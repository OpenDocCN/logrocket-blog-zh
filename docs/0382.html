<html>
<head>
<title>Creating a full-stack MERN app using JWT authentication: Part 1 - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>使用JWT认证创建全栈MERN应用程序:第1部分</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/mern-app-jwt-authentication-part-1/#0001-01-01">https://blog.logrocket.com/mern-app-jwt-authentication-part-1/#0001-01-01</a></blockquote><div><article class="article-post">
<p>我的绿地项目需要通常的歌舞:认证。我们的客户想要时髦一点，并且发现认证中的趋势技术是<a href="https://tools.ietf.org/html/rfc7519"> JWT (JSON Web Token) </a>，并且在将它用于所有认证目的时，压力很快就增大了。</p>
<p>作为一个反应快的人，我不介意在这上面工作和学习一项新技术，但是，是的——这就是为什么我在这里写我的经验。</p>
<p>我们正在构建一个与<a href="https://dotnet.microsoft.com/">对话的React前端。NET Core API服务器</a>。身份验证机制建立在JWT上。项目的. NET端。我正在使用React在前端实现JWT认证，现在开始。</p>
<p>另外，请注意，我没有添加任何MongoDB部分，但我称它为<a href="https://blog.logrocket.com/mern-stack-a-to-z-part-2/" target="_blank" rel="noopener noreferrer"> MERN堆栈应用程序</a>——抱歉。这不在本文的讨论范围之内。</p>
<h2>什么是JWT？</h2>
<p>JSON Web令牌是一种开放的、符合行业标准的RFC 7519方法，用于安全地表示双方之间的声明。一个<a href="https://blog.logrocket.com/jwt-authentication-best-practices/" target="_blank" rel="noopener noreferrer"> JWT </a>是一个<a href="https://www.json.org/"> JSON </a>响应，它在RFC 7519中被定义为一种在双方之间表示一组信息的安全方式。令牌由报头、有效载荷和签名组成。</p>
<p>简单地说，JWT就是以下格式的字符串:</p>
<figure class="wp-block-image"><img data-attachment-id="4073" data-permalink="https://blog.logrocket.com/mern-app-jwt-authentication-part-1/jwt-string-format/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2019/07/jwt-string-format.jpg" data-orig-size="730,198" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;1&quot;}" data-image-title="JWT string format" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2019/07/jwt-string-format-300x81.jpg" data-large-file="https://blog.logrocket.com/wp-content/uploads/2019/07/jwt-string-format.jpg" decoding="async" class="wp-image-4073 aligncenter jetpack-lazy-image" src="../Images/971cf6e0e4439d35271bc96857917b1d.png" alt="JWT String Format" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2019/07/jwt-string-format.jpg 730w, https://blog.logrocket.com/wp-content/uploads/2019/07/jwt-string-format-300x81.jpg 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2019/07/jwt-string-format.jpg?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/07/jwt-string-format.jpg"/><noscript><img data-lazy-fallback="1" data-attachment-id="4073" data-permalink="https://blog.logrocket.com/mern-app-jwt-authentication-part-1/jwt-string-format/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2019/07/jwt-string-format.jpg" data-orig-size="730,198" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;1&quot;}" data-image-title="JWT string format" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2019/07/jwt-string-format-300x81.jpg" data-large-file="https://blog.logrocket.com/wp-content/uploads/2019/07/jwt-string-format.jpg" decoding="async" loading="lazy" class="wp-image-4073 aligncenter" src="../Images/971cf6e0e4439d35271bc96857917b1d.png" alt="JWT String Format" srcset="https://blog.logrocket.com/wp-content/uploads/2019/07/jwt-string-format.jpg 730w, https://blog.logrocket.com/wp-content/uploads/2019/07/jwt-string-format-300x81.jpg 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/07/jwt-string-format.jpg"/></noscript><figcaption>JWT string format.</figcaption></figure>
<p>应该注意的是，双引号引起的字符串实际上被认为是有效的JSON响应:</p>
<pre>"header.payload.signature"</pre>
<h3>JWT流</h3>
<p>由于我们在基于微服务的架构中工作，我们有不同的微服务，其中一个是身份验证服务。这是后端服务之一。NET Core API，它基于域cookie中的引用令牌检索用户声明，并为该声明生成JWT。</p>
<p>如果返回有效的JWT，则调用被转发到相应的服务，并且JWT作为OAuth承载令牌在请求头中传递，以供后台服务进一步授权。</p>
<figure class="wp-block-image"><img data-attachment-id="4074" data-permalink="https://blog.logrocket.com/mern-app-jwt-authentication-part-1/jwt-auth-sequence/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2019/07/jwt-auth-sequence.jpg" data-orig-size="730,456" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;1&quot;}" data-image-title="JWT auth sequence" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2019/07/jwt-auth-sequence-300x187.jpg" data-large-file="https://blog.logrocket.com/wp-content/uploads/2019/07/jwt-auth-sequence.jpg" decoding="async" class="wp-image-4074 aligncenter jetpack-lazy-image" src="../Images/0343d7cb070f1c3eee02785006b12b40.png" alt="JWT Auth Sequence" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2019/07/jwt-auth-sequence.jpg 730w, https://blog.logrocket.com/wp-content/uploads/2019/07/jwt-auth-sequence-300x187.jpg 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2019/07/jwt-auth-sequence.jpg?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/07/jwt-auth-sequence.jpg"/><noscript><img data-lazy-fallback="1" data-attachment-id="4074" data-permalink="https://blog.logrocket.com/mern-app-jwt-authentication-part-1/jwt-auth-sequence/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2019/07/jwt-auth-sequence.jpg" data-orig-size="730,456" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;1&quot;}" data-image-title="JWT auth sequence" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2019/07/jwt-auth-sequence-300x187.jpg" data-large-file="https://blog.logrocket.com/wp-content/uploads/2019/07/jwt-auth-sequence.jpg" decoding="async" loading="lazy" class="wp-image-4074 aligncenter" src="../Images/0343d7cb070f1c3eee02785006b12b40.png" alt="JWT Auth Sequence" srcset="https://blog.logrocket.com/wp-content/uploads/2019/07/jwt-auth-sequence.jpg 730w, https://blog.logrocket.com/wp-content/uploads/2019/07/jwt-auth-sequence-300x187.jpg 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/07/jwt-auth-sequence.jpg"/></noscript><figcaption>JWT auth sequence represented in a flowchart.</figcaption></figure>
<p>使用下图可以简化上述顺序:</p>
<figure class="wp-block-image"><img data-attachment-id="4075" data-permalink="https://blog.logrocket.com/mern-app-jwt-authentication-part-1/simplified-jwt-auth-sequence/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2019/07/simplified-jwt-auth-sequence.jpg" data-orig-size="730,382" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;1&quot;}" data-image-title="Simplified JWT auth sequence" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2019/07/simplified-jwt-auth-sequence-300x157.jpg" data-large-file="https://blog.logrocket.com/wp-content/uploads/2019/07/simplified-jwt-auth-sequence.jpg" decoding="async" class="wp-image-4075 aligncenter jetpack-lazy-image" src="../Images/b14606ce85b5152f8c21a753ecf3340c.png" alt="Simplified JWT Auth Sequence" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2019/07/simplified-jwt-auth-sequence.jpg 730w, https://blog.logrocket.com/wp-content/uploads/2019/07/simplified-jwt-auth-sequence-300x157.jpg 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2019/07/simplified-jwt-auth-sequence.jpg?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/07/simplified-jwt-auth-sequence.jpg"/><noscript><img data-lazy-fallback="1" data-attachment-id="4075" data-permalink="https://blog.logrocket.com/mern-app-jwt-authentication-part-1/simplified-jwt-auth-sequence/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2019/07/simplified-jwt-auth-sequence.jpg" data-orig-size="730,382" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;1&quot;}" data-image-title="Simplified JWT auth sequence" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2019/07/simplified-jwt-auth-sequence-300x157.jpg" data-large-file="https://blog.logrocket.com/wp-content/uploads/2019/07/simplified-jwt-auth-sequence.jpg" decoding="async" loading="lazy" class="wp-image-4075 aligncenter" src="../Images/b14606ce85b5152f8c21a753ecf3340c.png" alt="Simplified JWT Auth Sequence" srcset="https://blog.logrocket.com/wp-content/uploads/2019/07/simplified-jwt-auth-sequence.jpg 730w, https://blog.logrocket.com/wp-content/uploads/2019/07/simplified-jwt-auth-sequence-300x157.jpg 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/07/simplified-jwt-auth-sequence.jpg"/></noscript><figcaption>Simplified representation of JWT auth sequence, courtesy of <a href="https://www.toptal.com/java/rest-security-with-jwt-spring-security-and-java%23jwt-authentication">TopTal</a>.</figcaption></figure>
<p>让我们现在开始构建类似的东西。</p>
<h2>先决条件</h2>
<p>正如我所说的，这是一个我们将要构建的MERN堆栈应用程序。显而易见的要求是:</p>

<p>我想现在够了。</p>
<h2>创建Express.js服务器</h2>
<p>下面是最简单的代码形式:<code>index.js</code>运行<code>node index</code>后，当你打开端口3000 上的<a href="http://localhost:3000/">本地主机时，浏览器上会显示<code>Hello World!</code>:</a></p>
<pre>const express = require("express");
const app = express();
const port = 3000;

app.get("/", (req, res) =&gt; res.send("Hello World!"));

app.listen(port, () =&gt; console.log(`Example app listening on port ${port}!`));</pre>
<h2>在服务器上生成JWT</h2>
<p>我们必须从基于JWT的认证开始，并尝试验证一些东西。jwt.io给出了支持jwt不同特性的不同库的列表。我试图找到一个支持一切的，但在JavaScript中没有。😔</p>
<p>让我们想想这里需要什么。后端应该能够支持算法HS512和RS512，因为这些是我们的一些银行客户推荐的。</p>
<h3>选择正确的库！</h3>
<p>我计划使用<code><a href="https://www.npmjs.com/package/jsrsasign" target="_blank" rel="noopener noreferrer">jsrsasign</a></code>，因为这是最接近我的后端团队生成的，并且它支持所有的算法。让我们以这种方式包含它们，但是不要忘记在运行代码之前在本地安装软件包:</p>
<pre>const JSRSASign = require("jsrsasign");</pre>
<h3>实现编码功能</h3>
<p>JWT有效载荷通常被称为声明——不知道为什么。所以让我们先创建一个<code>claims</code>:</p>
<pre>const claims = {
  Username: "praveen",
  Age: 27,
  Fullname: "Praveen Kumar"
}</pre>
<p>这就是我现在从Users DB中为我的应用程序所需要的一切。我在这里没有涉及任何数据库概念，所以我跳过了它们。接下来是私钥——顾名思义，让它保持私有，不要在任何客户端代码中使用它。</p>
<pre>const key = "$PraveenIsAwesome!";</pre>
<blockquote><p><strong>注意:</strong>绝对保密这个东西！🤐</p></blockquote>
<p>现在我们已经准备好了我们的<code>claims</code>和<code>key</code>。让我们开始签名并生成令牌。在签名之前，我们必须确定我们将使用哪种算法。这些细节将在标题中。所以，让我们创建一个标题。</p>
<pre>const header = {
  alg: "HS512",
  typ: "JWT"
};</pre>
<p>我们将使用HS512 (HMAC-SHA512)算法对令牌进行签名，并且我们将生成一个JWT。您可以生成的其他类型或现有标准有:</p>
<ul>
<li>JSON网络签名(JWS): <a href="https://tools.ietf.org/html/rfc7515"> RFC7515 </a></li>
<li>JSON网页加密(JWE): <a href="https://tools.ietf.org/html/rfc7516"> RFC7516 </a></li>
<li>JSON Web Key (JWK): <a href="https://tools.ietf.org/html/rfc7517"> RFC7517 </a></li>
<li>JSON网络算法(JWA)–<a href="https://tools.ietf.org/html/rfc7518">RFC 7518</a></li>
<li>JSON Web令牌(JWT): <a href="https://tools.ietf.org/html/rfc7519"> RFC7519 </a></li>
<li>JSON Web Key (JWK)指纹:<a href="https://tools.ietf.org/html/rfc7638"> RFC7638 </a></li>
<li>JWS未编码有效载荷选项:<a href="https://tools.ietf.org/html/rfc7797"> RFC7797 </a></li>
<li>CFRG椭圆曲线签名(EdDSA): <a href="https://tools.ietf.org/html/rfc8037"> RFC8037 </a></li>
</ul>
<p>让我们继续下一个生成令牌的主要过程。我们已经得到了我们所需要的一切:<code>header</code>、<code>payload</code> ( <code>claims</code>)和<code>key</code>。我们需要将上述对象字符串化并发送给生成器。</p>
<pre>var sHeader = JSON.stringify(header);
var sPayload = JSON.stringify(claims);</pre>
<p><code>key</code>已经是一个字符串了，所以不要费心将其字符串化。要生成密钥，我们应该将三个字符串和算法一起传递给<code>JSRSASign.jws.JWS.sign()</code>函数，如下所示:</p>
<pre>const sJWT = JSRSASign.jws.JWS.sign("HS512", sHeader, sPayload, key);</pre>
<p>您得到的输出是一个JWT！可以在<a href="https://jwt.io/"> jwt.io </a>验证正确性。最后，将字符串记录到控制台将得到输出:</p>
<pre>console.log(sJWT);</pre>
<p>当我执行上面的代码时，我得到了这个:</p>
<pre>​​eyJhbGciOiJIUzUxMiIsInR5cCI6IkpXVCJ9.eyJVc2VybmFtZSI6InByYXZlZW4iLCJBZ2UiOjI3LCJGdWxsbmFtZSI6IlByYXZlZW4gS3VtYXIifQ.Nut6I57FYUGP973LgfOUNUBjMlaIm6NKk8ffgX4BTdQ_Wc2ob8m6uOwWlgoNMxpuRQaOoeFQOHhrIOJ_V8E-YA</pre>
<p>将它和我的签名一起放入在线验证器，我得到了相同的输出，其中包含一条经过签名验证的消息:</p>
<figure class="wp-block-image"><img data-attachment-id="4433" data-permalink="https://blog.logrocket.com/mern-app-jwt-authentication-part-1/signature-verified/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2019/07/signature-verified.png" data-orig-size="1188,896" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Signature verified" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2019/07/signature-verified-300x226.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2019/07/signature-verified-1024x772.png" decoding="async" class="alignnone size-full wp-image-4433 jetpack-lazy-image" src="../Images/d4960a2fc34f576b5d23a11132ddc513.png" alt="Signature Verified" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2019/07/signature-verified.png 1188w, https://blog.logrocket.com/wp-content/uploads/2019/07/signature-verified-300x226.png 300w, https://blog.logrocket.com/wp-content/uploads/2019/07/signature-verified-768x579.png 768w, https://blog.logrocket.com/wp-content/uploads/2019/07/signature-verified-1024x772.png 1024w" data-lazy-sizes="(max-width: 1188px) 100vw, 1188px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2019/07/signature-verified.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/07/signature-verified.png"/><noscript><img data-lazy-fallback="1" data-attachment-id="4433" data-permalink="https://blog.logrocket.com/mern-app-jwt-authentication-part-1/signature-verified/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2019/07/signature-verified.png" data-orig-size="1188,896" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Signature verified" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2019/07/signature-verified-300x226.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2019/07/signature-verified-1024x772.png" decoding="async" loading="lazy" class="alignnone size-full wp-image-4433" src="../Images/d4960a2fc34f576b5d23a11132ddc513.png" alt="Signature Verified" srcset="https://blog.logrocket.com/wp-content/uploads/2019/07/signature-verified.png 1188w, https://blog.logrocket.com/wp-content/uploads/2019/07/signature-verified-300x226.png 300w, https://blog.logrocket.com/wp-content/uploads/2019/07/signature-verified-768x579.png 768w, https://blog.logrocket.com/wp-content/uploads/2019/07/signature-verified-1024x772.png 1024w" sizes="(max-width: 1188px) 100vw, 1188px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/07/signature-verified.png"/></noscript><figcaption>Signature verified.</figcaption></figure>
<p>呜哇！你可以在这里查看<a href="https://jwt.io%2F%23debugger-io%3Ftoken%3DeyJhbGciOiJIUzUxMiIsInR5cCI6IkpXVCJ9.eyJVc2VybmFtZSI6InByYXZlZW4iLCJQYXNzd29yZCI6IlByQHYzM24iLCJGdWxsbmFtZSI6IlByYXZlZW4gS3VtYXIifQ.nsE9yzUct5vdoNjFZ-2P48vFLGld5-Wr1tne8P3P9eZyCtrRPDSR7dJ8myg30sSV0kcRJVGogzTI92NpOo5pPw">。</a></p>
<h2>解码和验证JWT</h2>
<p>第一步是在解码和了解令牌中的内容之前验证令牌。只有在确保令牌未被篡改并且使用相同的私钥进行了签名时，才需要进行验证。<strong>这不应该在客户端进行。</strong>我们先通过实现验证函数来尝试解码JSON Web Token，然后我们再解码。</p>
<h3>实现验证功能</h3>
<p>既然我们已经基于我的后端团队使用的相同算法成功地生成了令牌，那么让我们尝试验证它并验证它是否有效。为了验证令牌，我们只需要<code>algorithm</code>、<code>key</code>和生成的<code>token</code>。让我们继续干吧。</p>
<pre>const token = "eyJhbGciOiJIUzUxMiIsInR5cCI6IkpXVCJ9.eyJVc2VybmFtZSI6InByYXZlZW4iLCJBZ2UiOjI3LCJGdWxsbmFtZSI6IlByYXZlZW4gS3VtYXIifQ.Nut6I57FYUGP973LgfOUNUBjMlaIm6NKk8ffgX4BTdQ_Wc2ob8m6uOwWlgoNMxpuRQaOoeFQOHhrIOJ_V8E-YA";
const algorithm = "HS512";
const key = "$PraveenIsAwesome!";</pre>
<p>语法有点奇怪——原因是，验证器可以尝试在任何算法中进行验证，所以它需要一组算法。上述信息将被传递给<code>JSRSASign.jws.JWS.verifyJWT()</code>函数，该函数接受<code>token</code>、<code>key</code>和<code>{"alg": [ algorithm ]}</code>，语法如下:</p>
<pre>console.log(
  JSRSASign.jws.JWS.verifyJWT(token, key, {
    alg: [algorithm]
  })
);</pre>
<p>在控制台上，当我运行这个命令时，我得到了以下结果:</p>
<pre>true</pre>
<p>啊，那是一个甜蜜的成功。现在让我们继续解码令牌。解码部分真的很容易；甚至客户端的浏览器也可以做到这一点，这就是为什么我的客户更喜欢在React这样的单页面应用程序框架中安全可靠地传输声明对象。</p>
<h3>实现解码功能</h3>
<p>为了解码JSON Web令牌，我们将只传递令牌的第二部分。这包含有效载荷，或<code>claims</code>。我们还需要算法，可以从令牌的第一部分获取。</p>
<p>我们需要做的第一件事是分割<code>.</code>上的令牌，然后将它转换成一个数组，并获得<code>Header</code>和<code>Claim</code>:</p>
<pre>const aJWT = sJWS.split(".");
const uHeader = JSRSASign.b64utos(aJWT[0]);
const uClaim = JSRSASign.b64utos(aJWT[1]);</pre>
<p>让我们将它们设为<code>uHeader</code>和<code>uClaim</code>，因为此时它们是不可信的。现在让我们解析它们。<code>JSRSASign.b64utos()</code>将不受信任的Base64转换成字符串，由同一个库提供。我们现在将使用函数<code>JSRSASign.jws.JWS.readSafeJSONString()</code>，它类似于<code>JSON.parse()</code>，但是有更多的异常处理机制。</p>
<pre>const pHeader = JSRSASign.jws.JWS.readSafeJSONString(uHeader);
const pClaim = JSRSASign.jws.JWS.readSafeJSONString(uClaim);</pre>
<p>现在我们已经得到了解析后的头和声明。让我们尝试记录它们并查看输出。</p>
<pre>console.log(pHeader);
console.log(pClaim);</pre>
<p>呜哇！我们这里有解码版本。</p>
<pre>{
  "alg": "HS512",
  "typ": "JWT"
}
{
  "Username": "praveen",
  "Age": 27,
  "Fullname": "Praveen Kumar"
}</pre>
<p>开始了。现在我们可以用这种方式安全地访问有效载荷(至少不是明文形式的)!👍🏻</p>
<h2>完整的代码和下一部分</h2>
<p>下面是完整的代码，包括签名、生成、确认、验证和解码！😇</p>
<pre>const JSRSASign = require("jsrsasign");

// Generation
const claims = {
  Username: "praveen",
  Age: 27,
  Fullname: "Praveen Kumar"
};
const key = "$PraveenIsAwesome!";
const header = {
  alg: "HS512",
  typ: "JWT"
};

const sHeader = JSON.stringify(header);
const sPayload = JSON.stringify(claims);
// Generate the JWT
const sJWT = JSRSASign.jws.JWS.sign("HS512", sHeader, sPayload, key);
// Log it to the console.
console.log("JSON Web Token: ", sJWT);

const token =
  "eyJhbGciOiJIUzUxMiIsInR5cCI6IkpXVCJ9.eyJVc2VybmFtZSI6InByYXZlZW4iLCJBZ2UiOjI3LCJGdWxsbmFtZSI6IlByYXZlZW4gS3VtYXIifQ.Nut6I57FYUGP973LgfOUNUBjMlaIm6NKk8ffgX4BTdQ_Wc2ob8m6uOwWlgoNMxpuRQaOoeFQOHhrIOJ_V8E-YA";
const algorithm = "HS512";

// Log it to the console.
console.log(
  "Verification: ",
  // Validation
  JSRSASign.jws.JWS.verifyJWT(token, key, {
    alg: [algorithm]
  })
);

// Decoding
const sJWS = token;
const aJWT = sJWS.split(".");
const uHeader = JSRSASign.b64utos(aJWT[0]);
const uClaim = JSRSASign.b64utos(aJWT[1]);
const pHeader = JSRSASign.jws.JWS.readSafeJSONString(uHeader);
const pClaim = JSRSASign.jws.JWS.readSafeJSONString(uClaim);
// Decoded objects.
// Log it to the console.
console.log("Header: ", pHeader);
console.log("Claim: ", pClaim);</pre>
<p>上面的代码会给出这样的输出:</p>
<pre>➜  MockAPIServer node dec-enc.js
JSON Web Token:  eyJhbGciOiJIUzUxMiIsInR5cCI6IkpXVCJ9.eyJVc2VybmFtZSI6InByYXZlZW4iLCJBZ2UiOjI3LCJGdWxsbmFtZSI6IlByYXZlZW4gS3VtYXIifQ.Nut6I57FYUGP973LgfOUNUBjMlaIm6NKk8ffgX4BTdQ_Wc2ob8m6uOwWlgoNMxpuRQaOoeFQOHhrIOJ_V8E-YA
Verification:  true
Header: { alg: 'HS512', typ: 'JWT' }
Claim: { Username: 'praveen',
  Age: 27,
  Fullname: 'Praveen Kumar' }</pre>
<p>顺便说一下，我所做的只是一个服务器端生成组件，并不包括使用POST请求向您发送令牌的“web服务器”。</p>
<p>现在我们已经完成了服务器端的工作，让我们开始<a href="https://blog.logrocket.com/mern-app-jwt-authentication-part-2/" target="_blank" rel="noopener noreferrer">构建REST API端点，供客户端在第二部分中使用</a>！</p><div class="code-block code-block-17">
<div class="blog-plug inline-plug react-plug" vwo-el-id="26283398190">
<h2 vwo-el-id="41600691720"><a href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener"> LogRocket </a>:全面了解您的生产React应用</h2><p>调试React应用程序可能很困难，尤其是当用户遇到难以重现的问题时。如果您对监视和跟踪Redux状态、自动显示JavaScript错误以及跟踪缓慢的网络请求和组件加载时间感兴趣，</p><a href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" vwo-el-id="19356441070">try LogRocket</a><p>. </p><a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="19356441380">
<img class="first-react-image alignnone size-full wp-image-46 jetpack-lazy-image jetpack-lazy-image--handled" src="../Images/f300c244a1a1cf916df8b4cb02bec6c6.png" vwo-el-id="18272717540" data-lazy-loaded="1" data-original-src="https://files.readme.io/27c94e7-Image_2017-06-05_at_9.46.04_PM.png"/>
</a>
<a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="19356441690">
<img class="second-react-image alignnone size-full wp-image-46 jetpack-lazy-image jetpack-lazy-image--handled" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" vwo-el-id="30720362350" data-lazy-loaded="1" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/>
</a>
<p vwo-el-id="28675660440" class="">LogRocket 结合了会话回放、产品分析和错误跟踪，使软件团队能够创建理想的web和移动产品体验。这对你来说意味着什么？</p>
<p>LogRocket不是猜测错误发生的原因，也不是要求用户提供截图和日志转储，而是让您回放问题，就像它们发生在您自己的浏览器中一样，以快速了解哪里出错了。</p>
<p>不再有嘈杂的警报。智能错误跟踪允许您对问题进行分类，然后从中学习。获得有影响的用户问题的通知，而不是误报。警报越少，有用的信号越多。</p>
<p vwo-el-id="28675660750">LogRocket Redux中间件包为您的用户会话增加了一层额外的可见性。LogRocket记录Redux存储中的所有操作和状态。</p>
<p vwo-el-id="28675661060">现代化您调试React应用的方式— <a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="40093418840">开始免费监控</a>。</p>
</div></div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
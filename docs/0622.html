<html>
<head>
<title>A complete guide to React refs - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>React refs - LogRocket博客完全指南</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/complete-guide-react-refs/#0001-01-01">https://blog.logrocket.com/complete-guide-react-refs/#0001-01-01</a></blockquote><div><article class="article-post">
<p><em> <strong>编者按</strong>:本帖于2023年2月23日更新，添加了交互式代码示例，更新了任何过时的信息，并包含了React引用的用例。查看我们的<a href="https://blog.logrocket.com/react-hooks-cheat-sheet-solutions-common-problems/"> React Hooks备忘单</a>，了解更多关于React Hooks的信息。</em></p>
<p>与许多其他UI库一样，React提供了一种方式，将视图作为组件状态的结果进行重新思考。这与我们通常构建应用程序的方式有很大的不同。当我们熟悉其中一些概念时，我们会发现在前端世界中解决曾经给我们带来麻烦的简单问题是多么容易。这种好处的一部分来自于创建具有抽象机制的视图，这些抽象机制由JSX公开，而不是通过DOM spec方法来实现。</p>
<p>尽管如此，React团队还是做了一些聪明的事情:他们提供了逃生出口。他们对超出他们特别设计的情况和模型可能不工作的情况保持库开放。我们将在本文后面讨论反模式。</p>
<p>这些escape hatches是refs，它允许我们直接访问DOM属性。通常，React通过为我们重新呈现组件来使用状态更新屏幕上的数据。但是，在某些情况下，您需要直接处理DOM属性，这就是refs发挥作用的地方。</p>
<p>一个例子是当组件呈现时自动聚焦文本框。React没有提供一种简单的方法来做到这一点，所以我们可以使用refs来直接访问DOM，并在组件呈现在屏幕上时聚焦文本框。</p>
<p>在本文中，我们将研究React(一个旨在将代码从DOM操作中抽象出来的框架)为什么为开发人员打开了访问它的大门。</p>
<p><em>向前跳转:</em></p>

<h2 id="creating-refs">创建参考</h2>
<p>过去使用基于类的组件时，我们使用<code>createRef()</code>来创建一个ref。不过，既然React推荐了<a href="https://blog.logrocket.com/what-are-react-pure-functional-components/">功能组件</a>，而且一般的做法是<a href="https://blog.logrocket.com/refactor-react-components-hooks/">跟着钩子的方式</a>做事，我们就没必要用<code>createRef()</code>。相反，我们使用<code>useRef(null)</code>在功能组件中创建引用。</p>
<p>正如简介中所说，引用是React开发人员的逃生出口，如果可能的话，我们应该尽量避免使用它们。当我们使用<code>ref</code>获得一个节点，然后修改它的一些属性或DOM结构时，它可能会与React的diff和update方法发生冲突。</p>
<p>首先，让我们从一个简单的组件开始，使用refs获取一个节点元素:</p>
<pre class="language-jsx hljs">import React from "react";
const ActionButton = ({ label, action }) =&gt; {
  return &lt;button onClick={action}&gt;{label}&lt;/button&gt;;
};
export default ActionButton;
</pre>
<p>这里的<code>&lt;button&gt;</code>表达式是调用<code>React.createElement('button')</code>语句的JSX方式，它不是HTML按钮元素的表示——它是一个React元素。</p>
<p>您可以通过创建一个React引用并将其传递给元素本身来访问实际的<a href="https://blog.logrocket.com/type-html-faster-react-emmet-vs-code/"> HTML元素</a>:</p>
<pre class="language-jsx hljs">import React, { useRef } from "react";
const ActionButton = ({ label, action }) =&gt; {
  const buttonRef = useRef(null);
  return (
    &lt;button onClick={action} ref={buttonRef}&gt;
      {label}
    &lt;/button&gt;
  );
};
export default ActionButton;
</pre>
<p>这样，在组件生命周期的任何时候，我们都可以在<code>buttonRef.current</code>访问实际的HTML元素。现在，我们知道了如何访问React组件中的DOM节点。让我们看看这可能有用的一些情况。</p>
<h3 id="useref-vs-create-ref"><code>useRef</code>和<code>createRef</code>的区别</h3>
<p><code>useRef</code>和<code>createRef</code>的第一个区别是<code>createRef</code>通常用于在类组件中创建引用，而<code>useRef</code>用于函数组件中。此外，<code>createRef</code>每次被调用都会返回一个新的ref对象，而<code>useRef</code>每次渲染都会返回相同的ref对象。</p>
<p>另一个主要区别是<code>createRef</code>不接受初始值，所以ref的<code>current</code>属性将被初始设置为<code>null</code>。另一方面，<code>useRef</code>可以接受一个初始值，ref的<code>current</code>属性将被设置为该值。</p>
<h2 id="using-react-refs">使用反应引用</h2>
<p>React在开发人员中流行的许多概念之一是<a href="https://blog.logrocket.com/solidjs-vs-react/">声明性视图</a>的概念。在声明式视图出现之前，我们大多数人通过调用显式改变DOM的函数来修改它。正如本文介绍中提到的，我们现在基于状态声明视图，并且——尽管我们仍在调用函数来改变这种状态——我们无法控制DOM何时会改变或者是否应该改变。</p>
<p>因为这种控制的倒置，如果没有裁判，我们就会失去这种命令性。下面是一些在代码中引入引用可能有意义的用例。</p>
<h3 id="focus-control">聚焦控制</h3>
<p>您可以通过调用节点实例上的<code>focus()</code>以编程方式在元素中获得焦点。因为DOM将此公开为函数调用，所以在React中最好的方法是创建一个ref，并在我们认为合适的时候手动执行，如下所示:</p>
<pre class="language-jsx hljs">import React, { useState } from "react";
const InputModal = ({ initialValue }) =&gt; {
  const [value, setValue] = useState(initialValue);
  const onChange = (e) =&gt; {
    setValue(e.target.value);
  };
  const onSubmit = (e) =&gt; {
    e.preventDefault();
  };
  return (
    &lt;div className="modal--overlay"&gt;
      &lt;div className="modal"&gt;
        &lt;h1&gt;Insert a new value&lt;/h1&gt;
        &lt;form action="?" onSubmit={onSubmit}&gt;
          &lt;input type="text" onChange={onChange} value={value} /&gt;
          &lt;button&gt;Save new value&lt;/button&gt;
        &lt;/form&gt;
      &lt;/div&gt;
    &lt;/div&gt;
  );
};
export default InputModal;
</pre>
<p>在这种模式下，我们允许用户修改已经在下面的屏幕中设置的值。如果模式打开时输入是焦点，这将是一个更好的UX T2，这将使两个屏幕之间的键盘平滑过渡。我们需要做的第一件事是为<code>input</code>获取一个参考:</p>
<pre class="language-jsx hljs">import React, { useRef, useState } from "react";
const InputModal = ({ initialValue }) =&gt; {
  const [value, setValue] = useState(initialValue);
  const inputRef = useRef(null);
  const onChange = (e) =&gt; {
    setValue(e.target.value);
  };
  const onSubmit = (e) =&gt; {
    e.preventDefault();
  };
  return (
    &lt;div className="modal--overlay"&gt;
      &lt;div className="modal"&gt;
        &lt;h1&gt;Insert a new value&lt;/h1&gt;
        &lt;form action="?" onSubmit={onSubmit}&gt;
          &lt;input ref={inputRef} type="text" onChange={onChange} value={value} /&gt;
          &lt;button&gt;Save new value&lt;/button&gt;
        &lt;/form&gt;
      &lt;/div&gt;
    &lt;/div&gt;
  );
};
export default InputModal;
</pre>
<p>接下来，当我们的<code>modal</code>挂载时，我们必须在<code>useEffect</code>内调用<code>input ref</code>上的<code>focus</code>:</p>
<pre class="language-jsx hljs">import React, { useEffect, useRef, useState } from "react";
const InputModal = ({ initialValue }) =&gt; {
  const [value, setValue] = useState(initialValue);
  const inputRef = useRef(null);
  useEffect(() =&gt; {
    inputRef.current.focus();
  }, [])
  const onChange = (e) =&gt; {
    setValue(e.target.value);
  };
  const onSubmit = (e) =&gt; {
    e.preventDefault();
  };
  return (
    &lt;div className="modal--overlay"&gt;
      &lt;div className="modal"&gt;
        &lt;h1&gt;Insert a new value&lt;/h1&gt;
        &lt;form action="?" onSubmit={onSubmit}&gt;
          &lt;input ref={inputRef} type="text" onChange={onChange} value={value} /&gt;
          &lt;button&gt;Save new value&lt;/button&gt;
        &lt;/form&gt;
      &lt;/div&gt;
    &lt;/div&gt;
  );
};
export default InputModal;
</pre>
<p>因此，当您打开<code>modal</code>时，您应该会看到文本框在默认情况下被聚焦:</p>
<p><img data-attachment-id="162748" data-permalink="https://blog.logrocket.com/complete-guide-react-refs/attachment/opened-modal-react-useref/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/01/opened-modal-react-useref.png" data-orig-size="730,364" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Opening a modal focuses the text box" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/01/opened-modal-react-useref-300x150.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/01/opened-modal-react-useref.png" decoding="async" class="aligncenter size-full wp-image-162748 jetpack-lazy-image" src="../Images/d22f6d7fba75675461cb668f435110cc.png" alt="Opening a Modal Focuses the Text Box" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2022/01/opened-modal-react-useref.png 730w, https://blog.logrocket.com/wp-content/uploads/2022/01/opened-modal-react-useref-300x150.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2022/01/opened-modal-react-useref.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/01/opened-modal-react-useref.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="162748" data-permalink="https://blog.logrocket.com/complete-guide-react-refs/attachment/opened-modal-react-useref/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/01/opened-modal-react-useref.png" data-orig-size="730,364" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Opening a modal focuses the text box" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/01/opened-modal-react-useref-300x150.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/01/opened-modal-react-useref.png" decoding="async" loading="lazy" class="aligncenter size-full wp-image-162748" src="../Images/d22f6d7fba75675461cb668f435110cc.png" alt="Opening a Modal Focuses the Text Box" srcset="https://blog.logrocket.com/wp-content/uploads/2022/01/opened-modal-react-useref.png 730w, https://blog.logrocket.com/wp-content/uploads/2022/01/opened-modal-react-useref-300x150.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/01/opened-modal-react-useref.png"/></noscript>
<p>请记住，您需要通过<code>current</code>属性来访问元素。</p>
<p>上面的例子有一个CodeSandbox:</p>
<p/>
<h3 id="element-contained">检测是否包含元素</h3>
<p>类似地，您想知道是否有任何调度事件的元素应该触发您的应用程序上的一些动作。例如，如果用户在组件外单击，我们的<code>modal</code>组件可能会被关闭，如下所示:</p>
<pre class="language-jsx hljs">import React, { useEffect, useRef, useState } from "react";
const InputModal = ({ initialValue, onClose, onSubmit }) =&gt; {
  const [value, setValue] = useState(initialValue);
  const inputRef = useRef(null);
  const modalRef = useRef(null);
  useEffect(() =&gt; {
    inputRef.current.focus();
    document.body.addEventListener("click", onClickOutside);
    return () =&gt; document.removeEventListener("click", onClickOutside);
  }, []);
  const onClickOutside = (e) =&gt; {
    const element = e.target;
    if (modalRef.current &amp;&amp; !modalRef.current.contains(element)) {
      e.preventDefault();
      e.stopPropagation();
      onClose();
    }
  };
  const onChange = (e) =&gt; {
    setValue(e.target.value);
  };
  const onSub = (e) =&gt; {
    e.preventDefault();
    onSubmit(value);
    onClose();
  };
  return (
    &lt;div className="modal--overlay"&gt;
      &lt;div className="modal" ref={modalRef}&gt;
        &lt;h1&gt;Insert a new value&lt;/h1&gt;
        &lt;form action="?" onSubmit={onSub}&gt;
          &lt;input ref={inputRef} type="text" onChange={onChange} value={value} /&gt;
          &lt;button&gt;Save new value&lt;/button&gt;
        &lt;/form&gt;
      &lt;/div&gt;
    &lt;/div&gt;
  );
};
export default InputModal;
</pre>
<p>这里，我们检查元素<code>click</code>是否在<code>modal</code>限制之外。它是这样工作的:</p>
<p><img data-attachment-id="162752" data-permalink="https://blog.logrocket.com/complete-guide-react-refs/attachment/check-element-click-react-useref/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/01/check-element-click-react-useref.gif" data-orig-size="730,271" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Checking the element click in React" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/01/check-element-click-react-useref-300x111.gif" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/01/check-element-click-react-useref.gif" decoding="async" class="aligncenter size-full wp-image-162752 jetpack-lazy-image" src="../Images/b60417d185216e532ac70c0ee15a7037.png" alt="Checking the Element Click in React" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2022/01/check-element-click-react-useref.gif?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/01/check-element-click-react-useref.gif"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="162752" data-permalink="https://blog.logrocket.com/complete-guide-react-refs/attachment/check-element-click-react-useref/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/01/check-element-click-react-useref.gif" data-orig-size="730,271" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Checking the element click in React" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/01/check-element-click-react-useref-300x111.gif" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/01/check-element-click-react-useref.gif" decoding="async" loading="lazy" class="aligncenter size-full wp-image-162752" src="../Images/b60417d185216e532ac70c0ee15a7037.png" alt="Checking the Element Click in React" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/01/check-element-click-react-useref.gif"/></noscript>
<p>如果是，那么我们将阻止进一步的动作并调用<code>onClose</code>回调，因为<code>modal</code>组件期望由其父组件控制。记得检查DOM元素的当前引用是否仍然存在，因为React中的状态变化是异步的。为了实现这一点，我们在<code>body</code>元素上添加了一个<a href="https://blog.logrocket.com/detect-click-outside-react-component-how-to/">全局点击监听器</a>。当元件被卸载时，记住清理<code>listener</code>是很重要的。</p>
<h3 id="integrating-dom">与基于DOM的库集成</h3>
<p>与React一样好的是，其生态系统之外的许多实用程序和库已经在web上使用了很多年。例如，使用refs允许我们将React与一个伟大的动画库结合起来。利用他们的稳定性和对一些特定问题的解决是很好的。</p>
<p>GSAP图书馆是动画示例的热门选择。要使用它，我们需要向它的任何方法发送一个<code>DOM</code>元素。让我们回到我们的模式，并添加一些动画，使其外观更花哨:</p>
<pre class="language-jsx hljs">import React, { useEffect, useRef, useState } from "react";
import gsap from "gsap";
const InputModal = ({ initialValue, onClose, onSubmit }) =&gt; {
  const [value, setValue] = useState(initialValue);
  const inputRef = useRef(null);
  const modalRef = useRef(null);
  const overlayRef = useRef(null);
  const onComplete = () =&gt; {
    inputRef.current.focus();
  };
  const timeline = gsap.timeline({ paused: true, onComplete });
  useEffect(() =&gt; {
    timeline
      .from(overlayRef.current, {
        duration: 0.25,
        autoAlpha: 0,
      })
      .from(modalRef.current, {
        duration: 0.25,
        autoAlpha: 0,
        y: 25,
      });
    timeline.play();
    document.body.addEventListener("click", onClickOutside);
    return () =&gt; {
      timeline.kill();
      document.removeEventListener("click", onClickOutside);
    };
  }, []);
  const onClickOutside = (e) =&gt; {
    const element = e.target;
    if (modalRef.current &amp;&amp; !modalRef.current.contains(element)) {
      e.preventDefault();
      e.stopPropagation();
      onClose();
    }
  };
  const onChange = (e) =&gt; {
    setValue(e.target.value);
  };
  const onSub = (e) =&gt; {
    e.preventDefault();
    onSubmit(value);
    onClose();
  };
  return (
    &lt;div className="modal--overlay" ref={overlayRef}&gt;
      &lt;div className="modal" ref={modalRef}&gt;
        &lt;h1&gt;Insert a new value&lt;/h1&gt;
        &lt;form action="?" onSubmit={onSub}&gt;
          &lt;input ref={inputRef} type="text" onChange={onChange} value={value} /&gt;
          &lt;button&gt;Save new value&lt;/button&gt;
        &lt;/form&gt;
      &lt;/div&gt;
    &lt;/div&gt;
  );
};
export default InputModal;
</pre>
<p><img data-attachment-id="162754" data-permalink="https://blog.logrocket.com/complete-guide-react-refs/attachment/animations-react/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/01/animations-react.gif" data-orig-size="730,300" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Adding animations to our React modal" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/01/animations-react-300x123.gif" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/01/animations-react.gif" decoding="async" class="aligncenter size-full wp-image-162754 jetpack-lazy-image" src="../Images/88264c83816d18d8180b8610b123ec3b.png" alt="Adding Animations to Our React Modal" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2022/01/animations-react.gif?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/01/animations-react.gif"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="162754" data-permalink="https://blog.logrocket.com/complete-guide-react-refs/attachment/animations-react/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/01/animations-react.gif" data-orig-size="730,300" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Adding animations to our React modal" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/01/animations-react-300x123.gif" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/01/animations-react.gif" decoding="async" loading="lazy" class="aligncenter size-full wp-image-162754" src="../Images/88264c83816d18d8180b8610b123ec3b.png" alt="Adding Animations to Our React Modal" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/01/animations-react.gif"/></noscript>
<p>在构造函数级别，我们正在设置初始动画值，这将修改我们的DOM引用的样式。时间轴仅在组件安装时播放。当元素被卸载时，我们将通过使用由<code>Timeline</code>实例提供的<code>kill()</code>方法终止任何正在进行的动画来清理DOM状态和动作。</p>
<p>现在，在<code>timeline</code>完成后，我们将把注意力转向<code>input</code>。</p>
<h3 id="use-useref-hook">什么时候应该使用<code>useRef</code>钩子？</h3>
<p>在某些情况下，您可能会想要使用<code>useRef</code>钩子，包括以下情况:</p>
<ul>
<li>访问DOM元素:当需要与组件中的特定DOM元素交互时，可以使用<code>useRef</code>钩子，比如将焦点设置在输入字段上或者测量元素的大小</li>
<li>存储不会触发重新渲染的值:当你有一个频繁变化但不会触发重新渲染的值时，你可以使用<code>useRef</code>来存储这个值。例如，如果您的组件中有一个计时器，您可以使用<code>useRef</code>来存储当前时间，而无需触发重新渲染</li>
<li>缓存昂贵的计算:如果你需要避免在每次渲染时重复昂贵的计算，你可以使用<code>useRef</code>来存储计算的结果</li>
</ul>
<h2 id="avoid-anti-pattern">避免React ref反模式</h2>
<p>一旦你知道了引用是如何工作的，就很容易在不需要的地方使用它们。在React组件中有不止一种方法可以实现同样的事情，所以很容易陷入<a href="https://blog.logrocket.com/product-management/strategic-roadmap-examples-antipatterns/">反模式</a>。关于引用的使用，我的原则是:只有当你需要强制调用React不允许你控制的行为的函数时，才使用引用。</p>
<p>更简单的说法是，当您需要调用一个函数，而该函数与React方法或工件没有关联时，使用ref。让我们探索一个我反复看到的反模式:</p>
<pre class="language-jsx hljs">import React, { useRef } from "react";
const Form = () =&gt; {
  const [storedValue, setStoredValue] = useState("");
  const inputRef = useRef(null);
  const onSubmit = (e) =&gt; {
    e.preventDefault();
    setStoredValue(inputRef.current.value);
  };
  return (
    &lt;div className="modal"&gt;
      &lt;form action="?" onSubmit={onSubmit}&gt;
        &lt;input ref={inputRef} type="text" /&gt;
        &lt;button&gt;Submit&lt;/button&gt;
      &lt;/form&gt;
    &lt;/div&gt;
  );
};
</pre>
<p>公平地说，如果你想在<code>submit</code>上发送一个<code>value</code>，这种方法是可行的，但是这里的问题是，因为我们知道refs提供了一个视图模型React提供的出口，我们可以很容易地嗅探到DOM元素值或属性，我们可以通过React的接口访问它们。控制<code>input</code>值意味着我们可以随时检查它的值。我们不需要在这里使用refs来访问文本框的值。我们可以使用React本身提供的值:</p>
<pre class="language-jsx hljs">return (
  &lt;input
    type="text"
    onChange={e =&gt; setValue(e.target.value)}
    value={value}
  /&gt;
)
</pre>
<p>让我们回到我们的规则:只有当你需要强制调用React不允许你控制的行为的函数时，才使用ref。在我们的uncontrolled <code>input</code>中，我们创建了一个ref，但没有进行命令式调用。那么，这个函数应该存在，这是不满足的，因为我确实可以控制一个输入的值。</p>
<h2 id="using-forwardref">使用<code>forwardRef</code></h2>
<p>正如我们已经讨论过的，引用对于真正特定的动作是有用的。所示的例子比我们现在通常在web应用程序代码库中找到的要简单一些。组件更复杂，我们很少直接使用普通的HTML元素。包含多个节点来封装视图行为的更多逻辑是很常见的。这里有一个例子:</p>
<pre class="language-jsx hljs">import React from 'react'

const LabelledInput = (props) =&gt; {
  const { id, label, value, onChange } = props

  return (
    &lt;div class="labelled--input"&gt;
      &lt;label for={id}&gt;{label}&lt;/label&gt;
      &lt;input id={id} onChange={onChange} value={value} /&gt;
    &lt;/div&gt;
  )
}

export default LabelledInput
</pre>
<p>现在的问题是，传递对这个组件的引用将返回它的实例，一个React组件引用，而不是我们想要关注的<code>input</code>元素，就像我们的第一个例子一样。幸运的是，React为此提供了一个名为<code><a href="https://blog.logrocket.com/cleaning-up-the-dom-with-forwardref-in-react/">forwardRef</a></code>的内置解决方案，允许您在内部定义<code>ref</code>将指向的元素:</p>
<pre class="language-jsx hljs">import React from 'react'

const LabelledInput = (props, ref) =&gt; {
  const { id, label, value, onChange } = props

  return (
    &lt;div class="labelled--input"&gt;
      &lt;label for={id}&gt;{label}&lt;/label&gt;
      &lt;input id={id} onChange={onChange} value={value} ref={ref}/&gt;
    &lt;/div&gt;
  )
}

export default React.forwardRef(LabelledInput)
</pre>
<p>请看这个<a href="https://codesandbox.io/s/input-modal-example-l2wst?module=%2Fsrc%2Flabelled-input.js">例子中的动作</a>:</p>
<p/>
<p>为此，我们将向函数传递第二个参数，并将其放在所需的元素中。现在，当父组件传递一个<code>ref</code>值时，它将获得<code>input</code>，这有助于避免暴露组件的内部和属性并破坏其封装。我们的形式的例子，我们看到未能实现焦点，现在将按预期工作。</p>
<h2>结论</h2>
<p>我们首先回顾了React的基本概念及其用法，为什么我们通常不应该打破框架的模型，以及为什么我们有时可能需要这样做。通过库公开的接口访问DOM有助于维护React的内部结构(记住<code>useState</code>包含的逻辑不仅仅是触发重新渲染循环，比如批处理更新，以及未来的时间片)。</p>
<p>用反模式破坏这种模型会使库中后来的性能改进变得无用，甚至会在应用程序中产生bug。请记住，只有当React无法通过其方法处理隐式函数调用时，才使用refs。此外，确保它不会改变组件的内部状态。欲了解更多信息，请阅读关于参考文献的官方React文档。</p>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
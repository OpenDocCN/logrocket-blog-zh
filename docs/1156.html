<html>
<head>
<title>JSON and Rust: Why serde_json is the top choice - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>JSON和Rust:为什么serde_json是首选</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/json-and-rust-why-serde_json-is-the-top-choice/#0001-01-01">https://blog.logrocket.com/json-and-rust-why-serde_json-is-the-top-choice/#0001-01-01</a></blockquote><div><article class="article-post">
<p>JSON已经成为web上最常见的数据交换格式之一，所以服务器端语言对它的良好支持是至关重要的。幸运的是，处理JSON是一个容易生锈的领域，这在很大程度上要感谢<a href="https://crates.io/crates/serde" target="_blank" rel="noopener noreferrer"> serde </a>和<a href="https://crates.io/crates/serde_json" target="_blank" rel="noopener noreferrer"> serde_json </a>机箱。这些都是Rust生态系统中久经考验的箱子，是利用Rust的高级抽象同时保持低级控制的好例子。</p>
<p/>
<p>虽然有很多其他JSON板条箱可用，但serde_json是目前最受欢迎的。围绕serde构建的大型生态系统使其成为用Rust编写的web服务器的首选。</p>
<p>在本教程中，我们将探索serde_json，并演示如何使用Rust的类型系统来表达json数据。</p>
<h2 id="gettingstarted">入门指南</h2>
<p>要开始使用serde_json，您必须首先在您的类型上实现<a href="https://docs.serde.rs/serde/trait.Serialize.html" target="_blank" rel="noopener noreferrer"> <code>Serialize</code> </a>和<a href="https://docs.serde.rs/serde/trait.Deserialize.html" target="_blank" rel="noopener noreferrer"> <code>Deserialize</code> </a>特征。由于派生宏，这对于大多数类型来说是微不足道的。要使用派生宏，请确保在依赖项中为serde启用了“派生”特性标志。</p>
<pre># cargo.toml

[dependencies]
serde = { version = "1", features = ["derive"] }
serde_json = "1"
</pre>
<p>现在我们可以像使用任何其他派生宏一样使用它们。</p>
<pre>use serde::{Deserialize, Serialize};

#[derive(Debug, Deserialize, Serialize)]
struct Person {
    name: String,
    age: usize,
    verified: bool,
}
</pre>
<p>这就是用支持serde的crate将<code>Person</code>序列化和反序列化成任何数据格式所需要做的全部工作。调试是可选的，但是我们将使用它来进行演示。将JSON字符串转换成<code>Person</code>的实例现在就像调用<code>serde_json::from_str</code>一样简单。</p>
<pre>fn main() {
    let json = r#"
        {
          "name": "George",
          "age": 27,
          "verified": false
        }
    "#;

    let person: Person = serde_json::from_str(json).unwrap();

    println!("{:?}", person);
}
</pre>
<p>这里有几件事情需要指出，首先是显式的<code>Person</code>类型注释。在这个例子中，编译器没有办法推断出<code>person</code>的类型；它可能是实现<code>Deserialize</code>的任何类型。在更完整的例子中，当传递<code>person</code>时，它可以从函数参数类型中推断出来。</p>
<p>另一件要注意的事情是对<code>unwrap()</code>的调用。反序列化可能以多种方式失败，所以<code>serde_json::from_str</code>返回一个<code>Result</code>来让我们处理这些失败。来自serde_json的错误非常丰富，给了我们足够的信息来确定到底哪里出错了。例如，在删除了<code>age</code>字段的情况下运行与上面相同的代码会触发下面的错误消息。</p>
<pre>Error("missing field `age`", line: 5, column: 9)
</pre>
<p>如果JSON中有语法错误，您会得到类似的消息。不使用<code>unwrap</code>，你可以使用<a href="https://docs.rs/serde_json/1.0.57/serde_json/struct.Error.html" target="_blank" rel="noopener noreferrer"> <code>serde_json::Error</code> </a>提供的方法提取上面看到的相同信息，并尽可能优雅地处理错误。</p>
<p>我最喜欢在Rust中使用JSON的一点是，由于使用了<code>Result</code>类型，它提供了完整的类型检查，没有样板代码和编译时强制执行的错误处理。使用JSON的地方几乎总是在系统边界，在那里您可以接收各种各样的意外输入。拥有一流的、一致的错误处理支持使得处理这些系统边界变得更加愉快和可靠。</p>
<h2 id="serverexample">服务器示例</h2>
<p>到目前为止，我们仅仅触及了serde和serde_json的皮毛。为了展示它们的作用，我们将创建一个服务器来计算各种形状的周长和面积。我们希望请求发送如下所示的JSON:</p>
<pre>{
  "calculation": "area",
  "shape": "circle",
  "radius": 4.5
}
</pre>
<p>在Rust中，这通常是一个好主意，我们将从考虑类型开始。JSON中的<code>calculation</code>字段的值只是一个字符串。虽然我们可以使用Rust <code>String</code>，但是我们需要执行一些不变量，这些不变量不能被<code>String</code>类型捕获。我们并不允许任何字符串值，我们只是想允许<code>perimeter</code>或<code>area</code>。一款<code>enum</code>很适合这样的产品。</p>
<pre>#[derive(Debug, Deserialize, Serialize)]
enum Calculation {
    Perimeter,
    Area,
}
</pre>
<p>JSON不包含枚举的概念，但这没关系，因为serde足够灵活，可以将这些数据类型融入到JSON等价物中。默认情况下，<code>Calculation</code>的变量将被转换成JSON字符串<code>Perimeter</code>和<code>Area</code>。这很好，但是我们更希望字符串都是小写的。为此，我们需要使用我们的第一个<a href="https://serde.rs/variant-attrs.html" target="_blank" rel="noopener noreferrer"> serde属性宏</a>。</p>
<pre>#[derive(Debug, Deserialize, Serialize)]
#[serde(rename_all = "lowercase")]
enum Calculation {
    Perimeter,
    Area,
}
</pre>
<p>顾名思义，<code>rename_all = "lowercase"</code>会将枚举变量映射到JSON中的小写字符串。</p>
<p>我们想要的JSON格式中的下一个字段是形状名称和该形状的属性。这些场彼此紧密耦合。圆应该有半径，但矩形不应该。为了在我们的类型中加强这种耦合，我们可以使用带有关联数据的<code>enum</code>。</p>
<pre>#[derive(Debug, Deserialize, Serialize)]
enum Shape {
    Circle {
        radius: f64,
    },
    Rectangle {
        length: f64,
        width: f64,
    },
}
</pre>
<p>默认情况下，这由外部标记的JSON对象表示，并添加了我们不想要的嵌套。</p>
<pre>{
  "Circle": {
    "radius": 4.5
  }
}
</pre>
<p>我们可以用另一个属性来解决这个问题。</p>
<pre>#[derive(Debug, Deserialize, Serialize)]
#[serde(rename_all = "lowercase", tag = "shape")]
enum Shape {
    Circle {
        radius: f64,
    },
    Rectangle {
        length: f64,
        width: f64,
    },
}
</pre>
<p><code>tag = "shape"</code>属性导致JSON对象在内部用键<code>shape</code>标记，给出如下内容。</p>
<pre>{
  "shape": "circle",
  "radius": 4.5
}
</pre>
<p>现在我们可以创建一个<code>Request</code>类型，将一个<code>Calculation</code>和一个<code>Shape</code>放在一起。</p>
<pre>#[derive(Debug, Deserialize, Serialize)]
struct Request {
    calculation: Calculation,
    shape: Shape,
}
</pre>
<p>您可能已经注意到，这种类型增加了另一层嵌套，与我们想要的JSON格式不匹配。</p>
<pre>{
  "calculation": "area",
  "shape": {
    "shape": "circle",
    "radius": 4.5
  }
}
</pre>
<p>同样，我们可以用一个属性来解决这个问题。</p>
<pre>#[derive(Debug, Deserialize, Serialize)]
struct Request {
    calculation: Calculation,
    #[serde(flatten)]
    shape: Shape,
}
</pre>
<p>这一次，<code>flatten</code>属性用于删除一层嵌套。在JSON对象包含一些没有可预测名称的键的情况下，这也很有用。为了解决这个问题，您可以创建一个类型，其中已知字段直接映射到一个<code>struct</code>字段，未知字段可以收集在一个扁平的<code>HashMap</code>中。</p>
<p>你现在可以用我们之前测试<code>Person</code>类型的方法来测试我们到目前为止做了什么。</p>
<pre>fn main() {
    let json = r#"
        {
          "calculation": "perimeter",
          "shape": "circle",
          "radius": 2.3
        }
    "#;

    let request: Request = serde_json::from_str(json).unwrap();

    println!("{:?}", request);
}
</pre>
<p>我鼓励您尝试输入JSON，看看类型验证有多健壮，错误有多大帮助。</p>
<p>我们的应用程序需要的最后一个类型是一个<code>Response</code>，它包含计算的结果。</p><div class="code-block code-block-54">
<hr/>
<h3>更多来自LogRocket的精彩文章:</h3>

<hr/></div>
<pre>#[derive(Debug, Deserialize, Serialize)]
struct Response {
    result: f64,
}
</pre>
<p>有了所有的类型，我们就可以构建实际执行计算的逻辑了。</p>
<pre>use std::f64::consts::PI;

fn calculation_handler(request: Request) -&gt; Response {
    let result = match (request.calculation, request.shape) {
        (Calculation::Perimeter, Shape::Circle { radius }) =&gt; PI * 2.0 * radius,
        (Calculation::Perimeter, Shape::Rectangle { length, width }) =&gt; 2.0 * length + 2.0 * width,
        (Calculation::Area, Shape::Circle { radius }) =&gt; PI * radius * radius,
        (Calculation::Area, Shape::Rectangle { length, width }) =&gt; length * width,
    };

    Response { result }
}
</pre>
<p>由于我们在类型系统中实施了不变量，我们的逻辑变得简单且易于推理。在这种情况下，它是一个纯粹的函数，接受一个<code>Request</code>并返回一个<code>Response</code>，使其可测试并与任何web框架完全解耦。serde的一个优点是，它不强迫您将逻辑和类型耦合到它，因为派生宏不修改现有的东西；他们纯粹添加了trait实现。</p>
<p>正如我前面提到的，serde_json可以利用serde周围的生态系统。许多箱子包含实现<code>Serialize</code>或<code>Deserialize</code>特征的类型的通用代码。web框架就是一个很好的例子。我们的处理程序已经有了一个类似HTTP请求-响应循环的类型签名，所以我们将能够把它插入到任何与serde集成的web框架中。</p>
<p>为了构建web服务器，我们需要添加一些新的依赖项。</p>
<pre>[dependencies]
serde = { version = "1", features = ["derive"] }
tokio = { version = "0.2", features = ["macros"] }
warp = "0.2"
</pre>
<p>接下来，用设置和启动服务器的<code>async</code>函数替换<code>main</code>函数。</p>
<pre>use warp::Filter;

#[tokio::main]
async fn main() {
    let endpoint = warp::post()
        .and(warp::body::json())
        .map(|body| warp::reply::json(&amp;calculation_handler(body)));
    warp::serve(endpoint).run(([127, 0, 0, 1], 5000)).await;
}
</pre>
<p>不要太担心这里发生的事情；重要的部分是<code>map</code>内部的封闭。为了让我们的逻辑与warp web服务器一起工作，我们需要做的就是将响应包装在<code>warp::reply::json</code>中。warp可以通过在引擎盖下使用serde_json来做到这一点。</p>
<p>此时，我们可以尝试将带有JSON主体的POST请求发送到localhost:5000，以测试包括错误消息在内的所有内容现在是否都可以在我们的HTTP API上工作。</p>
<p>现在，您应该已经很好地掌握了如何使用Rust类型来处理JSON。从这个例子中得到的一个关键信息是，您可以使用与您交互的JSON没有精确结构的Rust类型。当使用比简单的键值对象更适合问题的Rust类型系统的高级特性时，我们可以自由地使用它们，而不用担心额外的样板文件。</p>
<p>这个例子的完整代码在<a href="https://github.com/joshua-cooper/rust-json-example" target="_blank" rel="noopener noreferrer"> GitHub </a>上。</p>
<h2 id="workingwithouttypes">不使用类型工作</h2>
<p>尽管通常最好使用自己的类型，并通过serde_json派生出<code>Serialize</code>和<code>Deserialize</code>特征，但有时您要么不能，要么不想。对于这些情况，您可以直接使用serde_json <code>Value</code>类型。这是一个枚举，包含JSON中每种可能的数据类型的变量。</p>
<pre>// serde_json::Value

pub enum Value {
    Null,
    Bool(bool),
    Number(Number),
    String(String),
    Array(Vec&lt;Value&gt;),
    Object(Map&lt;String, Value&gt;),
}
</pre>
<p>创建<code>Value</code>的一个简单方法是使用<code>serde_json::json</code>宏。这实质上允许您直接在Rust源代码中编写JSON。如果您有一个代表对象或数组的<code>Value</code>，您可以使用<code>Value::get</code>访问这些字段，类似于<code>Vec::get</code>和<code>HashMap::get</code>。</p>
<pre>use serde_json::json;

fn main() {
    let value = json!({
        "name": "Bob",
        "age": 51,
        "address": {
            "country": "Germany",
            "city": "Example City",
            "street": "Example Street"
        },
        "siblings": ["Alice", "Joe"]
    });

    println!(
        "{:?}",
        value.get("address").and_then(|name| name.get("country"))
    );
}
</pre>
<p>这个例子将打印<code>Some(String("Germany"))</code>。如您所料，<code>get</code>返回一个<code>Option</code>，因为索引或键可能不存在。</p>
<p>这就是在没有自定义类型的情况下使用serde_json的全部内容。可以想象，这对于处理带有未知键的JSON和快速原型很有用。由于web框架之类的东西在<code>Serialize</code>和<code>Deserialize</code>特征上是通用的，而<code>serde_json::Value</code>实现了这些特征，所以你可以使用这些<code>Value</code>而不会有任何额外的摩擦。</p>
<h2 id="conclusion">结论</h2>
<p>作为Rust最成熟的产品之一，serde和serde_json使得使用json变得轻而易举。在本指南中，我们讨论了如何使用自己的数据类型来表示已知的JSON结构，以及如何处理未知的JSON结构。Serde的数据模型非常灵活，所以你应该能够处理任何符合人体工程学的JSON数据，最大限度地减少样板文件的生锈。</p>
<p>简而言之，任何Rust开发者都不应该担心JSON支持。与其他主流语言相比，它非常适合生产，可以说是同类中最好的。</p><div class="code-block code-block-29">
<div class="blog-plug inline-plug rust-plug"><h2><a href="https://lp.logrocket.com/blg/rust-signup" target="_blank">log rocket</a>:Rust应用的web前端的全面可见性</h2><p>调试Rust应用程序可能很困难，尤其是当用户遇到难以重现的问题时。如果您对监控和跟踪Rust应用程序的性能、自动显示错误、跟踪缓慢的网络请求和加载时间感兴趣，</p><a href="https://lp.logrocket.com/blg/rust-signup" target="_blank">try LogRocket</a><p>. </p><a class="signup" href="https://lp.logrocket.com/blg/rust-signup" target="_blank" rel="noopener noreferrer"><img class="alignnone size-full wp-image-46 jetpack-lazy-image" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/><noscript><img data-lazy-fallback="1" class="alignnone size-full wp-image-46" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/></noscript></a><p>LogRocket 就像是网络和移动应用程序的DVR，记录你的Rust应用程序上发生的一切。您可以汇总并报告问题发生时应用程序的状态，而不是猜测问题发生的原因。LogRocket还可以监控应用的性能，报告客户端CPU负载、客户端内存使用等指标。</p><p>现代化调试Rust应用的方式— <a class="signup" href="https://lp.logrocket.com/blg/rust-signup" target="_blank" rel="noopener noreferrer">开始免费监控</a>。</p></div>


</div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
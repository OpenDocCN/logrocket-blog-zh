<html>
<head>
<title>Comparing statically typed JavaScript implementations - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>比较静态类型的JavaScript实现</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/typescript-vs-flow-vs-proptypes/#0001-01-01">https://blog.logrocket.com/typescript-vs-flow-vs-proptypes/#0001-01-01</a></blockquote><div><article class="article-post">
 <p><em>编者按:这篇文章于2021年10月28日编辑，以添加新的实现，提供更好、更易读的比较格式，并更彻底地讨论不同的选项。</em></p>
<p>JavaScript是一种动态类型语言，这意味着变量的数据类型由它们在运行时保存的值决定，并且当我们给它们赋予不同的值时，它们会在整个程序中发生变化。</p>
<p>没有内置的方法来注释或限制变量的类型。虽然这意味着我们可以更快地编写程序，而不必过多考虑变量应该具有的类型，但这也意味着当变量在不同类型之间移动时，我们的程序可能会出现错误和意外行为。</p>
<p>为了避免JavaScript的这些动态类型改变问题，我们需要用另一种语言编写程序，然后将其转换成JavaScript。为此，我们需要一种JavaScript的类型化扩展语言来检查和限制变量的类型。</p>
<p>有几种语言和库提供JavaScript的静态类型扩展，例如:</p>

<p>在本文中，我们将重点关注TypeScript、Flow和Prop类型，比较和对比它们特性和功能。</p>
<h2 id="comparing-type-checking-libraries-languages">比较类型检查库/语言</h2>
<table>
<tbody>
<tr>
<td><strong>打字稿</strong></td>
<td><strong>流量</strong></td>
<td><strong>道具类型</strong></td>
<td><strong>开发商</strong></td>
</tr>
<tr>
<td><strong>微软</strong></td>
<td><strong>脸书</strong></td>
<td><strong>脸书</strong></td>
<td><strong>首次发布</strong></td>
</tr>
<tr>
<td>2012年10月1日</td>
<td>【2014年11月18日</td>
<td>2017年4月8日</td>
<td><strong>执照</strong></td>
</tr>
<tr>
<td><span>开源</span></td>
<td>麻省理工学院</td>
<td>麻省理工学院</td>
<td><strong>社区</strong></td>
</tr>
<tr>
<td><span>大</span></td>
<td><span>小</span></td>
<td><span>相对较小</span></td>
<td><strong>依赖关系</strong></td>
</tr>
<tr>
<td colspan="4"><strong>性能</strong></td>
<td><span>被认为是最快和错误最少的</span></td>
<td>一些报告的内存泄漏。 <a href="https://medium.com/flow-type/improvements-to-flow-in-2019-c8378e7aa007" target="_blank" rel="noopener"> <span>流团队2019年</span> </a> <span>报告复检时间和内存使用量减少</span></td>
<td><span>未上报的性能统计数据</span></td>
</tr>
<tr>
<td><a href="#type-definition-checking-syntax"> <strong>类型检查</strong> </a></td>
<td><span>使用JavaScript类型，泛型类型定义，并有可选类型</span> <span>可空</span></td>
<td><span>使用JavaScript类型，泛型类型定义，并有可选类型</span> <span>也许是</span></td>
<td><span>使用自己的类型验证器对象</span></td>
</tr>
<tr>
<td><a href="#typecasting"> <strong>型铸造</strong> </a></td>
<td><span>使用关键字</span> <span>作为</span></td>
<td><span>使用符号</span> <span> : </span></td>
<td><span>不适用</span></td>
</tr>
<tr>
<td><strong>支持<a href="#interfaces-enums-custom-types">接口、枚举和自定义类型对象</a>T3】</strong></td>
<td><span>支持用关键字</span> <span>接口</span> <span>和</span> <span>枚举</span>声明的接口和枚举</td>
<td><span>支持接口和枚举，用关键字</span> <span>声明接口</span> <span>和</span> <span>枚举</span></td>
<td><span>支持enum使用自己的选项，</span><span>proptypes . one of([…])</span><span>T5】</span></td>
</tr>
<tr>
<td><a href="#text-editor-support"> <strong>文本编辑器支持</strong> </a></td>
<td>多个编辑器/ide提供了大量支持，包括智能感知(自动完成)、定位定义、错误/警告等功能。</td>
<td>多个编辑器/ide提供了大量支持，包括智能感知(自动完成)、定位定义、错误/警告等功能。</td>
<td><span>有限支持Visual Studio代码和WebStorm自动生成组件的属性类型</span></td>
</tr>
<tr>
<td><a href="#resources-documentation"> <strong>资源和文档</strong> </a></td>
<td><span>Massive support with several editors/IDEs providing functionality like IntelliSense (autocomplete), go-to definition, errors/warnings, etc.</span></td>
<td><span>Massive support with several editors/IDEs providing functionality like IntelliSense (autocomplete), go-to definition, errors/warnings, etc.</span></td>
<td><span>Limited support with Visual Studio Code and WebStorm to autogenerate propTypes of components</span></td>
</tr>
<tr>
<td colspan="4"><a href="#community-project-support"> <strong>社区和项目支持</strong> </a></td>
<td>由多个现成的框架和库支持，例如Vue、React、Angular、Express等。，包括Nest.js </td>
<td><span>可以通过Babel安装在现有项目上。最常见的用法是与React一起使用。</span></td>
<td><span>主要用于React(它是从那里提取的),但也可以通过手动调用</span><span>proptypes . checkproptypes</span>用于其他框架</td>
</tr>
<tr>
<td><strong>堆栈溢出上发布的问题</strong></td>
<td><a href="https://stackoverflow.com/questions/tagged/typescript" target="_blank" rel="noopener"> <span>超过10万+帖子</span> </a></td>
<td><a href="https://stackoverflow.com/search?q=facebook+flow&amp;s=371fcc4b-982f-45e3-b960-e06b49d967e2" target="_blank" rel="noopener"> <span>大约500个帖子</span> </a></td>
<td><a href="https://stackoverflow.com/search?q=proptypes&amp;s=14bfb66b-084b-49e5-9d9c-5e4d2325a824" target="_blank" rel="noopener"> <span>大约500个帖子</span> </a></td>
</tr>
<tr>
<td><strong>编译器错误检测</strong></td>
<td><span>在ide和文本编辑器中可用</span></td>
<td><span>在支持的ide和编辑器中可用</span></td>
<td><span>不可用</span></td>
</tr>
<tr>
<td><strong>语法</strong></td>
<td><span>全面的类型检查，包括静态和动态类型注释</span></td>
<td><span>全面的类型检查，包括静态和动态类型注释</span></td>
<td><span>依赖于对PropTypes对象</span>的引用</td>
</tr>
<tr>
<td><strong>仿制药</strong></td>
<td><span>支持的</span></td>
<td><span>支持的</span></td>
<td><span>不支持</span></td>
</tr>
<tr>
<td><strong>对现有项目的支持</strong></td>
<td><span>可以添加TypeScript包来支持TypeScript </span></td>
<td><span>用巴别塔添加支持</span></td>
<td><span>通过安装库和手动调用</span> <span> <code>PropTypes.checkPropTypes</code> </span>添加支持</td>
</tr>
<tr>
<td>在本文中，我们将从许多特性和能力方面比较和对比这些JavaScript扩展技术。</td>
<td>当我们探讨它们的相似性和差异时，前面要注意的一个重要差异是，与TypeScript不同，Flow和PropTypes不是编程语言。Flow和PropTypes只是静态类型检查库，他的不同影响了哪些框架支持它们的使用。</td>
<td>在项目中设置TypeScript</td>
<td>在本文比较的三种技术中，TypeScript拥有最多的库支持，在Vue、Angular或React中设置项目以使用TypeScript很容易，并且开箱即用。</td>
</tr>
</tbody>
</table>
<p>例如，我们可以通过从Vue CLI选择TypeScript选项来构建带有TypeScript 的<a href="https://vuejs.org/v2/guide/typescript.html" target="_blank" rel="noopener"> Vue项目，因为它是内置的。一旦我们选择了TypeScript，那么我们可以在我们的<code>tsconfig.json</code>文件中将其配置为transpile to JavaScript(通常设置ECMAScript 2009以最大化浏览器的支持)。</a></p>
<p>然后，当我们在组件创建期间引用Vue时，我们将得到TypeScript类型推断:</p>
<h2 id="setting-up-typescript-projects">同样，使用Vue，我们可以用自己的特殊方式用TypeScript和<a href="https://blog.logrocket.com/when-how-use-interfaces-classes-typescript/" target="_blank" rel="noopener">类</a>编写组件，就像这样:</h2>
<p>这里，我们可以看到熟悉的JavaScript语法和一些TypeScript注释。例如，Angular是用TypeScript构建的，它几乎只使用TypeScript。曾经有一个用普通JavaScript编写Angular应用程序的选项，但它从未流行起来。</p>
<p>在项目中设置流程</p>
<pre class="language-yaml hljs">// tsconfig.json
{
  "compilerOptions": {
    // this aligns with Vue's browser support
    "target": "es5",
    // this enables stricter inference for data properties on `this`
    "strict": true,
    // if using webpack 2+ or rollup, to leverage tree shaking:
    "module": "es2015",
    "moduleResolution": "node"
  }
}
</pre>
<p>另一方面，我们可以通过在Babel配置中添加流支持来为我们的项目添加流。</p>
<pre class="&quot;language-typescript">import Vue from 'vue'

const Component = Vue.extend({
  // ...
})
</pre>
<p>要添加流支持，我们只需运行:</p>
<pre class="language-typescript hljs">&lt;template&gt;
  &lt;button @click="onClick"&gt;Click!&lt;/button&gt;
&lt;/template&gt;


&lt;script lang="ts"&gt;
import * as Vue from "vue";
import { Component } from "vue-property-decorator";

@Component()
class App extends Vue {
  public message: string = "Hello World";

  public onClick(): void {
    window.alert(this.message);
  }
}

export default App;
&lt;/script&gt;
</pre>
<p>并将以下内容添加到<code>.babelrc</code>文件中:</p>
<h2 id="settingupflowinprojects">在项目中设置属性类型</h2>
<p>要在我们的项目中添加PropTypes，我们只需安装PropTypes库，定义我们的组件prop类型，并手动调用<code>PropTypes.checkPropTypes</code>验证方法。</p>
<p>为了安装PropTypes，我们运行:</p>
<pre class="language-bash hljs">npm install --save-dev @babel/preset-flow
</pre>
<p>然后，我们定义组件属性类型验证，用属性/值设置一个对象:</p>
<pre class="language-javascript hljs">{
  "presets": ["@babel/preset-flow"]
}
</pre>
<h2 id="setting-up-proptypes-projects">并运行PropType检查:</h2>
<p>类型定义和检查语法</p>
<p>如前所述，这三种技术都提供了对变量的类型检查和限制，这里我们将对它们进行比较。</p>
<pre class="language-bash hljs">npm install --save prop-types
</pre>
<p>流和类型脚本类型定义</p>
<pre class="language-typescript hljs"> const myPropTypes = {
  name: PropTypes.string,
  age: PropTypes.number,
  // ... define your prop validations
};

const props = {
  name: 'hello', // is valid
  age: 'world', // not valid
};
</pre>
<p>Flow和TypeScript具有非常相似的类型定义语法。他们都:</p>
<pre class="language-javascript hljs">// Let's say your component is called 'MyComponent'

// Works with standalone PropTypes
PropTypes.checkPropTypes(myPropTypes, props, 'age', 'MyComponent');

// This will warn as follows:
// Warning: Failed prop type: Invalid prop `age` of type `string` supplied to
// `MyComponent`, expected `number`.
</pre>
<h2 id="type-definition-checking-syntax">为类型检查变量支持JavaScript原始类型和派生(对象)类型</h2>
<p>对于类型注释有相似的语法</p>
<h3>使用运算符和各种实用程序类型来保持JavaScript类型系统的灵活性</h3>
<p>具有可选属性的类型，即TypeScript具有<code>nullable</code>类型，而Flow具有<code>maybe</code>类型</p>
<ul>
<li>有泛型，我们可以用它来编写采用变量类型的代码</li>
<li>有关最后一个项目符号的示例，请参见下文:</li>
<li>泛型采用一个变量类型，可以用不同的类型重载，例如<code>identity&lt;string&gt;('foo')</code>。</li>
<li>此外，下面的代码块在TypeScript和Flow中都是相同的，其中函数接受两个类型为<code>string</code>的变量，并将它们连接在一起返回。</li>
<li>PropTypes类型验证程序</li>
</ul>
<p>另一方面，PropTypes使用自己的类型验证器来设置组件属性的类型——也就是说，在PropTypes中，我们将使用<code>PropTypes</code>对象来定义类型。</p>
<pre class="language-javascript hljs">function identity&lt;T&gt;(value: T): T {
    return value
}
</pre>
<p>铅字铸造</p>
<p>Flow和TypeScript都提供了将变量从一种类型显式转换为另一种类型的能力。</p>
<pre class="language-javascript hljs">function concat(a: string, b: string) {
  return a + b;
}
</pre>
<h3>对于Flow，我们使用符号<code>:</code>进行造型，而在TypeScript中，我们使用关键字<code>as</code>进行造型。</h3>
<p>PropTypes不提供将属性或变量从一种类型转换为另一种类型的能力。</p>
<pre class="language-javascript hljs">import React from 'react';
import PropTypes from 'prop-types'

class MyComponent extends React.Component {
  render() {
    // ... do things with the props
  }
}

MyComponent.propTypes = {
  optionalArray: PropTypes.array,
...
</pre>
<h2 id="typecasting">接口、枚举和自定义类型</h2>
<p>接口是限制对象的结构和属性的类型定义。<a href="https://blog.logrocket.com/writing-readable-code-with-typescript-enums-a84864f340e9/" target="_blank" rel="noopener">枚举</a>是列出的值，可以通过将变量限制为保存其值之一来用作类型。Flow、TypeScript和PropTypes允许定义自定义类型限制。</p>
<p>Flow和TypeScript使用关键字<code>interface</code>定义这些自定义类型对象。它们都允许类使用<code>implements</code>关键字继承接口的结构。参见下面的示例。</p>
<pre class="language-javascript hljs">// TypeScript
let value = 1 as number;

// Flow
let value = 1;
(value: number);
</pre>
<p>如果我们没有实现接口中列出的所有成员，那么流和TypeScript transpilers将会出错。</p>
<h2 id="interfaces-enums-custom-types">Flow和TypeScript还使用<code>enum</code>关键字定义了用于类型检查的枚举列表。</h2>
<p>Flow的一个独特特性是，我们可以将类型检查代码放在注释中，如下所示:</p>
<p>这在TypeScript中不可用。然而，这并没有太大的吸引力，因为注释没有自动完成或语法高亮。</p>
<pre class="language-javascript hljs">interface PersonInterface {
  firstName: string;
  lastName: string;
  fullName(firstName: string, lastName: string): string
}

class Person implements PersonInterface {
    firstName: string;
    lastName: string;
    constructor(firstName: string, lastName: string){
        this.firstName = firstName;
        this.lastName = lastName;
    }

    fullName(firstName: string, lastName: string): string {
        return `${firstName} ${lastName}`;
    }
}
</pre>
<p>另一方面，PropTypes使用<code>PropTypes.oneOf</code>定义枚举类型，如下所示:</p>
<p>PropTypes还使用<code>PropTypes.shape</code>定义了对象类型结构。</p>
<pre class="language-javascript hljs">enum Status {
  Active,
  Paused,
  Off,
}

const status: Status = Status.Active //correct
const wrongStatus: Status = 'test' //incorrect and not conforming to defined type
</pre>
<p>文本编辑器支持</p>
<pre class="language-javascript hljs">function greet(greeting /*: string*/) /* : string */ {
  return greeting;
}
</pre>
<p>Flow和TypeScript都有来自Visual Studio Code和Sublime等编辑器的内置或插件支持。</p>
<p>对Flow和TypeScript的编辑器支持意味着开发人员可以获得如下功能:</p>
<pre class="language-javascript hljs">...
optionalEnum: PropTypes.oneOf(['News', 'Photos']),
...
</pre>
<p>智能感知(自动完成)</p>
<pre class="language-javascript hljs">...
optionalObjectWithShape: PropTypes.shape({
    optionalProperty: PropTypes.string,
    requiredProperty: PropTypes.number.isRequired
}),
...
</pre>
<h2 id="text-editor-support">转到定义/查看定义</h2>
<p>诊断(错误、警告)</p>
<p>悬停类型信息</p>
<ul>
<li>可切换的代码覆盖率报告</li>
<li>还有<a href="https://flow.org/en/docs/install/" target="_blank" rel="noopener">文档</a>通过Babel在现有项目中安装流支持。阅读编辑器/IDE安装的更多细节<a href="https://flow.org/en/docs/editors/" target="_blank" rel="noopener">获得流支持</a>和<a href="https://github.com/Microsoft/TypeScript/wiki/TypeScript-Editor-Support" target="_blank" rel="noopener">打字稿编辑器支持</a>。</li>
<li>PropTypes还对Visual Studio代码提供了一些支持，用于为组件的赋值自动生成适当的组件类型。</li>
<li>PropTypes也<a href="http://PropTypes.checkPropTypes" target="_blank" rel="noopener">有能力通过手动调用<code>PropTypes.checkPropTypes</code>应用到其他库</a>(在React中自动调用)。虽然在PropTypes的官方文档中提到了对其他库的支持，但是没有很多外部文档说明这如何适用于不同的库。</li>
<li>效率和性能</li>
</ul>
<p>Flow和TypeScript之间的性能差异很小。TypeScript始终使用500-600MB的内存，流量也没有太大的不同。它们在计算资源效率方面没有太大的区别。</p>
<p>PropTypes效率？根据这个Reddit线程的说法，TypeScript速度更快，错误更少。</p>
<p>与对Flow和PropTypes的支持相比，社区对TypeScript的支持是最大的。除了官方来源之外，Flow和PropTypes的文档也更少，关于StackOverflow的问题也更少，正如我们之前在本文顶部的表格中讨论的那样。</p>
<h2 id="efficiency-performance">许多流行的前端库、框架和平台都内置了对TypeScript的支持，比如Vue、Angular和React。像<a href="https://expressjs.com/" target="_blank" rel="noopener"> Express </a>这样的Node.js web框架也可以添加TypeScript支持，<a href="https://nestjs.com/"> Nest.js </a>内置了TypeScript支持，允许我们使用TypeScript进行开发，而无需对我们的项目进行大的更改。</h2>
<p>例如，要在Express 中使用TypeScript，我们只需运行下面的命令来安装TypeScript transpiler。</p>
<p>然后我们可以添加一个<code>tsconfig.json</code>文件来配置我们的TypeScript transpiler，编写如下代码:</p>

<p>为了安装Express和Node的标准库的类型定义，我们运行:</p>
<p>正如我们所看到的，对现有的库使用TypeScript并不太难，因为许多库和框架都有TypeScript类型定义。关于TypeScript的更多类型定义，我们可以去<a href="http://definitelytyped.org/" target="_blank" rel="noopener"> DefinitelyTyped </a>网站。</p>
<p>资源和文档</p>
<pre class="language-typescript hljs">npm install --save-dev typescript
</pre>
<p>就可用的资源和文档数量而言，TypeScript无疑胜出。<br/>打字稿报价:</p>
<pre class="language-javascript hljs">{
    "compilerOptions": {
        "module": "commonjs",
        "esModuleInterop": true,
        "target": "es6",
        "noImplicitAny": true,
        "moduleResolution": "node",
        "sourceMap": true,
        "outDir": "dist",
        "baseUrl": ".",
        "paths": {
            "*": [
                "node_modules/*"
            ]
        }
    },
    "include": [
        "src/**/*"
    ]
}
</pre>
<p>作为一个额外的好处，TypeScript playground支持不同版本的TypeScript，因此我们可以看到我们的代码如何处理不同版本的TypeScript transpiler。</p>
<pre class="language-bash hljs">npm install --save-dev @types/node @types/express
</pre>
<p>结论</p>
<h2 id="resources-documentation">由于TypeScript受到许多库和框架的支持，许多人每天都在使用TypeScript。TypeScript中有大量关于每个特性的信息，包括示例和解释。这很可能是实现静态类型的最佳选择。</h2>
<p>另一方面，<a href="https://flow.org/" target="_blank" rel="noopener"> Flow只有一些文档</a>和一个关于如何用React 设置<a href="https://flow.org/en/docs/react/" target="_blank" rel="noopener"> Flow的简短文档，也可以应用到其他JavaScript框架上设置Flow。然而，到目前为止，PropTypes拥有三个选项中</a><a href="https://github.com/facebook/prop-types" target="_blank" rel="noopener">最稀疏的文档</a>，尽管存在一些帖子，如<a href="https://blog.logrocket.com/validating-react-component-props-with-prop-types-ef14b29963fc/" target="_blank" rel="noopener"> this </a>。</p>

<p><a class="signup" href="https://lp.logrocket.com/blg/typescript-signup" target="_blank" rel="noopener noreferrer"> LogRocket </a>:全面了解您的网络和移动应用</p>
<h2>LogRocket 是一个前端应用程序监控解决方案，可以让您回放问题，就像问题发生在您自己的浏览器中一样。LogRocket不需要猜测错误发生的原因，也不需要向用户询问截图和日志转储，而是让您重放会话以快速了解哪里出错了。它可以与任何应用程序完美配合，不管是什么框架，并且有插件可以记录来自Redux、Vuex和@ngrx/store的额外上下文。</h2>
<p>除了记录Redux操作和状态，LogRocket还记录控制台日志、JavaScript错误、堆栈跟踪、带有头+正文的网络请求/响应、浏览器元数据和自定义日志。它还使用DOM来记录页面上的HTML和CSS，甚至为最复杂的单页面和移动应用程序重新创建像素级完美视频。</p>
<p>.</p><div class="code-block code-block-21">
<div class="blog-plug inline-plug typescript-plug"><h2><a class="signup" href="https://lp.logrocket.com/blg/typescript-signup" target="_blank" rel="noopener noreferrer">LogRocket</a>: Full visibility into your web and mobile apps</h2>
<a href="https://lp.logrocket.com/blg/typescript-signup" class="signup" target="_blank" rel="noopener noreferrer"><img class="alignnone size-full wp-image-46 jetpack-lazy-image" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/><noscript><img data-lazy-fallback="1" class="alignnone size-full wp-image-46" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/></noscript></a>
<p><a href="https://lp.logrocket.com/blg/typescript-signup" target="_blank" rel="noopener noreferrer">LogRocket</a> is a frontend application monitoring solution that lets you replay problems as if they happened in your own browser. Instead of guessing why errors happen, or asking users for screenshots and log dumps, LogRocket lets you replay the session to quickly understand what went wrong. It works perfectly with any app, regardless of framework, and has plugins to log additional context from Redux, Vuex, and @ngrx/store.</p>
<p>In addition to logging Redux actions and state, LogRocket records console logs, JavaScript errors, stacktraces, network requests/responses with headers + bodies, browser metadata, and custom logs. It also instruments the DOM to record the HTML and CSS on the page, recreating pixel-perfect videos of even the most complex single-page and mobile apps.</p>
<a class="signup" href="https://lp.logrocket.com/blg/typescript-signup" target="_blank" rel="noopener noreferrer">Try it for free</a><p>.</p></div>
</div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
<html>
<head>
<title>It’s 2018 — you shouldn’t be writing vanilla CSS - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>现在是2018年——你不应该写普通的CSS - LogRocket博客</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/its-2018-you-shouldn-t-be-writing-vanilla-css-b3d09b9c2c41/#0001-01-01">https://blog.logrocket.com/its-2018-you-shouldn-t-be-writing-vanilla-css-b3d09b9c2c41/#0001-01-01</a></blockquote><div><article class="article-post">
<p>开发人员的一个常见错误是，与他们代码库的其他部分相比，不太重视(通常根本不重视)样式。</p>
<p>从CSS的早期开始，有一种非常流行的做法，将所有内容都累积在一个样式表中，不小心，很快就造成了一个巨大的维护噩梦。</p>
<p>这是一个非常简单的哲学:</p>
<ul>
<li>如果你需要设计一些东西，只要把它放在<code>styles.css</code>的末尾</li>
<li>当你试图让一个属性工作有问题时，没有必要调试你的代码，这是愚蠢的，这只是CSS…一个简单的<code>!important</code>就可以完成这项工作。作为一种预防措施，你可以用它做任何事情，所以它肯定会工作</li>
<li>如果它仍然不起作用，一个超特定的选择器是肯定的事情，类似于<code>body&gt;header#main_header.main-header&gt;img.logo+div.links&gt;a.link</code></li>
<li>你有很多重复的代码吗？这很正常，这只是老式的代码重用</li>
<li>模式、惯例、最佳实践、方法？为了什么？就是<em>就</em> CSS，记得吗？</li>
</ul>
<p>好在这几年，这种思维方式已经越来越过时了。</p>
<p>web中发生了很多变化:浏览器、浏览器的三种主要语言、可用库和框架数量的爆炸性增长、方便我们日常工作的许多令人难以置信的工具的出现，以及最后但并非最不重要的前端社区及其不断增长的自我完善的渴望。</p>
<p>CSS的发展是持续的。像<a href="https://blog.logrocket.com/the-simpletons-guide-to-css-grid-1767565b3cf7/" target="_blank" rel="noopener noreferrer"> CSS网格布局</a>、<a href="https://blog.logrocket.com/flexing-with-css-flexbox-b7940b329a8a/" target="_blank" rel="noopener noreferrer"> Flexbox </a>、自定义属性、书写模式等特性很快出现并得到支持。即便如此，不管您是否遵循了最佳实践，仅用普通CSS来维护复杂web应用程序的外观也是一件吃力不讨好的工作。</p>
<p>事实是，除了少数例外，任何项目都可能受到预处理和后处理工具或CSS-in-JS库的青睐。在本文中，我们将看到它们是如何工作的以及它们的优点。</p>
<h2>预处理器</h2>
<p>CSS预处理器是一种将给定语言的代码转换成纯CSS的工具。最受欢迎的有<a href="https://sass-lang.com/" target="_blank" rel="noopener noreferrer">萨斯</a>、<a href="http://stylus-lang.com/" target="_blank" rel="noopener noreferrer">手写笔</a>、<a href="http://lesscss.org/" target="_blank" rel="noopener noreferrer">少</a>。其中，功能集和语言语法存在差异。</p>
<p>本文的目的不是对可用的选项进行详细的比较(因为互联网上有许多关于这个目标的伟大帖子)，而是以一种通用的方式介绍预处理程序。对于示例，我选择了Stylus，这是一个用JavaScript编写的工具，运行在Node.js上。</p>
<p>看一下这段代码:</p>
<pre>$base-color = #2DD;
$base-color--dark = darken($base-color, 30%);

.menu {
    background-color: $base-color--dark;

    &amp;::before {
        color: $base-color;
    }
}</pre>
<p>在上面代码的开始，我声明了两个变量，它们的值是颜色。第一个有一个文字值。第二个使用一个本地手写笔函数<code>darken</code>，使存储在<code>$base-color</code>变量中的颜色变暗30%。</p>
<p>然后，我声明一个名为<code>menu</code>的类。在这个规则的主体中，我使用了之前已经声明的两个变量。最后，出现了选择器嵌套，我为<code>menu</code>类设置了<code>before</code>伪元素的颜色。</p>
<blockquote><p><strong>注意:</strong>使用美元符号作为变量名称的前缀是个人偏好的问题，而不是手写笔的需求。我在使用Sass的这些年里养成了这个习惯，现在我仍然把它作为手写笔的最佳实践。这样，变量变得更加明显，不会与CSS关键字混淆。</p></blockquote>
<p>上面的例子有一些浏览器不支持的特性，例如选择器嵌套和变量(好了，现在CSS有了自定义属性，正如我在本文的<a class="markup--anchor markup--p-anchor" href="https://medium.com/@alcidesqueiroz/vanilla-css-magic-with-custom-properties-5f2f145e3e07" target="_blank" rel="noopener noreferrer" data-href="https://medium.com/@alcidesqueiroz/vanilla-css-magic-with-custom-properties-5f2f145e3e07">中解释的，但是它们的用法和语法是不同的，有些奇怪)。为了让浏览器正确地解释Sass、Stylus或Less代码，编译过程是必要的。编译后，输出只是普通的CSS:</a></p>
<pre>.menu {
  background-color: #189b9b;
}
.menu::before {
  color: #2dd;
}</pre>
<p>如您所见，最终结果将嵌套的选择器扩展为单独的规则，并用各自的值替换每个变量引用。就这样。</p>
<h2>预处理器中的常见功能</h2>
<p>不同的预处理器支持不同的功能。主要的几个里面，Sass和Stylus是最全能最全的。我将再次使用手写笔来解释每个概念。</p>
<h3>变量</h3>
<p>变量可以存储以下内容:</p>
<h4>颜色；色彩；色调</h4>
<ul>
<li><code>$base-color = blue;</code></li>
<li><code>$cta-color = #D32;</code></li>
<li><code>$link-color = rgb(15, 200, 25);</code></li>
</ul>
<h4>数值+单位</h4>
<ul>
<li><code>$container-padding = 2rem;</code></li>
<li><code>$rotation-increment = 15deg;</code></li>
<li><code>$default-transition-duration = 20ms;</code></li>
</ul>
<h4>值列表，如…</h4>
<ul>
<li>数字:<code>$sequence = 1, 2, 3;</code></li>
<li>颜色:<code>$colors = blue, #F00, hsla(120,100%,30%,0.5);</code></li>
<li>还有更多……:<code>$font-stack: “Helvetica Neue”, Helvetica, Arial, sans-serif;</code></li>
</ul>
<h3>嵌套</h3>
<p>可以嵌套选择器，以避免代码重复，并以更清晰的方式对相关规则进行分组:</p>
<pre>.main-navbar {
    ul {
        list-style-type: none;
    }

        a {
            color: #D22;
            
            &amp;::after {
                margin-left: 1rem;
            }

            &amp;:hover{
                opacity: 0.8;
            }
        }
}</pre>
<blockquote><p>建议:需要指出的是，这个特性需要仔细考虑，因为如果过度使用，它很容易出现问题，例如:与HTML层次结构高度耦合的样式表、具有高特异性的选择器以及不必要的大CSS输出。</p></blockquote>
<h3>单一和多重遗传</h3>
<p>像OO语言一样，预处理程序允许通过继承来重用代码。</p>
<p>类X可以扩展另一个类Y，继承它的所有属性，并拥有自己的属性:</p>
<pre>.btn {
    border-radius: 0.3rem;
    border: 0.1rem solid #222;

    &amp;:hover {
        opacity: 0.9;
    }
}

.btn--blue {
    @extend .btn;
    background-color: #22D;
}</pre>
<p>除了上面举例说明的单一继承之外，还可以同时从多个类继承样式:</p>
<pre>.btn {
    border-radius: 0.3rem;
    border: 0.1rem solid #222;

    &amp;:hover {
        opacity: 0.9;
    }
}

.big-btn {
    font-size: 1.8rem;
    padding: 1rem 2rem;
}

.big-btn--blue {
    @extend .btn, .big-btn;
    background-color: #22D;
}</pre>
<h3>占位符(抽象类)</h3>
<p>为了继续我们与OO语言的比较，让我们引入占位符的概念，它最初是由Sass推广的，可以比作OOP中的抽象类。占位符是一种特殊类型的类，只能被扩展。这意味着你不能直接从你的HTML中引用它，一旦它不出现在你最终的CSS输出中。占位符中的代码只有在类扩展它的情况下才会被呈现。</p>
<p class="graf graf--p">我们以与使用普通CSS类相同的方式扩展占位符:</p>
<pre>$btn {
    border-radius: 0.3rem;
    border: 0.1rem solid #222;

    &amp;:hover {
        opacity: 0.9;
    }
}

.btn--blue {
    @extend $btn;
    background-color: #22D;
}</pre>
<p>在手写笔中，占位符以美元符号为前缀。在上面的代码中，<code>.btn--blue</code>类将继承<code>$btn</code>占位符的整个主体，但是它不会出现在编译后的CSS中。</p>
<h3>条件句和循环</h3>
<p>像任何结构化语言一样，也可以使用条件和循环:</p>
<pre>$colors = 'blue', 'black', 'yellow', 'aqua';
$dark-colors = 'blue', 'black';

for $color in $colors {
    .btn--{$color} {
        background-color: unquote($color);
        
        if $color in $dark-colors {
            color: white;  
        } else {
            color: #222;
        }
    }
}</pre>
<p>下面是编译后的CSS:</p>
<pre>.btn--blue {
  background-color: blue;
  color: #fff;
}
.btn--black {
  background-color: black;
  color: #fff;
}
.btn--yellow {
  background-color: yellow;
  color: #222;
}
.btn--aqua {
  background-color: aqua;
  color: #222;
}</pre>
<h3>功能</h3>
<p>函数也包含在主预处理器中。一个函数的行为与你在其他语言中习惯的完全一样，接收从0到<em> n </em>个参数并返回一个值:</p>
<pre>repeat($str, $qty) {
    if ($qty &lt; 1) {
        return '';
    }
  
    $ret = '';
  
    for $i in 1..$qty {
        $ret += $str;
    }
  
    $ret;
}

h1:before{
    content: repeat(ha, 5);
}</pre>
<p>CSS输出:</p>
<pre>h1:before {
  content: 'hahahahaha';
}</pre>
<h3>混合蛋白</h3>
<p>混合与函数非常相似，但有以下区别:</p>
<ul>
<li>它们没有返回值</li>
<li>由于没有返回值，它们不能用作变量或属性的值</li>
<li>mixin的主体中可以有CSS属性，这些属性将在调用mixin的地方呈现</li>
</ul>
<pre>square($side) {
    width: $side;
    height: $side;
}

.card{
    square(20rem);
    background-color: #3C3;
}</pre>
<p>CSS输出:</p>
<pre>.card {
  width: 20rem;
  height: 20rem;
  background-color: #3c3;
}</pre>
<h3>进口</h3>
<p>你可能已经知道CSS <code>@import</code> <a class="markup--anchor markup--p-anchor" href="https://developer.mozilla.org/en-US/docs/Web/CSS/At-rule" target="_blank" rel="noopener noreferrer" data-href="https://developer.mozilla.org/en-US/docs/Web/CSS/At-rule"> at-rule </a>，它允许样式表<em> X </em>包含外部样式表<em> Y </em>。这是浏览器在解释样式表的过程中完成的，会触发一个额外的HTTP请求。</p>
<p>预处理程序使浏览器不必为每个包含的CSS做这些额外的请求。当您导入一个Sass、Stylus或Less文件时，包含的样式表和包含它的样式表将成为一个单独的CSS包(编译后)加载到您的应用程序中。</p>
<p>为了更清楚，这里有一个简单的例子:</p>
<pre>// color-scheme.styl
$base-color = #555;
$cta-color = #D22;</pre>
<pre>// another-thing.styl
.whatever {
    padding: 2rem;
    background-color: $cta-color;
}</pre>
<pre>// example.styl
@import 'color-scheme';
@import 'another-thing';

.footer {
    background-color: $base-color;
    color: white;
}</pre>
<p>主文件<code>example.styl</code>导入另外两个文件。在第一个例子中，我们可以看到两个被定义的变量，从这一刻起，这两个变量将可以被全局访问。第二个文件定义了一个CSS规则，它使用了我们之前定义的一个变量。编译后，CSS输出如下所示:</p>
<pre>.whatever {
  padding: 2rem;
  background-color: #d22;
}
.footer {
  background-color: #555;
  color: #fff;
}</pre>
<p>自然，在现实世界中，最终的包在提供给用户之前会被缩小和压缩。</p>
<h3>本地函数</h3>
<p>在许多可能的用途中，本机函数帮助我们处理:</p>
<ul>
<li>颜色(例如，变暗、饱和度、alpha、亮度)</li>
<li>列表(例如，<code>push</code>、<code>pop</code>、<code>index</code>、<code>shift</code>、<code>keys</code>)</li>
<li>不同类型的值和单位(如<code>typeof</code>、<code>unit</code>)</li>
<li>数学运算(如<code>round</code>、<code>sin</code>、<code>floor</code>、<code>abs</code>)</li>
<li>字符串(例如，<code>split</code>、<code>substr</code>、<code>slice</code>)</li>
</ul>
<p>本机函数既可以用来组成mixins自定义函数逻辑，也可以直接用在规则体中。</p>
<h2>后处理器(或者只是“处理器”？)</h2>
<p>理论上，后处理器是一种工具，其输入是CSS文件，其输出是转换后的CSS文件。注意，与前处理器不同，后处理器不涉及另一种语言；只是普通的CSS。</p>
<p>那么，我们在谈论什么样的转变呢？嗯，很多种。以下是后处理插件的一些好例子:</p>
<ul>
<li><strong> <a href="https://autoprefixer.github.io/" target="_blank" rel="noopener noreferrer">自动前缀</a> : </strong>根据您想要支持的浏览器自动包含供应商前缀</li>
<li><strong> <a href="https://github.com/borodean/postcss-assets" target="_blank" rel="noopener noreferrer"> PostCSS资产</a> : </strong>处理资产路径、缓存破坏、图像尺寸和base64图像内联</li>
<li><strong>T1】CSS nano:</strong>缩小你的CSS</li>
<li><strong> <a href="https://github.com/jonathantneal/postcss-font-magician" target="_blank" rel="noopener noreferrer">字体魔术师</a> : </strong>自动生成@font-faces</li>
<li><strong><a href="https://github.com/zaim/postcss-color-palette" target="_blank" rel="noopener noreferrer">postcss-color-palette</a>:</strong>允许您使用本地css颜色名称，如蓝色、紫色、浅绿色、黄色和其他颜色，作为您自己调色板中颜色的别名，用您指定的颜色替换每个引用</li>
<li><strong> <a href="https://stylelint.io/" target="_blank" rel="noopener noreferrer"> stylelint </a> : </strong>分析你的代码，提出修正和改进的建议，并且(如果你愿意)应用其中的一些</li>
<li><strong> <a href="https://github.com/2createStudio/postcss-sprites" target="_blank" rel="noopener noreferrer"> postcss-sprites </a> : </strong>从你的样式表中提取图像，生成一个包含所有图像的sprite，并替换原始引用以使用创建的sprite</li>
</ul>
<p>以上例子都是<a href="https://postcss.org/" target="_blank" rel="noopener noreferrer"> PostCSS </a>插件。当谈到后处理器时，许多人认为PostCSS是最先想到的名字。</p>
<p>然而，在开发社区中有一些关于术语“后处理器”含义的讨论一些人认为“post”前缀<a href="https://medium.com/@ddprrt/deconfusing-pre-and-post-processing-d68e3bd078a3" target="_blank" rel="nofollow noopener noreferrer">只有在处理发生在浏览器中</a>才有意义(例如像<a class="markup--anchor markup--p-anchor" href="https://leaverou.github.io/prefixfree/" target="_blank" rel="noopener noreferrer" data-href="https://leaverou.github.io/prefixfree/">——无前缀</a>)，而不是在开发时间之前。</p>
<p>其他人<a href="https://alistapart.com/column/what-will-save-us-from-the-dark-side-of-pre-processors/#section5" target="_blank" rel="noopener noreferrer">不同意“有效CSS in，有效CSS out”的前提</a>，因为许多后处理插件使用不存在的属性或无效的CSS语法来实现它们的魔力。一些插件甚至模仿典型的预处理器行为，支持混合、继承、循环、条件和其他CSS本身不支持的特性。</p>
<p>下面是一些使用CSS非标准语法和属性的后处理插件的例子:</p>
<ul>
<li><strong> <a href="https://github.com/jonathantneal/precss" target="_blank" rel="noopener noreferrer"> PreCSS </a> : </strong>允许使用类似Sass的标记，具有条件、循环、导入、扩展、混合、选择器嵌套和其他特性</li>
<li><strong> <a href="https://github.com/jonathantneal/postcss-short" target="_blank" rel="noopener noreferrer"> Short </a> : </strong>扩展了原生CSS shorthands，并提供了自己的shorthands，以支持更简洁的规则</li>
<li><strong> <a href="https://github.com/jonathantneal/postcss-write-svg" target="_blank" rel="noopener noreferrer">编写SVG </a> : </strong>让你直接在CSS中编写SVG</li>
<li><strong> <a href="https://github.com/peterramsing/lost" target="_blank" rel="noopener noreferrer"> LostGrid </a> : </strong>一个基于<code><a href="https://developer.mozilla.org/en-US/docs/Web/CSS/calc" target="_blank" rel="noopener noreferrer">calc()</a></code> CSS函数的网格系统。取决于非标准属性的使用(如<code>lost-column</code>、<code>lost-row</code>、<code>lost-utility</code>、<code>lost-center</code>)</li>
</ul>
<figure class="graf graf--figure graf--layoutOutsetCenter"/>
<p class="graf graf--p">在开发人员大量采用PostCSS和<a class="markup--anchor markup--p-anchor" href="https://www.postcss.parts/" target="_blank" rel="noopener noreferrer" data-href="https://www.postcss.parts/">数百个用于各种目的的插件</a>之后，项目维护人员自己意识到“后处理器”这个术语不再有意义，<a class="markup--anchor markup--p-anchor" href="https://twitter.com/PostCSS/status/626046993006239744" target="_blank" rel="noopener noreferrer" data-href="https://twitter.com/PostCSS/status/626046993006239744">正式停止使用它</a>。</p>
<p class="graf graf--p">独立于关于概念名称的语义争论，像PostCSS这样的工具的潜力是毋庸置疑的，并且由于其巨大的灵活性，它既可以与预处理器(像Sass、Stylus或更少)一起使用，也可以作为它的替代品(例如，通过像<a class="markup--anchor markup--p-anchor" href="https://github.com/jonathantneal/precss" target="_blank" rel="noopener noreferrer" data-href="https://github.com/jonathantneal/precss"> PreCSS </a>这样的插件)。</p>
<h2>CSS-in-JS</h2>
<p>React爆炸在前端开发人员中普及了许多概念，如函数式编程、反应式编程、Flux architecture(及其最著名的化身Redux)等。</p>
<p>React世界中诞生的最新趋势之一是CSS-in-JS，即用JavaScript编写样式代码，在运行时呈现最终的CSS。这一类别中最受欢迎的库当然是<a class="markup--anchor markup--p-anchor" href="https://www.styled-components.com/" target="_blank" rel="noopener noreferrer" data-href="https://www.styled-components.com/"> styled-components </a>，但是还有其他相关的选项，比如<a class="markup--anchor markup--p-anchor" href="https://github.com/cssinjs/jss" target="_blank" rel="noopener noreferrer" data-href="https://github.com/cssinjs/jss"> JSS </a>、<a class="markup--anchor markup--p-anchor" href="https://github.com/FormidableLabs/radium" target="_blank" rel="noopener noreferrer" data-href="https://github.com/FormidableLabs/radium">镭</a>、<a class="markup--anchor markup--p-anchor" href="https://github.com/emotion-js/emotion" target="_blank" rel="noopener noreferrer" data-href="https://github.com/emotion-js/emotion">情感</a>和<a class="markup--anchor markup--p-anchor" href="https://github.com/Khan/aphrodite" target="_blank" rel="noopener noreferrer" data-href="https://github.com/Khan/aphrodite">阿芙罗狄蒂</a>，这里仅列举几个。</p>
<p>脸书的前端工程师Christopher "Vjeux" Chedeau 通常被认为是CSS-in-JS的先驱。他在2014年为React团队工作时有了这个想法，正如你在这个演示中看到的<a class="markup--anchor markup--p-anchor" href="https://speakerdeck.com/vjeux/react-css-in-js" target="_blank" rel="noopener noreferrer" data-href="https://speakerdeck.com/vjeux/react-css-in-js"/>。</p>
<p>当Vjeux创建CSS-in-JS时，其最初的目标是解决七个CSS问题:</p>
<ol>
<li><strong>全局命名空间:</strong>每个CSS类都是一个全局标识符，由于是在JavaScript中，这就容易产生一些不良冲突。</li>
<li><strong>依赖关系:</strong>如果一个组件<em> A </em>依赖于一个无法加载的样式表<em> B </em>，很可能你会看到一个外观破损的组件。这通常足以提醒维护人员有问题。但是，如果这个样式表已经加载到应用程序的另一个地方，组件<em> A </em>就不会有任何样式问题，它的开发人员也不会怀疑有错误。</li>
<li><strong>死代码消除:</strong>很难跟踪和删除不再使用的类。</li>
<li><strong>缩小:</strong>标准的CSS缩小过程是有限的，因为如果不更新HTML中现有的引用，就不能重命名类。</li>
<li><strong>共享常量:</strong>经常需要在JavaScript和CSS之间共享值。如今我们可能有CSS自定义属性，但在2014年，没有优雅的方法来解决这个问题。</li>
<li><strong>非确定性解析:</strong>一个HTML元素可以在多个规则中将一个给定的CSS属性设置为不同的值。如果这些规则的选择器具有相同的特异性，最后一个被解释的将“赢得战斗”，正如<a href="https://blog.logrocket.com/how-css-works-understanding-the-cascade-d181cd89a4d8/" target="_blank" rel="noopener noreferrer">级联行为</a>所述。如果这些规则中的一个是在异步加载的样式表中定义的，就不可能预测最后读取的是哪一个。</li>
<li><strong>隔离:</strong>假设你正在使用一个由另一个团队创建和维护的组件，但是你想创建一个这个组件的变体，并做一些视觉上的改变，比如一个按钮的背景颜色。理想情况下，您应该与负责团队协商这个变更的创建。然而，更有可能的是，需要这种改变的工程师将自己做出改变，分析组件的内部结构，并通过选择器对其进行样式化。这是一个问题，因为HTML中的任何更改都可能破坏其他团队所做的定制(这些定制可能依赖于特定的结构才能正常工作)。</li>
</ol>
<h3>实际例子</h3>
<p>我将使用样式化组件来举例说明这个概念:</p>
<pre>import React, { Component } from 'react';
import styled from 'styled-components';

const Title = styled.h1`
    color: white;
    font-size: 2rem;
`;

const Content = styled.div`
    background: blue;
    padding: 2rem;
`;

class Example extends Component {
    render() {
        return (
                
            
        );
    }
}

export default Example;</pre>
<p>对于那些对React有所了解的人来说，上面的例子不言自明。常量<code>Title</code>和<code>Content</code>是普通的React组件，但是具有自定义样式。</p>
<p><code>styled.div</code>符号是ES2015的原生功能，它被称为<a class="markup--anchor markup--p-anchor" href="https://wesbos.com/tagged-template-literals/" target="_blank" rel="noopener noreferrer" data-href="https://wesbos.com/tagged-template-literals/">标记模板文字</a>。在这种情况下，它允许我们根据组件的属性动态处理组件的样式，如下例所示:</p>
<pre>const SignInButton = styled.button`
  font-size: ${
    props =&gt; props.standout ? '2rem' : '1.4rem'
  };
`;</pre>
<h3>CSS-in-JS:一个创新而有争议的想法</h3>
<p>虽然像styled-components这样的库确实被社区广泛认可和使用，但是大量开发人员对CSS-in-JS概念有相当大的不信任，或者<a class="markup--anchor markup--p-anchor" href="https://medium.com/@gajus/stop-using-css-in-javascript-for-web-development-fa32fb873dcc" target="_blank" rel="noopener noreferrer" data-href="https://medium.com/@gajus/stop-using-css-in-javascript-for-web-development-fa32fb873dcc">甚至拒绝</a>，许多<a class="markup--anchor markup--p-anchor" href="https://gomakethings.com/whats-wrong-with-css-in-js/" target="_blank" rel="noopener noreferrer" data-href="https://gomakethings.com/whats-wrong-with-css-in-js/">质疑其最初的目标</a>。这有很多原因，但最明显的原因是在JavaScript文件中定义样式的想法带来的不适。</p>
<p>事实是，CSS-in-JS旨在解决的一些问题<a class="markup--anchor markup--p-anchor" href="https://gomakethings.com/alternatives-to-css-in-js/" target="_blank" rel="noopener noreferrer" data-href="https://gomakethings.com/alternatives-to-css-in-js/">如今已经有了其他解决方案</a>。<a class="markup--anchor markup--p-anchor" href="https://github.com/css-modules/css-modules" target="_blank" rel="noopener noreferrer" data-href="https://github.com/css-modules/css-modules"> CSS模块</a>就是一个很好的例子，它允许你以优雅的方式模块化样式表，防止全局标识符之间的冲突。</p>
<p>此外，它们还可以与预处理器结合使用。命名约定的一致使用，比如<a class="markup--anchor markup--p-anchor" href="http://getbem.com/introduction/" target="_blank" rel="noopener noreferrer" data-href="http://getbem.com/introduction/"> BEM </a>，也可以防止这些问题。CSS自定义属性，已经有了一个<a class="markup--anchor markup--p-anchor" href="https://caniuse.com/#feat=css-variables" target="_blank" rel="noopener noreferrer" data-href="https://caniuse.com/#feat=css-variables">像样的浏览器支持</a>，让你在CSS和JavaScript之间共享值。诸如此类…</p>
<h2>结论</h2>
<p>普通CSS有许多现代的替代方案。其中没有完美和通用的解决方案，每一个都有自己的优点和缺点。由开发人员为每个项目选择最适合的。</p>
<p>重要的是不要被相关规模或合理增长前景的项目中的普通CSS的限制所束缚，因为不知道更好的可用选项而忍受维护样式表的痛苦。</p><div class="code-block code-block-17">
<div class="blog-plug inline-plug react-plug" vwo-el-id="26283398190">
<h2 vwo-el-id="41600691720">使用LogRocket消除传统反应错误报告的噪音</h2>
<a href="https://lp.logrocket.com/blg/react-signup-issue-free" target="_blank" vwo-el-id="19356441070">LogRocket
</a><p>是一款React analytics解决方案，可保护您免受数百个误报错误警报的影响，只针对少数真正重要的项目。LogRocket告诉您React应用程序中实际影响用户的最具影响力的bug和UX问题。</p><a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="19356441380">
<img class="first-react-image alignnone size-full wp-image-46 jetpack-lazy-image jetpack-lazy-image--handled" src="../Images/f300c244a1a1cf916df8b4cb02bec6c6.png" vwo-el-id="18272717540" data-lazy-loaded="1" data-original-src="https://files.readme.io/27c94e7-Image_2017-06-05_at_9.46.04_PM.png"/>
</a>
<a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="19356441690">
<img class="second-react-image alignnone size-full wp-image-46 jetpack-lazy-image jetpack-lazy-image--handled" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" vwo-el-id="30720362350" data-lazy-loaded="1" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/>
</a>
<a href="https://lp.logrocket.com/blg/react-signup-issue-free" target="_blank" rel="noopener noreferrer" vwo-el-id="35866400580">LogRocket
</a><p>自动聚合客户端错误、反应错误边界、还原状态、缓慢的组件加载时间、JS异常、前端性能指标和用户交互。然后，LogRocket使用机器学习来通知您影响大多数用户的最具影响力的问题，并提供您修复它所需的上下文。</p><p vwo-el-id="28675661060">关注重要的React bug—<a class="signup" href="https://lp.logrocket.com/blg/react-signup-issue-free" target="_blank" rel="noopener noreferrer" vwo-el-id="40093418840">今天就试试LogRocket】。</a></p>
</div></div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
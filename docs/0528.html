<html>
<head>
<title>React and Stripe payment system tutorial - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>React和Stripe支付系统教程- LogRocket博客</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/react-stripe-payment-system-tutorial/#0001-01-01">https://blog.logrocket.com/react-stripe-payment-system-tutorial/#0001-01-01</a></blockquote><div><article class="article-post">
<p><strong> <em>编者按</em> </strong> : <em>本帖最后更新于2021年9月14日，旨在改进代码并更新任何过时的信息。</em></p>
<p>Stripe是一套API，可以轻松设置在线支付处理，在本文中，我们将利用Stripe创建一个使用React的基本支付系统。</p>
<p>无论您是在实施基于订阅的服务、电子商务商店还是众筹解决方案，Stripe都能提供完成任务的灵活性。我们将建立一个小型的概念验证支付系统，以实现网站上的一次性购买。</p>
<p>本教程结束时，您应该能够在React应用程序中设置处理在线支付的后端和前端。</p>
<h2>条带化和反应教程要求</h2>
<p>本教程要求您具备以下条件:</p>
<ol>
<li>安装在计算机上的Node.js</li>
<li>Stripe开发人员帐户</li>
<li>Express.js的基础知识</li>
<li><a href="https://blog.logrocket.com/practical-react-hooks-how-to-refactor-your-app-to-use-hooks-b1867e7b0a53/">反应钩的基础知识</a></li>
</ol>
<p>如果没有安装Node，可以从<a href="https://nodejs.org/en/">官网</a>获取最新版本。本教程写的所有代码<a href="https://github.com/philipszdavido/react-stripe-payment">都可以在这里</a>访问。</p>
<h2>设置Stripe帐户需要什么？</h2>
<p>如果你没有Stripe开发者账户，你可以在这里注册一个<a href="https://dashboard.stripe.com/register">账户免费使用。注册后，完成以下步骤进行设置:</a></p>
<ul>
<li>在<strong>上选择<strong>开发者集成</strong>你想如何开始？</strong>莫代尔</li>
<li>选择<strong>在下一个模式下仅接受付款</strong></li>
<li>勾选下一模式的<strong>一次性付款</strong>选项</li>
<li>最后，检查<strong>在最后一个模型上构建一个自定义支付流</strong></li>
</ul>
<p>您现在应该已经建立了一个基本帐户。您可以通过点击页面左上角的<strong>添加名称</strong>链接来更新帐户名称。</p>
<p>您需要从仪表板上复制您的可发布密钥和秘密密钥，并将它们存储在某个地方，因为我们很快就会需要它们。</p>
<p><img data-attachment-id="69319" data-permalink="https://blog.logrocket.com/react-stripe-payment-system-tutorial/copy-test-publishable-secret-keys/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2019/11/Copy-Test-Publishable-Secret-Keys.png" data-orig-size="730,262" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Copy test publishable secret keys" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2019/11/Copy-Test-Publishable-Secret-Keys-300x108.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2019/11/Copy-Test-Publishable-Secret-Keys.png" decoding="async" class="aligncenter size-full wp-image-69319 jetpack-lazy-image" src="../Images/ffa10c94a7e4fbbab179c99677e2c231.png" alt="Copy Your Test Publishable And Secret Keys" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2019/11/Copy-Test-Publishable-Secret-Keys.png 730w, https://blog.logrocket.com/wp-content/uploads/2019/11/Copy-Test-Publishable-Secret-Keys-300x108.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2019/11/Copy-Test-Publishable-Secret-Keys.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/11/Copy-Test-Publishable-Secret-Keys.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="69319" data-permalink="https://blog.logrocket.com/react-stripe-payment-system-tutorial/copy-test-publishable-secret-keys/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2019/11/Copy-Test-Publishable-Secret-Keys.png" data-orig-size="730,262" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Copy test publishable secret keys" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2019/11/Copy-Test-Publishable-Secret-Keys-300x108.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2019/11/Copy-Test-Publishable-Secret-Keys.png" decoding="async" loading="lazy" class="aligncenter size-full wp-image-69319" src="../Images/ffa10c94a7e4fbbab179c99677e2c231.png" alt="Copy Your Test Publishable And Secret Keys" srcset="https://blog.logrocket.com/wp-content/uploads/2019/11/Copy-Test-Publishable-Secret-Keys.png 730w, https://blog.logrocket.com/wp-content/uploads/2019/11/Copy-Test-Publishable-Secret-Keys-300x108.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/11/Copy-Test-Publishable-Secret-Keys.png"/></noscript>
<h2>用Express.js构建支付服务器</h2>
<p>在我们继续构建React应用程序之前，我们需要设置一个服务器来处理支付请求。</p>
<p>我们需要在Express服务器上设置一个RESTful端点，它将充当React代码和Stripe后端之间的中间人。如果您以前从未构建过API，不要担心——这将是非常基础的，因为我们没有实现生产就绪的后端。</p>
<p>让我们开始吧。首先，创建一个新的项目文件夹，想怎么命名就怎么命名(我用<code>react-stripe-payment</code>)。在文件夹中打开您的终端并运行<code>npm init -y</code>。</p>
<p>接下来，通过运行<code>npm install express dotenv body-parser stripe</code>安装依赖项，并通过运行<code>mkdir src</code>在根文件夹下创建一个<code>src</code>文件夹。</p>
<h3>使用<code>server.js</code>创建服务器</h3>
<p>让我们创建一个服务器来监听支付请求。在<code>src</code>文件夹下创建一个名为<code>server.js</code>的新文件，并将以下内容粘贴到其中:</p>
<pre>const path = require('path')
const express = require('express')
const bodyParser = require('body-parser')
require('dotenv').config()
const postCharge = require('./stripe')

const app = express()
const router = express.Router()
const port = process.env.PORT || 7000

router.post('/stripe/charge', postCharge)
router.all('*', (_, res) =&amp;gt;
  res.json({ message: 'please make a POST request to /stripe/charge' })
)
app.use((_, res, next) =&amp;gt; {
  res.header('Access-Control-Allow-Origin', '*')
  res.header(
    'Access-Control-Allow-Headers',
    'Origin, X-Requested-With, Content-Type, Accept'
  )
  next()
})
app.use(bodyParser.json())
app.use('/api', router)
app.use(express.static(path.join(__dirname, '../build')))

app.get('*', (_, res) =&amp;gt; {
  res.sendFile(path.resolve(__dirname, '../build/index.html'))
})

app.listen(port, () =&amp;gt; console.log(`server running on port ${port}`))
</pre>
<p>让我们一节一节地分解这个文件。在这里，我们正在导入所需的包。注意，除了从名为<code>stripe</code>的文件导入的<code>postCharge</code>，它们都是第三方导入。我们稍后将创建该文件:</p>
<pre>const path = require('path')
const express = require('express')
const bodyParser = require('body-parser')
require('dotenv').config()
const postCharge = require('./stripe')
</pre>
<p><code>dotenv</code>允许我们<a href="https://blog.logrocket.com/customizing-node-js-env-files/">从节点进程</a>中读取敏感信息，这样我们就不必在代码中硬编码秘密值。</p>
<p>然后，我们将一个新的Express实例初始化到一个名为<code>app</code>的变量中，并创建一个新的<code>Router</code>实例，将其存储在一个名为<code>router</code>的变量中。这是我们将用来定义支付端点的内容:</p>
<pre>const app = express()
const router = express.Router()
const port = process.env.PORT || 7000
</pre>
<p>然后，我们初始化一个名为<code>port</code>的新变量，并从节点进程(<code>process.env.PORT</code>)中给它赋值，如果是<code>undefined</code>，就给它赋值<code>7000</code>。</p>
<p>还记得我们之前初始化的路由器吗？在第一行中，我们设置了一个名为<code>/stripe/charge</code>的端点，并分配<code>postCharge</code>来处理这个路由的所有<code>POST</code>请求。</p>
<p>然后，我们可以捕捉所有其他对服务器的请求，并用一个JSON对象进行响应，该对象包含一条将用户定向到适当端点的消息:</p>
<pre>router.post('/stripe/charge', postCharge)
router.all('*', (_, res) =&amp;gt;
  res.json({ message: 'please make a POST request to /stripe/charge' })
)
app.use((_, res, next) =&amp;gt; {
  res.header('Access-Control-Allow-Origin', '*')
  res.header(
    'Access-Control-Allow-Headers',
    'Origin, X-Requested-With, Content-Type, Accept'
  )
  next()
})
app.use(bodyParser.json())
app.use('/api', router)
app.use(express.static(path.join(__dirname, '../build')))
</pre>
<p>接下来，我们在app实例上定义一个中间件来为所有请求启用CORS。在下面一行中，我们附加了另一个中间件，使我们能够从请求体中解析JSON对象。</p>
<p>我们告诉我们的应用程序实例使用<code>router</code>实例来处理对<code>/api</code>端点的所有请求，然后告诉Express提供<code>/build</code>文件夹。这个文件夹将保存应用程序前端的编译代码。</p>
<p>我们还需要告诉应用程序实例通过服务位于<code>/build</code>文件夹中的<code>index.html</code>文件来处理所有的<code>GET</code>请求。这就是我们如何<a href="https://create-react-app.dev/docs/deployment/#other-solutions">在生产</a>中为前端服务。</p>
<p>最后，我们在前面定义的端口上启动服务器，并在成功启动时向控制台记录一条消息:</p>
<pre>app.get('*', (_, res) =&amp;gt; {
  res.sendFile(path.resolve(__dirname, '../build/index.html'))
})

app.listen(port, () =&amp;gt; console.log(`server running on port ${port}`))
</pre>
<h3>使用<code>stripe.js</code>创建<code>postCharge</code>处理程序</h3>
<p>我们现在将创建我们在上面的<code>server.js</code>中需要的<code>postCharge</code>处理程序。在<code>src</code>文件夹下，创建一个新文件<code>stripe.js</code>，并粘贴以下内容:</p>
<pre>const stripe = require('stripe')(&amp;lt;your_secret_key&amp;gt;)

async function postCharge(req, res) {
  try {
    const { amount, source, receipt_email } = req.body

    const charge = await stripe.charges.create({
      amount,
      currency: 'usd',
      source,
      receipt_email
    })

    if (!charge) throw new Error('charge unsuccessful')

    res.status(200).json({
      charge,
      message: 'charge posted successfully'
    })
  } catch (error) {
    res.status(500).json({
      message: error.message
    })
  }
}

module.exports = postCharge
</pre>
<p>我们来分解一下。这里，我们初始化一个新的Stripe实例，方法是需要<code>stripe</code>包并用我们之前作为字符串复制的秘密密钥调用它。我们将这个实例保存在一个名为<code>stripe</code>的变量中:</p>
<pre>const stripe = require('stripe')(&amp;lt;your_secret_key&amp;gt;)
</pre>
<p>然后我们创建一个名为<code>postCharge</code>的新函数。这个函数是一个请求处理器，所以我们必须接受两个参数:<code>req</code>和<code>res</code>。</p>
<p>在这个函数中打开一个<code>try catch</code>块，我们析构了所有我们期望与请求对象的请求一起发送的变量；在这种情况下，这些变量是<code>amount</code>、<code>source</code>和<code>receipt_email</code>。</p>
<p>然后，我们必须创建一个名为<code>charge</code>的新变量，它保存对Stripe API的异步调用的结果，以创建新的费用(<code>stripe.charges.create</code>):</p>
<pre>async function postCharge(req, res) {
  try {
    const { amount, source, receipt_email } = req.body

    const charge = await stripe.charges.create({
      amount,
      currency: 'usd',
      source,
      receipt_email
    })
</pre>
<p>如果Stripe调用的结果是一个falsy值，在这种情况下，这意味着我们的支付请求失败，我们抛出一个新的错误，消息为<code>charge unsuccessful</code>:</p>
<pre>if (!charge) throw new Error('charge unsuccessful')
</pre>
<p>否则，我们用一个<code>200</code>状态代码和一个包含消息和费用对象的JSON对象来响应请求。</p>
<pre>res.status(200).json({
  charge,
  message: 'charge posted successfully'
})
</pre>
<p>在<code>catch</code>块中，我们拦截所有其他错误，并将其发送给客户端，同时附上一个<code>500</code>状态代码和一条包含错误消息的消息。</p>
<p>在文件的最后，我们使用<code>module.exports</code>导出<code>postCharge</code>函数:</p>
<pre>} catch (error) {
    res.status(500).json({
      message: error.message
    })
  }
}

module.exports = postCharge
</pre>
<p>这就是支付服务器的全部内容。当然，这不是生产就绪，不应该在处理实际支付的实际应用程序中使用，但对于我们当前的用例来说已经足够了。让我们转到前端。</p>
<h2>如何用React构建一个前端？</h2>
<p>既然我们已经完成了支付服务器的构建，是时候充实前端了。它不会是任何花哨的东西，因为我试图保持这个教程咬大小。</p><div class="code-block code-block-54">
<hr/>
<h3>更多来自LogRocket的精彩文章:</h3>

<hr/></div>
<p>以下是该应用程序的不同组件:</p>
<ul>
<li>路由器组件</li>
<li>产品列表组件</li>
<li>结帐表单组件</li>
</ul>
<p>让我们开始吧。</p>
<p>首先，运行以下命令安装所需的软件包:</p>
<pre>npm install axios babel-polyfill history parcel parcel-bundler react react-dom react-router-dom react-stripe-elements
</pre>
<p>然后，在项目根目录中，运行以下命令:</p>
<pre>mkdir public &amp;amp;&amp;amp; touch public/index.html
</pre>
<p>这将创建一个名为<code>public</code>的文件夹，并在这个新文件夹中创建一个<code>index.html</code>文件。打开<code>index.html</code>文件并粘贴以下内容:</p>
<pre>&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
  &lt;head&gt;
    &lt;meta charset="utf-8" /&gt;
    &lt;meta name="viewport" content="width=device-width, initial-scale=1" /&gt;
    &lt;meta name="description" content="React + Stripe" /&gt;
    &lt;title&gt;React and Stripe Payment&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;noscript&gt;You need to enable JavaScript to run this app.&lt;/noscript&gt;
    &lt;div id="root"&gt;&lt;/div&gt;
    &lt;script src="https://js.stripe.com/v3/"&gt;&lt;/script&gt;
    &lt;script src="../src/index.js"&gt;&lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;
</pre>
<p>如果您已经熟悉React，这应该不是什么新鲜事；这简直就是我们app的切入点。还要注意，我们在第一个<code>&lt;script&gt;</code>标签中导入了Stripe SDK——Stripe SDK的导入必须在我们自己的代码之前。</p>
<p>在<code>src</code>文件夹中，运行以下命令:</p>
<pre>touch src/index.js &amp;amp;&amp;amp; touch src/products.js
</pre>
<p>然后，打开<code>index.js</code>并粘贴以下内容:</p>
<pre>import React from 'react'
import ReactDOM from 'react-dom'
import App from './components/App'
import 'babel-polyfill'

const rootNode = document.querySelector('#root')
ReactDOM.render(&amp;lt;App /&amp;gt;, rootNode)
</pre>
<p>现在我们需要从某个地方获取产品列表。通常，这可能来自数据库或一些API，但是对于这个简单的用例，我们可以在一个JavaScript文件中硬编码两到三个产品。这就是为什么我们需要<code>products.js</code>。打开它并粘贴以下内容:</p>
<pre>export const products = [
  {
    name: 'Rubber Duck',
    desc: `Rubber ducks can lay as many eggs as the best chicken layers, and they
  are fun to watch with their antics in your backyard, your barnyard, or
  your pond.`,
    price: 9.99,
    img:
      'https://encrypted-tbn0.gstatic.com/images?q=tbn%3AANd9GcSqkN8wkHiAuT2FQ14AsJFgihZDzKmS6OHQ6eMiC63rW8CRDcbK',
    id: 100
  },
  {
    name: 'Chilli Sauce',
    desc: `This Chilli Sauce goes well with some nice roast rubber duck. Flavored with
    the best spices and the hottest chillis, you can rest assured of a tasty Sunday
    rubber roast.`,
    price: 12.99,
    img:
      'https://encrypted-tbn0.gstatic.com/images?q=tbn%3AANd9GcRTREm1dEzdI__xc6O8eAz5-4s88SP-Gg9dWYMkBKltGMi84RW5',
    id: 101
  }
]
</pre>
<p>这是一系列可供购买的产品。我们可以添加任意多的组件，然后继续创建组件。</p>
<p>从项目根目录运行<code>mkdir src/components</code>。这将在<code>src</code>文件夹中创建一个名为<code>components</code>的新文件夹来存放我们的React组件。让我们继续创建第一个组件。</p>
<h3>创建<code>App.jsx</code>组件</h3>
<p>这是根组件，将路由到我们的应用程序中的各个页面。首先在<code>components</code>文件夹中创建一个名为<code>App.jsx</code>的新文件，然后粘贴以下内容:</p>
<pre>import React, { useState } from 'react'
import { Router, Route, Switch } from 'react-router-dom'
import { createBrowserHistory } from 'history'
import Products from './Products'
import Checkout from './Checkout'
import { products } from '../products'

const history = createBrowserHistory()

const App = () =&gt; {
  const [selectedProduct, setSelectedProduct] = useState(null)

  return (
    &lt;Router history={history}&gt;
      &lt;Switch&gt;
        &lt;Route
          exact
          path="/"
          render={() =&gt; (
            &lt;Products
              products={products}
              selectProduct={setSelectedProduct}
              history={history}
            /&gt;
          )}
        /&gt;
        &lt;Route
          path="/checkout"
          render={() =&gt; (
            &lt;Checkout
              selectedProduct={selectedProduct}
              history={history}
            /&gt;
          )}
        /&gt;
      &lt;/Switch&gt;
    &lt;/Router&gt;
  )
}

export default App
</pre>
<p>我们来分解一下。</p>
<p>第一部分只是一堆依赖项导入。任何单页面React应用程序都需要前三个导入。接下来的两个导入是自定义组件，我们将在后面编写。</p>
<p>最后一个导入是我们之前创建的硬编码产品。我们将把它作为道具传递给<code>Products</code>组件:</p>
<pre>import React, { useState } from 'react'
import { Router, Route, Switch } from 'react-router-dom'
import { createBrowserHistory } from 'history'
import Products from './Products'
import Checkout from './Checkout'
import { products } from '../products'

const history = createBrowserHistory()
</pre>
<p>最后，我们从<code>history</code>包中创建一个新的历史实例，并将其保存在一个名为history的变量中。</p>
<p>然后我们创建一个名为<code>App</code>的新功能组件。<code>App</code>有一个名为<code>selectedProduct</code>的<a href="https://blog.logrocket.com/a-guide-to-usestate-in-react-ecb9952e406c/">状态变量</a>，保存当前选择购买的产品:</p>
<pre>const App = () =&gt; {
  const [selectedProduct, setSelectedProduct] = useState(null)

  return (
    &lt;Router history={history}&gt;
      &lt;Switch&gt;
        &lt;Route
          exact
          path="/"
          render={() =&gt; (
            &lt;Products
              products={products}
              selectProduct={setSelectedProduct}
              history={history}
            /&gt;
          )}
        /&gt;
        &lt;Route
          path="/checkout"
          render={() =&gt; (
            &lt;Checkout
              selectedProduct={selectedProduct}
              history={history}
            /&gt;
          )}
        /&gt;
      &lt;/Switch&gt;
    &lt;/Router&gt;
  )
}

export default App
</pre>
<p>我们返回一个<code>Router</code>实例，它定义了所有的路线和它们各自的组件。</p>
<p>在第一个路径<code>/</code>中，我们呈现了<code>Products</code>组件，并传入了三个属性:硬编码产品的列表、将产品设置为<code>App</code>状态的函数，以及使我们能够导航到新页面而不破坏浏览器历史的历史对象。</p>
<p>在第二个路径<code>/checkout</code>中，我们呈现了<code>Checkout</code>组件，并传入了两个道具:当前选择的产品和<code>history</code>对象。</p>
<p>在文件的最后，我们导出<code>App</code>组件作为默认导出。</p>
<h3>创建<code>Products.jsx</code>组件</h3>
<p><code>Products.jsx</code>组件负责将产品列表呈现给DOM，这相当简单。在<code>components</code>文件夹中创建一个名为<code>Products.jsx</code>的新文件，并粘贴如下内容:</p>
<pre>import React from 'react'
import './Products.scss'

const Products = ({ products, selectProduct, history }) =&gt; {
  const handlePurchase = prod =&gt; () =&gt; {
    selectProduct(prod)
    history.push('/checkout')
  }

  return products.map(prod =&gt; (
    &lt;div className="product" key={prod.id}&gt;
      &lt;section&gt;
        &lt;h2&gt;{prod.name}&lt;/h2&gt;
        &lt;p&gt;{prod.desc}&lt;/p&gt;
        &lt;h3&gt;{'$' + prod.price}&lt;/h3&gt;
        &lt;button type="button" onClick={handlePurchase(prod)}&gt;
          PURCHASE
        &lt;/button&gt;
      &lt;/section&gt;
      &lt;img src={prod.img} alt={prod.name} /&gt;
    &lt;/div&gt;
  ))
}

export default Products
</pre>
<p>注意，我们可以在这里得到<code><a href="https://github.com/philipszdavido/react-stripe-payment/blob/main/src/components/Products.scss">Products.scss</a></code> <a href="https://github.com/philipszdavido/react-stripe-payment/blob/main/src/components/Products.scss">的内容。</a></p>
<p>我们来分解一下。我们首先定义一个功能组件，它包含三个要素:</p>
<ul>
<li><code>products</code></li>
<li><code>selectProduct</code></li>
<li><code>history</code></li>
</ul>
<pre>const Products = ({ products, selectProduct, history }) =&gt; {
  const handlePurchase = prod =&gt; () =&gt; {
    selectProduct(prod)
    history.push('/checkout')
  }
</pre>
<p><code>products</code>是我们之前硬编码的产品阵列。稍后我们将映射这个数组，以将单个产品呈现到DOM中。</p>
<p><code>selectProduct</code>是接受单个产品对象的函数。它更新<code>App</code>组件的状态来保存这个产品，以便<code>Checkout</code>组件可以通过它的props访问它。</p>
<p><code>history</code>是允许我们安全导航到其他路线的历史对象。</p>
<p>然后我们定义了<code>handlePurchase</code>函数，当用户想要购买某个产品时会调用这个函数。它接受一个参数<code>prod</code>，并用这个参数调用<code>selectProduct</code>。</p>
<p>调用<code>selectProduct</code>后，通过调用<code>history.push</code>导航到<code>/checkout</code>路线。</p>
<p>是时候将产品呈现给DOM了。我们映射到<code>products</code>数组，对于数组中的每个产品，返回一组JSX:</p>
<pre>return products.map(prod =&gt; (
    &lt;div className="product" key={prod.id}&gt;
      &lt;section&gt;
        &lt;h2&gt;{prod.name}&lt;/h2&gt;
        &lt;p&gt;{prod.desc}&lt;/p&gt;
        &lt;h3&gt;{'$' + prod.price}&lt;/h3&gt;
        &lt;button type="button" onClick={handlePurchase(prod)}&gt;
          PURCHASE
        &lt;/button&gt;
      &lt;/section&gt;
      &lt;img src={prod.img} alt={prod.name} /&gt;
    &lt;/div&gt;
  ))
}

export default Products
</pre>
<p>JSX应该非常简单，并将在屏幕上显示如下图像:</p>
<p><img data-attachment-id="69317" data-permalink="https://blog.logrocket.com/react-stripe-payment-system-tutorial/rubber-duck-chilli-sauce-product-images/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2019/11/Rubber-Duck-Chilli-Sauce-Product-Images.png" data-orig-size="730,747" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Rubber duck chilli sauce product images" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2019/11/Rubber-Duck-Chilli-Sauce-Product-Images-293x300.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2019/11/Rubber-Duck-Chilli-Sauce-Product-Images.png" decoding="async" class="aligncenter size-full wp-image-69317 jetpack-lazy-image" src="../Images/eb117ee0c3832ad71baf68cd768e9571.png" alt="Rubber Duck Chilli Sauce Product Images" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2019/11/Rubber-Duck-Chilli-Sauce-Product-Images.png 730w, https://blog.logrocket.com/wp-content/uploads/2019/11/Rubber-Duck-Chilli-Sauce-Product-Images-293x300.png 293w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2019/11/Rubber-Duck-Chilli-Sauce-Product-Images.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/11/Rubber-Duck-Chilli-Sauce-Product-Images.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="69317" data-permalink="https://blog.logrocket.com/react-stripe-payment-system-tutorial/rubber-duck-chilli-sauce-product-images/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2019/11/Rubber-Duck-Chilli-Sauce-Product-Images.png" data-orig-size="730,747" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Rubber duck chilli sauce product images" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2019/11/Rubber-Duck-Chilli-Sauce-Product-Images-293x300.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2019/11/Rubber-Duck-Chilli-Sauce-Product-Images.png" decoding="async" loading="lazy" class="aligncenter size-full wp-image-69317" src="../Images/eb117ee0c3832ad71baf68cd768e9571.png" alt="Rubber Duck Chilli Sauce Product Images" srcset="https://blog.logrocket.com/wp-content/uploads/2019/11/Rubber-Duck-Chilli-Sauce-Product-Images.png 730w, https://blog.logrocket.com/wp-content/uploads/2019/11/Rubber-Duck-Chilli-Sauce-Product-Images-293x300.png 293w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/11/Rubber-Duck-Chilli-Sauce-Product-Images.png"/></noscript>
<h3>创建<code>Checkout.jsx</code>组件</h3>
<p>接下来，我们想要创建一个结帐页面，当用户点击产品上的<strong>购买</strong>按钮时，他们将被转到这个页面。</p>
<p>在<code>components</code>文件夹下创建一个<code>Checkout.jsx</code>文件，并将以下内容粘贴到其中:</p>
<pre>import React, { useEffect } from 'react'
import { StripeProvider, Elements } from 'react-stripe-elements'
import CheckoutForm from './CheckoutForm'

const Checkout = ({ selectedProduct, history }) =&gt; {
  useEffect(() =&gt; {
    window.scrollTo(0, 0)
  }, [])

  return (
    &lt;StripeProvider apiKey="pk_test_UrBUzJWPNse3I03Bsaxh6WFX00r6rJ1YCq"&gt;
      &lt;Elements&gt;
        &lt;CheckoutForm selectedProduct={selectedProduct} history={history} /&gt;
      &lt;/Elements&gt;
    &lt;/StripeProvider&gt;
  )
}

export default Checkout
</pre>
<p>这就是我们开始将Stripe引入组合的时候。在第二行，我们从本节开始时安装的<code>react-stripe-elements</code>包中导入了名为<code>StripeProvider</code>和<code>Elements</code>的东西。</p>
<p>我们的应用程序需要使用<code>StripeProvider</code>来访问条带对象；任何与Stripe对象交互的组件都必须是<code>StripeProvider</code>的子组件。</p>
<p><code><a href="https://blog.logrocket.com/integrating-stripe-react-stripe-js/">Elements</a></code> <a href="https://blog.logrocket.com/integrating-stripe-react-stripe-js/#stripe-elements">是一个React组件</a>，它包装了实际的结账表单。它有助于将一组<a href="https://stripe.com/payments/elements">条带元素</a>组合在一起，并使标记来自每个条带元素的所有数据变得容易。</p>
<p>组件本身相当简单。它接受两个道具，<code>selectedProduct</code>和<code>history</code>，并传递给我们接下来要创建的<code>CheckoutForm</code>组件。</p>
<p>还有一个<code>useEffect</code>调用，在页面第一次装载时将文档滚动到顶部。这是必要的，因为当我们切换路线时,<code>react-router-dom</code>保持先前的滚动状态。</p>
<p>请注意，我们正在将一个道具<code>apiKey</code>传递给<code>StripeProvider</code>。这个密钥是我们之前在设置Stripe时复制的可发布密钥。请注意，这个属性是必需的，因为它是向条带服务器验证我们的应用程序的一种方式。</p>
<h3>创建<code>CheckoutForm.jsx</code>组件</h3>
<p>这是我们将要创建的最后一个组件，也是最重要的。<code>CheckoutForm</code>组件保存输入，用于获取用户卡的详细信息，以及调用后端来处理支付费用。</p>
<p>为此，在<code>components</code>目录中创建一个名为<code>CheckoutForm.jsx</code>的新文件。我们将一节一节地检查这个文件的内容。</p>
<p>首先，我们将所需的包导入到文件中。注意从<code>react-stripe-elements</code>包的导入:</p>
<pre>import React, { useState } from 'react'
import { Link } from 'react-router-dom'
import {
  CardNumberElement,
  CardExpiryElement,
  CardCVCElement,
  injectStripe
} from 'react-stripe-elements'
import axios from 'axios'
import './CheckoutForm.scss'
...to be continued below...
</pre>
<p>这是一个谈论Stripe元素的好时机:Stripe元素是一组预构建的UI元素，允许我们收集用户的卡信息，而无需我们自己管理这些敏感信息。</p>
<p><code>react-stripe-elements</code>包是Stripe元素的包装器，它将这些元素公开为React组件，我们只需将它们插入到我们的应用程序中即可——无需从头开始创建它们。</p>
<p>我们将其中一些组件和一个高阶组件(HOC)，<code>injectStripe</code>一起导入到这个文件中。</p>
<p><code>injectStripe</code>基本上接受在<code>StripeProvider</code>组件中初始化的Stripe对象，并将该对象注入到任何用它包装的组件中。这是我们访问条带对象的方式。</p>
<p>然后我们导入一个名为<code>axios</code>的包。<a href="https://blog.logrocket.com/how-to-make-http-requests-like-a-pro-with-axios/"> Axios只是一个基于承诺的浏览器HTTP客户端</a>，我们将使用它与我们的支付服务器进行通信。我们可以从这里得到 <code><a href="https://github.com/philipszdavido/react-stripe-payment/blob/main/src/components/CheckoutForm.scss">CheckoutForm.scss</a></code> <a href="https://github.com/philipszdavido/react-stripe-payment/blob/main/src/components/CheckoutForm.scss">的</a><a href="https://github.com/philipszdavido/react-stripe-payment/blob/main/src/components/CheckoutForm.scss">内容</a>:</p>
<pre>...continued...
const CheckoutForm = ({ selectedProduct, stripe, history }) =&amp;gt; {
  if (selectedProduct === null) history.push('/')

  const [receiptUrl, setReceiptUrl] = useState('')

  const handleSubmit = async event =&amp;gt; {
    event.preventDefault()

    const { token } = await stripe.createToken()

    const order = await axios.post('http://localhost:7000/api/stripe/charge', {
      amount: selectedProduct.price.toString().replace('.', ''),
      source: token.id,
      receipt_email: '<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="6a091f191e05070f182a0f120b071a060f44090507">[email protected]</a>'
    })

    setReceiptUrl(order.data.charge.receipt_url)
  }
...to be continued...
</pre>
<p>接下来是实际的<code>CheckoutForm</code>组件本身。它需要三个道具:</p>
<ol>
<li><code>selectedProduct</code></li>
<li><code>stripe</code></li>
<li><code>history</code></li>
</ol>
<p><code>selectedProduct</code>是用户点击购买的产品。它来自根<code>App</code>组件的状态，并作为道具传递下来。</p>
<p><code>stripe</code>是我们导入的<code>injectStripe</code> HOC作为道具注入的实际条纹对象。而且，我们已经知道<code>history</code>是做什么的。</p>
<p>我们在组件中做的第一件事是检查<code>selectedProduct</code>是否确实存在。如果没有，我们会将用户转到主页。在生产级应用程序中，这可能会由一个<a href="https://tylermcginnis.com/react-router-protected-routes-authentication/">路由保护特设</a>来处理。</p>
<p>然后我们定义一个新的状态来保存成功支付的收据URL。它最初是空的。</p>
<p>接下来，我们必须定义一个名为<code>handleSubmit</code>的函数，该函数在提交结账表单时(即点击<strong>支付</strong>按钮时)被调用。我们来看看这个函数。</p>
<h4>定义<code>handleSubmit</code></h4>
<p>首先，我们必须防止<code>form</code>元素的默认行为，这样页面就不会刷新。然后我们可以从对<code>stripe.createToken</code>的异步调用结果中析构一个<code>token</code>值。</p>
<p><code>createToken</code>标记表单中的卡信息，并将其发送到条带服务器。然后它返回一个<code>token</code>对象，在这里我们可以得到一个<code>token.id</code>值作为实际卡信息的别名。</p>
<p>这确保了我们永远不会将用户的卡细节发送到支付服务器。</p>
<p>其次，我们必须向<code>localhost:7000/api/stripe/charge</code>发出一个HTTP <code>POST</code>请求，请求体包含三个内容:</p>
<ol>
<li><code>amount</code></li>
<li><code>source</code></li>
<li><code>receipt_email</code></li>
</ol>
<p><code>amount</code>是所购商品的价格。我们必须将它转换成一个字符串，并删除所有特殊字符，如<code>.</code>和<code>,</code>。这意味着9.99美元的成本将作为<code>999</code>发送到支付服务器。</p>
<p><code>source</code>是支付费用的地方。在我们的例子中，它将是我们刚刚生成的令牌的ID。</p>
<p>最后，<code>receipt_email</code>是发送付款收据的地方。它通常是客户的电子邮件地址，但是在我们的例子中，我们只是硬编码它，因为我们没有实现身份验证。</p>
<p>请求完成后，我们可以从响应对象中获取收据的URL，并将其设置为state。这是假设没有错误，因此在生产级应用程序中，我们通常会实现错误处理:</p>
<pre>...continued...
if (receiptUrl) {
    return (
      &lt;div className="success"&gt;
        &lt;h2&gt;Payment Successful!&lt;/h2&gt;
        &lt;a href={receiptUrl}&gt;View Receipt&lt;/a&gt;
        &lt;Link to="/"&gt;Home&lt;/Link&gt;
      &lt;/div&gt;
    )
  }
...to be continued...
</pre>
<h4>检查<code>recieptyUrl</code></h4>
<p>紧接在<code>handleSubmit</code>函数之后，我们有一个<code>if</code>检查来查看是否有一个<code>receiptUrl</code>在状态中。如果有，我们希望呈现一个包含成功消息、查看收据的链接和返回主页的链接的<code>div</code>:</p>
<pre>...continued...
  return (
    &lt;div className="checkout-form"&gt;
      &lt;p&gt;Amount: ${selectedProduct.price}&lt;/p&gt;
      &lt;form onSubmit={handleSubmit}&gt;
        &lt;label&gt;
          Card details
          &lt;CardNumberElement /&gt;
        &lt;/label&gt;
        &lt;label&gt;
          Expiration date
          &lt;CardExpiryElement /&gt;
        &lt;/label&gt;
        &lt;label&gt;
          CVC
          &lt;CardCVCElement /&gt;
        &lt;/label&gt;
        &lt;button type="submit" className="order-button"&gt;
          Pay
        &lt;/button&gt;
      &lt;/form&gt;
    &lt;/div&gt;
  )
}

export default injectStripe(CheckoutForm)
</pre>
<p>否则我们。必须呈现实际的结帐表单。这里，我们使用预构建的<code>Elements</code>组件，而不是从头开始重新创建它们，并且必须管理敏感信息。</p>
<p>在这个文件的最后，我们将<code>CheckoutForm</code>组件包装在<code>injectStripe</code> HOC中，这样我们就可以访问我们在组件中使用的Stripe对象。</p>
<h2>测试我们的React应用</h2>
<p>让我们回顾一下到目前为止我们已经完成的工作:</p>
<ol>
<li>我们已经创建了一个与Stripe通信的支付服务器</li>
<li>我们已经创建了一个主页来列出我们的产品</li>
<li>我们已经创建了一个结帐页面来获取用户的付款细节</li>
<li>我们已经创建了一个<code>handleSubmit</code>函数，向服务器发送请求来处理支付费用</li>
</ol>
<p>我们几乎已经设置好了一切，所以是时候实际运行我们的应用程序，看看我们是否能够购买一个橡胶鸭。我们必须先添加我们的脚本，所以打开<code>package.json</code>文件，用以下内容替换<code>scripts</code>部分:</p>
<pre>"scripts": {
    "build": "parcel build public/index.html --out-dir build --no-source-maps",
    "dev": "node src/server.js &amp;amp; parcel public/index.html",
    "start": "node src/server.js"
  },
</pre>
<p>打开终端，运行<code>npm run</code> <code>build</code>命令构建app，然后运行<code>npm run dev</code>。这将启动支付服务器，并在端口1234上显示前端。如果没有<code>.env</code>文件，服务器会在端口7000暴露前端。</p>
<p>接下来，打开浏览器，视情况导航至<code><a href="http://localhost:1234" rel="nofollow">http://localhost:1234</a></code>或<code><a href="http://localhost:7000" rel="nofollow">http://localhost:7000</a></code>，并遵循以下步骤:</p>
<ul>
<li>点击任何产品上的<strong>购买</strong>按钮</li>
<li>在结账页面中，在<strong>卡详细信息</strong>字段填写<strong> 4242 4242 4242 4242 </strong></li>
<li>填写任何到期日期，并选择一个随机的CVC值</li>
<li>点击<strong>支付</strong></li>
</ul>
<p>如果一切顺利，我们应该会看到一条<strong>付款成功</strong>的消息，其中包含查看收据和返回主页的链接。</p>
<p>要确认付款，请登录您的Stripe仪表盘，点击<strong>付款</strong>，您应该会在那里看到付款。</p>
<p><img data-attachment-id="69315" data-permalink="https://blog.logrocket.com/react-stripe-payment-system-tutorial/stripe-payments-dashboard-2/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2019/11/Stripe-Payments-Dashboard-1.png" data-orig-size="730,269" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Stripe payments dashboard" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2019/11/Stripe-Payments-Dashboard-1-300x111.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2019/11/Stripe-Payments-Dashboard-1.png" decoding="async" class="aligncenter size-full wp-image-69315 jetpack-lazy-image" src="../Images/f0ad7411a70367326f5707c241d7f538.png" alt="Stripe Payments Dashboard" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2019/11/Stripe-Payments-Dashboard-1.png 730w, https://blog.logrocket.com/wp-content/uploads/2019/11/Stripe-Payments-Dashboard-1-300x111.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2019/11/Stripe-Payments-Dashboard-1.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/11/Stripe-Payments-Dashboard-1.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="69315" data-permalink="https://blog.logrocket.com/react-stripe-payment-system-tutorial/stripe-payments-dashboard-2/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2019/11/Stripe-Payments-Dashboard-1.png" data-orig-size="730,269" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Stripe payments dashboard" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2019/11/Stripe-Payments-Dashboard-1-300x111.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2019/11/Stripe-Payments-Dashboard-1.png" decoding="async" loading="lazy" class="aligncenter size-full wp-image-69315" src="../Images/f0ad7411a70367326f5707c241d7f538.png" alt="Stripe Payments Dashboard" srcset="https://blog.logrocket.com/wp-content/uploads/2019/11/Stripe-Payments-Dashboard-1.png 730w, https://blog.logrocket.com/wp-content/uploads/2019/11/Stripe-Payments-Dashboard-1-300x111.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/11/Stripe-Payments-Dashboard-1.png"/></noscript>
<h2>结论</h2>
<p>这是一个使用Stripe的支付系统的非常简化的(并且肯定不适合生产)实现。让我们总结一下真正的生产就绪型实施所需的必要组件，以防您想尝试一下:</p>
<ol>
<li>一个更强大的支付服务器，具有适当的认证(<a href="https://blog.logrocket.com/jwt-authentication-best-practices/">想到JWT</a>)和验证</li>
<li>一个捕获和保存客户详细信息的流程，以便于将来计费</li>
<li>利用Stripe的欺诈检测服务来决定应该处理哪些支付</li>
<li>客户端有更好的用户界面和UX</li>
<li>客户端强大的错误处理</li>
</ol>
<p>虽然本教程应该足以让您入门，但它还不足以构建一个成熟的支付解决方案，所以请花一些时间阅读<a href="https://stripe.com/docs"> Stripe文档</a>。</p><div class="code-block code-block-22">
<div class="blog-plug inline-plug ecomm-plug"><h2><a href="https://lp.logrocket.com/blg/ecommerce-signup"> LogRocket </a>:看看用户为什么不完成你的电子商务流程中的一个步骤的技术和UX原因。</h2><a class="signup" href="https://lp.logrocket.com/blg/ecommerce-signup" target="_blank" rel="noopener noreferrer"><img class="alignnone size-full wp-image-46 jetpack-lazy-image" src="../Images/d60d88871d85e76e0dcca90f4bbaf78c.png" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2020/12/insights-step-2-lg.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/12/insights-step-2-lg.png"/><noscript><img data-lazy-fallback="1" class="alignnone size-full wp-image-46" src="../Images/d60d88871d85e76e0dcca90f4bbaf78c.png" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/12/insights-step-2-lg.png"/></noscript></a><p>LogRocket 就像是一个网络和移动应用程序和网站的DVR，记录你的电子商务应用程序上发生的一切。LogRocket没有猜测用户不转化的原因，而是主动揭示了阻止你转化的根本原因，比如JavaScript错误或死点击。LogRocket还可以监控应用的性能，报告客户端CPU负载、客户端内存使用等指标。</p><p>开始主动监控您的电子商务应用程序— <a class="signup" href="https://lp.logrocket.com/blg/ecommerce-signup" target="_blank" rel="noopener noreferrer">免费试用</a>。</p></div></div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
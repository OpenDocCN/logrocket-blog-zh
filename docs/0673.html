<html>
<head>
<title>Debugging performance problems in React - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>在React - LogRocket博客中调试性能问题</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/debugging-performance-problems-in-react/#0001-01-01">https://blog.logrocket.com/debugging-performance-problems-in-react/#0001-01-01</a></blockquote><div><article class="article-post">
<p>在开发任何应用程序时，确保高水平的性能是关键，无论是API、前端应用程序还是后端应用程序。</p>
<p>尽管性能很重要，但是性能测试和调试比您想象的更容易被遗忘。</p>
<p>关于基于React的应用程序，已经有数百篇好文章关注于消除性能问题的策略，识别和消除瓶颈，以及排除通常导致内存泄漏、内存不足或死锁错误的常见错误。</p>
<p>然而，当涉及到快速增长、处理大量并发数据或包含大量嵌套在一起的复杂流程的应用程序时，事情会变得有点棘手和难以预测——甚至是测试和调试。</p>
<p>这就是坚实的工具发挥作用的时候了。了解它们是如何工作的只是第一步。</p>
<p>您可以经常使用它，将您的日常工作作为一个开发工具来不断地度量一个新特性的性能，并判断它是否会影响现有的特性。</p>
<p>一旦你习惯了自动化测试和持续的集成和交付，自动化你的性能测试会更加顺利。</p>
<p>本文将重点讨论工具部分。</p>
<p>我们将深入探讨当前在评测方面的最佳解决方案:Chrome <a href="https://developers.google.com/web/tools/chrome-devtools/evaluate-performance" target="_blank" rel="noopener noreferrer">性能选项卡</a>，来自<a href="https://chrome.google.com/webstore/detail/react-developer-tools/fmkadmapgofadopljbjfkapdkoienihi?hl=en" target="_blank" rel="noopener noreferrer"> React Chrome插件</a> DevTools的评测器，以及React官方<a href="https://reactjs.org/docs/profiler.html" target="_blank" rel="noopener noreferrer">评测器API </a>。</p>
<p>这样，您将更好地了解哪些选项是可用的，哪一个最适合您的用例。</p>
<h2>使用Chrome Performance选项卡进行性能分析</h2>
<p>React已经以性能著称。这是近年来它最好的旗舰产品之一。凭借其虚拟dom，效率是每个开发人员都信任的一个众所周知的特性。</p>
<p>然而，你也知道不存在什么灵丹妙药，当你的一些组件开始变得太慢而无法渲染，或者你曾经引以为豪的一些嵌套结构不再执行得那么好时，这就是你必须停下来分析整个事情的时候。</p>
<p>我们将从Chrome Performance选项卡开始，这是一个很好的资源，不仅可以找到React的问题，还可以找到您可能开发的任何前端应用程序的问题。这是一个很好的方法，因为它是框架/库不可知的，这意味着您在这里获得的知识可以用于其他栈中的未来项目。</p>
<p>首先，一些依赖性:</p>
<ul>
<li>您必须在开发模式下安装了Node、npm和React(16+)；</li>
<li>谷歌Chrome，或Chromium，DevTools(它已经在浏览器里了)。</li>
</ul>
<p>为了更好地理解它，我们需要一个项目样本来玩。</p>
<p>为了保持文章的重点，我们将使用官方React示例<a href="https://reactjs.org/community/examples.html" target="_blank" rel="noopener noreferrer">项目</a>之一:<a href="https://github.com/alik0211/pokedex" target="_blank" rel="noopener noreferrer">口袋妖怪搜索应用</a>。</p>
<p>将其克隆到您的本地计算机上，并运行以下命令:</p>
<pre>npm install
npm start</pre>
<p>然后，下面的屏幕将在您的浏览器中提示:</p>
<p><img data-attachment-id="14097" data-permalink="https://blog.logrocket.com/debugging-performance-problems-in-react/pokemon/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/02/pokemon.png" data-orig-size="730,456" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="pokemon" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/02/pokemon-300x187.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/02/pokemon.png" decoding="async" class="aligncenter wp-image-14097 size-full jetpack-lazy-image" src="../Images/9ced8614b74d6ddf37b449ca4b9d9af6.png" alt="An image of the Pokemon search app." data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2020/02/pokemon.png 730w, https://blog.logrocket.com/wp-content/uploads/2020/02/pokemon-300x187.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2020/02/pokemon.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/02/pokemon.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="14097" data-permalink="https://blog.logrocket.com/debugging-performance-problems-in-react/pokemon/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/02/pokemon.png" data-orig-size="730,456" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="pokemon" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/02/pokemon-300x187.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/02/pokemon.png" decoding="async" loading="lazy" class="aligncenter wp-image-14097 size-full" src="../Images/9ced8614b74d6ddf37b449ca4b9d9af6.png" alt="An image of the Pokemon search app." srcset="https://blog.logrocket.com/wp-content/uploads/2020/02/pokemon.png 730w, https://blog.logrocket.com/wp-content/uploads/2020/02/pokemon-300x187.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/02/pokemon.png"/></noscript>
<h3>本地运行的Pokedex React应用程序</h3>
<p>要让Chrome插件与React一起工作，你应该在开发模式下运行应用程序。一旦我们使用的应用程序是用这个设置创建的，你就不用担心了。</p>
<p>现在，打开你的Chrome开发工具，进入性能标签。在那里，你会看到如下界面:</p>
<p><img data-attachment-id="14098" data-permalink="https://blog.logrocket.com/debugging-performance-problems-in-react/final/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/02/FINAL.png" data-orig-size="730,443" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="FINAL" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/02/FINAL-300x182.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/02/FINAL.png" decoding="async" class="aligncenter wp-image-14098 size-full jetpack-lazy-image" src="../Images/e4c71e2039875cf1a0c4987eda9fc3be.png" alt="A screenshot of the Chrome Devtools performance tab." data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2020/02/FINAL.png 730w, https://blog.logrocket.com/wp-content/uploads/2020/02/FINAL-300x182.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2020/02/FINAL.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/02/FINAL.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="14098" data-permalink="https://blog.logrocket.com/debugging-performance-problems-in-react/final/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/02/FINAL.png" data-orig-size="730,443" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="FINAL" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/02/FINAL-300x182.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/02/FINAL.png" decoding="async" loading="lazy" class="aligncenter wp-image-14098 size-full" src="../Images/e4c71e2039875cf1a0c4987eda9fc3be.png" alt="A screenshot of the Chrome Devtools performance tab." srcset="https://blog.logrocket.com/wp-content/uploads/2020/02/FINAL.png 730w, https://blog.logrocket.com/wp-content/uploads/2020/02/FINAL-300x182.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/02/FINAL.png"/></noscript>
<h3>性能选项卡概述</h3>
<p>这里必须考虑一些因素:这个齿轮，当切换时，启用数字4可用的选项。它们对于微调你的侧写记录的方式很重要。</p>
<p>这里有三个按钮，分别是:切换新记录、通过重新加载页面开始新的分析，以及清除当前记录。我们也有更多的输入，以确定您是否想要对屏幕导航/渲染进行截图，以及内存使用情况。</p>
<p>我们已经提到了控制——在这里，重要的是您在“CPU”项选择“4x减速”选项。这将有助于在模拟环境中测试页面，在模拟环境中，计算机的处理速度应该较慢。</p>
<p><span>现在，去你的<a href="http://locahost:3000/" rel="nofollow"> http://locahost:3000/ </a>，启动录制按钮，玩玩口袋妖怪app。录制时间不要超过20秒，这一点很重要，因为Chrome会因为要处理的数据太多而变得太慢。</span></p>
<p>结果取决于许多变量，如机器设置、CPU和内存、互联网连接等。</p>
<p>所以，如果你的和我的不一样，不要担心——重要的是理解这个工具是如何工作的。</p>
<p>下图代表了我的测试记录:</p>
<p><img data-attachment-id="14100" data-permalink="https://blog.logrocket.com/debugging-performance-problems-in-react/final2/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/02/final2.png" data-orig-size="730,508" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="final2" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/02/final2-300x209.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/02/final2.png" decoding="async" class="aligncenter wp-image-14100 size-full jetpack-lazy-image" src="../Images/0083a3481f1d88e06279b7a2913fe8f9.png" alt="A record of performance tests using the Chrome devtools performance tab." data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2020/02/final2.png 730w, https://blog.logrocket.com/wp-content/uploads/2020/02/final2-300x209.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2020/02/final2.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/02/final2.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="14100" data-permalink="https://blog.logrocket.com/debugging-performance-problems-in-react/final2/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/02/final2.png" data-orig-size="730,508" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="final2" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/02/final2-300x209.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/02/final2.png" decoding="async" loading="lazy" class="aligncenter wp-image-14100 size-full" src="../Images/0083a3481f1d88e06279b7a2913fe8f9.png" alt="A record of performance tests using the Chrome devtools performance tab." srcset="https://blog.logrocket.com/wp-content/uploads/2020/02/final2.png 730w, https://blog.logrocket.com/wp-content/uploads/2020/02/final2-300x209.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/02/final2.png"/></noscript>
<h3>报告记录示例</h3>
<p>最重要的是第一点:时间线上的红色分段条清楚地表明某件事处理时间过长(通常与CPU消耗有关)。这是一个很好的调查起点。</p>
<p>还要注意，为了便于识别每个组有多少资源(脚本文件、绘画、图像等),每个过程都用不同的颜色表示。)在2号消费。</p>
<p>数字3显示了时间线中每个组的加载历史。但是“Main”部分对我们来说并不是很有用，因为它显示了太多:所有的JavaScript函数调用、事件触发等等。相反，我们将使用“计时”部分(见下图)。</p>
<p>这是因为React通过<a href="https://developer.mozilla.org/en-US/docs/Web/API/User_Timing_API" target="_blank" rel="noopener noreferrer">用户计时API提供了大量的度量数据。</a>这是一个很好的方法来跟踪JavaScript文件中某些动作的时间，并将信息集中在浏览器的本机功能中。</p>
<p><img data-attachment-id="14099" data-permalink="https://blog.logrocket.com/debugging-performance-problems-in-react/pasted-image-0/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/02/pasted-image-0.png" data-orig-size="730,439" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="pasted image 0" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/02/pasted-image-0-300x180.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/02/pasted-image-0.png" decoding="async" class="aligncenter wp-image-14099 size-full jetpack-lazy-image" src="../Images/d33f0cd0a8af530023f221ae130eecb8.png" alt="An example of the User Timing API, which can help you measure performance." data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2020/02/pasted-image-0.png 730w, https://blog.logrocket.com/wp-content/uploads/2020/02/pasted-image-0-300x180.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2020/02/pasted-image-0.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/02/pasted-image-0.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="14099" data-permalink="https://blog.logrocket.com/debugging-performance-problems-in-react/pasted-image-0/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/02/pasted-image-0.png" data-orig-size="730,439" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="pasted image 0" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/02/pasted-image-0-300x180.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/02/pasted-image-0.png" decoding="async" loading="lazy" class="aligncenter wp-image-14099 size-full" src="../Images/d33f0cd0a8af530023f221ae130eecb8.png" alt="An example of the User Timing API, which can help you measure performance." srcset="https://blog.logrocket.com/wp-content/uploads/2020/02/pasted-image-0.png 730w, https://blog.logrocket.com/wp-content/uploads/2020/02/pasted-image-0-300x180.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/02/pasted-image-0.png"/></noscript>
<h3>探索时序部分</h3>
<p>要了解这一部分，请单击其中一个计时块(注意，React计时块在计时块的开头带有React徽标)，转到名为“自下而上”的底部菜单，并按“总时间”降序排列结果。</p>
<p>在这里，您可以看到每个React组件完成所用的时间，以及占总处理时间的百分比。一旦你知道了每个人所花的时间，就更容易找出差距所在，并采取行动。</p>
<p>此外，DevTools在执行的操作类型(更新、装载等)的层次结构中的每个活动(在括号之间)之后打印。).</p>
<p>“自身时间”列依次表示在特定活动之前累积的时间总量。</p>
<p>最好能更好地了解到这一点已经过去了多长时间。</p>
<p>如果您想对问题的确切位置有更多的控制，您可以配置您的项目使用一个<a href="https://developer.mozilla.org/en-US/docs/Tools/Debugger/How_to/Use_a_source_map" target="_blank" rel="noopener noreferrer">源映射</a>。</p>
<p>源地图是一种通向真实的、未统一的JavaScript代码版本的捷径。换句话说，它结合了从转换代码(美化、缩小等)生成的地图。)到原始源代码，让浏览器确切地知道为了调试目的如何重构原始代码。</p>
<h2>使用React DevTools进行性能分析</h2>
<p>在继续这一部分之前，您必须安装<a href="https://chrome.google.com/webstore/detail/react-developer-tools/fmkadmapgofadopljbjfkapdkoienihi?hl=en" target="_blank" rel="noopener noreferrer"> React开发工具</a>扩展。<a href="https://reactjs.org/blog/2018/09/10/introducing-the-react-profiler.html" target="_blank" rel="noopener noreferrer">默认情况下，分析器</a>只在开发模式下工作。</p>
<p>目前，有一种方法可以在生产模式下运行并激活该特性:如果您感兴趣，只需关注这个<a href="https://gist.github.com/bvaughn/25e6233aeb1b4f0cdb8d8366e54a3977" target="_blank" rel="noopener noreferrer">链接</a>。</p>
<p>通常，前端开发人员处理这个扩展只是为了检查React组件，但它不止于此。您也可以在Profiler选项卡中检查组件的性能。</p>
<h3>React开发工具概述</h3>
<p><img data-attachment-id="14105" data-permalink="https://blog.logrocket.com/debugging-performance-problems-in-react/final3-1/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/02/final3-1.png" data-orig-size="730,459" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="final3 (1)" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/02/final3-1-300x189.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/02/final3-1.png" decoding="async" class="aligncenter wp-image-14105 size-full jetpack-lazy-image" src="../Images/da8d558ebda62266d8250119863bd7b8.png" alt="An image of the React Devtools performance tool." data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2020/02/final3-1.png 730w, https://blog.logrocket.com/wp-content/uploads/2020/02/final3-1-300x189.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2020/02/final3-1.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/02/final3-1.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="14105" data-permalink="https://blog.logrocket.com/debugging-performance-problems-in-react/final3-1/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/02/final3-1.png" data-orig-size="730,459" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="final3 (1)" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/02/final3-1-300x189.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/02/final3-1.png" decoding="async" loading="lazy" class="aligncenter wp-image-14105 size-full" src="../Images/da8d558ebda62266d8250119863bd7b8.png" alt="An image of the React Devtools performance tool." srcset="https://blog.logrocket.com/wp-content/uploads/2020/02/final3-1.png 730w, https://blog.logrocket.com/wp-content/uploads/2020/02/final3-1-300x189.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/02/final3-1.png"/></noscript>
<p>看看上面的图片。这里，我们有扩展的四个主要部分。</p>
<p>首先，我们有扩展中的两个默认选项卡。</p>
<p>第一个，组件，是最有名的。在那里，您可以找到React组件的嵌套堆栈，并检查它们的状态。</p>
<p>第二个是指剖析机制。这里我们有几乎相同的Chrome性能标签的按钮。它们的功能也是相似的。</p>
<p>这三个选项卡指的是分析结果的显示方式。我们很快就会谈到这一点。</p>
<p>gear将选择一系列选项来调整必须如何进行分析。我们将让一切都默认在这里。</p>
<p>现在，我们去录音。再次打开你的Pokedex应用程序，点击图2(上图)所示的“开始剖析”按钮，然后玩这个应用程序。</p>
<p>完成后，再次单击同一按钮停止录制。</p>
<p>结果应该类似于下图:</p>
<p><img data-attachment-id="14102" data-permalink="https://blog.logrocket.com/debugging-performance-problems-in-react/new-pic/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/02/NEW-PIC.png" data-orig-size="730,461" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="NEW PIC" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/02/NEW-PIC-300x189.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/02/NEW-PIC.png" decoding="async" class="aligncenter wp-image-14102 size-full jetpack-lazy-image" src="../Images/4d4f74612824f53dba0a969a3865dda7.png" alt="An example of how React Devtools records and profiles performance." data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2020/02/NEW-PIC.png 730w, https://blog.logrocket.com/wp-content/uploads/2020/02/NEW-PIC-300x189.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2020/02/NEW-PIC.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/02/NEW-PIC.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="14102" data-permalink="https://blog.logrocket.com/debugging-performance-problems-in-react/new-pic/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/02/NEW-PIC.png" data-orig-size="730,461" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="NEW PIC" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/02/NEW-PIC-300x189.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/02/NEW-PIC.png" decoding="async" loading="lazy" class="aligncenter wp-image-14102 size-full" src="../Images/4d4f74612824f53dba0a969a3865dda7.png" alt="An example of how React Devtools records and profiles performance." srcset="https://blog.logrocket.com/wp-content/uploads/2020/02/NEW-PIC.png 730w, https://blog.logrocket.com/wp-content/uploads/2020/02/NEW-PIC-300x189.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/02/NEW-PIC.png"/></noscript>
<h3>Pokedex DevTools分析结果</h3>
<p>这是flamegraph的结果，flame graph是一个显示每个组件渲染所花费的总时间的图表，已经按平铺的长度排序。</p>
<p>DevTools还引入了<code>commit</code>的概念，它类似于我们在Performance选项卡中看到的<code>self time</code>，即React实际上将更改应用于DOM的时间。</p>
<p>这里的颜色不是随机的——事实上，它们很重要。黄色瓷砖意味着他们花了更长的时间来完成。</p>
<p>蓝绿色的人说他们的渲染速度非常快。在上面的屏幕截图中，我们没有第三种颜色，灰色，但是它代表了提交时没有花费任何时间渲染(或重新渲染)的组件。</p>
<p>但是，如果您使用选项卡顶部的箭头导航到其他提交，您将看到一些灰色的组件，因为它们没有参与React的任何更新。</p>
<p><img data-attachment-id="14103" data-permalink="https://blog.logrocket.com/debugging-performance-problems-in-react/final5/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/02/final5.png" data-orig-size="730,458" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="final5" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/02/final5-300x188.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/02/final5.png" decoding="async" class="aligncenter wp-image-14103 size-full jetpack-lazy-image" src="../Images/c22e4e50c21d50fb9f16eb9becd1d32c.png" alt="An example of the Pokedex Devtools profiling results." data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2020/02/final5.png 730w, https://blog.logrocket.com/wp-content/uploads/2020/02/final5-300x188.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2020/02/final5.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/02/final5.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="14103" data-permalink="https://blog.logrocket.com/debugging-performance-problems-in-react/final5/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/02/final5.png" data-orig-size="730,458" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="final5" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/02/final5-300x188.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/02/final5.png" decoding="async" loading="lazy" class="aligncenter wp-image-14103 size-full" src="../Images/c22e4e50c21d50fb9f16eb9becd1d32c.png" alt="An example of the Pokedex Devtools profiling results." srcset="https://blog.logrocket.com/wp-content/uploads/2020/02/final5.png 730w, https://blog.logrocket.com/wp-content/uploads/2020/02/final5-300x188.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/02/final5.png"/></noscript>
<h3>带有组件渲染历史记录的分级选项卡结果</h3>
<p>上图显示了“排名”选项卡的可视化效果。注意，它侧重于计时。</p>
<p>单击左侧的任何组件后，右侧部分将更新该组件的所有历史信息，包括何时渲染以及渲染了多长时间。</p>
<p>另一方面，如果您单击时间表中的任何一项，您将看到左侧部分会更新，显示相同历史的平铺视图。</p>
<p>请注意，如果React组件化太复杂，那么需要一些定制规则来更好地过滤结果。为此，转到我们提到的齿轮图标，并探索它的选项。</p>
<h2>探查器API</h2>
<p>从React 16.4开始，你可以受益于一个名为<code>&lt;Profiler/&gt;</code>的新组件，它属于React的<a href="https://reactjs.org/docs/profiler.html" target="_blank" rel="noopener noreferrer">分析器API </a>。它有助于从源代码定制您的度量标准，为您的组件的生命周期测量时间。</p>
<p>它的用法非常简单:您只需要在代码中任何您希望收集渲染成本的地方添加标签。只有两个可能的道具:一个字符串<code>id</code>和一个<code>callback function</code>在每次提交执行后被调用。</p>
<p>让我们修改Pokedex应用程序来收集一些指标。在您最喜欢的IDE中打开项目并转到<code>cmp-page.js.</code>，然后将您的import React语句更新为以下内容:</p>
<pre>import React, { Component, unstable_Profiler as Profiler } from 'react'</pre>
<p>之后，在渲染函数上方添加以下内容:</p>
<pre>onRenderCallback = (
    id, // the "id" prop of the Profiler tree that has just committed
    phase, // either "mount" (if the tree just mounted) or "update" (if it re-rendered)
    actualDuration, // time spent rendering the committed update
    baseDuration, // estimated time to render the entire subtree without memoization
    startTime, // when React began rendering this update
    commitTime, // when React committed this update
    interactions // the Set of interactions belonging to this update
  ) =&gt; {
    console.log({id, phase, actualDuration, baseDuration, startTime, commitTime, interactions});
}</pre>
<p>这个回调函数将简单地打印React profiler提供的所有属性。您可以在代码片段中查看对每一项的描述。</p>
<p>接下来，将<code>render</code>功能内容更改如下:</p>
<pre>&lt;Profiler id="pokemon_profiler" onRender={this.onRenderCallback}&gt;
    &lt;li className="pokemons__item" key={pokemon.id}&gt;
        &lt;Pokemon pokemon={pokemon} /&gt;
    &lt;/li&gt;
&lt;/Profiler&gt;</pre>
<p>以下是您可以在控制台上查看的输出示例:</p>
<p><img data-attachment-id="14104" data-permalink="https://blog.logrocket.com/debugging-performance-problems-in-react/screen-shot-2020-02-06-at-12-15-42/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/02/Screen-Shot-2020-02-06-at-12.15.42.png" data-orig-size="730,214" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Screen Shot 2020-02-06 at 12.15.42" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/02/Screen-Shot-2020-02-06-at-12.15.42-300x88.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/02/Screen-Shot-2020-02-06-at-12.15.42.png" decoding="async" class="aligncenter wp-image-14104 size-full jetpack-lazy-image" src="../Images/f8eed16a022a614e3d480e95eccfbc62.png" alt="A screenshot of an output example of the Profiler API" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2020/02/Screen-Shot-2020-02-06-at-12.15.42.png 730w, https://blog.logrocket.com/wp-content/uploads/2020/02/Screen-Shot-2020-02-06-at-12.15.42-300x88.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2020/02/Screen-Shot-2020-02-06-at-12.15.42.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/02/Screen-Shot-2020-02-06-at-12.15.42.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="14104" data-permalink="https://blog.logrocket.com/debugging-performance-problems-in-react/screen-shot-2020-02-06-at-12-15-42/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/02/Screen-Shot-2020-02-06-at-12.15.42.png" data-orig-size="730,214" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Screen Shot 2020-02-06 at 12.15.42" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/02/Screen-Shot-2020-02-06-at-12.15.42-300x88.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/02/Screen-Shot-2020-02-06-at-12.15.42.png" decoding="async" loading="lazy" class="aligncenter wp-image-14104 size-full" src="../Images/f8eed16a022a614e3d480e95eccfbc62.png" alt="A screenshot of an output example of the Profiler API" srcset="https://blog.logrocket.com/wp-content/uploads/2020/02/Screen-Shot-2020-02-06-at-12.15.42.png 730w, https://blog.logrocket.com/wp-content/uploads/2020/02/Screen-Shot-2020-02-06-at-12.15.42-300x88.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/02/Screen-Shot-2020-02-06-at-12.15.42.png"/></noscript>
<h3>探查器结果输出</h3>
<p>这种方法的优点之一是，您可以根据自己的愿望在概要分析上实现条件。你不必记录所有的事情。</p>
<p>例如，您可以创建警报，在速度太慢时发出警告。这将使您在信任您的实现或相信新代码不会干扰正在运行的应用程序时感到更安全。</p>
<h2>结论</h2>
<p>正如我们目前所见，有许多工具。</p>
<p>真正的问题是:我们如何从这些工具中提取最好的来适应我们在项目中可能遇到的任何情况？</p>
<p>此外，作为开发人员，我们如何适应并习惯在日常生活中使用它们，以便更快地获得关于我们正在编写的代码的反馈？</p>
<p>就个人而言，我认为混合方法比使用单一工具更适合您的需求。您可以了解每个工具的哪个功能最适合您和您的团队，然后使用图表、日志、警报、指标、过滤器等来调整您的流程和测试。</p>
<p>有许多不同的方法可以自定义您的分析操作，所以给他们一个机会。测试，收集，分析，最后决定。这是一个值得信任的良性循环。</p>
<p>如果您有自己的其他工具或技术来衡量React的性能，请在下面评论并告诉我们。</p><div class="code-block code-block-17">
<div class="blog-plug inline-plug react-plug" vwo-el-id="26283398190">
<h2 vwo-el-id="41600691720">使用LogRocket消除传统反应错误报告的噪音</h2>
<a href="https://lp.logrocket.com/blg/react-signup-issue-free" target="_blank" vwo-el-id="19356441070">LogRocket
</a><p>是一款React analytics解决方案，可保护您免受数百个误报错误警报的影响，只针对少数真正重要的项目。LogRocket告诉您React应用程序中实际影响用户的最具影响力的bug和UX问题。</p><a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="19356441380">
<img class="first-react-image alignnone size-full wp-image-46 jetpack-lazy-image jetpack-lazy-image--handled" src="../Images/f300c244a1a1cf916df8b4cb02bec6c6.png" vwo-el-id="18272717540" data-lazy-loaded="1" data-original-src="https://files.readme.io/27c94e7-Image_2017-06-05_at_9.46.04_PM.png"/>
</a>
<a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="19356441690">
<img class="second-react-image alignnone size-full wp-image-46 jetpack-lazy-image jetpack-lazy-image--handled" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" vwo-el-id="30720362350" data-lazy-loaded="1" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/>
</a>
<a href="https://lp.logrocket.com/blg/react-signup-issue-free" target="_blank" rel="noopener noreferrer" vwo-el-id="35866400580">LogRocket
</a><p>自动聚合客户端错误、反应错误边界、还原状态、缓慢的组件加载时间、JS异常、前端性能指标和用户交互。然后，LogRocket使用机器学习来通知您影响大多数用户的最具影响力的问题，并提供您修复它所需的上下文。</p><p vwo-el-id="28675661060">关注重要的React bug—<a class="signup" href="https://lp.logrocket.com/blg/react-signup-issue-free" target="_blank" rel="noopener noreferrer" vwo-el-id="40093418840">今天就试试LogRocket】。</a></p>
</div></div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
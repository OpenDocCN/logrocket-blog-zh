<html>
<head>
<title>Using D3.js v6 with React - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>在React - LogRocket博客中使用D3.js v6</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/using-d3-js-v6-with-react/#0001-01-01">https://blog.logrocket.com/using-d3-js-v6-with-react/#0001-01-01</a></blockquote><div><article class="article-post">
<p>React是世界上最流行的前端web框架，D3.js是最流行的操纵屏幕图形的JavaScript库之一。</p>
<p>版本6是D3.js的最新版本，在本文中，我们将看看如何在React应用程序中使用D3.js v6。</p>
<h2>入门指南</h2>
<p>首先，我们将使用create-react-app创建一个React项目，如下所示:</p>
<pre>npx create-react-app d3-app
cd d3-app
npm start</pre>
<p>然后我们安装D3.js包:</p>
<pre>npm i d3</pre>
<p>现在，我们可以在React应用程序中添加D3来添加一些图形。</p>
<h2>在React应用中使用D3.js v6</h2>
<p>我们可以在应用程序中使用D3，方法是将D3代码放在<code>useEffect</code>钩子回调中。这是因为我们用DOM选择了一个元素，然后用D3修改了它。</p>
<p>例如，我们可以写:</p>
<pre>import React, { useEffect } from "react";
import * as d3 from "d3";

export default function App() {
  useEffect(() =&gt; {
    d3.select(".target").style("stroke-width", 5);
  }, []);
  return (
    &lt;div className="App"&gt;
      &lt;svg&gt;
        &lt;circle
          class="target"
          style={{ fill: "green" }}
          stroke="black"
          cx={50}
          cy={50}
          r={40}
        &gt;&lt;/circle&gt;
      &lt;/svg&gt;
    &lt;/div&gt;
  );
}</pre>
<p>我们用<code>target</code>类获取SVG，然后在选择它之后更改<code>stroke-width</code>。</p>
<p>我们也可以将D3代码放在一个函数中，当我们想使用它时就调用它。例如，我们可以写:</p>
<pre>import React from "react";
import * as d3 from "d3";

export default function App() {
  const changeStroke = () =&gt; {
    d3.select(".target").style("stroke-width", 5);
  };

  return (
    &lt;div className="App"&gt;
      &lt;button onClick={changeStroke}&gt;change stroke&lt;/button&gt;
      &lt;svg&gt;
        &lt;circle
          class="target"
          style={{ fill: "green" }}
          stroke="black"
          cx={50}
          cy={50}
          r={40}
        &gt;&lt;/circle&gt;
      &lt;/svg&gt;
    &lt;/div&gt;
  );
}</pre>
<p>我们在<code>changeStroke</code>函数中设置D3代码来改变圆的笔划，并在单击按钮时调用它。</p>
<p>我们还可以将所有内容添加到另一个<code>svg</code>元素中。例如，我们可以通过编写以下代码来添加三个圆:</p>
<pre>import React, { useEffect } from "react";
import * as d3 from "d3";

export default function App() {
  useEffect(() =&gt; {
    const svg = d3.select("#area");
    svg
      .append("circle")
      .attr("cx", 50)
      .attr("cy", 50)
      .attr("r", 40)
      .style("fill", "blue");
    svg
      .append("circle")
      .attr("cx", 140)
      .attr("cy", 70)
      .attr("r", 40)
      .style("fill", "red");
    svg
      .append("circle")
      .attr("cx", 300)
      .attr("cy", 100)
      .attr("r", 40)
      .style("fill", "green");
  }, []);

  return (
    &lt;div className="App"&gt;
      &lt;svg id="area" height={200} width={450}&gt;&lt;/svg&gt;
    &lt;/div&gt;
  );
}</pre>
<p>让我们来分解一下:</p>
<ul>
<li>带有<code>'circle'</code>参数的<code>append</code>方法添加圆</li>
<li><code>attr</code>方法调用为圆添加属性</li>
<li><code>cx</code>是圆心的x坐标</li>
<li><code>cy</code>是圆心的y坐标</li>
<li><code>r</code>是半径</li>
<li><code>style</code>包含我们想要放入圆的<code>style</code>属性中的属性和值</li>
</ul>
<h2>缩放图形</h2>
<p>通过使用<code>scaleLinear</code>方法，我们可以在React应用程序中用D3.js缩放图形。例如，我们可以编写以下代码，将x轴添加到我们的图表中:</p>
<pre>import React, { useEffect } from "react";
import * as d3 from "d3";

export default function App() {
  useEffect(() =&gt; {
    const margin = { top: 10, right: 40, bottom: 30, left: 30 },
      width = 450 - margin.left - margin.right,
      height = 400 - margin.top - margin.bottom;

    const svg = d3
      .select("#area")
      .append("svg")
      .attr("width", width + margin.left + margin.right)
      .attr("height", height + margin.top + margin.bottom)
      .append("g")
      .attr("transform", `translate(${margin.left}, ${margin.top})`);

    const x = d3.scaleLinear().domain([0, 100]).range([0, width]);
    svg
      .append("g")
      .attr("transform", `translate(0, ${height})`)
      .call(d3.axisBottom(x));

    const y = d3.scaleLinear().domain([0, 100]).range([height, 0]);
    svg.append("g").call(d3.axisLeft(y));
  }, []);

  return (
    &lt;div className="App"&gt;
      &lt;svg id="area" height={400} width={500}&gt;&lt;/svg&gt;
    &lt;/div&gt;
  );
}</pre>
<p>我们简单地用我们的<code>x</code>函数调用<code>d3.axisBottom</code>来添加x轴。它将把我们传递给<code>domain</code>函数的最小值和最大值相加。</p>
<h2>将y轴添加到图表中</h2>
<p>不用说，我们可以用D3给一个图添加一个y轴。</p>
<p>在上面的代码中，你会注意到我们添加了<code>margin</code>对象来让我们更容易地设置图形的边距。然后，我们使用以下代码将<code>svh</code>对象附加到页面主体:</p>
<pre>const svg = d3
  .select("#area")
  .append("svg")
  .attr("width", width + margin.left + margin.right)
  .attr("height", height + margin.top + margin.bottom)
  .append("g")
  .attr("transform", `translate(${margin.left}, ${margin.top})`);</pre>
<p>我们设置<code>width</code>和<code>height</code>，然后<code>translate</code>物体到我们想要的位置。</p>
<p>接下来，我们通过书写来添加x轴和刻度:</p>
<pre>const x = d3.scaleLinear().domain([0, 100]).range([0, width]);
svg
  .append("g")
  .attr("transform", `translate(0, ${height})`)
  .call(d3.axisBottom(x));</pre>
<p>我们像以前一样调用<code>domain</code>和<code>range</code>，我们调用<code>d3.axisBottom</code>方法来添加x轴。</p>
<p>然后，添加y轴，我们写:</p>
<pre>const y = d3.scaleLinear().domain([0, 100]).range([height, 0]);
svg.append("g").call(d3.axisLeft(y));</pre>
<p>我们调用了<code>domain</code>和<code>range</code>来创建y轴的最小值和最大值，然后我们调用<code>d3.axisLeft</code>来添加y轴。</p>
<h2>创建散点图</h2>
<p>要将点/点添加到图表中以创建散点图，我们可以像前面一样添加圆形。例如，我们可以编写以下内容来创建完整的散点图:</p>
<pre>import React, { useEffect } from "react";
import * as d3 from "d3";

const DATA = [
  { x: 10, y: 20 },
  { x: 20, y: 50 },
  { x: 80, y: 90 }
];

export default function App() {
  useEffect(() =&gt; {
    const margin = { top: 10, right: 40, bottom: 30, left: 30 },
      width = 450 - margin.left - margin.right,
      height = 400 - margin.top - margin.bottom;

    const svg = d3
      .select("#area")
      .append("svg")
      .attr("width", width + margin.left + margin.right)
      .attr("height", height + margin.top + margin.bottom)
      .append("g")
      .attr("transform", `translate(${margin.left}, ${margin.top})`);

    const x = d3.scaleLinear().domain([0, 100]).range([0, width]);
    svg
      .append("g")
      .attr("transform", `translate(0, ${height})`)
      .call(d3.axisBottom(x));

    const y = d3.scaleLinear().domain([0, 100]).range([height, 0]);
    svg.append("g").call(d3.axisLeft(y));

    svg
      .selectAll("whatever")
      .data(DATA)
      .enter()
      .append("circle")
      .attr("cx", (d) =&gt; x(d.x))
      .attr("cy", (d) =&gt; y(d.y))
      .attr("r", 7);
  }, []);

  return (
    &lt;div className="App"&gt;
      &lt;svg id="area" height={400} width={500}&gt;&lt;/svg&gt;
    &lt;/div&gt;
  );
}</pre>
<p>让我们把它分解一下。您会注意到我们在<code>useEffect</code>回调中添加了这段代码来呈现散点图上的点:</p>
<pre>svg
  .selectAll("whatever")
  .data(DATA)
  .enter()
  .append("circle")
  .attr("cx", (d) =&gt; x(d.x))
  .attr("cy", (d) =&gt; y(d.y))
  .attr("r", 7);</pre>
<p>我们用<code>data</code>方法读取数据。<code>DATA</code>数组是:</p>
<pre>const DATA = [
  { x: 10, y: 20 },
  { x: 20, y: 50 },
  { x: 80, y: 90 }
];</pre>
<p>然后，为了获得相对于域的x和y坐标，我们使用带点的<code>x</code>和<code>y</code>方法。这些值在0到100之间，它们将自动与<code>width</code>和<code>height</code>值成比例缩放。</p>
<p>所以如果<code>x</code>是10，那么在屏幕上，<code>cx</code>就是<code>10 * (450 - margin.left - margin.right)</code>；如果<code>y</code>是20，那么在屏幕上，<code>cy</code>就是<code>20 * (400 - margin.top - margin.bottom)</code>。</p>
<h2>从数据创建图表</h2>
<p>D3最常见的用例之一是从数据中创建图表。为此，我们可以从CSV中读取数据。</p>
<p>例如，我们可以从<code>src</code>文件夹中的<code>data.csv</code>文件中读取数据:</p>
<pre>date,close
01-May-20,58.13
30-Apr-20,53.98
27-Apr-20,67.00
26-Apr-20,89.70
25-Apr-20,99.00
24-Apr-20,130.28
23-Apr-20,166.70
20-Apr-20,234.98
19-Apr-20,345.44
18-Apr-20,443.34
17-Apr-20,543.70
16-Apr-20,580.13
13-Apr-20,605.23
12-Apr-20,622.77
11-Apr-20,626.20
10-Apr-20,628.44
09-Apr-20,636.23
05-Apr-20,633.68
04-Apr-20,624.31
03-Apr-20,629.32
02-Apr-20,618.63</pre>
<p>在<code>App.js</code>中，我们写道:</p>
<pre>import React, { useEffect } from "react";
import * as d3 from "d3";
import "d3-time-format";
const parseTime = d3.timeParse("%d-%b-%y");

const createGraph = async () =&gt; {
  const margin = { top: 20, right: 20, bottom: 50, left: 70 },
    width = 960 - margin.left - margin.right,
    height = 500 - margin.top - margin.bottom;
  const x = d3.scaleTime().range([0, width]);
  const y = d3.scaleLinear().range([height, 0]);

  const valueLine = d3.line()
    .x((d) =&gt; { return x(d.date); })
    .y((d) =&gt; { return y(d.close); });

  const svg = d3.select("body").append("svg")
    .attr("width", width + margin.left + margin.right)
    .attr("height", height + margin.top + margin.bottom)
    .append("g")
    .attr("transform", `translate(${margin.left}, ${margin.top})`);

  let data = await d3.csv(require("./data.csv"))

  data.forEach((d) =&gt; {
    d.date = parseTime(d.date);
    d.close = +d.close;
  });

  data = data.sort((a, b) =&gt; +a.date - +b.date)

  x.domain(d3.extent(data, (d) =&gt; { return d.date; }));
  y.domain([0, d3.max(data, (d) =&gt; { return d.close; })]);

  svg.append("path")
    .data([data])
    .attr("class", "line")
    .attr("d", valueLine);

  svg.append("g")
    .attr("transform", `translate(0, ${height})`)
    .call(d3.axisBottom(x));

  svg.append("g")
    .call(d3.axisLeft(y));
}

export default function App() {
  useEffect(() =&gt; {
    createGraph();
  }, []);

  return (
    &lt;div&gt;
      &lt;style&gt;{
        `
          .line {
            fill: none;
            stroke: steelblue;
            stroke-width: 2px;
          }
      `}
      &lt;/style&gt;
    &lt;/div&gt;
  );
}</pre>
<p>我们将图形创建代码移至<code>createGraph</code>函数。我们还通过运行<code>npm i d3-time-format</code>添加了<code>d3-time-format</code>库。然后我们可以像在这个文件上一样导入它。</p>
<p>我们以与前面的例子相似的方式创建了轴。我们像这样创建<code>x</code>和<code>y</code>函数，这样我们以后可以用它们创建轴:</p>
<pre>const x = d3.scaleTime().range([0, width]);
const y = d3.scaleLinear().range([height, 0]);</pre>
<p>图表的容器是通过以下方式创建的:</p>
<pre>const svg = d3.select("body").append("svg")
  .attr("width", width + margin.left + margin.right)
  .attr("height", height + margin.top + margin.bottom)
  .append("g")
  .attr("transform", `translate(${margin.left}, ${margin.top})`);</pre>
<p>然后，我们使用以下内容读取CSV数据:</p>
<pre>let data = await d3.csv(require("./data.csv"))</pre>
<p>我们解析时间并将<code>close</code>属性改为数字:</p>
<pre>data.forEach((d) =&gt; {
  d.date = parseTime(d.date);
  d.close = +d.close;
});</pre>
<p>然后我们按日期对数据进行排序，如下所示:</p>
<pre>data = data.sort((a, b) =&gt; +a.date - +b.date)</pre>
<p>我们使用以下代码添加该行:</p>
<pre>svg.append("path")
  .data([data])
  .attr("class", "line")
  .attr("d", valueLine);</pre>
<p>我们分别添加x轴和y轴:</p>
<pre>svg.append("g")
  .attr("transform", `translate(0, ${height})`)
  .call(d3.axisBottom(x));</pre>
<pre>svg.append("g")
  .call(d3.axisLeft(y));</pre>
<p>最后，在<code>App</code>组件中，我们编写:</p>
<pre>&lt;style&gt;{
  `
    .line {
      fill: none;
      stroke: steelblue;
      stroke-width: 2px;
    }
`}</pre>
<p>这样，我们将看到一条线，而不是填充的形状。</p>
<h2>结论</h2>
<p>正如你刚刚看到的，我们可以轻松地用D3.js创建图形。它与React应用程序配合良好，无需额外工作即可集成。</p><div class="code-block code-block-17">
<div class="blog-plug inline-plug react-plug" vwo-el-id="26283398190">
<h2 vwo-el-id="41600691720"><a href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener"> LogRocket </a>:全面了解您的生产React应用</h2><p>调试React应用程序可能很困难，尤其是当用户遇到难以重现的问题时。如果您对监视和跟踪Redux状态、自动显示JavaScript错误以及跟踪缓慢的网络请求和组件加载时间感兴趣，</p><a href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" vwo-el-id="19356441070">try LogRocket</a><p>. </p><a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="19356441380">
<img class="first-react-image alignnone size-full wp-image-46 jetpack-lazy-image jetpack-lazy-image--handled" src="../Images/f300c244a1a1cf916df8b4cb02bec6c6.png" vwo-el-id="18272717540" data-lazy-loaded="1" data-original-src="https://files.readme.io/27c94e7-Image_2017-06-05_at_9.46.04_PM.png"/>
</a>
<a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="19356441690">
<img class="second-react-image alignnone size-full wp-image-46 jetpack-lazy-image jetpack-lazy-image--handled" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" vwo-el-id="30720362350" data-lazy-loaded="1" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/>
</a>
<p vwo-el-id="28675660440" class="">LogRocket 结合了会话回放、产品分析和错误跟踪，使软件团队能够创建理想的web和移动产品体验。这对你来说意味着什么？</p>
<p>LogRocket不是猜测错误发生的原因，也不是要求用户提供截图和日志转储，而是让您回放问题，就像它们发生在您自己的浏览器中一样，以快速了解哪里出错了。</p>
<p>不再有嘈杂的警报。智能错误跟踪允许您对问题进行分类，然后从中学习。获得有影响的用户问题的通知，而不是误报。警报越少，有用的信号越多。</p>
<p vwo-el-id="28675660750">LogRocket Redux中间件包为您的用户会话增加了一层额外的可见性。LogRocket记录Redux存储中的所有操作和状态。</p>
<p vwo-el-id="28675661060">现代化您调试React应用的方式— <a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="40093418840">开始免费监控</a>。</p>
</div></div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

 </div>    
</body>
</html>
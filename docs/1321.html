<html>
<head>
<title>Encoding and decoding packages for Rust - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>Rust - LogRocket博客的编码和解码包</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/encoding-and-decoding-packages-for-rust/#0001-01-01">https://blog.logrocket.com/encoding-and-decoding-packages-for-rust/#0001-01-01</a></blockquote><div><article class="article-post">
<p>编码是将数据从一种形式转换成另一种形式的过程。解码的意思完全一样。尽管编码通常被定义为一个过程，但它也指一种特定形式的数据(字符编码或媒体编码)。</p>
<p/>
<p>字符编码/解码在编程中尤其重要，因为计算机只能识别二进制数据。这就是我们翻译一系列字符(字母、数字、符号、标点符号等)的方式。)转换成一种专门的格式，以帮助我们说计算机的语言，并理解它的反馈。</p>
<p>在本指南中，我们将演示如何在Rust中编码和解码您的数据。</p>
<h2>Rust中的编码和解码</h2>
<p>如果你认为编码和解码听起来很无聊，你并不孤单。有许多边缘情况，过程可能相当复杂。</p>
<p>幸运的是，在Rust中，就像在许多其他编程语言中一样，编码和解码是由模块处理的，这些模块已经针对大多数边缘情况进行了彻底的测试。高效的编码和解码库对于像Rust这样接近机器的语言来说尤为关键。</p>
<p>Rust中的编码相对简单。尽管它没有包含在核心的Rust包中，但是社区开发的一些解决方案可以很好地处理这项工作。这些工具使您能够通过函数发送要编码或解码的字符串，并接收所追求的结果(编码或解码的字符串)。</p>
<h3><code>base64</code>铁锈库</h3>
<p><a href="https://crates.io/crates/base64" target="_blank" rel="noopener noreferrer"> base64 </a>设计用于尽可能快和精确地编码和解码base64。顾名思义，它只适用于base64。它实际上有两个转换函数——<code>encode()</code>和<code>decode()</code>——以及配置函数来帮助你塑造它解码和编码的方式。</p>
<pre>extern crate base64;
use base64::{encode};
fn main() {
    let a = "hello world";
    println!("{}", encode(a)); // -&gt; aGVsbG8gd29ybGQ=
}
</pre>
<p>信不信由你，在你的电脑上处理二进制文件时，base64实际上是头等必需品。Base64通常用于对二进制数据(图像、声音文件等)进行编码，我们在网上分享的所有内容都使用这种编码，从电子邮件附件到在数据库中保存文件。</p>
<p>如果想更深入地了解，可以去找base64大师。</p>
<h3><code>rust-encoding</code></h3>
<p><code><a href="https://crates.io/crates/encoding" target="_blank" rel="noopener noreferrer">rust-encoding</a></code>支持大量的字符编码(所有那些被WHATWG标准支持的)。非常独特的是，它通过用指定的值替换处理字符串时收到的错误来处理错误。当检测到错误时，可以使用严格模式完全停止执行=。</p>
<p>编码的<code>encode</code>和<code>decode</code>方法将一个<code>String</code>转换为<code>Vec&lt;u8&gt;</code>，反之亦然。由于支持许多编码类型，该库提供了两种方式来获得您的编码:</p>
<ol>
<li>   <ol>
<li>您将用于编码过程的编码附加到其中。所有未使用的编码类型都将从二进制文件中丢弃</li>
<li><code>encoding::label</code>，它根据给定的标签捕获编码，并返回静态编码类型，得到一个更大的二进制文件</li>
</ol>
</li>
</ol>
<pre>use encoding::{Encoding, EncoderTrap};
use encoding::all::ISO_8859_1; // use with all
use encoding::label::encoding_from_whatwg_label; // use with label

assert_eq!(ISO_8859_1.encode("caf\u{e9}", EncoderTrap::Strict),
Ok(vec![99,97,102,233]));
let euckr = encoding_from_whatwg_label("euc-kr").unwrap();
assert_eq!(euckr.name(), "windows-949");</pre>
<p><code>rust-encoding</code>是下载量最高的库之一(3.5k/周)，尽管它已经四年没有更新了。可以肯定地说，它极其稳定和强健。</p>
<h3><code>data-encoding</code></h3>
<p><a href="https://crates.io/crates/data-encoding" target="_blank" rel="noopener noreferrer"> <code>data-encoding</code> </a>处理15种不同的编码类型，允许用户定义自己的自定义边缘情况。用数据编码来编码和解码你的字符非常具体和简单，假设你知道你想编码成什么类型或者从什么类型解码。</p>
<pre>BASE64.encode(&amp;input_to_encode)
HEXLOWER.decode(&amp;input_to_decode)
</pre>
<p>该库允许您为2到64的基数定义自己的小端ASCII基数转换编码，这对于本机编码类型是无法实现的，因为它们是特殊的用例。</p>
<p>是一个小型的现代化图书馆。它非常受欢迎并且维护良好，如果您必须使用它们支持的编码类型，这是一个很好的选择。</p>
<h3><code>integer-encoding</code></h3>
<p>我们认为整数是字符，因此它们也需要编码和解码。<a href="https://lib.rs/crates/integer-encoding" target="_blank" rel="noopener noreferrer"> <code>integer-encoding</code> </a>支持两种整数类型:<code><a href="https://docs.rs/integer-encoding/2.0.0/integer_encoding/trait.FixedInt.html" target="_blank" rel="noopener noreferrer">FixedInt</a></code>和<code><a href="https://docs.rs/integer-encoding/2.0.0/integer_encoding/trait.VarInt.html" target="_blank" rel="noopener noreferrer">VarInt</a></code>。它还提供了有效的读写类型来简化整数的处理。</p>
<p>这个库有一个特殊的用例，在使用Google的<a href="https://developers.google.com/protocol-buffers/docs/encoding#top_of_page" target="_blank" rel="noopener noreferrer">协议缓冲区</a>的开发人员中众所周知，它说明了对非通用类型进行编码/解码的需要。</p>
<h2>网络的Rust编码和解码</h2>
<p>编码和解码的一个最实用和最常见的用例是在web上，在web上，我们使用字符串、表单、数组、JSON等创建了两个不同的实体(后端和前端)。它可能看起来天衣无缝，但幕后有很多工作要做。</p>
<p>让我们放大一些有助于实现这种交流的库。</p>
<h3><code>urlencoded</code></h3>
<p>人们经常想知道为什么浏览器和服务器能够从URL中读取参数和表单数据，以及其他奇怪的字符，如空格、问号等。尽管这是web 的<a href="https://url.spec.whatwg.org/" target="_blank" rel="noopener noreferrer">标准，但是每种语言都应该能够阅读和理解它，以便能够与用户的浏览器进行交流。</a></p>
<p>在Rust中，<a href="https://crates.io/crates/urlencoded" target="_blank" rel="noopener noreferrer"> <code>urlencoded</code> </a>在<a href="https://github.com/iron/iron" target="_blank" rel="noopener noreferrer"> Iron </a> web框架中扮演中间件的角色。它的职责是将URL查询字符串解析成<code>hashmaps</code>，这在Rust中更容易阅读。得到的值保存在一个<code>Vec</code>中，以确保在密钥被复制的情况下不会丢失任何信息。因此，查询<code>a=b&amp;a=c</code>将导致从<code>a</code>到<code>[b, c]</code>的映射。</p>
<p><code>urlencoded</code>也能够解析MIME类型的post主体:<code>application/x-www-form-urlencoded</code>。在前端处理表单时，这很方便。</p>
<p>在url编码和解码方面,<code>urlencoded</code>是一个完整的库。在不到四个依赖项的情况下工作，它被认为是稳定的，可以投入生产了。</p>
<h3><code>multer-rs</code></h3>
<p>深受<a href="https://crates.io/crates/multipart" target="_blank" rel="noopener noreferrer"> <code>multipart</code> </a>和<a href="https://github.com/abonander/multipart-async" target="_blank" rel="noopener noreferrer"><code>multipart-async</code></a><a href="https://github.com/rousan/multer-rs"><code>multer-rs</code></a>的启发，以异步解析Rust中<code>multipart/form-data</code>内容类型的能力著称。以前的库不能处理任何异步服务器，这是至关重要的，因为Rust的生态系统正在走向异步。</p>
<p><code>multer-rs</code>接受<code>Bytes</code>的一个<code>Stream</code>作为源，并生成一个iterable，包含从<code>multipart/form-data</code>获得的所有需要的字段，包括来自文件的数据，然后可以将这些数据写入一个定制文件。</p>
<p>由于对异步工作的多部分解码器的需求，它越来越受欢迎。之前流行的都达不到。虽然它的维护者仍在研究新的问题，但multer-rs可以被认为是稳定的。</p>
<h3><code>percent-encoding</code></h3>
<p><a href="https://lib.rs/crates/percent-encoding" target="_blank" rel="noopener noreferrer"> <code>percent-encoding</code> </a>是url-encoder的绝佳替代品。它们有许多相似的特征，但是百分比编码是不同的，因为:</p>
<ol>
<li>   <ol>
<li>它不依赖于铁网框架</li>
<li>它是一个完整的URL解析器，可以分解URL的结构，只得到特定的部分，而不是查询参数</li>
<li>它解析和序列化HTML表单中使用的<code><a href="https://url.spec.whatwg.org/#application/x-www-form-urlencoded" target="_blank" rel="noopener noreferrer">application/x-www-form-urlencoded</a></code>语法</li>
</ol>
</li>
</ol>
<pre>// code from url docs
use url::{Url, Host, Position};
let issue<em>list</em>url = Url::parse(
"https://github.com/rust-lang/rust/issues?labels=E-easy&amp;state=open"
)?

;assert!(issue_list_url.scheme() == "https"); // takes the scheme
assert!(issue_list_url.hoststr() == Some("github.com")); //get the url's host
assert!(issue_list_url.port() == None); // get the port if there's one
assert!(issue_list_url.path() == "/rust-lang/rust/issues"); // the whole path
assert!(issue_list_url.query() == Some("labels=E-easy&amp;state=open")); // get only the query
assert!(&amp;issue_list_url[Position::BeforePath..] == "/rust-lang/rust/issues?labels=E-easy&amp;state=open");</pre>
<p>这个库优雅地处理边缘情况，就像拥有相对URL一样。它使您能够加入URL并创建新的URL。</p>
<pre>use url::Url;

let this_document = Url::parse("http://servo.github.io/rust-url/url/index.html")?;
let css_url = this_document.join("../main.css")?;
assert_eq!(css_url.as_str(), "http://servo.github.io/rust-url/main.css");
</pre>
<p>当比较开发人员的体验时，<code>percent-encoding</code>比<code>url-encoded</code>更有优势，尤其是如果你没有使用Iron框架的话。此外，虽然它仍然使用2015年的老锈，<code>percent-encoding</code>似乎更强大。</p>
<h3><code>base64-url</code></h3>
<p><a href="https://lib.rs/crates/base64-url" target="_blank" rel="noopener noreferrer"> <code>base64-url</code> </a>是——你猜对了——另一个base64编码器，现在在URL中。虽然听起来不太可能，但当你需要缩短URL或包含一些二进制数据时，这是一个<a href="https://en.wikipedia.org/wiki/Base64#URL_applications" target="_blank" rel="noopener noreferrer">便利的功能</a>。</p>
<h3><code>blob-uuid</code></h3>
<p>有时你只是简单地编码来缩短字符串的长度。<a href="https://lib.rs/crates/blob-uuid" target="_blank" rel="noopener noreferrer"> <code>blob-uuid</code> </a>用36个字符的UUIDs帮你做到这一点，编码后变成22个。如果您想在URL中共享UUID，它还可以帮助您隐藏它。</p>
<pre>let uuid = Uuid::parse_str("557c8018-5e21-4b74-8bb0-9040e2e8ead1").unwrap();
assert_eq!("VXyAGF4hS3SLsJBA4ujq0Q", blob_uuid::to_blob(uuid));
</pre>
<h2>操场</h2>
<p>我在我的<a href="https://repl.it/@DylanJason/ThankfulChocolateBug#main.rs"> Repl.it </a>上为这些图书馆准备了一个操场。确保使用<code>Cargo.toml</code>添加您想要的库，并在终端上点击<code>cargo run</code>。</p>
<h2>Rust中的序列化</h2>
<p>序列化意味着将数据(数组、对象和类似的结构)转换成单个字符串，以便于存储或传输。序列化是一个非常具体的主题，被视为编码的一个子集。然而，为了简单起见，本文不包括序列化库。</p>
<p>Rust的生态系统提供了一些<a href="https://blog.logrocket.com/rust-serialization-whats-ready-for-production-today/" target="_blank" rel="noopener noreferrer">优秀的序列化库</a>，包括<a href="https://blog.logrocket.com/json-and-rust-why-serde_json-is-the-top-choice/" target="_blank" rel="noopener noreferrer"><code>serde_json</code></a><a href="https://lib.rs/crates/toml" target="_blank" rel="noopener noreferrer"><code>toml</code></a><a href="https://lib.rs/crates/bincode" target="_blank" rel="noopener noreferrer"><code>bincode</code></a>。这些在幕后也经历了某种形式的编码和解码。</p>
<h2>结论</h2>
<p>还有比我们上面描述的更多的Rust编码库。我们强调了一些最常见的。在现实生活中，您最有可能根据需要处理的格式选择编码库。</p>
<p>编码和解码不限于字符编码。Rust 也有各种各样的<a href="https://lib.rs/multimedia/encoding" target="_blank" rel="noopener noreferrer">媒体编码库。</a></p>
<p>上面列出的所有库都是为生产使用而建立的、流行的和稳定的。这仅仅是因为编码和解码在任何现代语言中都是一个强制性的特征。列表是多样化的，每个库以不同的方式处理特定的用例。这使得它们很难相互比较。</p>
<p>Rust有很强的编码和解码库基础。然而，我相信如果Rust内核中至少装载了最流行的编码类型(UTF-8和base64 ),并且设计得像Python中的<a href="https://docs.python.org/3/library/base64.html" target="_blank" rel="noopener noreferrer">模块</a>一样具有延展性，Rust会感觉更加成熟。</p><div class="code-block code-block-29">
<div class="blog-plug inline-plug rust-plug"><h2><a href="https://lp.logrocket.com/blg/rust-signup" target="_blank">log rocket</a>:Rust应用的web前端的全面可见性</h2><p>调试Rust应用程序可能很困难，尤其是当用户遇到难以重现的问题时。如果您对监控和跟踪Rust应用程序的性能、自动显示错误、跟踪缓慢的网络请求和加载时间感兴趣，</p><a href="https://lp.logrocket.com/blg/rust-signup" target="_blank">try LogRocket</a><p>. </p><a class="signup" href="https://lp.logrocket.com/blg/rust-signup" target="_blank" rel="noopener noreferrer"><img class="alignnone size-full wp-image-46 jetpack-lazy-image" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/><noscript><img data-lazy-fallback="1" class="alignnone size-full wp-image-46" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/></noscript></a><p>LogRocket 就像是网络和移动应用程序的DVR，记录你的Rust应用程序上发生的一切。您可以汇总并报告问题发生时应用程序的状态，而不是猜测问题发生的原因。LogRocket还可以监控应用的性能，报告客户端CPU负载、客户端内存使用等指标。</p><p>现代化调试Rust应用的方式— <a class="signup" href="https://lp.logrocket.com/blg/rust-signup" target="_blank" rel="noopener noreferrer">开始免费监控</a>。</p></div>


</div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
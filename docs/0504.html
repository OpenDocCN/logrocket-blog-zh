<html>
<head>
<title>How to practically use Performance API to measure performance - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>如何实际使用性能API测量性能</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/how-to-practically-use-performance-api-to-measure-performance/#0001-01-01">https://blog.logrocket.com/how-to-practically-use-performance-api-to-measure-performance/#0001-01-01</a></blockquote><div><article class="article-post">
<p>从历史上看，我们在性能监控客户端的性能指标方面的信息非常有限。我们还遇到了API浏览器的限制，这阻碍了我们准确地测量性能。</p>
<p>幸运的是，由于新的面向性能的API，这种情况正在开始改变。现在，浏览器的<a href="https://developer.mozilla.org/en-US/docs/Web/API/Performance_API" target="_blank" rel="noopener noreferrer">性能API </a>提供了精确测量网页性能的工具。</p>
<p>在我们深入研究这些性能API是什么之前，让我们看看为什么应该使用它们的一些令人信服的理由。</p>
<h3>使用性能API的好处</h3>
<ul>
<li>这些API增强了在开发工具中使用性能分析的体验</li>
<li>Chrome开发工具和其他类似Lighthouse的工具只在开发阶段有用。但是有了性能API，我们可以在生产中获得真实用户测量(RUM)。</li>
<li>我们可以获得非常精确的时间戳，这使得对这些性能指标的分析非常准确。</li>
</ul>
<p>现在我们来谈谈这些API是什么。</p>
<p>“性能API是高分辨率时间API的一部分，但由<a href="https://developer.mozilla.org/en-US/docs/Web/API/Performance_Timeline" target="_blank" rel="noopener noreferrer">性能时间线API </a>、<a href="https://developer.mozilla.org/en-US/docs/Web/API/Navigation_timing_API" target="_blank" rel="noopener noreferrer">导航计时API </a>、<a href="https://developer.mozilla.org/en-US/docs/Web/API/User_Timing_API" target="_blank" rel="noopener noreferrer">用户计时API </a>和<a href="https://developer.mozilla.org/en-US/docs/Web/API/Resource_Timing_API" target="_blank" rel="noopener noreferrer">资源计时API </a>增强。”–MDN</p>
<p>每当阅读有关Performance API的内容时，您会遇到一系列令人困惑的术语，如高分辨率时间、性能时间线API等，这使得很难理解它到底是什么以及如何利用它来测量web性能。</p>
<p>让我们分解这些术语，以便更好地理解。</p>
<h3>高分辨率时间</h3>
<p>高分辨率时间精确到几分之一毫秒。</p>
<p>相比之下，基于<code>Date</code>的时间只精确到毫秒。这种精度使其成为精确测量时间的理想选择。</p>
<p>由用户代理(UA)测量的高分辨率时间不随系统时间的任何变化而变化，因为它取自UA创建的全局时钟。</p>
<p>在Performance API中测量的每个度量都是高分辨率时间。这就是为什么你总是听到性能API是高分辨率时间API的一部分。</p>
<h3>绩效时间线API</h3>
<p><a href="https://www.w3.org/TR/performance-timeline-2/" target="_blank" rel="noopener noreferrer">性能时间线API </a>是性能API的扩展。该扩展提供了基于特定过滤标准检索性能指标的接口。</p>
<p>Performance Timeline API提供了以下三种方法，包含在<code>performance</code>接口中:</p>
<ul>
<li><code>getEntries()</code></li>
<li><code>getEntriesByName()</code></li>
<li><code>getEntriesByType()</code></li>
</ul>
<p>每个方法都返回一个从Performance API的所有其他扩展中收集的性能条目列表。</p>
<p><code><a href="https://www.w3.org/TR/performance-timeline-2/#dom-performanceobserver" target="_blank" rel="noopener noreferrer">PerformanceObserver</a></code>是API中包含的另一个接口。它在给定的性能条目列表中观察新的条目，并通知相同的条目。</p>
<h3>绩效条目</h3>
<p>我们用性能API度量的东西被称为<code>entries</code>。这些是我们可用的性能条目:</p>
<ul>
<li><code>mark</code></li>
<li><code>measure</code></li>
<li><code>navigation</code></li>
<li><code>resource</code></li>
<li><code>paint</code></li>
<li><code>frame</code></li>
</ul>
<p>我们将利用这些条目和各自的API来测量性能。</p>
<h3>我们能测量什么？</h3>
<p>让我们看一些我们可以用这些API做的实际测量。</p>
<h3>使用导航定时API和资源定时API</h3>
<p>这两个API之间有很大的重叠，所以我们将一起讨论它们。</p>
<p>两者都用于衡量不同的资源。我们不会深入这个重叠的细节，但是如果你好奇的话，你可以看看这个<a href="https://www.w3.org/TR/navigation-timing-2/#processing-model" target="_blank" rel="noopener noreferrer">处理模型</a>，它可能会帮助你更好地理解这个重叠。</p>
<pre>// Get Navigation Timing entries:
const navigationEntries = performance.getEntriesByType("navigation")[0]; // returns an array of a single object by default so we're directly getting that out.

// output:
{
  "name": "https://awebsite.com",
  "entryType": "navigation",
  "startTime": 0,
  "duration": 7816.495000151917,
  "initiatorType": "navigation",
  "nextHopProtocol": "",
  "workerStart": 9.504999965429306,
  "redirectStart": 0,
  "redirectEnd": 0,
  "fetchStart": 39.72000000067055,
  "domainLookupStart": 39.72000000067055,
  "domainLookupEnd": 39.72000000067055,
  "connectStart": 39.72000000067055,
  "connectEnd": 39.72000000067055,
  "secureConnectionStart": 0,
  "requestStart": 39.72000000067055,
  "responseStart": 6608.200000133365,
  "responseEnd": 6640.834999969229,
  "transferSize": 0,
  "encodedBodySize": 0,
  "decodedBodySize": 0,
  "serverTiming": [],
  "unloadEventStart": 0,
  "unloadEventEnd": 0,
  "domInteractive": 6812.060000142083,
  "domContentLoadedEventStart": 6812.115000095218,
  "domContentLoadedEventEnd": 6813.680000137538,
  "domComplete": 7727.995000081137,
  "loadEventStart": 7760.385000146925,
  "loadEventEnd": 7816.495000151917,
  "type": "navigate",
  "redirectCount": 0
}</pre>
<pre>// Get Resource Timing entries
const resourceListEntries = performance.getEntriesByType("resource");</pre>
<p>这将返回一个资源计时对象数组。单个对象看起来会像这样:</p>
<pre>{
  "name": "https://awebsite.com/images/image.png",
  "entryType": "resource",
  "startTime": 237.85999999381602,
  "duration": 11.274999938905239,
  "initiatorType": "img",
  "nextHopProtocol": "h2",
  "workerStart": 0,
  "redirectStart": 0,
  "redirectEnd": 0,
  "fetchStart": 237.85999999381602,
  "domainLookupStart": 237.85999999381602,
  "domainLookupEnd": 237.85999999381602,
  "connectStart": 237.85999999381602,
  "connectEnd": 237.85999999381602,
  "secureConnectionStart": 0,
  "requestStart": 243.38999995961785,
  "responseStart": 244.40500000491738,
  "responseEnd": 249.13499993272126,
  "transferSize": 0,
  "encodedBodySize": 29009,
  "decodedBodySize": 29009,
  "serverTiming": []
}</pre>
<ul>
<li><strong>测量DNS时间</strong>:当用户请求一个URL时，查询域名系统(DNS)将一个域翻译成一个IP地址。</li>
</ul>
<p>导航和资源计时都暴露了两个与DNS相关的指标:</p>
<p>–<code>domainLookupStart</code>:标记DNS查找开始的时间。<br/>–<code>domainLookupEnd</code>:标记DNS查找结束的时间。</p>
<pre>// Measuring DNS lookup time
const dnsTime = navigationEntries.domainLookupEnd - navigationEntries.domainLookupStart;</pre>
<p><strong>抓住了</strong>:如果主机没有设置正确的<code><a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Timing-Allow-Origin" target="_blank" rel="noopener noreferrer">Timing-Allow-Origin</a></code>响应头，那么<code>domainLookupStart</code>和<code>domainLookupEnd</code>都可能成为第三方提供的资源的<code>0</code>。</p>
<ul>
<li><strong>测量请求和响应时间</strong></li>
</ul>
<p>导航和资源计时都用这些指标描述请求和响应-</p>
<ul>
<li><code>fetchStart</code>标记浏览器开始获取资源的时间。这并不直接标记浏览器何时对资源发出网络请求，而是标记它何时开始检查缓存(如HTTP和服务工作者缓存)以查看网络请求是否必要。</li>
<li><code>requestStart</code>是浏览器发出网络请求的时间</li>
<li><code>responseStart</code>是响应的第一个字节到达的时间</li>
<li><code>responseEnd</code>是响应的最后一个字节到达的时间</li>
<li><code>workerStart</code>标记何时从服务人员处获取请求。如果没有为当前页面安装服务人员，这将始终是<code>0</code>。</li>
</ul>
<pre>// Request + Request Time
const totalTime = navigationEntries.responseEnd - navigationEntries.requestStart;
// Response time with cache seek
const fetchTime = navigationEntries.responseEnd - navigationEntries.fetchStart;

// Response time with Service worker
let workerTime = 0;
if (navigationEntries.workerStart &gt; 0) {
workerTime = navigationEntries.responseEnd - navigationEntries.workerStart;
}

// Time To First Byte
const ttfb = navigationEntries.responseStart - navigationEntries.requestStart;

// Redirect Time
const redirectTime = navigationEntries.redirectEnd - navigationEntries.redirectStart;</pre>

<pre>const headerSize = navigationEntries.transferSize - navigationEntries.encodedBodySize;</pre>
<p><code>transferSize</code>是包括HTTP头的资源的总大小。<br/> <code>encodedBodySize</code>是资源<em>的压缩大小，不包括</em> HTTP头。<br/> <code>decodedBodySize</code>是资源解压缩后的大小(同样，不包括HTTP头)。</p>
<ul>
<li><strong>测量资源的加载时间</strong></li>
</ul>
<pre>resourceListEntries.forEach(resource =&gt; {
  if (resource.initiatorType == 'img') {
    console.info(`Time taken to load ${resource.name}: `, resource.responseEnd - resource.startTime);
  }
});</pre>
<p><code>initiatorType</code>属性返回启动性能条目的资源类型。在上面的例子中，我们只关心图像，但是我们也可以检查<code>script</code>、<code>css</code>、<code>xmlhttprequest</code>等。</p>
<ul>
<li><strong>获取单个资源的指标</strong></li>
</ul>
<p>我们可以通过使用<code>getEntriesByName</code>来做到这一点，它通过名称获得一个性能条目。这里是该资源的URL:</p>
<pre>const impResourceTime = performance.getEntriesByName("https://awebsite.com/imp-resource.png");</pre>
<p>此外，我们还可以使用文档处理指标，如<code>domInteractive</code>、<code>domContentLoadedEventStart</code>、<code>domContentLoadedEventEnd</code>和<code>domComplete</code>。</p><div class="code-block code-block-54">
<hr/>
<h3>更多来自LogRocket的精彩文章:</h3>

<hr/></div>
<p>属性传达了文档的加载时间。</p>
<h3>使用绘制计时API</h3>
<p>绘画是浏览器的任何活动，包括在浏览器窗口上绘制像素。我们可以用这个API来衡量“第一次绘画”和“第一次满意的绘画”。<br/> <code>first-paint:</code>浏览器在页面上绘制第一个像素的点<br/> <code>first-contentful-paint</code>:绘制第一点内容的点——即在DOM中定义的东西。这可以是文本、图像或画布渲染。</p>
<pre>const paintEntries = performance.getEntriesByType("paint");</pre>
<p>这将返回由两个对象组成的数组:</p>
<pre>[
  {
    "name": "first-paint",
    "entryType": "paint",
    "startTime": 17718.514999956824,
    "duration": 0
  },
  {
    "name": "first-contentful-paint",
    "entryType": "paint",
    "startTime": 17718.519999994896,
    "duration": 0
  }
]</pre>
<p>从这些条目中，我们可以提取出指标:</p>
<pre>paintEntries.forEach((paintMetric) =&gt; {
  console.info(`${paintMetric.name}: ${paintMetric.startTime}`);
});</pre>
<h3>使用用户计时</h3>
<p>用户计时API为我们提供了可以在应用程序的不同位置调用的方法，这让我们可以跟踪时间被用在了哪里。</p>
<p>我们可以测量脚本的性能，特定的JavaScript任务需要多长时间，甚至用户与页面交互的延迟。</p>
<p>这个API提供的mark方法是我们的用户计时分析工具包中的主要工具。</p>
<p>它为我们存储了一个时间戳。<code>mark()</code>的超级有用之处在于，我们可以命名时间戳，API会将名称和时间戳作为一个单元记忆下来。</p>
<p>在应用程序的不同地方调用<code>mark()</code>可以让我们计算出在我们的web应用程序中达到那个标记所花的时间。</p>
<pre>performance.mark('starting_calculations')
const multiply = 82 * 21;
performance.mark('ending_calculations')

performance.mark('starting_awesome_script')
function awesomeScript() {
  console.log('doing awesome stuff')
}
performance.mark('ending_awesome_script');</pre>
<p>一旦我们设置了一组计时标记，我们就想找出这些标记之间经过的时间。</p>
<p>这就是<code>measure()</code>方法发挥作用的地方。</p>
<p><code>measure()</code>方法计算标记之间经过的时间，也可以测量我们的标记与<a href="http://www.w3.org/TR/navigation-timing/#sec-navigation-timing-interface" target="_blank" rel="noopener noreferrer"> PerformanceTiming </a>界面中任何一个众所周知的事件名称之间的时间，比如<code>paint</code>、<code>navigation</code>等。</p>
<p><code>measure</code>方法接受3个参数:首先是度量本身的名称(可以是任何东西)，然后是开始标记的名称，最后是结束标记的名称。</p>
<p>因此，上面带有<code>measure</code>的例子应该是:</p>
<pre>performance.mark('starting_calculations')
const multiply = 82 * 21;
performance.mark('ending_calculations')
+ performance.measure("multiply_measure", "starting_calculations", "ending_calculations");

performance.mark('starting_awesome_script')
function awesomeScript() {
  console.log('doing awesome stuff')
}
performance.mark('starting_awesome_script');
+ performance.measure("awesome_script", "starting_awesome_script", "starting_awesome_script");</pre>
<p>为了得到我们所有的<code>measure</code>,我们可以使用我们可信赖的<code>getEntriesByType</code>:</p>
<pre>const measures = performance.getEntriesByType('measure');
    measures.forEach(measureItem =&gt; {
      console.log(`${measureItem.name}: ${measureItem.duration}`);
    });</pre>
<p>这个API对于缩小我们的web应用程序中的性能热点非常有用，可以创建一个清晰的时间消耗图。</p>
<hr/>
<p>厉害！我们已经收集了各种性能指标。现在，我们可以将所有这些数据发送回我们的监控工具，或者将其存储在某个地方供以后分析。</p>
<p>请记住，这些API并不是到处都有。但是，重要的是，像<code>getEntriesByType</code>这样的方法不会在找不到任何东西时抛出错误。</p>
<p>因此，我们可以检查<code>getEntriesByType</code>是否返回了任何内容，然后进行我们的PerformanceAPI测量:</p>
<pre>if (performance.getEntriesByType("navigation").length &gt; 0) {
  // We have Navigation Timing API
}</pre>
<h3>额外收获:使用性能API和木偶师</h3>
<p><a href="https://pptr.dev" target="_blank" rel="noopener noreferrer">puppeter</a>是一个无头节点库，它提供了一个高级API来通过<a href="https://chromedevtools.github.io/devtools-protocol/" target="_blank" rel="noopener noreferrer"> DevTools协议</a>控制Chrome或Chrome。默认情况下，木偶师无头运行。</p>
<p>大多数你可以在浏览器中手动完成的事情都可以使用木偶师来完成！</p>
<p>下面是一个使用导航计时API提取计时指标的示例:</p>
<pre>const puppeteer = require('puppeteer');

(async () =&gt; {
  const browser = await puppeteer.launch();
  const page = await browser.newPage();
  await page.goto('https://awebsite.com'); // change to your website
  
  // Executes Navigation API within the page context
  const performanceTiming = JSON.parse(
      await page.evaluate(() =&gt; JSON.stringify(window.performance.timing))
  );
  console.log('performanceTiming', performanceTiming)
  await browser.close();
})();</pre>
<p>这将返回一个定时对象，如前面的导航定时API部分所示:</p>
<pre>{
  "navigationStart": 1570451005291,
  "unloadEventStart": 1570451005728,
  "unloadEventEnd": 1570451006183,
  "redirectStart": 0,
  "redirectEnd": 0,
  "fetchStart": 1570451005302,
  "domainLookupStart": 1570451005302,
  "domainLookupEnd": 1570451005302,
  "connectStart": 1570451005302,
  "connectEnd": 1570451005302,
  "secureConnectionStart": 0,
  "requestStart": 1570451005309,
  "responseStart": 1570451005681,
  "responseEnd": 1570451006173,
  "domLoading": 1570451006246,
  "domInteractive": 1570451010094,
  "domContentLoadedEventStart": 1570451010094,
  "domContentLoadedEventEnd": 1570451010096,
  "domComplete": 1570451012756,
  "loadEventStart": 1570451012756,
  "loadEventEnd": 1570451012801
}</pre>
<p>你可以在<a href="https://pptr.dev/" target="_blank" rel="noopener noreferrer">官方网站</a>上了解更多关于木偶师的信息，也可以在<a href="https://github.com/ananyaneogi/puppeteer-uses" target="_blank" rel="noopener noreferrer">这个回购</a>中查看它的一些用途。</p><div class="code-block code-block-2">
<div class="blog-plug base-cta"><h2>使用<a class="signup" href="https://lp.logrocket.com/blg/signup" target="_blank" rel="noopener noreferrer"> LogRocket </a>消除传统错误报告的干扰</h2>
<a href="https://lp.logrocket.com/blg/signup" class="signup" target="_blank" rel="noopener noreferrer"><img class="alignnone size-full wp-image-46 jetpack-lazy-image" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/><noscript><img data-lazy-fallback="1" class="alignnone size-full wp-image-46" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/></noscript></a>
<p><a href="https://lp.logrocket.com/blg/signup" target="_blank" rel="noopener noreferrer"> LogRocket </a>是一个数字体验分析解决方案，它可以保护您免受数百个假阳性错误警报的影响，只针对几个真正重要的项目。LogRocket会告诉您应用程序中实际影响用户的最具影响力的bug和UX问题。</p>
<p>然后，使用具有深层技术遥测的会话重放来确切地查看用户看到了什么以及是什么导致了问题，就像你在他们身后看一样。</p>
<p>LogRocket自动聚合客户端错误、JS异常、前端性能指标和用户交互。然后LogRocket使用机器学习来告诉你哪些问题正在影响大多数用户，并提供你需要修复它的上下文。</p>
<p>关注重要的bug—<a class="signup" href="https://lp.logrocket.com/blg/signup-issue-free" target="_blank" rel="noopener noreferrer">今天就试试LogRocket】。</a></p></div></div>
<h3>额外资源</h3>
<ol>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/API/Performance_API" target="_blank" rel="noopener noreferrer"> MDN性能API </a></li>
<li><a href="https://w3c.github.io/perf-timing-primer/" target="_blank" rel="noopener noreferrer">Web性能计时API初级读本</a></li>
<li><a href="https://michaljanaszek.com/blog/test-website-performance-with-puppeteer" target="_blank" rel="noopener noreferrer">用木偶师</a> <br/>测试网站性能</li>
</ol>

<p class="clearfix"/>
<p class="clearfix"/>
</article>
 
</div>    
</body>
</html>
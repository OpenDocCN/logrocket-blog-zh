<html>
<head>
<title>Framer Motion tutorial: How to easily create React animations - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>帧运动教程:如何轻松创建反应动画</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/framer-motion-tutorial/#0001-01-01">https://blog.logrocket.com/framer-motion-tutorial/#0001-01-01</a></blockquote><div><article class="article-post">
<p><em> <strong>编者按:</strong>本帖最后更新于2021年7月29日。一些信息可能仍然是过时的。</em></p>
<h2>什么是框架运动？</h2>
<p>如果你像我一样，当你读到这个标题时，你的第一个想法可能是，“为什么我们还需要React的另一个动画库？这越来越累了！”</p>
<p>将Framer Motion视为对现有动画库的改进或改造，而不是全新的动画库。</p>
<p>帧运动是Pose的继承者，Pose是React使用的最流行的动画库之一。像Pose一样，它是建立在promotion之上的，promotion是一个低级的、非个性化的动画库，但是它提供了抽象来简化这个过程。</p>
<p>Framer Motion改进并简化了API，这是在不中断更改和重写的情况下无法做到的。一个区别是帧运动只支持React，而Pose支持React-Native和Vue。如果你目前正在使用Pose，我会推荐更新到帧运动，因为<a href="https://popmotion.io/blog/20200115-pose-is-deprecated/"> Pose已经被弃用</a>。</p>
<p>要了解有关成帧器运动的更多信息，我们的教程将涵盖以下主题:</p>

<h2 id="spring-animations">什么是春季动画？</h2>
<p>默认情况下，帧运动使用<a href="https://blog.logrocket.com/animations-with-react-spring/" target="_blank" rel="noopener noreferrer">弹簧动画</a>。如果你想要不同的行为，你需要定制这些。近年来，春季动画大受欢迎。另一种方法是使用CSS创建动画，例如<code>1s ease-in</code>。缓动动画的行为和设定的持续时间看起来不自然或不真实。</p>
<p>弹簧动画应用物理定律来制作更流畅、更自然的动画。他们通过物理原理如动量来做到这一点。它们不会简单地到达并停止在最终状态；它们会反弹过去，然后固定下来。两个值用于定义弹簧动画:刚度和阻尼。调整这些值将使动画表现不同。</p>
<h2 id="why-use-framer-motion">为什么使用帧运动？</h2>
<p>如果大多数动画库使用基于spring的动画，那么，为什么要使用Framer Motion呢？首先，它有一个很好的API，很简单，不会用额外的代码填充组件。在大多数情况下，您可以简单地将HTML元素替换为motion元素——例如，将<code>div</code>替换为<code>motion.div</code>,这将产生相同的标记，但具有额外的动画道具。</p>
<p><a href="https://www.framer.com/motion/" target="_blank" rel="noopener noreferrer"> Framer Motion官网</a>上的文档和例子是我在动画库中见过的最好的。对于大多数常见的用例，您可以在文档中找到CodeSandbox示例。有些很简单，有些更复杂，但它们都让您有了很好的理解，并使您能够调整以构建自己的解决方案。与大多数库不同，Framer Motion还可以处理SVG动画。</p>
<p>最后，由于它是Framer的一部分，并与Framer X设计工具集成，使用这两种工具可以帮助您的工作流程更加顺畅和高效(我个人对此没有任何经验，但我想象它们在一起会很棒)。</p>
<h2 id="how-framer-motion-works">成帧器动作如何工作</h2>
<p>如前所述，Framer Motion用Motion元素替换HTML元素。每个HTML和SVG元素都有一个motion元素(例如<code>&lt;motion.div&gt;</code>)。这些运动元素与帧运动挂钩，并接受定义动画行为的附加道具。这些道具中最简单的是<code>animate</code>，也是你最常使用的一个。传递给<code>animate</code>的任何有效值都会使组件在挂载时动画化到那个状态。</p>
<pre>&lt;motion.div 
  animate={{
    x: '100px'    
  }}
&gt;
Weeee I'm animated
&lt;/motion.div&gt;
</pre>
<p>这将导致div在加载时向右滑动100个像素。如果您想让它在一系列状态中产生动画效果，可以使用关键帧，关键帧是状态值的数组。</p>
<pre>&lt;motion.div 
  animate={{
    x: ['100px', '0px', '100px']  
  }}
&gt;
Weeee I'm animated
&lt;/motion.div&gt;
</pre>
<p>这将使它向右滑动100个像素，回到其原始位置，然后再向右滑动100个像素。默认情况下，这些都需要相同的时间，但是如果需要，您可以使用<code>times</code>按钮来调整设置。</p>
<p>默认情况下，一个元素将从其自然样式的地方开始动画到在<code>animation.</code>中定义的状态。在某些情况下，您可能想要定义动画开始的状态。以不透明度为例。假设您希望它不是从<code>0</code>开始，而是从一个可见的值开始，比如<code>0.5</code>。这可以通过将状态传递给<code>initial</code> prop来定义。如果您传递一个值<code>false</code>，初始状态将是动画中的值，并且不会出现初始动画。</p>
<pre>&lt;motion.div
  initial={{
    opacity: 0.5
  }}
  animation={{
    opacity: 1
  }}
&gt;
&lt;/motion.div&gt;
</pre>
<p>虽然我提到Framer Motion是一个基于spring的库，但从技术上来说，这并不是100%正确的。对于不涉及运动的动画，弹簧是不可能的。这些使用补间动画，如不透明度和颜色。此外，惯性是根据初速度计算的，并用于<code>dragTransition</code>。</p>
<p>通过<code>transition</code>道具，可以改变动画以使用不同的类型或以其他方式调整。例如，如果您想要将持续时间设置为<code>2</code>并使用补间样式，那么您应该传递以下内容。</p>
<pre>&lt;motion.div 
  animate={{
    x: '100px'    
  }}
  transition={{
    type: 'tween',
    duration: 2
  }}
&gt;
Weeee I'm animated
&lt;/motion.div&gt;
</pre>
<p>还有其他强大的转换可用，比如<code>stagger</code>和<code>delay</code>子元素。这些允许您轻松地执行传统上涉及多个子元素的复杂动画。</p>
<p>通常，您希望在元素被单击、悬停或以其他方式交互时触发动画。令人欣慰的是，Framer Motion内置了名为手势的道具。</p>
<p>可用的手势有<code>hover</code>、<code>tap</code>、<code>pan</code>和<code>drag</code>。<code>hover</code>和<code>tap</code>以<code>while</code>为前缀，如你所料，仅在鼠标悬停或点击时应用动画。当用户不再悬停或点击时，它将恢复到默认风格，并显示平滑的动画。<code>drag</code>和<code>pan</code>工作原理不同。启用拖动允许您将元素拖动到页面上的任何位置，它将保留在被拖动到的位置。默认的物理拖动感觉非常自然；拖动会增加动量，当释放时，元素会根据拖动的力度和速度继续向那个方向移动。</p>
<p>这些是我认为的框架运动的基础构件。有了这些技术，你几乎可以创建你能想到的任何类型的动画。</p>
<p>更高级的技术对于动画组件的卸载是必要的，但是我们将在后面用一个例子来介绍其中的一些。</p>
<h2 id="use-framer-motion-react">如何在React中使用帧运动？</h2>
<p>关于图书馆本身就足够了。现在让我们构建一个实用的模型来展示常见的技术，并帮助我们了解这个库的运行情况。</p>
<p>从一个基本的React应用开始(比如<a href="https://blog.logrocket.com/getting-started-with-create-react-app-d93147444a27/" target="_blank" rel="noopener noreferrer"> Create React App </a>，我们需要安装Framer Motion。我们还将安装一个包来创建名为<code>uuid</code>的惟一id。</p>
<pre>npm install framer-motion uuid
</pre>
<p>我们的基本应用程序将如下所示，我们将用<code>App</code>编写我们的应用程序。</p>
<pre>// index.js
import React from "react";
import ReactDOM from "react-dom";
import App from "./App";
import "./styles.css";

ReactDOM.render(
  &lt;React.StrictMode&gt;
    &lt;App /&gt;
  &lt;/React.StrictMode&gt;,
  document.getElementById("root"),
);
</pre>
<p>只有一些基本样式的规则。</p>
<pre>// styles.css
html,
body,
#root {
  height: 100%;
  width: 100%;
}

.app {
  height: 100%;
  width: 100%;
}

.list {
  display: flex;
  flex-wrap: wrap;
  width: 1200px;
}

img {
  // disables dragging on img elements
  pointer-events: none;
}
</pre>
<p>我们还将使用<a href="https://blog.logrocket.com/how-to-use-bootstrap-with-react-a354715d1121/" target="_blank" rel="noopener noreferrer"> Bootstrap </a>来简化样式。将下面的链接添加到您的HTML的头部以包含它。</p>
<pre>&lt;link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.4.1/css/bootstrap.min.css"
integrity="sha384-Vkoo8x4CGsO3+Hhxv8T/Q5PaXtkKtu6ug5TOeNV6gBiFeWPGFN9MuhOf23Q9Ifjh"
crossorigin="anonymous"
/&gt;
</pre>
<p>这里是我们的开始<code>App.js</code>。我们将有一个项目/卡的列表，可以添加额外的项目或删除现有的项目。它们将跨越多行和多列，您可以通过拖动对它们进行重新排序。我加入了Unsplash的随机图片，让它更有趣。</p>
<pre>import React, { useState } from 'react';
import { motion } from 'framer-motion';
import { v4 as uuid } from ‘uuid’;

const App = () =&gt; {
  const [cards, setCards] = useState(defaultCards);

  async function addCard() {
    const res = await fetch('https://source.unsplash.com/random');
    if (!res.ok) return;
    const id = uuid()
    const card = { id, img: res.url };
    setCards([...cards, card]);
  }

 function removeCard() {
    setCards(cards.filter((card) =&gt; card !== card.id));
  }

  return (
    &lt;div className='app'&gt;
      &lt;div&gt;
        &lt;h1&gt;Sweet Animations!&lt;/h1&gt;
      &lt;/div&gt;
      &lt;button className="btn btn-primary" onClick={addCard}&gt;
        Add Card
      &lt;/button
      &lt;div className='list'&gt;
        {cards.map(card =&gt; (
          &lt;Card
            card={card}
            setCards={setCards}
            removeCard={removeCard}
            key={card.id} /&gt;
        ))}
      &lt;/div&gt;
    &lt;/div&gt;  
  )
}

const Card = ({ card, setCards, removeCard }) =&gt; {
  function handleRemove() {
    removeCard(card.id);
  }

  return (
    &lt;div className="card" style={{ width: "18rem" }}&gt;
      &lt;img src={card.img} className="card-img-top" alt="..." /&gt;
      &lt;div className="card-body"&gt;
        &lt;h5 className="card-title"&gt;Cool Image&lt;/h5&gt;
      &lt;/div&gt;
    &lt;/div&gt;
  );
}

const defaultCards = [
  {
    id: 0,
    img: "https://images.unsplash.com/photo-1587900437942-8758241767ef?crop=entropy&amp;cs=tinysrgb&amp;fit=crop&amp;fm=jpg&amp;h=400&amp;ixlib=rb-1.2.1&amp;q=80&amp;w=300",
  },
  {
    id: 1,
    img: "https://images.unsplash.com/photo-1586336900429-71f0642f66fd?crop=entropy&amp;cs=tinysrgb&amp;fit=crop&amp;fm=jpg&amp;h=400&amp;ixlib=rb-1.2.1&amp;q=80&amp;w=300",
  },
];
</pre>
<p>让我们从添加新图像时播放的动画开始。首先，我们需要转换我们的<code>Card</code>组件来使用<code>motion.div</code>而不是<code>div</code>，这样我们就可以访问所有的动画。</p>
<pre>const Card = ({ card, removeCard }) =&gt; {
  function handleRemove() {
    removeCard(card.id);
  }

  return (
    &lt;motion.div className="card" style={{ width: "18rem" }}&gt;
      &lt;img src={card.img} className="card-img-top" alt="..." /&gt;
      &lt;div className="card-body"&gt;
        &lt;h5 className="card-title"&gt;Cool Image&lt;/h5&gt;
      &lt;/div&gt;
    &lt;/motion.div&gt;
  );
};
</pre>
<p>然后我们需要给我们的<code>motion.div</code>加上一个<code>initial</code>值和一个<code>animate</code>值。我们将使它从左边滑动和淡入。</p>
<pre>initial={{ x: "-300px", opacity: 0 }}
animate={{ x: 0, opacity: 1 }
</pre>
<h2 id="svg-animation">成帧器运动中的SVG动画</h2>
<p>制作SVGs动画是我最喜欢的<a href="https://blog.logrocket.com/introduction-to-react-motion/" target="_blank" rel="noopener noreferrer"> React Motion </a>功能之一。我们将添加一个remove按钮，它将是一个带有<code>motion.path</code> s的<code>motion.svg</code>。您可以动画显示路径元素的<code>pathLength</code>、<code>pathSpacing</code>和<code>pathOffset</code>属性。</p>
<pre>&lt;motion.div className="card" style={{ width: "18rem" }}&gt;
      &lt;motion.svg
        
        width="24"
        height="24"
        viewBox="0 0 24 24"
        fill="none"
        stroke="#333"
        stroke-width="2"
        stroke-linecap="round"
        stroke-linejoin="round"
        onClick={handleRemove}
      &gt;
        &lt;motion.path d="M 18 6 L 6 18"  /&gt;
        &lt;motion.path d="M 6 6 L 18 18"  /&gt;
      &lt;/motion.svg&gt;      
      &lt;img src={card.img} className="card-img-top" alt="..." /&gt;
      &lt;div className="card-body"&gt;
        &lt;h5 className="card-title"&gt;Cool Image&lt;/h5&gt;
      &lt;/div&gt;
    &lt;/motion.div&gt;
</pre>
<p>让我们给这个SVG添加几个动画。在mount上，它会一个接一个地画两条线。悬停时，它会使线条变粗。</p>
<p>为了达到这个效果，我们需要父<code>motion.svg</code>和子<code>motion.path</code>链接起来，这样我们就可以错开子路径的动画。</p>
<p>我们可以使用名为<code>variants</code>的成帧器运动道具来做到这一点。<code>variants</code>接受具有已定义状态属性的对象。然后你可以将它们作为动画状态的值来传递，比如<code>animate</code>或者<code>initial</code>。除非被覆盖，否则这些值将自动传递给子代。</p>
<pre>// example usage
&lt;motion.div
  variants={{ 
    mount: { opacity: 0.5 },
    rest: { opacity: 1 }
  }}
  initial='mount'
  animate='rest'
/&gt;
</pre>
<p>我们将关注三种状态:<code>initial</code>、<code>animate</code>和<code>hover</code>。在<code>animate</code>内，我们还需要定义一个转场，这个转场将决定动画需要多长时间以及孩子的蹒跚。</p>
<p><code>staggerChildren</code>定义每个孩子的动画开始之间应该经过多长时间。<code>when</code>定义这些动画应该开始的点。值为<code>afterChildren</code>意味着交错延迟将发生在子动画之后。<code>beforeChildren</code>表示相反的意思——在动画开始前等待规定的时间。</p>
<p>这里的主要区别在于第一个动画，它是立即开始(<code>afterChildren</code>)还是短暂等待(<code>beforeChildren</code>)。我们不想耽误第一个孩子的动画，所以我们将使用<code>afterChildren</code>。</p>
<pre>const variants = {
  initial: {
    strokeWidth: 2,
    pathLength: 0,
  },
  animate: {
    pathLength: 1,
    transition: { duration: 1, when: "afterChildren", staggerChildren: 1 },
  },
  hover: {
    strokeWidth: 4,
  },
};


&lt;motion.svg
  
  width="24"
  height="24"
  viewBox="0 0 24 24"
  fill="none"
  stroke="#333"
  stroke-width="2"
  stroke-linecap="round"
  stroke-linejoin="round"
  variants={variants}
  initial="initial"
  animate="animate"
  whileHover="hover"
  onClick={handleRemove}
&gt;
  &lt;motion.path d="M 18 6 L 6 18" variants={variants} /&gt;
  &lt;motion.path d="M 6 6 L 18 18" variants={variants} /&gt;
&lt;/motion.svg&gt;
</pre>
<p>类似于我们在mount上创建的动画，我们想为退出动画创建一个，它将向上滑动并淡出。</p>
<p>当一个<code>Card</code>被移除时，React从DOM中移除该组件。因此，我们需要用一个特殊的组件<code>AnimatePresence</code>来包装我们的<code>Card</code>组件。这允许Framer Motion跟踪组件何时卸载，并延迟它，直到动画结束。</p>
<p>我们实际上可以包装组件列表，而不是单独包装每个组件，但是我们需要确保它们是直接子组件。</p>
<pre>&lt;div className="list"&gt;
    &lt;AnimatePresence&gt;
      {cards.map((card) =&gt; (
        &lt;Card key={card.id} card={card} removeCard={removeCard} /&gt;
      ))}
    &lt;/AnimatePresence&gt;
&lt;/div&gt;
</pre>
<p>一旦被这个组件包装，<code>motion.div</code>接受一个<code>exit</code>道具，这将是退出时的动画状态。</p>
<pre>&lt;motion.div
  initial={{ x: "-300px", opacity: 0 }}
  animate={{ x: 0, opacity: 1 }}
  exit={{ y: '-300px', opacity: 0 }}
&gt;
&lt;/motion.div&gt;
</pre>
<p>当一个<code>Card</code>被移除时，假设我们希望其他的<code>Card</code>滑过而不是跳到位置上。成帧器运动使这项通常困难的任务变得轻而易举。一个运动组件接受一个道具<code>layout</code>，它将自动动画显示它在布局中位置的任何变化。</p>
<pre> &lt;motion.div
  initial={{ x: "-300px", opacity: 0 }}
  animate={{ x: 0, opacity: 1 }
  exit={{ exit={{ y: '-300px', opacity: 0 }}
  layout
&gt;
&lt;/motion.div&gt;
</pre>
<p>您可能会注意到，不幸的是，在移除的项目动画完成之前，新位置的动画不会出现。在动画完成之前，该项仍然存在于DOM中，因此，其他项的位置还没有改变。这不是一个容易解决的问题，并且《框架运动》的作者<a href="https://github.com/framer/motion/issues/215" target="_blank" rel="noopener noreferrer">已经承认这是一个困难的案例</a>。</p>
<p>不确定图书馆是否会提供解决方案。幸运的是，您可以通过向项目添加一些条件样式来解决这个问题，这将在退出动画出现时将它们从DOM的布局中移除。这允许位置转换同时发生。</p>
<p>为了实现这一点，我们需要知道卡片何时被取出以及它在此时的位置。Framer Motion有两个内置挂钩，可供<code>AnimatePresence</code>的孩子使用，他们是<code>usePresence</code>和<code>useIsPresent</code>。这两个钩子都返回<code>isPresent</code>,通知你项目何时被移除，但是在任何退出动画出现之前。<code>usePresence</code>还返回了一个<code>safeToRemove</code>函数，您必须手动调用该函数才能从DOM中完全移除元素。</p>
<p>在这种情况下，我们只需要<code>isPresent</code>变量，所以我们将使用<code>useIsPresent</code>和帧运动将处理删除元素。</p>
<p>为了获得卡的位置，我们将使用一个<code>ref</code>，这是React访问DOM节点的方法，以及<code>getBoundingClientRect</code>。当删除一个项目时，它会首先更新<code>position</code>。当<code>isPresent</code>为假时，我们将用<code>position: absolute</code>来设计<code>Card</code>的样式，将它从布局中移除，并将<code>left</code>和<code>top</code>设置到计算的位置。</p>
<pre>const Card = ({ card, removeCard }) =&gt; {
  const [position, setPosition ] = useState({ left: 0, top: 0})
  const cardRef = useRef(null);
  const isPresent = useIsPresent();

  function handleRemove() {
    const position = cardRef.current.getBoundingClientRect();
    setPosition(position);
    removeCard(card.id);    
  }
  return (
    &lt;motion.div
      initial={{ x: "-300px", opacity: 0 }}
      animate={{ x: 0, opacity: 1 }}
      exit={{ y: "-300px", opacity: 0 }}
      layout
      className="card"
      style={{
        width: "18rem",
        position: !isPresent ? "absolute" : "block",
        left: !isPresent ? position.left : "auto",
        top: !isPresent ? position.top : "auto",
      }}
      ref={cardRef}
    &gt;
      &lt;img src={card.img} className="card-img-top" alt="..." /&gt;
      // ... svg
      &lt;div className="card-body"&gt;
        &lt;h5 className="card-title"&gt;Cool Image&lt;/h5&gt;
      &lt;/div&gt;
    &lt;/motion.div&gt;
  );
}
</pre>
<h2 id="dragging">在帧运动中拖动</h2>
<p>另一个常见的特性是能够通过拖动项目来重新排序项目列表。我们将启用拖动来向左/向右或向上/向下移动卡片。首先，我们需要使用<code>drag</code>道具来启用拖动。我们允许向任何方向拖动，但是如果你有一个垂直/水平的列表，你可以用<code>drag='x'</code>或<code>drag='y'</code>来限制方向。</p>
<p>注意:由于我们使用的是图像，我们还必须禁用对<code>*img*</code>元素的自然拖动。根据您的浏览器支持，您可以通过几种方式实现这一点。这里我们用一些CSS来简单的移除指针事件，这已经在我们的CSS文件中完成了。</p>
<pre>&lt;motion.div
  // other properties
  drag
/&gt;
</pre>
<p>这将允许您将元素拖动到页面上的任何位置，但它实际上会停留在那个位置。您可以使用<code>dragConstraints</code>定义您希望元素被拖动到的区域。<code/></p>
<p><code>dragConstraints</code>取一个具有上/下/左/右属性的对象。我们将这些都设置为<code>0</code>，这样元素在拖动后会返回到相同的位置(您仍然可以将它拖动到这些界限之外)。如果您想调整元素可以从这些约束拖动多远，您可以使用<code>dragElastic</code>道具，它取一个在<code>0</code>(没有超出约束拖动)和<code>1</code>(从约束拖动到您想要的距离)之间的值。</p>
<pre>&lt;motion.div
  // other properties
  drag
  dragConstraints={{ top: 0, right: 0, bottom: 0, left: 0 }} 
/&gt;
</pre>
<p>还有一些回调函数道具可以用来插入不同的行为——即<code>onDrag</code>、<code>onDragStart</code>、<code>onDragEnd</code>。这些函数传递事件的参数和一个包含相关信息的拖动对象。我们将使用<code>onDragEnd</code>来计算我们的重新定位。</p>
<pre>&lt;motion.div
  // other properties
  drag
  dragConstraints={{ top: 0, right: 0, bottom: 0, left: 0 }}
  onDragEnd={(e, drag) =&gt; moveCard(drag.offset, i)} 
  // we will write the move card function in a moment
/&gt;
</pre>
<p>通过传递给<code>onDragEnd</code>的拖动参数，我们可以得到元素从其自然位置被拖动的距离。在<code>moveCard</code>中，我们将使用这个点来确定方向，以及它是否被拖得足够远以构成重新排序。</p>
<pre>// App.js
function moveCard(offset, index) {
  let reorderedCards = [...cards];
  let movedFrom = index;
  let movedTo = index;

  if (offset.x &lt;= -100) {
    movedTo = index - 1;
  }
  if (offset.x &gt;= 100) {
    movedTo = index + 1;
  }
  if (offset.y &gt;= 100) {
    movedTo = index + 4;
  }
  if (offset.y &lt;= -100) {
    movedTo = index - 4;
  }

  if (movedFrom !== movedTo &amp;&amp; cards[movedFrom] &amp;&amp; cards[movedTo]) {
    reorderedCards[movedFrom] = cards[movedTo];
    reorderedCards[movedTo] = cards[movedFrom];
    setCards(reorderedCards);
  }
}

// don't forget to pass it down as a prop to the `Card` element.
</pre>
<h2>摘要</h2>
<p>现在我们有了一个基本的应用程序，它实现了各种常见的功能和动画。希望本教程给你一个坚实的基础，添加一些很棒的动画到你的库中，并随着时间的推移建立它们来满足你的所有需求。</p><div class="code-block code-block-17">
<div class="blog-plug inline-plug react-plug" vwo-el-id="26283398190">
<h2 vwo-el-id="41600691720"><a href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener"> LogRocket </a>:全面了解您的生产React应用</h2><p>调试React应用程序可能很困难，尤其是当用户遇到难以重现的问题时。如果您对监视和跟踪Redux状态、自动显示JavaScript错误以及跟踪缓慢的网络请求和组件加载时间感兴趣，</p><a href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" vwo-el-id="19356441070">try LogRocket</a><p>. </p><a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="19356441380">
<img class="first-react-image alignnone size-full wp-image-46 jetpack-lazy-image jetpack-lazy-image--handled" src="../Images/f300c244a1a1cf916df8b4cb02bec6c6.png" vwo-el-id="18272717540" data-lazy-loaded="1" data-original-src="https://files.readme.io/27c94e7-Image_2017-06-05_at_9.46.04_PM.png"/>
</a>
<a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="19356441690">
<img class="second-react-image alignnone size-full wp-image-46 jetpack-lazy-image jetpack-lazy-image--handled" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" vwo-el-id="30720362350" data-lazy-loaded="1" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/>
</a>
<p vwo-el-id="28675660440" class="">LogRocket 结合了会话回放、产品分析和错误跟踪，使软件团队能够创建理想的web和移动产品体验。这对你来说意味着什么？</p>
<p>LogRocket不是猜测错误发生的原因，也不是要求用户提供截图和日志转储，而是让您回放问题，就像它们发生在您自己的浏览器中一样，以快速了解哪里出错了。</p>
<p>不再有嘈杂的警报。智能错误跟踪允许您对问题进行分类，然后从中学习。获得有影响的用户问题的通知，而不是误报。警报越少，有用的信号越多。</p>
<p vwo-el-id="28675660750">LogRocket Redux中间件包为您的用户会话增加了一层额外的可见性。LogRocket记录Redux存储中的所有操作和状态。</p>
<p vwo-el-id="28675661060">现代化您调试React应用的方式— <a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="40093418840">开始免费监控</a>。</p>
</div></div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
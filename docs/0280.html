<html>
<head>
<title>The noob’s guide to 3D transforms with CSS - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>noob的CSS 3D转换指南- LogRocket博客</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/the-noobs-guide-to-3d-transforms-with-css-7370aafd9edf/#0001-01-01">https://blog.logrocket.com/the-noobs-guide-to-3d-transforms-with-css-7370aafd9edf/#0001-01-01</a></blockquote><div><article class="article-post">
<figure class="graf graf--figure"><img decoding="async" class="graf-image jetpack-lazy-image" src="../Images/5dc572161e9bf4efea0c80e5feea03a7.png" data-image-id="1*9b-zGEjNmyi1fAuwsbX7Zg.png" data-width="1248" data-height="558" data-is-featured="true" data-lazy-src="https://cdn-images-1.medium.com/max/1600/1*9b-zGEjNmyi1fAuwsbX7Zg.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://cdn-images-1.medium.com/max/1600/1*9b-zGEjNmyi1fAuwsbX7Zg.png"/><noscript><img data-lazy-fallback="1" decoding="async" class="graf-image" src="../Images/5dc572161e9bf4efea0c80e5feea03a7.png" data-image-id="1*9b-zGEjNmyi1fAuwsbX7Zg.png" data-width="1248" data-height="558" data-is-featured="true" data-original-src="https://cdn-images-1.medium.com/max/1600/1*9b-zGEjNmyi1fAuwsbX7Zg.png"/></noscript></figure>
<p class="graf graf--p">大多数网站和界面被限制在二维空间，最多模仿3D效果。以你最常见的日常界面为例:社交媒体、移动设备应用，或许还有生产力工具。所有这些都具有带有少量二维动画的二维按钮。使用投影和叠加对象，这些界面可以在二维中模仿三维效果。</p>
<p class="graf graf--p">然而，这些界面中的大多数都缺少真正的三维变换。当CSS转换在2009年首次引入时，缺乏浏览器支持或低效的客户端呈现可以证明坚持二维是合理的。然而，CSS 3D转换现在<a class="markup--anchor markup--p-anchor" href="https://caniuse.com/#feat=transforms3d" target="_blank" rel="noopener noreferrer" data-href="https://caniuse.com/#feat=transforms3d">被普遍支持</a>和<a class="markup--anchor markup--p-anchor" href="https://www.smashingmagazine.com/2016/12/gpu-animation-doing-it-right/" target="_blank" rel="noopener noreferrer" data-href="https://www.smashingmagazine.com/2016/12/gpu-animation-doing-it-right/">根据经验测试</a>，CSS转换被硬件加速。此外，根据前微软创意人Claudio Gulgieri在<a class="markup--anchor markup--p-anchor" href="https://www.youtube.com/watch?v=njcpgtnyKRk" target="_blank" rel="noopener noreferrer" data-href="https://www.youtube.com/watch?v=njcpgtnyKRk"> TEDxBerkeley的演讲</a>,当设计师利用物理的三维世界时，数字界面会受益:熟悉“界面”,如门把手、拨号盘、扑克牌等，并扩展到数字界面中的类似物。然而，模仿阴影等效果只是一个开始。</p>
<p class="graf graf--p">有许多三维属性可以利用，例如，用户知道一个三维物体有多少个面。一张翻转的卡片暗示只有两面存在。一个绕一个轴旋转的盒子意味着四个轴。此外，用户知道如何与不同的3D对象交互。刻度盘应该旋转，陀螺应该旋转。不同的界面有不同的机会利用对三维物体的熟悉度——有些界面根本没有空间。</p>
<figure class="graf graf--figure graf--layoutOutsetCenter"><a class="graf-imageAnchor" href="https://logrocket.com/signup/" target="_blank" rel="noopener noreferrer" data-href="https://logrocket.com/signup/" data-action="image-link" data-action-observe-only="true"><img decoding="async" class="graf-image jetpack-lazy-image" src="../Images/37fb366b01f8ba4b23129468d1953129.png" data-image-id="1*GPjaPKNNUYHU8EsA3Z0JGA.png" data-width="3212" data-height="750" data-lazy-src="https://cdn-images-1.medium.com/max/2400/1*GPjaPKNNUYHU8EsA3Z0JGA.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://cdn-images-1.medium.com/max/2400/1*GPjaPKNNUYHU8EsA3Z0JGA.png"/><noscript><img data-lazy-fallback="1" decoding="async" class="graf-image" src="../Images/37fb366b01f8ba4b23129468d1953129.png" data-image-id="1*GPjaPKNNUYHU8EsA3Z0JGA.png" data-width="3212" data-height="750" data-original-src="https://cdn-images-1.medium.com/max/2400/1*GPjaPKNNUYHU8EsA3Z0JGA.png"/></noscript></a></figure>
<p class="graf graf--p">然而，这个介绍性的指南将会给你足够的体验来理解3D变换。有了这样的理解，你就可以自己决定3D转换是好事还是负担。在本指南中，我们将探索基本的3D变换和一些用例，讨论使用CSS在3D中进一步工作的必要构件。在本指南的结尾，您将看到下面翻转卡片和盒子的示例代码，使用我们下面讨论的概念。</p>
<figure class="graf graf--figure"><img decoding="async" class="graf-image jetpack-lazy-image" src="../Images/702921334b9d1e1de190aa94897ec3d7.png" data-image-id="0*wJ65x6TeT8Mk9ATG.gif" data-width="569" data-height="326" data-lazy-src="https://cdn-images-1.medium.com/max/1600/0*wJ65x6TeT8Mk9ATG.gif?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://cdn-images-1.medium.com/max/1600/0*wJ65x6TeT8Mk9ATG.gif"/><noscript><img data-lazy-fallback="1" decoding="async" class="graf-image" src="../Images/702921334b9d1e1de190aa94897ec3d7.png" data-image-id="0*wJ65x6TeT8Mk9ATG.gif" data-width="569" data-height="326" data-original-src="https://cdn-images-1.medium.com/max/1600/0*wJ65x6TeT8Mk9ATG.gif"/></noscript></figure>
<figure class="graf graf--figure"><img decoding="async" class="graf-image jetpack-lazy-image" src="../Images/67ff4e20fdb6b64d233f119798bbc09c.png" data-image-id="0*FL4Ajj3WEViWWdAG.gif" data-width="569" data-height="259" data-lazy-src="https://cdn-images-1.medium.com/max/1600/0*FL4Ajj3WEViWWdAG.gif?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://cdn-images-1.medium.com/max/1600/0*FL4Ajj3WEViWWdAG.gif"/><noscript><img data-lazy-fallback="1" decoding="async" class="graf-image" src="../Images/67ff4e20fdb6b64d233f119798bbc09c.png" data-image-id="0*FL4Ajj3WEViWWdAG.gif" data-width="569" data-height="259" data-original-src="https://cdn-images-1.medium.com/max/1600/0*FL4Ajj3WEViWWdAG.gif"/></noscript></figure>
<h3 class="graf graf--h3">转换</h3>
<p class="graf graf--p">首先，我们将使用基本的二维正方形来说明三维空间中的变换。变换包括三种基本操作，即平移、旋转和缩放，它们控制对象的放置和方向。所有变换都围绕三个轴:</p>
<ol class="postList">
<li class="graf graf--li"><strong class="markup--strong markup--li-strong"> x轴</strong>从左向右运行，数值向右增加</li>
<li class="graf graf--li"><strong class="markup--strong markup--li-strong"> y轴</strong>自下而上直线运行，数值向上递增</li>
<li class="graf graf--li"><strong class="markup--strong markup--li-strong"> z轴</strong>从屏幕上突出，数值越高越靠近观察者。所有三个轴如下图所示:</li>
</ol>
<figure class="graf graf--figure"><img decoding="async" class="graf-image jetpack-lazy-image" src="../Images/1d84f0ef2321dc516df2ec68b329357a.png" data-image-id="0*bxMneFPF6loTMIlI.png" data-width="960" data-height="540" data-lazy-src="https://cdn-images-1.medium.com/max/1600/0*bxMneFPF6loTMIlI.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://cdn-images-1.medium.com/max/1600/0*bxMneFPF6loTMIlI.png"/><noscript><img data-lazy-fallback="1" decoding="async" class="graf-image" src="../Images/1d84f0ef2321dc516df2ec68b329357a.png" data-image-id="0*bxMneFPF6loTMIlI.png" data-width="960" data-height="540" data-original-src="https://cdn-images-1.medium.com/max/1600/0*bxMneFPF6loTMIlI.png"/></noscript></figure>
<p class="graf graf--p">我们下面讨论的转换都在这三个轴上运行。总共有三个转变；第一个是沿着一个或多个轴的<strong class="markup--strong markup--p-strong">平移</strong>，或者运动。使用<code>translateX</code>、<code>translateY</code>和<code>translateZ</code>，或者使用简写<code>translate3d</code>在三维空间中移动对象。</p>
<p> </p>
<p class="graf graf--p">这里是沿着每个轴平移的<a class="markup--anchor markup--p-anchor" href="https://codepen.io/alvinwan/pen/WPapwm?editors=1100" target="_blank" rel="noopener noreferrer" data-href="https://codepen.io/alvinwan/pen/WPapwm?editors=1100"> codepen演示。</a></p>
<figure class="graf graf--figure"><img decoding="async" class="graf-image jetpack-lazy-image" src="../Images/eb13f0ab19106baeaac03a7cc46b661f.png" data-image-id="0*rHx01ECKRlH54RZI.gif" data-width="720" data-height="232" data-lazy-src="https://cdn-images-1.medium.com/max/1600/0*rHx01ECKRlH54RZI.gif?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://cdn-images-1.medium.com/max/1600/0*rHx01ECKRlH54RZI.gif"/><noscript><img data-lazy-fallback="1" decoding="async" class="graf-image" src="../Images/eb13f0ab19106baeaac03a7cc46b661f.png" data-image-id="0*rHx01ECKRlH54RZI.gif" data-width="720" data-height="232" data-original-src="https://cdn-images-1.medium.com/max/1600/0*rHx01ECKRlH54RZI.gif"/></noscript></figure>
<p class="graf graf--p">为了便于<strong class="markup--strong markup--p-strong">绕一个或多个轴旋转</strong>，使用<code>rotateX</code>、<code>rotateY</code>和<code>rotateZ</code>。和以前一样，这里有一个简写<code>rotate3d</code>。</p>
<pre>.translated-square {
  transform: 
    translateX(20px)  /* move right */
    translateY(-20px)  /* move down */
    translateZ(20px);  /* move closer to viewer */
}

.translated-square-shorthand {
  transform: translate3d(20px, -20px, 20px);
}</pre>
<p class="graf graf--p">绕z轴的旋转等同于在2D的旋转。然而，围绕x轴和y轴的旋转是非常不同的效果。这里是围绕每个轴旋转的<a class="markup--anchor markup--p-anchor" href="https://codepen.io/alvinwan/pen/aXRJYW?editors=1100" target="_blank" rel="noopener noreferrer" data-href="https://codepen.io/alvinwan/pen/aXRJYW?editors=1100">代码演示。</a></p>
<figure class="graf graf--figure"><img decoding="async" class="graf-image jetpack-lazy-image" src="../Images/596741013c16d3d7f6fafd6206529b28.png" data-image-id="0*QRkV6p3FsJx9U_lD.gif" data-width="720" data-height="232" data-lazy-src="https://cdn-images-1.medium.com/max/1600/0*QRkV6p3FsJx9U_lD.gif?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://cdn-images-1.medium.com/max/1600/0*QRkV6p3FsJx9U_lD.gif"/><noscript><img data-lazy-fallback="1" decoding="async" class="graf-image" src="../Images/596741013c16d3d7f6fafd6206529b28.png" data-image-id="0*QRkV6p3FsJx9U_lD.gif" data-width="720" data-height="232" data-original-src="https://cdn-images-1.medium.com/max/1600/0*QRkV6p3FsJx9U_lD.gif"/></noscript></figure>
<p class="graf graf--p">第三个也是最后一个变换是关于一个或多个轴的<strong class="markup--strong markup--p-strong">缩放</strong>。重申一下，缩放就是简单地调整对象的大小。使用<code>scaleX</code>、<code>scaleY</code>、<code>scaleZ</code>，或简称<code>scale3d</code>。由于我们的演示广场只存在于二维空间，在z维度上缩放是没有意义的。然而，缩放x或y相当于改变正方形的宽度或高度。</p>
<pre>.scaled-square {
  transform: 
    scaleX(20deg)  /* flip "up" */
    scaleY(-20deg)  /* flip "right" */
    scaleZ(20deg);  /* rotate counter-clockwise */
}

.scaled-square-shorthand {
  transform: scale3d(20deg, -20deg, 20deg);
}</pre>
<h3 class="graf graf--h3">参照系</h3>
<p class="graf graf--p">请注意，所有变换都是相对于参考框架进行操作的。为了更好地理解这一概念，请设想以下场景:</p>
<ol class="postList">
<li class="graf graf--li">一列火车正沿着铁路行驶。这列火车正向北移动，相对于地球</li>
<li class="graf graf--li">列车员坐在火车里扔苹果。这个苹果相对于火车上下移动<em class="markup--em markup--li-em">。在火车的参照系中，没有“北”的概念。关于火车，这个苹果只是上下移动</em></li>
<li class="graf graf--li">然而，<em class="markup--em markup--li-em">相对于地球</em>，苹果实际上是向北<em class="markup--em markup--li-em">和</em>上下移动</li>
</ol>
<p class="graf graf--p">注意参照系决定了我们如何描述苹果的运动。同样，以下面的HTML代码片段为例。我们将看到每个对象的参考系都是它在文档对象模型(DOM)中的父对象。换句话说，对于下面的例子，父对象类似于火车，子对象类似于苹果。</p>
<pre>&lt;div class="square parent"&gt;
  &lt;div class="square child"&gt;&lt;/div&gt;
&lt;/div&gt;</pre>
<p class="graf graf--p">假设我们将父元素向右平移20个像素，将子元素向上平移20个像素。</p>
<pre>.parent {
  transform: translateX(20px);
}

.child {
  transform: translateY(20px);
}</pre>
<p class="graf graf--p">子节点的向上平移是相对于父节点的<em class="markup--em markup--p-em">，这意味着子节点将总共向右<em class="markup--em markup--p-em">平移20像素，向上</em>平移20像素。</em></p>
<figure class="graf graf--figure"><img decoding="async" class="graf-image jetpack-lazy-image" src="../Images/689157fee29453e8bb67d3058aed4250.png" data-image-id="0*x5HiRBGi1lwR70RI.png" data-width="960" data-height="540" data-lazy-src="https://cdn-images-1.medium.com/max/1600/0*x5HiRBGi1lwR70RI.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://cdn-images-1.medium.com/max/1600/0*x5HiRBGi1lwR70RI.png"/><noscript><img data-lazy-fallback="1" decoding="async" class="graf-image" src="../Images/689157fee29453e8bb67d3058aed4250.png" data-image-id="0*x5HiRBGi1lwR70RI.png" data-width="960" data-height="540" data-original-src="https://cdn-images-1.medium.com/max/1600/0*x5HiRBGi1lwR70RI.png"/></noscript></figure>
<p class="graf graf--p">参考框架允许我们将不同的3D对象组合在一起，并使用积木来组装更复杂的3D对象。为了更好地理解参考框架，请随意使用这个<a class="markup--anchor markup--p-anchor" href="https://codepen.io/alvinwan/pen/PVypMr" target="_blank" rel="noopener noreferrer" data-href="https://codepen.io/alvinwan/pen/PVypMr">参考框架的</a>codepen演示。我们对转换的讨论到此结束。在下一节中，我们将讨论相机的属性。</p>
<h3 class="graf graf--h3">远景</h3>
<p class="graf graf--p">到目前为止，在CSS规范中，透视是相机设置的总称。一个这样的设置是观察者和物体之间的距离。这由<code>perspective</code>属性本身控制。较低的透视值会产生放大的3D效果，而较高的透视值会产生柔和的3D效果。在这个<a class="markup--anchor markup--p-anchor" href="https://codepen.io/alvinwan/pen/xMyWKB" target="_blank" rel="noopener noreferrer" data-href="https://codepen.io/alvinwan/pen/xMyWKB">透视</a>的codepen演示中，透视值向右移动增加。</p>
<pre>.square {
  transform: perspective(200px) rotateX(20deg);
}</pre>
<p class="graf graf--p">物体离得越远，3D效果就越不强烈。</p>
<figure class="graf graf--figure"><img decoding="async" class="graf-image jetpack-lazy-image" src="../Images/c4101deb0c822a193b6c98027a0c3aa3.png" data-image-id="0*KG18uKSU1_4LJ1W3.gif" data-width="707" data-height="227" data-lazy-src="https://cdn-images-1.medium.com/max/1600/0*KG18uKSU1_4LJ1W3.gif?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://cdn-images-1.medium.com/max/1600/0*KG18uKSU1_4LJ1W3.gif"/><noscript><img data-lazy-fallback="1" decoding="async" class="graf-image" src="../Images/c4101deb0c822a193b6c98027a0c3aa3.png" data-image-id="0*KG18uKSU1_4LJ1W3.gif" data-width="707" data-height="227" data-original-src="https://cdn-images-1.medium.com/max/1600/0*KG18uKSU1_4LJ1W3.gif"/></noscript></figure>
<p class="graf graf--p">设置透视图还有第二种方法，第一种方法是像上面那样设置属性，另一种方法是调用函数，如下所示:</p>
<pre>.scene.close {
  perspective: 10em;
}

.scene.medium {
  perspective: 20em;
}

.scene.far {
  perspective: 100em;</pre>
<p class="graf graf--p">注意，在调用<code>rotateX</code>函数之前，必须调用<code>perspective</code>函数<em class="markup--em markup--p-em">才能生效。此外，第二种方法仅适用于单个对象的透视。在下面的<a class="markup--anchor markup--p-anchor" href="https://codepen.io/alvinwan/pen/BMqrRd" target="_blank" rel="noopener noreferrer" data-href="https://codepen.io/alvinwan/pen/BMqrRd">透视组的代码公开演示</a>中，我们看到了共享透视(左)和个人透视(右)之间的区别。</em></p>
<figure class="graf graf--figure"><img decoding="async" class="graf-image jetpack-lazy-image" src="../Images/ee92f47224a7dea3e4de01375a0df559.png" data-image-id="0*i4pbzc1SVthUfe-5.gif" data-width="767" data-height="227" data-lazy-src="https://cdn-images-1.medium.com/max/1600/0*i4pbzc1SVthUfe-5.gif?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://cdn-images-1.medium.com/max/1600/0*i4pbzc1SVthUfe-5.gif"/><noscript><img data-lazy-fallback="1" decoding="async" class="graf-image" src="../Images/ee92f47224a7dea3e4de01375a0df559.png" data-image-id="0*i4pbzc1SVthUfe-5.gif" data-width="767" data-height="227" data-original-src="https://cdn-images-1.medium.com/max/1600/0*i4pbzc1SVthUfe-5.gif"/></noscript></figure>
<p class="graf graf--p">有了距离设置，我们还可以配置摄像机角度。具体来说，<code>perspective-origin</code>属性确定了消失点在场景中的位置。将消失点设置在左侧就好像观众向左移动。同样，将消失点设置在顶部就好像观察者从更高的角度观察物体。下面是不同视角起源的<a class="markup--anchor markup--p-anchor" href="https://codepen.io/alvinwan/pen/exPMXq" target="_blank" rel="noopener noreferrer" data-href="https://codepen.io/alvinwan/pen/exPMXq">代码笔演示。</a></p>
<figure class="graf graf--figure"><img decoding="async" class="graf-image jetpack-lazy-image" src="../Images/df46b34b662ef1b76ccf38db2995fb53.png" data-image-id="0*m3TGWvcdDaM-Wio_.gif" data-width="728" data-height="226" data-lazy-src="https://cdn-images-1.medium.com/max/1600/0*m3TGWvcdDaM-Wio_.gif?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://cdn-images-1.medium.com/max/1600/0*m3TGWvcdDaM-Wio_.gif"/><noscript><img data-lazy-fallback="1" decoding="async" class="graf-image" src="../Images/df46b34b662ef1b76ccf38db2995fb53.png" data-image-id="0*m3TGWvcdDaM-Wio_.gif" data-width="728" data-height="226" data-original-src="https://cdn-images-1.medium.com/max/1600/0*m3TGWvcdDaM-Wio_.gif"/></noscript></figure>
<p class="graf graf--p">相机设置到此结束。在本节中，我们讨论了如何设置摄像机的距离和位置。在接下来的两节中，除了上面的变换，我们还将使用这些相机效果来构建简单的几何对象和3D效果。</p>
<h3 class="graf graf--h3">示例1:翻转卡片</h3>
<p class="graf graf--p">2012年，幻想互动在他们的<a class="markup--anchor markup--p-anchor" href="https://www.facebook.com/Fi/videos/10151250080289923/" target="_blank" rel="noopener noreferrer" data-href="https://www.facebook.com/Fi/videos/10151250080289923/">重新设计的《今日美国》</a>中使用了翻转卡片，标题在一边，文章的序言在另一边。在这一节中，我们将使用我们到目前为止接触过的技术重新创建这张翻转卡。</p>
<p class="graf graf--p">在<a class="markup--anchor markup--p-anchor" href="https://codepen.io/" target="_blank" rel="noopener noreferrer" data-href="http://codepen.io/"> codepen.io </a>创建一个新的codepen。在HTML部分，定义您的卡。</p>
<ol class="postList">
<li class="graf graf--li">总是从定义一个场景来保存3D对象开始</li>
<li class="graf graf--li">在这个场景中，我们添加了我们的卡</li>
<li class="graf graf--li">该卡包含两个面，每个面将是一个2D矩形物体</li>
</ol>
<pre>&lt;div class="scene"&gt;
  &lt;div class="card"&gt;
    &lt;div class="face front"&gt;front&lt;/div&gt;
    &lt;div class="face back"&gt;back&lt;/div&gt;
  &lt;/div&gt;
&lt;/div&gt;</pre>
<figure class="graf graf--figure graf--iframe"/>
<p class="graf graf--p">在你的CSS中，定义一个场景，包括它的视角。</p>
<pre>.scene {
  width:10em;
  height:15em;
  perspective: 30em;
}</pre>
<p class="graf graf--p">接下来，设计你的卡片对象。在这里，添加一个额外的属性<code>transform-style</code>，它控制子元素是如何呈现的——这个属性将决定子元素是在2D还是在3D空间中呈现。使用值<code>preserve-3d</code>确保卡的两面以3D方式呈现。</p>
<pre>.card {
  width:100%;
  height:100%;
  position:relative;
  transition: transform 0.5s;
  transform-style: preserve-3d;
}</pre>
<p class="graf graf--p">接下来，设计你的卡片的两面。最关键的属性是<code>backface-visibility</code>，它决定了我们的牌面背面是否被渲染。这里，将值设置为<code>hidden</code>，以便只渲染两面的“正面”。任意给每张脸分配颜色。</p>
<pre>.face {
  width:100%;
  height:100%;
  
  color:#FFF;
  line-height:15em;
  text-align:center;
  position:absolute;
  
  backface-visibility:hidden;
}

.front {
  background-color:#0379ff;
}

.back {
  background-color:#333;
  transform: rotateY(180deg);
}</pre>
<p class="graf graf--p">最后，在悬停时旋转卡片。</p>
<pre>.scene:hover .card {
  transform: rotateY(180deg);
}</pre>
<p class="graf graf--p">现在你已经完成了你的第一个纯CSS的3D变换效果！你可以在这里查看上面代码<a class="markup--anchor markup--p-anchor" href="https://codepen.io/alvinwan/pen/zemjbw" target="_blank" rel="noopener noreferrer" data-href="https://codepen.io/alvinwan/pen/zemjbw">的codepen演示来测试。</a></p>
<figure class="graf graf--figure"><img decoding="async" class="graf-image jetpack-lazy-image" src="../Images/ac1cfabb337ceb4c7edc1af11af535b2.png" data-image-id="0*Bs96ukmb5uS3-Kts.gif" data-width="569" data-height="326" data-lazy-src="https://cdn-images-1.medium.com/max/1600/0*Bs96ukmb5uS3-Kts.gif?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://cdn-images-1.medium.com/max/1600/0*Bs96ukmb5uS3-Kts.gif"/><noscript><img data-lazy-fallback="1" decoding="async" class="graf-image" src="../Images/ac1cfabb337ceb4c7edc1af11af535b2.png" data-image-id="0*Bs96ukmb5uS3-Kts.gif" data-width="569" data-height="326" data-original-src="https://cdn-images-1.medium.com/max/1600/0*Bs96ukmb5uS3-Kts.gif"/></noscript></figure>
<p class="graf graf--p">我们翻转卡片的例子到此结束。就其核心而言，这种效果依赖于前面讨论的转换和视角。然而，根据上面的例子，要达到预期的效果，还需要一些小技巧。以这些简单的2D面为基础，我们可以构建更复杂的几何图形，然后将它们组装起来，构建更复杂的物体。</p>
<h3 class="graf graf--h3">示例2:立方体</h3>
<p class="graf graf--p">web的3D引擎WebGL将一个对象定义为一个<em class="markup--em markup--p-em">几何体</em>和一个<em class="markup--em markup--p-em">材质</em>的组合。不严格地说，<em class="markup--em markup--p-em">几何</em>定义了形状，比如立方体、球体或圆柱体。<em class="markup--em markup--p-em">材质</em>定义外观，如反光、紫色和50%透明。在这一节中，我们将建立一个最简单的几何图形，一个立方体。然后，这个立方体可以成为CSS中未来3D创作的构建块。</p><div class="code-block code-block-54">
<hr/>
<h3>更多来自LogRocket的精彩文章:</h3>

<hr/></div>
<p class="graf graf--p">和前面一样，在<a class="markup--anchor markup--p-anchor" href="https://codepen.io/" target="_blank" rel="noopener noreferrer" data-href="http://codepen.io/"> codepen.io </a>创建一个新的Codepen。在HTML部分中，为多维数据集键入以下设置。再次像以前一样，定义一个场景，对象和面孔。</p>
<pre>    &lt;div class="scene"&gt;
      &lt;div class="cube"&gt;
        &lt;div class="face front"&gt;front&lt;/div&gt;
        &lt;div class="face right"&gt;right&lt;/div&gt;
        &lt;div class="face left"&gt;left&lt;/div&gt;
        &lt;div class="face back"&gt;back&lt;/div&gt;
        &lt;div class="face top"&gt;top&lt;/div&gt;
        &lt;div class="face bottom"&gt;bottom&lt;/div&gt;
      &lt;/div&gt;
    &lt;/div&gt;</pre>
<p class="graf graf--p">在CSS部分，给场景添加透视。</p>
<pre>.scene {
  width:10em;
  height:10em;
  perspective:10em;
}</pre>
<p class="graf graf--p">样式立方体，使所有的子元素都呈现在三维空间(<code>transform-style</code>)，并添加一个无限旋转的动画，这样我们就可以从各个角度看到我们的三维创作。</p>
<pre>.cube {
  width:100%;
  height:100%;
  position:relative;
  animation: spinning 2s infinite;
  transform-style:preserve-3d;
}

@keyframes spinning {
  from  { transform: translateZ(-5em) rotateY(0deg);   }
  to    { transform: translateZ(-5em) rotateY(360deg); }
}</pre>
<p class="graf graf--p">接下来，设置面的样式，使它们可见。</p>
<pre>.face {
  width:100%;
  height:100%;
  position:absolute;
  background-color:rgba(3, 121, 255, 0.5);
  
  color:#FFF;
  line-height:10em;
  text-align:center;
}</pre>
<p class="graf graf--p">对于这个倒数第二步，将每个面旋转到位。请注意，前、后、右和左面沿y轴旋转，顶面和底面沿x轴旋转。</p>
<pre>.front  { transform: rotateY(0deg)   }
.right  { transform: rotateY(90deg)  }
.left   { transform: rotateY(-90deg) }
.back   { transform: rotateY(180deg) }
.top    { transform: rotateX(90deg)  }
.bottom { transform: rotateX(-90deg) }</pre>
<p class="graf graf--p">请注意，所有的面都以原点为中心。然而，我们希望所有面的中心都在立方体的外围。因为立方体是10em x 10em x 10em，所以沿着Z维度平移每个面以将它们全部向外移动。</p>
<pre>.front  { transform: rotateY(0deg) translateZ(5em); }
.right  { transform: rotateY(90deg) translateZ(5em);  }
.left   { transform: rotateY(-90deg) translateZ(5em); }
.back   { transform: rotateY(180deg) translateZ(5em); }
.top    { transform: rotateX(90deg) translateZ(5em); }
.bottom { transform: rotateX(-90deg) translateZ(5em); }</pre>
<p class="graf graf--p">您的预览现在应该与下面的匹配，一个无限旋转的立方体，所有6个面都被标记。你可以看到我们的旋转立方体的<a class="markup--anchor markup--p-anchor" href="https://codepen.io/alvinwan/pen/XOxOXa" target="_blank" rel="noopener noreferrer" data-href="https://codepen.io/alvinwan/pen/XOxOXa"> Codepen演示。</a></p>
<figure class="graf graf--figure"><img decoding="async" class="graf-image jetpack-lazy-image" src="../Images/0266e52763625497bbc31649ece9f3b7.png" data-image-id="0*t-TfUVvkmCqyqljx.gif" data-width="569" data-height="259" data-lazy-src="https://cdn-images-1.medium.com/max/1600/0*t-TfUVvkmCqyqljx.gif?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://cdn-images-1.medium.com/max/1600/0*t-TfUVvkmCqyqljx.gif"/><noscript><img data-lazy-fallback="1" decoding="async" class="graf-image" src="../Images/0266e52763625497bbc31649ece9f3b7.png" data-image-id="0*t-TfUVvkmCqyqljx.gif" data-width="569" data-height="259" data-original-src="https://cdn-images-1.medium.com/max/1600/0*t-TfUVvkmCqyqljx.gif"/></noscript></figure>
<p class="graf graf--p">这个例子不需要新的机器或逻辑；事实上，我们遇到的怪癖和翻牌例子中的一样。我们的第二个例子到此结束，这是CSS中更复杂的3D创作的基本构建块。事实上，您可以通过合成多个2D面来创建任何3D几何图形，反过来，也可以在CSS中创建任意的3D模型。</p>
<h3 class="graf graf--h3">结论</h3>
<p class="graf graf--p">在本指南中，我们讲述了使用纯CSS进行3D变换的基础知识。具体来说，使用CSS从3D创作的构建块进行转换和透视。然而，最终，比CSS更强大更有效的3D引擎还是存在的；CSS的作用只是增加一个界面。有了这个指南，你可以进一步发挥CSS的作用，潜在地利用用户对现有3D界面的熟悉，比如卡片、盒子或表盘。</p><div class="code-block code-block-25">
<div class="blog-plug inline-plug css-plug"><h2>你的前端是否占用了用户的CPU？</h2><p>随着web前端变得越来越复杂，资源贪婪的特性对浏览器的要求越来越高。如果您对监控和跟踪生产环境中所有用户的客户端CPU使用、内存使用等感兴趣，</p><a target="_blank" href="https://lp.logrocket.com/blg/css-signup">try LogRocket</a><p>.</p><a class="signup" href="https://lp.logrocket.com/blg/css-signup" target="_blank" rel="noopener noreferrer"><img class="alignnone size-full wp-image-46 jetpack-lazy-image" src="../Images/dacb06c713aec161ffeaffae5bd048cd.png" alt="LogRocket Dashboard Free Trial Banner" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2019/12/cpu-memory-usage.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/12/cpu-memory-usage.png"/><noscript><img data-lazy-fallback="1" class="alignnone size-full wp-image-46" src="../Images/dacb06c713aec161ffeaffae5bd048cd.png" alt="LogRocket Dashboard Free Trial Banner" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/12/cpu-memory-usage.png"/></noscript></a><a href="https://lp.logrocket.com/blg/css-signup" target="_blank" rel="noopener noreferrer">https://logrocket.com/signup/</a><p>LogRocket 就像是网络和移动应用的DVR，记录你的网络应用或网站上发生的一切。您可以汇总和报告关键的前端性能指标，重放用户会话和应用程序状态，记录网络请求，并自动显示所有错误，而不是猜测问题发生的原因。</p><p>现代化您调试web和移动应用的方式— <a class="signup" href="https://lp.logrocket.com/blg/css-signup" target="_blank" rel="noopener noreferrer">开始免费监控</a>。</p></div>
</div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
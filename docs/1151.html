<html>
<head>
<title>An introduction to Wouter: A React Router alternative - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>Wouter简介:React路由器替代方案</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/an-introduction-to-wouter-a-react-router-alternative/#0001-01-01">https://blog.logrocket.com/an-introduction-to-wouter-a-react-router-alternative/#0001-01-01</a></blockquote><div><article class="article-post">
<p>JavaScript生态系统总是处于不断变化的状态。尽管发生了这些变化，JavaScript社区还是努力解决出现的所有问题。如果您以前使用过React，您会注意到首选路由解决方案是React路由器库。</p>
<p>它经常被错误地描述为来自脸书的官方路由解决方案。然而实际上，脸书大学的大多数项目甚至没有利用它。</p>
<p>大多数web应用程序项目和用例可以用一个小而简单的路由库做得很好。</p>
<p>一个这样的路由解决方案是Wouter。在本指南中，您将对Wouter进行概述，并了解如何用它来代替React路由器。</p>
<h2>客户端路由是如何工作的？</h2>
<p>客户端路由(CSR)类似于服务器端路由(SSR)，只是CSR是由浏览器处理的。在典型的web应用程序中，一些页面或路径映射到不同的URL。每个页面都有一些逻辑和一个模板，一旦调用了路由，就会呈现这个模板。</p>
<p>CSR完全由浏览器的JavaScript引擎处理。客户端框架预取并加载JavaScript包。这使得应用程序能够在包中存储的页面之间切换，而不会丢失状态或应用程序数据。</p>
<p>前端路由或CSR的工作方式是将URL与JavaScript文件中的登录信息进行匹配，然后使用API从服务器获取必要的数据。</p>
<p>要了解有关客户端路由的更多信息，您可以参考本指南的<a href="https://www.pluralsight.com/guides/pros-and-cons-of-client-side-routing-with-react" target="_blank" rel="noopener noreferrer"/>，其中详细解释了CSR。</p>
<h2>伤口特征</h2>
<p>下面你会发现Wouter比React路由器提供的所有特性或优势。</p>
<ul>
<li>它没有依赖性——与React路由器的17KB相比，只有1308字节的gzip。</li>
<li>除了react，Wouter还支持Preact，这是React的一个微小的替代方案，使用相同的API。</li>
<li>组件在Wouter中是完全可选的。</li>
<li>Wouter是一个基于Hook的API，所以你对路由有更多的控制权。</li>
</ul>
<h2>Wouter入门</h2>
<p>看看这个使用Wouter设置路由的基本代码。你所需要做的就是从<code>wouter</code>进口<code>Link</code>和<code>Route</code>组件，然后你就可以开始了。与<code>react-router</code>所需的所有样板文件相比，这个设置非常简单。</p>
<pre>import { Link, Route } from "wouter";

const App = () =&gt; (
  &lt;div&gt;
    &lt;Link href="/users/John"&gt;
      &lt;a className="link"&gt;My Account&lt;/a&gt;
    &lt;/Link&gt;

    &lt;Route path="/inbox" component={InboxPage} /&gt;
    &lt;Route path="/settings"&gt;Settings&lt;/Route&gt;
    &lt;Route path="/users/:name"&gt;
      {(params) =&gt; &lt;div&gt;Hello, {params.name}!&lt;/div&gt;}
    &lt;/Route&gt;
  &lt;/div&gt;
);

export default App;</pre>
<h2>外部组件</h2>
<h3><code>&lt;Route /&gt;</code></h3>
<p><code>&lt;Route /&gt;</code>组件表示基于特定模式有条件呈现的应用程序的一部分。模式是一个字符串，可以包含特殊字符来匹配动态段。</p>
<p>Wouter提供了不同的方式来声明路由。</p>
<pre>import { Route } from "wouter";

// basic usage
&lt;Route path="/home"&gt;&lt;Home /&gt;&lt;/Route&gt;

// render-prop style usage
&lt;Route path="/profile/:id"&gt;
  {params =&gt; &lt;ProfilePage id={params.id} /&gt;}
&lt;/Route&gt;

// prop based usage
&lt;Route path="/orders/:status" component={Orders} /&gt;</pre>
<h3><code>&lt;Link /&gt;</code></h3>
<p><code>&lt;Link /&gt;</code>组件呈现一个锚<code>&lt;a /&gt;</code>元素，单击该元素可以导航到在<code>href</code>属性中指定的路线。还可以通过提供一个自定义组件作为其子组件来对其进行自定义。</p>
<pre>import { Link } from "wouter";

&lt;Link href="/users/all" className="active"&gt;
  List Users
&lt;/Link&gt;;

&lt;Link href="/users/all"&gt;
  &lt;CustomLink&gt; List Users &lt;/CustomLink&gt;
&lt;/Link&gt;;</pre>
<h3><code>&lt;Switch /&gt;</code></h3>
<p>在某些情况下，您可能需要独占路由。也就是说，任何时候都只需要在页面上呈现一条路线，即使这些路线具有彼此重叠的模式。</p>
<p>您可以使用<code>&lt;Switch /&gt;</code>组件实现独占路由。它只呈现第一个匹配的路线。</p>
<pre>import { Route, Switch } from "wouter";

&lt;Switch&gt;
  &lt;Route path="/users/all" component={AllUsers} /&gt;
  &lt;Route path="/users/:userId" component={User} /&gt;
&lt;/Switch&gt;;</pre>
<h3><code>Redirect</code></h3>
<p><code>&lt;Redirect /&gt;</code>组件用于将用户重定向到<code>to</code>属性中提供的另一条路线。它在内部使用<code>useLocation</code>钩子来触发<code>useEffect</code>回调块内部的导航。</p>
<pre>import { Redirect } from "wouter";

const User = ({ userId }) =&gt; {
  if (!userId) return &lt;Redirect to="/login" /&gt;;

  return &lt;div&gt; Current User is {userId} &lt;/div&gt;;
};</pre>
<p>为了以编程方式导航用户，您可以使用<code>useLocation</code>钩子直接访问<code>setLocation</code>方法。</p>
<pre>import { useLocation } from "wouter";

const App = () =&gt; {
  const [location, setLocation] = useLocation();

  const navigate = () =&gt; {
    setLocation("/login");
  };

  return (
    &lt;div&gt;
      &lt;button onClick={() =&gt; navigate()}&gt; Logout &lt;/button&gt;
    &lt;/div&gt;
  );
};</pre>
<h2>如何激活当前链接</h2>
<p>例如，在导航菜单中，Wouter开箱即用不支持确定链接当前是否处于活动状态。然而，通过创建一个包装器组件并使用<code>useRoute</code>钩子检测当前路径是否有效，可以很容易地实现这个功能。</p><div class="code-block code-block-54">
<hr/>
<h3>更多来自LogRocket的精彩文章:</h3>

<hr/></div>
<pre>import { useRoute, Link } from "wouter";

const CustomLink = (props) =&gt; {
  const [isActive] = useRoute(props.href);

  return (
    &lt;Link {...props}&gt;
      &lt;a className={isActive ? "active" : ""}&gt;{props.children}&lt;/a&gt;
    &lt;/Link&gt;
  );
};</pre>
<h2>使用Wouter进行服务器端渲染(SSR)</h2>
<p>要在服务器端上下文中使用Wouter，您需要指示路由器当前位置需要来自HTTP请求，而不是浏览器历史。</p>
<p>您可以使用<code>staticLocationHook</code>而不是默认的<code>useLocation</code>钩子来告诉路由器处理传入的HTTP请求。</p>
<pre>import { renderToString } from "react-dom/server";
import { Router } from "wouter";

import staticLocationHook from "wouter/static-location";

import App from "./App";

const handleRequest = (req, res) =&gt; {
  const prerendered = renderToString(
    &lt;Router hook={staticLocationHook(req.path)}&gt;
      &lt;App /&gt;
    &lt;/Router&gt;
  );

  // return with prerendered html
};</pre>
<p>如果您需要检测重定向，您还可以向<code>staticLocationHook</code>提供record选项。<code>location.history</code>属性是一个匹配用户历史的数组，它将在加载页面后被捕获。</p>
<pre>import { renderToString } from "react-dom/server";
import { Router } from "wouter";
import staticLocationHook from "wouter/static-location";

import App from "./App";

const handleRequest = (req, res) =&gt; {
  const location = staticLocationHook(req.path, { record: true });
  const prerendered = renderToString(
    &lt;Router hook={location}&gt;
      &lt;App /&gt;
    &lt;/Router&gt;
  );

  const finalPage = location.history.slice(-1)[0];
  if (finalPage !== req.path) {
    // perform redirect here
  }
};</pre>
<h3>进一步最小化包的大小</h3>
<p>如果你是一个捆绑包大小的极简主义者，并希望你的应用程序的捆绑包大小尽可能小，你可以使用<code>useLocation</code>钩子来处理所有的路线。</p>
<p><code>useLocation</code> Hook是一个底层导航API，为核心Wouter组件和路由提供动力。它本质上是本机浏览器<code>location</code>对象的包装器。</p>
<pre>import { useLocation } from "wouter";

const CurrentLocation = () =&gt; {
  const [location, setLocation] = useLocation();

  return (
    &lt;div&gt;
      {`The active page is: ${location}`}
      &lt;button onClick={() =&gt; setLocation("/users")}&gt;
        Click to update the route
      &lt;/buttom&gt;
    &lt;/div&gt;
  );
};</pre>
<p>还可以从一个单独的文件访问<code>useLocation</code>挂钩，如果您只打算使用<code>useLocation</code>挂钩并手动匹配路线，这将进一步减小包的大小。</p>
<pre>import useLocation from "wouter/use-location";

const UsersRoute = () =&gt; {
  const [location] = useLocation();

  if (location !== "/users") return null;

  // render the route
};</pre>
<h3>过时的平台支持</h3>
<p>Wouter库使用最新的EcmaScript (ES) 6特性，如析构赋值和const/let变量声明，并且不附带ES5 transpiled源代码。如果你想支持像Internet Explorer 11和更低版本的传统浏览器，确保你在<code>node_modules</code>文件夹上运行Babel。</p>
<h2>与React路由器相比的优缺点</h2>
<p>下面列出了Wouter与React路由器库相比的一些优点和缺点。</p>
<h3>优点:</h3>
<ul>
<li>Wouter很小，不依赖于其他库</li>
<li>Wouter对于附带项目、黑客马拉松项目和大约有十条路线的小应用程序来说非常优秀</li>
<li>Wouter对于那些想通过阅读源代码来了解更多关于React Hooks的开发人员来说是一个很好的启发</li>
</ul>
<h3>缺点:</h3>
<ul>
<li>Wouter只实现了一组有限的功能(重定向、开关、对基于散列的历史的支持、扩展模式语法(如<code>/app/:foo(\d+)</code>)尚未开发)</li>
<li>对于复杂的企业级应用程序来说，这不是一个好的选择</li>
<li>Wouter后面的社区与React路由器相比要小得多</li>
</ul>
<h2>结论</h2>
<p>Wouter无疑不是React路由器的替代品，也不建议在您的项目中切换到Wouter。从React路由器到Wouter的迁移在大多数用例中是不可行的，因为Wouter只是模仿React路由器API的特性，并没有完全实现这些特性。</p>
<p>但Wouter背后的主要思想是，大多数开发者倾向于选择React路由器，然后只使用30%的功能或特性。对于只需要简单路由的基本项目，React路由器可能是多余的。</p>
<p>Wouter也可以作为一个参考，说明如何使用React Hooks来创建可以开源的优秀库。</p>
<p>这就是本指南的全部内容。直到下一次，继续探索更多的路由解决方案和库。</p>
<h3>参考</h3>

<p><a href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener"> LogRocket </a>:全面了解您的生产React应用</p><div class="code-block code-block-17">
<div class="blog-plug inline-plug react-plug" vwo-el-id="26283398190">
<h2 vwo-el-id="41600691720">调试React应用程序可能很困难，尤其是当用户遇到难以重现的问题时。如果您对监视和跟踪Redux状态、自动显示JavaScript错误以及跟踪缓慢的网络请求和组件加载时间感兴趣，</h2><p>. </p><a href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" vwo-el-id="19356441070">try LogRocket</a><p>LogRocket 结合了会话回放、产品分析和错误跟踪，使软件团队能够创建理想的web和移动产品体验。这对你来说意味着什么？</p><a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="19356441380">
<img class="first-react-image alignnone size-full wp-image-46 jetpack-lazy-image jetpack-lazy-image--handled" src="../Images/f300c244a1a1cf916df8b4cb02bec6c6.png" vwo-el-id="18272717540" data-lazy-loaded="1" data-original-src="https://files.readme.io/27c94e7-Image_2017-06-05_at_9.46.04_PM.png"/>
</a>
<a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="19356441690">
<img class="second-react-image alignnone size-full wp-image-46 jetpack-lazy-image jetpack-lazy-image--handled" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" vwo-el-id="30720362350" data-lazy-loaded="1" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/>
</a>
<p vwo-el-id="28675660440" class="">LogRocket不是猜测错误发生的原因，也不是要求用户提供截图和日志转储，而是让您回放问题，就像它们发生在您自己的浏览器中一样，以快速了解哪里出错了。</p>
<p>不再有嘈杂的警报。智能错误跟踪允许您对问题进行分类，然后从中学习。获得有影响的用户问题的通知，而不是误报。警报越少，有用的信号越多。</p>
<p>LogRocket Redux中间件包为您的用户会话增加了一层额外的可见性。LogRocket记录Redux存储中的所有操作和状态。</p>
<p vwo-el-id="28675660750">现代化您调试React应用的方式— <a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="40093418840">开始免费监控</a>。</p>
<p vwo-el-id="28675661060">Modernize how you debug your React apps —
<a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="40093418840">start monitoring for free</a>.
</p>
</div></div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
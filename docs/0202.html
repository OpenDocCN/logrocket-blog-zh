<html>
<head>
<title>Styling in React: 5 ways to style React apps - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>React中的风格:5种风格React应用程序的方法</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/styling-react-5-ways-style-react-apps/#0001-01-01">https://blog.logrocket.com/styling-react-5-ways-style-react-apps/#0001-01-01</a></blockquote><div><article class="article-post">
<p><em> <strong>编者按:</strong>React帖子中的这一样式最近一次更新是在2022年12月8日，包括了关于使用Sass和CSS样式表进行样式化的部分，每种样式化方法的优缺点，以及关于在React中进行样式化的最佳方式的讨论。</em></p>
<p>那么，你是来学习如何在<a href="https://blog.logrocket.com/tag/react/"> React </a>中进行造型的？嗯，你来对地方了。当你读完这篇文章时，我保证你会知道该怎么做。在本文中，我们将回顾使用内联样式、样式化组件、CSS模块、顺风CSS以及Sass和CSS样式表对React组件进行样式化。</p>
<p>我们将使用待办事项应用程序的一个组件来解释这些方法。同时也要考虑本文中讨论的样式选项的优缺点。</p>
<p>如果你是新反应过来的，可以查一下<a href="https://reactjs.org">官方文档</a>。</p>
<p><span class="embed-youtube"> <iframe loading="lazy" class="youtube-player" src="https://www.youtube.com/embed/d-7hWYBguSs?version=3&amp;rel=1&amp;showsearch=0&amp;showinfo=1&amp;iv_load_policy=1&amp;fs=1&amp;hl=en-US&amp;autohide=2&amp;wmode=transparent" allowfullscreen="true" sandbox="allow-scripts allow-same-origin allow-popups allow-presentation">视频</iframe> </span></p>
<p><em>向前跳转:</em></p>

<h2 id="setting-react-application">设置React应用程序</h2>
<p>要设置一个应用程序，可以使用<a href="https://blog.logrocket.com/getting-started-with-create-react-app-d93147444a27/"> Create React App </a>。这是开始React项目最简单的方法。然而，<a href="https://blog.logrocket.com/tag/create-react-app/"> CRA演示</a>超出了本文的范围，所以我们将跳过它，设计一个假想的待办事项应用程序。</p>
<p>这是React应用程序的演示:</p>

<p>让我们从第一种方法开始吧！</p>
<h2 id="styling-react-components-inline-styling">样式用内嵌样式反应组件</h2>
<p>如果你熟悉基本的HTML，你会知道添加你的<a href="https://blog.logrocket.com/improve-site-performance-inlining-css/"> CSS内嵌</a>是可能的。这类似于React。</p>
<p>我们可以向任何想要呈现的React组件添加内联样式。这些样式作为属性编写，并传递给元素。让我们使用内联样式来设计组件的各个部分:</p>
<pre class="language-javascript hljs">/** src/todo/AddTodo.js **/

//...code omitted for brevity
const AddTodo = () =&gt; {
 //...
  return (
    &lt;div style={{ display: "flex", flexDirection: "column" }}&gt;
      &lt;h2 style={{ padding: "10px 20px", textAlign: "center", color: "white" }}&gt;
        TODO
      &lt;/h2&gt;
      &lt;div
        style={{
          display: "flex",
          justifyContent: "center",
          alignItems: "center"
        }}
      &gt;
        &lt;label
          style={{ padding: "10px 20px", textAlign: "center" }}
          htmlFor="new-todo"
        &gt;
          What needs to be done?
        &lt;/label&gt;
      &lt;/div&gt;
      &lt;div
        style={{
          display: "flex",
          justifyContent: "center",
          alignItems: "center"
        }}
      &gt;
        &lt;form onSubmit={handleSubmit}&gt;
          &lt;input onChange={onChange} value={task} ref={inputRef} /&gt;
          &lt;button&gt;Add &lt;/button&gt;
        &lt;/form&gt;
      &lt;/div&gt;
      {message &amp;&amp; (
        &lt;div
          style={{
            display: "flex",
            justifyContent: "center",
            alignItems: "center"
          }}
        &gt;
          &lt;h4 style={{ color: "red" }}&gt;{message}&lt;/h4&gt;
        &lt;/div&gt;
      )}
    &lt;/div&gt;
  );
};
export default AddTodo;
</pre>
<p>在上面的代码中，我们向<code>AddTodo()</code>中的HTML元素添加了内联样式。这里有一些你应该注意的事情。</p>
<p>首先，有两个大括号。我们正在渲染的是用JSX写的，对于要在JSX使用的纯JavaScript表达式，它们必须包含在花括号中。</p>
<p>第一个花括号将JavaScript注入JSX。内部的花括号创建一个对象</p>
<p>字面意思。样式作为对象文字传递给元素。</p>
<blockquote><p>💡JSX是将XML语法添加到JavaScript的预处理步骤。没有JSX，你当然可以使用React，但是JSX让React更加优雅。就像XML一样，JSX标签有标签名、属性和子标签。</p></blockquote>
<p>下一件要注意的事情是属性由逗号分隔。这是因为我们传递的是一个对象。因为它是一个JavaScript属性，所以属性是用camelCase编写的，并且没有用破折号分隔。</p>
<p>在上面的代码中，我们只是给我们设计的元素添加了一些属性。然而，想象一下我们必须向元素添加越来越多的样式。这就是内联方法失败的地方，因为它看起来不干净。</p>
<p>不过，有一种方法可以解决这个问题。我们可以创建对象变量并将它们传递给元素。</p>
<h3 id="creating-style-object-variable">创建样式对象变量</h3>
<p>我们创建样式对象变量的方式与创建JavaScript对象的方式相同。然后，这个对象被传递给我们想要设置样式的元素的style属性。</p>
<p>因此，我们没有像上一个例子那样直接内联添加样式，而是传递<code>object</code>变量，如下所示:</p>
<pre class="language-javascript hljs">/** src/todo/AddTodo.js **/
const AddTodo = () =&gt; {
//...
  return (
    &lt;div style={Container}&gt;
      &lt;h2 style={Header}&gt;TODO&lt;/h2&gt;
      &lt;div style={LabelContainer}&gt;
        &lt;label style={Label} htmlFor="new-todo"&gt;
          What needs to be done?
        &lt;/label&gt;
      &lt;/div&gt;
      &lt;div style={FormContainer}&gt;
        &lt;form onSubmit={handleSubmit}&gt;
          &lt;input onChange={onChange} value={task} ref={inputRef} /&gt;
          &lt;button&gt;Add &lt;/button&gt;
        &lt;/form&gt;
      &lt;/div&gt;
      {message &amp;&amp; (
        &lt;div style={Message}&gt;
          &lt;h4 style={{ color: "red" }}&gt;{message}&lt;/h4&gt;
        &lt;/div&gt;
      )}
    &lt;/div&gt;
  );
};

const Container = { display: "flex", flexDirection: "column" };
const Header = { padding: "10px 20px", textAlign: "center", color: "white" };
const LabelContainer = { display: "flex", justifyContent: "center", alignItems: "center"};
const Label = { padding: "10px 20px", textAlign: "center" };
const FormContainer = { display: "flex", justifyContent: "center", alignItems: "center"};
const ErrorMessage = { display: "flex", justifyContent: "center", alignItems: "center"};
</pre>
<p>在上面的代码中，我们创建了六个对象变量:<code>Container</code>、<code>Header</code>、<code>LabelContainer</code>、<code>Label</code>、<code>FormContainer, </code>和<code>ErrorMessage</code>。</p>
<p>然后，我们将这些变量传递给元素，而不是直接键入它们。</p>
<blockquote><p>💡我们不必在元素中使用双花括号，因为这些变量本身就是对象。</p></blockquote>
<p>如果您查看对象属性，<code>camelCases</code>将在编译期间被转换为破折号分隔的CSS属性。例如，这个:</p>
<pre class="language-css hljs">backgroundColor: "#44014C",
minHeight: "200px",
boxSizing: "border-box"
In plain CSS, these will be written as:
background-color: #44014C;
min-height: 200px;
box-sizing: border-box;
</pre>
<blockquote><p>⚠️The <code>camelCase</code>对破折号分隔的字符串的更改只适用于属性名，而不适用于属性值。</p></blockquote>
<p>可以将变量作为值传递给属性。所以，我们可以这样做:</p>
<pre class="language-javascript hljs">/* in .js file */
const spacing = "10px 20px";
const Header = {
  margin: spacing,
  padding: spacing
  // ...
}
</pre>
<p>在许多<a href="https://logrocket.com/for/debug-javascript-app/"> JavaScript环境</a>中，创建一个全局对象变量可能是不好的做法，但是在React中却很好。因为除非导入，否则文件对其他文件是不可见的，所以我们可以创建尽可能多的对象变量，即使使用相同的名称也不会有冲突。</p>
<h3 id="sharing-styles-react-components">跨许多React组件共享样式</h3>
<p>样式对象和组件不必在同一个文件中。我们可以为我们的样式创建一个单独的<code>.js</code>文件，导出这些样式，然后将它们导入到我们想要使用它们的组件中。这样做使得样式可以跨多个组件重用。让我们为我们的组件这样做。</p>
<p>首先，我们将创建一个名为<code>styles.js</code>的单独的<code>.js</code>文件。然后，我们将添加这些样式:</p>
<pre class="language-javascript hljs">const Container = { display: "flex", flexDirection: "column" };
const Header = { padding: "10px 20px", textAlign: "center", color: "white" };
const LabelContainer = {
  display: "flex",
  justifyContent: "center",
  alignItems: "center"
};
const Label = { padding: "10px 20px", textAlign: "center" };
const FormContainer = {
  display: "flex",
  justifyContent: "center",
  alignItems: "center"
};
const ErrorMessage = {
  display: "flex",
  justifyContent: "center",
  alignItems: "center"
};

export const styles = {
  Container: Container,
  Header: Header,
  LabelContainer: LabelContainer,
  Label: Label,
  ErrorMessage: ErrorMessage,
  FormContainer: FormContainer
}

export const styles = {
  Container: Container,
  Header: Header,
  LabelContainer: LabelContainer,
  Label: Label,
  ErrorMessage: ErrorMessage,
  FormContainer: FormContainer
}
</pre>
<p>在上面的代码中，我们可以分别导出每个样式对象，这也意味着分别导入它们。如果文件中有许多样式对象，这可能会变得很乏味。</p>
<p>因此，创建包含所有样式的对象才有意义。该对象被导出和导入到将要使用它的组件中一次。所以，让我们这样做:</p>
<pre class="language-javascript hljs">/** AddTodo.js file **/

// Import the styles
import {styles} from "./styles";


const AddTodo = () =&gt; {
//....
  return (
    &lt;div style={styles.Container}&gt;
      &lt;h2 style={styles.Header}&gt;TODO&lt;/h2&gt;
      &lt;div style={styles.LabelContainer}&gt;
        &lt;label style={styles.Label} htmlFor="new-todo"&gt;
          What needs to be done?
        &lt;/label&gt;
      &lt;/div&gt;
      &lt;div style={styles.FormContainer}&gt;
        &lt;form onSubmit={handleSubmit}&gt;
          &lt;input onChange={onChange} value={task} ref={inputRef} /&gt;
          &lt;button&gt;Add &lt;/button&gt;
        &lt;/form&gt;
      &lt;/div&gt;
      {message &amp;&amp; (
        &lt;div style={styles.ErrorMessage}&gt;
          &lt;h4 style={{ color: "red" }}&gt;{message}&lt;/h4&gt;
        &lt;/div&gt;
      )}
    &lt;/div&gt;
  );
};
</pre>
<p>在<code>AddTodo()</code>之上，我们将导入<code>styles</code>对象。然后，这个对象被用来设计React应用程序的组件，就像任何JavaScript对象一样使用。</p>
<h3 id="pros-cons-one">利弊</h3>
<p>从这一点可以看出，样式可以在多个组件中使用和重用。只需要将样式导入并添加到样式属性中。</p>
<p>当然，<a href="https://blog.logrocket.com/why-you-shouldnt-use-inline-styling-in-production-react-apps/">有些情况下你不应该使用内联样式</a>，这就是我们接下来两个方法的用武之地。</p>
<h3>优点:</h3>
<p>使用内联样式可以帮助你快速原型化你的界面。</p>
<h3>缺点:</h3>
<p>使用内联样式，声明会很快变得杂乱无章。此外，直列式设计并不提倡干燥(不要重复自己)的原则。使用内联样式不适合包含大量代码的大型项目。</p>
<h2 id="using-styled-components">使用样式组件</h2>
<p>使用样式化组件，我们可以在JavaScript文件中编写实际的CSS。这意味着你可以在JavaScript中使用CSS的所有特性——比如<a href="https://blog.logrocket.com/choose-between-media-container-queries/">媒体查询</a>、<a href="https://blog.logrocket.com/css-modal-pseudo-selector/">伪选择器</a>、<a href="https://blog.logrocket.com/native-css-nesting/">嵌套</a>等等。</p>
<p><a href="https://github.com/styled-components/styled-components">样式化组件</a>使用ES6的标记模板文字来样式化组件。有了它，组件和样式之间的映射被删除。这意味着当您定义您的样式时，您实际上是在创建一个普通的React组件，它将您的样式附加到它上面。</p>
<p>使用样式化组件，我们可以创建带有样式的可重用组件。创造和使用它是相当令人兴奋的。</p>
<p>首先，我们需要在React应用程序的目录下运行<code>$ npm install --save styled-components</code>来安装它。</p>
<p>让我们回到我们的待办事项应用程序，<a href="https://blog.logrocket.com/using-styled-components-in-react/">让我们的组件使用样式化组件</a>。首先，用<code>import styled from 'styled-components';</code>导入<code>AddTodo.js</code>文件中的<code>styled-components</code>包。</p>
<p>现在，我们可以马上开始使用它。我们将首先创建一个样式化组件，然后看看我们将如何使用它:</p>
<pre class="language-javascript hljs">/** AddTodo.js file **/
const Container = styled.div`
  display: flex;
  flex-direction: column;
`;
const Header = styled.div`
  padding: 10px 20px;
  text-align: center;
  color: white;
`;
//....
</pre>
<p>在上面的代码中，我们创建了一个可以像任何React组件一样使用的组件。但是，请注意，我们在JavaScript文件中使用的是纯CSS。接下来，让我们把这个组件:</p>
<pre class="language-javascript hljs">/** AddTodo.js file **/

function AddTodo() {
 //...


return (
    &lt;Container&gt;
      &lt;Header&gt;TODO&lt;/Header&gt;
      &lt;LabelContainer&gt;
        &lt;Label htmlFor="new-todo"&gt;What needs to be done?&lt;/Label&gt;
      &lt;/LabelContainer&gt;
      &lt;FormContainer&gt;
        &lt;form onSubmit={handleSubmit}&gt;
          &lt;input onChange={onChange} value={task} ref={inputRef} /&gt;
          &lt;button&gt;Add &lt;/button&gt;
        &lt;/form&gt;
      &lt;/FormContainer&gt;
      {message &amp;&amp; (
        &lt;ErrorContainer&gt;
          &lt;ErrorMessage&gt;{message}&lt;/ErrorMessage&gt;
        &lt;/ErrorContainer&gt;
      )}
    &lt;/Container&gt;
  );
}
</pre>
<p>在上面的代码中，我们使用了自己创建的样式化组件，并用定义的组件样式标签替换了HTML标签。styled-component用作任何其他HTML元素。唯一的区别是它有自己的预定义样式。</p>
<p>您可以在CodeSandbox playground中访问代码:</p>
<p>利弊</p>
<h3 id="pros-cons-two">要找到更多关于样式组件以及如何使用它们的信息，你可以在这里阅读。</h3>
<p>优点:</p>
<h3>styled——组件以您认为合适的方式动态地设计您的元素的样式。他们鼓励用优秀的模式来组织代码的DRY原则，并且风格化组件与广泛的框架和库兼容。它们也非常适合开发和维护设计系统。</h3>
<p>缺点:</p>
<h3>将声明转换成普通CSS时，样式化组件会带来大量的计算开销。这可能会影响应用程序的性能。样式化组件也需要时间来熟悉语法和过程。</h3>
<p>接下来，让我们讨论React中样式的第三种方式。</p>
<p>样式化React组件的CSS模块</p>
<h2 id="css-modules-style-react-components">一个<a href="https://blog.logrocket.com/a-deep-dive-into-css-modules/"> CSS模块</a>是一个CSS文件，默认情况下所有的类名和动画名都在本地范围内。记下局部作用域的单词。让我们稍微分解一下。</h2>
<p>默认情况下，CSS类名和动画名的作用域是全局的。这可能会导致冲突，尤其是在大型样式表中，因为一种样式可能会覆盖另一种样式。CSS模块解决了这个问题。CSS类只在使用它们的组件中可用。</p>
<p>CSS模块基本上是一个被编译的<code>.css</code>文件。编译时，它产生两个输出。一个是CSS，它是输入CSS的修改版本，具有重命名的类名。另一个是JavaScript对象，它将原来的CSS名称映射到重命名的名称。</p>
<p>好了，让我们在一个模块中为一个示例错误消息创建一个CSS类。我们模块的名字是<code>styles.module.css</code>:</p>
<p>编译时，将会产生如下内容:</p>
<pre class="language-css hljs">.error-message {
  color: red;
  font-size: 16px;
}
</pre>
<p>添加的<code>jhys</code>只是一个样本键(我自己添加的)，用来唯一标识这个类。如前所述，它生成一个JavaScript对象，可以导入React文件并使用:</p>
<pre class="language-css hljs">.error-message_jhys {
  color: red;
  font-size: 16px;
}
</pre>
<p>现在，让我们看看如何使用:</p>
<pre class="language-javascript hljs">{
  error-message: error-message_jhys
}
</pre>
<p>利弊</p>
<pre class="language-javascript hljs">/** .js file **/
import styles from './styles.css';


function Message() {
 return (
   &lt;div className={styles.ErrorMessage}&gt;I am an error message&lt;/div&gt;
 );
}
</pre>
<h3 id="pros-cons-three">请记住，CSS模块的主要目的是使CSS类具有本地作用域，并避免命名冲突。这里有一些使用CSS模块的优点和缺点。</h3>
<p>优点:</p>
<h3>CSS模块可以很容易地与CSS或SCSS风格引擎集成。它们生成唯一的类名，没有冲突，并且在React库中有<a href="https://create-react-app.dev/docs/adding-a-css-modules-stylesheet/">内置支持</a>。CSS模块还修复了CSS声明的全局范围问题。</h3>
<p>缺点:</p>
<h3>用CSS模块引用类名在大多数时候会令人困惑。</h3>
<p>使用顺风CSS的样式</p>
<h2 id="styling-tailwind-css">Tailwind CSS 提供了一种不同的方法，在这种方法中，不需要编写CSS来设计应用程序。相反，Tailwind CSS为每个CSS属性使用实用程序类，您可以在HTML或JSX中直接使用它们。</h2>
<p>也许您想知道是否每个CSS属性都映射到一个类；最终CSS的包大小是多少？事实上，包的大小非常小，大多数项目交付的包的大小都小于10kB。但是怎么做呢？Tailwind CSS处理您在构建时使用的类，并构建一个适合您的项目的CSS包。</p>
<p>Tailwind CSS提供的<a href="https://blog.logrocket.com/10-best-tailwind-css-component-template-collections/">比映射到属性的CSS类</a>多得多；这也是一个支持响应行为、网格、状态、黑暗模式、<a href="https://blog.logrocket.com/guide-adding-gradients-tailwind-css/">和更多</a>的完整框架。此外，它是高度可配置的。</p>
<p>要在CRA项目上设置Tailwind CSS，需要几个步骤(和库)。这是因为它需要修改应用程序的构建过程来生成CSS包。</p>
<p>首先，从安装Tailwind CSS并生成<code>tailwind.config.js</code>和<code>postcss.config.js</code>开始。</p>
<p>然后，运行<code>$ npm install -D tailwindcss postcss autoprefixer</code>和<code>$ npx tailwindcss init -p</code>命令。</p>
<p>注意，所有与Tailwind CSS相关的库都是作为<code>dev</code>包安装的，这意味着它们不会影响JavaScript包的大小。</p>
<p>在上面生成的<code>tailwind.config.js</code>中，将以下值添加到<code>content</code>数组中:</p>
<p>现在，我们需要设置我们的CSS基线。因为Tailwind CSS使用多个具有相对值的类，所以跨所有浏览器设置相同的CSS样式库非常重要。Tailwind CSS提供了一些默认样式来实现这一点。</p>
<pre class="language-javascript hljs">/** @type {import('tailwindcss').Config} */
module.exports = {
  content: ["./src/**/*.{js,jsx,ts,tsx}",],
  theme: {
    extend: {},
  },
  plugins: [],
}
</pre>
<p>为此，导航到您的<code>src/index.css</code>文件并粘贴代码:</p>
<p>💡请注意，导入这些类将使所有默认元素的行为与您预期的不同，因此标题和段落等元素将具有相同的样式属性，直到您向它们添加Tailwind CSS类。</p>
<pre class="language-css hljs">/* ./src/styles.css */
@tailwind base;
@tailwind components;
@tailwind utilities;
</pre>
<blockquote><p>Tailwind CSS在其设置期间提供了许多配置选项，因此如果您想了解更多，请查看官方文档。</p></blockquote>
<p>最后，在项目中使用Tailwind CSS类。设置就绪后，现在可以直接在项目中使用CSS类了。继续使用Tailwind CSS构建一个<code>ToDo</code>组件:</p>
<p>请注意，这些类是作为文本直接注入到<code>className</code>属性中的，并且有一个完整的引用，引用了所有可以使用的带有状态和响应属性的类名。</p>
<pre class="language-javascript hljs">/** AddTodo.js file **/

function AddTodo() {
 //...

  return (
    &lt;div className="flex flex-col"&gt;
      &lt;h2 className="px-2.5 py-5 text-center text-white"&gt;TODO&lt;/h2&gt;
      &lt;div className="flex justify-center items-center"&gt;
        &lt;label className="px-2.5 py-5 text-center" htmlFor="new-todo"&gt;
          What needs to be done?
        &lt;/label&gt;
      &lt;/div&gt;
      &lt;div className="flex justify-center items-center"&gt;
        &lt;form onSubmit={handleSubmit}&gt;
          &lt;input onChange={onChange} value={task} ref={inputRef} /&gt;
          &lt;button&gt;Add &lt;/button&gt;
        &lt;/form&gt;
      &lt;/div&gt;
      {message &amp;&amp; (
        &lt;div className="flex justify-center items-center"&gt;
          &lt;h4 className="text-red-800"&gt;{message}&lt;/h4&gt;
        &lt;/div&gt;
      )}
    &lt;/div&gt;
  );
}
</pre>
<p>利弊</p>
<h3 id="pros-cons-four">虽然一开始可能看起来违反直觉，但是一旦你使用Tailwind CSS几天，你很可能会爱上它。让我们来看看Tailwind CSS的一些优缺点。</h3>
<p>优点:</p>
<h3>Tailwind CSS很容易用于定制元素和构建简洁的用户界面。Tailwind CSS大大减少了编写定制CSS代码的工作量，这使您可以更快地开发UI屏幕。</h3>
<p>缺点:</p>
<h3>Tailwind CSS经常要求你从头开始实现它，因为像按钮、导航条和标签这样的基本组件都没有提供。此外，学习Tailwind CSS需要一个最小的学习曲线。</h3>
<p>React中的Sass和CSS样式表</p>
<h2 id="sass-css-stylesheets-react">Sass ( <a href="https://blog.logrocket.com/a-beginners-guide-to-programming-for-css-with-sass/">语法上令人敬畏的样式表</a>)是一个CSS预处理器，具有许多功能，用于<a href="https://blog.logrocket.com/how-to-write-reusable-css-with-sass/">创建可重用的样式</a>，嵌套功能，以及组织CSS声明。使用Sass或CSS样式表是基于在外部文件中编写样式并将其导入到需要它的组件中。</h2>
<p>总的来说，Sass是关于编写具有额外好处的标准CSS的。同样，你可以使用<a href="https://blog.logrocket.com/the-definitive-guide-to-scss/"> Sass或者SCSS </a>语法来编写你的风格。</p>
<p>本指南使用SCSS语法来演示其在待办事项应用程序中的用法。</p>
<p>首先，使用<code>npm install node-sass</code>命令将<code>node-sass</code> dev依赖项添加到项目中。另外，将你的<code>.css</code>文件更新为<code>.scss</code>文件扩展名。</p>
<p>在下面的代码中，你会看到CSS和SCSS语法的混合。SCSS引擎允许编写普通的CSS，同时还利用了它的附加功能:</p>
<p>接下来，将样式声明导入到组件中。因此，在<code>AddTodo</code>文件中，导入<code>todo.scss</code>文件的内容，然后您可以访问您的样式，如下所示:</p>
<pre class="language-css hljs">/** todo.scss file **/

// declare global variables
$paddingVertical: 10px;
$paddingHorizontal: 20px;
$text-center: center;
$text-white: #ffffff;
$text-black: #000000;
$text-red: rgb(185 28 28);
$font-size: 16px;
.error {
  color: $text-red;
}
.container{
  display:flex;
  flex-direction: column;
}
.flex-center {
display: flex;
justify-content: center;
align-items: center;
}
%typo-large {
  padding: $paddingVertical $paddingHorizontal;
  text-align: $text-center;
}
.h2 {
 @extend %typo-large;
 color: $text-white;
}

.label {
 @extend %typo-large;
}
</pre>
<p>以下是上述示例的CodeSandbox游戏场:</p>
<pre class="language-javascript hljs">/** AddTodo.js file**/

//...imports omitted for brevity

// Import the styles
import "./todo.scss";


function AddTodo() {
 //...code omitted for brevity
return (
    &lt;div className="container"&gt;
      &lt;h2 className="h2"&gt;TODO&lt;/h2&gt;
      &lt;div className="flex-center"&gt;
        &lt;label className="label" htmlFor="new-todo"&gt;
          What needs to be done?
        &lt;/label&gt;
      &lt;/div&gt;
      &lt;div className="flex-center"&gt;
        &lt;form onSubmit={handleSubmit}&gt;
          &lt;input onChange={onChange} value={task} ref={inputRef} /&gt;
          &lt;button&gt;Add &lt;/button&gt;
        &lt;/form&gt;
      &lt;/div&gt;
      {message &amp;&amp; (
        &lt;div className="flex-center"&gt;
          &lt;h4 className="error"&gt;{message}&lt;/h4&gt;
        &lt;/div&gt;
      )}
    &lt;/div&gt;
  );
}
</pre>
<p>利弊</p>
<p>让我们考虑一下Sass和CSS样式表的优缺点。</p>
<h3 id="pros-cons-five">优点:</h3>
<p>Sass和CSS样式表具有广泛的动态设计用户界面的特性，并且拥有大量的用户和支持。Sass和CSS样式表允许您轻松地与标准CSS代码集成。</p>
<h3>缺点:</h3>
<p>不幸的是，学习Sass和CSS样式表有一个陡峭的学习曲线，Sass和CSS样式表需要在构造和组织您的SCSS代码方面付出一些努力。</p>
<h3>React中风格的最佳方式是什么？</h3>
<p>虽然许多库和CSS引擎都提供了在React应用程序中进行样式化的方法，但需要注意的是，这并不是一种适合所有人的最佳React样式化解决方案。</p>
<h2 id="best-way-style-react">有鉴于此，在寻找设计React应用程序的最佳方式时，几个因素在不同的软件团队中有所不同。以下是一些注意事项:</h2>
<p>性能指标是什么？</p>
<p>优化你的代码有多容易？</p>
<ul>
<li>需要设计系统吗？</li>
<li>CSS系统需要额外的努力来定制你的UI吗？</li>
<li>在总结React风格的最佳方式之前，您需要回答这些问题。最终，团队在选择最适合产品需求的CSS解决方案时扮演了重要角色，同时考虑了团队的专业技能和领域知识。</li>
<li>现在，显而易见的是，对于选择最好的库、框架或系统来设计用React构建的网站没有直接的答案。然而，本文概述了在React中进行样式化的五种优秀方法。</li>
</ul>
<p>走下去，去探索适合你或者你的团队的；您可能会满足于本文中讨论的任何CSS解决方案。</p>
<p>结论</p>
<p>所以，我们有了它React中的五种样式。一般来说，所有的方法都是有用的，这取决于项目的大小；你可以用任何一个。</p>
<h2>如果您有任何问题或反馈，请在下面留下评论。</h2>
<p><a href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener"> LogRocket </a>:全面了解您的生产React应用</p>
<p>调试React应用程序可能很困难，尤其是当用户遇到难以重现的问题时。如果您对监视和跟踪Redux状态、自动显示JavaScript错误以及跟踪缓慢的网络请求和组件加载时间感兴趣，</p><div class="code-block code-block-17">
<div class="blog-plug inline-plug react-plug" vwo-el-id="26283398190">
<h2 vwo-el-id="41600691720">. </h2><p>LogRocket 结合了会话回放、产品分析和错误跟踪，使软件团队能够创建理想的web和移动产品体验。这对你来说意味着什么？</p><a href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" vwo-el-id="19356441070">try LogRocket</a><p>LogRocket不是猜测错误发生的原因，也不是要求用户提供截图和日志转储，而是让您回放问题，就像它们发生在您自己的浏览器中一样，以快速了解哪里出错了。</p><a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="19356441380">
<img class="first-react-image alignnone size-full wp-image-46 jetpack-lazy-image jetpack-lazy-image--handled" src="../Images/f300c244a1a1cf916df8b4cb02bec6c6.png" vwo-el-id="18272717540" data-lazy-loaded="1" data-original-src="https://files.readme.io/27c94e7-Image_2017-06-05_at_9.46.04_PM.png"/>
</a>
<a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="19356441690">
<img class="second-react-image alignnone size-full wp-image-46 jetpack-lazy-image jetpack-lazy-image--handled" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" vwo-el-id="30720362350" data-lazy-loaded="1" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/>
</a>
<p vwo-el-id="28675660440" class="">不再有嘈杂的警报。智能错误跟踪允许您对问题进行分类，然后从中学习。获得有影响的用户问题的通知，而不是误报。警报越少，有用的信号越多。</p>
<p>LogRocket Redux中间件包为您的用户会话增加了一层额外的可见性。LogRocket记录Redux存储中的所有操作和状态。</p>
<p>现代化您调试React应用的方式— <a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="40093418840">开始免费监控</a>。</p>
<p vwo-el-id="28675660750">The LogRocket Redux middleware package adds an extra layer of visibility into your user sessions. LogRocket logs all actions and state from your Redux stores.
</p>
<p vwo-el-id="28675661060">Modernize how you debug your React apps —
<a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="40093418840">start monitoring for free</a>.
</p>
</div></div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
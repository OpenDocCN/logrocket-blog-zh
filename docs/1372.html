<html>
<head>
<title>Using styled-components in React - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>在React - LogRocket博客中使用样式组件</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/using-styled-components-in-react/#0001-01-01">https://blog.logrocket.com/using-styled-components-in-react/#0001-01-01</a></blockquote><div><article class="article-post">
<p>随着现代基于组件的前端框架的出现，编写特定组件范围的CSS的需求增加了。与前端领域的大多数问题一样，各种各样的解决方案已经涌现出来。</p>
<p>最常见的解决方案是<a href="https://blog.logrocket.com/tag/css-in-js/" target="_blank" rel="noopener noreferrer"> CSS-in-JS </a>，这种模式涉及用JavaScript编写组件和应用程序样式(CSS)。现在有很多CSS-in-JS库，但是可能最流行和持久的一个——也是这篇文章的重点——是样式化组件。</p>
<p>Styled-components是一个CSS-in-JS库，它极大地改善了现代前端开发人员的开发体验，同时提供了近乎完美的用户体验。除了让开发人员能够编写组件范围的CSS之外，styled-components还有许多其他好处，包括:</p>
<ul>
<li>自动供应商前缀</li>
<li>每个样式组件的唯一类名</li>
<li>更容易维护样式——开发人员可以删除或修改样式，而不会影响其他组件</li>
</ul>
<p>现在我们已经正确地介绍了样式组件库，让我们来看看一个基本的用例，它涉及到使用样式API。</p>
<h2>API:一切开始的地方</h2>
<p><code>styled</code> API允许我们创建一个<code>StyledComponent</code>——一个有风格的组件，顾名思义——通过使用一个常规的HTML元素或另一个<code>StyledComponent</code>作为基础。</p>
<p>我们来看看第一种方法。如果我们想将一个样式化的<code>div</code>元素和一个样式化的<code>&lt;h1&gt;</code>元素制作成React组件，我们可以简单地编写:</p>
<pre>import React from "react";
import styled from "styled-components";
const StyledDiv = styled.div`
  padding: 1.5rem;
  background-color: skyblue;
`
const StyledH1 = styled.h1`
  color: blue;
`
</pre>
<p>这样，我们就有了两个React组件，现在可以用作常规组件:</p>
<pre>function App() {
  return (
      &lt;StyledDiv&gt;
        &lt;StyledH1&gt;A styled H1 element&lt;/StyledH1&gt;
      &lt;/StyledDiv&gt;
  );
</pre>
<p>浏览器中的结果应该如下所示:</p>
<p><img data-attachment-id="30163" data-permalink="https://blog.logrocket.com/using-styled-components-in-react/styled-h1-element-example/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/12/styled-h1-element-example.jpeg" data-orig-size="497,197" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Styled H1 element" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/12/styled-h1-element-example-300x119.jpeg" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/12/styled-h1-element-example.jpeg" decoding="async" class="aligncenter size-full wp-image-30163 jetpack-lazy-image" src="../Images/44bae8c0528b4793aa960b39827be071.png" alt="Styled H1 Element Example" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2020/12/styled-h1-element-example.jpeg 497w, https://blog.logrocket.com/wp-content/uploads/2020/12/styled-h1-element-example-300x119.jpeg 300w" data-lazy-sizes="(max-width: 497px) 100vw, 497px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2020/12/styled-h1-element-example.jpeg?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/12/styled-h1-element-example.jpeg"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="30163" data-permalink="https://blog.logrocket.com/using-styled-components-in-react/styled-h1-element-example/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/12/styled-h1-element-example.jpeg" data-orig-size="497,197" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Styled H1 element" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/12/styled-h1-element-example-300x119.jpeg" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/12/styled-h1-element-example.jpeg" decoding="async" loading="lazy" class="aligncenter size-full wp-image-30163" src="../Images/44bae8c0528b4793aa960b39827be071.png" alt="Styled H1 Element Example" srcset="https://blog.logrocket.com/wp-content/uploads/2020/12/styled-h1-element-example.jpeg 497w, https://blog.logrocket.com/wp-content/uploads/2020/12/styled-h1-element-example-300x119.jpeg 300w" sizes="(max-width: 497px) 100vw, 497px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/12/styled-h1-element-example.jpeg"/></noscript>
<p>这就是为我们的组件设计样式是多么容易！</p>
<blockquote><p><strong>注意</strong>:你可能已经注意到了<code>styled</code> API使用了反斜杠(")。这是ES6中的一个特性，叫做<a href="https://wesbos.com/tagged-template-literals" target="_blank" rel="noopener noreferrer">标记模板文字</a>；这和调用函数是一样的。</p></blockquote>
<p>正如我前面提到的，我们也可以通过使用其他的<code>StyledComponent</code>作为基础来创建一个新的<code>StyledComponent</code>。因此，如果我们想创建另一个<code>StyledComponent</code>，它拥有<code>&lt;StyledDiv&gt;</code>的所有样式属性，但边框更圆，我们可以这样做:</p>
<pre>const StyledRoundedDiv = styled(StyledDiv)`
  border-radius: 30px;
`
</pre>
<p>所以现在<code>&lt;StyledRoundedDiv&gt;</code>继承了<code>&lt;StyledDiv&gt;</code>的所有风格，但是用自己的风格来调整<code>border-radius</code>属性。有了这个特性，我们可以创建不同的组件，这些组件都从单个基础组件继承样式。</p>
<p><code>styled</code> API还允许我们通过使用JavaScript样式化对象来创建<code>StyledComponent</code>(在JSX很常用)。如文档中所述，“当您拥有现有的样式对象并希望逐渐转移到样式化组件时，这尤其有用。”</p>
<p>如果我们要使用样式对象重新创建我们的<code>StyledDiv</code>组件，我们的代码将如下所示:</p>
<pre>const StyledDiv = styled.div({
  padding: "1.5rem",
  backgroundColor: "skyblue"
})
</pre>
<h2>使用React道具的动态样式</h2>
<p>styled-components的另一个强大特性是它能够使用props改变组件的样式。为了更好地说明这个概念，我们来看看<a href="https://blog.logrocket.com/the-definitive-guide-to-react-material-d730c8a3e8ba/" target="_blank" rel="noopener noreferrer"> Material-UI React库</a>。我们有一个接受不同道具的<code>&lt;Button&gt;</code>组件，但是我们将只关注<code>variant</code>和<code>color</code>道具。</p>
<p>有了<code>variant</code>属性，我们可以决定我们是想要按钮被勾勒出来，还是仅仅用<code>color</code>属性中指定的颜色填充。使用<code>color</code>属性，我们可以指定轮廓的颜色或者按钮的颜色，这取决于我们传递给<code>variant</code>属性的值。</p>
<p>如果我们要使用样式化组件实现这样一个组件，我们的代码可能看起来很像这样:</p>
<pre>const Button = styled.button`
  border-radius: 4px;
  padding: 6px 16px;
  min-width: 64px;
  text-transform: uppercase;
  font-weight: 500;
  font-size: 0.875rem;
  letter-spacing: 0.02857em;
  line-height: 1.75;
  font-family: "Roboto", "Helvetica", "Arial", sans-serif;
  background-color: ${(props) =&gt; backgroundColor(props)};
  ${(props) =&gt; colorAndBorder(props)}
`;
const colorToValue = {
  primary: "#1976d2",
  secondary: "rgb(220, 0, 78)",
};
const colorAndBorder = (props) =&gt; {
  var finalColor = "white";
  if (props.variant == "outlined") {
    if (colorToValue[props.color]) {
      finalColor = colorToValue[props.color];
    } else {
      finalColor = "black";
    }
  } else if (props.variant == "contained") {
    if (props.color) {
      finalColor = "white";
    } else {
      finalColor = "black";
    }
  }
  return css`
    color: ${finalColor};
    border: ${(prop) =&gt;
      props.variant == "outlined" ? "1px solid " + finalColor : "none"};
  `;
};
const backgroundColor = (props) =&gt; {
  if (props.variant == "outlined") {
    return "white";
  } else if (props.variant == "contained") {
    if (props.color) {
      let color = colorToValue[props.color];
      if (color) {
        return color;
      } else {
        return "#e0e0e0";
      }
    } else {
      return "#e0e0e0";
    }
  }
};
</pre>
<p>从上面的代码块中，你可以看到我为<code>Button</code>组件设置了基本样式，为<code>background-color</code>、<code>color</code>和<code>border</code>属性设置了动态样式，这取决于道具。</p>
<p>由于<code>styled</code>和<code>css</code>API使用标记的模板文字，我们可以将JavaScript(使用字符串插值)“注入”到我们的CSS中，以动态样式化组件，我们使用了两个自定义函数:<code>backgroundColor</code>和<code>colorAndBorder</code>。</p>
<p><code>backgroundColor</code>接受<code>StyledComponent</code>的道具，并以字符串形式返回按钮的合适背景色。<code>Button</code>组件样式中的外部函数现在可以使用该字符串来设置按钮的样式。</p>
<p>然而，对于<code>color</code>和<code>border</code>属性，我们使用了一个函数，它返回一个我们可以直接在<code>Button</code>的样式字符串中使用的值，而不仅仅是一个由外部函数使用的字符串。这就是<code>css</code>助手函数的用武之地。</p>
<p><code>css</code>辅助函数生成一个可以直接在模板文本样式中使用的值，特别是当传递给<code>css</code>函数的模板文本包含<a href="https://dmitripavlutin.com/string-interpolation-in-javascript/#:~:text=String%20interpolation%20is%20replacing%20placeholders,%24%7Bexpression%7D%20as%20a%20placeholder." target="_blank" rel="noopener noreferrer">字符串插值</a>时。</p>
<p>我们现在可以像这样使用我们的<code>Button</code>组件:</p>
<pre>function App() {
  return (
    &lt;&gt;
      &lt;Button variant="contained" color="primary"&gt;
        Primary Contained
      &lt;/Button&gt;

      &lt;Button variant="outlined" color="secondary"&gt;
       Secondary Outlined
      &lt;/Button&gt;

      &lt;Button variant="contained"&gt;
       Default contained
      &lt;/Button&gt;
    &lt;/&gt;
  );
}
</pre>
<h3>使用<code>attrs</code>构造函数的其他样式方法</h3>
<p>styled-components还允许使用<code>attrs</code>方法向组件添加额外的属性或HTML属性。使用<code>attrs</code>，我们可以定义静态属性，比如<code>&lt;input&gt;</code>元素的类型，以及动态属性。下面是一个正在使用的<code>attrs</code>方法的例子:</p>
<pre>const Link = styled.a.attrs((props) =&gt; ({
  href: props.$to,
}))`
  text-decoration: none;
  color: #000;
  border: 1px solid #000;
  padding: 1rem 1.5rem;
  border-radius: 5px;
`;

function App() {
  return (
    &lt;&gt;
      &lt;Link $to="https://blog.logrocket.com"&gt;Test link&lt;/Link&gt;
    &lt;/&gt;
  );
}
</pre>
<p>在上面的代码中，我们给我们的<code>&lt;Link&gt;</code>组件附加了一个<code>href</code>属性，它的底层HTML元素是一个锚元素。传递给<code>href</code>元素的值是从我们的<code>&lt;Link&gt;</code>组件的瞬态属性<code>$to</code>接收的。</p>
<p>瞬态属性是样式化组件中的一个特性，它允许我们使用不会出现在DOM中的属性。因此，如果您检查我们的<code>Link</code>组件，您会注意到它被简单地呈现为:</p>
<pre>&lt;a href="https://blog.logrocket.com" class="sc-bdfBwQ geNjDe"&gt;Test link&lt;/a&gt;
</pre>
<h2>使用样式化组件对React应用程序进行主题化</h2>
<p>styled-components还通过使用一个<code>ThemeProvider</code>组件来支持主题化。我们可以传递一个<code>theme</code>道具给<code>&lt;ThemeProvider&gt;</code>，这个<code>theme</code>会作为道具传递给<code>&lt;ThemeProvider&gt;</code>的所有孩子。</p>
<p>我们现在可以选择基于<code>theme</code>属性的值动态地设计这些子组件的样式。这里有一个简单的例子来说明这是如何工作的:</p>
<pre>const lightTheme = {
  main: "#fff",
};
const darkTheme = {
  main: "#000",
};
const invertColor = (props) =&gt; {
  if (props.theme.main == "#000"){
    return "#fff"
  } else {
    return "#000"
  }
}
const Div = styled.div`
  padding: 4rem;
  background-color: ${props =&gt; props.theme.main}
`
const Button = styled.button`
  padding: 1.5rem 2rem;
  color: ${props =&gt; invertColor(props)};
  border: 1px solid ${props =&gt; invertColor(props)};
  background-color: ${props =&gt; props.theme.main};
  transition: all 0.5s;
  &amp;:hover{
    color: ${props =&gt; props.theme.main};
    background-color: ${props =&gt; invertColor(props)};
    border: 1px solid ${props =&gt; props.theme.main};
  }
`
/*Default props for the Button component in case it has no theme attached to its props
*/
Button.defaultProps = {
  theme: darkTheme
}
function App() {
  return (
    &lt;&gt;
    &lt;ThemeProvider theme = {lightTheme}&gt;
      &lt;Div&gt;
        &lt;Button&gt;Light Theme button&lt;/Button&gt;
      &lt;/Div&gt;
    &lt;/ThemeProvider&gt;
    &lt;ThemeProvider theme = {darkTheme}&gt;
      &lt;Div&gt;
        &lt;Button&gt;Dark Theme button&lt;/Button&gt;
      &lt;/Div&gt;
      &lt;Button&gt;Dark Theme button&lt;/Button&gt;
    &lt;/ThemeProvider&gt;

    &lt;/&gt;
  );
}
</pre>
<p>浏览器中上述代码块的结果应该是:</p>
<p><img data-attachment-id="30164" data-permalink="https://blog.logrocket.com/using-styled-components-in-react/code-block-light-dark-themes/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/12/code-block-light-dark-themes.jpeg" data-orig-size="331,476" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Code block with light and dark themes" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/12/code-block-light-dark-themes-209x300.jpeg" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/12/code-block-light-dark-themes.jpeg" decoding="async" class="aligncenter size-full wp-image-30164 jetpack-lazy-image" src="../Images/78628c88d92a5c2b9f90d8e558d1f1d5.png" alt="A Code Block With Light and Dark Themes" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2020/12/code-block-light-dark-themes.jpeg 331w, https://blog.logrocket.com/wp-content/uploads/2020/12/code-block-light-dark-themes-209x300.jpeg 209w" data-lazy-sizes="(max-width: 331px) 100vw, 331px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2020/12/code-block-light-dark-themes.jpeg?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/12/code-block-light-dark-themes.jpeg"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="30164" data-permalink="https://blog.logrocket.com/using-styled-components-in-react/code-block-light-dark-themes/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/12/code-block-light-dark-themes.jpeg" data-orig-size="331,476" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Code block with light and dark themes" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/12/code-block-light-dark-themes-209x300.jpeg" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/12/code-block-light-dark-themes.jpeg" decoding="async" loading="lazy" class="aligncenter size-full wp-image-30164" src="../Images/78628c88d92a5c2b9f90d8e558d1f1d5.png" alt="A Code Block With Light and Dark Themes" srcset="https://blog.logrocket.com/wp-content/uploads/2020/12/code-block-light-dark-themes.jpeg 331w, https://blog.logrocket.com/wp-content/uploads/2020/12/code-block-light-dark-themes-209x300.jpeg 209w" sizes="(max-width: 331px) 100vw, 331px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/12/code-block-light-dark-themes.jpeg"/></noscript>
<p>从代码中可以看出，有两个对象，<code>lightTheme</code>和<code>darkTheme</code>，分别代表浅色和深色主题的原色。</p>
<p>还有一个叫<code>invertColor</code>的函数，它只是简单的接受道具，并返回道具所附带的主题的相反原色。使用主题对象和<code>invertColor</code>函数，我们能够创建一个明暗主题，并相应地设计我们的组件。</p>
<p>还要注意，我们在<code>&lt;Button&gt;</code>组件的模板文本中使用了&amp;符号(<code>&amp;</code>);它的用法类似于你在CSS预处理器如SCSS中发现的。这个符号仅仅代表我们正在设计样式的组件，所以它可以用来设计组件的CSS伪元素或类的样式，就像我们所做的那样。</p>
<h2>动画功能</h2>
<p>应该的是，styled-components也通过<code>keyframes</code>辅助函数支持CSS动画。这个函数利用模板文字来定义动画的CSS，并返回一个值，这个值现在可以被插入到<code>css</code>辅助函数中或者与<code>styled</code> API一起使用。</p>
<p>下面是文档中的一个简单示例，展示了我们代码中的<code>keyframes</code>函数:</p>
<pre>import styled, { keyframes } from 'styled-components'

const fadeIn = keyframes`
  0% {
    opacity: 0;
  }
  100% {
    opacity: 1;
  }
`

const FadeInButton = styled.button`
  animation: 1s ${fadeIn} ease-out;
` 
</pre>
<h2>结论</h2>
<p>我们终于讨论了我认为是样式组件库中最重要和最常用的部分。你可以在综合文档<a href="https://styled-components.com/docs/basics" target="_blank" rel="noopener noreferrer">这里</a>了解更多关于这个库的信息。</p><div class="code-block code-block-17">
<div class="blog-plug inline-plug react-plug" vwo-el-id="26283398190">
<h2 vwo-el-id="41600691720">使用LogRocket消除传统反应错误报告的噪音</h2>
<a href="https://lp.logrocket.com/blg/react-signup-issue-free" target="_blank" vwo-el-id="19356441070">LogRocket
</a><p>是一款React analytics解决方案，可保护您免受数百个误报错误警报的影响，只针对少数真正重要的项目。LogRocket告诉您React应用程序中实际影响用户的最具影响力的bug和UX问题。</p><a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="19356441380">
<img class="first-react-image alignnone size-full wp-image-46 jetpack-lazy-image jetpack-lazy-image--handled" src="../Images/f300c244a1a1cf916df8b4cb02bec6c6.png" vwo-el-id="18272717540" data-lazy-loaded="1" data-original-src="https://files.readme.io/27c94e7-Image_2017-06-05_at_9.46.04_PM.png"/>
</a>
<a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="19356441690">
<img class="second-react-image alignnone size-full wp-image-46 jetpack-lazy-image jetpack-lazy-image--handled" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" vwo-el-id="30720362350" data-lazy-loaded="1" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/>
</a>
<a href="https://lp.logrocket.com/blg/react-signup-issue-free" target="_blank" rel="noopener noreferrer" vwo-el-id="35866400580">LogRocket
</a><p>自动聚合客户端错误、反应错误边界、还原状态、缓慢的组件加载时间、JS异常、前端性能指标和用户交互。然后，LogRocket使用机器学习来通知您影响大多数用户的最具影响力的问题，并提供您修复它所需的上下文。</p><p vwo-el-id="28675661060">关注重要的React bug—<a class="signup" href="https://lp.logrocket.com/blg/react-signup-issue-free" target="_blank" rel="noopener noreferrer" vwo-el-id="40093418840">今天就试试LogRocket】。</a></p>
</div></div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
<html>
<head>
<title>Babel vs. TypeScript: Choosing the right compiler for your project - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>Babel vs. TypeScript:为您的项目选择正确的编译器</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/babel-vs-typescript/#0001-01-01">https://blog.logrocket.com/babel-vs-typescript/#0001-01-01</a></blockquote><div><article class="article-post">
<p><strong>编者按:</strong> <i>本帖最后更新于2021年7月30日。随着<a href="https://babeljs.io/blog/2021/07/26/7.15.0">巴别塔7.15 </a>的更新，一些部分被重写以保持准确。</i></p>
<p>自Babel 7于2018年发布以来，使用Babel的项目可以使用TypeScript，而无需使用TypeScript编译器来复杂化他们的构建。</p>
<p>但是使用Babel和使用TypeScript编译器有什么区别呢？你的下一个项目应该使用Babel还是TypeScript？</p>
<figure><a href="https://logrocket.com/signup/" target="_blank" rel="noopener noreferrer"><img decoding="async" src="../Images/94b3e0f84b30cb0d321f60471481ab64.png" data-height="750" data-width="3212" data-lazy-src="https://storage.googleapis.com/blog-images-backup/1*GPjaPKNNUYHU8EsA3Z0JGA.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" class=" jetpack-lazy-image" data-original-src="https://storage.googleapis.com/blog-images-backup/1*GPjaPKNNUYHU8EsA3Z0JGA.png"/><noscript><img data-lazy-fallback="1" decoding="async" src="../Images/94b3e0f84b30cb0d321f60471481ab64.png" data-height="750" data-width="3212" data-original-src="https://storage.googleapis.com/blog-images-backup/1*GPjaPKNNUYHU8EsA3Z0JGA.png"/></noscript></a></figure>
<h2>巴别塔和打字稿的区别</h2>
<p>使用TypeScript和将TypeScript与Babel一起使用有一些主要区别。</p>
<p>在这篇文章中，我们将看看五个最重要的区别。</p>
<h3>1.Babel中没有类型检查</h3>
<p>巴贝尔不关心你的花式打字稿类型。它只是把它们扔进垃圾桶，而不检查它们是否正确。以下示例使用Babel编译时没有任何错误或警告，但使用TypeScript时没有:</p>
<figure class="wp-caption">
<pre><code>const myCoolString : string = 9;</code></pre><figcaption class="wp-caption-text"><code>9</code> is definitely not a string Babel.</figcaption></figure>
<p>移除类型对于您希望代码编译的快速原型开发来说是非常好的，即使您的类型并不合适。</p>
<p>如果你正在努力输入东西，在某些时候你可能会想检查它们是否正确。幸运的是，这不是什么大事。您可以让您的编辑器来处理它，或者运行<code>tsc --noEmit</code>，它在不编译任何东西的情况下对您的项目进行类型检查。</p>
<h3>2.巴贝尔做不到<code>const enums</code></h3>
<p>默认情况下，TypeScript一次编译整个项目，而Babel一次只编译一个文件。</p>
<p>以前，这意味着Babel不支持需要读取多个文件的TypeScript特性——比如<code>const enums</code>。</p>
<p>然而，自从2021年7月26日发布的巴别塔7.15(T1)以来，情况就不一样了。这实质上意味着，如果您使用的是最新版本的Babel，您应该能够编译所有有效的TypeScript代码库。</p>
<h3>3.装饰者和元数据:TypeScript有优势</h3>
<p>TypeScript对于decorator党来说有点早(如果你不确定decorator是什么，<a href="https://blog.logrocket.com/a-practical-guide-to-typescript-decorators/">这是对decorator的很好的介绍</a>)。在TypeScript实现了decorator之后，decorator提案已经更改了多次，仍然没有最终确定。</p>
<p>这意味着目前<a href="https://blog.logrocket.com/how-to-use-ecmascript-modules-with-node-js/"> ECMAScript </a>规范和TypeScript在装饰者应该如何表现的问题上意见不一致。Babel的插件遵循ECMAScript规范，这意味着Babel不会像TypeScript那样编译decorators。幸运的是，Babel有一个<code>legacy</code>模式来编译带有旧行为的decorators。</p>
<p>只需添加巴别塔插件</p>
<p><code>“@babel/plugin-proposal-decorators”</code></p>
<p>将<code>legacy</code>选项设置为<code>true</code> <strong>。</strong></p>
<p>还有一个我们应该讨论的TypeScript decorators特性:<code>emitDecoratorMetadata</code>。</p>
<p>TypeScript通常会清除所有类型信息，使其在运行时不存在。<code>emitDecoratorMetadata</code>是一个为应用了装饰器的类和方法保留类型的特性。</p>
<p>在运行时拥有该类型允许我们做各种各样有趣的事情，比如依赖注入和将TypeScript类型映射到SQL数据库中的类型。</p>
<p>该特性在这两个领域得到了大量使用，诸如TypeORM、TypeGoose、inversifyJS等库，甚至<a href="https://blog.logrocket.com/how-to-use-ecmascript-modules-with-node-js/"> Angular的依赖注入系统</a>都依赖于该特性。</p>
<p>由于Babel不关心你的类型信息，这个特性需要一个自定义插件，<a href="https://www.npmjs.com/package/babel-plugin-transform-typescript-metadata">Babel-plugin-transform-typescript-metadata</a>。添加这个插件和前面提到的<code>plugin-proposal-decorators</code>应该会让Babel的特性在decorators方面与TypeScript平起平坐。</p>
<h3>4.巴别塔擅长自定义转换</h3>
<p>Babel比TypeScript更具可扩展性。有大量的插件可以优化你的代码，帮助你去掉不用的导入、内联、常量等等。</p>
<p>虽然TypeScript有自己的Transformer API，允许自定义转换，但Babel生态系统在插件选择上更丰富，也更容易访问。</p>
<p>如果您需要自定义转换，您将需要使用Babel。好消息是，大多数TypeScript工具都允许您使用TypeScript，然后通过Babel运行代码，这样可以两全其美。但是这显然会增加构建链的复杂性。</p>
<h3>5.TypeScript和Babel具有相似的性能</h3>
<p>比较Babel和TypeScript的性能是很困难的，并且可能不会给你完整的描述。执行类型检查的TypeScript肯定会比Babel慢，因为有额外的步骤。</p>
<p>为了达到大致相同的速度，您可以通过使用类似于<a href="https://github.com/TypeStrong/fork-ts-checker-webpack-plugin">fork-ts-checker-web pack-plugin</a>的东西来缓解这种减速，它在一个进程中运行不带类型的编译，在一个后台进程中运行类型检查。</p>
<p>当然，任何试图配置webpack的人都知道，JavaScript工具链非常复杂。你有源映射插件，缓存，选择你应该使用多少线程——还有很多。没有一个简单的基准可以考虑全部情况，但是如果你期望使用Babel比使用TypeScript编译器有多倍的提高，你将不得不在其他地方寻找你的性能提升——<a href="https://blog.logrocket.com/benchmarking-bundlers-2020-rollup-parcel-webpack/">也许是你的bundler </a>？</p>
<h2>Babel和TypeScript你该选哪个？</h2>
<p>在这一点上，TypeScript和Babel在您的构建链中扮演的角色大致相同。Babel现在完全支持<code>const enums</code>、decorator和decorator元数据。</p>
<p>使用Babel的唯一缺点是，您需要将类型检查作为一个单独的过程来运行。</p>
<p>如果你已经有了一个适合你的构建管道，我看不出有什么令人信服的理由去转换。然而，如果你开始一个项目，我可能会倾向于使用TypeScript编译器，可能通过类似于<a href="https://github.com/TypeStrong/ts-loader"> ts-loader </a>的东西。然后，如果你发现你需要一些只有Babel提供的转换，你可以把transpiled的TypeScript输出传递给Babel。</p>
<p>对我来说，这有点太复杂了，但是嘿——没有人说过JavaScript构建工具链是容易的。</p>
<p>你有使用TypeScript和Babel的经验吗？我很想听听。 <a href="https://twitter.com/GeeWengel" target="_blank" rel="noopener noreferrer"> <em> @GeeWengel </em> </a></p><div class="code-block code-block-21">
<div class="blog-plug inline-plug typescript-plug"><h2><a class="signup" href="https://lp.logrocket.com/blg/typescript-signup" target="_blank" rel="noopener noreferrer"> LogRocket </a>:全面了解您的网络和移动应用</h2>
<a href="https://lp.logrocket.com/blg/typescript-signup" class="signup" target="_blank" rel="noopener noreferrer"><img class="alignnone size-full wp-image-46 jetpack-lazy-image" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/><noscript><img data-lazy-fallback="1" class="alignnone size-full wp-image-46" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/></noscript></a>
<p>LogRocket 是一个前端应用程序监控解决方案，可以让您回放问题，就像问题发生在您自己的浏览器中一样。LogRocket不需要猜测错误发生的原因，也不需要向用户询问截图和日志转储，而是让您重放会话以快速了解哪里出错了。它可以与任何应用程序完美配合，不管是什么框架，并且有插件可以记录来自Redux、Vuex和@ngrx/store的额外上下文。</p>
<p>除了记录Redux操作和状态，LogRocket还记录控制台日志、JavaScript错误、堆栈跟踪、带有头+正文的网络请求/响应、浏览器元数据和自定义日志。它还使用DOM来记录页面上的HTML和CSS，甚至为最复杂的单页面和移动应用程序重新创建像素级完美视频。</p>
<a class="signup" href="https://lp.logrocket.com/blg/typescript-signup" target="_blank" rel="noopener noreferrer">Try it for free</a><p>.</p></div>
</div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
<html>
<head>
<title>Understanding Deno’s file system - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>了解Deno的文件系统- LogRocket博客</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/understanding-denos-file-system/#0001-01-01">https://blog.logrocket.com/understanding-denos-file-system/#0001-01-01</a></blockquote><div><article class="article-post">
<p><a href="https://blog.logrocket.com/deno-1-0-what-you-need-to-know/" target="_blank" rel="noopener noreferrer"> Deno </a>自带文件系统作为核心模块。这个文件系统模块可以用于任何类型的文件或目录操作。</p>
<p>在本教程中，我们将介绍可以在Deno应用程序中使用的文件系统方法。</p>
<p>目前，一些方法仍然是实验性的，并且相当不稳定；当使用这些方法时，您应该总是添加<code>--unstable</code>标志。</p>
<p>我们将带您了解以下内容:</p>

<h2 id="howtowritefilesindeno">如何用Deno写文件</h2>
<p>用Deno写文件有几种方法。它们都需要<code>--allow-write</code>标志，如果出现一个错误就会抛出。</p>
<p>您可以使用<code>Deno.writeTextFile</code>或<code>Deno.writeFile</code>将文本写入文件。<code>Deno.writeTextFile</code>有同步和异步两种格式，接受两个参数:文件的位置和要写入下面文件的内容。</p>
<pre>// using the async method
await Deno.writeTextFile('./file.txt', 'This is the content to be written');

//using sync method
Deno.writeTextFileSync('./file.txt', 'This is the content to be written');
</pre>
<p>您也可以使用带有<code>TextEncoder</code>的<code>Deno.writeFile</code>方法。<code>TextEncoder</code>将字符串转换为Uint8Array:</p>
<pre>const encoder = new TextEncoder(); // to convert a string to Uint8Array
await Deno.writeFile("./file.txt", encoder.encode("Content to be written"));
</pre>
<p>最后，您可以使用<code>Deno.open</code>和<code>Deno.writeAll</code>方法打开一个文件，向其中写入内容，然后关闭该文件，如下所示。</p>
<pre>const file = await Deno.open("./image.png", { write: true, create: true }); //this opens the file
await Deno.writeAll(file, imageBytes); //writes to file
file.close(); // closes the file
</pre>
<p>如果您尝试写入一个不存在的文件，Deno会自动创建该文件。</p>
<h2 id="howtoreadfilesindeno">如何在Deno中读取文件</h2>
<p>像写文件一样，Deno中有无数种读取文件的方法，所有这些方法都需要使用<code>--allow-read</code>标志。</p>
<p>您可以使用<code>Deno.readTextFile</code>和<code>Deno.readFile</code>方法在Deno中读取文件。<code>Deno.readTextFile</code>有同步和异步两种格式，并接受文件路径作为参数:</p>
<pre>// using the async method
const text = await Deno.readTextFile("file.txt");
console.log(text);

//using the sync method
const sync = Deno.readTextFileSync("file.txt");
console.log(sync);
</pre>
<p>另一种方法是<code>Deno.readFile</code>。您必须首先使用<code>TextDecoder</code>方法将文件解码为可读格式。</p>
<pre>const decoder = new TextDecoder("utf-8");
const text = decoder.decode(await Deno.readFile("file.txt"));

console.log(text);
</pre>
<h2 id="removingfilesindeno">删除Deno ( <code>remove</code>和<code>removeSync</code>)中的文件</h2>
<p>要删除Deno中的文件，请使用<code>remove</code>或<code>removeSync</code>方法。</p>
<pre>// Deno remove file asynchronous (non-block)
await Deno.remove("file.txt");

// Deno remove file synchronous (blocking way)
Deno.removeSync("image.png");
</pre>
<p>如果你试图删除一个不存在的文件，Deno会抛出一个错误。</p>
<pre>Uncaught NotFound: No such file or directory (os error 2)
</pre>
<h2 id="ensuredirectory">检查目录中的文件夹(<code>ensureDir</code>)</h2>
<p><code>ensureDir</code>方法确保文件夹存在于您的工作目录中。你可以用它来写一个简单的程序。</p>
<p>让我们写一个简单的程序来检查文件夹是否存在。如果文件夹存在，它会创建一个新文件并向其中添加一些文本内容。</p>
<p>要使用此方法，必须将其导入到应用程序中。在您的工作目录中创建一个<code>notes</code>文件夹。这是你存放笔记的地方。</p>
<pre>import { ensureDir, ensureDirSync } from "https://deno.land/std/fs/mod.ts";
</pre>
<p>像我们到目前为止讨论的其他方法一样，这种方法有异步和同步两种格式。下面是如何使用异步方法:</p>
<pre>ensureDir("./notes")
  .then(() =&gt; Deno.writeTextFile("./notes/note1.txt", "This is the content for note 1")); 
</pre>
<h2 id="copyingfilecontents">复制文件内容(<code>copy</code>)</h2>
<p><code>copy</code>方法使您能够将文件内容复制到另一个文件。</p>
<p>要将<code>copy</code>方法导入到Deno应用程序中:</p>
<pre>import { copy } from "https://deno.land/std/fs/mod.ts";
copy("file.txt", "test.txt", {
  overwrite: true,
});
</pre>
<p>该方法将文件内容从<code>file.txt</code>复制到<code>test.txt</code>。这也需要一些选择。例如，<code>overwrite</code>选项会覆盖您正在复制内容的文件的内容。</p>
<h2 id="checkingifafileexists">检查目录(<code>exists</code>)</h2>
<p>方法检查一个目录是否存在。<code>exists</code>返回一个承诺，而<code>existsSync</code>返回一个布尔值。</p>
<p>让我们写一个简单的程序来检查一个目录是否存在:</p>
<pre>import { exists, existsSync } from "https://deno.land/std/fs/mod.ts";

exists("./notes").then((res) =&gt; console.log(res)); //res here returns a boolean
 //or do this
let fileExists = existsSync("./notes"); 
console.log(fileExists);// returns boolean
</pre>
<h2 id="ensurefile">检查文件是否存在(<code>ensureFile</code>)</h2>
<p>确保文件存在。</p>
<p>让我们编写一个简单的程序来试验它:</p>
<pre>import { ensureFile, ensureFileSync } from "https://deno.land/std/fs/mod.ts";
let ok = ensureFileSync("./read.ts");
</pre>
<p>如果文件不存在，Deno会自动创建它。同样，记住添加<code>--unstable</code>标志，因为其中一些方法仍然是实验性的。</p><div class="code-block code-block-54">
<hr/>
<h3>更多来自LogRocket的精彩文章:</h3>

<hr/></div>
<h2 id="emptydir">如何清空Deno ( <code>emptyDir</code>)中的目录</h2>
<p>方法检查一个目录是否为空。如果指定的目录包含任何文件或目录，Deno将清空目录。</p>
<pre>import { emptyDir } from "https://deno.land/std/fs/mod.ts";

emptyDir("./notes").then((res) =&gt; console.log("res", res)); // this method return a promise.
</pre>
<h2 id="creatingacliapplicationindeno">在Deno中创建CLI应用程序</h2>
<p>现在让我们创建一个简单的CLI应用程序，它将为我们创建文件。我们将使用终端来创建这个文件。</p>
<p><code>Deno.args</code>返回命令中传递的所有参数。这样，我们可以创建一个简单的应用程序。我们的命令将保存我们想要创建的文件的名称。</p>
<p>运行以下命令:</p>
<pre>deno run main.ts create-file test.ts.</pre>
<p>这个命令有两个参数:<code>create-file</code>和<code>test.ts</code>。如果我们记录<code>Deno.args</code>，它将返回一个数组中的参数。</p>
<p>我们可以用这个来检查美国是否</p>
<p>ser传递了<code>create-file</code>参数并提供了一个文件名:</p>
<pre>let params = Deno.args;
console.log(params);
let createFile = () =&gt; {
  if (params[0] !== "create-file") {
    console.log(
      `${params[0]} is not a valid command, Did you mean 'create-file'`,
    );
    return false;
  } else if (!params[1]) {
    console.log(
      `You need to provide a name of a file`,
    );
    return false;
  } else {
    Deno.writeTextFileSync(`./${params[1]}`, "//This is your created file");
  }
};
createFile();
</pre>
<p>现在要运行应用程序，打开您的终端并运行以下命令:</p>
<pre>deno run --allow-all main.ts create-file &lt;name of file&gt;
</pre>
<p>记得添加<code>--allow-all</code>或<code>--allow-write</code>文件标志。</p>
<h2 id="conclusion">结论</h2>
<p>如你所见，<a href="https://deno.land/" target="_blank" rel="noopener noreferrer"> Deno的</a>文件系统相当通用，在向Deno写入文件时有多种方法和场景需要考虑。知道如何使用同步和异步方法总是好的，因为它们都有自己的用例。当写入较大的文件时，您应该考虑利用写入流的分块写入功能。</p>
<p>本演示中使用的源代码可在<a href="https://github.com/Wisdom132/deno/tree/master/fs" target="_blank" rel="noopener noreferrer"> GitHub </a>上获得。</p>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
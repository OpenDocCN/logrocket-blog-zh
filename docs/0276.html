<html>
<head>
<title>A quick and complete guide to TypeScript types - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>一个快速完整的类型脚本类型指南</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/a-quick-and-complete-guide-to-typescript-types-438c259257d3/#0001-01-01">https://blog.logrocket.com/a-quick-and-complete-guide-to-typescript-types-438c259257d3/#0001-01-01</a></blockquote><div><div class="section-inner sectionLayout--insetColumn">
<h3 class="graf graf--h3">使用类型</h3>
<p class="graf graf--p">在TypeScript中，变量的类型在变量声明之前在右侧定义。如果我们想定义变量<code>name</code>的类型，它看起来会像下面的代码片段:</p>
<pre>const name: string = 'John';</pre>
<p class="graf graf--p">可以使用的类型有:</p>
<ul class="postList">
<li class="graf graf--li">声明变量时</li>
<li class="graf graf--li">在函数参数中</li>
<li class="graf graf--li">对函数的返回值进行类型检查</li>
</ul>
<h3 class="graf graf--h3">变量声明</h3>
<p class="graf graf--p">当在TypeScript中声明一个变量时，我们使用了<code>let</code>和<code>const</code>关键字。你可以输入校验数组，字符串，数字等。</p>
<p class="graf graf--p"><strong class="markup--strong markup--p-strong">数组</strong> TypeScript和JavaScript一样，允许你处理数值数组。数组类型可以用两种方式之一编写。在第一个例子中，使用元素的类型后跟<code>[]</code>来表示该元素类型的数组:</p>
<pre>const names: string[] = ['John', 'Peter', 'Mark'];
const ages: number[] = [23, 45, 56];</pre>
<p class="graf graf--p">此外，我们可以使用通用数组类型<code>Array&lt;elementType&gt;</code>，其中<code>elementType</code>是数组中包含的元素的类型。一个例子是这样的:</p>
<pre>const names: Array&lt;string&gt; = ['Mark', 'Peter', 'John'];
const ages: Array&lt;number&gt; = [56, 45, 23];</pre>
<p class="graf graf--p">现在，如果您的数组将包含几个类型，元组开始发挥作用。</p>
<p class="graf graf--p"><strong class="markup--strong markup--p-strong">元组</strong>元组允许你声明一个数组，其中固定数量的元素的类型是已知的，但不需要相同。例如，您可能希望将一个值表示为一对<code>string</code>和<code>number</code>:</p>
<pre>let names: [string, number];
names = ['peter', 23]; // Correct
names = [23, 'John']; // Error
names = [23, 'John', 33, 'Peter' ] // Correct</pre>
<p class="graf graf--p">最后一个例子是一个多于两个字符的数组，这没有出错，因为我们提供了额外的元素，或者是一个<code>string</code>或者是一个<code>number</code>。如果将一个布尔值添加到数组中，将会抛出一个错误。</p>
<pre>names = ['Peter', 24, false] // error
names = ['John', 34, {} ] // error</pre>
<p class="graf graf--p"><strong class="markup--strong markup--p-strong">布尔</strong>布尔是最基本的数据类型。不是<code>true</code>就是<code>false</code>。</p>
<pre>const isHappy: boolean = true;
const canDrive: boolean = 34; // error</pre>
<p class="graf graf--p">TypeScript中的字符串有三种用法:</p>
<ul class="postList">
<li class="graf graf--li">双引号。</li>
<li class="graf graf--li">单引号。</li>
<li class="graf graf--li">模板文字。</li>
</ul>
<p class="graf graf--p">双引号:</p>
<pre>let name: string = "Peter";</pre>
<p class="graf graf--p">单引号:</p>
<pre>name = 'John';</pre>
<p class="graf graf--p"><a class="markup--anchor markup--p-anchor" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals" target="_blank" rel="noopener noreferrer" data-href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals">模板文字</a>:这些是允许嵌入表达式的字符串文字。您可以使用多行字符串和字符串插值功能。在ES2015规范的早期版本中，它们被称为“模板字符串”。这些字符串用反勾/反引号(" ` ")字符括起来，嵌入表达式的形式是<code>${ expr }</code>。</p>
<pre>let color: string = 'green';
let amount: number = 3;
let car: string = 'Benz';
let sentence: string = `John has ${amount} cars. They are all ${color}, his favorite is the ${car}`.</pre>
<p class="graf graf--p"><strong class="markup--strong markup--p-strong">数字</strong>在JavaScript中，所有的数字都有确定的数字类型。所有的JavaScript数字都是浮点值，TypeScript也一样。TypeScript还支持二进制和八进制文本以及十六进制和十进制值。</p>
<pre>let hexadecimal: number = 0xf00d;
let decimal: number = 23.34;
let binary: number = 0b1010;
let octal: number = 0o744;</pre>
<p class="graf graf--p">枚举是一种命名数值集合的友好方式。枚举从0开始编号，但您可以手动设置其中一个成员的值。</p>
<pre>enum Car {BENZ, TOYOTA, HONDA}
const myCar: Car = Car.TOYOTA;</pre>
<p class="graf graf--p">或者我们可以手动设置枚举的值:</p>
<pre>enum Car {BENZ = 2, TOYOTA = 4, HONDA = 6}
const myCar: Car = Car.HONDA;</pre>
<p class="graf graf--p">枚举的一个便利特性是，您还可以在枚举中从一个数值转到该值的名称。例如，如果我们有值<code>6</code>，但不确定它映射到上面的<code>Car</code>枚举中的什么，我们可以查找相应的名称。</p>
<pre>enum Car { BENZ=2, TOYOTA, HONDA=6 }
const myCar: string = Car[6];</pre>
<p class="graf graf--p"><strong class="markup--strong markup--p-strong">任何</strong>有时候，我们可能不知道我们在和什么类型的人一起工作。这时我们就可以使用<code>any</code>类型了。<code>any</code>类型允许我们选择不进行类型检查。</p>
<pre>let myCar: any = 'honda';
myCar = false; // correct
myCar = 34; // correct</pre>
<p class="graf graf--p"><code>any</code>型非常灵活。比JavaScript <code>object</code>更是如此。使用<code>any</code>类型，您可以在代码中不断地选择加入或退出类型检查。</p>
<pre>let car: any = 'honda';
car.start(); // compiles</pre>
<p class="graf graf--p"><strong class="markup--strong markup--p-strong"> Void </strong> Void几乎是<code>any</code>的直接反义词，它描绘了一种类型的缺失。它通常用于定义函数的返回类型。</p>
<pre>function startCar():void {
    console.log('Car started');
}</pre>
<p class="graf graf--p">当声明变量时，将变量类型定义为<code>void</code>并不真正有用，因为你只能将变量设置为<code>undefined</code>或<code>null</code>。</p>
<p class="graf graf--p"><strong class="markup--strong markup--p-strong"> Null和Undefined </strong> <code>Null</code>和<code>Undefined</code>都有各自的类型命名。这些类型本身没有用，因为我们只能将<code>Null</code>和<code>Undefined</code>赋给定义为<code>Null</code>或<code>Undefined</code>类型的变量。</p>
<pre>let n: null = null;
n = 43; //compile error
let u: undefined = undefined;
u = 'string'; // compile error</pre>
<p class="graf graf--p">自然，<code>null</code>和<code>undefined</code>是任意类型的子类型。所以你可以把<code>null</code>或者<code>undefined</code>分配给<code>number</code>或者<code>string</code>。</p>
<p class="graf graf--p"><strong class="markup--strong markup--p-strong">从不</strong><code>never</code>类型代表从不出现的值的类型。例如，<code>never</code>是函数表达式或箭头函数表达式的返回类型，它总是抛出异常或从不返回；当被任何不可能为真的类型守卫缩小时，变量也会获得类型<code>never</code>。</p>
<p class="graf graf--p"><code>never</code>类型是每个类型的子类型，并且可以分配给每个类型；然而，<em class="markup--em markup--p-em">没有</em>类型是<code>never</code>的子类型，或者可分配给<code>never</code>(除了<code>never</code>本身)。甚至<code>any</code>都不能分配给<code>never</code>。一些函数返回的例子<code>never</code>:</p>
<pre>function throwIt(message: string): never{
    throw new Error(message);
}

// Inferred return type is never
function fail() {
    return error("Something failed");
}</pre>
<p class="graf graf--p"><strong class="markup--strong markup--p-strong">函数类型</strong>我们可以定义函数参数和函数返回值的类型。当我们在一个没有任何值的函数上使用<code>void</code>时，我们做了类似的事情。</p>
<pre>function returnValue(message: string): string{
    return message;
}</pre>
<h3 class="graf graf--h3">结论</h3>
<p class="graf graf--p">我们快速浏览了打字稿的类型。在TypeScript中有更高级的类型应用，比如创建声明文件等。你可以在这里阅读更多关于创建声明文件的信息。</p><div class="code-block code-block-21">
<div class="blog-plug inline-plug typescript-plug"><h2><a class="signup" href="https://lp.logrocket.com/blg/typescript-signup" target="_blank" rel="noopener noreferrer"> LogRocket </a>:全面了解您的网络和移动应用</h2>
<a href="https://lp.logrocket.com/blg/typescript-signup" class="signup" target="_blank" rel="noopener noreferrer"><img class="alignnone size-full wp-image-46 jetpack-lazy-image" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/><noscript><img data-lazy-fallback="1" class="alignnone size-full wp-image-46" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/></noscript></a>
<p>LogRocket 是一个前端应用程序监控解决方案，可以让您回放问题，就像问题发生在您自己的浏览器中一样。LogRocket不需要猜测错误发生的原因，也不需要向用户询问截图和日志转储，而是让您重放会话以快速了解哪里出错了。它可以与任何应用程序完美配合，不管是什么框架，并且有插件可以记录来自Redux、Vuex和@ngrx/store的额外上下文。</p>
<p>除了记录Redux操作和状态，LogRocket还记录控制台日志、JavaScript错误、堆栈跟踪、带有头+正文的网络请求/响应、浏览器元数据和自定义日志。它还使用DOM来记录页面上的HTML和CSS，甚至为最复杂的单页面和移动应用程序重新创建像素级完美视频。</p>
<a class="signup" href="https://lp.logrocket.com/blg/typescript-signup" target="_blank" rel="noopener noreferrer">Try it for free</a><p>.</p></div>
</div>
</div>
</div>    
</body>
</html>
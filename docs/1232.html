<html>
<head>
<title>RE:DOM vs. Svelte - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>回复:DOM vs. Svelte - LogRocket博客</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/redom-vs-svelte/#0001-01-01">https://blog.logrocket.com/redom-vs-svelte/#0001-01-01</a></blockquote><div><article class="article-post">
<p>RE:DOM是一个用于操作DOM的库，Svelte是一个带有路由和转换的框架。在本帖中，我们将回顾它们的不同之处，并确定哪一个是不同类型应用的更好选择。</p>
<h2>用RE:DOM和Svelte创建组件</h2>
<p>回复:DOM和Svelte都允许我们创建组件来呈现内容。</p>
<h3>苗条的</h3>
<p>在Svelte中，我们在单独的文件中创建组件。例如，我们可以写:</p>
<pre>//App.svelte

&lt;script&gt;
    import Button from "./Button.svelte";
&lt;/script&gt;

&lt;style&gt;
  main {
    font-family: sans-serif;
    text-align: center;
  }
&lt;/style&gt;

&lt;main&gt;
    &lt;h1&gt;Hello&lt;/h1&gt;
    &lt;Button /&gt;
&lt;/main&gt;</pre>
<pre>//Button.svelte

&lt;script&gt;
    let count = 0;

    function handleClick() {
      count += 1;
    }
&lt;/script&gt;

&lt;style&gt;
    button {
      background: #ff3e00;
      color: white;
      border: none;
      padding: 8px 12px;
      border-radius: 2px;
    }
&lt;/style&gt;

&lt;button on:click={handleClick}&gt;
  Clicked {count} {count === 1 ? 'time' : 'times'}
&lt;/button&gt;</pre>
<p>我们在<code>Button.svelte</code>中创建了<code>Button</code>组件，它包含在<code>App.svelte</code>组件文件中。</p>
<p><code>script</code>标签有逻辑，<code>style</code>有每个组件的样式。文件的其余部分是我们想要呈现的HTML内容。</p>
<p>我们将JavaScript表达式嵌入在括号中，它有自己的附加事件处理程序的语法。属性让我们附加一个点击处理程序。</p>
<p>标签中的函数可以在HTML模板中引用，就像我们对函数所做的一样。</p>
<p>在<code>script</code>标签中声明的任何变量都可以在模板中引用和呈现，就像在<code>button</code>元素中一样。</p>
<p>数据绑定是自动完成的，所以不需要我们自己来做。</p>
<h3>回复:DOM</h3>
<p>对于RE:DOM，我们通过运行以下命令来安装<code>redom</code>包:</p>
<pre>npm i redom</pre>
<p>然后，我们可以通过编写以下代码来创建一个简单的组件:</p>
<pre>//index.js

import { el, mount } from "redom";

const hello = el("h1", "Hello world");

mount(document.body, hello);</pre>
<p>这假设我们将使用像Parcel这样的模块捆绑器来创建我们的项目。我们用<code>el</code>函数创建组件，并传入我们想要显示的标签和HTML。然后，我们调用<code>mount</code>将<code>hello</code>组件安装到车身上。</p>
<p>我们可以用<code>text</code>函数创建一个文本组件:</p>
<pre>import { text, mount } from "redom";

const hello = text("hello");

mount(document.body, hello);

hello.textContent = "hi!";</pre>
<p>我们将初始的<code>textContent</code>传递给<code>text</code>函数，当我们重新分配它的值时，它会自动更新。</p>
<p>如果我们想添加子元素，我们写:</p>
<pre>import { el, setChildren } from "redom";

const a = el("h1", "foo");
const b = el("h2", "bar");
const c = el("h3", "baz");

setChildren(document.body, [a, b, c]);</pre>
<p>然后，我们按照与数组中相同的顺序添加元素。</p>
<p>我们也可以用类创建RE:DOM组件。这让我们可以设置生命周期方法，在组件生命周期的不同阶段运行代码。例如，我们可以写:</p>
<pre>import { el, mount } from "redom";

class Hello {
  constructor() {
    this.el = el("h1", "Hello world");
  }
  onmount() {
    console.log("mounted Hello");
  }
  onremount() {
    console.log("remounted Hello");
  }
  onunmount() {
    console.log("unmounted Hello");
  }
}

class App {
  constructor() {
    this.el = el("app", (this.hello = new Hello()));
  }
  onmount() {
    console.log("mounted App");
  }
  onremount() {
    console.log("remounted App");
  }
  onunmount() {
    console.log("unmounted App");
  }
}

const app = new App();

mount(document.body, app);</pre>
<p>上面，我们有一个嵌套在<code>App</code>组件中的<code>Hello</code>组件。为了进行嵌套，我们创建了它的一个新实例，并将其作为第二个参数传递给<code>el</code>。</p>
<p>总的来说，Svelte有更多的选择来创建组件，因为它是一个应用程序开发框架。回复:DOM的局限性更大，因为它应该被用作DOM操作库。</p>
<h2>更新组件</h2>
<h3>苗条的</h3>
<p>在Svelte中，我们可以用各种方式更新组件。</p>
<p>我们更新了<code>script</code>标签中的变量，新的值将被自动呈现。例如:</p>
<pre>//Button.svelte

&lt;script&gt;
    let count = 0;

    function handleClick() {
      count += 1;
    }
&lt;/script&gt;

&lt;style&gt;
    button {
      background: #ff3e00;
      color: white;
      border: none;
      padding: 8px 12px;
      border-radius: 2px;
    }
&lt;/style&gt;

&lt;button on:click={handleClick}&gt;
  Clicked {count} {count === 1 ? 'time' : 'times'}
&lt;/button&gt;</pre>
<p>如果我们单击该按钮，那么<code>handleClick</code>功能将运行，这将使<code>count</code>增加1。<code>count</code>的最新值将会呈现在模板中。我们只是显示它，我们也用它来渲染别的东西，从表达式可以看出。</p>
<p>我们还可以用Svelte添加样式绑定。例如，我们可以写:</p>
<pre>&lt;script&gt;
    let size = 42;
    let text = "edit me";
&lt;/script&gt;


&lt;input type=range bind:value={size}&gt;

&lt;div&gt;
    &lt;span style="font-size: {size}px"&gt;{text}&lt;/span&gt;
&lt;/div&gt;</pre>
<p>我们有一个范围滑块，它绑定到<code>size</code>变量。所以，当我们改变滑块值时，<code>size</code>值也会随之改变。</p>
<p>在<code>span</code>元素中，我们使用<code>size</code>值来改变<code>font-size</code>样式。因此，滑块会改变<strong>编辑我</strong>文本的大小。</p>
<p>它还带有一个设置类的特殊语法。</p>
<p>例如，我们可以写:</p>
<pre>&lt;script&gt;
 let active = true;
&lt;/script&gt;

&lt;style&gt;
  .active {
    background-color: red;
  }
&lt;/style&gt;

&lt;div&gt;
  &lt;div
    class="{active ? 'active' : ''}"
    on:click="{() =&gt; active = !active}"
  &gt;
    toggle
  &lt;/div&gt;
&lt;/div&gt;</pre>
<p>当我们点击按钮时，我们通过在<code>true</code>和<code>false</code>之间切换<code>active</code>变量来打开和关闭<code>active</code>类。</p>
<p>我们也可以写类似这样的东西来做同样的事情:</p>
<pre>&lt;script&gt;
 let active = true;
&lt;/script&gt;

&lt;style&gt;
  .active {
    background-color: red;
  }
&lt;/style&gt;

&lt;div&gt;
  &lt;div
    class:active='{active}'
    on:click="{() =&gt; active = !active}"
  &gt;
    toggle
  &lt;/div&gt;
&lt;/div&gt;</pre>
<p>我们有一个表达式来决定<code>active</code>类是否应用了<code>class:active</code>属性。</p>
<h3>回复:DOM</h3>
<p>使用RE:DOM，更新组件会受到更多限制。我们可以设置元素的属性或者样式。例如，我们可以编写这样的代码来创建一个<code>h1</code>元素，并将其颜色设置为红色:</p>
<pre>import { el, setAttr, mount } from "redom";

const hello = el("h1", "Hello world!");

setAttr(hello, {
  style: { color: "red" },
  className: "hello"
});

mount(document.body, hello);</pre>
<p><code>setAttr</code>函数有两个参数:第一个是我们创建的元素，第二个是对象，键是属性名，值是属性值。</p>
<p>RE:DOM还附带了一个<code>setStyle</code>方法，让我们设置元素的样式。例如，我们可以这样使用它:</p>
<pre>import { el, setStyle, mount } from "redom";

const hello = el("h1", "Hello world!");

setStyle(hello, { color: "green" });

mount(document.body, hello);</pre>
<p>这会将<code>h1</code>元素设置为绿色。</p>
<p>这些是更新组件的主要方式。</p><div class="code-block code-block-54">
<hr/>
<h3>更多来自LogRocket的精彩文章:</h3>

<hr/></div>
<h2>开发者体验</h2>
<p>Svelte是一个完整的app开发框架，而RE:DOM是一个用于DOM操作的库。它们都使得操作DOM变得容易。</p>
<p>苗条让我们有表现力地编写代码，消除样板文件。为了快速创建一个苗条的项目，我们必须克隆<a href="https://github.com/sveltejs/template">苗条模板repo </a>，这不是非常方便。</p>
<p>另一方面，使用RE:DOM，我们只需安装带有<code>npm i redom</code>的<code>redom</code>包。</p>
<p>我们也可以使用https://redom.js.org/redom.min.js的脚本将其添加到我们的应用程序中。这意味着我们不需要构建工具来将RE:DOM添加到我们的应用程序项目中。</p>
<p>这两个工具都支持最新的JavaScript语法。因为RE:DOM是一个库，它没有一个CLI程序让我们创建应用程序。另一方面，没有CLI程序从头开始创建一个苗条的项目并构建它，这不是很方便。</p>
<h2>表演</h2>
<p>根据很多测试，RE:DOM比Svelte快。从<a href="https://medium.com/@ajmeyghani/javascript-frameworks-performance-comparison-c566d19ab65b"> AJ Meyghani的基准</a>可以看出，Svelte在很多方面都比RE:DOM慢。这在<a href="https://krausest.github.io/js-framework-benchmark/current.html">最近的基准</a>中也有类似的表现。</p>
<p>然而，这种差异只有几毫秒，在大多数情况下可能不太明显。值得重申的是，RE:DOM是一个轻量级的库，而Svelte是一个完整的app开发框架，所以这是有意义的。</p>
<h2>按指定路线发送</h2>
<p>RE:DOM自带路由器，用于将URL映射到要呈现的组件，而Svelte没有自带路由器。</p>
<h3>苗条的</h3>
<p>要将路由添加到我们的瘦应用程序中，我们需要通过运行以下命令来安装<code>svelte-routing</code>包:</p>
<pre>npm i svelte-routing</pre>
<p>然后，我们写道:</p>
<pre>//routes/About.svelte

&lt;p&gt;about&lt;/p&gt;</pre>
<pre>//routes/Blog.svelte

&lt;p&gt;blog&lt;/p&gt;</pre>
<pre>//routes/BlogPost.svelte

&lt;script&gt;
  export let id;
&lt;/script&gt;

&lt;p&gt;blog post {id}&lt;/p&gt;</pre>
<pre>//routes/Home.svelte

&lt;p&gt;home&lt;/p&gt;</pre>
<pre>//App.svelte

&lt;script&gt;
  import { Router, Link, Route } from "svelte-routing";
  import Home from "./routes/Home.svelte";
  import About from "./routes/About.svelte";
  import Blog from "./routes/Blog.svelte";
  import BlogPost from "./routes/BlogPost.svelte";

  export let url = "";
&lt;/script&gt;

&lt;Router url="{url}"&gt;
  &lt;nav&gt;
    &lt;Link to="/"&gt;Home&lt;/Link&gt;
    &lt;Link to="about"&gt;About&lt;/Link&gt;
    &lt;Link to="blog"&gt;Blog&lt;/Link&gt;
    &lt;Link to="blog/1"&gt;Blog Post&lt;/Link&gt;
  &lt;/nav&gt;
  &lt;div&gt;
    &lt;Route path="blog/:id" let:params&gt;
      &lt;BlogPost id="{params.id}" /&gt;
    &lt;/Route&gt;
    &lt;Route path="blog" component="{Blog}" /&gt;
    &lt;Route path="about" component="{About}" /&gt;
    &lt;Route path="/"&gt;&lt;Home /&gt;&lt;/Route&gt;
  &lt;/div&gt;
&lt;/Router&gt;</pre>
<p>我们添加<code>Router</code>组件来添加路由器，<code>Route</code>添加路由。</p>
<p>我们传递带有<code>let:params</code>属性和<code>id</code>属性的URL参数来接受<code>id</code> URL参数。</p>
<p><code>:id</code>是URL参数占位符。如果有什么参数，我们可以把它们作为道具获取，就像我们在<code>BlogPost.svelte</code>中做的那样。如果变量声明前面有<code>export</code>关键字，那么它就是一个道具。</p>
<h3>回复:DOM</h3>
<p>要使用RE:DOM的路由器，我们可以编写:</p>
<pre>//index.js

import { el, router, mount } from "redom";

class Home {
  constructor() {
    this.el = el("h1");
  }
  update(data) {
    this.el.textContent = `Hello ${data}`;
  }
}

class About {
  constructor() {
    this.el = el("about");
  }
  update(data) {
    this.el.textContent = `About ${data}`;
  }
}

class Contact {
  constructor() {
    this.el = el("contact");
  }
  update(data) {
    this.el.textContent = `Contact ${data}`;
  }
}

const app = router(".app", {
  home: Home,
  about: About,
  contact: Contact
});

mount(document.body, app);

const data = "world";

app.update("home", data);
app.update("about", data);
app.update("contact", data);</pre>
<p>我们通过使用<code>router</code>功能创建路线。</p>
<p>对象中的键是路由的URL。前往我们想要的路线。我们将从<code>update</code>方法的参数中获得的<code>data</code>传递给路由。</p>
<p>总的来说，RE:DOM的路由器肯定不如Svelte的灵活。</p>
<h2>结论</h2>
<p>RE:DOM是一个轻量级的DOM操作库。尽管我们可以用它来创建组件，但对于创建复杂的组件来说，它的表达能力不是很强。因此，我们应该坚持用它来操纵DOM。</p>
<p>另一方面，Svelte是一个完整的应用程序框架，只要我们将<code>svelte-routing</code>包添加到其中进行路由。</p><div class="code-block code-block-28">
<div class="blog-plug inline-plug js-libraries-plug"><h2>您是否添加了新的JS库来提高性能或构建新特性？如果他们反其道而行之呢？</h2><p>毫无疑问，前端变得越来越复杂。当您向应用程序添加新的JavaScript库和其他依赖项时，您将需要更多的可见性，以确保您的用户不会遇到未知的问题。</p>
<p>LogRocket 是一个前端应用程序监控解决方案，可以让您回放JavaScript错误，就像它们发生在您自己的浏览器中一样，这样您就可以更有效地对错误做出反应。</p><a class="signup" href="https://lp.logrocket.com/blg/javascript-signup" target="_blank" rel="noopener noreferrer"><img class="alignnone size-full wp-image-46 jetpack-lazy-image" src="../Images/e8a0ab42befa3b3b1ae08c1439527dc6.png" alt="LogRocket Dashboard Free Trial Banner" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2019/10/errors-screenshot.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/10/errors-screenshot.png"/><noscript><img data-lazy-fallback="1" class="alignnone size-full wp-image-46" src="../Images/e8a0ab42befa3b3b1ae08c1439527dc6.png" alt="LogRocket Dashboard Free Trial Banner" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/10/errors-screenshot.png"/></noscript></a>
<a href="https://lp.logrocket.com/blg/javascript-signup" target="_blank" rel="noopener noreferrer">https://logrocket.com/signup/</a><p><a href="https://lp.logrocket.com/blg/javascript-signup" target="_blank" rel="noopener noreferrer"> LogRocket </a>可以与任何应用程序完美配合，不管是什么框架，并且有插件可以记录来自Redux、Vuex和@ngrx/store的额外上下文。您可以汇总并报告问题发生时应用程序的状态，而不是猜测问题发生的原因。LogRocket还可以监控应用的性能，报告客户端CPU负载、客户端内存使用等指标。</p><p>自信地构建— <a class="signup" href="https://lp.logrocket.com/blg/javascript-signup" target="_blank" rel="noopener noreferrer">开始免费监控</a>。</p></div>


</div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
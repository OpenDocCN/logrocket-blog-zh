<html>
<head>
<title>What’s new in Laravel 8 - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>Laravel 8 - LogRocket博客中的新内容</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/whats-new-in-laravel-8/#0001-01-01">https://blog.logrocket.com/whats-new-in-laravel-8/#0001-01-01</a></blockquote><div><article class="article-post">
<p><a href="https://laravel.com/docs/8.x/releases" target="_blank" rel="noopener noreferrer"> Laravel 8发布</a>2020年9月8日。此版本延续了上一版本(版本7)中的改进，以及新功能，包括对Jetstream、作业批处理、动态刀片组件、模型工厂类、改进的artisan serve和许多其他功能的支持。</p>
<p>在这篇文章中，我们将看看这个新版本中引入的13个新特性，如下所示:</p>
<ul>
<li>拉勒维尔急流</li>
<li>模型目录</li>
<li>模型工厂类</li>
<li>迁移挤压</li>
<li>作业批处理</li>
<li>改进的速率限制</li>
<li>改进的维护模式</li>
<li>关闭派单/连锁</li>
<li>动态刀片组件</li>
<li>时间测试助手</li>
<li>工匠服务改进</li>
<li>顺风分页视图</li>
<li>路由命名空间更新</li>
</ul>
<h2>拉勒维尔急流</h2>
<p>Laravel Jetstream是一个制作精美的应用程序，用于搭建Laravel应用程序。使用Tailwind CSS设计的Jetstream为新项目提供了一个完美的起点，它具有身份验证、配置文件管理、安全性和使用<a href="https://github.com/laravel/sanctum" target="_blank" rel="noopener noreferrer"> Laravel Sanctum </a>的API支持等功能。</p>
<p><img data-attachment-id="27021" data-permalink="https://blog.logrocket.com/whats-new-in-laravel-8/attachment/laraveljetstream/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/10/laraveljetstream.png" data-orig-size="730,550" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="laraveljetstream" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/10/laraveljetstream-300x226.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/10/laraveljetstream.png" decoding="async" class="aligncenter size-full wp-image-27021 jetpack-lazy-image" src="../Images/b104fc633ec83acff594dcd7f7426233.png" alt="Laravel Jetstream page" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2020/10/laraveljetstream.png 730w, https://blog.logrocket.com/wp-content/uploads/2020/10/laraveljetstream-300x226.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2020/10/laraveljetstream.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/10/laraveljetstream.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="27021" data-permalink="https://blog.logrocket.com/whats-new-in-laravel-8/attachment/laraveljetstream/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/10/laraveljetstream.png" data-orig-size="730,550" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="laraveljetstream" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/10/laraveljetstream-300x226.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/10/laraveljetstream.png" decoding="async" loading="lazy" class="aligncenter size-full wp-image-27021" src="../Images/b104fc633ec83acff594dcd7f7426233.png" alt="Laravel Jetstream page" srcset="https://blog.logrocket.com/wp-content/uploads/2020/10/laraveljetstream.png 730w, https://blog.logrocket.com/wp-content/uploads/2020/10/laraveljetstream-300x226.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/10/laraveljetstream.png"/></noscript>
<p>此外，Jetstream为前端脚手架提供了两种选择，要么是<a href="https://jetstream.laravel.com/1.x/stacks/livewire.html" target="_blank" rel="noopener noreferrer"> Livewire </a>要么是<a href="https://jetstream.laravel.com/1.x/stacks/livewire.html" target="_blank" rel="noopener noreferrer">惯性</a>。</p>
<p><strong> Laravel Livewire — </strong>是一个库，它使得在Laravel上构建全栈应用成为可能，而不需要引入其他前端库/框架，如React和Vue.js。由于Livewire使用已经很熟悉的blend模板引擎，Laravel开发人员可以轻松构建动态界面，而无需离开Laravel的舒适环境。</p>
<p><strong> Inertia.js — </strong>是一个与Laravel Jetstream捆绑在一起的包，它让您可以使用Vue.js快速构建客户端模板。最酷的是，您可以享受Vue的全部功能，而没有前端路由的复杂性，因为您可以使用您熟悉的标准Laravel路由器。</p>
<p><strong> Jetstream安装— </strong>如果您安装了<a href="https://laravel.com/docs/installation#installing-laravel" target="_blank" rel="noopener noreferrer"> Laravel安装程序</a>，您可以通过添加<code>--jet</code>标志轻松安装Jetstream和您的Laravel安装程序，如下所示</p>
<pre>$ laravel new project-name --jet</pre>
<p>通过运行迁移来完成设置:</p>
<pre>$ php artisan migrate</pre>
<p>或者，您可以使用composer将Jetstream安装到新的Laravel应用程序中。通过composer安装Jetstream需要您运行<code>jetstream:install</code> artisan命令，该命令接受您首选的前端堆栈的名称，例如livewire或Inertia.js。这可以通过运行以下命令来完成:</p>
<pre>$ php artisan jetstream:install livewire

$ php artisan migrate

$ npm install &amp;&amp; npm run dev</pre>
<p>您可以访问<a href="https://jetstream.laravel.com/" target="_blank" rel="noopener noreferrer"> Jetstream官方文档</a>了解更多信息。</p>
<h2>模型目录</h2>
<p>一直有人建议Laravel应该将<code>Model</code>目录作为存储模型的默认目录。2016年，Taylor Otwell就此进行了一次民意调查，结果显示，更高比例的人想要一个默认的模型目录。四年后，人民的请求得到了批准。</p>
<blockquote class="embedly-card" data-card-controls="1" data-card-align="center" data-card-theme="light">

<p>Laravel应该有一个“模型”目录吗？</p>
</blockquote>
<p/>
<p>在Laravel的早期版本中，如果您在生成模型时没有指定路径，那么所有的模型文件都默认存储在<code>/app</code>目录中。然而，由于新的更新，Laravel现在默认包含了<code>app/Models</code>目录。</p>
<p>所以，当你运行<code>$ php artisan make:model ModelName</code>命令时，<code>ModelName.php</code>将被保存在<code>app/Models</code>中。然而，如果该目录不存在，Laravel将假设应用程序模型已经在<code>app/</code>目录中。</p>
<h2>模型工厂类</h2>
<p>雄辩的模型工厂让我们定义在测试我们的应用程序时用于生成虚假数据的模式。在以前的版本中，Laravel提供了一个<code>$factory</code>全局对象，我们可以扩展它来定义我们的工厂。从Laravel 8开始，工厂现在是基于类的，并且改进了对工厂之间关系的支持(例如，一个用户有许多帖子)。</p>
<p>先前定义的工厂如下所示:</p>
<pre>// database/factories/UserFactory.php

use Faker\Generator as Faker;
use Illuminate\Support\Str;

$factory-&gt;define(App\User::class, function (Faker $faker) {
    return [
        'name' =&gt; $faker-&gt;name,
        'email' =&gt; $faker-&gt;unique()-&gt;safeEmail,
        'email_verified_at' =&gt; now(),
        'password' =&gt; '$2y$10$92IXUNpkjO0rOQ5byMi.Ye4oKoEa3Ro9llC/.og/at2.uheWG/igi', // password
        'remember_token' =&gt; Str::random(10),
    ];
});</pre>
<p>然后，我们可以像这样使用定义的工厂:</p>
<pre>public function testDatabase()
{
    $user = factory(App\User::class)-&gt;make();

    // Use model in tests...
}</pre>
<p>从新版本开始，工厂现在将被定义为一个类，像这样:</p>
<pre>// database/factories/UserFactory.php

namespace Database\Factories;
use App\Models\User;
use Illuminate\Database\Eloquent\Factories\Factory;
use Illuminate\Support\Str;

class UserFactory extends Factory
    {
        /**
         * The name of the factory's corresponding model.
         *
         * @var string
         */
        protected $model = User::class;

        /**
         * Define the model's default state.
         *
         * @return array
         */
        public function definition()
        {
            return [
                'name' =&gt; $this-&gt;faker-&gt;name,
                'email' =&gt; $this-&gt;faker-&gt;unique()-&gt;safeEmail,
                'email_verified_at' =&gt; now(),
                'password' =&gt; '$2y$10$92IXUNpkjO0rOQ5byMi.Ye4oKoEa3Ro9llC/.og/at2.uheWG/igi', // password
                'remember_token' =&gt; Str::random(10),
            ];
        }
    }</pre>
<p>随着新的<code>HasFactory</code>特性在生成的模型上可用，模型工厂可以这样使用:</p>
<pre>use App\Models\User;
public function testDatabase()
{
    $user = User::factory()-&gt;make();
    // Use model in tests...
}</pre>
<h2>迁移挤压</h2>
<p>借助新的迁移压缩功能，您可以将大型迁移文件压缩到一个SQL文件中，告别臃肿的迁移文件夹。当您运行迁移时，将首先执行生成的文件，然后Laravel执行不属于压缩模式文件的任何其他迁移文件。您可以使用下面的artisan命令挤压迁移文件:</p>
<pre>$ php artisan schema:dump

// Dump the current database schema and prune all existing migrations...
$ php artisan schema:dump --prune</pre>
<p>当您运行这个命令时，Laravel会将一个模式文件写到您的<code>database/schema</code>目录中。</p>
<h2>作业批处理</h2>
<p>Laravel的新版本还提供了一个漂亮的特性，允许您调度一组并行执行的作业。要监控分组/批处理作业的进度，您可以使用<code>then</code>、<code>catch</code>和<code>finally</code>方法来定义完成回调，如下所示:</p>
<pre>use App\Jobs\ProcessPodcast;
use App\Podcast;
use Illuminate\Bus\Batch;
use Illuminate\Support\Facades\Batch;
use Throwable;

$batch = Bus::batch([
    new ProcessPodcast(Podcast::find(1)),
    new ProcessPodcast(Podcast::find(2)),
    new ProcessPodcast(Podcast::find(3)),
    new ProcessPodcast(Podcast::find(4)),
    new ProcessPodcast(Podcast::find(5)),
])-&gt;then(function (Batch $batch) {
    // All jobs completed successfully...
})-&gt;catch(function (Batch $batch, Throwable $e) {
    // First batch job failure detected...
})-&gt;finally(function (Batch $batch) {
    // The batch has finished executing...
})-&gt;dispatch();

return $batch-&gt;id;</pre>
<p>您可以查看Laravel文档来了解更多关于新的<a href="https://laravel.com/docs/8.x/queues#job-batching" target="_blank" rel="noopener noreferrer"> job </a>批处理特性的信息。</p>
<h2>改进的速率限制</h2>
<p>有了新改进的速率限制，您现在可以使用<code>RateLimiter</code> facade做更多的事情，例如动态限制请求。首先，让我们看看在以前的版本中是如何处理请求节流的。</p>
<p>在Laravel 7中，为了限制API请求，您需要编辑<code>app/Http</code>文件夹中的<code>Kernel.php</code>文件:</p>
<pre>// app/Http/Kernel.php
...

protected $middlewareGroups = [
    'web' =&gt; [
        \App\Http\Middleware\EncryptCookies::class,
        \Illuminate\Cookie\Middleware\AddQueuedCookiesToResponse::class,
        \Illuminate\Session\Middleware\StartSession::class,
        \Illuminate\View\Middleware\ShareErrorsFromSession::class,
        \App\Http\Middleware\VerifyCsrfToken::class,
        \Illuminate\Routing\Middleware\SubstituteBindings::class,
    ],
    'api' =&gt; [
        'throttle:60,1', // Here the API request limit is set to 60 request per minute
        \Illuminate\Routing\Middleware\SubstituteBindings::class,
    ],
];

...</pre>
<p>在Laravel 8中，上面的配置现在看起来像这样:</p>
<pre>// app/Http/Kernel.php
...
protected $middlewareGroups = [
        'web' =&gt; [
            \App\Http\Middleware\EncryptCookies::class,
            \Illuminate\Cookie\Middleware\AddQueuedCookiesToResponse::class,
            \Illuminate\Session\Middleware\StartSession::class,
            // \Illuminate\Session\Middleware\AuthenticateSession::class,
            \Illuminate\View\Middleware\ShareErrorsFromSession::class,
            \App\Http\Middleware\VerifyCsrfToken::class,
            \Illuminate\Routing\Middleware\SubstituteBindings::class,
        ],
        'api' =&gt; [
            'throttle:api', // Request limit is now defined in RouteServiceProvider
            \Illuminate\Routing\Middleware\SubstituteBindings::class,
        ],
    ];
...</pre>
<p>API请求限制现在在<code>app/Providers/</code>目录的<code>RouteServiceProvider.php</code>中定义。让我们看看如何:</p>
<pre>// app/Providers/RouteServiceProvider.php
use Illuminate\Cache\RateLimiting\Limit;
use Illuminate\Support\Facades\RateLimiter;
...
public function boot()
{
    $this-&gt;configureRateLimiting();
    ...
}
// Configure the rate limiters for the application.
protected function configureRateLimiting()
{
    RateLimiter::for('api', function (Request $request) {
    return Limit::perMinute(60); // 60 Request per minute
    });
}</pre>
<p>在<code>boot</code>方法中，<code>configureRateLimiting()</code>被调用。顾名思义，它拥有速率限制的配置。</p>
<p>使用<code>RateLimiter</code> facade的<code>for</code>方法定义速率限制器。<code>for</code>方法接受两个参数，一个速率限制器名称(即<code>api</code>)和一个闭包，后者返回限制配置，该配置应该只应用于分配了该速率限制器的路由。</p>
<p>如您所见，<code>for</code>方法接受HTTP请求实例，让我们完全控制动态限制请求。</p>
<p>假设我们希望为未经身份验证的用户设置每分钟十个请求的限制，为经过身份验证的用户设置无限制的请求限制。我们会这样做:</p>
<pre>// app/Providers/RouteServiceProvider.php

protected function configureRateLimiting()
{
    ...
    RateLimiter::for('guest', function (Request $request) {
    return $request-&gt;user()
                ? Limit:none()
                : Limit::perMinute(10); // 10 Request per minute
    });
}</pre>
<p>也可以使用中间件将配置的速率直接应用于路由，如下所示:</p>
<pre>// routes/api.php
...
Route::get('posts', '<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="6e3e011d1a2d01001a1c0102020b1c2e1d1a011c0b">[email protected]</a>')-&gt;middleware('throttle:guest');
...</pre>
<p>你可以在<a href="https://laravel.com/docs/8.x/routing#rate-limiting" target="_blank" rel="noopener noreferrer"> Laravel路由文档</a>中了解更多关于速率限制的信息。</p>
<h2>改进的维护模式</h2>
<p>在以前的Laravel版本中，可以通过设置允许访问应用程序的白名单IP地址列表来绕过维护模式，该功能已被删除，取而代之的是<code>secret/token</code>。让我们看看这是如何工作的:</p>
<p>将应用程序设置为维护模式时，您现在可以指定用于访问网站的密码，如下所示:</p>
<pre>$ php artisan down --secret="my-secret"</pre>
<p>当应用程序处于维护模式时，您可以通过如下方式指定您的密码来访问它:</p>
<blockquote class="embedly-card" data-card-controls="1" data-card-align="center" data-card-theme="light">

<p>此高级域名可供购买！该域名由Saw.com代理出售，该公司是网上领先的精品域名经纪公司。为Your-Website.Com的最佳保证价格在这里询问想要一个价格吗？致电+1 (781) 281-9475</p>
</blockquote>
<p/>
<p>然后，Laravel用关键字<code>laravel_maintenance</code>在你的浏览器中设置一个cookie，用来检查访问者是否可以访问。</p>
<h2>维护预渲染</h2>
<p>维护模式的另一个改进是能够预呈现您选择的维护视图。在Laravel的以前版本中，当应用程序停机维护时，更新运行<code>composer install</code>的依赖项很可能会让您的访问者得到一个实际的服务器错误。</p>
<p>这是因为Laravel的大部分必须启动，以便检查应用程序是否在维护中。通过允许您指定一个将在请求周期开始时返回的视图，维护预呈现变得非常方便。然后，在加载应用程序的任何依赖项之前，呈现这个视图。</p>
<p>您可以使用<code>artisan down</code>命令的<code>--render</code>选项预渲染一个默认视图，如下所示:</p>
<pre>$ php artisan serve
// Starting Laravel development server: http://127.0.0.1:8000
...

$ php artisan down --render="errors::503"
// Application is now in maintenance mode.</pre>
<p>运行上述命令将显示如下屏幕:<br/> <img data-attachment-id="27042" data-permalink="https://blog.logrocket.com/whats-new-in-laravel-8/attachment/503error/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/10/503error.png" data-orig-size="730,466" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="503error" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/10/503error-300x192.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/10/503error.png" decoding="async" class="aligncenter size-full wp-image-27042 jetpack-lazy-image" src="../Images/e8e4431a9365685a4777269817da08be.png" alt="503 service error" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2020/10/503error.png 730w, https://blog.logrocket.com/wp-content/uploads/2020/10/503error-300x192.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2020/10/503error.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/10/503error.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="27042" data-permalink="https://blog.logrocket.com/whats-new-in-laravel-8/attachment/503error/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/10/503error.png" data-orig-size="730,466" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="503error" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/10/503error-300x192.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/10/503error.png" decoding="async" loading="lazy" class="aligncenter size-full wp-image-27042" src="../Images/e8e4431a9365685a4777269817da08be.png" alt="503 service error" srcset="https://blog.logrocket.com/wp-content/uploads/2020/10/503error.png 730w, https://blog.logrocket.com/wp-content/uploads/2020/10/503error-300x192.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/10/503error.png"/></noscript>
<h2>关闭派单/连锁</h2>
<p>使用新的<code>catch</code>方法，您现在可以提供一个闭包，如果一个排队的闭包在用尽所有配置的队列后未能成功完成，就应该执行这个闭包，并重试它的尝试，如下所示:</p>
<pre>use Throwable;

dispatch(function () use ($podcast) {
    $podcast-&gt;publish();
})-&gt;catch(function (Throwable $e) {
    // This job has failed...
});</pre>
<h2>动态刀片组件</h2>
<p>有些情况下，您可能希望呈现一个依赖于运行时在视图中执行的操作的组件。使用动态刀片组件，您可以通过将组件名称作为变量传递来呈现组件，如下所示:</p>
<pre>&lt;x-dynamic-component :component="$componentName" class="mt-4" /&gt;</pre>
<h2>时间测试助手</h2>
<p>受Ruby on Rails的启发，通过<a href="https://carbon.nesbot.com/docs/" target="_blank" rel="noopener noreferrer"> carbon PHP库</a>进行的时间修改在测试时的旅行方面更进了一步。</p>
<p>编写测试用例时，可能偶尔需要修改<code>now</code>或<code>Illuminate\Support\Carbon::now()</code>等帮助器返回的时间。Laravel的基本特性测试类现在包括帮助器方法，允许您像这样操作当前时间:</p>
<pre>public function testTimeCanBeManipulated()
{
    // Travel into the future...
    $this-&gt;travel(5)-&gt;milliseconds();
    $this-&gt;travel(5)-&gt;seconds();
    $this-&gt;travel(5)-&gt;minutes();
    $this-&gt;travel(5)-&gt;hours();
    $this-&gt;travel(5)-&gt;days();
    $this-&gt;travel(5)-&gt;weeks();
    $this-&gt;travel(5)-&gt;years();

    // Travel into the past...
    $this-&gt;travel(-5)-&gt;hours();

    // Travel to an explicit time...
    $this-&gt;travelTo(now()-&gt;subHours(6));

    // Return back to the present time...
    $this-&gt;travelBack();
}</pre>
<h2>工匠服务改进</h2>
<p>在Laravel的早期版本中，当您使用<code>php artisan serve</code>命令启动应用程序时，修改<code>.env</code>需要您手动重启应用程序。由于新版本，修改<code>.env</code>将自动重新加载应用程序，所以你不必手动重启你的应用程序。</p>
<h2>顺风分页视图</h2>
<p>Laravel的分页器已经更新为默认使用<a href="https://tailwindcss.com/" target="_blank" rel="noopener noreferrer"> Tailwind CSS框架</a>。同时仍然支持引导数据库3和4。</p>
<p>要将分页视图配置为使用Bootstrap而不是默认的Tailwind，可以在您的<code>AppServiceProvider</code>中调用分页器<code>useBootstrap</code>方法:</p>
<pre>// app/Providers/AppServiceProvider.php

...
use Illuminate\Pagination\Paginator;
...
public function boot()
{
    Paginator::useBootstrap();
    ...
}</pre>
<h2>路由命名空间更新</h2>
<p>在以前的Laravel版本中，<code>RouteServiceProvider</code>包含一个<code>$namespace</code>属性，该属性会自动添加到控制器路由定义和对动作助手<code>URL::action</code>方法的调用中。</p>
<pre>// app/Providers/RouteServiceProvider.php

...

class RouteServiceProvider extends ServiceProvider
{
    protected $namespace = 'App\Http\Controllers';

    ...

}</pre>
<p>这个默认值允许您定义一个路由控制器，如下所示:</p>
<pre>// routes/web.php
...
Route::post('login', '<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="b3e6c0d6c1f0dcddc7c1dcdfdfd6c1f3dfdcd4dadd">[email protected]</a>')
...</pre>
<p>在Laravel 8中，<code>$namespace</code>属性默认为null，这意味着Laravel不会自动添加名称空间前缀。应该使用标准的PHP可调用语法来定义控制器路由定义，如下所示:</p>
<pre>// routes/web.php

use App\Http\Controllers\UserController;

Route::post('/login', [UserController::class, 'login']);</pre>
<p>如果您喜欢以前的版本风格，您必须在<code>RouteServiceProvider</code>中指定您的控制器名称空间。</p>
<h2>结论</h2>
<p>在本文中，我们研究了Laravel 8的新特性。要将您当前的应用程序升级到版本8，您可以查看<a href="https://laravel.com/docs/8.x/upgrade" target="_blank" rel="noopener noreferrer">升级指南</a>以及<a href="https://laravel.com/docs/8.x/releases" target="_blank" rel="noopener noreferrer">发行说明</a>。</p><div class="code-block code-block-2">
<div class="blog-plug base-cta"><h2>使用<a class="signup" href="https://lp.logrocket.com/blg/signup" target="_blank" rel="noopener noreferrer"> LogRocket </a>消除传统错误报告的干扰</h2>
<a href="https://lp.logrocket.com/blg/signup" class="signup" target="_blank" rel="noopener noreferrer"><img class="alignnone size-full wp-image-46 jetpack-lazy-image" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/><noscript><img data-lazy-fallback="1" class="alignnone size-full wp-image-46" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/></noscript></a>
<p><a href="https://lp.logrocket.com/blg/signup" target="_blank" rel="noopener noreferrer"> LogRocket </a>是一个数字体验分析解决方案，它可以保护您免受数百个假阳性错误警报的影响，只针对几个真正重要的项目。LogRocket会告诉您应用程序中实际影响用户的最具影响力的bug和UX问题。</p>
<p>然后，使用具有深层技术遥测的会话重放来确切地查看用户看到了什么以及是什么导致了问题，就像你在他们身后看一样。</p>
<p>LogRocket自动聚合客户端错误、JS异常、前端性能指标和用户交互。然后LogRocket使用机器学习来告诉你哪些问题正在影响大多数用户，并提供你需要修复它的上下文。</p>
<p>关注重要的bug—<a class="signup" href="https://lp.logrocket.com/blg/signup-issue-free" target="_blank" rel="noopener noreferrer">今天就试试LogRocket】。</a></p></div></div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
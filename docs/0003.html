<html>
<head>
<title>Make React Fast Again [Part 2]: why-did-you-update - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>再次快速反应[第2部分]:你为什么更新日志博客</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/make-react-fast-again-part-2-why-did-you-update-dd1faf79399f/#0001-01-01">https://blog.logrocket.com/make-react-fast-again-part-2-why-did-you-update-dd1faf79399f/#0001-01-01</a></blockquote><div><article class="article-post">
<figure><img decoding="async" src="../Images/3f81f4726fb793459f3e4c2c4bafac87.png" data-height="1275" data-width="4854" data-lazy-src="https://storage.googleapis.com/blog-images-backup/1*mJFYp7LKVzZM3PPjFb0QXQ.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" class=" jetpack-lazy-image" data-original-src="https://storage.googleapis.com/blog-images-backup/1*mJFYp7LKVzZM3PPjFb0QXQ.png"/><noscript><img data-lazy-fallback="1" decoding="async" src="../Images/3f81f4726fb793459f3e4c2c4bafac87.png" data-height="1275" data-width="4854" data-original-src="https://storage.googleapis.com/blog-images-backup/1*mJFYp7LKVzZM3PPjFb0QXQ.png"/></noscript></figure>
<p>React通常非常快，但是很容易犯小错误，导致性能问题。缓慢的组件安装、深度的组件树和不必要的渲染周期很快会让应用程序感觉很慢。</p>
<p>幸运的是，有很多工具可以帮助诊断性能问题，有些工具甚至是内置的。在本系列中，我们将重点介绍让React应用程序快速运行的工具和技术。每个帖子还会有一个互动的，有趣的演示！</p>
<hr/>
<h3>问题:不必要的渲染周期</h3>
<p>影响React性能的最常见问题之一是不必要的渲染周期。默认情况下，无论父组件何时渲染，React组件都会重新渲染，即使它们的道具没有改变。</p>
<p>例如，如果我有这样一个简单的组件:</p>
<pre>class DumbComponent extends Component {
  render() {
    return  {this.props.value} ;
  }
}</pre>
<p>有这样一个父组件:</p>
<pre>class Parent extends Component {
  render() {
    return 
      
    ;
  }
}</pre>
<p>每当父组件渲染时，<code>DumbComponent</code>将重新渲染，尽管其属性没有改变。</p>
<p>一般来说，如果<code>render</code>运行，并且虚拟DOM没有变化，这是一个浪费的渲染周期，因为<code>render</code>方法应该是纯的，没有任何副作用。在大规模的React应用程序中，检测发生这种情况的位置可能很棘手，但幸运的是，有一个工具可以提供帮助！</p>
<h3>为什么更新？</h3>
<figure><img decoding="async" src="../Images/990ee141ff4ae7af9b9efe347c983d87.png" data-height="372" data-width="1368" data-lazy-src="https://storage.googleapis.com/blog-images-backup/1*Lb4nr_WLwnLt63jUoszrnQ.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" class=" jetpack-lazy-image" data-original-src="https://storage.googleapis.com/blog-images-backup/1*Lb4nr_WLwnLt63jUoszrnQ.png"/><noscript><img data-lazy-fallback="1" decoding="async" src="../Images/990ee141ff4ae7af9b9efe347c983d87.png" data-height="372" data-width="1368" data-original-src="https://storage.googleapis.com/blog-images-backup/1*Lb4nr_WLwnLt63jUoszrnQ.png"/></noscript></figure>
<p>是一个连接React并检测潜在不必要的组件渲染的库。它检测组件的<code>render</code>方法何时被调用，尽管它的属性没有改变。</p>
<h4>设置</h4>
<ol>
<li>使用npm安装:<code>npm i --save-dev why-did-you-update</code></li>
<li>将此片段添加到您的应用中的任意位置:</li>
</ol>
<pre>import React from 'react'
if (process.env.NODE_ENV !== 'production') {
  const {whyDidYouUpdate} = require('why-did-you-update')
  whyDidYouUpdate(React)
}</pre>
<p><strong>请注意</strong>该工具在本地开发中非常有用，但请确保在生产中禁用它，因为它会降低应用程序的速度。</p>
<h4>了解输出</h4>
<p><code>why-did-you-update</code>在应用运行时监控应用，并记录可能发生不必要更改的组件。它可以让你在一个渲染周期之前和之后看到它认为可能是不必要的道具。</p>
<h3>修复不必要的渲染</h3>
<p>一旦你发现应用程序中有不必要的重复渲染的组件，有一些简单的修复方法。</p>
<h4>使用纯组件</h4>
<p>在上面的例子中，<code>DumbComponent</code>是其道具的纯函数。即组件只需要在其道具发生变化时重新渲染即可。React内置了一种特殊类型的组件，称为<code>PureComponent</code>,正是为了这个用例。</p>
<p>而不是从React继承。组件，使用React。像这样的纯组件:</p>
<pre>class DumbComponent extends PureComponent {
  render() {
    return  {this.props.value} ;
  }
}</pre>
<p>然后，组件只会在它的道具实际改变时重新渲染。就是这样！</p>
<p>注意<code>PureComponent</code>做了一个肤浅的道具比较，所以如果你使用复杂的数据结构，它可能会错过一些道具变化，不会更新你的组件。</p>
<h4>实现shouldComponentUpdate</h4>
<p><code>shouldComponentUpdate</code>是当<code>props</code>或<code>state</code>发生变化时，在<code>render</code>之前调用的组件方法。如果<code>shouldComponentUpdate</code>返回true，将调用<code>render</code>，如果返回false，则不执行任何操作。</p>
<p>通过实现这个方法，您可以指示React避免重新渲染一个给定的组件，如果它的属性没有改变的话。</p>
<p>例如，我们可以在上面的哑组件中实现<code>shouldComponentUpdate</code>,如下所示:</p>
<pre>class DumbComponent extends Component {
  shouldComponentUpdate(nextProps) {
    if (this.props.value !== nextProps.value) {
      return true;
    } else {
      return false;
    }
  }

render() {
    return foo;
  }
}</pre>
<h3>演示！</h3>
<p>为了演示<code>why-did-you-update</code>，我在Code Sandbox上的TodoMVC应用程序中安装了这个库，Code Sandbox是一个在线React游乐场。打开浏览器控制台，添加一些TODOs来查看输出。</p>
<p><a href="https://codesandbox.io/s/xGJP4QExn" target="_blank" rel="noopener noreferrer">https://codesandbox.io/s/xGJP4QExn</a></p>
<p>请注意，应用程序中的一些组件进行了不必要的渲染。尝试实现上述技术，以防止不必要的渲染。如果操作正确，控制台中应该没有来自<code>why-did-you-update</code>的输出。</p>
<h3>调试生产中的性能问题</h3>
<p><code>why-did-you-update</code>只在本地开发工作。如果你有兴趣了解你的生产应用中的性能问题，试试<a href="https://logrocket.com" target="_blank" rel="noopener noreferrer"> LogRocket </a>。</p>
<figure class="wp-caption"><a href="https://logrocket.com/signup/" target="_blank" rel="noopener noreferrer"><img decoding="async" src="../Images/7f9cc7da85477f88dd33827526df86b4.png" data-height="2004" data-width="3552" data-lazy-src="https://storage.googleapis.com/blog-images-backup/1*s_rMyo6NbrAsP-XtvBaXFg.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" class=" jetpack-lazy-image" data-original-src="https://storage.googleapis.com/blog-images-backup/1*s_rMyo6NbrAsP-XtvBaXFg.png"/><noscript><img data-lazy-fallback="1" decoding="async" src="../Images/7f9cc7da85477f88dd33827526df86b4.png" data-height="2004" data-width="3552" data-original-src="https://storage.googleapis.com/blog-images-backup/1*s_rMyo6NbrAsP-XtvBaXFg.png"/></noscript></a><figcaption class="wp-caption-text"><a href="https://logrocket.com/signup/" target="_blank" rel="noopener noreferrer">https://logrocket.com/signup/</a></figcaption></figure>
<p>LogRocket 就像是网络应用的DVR，记录下<em>字面上的</em> <em>发生在你网站上的一切</em>。您可以重放有错误或性能问题的会话，以快速了解根本原因，而不是猜测问题发生的原因。</p>
<p>LogRocket让你的应用程序记录性能计时、Redux动作/状态、日志、错误、带有头+主体的网络请求/响应以及浏览器元数据。它还记录页面上的HTML和CSS，甚至可以重建最复杂的单页面应用程序的像素级完美视频。</p>
<blockquote class="embedly-card" data-card-controls="1" data-card-align="center" data-card-theme="light">

<p>LogRocket帮助您了解影响用户的问题，以便您可以重新开始构建优秀的软件。</p>
</blockquote>
<p>结论</p>
<h3><code>why-did-you-update</code>是一个方便的工具，用于检测潜在的不必要的组件重新渲染，帮助您使您的应用程序执行得更好。</h3>
<p>因为<code>why-did-you-update</code>只在开发中工作，所以请查看<a href="https://logrocket.com" target="_blank" rel="noopener noreferrer">日志火箭</a>，以诊断生产中的错误和性能问题。</p>
<p>要了解更多React性能技巧，请查看本系列的第1部分和第3部分:</p>
<p><a href="https://blog.logrocket.com/make-react-fast-again-part-1-performance-timeline-f7f39f676f58/">再次快速反应【第1部分】:性能时间表</a></p>
<blockquote class="wp-embedded-content" data-secret="9pmjuYBhNO"><p><a href="https://blog.logrocket.com/make-react-fast-again-part-1-performance-timeline-f7f39f676f58/">Make React Fast Again [Part 1]: Performance Timeline</a></p></blockquote>
<p><a href="https://blog.logrocket.com/make-react-fast-again-part-3-highlighting-component-updates-6119e45e6833/">再次快速反应【第3部分】:突出显示组件更新</a></p>
<blockquote class="wp-embedded-content" data-secret="Cnc9DHiXnr"><p><a href="https://blog.logrocket.com/make-react-fast-again-part-3-highlighting-component-updates-6119e45e6833/">Make React Fast Again [Part 3]: Highlighting Component Updates</a></p></blockquote>
<p/>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
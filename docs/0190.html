<html>
<head>
<title>Building size-aware React components - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>构建大小敏感的React组件</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/building-size-aware-react-components-b4c37e7d96e7/#0001-01-01">https://blog.logrocket.com/building-size-aware-react-components-b4c37e7d96e7/#0001-01-01</a></blockquote><div><div class="mainheading">



<h1 class="posttitle">构建感知大小的React组件</h1>
<h2 class="post-subtitle"/>
<p><span class="post-date"><time class="post-date">2017年6月27日</time> </span> <span class="dot"/> <span class="readingtime"> 2分钟阅读</span> <span class="wordcount"> 639 </span> <span class="logrocket_editor"/></p>
</div>
<article class="article-post">
<figure><img decoding="async" src="../Images/3bb18ca8dcd0d0a3dcb12bd9d110fd47.png" data-height="1110" data-width="4854" data-lazy-src="https://storage.googleapis.com/blog-images-backup/1*blZzZqBE4_FOVkFSDJKDig.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" class=" jetpack-lazy-image" data-original-src="https://storage.googleapis.com/blog-images-backup/1*blZzZqBE4_FOVkFSDJKDig.png"/><noscript><img data-lazy-fallback="1" decoding="async" src="../Images/3bb18ca8dcd0d0a3dcb12bd9d110fd47.png" data-height="1110" data-width="4854" data-original-src="https://storage.googleapis.com/blog-images-backup/1*blZzZqBE4_FOVkFSDJKDig.png"/></noscript></figure>
<p>当构建React应用程序时，组件知道它们在屏幕上的大小和位置有时是有利的。这对于最初呈现内容很有用，对于需要知道其大小何时改变的组件也很有用。这方面的一些例子有:</p>
<ul>
<li>需要根据大小对内容进行不同布局的组件。例如，从1列变为2列的响应式布局，或者在宽度受限时切换到汉堡包的下拉式菜单。</li>
<li>当使用HTML5画布时，每当其大小改变时都必须重新绘制</li>
<li>当构建用户可以调整不同窗格大小的布局时</li>
<li>当使用需要已知大小的元素或第三方库时，如react-virtualized、固定数据表等。</li>
<li>当呈现具有绝对定位的元素时，需要在容器大小改变时调整其位置。</li>
<li>当用CSS动画显示元素的大小时，附加逻辑依赖于这个动画的大小</li>
</ul>
<p>其中一些行为可以通过CSS实现，或者通过用<code>onResize</code>事件管理窗口大小来实现，但是为了构建可最大程度重用的React组件，将这个逻辑封装到组件本身是有意义的。这样，无论组件在哪里/如何使用，它都将正确运行。</p>
<p>幸运的是，有一些优秀的库可以帮助解决这个问题。在这里，我将对每一个进行简单介绍，并说明何时使用它。</p>
<h3>反应-测量</h3>
<p>react-measure是一个有用的库，用于构建大小感知组件。它包装一个组件并公开一个用元素的contentRect(有边界和位置)调用的<code>onResize</code>函数。每当组件的大小或位置发生变化时，都会调用此方法，它可用于触发副作用或使维度进入状态。</p>
<figure><img decoding="async" src="../Images/ea4d4b989b9cff130c3270db62917a38.png" data-height="454" data-width="1078" data-lazy-src="https://storage.googleapis.com/blog-images-backup/1*Wf_cRemzOXQCzjj3XCOWLg.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" class=" jetpack-lazy-image" data-original-src="https://storage.googleapis.com/blog-images-backup/1*Wf_cRemzOXQCzjj3XCOWLg.png"/><noscript><img data-lazy-fallback="1" decoding="async" src="../Images/ea4d4b989b9cff130c3270db62917a38.png" data-height="454" data-width="1078" data-original-src="https://storage.googleapis.com/blog-images-backup/1*Wf_cRemzOXQCzjj3XCOWLg.png"/></noscript></figure>
<p>这解决了大多数早期的例子，但是有一个问题——一个<em>鸡和蛋的问题</em>。当组件第一次呈现时，它的尺寸并不总是已知的，因为它的宽度/高度可能由其内容决定。因此，我们并不总是知道<code>render</code>函数中的维度，所以组件基于其维度来呈现逻辑是不完全可能的。</p>
<h3>react-sizeme</h3>
<figure><img decoding="async" src="../Images/3de507865ad115428de6ed0f7c08ddbd.png" data-height="100" data-width="500" data-lazy-src="https://storage.googleapis.com/blog-images-backup/1*B7JssTBhegmG78diNO2lIQ.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" class=" jetpack-lazy-image" data-original-src="https://storage.googleapis.com/blog-images-backup/1*B7JssTBhegmG78diNO2lIQ.png"/><noscript><img data-lazy-fallback="1" decoding="async" src="../Images/3de507865ad115428de6ed0f7c08ddbd.png" data-height="100" data-width="500" data-original-src="https://storage.googleapis.com/blog-images-backup/1*B7JssTBhegmG78diNO2lIQ.png"/></noscript></figure>
<p>为了解决这个问题，我们求助于一个名为<code>react-sizeme</code>的库。这个库类似于<code>react-measure</code>，但是使用了一个聪明的解决方案来解决前面提到的问题。</p>
<p>对组件进行初始的、不可见的渲染，以测量其大小。它是以一种轻量级的方式来实现的，没有完全渲染组件那么强烈。然后，当组件呈现时，大小是已知的，并且组件可以从头开始正确呈现。因此，组件可以基于自己的维度拥有<code>render</code>逻辑！</p>
<p>使用<code>react-sizeme</code>看起来像这样:</p>
<figure><img decoding="async" src="../Images/1b070ec9e7cec52c7f0e920409ad9140.png" data-height="458" data-width="1202" data-lazy-src="https://storage.googleapis.com/blog-images-backup/1*hKHkRR-37lukmNPMJVuFBA.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" class=" jetpack-lazy-image" data-original-src="https://storage.googleapis.com/blog-images-backup/1*hKHkRR-37lukmNPMJVuFBA.png"/><noscript><img data-lazy-fallback="1" decoding="async" src="../Images/1b070ec9e7cec52c7f0e920409ad9140.png" data-height="458" data-width="1202" data-original-src="https://storage.googleapis.com/blog-images-backup/1*hKHkRR-37lukmNPMJVuFBA.png"/></noscript></figure>
<h3>警告</h3>
<p>对于这两个库，有一些需要注意的地方。<code>react-sizeme</code>决定组件尺寸的初始渲染不是免费的，并且确实增加了渲染组件的可见性时间。对于只挂载一次的组件来说，这通常是不明显的，但是对于挂载多次的组件(例如，虚拟列表中的项目)，会有明显的性能影响。因为<code>react-measure</code>不做这个初始渲染，它应该在这些情况下被理想地使用。</p>
<p>两个库用来检测大小变化的方法也有轻微的延迟(大约20毫秒)。通常这感觉起来很快，但在实践中，我注意到在检测变化时会有轻微的延迟，这会导致组件感觉很慢。</p>
<p>一般来说，<code>react-measure</code>对性能的影响较小，所以如果可能的话应该使用它，但是如果组件的初始渲染依赖于它的大小，那么<code>react-sizeme</code>是一个好的选择。</p>
<h3>资源</h3>
<blockquote class="embedly-card" data-card-controls="1" data-card-align="center" data-card-theme="light">

<p>计算反应组分测量值。使用ResizeObserver来检测元素的尺寸何时发生了变化。在不支持的浏览器中包含一个用于ResizeObserver的polyfill。yarn add react-measure NPM install react-measure–save Wrap任何子组件并计算其客户端rect。将以下内容添加到子函数中返回的contentRect.client。</p>
</blockquote>
<p/>
<blockquote class="embedly-card" data-card-controls="1" data-card-align="center" data-card-theme="light">

<p>让您的React组件知道它们的宽度和/或高度！超灵敏元件！表演。好用。广泛的浏览器支持。支持函数和类组件类型。小捆尺寸。演示:<a href="https://4mkpc.csb.app/" rel="nofollow">https://4mkpc.csb.app/</a>通过渲染道具模式使用它(支持子元素或渲染道具):或者，通过一个更高级的组件:让你的组件能够根据它们的高度和/或宽度来渲染逻辑。</p>
</blockquote>
<p/>
<p> </p><div class="code-block code-block-17">
<div class="blog-plug inline-plug react-plug" vwo-el-id="26283398190">
<h2 vwo-el-id="41600691720"><a href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener"> LogRocket </a>:全面了解您的生产React应用</h2><p>调试React应用程序可能很困难，尤其是当用户遇到难以重现的问题时。如果您对监视和跟踪Redux状态、自动显示JavaScript错误以及跟踪缓慢的网络请求和组件加载时间感兴趣，</p><a href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" vwo-el-id="19356441070">try LogRocket</a><p>. </p><a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="19356441380">
<img class="first-react-image alignnone size-full wp-image-46 jetpack-lazy-image jetpack-lazy-image--handled" src="../Images/f300c244a1a1cf916df8b4cb02bec6c6.png" vwo-el-id="18272717540" data-lazy-loaded="1" data-original-src="https://files.readme.io/27c94e7-Image_2017-06-05_at_9.46.04_PM.png"/>
</a>
<a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="19356441690">
<img class="second-react-image alignnone size-full wp-image-46 jetpack-lazy-image jetpack-lazy-image--handled" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" vwo-el-id="30720362350" data-lazy-loaded="1" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/>
</a>
<p vwo-el-id="28675660440" class="">LogRocket 结合了会话回放、产品分析和错误跟踪，使软件团队能够创建理想的web和移动产品体验。这对你来说意味着什么？</p>
<p>LogRocket不是猜测错误发生的原因，也不是要求用户提供截图和日志转储，而是让您回放问题，就像它们发生在您自己的浏览器中一样，以快速了解哪里出错了。</p>
<p>不再有嘈杂的警报。智能错误跟踪允许您对问题进行分类，然后从中学习。获得有影响的用户问题的通知，而不是误报。警报越少，有用的信号越多。</p>
<p vwo-el-id="28675660750">LogRocket Redux中间件包为您的用户会话增加了一层额外的可见性。LogRocket记录Redux存储中的所有操作和状态。</p>
<p vwo-el-id="28675661060">现代化您调试React应用的方式— <a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="40093418840">开始免费监控</a>。</p>
</div></div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
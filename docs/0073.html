<html>
<head>
<title>Using WebSockets for two-way communication in React apps - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>在React apps - LogRocket博客中使用WebSockets进行双向通信</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/websockets-two-way-communication-react-app/#0001-01-01">https://blog.logrocket.com/websockets-two-way-communication-react-app/#0001-01-01</a></blockquote><div><article class="article-post">
<p><em> <strong>编者按:</strong>本文于2022年4月10日更新，以确保代码块与React 18一致，并保持与Socket IO v4.x相关的依赖关系最新</em></p>
<p>REST是web APIs无可争议的冠军。它抛弃了旧的SOAP及其冗长的XML，转而支持JSON而不是HTTP。REST也有基于资源和动词的复杂概念模型。</p>
<p>但是，REST并不是所有基于网络的交流问题的完美解决方案。开发人员竭尽全力，试图将所有的通信和数据交换需求融入RESTful模式。</p>
<p>如今，现代软件开发团队倾向于在传统的RESTful模式上使用WebSockets、GraphQL、gRPC和HTTP/2来开发他们的web服务通信。Web开发人员经常选择WebSockets来构建现代实时web应用程序。</p>
<p>这篇文章是关于WebSockets的。您将了解到:</p>

<p>我们的演示将让您构建一个很酷的客户端-服务器游戏Connect4，Node在后端，React+SVG在前端，服务器和客户端之间的所有通信都通过WebSockets运行。</p>
<h2 id="what-are-web-sockets">什么是WebSockets？</h2>
<p>WebSockets是一种基于连接的通信协议，支持全双工实时通信。</p>
<p>你会问，这有什么大不了的？为了满足这种需求，我们从一开始就有了TCP。</p>
<p>的确如此，但TCP是一种低级通信协议，不能作为web API在浏览器中供web开发人员使用。</p>
<p>每个现代的web浏览器都支持WebSockets，每个流行的后端语言都有WebSocket服务器库，作为第三方模块或标准库模块。在WebSockets出现之前，您只能在web浏览器中执行HTTP请求-响应操作。</p>
<p>然而，WebSockets是基于消息的——这意味着你发送一条消息，另一端接收一条消息。WebSockets是在TCP之上实现的，但是原始TCP是基于流的。你发送一串字节(八位字节),另一端必须找出如何累积它们，并把它们分解成连贯的消息。WebSockets帮你做到了，对开发者帮助很大。</p>
<p>让我们看下图，了解WebSocket客户端和服务器全双工通信通道是如何形成的:</p>
<p><img data-attachment-id="105224" data-permalink="https://blog.logrocket.com/websockets-two-way-communication-react-app/websocket-communication-initialization-http/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2018/05/websocket-communication-initialization-http.png" data-orig-size="573,414" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="websocket-communication-initialization-http" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2018/05/websocket-communication-initialization-http-300x217.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2018/05/websocket-communication-initialization-http.png" decoding="async" class="aligncenter wp-image-105224 size-full jetpack-lazy-image" src="../Images/8a6f861533b061593c5b5be02674068b.png" alt="Websocket Communication Initialization HTTP" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2018/05/websocket-communication-initialization-http.png 573w, https://blog.logrocket.com/wp-content/uploads/2018/05/websocket-communication-initialization-http-300x217.png 300w" data-lazy-sizes="(max-width: 573px) 100vw, 573px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2018/05/websocket-communication-initialization-http.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2018/05/websocket-communication-initialization-http.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="105224" data-permalink="https://blog.logrocket.com/websockets-two-way-communication-react-app/websocket-communication-initialization-http/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2018/05/websocket-communication-initialization-http.png" data-orig-size="573,414" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="websocket-communication-initialization-http" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2018/05/websocket-communication-initialization-http-300x217.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2018/05/websocket-communication-initialization-http.png" decoding="async" loading="lazy" class="aligncenter wp-image-105224 size-full" src="../Images/8a6f861533b061593c5b5be02674068b.png" alt="Websocket Communication Initialization HTTP" srcset="https://blog.logrocket.com/wp-content/uploads/2018/05/websocket-communication-initialization-http.png 573w, https://blog.logrocket.com/wp-content/uploads/2018/05/websocket-communication-initialization-http-300x217.png 300w" sizes="(max-width: 573px) 100vw, 573px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2018/05/websocket-communication-initialization-http.png"/></noscript>
<p>如上图所示，客户端首先倾向于通过发送HTTP请求来初始化与服务器的WebSocket连接。</p>
<p>接下来，服务器通过回复一个HTTP响应来初始化WebSocket连接，从而完成WebSocket握手。</p>
<p>一旦建立了连接，客户端和服务器都可以使用WebSocket协议消息异步地相互发送消息。</p>
<h2 id="how-are-web-sockets-useful">WebSockets有什么用？</h2>
<p>当服务器想要推送大量数据和/或频繁更新浏览器时(想想多人游戏或聊天服务)，WebSockets真的很有用。传统的RESTful模式是一种基于同步请求-响应的机制，不适合全双工实时场景。请看下面RESTful方法和WebSockets之间的比较:</p>
<p><img data-attachment-id="105212" data-permalink="https://blog.logrocket.com/websockets-two-way-communication-react-app/rest-websockets-table-comparison/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2018/05/rest-websockets-table-comparison.png" data-orig-size="730,328" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="rest-websockets-table-comparison" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2018/05/rest-websockets-table-comparison-300x135.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2018/05/rest-websockets-table-comparison.png" decoding="async" class="aligncenter wp-image-105212 size-full jetpack-lazy-image" src="../Images/5681d40d8a4710f1b8bd28bf630868f0.png" alt="Rest Websockets Table Comparison" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2018/05/rest-websockets-table-comparison.png 730w, https://blog.logrocket.com/wp-content/uploads/2018/05/rest-websockets-table-comparison-300x135.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2018/05/rest-websockets-table-comparison.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2018/05/rest-websockets-table-comparison.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="105212" data-permalink="https://blog.logrocket.com/websockets-two-way-communication-react-app/rest-websockets-table-comparison/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2018/05/rest-websockets-table-comparison.png" data-orig-size="730,328" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="rest-websockets-table-comparison" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2018/05/rest-websockets-table-comparison-300x135.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2018/05/rest-websockets-table-comparison.png" decoding="async" loading="lazy" class="aligncenter wp-image-105212 size-full" src="../Images/5681d40d8a4710f1b8bd28bf630868f0.png" alt="Rest Websockets Table Comparison" srcset="https://blog.logrocket.com/wp-content/uploads/2018/05/rest-websockets-table-comparison.png 730w, https://blog.logrocket.com/wp-content/uploads/2018/05/rest-websockets-table-comparison-300x135.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2018/05/rest-websockets-table-comparison.png"/></noscript>
<p>考虑一个游戏，其中一个玩家执行的每个操作都必须尽快传达给其他玩家。</p>
<p>如果你试图用REST来实现它，你可能会求助于一些轮询机制，所有玩家不断地用更新请求轰炸服务器。</p>
<p>这个场景有几个问题:</p>
<ul>
<li>服务器必须处理大量的请求，即使它没有什么新的东西要报告</li>
<li>如果玩家变得更好并且不经常投票，滞后将会存在并增长</li>
<li>服务器必须保持最近的状态，直到所有玩家都得到通知，并想出一个解决方案来与客户端协调版本控制</li>
<li>如果一个客户机掉线，服务器没有好的方法知道它</li>
</ul>
<p>有了WebSockets，所有这些问题都迎刃而解了——服务器处于控制之中，它确切地知道每次有多少客户端被连接。</p>
<p>当有值得做的事情发生时，它可以立即更新所有连接的客户端，并且HTTP轮询机制没有延迟。一旦通知了所有客户端，服务器就不需要保持状态，此外，如果客户端断开连接，服务器会立即得到通知。</p>
<h2 id="building-a-connect4-style-demo-app-with-web-sockets">使用WebSockets构建Connect4风格的演示应用程序</h2>
<p>聊天服务是WebSockets的杀手级应用。如果浏览器中没有WebSockets，逐字符更新甚至仅仅是消息:“X正在输入…”是不可能的。</p>
<p>让我们构建一个Connect4游戏来演示WebSockets是如何工作的。</p><div class="code-block code-block-54">
<hr/>
<h3>更多来自LogRocket的精彩文章:</h3>

<hr/></div>
<p>将会有一个管理游戏状态的服务器和两个互相对战的玩家。服务器负责管理棋盘，确保玩家只进行有效的移动，告诉每个玩家何时轮到他们，检查胜利条件，并通知玩家。</p>
<p>客户端是一个基于React的应用程序。它显示来自服务器的公告板和消息。当服务器发送更新的公告板或消息时，客户端更新其状态，React负责更新显示。</p>
<p>当轮到玩家时，客户端还负责响应板上的点击，并通知服务器。</p>
<p>(注:Connect4游戏根本没有优化。每次都发送整个板，而不只是更改，即使可以组合，我也发送多个消息。这是有意的——我这样做是为了展示WebSockets是多么简单和用户友好。代码非常简单易读，唯一有点复杂的方面是检查胜利，它在服务器端有自己的功能)</p>
<p>它看起来是这样的:</p>
<p><img data-attachment-id="105214" data-permalink="https://blog.logrocket.com/websockets-two-way-communication-react-app/connect-four-game-preview/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2018/05/connect-four-game-preview.gif" data-orig-size="730,410" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="connect-four-game-preview" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2018/05/connect-four-game-preview-300x168.gif" data-large-file="https://blog.logrocket.com/wp-content/uploads/2018/05/connect-four-game-preview.gif" decoding="async" class="aligncenter wp-image-105214 size-full jetpack-lazy-image" src="../Images/a6c854c91eed1b8a81f5f38803af3088.png" alt="Connect Four Game Preview" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2018/05/connect-four-game-preview.gif?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2018/05/connect-four-game-preview.gif"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="105214" data-permalink="https://blog.logrocket.com/websockets-two-way-communication-react-app/connect-four-game-preview/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2018/05/connect-four-game-preview.gif" data-orig-size="730,410" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="connect-four-game-preview" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2018/05/connect-four-game-preview-300x168.gif" data-large-file="https://blog.logrocket.com/wp-content/uploads/2018/05/connect-four-game-preview.gif" decoding="async" loading="lazy" class="aligncenter wp-image-105214 size-full" src="../Images/a6c854c91eed1b8a81f5f38803af3088.png" alt="Connect Four Game Preview" data-original-src="https://blog.logrocket.com/wp-content/uploads/2018/05/connect-four-game-preview.gif"/></noscript>
<h2 id="project-structure">项目结构</h2>
<p>在我们深入研究代码之前，让我们快速找到它并检查它的结构。</p>
<p>服务器和客户端的代码都可以在<a href="https://github.com/codezri/connect4-websockets" target="_blank" rel="noopener">这个</a> GitHub仓库中找到。在您的工作目录中克隆GitHub存储库，用您最喜欢的代码编辑器打开它，开始检查源代码。</p>
<p>您会注意到，整个服务器都在一个文件中，即<a href="https://github.com/codezri/connect4-websockets/blob/master/server.js" target="_blank" rel="noopener"> server.js </a>，而客户端是使用<a href="https://blog.logrocket.com/tag/create-react-app" target="_blank" rel="noopener"> Create React App (CRA) </a>创建的，它创建了自己的目录结构。我把所有的东西都移到了客户端子目录中，以隔离前端代码和后端代码。</p>
<p>有两个自述文件。</p>
<p>README.md是一个简洁的文件，对该应用程序及其使用方法进行了简短描述。</p>
<p>README2.md是由CRA生成的文件，其中包含了许多关于使用CRA启动项目的好处的信息。</p>
<p>现在，安装依赖项并运行以下命令来启动游戏:</p>
<pre class="language-bash hljs">npm run dev
# or
yarn dev
</pre>
<p>上面的命令在开发模式下启动服务器和客户端。在两个浏览器窗口中同时打开游戏，并尝试玩游戏。</p>
<p>让我们深入源代码，研究每个模块。</p>
<h2 id="building-the-connect4-server">构建Connect4服务器</h2>
<p>服务器是一个Node.js应用程序，它使用<a href="https://socket.io/" target="_blank" rel="noopener"> socket.io </a>作为WebSockets服务器。启动所需要的只是一个监听端口1337的WebSockets服务器:</p>
<pre class="language-javascript hljs">const { createServer } = require('http')
const { Server } = require('socket.io')

const httpServer = createServer()
const io = new Server(httpServer, {
  cors: {
    origin: '*'
  }
})
.
.
.
reset()
const port = 1337
httpServer.listen(port)
console.log('Listening on port ' + port + '...')
</pre>
<p>服务器超级简单；它一次只能运行一个游戏。游戏状态包括游戏板、两个玩家以及当前玩家是谁。</p>
<p>该板是一个6×8的2D阵列，其中所有单元最初都是白色的。我选择将玩家表示为一个具有两个属性的对象，<code>red</code>和<code>yellow</code>。这里不需要映射，因为键是字符串，我不需要迭代它们。每个玩家的值是他们的WebSocket连接引用，最初为空。</p>
<pre class="language-javascript hljs">let board = null
const players = {'red': null, 'yellow': null}
let player = 'red'

function reset() {
  board = Array(6).fill(0).map(x =&gt; Array(8).fill('white'))
  players['red'] = null
  players['yellow'] = null
  player = 'red'
}
</pre>
<p>为什么保留一个<code>players</code>对象而不是两个变量？字符串<code>red</code>和<code>yellow</code>始终用于在服务器和客户端之间来回传递重要信息。</p>
<p>在服务器端，一切都发生在<code>io.on('connection', function(socket) {...}</code>内部。每当有新的客户端连接到服务器时，都会调用这个回调函数。</p>
<p>然后，服务器为各种事件和消息注册回调，我将很快介绍这一点。但是首先，服务器将套接字对象引用存储在<code>players</code>对象中。</p>
<p>第一个连接的客户端成为红色玩家；黄色是第二。服务器将断开任何进一步的连接尝试，以隔离当前的双人游戏会话。服务器也将发送给每个玩家他们的颜色和轮到谁了。</p>
<pre class="language-javascript hljs">if (players['red'] == null) {
    players['red'] = socket
    socket.emit('color', 'red')
  } else if (players['yellow'] == null) {
    players['yellow'] = socket
    socket.emit('color', 'yellow')
    io.emit('turn', 'red')
  } else {
    socket.disconnect()
  }
</pre>
<p>用于向客户端发送消息的<code>emit()</code>函数有两种风格:</p>
<ol>
<li><code>io.emit()</code>调用:这让服务器向所有连接的客户机广播相同的消息</li>
<li>调用:这将消息发送给一个特定的客户端</li>
</ol>
<p>这里要考虑的一个例子是，每个玩家需要得到不同的信息来知道他们的颜色，但是所有玩家需要得到相同的信息来告诉该轮到谁了。</p>
<p>然后，服务器继续为两个事件注册回调:<code>disconnect</code>和<code>click</code>。<code>disconnect</code>事件不是很有趣，只是把断开玩家的插座从玩家的物体上移除了。</p>
<h2 id="the-click-event"><code>click</code>事件</h2>
<p><code>click</code>事件是所有活动发生的地方。当活动玩家点击棋盘上的一列时，服务器接收到<code>click</code>事件并开始工作。首先，服务器验证点击是有效的。</p>
<p>在下列情况下，单击会被忽略:</p>
<ul>
<li>轻言放弃</li>
<li>点击全栏(第一名已被占据)</li>
<li>当只有一个玩家连接时点击(如果没有人连接，那么没有人可以<pre class="language-javascript hljs">click)socket.on('click', function (column) { // Ignore players clicking when it's not their turn if (players[player] !== socket) { return } // Ignore clicks on full columns if (board\[0\][column] !== 'white') {   return }  // Ignore clicks before both players are connected if ((players['red'] == null) || (players['yellow'] == null)) {   return } </pre></li>
</ul>
<p>一旦这一部分完成，服务器知道这是一个正确的点击，并继续处理它。然后，服务器在目标栏的顶部放置一个新棋子，并通过<code>board</code>消息将更新后的棋盘发送给所有玩家:</p>
<pre class="language-javascript hljs">// find first open spot in the column
    let row = -1
    for (row = 5; row &gt;= 0; --row) {
      if (board\[row\][column] === 'white') {
        board\[row\][column] = player
        break
      }
    }

io.emit('board', board)
</pre>
<p>现在，服务器需要检查当前玩家是否真的通过放置该棋子而获胜。它用当前放置棋子的位置调用<code>checkVictory()</code>函数，如果返回<code>true</code>，则表示当前玩家赢了。</p>
<p>然后服务器会用获胜玩家的颜色向两个玩家广播<code>victory</code>消息，断开两个玩家的连接，然后退出。</p>
<p>但是，如果玩家没有赢，玩家切换当前玩家，并用<code>turn</code>消息通知两个玩家。</p>
<pre class="language-javascript hljs">// Check victory (only current player can win)
    if (checkVictory(row, column)) {
      io.emit('victory', player)
      // Disconnect players
      players['red'].disconnect()
      players['yellow'].disconnect()
      reset()
      return
    }

// Toggle the player
    player = player === 'red' ? 'yellow' : 'red'
    io.emit('turn', player)
</pre>
<h2 id="checking-for-victory">检查胜利</h2>
<p>服务器最复杂的部分是胜利检查。这不是火箭科学，但是如果你不小心的话，你很容易错过一些关键案例。让我们稍微讨论一下，然后看看一些代码。</p>
<p>要赢得Connect4游戏，玩家必须将四个相邻的棋子水平、垂直或对角对齐。如果一个玩家在一个回合中获胜，那么刚刚放置的棋子必须是四个相邻棋子的一部分。</p>
<p>简单的方法是从最后放置的棋子开始，然后在八个方向中的每一个方向检查玩家颜色的另外三个相邻的棋子。</p>
<p>但是，您可能会忽略放置的棋子位于序列中间的情况，如下图所示:</p>
<p><img data-attachment-id="105216" data-permalink="https://blog.logrocket.com/websockets-two-way-communication-react-app/connect-four-middle-sequence-placed-piece/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2018/05/connect-four-middle-sequence-placed-piece.png" data-orig-size="680,602" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="connect-four-middle-sequence-placed-piece" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2018/05/connect-four-middle-sequence-placed-piece-300x266.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2018/05/connect-four-middle-sequence-placed-piece.png" decoding="async" class="aligncenter wp-image-105216 size-full jetpack-lazy-image" src="../Images/a714d9ad17a2849700a8a440400fc16d.png" alt="Connect Four Middle Sequence Placed Piece" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2018/05/connect-four-middle-sequence-placed-piece.png 680w, https://blog.logrocket.com/wp-content/uploads/2018/05/connect-four-middle-sequence-placed-piece-300x266.png 300w" data-lazy-sizes="(max-width: 680px) 100vw, 680px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2018/05/connect-four-middle-sequence-placed-piece.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2018/05/connect-four-middle-sequence-placed-piece.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="105216" data-permalink="https://blog.logrocket.com/websockets-two-way-communication-react-app/connect-four-middle-sequence-placed-piece/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2018/05/connect-four-middle-sequence-placed-piece.png" data-orig-size="680,602" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="connect-four-middle-sequence-placed-piece" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2018/05/connect-four-middle-sequence-placed-piece-300x266.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2018/05/connect-four-middle-sequence-placed-piece.png" decoding="async" loading="lazy" class="aligncenter wp-image-105216 size-full" src="../Images/a714d9ad17a2849700a8a440400fc16d.png" alt="Connect Four Middle Sequence Placed Piece" srcset="https://blog.logrocket.com/wp-content/uploads/2018/05/connect-four-middle-sequence-placed-piece.png 680w, https://blog.logrocket.com/wp-content/uploads/2018/05/connect-four-middle-sequence-placed-piece-300x266.png 300w" sizes="(max-width: 680px) 100vw, 680px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2018/05/connect-four-middle-sequence-placed-piece.png"/></noscript>
<p>所以，正确的检查方法是双向进行，用玩家的颜色数出棋子总数。例如，当检查水平方向时，我们检查左侧和右侧。</p>
<p>这意味着我们只需要检查四个方向:水平、垂直、从左上角到右下角的对角线，以及从左下角到右上角的对角线。我们还需要注意，不要超出我们的检查范围。以下是水平检查的部分代码:</p>
<pre class="language-javascript hljs">function checkVictory(i, j) {
  const c = board\[i\][j]

// Check horizontally
  let count = 0
  // count to the left
  for (let k = 1; k &lt; 4; ++k) {
    if (j - k &lt; 0) {
      break
    }
    if (board\[i\][j - k] !== c) {
      break
    }
    count++
  }
  // count to the right
  for (let k = 1; k &lt; 4; ++k) {
    if (j + k &gt; 7) {
      break
    }
    if (board\[i\][j + k] !== c) {
      break
    }
    count++
  }

if (count &gt; 2) {
    return true
  }
</pre>
<p>我们向左向右最多数三个地方，遇到任何不是当前玩家颜色的东西就破。最后，如果计数超过2，这意味着我们有一个4的序列，包括当前放置的棋子，这是一个胜利。</p>
<p>对垂直线和对角线的检查非常相似，除了索引稍有不同，在对角线的情况下，<code>i</code>和<code>j</code>都增加。</p>
<p>从<a href="https://github.com/codezri/connect4-websockets/blob/9f4874491aa7c94e2647e4ce634824f0c12c4f2e/server.js#L23" target="_blank" rel="noopener">这里</a>检查<code>checkVictory</code>功能的完整实现。</p>
<h2 id="websockets-and-solution-design">WebSockets和解决方案设计</h2>
<p>WebSockets很牛逼，但还是来说说基于WebSockets的解决方案设计吧。</p>
<p>客户端连接并向服务器发送<code>click</code>消息。服务器发送多条消息，如<code>board</code>、<code>color</code>和<code>turn</code>。</p>
<p>真的有必要将所有这些信息分开发送吗？不完全是。服务器可以发送包含所有内容的单个状态消息。</p>
<p>但是，如果您只发送一条消息，那么客户端代码将会更加复杂，因为它必须解析并找出发生了什么变化。</p>
<p><code>board</code>消息提供了另一个决策点。在我们的演示应用程序中，我发送了整个棋盘，但是我也可以很容易地只发送最近放置棋子的位置。</p>
<p>如果是这种情况，那么应用前端实现必须将板状态存储在存储器中，并在接收到关于新放置的块的消息时适当地更新它，而不是仅仅接收整个板。</p>
<p>我们的应用前端的电路板渲染逻辑现在很简单，因为我们用<code>board</code>消息发送整个电路板矩阵。我们可以用下面的一行代码呈现新的电路板状态:</p>
<pre class="language-jsx hljs">this.setState({...self.state, board: board})
</pre>
<p>此外，我们直接从服务器端发送<code>board</code>对象。但是，我们可以通过只发送更新后的电路板位置坐标来减少WebSocket消息的有效负载大小。但是，为了简单起见，我们将在本教程中发送整个电路板矩阵。</p>
<h2 id="building-the-connect4-client">构建Connect4客户端</h2>
<p>客户端是一个React应用程序，所有的动作都发生在<code>App</code>主组件中。它还有两个子组件:<code>Board</code>和<code>Infobar</code>。</p>
<h3><strong/><code>InfoBar</code><strong>componen</strong>T5】t</h3>
<p><code>InfoBar</code>是一个无状态的功能组件，以玩家的颜色显示信息。它有一些嵌入的样式，并从其父节点接收消息和颜色作为属性:</p>
<pre class="language-jsx hljs">import React from 'react'

const InfoBar = ({message, color}) =&gt; {
  let style = {color: color, 
               backgroundColor: 'black', 
               padding: '5px'};
  return &lt;p style={style}&gt;{message}&lt;/p&gt;
}

export default InfoBar
</pre>
<h3><strong/><code>Board</code><strong>分量</strong></h3>
<p>棋盘有趣多了。它必须处理点击，但它也是一个无状态的功能组件，对服务器或WebSockets一无所知。</p>
<p>它是如何工作的？</p>
<p>父组件<code>App</code>传递一个名为<code>onColumnClick</code>的回调函数作为道具——电路板只是用被点击的列调用这个回调函数。</p>
<p>关于棋盘的另一个很酷的事情是，它使用<a href="https://developer.mozilla.org/en-US/docs/Web/SVG" target="_blank" rel="noopener"> SVG </a>来呈现棋盘和棋子——而不是传统的DOM元素。此外，它还根据玩家的回合改变鼠标指针。</p>
<p>让我们一点一点地分解它，以获得关于棋盘组件的道具的详细信息。</p>
<p>董事会接受了父母的三点支持。<code>board</code>道具是6×8 2D阵列，您在构建服务器时已经很熟悉了。<code>onColumnClick</code>属性是当点击一列时调用的回调函数，<code>yourTurn</code>是处理当前鼠标光标的布尔值。</p>
<p>接下来，板为稍后将被填充的单元定义一个空数组，并根据<code>yourTurn</code>属性将鼠标光标设置为指针或不放。</p>
<pre class="language-jsx hljs">import React from 'react'

const Board = ({board, onColumnClick, yourTurn}) =&gt; {
  const cells = []
  const style = {cursor: yourTurn? 'pointer' : 'no-drop'}
</pre>
<p>这里，我们用电路板单元填充<code>cells</code>数组。每个单元格都是一个SVG组，有一个50×50像素的蓝色矩形，中间有一个圆。圆圈的颜色来自<code>board</code>道具，可以是红色、黄色或白色。</p>
<pre class="language-jsx hljs">for (let i = 0; i &lt; 6; ++i) {
  for (let j = 0; j &lt; 8; ++j) {
    let cell =  onColumnClick(j)} 
                style={style}&gt;



    cells.push(cell)
  }
}
</pre>
<p>最后，我们返回一个440×360 px的SVG元素，上面的单元格代表板子，后面是一个蓝色的梯形作为底部。</p>
<pre class="language-jsx hljs">return &lt;svg width={440} height={360}&gt;
          {cells}
          &lt;polygon points="20,300 0,360 440,360 420,300"
          fill={'blue'}/&gt;
       &lt;/svg&gt;
}
export default Board
</pre>
<h3><strong/><code>App</code><strong>分量</strong></h3>
<p><code>App</code>是主要部件。它负责渲染<code>InfoBar</code>和<code>board</code>组件，以及处理所有的通信。</p>
<p>它还使用了一点来自App.css的CSS，为了与服务器通信，它使用了提供<code>io()</code>函数的<a href="https://socket.io/docs/v4/" target="_blank" rel="noopener"> Socket.io库</a>。</p>
<pre class="language-jsx hljs">import React, {Component} from 'react'
import './App.css'
import InfoBar from './components/InfoBar'
import Board from './components/Board'
import { io } from 'socket.io-client'
</pre>
<p>构造函数设置状态，包括:</p>
<ul>
<li>   <ul>
<li>与服务器表示相同的板</li>
<li>总是显示在<code>InfoBar</code>中的信息</li>
<li><code>yourTurn</code>布尔</li>
</ul>
</li>
</ul>
<pre class="language-jsx hljs">class App extends Component {
  constructor(props) {
    super(props)

    this.state = {
      board: Array(6).fill(0).map(x =&gt; Array(8).fill('white')),
      message: 'Waiting for another player...',
      yourTurn: false
    }
</pre>
<p>构造函数的下一部分是所有通信发生的地方。首先，<code>this</code>指针被存储为闭包中的<code>self</code>变量。这是WebSockets访问组件状态所必需的。</p>
<p>然后，app构造函数为以下消息注册处理程序:</p>

<p>在每种情况下，构造函数都更新状态的相关部分。</p>
<p>(注意:处理程序是在构造函数中注册的，但是随着游戏的进行会被再次调用)</p>
<pre class="language-jsx hljs">let self = this

socket.on('board', board =&gt; {
  this.setState({...self.state, board: board})
});

socket.on('color', color =&gt; {
  this.setState({...self.state, color: color})
});

socket.on('turn', player =&gt; {
  if (player === this.state.color) {
    this.setState({...self.state, message: "You're up. What's your move?", yourTurn: true})
  } else {
    this.setState({...self.state, message: player + ' is thinking...', yourTurn: false})
  }
});

socket.on('victory', player =&gt; {
  let newState = {yourTurn: false}
  if (player === this.state.color) {
    newState['message'] = 'You win!'
  } else {
    newState['message'] = 'You lose!'
  }
  this.setState({...self.state, ...newState})
});
</pre>
<p>还记得当点击一列时，电路板接收到的调用函数<code>onColumnClick</code>吗？这是一个只向服务器发送一条<code>click</code>消息的单行程序。</p>
<pre class="language-jsx hljs">onColumnClick = column =&gt; socket.emit('click', column);
</pre>
<p><code>render()</code>函数非常简单。它呈现标题，然后是<code>InfoBar</code>，然后是棋盘，从状态中传递必要的属性。</p>
<pre class="language-jsx hljs">render() {
    return (
      &lt;div className="App"&gt;
        &lt;header className="App-header"&gt;
          &lt;h1 className="App-title"&gt;Connect Four&lt;/h1&gt;
        &lt;/header&gt;
        &lt;InfoBar color={this.state.color} 
                 message={this.state.message} /&gt;
        &lt;Board board={this.state.board} 
               onColumnClick={this.onColumnClick} 
               yourTurn={this.state.yourTurn}/&gt;
      &lt;/div&gt;
    )
  }
</pre>
<p>这是一个带有胜利之箭的插图:</p>
<p><img data-attachment-id="105218" data-permalink="https://blog.logrocket.com/websockets-two-way-communication-react-app/victory-state-demonstration/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2018/05/victory-state-demonstration.png" data-orig-size="725,635" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="victory-state-demonstration" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2018/05/victory-state-demonstration-300x263.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2018/05/victory-state-demonstration.png" decoding="async" class="aligncenter wp-image-105218 size-full jetpack-lazy-image" src="../Images/d40211d2a3e5c421d80deea3d63db079.png" alt="Victory State Demonstration" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2018/05/victory-state-demonstration.png 725w, https://blog.logrocket.com/wp-content/uploads/2018/05/victory-state-demonstration-300x263.png 300w" data-lazy-sizes="(max-width: 725px) 100vw, 725px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2018/05/victory-state-demonstration.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2018/05/victory-state-demonstration.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="105218" data-permalink="https://blog.logrocket.com/websockets-two-way-communication-react-app/victory-state-demonstration/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2018/05/victory-state-demonstration.png" data-orig-size="725,635" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="victory-state-demonstration" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2018/05/victory-state-demonstration-300x263.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2018/05/victory-state-demonstration.png" decoding="async" loading="lazy" class="aligncenter wp-image-105218 size-full" src="../Images/d40211d2a3e5c421d80deea3d63db079.png" alt="Victory State Demonstration" srcset="https://blog.logrocket.com/wp-content/uploads/2018/05/victory-state-demonstration.png 725w, https://blog.logrocket.com/wp-content/uploads/2018/05/victory-state-demonstration-300x263.png 300w" sizes="(max-width: 725px) 100vw, 725px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2018/05/victory-state-demonstration.png"/></noscript>
<h2 id="conclusion">结论</h2>
<p>WebSockets对于客户机-服务器应用程序来说是一项伟大的技术，在这种应用程序中，服务器需要向客户机发送消息、事件或通知，而不需要不断地被提示或轮询。</p>
<p>例如，我们可以使用WebSockets构建实时聊天应用程序、基于浏览器的在线多人游戏和监控工具。WebSocket有效负载比HTTP消息更轻量级，因此我们也可以使用web socket来构建实时web仪表板。</p>
<p>在这篇文章中，我们了解了使用WebSockets相对于REST的优势，并且我们通过一个节点服务器和React客户端的完整示例，这些客户端通过WebSockets进行通信，并一起实现了经典的Connect4游戏。作为奖励，我们使用SVG来渲染棋盘和棋子。</p>
<p>现在，是时候走出去，用WebSockets构建令人敬畏的东西了。</p><div class="code-block code-block-17">
<div class="blog-plug inline-plug react-plug" vwo-el-id="26283398190">
<h2 vwo-el-id="41600691720">使用LogRocket消除传统反应错误报告的噪音</h2>
<a href="https://lp.logrocket.com/blg/react-signup-issue-free" target="_blank" vwo-el-id="19356441070">LogRocket
</a><p>是一款React analytics解决方案，可保护您免受数百个误报错误警报的影响，只针对少数真正重要的项目。LogRocket告诉您React应用程序中实际影响用户的最具影响力的bug和UX问题。</p><a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="19356441380">
<img class="first-react-image alignnone size-full wp-image-46 jetpack-lazy-image jetpack-lazy-image--handled" src="../Images/f300c244a1a1cf916df8b4cb02bec6c6.png" vwo-el-id="18272717540" data-lazy-loaded="1" data-original-src="https://files.readme.io/27c94e7-Image_2017-06-05_at_9.46.04_PM.png"/>
</a>
<a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="19356441690">
<img class="second-react-image alignnone size-full wp-image-46 jetpack-lazy-image jetpack-lazy-image--handled" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" vwo-el-id="30720362350" data-lazy-loaded="1" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/>
</a>
<a href="https://lp.logrocket.com/blg/react-signup-issue-free" target="_blank" rel="noopener noreferrer" vwo-el-id="35866400580">LogRocket
</a><p>自动聚合客户端错误、反应错误边界、还原状态、缓慢的组件加载时间、JS异常、前端性能指标和用户交互。然后，LogRocket使用机器学习来通知您影响大多数用户的最具影响力的问题，并提供您修复它所需的上下文。</p><p vwo-el-id="28675661060">关注重要的React bug—<a class="signup" href="https://lp.logrocket.com/blg/react-signup-issue-free" target="_blank" rel="noopener noreferrer" vwo-el-id="40093418840">今天就试试LogRocket】。</a></p>
</div></div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
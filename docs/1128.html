<html>
<head>
<title>What’s new in Storybook 6 - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>故事书6中的新内容-日志火箭博客</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/whats-new-in-storybook-6/#0001-01-01">https://blog.logrocket.com/whats-new-in-storybook-6/#0001-01-01</a></blockquote><div><article class="article-post">
<p>Storybook是一组库，它允许我们创建组件，并通过向组件传递各种属性来预览它们。最近发布的故事书6包括了许多方便的新功能。事不宜迟，我们来看看新特性以及如何使用它们。</p>
<p> </p>
<h5 class="blog-button">在这里听我们的播客故事集。T3】</h5>
<p>零配置设置</p>
<h2>有了Storybook 6，我们可以轻松地构建一个故事书:我们所要做的就是在我们的项目上运行<code>npx sb init</code>,然后我们就可以添加故事书了。</h2>
<p>例如，如果我们想将Storybook添加到用create-react-app创建的React项目中，我们只需使用该命令。但是请注意，<code>npx sb init</code>只适用于现有的项目，不能用于空的项目文件夹。</p>
<p>因此，要在React项目中使用Storybook，我们首先运行:</p>
<p>这就创建了<code>storybook-project</code> React项目。然后，我们进入<code>storybook-project</code>文件夹，运行<code>npx sb init</code>向其中添加故事书。</p>
<pre>npx create-react-app storybook-project</pre>
<p>为了将现有的Storybook项目升级到最新版本，我们运行<code>npx sb upgrade</code>来安装它。然后我们运行<code>yarn add @storybook/addon-essentials --dev</code>来安装插件，这些插件呈现我们在组件预览下面看到的内容。</p>
<p>Storybook Essentials包有一些有用的插件，用于改变我们可以预览组件的视口。它还有一个插件，允许我们使用JSX或MDX代码记录我们的组件。(MDX是Markdown和JSX的混合体。)</p>
<p>其他插件包括:</p>
<p><strong>actions addon</strong>:让我们记录各种事件发出的事件对象，比如点击、鼠标悬停、键盘事件等。</p>
<ul>
<li>背景插件:让我们在预览组件时将背景设置为我们喜欢的颜色</li>
<li>工具栏插件:让我们根据自己的喜好定制故事书屏幕顶部的工具栏</li>
<li>Storybook 6还内置了TypeScript支持，因此我们可以立即使用TypeScript，无需额外配置。</li>
</ul>
<p>故事的参数</p>
<h2>在Storybook中，参数是我们传递到组件中来改变它的属性。这让我们可以为组件进行预设配置，以便我们可以预览它们。</h2>
<p>我们可以在故事文件中设置参数。例如，如果我们有一个React Storybook项目，我们可以如下创建我们的组件和故事:</p>
<p><code>Button.js</code>文件有组件文件，<code>button.css</code>有<code>Button</code>组件的样式。</p>
<pre>//src/stories/Button.js

import React from 'react';
import PropTypes from 'prop-types';
import './button.css';

export const Button = ({ primary, backgroundColor, size, label, ...props }) =&gt; {
  const mode = primary ? 'button-primary' : 'button-secondary';
  return (
    &lt;button
      type="button"
      className={['button', `button-${size}`, mode].join(' ')}
      style={backgroundColor &amp;&amp; { backgroundColor }}
      {...props}
    &gt;
      {label}
    &lt;/button&gt;
  );
};

Button.propTypes = {
  primary: PropTypes.bool,
  backgroundColor: PropTypes.string,
  size: PropTypes.oneOf(['small', 'medium', 'large']),
  label: PropTypes.string.isRequired,
  onClick: PropTypes.func,
};

Button.defaultProps = {
  backgroundColor: null,
  primary: false,
  size: 'medium',
  onClick: undefined,
};
</pre>
<pre>//src/stories/button.css

.button {
  font-weight: 700;
  border: 0;
  border-radius: 3em;
  cursor: pointer;
  display: inline-block;
  line-height: 1;
}
.button-primary {
  color: white;
  background-color: #1ea7fd;
}
.button-secondary {
  color: #333;
  background-color: transparent;
}
.button-small {
  font-size: 12px;
  padding: 10px;
}
.button-medium {
  font-size: 14px;
  padding: 11px;
}
.button-large {
  font-size: 16px;
  padding: 12px;
}</pre>
<pre>//src/stories/Button.stories.js

import React from 'react';

import { Button } from './Button';

export default {
  title: 'Example/Button',
  component: Button,
  argTypes: {
    backgroundColor: { control: 'color' },
  },
};

const Template = (args) =&gt; &lt;Button {...args} /&gt;;

export const Primary = Template.bind({});
Primary.args = {
  primary: true,
  label: 'Button',
};

export const Secondary = Template.bind({});
Secondary.args = {
  label: 'Button',
};

export const Large = Template.bind({});
Large.args = {
  size: 'large',
  label: 'Button',
};

export const Small = Template.bind({});
Small.args = {
  size: 'small',
  label: 'Button',
};</pre>
<p><code>Button</code>组件需要几个道具:</p>
<p>属性让我们可以设置类来以不同的方式设计按钮</p>
<ul>
<li><code>backgroundColor</code>设置背景颜色</li>
<li><code>size</code>设置尺寸</li>
<li><code>label</code>设置按钮文本</li>
<li>其余的道具被传递到<code>button</code>元素中。</li>
</ul>
<p>在此之下，我们添加了一些适当的类型验证，这样我们就可以正确地设置我们的参数，并让Storybook为这些参数选择控件。<code>primary</code>是一个布尔值，所以它将显示为一个复选框按钮。<code>backgroundColor</code>是字符串。</p>
<p><code>size</code>可以是三个值中的一个，所以Storybook会自动为它创建一个下拉列表，让我们选择值。<code>label</code>是一个字符串属性，所以它将显示为一个文本输入。输入控件位于组件预览下方故事书屏幕的<strong>控件</strong>选项卡中。</p>
<p>参数设置在<code>Button.stories.js</code>文件中，该文件是一个包含故事的文件。故事书将挑选任何以<code>stories.js</code>或<code>stories.ts</code>结尾的文件作为故事文件。</p>
<p>属性让我们设置对参数的控制。在我们的示例中，我们将<code>backgroundColor</code>道具设置为由<code>'color'</code>控件控制，该控件是颜色选择器。</p>
<p>在那下面，我们有我们的故事代码。我们用我们的<code>Template</code>函数从<code>Button</code>组件创建一个模板。它接受我们传入的参数，并将它们全部传递给<code>Button</code>。</p>
<p>然后，我们调用<code>Template.bind</code>,通过将<code>args</code>属性设置为带有道具的对象，让我们将参数作为道具传递给<code>Button</code>。</p>
<p>更多来自LogRocket的精彩文章:</p><div class="code-block code-block-54">
<hr/>
<h3>返回一个故事对象，我们可以用参数来配置它。这是一种设置我们想要在故事中预览的道具的便捷方式。</h3>

<hr/></div>
<p>实时编辑用户界面组件</p>
<h2><strong>控件</strong>选项卡包含了我们可以用来设置组件道具的所有表单控件。Storybook选择道具并根据道具类型显示控件。</h2>
<p>此外，我们可以在stories文件中随意设置表单控件类型，就像我们在前面章节的示例中的<code>argTypes</code>属性中看到的那样。这样，我们可以在故事书屏幕上设置道具，并在<strong>画布</strong>标签中查看输出结果。</p>
<p>用颜色选择器改变<code>backgroundColor</code>道具的值。<code>primary</code>道具被换成了一个切换按钮，让我们将其设置为<code>true</code>或<code>false</code>。而<code>size</code>道具是用下拉菜单控制的，因为它只能是三个值中的一个。</p>
<p>Storybook会自动完成这项工作，除非我们自己改变控件类型。这是一个非常有用的特性，它让我们无需更改任何代码就可以更改我们的组件。</p>
<p>组合多本故事书</p>
<h2>Storybook 6引入了通过在另一个项目中引用不同的Storybook项目来组合多个Storybook项目的能力。</h2>
<p>我们可以通过在<code>.storybook/main.js</code>文件中添加以下代码来做到这一点:</p>
<p>这让我们可以在一个项目中加载多个故事书项目的故事。现在，如果我们运行<code>npm run storybook</code>，我们将在左侧栏看到两个项目中显示的所有故事书故事。</p>
<pre>module.exports = {
  //...
  refs: {
    react: {
      title: "React",
      url: 'http://localhost:6007'
    },
    angular: {
      title: "Angular",
      url: 'http://localhost:6008'
    }
  }
}</pre>
<p>在左侧边栏中显示了<code>title</code>值，并且<code>url</code>具有到达Storybook项目的URL。</p>
<p>结论</p>
<h2>故事书6附带了许多有用的新功能。如果您有一个Storybook支持的项目，现在可以用一个命令在现有项目中设置Storybook。我们可以使用args来预设故事中的道具，并轻松预览它们，我们可以通过最小的配置从另一个故事书项目引用另一个故事书项目。</h2>
<p>使用<a class="signup" href="https://lp.logrocket.com/blg/signup" target="_blank" rel="noopener noreferrer"> LogRocket </a>消除传统错误报告的干扰</p><div class="code-block code-block-2">
<div class="blog-plug base-cta"><h2><a href="https://lp.logrocket.com/blg/signup" target="_blank" rel="noopener noreferrer"> LogRocket </a>是一个数字体验分析解决方案，它可以保护您免受数百个假阳性错误警报的影响，只针对几个真正重要的项目。LogRocket会告诉您应用程序中实际影响用户的最具影响力的bug和UX问题。</h2>
<a href="https://lp.logrocket.com/blg/signup" class="signup" target="_blank" rel="noopener noreferrer"><img class="alignnone size-full wp-image-46 jetpack-lazy-image" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/><noscript><img data-lazy-fallback="1" class="alignnone size-full wp-image-46" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/></noscript></a>
<p>然后，使用具有深层技术遥测的会话重放来确切地查看用户看到了什么以及是什么导致了问题，就像你在他们身后看一样。</p>
<p>LogRocket自动聚合客户端错误、JS异常、前端性能指标和用户交互。然后LogRocket使用机器学习来告诉你哪些问题正在影响大多数用户，并提供你需要修复它的上下文。</p>
<p>关注重要的bug—<a class="signup" href="https://lp.logrocket.com/blg/signup-issue-free" target="_blank" rel="noopener noreferrer">今天就试试LogRocket】。</a></p>
<p>Focus on the bugs that matter — <a class="signup" href="https://lp.logrocket.com/blg/signup-issue-free" target="_blank" rel="noopener noreferrer">try LogRocket today</a>.</p></div></div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
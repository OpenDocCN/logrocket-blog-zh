<html>
<head>
<title>React Reference Guide: React.Component - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>反应参考指南:反应。组件-日志火箭博客</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/react-reference-guide-react-component/#0001-01-01">https://blog.logrocket.com/react-reference-guide-react-component/#0001-01-01</a></blockquote><div><article class="article-post">
<p>的反应。组件类是创建React组件的两种方式之一，另外还有功能组件。的反应。组件API提供了更多有助于调整组件行为的特性。</p>
<h4><em>向前跳转:</em></h4>

<hr/>
<h1 id="componentlifecycle">组件生命周期</h1>
<p>类组件中的组件生命周期可以定义为方法的集合，在组件本身的不同阶段，可以访问这些方法来运行一些代码。</p>
<p>组件生命周期方法可以分为三个阶段:</p>
<h2 id="mounting">增加</h2>
<p>在幕后，React使用了一个虚拟DOM，它是浏览器中呈现的DOM的内存表示。虚拟DOM是DOM的副本，可以在不使用任何DOM APIs的情况下进行更新。</p>
<p>对虚拟DOM的更新告诉React将虚拟DOM的当前版本与以前的版本进行比较。一旦React知道哪些虚拟DOM对象已经改变，React就会使用<a href="https://reactjs.org/docs/react-dom.html"> ReactDOM </a>只更新<strong><em/></strong>真实DOM中的那些对象。例如:</p>
<pre>ReactDOM.render(&lt;App /&gt;, domContainer);</pre>
<p>挂载阶段是创建对应于React组件的实例和DOM节点并将它们插入DOM的过程。</p>
<p>以下是安装阶段可用的生命周期方法，按以下顺序调用:</p>
<ul>
<li><code>constructor()</code></li>
<li><code>static getDerivedStateFromProps()</code></li>
<li><code>render()</code></li>
<li><code>componentDidMount()</code></li>
</ul>
<h2 id="updating">更新</h2>
<p>当一个组件被添加到DOM时——也就是安装过程——该组件仍然存储在内存中，以便React在状态改变时能够感知。当React检测到组件状态或道具的更改并重新渲染它时，可以定义更新阶段。</p>
<p>以下是更新阶段可用的生命周期方法，按以下顺序调用:</p>
<ul>
<li><code>static getDerivedStateFromProps()</code></li>
<li><code>shouldComponentUpdate()</code></li>
<li><code>render()</code></li>
<li><code>getSnapshotBeforeUpdate()</code></li>
<li><code>componentDidUpdate()</code></li>
</ul>
<h2 id="unmounting">卸载</h2>
<p>卸载阶段是指不再需要的组件被销毁/从DOM中删除。这个阶段对于执行清除操作特别有用，例如删除事件侦听器、取消网络请求或清除以前的订阅。</p>
<p>以下是卸载阶段可用的一种生命周期方法:</p>

<p>你可以查看<a href="https://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/">这个交互式的、可访问的图</a>，它解释了每个生命周期方法何时被调用。</p>
<h5 class="blog-button"><em> <strong>准备好一探究竟了吗？深入了解React的挂单后挂钩。</strong>T3】</em></h5>
<p>生命周期方法</p>
<hr/>
<h1>接下来，我们将回顾React类组件可用的各种生命周期方法。</h1>
<p><code>constructor()</code></p>
<h2 id="constructor">React组件的构造函数在挂载之前被调用。</h2>
<p>您希望在组件初始化时运行的代码应该放在这里，这些代码可以是初始化本地状态或绑定事件处理程序。</p>
<p><em>即使你可以在构造函数中初始化状态，你<strong>也不应该</strong>调用其中的<code>setState()</code>函数</em>。</p>
<p><em>在每个构造函数方法中，在任何其他行之前添加<code>super(props)</code>行是很重要的，因为它将<code>this</code>值赋给了属性</em>。这是因为，根据定义，<code>super()</code>函数指的是父类构造函数，在本例中是<code>React.Component</code>。</p>
<pre>constructor(props) {
  super(props);
  // Don't call this.setState() here!
  this.state = { counter: 0 };
  this.handleClick = this.handleClick.bind(this);
}</pre>
<p>如果你试图在不调用<code>super(props)</code>的情况下访问组件的属性，你会得到一个<code>undefined</code>错误。因此，调用<code>super(props)</code>允许您访问构造函数中的<code>this</code>，这反过来允许您访问构造函数中的<code>props</code>。</p>
<p>注意:如果你没有初始化一个状态或者绑定方法，你不需要为你的类组件实现一个构造函数。</p>
<blockquote><p><code>render()</code></p></blockquote>
<hr/>
<h2 id="render"><code>render()</code>方法是组件生命周期中唯一需要的方法。它在组件生命周期的安装和更新阶段被调用。</h2>
<p><code>render()</code>方法返回以下任何一项:</p>
<p>使用JSX创建的反应元素</p>
<ul>
<li>片段，它允许您重新运行多个元素</li>
<li>字符串和数字，在DOM中呈现为文本节点</li>
<li>React门户，它提供了将子组件呈现到父组件的DOM层次结构之外的DOM节点中的方法</li>
<li>React鼓励<code>render()</code>方法是纯的，没有副作用——也就是说，当传递相同的输入时，该方法将总是返回相同的输出。<em>这意味着你<strong>不应该</strong>在<code>render()</code>方法中调用<code>setState()</code>函数。</em></li>
</ul>
<p>如果您需要修改组件的状态，可以在<code>componentDidMount()</code>或其他生命周期中完成。</p>
<pre>render() {
  // Don't call this.setState() here!
  return (
    &lt;p&gt;Hello&lt;/p&gt;
  )
}</pre>
<p><em> <strong>更细致地看看React的渲染方法。单击此处查看8种条件渲染方法。</strong>T3】</em></p>
<h5 class="blog-button"> </h5>
<p>更多来自LogRocket的精彩文章:</p><div class="code-block code-block-54">
<hr/>
<h3><code>setState()</code></h3>

<hr/></div>
<hr/>
<h2 id="setstate"><code>setState()</code>函数用于更新组件的状态，并通知React组件需要用更新后的状态重新呈现。使用<code>setState()</code>是更新组件状态的唯一方式。</h2>
<p>无论何时使用<code>setState()</code>调用更新状态，重要的是要注意这是一个异步请求，而不是一个即时命令。这意味着React可能会延迟对组件的状态更新，或者为了提高性能而批量更新多个<code>setState()</code>请求。</p>
<p>您可以通过向<code>setState()</code>传递一个对象或者传递一个更新函数来使用<code>setState()</code>函数，下面将详细解释。</p>
<p>用对象更新状态</p>
<h3 id="updatewithobject">当您调用<code>setState()</code>函数并传递一个对象时，React shallow将您提供的对象合并到当前状态中——也就是说，如果您有一个现有状态(如下面的代码片段)并调用<code>this.setState({hasCountStarted: true})</code>，只有<code>hasCounterStarted</code>的值会被修改。</h3>
<p>用函数更新状态</p>
<pre>this.state = {
  counter: 0,
  hasCounterStarted: false
}</pre>
<h3 id="updatewithfunction">您还可以通过将updater函数传递给<code>setState()</code>函数来更新状态。更新器函数包含在状态更新发生时对当前<code>state</code>和<code>props</code>的引用。</h3>
<p>当您希望用依赖于当前状态的值来更新状态时，此方法特别有用。请参见下面的示例。</p>
<pre>(state, props) =&gt; stateChange</pre>
<p>This method is particularly useful when you want to update the state with values that depend on the current state. See the example below.</p>
<p>如上所述，因为<code>setState()</code>是一个异步请求，也就是说，更新可能会被延迟，所以读取<code>this.state</code>并依赖它的更新值可能会很棘手。确保获得更新状态的一种方法是使用<code>setState()</code>函数接受的回调方法。</p>
<p>回调方法是一个可选的第二个参数，一旦<code>setState()</code>完成并且组件被重新呈现，该参数将被执行。请参见下面的示例。</p>
<p>The callback method is an optional second parameter that will be executed once <code>setState()</code> is completed and the component is re-rendered. See the example below.</p>
<p><em> <strong>您可以通过批量更新来进一步简化状态管理—看看如何操作。</strong>T3】</em></p>
<h5 class="blog-button"> </h5>
<p><code>componentDidMount()</code></p>
<hr/>
<h2 id="componentdidmount">在完成了<code>render()</code>方法之后，也就是在组件已经被挂载并插入到DOM树中之后，立即调用<code>componentDidMount()</code>,并且只调用一次。</h2>
<p>它通常是进行外部API调用、添加事件侦听器或为组件设置订阅的好地方。</p>
<p>您可以在这个生命周期中安全地调用<code>setState()</code>函数。调用<code>setState()</code>函数会导致额外的渲染，但这没关系，因为它会在浏览器更新页面之前发生。</p>
<p>如果您在<code>componentDidMount()</code>方法中设置了事件侦听器或订阅，请不要忘记在<code>componentWillUnmount()</code>方法中删除它们。参见下面的示例，了解如何在<code>componentDidMount()</code>获取外部数据并使用该数据更新状态。</p>
<p>If you set up event listeners or subscriptions in the <code>componentDidMount()</code> method, don’t forget to remove them in the <code>componentWillUnmount()</code> method. See the example below on how to fetch external data in <code>componentDidMount()</code> and updating the state with that data.</p>
<p><code>componentDidUpdate()</code></p>
<hr/>
<h2 id="componentdidupdate"><code>componentDidUpdate(prevProps, prevState, snapshot)</code>在组件生命周期的更新阶段被调用。它在组件重新呈现后被调用，通常用于更新DOM以响应对<code>prop</code>或<code>state</code>的更改。</h2>
<p>该方法接收以下参数:</p>
<p><code>prevProps</code>–先前的<code>prop</code>值</p>
<ul>
<li><code>prevState</code>–先前的<code>state</code>值</li>
<li><code>snapshot</code>–仅当您的组件在组件生命周期中使用<code>getSnapshotBeforeUpdate()</code>方法时，此值才可用</li>
<li>也可以在这里调用<code>setState()</code>函数，只要它被包装在一个条件中，以检查状态/属性相对于前一个状态/属性的变化。这样做是为了防止渲染的无限循环。</li>
</ul>
<p><code>componentDidUpdate()</code>方法的一个典型用例是，当您需要在先前和当前状态不相同的情况下，只调用一个API<em><strong/></em>。</p>
<p>在组件生命周期中，除了当<code>shouldComponentUpdate()</code>方法返回<code>false</code>时，<code>componentDidUpdate()</code>方法是<strong> <em>总是在每次渲染后调用</em> </strong>。</p>
<pre>componentDidUpdate (prevProps, prevState) {
  if (prevState.user.id !== this.state.user.id) {
    // Make your API call here...
  }
}</pre>
<p><code>componentWillUnmount()</code></p>
<hr/>
<h2 id="willunmount">当一个组件将要被销毁并从DOM中移除时，调用<code>componentWillUnmount()</code>。</h2>
<p>这个方法对于取消网络请求、删除事件监听器以及清理可能已经在<code>componentDidMount()</code>中设置的订阅非常有用。</p>
<p> </p>
<pre>componentWillUnmount() {
  // Cancel network requests, event listeners or subscriptions here...
  clearInterval(this.timer);
  this.chatService.unsubscribe();
}</pre>
<p>了解上述生命周期方法如何与useEffect挂钩集成。T3】</p>
<h5 class="blog-button"> </h5>
<p><code>shouldComponentUpdate()</code></p>
<hr/>
<h2 id="shouldcomponentupdate"><code>shouldComponentUpdate(nextProps, nextState)</code>是一种组件生命周期方法，用于确定组件是否应该更新/重新呈现。默认情况下，它返回一个值<code>true</code>,因为每当组件的属性或状态改变时，组件都会重新呈现自己。</h2>
<p>但是，如果您希望在满足特定条件时只重新渲染<em/>，则可以使方法返回<code>false</code>。</p>
<p>它接收两个参数，<code>nextProps</code>和<code>nextState</code>，这两个参数通过与当前的<code>prop</code>和<code>state</code>值进行比较来检查组件是否应该更新。</p>
<p>例如，在上面的代码块中，如果<code>state</code>中的当前<code>user.id</code>在<code>nextState</code>中有相同的值，组件将不会被更新/重新呈现。</p>
<pre>shouldComponentUpdate(nextProps, nextState) {
  if (this.state.user.id === nextState.user.id) {
    return false;
  }
}</pre>
<p>除了最初的渲染之外，每次渲染<em>都会调用这个方法，同样重要的是要注意，当内部子组件的状态改变时，返回<code>false</code>不会阻止它们重新渲染。</em></p>
<p><code>componentDidCatch()</code></p>
<hr/>
<h2 id="didcatch">React最近引入了一个叫做错误边界的概念来处理React组件中的错误。</h2>
<p>错误边界是React组件，帮助捕捉子组件树中任何位置的JavaScript错误，然后记录错误信息/显示带有错误信息的回退UI。</p>
<p>这对调试非常有帮助。您可以将错误边界视为JavaScript <code>catch</code>块，但只适用于React组件。那么误差边界是如何产生的呢？</p>
<p>如果一个类组件有<code>componentDidCatch()</code>或<code>getDerivedStateFromError()</code>方法中的一个(或两个都有),它就会成为一个错误边界。</p>
<p>在子组件中出现错误后，调用<code>componentDidCatch(error, info)</code>方法。它接收<code>error</code>和<code>info</code>参数；<code>error</code>包含抛出的错误消息，<code>info</code>是一个具有<code>componentStack</code>属性的对象，包含组件堆栈跟踪信息。</p>
<p>通过将错误边界组件放置在应用程序组件树的顶部来使用它们。例如:</p>
<pre>class ErrorBoundary extends React.Component {
  constructor(props) {
    super(props);
    this.state = { hasError: false };
  }

  componentDidCatch(error, info) {
    // Once this method is invoked, set the hasError state to be true
    this.setState({hasError: true });
  }

  render() {
    if (this.state.hasError) {
      // You can render any custom fallback UI
      return &lt;h1&gt;Oh no! Something went wrong.&lt;/h1&gt;;
    }

    // if not, just render the child component
    return this.props.children; 
  }
}</pre>
<p><code>static getDerivedStateFromProps()</code></p>
<pre>&lt;ErrorBoundary&gt;
  &lt;SomeProvider&gt;
    &lt;App /&gt;
  &lt;/SomeProvider&gt;
&lt;/ErrorBroundary&gt;</pre>
<hr/>
<h2 id="fromprops"><code>static getDerivedStateFromProps(props, state)</code>是在<code>render()</code>方法之前调用的组件生命周期方法。它接收<code>props</code>和<code>state</code>的参数，并返回一个对象来更新<code>null</code>的状态或值。</h2>
<p>每当组件接收到新的属性时就会调用它，这对于状态依赖于属性随时间变化的情况非常有用。</p>
<p>例如，在上面的代码块中，如果来自<code>props</code>的<code>user.id</code>与<code>state</code>不同，即<code>state</code>依赖于对<code>props</code>的更改，则<code>getDerivedStateFromProps()</code>方法仅返回新状态<strong><em/></strong>。</p>
<pre>static getDerivedStateFromProps(props, state) {
  if (props.user.id !== state.user.id) {
    return {
      isNewUser: true,
      user: props.user,
    };
  }

  // Return null to indicate no change to the state.
  return null;
}</pre>
<p><code>static getDerivedStateFromError()</code></p>
<hr/>
<h2 id="fromerror"><code>static getDerivedStateFromError(error)</code>是一个生命周期方法，在后代组件抛出错误后被调用。它从组件接收错误，然后返回一个值来更新状态。</h2>
<p>与<code>componentDidCatch()</code>方法一样，它也用于误差边界组件中，可以用来代替<code>componentDidCatch()</code>。</p>
<p><code>getSnapshotBeforeUpdate()</code></p>
<pre>class ErrorBoundary extends React.Component {
  constructor(props) {
    super(props);
    this.state = { hasError: false };
  }

  static getDerivedStateFromError(error) {
    // Do something with the error here...
    console.error(error)
    // Update state so the next render will show the fallback UI.
    return { hasError: true };
  }

  render() {
    if (this.state.hasError) {
      // You can render any custom fallback UI
      return &lt;h1&gt;Oh no! Something went wrong.&lt;/h1&gt;;
    }

    // if not, just render the child component
    return this.props.children; 
  }
}</pre>
<hr/>
<h2 id="beforeupdate"><code>getSnapshotBeforeUpdate(prevProps, prevState)</code>是在DOM更新之前调用的生命周期方法。</h2>
<p>它允许您在DOM发生变化之前获取信息。该方法应该返回快照值或<code>null</code>。返回值总是作为参数传递给<code>componentDidUpdate()</code>。</p>
<p><code>getSnapshotBeforeUpdate()</code>的一个典型用例是，在DOM更新之前，您想要记住页面上特定元素的滚动位置。假设页面上有一个定义了高度的评论区，一旦添加了新的评论，我们会自动向下滚动到新的评论。</p>
<p>下面的CodeSandbox演示了如何使用<code>getSnapshotBeforeUpdate()</code>来做到这一点。</p>
<p>The CodeSandbox below demonstrates how to do that using <code>getSnapshotBeforeUpdate()</code>.</p>
<p><em> <strong>你也可以用钩子实现getSnapshotBeforeUpdate()—是的，真的。在这里阅读。</strong>T3】</em></p>
<h5 class="blog-button">类别属性</h5>
<p>这些是React类组件可用的属性。</p>
<hr/>
<h1 id="classproperties"><code>props</code></h1>
<p><code>props</code>是properties的简称。它们用于在React组件之间传递数据。在React类组件中，<code>props</code>可以通过使用<code>this.props</code>来访问。</p>
<h2 id="props"><code>state</code></h2>
<p>React组件中的<code>state</code>包含特定于该组件的数据，这些数据可能会随时间而变化。它是用户定义的，并且总是一个普通的JavaScript对象。</p>
<h2 id="state">React组件中的状态可以通过使用<code>this.state</code>来访问，该状态的值可以通过使用<code>setState()</code>函数来修改。需要注意的是，永远不要使用<code>this.state</code>直接修改状态；而是用<code>setState()</code>代替。</h2>
<p><code>defaultProps</code></p>
<p><code>defaultProps</code>是类组件的一个属性，允许您为类设置默认的<code>props</code>。当预期的<code>props</code>未通过时，使用<code>defaultProps</code>值。</p>
<h2 id="defaultprops">因此，如果在没有指定<code>props.color</code>的情况下在其他地方使用了<code>&lt;CustomButton /&gt;</code>组件，它将退回到被定义为<code>defaultProps</code>的值。</h2>
<p><code>displayName</code></p>
<pre>class CustomButton extends React.Component {
  // ...
}

// Set default props outside the class component
CustomButton.defaultProps = {
  color: 'blue'
};</pre>
<p><code>displayName</code>属性是一个字符串，可以用于调试React组件。默认情况下，它是定义组件的函数或类的名称。但是，如果您想显示不同的名称，可以显式设置它。</p>
<h2 id="displayname"><a href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener"> LogRocket </a>:全面了解您的生产React应用</h2>
<p>调试React应用程序可能很困难，尤其是当用户遇到难以重现的问题时。如果您对监视和跟踪Redux状态、自动显示JavaScript错误以及跟踪缓慢的网络请求和组件加载时间感兴趣，</p><div class="code-block code-block-17">
<div class="blog-plug inline-plug react-plug" vwo-el-id="26283398190">
<h2 vwo-el-id="41600691720">. </h2><p>LogRocket 结合了会话回放、产品分析和错误跟踪，使软件团队能够创建理想的web和移动产品体验。这对你来说意味着什么？</p><a href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" vwo-el-id="19356441070">try LogRocket</a><p>LogRocket不是猜测错误发生的原因，也不是要求用户提供截图和日志转储，而是让您回放问题，就像它们发生在您自己的浏览器中一样，以快速了解哪里出错了。</p><a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="19356441380">
<img class="first-react-image alignnone size-full wp-image-46 jetpack-lazy-image jetpack-lazy-image--handled" src="../Images/f300c244a1a1cf916df8b4cb02bec6c6.png" vwo-el-id="18272717540" data-lazy-loaded="1" data-original-src="https://files.readme.io/27c94e7-Image_2017-06-05_at_9.46.04_PM.png"/>
</a>
<a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="19356441690">
<img class="second-react-image alignnone size-full wp-image-46 jetpack-lazy-image jetpack-lazy-image--handled" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" vwo-el-id="30720362350" data-lazy-loaded="1" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/>
</a>
<p vwo-el-id="28675660440" class="">不再有嘈杂的警报。智能错误跟踪允许您对问题进行分类，然后从中学习。获得有影响的用户问题的通知，而不是误报。警报越少，有用的信号越多。</p>
<p>LogRocket Redux中间件包为您的用户会话增加了一层额外的可见性。LogRocket记录Redux存储中的所有操作和状态。</p>
<p>现代化您调试React应用的方式— <a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="40093418840">开始免费监控</a>。</p>
<p vwo-el-id="28675660750">The LogRocket Redux middleware package adds an extra layer of visibility into your user sessions. LogRocket logs all actions and state from your Redux stores.
</p>
<p vwo-el-id="28675661060">Modernize how you debug your React apps —
<a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="40093418840">start monitoring for free</a>.
</p>
</div></div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
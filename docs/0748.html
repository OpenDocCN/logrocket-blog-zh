<html>
<head>
<title>Redux DevTools: Tips and tricks for faster debugging - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>Redux DevTools:快速调试的技巧和诀窍</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/redux-devtools-tips-tricks-for-faster-debugging/#0001-01-01">https://blog.logrocket.com/redux-devtools-tips-tricks-for-faster-debugging/#0001-01-01</a></blockquote><div><article class="article-post">
<p>Redux是大规模React应用程序最常用的状态管理库之一。除了使您的应用程序更加可预测的能力之外，围绕它发展起来的生态系统使Redux成为大规模应用程序的最佳解决方案。Redux的另一个优势是开发人员工具，它使得跟踪应用程序状态何时、何地、为何以及如何改变变得容易。</p>
<p>我们将研究Redux DevTools提供的一些非凡特性，这些特性可以帮助您更快地调试应用程序。</p>
<h2>跟踪操作</h2>
<p>Redux DevTools的另一个惊人特性是可以看到触发动作的调用栈。我们可以从历史中选择任何行动，并看到行动的原因。</p>
<p><img data-attachment-id="15767" data-permalink="https://blog.logrocket.com/redux-devtools-tips-tricks-for-faster-debugging/tracingactions/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/03/tracingactions.png" data-orig-size="730,393" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="tracingactions" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/03/tracingactions-300x162.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/03/tracingactions.png" decoding="async" class="aligncenter wp-image-15767 size-full jetpack-lazy-image" src="../Images/ed189b4610233e03c5aec0b725f4c374.png" alt="tracing actions" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2020/03/tracingactions.png 730w, https://blog.logrocket.com/wp-content/uploads/2020/03/tracingactions-300x162.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2020/03/tracingactions.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/03/tracingactions.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="15767" data-permalink="https://blog.logrocket.com/redux-devtools-tips-tricks-for-faster-debugging/tracingactions/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/03/tracingactions.png" data-orig-size="730,393" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="tracingactions" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/03/tracingactions-300x162.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/03/tracingactions.png" decoding="async" loading="lazy" class="aligncenter wp-image-15767 size-full" src="../Images/ed189b4610233e03c5aec0b725f4c374.png" alt="tracing actions" srcset="https://blog.logrocket.com/wp-content/uploads/2020/03/tracingactions.png 730w, https://blog.logrocket.com/wp-content/uploads/2020/03/tracingactions-300x162.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/03/tracingactions.png"/></noscript>
<p>对于大规模的应用程序，相同的动作从应用程序的不同部分同时触发，很难找到动作分派的根本原因。这就是开发人员使用跟踪功能的地方。</p>
<p>Redux DevTool允许开发人员使用依赖于<code>Error.stack()</code>的默认实现，或者定义自定义实现。下面是启用<code>trace</code>的API:</p>
<pre>window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__({
    trace: true, // (action) =&gt; { return ‘trace as string’; }
    traceLimit: 25,
 })</pre>
<p>正如所见，<code>trace</code>参数也接受方法。每个动作都会调用这个方法。开发人员可以在这里添加自定义实现来查看动作分派的原因。针对trace属性传递此方法允许开发人员仅监视所需操作的跟踪。</p>
<p>这有助于保持开发体验的流畅和高效，因为为每个动作创建<code>trace</code>可能会消耗大量内存。作为<code>trace</code>的方法对于通过副作用库(如redux-saga或其他事件监听器)调度的动作很有帮助。</p>
<p>当没有实现自定义跟踪方法时，开发人员可以依赖使用<code>Error.stack()</code> API的默认实现。在这种情况下，<code>traceLimit</code>属性对于管理DevTool的内存使用非常有用。它覆盖了浏览器默认的<code>Error.stackTraceLimit</code>，并限制了堆栈的长度以优化内存消耗。</p>

<div class="podcast-container">
<div class="podcast-embed">
<h2>我们不只是写Redux，我们也谈论它。现在听着:</h2>
<p>或者以后订阅</p>
<h3>在编辑器中跟踪操作</h3>

</div>
</div>
<h2>Redux DevTool扩展了显示动作的<code>trace</code>的能力，允许您导航到代码库的确切位置。对于大型代码库来说，这非常方便，因为它节省了在大型代码库中导航到准确位置的大量时间。</h2>
<p>可以从DevTool右下角的扩展设置中设置编辑器。</p>
<p><img data-attachment-id="15772" data-permalink="https://blog.logrocket.com/redux-devtools-tips-tricks-for-faster-debugging/tracingactionsintheeditors/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/03/tracingactionsintheeditors.png" data-orig-size="344,512" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="tracingactionsintheeditors" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/03/tracingactionsintheeditors-202x300.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/03/tracingactionsintheeditors.png" decoding="async" class="aligncenter wp-image-15772 size-full jetpack-lazy-image" src="../Images/1d18cf58d141123204a7aed9b879f58f.png" alt="tracing actions in the editors" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2020/03/tracingactionsintheeditors.png 344w, https://blog.logrocket.com/wp-content/uploads/2020/03/tracingactionsintheeditors-202x300.png 202w" data-lazy-sizes="(max-width: 344px) 100vw, 344px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2020/03/tracingactionsintheeditors.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/03/tracingactionsintheeditors.png"/></p>
<p>跳过动作</p><noscript><img data-lazy-fallback="1" data-attachment-id="15772" data-permalink="https://blog.logrocket.com/redux-devtools-tips-tricks-for-faster-debugging/tracingactionsintheeditors/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/03/tracingactionsintheeditors.png" data-orig-size="344,512" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="tracingactionsintheeditors" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/03/tracingactionsintheeditors-202x300.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/03/tracingactionsintheeditors.png" decoding="async" loading="lazy" class="aligncenter wp-image-15772 size-full" src="../Images/1d18cf58d141123204a7aed9b879f58f.png" alt="tracing actions in the editors" srcset="https://blog.logrocket.com/wp-content/uploads/2020/03/tracingactionsintheeditors.png 344w, https://blog.logrocket.com/wp-content/uploads/2020/03/tracingactionsintheeditors-202x300.png 202w" sizes="(max-width: 344px) 100vw, 344px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/03/tracingactionsintheeditors.png"/></noscript>
<h2>时间旅行是Redux DevTools最强大的功能之一，它允许我们看到我们的应用程序的状态如何达到当前点。在某些情况下，为了分析应用程序的行为，我们可能需要从时间轴中删除一个特定的动作。这在时间旅行机制中是不可能的。Redux DevTool有一个很好的方法。在应用程序流的三种不同视图类型中，日志监视器和检查器允许您从时间线中禁用或移除操作。这是它的样子。</h2>
<p><img data-attachment-id="15774" data-permalink="https://blog.logrocket.com/redux-devtools-tips-tricks-for-faster-debugging/skippingactions/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/03/skippingactions.png" data-orig-size="512,274" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="skippingactions" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/03/skippingactions-300x161.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/03/skippingactions.png" decoding="async" class="aligncenter wp-image-15774 size-full jetpack-lazy-image" src="../Images/28ba0f0187f0510a96b0926c79603883.png" alt="skipping actions" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2020/03/skippingactions.png 512w, https://blog.logrocket.com/wp-content/uploads/2020/03/skippingactions-300x161.png 300w" data-lazy-sizes="(max-width: 512px) 100vw, 512px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2020/03/skippingactions.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/03/skippingactions.png"/></p>
<p>开始行动</p><noscript><img data-lazy-fallback="1" data-attachment-id="15774" data-permalink="https://blog.logrocket.com/redux-devtools-tips-tricks-for-faster-debugging/skippingactions/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/03/skippingactions.png" data-orig-size="512,274" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="skippingactions" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/03/skippingactions-300x161.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/03/skippingactions.png" decoding="async" loading="lazy" class="aligncenter wp-image-15774 size-full" src="../Images/28ba0f0187f0510a96b0926c79603883.png" alt="skipping actions" srcset="https://blog.logrocket.com/wp-content/uploads/2020/03/skippingactions.png 512w, https://blog.logrocket.com/wp-content/uploads/2020/03/skippingactions-300x161.png 300w" sizes="(max-width: 512px) 100vw, 512px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/03/skippingactions.png"/></noscript>
<h2>除了从时间轴上跳过状态之外，开发人员还可以跳到所需的状态，而不必在时间轴上移动。这使得开发人员能够快速移动，并在不同的中间状态下查看应用程序的输出。开发人员也可以监控时间线跳跃的影响。此功能仅在检查器模式下可用。</h2>
<p><img data-attachment-id="15776" data-permalink="https://blog.logrocket.com/redux-devtools-tips-tricks-for-faster-debugging/jumpingtoaction/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/03/jumpingtoaction.png" data-orig-size="512,276" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="jumpingtoaction" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/03/jumpingtoaction-300x162.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/03/jumpingtoaction.png" decoding="async" class="aligncenter wp-image-15776 size-full jetpack-lazy-image" src="../Images/c4e2f30976c1f80877c02470b49196e6.png" alt="jumping in action" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2020/03/jumpingtoaction.png 512w, https://blog.logrocket.com/wp-content/uploads/2020/03/jumpingtoaction-300x162.png 300w" data-lazy-sizes="(max-width: 512px) 100vw, 512px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2020/03/jumpingtoaction.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/03/jumpingtoaction.png"/></p>
<p>海关派遣</p><noscript><img data-lazy-fallback="1" data-attachment-id="15776" data-permalink="https://blog.logrocket.com/redux-devtools-tips-tricks-for-faster-debugging/jumpingtoaction/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/03/jumpingtoaction.png" data-orig-size="512,276" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="jumpingtoaction" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/03/jumpingtoaction-300x162.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/03/jumpingtoaction.png" decoding="async" loading="lazy" class="aligncenter wp-image-15776 size-full" src="../Images/c4e2f30976c1f80877c02470b49196e6.png" alt="jumping in action" srcset="https://blog.logrocket.com/wp-content/uploads/2020/03/jumpingtoaction.png 512w, https://blog.logrocket.com/wp-content/uploads/2020/03/jumpingtoaction-300x162.png 300w" sizes="(max-width: 512px) 100vw, 512px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/03/jumpingtoaction.png"/></noscript>
<h2>Redux DevTool允许我们在不编写任何代码的情况下分派动作。我们可以在dispatcher中添加我们的动作，它就像通过Redux API调度的动作一样工作。这种嘲笑有助于测试副作用和依赖行为。当与锁定到当前状态结合使用时，这个特性变得非常方便。我们可以将状态锁定到某个阶段，并从DevTool调度操作，以查看对存储的影响并监视副作用。</h2>
<p><img data-attachment-id="15778" data-permalink="https://blog.logrocket.com/redux-devtools-tips-tricks-for-faster-debugging/customdispatch1/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/03/customdispatch1.png" data-orig-size="512,89" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="customdispatch1" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/03/customdispatch1-300x52.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/03/customdispatch1.png" decoding="async" class="aligncenter wp-image-15778 size-full jetpack-lazy-image" src="../Images/98117ff954511361450e0303d01eb87a.png" alt="custom dispatch" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2020/03/customdispatch1.png 512w, https://blog.logrocket.com/wp-content/uploads/2020/03/customdispatch1-300x52.png 300w" data-lazy-sizes="(max-width: 512px) 100vw, 512px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2020/03/customdispatch1.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/03/customdispatch1.png"/></p>
<p> </p><noscript><img data-lazy-fallback="1" data-attachment-id="15778" data-permalink="https://blog.logrocket.com/redux-devtools-tips-tricks-for-faster-debugging/customdispatch1/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/03/customdispatch1.png" data-orig-size="512,89" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="customdispatch1" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/03/customdispatch1-300x52.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/03/customdispatch1.png" decoding="async" loading="lazy" class="aligncenter wp-image-15778 size-full" src="../Images/98117ff954511361450e0303d01eb87a.png" alt="custom dispatch" srcset="https://blog.logrocket.com/wp-content/uploads/2020/03/customdispatch1.png 512w, https://blog.logrocket.com/wp-content/uploads/2020/03/customdispatch1-300x52.png 300w" sizes="(max-width: 512px) 100vw, 512px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/03/customdispatch1.png"/></noscript>
<p><img data-attachment-id="15779" data-permalink="https://blog.logrocket.com/redux-devtools-tips-tricks-for-faster-debugging/customdispatch2/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/03/customdispatch2.png" data-orig-size="512,84" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="customdispatch2" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/03/customdispatch2-300x49.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/03/customdispatch2.png" decoding="async" class="aligncenter wp-image-15779 size-full jetpack-lazy-image" src="../Images/dfcda026d8a5c1c65067a4ebfadd5d9a.png" alt="custom dispatch 2" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2020/03/customdispatch2.png 512w, https://blog.logrocket.com/wp-content/uploads/2020/03/customdispatch2-300x49.png 300w" data-lazy-sizes="(max-width: 512px) 100vw, 512px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2020/03/customdispatch2.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/03/customdispatch2.png"/></p>
<p>允许/阻止操作</p><noscript><img data-lazy-fallback="1" data-attachment-id="15779" data-permalink="https://blog.logrocket.com/redux-devtools-tips-tricks-for-faster-debugging/customdispatch2/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/03/customdispatch2.png" data-orig-size="512,84" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="customdispatch2" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/03/customdispatch2-300x49.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/03/customdispatch2.png" decoding="async" loading="lazy" class="aligncenter wp-image-15779 size-full" src="../Images/dfcda026d8a5c1c65067a4ebfadd5d9a.png" alt="custom dispatch 2" srcset="https://blog.logrocket.com/wp-content/uploads/2020/03/customdispatch2.png 512w, https://blog.logrocket.com/wp-content/uploads/2020/03/customdispatch2-300x49.png 300w" sizes="(max-width: 512px) 100vw, 512px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/03/customdispatch2.png"/></noscript>
<h2>对于由许多动作组成的大规模应用程序，我们可以只监控想要的动作；或者，我们可以阻止某些动作出现在DevTools中。这可以通过在DevTools设置中添加一个动作列表来阻止或允许，或者在我们的应用程序中初始化它。</h2>
<p>正如所看到的，我们可以在初始化时在一个参数中使用<code>actionsBlacklist</code> / <code>actionsWhitelist</code>参数，或者通过设置来完成。</p>
<pre>window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__({
    actionsBlacklist: 'SOME_ACTION',
  // or actionsBlacklist: ['SOME_ACTION', 'SOME_OTHER_ACTION']
  // or just actionsBlacklist: 'SOME_' to omit both
 })</pre>
<p><strong>免责声明</strong>:我们不鼓励使用任何种族主义术语，无论意图如何；我们使用这些术语只是为了引用API。<a href="https://github.com/reduxjs/redux-devtools/issues/686">这个包的维护者</a>提出了这个问题，我们希望他们会考虑我们的请求。</p>
<p>页面重新加载时保持存储</p>
<h2>大规模应用程序中的一个痛点是为状态开发接口，该状态是在应用程序内的一次旅行之后获得的。当一些状态依赖于副作用时，例如网络响应，就变得更加困难。DevTool来帮忙了，我们可以在页面重新加载时保持某些状态。这将允许你在重新加载后直接跳转到所需的状态，而无需再次经历旅程。</h2>
<p>这可以通过点击底部栏中的“Persist”按钮或将<code>?debug_session=</code>添加到URL来完成。<img data-attachment-id="15782" data-permalink="https://blog.logrocket.com/redux-devtools-tips-tricks-for-faster-debugging/persist/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/03/persist.png" data-orig-size="730,81" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="persist" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/03/persist-300x33.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/03/persist.png" decoding="async" class="aligncenter wp-image-15782 size-full jetpack-lazy-image" src="../Images/1d6121abc66bf31ef28675c16d29c699.png" alt="persist" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2020/03/persist.png 730w, https://blog.logrocket.com/wp-content/uploads/2020/03/persist-300x33.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2020/03/persist.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/03/persist.png"/></p>
<p>在生产中使用</p><noscript><img data-lazy-fallback="1" data-attachment-id="15782" data-permalink="https://blog.logrocket.com/redux-devtools-tips-tricks-for-faster-debugging/persist/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/03/persist.png" data-orig-size="730,81" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="persist" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/03/persist-300x33.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/03/persist.png" decoding="async" loading="lazy" class="aligncenter wp-image-15782 size-full" src="../Images/1d6121abc66bf31ef28675c16d29c699.png" alt="persist" srcset="https://blog.logrocket.com/wp-content/uploads/2020/03/persist.png 730w, https://blog.logrocket.com/wp-content/uploads/2020/03/persist-300x33.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/03/persist.png"/></noscript>
<h2>很难预测或捕捉我们应用程序中所有可能的错误。在我们的应用程序投入生产并被大量用户使用后，我们会遇到许多问题。为了分析这些错误，我们可能需要查看问题发生时应用程序的动作轨迹或当前状态。DevTool允许我们看到一系列的动作，并存储在产品中，这使得重现问题变得更加容易。</h2>
<p>为了安全和性能，强烈建议使用<a href="https://github.com/zalmoxisus/redux-devtools-extension/blob/master/docs/API/Arguments.md#actionsanitizer--statesanitizer" target="_blank" rel="noopener noreferrer">动作和状态清理</a>选项。<a href="https://medium.com/@zalmoxis/using-redux-devtools-in-production-4c5b56c5600f" target="_blank" rel="noopener noreferrer">这里有一篇关于在产品中启用DevTool的博文</a>。</p>
<p>锁定到当前状态</p>
<h2>在频繁分派几个动作的应用程序中，我们可能需要在中间位置分析我们的应用程序，而不允许分派进一步的动作。这可以通过将我们的应用程序锁定到当前状态来实现。与暂停不同，这将应用程序冻结在当前状态。当应用程序被锁定，我们仍然可以做时间旅行和其他启用/禁用调度的行动。<br/> <img data-attachment-id="15786" data-permalink="https://blog.logrocket.com/redux-devtools-tips-tricks-for-faster-debugging/lockingtocurrentstate/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/03/lockingtocurrentstate.gif" data-orig-size="600,339" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="lockingtocurrentstate" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/03/lockingtocurrentstate-300x170.gif" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/03/lockingtocurrentstate.gif" decoding="async" class="aligncenter wp-image-15786 size-full jetpack-lazy-image" src="../Images/6f3e2b19e8e64580cba412800f8c2c4c.png" alt="locking to current state" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2020/03/lockingtocurrentstate.gif?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/03/lockingtocurrentstate.gif"/></h2>
<p>锁定的另一个好处是我们终于有了一个避免副作用的解决方案。</p><noscript><img data-lazy-fallback="1" data-attachment-id="15786" data-permalink="https://blog.logrocket.com/redux-devtools-tips-tricks-for-faster-debugging/lockingtocurrentstate/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/03/lockingtocurrentstate.gif" data-orig-size="600,339" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="lockingtocurrentstate" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/03/lockingtocurrentstate-300x170.gif" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/03/lockingtocurrentstate.gif" decoding="async" loading="lazy" class="aligncenter wp-image-15786 size-full" src="../Images/6f3e2b19e8e64580cba412800f8c2c4c.png" alt="locking to current state" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/03/lockingtocurrentstate.gif"/></noscript>
<p>固定到子状态</p>
<h2>在大多数生产应用程序中，状态被分成小的子状态对象，通常反映应用程序中的不同模块。调试案例可能需要关注特定的子状态。对于这种情况，开发人员可以锁定到子状态，并查看不同的操作如何影响这个锁定的子状态。子状态可以通过<em>检查器&amp;图表模式</em>锁定。</h2>
<p><img data-attachment-id="15788" data-permalink="https://blog.logrocket.com/redux-devtools-tips-tricks-for-faster-debugging/pintostate/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/03/pintostate.gif" data-orig-size="512,289" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="pintostate" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/03/pintostate-300x169.gif" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/03/pintostate.gif" decoding="async" class="aligncenter wp-image-15788 size-full jetpack-lazy-image" src="../Images/48fc31f991cb5ad7613b87b5ef420234.png" alt="pin to sub state" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2020/03/pintostate.gif?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/03/pintostate.gif"/></p>
<p>提交操作</p><noscript><img data-lazy-fallback="1" data-attachment-id="15788" data-permalink="https://blog.logrocket.com/redux-devtools-tips-tricks-for-faster-debugging/pintostate/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/03/pintostate.gif" data-orig-size="512,289" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="pintostate" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/03/pintostate-300x169.gif" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/03/pintostate.gif" decoding="async" loading="lazy" class="aligncenter wp-image-15788 size-full" src="../Images/48fc31f991cb5ad7613b87b5ef420234.png" alt="pin to sub state" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/03/pintostate.gif"/></noscript>
<h2>对于大规模的应用程序来说，浏览上百个动作的列表从来都不是一件容易的事情。相反，开发人员更喜欢分块监控应用程序。对于这种情况，Redux DevTool允许开发人员提交当前的一组操作。当前状态被认为是即将到来的动作的初始状态。该特性的一个最佳用途是跨页面转换监控状态。</h2>
<p>提交后，您还可以随时恢复到这种状态。换句话说，您可以将pivot添加到您的状态中，并在需要时随时返回。<br/> <img data-attachment-id="15789" data-permalink="https://blog.logrocket.com/redux-devtools-tips-tricks-for-faster-debugging/commitactions/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/03/commitactions.gif" data-orig-size="512,289" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="commitactions" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/03/commitactions-300x169.gif" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/03/commitactions.gif" decoding="async" class="aligncenter wp-image-15789 size-full jetpack-lazy-image" src="../Images/4c1cc2c7ea5608fb9f423289b9a47f44.png" alt="commit actions" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2020/03/commitactions.gif?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/03/commitactions.gif"/></p>
<p>开发人员可以从检查器模式提交状态，但要恢复必须切换到日志监视器。</p><noscript><img data-lazy-fallback="1" data-attachment-id="15789" data-permalink="https://blog.logrocket.com/redux-devtools-tips-tricks-for-faster-debugging/commitactions/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/03/commitactions.gif" data-orig-size="512,289" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="commitactions" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/03/commitactions-300x169.gif" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/03/commitactions.gif" decoding="async" loading="lazy" class="aligncenter wp-image-15789 size-full" src="../Images/4c1cc2c7ea5608fb9f423289b9a47f44.png" alt="commit actions" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/03/commitactions.gif"/></noscript>
<p>结论</p>
<h2>毫无疑问，Redux DevTool是调试React应用程序的最有用和最强大的工具之一。它允许开发人员充分利用Redux提供的应用程序的可预测性。React本机调试器中也提供了它，这就是为什么充分了解它可以加快我们在web和移动平台上同时进行开发和调试的速度。</h2>
<p><a href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener"> LogRocket </a>:全面了解您的生产React应用</p><div class="code-block code-block-17">
<div class="blog-plug inline-plug react-plug" vwo-el-id="26283398190">
<h2 vwo-el-id="41600691720">调试React应用程序可能很困难，尤其是当用户遇到难以重现的问题时。如果您对监视和跟踪Redux状态、自动显示JavaScript错误以及跟踪缓慢的网络请求和组件加载时间感兴趣，</h2><p>. </p><a href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" vwo-el-id="19356441070">try LogRocket</a><p>LogRocket 结合了会话回放、产品分析和错误跟踪，使软件团队能够创建理想的web和移动产品体验。这对你来说意味着什么？</p><a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="19356441380">
<img class="first-react-image alignnone size-full wp-image-46 jetpack-lazy-image jetpack-lazy-image--handled" src="../Images/f300c244a1a1cf916df8b4cb02bec6c6.png" vwo-el-id="18272717540" data-lazy-loaded="1" data-original-src="https://files.readme.io/27c94e7-Image_2017-06-05_at_9.46.04_PM.png"/>
</a>
<a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="19356441690">
<img class="second-react-image alignnone size-full wp-image-46 jetpack-lazy-image jetpack-lazy-image--handled" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" vwo-el-id="30720362350" data-lazy-loaded="1" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/>
</a>
<p vwo-el-id="28675660440" class="">LogRocket不是猜测错误发生的原因，也不是要求用户提供截图和日志转储，而是让您回放问题，就像它们发生在您自己的浏览器中一样，以快速了解哪里出错了。</p>
<p>不再有嘈杂的警报。智能错误跟踪允许您对问题进行分类，然后从中学习。获得有影响的用户问题的通知，而不是误报。警报越少，有用的信号越多。</p>
<p>LogRocket Redux中间件包为您的用户会话增加了一层额外的可见性。LogRocket记录Redux存储中的所有操作和状态。</p>
<p vwo-el-id="28675660750">现代化您调试React应用的方式— <a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="40093418840">开始免费监控</a>。</p>
<p vwo-el-id="28675661060">Modernize how you debug your React apps —
<a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="40093418840">start monitoring for free</a>.
</p>
</div></div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
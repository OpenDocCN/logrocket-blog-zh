<html>
<head>
<title>The introductory guide to AssemblyScript - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>AssemblyScript - LogRocket博客入门指南</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/the-introductory-guide-to-assemblyscript/#0001-01-01">https://blog.logrocket.com/the-introductory-guide-to-assemblyscript/#0001-01-01</a></blockquote><div><article class="article-post">
<p>WebAssembly(或Wasm)是web浏览器的一个相对较新的功能，但它有可能极大地扩展web作为应用服务平台的能力。</p>
<p>虽然web开发人员开始使用WebAssembly可能会有一个陡峭的学习曲线，但<a href="https://assemblyscript.org/"> AssemblyScript </a>提供了一种绕过它的方法。让我们首先看看为什么WebAssembly是一项如此有前途的技术，然后我们将看到AssemblyScript如何帮助释放其潜力。</p>
<h2>web程序集</h2>
<p>WebAssembly是浏览器的底层语言，给开发者提供了除JavaScript之外的web编译目标。它使网站代码在安全的沙盒环境中以接近本地的速度运行成为可能。</p>
<p>它是在所有主要浏览器(Chrome、Firefox、Safari和Edge)代表的参与下开发的，他们<a href="https://lists.w3.org/Archives/Public/public-webassembly/2017Feb/0002.html">在2017年初达成了设计共识</a>。所有这些浏览器现在都支持WebAssembly，它可以在<a href="https://caniuse.com/#feat=wasm" target="_blank" rel="noopener noreferrer">大约87%的浏览器中使用。</a></p>
<p>WebAssembly以二进制格式交付，这意味着它在大小和加载时间上都比JavaScript有优势。然而它也有一个人类可读的文本表示。</p>
<p>当WebAssembly首次发布时，一些开发人员认为它有可能最终取代JavaScript成为web的主要语言。但是最好把WebAssembly看作是一个新的工具，与现有的web平台很好地集成，这是它的<a href="https://webassembly.org/docs/high-level-goals/">高层目标</a>之一。</p>
<p>WebAssembly更吸引人，而不是取代现有用例的JavaScript，因为它支持新的用例。WebAssembly还不能直接访问DOM，大多数现有网站都希望坚持使用JavaScript，经过多年的优化，JavaScript已经非常快了。以下是web assembly<a href="https://webassembly.org/docs/use-cases/">自己的可能用例列表</a>的示例:</p>
<ul>
<li>比赛</li>
<li>科学可视化和模拟</li>
<li>CAD应用</li>
<li>图像/视频编辑</li>
</ul>
<p>这些应用程序的共同特点是，我们通常认为它们是桌面应用程序。通过为CPU密集型任务提供接近本机的性能，WebAssembly使得将更多这些应用程序转移到web上变得可行。</p>
<p>现有网站也可以从WebAssembly中受益。<a href="https://www.figma.com/"> Figma </a>提供了一个现实世界的例子，他们使用WebAssembly来显著改善加载时间。如果一个网站使用大量计算的代码，用WebAssembly只替换那些代码来提高性能是有意义的。</p>
<p>所以现在你可能对WebAssembly感兴趣了。你可以学习语言本身，然后<a href="https://blog.scottlogic.com/2018/04/26/webassembly-by-hand.html">直接编写它</a>，但它实际上是为了成为其他语言的<a href="https://github.com/appcypher/awesome-wasm-langs">编译目标。它</a><a href="https://webassembly.org/docs/c-and-c++/">被设计</a>对C和C++有很好的支持，Go <a href="https://golang.org/doc/go1.11#wasm">在1.11版本中为它增加了实验性支持</a>，Rust也<a href="https://www.rust-lang.org/what/wasm">在其中投入巨资</a>。</p>
<p>但也许你不想为了使用WebAssembly而学习或使用这些语言中的一种。这就是AssemblyScript发挥作用的地方。</p>
<h2>汇编脚本</h2>
<p>AssemblyScript是一个类型脚本到WebAssembly的编译器。由微软开发的TypeScript为JavaScript增加了类型。它已经变得非常流行，即使对于不熟悉它的人来说，AssemblyScript也只允许有限的一部分类型脚本特性，所以不需要很长时间就能上手。</p>
<p>因为它与JavaScript非常相似，AssemblyScript让web开发人员可以轻松地将WebAssembly集成到他们的网站中，而不必使用完全不同的语言。</p>
<h3>尝试一下</h3>
<p>让我们编写我们的第一个AssemblyScript模块(以下所有代码都可以在<a href="https://github.com/dguo/assemblyscript-demo"> this GitHub repository </a>中找到)。我们需要最低版本为8的<a href="https://nodejs.org/"> Node.js </a>来支持<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WebAssembly#Browser_compatibility">web assembly</a>。</p>
<p>转到一个空目录，创建一个<code>package.json</code>文件，并安装AssemblyScript。注意，我们需要直接从<a href="https://github.com/AssemblyScript/assemblyscript">的GitHub库</a>安装它。它没有在npm上发布，因为AssemblyScript开发者<a href="https://github.com/AssemblyScript/assemblyscript/issues/442#issuecomment-458523778">认为编译器还没有准备好</a>用于一般用途。</p>
<pre>mkdir assemblyscript-demo
cd assemblyscript-demo
npm init
npm install --save-dev github:AssemblyScript/assemblyscript</pre>
<p>使用附带的<code>asinit</code>命令生成脚手架文件:</p>
<pre>npx asinit .</pre>
<p>我们的<code>package.json</code>现在应该包括这些脚本:</p>
<pre>{
  "scripts": {
    "asbuild:untouched": "asc assembly/index.ts -b build/untouched.wasm -t build/untouched.wat --sourceMap --validate --debug",
    "asbuild:optimized": "asc assembly/index.ts -b build/optimized.wasm -t build/optimized.wat --sourceMap --validate --optimize",
    "asbuild": "npm run asbuild:untouched &amp;&amp; npm run asbuild:optimized"
  }
}</pre>
<p>顶层<code>index.js</code>看起来像这样:</p>
<pre>const fs = require("fs");
const compiled = new WebAssembly.Module(fs.readFileSync(__dirname + "/build/optimized.wasm"));
const imports = {
  env: {
    abort(_msg, _file, line, column) {
       console.error("abort called at index.ts:" + line + ":" + column);
    }
  }
};
Object.defineProperty(module, "exports", {
  get: () =&gt; new WebAssembly.Instance(compiled, imports).exports
});</pre>
<p>它允许我们轻松地<code><a href="https://nodejs.org/api/modules.html#modules_require_id" target="_blank" rel="noopener noreferrer">require</a></code>我们的WebAssembly模块，就像普通的JavaScript模块一样。</p>
<p><code>assembly</code>目录包含我们的AssemblyScript源代码。生成的示例是一个简单的加法函数。</p>
<pre>export function add(a: i32, b: i32): i32 {
  return a + b;
}</pre>
<p>如果您希望函数签名看起来像<code>add(a: number, b: number): number</code>，就像在TypeScript中一样，它使用<code>i32</code>的原因是AssemblyScript使用WebAssembly的<a href="https://docs.assemblyscript.org/basics/types">特定整数和浮点类型</a>，而不是TypeScript的<a href="https://www.typescriptlang.org/docs/handbook/basic-types.html#number" target="_blank" rel="noopener noreferrer">通用<code>number</code>类型</a>。</p>
<p>让我们来构建这个例子。</p>
<pre>npm run asbuild</pre>
<p><code>build</code>目录现在应该包括以下文件:</p>
<pre>optimized.wasm
optimized.wasm.map
optimized.wat
untouched.wasm
untouched.wasm.map
untouched.wat</pre>
<p>我们得到了简单的和优化的版本。对于每个构建版本，我们得到一个<code>.wasm</code>二进制文件，一个<code>.wasm.map</code> <a href="https://developer.mozilla.org/en-US/docs/Tools/Debugger/How_to/Use_a_source_map">源映射</a>，以及一个<code>.wat</code>二进制文件的文本表示。文本表示被设计为人类可读的，但是对于我们的目的，我们不需要阅读或理解它——使用AssemblyScript的部分原因是我们不需要使用原始WebAssembly。</p>
<p>启动节点，像使用其他模块一样使用我们编译的模块。</p>
<pre>$ node
Welcome to Node.js v12.10.0.
Type ".help" for more information.
&gt; const add = require('./index').add;
undefined
&gt; add(3, 5)
8</pre>
<p>这就是从Node调用WebAssembly所做的全部工作！</p>
<h3>添加观察脚本</h3>
<p>对于开发来说，我推荐使用<a href="https://github.com/Qard/onchange"> onchange </a>在你修改源代码的时候自动重建模块，因为AssemblyScript <a href="https://github.com/AssemblyScript/assemblyscript/issues/624">还不包括观察模式</a>。</p>
<pre>npm install --save-dev onchange</pre>
<p>给<code>package.json</code>添加一个<code>asbuild:watch</code>脚本。包含<code>-i</code> <a href="https://github.com/Qard/onchange#initial--i---initial">标志</a>，以便在运行命令时立即运行初始构建。</p>
<pre>{
  "scripts": {
    "asbuild:untouched": "asc assembly/index.ts -b build/untouched.wasm -t build/untouched.wat --sourceMap --validate --debug",
    "asbuild:optimized": "asc assembly/index.ts -b build/optimized.wasm -t build/optimized.wat --sourceMap --validate --optimize",
    "asbuild": "npm run asbuild:untouched &amp;&amp; npm run asbuild:optimized",
    "asbuild:watch": "onchange -i 'assembly/**/*' -- npm run asbuild"
  }
}</pre>
<p>现在你可以运行<code>asbuild:watch</code>而不是不断地重新运行<code>asbuild</code>。</p>
<h3>表演</h3>
<p>让我们编写一个基本的基准测试来了解我们可以获得什么样的性能提升。WebAssembly的专长是处理CPU密集型任务，如数值计算，所以让我们用一个函数来确定一个整数是否是质数。</p>
<p>我们的参考实现如下所示。这是一个天真的、蛮力的解决方案，因为我们的目标是执行大量的计算。</p>
<pre>function isPrime(x) {
    if (x &lt; 2) {
        return false;
    }

    for (let i = 2; i &lt; x; i++) {
        if (x % i === 0) {
            return false;
        }
    }

    return true;
}</pre>
<p>等效的AssemblyScript版本只需要一些类型注释:</p>
<pre>function isPrime(x: u32): bool {
    if (x &lt; 2) {
        return false;
    }

    for (let i: u32 = 2; i &lt; x; i++) {
        if (x % i === 0) {
            return false;
        }
    }

    return true;
}</pre>
<p>我们将使用<a href="https://benchmarkjs.com/"> Benchmark.js </a>。</p>
<pre>npm install --save-dev benchmark</pre>
<p>创建<code>benchmark.js</code>:</p>
<pre>const Benchmark = require('benchmark');

const assemblyScriptIsPrime = require('./index').isPrime;

function isPrime(x) {
    for (let i = 2; i &lt; x; i++) {
        if (x % i === 0) {
            return false;
        }
    }

    return true;
}

const suite = new Benchmark.Suite;
const startNumber = 2;
const stopNumber = 10000;

suite.add('AssemblyScript isPrime', function () {
    for (let i = startNumber; i &lt; stopNumber; i++) {
        assemblyScriptIsPrime(i);
    }
}).add('JavaScript isPrime', function () {
    for (let i = startNumber; i &lt; stopNumber; i++) {
        isPrime(i);
    }
}).on('cycle', function (event) {
    console.log(String(event.target));
}).on('complete', function () {
    const fastest = this.filter('fastest');
    const slowest = this.filter('slowest');
    const difference = (fastest.map('hz') - slowest.map('hz')) / slowest.map('hz') * 100;
    console.log(`${fastest.map('name')} is ~${difference.toFixed(1)}% faster.`);
}).run();</pre>
<p>在我的机器上，当我运行<code>node benchmark</code>时，我得到了这些结果:</p>
<pre>AssemblyScript isPrime x 74.00 ops/sec ±0.43% (76 runs sampled)
JavaScript isPrime x 61.56 ops/sec ±0.30% (64 runs sampled)
AssemblyScript isPrime is ~20.2% faster.</pre>
<p>注意，这个测试是一个<a href="https://stackoverflow.com/a/2842707/1481479">微基准测试</a>，我们应该小心不要过度解读它。</p>
<p>对于一些更复杂的AssemblyScript基准，我推荐查看<a href="https://wasmboy.app/benchmark/">这是一个波动方程基准</a>和<a href="https://jtiscione.github.io/webassembly-wave/index.html">这是一个波动方程基准</a>。</p>
<h3>加载模块</h3>
<p>接下来，让我们在一个网站中使用我们的模块。创建<code>index.html</code>:</p>
<pre>&lt;!DOCTYPE html&gt;
&lt;html&gt;
    &lt;head&gt;
        &lt;meta charset="utf-8" /&gt;
        &lt;title&gt;AssemblyScript isPrime demo&lt;/title&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;form id="prime-checker"&gt;
            &lt;label for="number"&gt;Enter a number to check if it is prime:&lt;/label&gt;
            &lt;input name="number" type="number" /&gt;
            &lt;button type="submit"&gt;Submit&lt;/button&gt;
        &lt;/form&gt;

        &lt;p id="result"&gt;&lt;/p&gt;

        &lt;script src="demo.js"&gt;&lt;/script&gt;
    &lt;/body&gt;
&lt;/html&gt;</pre>
<p>创建<code>demo.js</code>。加载WebAssembly模块的<a href="https://developers.google.com/web/updates/2018/04/loading-wasm">有多种方式</a>，但最有效的是用<code><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WebAssembly/instantiateStreaming" target="_blank" rel="noopener noreferrer">WebAssembly.instantiateStreaming</a></code>函数以流的方式编译和实例化它们。注意，我们需要<a href="https://docs.assemblyscript.org/details/debugging#overriding-abort">提供一个中止函数</a>，如果<a href="https://docs.assemblyscript.org/basics/environment#utility">断言</a>失败，就会调用这个函数。</p>
<pre>(async () =&gt; {
    const importObject = {
        env: {
            abort(_msg, _file, line, column) {
                console.error("abort called at index.ts:" + line + ":" + column);
            }
        }
    };
    const module = await WebAssembly.instantiateStreaming(
        fetch("build/optimized.wasm"),
        importObject
    );
    const isPrime = module.instance.exports.isPrime;

    const result = document.querySelector("#result");
    document.querySelector("#prime-checker").addEventListener("submit", event =&gt; {
        event.preventDefault();
        result.innerText = "";
        const number = event.target.elements.number.value;
        result.innerText = `${number} is ${isPrime(number) ? '' : 'not '}prime.`;
    });
})();</pre>
<p>现在安装<a href="https://github.com/nbluis/static-server">静态服务器</a>。我们需要一个服务器，因为为了使用<code>WebAssembly.instantiateStreaming</code>，模块需要使用<code>application/wasm</code>的<a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types"> MIME类型</a>。</p>
<pre>npm install --save-dev static-server
</pre>
<p>向<code>package.json</code>添加脚本。</p>
<pre>{
  "scripts": {
    "serve-demo": "static-server"
  }
}</pre>
<p>运行<code>npm run serve-demo</code>并在浏览器中打开本地主机URL。在表单中提交一个数字，您应该会得到一条消息，表明这个数字是否是质数。现在我们已经从编写AssemblyScript一路走到了在网站中实际使用它。</p>
<h2>结论</h2>
<p>WebAssembly和AssemblyScript不会神奇地让每个网站都变得更快，但这从来都不是重点。WebAssembly令人兴奋，因为它可以使web适用于更多的应用程序。</p>
<p>类似地，AssemblyScript使更多的开发人员可以访问WebAssembly，这使得我们可以很容易地在默认情况下坚持使用JavaScript，但当我们有需要大量数字处理的工作时，就引入WebAssembly。</p><div class="code-block code-block-21">
<div class="blog-plug inline-plug typescript-plug"><h2><a class="signup" href="https://lp.logrocket.com/blg/typescript-signup" target="_blank" rel="noopener noreferrer"> LogRocket </a>:全面了解您的网络和移动应用</h2>
<a href="https://lp.logrocket.com/blg/typescript-signup" class="signup" target="_blank" rel="noopener noreferrer"><img class="alignnone size-full wp-image-46 jetpack-lazy-image" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/><noscript><img data-lazy-fallback="1" class="alignnone size-full wp-image-46" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/></noscript></a>
<p>LogRocket 是一个前端应用程序监控解决方案，可以让您回放问题，就像问题发生在您自己的浏览器中一样。LogRocket不需要猜测错误发生的原因，也不需要向用户询问截图和日志转储，而是让您重放会话以快速了解哪里出错了。它可以与任何应用程序完美配合，不管是什么框架，并且有插件可以记录来自Redux、Vuex和@ngrx/store的额外上下文。</p>
<p>除了记录Redux操作和状态，LogRocket还记录控制台日志、JavaScript错误、堆栈跟踪、带有头+正文的网络请求/响应、浏览器元数据和自定义日志。它还使用DOM来记录页面上的HTML和CSS，甚至为最复杂的单页面和移动应用程序重新创建像素级完美视频。</p>
<a class="signup" href="https://lp.logrocket.com/blg/typescript-signup" target="_blank" rel="noopener noreferrer">Try it for free</a><p>.</p></div>
</div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
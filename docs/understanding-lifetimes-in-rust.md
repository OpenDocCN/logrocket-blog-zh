# 理解 Rust 中的生命周期

> 原文：<https://blog.logrocket.com/understanding-lifetimes-in-rust/>

所以你决定再次尝试解决生锈的问题。上一次进行得相当顺利，除了与[借款检查器](https://blog.logrocket.com/introducing-the-rust-borrow-checker/)的一些小问题。但是你熬过来了，并且对它在这个过程中是如何运作的有了更好的理解。也许到头来一切都值了？

你已经有了一些宏伟的计划，你不会让借款检查阻止你。当你把你的想法印在键盘上并转化成纯粹的铁锈时，你几乎可以感觉到能量在你的血管中流动。这一定是你久闻的甜蜜感觉。

您保存您的项目，开始编译过程，然后…

```
error[E0597]: `x` does not live long enough

```

你叹气。不要再这样了。

你深吸一口气，放下肩膀，再次阅读错误信息。"活得不够久"这到底是什么意思？

你已经遇到了 Rust 的另一个特性:寿命。

## 生命周期简介

Rust 编译器使用生存期来跟踪引用的有效期。检查证明资料是借货检查员的主要职责之一。生存期有助于借用检查器确保您永远不会有无效的引用。

生存期注释使您能够告诉借用检查器引用的有效时间。在许多情况下，借用检查器可以推断出正确的寿命，并自行处理一切。但通常需要你的帮助才能弄明白。

在本指南中，我们将回顾生存期和注释的基础知识，并演示如何使用它们。我们还将看看您可能遇到的一些常见场景，并演示如何用生存期来解决它们。要继续学习，您应该对 Rust 和它的一些概念有一个基本的了解(比如借用检查器)，但是不要特别深入。

### 生存期注释

在我们进一步讨论之前，先简要说明一下生命周期的符号，因为它与其他语言中的符号有些不同。

生存期由一个前导撇号标注，后跟一个变量名。当谈到泛型生存期时，我们经常使用单个小写字母，从`'a`、`'b`等开始。然而，如果更适合你，没有什么可以阻止你使用更长、更有解释力的名字。

### 为什么我们需要寿命

如果这是一个如此奇怪的特性，那么我们为什么需要寿命呢？答案在于 Rust 的所有权模型。借用检查器负责分配和释放内存，并确保没有引用指向已被释放的内存。像借用一样，生存期在编译时被检查，这意味着如果借用检查器认为引用无效，你的程序就不能编译。

特别是，当从函数返回引用以及创建带有引用的结构时，记住生存期非常重要。这两种情况都很常见，不明白怎么回事就容易迷路。

### 解释性的例子

最终，生存期是一个范围问题。当值超出范围时，它们会被删除，删除后对它们的任何引用都是无效的。

演示生命周期的最简单的方法就是下面这个例子，它无耻地剽窃/改编自官方书籍中关于生命周期的章节。

```
// this code sample does *not* compile
{
    let x;
    {                           // create new scope
        let y = 42;
        x = &y;
    }                           // y is dropped

    println!("The value of 'x' is {}.", x);
}

```

这段代码有两个不同的范围。当内部作用域关闭时，`y`被删除。此时，即使`x`在外部作用域中仍然可用，引用也是无效的，因为它所指向的值被丢弃了；`x`所指的价值“活得不够久”

用生存期术语来说，我们可以说外部作用域有生存期`'outer`，内部作用域有生存期`'inner`。在这种情况下，`'outer`显然比`'inner`活得长。当`'inner`结束时，所有具有该生命周期的值都失效。

### 一生的梦想

当编写接受引用作为参数的函数时，编译器可以在许多情况下推断出正确的生存期，从而省去您手动写出它们的麻烦。当生存期注释是隐式的时，我们称之为生存期省略。

编译器使用三个规则来判断是否可以省略生存期注释。这本书关于生存期省略的部分详细讨论了这些规则，但简短的形式是，如果下列情况之一为真，您可以在函数中省略生存期注释。

*   该函数不返回引用
*   只有一个参考输入参数
*   该函数是一个方法，将`&self`或`&mut self`作为第一个参数

## 示例和常见问题

一生是很难理解的，一墙的文字不太可能真正帮助你理解它们是如何工作的。当然，获得正确理解的最好方法是自己体验生命周期并解决问题。也就是说，举几个例子就够了。

### 从函数返回引用

如果没有传入引用，就不能从函数返回引用。如果你尝试的话，你会发现函数一返回，引用就无效了，你的程序就不能编译了。你可以使用`'static`寿命，但这可能不是你想要的。这也超出了本文的范围，所以让我们暂时忘记它。

* * *

### 更多来自 LogRocket 的精彩文章:

* * *

如果你的函数只有一个引用参数，那么没有注释也没问题。所有输出参考将被赋予与输入参数相同的寿命。因此，即使没有显式的生存期注释，这个简单的函数也可以很好地编译。

```
fn f(s: &str) -> &str {
    s
}

```

但是，如果您添加另一个输入字符串参数(即使您不使用它)，您将突然无法编译这个:

```
// this code sample does *not* compile
fn f(s: &str, t: &str) -> &str {
    if s.len() > 5 { s } else { t }
}

```

这是因为自动生命周期注释是如何工作的。当一个函数接受多个引用时，每个引用都有自己的
生存期。我们知道返回的引用必须是作为输入参数接收的引用之一，但我们不知道是哪一个。下面的`'???`用什么代替？

```
// this code sample does *not* compile
fn f<'a, 'b>(s: &'a str, t: &'b str) -> &'??? str {
    if s.len() > 5 { s } else { t }
}

```

假设您想在这个函数之外使用返回值。你认为它的寿命有多长？唯一的保证是，返回的引用至少在传递给函数的最短引用期间有效。这告诉编译器，这两个引用在较短的生存期内肯定有效。除此之外没有任何保证。

实现这一点的方法是给两个输入参数相同的生存期注释。这就是我们如何告诉编译器，只要这两个输入参数都有效，返回值也有效。

```
fn f<'a>(s: &'a str, t: &'a str) -> &'a str {
    if s.len() > 5 { s } else { t }
}

```

如果从一个接受多个输入生存期参数的函数返回一个引用，但是您确切地知道要返回哪个参数，那么您可以对该特定生存期进行注释。这样，各世之间的关系就不重要了。

```
fn f<'a, 'b>(s: &'a str, _t: &'b str) -> &'a str {
    s
}

```

### 带有引用的 struts

结构中的引用可能会很麻烦。你最好避开它们，转而使用自己的价值观。这样，您就不需要担心引用失效和生存期不够长。以我的经验，这通常也是你想要的。

但是，在某些情况下，带有引用的结构正是您想要的—特别是，如果您想要创建其他内容的视图。使用带有引用的结构是将一些数据组织到一个包中的好方法，这样不用移动或复制数据就可以更容易地处理。这意味着原始数据源仍然可以在其他地方被引用，这样就免去了克隆数据的麻烦。

例如，假设您想要找到一个段落的第一句和最后一句，并将它们保存在 struct `S`中。因为不想复制数据，所以需要使用引用，并给它们终身注释。

```
struct S<'a> {
    first: &'a str,
    last: &'a str,
}

```

您可以使用这样的函数来填充该结构。为了简单起见，我们假设句号是唯一使用的句尾标点符号。如果段落是空的，返回`None`，如果只有一个句子，使用它作为第一个和最后一个句子。

```
fn try_create(paragraph: &str) -> Option<S> {
    let mut sentences = paragraph.split('.').filter(|s| !s.is_empty());
    match (sentences.next(), sentences.next_back()) {
        (Some(first), Some(last)) => Some(S { first, last }),
        (Some(first), None) => Some(S { first, last: first }),
        _ => None,
    }
}

```

您不需要在函数签名中标注生存期，因为编译器可以为您找出它。在这种情况下，实际上只有一种选择:输入字符串的生存期。很整洁，是吧？

## 总结和进一步阅读

这只是对生存期和生存期注释的粗略浏览。我们掩饰了很多关于生命周期如何工作的更好更复杂的细节，但是我们覆盖了足够多的领域，当你遇到问题时，你应该能够对它们进行推理。

因为生存期是 Rust 如此重要的一部分，我鼓励您阅读“[Rust 编程语言](https://doc.rust-lang.org/book/title-page.html)”的“[用生存期验证引用](https://doc.rust-lang.org/book/ch10-03-lifetime-syntax.html)”一章，以获得更全面的介绍。

此外，如果你觉得自己已经对生命周期有了很好的理解，但还想更深入一点，可以看看 Jon Gjengset 的精彩视频，
[Rust Crust:Lifetime Annotations](https://youtu.be/rAl-9HwD858)，他在视频中探索了一个需要多个显式生命周期注释的案例。他还从总体上对终身注释做了很好的介绍，因此值得一看。

## [log rocket](https://lp.logrocket.com/blg/rust-signup):Rust 应用的 web 前端的全面可见性

调试 Rust 应用程序可能很困难，尤其是当用户遇到难以重现的问题时。如果您对监控和跟踪 Rust 应用程序的性能、自动显示错误、跟踪缓慢的网络请求和加载时间感兴趣，

[try LogRocket](https://lp.logrocket.com/blg/rust-signup)

.

[![LogRocket Dashboard Free Trial Banner](img/d6f5a5dd739296c1dd7aab3d5e77eeb9.png)](https://lp.logrocket.com/blg/rust-signup)

LogRocket 就像是网络和移动应用程序的 DVR，记录你的 Rust 应用程序上发生的一切。您可以汇总并报告问题发生时应用程序的状态，而不是猜测问题发生的原因。LogRocket 还可以监控应用的性能，报告客户端 CPU 负载、客户端内存使用等指标。

现代化调试 Rust 应用的方式— [开始免费监控](https://lp.logrocket.com/blg/rust-signup)。
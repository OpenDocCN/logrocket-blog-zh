<html>
<head>
<title>Experimental React: Using Suspense for data fetching - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>实验反应:使用悬念获取数据</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/react-suspense-data-fetching/#0001-01-01">https://blog.logrocket.com/react-suspense-data-fetching/#0001-01-01</a></blockquote><div><article class="article-post">
<p><em> <strong>编者按:</strong>本文于2022年3月16日更新，包含React 18发布前React悬念的最新更新。</em></p>
<p>随着时间的推移，管理前端应用程序中的数据加载会变得非常复杂。以至于有一整个图书馆生态系统致力于国家管理以对抗它。</p>
<p>React核心团队意识到了这一点，并通过开发一组并发特性来使React中的数据获取更加容易。<a href="https://17.reactjs.org/blog/2019/11/06/building-great-user-experiences-with-concurrent-mode-and-suspense.html" target="_blank" rel="noopener">悬念</a>就是其中之一，它旨在简化React组件中加载状态的管理。</p>
<p>在本文中，我们将通过创建一个从API获取数据并将其呈现到DOM的简单应用程序来了解悬念是如何工作的。</p>
<blockquote><p>注意:在撰写本文时，数据获取的暂记仍处于试验阶段，当它变得稳定时，API可能已经发生了显著的变化。</p></blockquote>
<h3>内容</h3>

<h2 id="what-is-react-suspense">什么是反应悬疑？</h2>
<p><a href="https://github.com/reactjs/rfcs/blob/main/text/0213-suspense-in-react-18.md" target="_blank" rel="noopener">悬念</a>是React应用中管理异步操作的一个特性。它让您的组件进行通信，以反应它们正在等待一些数据。</p>
<p>需要注意的是，悬念不是像<a href="https://github.com/ghengeveld/react-async" target="_blank" rel="noopener"> react-async </a>那样的数据获取库，也不是像<a href="https://blog.logrocket.com/understanding-redux-saga-action-creators-sagas/" target="_blank" rel="noopener"> Redux </a>那样的管理状态的方式。它只是让您在组件等待某个异步操作(即网络请求)完成时以声明方式呈现回退。</p>
<p>正如我们将进一步看到的，这允许我们跨不同组件同步加载状态，从而为用户提供更好的用户体验。它以一种非侵入性的方式做到这一点，不需要完全重写现有的应用程序。</p>
<h2 id="how-to-use-suspense">如何利用悬念</h2>
<p>让我们看一下最简单的悬念用例，它是在一个组件中处理一个挂起的网络请求:</p>
<pre class="language-javascript hljs">const [todos, isLoading] = fetchData('/todos')

if (isLoading) {
  return &lt;Spinner /&gt;
}

return &lt;Todos data={todos} /&gt;
</pre>
<p>这应该看起来很熟悉，因为这是大多数人(包括我)处理等待网络呼叫的方式。<code>fetchData</code>功能、<code>Spinner</code>和<code>Todos</code>组件的实现与此无关。</p>
<p>变量<code>isLoading</code>用于跟踪请求的状态。如果<code>true</code>，我们渲染一个微调器，向用户传达这个状态。这样做绝对没有错，但是让我们看看如何利用悬念来处理这个问题:</p>
<pre class="language-javascript hljs">const todos = fetchData('/todos')

return (
  &lt;Suspense fallback={&lt;Spinner /&gt;}&gt;
    &lt;Todos data={todos} /&gt;
  &lt;/Suspense&gt;
)
</pre>
<p>代码有一个微妙但重要的变化。不是将加载状态作为一个状态变量，通过逻辑根据值来呈现微调器，而是由React使用悬念来管理。我们现在以声明方式呈现回退。</p>
<p>在前面的例子中，React不知道网络调用，所以我们必须使用<code>isLoading</code>变量来管理加载状态。在这个例子中，React知道一个网络调用正在发生，通过暂停包装<code>Todos</code>组件，它延迟呈现它，直到网络调用完成。</p>
<p>另一个需要注意的重要事情是传递给悬念的<code>fallback</code>属性。这就是我们在等待网络调用结束时想要呈现的内容。它可能是一个旋转器，骨骼装载机，或只是简单的什么都没有。</p>
<p>React将在等待网络请求完成时呈现<code>fallback</code>的值。</p>
<p>然而，React究竟是如何知道网络调用正在进行的呢？到目前为止，我们所经历的悬念只是在等待时呈现一个后备组件。我们在代码中的什么地方进行通信来对我们正在进行的网络调用做出反应？</p>
<p>这就是数据提取库的用武之地。目前，<a href="https://relay.dev/docs/guided-tour/rendering/loading-states/#internaldocs-banner" target="_blank" rel="noopener">继电器</a>和<a href="https://swr.vercel.app/docs/suspense" target="_blank" rel="noopener"> SWR </a>都集成了悬念，以传达负载状态做出反应。我想将来会有更多的库作者添加集成。</p>
<p>到目前为止我们学到了什么？暂停让React可以访问我们的应用程序中的挂起状态。这允许我们在等待时以声明方式呈现回退组件。</p>
<p>接下来，让我们探索一些常见的数据获取方法，它们的局限性，以及悬念如何改善开发人员和用户的体验。然后，我们将使用悬念构建一个应用程序来管理网络请求的加载状态。最后，我们将把所有这些联系起来，并对悬念提供的一些好处进行实践探索。</p>
<h2 id="data-fetching-approaches">数据获取方法</h2>
<p>如果一个React组件需要来自API的一些数据，我们通常必须在某个地方发出网络请求来检索它。这就是<a href="https://blog.logrocket.com/patterns-for-data-fetching-in-react-981ced7e5c56/" target="_blank" rel="noopener">数据获取方法</a>发挥作用的地方。</p>
<h3 id="fetch-on-render">渲染时提取</h3>
<p>使用这种方法，网络请求在安装后在组件本身中触发。</p>
<p>之所以称之为呈现时提取，是因为直到组件呈现时请求才被触发，在某些情况下，这可能会导致一个称为“瀑布”的问题考虑下面的例子:</p>
<pre class="language-javascript hljs">const App = () =&gt; {
  const [userDetails, setUserDetails] = useState({})

  useEffect(() =&gt; {
    fetchUserDetails().then(setUserDetails)
  }, [])

  if (!userDetails.id) return &lt;p&gt;Fetching user details...&lt;/p&gt;

  return (
    &lt;div className="app"&gt;
      &lt;h2&gt;Simple Todo&lt;/h2&gt;

      &lt;UserWelcome user={userDetails} /&gt;
      &lt;Todos /&gt;
    &lt;/div&gt;
  )
}
</pre>
<p>这看起来非常类似于当我有一个组件需要来自API的数据时我通常会做的事情，但是这有一个问题。</p>
<p>如果嵌套的<code>Todos</code>组件也需要从API获取一些数据，那么它必须等到<code>fetchUserDetails()</code>解析。如果这需要三秒钟，那么<code>&lt;Todos/&gt;</code>将不得不在开始获取自己的数据之前等待三秒钟，而不是让两个请求并行发生。</p>
<p>检查<strong>网络</strong>选项卡清楚地显示了这一点，其中第二个请求仅在第一个请求完成后发生。</p>
<p><img data-attachment-id="101693" data-permalink="https://blog.logrocket.com/react-suspense-data-fetching/waterfall-networks-tab/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2019/11/waterfall-networks-tab.png" data-orig-size="730,95" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="waterfall networks tab" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2019/11/waterfall-networks-tab-300x39.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2019/11/waterfall-networks-tab.png" decoding="async" class="size-full wp-image-101693 aligncenter jetpack-lazy-image" src="../Images/9501c0816b5a1347a5e6017665a7e827.png" alt="waterfall networks tab" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2019/11/waterfall-networks-tab.png 730w, https://blog.logrocket.com/wp-content/uploads/2019/11/waterfall-networks-tab-300x39.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2019/11/waterfall-networks-tab.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/11/waterfall-networks-tab.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="101693" data-permalink="https://blog.logrocket.com/react-suspense-data-fetching/waterfall-networks-tab/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2019/11/waterfall-networks-tab.png" data-orig-size="730,95" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="waterfall networks tab" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2019/11/waterfall-networks-tab-300x39.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2019/11/waterfall-networks-tab.png" decoding="async" loading="lazy" class="size-full wp-image-101693 aligncenter" src="../Images/9501c0816b5a1347a5e6017665a7e827.png" alt="waterfall networks tab" srcset="https://blog.logrocket.com/wp-content/uploads/2019/11/waterfall-networks-tab.png 730w, https://blog.logrocket.com/wp-content/uploads/2019/11/waterfall-networks-tab-300x39.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/11/waterfall-networks-tab.png"/></noscript>
<p>在一个组件中，有相当数量的其他组件各自进行自己的异步调用，这可能会导致缓慢而笨拙的用户体验。</p>
<p>当然，我们可以让<code>UserWelcome</code>组件处理它自己的数据获取，但是这里重要的概念是协调网络请求的想法，正如我们将在下面看到的，悬念使这不成问题。</p>
<h3 id="fetch-then-render">提取然后渲染</h3>
<p>使用这种方法，我们在组件呈现之前发出异步请求。让我们回到上一个例子，看看我们将如何修复它:</p>
<pre class="language-javascript hljs">const fetchDataPromise = fetchUserDetailsAndTodos() // We start fetching here

const App = () =&gt; {
  const [userDetails, setUserDetails] = useState({})
  const [todos, setTodos] = useState([])

  useEffect(() =&gt; {
    fetchDataPromise.then((data) =&gt; {
      setUserDetails(data.userDetails)
      setTodos(data.todos)
    })
  }, [])

  return (
    &lt;div className="app"&gt;
      &lt;h2&gt;Simple Todo&lt;/h2&gt;

      &lt;UserWelcome user={userDetails} /&gt;
      &lt;Todos todos={todos} /&gt;
    &lt;/div&gt;
  )
}
</pre>
<p>在这种情况下，我们将获取逻辑移到了<code>App</code>组件之外，这样网络请求甚至在组件安装之前就开始了。我们做的另一个改变是<code>&lt;Todos/&gt;</code>不再触发它自己的异步请求。而是从父<code>App</code>组件获取所需的数据。</p>
<p>检查<strong> networks </strong>选项卡可以清楚地看到两个请求是同时开始的，但是这里有一个微妙的问题，乍一看可能不那么明显。</p>
<p><img data-attachment-id="101695" data-permalink="https://blog.logrocket.com/react-suspense-data-fetching/fetch-then-render-networks-tab/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2019/11/fetch-then-render-networks-tab.png" data-orig-size="730,93" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="fetch then render networks tab" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2019/11/fetch-then-render-networks-tab-300x38.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2019/11/fetch-then-render-networks-tab.png" decoding="async" class="size-full wp-image-101695 aligncenter jetpack-lazy-image" src="../Images/8116b4fb0e0afefe3f146feafd839d0a.png" alt="fetch then render networks tab" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2019/11/fetch-then-render-networks-tab.png 730w, https://blog.logrocket.com/wp-content/uploads/2019/11/fetch-then-render-networks-tab-300x38.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2019/11/fetch-then-render-networks-tab.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/11/fetch-then-render-networks-tab.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="101695" data-permalink="https://blog.logrocket.com/react-suspense-data-fetching/fetch-then-render-networks-tab/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2019/11/fetch-then-render-networks-tab.png" data-orig-size="730,93" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="fetch then render networks tab" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2019/11/fetch-then-render-networks-tab-300x38.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2019/11/fetch-then-render-networks-tab.png" decoding="async" loading="lazy" class="size-full wp-image-101695 aligncenter" src="../Images/8116b4fb0e0afefe3f146feafd839d0a.png" alt="fetch then render networks tab" srcset="https://blog.logrocket.com/wp-content/uploads/2019/11/fetch-then-render-networks-tab.png 730w, https://blog.logrocket.com/wp-content/uploads/2019/11/fetch-then-render-networks-tab-300x38.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/11/fetch-then-render-networks-tab.png"/></noscript>
<p>让我们假设<code>fetchUserDetailsAndTodos</code>看起来像这样:</p>
<pre class="language-javascript hljs">function fetchUserDetailsAndTodos() {
  return Promise.all([fetchUserDetails(), fetchTodos()])
    .then(([userDetails, todos]) =&gt; ({ userDetails, todos }))
}
</pre>
<p>虽然<code>fetchUserDetails</code>和<code>fetchTodos()</code>都是并行启动的，但是在我们呈现任何有用的数据之前，我们仍然需要等待两者之间较慢的请求完成。</p>
<p>如果<code>fetchTodos()</code>需要200毫秒来解析，而<code>fetchUserDetails()</code>需要900毫秒来解析，<code>&lt;Todos /&gt;</code>在渲染之前仍然需要额外等待700毫秒，尽管它的数据已经准备就绪。</p>
<p>这是因为<code>Promise.all</code>要等到所有的承诺都解决了才解析。当然，我们可以通过移除<code>Promise.all</code>并分别等待两个请求来解决这个问题，但是随着应用程序的增长，这很快就会变得很麻烦。</p>
<p>还有一个事实是，父组件现在必须管理<code>UserWelcome</code>和<code>Todos</code>的状态。这在开发人员和用户体验方面都不太好。</p>
<h3 id="render-as-you-fetch">随取随渲染</h3>
<p>这可以说是悬念给反应带来的最重要的好处。这允许您以简单的方式解决我们在其他方法中遇到的问题。它允许我们在触发网络请求后立即开始呈现组件。</p>
<p>这意味着，就像获取然后渲染一样，我们在渲染之前开始获取，但我们不必在开始渲染之前等待响应。让我们看一些代码:</p>
<pre class="language-javascript hljs">const data = fetchData() // this is not a promise (we'll implement something similar)

const App = () =&gt; (
  &lt;&gt;
    &lt;Suspense fallback={&lt;p&gt;Fetching user details...&lt;/p&gt;}&gt;
      &lt;UserWelcome /&gt;
    &lt;/Suspense&gt;

    &lt;Suspense fallback={&lt;p&gt;Loading todos...&lt;/p&gt;}&gt;
      &lt;Todos /&gt;
    &lt;/Suspense&gt;
  &lt;/&gt;
)

const UserWelcome = () =&gt; {
  const userDetails = data.userDetails.read()
  // code to render welcome message
}

const Todos = () =&gt; {
  const todos = data.todos.read()
  // code to map and render todos
}
</pre>
<p>这段代码可能看起来有点陌生，但并没有那么复杂。大多数工作实际上发生在<code>fetchData()</code>函数中，我们将看到如何进一步实现类似的东西。但是现在，让我们看看代码的其余部分。</p>
<p>首先，我们在第一行呈现任何组件之前触发网络请求。在主<code>App</code>组件中，我们将<code>UserWelcome</code>和<code>Todos</code>组件包装在单独的<code>Suspense</code>组件中，它们有自己的后备。</p>
<p>当<code>App</code>第一次挂载时，它试图先渲染<code>UserWelcome</code>，这触发了<code>data.userDetails.read()</code>线。如果数据还没有准备好(也就是说，请求还没有解决)，它将被传递回悬念，然后由悬念呈现<code>&lt;p&gt;Fetching user details…&lt;/p&gt;</code>。同样的事情也发生在<code>Todos</code>身上。</p>
<p>回退将一直呈现到数据准备就绪，然后呈现组件。这种方法的好处是没有一个组件必须等待另一个。一旦任何组件接收到完整的数据，不管另一个组件的请求是否得到解决，它都会被呈现。</p>
<p>我们保留了很好的并行网络请求，呈现代码看起来也更简洁，因为我们消除了查看所需数据是否存在的<code>if</code>检查。</p>
<p><img data-attachment-id="101697" data-permalink="https://blog.logrocket.com/react-suspense-data-fetching/render-as-you-fetch-networks-tab/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2019/11/render-as-you-fetch-networks-tab.png" data-orig-size="858,148" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="render as you fetch networks tab" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2019/11/render-as-you-fetch-networks-tab-300x52.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2019/11/render-as-you-fetch-networks-tab.png" decoding="async" class="size-full wp-image-101697 aligncenter jetpack-lazy-image" src="../Images/9d3a31d2ad8179831def3a3855b4170a.png" alt="render as you fetch networks tab" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2019/11/render-as-you-fetch-networks-tab.png 858w, https://blog.logrocket.com/wp-content/uploads/2019/11/render-as-you-fetch-networks-tab-300x52.png 300w, https://blog.logrocket.com/wp-content/uploads/2019/11/render-as-you-fetch-networks-tab-768x132.png 768w" data-lazy-sizes="(max-width: 858px) 100vw, 858px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2019/11/render-as-you-fetch-networks-tab.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/11/render-as-you-fetch-networks-tab.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="101697" data-permalink="https://blog.logrocket.com/react-suspense-data-fetching/render-as-you-fetch-networks-tab/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2019/11/render-as-you-fetch-networks-tab.png" data-orig-size="858,148" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="render as you fetch networks tab" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2019/11/render-as-you-fetch-networks-tab-300x52.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2019/11/render-as-you-fetch-networks-tab.png" decoding="async" loading="lazy" class="size-full wp-image-101697 aligncenter" src="../Images/9d3a31d2ad8179831def3a3855b4170a.png" alt="render as you fetch networks tab" srcset="https://blog.logrocket.com/wp-content/uploads/2019/11/render-as-you-fetch-networks-tab.png 858w, https://blog.logrocket.com/wp-content/uploads/2019/11/render-as-you-fetch-networks-tab-300x52.png 300w, https://blog.logrocket.com/wp-content/uploads/2019/11/render-as-you-fetch-networks-tab-768x132.png 768w" sizes="(max-width: 858px) 100vw, 858px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/11/render-as-you-fetch-networks-tab.png"/></noscript>
<p>现在让我们构建一个简单的应用程序来实现这些概念，并看看我们如何实现上面的<code>fetchData()</code>函数。</p>
<h2 id="building-sample-app-react-suspense">使用React悬念构建示例应用程序</h2>
<p>我们将构建一个简单的应用程序，从API获取一些数据，并将其呈现到DOM，但我们将利用悬念和即取即呈现的方法。我假设你已经熟悉React钩子；否则，你可以在这里得到一个快速介绍<a href="https://blog.logrocket.com/react-hooks-cheat-sheet-unlock-solutions-to-common-problems-af4caf699e70/" target="_blank" rel="noopener">。</a><a href="https://github.com/ovieokeh/suspense-data-fetching" target="_blank" rel="noopener">本文的所有代码都可以在这里找到</a>。</p>
<p><img data-attachment-id="101699" data-permalink="https://blog.logrocket.com/react-suspense-data-fetching/finished-to-do-app-2/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2019/11/Finished-to-do-app.png" data-orig-size="730,675" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Finished to do app" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2019/11/Finished-to-do-app-300x277.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2019/11/Finished-to-do-app.png" decoding="async" class="size-full wp-image-101699 aligncenter jetpack-lazy-image" src="../Images/fa7191ce8c235768a62d1cfe07befeef.png" alt="Finished to do app" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2019/11/Finished-to-do-app.png 730w, https://blog.logrocket.com/wp-content/uploads/2019/11/Finished-to-do-app-300x277.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2019/11/Finished-to-do-app.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/11/Finished-to-do-app.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="101699" data-permalink="https://blog.logrocket.com/react-suspense-data-fetching/finished-to-do-app-2/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2019/11/Finished-to-do-app.png" data-orig-size="730,675" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Finished to do app" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2019/11/Finished-to-do-app-300x277.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2019/11/Finished-to-do-app.png" decoding="async" loading="lazy" class="size-full wp-image-101699 aligncenter" src="../Images/fa7191ce8c235768a62d1cfe07befeef.png" alt="Finished to do app" srcset="https://blog.logrocket.com/wp-content/uploads/2019/11/Finished-to-do-app.png 730w, https://blog.logrocket.com/wp-content/uploads/2019/11/Finished-to-do-app-300x277.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/11/Finished-to-do-app.png"/></noscript>
<h3 id="setup">设置</h3>
<p>让我们创建所有的文件和文件夹，并安装所需的软件包。我们会边走边填充内容。</p>
<p>运行以下命令来设置项目结构:</p>
<pre class="language-shell hljs">mkdir suspense-data-fetching &amp;&amp; cd suspense-data-fetching
mkdir -p lib/{api,components} public
touch public/index.html public/index.css
cd lib/ &amp;&amp; touch index.jsx
touch api/fetchData.js api/wrapPromise.js
cd components/
touch App.jsx UserWelcome.jsx Todos.jsx
</pre>
<p>现在让我们安装所需的依赖项:</p>
<pre class="language-shell hljs">npm install <a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="a7d5c2c6c4d3e7d5c4">[email protected]</a> <a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="dcaeb9bdbfa8f1b8b3b19caebf">[email protected]</a>
npm install --save-dev parcel parcel-bundler
</pre>
<p>请注意，我们正在安装<code>react</code>和<code>react-dom</code>的“发布候选”版本。这是因为数据获取的悬念还不稳定，所以您需要手动选择加入。</p>
<p>我们正在安装<code>parcel</code>和<code>parcel-bundler</code>来帮助我们将代码转换成浏览器能够理解的东西。我选择package而不是webpack之类的东西的原因是因为它不需要任何配置，而且运行得非常好。</p>
<p>接下来，在<code>package.json</code>中添加以下部分:</p>
<pre class="language-json hljs">"scripts": {
  "dev": "parcel public/index.html -p 4000"
},
</pre>
<p>既然我们已经准备好了项目结构并安装了所需的依赖项，让我们开始编写一些代码。为了保持教程简洁，我将省略以下文件的代码，您可以从链接的repo中获得这些代码:</p>

<h2 id="api">应用程序接口</h2>
<p>让我们从<code>api</code>文件夹中的文件开始。</p>
<h3 id="wrappromise-js"><code>wrapPromise.js</code></h3>
<p>这可能是整个教程中最重要的部分，因为这是与悬念交流的内容，也是任何为悬念API编写抽象的库作者将花费大部分时间的内容。</p>
<p><code>wrapPromise.js</code>是一个包装器，它包装了一个承诺，并提供了一种方法，允许您确定从承诺返回的数据是否可以读取。如果承诺解析，则返回解析的数据；如果它拒绝，它抛出错误；如果它仍然是未决的，它抛出承诺。</p>
<p>这个Promise参数通常是一个从API中检索一些数据的网络请求，但是从技术上讲，它可以是任何Promise对象。实际的实现留给实现它的人去解决，所以您可能会找到其他方法来实现它。</p>
<p><code>wrapPromise</code>功能有以下要求:</p>
<ul>
<li>它把承诺当作论据</li>
<li>当承诺被解析时，它返回解析的值</li>
<li>当承诺被拒绝时，它抛出被拒绝的值</li>
<li>当承诺仍处于待定状态时，它会抛出承诺</li>
<li>它公开了一个读取承诺状态的方法</li>
</ul>
<p>定义了需求之后，是时候写一些代码了。打开<code>api/wrapPromise.js</code>文件，我们就可以开始了:</p>
<pre class="language-javascript hljs">function wrapPromise(promise) {
  let status = 'pending'
  let response

  const suspender = promise.then(
    (res) =&gt; {
      status = 'success'
      response = res
    },
    (err) =&gt; {
      status = 'error'
      response = err
    },
  )

...to be continued...
</pre>
<p>这里发生了什么事？在<code>wrapPromise</code>函数中，我们定义了两个变量:</p>
<ol>
<li><code>status</code>，跟踪promise参数的状态</li>
<li><code>response</code>，保存承诺的结果(无论是解决还是拒绝)</li>
</ol>
<p>默认情况下,<code>status</code>被初始化为“待定”,因为这是任何新承诺的默认状态。然后，我们初始化一个新变量<code>suspender</code>，将其值设置为Promise，并为其附加一个<code>then</code>方法。</p>
<p>在这个<code>then</code>方法中，我们有两个回调函数:第一个处理解析的值，第二个处理拒绝的值。如果承诺成功解析，我们将变量<code>status</code>更新为“成功”,并将变量<code>response</code>设置为解析后的值。</p>
<p>如果承诺被拒绝，我们将变量<code>status</code>更新为“error ”,并将变量<code>response</code>设置为被拒绝的值。</p>
<pre class="language-javascript hljs">...continued from above...
  const read = () =&gt; {
    switch (status) {
      case 'pending':
        throw suspender
      case 'error':
        throw response
      default:
        return response
    }
  }

  return { read }
}

export default wrapPromise
</pre>
<p>接下来，我们创建一个名为<code>read</code>的新函数，在这个函数中，我们有一个<code>switch</code>语句来检查<code>status</code>变量的值。如果承诺的<code>status</code>是“待定”，我们抛出刚刚定义的<code>suspender</code>变量。如果是“错误”，我们抛出<code>response</code>变量。最后，如果它是除了这两个以外的任何东西(例如，“成功”)，我们返回<code>response</code>变量。</p>
<p>我们抛出<code>suspender</code>变量或错误<code>response</code>变量的原因是因为我们想要传达回承诺尚未解决的悬念。</p>
<p>我们通过模拟组件中的一个错误(使用<code><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/throw" target="_blank" rel="noopener">throw</a></code>)来做到这一点，这个错误将被悬念组件拦截。然后，暂记组件查看抛出的值，以确定它是一个实际的错误还是一个承诺。</p>
<p>如果它是一个承诺，悬念组件将识别出该组件仍在等待一些数据，它将呈现回退。如果这是一个错误，它会使错误冒泡回到最近的<a href="https://reactjs.org/docs/error-boundaries.html">错误边界</a>，直到它被捕获或者使应用程序崩溃。</p>
<p>在<code>wrapPromise</code>函数的末尾，我们返回一个包含<code>read</code>函数的对象作为方法，这是我们的React组件将与之交互以检索承诺值的对象。</p>
<p>最后，我们有一个默认的导出，这样我们可以在其他文件中使用<code>wrapPromise</code>函数。现在让我们继续讨论<code>fetchData.js</code>文件。</p>
<h3 id="fetchdata-js"><code>fetchData.js</code></h3>
<p>在这个文件中，我们将创建一个函数来获取组件所需的数据。它将返回一个用我们刚刚经历的<code>wrapPromise</code>函数包装的承诺:</p>
<pre class="language-javascript hljs">import wrapPromise from './wrapPromise'

function fetchData(url) {
  const promise = fetch(url)
    .then((res) =&gt; res.json())
    .then((res) =&gt; res.data)

  return wrapPromise(promise)
}

export default fetchData
</pre>
<p>我们在这里做的第一件事是导入我们刚刚创建的<code>wrapPromise</code>函数，然后定义一个函数<code>fetchData</code>。</p>
<p>在这个函数中，我们初始化一个新变量<code>promise</code>，并将其值设置为一个<a href="https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API/Using_Fetch">获取</a>请求承诺。当这个请求完成时，我们使用<code>res.json()</code>从<a href="https://developer.mozilla.org/en-US/docs/Web/API/Response" target="_blank" rel="noopener"> <code>Response</code>对象</a>获取数据，然后返回<code>res.data</code>，其中包含我们需要的数据。</p>
<p>最后，我们将这个<code>promise</code>传递给<code>wrapPromise</code>函数并返回它。在这个文件的最后，我们导出了<code>fetchData</code>函数。</p>
<h3 id="api-recap">API概述</h3>
<p>让我们回顾一下到目前为止我们所做的一切。我们定义了一个函数<code>wrapPromise</code>，它接收一个承诺，并根据该承诺的状态，或者抛出该承诺的拒绝值、该承诺本身，或者返回已解析的值。</p>
<p>然后，<code>wrapPromise</code>返回一个包含<code>read</code>方法的对象，该方法允许我们查询值(或者，如果没有解析，则查询承诺本身)。另一方面，<code>fetchData.js</code>包含一个使用<a href="https://blog.logrocket.com/fetch-api-node-js/" target="_blank" rel="noopener">获取API </a>从服务器获取数据的函数，并返回一个用<code>wrapPromise</code>函数包装的承诺。</p>
<p>现在来看组件！</p>
<h2 id="components">成分</h2>
<p>我们现在已经为我们的应用程序准备好了“后端”,所以是时候构建组件了。</p>
<h3 id="index-jsx"><code>index.jsx</code></h3>
<p>这是我们应用程序的入口点，我们将首先创建它。这是我们将React应用程序安装到DOM的地方:</p>
<pre class="language-javascript hljs">import React from 'react'
import ReactDOM from 'react-dom/client'
import App from './components/App'

const mountNode = document.querySelector('#root')
ReactDOM.createRoot(mountNode).render(&lt;App /&gt;)
</pre>
<p>如果你曾经使用过React应用程序，这应该看起来很熟悉，但是与你通常附加应用程序的方式有两个微妙的区别。</p>
<p>首先，我们从<code>react-dom/client</code>导入ReactDOM。在<a href="https://blog.logrocket.com/exploring-react-18-three-new-apis/">反应18 </a>中这是一种新的方式。原因是因为ReactDOM的新版本也支持服务器渲染，所以我们必须明确要导入哪个包。</p>
<p>其次，是我们使用ReactDOM的方式。通常，我们会这样写—</p>
<pre class="language-javascript hljs">ReactDOM.render(&lt;App /&gt;, mountNode)
</pre>
<p>但是，现在这只对React v17及以下版本有效。我们需要使用<code>createRoot</code>方法来呈现我们的应用程序。这也允许我们手动选择使用并发功能。</p>
<h3 id="app-jsx"><code>App.jsx</code></h3>
<p>这是大部分魔法发生的地方，所以我们将一步一步来看:</p>
<pre class="language-javascript hljs">import React, { Suspense } from 'react'

import UserWelcome from './UserWelcome'
import Todos from './Todos'

const App = () =&gt; {
  return (
    &lt;div className="app"&gt;
      &lt;h2&gt;Simple Todo&lt;/h2&gt;

      &lt;Suspense fallback={&lt;p&gt;Loading user details...&lt;/p&gt;}&gt;
        &lt;UserWelcome /&gt;
      &lt;/Suspense&gt;
      &lt;Suspense fallback={&lt;p&gt;Loading Todos...&lt;/p&gt;}&gt;
        &lt;Todos /&gt;
      &lt;/Suspense&gt;
    &lt;/div&gt;
  )
}

export default App
</pre>
<p>一开始，我们有React导入，但是请注意，我们也引入了悬念，如果您还记得的话，它让我们的组件在渲染之前等待一些东西。我们还导入了两个定制组件，它们将为用户呈现一条欢迎消息以及一些待办事项。</p>
<p>导入之后，我们创建一个名为<code>App</code>的新组件，它将作为其他组件的父组件。接下来，我们用return语句来呈现我们的JSX，这就是我们使用<code>Suspense</code>组件的地方。</p>
<p>第一个<code>Suspense</code>组件有一个<code>&lt;p&gt;Loading user details…&lt;/p&gt;</code>的后备，用于包装<code>&lt;UserWelcome/&gt;</code>组件。这将导致React在用户详细信息数据未准备好时呈现加载消息。</p>
<p>同样的事情也适用于<code>&lt;Todos /&gt;</code>组件，唯一的区别是回退消息。注意两个<code>Suspense</code>组件是并排的。这仅仅意味着获取未决和已完成的待办事项的请求将被并行启动，并且两者都不必等待对方。</p>
<h3 id="userwelcome-jsx"><code>UserWelcome.jsx</code></h3>
<p>该组件向用户呈现欢迎消息:</p>
<pre class="language-javascript hljs">import React from 'react'
import fetchData from '../api/fetchData'

const resource = fetchData(
  'https://run.mocky.io/v3/d6ac91ac-6dab-4ff0-a08e-9348d7deed51'
)

const UserWelcome = () =&gt; {
  const userDetails = resource.read()

  return (
    &lt;div&gt;
      &lt;p&gt;
        Welcome &lt;span className="user-name"&gt;{userDetails.name}&lt;/span&gt;, here are
        your Todos for today
      &lt;/p&gt;
      &lt;small&gt;Completed todos have a line through them&lt;/small&gt;
    &lt;/div&gt;
  )
}

export default UserWelcome
</pre>
<p>我们从在文件顶部导入React和<code>fetchData</code>函数开始。然后，我们启动获取用户详细信息的网络请求，并将结果存储在一个名为<code>resource</code>的变量中。</p>
<p>这个<code>resource</code>变量是一个引用请求承诺的对象，我们可以通过调用一个<code>.read()</code>方法来查询它。如果请求还没有解决，调用<code>resource.read()</code>将会向<code>Suspense</code>组件抛出一个异常。</p>
<p>但是，如果是，它将从承诺中返回已解析的数据，在本例中，该数据将是todo项的数组。然后，我们继续映射这个数组，并呈现每个待办事项。</p>
<p>在文件的末尾，我们有一个默认的导出，这样我们就可以在其他文件中导入这个组件。</p>
<h3 id="todos-jsx"><code>Todos.jsx</code></h3>
<p>该组件呈现待办事项列表:</p>
<pre class="language-javascript hljs">import React from 'react'
import fetchData from '../api/fetchData'

const resource = fetchData(
  'https://run.mocky.io/v3/8a33e687-bc2f-41ea-b23d-3bc2fb452ead'
)

const Todos = () =&gt; {
  const todos = resource.read()

  const renderTodos = todos.map((todo) =&gt; {
    const className = todo.status === 'Completed' ? 'todo-completed' : 'todo'
    return (
      &lt;li className={`todo ${className}`} key={todo.id}&gt;
        {todo.title}
      &lt;/li&gt;
    )
  })

  return (
    &lt;div&gt;
      &lt;h3&gt;Todos&lt;/h3&gt;
      &lt;ol className="todos"&gt;{renderTodos}&lt;/ol&gt;
    &lt;/div&gt;
  )
}

export default Todos
</pre>
<p>它与上面的<code>UserWelcome</code>组件非常相似，唯一的区别是渲染逻辑和内容。</p>
<p>现在我们已经准备好了两个组件，让我们更深入地探索悬念。</p>
<h2 id="managing-rendering-order-suspense">管理带悬念的渲染顺序</h2>
<p>想象一下，如果<code>Todos</code>组件首先获得数据，然后您开始遍历列表，只为<code>UserWelcome</code>稍后解析。正在呈现的新内容会以一种滑稽的方式将现有的待办内容向下推，这可能会让用户迷失方向。</p>
<p><img data-attachment-id="101701" data-permalink="https://blog.logrocket.com/react-suspense-data-fetching/janky-loading-in-our-demo-app/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2019/11/Janky-Loading-In-Our-Demo-App.gif" data-orig-size="600,498" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Janky Loading In Our Demo App" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2019/11/Janky-Loading-In-Our-Demo-App-300x249.gif" data-large-file="https://blog.logrocket.com/wp-content/uploads/2019/11/Janky-Loading-In-Our-Demo-App.gif" decoding="async" class="size-full wp-image-101701 aligncenter jetpack-lazy-image" src="../Images/ef378b93c8cdbdc5104b9bf2e417d0a9.png" alt="Janky Loading In Our Demo App" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2019/11/Janky-Loading-In-Our-Demo-App.gif?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/11/Janky-Loading-In-Our-Demo-App.gif"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="101701" data-permalink="https://blog.logrocket.com/react-suspense-data-fetching/janky-loading-in-our-demo-app/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2019/11/Janky-Loading-In-Our-Demo-App.gif" data-orig-size="600,498" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Janky Loading In Our Demo App" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2019/11/Janky-Loading-In-Our-Demo-App-300x249.gif" data-large-file="https://blog.logrocket.com/wp-content/uploads/2019/11/Janky-Loading-In-Our-Demo-App.gif" decoding="async" loading="lazy" class="size-full wp-image-101701 aligncenter" src="../Images/ef378b93c8cdbdc5104b9bf2e417d0a9.png" alt="Janky Loading In Our Demo App" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/11/Janky-Loading-In-Our-Demo-App.gif"/></noscript>
<p>然而，如果你想让<code>Todos</code>组件只在<code>UserWelcome</code>组件完成渲染后才进行渲染，那么你可以像这样嵌套<code>Suspense</code>组件包装<code>Todos</code>:</p>
<pre class="language-javascript hljs">&lt;Suspense fallback={&lt;p&gt;Loading user details...&lt;/p&gt;}&gt;
  &lt;UserWelcome /&gt;

  &lt;Suspense fallback={&lt;p&gt;Loading Todos...&lt;/p&gt;}&gt;
    &lt;Todos /&gt;
  &lt;/Suspense&gt;
&lt;/Suspense&gt;
</pre>
<p>另一种方法是将两个<code>Suspense</code>组件包装在一个<code><a href="https://reactjs.org/docs/concurrent-mode-patterns.html#suspenselist" target="_blank" rel="noopener">SuspenseList</a></code>中，并指定一个“显示顺序”，如下所示:</p>
<pre class="language-javascript hljs">&lt;SuspenseList revealOrder="forwards"&gt;
  &lt;Suspense fallback={&lt;p&gt;Loading user details...&lt;/p&gt;}&gt;
    &lt;UserWelcome /&gt;
  &lt;/Suspense&gt;

  &lt;Suspense fallback={&lt;p&gt;Loading Todos...&lt;/p&gt;}&gt;
    &lt;Todos /&gt;
  &lt;/Suspense&gt;
&lt;/SuspenseList&gt;
</pre>
<blockquote><p>注意:<code>SuspenseList</code>仅在React的实验版本中可用，在发布候选版本中不可用。要尝试一下，运行<code>npm i <a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="2c5e494d4f586c49545c495e45414942584d40">[email protected]</a></code>。</p></blockquote>
<p>这将使React按照组件在代码中出现的顺序呈现组件，而不管哪个组件先获得数据。</p>
<p><img data-attachment-id="101703" data-permalink="https://blog.logrocket.com/react-suspense-data-fetching/updated-demo-app-with-top-down-loading/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2019/11/Updated-Demo-App-With-Top-Down-Loading.gif" data-orig-size="600,498" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Updated Demo App With Top-Down Loading" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2019/11/Updated-Demo-App-With-Top-Down-Loading-300x249.gif" data-large-file="https://blog.logrocket.com/wp-content/uploads/2019/11/Updated-Demo-App-With-Top-Down-Loading.gif" decoding="async" class="size-full wp-image-101703 aligncenter jetpack-lazy-image" src="../Images/13fc0bbdcd1f76b10a1ea6364402f403.png" alt="Updated Demo App With Top-Down Loading" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2019/11/Updated-Demo-App-With-Top-Down-Loading.gif?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/11/Updated-Demo-App-With-Top-Down-Loading.gif"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="101703" data-permalink="https://blog.logrocket.com/react-suspense-data-fetching/updated-demo-app-with-top-down-loading/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2019/11/Updated-Demo-App-With-Top-Down-Loading.gif" data-orig-size="600,498" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Updated Demo App With Top-Down Loading" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2019/11/Updated-Demo-App-With-Top-Down-Loading-300x249.gif" data-large-file="https://blog.logrocket.com/wp-content/uploads/2019/11/Updated-Demo-App-With-Top-Down-Loading.gif" decoding="async" loading="lazy" class="size-full wp-image-101703 aligncenter" src="../Images/13fc0bbdcd1f76b10a1ea6364402f403.png" alt="Updated Demo App With Top-Down Loading" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/11/Updated-Demo-App-With-Top-Down-Loading.gif"/></noscript>
<p>您可以开始看到组织应用程序的加载状态变得多么简单，而不是自己去管理<code>isLoading</code>变量。自上而下的加载方式要好得多。</p>
<h2 id="recap">概述</h2>
<p>我们已经完成了组件的编码，现在是时候回顾一下我们到目前为止所做的工作了:</p>
<ul>
<li>我们选择在我们的<code>index.jsx</code>文件中使用并发特性</li>
<li>我们创建了一个有两个子组件的<code>App</code>组件，每个子组件包装在一个<code>Suspense</code>组件中</li>
<li>在每个子组件中，我们在它们安装之前启动了网络请求</li>
</ul>
<p>让我们运行我们的应用程序，看看它是否有效。在您的终端中，运行<code>npm run dev</code>并在浏览器中导航至<code><a href="http://localhost:4000" rel="nofollow">http://localhost:4000</a></code>。在你的Chrome开发者工具中打开<strong>网络</strong>标签并刷新页面。</p>
<p>您应该看到对已完成和待定todo项的请求都是并行发生的，如下所示。</p>
<p><img data-attachment-id="101705" data-permalink="https://blog.logrocket.com/react-suspense-data-fetching/network-requests-in-chrome-devtools/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2019/11/Network-Requests-In-Chrome-DevTools.png" data-orig-size="730,187" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Network Requests In Chrome DevTools" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2019/11/Network-Requests-In-Chrome-DevTools-300x77.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2019/11/Network-Requests-In-Chrome-DevTools.png" decoding="async" class="size-full wp-image-101705 aligncenter jetpack-lazy-image" src="../Images/f64197ba5b33e8ba7d0f008911e5aa9c.png" alt="Network Requests In Chrome DevTools" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2019/11/Network-Requests-In-Chrome-DevTools.png 730w, https://blog.logrocket.com/wp-content/uploads/2019/11/Network-Requests-In-Chrome-DevTools-300x77.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2019/11/Network-Requests-In-Chrome-DevTools.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/11/Network-Requests-In-Chrome-DevTools.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="101705" data-permalink="https://blog.logrocket.com/react-suspense-data-fetching/network-requests-in-chrome-devtools/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2019/11/Network-Requests-In-Chrome-DevTools.png" data-orig-size="730,187" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Network Requests In Chrome DevTools" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2019/11/Network-Requests-In-Chrome-DevTools-300x77.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2019/11/Network-Requests-In-Chrome-DevTools.png" decoding="async" loading="lazy" class="size-full wp-image-101705 aligncenter" src="../Images/f64197ba5b33e8ba7d0f008911e5aa9c.png" alt="Network Requests In Chrome DevTools" srcset="https://blog.logrocket.com/wp-content/uploads/2019/11/Network-Requests-In-Chrome-DevTools.png 730w, https://blog.logrocket.com/wp-content/uploads/2019/11/Network-Requests-In-Chrome-DevTools-300x77.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/11/Network-Requests-In-Chrome-DevTools.png"/></noscript>
<p>看<strong>瀑布</strong>段。我们已经成功实现了一个用于数据获取的简单版本的悬念，您可以看到它如何帮助您以一种简单和可预测的方式编排应用程序的数据获取操作。</p>
<h2 id="conclusion">结论</h2>
<p>在本文中，我们已经了解了什么是悬念，各种数据获取方法，并且我们已经构建了一个简单的应用程序，利用悬念进行数据获取。</p>
<p>虽然并发模式仍处于试验阶段，但我希望这篇文章能够突出它变得稳定时将带来的一些好处。</p>
<p>如果你有兴趣了解更多，我建议你阅读<a href="https://reactjs.org/docs/concurrent-mode-intro.html" target="_blank" rel="noopener">文档</a>并尝试构建一个更复杂的应用程序。同样，你可以在这里找到本教程<a href="https://github.com/ovieokeh/suspense-data-fetching" target="_blank" rel="noopener">中写的所有代码。<br/>再见，编码快乐！<strong> ❤️ </strong></a></p><div class="code-block code-block-17">
<div class="blog-plug inline-plug react-plug" vwo-el-id="26283398190">
<h2 vwo-el-id="41600691720">使用LogRocket消除传统反应错误报告的噪音</h2>
<a href="https://lp.logrocket.com/blg/react-signup-issue-free" target="_blank" vwo-el-id="19356441070">LogRocket
</a><p>是一款React analytics解决方案，可保护您免受数百个误报错误警报的影响，只针对少数真正重要的项目。LogRocket告诉您React应用程序中实际影响用户的最具影响力的bug和UX问题。</p><a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="19356441380">
<img class="first-react-image alignnone size-full wp-image-46 jetpack-lazy-image jetpack-lazy-image--handled" src="../Images/f300c244a1a1cf916df8b4cb02bec6c6.png" vwo-el-id="18272717540" data-lazy-loaded="1" data-original-src="https://files.readme.io/27c94e7-Image_2017-06-05_at_9.46.04_PM.png"/>
</a>
<a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="19356441690">
<img class="second-react-image alignnone size-full wp-image-46 jetpack-lazy-image jetpack-lazy-image--handled" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" vwo-el-id="30720362350" data-lazy-loaded="1" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/>
</a>
<a href="https://lp.logrocket.com/blg/react-signup-issue-free" target="_blank" rel="noopener noreferrer" vwo-el-id="35866400580">LogRocket
</a><p>自动聚合客户端错误、反应错误边界、还原状态、缓慢的组件加载时间、JS异常、前端性能指标和用户交互。然后，LogRocket使用机器学习来通知您影响大多数用户的最具影响力的问题，并提供您修复它所需的上下文。</p><p vwo-el-id="28675661060">关注重要的React bug—<a class="signup" href="https://lp.logrocket.com/blg/react-signup-issue-free" target="_blank" rel="noopener noreferrer" vwo-el-id="40093418840">今天就试试LogRocket】。</a></p>
</div></div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
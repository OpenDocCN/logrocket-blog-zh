<html>
<head>
<title>Introduction to RPC using Go and Node - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>使用Go和Node - LogRocket博客介绍RPC</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/introduction-to-rpc-using-go-and-node/#0001-01-01">https://blog.logrocket.com/introduction-to-rpc-using-go-and-node/#0001-01-01</a></blockquote><div><article class="article-post">
<h2>介绍</h2>
<p><a href="https://en.wikipedia.org/wiki/Remote_procedure_call" target="_blank" rel="noopener noreferrer"> RPC(远程过程调用)</a>简而言之，是一种用于客户端-服务器应用的协议，它允许软件开发者向远程服务器请求过程或函数调用。在本教程中，您将学习如何在Go中构建一个RPC服务器，以及在Node.js中构建一个RPC客户端。</p>
<h2>先决条件</h2>
<p>你需要:</p>
<ul>
<li>安装在本地机器上的<a href="https://golang.org" target="_blank" rel="noopener noreferrer"> Go </a></li>
<li>安装在本地机器上的<a href="https://nodejs.org/en/download" target="_blank" rel="noopener noreferrer">节点</a></li>
<li>安装在本地机器上的协议缓冲区</li>
</ul>
<h2>目标</h2>
<p>在本文中，我们将构建一个聊天RPC服务器来发送消息并返回用户的描述性细节。send message过程将接受消息正文，而另一个过程将接受用户的姓名和年龄。</p>
<h2>创建服务器</h2>
<p>在这一步中，您将构建您的RPC服务器。运行以下命令，创建一个新的项目目录:</p>
<pre>mkdir rpc-server</pre>
<p>将目录更改为新创建的文件夹:</p>
<pre>cd rpc-server</pre>
<h2>配置协议缓冲区</h2>
<p>协议缓冲区是Google创建的一种数据格式，使开发人员能够基于为任何编程语言指定的数据和服务生成源代码。</p>
<p>创建一个名为<code>chat.proto</code>的<code>proto</code>文件:</p>
<pre>touch chat.proto</pre>
<p>用您想要的编辑器打开<code>chat.proto</code>,粘贴以下代码:</p>
<pre>syntax = "proto3";

package chat;

message Message {
  string body = 1;
}

message Details {
  string name = 1;
  int32 age = 2;
}

message Response {
  string body = 1;
}

service ChatService {
  rpc SayHello(Message) returns (Response) {}
  rpc GetDetails(Details) returns (Response) {}
}
</pre>
<p>让我们来看看每个模块的功能:</p>
<pre>syntax = "proto3";</pre>
<p>这指定了我们打算写什么版本的protobuf。</p>
<pre>message Message {
  string body = 1;
}
</pre>
<p>这声明了一个<code>Message</code>数据对象，它只能包含一个带有标签<code>body</code>的字符串元素。</p>
<pre>message Details {
  string name = 1;
  int32 age = 2;
}</pre>
<p>这声明了一个<code>Details</code>数据对象，它只能包含一个带有标签<code>name</code>的字符串元素和一个带有标签<code>age</code>的整数元素。</p>
<pre>message Response {
  string body = 1;
}</pre>
<p>这声明了一个<code>Response</code>数据对象，它只能包含一个带有标签<code>body</code>的字符串元素。</p>
<pre>service ChatService {
  rpc SayHello(Message) returns (Message) {}
  rpc GetDetails(Details) returns (Details) {}
}</pre>
<p>这声明了一个名为<code>ChatService</code>的新服务，它将包含两个方法，接受<code>Message</code>数据对象并返回<code>Response</code>的<code>SayHello</code>方法和接受<code>Details</code>并返回<code>Response</code>的<code>GetDetails</code>方法。保存并退出文件。</p>
<p><em>注:你可以在这里了解更多关于protobuf <a href="https://developers.google.com/protocol-buffers/" target="_blank" rel="noopener noreferrer">的信息。</a></em></p>
<h2>生成Go代码</h2>
<p>我们将基于上一步中编写的<code>proto</code>文件生成一个协议缓冲区Go代码。仍然在<code>rpc-server</code>目录中，运行以下命令:</p>
<pre> mkdir chat</pre>
<p>这将在<code>rpc-server</code>目录中生成一个名为<code>chat</code>的新文件夹。这是您放置我们生成的Go代码以及您的<code>chat.proto</code>文件的实现的地方。运行以下命令，从<code>chat.proto</code>文件中生成go代码:</p>
<pre>protoc --go_out=plugins=grpc:chat chat.proto</pre>
<p><em>注:你可以在这里了解更多关于Go生成代码<a href="https://developers.google.com/protocol-buffers/docs/reference/go-generated#invocation" target="_blank" rel="noopener noreferrer">的信息。</a></em></p>
<p>这将在之前创建的<code>chat</code>目录中生成一个名为<code>chat.pb.go</code>的新文件。</p>
<p><em>注意:不要修改<code>chat.pb.go</code>的内容。</em></p>
<h2>实现方法</h2>
<p>在这一步中，我们将实现在<code>chat.proto</code>中定义的<code>ChatService</code>中的方法。</p>
<p>创建一个名为<code>chat.go</code>的新文件:</p>
<pre>touch chat.go</pre>
<p>用您想要的编辑器打开<code>chat.go</code>,粘贴以下代码:</p>
<pre>package chat

import (
    "fmt"
    "golang.org/x/net/context"
    "log"
)

type Server struct{}

func (s *Server) SayHello(ctx context.Context, message *Message) (*Response, error) {
    log.Println("SayHello Called")
    return &amp;Response{Body: fmt.Sprintf("New Message: %s", message.Body)}, nil
}

func (s *Server) GetDetails(ctx context.Context, message *Details) (*Response, error) {
    log.Println("GetDetails Called")
    return &amp;Response{Body: fmt.Sprintf("Your name is %s and you're %d years old", message.Name, message.Age)}, nil
}</pre>
<p>让我来分解一下要点:</p>
<pre>type Server struct{}</pre>
<p>这充当了这个<code>ChatService</code>实现的服务器接口，我们稍后将使用它来插入RPC服务器。</p>
<p>第一个函数实现了<code>SayHello</code>函数，当被调用时，它会将<br/> <code>SayHello Called</code>记录到控制台，同时将<code>Response</code>对象以及传递给它的消息体返回给客户端。</p>
<p>第二个函数实现了<code>GetDetails</code>函数，当被调用时，它会将<br/> <code>GetDetails Called</code>记录到控制台，同时返回<code>Response</code>对象以及一条包含传回客户端的数据的自定义消息。</p>
<p>两个方法都返回<code>error</code>和一个指针引用<code>Response</code>，它作为一个结构存在于基于我们在<code>chat.proto</code>中定义的内容生成的<code>chat.pb.go</code>文件中。</p>
<p><em>注意:实现的方法必须返回在<code>proto</code>声明和错误中定义的指针引用。</em></p>
<h2>配置服务器</h2>
<p>在这一步中，您将通过RPC服务于<code>ChatService</code>。将目录从<code>/chat</code>转到你的<code>rpc-server</code>目录的根目录。</p>
<pre>cd ..</pre>
<p>生成<code>mod</code>文件:</p>
<pre>go mod init grpc-server/chat</pre>
<p>创建一个名为<code>server.go</code>的新文件:</p>
<pre>touch server.go</pre>
<p>用您想要的编辑器打开<code>server.go</code>,粘贴以下代码:</p>
<pre>package main

import (
    "fmt"
    "grpc-server/chat"
    "log"
    "net"

    "google.golang.org/grpc"
)

func main() {
    listener, err := net.Listen("tcp", fmt.Sprintf(":%d", 9000))

    if err != nil {
        log.Fatal(err)
    }

    chatServer := chat.Server{}

    grpcServer := grpc.NewServer()

    chat.RegisterChatServiceServer(grpcServer, &amp;chatServer)

    if err := grpcServer.Serve(listener); err != nil {
        log.Fatal(err)
    }
}
</pre>
<p>在除Go标准库之外的导入块中，我们正在导入聊天包，它允许您调用在<code>chat.go</code>中声明的服务器结构接口，并调用在<code>chat.pb.go</code>中为我们自动生成的<code>RegisterChatServiceServer</code>方法，该方法接受两个参数，一个新的服务器实例<code>grpc</code>和聊天服务器的内存位置。</p>
<p>最后一个块通过<code>TCP</code>服务于我们在端口<code>9000</code>上的RPC服务器，如之前在<code>listener</code>中声明的。保存并退出文件。<code>rpc-server</code>的内容结构应该类似于下面的内容:</p>
<pre>🗂rpc-server/
  🗂chat/
    🗒 chat.go
    🗒 chat.pb.go
  🗒 chat.proto
  🗒 go.mod
  🗒 server.go</pre>
<p>通过运行以下命令启动RPC服务器:</p>
<pre>go run server.go</pre>
<h2>创建客户端</h2>
<p>打开一个新的终端实例，通过运行以下命令在<code>rpc-server</code>之外创建一个名为<code>rpc-client</code>的不同文件夹:</p>
<pre>mkdir rpc-client</pre>
<p>将目录更改为<code>rpc-client</code>:</p>
<pre>cd rpc-client</pre>
<p>启动<code>npm</code>:</p>
<pre>npm init</pre>
<p>通过按return/enter键接受默认选项。接下来，安装RPC包:</p>
<pre>npm i node-grpc-client</pre>
<p>创建一个<code>chat.proto</code>文件:</p>
<pre>touch chat.proto</pre>
<p>将位于<code>rpc-server</code>中的<code>chat.proto</code>的内容复制到您新创建的<code>chat.proto</code>中。创建一个名为<code>client.js</code>的新文件:</p>
<pre>touch client.js</pre>
<p>用您想要的编辑器打开<code>client.js</code>,粘贴以下代码:</p>
<pre>const GRPCClient = require('node-grpc-client')

const path = require("path")

const PROTO_PATH = path.resolve(__dirname, 'chat.proto')

const client = new GRPCClient(PROTO_PATH, 'chat', 'ChatService', 'localhost:9000')

const message = {
    body: "Hello from Trojan",
}

const details = {
    name: "Trojan",
    age: 40
}

client.runService('SayHello', message, (err, res) =&gt; {
    console.log(res.body);
});

client.runService('GetDetails', details, (err, res) =&gt; {
    console.log(res.body);
});
</pre>
<p>您可以查看<a href="https://www.npmjs.com/package/node-grpc-client" target="_blank" rel="noopener noreferrer"> node-grpc-client </a>包文档来全面了解这是做什么的。保存并退出。</p>
<p><code>rpc-server</code>的内容结构应该类似于下面的内容:</p>
<pre>🗂rpc-client/
  🗂node_modules/
  🗒 chat.proto
  🗒 client.js
  🗒 package.json
  🗒 package-lock.json
</pre>
<p>通过执行以下命令，运行您的客户端代码来调用RPC服务器:</p>
<pre>node client.js</pre>
<p>这将从服务器返回以下输出:<img data-attachment-id="20930" data-permalink="https://blog.logrocket.com/introduction-to-rpc-using-go-and-node/client/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/06/client.png" data-orig-size="730,529" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="client" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/06/client-300x217.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/06/client.png" decoding="async" class="aligncenter size-full wp-image-20930 jetpack-lazy-image" src="../Images/d5ab49fcbd09bb96ba60161623bebb8b.png" alt="client" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2020/06/client.png 730w, https://blog.logrocket.com/wp-content/uploads/2020/06/client-300x217.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2020/06/client.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/06/client.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="20930" data-permalink="https://blog.logrocket.com/introduction-to-rpc-using-go-and-node/client/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/06/client.png" data-orig-size="730,529" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="client" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/06/client-300x217.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/06/client.png" decoding="async" loading="lazy" class="aligncenter size-full wp-image-20930" src="../Images/d5ab49fcbd09bb96ba60161623bebb8b.png" alt="client" srcset="https://blog.logrocket.com/wp-content/uploads/2020/06/client.png 730w, https://blog.logrocket.com/wp-content/uploads/2020/06/client-300x217.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/06/client.png"/></noscript>
<p>它工作了，继续在它的终端标签/窗口上检查服务器的日志输出:<br/> <img data-attachment-id="20931" data-permalink="https://blog.logrocket.com/introduction-to-rpc-using-go-and-node/server/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/06/server.png" data-orig-size="730,589" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="server" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/06/server-300x242.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/06/server.png" decoding="async" class="aligncenter size-full wp-image-20931 jetpack-lazy-image" src="../Images/00404ee07bbbbd82f6a1612bdb8cbe33.png" alt="server" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2020/06/server.png 730w, https://blog.logrocket.com/wp-content/uploads/2020/06/server-300x242.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2020/06/server.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/06/server.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="20931" data-permalink="https://blog.logrocket.com/introduction-to-rpc-using-go-and-node/server/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/06/server.png" data-orig-size="730,589" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="server" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/06/server-300x242.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/06/server.png" decoding="async" loading="lazy" class="aligncenter size-full wp-image-20931" src="../Images/00404ee07bbbbd82f6a1612bdb8cbe33.png" alt="server" srcset="https://blog.logrocket.com/wp-content/uploads/2020/06/server.png 730w, https://blog.logrocket.com/wp-content/uploads/2020/06/server-300x242.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/06/server.png"/></noscript><br/>
As you can see in the image above, <code>SayHello Called</code> and <code>GetDetails Called</code> was logged as expected as the functions were accessed by the client.
<h2>结论</h2>
<p>在本教程结束时，您应该了解了如何在Go中构建RPC服务器，以及如何通过Node编写的客户端调用服务器上的过程。你可以在GitHub上找到<a href="https://github.com/ichtrojan/grpc-server" target="_blank" rel="noopener noreferrer"> RPC服务器</a>和<a href="https://github.com/ichtrojan/node-rpc-client" target="_blank" rel="noopener noreferrer"> RPC客户端</a>的存储库。</p><div class="code-block code-block-23">
<div class="blog-plug inline-plug node-plug"><h2>200只<img src="../Images/61167b9d027ca73ed5aaf59a9ec31267.png" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2019/10/green-check.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" class=" jetpack-lazy-image" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/10/green-check.png"/> <noscript> <img data-lazy-fallback="1" src="../Images/61167b9d027ca73ed5aaf59a9ec31267.png" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/10/green-check.png"/> </noscript>显示器出现故障，生产中网络请求缓慢</h2><p>部署基于节点的web应用程序或网站是容易的部分。确保您的节点实例继续为您的应用程序提供资源是事情变得更加困难的地方。如果您对确保对后端或第三方服务的请求成功感兴趣，</p><a href="https://lp.logrocket.com/blg/node-signup" target="_blank">try LogRocket</a><p>. </p><a class="signup" href="https://lp.logrocket.com/blg/node-signup" target="_blank" rel="noopener noreferrer"><img src="../Images/cae72fd2a54c5f02a6398c4867894844.png" alt="LogRocket Network Request Monitoring" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2019/12/network-request-filter-2-1.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" class=" jetpack-lazy-image" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/12/network-request-filter-2-1.png"/><noscript><img data-lazy-fallback="1" src="../Images/cae72fd2a54c5f02a6398c4867894844.png" alt="LogRocket Network Request Monitoring" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/12/network-request-filter-2-1.png"/></noscript></a><a href="https://lp.logrocket.com/blg/node-signup" target="_blank" rel="noopener noreferrer">https://logrocket.com/signup/</a><p>LogRocket 就像是网络和移动应用程序的DVR，记录下用户与你的应用程序交互时发生的一切。您可以汇总并报告有问题的网络请求，以快速了解根本原因，而不是猜测问题发生的原因。</p><p>LogRocket检测您的应用程序以记录基线性能计时，如页面加载时间、到达第一个字节的时间、慢速网络请求，还记录Redux、NgRx和Vuex操作/状态。</p><a class="signup" href="https://lp.logrocket.com/blg/node-signup" target="_blank" rel="noopener noreferrer">Start monitoring for free</a><p>. </p></div>
</div>

<p class="clearfix"/>
<p class="clearfix"/>
 </article>

</div>    
</body>
</html>
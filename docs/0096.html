<html>
<head>
<title>How to manipulate CSS colors with JavaScript - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>如何用JavaScript操纵CSS颜色</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/how-to-manipulate-css-colors-with-javascript-fb547113a1b8/#0001-01-01">https://blog.logrocket.com/how-to-manipulate-css-colors-with-javascript-fb547113a1b8/#0001-01-01</a></blockquote><div><article class="article-post">
<h2 class="graf graf--h3">彩色模型101</h2>
<p class="graf graf--p">我知道你是来学习处理颜色的——我们会实现的。但是在此之前，我们需要对CSS如何表示颜色有一个基本的了解。CSS使用两种不同的颜色模型:RGB和HSL。让我们快速浏览一下两者。</p>
<h3 class="graf graf--h4">RGB</h3>
<p class="graf graf--p">“红、绿、蓝、<a class="markup--anchor markup--p-anchor" href="https://codepen.io/AdamGiese/full/5783951de51e0db0f569d5abbd9cb2f7" target="_blank" rel="noopener noreferrer" data-href="https://codepen.io/AdamGiese/full/5783951de51e0db0f569d5abbd9cb2f7">、RGB </a>的首字母由三个数字组成，每个数字表示最终颜色中包含了多少相应颜色的光。在CSS中，每个数字都在0-255的范围内，可以写成CSS <code>rgb</code>函数的逗号分隔参数。比如<code>rgb(50,100,0)</code>。</p>
<p class="graf graf--p">RGB是一种“加色”颜色系统，这意味着每个数字越高，最终颜色就越亮。如果所有值相等，则颜色为灰度；如果所有值都为零，结果将是黑色的；如果所有值都是255，结果将是白色的。</p>
<p class="graf graf--p">或者，您可以使用十六进制记数法来表示RGB颜色，其中每种颜色的整数都从基数10转换为基数16。例如，<code>rgb(50,100,0)</code>就是<code>#326400</code>。</p>
<p class="graf graf--p">虽然我通常发现自己出于习惯而接触RGB(尤其是十六进制)，但我经常发现它很难阅读，尤其难以操作。输入HSL。</p>
<h3 class="graf graf--h4">high-speedlaunch高速快艇</h3>
<p class="graf graf--p">“色调、饱和度、亮度”的首字母组合<a class="markup--anchor markup--p-anchor" href="https://codepen.io/AdamGiese/full/989988044f3b8cf6403e3c60f56dd612" target="_blank" rel="noopener noreferrer" data-href="https://codepen.io/AdamGiese/full/989988044f3b8cf6403e3c60f56dd612"> HSL </a>也由三个值组成。色调值对应于色轮上的位置，由CSS角度值表示；最常用的是deg单位。</p>
<p class="graf graf--p">饱和度是指颜色的强度，用百分比表示。当饱和度为100%时，它是全彩色的；饱和度越低，颜色越浅，直到灰度达到0%。</p>
<p class="graf graf--p">明度，也用百分比表示，指的是颜色有多亮。“常规”亮度为50%。100%的明度将是纯白，0%的明度将是纯黑，与色调和饱和度值无关。</p>
<p class="graf graf--p">我发现HSL是一个更直观的模型。颜色之间的关系更加明显，对颜色的处理往往就像调整其中一个数字一样简单。</p>
<figure class="graf graf--figure graf--layoutOutsetCenter"><a class="graf-imageAnchor" href="https://logrocket.com/signup/" target="_blank" rel="noopener noreferrer" data-href="https://logrocket.com/signup/" data-action="image-link" data-action-observe-only="true"><img decoding="async" class="graf-image jetpack-lazy-image" src="../Images/e18e0769df17c13e116ad4fd8dfd8166.png" data-image-id="1*wV7zU6J05BL3bphzMlB2rA.png" data-width="2400" data-height="560" data-lazy-src="https://storage.googleapis.com/blog-images-backup/1*wV7zU6J05BL3bphzMlB2rA.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://storage.googleapis.com/blog-images-backup/1*wV7zU6J05BL3bphzMlB2rA.png"/><noscript><img data-lazy-fallback="1" decoding="async" class="graf-image" src="../Images/e18e0769df17c13e116ad4fd8dfd8166.png" data-image-id="1*wV7zU6J05BL3bphzMlB2rA.png" data-width="2400" data-height="560" data-original-src="https://storage.googleapis.com/blog-images-backup/1*wV7zU6J05BL3bphzMlB2rA.png"/></noscript></a></figure>
<h2 class="graf graf--h3">颜色模型之间的转换</h2>
<p class="graf graf--p">RGB和HSL颜色模型都将颜色分解成各种属性。为了在语法之间进行转换，我们首先需要计算这些属性。</p>
<p class="graf graf--p">除了色调之外，我们所讨论的每一个值都可以用百分数来表示。甚至RGB值也是字节大小的百分比表示。在下面的公式和函数中，这些百分比将由0到1之间的小数表示。</p>
<p class="graf graf--p">我想指出的是，我不会深入讨论这些问题的数学；相反，我将简要回顾一下原始的数学公式，然后将其转换成JavaScript公式。</p>
<h3 class="graf graf--h4">从RGB计算亮度</h3>
<p class="graf graf--p">亮度是三个HSL值中最容易计算的。数学上，公式显示如下，其中<code>M</code>是RGB值的最大值，<code>m</code>是最小值:</p>
<figure class="graf graf--figure"><img decoding="async" class="graf-image jetpack-lazy-image" src="../Images/ae3ebf93df5e39af269b8725f2b8e23c.png" data-image-id="0*mZxFLQvMNraVQWQS.png" data-width="163" data-height="50" data-lazy-src="https://storage.googleapis.com/blog-images-backup/0*mZxFLQvMNraVQWQS.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://storage.googleapis.com/blog-images-backup/0*mZxFLQvMNraVQWQS.png"/><noscript><img data-lazy-fallback="1" decoding="async" class="graf-image" src="../Images/ae3ebf93df5e39af269b8725f2b8e23c.png" data-image-id="0*mZxFLQvMNraVQWQS.png" data-width="163" data-height="50" data-original-src="https://storage.googleapis.com/blog-images-backup/0*mZxFLQvMNraVQWQS.png"/></noscript><figcaption class="imageCaption">The mathematic formula for lightness</figcaption></figure>
<p class="graf graf--p">下面是与JavaScript函数相同的公式:</p>
<pre class="graf graf--pre"><code class="markup--code markup--pre-code">const rgbToLightness = (r,g,b) =&gt; 
    1/2 * (Math.max(r,g,b) + Math.min(r,g,b));</code></pre>
<h3 class="graf graf--h4">从RGB计算饱和度</h3>
<p class="graf graf--p">饱和度只是比明度稍微复杂一点。如果亮度为0或1，则饱和度值将为0。否则，它遵循下面的数学公式，其中<code>L</code>代表亮度:</p>
<figure class="graf graf--figure"><img decoding="async" class="graf-image jetpack-lazy-image" src="../Images/77c128861782de0d0e4424bc0fc082e3.png" data-image-id="0*xZf55x3WTTJUIAG3.png" data-width="169" data-height="50" data-lazy-src="https://storage.googleapis.com/blog-images-backup/0*xZf55x3WTTJUIAG3.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://storage.googleapis.com/blog-images-backup/0*xZf55x3WTTJUIAG3.png"/><noscript><img data-lazy-fallback="1" decoding="async" class="graf-image" src="../Images/77c128861782de0d0e4424bc0fc082e3.png" data-image-id="0*xZf55x3WTTJUIAG3.png" data-width="169" data-height="50" data-original-src="https://storage.googleapis.com/blog-images-backup/0*xZf55x3WTTJUIAG3.png"/></noscript><figcaption class="imageCaption">The mathematical formula for saturation</figcaption></figure>
<p class="graf graf--p">作为JavaScript:</p>
<pre class="graf graf--pre"><code class="markup--code markup--pre-code">const rgbToSaturation = (r,g,b) =&gt; {
  const L = rgbToLightness(r,g,b);
  const max = Math.max(r,g,b);
  const min = Math.min(r,g,b);
  return (L === 0 || L === 1)
   ? 0
   : (max - min)/(1 - Math.abs(2 * L - 1));
};</code></pre>
<h3 class="graf graf--h4">从RGB计算色调</h3>
<p class="graf graf--p">从RGB坐标计算色相角的公式有点复杂:</p>
<figure class="graf graf--figure"><img decoding="async" class="graf-image jetpack-lazy-image" src="../Images/3aa358422d6474b4f13ac1d415f123c3.png" data-image-id="0*oLI0PhBJhkE8BK_e.png" data-width="497" data-height="35" data-lazy-src="https://storage.googleapis.com/blog-images-backup/0*oLI0PhBJhkE8BK_e.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://storage.googleapis.com/blog-images-backup/0*oLI0PhBJhkE8BK_e.png"/><noscript><img data-lazy-fallback="1" decoding="async" class="graf-image" src="../Images/3aa358422d6474b4f13ac1d415f123c3.png" data-image-id="0*oLI0PhBJhkE8BK_e.png" data-width="497" data-height="35" data-original-src="https://storage.googleapis.com/blog-images-backup/0*oLI0PhBJhkE8BK_e.png"/></noscript><figcaption class="imageCaption">The mathematical formula for hue</figcaption></figure>
<p class="graf graf--p">作为JavaScript:</p>
<pre class="graf graf--pre"><code class="markup--code markup--pre-code">const rgbToHue = (r,g,b) =&gt; Math.round(
  Math.atan2(
    Math.sqrt(3) * (g - b),
    2 * r - g - b,
  ) * 180 / Math.PI
);</code></pre>
<p class="graf graf--p">最后与<code>180 / Math.PI</code>相乘就是把结果从弧度转换成度。</p>
<h3 class="graf graf--h4">计算HSL</h3>
<p class="graf graf--p">所有这些功能都可以打包成一个单一的实用功能:</p>
<pre class="graf graf--pre"><code class="markup--code markup--pre-code">const rgbToHsl = (r,g,b) =&gt; {
  const lightness = rgbToLightness(r,g,b);
  const saturation = rgbToSaturation(r,g,b);
  const hue = rgbToHue(r,g,b);
  return [hue, saturation, lightness];
}</code></pre>
<h3 class="graf graf--h4">从HSL计算RGB</h3>
<p class="graf graf--p">在开始计算RGB之前，我们需要一些先决条件值。</p>
<p class="graf graf--p">首先是“色度”值:</p>
<figure class="graf graf--figure"><img decoding="async" class="graf-image jetpack-lazy-image" src="../Images/86a09d91ee0e1f3428d100cdd0d1db59.png" data-image-id="0*Noxj7Gk7KGYqGfvx.png" data-width="331" data-height="35" data-lazy-src="https://storage.googleapis.com/blog-images-backup/0*Noxj7Gk7KGYqGfvx.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://storage.googleapis.com/blog-images-backup/0*Noxj7Gk7KGYqGfvx.png"/><noscript><img data-lazy-fallback="1" decoding="async" class="graf-image" src="../Images/86a09d91ee0e1f3428d100cdd0d1db59.png" data-image-id="0*Noxj7Gk7KGYqGfvx.png" data-width="331" data-height="35" data-original-src="https://storage.googleapis.com/blog-images-backup/0*Noxj7Gk7KGYqGfvx.png"/></noscript><figcaption class="imageCaption">The mathematical formula for chroma</figcaption></figure>
<p class="graf graf--p">我们也有一个临时色调值，我们将使用它的范围来决定我们属于哪个“段”的色调圈:</p>
<figure class="graf graf--figure"><img decoding="async" class="graf-image jetpack-lazy-image" src="../Images/b561cd0bff0337752eedf5e7e8aba929.png" data-image-id="0*DgjQEdahvhEjn60j.png" data-width="90" data-height="50" data-lazy-src="https://storage.googleapis.com/blog-images-backup/0*DgjQEdahvhEjn60j.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://storage.googleapis.com/blog-images-backup/0*DgjQEdahvhEjn60j.png"/><noscript><img data-lazy-fallback="1" decoding="async" class="graf-image" src="../Images/b561cd0bff0337752eedf5e7e8aba929.png" data-image-id="0*DgjQEdahvhEjn60j.png" data-width="90" data-height="50" data-original-src="https://storage.googleapis.com/blog-images-backup/0*DgjQEdahvhEjn60j.png"/></noscript><figcaption class="imageCaption">The mathematical formula for hue prime</figcaption></figure>
<p class="graf graf--p">接下来，我们有一个“x”值，它将用作中间(第二大)分量值:</p>
<figure class="graf graf--figure"><img decoding="async" class="graf-image jetpack-lazy-image" src="../Images/e6fed6722c8ba39e60c9867f21ecabd8.png" data-image-id="0*rmrqPF1miT7a-O-O.png" data-width="381" data-height="30" data-lazy-src="https://storage.googleapis.com/blog-images-backup/0*rmrqPF1miT7a-O-O.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://storage.googleapis.com/blog-images-backup/0*rmrqPF1miT7a-O-O.png"/><noscript><img data-lazy-fallback="1" decoding="async" class="graf-image" src="../Images/e6fed6722c8ba39e60c9867f21ecabd8.png" data-image-id="0*rmrqPF1miT7a-O-O.png" data-width="381" data-height="30" data-original-src="https://storage.googleapis.com/blog-images-backup/0*rmrqPF1miT7a-O-O.png"/></noscript><figcaption class="imageCaption">The mathematical formula for a temporary “x” value</figcaption></figure>
<p class="graf graf--p">我们有一个“m”值，用于调整每个亮度值:</p>
<figure class="graf graf--figure"><img decoding="async" class="graf-image jetpack-lazy-image" src="../Images/f1aae78c09fc9f0de48b2e6eb2ed367d.png" data-image-id="0*TwM-2sYH0uEJhu35.png" data-width="124" data-height="50" data-lazy-src="https://storage.googleapis.com/blog-images-backup/0*TwM-2sYH0uEJhu35.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://storage.googleapis.com/blog-images-backup/0*TwM-2sYH0uEJhu35.png"/><noscript><img data-lazy-fallback="1" decoding="async" class="graf-image" src="../Images/f1aae78c09fc9f0de48b2e6eb2ed367d.png" data-image-id="0*TwM-2sYH0uEJhu35.png" data-width="124" data-height="50" data-original-src="https://storage.googleapis.com/blog-images-backup/0*TwM-2sYH0uEJhu35.png"/></noscript><figcaption class="imageCaption">The mathematical formula for lightness match</figcaption></figure>
<p class="graf graf--p">根据色调素值，<code>r</code>、<code>g</code>和<code>b</code>值将映射到<code>C</code>、<code>X</code>和<code>0</code>:</p>
<figure class="graf graf--figure"><img decoding="async" class="graf-image jetpack-lazy-image" src="../Images/f623ad955a54c9e5bf0dda6f7bf29d24.png" data-image-id="0*k1pxEnWMU-rDQYIG.png" data-width="536" data-height="250" data-lazy-src="https://storage.googleapis.com/blog-images-backup/0*k1pxEnWMU-rDQYIG.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://storage.googleapis.com/blog-images-backup/0*k1pxEnWMU-rDQYIG.png"/><noscript><img data-lazy-fallback="1" decoding="async" class="graf-image" src="../Images/f623ad955a54c9e5bf0dda6f7bf29d24.png" data-image-id="0*k1pxEnWMU-rDQYIG.png" data-width="536" data-height="250" data-original-src="https://storage.googleapis.com/blog-images-backup/0*k1pxEnWMU-rDQYIG.png"/></noscript><figcaption class="imageCaption">The mathematical formula for RGB values without accounting for lightness</figcaption></figure>
<p class="graf graf--p">最后，我们需要映射每个值来调整亮度:</p>
<figure class="graf graf--figure"><img decoding="async" class="graf-image jetpack-lazy-image" src="../Images/4fbc990bcf50ab75a93765a757ed2f95.png" data-image-id="0*Vlii9C8Cum3apLK-.png" data-width="567" data-height="35" data-lazy-src="https://storage.googleapis.com/blog-images-backup/0*Vlii9C8Cum3apLK-.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://storage.googleapis.com/blog-images-backup/0*Vlii9C8Cum3apLK-.png"/><noscript><img data-lazy-fallback="1" decoding="async" class="graf-image" src="../Images/4fbc990bcf50ab75a93765a757ed2f95.png" data-image-id="0*Vlii9C8Cum3apLK-.png" data-width="567" data-height="35" data-original-src="https://storage.googleapis.com/blog-images-backup/0*Vlii9C8Cum3apLK-.png"/></noscript><figcaption class="imageCaption">The mathematical formula to account for lightness with RGB</figcaption></figure>
<p class="graf graf--p">将所有这些放到一个JavaScript函数中:</p>
<pre class="graf graf--pre"><code class="markup--code markup--pre-code">const hslToRgb = (h,s,l) =&gt; {
  const C = (1 - Math.abs(2 * l - 1)) * s;
  const hPrime = h / 60;
  const X = C * (1 - Math.abs(hPrime % 2 - 1));
  const m = l - C/2;
  const withLight = (r,g,b) =&gt; [r+m, g+m, b+m];
</code><code class="markup--code markup--pre-code">if (hPrime &lt;= 1) { return withLight(C,X,0); } else
  if (hPrime &lt;= 2) { return withLight(X,C,0); } else
  if (hPrime &lt;= 3) { return withLight(0,C,X); } else
  if (hPrime &lt;= 4) { return withLight(0,X,C); } else
  if (hPrime &lt;= 5) { return withLight(X,0,C); } else
  if (hPrime &lt;= 6) { return withLight(C,0,X); }
}</code></pre>
<h3 class="graf graf--h4">创建颜色对象</h3>
<p class="graf graf--p">为了在操作它们的属性时易于访问，我们将处理一个JavaScript对象。这可以通过包装先前编写的函数来创建:</p>
<pre class="graf graf--pre"><code class="markup--code markup--pre-code">const rgbToObject = (red,green,blue) =&gt; {
  const [hue, saturation, lightness] = rgbToHsl(red, green, blue);
  return {red, green, blue, hue, saturation, lightness};
}
</code><code class="markup--code markup--pre-code">const hslToObject = (hue, saturation, lightness) =&gt; {
  const [red, green, blue] = hslToRgb(hue, saturation, lightness);
  return {red, green, blue, hue, saturation, lightness};
}</code></pre>
<h3 class="graf graf--h4">例子</h3>
<p class="graf graf--p">我强烈建议你花一些时间<a class="markup--anchor markup--p-anchor" href="https://codepen.io/AdamGiese/full/86b353c35a8bfe0868a8b48683faf668" target="_blank" rel="noopener noreferrer" data-href="https://codepen.io/AdamGiese/full/86b353c35a8bfe0868a8b48683faf668">来玩这个例子</a>。当您调整其他属性时，查看每个属性如何相互作用，可以让您更深入地了解这两种颜色模型是如何配合在一起的。</p>
<h2 class="graf graf--h3">颜色处理</h2>
<p class="graf graf--p">既然我们已经有了在颜色模型之间转换的能力，让我们看看如何操纵这些颜色！</p>
<h3 class="graf graf--h4">更新属性</h3>
<p class="graf graf--p">我们介绍的每个颜色属性都可以单独操作，返回一个新的颜色对象。例如，我们可以编写一个旋转色调角度的函数:</p>
<pre class="graf graf--pre"><code class="markup--code markup--pre-code">const rotateHue = rotation =&gt; ({hue, ...rest}) =&gt; {
  const modulo = (x, n) =&gt; (x % n + n) % n;
  const newHue = modulo(hue + rotation, 360);
</code><code class="markup--code markup--pre-code">return { ...rest, hue: newHue };
}</code></pre>
<p class="graf graf--p"><code>rotateHue</code>函数接受一个<code>rotation</code>参数并返回一个新函数，该函数接受并返回一个颜色对象。这样就可以轻松创建新的“旋转”功能:</p>
<pre class="graf graf--pre"><code class="markup--code markup--pre-code">const rotate30 = rotateHue(30);
const getComplementary = rotateHue(180);
</code><code class="markup--code markup--pre-code">const getTriadic = color =&gt; {
  const first = rotateHue(120);
  const second = rotateHue(-120);
  return [first(color), second(color)];
}</code></pre>
<p class="graf graf--p">按照同样的思路，你可以写函数给<code>saturate</code>或<code>lighten</code>一种颜色——或者，反过来，<code>desaturate</code>或<code>darken</code>。</p>
<pre class="graf graf--pre"><code class="markup--code markup--pre-code">const saturate = x =&gt; ({saturation, ...rest}) =&gt; ({
  ...rest,
  saturation: Math.min(1, saturation + x),
});
</code><code class="markup--code markup--pre-code">const desaturate = x =&gt; ({saturation, ...rest}) =&gt; ({
  ...rest,
  saturation: Math.max(0, saturation - x),
});
</code><code class="markup--code markup--pre-code">const lighten = x =&gt; ({lightness, ...rest}) =&gt; ({
  ...rest,
  lightness: Math.min(1, lightness + x)
});
</code><code class="markup--code markup--pre-code">const darken = x =&gt; ({lightness, ...rest}) =&gt; ({
  ...rest,
  lightness: Math.max(0, lightness - x)
});</code></pre>
<h3 class="graf graf--h4">颜色谓词</h3>
<p class="graf graf--p">除了颜色操作，您还可以编写“谓词”——即返回布尔值的函数。</p>
<pre class="graf graf--pre"><code class="markup--code markup--pre-code">const isGrayscale = ({saturation}) =&gt; saturation === 0;
const isDark = ({lightness}) =&gt; lightness &lt; .5;</code></pre>
<h2 class="graf graf--h3">处理颜色数组</h2>
<h3 class="graf graf--h4">过滤</h3>
<p class="graf graf--p">JavaScript <code>[].filter</code>方法接受一个谓词，并返回一个包含所有“通过”的元素的新数组。我们在上一节中写的谓词可以用在这里:</p>
<pre class="graf graf--pre"><code class="markup--code markup--pre-code">const colors = [/* ... an array of color objects ... */];
const isLight = ({lightness}) =&gt; lightness &gt; .5;
const lightColors = colors.filter(isLight);</code></pre>
<h3 class="graf graf--h4">整理</h3>
<p class="graf graf--p">要对颜色数组进行排序，首先需要编写一个“比较器”函数。这个函数接受一个数组的两个元素，并返回一个数字来表示“获胜者”正数表示第一个元素应该先排序，负数表示第二个元素应该先排序。零值表示平局。</p>
<p class="graf graf--p">例如，下面是一个比较两种颜色亮度的函数:</p>
<pre class="graf graf--pre"><code>const compareLightness = (a,b) =&gt; a.lightness - b.lightness;</code></pre>
<p class="graf graf--p">下面是一个比较饱和度的函数:</p>
<pre class="graf graf--pre"><code>const compareSaturation = (a,b) =&gt; a.saturation - b.saturation;</code></pre>
<p class="graf graf--p">为了防止代码重复，我们可以编写一个高阶函数来返回一个比较函数来比较任何属性:</p>
<pre class="graf graf--pre"><code class="markup--code markup--pre-code">const compareAttribute = attribute =&gt;
  (a,b) =&gt; a[attribute] - b[attribute];
</code><code class="markup--code markup--pre-code">const compareLightness = compareAttribute('lightness');
const compareSaturation = compareAttribute('saturation');
const compareHue = compareAttribute('hue');</code></pre>
<h3 class="graf graf--h4">平均属性</h3>
<p class="graf graf--p">您可以通过组合各种JavaScript数组方法来平均颜色数组的特定属性。首先，您可以通过用reduce求和并除以数组长度来计算属性的平均值:</p>
<pre class="graf graf--pre"><code class="markup--code markup--pre-code">const colors = [/* ... an array of color objects ... */];
const toSum = (a,b) =&gt; a + b;
const toAttribute = attribute =&gt; element =&gt; element[attribute];
const averageOfAttribute = attribute =&gt; array =&gt;
  array.map(toAttribute(attribute)).reduce(toSum) / array.length;</code></pre>
<p class="graf graf--p">您可以使用它来“正常化”颜色数组:</p>
<pre class="graf graf--pre"><code>/* ... continuing */</code></pre>
<pre class="graf graf--pre"><code class="markup--code markup--pre-code">const normalizeAttribute = attribute =&gt; array =&gt; {
  const averageValue = averageOfAttribute(attribute)(array);
  const normalize = overwriteAttribute(attribute)(averageValue);
  return normalize(array);
}
</code><code class="markup--code markup--pre-code">const normalizeSaturation = normalizeAttribute('saturation');
const normalizeLightness = normalizeAttribute('lightness');
const normalizeHue = normalizeAttribute('hue');</code></pre>
<h2 class="graf graf--h3">结论</h2>
<p class="graf graf--p">颜色是网络不可或缺的一部分。将颜色分解成不同的属性，可以让你对颜色进行巧妙的处理，并为各种各样的可能性打开大门。</p><div class="code-block code-block-25">
<div class="blog-plug inline-plug css-plug"><h2>你的前端是否占用了用户的CPU？</h2><p>随着web前端变得越来越复杂，资源贪婪的特性对浏览器的要求越来越高。如果您对监控和跟踪生产环境中所有用户的客户端CPU使用情况、内存使用情况等感兴趣，</p><a target="_blank" href="https://lp.logrocket.com/blg/css-signup">try LogRocket</a><p>.</p><a class="signup" href="https://lp.logrocket.com/blg/css-signup" target="_blank" rel="noopener noreferrer"><img class="alignnone size-full wp-image-46 jetpack-lazy-image" src="../Images/dacb06c713aec161ffeaffae5bd048cd.png" alt="LogRocket Dashboard Free Trial Banner" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2019/12/cpu-memory-usage.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/12/cpu-memory-usage.png"/><noscript><img data-lazy-fallback="1" class="alignnone size-full wp-image-46" src="../Images/dacb06c713aec161ffeaffae5bd048cd.png" alt="LogRocket Dashboard Free Trial Banner" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/12/cpu-memory-usage.png"/></noscript></a><a href="https://lp.logrocket.com/blg/css-signup" target="_blank" rel="noopener noreferrer">https://logrocket.com/signup/</a><p>LogRocket 就像是网络和移动应用的DVR，记录你的网络应用或网站上发生的一切。您可以汇总和报告关键的前端性能指标，重放用户会话和应用程序状态，记录网络请求，并自动显示所有错误，而不是猜测问题发生的原因。</p><p>现代化您调试web和移动应用的方式— <a class="signup" href="https://lp.logrocket.com/blg/css-signup" target="_blank" rel="noopener noreferrer">开始免费监控</a>。</p></div>
</div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
<html>
<head>
<title>When (and when not) to use Redux - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>何时(何时)使用Redux - LogRocket博客</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/when-and-when-not-to-use-redux-41807f29a7fb/#0001-01-01">https://blog.logrocket.com/when-and-when-not-to-use-redux-41807f29a7fb/#0001-01-01</a></blockquote><div><div class="section-inner sectionLayout--insetColumn">
<h3 class="graf graf--h3 graf--startsWithDoubleQuote">“那么我为什么需要Redux呢？”</h3>
<p class="graf graf--p">不要跳到每一个新的闪亮的工具上，并把它包含在你的项目中，这只是常识。毕竟组件不是有它们的状态吗？为什么您需要一个工具来帮助您管理这种状态？</p>
<p class="graf graf--p">不要误会我；React一个人很棒。是的，只用一个框架就可以编写一个完整的应用程序。但是随着你的应用变得越来越复杂，组件越来越多，仅仅使用一个框架来管理它会变得非常棘手。</p>
<p class="graf graf--p">那就是Redux为你化险为夷的地方；它简化了此类应用中出现的复杂性。如果你有一些React的经验，你会知道React的数据流是这样的，父组件传递道具给子组件。在一个庞大的应用程序中，数据通过状态和道具流经如此多的组件，通信往往会变得容易出错，相信我——您的代码将变得非常难以阅读，甚至难以改进。</p>
<p class="graf graf--p">看看下面的图表，看看我在说什么:</p>
<figure class="graf graf--figure"><img decoding="async" class="graf-image jetpack-lazy-image" src="../Images/2bf357553149c7478aec85574fdb1021.png" data-image-id="0*sMMLcNaYusJ3Qgtg.png" data-width="886" data-height="430" data-lazy-src="https://cdn-images-1.medium.com/max/1600/0*sMMLcNaYusJ3Qgtg.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://cdn-images-1.medium.com/max/1600/0*sMMLcNaYusJ3Qgtg.png"/><noscript><img data-lazy-fallback="1" decoding="async" class="graf-image" src="../Images/2bf357553149c7478aec85574fdb1021.png" data-image-id="0*sMMLcNaYusJ3Qgtg.png" data-width="886" data-height="430" data-original-src="https://cdn-images-1.medium.com/max/1600/0*sMMLcNaYusJ3Qgtg.png"/></noscript><figcaption class="imageCaption"><a class="markup--anchor markup--figure-anchor" href="https://css-tricks.com/learning-react-redux/" target="_blank" rel="nofollow noopener noreferrer" data-href="https://css-tricks.com/learning-react-redux/">https://css-tricks.com/learning-react-redux/</a></figcaption></figure>
<p class="graf graf--p">在React(以及其他框架)中，不鼓励没有父子关系的两个组件之间的通信。React建议，如果您必须这样做，您可以按照Flux的模式构建您的全球事件系统——这就是Redux的用武之地。</p>
<p class="graf graf--p">有了Redux，您就有了一个可以保存所有应用程序状态存储库。如果组件A中发生了状态更改，则它会被中继到存储，需要知道组件A中状态更改的其他组件B和C可以订阅存储:</p>
<figure class="graf graf--figure"><img decoding="async" class="graf-image jetpack-lazy-image" src="../Images/f896975308f7cd18dd32ea01d858fd90.png" data-image-id="0*dqzodavE-J3Oz-Ky.png" data-width="853" data-height="500" data-lazy-src="https://cdn-images-1.medium.com/max/1600/0*dqzodavE-J3Oz-Ky.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://cdn-images-1.medium.com/max/1600/0*dqzodavE-J3Oz-Ky.png"/><noscript><img data-lazy-fallback="1" decoding="async" class="graf-image" src="../Images/f896975308f7cd18dd32ea01d858fd90.png" data-image-id="0*dqzodavE-J3Oz-Ky.png" data-width="853" data-height="500" data-original-src="https://cdn-images-1.medium.com/max/1600/0*dqzodavE-J3Oz-Ky.png"/></noscript><figcaption class="imageCaption"><a class="markup--anchor markup--figure-anchor" href="https://css-tricks.com/learning-react-redux/" target="_blank" rel="nofollow noopener noreferrer" data-href="https://css-tricks.com/learning-react-redux/">https://css-tricks.com/learning-react-redux/</a></figcaption></figure>
<p class="graf graf--p">看到了吗？比我们想象的要好得多。如果我们让我们的组件相互通信，我们就会创建一个容易出错和不可读的代码库。Redux让故事变得不一样。</p>
<p class="graf graf--p">组件A将其状态更改发送到存储，如果组件B和C需要此状态更改，它们可以从存储中获取。因此，我们的数据流逻辑是无缝的。</p>
<p class="graf graf--p">除了它的主要任务之外，使用Redux还有很多好处，我只想提出我认为最重要的三个,它们是:</p>
<ol class="postList">
<li class="graf graf--li"><strong class="markup--strong markup--li-strong">结果的可预测性</strong></li>
</ol>
<p class="graf graf--p">由于只有一个真实的来源(商店)，您在将当前状态与应用程序的动作和其他部分同步时会遇到一些问题。</p>
<p class="graf graf--p"><strong class="markup--strong markup--p-strong"> 2。可维护性</strong></p>
<p class="graf graf--p">Redux对代码应该如何组织有严格的指导方针；这进一步确保了可预测的结果，使代码更容易维护。</p>
<p class="graf graf--p"><strong class="markup--strong markup--p-strong"> 3。易于测试</strong></p>
<p class="graf graf--p">在Redux中编写代码涉及到被隔离的纯函数，这与编写可测试代码的黄金法则相关:编写只做一件事并且独立的小函数。</p>
<h3 class="graf graf--h3">嘿…你可能根本不需要Redux</h3>
<p class="graf graf--p">这对你来说似乎是显而易见的，但我还是要提一下。不一定<em class="markup--em markup--p-em">有</em>才能用Redux。有时候不这么做更有意义。如果这些场景中的任何一个对你来说是真的，你可能根本不需要Redux:</p>
<ul class="postList">
<li class="graf graf--li">您和您的伙伴(或者同事，如果你们不是真正的朋友)已经有了一种预定义的方式来共享和安排组件间的状态</li>
<li class="graf graf--li">您仍在体验React或任何其他框架</li>
<li class="graf graf--li">如果你的应用程序主要由简单的动作组成，比如用户界面的改变，那么这些并不一定是Redux store的一部分，可以在组件层次上处理</li>
<li class="graf graf--li">您不需要管理服务器端事件(SSE)或websockets</li>
<li class="graf graf--li">您可以从每个视图的单个数据源获取数据</li>
</ul>
<h3 class="graf graf--h3">Redux:一部分接一部分</h3>
<p class="graf graf--p">对于一个方法可能会让初学者感到困惑的工具来说，Redux的库只有2KB，工具本身由三部分组成:动作、存储和reducers。</p>
<figure class="graf graf--figure"><img decoding="async" class="graf-image jetpack-lazy-image" src="../Images/0492918f159b92af13918b7c39b89ff9.png" data-image-id="0*igA-RO7ila55cVWb.png" data-width="541" data-height="295" data-lazy-src="https://cdn-images-1.medium.com/max/1600/0*igA-RO7ila55cVWb.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://cdn-images-1.medium.com/max/1600/0*igA-RO7ila55cVWb.png"/><noscript><img data-lazy-fallback="1" decoding="async" class="graf-image" src="../Images/0492918f159b92af13918b7c39b89ff9.png" data-image-id="0*igA-RO7ila55cVWb.png" data-width="541" data-height="295" data-original-src="https://cdn-images-1.medium.com/max/1600/0*igA-RO7ila55cVWb.png"/></noscript><figcaption class="imageCaption"><a class="markup--anchor markup--figure-anchor" href="https://stackoverflow.com/questions/45416237/axios-calls-in-actions-redux" target="_blank" rel="nofollow noopener noreferrer" data-href="https://stackoverflow.com/questions/45416237/axios-calls-in-actions-redux">https://stackoverflow.com/questions/45416237/axios-calls-in-actions-redux</a></figcaption></figure>
<h3 class="graf graf--h3">行动</h3>
<p class="graf graf--p">动作只是使用函数创建的事件，将数据从应用程序发送到存储。数据可以通过不同的方式发送，例如提交表单、调用API或基本的用户交互。Redux中的每个动作都有一个<code>type</code>属性，它描述了动作的类型以及发送到存储的信息的“有效载荷”。让我们来看一个最基本的工作实例:</p>
<pre>// The action
  {
    type: ADD_USER,
    payload: {
      username: ‘Chris’,
      email: ‘redux @frameworks.io’
    }
  }
  // The function that creates the action
  function signUpUser(data) {
    return {
      type: ADD_USER,
      payload: data
    }
  }</pre>
<p class="graf graf--p">为了在你的应用中调用一个动作，Redux使用了<code>dispatch()</code>方法，该方法将动作发送到Redux store来指示状态的改变:</p>
<pre>dispatch(signUpUser(data));</pre>
<h3 class="graf graf--h3">还原剂</h3>
<p class="graf graf--p">因为Redux不允许您的应用程序更改状态，而是使用<code>dispatch()</code>来完成。仅仅表示改变状态的意图，它实际上并没有改变状态…这就是Reducers的用武之地。</p>
<p class="graf graf--p">Reducers是通过调度的动作获取应用程序的当前状态，然后返回新状态的函数。看看下面的reducer，它将当前状态和一个动作作为参数，然后返回下一个状态:</p>
<pre>function handleAuth(state, action) {
    return _.assign({}, state, {
      auth: action.payload
    });
  }</pre>
<p class="graf graf--p">构建更复杂的app时，推荐使用Redux的<code>combineReducers()</code>方法。此方法将应用程序中的所有reducer合并到一个reducer列表中，其中每个reducer处理其应用程序状态的一部分，并且每个reducer的状态参数都不同:</p>
<pre>const indexReducer = combineReducers({
    signUp: signUp,
    editProfile: editProfile,
    makePayment: makePayment
  });</pre>
<p class="graf graf--p">这里还值得注意的是，Reducers应该用纯函数编写。下面我列出了这些函数的一些特征:</p>
<ul class="postList">
<li class="graf graf--li">他们不进行外部网络或数据库调用。</li>
<li class="graf graf--li">它们的返回值只取决于它们的参数值。</li>
<li class="graf graf--li">他们的论点应该被看作是不可改变的，也就是说他们不应该被改变。</li>
</ul>
<h3 class="graf graf--h3">商店</h3>
<p class="graf graf--p">商店就像Redux的心脏。它是保存应用程序所有状态的唯一来源，并通过一些方法、调度操作和注册侦听器提供对状态的访问。任何调度的动作都通过reducers向存储返回一个新状态。看看这个Redux商店的基本例子:</p>
<pre>import { createStore } from‘ redux’;
  let store = createStore(indexReducer);
  let signUpInfo = {
    username: ‘Chris’,
    email: ‘redux @frameworks.io’
  };
  store.dispatch(signUpUser(signUpInfo));</pre>
<h3 class="graf graf--h3">函数式编程和Redux</h3>
<p class="graf graf--p">如果你打算使用Redux，你应该知道函数式编程是如何工作的。Redux是建立在函数式编程的原则之上的，理解函数式编程的概念会让你了解Redux是如何工作的。</p>
<p class="graf graf--p">让我们浏览一下函数式编程的关键准则:</p>
<ul class="postList">
<li class="graf graf--li">它可以使用纯函数、递归函数、高阶函数、闭包函数和匿名函数</li>
<li class="graf graf--li">它可以使用辅助功能，如映射、过滤和减少</li>
<li class="graf graf--li">它可以将功能链接在一起</li>
<li class="graf graf--li">它可以将函数视为一级对象</li>
<li class="graf graf--li">它可以将函数作为参数传递</li>
<li class="graf graf--li">它可以使用函数、递归和数组来控制流程</li>
<li class="graf graf--li">状态不会改变(即，它是不可变的)</li>
<li class="graf graf--li">代码执行的顺序并不重要</li>
</ul>
<p class="graf graf--p">函数式编程包括编写更简单、更小和孤立的函数。通过遵循这种模式，代码维护、测试和调试变得更加容易。由于这些函数很小并且是孤立的，这使得它们可以重复使用，因此它们可以被复制并粘贴到任何需要的地方。</p>
<p class="graf graf--p">这也消除了编写更多代码的需要，在我看来这很棒。使用函数式编程时，理解纯函数、匿名函数、闭包和高阶函数等概念非常重要。</p>

<div class="podcast-container">
<div class="podcast-embed">
<h2>我们不只是写Redux，我们也谈论它。现在听着:</h2>
<p>或者以后订阅</p>
<h3>摘要</h3>

</div>
</div>
<h3 class="graf graf--h3">诚然，Redux是管理应用程序状态的一个很好的库，同样，Redux也获得了很大的吸引力。那么你还需要知道什么？</h3>
<p class="graf graf--p">除了被优步和Twitter这样的公司广泛使用，Redux也已经在WordPress这样的项目中成功实现。当然，Redux并不适合所有应用程序的观点是存在的，这是事实。</p>
<p class="graf graf--p">主要执行简单动作，不需要服务器端渲染的应用大概不需要Redux它们的动作可以在组件级别处理。</p>
<p class="graf graf--p">无论哪种方式，Redux都是一个很棒的工具，我认为您应该去看看，尤其是如果您正在使用React的话。</p>
<p class="graf graf--p">使用LogRocket消除传统反应错误报告的噪音</p><div class="code-block code-block-17">
<div class="blog-plug inline-plug react-plug" vwo-el-id="26283398190">
<h2 vwo-el-id="41600691720">是一款React analytics解决方案，可保护您免受数百个误报错误警报的影响，只针对少数真正重要的项目。LogRocket告诉您React应用程序中实际影响用户的最具影响力的bug和UX问题。</h2>
<a href="https://lp.logrocket.com/blg/react-signup-issue-free" target="_blank" vwo-el-id="19356441070">LogRocket
</a><p>自动聚合客户端错误、反应错误边界、还原状态、缓慢的组件加载时间、JS异常、前端性能指标和用户交互。然后，LogRocket使用机器学习来通知您影响大多数用户的最具影响力的问题，并提供您修复它所需的上下文。</p><a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="19356441380">
<img class="first-react-image alignnone size-full wp-image-46 jetpack-lazy-image jetpack-lazy-image--handled" src="../Images/f300c244a1a1cf916df8b4cb02bec6c6.png" vwo-el-id="18272717540" data-lazy-loaded="1" data-original-src="https://files.readme.io/27c94e7-Image_2017-06-05_at_9.46.04_PM.png"/>
</a>
<a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="19356441690">
<img class="second-react-image alignnone size-full wp-image-46 jetpack-lazy-image jetpack-lazy-image--handled" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" vwo-el-id="30720362350" data-lazy-loaded="1" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/>
</a>
<a href="https://lp.logrocket.com/blg/react-signup-issue-free" target="_blank" rel="noopener noreferrer" vwo-el-id="35866400580">LogRocket
</a><p>关注重要的React bug—<a class="signup" href="https://lp.logrocket.com/blg/react-signup-issue-free" target="_blank" rel="noopener noreferrer" vwo-el-id="40093418840">今天就试试LogRocket】。</a></p><p vwo-el-id="28675661060">Focus on the React bugs that matter —
<a class="signup" href="https://lp.logrocket.com/blg/react-signup-issue-free" target="_blank" rel="noopener noreferrer" vwo-el-id="40093418840">try LogRocket today</a>.
</p>
</div></div>
</div>
</div>    
</body>
</html>
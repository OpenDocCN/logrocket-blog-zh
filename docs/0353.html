<html>
<head>
<title>Node.js 12: The future of server-side JavaScript - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>Node.js 12:服务器端JavaScript - LogRocket博客的未来</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/node-js-12/#0001-01-01">https://blog.logrocket.com/node-js-12/#0001-01-01</a></blockquote><div><article class="article-post">
<h2>介绍</h2>
<p>自从2009年在<a href="https://en.wikipedia.org/wiki/Node.js" target="_blank" rel="noopener noreferrer">发布以来，Node.js </a>已经成为一项改变游戏规则的技术。简而言之，它允许开发人员使用JavaScript在服务器端运行脚本，在页面被发送到用户的web浏览器之前生成动态web内容。因此，Node.js代表了一种“JavaScript无处不在”的范式，围绕一种编程语言统一了web应用程序开发，而不需要服务器端和客户端脚本使用不同的语言。</p>
<p>如果你像我一样是JavaScript和Node.js的粉丝，你会很兴奋地知道它会变得更好。</p>
<h2>节点12新增和改进</h2>
<p>为什么JavaScript会变得更好？Node.js 12几个月前刚掉了。</p>
<p>2019年4月23日，<a href="https://medium.com/@nodejs/introducing-node-js-12-76c41a1b3f3f" target="_blank" rel="noopener noreferrer"> Node.js 12正式上线</a>，各地JavaScript爱好者欢欣鼓舞。让我们明确一点，这不仅仅是一次常规的旧版本更新，这是一次带有一些重大升级的大检修，让我们来看看亮点列表。</p>
<h2>V8 JavaScript引擎升级</h2>
<p>除了每一个新版本的JavaScript V8引擎带来的<a href="https://v8.dev/blog/v8-release-74" target="_blank" rel="noopener noreferrer">预期的性能调整和改进</a>之外，这次还有一些真正值得注意的升级。其中包括:</p>
<ul>
<li><strong> <a href="https://v8.dev/blog/v8-release-72#async-stack-traces" target="_blank" rel="noopener noreferrer">零成本异步堆栈跟踪</a></strong>——这将有助于用异步调用帧丰富<code>error.stack</code>属性，而不会给V8引擎增加额外的运行时间</li>
<li><strong> <a href="https://v8.dev/blog/v8-release-74#faster-calls-with-arguments-mismatch" target="_blank" rel="noopener noreferrer">参数不匹配的更快调用</a></strong>–过去，V8必须以相同的方式处理所有参数过多或过少的函数调用，这是以性能为代价的。现在，它足够聪明，知道什么时候可以跳过这一步，从而减少高达60%的呼叫开销</li>
<li><strong> <a href="https://v8.dev/blog/v8-release-73#faster-await" target="_blank" rel="noopener noreferrer">更快的异步函数和承诺</a></strong>——的确，使用异步实际上比现在的承诺快了两个额外的<em>微信号</em>，如果除了async / await为不熟悉承诺的开发人员提供的更同步风格的语法之外，你还需要一个理由</li>
<li><strong> <a href="https://v8.dev/blog/v8-release-72#javascript-parsing" target="_blank" rel="noopener noreferrer">更快的JavaScript解析</a></strong>——在网页启动时，不到10%的V8时间花在解析JS上。最新发布的JavaScript解析器将桌面解析速度提高了30%</li>
</ul>
<h2>TLS 1.3带来更高的安全性</h2>
<p>TLS代表传输层安全性，是节点处理加密流通信的方式。</p>
<p>随着Node.js 12的发布，<a href="https://developer.ibm.com/blogs/tls13-is-coming-to-nodejs/" target="_blank" rel="noopener noreferrer"> TLS获得了1.3版</a>的升级，这听起来微不足道，但实际上是一次重大更新，具有众多的性能和安全增强。虽然乍听起来有些违反直觉，但TLS 1.3实际上是一个比TLS 1.2更容易实现的协议，它更安全，更容易配置，并且可以更快地在应用程序之间协商会话。</p>
<p>通过使用TLS 1.3，节点应用将增加最终用户隐私，同时通过减少HTTPS握手所需的时间来提高请求的性能。</p>
<p>底线:为使用它的每个人提供更好的安全性，并减少通信服务之间的延迟。这对我来说是一个重大的胜利。</p>
<h2>正确配置的默认堆限制</h2>
<p>现在，让我们谈谈一些较低层次的改进。到目前为止，JavaScript堆大小默认为V8为浏览器设置的最大堆大小，除非手动配置。随着Node.js 12的发布，js堆大小将基于可用内存进行配置，这确保了Node不会试图使用比可用内存更多的内存，并在内存耗尽时终止进程。</p>
<p>在处理大量数据时，告别内存不足错误——至少有时是这样。如果需要，旧的<code>--max-old-space-size</code>标志仍可用于设置不同的限制，但希望该功能将减少设置标志的需要。</p>
<h2>默认的http解析器变成了llhttp</h2>
<p>许多人(包括我自己)不知道的是，Node中使用的当前的<code>http_parser</code>库很难维护和改进，这就是<a href="https://github.com/nodejs/llhttp#readme" target="_blank" rel="noopener noreferrer"> llhttp </a>诞生的原因。该项目是http_parser到TypeScript的一个端口，然后通过llparse运行，生成C或bitcode输出。</p>
<p>结果是，<a href="https://github.com/nodejs/llhttp#performance" target="_blank" rel="noopener noreferrer"> llhttp比http_parser快156% </a>，它用更少的代码行编写，所有性能优化都是自动生成的，这与http_parser手工优化的代码相反。</p>
<p>在Node.js 12中，他们决定第一次将默认解析器切换到llhttp，并更彻底地对其进行测试。让我们希望，当有许多不同需求的不同应用程序正在试用它时，它会继续表现良好。</p>
<h2>按需诊断报告</h2>
<p>将话题转到调试上来，Node.js 12中有一个新的实验性特性，允许用户按需或在某些触发事件发生时生成报告。</p>
<p>这种实时报告有助于诊断生产中的问题，包括崩溃、性能低下、内存泄漏、高CPU使用率、意外错误等。–这种东西通常需要几个小时甚至几天来调试、诊断和修复。</p>
<h2>集成堆转储</h2>
<p>这个版本中关于堆的另一个特性是集成的堆转储，它是Node.js 12附带的，已经内置，肯定会加快调试过程。</p>
<p>现在不需要安装新的模块来调查内存问题——只需通过命令行或API调用告诉Node您想要哪种JSON格式的诊断摘要，并解析您可以处理的所有信息。</p>
<h2>Node.js中的本机模块变得更容易</h2>
<p>从低级的改进退一步说，对于节点生态系统中的开发者和模块制造商来说，还有一些很酷的东西。</p>
<p>为Node制作和构建本机模块的工作在继续改进，包括更好地支持与工作线程结合的本机模块，以及N-API的第4版，这使得为本机异步功能配置自己的线程变得更加容易。</p>
<p>总而言之，这意味着特定于节点的模块的创建者和维护者维护这些模块几乎和纯JavaScript模块创建者一样容易。维护人员需要为他们希望他们的模块支持的每个Node.js版本重新构建分布式二进制文件，这增加了复杂性，现在N-API很大程度上抽象掉了这种复杂性。</p>
<h2>工作线程即将到来–实验标志已被移除</h2>
<p>工作线程，虽然从Node 10开始就已经存在，但不再需要启用标志——它们正在走出实验阶段。在Node.js 11.7.0之前，您不能访问工作线程模块，除非您在命令行中使用<code>--experimental-worker</code>标志启动<code>node</code>。</p>
<pre>$ node -e "require('worker_threads'); console.log('success');"
internal/modules/cjs/loader.js:605
    throw err;
    ^
Error: Cannot find module 'worker_threads'
    at Function.Module._resolveFilename (internal/modules/cjs/loader.js:603:15)
    at Function.Module._load (internal/modules/cjs/loader.js:529:25)
    at Module.require (internal/modules/cjs/loader.js:657:17)
    at require (internal/modules/cjs/helpers.js:22:18)
    at [eval]:1:1
    at Script.runInThisContext (vm.js:123:20)
    at Object.runInThisContext (vm.js:312:38)
    at Object. ([eval]-wrapper:6:22)
    at Module._compile (internal/modules/cjs/loader.js:721:30)
    at evalScript (internal/bootstrap/node.js:720:27)
$
$ node --experimental-worker -e "require('worker_threads'); console.log('success');"
success
$</pre>
<p>工作人员在执行CPU密集型JavaScript操作时确实很出色，他们不会对I/O密集型工作有太大帮助。Node的内置异步I/O操作比Workers更高效。</p>
<h2>启动时间改进</h2>
<p>Node.js 11通过使用内置代码缓存支持，将<a href="https://github.com/nodejs/node/pull/24950" target="_blank" rel="noopener noreferrer">工作线程的启动时间减少了近60% </a>。</p>
<p>Node 12基于这一想法，在构建时提前为内置库<strong>生成代码缓存，允许主线程使用代码缓存启动任何用JavaScript编写的内置库的初始加载。</strong></p>
<p><a href="https://github.com/nodejs/node/pull/27161" target="_blank" rel="noopener noreferrer">最终结果是主线程的启动时间又加快了30% </a>,你的应用程序将比以往任何时候都更快地为用户加载。</p>
<h2>ES6模块支持，快到了🙌</h2>
<p>我把最好的留到了最后。对我来说，最令人兴奋的功能之一是<a href="https://medium.com/@nodejs/announcing-a-new-experimental-modules-1be8d2d6c2ff" target="_blank" rel="noopener noreferrer"> ES6模块支持</a>——这是我们许多人一直在等待的。这个功能仍然是试验性的，<a href="https://github.com/nodejs/modules" target="_blank" rel="noopener noreferrer">节点团队正在寻找试用者的反馈</a>,但是想象一下能够从前端无缝过渡到后端JavaScript而不用担心这个世界。</p>
<p>以下是最新版本的<code>-–experimental-modules</code>包含的最佳内容:</p>
<ul>
<li>ES2015 import语句使用相对URL<code>./examples.js</code>、绝对URL<code>file:///opt.app/examples.js</code>、包名<code>example-package</code>或包内路径<code>example-package/lib/examples.js</code>引用JavaScript文件。</li>
</ul>
<pre>// relative urls
‘./examples.js’
 
// absolute URLs
‘file:///opt.app/examples.js’
 
// package names
‘example-package’
 
// paths within packages
example-package/lib/examples.js</pre>
<ul>
<li><code>.js</code>文件中的导入和导出语法有效。最后，开发者可以指定默认导出<code>import test from</code> <code>'./examples'</code>、命名导出<code>import {example1, example2} from './examples'</code>和名称空间导出<code>import * as samples from './examples'</code>，就像自从ES6出现以来我们在传统JavaScript中所做的一样。</li>
</ul>
<pre>// default imports / exports
import test from ‘./examples’
 
// named imports / exports
import {example1, example2} from ‘./examples’
 
// namespace exports
 import * as samples from ‘./examples’</pre>
<ul>
<li>将<code>"type": "module"</code>添加到项目的<code>package.json</code>中，Node.js会将项目中的所有<code>.js</code>文件视为es模块。这种方法允许Node使用<code>package.json</code>进行包级元数据和配置，类似于Babel和其他捆绑和配置工具已经使用的方式。</li>
<li>文件的显式扩展名将被视为以<code>.mjs</code>结尾的模块，而文件将被视为以<code>.cjs</code>结尾的普通文件。这些文件仍然使用<code>require</code>和<code>module.exports</code>类型的语法。</li>
</ul>
<p>哈利路亚！我真的很期待这一天的到来。</p>
<h2>节点12的新编译器和平台最低标准</h2>
<p>最后但同样重要的是，对运行节点本身有了新的要求。</p>
<p>随着Node.js通过内部改进和升级到<a href="https://blog.logrocket.com/how-javascript-works-optimizing-the-v8-compiler-for-efficiency/" target="_blank" rel="noopener noreferrer"> V8引擎</a>的C++来实现新的功能，Node.js 12也有了新的最低要求。在macOS和Windows之外的平台上，代码库现在至少需要GCC 6和glibc 2.17。发布的二进制文件使用这个新的工具链最小值，并包括新的编译时性能和安全性增强。</p>
<p>如果你使用Mac或Windows机器，你应该没问题:运行Node.js 11的Windows最低要求是一样的，Mac用户至少需要<a href="https://developer.apple.com/xcode/" target="_blank" rel="noopener noreferrer"> Xcode 8 </a>和最低<a href="https://support.apple.com/downloads/OS-X-Yosemite" target="_blank" rel="noopener noreferrer">10.10</a>“Yosemite”的macOS。来自nodejs.org的Linux兼容二进制文件将支持<a href="https://developers.redhat.com/products/rhel/download" target="_blank" rel="noopener noreferrer"> Enterprise Linux 7 </a>、<a href="https://www.debian.org/releases/jessie/debian-installer/" target="_blank" rel="noopener noreferrer"> Debian 8 </a>和<a href="http://releases.ubuntu.com/14.04/" target="_blank" rel="noopener noreferrer"> Ubuntu 14.04 </a>，但是在原生不支持GCC 6的系统上定制工具链可能是必要的。我相信你会很快找到需要什么的。</p>
<h2>结论</h2>
<p>是的，Node.js只有10年的历史，是的，它是单线程的，是的，它不像其他一些编程语言那样被广泛采用和利用，但Node拥有其他编程语言无法拥有的东西:<a href="https://en.wikipedia.org/wiki/Node.js" target="_blank" rel="noopener noreferrer">它是用JavaScript构建的，可以在客户端和服务器端运行</a>。</p>
<p>致力于支持和改进Node <a href="https://foundation.nodejs.org/about/members" target="_blank" rel="noopener noreferrer">的团队和公司都是业内最优秀、最聪明的</a>。Node继续从核心JavaScript和其他语言中学习，挑选合适的部分整合到自身中，成为开发人员和应用程序等越来越好的平台。</p>
<p>Node.js 12带来了一些非常令人兴奋的改进，比如ES6模块支持、更好的应用程序安全性和更快的启动时间。虽然它要到2019年10月才会进入<a href="https://github.com/nodejs/release#release-schedule" target="_blank" rel="noopener noreferrer"> LTS(长期支持)模式</a>，但我很想挖掘这些新功能，看看团队还能想出什么来继续让这个平台成为一个伟大的服务器端解决方案。</p>
<p> </p><div class="code-block code-block-23">
<div class="blog-plug inline-plug node-plug"><h2>200只<img src="../Images/61167b9d027ca73ed5aaf59a9ec31267.png" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2019/10/green-check.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" class=" jetpack-lazy-image" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/10/green-check.png"/> <noscript> <img data-lazy-fallback="1" src="../Images/61167b9d027ca73ed5aaf59a9ec31267.png" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/10/green-check.png"/> </noscript>显示器出现故障，生产中网络请求缓慢</h2><p>部署基于节点的web应用程序或网站是容易的部分。确保您的节点实例继续为您的应用程序提供资源是事情变得更加困难的地方。如果您对确保对后端或第三方服务的请求成功感兴趣，</p><a href="https://lp.logrocket.com/blg/node-signup" target="_blank">try LogRocket</a><p>. </p><a class="signup" href="https://lp.logrocket.com/blg/node-signup" target="_blank" rel="noopener noreferrer"><img src="../Images/cae72fd2a54c5f02a6398c4867894844.png" alt="LogRocket Network Request Monitoring" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2019/12/network-request-filter-2-1.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" class=" jetpack-lazy-image" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/12/network-request-filter-2-1.png"/><noscript><img data-lazy-fallback="1" src="../Images/cae72fd2a54c5f02a6398c4867894844.png" alt="LogRocket Network Request Monitoring" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/12/network-request-filter-2-1.png"/></noscript></a><a href="https://lp.logrocket.com/blg/node-signup" target="_blank" rel="noopener noreferrer">https://logrocket.com/signup/</a><p>LogRocket 就像是网络和移动应用程序的DVR，记录下用户与你的应用程序交互时发生的一切。您可以汇总并报告有问题的网络请求，以快速了解根本原因，而不是猜测问题发生的原因。</p><p>LogRocket检测您的应用程序以记录基线性能计时，如页面加载时间、到达第一个字节的时间、慢速网络请求，还记录Redux、NgRx和Vuex操作/状态。</p><a class="signup" href="https://lp.logrocket.com/blg/node-signup" target="_blank" rel="noopener noreferrer">Start monitoring for free</a><p>. </p></div>
</div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
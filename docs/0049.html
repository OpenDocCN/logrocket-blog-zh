<html>
<head>
<title>Using setState in React components - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>在React组件中使用setState-log rocket博客</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/using-setstate-react-components/#0001-01-01">https://blog.logrocket.com/using-setstate-react-components/#0001-01-01</a></blockquote><div><article class="article-post">
<p><em> <strong>编者按</strong>:本帖最后更新于2021年7月30日。它可能仍然包含过时的信息。</em></p>
<p>与道具一样，React中的状态是存储数据并影响组件呈现或行为方式的对象。与props不同，状态完全在组件中管理，并且可以随着时间的推移而改变。</p>
<p>用户操作、网络活动、API请求或特定的应用程序行为通常会触发React组件的状态变化。</p>
<p>在本文中，我们将回顾:</p>

<h2 id="what-component-state-react">React中的组件状态是什么？</h2>
<p>有状态的组件称为有状态组件，而没有状态的组件称为无状态组件。</p>
<p>一个组件可以有一个初始状态集，访问它，并更新它。在下面的代码块中，我们设置组件的初始状态。这是通过构造函数方法完成的:</p>
<pre>import React, { Component } from 'react';

class Food extends Component {
  constructor(props) {
    super(props)

    this.state = {
      fruits: ['apple', 'orange'],
      count: 0
    }
  }
}</pre>
<p>因为状态是普通的JavaScript对象，<code>this.state</code>必须等于一个对象:</p>
<pre>this.state = {
  fruits: ['apple', 'orange'],
  count: 0
}</pre>
<p>避免将<code>state</code>对象与其他实例属性混淆。很容易假设您可以在构造函数中定义另一个对象，并尝试像使用<code>state</code>一样使用它，但是<code>state</code>实例是一个特殊的实例，因为React管理它:</p>
<pre>...
//constructor function above

this.state = {
  fruits: ['apple', 'orange'],
  count: 0
}
    
this.user = {
  name: 'Obaseki Nosa'
}

...</pre>
<p>虽然<code>this.state</code>和<code>this.user</code>都是在构造函数中初始化的对象，但是只有<code>this.state</code>与<code>setState()</code>发生反应，并由React管理。</p>
<h2 id="how-access-component-state-react">如何在React中访问组件状态？</h2>
<p>我们可以使用<code>this.state.property_name</code>像访问其他对象一样访问组件状态。</p>
<p>为了访问上面例子中的<code>count</code>,我们；将使用<code>this.state.count</code>:</p>
<pre>render() {
  return (
    &lt;div className = "container"&gt;
      &lt;h2&gt; Hello!!!&lt;/h2&gt;
      &lt;p&gt; I have {this.state.count} fruit(s)&lt;/p&gt;
    &lt;/div&gt;
  );
}</pre>
<h2 id="how-update-component-state-react">如何在React中更新我的组件状态？</h2>
<p>尽管从技术上讲，可以从代码中的任何地方写入到<code>this.state</code>，但它不会提示重新呈现，这将导致在试图通过<code>this.state</code>访问值时出现不稳定和不正确的状态值。</p>
<p>您应该直接写入<code>this.state</code>的唯一地方是组件的构造函数方法。</p>
<p>在其他地方使用<code>setState()</code>方法；这样做接受一个最终合并到组件现有状态的对象。</p>
<p>例如，以下内容不会重新渲染组件:</p>
<pre>// Wrong
this.state.name = 'Obaseki Nosa';</pre>
<p>而是使用<code>setState()</code>。</p>
<h2 id="how-use-setstate-react">我如何在React中使用<code>setState()</code>？</h2>
<p><code>setState()</code>调度改变组件的状态对象，并告诉React组件及其子组件必须用更新后的状态重新呈现:</p>
<pre>// Correct
this.setState({name: 'Obaseki Nosa'});</pre>
<p>React有意等待，直到所有组件在它们的事件处理程序中调用<code>setState()</code>后再重新呈现。这通过避免不必要的重新呈现来提高性能。</p>
<p><code>setState()</code>可以被认为是请求而不是立即命令来更新组件。这就是为什么试图在<code>setState()</code>之后立即使用<code>this.state</code>会导致不正确的行为:</p>
<pre>// Trying to change the value of this.state.count from previous example
this.setState({
  count: 4
});

console.log(this.state.count); // 0</pre>
<p><code>this.state.count</code>返回<code>0</code>,因为即使该值是用<code>setState()</code>设置的，在试图用<code>this.state</code>使用该值之前，它只是被调度而不是重新呈现。</p>
<p><code>setState()</code>总是导致重新招标，除非<code>shouldComponentUpdate()</code>返回<code>false</code>。</p>
<h2 id="using-setstate-react-lifecycle-methods">在React生命周期方法中使用<code>setState()</code></h2>
<p>在<a href="https://blog.logrocket.com/react-lifecycle-methods-tutorial-examples/"> React的生命周期方法</a>中调用<code>setState()</code>需要一定程度的谨慎。有一些方法调用<code>setState()</code>会导致不希望的结果，还有一些方法需要完全避免。让我们来看看几种方法，以及它们在调用<code>setState()</code>时的反应</p>
<h3><code>render()</code></h3>
<p>在这里调用<code>setState()</code>使得一个组件产生无限循环成为可能。</p>
<p><code>render()</code>函数应该是纯的，这意味着它不修改组件的状态。每次调用它都返回相同的结果，并且它不直接与浏览器交互。</p>
<p>在这种情况下，避免在这里使用<code>setState()</code>。</p>
<h3><code>constructor()</code></h3>
<p>不要在<code>constructor()</code>中调用<code>setState()</code>。相反，如果一个组件需要使用本地状态，直接在构造函数中将初始状态赋给<code>this.state</code>。</p>
<h3><code>componentDidMount()</code></h3>
<p><code>componentDidMount()</code>组件挂载后立即调用。您可以在<code>componentDidMount()</code>中立即调用<code>setState()</code>并触发额外的渲染，但这发生在浏览器更新屏幕之前，调用两次<code>render()</code>。</p><div class="code-block code-block-54">
<hr/>
<h3>更多来自LogRocket的精彩文章:</h3>

<hr/></div>
<h3><code>componentDidUpdate()</code></h3>
<p><code>componentDidUpdate()</code>更新后立即调用。您可以在这里立即调用<code>setState()</code>,但是它必须包含在如下示例所示的条件中，否则会导致无限循环:</p>
<pre>componentDidUpdate(prevProps, prevState) {
  let newName = 'Obaseki Nosa'
  // Don't forget to compare states
  if (prevState &amp;&amp; prevState.name !== newName) {
    this.setState({name: newName});
  }
}
</pre>
<h3><code>componentWillUnmount()</code></h3>
<p>不要在这里调用<code>setState()</code>，因为组件不会重新呈现。一旦组件实例被卸载，它就不会再被装载。</p>
<h2>结论</h2>
<p>我们对<code>setState()</code>的概述到此结束。使用<code>setState()</code>时需要记住的一些事情包括:</p>
<ol>
<li><code>setState()</code>是async，这意味着当试图立即访问该值时，不能保证状态已经更新</li>
<li>你只能用<code>setState</code>改变<code>state</code>,而React将对改变做出反应</li>
</ol>
<p>干杯！！！</p><div class="code-block code-block-17">
<div class="blog-plug inline-plug react-plug" vwo-el-id="26283398190">
<h2 vwo-el-id="41600691720">使用LogRocket消除传统反应错误报告的噪音</h2>
<a href="https://lp.logrocket.com/blg/react-signup-issue-free" target="_blank" vwo-el-id="19356441070">LogRocket
</a><p>是一款React analytics解决方案，可保护您免受数百个误报错误警报的影响，只针对少数真正重要的项目。LogRocket告诉您React应用程序中实际影响用户的最具影响力的bug和UX问题。</p><a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="19356441380">
<img class="first-react-image alignnone size-full wp-image-46 jetpack-lazy-image jetpack-lazy-image--handled" src="../Images/f300c244a1a1cf916df8b4cb02bec6c6.png" vwo-el-id="18272717540" data-lazy-loaded="1" data-original-src="https://files.readme.io/27c94e7-Image_2017-06-05_at_9.46.04_PM.png"/>
</a>
<a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="19356441690">
<img class="second-react-image alignnone size-full wp-image-46 jetpack-lazy-image jetpack-lazy-image--handled" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" vwo-el-id="30720362350" data-lazy-loaded="1" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/>
</a>
<a href="https://lp.logrocket.com/blg/react-signup-issue-free" target="_blank" rel="noopener noreferrer" vwo-el-id="35866400580">LogRocket
</a><p>自动聚合客户端错误、反应错误边界、还原状态、缓慢的组件加载时间、JS异常、前端性能指标和用户交互。然后，LogRocket使用机器学习来通知您影响大多数用户的最具影响力的问题，并提供您修复它所需的上下文。</p><p vwo-el-id="28675661060">关注重要的React bug—<a class="signup" href="https://lp.logrocket.com/blg/react-signup-issue-free" target="_blank" rel="noopener noreferrer" vwo-el-id="40093418840">今天就试试LogRocket】。</a></p>
</div></div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
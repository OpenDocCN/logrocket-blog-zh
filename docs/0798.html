<html>
<head>
<title>Creating a CRUD API with Node, Express, and gRPC - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>用Node、Express和gRPC - LogRocket Blog创建CRUD API</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/creating-a-crud-api-with-node-express-and-grpc/#0001-01-01">https://blog.logrocket.com/creating-a-crud-api-with-node-express-and-grpc/#0001-01-01</a></blockquote><div><article class="article-post">
<p>在网络世界中，速度变得越来越有价值。</p>
<p>开发人员推出新版本的软件、框架和库时，无疑投入了大量时间来减少加载时间、请求处理和资源消耗。</p>
<p>例如，HTTP/2 诞生于无数的优化之中，这些优化将网络引向了一个比我们以往任何时候都更健壮、更快速、更轻便的领域。</p>
<p>RPC(代表远程过程调用)是一种众所周知的方法，当您需要稍微远程化或分布式时，它会很有吸引力。在企业服务器和复杂的大量代码需要设置的时代，它曾经占据统治地位。</p>
<p>经过多年的孤立，谷歌重新设计了它，并给它注入了新的光芒。</p>
<p>gRPC是一个现代的开源高性能RPC框架，可以在任何环境下运行。</p>
<p>借助对负载平衡、跟踪、运行状况检查和身份验证的可插拔支持，它可以高效地连接数据中心内和数据中心间的服务。</p>
<p>它也适用于分布式计算的最后一英里，将设备、移动应用程序和浏览器连接到后端服务。</p>
<p>它支持HTTP/2、跨平台和开源。就尺寸而言，它也很紧凑。</p>
<p>gRPC可以与许多编程语言一起工作，比如Java、Go、Ruby、Python等等。</p>
<p>继续检查他们的官方文档<a href="https://grpc.io/docs/quickstart/" target="_blank" rel="noopener noreferrer">链接</a>(以及它的<a href="https://github.com/grpc/grpc" target="_blank" rel="noopener noreferrer"> GitHub页面</a>)来检查是否有对你的支持。</p>
<p>即使你的语言没有列在那里，你也可以在Docker图片中使用<a href="https://grpc.io/docs/tutorials/basic/web/" target="_blank" rel="noopener noreferrer"> web特性</a>。</p>
<p>它的工作流程是这样的:</p>
<figure id="attachment_16995" aria-describedby="caption-attachment-16995" class="wp-caption aligncenter"><img data-attachment-id="16995" data-permalink="https://blog.logrocket.com/creating-a-crud-api-with-node-express-and-grpc/grpc-server/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/04/gRPC-server.png" data-orig-size="1600,1032" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="gRPC-server" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/04/gRPC-server-300x194.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/04/gRPC-server-1024x660.png" decoding="async" class="wp-image-16995 jetpack-lazy-image" src="../Images/f516b64102ba3f052c47d924b1b6fbcd.png" alt="gRPC" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2020/04/gRPC-server.png 1600w, https://blog.logrocket.com/wp-content/uploads/2020/04/gRPC-server-300x194.png 300w, https://blog.logrocket.com/wp-content/uploads/2020/04/gRPC-server-1024x660.png 1024w, https://blog.logrocket.com/wp-content/uploads/2020/04/gRPC-server-768x495.png 768w, https://blog.logrocket.com/wp-content/uploads/2020/04/gRPC-server-1536x991.png 1536w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2020/04/gRPC-server.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/04/gRPC-server.png"/><noscript><img data-lazy-fallback="1" data-attachment-id="16995" data-permalink="https://blog.logrocket.com/creating-a-crud-api-with-node-express-and-grpc/grpc-server/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/04/gRPC-server.png" data-orig-size="1600,1032" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="gRPC-server" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/04/gRPC-server-300x194.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/04/gRPC-server-1024x660.png" decoding="async" loading="lazy" class="wp-image-16995" src="../Images/f516b64102ba3f052c47d924b1b6fbcd.png" alt="gRPC" srcset="https://blog.logrocket.com/wp-content/uploads/2020/04/gRPC-server.png 1600w, https://blog.logrocket.com/wp-content/uploads/2020/04/gRPC-server-300x194.png 300w, https://blog.logrocket.com/wp-content/uploads/2020/04/gRPC-server-1024x660.png 1024w, https://blog.logrocket.com/wp-content/uploads/2020/04/gRPC-server-768x495.png 768w, https://blog.logrocket.com/wp-content/uploads/2020/04/gRPC-server-1536x991.png 1536w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/04/gRPC-server.png"/></noscript><figcaption id="caption-attachment-16995" class="wp-caption-text">gRPC Workflow</figcaption></figure>
<p>整个体系结构基于已知的客户机-服务器结构。</p>
<p>gRPC客户端应用程序可以向服务器应用程序发出直接请求。客户机和服务器都包含一个公共接口，就像一个契约，在这个契约中，它决定了每个操作将具有的方法、类型和返回。</p>
<p>服务器确保接口将由其服务提供，而客户端有存根来保证方法是相似的。</p>
<p>例如，它还使用<a href="https://developers.google.com/protocol-buffers" target="_blank" rel="noopener noreferrer">协议缓冲区</a>来序列化和反序列化请求和响应数据，而不是JSON或XML。</p>
<p>协议缓冲区是Google的语言中立、平台中立、可扩展的机制，用于序列化结构化数据——想想XML，但是更小、更快、更简单。</p>
<p>您只需定义一次数据的结构化方式，然后就可以使用特殊生成的源代码轻松地在每种支持的语言中的各种数据流之间写入和读取结构化数据。</p>
<p>首先，您需要创建并定义protobuf文件，该文件将包含根据协议本身指定的接口定义语言编写的代码(稍后将详细介绍)。</p>
<p>有了手头的文件，您可以通过<code>protoc</code>编译器将其编译成所需的语言代码。</p>
<p>整个过程都是秘密进行的，所以不要担心，你不会看到太多的样板代码。最后，随着生成的代码，您可以进入服务器和客户端的实现。</p>
<p>我们将构建一个全功能的CRUD API应用程序，使用一个引导接口来管理内存中客户列表的操作(由服务器应用程序管理)，而不是想象。</p>
<p>这是我们的应用程序最终的样子:</p>
<figure id="attachment_16996" aria-describedby="caption-attachment-16996" class="wp-caption aligncenter"><img data-attachment-id="16996" data-permalink="https://blog.logrocket.com/creating-a-crud-api-with-node-express-and-grpc/logrocket-customers-list/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/04/Logrocket-customers-list.png" data-orig-size="730,309" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Logrocket-customers-list" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/04/Logrocket-customers-list-300x127.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/04/Logrocket-customers-list.png" decoding="async" class="wp-image-16996 size-full jetpack-lazy-image" src="../Images/23e3a4dab67e20ff38f3d4a9279cbcdc.png" alt="Logrocket customers list CRUD" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2020/04/Logrocket-customers-list.png 730w, https://blog.logrocket.com/wp-content/uploads/2020/04/Logrocket-customers-list-300x127.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2020/04/Logrocket-customers-list.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/04/Logrocket-customers-list.png"/><noscript><img data-lazy-fallback="1" data-attachment-id="16996" data-permalink="https://blog.logrocket.com/creating-a-crud-api-with-node-express-and-grpc/logrocket-customers-list/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/04/Logrocket-customers-list.png" data-orig-size="730,309" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Logrocket-customers-list" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/04/Logrocket-customers-list-300x127.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/04/Logrocket-customers-list.png" decoding="async" loading="lazy" class="wp-image-16996 size-full" src="../Images/23e3a4dab67e20ff38f3d4a9279cbcdc.png" alt="Logrocket customers list CRUD" srcset="https://blog.logrocket.com/wp-content/uploads/2020/04/Logrocket-customers-list.png 730w, https://blog.logrocket.com/wp-content/uploads/2020/04/Logrocket-customers-list-300x127.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/04/Logrocket-customers-list.png"/></noscript><figcaption id="caption-attachment-16996" class="wp-caption-text">Customer’s CRUD application</figcaption></figure>
<h2>设置</h2>
<p>本教程的要求非常简单:</p>
<ul>
<li>Node.js和npm(最新版本)</li>
<li>您选择的IDE</li>
</ul>
<p>为了简单起见，我们不打算使用任何类型的数据库——条目列表将保存在服务器应用程序的内存中。</p>
<p>这将非常接近地模拟数据库的使用，因为当服务器启动时数据就在那里，而客户机可以根据您的需要重启多次。你可以随意加入任何你想要的框架或特性。</p>
<p>接下来，在您选择的文件夹中，创建以下结构的文件夹和文件:</p>
<figure id="attachment_16997" aria-describedby="caption-attachment-16997" class="wp-caption aligncenter"><img data-attachment-id="16997" data-permalink="https://blog.logrocket.com/creating-a-crud-api-with-node-express-and-grpc/logrocket-client/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/04/LOGROCKET-CLIENT.png" data-orig-size="716,556" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="LOGROCKET-CLIENT" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/04/LOGROCKET-CLIENT-300x233.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/04/LOGROCKET-CLIENT.png" decoding="async" class="wp-image-16997 jetpack-lazy-image" src="../Images/fff6bdc07e1ab8e98f935ae1afdacc8a.png" alt="project structure" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2020/04/LOGROCKET-CLIENT.png 716w, https://blog.logrocket.com/wp-content/uploads/2020/04/LOGROCKET-CLIENT-300x233.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2020/04/LOGROCKET-CLIENT.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/04/LOGROCKET-CLIENT.png"/><noscript><img data-lazy-fallback="1" data-attachment-id="16997" data-permalink="https://blog.logrocket.com/creating-a-crud-api-with-node-express-and-grpc/logrocket-client/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/04/LOGROCKET-CLIENT.png" data-orig-size="716,556" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="LOGROCKET-CLIENT" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/04/LOGROCKET-CLIENT-300x233.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/04/LOGROCKET-CLIENT.png" decoding="async" loading="lazy" class="wp-image-16997" src="../Images/fff6bdc07e1ab8e98f935ae1afdacc8a.png" alt="project structure" srcset="https://blog.logrocket.com/wp-content/uploads/2020/04/LOGROCKET-CLIENT.png 716w, https://blog.logrocket.com/wp-content/uploads/2020/04/LOGROCKET-CLIENT-300x233.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/04/LOGROCKET-CLIENT.png"/></noscript><figcaption id="caption-attachment-16997" class="wp-caption-text">Project’s structure</figcaption></figure>
<p>您也可以选择分别创建客户端和服务器应用程序。</p>
<p>我们将它们放在一起以简化最终的结构。</p>
<p>现在，在命令行的根文件夹中运行以下命令:</p>
<pre>npm install --save grpc @grpc/proto-loader uuid express hbs body-parser</pre>
<p>前两次安装将处理gRPC服务器，并将我们的protobuf文件加载到客户机和服务器代码的实现中。<code>Uuid</code>将有助于为我们的客户创建随机散列id，但是您也可以使用数字来简化(例如，虽然这样您的代码将已经准备好切换到MongoDB)。</p>
<p>您可能想知道，如果我们在不同的协议下开发API，为什么我们在这里使用Express(用于HTTP处理)。</p>
<p><a href="https://expressjs.com/" target="_blank" rel="noopener noreferrer"> Express </a>将只服务于我们视图的路由系统。每个CRUD操作都需要到达客户机(顺便说一下，这是一个HTTP服务器)，客户机将通过gRPC与服务器应用程序进行通信。</p>
<p>虽然您可以从web页面调用gRPC方法，但我不推荐这样做，因为有很多缺点。</p>
<p>请记住，gRPC是为了加快后端的速度，比如从一个微服务到另一个微服务。为了服务于首页、移动应用或任何其他类型的图形用户界面，你必须调整你的架构。</p>
<p>最后，我们有用于页面模板化的<a href="https://handlebarsjs.com/" target="_blank" rel="noopener noreferrer">手柄</a>(我们不会在这里讨论它的细节，但是您可以使用EJS或任何其他用于节点应用程序的模板系统)，和<a href="https://www.npmjs.com/package/body-parser" target="_blank" rel="noopener noreferrer">主体解析器</a>，用于在处理程序之前在中间件中转换传入的请求主体，在<code>req.body</code>属性下可用。</p>
<p>当访问请求参数时，这将使我们的生活更容易。</p>
<p>您的最终<code>package.json</code>文件应该如下所示:</p>
<pre>{
  "name": "logrocket_customers_grpc",
  "version": "1.0.0",
  "description": "LogRocket CRUD with gRPC and Node",
  "main": "server.js",
  "scripts": {
    "start": "node server/server.js"
  },
  "author": "Diogo Souza",
  "license": "MIT",
  "dependencies": {
    "@grpc/proto-loader": "^0.5.3",
    "body-parser": "^1.18.3",
    "express": "^4.17.1",
    "grpc": "^1.24.2",
    "hbs": "^4.1.0",
    "uuid": "^7.0.2"
  }
}</pre>
<h2>服务器</h2>
<p>让我们来看看代码，从我们的protobuf文件开始，<code>customers.proto</code>:</p>
<pre>syntax = "proto3";

service CustomerService {
    rpc GetAll (Empty) returns (CustomerList) {}
    rpc Get (CustomerRequestId) returns (Customer) {}
    rpc Insert (Customer) returns (Customer) {}
    rpc Update (Customer) returns (Customer) {}
    rpc Remove (CustomerRequestId) returns (Empty) {}
}

message Empty {}

message Customer {
    string id = 1;
    string name = 2;
    int32 age = 3;
    string address = 4;
}

message CustomerList {
    repeated Customer customers = 1;
}

message CustomerRequestId {
    string id = 1;
}</pre>
<p>第一行说明了我们将使用的protobuf的版本——在本例中，是最新的版本。</p>
<p>内容的语法重组了很多JSON。服务是我们已经讨论过的接口契约。在这里，您将放置每个gRPC调用的方法名、参数和返回类型。</p>
<p>如果类型不是基本类型，则必须通过message关键字来声明。请参考<a href="https://developers.google.com/protocol-buffers/docs/proto3" target="_blank" rel="noopener noreferrer">文档</a>查看所有允许的类型。</p>
<p>消息的每个属性都必须接收一个数字值，该值表示该属性在堆栈中的顺序，从1开始。</p>
<p>最后，对于数组，需要在声明的属性前使用repeated关键字。</p>
<p>有了原型，让我们创建我们的<code>server.js</code>代码:</p>
<pre>const PROTO_PATH = "./customers.proto";

var grpc = require("grpc");
var protoLoader = require("@grpc/proto-loader");

var packageDefinition = protoLoader.loadSync(PROTO_PATH, {
    keepCase: true,
    longs: String,
    enums: String,
    arrays: true
});

var customersProto = grpc.loadPackageDefinition(packageDefinition);

const { v4: uuidv4 } = require("uuid");

const server = new grpc.Server();
const customers = [
    {
        id: "a68b823c-7ca6-44bc-b721-fb4d5312cafc",
        name: "John Bolton",
        age: 23,
        address: "Address 1"
    },
    {
        id: "34415c7c-f82d-4e44-88ca-ae2a1aaa92b7",
        name: "Mary Anne",
        age: 45,
        address: "Address 2"
    }
];

server.addService(customersProto.CustomerService.service, {
    getAll: (_, callback) =&gt; {
        callback(null, { customers });
    },

    get: (call, callback) =&gt; {
        let customer = customers.find(n =&gt; n.id == call.request.id);

        if (customer) {
            callback(null, customer);
        } else {
            callback({
                code: grpc.status.NOT_FOUND,
                details: "Not found"
            });
        }
    },

    insert: (call, callback) =&gt; {
        let customer = call.request;
        
        customer.id = uuidv4();
        customers.push(customer);
        callback(null, customer);
    },

    update: (call, callback) =&gt; {
        let existingCustomer = customers.find(n =&gt; n.id == call.request.id);

        if (existingCustomer) {
            existingCustomer.name = call.request.name;
            existingCustomer.age = call.request.age;
            existingCustomer.address = call.request.address;
            callback(null, existingCustomer);
        } else {
            callback({
                code: grpc.status.NOT_FOUND,
                details: "Not found"
            });
        }
    },

    remove: (call, callback) =&gt; {
        let existingCustomerIndex = customers.findIndex(
            n =&gt; n.id == call.request.id
        );

        if (existingCustomerIndex != -1) {
            customers.splice(existingCustomerIndex, 1);
            callback(null, {});
        } else {
            callback({
                code: grpc.status.NOT_FOUND,
                details: "Not found"
            });
        }
    }
});

server.bind("127.0.0.1:30043", grpc.ServerCredentials.createInsecure());
console.log("Server running at http://127.0.0.1:30043");
server.start();</pre>
<p>例如，因为它是一个服务器，所以它看起来很像一个Express代码的结构。你有一个IP和一个端口，然后你启动一些东西。</p>
<p>一些要点:</p>
<p>首先，将原型文件路径导入到一个常量中。</p>
<p>然后，<code>require</code><code>grpc</code>和<code>@grpc/proto-loader</code>都包了。他们会让奇迹发生。为了将proto转录成JavaScript对象，您需要首先设置它的包定义。<code>protoLoader</code>将通过接收原型文件所在的路径作为第一个参数，设置属性作为第二个参数来完成这项任务。</p>
<p>一旦有了包定义对象，就将它传递给<code>grpc</code>对象的<code>loadPackageDefinition</code>函数，该函数又将它返回给您。然后，您可以通过<code>Server()</code>功能创建服务器。</p>
<p><code>customers</code>数组是我们的内存数据库。</p>
<p>我们已经对两个客户进行了初始化，所以当应用程序启动时，你可以看到一些数据。在服务器上，我们需要告诉<code>server</code>对象它将处理哪些服务(在我们的例子中，是我们在proto文件中创建的<code>CustomerService</code>)。每个操作都必须将它们的名称分别与原型匹配。它们的代码很简单，非常直观，所以请继续查看它们。</p>
<p>最后，将服务器连接绑定到所需的IP和端口，并启动它。<code>bind()</code>函数接收身份验证对象作为第二个参数，但是为了简单起见，您可能会注意到，我们会不安全地使用它(不推荐用于生产)。</p>
<p>服务器搞定了。很简单，不是吗？现在，您可以通过发出以下命令来启动它:</p>
<pre>npm start</pre>
<p>然而，它不能被测试，因为你需要一个合适的客户机，它理解服务器所服务的protobuf契约。</p>
<h3>客户</h3>
<p>现在让我们构建我们的客户端应用程序，从<code>client.js</code>代码开始:</p>
<pre>const PROTO_PATH = "../customers.proto";

const grpc = require("grpc");
const protoLoader = require("@grpc/proto-loader");

var packageDefinition = protoLoader.loadSync(PROTO_PATH, {
    keepCase: true,
    longs: String,
    enums: String,
    arrays: true
});

const CustomerService = grpc.loadPackageDefinition(packageDefinition).CustomerService;
const client = new CustomerService(
    "localhost:30043",
    grpc.credentials.createInsecure()
);

module.exports = client;</pre>
<p>该文件将专门处理我们与gRPC服务器的通信。</p>
<p>注意，它的初始结构与服务器文件中的完全相同，因为相同的gRPC对象处理客户机和服务器实例。</p>
<p>这里唯一的区别是没有像<code>Client()</code>这样的方法。</p>
<p>我们所需要的就是加载包定义并创建一个新的服务——与我们在服务器中创建的服务相同——通过相同的IP和端口。如果设置了凭据，第二个参数也必须满足这些设置。</p>
<p>就是这样。</p>
<p>为了使用这个服务契约，我们需要首先实现我们的Express代码。因此，在<code>index.js</code>文件中，插入以下内容:</p>
<pre>const client = require("./client");

const path = require("path");
const express = require("express");
const bodyParser = require("body-parser");

const app = express();

app.set("views", path.join(__dirname, "views"));
app.set("view engine", "hbs");

app.use(bodyParser.json());
app.use(bodyParser.urlencoded({ extended: false }));

app.get("/", (req, res) =&gt; {
    client.getAll(null, (err, data) =&gt; {
        if (!err) {
            res.render("customers", {
                results: data.customers
            });
        }
    });
});

app.post("/save", (req, res) =&gt; {
    let newCustomer = {
        name: req.body.name,
        age: req.body.age,
        address: req.body.address
    };

    client.insert(newCustomer, (err, data) =&gt; {
        if (err) throw err;

        console.log("Customer created successfully", data);
        res.redirect("/");
    });
});

app.post("/update", (req, res) =&gt; {
    const updateCustomer = {
        id: req.body.id,
        name: req.body.name,
        age: req.body.age,
        address: req.body.address
    };

    client.update(updateCustomer, (err, data) =&gt; {
        if (err) throw err;

        console.log("Customer updated successfully", data);
        res.redirect("/");
    });
});

app.post("/remove", (req, res) =&gt; {
    client.remove({ id: req.body.customer_id }, (err, _) =&gt; {
        if (err) throw err;

        console.log("Customer removed successfully");
        res.redirect("/");
    });
});

const PORT = process.env.PORT || 3000;
app.listen(PORT, () =&gt; {
    console.log("Server running at port %d", PORT);
});</pre>
<p>在您导入了<code>requires</code>，从<code>express()</code>函数创建了<code>app</code>，并设置了每个CRUD HTTP函数之后，剩下的就是调用接口契约提供的每个动作。</p>
<p>还要注意，对于所有这些，我们都从请求<code>body</code>中恢复输入值(承蒙<code>body-parser</code>)。</p>
<p>不要忘记，每个<code>client</code>函数必须符合proto文件中定义的完全相同的名称。</p>
<p>最后但同样重要的是，这是<code>customers.hbs</code>文件的代码:</p>
<pre>&lt;html lang="en"&gt;

&lt;head&gt;
    &lt;meta charset="utf-8"&gt;
    &lt;title&gt;LogRocket CRUD with gRPC and Node&lt;/title&gt;
    &lt;link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css"
        integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"&gt;
    &lt;style&gt;
        .logrocket {
            background-color: #764abc;
            color: white;
        }
    &lt;/style&gt;
&lt;/head&gt;

&lt;body&gt;
    &lt;div class="container"&gt;
        &lt;div class="py-5 text-center"&gt;
            &lt;img class="d-block mx-auto mb-4"
                src="https://blog.logrocket.com/wp-content/uploads/2020/01/logrocket-blog-logo.png" alt="Logo"
                height="72"&gt;
            &lt;h2&gt;Customer's List&lt;/h2&gt;
            &lt;p class="lead"&gt;Example of CRUD made with Node.js, Express, Handlebars and gRPC&lt;/p&gt;
        &lt;/div&gt;

        &lt;table class="table" id="customers_table"&gt;
            &lt;thead&gt;
                &lt;tr&gt;
                    &lt;th&gt;Customer ID&lt;/th&gt;
                    &lt;th&gt;Customer Name&lt;/th&gt;
                    &lt;th&gt;Age&lt;/th&gt;
                    &lt;th&gt;Address&lt;/th&gt;
                    &lt;th&gt;Action&lt;/th&gt;
                &lt;/tr&gt;
            &lt;/thead&gt;
            &lt;tbody&gt;
                {{#each results}}
                &lt;tr&gt;
                    &lt;td&gt;{{ id }}&lt;/td&gt;
                    &lt;td&gt;{{ name }}&lt;/td&gt;
                    &lt;td&gt;{{ age }} years old&lt;/td&gt;
                    &lt;td&gt;{{ address }}&lt;/td&gt;
                    &lt;td&gt;
                        &lt;a href="javascript:void(0);" class="btn btn-sm edit logrocket" data-id="{{ id }}"
                            data-name="{{ name }}" data-age="{{ age }}" data-address="{{ address }}"&gt;Edit&lt;/a&gt;
                        &lt;a href="javascript:void(0);" class="btn btn-sm btn-danger remove" data-id="{{ id }}"&gt;Remove&lt;/a&gt;
                    &lt;/td&gt;
                &lt;/tr&gt;
                {{else}}
                &lt;tr&gt;
                    &lt;td colspan="5" class="text-center"&gt;No data to display.&lt;/td&gt;
                &lt;/tr&gt;
                {{/each}}
            &lt;/tbody&gt;
        &lt;/table&gt;
        &lt;button class="btn btn-success float-right" data-toggle="modal" data-target="#newCustomerModal"&gt;Add New&lt;/button&gt;
    &lt;/div&gt;

    &lt;!-- New Customer Modal --&gt;
    &lt;form action="/save" method="post"&gt;
        &lt;div class="modal fade" id="newCustomerModal" role="dialog"&gt;
            &lt;div class="modal-dialog" role="document"&gt;
                &lt;div class="modal-content"&gt;
                    &lt;div class="modal-header"&gt;
                        &lt;h4 class="modal-title"&gt;New Customer&lt;/h4&gt;
                        &lt;button type="button" class="close" data-dismiss="modal"&gt;
                            &lt;span&gt;&amp;times;&lt;/span&gt;
                        &lt;/button&gt;
                    &lt;/div&gt;
                    &lt;div class="modal-body"&gt;
                        &lt;div class="form-group"&gt;
                            &lt;input type="text" name="name" class="form-control" placeholder="Customer Name"
                                required="required"&gt;
                        &lt;/div&gt;

                        &lt;div class="form-group"&gt;
                            &lt;input type="number" name="age" class="form-control" placeholder="Age" required="required"&gt;
                        &lt;/div&gt;

                        &lt;div class="form-group"&gt;
                            &lt;input type="text" name="address" class="form-control" placeholder="Address"
                                required="required"&gt;
                        &lt;/div&gt;
                    &lt;/div&gt;
                    &lt;div class="modal-footer"&gt;
                        &lt;button type="button" class="btn btn-secondary" data-dismiss="modal"&gt;Close&lt;/button&gt;
                        &lt;button type="submit" class="btn logrocket"&gt;Create&lt;/button&gt;
                    &lt;/div&gt;
                &lt;/div&gt;
            &lt;/div&gt;
        &lt;/div&gt;
    &lt;/form&gt;

    &lt;!-- Edit Customer Modal --&gt;
    &lt;form action="/update" method="post"&gt;
        &lt;div class="modal fade" id="editCustomerModal" role="dialog"&gt;
            &lt;div class="modal-dialog" role="document"&gt;
                &lt;div class="modal-content"&gt;
                    &lt;div class="modal-header"&gt;
                        &lt;h4 class="modal-title"&gt;Edit Customer&lt;/h4&gt;
                        &lt;button type="button" class="close" data-dismiss="modal"&gt;
                            &lt;span&gt;&amp;times;&lt;/span&gt;
                        &lt;/button&gt;
                    &lt;/div&gt;
                    &lt;div class="modal-body"&gt;
                        &lt;div class="form-group"&gt;
                            &lt;input type="text" name="name" class="form-control name" placeholder="Customer Name"
                                required="required"&gt;
                        &lt;/div&gt;

                        &lt;div class="form-group"&gt;
                            &lt;input type="number" name="age" class="form-control age" placeholder="Age"
                                required="required"&gt;
                        &lt;/div&gt;

                        &lt;div class="form-group"&gt;
                            &lt;input type="text" name="address" class="form-control address" placeholder="Address"
                                required="required"&gt;
                        &lt;/div&gt;
                    &lt;/div&gt;
                    &lt;div class="modal-footer"&gt;
                        &lt;input type="hidden" name="id" class="customer_id"&gt;
                        &lt;button type="button" class="btn btn-secondary" data-dismiss="modal"&gt;Close&lt;/button&gt;
                        &lt;button type="submit" class="btn logrocket"&gt;Update&lt;/button&gt;
                    &lt;/div&gt;
                &lt;/div&gt;
            &lt;/div&gt;
        &lt;/div&gt;
    &lt;/form&gt;

    &lt;!-- Remove Customer Modal --&gt;
    &lt;form id="add-row-form" action="/remove" method="post"&gt;
        &lt;div class="modal fade" id="removeCustomerModal" role="dialog" aria-labelledby="myModalLabel"&gt;
            &lt;div class="modal-dialog"&gt;
                &lt;div class="modal-content"&gt;
                    &lt;div class="modal-header"&gt;
                        &lt;h4 class="modal-title"&gt;&lt;/h4&gt;Remove Customer&lt;/h4&gt;
                        &lt;button type="button" class="close" data-dismiss="modal"&gt;&lt;span&gt;&amp;times;&lt;/span&gt;&lt;/button&gt;
                    &lt;/div&gt;
                    &lt;div class="modal-body"&gt;
                        Are you sure?
                    &lt;/div&gt;
                    &lt;div class="modal-footer"&gt;
                        &lt;input type="hidden" name="customer_id" class="form-control customer_id_removal"
                            required="required"&gt;
                        &lt;button type="button" class="btn btn-default" data-dismiss="modal"&gt;Close&lt;/button&gt;
                        &lt;button type="submit" class="btn logrocket"&gt;Remove&lt;/button&gt;
                    &lt;/div&gt;
                &lt;/div&gt;
            &lt;/div&gt;
        &lt;/div&gt;
    &lt;/form&gt;

    &lt;script src="https://code.jquery.com/jquery-3.3.1.slim.min.js"
        integrity="sha384-q8i/X+965DzO0rT7abK41JStQIAqVgRVzpbzo5smXKp4YfRvH+8abtTE1Pi6jizo"
        crossorigin="anonymous"&gt;&lt;/script&gt;
    &lt;script src="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/js/bootstrap.min.js"
        integrity="sha384-JjSmVgyd0p3pXB1rRibZUAYoIIy6OrQ6VrjIEaFf/nJGzIxFDsf4x0xIM+B07jRM"
        crossorigin="anonymous"&gt;&lt;/script&gt;
    &lt;script&gt;
        $(document).ready(function () {
            $('#customers_table').on('click', '.edit', function () {
                $('#editCustomerModal').modal('show');

                $('.customer_id').val($(this).data('id'));
                $('.name').val($(this).data('name'));
                $('.age').val($(this).data('age'));
                $('.address').val($(this).data('address'));
            }).on('click', '.remove', function () {
                $('#removeCustomerModal').modal('show');

                $('.customer_id_removal').val($(this).data('id'));
            });
        });
    &lt;/script&gt;
&lt;/body&gt;

&lt;/html&gt;</pre>
<p>这有点冗长，尤其是因为我决定通过引导模式将整个CRUD UIs创建到同一个页面中，而不是重定向和设置许多不同的页面。</p>
<p>在页面的开头和结尾，我们分别找到了Bootstrap和jQuery的CSS和JS文件的导入。</p>
<p>主桌通过以下方式利用把手进行教学:</p>
<pre>{{#each results}}
…
{{else}}
…
{{/each}}</pre>
<p>这里的<code>else</code>有助于在列表中没有可用元素时配置文本。关于编辑和删除操作的链接，我们设置了HTML <code>data</code>属性来帮助打开模态。</p>
<p>每次我们打开edit a modal时，它的每个输入都必须用该行值的对应值填充。删除操作也是如此，尽管这里我们只需要id。</p>
<p>在第一个div的末尾，我们可以看到添加新客户的链接，这也触发了相应的模式。</p>
<p>就在下面，有三个情态动词。</p>
<p>它们彼此非常相似，因为它们只持有HTML结构。</p>
<p>逻辑实际上是放在HTML末尾的JavaScript部分。</p>
<p>这里，我们使用jQuery来打开模型本身，并简化将每个模型的输入值(通过<code>val</code>函数)更改为其对应的<code>data</code>属性值的工作。</p>
<p>我们完了。现在，您可以通过发出以下命令在另一个命令行窗口中启动客户端:</p>
<pre>node index</pre>
<p>然后，在服务器也启动的情况下，转到<a href="http://localhost:3000/" rel="nofollow"> http://localhost:3000/ </a>并进行测试。</p>
<h2>结论</h2>
<p>你可以在这里找到这个项目<a href="https://github.com/diogosouza/logrocket-node-grpc-crud/" target="_blank" rel="noopener noreferrer">的最终源代码。</a></p>
<p>现在，您可以将它部署到云或生产服务器上，或者在您自己的项目中从一个适度的POC开始，看看它与您的REST APIs相比有多快。</p>
<p>但是使用gRPC可以做更多的事情。您可以插入身份验证以使其更加安全、超时、双向流、健壮的错误处理机制、通道等等。</p>
<p>确保阅读<a href="https://grpc.io/docs/" target="_blank" rel="noopener noreferrer">文档</a>以检查其更多功能。</p><div class="code-block code-block-23">
<div class="blog-plug inline-plug node-plug"><h2>200只<img src="../Images/61167b9d027ca73ed5aaf59a9ec31267.png" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2019/10/green-check.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" class=" jetpack-lazy-image" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/10/green-check.png"/> <noscript> <img data-lazy-fallback="1" src="../Images/61167b9d027ca73ed5aaf59a9ec31267.png" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/10/green-check.png"/> </noscript>显示器出现故障，生产中网络请求缓慢</h2><p>部署基于节点的web应用程序或网站是容易的部分。确保您的节点实例继续为您的应用程序提供资源是事情变得更加困难的地方。如果您对确保对后端或第三方服务的请求成功感兴趣，</p><a href="https://lp.logrocket.com/blg/node-signup" target="_blank">try LogRocket</a><p>. </p><a class="signup" href="https://lp.logrocket.com/blg/node-signup" target="_blank" rel="noopener noreferrer"><img src="../Images/cae72fd2a54c5f02a6398c4867894844.png" alt="LogRocket Network Request Monitoring" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2019/12/network-request-filter-2-1.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" class=" jetpack-lazy-image" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/12/network-request-filter-2-1.png"/><noscript><img data-lazy-fallback="1" src="../Images/cae72fd2a54c5f02a6398c4867894844.png" alt="LogRocket Network Request Monitoring" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/12/network-request-filter-2-1.png"/></noscript></a><a href="https://lp.logrocket.com/blg/node-signup" target="_blank" rel="noopener noreferrer">https://logrocket.com/signup/</a><p>LogRocket 就像是网络和移动应用程序的DVR，记录下用户与你的应用程序交互时发生的一切。您可以汇总并报告有问题的网络请求，以快速了解根本原因，而不是猜测问题发生的原因。</p><p>LogRocket检测您的应用程序以记录基线性能计时，如页面加载时间、到达第一个字节的时间、慢速网络请求，还记录Redux、NgRx和Vuex操作/状态。</p><a class="signup" href="https://lp.logrocket.com/blg/node-signup" target="_blank" rel="noopener noreferrer">Start monitoring for free</a><p>. </p></div>
</div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
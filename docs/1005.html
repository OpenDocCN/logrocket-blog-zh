<html>
<head>
<title>Why you don't need to mix routing state with Redux - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>为什么不需要将路由状态与Redux - LogRocket Blog混合</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/why-you-dont-need-mix-routing-state-with-redux/#0001-01-01">https://blog.logrocket.com/why-you-dont-need-mix-routing-state-with-redux/#0001-01-01</a></blockquote><div><article class="article-post">
<p><em> <strong>编者的</strong> <strong>注</strong>:本帖于2021年12月7日更新，删除了对已弃用的react-router-redux包的引用，用官方的react-router-redux替换重新编写了教程，改进了对动态路由的描述，并更清楚地说明了何时应该考虑复杂性。</em></p>
<p>本文涵盖了不需要将路由状态与Redux混合的一些原因。</p>
<p>在我们开始解释不需要混合路由状态的原因之前，让我们先回顾一下将路由状态与Redux集成的可用方法，并理解它是如何工作的。</p>
<h2>React常用的路由状态库</h2>
<p>有不同的库和方法可以用来集成路由状态和Redux。最常用的有:</p>
<ul>
<li><a href="https://www.npmjs.com/package/connected-react-router"> connected-react-router </a>(以前被称为已弃用的<a href="https://www.npmjs.com/package/react-router-redux"> react-router-redux </a>):当你想要将你的路线历史与你的应用状态同步，并通过redux管理路线时，这个库是合适的。它提供了一些特性，如<code>push</code>、<code>replace</code>、<code>go</code>、<code>goBack</code>和<code>goForward</code>，以便在应用程序中方便地导航。<ul>
<li><a href="https://reactrouter.com/"> React-router-dom </a>:这是一个备受推崇的库，用于在React应用程序中实现导航和路由，它提供了<code>BrowserRouter</code>、<code>Link</code>、<code>Route</code>和<code>Switch</code>等特性，所有这些特性使得它的集成无缝<ul>
<li>Redux-first-router :另一个React库，它让你可以在浏览器历史记录和应用程序中用户的当前位置/URL中导航</li>
<li><a href="https://www.npmjs.com/package/redux-first-history"> Redux-first-history </a>:这个库的开发者的主要目标是让这个库的用户能够混合组件，这些组件通过它的<code>state.router.location</code>方法从任何其他库获得导航历史</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>如果您有兴趣探索其他集成了路由和Redux的库，您可以查看<a href="https://github.com/markerikson/redux-ecosystem-links/blob/master/routing.md">这个GitHub repo以获得更多见解</a>。</p>
<h2>【Redux路由是如何工作的？</h2>
<p>Redux是一个状态管理工具，它使应用程序内部和应用程序之间的数据或状态保持同步。它通过组件状态所在的单一位置来实现这一点。这个单一的位置被认为是商店。</p>
<p>可能会更改应用程序状态的操作将被分派到此存储区，并且状态将被更新。应用程序中订阅该状态的任何组件都将被通知该组件的新状态，并且该值将通过该组件呈现。</p>
<p id="gdcalert2"><img data-attachment-id="85438" data-permalink="https://blog.logrocket.com/why-you-dont-need-mix-routing-state-with-redux/react-redux-app-structure/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/07/react-redux-app-structure.png" data-orig-size="730,252" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="react-redux-app-structure" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/07/react-redux-app-structure-300x104.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/07/react-redux-app-structure.png" decoding="async" class="aligncenter size-full wp-image-85438 jetpack-lazy-image" src="../Images/593252c7a229e78e7a0a792abd5facdb.png" alt="The React-Redux app structure" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2020/07/react-redux-app-structure.png 730w, https://blog.logrocket.com/wp-content/uploads/2020/07/react-redux-app-structure-300x104.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2020/07/react-redux-app-structure.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/07/react-redux-app-structure.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="85438" data-permalink="https://blog.logrocket.com/why-you-dont-need-mix-routing-state-with-redux/react-redux-app-structure/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/07/react-redux-app-structure.png" data-orig-size="730,252" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="react-redux-app-structure" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/07/react-redux-app-structure-300x104.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/07/react-redux-app-structure.png" decoding="async" loading="lazy" class="aligncenter size-full wp-image-85438" src="../Images/593252c7a229e78e7a0a792abd5facdb.png" alt="The React-Redux app structure" srcset="https://blog.logrocket.com/wp-content/uploads/2020/07/react-redux-app-structure.png 730w, https://blog.logrocket.com/wp-content/uploads/2020/07/react-redux-app-structure-300x104.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/07/react-redux-app-structure.png"/></noscript>
<p>通常情况下，浏览器历史记录和Redux存储会不断相互通信以保持同步。每次用户在应用程序中导航时，浏览器历史和商店中的位置更改都会更新。</p>
<p>这似乎违背了Redux的“单一来源的真理”原则，但事实并非如此。只要您能够保证存储在浏览器历史和Redux存储中的路由数据是相同的，您就可以配置您的应用程序只从存储中获取数据，从而维护单一来源的事实原则。</p>
<h2>浏览您的应用程序</h2>
<p>用户可以通过两种方式在应用程序中导航:内部和外部。</p>
<h3>内部导航</h3>
<p>当用户单击应用程序中的链接时，就会出现这种类型的导航，例如导航栏上的<strong>联系人</strong>选项卡/按钮，或者将用户导向应用程序另一个页面的任何链接。</p>
<p>这通常由管理应用程序路由的库的<code>history</code>特性来处理。Redux中间件接收动作，并与Redux一起更新浏览器历史，Redux更新Redux状态。</p>
<p>之后，我们连接的路由监听状态的变化，并根据Redux状态确定页面如何呈现。</p>
<h3>外部导航</h3>
<p>一个很好的例子是从另一个网站访问一个网页，或者通过URL栏、外部链接，或者当您使用浏览器的导航按钮在页面之间来回导航时。简单来说，通过浏览器的导航栏访问网页被认为是外部导航。</p>
<p>当浏览器中的URL发生变化时，Redux存储中的监听器会观察到变化，并调度一个动作来更新状态和历史。</p>
<h2>实施冗余优先路由方法</h2>
<p>让我们探索一个冗余优先路由方法的简单例子。这将帮助您理解它在我们的应用程序中是如何实现的。</p>
<p>在您的终端中运行下面的代码行，创建一个React应用程序:</p>
<pre class="prettyprint">npx create-react-app redux-first-demo
</pre>
<p><code>cd</code>进入React app，安装<code>redux-first-router</code>库。</p>
<pre class="prettyprint">cd redux-first-demo

npm i redux-first-router
</pre>
<h3>配置<code>store.js</code>文件</h3>
<p>让我们从创建一个文件开始，我们在这个文件中配置保存应用程序状态的存储。创建一个名为<code>store.js</code>的文件，并添加以下代码片段:</p>
<pre class="prettyprint">import { applyMiddleware, combineReducers, compose, createStore } from 'redux'
import { connectRoutes } from 'redux-first-router'

import page from './pageReducer'

const routesMap = {
  HOME: '/',
  USER: '/user/:id'
}

export default function store(preloadedState) {
  const { reducer, middleware, enhancer } = connectRoutes(routesMap)

  const rootReducer = combineReducers({ page, location: reducer })
  const middlewares = applyMiddleware(middleware)
  const enhancers = compose(enhancer, middlewares)

  const store = createStore(rootReducer, preloadedState, enhancers)

  return { store }
}
</pre>
<p>在上面的<code>store.js</code>文件中，<code>connectRoutes</code>将路由器映射到我们想要渲染的组件。<code>routesMap</code>是一个对象，它包含路径和它们所呈现的各个组件的键。</p>
<p>然后，我们使用经过处理的<code>combineReducers</code>和<code>applyMiddleware</code>API的值，用<code>createStore</code> API初始化商店。</p>
<h3>用<code>pageReducer.js</code>更新状态</h3>
<p>reducer调度Redux操作来更新应用程序的状态。下面的代码是我们的应用程序的<code>reducer</code>函数的一个实现，它包含需要根据路线呈现的组件。</p>
<p>这里，我们检查传递给减速器的动作类型。例如，如果动作的类型是<code>HOME</code>，我们返回它的状态。</p><div class="code-block code-block-54">
<hr/>
<h3>更多来自LogRocket的精彩文章:</h3>

<hr/></div>
<pre class="prettyprint">import { NOT_FOUND } from 'redux-first-router'

const components = {
  HOME: 'Home',
  USER: 'User',
  [NOT_FOUND]: 'NotFound'
}

export default (state = 'HOME', action = {}) =&gt; {
  return components[action.type] || state
}
</pre>
<h3>渲染React组件</h3>
<p><code>components.js</code>文件包含了我们可以在React应用程序中渲染的组件。</p>
<pre class="prettyprint">import React from 'react'
import { connect } from 'react-redux'

const Home = () =&gt; &lt;h3&gt;Home&lt;/h3&gt;

const User = ({ userId }) =&gt; &lt;h3&gt;{`User ${userId}`}&lt;/h3&gt;
const mapStateToProps = ({ location }) =&gt; ({
  userId: location.payload.id
})
const ConnectedUser = connect(mapStateToProps)(User)

const NotFound = () =&gt; &lt;h3&gt;404&lt;/h3&gt;

export { Home, ConnectedUser as User, NotFound }
</pre>
<h3><code>App.js</code>帮助加载正确的页面</h3>
<p>最后，<code>App.js</code>文件是Redux的<code>page</code>参数的状态根据导航状态决定要加载的组件的地方。我们从<code>components.js</code>文件中导入所有组件，并在用户导航到相应的路线时呈现它们各自的内容。</p>
<pre class="prettyprint">import React from 'react'
import { connect } from 'react-redux'

// Contains 'Home', 'User' and 'NotFound'
import * as components from './components';

const App = ({ page }) =&gt; {
  const Component = components[page]
  return &lt;Component /&gt;
}

const mapStateToProps = ({ page }) =&gt; ({ page })

export default connect(mapStateToProps)(App)
</pre>
<h2><strong>为什么路由不需要Redux】</strong></h2>
<p>在某些情况下，将路由状态存储在Redux中可能是一个不错的选择，例如当您希望:</p>
<ul>
<li>访问路由状态的历史实例</li>
<li>防止组件充当路由状态和应用程序状态之间的中介</li>
<li>使用调度的操作在应用程序中导航</li>
<li>使用Redux devtools更改路线时利用行程调试</li>
<li>保持路由数据和存储数据同步</li>
</ul>
<p>然而，随之而来的问题也很多。</p>
<h3>复杂性</h3>
<p>在Redux中使用路由状态时，您将面临的一个主要问题是复杂性。</p>
<p>您无法预测它会有多复杂，并且您的完整应用程序状态将依赖于Redux。</p>
<p>对于我们中一些拥有大量代码的人来说，这种复杂性可能是一件好事。大型应用程序很可能会被分解成许多组件，从而使代码更具可读性——这是一个很好的优势，但是在调试和跟踪性能方面，您将有更多的工作要做。</p>
<p>您还必须在一个地方管理一切，随着应用程序开始增长，这可能很难扩展。在我看来，这是不必要的——这就像在一个地方管理所有组件的状态一样。想想当你的代码库增长时会有多难。</p>
<h3>多重“真相来源”</h3>
<p>Redux最突出的属性之一是它的单一真理来源原则。当您将路由与Redux集成在一起时，遵守这一原则可能会很麻烦，因为Redux存储不保存有关您的URL和导航历史的信息——这是由React路由器库和路由组件处理的。</p>
<p>由于URL的当前位置也决定了视图上呈现的数据，这意味着除了Redux存储之外，您还必须考虑路由组件提供的数据。</p>
<p>为了保持Redux Store作为获取准确数据的主要来源，您必须编写代码来跟踪Store和路由器之间的数据，并在用户与React应用程序交互时保持它们同步。</p>
<h3>冗长</h3>
<p>您可能需要处理的另一个问题是，您最终会得到大量用于解决简单问题的代码。您可能需要编写大量代码来导航到一个页面，而这是很容易避免的。</p>
<p>您必须管理仅用于路由的所有动作和归约器，以及用于更新路由的浏览器历史API的中间件。</p>
<h3>代码冗余</h3>
<p>如果您使用Redux进行路由，您可能最终会编写大量冗余代码，这是很容易避免的。例如，您可能需要编写许多动作和reducer函数来处理路由功能。</p>
<p>这可能给你一些权力来控制自己的路由器逻辑，但你可能不需要这种权力来处理应用程序的大部分需求。</p>
<p>因此，如果使用客户端路由，您可能最终会编写可以简化的代码。</p>
<h2>Redux路由的替代方案</h2>
<p>React生态系统中管理路由问题的一种流行方法是<a href="https://reacttraining.com/react-router/"> react-router </a>，在本文开始时对其进行了简要描述。它是一个客户端路由器，解决了我们在开发React应用程序时面临的大多数问题。</p>
<p>让我们看看React路由器库的一些优点。</p>
<h3>动态路线匹配</h3>
<p>使用React路由器，我们可以将动态路由与React组件相匹配。假设您有一个动态子域的应用程序需求:</p>
<pre class="prettyprint">logrocket.slack.com
</pre>
<p>这里，子域是动态变化的。我们可以使用React路由器轻松处理路由。我们还可以使用React Router基于子域执行一些操作，而无需使用Redux。</p>
<h3>浏览器历史功能</h3>
<p>在React Router中，浏览器历史特性(如在我们的应用程序路径上来回导航)是现成的。</p>
<h3>惰性装载</h3>
<p>React路由器支持延迟加载。这有助于您根据优先级分割代码包。您可以在顶部捆绑包中加载主要功能，在分割捆绑包中加载次要功能。</p>
<h2>最后的想法</h2>
<p>归根结底，最重要的是我们解决的问题。最重要的是，我们需要简单而有效地做到这一点，使用Redux-first路由方法会有一些好处。</p>
<p>但是我们可以使用本文中讨论的更简单的方法来解决同样的问题。有很多库可以帮助我们做到这一点，比如React Router。</p><div class="code-block code-block-17">
<div class="blog-plug inline-plug react-plug" vwo-el-id="26283398190">
<h2 vwo-el-id="41600691720"><a href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener"> LogRocket </a>:全面了解您的生产React应用</h2><p>调试React应用程序可能很困难，尤其是当用户遇到难以重现的问题时。如果您对监视和跟踪Redux状态、自动显示JavaScript错误以及跟踪缓慢的网络请求和组件加载时间感兴趣，</p><a href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" vwo-el-id="19356441070">try LogRocket</a><p>. </p><a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="19356441380">
<img class="first-react-image alignnone size-full wp-image-46 jetpack-lazy-image jetpack-lazy-image--handled" src="../Images/f300c244a1a1cf916df8b4cb02bec6c6.png" vwo-el-id="18272717540" data-lazy-loaded="1" data-original-src="https://files.readme.io/27c94e7-Image_2017-06-05_at_9.46.04_PM.png"/>
</a>
<a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="19356441690">
<img class="second-react-image alignnone size-full wp-image-46 jetpack-lazy-image jetpack-lazy-image--handled" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" vwo-el-id="30720362350" data-lazy-loaded="1" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/>
</a>
<p vwo-el-id="28675660440" class="">LogRocket 结合了会话回放、产品分析和错误跟踪，使软件团队能够创建理想的web和移动产品体验。这对你来说意味着什么？</p>
<p>LogRocket不是猜测错误发生的原因，也不是要求用户提供截图和日志转储，而是让您回放问题，就像它们发生在您自己的浏览器中一样，以快速了解哪里出错了。</p>
<p>不再有嘈杂的警报。智能错误跟踪允许您对问题进行分类，然后从中学习。获得有影响的用户问题的通知，而不是误报。警报越少，有用的信号越多。</p>
<p vwo-el-id="28675660750">LogRocket Redux中间件包为您的用户会话增加了一层额外的可见性。LogRocket记录Redux存储中的所有操作和状态。</p>
<p vwo-el-id="28675661060">现代化您调试React应用的方式— <a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="40093418840">开始免费监控</a>。</p>
</div></div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
<html>
<head>
<title>Getting started with radioactive state in React - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>React - LogRocket博客中的放射性状态入门</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/getting-started-with-radioactive-state-in-react/#0001-01-01">https://blog.logrocket.com/getting-started-with-radioactive-state-in-react/#0001-01-01</a></blockquote><div><article class="article-post">
<p>放射性状态是一种深度反应状态。当变异时(浅或深)，它会自动触发渲染更新。这消除了设置状态的需要、创建新状态的麻烦以及处理<a href="https://reactjs.org/docs/hooks-faq.html#why-am-i-seeing-stale-props-or-state-inside-my-function" target="_blank" rel="noopener noreferrer"> <code>stale state</code> </a>的尴尬。</p>
<p>用<code>useState</code>钩子管理复杂的状态是相当费力的。在React社区中，这被认为是一种反模式。</p>
<p>此外，在设置新状态后，<code>useState</code>挂钩不提供对<code>fresh state</code>的即时访问。因为状态只在渲染更新后更新，我们仍然需要处理<code>stale state</code>。</p>
<p>有了放射性状态，我们消除了这些挑战，提高了性能，并享受新的功能。</p>
<h2>入门指南</h2>
<p>要开始使用放射性状态，请通过运行以下命令安装软件包:</p>
<pre>npm i radioactive-state or yarn add radioactive-state</pre>
<p>这提供了<code>useRS</code>钩子，使我们能够在我们的组件中创建放射性状态。我们使用<code>useRS</code>钩子来初始化状态，钩子将一个对象作为它的参数。该对象的每个属性都指向一个不同的状态，并且可以在不设置状态的情况下进行变异:</p>
<pre>const state = useRS({ count: 0 }); // initializes the state</pre>
<p>为了改变这种状态，我们使用下面的语法:</p>
<pre>const increment = () =&gt; state.count++; // increases the count
const decrement = () =&gt; state.count--; // decreates the count</pre>
<h3>计数器组件</h3>
<pre>import "./styles.css";
import React from "react";
import useRS from "radioactive-state";
export default function App() {
  const state = useRS({ count: 0 });
  const increment = () =&gt; state.count++;
  const decrement = () =&gt; state.count--;
  return (
    &lt;div className="app container d-flex flex-column justify-content-center align-items-center"&gt;
      &lt;div className="mb-4"&gt;
        &lt;span className="count"&gt;{state.count}&lt;/span&gt;
      &lt;/div&gt;
      &lt;article className="d-flex"&gt;
        &lt;button className="mx-2 btn btn-success btn-sm" onClick={increment}&gt;
          increment count
        &lt;/button&gt;
        &lt;button className="mx-2 btn btn-danger btn-sm" onClick={decrement}&gt;
          increment count
        &lt;/button&gt;
      &lt;/article&gt;
    &lt;/div&gt;
  );
}</pre>
<p>上面是一个简单的计数器组件，当它们的按钮被点击时，它增加或减少count的值。你可以在这里玩代码<a href="https://codesandbox.io/s/peaceful-night-w6362?fontsize=14&amp;hidenavigation=1&amp;theme=dark" target="_blank" rel="noopener noreferrer">。</a></p>
<p>根据这一简洁的阐述，我们几乎没有触及放射性状态的表面。</p>
<h2>特征</h2>
<h3>永远新鲜的状态，不像<code>useState</code></h3>
<p>使用<code>useState</code>钩子管理状态时。我们的组件只在渲染更新后获得一个新的状态。这可能会导致一些难以调试的令人讨厌的错误。让我们看一些例子:</p>
<pre>import React, { useState } from "react";
import "./styles.css";
const App = () =&gt; {
  const [count, setCount] = useState(0);
  const increment = () =&gt; {
    console.log("before: ", count);
    setCount(count + 1);
    console.log("after: ", count);
  };
  return (
    &lt;div className="App"&gt;
      &lt;div className="app
           container
           d-flex
           flex-column
           justify-content-center
           align-items-center"
      &gt;
        &lt;div className="mb-5"&gt;
          &lt;span className="count"&gt;{count}&lt;/span&gt;
        &lt;/div&gt;
        &lt;article className="d-flex"&gt;
          &lt;button
            className="mx-2 p-3 btn btn-success btn-sm"
            onClick={increment}
          &gt;
            increment count
          &lt;/button&gt;
        &lt;/article&gt;
      &lt;/div&gt;
    &lt;/div&gt;
  );
};
export default App;</pre>
<p>上面是一个简单的组件，带有一个<code>count state</code>和一个增量函数，该函数调用底层的<code>useState</code> setter函数来更新<code>count state</code>。计数的当前值显示在UI中。</p>
<p>我们注意到，当我们增加计数时，它反映在<code>UI</code>上，但是记录到控制台的计数仍然是<code>0</code>。</p>
<p><img data-attachment-id="29245" data-permalink="https://blog.logrocket.com/getting-started-with-radioactive-state-in-react/incrementcounter/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/11/incrementcounter.png" data-orig-size="730,441" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="incrementcounter" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/11/incrementcounter-300x181.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/11/incrementcounter.png" decoding="async" class="aligncenter size-full wp-image-29245 jetpack-lazy-image" src="../Images/bace161b945c697c90caa6992c58caee.png" alt="increment counter in code sandbox" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2020/11/incrementcounter.png 730w, https://blog.logrocket.com/wp-content/uploads/2020/11/incrementcounter-300x181.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2020/11/incrementcounter.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/11/incrementcounter.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="29245" data-permalink="https://blog.logrocket.com/getting-started-with-radioactive-state-in-react/incrementcounter/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/11/incrementcounter.png" data-orig-size="730,441" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="incrementcounter" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/11/incrementcounter-300x181.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/11/incrementcounter.png" decoding="async" loading="lazy" class="aligncenter size-full wp-image-29245" src="../Images/bace161b945c697c90caa6992c58caee.png" alt="increment counter in code sandbox" srcset="https://blog.logrocket.com/wp-content/uploads/2020/11/incrementcounter.png 730w, https://blog.logrocket.com/wp-content/uploads/2020/11/incrementcounter-300x181.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/11/incrementcounter.png"/></noscript>
<p>记录到控制台的计数值总是比<code>UI</code>中的值小1。你可以在这里玩代码<a href="https://codesandbox.io/s/brave-visvesvaraya-ysmfv?fontsize=14&amp;hidenavigation=1&amp;theme=dark" target="_blank" rel="noopener noreferrer"/>。</p>
<p>有了<code>radioactive state</code>，我们就没有这个问题了:</p>
<pre>import "./styles.css";
import React from "react";
import useRS from "radioactive-state";
const App = () =&gt; {
  const state = useRS({ count: 0 });
  const increment = () =&gt; {
    console.log("before: ", state.count);
    state.count++;
    console.log("after: ", state.count);
  };
  return (
    &lt;div className="app
          container
          d-flex
          flex-column
          justify-content-center
          align-items-center"
    &gt;
      &lt;div className="mb-5"&gt;
        &lt;span className="count"&gt;{state.count}&lt;/span&gt;
      &lt;/div&gt;
      &lt;article className="d-flex"&gt;
        &lt;button className="mx-2 p-3 btn btn-success btn-sm" onClick={increment}&gt;
          increment count
        &lt;/button&gt;
      &lt;/article&gt;
    &lt;/div&gt;
  );
};
export default App;</pre>
<p>上面是同一个应用程序的实现，但是使用了<code>useRS</code>钩子。多亏了<code>radioactive state</code>，才没有出现这个问题。</p>
<p><img data-attachment-id="29248" data-permalink="https://blog.logrocket.com/getting-started-with-radioactive-state-in-react/beforeandafterincreementcounter/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/11/beforeandafterincreementcounter.png" data-orig-size="730,440" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="beforeandafterincreementcounter" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/11/beforeandafterincreementcounter-300x181.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/11/beforeandafterincreementcounter.png" decoding="async" class="aligncenter size-full wp-image-29248 jetpack-lazy-image" src="../Images/594072e273d073335469f1cb1e0365e3.png" alt="useRS increment counter " data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2020/11/beforeandafterincreementcounter.png 730w, https://blog.logrocket.com/wp-content/uploads/2020/11/beforeandafterincreementcounter-300x181.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2020/11/beforeandafterincreementcounter.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/11/beforeandafterincreementcounter.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="29248" data-permalink="https://blog.logrocket.com/getting-started-with-radioactive-state-in-react/beforeandafterincreementcounter/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/11/beforeandafterincreementcounter.png" data-orig-size="730,440" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="beforeandafterincreementcounter" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/11/beforeandafterincreementcounter-300x181.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/11/beforeandafterincreementcounter.png" decoding="async" loading="lazy" class="aligncenter size-full wp-image-29248" src="../Images/594072e273d073335469f1cb1e0365e3.png" alt="useRS increment counter " srcset="https://blog.logrocket.com/wp-content/uploads/2020/11/beforeandafterincreementcounter.png 730w, https://blog.logrocket.com/wp-content/uploads/2020/11/beforeandafterincreementcounter-300x181.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/11/beforeandafterincreementcounter.png"/></noscript>
<p>你可以在这里玩代码<a href="https://codesandbox.io/s/infallible-banzai-8t3d9?fontsize=14&amp;hidenavigation=1&amp;theme=dark" target="_blank" rel="noopener noreferrer"/>。在上图中，我们可以从控制台上看到，<code>count state</code>被递增前后的值分别是<code>0</code>和<code>1</code>。这是因为放射性状态的反应性。</p>
<h3>深度反应，在任何级别直接改变状态以更新组件</h3>
<p>这里我们将看看<code>radioactive state</code>如何解决React中的<code>stale state</code>问题:</p>
<pre>import "./styles.css";
import React, { useState } from "react";
export default function Example() {
  const [count, setCount] = useState(0);
  const lazyIncrement = () =&gt; {
    setTimeout(() =&gt; {
      setCount(count + 1);
    }, 3000);
  };
  return (
    &lt;div className="app
          container
          d-flex
          flex-column
          justify-content-center
          align-items-center"
    &gt;
      &lt;div className="mb-5"&gt;
        &lt;span className="count"&gt;{count}&lt;/span&gt;
      &lt;/div&gt;
      &lt;article className="d-flex flex-column"&gt;
        &lt;button
          className="mx-2 p-3 btn btn-success btn-sm"
          onClick={lazyIncrement}
        &gt;
          increment count
        &lt;/button&gt;
        &lt;small className="m-2"&gt;
          &lt;strong&gt;Increment the count a number of times!&lt;/strong&gt;
        &lt;/small&gt;
      &lt;/article&gt;
    &lt;/div&gt;
  );
}</pre>
<p>这里可以玩代码<a href="https://codesandbox.io/s/confident-poincare-pqw72?fontsize=14&amp;hidenavigation=1&amp;theme=dark" target="_blank" rel="noopener noreferrer">。上面是一个使用<code>useState</code>钩子管理<code>count state</code>的React组件。当点击<code>show count</code>按钮时，调用<code>lazyIncrement</code>函数更新状态。但是<code>useState</code>的setter函数(<code>setCount</code>)会因为<code>setTimeout</code>函数而在<code>3000 milliseconds</code>之后被调用。因此，状态仅在<code>3000 milliseconds</code>之后更新。</a></p>
<p>当我们点击按钮<code>n</code>次来增加状态时，我们看到状态只实现了一次。发生这种情况是因为<code>setCount</code>不断被旧状态调用。它只在组件重新呈现时获得一个新状态。</p>
<p>为了缓解这个问题，我们通常将一个更新函数传递给<code>useState</code> setter函数。这会将先前的状态(<code>prevState</code>)作为参数，并使用它来计算<code>nextState</code>的值。因此，上面的问题可以用下面的代码解决:</p>
<pre>setCount(prevCount =&gt; prevCount++)</pre>
<p>然而，当您想要基于新的状态值更新其他状态时，这就变得很尴尬了。</p>
<p>解决这个<code>stale state</code>问题的更干净的方法是使用<code>radioactive state</code>。因为它给了我们一个真正的反应状态，我们可以像这样重新实现我们的组件:</p>
<pre>import "./styles.css";
import React from "react";
import useRS from "radioactive-state";
export default function Example() {
  const count = useRS({ value: 0 });
  const lazyIncrement = () =&gt; {
    setTimeout(() =&gt; {
      count.value++;
    }, 3000);
  };
  return (
    &lt;div className="app
          container
          d-flex
          flex-column
          justify-content-center
          align-items-center"
    &gt;
      &lt;div className="mb-5"&gt;
        &lt;span className="count"&gt;{count.value}&lt;/span&gt;
      &lt;/div&gt;
      &lt;article className="d-flex flex-column"&gt;
        &lt;button
          className="mx-2 p-3 btn btn-success btn-sm"
          onClick={lazyIncrement}
        &gt;
          increment count
        &lt;/button&gt;
        &lt;small className="m-2"&gt;
          &lt;strong&gt;Increment the count a number of times!&lt;/strong&gt;
        &lt;/small&gt;
      &lt;/article&gt;
    &lt;/div&gt;
  );
}</pre>
<p>因为我们现在有一个真正的反应新鲜状态，它能够计算新状态的正确值。即使状态在<code>3000 milliseconds</code>之后被更新。你可以在这里玩代码<a href="https://codesandbox.io/s/hopeful-poitras-i8p9j?fontsize=14&amp;hidenavigation=1&amp;theme=dark" target="_blank" rel="noopener noreferrer"/>。</p>
<h3>输入的反应式绑定</h3>
<p>React很棒，但是说到表单处理，许多开发人员更喜欢使用第三方库。反应形式通常是由<a href="https://reactjs.org/docs/forms.html" target="_blank" rel="noopener noreferrer">个受控组件</a>组成的。处理这些涉及许多重复和烦人的事情，比如记录值和错误。</p>
<p>我们可以像这样创建一个受控组件:</p>
<pre>const [email, setEmail] = useState("");
  return (
    &lt;div className="App"&gt;
      &lt;form&gt;
        &lt;label&gt;Email:&lt;/label&gt;
        &lt;input
          value={email}
          placeholder="Enter Email"
          onChange={(e) =&gt; setEmail(e.target.value)}
          type="text"
        /&gt;
      &lt;/form&gt;
    &lt;/div&gt;</pre>
<p>注意，我们必须使用<code>e.target.value</code>来跟踪值。如果我们使用复选框，这将是<code>e.target.checked</code>。如果我们的表单有不同的输入，比如复选框、范围、单选按钮等等，那就更难了。</p>
<p>放射性状态提供了一个绑定API，将输入的值绑定到状态中的一个键。此功能使用es6扩展运算符，如下所示:</p>
<pre>&lt;input {...state.$key}  /&gt;</pre>
<p>我们简单地给键加上前缀<code>$</code>并如上所示访问它。</p>
<p>绑定API通过使用每个状态的初始值作为属性状态来确定输入的类型。因此<code>state.$key</code>将返回以下内容:</p>
<ul>
<li>一个包含<code>value</code>和<code>onChange</code>的对象，如果初始值是一个类型，那么它就是一个<code>string</code>或<code>number</code></li>
</ul>
<p>如果初始值类型是<code>number</code>，<code>onChange</code>函数会将<code>e.target.value</code>从<code>string</code>转换为<code>number</code>，然后保存在key中</p>
<ul>
<li>包含<code>checked</code>和<code>onChange</code>道具的对象。如果初始值类型为<code>boolean</code>，<code>state.$key</code>，则在<code>onChange</code>函数中内部使用<code>e.target.checked</code></li>
</ul>
<p>实现如下所示:</p>
<pre>const state = useRS({
  name: "iPhone 8",
  desc: "The mobile phone",
  promoPrice: 500,
  price: 1000,
  sold: true,
  color: "red"
});
const { $promoPrice, $price, $name, $sold, $color } = state;</pre>
<p>绑定的用法如下:</p>
<pre>&lt;input className="form-control" {...$name} type="text" /&gt;</pre>
<p>我已经使用这些绑定构建了一个具有反应状态的产品过滤器组件。这里可以玩代码<a href="https://codesandbox.io/s/sparkling-rgb-66tw9?fontsize=14&amp;hidenavigation=1&amp;theme=dark" target="_blank" rel="noopener noreferrer">。</a></p>
<h3>没有额外的重新渲染–自动变异批处理</h3>
<p>这里需要注意的是，当使用<code>reactive state</code>时，我们必须将一个对象传递给钩子。</p>
<h4>正确的</h4>
<pre>const state = useRS({count: 0})</pre>
<h4>错误的</h4>
<pre>const state = useRS(0)</pre>
<p>另外，考虑下面的函数:</p>
<pre>const customFunc = () =&gt; {
  state.name = "Lawrence";
  state.teams.frontend.react.push(["Lawrence", "Dave"]);
  state.commits++;
  state.teams.splice(10, 1);
  state.tasks = state.tasks.filter(x =&gt; x.completed);
};</pre>
<p>当调用上面的函数时，问题出现了，它是否会触发多个渲染更新。但它不会。这是因为在<code>reactive state</code>中，突变被分批成单个突变。因此，无论状态变化多少次，它都只会在rerender上触发。</p>
<p>你可以在这里获得更多关于这个<a href="https://github.com/MananTank/radioactive-state#-no-extra-re-renders-mutations-are-batched" target="_blank" rel="noopener noreferrer">的细节。</a></p>
<h3>反应道具</h3>
<p>这大概是<code>radioactive state</code>最有趣的特点。React具有单向数据流。这意味着它的数据向下流动，从父组件到子组件。这些数据(<code>props</code>)通常是不可变的，改变它们对父组件没有影响。</p>
<p>父组件可以将其状态作为道具传递给子组件，如下所示:</p>
<pre>export default function App() {
  const [bulbSwitch, setBulbSwitch] = useState(false);

  return (
    &lt;div className="App"&gt;
      &lt;Bulb bulbSwitch={bulbSwitch} /&gt;
    &lt;/div&gt;
  );
}</pre>
<p>改变子组件中的<code>bulbSwitch</code>状态不会触发父组件中的渲染更新。</p>
<p>然而，<code>reactive state</code>世事无常。使用时，子组件可以通过改变状态来触发父组件中的重新呈现器。这是一个非常强大的功能，它还消除了记忆该组件的需要。点击了解更多信息。</p>
<h3>放射性状态正在飞速发展</h3>
<p>当然，如果不谈论使用<code>reactive state</code>的性能含义，我们的论述是不完整的。<br/>嗯，<code>reactive state</code>就是快。非常快。比<code>useState</code>钩子快25%,这是一个相当复杂的应用程序。随着状态变得越来越复杂，它的表现持续优于<code>useState</code>钩子。</p>
<blockquote><p>这个数字是从平均100次性能测试中得出的，其中呈现了200个对象的数组，并且一个接一个地进行了各种操作，如添加、删除、重新排序和突变</p></blockquote>
<p>当我们使用<code>useState</code>钩子时，每当我们想要更新状态时，就会创建一个新的状态。并且用这个新状态调用<code>setter function</code>来更新状态。<code>Radioactive state</code>并不是每次更新一个状态就创建一个新的状态。这是它胜过<code>useState</code>的一个主要原因。</p><div class="code-block code-block-54">
<hr/>
<h3>更多来自LogRocket的精彩文章:</h3>

<hr/></div>
<p>同样，放射性状态通过使用<code>JavaScript proxy</code>递归代理状态来创建深度反应状态。点击了解更多信息。</p>
<h2>要避免的突变陷阱</h2>
<p>虽然<code>radioactive state</code>很神奇，但是在使用它的时候还是有一些陷阱需要避免。在这一节中，我们将考虑避免这些问题的模式。</p>
<h3>处理昂贵的初始状态</h3>
<p>如果初始状态是从一个昂贵的或长时间运行的计算中获得的，那么初始化状态将是低效的，如下所示:</p>
<pre>const state = useRS({
  x: getData(); // if getData is an expensive operation.
})</pre>
<p>每当组件呈现时，上面的模式都会触发<code>getData</code>函数。这不是我们想要的。这是一种反模式。正确的方法如下所示:</p>
<pre>const state = useRS({
  x: getData;
})</pre>
<p>现在只需要调用一次<code>getData</code>函数来初始化状态，因此效率更高。</p>
<h3>突变标志</h3>
<p>考虑下面的代码:</p>
<pre>const state = useRS({
  users: []
})

useEffect( () =&gt; {
  // do something ...
}, [state.users])


const addUser = (user) =&gt; state.users.push(user)</pre>
<p>上面是一个小的人为的例子来说明这个问题。当调用<code>addUser</code>函数时，一个新用户被添加到状态中的<code>users array</code>。</p>
<p>然而，<code>useEffect</code>挂钩不会运行。请注意，调用<code>addUser</code>函数会改变用户状态。</p>
<p>这是因为当我们变异一个引用类型数据(比如一个数组或者一个对象)时，在状态中，它的引用保持不变。注意，这个引用类型date作为依赖项传递给了<code>useEffect</code>钩子。因为它没有改变(即使我们调用了<code>addUser</code>),<code>useEffect</code>钩子没有运行。</p>
<p>这无疑是一个怪异的bug。为了解决这个问题，我们将<code>state.users.$</code>作为依赖项传递给<code>useEffect</code>,而不是<code>state.users</code>,如下所示:</p>
<pre>const state = useRS( { users: [] })

useEffect( () =&gt; {
  // do something.
}, [state.users.$])</pre>
<p>点击了解更多关于此<a href="https://github.com/MananTank/radioactive-state#-mutation-flag" target="_blank" rel="noopener noreferrer">的信息。</a></p>
<h2>最后的想法</h2>
<p>给React世界带来了革命性的创新。它速度极快、反应灵敏且高效。它提供了更清晰的模式来避免React状态管理中的常见缺陷。随着国家变得越来越复杂，它会越来越亮。在这篇文章之后，我相信你应该可以毫无困难地使用<code>reactive state</code>,但是请记住这些“陷阱”。</p><div class="code-block code-block-17">
<div class="blog-plug inline-plug react-plug" vwo-el-id="26283398190">
<h2 vwo-el-id="41600691720">使用LogRocket消除传统反应错误报告的噪音</h2>
<a href="https://lp.logrocket.com/blg/react-signup-issue-free" target="_blank" vwo-el-id="19356441070">LogRocket
</a><p>是一款React analytics解决方案，可保护您免受数百个误报错误警报的影响，只针对少数真正重要的项目。LogRocket告诉您React应用程序中实际影响用户的最具影响力的bug和UX问题。</p><a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="19356441380">
<img class="first-react-image alignnone size-full wp-image-46 jetpack-lazy-image jetpack-lazy-image--handled" src="../Images/f300c244a1a1cf916df8b4cb02bec6c6.png" vwo-el-id="18272717540" data-lazy-loaded="1" data-original-src="https://files.readme.io/27c94e7-Image_2017-06-05_at_9.46.04_PM.png"/>
</a>
<a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="19356441690">
<img class="second-react-image alignnone size-full wp-image-46 jetpack-lazy-image jetpack-lazy-image--handled" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" vwo-el-id="30720362350" data-lazy-loaded="1" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/>
</a>
<a href="https://lp.logrocket.com/blg/react-signup-issue-free" target="_blank" rel="noopener noreferrer" vwo-el-id="35866400580">LogRocket
</a><p>自动聚合客户端错误、反应错误边界、还原状态、缓慢的组件加载时间、JS异常、前端性能指标和用户交互。然后，LogRocket使用机器学习来通知您影响大多数用户的最具影响力的问题，并提供您修复它所需的上下文。</p><p vwo-el-id="28675661060">关注重要的React bug—<a class="signup" href="https://lp.logrocket.com/blg/react-signup-issue-free" target="_blank" rel="noopener noreferrer" vwo-el-id="40093418840">今天就试试LogRocket】。</a></p>
</div></div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
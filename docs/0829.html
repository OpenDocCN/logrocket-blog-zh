<html>
<head>
<title>New features in Vue 3 and how to use them - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>Vue 3中的新特性以及如何使用它们</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/new-features-in-vue-3-and-how-to-use-them/#0001-01-01">https://blog.logrocket.com/new-features-in-vue-3-and-how-to-use-them/#0001-01-01</a></blockquote><div><article class="article-post">
<p>Vue 3尚未正式发布，但Vue团队已经发布了Alpha版本，供美国开发者使用Vue 3将附带的一些功能。</p>
<p>在写这篇文章的时候，我们有(Alpha-10)版本可以进行实验。</p>
<p>虽然这还没有准备好用于生产，但提前了解新功能总是好的，这样当稳定版本发布时，我们可以直接开始使用它或将现有的Vue 2应用程序迁移到版本3.0以使用最新的功能。</p>
<h2>设置</h2>
<p>我们将使用基于WebPack的设置。</p>
<p>为此，请克隆此存储库:</p>
<pre>git clone https://github.com/vuejs/vue-next-webpack-preview.git vue-next
cd vue-next</pre>
<p>现在安装软件包:</p>
<pre>npm install</pre>
<p>就是这样。我们现在有一个工作Vue 3项目设置。</p>
<p>要启动应用程序，只需运行以下命令:</p>
<pre>npm run dev</pre>
<p>在您的浏览器中打开<code>localhost:8080</code>，您可以看到一个简单的计数器应用程序。</p>
<p>打开<code>package.json</code>文件，这里可以看到Vue版本。写这篇文章的时候，版本是<code>3.0.0-alpha.8</code>。</p>
<p>打开<code>App.vue</code>，你会看到<code>setup()</code>方法，即这里已经使用的组合API。我们可能会从Vue的官方插件<code>eslint-plugin-vue</code>中看到一些lint错误，因为linters还没有更新以理解新语法。</p>
<p>在我们开始编码之前，让我们回顾一下Vue 3中的新特性。</p>
<h2>Vue 3中的新功能</h2>
<p>Vue 3速度更快，文件更小，并配备了更好的TypeScript支持。我们可以在本文中讨论并学习实现的一些新特性包括:</p>
<ul>
<li>组合API(现在是内置的)</li>
<li>多个根元素(模板语法)</li>
<li>焦虑</li>
<li>多个虚拟模型</li>
<li>更好的反应性</li>
<li>门户网站</li>
</ul>
<h3>组合API</h3>
<p>Composition API是几个月前作为插件发布的，所以没有什么新的东西，但在Vue 3中，我们不必再像插件一样安装它了。现在，它内置在软件包中，无需任何额外设置即可开箱使用。</p>
<p>使用组合API有两个主要优点:</p>
<ul>
<li>更好的组织</li>
<li>共享/重用代码</li>
</ul>
<p>Vue 3仍然支持Options API，所以如果你认为你不需要composition API，你可以一直使用Vue 2中使用的传统方法。</p>
<p>如果您不熟悉Composition API，下面是我们如何使用它来实现一个组件:</p>
<pre>&lt;template&gt;
  &lt;div class="counter"&gt;
    &lt;p&gt;count: {{ count }}&lt;/p&gt;
    &lt;p&gt;NewVal (count + 2): {{ countDouble }}&lt;/p&gt;
    &lt;button @click="inc"&gt;Increment&lt;/button&gt;
    &lt;button @click="dec"&gt;Decrement&lt;/button&gt;
    &lt;p&gt; Message: {{ msg }} &lt;/p&gt;
    &lt;button @click="changeMessage()"&gt;Change Message&lt;/button&gt;
  &lt;/div&gt;
&lt;/template&gt;
&lt;script&gt;
import { ref, computed, watch } from 'vue'
export default {
  setup() {
/* ---------------------------------------------------- */
    let count = ref(0)
    const countDouble = computed(() =&gt; count.value * 2)
    watch(count, newVal =&gt; {
      console.log('count changed', newVal)
    })
    const inc = () =&gt; {
      count.value += 1
    }
    const dec = () =&gt; {
      if (count.value !== 0) {
        count.value -= 1
      }
    }
/* ---------------------------------------------------- */
    let msg= ref('some text')
    watch(msg, newVal =&gt; {
      console.log('msg changed', newVal)
    })
    const changeMessage = () =&gt; {
      msg.value = "new Message"
    }
/* ---------------------------------------------------- */
    return {
      count,
      inc,
      dec,
      countDouble,
      msg,
      changeMessage
    }
  }
}
&lt;/script&gt;</pre>
<p>下面是Options API中的等效代码:</p>
<pre>&lt;template&gt;
  &lt;div class="counter"&gt;
    &lt;p&gt;count: {{ count }}&lt;/p&gt;
    &lt;p&gt;NewVal (count + 2): {{ countDouble }}&lt;/p&gt;
    &lt;button @click="inc"&gt;Increment&lt;/button&gt;
    &lt;button @click="dec"&gt;Decrement&lt;/button&gt;
    &lt;p&gt; Message: {{ msg }} &lt;/p&gt;
    &lt;button @click="changeMessage()"&gt;Change Message&lt;/button&gt;
  &lt;/div&gt;
&lt;/template&gt;
&lt;script&gt;
export default {
  data() {
    return {
      count: 0,
      msg: 'some message'
    }
  },
  computed: {
    countDouble() {
      return this.count*2
    }
  },
  watch: {
    count(newVal) {
      console.log('count changed', newVal)
    },
    msg(newVal) {
      console.log('msg changed', newVal)
    }
  },
  methods: {
     inc() {
      this.count += 1
    },
    dec() {
      if (this.count !== 0) {
        this.count -= 1
      }
    },
    changeMessage() {
      msg = "new Message"
    }
  }
 
}
&lt;/script&gt;</pre>
<p>我们可以看到，通过将特定特性的代码(状态、方法、计算属性、观察器等)放在一起，使用Composition API允许我们更好地组织，这在Options API中是不可能的。</p>
<p>在上面的例子中，<code>counter</code>的代码和改变一个<code>message</code>的代码在组合API中是明确分开的。</p>
<p>随着组件规模的增长，组织代码成为一个重要的因素。任何新开发人员都可以轻松理解代码，而无需花费太多时间分析所有代码行。</p>
<p>以前，我们可以使用Mixins来共享代码。然而，很难跟踪不同组件中的状态和方法，如果我们不小心，Mixins有可能覆盖我们组件中现有的状态或方法。</p>
<p>使用组合API使得代码共享更加容易。我们可以提取出特定特性的代码，并在多个地方使用它，如下所示:</p>
<pre>//message.js
import { ref, watch } from 'vue'
export function message() {
  let msg = ref(123)
  watch(msg, newVal =&gt; {
    console.log('msg changed', newVal)
  })
  const changeMessage = () =&gt; {
    msg.value = 'new Message'
  }
  return { msg, changeMessage }
}</pre>
<p>在我们的组件中使用共享代码</p>
<pre>&lt;template&gt;
  &lt;div class="counter"&gt;
    &lt;p&gt;count: {{ count }}&lt;/p&gt;
    &lt;p&gt;NewVal (count + 2): {{ countDouble }}&lt;/p&gt;
    &lt;button @click="inc"&gt;Increment&lt;/button&gt;
    &lt;button @click="dec"&gt;Decrement&lt;/button&gt;
    &lt;p&gt;Message: {{ msg }}&lt;/p&gt;
    &lt;button @click="changeMessage()"&gt;change message&lt;/button&gt;
  &lt;/div&gt;
&lt;/template&gt;
&lt;script&gt;
import { ref, computed, watch } from 'vue'
import { message } from './common/message'
export default {
  setup() {
    let count = ref(0)
    const countDouble = computed(() =&gt; count.value * 2)
    watch(count, newVal =&gt; {
      console.log('count changed', newVal)
    })
    const inc = () =&gt; {
      count.value += 1
    }
    const dec = () =&gt; {
      if (count.value !== 0) {
        count.value -= 1
      }
    }
    let { msg, changeMessage } = message()
    return {
      count,
      msg,
      changeMessage,
      inc,
      dec,
      countDouble
    }
  }
}
&lt;/script&gt;</pre>
<p>更多细节请参考官方组合API <a href="https://vue-composition-api-rfc.netlify.com/" target="_blank" rel="noopener noreferrer">指南</a>。</p>
<h3>多个根元素(模板语法)</h3>
<p>在Vue 2中，模板标签只能接受一个根元素。即使我们只有两个<code>&lt;p&gt;</code>标签，我们也必须将它们包含在一个<code>&lt;div&gt;</code>标签中才能让它工作。因此，我们必须在父组件中也更改CSS代码，以便它看起来像预期的那样。</p>
<p>在Vue 3中，这个限制被取消了。不再需要根元素了。</p><div class="code-block code-block-54">
<hr/>
<h3>更多来自LogRocket的精彩文章:</h3>

<hr/></div>
<p>我们可以在<code>&lt;template&gt;&lt;/template&gt;</code>部分直接使用任意数量的标签:</p>
<pre>&lt;template&gt;
  &lt;p&gt; Count: {{ count }} &lt;/p&gt;
  &lt;button @click="increment"&gt; Increment &lt;/button&gt;
  &lt;button @click="decrement"&gt; Decrement&lt;/button&gt;
&lt;/template&gt;</pre>
<p>Vue 2中的等效代码:</p>
<pre>&lt;template&gt;
  &lt;div class="counter"&gt;
    &lt;p&gt; Count: {{ count }} &lt;/p&gt;
    &lt;button @click="increment"&gt; Increment &lt;/button&gt;
    &lt;button @click="decrement"&gt; Decrement&lt;/button&gt;
  &lt;/div&gt;
&lt;/template&gt;</pre>
<h3>焦虑</h3>
<p>悬念是一个新特性，它在主组件获取数据之前呈现一个默认/后备组件。</p>
<p>有时我们使用异步操作从服务器获取数据。不是用<code>v-if</code>处理模板，然后在我们返回数据时将它设置回来，而是悬念为我们做了这件事。</p>
<p>暂记可用于模板的两个部分或整个模板:</p>
<pre>&lt;template&gt;
  &lt;Suspense&gt;
    &lt;template #default&gt;
      &lt;div v-for="item in articleList" :key="item.id"&gt;
        &lt;article&gt;
          &lt;h2&gt;{{ item.title }}&lt;/h2&gt;
          &lt;p&gt;{{ item.body }}&lt;/p&gt;
        &lt;/article&gt;
      &lt;/div&gt;
    &lt;/template&gt;
    &lt;template #fallback&gt;
      Articles loading...
    &lt;/template&gt;
  &lt;/Suspense&gt;
&lt;/template&gt;
&lt;script&gt;
import axios from 'axios'
export default {
  async setup() {
    let articleList = await axios
      .get('https://jsonplaceholder.typicode.com/posts')
      .then(response =&gt; {
        console.log(response)
        return response.data
      })
    return {
      articleList
    }
  }
}
&lt;/script&gt;</pre>
<h3>多个虚拟模型</h3>
<p>我们都知道v-model是用于双向绑定的。我们通常在表单元素中使用它。有时，我们甚至用它来定制组件。</p>
<p>Vue-2只允许在一个组件上使用一个v-model。在Vue-3中，我们可以将任意数量的v模型绑定到我们的定制组件:</p>
<pre>&lt;template&gt;
      &lt;survey-form v-model:name="name" v-model:age="age"&gt; &lt;/survey-form&gt;
    &lt;/template&gt;



    //SurveyForm.vue
    &lt;template&gt;
      &lt;div&gt;
        &lt;label&gt;Name: &lt;/label&gt;
        &lt;input :value="name" @input="updateName($event.target.value)" /&gt;
        &lt;label&gt;Age: &lt;/label&gt;
        &lt;input :value="age" @input="updateAge($event.target.value)" /&gt;
      &lt;/div&gt;
    &lt;/template&gt;
    &lt;script&gt;
    export default {
      props: {
        name: String,
        age: Number
      },
      setup(props, { emit }) {
        const updateName = value =&gt; {
          emit('update:name', value)
        }
        const updateAge = value =&gt; {
          emit('update:age', +value)
        }
        return { updateName, updateAge }
      }
    }
    &lt;/script&gt;</pre>
<h3>更好的反应性</h3>
<p>Vue 2已经有了很好的反应性，你可能没有遇到过任何反应性缺乏的情况。然而，Vue 2也有一些不足之处。</p>
<p>让我们重温Vue 2，看看这些限制是什么。</p>
<p>为了演示反应性，我们将使用观察器来监听其中一个状态变量，然后修改它以查看<code>watchers</code>是否被触发:</p>
<pre>&lt;template&gt;
  &lt;div class="hello" @click="test"&gt;test {{list }} {{ myObj }}&lt;/div&gt;
&lt;/template&gt;
&lt;script&gt;
export default {
  name: "HelloWorld",
  data() {
    return {
      list: [1, 2],
      myObj: { name: "Preetish" }
    };
  },
  watch: {
    list: {
      handler: () =&gt; {
        console.log("watcher triggered");
      },
      deep: true
    }
  },
  methods: {
    test() {
      this.list[2] = 4;
      this.myObj.last = "HS";
      delete this.myObj.name;
    }
  }
};
&lt;/script&gt;</pre>
<p>在Vue-2中，上述三种修改(例如基于索引向数组添加新项、向对象添加新项或从对象中删除项)都不是反应性的。因此<code>watchers</code>不会被触发，否则DOM会被更新。我们不得不使用<code>vue.set()</code>或<code>vue.delete()</code>方法。</p>
<p>在Vue-3中，这些功能直接工作，无需任何辅助功能:</p>
<pre>export default {
  setup() {
    let list = ref([1, 2])
    let a = ref(0)
    let myObj = ref({ name: 'Preetish' })
    function myFun() {
      list.value[3] = 3
      myObj.value.last = 'HS'
      delete myObj.value.name
    }
    return { myFun, list, myObj }
  }
}</pre>
<p>我们可以看到在Vue 3设置中<code>watcher</code>被触发了四次。</p>
<h3>全球安装</h3>
<p>当你在<code>about</code>项目中打开<code>main.js</code>时，你会注意到一些不同。我们不再使用全局Vue实例来安装插件和其他库。</p>
<p>相反，你可以看到<code>createApp</code>方法:</p>
<pre>import { createApp } from 'vue'
import App from './App.vue'
const myApp = createApp(App)
myApp.use(/* plugin name */)
myApp.use(/* plugin name */)
myApp.use(/* plugin name */)
myApp.mount('#app')</pre>
<p>这个特性的优点是，它保护Vue应用程序免受我们使用的第三方库/插件的影响，这些库/插件可能会覆盖或更改全局实例——主要是通过使用Mixins。</p>
<p>现在使用<code>createApp</code>方法，我们将这些插件安装在一个特定的实例上，而不是全局对象上。</p>
<h3>门户网站</h3>
<p>Portal是一个特性，我们可以将一个组件中的部分代码呈现到不同DOM树中的不同组件中。Vue 2中有一个名为<code>portal-vue</code>的第三方插件实现了这一点。</p>
<p>在Vue 3中，将内置portal，非常易于使用。</p>
<p>Vue 3将有一个名为<code>&lt;Teleport&gt;</code>的特殊标签，这个标签内的任何代码都可以随时传送到任何地方。标签接受一个<code>to</code>参数。</p>
<p>让我们来看看实际情况:</p>
<pre>&lt;Teleport to="#modal-layer"&gt;
  &lt;div class="modal"&gt;
      hello
  &lt;/div&gt;
&lt;/Teleport&gt;</pre>
<p><code>&lt;Portal&gt;&lt;/Portal&gt;</code>中的任何代码都将显示在提到的目标位置。</p>
<pre>&lt;div id="modal-target"&gt;&lt;/div&gt;</pre>
<p>在撰写本文时，<code>&lt;Teleport&gt;</code>在上面提到的Alpha版本中不起作用。</p>
<h2>结论</h2>
<p>如果你计划开始你的新项目，你仍然可以继续使用Vue 2和一个复合API插件，然后迁移到Vue 3，因为除了移除过滤器之外，不会有任何突破性的改变。</p>
<p>Vue 3将会有很多令人惊奇的新功能。集成的组合将对未来应用程序的开发流程产生重大影响，它提供了一种简单的方法来组织和共享代码，并提供了强大的类型脚本支持。</p>
<p>在即将到来的新更新中，性能将得到微调，包的大小将进一步减小。</p>
<p>其他功能，如悬念，多v模型等，将使开发比以前更容易。</p><div class="code-block code-block-20">
<div class="blog-plug inline-plug vue-inline"><h2>像用户一样体验您的Vue应用</h2><p>调试Vue.js应用程序可能会很困难，尤其是当用户会话期间有几十个(如果不是几百个)突变时。如果您对监视和跟踪生产中所有用户的Vue突变感兴趣，</p><a href="https://lp.logrocket.com/blg/vue-signup" target="_blank">try LogRocket</a><p>. </p><a class="signup" href="https://lp.logrocket.com/blg/vue-signup" target="_blank" rel="noopener noreferrer"><img class="alignnone size-full wp-image-46 jetpack-lazy-image" src="../Images/0d269845910c723dd7df26adab9289cb.png" alt="LogRocket Dashboard Free Trial Banner" data-lazy-src="https://files.readme.io/00591d0-687474703a2f2f692e696d6775722e636f6d2f6a3049327856572e706e67.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://files.readme.io/00591d0-687474703a2f2f692e696d6775722e636f6d2f6a3049327856572e706e67.png"/><noscript><img data-lazy-fallback="1" class="alignnone size-full wp-image-46" src="../Images/0d269845910c723dd7df26adab9289cb.png" alt="LogRocket Dashboard Free Trial Banner" data-original-src="https://files.readme.io/00591d0-687474703a2f2f692e696d6775722e636f6d2f6a3049327856572e706e67.png"/></noscript></a><a href="https://lp.logrocket.com/blg/vue-signup" target="_blank" rel="noopener noreferrer">https://logrocket.com/signup/</a><p>LogRocket 就像是网络和移动应用程序的DVR，记录你的Vue应用程序中发生的一切，包括网络请求、JavaScript错误、性能问题等等。您可以汇总并报告问题发生时应用程序的状态，而不是猜测问题发生的原因。</p><p>LogRocket Vuex插件将Vuex突变记录到LogRocket控制台，为您提供导致错误的环境，以及出现问题时应用程序的状态。</p><p>现代化您调试Vue应用的方式- <a class="signup" href="https://lp.logrocket.com/blg/vue-signup" target="_blank" rel="noopener noreferrer">开始免费监控</a>。</p></div>


</div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
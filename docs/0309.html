<html>
<head>
<title>The future of React, unfolding with Suspense - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>React的未来，悬念迭起</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/the-future-of-react-unfolding-with-suspense/#0001-01-01">https://blog.logrocket.com/the-future-of-react-unfolding-with-suspense/#0001-01-01</a></blockquote><div><article class="article-post">
<p>自从React团队发布了他们的16.x版本，它就像风暴一样席卷了整个社区。该集合中一些最酷的新增功能是挂钩、延迟加载、悬念和缓存API。</p>
<p>这不仅仅是另一篇关于如何编写钩子的文章，而是关于React未来的展望！如果您从未听说过Hooks，或者React中的任何其他新API，那么这篇文章将是一个让您对未来感到兴奋的良好开端。</p>
<p>随着文章的深入，我们将涵盖两个新概念，预计将于2019年在Q2发布:</p>
<ul>
<li>如何使用悬念获取数据</li>
<li>如何使用react-cache</li>
</ul>
<p>我已经很兴奋了！但是，在我们深入探讨之前，让我们放慢速度，快速回顾一下。</p>
<h2>反应钩</h2>
<p>在React 16.8中，钩子正式成为稳定版本的一部分。它在高层次上解决了一些问题:</p>
<ul>
<li>通过采用使用函数编写一切的概念，它使得编写代码更加模块化，更易于维护</li>
<li>不鼓励使用使代码难以理解的<a href="https://reactjs.org/docs/higher-order-components.html" target="_blank" rel="noopener noreferrer"> HOCs </a>和其他复杂函数</li>
<li id="26e2" class="graf graf--li graf-after--li">放弃使用复杂的<a href="https://hackernoon.com/reactjs-component-lifecycle-methods-a-deep-dive-38275d9d13c0" target="_blank" rel="noopener noreferrer">生命周期</a>，如<code>componentDidMount</code>、<code>componentDidUpdate</code>等。，这需要我们编写重复的代码</li>
</ul>
<p>如果你想了解更多细节，<a href="https://reactjs.org/docs/hooks-intro.html#motivation" target="_blank" rel="noopener noreferrer">查看这里</a>。</p>
<p>所以，让我们来看看React Hooks的演示，看看一个典型的应用程序会是什么样子！</p>
<p>反应.懒惰</p>
<h2>这个名字真的泄露了它的意图！当我们想要延迟加载组件时，我们需要它:</h2>
<p>借助使用webpack的动态导入，我们可以做到这一点；它有助于创建包，这提高了我们的页面加载速度。让我们玩一个演示吧！只需返回到Codesandbox演示链接，将导入更改为以下内容:</p>
<pre>const<em> TodoList </em>=<em> React.lazy</em>(() =&gt; import("./containers/todoList"));</pre>
<p>请注意下图中单独的包是如何创建的😄</p>
<pre>const <em>TodoList</em> = <em>React.lazy</em>(() =&gt; import("./containers/todoList"));
const <em>CompletedList</em> = <em>React.lazy</em>(() =&gt; import("./containers/completedList"));
const <em>AddNewTask</em> = <em>React.lazy</em>(() =&gt; import("./containers/addNewTask"));</pre>
<p><img data-attachment-id="2547" data-permalink="https://blog.logrocket.com/the-future-of-react-unfolding-with-suspense/attachment/bundles-created/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2019/06/bundles-created.png" data-orig-size="2484,380" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Bundles created using webpack dynamic import" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2019/06/bundles-created-300x46.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2019/06/bundles-created-1024x157.png" decoding="async" class="alignnone size-full wp-image-2547 jetpack-lazy-image" src="../Images/a9255f1f2ff5b4ff171f2ce52114b49c.png" alt="Bundles Created With Webpack" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2019/06/bundles-created.png 2484w, https://blog.logrocket.com/wp-content/uploads/2019/06/bundles-created-300x46.png 300w, https://blog.logrocket.com/wp-content/uploads/2019/06/bundles-created-768x117.png 768w, https://blog.logrocket.com/wp-content/uploads/2019/06/bundles-created-1024x157.png 1024w" data-lazy-sizes="(max-width: 2484px) 100vw, 2484px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2019/06/bundles-created.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/06/bundles-created.png"/></p>
<p>焦虑</p><noscript><img data-lazy-fallback="1" data-attachment-id="2547" data-permalink="https://blog.logrocket.com/the-future-of-react-unfolding-with-suspense/attachment/bundles-created/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2019/06/bundles-created.png" data-orig-size="2484,380" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Bundles created using webpack dynamic import" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2019/06/bundles-created-300x46.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2019/06/bundles-created-1024x157.png" decoding="async" loading="lazy" class="alignnone size-full wp-image-2547" src="../Images/a9255f1f2ff5b4ff171f2ce52114b49c.png" alt="Bundles Created With Webpack" srcset="https://blog.logrocket.com/wp-content/uploads/2019/06/bundles-created.png 2484w, https://blog.logrocket.com/wp-content/uploads/2019/06/bundles-created-300x46.png 300w, https://blog.logrocket.com/wp-content/uploads/2019/06/bundles-created-768x117.png 768w, https://blog.logrocket.com/wp-content/uploads/2019/06/bundles-created-1024x157.png 1024w" sizes="(max-width: 2484px) 100vw, 2484px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/06/bundles-created.png"/></noscript>
<h2>悬念使用起来相当简单。让我们借助代码演示来更好地理解这一点:</h2>
<p>你可以在这里找到<a href="https://codesandbox.io/s/new-6m2gj" target="_blank" rel="noopener noreferrer">的演示链接</a>，如果你想玩的话。</p>
<pre><strong>// <a href="https://codesandbox.io/s/new-6m2gj" target="_blank" rel="noopener noreferrer">https://codesandbox.io/s/new-6m2gj</a></strong>
import React, { useState, useEffect, Suspense } from "react";
import ReactDOM from "react-dom";
import todoListData from "./containers/todoList/todolistData";
import Header from "./containers/header";
import Clock from "./components/Clock";
import "./styles.css";

<strong>const TodoList = React.lazy(() =&gt; import("./containers/todoList"));
const CompletedList = React.lazy(() =&gt; import("./containers/completedList"));
const AddNewTask = React.lazy(() =&gt; import("./containers/addNewTask"));</strong>

function App() {
  const { todolist } = todoListData;
  const [todoListPayload, setTodoListPayload] = useState(todolist);
  const [completedTodoList, setCompletedTodoList] = useState([]);

  const addTodoTaskHandler = value =&gt; {
    // addTodoTaskHandler
  };

  const removeTodoTaskHandler = ({ id }) =&gt; {
    // Remove from the set of todo list
  };

  const completeTodoTaskHandler = ({ id }) =&gt; {
    // Get item to remove
  };

return (
    &lt;div className="App"&gt;
      &lt;Header title={"My Tasks"} /&gt;
      &lt;Clock /&gt;
      &lt;div className="PageLayout"&gt;
        <strong>&lt;Suspense fallback={&lt;div&gt;Loading...&lt;/div&gt;}&gt;</strong>
          &lt;TodoList
            payload={todoListPayload}
            completeTodoTaskHandler={completeTodoTaskHandler}
          /&gt;
          &lt;CompletedList list={completedTodoList} /&gt;
          &lt;AddNewTask addTodoTaskHandler={addTodoTaskHandler} /&gt;
        <strong>&lt;/Suspense&gt;</strong>
      &lt;/div&gt;
    &lt;/div&gt;
  );
}

const rootElement = document.getElementById("root");
ReactDOM.render(&lt;App /&gt;, rootElement);</pre>
<p>如果我们检查演示中的代码，我们会看到:</p>
<p>就像用悬念包裹组件一样简单。我们使用<code>React.lazy()</code>缓慢地加载了一些组件— <code>TodoList</code>、<code>CompletedList</code>、<code>AddNewTask</code>。由于在内部它会为每个包生成包，在较慢的网络条件下，可能需要一些时间来加载它们。</p>
<pre><strong>&lt;Suspense fallback={&lt;div&gt;Loading...&lt;/div&gt;}&gt;</strong>
  &lt;TodoList
     payload={todoListPayload}
     completeTodoTaskHandler={completeTodoTaskHandler}
   /&gt;
  &lt;CompletedList list={completedTodoList} /&gt;
  &lt;AddNewTask addTodoTaskHandler={addTodoTaskHandler} /&gt;
<strong>&lt;/Suspense&gt;</strong></pre>
<p>“暂停”将通过显示一个<code>fallback</code>，如<strong>装载……</strong>或任何其他组件，如旋转器或类似组件，来自动处理此问题。</p>
<p>深入未来</p>
<h2>太好了！我们简短的回顾很激烈。现在让我们用悬念获得更多的乐趣。</h2>
<p>暂停和反应-缓存</p>
<h3>等等，我们不是已经谈过悬念了吗？那么，如果我告诉你当一个API被调用时，悬念也能处理我们的加载状态，会怎么样？但为此，我们真的需要深入研究API并更好地理解它。</h3>
<p>经过一番挖掘和研究，我终于找到了肖恩·王的🌟 GitHub库，我想直接引用他的<a href="https://github.com/sw-yx/fresh-concurrent-react/blob/master/apis/react-suspense.md" target="_blank" rel="noopener noreferrer">文档</a>:</p>
<p>反应暂停是组件在从缓存加载数据时暂停渲染的一种通用方式。它解决的问题:当渲染受到I/O限制时。</p>
<blockquote><p>好的，“从缓存中加载数据”给了我一个提示，但是我需要更多的信息来了解如何真正处理这个API。</p></blockquote>
<p>肯特·c·多兹在他的<a href="https://egghead.io/lessons/react-learn-fundamentals-of-react-suspense?pl=react-hooks-and-suspense-650307f2" target="_blank" rel="noopener noreferrer">理论家课</a>中教授了一个重要的概念:如果我们抛出一个承诺，悬念会自动知道一个API请求已经被调用。</p>
<p>当然，这不是处理代码的最佳方式；它看起来有点粗糙。因此，让我们尝试使用react-cache来更好地处理这段代码:</p>
<pre>import React, { Suspense } from "react";

fetchArticles() {
  // Some fetch API fetching articles
}

let isRequestCalled = false;
function Content() {
  let result = [];
  if (!cache) {
    const promise = fetchArticles();
    isRequestCalled = true;
    throw promise; // Let suspense know
  }
  return &lt;div&gt;Article&lt;/div&gt;;
}

const Articles = () =&gt; {
  return (
    &lt;div&gt;
     {/* Yay promise is thrown */}
      &lt;Suspense fallback={&lt;div&gt;loading...&lt;/div&gt;}&gt;
        &lt;Content /&gt;
      &lt;/Suspense&gt;
    &lt;/div&gt;
  );
};

export default Articles;</pre>
<p>从react-cache通过回调创建一个资源，返回一个承诺。</p>
<pre>import React, { Suspense } from "react";

<strong>import { unstable_createResource as createResource } from "react-cache";</strong>

function fetchArticles() {
  // Some fetch API fetching articles
}

<strong>const politicalArticles = createResource(fetchArticles);</strong>

function Content() {
  <strong>const result = politicalArticles.read(someKey);</strong>
  return &lt;div&gt;Article&lt;/div&gt;;
}

const Articles = () =&gt; {
  return (
    &lt;div&gt;
      <strong>&lt;Suspense fallback={&lt;div&gt;loading...&lt;/div&gt;}&gt;</strong>
        &lt;Content /&gt;
      <strong>&lt;/Suspense&gt;</strong>
    &lt;/div&gt;
  );
};

export default Articles;</pre>
<p>好吧，悬疑要知道它必须显示加载状态，它需要的只是一个承诺。它将继续显示装货状态，直到承诺得到解决。</p>
<p>然而，这是实验性的。我相信你会遇到错误，所以不要担心，它明确提到react-cache仍在开发中。</p>
<blockquote><p>只是提醒一下，确保在组件内部使用<code>read</code>方法；否则，它将抛出一个错误。</p></blockquote>
<p>如果您有兴趣阅读react-cache源代码，请查看这个<a href="https://github.com/facebook/react/blob/master/packages/react-cache/src/ReactCache.js" target="_blank" rel="noopener noreferrer">链接</a>。</p>
<pre>// A snippet from the React-cache library

function readContext(Context, observedBits) {
  const dispatcher = ReactCurrentDispatcher.current;
  if (dispatcher === null) {
    throw new Error(
      'react-cache: read and preload may only be called from within a ' +
        "component's render. They are not supported in event handlers or " +
        'lifecycle methods.',
    );
  }
  return dispatcher.readContext(Context, observedBits);
}</pre>
<p>恭喜你！</p>
<h2>我们现在赶上了React的不久的将来，有一件事是显而易见的:React团队希望使API尽可能简单。</h2>
<p>越来越多的库正在转向函数式编程，这也让我很兴奋。这种模式肯定会彻底改变我们编写前端的方式。我也在关注concurrent React——如果你感兴趣，可以查看官方的<a href="https://reactjs.org/blog/2018/11/27/react-16-roadmap.html#react-16x-mid-2019-the-one-with-suspense-for-data-fetching" target="_blank" rel="noopener noreferrer">路线图文档</a>。React——缓存和暂停是并发react的一些特性😎。</p>
<p><em>在<a href="https://twitter.com/daslusan" target="_blank" rel="noopener noreferrer"> <strong class="markup--strong markup--p-strong"> <strong> Twitter </strong> </strong> </a>上关注我，获取关于新文章和最新前端开发的更新。还有，在Twitter上分享这篇文章，帮助其他人找到它。分享就是关爱^_^ </em></p>
<p><a href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener"> LogRocket </a>:全面了解您的生产React应用</p><div class="code-block code-block-17">
<div class="blog-plug inline-plug react-plug" vwo-el-id="26283398190">
<h2 vwo-el-id="41600691720">调试React应用程序可能很困难，尤其是当用户遇到难以重现的问题时。如果您对监视和跟踪Redux状态、自动显示JavaScript错误以及跟踪缓慢的网络请求和组件加载时间感兴趣，</h2><p>. </p><a href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" vwo-el-id="19356441070">try LogRocket</a><p>LogRocket 结合了会话回放、产品分析和错误跟踪，使软件团队能够创建理想的web和移动产品体验。这对你来说意味着什么？</p><a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="19356441380">
<img class="first-react-image alignnone size-full wp-image-46 jetpack-lazy-image jetpack-lazy-image--handled" src="../Images/f300c244a1a1cf916df8b4cb02bec6c6.png" vwo-el-id="18272717540" data-lazy-loaded="1" data-original-src="https://files.readme.io/27c94e7-Image_2017-06-05_at_9.46.04_PM.png"/>
</a>
<a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="19356441690">
<img class="second-react-image alignnone size-full wp-image-46 jetpack-lazy-image jetpack-lazy-image--handled" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" vwo-el-id="30720362350" data-lazy-loaded="1" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/>
</a>
<p vwo-el-id="28675660440" class="">LogRocket不是猜测错误发生的原因，也不是要求用户提供截图和日志转储，而是让您回放问题，就像它们发生在您自己的浏览器中一样，以快速了解哪里出错了。</p>
<p>不再有嘈杂的警报。智能错误跟踪允许您对问题进行分类，然后从中学习。获得有影响的用户问题的通知，而不是误报。警报越少，有用的信号越多。</p>
<p>LogRocket Redux中间件包为您的用户会话增加了一层额外的可见性。LogRocket记录Redux存储中的所有操作和状态。</p>
<p vwo-el-id="28675660750">现代化您调试React应用的方式— <a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="40093418840">开始免费监控</a>。</p>
<p vwo-el-id="28675661060">Modernize how you debug your React apps —
<a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="40093418840">start monitoring for free</a>.
</p>
</div></div>
<hr/>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
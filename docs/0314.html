<html>
<head>
<title>What’s new in Nuxt 2.8 - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>Nuxt 2.8中的新特性- LogRocket博客</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/whats-new-in-nuxtjs-2-8/#0001-01-01">https://blog.logrocket.com/whats-new-in-nuxtjs-2-8/#0001-01-01</a></blockquote><div><article class="article-post">
<p>NuxtJS是开发VueJS应用程序发展最快的框架之一。能够选择你可以用它创建什么类型的应用程序(通用、静态生成或单页应用程序)是它的独特功能之一。</p>
<p>自从最初发布以来，它已经吸引了JavaScript社区的大量关注。VueJS社区非常支持这个工具，它可以帮助开发人员使用VueJS构建服务器端呈现的应用程序，而不需要深入的技术知识。如果你看看他们的GitHub简介，你会看到社区成员和用户提出的问题和各种各样的请求，以更好地改进框架。</p>
<p>核心团队已经发布了许多版本(您可以查看<a href="https://blog.logrocket.com/whats-new-in-nuxt-2-7/" target="_blank" rel="noreferrer noopener" aria-label=" (opens in a new tab)">这篇文章</a>以了解v2.7中的新内容)。在这篇文章中，我将重点介绍NuxtJS新版本中值得注意的新增内容，<strong> NuxtJS 2.8 </strong>。</p>
<h2>丰富</h2>
<p>在使用NuxtJS时，已经做了一些改进来增强开发人员的体验。让我们探索其中的一些。</p>
<h3>SSR(通用渲染)日志分组</h3>
<p>从NuxtJS v2.7开始，所有SSR日志都被报告给浏览器控制台。你不再需要切换屏幕。如下图所示，所有日志的结果都直接显示在浏览器中。</p>
<figure class="wp-block-image"><img decoding="async" src="../Images/dcc11f980cc215513263bb74ddcaac2c.png" alt="" data-lazy-src="https://user-images.githubusercontent.com/904724/57533442-12acec80-733e-11e9-92e9-950718b198ac.gif?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" class=" jetpack-lazy-image" data-original-src="https://user-images.githubusercontent.com/904724/57533442-12acec80-733e-11e9-92e9-950718b198ac.gif"/><noscript><img data-lazy-fallback="1" decoding="async" src="../Images/dcc11f980cc215513263bb74ddcaac2c.png" alt="" data-original-src="https://user-images.githubusercontent.com/904724/57533442-12acec80-733e-11e9-92e9-950718b198ac.gif"/></noscript></figure>
<p>然而，当你试图一次记录两件或更多事情时，事情会变得很混乱，因为你的浏览器日志会不断地被弄乱。从NuxtJS v2.8开始，SSR日志现在被分组，以避免污染浏览器控制台。</p>
<figure class="wp-block-image"><img decoding="async" src="../Images/5ff513fa75a99d427a9e55f26413a0ae.png" alt="" data-lazy-src="https://user-images.githubusercontent.com/904724/58566291-a3396700-8230-11e9-9dd6-09c3ff8578d2.gif?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" class=" jetpack-lazy-image" data-original-src="https://user-images.githubusercontent.com/904724/58566291-a3396700-8230-11e9-9dd6-09c3ff8578d2.gif"/><noscript><img data-lazy-fallback="1" decoding="async" src="../Images/5ff513fa75a99d427a9e55f26413a0ae.png" alt="" data-original-src="https://user-images.githubusercontent.com/904724/58566291-a3396700-8230-11e9-9dd6-09c3ff8578d2.gif"/></noscript></figure>
<h3>浏览器中的代码构建指示器</h3>
<p>NuxtJS v2.8附带的另一个令人兴奋的特性是一个指示器，可以在浏览器中显示新更改的构建状态。</p>
<figure class="wp-block-image"><img decoding="async" src="../Images/4a8db5822ecf6fca9d2442471fc7e705.png" alt="" data-lazy-src="https://user-images.githubusercontent.com/904724/58547105-129a6100-8207-11e9-9c61-a93956a17727.gif?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" class=" jetpack-lazy-image" data-original-src="https://user-images.githubusercontent.com/904724/58547105-129a6100-8207-11e9-9c61-a93956a17727.gif"/><noscript><img data-lazy-fallback="1" decoding="async" src="../Images/4a8db5822ecf6fca9d2442471fc7e705.png" alt="" data-original-src="https://user-images.githubusercontent.com/904724/58547105-129a6100-8207-11e9-9c61-a93956a17727.gif"/></noscript></figure>
<p>这非常有用，尤其是当你的应用程序需要一些时间来构建的时候。现在，您可以在浏览器中快速查看状态，而不必切换到终端进行检查。</p>
<h2>错误修复</h2>
<p>新版本修复了一些错误。这些错误修复旨在改善开发人员的体验或解决社区表达的问题。</p>
<h3><strong>智能重装</strong></h3>
<p>由于NuxtJS不直接使用的文件更改，监听没有支持的文件扩展名的目录可能会导致不必要的重新加载。如编辑使用的<code>*.swp</code>、<code>*~</code>或<code>*.bak</code>文件。从v2.8开始，NuxtJS只监听支持的扩展名的文件更改。所以当一个新文件(没有被NuxtJS直接使用)被创建时，你不再需要担心。</p>
<h3><strong>自动检测页面目录创建</strong></h3>
<p>页面是通用应用程序不可或缺的一部分。它们允许创建不同的文件，并在应用程序中自动路由。这是NuxtJS的默认行为。但是，当创建页面以查看它们的运行时，您必须重新启动服务器。在v2.8中，您不再需要这样做，因为NuxtJS现在可以检测您何时创建了一个<code>page/</code>目录，并且会自动重新加载。</p>
<h3><strong>简化的安装错误日志</strong></h3>
<p>在创建应用程序时，大多数时候肯定会出现错误。发生错误时立即看到正确的错误消息将使调试过程更快更容易。从Nuxtv2.8开始，当安装应用程序时出现错误时，错误会以开发模式记录到控制台，这样更容易跟踪。</p>
<p>之前:</p>
<figure class="wp-block-image"><img decoding="async" src="../Images/49479afec3818717fcee78a30b983302.png" alt="" data-lazy-src="https://user-images.githubusercontent.com/640208/58495799-ac66fd00-8178-11e9-969f-f80dad9a75e3.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" class=" jetpack-lazy-image" data-original-src="https://user-images.githubusercontent.com/640208/58495799-ac66fd00-8178-11e9-969f-f80dad9a75e3.png"/><noscript><img data-lazy-fallback="1" decoding="async" src="../Images/49479afec3818717fcee78a30b983302.png" alt="" data-original-src="https://user-images.githubusercontent.com/640208/58495799-ac66fd00-8178-11e9-969f-f80dad9a75e3.png"/></noscript></figure>
<p>之后:</p>
<figure class="wp-block-image"><img decoding="async" src="../Images/03d4e947e5f3ba3a133290adfc4df44d.png" alt="" data-lazy-src="https://user-images.githubusercontent.com/640208/58496300-e2f14780-8179-11e9-9923-ebc3b637fb1d.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" class=" jetpack-lazy-image" data-original-src="https://user-images.githubusercontent.com/640208/58496300-e2f14780-8179-11e9-9923-ebc3b637fb1d.png"/><noscript><img data-lazy-fallback="1" decoding="async" src="../Images/03d4e947e5f3ba3a133290adfc4df44d.png" alt="" data-original-src="https://user-images.githubusercontent.com/640208/58496300-e2f14780-8179-11e9-9923-ebc3b637fb1d.png"/></noscript></figure>
<h3>改进的延迟加载组件</h3>
<p>NuxtJS默认支持延迟加载。但是，有时用户编辑会改变这种行为。例如，如果用户用<code>splitChunks:{layouts: false, pages: false}</code>覆盖<code>webpack</code>的构建选项，页面将在运行应用程序时加载。即使这些组件已经加载到您的应用程序中，当NuxtJS完成解析过程时，它们仍然是延迟加载的。新更新中的更改解决了这个问题。现在，延迟加载的组件变得更小，并且得到了改进。</p>
<h3><strong>缩小的SPA回退HTML文件</strong></h3>
<p>以前，SPA回退的HTML在生成路由后不会缩小，从而导致在SPA模式下产生不同的文件。缩小通过将相关文件整理和分组在一起，有助于减少应用程序中使用的文件数量。<br/>之前:</p>
<pre class="wp-block-code"><code>$ find examples/spa/dist/ -name '*.html' -exec md5sum {} \;&#13;
853e7d39c6c79431172d11c71115d487  examples/spa/dist/200.html&#13;
4014fb429eb22afeb868705a0dd476db  examples/spa/dist/about/index.html&#13;
4014fb429eb22afeb868705a0dd476db  examples/spa/dist/index.html</code></pre>
<p>之后:</p>
<pre class="wp-block-code"><code>$ find examples/spa/dist/ -name '*.html' -exec md5sum {} \;&#13;
4014fb429eb22afeb868705a0dd476db  examples/spa/dist/200.html&#13;
4014fb429eb22afeb868705a0dd476db  examples/spa/dist/about/index.html&#13;
4014fb429eb22afeb868705a0dd476db  examples/spa/dist/index.html</code></pre>
<h3><strong>改良控制台</strong></h3>
<p>Consola可以向您的控制台添加自定义样式。然而，在NuxtJS以前的版本中，自定义样式被覆盖了。这个问题在2.8版中已经得到修复，因为consola现在是可选的。</p>
<h3><strong>捆绑重新渲染</strong></h3>
<p>控制你的HTML加载的脚本就是在你的<strong> nuxt.config.js </strong>文件<strong>的<strong> bundleRenderer </strong>对象中编写<code>"inject: false"</code>。</strong>然而<strong>，</strong>一些JavaScript文件甚至在改变选项后仍然被加载。此问题已在新版本中得到解决。所以你100%的控制你的脚本。</p>
<h3><strong>安全SSR日志</strong></h3>
<p>在使用NuxtJS进行开发时，您可能会在终端中遇到以下错误:</p>
<pre class="wp-block-code"><code> WARN  Cannot stringify a function VueComponent                                                                          &#13;
 WARN  Cannot stringify arbitrary non-POJOs VueComponent </code></pre>
<p>在您的浏览器中:</p>
<pre class="wp-block-code"><code>Maximum call stack size exceeded error</code></pre>
<p>当您尝试将消息记录到您的控制台时，就会出现这种情况，如下所示:</p>
<pre class="wp-block-code"><code>created() {&#13;
  console.log(this.$route)&#13;
}</code></pre>
<p>虽然它不会阻止你的应用程序运行，但这不是你想要的行为，而且会让调试变得很痛苦。从v2.8开始，NuxtJS现在可以安全地格式化SSR日志。</p>
<figure class="wp-block-image"><img decoding="async" src="../Images/dddb8900ce843d9b56c0b09c0fd8e82f.png" alt="" data-lazy-src="https://user-images.githubusercontent.com/5158436/57982252-ed179580-7a57-11e9-8e78-79535b92ebb6.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" class=" jetpack-lazy-image" data-original-src="https://user-images.githubusercontent.com/5158436/57982252-ed179580-7a57-11e9-8e78-79535b92ebb6.png"/><noscript><img data-lazy-fallback="1" decoding="async" src="../Images/dddb8900ce843d9b56c0b09c0fd8e82f.png" alt="" data-original-src="https://user-images.githubusercontent.com/5158436/57982252-ed179580-7a57-11e9-8e78-79535b92ebb6.png"/></noscript></figure>
<h2>依赖性升级</h2>

<p>移植提示 : 你不需要为了任何效果而修改你的项目中的任何一行代码。一旦升级到NuxtJS v2.8，一切都会自动迁移。</p>
<h2>结论</h2>
<p>在本教程中，我们探索了NuxtJS v2.8中的一些新特性和改进。我们还研究了一些不推荐使用的特性和未来警告。要查看所有变更的具体列表并了解更多关于新版本的信息，请务必查看版本<a href="https://github.com/nuxt/nuxt.js/releases" target="_blank" rel="noreferrer noopener" aria-label=" (opens in a new tab)">页面</a>。你最喜欢的新特性/API是什么？分享在评论里<strong>！</strong>快乐编码！</p>
<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
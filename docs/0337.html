<html>
<head>
<title>Sapper and Svelte: A quick tutorial - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>Sapper和Svelte:快速教程- LogRocket博客</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/sapper-svelte-tutorial-2021/#0001-01-01">https://blog.logrocket.com/sapper-svelte-tutorial-2021/#0001-01-01</a></blockquote><div><article class="article-post">
<p><em> <strong>编者按</strong>:这个苗条和工蜂的教程最后一次更新是在2021年7月2日，包括工蜂的继任者<a href="https://kit.svelte.dev/" target="_blank" rel="noopener">苗条装备</a>的信息。关于SvelteKit的更多信息，请查看"<a href="https://blog.logrocket.com/exploring-sveltekit-the-newest-svelte-based-framework/" target="_blank" rel="noopener">探索SvelteKit，最新的基于SvelteKit的框架</a>"</em></p>
<p/>
<p>不久前，<a href="http://We'll%20be%20taking%20a%20high-level%20look%20at%20Sapper,%20what%20it%20is,%20how%20it%20helps%20you%20build%20full-fledged,%20lightweight%20apps,%20and%20why%20you%20should%20consider%20using%20it.%20Note:%20This%20post%20is%20a%20followup%20to%20the%20intro%20to%20Svelte%20article%20published%20a%20while%20back.%20I%20strongly%20urge%20you%20to%20read%20it%20here:%20https://blog.logrocket.com/truly-reactive-programming-with-svelte-3-0-321b49b75969/." target="_blank" rel="noreferrer noopener">我们探索了Svelte.js </a>,看到了它如何帮助你编写真正的反应式应用程序，同时比许多其他前端框架交付更少的代码。虽然你完全可以单独用<a href="https://blog.logrocket.com/how-to-build-a-simple-svelte-js-app/" target="_blank" rel="noopener noreferrer">苗条的</a>构建一个更复杂的应用程序，但它可能会很快变得一团糟。进入工兵！</p>
<p>在本教程中，我们将对Sapper进行一个高层次的观察，展示它如何帮助您构建成熟的轻量级应用程序，并分解服务器渲染的应用程序。以下是我们将要介绍的内容:</p>

<h2 id="dead">萨帕尔死了吗？</h2>
<p>在2020年10月的<a href="https://sveltesummit.com/" target="_blank" rel="noopener">svelet峰会</a>上，svelet和Sapper的创造者Rich Harris在他题为“未来主义Web开发”的演讲中宣布，他和他的团队正在开发<a href="https://kit.svelte.dev/" target="_blank" rel="noopener">svelet kit</a>来取代Sapper。</p>
<p><iframe loading="lazy" title="YouTube video player" src="https://www.youtube.com/embed/qSfdtmcZ4d0" frameborder="0" allowfullscreen="allowfullscreen">视频</iframe></p>
<p>在他的后续博客文章中，哈里斯解释了这一转变背后的原因。首先，SvelteKit旨在简化入门，减少维护和支持负担，并提供可预测的项目结构。</p>
<p>在更高的层面上，SvelteKit是为了应对“非捆绑开发”工作流的兴起而构建的，在这种工作流中，开发服务器按需提供模块，而不是捆绑应用程序。这使得启动几乎是瞬间的，不管你的应用程序有多大。</p>
<p>最后，SvelteKit将支持所有主要的无服务器提供商，并包括一个适配器API，使其与非官方平台兼容。</p>
<h2 id="whyyoushouldnt">为什么2021年不应该用Sapper</h2>
<p>虽然在撰写本文时它仍处于公开测试阶段，但SvelteKit现在已经有了<a href="https://kit.svelte.dev/docs" target="_blank" rel="noopener">完整的文档</a>，看起来<a href="https://github.com/sveltejs/kit/issues?q=is%3Aopen+is%3Aissue+milestone%3A1.0" target="_blank" rel="noopener">正在向版本1.0 </a>冲刺。</p>
<p>另一方面，工兵将不再被维持。如<a href="https://sapper.svelte.dev/docs/#Introduction" target="_blank" rel="noopener">正式文件</a>所述:</p>
<blockquote><p>Sapper的succesor，SvelteKit，目前可以使用。所有向前发展的努力将集中在SvelteKit上。</p></blockquote>
<p>对于苗条的开发者来说，这意味着，在大多数情况下，你应该<a href="https://dev.to/danawoodman/when-to-use-svelte-vs-sveltetkit-vs-sapper-4o6a" target="_blank" rel="noopener">考虑从Sapper迁移到svelet kit</a>。Sapper文档包括一个有用的<a href="https://sapper.svelte.dev/migrating/" target="_blank" rel="noopener">迁移指南</a>，供希望做出改变的苗条开发者使用。</p>
<p>也就是说，如果你对使用beta软件的潜在障碍感到不安，或者如果你想直接访问Express/Polka，你可能仍然想使用Sapper。如果你仍然想使用Sapper，尽管它缺乏支持，请继续阅读了解如何使用。</p>
<h2 id="whatissapper">什么是Sapper？</h2>
<p>Sapper 是Svelte的配套组件框架，可以帮助你快速高效地构建更大更复杂的应用。</p>
<p>在当今时代，构建web应用程序是一项相当复杂的工作，需要进行代码拆分、数据管理、性能优化等。这也是为什么现在有无数的前端工具，但是它们都有自己的复杂程度和学习曲线。</p>
<p>建一个app应该没那么难吧？还能比现在更简单吗？有没有一种方法可以在保持理智的情况下勾选所有的选项？当然有——那是一个反问句！</p>
<p>先说名字:工兵。我将直接引用官方文件来解释为什么选择这个名字:</p>
<blockquote class="wp-block-quote"><p>在战争中，那些在战斗条件下架桥、修路、扫雷和爆破的士兵被称为工兵。</p></blockquote>
<p>对于网络开发人员来说，风险通常低于战斗工程师。但我们面临着自己的不利环境:功能不足的设备、糟糕的网络连接以及前端工程固有的复杂性。Sapper是苗条应用制造商的简称，是你勇敢而尽职的盟友。</p>
<p>嗯，很有道理🤓。</p>
<p>Sapper(或者说，Svelte)的设计是轻量级的、高性能的、易于推理的，同时还提供了足够的功能来将你的想法转化为出色的网络应用。</p>
<p>基本上，以下是Sapper在以苗条的方式构建web应用程序时帮助你处理的事情:</p>
<ul>
<li>按指定路线发送</li>
<li>服务器端渲染</li>
<li>自动代码分割</li>
<li>离线支持(使用服务人员)</li>
<li>高层项目结构管理</li>
</ul>
<p>我相信你会同意，自己管理这些会很快变成一件杂务，让你从实际的业务逻辑中分心。</p>
<p>但是空谈是廉价的——代码是有说服力的！让我们通过一个使用Svelte和Sapper的小型服务器渲染应用程序。</p>
<h2 id="example">工蜂示例</h2>
<p>我不会告诉你Sapper如何帮助你轻松构建应用程序，我们将探索当你搭建一个新项目时得到的演示应用程序，并看看它是如何在幕后工作的。</p>
<p>首先，运行以下命令来引导一个新项目:</p>
<pre>$ npx degit "sveltejs/sapper-template#rollup" my-app
$ cd my-app
$ npm install
$ npm run dev</pre>
<p>这样做将得到一个基本的项目，但是对于本文的目的来说已经足够了。我们应该能够探索Sapper如何用这个简单的项目处理路由和服务器端渲染，而不必太深入。</p>
<p>让我们开始吧！</p>
<h2 id="project">项目结构</h2>
<p>Sapper是一个固执己见的框架，意味着某些文件和文件夹是必需的，项目目录必须以某种方式构建。让我们看看一个典型的Sapper项目是什么样子的，所有的东西都放在哪里。</p>
<h3>入口点</h3>
<p>每个Sapper项目都有三个入口点和一个<code>src/template.html</code>文件:</p>
<ol>
<li><code>src/client.js</code></li>
<li><code>src/server.js</code></li>
<li><code>src/service-worker.js</code>(这个是可选的)</li>
</ol>
<h4><code>client.js</code></h4>
<pre>import * as sapper from '@sapper/app';

sapper.start({
  target: document.querySelector('#sapper')
});</pre>
<p>这是客户端渲染应用程序的入口点。这是一个相当简单的文件，您在这里需要做的就是从<code>@sapper/app</code>导入主Sapper模块，并从中调用<code>start</code>方法。它接受一个对象作为参数，唯一需要的键是<code>target</code>。</p>
<p/>
<p>目标指定应用程序将被挂载到哪个DOM节点上。如果你来自React.js背景，就把这个当做<code>ReactDOM.render</code>。</p>
<h4><code>server.js</code></h4>
<p>我们需要一个服务器来为用户提供我们的应用程序，不是吗？因为这是一个Node.js环境，所以有大量选项可供选择。你可以使用Express.js服务器、Koa.js服务器、Polka服务器等等。，但是有一些规则要遵循:</p>
<ol>
<li>服务器必须提供<code>/static</code>文件夹的内容。Sapper不在乎你怎么做。把那个文件夹端上来！</li>
<li>你的服务器框架必须支持中间件(我个人不知道有哪个不支持)，而且必须使用从<code>@sapper/server</code>导入的<code>sapper.middleware()</code>。</li>
<li>您的服务器必须监听<code>process.env.PORT</code>。</li>
</ol>
<p>只有三条规则——如果你问我，我觉得还不错。看一看为我们生成的<code>src/server.js</code>文件，看看它实际上是什么样子。</p>
<h4><code>service-worker.js</code></h4>
<p>如果你需要重温一下什么是服务人员，<a href="https://developers.google.com/web/fundamentals/primers/service-workers/" target="_blank" rel="noreferrer noopener">这篇文章应该很适合</a>。现在，你用Sapper构建一个全功能的web app不需要<code>service-worker.js</code>文件；它只允许您访问离线支持、推送通知、后台同步等功能。</p>
<p>由于服务人员习惯于应用程序，因此没有关于如何编写应用程序的硬性规定。您可以选择完全忽略它，或者利用它来提供更完整的用户体验。</p><div class="code-block code-block-54">
<hr/>
<h3>更多来自LogRocket的精彩文章:</h3>

<hr/></div>
<h4><code>template.html</code></h4>
<p>这是应用程序的主要入口点，所有的组件、样式引用和脚本都是在这里根据需要注入的。除了极少数情况下需要通过从HTML链接到CDN来添加模块，这几乎是一劳永逸的。</p>
<h4><code>routes</code></h4>
<p>每个工蜂app的MVP。这是你大部分逻辑和内容的所在。我们将在下一节中进行更深入的探讨。</p>
<h2 id="routing">按指定路线发送</h2>
<p>如果你运行了<strong>动手体验</strong>部分的所有命令，导航到<code><a href="http://localhost:3000" rel="nofollow">http://localhost:3000</a></code>应该会带你到一个简单的网络应用，有主页、关于页面和博客页面。到目前为止，很简单。</p>
<p>现在让我们试着理解Sapper是如何将URL与相应的文件相协调的。在Sapper中，有两种类型的路由:页面路由和服务器路由。</p>
<p>让我们进一步分解一下。</p>
<h3>寻呼路线</h3>
<p>当你导航到一个页面——比如说，<code>/about</code> — Sapper会呈现一个位于<code>src/routes</code>文件夹中的<code>about.svelte</code>文件。这意味着该文件夹中的任何<code>.svelte</code>文件都会自动“映射”到同名的路径。因此，如果在<code>src/routes</code>文件夹中有一个名为<code>jumping.svelte</code>的文件，导航到<code>/jumping</code>将导致该文件被渲染。</p>
<p>简而言之，页面路由就是<code>src/routes</code>文件夹下的<code>.svelte</code>文件。这种方法的一个非常好的副作用是你的路线是可预测的，并且很容易推理。你想要一条新路线？在<code>src/routes</code>中创建一个新的<code>.svelte</code>文件，你就成功了！</p>
<p>如果您想要一个类似于下面这样的嵌套路由怎么办:<code>/projects/sapper/awesome</code>？您需要做的就是为每个子路由创建一个文件夹。因此，对于上面的例子，你将有一个这样的文件夹结构:<code>src/routes/projects/sapper</code>，然后你可以在<code>/sapper</code>文件夹中放置一个<code>awesome.svelte</code>文件。</p>
<p>记住这一点，让我们看看我们的引导应用程序，并导航到“关于”页面。你认为这个页面的内容是从哪里呈现的？好吧，我们来看看<code>src/routes</code>。果然，我们在那里找到了一个<code>about.svelte</code>文件——简单且可预测！</p>
<p>请注意，<code>index.svelte</code>文件是一个保留文件，当您导航到一个子路由时会呈现出来。例如，在我们的例子中，我们有一个<code>/blogs</code>路由，在那里我们可以访问它下面的其他子路由，例如<code>/blogs/why-the-name</code>。</p>
<p>但是请注意，当<code>/blogs</code>本身是一个文件夹时，在浏览器中导航到<code>/blogs</code>会呈现一个文件。如何为这样的路线选择要渲染的文件？</p>
<p>要么我们在<code>/blogs</code>文件夹外定义一个<code>blog.svelte</code>文件，要么我们需要一个<code>index.svelte</code>文件放在<code>/blogs</code>文件夹下，但不能同时放在两个文件夹下。当您直接访问<code>/blogs</code>时，该<code>index.svelte</code>文件被渲染。</p>
<p>有动态slugs的URL怎么办？在我们的例子中，手动创建每一篇博客文章并将它们存储为<code>.svelte</code>文件是不可行的。我们需要的是一个模板，用于渲染所有的博客帖子，而不管蛞蝓。</p>
<p>再看一下我们的项目。在<code>src/routes/blogs</code>下面，有一个<code>[slug].svelte</code>文件。你认为那是什么？是的——它是渲染所有博客文章的模板，而不考虑slug。这意味着任何跟在<code>/blogs</code>后面的slug都会被这个文件自动处理，我们可以在page mount上获取页面内容，然后将它呈现给浏览器。</p>
<p>这是否意味着<code>/routes</code>下的任何文件或文件夹都会自动映射到一个URL？是的，但是这条规则有一个例外。如果您在文件或文件夹前添加下划线，Sapper不会将其转换为URL。这使得您可以轻松地在routes文件夹中放置助手文件。</p>
<p>假设我们需要一个助手文件夹来存放我们所有的助手函数。我们可以有一个类似于<code>/routes/_helpers</code>的文件夹，然后任何放在<code>/_helpers</code>下的文件都不会被当作一个路径。很漂亮，对吧？</p>
<h3>服务器路由</h3>
<p>在上一节中，我们看到有一个<code>[slug].svelte</code>文件可以帮助我们匹配像这样的任何URL:<code>/blogs/&lt;any_url&gt;</code>。但是它实际上是如何让页面的内容呈现出来的呢？</p>
<p>您可以从静态文件中获取内容，或者通过API调用来检索数据。无论哪种方式，您都需要向路由(或者端点，如果您只考虑API)发出请求来检索数据。这就是服务器路由的用武之地。</p>
<p>来自官方文档:“服务器路由是写在<code>.js</code>文件中的模块，这些模块导出对应于HTTP方法的函数。”</p>
<p>这只是意味着服务器路由是端点，您可以调用它们来执行特定的操作，比如保存数据、获取数据、删除数据等。它基本上是你的应用程序的后端，所以你可以在一个项目中拥有你需要的一切(当然，如果你愿意，你可以把它分开)。</p>
<p>现在回到我们的自举项目。如何获取<code>[slug].svelte</code>中每篇博文的内容？好吧，打开文件，你看到的第一段代码是这样的:</p>
<pre>&lt;script context="module"&gt;
  export async function preload({ params, query }) {
    // the `slug` parameter is available because
    // this file is called [slug].html
    const res = await this.fetch(`blog/${params.slug}.json`);
    const data = await res.json();
    if (res.status === 200) {
      return { post: data };
    } else {
      this.error(res.status, data.message);
    }
  }
&lt;/script&gt;</pre>
<p>我们所看到的只是一个简单的JS函数，它发出一个GET请求并从该请求中返回数据。它接受一个对象作为参数，然后在第2行将其析构以获得两个变量:<code>params</code>和<code>query</code>。</p>
<p><code>params</code>和<code>query</code>包含什么？为什么不在函数的开头加一个<code>console.log()</code>，然后在浏览器中打开一篇博文呢？这样做后，您会在控制台中记录如下内容:</p>
<pre>{slug: "why-the-name"}slug: "why-the-name"__proto__: Object {}</pre>
<p>嗯。因此，如果我们打开第5行的“why-the-name”帖子，我们的GET请求将是对<code>blog/why-the-name.json</code>的请求，然后在第6行将其转换为JSON对象。</p>
<p>在第7行，我们检查我们的请求是否成功，如果成功，就在第8行返回它，否则调用一个名为<code>this.error</code>的<a href="https://sapper.svelte.dev/docs#this_error" target="_blank" rel="noreferrer noopener">特殊方法</a>，并给出响应状态和错误消息。</p>
<p>很简单。但是实际的服务器路由在哪里，它看起来像什么？查看<code>src/routes/blogs</code>内部，您应该会看到一个<code>[slug].json.js</code>文件——这是我们的服务器路由。注意到它的名字和<code>[slug].svelte</code>一样吗？这就是Sapper如何将服务器路由映射到页面路由。因此，如果您在名为<code>example.svelte</code>的文件中调用<code>this.fetch</code>，Sapper将寻找一个<code>example.json.js</code>文件来处理请求。</p>
<p>现在我们来解码[slug].json.js，好吗？</p>
<pre>import posts from './_posts.js';

const lookup = new Map();
posts.forEach(post =&gt; {
  lookup.set(post.slug, JSON.stringify(post));
});

export function get(req, res, next) {
  // the `slug` parameter is available because
  // this file is called [slug].json.js
  const { slug } = req.params;
  if (lookup.has(slug)) {
    res.writeHead(200, {
      'Content-Type': 'application/json'
    });
    res.end(lookup.get(slug));
  } else {
    res.writeHead(404, {
      'Content-Type': 'application/json'
    });
    res.end(JSON.stringify({
      message: `Not found`
    }));
  }
}</pre>
<p>我们真正感兴趣的是从第8行开始。第3–6行只是为要使用的路线准备数据。还记得我们如何在页面路由中发出GET请求:<code>[slug].svelte</code>？这是处理该请求的服务器路由。</p>
<p>如果您熟悉Express.js APIs，那么您应该对此很熟悉。这是因为这只是一个简单的端点控制器。它所做的就是获取从<code>Request</code>对象传递给它的slug，在我们的数据存储中搜索它(在本例中是<code>lookup</code>，并在<code>Response</code>对象中返回它。</p>
<p>如果我们使用数据库，第12行可能看起来像<code>Posts.find({ where: { slug } })</code> (Sequelize，有人吗？).你知道了。</p>
<p>服务器路由是包含端点的文件，我们可以从页面路由中调用这些端点。因此，让我们快速总结一下目前为止我们所知道的:</p>
<ul>
<li>页面路由是<code>src/routes</code>文件夹下的<code>.svelte</code>文件，用于向浏览器呈现内容。</li>
<li>服务器路由是包含API端点的<code>.js</code>文件，通过名称映射到特定的页面路由。</li>
<li>页面路由可以调用服务器路由中定义的端点来执行特定的操作，如获取数据。</li>
<li>萨帕尔是相当深思熟虑的。</li>
</ul>
<h2 id="server">服务器端渲染</h2>
<p>服务器端渲染(SSR)是Sapper如此吸引人的一个重要原因。如果你不知道什么是SSR，也不知道你为什么需要它，这篇文章很好地解释了这个问题。</p>
<p>默认情况下，在客户端挂载动态元素之前，Sapper会先在服务器端渲染所有的应用程序。这让你可以两全其美，而不必做出任何妥协。</p>
<p>不过，这里有一个警告:虽然Sapper在支持第三方模块方面做得近乎完美，但是有些模块需要访问<code>window</code>对象，正如您所知，您不能从服务器端访问<code>window</code>。简单地导入这样一个模块将导致你的编译失败，世界将变得有点暗淡🥺.</p>
<p>不过，不要担心；对此有一个简单的解决方法。Sapper允许你动态地导入模块(嘿，更小的初始包大小)，所以你不需要在顶层导入模块。相反，您所做的将是这样的:</p>
<pre>&lt;script&gt;
  import { onMount } from 'svelte';

  let MyComponent;

  onMount(async () =&gt; {
    const module = await import('my-non-ssr-component');
    MyComponent = module.default;
  });
&lt;/script&gt;

&lt;svelte:component this={MyComponent} foo="bar"/&gt;</pre>
<p>在第2行，我们导入了<code>onMount</code>函数。<code>onMount</code>函数内置在Svelte中，只有当组件安装在客户端时才会被调用(可以把它想象成React的<code>componentDidMount</code>)。</p>
<p>这意味着当只在<code>onMount</code>函数中导入我们有问题的模块时，该模块永远不会在服务器上被调用，我们也不会有丢失<code>window</code>对象的问题。那里！您的代码编译成功，一切又都好了。</p>
<p>哦，这种方法还有另一个好处:因为您对这个组件使用了动态导入，所以实际上最初向客户端发送的代码更少。</p>
<h2>结论</h2>
<p>我们已经看到了使用Sapper是多么直观和简单。路由系统非常容易掌握，即使对于绝对的初学者来说也是如此，创建一个API来驱动你的前端相当简单，SSR非常容易实现，等等。</p>
<p>这里有很多我没有提到的特性，包括预加载、错误处理、正则表达式路径等等。真正受益的唯一方法是用它来建造一些东西。</p><div class="code-block code-block-2">
<div class="blog-plug base-cta"><h2>使用<a class="signup" href="https://lp.logrocket.com/blg/signup" target="_blank" rel="noopener noreferrer"> LogRocket </a>消除传统错误报告的干扰</h2>
<a href="https://lp.logrocket.com/blg/signup" class="signup" target="_blank" rel="noopener noreferrer"><img class="alignnone size-full wp-image-46 jetpack-lazy-image" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/><noscript><img data-lazy-fallback="1" class="alignnone size-full wp-image-46" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/></noscript></a>
<p><a href="https://lp.logrocket.com/blg/signup" target="_blank" rel="noopener noreferrer"> LogRocket </a>是一个数字体验分析解决方案，它可以保护您免受数百个假阳性错误警报的影响，只针对几个真正重要的项目。LogRocket会告诉您应用程序中实际影响用户的最具影响力的bug和UX问题。</p>
<p>然后，使用具有深层技术遥测的会话重放来确切地查看用户看到了什么以及是什么导致了问题，就像你在他们身后看一样。</p>
<p>LogRocket自动聚合客户端错误、JS异常、前端性能指标和用户交互。然后LogRocket使用机器学习来告诉你哪些问题正在影响大多数用户，并提供你需要修复它的上下文。</p>
<p>关注重要的bug—<a class="signup" href="https://lp.logrocket.com/blg/signup-issue-free" target="_blank" rel="noopener noreferrer">今天就试试LogRocket】。</a></p></div></div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>
 
</div>    
</body>
</html>
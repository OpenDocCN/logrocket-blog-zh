<html>
<head>
<title>Setting up a Headless Chrome Node.js server in Docker - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>在Docker - LogRocket博客中设置一个无头Chrome Node.js服务器</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/setting-headless-chrome-node-js-server-docker/#0001-01-01">https://blog.logrocket.com/setting-headless-chrome-node-js-server-docker/#0001-01-01</a></blockquote><div><article class="article-post">
<p><em> <strong>编者按:</strong> </em> <em>这篇关于在Docker中设置无头Chrome Node.js服务器的指南最后一次更新是在2023年1月9日更新任何过时的代码，进一步解释了Dockerfile步骤的分解，并包括了更多交互式代码示例。要了解更多关于Docker的信息，请访问我们的档案<a href="https://blog.logrocket.com/tag/docker/">这里</a>。</em></p>
<p>随着应用程序开发过程中自动化UI测试的兴起，无头浏览器变得非常流行。网站爬虫和基于HTML的内容分析也有无数的用例。</p>
<p>在99%的情况下，你不需要浏览器GUI，因为它是完全自动化的。运行一个GUI比运行一个基于Linux的服务器或者在一个微服务集群上扩展一个简单的Docker容器更昂贵，比如T2的Kubernetes T3。</p>
<p>但是我跑题了。拥有一个基于Docker容器的无头浏览器来最大化灵活性和可伸缩性变得越来越重要。在本教程中，我们将演示如何创建一个<a href="https://blog.logrocket.com/node-js-docker-improve-dx-docker-compose/"> Dockerfile </a>来在<a href="https://blog.logrocket.com/tag/node/"> Node.js </a>中设置一个无头Chrome浏览器。</p>
<p><em>向前跳转:</em></p>

<h2 id="headless-chrome-node-js">带有Node.js的无头浏览器</h2>
<p>Node.js是谷歌Chrome开发团队使用的主要语言接口，它有一个几乎是原生的集成库，用于与Chrome进行通信，名为<a href="https://blog.logrocket.com/creating-puppeteer-microservice-deploy-google-cloud-functions/">puppeter</a>。这个库通过一个<a href="https://blog.logrocket.com/debugging-node-js-chrome-devtools/"> Chrome DevTools </a>接口使用<a href="https://blog.logrocket.com/websocket-tutorial-real-time-node-react/"> WebSocket </a>或一个基于系统管道的协议，它可以截图，并测量页面负载指标、连接速度、下载内容大小等等。</p>
<p>您可以使用Puppeteer库将Headless Chrome与Node.js一起使用。Puppeteer是一个Node.js库，它提供了一个<a href="https://blog.logrocket.com/understanding-api-key-authentication-node-js/">高级API </a>来控制Chrome或通过Chrome DevTools协议控制<a href="https://blog.logrocket.com/what-chromiums-browser-compatibility-means-for-scrolling/">Chrome</a>。</p>
<p>你可以在不同的设备模拟上测试你的UI，并截图。最重要的是，木偶师不需要运行GUI。事实上，这一切都可以在无头模式下完成。</p>
<p>下面是一个使用Puppeteer控制Headless Chrome并导航到网站的实现:</p>
<pre class="language-javascript hljs">// Filename: server.js

const express = require('express');
const puppeteer = require('puppeteer');

const app = express();

app.get('/screenshot', async (req, res) =&gt; {
    console.log('Taking screenshot');
    const browser = await puppeteer.launch({
        headless: true,
        executablePath: '/usr/bin/google-chrome',
        args: [
            "--no-sandbox",
            "--disable-gpu",
        ]
    });
    const page = await browser.newPage();
    await page.goto('https://www.google.com');
    const imageBuffer = await page.screenshot();
    await browser.close();

    res.set('Content-Type', 'image/png');
    res.send(imageBuffer);
    console.log('Screenshot taken');
});

app.listen(3000, () =&gt; {
    console.log('Listening on port 3000');
});
</pre>
<p>上面显示了在Headless Chrome上截屏的简单代码。这个脚本将启动一个Headless Chrome实例，导航到<a href="https://www.google.com/"> Google </a>，并对页面进行截图。截图会保存到当前目录。</p>
<p>代码还创建了一个<a href="https://blog.logrocket.com/organizing-express-js-project-structure-better-productivity/"> Express.js </a> app，它只有一个路由<code>/screenshot</code>，使用Headless Chrome对<a href="https://www.google.comand/">这个</a>进行截图，然后在HTTP响应中将图像数据发送回客户端。</p>
<p>要使用这个路由，您可以发出一个<a href="https://blog.logrocket.com/axios-vs-fetch-best-http-requests/"> HTTP请求</a>到<code><a href="http://localhost:3000/screenshot" rel="nofollow">http://localhost:3000/screenshot</a></code>，服务器将用一个图像来响应。您还可以自定义路由以接受查询参数，或者使用其他HTTP方法来控制屏幕截图的行为。</p>
<h2 id="headless-chrome-inside-docker-container">Docker容器中的无头Chrome</h2>
<p>基于上面的代码，在容器中运行浏览器看起来很简单，但是重要的是不要忽视<a href="https://blog.logrocket.com/secure-open-source-node-js-dependencies/">安全性</a>。默认情况下，容器中的所有东西都在root用户下运行，浏览器在本地执行JavaScript文件。</p>
<h3 id="dockerfile-google-chrome-setup">Google Chrome设置的docker文件</h3>
<p>要继续学习本教程，请确保您已经安装了Docker v17.03或更高版本的浏览器(最好是谷歌浏览器)。</p>
<p>当然，谷歌Chrome是安全的，不允许用户从基于浏览器的脚本访问本地文件，但仍然存在潜在的安全风险。您可以通过创建一个新用户来执行浏览器本身来最小化这些风险。Google还默认启用沙盒模式，限制外部脚本访问本地环境。</p>
<p>下面是负责Google Chrome设置的Dockerfile示例:</p>
<pre class="language-dockerfile hljs"># Filename: Dockerfile

FROM node:slim

# We don't need the standalone Chromium
ENV PUPPETEER_SKIP_CHROMIUM_DOWNLOAD true

# Install Google Chrome Stable and fonts
# Note: this installs the necessary libs to make the browser work with Puppeteer.
RUN apt-get update &amp;&amp; apt-get install gnupg wget -y &amp;&amp; \
    wget --quiet --output-document=- https://dl-ssl.google.com/linux/linux_signing_key.pub | gpg --dearmor &gt; /etc/apt/trusted.gpg.d/google-archive.gpg &amp;&amp; \
    sh -c 'echo "deb [arch=amd64] http://dl.google.com/linux/chrome/deb/ stable main" &gt;&gt; /etc/apt/sources.list.d/google.list' &amp;&amp; \
    apt-get update &amp;&amp; \
    apt-get install google-chrome-stable -y --no-install-recommends &amp;&amp; \
    rm -rf /var/lib/apt/lists/*

# FROM public.ecr.aws/lambda/nodejs:14.2022.09.09.11
# Create working directory
WORKDIR /usr/src/app

# Copy package.json
COPY package.json ./

# Install NPM dependencies for function
RUN npm install

# Copy handler function and tsconfig
COPY server.js ./

# Expose app
EXPOSE 3000

# Run app
CMD ["node", "server.js"]
</pre>
<h3 id="dockerfile-steps">Dockerfile文件步骤的分解</h3>
<p>这个Docker文件创建了一个<a href="https://blog.logrocket.com/reduce-docker-image-sizes-using-multi-stage-builds/"> Docker映像</a>，它使用Headless Chrome运行Node.js服务器。以下是Dockerfile文件中不同步骤的分类:</p>
<ul>
<li><code>FROM node:slim</code>:指定Docker图像的基础图像。Node.js映像的<code>slim</code>变体是官方Node.js映像的一个较小版本，只包含基本的包</li>
<li><code>ENV PUPPETEER_SKIP_CHROMIUM_DOWNLOAD true</code>:设置一个环境变量，告诉木偶师跳过下载Chromium</li>
<li>下一个命令块安装Google Chrome Stable和必要的字体，使其能够与木偶师一起工作</li>
<li><code>WORKDIR /usr/src/app</code>:设置Docker图像的工作目录。Dockerfile文件中的其余文件和命令将在这里执行</li>
<li><code>COPY package.json ./</code>:将<code>package.json</code>文件复制到工作目录</li>
<li><code>RUN npm install</code>:安装<code>package.json</code>文件中列出的依赖项</li>
<li><code>COPY server.js ./</code>:将<code>server.js</code>文件复制到工作目录</li>
<li><code>EXPOSE 3000</code>:在Docker容器上暴露<code>port 3000</code>。这允许你从<code>port 3000</code>上的主机访问服务器</li>
<li><code>CMD ["node", "server.js"]</code>:通过用Node.js运行<code>server.js</code>脚本来启动服务器</li>
</ul>
<h3 id="building-docker-image">建立码头工人形象</h3>
<p>要构建并运行Docker映像，可以使用以下命令:</p>
<pre class="language-dockerfile hljs">docker build -t headless-chrome .
</pre>
<p><img data-attachment-id="156556" data-permalink="https://blog.logrocket.com/setting-headless-chrome-node-js-server-docker/attachment/building-docker-image-node-js/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/01/building-docker-image-node-js.png" data-orig-size="730,527" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Building a Docker image in Node.js" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/01/building-docker-image-node-js-300x217.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/01/building-docker-image-node-js.png" decoding="async" class="aligncenter size-full wp-image-156556 jetpack-lazy-image" src="../Images/b8c78af2b6126cd15965fe6a4286cea2.png" alt="Building a Docker Image in Node.js" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2020/01/building-docker-image-node-js.png 730w, https://blog.logrocket.com/wp-content/uploads/2020/01/building-docker-image-node-js-300x217.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2020/01/building-docker-image-node-js.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/01/building-docker-image-node-js.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="156556" data-permalink="https://blog.logrocket.com/setting-headless-chrome-node-js-server-docker/attachment/building-docker-image-node-js/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/01/building-docker-image-node-js.png" data-orig-size="730,527" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Building a Docker image in Node.js" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/01/building-docker-image-node-js-300x217.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/01/building-docker-image-node-js.png" decoding="async" loading="lazy" class="aligncenter size-full wp-image-156556" src="../Images/b8c78af2b6126cd15965fe6a4286cea2.png" alt="Building a Docker Image in Node.js" srcset="https://blog.logrocket.com/wp-content/uploads/2020/01/building-docker-image-node-js.png 730w, https://blog.logrocket.com/wp-content/uploads/2020/01/building-docker-image-node-js-300x217.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/01/building-docker-image-node-js.png"/></noscript>
<p>如果您遇到与平台相关的问题，例如，在macOS上运行它，您可以使用以下命令:</p>
<pre class="language-dockerfile hljs">docker build --platform linux/amd64 -t headless-chrome .
</pre>
<p>要运行构建的映像，请使用以下命令:</p>
<pre class="language-dockerfile hljs">docker run --rm -p 3000:3000 headless-chrome
</pre>
<p><img data-attachment-id="156567" data-permalink="https://blog.logrocket.com/setting-headless-chrome-node-js-server-docker/attachment/docker-image-running-2/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/01/docker-image-running-1.png" data-orig-size="730,33" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Running the built Docker image with Headless Chrome" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/01/docker-image-running-1-300x14.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/01/docker-image-running-1.png" decoding="async" class="aligncenter size-full wp-image-156567 jetpack-lazy-image" src="../Images/56e0ff5353393a91391995e3c048de1a.png" alt="Running the Built Docker Image With Headless Chrome" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2020/01/docker-image-running-1.png 730w, https://blog.logrocket.com/wp-content/uploads/2020/01/docker-image-running-1-300x14.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2020/01/docker-image-running-1.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/01/docker-image-running-1.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="156567" data-permalink="https://blog.logrocket.com/setting-headless-chrome-node-js-server-docker/attachment/docker-image-running-2/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/01/docker-image-running-1.png" data-orig-size="730,33" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Running the built Docker image with Headless Chrome" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/01/docker-image-running-1-300x14.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/01/docker-image-running-1.png" decoding="async" loading="lazy" class="aligncenter size-full wp-image-156567" src="../Images/56e0ff5353393a91391995e3c048de1a.png" alt="Running the Built Docker Image With Headless Chrome" srcset="https://blog.logrocket.com/wp-content/uploads/2020/01/docker-image-running-1.png 730w, https://blog.logrocket.com/wp-content/uploads/2020/01/docker-image-running-1-300x14.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/01/docker-image-running-1.png"/></noscript>
<p>这将构建Docker映像，并基于该映像运行一个新的容器。服务器将在<code>port 3000</code>启动并监听请求。您可以通过在网络浏览器中访问<code><a href="http://localhost:3000/">http://localhost:3000</a></code>从主机访问服务器。下面是它的样子:</p>
<p><img data-attachment-id="156560" data-permalink="https://blog.logrocket.com/setting-headless-chrome-node-js-server-docker/attachment/docker-image-running/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/01/docker-image-running.png" data-orig-size="730,446" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Example of a Docker image running Headless Chrome" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/01/docker-image-running-300x183.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/01/docker-image-running.png" decoding="async" class="aligncenter size-full wp-image-156560 jetpack-lazy-image" src="../Images/0c2ea77220b856654daea906acc43cd0.png" alt="Example of a Docker Image Running Headless Chrome" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2020/01/docker-image-running.png 730w, https://blog.logrocket.com/wp-content/uploads/2020/01/docker-image-running-300x183.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2020/01/docker-image-running.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/01/docker-image-running.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="156560" data-permalink="https://blog.logrocket.com/setting-headless-chrome-node-js-server-docker/attachment/docker-image-running/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/01/docker-image-running.png" data-orig-size="730,446" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Example of a Docker image running Headless Chrome" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/01/docker-image-running-300x183.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/01/docker-image-running.png" decoding="async" loading="lazy" class="aligncenter size-full wp-image-156560" src="../Images/0c2ea77220b856654daea906acc43cd0.png" alt="Example of a Docker Image Running Headless Chrome" srcset="https://blog.logrocket.com/wp-content/uploads/2020/01/docker-image-running.png 730w, https://blog.logrocket.com/wp-content/uploads/2020/01/docker-image-running-300x183.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/01/docker-image-running.png"/></noscript>
<p><img data-attachment-id="156570" data-permalink="https://blog.logrocket.com/setting-headless-chrome-node-js-server-docker/attachment/headless-chrome-node-js/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/01/headless-chrome-node-js.png" data-orig-size="730,74" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Docker container log showing where the screenshot was taken" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/01/headless-chrome-node-js-300x30.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/01/headless-chrome-node-js.png" decoding="async" class="aligncenter size-full wp-image-156570 jetpack-lazy-image" src="../Images/e0d22ad716c01f8081e4fa8afae83ce1.png" alt="Docker Container Log Showing Where the Screenshot was Taken" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2020/01/headless-chrome-node-js.png 730w, https://blog.logrocket.com/wp-content/uploads/2020/01/headless-chrome-node-js-300x30.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2020/01/headless-chrome-node-js.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/01/headless-chrome-node-js.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="156570" data-permalink="https://blog.logrocket.com/setting-headless-chrome-node-js-server-docker/attachment/headless-chrome-node-js/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/01/headless-chrome-node-js.png" data-orig-size="730,74" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Docker container log showing where the screenshot was taken" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/01/headless-chrome-node-js-300x30.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/01/headless-chrome-node-js.png" decoding="async" loading="lazy" class="aligncenter size-full wp-image-156570" src="../Images/e0d22ad716c01f8081e4fa8afae83ce1.png" alt="Docker Container Log Showing Where the Screenshot was Taken" srcset="https://blog.logrocket.com/wp-content/uploads/2020/01/headless-chrome-node-js.png 730w, https://blog.logrocket.com/wp-content/uploads/2020/01/headless-chrome-node-js-300x30.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/01/headless-chrome-node-js.png"/></noscript>
<p>正如在Docker容器日志中所看到的，您可以验证截图是否被拍摄。下面是一个视频，以更互动的方式展示了截图是如何拍摄的:</p>
<blockquote class="embedly-card" data-card-controls="1" data-card-align="center" data-card-theme="light">

<p>没有描述</p>
</blockquote>
<p>截图很有趣，但是还有无数其他的用例。幸运的是，上述过程几乎适用于所有人。在大多数情况下，只需要对Node.js代码进行微小的修改。其余的是非常标准的环境设置。</p>
<p>无头浏览器的常见问题</p>
<h2 id="common-problems-headless-chrome">谷歌Chrome在执行过程中会吃掉大量内存，所以无头Chrome在服务器端也是如此也就不足为奇了。如果您保持浏览器打开并多次重用同一个浏览器实例，您的服务最终会崩溃。</h2>
<p>最佳解决方案是遵循一个连接、一个浏览器实例的原则。虽然这比在每个浏览器上管理多个页面的成本更高，但坚持只使用一个页面和一个浏览器会让您的系统更加稳定。当然，这取决于个人偏好和您的特定用例。根据你独特的需求和目标，你可能会找到一个中间地带。</p>
<p>以性能监控工具的官方网站<a href="https://hexometer.com/"> Hexometer </a>为例。该环境包括一个包含数百个空闲浏览器池的远程浏览器服务。这些是为了在需要执行时通过WebSocket获取新连接而设计的，但它严格遵循一个页面、一个浏览器的原则。这使得它成为一种稳定而有效的方法，不仅可以让运行中的浏览器保持空闲，还可以让它们保持活跃。</p>
<p>通过WebSocket的Puppeteer连接非常稳定，你可以通过定制类似于<a href="https://www.browserless.io/"> browserless.io </a>的服务来做类似的事情(也有一个开源版本)。</p>
<p>这将使用相同的浏览器管理协议连接到Headless Chrome DevTools套接字:</p>
<p>结论</p>
<pre class="language-javascript hljs">// Filename: server.js
// ...
// ...

const browser = await puppeteer.launch({
    browserWSEndpoint: `ws://repo.treescale.com:6799`,
});

// ...
// ...
</pre>
<h2>在容器中运行浏览器提供了很大的灵活性和可伸缩性。它也比传统的基于虚拟机的实例便宜得多。现在，我们可以简单地使用AWS Fargate或<a href="https://blog.logrocket.com/how-to-deploy-a-node-api-on-google-cloud-run/"> Google Cloud Run </a>等容器服务，仅在需要时触发容器执行，并在几秒钟内扩展到数千个实例。</h2>
<p>最常见的用例仍然是用<a href="https://blog.logrocket.com/node-js-express-test-driven-development-jest/"> Jest </a>和<a href="https://blog.logrocket.com/testing-node-js-mocha-chai/"> Mocha </a>进行<a href="https://blog.logrocket.com/end-to-end-testing-react-apps-with-puppeteer-and-jest-ce2f414b4fd7/"> UI自动化测试</a>。但是如果你考虑到你实际上可以在一个容器中用Node.js操作一个完整的网页，那么用例就只受你想象力的限制了。</p>
<p>你可以找到这个<a href="https://github.com/m3rryqold/headless-chrome-nodejs-docker"> GitHub库</a>中使用的源代码。</p>
<p>200只<img src="../Images/61167b9d027ca73ed5aaf59a9ec31267.png" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2019/10/green-check.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" class=" jetpack-lazy-image" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/10/green-check.png"/> <noscript> <img data-lazy-fallback="1" src="../Images/61167b9d027ca73ed5aaf59a9ec31267.png" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/10/green-check.png"/> </noscript>显示器出现故障，生产中网络请求缓慢</p><div class="code-block code-block-23">
<div class="blog-plug inline-plug node-plug"><h2>部署基于节点的web应用程序或网站是容易的部分。确保您的节点实例继续为您的应用程序提供资源是事情变得更加困难的地方。如果您对确保对后端或第三方服务的请求成功感兴趣，</h2><p>. </p><a href="https://lp.logrocket.com/blg/node-signup" target="_blank">try LogRocket</a><p>LogRocket 就像是网络和移动应用程序的DVR，记录下用户与你的应用程序交互时发生的一切。您可以汇总并报告有问题的网络请求，以快速了解根本原因，而不是猜测问题发生的原因。</p><a class="signup" href="https://lp.logrocket.com/blg/node-signup" target="_blank" rel="noopener noreferrer"><img src="../Images/cae72fd2a54c5f02a6398c4867894844.png" alt="LogRocket Network Request Monitoring" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2019/12/network-request-filter-2-1.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" class=" jetpack-lazy-image" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/12/network-request-filter-2-1.png"/><noscript><img data-lazy-fallback="1" src="../Images/cae72fd2a54c5f02a6398c4867894844.png" alt="LogRocket Network Request Monitoring" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/12/network-request-filter-2-1.png"/></noscript></a><a href="https://lp.logrocket.com/blg/node-signup" target="_blank" rel="noopener noreferrer">https://logrocket.com/signup/</a><p>LogRocket检测您的应用程序以记录基线性能计时，如页面加载时间、到达第一个字节的时间、慢速网络请求，还记录Redux、NgRx和Vuex操作/状态。</p><p>. </p><a class="signup" href="https://lp.logrocket.com/blg/node-signup" target="_blank" rel="noopener noreferrer">Start monitoring for free</a><p>. </p></div>
</div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
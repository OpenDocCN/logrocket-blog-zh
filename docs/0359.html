<html>
<head>
<title>Exploring urql from an Apollo perspective - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>从阿波罗视角探索urql</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/exploring-urql-from-an-apollo-perspective/#0001-01-01">https://blog.logrocket.com/exploring-urql-from-an-apollo-perspective/#0001-01-01</a></blockquote><div><article class="article-post">
<p>我已经与GraphQL合作了一年多，主要是与北欧的视频点播(SVOD)服务C More合作，客户数据由GraphQL提供。我们一直在web客户端上使用react-apollo，最近看到GraphQL库urql弹出来激起了我的兴趣，特别是它与apollo相比如何。</p>
<p>urql代表Universal React Query Language，每周有约2500次下载，截至2019年7月，apollo的下载量约为50万次。虽然它还没有太多的用途，但这个项目有一些诱人的方面。稍后会有更多的内容——首先，我想花点时间思考一下为什么图书馆可能是一个好主意。</p>
<h2>什么是GraphQL，为什么我们需要一个库？</h2>
<p>GraphQL是一种查询语言，在这种语言中，客户机向服务器请求它所需要的东西——不多也不少。您可以把它看作是发送一个包含JSON对象的所有键的字符串，服务器应该为您填充这些键。查询可能是这样的:</p>
<pre>query {
  series(id: 3446) {
    title
    year
    suggestedEpisode {
      title
      episodeNumber
    }
  }
}
</pre>
<p>它会返回:</p>
<pre>{
  "data": {
    "series": {
      "title": "Game of Thrones",
      "year": 2019,
      "suggestedEpisode": {
        "title": "Winterfell",
        "episodeNumber": 1
      }
    }
  }
}
</pre>
<p>GraphQL有三种不同的操作类型:查询、变异和订阅。查询用于请求数据，突变用于改变数据，订阅用于实时数据。由于我在订阅方面的经验有限，所以我不会对urql如何处理它做出判断，而是专注于更常见的操作:查询和变异。</p>
<p>GraphQL查询和变异通常在HTTP上使用，并经常通过<code>POST</code>请求发送(通常也支持<code>GET</code>)。GraphQL查询通常与任何变量一起在请求正文中发送。</p>
<p>那么为什么你需要一个库来做这件事呢？要做简单的事情，你不需要——你可以做简单的<code>fetch</code>呼叫，它会工作得很好。如果我从一个<a href="https://blog.logrocket.com/design-patterns-in-node-js-2/" target="_blank" rel="noopener noreferrer">节点</a>服务器或者从一个有一些(很少被调用)GraphQL请求的简单模块调用它，这是我使用GraphQL的首选方式。我觉得它作为真正简单用例的替代方案经常被忽视。</p>
<p>那么图书馆给了我们什么呢？GraphQL对所有数据使用类型系统，这为一些客户端缓存提供了可能性。缓存，以及一些关于数据获取的实用工具，是一个库可以节省你很多时间的地方。因此，让我们来看看urql如何为我们节省时间。</p>
<h2>使用urql</h2>
<p>正如我前面提到的，urql是React的一个轻量级、可扩展的GraphQL客户端。它存在的全部原因是使客户端的GraphQL尽可能简单，正如在<a href="https://github.com/FormidableLabs/urql/commit/b97d64ab7ffabe5be7439135282553151c3585ea#diff-04c6e90faac2675aa89e2176d2eec7d8" target="_blank" rel="noopener noreferrer">初始提交</a>中看到的。这立即反映在安装中；你只要输入<code>npm install urql graphql</code>。</p>
<p>然后你做一些小的设置:</p>
<pre><strong>import</strong> { Provider, createClient } <strong>from</strong> "urql"

<strong>const</strong> client = createClient({
  url: "http://localhost:1234/graphql",
  <em>// you can also add more customizations here,
  // such as setting up an authorization header.

  // Advanced customizations are called "Exchanges",
  // and also go here if you need more advanced stuff.</em>
})

ReactDOM.render(
  &lt;Provider value={client}&gt;
    &lt;YourApp /&gt;
  &lt;/Provider&gt;,
  document.body
)
</pre>
<p>现在您已经准备好在您的组件中使用urql了！</p>
<h3>提出疑问</h3>
<p>urql支持组件API和钩子API。组件API基于渲染道具，由一个<code>&lt;Query&gt;</code>、一个<code>&lt;Mutation&gt;</code>和一个<code>&lt;Subscription&gt;</code>组件组成。最基本的情况是这样的:</p>
<pre><strong>function RenderPropVersion</strong>() {
  <strong>return</strong> (
    &lt;Query
      query={`{
        # 4711 would normally be passed as a variable
        # (in all the following examples too, not just this one)
        movie(id: 4711) {
          title
          isInFavoriteList
          year
        }   
      }`}
    &gt;
      {({ fetching, data }) =&gt;
        fetching ? (
          &lt;div className="loader"&gt;Loading..&lt;/div&gt;
        ) : (
          &lt;div className="json"&gt;
            {JSON.stringify(
              data,
              null,
              2
            ) /* The (_, null, 2) makes JSON.stringify pretty. */}
          &lt;/div&gt;
        )
      }
    &lt;/Query&gt;
  )
}
</pre>
<p>钩子API由<code>useQuery</code>、<code>useMutation</code>和<code>useSubscription</code>钩子组成，我们上面的组件看起来和钩子一样:</p>
<pre><strong>function HookVersion</strong>() {
  <strong>const</strong> [result] = useQuery({
    query: `{
      movie(id: 4711) {
        title
        isInFavoriteList
        year
      } 
    }`,
  })
  <strong>const</strong> { fetching, data } = result
  <strong>return</strong> fetching ? (
    &lt;div className="loader"&gt;Loading..&lt;/div&gt;
  ) : (
    &lt;div className="json"&gt;{JSON.stringify(data, null, 2)}&lt;/div&gt;
  )
}
</pre>
<p>注意钩子版本是如何少了一个缩进层次的。作为曾经用Apollo编写过三层组件的人，我只想说我喜欢这样。在接下来的突变部分，您会很高兴Hooks API的存在。</p>
<p>当React呈现一个urql <code>&lt;Query&gt;</code>或<code>useQuery</code>时，urql会查看查询和任何变量，并检查是否缓存了该查询的结果。在这种情况下，结果会立即呈现。否则，它发送一个请求来填充缓存(这个行为可以用<code>requestPolicy</code>属性/参数来修改)。</p>
<h3>urql缓存</h3>
<p>因为从GraphQL库获得的主要好处是缓存，所以我认为对您选择的库如何为您处理缓存有一个合适的心理模型是很重要的。</p>
<p>在urql中，查询的结果被精确的查询缓存(甚至字段的顺序也很重要！)以及映射到该查询结果的任何变量。没有奇迹发生——从输入到输出是一个<code>Map</code>。</p>
<p>当数据因突变而改变时，缓存失效。当urql从GraphQL服务器获得变异响应时，urql会查看响应中存在哪些类型。任何包含这些类型的缓存数据都将失效，任何缓存失效的当前呈现的查询都将重新提取。</p>
<p>没有对缓存的手动访问。缓存是在后台完成的，这一切都是为了方便用户。</p>
<h3>变异数据</h3>
<p>如果您熟悉查询数据，从API的角度来看，使用urql改变数据是非常简单的。上面的Hooks版本添加了两个变体，看起来像这样:</p>
<pre><strong>function HookVersion</strong>() {
  <strong>const</strong> [result] = useQuery({
    query: `{
      movie(id: 4711) {
        title
        isInFavoriteList
        year
      } 
    }`,
  })

  <em>// Mutations added here! (imagine if this was render props 😰)</em>
  <strong>const</strong> [addFavoriteResult, addFavorite] = useMutation(`mutation {
    addMovieToFavoriteList(id: 4711) {
      title
    }
  }`)
  <strong>const</strong> [removeFavoriteResult, removeFavorite] = useMutation(`mutation {
    removeMovieFromFavoriteList(id: 4711) {
      title
    }
  }`)

  <strong>const</strong> { fetching, data } = result

  <em>// &lt;button&gt; added in render</em>
  <strong>return</strong> fetching ? (
    &lt;div className="loader"&gt;Loading..&lt;/div&gt;
  ) : (
    &lt;&gt;
      &lt;button
        onClick={() =&gt; {
          if (data.movie.isInFavoriteList) {
            removeFavorite()
          } else {
            addFavorite()
          }
        }}
      &gt;
        {data.movie.isInFavoriteList ? "Remove favorite" : "Add favorite"}
      &lt;/button&gt;
      &lt;div className="json"&gt;{JSON.stringify(data, null, 2)}&lt;/div&gt;
    &lt;/&gt;
  )
}
</pre>
<p>请记住，缓存的失效是基于变异响应中包含的类型。作为一名urql用户，这意味着您必须考虑GraphQL服务器返回的内容。</p>
<p>想象一下，如果<code>removeMovieFromFavoriteList</code>突变返回所有标记为喜爱的电影的完整列表。这似乎不是太不合逻辑，因为你<em>是</em>有效地改变了最喜欢的电影列表。然而，这被证明是一个坏主意。</p>
<p>这是一个坏主意的原因是它会导致一个错误！下面的场景说明了可能发生的错误:用户删除了收藏列表中的最后一项，因此用户不再有任何标记为收藏的电影。变异响应(收藏夹列表)将是一个空数组。</p>
<p>空数组不包含任何类型。这意味着urql不会使正确的查询缓存失效，数据也不会与服务器同步。</p>
<p>也就是说，无论使用什么库，返回GraphQL查询中实际发生变化的内容总是一个好主意。从上面的例子中，Apollo也会得到一个陈旧的缓存。</p>
<p>在这种情况下，更好的反应是我们标记为最喜欢的电影。这样，响应将总是包含类型，urql可以使正确的缓存无效。</p>
<h2>urql和Apollo的区别</h2>
<p>阿波罗可能是当今最著名和最受欢迎的GraphQL库，也是我所知最多的库。因此，继续进行简单的比较似乎是合乎逻辑的。</p>
<h3>哲学</h3>
<p>urql只有一个包，相比之下，react-apollo需要五个以上的包(然而，你可以使用<a href="https://github.com/apollographql/apollo-client/tree/master/packages/apollo-boost"> apollo-boost </a>，它给你一个与urql相似的设置体验)。</p>
<p>库的文件大小也不同:apollo-boost + react-apollo的文件大小为91kB + 35kB，而urql的文件大小为21.5kB(缩小，通过<a href="https://bundlephobia.com/"> BundlePhobia </a>检查)。这些不同的事实反映了他们的指导思想和目标。</p>
<p>urql是轻量级和可扩展的，信任开源社区来解决利基问题，如<a href="https://github.com/FormidableLabs/urql/issues/196">持久化查询</a>，这是一种请求大小优化，其中GraphQL查询存储在服务器上，并且只发送一个哈希。Apollo是一家公司，感觉他们希望自己有一个解决每个问题的方案。</p>
<p>两者都是有效的哲学，但是当你选择你的图书馆的时候考虑一下是有价值的。</p><div class="code-block code-block-54">
<hr/>
<h3>更多来自LogRocket的精彩文章:</h3>

<hr/></div>
<h3>应用程序接口</h3>
<p>在评估API时，它们看起来非常相似。创建一个连接到您的端点的客户机，将它挂接到一个<code>&lt;Provider&gt;</code>，并在您的组件中使用查询、变异和订阅。</p>
<p>两个库都公开了<code>&lt;Query&gt;</code>、<code>&lt;Mutation&gt;</code>和<code>&lt;Subscription&gt;</code>渲染道具组件来与您的API一起工作。urql还支持<code>useQuery</code>、<code>useMutation</code>和<code>useSubscription</code>挂钩。Apollo也创建了一个Hooks API，但是还没有文档化。</p>
<p>目前，React悬念还没有发布，但我们可以确定两个库都将支持它。API是否不同，或者仅仅是移除了<code>fetching</code>状态，还有待观察。</p>
<p>Apollo有很多urql没有的API。例如，Apollo允许您直接访问缓存。如果您使用的GraphQL模式不返回缓存失效所需的类型，这将非常有用。</p>
<p>您可以在urql中通过(ab)使用<code>requestPolicy</code>参数/prop来解决此类问题，但我认为在Apollo中使用此类模式更好。</p>
<h3>贮藏</h3>
<p>缓存可能是Apollo和urql最大的不同之处。Apollo对其缓存进行了规范化，这意味着从GraphQL返回的每一项都按照其<code>id</code>和类型进行缓存。这个组合是一个不错的启发，因为你不能只通过<code>id</code>缓存(一个<code>User</code>和<code>Movie</code>可能有相同的<code>id</code>)。Apollo还在查询级别进行缓存——如果您对缓存的外观感兴趣，我建议您下载Apollo devtools，在那里您可以检查缓存。</p>
<p>规范化缓存意味着，如果两个不同的查询在同一个页面上有相同的条目，改变其中一个就会改变另一个；它们都是从规范化缓存中呈现的。</p>
<p>然而，Apollo的缓存有一个缺点。想象一下，我们正在显示一个标记为喜爱的电影列表，以及另一个电影列表(新发布的或类似的)，其中每部电影都有一个<strong>标记为喜爱的</strong>按钮，其当前的喜爱状态(是的，现在是一个词)在每部电影上可见。</p>
<p>如果我们点击那个按钮，电影改变了它的受欢迎状态，GraphQL服务器将返回更新的<code>Movie</code>和更新的<code>isInFavoriteList</code>字段。这将更新<code>Movie</code>的偏好状态，但该电影不会出现在您最喜欢的电影列表中，因为更新的列表不是响应的一部分。</p>
<p>使用urql的缓存策略就不会出现这个问题。正如我前面说过的，urql的缓存方法更简单:它在查询级别缓存，而不是每个单独的项。为了确保缓存在突变后不会过时，它只是清除所有查询的缓存，这些查询返回一些与突变返回的类型相同的项。</p>
<p>urql缓存方法可能适用于某些站点，但不适用于其他站点。比如C More(北欧的流媒体服务，还记得吗？)要清除所有<code>Movie</code>项的缓存，如果你在单个<code>Movie</code>上使用了突变<code>addMovieToFavoriteList</code>或<code>markAsSeen</code>，基本上会清空整个缓存。</p>
<h2>结论</h2>
<p>说实话，看到urql和Apollo如此相似，我很惊讶。urql更简单，但是缺少一些现成的特性，比如持久化查询。urql在从缓存中删除内容方面也相当自由，所以如果您有一个突变多、数据类型少的应用程序，urql缓存策略可能并不适合您。</p>
<p>然而，由于Apollo和urql APIs如此相似，从urql更改为Apollo应该不会非常复杂。如果当您遇到需要规范化缓存或持久化查询等特性的问题时，您可以进行重写，而不会花费太多成本。</p>
<p>因此，如果您正在寻找一个简单的库来帮助您使用GraphQL，我绝对推荐您尝试一下urql。</p><div class="code-block code-block-17">
<div class="blog-plug inline-plug react-plug" vwo-el-id="26283398190">
<h2 vwo-el-id="41600691720">使用LogRocket消除传统反应错误报告的噪音</h2>
<a href="https://lp.logrocket.com/blg/react-signup-issue-free" target="_blank" vwo-el-id="19356441070">LogRocket
</a><p>是一款React analytics解决方案，可保护您免受数百个误报错误警报的影响，只针对少数真正重要的项目。LogRocket告诉您React应用程序中实际影响用户的最具影响力的bug和UX问题。</p><a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="19356441380">
<img class="first-react-image alignnone size-full wp-image-46 jetpack-lazy-image jetpack-lazy-image--handled" src="../Images/f300c244a1a1cf916df8b4cb02bec6c6.png" vwo-el-id="18272717540" data-lazy-loaded="1" data-original-src="https://files.readme.io/27c94e7-Image_2017-06-05_at_9.46.04_PM.png"/>
</a>
<a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="19356441690">
<img class="second-react-image alignnone size-full wp-image-46 jetpack-lazy-image jetpack-lazy-image--handled" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" vwo-el-id="30720362350" data-lazy-loaded="1" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/>
</a>
<a href="https://lp.logrocket.com/blg/react-signup-issue-free" target="_blank" rel="noopener noreferrer" vwo-el-id="35866400580">LogRocket
</a><p>自动聚合客户端错误、反应错误边界、还原状态、缓慢的组件加载时间、JS异常、前端性能指标和用户交互。然后，LogRocket使用机器学习来通知您影响大多数用户的最具影响力的问题，并提供您修复它所需的上下文。</p><p vwo-el-id="28675661060">关注重要的React bug—<a class="signup" href="https://lp.logrocket.com/blg/react-signup-issue-free" target="_blank" rel="noopener noreferrer" vwo-el-id="40093418840">今天就试试LogRocket】。</a></p>
</div></div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
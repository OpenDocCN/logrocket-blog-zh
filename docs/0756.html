<html>
<head>
<title>Application state management with Svelte - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>使用svelet-log rocket博客进行应用状态管理</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/application-state-management-svelte/#0001-01-01">https://blog.logrocket.com/application-state-management-svelte/#0001-01-01</a></blockquote><div><article class="article-post">
<p><em> <strong>编者按</strong>:这篇文章的最后一次准确性验证是在2022年11月16日。</em></p>
<p>在早期的JavaScript框架中，比如Angular，通常将应用程序中的所有状态嵌入到路由、服务、控制器、本地存储和会话存储中。然而，随着应用程序变得越来越大，跟踪什么存储在哪里变得越来越困难。</p>
<p>改进的形式是像Redux和Vuex这样的状态管理库。像Svelte这样的新框架采用了更简单的状态管理方法，不需要安装库，而是提供管理框架内状态的存储。在本文中，我们将探索Svelte如何管理和处理应用程序中的状态。</p>
<p>目录</p>
<h2 id="tableofcontents">瘦上下文API</h2>

<h2 id="context-svelte">Svelte的上下文API非常适合跨组件通信，而不必通过传递道具来使您的代码库变得复杂。<a href="https://svelte.dev/tutorial/context-api">上下文API </a>由两个内置的瘦函数<code>getContext</code>和<code>setContext</code>启用。通过在上下文中设置对象或值并将其与一个键相关联，您可以使其在应用程序中的任何位置可用，如下面的代码示例所示:</h2>
<p>要使<code>thisKey</code>在应用程序的不同组件中可用，只需使用<code>getContext</code>函数导入它:</p>
<pre>&lt;script&gt;
  import { setContext } from 'svelte'

  const thisObject = {}

  setContext('thisKey', thisObject)
&lt;/script&gt;
</pre>
<p>请记住，您只能使用<code>getContext</code>来检索使用了<code>setContext</code>的组件或同一组件树中的组件的键。为了在不同树中的两个组件之间传递属性和值，Svelte使用了<a href="https://svelte.dev/docs#svelte_store">存储</a>。</p>
<pre>&lt;script&gt;
  import { getContext } from 'svelte'

  const thisObject = getContext('thisKey')
&lt;/script&gt;
</pre>
<p>与苗条商店合作</p>
<h2 id="working-svelte-stores">随着应用程序规模的增加，它的复杂性也会增加。此时，在应用程序的组件层次结构中嵌套应用程序状态的某些部分并不是一个好主意；您将拥有一些需要由不同组件访问的属性。</h2>
<p>Svelte通过stores处理这种类型的属性，stores是保存一个值的对象，当值改变时可以通知您。Svelte有两种存储来处理应用程序中的状态，<code>writable</code>和<code>readable</code>存储。</p>
<p>可写商店</p>
<h3 id="writable-stores"><a href="https://svelte.dev/docs#writable">可写存储</a>是保存值或属性的对象，可由应用程序中的不同组件访问。让我们使用可写存储来保存一个值，然后我们可以在我们的应用程序中修改或传递这个值。要访问这个值，您可以从存储中导出它，并将其保存为一个JavaScript文件:</h3>
<p>然后，您可以将它导入到需要它的任何其他组件中，如下所示:</p>
<pre>&lt;!-- location.js --&gt;
&lt;script&gt;
  import writable from 'svelte/store'

  export const city = writable('New York')
&lt;/script&gt;
</pre>
<p>可写存储器中的值可以改变。如果您需要在导入的任何组件中更改<code>city</code>的值，您可以使用<code>set()</code>方法:</p>
<pre>&lt;scipt&gt;
  import { city } from './location.js'
&lt;/script&gt;
</pre>
<p>或者，您可以使用<code>update()</code>方法运行回调，将当前值作为参数传递:</p>
<pre>&lt;!-- Map.svelte --&gt;

&lt;script&gt;
  import { city } from './location.js'

  city.set('Washington')

&lt;/script&gt;
</pre>
<p>或者，您可以使用Svelte的<code>subscribe()</code>方法让组件监视您在商店中设置的值的变化:</p>
<pre>&lt;!-- Map.svelte --&gt;

&lt;script&gt;
  import { city } from './location.js'

  const newCity = 'Washington'

  function changeCity() {
    city.update(existing =&gt; newCity)
  }

&lt;/script&gt;
</pre>
<p>可读存储</p>
<pre>&lt;!-- Map.svelte --&gt;

&lt;script&gt;
  import { city } from './location.js'

  const watch = city.subscribe(value =&gt; {
    console.log(value);
  });
&lt;/script&gt;
</pre>
<h3 id="readable-stores">像可写存储一样，可读存储保存对象，但是不能从外部组件更新它们。使用可读存储时，您必须在创建它时设置它的值。可读存储主要用于处理需要不可变的数据。下面是一个使用可读存储和计数器来处理的示例:</h3>
<p>然后可以将上面的计数器导入到另一个组件中，如下所示:</p>
<pre>&lt;!-- counter.js --&gt;

&lt;script&gt;
  import { readable } from 'svelte/store'

  export const counter = readable(0, set =&gt; {
    setTimeout(() =&gt; {
     set(1)
    }, 1000)
  })
&lt;/script&gt;
</pre>
<p>用苗条的商店建立数据集</p>
<pre>&lt;!-- Home.svelte--&gt;

&lt;script&gt;
  import { counter } from './store.js'
&lt;/script&gt;

&lt;h1&gt;You have {$counter} seconds left!&lt;h1&gt;
</pre>
<h2 id="building-datasets-svelte-stores">让我们建立一个真正的应用程序，在那里我们将管理苗条的状态。我们的应用程序将只是一个基本的更新列表。首先，<a href="https://blog.logrocket.com/how-to-build-simple-svelte-js-app/">我们将创建一个苗条的项目</a>。在您的终端中，输入以下命令:</h2>
<p>然后，导航到项目目录并安装该项目的所有依赖项:</p>
<pre>npm create <a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="47312e3322072b2633223433">[email protected]</a> dealership-svelte -- --template svelte
</pre>
<p>完整的应用程序应具有类似如下的文件夹结构:</p>
<pre>npm install
</pre>
<p><img data-attachment-id="144183" data-permalink="https://blog.logrocket.com/svelte-folder-structure/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/11/svelte-folder-structure.png" data-orig-size="235,283" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="svelte-folder-structure" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/11/svelte-folder-structure.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/11/svelte-folder-structure.png" decoding="async" class="aligncenter wp-image-144183 size-full jetpack-lazy-image" src="../Images/88f7d6832b5c4a78fc3316d41c84cdb9.png" alt="Svelte Folder Structure" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2022/11/svelte-folder-structure.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/11/svelte-folder-structure.png"/></p>
<p>一旦应用程序构建完成，在您的终端上运行<code>npm run dev</code>来部署它。这将在端口<code>localhost:5000</code>上部署应用程序。</p><noscript><img data-lazy-fallback="1" data-attachment-id="144183" data-permalink="https://blog.logrocket.com/svelte-folder-structure/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/11/svelte-folder-structure.png" data-orig-size="235,283" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="svelte-folder-structure" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/11/svelte-folder-structure.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/11/svelte-folder-structure.png" decoding="async" loading="lazy" class="aligncenter wp-image-144183 size-full" src="../Images/88f7d6832b5c4a78fc3316d41c84cdb9.png" alt="Svelte Folder Structure" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/11/svelte-folder-structure.png"/></noscript>
<p>建一个苗条的商店</p>
<h2 id="build-store">在我们项目的<code>src</code>文件夹中，让我们创建一个<code>store</code>文件夹，我们将使用它来保存我们的商店。接下来，我们将创建一个文件来包含我们需要存储的内容，定义更新存储值的方法，并将它们重置为默认值。我们将这个文件称为<code>cars.js</code>:</h2>
<p>您现在可以将导出的方法<code>subscribe</code>、<code>addCar</code>和<code>reset</code>导入到任何组件中，并分别使用它们来订阅、添加新值和重置我们的汽车列表。</p>
<pre> // src/store/cars.js

 import { writable } from 'svelte/store';

 const CARS = [
     { make: "Ford", model: "Taurus", year: "2015" },
     { make: "Toyota", model: "Avalon", year: "2013" }
 ];

 const { subscribe, set, update } = writable(CARS);

 const addCar = car =&gt; update(cars =&gt; {
     return [...cars, car];
 });

 const reset = () =&gt; {
     set(CARS);
 };

 export default {
     subscribe,
     addCar,
     reset
 }
</pre>
<p>创建组件</p>
<h2 id="creating-components">接下来，我们将创建接收从我们的存储中导出的方法的组件。我们将创建两个组件，<code>CarPage</code>，当我们想要添加一辆新车时将使用它，和<code>CarList</code>，它将显示添加的汽车列表。<code>CarPage</code>将更新所有添加的汽车并自动响应变化:</h2>
<p>接下来，我们将创建<code>CarList</code>，这是一个允许我们相应地更新和删除车辆的表单:</p>
<pre>&lt;!-- src/CarPage.svelte --&gt;
&lt;script&gt;
        import cars from "./store/cars";
&lt;/script&gt;

&lt;div id="carPage"&gt;
        { #each $cars as car }
                &lt;p&gt;{car.make} {car.model}&lt;/p&gt;
                &lt;p&gt;{car.year}&lt;/p&gt;
                &lt;hr /&gt;
        { /each }
&lt;/div&gt;
</pre>
<p>最后，我们将把<code>CarList</code>和<code>CarPage</code>导入到<code>App.svelte</code>中:</p>
<pre>&lt;!-- src/CarList.svelte --&gt;
&lt;script&gt;
        import cars from "./store/cars";

        // binding values
        let make = "";
        let model = "";
        let year = "";

        // submit car
        const submitCar = () =&gt; {
                cars.addCar({ make, model, year });
                // reset values
                make = model = year = "";
        }
&lt;/script&gt;

&lt;div id="carList"&gt;
    &lt;input type="text"  bind:value={make} placeholder="Enter vehicle make" /&gt;
    &lt;input type="text"  bind:value={model} placeholder="Enter vehicle model" /&gt;
    &lt;input type="year" bind:value={year} placeholder="Enter vehicle year" /&gt;
    &lt;input type="submit" on:click={submitCar} value="Include Vehicle" /&gt;
    &lt;input type="submit" on:click={cars.reset} value="Reset Vehicle list" /&gt;
&lt;/div&gt;
</pre>
<p>Lastly, we’ll import both <code>CarList</code> and <code>CarPage</code> into <code>App.svelte</code>:</p>
<p>此时，我们将有一个应用程序显示使用Svelte管理状态的基本原理。我们的应用程序的行为应该模仿下面视频中的行为:</p>
<pre>&lt;!-- src/App.svelte--&gt;

&lt;script&gt;
    import CarList from "./CarList.svelte";
    import CarPage from "./CarPage.svelte";
&lt;/script&gt;
&lt;main&gt;
    &lt;h1&gt;Car Dealership&lt;/h1&gt;
    &lt;CarList /&gt;
    &lt;CarPage /&gt;
&lt;/main&gt;
</pre>
<p><span class="embed-youtube"> <iframe loading="lazy" class="youtube-player" src="https://www.youtube.com/embed/xCP013FPmDE?version=3&amp;rel=1&amp;showsearch=0&amp;showinfo=1&amp;iv_load_policy=1&amp;fs=1&amp;hl=en-US&amp;autohide=2&amp;wmode=transparent" allowfullscreen="true" sandbox="allow-scripts allow-same-origin allow-popups allow-presentation">视频</iframe> </span></p>
<p>结论</p>
<h2 id="conclusion"><a href="https://blog.logrocket.com/svelte-vs-vue-comparing-framework-internals/#reactivity"> Svelte的适应性使其成为构建需要管理状态的小规模应用的绝佳选择</a>。它提供的可定制商店非常棒，可以让你通过商店隔离偏好。当然，随着GitHub上<a href="https://github.com/sveltejs/svelte">苗条报告</a>的更多贡献者，我们应该会看到更多有前途的功能和改变。</h2>
<p><a href="https://blog.logrocket.com/svelte-vs-vue-comparing-framework-internals/#reactivity">Svelte’s adaptability makes it a great choice</a> for building small scale apps that require you to manage state. Its offering of customizable stores to choose from is brilliant, allowing you to isolate preferences via stores. Certainly, we should see more promising features and alterations on this with more contributors to the <a href="https://github.com/sveltejs/svelte">Svelte repo</a> on GitHub.</p>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
<html>
<head>
<title>A beginner’s guide to redux-observable - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>redux-observable - LogRocket博客初学者指南</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/a-beginners-guide-to-redux-observable-c0381da8ed3a/#0001-01-01">https://blog.logrocket.com/a-beginners-guide-to-redux-observable-c0381da8ed3a/#0001-01-01</a></blockquote><div><article class="article-post">
<figure class="graf graf--figure"><img decoding="async" class="graf-image jetpack-lazy-image" src="../Images/fa0c18a6bfca2f1c760e758bd80403db.png" data-image-id="1*YWr-aGD5v0_Ca6YyDAlF2A.png" data-width="1506" data-height="1254" data-lazy-src="https://cdn-images-1.medium.com/max/1600/1*YWr-aGD5v0_Ca6YyDAlF2A.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://cdn-images-1.medium.com/max/1600/1*YWr-aGD5v0_Ca6YyDAlF2A.png"/><noscript><img data-lazy-fallback="1" decoding="async" class="graf-image" src="../Images/fa0c18a6bfca2f1c760e758bd80403db.png" data-image-id="1*YWr-aGD5v0_Ca6YyDAlF2A.png" data-width="1506" data-height="1254" data-original-src="https://cdn-images-1.medium.com/max/1600/1*YWr-aGD5v0_Ca6YyDAlF2A.png"/></noscript></figure>
<p class="graf graf--p"><a class="markup--anchor markup--p-anchor" href="https://www.npmjs.com/package/redux-observable" target="_blank" rel="noopener noreferrer" data-href="https://www.npmjs.com/package/redux-observable"> Redux-Observable </a>是一个<a class="markup--anchor markup--p-anchor" href="https://www.codementor.io/vkarpov/beginner-s-guide-to-redux-middleware-du107uyud" target="_blank" rel="noopener noreferrer" data-href="https://www.codementor.io/vkarpov/beginner-s-guide-to-redux-middleware-du107uyud"> Redux中间件</a>，它允许你使用<a class="markup--anchor markup--p-anchor" href="https://www.npmjs.com/package/rxjs" target="_blank" rel="noopener noreferrer" data-href="https://www.npmjs.com/package/rxjs"> RxJS操作符</a>过滤和映射动作。像<code><a class="markup--anchor markup--p-anchor" href="https://www.learnrxjs.io/operators/filtering/filter.html" target="_blank" rel="noopener noreferrer" data-href="https://www.learnrxjs.io/operators/filtering/filter.html">filter()</a></code>和<code><a class="markup--anchor markup--p-anchor" href="https://www.learnrxjs.io/operators/transformation/map.html" target="_blank" rel="noopener noreferrer" data-href="https://www.learnrxjs.io/operators/transformation/map.html">map()</a></code>这样的RxJS操作符让你转换动作流，就像<a class="markup--anchor markup--p-anchor" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter" target="_blank" rel="noopener noreferrer" data-href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter"> JavaScript的</a> <code><a class="markup--anchor markup--p-anchor" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter" target="_blank" rel="noopener noreferrer" data-href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter">Array.prototype.filter()</a></code>让你转换数组一样。</p>
<p class="graf graf--p">在本文中，我将向您展示如何使用可以从Node.js运行的脚本开始使用redux-observable。</p>
<h3 class="graf graf--h3">你的第一部史诗</h3>
<p class="graf graf--p">在redux-observable中，一个<a class="markup--anchor markup--p-anchor" href="https://redux-observable.js.org/docs/basics/Epics.html" target="_blank" rel="noopener noreferrer" data-href="https://redux-observable.js.org/docs/basics/Epics.html"> " <strong class="markup--strong markup--p-strong">史诗</strong> " </a>是一个接受动作流并返回修改后的动作流的函数。你可以把epic看作是redux-observable应该调度的附加动作的描述。史诗的概念类似于redux-saga 中的<a class="markup--anchor markup--p-anchor" href="http://thecodebarbarian.com/redux-saga-vs-async-await.html" target="_blank" rel="noopener noreferrer" data-href="http://thecodebarbarian.com/redux-saga-vs-async-await.html">【传奇】。</a></p>
<p class="graf graf--p">在你写第一部史诗之前，你需要<a class="markup--anchor markup--p-anchor" href="https://www.npmjs.com/package/redux-observable#install" target="_blank" rel="noopener noreferrer" data-href="https://www.npmjs.com/package/redux-observable#install">安装redux-observable </a>。本文假设您已经安装了Node.js和npm。要安装redux-observable以及<a class="markup--anchor markup--p-anchor" href="https://www.npmjs.com/package/redux" target="_blank" rel="noopener noreferrer" data-href="https://www.npmjs.com/package/redux"> redux </a>和RxJS，运行以下命令:</p>
<pre>install <a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="1e6c7b7a6b665e2a3066">[email protected]</a> <a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="0173646574792c6e637264737760636d6441302f79">[email protected]</a> <a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="85f7fdeff6c5b3abfd">[email protected]</a></pre>
<p class="graf graf--p">redux-observable API中最基本的函数是<code><a class="markup--anchor markup--p-anchor" href="https://redux-observable.js.org/docs/api/createEpicMiddleware.html" target="_blank" rel="noopener noreferrer" data-href="https://redux-observable.js.org/docs/api/createEpicMiddleware.html">createEpicMiddleware()</a></code> <a class="markup--anchor markup--p-anchor" href="https://redux-observable.js.org/docs/api/createEpicMiddleware.html" target="_blank" rel="noopener noreferrer" data-href="https://redux-observable.js.org/docs/api/createEpicMiddleware.html">函数</a>。这个函数创建了实际的Redux中间件，你应该把它传递给<a class="markup--anchor markup--p-anchor" href="https://redux.js.org/api/applymiddleware" target="_blank" rel="noopener noreferrer" data-href="https://redux.js.org/api/applymiddleware"> Redux的</a> <code><a class="markup--anchor markup--p-anchor" href="https://redux.js.org/api/applymiddleware" target="_blank" rel="noopener noreferrer" data-href="https://redux.js.org/api/applymiddleware">applyMiddleware()</a></code> <a class="markup--anchor markup--p-anchor" href="https://redux.js.org/api/applymiddleware" target="_blank" rel="noopener noreferrer" data-href="https://redux.js.org/api/applymiddleware">函数</a>。</p>
<p class="graf graf--p">下面是一个如何创建中间件的示例，该中间件将“CLICK_INCREMENT”类型的操作转换为“INCREMENT”类型的操作:</p>
<pre>const { createEpicMiddleware } = require('redux-observable');
const { filter, map } = require('rxjs/operators');
const redux = require('redux');

// An 'epic' takes a single parameter, `action$`, which is an RxJS observable
// that represents the stream of all actions going through Redux
const countEpic = action$ =&gt; action$.pipe(
  filter(action =&gt; action.type === 'CLICK_INCREMENT'),
  map(action =&gt; {
    return { type: 'INCREMENT', amount: 1 };
  })
);

const observableMiddleware = createEpicMiddleware();
const store = redux.createStore(reducer, redux.applyMiddleware(observableMiddleware));

// **Must** add the epic to the observable after calling `applyMiddleware()`.
// Otherwise you'll get a warning: "epicMiddleware.run(rootEpic) called before
// the middleware has been setup by redux. Provide the epicMiddleware instance
// to createStore() first"
observableMiddleware.run(countEpic);

// Sample Redux reducer
function reducer(state = 0, action) {
  console.log('Action', action);

  switch (action.type) {
    case 'INCREMENT':
      return state + action.amount;
    default:
      return state;
  }
}</pre>
<p class="graf graf--p">假设您将类型为“CLICK_INCREMENT”的操作分派给上述商店，如下所示:</p>
<pre>store.dispatch({ type: 'CLICK_INCREMENT' });</pre>
<p class="graf graf--p">您的<code>filter()</code>和<code>map()</code>调用将运行，redux-observable将分派一个‘INCREMENT’类型的附加动作。</p>
<p class="graf graf--p">下面是<code>reducer()</code>函数中<code>console.log()</code>语句的输出:</p>
<pre>{ type: '@@redux/INIT7.2.m.z.p.l' }
Action { type: 'CLICK_INCREMENT' }
Action { type: 'INCREMENT', amount: 1 }</pre>
<p class="graf graf--p">请注意，redux-observable调度了一个额外的操作。“CLICK_INCREMENT”动作仍然会传递到减速器。默认情况下，史诗将动作添加到流中。</p>

<div class="podcast-container">
<div class="podcast-embed">
<h2>我们不只是写Redux，我们也谈论它。现在听着:</h2>
<p>或者以后订阅</p>
<h3>异步调度</h3>

</div>
</div>
<h3 class="graf graf--h3">上面显示的例子是一个简单的介绍，但是并没有抓住为什么你首先要使用redux-observable。</h3>
<p class="graf graf--p">redux-observable之所以如此有趣，是因为它能够使用<a class="markup--anchor markup--p-anchor" href="https://www.learnrxjs.io/operators/transformation/mergemap.html" target="_blank" rel="noopener noreferrer" data-href="https://www.learnrxjs.io/operators/transformation/mergemap.html">RxJS’</a><code><a class="markup--anchor markup--p-anchor" href="https://www.learnrxjs.io/operators/transformation/mergemap.html" target="_blank" rel="noopener noreferrer" data-href="https://www.learnrxjs.io/operators/transformation/mergemap.html">mergeMap()</a></code><a class="markup--anchor markup--p-anchor" href="https://www.learnrxjs.io/operators/transformation/mergemap.html" target="_blank" rel="noopener noreferrer" data-href="https://www.learnrxjs.io/operators/transformation/mergemap.html">函数</a>来处理异步函数。换句话说，redux-observable是<a class="markup--anchor markup--p-anchor" href="http://thecodebarbarian.com/redux-saga-vs-async-await.html" target="_blank" rel="noopener noreferrer" data-href="http://thecodebarbarian.com/redux-saga-vs-async-await.html"> redux-saga </a>和<a class="markup--anchor markup--p-anchor" href="http://thecodebarbarian.com/async-await-with-react-and-redux-thunk.html" target="_blank" rel="noopener noreferrer" data-href="http://thecodebarbarian.com/async-await-with-react-and-redux-thunk.html"> redux-thunk </a>的可行替代方案。</p>
<p class="graf graf--p">下面是一个如何将redux-observable与一个简单的<a class="markup--anchor markup--p-anchor" href="http://thecodebarbarian.com/common-async-await-design-patterns-in-node.js.html" target="_blank" rel="noopener noreferrer" data-href="http://thecodebarbarian.com/common-async-await-design-patterns-in-node.js.html">异步函数</a>一起使用的例子:</p>
<p class="graf graf--p"><code>countEpic()</code>现在将等待大约1秒钟，然后分派“增量”动作:</p>
<pre>const { createEpicMiddleware } = require('redux-observable');
const { filter, mergeMap } = require('rxjs/operators');
const redux = require('redux');

const startTime = Date.now();

const countEpic = action$ =&gt; action$.pipe(
  filter(action =&gt; action.type === 'CLICK_INCREMENT'),
  // `mergeMap()` supports functions that return promises, as well as observables
  mergeMap(async (action) =&gt; {
    await new Promise(resolve =&gt; setTimeout(resolve, 1000));
    return { type: 'INCREMENT', amount: 1 };
  })
);

const observableMiddleware = createEpicMiddleware();
const store = redux.createStore(reducer, redux.applyMiddleware(observableMiddleware));

observableMiddleware.run(countEpic);

// Sample Redux reducer
function reducer(state = 0, action) {
  console.log(`+${Date.now() - startTime}ms`, action);

  switch (action.type) {
    case 'INCREMENT':
      return state + action.amount;
    default:
      return state;
  }
}

store.dispatch({ type: 'CLICK_INCREMENT' });</pre>
<p class="graf graf--p">如果你读过<a class="markup--anchor markup--p-anchor" href="http://thecodebarbarian.com/new-ebook-mastering-async-await" target="_blank" rel="noopener noreferrer" data-href="http://thecodebarbarian.com/new-ebook-mastering-async-await"> <em class="markup--em markup--p-em">掌握异步/等待</em> </a>，你就知道这不是支持异步/等待的全部。如果你的异步函数出错了会怎么样？下面的<code>countEpic()</code>会崩溃:</p>
<pre>+1ms { type: '@@redux/INIT7.i.8.v.i.t' }
+7ms { type: 'CLICK_INCREMENT' }
+1012ms { type: 'INCREMENT', amount: 1 }</pre>
<p class="graf graf--p">为了处理错误，你应该总是在你的epic的末尾加上一个<a class="markup--anchor markup--p-anchor" href="https://www.learnrxjs.io/operators/error_handling/catch.html" target="_blank" rel="noopener noreferrer" data-href="https://www.learnrxjs.io/operators/error_handling/catch.html"> RxJS </a> <code><a class="markup--anchor markup--p-anchor" href="https://www.learnrxjs.io/operators/error_handling/catch.html" target="_blank" rel="noopener noreferrer" data-href="https://www.learnrxjs.io/operators/error_handling/catch.html">catchError()</a></code>，如下所示:</p>
<pre>const countEpic = action$ =&gt; action$.pipe(
  filter(action =&gt; action.type === 'CLICK_INCREMENT'),
  mergeMap(async () =&gt; {
    throw new Error('Oops!');
  })
);</pre>
<p class="graf graf--p"><code>countEpic()</code>现在将分派一个“错误”类型的动作，并显示错误消息:</p>
<pre>const { createEpicMiddleware } = require('redux-observable');
const { catchError, filter, mergeMap } = require('rxjs/operators');
const redux = require('redux');

const startTime = Date.now();

const countEpic = action$ =&gt; action$.pipe(
  filter(action =&gt; action.type === 'CLICK_INCREMENT'),
  mergeMap(async () =&gt; {
    throw new Error('Oops!');
  }),
  catchError(err =&gt; Promise.resolve({ type: 'Error', message: err.message }))
);</pre>
<p class="graf graf--p">发出HTTP请求</p>
<pre>+1ms { type: '@@redux/INIT0.a.g.q.3.o' }
+6ms { type: 'CLICK_INCREMENT' }
+8ms { type: 'Error', message: 'Oops!' }</pre>
<h3 class="graf graf--h3">上面的例子很简单，但是不太现实。让我们将redux-observable用于一个更现实的用例:使用<a class="markup--anchor markup--p-anchor" href="https://www.npmjs.com/package/node-fetch" target="_blank" rel="noopener noreferrer" data-href="https://www.npmjs.com/package/node-fetch"> node-fetch </a>发出一个HTTP请求，从<a class="markup--anchor markup--p-anchor" href="https://iextrading.com/developer/" target="_blank" rel="noopener noreferrer" data-href="https://iextrading.com/developer/"> IEX API </a>获取当前的MongoDB股票价格。要获取股票价格，您需要向以下URL发出get请求:</h3>
<p class="graf graf--p">因为可以使用async/await和<code>mergeMap()</code>，所以用redux-observable发出HTTP请求类似于异步调度示例。<a class="markup--anchor markup--p-anchor" href="https://www.npmjs.com/package/node-fetch#usage" target="_blank" rel="noopener noreferrer" data-href="https://www.npmjs.com/package/node-fetch#usage"> Node-fetch返回一个承诺</a>，所以您可以<code>await</code>一个HTTP请求，然后用请求的结果分派一个新的动作。</p>
<pre>://api.iextrading.com/1.0/stock/MDB/price</pre>
<p class="graf graf--p">在下面的代码中，每当‘FETCH _ STOCK _ PRICE’类型的动作通过系统时，<code>fetchEpic()</code>向IEX API发出一个GET请求。如果请求成功，<code>fetchEpic()</code>将分派一个“FETCH_STOCK_PRICE_SUCCESS”类型的新操作，股票价格为:</p>
<p class="graf graf--p">为了将<code>fetchEpic()</code>粘合到Redux，reducer(如下所示)存储了一个映射图<code>prices</code>，它将股票符号映射到价格。为了在Redux中存储MongoDB的股票价格，reducer监听“FETCH_STOCK_PRICE_SUCCESS”类型的操作，而不是“FETCH_STOCK_PRICE”:</p>
<pre>const fetch = require('node-fetch');

// ...

const fetchEpic = action$ =&gt; action$.pipe(
  filter(action =&gt; action.type === 'FETCH_STOCK_PRICE'),
  mergeMap(async (action) =&gt; {
    const url = `https://api.iextrading.com/1.0/stock/${action.symbol}/price`;
    const price = await fetch(url).then(res =&gt; res.text());
    return Object.assign({}, action, { type: 'FETCH_STOCK_PRICE_SUCCESS', price });
  }),
  catchError(err =&gt; Promise.resolve({ type: 'FETCH_STOCK_PRICE_ERROR', message: err.message }))
);</pre>
<p class="graf graf--p">下面显示的是通过带有<code>fetchEpic()</code>和<code>reducer()</code>的Redux store运行“FETCH_STOCK_PRICE”操作的示例输出。“FETCH_STOCK_PRICE”操作通过，<code>fetchEpic()</code>看到这个操作并发出一个HTTP请求。</p>
<pre>// Sample Redux reducer
function reducer(state = { prices: {} }, action) {
  console.log(`+${Date.now() - startTime}ms`, action);

  switch (action.type) {
    case 'FETCH_STOCK_PRICE_SUCCESS':
      const prices = Object.assign({}, state.prices, { [action.symbol]: action.price });
      state = Object.assign({}, state, { prices });
      console.log('New state', state);
      return state;
    default:
      return state;
  }
}

store.dispatch({ type: 'FETCH_STOCK_PRICE', symbol: 'MDB' });</pre>
<p class="graf graf--p">当<code>fetchEpic()</code>从IEX API得到响应时，它发出一个‘FETCH _ STOCK _ PRICE _ SUCCESS’动作，然后reducer更新状态:</p>
<p class="graf graf--p">结论</p>
<pre>+1ms { type: '@@redux/INITg.3.m.s.8.f.i' }
+5ms { type: 'FETCH_STOCK_PRICE', symbol: 'MDB' }
+198ms { type: 'FETCH_STOCK_PRICE_SUCCESS',
  symbol: 'MDB',
  price: '79.94' }
New state { prices: { MDB: '79.94' } }</pre>
<h3 class="graf graf--h3">Redux-observable是一个用React和Redux 处理<a class="markup--anchor markup--p-anchor" href="http://thecodebarbarian.com/async-await-with-react-and-redux-thunk.html" target="_blank" rel="noopener noreferrer" data-href="http://thecodebarbarian.com/async-await-with-react-and-redux-thunk.html">异步逻辑的工具。这很重要，因为React通常不支持异步函数。Redux-observable是redux-saga和redux-thunk的一个有趣的替代品，特别是如果你已经有了RxJS的经验。所以下次你发现自己想要</a><a class="markup--anchor markup--p-anchor" href="https://www.codementor.io/vkarpov/beginner-s-guide-to-redux-middleware-du107uyud" target="_blank" rel="noopener noreferrer" data-href="https://www.codementor.io/vkarpov/beginner-s-guide-to-redux-middleware-du107uyud">编写自己的承诺中间件</a>时，给redux-observable一个机会。</h3>
<p class="graf graf--p">使用<a class="signup" href="https://lp.logrocket.com/blg/signup" target="_blank" rel="noopener noreferrer"> LogRocket </a>消除传统错误报告的干扰</p><div class="code-block code-block-2">
<div class="blog-plug base-cta"><h2><a href="https://lp.logrocket.com/blg/signup" target="_blank" rel="noopener noreferrer"> LogRocket </a>是一个数字体验分析解决方案，它可以保护您免受数百个假阳性错误警报的影响，只针对几个真正重要的项目。LogRocket会告诉您应用程序中实际影响用户的最具影响力的bug和UX问题。</h2>
<a href="https://lp.logrocket.com/blg/signup" class="signup" target="_blank" rel="noopener noreferrer"><img class="alignnone size-full wp-image-46 jetpack-lazy-image" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/><noscript><img data-lazy-fallback="1" class="alignnone size-full wp-image-46" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/></noscript></a>
<p>然后，使用具有深层技术遥测的会话重放来确切地查看用户看到了什么以及是什么导致了问题，就像你在他们身后看一样。</p>
<p>LogRocket自动聚合客户端错误、JS异常、前端性能指标和用户交互。然后LogRocket使用机器学习来告诉你哪些问题正在影响大多数用户，并提供你需要修复它的上下文。</p>
<p>关注重要的bug—<a class="signup" href="https://lp.logrocket.com/blg/signup-issue-free" target="_blank" rel="noopener noreferrer">今天就试试LogRocket】。</a></p>
<p><a href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener"> LogRocket </a>:全面了解您的生产React应用</p><div class="code-block code-block-17">
<div class="blog-plug inline-plug react-plug" vwo-el-id="26283398190">
<h2 vwo-el-id="41600691720">调试React应用程序可能很困难，尤其是当用户遇到难以重现的问题时。如果您对监视和跟踪Redux状态、自动显示JavaScript错误以及跟踪缓慢的网络请求和组件加载时间感兴趣，</h2><p>. </p><a href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" vwo-el-id="19356441070">try LogRocket</a><p>LogRocket 结合了会话回放、产品分析和错误跟踪，使软件团队能够创建理想的web和移动产品体验。这对你来说意味着什么？</p><a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="19356441380">
<img class="first-react-image alignnone size-full wp-image-46 jetpack-lazy-image jetpack-lazy-image--handled" src="../Images/f300c244a1a1cf916df8b4cb02bec6c6.png" vwo-el-id="18272717540" data-lazy-loaded="1" data-original-src="https://files.readme.io/27c94e7-Image_2017-06-05_at_9.46.04_PM.png"/>
</a>
<a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="19356441690">
<img class="second-react-image alignnone size-full wp-image-46 jetpack-lazy-image jetpack-lazy-image--handled" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" vwo-el-id="30720362350" data-lazy-loaded="1" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/>
</a>
<p vwo-el-id="28675660440" class="">LogRocket不是猜测错误发生的原因，也不是要求用户提供截图和日志转储，而是让您回放问题，就像它们发生在您自己的浏览器中一样，以快速了解哪里出错了。</p>
<p>不再有嘈杂的警报。智能错误跟踪允许您对问题进行分类，然后从中学习。获得有影响的用户问题的通知，而不是误报。警报越少，有用的信号越多。</p>
<p>LogRocket Redux中间件包为您的用户会话增加了一层额外的可见性。LogRocket记录Redux存储中的所有操作和状态。</p>
<p vwo-el-id="28675660750">现代化您调试React应用的方式— <a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="40093418840">开始免费监控</a>。</p>
<p vwo-el-id="28675661060">Modernize how you debug your React apps —
<a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="40093418840">start monitoring for free</a>.
</p>
</div></div>
</div></div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
<html>
<head>
<title>Docker for frontend developers - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>面向前端开发者的docker-log rocket博客</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/docker-for-front-end-developers/#0001-01-01">https://blog.logrocket.com/docker-for-front-end-developers/#0001-01-01</a></blockquote><div><article class="article-post">
<p>自从2013年Docker的发布以来，容器的使用一直在增加，现在它已经成为大多数科技公司的一部分。可悲的是，说到前端开发，这个概念很少被触及。</p>
<p>所以前端开发者要和容器化交互的时候，往往会纠结很多。这正是几周前发生在我身上的事情，当时我不得不与公司中一些我通常不处理的服务进行交互。</p>
<p>这项任务本身很容易，但由于缺乏集装箱化工作的知识，完成这项任务几乎花了整整两天的时间。经过这次经历，我现在在处理容器和CI管道时感到更加安全，但整个过程相当痛苦和漫长。</p>
<p>这篇文章的目标是教你Docker的核心概念以及如何操作容器，这样你就可以专注于你喜欢的任务！</p>
<h2>Docker的内容和原因🤔</h2>
<p>让我们从用简单易懂的语言定义Docker开始(在Docker课程的帮助下):</p>
<blockquote><p>Docker是一个允许开发者、系统管理员等。轻松地将他们的应用程序部署在沙箱(称为容器)中，以便在主机操作系统上运行。</p></blockquote>
<p>使用容器的主要好处是，它们打包了代码及其所有依赖项，因此应用程序可以快速可靠地运行，而不管计算环境如何。</p>
<p>这种解耦允许基于容器的应用程序被容易且一致地部署，而不管应用程序将被部署在哪里:云服务器、内部公司服务器或您的个人计算机。</p>
<p><img data-attachment-id="4755" data-permalink="https://blog.logrocket.com/docker-for-front-end-developers/containerized-apps-visual/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2019/08/containerized-apps-visual.png" data-orig-size="730,632" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Containerized apps visualization" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2019/08/containerized-apps-visual-300x260.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2019/08/containerized-apps-visual.png" decoding="async" class="aligncenter size-full wp-image-4755 jetpack-lazy-image" src="../Images/4bb603fe4c7fd989b6e016070ed2a667.png" alt="Containerized Apps Visualization" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2019/08/containerized-apps-visual.png 730w, https://blog.logrocket.com/wp-content/uploads/2019/08/containerized-apps-visual-300x260.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2019/08/containerized-apps-visual.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/08/containerized-apps-visual.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="4755" data-permalink="https://blog.logrocket.com/docker-for-front-end-developers/containerized-apps-visual/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2019/08/containerized-apps-visual.png" data-orig-size="730,632" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Containerized apps visualization" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2019/08/containerized-apps-visual-300x260.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2019/08/containerized-apps-visual.png" decoding="async" loading="lazy" class="aligncenter size-full wp-image-4755" src="../Images/4bb603fe4c7fd989b6e016070ed2a667.png" alt="Containerized Apps Visualization" srcset="https://blog.logrocket.com/wp-content/uploads/2019/08/containerized-apps-visual.png 730w, https://blog.logrocket.com/wp-content/uploads/2019/08/containerized-apps-visual-300x260.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/08/containerized-apps-visual.png"/></noscript>
<h2>术语📖</h2>
<p>在Docker生态系统中，你需要知道几个关键定义，才能理解他们到底在谈论什么:</p>
<ul>
<li>应用程序的蓝图，它构成了容器的基础。它是一个轻量级、独立、可执行的软件包，包括运行应用程序所需的一切，即代码、运行时、系统工具、系统库和设置。</li>
<li><code>Containers</code>:这些由启动容器时提供的映像和任何附加配置选项定义，包括但不限于网络连接和存储选项。</li>
<li><code>Docker daemon</code>:运行在主机上的后台服务，管理Docker容器的构建、运行和分发。守护进程是在操作系统中运行的进程，客户端与之对话。</li>
<li><code>Docker client</code>:允许用户与Docker守护进程交互的CLI。它也可以是其他形式的客户端，比如提供UI界面的客户端。</li>
<li><code>Docker Hub</code>:图像注册表。您可以将注册表视为所有可用Docker图像的目录。如果需要，您可以托管自己的Docker注册表，并从那里提取映像。</li>
</ul>
<h2>“你好，世界，”演示🌎</h2>
<p>为了充分理解上述术语，让我们设置Docker并运行一个示例。</p>
<p>第一步是在你的机器上安装Docker。为此，进入官方<a href="https://docs.docker.com/ee/desktop/"> Docker页面</a>，选择你当前的操作系统，并开始下载。你可能需要创建一个账户，但是不要担心，他们不会在这些步骤中向你收费。</p>
<p>安装Docker后，打开你的终端，执行<code>docker run hello-world</code>。您应该会看到以下消息:</p>
<pre>➜ ~ docker run hello-world
Unable to find image 'hello-world:latest' locally
latest: Pulling from library/hello-world
1b930d010525: Pull complete
Digest: sha256:6540fc08ee6e6b7b63468dc3317e3303aae178cb8a45ed3123180328bcc1d20f
Status: Downloaded newer image for hello-world:latest

Hello from Docker!
This message shows that your installation appears to be working correctly.
</pre>
<p>让我们看看幕后到底发生了什么:</p>
<ol>
<li><code>docker</code>是使您能够与Docker客户端通信的命令。</li>
<li>当您运行<code>docker run [name-of-image]</code>时，Docker守护进程将首先检查您的计算机上是否有该映像的本地副本。否则，它将从Docker Hub中提取图像。在这种情况下，图像的名称是<code>hello-world</code>。</li>
<li>一旦您有了图像的本地副本，Docker守护程序将从它创建一个容器，这将产生消息<code>Hello from Docker!</code></li>
<li>Docker守护进程然后将输出流式传输到Docker客户端，并将其发送到您的终端。</li>
</ol>
<h2>Node.js演示</h2>
<p>“你好，世界！”Docker演示既快速又简单，但事实是我们没有使用Docker的所有功能。让我们做一些更有趣的事情。让我们使用Node.js运行一个Docker容器。</p>
<p>所以，正如你可能猜到的，我们需要在Docker中建立一个节点环境。幸运的是，Docker团队已经创建了一个惊人的市场，你可以在他们的公共Docker Hub中搜索Docker图片。要查找Node.js图片，你只需要在搜索栏中键入“Node”，你很可能会<a href="https://hub.docker.com/_/node">找到这个</a>。</p>
<p><img data-attachment-id="4756" data-permalink="https://blog.logrocket.com/docker-for-front-end-developers/docker-hub/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2019/08/docker-hub.png" data-orig-size="730,239" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Screenshot of the Docker Hub" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2019/08/docker-hub-300x98.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2019/08/docker-hub.png" decoding="async" class="aligncenter size-full wp-image-4756 jetpack-lazy-image" src="../Images/ca87c9ab5a5fb7ebf98f69f47cb74305.png" alt="Screenshot Of The Docker Hub" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2019/08/docker-hub.png 730w, https://blog.logrocket.com/wp-content/uploads/2019/08/docker-hub-300x98.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2019/08/docker-hub.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/08/docker-hub.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="4756" data-permalink="https://blog.logrocket.com/docker-for-front-end-developers/docker-hub/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2019/08/docker-hub.png" data-orig-size="730,239" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Screenshot of the Docker Hub" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2019/08/docker-hub-300x98.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2019/08/docker-hub.png" decoding="async" loading="lazy" class="aligncenter size-full wp-image-4756" src="../Images/ca87c9ab5a5fb7ebf98f69f47cb74305.png" alt="Screenshot Of The Docker Hub" srcset="https://blog.logrocket.com/wp-content/uploads/2019/08/docker-hub.png 730w, https://blog.logrocket.com/wp-content/uploads/2019/08/docker-hub-300x98.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/08/docker-hub.png"/></noscript>
<p>因此，第一步是从Docker Hub中提取图像，如下所示:</p>
<pre>➜ ~ docker pull node</pre>
<p>然后你需要设置一个基本的节点app。创建一个名为<code>node-test.js</code>的文件，让我们使用<a href="https://jsonplaceholder.typicode.com/"> JSON占位符</a>做一个简单的HTTP请求。以下代码片段将获取一个Todo并打印标题:</p>
<pre>const https = require('https');

https
  .get('https://jsonplaceholder.typicode.com/todos/1', response =&gt; {
    let todo = '';

    response.on('data', chunk =&gt; {
      todo += chunk;
    });

    response.on('end', () =&gt; {
      console.log(`The title is "${JSON.parse(todo).title}"`);
    });
  })
  .on('error', error =&gt; {
    console.error('Error: ' + error.message);
  });</pre>
<p>我想避免使用像<code>node-fetch</code>或<code>axios</code>这样的外部依赖关系，以便将示例的焦点放在节点上，而不是依赖关系管理器中。</p>
<p>让我们看看如何使用节点映像运行单个文件，并解释一下<code>docker run</code>标志:</p>
<pre>➜ ~ docker run -it --rm --name my-running-script -v "$PWD":/usr/src/app -w /usr/src/app node node node-test.js</pre>
<ul>
<li><code>-it</code>在<code>interactive</code>模式下运行容器，在这里你可以在容器内执行几个命令。</li>
<li><code>--rm</code>执行完成后自动移除容器。</li>
<li><code>--name [name]</code>为Docker守护进程中运行的进程提供一个名称。</li>
<li>在Docker中挂载一个本地目录，允许交换信息或访问当前系统的文件系统。<em>这是Docker我最喜欢的功能之一！</em></li>
<li><code>-w [docker-path]</code>设置工作目录(开始路线)。默认情况下，这是<code>/</code>。</li>
<li><code>node</code>是要运行的图像的名称。它总是出现在所有的<code>docker run</code>标志之后。</li>
<li><code>node node-test.js</code>是容器的说明。这些总是在图像名称之后。</li>
</ul>
<p>运行前面命令的输出应该是:<code>The title is "delectus aut autem"</code>。</p>
<h2>React.js演示⚛️</h2>
<p>既然这篇帖子关注的是前端开发者，那我们就在Docker中运行一个React应用吧！</p>
<p>让我们从一个基础项目开始。为此，我建议使用<code>create-react-app</code> CLI，但是您可以使用您手边的任何项目；过程将是相同的。</p>
<pre>➜ ~ npx create-react-app react-test
➜ ~ cd react-test
➜ ~ yarn start</pre>
<p>你应该能看到<code>create-react-app</code>项目的主页。然后，让我们引入一个新的概念，<code>Dockerfile</code>。</p>
<p>从本质上来说，<code>Dockerfile</code>是一个简单的文本文件，包含如何构建Docker图像的说明。在这个文件中，您通常会指定您想要使用的图像，其中将包含哪些文件，以及在构建之前是否需要执行一些命令。</p>
<p>现在让我们在<code>react-test</code>项目的根目录下创建一个文件。将此命名为<code>Dockerfile</code>，并编写以下内容:</p>
<pre># Select the image to use
FROM node

## Install dependencies in the root of the Container
COPY package.json yarn.lock ./
ENV NODE_PATH=/node_modules
ENV PATH=$PATH:/node_modules/.bin
RUN yarn

# Add project files to /app route in Container
ADD . /app

# Set working dir to /app
WORKDIR /app

# expose port 3000
EXPOSE 3000
</pre>
<p>当在<code>yarn</code>项目中工作时，建议将<code>node_modules</code>从<code>/app</code>中移除，并将其移动到root。这是为了利用<code>yarn</code>提供的缓存。因此，您可以在React应用程序中自由地执行<code>rm -rf node_modules/</code>。</p>
<p>之后，您可以构建一个新的映像，它将一步一步地运行定义的命令。</p>
<pre>➜ ~ docker image build -t react:test .</pre>
<p>要检查Docker映像是否可用，可以运行<code>docker image ls</code>。</p>
<pre>➜ ~ docker image ls
REPOSITORY TAG IMAGE ID CREATED SIZE
react test b530cde7aba1 50 minutes ago 1.18GB
hello-world latest fce289e99eb9 7 months ago 1.84kB</pre>
<p>现在是时候使用您在前面的示例中使用的命令运行容器了:<code>docker run</code>。</p>
<pre>➜ ~ docker run -it -p 3000:3000 react:test /bin/bash</pre>
<p>注意<code>-it</code>标志，在运行命令后，它会在容器中给出提示。在这里，您可以运行与本地环境中相同的命令，例如<code>yarn start</code>或<code>yarn build</code>。</p>
<p>要退出容器，只需键入<code>exit</code>，但是记住，当你重新启动容器时，你在容器中所做的更改不会保留。如果您想在您的文件系统中保留对容器的更改，您可以使用<code>-v</code>标志并将当前目录挂载到<code>/app</code>中。</p>
<pre>➜ ~ docker run -it -p 3000:3000 -v $(pwd):/app react:test /bin/bash

<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="cfbda0a0bb8ffafaf7fdfaaefda9adf6a9fe">[email protected]</a>:/app# yarn build</pre>
<p>该命令完成后，您可以检查本地项目中是否有一个<code>/build</code>文件夹。</p><div class="code-block code-block-54">
<hr/>
<h3>更多来自LogRocket的精彩文章:</h3>

<hr/></div>
<h2>结论👋</h2>
<p>这是一次深入了解Docker工作原理的奇妙之旅。对于更高级的概念，或者为了巩固您对本文中讨论的概念的理解，我建议您查看下面链接的参考资料。</p>
<p>让我们继续一起建造东西👷</p><div class="code-block code-block-17">
<div class="blog-plug inline-plug react-plug" vwo-el-id="26283398190">
<h2 vwo-el-id="41600691720">使用LogRocket消除传统反应错误报告的噪音</h2>
<a href="https://lp.logrocket.com/blg/react-signup-issue-free" target="_blank" vwo-el-id="19356441070">LogRocket
</a><p>是一款React analytics解决方案，可保护您免受数百个误报错误警报的影响，只针对少数真正重要的项目。LogRocket告诉您React应用程序中实际影响用户的最具影响力的bug和UX问题。</p><a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="19356441380">
<img class="first-react-image alignnone size-full wp-image-46 jetpack-lazy-image jetpack-lazy-image--handled" src="../Images/f300c244a1a1cf916df8b4cb02bec6c6.png" vwo-el-id="18272717540" data-lazy-loaded="1" data-original-src="https://files.readme.io/27c94e7-Image_2017-06-05_at_9.46.04_PM.png"/>
</a>
<a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="19356441690">
<img class="second-react-image alignnone size-full wp-image-46 jetpack-lazy-image jetpack-lazy-image--handled" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" vwo-el-id="30720362350" data-lazy-loaded="1" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/>
</a>
<a href="https://lp.logrocket.com/blg/react-signup-issue-free" target="_blank" rel="noopener noreferrer" vwo-el-id="35866400580">LogRocket
</a><p>自动聚合客户端错误、反应错误边界、Redux状态、缓慢的组件加载时间、JS异常、前端性能度量和用户交互。然后，LogRocket使用机器学习来通知您影响最多用户的最有影响的问题，并提供您修复该问题所需的上下文。</p><p vwo-el-id="28675661060">关注重要的React bug—<a class="signup" href="https://lp.logrocket.com/blg/react-signup-issue-free" target="_blank" rel="noopener noreferrer" vwo-el-id="40093418840">今天就试试LogRocket】。</a></p>
</div></div>
<h2>参考🤓</h2>


<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
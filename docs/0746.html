<html>
<head>
<title>How to set up and code Nuxt.js apps fully in TypeScript - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>如何在TypeScript - LogRocket博客中完整地设置和编写Nuxt.js应用程序</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/how-to-set-up-and-code-nuxt-js-apps-fully-in-typescript/#0001-01-01">https://blog.logrocket.com/how-to-set-up-and-code-nuxt-js-apps-fully-in-typescript/#0001-01-01</a></blockquote><div><article class="article-post">
<p>用TypeScript编写JavaScript代码有助于减少错误和促进协作，还有其他好处。尽管Nuxt为在TypeScript中编写代码提供了内置支持，但您仍然需要依靠其他一些库来充分利用它的特性。</p>
<p>在本教程中，我们将演示如何在TypeScript中构建Nuxt应用程序。我们将创建一个新的Nuxt.js应用程序并安装几个包。我们开始吧！</p>
<h2 id="installation">装置</h2>
<p>要安装Nuxt.js，请输入以下代码行。</p>
<pre>npx create-nuxt-app nuxt-ts-app
</pre>
<p>您将被要求选择名称、描述、框架等。选择<code>universal</code>应用程序，其余选择使用默认设置。</p>
<p>成功创建应用程序后，导航到应用程序目录并安装以下软件包。</p>
<pre>cd nuxt-ts-app
npm install --save-dev @nuxt/typescript-build
</pre>
<p>现在我们已经加载了所有必需的包。不像<a href="https://blog.logrocket.com/how-to-write-a-vue-js-app-completely-in-typescript/" target="_blank" rel="noopener noreferrer"> Vue </a>自动生成配置文件，我们需要手动创建。</p>
<h2 id="configuration">配置</h2>
<p>将<code>@nuxt/typescript-build</code>添加到<code>nuxt.config.js</code>中的<code>buildModules</code>中。</p>
<pre>// nuxt.config.js
export default {
  buildModules: ['@nuxt/typescript-build']
}
</pre>
<p>创建<code>tsconfig.json</code>文件并添加以下内容。</p>
<pre>// tsconfig.json
{
  "compilerOptions": {
    "target": "es2018",
    "module": "esnext",
    "moduleResolution": "node",
    "lib": [
      "esnext",
      "esnext.asynciterable",
      "dom"
    ],
    "esModuleInterop": true,
    "allowJs": true,
    "sourceMap": true,
    "strict": true,
    "noEmit": true,
    "baseUrl": ".",
    "paths": {
      "~/*": [
        "./*"
      ],
      "@/*": [
        "./*"
      ]
    },
    "types": [
      "@types/node",
      "@nuxt/types"
    ]
  },
  "exclude": [
    "node_modules"
  ]
}
</pre>
<p>现在创建<code>vue-shim.d.ts</code>并添加以下内容。</p>
<pre>declare module "*.vue" {
  import Vue from 'vue'
  export default Vue
}
</pre>
<p>也可以安装<code>eslint</code>进行TypeScript。如果您在创建应用程序时已经选择了<code>eslist</code>，您可以先移除它。</p>
<pre>npm remove @nuxtjs/eslint-config
npm i -D @nuxtjs/eslint-config-typescript
</pre>
<p>现在将lint脚本更新为:</p>
<pre>"lint": "eslint --ext .ts,.js,.vue ."
</pre>
<p>我们可以走了！让我们编写一些打字稿代码来进行双重检查。您可以使用选项API样式(普通的)或基于类的组件样式。让我们从两方面来看这件事。</p>
<h2 id="optionsapivanilla">选项API(普通)</h2>
<p>这是一种简单的基本类型，我们不需要对JavaScript代码做太多改动就可以完成。</p>
<p>语法看起来非常类似于JavaScript代码。</p>
<pre>&lt;template&gt;
  &lt;div class="container"&gt;
    &lt;p&gt;FirstName: {{ firstName }}&lt;/p&gt;
    &lt;p&gt;LastName: {{ lastName }}&lt;/p&gt;
    &lt;p&gt;FullName: {{ fullName }}&lt;/p&gt;
    &lt;div&gt;Calculate Age:&lt;/div&gt;
    &lt;input v-model="year" type="number" /&gt;
    {{ ageText }}
  &lt;/div&gt;
&lt;/template&gt;
&lt;script lang="ts"&gt;
import Vue from 'vue'
export default Vue.extend({
  data() {
    return {
      firstName: 'John',
      lastName: 'Doe',
      year: null,
      ageText: 'Age'
    }
  },
  computed: {
    fullName(): string {
      return this.firstName + this.lastName
    }
  },
  watch: {
    year(newVal: number) {
      this.ageText = this.calculate(newVal)
    }
  },
  methods: {
    calculate(newVal: number): string {
      return 'Age:' + newVal
    }
  }
})
&lt;/script&gt;
</pre>
<p>您可以进行基本的输入，比如返回类型<code>computed properties</code>和<code>methods</code>，传递给<code>watchers</code>和<code>methods</code>的参数。</p>
<h2 id="vuextypingvanilla">Vuex typing(香草)</h2>
<p><a href="https://blog.logrocket.com/whats-new-in-vuex-3-1-1-d796b0c791bf/" target="_blank" rel="noopener noreferrer"> Vuex </a>支持开箱即用的基本打字功能。</p>
<pre>import { GetterTree, ActionTree, MutationTree } from 'vuex'
export const state = () =&gt; ({
  count: 0 as number
})
export type RootState = ReturnType&lt;typeof state&gt;
export const getters: GetterTree&lt;RootState, RootState&gt; = {
  count: state =&gt; state.count
}
export const mutations: MutationTree&lt;RootState&gt; = {
  CHANGE_COUNT: (state, newVal: number) =&gt; (state.count = newVal)
}
export const actions: ActionTree&lt;RootState, RootState&gt; = {
  updateCount({ commit }, newVal) {
    // Some async code
    commit('CHANGE_COUNT', newVal)
  }
}
</pre>
<p>要将这些Vuex商店项目映射到您的组件，您仍然需要使用传统的<code>this.$store</code>或Vuex助手，如<code>mapState</code>、<code>mapMutations</code>等。</p>
<p>对于使用类和decorators语法的更高级的类型，我们使用了基于类的方法。</p>
<h2 id="classbasedapi">基于类的API</h2>
<p>在基于类的API风格中，我们将利用<code>nuxt-property-decorator</code>库，它在内部使用<code>vue-property-decorator</code>、<code>vue-class-component</code>和<code>vuex-class</code>，并添加更多特定于Nuxt的装饰器。</p>
<p>要安装库，请执行以下操作:</p>
<pre>npm install --save nuxt-property-decorator
</pre>
<p>让我们看看如何在单文件Vue组件中初始化该类。我们在基于类的API方面所做的大部分事情与我们在Vue中使用基于类的TypeScript类似，因为它使用相同的库。然而，Nuxt还有其他特定的装饰器，我们也会看到。</p><div class="code-block code-block-54">
<hr/>
<h3>更多来自LogRocket的精彩文章:</h3>

<hr/></div>
<h3 id="initializingaclass">初始化类</h3>
<p>使用下面的代码初始化一个类。</p>
<pre>//Typescript code
&lt;script lang="ts"&gt;
import { Component, Vue } from 'nuxt-property-decorator'
@Component
export default class MyStore extends Vue {
}
&lt;/script&gt;
</pre>
<p>相当于JavaScript的代码应该是:</p>
<pre>&lt;script&gt;
export default {
name: 'MyStore'
}
&lt;/script&gt;
</pre>
<p>要在Vue SFC文件中使用TypeScript，类似于Option API方法，您需要将<code>script</code>标记的<code>lang</code>属性设置为<code>ts</code>。</p>
<h2 id="importingacomponent">导入组件</h2>
<p>在其他组件中注册组件的代码写在<code>@Component</code>装饰器中。</p>
<pre>&lt;script lang="ts"&gt;
import Tile from '@/components/Tile.vue'
import { Vue, Component } from 'nuxt-property-decorator'
@Component({
  components: {
    Tile
  }
})
export default class MyStore extends Vue {}
&lt;/script&gt;
</pre>
<p>相当于JavaScript的代码应该是:</p>
<pre>&lt;script&gt;
import Tile from '@/components/Tile.vue'
export default {
  name: 'MyStore',
  components: {
    Tile
  }
}
&lt;/script&gt;
</pre>
<h2 id="usingdatapropscomputedpropertiesmethodswatchersandemit">使用数据、属性、计算属性、方法、观察器和发出</h2>
<h3>数据</h3>
<p>要使用数据属性，只需将它们声明为类变量。</p>
<pre>export default class MyStore extends Vue {
  title: string = 'Product Categories'
  categoryList: Array&lt;object&gt; = [
    {
      name: 'Phones',
      link: '/phones',
      image: 'iphone-11.png'
    },
    {
      name: 'Laptops',
      link: '/laptops',
      image: 'macbook.png'
    }
  ]
}
</pre>
<p>相当于JavaScript的代码如下所示:</p>
<pre>export default {
  title: 'Product Categories'
  categoryList: [
    {
      name: 'Phones',
      link: '/phones',
      image: 'iphone-11.png'
    },
    {
      name: 'Laptops',
      link: '/laptops',
      image: 'macbook.png'
    }
  ]
}
</pre>
<h3>小道具</h3>
<p>我们可以使用<code>@Prop</code>装饰器在我们的Vue组件中使用道具。在Vue中，我们可以给出道具的附加细节，比如<code>required</code>、<code>default</code>和<code>type</code>。我们首先从<code>vue-property-decorator</code>导入<code>Prop</code>装饰器，并如下所示编写它。我们也可以使用<code>readonly</code>来避免操纵道具。</p>
<pre>import { Component, Prop, Vue } from 'nuxt-property-decorator'
@Component
export default class Tile extends Vue {
  @Prop({ required: true }) readonly item!: object
  @Prop() quantity!: number
  @Prop({ default: 'Apple' }) brand!: string
  @Prop(String) readonly type!: string
  @Prop({ required: false, type: String, default: 'Available' })
  readonly stock!: string
}
</pre>
<p>相当于JavaScript的代码如下。</p>
<pre>export default {
  props: {
   item: {
      required: true  
  },
   quantity,
   brand: {
      default: 'Apple',
    },
   type: {
      type: String
    },
   stock: {
      required: false,
      type: string,
      default: 'Available'
    }
  }
}
</pre>
<h3>计算属性</h3>
<p>计算属性用于编写简单的模板逻辑，如操作、追加或连接数据。在TypeScript中，普通的计算属性也以<code>get</code>关键字为前缀。</p>
<pre>export default class Tile extends Vue {
  get buttonText(): string {
    if (this.quantity) {
      return 'Buy Now!'
    } else {
      return 'Coming Soon!'
    }
  }
}
</pre>
<p>下面是相当于JavaScript的代码:</p>
<pre>export default {
  buttonText() {
   if (this.quantity) {
      return 'Buy Now!'
    } else {
      return 'Coming Soon!'
    }
  }
}
</pre>
<p>您可以在TypeScript中编写复杂的计算属性，其中既有<code>getter</code>又有<code>setter</code>，如下所示。</p>
<pre>export default class MyStore extends Vue {
 get searchText() {
    return this.searchTextValue
  }
  set searchText(val) {
    this.searchTextValue = val
  }
}
</pre>
<p>相当于JavaScript的代码应该是:</p>
<pre>searchText: {
  get: function () {
    return this.searchTextValue
  },
  set: function (val) {
    this.searchTextValue = val
  }
}
</pre>
<h3>方法</h3>
<p>与普通的类方法一样，TypeScript中的方法也有一个可选的访问修饰符。</p>
<pre>import { Vue, Component } from 'nuxt-property-decorator'
@Component
export default class Laptop extends Vue {
  laptopPrice: number = 1400
  quantity: number = 0
  calculateTotal(): number {
    return this.laptopPrice * this.quantity
  }
}
</pre>
<p>相当于JavaScript的代码是:</p>
<pre>export default {
  data() {
    return {
      laptopPrice: 1400
        quantity: 0
    }
  }
  methods: {
    calculateTotal() {
      return this.laptopPrice * this.quantity
    }
  }
}
</pre>
<h3>观察者</h3>
<p>观察器编写方式不同于通常用JavaScript编写的方式。JavaScript中最常用的观察器语法是:</p>
<pre>watch: {
  total: function(newval) {
    //do something
  }
}
</pre>
<p>开发人员不经常使用处理程序语法。</p>
<pre>watch: {
  total: {
    handler: 'totalChanged'
  }
}
methods: {
  totalChanged(newVal) {
    // do something
  }
}
</pre>
<p>但是，TypeScript语法类似于第二种方法。在TypeScript中，使用<code>@Watch</code> decorator并传递需要监视的变量的名称。</p>
<pre>@Watch('name')
totalChanged(newVal: string) {
  if(newVal &gt; 20000) {
    this.status = 'limit exceeded for user'
  }
}
</pre>
<p>我们还可以设置<code>immediate</code>和<code>deep</code>观察者。</p>
<pre>@Watch('itemList', { 
  immediate: true, deep: true 
})
itemChanged(newVal: Product, oldVal: Product) {
  // do something
}
</pre>
<p>下面是JS等价的代码:</p>
<pre>watch: {
  itemList: {
      handler: 'itemChanged',
      immediate: true,
      deep: true
    }
}
methods: {
  itemChanged(newVal, oldVal) {
    // do something
  }
}
</pre>
<h3>发射</h3>
<p>要从子组件向父组件发出方法，请使用TypeScript中的<code>@Emit</code> decorator。</p>
<pre>@Emit()
addToCount(n: number) {
  this.count += n
}
@Emit('resetData')
resetCount() {
  this.count = 0
}
</pre>
<p>在第一个例子中，函数名<code>addToCount</code>被转换为<code>kebab-case</code>，类似于Vue emit的工作方式。</p>
<p>在第二个例子中，我们传递了方法的显式名称<code>resetData</code>,并使用了该名称。由于<code>addData</code>在<code>CamelCase</code>，所以再次转换为<code>kebab-case</code>。</p>
<pre>&lt;some-component add-to-count="someMethod" /&gt;
&lt;some-component reset-data="someMethod" /&gt;


//Javascript Equivalent
 methods: {
    addToCount(n) {
      this.count += n
      this.$emit('add-to-count', n)
    },
    resetCount() {
      this.count = 0
      this.$emit('resetData')
    }
}
</pre>
<h2 id="lifecyclehooks">生命周期挂钩</h2>
<p>一个Vue组件有八个生命周期钩子，包括<code>created</code>、<code>mounted</code>等。特定于Nuxt的钩子，比如<code>asyncData</code>和<code>fetch</code>，使用相同的TypeScript语法。这些被声明为普通的类方法。因为生命周期挂钩是自动调用的，它们既不接受参数也不返回任何数据，所以我们不需要访问修饰符、类型参数或返回类型。</p>
<pre>export default class MyStore extends Vue {
  asyncData() {
    //do something
  }
  beforeUpdate() {
    // do something
  }
}
</pre>
<p>JavaScript等效代码如下所示。</p>
<pre>export default {
  asyncData() {
    //do something
  }
  beforeUpdate() {
    // do something
  }
}
</pre>
<h2 id="mixins">混合蛋白</h2>
<p>要在TypeScript中创建mixin，首先创建一个mixin文件。这包含您要与其他组件共享的数据。</p>
<p>在<code>mixins</code>目录中创建一个名为<code>CartMixin.ts</code>的文件，并添加下面的mixin，它共享项目名和一个更新项目名的方法。</p>
<pre>/mixins/CartMixin.ts
import { Component, Vue } from 'nuxt-property-decorator'
@Component
class CartMixin extends Vue {
  public cartProducts: Array&lt;object&gt; = []
  public addToCart(newItem: object): void {
    this.cartProducts = { ...this.cartProducts, ...newItem }
  }
}
export default CartMixin
</pre>
<p>在JavaScript中，我们应该编写如下代码。</p>
<pre>export default {
  data() {
    return {
      cartProducts: []
    }
  },
  methods: {
    addToCart(newItem) {
     this.cartProducts = { ...this.cartProducts, ...newItem }
    }
  }
}
</pre>
<p>要在你的Vue组件中使用上面的mixin，从<code>nuxt-property-decorator</code>导入<code>Mixins</code>和mixin文件本身，并编写如下。</p>
<pre>//pages/phone/index.vue
&lt;template&gt;
  &lt;div class="phones"&gt;
    &lt;div class="item"&gt;
      &lt;img src="@/assets/images/iphone-11.png" /&gt;
      &lt;div&gt;iphone 11&lt;/div&gt;
      &lt;button @click="add"&gt;Add to Cart&lt;/button&gt;
    &lt;/div&gt;
    &lt;div class="cart"&gt;
      &lt;div v-for="(item, i) in cartProducts" :key="i" class="item"&gt;
        &lt;div&gt;Item: {{ item.name}}&lt;/div&gt;
        &lt;div&gt;Quantity: {{ item.quantity }}&lt;/div&gt;
      &lt;/div&gt;
    &lt;/div&gt;
  &lt;/div&gt;
&lt;/template&gt;
&lt;script lang="ts"&gt;
import { Vue, Component, mixins } from 'nuxt-property-decorator'
import CartMixin from '@/mixins/CartMixin'
@Component
export default class Phones extends mixins(CartMixin) {
  public add() {
    this.addToCart({ name: 'phone', quantity: 1 })
  }
}
&lt;/script&gt;
</pre>
<p>我们使用mixin中的<code>cartProducts</code>列表和<code>addToCart</code>方法。</p>
<p>相当于JavaScript的代码应该是:</p>
<pre>&lt;template&gt;
  &lt;div class="phones"&gt;
    &lt;div class="item"&gt;
      &lt;img src="@/assets/images/iphone-11.png" /&gt;
      &lt;div&gt;iphone 11&lt;/div&gt;
      &lt;button @click="add"&gt;Add to Cart&lt;/button&gt;
    &lt;/div&gt;
    &lt;div class="cart"&gt;
      &lt;div v-for="(item, i) in cartProducts" :key="i" class="item"&gt;
        &lt;div&gt;Item: {{ item.name}}&lt;/div&gt;
        &lt;div&gt;Quantity: {{ item.quantity }}&lt;/div&gt;
      &lt;/div&gt;
    &lt;/div&gt;
  &lt;/div&gt;
&lt;/template&gt;
&lt;script&gt;
import CartMixin from '@/mixins/CartMixin'
export default {
  mixins: [ CartMixin],
  methods: {
     public add() {
      this.addToCart({ name: 'phone', quantity: 1 })
    }
  }
}
&lt;/script&gt;
</pre>
<h2 id="vuex">武契特</h2>
<p>为了用TypeScript decorators创建Vuex商店，我们将使用一个流行的库<code>vuex-module-decorators</code>。您还需要一个名为<code>vuex-class</code>的库来在您的组件中使用这些模块。由于<code>nuxt-property-decorators</code>内部使用的是<code>vuex-class</code>，我们不需要重新安装。</p>
<p>安装<code>vuex-module-decorators</code>。</p>
<pre>npm install -D vuex-module-decorators
</pre>
<p>在<code>store</code>文件夹中创建一个名为<code>users.ts</code>的新文件。这将是您的用户模块。</p>
<p>要使用Nuxt的库，必须显式地将<code>stateFactory</code>设置为<code>True</code>。</p>
<pre>import { Module, VuexModule, Mutation } from 'vuex-module-decorators'
interface UserData {
  first: string
  last: string
  address1: string
  address2: string
  state: string
  country: string
  phone: number
}
@Module({
  name: 'user',
  stateFactory: true,
  namespaced: true
})
export default class User extends VuexModule {
  public info: UserData = {
    first: 'Preetish',
    last: 'HS',
    address1: '',
    address2: '',
    state: '',
    country: '',
    phone: 9000000009
  }
  get fullName(): string {
    return this.info.first + ' ' + this.info.last
  }
  @Mutation
  public updateUserInfo(data: UserData) {
    this.info = { ...this.info, ...data }
  }
}
</pre>
<p><code>vuex-module-decorators</code>库为<code>Module</code>、<code>Mutation</code>和<code>Action</code>提供装饰者。像类变量一样，状态变量是直接声明的。</p>
<p>这里我们有一个<code>getter</code>来返回全名和突变来更新用户信息。下面是JavaScript等价代码。</p>
<pre>export default {
  namespaced: true,
  state: {
    info: {
      first: 'Preetish',
      last: 'HS',
      address1: '',
      address2: '',
      state: '',
      country: '',
      phone: 9000000009
    }
  },
  getters: {
    fullName() {
      return this.info.first + ' ' + this.info.last
    }
  }
  mutations: {
    updateUserInfo(data) {
      this.info = { ...this.info, ...data }
    }
  }
}
</pre>
<h3 id="usingvuexincomponents">在组件中使用Vuex</h3>
<p>要使用Vuex，您将使用一个名为<code>vuex-class</code>的库。这个已经从<code>nuxt-property-decorator</code>导出了，不需要再安装了。这个库提供了decorators来绑定我们Vue组件中的<code>State</code>、<code>Getter</code>、<code>Mutation</code>和<code>Action</code>。</p>
<p>因为您正在使用命名空间Vuex模块，所以首先从<code>nuxt-property-decorator</code>导入<code>namespace</code>，然后传递模块的名称来访问该模块。</p>
<pre>&lt;template&gt;
  &lt;div class="user"&gt;
    &lt;div class="title"&gt;Welcome {{ fullName }}&lt;/div&gt;
    &lt;div&gt;
      First:
      &lt;input type="text" v-model="localData.first" /&gt;
    &lt;/div&gt;
    &lt;button @click="update"&gt;Update Info&lt;/button&gt;
  &lt;/div&gt;
&lt;/template&gt;
&lt;script lang="ts"&gt;
import { Vue, Component, namespace } from 'nuxt-property-decorator'
const user = namespace('user')
@Component
export default class User extends Vue {
  public localData: object = {}
  @user.State
  public info!: object
  @user.Getter
  public fullName!: string
  @user.Mutation
  public updateUserInfo!: (data: object) =&gt; void
  mounted() {
    this.localData = { ...this.localData, ...this.info }
  }
  public update(): void {
    this.updateUserInfo(this.localData)
  }
}
&lt;/script&gt;
</pre>
<p>JavaScript等效代码:</p>
<pre>&lt;script&gt;
import { mapState, mapGetters, mapMutations } from 'vuex'
export default {
  data() {
    return {
      localData: {}
    }
  },
  computed: {
    ...mapState('user', ['info']),
    ...mapGetters('user', ['fullName'])
  },
  mounted() {
    this.localData = { ...this.localData, ...this.info }
  },
  methods: {
    ...mapMutations('user', ['updateUserInfo']),
    update() {
      this.updateUserInfo(this.localData)
    }
  }
}
&lt;/script&gt;
</pre>
<p>访问<a href="https://github.com/preetishhs/nuxt-typescript-example" target="_blank" rel="noopener noreferrer"> GitHub repo </a>查看本文中使用的代码片段。</p>
<h2 id="conclusion">结论</h2>
<p>现在，您已经拥有了使用一些官方和第三方库完全在TypeScript中创建一个Nuxt.js应用程序所需的所有基本信息，可以充分利用类型和定制装饰器特性。起初，使用TypeScript可能看起来有点势不可挡，但是当您习惯使用它时，您的代码中的错误会少得多，并且在使用相同代码库的其他开发人员之间的代码协作会更加顺畅。</p><div class="code-block code-block-21">
<div class="blog-plug inline-plug typescript-plug"><h2><a class="signup" href="https://lp.logrocket.com/blg/typescript-signup" target="_blank" rel="noopener noreferrer"> LogRocket </a>:全面了解您的网络和移动应用</h2>
<a href="https://lp.logrocket.com/blg/typescript-signup" class="signup" target="_blank" rel="noopener noreferrer"><img class="alignnone size-full wp-image-46 jetpack-lazy-image" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/><noscript><img data-lazy-fallback="1" class="alignnone size-full wp-image-46" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/></noscript></a>
<p>LogRocket 是一个前端应用程序监控解决方案，可以让您回放问题，就像问题发生在您自己的浏览器中一样。LogRocket不需要猜测错误发生的原因，也不需要向用户询问截图和日志转储，而是让您重放会话以快速了解哪里出错了。它可以与任何应用程序完美配合，不管是什么框架，并且有插件可以记录来自Redux、Vuex和@ngrx/store的额外上下文。</p>
<p>除了记录Redux操作和状态，LogRocket还记录控制台日志、JavaScript错误、堆栈跟踪、带有头+正文的网络请求/响应、浏览器元数据和自定义日志。它还使用DOM来记录页面上的HTML和CSS，甚至为最复杂的单页面和移动应用程序重新创建像素级完美视频。</p>
<a class="signup" href="https://lp.logrocket.com/blg/typescript-signup" target="_blank" rel="noopener noreferrer">Try it for free</a><p>.</p></div>
</div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
<html>
<head>
<title>Set up React Hot Loader in 10 minutes - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>在10分钟内设置React热加载器</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/setup-react-hotloader-in-10-minutes-3175dfdbf38a/#0001-01-01">https://blog.logrocket.com/setup-react-hotloader-in-10-minutes-3175dfdbf38a/#0001-01-01</a></blockquote><div><article class="article-post">
<p>几年前，刷新浏览器以查看web项目的最新更新变得很累(在更改没有按预期呈现的情况下甚至很烦人)。</p>
<p>为了解决这个问题，开发人员开发了几个插件和工具，可以让<code>DOM</code>在每次保存时重新渲染，甚至不需要完全重新加载。</p>
<p>这叫做热重装。它的工作原理是在运行时用一个更新的模块替换应用程序的一个模块，以便它可以立即使用。</p>
<p>这就让我们谈到了热模块更换(HMR)。</p>
<p>顾名思义，HMR可以在不重启服务器的情况下替换模块，并且可以很容易地在不同的捆绑器上启用。</p>
<p>在<a class="markup--anchor markup--p-anchor" href="https://webpack.js.org/" target="_blank" rel="noopener noreferrer" data-href="https://webpack.js.org/"> webpack的</a>网站上，它说:</p>
<blockquote><p>热模块替换(HMR)在应用程序运行时交换、添加或删除<a class="markup--anchor markup--blockquote-anchor" href="https://webpack.js.org/concepts/modules/" target="_blank" rel="noopener noreferrer" data-href="https://webpack.js.org/concepts/modules/">模块</a>，无需完全重新加载。这可以在几个方面大大加快开发速度。</p></blockquote>
<p>HMR解决了热重新加载的问题，使调整样式变得更容易(几乎相当于在浏览器的调试器中改变样式),并且总体上加快了开发过程。</p>
<p>但是，当我们在React这样的基于组件的框架中实时重载并跟踪其状态时，会发生什么呢？我们失去了国家。</p>
<p>我们丢失状态的原因可以通过首先理解热重装和实时重装之间的区别来理解:</p>
<ul>
<li>对应用程序的<strong>热重新加载</strong>只会刷新被更改的文件，而不会丢失应用程序的状态。</li>
<li>一个<strong>实时重新加载</strong>到一个应用程序将会重新启动整个应用程序，并且加载导致它丢失它的状态。</li>
</ul>
<p>本教程的主要目的是演示我们如何快速设置react应用程序的react-hot-loader，以便它的组件可以被实时重新加载而不会丢失状态。</p>
<p>本文的结果代码可以在<a class="markup--anchor markup--p-anchor" href="https://github.com/christiannwamba/react-hot-loader-demo" target="_blank" rel="noopener noreferrer" data-href="https://github.com/christiannwamba/react-hot-loader-demo"> GitHub </a>上找到。</p>
<h2>先决条件</h2>
<ol>
<li>请确保在开始本教程之前安装了节点和npm</li>
<li>这里假设您对React有非常基本的了解，并且对JavaScript有一个大致的了解会很有帮助</li>
<li>我们将使用create-react-app工具创建react应用程序</li>
</ol>
<p>如果您的计算机上还没有<code>create-react-app</code>工具，您可以使用以下命令安装它:</p>
<pre>npm install -g create-react-app</pre>
<h2>设置开发环境</h2>
<p>让我们启动一个create-react-app项目的新实例，并使用以下命令导航到新创建的目录:</p>
<pre>create-react-app react-hot-loader-demo
cd react-hot-loader-demo</pre>
<p>我们可以使用以下命令运行应用程序:</p>
<pre>npm start</pre>
<p>该命令启动指向地址<code>localhost://3000</code>的web服务器。我们将在浏览器上访问这个地址，并保持选项卡打开，因为在整个教程中，我们将在浏览器中监控应用程序的更新和行为。</p>
<figure class="graf graf--figure"><img decoding="async" class="graf-image jetpack-lazy-image" src="../Images/345e53099d5ab79c49f85ba328a30818.png" data-image-id="0*EcS1HNjAsGcS3BAo.png" data-width="655" data-height="440" data-lazy-src="https://cdn-images-1.medium.com/max/1600/0*EcS1HNjAsGcS3BAo.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://cdn-images-1.medium.com/max/1600/0*EcS1HNjAsGcS3BAo.png"/><noscript><img data-lazy-fallback="1" decoding="async" class="graf-image" src="../Images/345e53099d5ab79c49f85ba328a30818.png" data-image-id="0*EcS1HNjAsGcS3BAo.png" data-width="655" data-height="440" data-original-src="https://cdn-images-1.medium.com/max/1600/0*EcS1HNjAsGcS3BAo.png"/></noscript></figure>
<p>当我们使用<code>create-react-app</code>创建一个新项目时，HMR插件在<code>webpack</code>配置文件中默认启用，尽管我们看不到这个文件，因为<code>create-react-app</code>为我们配置了我们的应用程序并隐藏了配置文件。</p>
<h2>检查热重装行为</h2>
<p>我们可以通过向开箱即用的<code>index.css</code>文件添加一个基本样式来看到HMR的热重装。我们将向正文样式添加一个属性值对— <code>background: lightblue</code>:</p>
<pre>body {
  margin: 0;
  padding: 0;
  font-family: sans-serif;
  background: lightblue;
}</pre>
<p>保存后，应用程序会在不刷新浏览器选项卡的情况下更新。</p>
<p>这种行为是可能的，因为HMR能够在运行时替换应用程序中的代码模块。</p>
<h3>用JavaScript文件检查热重装行为</h3>
<p>现在让我们看看当我们编辑<code>App.js</code>文件中的内容时会发生什么，我们可以做一些基本的事情，如将“开始，编辑<code>src/App.js</code>并保存以重新加载”替换为“这是设置React热加载器的教程”</p>
<pre>import React, { Component } from 'react';
import logo from './logo.svg';
import './App.css';

class App extends Component {
  render() {
    return (
      &lt;div className="App"&gt;
        &lt;header className="App-header"&gt;
          &lt;img src={logo} className="App-logo" alt="logo" /&gt;
          &lt;h1 className="App-title"&gt;Welcome to React&lt;/h1&gt;
        &lt;/header&gt;
        &lt;p className="App-intro"&gt;
        This is a tutorial to setup React Hotloader..
        &lt;/p&gt;
      &lt;/div&gt;
    );
  }
}

export default App;</pre>
<p><span class="embed-youtube"> <iframe loading="lazy" class="youtube-player" src="https://www.youtube.com/embed/ahXEHGJrzTI?version=3&amp;rel=1&amp;showsearch=0&amp;showinfo=1&amp;iv_load_policy=1&amp;fs=1&amp;hl=en-US&amp;autohide=2&amp;wmode=transparent" allowfullscreen="true" sandbox="allow-scripts allow-same-origin allow-popups allow-presentation">视频</iframe> </span></p>
<p>这一次，可以观察到应用程序进行了实时重新加载，并且整个页面刷新，这样就可以实现更改了。这是因为HMR无法决定如何处理这个JavaScript文件的更新。</p>
<p>自然，当HMR在运行时收到更新并确认相关模块知道如何更新自己时，热重新加载是可能的。当模块知道如何更新自己时，HMR就沿着导入/请求链向上，搜索可以接受更新的父模块。</p>
<p>让我们稍微调整一下我们的应用程序，让HMR知道如何处理热重载的JavaScript文件。</p>
<p>在<code>index.js</code>文件中(这是我们应用程序的入口点)，我们将添加这行代码:</p>
<pre>if(module.hot){
  module.hot.accept()
}</pre>
<p>这段代码将使React组件的更新能够热重载，因为父模块(<code>index.js</code>)现在知道如何接受和处理运行时更新。</p>
<p>现在，让我们快速编辑代码并保存它，看看状态是否持续，我们将用<code>“Does the state persist now? The value is {this.state.number}”</code>替换<code>Will the state be preserved? The value is {this.state.number}</code>:</p>
<pre>import React, { Component } from 'react';
import logo from './logo.svg';
import './App.css';

class App extends Component {
  render() {
    return (
      &lt;div className="App"&gt;
        &lt;header className="App-header"&gt;
          &lt;img src={logo} className="App-logo" alt="logo" /&gt;
          &lt;h1 className="App-title"&gt;Welcome to React&lt;/h1&gt;
        &lt;/header&gt;
        &lt;p className="App-intro"&gt;
        This update will not cause a refresh to the browser tab.
        &lt;/p&gt;
      &lt;/div&gt;
    );
  }
}

export default App;</pre>
<p>结果页面:</p>
<p><span class="embed-youtube"> <iframe loading="lazy" class="youtube-player" src="https://www.youtube.com/embed/XSuT76vPfBk?version=3&amp;rel=1&amp;showsearch=0&amp;showinfo=1&amp;iv_load_policy=1&amp;fs=1&amp;hl=en-US&amp;autohide=2&amp;wmode=transparent" allowfullscreen="true" sandbox="allow-scripts allow-same-origin allow-popups allow-presentation">视频</iframe> </span></p>
<p>此更新被处理为热重新加载，不会导致浏览器刷新！</p>
<h3>用状态变量检查热重装行为</h3>
<p>到目前为止，我们所做的一切都很棒。让我们看看当我们在应用程序中包含一个基本状态变量时会发生什么，我们还可以添加一个函数，使它在单击事件时递增:</p>
<pre>import React, { Component } from 'react';
import logo from './logo.svg';
import './App.css';

class App extends Component {
  constructor(props){
    super(props);
    this.state = {
      number : 0
    }
  }
  
  render() {
    return (
      &lt;div className="App"&gt;
        &lt;header className="App-header"&gt;
          &lt;img src={logo} className="App-logo" alt="logo" /&gt;
          &lt;h1 className="App-title"&gt;Welcome to React&lt;/h1&gt;
        &lt;/header&gt;
        &lt;p className="App-intro"&gt;
        The current value of number is {this.state.number}
        &lt;/p&gt;
        &lt;button onClick={()=&gt;this.setState({number : this.state.number + 1})}&gt;+&lt;/button&gt;
      &lt;/div&gt;
    );
  }
}

export default App;</pre>
<p>当我们保存该代码并且它重新加载时，我们可以点击按钮12次来增加它:</p>
<p><span class="embed-youtube"> <iframe loading="lazy" class="youtube-player" src="https://www.youtube.com/embed/iIq7tUM0z1I?version=3&amp;rel=1&amp;showsearch=0&amp;showinfo=1&amp;iv_load_policy=1&amp;fs=1&amp;hl=en-US&amp;autohide=2&amp;wmode=transparent" allowfullscreen="true" sandbox="allow-scripts allow-same-origin allow-popups allow-presentation">视频</iframe> </span></p>
<p>它就像我们希望的那样工作，但是，如果我们现在编辑JavaScript文件并保存它，会发生什么呢？它应该像以前一样进行热重新加载，并保留状态变量的值，对吗？让我们看看。让我们用<code>Will the state be preserved? The value is {this.state.number}</code>替换<code>The current value of number is {this.state.number}</code>行:</p>
<pre>import React, { Component } from 'react';
import logo from './logo.svg';
import './App.css';

class App extends Component {
  constructor(props){
    super(props);
    this.state = {
      number : 0
    }
  }
  
  render() {
    return (
      &lt;div className="App"&gt;
        &lt;header className="App-header"&gt;
          &lt;img src={logo} className="App-logo" alt="logo" /&gt;
          &lt;h1 className="App-title"&gt;Welcome to React&lt;/h1&gt;
        &lt;/header&gt;
        &lt;p className="App-intro"&gt;
        Will the state be preserved? The value is {this.state.number}
        &lt;/p&gt;
        &lt;button onClick={()=&gt;this.setState({number : this.state.number + 1})}&gt;+&lt;/button&gt;
      &lt;/div&gt;
    );
  }
}

export default App;</pre>
<p>在保存它时，我们得到这个屏幕:</p>
<p><span class="embed-youtube"> <iframe loading="lazy" class="youtube-player" src="https://www.youtube.com/embed/CBkQm2ASfso?version=3&amp;rel=1&amp;showsearch=0&amp;showinfo=1&amp;iv_load_policy=1&amp;fs=1&amp;hl=en-US&amp;autohide=2&amp;wmode=transparent" allowfullscreen="true" sandbox="allow-scripts allow-same-origin allow-popups allow-presentation">视频</iframe> </span></p>
<p>刚刚发生了什么？几秒钟前我们的数字不是等于12吗？这种价值去了哪里？没错，在热重装期间，组件被卸载了，当组件被再次装载时，构造函数必须重新运行。即使使用HMR提供的热重装功能，我们也会丢失状态数据。</p><div class="code-block code-block-54">
<hr/>
<h3>更多来自LogRocket的精彩文章:</h3>

<hr/></div>
<p>我们可以使用React热加载器插件并做一些配置来解决这个问题。</p>
<h2>设置React热加载器</h2>
<p>首先，我们要弹出我们的应用程序，这样我们就可以定制它的配置:</p>
<pre>npm run eject</pre>
<blockquote><p>运行<code>npm run eject</code>复制所有的配置文件和可传递的依赖项(webpack、Babel、ESLint等。)到您的项目中，这样您就可以完全控制它们。像<code>npm start</code>和<code>npm run build</code>这样的命令仍然有效，但是它们会指向复制的脚本，这样你就可以调整它们了。</p>
<p>这样做也是永久的。</p></blockquote>
<p>接下来，我们引入React Hot Loader，这是一个插件，允许React组件在不丢失状态的情况下被实时重新加载。它可以与webpack和其他支持HMR和巴别塔插件的捆绑器一起工作。</p>
<pre>npm install --save react-hot-loader</pre>
<blockquote><p>出于权限方面的原因，Linux用户可能需要在这个命令前面加上前缀<code>sudo</code>。</p></blockquote>
<p>安装完成后，我们希望导航到现在可用的<code>config/webpack.config.dev.js</code>，将这一行— <code>plugins: ['react-hot-loader/babel']</code> —添加到Babel loader配置中。它应该是这样的:</p>
<pre>// Process JS with Babel.
{
  test: /\.(js|jsx)$/,
  include: paths.appSrc,
  loader: require.resolve('babel-loader'),
  options: {
    // This is a feature of `babel-loader` for Webpack (not Babel itself).
    // It enables caching results in ./node_modules/.cache/babel-loader/
    // directory for faster rebuilds.
    cacheDirectory: true,
    plugins: ['react-hot-loader/babel'],
  },
}</pre>
<p>接下来我们要做的是再次打开应用程序的入口点，并将应用程序的顶层组件包装在一个<code>&lt;AppContainer&gt;</code>中。我们必须先从<code>react-hot-loader</code>进口<code>&lt;AppContainer&gt;</code>:</p>
<pre>import React from 'react';
import ReactDOM from 'react-dom';
import './index.css';
import App from './App';
import registerServiceWorker from './registerServiceWorker';
import { AppContainer } from 'react-hot-loader';

ReactDOM.render(
    &lt;AppContainer&gt;
      &lt;App /&gt;
    &lt;/AppContainer&gt;, document.getElementById('root'));
registerServiceWorker();

if(module.hot){
    module.hot.accept()
}</pre>
<p>让我们修改<code>module.hot</code>部分，这样我们也可以在其中呈现<code>&lt;AppContainer&gt;</code>:</p>
<pre>if(module.hot){

    module.hot.accept('./App', () =&gt; {
    
    const NextApp = require('./App').default; 
    
    ReactDOM.render(
    &lt;AppContainer&gt;
    &lt;NextApp /&gt;
    &lt;/AppContainer&gt;,
    document.getElementById('root')
    );
    
    });
}</pre>
<p>这个修改告诉<code>&lt;AppContainer&gt;</code>处理模块重载，并处理运行时可能产生的任何错误。</p>
<blockquote><p>在生产环境中会被禁用。</p></blockquote>
<p>最后，我们需要将<code>react-hot-loader</code>补丁放入我们的入口点文件:</p>
<pre>require('react-hot-loader/patch');</pre>
<p>我们需要这样做，因为它负责在底层处理中修补代码。</p>
<h2>测试React热加载器</h2>
<p>让我们测试我们的应用程序，看看状态是否会在更新时保留。现在，我们可以通过保存我们刚刚进行的更新并运行应用程序来完成这一任务:</p>
<pre>npm start</pre>
<p>我们可以单击按钮将数字变量增加到36这样的数字:</p>
<p><span class="embed-youtube"> <iframe loading="lazy" class="youtube-player" src="https://www.youtube.com/embed/7kfwTzH30zA?version=3&amp;rel=1&amp;showsearch=0&amp;showinfo=1&amp;iv_load_policy=1&amp;fs=1&amp;hl=en-US&amp;autohide=2&amp;wmode=transparent" allowfullscreen="true" sandbox="allow-scripts allow-same-origin allow-popups allow-presentation">视频</iframe> </span></p>
<p>现在，让我们快速编辑代码并保存它，看看状态是否持续:</p>
<pre>import React, { Component } from 'react';
import logo from './logo.svg';
import './App.css';

class App extends Component {
  constructor(props){
    super(props);
    this.state = {
      number : 0
    }
  }
  render() {
    return (
      &lt;div className="App"&gt;
        &lt;header className="App-header"&gt;
          &lt;img src={logo} className="App-logo" alt="logo" /&gt;
          &lt;h1 className="App-title"&gt;Welcome to React&lt;/h1&gt;
        &lt;/header&gt;
        &lt;p className="App-intro"&gt;
        Does the state persist now? The value is {this.state.number}
        &lt;/p&gt;
        &lt;button onClick={()=&gt;this.setState({number : this.state.number + 1})}&gt;+&lt;/button&gt;
      &lt;/div&gt;
    );
  }
}

export default App;</pre>
<p>此更新导致浏览器窗口更新为:</p>
<p><span class="embed-youtube"> <iframe loading="lazy" class="youtube-player" src="https://www.youtube.com/embed/vqZ6cpBYkH0?version=3&amp;rel=1&amp;showsearch=0&amp;showinfo=1&amp;iv_load_policy=1&amp;fs=1&amp;hl=en-US&amp;autohide=2&amp;wmode=transparent" allowfullscreen="true" sandbox="allow-scripts allow-same-origin allow-popups allow-presentation">视频</iframe> </span></p>
<p>厉害！尽管我们对文档进行了更改，但状态仍然存在，这意味着我们的<code>react-hot-loader</code>可以完美地工作，并为我们处理模块重载。</p>
<h2>结论</h2>
<p class="graf graf--p">在本教程中，我们从理解热加载的重要性开始，详细说明了热加载和动态加载之间的区别。我们还看到了如何使用<code>react-hot-loader</code>插件快速、轻松地设置React应用程序进行热重载，这样应用程序中所有状态的值都可以被持久化，而不管进行了哪些更新。这篇文章的最终代码可以在<a class="markup--anchor markup--p-anchor" href="https://github.com/christiannwamba/react-hot-loader-demo" target="_blank" rel="noopener noreferrer" data-href="https://github.com/christiannwamba/react-hot-loader-demo"> GitHub </a>上找到。</p><div class="code-block code-block-17">
<div class="blog-plug inline-plug react-plug" vwo-el-id="26283398190">
<h2 vwo-el-id="41600691720"><a href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener"> LogRocket </a>:全面了解您的生产React应用</h2><p>调试React应用程序可能很困难，尤其是当用户遇到难以重现的问题时。如果您对监视和跟踪Redux状态、自动显示JavaScript错误以及跟踪缓慢的网络请求和组件加载时间感兴趣，</p><a href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" vwo-el-id="19356441070">try LogRocket</a><p>. </p><a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="19356441380">
<img class="first-react-image alignnone size-full wp-image-46 jetpack-lazy-image jetpack-lazy-image--handled" src="../Images/f300c244a1a1cf916df8b4cb02bec6c6.png" vwo-el-id="18272717540" data-lazy-loaded="1" data-original-src="https://files.readme.io/27c94e7-Image_2017-06-05_at_9.46.04_PM.png"/>
</a>
<a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="19356441690">
<img class="second-react-image alignnone size-full wp-image-46 jetpack-lazy-image jetpack-lazy-image--handled" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" vwo-el-id="30720362350" data-lazy-loaded="1" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/>
</a>
<p vwo-el-id="28675660440" class="">LogRocket 结合了会话回放、产品分析和错误跟踪，使软件团队能够创建理想的web和移动产品体验。这对你来说意味着什么？</p>
<p>LogRocket不是猜测错误发生的原因，也不是要求用户提供截图和日志转储，而是让您回放问题，就像它们发生在您自己的浏览器中一样，以快速了解哪里出错了。</p>
<p>不再有嘈杂的警报。智能错误跟踪允许您对问题进行分类，然后从中学习。获得有影响的用户问题的通知，而不是误报。警报越少，有用的信号越多。</p>
<p vwo-el-id="28675660750">LogRocket Redux中间件包为您的用户会话增加了一层额外的可见性。LogRocket记录Redux存储中的所有操作和状态。</p>
<p vwo-el-id="28675661060">现代化您调试React应用的方式— <a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="40093418840">开始免费监控</a>。</p>
</div></div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
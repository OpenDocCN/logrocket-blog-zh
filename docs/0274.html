<html>
<head>
<title>Using TypeScript transforms to enrich runtime code - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>使用TypeScript转换来丰富运行时代码</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/using-typescript-transforms-to-enrich-runtime-code-3fd2863221ed/#0001-01-01">https://blog.logrocket.com/using-typescript-transforms-to-enrich-runtime-code-3fd2863221ed/#0001-01-01</a></blockquote><div><article class="article-post">
<figure class="graf graf--figure"><img decoding="async" class="graf-image jetpack-lazy-image" src="../Images/1ae9bf750419fa08427dbb4e9c404c23.png" data-image-id="1*o_eQQtjnjinTDzTRyoREvQ.jpeg" data-width="515" data-height="515" data-is-featured="true" data-lazy-src="https://cdn-images-1.medium.com/max/1600/1*o_eQQtjnjinTDzTRyoREvQ.jpeg?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://cdn-images-1.medium.com/max/1600/1*o_eQQtjnjinTDzTRyoREvQ.jpeg"/><noscript><img data-lazy-fallback="1" decoding="async" class="graf-image" src="../Images/1ae9bf750419fa08427dbb4e9c404c23.png" data-image-id="1*o_eQQtjnjinTDzTRyoREvQ.jpeg" data-width="515" data-height="515" data-is-featured="true" data-original-src="https://cdn-images-1.medium.com/max/1600/1*o_eQQtjnjinTDzTRyoREvQ.jpeg"/></noscript></figure>
<p class="graf graf--p">当我开始开发时，没有人谈论“编译”他们的JavaScript源代码。大家只是写了几个脚本，直接引用。</p>
<p class="graf graf--p">随着时间的推移，缩小和进一步增强成为web开发中事实上的标准，因此在编写代码后进行一些处理成为一种相当正常的做法。如今，每个人都承认前端web开发需要一些处理，主要是使用bundler来帮助我们驯服web怪兽。</p>
<p class="graf graf--p">就JavaScript“处理器”而言，有两种主流。我们要么用TypeScript，要么用Babel加一些插件。有些人实际上可能会使用TypeScript和Babel(或者这些天专门用Babel来编写他们的TypeScript代码)。然而，通常情况下，你只能看到其中之一，这取决于项目是使用TypeScript还是其他可以使用Babel传输的东西。当然，还有其他可用的语言和工具，但这两种是主要的。</p>
<p class="graf graf--p">巴别塔是一个成功的故事。它从一个非常简单的任务开始；为可扩展性打开JavaScript解析器。随着时间的推移，生态系统成长起来，成为向我们的目标浏览器提供兼容输出的标准工具，在开发过程中对使用什么功能没有任何限制。</p>
<p class="graf graf--p">太好了！更好的是，它还在标准JavaScript之上培养了一些元编程和语法糖，如JSX，它允许在React或类似的UI库和框架中编写优雅的前端代码。</p>
<p class="graf graf--p">到目前为止，这种伟大似乎是巴别塔独有的，然而，这被引入的类型转换所改变。现在，可以从外部增强TypeScript。在这篇文章中，我们将看到为什么(以及何时)扩展TypeScript有意义，以及如何去做。</p>
<figure class="graf graf--figure graf--layoutOutsetCenter"/>
<h3 class="graf graf--h3">动机</h3>
<p class="graf graf--p">尽管TypeScript采用了与Babel不同的方法，但它也成为了一个相当成功的故事。最初，许多人怀疑微软在JavaScript世界的抱负。然而，由于它的开源特性和解决问题的方法(“以JavaScript开始，以JavaScript结束”)，人们开始为许多项目快速过渡。</p>
<p class="graf graf--p">就我个人而言，我一直在为任何与JavaScript相关的项目使用TypeScript，然而，我能理解为什么许多人只在更大的项目中使用它。</p>
<p class="graf graf--p">TypeScript的反对者通常给我们以下两个反对使用它的理由:</p>
<ol class="postList">
<li class="graf graf--li">TypeScript所做的保证充其量只是表面的——它们很容易被绕过，并且过于局限而无法使用</li>
<li class="graf graf--li">所有创建类型的工作都会在编译时丢失</li>
</ol>
<p class="graf graf--p">虽然前者是TypeScripts与“普通”JavaScript非常强(100%)兼容性的副作用(也就是说，这里已经选择了一个折衷方案，并且这个折衷方案选择得非常好)，但后者肯定是有效的。</p>
<p class="graf graf--p">目前，没有办法从编译时到运行时引入一些元数据(类型系统)信息。尽管JavaScript是动态的，但我们对这种运行时类型信息(<strong class="markup--strong markup--p-strong"> RTTI </strong>)机制感兴趣的原因有很多。首先，它允许我们在运行时检查外来代码的类型(例如，服务端点的API中的传入数据，来自请求的JSON响应)。</p>
<p class="graf graf--p">抱怨TypeScript缺少RTTI对我们没有太大帮助。相反，我们将尝试使用TypeScript转换来按需提供RTTI。理想情况下，代码可能是这样的:</p>
<pre>import { generateRtti } from 'hypothetical-typescript-rtti';

interface MyType {
  id: string;
}

generateRtti&lt;MyType&gt;();</pre>
<p class="graf graf--p">其中附加信息可以这样检索:</p>
<pre>import { obtainRtti } from 'hypothetical-typescript-rtti';

// get type information as JSON schema
const schema = obtainRtti('MyType').schema;

// get validation results for an instance
const errors = obtainRtti('MyType').validate({ id: 7 });</pre>
<p class="graf graf--p">需要明确的是，在这篇文章中，我们将只关注第一部分，第二部分(揭露RTTI)将不会被讨论。</p>
<p class="graf graf--p">因此，让我们通过引入TypeScript转换来尝试一种生成RTTI的解决方案。</p>
<h3 class="graf graf--h3">类型脚本转换</h3>
<p class="graf graf--p">TypeScript转换只是一个简单的函数，定义如下:</p>
<pre>import { TransformationContext, Transformer, SourceFile } from 'typescript'

interface TypeScriptTransform {
  (ctx: TransformationContext): Transformer&lt;SourceFile&gt;;
}</pre>
<p class="graf graf--p">本质上，我们得到的是一些上下文信息来返回一个函数，该函数可用于源文件的任何类型的转换。以下是此类函数的一个示例:</p>
<pre>function sampleTransformer(ctx: TransformationContext) {
  return (sf: SourceFile) =&gt; visitNode(sf, visitor(ctx, sf, opts))
}</pre>
<p class="graf graf--p">在我们继续之前，我们需要看看我们改变了什么。由于TypeScript是一个编译器(或<em class="markup--em markup--p-em"> transpiler </em>),我们正在处理由编译器处理的数据结构。高层的编译器管道由一个<strong class="markup--strong markup--p-strong">前端</strong>(理解源代码并将其转换为核心数据结构)和一个<strong class="markup--strong markup--p-strong">后端</strong>(将优化等转换应用于数据结构并将其序列化为输出格式)组成。</p>
<p class="graf graf--p">为了达到核心数据结构(通常以树的形式提供，称为抽象语法树或<strong class="markup--strong markup--p-strong"> AST </strong>)，已经应用了一些转换:</p>
<ol class="postList">
<li class="graf graf--li">将字符的线性流转换成定义明确的符号的线性流</li>
<li class="graf graf--li">将线性令牌流转换成符合语言语法的树形结构</li>
</ol>
<p class="graf graf--p">这里也说明了这一点:</p>
<figure class="graf graf--figure"><img decoding="async" class="graf-image jetpack-lazy-image" src="../Images/f97e4079e09c989fa668b4e0302023da.png" data-image-id="1*PHTLSZMgybzo7vp8meaqlA.png" data-width="498" data-height="530" data-lazy-src="https://cdn-images-1.medium.com/max/1600/1*PHTLSZMgybzo7vp8meaqlA.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://cdn-images-1.medium.com/max/1600/1*PHTLSZMgybzo7vp8meaqlA.png"/><noscript><img data-lazy-fallback="1" decoding="async" class="graf-image" src="../Images/f97e4079e09c989fa668b4e0302023da.png" data-image-id="1*PHTLSZMgybzo7vp8meaqlA.png" data-width="498" data-height="530" data-original-src="https://cdn-images-1.medium.com/max/1600/1*PHTLSZMgybzo7vp8meaqlA.png"/></noscript><figcaption class="imageCaption">Data transformations (pipeline) for parsing source code</figcaption></figure>
<p class="graf graf--p">使用TypeScript转换，我们只能有一个后端转换器，允许我们在现有的AST上执行修改。</p>
<h3 class="graf graf--h3">AST基础知识</h3>
<p class="graf graf--p">AST是一棵树，由表示语法信息组的节点和表示它们之间关系的边组成。例如，一个简单的示例代码如下:</p>
<pre>const a = 3 + 4;
console.log(a);</pre>
<p class="graf graf--p">转换成这样的AST:</p>
<pre>{
  "type": "Program",
  "body": [
    {
      "type": "VariableDeclaration",
      "kind": "const",
      "declarations": [
        {
          "type": "VariableDeclarator",
          "id": {
            "type": "Identifier",
            "name": "a"
          },
          "init": {
            "type": "BinaryExpression",
            "operator": "+",
            "left": {
              "type": "Literal",
              "value": 3,
            },
            "right": {
              "type": "Literal",
              "value": 4,
            }
          }
        }
      ]
    },
    {
      "type": "ExpressionStatement",
      "expression": {
        "type": "CallExpression",
        "callee": {
          "type": "MemberExpression",
          "computed": false,
          "object": {
            "type": "Identifier",
            "name": "console"
          },
          "property": {
            "type": "Identifier",
            "name": "log"
          }
        },
        "arguments": [
          {
            "type": "Identifier",
            "name": "a"
          }
        ]
      }
    }
  ]
}</pre>
<p class="graf graf--p">这里我们选择了所谓的<a class="markup--anchor markup--p-anchor" href="https://github.com/estree/estree" target="_blank" rel="noopener noreferrer" data-href="https://github.com/estree/estree"> ES树</a>规范来以JSON形式表示输出。有两件事在所有AST实现中都很常见:</p>
<ol class="postList">
<li class="graf graf--li">由于有许多不同的节点，我们需要一个类型鉴别器来区分不同类型的节点。通常，相关属性被称为<code>type</code></li>
<li class="graf graf--li">根节点是程序本身，它的主体由所有语句组成。一个语句由表达式组成。表达式可以计算东西，可以组合，语句只是指令，不允许组合(只允许聚合，例如在程序、块语句或函数体中)</li>
</ol>
<p class="graf graf--p">使用AST最有效的方法是回到经典的软件设计模式，使用<strong class="markup--strong markup--p-strong">访问者模式</strong>。这种模式允许我们遍历树，而不必实现/知道树中的所有信息。</p>
<p class="graf graf--p">考虑上面的示例树。为了在没有访问者模式的情况下遍历它，我们需要知道:</p>
<ul class="postList">
<li class="graf graf--li">二元运算有两个子节点，一个在<code>left</code>中，一个在<code>right</code>中</li>
<li class="graf graf--li">变量声明符有两个子节点，一个在<code>id</code>中，一个在<code>init</code>中，后者是可选的</li>
<li class="graf graf--li">变量声明中有一个由<code>declarations</code>属性公开的声明数组</li>
<li class="graf graf--li">有一个表达式语句(仅由一个表达式组成，没有任何其他指令)，在其<code>expression</code>属性中包含该表达式</li>
<li class="graf graf--li">调用表达式包含两个属性<code>callee</code>(定义被调用值的表达式)和<code>arguments</code>(计算参数的表达式数组)</li>
<li class="graf graf--li">成员表达式由包含在<code>object</code>和<code>property</code>中的两个表达式组成</li>
</ul>
<p class="graf graf--p">这只是一个简单的例子，但是它已经强调了遍历它需要大量的信息。概括这一点将需要巨大的努力，这可以通过使用访问者模式来减轻。</p>
<p class="graf graf--p">例如，以下代码是将与<code>a</code>相关的每个标识符更改为<code>b</code>所必需的全部内容:</p>
<pre>tree.visit({
  Identifier(node) {
    if (node.name === 'a') {
      node.name = 'b';
    }
  },
})</pre>
<p class="graf graf--p">这个示例代码说明了在树上应用一个访问者函数会将我们这边的代码减少到我们感兴趣的部分。我们可以只关注标识符节点，而不是做遍历树的所有基础工作。</p><div class="code-block code-block-54">
<hr/>
<h3>更多来自LogRocket的精彩文章:</h3>

<hr/></div>
<p class="graf graf--p">现实世界的实现可能看起来不同。例如，在TypeScript中公开的方法如下所示:</p>
<pre>import * as ts from 'typescript';

function visit(ctx: ts.TransformationContext, sf: ts.SourceFile) {
  const visitor: ts.Visitor = (node: ts.Node): ts.VisitResult =&gt; {
    // here we can check each node and potentially return 
    // new nodes if we want to leave the node as is, and 
    // continue searching through child nodes:
    return ts.visitEachChild(node, visitor, ctx);
  };
  return visitor;
}

export default function() {
  return (ctx: ts.TransformationContext): ts.Transformer =&gt; {
    return (sf: ts.SourceFile) =&gt; ts.visitNode(sf, visit(ctx, sf))
  }
}</pre>
<p class="graf graf--p">出于性能原因，TypeScript访问者需要助手方法来触发遍历。</p>
<h3 class="graf graf--h3">简单的变压器</h3>
<p class="graf graf--p">我们的第一步是创建要导出的转换器。因为我们使用类型，所以从评估的源代码中获取类型检查器实例是有意义的。代码看起来像这样:</p>
<pre>import * as ts from 'typescript';

export interface TransformerOptions {}

export function transformer(program: ts.Program, opts?: TransformerOptions) {
  function visitor(ctx: ts.TransformationContext, sf: ts.SourceFile) {
    const typeChecker = program.getTypeChecker();

    const visitor: ts.Visitor = (node: ts.Node) =&gt; {
      // Implementation here
      return ts.visitEachChild(node, visitor, ctx);
    };

    return visitor;
  }

  return (ctx: ts.TransformationContext) =&gt; {
    return (sf: ts.SourceFile) =&gt; ts.visitNode(sf, visitor(ctx, sf));
  };
}</pre>
<p class="graf graf--p">所以我们创建一个简单的函数，将整个程序作为转换输入。此外，我们接受一些选项(我们现在还没有使用，但是知道用户定义的配置可能传入的位置是很好的)。最后，我们返回前面提到的函数，该函数接受转换上下文并返回实际的源文件转换器。</p>
<p class="graf graf--p">源文件转换器的实现使用TypeScript给出的<code>visitNode</code>函数以及我们自己的实现。应用于每个节点的非常特定的访问者仍然需要实现。查看我们的样本代码，我们对调用一个<code>generateRtti</code>函数感兴趣。</p>
<p class="graf graf--p">下面的代码代表了我们想要的一个合理的实现:</p>
<pre>if (ts.isCallExpression(node) &amp;&amp; node.typeArguments &amp;&amp; node.expression.getText(sf) == 'generateRtti') {
  const [type] = node.typeArguments;
  const [argument] = node.arguments;
  const fn = ts.createIdentifier('__rtti__generate');
  const typeName = type.getText();
  const typeSource = getDescriptor(type, typeChecker);
  return ts.createCall(fn, undefined, [argument || ts.createStringLiteral(typeName), typeSource]);
}</pre>
<p class="graf graf--p">如果我们看到一个节点是带有一些类型参数的对<code>generateRtti</code>的调用表达式，我们将该节点转换成:</p>
<pre>__rtti__generate(name_of_the_type, descriptor_of_the_type);</pre>
<p class="graf graf--p">此时会出现两个问题:</p>
<ul class="postList">
<li class="graf graf--li"><code>getDescriptor</code>的实现是什么样子的？</li>
<li class="graf graf--li"><code>__rtti__generate</code>(或者我们给这个函数起的任何名字)从何而来？</li>
</ul>
<p class="graf graf--p">让我们试着逐一回答这些问题。首先，<code>getDescriptor</code>的实现需要与我们期望的所有类型对抗。最重要的是，它需要处理类型引用和接口。在上面的例子中，我们得到了一个绑定到接口的类型引用。</p>
<p class="graf graf--p">一个简单的实现可能如下所示:</p>
<pre>function getDescriptor(type: ts.Node, typeChecker: ts.TypeChecker): ts.Expression {
  switch (type.kind) {
    case ts.SyntaxKind.PropertySignature:
      return getDescriptor((type as ts.PropertySignature).type, typeChecker);
    case ts.SyntaxKind.TypeLiteral:
    case ts.SyntaxKind.InterfaceDeclaration:
      return ts.createObjectLiteral(
        (type as ts.InterfaceDeclaration).members.map(
          (m): ts.ObjectLiteralElementLike =&gt; ts.createPropertyAssignment(m.name || '', getDescriptor(m, typeChecker)),
        ),
      );
    case ts.SyntaxKind.TypeReference:
      const symbol = typeChecker.getSymbolAtLocation((type as ts.TypeReferenceNode).typeName);
      const declaration = ((symbol &amp;&amp; symbol.declarations) || [])[0];
      return getDescriptor(declaration, typeChecker);
    case ts.SyntaxKind.NumberKeyword:
    case ts.SyntaxKind.BooleanKeyword:
    case ts.SyntaxKind.AnyKeyword:
    case ts.SyntaxKind.StringKeyword:
      return ts.createLiteral('string');
    case ts.SyntaxKind.ArrayType:
    default:
      throw new Error('Unknown type ' + ts.SyntaxKind[type.kind]);
  }
}</pre>
<p class="graf graf--p">为了简单起见，我们省略了许多情况(例如，yielding】),只保留了使我们的例子正常工作所必需的内容。我们看到原语被直接输出(例如，当我们看到一个字符串类型被使用时，给出一个<code>'string'</code>文字)，而组合类型如接口声明被递归地使用<code>getDescriptor</code>函数。</p>
<p class="graf graf--p">就第二个问题而言，有多种方法。我们可以:</p>
<ul class="postList">
<li class="graf graf--li">在我们的库中定义函数，并在导入语句中添加对它的引用，或者</li>
<li class="graf graf--li">在新模块中定义该函数(如果该函数已被使用/引用)</li>
</ul>
<p class="graf graf--p">第一个可能很容易改变或摆弄，但是，它带来了一些很大的问题。这一次，我们的转换是在绑定阶段之后的<em class="markup--em markup--p-em">，也就是说，我们需要自己处理任何模块绑定。通常，如果我们知道目标(特别是对于ES6模块)，这不是一件大事，但是，支持所有可能的模块系统这可能是相当麻烦的。此外，这将把运行时依赖留在那里，这仍然可能把我们的转换器代码带到包中(取决于所使用的树抖动器的能力)。</em></p>
<p class="graf graf--p">因此，我们应该选择第二个选项，这也是TypeScript使用的选项。众所周知，TypeScript也喜欢为引入的函数生成代码。我们也可以这样做。对我们的visitor函数的一个简单修改允许我们在应用了所有转换之后对源文件<em class="markup--em markup--p-em">做一些修改:</em></p>
<pre>return (ctx: ts.TransformationContext) =&gt; {
  return (sf: ts.SourceFile) =&gt; {
    const result = { seen: false };
    const newSf = ts.visitNode(sf, visitor(ctx, sf, result));

    if (result.seen) {
      const fn = createGenerateFunction();
      return ts.updateSourceFileNode(newSf, [fn, ...newSf.statements]);
    }

    return newSf;
  };
};</pre>
<p class="graf graf--p">如果我们以后需要生成函数，那么应该在我们的visitor中更改<code>seen</code>属性的值。函数本身(在本例中)将被放在文件的顶部。</p>
<p class="graf graf--p">由于吊装，我们也可以把它放在底部，没有任何负面影响。函数声明本身并不引人注意——它很长，基本上编译成以下JavaScript代码:</p>
<pre>function __rtti__generate(typeName, typeDefinition) {
  var ctx = typeof window === "undefined" ? global : window;
  var types = ctx.__rtti__types || (ctx.__rtti__types = {});
  types[typeName] = typeDefinition;
}</pre>
<p class="graf graf--p">更多细节可以在GitHub 上的<a class="markup--anchor markup--p-anchor" href="https://github.com/FlorianRappl/ts-transform-sample" target="_blank" rel="noopener noreferrer" data-href="https://github.com/FlorianRappl/ts-transform-sample">样本库中看到。</a></p>
<p class="graf graf--p">我们的简单转换器目前没有覆盖的是循环引用。所以一个自引用的接口(可能是通过其他被引用的接口间接引用的)肯定不会被捕获，从而导致传统的堆栈溢出。通过将包含的接口放在顶层也可以避免这种情况。</p>
<h3 class="graf graf--h3">使用变压器</h3>
<p class="graf graf--p">不幸的是，目前transformers在TypeScript中的使用是有限的。有两个问题:</p>
<ol class="postList">
<li class="graf graf--li"><code>tsc</code>应用不消耗/考虑变压器，例如通过<em class="markup--em markup--li-em"> tsconfig.json </em></li>
<li class="graf graf--li">声明文件(<em class="markup--em markup--li-em"> d.ts </em>)的发出管道独立于转换器</li>
</ol>
<p class="graf graf--p">这两个问题都在TypeScript团队的关注范围内，但是，目前还没有最高优先级。虽然第二个问题不容易有效解决，但第一个问题可以通过多种方式规避。</p>
<p class="graf graf--p">最流行的方法是提供一个额外的runner脚本。这也可以用一个小的包装器脚本作为<a class="markup--anchor markup--p-anchor" href="https://github.com/cevek/ttypescript" target="_blank" rel="noopener noreferrer" data-href="https://github.com/cevek/ttypescript">结果</a>来概括。现在我们不叫<code>tsc</code>而是叫<code>ttsc</code>。希望在将来，TypeScript直接支持转换/插件，让我们摆脱额外的依赖。</p>
<p class="graf graf--p">如果我们主要对在诸如webpack这样的捆绑器中使用我们的转换感兴趣，那么会有一些好消息。标准装载机如<code>ts-loader</code>或<code>awesome-typescript-loader</code>支持开箱即用的变压器，不需要<code>ttsc</code>。然而，由于这些加载器也可以与“自定义版本的TypeScript”一起工作，我们也可以将它们与<code>ttsc</code>结合使用，让我们可以自由地捆绑或直接传输。</p>
<h3 class="graf graf--h3">结论</h3>
<p class="graf graf--p">现在我们已经看到了如何使用TypeScript转换，以及它们会带来什么。在我们的示例中，我们探索了用附加函数调用来注释代码的能力，以声明我们想要为哪些类型生成附加信息。我们停留在生成阶段，没有查看访问包含的RTTI的一些API的创建。</p>
<p class="graf graf--p">这种插件带来的可能性是无限的。我们已经在Babel生态系统(以及TypeScript)中看到许多有创造力和聪明的人提出了很大的改进。虽然使用类型系统信息可能是一种方式，但另一种方式可以是对所用代码进行一些自省的简单扩展。</p>
<p class="graf graf--p">例如，有一个插件(<a class="markup--anchor markup--p-anchor" href="https://github.com/ZEISS/typescript-plugin-inner-jsx" target="_blank" rel="noopener noreferrer" data-href="https://github.com/ZEISS/typescript-plugin-inner-jsx">typescript-plugin-inner-jsx</a>)可以将组件中已经使用过的组件放到组件上，以一种更简单(隐式)的方式对组件进行样式化。存在许多其他伟大的打字稿变形器，尽管打字稿生态系统不会像巴别塔生态系统那样依赖于它们。</p>
<p class="graf graf--p">你对打字稿变形金刚有什么想法？你觉得这些有用吗？目前缺少什么能让它们变得更有用？请在评论中告诉我们！</p><div class="code-block code-block-21">
<div class="blog-plug inline-plug typescript-plug"><h2><a class="signup" href="https://lp.logrocket.com/blg/typescript-signup" target="_blank" rel="noopener noreferrer"> LogRocket </a>:全面了解您的网络和移动应用</h2>
<a href="https://lp.logrocket.com/blg/typescript-signup" class="signup" target="_blank" rel="noopener noreferrer"><img class="alignnone size-full wp-image-46 jetpack-lazy-image" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/><noscript><img data-lazy-fallback="1" class="alignnone size-full wp-image-46" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/></noscript></a>
<p>LogRocket 是一个前端应用程序监控解决方案，可以让您回放问题，就像问题发生在您自己的浏览器中一样。LogRocket不需要猜测错误发生的原因，也不需要向用户询问截图和日志转储，而是让您重放会话以快速了解哪里出错了。它可以与任何应用程序完美配合，不管是什么框架，并且有插件可以记录来自Redux、Vuex和@ngrx/store的额外上下文。</p>
<p>除了记录Redux操作和状态，LogRocket还记录控制台日志、JavaScript错误、堆栈跟踪、带有头+正文的网络请求/响应、浏览器元数据和自定义日志。它还使用DOM来记录页面上的HTML和CSS，甚至为最复杂的单页面和移动应用程序重新创建像素级完美视频。</p><div class="code-block code-block-23">
<div class="blog-plug inline-plug node-plug"><h2>200只<img src="../Images/61167b9d027ca73ed5aaf59a9ec31267.png" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2019/10/green-check.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" class=" jetpack-lazy-image" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/10/green-check.png"/> <noscript> <img data-lazy-fallback="1" src="../Images/61167b9d027ca73ed5aaf59a9ec31267.png" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/10/green-check.png"/> </noscript>显示器出现故障，生产中网络请求缓慢</h2><p>部署基于节点的web应用程序或网站是容易的部分。确保您的节点实例继续为您的应用程序提供资源是事情变得更加困难的地方。如果您对确保对后端或第三方服务的请求成功感兴趣，</p><a href="https://lp.logrocket.com/blg/node-signup" target="_blank">try LogRocket</a><p>. </p><a class="signup" href="https://lp.logrocket.com/blg/node-signup" target="_blank" rel="noopener noreferrer"><img src="../Images/cae72fd2a54c5f02a6398c4867894844.png" alt="LogRocket Network Request Monitoring" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2019/12/network-request-filter-2-1.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" class=" jetpack-lazy-image" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/12/network-request-filter-2-1.png"/><noscript><img data-lazy-fallback="1" src="../Images/cae72fd2a54c5f02a6398c4867894844.png" alt="LogRocket Network Request Monitoring" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/12/network-request-filter-2-1.png"/></noscript></a><a href="https://lp.logrocket.com/blg/node-signup" target="_blank" rel="noopener noreferrer">https://logrocket.com/signup/</a><p>LogRocket 就像是网络和移动应用程序的DVR，记录下用户与你的应用程序交互时发生的一切。您可以汇总并报告有问题的网络请求，以快速了解根本原因，而不是猜测问题发生的原因。</p><p>LogRocket检测您的应用程序以记录基线性能计时，如页面加载时间、到达第一个字节的时间、慢速网络请求，还记录Redux、NgRx和Vuex操作/状态。</p><a class="signup" href="https://lp.logrocket.com/blg/node-signup" target="_blank" rel="noopener noreferrer">Start monitoring for free</a><p>. </p></div>
</div>
<a class="signup" href="https://lp.logrocket.com/blg/typescript-signup" target="_blank" rel="noopener noreferrer">Try it for free</a><p>.</p></div>
</div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
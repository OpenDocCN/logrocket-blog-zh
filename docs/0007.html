<html>
<head>
<title>How (and when) to use React’s new Context API - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>如何(以及何时)使用React的新上下文API - LogRocket博客</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/how-and-when-to-use-reacts-new-context-api-b584e41b2704/#0001-01-01">https://blog.logrocket.com/how-and-when-to-use-reacts-new-context-api-b584e41b2704/#0001-01-01</a></blockquote><div><article class="article-post">
<figure class="wp-caption"/>
<p>因此，在即将发布的React，React 16.3.0中，<a href="https://reactjs.org/docs/context.html#why-not-to-use-context"> React上下文</a>将保持稳定，这在互联网上并不是什么新闻。React上下文是React的一个实验性特性，由于贡献者的<a href="https://github.com/facebook/react/pull/11818">多重</a> <a href="https://github.com/reactjs/rfcs/pull/2"> PRs </a>，React得到了更好的实现。</p>
<p>尽管这不是什么新闻，但花一分钟来学习何时以及如何使用它是值得的。这就是我们要做的。</p>
<h3><a class="anchor" href="https://dev.to/bnevilleoneill/how-and-when-to-use-reacts-new-context-api-131o#what-problem-does-context-api-solve" name="what-problem-does-context-api-solve"/> <strong>上下文API解决什么问题？</strong></h3>
<p>反应上下文是子组件访问父组件中的值的一种方式。</p>
<p>React中的一个常见问题是众所周知的<a href="https://medium.com/dailyjs/reacts-%EF%B8%8F-new-context-api-70c9fe01596b">支柱钻孔</a>。</p>
<p>道具钻取发生在这样的情况下，您希望从react树的顶部到底部获得状态，并且您最终通过不一定需要它们的组件传递道具。</p>
<p>React Context解决道具演练问题。它允许你与一个间接的孩子或父母分享道具或状态。</p>
<p>通常，您会使用像Redux或Mobx这样的状态管理库，但是如果您不想这样做呢？或者要传递的数据是如此之小，以至于使用状态管理库将是多余的。</p>
<p>这就是新的React上下文API的用武之地。</p>
<h3><a class="anchor" href="https://dev.to/bnevilleoneill/how-and-when-to-use-reacts-new-context-api-131o#what-happened-to-the-current-context-api" name="what-happened-to-the-current-context-api"/> <strong>当前上下文API怎么了？</strong></h3>
<p>嗯，当前的上下文API被认为是不稳定的，因为它是一个实验性的API，很可能会在React的未来版本中崩溃。此外，当前的和即将过时的上下文API在shouldComponentUpdate阻止上下文更改方面存在问题。</p>
<p>当一个中间组件使用shouldComponentUpdate进行更新时，React会自动假设没有更改，并重用整个子树。问题是，如果子树包含一个上下文消费者，消费者将不会收到最新的上下文。</p>
<h3><a class="anchor" href="https://dev.to/bnevilleoneill/how-and-when-to-use-reacts-new-context-api-131o#whats-new" name="whats-new"/> <strong>有什么新鲜事？</strong></h3>
<p>对于新的React上下文API，您应该熟悉三件事情:</p>
<p><strong>反应。createContext </strong></p>
<p>React.createContext用于初始化上下文，并传递初始值。它返回一个带有提供者和使用者的对象。提供者和消费者是成对出现的，也就是说，对于每个提供者，都有一个相应的消费者。</p>
<div class="highlight">
<pre class="highlight plaintext"><code>const Context = React.createContext();
</code></pre>
</div>
<p><strong>供应商</strong></p>
<p>Provider组件在树的更高层使用，它接受一个名为value的属性。它提供了一个根，在这个根上，树中的任何子节点都可以访问由上下文提供者提供的值。</p>
<div class="highlight">
<pre class="highlight plaintext"><code>render() { return ( \&lt;Provider value={this.state.contextValue}\&gt; {this.props.children} \&lt;/Provider\&gt; ); }
</code></pre>
</div>
<p>提供者接受一个上下文值作为属性。在提供者的子树中，任何匹配的消费者都可以访问它，不管它的嵌套有多深。</p>
<p><strong>消费者</strong></p>
<p>顾名思义，消费者使用被传递的数据，并通过使用render prop API来呈现数据。</p>
<div class="highlight">
<pre class="highlight plaintext"><code>render() { return ( \&lt;Consumer\&gt; {contextValue =\&gt; \&lt;Child arbitraryProp={contextValue} /\&gt;} \&lt;/Consumer\&gt; ) }
</code></pre>
</div>
<h3><a class="anchor" href="https://dev.to/bnevilleoneill/how-and-when-to-use-reacts-new-context-api-131o#using-react-context-api" name="using-react-context-api"/>使用React上下文API</h3>
<p>在我演示如何使用React Context之前，让我们看一下下面这个使用prop drilling来获取一些数据的示例，以便我们可以建立一点…等等…上下文。</p>
<blockquote class="embedly-card" data-card-controls="1" data-card-align="center" data-card-theme="light">

<p>yomete使用react、react-dom、react-scripts进行的经典道具演练</p>
</blockquote>
<p/><div class="code-block code-block-54">
<hr/>
<h3>更多来自LogRocket的精彩文章:</h3>

<hr/></div>
<p>上面的代码块只是一个简短的例子，说明了支柱钻探是如何工作的。我们必须从上到下传递道具数据，即使组件不一定需要它。</p>
<p>现在让我们看看如何使用React上下文来解决这个问题。要开始，你必须安装React 16.3的alpha版本。</p>

<blockquote class="embedly-card" data-card-controls="1" data-card-align="center" data-card-theme="light">

<p>使用React，react-dom，react-scripts通过yomete反应上下文</p>
</blockquote>
<p/>
<p>让我们看一下上面的代码块。</p>
<div class="highlight">
<pre class="highlight plaintext"><code>const JediContext = React.createContext();
</code></pre>
</div>
<p>我们首先初始化一个新的上下文，并将其设置为常量变量。它可以设置为任何值。</p>
<div class="highlight">
<pre class="highlight plaintext"><code>class JediProvider extends Component { state = { name: "Vader", side: "dark" }; render() { return ( \&lt;JediContext.Provider value={{ state: this.state, turnGood: () =\&gt; this.setState({ side: "good" }) }} \&gt; {this.props.children} \&lt;/JediContext.Provider\&gt; ); } }
</code></pre>
</div>
<p>在JediProvider组件中，我们在render()函数中创建了一个提供者上下文作为JediContext。提供商。JediContext。Provider接受一个设置为状态的prop called值和一个更新状态的函数。</p>
<p>现在我们有了一个提供者，我们如何消费数据，甚至是跨父组件到子组件的数据？</p>
<div class="highlight">
<pre class="highlight plaintext"><code>class App extends Component { render() { return ( \&lt;JediProvider\&gt; \&lt;Vader /\&gt; \&lt;/JediProvider\&gt; ); } }

const Vader = props =\&gt; { return \&lt;Luke /\&gt;; }; const Luke = props =\&gt; { return \&lt;KyloRen /\&gt;; };

const KyloRen = props =\&gt; { return ( \&lt;JediContext.Consumer\&gt; {context =\&gt; ( \&lt;React.Fragment\&gt; \&lt;p\&gt;My grandfather is {context.state.name} \&lt;/p\&gt; \&lt;p\&gt;He belonged to the {context.state.side} side\&lt;/p\&gt; \&lt;button onClick={context.turnGood}\&gt;Turn\&lt;/button\&gt; \&lt;/React.Fragment\&gt; )} \&lt;/JediContext.Consumer\&gt; ); };

render(\&lt;App /\&gt;, document.getElementById("root"));
</code></pre>
</div>
<p>首先要做的是用我们创建的提供者(即JediProvider)包装顶级应用程序组件的所有子组件。这意味着它的所有子节点都可以访问上下文中的值。</p>
<p>几乎就像上面的道具钻孔方法一样，虽然没有道具，没有钻孔，但是组件是相互传递的。不同之处在于底部的孩子是KyloRen。KyloRen组件使用JediContext。消费者将上下文作为呈现道具传递。因为上下文保存状态，所以您可以很容易地使用它来显示所需的数据。</p>
<p>如context.turnGood所示，我们还可以使用context来更改和更新状态。每当单击按钮时，它都会调用作为值添加到提供程序中的turnGood函数。</p>
<p>总的来说，这是一个比prop drilling方法更好的解决方案，你不必把不必要的道具传递给不需要它们的组件。</p>
<blockquote class="embedly-card" data-card-controls="1" data-card-align="center" data-card-theme="light">

<p>使用React，react-dom，react-scripts通过yomete反应上下文</p>
</blockquote>
<p/>
<h3><a class="anchor" href="https://dev.to/bnevilleoneill/how-and-when-to-use-reacts-new-context-api-131o#is-it-a-redux-killer" name="is-it-a-redux-killer"/> <strong>是Redux杀手吗？</strong></h3>
<p>不。新的上下文API有其局限性。</p>
<p>例如，它<a href="https://github.com/reactjs/rfcs/blob/master/text/0002-new-version-of-context.md#relies-on-strict-comparison-of-context-values">鼓励使用不可变的</a>或持久的数据结构或上下文值的严格比较，这可能被证明是困难的，因为许多常见的数据源依赖于突变。</p>
<p>另一个<a href="https://github.com/reactjs/rfcs/blob/master/text/0002-new-version-of-context.md#only-one-provider-type-per-consumer">限制</a>是新的上下文API只允许消费者从单个提供者类型读取值，一个消费者对一个提供者。不像当前的API，它允许一个消费者连接到多个提供者。</p>
<h3>什么时候应该使用React上下文？</h3>
<p>当您只想进行简单的状态管理时，或者当您想深入传递一些道具而又不想使用Redux或MobX带来的过度杀伤时，您可以使用它。</p>
<p>上下文API应该更新，并包含在React的下几个更新中。看到Context API的更新和特性变化肯定会很有趣。</p><div class="code-block code-block-17">
<div class="blog-plug inline-plug react-plug" vwo-el-id="26283398190">
<h2 vwo-el-id="41600691720"><a href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener"> LogRocket </a>:全面了解您的生产React应用</h2><p>调试React应用程序可能很困难，尤其是当用户遇到难以重现的问题时。如果您对监视和跟踪Redux状态、自动显示JavaScript错误以及跟踪缓慢的网络请求和组件加载时间感兴趣，</p><a href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" vwo-el-id="19356441070">try LogRocket</a><p>. </p><a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="19356441380">
<img class="first-react-image alignnone size-full wp-image-46 jetpack-lazy-image jetpack-lazy-image--handled" src="../Images/f300c244a1a1cf916df8b4cb02bec6c6.png" vwo-el-id="18272717540" data-lazy-loaded="1" data-original-src="https://files.readme.io/27c94e7-Image_2017-06-05_at_9.46.04_PM.png"/>
</a>
<a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="19356441690">
<img class="second-react-image alignnone size-full wp-image-46 jetpack-lazy-image jetpack-lazy-image--handled" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" vwo-el-id="30720362350" data-lazy-loaded="1" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/>
</a>
<p vwo-el-id="28675660440" class="">LogRocket 结合了会话回放、产品分析和错误跟踪，使软件团队能够创建理想的web和移动产品体验。这对你来说意味着什么？</p>
<p>LogRocket不是猜测错误发生的原因，也不是要求用户提供截图和日志转储，而是让您回放问题，就像它们发生在您自己的浏览器中一样，以快速了解哪里出错了。</p>
<p>不再有嘈杂的警报。智能错误跟踪允许您对问题进行分类，然后从中学习。获得有影响的用户问题的通知，而不是误报。警报越少，有用的信号越多。</p>
<p vwo-el-id="28675660750">LogRocket Redux中间件包为您的用户会话增加了一层额外的可见性。LogRocket记录Redux存储中的所有操作和状态。</p>
<p vwo-el-id="28675661060">现代化您调试React应用的方式— <a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="40093418840">开始免费监控</a>。</p>
</div></div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
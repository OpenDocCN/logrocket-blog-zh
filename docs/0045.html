<html>
<head>
<title>Frontend in 2018: More consensus, less complexity - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>2018年的前端:更多共识，更少复杂性</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/what-im-looking-for-from-frontend-in-2018-2f1de300b548/#0001-01-01">https://blog.logrocket.com/what-im-looking-for-from-frontend-in-2018-2f1de300b548/#0001-01-01</a></blockquote><div><article class="article-post">
<figure><img decoding="async" src="../Images/68f36745db2162d3c99fc74d43cb6822.png" data-height="1280" data-width="1920" data-lazy-src="https://storage.googleapis.com/blog-images-backup/1*8ITf_jyAEhKNKb7KWgGylA.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" class=" jetpack-lazy-image" data-original-src="https://storage.googleapis.com/blog-images-backup/1*8ITf_jyAEhKNKb7KWgGylA.png"/><noscript><img data-lazy-fallback="1" decoding="async" src="../Images/68f36745db2162d3c99fc74d43cb6822.png" data-height="1280" data-width="1920" data-original-src="https://storage.googleapis.com/blog-images-backup/1*8ITf_jyAEhKNKb7KWgGylA.png"/></noscript></figure>
<p><a href="https://blog.logrocket.com/frontend-in-2017-the-important-parts-4548d085977f" target="_blank" rel="noopener noreferrer"> 2017年是前端web开发不平凡的一年</a>。</p>
<p>像React和Angular这样的框架继续在社区中享有大规模的支持，但像Vue这样的新竞争者也在流行中爆发。Webpack仍然是构建工具的首选，NPM是软件包系统的首选。WebAssembly以前所未有的速度向众多令人兴奋的新用例打开了web。像GraphQL这样的技术革新了API在web应用程序中的编写和使用方式。</p>
<p>与此同时，语言本身也在不断发展。ECMAScript标准的2017版增加了异步函数，大大改善了开发人员编写异步代码时的体验。现在所有主流浏览器都支持它们。另一个值得注意的增加是共享内存和原子操作。</p>
<p>然而，共享内存于1月5日在所有主流浏览器中被暂时禁用，因为有消息称它们向浏览器开放了涉及投机执行的旁路攻击<a href="https://security.googleblog.com/2018/01/todays-cpu-vulnerability-what-you-need.html" target="_blank" rel="noopener noreferrer"/>。</p>
<p>预计今年某个时候，当浏览器供应商找到一种方法来防止这种漏洞时，共享内存将变得可用。</p>
<figure><a href="https://logrocket.com/signup/" target="_blank" rel="noopener noreferrer"><img decoding="async" src="../Images/576491a4328cdae7545b9efa365439da.png" data-height="750" data-width="3212" data-lazy-src="https://storage.googleapis.com/blog-images-backup/1*2H5cnv_UzdWhAwB6KOAOhg.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" class=" jetpack-lazy-image" data-original-src="https://storage.googleapis.com/blog-images-backup/1*2H5cnv_UzdWhAwB6KOAOhg.png"/><noscript><img data-lazy-fallback="1" decoding="async" src="../Images/576491a4328cdae7545b9efa365439da.png" data-height="750" data-width="3212" data-original-src="https://storage.googleapis.com/blog-images-backup/1*2H5cnv_UzdWhAwB6KOAOhg.png"/></noscript></a></figure>
<h3>库和框架</h3>
<h4>反应</h4>
<p>React经历了非常多事的2017年，9月份发布了<a href="https://reactjs.org/blog/2017/09/26/react-v16.0.html" target="_blank" rel="noopener noreferrer"> React 16 </a>。这是React迄今为止最大的版本，增加了<strong>片段</strong>(您现在可以返回一个数组，而不必将所有内容包装在一个无用的&lt; div &gt;元素中)、更好的<strong>错误处理</strong>和错误边界(错误现在会导致React在根或特殊错误边界组件处卸载)、<strong>门户</strong>(您现在可以将React子级渲染到React DOM层次结构之外的DOM节点中)和<strong>流</strong>(允许服务器端渲染应用程序将渲染流传送到客户端，而不必等待整个渲染)</p>
<p>此外，React还<a href="https://reactjs.org/blog/2017/12/07/introducing-the-react-rfc-process.html" target="_blank" rel="noopener noreferrer">切换到RFC流程</a>，为React团队贡献创意。任何人都可以提交RFC提案，只要这些提案改变了React API。React团队已经发布了他们的<a href="https://github.com/reactjs/rfcs/pull/2" target="_blank" rel="noopener noreferrer">提议的上下文变更</a>作为第一个RFC，这是一个非常有趣的阅读。</p>
<p>该群体还提交了几项提案，涵盖了许多有趣的新功能，包括:</p>
<ul>
<li><a href="https://github.com/reactjs/rfcs/pull/4" target="_blank" rel="noopener noreferrer">渲染函数参数</a> —为了减少代码混乱，它建议渲染函数将属性、状态和上下文作为参数。</li>
<li><a href="https://github.com/reactjs/rfcs/pull/10" target="_blank" rel="noopener noreferrer"> setState返回一个承诺</a>——当您需要setState是同步的并且您处于一个带有async / await的环境中时，它会很好地配对。</li>
<li><a href="https://github.com/reactjs/rfcs/pull/6" target="_blank" rel="noopener noreferrer">异步安全静态生命周期挂钩</a>——对传统的基于类的应用编程接口的彻底改造，使其更容易处理异步数据，同时避免不必要的渲染，并为功能组件提供清晰的升级路径。</li>
</ul>
<p>当然，并不是所有的提议都会出现在未来的版本中，但是React团队向社区开放规划是件好事。随着最近像<a href="https://github.com/yarnpkg/rfcs" target="_blank" rel="noopener noreferrer"> Yarn </a>和<a href="https://github.com/emberjs/rfcs" target="_blank" rel="noopener noreferrer"> Ember </a>这样的项目采用RFC过程，RFC过程在社区中变得更加流行。</p>
<p>由于设置现代web开发所需的所有不同工具相对复杂，样板项目在React社区中一直很受欢迎。大多数建议用户克隆项目来使用，并从那里开始构建。这对初学者来说可能很困惑，因为他们被一个复杂的“白板”淹没了，这个白板上有大量他们不理解的依赖项和配置代码。</p>
<p>脸书的<a href="https://github.com/facebookincubator/create-react-app" target="_blank" rel="noopener noreferrer"> create-react-app </a>不同——它是一个CLI工具，包装了Webpack、Babel、PostCSS和Jest，允许零配置开发。去年它的受欢迎程度持续增长，从2017年初的18k GitHub stars到年底的40k。它还允许您通过提供“弹出”命令来停止使用create-react-app，该命令安装依赖项并复制配置文件，以便您可以手动更改它们。可以说，这是React近年来受欢迎程度增长的部分原因。</p>
<p>对于服务器渲染的React应用，<a href="https://github.com/zeit/next.js" target="_blank" rel="noopener noreferrer"> next.js </a>是一个流行的框架选择。它提供了一个“通用”web应用程序所需的所有工具，而不需要复杂的配置和设置。这一点很重要，因为最近人们对通用(或“同构”)应用的兴趣似乎有所下降，转而青睐渐进式web应用——可能是因为开发的复杂性。如果你开始一个新项目，我会认真考虑将next.js作为一个框架选择。</p>
<p>我认为React社区最终会开发类似于create-react-app的东西，但目标是更复杂的应用程序。</p>
<p>Next.js接近这一目标，但它的目标是服务器渲染的应用程序，这绝不是大多数。在我看来，配置和易用性之间有一个最佳平衡点，这是任何框架都没有达到的。</p>
<blockquote><p>对于越来越多对构建系统配置的复杂性和维护它所需的开发时间失望的开发人员来说,“包含电池”方法的吸引力将变得诱人。</p></blockquote>
<h4>有角的</h4>
<p>尽管Angular的最新版本(<a href="https://github.com/angular/angular/blob/master/CHANGELOG.md" target="_blank" rel="noopener noreferrer">版本5.1.3 </a>)于1月3日发布，但AngularJS项目(又名旧Angular 1.x版本)仍在积极开发中，甚至<a href="https://github.com/angular/angular.js/blob/master/CHANGELOG.md" target="_blank" rel="noopener noreferrer">在2017年12月18日发布了版本1.6.8 </a>。许多大公司仍然在使用Angular的传统版本，因此重要的速度改进和安全修复已经被反向移植到AngularJS。</p>
<p>目前还不知道谷歌对传统项目的支持将于何时结束，但在过去<a href="https://stackoverflow.com/questions/37037251/angularjs-1-x-support-lifecycle" target="_blank" rel="noopener noreferrer">官方说法</a>是，在大部分网络流量流向angular.io域名(下一代版本的网站)而不是angularjs.org之前，支持不会结束。然而，鉴于传统版本使用相当自由的<a href="https://github.com/angular/angular.js/blob/master/LICENSE" target="_blank" rel="noopener noreferrer">麻省理工学院许可</a>，即使官方支持在2018年消失，你也可以期待进一步的发展。</p>
<p>最近的Angular版本令人印象深刻，尤其是最新的v5版本。它继续通过提供创新功能(如模板的提前编译和服务人员集成到一个整洁且易于设置的包中)在每个版本中都将自己与竞争对手区分开来。</p>
<p>虽然这些特性当然适用于任何应用程序，但Angular的亮点在于它的集成工具。Angular CLI 易于使用，现在支持使用<a href="https://developers.google.com/web/fundamentals/architecture/app-shell" target="_blank" rel="noopener noreferrer">应用外壳</a>快速生成通用和渐进式web应用。</p>
<p>React社区信奉一种不那么固执己见的前端开发哲学。在很大程度上，开发人员必须手动设置这些复杂的特性，除非他们使用<a href="https://github.com/topics/boilerplate" target="_blank" rel="noopener noreferrer">众多样板项目</a>中的一个。许多开发人员更喜欢自己设置东西，这样他们就能理解系统的所有部分。</p>
<p>有时感觉网络社区在固执己见和集中到不固执己见和分散之间循环。人们不禁想知道React社区最终是否会朝着另一个方向发展。</p>
<blockquote><p>在参与了几个大型定制React / Redux / Webpack项目之后，基本上已经为您设置好了一切，并且“正常工作”是一个非常有吸引力的前景。</p></blockquote>
<p>鉴于最近的发布，看看Angular在未来一年是否会变得更受欢迎将是一件有趣的事情。虽然很难衡量，但当你查看NPM的下载量时，Angular似乎并没有增长多少。React】继续扩大领先优势，尤其是在去年。它现在每天的NPM下载量几乎是现在的三倍。</p>
<h4>某视频剪辑软件</h4>
<p><a href="https://github.com/vuejs/vue" target="_blank" rel="noopener noreferrer"> Vue </a>已经成为2017年非常流行的视图框架替代React。两者都利用了虚拟DOM，并且都是基于组件的，非常轻量级。在JavaScript 2017年的State survey中Vue被列为继Angular 1和React之后第三个最常用的前端框架<a href="https://stateofjs.com/2017/front-end/results" target="_blank" rel="noopener noreferrer">。最值得注意的是，这是调查中最“愿意学习”的框架。</a></p>
<p>Vue核心团队计划在今年二月之前发布2.6版本,主要关注错误处理、功能组件和服务器端渲染。在React的带领下，他们还计划在未来的版本中只针对evergreen浏览器。</p>
<blockquote><p>Vue在过去的一年里越来越受欢迎，但是很难看到它取代React成为前端视图库之王。</p></blockquote>
<p>关于它对来自Angular 的<a href="https://medium.com/reverdev/why-we-moved-from-angular-2-to-vue-js-and-why-we-didnt-choose-react-ef807d9f4163" target="_blank" rel="noopener noreferrer">开发者的吸引力已经写了很多，我希望这种吸引力会继续下去。一般的观点是，与React不同，Vue不要求你使用JSX，与Angular不同，它不要求你使用TypeScript。</a></p>
<p>它的模板语言也和Angular的非常相似。此外，Vue有一系列维护良好的软件包，它们共同提供与Angular类似的功能，但以一种更分散的方式提供。</p>
<h3>模块捆扎机</h3>
<h4>网络包</h4>
<p><a href="https://medium.com/webpack/webpack-3-official-release-15fd2dd8f07b" target="_blank" rel="noopener noreferrer"> Webpack 3 </a>于2017年6月发布，并将范围提升作为其旗舰功能。scope hoisting不是将每个模块包装在一个单独的外壳中，而是将所有模块放在一个外壳中，而不会破坏它们。这可以显著改善包的执行时间和包的大小。这是另一个模块捆绑器<a href="https://github.com/rollup/rollup" target="_blank" rel="noopener noreferrer"> Rollup </a>的一个显著特征，它一直是Webpack 2及以后功能的灵感来源。</p>
<p>Webpack团队<a href="https://medium.com/webpack/road-to-webpack-4-week-20-21-1641d03ce06e" target="_blank" rel="noopener noreferrer">为Webpack v4计划了</a>许多重要的特性，在撰写这篇博文时它还处于alpha阶段，预计很快就会发布。主要特性是WebAssembly模块支持——目标是使Webpack中的WASM模块像ECMAScript模块一样易于使用。还计划对Webpack生成CSS的方式进行彻底检查，而不是将CSS注入JavaScript Webpack 4现在将生成CSS资产。</p>
<p>新版本还将关注构建性能——这个问题被Webpack社区投票选为重中之重。</p>
<blockquote><p>在我看来，Webpack还应该更多地关注文档和配置。尽管Webpack擅长灵活的配置，但它牺牲了用户体验。</p></blockquote>
<p>已经有人提出了Webpack零配置模式，但是尽管像package这样的其他模块打包器大受欢迎，它还没有被优先考虑。</p>
<h4>包裹</h4>
<p><a href="https://parceljs.org/" target="_blank" rel="noopener noreferrer"> Parcel </a>于2017年末在GitHub上引起了巨大的轰动，在不到一个月的时间里聚集了令人印象深刻的一万四千颗星星。人们对Webpack混乱的配置和缓慢的构建时间越来越不满，它利用这一点推出了一个“零配置”设置。它已经有了几个由Webpack推广的重要的模块捆绑特性，比如代码分割和热模块替换。</p>
<p>剩下的大部分开发似乎集中在添加更小的功能，使其与Webpack不相上下——如入口点和一个全面的插件系统。</p>
<p>我将在2018年密切关注包裹的发展，看看它是否会成为Webpack统治地位的主要挑战者，这将是一件有趣的事情。</p>
<blockquote><p>尽管Webpack的最新版本引入了有价值的功能，新的文档站点也是一个巨大的改进，但感觉Webpack现在是颠覆性的。</p></blockquote>
<p>为复杂的用例配置Webpack简直是一项艰巨的任务。</p>
<p>如果Parcel成功地利用了开发人员的挫折感，并以较少的配置提供了一个更简单的替代方案，那么它可以发展成一个大项目。</p>
<h4>其他工具</h4>
<p>Gulp和Browserify仍然被成千上万的项目以某种形式使用，但它们不再被认为是前端构建工具的前沿。它们的持续开发对于现有系统的维护非常重要，并且它们可能仍然会在新项目中用于非常特殊的用例；然而，在过去几年中，开发人员普遍认为它们过于复杂，需要太多的手动设置。去年，在Webpack日益扩大的领先优势中期，这两家公司在NPM的下载量都持续相对稳定的下降。</p>
<h3>工具</h3>
<h4>以打字打的文件</h4>
<p>TypeScript有一个计划在一月份发布的版本<a href="https://github.com/Microsoft/TypeScript/wiki/Roadmap#27-january-2018" target="_blank" rel="noopener noreferrer"/>，其中包括新的ECMAScript特性，比如<a href="https://github.com/tc39/proposal-numeric-separator" target="_blank" rel="noopener noreferrer">数字分隔符</a>和一些涉及对象文字和类的高级类型系统改进。同样计划中的还有<a href="https://github.com/Microsoft/TypeScript/pull/19675" target="_blank" rel="noopener noreferrer">一个改变</a>，它将改进TypeScript的模块系统处理非ECMAScript模块的方式。</p>
<p>这使得它更符合Babel处理模块互操作性的方式。希望这将使使用不同类型的模块时更容易使用TypeScript，这对于新用户来说通常是一个令人困惑的痛点。这个版本还计划通过增加对ECMAScript模块自动转换的支持来改进已经令人印象深刻的重构特性。</p>
<blockquote><p>微软的TypeScript明显战胜了 Flow(来自脸书的对手类型检查工具)。这有几个原因，但在我看来，这只是微软运行TypeScript项目的好坏的问题。</p></blockquote>
<p>与<a href="https://github.com/facebook/flow/releases" target="_blank" rel="noopener noreferrer">零星的、较小的流量发布</a>相比，微软每月发布<a href="https://github.com/Microsoft/TypeScript/releases" target="_blank" rel="noopener noreferrer">大量</a>。使用TypeScript的工具也更好，使用<a href="https://github.com/palantir/tslint" target="_blank" rel="noopener noreferrer"> tslint </a>的出色linter支持和使用Visual Studio代码(和许多其他编辑器)的奇妙<a href="https://code.visualstudio.com/docs/languages/typescript" target="_blank" rel="noopener noreferrer">编辑器支持</a>，它们提供了使用Flow根本不可能实现的自动转换。</p>
<p>一个是否是更好的类型系统几乎无关紧要——我敢打赌大多数开发人员更关心支持和易用性。</p>
<p>此外，围绕TypeScript的社区要大得多。与<a href="https://github.com/flowtype/flow-typed" target="_blank" rel="noopener noreferrer">流类型</a>提供的类型定义相比，通过<a href="https://github.com/DefinitelyTyped/DefinitelyTyped" target="_blank" rel="noopener noreferrer"> DefinitelyTyped </a>项目可以为TypeScript提供更多的流行NPM包的类型定义。如果不说别的，这个事实对任何使用Flow的项目的长期生存能力都是一个严重的威胁。</p>
<h3>移动的</h3>
<p>通用web应用程序最初流行是在React推出的时候。这项创新允许前端web应用程序首先在服务器上呈现，代价是开发复杂性。虽然它们仍然受欢迎，但它们绝不是事实上的做事方式。</p>
<p>对于移动设备，开发者今天开始专注于开发所谓的<a href="https://developers.google.com/web/progressive-web-apps/" target="_blank" rel="noopener noreferrer">渐进式网络应用</a>——这是由谷歌发起的一项倡议，旨在使网络应用对移动用户更加友好。对于开发者来说，这意味着更加关注速度和移动用户体验。这是通过使用新技术实现的，如服务工作者提供离线支持，应用程序清单文件定制应用程序在操作系统中的外观。这可以看作是响应式网页设计的自然发展。</p>
<p>谷歌还赞助了<a href="https://www.ampproject.org/" target="_blank" rel="noopener noreferrer">加速移动页面</a> (AMP)项目，该项目通过标准化一种轻量级文档格式来大幅减少移动设备上网页的加载时间，这种格式使用了<a href="https://developer.mozilla.org/en-US/docs/Web/Web_Components" target="_blank" rel="noopener noreferrer"> Web组件</a>和谷歌提供的缓存。它很快被网络上的主要内容出版商采用，然而关于出版商<a href="https://www.wsj.com/articles/google-amp-gets-mixed-reviews-from-publishers-1477648838" target="_blank" rel="noopener noreferrer">广告收入</a>的争议仍然存在，并且担心通过在谷歌的服务器上托管<a href="https://www.theregister.co.uk/2017/05/19/open_source_insider_google_amp_bad_bad_bad/" target="_blank" rel="noopener noreferrer">内容而放弃控制权。</a></p>
<p>如果我们希望网络保持竞争力和吸引力，我们需要与移动应用竞争。</p><div class="code-block code-block-54">
<hr/>
<h3>更多来自LogRocket的精彩文章:</h3>

<hr/></div>
<blockquote><p>虽然他们不能做手机应用程序能做的一切，但是渐进式网络应用程序是保持网络长期健康发展的重要一步。我预计它们在未来会变得更受欢迎，甚至是强制性的。</p></blockquote>
<h3>把所有的放在一起</h3>
<p>总的来说，frontend已经趋向于围绕现有项目和web开发的许多不同部分进行整合。React、Webpack、TypeScript继续变得更加流行。Vue和Parcel似乎会对各自领域的领先者构成更大的威胁；与此同时，Angular和Browserify等老牌技术仍然存在，但正在慢慢衰落。</p>
<p>一些趋势还在继续，比如基于组件的设计。最近没有一个新图书馆受到欢迎，挑战了这个网络。这绝不是一个新概念，最近它的复兴也不局限于网络开发。我不认为应用程序架构会很快发生根本性的变化。</p>
<p>有一种趋势是开发人员更友好的，“固执己见”的工具。你可以从Webpack和React生态系统的复杂性中看到这一点。简单比复杂好，但是如果不复杂，很难满足各种各样的用例。</p>
<blockquote><p>前端开发需要的是更多的共识。它经常被嘲笑为过于复杂，我也有同感。</p></blockquote>
<p>虽然最近的重点是吸引新的开发人员，但我认为我们也应该注意一般企业web项目的复杂性——包括应用程序本身和围绕它的构建工具。</p><div class="code-block code-block-17">
<div class="blog-plug inline-plug react-plug" vwo-el-id="26283398190">
<h2 vwo-el-id="41600691720"><a href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener"> LogRocket </a>:全面了解您的生产React应用</h2><p>调试React应用程序可能很困难，尤其是当用户遇到难以重现的问题时。如果您对监视和跟踪Redux状态、自动显示JavaScript错误以及跟踪缓慢的网络请求和组件加载时间感兴趣，</p><a href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" vwo-el-id="19356441070">try LogRocket</a><p>. </p><a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="19356441380">
<img class="first-react-image alignnone size-full wp-image-46 jetpack-lazy-image jetpack-lazy-image--handled" src="../Images/f300c244a1a1cf916df8b4cb02bec6c6.png" vwo-el-id="18272717540" data-lazy-loaded="1" data-original-src="https://files.readme.io/27c94e7-Image_2017-06-05_at_9.46.04_PM.png"/>
</a>
<a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="19356441690">
<img class="second-react-image alignnone size-full wp-image-46 jetpack-lazy-image jetpack-lazy-image--handled" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" vwo-el-id="30720362350" data-lazy-loaded="1" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/>
</a>
<p vwo-el-id="28675660440" class="">LogRocket 结合了会话回放、产品分析和错误跟踪，使软件团队能够创建理想的web和移动产品体验。这对你来说意味着什么？</p>
<p>LogRocket不是猜测错误发生的原因，也不是要求用户提供截图和日志转储，而是让您回放问题，就像它们发生在您自己的浏览器中一样，以快速了解哪里出错了。</p>
<p>不再有嘈杂的警报。智能错误跟踪允许您对问题进行分类，然后从中学习。获得有影响的用户问题的通知，而不是误报。警报越少，有用的信号越多。</p>
<p vwo-el-id="28675660750">LogRocket Redux中间件包为您的用户会话增加了一层额外的可见性。LogRocket记录Redux存储中的所有操作和状态。</p>
<p vwo-el-id="28675661060">现代化您调试React应用的方式— <a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="40093418840">开始免费监控</a>。</p><div class="code-block code-block-20">
<div class="blog-plug inline-plug vue-inline"><h2>像用户一样体验您的Vue应用</h2><p>调试Vue.js应用程序可能会很困难，尤其是当用户会话期间有几十个(如果不是几百个)突变时。如果您对监视和跟踪生产中所有用户的Vue突变感兴趣，</p><a href="https://lp.logrocket.com/blg/vue-signup" target="_blank">try LogRocket</a><p>. </p><a class="signup" href="https://lp.logrocket.com/blg/vue-signup" target="_blank" rel="noopener noreferrer"><img class="alignnone size-full wp-image-46 jetpack-lazy-image" src="../Images/0d269845910c723dd7df26adab9289cb.png" alt="LogRocket Dashboard Free Trial Banner" data-lazy-src="https://files.readme.io/00591d0-687474703a2f2f692e696d6775722e636f6d2f6a3049327856572e706e67.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://files.readme.io/00591d0-687474703a2f2f692e696d6775722e636f6d2f6a3049327856572e706e67.png"/><noscript><img data-lazy-fallback="1" class="alignnone size-full wp-image-46" src="../Images/0d269845910c723dd7df26adab9289cb.png" alt="LogRocket Dashboard Free Trial Banner" data-original-src="https://files.readme.io/00591d0-687474703a2f2f692e696d6775722e636f6d2f6a3049327856572e706e67.png"/></noscript></a><a href="https://lp.logrocket.com/blg/vue-signup" target="_blank" rel="noopener noreferrer">https://logrocket.com/signup/</a><p>LogRocket 就像是网络和移动应用程序的DVR，记录你的Vue应用程序中发生的一切，包括网络请求、JavaScript错误、性能问题等等。您可以汇总并报告问题发生时应用程序的状态，而不是猜测问题发生的原因。</p><p>LogRocket Vuex插件将Vuex突变记录到LogRocket控制台，为您提供导致错误的环境，以及出现问题时应用程序的状态。</p><p>现代化您调试Vue应用的方式- <a class="signup" href="https://lp.logrocket.com/blg/vue-signup" target="_blank" rel="noopener noreferrer">开始免费监控</a>。</p><div class="code-block code-block-21">
<div class="blog-plug inline-plug typescript-plug"><h2><a class="signup" href="https://lp.logrocket.com/blg/typescript-signup" target="_blank" rel="noopener noreferrer"> LogRocket </a>:全面了解您的网络和移动应用</h2>
<a href="https://lp.logrocket.com/blg/typescript-signup" class="signup" target="_blank" rel="noopener noreferrer"><img class="alignnone size-full wp-image-46 jetpack-lazy-image" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/><noscript><img data-lazy-fallback="1" class="alignnone size-full wp-image-46" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/></noscript></a>
<p>LogRocket 是一个前端应用程序监控解决方案，可以让您回放问题，就像问题发生在您自己的浏览器中一样。LogRocket不需要猜测错误发生的原因，也不需要向用户询问截图和日志转储，而是让您重放会话以快速了解哪里出错了。它可以与任何应用程序完美配合，不管是什么框架，并且有插件可以记录来自Redux、Vuex和@ngrx/store的额外上下文。</p>
<p>除了记录Redux操作和状态，LogRocket还记录控制台日志、JavaScript错误、堆栈跟踪、带有头+正文的网络请求/响应、浏览器元数据和自定义日志。它还使用DOM来记录页面上的HTML和CSS，甚至为最复杂的单页面和移动应用程序重新创建像素级完美视频。</p>
<a class="signup" href="https://lp.logrocket.com/blg/typescript-signup" target="_blank" rel="noopener noreferrer">Try it for free</a><p>.</p></div>
</div>
</div>


</div>
</div></div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
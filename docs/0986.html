<html>
<head>
<title>Introduction to Hegel - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>黑格尔- LogRocket博客简介</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/introduction-to-hegel/#0001-01-01">https://blog.logrocket.com/introduction-to-hegel/#0001-01-01</a></blockquote><div><article class="article-post">
<p><a href="https://hegel.js.org/" target="_blank" rel="noopener noreferrer"> Hegel </a>是一个静态类型检查器库，它可以帮助你在不实际运行你的代码的情况下尽可能早地识别打字错误。就像TypeScript和Flow一样，Hegel会在您编写代码时检测出代码中存在的任何类型错误信息。</p>
<p>Hegel合并了许多TypeScript和Flow的设计原则，比如拥有类型注释和类型推断，而没有引入像<a href="https://blog.logrocket.com/why-typescript-enums-suck/" target="_blank" rel="noopener noreferrer"> TypeScript的enum</a>这样的新语言特性。当使用Hegel时，您甚至不需要添加注释就可以编写纯JavaScript，就像Flow一样。</p>
<p>在本指南中，我们将展示Hegel与TypeScript和Flow的不同之处，并引导您在下一个项目中如何开始使用Hegel。</p>
<h2 id="hegelandtypescript">黑格尔对打字稿</h2>
<p>让我们来分解一下黑格尔和TypeScript之间的一些最显著的区别。</p>
<h3 id="abilitytoskiptypeannotation">跳过类型注释</h3>
<p>黑格尔有一个强大的类型推理系统，可以让你编写更少的类型注释。</p>
<pre>// Hegel
const promisify = fn =&gt; arg =&gt; Promise.resolve(fn(arg));
const id = promisify(x =&gt; x);
// And "upperStr" will be inferred as "Promise&lt;string&gt;"
const upperStr = id("It will be inferred").then(str =&gt; str.toUpperCase());

// TypeScript
const promisify = fn =&gt; arg =&gt; Promise.resolve(fn(arg));
const id = promisify(x =&gt; x);
// And "upperStr" will be inferred as "Promise&lt;any&gt;"
const upperStr = id("It will be inferred").then(str =&gt; str.toUpperCase());
</pre>
<h3 id="nounexpectedruntimeerrors">没有意外的运行时错误</h3>
<p>TypeScript的目的不是应用一个可靠的或可证明正确的类型系统，这意味着它不能保证您在运行时不会有任何类型错误。黑格尔反其道而行之，实现一个强类型系统来保证你的代码是有效的。</p>
<pre>// Hegel
const doubles: Array&lt;number&gt; = [Math.PI, Math.E];
// Error: Type "Array&lt;number&gt;" is incompatible with type "Array&lt;number | string&gt;"
const numbersToShow: Array&lt;number | string&gt; = doubles;
numbersToShow.push(42..toString(2));
const rounded = doubles.map(double =&gt; double.toFixed());

// TypeScript
const doubles: Array&lt;number&gt; = [Math.PI, Math.E];
const numbersToShow: Array&lt;number | string&gt; = doubles;
numbersToShow.push(42..toString(2));
// Uncaught TypeError: double.toFixed is not a function
doubles.map(double =&gt; double.toFixed());
</pre>
<h3 id="typederrors">键入的错误</h3>
<p>黑格尔为函数实现了推理和注释，这使您能够理解代码抛出了什么错误。</p>
<pre>// Type of "assertIsTrue" function is "(boolean) =&gt; undefined throws TypeError"
function assertIsTrue(arg) {
    if (!arg) {
        throw new TypeError("arg is invalid")
    }
}
try {
    assertIsTrue(false);
} catch (e) {
    // Type of "e" variable is "TypeError | unknown"
}

// TypeScript
function assertIsTrue(arg) {
    if (!arg) {
        throw new TypeError("arg is invalid")
    }
}
try {
    assertIsTrue(false);
} catch (e) {
    // Type of "e" variable is "any"
}
</pre>
<h3 id="nonewconstructors">没有新的构造函数</h3>
<p>与TypeScript不同，黑格尔不是一种超集语言。这意味着JavaScript之外的构造函数和特性，比如decorators、<a href="https://www.typescriptlang.org/docs/handbook/classes.html#ecmascript-private-fields" target="_blank" rel="noopener noreferrer">私有类字段</a>、名称空间、枚举和TypeScript中的其他好东西，在Hegel中都是不可用的。</p>
<pre>// TypeScript
enum UserStatus {
  Active,
  Muted,
  Banned
}
class User {
  constructor(
    public name: string,
    public status: UserStatus
  ) {}
}
const Anatoly = new User("Anatoly", UserStatus.Active);

// Hegel
const UserStatus = Object.freeze({
  Active: "Active",
  Muted: "Muted",
  Banned: "Banned"
});
class User {
    name: string;
    status: $Values&lt;$TypeOf&lt;UserStatus&gt;&gt;
    constructor(name, status) {
        this.name = name;
        this.status = status;
    }
}
const Anatoly = new User("Anatoly", UserStatus.Active);
</pre>
<h3 id="notypecoercionandanytype">无类型强制和<code>any</code>类型</h3>
<p>因为黑格尔关心的是实现一个健全的类型系统，它没有类型强制或<code>any</code>类型。</p>
<pre>// Error: There is no "any" type in Hegel.
const something: any = null;

// Error: Type cast does not exist in Hegel
(null: any).call();
</pre>
<h2 id="hegelandflow">黑格尔和心流</h2>
<p>Hegel与Flow有许多相似之处，因为它们都是静态类型检查器库。以下是黑格尔和心流之间的一些显著差异。</p>
<h3 id="bettertypeinference">更好的类型推理</h3>
<p>Flow很难推断出泛型类型，所以如果您想拥有正确的类型，请对其进行注释。这是因为Flow.js是通过函数用法来推断函数类型的。</p>
<p>黑格尔通过函数声明来推断函数类型。因此，黑格尔的推论是多态型的。</p>
<pre>// Hegel
// Type of "id" function is "&lt;_a&gt;(_a) =&gt; _a"
const id = x =&gt; x;
// Type of "num" variable is "number"
let num = id(4);
// Type of "str" variable is "string"
let str = id("4");
// Type of "anotherId" variable is "&lt;_a&gt;(_a) =&gt; _a"
let anotherId = id(id);

// Flow
// Type of "id" function is "(number | string | ((x: V$1) =&gt; V$2)) =&gt; (number | string | ((x: V$1) =&gt; V$2)"
const id = x =&gt; x;
// Type of "num" variable is "number | string | ((x: V$1) =&gt; V$2)"
let num = id(4);
// Type of "str" variable is "number | string | ((x: V$1) =&gt; V$2)"
let str = id("4");
// Type of "anotherId" variable is "number | string | ((x: V$1) =&gt; V$2)"
let anotherId = id(id);
</pre>
<h3 id="typederrors-1">键入的错误</h3>
<p>就像使用TypeScript一样，Flow对错误没有有用的类型推断，将返回一个<code>empty</code>类型。</p>
<pre>// Type of "assertIsTrue" function is "(boolean) =&gt; undefined throws TypeError"
function assertIsTrue(arg) {
    if (!arg) {
        throw new TypeError("arg is invalid")
    }
}
try {
    assertIsTrue(false);
} catch (e) {
    // Type of "e" variable is "TypeError | unknown"
}

/* @flow */
function assertIsTrue(arg) {
    if (!arg) {
        throw new TypeError("arg is invalid")
    }
}
try {
    assertIsTrue(false);
} catch (e) {
    // Type of "e" variable is "empty"
}
</pre>
<h3 id="nocustomlibrarydefinitionlanguage">没有自定义库定义语言</h3>
<p>黑格尔没有像Flow一样创建自己的<a href="https://flow.org/en/docs/libdefs/" target="_blank" rel="noopener noreferrer">自定义库定义</a>，而是实现了与TypeScript中相同的<a href="https://www.typescriptlang.org/docs/handbook/declaration-files/introduction.html" target="_blank" rel="noopener noreferrer"> d.ts定义</a>。每一个有打字稿定义的库都应该和黑格尔合作。</p>
<h3 id="hegelisimplementedinjavascript">黑格尔是用JavaScript实现的</h3>
<p>Flow主要是在OCaml中实现的，这使得JavaScript开发人员很难对项目做出贡献。</p>
<p>Hegel是用JavaScript实现的，因此使用它的开发人员可以帮助解决任何PRs或将来出现的问题。</p>
<h3 id="notypecoercionandanytype-1">无类型强制和<code>any</code>类型</h3>
<p>Flow既有类型强制，也有<code>any</code>类型，就像TypeScript一样。</p>
<pre>// Error: There is no "any" type in Hegel.
const something: any = null;

// Error: Type cast does not exist in Hegel
(null: any).call();
</pre>
<h2 id="gettingstartedwithhegel">黑格尔入门</h2>
<p>要开始在您的项目中使用Hegel，请从终端安装它的CLI包。请注意，您需要Node.js版本12或更高版本。</p>
<pre># globally
$ npm install -g @hegel/cli

# locally
$ npm install -D @hegel/cli
</pre>
<p>安装完成后，创建一个新的<code>index.js</code>文件，并编写一个带有类型注释的变量。</p>
<pre>let price :number = "7"
</pre>
<p>从项目的根目录运行<code>hegel</code>命令。它将扫描所有的<code>.js</code>文件，查找输入错误。</p>
<pre>hegel
./index.js:1
&gt; 1 | let price :number = "7"
    |    ^^^^^^^^^^^^^^^^^^^ Type "'7'" is incompatible with type "number"
</pre>
<p>就这样，你一切都准备好了！你不需要创建一个<code>.tsx</code>文件或者在你的文件上写<code>@flow</code>注释。</p><div class="code-block code-block-54">
<hr/>
<h3>更多来自LogRocket的精彩文章:</h3>

<hr/></div>
<h2 id="settingupforproduction">为生产做准备</h2>
<p>就像Flow一样，当您运行文件时，像Node这样的JavaScript运行时引擎会抛出一个错误，因为它不能识别注释语法。</p>
<p>为了让它正常运行，你必须用<a href="https://babeljs.io/" target="_blank" rel="noopener noreferrer"> Babel </a>或<a href="https://www.npmjs.com/package/flow-remove-types" target="_blank" rel="noopener noreferrer"> flow-remove-types </a>去掉黑格尔的类型语法。</p>
<h3 id="usingbabel">使用巴别塔</h3>
<p>安装所需的Babel包。</p>
<pre>$ npm i -D @babel/core @babel/cli @babel/preset-flow
</pre>
<p>在项目的根目录下写一个<code>.babelrc</code>文件，使用下面的预置。</p>
<pre>{
  "presets": [["@babel/preset-flow", { "all": true }]]
}
</pre>
<p>现在，您可以从终端运行它。</p>
<pre>npx babel index.js -d build/
</pre>
<p>您也可以将其作为脚本添加到您的<code>package.json</code>中。</p>
<pre>{
  "scripts": {
    "build": "babel index.js -d build/",
  }
}
</pre>
<p>然后，运行脚本。</p>
<pre>npm run build</pre>
<h2 id="usingflowremovetypes">使用<code>flow-remove-types</code></h2>
<p>安装软件包。</p>
<pre>npm i -D flow-remove-types
</pre>
<p>将构建脚本添加到您的<code>package.json</code>中，就像处理Babel一样。</p>
<pre>{
  "scripts": {
    "build": "flow-remove-types index.js --out-dir build/",
  }
}
</pre>
<p>最后，运行脚本。</p>
<pre>npm run build</pre>
<h2 id="conclusion">结论</h2>
<p>Hegel是一个新的静态类型检查器库，它通过将静态的、强大的类型系统与强大的类型推理结合起来，试图将TypeScript的所有优点结合在一起。它试图使用纯JavaScript实现一个极简但完全静态的类型检查器，因此您不需要使用特定的文件扩展名或注释来使用它。</p>
<p>黑格尔还附带了一个<a href="https://hegel.js.org/try#DYUwLgBADgTglgYxALggOwK4FsBGIYQC8EARAOwlA" target="_blank" rel="noopener noreferrer">交互式在线编辑器</a>，你可以在那里测试它的极限。别忘了查看官方的<a href="https://hegel.js.org/docs" target="_blank" rel="noopener noreferrer"> Hegel文档</a>来了解它的所有特性。</p><div class="code-block code-block-21">
<div class="blog-plug inline-plug typescript-plug"><h2><a class="signup" href="https://lp.logrocket.com/blg/typescript-signup" target="_blank" rel="noopener noreferrer"> LogRocket </a>:全面了解您的网络和移动应用</h2>
<a href="https://lp.logrocket.com/blg/typescript-signup" class="signup" target="_blank" rel="noopener noreferrer"><img class="alignnone size-full wp-image-46 jetpack-lazy-image" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/><noscript><img data-lazy-fallback="1" class="alignnone size-full wp-image-46" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/></noscript></a>
<p>LogRocket 是一个前端应用程序监控解决方案，可以让您回放问题，就像问题发生在您自己的浏览器中一样。LogRocket不需要猜测错误发生的原因，也不需要向用户询问截图和日志转储，而是让您重放会话以快速了解哪里出错了。它可以与任何应用程序完美配合，不管是什么框架，并且有插件可以记录来自Redux、Vuex和@ngrx/store的额外上下文。</p>
<p>除了记录Redux操作和状态，LogRocket还记录控制台日志、JavaScript错误、堆栈跟踪、带有头+正文的网络请求/响应、浏览器元数据和自定义日志。它还使用DOM来记录页面上的HTML和CSS，甚至为最复杂的单页面和移动应用程序重新创建像素级完美视频。</p><div class="code-block code-block-27">
<div class="blog-plug inline-plug vanilla-javascript-cta"><h2>通过理解上下文，更容易地调试JavaScript错误</h2>
<p>调试代码总是一项单调乏味的任务。但是你越了解自己的错误，就越容易改正。</p>
<p>LogRocket 让你以新的独特的方式理解这些错误。我们的前端监控解决方案跟踪用户与您的JavaScript前端的互动，让您能够准确找出导致错误的用户行为。</p>
<a href="https://lp.logrocket.com/blg/javascript-signup" class="signup" target="_blank" rel="noopener noreferrer"><img class="alignnone size-full wp-image-46 jetpack-lazy-image" src="../Images/cbfed9be3defcb505e662574769a7636.png" alt="LogRocket Dashboard Free Trial Banner" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2020/06/reproduce-javascript-errors.gif?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/06/reproduce-javascript-errors.gif"/><noscript><img data-lazy-fallback="1" class="alignnone size-full wp-image-46" src="../Images/cbfed9be3defcb505e662574769a7636.png" alt="LogRocket Dashboard Free Trial Banner" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/06/reproduce-javascript-errors.gif"/></noscript></a>
<p>LogRocket记录控制台日志、页面加载时间、堆栈跟踪、慢速网络请求/响应(带有标题+正文)、浏览器元数据和自定义日志。理解您的JavaScript代码的影响从来没有这么简单过！</p>
<a class="signup" href="https://lp.logrocket.com/blg/javascript-signup" target="_blank" rel="noopener noreferrer">Try it for free</a><p>.</p></div>


</div>
<a class="signup" href="https://lp.logrocket.com/blg/typescript-signup" target="_blank" rel="noopener noreferrer">Try it for free</a><p>.</p></div>
</div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
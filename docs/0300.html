<html>
<head>
<title>Cleaning up your Vue.js code with ES6+ - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>用ES6+日志火箭博客清理你的Vue.js代码</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/cleaning-up-your-vue-js-code-with-es6/#0001-01-01">https://blog.logrocket.com/cleaning-up-your-vue-js-code-with-es6/#0001-01-01</a></blockquote><div><article class="article-post">
<p>ES6是web向前迈出的一大步，它引入了许多新特性，解决了所有JavaScript开发人员面临的各种难题。但是它的一些特性特别适合于解决使用Vue.js开发时出现的问题。我们将了解每个功能的工作原理，以及它为您的应用程序和网站解决了什么问题。事不宜迟，我们开始吧！</p>
<h3>特性#1:方法定义速记</h3>
<p>我想说的第一个特性有一个纯粹的美学效果，但是它确实有助于使你的代码尽可能的可读。ES6引入了这个简写来更简洁地为对象分配功能，我们在Vue中一直为方法、计算属性、观察器和生命周期方法这样做。下面是一个如何将其应用于Vue代码的示例:</p>
<pre><code>// Without shorthand
{
    methods: {
        getValue: function() { // ... }
    },
    computed: {
        halfValue: function() { // ... }
    },
    created: function() { // ... }
}

// With ES6 shorthand
{
    methods: {
        getValue() { // ... }
    },
    computed: {
        halfValue() { // ... }
    },
    created() { // ... }
}</code></pre>
<p>同样，这是一个很小的变化，但是对于可读性来说会有很大的不同。</p>
<h3>特性#2:析构</h3>
<p>析构是ES6中添加的一个特性，它使得从对象中提取属性并将其赋给变量变得更加容易。在我们开始研究这如何在我们的Vue代码中帮助我们之前，这里有一个关于对象析构如何工作的非常基本的例子:</p>
<pre>const person = { name: 'Jake', email: '<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="1f757e747a5f7a677e726f737a317c7072">[email protected]</a>', phone: '555-555-5555' }

// With destructuring
const { name, email, phone } = person

// Without destructuring
const name = person.name
const email = person.email
const phone = person.phone</pre>
<p>上面的两个例子(有/没有析构)完全一样。使用析构的版本只是一个更干净的代码模式来达到相同的结果。</p>
<p>那么如何在你的Vue代码库中使用析构呢？在Vue中，析构主要表现在两个方面:从<code>this</code>析构属性，以及从作用域插槽接收属性。让我们浏览一下每一个用例。</p>
<h4>从<code>this</code>开始解构</h4>
<p>在Vue中，要引用Vue或组件实例上的数据、方法或任何东西，可以使用<code>this</code>。但是有时不需要反复引用<code>this</code>就可以访问那些实例属性。让我向您展示一个将属性从<code>this</code>拉入本地函数范围的小技巧:</p>
<pre>data() {
    return {
        endpoint: 'example.com/api',
    }
},
methods: {
    postForm() { // this is just an example method we can call in submitForm }
    submitForm() {
        // Without destructuring
        const endpoint = this.endpoint
        const postForm = this.postForm

        // With destructuring
        const { endpoint, postForm } = this
  }
}</pre>
<p>这种模式不仅允许我们使用不带<code>this</code>前缀的变量，还让我们清楚地知道我们的函数所依赖的数据和/或方法。</p>
<h4>作用域插槽</h4>
<p>插槽允许我们将模板传递到组件中，作用域插槽允许组件向这些模板提供一些组件数据。如果您不熟悉作用域插槽，这可能没有多大意义，但希望这个示例至少可以强化析构的工作方式，以及如何在许多不同的场景中使用它:</p>
<pre>&lt;!-- Without Destructuring --&gt;
&lt;User v-slot="slotProps"&gt;
    &lt;div&gt;Name: {{ slotProps.name }}&lt;/div&gt;
    &lt;div&gt;Email: {{ slotProps.email }}&lt;/div&gt;
&lt;/User&gt;

&lt;!-- With Destructuring --&gt;
&lt;User v-slot="{ name, email }"&gt;
    &lt;div&gt;Name: {{ name }}&lt;/div&gt;
    &lt;div&gt;Email: {{ email }}&lt;/div&gt;
&lt;/User&gt;
</pre>
<p>与“从<code>this</code>析构”模式不同，析构我们的槽属性不仅允许我们在不使用<code>slotProps</code>前缀的情况下访问我们的变量，而且它准确地向我们显示了我们通过槽接受的属性。</p>
<h3>特性#3:函数数组方法</h3>
<p>ES6引入了许多内置于阵列原型中的新方法。这些方法允许您以不同的方式与数组中的数据进行交互，比如转换每个项目(<code>map</code>)、对数组进行排序或过滤数组。我在Vue应用中常用的最喜欢的数组方法是<code>filter</code>、<code>map</code>、<code>forEach</code>和<code>includes</code>。这里有一个使用<code>filter</code>的例子:</p>
<pre>computed: {
    // Without "filter" functional array method
    oldFilteredItems() {
        const filtered = []
        for (const item in this.items) {
            if(item.value &gt; 10) {
                filtered.push(item)
            }
        }
        return filtered
    },
    // With "filter" functional array method
    filteredItems() {
        return this.items.filter((item) =&gt; item.value &gt; 10)
    }
}</pre>
<p>这减少了我们必须写(和读！)从七行变成只有一行！</p>
<h3>功能#4:箭头功能</h3>
<p>在我们学习箭头函数，它们是如何工作的，以及如何在你的Vue代码中使用它们之前，让我们看看它们解决的问题。查看以下代码:</p>
<pre>data() {
    return {
        scrolled: false
    }
},
mounted() {
    window.addEventListener('scroll', function() {
        this.scrolled = true
    })
}</pre>
<p>这个代码不起作用。为什么？因为当你创建一个新函数时，<code>this</code>的值被重新绑定为等于函数实例而不是Vue实例。如果您曾经遇到过这个问题，您可能已经尝试了以下方法来解决这个问题:</p>
<pre>mounted() {
    var self = this
    window.addEventListener('scroll', function() {
        self.scrolled = true
    })
}</pre>
<p>虽然这确实“修复”了问题，但是让<code>var self = this</code>散落在代码中绝对不是理想的，尤其是当这是一个可以用(drumroll please) … arrow函数解决的问题时！</p>
<p>箭头函数与标准函数非常相似，但一个关键的区别是箭头函数不重新绑定<code>this</code>，这在Vue应用中非常有帮助！这是先前示例的更新版本，其中我们用箭头函数替换了标准函数，因此<code>this</code>不会被重新绑定:</p>
<pre>mounted() {
    window.addEventListener('scroll', () =&gt; {
        this.scrolled = true
    })
}</pre>
<p>我发现在编写Vue应用时，遵循以下规则很有帮助:在Vue组件中，<code>this</code>应该总是引用Vue实例。如果您使用箭头函数，这并不难实现，而且它使您的代码更容易理解。</p>
<p>如果你不熟悉箭头函数，它们绝对值得学习。虽然它们在这种情况下特别有用，但它们也允许您编写更简洁的函数，这适用于更多的情况。它们的另一个好处是与数组方法成对出现！如果你看看我在<strong>特性#4 </strong>中的<code>filteredItems</code>函数，你会发现我使用了一个箭头函数作为<code>filter</code>数组方法的第一个参数！</p>
<h3>包扎</h3>
<p>在我结束之前，我想谈谈我是如何着手确定这四个改进的，以及你如何学会发现你的代码库中可以改进的地方。这里有几个小技巧！</p>
<h4>寻找重复</h4>
<p>并不是所有的重复都是不好的，但是在代码中看到任何重复的东西都会让你想知道是否有机会进行良好的抽象，或者学习一种新的模式或语言特性来解决你正在处理的问题。</p>
<h4>注意语言的变化</h4>
<p>如果不跟上JavaScript的变化，就不可能知道通过使用数组方法可以简化代码中的许多循环。也就是说，你不必“深入”钻研每一件新事物，但要试着了解你所使用的语言有哪些可用之处。然后，当你遇到一个问题，希望你会想起一个语言功能，解决你所面临的问题。</p>
<h4>看别人的代码</h4>
<p>如果你在一个团队中工作，要求和他们一起评审别人的代码，或者要求他们评审你的代码。看到其他人的代码，或者他们对你的代码的评论，会让你了解到其他人是如何以不同的方式做事的。当你看到一个你不认识的代码模式时，找出它是什么，如果它有意义，就把它应用到你的代码中。</p><div class="code-block code-block-20">
<div class="blog-plug inline-plug vue-inline"><h2>像用户一样体验您的Vue应用</h2><p>调试Vue.js应用程序可能会很困难，尤其是当用户会话期间有几十个(如果不是几百个)突变时。如果您对监视和跟踪生产中所有用户的Vue突变感兴趣，</p><a href="https://lp.logrocket.com/blg/vue-signup" target="_blank">try LogRocket</a><p>. </p><a class="signup" href="https://lp.logrocket.com/blg/vue-signup" target="_blank" rel="noopener noreferrer"><img class="alignnone size-full wp-image-46 jetpack-lazy-image" src="../Images/0d269845910c723dd7df26adab9289cb.png" alt="LogRocket Dashboard Free Trial Banner" data-lazy-src="https://files.readme.io/00591d0-687474703a2f2f692e696d6775722e636f6d2f6a3049327856572e706e67.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://files.readme.io/00591d0-687474703a2f2f692e696d6775722e636f6d2f6a3049327856572e706e67.png"/><noscript><img data-lazy-fallback="1" class="alignnone size-full wp-image-46" src="../Images/0d269845910c723dd7df26adab9289cb.png" alt="LogRocket Dashboard Free Trial Banner" data-original-src="https://files.readme.io/00591d0-687474703a2f2f692e696d6775722e636f6d2f6a3049327856572e706e67.png"/></noscript></a><a href="https://lp.logrocket.com/blg/vue-signup" target="_blank" rel="noopener noreferrer">https://logrocket.com/signup/</a><p>LogRocket 就像是网络和移动应用程序的DVR，记录你的Vue应用程序中发生的一切，包括网络请求、JavaScript错误、性能问题等等。您可以汇总并报告问题发生时应用程序的状态，而不是猜测问题发生的原因。</p><p>LogRocket Vuex插件将Vuex突变记录到LogRocket控制台，为您提供导致错误的环境，以及出现问题时应用程序的状态。</p><p>现代化您调试Vue应用的方式- <a class="signup" href="https://lp.logrocket.com/blg/vue-signup" target="_blank" rel="noopener noreferrer">开始免费监控</a>。</p></div>


</div>
<h3>进一步阅读</h3>

<hr/>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
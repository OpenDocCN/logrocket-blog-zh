<html>
<head>
<title>What’s new in TypeScript 3.8 - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>TypeScript 3.8中的新特性- LogRocket博客</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/whats-new-in-typescript-3-8/#0001-01-01">https://blog.logrocket.com/whats-new-in-typescript-3-8/#0001-01-01</a></blockquote><div><article class="article-post">
<p><a href="https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-8.html" target="_blank" rel="noopener noreferrer"> Typescript 3.8 </a>发布于2020年2月20日。此版本包括对编译器、性能和编辑器的更改。</p>
<p>在这篇文章中，我将回顾编译器的五个重要变化:</p>
<ul>
<li>仅键入的导入和导出</li>
<li>将*导出为ns语法</li>
<li>ES2020私有字段</li>
<li>顶级等待</li>
<li>JSDoc属性修饰符</li>
</ul>
<p>在撰写本文时，<a href="https://github.com/microsoft/TypeScript/releases/tag/v3.8.3" target="_blank" rel="noopener noreferrer">版本3.8.3 </a>已经发布。所以首先，升级到最新版本:</p>

<p>在终端窗口中，您可以使用以下命令来确认您使用的是最新版本:</p>
<pre>tsc --version</pre>
<p>现在，让我们先来回顾一下仅限类型的导入/导出功能。</p>
<h2>仅键入的导入和导出</h2>
<p>这个特性为导入和导出声明带来了新的语法，以及一个新的编译器选项<code>importsNotUsedAsValues</code>:</p>
<pre>import type { MyType } from "./my-module.js";
// ...
export type { MyType };</pre>
<p>这让您可以更好地控制如何在输出中处理导入语句，这在使用<code>--isolatedModules</code>选项、<code>transpileModule</code> API或Babel进行编译时特别有用。</p>
<p>默认情况下，当导入仅用作类型时，TypeScript会删除导入语句。例如，考虑以下情况:</p>
<pre>// lion.ts
export default class Lion {}

// zoo.ts
import Lion from './lion';
let myLion: Lion;</pre>
<p>这将是您编译<code>zoo.ts</code>时的输出:</p>
<pre>// zoo.js
let myLion: Lion;</pre>
<p>通常，这不会是一个问题。但是如果在<code>Lion</code>模块中有副作用呢:</p>
<pre>// lion.ts
export default class Lion {}
console.log("Here's an important message about lions: ... ");</pre>
<p>在这种情况下，如果从输出中删除import语句，则<code>console.log</code>语句将永远不会执行。</p>
<p>如果像下面这样声明，import语句也将被删除:</p>
<pre>import {TypeA, Type2} from "./my-module";</pre>
<p>但是，如果您像这样声明它，它将保留在输出中:</p>
<pre>import "./my-module";</pre>
<p>有点困惑，对吧？</p>
<p>还有一个问题。在下面的代码中，你能分辨出<code>X</code>是数值还是类型吗？</p>
<pre>import { X } from "./my-module.js";

export { X };</pre>
<p>知道这一点可能很重要，如果<code>X</code>只是一个类型，Babel和TypeScript的<code>transpileModule</code> API将输出不能正确工作的代码，TypeScript的<code>isolatedModules</code>标志将生成一个警告。</p>
<p>另一方面，我们在导出方面也有类似的问题，例如，类型的重新导出应该被省略，但是编译器不能判断我们只是在单文件Babel编译期间重新导出了一个类型。</p>
<p>在TypeScript 3.8中，<code>import type</code>和<code>export type</code>明确了类型的导入/导出。</p>
<p>以下是一些有效的使用方法:</p>
<pre>import type MyType from './my-module';
import type { MyTypeA, MyTypeB } from './my-module';
import type * as Types from './my-module';

export type { MyType };
export type { MyType } from './module';</pre>
<p>以下是一些无效的方法:</p>
<pre>import { type MyType } from './my-module';
import type MyType, { FunctionA } from './my-module';

export { FunctionA, type MyType } from './my-module';</pre>
<p>请记住，如果该类型未用作类型，编译器会将其标记为错误:</p>
<pre>import type Lion from './lion';
let myLion: Lion; // Valid
myLion = new Lion(); // Invalid: 'Lion' cannot be used as a value because it was imported using 'import type'.</pre>
<p>使用<code>import type</code>时，行为是像往常一样从JavaScript文件中删除导入声明。但是在TypeScript 3.8中，当使用<code>import</code>时，行为可以用编译器选项<code>importsNotUsedAsValue</code>来控制，它可以取值:</p>
<ul>
<li><code>default</code>，省略进口申报</li>
<li><code>preserve</code>，保存进口申报单，对执行副作用有用</li>
<li><code>error</code>，类似于<code>preserve</code>，但是每当一个<code>import</code>可以被写成一个<code>import type</code>时就会增加一个错误</li>
</ul>
<p>这样，通过将选项<code>"importsNotUsedAsValue":"preserve"</code>添加到<code>tsconfig.json</code>文件:</p>
<pre>// tsconfig.json
{
    "compilerOptions": {
      // ...
      "importsNotUsedAsValues": "preserve"
    },
    // ...
}</pre>
<p>这段打字稿代码:</p>
<pre>import Lion from './lion';
let myLion: Lion;</pre>
<p>编译成这段JavaScript代码:</p>
<pre>import './Lion';
let myLion;</pre>
<h2>将*导出为ns语法</h2>
<p>TypeScript支持一些更新的<a href="https://tc39.es/ecma262/" target="_blank" rel="noopener noreferrer"> ECMAScript 2020特性</a>，比如<code>export * as namespace</code>声明。</p>
<p>有时候，像这样的东西很有用:</p>
<pre>import * as animals from "./animals.js";
export { animals };</pre>
<p>它将另一个模块的所有成员作为单个成员公开。</p>
<p>在ES2020中，这可以用一句话来表达:</p>
<pre>export * as animals from "./animals";</pre>
<p>TypeScript 3.8支持此语法。</p>
<p>如果您为ES2020配置模块:</p>
<pre>// tsconfig.json
{
    "compilerOptions": {
      "module": "ES2020",
      // ...
    }
}</pre>
<p>TypeScript将输出没有修改的语句:</p>
<pre>// allAnimals.ts
export * as animals from "./animals";

// allAnimals.js
export * as animals from "./animals";</pre>
<p>但是，如果您之前对模块进行了配置，例如:</p>
<pre>// tsconfig.json
{
    "compilerOptions": {
      "module": "ES2015",
      // ...
    }
}</pre>
<p>TypeScript将输出这两个声明:</p>
<pre>import * as animals_1 from "./animals";
export { animals_1 as animals };</pre>
<h2>ES2020私有字段</h2>
<p>ES2020还为私有字段带来了新的语法。这里有一个例子:</p>
<pre>class Lion {
    #age: number;
    constructor(age: number) {
        this.#age = age;
    }
    getAge() {
        return this.#age;
    }
}</pre>
<p>私有字段以<code>#</code>字符开始，就像用<code>private</code>关键字标记的字段一样，它们的作用域是它们包含的类。</p>
<p>为什么是<code>#</code>字？嗯，显然所有其他酷字符都已经被<a href="https://github.com/tc39/proposal-class-fields/blob/master/PRIVATE_SYNTAX_FAQ.md#why-was-the-sigil--chosen-among-all-the-unicode-code-points" target="_blank" rel="noopener noreferrer">占用或者可能导致无效代码</a>。</p>
<p>但是，有一些规则。</p>
<p>首先，你不能在同一个字段上同时使用<code>private</code>修饰符和<code>#</code>字符(或者<code>public</code>修饰符，尽管这种组合无论如何都没有意义)。</p>
<p>这是否意味着<code>private</code>修改器最终会消失？</p>
<p>在写这篇文章的时候，有一个关于这个的<a href="https://github.com/microsoft/TypeScript/issues/31670" target="_blank" rel="noopener noreferrer">公开讨论，但是当前的计划是让它保持原样。</a></p>
<p>那么，你应该用哪一个呢？</p>
<p>嗯，这取决于你对隐私的要求有多严格。</p>
<p>关于<code>private</code>修饰符的事情是，它只被TypeScript识别，这意味着访问限制只在编译时执行，私有约束将从生成的JavaScript代码中删除，在那里私有字段可以毫无问题地被访问。</p><div class="code-block code-block-54">
<hr/>
<h3>更多来自LogRocket的精彩文章:</h3>

<hr/></div>
<p>另一方面，<code>#</code>字符将保留在JavaScript代码中，使得该字段在类之外完全不可访问。</p>
<p>使用<code>#</code>的另一个规则是私有字段必须在使用前声明:</p>
<pre>class Lion {
    constructor(age: number) {
          // Error: Property '#age' does not exist on type 'Lion'.ts
          this.#age = age;
    }
}
</pre>
<p>另外，请注意，您必须用<code>this</code>引用私有字段，否则，将会标记一个错误:</p>
<pre>class Lion {
    #age: number;
    // ...
    getAge() {
        // The following line throws two errors:
        // 1. Private identifiers are not allowed outside class bodies.
        // 2. Cannot find name '#age'
        return #age;
    }
}</pre>
<p>为了使用标有<code>#</code>的字段，您必须以ECMAScript 2015 (ES6)或更高版本为目标:</p>
<pre>// tsconfig.json
{
    "compilerOptions": {
      "target": "ES6",
      // ...
    }
}</pre>
<p>原因是实施隐私的实现使用了<code>WeakMap</code> s，不能以不导致内存泄漏的方式进行聚合填充，不是所有的运行时都优化了<code>WeakMap</code> s的使用。相反，带有<code>private</code>修饰符的字段适用于所有目标，并且速度更快。</p>
<p>例如，这个TypeScript类:</p>
<pre>// lion.ts
class Lion {
    #age: number;
    constructor(age: number) {
        this.#age = age;
    }
    getAge() {
        return this.#age;
    }
}</pre>
<p>输出这个:</p>
<pre>// lion.js
var __classPrivateFieldSet = (this &amp;&amp; this.__classPrivateFieldSet) || function (receiver, privateMap, value) {
    if (!privateMap.has(receiver)) {
        throw new TypeError("attempted to set private field on non-instance");
    }
    privateMap.set(receiver, value);
    return value;
};
var __classPrivateFieldGet = (this &amp;&amp; this.__classPrivateFieldGet) || function (receiver, privateMap) {
    if (!privateMap.has(receiver)) {
        throw new TypeError("attempted to get private field on non-instance");
    }
    return privateMap.get(receiver);
};
var _age;
class Lion {
    constructor(age) {
        _age.set(this, void 0);
        __classPrivateFieldSet(this, _age, age);
    }
    getAge() {
        return __classPrivateFieldGet(this, _age);
    }
}
_age = new WeakMap();</pre>
<p>从以下代码的输出中，您可以看到<code>age</code>属性在它的类之外是不可见的:</p>
<pre>const lion = new Lion(5);
console.log(lion); // 'Lion {}'
console.log(Object.keys(lion)); // '[]'
console.log(lion.getAge()); // 5</pre>
<h2>顶级等待</h2>
<p>在JavaScript中，我们可以使用带有await表达式的<code>async</code>函数来执行异步操作:</p>
<pre>async function getLionInformation() {
    let response = await fetch('/animals/lion.json');
    let lion = await response.json();
    return lion;
}

getLionInformation().then((value) =&gt; console.log(value));</pre>
<p>但是<code>await</code>表达式只允许在<code>async</code>函数体中使用，我们不能在顶级代码中使用它们(例如，在Chrome上使用开发人员控制台时，这可能很有用):</p>
<pre>// Syntax error
let response = await fetch('/animals/lion.json');
let lion = await response.json();
console.log(lion);</pre>
<p>然而，<a href="https://tc39.es/proposal-top-level-await/" target="_blank" rel="noopener noreferrer">顶层等待</a>(目前是ECMAScript的第三阶段提案)允许我们在模块或脚本的顶层直接使用<code>await</code>。</p>
<p>TypeScript 3.8支持顶级await，由于带有<code>import</code>和<code>export</code>表达式的文件被认为是模块，所以即使一个简单的<code>export {}</code>也足以使这种语法起作用:</p>
<pre>let response = await fetch('/animals/lion.json');
let lion = await response.json();
console.log(lion);

export {}</pre>
<p>TypeScript中唯一的限制是:</p>
<ul>
<li><code>target</code>编译器选项必须是<code>es2017</code>或以上，</li>
<li><code>module</code>编译器选项必须是<code>esnext</code>或<code>system</code></li>
</ul>
<h2>JSDoc属性修饰符</h2>
<p>JSDoc允许我们将文档注释直接添加到JavaScript源代码中，因此JSDoc工具可以扫描代码并生成HTML文档网站。</p>
<p>但是TypeScript使用JSDoc对JavaScript文件进行类型检查不仅仅是为了文档目的。</p>
<p>这是可能的，因为有两个<a href="https://www.typescriptlang.org/docs/handbook/compiler-options.html" target="_blank" rel="noopener noreferrer">编译器选项</a>:</p>
<ul>
<li><code>allowJs</code>，允许TypeScript编译JavaScript文件</li>
<li><code>checkJs</code>，与上面的选项结合使用，允许TypeScript报告JavaScript文件中的错误</li>
</ul>
<p>TypeScript 3.8增加了对三种可访问性修饰符的支持:</p>
<ul>
<li><code>@public</code>，这意味着该属性可以在任何地方使用(默认行为)</li>
<li><code>@private</code>，这意味着一个属性只能在定义它的类中使用</li>
<li><code>@protected</code>，这意味着一个属性只能在定义它的类和所有派生的子类中使用</li>
</ul>
<p>例如:</p>
<pre>// lion.js
// @ts-check
class Lion {
    constructor() {
        /** @private */
        this.age = 5;
    }
}

// Error: Property 'age' is private and only accessible within class 'Lion'.
console.log(new Lion().age);</pre>
<p>和<code>@readonly</code>修饰符，它确保属性只在初始化期间赋值:</p>
<pre>// lion.js
// @ts-check
class Lion {
    constructor(ageParam) {
        /** @readonly */
        this.age = ageParam;
    }
    setAge(ageParam) {
        // Error: Cannot assign to 'age' because it is a read-only property
        this.age = ageParam;
    }
}</pre>
<p>你可以在这里了解更多关于类型检查JavaScript文件<a href="https://www.typescriptlang.org/docs/handbook/type-checking-javascript-files.html" target="_blank" rel="noopener noreferrer">，以及</a><a href="https://www.typescriptlang.org/docs/handbook/type-checking-javascript-files.html#supported-jsdoc" target="_blank" rel="noopener noreferrer">支持的JSDoc标签</a>。</p>
<h2>结论</h2>
<p>在这篇文章中，您了解了TypeScript 3.8中的五个新特性:仅类型导入和导出、<code>export * as ns</code>语法、ES2020私有字段、顶级await和JSDoc属性修饰符。</p>
<p>当然还有更多的新功能。</p>
<p><strong>对于编译器</strong>:</p>
<ul>
<li>在Linux和<code>watchOptions</code>上更好的目录监视(更多信息<a href="https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-8.html#-better-directory-watching-on-linux-and-watchoptions" target="_blank" rel="noopener noreferrer">在这里</a>)</li>
<li>“快速和宽松”的增量检查(更多信息<a href="https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-8.html#-fast-and-loose-incremental-checking" target="_blank" rel="noopener noreferrer">此处</a></li>
</ul>
<p><strong>为编者(更多信息<a href="https://devblogs.microsoft.com/typescript/announcing-typescript-3-8/#editor-features" target="_blank" rel="noopener noreferrer">此处</a> ) </strong>:</p>

<p><strong>和一些突破性的变化</strong>:</p>
<ul>
<li>对具有索引签名的联合进行更严格的可分配性检查</li>
<li>没有推论的可选参数被正确地标记为隐式<code>any</code></li>
<li>JSDoc中的<code>object</code>不再是<code>noImplicitAny</code>下的<code>any</code></li>
</ul>
<p>你可以在这里找到关于这些<a href="https://github.com/microsoft/TypeScript/wiki/Breaking-Changes" target="_blank" rel="noopener noreferrer">突破性变化的更多信息。</a></p>
<p>编码快乐！</p><div class="code-block code-block-21">
<div class="blog-plug inline-plug typescript-plug"><h2><a class="signup" href="https://lp.logrocket.com/blg/typescript-signup" target="_blank" rel="noopener noreferrer"> LogRocket </a>:全面了解您的网络和移动应用</h2>
<a href="https://lp.logrocket.com/blg/typescript-signup" class="signup" target="_blank" rel="noopener noreferrer"><img class="alignnone size-full wp-image-46 jetpack-lazy-image" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/><noscript><img data-lazy-fallback="1" class="alignnone size-full wp-image-46" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/></noscript></a>
<p>LogRocket 是一个前端应用程序监控解决方案，可以让您回放问题，就像问题发生在您自己的浏览器中一样。LogRocket不需要猜测错误发生的原因，也不需要向用户询问截图和日志转储，而是让您重放会话以快速了解哪里出错了。它可以与任何应用程序完美配合，不管是什么框架，并且有插件可以记录来自Redux、Vuex和@ngrx/store的额外上下文。</p>
<p>除了记录Redux操作和状态，LogRocket还记录控制台日志、JavaScript错误、堆栈跟踪、带有头+正文的网络请求/响应、浏览器元数据和自定义日志。它还使用DOM来记录页面上的HTML和CSS，甚至为最复杂的单页面和移动应用程序重新创建像素级完美视频。</p>
<a class="signup" href="https://lp.logrocket.com/blg/typescript-signup" target="_blank" rel="noopener noreferrer">Try it for free</a><p>.</p></div>
</div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
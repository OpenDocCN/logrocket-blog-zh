<html>
<head>
<title>Dealing with links in Next.js - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>处理Next.js - LogRocket博客中的链接</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/dealing-with-links-in-next-js/#0001-01-01">https://blog.logrocket.com/dealing-with-links-in-next-js/#0001-01-01</a></blockquote><div><article class="article-post">
<p><a href="https://nextjs.org"> Next.js </a>是用React构建web应用的优秀工具。我把它看作是React应用程序的<a href="https://rubyonrails.org/"> Ruby on Rails </a>。它包了很多好东西。</p>
<p>其中一个好处是它可以为您处理路由。</p>
<p>然而，这些年来，我使用了各种路由库——几个版本的<a href="https://reacttraining.com/react-router/"> react-router </a>、<a href="https://github.com/4Catalyzer/found"> found </a>、<a href="https://frontarm.com/navi/en/"> Navi </a>，现在还有Next。</p>
<p>我经常不得不切换库或更新react-router，这在每个主要版本中都像是一个新的库。因此，我养成了将路由与应用程序的其他部分隔离开来的习惯。</p>
<p>在本文中，我将解释我在应用程序中隔离路由的两种技术。我使用Next作为例子，但是它们可以应用于几乎所有的路由库:</p>
<ul>
<li>使用定制的<code>Link</code>组件</li>
<li>将所有路径放在一个文件中</li>
</ul>
<h2>技术1:定制<code>Link</code>组件</h2>
<p>我的第一个技巧是包装<code>Link</code>组件。每个路由库都有类似的组件；它被用来代替<code>&lt;a&gt;</code>标签。单击时，它会更改URL，而不需要整个页面重定向，然后路由处理新页面的加载和显示。</p>
<p>在我几乎所有的项目中，我都使用自己的名为<code>Link</code>的组件。这个组件包装了底层路由库<code>Link</code>组件。</p>
<p>Next有类似的<code><a href="https://nextjs.org/docs/api-reference/next/link">Link</a></code>组件。它的界面与其他界面稍有不同，但功能相同:</p>
<pre>&lt;Link href="/about"&gt;
  &lt;a&gt;About&lt;/a&gt;
&lt;/Link&gt;</pre>
<p>我理解他们为什么这样设计。它相当聪明；它在内部使用<code><a href="https://reactjs.org/docs/react-api.html#cloneelement">React.cloneElement</a></code>。你可以在这里查看它的代码<a href="https://github.com/zeit/next.js/blob/canary/packages/next/client/link.tsx">。不过，对我的口味来说有点繁琐。它给你的页面增加了很多视觉效果。</a></p>
<p>仅此一点就足以成为包装组件的理由。然而，在这种情况下，我有更大的理由。比方说我想从类似<a href="https://www.gatsbyjs.org/">盖茨比</a>的地方迁移出来。我不得不改变大量的代码结构；它不会仅仅取代从<code>next/link</code>到<code>gatsby/link</code>的进口。</p>
<p>下面是一个包装版本的<code>Link</code>是如何工作的:</p>
<pre>import * as React from 'react';
import Link from 'next/link';

// allow this component to accept all properties of "a" tag
interface IProps extends React.AnchorHTMLAttributes&lt;HTMLAnchorElement&gt; {
  to: string;
  // we can add more properties we need from next/link in the future
}

// Forward Refs, is useful
export default React.forwardRef(({ to, ...props }: IProps, ref: any) =&gt; {
  return (
    &lt;Link href={to}&gt;
      &lt;a {...props} ref={ref} /&gt;
    &lt;/Link&gt;
  );
});</pre>
<blockquote><p>注意:我对所有的例子都使用了TypeScript。没有类型，代码也能工作。</p></blockquote>
<p>这是它的使用方法:</p>
<pre>&lt;Link to="/about"&gt;About&lt;/Link&gt;</pre>
<p>新的<code>Link</code>组件开始很简单，但是随着时间的推移，您可以添加更多的功能。添加的一个很好的选择是覆盖库的缺省值。</p>
<p>在Next 9中，<a href="https://nextjs.org/blog/next-9#production-optimizations">自动预取</a>默认开启。这将在链接内容位于页面的视口中时预取链接内容。Next使用一个名为<code><a href="https://developer.mozilla.org/en-US/docs/Web/API/IntersectionObserver">IntersectionObserver</a></code>的新浏览器API来检测这一点。</p>
<p>这是一个很方便的特性，但是如果你有很多动态的链接和页面，那就有点过头了。静态方面是可以的。通常，我想为特定的页面设置这个，而不是为所有的页面设置。或者，您可能希望只在鼠标悬停在链接上时进行预取。</p>
<p>我们的<code>Link</code>组件使得关闭这个特性变得很简单:</p>
<pre>interface IProps extends React.AnchorHTMLAttributes&lt;HTMLAnchorElement&gt; {
  to: string;
  prefetch?: boolean;
}

export default React.forwardRef(({ to, prefetch, ...props }: IProps, ref: any) =&gt; {
  return (
    &lt;Link href={to} prefetch={prefetch || false}&gt;
      &lt;a {...props} ref={ref} /&gt;
    &lt;/Link&gt;
  );
});</pre>
<p>现在想象一下，如果我们没有我们的<code>Link</code>组件，我们必须为每个链接关闭预取。</p>
<h2>技术2:将所有路径放在一个文件中</h2>
<p>我看到人们在React应用程序中做的一件事是硬编码链接。类似于以下内容:</p>
<pre>&lt;Link to="/about"&gt;About&lt;/Link&gt;
&lt;Link to="/contact"&gt;Contact&lt;/Link&gt;</pre>
<p>这很脆。它不是类型安全的，并且使重命名URL或改变URL结构变得困难。</p>
<p>我解决这个问题的方法是在项目的根目录下放一个名为<code>path.ts</code>的文件。它看起来像下面这样:</p>
<pre>export default {
  about: '/about',
  contact: '/contact',
}</pre>
<p>该文件包含我的应用程序中的所有路线。</p>
<p>这是它的使用方法:</p>
<pre>import paths from '~/paths';

&lt;Link to={paths.about}&gt;About&lt;/Link&gt;
&lt;Link to={paths.contact}&gt;Contact&lt;/Link&gt;</pre>
<p>通过这种方式，我可以更改路线，并且不会出现拼写错误。</p>
<h2>下一步处理动态路由</h2>
<p>接下来的9年是一个史诗发行。它最重要的特性是支持<a href="https://nextjs.org/blog/next-9#dynamic-route-segments">动态路段</a>。</p>
<p>在此之前，Next并不支持类似<code>/products/1</code>开箱即用的动态路由。你必须使用像<a href="https://github.com/pvtri96/next-router">下一个路由器</a>这样的外部包，或者使用像<code>/products?id=1</code>这样的URL。</p>
<p>处理<a href="https://nextjs.org/docs/api-reference/next/link#dynamic-routes">d</a>T3】动态路线的方式，我们需要传递两个道具给<code>Link</code>:</p>
<ul>
<li><code>href</code>:这是<code>pages</code>文件夹中的哪个文件</li>
<li><code>as</code>:该页面如何显示在地址栏中</li>
</ul>
<p>这是必要的，因为下一个客户端路由器相当轻，不知道你整个路由的结构。这种方法的伸缩性很好，因为您不像在其他路由系统中那样，在浏览器内存中保存复杂的路由结构。</p>
<p>下面是它在实践中的样子:</p>
<pre>&lt;Link href="/products/[id]" as="/product/1"&gt;
  &lt;a&gt;Product 1&lt;/a&gt;
&lt;/Link&gt;</pre>
<p>这使得处理链接更加麻烦。幸运的是，我们有自己的习俗<code>Link</code>和<code>paths</code>。我们可以将它们结合起来，得到如下结果:</p>
<pre>&lt;Link to={paths.product(product)}Product 1&lt;/Link&gt;</pre>
<p>这是如何实现的？</p>
<p>首先，我们在<code>paths</code>中添加一个函数，返回页面的两个属性:</p>
<pre>export default {
  about: '/about',

  contact: '/contact',

  // paths can be functions
  // this also makes it easier to change from "id" to "slug" in the future
  product(product: { id: string }) {
    return {
      href: '/products/[id],
      as: `/products/${id}`,
    };
  }
}</pre>
<p>其次，我们必须处理好这些道具:</p>
<pre>interface IProps extends React.AnchorHTMLAttributes&lt;HTMLAnchorElement&gt; {
  // allow both static and dynamic routes
  to: string | { href: string, as: string };
  prefetch?: boolean;
}

export default React.forwardRef(({ to, prefetch, ...props }: IProps, ref: any) =&gt; {
  // when we just have a normal url we jsut use it
  if (typeof to === 'string') {
    return (
      &lt;Link href={to} prefetch={prefetch || false}&gt;
        &lt;a {...props} ref={ref} /&gt;
      &lt;/Link&gt;
    );
  }

  // otherwise pass both "href" / "as"
  return (
    &lt;Link href={to.href} as={to.as} prefetch={prefetch || false}&gt;
      &lt;a {...props} ref={ref} /&gt;
    &lt;/Link&gt;
  );
});</pre>
<h2>迁移故事</h2>
<p>在版本9之前，Next不支持动态路由。这是一个大问题，我一直在使用<a href="https://github.com/pvtri96/next-router">下一个路由器</a>进行动态路由。它有一个中心文件，您可以在其中创建从URL到<code>pages</code>文件夹中的文件的映射。它的<code>Link</code>组件工作方式完全不同。</p>
<p>在接下来的9个月之前，它是一个救生员。但是当动态路由被添加到Next时，就该停止使用该库了；它现在甚至处于维护模式。</p>
<p>想象一下，有一个包含数百个链接的大型应用程序。你认为像这样的迁移需要多长时间？</p>
<p>对我来说，不到一个小时。我只是替换了<code>Link</code>组件中的代码，并更改了动态路径以返回一个对象，而不是下一个路由器需要的路由/参数。</p>
<h2>结论</h2>
<p>这些技术在我使用React应用程序的这些年里帮助了我很多。它们相对简单，但有助于将应用程序与底层库分离，使系统易于更改，并具有类型安全性。</p>
<p>我希望它们对你也有用。对于任何问题或评论，您可以在<a href="https://twitter.com/rstankov"> Twitter </a>上ping我。</p><div class="code-block code-block-30">
<div class="blog-plug inline-plug next-plug"><h2><a href="https://lp.logrocket.com/blg/nextjs-signup" target="_blank"> LogRocket </a>:全面了解生产Next.js应用</h2><p>调试下一个应用程序可能会很困难，尤其是当用户遇到难以重现的问题时。如果您对监视和跟踪状态、自动显示JavaScript错误、跟踪缓慢的网络请求和组件加载时间感兴趣，</p><a href="https://lp.logrocket.com/blg/nextjs-signup" target="_blank">try LogRocket</a><p>. </p><a class="signup" href="https://lp.logrocket.com/blg/nextjs-signup" target="_blank" rel="noopener noreferrer"><img class="alignnone size-full wp-image-46 jetpack-lazy-image" src="../Images/f300c244a1a1cf916df8b4cb02bec6c6.png" data-lazy-src="https://files.readme.io/27c94e7-Image_2017-06-05_at_9.46.04_PM.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://files.readme.io/27c94e7-Image_2017-06-05_at_9.46.04_PM.png"/><noscript><img data-lazy-fallback="1" class="alignnone size-full wp-image-46" src="../Images/f300c244a1a1cf916df8b4cb02bec6c6.png" data-original-src="https://files.readme.io/27c94e7-Image_2017-06-05_at_9.46.04_PM.png"/></noscript></a><a class="signup" href="https://lp.logrocket.com/blg/nextjs-signup" target="_blank" rel="noopener noreferrer"><img class="alignnone size-full wp-image-46 jetpack-lazy-image" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/><noscript><img data-lazy-fallback="1" class="alignnone size-full wp-image-46" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/></noscript></a><p>LogRocket 就像是网络和移动应用的DVR，记录下你的Next.js应用上发生的一切。您可以汇总并报告问题发生时应用程序的状态，而不是猜测问题发生的原因。LogRocket还可以监控应用程序的性能，报告客户端CPU负载、客户端内存使用等指标。</p><p>LogRocket Redux中间件包为您的用户会话增加了一层额外的可见性。LogRocket记录Redux存储中的所有操作和状态。</p><p>让您调试Next.js应用的方式现代化— <a class="signup" href="https://lp.logrocket.com/blg/nextjs-signup" target="_blank" rel="noopener noreferrer">开始免费监控</a>。</p></div></div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
<html>
<head>
<title>What's new in GSAP 3 - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>GSAP 3 - LogRocket博客中的新内容</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/whats-new-in-gsap-3/#0001-01-01">https://blog.logrocket.com/whats-new-in-gsap-3/#0001-01-01</a></blockquote><div><article class="article-post">
<p>GreenSock已经存在了十多年，是最古老的JavaScript动画库之一。它可以在JavaScript运行的任何地方工作，并在保持其性能的同时动画显示DOM元素和JavaScript对象。</p>
<p>GreenSock是向后兼容的，与框架无关的，对于所有技能水平的开发人员来说都很容易掌握。因此，它是构建直观和交互式网站的最重要的工具之一。</p>
<p>最新版本<a href="https://greensock.com/3/" target="_blank" rel="noopener noreferrer"> GSAP 3 </a>，在之前版本的基础上增加了大约50项新功能和大量改进，包括:</p>
<ul>
<li>更易于使用的API</li>
<li>减小文件大小</li>
<li>时间线默认值</li>
<li>全新的实用方法</li>
<li>运动路径插件</li>
<li>向后兼容性</li>
<li>相对位置前缀</li>
<li>高级蹒跚者</li>
<li>随机能力</li>
</ul>
<p>让我们更详细地了解一下GSAP 3中一些最重要的新功能。</p>
<h2 id="simplifiedapi">简化的API</h2>
<p>新版本附带了一个简化的、更加用户友好的API。GreenSock将“Lite”和“Max”功能整合到一个名为<code>gsap</code>的单一对象中，这两个功能构成了以前版本中的核心模块。</p>
<p>以下面的代码为例，它在以前版本的GSAP中应该是这样的。</p>
<pre>TweenMax.method('selector', {});
</pre>
<p>在GSAP 3中，上面的代码看起来像这样:</p>
<pre>gsap.method('selector', {});
</pre>
<p>类似地，下面一行也适用于以前的版本。</p>
<pre>TweenLite.method('selector',{});
</pre>
<p>在GSAP 3中，它会被翻译成以下内容。</p>
<pre>gsap.method('selector',{});
</pre>
<p>这一变化也影响了时间线的创建方式。下面的两个代码块在旧版本的GSAP中将如下所示。</p>
<pre>const tl = new TimelineMax();
tl.method('selector',{})

const tl = new TimelineLite();
tl.method('selector',{})
</pre>
<p>在最新的版本中，它会被写成这样:</p>
<pre>var tl = gsap.timeline();
tl.method("selector", {});
</pre>
<p>当链接到像<code>to()</code>或<code>from()</code>这样的方法时，<code>gsap</code>对象返回一个补间实例。</p>
<h2 id="reducedfilesize">减小文件大小</h2>
<p>GSAP保留了几乎所有的旧功能，并增加了许多新功能。此外，GreenSock从头开始重建核心作为现代ES模块。</p>
<h2 id="backwardcompatibility">向后兼容性</h2>
<p>新的GSAP更新仍然识别旧的语法，因为以前版本的Max和Lite功能都是别名，以防止遗留代码库被破坏。这为开发人员省去重新编写代码来使用GSAP 3的麻烦。</p>
<h2 id="duration">持续时间</h2>
<p>现在，补间的持续时间参数是在<code>vars</code>对象中定义的，而在以前的版本中，它被定义为方法的参数。</p>
<p>以下面的代码为例，它是为以前版本的GSAP编写的。</p>
<pre>TweenMax.from('selector', 1, {});
</pre>
<p>在GSAP 3中，上述代码可以重写为:</p>
<pre>gsap.from('selctor', {duration:1})
</pre>
<p>注意:旧的语法仍然有效，因为新的更新是向后兼容的。这有助于防止破坏使用旧语法的代码库。</p>
<h2 id="timelinedefaults">时间线默认值</h2>
<p>GSAP 3使您能够为您的时间轴指定默认属性。子补间在创建时继承这些值。</p>
<p>在旧版本中，属性是针对每个补间单独设置的，这导致了代码重复。该更新有助于开发人员遵循不要重复自己(DRY)的原则，保持代码简单和更简洁。</p>
<p>以下示例是为旧版本的GSAP编写的。</p>
<pre>var tl = new TimelineMax();
  tl.to(".selector1", 5 , {ease: Power2.Out, x:200})
    .to(".selector2", 5 , {ease: Power2.Out, y:500})
</pre>
<p>这在GSAP 3中被翻译成以下内容。</p><div class="code-block code-block-54">
<hr/>
<h3>更多来自LogRocket的精彩文章:</h3>

<hr/></div>
<pre>gsap.timeline({defaults:{ease:"power2.out", duration:5}})
    .to(".selector1", {x:200})
    .to(".selector2", {y:500}) 
</pre>
<p>每个补间从父时间轴继承缓动和持续时间。当在子补间上定义另一个值时，继承的默认值很容易被覆盖。</p>
<h2 id="advancedstaggers">高级蹒跚者</h2>
<p>新的更新删除了用于错开的方法，如<code>staggerTo()</code>、<code>staggerFrom()</code>、<code>staggerFromTo()</code>。这现在是<code>vars</code>对象中的一个参数。</p>
<p>您可以使用以下格式将交错添加到补间。</p>
<pre>gsap.method("selector", {
  x:500,
  duration:2,
  stagger: 1 // adds a stagger of 1 second
});
</pre>
<p class="codepen" data-height="265" data-theme-id="default" data-default-tab="css,result" data-user="jola_adebayor" data-slug-hash="KKKLjqQ" data-pen-title="gsap-stagger">参见<a href="https://codepen.io">代码本</a>上的<a href="https://codepen.io/jola_adebayor/pen/KKKLjqQ">笔-错开</a>的anjolaoluva(<a href="https://codepen.io/jola_adebayor">@卫英琦_阿德巴约</a> ) <br/>笔。</p>
<p/>
<p>您还可以通过使用对象语法来执行更高级的交错操作。</p>
<pre>gsap.method("selector", {
  x:500,
  duration:2,
  stagger: {
    amount:2, // amount of time between staggered tweens
  }
</pre>
<p>交错对象还接受其他参数，例如:</p>
<ul>
<li><code>from</code>，定义了错开的起点</li>
<li><code>axis</code>，定义要错开的轴</li>
<li><code>ease</code>，定义交错项目应具有的缓动类型</li>
</ul>
<h2 id="newrandomcapabilities">新的随机功能</h2>
<p>你现在可以定义一个随机值范围到(比如<code>random(-100, 100)</code>)或者一个数组来选择，GSAP会选择一个随机值来制作动画。</p>
<p>这使得创建高级随机化效果更加容易。</p>
<pre>gsap.method("selector", {
  x:"random(100, 200)" //chooses a random number between 1 and 100
}); 
</pre>
<p>下面是一个使用数组的例子。</p>
<pre>gsap.method("selector", {
  x:"random([0, 100, 400, 500])" //chooses a number in the array at random
}); 
</pre>
<p>您甚至可以将随机数四舍五入到任何数字的最接近的增量。</p>
<pre>gsap.method("selector", {
  x:"random(-100, 100, 5)" //chooses a random number between -100 and 100 for each target, rounding to the closest 5!
});
</pre>
<h2 id="relativeandpositionprefix">相对“&gt;”和“</h2>
<p>此功能有助于在时间轴中定位动画。它将补间相对于前一个补间的开始或结束时间放置，并消除了通过代码添加标签的需要。</p>
<pre>gsap.method('selector',{}, "&lt;" ) //Inserts a tween at the start of the previous tween

gsap.method('selector',{}, "&gt;" ) //Inserts a tween at the end of the previous tween
</pre>
<h2 id="newutilitymethods">新的实用方法</h2>
<p>GSAP已经提供了15种新的实用方法。它们中的许多都返回函数，以便可以直接添加到补间动画中。</p>
<p>这些方法包括:</p>

<h2 id="keyframes">关键帧</h2>
<p>关键帧是定义单个补间动画应达到的多个状态的一种方式，而不是用同一目标创建多个补间动画。</p>
<p>你可以在<code>vars</code>对象中传递一组关键帧，它们将被完美地排序。</p>
<pre>gsap.method("selector", {keyframes: [
  {x:500, duration:1,delay:2},//adds a delay of 2 seconds before the next animation
  {y:200, duration:1 }
]});
</pre>
<h2 id="usinggsap3inyourproject">在您的项目中使用GSAP3</h2>
<p>您可以通过以下任一方法在项目中使用最新版本的GreenSock。</p>
<h3>使用CDN</h3>
<p>通过将以下内容添加到HTML文件中，您可以使用CDN将GSAP 3包含在您的项目中。</p>
<pre>&lt;script src="https://cdn.jsdelivr.net/npm/<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="5e392d3f2e1e6d706e706f">[email protected]</a>/dist/gsap.min.js"&gt;&lt;/script&gt;
</pre>
<h3>通过软件包管理器安装</h3>
<p>要通过包管理器安装，请使用下面的代码。</p>
<pre>#Using Yarn

yarn add gsap

#or Using NPM

npm install gsap
</pre>
<p>然后，将其导入您的JavaScript文件中。</p>
<pre>import { gsap } from "gsap";
</pre>
<h2 id="conclusion">结论</h2>
<p>新发布的GSAP 3包括无数的更新，以帮助您创建更令人惊叹的动画。还有更多惊人的特性没有在本文中介绍；有关更新的完整列表，请阅读<a href="https://greensock.com/3-release-notes/" target="_blank" rel="noopener noreferrer"> GSAP 3发行说明</a>。GreenSock团队还整理了一份《T2》五大特色的列表，以便在新版本中检验。</p>
<p>哪些新功能让你印象深刻？请在评论区告诉我们。</p><div class="code-block code-block-28">
<div class="blog-plug inline-plug js-libraries-plug"><h2>您是否添加了新的JS库来提高性能或构建新特性？如果他们反其道而行之呢？</h2><p>毫无疑问，前端变得越来越复杂。当您向应用程序添加新的JavaScript库和其他依赖项时，您将需要更多的可见性，以确保您的用户不会遇到未知的问题。</p>
<p>LogRocket 是一个前端应用程序监控解决方案，可以让您回放JavaScript错误，就像它们发生在您自己的浏览器中一样，这样您就可以更有效地对错误做出反应。</p><a class="signup" href="https://lp.logrocket.com/blg/javascript-signup" target="_blank" rel="noopener noreferrer"><img class="alignnone size-full wp-image-46 jetpack-lazy-image" src="../Images/e8a0ab42befa3b3b1ae08c1439527dc6.png" alt="LogRocket Dashboard Free Trial Banner" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2019/10/errors-screenshot.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/10/errors-screenshot.png"/><noscript><img data-lazy-fallback="1" class="alignnone size-full wp-image-46" src="../Images/e8a0ab42befa3b3b1ae08c1439527dc6.png" alt="LogRocket Dashboard Free Trial Banner" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/10/errors-screenshot.png"/></noscript></a>
<a href="https://lp.logrocket.com/blg/javascript-signup" target="_blank" rel="noopener noreferrer">https://logrocket.com/signup/</a><p><a href="https://lp.logrocket.com/blg/javascript-signup" target="_blank" rel="noopener noreferrer"> LogRocket </a>可以与任何应用程序完美配合，不管是什么框架，并且有插件可以记录来自Redux、Vuex和@ngrx/store的额外上下文。您可以汇总并报告问题发生时应用程序的状态，而不是猜测问题发生的原因。LogRocket还可以监控应用的性能，报告客户端CPU负载、客户端内存使用等指标。</p><p>自信地构建— <a class="signup" href="https://lp.logrocket.com/blg/javascript-signup" target="_blank" rel="noopener noreferrer">开始免费监控</a>。</p></div>


</div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
<html>
<head>
<title>CSS Motion Path: The end of GSAP? - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>CSS运动路径:GSAP的终结？- LogRocket博客</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/css-motion-path-the-end-of-gsap/#0001-01-01">https://blog.logrocket.com/css-motion-path-the-end-of-gsap/#0001-01-01</a></blockquote><div><article class="article-post">
<p>CSS动画曾经相当有限。</p>
<p>处理除了非常基本的效果之外的任何东西通常意味着冗长而复杂的声明。</p>
<p>此外，通过一条路径移动元素需要熟练地使用同步平移和旋转:这正是浏览器差异会变成噩梦的那种事情。</p>
<p>为了解决这个问题，自从网络动画出现以来，开发人员一直在转向JS解决方案(或者至少，自从我们决定放弃Flash以来，但我喜欢假装Flash从未发生过)。)</p>
<p>过去，移动东西是好的ol' jQuery的一个很好的用途，但是在紧要关头事情可能会变得资源密集型。</p>
<p>然后GSAP出来了，给了我们无限的动画力量和更好的性能，这很快就变成了行业标准。</p>
<p>但是CSS也一直在进步，最近发布的Firefox 72和Chromium-powered Edge意味着我们可以开始实施<a href="https://drafts.fxtf.org/motion-1/" target="_blank" rel="noopener noreferrer"> CSS运动路径规范</a>来解决这种情况。</p>
<p>但这是否意味着我们可以摆脱纯粹的CSS动画，抛弃GSAP？</p>
<h2>通过路径定位元素</h2>
<p>运动路径模块的核心是<code>offset-path</code>属性。它采用一个<code>path()</code>函数作为它的值，允许我们为要定位的元素定义一个SVG路径。</p>
<pre>.container{
  offset-path: path('M 0 100 L 200 150 L 300 150');
}</pre>
<p>如果您曾经使用过CSS clip-path，这应该看起来很熟悉。本质上，它定义了直线经过的点以及到达这些点的不同方式。</p>
<p>接下来，<code>offset-distance</code>属性允许我们定义元素在它的<code>offset-path</code>上的位置。它可以带任何CSS <code>&lt;length&gt;</code>单位(<code>%</code>、<code>px</code>等)。</p>
<p>在大多数情况下，使用百分比将是更好的方法。</p>
<p>例如，下面的代码将把一个元素放在它的<code>offset-path</code>的正中间。</p>
<pre>.element{
  offset-distance: 50%;
}</pre>
<p>下面是一个在整个路径中放置了各种元素的示例:</p>
<blockquote class="embedly-card" data-card-controls="1" data-card-align="center" data-card-theme="light">

<p>没有描述</p>
</blockquote>
<p>使用动画路径</p>
<p>尽管顾名思义，在使用运动路径模块本身的属性时并不涉及运动:该部分仍然是通过转场、CSS动画或Web动画API来处理不同的运动路径属性。</p>
<h2>因此，要真正移动路径上的元素，我们可以使用一个移动<code>offset-distance</code>的<code>@keyframes</code>声明。</h2>
<p>dot { offset-path:path(' M 0 0 Q 150 500 300 0 ')；动画:移动4s三次-贝塞尔(0.78，0，0.17，0.99)无限交替；} @关键帧移动{ 100%{偏移距离:100%；} } .dot{背景:浅蓝色；宽度:50px高度:50px显示器:flex对齐-项目:居中；justify-content:居中；边框:2px纯色slateblue边框半径:5px} section{ position:相对；宽度:300px高度:300px边距:自动；} svg { position:绝对；笔画宽度:2px} body{背景:Azure显示器:flex伸缩方向:列；对齐-项目:居中；justify-content:居中；最小高度:100vh溢出-x:隐藏；} *{框大小:边框-框；}</p>
<p>Therefore, to actually move the element on the path we can use a <code>@keyframes</code> declaration that shifts the <code>offset-distance</code>.</p>
<pre>.element{
  offset-path: path('M0,0 C40,160 60,160 100,0');
  animation: move 2000ms;
}
@keyframes move {
  100% {
    offset-distance: 100%;
  }
}</pre>
<blockquote class="embedly-card" data-card-controls="1" data-card-align="center" data-card-theme="light">

<p> </p>
</blockquote>
<p>控制元素的旋转</p>
<p>我们还可以使用<code>offset-rotate</code>属性来控制元素在经过其定义的路径时应该如何旋转。</p>
<h2>更多来自LogRocket的精彩文章:</h2>
<p>默认的<code>auto</code>值将确保元素总是面向路径的方向，根据需要自动旋转。如果我们想通过面向给定方向的路径定位元素，我们可以使用CSS <code>&lt;degree&gt;</code>值来代替。</p><div class="code-block code-block-54">
<hr/>
<h3>下面的代码将确保元素在通过路径时保持其原始方向。</h3>

<hr/></div>
<p>类似于我们对<code>offset-position</code>所做的，我们可以在整个关键帧声明中控制<code>offset-rotate</code>，并相应地调整元素方向。</p>
<p>请记住，为了让旋转平滑过渡，我们必须在角度中声明所有的旋转；从一个角度改变到<code>auto</code>会导致跳动。</p>
<pre>.element{
  offset-rotate: 0deg;
}</pre>
<p>将两者结合起来，我们可以得到如下结果:</p>
<p>移动元素{ offset-path:path(' M 0 100 L 200 150 L 300 150 ')；动画:移动4s易进难出无限；} @关键帧移动{ 0% { offset-rotate:15 deg；} 30%{偏移-旋转:15度；} 60%{偏移-旋转:-20度；} 100%{偏移距离:100%；偏移-旋转:0度；} } .移动元素{背景:浅蓝色；宽度:50px高度:20px显示器:flex对齐-项目:居中；justify-content:居中；边框:2px纯色slateblue边框半径:5px} section{ position:相对；宽度:300px高度:300px边距:自动；} svg { position:绝对；笔画宽度:2px} body{背景:Azure溢出-x:隐藏；} *{框大小:边框-框；}</p>
<p>Combining both, we can get results as follows:</p>
<blockquote class="embedly-card" data-card-controls="1" data-card-align="center" data-card-theme="light">

<p> </p>
</blockquote>
<p>使用<code>:hover</code>和转场制作动画</p>
<p>记住，我们也可以使用简单的过渡来制作运动路径属性的动画</p>
<h2>在下面的示例中，所有元素都从其路径的起点开始定位，并在悬停时显示动画。</h2>
<p>部分:悬停&gt;。dot{偏移距离:100%；偏移-旋转:360度；} .dot:n-child(1){ offset-path:path(' M 50 50 Q 0 50 0 ')；} .dot:n-child(2){ offset-path:path(' M 50 50 Q 50 0 100 0 ')；} .dot:n-child(3){ offset-path:path(' M 50 50 Q 100 50 100 100 ')；} .dot:n-child(4){ offset-path:path(' M 50 50 Q 50 100 0</p>
<pre>.element:hover{
  offset-distance: 100%;
  offset-rotate: 360deg;
}</pre>
<p>通过路径环绕文本</p>
<blockquote class="embedly-card" data-card-controls="1" data-card-align="center" data-card-theme="light">

<p>如果我们尝试将运动路径属性应用于文本元素，我们会看到整个文本块被视为一个整体。如果我们想要的是文本环绕路径(并有可能通过它被动画化)，我们需要让每个字母表现为一个单独的元素。</p>
</blockquote>
<p>第一种方法实际上是用一个实用程序分割文本，比如<a href="https://splitting.js.org/" target="_blank" rel="noopener noreferrer"> splitting.js </a>。虽然这样做很好，但是它会污染dom，给每个字母加上一个<code>&lt;span&gt;</code>，并导致屏幕阅读器拼出单词。</p>
<p>屏幕阅读器友好的选项是<a href="https://www.youtube.com/watch?v=Tae96ze3xwY" target="_blank" rel="noopener noreferrer">使用带有textPath元素</a>的实际SVG文本。</p>
<h2>添加外部样式表/笔此处添加的任何URL都将按顺序添加，并放在编辑器中的CSS之前。通过使用其URL和适当的URL扩展名，您可以使用另一个笔中的CSS。JavaScript预处理器巴贝尔包括JSX处理。</h2>
<p>为路径本身制作动画</p>
<p>就像我们用<code>clip-path</code>做的有趣的事情一样，<code>offset-path</code>的路径声明可以被动画化。</p>
<p>为此，我们必须确保动画的每一步都有相同数量的节点，以便浏览器能够在它们之间平滑过渡。</p>
<blockquote class="embedly-card" data-card-controls="1" data-card-align="center" data-card-theme="light">

<p>如果我们在任何一个步骤中提供不同数量的节点，浏览器将无法猜测中间的节点，而只是简单地从一个步骤跳到下一个步骤，而不进行转换。</p>
</blockquote>
<p>dot { offset-path:path(' M 0 100 Q 100 0 200 100 Q 300 200 400 100 ')；位置:绝对；偏移-旋转:0度；动画:移动3s缓入缓出无限交替；} @关键帧移动{ 100% { offset-path:path(' M 0 100 Q 100 200 200 100 Q 300 0 400 100 ')}。点:第n种类型(2) {偏移距离:20%；</p>
<p> </p>
<h2> </h2>
<p>即将推出的功能和改进</p>
<p>浏览器当前对<code>offset-path</code>的实现只允许我们为后面的元素声明一个<code>path()</code>函数。根据规范的工作草案，我们应该也能使用<code>&lt;basic-shape&gt;</code>(如圆形、多边形等)。所以我们可以期待在不久的将来。</p>
<p>它还允许我们使用一个SVG路径id作为值(例如<code>offset-path: url(#my-path)</code>)，这将帮助我们在HTML中绘制一个动画路径，并让它相应地缩放。</p>
<blockquote class="embedly-card" data-card-controls="1" data-card-align="center" data-card-theme="light">

<p>还有一个额外的属性，目前只有Firefox实现了:<code>offset-anchor</code>属性允许我们定义元素相对于其偏移路径的锚点。</p>
</blockquote>
<p>它的默认设置是<code>50 %/50 %</code>，这意味着元素在路径上居中。通过改变<code>offset-anchor</code>，我们可以操纵元素的哪一部分固定在路径上，类似于我们对<code>transform-origin</code>所做的。</p>
<p>关于可达性的一句话</p>
<h2>我将是第一个承认到处使用这个新工具的人，但是动画应该被有目的地和负责任地使用。</h2>
<p>动画可能会引发前庭障碍患者的恶心，让任何有注意力障碍的人分心，或者只是让一些可能喜欢禁用它的用户感到讨厌。</p>
<p>因此，考虑在<a href="https://blog.logrocket.com/new-in-chrome-74-prefers-reduced-motion-media-query-50cd89d3e769/" target="_blank" rel="noopener noreferrer">偏好减少运动</a>媒体查询中实现这一点，以保证这些用户的安全。</p>
<p>结论</p>
<p>运动路径模块刚刚使CSS动画强大了一百倍，我们刚刚开始发现许多用例。</p>
<h2>但它仍然有一些缺点:首先，为了解决房间里的大象，Safari还不支持该规范，这可能是兼容性的一个障碍。</h2>
<p>它也没有改变CSS动画本身的怪癖，例如编写和维护关键帧的复杂性(特别是当我们需要将它们链接在一起并同步时)，以及它们的缓动功能对两个贝塞尔处理程序的限制，这使得像反弹效果这样的东西比在支持多个贝塞尔函数的外部库中更难创建和维护。</p>
<p>因此，GSAP将会留在这里，至少会持续一段时间。</p>
<p>在我看来，运动路径所做的就是将动画从CSS切换到JS的门槛移动了很多。</p>
<pre>.element{
  offset-path: path('M0,0 C40,160 60,160 100,0');
  animation: move 2s ease-out;
}

@keyframes move {
  100% {
    offset-distance: 100%;
  }
}

@media screen and (prefers-reduced-motion: reduce){
  .element{
    animation-duration: 1ms; /* takes it immediately to the ending position */
  }
}</pre>
<h2>你的前端是否占用了用户的CPU？</h2>
<p>随着web前端变得越来越复杂，资源贪婪的特性对浏览器的要求越来越高。如果您对监控和跟踪生产环境中所有用户的客户端CPU使用、内存使用等感兴趣，</p>
<p>.</p>
<p>LogRocket 就像是网络和移动应用的DVR，记录你的网络应用或网站上发生的一切。您可以汇总和报告关键的前端性能指标，重放用户会话和应用程序状态，记录网络请求，并自动显示所有错误，而不是猜测问题发生的原因。</p>
<p>现代化您调试web和移动应用的方式— <a class="signup" href="https://lp.logrocket.com/blg/css-signup" target="_blank" rel="noopener noreferrer">开始免费监控</a>。</p>
<p>What Motion Path does, in my opinion, is moving the threshold at which we would switch from CSS to JS for animations quite a bit.</p><div class="code-block code-block-25">
<div class="blog-plug inline-plug css-plug"><h2>Is your frontend hogging your users' CPU?</h2><p>As web frontends get increasingly complex, resource-greedy features demand more and more from the browser. If you’re interested in monitoring and tracking client-side CPU usage, memory usage, and more for all of your users in production, </p><a target="_blank" href="https://lp.logrocket.com/blg/css-signup">try LogRocket</a><p>.</p><a class="signup" href="https://lp.logrocket.com/blg/css-signup" target="_blank" rel="noopener noreferrer"><img class="alignnone size-full wp-image-46 jetpack-lazy-image" src="../Images/dacb06c713aec161ffeaffae5bd048cd.png" alt="LogRocket Dashboard Free Trial Banner" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2019/12/cpu-memory-usage.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/12/cpu-memory-usage.png"/><noscript><img data-lazy-fallback="1" class="alignnone size-full wp-image-46" src="../Images/dacb06c713aec161ffeaffae5bd048cd.png" alt="LogRocket Dashboard Free Trial Banner" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/12/cpu-memory-usage.png"/></noscript></a><a href="https://lp.logrocket.com/blg/css-signup" target="_blank" rel="noopener noreferrer">https://logrocket.com/signup/</a><p><a href="https://lp.logrocket.com/blg/css-signup" target="_blank" rel="noopener noreferrer">LogRocket</a> is like a DVR for web and mobile apps, recording everything that happens in your web app or site. Instead of guessing why problems happen, you can aggregate and report on key frontend performance metrics, replay user sessions along with application state, log network requests, and automatically surface all errors.</p><p>Modernize how you debug web and mobile apps — <a class="signup" href="https://lp.logrocket.com/blg/css-signup" target="_blank" rel="noopener noreferrer">Start monitoring for free</a>.</p></div>
</div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
<html>
<head>
<title>Using forwardRef in React to clean up the DOM - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>在React中使用forwardRef清理DOM - LogRocket博客</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/cleaning-up-the-dom-with-forwardref-in-react/#0001-01-01">https://blog.logrocket.com/cleaning-up-the-dom-with-forwardref-in-react/#0001-01-01</a></blockquote><div><article class="article-post">
<p><em> <strong>编者按:</strong>本帖更新于2021年3月18日。</em></p>
<h2>介绍</h2>
<p>在本教程中，我们将回顾React中转发引用的概念，并理解它如何帮助我们管理与DOM的交互。为了获得更有吸引力的体验，我们将介绍如何创建引用、将创建的引用附加到DOM元素和类、使用forwardRef方法等等。</p>
<p>同样值得注意的是，我们将经常参考文档页面，以建立在已经存在的信息上，并通过相关的真实生活示例和片段来证明我们的概念，这些示例和片段将被托管在<a href="http://codesandbox.io" target="_blank" rel="noopener noreferrer"> CodeSandbox </a>上。</p>
<h2>React中forwardRef是什么？</h2>
<p><a href="https://reactjs.org/docs/forwarding-refs.html"> React forwardRef </a>是一种允许父组件将引用向下传递(即“转发”)给其子组件的方法。在React中使用forwardRef可以为子组件提供对由其父组件创建的DOM元素的引用。这样，孩子就可以在任何使用该元素的地方阅读和修改它。</p>
<h2>forwardRef在React中是如何工作的？</h2>
<p>要理解引用转发，我们必须首先理解什么是引用，它们是如何工作的，并涵盖一些用例。通常在React中，父组件通过props将数据传递给它们的子组件。</p>
<p>要改变一个子组件的行为，你可以用一组新的道具来渲染它。要修改子组件，使其表现出稍微不同的行为，我们需要一种方法来进行这种更改，而无需达到状态或重新呈现组件。</p>
<p>我们可以通过引用来实现这一点。通过引用，我们可以访问由元素表示的DOM节点。因此，我们可以修改它，而不接触它的状态或重新渲染它。</p>
<p>因为refs持有对DOM元素本身的引用，所以我们可以用React库中没有的原生JavaScript函数来操作它。例如，当点击一个按钮时，我们可以启动输入字段的焦点:</p>
<pre>import * as React from "react";
import ReactDOM from "react-dom";
 
export default function App() {
 const ref = React.useRef();
 
 function focus() {
   ref.current.focus();
 }
 
 return (
   &lt;div className="App"&gt;
     &lt;input ref={ref} placeholder="my input" /&gt;
     &lt;button onClick={focus}&gt;Focus&lt;/button&gt;
   &lt;/div&gt;
 );
}
 
const rootElement = document.getElementById("root");
ReactDOM.render(&lt;App /&gt;, rootElement);</pre>
<p>你也可以在<a href="https://codesandbox.io/s/input-element-ref-fp220" target="_blank" rel="noopener noreferrer"> CodeSandbox </a>找到代码。</p>
<p>类似地，我们可以使用JavaScript来实现类似的效果，尽管不建议这样做，甚至认为在使用React时直接访问DOM是一种不好的做法。等同于获取引用的纯JavaScript代码是:</p>
<pre>document.getElementById('myInput).focus()</pre>
<p>通过ref，我们操纵光标，每当单击按钮时，光标自动聚焦在输入元素上。如果没有refs，我们必须使用state来检查输入字段是否应该聚焦——这是在做出决定之前，在这种情况下通常是不必要的。</p>
<p>这个信息很重要，因为<code><span class="pln">forwardRef</span></code>允许你在内部定义<code><span class="kwd">ref</span></code>将指向什么元素。</p>
<h3>React中何时使用引用</h3>
<p>在React 中有<a href="https://blog.logrocket.com/a-guide-to-react-refs/">个引用可以用<code>forwardRef</code>指向。正如在官方</a><a href="https://reactjs.org/docs/refs-and-the-dom.html" target="_blank" rel="noopener noreferrer"> React文档</a>中看到的，我们可以使用refs来完成各种任务:</p>
<h4>管理焦点、文本选择或媒体播放</h4>
<p>让我们假设你有一个输入组件。在应用程序的某些部分，当用户单击按钮时，您可能希望光标聚焦在它上面。更有意义的是只修改输入组件的特定实例而不改变状态(通过refs)，而不是改变状态(通过<em> props </em>)，这会导致组件每次都重新呈现。类似地，我们可以使用refs来控制音乐或视频播放器的状态(暂停、播放、停止)，而无需在我们单击按钮时重新呈现(更改状态)。</p>
<h4>递增值</h4>
<p>想想一个中等的拍手按钮。实现类似特性的一个快速方法是，每当用户点击拍手时，递增存储在状态中的计数值。然而，这可能效率不是很高。每当用户单击clap按钮时，它将重新呈现，并且，如果我们发送一个网络请求来将值存储在服务器中，它将在按钮被单击时被发送。有了refs，我们可以定位那个特定的节点，并在每次用户单击按钮时递增它，而不会导致重新呈现，最后，我们可以向服务器发送一个带有最终值的请求。</p>
<p>通过使用这种技术，我们可以提高应用程序的性能，因为我们可以防止重新渲染的发生，尽管它应该只在特定的情况下使用，并且要小心，因为如果使用不当，它可能会导致意想不到的行为。</p>
<h4>触发命令式动画</h4>
<p>我们可以使用引用来触发元素之间的动画，这些元素依赖于它们自己的下一个状态，但存在于不同的组件中(这个概念称为引用转发)。Refs还可以用来简化与第三方DOM库的集成以及管理多步表单值状态等。</p>
<h2>在类组件中使用引用</h2>
<h3>在React中创建引用</h3>
<p>为了创建ref，React提供了一个名为<code>React.createRef()</code>的函数。创建后，可以通过ref属性将它们附加到React元素。同样值得注意的是，refs与state有些相似。构建构件时，会将参照指定给该构件的实例属性，以确保可以在构件中的任何位置参照这些参照:</p>
<pre>class MyComponent extends React.Component {
  constructor(props) {
    super(props);
    this.newRef = React.createRef(); //newRef is now available for use throughout our component
  }
 ...
}</pre>
<p>至此，我们已经创建了一个名为<code>newRef</code>的Ref。要在我们的组件中使用这个Ref，我们只需将它作为一个值传递给<code>ref</code>属性，如下所示:</p>
<pre>class MyComponent extends React.Component {
 ...
  render() {
    return &lt;div ref={this.myRef} /&gt;;
  }
}</pre>
<p>我们在这里附加了Ref，并传入了<code>newRef</code>作为它的值。因此，我们现在能够在不改变状态的情况下更新它。更多信息，<a href="https://blog.logrocket.com/how-to-use-react-createref-ea014ad09dba/">了解如何在React </a>中使用createRef。</p>
<h3>附加参考</h3>
<p>Refs在组件渲染时创建，可在<code>componentDidMount()</code>或<code>constructor()</code>中定义。因此，它们可以附加到DOM元素或类组件，但不能附加到函数组件，因为它们没有实例。</p>
<p>您定义的每个Ref将代表DOM中的一个节点。因此，当您想要在一个<code>render()</code>函数中引用该节点时，React提供了一个引用该节点的<code>current</code>属性。</p>
<pre>const DOMNode = this.newRef.current; // refers to the node it represents</pre>
<p>ref的值根据它引用的节点类型(类组件或DOM元素)而不同。</p>
<p>为了更好地理解引用和它们引用的节点类型，以及与每个相关联的默认值，让我们考虑一下来自<a href="https://reactjs.org/docs/refs-and-the-dom.html" target="_blank" rel="noopener noreferrer">文档</a>的这段内容:</p>
<ul>
<li>当在HTML元素上使用ref属性时，在构造函数中用<code>React.createRef()</code>创建的ref接收底层DOM元素作为其<code>current</code>属性</li>
<li>当ref属性用于定制类组件时，ref对象接收组件的挂载实例作为其<code>current</code>，即组件属性、状态和方法</li>
</ul>
<p>让我们用一个小的视频播放器来演示这个概念。视频播放器将有一些暂停和播放功能。为了继续构建，创建一个新的<a href="https://codesandbox.io" target="_blank" rel="noopener noreferrer"> CodeSandbox </a>项目，并添加以下代码:</p>
<pre>import ReactDOM from "react-dom";
import React, { Component } from "react";

export default class App extends Component {
  constructor(props) {
    super(props);
    this.myVideo = React.createRef();
  }
  render() {
    return (
      &lt;div&gt;
        &lt;video ref={this.myVideo} width="320" height="176" controls&gt;
          &lt;source
            src="https://res.cloudinary.com/daintu6ky/video/upload/v1573070866/Screen_Recording_2019-11-06_at_4.14.52_PM.mp4"
            type="video/mp4"
          /&gt;
        &lt;/video&gt;
        &lt;div&gt;
          &lt;button
            onClick={() =&gt; {
              this.myVideo.current.play();
            }}
          &gt;
            Play
          &lt;/button&gt;
          &lt;button
            onClick={() =&gt; {
              this.myVideo.current.pause();
            }}
          &gt;
            Pause
          &lt;/button&gt;
        &lt;/div&gt;
      &lt;/div&gt;
    );
  }
}
const rootElement = document.getElementById("root");
ReactDOM.render(&lt;App /&gt;, rootElement);</pre>
<p>你也可以在这里找到代码<a href="https://codesandbox.io/s/react-ref-sample-njkbc" target="_blank" rel="noopener noreferrer">。</a></p>
<p>这里，我们使用ref通过调用视频上的pause和play方法来暂停和播放我们的视频播放器。当单击暂停或播放按钮时，将在视频播放器上调用该函数，无需重新渲染。</p>
<h4>对函数组件使用引用</h4>
<p>引用不能附加到功能组件。但是，我们可以定义refs并将它们附加到DOM元素或类组件上。底线是——功能组件没有实例，所以您不能引用它们。</p>
<p>但是，如果您必须将一个ref附加到一个函数组件上，官方的React团队建议您将该组件转换成一个类，就像您需要生命周期方法或状态时所做的那样。</p>
<h3>条件参考</h3>
<p>除了传递默认的<code>ref</code>属性，我们还可以传递函数来设置refs。这种方法的主要优点是，您可以更好地控制何时设置和取消设置ref。这是可能的，因为它使我们能够在触发某些动作之前确定ref的状态。考虑下面来自<a href="https://reactjs.org/docs/refs-and-the-dom.html" target="_blank" rel="noopener noreferrer">文档页面</a>的片段:</p>
<pre>class CustomTextInput extends React.Component {
  constructor(props) {
    super(props);
    this.textInput = null;
    this.setTextInputRef = element =&gt; {
      this.textInput = element;
    };
    this.focusTextInput = () =&gt; {
      // Focus the text input using the raw DOM API
      if (this.textInput) this.textInput.focus();
    };
  }
  componentDidMount() {
    this.focusTextInput();
  }
  render() {
    return (
      &lt;div&gt;
        &lt;input
          type="text"
          ref={this.setTextInputRef}
        /&gt;
        &lt;input
          type="button"
          value="Focus the text input"
          onClick={this.focusTextInput}
        /&gt;
      &lt;/div&gt;
    );
  }
}</pre>
<p>我们没有在构造函数中定义refs，而是将初始值设置为null。这种方法的好处是<code>textInput</code>不会引用节点，直到组件被加载(当元素被创建时)。</p><div class="code-block code-block-54">
<hr/>
<h3>更多来自LogRocket的精彩文章:</h3>

<hr/></div>
<h2>在函数组件中使用引用</h2>
<p>在函数组件中，我们不能简单地使用函数<code>createRef</code>，因为它每次被调用时都会创建一个新的引用。我们可以选择使用效果和状态来处理引用，但是React用<code>useRef</code>提供了一个更简单的方法。<code>useRef</code>负责每次返回与初始渲染时相同的引用。</p>
<p>使用<code>useRef</code>很简单，就像我们在本教程开始的第一个例子中展示的那样。</p>
<h2>使用<code>forwardRef</code>转发React中的参考</h2>
<p>当一个子组件需要引用其父组件的当前节点时，父组件需要一种方法将其ref向下发送到子组件。这种技术被称为引用转发。</p>
<p><a href="https://reactjs.org/docs/forwarding-refs.html" target="_blank" rel="noopener noreferrer">引用转发</a>是一种通过组件自动将引用传递给其子组件的技术。这在构建可重用组件库时非常有用。<code>forwardRef</code>是用于将引用传递给子组件的函数。</p>
<p>让我们以一个具有InputText组件的新库为例，它将提供许多功能，不过，现在，我们将保持它的简单性:</p>
<pre>const InputText = (props) =&gt; (
&lt;input {...props} /&gt;
));</pre>
<p>在整个应用程序中，<code>InputText()</code>组件的使用方式类似于常规的DOM输入，因此为了管理焦点、选择或与之相关的动画，访问它的DOM节点可能是不可避免的。</p>
<p>在下面的例子中，应用程序中的其他组件无法访问由<code>InputText()</code>组件生成的DOM input元素，因此限制了我们已经预见到的满足应用程序需求所需的一些操作，比如以编程方式控制输入的焦点。</p>
<p>这里是当<code>React.forwardRef</code>进入以获得作为props传递的ref，然后将它转发到它呈现的DOM输入:</p>
<pre>const InputText = React.forwardRef((props, ref) =&gt; (
 &lt;input ref={ref} {...props} /&gt;
));
</pre>
<p>既然我们的组件支持<code>forwardRef</code>，那么让我们在应用程序的上下文中使用它来构建一个按钮，当它被点击时会自动聚焦输入。代码如下所示:</p>
<pre>import * as React from "react";
import ReactDOM from "react-dom";
 
const InputText = React.forwardRef((props, ref) =&gt; (
 &lt;input ref={ref} {...props} /&gt;
));
 
export default function App() {
 const ref = React.useRef();
 
 function focus() {
   ref.current.focus();
 }
 
 return (
   &lt;div className="App"&gt;
     &lt;InputText ref={ref} placeholder="my input" /&gt;
     &lt;button onClick={focus}&gt;Focus&lt;/button&gt;
   &lt;/div&gt;
 );
}
 
const rootElement = document.getElementById("root");
ReactDOM.render(&lt;App /&gt;, rootElement);

</pre>
<p><span>你也可以在</span><a href="https://codesandbox.io/s/thirsty-kowalevski-pxyos?file=/src/index.js:68-156" target="_blank" rel="noopener"><span>code sandbox</span></a><span>上看到它的动作。</span></p>
<p>下面是对上面代码的澄清:</p>
<ul>
<li>我们在需要引用的组件中定义一个引用，并将其传递给按钮组件</li>
<li>React将传递ref，并通过将其指定为JSX属性将其向下转发给<code>&lt;input ref={ref}&gt;</code></li>
<li>当引用被附加时，<code>ref.current</code>将指向<code>&lt;input&gt;</code> DOM节点</li>
<li><code>InputRef</code> <span>组件中的第二个ref参数只存在于用</span> <code>React.forwardRef</code> <span>调用</span>定义组件时</li>
<li>常规函数或类组件不接收ref参数，ref在props中也不可用</li>
<li>Ref转发不限于DOM组件。您也可以将引用转发给类组件实例</li>
</ul>
<h2>结论</h2>
<p>React中的Refs是一个强大的工具，它支持直接访问DOM节点，因此提供了一系列全新的方法和选项来构建性能更高、功能更丰富、更简洁的组件。</p>
<p>然而，在React中，直接访问DOM通常被认为是一种不好的做法，由于某种原因，如果使用不当，它会将所有的好处变成真正的问题。一般来说，应该避免使用它，并且只在非常特殊的情况下使用，并且要经过彻底的检查。</p>
<p>在本教程中，我们介绍了引用和引用转发的主题，我们查看了一些用例，并使用函数和类组件构建了代码。要阅读更多关于参考文献的信息，请点击此处查看相关文档。</p>
<p>感谢阅读！</p><div class="code-block code-block-17">
<div class="blog-plug inline-plug react-plug" vwo-el-id="26283398190">
<h2 vwo-el-id="41600691720">使用LogRocket消除传统反应错误报告的噪音</h2>
<a href="https://lp.logrocket.com/blg/react-signup-issue-free" target="_blank" vwo-el-id="19356441070">LogRocket
</a><p>是一款React analytics解决方案，可保护您免受数百个误报错误警报的影响，只针对少数真正重要的项目。LogRocket告诉您React应用程序中实际影响用户的最具影响力的bug和UX问题。</p><a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="19356441380">
<img class="first-react-image alignnone size-full wp-image-46 jetpack-lazy-image jetpack-lazy-image--handled" src="../Images/f300c244a1a1cf916df8b4cb02bec6c6.png" vwo-el-id="18272717540" data-lazy-loaded="1" data-original-src="https://files.readme.io/27c94e7-Image_2017-06-05_at_9.46.04_PM.png"/>
</a>
<a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="19356441690">
<img class="second-react-image alignnone size-full wp-image-46 jetpack-lazy-image jetpack-lazy-image--handled" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" vwo-el-id="30720362350" data-lazy-loaded="1" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/>
</a>
<a href="https://lp.logrocket.com/blg/react-signup-issue-free" target="_blank" rel="noopener noreferrer" vwo-el-id="35866400580">LogRocket
</a><p>自动聚合客户端错误、反应错误边界、还原状态、缓慢的组件加载时间、JS异常、前端性能指标和用户交互。然后，LogRocket使用机器学习来通知您影响大多数用户的最具影响力的问题，并提供您修复它所需的上下文。</p><p vwo-el-id="28675661060">关注重要的React bug—<a class="signup" href="https://lp.logrocket.com/blg/react-signup-issue-free" target="_blank" rel="noopener noreferrer" vwo-el-id="40093418840">今天就试试LogRocket】。</a></p>
</div></div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
<html>
<head>
<title>Using Recompose to write clean higher-order components - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>使用重新组合来编写干净的高阶组件</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/using-recompose-to-write-clean-higher-order-components-3019a6daf44c/#0001-01-01">https://blog.logrocket.com/using-recompose-to-write-clean-higher-order-components-3019a6daf44c/#0001-01-01</a></blockquote><div><article class="article-post">
<p><em> <strong>编者按</strong>:自2018年10月25日起<a href="https://github.com/acdlite/recompose/issues/756#issuecomment-438674573">停止</a>对重组库的主动维护。笔者推荐用<a href="https://blog.logrocket.com/react-hooks-cheat-sheet-unlock-solutions-to-common-problems-af4caf699e70/" target="_blank" rel="noopener"> React钩子</a>代替。</em></p>
<p>如果您喜欢在React中通过使用功能组件语法创建小组件，然后使用它们作为片段来创建更大的组件，那么<a class="markup--anchor markup--p-anchor" href="https://github.com/acdlite/recompose" target="_blank" rel="noopener noreferrer" data-href="https://github.com/acdlite/recompose"> Recompose </a>可以帮助您对高阶组件(hoc)做同样的事情。</p>
<p>使用重组，可以更容易地创建小的高阶组件，这些组件可以组合成更复杂的组件。使用Recompose鼓励的方法，您将不再需要更多的<code>Class</code>语法来创建React组件。</p>
<p>但是在进入细节之前，让我们开始回顾一些概念…</p>
<h2>高阶函数</h2>
<p>在JavaScript中，我们有一种特殊类型的函数，称为高阶函数:</p>
<blockquote><p>一个<a class="markup--anchor markup--pullquote-anchor" href="https://en.wikipedia.org/wiki/Higher-order_function" target="_blank" rel="noopener noreferrer" data-href="https://en.wikipedia.org/wiki/Higher-order_function">高阶函数</a>是一个处理其他函数的函数，要么是因为它接收其他函数作为参数(在函数体的某个点执行它们)，要么是因为它在被调用时返回一个新函数，或者两者都有。</p></blockquote>
<pre>const sum = (a, b) =&gt; a + b
const multiplication = (a, b) =&gt; a * b

// Our Higher-Order Function
const getResultOperation = op =&gt; (a, b) =&gt; `The ${op.name} of ${a} and ${b} is ${op(a, b)}`

const getSumResult = getResultOperation(sum)
const getMultiplicationResult = getResultOperation(multiplication)

console.log( getSumResult(2, 5) ) // The sum of 2 and 5 is 7 
console.log( getMultiplicationResult(2, 5) ) // The multiplication of 2 and 5 is 10</pre>
<p>在上面的例子中，<code>getResultOperation</code>接收一个函数并返回一个新函数。所以是高阶函数。</p>
<blockquote><p>JavaScript中最流行的高阶函数是数组方法<code><a class="markup--anchor markup--blockquote-anchor" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map" target="_blank" rel="noopener noreferrer" data-href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map">map</a></code>、<code><a class="markup--anchor markup--blockquote-anchor" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter" target="_blank" rel="noopener noreferrer" data-href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter">filter</a></code>或<code><a class="markup--anchor markup--blockquote-anchor" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce" target="_blank" rel="noopener noreferrer" data-href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce">reduce</a></code>。它们都将一些函数作为参数传递给数组的元素，以获得结果。</p></blockquote>
<h2>高阶组件</h2>
<p>在React中，我们有高阶函数的等价物，但是对于组件，所谓的高阶组件。</p>
<blockquote><p>一个<a class="markup--anchor markup--pullquote-anchor" href="https://reactjs.org/docs/higher-order-components.html" target="_blank" rel="noopener noreferrer" data-href="https://reactjs.org/docs/higher-order-components.html">高阶分量</a>是取一个分量并返回一个新分量的函数。</p></blockquote>
<p>高阶分量什么时候有用？嗯，主要是为了重用涉及跨组件行为的逻辑。让我们用下面的场景来解释一下。</p>
<p>假设我们已经有了一个组件<code>Button</code>。</p>
<pre>const Button = ({ type = "primary", children, onClick }) =&gt; (
  &lt;button className={`btn btn-${type}`} onClick={onClick}&gt;
    {children}
  &lt;/button&gt;
);</pre>
<p>我们想在这个<code>Button</code>的基础上创建另一个<code>ButtonWithTrack</code>(同样的道具在<code>Button</code>上也可以工作，同样的样式也可以应用)，但是行为有所改进(比如记录它被点击的次数，并在按钮上显示这个值)。</p>
<p>为此，我们可以做…</p>
<pre>import Button from "./Button";

class ButtonWithTrack extends Component {
  constructor(props) {
    super(props);
    this.state = {
      times: 0
    };
  }
  handleClick = e =&gt; {
    let { times } = this.state;
    const { onClick } = this.props;
    this.setState({ times: ++times });
    onClick &amp;&amp; onClick();
  };
  render() {
    const { children } = this.props;
    const { times } = this.state;
    return (
      &lt;span onClick={this.handleClick}&gt;
        &lt;Button type={times &gt; 5 ? "danger" : "primary"}&gt;
          {children} &lt;small&gt;{times} times clicked&lt;/small&gt;
        &lt;/Button&gt;
      &lt;/span&gt;
    );
  }
}</pre>
<p>我们重用了原来的<code>Button</code>，所以现在一切正常。</p>
<p>再来看另一个组件，<code>Link</code>:</p>
<pre>const Link = ({ type = "primary", children, href, onClick }) =&gt; (
  &lt;a style={styles} className={`badge badge-${type}`} href={href} onClick={onClick}&gt;
    {children}
  &lt;/a&gt;
);</pre>
<p>我们想要添加与我们添加到<code>Button</code>中的行为完全相同的行为。</p>
<p>那怎么办呢？我们应该在两个文件中重复90%的代码吗？或者有没有一种方法可以让我们去掉添加到<code>ButtonWithTrack</code>中的逻辑，使其可以应用于<code>Button</code>和<code>Link</code>组件？</p>
<p>高阶组件来救援了！！</p>
<p>为了解决这个问题，我们可以创建一个更高阶的组件，即一个函数，它接受一个组件，并返回该组件的增强版本，该版本具有我们想要的行为。</p>
<p>例如，我们可以这样做:</p>
<pre>const withClickTimesTrack = WrappedComponent =&gt;
  class extends Component {
    constructor(props) {
      super(props);
      this.state = {
        times: 0
      };
    }
    handleClick = e =&gt; {
      e.preventDefault();
      let { times } = this.state;
      const { onClick } = this.props;
      this.setState({ times: ++times });
      onClick &amp;&amp; onClick();
    };
    render() {
      const { children, onClick, ...props } = this.props;
      const { times } = this.state;
      return (
        &lt;span onClick={this.handleClick}&gt;
          &lt;WrappedComponent
            type={times &gt; 5 ? "danger" : "primary"}
            {...props}
          &gt;
            {children} &lt;small&gt;({times} times clicked)&lt;/small&gt;
          &lt;/WrappedComponent&gt;
        &lt;/span&gt;
      );
    }
  };</pre>
<p>因此，我们可以像这样使用<code>withClickTimesTrack</code> HOC来简化从<code>Button</code>创建组件<code>ButtonWithTrack</code>的过程:</p>
<pre>import withClickTimesTrack from "./hoc/withClickTimesTrack";

const Button = ({ type = "primary", children, onClick }) =&gt; (
  &lt;button className={`btn btn-${type}`} onClick={onClick}&gt;
    {children}
  &lt;/button&gt;
);

const ButtonWithTrack = withClickTimesTrack(Button);</pre>
<p>现在，我们可以轻松地将相同的增强应用到其他组件，如<code>Link</code>:</p>
<pre>import withClickTimesTrack from "./hoc/withClickTimesTrack";

const Link = ({ type = "primary", children, href, onClick }) =&gt; (
  &lt;a style={styles} className={`badge badge-${type}`} href={href} onClick={onClick}&gt;
    {children}
  &lt;/a&gt;
);
const LinkWithTrack = withClickTimesTrack(Link);</pre>
<p>很酷，不是吗？</p>
<p>但是我们可以认为这个HOC同时添加了太多的行为(处理程序、状态和新的UI)。</p>
<p>如果我们把HOC背后的逻辑分成更小的部分不是更好吗？</p>
<h2>作曲技巧</h2>
<p>好了，决定了！我们希望将HOC的这三种行为隔离开来，这样我们就可以在其他组件中独立地重用它们:</p>
<ul>
<li>添加<code>times</code>状态</li>
<li>添加自定义<code>handleClick</code></li>
<li>显示元素内部的<code>times</code>状态</li>
</ul>
<p>为此，我们可以创建三个hoc，每个hoc将添加一个特定的行为…</p><div class="code-block code-block-54">
<hr/>
<h3>更多来自LogRocket的精彩文章:</h3>

<hr/></div>
<p><code>withStateTimes.js</code>:</p>
<pre>const withStateTimes = WrappedComponent =&gt;
  class extends Component {
    constructor(props) {
      super(props);
      this.state = {
        times: 0
      };
    }
    setTimes = (times) =&gt; {
      this.setState({ times })
    }
    render() {
      const { times } = this.state
      const { setTimes } = this
      return (
        &lt;WrappedComponent times={times} setTimes={setTimes} { ...this.props } /&gt;
      );
    }
  };</pre>
<p><code>withHandlerClick.js</code>:</p>
<pre>const withHandlerClick = WrappedComponent =&gt; props =&gt; {

  let { times, setTimes, children, onClick, ..._props } = props;
    
  const handleClick = e =&gt; {
    e.preventDefault();
    setTimes( ++times );
    onClick &amp;&amp; onClick();
  };

  return (
    
      {children}
    
  );

}</pre>
<p><code>withDisplayTrack.js</code>:</p>
<pre>const withDisplayTrack = WrappedComponent =&gt; props =&gt; {
  const { children, onClick, handleClick, times, ..._props } = props;
  return (
    &lt;span onClick={handleClick}&gt;
      &lt;WrappedComponent
        type={times &gt; 5 ? "danger" : "primary"}
        {..._props}
      &gt;
        {children} &lt;small&gt;({times} times clicked)&lt;/small&gt;
      &lt;/WrappedComponent&gt;
    &lt;/span&gt;
  )
}</pre>
<p>有了这三个hoc，我们就可以以这种方式将它们应用到我们的元素中…</p>
<pre>const ButtonWithTrack = withStateTimes(withHandlerClick(withDisplayTrack(Button)));</pre>
<p>这是怎么回事？嗯，<code>withDisplayTrack(Button)</code>返回一个在<code>withHandlerClick</code>调用中使用的组件，该组件也将返回一个在<code>withStateTimes</code>调用中使用的组件，该组件将返回我们的最终组件(<code>ButtonWithTrack</code>)。</p>
<p>正如你所看到的，这个想法很好，因为我们可以以这种方式重用我们的代码，但是创建这些hoc有点复杂，并且以这种方式应用它们也有点难以理解。</p>
<p>这有什么改进吗？</p>
<p>重组救援！！🙂</p>
<h2>重写</h2>
<p>什么是重组？用他们自己的话说:</p>
<blockquote><p><a class="markup--anchor markup--pullquote-anchor" href="https://github.com/acdlite/recompose" target="_blank" rel="noopener noreferrer" data-href="https://github.com/acdlite/recompose">重组</a>是功能组件和高阶组件的React实用带。把它想象成反应的<a class="markup--anchor markup--pullquote-anchor" href="https://lodash.com/docs/4.17.10#lodash" target="_blank" rel="noopener noreferrer" data-href="https://lodash.com/docs/4.17.10#lodash">洛达什</a>。</p></blockquote>
<p>因此，这是一套我们可以用来改进我们的HOC的组织、创建和应用的方法，鼓励使用与HOC的组合相结合的功能性无状态组件。</p>
<p>先说最常用的重新构图方法:<code>compose</code>。</p>

<p>通过<code>compose</code>，我们可以<em>将多个高阶分量组合成一个高阶分量</em>。</p>
<p>在我们的场景中，使用<code>compose</code>，我们现在可以这样表达hoc的应用:</p>
<pre>import { compose } from "recompose";

...

const ButtonWithTrack = compose(
  withStateTimes,
  withHandlerClick,
  withDisplayTrack
)(Button)</pre>
<p>更清晰易读，对吗？</p>

<p>我们场景中另一个有用的重组方法是<code>withState</code>。</p>
<p>该方法创建了一个与我们在<code>withStateTimes.js</code>中实现的行为几乎相同的特设</p>
<ul>
<li>它添加了一个状态属性</li>
<li>它创建一个<em>处理程序</em>来设置这个状态属性的值</li>
<li>它允许我们设置一个初始值</li>
</ul>
<p>所以，用<em class="markup--em markup--p-em">重组</em>，现在我们可以这样表达同样的逻辑…</p>
<pre>...
import { withState } from "recompose";
const withStateTimes = withState('times', 'setTimes', 0)
...</pre>
<p>真的吗？是的，真的🙂</p>
<p>重组的效用开始变得有意义了，对吗？</p>

<p>让我们继续改进我们场景的代码。让我们坐特设的<code>withHandlerClick</code>。为了改进这个特设的创建，我们可以使用Recompose的<code>withHandlers</code>方法。</p>
<pre>import { withHandlers } from "recompose";

const withHandlerClick = withHandlers({
  handleClick: props =&gt; e =&gt; {
    let { times, onClick, setTimes } = props;
    e.preventDefault()
    setTimes( ++times );
    onClick &amp;&amp; onClick();
  }
})</pre>
<p><code>withHandlers</code>方法获取处理程序创建者的对象映射。传递给<code>withHandlers</code>的这个对象的每个属性应该是一个高阶函数，它接受一组props并返回一个函数处理程序。这样，我们可以生成一个可以访问组件的<code>props</code>的处理程序。</p>

<p>在我们的例子中，如果我们用<a class="markup--anchor markup--p-anchor" href="https://chrome.google.com/webstore/detail/react-developer-tools/fmkadmapgofadopljbjfkapdkoienihi" target="_blank" rel="noopener noreferrer" data-href="https://chrome.google.com/webstore/detail/react-developer-tools/fmkadmapgofadopljbjfkapdkoienihi"> React开发工具</a>调试代码，那么<code>withDisplayTrack</code>返回的组件显示为<code>Unknown</code>。</p>
<p>为了解决这个问题，我们可以使用Recompose的<code>setDisplayName</code> to <code>export</code> a final HOC返回一个名为<code>ComponentWithDisplayTrack</code>的组件。</p>
<pre>export default compose(
  setDisplayName('ComponentWithDisplayTrack'),
  withDisplayTrack
);</pre>

<p>使用方法<code>lifecycle</code>,我们可以将生命周期方法添加到我们的函数语法组件中。</p>
<p>在我们的场景中，我们可以添加一个不同版本的按钮来显示待处理消息的数量。</p>
<p>我们可以使用一个<code>messages</code> props创建一个HOC来返回按钮的不同视图:</p>
<pre>import React from "react";
import { compose, setDisplayName } from "recompose";

const withDisplayMessages = WrappedComponent =&gt; props =&gt; {
  const { children, messages, loading, ..._props } = props;
  return (
    &lt;WrappedComponent {..._props}&gt;
      {children}
      {loading ? (
        &lt;span className="fas fa-spinner fa-pulse"&gt; &lt;/span&gt;
      ) : (
        &lt;span className="badge badge-light"&gt;{messages}&lt;/span&gt;
      )}
    &lt;/WrappedComponent&gt;
  );
};

export default compose(
  setDisplayName("withDisplayMessages"),
  withDisplayMessages
);</pre>
<p>我们可以向我们的组件添加一个<code>componentDidMount</code>生命周期方法，它将添加:</p>
<ul>
<li>当我们的假请求开始时，一个<code>loading</code>状态被设置为<code>true</code>,当它结束时，被设置为<code>false</code></li>
<li>一个<code>messages</code>状态，这个值将被我们的假请求返回的随机数更新</li>
</ul>
<p>这里管理的<code>loading</code>和<code>messages</code>状态都将向返回的组件添加一个新的属性，用于传播相应的值:</p>
<pre>import { lifecycle } from "recompose";

const getPendingMessages = () =&gt; {
  const randomNumber = Math.ceil(Math.random() * 10);
  return new Promise(resolve =&gt; {
    setTimeout(() =&gt; resolve(randomNumber), randomNumber * 1000);
  });
};

const withDidMountStateMessages = lifecycle({
  componentDidMount() {
    this.setState({ loading: true });
    getPendingMessages().then(messages =&gt; {
      this.setState({ loading: false, messages });
    });
  }
});

export default withDidMountStateMessages;</pre>
<p>有了这些新的hoc，我们现在可以快速创建我们的新型<code>Button</code>:</p>
<pre>const ButtonWithMessages = compose(
  withDidMountStateMessages, 
  withDisplayMessages
)(Button)</pre>

<p>有了这些hoc，我们就可以用很少的几行把这些新的行为转换成一个链接。我们可以添加<code>defaultProps</code>来改变链接的默认类型。</p>
<pre>const LinkWithMessages = compose(
  defaultProps({ type: "info" }),
  withDidMountStateMessages,
  withDisplayMessages
)(Link);</pre>
<h2>结论</h2>
<p>使用这些方法，我们可以通过轻松地创建另一个版本的<code>Button</code>(只是为了显示这种模式的灵活性)来完成我们的演示，该版本跟踪从3到0的点击，并添加另一个<code>prop</code>，以便我们可以在倒计时到达0时更改<code>type</code>。</p>
<pre>const ButtonWithTrackCountdown = compose(
  withState('times', 'setTimes', 3),
  withState('type', 'setType', 'primary'),
  withHandlers({
    handleClick: props =&gt; e =&gt; {
      let { times, onClick, setTimes, setType } = props;
      e.preventDefault()
      if ( times &lt;= 0 ) {  setType('secondary') }
      else { setTimes( --times ) }
      onClick &amp;&amp; onClick();
    }
  }),
  withDisplayTrack
)(Button)</pre>
<p>正如您所看到的，使用Recompose可以更容易地将逻辑委托给小的高阶组件，然后<em>将它们组合成更复杂的HOC，我们可以使用它来创建组件的不同版本，重用我们的大部分代码。</em></p>
<p>此外，重新组合不鼓励使用<code>Class</code>语法来创建组件，而鼓励使用功能性无状态组件和更高级的组件相结合。</p>
<p>仅使用功能组件的最重要优势是:</p>
<ul>
<li>他们鼓励代码更加可重用和模块化</li>
<li>他们不鼓励庞大复杂的组件做太多的事情</li>
</ul>
<p>基本上，一旦您了解了重组方法的工作方式，它就简化了React组件的开发和组织。</p>
<p>有更多的方法可以用来以更简单的方式产生更多的高阶分量。</p>
<p>在<a class="markup--anchor markup--p-anchor" href="https://github.com/acdlite/recompose" target="_blank" rel="noopener noreferrer" data-href="https://github.com/acdlite/recompose">官方回购</a>中，你可以找到一些对你的项目有用的<a class="markup--anchor markup--p-anchor" href="https://github.com/acdlite/recompose/wiki/Recipes" target="_blank" rel="noopener noreferrer" data-href="https://github.com/acdlite/recompose/wiki/Recipes">重组食谱</a>。</p>
<p>此外，这里有这篇文章中使用的代码和结果的现场演示。</p>
<p/>
<p>那么，现在你对<em class="markup--em markup--p-em">重新作曲</em>有了更多的了解……你的第一印象是什么？在创建组件时，你认为这是一个好方法吗？</p>
<p>我的看法是…我喜欢！我真的很喜欢Recompose鼓励的面向创建小而简单的片段(组件和hoc)的模式，这些片段可以用于以易读的方式创建更复杂的片段，并且是面向函数式编程的。</p>
<p>嗯，那是我的看法。你呢？</p><div class="code-block code-block-17">
<div class="blog-plug inline-plug react-plug" vwo-el-id="26283398190">
<h2 vwo-el-id="41600691720">使用LogRocket消除传统反应错误报告的噪音</h2>
<a href="https://lp.logrocket.com/blg/react-signup-issue-free" target="_blank" vwo-el-id="19356441070">LogRocket
</a><p>是一款React analytics解决方案，可保护您免受数百个误报错误警报的影响，只针对少数真正重要的项目。LogRocket告诉您React应用程序中实际影响用户的最具影响力的bug和UX问题。</p><a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="19356441380">
<img class="first-react-image alignnone size-full wp-image-46 jetpack-lazy-image jetpack-lazy-image--handled" src="../Images/f300c244a1a1cf916df8b4cb02bec6c6.png" vwo-el-id="18272717540" data-lazy-loaded="1" data-original-src="https://files.readme.io/27c94e7-Image_2017-06-05_at_9.46.04_PM.png"/>
</a>
<a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="19356441690">
<img class="second-react-image alignnone size-full wp-image-46 jetpack-lazy-image jetpack-lazy-image--handled" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" vwo-el-id="30720362350" data-lazy-loaded="1" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/>
</a>
<a href="https://lp.logrocket.com/blg/react-signup-issue-free" target="_blank" rel="noopener noreferrer" vwo-el-id="35866400580">LogRocket
</a><p>自动聚合客户端错误、反应错误边界、还原状态、缓慢的组件加载时间、JS异常、前端性能指标和用户交互。然后，LogRocket使用机器学习来通知您影响大多数用户的最具影响力的问题，并提供您修复它所需的上下文。</p><p vwo-el-id="28675661060">关注重要的React bug—<a class="signup" href="https://lp.logrocket.com/blg/react-signup-issue-free" target="_blank" rel="noopener noreferrer" vwo-el-id="40093418840">今天就试试LogRocket】。</a></p>
</div></div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
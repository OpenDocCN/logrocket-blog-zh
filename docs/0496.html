<html>
<head>
<title>The best Rust frameworks for web dev and desktop apps - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>web开发和桌面应用程序的最佳Rust框架</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/the-best-rust-frameworks-to-check-out-in-2019/#0001-01-01">https://blog.logrocket.com/the-best-rust-frameworks-to-check-out-in-2019/#0001-01-01</a></blockquote><div><article class="article-post">
<p>开发人员可以使用带有<a href="https://www.rust-lang.org/"> Rust </a>的框架来构建快速、高度可伸缩、内存高效的软件。无论您是在构建CLI工具、服务器或客户端的web应用、网络服务、嵌入式系统软件还是桌面软件，Rust都足以满足您的所有编程需求。</p>
<p/>
<p>框架通常是工具、助手和库的组合，提供了一种(快速、轻松地)构建、测试和运行应用程序的方法。它为构建软件奠定了基础。选择框架时要注意的关键方面是它的架构和特性(比如对定制的支持、灵活性、可扩展性、安全性、与其他库的兼容性等)。</p>
<p>本文旨在展示几种不同领域的Rust框架，突出它们的优点和缺点。最后，您应该能够对适合您需求的Rust框架做出明智的决定。</p>
<h2>rust web开发框架</h2>

<p>凭借GitHub上的8k stars，Rocket是最成熟、生产就绪、全栈的web框架之一。它的主要优点是,<a href="https://medium.com/@lholznagel/comparing-nodejs-and-rust-http-frameworks-response-times-5738dfa1843d" target="_blank" rel="noopener noreferrer">不会像许多框架那样让你为了一个高效的环境而牺牲速度，反之亦然。它有助于编写快速、安全的web应用程序，并且不会牺牲灵活性、可用性或类型安全性。</a></p>
<p>其他值得注意的酷事包括:</p>
<ul>
<li>它支持JSON开箱即用，所以你不需要有另一个依赖</li>
<li>表单处理简单易行。它不会让错误的表单请求通过，因此您的代码不会中断。它让您可以完全控制应用程序的所有方面</li>
<li>它带有内置的模板支持</li>
<li>您可以轻松地查看、添加或删除加密或未加密的cookies</li>
<li>它类型检查路由URL</li>
<li>它使用内置的测试库轻松地在您的应用程序上运行单元测试</li>
<li>您可以按照自己的方式为开发、试运行和生产配置您的应用程序</li>
</ul>
<p>我最喜欢的特性是不必担心样板代码。Rocket大量使用Rust的代码生成工具来提供一个干净的API，所以如果你想构建一个服务器渲染的web app，Rocket是一个很棒的工具。查看更多关于超级易懂的<a href="https://rocket.rs/v0.4/guide/" target="_blank" rel="noopener noreferrer">文档</a>。</p>

<p>Actix是一个服务器渲染的框架。该架构基于Rust非常强大的actor系统，并标榜自己是一个有趣的网络框架。根据这个<a href="https://www.techempower.com/benchmarks/#section=data-r18" target="_blank" rel="noopener noreferrer">基准</a>，Actix是最快的web框架。它非常适合用硬逻辑和组件编写服务。您还可以以异步方式使用这些服务。</p>
<p>它还提供了很多特性(比如日志、http/2等。)开箱。根据您的偏好，它的样板代码可以帮助您快速入门，或者如果您正在编写一个简单的应用程序，它就显得有些多余。这是一个很棒的框架，有适当的文档。在此了解如何开始<a href="https://actix.rs/docs/" target="_blank" rel="noopener noreferrer">。即使对完全的初学者来说，这也是容易做到的。</a></p>

<p>Nickel也是一个用于构建服务器呈现的web应用程序的web框架。对于用Rust编写的web应用程序来说，它是一个简单而轻量级的基础。它的<a href="https://docs.rs/nickel/0.11.0/nickel/" target="_blank" rel="noopener noreferrer"> API </a>受到了流行的JavaScript express框架的启发。</p>
<p>它对你应该如何写你的代码没有自己的看法，这意味着它没有一个模板或者给出具体的做事方法，并且有一个更渐进的学习曲线。Nickel支持用<a href="https://github.com/spullara/mustache.rs" target="_blank" rel="noopener noreferrer"> mustache.rs </a>定义模板，你需要做的就是创建模板。</p>
<p>Nickel可以很容易地将JSON数据直接映射到您的<code>struct</code>上，默认情况下，Nickel用它的默认<code>ErrorHandler</code>捕捉所有错误，并尝试采取合理的行动。因此不需要编写自己的自定义错误处理程序。</p>
<p>路由可以像/fizzBuzz一样简单，使用参数、通配符甚至双通配符。中间件是Nickel的扩展点。它与现有的中间件一起开箱即用，如果您愿意，您可以对其进行扩展。<a href="https://nickel-org.github.io/getting-started.html" target="_blank" rel="noopener noreferrer">入门指南</a>可以马上帮你。</p>

<p>受<a href="https://elm-lang.org/" target="_blank" rel="noopener noreferrer"> Elm </a>和<a href="https://reactjs.org/" target="_blank" rel="noopener noreferrer"> React </a>的启发，Yew是一个用<a href="https://webassembly.org" target="_blank" rel="noopener noreferrer"> WebAssembly </a>构建多线程web客户端应用的现代框架，通常被称为WASM。它包含许多出色的功能，例如:</p>
<ul>
<li>可重用组件架构</li>
<li>另一个很酷的功能是服务。它们允许跨组件重用相同的逻辑。这些服务是无状态的。它利用了代理的概念，代理也用于跨组件共享数据，并为应用程序提供整体状态</li>
<li>它使用<a href="https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API" target="_blank" rel="noopener noreferrer"> WebWorkers API </a>在单独的线程中生成代理，并使用一个附加到线程的本地调度程序来执行并发任务。这使得用Rust编写的浏览器中的高并发应用成为可能</li>
</ul>
<p>一些缺点包括:</p>
<ul>
<li>测试并不完全有益健康。是的，您可以测试单个服务，但是目前还没有办法测试组件或代理。在撰写本文时，集成和端到端测试都无法在plain Rust中完成</li>
<li>红豆杉似乎处于早期阶段，因此，没有一个适当的官方指导如何使用它</li>
</ul>
<h2>为桌面应用程序使用Rust</h2>

<p>与JavaScript的<a href="https://electronjs.org/" target="_blank" rel="noopener noreferrer"> Electron </a>非常相似，Azul是一个免费的、功能性的、即时模式的GUI框架，用于快速开发用Rust编写的桌面应用程序，由Mozilla WebRender渲染引擎支持。它包含许多有用的功能:</p>
<ul>
<li>跨平台GUI工具包(Windows、Linux、Mac)</li>
<li>即时模式API，窗口小部件通过函数组合来组成</li>
<li>CSS样式引擎，基于flexbox的布局</li>
<li>常见用户界面元素的内置控件</li>
<li>通过功能组合创建自定义小部件</li>
<li>SVG渲染引擎，2D绘图助手</li>
<li>OpenGL集成</li>
<li>异步I/O帮助函数</li>
<li>XML序列化和热重装，内置XML-to-Rust编译器</li>
<li>单一部署二进制文件、最小二进制文件大小(大约5MB全包)、CPU(0–4%)和RAM使用量(总共约50MB)</li>
<li>硬件加速的OpenGL渲染(0.5-4毫秒)</li>
<li>react-like DOM differing用于增量布局和样式更改</li>
</ul>
<p><strong>缺点包括:</strong></p>
<ul>
<li>它没有一个广泛的社区，仍然处于早期阶段。尽管如此，它已经可以生产了。</li>
</ul>
<p>这里 <span>开始使用<a href="https://github.com/maps4print/azul/wiki" target="_blank" rel="noopener noreferrer">。</a></span></p>

<p>Conrod是一个用于Rust的可移植的2D图形用户界面库。它提供了一个即时模式的API，该API包装了保留模式的小部件状态图，允许暴露一个简单、健壮和反应式的界面，同时接近传统的保留GUI框架的性能。</p>
<p>中间模式指的是用户界面API的一种风格，其中GUI部件使用更新或绘制循环中的函数进行实例化，这与更传统的“保留模式”截然不同，后者在设置阶段构建部件类型。</p>
<p>功能包括:</p>
<ul>
<li>一种易于使用的风格，适用于高度动态的界面和那些需要频繁同步应用程序状态的界面</li>
<li>高性能</li>
<li>然而，它需要大量的稳定性，在我看来，它还不是一个完全健壮的框架，但由于它的即时模式API方法，它显示了很大的前景</li>
</ul>
<p>从这里开始<a href="https://docs.rs/conrod/0.61.1/conrod/guide/chapter_2/index.html" target="_blank" rel="noopener noreferrer">。</a></p>

<p>基于非常成熟的跨平台用户界面库<a href="https://wiki.qt.io/Main" target="_blank" rel="noopener noreferrer"> Qt </a>。大多数语言都有包装器，当然Rust也不例外。</p>
<p>它拥有Qt的所有巨大优势，当然还有rust的标志性特征——小二进制文件。这些功能包括:</p>
<ul>
<li>开发允许通过简单的重新编译将应用程序移植到多个平台</li>
<li>它提高了开发效率，缩短了上市时间，使应用程序面向未来</li>
<li>使用Qt进行开发简化了技术策略，并最终降低了成本</li>
<li>通过在所有屏幕和平台上部署一个代码来节省时间</li>
<li>Rust中的编码给了开发人员更大的控制力，以及使用大量现有库的可能性</li>
<li>代码被编译成全速运行的本机二进制文件(不需要使用虚拟机)</li>
<li>它的跨平台软件开发使得为所有用户创建直观的体验变得容易，无论使用什么系统</li>
</ul>
<p><strong>缺点包括:</strong></p>
<ul>
<li>它固有地遭受了Qt带来的同样的缺点，比如QObject和QWidget不是线程安全的</li>
<li>用户体验(UX)远非顺畅。在桌面平台上，更容易开发原生用户体验，因为有更多的通用模式和小部件，同时，移动UX是不同的，缺乏平台特定的东西</li>
<li>当默认使用QT GUI组件时，您不会得到iOS和Android的理想外观和感觉</li>
</ul>
<p>Qt是一个经过验证的跨平台应用程序开发框架，Rust的加入使这个框架变得强大，可能是最成熟的GUI Rust框架。由于Rust Qt绑定生成器在Rust中被重写，现在可以作为一个货箱使用，所以您不必担心庞大的构建和接口复杂性。这使得普通情况下的开发变得非常简单。</p>
<h2>结论</h2>
<p>作为一种低级语言，Rust非常适合用传统的方式制作用户界面，使用本地API。可悲的是，在当今世界，通常涉及到支持许多平台，使用原生API对许多人来说是没有吸引力的选择。</p>
<p>然而，Rust的表现力和高级抽象使它成为构建错综复杂的用户界面的理想选择。不幸的是，对于什么是最好的抽象还没有达成共识，特别是对于网络的独特性。使用适合您的用例的方法，并根据需要进行迭代。</p>
<p>还有更多基于Rust的web和GUI框架正处于起步阶段，比如<a href="https://docs.rs/core-foundation/0.6.4/core_foundation/" target="_blank" rel="noopener noreferrer"> core foundation </a>、<a href="https://github.com/xi-editor/druid" target="_blank" rel="noopener noreferrer">德鲁伊</a>、<a href="https://docs.rs/iced/0.1.0-alpha/iced/" target="_blank" rel="noopener noreferrer">冰封</a>、<a href="https://docs.rs/relm/0.17.0/relm/" target="_blank" rel="noopener noreferrer"> relm </a>和<a href="https://doc.servo.org/webrender/index.html" target="_blank" rel="noopener noreferrer"> web renderer </a>等等。你可以查看它们，贡献或者甚至构建你自己的框架。</p>
<p>关于Rust框架在2020年及以后的评估，请查看Rust web框架的当前状态。</p>
<p>快乐编码😀。</p><div class="code-block code-block-29">
<div class="blog-plug inline-plug rust-plug"><h2><a href="https://lp.logrocket.com/blg/rust-signup" target="_blank">log rocket</a>:Rust应用的web前端的全面可见性</h2><p>调试Rust应用程序可能很困难，尤其是当用户遇到难以重现的问题时。如果您对监控和跟踪Rust应用程序的性能、自动显示错误、跟踪缓慢的网络请求和加载时间感兴趣，</p><a href="https://lp.logrocket.com/blg/rust-signup" target="_blank">try LogRocket</a><p>. </p><a class="signup" href="https://lp.logrocket.com/blg/rust-signup" target="_blank" rel="noopener noreferrer"><img class="alignnone size-full wp-image-46 jetpack-lazy-image" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/><noscript><img data-lazy-fallback="1" class="alignnone size-full wp-image-46" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/></noscript></a><p>LogRocket 就像是网络和移动应用程序的DVR，记录你的Rust应用程序上发生的一切。您可以汇总并报告问题发生时应用程序的状态，而不是猜测问题发生的原因。LogRocket还可以监控应用的性能，报告客户端CPU负载、客户端内存使用等指标。</p><p>现代化调试Rust应用的方式— <a class="signup" href="https://lp.logrocket.com/blg/rust-signup" target="_blank" rel="noopener noreferrer">开始免费监控</a>。</p></div>


</div>

<p class="clearfix"/>
 <p class="clearfix"/>
</article>

</div>    
</body>
</html>
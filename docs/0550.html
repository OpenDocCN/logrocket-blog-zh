<html>
<head>
<title>React Table: A complete guide with updates for TanStack Table - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>React Table:一个完整的指南，包含对TanStack Table - LogRocket博客的更新</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/react-table-complete-guide/#0001-01-01">https://blog.logrocket.com/react-table-complete-guide/#0001-01-01</a></blockquote><div><article class="article-post">
<p><em> <strong>编者按</strong>:本教程最后一次更新是在2022年12月23日，以反映包含在TanStack表v8中的更新。</em></p>
<p>作为组织复杂数据最流行的方式之一，表格用户界面在web产品中非常常见。然而，从头开始构建一个表格UI可能是一个很高的要求，尤其是React，众所周知它让开发人员很头疼。</p>
<p>幸运的是，有各种各样的工具和库可以让创建React表的体验变得更加简单和有益，最著名的是<a href="https://react-table.tanstack.com/"> TanStack Table </a>，以前称为React table。</p>
<p>在本教程中，我们将向您展示如何构建一个具有基本排序和搜索功能的智能React数据表UI。在撰写本文时，TanStack表v8的迁移指南尚不可用。因此，我们将使用React表的最新稳定版本v7。</p>
<p>我们将详细介绍以下内容:</p>

<h2 id="when-use-table-react">React中何时使用表格</h2>
<p>React中表格用户界面的一些常见用例包括显示财务报告、体育排行榜、定价和比较页面的数据，仅举几例:</p>
<p><img data-attachment-id="154509" data-permalink="https://blog.logrocket.com/react-table-use-cases/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2023/01/react-table-use-cases.png" data-orig-size="730,548" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="react-table-use-cases" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2023/01/react-table-use-cases-300x225.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2023/01/react-table-use-cases.png" decoding="async" class="aligncenter wp-image-154509 size-full jetpack-lazy-image" src="../Images/112a3a2be4cc4f0508b51b9bfdb8e3db.png" alt="React Table Use Cases" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2023/01/react-table-use-cases.png 730w, https://blog.logrocket.com/wp-content/uploads/2023/01/react-table-use-cases-300x225.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2023/01/react-table-use-cases.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2023/01/react-table-use-cases.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="154509" data-permalink="https://blog.logrocket.com/react-table-use-cases/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2023/01/react-table-use-cases.png" data-orig-size="730,548" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="react-table-use-cases" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2023/01/react-table-use-cases-300x225.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2023/01/react-table-use-cases.png" decoding="async" loading="lazy" class="aligncenter wp-image-154509 size-full" src="../Images/112a3a2be4cc4f0508b51b9bfdb8e3db.png" alt="React Table Use Cases" srcset="https://blog.logrocket.com/wp-content/uploads/2023/01/react-table-use-cases.png 730w, https://blog.logrocket.com/wp-content/uploads/2023/01/react-table-use-cases-300x225.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2023/01/react-table-use-cases.png"/></noscript>
<p>一些广泛使用表格的产品包括Airtable、Asana List View、Asana Timeline、Google Sheets和idea Table。一些使用React Table的科技巨头包括谷歌、苹果和微软。</p>
<h2 id="what-react-table">什么是反应表？</h2>
<p><a href="https://github.com/tannerlinsley/react-table"> React表</a>是React中使用最广泛的表库之一。在撰写本文时，它在GitHub上有超过20，000颗星，接收频繁的更新，并支持钩子。React表库是非常轻量级的，提供了简单表所需的所有基本特性。</p>
<h3 id="react-table-v7">反应表v7</h3>
<p>2020年3月，React Table创建者Tanner Linsley发布了<a href="https://github.com/tannerlinsley/react-table/releases/tag/v7.0.0"> React Table v7 </a>，他将其描述为“一年多来将整个库重构为一个只有钩子的UI/样式/标记不可知的表构建实用程序的工作的高潮。”</p>
<p>React Table v7由一组React挂钩和插件组成，旨在帮助您将复杂数据网格的逻辑特性组合成一个单一的、高性能的、可扩展的和非独立的API，该API由主<code>useTable</code>挂钩返回。</p>
<p>作为一个无头工具，React Table不呈现或提供现成的数据表UI元素。因此，您负责使用React表挂钩的状态和回调来呈现您自己的表标记。</p>
<h3 id="tanstack-table-react-table-v8">转栈表v8</h3>
<p>2022年7月1日，Tanner宣布发布TanStack table ，这是React Table v7的一次重大升级。</p>
<p>TanStack Table v8的设计比v7性能更高，功能更丰富，支持其他web框架，如Vue、Solid和Svelte。在本文的后面，我们将看到从React Table v7的潜在迁移可能是什么样子。</p>
<h3 id="when-use-react-table">何时使用React表</h3>
<p>当您的表格UI需要以下任何一项时，您应该考虑React Table:</p>
<ul>
<li>排序、过滤和分页等基本功能</li>
<li>在不影响功能的情况下为表格定制用户界面设计</li>
<li>易扩展性；您可以使用自定义插件挂钩在React Table上构建自己的特性</li>
</ul>
<h3 id="when-not-use-react-table">何时不使用React表</h3>
<p>当您需要以下任一项时，应该考虑使用另一个React数据表库:</p>
<ul>
<li>对固定标题和列的默认支持</li>
<li>对触摸和非触摸设备的水平和垂直滚动的现成支持。</li>
</ul>
<p>React Table不支配UI；它是无头的。因此，根据我们的需求来定义UI是我们的责任。</p>
<p>尽管我们可以在React表中实现<a href="https://blog.logrocket.com/build-inline-editable-ui-react/">对行内编辑列的支持，但这超出了我们的表的范围。我们需要在React Table上创建一个插件或组件来支持这些特性。React Table名副其实，最适合呈现简单的表格。</a></p>
<p>就性能而言，React Table不能处理无限长的表，比如Google Sheet。React Table适用于中等大小的表，但不适用于长表。</p>
<h3 id="use-cases-react-table">React表的用例</h3>
<p>最后，对于需要基本功能(如搜索、排序、过滤等)的简单表，您应该考虑React Table。一些好的例子可能包括带有统计数据的体育排行榜或带有自定义元素的金融数据表。</p>
<p>在本教程中，我们将演示如何使用React Table构建一个简单的Airtable克隆。但是首先，让我们快速回顾一下全功能React表UI的特性，并讨论一些与在React中构建数据表相关的常见挑战。</p>
<h2 id="react-table-ui-features">反应表用户界面特性</h2>
<p>React数据表UI的一些基本功能包括:</p>
<ul>
<li>不折不扣的UX和用户界面:清晰易懂的排版和表格用户界面中的自定义元素</li>
<li>加载数据的远程数据调用</li>
<li>搜索表格或特定列</li>
<li>基本过滤和排序选项</li>
</ul>
<p>React数据表UI中的高级功能可能包括:</p>
<ul>
<li>基于数据类型，如数字、字符串、布尔、选择输入等，为列定制排序和过滤选项。</li>
<li>无限长表的分页支持</li>
<li>显示和隐藏列</li>
<li>支持对列数据的内联编辑</li>
<li>支持通过模式面板或细节面板编辑一整行数据</li>
<li>固定标题和固定列，便于查看数据</li>
<li>支持多种类型的设备；响应性</li>
<li>可调整大小的列，以适应列内的长数据点，即多行注释</li>
<li>水平和垂直滚动支持</li>
<li>可展开的行，显示关于该行的完整数据</li>
</ul>
<h2 id="common-ux-challenges-react-table-ui">React表格用户界面中常见的UX挑战</h2>
<p>就UI而言，数据表是以有组织的方式显示复杂数据的最佳选择之一。但是，从UX的角度来看，表格是很棘手的，当你支持多种设备时，它们很容易失控。</p>
<p>例如，如果不改变布局以适应更小的屏幕尺寸，就很难使表格具有响应性。此外，表格可能需要双向滚动。默认浏览器滚动条适用于全宽表格，但大多数表格都是自定义宽度的。自定义滚动条在触摸屏和非触摸屏上都很难支持。</p>
<p>根据数据长度管理列宽是很棘手的。当我们在表中加载动态数据时，我们经常会遇到UX毛刺。每次数据发生变化时，列宽都会调整，从而导致对齐故障。在设计UX时，我们需要小心处理这些问题。</p>
<h2 id="when-build-react-table-ui">何时在React中构建自己的表格UI</h2>
<p>在以下场景中，您可能希望构建自己的React表格UI:</p>
<ul>
<li>当你的桌子只是一个没有太多互动的橱窗时</li>
<li>当您需要表格的自定义用户界面时</li>
<li>当您需要一个没有任何功能的轻量级桌子时</li>
</ul>
<p>以下是在React中构建自己的表格的一些常见用例:</p>
<ul>
<li>带有比较表的产品和营销页面</li>
<li>定价表</li>
<li>具有自定义样式的简单表格，除了简单的弹出文本之外，不需要对列进行很多交互</li>
</ul>
<h2 id="react-table-example-building-react-table-component">React表示例:构建React <code>Table</code>组件</h2>
<p>够理论；让我们深入一个真实的例子。为了演示如何在React Table中创建一个<code>Table</code>组件，我们将构建一个具有排序和搜索等基本功能的简单表格UI。这是我们将要使用的<a href="https://logrocket-smart-table.netlify.app/">反应表示例</a>。</p>
<p>首先，使用Create React app创建一个新的React App:</p>
<pre>npx create-react-app react-table-demo
</pre>
<h3 id="calling-api-axios">用Axios调用API</h3>
<p>对于我们的应用程序，我们将使用Axios从<a href="https://www.tvmaze.com/api"> TVMAZE API </a>中检索带有搜索词<code>snow</code>的电影信息。以下是此操作的终点:</p>
<pre>https://api.tvmaze.com/search/shows?q=snow
</pre>
<p>要调用API，让我们安装Axios:</p>
<pre>npm install axios
# OR
yarn add axios
</pre>
<p>接下来，用下面的代码替换<code>default arc/App.js</code>文件的内容:</p>
<pre>// App.js

import axios from "axios";
import { useState, useEffect } from "react";

import Table from "./Table";
import "./App.css";

function App() {
  // data state to store the TV Maze API data. Its initial value is an empty array
  const [data, setData] = useState([]);

  // Using useEffect to call the API once mounted and set the data
  useEffect(() =&gt; {
    (async () =&gt; {
      const result = await axios("https://api.tvmaze.com/search/shows?q=snow");
      setData(result.data);
    })();
  }, []);

  return &lt;div className="App"&gt;&lt;/div&gt;;
}
export default App;
</pre>
<p>上面，我们创建了一个名为<code>data</code>的状态。一旦组件安装完毕，我们使用Axios从TVMAZE API获取电影内容，并将返回的结果设置为<code>data</code>。</p>
<h3 id="adding-react-table-to-app">将React表添加到您的应用程序</h3>
<p>使用下面的命令添加React表:</p>
<pre>npm install react-table
# OR
yarn add react-table
</pre>
<p><a href="https://blog.logrocket.com/react-hooks-cheat-sheet-unlock-solutions-to-common-problems-af4caf699e70/"> React工作台使用React挂钩</a>。它有一个名为<code>useTable</code>的主表挂钩，以及一个添加插件挂钩的插件系统。因此，React Table很容易根据我们的客户需求进行扩展。</p>
<p>让我们用<code>useTable</code>钩子创建我们的基本UI。接下来，我们将创建一个新的<code>Table</code>组件，它将接受两个道具<code>data</code>和<code>columns</code>。<code>data</code>道具是我们通过API调用得到的数据，而<code>columns</code>是定义表格列、标题、行以及如何显示行等的对象。我们很快会在代码中看到它:</p>
<p>在<code>/src</code>文件夹中，创建一个新的<code>Table.js</code>文件并粘贴以下代码:</p>
<pre>// Table.js

export default function Table({ columns, data }) {
   // Table component logic and UI come here
}
</pre>
<p>让我们修改<code>App.js</code>中的内容，以包含我们的表的列，并呈现<code>Table</code>组件:</p>
<pre>// App.js

import axios from "axios";
import React, { useMemo, useState, useEffect } from "react";

import Table from "./Table";
import "./App.css";

function App() {
  /* 
    - Columns is a simple array right now, but it will contain some logic later on. It is recommended by react-table to memoize the columns data
    - Here in this example, we have grouped our columns into two headers. react-table is flexible enough to create grouped table headers
  */

  const columns = useMemo(
    () =&gt; [
      {
        // first group - TV Show
        Header: "TV Show",
        // First group columns
        columns: [
          {
            Header: "Name",
            accessor: "show.name",
          },
          {
            Header: "Type",
            accessor: "show.type",
          },
        ],
      },
      {
        // Second group - Details
        Header: "Details",
        // Second group columns
        columns: [
          {
            Header: "Language",
            accessor: "show.language",
          },
          {
            Header: "Genre(s)",
            accessor: "show.genres",
          },
          {
            Header: "Runtime",
            accessor: "show.runtime",
          },
          {
            Header: "Status",
            accessor: "show.status",
          },
        ],
      },
    ],
    []
  );

  // data state to store the TV Maze API data. Its initial value is an empty array
  const [data, setData] = useState([]);

  // Using useEffect to call the API once mounted and set the data
  useEffect(() =&gt; {
    (async () =&gt; {
      const result = await axios("https://api.tvmaze.com/search/shows?q=snow");
      setData(result.data);
    })();
  }, []);

  return (
    &lt;div className="App"&gt;
      &lt;Table columns={columns} data={data} /&gt;
    &lt;/div&gt;
  );
}
export default App;
</pre>
<p>在上面的代码中，我们使用了<a href="https://blog.logrocket.com/react-usememo-vs-usecallback-a-pragmatic-guide/"> <code>useMemo</code>钩子</a>来创建一个列的记忆化数组；我们定义了两个级别的标题，每个标题都有不同的列作为我们的表头。</p>
<p>我们已经为所有的列设置了一个访问器，它是由设置为<code>data</code>的TVMAZE API返回的数据。因为我们的数据包含在数组中的<code>show</code>对象中，所以我们所有的访问器都以<code>show</code>开头:</p>
<pre>// sample data array looks like this

[
  {
    "score": 17.592657,
    "show": {
      "id": 44813,
      "url": "http://www.tvmaze.com/shows/44813/the-snow-spider",
      "name": "The Snow Spider",
      "type": "Scripted",
      "language": "English",
      "genres": [
        "Drama",
        "Fantasy"
      ],
      "status": "In Development",
      "runtime": 30,
      "premiered": null,
      "officialSite": null,
      "schedule": {
        "time": "",
        "days": [

        ]
      }
      ...
  },
  {
    // next TV show
  }
...
]
</pre>
<p>现在，让我们完成我们的<code>Table</code>组件:</p>
<pre>// Table.js

import React from "react";
import { useTable } from "react-table";

export default function Table({ columns, data }) {
  // Use the useTable Hook to send the columns and data to build the table
  const {
    getTableProps, // table props from react-table
    getTableBodyProps, // table body props from react-table
    headerGroups, // headerGroups, if your table has groupings
    rows, // rows for the table based on the data passed
    prepareRow // Prepare the row (this function needs to be called for each row before getting the row props)
  } = useTable({
    columns,
    data
  });

  /* 
    Render the UI for your table
    - react-table doesn't have UI, it's headless. We just need to put the react-table props from the Hooks, and it will do its magic automatically
  */
  return (
    &lt;table {...getTableProps()}&gt;
      &lt;thead&gt;
        {headerGroups.map(headerGroup =&gt; (
          &lt;tr {...headerGroup.getHeaderGroupProps()}&gt;
            {headerGroup.headers.map(column =&gt; (
              &lt;th {...column.getHeaderProps()}&gt;{column.render("Header")}&lt;/th&gt;
            ))}
          &lt;/tr&gt;
        ))}
      &lt;/thead&gt;
      &lt;tbody {...getTableBodyProps()}&gt;
        {rows.map((row, i) =&gt; {
          prepareRow(row);
          return (
            &lt;tr {...row.getRowProps()}&gt;
              {row.cells.map(cell =&gt; {
                return &lt;td {...cell.getCellProps()}&gt;{cell.render("Cell")}&lt;/td&gt;;
              })}
            &lt;/tr&gt;
          );
        })}
      &lt;/tbody&gt;
    &lt;/table&gt;
  );
}
</pre>
<p>上面，我们将<code>columns</code>和<code>data</code>传递给<code>useTable</code>。<code>useTable</code>钩子将返回表格、主体和转换数据的必要属性，以创建标题和单元格。表头通过<code>headerGroups</code>迭代生成，表体行通过<code>rows</code>循环生成:</p>
<pre>{rows.map((row, i) =&gt; {
  prepareRow(row); // This line is necessary to prepare the rows and get the row props from react-table dynamically

  // Each row can be rendered directly as a string using the react-table render method
  return (
    &lt;tr {...row.getRowProps()}&gt;
      {row.cells.map(cell =&gt; {
        return &lt;td {...cell.getCellProps()}&gt;{cell.render("Cell")}&lt;/td&gt;;
      })}
    &lt;/tr&gt;
  );
})}
</pre>
<p>您还会注意到，流派是一个数组，但在我们的最终输出中，它会自动转换为逗号分隔的字符串。</p>
<p>如果我们此时运行我们的应用程序，我们应该得到以下输出:</p>
<p><img data-attachment-id="154511" data-permalink="https://blog.logrocket.com/basic-functionality-table-ui-react/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2023/01/basic-functionality-table-ui-react.png" data-orig-size="730,377" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="basic-functionality-table-ui-react" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2023/01/basic-functionality-table-ui-react-300x155.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2023/01/basic-functionality-table-ui-react.png" decoding="async" class="aligncenter wp-image-154511 size-full jetpack-lazy-image" src="../Images/21ad82ba4fb7bca696f346d9111c28d8.png" alt="Basic Functionality Table UI React" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2023/01/basic-functionality-table-ui-react.png 730w, https://blog.logrocket.com/wp-content/uploads/2023/01/basic-functionality-table-ui-react-300x155.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2023/01/basic-functionality-table-ui-react.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2023/01/basic-functionality-table-ui-react.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="154511" data-permalink="https://blog.logrocket.com/basic-functionality-table-ui-react/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2023/01/basic-functionality-table-ui-react.png" data-orig-size="730,377" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="basic-functionality-table-ui-react" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2023/01/basic-functionality-table-ui-react-300x155.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2023/01/basic-functionality-table-ui-react.png" decoding="async" loading="lazy" class="aligncenter wp-image-154511 size-full" src="../Images/21ad82ba4fb7bca696f346d9111c28d8.png" alt="Basic Functionality Table UI React" srcset="https://blog.logrocket.com/wp-content/uploads/2023/01/basic-functionality-table-ui-react.png 730w, https://blog.logrocket.com/wp-content/uploads/2023/01/basic-functionality-table-ui-react-300x155.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2023/01/basic-functionality-table-ui-react.png"/></noscript>
<h3 id="custom-styling-react-table">React表中的自定义样式</h3>
<p>这个表对于大多数应用程序来说已经足够了，但是如果我们需要定制样式呢？使用React Table，您可以为每个单元格定义自定义样式；可以在<code>column</code>对象中定义样式，如下所示。例如，让我们制作一个类似徽章的自定义组件来显示每个流派:</p>
<pre>// App.js

import React, { useMemo } from "react";
...

// Custom component to render Genres 
const Genres = ({ values }) =&gt; {
  // Loop through the array and create a badge-like component instead of a comma-separated string
  return (
    &lt;&gt;
      {values.map((genre, idx) =&gt; {
        return (
          &lt;span key={idx} className="badge"&gt;
            {genre}
          &lt;/span&gt;
        );
      })}
    &lt;/&gt;
  );
};

function App() {
  const columns = useMemo(
    () =&gt; [
      ...
      {
        Header: "Details",
        columns: [
          {
            Header: "Language",
            accessor: "show.language"
          },
          {
            Header: "Genre(s)",
            accessor: "show.genres",
            // Cell method will provide the cell value; we pass it to render a custom component
            Cell: ({ cell: { value } }) =&gt; &lt;Genres values={value} /&gt;
          },
          {
            Header: "Runtime",
            accessor: "show.runtime",
            // Cell method will provide the value of the cell; we can create a custom element for the Cell        
            Cell: ({ cell: { value } }) =&gt; {
              const hour = Math.floor(value / 60);
              const min = Math.floor(value % 60);
              return (
                &lt;&gt;
                  {hour &gt; 0 ? `${hour} hr${hour &gt; 1 ? "s" : ""} ` : ""}
                  {min &gt; 0 ? `${min} min${min &gt; 1 ? "s" : ""}` : ""}
                &lt;/&gt;
              );
            }
          },
          {
            Header: "Status",
            accessor: "show.status"
          }
        ]
      }
    ],
    []
  );

  . . .
}

. . .
</pre>
<p>我们更新了上面的<code>Genres</code>列，通过迭代并将其值发送到一个定制组件，创建了一个类似徽章的元素。我们还更改了runtime列，根据时间显示手表的小时和分钟。完成这一步后，我们的表格用户界面应该如下所示:</p>
<p><img data-attachment-id="154513" data-permalink="https://blog.logrocket.com/table-ui-react-custom-styling-visual/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2023/01/table-ui-react-custom-styling-visual.png" data-orig-size="730,356" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="table-ui-react-custom-styling-visual" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2023/01/table-ui-react-custom-styling-visual-300x146.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2023/01/table-ui-react-custom-styling-visual.png" decoding="async" class="aligncenter wp-image-154513 size-full jetpack-lazy-image" src="../Images/17daf2208574ba262875f680e2e26e67.png" alt="Table UI React Custom Styling Visual" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2023/01/table-ui-react-custom-styling-visual.png 730w, https://blog.logrocket.com/wp-content/uploads/2023/01/table-ui-react-custom-styling-visual-300x146.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2023/01/table-ui-react-custom-styling-visual.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2023/01/table-ui-react-custom-styling-visual.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="154513" data-permalink="https://blog.logrocket.com/table-ui-react-custom-styling-visual/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2023/01/table-ui-react-custom-styling-visual.png" data-orig-size="730,356" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="table-ui-react-custom-styling-visual" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2023/01/table-ui-react-custom-styling-visual-300x146.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2023/01/table-ui-react-custom-styling-visual.png" decoding="async" loading="lazy" class="aligncenter wp-image-154513 size-full" src="../Images/17daf2208574ba262875f680e2e26e67.png" alt="Table UI React Custom Styling Visual" srcset="https://blog.logrocket.com/wp-content/uploads/2023/01/table-ui-react-custom-styling-visual.png 730w, https://blog.logrocket.com/wp-content/uploads/2023/01/table-ui-react-custom-styling-visual-300x146.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2023/01/table-ui-react-custom-styling-visual.png"/></noscript>
<p>我们已经看到了如何根据我们的需要定制每个单元格的样式；您可以根据数据值为每个单元格显示任何自定义元素。</p>
<h2 id="adding-search-functionality-use-filters">使用<code>useFilters</code>添加搜索功能</h2>
<p>让我们为我们的表添加更多的功能。React表格的<a href="https://github.com/tannerlinsley/react-table/blob/master/docs/examples.md">演示页面</a>已经提供了创建定制智能表格所需的一切。演示中还缺少一样东西，全局搜索功能。我决定使用React表中的<a href="https://react-table-v7.tanstack.com/docs/api/useFilters"> <code>useFilters</code>插件钩子</a>来创建它。</p>
<p>首先，让我们在<code>Table.js</code>中创建一个搜索输入:</p>
<pre>// Table.js

// Create a state
const [filterInput, setFilterInput] = useState("");

// Update the state when input changes
const handleFilterChange = e =&gt; {
  const value = e.target.value || undefined;
  setFilterInput(value);
};

// Input element
&lt;input
  value={filterInput}
  onChange={handleFilterChange}
  placeholder={"Search name"}
/&gt;
</pre>
<p>这是管理输入状态的一种简单明了的方式。但是，我们如何将这个过滤值传递给我们的表并过滤表中的行呢？</p>
<p>为此，React Table提供了一个名为<code>useFilters</code>的钩子插件:</p>
<pre>// Table.js

const {
  getTableProps,
  getTableBodyProps,
  headerGroups,
  rows,
  prepareRow,
  setFilter, // The useFilter Hook provides a way to set the filter
} = useTable(
  {
    columns,
    data,
  },
  useFilters // Adding the useFilters Hook to the table
  // You can add as many Hooks as you want. Check the documentation for details. You can even add custom Hooks for react-table here
);
</pre>
<p>在我们的例子中，我们将只为<code>Name</code>列设置过滤器。为了过滤名称，当输入值改变时，我们需要将第一个参数设置为列访问器或ID值，将第二个参数设置为搜索过滤器值。</p>
<p>让我们更新我们的<code>handleFilterChange</code>函数:</p>
<pre>const handleFilterChange = e =&gt; {
  const value = e.target.value || undefined;
  setFilter("show.name", value); // Update the show.name filter. Now our table will filter and show only the rows which have a matching value
  setFilterInput(value);
};
</pre>
<p>搜索实现后，我们的UI将如下所示:</p>
<p><img data-attachment-id="154515" data-permalink="https://blog.logrocket.com/react-table-ui-search-functionality/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2023/01/react-table-ui-search-functionality.png" data-orig-size="730,151" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="react-table-ui-search-functionality" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2023/01/react-table-ui-search-functionality-300x62.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2023/01/react-table-ui-search-functionality.png" decoding="async" class="aligncenter wp-image-154515 size-full jetpack-lazy-image" src="../Images/99f64c78abbe186d51961020a51e8438.png" alt="React Table UI Search Functionality" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2023/01/react-table-ui-search-functionality.png 730w, https://blog.logrocket.com/wp-content/uploads/2023/01/react-table-ui-search-functionality-300x62.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2023/01/react-table-ui-search-functionality.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2023/01/react-table-ui-search-functionality.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="154515" data-permalink="https://blog.logrocket.com/react-table-ui-search-functionality/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2023/01/react-table-ui-search-functionality.png" data-orig-size="730,151" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="react-table-ui-search-functionality" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2023/01/react-table-ui-search-functionality-300x62.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2023/01/react-table-ui-search-functionality.png" decoding="async" loading="lazy" class="aligncenter wp-image-154515 size-full" src="../Images/99f64c78abbe186d51961020a51e8438.png" alt="React Table UI Search Functionality" srcset="https://blog.logrocket.com/wp-content/uploads/2023/01/react-table-ui-search-functionality.png 730w, https://blog.logrocket.com/wp-content/uploads/2023/01/react-table-ui-search-functionality-300x62.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2023/01/react-table-ui-search-functionality.png"/></noscript>
<p>这是一个非常基本的过滤器示例，React Table API提供了几个选项。请务必查看API文档。</p>
<h2 id="adding-sorting-usesortby">用<code>useSortBy</code>添加排序</h2>
<p>让我们为我们的表实现一个更基本的功能，排序。让我们允许对所有列进行排序；很简单，类似于过滤。</p>
<p>我们需要添加一个名为<code>useSortBy</code>的插件挂钩，并创建样式来显示表格中的排序图标。它将自动处理升序和降序排序:</p>
<pre>// Table.js

const {
    getTableProps,
    getTableBodyProps,
    headerGroups,
    rows,
    prepareRow,
    setFilter
  } = useTable(
    {
      columns,
      data
    },
    useFilters,
    useSortBy // This plugin Hook will help to sort our table columns
  );

// Table header styling and props to allow sorting

&lt;th
  {...column.getHeaderProps(column.getSortByToggleProps())}
  className={
    column.isSorted
      ? column.isSortedDesc
        ? "sort-desc"
        : "sort-asc"
      : ""
  }
&gt;
  {column.render("Header")}
&lt;/th&gt;
</pre>
<p>基于排序，我们添加类名<code>sort-desc</code>或<code>sort-asc</code>。我们还向列标题添加了排序属性:</p>
<pre>{...column.getHeaderProps(column.getSortByToggleProps())}
</pre>
<p>这将自动允许对所有列进行排序。您可以通过使用列上的<code>disableSortBy</code>选项禁用特定列中的排序来控制这一点。在我们的例子中，我们允许对所有列进行排序。请随意使用演示。</p>
<p>在我们的排序实现之后，UI如下所示:</p>
<p><img data-attachment-id="154517" data-permalink="https://blog.logrocket.com/react-table-ui-sorting-functionality/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2023/01/react-table-ui-sorting-functionality.png" data-orig-size="730,229" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="react-table-ui-sorting-functionality" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2023/01/react-table-ui-sorting-functionality-300x94.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2023/01/react-table-ui-sorting-functionality.png" decoding="async" class="aligncenter wp-image-154517 size-full jetpack-lazy-image" src="../Images/574ea21282fa00ba05c0a91889c396f7.png" alt="React Table UI Sorting Functionality" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2023/01/react-table-ui-sorting-functionality.png 730w, https://blog.logrocket.com/wp-content/uploads/2023/01/react-table-ui-sorting-functionality-300x94.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2023/01/react-table-ui-sorting-functionality.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2023/01/react-table-ui-sorting-functionality.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="154517" data-permalink="https://blog.logrocket.com/react-table-ui-sorting-functionality/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2023/01/react-table-ui-sorting-functionality.png" data-orig-size="730,229" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="react-table-ui-sorting-functionality" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2023/01/react-table-ui-sorting-functionality-300x94.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2023/01/react-table-ui-sorting-functionality.png" decoding="async" loading="lazy" class="aligncenter wp-image-154517 size-full" src="../Images/574ea21282fa00ba05c0a91889c396f7.png" alt="React Table UI Sorting Functionality" srcset="https://blog.logrocket.com/wp-content/uploads/2023/01/react-table-ui-sorting-functionality.png 730w, https://blog.logrocket.com/wp-content/uploads/2023/01/react-table-ui-sorting-functionality-300x94.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2023/01/react-table-ui-sorting-functionality.png"/></noscript>
<p>当然，您可以进一步扩展这个演示。如果你需要帮助，请在评论区告诉我。扩展它的一些想法包括:</p>
<ul>
<li>使用全局过滤器过滤多个列(提示:使用<code>setAllFilters</code>而不是<code>setFilter</code></li>
<li>创建分页并调用更多数据为表加载</li>
<li>通过禁用列的<code>sortby</code>,仅允许对特定字段进行排序</li>
<li>不要将硬编码的搜索值传递给TVMAZE API，而是创建一个输入来直接搜索TVMAZE API。例如，删除客户端过滤，并在服务器端添加搜索电视节目的功能</li>
</ul>
<p>为了扩展这个演示，请查看React Table的扩展<a href="https://github.com/tannerlinsley/react-table/blob/master/docs/examples.md">示例页面</a>。它有一个非常好的厨房水槽可以玩，并且它为大多数用例提供了解决方案。</p>
<h2 id="getting-started-tanstack-table">TanStack表入门</h2>
<p>正如本文开头所提到的，TanStack Table是React Table的一个重大进步，允许该库支持更多的JavaScript框架，包括Svelte、Solid和Vue。TanStack table包括对TypeScript的完全重写、对服务器端操作的改进支持，以及一个大大扩展和改进的API，等等。</p>
<p>此外，由于它的设计，TanStack表的实现在许多支持的框架中是一致的，这意味着在React中创建一个表所必需的钩子与在一个苗条的应用程序中创建一个表所用的钩子是相同的。因此，对于已经熟悉React Table的人来说，在其他框架中使用它更容易。</p>
<p>与React Table v7相反，您可以使用下面的代码安装TanStack Table:</p>
<pre>npm install @tanstack/react-table
</pre>
<p>然后，我们可以将它导入我们的应用程序，如下所示:</p>
<pre>import { useReactTable } from '@tanstack/react-table'

function App() {
  const table = useReactTable(options)
   . . .
}
</pre>
<h3 id="migrating-react-table-v7-tanstack-table-v8">从React表v7迁移到TanStack表v8</h3>
<p>列配置是使用TanStack Table和React Table v7之间最显著的区别。在v8中，<code>createColumnHelper</code>钩子添加了一个创建列的新方法。在下面的示例中，我们将使用TanStack Table v8重新创建上一个表示例中的列:</p>
<pre>import { createColumnHelper } from "@tanstack/react-table";

const columnHelper = createColumnHelper();

const columns = [
  columnHelper.group({
    id: "tv-show",
    header: "TV Show",
    columns: [
      columnHelper.accessor("show.name", {
        header: () =&gt; "Name",
      }),
      columnHelper.accessor("show.type", {
        header: () =&gt; "Type",
      }),
    ],
  }),
  columnHelper.group({
    header: "Details",
    columns: [
      columnHelper.accessor("show.language", {
        header: () =&gt; "Language",
      }),
      columnHelper.accessor("show.genres", {
        header: () =&gt; "Genre(s)",
      }),
    ],
    // . . .
  }),
];
</pre>
<p>此外，v8中的表选项与v7中的基本相同，一些较大的差异集中在可选的状态管理和数据管道控制上。您可以在<a href="https://tanstack.com/table/v8/docs/guide/introduction">文档页面</a>上找到关于其他实现的更多信息。</p>
<h2 id="react-table-alternatives">反应表备选方案</h2>
<p>尽管React Table是最流行的React表库，但它并不总是在React 中构建表的最佳解决方案。根据您的特定项目和用例，有许多替代方案可能也适合您的需求。</p>
<p>下面是一些可供选择的React表库，值得一试。</p>
<h3>1.反应数据网格</h3>
<p><a href="https://github.com/adazzle/react-data-grid"> react-data-grid </a>用于创建智能表格。在撰写本文时，它拥有超过5000颗GitHub星，并且维护得很好。</p>
<p>当您的数据表需要以下功能时，请使用react-data-grid:</p>
<ul>
<li>基本功能，如分组列、排序、搜索和过滤</li>
<li>列的内联编辑</li>
<li>列中的下拉列表(如Google Sheets)或列中的任何自定义输入元素</li>
<li>支持扩展列以显示更多数据</li>
<li>对性能进行微调，例如，它支持无限长的表行的虚拟呈现</li>
<li>当没有行时支持空状态</li>
</ul>
<p>react-data-grid几乎涵盖了数据表的所有基本需求。但是，它默认不支持分页，所以如果您的表需要分页，您需要手动实现和处理它。默认情况下，react-data-grid支持更长的表用户界面，并针对性能进行了优化，因此除非UX要求，否则分页可能是不必要的。</p>
<p>react-data-grid也使用Bootstrap进行造型。没有它，您仍然可以使用react-data-grid，但是您必须为表格添加自己的样式。与React Table相比，它不容易定制，React Table允许您创建表结构。在react-data-grid中，库创建了表格UI，所以它不太适合大量使用UI的定制页面。</p>
<p>虽然以上几点并不完全是缺点，但是在开始使用react-data-grid之前，最好了解一下。最后，当您的应用程序需要一个带有漂亮UX的迷你可编辑数据表时，react-data-grid是最好的，类似于Google Sheets或Airtable。</p>
<h3>2.react-数据表</h3>
<p><a href="https://github.com/nadbm/react-datasheet">react-数据表</a>类似react-数据-网格。它有大约5000个GitHub stars，也是一个维护良好的库。</p>
<p>react-数据表主要致力于帮助您创建自己的类似Google Sheets的应用程序。它内置了创建这种UX密集型应用程序的基本功能。同样，它可能不适合创建带有表格的通用页面UI。</p>
<p>然而，与react-data-grid不同，react-datasheet并不是针对大型数据集进行优化的，因此可以将其用于需要类似工作表的功能的小型应用程序。它只有这一个用例，与react-data-grid相比，它的特性非常有限。</p>
<h3>3.反应虚拟化</h3>
<p>顾名思义，当数据集很大时，<a href="https://github.com/bvaughn/react-virtualized"> react-virtualized </a>针对性能进行了大量优化。在撰写本文时，它在GitHub上拥有超过24k颗星星。这个库不完全是一个表库；它做得更多。它专门用于在UI上以不同的格式显示大型数据集，如网格、表格和列表。</p>
<p>当数据集非常大时，呈现性能是表的关键指标；如果是这种情况，请选择react-virtualized。对于正常的用例来说，这个库可能有些多余，而且API可能太高级了。</p>
<p>您应该将react-virtualized用于定制时间线、包含无限长日历的图表以及大型数据集的繁重UI元素。</p>
<h2 id="choosingareacttablelibrary">选择反应表库</h2>
<p>对于具有有限数据、自定义样式和最小交互性(如排序和过滤)的简单页面，请使用React Table。要用有限的数据构建一个迷你的类似Google Sheets的应用程序，可以使用react-data-grid或react-datasheet。对于具有大型数据集的Google Sheets或类似Airtable的应用程序，请使用react-data-grid。</p>
<p>当您处理非常大的数据集，并且需要一个提供表格、网格和更多选项的自定义UI时，请选择react-virtualized。</p>
<h2 id="conclusion">结论</h2>
<p>在我们添加排序之后，这就是最终的<a href="https://logrocket-smart-table.netlify.com/">反应表演示</a>的样子。你可以玩玩这个演示，看看我们的<a href="https://github.com/learnwithparam/logrocket-smart-table"> React表示例</a>的代码库。</p>
<p>在本文中，我们学习了如何使用React构建一个表格UI。为基本用例创建自己的表并不困难，但是要确保尽可能不要重新发明轮子。希望你喜欢学习表格用户界面。请在评论中告诉我你对表格的体验。</p><div class="code-block code-block-17">
<div class="blog-plug inline-plug react-plug" vwo-el-id="26283398190">
<h2 vwo-el-id="41600691720"><a href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener"> LogRocket </a>:全面了解您的生产React应用</h2><p>调试React应用程序可能很困难，尤其是当用户遇到难以重现的问题时。如果您对监视和跟踪Redux状态、自动显示JavaScript错误以及跟踪缓慢的网络请求和组件加载时间感兴趣，</p><a href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" vwo-el-id="19356441070">try LogRocket</a><p>. </p><a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="19356441380">
<img class="first-react-image alignnone size-full wp-image-46 jetpack-lazy-image jetpack-lazy-image--handled" src="../Images/f300c244a1a1cf916df8b4cb02bec6c6.png" vwo-el-id="18272717540" data-lazy-loaded="1" data-original-src="https://files.readme.io/27c94e7-Image_2017-06-05_at_9.46.04_PM.png"/>
</a>
<a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="19356441690">
<img class="second-react-image alignnone size-full wp-image-46 jetpack-lazy-image jetpack-lazy-image--handled" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" vwo-el-id="30720362350" data-lazy-loaded="1" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/>
</a>
<p vwo-el-id="28675660440" class="">LogRocket 结合了会话回放、产品分析和错误跟踪，使软件团队能够创建理想的web和移动产品体验。这对你来说意味着什么？</p>
<p>LogRocket不是猜测错误发生的原因，也不是要求用户提供截图和日志转储，而是让您回放问题，就像它们发生在您自己的浏览器中一样，以快速了解哪里出错了。</p>
<p>不再有嘈杂的警报。智能错误跟踪允许您对问题进行分类，然后从中学习。获得有影响的用户问题的通知，而不是误报。警报越少，有用的信号越多。</p>
<p vwo-el-id="28675660750">LogRocket Redux中间件包为您的用户会话增加了一层额外的可见性。LogRocket记录Redux存储中的所有操作和状态。</p>
<p vwo-el-id="28675661060">现代化您调试React应用的方式— <a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="40093418840">开始免费监控</a>。</p>
</div></div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
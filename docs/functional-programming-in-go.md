# Go 中的函数式编程

> 原文：<https://blog.logrocket.com/functional-programming-in-go/>

你为什么要用 Go 练习函数式编程？简而言之，由于没有状态和可变数据，函数式编程使您的代码可读性更好，更容易测试，也更简单。如果遇到 bug，可以快速调试你的 app，只要不违反函数式编程的规则。当函数被隔离时，您不必处理影响输出的隐藏状态更改。

软件工程师兼作者 [Eric Elliot](https://medium.com/javascript-scene/master-the-javascript-interview-what-is-functional-programming-7f218c68b3a0) 将函数编程定义如下。

> 函数式编程是通过组合纯函数、避免共享状态、可变数据和副作用来构建软件的过程。函数式编程是声明性的而不是命令性的，应用程序状态流过纯函数。与面向对象的编程相反，在面向对象的编程中，应用程序状态通常是共享的，并与对象中的方法放在一起。

我将更进一步:函数式编程，像[面向对象](http://freecodecamp.org/news/object-oriented-programming-concepts-21bb035f7260/)和[过程式编程](https://en.wikipedia.org/wiki/Procedural_programming)，代表了一种范式的转变。在编写代码时，它强加了一种独特的思维方式，并引入了一套全新的规则来遵循。

## 需要理解的 4 个重要概念

要全面掌握函数式编程，首先要了解以下相关概念。

1.  纯函数和幂等性
2.  副作用
3.  功能组成
4.  共享状态和不可变数据

让我们快速回顾一下。

### 1.纯函数和幂等性

一个纯函数总是返回相同的输出，如果你给它相同的输入。该属性也被称为等幂。幂等性意味着函数应该总是返回相同的输出，与调用次数无关。

### 2.副作用

一个纯函数不可能有任何副作用。换句话说，你的功能不能与外部环境互动。

例如，函数式编程认为 API 调用是一种副作用。为什么？因为 API 调用被认为是不受您直接控制的外部环境。一个 API 可能有一些不一致，比如超时或失败，或者它甚至可能返回一个意外的值。它不符合纯函数的定义，因为我们每次调用 API 时都需要一致的结果。

其他常见的副作用包括:

*   数据突变
*   DOM 操作
*   请求冲突的数据，例如当前的`DateTime`与`time.Now()`

### 3.功能组成

函数组合的基本思想很简单:将两个纯函数组合起来创建一个新函数。这意味着同样的输入产生同样的输出的概念在这里仍然适用。因此，从简单、纯粹的功能开始创建更高级的功能非常重要。

### 4.共享状态和不可变数据

函数式编程的目标是创建不保存状态的函数。尤其是共享状态，会在纯函数中引入副作用或可变性问题，使它们变得不纯。

然而，并不是所有的州都不好。有时候，状态对于解决某个软件问题是必要的。函数式编程的目标是使状态可见和明确，以消除任何副作用。程序使用不可变的数据结构从纯函数中获得新数据。这样，就不需要可能导致副作用的可变数据。

既然我们已经讨论了基础，让我们定义一些在 Go 中编写函数代码时要遵循的规则。

## 函数式编程的规则

正如我提到的，函数式编程是一种范式。因此，很难为这种编程风格定义精确的规则。也不总是能完全遵循这些规则；有时候，你真的需要依赖一个保存状态的函数。

然而，为了尽可能地遵循函数式编程范式，我建议遵循以下准则。

*   没有可变数据，以避免副作用
*   无状态(或隐式状态，如循环计数器)
*   一旦变量被赋值，就不要修改它们
*   避免副作用，例如 API 调用

我们在函数式编程中经常遇到的一个好的“副作用”是强大的模块化。函数式编程鼓励自下而上的编程风格，而不是自上而下地处理软件工程。从定义模块开始，这些模块将您期望在未来需要的相似的纯函数组合在一起。接下来，开始编写那些小的、无状态的、独立的函数来创建你的第一个模块。

我们本质上是在创造黑盒。稍后，我们将按照自底向上的方法把这些盒子绑在一起。这使您能够构建一个强大的测试基础，尤其是验证纯函数正确性的单元测试。

一旦你对你坚实的模块基础有了信心，就该把模块绑在一起了。开发过程中的这一步还包括编写集成测试，以确保两个组件的正确集成。

## Go 中的 5 个函数式编程示例

为了更全面地描述 Go 函数式编程的工作原理，让我们来探索五个基本的例子。

### 1.更新字符串

这是纯函数最简单的例子。通常，当您想要更新一个字符串时，您应该执行以下操作。

```
<code>
name := "first name"
name := name + " last name"
</code>

```

上面的代码片段不符合函数式编程的规则，因为变量不能在函数中修改。因此，我们应该重写代码片段，使每个值都有自己的变量。

下面的代码片段可读性更好。

* * *

### 更多来自 LogRocket 的精彩文章:

* * *

```
<code>
    firstname := "first"
    lastname := "last"
    fullname := firstname + " " + lastname
</code>

```

当查看不起作用的代码片段时，我们必须浏览程序以确定`name`的最新状态，从而找到`name`变量的结果值。这需要更多的努力和时间来理解这个函数在做什么。

### 2.避免更新数组

如前所述，函数式编程的目标是使用不可变数据通过纯函数派生出新的不可变数据状态。这也适用于这样的数组，即每次我们想要更新一个数组时，都要创建一个新的数组。

在非函数式编程中，按如下方式更新数组:

```
<code>
names := [3]string{"Tom", "Ben"}

    // Add Lucas to the array
    names[2] = "Lucas"
</code>

```

让我们根据函数式编程范例来尝试一下。

```
<code>
    names := []string{"Tom", "Ben"}
    allNames := append(names, "Lucas")
</code>

```

该示例使用原始的`names`切片和`append()`函数向新数组添加额外的值。

### 3.避免更新地图

这是函数式编程的一个更极端的例子。假设我们有一个映射，它有一个字符串类型的键和一个整数类型的值。这张地图上有我们留在家里的水果数量。但是，我们刚买了苹果，想把它加到清单里。

```
<code>
fruits := map[string]int{"bananas": 11}

    // Buy five apples
    fruits["apples"] = 5
<code>

```

我们可以在函数式编程范式下实现相同的功能。

```
<code>
    fruits := map[string]int{"bananas": 11}
    newFruits := map[string]int{"apples": 5}

    allFruits := make(map[string]int, len(fruits) + len(newFruits))

    for k, v := range fruits {
        allFruits[k] = v
    }

    for k, v := range newFruits {
        allFruits[k] = v
    }
</code>

```

因为我们不想修改原始的映射，所以代码循环遍历两个映射并将值添加到一个新的映射中。这样，数据保持不变。

但是，从代码的长度可以看出，这段代码的性能比简单的可变地图更新要差得多，因为我们遍历了两个地图。这正是你用更好的代码质量换取代码性能的时候。

### 4.高阶函数和 currying

大多数程序员不经常在他们的代码中使用高阶函数，但是在函数式编程中建立 currying 是很方便的。

假设我们有一个简单的函数，将两个整数相加。尽管这已经是一个纯粹的函数，我们还是想通过这个例子来展示如何通过 curry 创建更高级的功能。

在这种情况下，我们只能接受一个参数。接下来，该函数返回另一个函数作为闭包。因为该函数返回一个闭包，所以它将记住包含初始输入参数的外部范围。

```
<code>
func add(x int) func(y int) int {
    return func(y int) int {
        return x + y
    }
}
</code>

```

现在让我们尝试 currying 并创建更高级的纯函数。

```
<code>
func main() {
    // Create more variations
    add10 := add(10)
    add20 := add(20)

    // Currying
    fmt.Println(add10(1)) // 11
    fmt.Println(add20(1)) // 21
}
</code>

```

这种方法在函数式编程中很常见，尽管在范式之外并不常见。

### 5.递归

递归是一种软件模式，通常用于规避循环的使用。因为循环总是持有一个内部状态来知道它们处于哪一轮，所以我们不能在函数式编程范式下使用它们。

例如，下面的代码片段试图计算一个数字的阶乘。阶乘是一个整数和它下面所有整数的乘积。所以，4 的阶乘等于 24 (= 4 * 3 * 2 * 1)。

通常，您会为此使用一个循环。

```
<code>
func factorial(fac int) int {
    result := 1
    for ; fac > 0; fac-- {
        result *= fac
    }
    return result
}
</code>

```

为了在函数式编程范例中实现这一点，我们需要使用递归。换句话说，我们将反复调用同一个函数，直到达到阶乘的最小整数。

```
<code>
func calculateFactorial(fac int) int {
    if fac == 0 {
        return 1
    }
    return fac * calculateFactorial(fac - 1)
}
</code>

```

## 结论

让我们总结一下我们对函数式编程的了解:

*   尽管 Golang 支持函数式编程，但它并不是为此目的而设计的，缺少 Map、Filter 和 Reduce 等函数就是证明
*   函数式编程提高了代码的可读性，因为函数是纯函数，因此容易理解
*   纯函数更容易测试，因为没有内部状态可以改变输出

要了解更多关于纯函数的用例及其重要性，请查看这篇关于 Redux reducers 需要纯函数的文章。

为了更好地了解函数式编程、过程式编程和面向对象编程之间的区别，或者如果您想了解哪种范式最适合您，我推荐您阅读 Lili Ouaknin Felsen 的这篇[见解深刻的文章](https://medium.com/@LiliOuakninFelsen/functional-vs-object-oriented-vs-procedural-programming-a3d4585557f3)。

## 使用 [LogRocket](https://lp.logrocket.com/blg/signup) 消除传统错误报告的干扰

[![LogRocket Dashboard Free Trial Banner](img/d6f5a5dd739296c1dd7aab3d5e77eeb9.png)](https://lp.logrocket.com/blg/signup)

[LogRocket](https://lp.logrocket.com/blg/signup) 是一个数字体验分析解决方案，它可以保护您免受数百个假阳性错误警报的影响，只针对几个真正重要的项目。LogRocket 会告诉您应用程序中实际影响用户的最具影响力的 bug 和 UX 问题。

然后，使用具有深层技术遥测的会话重放来确切地查看用户看到了什么以及是什么导致了问题，就像你在他们身后看一样。

LogRocket 自动聚合客户端错误、JS 异常、前端性能指标和用户交互。然后 LogRocket 使用机器学习来告诉你哪些问题正在影响大多数用户，并提供你需要修复它的上下文。

关注重要的 bug—[今天就试试 LogRocket】。](https://lp.logrocket.com/blg/signup-issue-free)
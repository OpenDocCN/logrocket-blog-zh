<html>
<head>
<title>How to bootstrap your project with JSON Server - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>如何用JSON服务器引导你的项目</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/how-to-bootstrap-your-project-with-json-server/#0001-01-01">https://blog.logrocket.com/how-to-bootstrap-your-project-with-json-server/#0001-01-01</a></blockquote><div><article class="article-post">
<p>JSON Server使前端开发人员能够快速构建一个假的REST API来验证应用程序的接口在从后端接收数据时的反应。当所需的后端路由尚未完成时，这尤其有用。</p>
<p>从高层次上来说，这并不复杂:您所需要做的就是创建一个定义端点和样本数据的JSON文件——不需要进一步的配置。事实上，你可以在五分钟内引导一个假的REST API 。</p>
<p>在本教程中，我们将演示:</p>
<ul>
<li>如何用JSON服务器引导一个简单的REST API</li>
<li>如何发送<code>GET</code>、<code>POST</code>和<code>PUT</code>请求</li>
<li>如何发送带有过滤和排序参数的高级请求</li>
<li>如何定义数据段之间的关系</li>
</ul>
<p>让我们开始吧！</p>
<h2>安装JSON服务器</h2>
<p>在发送任何请求之前，我们需要安装JSON服务器。我们最好使用npm来全局安装<code>json-server</code>包。</p>
<pre>npm install -g json-server
</pre>
<p>既然JSON服务器已经全局安装，我们可以创建我们的第一个服务器配置。</p>
<h2>了解JSON服务器配置</h2>
<p>下一步是创建我们的第一个<code>db.json</code>文件，它保存了伪REST API的JSON配置。下面是一个示例配置，它包括三个端点:authors、books和library。</p>
<pre>{
 "authors": [
   { "id": 1, "name": "Michiel Mulders", "genre": "fiction" }
 ],
 "books": [
   { "id": 1, "title": "some title", "authorId": 1 }
 ],
 "library": { "name": "City library" }
}
</pre>
<h3>多个端点</h3>
<p>请注意我们是如何定义端点的:每个具有复数名称的端点都包含一个对象数组，每个对象代表该端点的一个数据库记录。例如，<code>authors</code>端点将返回一个作者对象，其名称与米歇尔·穆尔德斯相同。</p>
<p>对于多个端点，JSON Server生成以下路由:</p>
<ul>
<li><code>GET /authors</code>返回所有作者</li>
<li><code>GET /authors/1</code>返回ID为1的作者</li>
<li><code>POST /authors</code>在数据库中创建新作者</li>
<li><code>PUT /authors/1</code>更新ID为1的整个作者对象</li>
<li><code>PATCH /authors/1</code>更新ID为1的作者对象的特定字段</li>
<li><code>DELETE /authors/1</code>删除特定的作者对象</li>
</ul>
<h3>奇异端点</h3>
<p>JSON配置显示了一个单独的端点库。当您以单数形式定义端点时，它只能返回一个对象。不可能定义一个数组。</p>
<p>对于为单个端点生成的路径，<code>GET/POST/PUT/PATCH /library</code>是对该对象可用的基本操作集，但不能删除该对象。</p>
<p>现在我们理解了JSON服务器生成的可能的路由。让我们开始我们的第一个服务器！</p>
<h2>启动您的第一个JSON服务器</h2>
<p>为了启动服务器并为上述端点提供服务，我们将在命令行中使用<code>json-server</code>命令。我们将告诉<code>json-server</code>命令查看我们的<code>db.json</code>配置文件。</p>
<pre>json-server --watch db.json
</pre>
<p>您可以通过向<code><a href="http://localhost:3000/authors/1" rel="nofollow">http://localhost:3000/authors/1</a></code>发送一个<code>GET</code>请求来验证您的服务器正在运行。如果它返回一个结果，您就可以探索其他端点了。</p>
<h3>如何发送<code>POST</code>请求</h3>
<p>我们可以通过<a href="https://www.getpostman.com/" target="_blank" rel="noopener noreferrer">邮递员</a>或<a href="https://gist.github.com/subfuzion/08c5d85437d5d4f00e58" target="_blank" rel="noopener noreferrer"> curl </a>发送一个<code>POST</code>请求。不要忘记为请求传递正确的头。因为我们处理的是JSON API，所以我们需要发送<code>Content-Type: application/json</code>头。</p>
<p>一个<code>POST</code>请求可以简单地通过请求体发送。下面的主体将在我们的数据库中创建一个新的author对象。不要忘记将请求发送到正确的URL: <code><a href="http://localhost:3000/authors" rel="nofollow">http://localhost:3000/authors</a></code>。</p>
<pre>{
    "name": "Gregory Salis",
    "genre": "nonfiction"
}
</pre>
<p>如您所见，请求体不需要传递ID。JSON服务器将自动为您的author对象创建一个新的ID。</p>
<h3>如何发送<code>PUT</code>请求</h3>
<p>发送一个<code>PUT</code>请求与发送一个<code>POST</code>请求非常相似。首先，我们必须指定需要更新的对象的ID。让我们使用URL <code><a href="http://localhost:3000/authors/1" rel="nofollow">http://localhost:3000/authors/1</a></code>更新ID为1的原始作者对象。</p>
<p>这个<code>PUT</code>请求必须将体裁从小说修改为非小说。因此，请求正文将如下所示:</p>
<pre>{
    "name": "Michiel Mulders",
    "genre": "nonfiction"
}
</pre>
<p>除了发送简单的<code>GET</code>、<code>POST</code>和<code>PUT</code>请求，JSON Server还允许更高级的请求，比如过滤、排序和搜索。</p>
<h2>高级JSON服务器请求</h2>
<p>为了丰富其功能，JSON Server提供了搜索、排序和过滤选项。</p>
<h3>整理</h3>
<p>可以通过<code>_sort</code>选项对数据进行排序。假设我们想按流派对作者进行排序。排序请求将如下所示:</p>
<pre>http://localhost:3000/authors?_sort=genre
</pre>
<p>但是，排序结果的顺序需要从<code>asc</code>切换到<code>desc</code>。<code>_order</code>选项允许我们将排序从升序改为降序。</p>
<pre>http://localhost:3000/authors?_sort=genre&amp;_order=desc
</pre>
<h3>过滤</h3>
<p>我们可以通过定义要过滤的字段和所需值来实现数据过滤。下面的示例链接将检索所有非小说作者。该请求定义了类型字段和所需的值<code>nonfiction</code>。</p>
<pre>http://localhost:3000/authors?genre=nonfiction
</pre>
<p>另外，JSON Server允许我们组合过滤器。现在，该请求应该检索作者米歇尔·穆尔德斯的所有非小说类书籍。下面的请求定义了两个由&amp;字符连接的字段。</p>
<pre>http://localhost:3000/authors?genre=nonfiction&amp;name=Michiel%20Mulders
</pre>
<p>注:米歇尔和穆尔德斯之间的空间由<code>%20</code>编码。这是编码URL的常见做法。最后，<code>json-server</code>提供了几种搜索的可能性。</p>
<h3>搜索</h3>
<p>最后但同样重要的是，搜索可以以多种方式执行。全文搜索选项有助于查找特定值。在查找值时，这种方法是最简单的。在这里，请求应该找到名称中包含“Michiel”的所有作者。</p>
<pre>http://localhost:3000/authors?q=michiel
</pre>
<p>此外，JSON Server有助于查找特定字段的值。例如，该请求应该返回所有在“类型”字段中包含“Michiel”的匹配记录。当调查<code>db.json</code>文件时，这个请求应该返回一个空响应，因为“Michiel”没有出现在流派字段中。</p>
<p>我们可以通过将<code>_like</code>操作符附加到我们想要搜索的字段来进行过滤。现在，请求包含了一个<code>genre_like</code>选项。</p><div class="code-block code-block-54">
<hr/>
<h3>更多来自LogRocket的精彩文章:</h3>

<hr/></div>
<pre>http://localhost:3000/authors?genre_like=michiel
</pre>
<p>另外，<code>_like</code>操作符支持<a href="https://www.regular-expressions.info/" target="_blank" rel="noopener noreferrer">正则表达式</a>查询。下面的查询应该检索所有以关键字<code>non</code>开头的流派。注意附加在<code>genre_like</code>选项后面的星号——那是正则表达式的一部分。</p>
<pre>http://localhost:3000/authors?genre_like=non*
</pre>
<p>更多操作符，如<code>_gte</code>、<code>_lte</code>、<code>_ne</code>，可以在<a href="https://github.com/typicode/json-server#operators" target="_blank" rel="noopener noreferrer"> JSON服务器文档</a>中找到。</p>
<h2>了解与JSON服务器的关系</h2>
<p>一个不具备定义端点间关系能力的伪JSON服务器是没有用的。大多数数据需要定义数据关系的能力。让我们讨论一下<code>json-server</code>是如何定义数据点之间的关系的。</p>
<p>首先，记住我们开始时的<code>db.json</code>配置:</p>
<pre>{
 "authors": [
   { "id": 1, "name": "Michiel Mulders", "genre": "fiction" }
 ],
 "books": [
   { "id": 1, "title": "some title", "authorId": 1 }
 ],
 "library": { "name": "City library" }
}
</pre>
<p>现在请注意<code>books</code>端点的<code>authorId</code>字段。通过使用数据库中另一个数据实体的单数形式，我们可以通过添加<code>id</code>关键字来链接它。在这里，我们将标题为“某个标题”的书链接到ID为1的作者。</p>
<p>此外，这允许我们查询ID等于1的作者米歇尔·穆尔德斯写的所有书籍。该查询需要添加关键字<code>books</code>来指定检索该作者的所有书籍。</p>
<pre>http://localhost:3000/authors/1/books
</pre>
<p>同样，我们进一步过滤这些端点，例如下面的请求。</p>
<pre>http://localhost:3000/authors/1/books?title_like=some
</pre>
<p>但是如果我们想要包含父资源(作者)呢？</p>
<h3>包括父资源</h3>
<p>此外，<code>json-server</code>允许我们通过<em> <code>_embed</code> </em>选项来包含父资源。这个请求现在看起来略有不同，因为我们从<code>authors</code>端点开始，要求嵌入ID等于1的作者的所有书籍。</p>
<pre>http://localhost:3000/authors/1?_embed=books
</pre>
<p>当发送上面的<code>GET</code>请求时，结果如下:</p>
<pre>{

    id: 1,
    name: "Michiel Mulders",
    genre: "fiction",
    books:
    [
                  {
                           id: 1,
                       title: "some title",
                       authorId: 1
                   }
    ]
}</pre>
<h2>使用JSON服务器的4个有用技巧</h2>
<p>为了结束我们的教程，我们将回顾一些常见的最佳实践，以帮助您最大限度地利用<code>json-server</code>。</p>
<p>除了生成路线之外，<code>json-server</code>还提供了许多对你有用的有趣功能。让我们探索四个最有趣的特性。</p>
<h3>1.数据库快照</h3>
<p>假设您已经更新并创建了许多新对象，并且您不想丢失您的进度。您可以点击键盘上的<code>s + enter</code>来获取当前数据库状态的快照。</p>
<p>快照保存在同一个文件夹中，名称后面会附加一个unix时间戳，结果如下:<code>db-1578083664783.json</code>。</p>
<h3>2.添加自定义路线</h3>
<p>“定制路线”这个名称实际上很容易让人误解。<code>json-server</code>允许您为现有路线创建别名。</p>
<p>假设您的前端依赖于一个从以<code>/api/v1</code>开始的根路径提供的API。由于<code>json-server</code>不包括这个前缀，我们必须创建一个自定义路由。我们将创建一个<code>routes.json</code>文件来告诉<code>json-server</code>要建立哪些映射。下面的例子将所有的<code>json-server</code>路由映射到所需的前缀<code>/api/v1</code>。</p>
<pre>{
  "/api/*": "/$1"
}
</pre>
<p>接下来，我们还可以为长URL创建更短的路径。</p>
<pre>{
  "/api/*": "/$1",
  "/:resource/:id/show": "/:resource/:id"
}
</pre>
<p>要告诉<code>json-server</code>使用这些别名，请将<code>--routes </code>选项传递给start命令。</p>
<pre>json-server --watch db.json --routes routes.json
</pre>
<h3>3.更改端口</h3>
<p>默认情况下，<code>json-server</code>在端口3000上提供其API。我们可以用<code>--port</code>选项改变端口。</p>
<pre>json-server --watch db.json --port 5000
</pre>
<h3>4.定制中间件</h3>
<p>最后，<code>json-server</code>允许您定义定制的中间件。例如，让我们创建一个<code>headers.js</code>文件，其中包含一小段代码，用于向请求添加额外的自定义头。</p>
<p><code>json-server</code>遵循Express.js用于请求的相同模式:<code>req</code>、<code>res</code>和<code>next</code>。因此，您可以修改请求的数据，或者给<code>res</code>对象添加一个额外的头，如下所示:</p>
<pre>module.exports = (req, res, next) =&gt; {
  res.header('X-Hello', 'World')
  next()
}
</pre>
<p>要使用上述中间件服务于<code>json-server</code>，请传递<code>--middlewares</code>选项。</p>
<pre>json-server --watch db.json --middlewares headers.js
</pre>
<h2>结论</h2>
<p>在您开始疯狂使用模拟API之前，让我们快速回顾一下我们所学到的内容。</p>
<p>JSON Server注重简单性和使用速度。它允许任何前端开发人员在不到五分钟的时间内构建一个假的REST API。</p>
<p>此外，很容易添加数据之间的关系。只需添加关键字<code>id</code>就可以链接任何数据。<code>json-server</code>允许您像常规API一样过滤、排序和查询数据。</p>
<p>下次验证前端组件时，考虑使用<code>json-server</code>快速引导JSON REST API。当您的项目需要特殊组件时，<code>json-server</code>允许通过中间件进行定制。</p>
<p>要了解JSON Server还能做些什么，请查看官方文档。</p><div class="code-block code-block-2">
<div class="blog-plug base-cta"><h2>使用<a class="signup" href="https://lp.logrocket.com/blg/signup" target="_blank" rel="noopener noreferrer"> LogRocket </a>消除传统错误报告的干扰</h2>
<a href="https://lp.logrocket.com/blg/signup" class="signup" target="_blank" rel="noopener noreferrer"><img class="alignnone size-full wp-image-46 jetpack-lazy-image" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/><noscript><img data-lazy-fallback="1" class="alignnone size-full wp-image-46" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/></noscript></a>
<p><a href="https://lp.logrocket.com/blg/signup" target="_blank" rel="noopener noreferrer"> LogRocket </a>是一个数字体验分析解决方案，它可以保护您免受数百个假阳性错误警报的影响，只针对几个真正重要的项目。LogRocket会告诉您应用程序中实际影响用户的最具影响力的bug和UX问题。</p>
<p>然后，使用具有深层技术遥测的会话重放来确切地查看用户看到了什么以及是什么导致了问题，就像你在他们身后看一样。</p>
<p>LogRocket自动聚合客户端错误、JS异常、前端性能指标和用户交互。然后LogRocket使用机器学习来告诉你哪些问题正在影响大多数用户，并提供你需要修复它的上下文。</p>
<p>关注重要的bug—<a class="signup" href="https://lp.logrocket.com/blg/signup-issue-free" target="_blank" rel="noopener noreferrer">今天就试试LogRocket】。</a></p></div></div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
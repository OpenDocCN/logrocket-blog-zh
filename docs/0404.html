<html>
<head>
<title>You’re overusing useMemo: Rethinking Hooks memoization - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>你过度使用了使用备忘录:重新思考钩子的记忆化</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/rethinking-hooks-memoization/#0001-01-01">https://blog.logrocket.com/rethinking-hooks-memoization/#0001-01-01</a></blockquote><div><article class="article-post">
<p>根据我的经验，我发现<code>useMemo</code>主要有两类是不相关的、被过度使用的，并且可能对你的应用程序的性能有害。</p>
<p>第一类很容易推理；但是，第二类相当微妙，容易被忽略。如果你在任何严肃的生产应用中使用过钩子，那么你很可能会在这两个类别中的一个中使用<code>useMemo</code> <a href="https://blog.logrocket.com/popular-react-hook-libraries/" target="_blank" rel="noopener noreferrer">钩子</a>。</p>
<p>我将向您展示为什么这些不重要并且可能损害您的应用程序的性能，更有趣的是，我将向您展示我对如何在这些用例中<em>而不是</em>过度使用<code>useMemo</code>的建议。</p>
<p>我们可以开始了吗？</p>
<h2>不使用<code>useMemo</code>的地方</h2>
<p>出于学习的目的，这些分类将被称为狮子和变色龙。</p>
<p><img data-attachment-id="4628" data-permalink="https://blog.logrocket.com/rethinking-hooks-memoization/lions-and-chameleons/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2019/08/lions-and-chameleons.png" data-orig-size="730,241" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Category A and category B: lions and chameleons" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2019/08/lions-and-chameleons-300x99.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2019/08/lions-and-chameleons.png" decoding="async" class="size-full wp-image-4628 aligncenter jetpack-lazy-image" src="../Images/8142eb9585e35988997844094fbe6b83.png" alt="Category A And Category B: Lions And Chameleons" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2019/08/lions-and-chameleons.png 730w, https://blog.logrocket.com/wp-content/uploads/2019/08/lions-and-chameleons-300x99.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2019/08/lions-and-chameleons.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/08/lions-and-chameleons.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="4628" data-permalink="https://blog.logrocket.com/rethinking-hooks-memoization/lions-and-chameleons/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2019/08/lions-and-chameleons.png" data-orig-size="730,241" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Category A and category B: lions and chameleons" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2019/08/lions-and-chameleons-300x99.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2019/08/lions-and-chameleons.png" decoding="async" loading="lazy" class="size-full wp-image-4628 aligncenter" src="../Images/8142eb9585e35988997844094fbe6b83.png" alt="Category A And Category B: Lions And Chameleons" srcset="https://blog.logrocket.com/wp-content/uploads/2019/08/lions-and-chameleons.png 730w, https://blog.logrocket.com/wp-content/uploads/2019/08/lions-and-chameleons-300x99.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/08/lions-and-chameleons.png"/></noscript>
<p>忽略那些分散注意力的分类名称，坚持住！</p>
<p>当面对狮子时，你的第一反应是逃跑，保护你的心脏不被撕裂，并活下来以后再讲述这个故事。没时间闲聊了。</p>
<p>这是a类，他们是狮子，你的反应应该是逃离这些。</p>
<p>让我们先从这些开始，然后再看更微妙的变色龙。</p>
<h3>1.相同的参考和廉价的操作</h3>
<p>考虑下面的示例组件:</p>
<pre>/** 
  @param {number} page 
  @param {string} type 
**/
const myComponent({page, type}) { 
  const resolvedValue = useMemo(() =&gt; {
     getResolvedValue(page, type)
  }, [page, type])

  return &lt;ExpensiveComponent resolvedValue={resolvedValue}/&gt; 
}</pre>
<p>在这个例子中，很容易证明作者使用了<code>useMemo</code>。他们的想法是，当对<code>resolvedValue</code>的引用改变时，他们不希望<code>ExpensiveComponent</code>被重新呈现。</p>
<p>虽然这是一个合理的担忧，但在任何给定的时间，有两个问题可以用来证明使用<code>useMemo</code>的合理性。</p>
<p>第一，传入<code>useMemo</code>的函数是不是很贵？在这种情况下，<code>getResolvedValue</code>计算是不是很昂贵？</p>
<p>JavaScript数据类型上的大多数方法都经过了优化，比如<code>Array.map</code>、<code>Object.getOwnPropertyNames()</code>等。如果你正在执行一个不昂贵的操作(想想大O符号)，那么你不需要记忆返回值。使用<code>useMemo</code>T3的成本可能会超过重新评估函数的成本。</p>
<p>第二，给定相同的输入值，对记忆值的引用会改变吗？例如，在上面的代码块中，给定<code>page</code>为<code>2</code>，给定<code>type</code>为<code>"GET"</code>，那么对<code>resolvedValue</code>的引用会发生变化吗？</p>
<p>简单的答案是考虑<code>resolvedValue</code>变量的数据类型。如果<code>resolvedValue</code>是一个<code>primitive</code>(即<code>string</code>、<code>number</code>、<code>boolean</code>、<code>null</code>、<code>undefined</code>或<code>symbol</code>)，那么参考永远不会改变。言下之意，<code>ExpensiveComponent</code>不会被重新渲染。</p>
<p>考虑下面的修订代码:</p>
<pre>/** 
  @param {number} page 
  @param {string} type 
**/
const MyComponent({page, type}) {
  const resolvedValue = getResolvedValue(page, type)
  return &lt;ExpensiveComponent resolvedValue={resolvedValue}/&gt; 
}</pre>
<p>按照上面的解释，如果<code>resolvedValue</code>返回一个字符串或其他原始值，并且<code>getResolvedValue</code>不是一个昂贵的操作，那么这是完全正确和高性能的代码。</p>
<p>只要<code>page</code>和<code>type</code>相同——即没有属性变化——<code>resolvedValue</code>将持有相同的引用，除非返回值不是原语(例如，对象或数组)。</p>
<p>记住这两个问题:被记忆的函数是一个昂贵的函数吗？返回值是一个原语吗？有了这些问题，你随时可以评估自己对<code>useMemo</code>的使用。</p>
<h3>2.出于多种原因记忆默认状态</h3>
<p>考虑下面的代码块:</p>
<pre>/** 
  @param {number} page 
  @param {string} type 
**/
const myComponent({page, type}) { 
  const defaultState = useMemo(() =&gt; ({
    fetched: someOperationValue(),
    type: type
  }), [type])

  const [state, setState] = useState(defaultState);
  return &lt;ExpensiveComponent /&gt; 
}</pre>
<p>上面的代码对一些人来说似乎无害，但是那里的<code>useMemo</code>调用绝对不重要。</p>
<p>第一，出于同理心，理解这段代码背后的思维。作者的意图值得称赞。当<code>type</code>道具改变时，他们想要一个新的<code>defaultState</code>对象，并且他们不希望对<code>defaultState</code>对象的引用在每次重新渲染时无效。</p><div class="code-block code-block-54">
<hr/>
<h3>更多来自LogRocket的精彩文章:</h3>

<hr/></div>
<p>虽然这些都是合理的考虑，但是这种方法是错误的，并且违反了一个基本原则:<code>useState</code>不会在每次重新渲染时被重新初始化，只有当组件被重新装载时。</p>
<p>传递给<code>useState</code>的参数最好叫做<code>INITIAL_STATE</code>。它只在组件最初安装时计算(或触发)一次。</p>
<pre>useState(INITIAL_STATE)</pre>
<p>尽管作者担心当<code>useMemo</code>的<code>type</code>数组依赖关系改变时会得到一个新的<code>defaultState</code>值，但这是一个错误的判断，因为<code>useState</code>忽略了新计算的<code>defaultState</code>对象。</p>
<p>如下所示，这与延迟初始化<code>useState</code>相同:</p>
<pre>/**
   @param {number} page 
   @param {string} type 
**/
const myComponent({page, type}) {
  // default state initializer 
  const defaultState = () =&gt; {
    console.log("default state computed")
    return {
       fetched: someOperationValue(),
       type: type
    }
  }

  const [state, setState] = useState(defaultState);
  return &lt;ExpensiveComponent /&gt; 
}</pre>
<p>在上面的例子中，<code>defaultState</code> init函数只被调用一次——在挂载时。并非每次重新渲染时都会调用该函数。因此，除非组件被重新装载，否则日志“默认状态已计算”将只出现一次。</p>
<p>下面是之前重写的代码:</p>
<pre>/**
   @param {number} page 
   @param {string} type 
**/
const myComponent({page, type}) {
  const defaultState = () =&gt; ({
     fetched: someOperationValue(),
     type,
   })

  const [state, setState] = useState(defaultState);

  // if you really need to update state based on prop change, 
  // do so here
  // pseudo code - if(previousProp !== prop){setState(newStateValue)}

  return &lt;ExpensiveComponent /&gt; 
}</pre>
<p>我们现在将考虑我认为你应该避免的更微妙的场景。</p>
<h3>3.使用<code>useMemo</code>作为ESLint吊钩警告的出口</h3>
<p><img data-attachment-id="4629" data-permalink="https://blog.logrocket.com/rethinking-hooks-memoization/eslint-hook-warnings/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2019/08/eslint-hook-warnings.png" data-orig-size="730,134" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="ESLint Hook warnings" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2019/08/eslint-hook-warnings-300x55.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2019/08/eslint-hook-warnings.png" decoding="async" class="alignnone size-full wp-image-4629 jetpack-lazy-image" src="../Images/1ac2a3c89b8c67b5ecca73bfec115de6.png" alt="ESLint Hook Warnings" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2019/08/eslint-hook-warnings.png 730w, https://blog.logrocket.com/wp-content/uploads/2019/08/eslint-hook-warnings-300x55.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2019/08/eslint-hook-warnings.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/08/eslint-hook-warnings.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="4629" data-permalink="https://blog.logrocket.com/rethinking-hooks-memoization/eslint-hook-warnings/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2019/08/eslint-hook-warnings.png" data-orig-size="730,134" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="ESLint Hook warnings" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2019/08/eslint-hook-warnings-300x55.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2019/08/eslint-hook-warnings.png" decoding="async" loading="lazy" class="alignnone size-full wp-image-4629" src="../Images/1ac2a3c89b8c67b5ecca73bfec115de6.png" alt="ESLint Hook Warnings" srcset="https://blog.logrocket.com/wp-content/uploads/2019/08/eslint-hook-warnings.png 730w, https://blog.logrocket.com/wp-content/uploads/2019/08/eslint-hook-warnings-300x55.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/08/eslint-hook-warnings.png"/></noscript>
<p>虽然我无法让自己去阅读那些想方设法压制来自官方<a href="https://www.npmjs.com/package/eslint-plugin-react-hooks"> ESLint插件</a> <a href="https://www.npmjs.com/package/eslint-plugin-react-hooks">钩子</a>的lint警告的人的所有评论，但我确实理解他们的困境。</p>
<p>在这一点上我同意丹·阿布拉莫夫<a href="https://github.com/facebook/create-react-app/issues/6880#issuecomment-485912528"/>。抑制插件中的<code>eslint-warnings</code>可能会在将来的某一天反噬你。</p>
<p>一般来说，我认为在生产应用中抑制这些警告是一个坏主意，因为你增加了在不久的将来引入微妙错误的可能性。</p>
<p>也就是说，仍然有一些有效的情况需要取消这些lint警告。下面是我自己遇到的一个例子。为了更容易理解，代码进行了简化:</p>
<pre>function Example ({ impressionTracker, propA, propB, propC }) {
  useEffect(() =&gt; {
    // 👇Track initial impression
    impressionTracker(propA, propB, propC)
  }, [])

  return &lt;BeautifulComponent propA={propA} propB={propB} propC={propC} /&gt;                 
}</pre>
<p>这是一个相当棘手的问题。</p>
<p>在这个具体的用例中，你不关心道具有没有变化。你只对调用带有初始<em>T2道具的<code>track</code>函数感兴趣。这就是印象追踪的工作原理。只有在组件挂载时才调用impression track函数。这里的区别是你需要用一些初始的道具来调用这个函数。</em></p>
<p>虽然您可能认为简单地将<code>props</code>重命名为类似<code>initialProps</code>的名称就可以解决问题，但这是行不通的。这是因为<code>BeautifulComponent</code>也依赖于接收更新的属性值。</p>
<p><img data-attachment-id="4630" data-permalink="https://blog.logrocket.com/rethinking-hooks-memoization/props-lint-warning-example/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2019/08/props-lint-warning-example.png" data-orig-size="730,309" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Initial props and updated props example" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2019/08/props-lint-warning-example-300x127.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2019/08/props-lint-warning-example.png" decoding="async" class="size-full wp-image-4630 aligncenter jetpack-lazy-image" src="../Images/63ea3913047f7cfa835af208905cccd8.png" alt="Initial Props And Updated Props Example" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2019/08/props-lint-warning-example.png 730w, https://blog.logrocket.com/wp-content/uploads/2019/08/props-lint-warning-example-300x127.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2019/08/props-lint-warning-example.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/08/props-lint-warning-example.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="4630" data-permalink="https://blog.logrocket.com/rethinking-hooks-memoization/props-lint-warning-example/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2019/08/props-lint-warning-example.png" data-orig-size="730,309" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Initial props and updated props example" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2019/08/props-lint-warning-example-300x127.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2019/08/props-lint-warning-example.png" decoding="async" loading="lazy" class="size-full wp-image-4630 aligncenter" src="../Images/63ea3913047f7cfa835af208905cccd8.png" alt="Initial Props And Updated Props Example" srcset="https://blog.logrocket.com/wp-content/uploads/2019/08/props-lint-warning-example.png 730w, https://blog.logrocket.com/wp-content/uploads/2019/08/props-lint-warning-example-300x127.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/08/props-lint-warning-example.png"/></noscript>
<p>在本例中，您将收到lint警告消息:<code>React Hook useEffect has missing dependencies: 'impressionTracker', 'propA', 'propB', and 'propC'. Either include them or remove the dependency array.</code></p>
<p>这是一个相当鲁莽的信息，但短绒只是做好自己的工作。简单的解决方案是使用一个<code>eslint-disable</code>注释，但是这并不总是最好的解决方案，因为将来您可能会在同一个<code>useEffect</code>调用中引入bug。</p>
<pre>useEffect(() =&gt; {
  impressionTracker(propA, propB, propC)
  // eslint-disable-next-line react-hooks/exhaustive-deps
}, [])</pre>
<p>我建议的解决方案是使用<code>useRef</code>钩子来保存对不需要更新的初始属性值的引用。</p>
<pre>function Example({impressionTracker, propA, propB, propC}) {
  // keep reference to the initial values         
  const initialTrackingValues = useRef({
      tracker: impressionTracker, 
      params: {
        propA, 
        propB, 
        propC, 
    }
  })

  // track impression 
  useEffect(() =&gt; {
    const { tracker, params } = initialTrackingValues.current;
    tracker(params)
  }, []) // you get NO eslint warnings for tracker or params

  return &lt;BeautifulComponent propA={propA} propB={propB} propC={propC} /&gt;   
}</pre>
<p>在我所有的测试中，linter只考虑这种情况下的<code>useRef</code>。有了<code>useRef</code>，linter知道引用的值不会改变，所以你不会得到任何警告！甚至<code>useMemo</code>也没有阻止这些警告。</p>
<p>例如:</p>
<pre>function Example({impressionTracker, propA, propB, propC}) {

  // useMemo to memoize the value i.e so it doesn't change
  const initialTrackingValues = useMemo({
    tracker: impressionTracker, 
    params: {
       propA, 
       propB, 
       propC, 
    }
  }, []) // 👈 you get a lint warning here

  // track impression 
  useEffect(() =&gt; {
    const { tracker, params} = initialTrackingValues
    tracker(params)
  }, [tracker, params]) // 👈 you must put these dependencies here

  return &lt;BeautifulComponent propA={propA} propB={propB} propC={propC} /&gt;
}</pre>
<p>在上面的错误解决方案中，即使我通过用<code>useMemo</code>记忆初始属性值来跟踪初始值，linter仍然对我大喊大叫。在<code>useEffect</code>调用中，记忆值<code>tracker</code>和<code>params</code>也必须作为数组依赖项输入。</p>
<p>我见过这样的人。这是糟糕的代码，应该避免。使用<code>useRef</code>挂钩，如初始解决方案所示。</p>
<p>总之，在大多数我真的想让lint警告静音的情况下，我发现<code>useRef</code>是一个完美的盟友。拥抱它。</p>
<h3 id="use-usememe-referential-equalities">4.仅将<code>useMemo</code>用于参考等式</h3>
<p>大多数人说使用<code>useMemo</code>进行昂贵的计算和保持参考等式。我同意第一个，但T2不同意第二个。不要仅仅为了引用等式而使用<code>useMemo</code>钩子。这样做只有一个原因——我稍后会讨论。</p>
<p>为什么仅仅用<code>useMemo</code>来表示参照等式是一件坏事？其他人不都是这么宣扬的吗？</p>
<p>考虑下面这个虚构的例子:</p>
<pre>function Bla() {
  const baz = useMemo(() =&gt; [1, 2, 3], [])
  return &lt;Foo baz={baz} /&gt;
}</pre>
<p>在组件<code>Bla</code>中，值<code>baz</code>被记忆，不是因为数组<code>[1,2,3]</code>的求值代价很高，而是因为对<code>baz</code>变量的引用在每次重新渲染时都会改变。</p>
<p>虽然这似乎不是问题，但我不认为<code>useMemo</code>是这里使用的正确钩子。</p>
<p>一，看数组依赖。</p>
<pre>useMemo(() =&gt; [1, 2, 3], [])</pre>
<p>这里，一个空数组被传递给了<code>useMemo</code>钩子。这意味着，值<code>[1,2,3]</code>只计算一次——当组件安装时。</p>
<p>因此，我们知道两件事:被记忆的值不是一个昂贵的计算，它在挂载后不会被重新计算。</p>
<p>如果你发现自己处于这种情况，我要求你重新考虑使用<code>useMemo</code>钩子。您正在记忆一个值，它不是一个昂贵的计算，也不会在任何时间点重新计算。这绝对不符合“记忆化”这个术语的定义</p>
<p>这是对<code>useMemo</code>钩子的糟糕使用。这在语义上是错误的，并且在内存分配和性能方面可能会花费更多。</p>
<p>那么，你应该怎么做呢？</p>
<p>首先，作者到底想达到什么目的？他们不是在试图记忆一个价值；相反，他们希望在重新渲染时保持<strong>引用</strong>的值不变。</p>
<p>别给那只黏糊糊的变色龙机会。在这种情况下，使用<code>useRef</code>钩。</p>
<p>例如，如果你真的讨厌使用当前属性(像我的许多同事一样)，那么简单地解构并重命名，如下所示:</p>
<pre>function Bla() {
  const { current: baz } = useRef([1, 2, 3])
  return &lt;Foo baz={baz} /&gt;
}</pre>
<p>问题解决了。</p>
<p>事实上，您可以使用<code>useRef</code>来保持对昂贵的函数求值的引用——只要函数不需要在props改变时重新计算。</p>
<p>对于这种情况，<code>useRef</code>是正确的挂钩，而不是<code>useMemo</code>挂钩。</p>
<p>能够使用<code>useRef</code>钩子模仿<a href="https://reactjs.org/docs/hooks-faq.html#is-there-something-like-instance-variables">实例变量</a>是钩子带给我们的最少使用的超能力之一。<code>useRef</code>钩子可以做的不仅仅是保存对DOM节点的引用。拥抱它。</p>
<p>请记住，这里的条件是，如果你记忆一个值，只是因为你需要保持对它的一致引用。如果您需要根据变化的属性或值重新计算值，那么请随意使用<code>useMemo</code>钩子。在某些情况下，您仍然可以使用<code>useRef</code>——但是考虑到数组依赖列表，<code>useMemo</code>最方便。</p>
<h2>结论</h2>
<p>逃离狮子，但不要让变色龙愚弄你。如果你允许它们，变色龙会改变它们的皮肤颜色，融入你的代码库，污染你的代码质量。</p>
<p>别让他们得逞。</p>
<p>好奇我对高级钩子的立场是什么？我正在做一个高级钩子的视频课程。注册吧，我会<a href="https://forms.gle/Qd6yZC1Lhcosnc2f8">让你知道</a>什么时候发布！</p><div class="code-block code-block-17">
<div class="blog-plug inline-plug react-plug" vwo-el-id="26283398190">
<h2 vwo-el-id="41600691720">使用LogRocket消除传统反应错误报告的噪音</h2>
<a href="https://lp.logrocket.com/blg/react-signup-issue-free" target="_blank" vwo-el-id="19356441070">LogRocket
</a><p>是一款React analytics解决方案，可保护您免受数百个误报错误警报的影响，只针对少数真正重要的项目。LogRocket告诉您React应用程序中实际影响用户的最具影响力的bug和UX问题。</p><a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="19356441380">
<img class="first-react-image alignnone size-full wp-image-46 jetpack-lazy-image jetpack-lazy-image--handled" src="../Images/f300c244a1a1cf916df8b4cb02bec6c6.png" vwo-el-id="18272717540" data-lazy-loaded="1" data-original-src="https://files.readme.io/27c94e7-Image_2017-06-05_at_9.46.04_PM.png"/>
</a>
<a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="19356441690">
<img class="second-react-image alignnone size-full wp-image-46 jetpack-lazy-image jetpack-lazy-image--handled" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" vwo-el-id="30720362350" data-lazy-loaded="1" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/>
</a>
<a href="https://lp.logrocket.com/blg/react-signup-issue-free" target="_blank" rel="noopener noreferrer" vwo-el-id="35866400580">LogRocket
</a><p>自动聚合客户端错误、反应错误边界、还原状态、缓慢的组件加载时间、JS异常、前端性能指标和用户交互。然后，LogRocket使用机器学习来通知您影响大多数用户的最具影响力的问题，并提供您修复它所需的上下文。</p><p vwo-el-id="28675661060">关注重要的React bug—<a class="signup" href="https://lp.logrocket.com/blg/react-signup-issue-free" target="_blank" rel="noopener noreferrer" vwo-el-id="40093418840">今天就试试LogRocket】。</a></p>
</div></div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
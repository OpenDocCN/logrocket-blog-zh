<html>
<head>
<title>Forget Express.js — opt for these alternatives instead - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>忘记Express.js吧——选择这些替代品——LogRocket Blog</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/forget-express-js-opt-for-these-alternatives-instead/#0001-01-01">https://blog.logrocket.com/forget-express-js-opt-for-these-alternatives-instead/#0001-01-01</a></blockquote><div><article class="article-post">
<p><em> <strong>编者按:</strong>这篇文章于2023年3月10日更新，包含了关于其他Node.js框架的信息，这些框架可能值得考虑作为Express.js的替代方案</em></p>
<p>在构建HTTP服务器时，Node.js 提供了一些强大的原语。默认情况下，每当服务器收到HTTP请求时，就会运行一个函数。众所周知，解析包含JSON主体的传入POST请求的服务器示例看起来有点像这样:</p>
<pre class="language-javascript hljs">const http = require('http');

const server = http.createServer((req, res) =&gt; {
  // This function is called once the headers have been received
  res.setHeader('Content-Type', 'application/json');

  if (req.method !== 'POST' || req.url !== '/user') {
    res.statusCode = 405;
    res.end('{"error":"METHOD_NOT_ALLOWED"}');
    return;
  }

  let body = '';

  req.on('data', (data) =&gt; {
    // This function is called as chunks of body are received
    body += data;
  });

  req.on('end', () =&gt; {
    // This function is called once the body has been fully received
    let parsed;

    try {
      parsed = JSON.parse(body);
    } catch (e) {
      res.statusCode = 400;
      res.end('{"error":"CANNOT_PARSE"}');
    }

    res.end(JSON.stringify({
      error: false,
      username: parsed.username
    }));
  });
});

server.listen(3000, () =&gt; {
  console.log('Server running at http://localhost:3000/');
});
</pre>
<p>默认情况下，Node.js允许我们在收到任何请求时运行一个函数。没有基于路径的内置路由器。Node.js执行一些基本的解析——例如，解析传入的HTTP消息并提取不同的组件，如路径、头对、编码(Gzip和SSL)等。</p>
<p>然而，对更高级功能的需求意味着我们通常不得不使用web框架。例如，如果收到一个<code>multipart/form-data</code>或<code>application/x-www-form-urlencoded</code>请求，我们需要使用一个模块来为我们解码内容。如果我们想简单地基于模式匹配和HTTP方法路由请求，我们将需要一个模块——或者，通常，一个完整的web框架——来为我们处理这个问题。</p>
<p>这就是像Express.js这样的工具发挥作用的地方。</p>
<p>在本文中，我们将研究Express.js以及其他几个Node.js框架，您可能希望在下一个项目中考虑这些框架。</p>
<p><em>向前跳转:</em></p>

<h2 id="getting-know-express-js">了解Express.js</h2>
<p>Express.js很早就成为使用Node.js构建web应用程序的首选框架。它为路由HTTP请求提供了良好的语法，并为构建中间件提供了标准化的接口。此外，它使用了核心Node.js APIs和大多数npm生态系统所采用的熟悉的回调模式。</p>
<p>Express.js变得如此流行，以至于它几乎无处不在地与Node.js联系在一起——就像当我们读到Ruby语言时，我们已经想到了框架Rails。事实上，Express.js和Node.js都是流行的MEAN和MERN堆栈首字母缩略词的成员。</p>
<p>让我们来看看当我们把Express.js引入到图片中时，我们前面的例子可能是什么样子的:</p>
<pre class="language-javascript hljs">const express = require('express');
const app = express();

app.post('/user', (req, res) =&gt; {
  // This function is called once the headers have been received

  let body = '';

  req.on('data', (data) =&gt; {
    // This function is called as chunks of body are received
    body += data;
  });

  req.on('end', () =&gt; {
    // This function is called once the body has been fully received
    let parsed;

    try {
      parsed = JSON.parse(body);
    } catch (e) {
      res.statusCode = 400;
      res.json({
        error: 'CANNOT_PARSE'
      });
    }

    res.json({
      error: false,
      username: parsed.username
    });
  });

});

app.listen(3000, () =&gt; {
  console.log('Server running at http://localhost:3000/');
});
</pre>
<p>在这个例子中，我们看到情况有所好转。我们可以通过使用<code>app.post('/user')</code>来具体说明我们想要匹配的方法和路径。这比在处理程序中编写一个大的分支语句要简单得多。</p>
<p>我们也被赋予了一些其他的细节。考虑一下<code>res.json({})</code>方法:这不仅将一个对象序列化为它的JSON等价物，而且还为我们设置了适当的<code>Content-Type</code>头！</p>
<p>然而，Express.js仍然给了我们与使用内置的<code>http</code>模块时相同的范例；例如，我们仍然在调用<code>req</code>和<code>res</code>对象上的方法。</p>
<h2 id="ideal-example-http-server">考虑一个HTTP服务器的理想例子</h2>
<p>让我们后退一步，看看HTTP服务器的理想示例是什么样的。路由是可取的，Express.js具有强大的路由语法(例如，它支持动态路由模式)。然而，在控制器函数中运行的代码是我们真正想要清理的地方。</p>
<p>在上面的例子中，我们用异步代码做了很多工作。请求对象是一个事件发射器，它发出我们关心的两个事件，即<code>data</code>和<code>end</code>。但是，实际上，我们通常只是希望能够将HTTP请求转换成JSON对象，以便于从中提取值。</p>
<p>此外，我们还得到一个请求(<code>req</code>)和一个响应(<code>res</code>)对象。<code>req</code>对象是有意义的——它包含了关于我们正在接收的请求的信息。但是<code>res</code>真的有那么多意义吗？我们只想提供一个来自控制器函数的结果作为回复。</p>
<p>对于同步函数，从函数调用中接收结果很简单:只需返回值。如果我们利用<code>async</code>函数，我们可以做同样的事情。通过返回对一个<code>async</code>函数的调用，控制器函数可以解析一个值，该值最终表示我们希望消费者接收的响应。</p>
<p>让我们来看一个例子:</p>
<pre class="language-javascript hljs">const server = someCoolFramework();

server.post('/user', async (req) =&gt; {
  let parsed;

  try {
    parsed = await req.requestBodyJson();
  } catch (e) {
    return [400, {
      error: 'CANNOT_PARSE'
    }];
  }

  return {
    error: false,
    username: parsed.username
  };
});

server.listen(3000, () =&gt; {
  console.log('Server running at http://localhost:3000/');
});
</pre>
<p>在我们这个理想化的例子中有一些概念。首先，我们维护Express.js使用的现有路由器语法，因为它相当可靠。其次，我们的<code>req</code>对象提供了一个助手，用于将传入的请求转换成JSON。</p>
<p>第三个特性是，我们能够通过简单地返回结果来提供响应的表示。由于JavaScript不支持元组，我们实际上是通过使用数组来重新创建一个元组。因此，在这个虚构的例子中，返回的字符串可以作为主体直接发送给客户机，返回的数组可以用于表示状态代码和主体(可能还有第三个参数用于元数据，如头)，返回的对象可以转换成它的JSON表示。</p>
<h2 id="adapting-express-js">改编Express.js</h2>
<p>现在，使用一组中间件，用Express.js实际上可以重现一些这种行为。</p>
<p><code>express-async-handler</code> npm模块提供了一个包装函数，它可以插入并允许<code>async</code>控制器函数与Express.js <code>app.use</code> API很好地交互。不幸的是，这需要开发人员手动包装每个控制器功能:</p>
<pre class="language-javascript hljs">const asyncHandler = require('express-async-handler')

app.post('/user', asyncHandler(async (req, res, next) =&gt; {
  const bar = await foo.findAll();
  res.send(bar);
}))
</pre>
<p>响应元组展开也可以由中间件来处理。这种中间件需要在控制器代码运行后运行，并用Express.js期望的表示替换数组。</p>
<p>承诺请求正文流解析的能力也可以以通用方式构建:</p>
<pre class="language-javascript hljs">app.use((req, res, next) =&gt; {
  req.bodyToJson = requestBodyJson(req);
  next();
});

function requestBodyJson(req) {
  return new Promise((resolve, reject) =&gt; {
    let body = '';

    req.on('data', (data) =&gt; {
      // This function is called as chunks of body are received
      body += data;
    });

    req.on('end', () =&gt; {
      // This function is called once the body has been fully received
      let parsed;

      try {
        parsed = JSON.parse(body);
      } catch (e) {
        reject(e);
        return;
      }

      resolve(parsed);
    });
  });
}
</pre>
<p>有了上面的代码，我们就可以等待使用Express.js进行解析了(实际上还有其他任何给定HTTP <code>Request</code>对象实例的情况):</p>
<pre class="language-javascript hljs">// When using the Express.js middleware:
const parsed = await req.bodyToJson();

// Using the function generically:
const parsed = await requestBodyJson(req);
</pre>
<h2 id="alternative-node-js-frameworks">使用替代Node.js框架</h2>
<p>的确，我们可以使用Express.js来复制这些期望的模式，但是也有一些框架是在支持promises和async/await范式的基础上构建的。让我们看看使用不同的web服务器框架编写的示例控制器是什么样子的。</p>
<h3 id="fastify">Fastify</h3>
<p>顾名思义，Fastify是一个非常快速的Node.js web框架。尽管它的主要目标是速度，但它实际上很好地实现了我们理想的控制器语法。</p>
<p>这个例子非常简洁，几乎让人感觉像是作弊:</p>
<pre class="language-javascript hljs">const fastify = require('fastify');
const app = fastify();

app.post('/user', async (req, reply) =&gt; {
  return {
    error: false,
    username: req.body.username
  };
});

app.listen(3000).then(() =&gt; {
  console.log('Server running at http://localhost:3000/');
});
</pre>
<p>Fastify不仅支持将<code>async</code>函数用作控制器代码，而且如果<code>Content-Type</code>头表明主体是JSON，它还会自动将传入的请求解析为JSON。这就是示例代码如此之小的原因。</p><div class="code-block code-block-54">
<hr/>
<h3>更多来自LogRocket的精彩文章:</h3>

<hr/></div>
<p>这也意味着当解析失败时，我们可以依靠Fastify来响应一个正常的错误。例如，当客户端向Fastify发送无效的JSON时，响应将类似如下:</p>
<pre class="language-javascript hljs">{
  "statusCode": 400,
  "error": "Bad Request",
  "message": "Unexpected string in JSON at position 19"
}
</pre>
<h4 id="fastify-quickstart">快速启动</h4>
<pre class="language-bash hljs">npm install fastify
</pre>
<h3 id="koa">寇阿相思树</h3>
<p><a href="https://koajs.com/"> Koa </a>是Express.js的精神继承者，由一些最初的Express.js作者编写。它确实支持户外功能，但它没有自带路由器。我们可以利用<code>koa-router</code>来提供路由。</p>
<p>下面是我们的示例控制器在Koa中的样子:</p>
<pre class="language-javascript hljs">const Koa = require('koa');
const Router = require('koa-router');
const app = new Koa();
const router = new Router();

router.post('/user', async (ctx) =&gt; {
  try {
    const parsed = await requestBodyJson(ctx.req);
    ctx.body = {
      error: false,
      username: parsed.username
    };
  } catch (e) {
    ctx.status = 400;
    ctx.body = {
      error: 'CANNOT_PARSE'
    };
  }
});

app.use(router.routes());
app.listen(3000);
</pre>
<p>这个Koa例子不像Fastify版本那样简洁。它不执行自动JSON解析，但是我们能够重用我们之前创建的<code>requestBodyJson()</code>方法。它也不使用从我们的控制器返回/解析的值，而是通过使用附加到<code>ctx</code>参数的数据来工作。</p>
<h4 id="koa-quickstart">快速启动</h4>
<pre class="language-bash hljs"> npm i koa
</pre>
<h3 id="nest-js">嵌套. js</h3>
<p>Nest.js为TypeScript提供了内置的支持，这保证了类型安全，并为创建可测试、可伸缩、模块化和可维护的应用程序提供了一个架构。与Fastify和Express.js等其他流行框架一样，Nest.js提供了广泛的功能，包括依赖注入、中间件、路由和异步编程。</p>
<p>下面是我们的示例控制器在Nest.js中的样子:</p>
<pre class="language-javascript hljs">import { Controller, Post, Body } from '@nestjs/common';

@Controller()
export class UserController {
  @Post('/user')
  async createUser(@Body() body: { username: string }): Promise&lt;{ error: boolean, username: string }&gt; {
    return {
      error: false,
      username: body.username,
    };
  }
}
</pre>
<p>Nest还自动将传入的请求解析成JSON，并支持控制器代码的<code>async</code>函数。然而，它不像Fastify那样简洁，这是由于它的面向对象、模块、依赖注入和装饰架构模式，这不容易掌握，尤其是对于开发新手来说。</p>
<h4 id="nest-js-quickstart">快速启动</h4>
<pre class="language-bash hljs">npm i @nestjs/core
</pre>
<h3 id="hapi">哈比神</h3>
<p>哈比神最初是为了处理沃尔玛的黑色星期五销售而构建的，因此它是开发人员构建可伸缩且健壮的应用程序的最佳选择之一。它非常适合我们选择控制器语法，因为它提供了许多内置特性，比如路由和异步编程。</p>
<p>下面是我们的示例控制器在使用哈比神时的样子:</p>
<pre class="language-javascript hljs">const Hapi = require('@hapi/hapi');

const init = async () =&gt; {
  const server = Hapi.server({
    port: 3000,
    host: 'localhost'
  });

  server.route({
    method: 'POST',
    path: '/user',
    handler: async (request, h) =&gt; {
      return {
        error: false,
        username: request.payload.username
      };
    }
  });

  await server.start();
  console.log('Server running at:', server.info.uri);
};

process.on('unhandledRejection', (err) =&gt; {
  console.error(err);
  process.exit(1);
});

init();
</pre>
<p>哈比神使用上例中的<code>request.payload</code>对象提取传入的请求体，并根据请求的<code>content-type</code>头自动解析它。</p>
<p>默认情况下，哈比神不仅解析传入的请求，还提供了一系列功能来帮助开发人员处理请求数据。例如，哈比神的验证系统允许开发人员为传入的请求数据定义输入验证规则，确保数据在被应用程序处理之前是有效和安全的。</p>
<h4 id="hapi-quickstart">快速启动</h4>
<pre class="language-bash hljs">npm install @hapi/hapi
</pre>
<h3 id="derbyjs">德比耶斯</h3>
<p>DerbyJS 采用了一种不同的方法来创建服务器端应用。它是一个模型-视图-控制器框架，可用于编写实时后端或前端应用程序。该框架为模板、路由、异步编程和后端框架中常见的其他特性提供了内置支持。</p>
<p>下面是我们的示例控制器使用DerbyJS时的样子:</p>
<pre class="language-javascript hljs">const app = require('derby').createApp();
const http = require('http');

app.post('/user', async function(page, model, params, next) {
  try {
    const username = params.body.username;
    await new Promise(resolve =&gt; setTimeout(resolve, 1000));
    next(null, {error: false, username: username});
  } catch (err) {
    next(err);
  }
});

const server = http.createServer(app.run());

server.listen(3000, function() {
  console.log('Server running at http://localhost:3000/');
});
</pre>
<p>尽管DerbyJS采用了非常规的架构，但它提供了对请求体的自动解析，不需要像其他Node.js框架那样使用中间件或库来手动解析请求体。</p>
<h4 id="derbyjs-quickstart">快速启动</h4>
<pre class="language-bash hljs">git clone https://github.com/derbyjs/derby-examples.git
</pre>
<h2 id="takeaways">外卖食品</h2>
<p>当Node.js还处于起步阶段时，Express.js成为构建web应用程序的明显选择。Express.js的目标是成为一个遵循回调范例的方便的web服务器。它实现了这个目标，产品现在基本上已经完成了。</p>
<p>然而，随着JavaScript生态系统的成熟，我们获得了新的语言工具和语法。从那以后，出现了几十个甚至几百个框架，其中许多都采用了这些新的语言特性。</p>
<p>如果你发现自己在从事一个用Node.js编写的新项目，它充当web服务器，我鼓励你考虑新的竞争者，比如Koa、Nest.js、哈比神、DerbyJS和Fastify，而不是默认使用熟悉的Express.js</p><div class="code-block code-block-23">
<div class="blog-plug inline-plug node-plug"><h2>200只<img src="../Images/61167b9d027ca73ed5aaf59a9ec31267.png" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2019/10/green-check.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" class=" jetpack-lazy-image" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/10/green-check.png"/> <noscript> <img data-lazy-fallback="1" src="../Images/61167b9d027ca73ed5aaf59a9ec31267.png" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/10/green-check.png"/> </noscript>显示器出现故障，生产中网络请求缓慢</h2><p>部署基于节点的web应用程序或网站是容易的部分。确保您的节点实例继续为您的应用程序提供资源是事情变得更加困难的地方。如果您对确保对后端或第三方服务的请求成功感兴趣，</p><a href="https://lp.logrocket.com/blg/node-signup" target="_blank">try LogRocket</a><p>. </p><a class="signup" href="https://lp.logrocket.com/blg/node-signup" target="_blank" rel="noopener noreferrer"><img src="../Images/cae72fd2a54c5f02a6398c4867894844.png" alt="LogRocket Network Request Monitoring" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2019/12/network-request-filter-2-1.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" class=" jetpack-lazy-image" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/12/network-request-filter-2-1.png"/><noscript><img data-lazy-fallback="1" src="../Images/cae72fd2a54c5f02a6398c4867894844.png" alt="LogRocket Network Request Monitoring" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/12/network-request-filter-2-1.png"/></noscript></a><a href="https://lp.logrocket.com/blg/node-signup" target="_blank" rel="noopener noreferrer">https://logrocket.com/signup/</a><p>LogRocket 就像是网络和移动应用程序的DVR，记录下用户与你的应用程序交互时发生的一切。您可以汇总并报告有问题的网络请求，以快速了解根本原因，而不是猜测问题发生的原因。</p><p>LogRocket检测您的应用程序以记录基线性能计时，如页面加载时间、到达第一个字节的时间、慢速网络请求，还记录Redux、NgRx和Vuex操作/状态。</p><a class="signup" href="https://lp.logrocket.com/blg/node-signup" target="_blank" rel="noopener noreferrer">Start monitoring for free</a><p>. </p></div>
</div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
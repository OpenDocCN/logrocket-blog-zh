<html>
<head>
<title>Getting started with WebAssembly and Rust - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>WebAssembly和Rust - LogRocket博客入门</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/getting-started-with-webassembly-and-rust/#0001-01-01">https://blog.logrocket.com/getting-started-with-webassembly-and-rust/#0001-01-01</a></blockquote><div><article class="article-post">
<p>我最初接触Rust是因为这个团队在支持和推动WebAssembly方面所做的出色工作。官方文档是构建一个示例项目的绝佳资源。</p>
<p/>
<p>本指南将作为WebAssembly的介绍以及如何在Rust Wasm环境中设置和工作的教程。</p>
<p>要继续学习，您应该对Rust和web开发有一个基本的了解。</p>
<h2 id="understandingwebassembly">了解WebAssembly</h2>
<p>WebAssembly是大多数浏览器都支持的二进制指令格式。它支持Rust、C、C++ Go等语言。，在web浏览器中编译和运行。</p>
<p>Wasm不是JavaScript的替代品。可以把它看作是把计算量大的任务转移到更合适的语言上的一种方式。它使您能够将现有的项目和库移植到web上，而不用用JS重写它们，从而提高性能。</p>
<p>如果你对在web之外采用Wasm规范感兴趣，那么<a href="https://wasi.dev/" target="_blank" rel="noopener noreferrer"> WebAssembly系统接口(WASI) </a>可能会让你感兴趣。</p>

<p>在开始设置环境之前，请确保您的计算机上安装了以下软件。</p>
<ul>
<li><a href="https://www.rust-lang.org/tools/install" target="_blank" rel="noopener noreferrer"> Rust </a>(最好是最新版本)</li>
<li>现代网络浏览器(Internet Explorer不算)</li>
<li>您最喜欢的文本编辑器</li>
<li>一种托管简单web服务器的方法，以避免浏览器唠叨跨源请求被阻塞；如果你安装了Python，有一个很棒的命令</li>
<li>CLI</li>
</ul>
<p>为什么需要<code>wasm-pack</code>？根据<a href="https://hacks.mozilla.org/2018/04/hello-wasm-pack/" target="_blank" rel="noopener noreferrer"> Mozilla </a>的说法，“<code>wasm-pack</code>是一个针对WebAssembly的组装打包Rust crates的工具。这些软件包可以发布到npm注册表，并与其他软件包一起使用。这意味着你可以将它们与JS和其他包一起使用，也可以在很多应用程序中使用。”</p>
<p>Rust crates类似于其他语言的包和库。板条箱直接与Rust的构建系统和package manager，Cargo一起工作。</p>
<h2 id="creatingbuildingawasmpackage">创建和构建Wasm包</h2>
<p>我们将使用<code>wasm-pack</code> CLI创建一个新的Wasm项目。如果您曾经通过<code>cargo</code> CLI创建过Rust项目，那么您应该对此很熟悉。</p>
<pre>wasm-pack new hello-wasm
cd hello-wasm
</pre>
<p>生成的项目本质上是一个带有样板Wasm代码的Rust库。</p>
<p><img data-attachment-id="20904" data-permalink="https://blog.logrocket.com/getting-started-with-webassembly-and-rust/rust-library-boilerplate-wasm/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/06/rust-library-boilerplate-wasm.png" data-orig-size="161,243" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Rust library boilerplate WASM code" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/06/rust-library-boilerplate-wasm.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/06/rust-library-boilerplate-wasm.png" decoding="async" class="aligncenter size-full wp-image-20904 jetpack-lazy-image" src="../Images/4023c4c750327ba5ac144cc9e44501e6.png" alt="Rust Library Boilerplate WASM Code" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2020/06/rust-library-boilerplate-wasm.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/06/rust-library-boilerplate-wasm.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="20904" data-permalink="https://blog.logrocket.com/getting-started-with-webassembly-and-rust/rust-library-boilerplate-wasm/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/06/rust-library-boilerplate-wasm.png" data-orig-size="161,243" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Rust library boilerplate WASM code" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/06/rust-library-boilerplate-wasm.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/06/rust-library-boilerplate-wasm.png" decoding="async" loading="lazy" class="aligncenter size-full wp-image-20904" src="../Images/4023c4c750327ba5ac144cc9e44501e6.png" alt="Rust Library Boilerplate WASM Code" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/06/rust-library-boilerplate-wasm.png"/></noscript>
<p>查看<code>wasm-pack</code>中可用的命令，很明显，这里关注的是创建和发布npm包。</p>
<pre>WASM-PACK SUBCOMMANDS:
    build      🏗️  build your npm package!
    help       Prints this message or the help of the given subcommand(s)
    login      👤  Add an npm registry user account! (aliases: adduser, add-user)
    new        🐑 create a new project with a template
    pack       🍱  create a tar of your npm package but don't publish!
    publish    🎆  pack up your npm package and publish!
    test       👩‍🔬  test your wasm!
</pre>
<p>虽然这对于有bundlers (Webpack、Rollup等)的项目来说很棒。)，我们的目标是一个简单的设置，我们可以在一个HTML文件中导入Wasm二进制文件。谢天谢地，<code>wasm-pack</code>的<code>build</code>有一个针对其他环境的论点。</p>
<pre>-t, --target &lt;target&gt;        Sets the target environment. [possible values: bundler, nodejs, web, no-modules]
                                [default: bundler]
</pre>
<p>这个目标正是我们想要的！一旦构建完成，输出将包含多个文件，作为Wasm和JS之间的粘合代码。最后，我们的Wasm二进制文件将通过一个<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Modules" target="_blank" rel="noopener noreferrer"> JavaScript模块</a>公开。</p>
<pre>wasm-pack build --target web
</pre>
<h2 id="runningwasminthebrowser">在浏览器中运行Wasm</h2>
<p>Rust代码编译成Wasm后，我们现在可以从JavaScript调用它了。</p>
<p>在项目的根目录下创建一个名为<code>index.html</code>的文件，并添加以下内容。</p>
<pre>&lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;meta charset="utf-8" /&gt;
    &lt;title&gt;My Wasm Project&lt;/title&gt;
  &lt;/head&gt;

  &lt;body&gt;
    &lt;script type="module"&gt;
      // Importing WASM as a JS module requires us to call an init function provided by the default export.
      // This is planned to be changed in the future.
      import { default as wasm, greet } from "./pkg/hello_wasm.js";

      wasm().then((module) =&gt; {
        // The boiler plate project comes with a `greet` function that calls:
        // `alert("Hello, hello-wasm!");`
        greet();
      });
    &lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;
</pre>
<p>出于安全原因，浏览器通常不允许您从<code>file://</code>导入本地资源。这阻止了我们导入Wasm二进制文件，但是一个简单的解决方案是启动一个快速web服务器。</p>
<p>如果安装了Python，可以使用以下命令之一。</p>
<ul>
<li>Python 3: <code>python -m http.server 8000</code></li>
<li>Python 2: <code>python -m SimpleHTTPServer 8000</code></li>
</ul>
<p>我们现在已经有了可以在浏览器中运行的Rust代码。访问<a href="http://localhost:8000/" target="_blank" rel="noopener noreferrer"> http://localhost:8000 </a>看直播。它应该是一个带有警告的空白页。</p>
<p><img data-attachment-id="20905" data-permalink="https://blog.logrocket.com/getting-started-with-webassembly-and-rust/wasm-project-running-in-browser/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/06/wasm-project-running-in-browser.png" data-orig-size="450,341" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="WASM project running in browser" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/06/wasm-project-running-in-browser-300x227.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/06/wasm-project-running-in-browser.png" decoding="async" class="aligncenter size-full wp-image-20905 jetpack-lazy-image" src="../Images/cd983aca936ecbac1b5f67712c86b675.png" alt="WASM Project Running in Browser" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2020/06/wasm-project-running-in-browser.png 450w, https://blog.logrocket.com/wp-content/uploads/2020/06/wasm-project-running-in-browser-300x227.png 300w" data-lazy-sizes="(max-width: 450px) 100vw, 450px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2020/06/wasm-project-running-in-browser.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/06/wasm-project-running-in-browser.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="20905" data-permalink="https://blog.logrocket.com/getting-started-with-webassembly-and-rust/wasm-project-running-in-browser/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/06/wasm-project-running-in-browser.png" data-orig-size="450,341" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="WASM project running in browser" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/06/wasm-project-running-in-browser-300x227.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/06/wasm-project-running-in-browser.png" decoding="async" loading="lazy" class="aligncenter size-full wp-image-20905" src="../Images/cd983aca936ecbac1b5f67712c86b675.png" alt="WASM Project Running in Browser" srcset="https://blog.logrocket.com/wp-content/uploads/2020/06/wasm-project-running-in-browser.png 450w, https://blog.logrocket.com/wp-content/uploads/2020/06/wasm-project-running-in-browser-300x227.png 300w" sizes="(max-width: 450px) 100vw, 450px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/06/wasm-project-running-in-browser.png"/></noscript>
<h2 id="rustandjavascriptinterop">Rust和JavaScript互操作</h2>
<p>对于下面的代码示例，您可以编辑<code>index.html</code> <span>和</span> <code>src/lib.rs</code> <span>文件来体验新的变化。</span>记住每次编辑Rust代码时都要编译。</p>
<p>既然您已经知道如何构建一个项目，那么是时候学习如何使用它了。默认情况下，Rust不能直接与JavaScript或web APIs通信。该功能通过<code><a href="https://rustwasm.github.io/docs/wasm-bindgen/" target="_blank" rel="noopener noreferrer">wasm-bindgen</a></code>启用。项目本身由多个板条箱和一个CLI工具组成。我们实际上一直在通过<code>wasm-pack</code>使用它的CLI。</p>
<p>来自<code>wasm-bindgen</code>的板条箱包括:</p>

<h3 id="exportingcommontypes">导出常见类型</h3>
<p>通过导入<code>wasm_bindgen::prelude::*</code>，我们获得了与JS对话的强大抽象。这里有一些我想强调的:</p>
<ul>
<li>自动处理Rust和JS之间大部分绑定的宏。</li>
<li><code>JsValue</code>:JS拥有的数据的表示。</li>
<li><code>UnwrapThrowExt</code>:对<code>Option&lt;T&gt;</code>和<code>Result&lt;T, E&gt;</code>的特征扩展。</li>
</ul>
<p>假设您正在编辑<code>src/lib.rs</code>，下面的例子展示了如何用Wasm接收和返回值。注意，给变量加下划线(比如<code>_c</code>)是一种习惯，表示它没有被使用。</p>
<pre>use wasm_bindgen::prelude::*;

// JS doesn't have a chars type which means:
// - The _c argument is the first char of a JS string.
// - The char returned will be a JS string.
#[wasm_bindgen]
pub fn char_example(_c: char) -&gt; char {
    '🚀'
}

#[wasm_bindgen]
pub fn string_example(s: String) -&gt; String {
    format!("Hello {}", s)
}

// str cannot be used as a return type.
// This is because we can't return borrowed references with the wasm_bindgen macro.
#[wasm_bindgen]
pub fn str_example(s: &amp;str) -&gt; String {
    format!("Hello {}", s)
}

#[wasm_bindgen]
pub fn number_example(n: i32) -&gt; i32 { // assume the same for u32, usize, etc.
    n+100
}

#[wasm_bindgen]
pub fn bool_example(_b: bool) -&gt; bool {
    true
}

// `Box&lt;[JsValue]&gt;` are the representation for a JS array object.
// When it comes to Js Arrays:
// - They are iterable.
// - Can contain multiple types by being of type JsValue (strictly typed arrays exist for numbers).
// - Don't really support N-dimensional arrays and are expensive to work with.
#[wasm_bindgen]
pub fn mixed_array_example(array: Box&lt;[JsValue]&gt;) -&gt; Box&lt;[JsValue]&gt; {
    for value in array.iter() {
        // compute things...
    }

    vec![
        "Hello".into(),
        512.into(),
        JsValue::NULL,
        JsValue::UNDEFINED,
        61.20.into(),
    ]
    .into_boxed_slice()
}

// Typed arrays are only available for number types.
// For example, the function below will return a JS Int32Array type.
#[wasm_bindgen]
pub fn typed_array_example(_array: Box&lt;[i32]&gt;) -&gt; Box&lt;[i32]&gt; {
    vec![1, 2, 3, 4, 5, 6, 7].into_boxed_slice()
}

// When it comes to Option:
// - Some returns the value inside.
// - None returns a JS undefined.
#[wasm_bindgen(catch)]
pub fn option_example() -&gt; Option&lt;i32&gt; {
    None
}

// When it comes to Result
// - Result&lt;T, JsValue&gt; is the only supported signature. T must be convertible to a JsValue.
// - #[wasm_bindgen(catch)] must be used when returning a result.
// - Err will be equivalent to a JS thrown error.
// - Ok will return the value inside.
#[wasm_bindgen]
pub fn result_example() -&gt; Result&lt;i32, JsValue&gt; {
    // With the wasm prelude imported, we can convert most common types by calling .into()
    Err("Look Pa, I'm throwing a JS error!".into())
}
</pre>
<p>一旦项目再次构建，这些功能可以直接在我们的网页中使用。您可以随意试验并打印返回值。</p>
<pre>&lt;script type="module"&gt;
  import * as wasm from "./pkg/hello_wasm.js";

  wasm.default().then((module) =&gt; {
    wasm.char_example("R");
    wasm.string_example("Jane");
    wasm.str_example("John");
    wasm.number_example(28);
    wasm.mixed_array_example([2, null, undefined, "Hola", true]);
    wasm.typed_array_example([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]);
    wasm.option_example();
    wasm.result_example();
  });
&lt;/script&gt;
</pre>
<h3 id="exportingstructsenums">导出结构和枚举</h3>
<p>枚举和结构是相当简单的导出。虽然有一些限制，但语法应该还是感觉日复一日的生锈。</p>
<pre>use wasm_bindgen::prelude::*;

// When it comes to Enums:
// - They  are C styled.
// - JS represents them through an object with a number for each variant.
#[wasm_bindgen]
pub enum ExampleEnum {
    Yes,
    No,
}

#[wasm_bindgen]
pub fn verify_enum_choice(choice: ExampleEnum) -&gt; bool {
    match choice {
        ExampleEnum::Yes =&gt; true,
        ExampleEnum::No =&gt; false,
    }
}

// When it comes to Structs:
// - Cannot contain lifetimes or type parameters.
// - Each field value must impl the Copy trait.
#[wasm_bindgen]
pub struct ExampleStruct {
    pub value: i32,
}

// For struct impl, we have the option for struct methods and type-level functions.
// JS handles structs by creating a JS object with a pointer (i.o.w. we can use references!).
#[wasm_bindgen]
impl ExampleStruct {
    pub fn new(value: i32) -&gt; ExampleStruct {
        ExampleStruct { value }
    }

    pub fn read_method(&amp;self) -&gt; i32 {
        self.value
    }

    pub fn write_method(&amp;mut self, value: i32) {
        self.value = value;
    }

    pub fn transfer_ownership(self) -&gt; ExampleStruct {
        self
    }
}
</pre>
<p>现在，我们可以将struct和enum直接导入到JS代码中。一旦一个结构被实例化，我们可以调用它的Wasm兼容的方法。</p>
<pre>&lt;script type="module"&gt;
  import * as wasm from "./pkg/hello_wasm.js";

  wasm.default().then((module) =&gt; {
    // Enum \\
    let rustEnum = wasm.ExampleEnum.Yes;
    console.log(wasm.verify_enum_choice(rustEnum));

    // Struct \\
    let rustStruct = wasm.ExampleStruct.new(6);
    console.log(rustStruct); // this will contain a pointer
    console.log(rustStruct.value);

    rustStruct.write_method(200);
    console.log(rustStruct.read_method());

    let newRustStruct = rustStruct.transfer_ownership();
    rustStruct.read_method(); // rustStruct is now invalid. An error will throw.
  });
&lt;/script&gt;
</pre>
<p>下面是上面脚本的输出图像，演示了这些类型是如何工作的。注意枚举和结构在JS中是如何表示的。</p>
<p><img data-attachment-id="20908" data-permalink="https://blog.logrocket.com/getting-started-with-webassembly-and-rust/structs-enums-represented-in-javascript-2/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/06/structs-enums-represented-in-javascript-1.png" data-orig-size="720,153" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Structs and enums represented in JavaScript" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/06/structs-enums-represented-in-javascript-1-300x64.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/06/structs-enums-represented-in-javascript-1.png" decoding="async" class="aligncenter size-full wp-image-20908 jetpack-lazy-image" src="../Images/423c107932191f1679ac5ad0b82a87c8.png" alt="Structs and Enums Represented in JavaScript" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2020/06/structs-enums-represented-in-javascript-1.png 720w, https://blog.logrocket.com/wp-content/uploads/2020/06/structs-enums-represented-in-javascript-1-300x64.png 300w" data-lazy-sizes="(max-width: 720px) 100vw, 720px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2020/06/structs-enums-represented-in-javascript-1.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/06/structs-enums-represented-in-javascript-1.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="20908" data-permalink="https://blog.logrocket.com/getting-started-with-webassembly-and-rust/structs-enums-represented-in-javascript-2/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/06/structs-enums-represented-in-javascript-1.png" data-orig-size="720,153" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Structs and enums represented in JavaScript" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/06/structs-enums-represented-in-javascript-1-300x64.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/06/structs-enums-represented-in-javascript-1.png" decoding="async" loading="lazy" class="aligncenter size-full wp-image-20908" src="../Images/423c107932191f1679ac5ad0b82a87c8.png" alt="Structs and Enums Represented in JavaScript" srcset="https://blog.logrocket.com/wp-content/uploads/2020/06/structs-enums-represented-in-javascript-1.png 720w, https://blog.logrocket.com/wp-content/uploads/2020/06/structs-enums-represented-in-javascript-1-300x64.png 300w" sizes="(max-width: 720px) 100vw, 720px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/06/structs-enums-represented-in-javascript-1.png"/></noscript>
<h3 id="manuallycreatingbindings">手动创建绑定</h3>
<p>这个箱子为与JS对话提供了强大的工具。然而，JS标准或web APIs没有直接的绑定。这就是<code>web-sys</code>和<code>js-sys</code>出现的原因。两个板条箱都有现成的绑定，提供了一个标准的工作界面。</p>
<p>当然，这些板条箱并不能覆盖所有东西，所以我们需要为丢失的任何东西创建我们自己的绑定。一个常见的例子是包装定制的JS类和函数。当您第一次打开<code>src/lib.rs</code>时，您可能已经注意到为<code>alert()</code>函数创建了一个绑定。</p>
<p>在我们介绍如何创建自己的定制绑定之前，让我们先来看看Rust要绑定的JS代码。</p>
<pre>&lt;!--
  For simplicity, we'll add a class declaration to the global namespace.
  The goal, from rust, is to create this class, call a method, and get/set a property.
--&gt;
&lt;script&gt;
  class Coordinate {
    constructor(x, y) {
      this.x = x;
      this.y = y;
    }

    printValues() {
      return `(x:${this.x} y:${this.y})`;
    }
  }
&lt;/script&gt;

&lt;script type="module"&gt;
  import * as wasm from "./pkg/hello_wasm.js";

  wasm.default().then((module) =&gt; {
    wasm.manual_bindings_example();
  });
&lt;/script&gt;
</pre>
<p>在绑定<code>Coordinates</code>类的基础上，下面是一些如何为各种JS函数做同样事情的例子。</p>
<pre>use wasm_bindgen::prelude::*;

// Although we're using what's in the global namespace, we can also import from other modules.
// #[wasm_bindgen(module = "./bar")]
// extern "C" {}

// Binding JS involves a bit of boilerplate because we have to specify each name
// and signature to bind.
#[wasm_bindgen]
extern "C" {
    // Bindings must be named as their JS equivalent
    fn alert(s: &amp;str);

    // A different name can be specified as long as the original name is passed to the macro.
    #[wasm_bindgen(js_name = prompt)]
    fn ask(s: &amp;str) -&gt; String;

    // Methods can be from any js namespace.
    #[wasm_bindgen(js_namespace = console)]
    fn log(s: &amp;str);

    // Using a different name allows us to specify various signatures.
    #[wasm_bindgen(js_namespace = console, js_name = log)]
    fn log_num(n: i32);

    //* JS Class example *\\
    // The process is a little verbose because create a binding for
    // each part of the class we want (class name, constructor, methods, setters, getters).
    type Coordinate;

    #[wasm_bindgen(constructor)]
    fn new(x: i32, y: i32) -&gt; Coordinate;

    // methods must match the naming in the class declaration.
    #[wasm_bindgen(method)]
    fn printValues(this: &amp;Coordinate) -&gt; String;

    // getters are named as the property we want.
    #[wasm_bindgen(getter, method)]
    fn x(this: &amp;Coordinate) -&gt; i32;

    // setters are named the same as getters but with a `set_` prefix.
    #[wasm_bindgen(setter, method)]
    fn set_x(this: &amp;Coordinate, x: i32);
}

#[wasm_bindgen]
pub fn manual_bindings_example() {
    alert("Hey buddy!");
    log(&amp;ask("Tell me about your day!"));

    let coordinates = Coordinate::new(-4, 15);
    log_num(coordinates.x()); // prints -4

    coordinates.set_x(coordinates.x() * 2);
    log(&amp;coordinates.printValues()); // prints (-8, 15)
}
</pre>
<p><img data-attachment-id="20907" data-permalink="https://blog.logrocket.com/getting-started-with-webassembly-and-rust/custom-bindings/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/06/custom-bindings.gif" data-orig-size="448,527" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Custom bindings" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/06/custom-bindings-255x300.gif" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/06/custom-bindings.gif" decoding="async" class="aligncenter size-full wp-image-20907 jetpack-lazy-image" src="../Images/522477eb3eb8ba155ded5b826dd48956.png" alt="Custom Bindings" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2020/06/custom-bindings.gif?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/06/custom-bindings.gif"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="20907" data-permalink="https://blog.logrocket.com/getting-started-with-webassembly-and-rust/custom-bindings/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/06/custom-bindings.gif" data-orig-size="448,527" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Custom bindings" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/06/custom-bindings-255x300.gif" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/06/custom-bindings.gif" decoding="async" loading="lazy" class="aligncenter size-full wp-image-20907" src="../Images/522477eb3eb8ba155ded5b826dd48956.png" alt="Custom Bindings" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/06/custom-bindings.gif"/></noscript>
<h2 id="interactingwithwebapis">与web APIs交互</h2>
<p>大多数重要的web APIs都是由<code>web-sys</code>机箱提供和记录的。在指定了我们想要的API之后，我们可以做很多事情，包括:</p>
<ul>
<li>编辑HTML元素</li>
<li>添加事件侦听器</li>
<li>打印到web控制台</li>
<li>在画布上画画</li>
</ul>
<p>由于列表非常广泛，我们将只关注如何设置和使用这个create。</p>
<p>将以下内容添加到项目的<code>Cargo.toml</code>中，然后指定您想要使用的每个web API。</p>
<pre>[dependencies]
web-sys = { version = "0.3.39", features = ['console'] }

use wasm_bindgen::prelude::*;
use web_sys::console;

#[wasm_bindgen]
pub fn print_things() {
  // console has multiple log_x functions that represent how many items are being printed.
  // log_x takes in a reference to a JsValue so we need to convert the values we want to print.
  console::log_1(&amp;"Printing from Rust!!".into());
  console::log_2(&amp;"Numbers: ".into(), &amp;1234.into());
}
</pre>
<p>要了解更多信息，请查看以下<code>web-sys</code>资源。</p>

<p>如果您发现需要从标准JS导入类型和函数，那么研究一下<code>js-sys</code>箱也是值得的。</p>
<h2 id="closingthoughts">结束语</h2>
<p>虽然我们不可能在一篇博文中涵盖所有内容，但我希望这篇指南能够帮助您开始WebAssembly之旅。我非常鼓励浏览<a href="https://rustwasm.github.io/docs/wasm-bindgen/" target="_blank" rel="noopener noreferrer"> <code>wasm-bindgen</code>文档</a>来探索更深入的例子和重要主题，比如<a href="https://rustwasm.github.io/docs/wasm-bindgen/reference/arbitrary-data-with-serde.html" target="_blank" rel="noopener noreferrer">在JavaScript和Rust </a>之间传输任意数据。</p>
<p>请记住，Rust WebAssembly生态系统仍在发展，而且只会越来越好。</p><div class="code-block code-block-29">
<div class="blog-plug inline-plug rust-plug"><h2><a href="https://lp.logrocket.com/blg/rust-signup" target="_blank">log rocket</a>:Rust应用的web前端的全面可见性</h2><p>调试Rust应用程序可能很困难，尤其是当用户遇到难以重现的问题时。如果您对监控和跟踪Rust应用程序的性能、自动显示错误、跟踪缓慢的网络请求和加载时间感兴趣，</p><a href="https://lp.logrocket.com/blg/rust-signup" target="_blank">try LogRocket</a><p>. </p><a class="signup" href="https://lp.logrocket.com/blg/rust-signup" target="_blank" rel="noopener noreferrer"><img class="alignnone size-full wp-image-46 jetpack-lazy-image" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/><noscript><img data-lazy-fallback="1" class="alignnone size-full wp-image-46" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/></noscript></a><p>LogRocket 就像是网络和移动应用程序的DVR，记录你的Rust应用程序上发生的一切。您可以汇总并报告问题发生时应用程序的状态，而不是猜测问题发生的原因。LogRocket还可以监控应用的性能，报告客户端CPU负载、客户端内存使用等指标。</p><p>现代化调试Rust应用的方式— <a class="signup" href="https://lp.logrocket.com/blg/rust-signup" target="_blank" rel="noopener noreferrer">开始免费监控</a>。</p></div>


</div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
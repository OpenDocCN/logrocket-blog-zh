<html>
<head>
<title>What's new in Chrome 78 - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>Chrome 78 - LogRocket博客有什么新内容</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/whats-new-in-chrome-78/#0001-01-01">https://blog.logrocket.com/whats-new-in-chrome-78/#0001-01-01</a></blockquote><div><article class="article-post">
<p>Chrome 78稳定版将于2019年10月22日发布。很少有用户会注意到这些变化，但是对于web开发人员来说，有一些令人兴奋的新特性…</p>
<h2>CSS不透明度百分比</h2>
<p>opacity属性当前接受0(完全透明)和1(完全不透明)之间的值。Chrome 78还允许从0%到100%的百分比:</p>
<pre>/* identical styles */
.style1 { opactity: 0.75; }
.style2 { opacity: 75%; }</pre>
<p>这给CSS带来了一些急需的一致性，因为rgba()函数已经接受了一个百分比，例如<code>rgba(100, 150, 200, 75%)</code>。</p>
<p>百分比也可以用于SVG属性stop-opacity、fill-opacity、stroke-opacity和shape-image-threshold中设置的不透明度。</p>
<h2>JavaScript可选链接</h2>
<p>可选链接是一个<a href="https://tc39.es/proposal-optional-chaining/" target="_blank" rel="noopener noreferrer"> ES2019提案</a>，它将为您节省数小时的键入和调试工作！假设您需要分析一个用户对象，该对象是在Ajax请求REST API调用后返回的:</p>
<pre>let user = {
  firstname: 'Imaginary',
  lastname: 'Person',
  address: {
    street1: '123 Madeup Street',
    street2: '',
    city: 'Nowhereville',
    country: 'Antarctica'
  }
};

// output "Antarctica"
console.log( user.address.country );</pre>
<p>如果没有设置国家值会怎样？JavaScript将返回undefined。</p>
<p>不幸的是，如果没有定义地址或用户对象，情况会更糟——代码会引发一个错误，并阻止进一步的JavaScript代码运行。</p>
<p>因此，您的代码必须检查每个父属性是否存在:</p>
<pre>let country = (user &amp;&amp; user.address &amp;&amp; user.address.country) || undefined;</pre>
<p>或者更可怕的:</p>
<pre>let country =
  (user ?
    (user.address ?
    (user.address.country ?
          user.address.country : undefined
    ) :
      undefined
    ) :
    undefined
  );</pre>
<p>Chrome 78中的可选链接允许更简洁的链接操作符:</p>
<pre>let country = user?.address?.country;</pre>
<p>如果任何值为falsy (null、undefined等), JavaScript不会抛出错误，而是将country变量设置为undefined。)可以附加更多的方法而没有失败的风险:</p>
<pre>let countryLength = user?.address?.country?.length;</pre>
<p>虽然可选链接非常有用，但目前没有其他浏览器或Node.js支持这种语法。巴别塔插件将是必要的，直到支持变得更加广泛。</p>
<h2>国际化API更新</h2>
<p>Intl对象提供特定于地区的字符串比较、数字格式、日期和时间格式，这在全球市场运营时特别有用。该API具有跨浏览器的合理支持，并慢慢出现在Node.js中。</p>
<pre>// set date to 31 December 2020
let date = new Date(2020, 11, 31);

// outputs US date format - 12/31/2020
console.log( new Intl.DateTimeFormat('en-US').format(date) );

// outputs UK date format - 31/12/2020
console.log( new Intl.DateTimeFormat('en-GB').format(date) );

// set number
let num = 12345.67;

// output US number format - 12,345.67
console.log( new Intl.NumberFormat('en-US').format(number) );

// output German number format - 12.345,67
console.log( new Intl.NumberFormat('de-DE').format(number) );</pre>
<p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat" target="_blank" rel="noopener noreferrer"> DateTimeFormat </a>和<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/NumberFormat" target="_blank" rel="noopener noreferrer"> NumberFormat </a>接受可选的options对象作为第二个参数。Chrome 78为使用两个或更多日历或编号系统的地区添加了<code>calendar</code>和<code>numberingSystem</code>选项。</p>
<h2>深色图案限制</h2>
<p>当用户离开页面时，触发<a href="https://developer.mozilla.org/en-US/docs/Web/API/Window/unload_event" target="_blank" rel="noopener noreferrer">窗口卸载</a>事件:</p>
<pre>window.addEventListener('unload', () =&gt; {
  // do something when the user leaves the page
});</pre>
<p>类似的事件可以登记为:</p>
<ul>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/API/Window/beforeunload_event" target="_blank" rel="noopener noreferrer">before unload</a>–文档可见，即将被卸载，但事件仍可被取消</li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/API/Window/pagehide_event" target="_blank" rel="noopener noreferrer">页面隐藏</a>–浏览器正在导航至会话历史中的不同页面，例如，点击了后退按钮</li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/API/Document/visibilitychange_event" target="_blank" rel="noopener noreferrer">可见性变化</a>–用户切换到当前标签页或从当前标签页切换</li>
</ul>
<p>通常，这些事件可用于检查已保存的数据或记录使用分析。</p>
<p>不幸的是，一些不太尽责的开发人员会添加代码来损害用户体验。从版本78开始，Chrome将不允许:</p>
<ol>
<li>同步Ajax请求——这可以在<code>AllowSyncXHRInPageDismissal</code>策略标志中被覆盖，但是在82版中该标志也将被删除</li>
<li>使用<code>window.open()</code>生成弹出窗口–弹出窗口拦截器通常会阻止这种情况，但现在即使拦截器处于非活动状态，它也会被禁止</li>
</ol>
<h2>独立滚动偏移</h2>
<p>在Chrome 78之前，<a href="https://developer.mozilla.org/en-US/docs/Web/API/Window/scrollTo" target="_blank" rel="noopener noreferrer"> window.scrollTo() </a>方法和滚动属性如<a href="https://developer.mozilla.org/en-US/docs/Web/API/Element/scrollTop" target="_blank" rel="noopener noreferrer"> scrollTop </a>和<a href="https://developer.mozilla.org/en-US/docs/Web/API/Element/scrollLeft" target="_blank" rel="noopener noreferrer"> scrollLeft </a>会计算最近的物理像素。例如，在双像素密度设备(devicePixelRatio为2)上，<code>window.scrollTo</code> (0，123.678)和<code>window.scrollTop</code>将等于123.5。</p>
<p>从Chrome 78开始，不管物理像素是多少，都会返回实际传递的值(123.678)。这应该有助于防止滚动计算问题，尤其是当页面被缩放时。</p>
<h2>用户定时级别3</h2>
<p>用户计时API允许开发人员通过创建自定义时间戳来测量应用程序性能。命名性能标记是在整个代码的关键点创建的，例如</p>
<pre>performance.mark('markstart');
// ...processing...
performance.mark('markend');</pre>
<p>然后，性能测量可以报告两个标记之间的持续时间，例如</p>
<pre>performance.measure('m1', 'markstart', 'markend');
performance.getEntriesByName('m1');

/*
Returns something like:
(1) [...]
  0: PerformanceMeasure
     duration: 5153
     entryType: "measure"
     name: "m1"
     startTime: 7314
*/</pre>
<p>第3级允许开发人员将自定义时间戳和任意元数据传递给性能标记和测量方法。</p>
<h2>付款API更新</h2>
<p><a href="https://developer.mozilla.org/en-US/docs/Web/API/Payment_Request_API" target="_blank" rel="noopener noreferrer">支付请求API </a>旨在为商家和客户提供一致且安全的在线交易体验。它允许用户选择他们喜欢的支付选项，并传递到电子商务网站。</p>
<p>Chrome 78引入了几个新选项:</p>
<ul>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/API/PaymentRequest" target="_blank" rel="noopener noreferrer"> PaymentRequest </a>对象的<a href="https://gist.github.com/rsolomakhin/d6d242cbb9306864ada5a29de7ab271e" target="_blank" rel="noopener noreferrer"> hasEnrolledInstrument() </a>方法检查自动填写的支付数据，以确保其有效且完整。例如，它不允许选择过期的信用卡</li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/API/PaymentResponse" target="_blank" rel="noopener noreferrer"> PaymentResponse </a>对象的<a href="https://developer.mozilla.org/en-US/docs/Web/API/PaymentResponse/retry" target="_blank" rel="noopener noreferrer"> retry() </a>方法允许客户在出现处理错误时重试支付</li>
<li>payment request<a href="https://developer.mozilla.org/en-US/docs/Web/API/PaymentRequest/shippingaddresschange_event" target="_blank" rel="noopener noreferrer">shipping address change</a>事件将送货地址发送给商家，以便计算送货成本、税费等。由于买家尚未承诺购买，他们的地址被编辑以删除收件人姓名、组织、完整地址和电话号码，这些都是运输计算不需要的</li>
</ul>
<h2>WebSocketStream</h2>
<p><a href="https://developer.mozilla.org/en-US/docs/Web/API/WebSocket" target="_blank" rel="noopener noreferrer"> WebSocket API </a>在浏览器和服务器之间创建一个双向通信通道。这两种设备都可以在任何时候发送消息，因此该技术经常用于聊天室、多人游戏和实时数据更新。</p>
<p>不幸的是，消息到达的速度可能超过浏览器的处理能力。在这些情况下，内存缓冲区可能会溢出，或者CPU使用率会增加到浏览器无法响应的程度。</p>
<p>WebSocketStream取代了WebSocket API。它是基于承诺的，并集成了流，因此在收到完整消息之前可以解析大块数据。</p>
<p>该API是新的、实验性的，在成为W3C标准之前可能会有所发展或被放弃。更多信息，请参考<a href="https://github.com/ricea/websocketstream-explainer/blob/master/README.md" target="_blank" rel="noopener noreferrer"> WebSocketStream解释</a>。</p>
<h2>媒体元素seekto事件</h2>
<p>HTML音频和视频媒体元素记录许多事件，例如:</p>
<ul>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement/play_event" target="_blank" rel="noopener noreferrer">播放</a>–当视频自动启动或暂停后恢复播放时触发</li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement/timeupdate_event" target="_blank" rel="noopener noreferrer">时间更新</a>–播放时间已经改变</li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement/volumechange_event" target="_blank" rel="noopener noreferrer">音量改变</a>–音量已被改变</li>
</ul>
<p>Chrome 78引入了一个新的seekto动作处理程序，当回放移动到时间轴上的特定点时会调用该处理程序。这可以用来改变DOM，记录分析等。在撰写本文时，其他浏览器中没有任何文档或支持。</p>
<h2>屏幕枚举API</h2>
<p>屏幕枚举API提供关于连接到用户设备的所有显示器的信息。它通常在应用程序可以使用多个监视器的情况下非常有用，例如提供面向公众的幻灯片和演讲者注释显示的演示文稿。</p>
<p>目前没有可用的文档，但它将与新的<a href="https://github.com/spark008/window-placement/blob/master/EXPLAINER.md">窗口放置API </a>结合使用。</p>
<h2>本地文件系统API</h2>
<p><a href="https://developers.google.com/web/updates/2019/08/native-file-system" target="_blank" rel="noopener noreferrer">本地文件系统API </a>允许浏览器直接与用户本地设备上选择的文件进行交互。它可以用来从客户端JavaScript编辑照片、视频或文本文档，而不需要上传和下载过程。</p>
<p>Chrome 78提供了一个早期版本的API供试用，开发者必须从谷歌注册一个令牌才能使用。</p>
<h2>SMS接收器API</h2>
<p>SMS文本消息通常用于验证电话号码或发送一次性密码(OTP)代码。原生智能手机应用程序可以拦截、读取和回应这些信息，但web应用程序用户被迫手动复制/粘贴或重新输入信息。</p>
<p>新的<a href="https://github.com/samuelgoto/sms-receiver" target="_blank" rel="noopener noreferrer"> SMS接收器API </a>允许网络应用使用特定的格式约定读取发送给它们的SMS消息，以避免手动用户交互，例如</p>
<pre>Your OTP is: 123ABC
For: https://example.com/verify?otp=123ABC&amp;hash=9B3FF1C2</pre>
<p>检索JavaScript:</p>
<pre>if (navigator.sms) {

  try {
    let { content } = await navigator.sms.receive();
    console.log('SMS text:', content);
  } catch (e) {
    console.log('error', e);
  }

}</pre>
<h2>杂项更新</h2>
<p>如果您想了解更多，还可以使用一些次要的和实验性的功能:</p>
<ol>
<li>   <ol>
<li>输入和文本区域<a href="https://developer.mozilla.org/en-US/docs/Web/CSS/::placeholder" target="_blank" rel="noopener noreferrer">::占位符</a>文本的默认颜色已从#757575更改为rgba(0，0，0，0.54)</li>
<li>使用<a href="https://developer.mozilla.org/en-US/docs/Web/API/WorkerGlobalScope/importScripts" target="_blank" rel="noopener noreferrer"> importScripts() </a>导入的服务工作者脚本现在可以检查更新，即使主服务工作者脚本没有被修改</li>
<li>可以从JavaScript调用一个<a href="https://developer.mozilla.org/en-US/docs/Web/API/CSS/RegisterProperty" target="_blank" rel="noopener noreferrer"> registerProperty() </a>函数来注册类型化和可动画化的自定义CSS属性(新Houdini API的一部分)</li>
<li><a href="https://github.com/WebAssembly/reference-types/blob/master/proposals/reference-types/Overview.md" target="_blank" rel="noopener noreferrer"> WebAssembly模块可以保存对JavaScript和DOM对象的引用</a>。它们可以作为参数传递，存储在局部变量、全局变量或<code>WebAssembly.Table</code>对象中</li>
<li>新的<a href="https://github.com/WICG/webhid/blob/master/EXPLAINER.md" target="_blank" rel="noopener noreferrer"> WebHID(人机界面设备)API </a>支持除键盘、鼠标、触摸屏和游戏手柄之外的输入和输出设备。本质上，它允许在JavaScript中实现低级的特定于设备的逻辑，而不依赖于浏览器支持</li>
<li>XSS审计员已被撤职</li>
</ol>
</li>
</ol>
<h2>这里有龙！</h2>
<p>令人鼓舞的是，尽管Chrome浏览器占据垄断性的市场份额，但它仍在不断创新。</p>
<p>虽然很容易让人一头扎进去，但许多新功能都是实验性的，可能会彻底改变、消失，或者永远不会在其他浏览器中实现。实验是健康的，但要警惕把你的声誉赌在谷歌的突发奇想上！</p>
<p> </p><div class="code-block code-block-2">
<div class="blog-plug base-cta"><h2>使用<a class="signup" href="https://lp.logrocket.com/blg/signup" target="_blank" rel="noopener noreferrer"> LogRocket </a>消除传统错误报告的干扰</h2>
<a href="https://lp.logrocket.com/blg/signup" class="signup" target="_blank" rel="noopener noreferrer"><img class="alignnone size-full wp-image-46 jetpack-lazy-image" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/><noscript><img data-lazy-fallback="1" class="alignnone size-full wp-image-46" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/></noscript></a>
<p><a href="https://lp.logrocket.com/blg/signup" target="_blank" rel="noopener noreferrer"> LogRocket </a>是一个数字体验分析解决方案，它可以保护您免受数百个假阳性错误警报的影响，只针对几个真正重要的项目。LogRocket会告诉您应用程序中实际影响用户的最具影响力的bug和UX问题。</p>
<p>然后，使用具有深层技术遥测的会话重放来确切地查看用户看到了什么以及是什么导致了问题，就像你在他们身后看一样。</p>
<p>LogRocket自动聚合客户端错误、JS异常、前端性能指标和用户交互。然后LogRocket使用机器学习来告诉你哪些问题正在影响大多数用户，并提供你需要修复它的上下文。</p>
<p>关注重要的bug—<a class="signup" href="https://lp.logrocket.com/blg/signup-issue-free" target="_blank" rel="noopener noreferrer">今天就试试LogRocket】。</a></p></div></div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
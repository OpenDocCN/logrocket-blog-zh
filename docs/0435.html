<html>
<head>
<title>Understanding common frustrations with React Hooks - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>了解React Hooks的常见问题</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/understanding-common-frustrations-react-hooks/#0001-01-01">https://blog.logrocket.com/understanding-common-frustrations-react-hooks/#0001-01-01</a></blockquote><div><article class="article-post">
<p><strong> <em>编者按</em> </strong> : <em>这篇React Hooks的文章最后一次更新是在2022年8月4日，包括了一个关于React Hooks中常见错误消息的部分。</em></p>
<p>React Hooks于2019年2月通过v16.8推出。尽管他们的目标是允许用户使用状态和其他React特性而无需编写类。虽然这一开始看起来令人兴奋，但随之而来的还有一些挫折和陷阱。</p>
<p>在本文中，我们将回顾React钩子的常见问题。我们将讨论React Hooks想要解决的问题，类组件有什么问题，以及在React Hooks中可能看到的常见错误消息和如何解决它们。我们开始吧！</p>

<h2 id="problems-react-hooks-solve">React钩子解决什么问题？</h2>
<p>在我详述我对React Hooks的失望之前，我想声明一下，在很大程度上，我是React Hooks的粉丝。</p>
<p>经常听说钩子存在的主要原因是为了替换类组件。可悲的是，React官方网站的主标题<a href="https://reactjs.org/docs/hooks-intro.html" target="_blank" rel="noopener">介绍钩子</a>用这样一个不那么大胆的声明来贬低钩子:</p>
<blockquote><p>钩子是React 16.8中的新增功能。它们允许您使用状态和其他React特性，而无需编写类。</p></blockquote>
<p>这个解释并没有给我很多使用React钩子的动力，除了“类并不酷，伙计！""</p>
<p>在我看来，React钩子允许我们以一种比以前的模式更优雅的方式解决横切关注点，比如<a href="https://reactjs.org/blog/2016/07/13/mixins-considered-harmful.html" target="_blank" rel="noopener">混合</a>、<a href="https://reactjs.org/docs/higher-order-components.html" target="_blank" rel="noopener">高阶组件</a>和<a href="https://reactjs.org/docs/render-props.html" target="_blank" rel="noopener">渲染道具</a>。日志和认证等功能不是特定于组件的，React挂钩允许我们将这种可重用的行为附加到组件上。</p>
<h2 id="what-wrong-class-components">类组件有什么问题？</h2>
<p>无状态组件接受一些道具并返回一个React元素，这个概念有一些美丽而纯粹的东西。这是一个纯粹的功能，因此，副作用免费。</p>
<pre class="language-javascript hljs">export const Heading: React.FC = ({ level, className, tabIndex, children, ...rest }) =&gt; {
  const Tag = `h${level}` as Taggable;

  return (

      {children}

  );
};
</pre>
<p>不幸的是，副作用的缺乏使得这些无状态组件有点受限，最终，某处的某些东西必须操纵状态。如果组件需要在渲染周期之间保持状态，类组件是唯一的选择。这些类组件通常被称为容器组件，它们执行副作用并将道具传递给这些纯粹的无状态组件函数。</p>
<p>对于基于<a href="https://blog.logrocket.com/react-lifecycle-methods-tutorial-examples/" target="_blank" rel="noopener">类的生命周期事件</a>，有几个被很好记录的问题。最大的抱怨之一就是你经常要在<code>componentDidMount</code>和<code>componentDidUpdate</code>中重复逻辑。</p>
<pre class="language-javascript hljs">async componentDidMount() {
  const response = await get(`/users`);
  this.setState({ users: response.data });
};

async componentDidUpdate(prevProps) {
  if (prevProps.resource !== this.props.resource) {
    const response = await get(`/users`);
    this.setState({ users: response.data });
  }
};
</pre>
<p>如果您使用React有一段时间，您将会遇到这个问题。</p>
<p>有了React钩子，可以在一个地方使用<a href="https://reactjs.org/docs/hooks-effect.html" target="_blank" rel="noopener">效果钩子</a>处理这个副作用代码。</p>
<pre class="language-javascript hljs">const UsersContainer: React.FC = () =&gt; {
  const [ users, setUsers ] = useState([]);
  const [ showDetails, setShowDetails ] = useState(false);

 const fetchUsers = async () =&gt; {
   const response = await get('/users');
   setUsers(response.data);
 };

 useEffect( () =&gt; {
    fetchUsers(users)
  }, [ users ]
 );

 // etc.
</pre>
<p>挂钩是一个相当大的改进，但是这与我们以前拥有的纯无状态函数相比是一个很大的进步。这让我第一次感到沮丧。</p>
<h2 id="yet-another-javascript-paradigm-learn">又一个需要学习的JavaScript范例</h2>
<p>声明一下，我是一个50岁的React粉丝。在用疯狂的观察者和计算属性完成一个<a href="https://emberjs.com/" target="_blank" rel="noopener"> ember </a>应用程序后，单向数据流将永远在我心中占有一席之地。</p>
<p><code>useEffect</code>和friends的问题在于，它在JavaScript领域的其他地方都不存在。它是不寻常的，有怪癖，对我来说，精通并消除这些怪癖的唯一方法是在现实世界中使用它，并经历一些痛苦。</p>
<p>没有使用计数器的教程能让我进入心流。我是一名自由职业者，除了React之外，我还使用其他框架，这让我感到疲劳。事实上，我需要设置<code><a href="https://www.npmjs.com/package/eslint-plugin-react-hooks" target="_blank" rel="noopener">eslint-plugin-react-hooks</a></code>来保持我在这个特定范例中的正直和狭隘，这让我感到有点警惕。</p>
<h2 id="hell-back-dependencies-array">去地狱，带着依赖数组回来</h2>
<p><a href="https://reactjs.org/docs/hooks-effect.html" target="_blank" rel="noopener"> <code>useEffect</code> </a>钩子可以接受一个可选的第二个参数，称为dependencies数组，它允许您优化React何时执行效果回调。React将通过<code><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is" target="_blank" rel="noopener">Object.is</a></code>对每个值进行比较，以确定是否有任何变化。如果任何元素与上一个渲染周期不同，那么效果将根据新值运行。</p>
<p>这种比较适用于原始的JavaScript类型，但是如果其中一个元素是对象或数组，就会出现问题。<code>Object.is</code>将通过引用来比较对象和数组，没有办法覆盖这个功能并提供一个自定义的比较器。</p>
<p>通过引用检查对象或函数的相等性是一个常见的陷阱，我可以用下面我遇到的一个问题的简化版本来说明这一点:</p>
<pre class="language-javascript hljs">const useFetch = (config: ApiOptions) =&gt; { 
 const [data, setData] = useState(null);

 useEffect(() =&gt; {
    const { url, skip, take } = config;
    const resource = `${url}?$skip=${skip}&amp;amp;take=${take}`;
    axios({ url: resource }).then(response =&gt; setData(response.data));
  }, [config]); // &lt;-- will fetch on each render

  return data;
};

const App: React.FC = () =&gt; {
  const data = useFetch({ url: "/users", take: 10, skip: 0 });
  return &lt;div&gt;{data.map(d =&gt; &lt;div&gt;{d})}&lt;/div&gt;;
};
</pre>
<p>在第14行，如果我们不做些什么来确保每次都使用相同的对象，那么在每次渲染时都会有一个新的对象被传递到<code>useFetch</code>中。在这种情况下，最好检查该对象的字段，而不是对象引用。</p>
<p>我确实理解为什么React没有走深入对象比较的道路。如果不小心，您可能会遇到一些严重的性能问题。我似乎经常重新考虑这个问题，并且有许多针对这个问题的修复。您的对象越动态，您开始添加的工作区就越多。</p>
<p>有一个<a href="https://github.com/facebook/react/tree/master/packages/eslint-plugin-react-hooks" target="_blank" rel="noopener"> ESLint插件</a>，你真的应该在你选择的文本编辑器中使用<a href="https://oprea.rocks/blog/automatically-fix-eslint-code-validation-errors-in-visual-studio-code/" target="_blank" rel="noopener">自动修复设置</a>来自动应用ESLint修复。我确实担心任何需要外部插件来检查正确性的新特性。</p>
<p>事实上，<code><a href="https://github.com/kentcdodds/use-deep-compare-effect" target="_blank" rel="noopener">use-deep-object-compare</a></code>、<code><a href="https://github.com/alexreardon/use-memo-one" target="_blank" rel="noopener">use-memo-one</a></code>和其他的存在证明了这是一个足够普遍的问题，或者至少是一个困惑点。</p>
<h2 id="react-relies-order-hooks-called">React依赖于钩子被调用的顺序</h2>
<p>第一批上架的定制React钩子是几个使用钩子查询远程API的<code>useFetch</code>实现。大多数都回避了从事件处理程序调用远程API的问题，因为钩子只能从功能组件的开始处调用。</p>
<p>如果我们拥有的数据有分页链接，我们想在用户点击链接时重新运行效果，该怎么办？下面是一个简单的<code>useFetch</code>例子:</p>
<pre class="language-javascript hljs">const useFetch = (config: ApiOptions): [User[], boolean] =&gt; {
  const [data, setData] = useState&lt;User[]&gt;([]);
  const [loading, setLoading] = useState(true);

  useEffect(() =&gt; {
    const { skip, take } = config;

    api({ skip, take }).then(response =&gt; {
      setData(response);
      setLoading(false);
    });
  }, [config]);

  return [data, loading];
};

const App: React.FC = () =&gt; {
  const [currentPage, setCurrentPage] = useState&lt;ApiOptions&gt;({
    take: 10,
    skip: 0
  });

  const [users, loading] = useFetch(currentPage);

  if (loading) {
    return &lt;div&gt;loading....&lt;/div&gt;;
  }

  return (
    &lt;&gt;
      {users.map((u: User) =&gt; (
        &lt;div&gt;{u.name}&lt;/div&gt;
      ))}
      &lt;ul&gt;
        {[...Array(4).keys()].map((n: number) =&gt; (
          &lt;li&gt;
            &lt;button onClick={() =&gt; console.log('what do we do now?')}&gt;{n + 1}&lt;/button&gt;
          &lt;/li&gt;
        ))}
      &lt;/ul&gt;
    &lt;/&gt;
  );
};
</pre>
<p>第一次渲染时会调用一次<code>useFetch</code>钩子，代码如下:</p>
<pre class="language-javascript hljs">  &lt;ul&gt;
    {[...Array(4).keys()].map((n: number) =&gt; (
      &lt;li&gt;
        &lt;button onClick={() =&gt; console.log('what do we do now?')}&gt;{n + 1}&lt;/button&gt;
      &lt;/li&gt;
    ))}
  &lt;/ul&gt;
</pre>
<p>但是我们如何从这些按钮的事件处理程序中调用<code>useFetch</code>钩子呢？</p>
<p>React挂钩的规则明确规定:</p>
<blockquote><p>不要在循环、条件或嵌套函数中调用钩子。相反，总是在React函数的顶层使用钩子。</p></blockquote>
<p>每次组件渲染时，React挂钩都需要以相同的顺序调用。<a href="https://overreacted.io/why-do-hooks-rely-on-call-order/" target="_blank" rel="noopener">反应过度</a>漂亮地阐明了为什么会这样的几个原因。</p>
<p>你绝对不能这么做:</p>
<pre class="language-javascript hljs">&lt;button onClick={() =&gt; useFetch({ skip: n + 1 * 10, take: 10 })}&gt;
  {n + 1}
&lt;/button&gt;
</pre>
<p>从事件处理程序调用<code>useFetch</code>钩子会破坏钩子的规则，因为你会破坏钩子在每次渲染时被调用的顺序。</p>
<h2 id="return-executable-function-hook">从钩子返回一个可执行函数</h2>
<p>许多钩子现在返回一个可以从顶级声明外部调用的函数。React挂钩的规则仍然有效，对<code>/api/user/1</code>的调用可以从事件处理程序中触发。</p>
<p>下面的代码来自我写的一个名为<code><a href="https://github.com/dagda1/cuttingedge/tree/main/packages/react-abortable-fetch" target="_blank" rel="noopener">react-abortable-fetch</a></code>的包:</p>
<pre class="language-javascript hljs">const { run, state } = useFetch(`/api/users/1`, { executeOnMount: false });
return (
  &lt;button
    disabled={state !== 'READY'}
    onClick={() =&gt; {
      run();
    }}
  &gt;
    DO IT
  &lt;/button&gt;
);
</pre>
<p>调用<code>useFetch</code>返回一个带有状态属性和<code>run</code>函数的对象。<code>run</code>函数将实际执行远程查询。</p>
<h2 id="common-error-messages-react-hooks">React挂钩中的常见错误消息</h2>
<p>React钩子经常抛出一些令人沮丧的错误。让我们回顾一下React钩子中的一些常见错误信息，并讨论它们为什么会出现。</p>
<h3 id="react-hook-cannot-called-inside-callback">"在回调中不能调用React挂钩"</h3>
<p>当在嵌套函数中调用React挂钩时，会出现此错误。让我们看一个例子:</p>
<pre class="language-javascript hljs">import React, { useState } from "react";

export const WithCounter = (WrappedComponent) =&gt; {
  return (props) =&gt; {
    const [count, setCount] = useState(0);
    const increment = () =&gt; setCount((count) =&gt; count + 1);
    return &lt;WrappedComponent count={count} increment={increment} {...props} /&gt;;
  };
};

const ClickCounter = (props) =&gt; {
  return &lt;button onClick={props.increment}&gt;clicked {props.count} times&lt;/button&gt;;
};

export default function App() {
  const Comp = WithCounter(ClickCounter);
  return (
    &lt;div className="App"&gt;
      &lt;Comp /&gt;
    &lt;/div&gt;
  );
}
</pre>
<p>看到我们有一个高阶计算<code>WithCounter</code>。在它的回调函数中，注意我们使用了<code>useState</code>钩子。这不符合React Hook的规则。</p><div class="code-block code-block-54">
<hr/>
<h3>更多来自LogRocket的精彩文章:</h3>

<hr/></div>
<p>上面的代码会抛出<code>React Hook "useState" cannot be called inside a callback. React Hooks must be called in a React function component or a custom React Hook function. </code>错误。在第5行，<code>const [count, setCount] = useState(0);</code>，我们在那里调用React <code>useState</code>钩子。即使该函数被用作<code>App</code>组件中的组件，React也会将该组件视为回调函数。</p>
<p>不应在嵌套函数中调用React挂钩</p>
<h3 id="react-hooks-must-called-react-function-component-custom-react-hook-function">"必须在React函数组件或自定义React挂钩函数中调用React挂钩"</h3>
<p>这个错误类似于我们刚刚了解到的上面的错误。React挂钩必须在React函数组件或自定义React挂钩内调用。</p>
<p>假设我们有一个React组件，<code>App</code>:</p>
<pre class="language-javascript hljs">function App() {}
</pre>
<p>我们可以在这里调用任何React挂钩或自定义挂钩:</p>
<pre class="language-javascript hljs">function App() {
  const [counter, setCounter] = useState(0);
}
</pre>
<p>我们刚刚在<code>App</code>组件中调用了一个<code>useState</code>钩子。这符合React的钩子法则。但是现在，让我们假设我们在<code>App</code>组件中有一个函数是这样的:</p>
<pre class="language-javascript hljs">function App() {
  const counterFn = () =&gt; {
    const [counter, setCounter] = useState(0);
    setCounter(counter++)
  }

  return (
    &lt;&gt;
      &lt;div&gt;
        &lt;button onClick={counterFn}&gt;Incr Counter&lt;/button&gt;
      &lt;/div&gt;
    &lt;/&gt;
  )
}
</pre>
<p>这不是使用React钩子的好方法。请注意，我们正在函数内部调用<code>useState</code>。这会抛出错误:<code>React hooks must be called in a React function component or a custom React hook function</code>。这是因为<code>onClick</code>功能处理器<code>counterFn</code>不是功能组件。</p>
<p>我们可以在自定义的React钩子内部调用React钩子。现在，React知道一个函数是一个名字以<code>use</code>开头的钩子，可能会调用其他React钩子。</p>
<p>让我们看一个例子:</p>
<pre class="language-javascript hljs">function useCounter() {
  let counter = 0
  const setCounter = () =&gt; {
    counter++
  }
  return { counter, setCounter }
}
</pre>
<p>上面的函数是一个自定义的React钩子，因为它的名字以<code>use</code>开头。</p>
<pre class="language-javascript hljs">function useCounter() {
  const [counter, setCounter] = useState(0)
  return { counter, setCounter }
}
</pre>
<p>这也是一个自定义的React挂钩。它不仅名字以<code>use</code>开头，而且调用React <code>useState</code>钩子。由于<code>useCounter</code>是一个函数而不是一个React功能组件，在其中调用React钩子是可行的。在这种情况下，React不会给我们<code>React hooks must be called in a React function component or a custom React hook function</code>错误。</p>
<h3 id="react-hook-use-effect-missing-dependency">" React挂钩<code>useEffect</code>缺少依赖项"</h3>
<p>如果我们没有向<code>useEffect</code>钩子依赖数组添加必要的依赖，就会出现这个错误。让我们看一个例子:</p>
<pre class="language-javascript hljs">function List(props) {
  const [counter, setCounter] = useState(0);

  useEffect(() =&gt; {
    setCounter(counter)
  }, []);

  return &lt;div&gt;Counter: {counter} &lt;/div&gt;;
}
</pre>
<p>我们这里有一个<code>useEffect</code>。在这种情况下，<code>useEffect</code>将在初始挂载时运行一次，并且不会再次运行。现在，看一下<code>useEffect</code>内部的回调，我们看到它用<code>counter</code>状态作为参数来调用<code>setCounter</code>。</p>
<p>我们可以看到<code>useEffect</code>依赖于<code>counter</code>状态。在这种情况下，React会显示警告:<code>Either include it or remove the dependency array. eslintreact-hooks/exhaustive-deps</code>。</p>
<p>为了避免这个错误，我们需要移除依赖数组或者在依赖数组中包含<code>counter</code>状态。让我们将<code>counter</code>状态包含在<code>useEffect</code>依赖数组中:</p>
<pre class="language-javascript hljs">function List(props) {
  const [counter, setCounter] = useState(0);

  useEffect(() =&gt; {
    setCounter(counter)
  }, [counter]);

  return &lt;div&gt;Counter: {counter} &lt;/div&gt;;
}
</pre>
<p>现在，这将清除我们控制台中的警告。</p>
<h2 id="conclusion">结论</h2>
<p>React钩子有问题，这是无法回避的事实。我一直很喜欢React的声明式方法，在这种方法中，状态会改变，UI会更新。<code>useEffect</code>和friends的依赖数组听起来像是实现这一点的声明性方式。</p>
<p>如果依赖数组只包含原语，那么这很好。不幸的是，当依赖数组中有对象和函数时，问题就出现了。引用检查是JavaScript中对象和函数的比较方式。一个放置不当的箭头函数将导致一个<code>useEffect</code>钩子陷入无限循环。然后，开发人员需要考虑在<code>useCallback</code>、<code>useRef</code>、<code>useMemo</code>等之间做出选择。，想出制胜的公式。</p>
<p>React钩子只能从顶层调用的事实导致了应该在框架层处理的变通办法。</p>
<p>React钩子也迫使你使用闭包，我有很多使用闭包时意外发生的事情留下的伤疤。由于代码在闭包中执行而导致的陈旧状态是Hooks linter要解决的问题之一。</p>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
<html>
<head>
<title>Deno alternatives to popular Node projects - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>流行节点项目的Deno替代方案</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/deno-alternatives-to-popular-node-projects/#0001-01-01">https://blog.logrocket.com/deno-alternatives-to-popular-node-projects/#0001-01-01</a></blockquote><div><article class="article-post">
<p>Deno是一个简单的现代安全运行时，用于使用JavaScript和TypeScript编写应用程序，它使用Rust内置的V8引擎。</p>
<p>这不是一篇解释Deno是什么的文章。但是，如果你需要了解更多关于Deno的信息，我可以提供帮助。查看这篇文章:<a href="https://blog.logrocket.com/what-is-deno/" target="_blank" rel="noopener noreferrer">Deno是什么，和Node.js有什么不同？</a></p>
<p>如果你对未来的发展感兴趣，你也可以看看Deno <a href="https://github.com/denoland/deno" target="_blank" rel="noopener noreferrer">库</a>。</p>
<p>现在，Node在过去几年中变得强大和流行。还出现了一些流行的节点项目，它们被称为依赖项。自从Deno诞生以来，关于如何在Deno中做我们在Node中做的同样的事情，一直有很多疑惑。</p>
<p>我将介绍Node中最受欢迎的几款，并向您展示Deno中的替代产品。</p>
<h2>Next.js/Aleph.js</h2>
<p><a href="https://alephjs.org/docs" target="_blank" rel="noopener noreferrer"> Aleph.js </a>是Deno中的一个React框架。对，就是这样。正如<a href="https://nextjs.org/" target="_blank" rel="noopener noreferrer"> Next.js </a>处于节点。Next.js for Node提供了使用React进行生产所需的所有特性。它允许您构建服务器端呈现、自动代码分割、静态导出选项、简单的生产构建以及静态web应用程序。</p>
<p>与Next.js不同，Aleph.js不使用也不需要捆绑器，因为它使用ESM(ECMAScript模块)导入语法。每个导入的模块只编译一次并缓存:</p>
<pre>import React from "https://esm.sh/<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="acdec9cdcfd8ec9d9b829c829d">[email protected]</a>"
import Logo from "../components/logo.tsx"

export default function Home() {
    return (
      &lt;div&gt;
        &lt;Logo /&gt;
        &lt;h1&gt;Hello World!&lt;/h1&gt;
      &lt;/div&gt;
    )
}
</pre>
<p>Aleph.js提供的其他高级功能有异步导入、自定义<code>404</code>页面、自定义加载页面、<code>useDeno</code>钩子等等。</p>
<h2>Express.js/Opine</h2>
<p>Express.js 因其开放、免费或自由的极简web框架而非常受欢迎。它的理念是为HTTP服务器提供一个小而快速的工具，使其成为spa、网站、混合或公共HTTP APIs的绝佳选择。无论如何，你可以使用Express.js来构建你自己的框架。另一个很棒的地方是它健壮的路由系统，可以有效地响应客户的请求，并且很少选择HTTP助手。</p>
<p>与Express.js不同，<a href="https://github.com/asos-craigmorten/opine/tree/0.25.0/" target="_blank" rel="noopener noreferrer"> Opine </a>专注于高性能、内容协商(当基于一种类型的请求返回响应时，这很棒)、健壮的路由和对HTTP代理中间件的支持(这在授权、负载平衡、日志记录等方面很有用)。指点江山前途光明！</p>
<pre>import opine from "../../mod.ts";

const app = opine();

app.get("/", function (req, res) {
  res.send("Hello Deno!");
});

const server = app.listen();
const address = server.listener.addr as Deno.NetAddr;
console.log(`Server started on ${address.hostname}:${address.port}`);
</pre>
<p>我真的很喜欢Opine处理内容协商的方式，让您一目了然地处理每种格式:</p>
<pre>import { opine } from "../../mod.ts";
import { users } from "./db.ts";
import type { Request, Response } from "../../src/types.ts";

const app = opine();

app.get("/", (req, res) =&gt; {
  res.format({
    html() {
      res.send(
        `&lt;ul&gt;${users.map((user) =&gt; `&lt;li&gt;${user.name}&lt;/li&gt;`).join("")}&lt;/ul&gt;`,
      );
    },

    text() {
      res.send(users.map((user) =&gt; ` - ${user.name}\n`).join(""));
    },

    json() {
      res.json(users);
    },
  });
});
</pre>
<h2>Passport.js/Onyx</h2>
<p>Passport.js 只是帮助处理节点服务器中的认证。它作为一个中间件，非常灵活和模块化。它广泛用于任何基于Express.js的web应用程序。它支持一套认证策略(<a href="http://www.passportjs.org/docs/username-password/" target="_blank" rel="noopener noreferrer">用户名和密码</a>、<a href="http://www.passportjs.org/docs/facebook/" target="_blank" rel="noopener noreferrer">脸书</a>、<a href="http://www.passportjs.org/docs/twitter/" target="_blank" rel="noopener noreferrer"> Twitter </a>等)。</p>
<p>与Passport.js不同，<a href="https://github.com/oslabs-beta/onyx/tree/v1.0.1/" target="_blank" rel="noopener noreferrer"> Onyx </a>的主要目的是保持代码的整洁和系统化。它可以帮助您简化身份验证策略，而无需像在Passport.js中那样进行导入。</p>
<p>就像您将Passport.js作为中间件应用一样，Onyx也是如此:</p>
<pre>import { Router } from '../deps.ts';
import { onyx } from '../deps.ts';
import User from './models/userModels.ts';

const router = new Router();

// invoke onyx.authenticate with the name of the strategy, invoke the result with context
router.post('/login', async (ctx) =&gt; {
  await (await onyx.authenticate('local'))(ctx);

  if (await ctx.state.isAuthenticated()) {
    const { username } = await ctx.state.getUser();
    ctx.response.body = {
      success: true,
      username,
      isAuth: true,
    };
  } else {
    const message = ctx.state.onyx.errorMessage || 'login unsuccessful';
    ctx.response.body = {
      success: false,
      message,
      isAuth: false,
    };
  }
});
</pre>
<p>在服务器文件中设置非常简单。这与您在Node:</p>
<pre>import { Application, send, join, log } from '../deps.ts';
import { Session } from '../deps.ts';

// Import in onyx and setup
import { onyx } from '../deps.ts';
import './onyx-setup.ts';

// Server Middlewares
import router from './routes.ts';

// SSR
import { html, browserBundlePath, js } from './ssrConstants.tsx';

const port: number = Number(Deno.env.get('PORT')) || 4000;
const app: Application = new Application();

// session with Server Memory
// const session = new Session({ framework: 'oak' });

// session with Redis Database
const session = new Session({
  framework: 'oak',
  store: 'redis',
  hostname: '127.0.0.1',
  port: 6379,
});

// Initialize Session
await session.init();
app.use(session.use()(session));

// Initialize onyx after session
app.use(onyx.initialize());
</pre>
<h2>NodeRedis/DenoRedis</h2>
<p>Redis是一种流行的内存数据结构服务器，通常用于缓存、数据库和消息代理。它速度超快，吞吐量惊人。</p>
<p>在Node中，<a href="https://github.com/NodeRedis/node-redis" target="_blank" rel="noopener noreferrer"> node-redis </a>是一个高性能的redis客户端，它是完全异步的。</p>
<p><a href="https://deno.land/x/redis@v0.14.0" target="_blank" rel="noopener noreferrer"> deno-redis </a>是deno的redis客户端的实现:</p>
<pre>import { connect } from "https://deno.land/x/redis/mod.ts";
const redis = await connect({
  hostname: "127.0.0.1",
  port: 6379
});
const ok = await redis.set("hoge", "fuga");
const fuga = await redis.get("hoge");
</pre>
<h2>Nodemon/Denon</h2>
<p><a href="https://github.com/remy/nodemon" target="_blank" rel="noopener noreferrer"> Nodemon </a>是一个命令行界面(CLI ),它监视文件系统中节点项目的任何变化，并自动重启进程/服务器。这有助于避免手动重启服务器来查看已经做出的更改。</p>
<p>在天龙，我们有<a href="https://github.com/denosaurs/denon/tree/2.4.5/" target="_blank" rel="noopener noreferrer">天龙</a>。与nodemon没有区别。你要做的就是把<code>deno</code>换成<code>denon</code>这个词。</p>
<pre>denon run app.ts
</pre>
<h2>WebSocket</h2>
<p>Websocket API开启了客户端和服务器之间的双向交互通信。基本上，在客户机和服务器之间有一个持久的连接，这样双方都可以在任何时候发送数据。<a href="https://github.com/websockets/ws" target="_blank" rel="noopener noreferrer"> ws </a>库是作为节点项目的客户机和服务器实现而构建的。</p>
<p>幸运的是，我们有<a href="https://deno.land/x/websocket@v0.0.5" target="_blank" rel="noopener noreferrer">deno web socket</a>——一个和<a href="https://github.com/websockets/ws" target="_blank" rel="noopener noreferrer"> ws </a>一样的库，但是是Deno的。</p>
<p>服务器端的使用与任何节点项目都非常相似:</p>
<pre>import { WebSocket, WebSocketServer } from "https://deno.land/x/<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="562133342539353d332216206678667863">[email protected]</a>/mod.ts";

const wss = new WebSocketServer(8080);
wss.on("connection", function (ws: WebSocket) {
  ws.on("message", function (message: string) {
    console.log(message);
    ws.send(message)
  });
});
</pre>
<p>客户端也是如此:</p>
<pre><code>import { WebSocket } from "https://deno.land/x/<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="384f5d5a4b575b535d4c784e081608160d">[email protected]</a>/mod.ts";
const endpoint = "ws://127.0.0.1:8080";
const ws: WebSocket = new WebSocket(endpoint);
ws.on("open", function() {
  console.log("ws connected!");
});
ws.on("message", function (message: string) {
  console.log(message);
});
ws.send("something");
</code></pre>
<h2>克-奥二氏分级量表</h2>
<p>接下来我们有<a href="https://github.com/expressjs/cors" target="_blank" rel="noopener noreferrer"> cors </a>，一个作为中间件提供支持的节点包，它可以用来为<a href="https://en.wikipedia.org/wiki/Cross-origin_resource_sharing" target="_blank" rel="noopener noreferrer"> CORS </a>提供各种选项。</p>
<p>在Express.js应用程序中启用所有cors请求的简单用法如下所示:</p>
<pre>var express = require('express')
var cors = require('cors')
var app = express()

app.use(cors())

app.get('/products/:id', function (req, res, next) {
  res.json({msg: 'This is CORS-enabled for all origins!'})
})

app.listen(80, function () {
  console.log('CORS-enabled web server listening on port 80')
})
</pre>
<p>在Deno，我们会在Opine做同样的事情。例如:</p>
<pre>import { opine, serveStatic } from "https://deno.land/x/opine/mod.ts";
import { opineCors } from "../../mod.ts";

const app = opine();

app.use(opineCors()); // Enable CORS for All Routes

app
  .use(serveStatic(`${Deno.cwd()}/examples/opine/static`))
  .get("/products/:id", (_req, res) =&gt; {
    res.json({msg: 'This is CORS-enabled for all origins!'});
  })
  .listen(
    { port: 8000 },
    () =&gt; console.info("CORS-enabled web server listening on port 8000"),
  );
</pre>
<h2 id="bcrypt">Bcrypt/BCrypt</h2>
<p>两者都是用于散列密码的类似库。由Niel Provos设计的Bcrypt是一个密码散列函数，主要用于密码。它的基本功能是从密码中生成一个散列并保存它。</p>
<p>虽然我们已经有了用于Node的<a href="https://github.com/kelektiv/node.bcrypt.js#readme" target="_blank" rel="noopener noreferrer"> Bcrypt </a>，但是我们现在有了用于Deno的<a href="https://deno.land/x/bcrypt@v0.2.4" target="_blank" rel="noopener noreferrer"> BCrypt </a>。Deno中的用法仍然与Node:</p>
<pre>import * as bcrypt from "https://deno.land/x/bcrypt/mod.ts";

const hash = await bcrypt.hash("test");

// To check a password
const result = await bcrypt.compare("test", hash);
</pre>
<h2>电子/网络视图</h2>
<p>在Node中，您可以使用<a href="https://github.com/electron/electron" target="_blank" rel="noopener noreferrer"> Electron </a>创建跨平台的桌面应用程序。在Deno，我们现在有了<a href="https://deno.land/x/webview@0.4.7" target="_blank" rel="noopener noreferrer">网络视图</a>。它还用于为跨平台桌面应用程序创建GUI:</p>
<pre>import { WebView } from "https://deno.land/x/webview/mod.ts";

const html = `
  &lt;html&gt;
  &lt;body&gt;
    &lt;h1&gt;Hello from deno&lt;/h1&gt;
  &lt;/body&gt;
  &lt;/html&gt;
`;

await new WebView({
  title: "Local webview_deno example",
  url: `data:text/html,${encodeURIComponent(html)}`,
  height: 600,
  resizable: true,
  debug: true,
  frameless: false,
}).run();
</pre>
<h2>MongoDB</h2>
<p>MongoDB 是流行的、可伸缩的、灵活的。它是一个基于文档的数据库，在JavaScript生态系统中被广泛使用。</p>
<p>是的，现在有可能在Deno中使用MongoDB:</p>
<pre>import { MongoClient } from "https://deno.land/x/<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="b4d9dbdad3dbf4c2859a849a84">[email protected]</a>/mod.ts";

const client = new MongoClient();
client.connectWithUri("mongodb://localhost:27017");

// Defining schema interface
interface UserSchema {
  _id: { $oid: string };
  username: string;
  password: string;
}

const db = client.database("test");
const users = db.collection&lt;UserSchema&gt;("users");

// insert
const insertId = await users.insertOne({
  username: "user1",
  password: "pass1",
});

// insertMany
const insertIds = await users.insertMany([
  {
    username: "user1",
    password: "pass1",
  },
  {
    username: "user2",
    password: "pass2",
  },
]);

// findOne
const user1 = await users.findOne({ _id: insertId });

// find
const all_users = await users.find({ username: { $ne: null } });

// find by ObjectId
const user1_id = await users.findOne({ _id: "idxxx" });
</pre>
<h2>简单邮件传输协议</h2>
<p>SMTP是Nodemailer中发送邮件的主要传输方式。现在Deno中可用的名称为<a href="https://deno.land/x/smtp@v0.6.0" target="_blank" rel="noopener noreferrer"> Deno SMTP </a>:</p>
<pre>import { SmtpClient } from "https://deno.land/x/smtp/mod.ts";

const client = new SmtpClient();

await client.connect({
  hostname: "smtp.163.com",
  port: 25,
  username: "username",
  password: "password",
});

await client.send({
  from: "<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="731e121a1f12171701160000334245405d101c1e">[email protected]</a>",
  to: "<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="9beff4b6faffffe9fee8e8dbe3e3b5f8f4f6">[email protected]</a>",
  subject: "Mail Title",
  content: "Mail Content，maybe HTML",
});

await client.close();
</pre>
<h2>NPM/Trex</h2>
<p>Node中的npm 是流行的包管理工具，已经存在很长时间了，令人惊叹的是，我们在Deno中用<a href="https://deno.land/x/trex@v1.3.2" target="_blank" rel="noopener noreferrer"> Trex </a>替代了它。它有很多选项，很像npm。不要忘记包是被缓存的，并且只生成一个文件。</p>
<p>有很多这样的Deno替代品，目前仍在开发中。我们还有:</p>
<ul>
<li><a href="https://deno.land/x/dinoenv@v1.0.0" target="_blank" rel="noopener noreferrer">dino env</a>–管理环境变量</li>
<li><a href="https://github.com/eveningkid/denodb" target="_blank" rel="noopener noreferrer">deno db</a>–MySQL、MongoDB、SQLite的ORM</li>
<li><a href="https://github.com/hashrock/deno-fnparse/blob/master/parsers/csv.ts" target="_blank" rel="noopener noreferrer">CSV</a>–CSV解析器</li>
<li><a href="https://github.com/denodrivers/mysql" target="_blank" rel="noopener noreferrer">deno-MySQL</a>–MySQL驱动程序</li>
<li><a href="https://github.com/cacjs/cac" target="_blank" rel="noopener noreferrer">CAC</a>–构建命令行应用程序的框架。</li>
</ul>
<h2>结论</h2>
<p>在本文中，我们讨论了开发过程中使用的流行节点项目的一些Deno替代方案。我们相信Deno仍在增长，如果你想进一步涉足Deno领域，了解当前可用的替代方案将是一件好事。</p>
<p>如果你觉得我跳过了一个流行的节点，你可以把它们作为回复。</p><div class="code-block code-block-23">
<div class="blog-plug inline-plug node-plug"><h2>200只<img src="../Images/61167b9d027ca73ed5aaf59a9ec31267.png" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2019/10/green-check.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" class=" jetpack-lazy-image" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/10/green-check.png"/> <noscript> <img data-lazy-fallback="1" src="../Images/61167b9d027ca73ed5aaf59a9ec31267.png" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/10/green-check.png"/> </noscript>显示器出现故障，生产中网络请求缓慢</h2><p>部署基于节点的web应用程序或网站是容易的部分。确保您的节点实例继续为您的应用程序提供资源是事情变得更加困难的地方。如果您对确保对后端或第三方服务的请求成功感兴趣，</p><a href="https://lp.logrocket.com/blg/node-signup" target="_blank">try LogRocket</a><p>. </p><a class="signup" href="https://lp.logrocket.com/blg/node-signup" target="_blank" rel="noopener noreferrer"><img src="../Images/cae72fd2a54c5f02a6398c4867894844.png" alt="LogRocket Network Request Monitoring" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2019/12/network-request-filter-2-1.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" class=" jetpack-lazy-image" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/12/network-request-filter-2-1.png"/><noscript><img data-lazy-fallback="1" src="../Images/cae72fd2a54c5f02a6398c4867894844.png" alt="LogRocket Network Request Monitoring" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/12/network-request-filter-2-1.png"/></noscript></a><a href="https://lp.logrocket.com/blg/node-signup" target="_blank" rel="noopener noreferrer">https://logrocket.com/signup/</a><p>LogRocket 就像是网络和移动应用程序的DVR，记录下用户与你的应用程序交互时发生的一切。您可以汇总并报告有问题的网络请求，以快速了解根本原因，而不是猜测问题发生的原因。</p><p>LogRocket检测您的应用程序以记录基线性能计时，如页面加载时间、到达第一个字节的时间、慢速网络请求，还记录Redux、NgRx和Vuex操作/状态。</p><a class="signup" href="https://lp.logrocket.com/blg/node-signup" target="_blank" rel="noopener noreferrer">Start monitoring for free</a><p>. </p></div>
</div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
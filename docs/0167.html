<html>
<head>
<title>Using React Transition Group to improve UI - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>使用React转换组改进UI - LogRocket博客</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/react-transition-group/#0001-01-01">https://blog.logrocket.com/react-transition-group/#0001-01-01</a></blockquote><div><article class="article-post">
<p><em> <strong>编者按</strong>:这个React过渡组教程最后一次更新是在2022年9月22日。</em></p>
<p>过渡是创建交互式ui时最常被忽视的原则之一。幸运的是，在过去的几年里，<a href="https://reactjs.org/" target="_blank" rel="noopener"> React </a>和其他以组件为中心的框架已经改变了我们对ui以及如何构建ui的看法。</p>
<p>在本<a href="https://reactcommunity.org/react-transition-group/" target="_blank" rel="noopener"> React过渡组</a>教程中，我们将向您展示如何使用<a href="http://reactcommunity.org/react-transition-group/css-transition" target="_blank" rel="noopener"> <code>CSSTransition</code> </a>和<a href="http://reactcommunity.org/react-transition-group/transition-group" target="_blank" rel="noopener"> <code>TransitionGroup</code> </a>组件，并复习一些简单的<code>react-transition-group</code>示例。</p>
<p>以下是我们将要介绍的内容:</p>

<p>要跟进，您应该:</p>

<h2 id="what-is-react-transition-group">什么是反应过渡族？</h2>
<p><a href="https://www.npmjs.com/package/react-transition-group" target="_blank" rel="noopener"> React Transition Group </a>使您能够以声明性和高效的方式将组件移入和移出DOM，并最大限度地减少对样板代码的需求。</p>
<p>与许多其他<a href="https://blog.logrocket.com/the-top-5-react-animation-libraries-compared/" target="_blank" rel="noopener"> React动画库</a>不同，例如<a href="https://blog.logrocket.com/animations-with-react-spring/" target="_blank" rel="noopener"> React Spring </a>，React Transition Group提供了用于定义动画的简单组件。该库本身并不定义样式，而是以有用的方式操纵DOM，使得过渡和动画的实现更加舒适。</p>
<p>简而言之，React过渡组提供了一种更直接的动画和过渡方法。</p>
<h2 id="installing-react-transition-group">安装<code>react-transition-group</code></h2>
<p>要将React转换组安装到React应用程序中，请在终端中运行以下命令:</p>
<pre class="language-bash hljs"># npm
npm install react-transition-group --save

# yarn
yarn add react-transition-group
</pre>
<p>接下来，我们将详细了解React转换组可用的组件，并查看一些实用的<code>react-transition-group</code>示例。</p>
<h2 id="csstransition-example-transition-react-component-using-css"><code>CSSTransition</code>示例:使用CSS转换一个React组件</h2>
<p><code>CSSTransition</code>组件允许您使用CSS将过渡应用于进入和离开DOM的元素。您可以通过使用以下道具来实现这一点:</p>
<ul>
<li><code>in</code>，用于控制元素外观的布尔值</li>
<li><code>timeout</code>，表示进入或离开DOM所需的毫秒数</li>
<li><code>unmountOnExit</code>，表示当元素消失时，它实际上要完全离开DOM。下面是它的代码片段:</li>
</ul>
<h3 id="list-example-react-transition-group">带有反应转换组的简单列表示例</h3>
<p>考虑以下代码块，分别代表使用<code>CSSTransition</code>前后的组件:</p>
<p>在<code>CSSTransition</code>之前:</p>
<pre class="language-css hljs">import React, { Component } from "react";
import ReactDOM from "react-dom";
import "./styles.css";

class App extends Component {
  state = {
    showList: false
  };
  switch = () =&gt; {
    this.setState(prevState =&gt; ({
      showList: !prevState.showList
    }));
  };
  render() {
    return (
      &lt;div className="container"&gt;
        &lt;button className="display" onClick={this.switch}&gt;
          List
        &lt;/button&gt;
        {this.state.showList &amp;&amp; (
          &lt;div className="menu"&gt;
            &lt;ul className="list"&gt;
              &lt;li className="list-item"&gt;Feed the dog&lt;/li&gt;
              &lt;li className="list-item"&gt;Cut hair&lt;/li&gt;
              &lt;li className="list-item"&gt;Do the dishs&lt;/li&gt;
              &lt;li className="list-item"&gt;Buy grossries&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/div&gt;
        )}
      &lt;/div&gt;
    );
  }
}

export default App;
const rootElement = document.getElementById("root");

ReactDOM.render(&lt;App /&gt;, rootElement);
</pre>
<p>在<code>CSSTransition</code>之后:</p>
<pre class="language-css hljs">import React, { Component } from "react";
import ReactDOM from "react-dom";
import cx from "classnames";
import { CSSTransition } from "react-transition-group";
import "./styles.css";

class App extends Component {
  state = {
    showList: true,
    highlightedHobby: false
  };
  switch = () =&gt; {
    this.setState(prevState =&gt; ({
      showList: !prevState.showList
    }));
  };
  listSwitch = () =&gt; {
    this.setState(state =&gt; ({
      highlightedHobby: !state.highlightedHobby
    }));
  };
  render() {
    return (
      &lt;div className="container"&gt;
        &lt;button className="display" onClick={this.switch}&gt;
          Obinna
        &lt;/button&gt;
        &lt;CSSTransition
          in={this.state.showList}
          timeout={400}
          classNames="list-transition"
          unmountOnExit
          appear
          onEntered={this.listSwitch}
          onExit={this.listSwitch}
        &gt;
          &lt;div className="list-body"&gt;
            &lt;ul className="list"&gt;
              &lt;li
                className={cx("list-item", {
                  "list-item--active": this.state.highlightedHobby
                })}
              &gt;
                Writing JavaScript
              &lt;/li&gt;
              &lt;li className="list-item"&gt; Running&lt;/li&gt;
              &lt;li className="list-item"&gt; Technical Writing&lt;/li&gt;
              &lt;li className="list-item"&gt; Writing Clean code&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/div&gt;
        &lt;/CSSTransition&gt;
      &lt;/div&gt;
    );
  }
}
export default App;
const rootElement = document.getElementById("root");

ReactDOM.render(&lt;App /&gt;, rootElement);
</pre>
<h2 id="creating-transition-using-css-transition">使用<code>CSSTransition</code>创建过渡</h2>
<p>在上面的第一个代码示例中，我们有一个没有过渡的普通组件。只要单击list按钮，就会呈现一个有序列表，没有延迟，也没有额外的CSS样式。</p>
<p>下面是展示结果的GIF图:</p>
<p><img data-attachment-id="133932" data-permalink="https://blog.logrocket.com/react-transition-group/attachment/creating-transition-without-csstransition/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2021/03/creating-transition-without-csstransition.gif" data-orig-size="332,222" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Creating a transition without CSSTransition" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2021/03/creating-transition-without-csstransition-300x201.gif" data-large-file="https://blog.logrocket.com/wp-content/uploads/2021/03/creating-transition-without-csstransition.gif" decoding="async" class="aligncenter size-full wp-image-133932 jetpack-lazy-image" src="../Images/e8610b90c6274d4295ff7b0d8f8a0ca5.png" alt="Creating A Transition Without CSSTransition" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2021/03/creating-transition-without-csstransition.gif?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2021/03/creating-transition-without-csstransition.gif"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="133932" data-permalink="https://blog.logrocket.com/react-transition-group/attachment/creating-transition-without-csstransition/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2021/03/creating-transition-without-csstransition.gif" data-orig-size="332,222" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Creating a transition without CSSTransition" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2021/03/creating-transition-without-csstransition-300x201.gif" data-large-file="https://blog.logrocket.com/wp-content/uploads/2021/03/creating-transition-without-csstransition.gif" decoding="async" loading="lazy" class="aligncenter size-full wp-image-133932" src="../Images/e8610b90c6274d4295ff7b0d8f8a0ca5.png" alt="Creating A Transition Without CSSTransition" data-original-src="https://blog.logrocket.com/wp-content/uploads/2021/03/creating-transition-without-csstransition.gif"/></noscript>
<p>但是当我们决定赋予这个例子更多的生命时，我们在使用<code>&lt;CSSTransition&gt;</code>标签的同时安装<code>react-transition-group</code>，并将<code>this.state.showList</code>中的信息作为道具传递给<code>in</code>，这使我们能够使用CSS添加一些过渡。这就是我们对上面的第二个代码块所做的。</p>
<p>以下是应用<code>CSSTransition</code>后的结果:</p>
<p><img data-attachment-id="133934" data-permalink="https://blog.logrocket.com/react-transition-group/attachment/creating-transition-with-csstransition/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2021/03/creating-transition-with-csstransition.gif" data-orig-size="290,200" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Creating a transition with CSSTransition" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2021/03/creating-transition-with-csstransition.gif" data-large-file="https://blog.logrocket.com/wp-content/uploads/2021/03/creating-transition-with-csstransition.gif" decoding="async" class="aligncenter size-full wp-image-133934 jetpack-lazy-image" src="../Images/4889224c94f590d977a6035439311dbb.png" alt="Creating A Transition With CSSTransition" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2021/03/creating-transition-with-csstransition.gif?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2021/03/creating-transition-with-csstransition.gif"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="133934" data-permalink="https://blog.logrocket.com/react-transition-group/attachment/creating-transition-with-csstransition/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2021/03/creating-transition-with-csstransition.gif" data-orig-size="290,200" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Creating a transition with CSSTransition" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2021/03/creating-transition-with-csstransition.gif" data-large-file="https://blog.logrocket.com/wp-content/uploads/2021/03/creating-transition-with-csstransition.gif" decoding="async" loading="lazy" class="aligncenter size-full wp-image-133934" src="../Images/4889224c94f590d977a6035439311dbb.png" alt="Creating A Transition With CSSTransition" data-original-src="https://blog.logrocket.com/wp-content/uploads/2021/03/creating-transition-with-csstransition.gif"/></noscript>
<p>请注意元素是如何从隐藏状态平稳地过渡到完全显示的。现在让我们详细地看一下代码。</p>
<h3 id="csstransition-timeout-prop"><code>CSSTransition</code>超时道具</h3>
<p>超时属性允许我们在列表离开DOM时应用一个转换。</p>
<pre class="language-css hljs">&lt;CSSTransition  
  timeout={400}
  // other props
&gt;
</pre>
<p>然后我们前往<code>style.css</code>为过渡添加一些样式。<code>CSSTransition</code>给了我们四个键<code>classNames</code>用于元素的进入和离开:<code>enter</code>、<code>enter-active</code>、<code>exit</code>和<code>exit-active</code>。</p>
<pre class="language-css hljs">/* This fires as soon as the element enters the DOM */
.list-transition-enter{
}
/* This is where we can add the transition*/
.list-transition-enter-active{
}
/* This fires as soon as the this.state.showList is false */
.list-transition-exit{
}
/* fires as element leaves the DOM*/
.list-transition-exit-active{
}
</pre>
<p>然后，在这些CSS类中，我们可以在类中添加一些很棒(但很简单)的CSS，使子组件看起来像是从按钮中生长出来的。</p>
<pre class="language-css hljs">/* This fires as soon as the element enters the DOM*/
.list-transition-enter {
/*We give the list the initial dimension of the list button*/
top: 0;
width: 120px;
max-height: 40px;
color: transparent;
background-color: #5a564c;
}
/* This is where we can add the transition*/
.list-transition-enter-active {
top: 45px;
width: 200px;
max-height: 200px;
background-color: #9e8949;
transition: all 400ms;
}
/* This fires as soon as the this.state.showList is false */
.list-transition-exit {
top: 45px;
width: 200px;
max-height: 200px;
background-color: #9e8949;
}
/* fires as element leaves the DOM*/
.list-transition-exit-active {
top: 0;
width: 120px;
max-height: 40px;
color: transparent;
background-color: #5a564c;
transition: all 400ms;
}
</pre>
<p>在上面的代码演示中，您会注意到<code>list-transition-enter</code>和<code>list-transition-exit-active</code>具有相同的值，因为它们是组件的开始和结束状态。然而，只有当<code>className</code>激活时，转换才会发生。</p>
<h3 id="adding-appear-prop-display-transition-on-load">添加显示道具以显示加载时的过渡</h3>
<p>列表的初始状态被设置为false。但是如果我们希望它在页面装载到DOM时显示呢？我们可以通过将<code>showList</code>的状态更改为true来实现这一点，但是使用如下所示的<code>appear</code>道具时，过渡不会显示:</p>
<pre class="language-css hljs">&lt;CSSTransition
  in={this.state.showList}
  timeout={400}
  classNames="list-transition"
  unmountOnExit
  appear
&gt;
</pre>
<p>在CSS文件中，<code>.list-transition-appear</code>的<code>classNames</code>样式将与<code>.list-transition-enter</code>和<code>.list-transition-exit-active</code>相同，因为它发生在组件安装时，并且它唯一的功能是允许过渡显示出来。</p>
<pre class="language-css hljs">.list-transition-enter, .list-transition-appear {
/*We give the list the initial dimension of the list button*/
top: 0;
width: 120px;
max-height: 40px;
color: transparent;
background-color: #5a564c;
}
/* This is where we can add the transition*/
.list-transition-enter-active, .list-transition-appear-active {
top: 45px;
width: 200px;
max-height: 200px;
background-color: #9e8949;
transition: all 400ms;
}
</pre>
<h3 id="using-enter-exit-props">使用<code>enter</code>和<code>exit</code>道具</h3>
<p>有时，如果应用程序要求在组件的转换生命周期的某个部分禁用转换，我们可以在组件中这样做，而无需编辑CSS或禁用<code>classNames</code>。我们这样使用<code>enter</code>和<code>exit</code>道具:</p>
<pre class="language-css hljs">&lt;CSSTransition
  in={this.state.showList}
  timeout={400}
  classNames="list-transition"
  unmountOnExit
  appear
  enter = {false}
&gt;
</pre>
<p>这将停止<code>.list-transition-active</code>和<code>.list-transition-enter</code>类的工作。</p>
<pre class="language-css hljs">&lt;CSSTransition
  in={this.state.showList}
  timeout={400}
  classNames="list-transition"
  unmountOnExit
  appear
  exit = {false}
&gt;
</pre>
<h3 id="lifecycle-props-csstransition-groups"><code>CSSTransition</code>组中的更多生命周期道具</h3>
<p>我们可以使用生命周期道具来瞄准产品化阶段的特定时间。这些生命周期正如其名称所暗示的那样:</p>
<ul>
<li><code>onEnter</code>当点击按钮并开始操作时触发</li>
<li>当信息进入DOM时触发</li>
<li><code>onEntered</code>表明信息已经进入DOM</li>
<li><code>onExit</code>当元素退出操作开始时，基本上触发</li>
<li>当信息退出DOM时触发</li>
<li><code>onExited</code>表明信息已经离开了DOM</li>
</ul>
<p>假设我们需要突出我喜欢做的最重要的活动。我们可以在列表呈现后突出显示颜色，并在突出显示之前添加一个延迟过渡。然后，我们的<code>CSSTransition</code>组件变成:</p>
<pre class="language-css hljs">&lt;CSSTransition
    in={this.state.showList}
    timeout={400}
    classNames="list-transition"
    unmountOnExit
    appear
    onEntered= {this.listSwitch}
    onExit={this.listSwitch}
&gt;
</pre>
<p><code>this.listSwitch</code>状态用于为我们想要突出显示的爱好设置一个条件类。所以当<code>highlightedHobby</code>是<code>true</code>时，我们将得到列表项的这个活动变量:</p>
<pre class="language-css hljs">&lt;li
className={cx('list-item', {
'list-item--active': this.state
.highlightedHobby,
})}
&gt;Writing JavaScript&lt;/li&gt;
</pre>
<p>条件<code>className</code>看起来是这样的:</p>
<pre class="language-css hljs">.list-item--active{
  color: blue;
  transition: 500ms;
}
</pre>
<p>当它打开时，我们看到<code>Writing JavaScript</code>在<code>500ms</code>的延迟后变成蓝色，这比<code>list-item</code>的转变晚<code>100ms</code>，它又回到<code>onExit</code>。因为这发生得如此之快，我们看不到它离开；但是如果您使用开发人员工具检查该元素，您会注意到它。</p>
<h2 id="transitiongroup-csstransition-example-applying-transitions-elements-list"><code>TransitionGroup</code>和<code>CSSTransition</code>示例:将过渡应用到列表中的元素</h2>
<p>在这个<code>react-transition-group</code>例子中，我们将演示如何用<code>TransitionGroup</code>和<code>CSSTransition</code>创建有趣的过渡。</p>
<p>考虑下面的代码块，它呈现了我最喜欢的音乐列表:</p>
<pre class="language-css hljs">import React, { Component } from 'react';
import {
  CSSTransition,
  TransitionGroup,
} from 'react-transition-group';

import uuid from 'uuid';
import './lesson.css';

class App extends Component {
  items = [
    {
      name: 'Jcole - Love Yours',
      id: uuid(),
    },
    {
      name: 'Kendirick Lamar - DNA',
      id: uuid(),
    },
    {
      name: 'Ryth B - Lost boy ',
      id: uuid(),
    },
    {
      name: 'Ruth B -  Chance',
      id: uuid(),
    },
    {
      name: 'Jcole- Lost ones',
      id: uuid(),
    },
    {
      name: 'Meek Mill- Cold heart ',
      id: uuid(),
    },
  ];

  state = {
    favorites: [],
  };

  toggleInFavorites = id =&gt; {
    let favorites;
    const isItemInFavorites = this.state.favorites.find(
      favorite =&gt; favorite.id === id
    );

    if (isItemInFavorites) {
      // Item is already in favorites, remove it.
      favorites = this.state.favorites.filter(
        favorite =&gt; favorite.id !== id
      );
    } else {
      // Item is not in favorites, add it.
      favorites = [
        ...this.state.favorites,
        this.items.find(item =&gt; id === item.id),
      ];
    }
    this.setState({ favorites });
  };

  render() {
    return (
      &lt;div className="container"&gt;
        &lt;ul className="musicList"&gt;
          {this.items.map(({ id, name }) =&gt; (
            &lt;li
              key={id}
              className="music"
              onClick={() =&gt;
                this.toggleInFavorites(id)
              }
            &gt;
              {name}
              &lt;span className="star"&gt;
                {this.state.favorites.find(
                  favorite =&gt; favorite.id === id
                )
                  ? '★'
                  : '☆'}
              &lt;/span&gt;
            &lt;/li&gt;
          ))}
        &lt;/ul&gt;
        &lt;div className="favorites"&gt;
          &lt;p&gt;My Favorite Songs:&lt;/p&gt;
          &lt;TransitionGroup component="ul"&gt;
            {this.state.favorites.map(
              ({ id, name }) =&gt; (
                &lt;CSSTransition
                  timeout={500}
                  classNames="fade"
                  key={id}
                &gt;
                  &lt;li className="favorite"&gt;{name}&lt;/li&gt;
                &lt;/CSSTransition&gt;
              )
            )}
          &lt;/TransitionGroup&gt;
        &lt;/div&gt;
      &lt;/div&gt;
    );
  }
}

export default App;
</pre>
<p>从代码示例中，我们可以看到,<code>TransitionGroup</code>映射到favorite music数组，并返回每个带有<code>CSSTransition</code>组件的数组。</p>
<pre class="language-css hljs">    &lt;TransitionGroup component="ul"&gt;
      {this.state.favorites.map(
      ({ id, name }) =&gt; (
      &lt;CSSTransition
      timeout={500}
      classNames="fade"
      key={id}
    &gt;
    &lt;li className="favorite"&gt;{name}&lt;/li&gt;
    &lt;/CSSTransition&gt;
    )
    )}
    &lt;/TransitionGroup&gt;
</pre>
<p>从上面的代码示例中，我们可以看到<code>TransitionGroup</code>组件渲染一个组件，我们可以设置这个来渲染任何东西。可能是<code>UL</code>、<code>div</code>、<code>p</code>、<code>option</code>等。但是当我们不想渲染任何组件时，我们可以将其设置为<code>{null}</code>:</p>
<pre class="language-css hljs">&lt;TransitionGroup component={null}&gt;
</pre>
<p>将上面的完整代码复制到React项目的App.js文件中，并在浏览器上运行该应用程序以查看列表。</p>
<p><img data-attachment-id="133938" data-permalink="https://blog.logrocket.com/react-transition-group/attachment/transition-list-songs/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2021/03/transition-list-songs.gif" data-orig-size="350,366" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Transition on list of songs" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2021/03/transition-list-songs-287x300.gif" data-large-file="https://blog.logrocket.com/wp-content/uploads/2021/03/transition-list-songs.gif" decoding="async" class="aligncenter size-full wp-image-133938 jetpack-lazy-image" src="../Images/9037c47dc7102e8883889966f2922f5c.png" alt="Transition On List Of Songs" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2021/03/transition-list-songs.gif?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2021/03/transition-list-songs.gif"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="133938" data-permalink="https://blog.logrocket.com/react-transition-group/attachment/transition-list-songs/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2021/03/transition-list-songs.gif" data-orig-size="350,366" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Transition on list of songs" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2021/03/transition-list-songs-287x300.gif" data-large-file="https://blog.logrocket.com/wp-content/uploads/2021/03/transition-list-songs.gif" decoding="async" loading="lazy" class="aligncenter size-full wp-image-133938" src="../Images/9037c47dc7102e8883889966f2922f5c.png" alt="Transition On List Of Songs" data-original-src="https://blog.logrocket.com/wp-content/uploads/2021/03/transition-list-songs.gif"/></noscript>
<p>现在我们已经看到了如何使用<code>&lt;TransitionGroup&gt;</code>将过渡应用到列表，让我们看看如何使用JavaScript添加过渡。</p>
<h2 id="transitions-using-jss">使用JSS的过渡</h2>
<p>我们一直使用普通的CSS来实现我们的CSS转换；现在，我们将重构我们的CSS成为JavaScript对象。我们将从创建一个<code>styles.js</code>文件开始，并在对象中转换我们的样式，就像这样:</p>
<pre class="language-css hljs">// Here we will turn all our Css into JavaScript Objects
const startTransitionStyles = {
top: 0,
width: '120px',
maxHeight: '40px',
color: 'transparent',
backgroundColor: '#5a564c',
};
const finishTransitionStyles = {
top: '45px',
width: '200px',
maxHeight: '200px',
backgroundColor: '#9e8949',
};
const styles = {
container: {
position: 'relative',
},
display: {
position: 'relative',
zindex: '1',
width: '120px',
height: '40px',
backgroundColor: '#5a564c',
border: 'none',
borderRadius: '5px',
outline: 'none',
cursor: 'pointer',
transition: 'backgroundColor 350ms',
},
displayActive: {
backgroundColor: '#000000',
},
listBody: {
position: 'absolute',
top: '45px',
Zindex: '1',
boxSizing: 'border-box',
width: '200px',
padding: '0 20px',
overflow: 'hidden',
backgroundColor: '#9e8949',
borderRadius: '5px',
},
list: {
padding: '0',
listStyleType: 'none',
},
listItem: {
padding: '5px 0',
},
listItemActive: {
color: 'blue',
transition: 'color 500ms',
},
listTransitionEnter: {
...startTransitionStyles,
},
listTransitionEnterActive: {
...finishTransitionStyles,
transition: 'all 400ms',
},
listTransitionExit: {
...finishTransitionStyles,
},
listTransitionExitActive: {
...startTransitionStyles,
transition: 'all 400ms',
},
};
export default styles;
</pre>
<p>上面的代码片段随后被导入到我们的<code>refactor.js</code>中:</p>
<pre class="language-javascript hljs">import styles from './styles';
</pre>
<p>使用从<code>react-jss</code>导入的<code>InjectSheet</code>完成样式的实现:</p>
<pre class="language-javascript hljs">import injectSheet from 'react-jss';
</pre>
<p>这给了我们<code>classes</code>道具，我们可以用它来访问<code>style.js</code>中的样式，就像这样:</p>
<pre class="language-javascript hljs">render() {
const { classes } = this.props;
return (
&lt;div className={classes.container}&gt;
&lt;button
  className={classes.display}
  onClick={this.switch}
&gt;
Obinna
&lt;/button&gt;
&lt;CSSTransition
  in={this.state.showList}
  timeout={400}
  classNames="list-transition"
  unmountOnExit
  classNames={{
  enter: classes.listTransitionEnter,
  enterActive:
  classes.listTransitionEnterActive,
  exit: classes.listTransitionExit,
  exitActive:
  classes.listTransitionExitActive,
  }}
&gt;
&lt;div className={classes.listBody}&gt;
  &lt;ul className={classes.list}&gt;
    &lt;li className={classes.listItem}&gt;
    Writing JavaScript
    &lt;/li&gt;
    &lt;li className={classes.listItem}&gt;
    Running
    &lt;/li&gt;
    &lt;li className={classes.listItem}&gt;
    Technical Writing
    &lt;/li&gt;
    &lt;li className={classes.listItem}&gt;
    Writing Clean code
    &lt;/li&gt;
  &lt;/ul&gt;
&lt;/div&gt;
&lt;/CSSTransition&gt;
&lt;/div&gt;
);
</pre>
<p>注意，我们在这里使用<code>classNames</code>而不是<code>className</code>，这样我们可以提供多个<code>classNames</code>。</p>
<p>通过传递带有<code>enter</code>、<code>enter-active</code>、<code>exit</code>和<code>enter-active</code>键的对象来添加转换，它们将引用JSS类名。</p>
<pre class="language-css hljs">&lt;CSSTransition
  in={this.state.showList}
  timeout={400}
  classNames="list-transition"
  unmountOnExit
  classNames={{
  enter: classes.listTransitionEnter,
  enterActive:classes.listTransitionEnterActive,
  exit: classes.listTransitionExit,
  exitActive:classes.listTransitionExitActive,
}}
&gt;

</pre>
<p><img data-attachment-id="134223" data-permalink="https://blog.logrocket.com/react-transition-group/attachment/smooth-transitions-demo/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2021/09/smooth-transitions-demo.gif" data-orig-size="312,240" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Demo of smooth css transition" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2021/09/smooth-transitions-demo-300x231.gif" data-large-file="https://blog.logrocket.com/wp-content/uploads/2021/09/smooth-transitions-demo.gif" decoding="async" class="aligncenter size-full wp-image-134223 jetpack-lazy-image" src="../Images/60fd6a7fa22aca6c846d0f6bd0c1d7a6.png" alt="Demo Of Smooth CSS Transition" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2021/09/smooth-transitions-demo.gif?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2021/09/smooth-transitions-demo.gif"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="134223" data-permalink="https://blog.logrocket.com/react-transition-group/attachment/smooth-transitions-demo/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2021/09/smooth-transitions-demo.gif" data-orig-size="312,240" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Demo of smooth css transition" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2021/09/smooth-transitions-demo-300x231.gif" data-large-file="https://blog.logrocket.com/wp-content/uploads/2021/09/smooth-transitions-demo.gif" decoding="async" loading="lazy" class="aligncenter size-full wp-image-134223" src="../Images/60fd6a7fa22aca6c846d0f6bd0c1d7a6.png" alt="Demo Of Smooth CSS Transition" data-original-src="https://blog.logrocket.com/wp-content/uploads/2021/09/smooth-transitions-demo.gif"/></noscript>
<h2 id="conclusion">结论</h2>
<p>平滑的过渡使你的应用程序的用户体验更加动态，更受终端用户的欢迎。React Transition Group帮助我们用更少、更容易理解的代码实现了这一点。编码快乐！</p><div class="code-block code-block-25">
<div class="blog-plug inline-plug css-plug"><h2>你的前端是否占用了用户的CPU？</h2><p>随着web前端变得越来越复杂，资源贪婪的特性对浏览器的要求越来越高。如果您对监控和跟踪生产环境中所有用户的客户端CPU使用、内存使用等感兴趣，</p><a target="_blank" href="https://lp.logrocket.com/blg/css-signup">try LogRocket</a><p>.</p><a class="signup" href="https://lp.logrocket.com/blg/css-signup" target="_blank" rel="noopener noreferrer"><img class="alignnone size-full wp-image-46 jetpack-lazy-image" src="../Images/dacb06c713aec161ffeaffae5bd048cd.png" alt="LogRocket Dashboard Free Trial Banner" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2019/12/cpu-memory-usage.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/12/cpu-memory-usage.png"/><noscript><img data-lazy-fallback="1" class="alignnone size-full wp-image-46" src="../Images/dacb06c713aec161ffeaffae5bd048cd.png" alt="LogRocket Dashboard Free Trial Banner" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/12/cpu-memory-usage.png"/></noscript></a><a href="https://lp.logrocket.com/blg/css-signup" target="_blank" rel="noopener noreferrer">https://logrocket.com/signup/</a><p>LogRocket 就像是网络和移动应用的DVR，记录你的网络应用或网站上发生的一切。您可以汇总和报告关键的前端性能指标，重放用户会话和应用程序状态，记录网络请求，并自动显示所有错误，而不是猜测问题发生的原因。</p><p>现代化您调试web和移动应用的方式— <a class="signup" href="https://lp.logrocket.com/blg/css-signup" target="_blank" rel="noopener noreferrer">开始免费监控</a>。</p></div>
</div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
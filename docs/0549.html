<html>
<head>
<title>Rendering child elements in React using Fragments - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>使用片段在React中呈现子元素</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/rendering-child-elements-react-fragments/#0001-01-01">https://blog.logrocket.com/rendering-child-elements-react-fragments/#0001-01-01</a></blockquote><div><article class="article-post">
<p>使用React呈现用户界面的一个优点是很容易将UI分解成组件。然而，一个常见的问题是当我们想要返回没有父元素的兄弟元素时。React有一个叫做片段的特性提供了解决方案。</p>
<h2>问题是</h2>
<p>如果你不熟悉这个问题，考虑这个例子。</p>
<pre>function FAQ() {
    return (
        &lt;p&gt;Q. What is React?&lt;/p&gt;
        &lt;p&gt;A. A JavaScript library for building user interfaces&lt;/p&gt;
        &lt;p&gt;Q. How do I render sibling elements?&lt;/p&gt;
        &lt;p&gt;A. Use Fragments&lt;/p&gt;
    );
}</pre>
<p>该代码导致一个错误:<code>Adjacent JSX elements must be wrapped in an enclosing tag.</code></p>
<h2>解决方案</h2>
<p>一种选择是用父元素包装元素。</p>
<pre>function FAQ() {
    return (
        &lt;div&gt;
            &lt;p&gt;Q. What is React?&lt;/p&gt;
            &lt;p&gt;A. A JavaScript library for building user interfaces&lt;/p&gt;
            &lt;p&gt;Q. How do I render sibling elements?&lt;/p&gt;
            &lt;p&gt;A. Use Fragments&lt;/p&gt;
        &lt;/div&gt;
    );
}</pre>
<p>但是这种方法在DOM中引入了一个额外的元素，增加了一个我们实际上并不需要的嵌套层次。</p>
<p>React <a href="https://github.com/facebook/react/releases/tag/v16.0.0"> v16.0 </a>引入了另一个选项，就是返回一个元素数组。</p>
<pre>function FAQ() {
    return [
        &lt;p&gt;Q. What is React?&lt;/p&gt;,
        &lt;p&gt;A. A JavaScript library for building user interfaces&lt;/p&gt;,
        &lt;p&gt;Q. How do I render sibling elements?&lt;/p&gt;,
        &lt;p&gt;A. Use Fragments&lt;/p&gt;
    ];
}</pre>
<p>现在我们需要在元素之间添加逗号。更重要的是，这段代码产生了一个<a href="https://reactjs.org/docs/lists-and-keys.html#keys">键</a>警告:<code>Warning: Each child in a list should have a unique "key" prop.</code>给每个元素添加一个键可以解决这个问题，但是非常麻烦。</p>
<pre>function FAQ() {
    return [
        &lt;p key="q1"&gt;Q. What is React?&lt;/p&gt;,
        &lt;p key="a1"&gt;A. A JavaScript library for building user interfaces&lt;/p&gt;,
        &lt;p key="q2"&gt;Q. How do I render sibling elements?&lt;/p&gt;,
        &lt;p key="a2"&gt;A. Use Fragments&lt;/p&gt;
    ];
}</pre>
<p>React <a href="https://github.com/facebook/react/releases/tag/v16.2.0"> v16.2 </a>给了我们一个更干净的解决方案，就是使用碎片。</p>
<pre>function FAQ() {
    return (
        &lt;React.Fragment&gt;
            &lt;p&gt;Q. What is React?&lt;/p&gt;
            &lt;p&gt;A. A JavaScript library for building user interfaces&lt;/p&gt;
            &lt;p&gt;Q. How do I render sibling elements?&lt;/p&gt;
            &lt;p&gt;A. Use Fragments&lt;/p&gt;
        &lt;/React.Fragment&gt;
    );
}</pre>
<p>我们不再需要提供键，我们不需要添加数组逗号，我们仍然避免添加额外的DOM元素，因为<code>React.Fragment</code>在呈现期间不会变成实际的元素。</p>
<p>我们可以导入<code>Fragment</code>来避免完全写出<code>React.Fragment</code>。</p>
<pre>import React, {Fragment} from "react";

function FAQ() {
    return (
        &lt;Fragment&gt;
            &lt;p&gt;Q. What is React?&lt;/p&gt;
            &lt;p&gt;A. A JavaScript library for building user interfaces&lt;/p&gt;
            &lt;p&gt;Q. How do I render sibling elements?&lt;/p&gt;
            &lt;p&gt;A. Use Fragments&lt;/p&gt;
        &lt;/Fragment&gt;
    );
}</pre>
<p>然而，更好的方法是使用片段的简写语法，它看起来像空标签:<code>&lt;&gt;</code>和<code>&lt;/&gt;</code>。</p>
<pre>function FAQ() {
    return (
        &lt;&gt;
            &lt;p&gt;Q. What is React?&lt;/p&gt;
            &lt;p&gt;A. A JavaScript library for building user interfaces&lt;/p&gt;
            &lt;p&gt;Q. How do I render sibling elements?&lt;/p&gt;
            &lt;p&gt;A. Use Fragments&lt;/p&gt;
        &lt;/&gt;
    );
}</pre>
<p>这给了我们与使用<code>React.Fragment</code>相同的好处，但是我们不需要导入任何其他东西，我们的代码看起来更干净。</p>
<p>速记语法目前唯一不支持的是添加一个<code>key</code>。例如，如果你正在创建一个<a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/dl">描述列表</a>，这可能会有问题。在这种情况下，使用标准语法。</p>
<pre>function Dictionary(props) {
    return (
        &lt;dl&gt;
            {props.terms.map(({word, definition}) =&gt; 
                &lt;React.Fragment key={word}&gt;
                    &lt;dt&gt;{word}&lt;/dt&gt;
                    &lt;dd&gt;{definition}&lt;/dd&gt;
                &lt;/React.Fragment&gt;
            )}
        &lt;/dl&gt;
    );
}</pre>
<p>我们需要提供一个密钥来避免密钥警告。</p>
<p>然而，在大多数情况下，简写方法是我们返回兄弟元素的原始问题的最佳解决方案。这个解决方案已经做得足够好，以至于当v3发布时，Vue.js 也将原生支持片段<a href="https://medium.com/the-vue-point/plans-for-the-next-iteration-of-vue-js-777ffea6fabf">的概念。</a></p>
<h2>使用片段</h2>
<p>在过去的两年中，JavaScript生态系统增加了对片段的广泛支持。</p>

<p>如果您升级您的依赖项，您将可能能够使用片段而无需任何额外的配置。</p><div class="code-block code-block-17">
<div class="blog-plug inline-plug react-plug" vwo-el-id="26283398190">
<h2 vwo-el-id="41600691720"><a href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener"> LogRocket </a>:全面了解您的生产React应用</h2><p>调试React应用程序可能很困难，尤其是当用户遇到难以重现的问题时。如果您对监视和跟踪Redux状态、自动显示JavaScript错误以及跟踪缓慢的网络请求和组件加载时间感兴趣，</p><a href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" vwo-el-id="19356441070">try LogRocket</a><p>. </p><a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="19356441380">
<img class="first-react-image alignnone size-full wp-image-46 jetpack-lazy-image jetpack-lazy-image--handled" src="../Images/f300c244a1a1cf916df8b4cb02bec6c6.png" vwo-el-id="18272717540" data-lazy-loaded="1" data-original-src="https://files.readme.io/27c94e7-Image_2017-06-05_at_9.46.04_PM.png"/>
</a>
<a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="19356441690">
<img class="second-react-image alignnone size-full wp-image-46 jetpack-lazy-image jetpack-lazy-image--handled" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" vwo-el-id="30720362350" data-lazy-loaded="1" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/>
</a>
<p vwo-el-id="28675660440" class="">LogRocket 结合了会话回放、产品分析和错误跟踪，使软件团队能够创建理想的web和移动产品体验。这对你来说意味着什么？</p>
<p>LogRocket不是猜测错误发生的原因，也不是要求用户提供截图和日志转储，而是让您回放问题，就像它们发生在您自己的浏览器中一样，以快速了解哪里出错了。</p>
<p>不再有嘈杂的警报。智能错误跟踪允许您对问题进行分类，然后从中学习。获得有影响的用户问题的通知，而不是误报。警报越少，有用的信号越多。</p>
<p vwo-el-id="28675660750">LogRocket Redux中间件包为您的用户会话增加了一层额外的可见性。LogRocket记录Redux存储中的所有操作和状态。</p>
<p vwo-el-id="28675661060">现代化您调试React应用的方式— <a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="40093418840">开始免费监控</a>。</p>
</div></div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
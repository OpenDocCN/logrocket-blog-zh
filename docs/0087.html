<html>
<head>
<title>Benefits of using styled-components in React - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>在React - LogRocket博客中使用样式化组件的好处</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/benefits-using-styled-components-react/#0001-01-01">https://blog.logrocket.com/benefits-using-styled-components-react/#0001-01-01</a></blockquote><div><article class="article-post">
<p><em> <strong>编者按:</strong>本文于2021年7月更新了相关信息，包括styled-components当前的GitHub评级以及围绕使用styled-components的其他好处和关注点。</em></p>
<p>在本文中，我们将探讨样式化组件的各种好处，以及为什么您应该考虑将它作为首选的CSS-in-JS框架。</p>
<h2>什么是样式组件？</h2>
<p><a href="http://styled-components.com/" target="_blank" rel="noopener noreferrer"> Styled-components </a>是一个CSS-in-JS样式框架，它使用JavaScript中的标记模板文字和CSS的力量来提供一个平台，允许您编写实际的CSS来样式化React组件。</p>
<p>样式化组件是用<a href="http://styled-components.com" target="_blank" rel="noopener noreferrer">样式化组件</a>库编写的易于制作的React组件，在这里，您可以用JavaScript代码中的普通CSS来样式化组件。在<a href="https://styled-components.com/docs" target="_blank" rel="noopener">官方文档页面</a>上，您会看到下面的例子:</p>
<pre>const Button = styled.a`
  display: inline-block;
  border-radius: 3px;
  padding: 0.5rem 0;
  margin: 0.5rem 1rem;
  width: 11rem;
  background: transparent;
  color: white;
  border: 2px solid white;


  ${props =&gt; props.primary &amp;&amp; css`
    background: white;
    color: palevioletred;
  `}
`

render(
  &lt;div&gt;
    &lt;Button
      href="https://github.com/styled-components/styled-components"
      target="_blank"
      rel="noopener"
      primary&gt;
      GitHub
    &lt;/Button&gt;

    &lt;Button as={Link} href="/docs" prefetch&gt;
      Documentation
    &lt;/Button&gt;
  &lt;/div&gt;
)</pre>
<p>我们可以清楚地看到按钮是一个JavaScript变量，反斜线中定义的样式是普通的CSS样式。我们还看到了普通CSS样式的嵌套样式属性。这就是styled-components在JavaScript中呈现CSS的方式。</p>
<p>我知道CSS-in-JS的主题在前端社区，尤其是React开发人员中引起了激烈的争论，所以我希望你保持开放的心态。</p>
<h2>样式反应组件</h2>
<p>有许多方法可以对React组件进行样式化。传统的方法是在外部CSS文件中使用CSS，然后传递一个字符串作为<code>className</code>属性来引用它们，就像这样:</p>
<pre>render() {
  return &lt;span className="menu navigation-menu"&gt;Menu&lt;/span&gt;
}</pre>
<p>如果您使用过大型web应用程序，您可以证明CSS文件开始变得庞大、笨拙和复杂。一个很好的解决方案是引入SASS。尽管SASS有所帮助，但由于一个项目可能有大量的SCSS文件，您最终还是会遇到同样的问题。甚至抽象本身也开始变得复杂。</p>
<p>您还可以在React组件中内联CSS:</p>
<pre>const divStyle = {
  color: 'blue',
  backgroundImage: 'url(' + imgUrl + ')',
};

function HelloWorldComponent() {
  return &lt;div style={divStyle}&gt;Hello World!&lt;/div&gt;;
}</pre>
<p>React非常不鼓励这种方法，因为它既不可持续也不可伸缩(稍后将详细介绍)。</p>
<p>最后，CSS-in-JS是一种使用JavaScript来设计组件样式的技术。当解析这个JavaScript时，CSS作为一个样式元素生成，并直接附加在DOM之上。</p>
<p>有许多CSS-in-JS框架:风格化组件、<a href="https://emotion.sh/docs/styled" target="_blank" rel="noopener">情感</a>、<a href="https://cssinjs.org/?v=v10.7.1" target="_blank" rel="noopener"> JSS </a>、<a href="https://formidable.com/open-source/radium/" target="_blank" rel="noopener">镭</a>、<a href="https://github.com/Khan/aphrodite" target="_blank" rel="noopener">阿芙罗狄蒂</a>等等。你可以在这里<a href="https://michelebertoli.github.io/css-in-js/" target="_blank" rel="noopener noreferrer">看到一个对比表</a>。然而，样式化组件可能是最受欢迎的。这个选项看起来很有前景——难怪会有一个<a href="http://www.npmtrends.com/jss-vs-aphrodite-vs-radium-vs-styled-components-vs-glamorous-vs-emotion-vs-styletron" target="_blank" rel="noopener noreferrer">非常快速、广泛的采用</a>，在过去的一个月里有超过60万次下载。</p>
<h2>为什么应该使用样式化组件</h2>
<h3>用CSS构建定制组件的自由</h3>
<p>使用样式化组件，UI设计的重点从仅仅设计HTML元素或React组件的样式转移到定义包含它们自己的样式并且在整个项目中容易重用的样式化组件。最初，一个副标题声明看起来像这样:</p>
<pre>&lt;h2 className="subTitle"&gt;Gucci Snakes &lt;/h2&gt;</pre>
<p>样式定义如下:</p>
<pre>h2.subTitle{
  font-size: 2em;
  color: blue;
}</pre>
<p>会变成这样:</p>
<pre>import styled from 'styled-components';
const Subtitle = styled.h2`
  font-size: 2em;
  color: blue;
`;
&lt;Subtitle&gt;Gucci Snakes&lt;/Subtitle&gt;</pre>
<p>在这里，样式成为组件不可分割的一部分，从而消除了CSS类最初通过消除样式和组件之间的映射而扮演的关键角色。这都是用普通的CSS构建的，所以当你使用你已经习惯的东西时，总会有一种熟悉的感觉。</p>
<p>这种感觉已经为样式化组件的每个用户小心翼翼地保留了下来，因为语法在很大程度上仍然是普通的CSS。</p>
<h3>带造型组件的类固醇内联造型</h3>
<p>通常，React团队不鼓励内联样式，这种担心是有道理的，因为内联样式不允许使用伪样式和媒体查询。此外，由于担心浏览器兼容性、骆驼大小写和自动追加标量，不应使用内联样式。</p>
<p>但是对于样式化组件，我们可以看到一种内联样式，但是没有前面提到的内联样式包袱。我称之为<em>振动</em>能量。下面是演示的示例代码:</p>
<pre>const paragraphStyles = {
color: red,
backgroundColor: black,
padding: 2px
}
&lt;p style={paragraphStyles}&gt; inline styles applied here &lt;/p&gt;</pre>
<p>编译输出:</p>
<pre>&lt;p style="color: red; background-color: black;"&gt;
inline styles applied here &lt;/p&gt;</pre>
<p>但是对于样式化组件…</p>
<pre>import styled from 'styled-components';
const Text = styled.div`
color: red,
background: black
`
&lt;Text&gt;Styled with CSS-in-JS &lt;/Text&gt;</pre>
<p>编译输出:</p>
<pre>&lt;style&gt;
.hash12345tf {
background-color: black;
color: red;
}
&lt;/style&gt;
&lt;p class="hash12345tf"&gt;Styled with CSS-in-JS&lt;/p&gt;</pre>
<p>看看styled-components如何在DOM上附加一个style标签，而inline style只是处理DOM节点的属性。</p>
<h3>styled-components提供React本地移动支持</h3>
<p>对于拥有React代码库并使用React Native进行移动开发的团队来说，styled-components是最好的统一解决方案之一。如果跨平台的一致性是优先考虑的，那么您会很高兴知道样式化组件可以捆绑到React Native中。</p>
<p>使用React Native中的样式化组件，您可以给注释分配别名，使您的JSX代码非常易读。此外，您可以通过简单地调用<code>styled()</code>将任何组件，甚至是定制组件，转换成样式化的组件。</p>
<h3>范围样式</h3>
<p>在前端工具世界中，<a href="https://vuejs.org/" target="_blank" rel="noopener noreferrer"> Vue </a>的团队(在我看来)是第一个完善这个范围样式概念的团队。使用CSS有一件非常恼人的事情，那就是对于一个非专业的CSS用户来说，当您更改样式表中某个特定元素或类的样式时，它会对DOM中另一个看似不相关的元素或行为产生负面影响，这是非常令人沮丧的。这是使用样式化组件的一个很好的理由，因为它是基于组件和限定范围的，就像Vue一样。</p>
<h3>样式化组件中的无类别策略</h3>
<p>样式化组件在类的位置强制使用道具。这种无类别策略帮助他们让更多的开发人员遵循控制组件行为的最佳实践。</p>
<p>最初，您应该写:</p>
<pre>&lt;h2 className="title primary"&gt;Hello World&lt;/h2&gt; 
h2.Subtitle{
  font-size: 2em;
  color: green;
  
  &amp;.primary{
    color: red;
  }
}</pre>
<p>但是现在，应该是这样的:</p>
<pre>const Subtitle = styled.h2`
  font-size: 2em;
  color: ${props =&gt; props.primary ? 'red' : 'green'};
`;
&lt;Subtitle primary&gt;Hello World&lt;/Subtitle&gt;</pre>
<p>请注意我们是如何设法将HTML和CSS操作排除在组件之外的。</p>
<p>或者，您也可以直接返回到<code>className</code>，同样会得到相同的结果。</p>
<pre>const Subtitle = styled.h2`
  font-size: 2em;
  color: green;
  
  &amp;.primary{
    color: red;
  }
`;
&lt;Subtitle className="primary"&gt;Hello World&lt;/Subtitle&gt;</pre>
<h3>服务器端渲染</h3>
<p>styled-components支持使用样式表重新水化的并发服务器端呈现。其基本思想是，每次在服务器上呈现应用程序时，都可以创建一个<code>ServerStyleSheet</code>，并将一个提供程序添加到React树中，该提供程序通过上下文API接受样式。</p><div class="code-block code-block-54">
<hr/>
<h3>更多来自LogRocket的精彩文章:</h3>

<hr/></div>
<p>这不会干扰全局样式，例如关键帧或<code>createGlobalStyle</code>，并且它允许您将样式化组件与React DOM的各种SSR APIs一起使用。</p>
<h3>用Jest测试CSS单元和快照</h3>
<p>由于styled-components确实是由组件组成的，所以您可以对它们进行单元测试。这是CSS的一个重大突破，styled-component团队已经提供了Jest集成支持。</p>
<p>Jest风格组件是一套用<a href="https://github.com/facebook/jest" target="_blank" rel="noopener noreferrer"> Jest </a>测试风格组件的工具。这个包改善了快照测试体验，并提供了一个全新的匹配器来对样式规则做出期望。它可以这样安装:</p>
<pre>npm install --dev jest-styled-components</pre>
<p>这里有一个测试的例子:</p>
<pre>import React from 'react'
import styled from 'styled-components'
import renderer from 'react-test-renderer'
import 'jest-styled-components'
const Button = styled.button`
  color: red;
`
test('it works', () =&gt; {
  const tree = renderer.create(&lt;Button /&gt;).toJSON()
  expect(tree).toMatchSnapshot()
})</pre>
<p>这是结果快照的一个示例:</p>
<pre>exports[`it works 1`] = `
.c0 {
  color: green;
}
&lt;button
  className="c0"
/&gt;
`</pre>
<h3>Sass和抛光支持</h3>
<p>如果您一直关注这篇文章，那么您一定已经注意到了一些嵌套的样式，<a href="https://sass-lang.com/" target="_blank" rel="noopener"> Sass </a>，甚至是团队为进一步扩展Sass的功能而创建的工具集:</p>
<pre>const Link = styled.a`
  cursor: pointer;
  text-decoration: none;
  &amp;:hover {
    color: blue;
    text-decoration: underline;
  }
`;</pre>
<p>支持Sass暴露了styled-components的核心任务:创建完美的CSS-in-JS体验，而不失去我们已经喜欢的CSS的一切，包括减少代码行和Sass的其他优化功能。</p>
<h2>反对使用样式化组件的理由</h2>
<p>我很难想出不使用样式化组件的理由(特别是考虑到文章的标题)，但是如果我不在本文中指出一些关于CSS-in-JS框架的(有效的)担忧，那将是不公平的。</p>
<h3>JavaScript、React和样式化组件锁定</h3>
<p>对于样式化组件的每个用户来说，都存在一种嵌套的锁定，您应该意识到这一点，并对此感到满意。您被锁定在JavaScript中，然后是React库，最后是样式化组件。如果它们中的任何一个消失了，你将不得不痛苦地重构你的代码库。</p>
<h3>学习曲线</h3>
<p>一些人还指出样式化组件的学习曲线很陡，以及CSS-in-JS框架之间的独特差异。我强烈建议使用并坚持使用样式化组件。</p>
<h3>连续性问题</h3>
<p><a href="https://medium.com/styled-components/announcing-primitives-support-for-truly-universal-component-systems-5772c7d14bc7" target="_blank" rel="noopener noreferrer"> Styled-components始于2017年，</a>而React开发者总是会问，“如果它不再被支持怎么办？”在生产中使用它们之前，您必须确保意识到这一点。</p>
<h3>个人偏好</h3>
<p>人们不喜欢改变。事实上，这是一个有效的论点，因为单独文档中的CSS仍然是web开发中持续时间最长的标准之一。</p>
<h3>社区关注</h3>
<p>有些人觉得样式组件社区很小，当他们遇到困难的bug、用例或错误时，他们可能无法尽快获得足够的支持。这也是有效的，但是您必须考虑样式化组件的锁定特性。</p>
<h3>表演</h3>
<p>事实是，如果您没有使用原生CSS内联样式，那么您选择用于样式化的任何库都有可能产生一些性能开销。然而，您获得的少量性能开销是您从样式化组件获得的能力和灵活性的代价。好的一面是styled-components专注于在每个新版本中提高库的性能。越来越好了。</p>
<h2>结论</h2>
<p>围绕样式组件有一个大规模增长的社区，有超过33，000个⭐️on github(t1)，大部分来自React开发者，这是非常令人鼓舞的，并且说明了长寿的前景。</p>
<p>它也是定期维护的，你可以<a href="https://www.styled-components.com/releases" target="_blank" rel="noopener noreferrer">点击这里</a>查看发布页面。如果你是一个CSS爱好者，你可以<a href="https://stateofcss.com/?source=announcement" target="_blank" rel="noopener noreferrer">看看这个目前遍布互联网的CSS调查状态</a>。编码快乐！</p><div class="code-block code-block-17">
<div class="blog-plug inline-plug react-plug" vwo-el-id="26283398190">
<h2 vwo-el-id="41600691720">使用LogRocket消除传统反应错误报告的噪音</h2>
<a href="https://lp.logrocket.com/blg/react-signup-issue-free" target="_blank" vwo-el-id="19356441070">LogRocket
</a><p>是一款React analytics解决方案，可保护您免受数百个误报错误警报的影响，只针对少数真正重要的项目。LogRocket告诉您React应用程序中实际影响用户的最具影响力的bug和UX问题。</p><a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="19356441380">
<img class="first-react-image alignnone size-full wp-image-46 jetpack-lazy-image jetpack-lazy-image--handled" src="../Images/f300c244a1a1cf916df8b4cb02bec6c6.png" vwo-el-id="18272717540" data-lazy-loaded="1" data-original-src="https://files.readme.io/27c94e7-Image_2017-06-05_at_9.46.04_PM.png"/>
</a>
<a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="19356441690">
<img class="second-react-image alignnone size-full wp-image-46 jetpack-lazy-image jetpack-lazy-image--handled" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" vwo-el-id="30720362350" data-lazy-loaded="1" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/>
</a>
<a href="https://lp.logrocket.com/blg/react-signup-issue-free" target="_blank" rel="noopener noreferrer" vwo-el-id="35866400580">LogRocket
</a><p>自动聚合客户端错误、反应错误边界、还原状态、缓慢的组件加载时间、JS异常、前端性能指标和用户交互。然后，LogRocket使用机器学习来通知您影响大多数用户的最具影响力的问题，并提供您修复它所需的上下文。</p><p vwo-el-id="28675661060">关注重要的React bug—<a class="signup" href="https://lp.logrocket.com/blg/react-signup-issue-free" target="_blank" rel="noopener noreferrer" vwo-el-id="40093418840">今天就试试LogRocket】。</a></p>
</div></div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
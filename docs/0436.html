<html>
<head>
<title>Building without bundling: How to do more with less - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>没有捆绑的建筑:如何用更少的博客做更多的事</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/building-without-bundling/#0001-01-01">https://blog.logrocket.com/building-without-bundling/#0001-01-01</a></blockquote><div><article class="article-post">
<p>您对代码库进行了更改。你点击了保存。你等着…等着…等着。</p>
<p>Web开发过去都是关于即时反馈的。但是随着webpack和Parcel等web bundlers的引入，web开发不再是保存和刷新浏览器那么简单。</p>
<p>当你使用bundler时，每次你只改变一行代码，你就不得不等待应用程序的整个部分重新构建。</p>
<p>我们要等这些捆扎机多久？这是我最近开始思考的事情。这让我很困扰，所以我决定弄清楚。</p>
<p>我在笔记本电脑上重温了旧网站，联系了老同事，得到了过去三年中我参与的四个主要应用程序的一些硬统计数据。</p>
<p>结果如下:</p>
<p><img data-attachment-id="5596" data-permalink="https://blog.logrocket.com/building-without-bundling/real-world-dev-performance-png/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2019/09/Real-World-Dev-Performance-png.png" data-orig-size="730,390" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Real-World Dev Performance-png" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2019/09/Real-World-Dev-Performance-png-300x160.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2019/09/Real-World-Dev-Performance-png.png" decoding="async" class="aligncenter wp-image-5596 size-full jetpack-lazy-image" src="../Images/0a45e63cc92bc988f43eb01deee29344.png" alt="A comparison of real-world dev performances across apps." data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2019/09/Real-World-Dev-Performance-png.png 730w, https://blog.logrocket.com/wp-content/uploads/2019/09/Real-World-Dev-Performance-png-300x160.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2019/09/Real-World-Dev-Performance-png.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/09/Real-World-Dev-Performance-png.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="5596" data-permalink="https://blog.logrocket.com/building-without-bundling/real-world-dev-performance-png/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2019/09/Real-World-Dev-Performance-png.png" data-orig-size="730,390" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Real-World Dev Performance-png" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2019/09/Real-World-Dev-Performance-png-300x160.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2019/09/Real-World-Dev-Performance-png.png" decoding="async" loading="lazy" class="aligncenter wp-image-5596 size-full" src="../Images/0a45e63cc92bc988f43eb01deee29344.png" alt="A comparison of real-world dev performances across apps." srcset="https://blog.logrocket.com/wp-content/uploads/2019/09/Real-World-Dev-Performance-png.png 730w, https://blog.logrocket.com/wp-content/uploads/2019/09/Real-World-Dev-Performance-png-300x160.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/09/Real-World-Dev-Performance-png.png"/></noscript>
<p>好的，让我们快速算一下。</p>
<p>平均来说，假设你每小时测试10次浏览器的变化，每3小时启动一次应用程序(改变分支，检测新文件等)。</p>
<p>因此，如果你连续一周不间断地使用App #3 (37秒的启动时间，2.5秒的重新编译时间)，那么一周40个小时将会引入大约25分钟的不间断等待时间。</p>
<p>对于App #1 (42秒的启动时间，11秒的重新编译时间),同样的计算会让你每周在你的开发环境中等待超过1小时(约82分钟)。</p>
<p>现在，将它乘以几年——这是花费在等待工具上的大量时间。当您考虑到JavaScript是一种浏览器已经理解的语言时，这个数字尤其令人沮丧。</p>
<p>我们这里不是编译Java。在很大程度上，我们正在编写浏览器友好的JavaScript。</p>
<h2>回收您的时间</h2>
<p>有没有可能去掉捆绑器，完全跳过这个开发者体验的噩梦？简单的演示在没有捆绑的情况下已经很好了，但是构建一个真正的、功能齐全的web应用程序怎么样呢？你能做到吗？</p>
<p>原来可以。现代的“非捆绑”开发不仅是可能的，而且它给你一个显著更快的开发者体验。</p>
<p>不再需要1000多个依赖文件夹，不再需要等待缓慢的启动，也不再需要重建阻碍发展的捆绑包。</p>
<p>为了向您展示我的意思，让我们来看一看今天在没有bundler的情况下构建一个现代web应用程序是什么样子的。</p>
<h2>最低可行的构建工具</h2>
<p>你最少需要的工具是什么？浏览器不能直接从你的计算机上加载文件，所以你首先需要一个本地静态资产服务器。</p>
<p><a href="https://www.npmjs.com/package/serve" target="_blank" rel="noopener noreferrer"> Serve </a>是一个流行的、简单的CLI，可以为你机器上的任何目录提供服务。它还带来了一些额外的好处，比如单页应用程序(SPA)支持和每当文件改变时自动实时重载。</p>
<p>通过在您的dev目录中运行<code>npx serve</code>,您可以很容易地构建一个本地服务CSS、HTML &amp; JavaScript的基本站点:</p>
<p class="glitch-embed-wrap"/>
<p>光靠这一套你就能走得很远。多亏了本地的<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Modules" target="_blank" rel="noopener noreferrer"> ES模块(ESM) </a>语法(在过去1年多的时间里，所有现代浏览器都支持该语法)，您可以使用<code>type="module"</code>脚本属性本地导入和导出JavaScript。</p>
<p>您可以用这种方式加载整个应用程序，完全不需要任何额外的工具或配置。</p><div class="code-block code-block-54">
<hr/>
<h3>更多来自LogRocket的精彩文章:</h3>

<hr/></div>
<p>然而，在某些时候，您会想要从npm获取一些代码。因此，让我们尝试使用其中一个本地导入来加载React框架，以便在我们的应用程序中使用。</p>
<h2>路障:国家预防机制</h2>
<pre>import React from 'react';
    
/* TypeError: Failed to resolve module specifier 'react' */</pre>
<p>“嗯……真奇怪。这在webpack上总是有效的…”</p>
<p><strong>未捆绑的路障#1 </strong>:浏览器还不支持通过包名导入(即通过“裸模块说明符”导入)。</p>
<p>Bundlers通过在构建时自动解析像“react”这样的说明符到正确的入口点文件，使现代web开发成为可能。</p>
<p>浏览器不知道“react”文件位于何处，也不知道node_modules目录位于服务器的哪个位置。</p>
<p>若要继续，您需要按包的真实文件路径导入包。</p>
<pre>import React from '/node_modules/react/index.js';

/* ReferenceError: process is not defined */</pre>
<p>“呃，现在怎么办？”</p>
<p><strong>未捆绑的路障#2 </strong>:大多数npm包——甚至主要是以web为中心的包——需要一个类似Node.js的环境，并且会在浏览器中失败。</p>
<p>您会看到一个“process is not defined”错误，因为React做的第一件事是检查<code>process.env.NODE_ENV</code>，这是一个Node.js专用的全局变量，通常也由bundler处理。</p>
<p>重要的是要记住，npm是作为Node.js生态系统开始的，它的包应该像Node.js上写的那样直接运行。</p>
<p>Bundlers为浏览器提供了这些节点机制，但代价是我们上面强调的所有这些额外的工具和等待时间。</p>
<p>即使大多数web友好的包也仍然会对任何依赖项使用相同的“裸模块说明符”模式，因为npm包没有办法知道它的依赖项将相对安装在哪里。</p>
<p>一些npm包(Preact、lit-html等)被编写为在安装后直接提供服务，但您或多或少会受限于那些没有依赖关系且仅由少数有思想的包维护者创作的包。</p>
<h2>重新定义捆绑器</h2>
<p>所以我们已经看到了为什么npm包在没有捆绑器的情况下不能在浏览器中运行。但是在之前的部分中，我们也看到我们自己的源代码在浏览器中运行得很好。</p>
<p>仅仅为了解决我们的依赖关系中的一个问题，就让我们的整个应用程序在每次变更时都通过一个耗时的开发管道，这看起来是不是有点过头了？</p>
<p>我开始<a href="https://github.com/pikapkg/web" target="_blank" rel="noopener noreferrer"> @pika/web </a>进行实验:如果现代JavaScript已经发展到拥有原生模块系统的地步，我们就不再需要通过捆绑器来运行它。在这种情况下，您能否重新确定捆绑销售的范围，只关注npm中的剩余问题？</p>
<p>依赖关系改变的频率要低得多——这个新工具只需要在npm/yarn安装后在您的<code>node_modules/</code>文件夹中运行，而不是在每次改变后。</p>
<p>@pika/web将任何npm包安装到在浏览器中运行的单个JavaScript文件中。当它运行时，内部包导入被解析为浏览器能够理解的内容，任何坏的节点-ism都被转换为在浏览器中运行。</p>
<p><img data-attachment-id="5599" data-permalink="https://blog.logrocket.com/building-without-bundling/pika-web/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2019/09/pika-web.png" data-orig-size="730,233" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="pika-web" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2019/09/pika-web-300x96.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2019/09/pika-web.png" decoding="async" class="aligncenter wp-image-5599 size-full jetpack-lazy-image" src="../Images/f1c8f9cfe424953d27b9a027d8318a31.png" alt="How @pika/web installs any npm package into a single JavaScript file that runs in the browser. " data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2019/09/pika-web.png 730w, https://blog.logrocket.com/wp-content/uploads/2019/09/pika-web-300x96.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2019/09/pika-web.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/09/pika-web.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="5599" data-permalink="https://blog.logrocket.com/building-without-bundling/pika-web/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2019/09/pika-web.png" data-orig-size="730,233" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="pika-web" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2019/09/pika-web-300x96.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2019/09/pika-web.png" decoding="async" loading="lazy" class="aligncenter wp-image-5599 size-full" src="../Images/f1c8f9cfe424953d27b9a027d8318a31.png" alt="How @pika/web installs any npm package into a single JavaScript file that runs in the browser. " srcset="https://blog.logrocket.com/wp-content/uploads/2019/09/pika-web.png 730w, https://blog.logrocket.com/wp-content/uploads/2019/09/pika-web-300x96.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/09/pika-web.png"/></noscript>
<p>它是一个只关注依赖项的安装时工具，不需要任何其他的应用程序构建步骤。</p>
<p>为了获得最佳效果，您应该使用包含本机ESM语法的现代软件包。</p>
<p>NPM有超过70，000个这样的现代包装。现在，您可能已经在web应用程序中使用了一些。您可以访问<a href="https://www.pika.dev/" target="_blank" rel="noopener noreferrer"> pika.dev </a>来搜索并找到任何用例的版本。</p>
<p>如果你找不到你想要的包，@pika/web也可以处理大多数非ESM的传统NPM包。</p>
<h2>Pika快速入门</h2>
<p>让我们使用@pika/web来安装较小的ESM替代React: Preact。在新项目中，运行以下命令:</p>
<pre>npm init                     # Create an empty package.json, if you haven't already
npm install preact --save    # Install preact to your node_modules directory
npx @pika/web                # Install preact.js to a new web_modules directory
serve .                      # Serve your application</pre>
<p>现在，您的应用程序可以直接在浏览器中使用以下导入，而无需构建步骤:</p>
<pre>import {h, render} from '/web_modules/preact.js';
render(h('h1', null, 'Hello, Preact!'), document.body); /* &lt;h1&gt;Hello, Preact!&lt;/h1&gt; */</pre>
<p>试着在你的浏览器中运行一下，自己看看。继续添加依赖项，根据需要将它们导入到您的应用程序中，然后观看<code>serve</code>实时重新加载您的站点以查看即时反映的更改。</p>
<h2>行动中的鼠兔</h2>
<p>没有人喜欢直接使用raw <code>h()</code>调用。JSX是React &amp; Preact的一个流行的语法扩展，但它需要一个像Babel或<a href="https://blog.logrocket.com/set-up-a-typescript-gatsby-app/" target="_blank" rel="noopener noreferrer"> TypeScript </a>这样的构建步骤才能在浏览器中工作。</p>
<p>幸运的是，Preact公司的杰森·米勒创造了一个可以直接在浏览器中运行的替代JSX的网站——<code>htm</code>:</p>
<pre>import {h, render} from '/web_modules/preact.js';
import htm from '/web_modules/htm.js';
const html = htm.bind(h);
render(html`&lt;h1&gt;Hello, ${"Preact!"}&lt;/h1&gt;`, document.body)</pre>
<p>同样，如果你想将CSS应用到你的UI组件中，你可以使用一个web原生的CSS库，比如CSZ:</p>
<pre>import css from '/web_modules/csz.js';
// Loads style.css onto the page, scoped to the returned class name
const className = css`/style.css`;
// Apply that class name to your component to apply those styles
render(html`&lt;h1 class=${headerClass}&gt;Hello, ${"Preact!"}&lt;/h1&gt;`, document.body);</pre>
<h2>我想念我的构建工具</h2>
<p>围绕这个“未建成”的开发项目，人们越来越兴奋。如果您使用@pika/web来安装现代npm包，您将不再需要等待构建步骤或重新编译步骤。</p>
<p>您唯一需要等待的是本地开发服务器上10-20毫秒的实时重新加载时间。</p>
<p>您仍然可以像Babel一样选择添加一个<strong>构建</strong>步骤，甚至可以不添加一个<strong>捆绑</strong>步骤。</p>
<p>构建工具能够在几毫秒内编译单个文件的更改，TypeScript甚至有一个<code>--incremental</code>模式，通过从您上次停止的地方继续来保持启动时间快速。</p>
<pre>/* JavaScript + Babel */
import {h, render} from '/web_modules/preact.js';
render(&lt;h1&gt;Hello, Preact!&lt;/h1&gt;, document.body);
/* CLI */
babel src/ --out-dir js/ --watch</pre>
<p>有了Babel，您还可以获得@pika/web Babel插件，它可以自动处理裸模块说明符转换(" preact" → "web_modules/preact.js ")。</p>
<pre>/* JavaScript + Babel + "@pika/web/assets/babel-plugin.js" */
    import {h, render} from 'preact';
    render(&lt;h1&gt;Hello, Preact!&lt;/h1&gt;, document.body);</pre>
<p>我们最终的代码片段与您在捆绑的web应用程序中看到的没有什么区别。</p>
<p>但是通过移除捆绑器，我们能够从我们的构建管道中提取出数百个依赖项，从而实现巨大的开发时迭代加速。</p>
<p>此外，@pika/web README为那些对使用React而不是Preact感兴趣的人提供了说明。</p>
<h2>CDNs:完全避免依赖管理</h2>
<p>内容交付网络(cdn)能够为公众消费提供资产，这意味着它们也能够为我们修复糟糕的npm包。</p>
<p>cdn对于完全依赖管理越来越受欢迎，一些项目如Deno将它们用于所有依赖管理。</p>
<p>在浏览器中直接运行npm软件包时，有两个选项值得一试:</p>
<ul>
<li><strong> UNPKG: </strong>一个流行的CDN，提供任何npm包的逐文件内容。附带了一个非常简洁的<code>?module</code>标志，它将从裸说明符(例如<code>lodash-es</code>)到相对UNPKG URLs(例如<code>lodash-es/v3.1.0/lodash.js</code>)的导入重写。</li>
<li>Pika CDN:Pika项目也有一个CDN，但是它不是为单个文件服务，而是为整个单个文件包服务。把它想象成一个托管的@pika/web。这些单文件包的加载速度比UNPKG快得多，CDN足够智能，可以为您提供浏览器所需的最少数量的聚合填充/传输。但是缺点是不能通过内部包文件导入——目前，只能导入整个包。</li>
</ul>
<h2>遗留浏览器呢？</h2>
<p>围绕非捆绑web开发的最大担忧是它只能在现代浏览器上运行。Caniuse.com报告称，全球86%的用户支持这种现代ESM语法，包括过去1-2年发布的所有主流浏览器。</p>
<p>但仍有14%的用户使用IE11或UC浏览器(一种在亚洲流行的网络浏览器)等传统浏览器。</p>
<p><img data-attachment-id="5600" data-permalink="https://blog.logrocket.com/building-without-bundling/javascript-modules-via-script-tag/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2019/09/JavaScript-modules-via-script-tag.png" data-orig-size="1914,884" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="JavaScript modules via script tag" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2019/09/JavaScript-modules-via-script-tag-300x139.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2019/09/JavaScript-modules-via-script-tag-1024x473.png" decoding="async" class="aligncenter wp-image-5600 jetpack-lazy-image" src="../Images/641098cf8259d40c30095f4522178fd0.png" alt="This graph displays load times for JavaScript modules across different browsers." data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2019/09/JavaScript-modules-via-script-tag.png 1914w, https://blog.logrocket.com/wp-content/uploads/2019/09/JavaScript-modules-via-script-tag-300x139.png 300w, https://blog.logrocket.com/wp-content/uploads/2019/09/JavaScript-modules-via-script-tag-768x355.png 768w, https://blog.logrocket.com/wp-content/uploads/2019/09/JavaScript-modules-via-script-tag-1024x473.png 1024w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2019/09/JavaScript-modules-via-script-tag.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/09/JavaScript-modules-via-script-tag.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="5600" data-permalink="https://blog.logrocket.com/building-without-bundling/javascript-modules-via-script-tag/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2019/09/JavaScript-modules-via-script-tag.png" data-orig-size="1914,884" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="JavaScript modules via script tag" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2019/09/JavaScript-modules-via-script-tag-300x139.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2019/09/JavaScript-modules-via-script-tag-1024x473.png" decoding="async" loading="lazy" class="aligncenter wp-image-5600" src="../Images/641098cf8259d40c30095f4522178fd0.png" alt="This graph displays load times for JavaScript modules across different browsers." srcset="https://blog.logrocket.com/wp-content/uploads/2019/09/JavaScript-modules-via-script-tag.png 1914w, https://blog.logrocket.com/wp-content/uploads/2019/09/JavaScript-modules-via-script-tag-300x139.png 300w, https://blog.logrocket.com/wp-content/uploads/2019/09/JavaScript-modules-via-script-tag-768x355.png 768w, https://blog.logrocket.com/wp-content/uploads/2019/09/JavaScript-modules-via-script-tag-1024x473.png 1024w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/09/JavaScript-modules-via-script-tag.png"/></noscript>
<p>对于一些网站——尤其是那些专注于移动和非企业用户的网站——这可能没问题。例如，https://www.pika.dev 通常拥有更现代的用户群，在过去一年的运营中，我们只收到过一次关于使用现代JavaScript的投诉。</p>
<p>但是，如果您需要针对遗留浏览器或者担心加载性能，那么没有什么可以阻止您在生产中使用bundler。事实上，这种设置可以让您两全其美:一个本地开发环境可以让您快速迭代，另一个较慢的生产构建管道由webpack或package提供支持，面向较旧的浏览器。</p>
<pre> &lt;!-- Modern browsers load the unbundled application --&gt;
 &lt;script type="module" src="/js/unbundled-app-entrypoint.js"&gt;&lt;/script&gt;
 &lt;!-- Legac browsers load the legacy bundled application --&gt;
 &lt;script nomodule src="/dist/bundled-app-entrypoint.js"&gt;&lt;/script&gt;</pre>
<h2>结论</h2>
<p>很长时间以来，你第一次可以选择是否使用捆绑器。</p>
<p>像Pika这样的项目和@pika/web这样的工具都是为了让您重新拥有这种选择。他们让每个人都有这样的选择，尤其是那些对JavaScript、bundler配置、1000多个依赖项安装或bundler插件生态系统中出现的所有突破性变化和奇怪的东西还不太有信心的人。</p>
<p>我预计未来几年的web开发将会非常简单:为高级用户提供高级工具支持，同时降低其他人的门槛。</p><div class="code-block code-block-2">
<div class="blog-plug base-cta"><h2>使用<a class="signup" href="https://lp.logrocket.com/blg/signup" target="_blank" rel="noopener noreferrer"> LogRocket </a>消除传统错误报告的干扰</h2>
<a href="https://lp.logrocket.com/blg/signup" class="signup" target="_blank" rel="noopener noreferrer"><img class="alignnone size-full wp-image-46 jetpack-lazy-image" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/><noscript><img data-lazy-fallback="1" class="alignnone size-full wp-image-46" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/></noscript></a>
<p><a href="https://lp.logrocket.com/blg/signup" target="_blank" rel="noopener noreferrer"> LogRocket </a>是一个数字体验分析解决方案，它可以保护您免受数百个假阳性错误警报的影响，只针对几个真正重要的项目。LogRocket会告诉您应用程序中实际影响用户的最具影响力的bug和UX问题。</p>
<p>然后，使用具有深层技术遥测的会话重放来确切地查看用户看到了什么以及是什么导致了问题，就像你在他们身后看一样。</p>
<p>LogRocket自动聚合客户端错误、JS异常、前端性能指标和用户交互。然后LogRocket使用机器学习来告诉你哪些问题正在影响大多数用户，并提供你需要修复它的上下文。</p>
<p>关注重要的bug—<a class="signup" href="https://lp.logrocket.com/blg/signup-issue-free" target="_blank" rel="noopener noreferrer">今天就试试LogRocket】。</a></p></div></div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
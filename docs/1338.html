<html>
<head>
<title>Building a GraphQL server with FastAPI - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>用FastAPI构建GraphQL服务器</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/building-a-graphql-server-with-fastapi/#0001-01-01">https://blog.logrocket.com/building-a-graphql-server-with-fastapi/#0001-01-01</a></blockquote><div><article class="article-post">
<p>FastAPI是一个用Python构建web APIs的高性能框架。它简单直观的本质使得使用很少的样板代码快速开发健壮的web APIs变得很容易。在本文中，我们将介绍FastAPI以及如何用它来设置GraphQL服务器。</p>
<p>从<a href="https://fastapi.tiangolo.com/" target="_blank" rel="noopener noreferrer">官方文档</a>来看，使用FastAPI构建web应用程序减少了大约40%的开发人员引起的错误，这是通过使用Python 3.6类型声明实现的。凭借其所有特性，包括交互式API文档的<a href="https://fastapi.tiangolo.com/tutorial/path-params/?h=+documenta#documentation" target="_blank" rel="noopener noreferrer">自动生成</a>，用Python构建web应用程序从未如此简单。</p>
<h2>设置我们的应用程序</h2>
<p>在我们开始之前，让我们通过在我们的终端上运行以下命令来确认我们已经安装了Python 3.6+:</p>
<pre>python --version
</pre>
<p>如果这返回一个错误，<a href="https://www.python.org/downloads/" target="_blank" rel="noopener noreferrer">点击这里</a>下载Python并安装在您的本地机器上。Python 3.4+安装默认带有pip，但是，我们需要Python 3.6+才能运行FastAPI。Pip是首选的Python包管理器，我们将使用它来安装FasAPI应用程序的支持模块。</p>
<p>安装Python和pip后，让我们在终端上运行以下命令，将FastAPI添加到我们的机器中:</p>
<pre>pip install fastapi
</pre>
<p>我们还需要Uvicorn，一个ASGI(异步服务器网关接口)服务器来服务我们的应用程序。让我们在终端上运行以下命令来安装它:</p>
<pre>pip install uvicorn
</pre>
<p>完成后，我们可以继续为我们的应用程序创建一个新目录。姑且称之为<code>fastapi-graphql</code>。在我们的新目录中，我们将创建一个名为<code>main.py</code>的新文件。这将是我们服务器的索引文件。</p>
<h2>GraphQL基础:查询和模式</h2>
<h3>你想要什么</h3>
<p>在GraphQL中，<a href="https://blog.logrocket.com/graphql-queries-in-simple-terms/" target="_blank" rel="noopener noreferrer">查询</a>用于获取数据，就像REST API架构中的GET请求一样。然而，使用GraphQL查询，我们可以选择请求我们想要的东西。例如，让我们假设我们有一个教育课程的API。对我们的API的查询如下所示:</p>
<pre>{
  getCourse {
    id
    title
    instructor
    publishDate
  }
}
</pre>
<p>当我们发送这个查询时，我们应该收到一个响应，其中包含来自我们的API的课程及其属性，按以下顺序排列:<code>id</code>、<code>title</code>、<code>instructor</code>和<code>publishDate</code>:</p>
<pre>{
  "data": {
    "getCourse": [
      {
        "id": "1",
        "title": "Python variables explained",
        "instructor": "Tracy Williams",
        "publishDate": "12th May 2020"
      },
      {
        "id": "2",
        "title": "How to use functions in Python",
        "instructor": "Jane Black",
        "publishDate": "9th April 2018"
      }
    ]
  }
}
</pre>
<p>可选地，我们可以要求我们的API返回一个课程列表，但是这次只使用<code>title</code>属性:</p>
<pre>{
  getCourse {
    title
  }
}
</pre>
<p>我们应该得到类似这样的响应:</p>
<pre>{
  "data": {
    "getCourse": [
      {
        "title": "Python variables explained"
      },
      {
        "title": "How to use functions in Python"
      }
    ]
  }
}
</pre>
<p>这种灵活性是用GraphQL构建的应用程序具有高度可扩展性的原因之一，它是通过GraphQL中的类型声明实现的。</p>
<h3>GraphQL模式</h3>
<p><a href="https://blog.logrocket.com/speeding-up-changes-to-the-graphql-schema/">模式</a>描述了我们的GraphQL服务，它包含什么数据，以及数据的格式。从我们的查询中，我们已经看到，我们可以指定哪些数据将被发送给我们，以及我们希望这些数据如何呈现。这是因为我们的GraphQL API已经包含了所有数据的模式，该模式包含了所有可用的字段、子字段及其数据类型。</p>
<p>为了演示这一点，我们将在根目录中创建一个<code>schemas.py</code>文件，我们将使用它来存放所有的数据字段。先说课程类型。这应该包含特定课程的所有信息，从我们上面的示例查询来看，一门课程包括字段<code>id</code>、<code>title</code>、<code>instructor</code>和<code>publish_date</code>。我们将继续更新我们的<code>schemas.py</code>文件，如下所示:</p>
<pre>from graphene import String, ObjectType

class CourseType(ObjectType):
  id = String(required=True)
  title = String(required=True)
  instructor = String(required=True)
  publish_date = String()
</pre>
<p>在我们的<code>schemas.py</code>文件中，我们从从<code>graphene</code>导入类型<code>String</code>和<code>ObjectType</code>开始。Graphene是一个用于构建GraphQL模式和类型的Python库。让我们在终端上运行以下命令来安装它:</p>
<pre>pip install graphene
</pre>
<p>在我们成功地从<code>graphene</code>导入了<code>String</code>和<code>ObjectType</code>之后，我们继续用括号中的导入的<code>ObjectType</code>定义了一个类<code>CourseType</code>。我们将几乎所有的GraphQL类型都声明为对象类型。</p>
<p>我们做的下一件事是为我们的<code>CourseType</code>创建不同的字段，并且我们为每个字段使用了<code>String</code>类型。来自<code>graphene</code>的一些其他类型包括<code>Int</code>、<code>Enum</code>、<code>Date</code>、<code>List</code>和<code>Boolean</code>。</p>
<p>注意，我们还在<code>String</code>类型中为<code>id</code>、<code>title</code>和<code>instructor</code>添加了一个<code>required</code>参数。这意味着如果不包含这些字段，我们将无法向我们的GraphQL服务添加课程，尽管我们在进行查询时仍然可以排除它们中的任何一个。</p>
<h2>设置临时数据库</h2>
<p>现在我们有了模式，我们还需要一个存储和检索课程数据的地方。对于这个演示，我们将使用一个JSON数据库。然而，FastAPI既支持<a href="https://fastapi.tiangolo.com/tutorial/sql-databases/?h=+databases" target="_blank" rel="noopener noreferrer">关系数据库</a>也支持<a href="https://fastapi.tiangolo.com/advanced/nosql-databases/?h=+databases" target="_blank" rel="noopener noreferrer">非关系数据库</a>，如PostgreSQL、MySQL、MongoDB、ElasticSearch等。</p>
<p>让我们在根目录中创建一个<code>courses.json</code>文件，并将下面的代码块粘贴到其中:</p>
<pre>[
  {
    "id": "1",
    "title": "Python variables explained",
    "instructor": "Tracy Williams",
    "publish_date": "12th May 2020"
  },
  {
    "id": "2",
    "title": "How to use functions in Python",
    "instructor": "Jane Black",
    "publish_date": "9th April 2018"
  },
  {
    "id": "3",
    "title": "Asynchronous Python",
    "instructor": "Matthew Rivers",
    "publish_date": "10th July 2020"
  },
  {
    "id": "4",
    "title": "Build a REST API",
    "instructor": "Babatunde Mayowa",
    "publish_date": "3rd March 2016"
  }
]
</pre>
<p>我们将能够使用我们的GraphQL API来修改和检索这个文件中的数据。</p>
<h2>创建我们的查询解析器</h2>
<p>解析器是我们的GraphQL服务用来与我们的模式和数据源进行交互的。为了创建用于获取课程的查询解析器，我们将从在我们的<code>main.py</code>文件中导入<code>fastapi</code>开始:</p>
<pre>from fastapi import FastAPI
</pre>
<p>接下来，让我们导入我们将在查询解析器中使用的相关类型，就像我们在<code>schemas.py</code>文件中所做的那样:</p>
<pre>...
from graphene import ObjectType, List, String, Schema
</pre>
<p>注意，我们添加了两个新类型:<code>List</code>，我们将把它用作<code>CourseType</code>的包装器；和<code>Schema</code>，我们将使用它来执行操作。</p>
<p>我们还将从<code>graphql.execution.executors.asyncio</code>导入<code>AsyncioExecutor</code>，这将使我们能够在我们的GraphQL服务中进行异步调用；<code>GraphQLApp</code>出自<code>starlette.graphql</code>；我们<code>schemas.py</code>文件中的<code>CourseType</code>:</p>
<pre>...
from graphql.execution.executors.asyncio import AsyncioExecutor
from starlette.graphql import GraphQLApp
from schemas import CourseType
</pre>
<p>最后，让我们导入内置的<code>json</code>包来处理我们的<code>courses.json</code>文件:</p>
<pre>...
import json
</pre>
<p>我们的最终导入块应该如下所示:</p>
<pre>from fastapi import FastAPI
from graphene import ObjectType, List, String, Schema
from graphql.execution.executors.asyncio import AsyncioExecutor
from starlette.graphql import GraphQLApp
from schemas import CourseType
import json
</pre>
<p>接下来，让我们通过将以下代码块添加到我们的<code>main.py</code>文件来创建我们的查询:</p>
<pre>...
class Query(ObjectType):
  course_list = None
  get_course = List(CourseType)
  async def resolve_get_course(self, info):
    with open("./courses.json") as courses:
      course_list = json.load(courses)
    return course_list
</pre>
<p>在上面的块中，我们从从对象类型创建一个类<code>Query</code>开始，然后我们在<code>line 3</code>上初始化我们的<code>course_list</code>变量。这是我们存储课程数据的地方。</p>
<p>由于我们将在一个列表中返回不同的课程对象，我们使用从<code>graphene</code>导入的<code>List</code>类型来包装我们的<code>CourseType</code>，然后将它赋给<code>line 4</code>上的<code>get_course</code>变量。这将是我们查询的名称。</p>
<p>需要注意的是，当在GraphQL客户端中进行查询时，我们需要以camel case的形式提供名称，即<code>getCourse</code>而不是<code>get_course</code>。</p>
<p>接下来，我们在<code>line 5</code>上为<code>get_course</code>查询创建了一个解析器方法。解析器方法的名称应该以前缀<code>resolve</code>开头，后面跟着查询名称——在本例中是<code>get_course</code>——然后用下划线隔开。</p>
<p>resolver方法还需要两个位置参数，这已经包含在方法定义中了。在<code>lines</code> <code>6-8</code>上，我们从我们的<code>courses.json</code>文件中加载数据，将其分配给<code>course_list</code>，然后返回变量。</p>
<h2>启动基于FastAPI的GraphQL服务器</h2>
<p>现在我们已经创建了GraphQL查询，让我们初始化FastAPI并将GraphQL服务分配给索引路由。</p>
<pre>...
app = FastAPI()
app.add_route("/", GraphQLApp(
  schema=Schema(query=Query),
  executor_class=AsyncioExecutor)
)
</pre>
<p>接下来，让我们在终端上运行以下命令来启动FastAPI应用程序:</p>
<pre><code>uvicorn main:app --reload
</code></pre>
<p>我们应该会得到类似这样的成功消息:</p>
<pre>Uvicorn running on http://127.0.0.1:8000 (Press CTRL+C to quit)
Started reloader process
Started server process
Waiting for application startup.
Application startup complete.
</pre>
<p>我们可以通过导航到<code><a href="http://127.0.0.1:8000" rel="nofollow">http://127.0.0.1:8000</a></code>来测试我们的GraphQL服务器。我们应该会看到这样一个页面:</p>
<p><img data-attachment-id="29402" data-permalink="https://blog.logrocket.com/building-a-graphql-server-with-fastapi/blank-graphql-server-page/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/11/blank-graphql-server-page.png" data-orig-size="730,242" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Blank GraphQL server page" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/11/blank-graphql-server-page-300x99.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/11/blank-graphql-server-page.png" decoding="async" class="aligncenter size-full wp-image-29402 jetpack-lazy-image" src="../Images/1e13939faf4b2c83b5e99abd329c7ff7.png" alt="A Blank GraphQL Server Page" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2020/11/blank-graphql-server-page.png 730w, https://blog.logrocket.com/wp-content/uploads/2020/11/blank-graphql-server-page-300x99.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2020/11/blank-graphql-server-page.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/11/blank-graphql-server-page.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="29402" data-permalink="https://blog.logrocket.com/building-a-graphql-server-with-fastapi/blank-graphql-server-page/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/11/blank-graphql-server-page.png" data-orig-size="730,242" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Blank GraphQL server page" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/11/blank-graphql-server-page-300x99.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/11/blank-graphql-server-page.png" decoding="async" loading="lazy" class="aligncenter size-full wp-image-29402" src="../Images/1e13939faf4b2c83b5e99abd329c7ff7.png" alt="A Blank GraphQL Server Page" srcset="https://blog.logrocket.com/wp-content/uploads/2020/11/blank-graphql-server-page.png 730w, https://blog.logrocket.com/wp-content/uploads/2020/11/blank-graphql-server-page-300x99.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/11/blank-graphql-server-page.png"/></noscript>
<p>让我们将以下查询粘贴到左侧窗格中，并通过单击run按钮进行API调用:</p>
<pre>{
  getCourse {
    id
    title
    instructor
    publishDate
  }
}
</pre>
<p>我们应该得到类似这样的响应:</p>
<p><img data-attachment-id="29403" data-permalink="https://blog.logrocket.com/building-a-graphql-server-with-fastapi/graphql-server-page-response/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/11/graphql-server-page-response.png" data-orig-size="730,277" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="GraphQL server page response" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/11/graphql-server-page-response-300x114.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/11/graphql-server-page-response.png" decoding="async" class="aligncenter size-full wp-image-29403 jetpack-lazy-image" src="../Images/228c546b723948cdad4f01dae5027a68.png" alt="The GraphQL Server Page Response" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2020/11/graphql-server-page-response.png 730w, https://blog.logrocket.com/wp-content/uploads/2020/11/graphql-server-page-response-300x114.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2020/11/graphql-server-page-response.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/11/graphql-server-page-response.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="29403" data-permalink="https://blog.logrocket.com/building-a-graphql-server-with-fastapi/graphql-server-page-response/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/11/graphql-server-page-response.png" data-orig-size="730,277" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="GraphQL server page response" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/11/graphql-server-page-response-300x114.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/11/graphql-server-page-response.png" decoding="async" loading="lazy" class="aligncenter size-full wp-image-29403" src="../Images/228c546b723948cdad4f01dae5027a68.png" alt="The GraphQL Server Page Response" srcset="https://blog.logrocket.com/wp-content/uploads/2020/11/graphql-server-page-response.png 730w, https://blog.logrocket.com/wp-content/uploads/2020/11/graphql-server-page-response-300x114.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/11/graphql-server-page-response.png"/></noscript>
<h2>仅获取一门课程</h2>
<p>让我们探索一下如何通过查询来获取一门课程的数据。我们将添加一个<code>id</code>参数到我们的查询中，让我们的GraphQL服务器知道我们只需要匹配那个<code>id</code>的课程。为了实现这一点，让我们用下面的代码替换我们的<code>Query</code>类:</p>
<pre>class Query(ObjectType):
  course_list = None
  get_course = Field(List(CourseType), id=String())
  async def resolve_get_course(self, info, id=None):
    with open("./courses.json") as courses:
      course_list = json.load(courses)
    if (id):
      for course in course_list:
        if course['id'] == id: return [course]
    return course_list
</pre>
<p>在新的<code>Query</code>类的<code>line 3</code>上，我们将<code>get_course</code>的值包装在一个<code>Field</code>类型中，这允许我们添加查询参数。这里，我们添加了一个类型为<code>String</code>的<code>id</code>参数。我们还在<code>resolve_get_course()</code>方法中包含了<code>id</code>参数，并给了它一个默认值<code>None</code>，使它成为可选的。</p>
<p>在<code>lines</code> <code>7-9</code>上，我们添加了一个条件，如果提供的话，它将只返回与<code>id</code>匹配的课程。在我们继续之前，我们还需要将<code>Field</code>型添加到我们的<code>graphene</code>进口中:</p>
<pre>from graphene import ObjectType, List, String, Schema, Field
</pre>
<p>现在，我们可以通过以下查询只获取一个与<code>id</code>匹配的课程:</p>
<pre>{
  getCourse(id: "2") {
    id
    title
    instructor
    publishDate
        }
}
</pre>
<p>我们应该得到这样的回应:</p>
<pre>{
  "data": {
    "getCourse": [
      {
        "id": "2",
        "title": "How to use functions in Python",
        "instructor": "Jane Black",
        "publishDate": "9th April 2018"
      }
    ]
  }
}
</pre>
<h2>GraphQL突变</h2>
<p>我们已经看到了如何用FastAPI设置我们的GraphQL服务器并从中获取数据。现在，让我们看看如何使用GraphQL变体向我们的数据存储添加新的课程或更新现有的课程。让我们从将<code>Mutation</code>类型添加到我们的<code>graphene</code>导入开始:</p>
<pre>from graphene import ObjectType, List, String, Schema, Field, Mutation
</pre>
<p>现在我们可以从<code>Mutation</code>类型创建一个名为<code>CreateCourse</code>的类:</p>
<pre>class CreateCourse(Mutation):
  course = Field(CourseType)

  class Arguments:
    id = String(required=True)
    title = String(required=True)
    instructor = String(required=True)
</pre>
<p>在我们的<code>CreateCourse</code>类中，我们开始为我们的课程创建一个变量，我们将它包装在<code>Field</code>类中。这是我们将在成功创建课程后返回给用户的内容。</p>
<p>然后我们继续为我们的突变参数创建一个类。我们这里的论点是<code>id</code>、<code>title</code>和<code>instructor</code>。我们需要在进行<code>CreateCourse</code>突变时提供这些信息。</p>
<p>接下来，我们需要一个<code>mutate</code>方法来创建课程。在这里，我们将使用用户提供的参数在我们的数据存储中创建新的课程。在这种情况下，我们将改变我们的<code>courses.json</code>文件。然而，在生产应用程序中，您可能需要一个数据库，正如前面提到的，FastAPI支持关系和非关系数据库。</p>
<p>让我们创建我们的<code>mutate</code>方法。注意，它必须被命名为<code>mutate</code>，因为这是我们的GraphQL服务所期望的:</p>
<pre>class CreateCourse(Mutation):
  ...
  async def mutate(self, info, id, title, instructor):
    with open("./courses.json", "r+") as courses:
      course_list = json.load(courses)
      course_list.append({"id": id, "title": title, "instructor": instructor})
      courses.seek(0)
      json.dump(course_list, courses, indent=2)
    return CreateCourse(course=course_list[-1])
</pre>
<p>在我们的<code>mutate</code>方法的return语句中，我们调用了<code>CreateCourse</code>类，并用括号将新创建的课程赋给我们之前声明的<code>course</code>变量。这是我们的GraphQL API将作为对突变请求的响应返回给用户的内容。</p><div class="code-block code-block-54">
<hr/>
<h3>更多来自LogRocket的精彩文章:</h3>

<hr/></div>
<p>现在我们有了自己的<code>CreateCourse</code>类，让我们从<code>ObjectType</code>创建一个名为<code>Mutation</code>的新类。我们会把所有的突变储存在这里:</p>
<pre>class Mutation(ObjectType):
  create_course = CreateCourse.Field()
</pre>
<p>完成后，我们可以将我们的<code>Mutation</code>类添加到我们的<code>app.add_route()</code>函数调用中的<code>Schema</code>:</p>
<pre>app.add_route("/", GraphQLApp(
  schema=Schema(query=Query, mutation=Mutation),
  executor_class=AsyncioExecutor)
)
</pre>
<p>我们现在可以通过在GraphQL客户机中运行以下查询来测试这一点:</p>
<pre>mutation {
  createCourse(
    id: "11" 
    title: "Python Lists" 
    instructor: "Jane Melody"
  ) {
    course {
      id
      title
      instructor
    }
  }
} 
</pre>
<p>我们应该得到这样的回应:</p>
<pre>{
  "data": {
    "createCourse": {
      "course": {
        "id": "11",
        "title": "Python Lists",
        "instructor": "Jane Melody"
      }
    }
  }
}
</pre>
<h2>处理请求错误</h2>
<p>让我们看看如何通过为预先存在的id添加验证来处理应用程序中的错误。如果一个用户试图用一个已经存在于我们的数据存储中的ID创建一个课程，我们的GraphQL服务器应该用错误消息来响应:<code>Course with provided id already exists!</code></p>
<p>就在我们将新课程添加到数据存储区的<code>CreateCourse</code> mutate函数之前，让我们粘贴以下代码:</p>
<pre>...
for course in course_list:
  if course['id'] == id:
    raise Exception('Course with provided id already exists!')
</pre>
<p>上面，我们遍历了我们的数据存储库<code>course_list</code>，并检查是否有一个现有的球场与即将到来的球场具有相同的<code>id</code>。如果我们有一个匹配，那么应该抛出一个异常。</p>
<p>根据我们为应用程序选择的数据库和<a href="https://fastapi.tiangolo.com/tutorial/sql-databases/?h=+orm#orms" target="_blank" rel="noopener noreferrer"> ORM </a>，检查是否有预先存在的值的过程可能会有所不同。但是，当出现异常时，GraphQL总是会返回一个错误。随着代码的新变化，我们的<code>CreateCourse</code>变异类应该是这样的:</p>
<pre>class CreateCourse(Mutation):
  course = Field(CourseType)

  class Arguments:
    id = String(required=True)
    title = String(required=True)
    instructor = String(required=True)
    publish_date = String()

  async def mutate(self, info, id, title, instructor):
    with open("./courses.json", "r+") as courses:
      course_list = json.load(courses)

      for course in course_list:
        if course['id'] == id:
          raise Exception('Course with provided id already exists!')

      course_list.append({"id": id, "title": title, "instructor": instructor})
      courses.seek(0)
      json.dump(course_list, courses, indent=2)
    return CreateCourse(course=course_list[-1])
</pre>
<p>现在，我们可以通过尝试使用预先存在的<code>id</code>创建一个新课程来测试这一点。让我们在GraphQL客户端中运行最后一个<code>CreateCourse</code>请求的精确变异:</p>
<pre>mutation {
  createCourse(
    id: "11" 
    title: "Python Lists" 
    instructor: "Jane Melody"
  ) {
    course {
      id
      title
      instructor
    }
  }
}
</pre>
<p>我们应该得到这样的回应:</p>
<pre>{
  "data": {
    "createCourse": null
  },
  "errors": [
    {
      "message": "Course with provided id already exists!",
      "locations": [
        {
          "line": 2,
          "column": 3
        }
      ],
      "path": [
        "createCourse"
      ]
    }
  ]
}
</pre>
<h2>结论</h2>
<p>在本文中，我们学习了FastAPI的基础知识，以及如何使用它来设置GraphQL服务器。这两种技术的结合给web开发带来了真正激动人心的体验。</p>
<p>使用GraphQL，我们能够使复杂的查询相对容易编写，同时让web客户端能够准确地询问他们想要的内容。使用FastAPI，我们可以用很少的样板代码构建健壮、高性能的GraphQL服务器。</p>
<p>这里有一个<a href="https://github.com/ebenezerdon/fastapi-graphql" target="_blank" rel="noopener noreferrer">链接</a>到我们演示课程的回购，如果你需要任何帮助，请随时在<a href="https://www.linkedin.com/in/ebenezerdon/" target="_blank" rel="noopener noreferrer"> LinkedIn </a>上联系我。</p><div class="code-block code-block-24">
<div class="blog-plug inline-plug graphql-plug"><h2>监控生产中失败和缓慢的GraphQL请求</h2><p>虽然GraphQL有一些调试请求和响应的特性，但确保GraphQL可靠地为您的生产应用程序提供资源是一件比较困难的事情。如果您对确保对后端或第三方服务的网络请求成功感兴趣，</p><a href="https://lp.logrocket.com/blg/graphql-signup" target="_blank">try LogRocket</a><p>.</p><a class="signup" href="https://lp.logrocket.com/blg/graphql-signup" target="_blank" rel="noopener noreferrer"><img src="../Images/432a3823c85b3fb72a206e6236a29f48.png" data-lazy-src="https://files.readme.io/69aa835-Image_2019-11-09_at_1.28.05_PM.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" class=" jetpack-lazy-image" data-original-src="https://files.readme.io/69aa835-Image_2019-11-09_at_1.28.05_PM.png"/><noscript><img data-lazy-fallback="1" src="../Images/432a3823c85b3fb72a206e6236a29f48.png" data-original-src="https://files.readme.io/69aa835-Image_2019-11-09_at_1.28.05_PM.png"/></noscript><img class="alignnone size-full wp-image-46 jetpack-lazy-image" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/><noscript><img data-lazy-fallback="1" class="alignnone size-full wp-image-46" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/></noscript></a><a href="https://lp.logrocket.com/blg/graphql-signup" target="_blank" rel="noopener noreferrer">https://logrocket.com/signup/</a><p>LogRocket 就像是网络和移动应用的DVR，记录下你网站上发生的每一件事。您可以汇总并报告有问题的GraphQL请求，以快速了解根本原因，而不是猜测问题发生的原因。此外，您可以跟踪Apollo客户机状态并检查GraphQL查询的键值对。</p><p>LogRocket检测您的应用程序以记录基线性能计时，如页面加载时间、到达第一个字节的时间、慢速网络请求，还记录Redux、NgRx和Vuex操作/状态。</p><a class="signup" href="https://lp.logrocket.com/blg/graphql-signup" target="_blank" rel="noopener noreferrer">Start monitoring for free</a><p>.</p></div>


</div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
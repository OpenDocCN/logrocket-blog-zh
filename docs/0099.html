<html>
<head>
<title>CSS Grid: A guide to getting started - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>CSS网格:入门指南</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/css-grid-guide/#0001-01-01">https://blog.logrocket.com/css-grid-guide/#0001-01-01</a></blockquote><div><article class="article-post">
<p><strong> <em>编者按:</em> </strong> <em>这份CSS网格指南最近一次更新是在2023年1月10日，它包含了更多关于<a href="https://blog.logrocket.com/css-flexbox-vs-css-grid/"> CSS网格和CSS flexbox </a>之间的差异的信息，交互式代码示例，以及关于何时使用CSS网格的更深入的定义。查看我们的<a href="https://blog.logrocket.com/tag/css/"> CSS档案库</a>，了解更多关于CSS的功能。</em></p>
<p>网络是基于布局的，由布局组成。您希望您的web应用程序在不同平台和设备(移动设备、平板电脑、笔记本电脑和台式机)上的外观在很大程度上取决于布局结构。</p>
<p>例如，我们已经开始接受一种响应迅速、移动优先的设计。这是因为大多数人通过手机上网。</p>
<p>为了最初实现这种布局，开发人员不得不依赖于web应用的CSS代码，如<code>tables</code>、<code>floats</code>、<code>positioning</code>和<code>inline-blocks</code>。然后，CSS网格布局被引入，以帮助开发人员创建更好的布局，尤其是避免使用<code>floats</code>和<code>tables</code>。CSS网格还有什么？它支持所有不同的浏览器。</p>
<p>有了CSS grid，我们可以无缝地创建惊人的布局和响应性网页。CSS网格布局系统的强大之处就在于此:能够使用它为移动优先的web应用程序和跨不同浏览器的响应网站设计布局。本文将深入探讨CSS grid，并向您展示如何开始使用它。</p>
<p><em>向前跳转:</em></p>

<h2 id="css-grid-use">CSS网格是用来做什么的？</h2>
<p>CSS grid用于创建二维布局。它不同于CSS flexbox，后者只能创建一维布局，主要是为对齐而创建的。作为一个二维布局系统，意味着CSS grid允许我们同时使用列和行来构建<a href="https://blog.logrocket.com/how-to-use-css-grid-to-build-a-responsive-web-layout/">复杂且响应迅速的布局</a>。CSS grid的出现意味着我们不再需要部署像<code>positioning</code>和<code>floats</code>这样的黑客。</p>
<p>当我们需要考虑不同元素的位置、大小和层次，以及它们如何在打开网页时相互关联时，CSS grid是一个很好的工具。这也使得快速<a href="https://blog.logrocket.com/full-bleed-layout-css-grid/">为网站创建不同类型的布局</a>变得容易。</p>
<h3 id="css-grid-vs-css-flexbox">CSS网格与CSS flexbox:你应该使用哪一个？</h3>
<p>和所有的网络和软件开发一样，这个问题的答案是:视情况而定。虽然<a href="https://blog.logrocket.com/css-flexbox-vs-css-grid/"> CSS grid和CSS flexbox </a>都不是万能的解决方案，但在某些情况下，CSS grid作为合适且更好的工具大放异彩。</p>
<p>对于由不同大小的元素组成的网站来说，需要<a href="https://gridbyexample.com/patterns/">复杂的布局</a>像<a href="https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Grid_Layout/Masonry_Layout">砖石布局</a>，CSS grid是你最好的选择。虽然您可以实现flexbox hacks来实现这些布局，但这些hacks通常很复杂，需要较长的代码行，因为您没有使用正确的工具来完成工作。</p>
<p>如果您希望对页面上每个单独元素的位置进行细粒度控制，CSS grid是一个很好的工具。CSS网格的<code>grid-template-areas</code>、网格线和网格跨越特性使这成为可能。虽然我们也可以用flexbox实现这种细粒度的控制，但它通常需要更多的代码行，随着时间的推移，维护和管理起来会很棘手，而且难以处理大量的CSS文件。</p>
<p>最后，如果您希望更灵活地移动元素，而不考虑HTML标记的结构，CSS grid应该是您的首选。</p>
<h2 id="basic-css-grid-principles">CSS网格的基本原则</h2>
<p>在最基本的层面上，CSS网格是web的二维布局系统。使用CSS grid，您可以在<a href="https://blog.logrocket.com/understanding-grid-template-columns-css/">行和</a>列中布置内容。</p>
<p>在深入探讨之前，我们先来看看CSS grid的构建模块——<code>display: grid;</code>容器。</p>
<p>首先，让我们创建我们想要用CSS网格样式化的<a href="https://blog.logrocket.com/deprecated-html-elements-and-what-to-use-instead/"> HTML元素</a>:</p>
<pre class="language-html hljs">&lt;body class="container"&gt;
    &lt;div class="item box1"&gt;&lt;p&gt;One&lt;/p&gt;&lt;/div&gt;
    &lt;div class="item box2"&gt;&lt;p&gt;Two&lt;/p&gt;&lt;/div&gt;
    &lt;div class="item box3"&gt;&lt;p&gt;Three&lt;/p&gt;&lt;/div&gt;
&lt;/body&gt;
</pre>
<p>接下来，我们通过将<code>display</code>设置为<code>grid</code>来定义网格布局:</p>
<pre class="language-css hljs">// define or create a grid 
.container{
    display: grid;
}
</pre>
<h2 id="css-grid-terminology">CSS网格术语</h2>
<p>一旦你的<code>grid</code>被定义，你就处于一个良好的开端。然而，这还没有产生任何神奇的效果。我们需要告诉<code>grid</code>列和行应该有多大。为了更好地了解细节，让我们来讨论CSS网格的术语:</p>
<ul>
<li>网格容器:定义了<code>grid display</code>的父容器</li>
<li>网格项目:你的<code>grid</code>容器的直接子容器</li>
<li>间隙:用于创建行和列之间的间距</li>
<li>网格单元:两个相邻行和两个相邻列<code>grid</code>行之间的空间。是<code>grid</code>的一个单体。下面的图片解释了网格单元:</li>
</ul>
<p><img data-attachment-id="156782" data-permalink="https://blog.logrocket.com/css-grid-guide/attachment/grid-cell-example/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2021/08/grid-cell-example.png" data-orig-size="730,417" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="CSS grid cell example" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2021/08/grid-cell-example-300x171.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2021/08/grid-cell-example.png" decoding="async" class="aligncenter size-full wp-image-156782 jetpack-lazy-image" src="../Images/f21dc70f4fde8cbfc19856b2b75d6bab.png" alt="CSS Grid Cell Example" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2021/08/grid-cell-example.png 730w, https://blog.logrocket.com/wp-content/uploads/2021/08/grid-cell-example-300x171.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2021/08/grid-cell-example.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2021/08/grid-cell-example.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="156782" data-permalink="https://blog.logrocket.com/css-grid-guide/attachment/grid-cell-example/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2021/08/grid-cell-example.png" data-orig-size="730,417" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="CSS grid cell example" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2021/08/grid-cell-example-300x171.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2021/08/grid-cell-example.png" decoding="async" loading="lazy" class="aligncenter size-full wp-image-156782" src="../Images/f21dc70f4fde8cbfc19856b2b75d6bab.png" alt="CSS Grid Cell Example" srcset="https://blog.logrocket.com/wp-content/uploads/2021/08/grid-cell-example.png 730w, https://blog.logrocket.com/wp-content/uploads/2021/08/grid-cell-example-300x171.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2021/08/grid-cell-example.png"/></noscript>
<ul>
<li>网格区域:一个或多个网格单元在网格上构成一个矩形区域。网格区域本质上必须是矩形的。这里有一个例子:</li>
</ul>
<p><img data-attachment-id="156784" data-permalink="https://blog.logrocket.com/css-grid-guide/attachment/grid-area-example/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2021/08/grid-area-example.png" data-orig-size="730,417" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="CSS grid area example" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2021/08/grid-area-example-300x171.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2021/08/grid-area-example.png" decoding="async" class="aligncenter size-full wp-image-156784 jetpack-lazy-image" src="../Images/a8b1c6ae5eeceba40d3c8923d7db6e0b.png" alt="CSS Grid Area Example" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2021/08/grid-area-example.png 730w, https://blog.logrocket.com/wp-content/uploads/2021/08/grid-area-example-300x171.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2021/08/grid-area-example.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2021/08/grid-area-example.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="156784" data-permalink="https://blog.logrocket.com/css-grid-guide/attachment/grid-area-example/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2021/08/grid-area-example.png" data-orig-size="730,417" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="CSS grid area example" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2021/08/grid-area-example-300x171.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2021/08/grid-area-example.png" decoding="async" loading="lazy" class="aligncenter size-full wp-image-156784" src="../Images/a8b1c6ae5eeceba40d3c8923d7db6e0b.png" alt="CSS Grid Area Example" srcset="https://blog.logrocket.com/wp-content/uploads/2021/08/grid-area-example.png 730w, https://blog.logrocket.com/wp-content/uploads/2021/08/grid-area-example-300x171.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2021/08/grid-area-example.png"/></noscript>
<ul>
<li>网格轨迹:轨迹是两个相邻网格线之间的空间，本质上是开始和停止行或列的线，因此您总是会比现有的列数和行数多一个。请查看以下内容:</li>
</ul>
<p><img data-attachment-id="156786" data-permalink="https://blog.logrocket.com/css-grid-guide/attachment/grid-track-example/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2021/08/grid-track-example.png" data-orig-size="730,417" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="CSS grid track example" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2021/08/grid-track-example-300x171.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2021/08/grid-track-example.png" decoding="async" class="aligncenter size-full wp-image-156786 jetpack-lazy-image" src="../Images/a1af1e7bec8538e37670c9e51636c730.png" alt="CSS Grid Track Example" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2021/08/grid-track-example.png 730w, https://blog.logrocket.com/wp-content/uploads/2021/08/grid-track-example-300x171.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2021/08/grid-track-example.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2021/08/grid-track-example.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="156786" data-permalink="https://blog.logrocket.com/css-grid-guide/attachment/grid-track-example/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2021/08/grid-track-example.png" data-orig-size="730,417" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="CSS grid track example" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2021/08/grid-track-example-300x171.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2021/08/grid-track-example.png" decoding="async" loading="lazy" class="aligncenter size-full wp-image-156786" src="../Images/a1af1e7bec8538e37670c9e51636c730.png" alt="CSS Grid Track Example" srcset="https://blog.logrocket.com/wp-content/uploads/2021/08/grid-track-example.png 730w, https://blog.logrocket.com/wp-content/uploads/2021/08/grid-track-example-300x171.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2021/08/grid-track-example.png"/></noscript>
<ul>
<li>网格线:这些是在定义网格显示时创建的分隔线:</li>
</ul>
<p><img data-attachment-id="156788" data-permalink="https://blog.logrocket.com/css-grid-guide/attachment/grid-lines-example/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2021/08/grid-lines-example.png" data-orig-size="730,417" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="CSS grid lines example" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2021/08/grid-lines-example-300x171.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2021/08/grid-lines-example.png" decoding="async" class="aligncenter size-full wp-image-156788 jetpack-lazy-image" src="../Images/be2fdbcd658aedb139a08a6976d21c9e.png" alt="CSS Grid Lines Example" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2021/08/grid-lines-example.png 730w, https://blog.logrocket.com/wp-content/uploads/2021/08/grid-lines-example-300x171.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2021/08/grid-lines-example.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2021/08/grid-lines-example.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="156788" data-permalink="https://blog.logrocket.com/css-grid-guide/attachment/grid-lines-example/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2021/08/grid-lines-example.png" data-orig-size="730,417" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="CSS grid lines example" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2021/08/grid-lines-example-300x171.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2021/08/grid-lines-example.png" decoding="async" loading="lazy" class="aligncenter size-full wp-image-156788" src="../Images/be2fdbcd658aedb139a08a6976d21c9e.png" alt="CSS Grid Lines Example" srcset="https://blog.logrocket.com/wp-content/uploads/2021/08/grid-lines-example.png 730w, https://blog.logrocket.com/wp-content/uploads/2021/08/grid-lines-example-300x171.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2021/08/grid-lines-example.png"/></noscript>
<h3 id="implicit-explicit-grid-lines">隐式和显式网格线</h3>
<p>隐式网格线在您的开发工具中显示为虚线，由浏览器创建，无需显式定义列或行。</p>
<p>让我们使用这个代码片段来解释隐式网格线:</p>
<pre class="language-css hljs">.container{
    display: grid;
    grid-template-columns: 100px 100px 100px;
}
</pre>
<p>在上面的代码片段中，我们明确定义了列的内容。我们不定义行。因此，浏览器将决定如何处理显式定义中没有包含的额外项目。它通过创建新的行并将这些额外的项移动到这些行中来实现这一点。而且那是隐性的！</p>
<p>显式网格线是在开发工具中可见的实线，用于CSS中定义的行和列。显式场景不是由浏览器做出的决定；它们是你做的决定，很明确。</p>
<p>这里有一个互动的例子:</p>
<p class="codepen" data-height="399.984375" data-default-tab="html,result" data-slug-hash="abjdyRx" data-user="nefejames">参见<a href="https://codepen.io"> CodePen </a>上Emadamerho Nefe(<a href="https://codepen.io/nefejames">@ Nefe James</a>)<br/>的Pen<a href="https://codepen.io/nefejames/pen/abjdyRx"><br/>CSS Grid-gap</a>。</p>
<p/>
<h2 id="gutters-separate-grid-cells">使用檐槽分隔网格单元</h2>
<p>檐槽是网格单元之间的空间。您可以使用<a href="https://developer.mozilla.org/en-US/docs/Web/CSS/gap"> <code>gap</code>速记属性</a>创建一个装订线，或者您可以使用<code>column-gap</code>和<code>row-gap</code>显式地创建装订线。如果您使用<code>gap</code>速记属性来创建装订线，那么您分配给<code>gap</code>的值将指向网格的<code>row</code>和<code>column</code>。</p>
<p>要使用<code>gap</code>为网格提供檐槽，您将在父<code>container</code>中定义该属性:</p>
<pre class="language-css hljs">// using gap to create gutter of 20px row and column
.container {
    gap: 20px; /* row and column gap */
}

// this can also be written as
.container {
    column-gap: 20px; 
    row-gap: 20px;
}
</pre>
<p class="codepen" data-height="399.84765625" data-default-tab="html,result" data-slug-hash="Yzjwxdy" data-user="nefejames">参见<a href="https://codepen.io"> CodePen </a>上Emadamerho Nefe(<a href="https://codepen.io/nefejames">@ Nefe James</a>)<br/>的Pen<a href="https://codepen.io/nefejames/pen/Yzjwxdy"><br/>CSS Grid-with gap</a>。</p>
<p>分数单位</p>
<h3 id="fractional-units"><code>fr</code>值，也称为分数单位，解决了在元素之间自动分配自由空间的问题，并取代了对百分比的需要。</h3>
<p>让我们更新示例的CSS文件，从像素切换到<code>fr</code>:</p>
<p>请注意网格中子元素的宽度如何自动增加，以填充父网格中的可用空间:</p>
<pre class="language-css hljs">.container {
  display: grid;
  gap: 10px;
  grid-template-columns: 1fr 1fr 1fr;
}
</pre>
<p>参见<a href="https://codepen.io"> CodePen </a>上Emadamerho Nefe(<a href="https://codepen.io/nefejames">@ Nefe James</a>)<br/>的Pen<a href="https://codepen.io/nefejames/pen/bGjEarg"><br/>CSS Grid–1fr</a>。</p>
<p class="codepen" data-height="399.40234375" data-default-tab="html,result" data-slug-hash="bGjEarg" data-user="nefejames">See the Pen <a href="https://codepen.io/nefejames/pen/bGjEarg"><br/>
CSS Grid – 1fr</a> by Emadamerho Nefe (<a href="https://codepen.io/nefejames">@nefejames</a>)<br/>
on <a href="https://codepen.io">CodePen</a>.</p>
<p>创建CSS网格容器、列和行</p>
<h2 id="creating-css-grid-containers-columns-rows">因为在您真正定义行和列之前什么都不会发生，所以我们现在应该学习创建它们。有各种方法来定义每一个，所以让我们从学习如何创建列开始。</h2>
<p>创建列和列跨越</p>
<h2 id="creating-columns-spanning">在<code>parent-container</code>中创建<a href="https://developer.mozilla.org/en-US/docs/Web/CSS/grid-template-columns"> <code>grid-template-columns</code>属性</a>，其中传递的每个值代表显式列的数量。例如:</h2>
<p>上面的例子告诉浏览器创建三列。第一列<code>20px</code>宽，第二列<code>1fr</code>，第三列<code>40px</code>。您还可以将函数和关键字作为值传递，我们将在本文的后面讨论这一点。</p>
<pre class="language-css hljs">.parent-container {
  grid-template-columns: 20px 1fr 40px;
}
</pre>
<p>通过定义<code>column start</code>和<code>column end</code>位置，被称为<a href="https://developer.mozilla.org/en-US/docs/Web/CSS/grid-column">跨越</a>的技术允许子项跨越<code>grid</code>中的列，如下所示:</p>
<p>上面的代码片段定义了每一列的开始和结束位置。但是，您也可以在两个值之间包含一条斜线。</p>
<pre class="language-css hljs">.container{
  display: grid;
  grid-template-columns: 1fr 1fr 1fr 1fr 1fr;
}

.child-item:nth-child(1) {
  grid-column: span 2; /* span 2 columns */
}

.child-item:nth-child(2) {
  grid-column: span 3
}
</pre>
<p>您也可以使用下面的代码获得同样的结果。这里的区别在于，<code>/</code>之前的第一个值将指向列的开始行，而第二个值将指向<code>grid</code>的结尾:</p>
<p>上面的代码告诉浏览器将我的<code>grid</code>项扩展两列，并在第五列结束。这代表了<code>column-start</code> / <code>column-end</code>位置，但是注意我们没有告诉浏览器从哪里开始列；我们只说在哪里结束。</p>
<pre class="language-css hljs">.child-item:nth-child(1) {
  grid-column: span 2 / 5;
}
</pre>
<p>这是浏览器要解决的问题。它自动理解我们想要跨越两列并结束第五列的网格线，因此它计算出该项目将从第二列的网格线的末端开始。</p>
<p>如果我们想告诉浏览器从哪里开始一个<code>child-item</code>，我们应该删除<code>span</code>关键字:</p>
<p>该代码片段告诉浏览器从列<code>2</code>开始我的项目，到列<code>5</code>结束。这里有一个例子:</p>
<pre class="language-css hljs">.child-item {
  grid-column: 2 / 5;
}
</pre>
<p>参见<a href="https://codepen.io"> CodePen </a>上Emadamerho Nefe(<a href="https://codepen.io/nefejames">@ Nefe James</a>)<br/>的Pen<a href="https://codepen.io/nefejames/pen/ZEjQvzJ"><br/>CSS Grid-Grid column span</a>。</p>
<p class="codepen" data-height="399.76171875" data-default-tab="html,result" data-slug-hash="ZEjQvzJ" data-user="nefejames">横跨整个宽度</p>
<p>您将经常使用这个偷偷摸摸的<code>-1</code>值来跨越整个网格容器，这都是因为您的网格比定义的列/行数多一个。这真的与曲目有关。这条赛道正式结束于你的网格容器的末端:</p>
<h3 id="spanning-width">此示例从第一列开始，跨越定义的网格的整个宽度，而不考虑CSS中定义的列数。很酷，对吧？是啊，的确是！请查看以下内容:</h3>
<p>参见<a href="https://codepen.io"> CodePen </a>上Emadamerho Nefe(<a href="https://codepen.io/nefejames">@ Nefe James</a>)<br/>的Pen <a href="https://codepen.io/nefejames/pen/VwBeyzo"> <br/> CSS网格-全角-1 </a>。</p>
<pre class="language-css hljs">.child-item {
  grid-column: 1 / -1;
}
</pre>
<p>创建和跨越行</p>
<p class="codepen" data-height="399.421875" data-default-tab="html,result" data-slug-hash="VwBeyzo" data-user="nefejames">网格行就像列一样，只是它们是水平的，而不是垂直的。该属性的写法与我们的列完全相同，只是我们使用了单词<code>rows</code>。这是如何用CSS编写的:</p>
<p>上面的例子定义了四个显式的<code>rows</code>，每个都是<code>1fr</code>高。如果有任何孩子使用新的<code>row</code>，那么你的隐式<code>rows</code>将被创建。</p>
<h3 id="creating-spanning-rows">使用<a href="https://developer.mozilla.org/en-US/docs/Web/CSS/grid-row"> <code>grid-row</code>速记属性</a>，我们有同样的机会跨行，就像我们可以跨列一样，就像这样:</h3>
<p>参见<a href="https://codepen.io"> CodePen </a>上Emadamerho Nefe(<a href="https://codepen.io/nefejames">@ Nefe James</a>)<br/>的Pen<a href="https://codepen.io/nefejames/pen/qBybpdJ"><br/>CSS Grid-Grid模板行</a>。</p>
<pre class="language-css hljs">.parent-container {
  grid-template-rows: 1fr 1fr 1fr 1fr 1fr;
}
</pre>
<p>The above example defines four explicit <code>rows</code>, each of which is <code>1fr</code> high. If any children wrap to a new <code>row</code>, that’s when your implicit <code>rows</code> will be created.</p>
<p>创建行和列的一种更简单的方法</p>
<pre class="language-css hljs">.item:nth-child(1){
  grid-row: span 2
}

.item:nth-child(2){
  grid-row: span 3
}
</pre>
<p class="codepen" data-height="399.32421875" data-default-tab="html,result" data-slug-hash="qBybpdJ" data-user="nefejames"><a href="https://developer.mozilla.org/en-US/docs/Web/CSS/grid-template"> <code>grid-template()</code>简写</a>允许您在一行中定义行和列的开始和结束位置，并且比我们之前讨论的<code>grid</code>属性更易于阅读。我个人很喜欢这个简写。对我来说很有意义。</p>
<p>这里有一个例子:</p>
<h2 id="shorter-way-create-rows-columns">上面给我们提供的人手是<code><a href="https://blog.logrocket.com/15-ways-implement-vertical-alignment-css/#explicit-grid-row-placement:~:text=13.%20Explicit%20grid%20row%20placement">grid-template-rows</a></code>和<code><a href="https://blog.logrocket.com/understanding-grid-template-columns-css/">grid-template-columns</a></code>，但是我们也要考虑<code>grid-template-areas</code>——稍后会详细介绍。</h2>
<p>第一个值是开始位置，第二个值是结束位置，后面跟着重复这个模式的斜杠<code>/</code>。你可以这样想:<code>/</code>前面的部分是你的行，<code>/</code>后面的部分是你的列:</p>
<p>参见<a href="https://codepen.io"> CodePen </a>上Emadamerho Nefe(<a href="https://codepen.io/nefejames">@ Nefe James</a>)<br/>的Pen<a href="https://codepen.io/nefejames/pen/ZEjQJrR"><br/>CSS Grid-Grid-template</a>。</p>
<pre class="language-css hljs">.parent-container {
  grid-template: 1fr 1fr / 100px 100px 100px;
}
</pre>
<p>The shorthands we’re provided with above are <code><a href="https://blog.logrocket.com/15-ways-implement-vertical-alignment-css/#explicit-grid-row-placement:~:text=13.%20Explicit%20grid%20row%20placement">grid-template-rows</a></code> and <code><a href="https://blog.logrocket.com/understanding-grid-template-columns-css/">grid-template-columns</a></code>, but we also have <code>grid-template-areas</code> to consider, too — more on that shortly.</p>
<p>控制列和行溢出</p>
<p class="codepen" data-height="399.734375" data-default-tab="html,result" data-slug-hash="ZEjQJrR" data-user="nefejames">当那个讨厌的<a href="https://developer.mozilla.org/en-US/docs/Web/CSS/grid-auto-flow"> <code>overflow</code> </a>在你的格子里徘徊时，你能做什么？你把你的电脑扔出窗外，对吗？不对！您可以使用一些精心放置的列和行溢出属性，在一个快速的操作中控制网格的溢出。让我们从研究列溢出开始。</p>
<p>列溢出</p>
<h2 id="controlling-overflow">属性将帮助处理您的溢出需求。它在<code>parent-container</code>上定义，并以如下方式书写:</h2>
<p>上面的代码片段暗示，当创建隐式网格时，<code>column</code>的大小应该占据<code>parent-container</code>的两个小数单位:</p>
<h3>上面代码的结果告诉溢出创建大小为<code>150px</code>的列，这意味着隐式的<code>overflow</code>将以<code>columns</code>的形式出现，而不是<code>rows</code>:</h3>
<p>参见<a href="https://codepen.io"> CodePen </a>上的Pen<a href="https://codepen.io/nefejames/pen/dyjGJVB"><br/>CSS Grid-auto column overflow</a>作者Emadamerho Nefe(<a href="https://codepen.io/nefejames">@ Nefe James</a>)<br/>。</p>
<pre class="language-css hljs">.parent-container {
    grid-auto-columns: 50px;
}
</pre>
<p>行溢出</p>
<pre class="language-css hljs">.parent-container {
    grid-auto-columns: 50px; /* overflow size */
    grid-auto-flow: column; /* overflow type */
}
</pre>
<p>这个属性的工作方式和我们的<code>column overflow</code>属性完全一样，编写方式也一样——bonus！</p>
<p class="codepen" data-height="399.3046875" data-default-tab="html,result" data-slug-hash="dyjGJVB" data-user="nefejames">就像我们用于列的属性一样，我们通过将值<code>row</code>传递给<code>grid-auto-flow</code>来指定隐式行的大小。我们得到的是<code>overflow</code>出现时产生的<code>rows</code>:</p>
<p>使用上面的代码行，我们为<code>grid</code>容器的子元素定义了隐式溢出的溢出类型(<code>rows</code>)和溢出大小(<code>150px</code>):</p>
<h3>参见<a href="https://codepen.io"> CodePen </a>上Emadamerho Nefe(<a href="https://codepen.io/nefejames">@ Nefe James</a>)<br/>的Pen <a href="https://codepen.io/nefejames/pen/xxJZppM"> <br/> CSS网格-自动行溢出</a>。</h3>
<p>构建网格模板</p>
<pre class="language-css hljs">.parent-container {
    grid-auto-rows: 150px;
}
</pre>
<p>当你不知道前期需要多少列时，网格模板很好用。它们也很适合与<a href="https://blog.logrocket.com/choose-between-media-container-queries/">媒体查询</a>一起使用，以实现一些重新排列的魔法。下面是编写该属性的方法:</p>
<pre class="language-css hljs">.parent-container {
    grid-auto-rows: 150px;
    grid-auto-flow: row;
}
</pre>
<p>使用一组包含您选择的单词的引号，例如<code>"sidebar1 content sidebar2"</code>，我们开始定义我们的<code>grid areas</code>。您也可以定义多个区域。例如:</p>
<p class="codepen" data-height="399.1328125" data-default-tab="html,result" data-slug-hash="xxJZppM" data-user="nefejames">这个属性减轻了对行号的担心，每个使用的行号都将被相应地定位。通过在您选择的子项上定义属性来设置位置:</p>
<p>使用<code>grid-area</code>，我们将相应的面积作为一个值传递。不多不少；就这么简单。这里有一个例子:</p>
<h2 id="building-grid-templates">参见<a href="https://codepen.io"> CodePen </a>上Emadamerho Nefe(<a href="https://codepen.io/nefejames">@ Nefe James</a>)<br/>的Pen<a href="https://codepen.io/nefejames/pen/ZEjQrgG"><br/>CSS Grid-Grid模板区域</a>。</h2>
<p>命名网格线</p>
<pre class="language-css hljs">.parent-container {
    grid-template-areas: "sidebar1 content sidebar2";
}
</pre>
<p>CSS grid的这个特性，<a href="https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Grid_Layout/Layout_using_Named_Grid_Lines">名为grid lines </a>，如果你想明确地指导你的布局行为，可能会很有用。您可以在网格上命名位置，而不是使用未命名的数值:</p>
<pre class="language-css hljs">.container {
  display: grid;
  gap: 10px;
  grid-template:
    "header header header" auto
    "sidebar1 content sidebar2" 1fr
    "footer footer footer" auto
}
</pre>
<p><img data-attachment-id="156796" data-permalink="https://blog.logrocket.com/css-grid-guide/attachment/css-grid-lines/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2021/08/css-grid-lines.jpeg" data-orig-size="730,333" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;1&quot;}" data-image-title="CSS grid naming lines example" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2021/08/css-grid-lines-300x137.jpeg" data-large-file="https://blog.logrocket.com/wp-content/uploads/2021/08/css-grid-lines.jpeg" decoding="async" class="aligncenter size-full wp-image-156796 jetpack-lazy-image" src="../Images/1801a3906f8ef27f2fff3f95818bc9d9.png" alt="CSS Grid Naming Lines Example" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2021/08/css-grid-lines.jpeg 730w, https://blog.logrocket.com/wp-content/uploads/2021/08/css-grid-lines-300x137.jpeg 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2021/08/css-grid-lines.jpeg?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2021/08/css-grid-lines.jpeg"/></p>
<pre class="language-css hljs">.header{
  grid-area: header;
}

.sidebar1{
  grid-area: sidebar1;
}

.content{
    grid-area: content;
}

.sidebar2{
  grid-area: sidebar2;
}

.footer{
    grid-area: footer;
}
</pre>
<p>让我们看看这是如何工作的。首先，HTML:</p>
<p class="codepen" data-height="399.1796875" data-default-tab="html,result" data-slug-hash="ZEjQrgG" data-user="nefejames">然后，CSS:</p>
<p>该区域的名称后跟大小(<code>constraint</code>)。为了定义位置，我们转向children，在那里我们将根据上面的命名区域定义值:</p>
<h2 id="named-grid-lines">参见<a href="https://codepen.io"> CodePen </a>上的Pen <a href="https://codepen.io/nefejames/pen/rNreWWR"> <br/> CSS Grid:由Emadamerho Nefe(<a href="https://codepen.io/nefejames">@ Nefe James</a>)<br/>命名的网格线</a>。</h2>
<p>对CSS网格使用函数</p>
<p>这些得心应手的小恶魔是你网格欲望的帮手。他们是帮助您的代码编写生活变得更简单、更高效的超级明星。先说我最喜欢的一个:<code>repeat()</code>。</p><noscript><img data-lazy-fallback="1" data-attachment-id="156796" data-permalink="https://blog.logrocket.com/css-grid-guide/attachment/css-grid-lines/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2021/08/css-grid-lines.jpeg" data-orig-size="730,333" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;1&quot;}" data-image-title="CSS grid naming lines example" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2021/08/css-grid-lines-300x137.jpeg" data-large-file="https://blog.logrocket.com/wp-content/uploads/2021/08/css-grid-lines.jpeg" decoding="async" loading="lazy" class="aligncenter size-full wp-image-156796" src="../Images/1801a3906f8ef27f2fff3f95818bc9d9.png" alt="CSS Grid Naming Lines Example" srcset="https://blog.logrocket.com/wp-content/uploads/2021/08/css-grid-lines.jpeg 730w, https://blog.logrocket.com/wp-content/uploads/2021/08/css-grid-lines-300x137.jpeg 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2021/08/css-grid-lines.jpeg"/></noscript>
<p><code>repeat()</code></p>
<pre class="language-html hljs">  &lt;body&gt;
    &lt;div class="container"&gt;
      &lt;div class="item header"&gt;Header&lt;/div&gt;
      &lt;div class="item content"&gt;Content&lt;/div&gt;
      &lt;div class="item articles"&gt;Articles&lt;/div&gt;
      &lt;div class="item footer"&gt;Footer&lt;/div&gt;
      &lt;div class="item ads"&gt;Ads&lt;/div&gt;
    &lt;/div&gt;
  &lt;/body&gt;
</pre>
<p><a href="https://developer.mozilla.org/en-US/docs/Web/CSS/repeat()"> <code>repeat()</code>函数</a>允许简洁地编写循环模式——在CSS网格中你会经常用到。我们定义了我们需要多少行或多少列，后跟一个约束，但是您也可以传递其他函数或关键字作为参数。参见下面的代码:</p>
<pre class="language-css hljs">.container {
  display: grid;
  grid-template-columns: [start sidebar-start] 3fr [sidebar-end content-start] 5fr [content-end ads-start] 3fr [end ads-end];
  grid-template-rows: [start header-start] auto [header-end content-start] auto [content-end footer-start] auto [end footer-end];
}
</pre>
<p>见笔<a href="https://codepen.io/nefejames/pen/rNrxpdZ"> <br/> CSS网格——在<a href="https://codepen.io"> CodePen </a>上重复第一个例子</a>由Emadamerho Nefe(<a href="https://codepen.io/nefejames">@ Nefe James</a>)<br/>。</p>
<pre class="language-css hljs">.header {
  grid-column: start / end;
  grid-row: start / header-end;
}
.articles {
  grid-column: start / sidebar-end;
  grid-row: header-end / footer-start;
}
.content {
  grid-column: content-start / content-end;
  grid-row: content-start / content-end;
}
.footer {
  grid-column: start / end;
  grid-row: footer-start / footer-end;
}
.ads {
  grid-column: ads-start / end;
  grid-row: header-end / footer-start;
}
</pre>
<p class="codepen" data-height="399.57421875" data-default-tab="html,result" data-slug-hash="rNreWWR" data-user="nefejames">See the Pen <a href="https://codepen.io/nefejames/pen/rNreWWR"><br/>
CSS Grid: named grid lines</a> by Emadamerho Nefe (<a href="https://codepen.io/nefejames">@nefejames</a>)<br/>
on <a href="https://codepen.io">CodePen</a>.</p>
<p>下面是一个使用<a href="https://blog.logrocket.com/what-are-container-queries-in-css/#:~:text=the%20resulting%20code%3A-,Container%20queries%20with%20CSS%20grid,-Just%20like%20with"> <code>repeat()</code> </a>创建四列<code>1fr</code>宽的示例，但是您也可以创建重复的模式:</p>
<h2 id="functions-css-grid">在本例中，该模式重复了两次。第一列为<code>50px</code>宽，下一列为<code>1fr</code>。该模式再次重复，并以设置为<code>2fr</code>的最后一列结束:</h2>
<p>见笔<a href="https://codepen.io/nefejames/pen/MWBKrGG"> <br/> CSS网格——在<a href="https://codepen.io"> CodePen </a>上重复第二个例子</a>作者Emadamerho Nefe(<a href="https://codepen.io/nefejames">@ Nefe James</a>)<br/>。</p>
<h3>适合内容()</h3>
<p><a href="https://developer.mozilla.org/en-US/docs/Web/CSS/fit-content"> <code>fit-content()</code>属性</a>做一件事:将一个值箝位到传递的给定大小:</p>
<pre class="language-css hljs">.parent-container {
    grid-template-columns: repeat(2, 1fr);
}
</pre>
<p class="codepen" data-height="399.3515625" data-default-tab="html,result" data-slug-hash="rNrxpdZ" data-user="nefejames">你通常会和<code>grid-template-columns</code>和<code>grid-template-row</code>一起使用。例如:</p>
<p>这创建了三列，最大宽度分别为<code>200px</code>和<code>400px</code>，以及<code>1fr</code>。您也可以把它看作是为网格列和行定义一个<code>max-width</code>的另一种方式。这是另一个例子:</p>
<p>参见<a href="https://codepen.io"> CodePen </a>上Emadamerho Nefe(<a href="https://codepen.io/nefejames">@ Nefe James</a>)<br/>的Pen<a href="https://codepen.io/nefejames/pen/RwBrxer"><br/>CSS Grid-fit-content()</a>。</p>
<pre class="language-css hljs">.parent-container {
    grid-template-columns: repeat(2, 50px 1fr) 2fr;
}
</pre>
<p><code>minmax()</code></p>
<p class="codepen" data-height="399.71484375" data-default-tab="html,result" data-slug-hash="MWBKrGG" data-user="nefejames"><a href="https://developer.mozilla.org/en-US/docs/Web/CSS/minmax"> <code>minmax()</code>函数</a>定义了一组值之间的范围，该范围的功能是——你猜对了——最小和最大约束——编写它是一件轻而易举的事:</p>
<p>当内容超出列边界时，可以在<code>repeat()</code>中使用该函数。例如:</p>
<h3>如果您想让您的孩子像冠军一样包装，这是一个不错的选择——尤其是在动态添加更多元素时:</h3>
<p>参见<a href="https://codepen.io"> CodePen </a>上Emadamerho Nefe(<a href="https://codepen.io/nefejames">@ Nefe James</a>)<br/>的Pen<a href="https://codepen.io/nefejames/pen/MWBKrZB"><br/>CSS Grid–minmax()</a>。</p>
<pre class="language-css hljs">fit-content(100px)</pre>
<p>关键词</p>
<pre class="language-css hljs">.parent-container {
    grid-template-columns: fit-content(200px) fit-content(400px) 1fr;
}
</pre>
<p>关键词对你的武器库来说非常有价值，所以你会想要熟悉它们。让我们从你最有可能使用的和最容易混淆的开始:<code>auto-fit</code>和<code>auto-fill</code>。</p>
<p class="codepen" data-height="399.44140625" data-default-tab="html,result" data-slug-hash="RwBrxer" data-user="nefejames"><code>auto-fill</code> / <code>auto-fit</code></p>
<p><code>auto-fill</code>关键字在显式网格线上结束网格，并填充所有可用空间。它还会拉伸网格轨迹内的项目以适应。当与<code>minmax()</code>结合使用时，这使得它成为包装元素的一种有价值的方法。</p>
<h3>关键字<code>auto-fit</code>在明确的列行结束网格。这与<code>auto-fill</code>的做法相反，因为它扩展了显式网格。</h3>
<p>您可以在<code>repeat()</code>函数中使用这个关键字。例如:</p>
<pre class="language-css hljs">minmax(20px, 100px)</pre>
<p>因为上面没有明确说明需要多少列，所以将添加额外的隐式网格或列。这相当于告诉浏览器自己去想办法。它将网格分割成尽可能多的空间，填满可用空间。你可以<a href="https://blog.logrocket.com/flexible-layouts-without-media-queries/">阅读更多关于<code>auto-fill</code>和<code>auto-fit</code> </a>的内容，进一步了解这些关键词。</p>
<pre class="language-css hljs">.parent-container {
    grid-template-columns: repeat(3, minmax(150px, 1fr))
}
</pre>
<p>使用值<code>dense</code>将使网格自动填充网格容器中的空间。这也将有助于为以后可能出现的其他较小的网格项目创造空间。</p>
<p class="codepen" data-height="399.72265625" data-default-tab="html,result" data-slug-hash="MWBKrZB" data-user="nefejames">当以这种方式使用时，<code>grid-auto-flow: dense</code>将放置项目而不创建剩余区域，并在其他合适的地方摆动。换句话说，它可以将物品打包，而不会留下未使用的空间。如下图所示:</p>
<p>如果你不在乎顺序，只想填满所有的空间，这是一个很好的选择。</p>
<h2 id="keywords">CSS网格中的对齐</h2>
<p>众所周知，CSS flexbox使项目对齐变得很容易，但是你也可以用CSS grid做到这一点。flexbox中可用的相同属性也可用于grid，例如:</p>
<h3><code>align-items</code></h3>
<p><code>align-self</code></p>
<p><code>justify-self</code></p>
<p><code>justify-items</code></p>
<pre class="language-css hljs">repeat(auto-fill, 150px)
</pre>
<p><code>justify-content</code></p>
<p>将<code>justify</code>视为沿着行轴(从左到右),将<code>align</code>视为沿着列轴(从上到下)。</p>
<p>还有一个强大的属性叫做<a href="https://developer.mozilla.org/en-US/docs/Web/CSS/place-items"> <code>place-items</code> </a>，它可以将项目水平或垂直对齐在一行中:</p>
<pre class="language-css hljs">grid-auto-flow: column dense;
grid-auto-flow: dense;
</pre>
<p>通常，这些对齐属性在父容器上定义，但也可以在子容器上覆盖。这是另一个例子:</p>
<h2 id="alignment-css-grid">见<a href="https://codepen.io/nefejames/pen/OJwMzGm"> <br/> CSS网格-放置物品</a>由Emadamerho Nefe(<a href="https://codepen.io/nefejames">@ Nefe James</a>)<br/>在<a href="https://codepen.io"> CodePen </a>上。</h2>
<p>法庭秩序！</p>
<ul>
<li>CSS grid有一个<code>order</code>属性<a href="https://blog.logrocket.com/flexbox-vs-css-grid/">，它的工作方式和flexbox的</a>完全一样，用来控制项目的排列。它是以同样的方式写的:</li>
<li>然后，在您的CSS中:</li>
<li>由于<code>grid</code>项的源顺序没有相关性，这使得重新排列变得非常容易，尤其是在媒体查询时。查看以下更多内容:</li>
<li>参见<a href="https://codepen.io"> CodePen </a>上的Pen<a href="https://codepen.io/nefejames/pen/bGjELbY"><br/>CSS Grid-order</a>by Emadamerho Nefe(<a href="https://codepen.io/nefejames">@ Nefe James</a>)<br/>。</li>
<li><code>justify-content</code></li>
</ul>
<p>通过CSS flexbox使用CSS网格</p>
<p>在本文前面，我们看到了CSS grid与CSS flexbox的不同之处，以及grid如何创建二维布局，而flexbox用于一维布局和对齐。尽管它们的用例和应用程序不同，我们可以将grid和flexbox结合起来，以获得两个世界的优势。</p>
<pre class="language-css hljs">place-items: x | y;
place-items: center center
</pre>
<p>例如，让我们看一个基本的博客页面场景。这是我们将构建的演示的屏幕截图:</p>
<p class="codepen" data-height="399.015625" data-default-tab="html,result" data-slug-hash="OJwMzGm" data-user="nefejames"><img data-attachment-id="156806" data-permalink="https://blog.logrocket.com/css-grid-guide/attachment/css-grid-blog/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2021/08/css-grid-blog.png" data-orig-size="730,411" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="CSS grid blog example" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2021/08/css-grid-blog-300x169.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2021/08/css-grid-blog.png" decoding="async" class="aligncenter size-full wp-image-156806 jetpack-lazy-image" src="../Images/a723ea2f1b5dcac81a9be7c741edb66e.png" alt="CSS Grid Blog Example" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2021/08/css-grid-blog.png 730w, https://blog.logrocket.com/wp-content/uploads/2021/08/css-grid-blog-300x169.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2021/08/css-grid-blog.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2021/08/css-grid-blog.png"/></p>
<p> </p>
<h2>上图显示了一个基本布局，带有一个<code>header</code>、<code>sidebar</code>、<code>footer</code>和一些<code>images</code>。</h2>
<p><code>header</code>、<code>sidebar</code>、<code>footer</code>和<code>content</code>部分的布局是用CSS grid实现的，而<code>blog cards</code>及其在<code>content</code>部分的排列是用CSS flexbox创建的。</p>
<pre class="language-html hljs">&lt;body class="container"&gt;
    &lt;div class="item content"&gt;&lt;p&gt;Content&lt;/p&gt;&lt;/div&gt;
    &lt;div class="item sidebar"&gt;&lt;p&gt;Sidebar&lt;/p&gt;&lt;/div&gt;
&lt;/body&gt;
</pre>
<p>让我们看看这在实践中是如何工作的，从HTML标记开始:</p>
<pre class="language-css hljs">.container {
    display: grid;
}

.sidebar{
  order: 1;
}

.content{
  order: 2;
}
</pre>
<p>接下来，<code>grid</code>布局:</p>
<p class="codepen" data-height="399.62109375" data-default-tab="html,result" data-slug-hash="bGjELbY" data-user="nefejames">然后，我们用flexbox创建了<code>blog card</code>样式:</p>
<p>将<code>flex-direction</code>设置为<code>column</code>可确保卡片中的图像和文本相互堆叠，而<code>flex-start</code>对齐可确保所有内容都向左对齐。</p>
<h2 id="using-css-grid-css-flexbox">最后，我们需要设置<code>flexbox styles</code>，它将定义<code>blog cards</code>如何在<code>content</code>部分中排列。这很重要，因为div的默认行为是它们<a href="https://blog.logrocket.com/best-practices-stacking-elements-css/">堆叠在彼此</a>之上，因为它们是块元素。在这个演示中，我们希望这些卡片在大屏幕设备上并排放置，并在移动设备上堆叠起来:</h2>
<p><img data-attachment-id="156804" data-permalink="https://blog.logrocket.com/css-grid-guide/attachment/css-grid-stacked-cards/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2021/08/css-grid-stacked-cards.png" data-orig-size="730,411" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="CSS grid stacked card blog" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2021/08/css-grid-stacked-cards-300x169.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2021/08/css-grid-stacked-cards.png" decoding="async" class="aligncenter size-full wp-image-156804 jetpack-lazy-image" src="../Images/002a7c445a1f5ae912413716874e392a.png" alt="CSS Grid Stacked Card Blog" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2021/08/css-grid-stacked-cards.png 730w, https://blog.logrocket.com/wp-content/uploads/2021/08/css-grid-stacked-cards-300x169.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2021/08/css-grid-stacked-cards.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2021/08/css-grid-stacked-cards.png"/></p>
<p>因为<code>blog cards</code>都在<code>content</code>部分中，我们将把<code>.content</code> div作为目标，并在那里应用<code>styles</code>:</p>
<p>在mobile上设置<code>flex-direction</code>到<code>column</code>可以确保卡片自动堆叠，对于大屏幕设备，我们将其设置为<code>row</code>。</p><noscript><img data-lazy-fallback="1" data-attachment-id="156806" data-permalink="https://blog.logrocket.com/css-grid-guide/attachment/css-grid-blog/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2021/08/css-grid-blog.png" data-orig-size="730,411" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="CSS grid blog example" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2021/08/css-grid-blog-300x169.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2021/08/css-grid-blog.png" decoding="async" loading="lazy" class="aligncenter size-full wp-image-156806" src="../Images/a723ea2f1b5dcac81a9be7c741edb66e.png" alt="CSS Grid Blog Example" srcset="https://blog.logrocket.com/wp-content/uploads/2021/08/css-grid-blog.png 730w, https://blog.logrocket.com/wp-content/uploads/2021/08/css-grid-blog-300x169.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2021/08/css-grid-blog.png"/></noscript>
<p>这个演示让我们了解了CSS grid和flexbox是如何很好地互补的。我们还看到，网格子节点可以是flexbox父节点，也可以是网格父节点。这是我们的最终产品:</p>
<p>参见<a href="https://codepen.io"> CodePen </a>上Emadamerho Nefe(<a href="https://codepen.io/nefejames">@ Nefe James</a>)<br/>的Pen<a href="https://codepen.io/nefejames/pen/WNKweEy"><br/>CSS Grid-flexbox+Grid</a>。</p>
<p>结论</p>
<p>你成功了！我们正处于学习帮助创建这个被称为CSS grid的惊人特性的旅程的终点。我希望我所分享的能激励你开始使用CSS grid——它并不像从远处看起来那么可怕！</p>
<pre class="language-html hljs">&lt;body class="container"&gt;
    //Header
    &lt;div class="item header"&gt;
      &lt;p&gt;Header&lt;/p&gt;
    &lt;/div&gt;


    //Content
    &lt;div class="item content"&gt;
      &lt;p&gt;Content&lt;/p&gt;


      //Blog card 1
      &lt;div class="blog-card"&gt;
        &lt;span&gt;Blog Title&lt;/span&gt;
        &lt;img src="/payment.webp" alt="a flexbox card" /&gt;
        &lt;p&gt;By: &lt;span&gt;John Doe&lt;/span&gt;&lt;/p&gt;
      &lt;/div&gt;


      //Blog card 2
      &lt;div class="blog-card"&gt;
        &lt;span&gt;Blog Title&lt;/span&gt;
        &lt;img src="/payment.webp" alt="a flexbox card" /&gt;
        &lt;p&gt;By: &lt;span&gt;John Doe&lt;/span&gt;&lt;/p&gt;
      &lt;/div&gt;


      //Blog card 3
      &lt;div class="blog-card"&gt;
        &lt;span&gt;Blog Title&lt;/span&gt;
        &lt;img src="/payment.webp" alt="a flexbox card" /&gt;
        &lt;p&gt;By: &lt;span&gt;John Doe&lt;/span&gt;&lt;/p&gt;
      &lt;/div&gt;
    &lt;/div&gt;


    //Sidebar
    &lt;div class="item sidebar1"&gt;
      &lt;p&gt;Sidebar 1&lt;/p&gt;
    &lt;/div&gt;


    //Footer
    &lt;div class="item footer"&gt;
      &lt;p&gt;Footer&lt;/p&gt;
    &lt;/div&gt;
  &lt;/body&gt;
</pre>
<p>你的前端是否占用了用户的CPU？</p>
<pre class="language-css hljs">.container {
  display: grid;
  gap: 10px;
  grid-template:
    "header header header" auto
    "sidebar1 content content" 1fr
    "footer footer footer" auto;
}

.header {
  grid-area: header;
}

.sidebar1 {
  grid-area: sidebar1;
}

.content {
  grid-area: content;
}

.footer {
  grid-area: footer;
}
</pre>
<p>随着web前端变得越来越复杂，资源贪婪的特性对浏览器的要求越来越高。如果您对监控和跟踪生产环境中所有用户的客户端CPU使用、内存使用等感兴趣，</p>
<pre class="language-css hljs"> .blog-card {
  display: flex;
  flex-direction: column;
  align-items: flex-start;
}
</pre>
<p>.</p>
<p>LogRocket 就像是网络和移动应用的DVR，记录你的网络应用或网站上发生的一切。您可以汇总和报告关键的前端性能指标，重放用户会话和应用程序状态，记录网络请求，并自动显示所有错误，而不是猜测问题发生的原因。</p>
<p>现代化您调试web和移动应用的方式— <a class="signup" href="https://lp.logrocket.com/blg/css-signup" target="_blank" rel="noopener noreferrer">开始免费监控</a>。</p><noscript><img data-lazy-fallback="1" data-attachment-id="156804" data-permalink="https://blog.logrocket.com/css-grid-guide/attachment/css-grid-stacked-cards/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2021/08/css-grid-stacked-cards.png" data-orig-size="730,411" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="CSS grid stacked card blog" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2021/08/css-grid-stacked-cards-300x169.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2021/08/css-grid-stacked-cards.png" decoding="async" loading="lazy" class="aligncenter size-full wp-image-156804" src="../Images/002a7c445a1f5ae912413716874e392a.png" alt="CSS Grid Stacked Card Blog" srcset="https://blog.logrocket.com/wp-content/uploads/2021/08/css-grid-stacked-cards.png 730w, https://blog.logrocket.com/wp-content/uploads/2021/08/css-grid-stacked-cards-300x169.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2021/08/css-grid-stacked-cards.png"/></noscript>
<p>Because the <code>blog cards</code> are all in the <code>content</code> section, we will target the <code>.content</code> div and apply the <code>styles</code> there:</p>
<pre class="language-css hljs">//mobile styles
.content {
  grid-area: content;
  display: flex;
  flex-direction: column;
  gap: 2rem;
}

//large screen styles
@media screen and (min-width: 600px) {
  .content {
    flex-direction: row;
  }
}
</pre>
<p>Setting the <code>flex-direction</code> to <code>column</code> on mobile ensures the cards stack upon themselves, and for large-screen devices, we set it to <code>row</code>.</p>
<p>This demo gives us an idea of how CSS grid and flexbox complement each other well. We also see that grid children can be flexbox parents or grid parents. Here’s our final product:</p>
<p class="codepen" data-height="399.5703125" data-default-tab="html,result" data-slug-hash="WNKweEy" data-user="nefejames">See the Pen <a href="https://codepen.io/nefejames/pen/WNKweEy"><br/>
CSS Grid – flexbox + grid</a> by Emadamerho Nefe (<a href="https://codepen.io/nefejames">@nefejames</a>)<br/>
on <a href="https://codepen.io">CodePen</a>.</p>
<p/>
<h2>Conclusion</h2>
<p>You’ve made it! We are at the end of our journey of learning the bits that helped create this amazing feature known as CSS grid. I hope what I’ve shared inspires you to start using CSS grid — it isn’t as scary as it may seem from afar!</p><div class="code-block code-block-25">
<div class="blog-plug inline-plug css-plug"><h2>Is your frontend hogging your users' CPU?</h2><p>As web frontends get increasingly complex, resource-greedy features demand more and more from the browser. If you’re interested in monitoring and tracking client-side CPU usage, memory usage, and more for all of your users in production, </p><a target="_blank" href="https://lp.logrocket.com/blg/css-signup">try LogRocket</a><p>.</p><a class="signup" href="https://lp.logrocket.com/blg/css-signup" target="_blank" rel="noopener noreferrer"><img class="alignnone size-full wp-image-46 jetpack-lazy-image" src="../Images/dacb06c713aec161ffeaffae5bd048cd.png" alt="LogRocket Dashboard Free Trial Banner" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2019/12/cpu-memory-usage.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/12/cpu-memory-usage.png"/><noscript><img data-lazy-fallback="1" class="alignnone size-full wp-image-46" src="../Images/dacb06c713aec161ffeaffae5bd048cd.png" alt="LogRocket Dashboard Free Trial Banner" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/12/cpu-memory-usage.png"/></noscript></a><a href="https://lp.logrocket.com/blg/css-signup" target="_blank" rel="noopener noreferrer">https://logrocket.com/signup/</a><p><a href="https://lp.logrocket.com/blg/css-signup" target="_blank" rel="noopener noreferrer">LogRocket</a> is like a DVR for web and mobile apps, recording everything that happens in your web app or site. Instead of guessing why problems happen, you can aggregate and report on key frontend performance metrics, replay user sessions along with application state, log network requests, and automatically surface all errors.</p><p>Modernize how you debug web and mobile apps — <a class="signup" href="https://lp.logrocket.com/blg/css-signup" target="_blank" rel="noopener noreferrer">Start monitoring for free</a>.</p></div>
</div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
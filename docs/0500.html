<html>
<head>
<title>The essential guide for designing a production-ready, developer-friendly RESTful API - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>设计生产就绪、开发人员友好的RESTful API的基本指南</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/the-essential-guide-for-designing-a-production-ready-developer-friendly-restful-api/#0001-01-01">https://blog.logrocket.com/the-essential-guide-for-designing-a-production-ready-developer-friendly-restful-api/#0001-01-01</a></blockquote><div><article class="article-post">
<p>开发人员是编程API的主要用户。通常，我们关心产品的UI和UX，但是忽略了为API创建良好的UX的重要性。</p>
<p>在产品开发的初始阶段，它可能不会引起问题，但是一旦它被不同需求的多组开发人员使用，它很容易成为开发速度和产品执行的瓶颈。</p>
<p>在这篇文章中，我们将讨论如何避免这个问题，并确保您的API随着产品的增长而平稳扩展。</p>
<p>我们将讨论构建更好的API UX的一些最佳实践和指南，尤其是广泛使用的RESTful API。</p>
<p>这不是说“这是构建REST API的最佳方式”的指南。每个产品都有不同的需求——这些是为您的REST API提供更好的DX(开发人员体验)的通用指南。</p>
<h3>REST API设计基础</h3>
<p>盲目遵循web标准不会做出好的API。RESTful是一种创建API的灵活的架构风格。它并没有规定如何去做——相反，它只是告诉你在设计过程中需要记住什么。</p>
<p>以下是REST API设计的一些基本技巧:</p>
<ul>
<li>从资源的角度考虑，而不是从CRUD操作的角度</li>
<li>使用正确的HTTP动词</li>
<li>精心制作不言自明的URL</li>
<li>将正确的内容类型作为标题发送</li>
<li>使用正确的HTTP状态代码</li>
<li>正确处理错误并为客户端错误发送错误消息</li>
</ul>
<p>在这篇文章中，我们将根据这些指导方针为工作公告板创建一个模拟API。</p>
<h3>从资源的角度考虑</h3>
<p>REST API围绕着创建资源。本质上，资源是应用程序的逻辑分割。</p>
<p>它不需要与您的数据模型相同。因为你可以在多个数据模型中使用资源，所以它不同于CRUD。</p>
<p>例如，在我们的job board中，我们可以拥有多个资源，其中一些资源在其操作中使用多个数据模型。</p>
<ul>
<li>乔布斯</li>
<li>使用的数据模型:工作、类别、工作类型</li>
<li>公司</li>
<li>使用的数据模型:公司、用户、订单</li>
<li>应用程序</li>
<li>使用的数据模型:应用程序、用户</li>
</ul>
<p>在这些资源中，将会有多个操作——而不仅仅是数据模型的CRUD。在下一节中，我们将探索如何使用HTTP动词和URL来分隔这些操作。</p>
<h3>HTTP动词和URL</h3>
<p>l有几个HTTP动词–GET、POST、PUT、PATCH、DELETE。所有这些HTTP动词都有特定的功能。</p>
<p>除了这些HTTP动词，资源还可以有多种功能。</p>
<p>例如:</p>
<ul>
<li><code>GET /jobs</code>–检索所有作业</li>
<li><code>GET /jobs/1234</code>–检索作业ID为<code>1234</code>的特定作业</li>
<li><code>POST /jobs</code>–创建新的工作列表</li>
<li><code>PUT /jobs/1234</code>–更新作业ID为<code>1234</code>的作业</li>
<li><code>DELETE /jobs/1234</code>–删除作业ID为<code>1234</code>的作业</li>
<li><code>PATCH /jobs/1234</code>–更新作业ID为<code>1234</code>的部分作业。它类似于<code>PUT</code>，但是put更新整个作业，而<code>PATCH</code>更新作业数据的特定部分。</li>
</ul>
<h3>更好的URL模式</h3>
<p>一个小提示:不要像这样构造URL:</p>
<ul>
<li><code>POST /createJobs</code>创造就业❌</li>
<li><code>GET /getAllJobs</code>去取❌所有的工作</li>
<li><code>GET /getJobById</code>用ID ❌获得特定的工作</li>
</ul>
<p>这种方法是可行的，它也是一个REST API。没有规定说你不能这样使用REST API。</p>
<p>然而，这种方法不能很好地扩展。</p>
<p>对于使用它的开发人员来说，这将是一场噩梦，他们每次都需要浏览文档来检查特定操作所需的URL模式。</p>
<p>我建议对资源URL使用名词，而不是动词。用户看到就更容易知道更新和删除的网址。</p><div class="code-block code-block-54">
<hr/>
<h3>更多来自LogRocket的精彩文章:</h3>

<hr/></div>
<p><code>POST /jobs</code>–创建作业✅<br/><code>GET /jobs</code>–检索所有作业✅</p>
<p>使用URL的这个模板将帮助开发人员很容易理解他们需要向<code>/jobs/:id</code>发送一个删除请求来删除一个作业。</p>
<h3>显式发送内容类型头</h3>
<p>如果URL中没有明确指定默认内容类型，请始终发送默认内容类型。</p>
<p>现在，JSON是默认的内容类型，它发送内容类型的头，这样用户就知道API URL返回什么类型的内容。</p>
<p>一些内容类型标题包括以下内容:</p>
<ul>
<li>内容类型:应用程序/json</li>
<li>内容类型:文本/html</li>
<li>内容类型:应用程序/xml</li>
</ul>
<h3>小心处理嵌套资源</h3>
<p>资源通常有很多关系，所以我们可能需要通过嵌套的资源来获取这些关系。如果没有正确定义嵌套资源，这可能会很棘手。</p>
<p>在我们的工作公告板示例中，一个工作可以有多个应用程序。您可以通过作业资源本身获取这些信息。</p>
<p>例如:</p>
<ul>
<li><code>GET /jobs/1234/applications</code>–获取特定工作ID的所有申请(<code>1234</code>)</li>
<li><code>GET /jobs/1234/applications/:123</code>–获取作业ID为(<code>1234</code>)的作业的应用ID为(<code>123</code>)的具体应用</li>
<li><code>/companies/12345/applications</code>–获取特定公司的所有申请(<code>12345</code>)。</li>
</ul>
<p>这里您可以看到<code>Jobs</code>和<code>Companies</code>都与<code>Applications</code>资源有关系。</p>
<p>在这种情况下，通过嵌套资源创建新的应用程序是不明智的。</p>
<p>相反，通过嵌套资源进行检索，并通过<code>Applications</code>资源创建新的应用程序。</p>
<p>换句话说，使用<code>POST /applications</code>创建一个新的应用程序，它将包含关于一个特定任务的信息。</p>
<p>在某些情况下，这是最有效的方法，但不是全部。最终，这取决于用例。</p>
<p>如果一个应用程序的唯一直接连接是工作而不是公司，那么这种方法将会起作用。您可以为<code>POST /jobs/1234/applications</code>中的工作创建应用程序。</p>
<p>尽管如此，将资源分开并尽可能避免嵌套总是好的。</p>
<p>一般来说，尽量不要超过一层嵌套，并确保在逻辑上分割成单独的资源。</p>
<h3>支持过滤以避免嵌套资源</h3>
<p>在我们的用例中，使用过滤可以帮助我们避免嵌套:</p>
<ul>
<li><code>GET /applications?jobId=1234</code>–这将获取ID为的特定作业的所有应用程序</li>
<li><code>GET /applications?companyId=12345</code>–这将获取ID为的特定公司的所有应用程序</li>
</ul>
<p>过滤器也可以基于字段:</p>
<ul>
<li><code>GET /jobs?jobType=Remote</code>–用<code>jobType: Remote</code>获取作业</li>
<li><code>GET /jobs?categories=developers,designers,marketers</code>–过滤器可以是一个数组。在这种情况下，它过滤类别<code>developers</code>、<code>designers</code>和<code>marketers</code>中的所有工作</li>
</ul>
<h3>支持搜索</h3>
<p>有两种类型的搜索:</p>
<ul>
<li>基于字段的搜索</li>
<li>一般搜索</li>
</ul>
<p>通用搜索可以作为以<code>q</code>或<code>search</code>为关键字的查询字符串传递。<br/>比如:<code>/jobs?q=searchterm</code></p>
<p>基于字段的搜索与基于字段的筛选相同。</p>
<p>一些字段使用精确匹配进行筛选，而另一些字段使用部分基于正则表达式的匹配进行筛选。<br/>比如:<code>/jobs?title=marketing ninja</code>。在这里，我们可以搜索部分标题为<code>marketing ninja</code>的职位</p>
<h3>使用正确的HTTP状态代码，并在整个API中保持一致</h3>
<p>我们都知道特定的HTTP状态代码意味着什么——200、4xx、5xx、302等等。</p>
<p>我们使用这些状态代码让API消费者确切地知道在处理他们的请求时发生了什么。一致地使用它<strong>是良好的API用户体验的关键。</strong></p>
<p>需要注意的是，您不需要支持所有的HTTP状态代码，但是您应该尝试支持符合您的API需求的HTTP状态代码。</p>
<p>您不希望发送状态代码为<code>200</code>的<code>Not found</code>错误。这是一种不好的做法，会让用户混淆错误是否发生。</p>
<p>以下是API中HTTP状态代码的一些示例:</p>
<ul>
<li>获取、放置、修补–200 OK</li>
<li>POST-201创建</li>
<li>删除–204无内容</li>
</ul>
<p>以下是一些错误的状态代码:</p>
<ul>
<li>400–错误的请求</li>
<li>401–未经授权</li>
<li>404未找到</li>
<li>429–请求太多</li>
<li>500–内部服务器错误</li>
</ul>
<h3>错误消息和响应</h3>
<p>在响应中发送客户机错误的详细信息也是一个好主意，这样API用户就可以向他们的最终用户显示错误的详细信息。</p>
<p>具有适当误差响应的示例响应如下:</p>
<pre>// A sample response
{
  errors: [{
    'status': 'InvalidError'
    'message': 'Invalid value for email',
    ... // Other details of the error
  }, {
    ... // Next error object
  }],
  data: {
  ... // Any data
  }
}</pre>
<h3>异步响应</h3>
<p>如果一个API动作正在后台进行异步操作，立即向用户发送响应。不要等到流程结束才发送带有适当状态代码的响应。</p>
<p>通常，在这种情况下，您将使用<code>202 Accepted</code>。这并不意味着操作已经完成，只是意味着它已经被接受。</p>
<p>电子邮件触发和大量计算是异步操作。</p>
<h3>选择字段:允许客户端获取他们实际需要的内容</h3>
<p>允许您的API用户选择他们想要的字段。默认情况下，向他们发送所有相关数据。</p>
<p>如果用户明确要求特定的细节，只发送所要求的细节。这样，您的API将能够灵活地发送客户要求的准确数据。</p>
<p>示例:</p>
<ul>
<li><code>GET /jobs?fields=id,title,description,jobType,categories</code>–专门显示明确传递给字段查询字符串的字段中的作业。</li>
</ul>
<h3>按需扩展资源</h3>
<p>数据模型有多个模型的ID引用。如果您的响应时间很慢，那么在解析资源时，默认情况下不要从多个模型展开对象。</p>
<p>例如，以下代码片段显示了以jobType和categories作为id的作业响应:</p>
<pre>// GET /jobs
[{
  title: 'Job title',
  description: 'Job description',
  jobType: 1233043949238923, // ID ref to jobType model
  categories: [ // ID ref to categories model
    1029102901290129,
    0232392930920390,
  ]
},
{
... // Job Objects
}]</pre>
<p>接下来，我们将使用一个显式请求来扩展jobType和Categories数据:<code>GET /jobs?expand=jobType,categories</code></p>
<pre>// GET /jobs?expand=jobType,categories
[{
  title: 'Job title',
  description: 'Job description',
  jobType: 'Remote', // Resolved from jobType model
  categories: [ // Resolved from categories model
    {
      name: 'Front end developer' 
    },
    {
      name: 'React developer'
    },
  ]
},
{
... // Job Objects
}]</pre>
<h3>支持排序，在前端实现更大的灵活性</h3>
<p>默认情况下，每个资源都有不同的排序顺序。通过扩展，最好为API用户提供基于字段排序的灵活性。支持升序和降序响应非常容易。</p>
<p>例如:</p>
<ul>
<li><code>GET /jobs?sort=createdDate</code>–这只是按照<code>createdDate</code>以升序对响应进行排序</li>
<li><code>GET /jobs?sort=-createdDate</code>–以相反的顺序排序(降序)</li>
<li><code>GET /jobs?sort=-createdDate,title</code>–按多个值排序(createdDate降序排列，title升序排列)</li>
</ul>
<blockquote><p>您不需要遵循相同的约定，这完全取决于您使用的框架。这只是一个如何支持资源排序的一般示例。</p></blockquote>
<h3>明智地使用分页</h3>
<p>对于较小的资源，不需要使用分页。</p>
<p>但是，一旦响应超过了一定的大小，分页就可以派上用场了。使您的分页实现简单明了。</p>
<p>例如:</p>
<ul>
<li><code>GET /jobs?page=2&amp;size=10</code>–此处，<code>page</code>表示页数,“尺寸”表示每页工作数量的限制。在此示例中，第2页包含从11到20的作业。</li>
</ul>
<p>在响应中，我们将向API用户发送相关的页面信息和内容:</p>
<pre>// Sample paginated list example
  {
    data: [
      {
        ... // actual response data
      }
    ],
    pageInfo: {
      currentPage: 2,
      hasNextPage: false,
      hasPrevPage: true,
      ... // Add any more pagination related information
    }
  }</pre>
<p>到目前为止，我们已经介绍了创建REST API所需的最基本的概念。</p>
<p>现在我们要换个话题，讨论一些创建开发人员友好的、生产就绪的RESTful API的高级概念。</p>
<h3>在API的早期阶段使用HATEOAS</h3>
<p>开发人员经常讨厌HATEOAS，不仅仅是因为名字本身就有“讨厌”这个词。我不打算深入讨论HATEOAS是什么——我只想告诉你它是做什么的。</p>
<p>HATEOAS是一种将所有相关资源URL显式发送到端点的方法。它允许消费者轻松地在您的资源之间导航，而不必自己构建URL。</p>
<p>这是RESTful APIs背后的主要概念之一。它允许API用户了解任何给定资源及其相关资源上的不同操作。</p>
<p>例如:<br/><code>GET /jobs</code>–获取所有作业。</p>
<p>它对HATEOAS的回应是这样的:</p>
<pre>// HATEOAS links are in the links section
{
  data: [{...job1}, {...job2}, {...job3}, ...],
  links: [
    // GET all applications
    {
      "rel": "applications",
      "href": "https://example.com/applications",
      "action": "GET",
      "types": ["text/xml","application/json"]
    },
    {
      "rel": "jobs",
      "href": "https://example.com/jobs",
      "action": "POST",
      "types": ["application/json"]
    },
    {
      "rel": "jobs",
      "href": "https://example.com/jobs",
      "action": "DELETE",
      "types": []
    }
  ]
}</pre>
<p>所有相关链接都被添加到响应本身。它帮助API用户在资源和不同操作之间导航。</p>
<h3>认证和授权</h3>
<p>在允许用户完成任何会改变数据的操作之前，始终要对用户进行身份验证和授权。</p>
<p>您还应该通过在授权墙后面保护敏感信息来限制对所有敏感信息的访问。对于没有完成必要的身份验证和授权的用户，应该只提供公共信息。</p>
<p>以下是在身份验证和授权过程中需要记住的一些提示:</p>
<ul>
<li>实施RBAC(基于角色的访问控制)并允许用户拥有多个角色</li>
<li>为每个角色提供精确的权限，并允许用户级别的某些权限</li>
<li>始终进行身份验证，然后检查用户是否有权执行该操作。如果他们没有被授权，发送一个<code>403 forbidden</code>响应。</li>
<li>如果用户没有通过认证，发送一个<code>401 Unauthorized</code>响应</li>
<li>对于无效的凭证，发送一个<code>401 Unauthorized</code>响应</li>
</ul>
<h3>API安全性</h3>
<p>安全性是一个广泛的话题。在API级别，最佳实践是，</p>
<ul>
<li>总是验证请求数据</li>
<li>遵循拒绝优先原则，仅当API请求通过特定端点的所有检查时才允许</li>
<li>不允许在没有适当验证的情况下对API进行批量操作</li>
<li>编写集成测试和一些端到端测试，以增强对API操作的信心</li>
</ul>
<h3>当您需要对API进行重大更改时，版本控制可以节省您的时间</h3>
<p>API是用户和开发者之间的契约。当您对模式进行重大更改时，通常会忘记契约，破坏现有API客户端的东西。</p>
<p>这就是API版本控制的用武之地。</p>
<p>例如:</p>
<ul>
<li><code>GET /v1/jobs</code>–获取API版本1并发送XML响应</li>
<li><code>GET /v2/jobs</code>–默认情况下发送JSON响应</li>
</ul>
<p>这样，我们就不会破坏现有消费者的API。相反，我们可以在必要的时候显示一个反对的警告，并要求现有用户使用新版本的API。</p>
<p>版本控制还可以在其他几个方面帮助您:</p>
<ul>
<li>它允许您发布实现的测试版本</li>
<li>它给你的API用户时间来适应任何变化</li>
</ul>
<p>广泛使用的版本化方法的一些例子包括基于数字和基于日期的版本化。</p>
<p>最后，版本控制不需要在URL上。一些API，如Github REST，将版本控制作为自定义头传递:</p>
<p>接受:application/vnd.github.v3+json</p>
<ul>
<li>v3是REST API</li>
<li>v4是图QL API</li>
</ul>
<h3>必要时限制费率</h3>
<p>大多数API不要求速率限制，但是它可以为您的API增加一些基本的安全性。</p>
<p>速率限制有几个级别:</p>
<ul>
<li>基于特定时间段内请求数量的速率限制(基于窗口的速率限制)。当分配的时间到期时，它会自动复位。</li>
<li>基于点数的费率限制，用户需要充值才能再次使用。如果用户没有充值，他们会收到一条错误消息。</li>
<li>通过自定义标头发送有关速率限制的信息，以便客户端知道在一个窗口期内他们还有多少请求或他们的当前配额。</li>
</ul>
<p>Github是这样对他们的API进行速率限制的:</p>
<pre>curl -i https://api.github.com/users/octocat
HTTP/1.1 200 OK
Date: Mon, 01 Jul 2013 17:27:06 GMT
Status: 200 OK
X-RateLimit-Limit: 60
X-RateLimit-Remaining: 56
X-RateLimit-Reset: 1372700873
This way, you don’t need to fetch from DB every time.</pre>
<p>现代数据库针对读取进行了优化，因此这并不总是必要的。尽管如此，尽可能地缓存有助于提高读取速度。</p>
<p>虽然缓存很有价值，但是它给API增加了额外的复杂性，因为每当数据发生变化时，您都需要中断并重新缓存。</p>
<p>如果数据没有改变，服务器应该返回<code>304 Not Modified</code>。这个响应将向您的浏览器客户端显示数据没有改变，并提示服务器重新使用以前获取的旧数据。</p>
<h3>实施CORS</h3>
<p>CORS允许跨域访问API。大多数应用程序只需要将某些域列入白名单，以允许来自这些域的CORS。</p>
<p>对于公共API，您可能需要允许任何人获取数据，前提是他们拥有正确的身份验证密钥集。在这种情况下，实现CORS允许所有域，并开始黑名单域，如果他们看起来可疑。</p>
<h3>当你陷入困境时，伐木会拯救你</h3>
<p>日志记录是开发任何web平台不可或缺的一部分。API也是如此——我们需要根据优先级(错误、信息、警告)来分离日志。)</p>
<p>当出现错误和安全问题时，适当的日志记录和分离将加快以后的调试。</p>
<p>请记住这些提示，以确保您的日志尽可能高效:</p>
<ul>
<li>尝试遵循日志记录中的一些标准(例如:JSON日志)。使用框架进行日志记录将有助于促进标准化，并从长远来看为您节省大量时间。</li>
<li>尝试在日志上创建警报和分析模式，以识别问题</li>
<li>不要升级同一优先级范围内的所有错误。在按照API中的优先级对每个错误进行分类之前，检查有多少用户受到了影响，问题有多大。日志应该有助于识别这些模式。</li>
<li>确保记录所有请求、会话以及关于请求来源的详细信息，以便您可以评估任何与安全相关的问题</li>
</ul>
<h3>监控设置</h3>
<p>以下是监控设置时需要记住的一些提示:</p>
<ul>
<li>投资一个好的监控系统</li>
<li>显示API的状态页面</li>
<li>确保您的支持易于获得。通过Twitter跟进也是一个好主意——这为那些想寻找简单问题答案的人节省了大量时间。</li>
<li>监控响应时间</li>
<li>检查慢速查询并尝试优化它们</li>
</ul>
<h3>面向开发人员的API文档</h3>
<p>为开发人员开发API文档时，确保所有内容都是最新的非常重要:</p>
<ul>
<li>更新API文档和你的拉取请求，如果可能的话，包括文档的版本控制</li>
<li>记录开发API时做出的小决定，并将其添加到版本描述中。这确保了在同一个API上工作的每个人都知道每个决定背后的原因。这也有助于团队自主工作。</li>
</ul>
<p>Postman collections和Swagger API文档是开发人员文档的好例子。</p>
<h3>面向消费者的文档</h3>
<p>公共API文档如下:</p>
<ul>
<li>对你的资源保持清晰</li>
<li>展示关于限制和如何不滥用API的细节</li>
<li>API playground将增强用户体验，也有助于直接测试该特性，而无需复杂的设置</li>
<li>必要时显示警告</li>
</ul>
<p>如果您想阅读优秀的API文档，请查阅以下资源:</p>

<h3>选择合适的框架，不要什么都自己做</h3>
<p>您可以将这最后一条建议应用到您正在进行的任何开发项目中，包括API开发。</p>
<p>一般来说，重用开源框架来为消费者构建一个可靠的API比重新发明轮子更容易。</p>
<h3>结论</h3>
<p>本指南是构建优秀API用户体验的起点。</p>
<p>在很多情况下，我们只需要构建一个快速的API，它可能不会被普通大众使用。</p>
<p>确保访问API的用户，只实现当前产品级别所必需的内容，然后根据需要进行扩展。过早优化从来都不是一个好主意。</p>
<p>欢迎在评论中分享你对构建API的见解和经验。</p><div class="code-block code-block-2">
<div class="blog-plug base-cta"><h2>使用<a class="signup" href="https://lp.logrocket.com/blg/signup" target="_blank" rel="noopener noreferrer"> LogRocket </a>消除传统错误报告的干扰</h2>
<a href="https://lp.logrocket.com/blg/signup" class="signup" target="_blank" rel="noopener noreferrer"><img class="alignnone size-full wp-image-46 jetpack-lazy-image" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/><noscript><img data-lazy-fallback="1" class="alignnone size-full wp-image-46" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/></noscript></a>
<p><a href="https://lp.logrocket.com/blg/signup" target="_blank" rel="noopener noreferrer"> LogRocket </a>是一个数字体验分析解决方案，它可以保护您免受数百个假阳性错误警报的影响，只针对几个真正重要的项目。LogRocket会告诉您应用程序中实际影响用户的最具影响力的bug和UX问题。</p>
<p>然后，使用具有深层技术遥测的会话重放来确切地查看用户看到了什么以及是什么导致了问题，就像你在他们身后看一样。</p>
<p>LogRocket自动聚合客户端错误、JS异常、前端性能指标和用户交互。然后LogRocket使用机器学习来告诉你哪些问题正在影响大多数用户，并提供你需要修复它的上下文。</p>
<p>关注重要的bug—<a class="signup" href="https://lp.logrocket.com/blg/signup-issue-free" target="_blank" rel="noopener noreferrer">今天就试试LogRocket】。</a></p></div></div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
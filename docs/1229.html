<html>
<head>
<title>5 new CSS features you can test right now - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>你现在就可以测试5个新的CSS特性</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/5-new-css-features-you-can-already-test/#0001-01-01">https://blog.logrocket.com/5-new-css-features-you-can-already-test/#0001-01-01</a></blockquote><div><article class="article-post">
<p>在浏览器逐渐开始实现它们之前，CSS特性首先在W3协会的规范中定义——通常是经过长时间的讨论。值得一提的CSS新特性数不胜数，但在本指南中，我们将重点介绍已经可以在至少一个web浏览器的稳定版本中测试的五个特性:</p>
<ol>
<li><a href="#1csssubgrid" rel="noopener"> CSS子网格</a></li>
<li><a href="#2flexboxgaps" rel="noopener">柔性盒间隙</a></li>
<li><a href="#3thecontentvisibilityproperty"><code>content-visibility</code>房产</a></li>
<li><a href="#4thecontainintrinsicsizeproperty"><code>contain-intrinsic-size</code>房产</a></li>
<li><a href="#5theisandwherepseudoclasses">中的<code>:is</code>和<code>:where</code>伪类</a></li>
</ol>
<p>请注意，浏览器对这些功能的支持一直在变化，因此请经常查看网站的当前支持水平，如<a href="https://caniuse.com/" target="_blank" rel="noopener noreferrer">我能使用</a>、<a href="https://developer.mozilla.org/en-US/docs/Web/CSS/Reference" target="_blank" rel="noopener noreferrer"> MDN CSS参考</a>(支持信息在每页的底部)，以及<a href="https://chromestatus.com/features" target="_blank" rel="noopener noreferrer"> Chrome平台状态</a>。</p>
<h2 id="1csssubgrid">1.CSS子网格</h2>
<p>CSS Grid是一个灵活的布局模块，允许开发人员创建复杂的布局，而无需使用JavaScript或求助于混乱的CSS技巧。</p>
<p>要将网格布局应用于HTML元素，请向其添加以下规则。</p>
<pre> .grid-container {
    display: grid;
}
</pre>
<p>有几个特定于网格的属性可用于设置您需要的精确布局。</p>
<p>例如，在上面的例子中，<code>.grid-container</code>的子元素将是网格项，它们将根据您用<a href="https://developer.mozilla.org/en-US/docs/Web/CSS/grid-template-columns" target="_blank" rel="noopener noreferrer"> <code>grid-template-columns</code> </a>和<a href="https://developer.mozilla.org/en-US/docs/Web/CSS/grid-template-rows" target="_blank" rel="noopener noreferrer"> <code>grid-template-rows</code> </a>属性定义的规则进行布局:</p>
<pre>.grid-container {
    display: grid;
    grid-template-columns: 1fr 2fr 1fr;
    grid-template-rows: 50px 70vh 50px;
}
</pre>
<p>上面的代码定义了下面的CSS网格布局。</p>
<p><img data-attachment-id="27073" data-permalink="https://blog.logrocket.com/5-new-css-features-you-can-already-test/css-grid-layout/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/10/css-grid-layout.jpeg" data-orig-size="720,359" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;1&quot;}" data-image-title="CSS grid layout" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/10/css-grid-layout-300x150.jpeg" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/10/css-grid-layout.jpeg" decoding="async" class="aligncenter size-full wp-image-27073 jetpack-lazy-image" src="../Images/e5b684ac0630dc40555eb3fb3d3db94e.png" alt="CSS Grid Layout" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2020/10/css-grid-layout.jpeg 720w, https://blog.logrocket.com/wp-content/uploads/2020/10/css-grid-layout-300x150.jpeg 300w" data-lazy-sizes="(max-width: 720px) 100vw, 720px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2020/10/css-grid-layout.jpeg?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/10/css-grid-layout.jpeg"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="27073" data-permalink="https://blog.logrocket.com/5-new-css-features-you-can-already-test/css-grid-layout/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/10/css-grid-layout.jpeg" data-orig-size="720,359" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;1&quot;}" data-image-title="CSS grid layout" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/10/css-grid-layout-300x150.jpeg" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/10/css-grid-layout.jpeg" decoding="async" loading="lazy" class="aligncenter size-full wp-image-27073" src="../Images/e5b684ac0630dc40555eb3fb3d3db94e.png" alt="CSS Grid Layout" srcset="https://blog.logrocket.com/wp-content/uploads/2020/10/css-grid-layout.jpeg 720w, https://blog.logrocket.com/wp-content/uploads/2020/10/css-grid-layout-300x150.jpeg 300w" sizes="(max-width: 720px) 100vw, 720px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/10/css-grid-layout.jpeg"/></noscript>
<p>但是，如果您也想在网格布局中包含一些(或全部)孙元素呢？这就是CSS子网格发挥作用的地方。</p>
<p>您可以将以下规则添加到网格项目，使其能够采用其父项的网格轨迹(包括名称网格线和区域，即使它也可以定义自己的)。</p>
<pre>.grid-item {
    /* these rules specify the subgrid's position within the layout */
    grid-column: 2 / 4;      /* two columns vertically */
    grid-row: 1 / 3;         /* two rows horizontally */

    /* these rules belong to the subgrid itself */
    display: grid;
    grid-template-columns: subgrid;
    grid-template-rows: subgrid;
}
</pre>
<p><a href="https://developer.mozilla.org/en-US/docs/Web/CSS/grid-column" target="_blank" rel="noopener noreferrer"> <code>grid-column</code> </a>和<a href="https://developer.mozilla.org/en-US/docs/Web/CSS/grid-row" target="_blank" rel="noopener noreferrer"> <code>grid-row</code> </a>属性定义网格项在网格列或行中的位置。<code>.grid-item</code>的子元素将形成子网格。一个网格项目可以跨越多个网格单元。例如，这里它分布在四个单元格中(在上面的例子中，<code>grid-column</code>和<code>grid-row</code>的值是任意的)。</p>
<p>如您所见，<code>subgrid</code>不是一个独立的CSS属性，而是一个可以添加到<code>grid-template-columns</code>和<code>grid-template-rows</code>属性中的值。它使<code>.grid-item</code>的子节点包含在网格布局中:</p>
<p><img data-attachment-id="27072" data-permalink="https://blog.logrocket.com/5-new-css-features-you-can-already-test/css-subgrid-layout/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/10/css-subgrid-layout.jpeg" data-orig-size="720,363" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;1&quot;}" data-image-title="CSS subgrid layout" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/10/css-subgrid-layout-300x151.jpeg" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/10/css-subgrid-layout.jpeg" decoding="async" class="aligncenter size-full wp-image-27072 jetpack-lazy-image" src="../Images/b09f22bcbcdb117aa15ab9cd8fe05a9f.png" alt="CSS Subgrid Layout" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2020/10/css-subgrid-layout.jpeg 720w, https://blog.logrocket.com/wp-content/uploads/2020/10/css-subgrid-layout-300x151.jpeg 300w" data-lazy-sizes="(max-width: 720px) 100vw, 720px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2020/10/css-subgrid-layout.jpeg?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/10/css-subgrid-layout.jpeg"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="27072" data-permalink="https://blog.logrocket.com/5-new-css-features-you-can-already-test/css-subgrid-layout/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/10/css-subgrid-layout.jpeg" data-orig-size="720,363" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;1&quot;}" data-image-title="CSS subgrid layout" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/10/css-subgrid-layout-300x151.jpeg" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/10/css-subgrid-layout.jpeg" decoding="async" loading="lazy" class="aligncenter size-full wp-image-27072" src="../Images/b09f22bcbcdb117aa15ab9cd8fe05a9f.png" alt="CSS Subgrid Layout" srcset="https://blog.logrocket.com/wp-content/uploads/2020/10/css-subgrid-layout.jpeg 720w, https://blog.logrocket.com/wp-content/uploads/2020/10/css-subgrid-layout-300x151.jpeg 300w" sizes="(max-width: 720px) 100vw, 720px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/10/css-subgrid-layout.jpeg"/></noscript>
<p>正如您所看到的，子网格已经成为网格布局的一部分，它已经被定位到我们想要的确切位置(在第二和第四条垂直网格线与第一和第三条水平网格线之间)。</p>
<p>其余的网格项保持了正常的网格流，第四行也出现在布局的底部。但是，由于我们只使用<code>grid-template-rows</code>属性定义了三行，所以第四行没有预设值，所以它只取其内容的自然高度。如果我们从最后三个网格项中删除文本，它们甚至不会出现，因为它们的自然高度是0。</p>
<p>您可以使用下面的CodePen演示来测试上面的例子。</p>
<p class="codepen" data-height="265" data-theme-id="light" data-default-tab="css,result" data-user="amonus" data-slug-hash="dyMgeLP" data-pen-title="Subgrid test">参见<a href="https://codepen.io"> CodePen </a>上安娜·莫努斯(<a href="https://codepen.io/amonus">@阿蒙斯</a> ) <br/>的Pen <a href="https://codepen.io/amonus/pen/dyMgeLP"> <br/>亚格子测试</a>。</p>
<p/>
<p>您也可以通过仅采用<code>grid-template-columns</code>或<code>grid-template-rows</code>并对另一个使用新值来创建一维子网格。</p>
<p>例如，在下面的例子中，子网格只采用主网格的列，但是它为行创建了一个新规则。</p>
<pre>.grid-item {
        display: grid;
        grid-template-columns: subgrid;
        grid-template-rows: 200px 400px 200px;
}
</pre>
<h3>浏览器支持</h3>
<p>CSS子网格规范是2020年8月的W3C候选推荐标准。目前，只有火狐71+ 支持<a href="https://caniuse.com/css-subgrid" target="_blank" rel="noopener noreferrer">，但也有</a><a href="https://blog.chromium.org/2020/06/improving-chromiums-browser.html" target="_blank" rel="noopener noreferrer">即将推出Chromium </a>，这款开源网络浏览器被用作包括Chrome、Opera、Brave和新的微软Edge在内的主流浏览器的基础。</p>
<p>如果你需要一个后备方法，注意嵌套网格(用<code>inherit</code>值定义)和CSS子网格不是一回事。可以使用嵌套网格并重新计算网格轨迹来模拟子网格；然而，在这种情况下，您仍然有两个独立的网格，而不是一个与网格项目的一些或所有子项目共享其轨迹的网格。</p>
<h2 id="2flexboxgaps">2.柔性盒间隙</h2>
<p>长期以来，在flexbox布局中的flex行或flex列之间添加间隙一直是一个难题。这通常是通过向flex项目添加边距来解决的，但边距的问题是，它们也被添加到每个flex行或列的开头和结尾。尽管可以通过在第一个/最后一个元素上添加负边距来消除这些问题，但这并不是最优雅的解决方案。</p>
<p>幸运的是，浏览器对flexbox gaps的支持越来越好。<a href="https://developer.mozilla.org/en-US/docs/Web/CSS/gap" target="_blank" rel="noopener noreferrer"> <code>gap</code> </a>、<a href="https://developer.mozilla.org/en-US/docs/Web/CSS/row-gap" target="_blank" rel="noopener noreferrer"> <code>row-gap</code> </a>和<code><a href="https://developer.mozilla.org/en-US/docs/Web/CSS/column-gap" target="_blank" rel="noopener noreferrer">column-gap</a></code>属性存在于不同的上下文中，具有不同级别的浏览器支持。您可以在以下布局模块中使用间隙属性。</p>
<ul>
<li>Flexbox，由<code>display: flex;</code>声明定义</li>
<li>CSS网格，由<code>display: grid;</code>声明定义</li>
<li>多列(多线圈)布局，由<code>column-count</code>和/或<code>column-width</code>属性定义</li>
</ul>
<p>你可以在<a href="https://www.w3.org/TR/css-align-3/#gaps" target="_blank" rel="noopener noreferrer"> CSS框对齐模块(3级)</a>规范中找到gap属性的共享语法。</p>
<p>您可以使用具有任意长度值(px、em、rem、cm、mm、vmin、vmax等)的<code>gap</code>、<code>row-gap</code>和<code>column-gap</code>属性。)或百分比(%)。</p>
<p>在flexbox上下文中，您需要将它们添加到flex容器中(而不是添加到flex条目中)。</p>
<pre>.flex-container {
  row-gap: 10px;
  column-gap: 15px;
}
</pre>
<p><code>gap</code>属性是<code>row-gap</code>和<code>column-gap</code>的简写。如果使用两个值，那么第一个值属于<code>row-gap</code>，第二个值属于<code>column-gap</code>。</p>
<pre>.flex-container {
  gap: 10px 15px;
}
</pre>
<p>如果只使用一个值，<code>row-gap</code>和<code>column-gap</code>将取相同的值。</p>
<pre>.flex-container {
  gap: 10px;
}
</pre>
<h3>浏览器支持</h3>
<p>您可以在相关的<a href="https://caniuse.com/?search=gap" target="_blank" rel="noopener noreferrer">我可以使用表格</a>中检查浏览器对gap属性的支持，这些表格显示了在各种上下文中的支持。你可以看到它在CSS网格布局中得到最广泛的支持，因为这是它第一次被定义的地方。</p>
<p>在flexbox布局中，Edge 84+、Firefox 63+、Chrome 84+和Opera 70+目前支持gap属性。Internet Explorer(显然)和Safari不支持它。</p>
<p>考虑到Safari和旧浏览器的回退，<code>gap</code>属性的问题是您不能用<a href="https://developer.mozilla.org/en-US/docs/Web/CSS/@supports" target="_blank" rel="noopener noreferrer"> <code>@supports</code> </a>特性查询来测试它，因为浏览器在三个布局模块(flexbox、CSS grid、multicol)中的支持是不同的，并且<code>@supports</code>检查最广泛支持的上下文(CSS grid)。如果你需要支持Safari、IE或更老的浏览器，现在最好使用margin hack(除非你想用JavaScript做额外的检查)。</p>
<h2 id="3thecontentvisibilityproperty">3.<code>content-visibility</code>属性</h2>
<p><a href="https://www.w3.org/TR/css-contain-2/#content-visibility" target="_blank" rel="noopener noreferrer"> <code>content-visibility</code> </a>属性使您能够管理屏幕外元素的呈现过程(和可见性)。作为CSS包容模块的一部分，这个组件可以帮助你显著提高页面的渲染性能。</p>
<p>它可以有三个值:</p>
<ul>
<li><code>visible</code>(默认)—元素的渲染正常进行</li>
<li><code>hidden</code> —当元素的渲染被跳过时，无论是在屏幕外还是在屏幕上</li>
<li><code>auto</code> —元素离屏时，跳过其渲染；当它出现在屏幕上时，它的渲染会自动实现</li>
</ul>
<p>您可以简单地将<code>content-visibility</code>属性添加到您想要更改其呈现过程的元素中。</p><div class="code-block code-block-54">
<hr/>
<h3>更多来自LogRocket的精彩文章:</h3>

<hr/></div>
<pre>article {
  content-visibility: auto;
} 
</pre>
<p>当内容可见性自动化时(取<code>auto</code>值)，呈现过程的不同方面(布局、风格、绘画和大小控制)会自动打开和关闭——你可以在<a href="https://web.dev/content-visibility/" target="_blank" rel="noopener noreferrer">这本优秀的指南</a>中详细了解。在他们的测试网站(一个旅游博客)上，作者通过将<code>content-visibility: auto;</code>规则添加到测试博客的不同部分，成功地将初始页面加载的渲染时间减少了七倍多(从232毫秒到30毫秒)——这是一个相当令人印象深刻的结果。</p>
<h3>浏览器支持</h3>
<p>目前Chrome 85+、Edge 85+和Opera 71+支持的<a href="https://caniuse.com/css-content-visibility" target="_blank" rel="noopener noreferrer">属性。火狐团队也在讨论添加功能</a>，但它仍处于非常早期的阶段。</p>
<h2 id="4thecontainintrinsicsizeproperty">4.<code>contain-intrinsic-size</code>属性</h2>
<p><a href="https://www.w3.org/TR/css-sizing-4/#propdef-contain-intrinsic-size" target="_blank" rel="noopener noreferrer"> <code>contain-intrinsic-size</code> </a>属性定义了激活了<a href="https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Containment#Size_containment" target="_blank" rel="noopener noreferrer">大小约束</a>的元素的显式宽度和高度，这意味着元素的大小不受其子元素大小的影响。设置明确的宽度和/或高度旨在防止这些元素在某些情况下折叠为零。</p>
<p>例如，当<code>content-visibility</code>被设置为<code>auto</code>时，建议您为<code>contain-intrinsic-size</code>定义一个值(参见上一节)。当屏幕外元素的渲染过程被跳过时，它们被渲染为空元素，所以它们的宽度和高度默认设置为<code>0</code>。但是，在它们滚动到视图中之前，它们的内容会自动呈现在屏幕上，这可能会导致UX问题，例如滚动条大小的突然变化。</p>
<p><code>contain-intrinsic-size</code>的默认值为<code>none</code>，但可以取任意长度值(px、rem、em、cm、mm等。)也是。您可以使用一个或两个值。对于一个值，固有的宽度和高度将是相同的，而对于两个值，第一个值提供宽度，第二个值提供高度。例如:</p>
<pre>article {
  content-visibility: auto;
  contain-intrinsic-size: 700px 1000px;
} 
</pre>
<h3>浏览器支持</h3>
<p>目前，<a href="https://www.chromestatus.com/feature/5737051062272000" target="_blank" rel="noopener noreferrer"> Chrome 83+ </a>、Edge 83+和Opera 69+支持<code>contain-intrinsic-size</code>属性。火狐不支持。</p>
<h2 id="5theisandwherepseudoclasses">5.<code>:is()</code>和<code>:where()</code>伪类</h2>
<p>由<a href="https://www.w3.org/TR/selectors-4/" target="_blank" rel="noopener noreferrer">选择器第4级</a>规范定义的<a href="https://developer.mozilla.org/en-US/docs/Web/CSS/:is" target="_blank" rel="noopener noreferrer"> <code>:is()</code> </a>和<a href="https://developer.mozilla.org/en-US/docs/Web/CSS/:where" target="_blank" rel="noopener noreferrer"> <code>:where()</code> </a>伪类使得减少较长CSS选择器列表中的重复成为可能。它们可用于标记重复选择器中的唯一项目，这样您只需添加一个选择器，而不是几个。</p>
<p>这两个伪类做的事情几乎一样；唯一的区别在于具体程度。<code>:is()</code>取括号内最具体元素的具体性，而<code>:where()</code>的具体性始终是<code>0</code>。特异性很重要，因为它决定了覆盖给定CSS规则的难易程度。</p>
<p>例如，如果您有以下选择器列表:</p>
<pre>.my-class p em,
.my-class li em,
.my-class section em {
    // CSS rules
}
</pre>
<p>如果您想保持较高的特异性，以使后续声明更难覆盖所属规则，那么您可以使用<code>:is()</code>来缩短列表。</p>
<pre>.my-class :is(p, li, section) em {
  // CSS rules
}
</pre>
<p>如果您想保持特异性<code>0</code>以便更容易覆盖所属规则，您可以使用<code>:where()</code>。</p>
<pre>.my-class :where(p, li, section) em {
  // CSS rules
}
</pre>
<p>在上面的例子中，<code>.my-class em</code>选择器会覆盖<code>:where</code>规则，但不会覆盖<code>:is</code>。你可以在下面的CodePen演示中比较这两个伪类的效果——目前，它只在Firefox中有效(<code>:is</code>在Safari中也有效，但<code>:where</code>无效)，但你可以在Chrome中通过启用chrome://flags/ URL中的<code>Experimental Web Platform features</code>标志来测试该功能。</p>
<p class="codepen" data-height="265" data-theme-id="light" data-default-tab="html,result" data-user="amonus" data-slug-hash="dyMEbqQ" data-pen-title="Testing :is and :where pseudo-classes">参见<a href="https://codepen.io/amonus/pen/dyMEbqQ"> <br/>测试之笔:is and :where伪类</a>作者安娜·莫纳斯(<a href="https://codepen.io/amonus">@阿蒙斯</a> ) <br/>于<a href="https://codepen.io"> CodePen </a>。</p>
<p>浏览器支持</p>
<h3>Firefox 78+和Safari 14+目前支持的<a href="https://caniuse.com/css-matches-pseudo" target="_blank" rel="noopener noreferrer"> <code>:is</code>伪类。基于Chromium的浏览器(Chrome 15+，Edge 79+，Opera 15+)支持使用<code>:-webkit-any()</code>前缀的前缀语法。在Chrome 68+、Opera 55+和Edge 79+中也可以通过将<code>Experimental Web Platform features</code>标志设置为选中来启用该功能。</a></h3>
<p>而<a href="https://caniuse.com/mdn-css_selectors_where" target="_blank" rel="noopener noreferrer"> <code>:where</code>伪类就没那么广泛支持</a>。目前，只有Firefox 78+支持它，但您可以通过使用<code>Experimental Web Platform features</code>标志在Chrome 72+中启用它。</p>
<p>最后的想法</p>
<h2 id="finalthoughts">您应该谨慎使用本文中讨论的新CSS特性。理想情况下，您应该为它们提供一个反馈方法，使用带前缀的版本，或者等到它们被更广泛地实现。</h2>
<p>但是，如果您喜欢试验，您已经可以使用<code>content-visibility</code>和<code>contain-intrinsic-size</code>属性。你可以在已经支持它的浏览器中实现严重的性能优化(你可以用<code>@supports</code>规则测试浏览器的支持)，并且它们不会影响还不支持它的浏览器。</p>
<p>除了这五个新的CSS特性之外，还有许多其他有趣的发展，比如还没有在任何浏览器中实现的<code>aspect-ratio</code> ( <a href="https://drafts.csswg.org/css-sizing-4/#aspect-ratio" target="_blank" rel="noopener noreferrer"> W3 </a>、<a href="https://developer.mozilla.org/en-US/docs/Web/CSS/aspect-ratio" target="_blank" rel="noopener noreferrer"> MDN </a>、<a href="https://caniuse.com/?search=aspect-ratio" target="_blank" rel="noopener noreferrer">我可以使用</a>)和<code>leading-trim</code> ( <a href="https://www.w3.org/TR/css-inline-3/#leading-trim" target="_blank" rel="noopener noreferrer"> W3 </a>)属性，以及已经在中实现的<code>::marker</code>伪元素(<a href="https://www.w3.org/TR/css-lists-3/#marker-pseudo" target="_blank" rel="noopener noreferrer"> W3 </a>、<a href="https://developer.mozilla.org/en-US/docs/Web/CSS/::marker" target="_blank" rel="noopener noreferrer"> MDN </a>、<a href="https://caniuse.com/css-marker-pseudo" target="_blank" rel="noopener noreferrer">我可以使用</a></p>
<p>总而言之，值得不断关注CSS新特性的标准化和实现过程。浏览器中有许多有用的功能，最终将使前端开发变得更容易、更快。</p>
<p>你的前端是否占用了用户的CPU？</p><div class="code-block code-block-25">
<div class="blog-plug inline-plug css-plug"><h2>随着web前端变得越来越复杂，资源贪婪的特性对浏览器的要求越来越高。如果您对监控和跟踪生产环境中所有用户的客户端CPU使用、内存使用等感兴趣，</h2><p>.</p><a target="_blank" href="https://lp.logrocket.com/blg/css-signup">try LogRocket</a><p>LogRocket 就像是网络和移动应用的DVR，记录你的网络应用或网站上发生的一切。您可以汇总和报告关键的前端性能指标，重放用户会话和应用程序状态，记录网络请求，并自动显示所有错误，而不是猜测问题发生的原因。</p><a class="signup" href="https://lp.logrocket.com/blg/css-signup" target="_blank" rel="noopener noreferrer"><img class="alignnone size-full wp-image-46 jetpack-lazy-image" src="../Images/dacb06c713aec161ffeaffae5bd048cd.png" alt="LogRocket Dashboard Free Trial Banner" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2019/12/cpu-memory-usage.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/12/cpu-memory-usage.png"/><noscript><img data-lazy-fallback="1" class="alignnone size-full wp-image-46" src="../Images/dacb06c713aec161ffeaffae5bd048cd.png" alt="LogRocket Dashboard Free Trial Banner" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/12/cpu-memory-usage.png"/></noscript></a><a href="https://lp.logrocket.com/blg/css-signup" target="_blank" rel="noopener noreferrer">https://logrocket.com/signup/</a><p>现代化您调试web和移动应用的方式— <a class="signup" href="https://lp.logrocket.com/blg/css-signup" target="_blank" rel="noopener noreferrer">开始免费监控</a>。</p><p>Modernize how you debug web and mobile apps — <a class="signup" href="https://lp.logrocket.com/blg/css-signup" target="_blank" rel="noopener noreferrer">Start monitoring for free</a>.</p></div>
</div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
<html>
<head>
<title>GraphQL subscriptions with Node.js and Express - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>Node.js和Express - LogRocket博客的GraphQL订阅</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/graphql-subscriptions-nodejs-express/#0001-01-01">https://blog.logrocket.com/graphql-subscriptions-nodejs-express/#0001-01-01</a></blockquote><div><article class="article-post">
<blockquote><p>编者按:这篇文章最后一次更新是在2021年11月29日，以反映GraphQL的更新。</p></blockquote>
<p>你有没有想过当朋友发布消息时，脸书会如何通知你？或者谷歌地图如何实时更新你的位置？这些和许多其他谜团的答案是GraphQL订阅。GraphQL订阅使您能够订阅源流下的事件，并在所选事件执行时通过响应流实时接收通知。</p>
<p>在本文中，我们将提供对Node.js服务器中JSON数据事件的GraphQL订阅的基本理解。你可以在<a href="https://github.com/finallyayo/graphql-subscription"> GitHub </a>上获得本教程中使用的完整源代码。</p>
<p>在我们开始之前，您应该具备以下条件:</p>

<p>我们开始吧！</p>
<blockquote><p>注意:您可以在这个<a href="https://github.com/finallyayo/graphql-subscription"> GitHub资源库</a>中访问该项目的完整源代码。</p></blockquote>
<h3>目录</h3>

<h2 id="howdographqlsubscriptionswork">GraphQL订阅是如何工作的？</h2>
<p>执行GraphQL订阅后，将在服务器上创建一个持久函数，该函数将底层的源流映射到返回的响应流，如下图所示:</p>
<figure id="attachment_80357" aria-describedby="caption-attachment-80357" class="wp-caption aligncenter"><img data-attachment-id="80357" data-permalink="https://blog.logrocket.com/graphql-subscriptions-nodejs-express/graphql-subscription-high-level-overview/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/01/graphql-subscription-high-level-overview.png" data-orig-size="730,397" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="graphql-subscription-high-level-overview" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/01/graphql-subscription-high-level-overview-300x163.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/01/graphql-subscription-high-level-overview.png" decoding="async" class="wp-image-80357 size-full jetpack-lazy-image" src="../Images/bbeac6ddbb36cee34fe3c09fdeffb3b0.png" alt="GraphQL Subscription High Level Overview" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2020/01/graphql-subscription-high-level-overview.png 730w, https://blog.logrocket.com/wp-content/uploads/2020/01/graphql-subscription-high-level-overview-300x163.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2020/01/graphql-subscription-high-level-overview.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/01/graphql-subscription-high-level-overview.png"/><noscript><img data-lazy-fallback="1" data-attachment-id="80357" data-permalink="https://blog.logrocket.com/graphql-subscriptions-nodejs-express/graphql-subscription-high-level-overview/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/01/graphql-subscription-high-level-overview.png" data-orig-size="730,397" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="graphql-subscription-high-level-overview" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/01/graphql-subscription-high-level-overview-300x163.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/01/graphql-subscription-high-level-overview.png" decoding="async" loading="lazy" class="wp-image-80357 size-full" src="../Images/bbeac6ddbb36cee34fe3c09fdeffb3b0.png" alt="GraphQL Subscription High Level Overview" srcset="https://blog.logrocket.com/wp-content/uploads/2020/01/graphql-subscription-high-level-overview.png 730w, https://blog.logrocket.com/wp-content/uploads/2020/01/graphql-subscription-high-level-overview-300x163.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/01/graphql-subscription-high-level-overview.png"/></noscript><figcaption id="caption-attachment-80357" class="wp-caption-text">High level overview of GraphQL subscriptions</figcaption></figure>
<blockquote><p>(来源:<a href="https://github.com/sangria-graphql/sangria-subscriptions-example"> GitHub </a>)</p></blockquote>
<p>GraphQL订阅与查询的不同之处在于向客户端传递数据的方式。查询会立即返回一个响应，而GraphQL订阅会在每次发布关于您订阅的主题的数据时返回一个结果。</p>
<p>GraphQL订阅方法是由一个<a href="https://www.apollographql.com/docs/graphql-subscriptions/setup/">发布者/订阅者机制</a>促成的，该机制可以有效地、大规模地处理事件驱动的系统。在发布者/订阅者模型中，所有消息和数据根据队列原则(先进先出)流动，然后到达订阅者:</p>
<figure id="attachment_80360" aria-describedby="caption-attachment-80360" class="wp-caption aligncenter"><img data-attachment-id="80360" data-permalink="https://blog.logrocket.com/graphql-subscriptions-nodejs-express/graphql-publisher-subscriber-mechanism/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/01/graphql-publisher-subscriber-mechanism.png" data-orig-size="730,383" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="graphql-publisher-subscriber-mechanism" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/01/graphql-publisher-subscriber-mechanism-300x157.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/01/graphql-publisher-subscriber-mechanism.png" decoding="async" class="wp-image-80360 size-full jetpack-lazy-image" src="../Images/78521dfed7021d0e5f01e9959d23050d.png" alt="GraphQL Publisher Subscriber Mechanism" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2020/01/graphql-publisher-subscriber-mechanism.png 730w, https://blog.logrocket.com/wp-content/uploads/2020/01/graphql-publisher-subscriber-mechanism-300x157.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2020/01/graphql-publisher-subscriber-mechanism.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/01/graphql-publisher-subscriber-mechanism.png"/><noscript><img data-lazy-fallback="1" data-attachment-id="80360" data-permalink="https://blog.logrocket.com/graphql-subscriptions-nodejs-express/graphql-publisher-subscriber-mechanism/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/01/graphql-publisher-subscriber-mechanism.png" data-orig-size="730,383" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="graphql-publisher-subscriber-mechanism" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/01/graphql-publisher-subscriber-mechanism-300x157.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/01/graphql-publisher-subscriber-mechanism.png" decoding="async" loading="lazy" class="wp-image-80360 size-full" src="../Images/78521dfed7021d0e5f01e9959d23050d.png" alt="GraphQL Publisher Subscriber Mechanism" srcset="https://blog.logrocket.com/wp-content/uploads/2020/01/graphql-publisher-subscriber-mechanism.png 730w, https://blog.logrocket.com/wp-content/uploads/2020/01/graphql-publisher-subscriber-mechanism-300x157.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/01/graphql-publisher-subscriber-mechanism.png"/></noscript><figcaption id="caption-attachment-80360" class="wp-caption-text">Diagram of the queue principle in the context of GraphQL subscriptions</figcaption></figure>
<blockquote><p>注意:对于生产，建议使用Redis 的<a href="https://redis.io/topics/pubsub">发布/订阅实现。</a></p></blockquote>
<p>npm上有许多可用的包，可以用来实现GraphQL订阅的发布/订阅模型。以下是一些最常用的软件包:</p>
<ul>
<li><code><a href="https://github.com/prisma-labs/graphql-yoga">graphql-yoga</a></code>:功能全面的GraphQL服务器，专注于简单的设置、性能和出色的开发人员体验</li>
<li><a href="https://github.com/apollographql/graphql-subscriptions"> <code>graphql-subscriptions</code> </a>:让您将GraphQL与发布/订阅系统(如Redis)连接起来，以实现GraphQL订阅</li>
<li><a href="https://github.com/apollographql/apollo-server"><code>apollo-server-express</code></a>:graph QL服务器的Express和connect集成。Apollo server是一个由社区维护的开源GraphQL服务器，可以与许多Node.js HTTP服务器框架一起工作</li>
</ul>
<p>我们将使用<code>graphql-yoga</code>模块，因为它是建立在其他两个包之上的，它提供了所有必要的依赖项和与Node.js的服务器绑定。</p>
<h2 id="buildingourgraphqlapplication">构建我们的GraphQL应用程序</h2>
<p>我们将使用存储在JSON文件中的预定义post数据来执行以下操作:</p>
<ul>
<li><code>getPosts</code>:阅读所有帖子</li>
<li><code>getPost</code>:通过ID阅读特定帖子</li>
<li><code>updatePost</code>:更新帖子</li>
<li><code>deletePost</code>:删除帖子</li>
<li><code>createPost</code>:创建帖子</li>
</ul>
<p>然后，我们将订阅添加到最后三个操作中。现在，是时候用一些代码来弄脏我们的手了！首先，创建一个文件夹，随意命名，并用一个<code>package.json</code>文件初始化，如下所示:</p>
<pre>mkdir graphql-sub
cd graphql-sub
npm init -y
</pre>
<p>接下来，安装所需的依赖项:</p>
<pre>npm i graphql-yoga
</pre>
<p>现在，我们将创建所有文件:</p>
<pre>mkdir src
cd src
touch index.js postData.json typeDefs.js resolver.js
</pre>
<p><code>index.js</code>负责使用pub/sub创建GraphQL服务器，稍后我们将看到。<code>postData.json</code>是JSON文件，我们将在其中执行CRUD操作。您可以添加来自GitHub 的<a href="https://gist.github.com/dg92/78ce53985f4a647681da6fc7c7c9dab7">示例代码，或者使用以下模式为帖子创建一个对象数组:</a></p>
<ul>
<li><code>id:ID!</code></li>
<li><code>title:String!</code></li>
<li><code>subtitle:String!</code></li>
<li><code>body:String!</code></li>
<li><code>published:Boolean!</code></li>
<li><code>author: String!</code></li>
<li><code>upvotes: Int!</code></li>
<li><code>downvotes: Int!</code></li>
<li><code>commentCount: Int!</code></li>
</ul>
<p>我们使用<code>typeDefs.js</code>为上面的操作创建模式。最后，<code>resolvers.js</code>有逻辑来解析在<code>typeDefs.js</code>下定义的所有查询、变异和订阅。在<code>typeDefs.js</code>中，添加以下代码:</p>
<pre>//type definitions and schemas - (operation and data structure)
const typeDefs = `
    type Query {
        getPosts(query: String):[Post!]!
        getPost(query: String):Post!
    }

    type Post{
        id:ID!
        title:String!
        subtitle:String!
        body:String!
        published:Boolean!
        author: String!
        upvotes: Int!
        downvotes: Int!
        commentCount: Int!
    }

    type Mutation{
        updatePost(
          id:ID!
          title:String!
          subtitle:String!
          body:String!
          published:Boolean!
          author: String!
          upvotes: Int!
          downvotes: Int!
          commentCount: Int!
        ): Post!
        deletePost(id: ID!): Post!
        createPost(
          id:ID!
          title:String!
          subtitle:String!
          body:String!
          published:Boolean!
          author: String!
          upvotes: Int!
          downvotes: Int!
          commentCount: Int!
        ): Post!
    }

    type Subscription {
        post: PostSubscriptionPayload!
    }

    type PostSubscriptionPayload {
        mutation: String!
        data: Post!
    }
`;

module.exports = typeDefs;
</pre>
<p>除了查询和突变的正常模式定义，我们还有一个名为<code>Subscription</code>的类型，它通过自定义类型<code>SubscriptionPayload</code>添加到<code>post</code>对象上。</p>
<p>因此，每次对一个<code>post</code>对象进行更改，都会触发一个事件，返回所执行的变异的名称，可以是<code>update</code>、<code>delete</code>或<code>create</code>一个post。</p>
<p>现在，让我们为上面的<code>typeDefs</code>编写<code>resolvers.js</code>文件的框架:</p>
<pre>const posts = require('./postData');
//Resolvers - This are the set of the function defined to get the desired output for the given API
const resolvers = {
  Query:{

  },

  Mutation:{

  },

  Subscription:{

  },
}
module.exports = resolvers;
</pre>
<p>我们导入了<code>postData</code>，然后添加了我们的<code>resolver</code>对象，它包含了我们的<code>Query</code>、<code>Mutation</code>和<code>Subscription</code>对象。我们将在下面的章节中充实每个对象。</p>
<h2 id="codingourqueryobject">编码我们的<code>Query</code>对象</h2>
<p>在我们的<code>Query</code>对象中，我们将定义两个查询，<code>getPost</code>和<code>getPosts</code>:</p>
<pre>Query: {
  getPosts() {
    return posts;
  },
  getPost(parent, args) {
    return posts.filter((post) =&gt; {
      const body = post.body.toLowerCase().includes(args.query.toLowerCase());
      const title = post.title
        .toLowerCase()
        .includes(args.query.toLowerCase());
      return body || title;
    });
  },
},
</pre>
<h2 id="codingourmutationobject">编码我们的<code>mutation</code>对象</h2>
<p>我们将在我们的<code>mutation</code>对象中定义三个突变，<code>createPost</code>、<code>updatePost</code>和<code>deletePost</code>。</p>
<h3><code>createPost</code></h3>
<p><code>createPost</code>方法检查该ID的帖子是否已经存在。如果是这样，我们将向GraphQL服务器抛出一个错误。否则，我们将从<code>args</code>对象创建帖子，并将其添加到我们的posts JSON数据中:</p>
<pre>createPost(parent, args, { pubsub }) {
  const id = parseInt(args.id, 10);
  const postIndex = posts.findIndex((post)=&gt; post.id === id);

  if (postIndex === -1) {
    posts.push({
      ...args
    });

    pubsub.publish('post', {
      post:{
        mutation: 'CREATED',
        data: {...args}
      }
    }); 

   return {...args};
  };

  throw new Error('Post with same id already exist!');
}
</pre>
<p>一旦创建了帖子，我们将通过套接字将新创建的帖子数据发布到<code>post</code>通道的所有订阅者。</p>
<h3><code>updatePost</code></h3>
<p>在<code>updatePost</code>方法中，具有指定ID的文章将被更新为<code>args</code>的内容。如果帖子ID不存在，我们将抛出一个错误:</p>
<pre>updatePost(parent, args, { pubsub }) {
  const id = parseInt(args.id, 10);
  const postIndex = posts.findIndex((post) =&gt; post.id === id);

  if (postIndex !== -1) {
    const post = posts[postIndex];
    const updatedPost = {
      ...post,
      ...args,
    };

    posts.splice(postIndex, 1, updatedPost);

    pubsub.publish("post", {
      post: {
        mutation: "UPDATED",
        data: updatedPost,
      },
    });
    return updatedPost;
  }

  throw new Error("Post does not exist!");
},
</pre>
<p>如您所见，当操作成功时，发布了一个名为<code>UPDATED</code>的新事件。</p>
<h3><code>deletePost</code></h3>
<p>如果ID存在，<code>deletePost</code>方法从数组中删除一个post。之后，发布一个名为<code>DELETED</code>的新事件，其中包含已删除的帖子数据:</p>
<pre>deletePost(parent, args, { pubsub }) {
  const id = parseInt(args.id, 10);
  const isPostExists = posts.findIndex((post)=&gt; post.id === id);
  if (isPostExists === -1) {
    throw new Error('Post does not exist!');
  }

  // splice will return the index of the removed items from the array object
  const [post] = posts.splice(isPostExists, 1);
  pubsub.publish('post', {
    post:{
        mutation: 'DELETED',
        data: post
    }
  });

  return post;
},
</pre>
<h2 id="codingoursubscriptionobject">编码我们的<code>subscription</code>对象</h2>
<p>最后，我们将添加我们的<code>subscription</code>对象，该对象使用一个<code>pubsub.asyncIterator</code>函数来将来源流下的事件映射到一个返回的响应流。<code>asyncIterator</code>采用频道名称，通过该名称将绘制出整个应用程序中的事件:</p>
<pre>post:{
  subscribe(parent, args, {pubsub}){
    return pubsub.asyncIterator('post');
  }
}
</pre>
<p>现在，唯一剩下的文件就是<code>index.js</code>。向其中添加以下代码:</p>
<pre>const { GraphQLServer, PubSub } = require("graphql-yoga");
const typeDefs = require("./typeDefs");
const resolvers = require("./resolvers");
const pubsub = new PubSub();

const server = new GraphQLServer({
  typeDefs,
  resolvers,
  context: {
    pubsub,
  },
});

const options = {
  port: 3000,
};

server.start(options, ({ port }) =&gt; {
  console.log(
    `Graphql Server started, listening on port ${port} for incoming requests.`
  );
});
</pre>
<p>我们创建了一个GraphQL服务器，传递了我们所有的文件，然后启动了服务器。最后，我们将添加一个脚本来运行我们在<code>package.json</code>中的项目:</p>
<pre>"scripts": {
  "start": "node src/index.js"
},
</pre>
<p>打开终端，运行<code>npm start</code>。如果一切正常，您将看到以下消息:</p>
<pre>Graphql Server started, listening on port 3000 for incoming requests.
</pre>
<p>现在，在浏览器中输入<code><a href="http://localhost:3000" rel="nofollow">http://localhost:3000</a></code>，您将看到一个GraphQL Playground实例。为了确认一切正常，运行一个<code>getPosts</code>查询，如下所示:</p>
<pre>query {
  getPosts {
    id,
    body,
    downvotes,
    title,
    subtitle,
    upvotes
  }
}
</pre>
<figure id="attachment_80362" aria-describedby="caption-attachment-80362" class="wp-caption aligncenter"><img data-attachment-id="80362" data-permalink="https://blog.logrocket.com/graphql-subscriptions-nodejs-express/graphql-getposts-query/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/01/graphql-getposts-query.png" data-orig-size="730,427" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="graphql-getposts-query" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/01/graphql-getposts-query-300x175.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/01/graphql-getposts-query.png" decoding="async" class="wp-image-80362 size-full jetpack-lazy-image" src="../Images/6d2d9d7944d5b627790c84c66c97bae3.png" alt="GraphQL Getposts Query" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2020/01/graphql-getposts-query.png 730w, https://blog.logrocket.com/wp-content/uploads/2020/01/graphql-getposts-query-300x175.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2020/01/graphql-getposts-query.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/01/graphql-getposts-query.png"/><noscript><img data-lazy-fallback="1" data-attachment-id="80362" data-permalink="https://blog.logrocket.com/graphql-subscriptions-nodejs-express/graphql-getposts-query/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/01/graphql-getposts-query.png" data-orig-size="730,427" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="graphql-getposts-query" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/01/graphql-getposts-query-300x175.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/01/graphql-getposts-query.png" decoding="async" loading="lazy" class="wp-image-80362 size-full" src="../Images/6d2d9d7944d5b627790c84c66c97bae3.png" alt="GraphQL Getposts Query" srcset="https://blog.logrocket.com/wp-content/uploads/2020/01/graphql-getposts-query.png 730w, https://blog.logrocket.com/wp-content/uploads/2020/01/graphql-getposts-query-300x175.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/01/graphql-getposts-query.png"/></noscript><figcaption id="caption-attachment-80362" class="wp-caption-text">Running a getPosts query in GraphQL</figcaption></figure>
<p>要开始订阅帖子更改，我们将在GraphQL Playground中打开一个新选项卡，并运行以下代码:</p>
<pre>subscription{
  post{
    mutation
    data{
      id,
      title,
      subtitle,
      body,
      published
      author,
      upvotes,
      downvotes,
      commentCount,
    }
  }
}
</pre>
<p>上面的代码使我们能够向我们的频道帖子添加订阅，并开始收听频道中发布的任何事件:</p>
<figure id="attachment_80364" aria-describedby="caption-attachment-80364" class="wp-caption aligncenter"><img data-attachment-id="80364" data-permalink="https://blog.logrocket.com/graphql-subscriptions-nodejs-express/add-subscription-channel-post-event-listener/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/01/add-subscription-channel-post-event-listener.png" data-orig-size="730,428" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="add-subscription-channel-post-event-listener" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/01/add-subscription-channel-post-event-listener-300x176.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/01/add-subscription-channel-post-event-listener.png" decoding="async" class="wp-image-80364 size-full jetpack-lazy-image" src="../Images/7d1fbc8a5bf1eb7bcff5d986a316de6b.png" alt="Add Subscription Channel Post Event Listener" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2020/01/add-subscription-channel-post-event-listener.png 730w, https://blog.logrocket.com/wp-content/uploads/2020/01/add-subscription-channel-post-event-listener-300x176.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2020/01/add-subscription-channel-post-event-listener.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/01/add-subscription-channel-post-event-listener.png"/><noscript><img data-lazy-fallback="1" data-attachment-id="80364" data-permalink="https://blog.logrocket.com/graphql-subscriptions-nodejs-express/add-subscription-channel-post-event-listener/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/01/add-subscription-channel-post-event-listener.png" data-orig-size="730,428" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="add-subscription-channel-post-event-listener" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/01/add-subscription-channel-post-event-listener-300x176.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/01/add-subscription-channel-post-event-listener.png" decoding="async" loading="lazy" class="wp-image-80364 size-full" src="../Images/7d1fbc8a5bf1eb7bcff5d986a316de6b.png" alt="Add Subscription Channel Post Event Listener" srcset="https://blog.logrocket.com/wp-content/uploads/2020/01/add-subscription-channel-post-event-listener.png 730w, https://blog.logrocket.com/wp-content/uploads/2020/01/add-subscription-channel-post-event-listener-300x176.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/01/add-subscription-channel-post-event-listener.png"/></noscript><figcaption id="caption-attachment-80364" class="wp-caption-text">Add GraphQL subscriptions to channel post</figcaption></figure>
<p>要查看我们的GraphQL订阅的运行情况，只需在一个新的选项卡中执行任何变化。例如:</p>
<pre>mutation {
  updatePost(
    id: 8,
    downvotes:3,
    author: "deepak gupta",
    published: true,
    subtitle: "testinng subtitle",
    body: "testing body",
    commentCount: 12,
    upvotes: 4,
    title: "oh yeah :)"
  ) {
    id
  } 
}
</pre>
<p><img data-attachment-id="80366" data-permalink="https://blog.logrocket.com/graphql-subscriptions-nodejs-express/mutations-graphql-new-tab/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/01/mutations-graphql-new-tab.png" data-orig-size="730,428" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="mutations-graphql-new-tab" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/01/mutations-graphql-new-tab-300x176.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/01/mutations-graphql-new-tab.png" decoding="async" class="aligncenter wp-image-80366 size-full jetpack-lazy-image" src="../Images/e13e9dacf63c4077bcf1d0772c8ea8b4.png" alt="Mutations GraphQL New Tab" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2020/01/mutations-graphql-new-tab.png 730w, https://blog.logrocket.com/wp-content/uploads/2020/01/mutations-graphql-new-tab-300x176.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2020/01/mutations-graphql-new-tab.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/01/mutations-graphql-new-tab.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="80366" data-permalink="https://blog.logrocket.com/graphql-subscriptions-nodejs-express/mutations-graphql-new-tab/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/01/mutations-graphql-new-tab.png" data-orig-size="730,428" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="mutations-graphql-new-tab" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/01/mutations-graphql-new-tab-300x176.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/01/mutations-graphql-new-tab.png" decoding="async" loading="lazy" class="aligncenter wp-image-80366 size-full" src="../Images/e13e9dacf63c4077bcf1d0772c8ea8b4.png" alt="Mutations GraphQL New Tab" srcset="https://blog.logrocket.com/wp-content/uploads/2020/01/mutations-graphql-new-tab.png 730w, https://blog.logrocket.com/wp-content/uploads/2020/01/mutations-graphql-new-tab-300x176.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/01/mutations-graphql-new-tab.png"/></noscript>
<p>导航到运行订阅查询的选项卡。注意post响应流是如何为<code>update</code>事件返回数据的:</p>
<figure id="attachment_80368" aria-describedby="caption-attachment-80368" class="wp-caption aligncenter"><img data-attachment-id="80368" data-permalink="https://blog.logrocket.com/graphql-subscriptions-nodejs-express/raphql-subscription-post-response-stream/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/01/raphql-subscription-post-response-stream.png" data-orig-size="730,427" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="graphql-subscription-post-response-stream" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/01/raphql-subscription-post-response-stream-300x175.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/01/raphql-subscription-post-response-stream.png" decoding="async" class="wp-image-80368 size-full jetpack-lazy-image" src="../Images/d4e2027ed2ce19b6db7a39bcb95948fd.png" alt="Graphql Subscription Post Response Stream" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2020/01/raphql-subscription-post-response-stream.png 730w, https://blog.logrocket.com/wp-content/uploads/2020/01/raphql-subscription-post-response-stream-300x175.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2020/01/raphql-subscription-post-response-stream.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/01/raphql-subscription-post-response-stream.png"/><noscript><img data-lazy-fallback="1" data-attachment-id="80368" data-permalink="https://blog.logrocket.com/graphql-subscriptions-nodejs-express/raphql-subscription-post-response-stream/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/01/raphql-subscription-post-response-stream.png" data-orig-size="730,427" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="graphql-subscription-post-response-stream" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/01/raphql-subscription-post-response-stream-300x175.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/01/raphql-subscription-post-response-stream.png" decoding="async" loading="lazy" class="wp-image-80368 size-full" src="../Images/d4e2027ed2ce19b6db7a39bcb95948fd.png" alt="Graphql Subscription Post Response Stream" srcset="https://blog.logrocket.com/wp-content/uploads/2020/01/raphql-subscription-post-response-stream.png 730w, https://blog.logrocket.com/wp-content/uploads/2020/01/raphql-subscription-post-response-stream-300x175.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/01/raphql-subscription-post-response-stream.png"/></noscript><figcaption id="caption-attachment-80368" class="wp-caption-text">Response stream data in a GraphQL subscription</figcaption></figure>
<h2 id="recappingthegraphqlsubscriptionprocess">概述GraphQL订阅流程</h2>
<p>为了结束我们的教程，让我们快速回顾一下订购流程。订阅在<code>typeDefs.js</code>中定义如下:</p>
<pre>type Subscription {
  post: PostSubscriptionPayload!
}

type PostSubscriptionPayload {
  mutation: String!
  data: Post!
}
</pre>
<p>使用<code>graphql-yoga</code>提供的发布/订阅方法进行订阅和发布。发布/订阅方法也可以促进类似于<code>EventEmitter</code>的机制:</p>
<pre>const { GraphQLServer, PubSub } = require('graphql-yoga');
const typeDefs = require('./typeDefs');
const resolvers = require('./resolvers');
const pubsub = new PubSub();

const server = new GraphQLServer({
  typeDefs,
  resolvers,
  context: {
    pubsub,
  },
});
</pre>
<p>使用<code>pubsub.asyncIterator</code>实现订阅类型解析器来映射事件。一旦我们从GraphQL Playground请求订阅，<code>pubsub.asyncIterator</code>会将我们的套接字添加到它的监听套接字列表中，并在我们调用<code>pubsub.publish</code>时发回事件:</p>
<pre>Subscription: {
  post: {
    subscribe(parent, args, { pubsub }) {
      return pubsub.asyncIterator('post');
    },
  },
}
</pre>
<p>最后，从变异通道调用<code>pubsub.publish()</code>方法:</p>
<pre>pubsub.publish('post', {
  post: {
    mutation: 'UPDATED',
    data: updatedPost,
  },
});
</pre>
<h2 id="conclusion">结论</h2>
<p>现在，您已经创建了一个GraphQL订阅，这是一种同步客户机和服务器的实时方法。通过像我们在本教程中所做的那样实现GraphQL订阅，您可以在执行所选事件时实现实时通知。我希望你喜欢这个教程。</p><div class="code-block code-block-23">
<div class="blog-plug inline-plug node-plug"><h2>200年代只有<img src="../Images/61167b9d027ca73ed5aaf59a9ec31267.png" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2019/10/green-check.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" class=" jetpack-lazy-image" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/10/green-check.png"/> <noscript> <img data-lazy-fallback="1" src="../Images/61167b9d027ca73ed5aaf59a9ec31267.png" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/10/green-check.png"/> </noscript>监视器在生产中出现故障和网络请求变慢</h2><p>部署基于节点的web应用程序或网站是容易的部分。确保您的节点实例继续为您的应用程序提供资源是事情变得更加困难的地方。如果您对确保对后端或第三方服务的请求成功感兴趣，</p><a href="https://lp.logrocket.com/blg/node-signup" target="_blank">try LogRocket</a><p>. </p><a class="signup" href="https://lp.logrocket.com/blg/node-signup" target="_blank" rel="noopener noreferrer"><img src="../Images/cae72fd2a54c5f02a6398c4867894844.png" alt="LogRocket Network Request Monitoring" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2019/12/network-request-filter-2-1.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" class=" jetpack-lazy-image" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/12/network-request-filter-2-1.png"/><noscript><img data-lazy-fallback="1" src="../Images/cae72fd2a54c5f02a6398c4867894844.png" alt="LogRocket Network Request Monitoring" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/12/network-request-filter-2-1.png"/></noscript></a><a href="https://lp.logrocket.com/blg/node-signup" target="_blank" rel="noopener noreferrer">https://logrocket.com/signup/</a><p>LogRocket 就像是网络和移动应用程序的DVR，记录下用户与你的应用程序交互时发生的一切。您可以汇总并报告有问题的网络请求，以快速了解根本原因，而不是猜测问题发生的原因。</p><div class="code-block code-block-24">
<div class="blog-plug inline-plug graphql-plug"><h2>监控生产中失败和缓慢的GraphQL请求</h2><p>虽然GraphQL有一些调试请求和响应的特性，但确保GraphQL可靠地为您的生产应用程序提供资源是一件比较困难的事情。如果您对确保对后端或第三方服务的网络请求成功感兴趣，</p><a href="https://lp.logrocket.com/blg/graphql-signup" target="_blank">try LogRocket</a><p>.</p><a class="signup" href="https://lp.logrocket.com/blg/graphql-signup" target="_blank" rel="noopener noreferrer"><img src="../Images/432a3823c85b3fb72a206e6236a29f48.png" data-lazy-src="https://files.readme.io/69aa835-Image_2019-11-09_at_1.28.05_PM.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" class=" jetpack-lazy-image" data-original-src="https://files.readme.io/69aa835-Image_2019-11-09_at_1.28.05_PM.png"/><noscript><img data-lazy-fallback="1" src="../Images/432a3823c85b3fb72a206e6236a29f48.png" data-original-src="https://files.readme.io/69aa835-Image_2019-11-09_at_1.28.05_PM.png"/></noscript><img class="alignnone size-full wp-image-46 jetpack-lazy-image" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/><noscript><img data-lazy-fallback="1" class="alignnone size-full wp-image-46" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/></noscript></a><a href="https://lp.logrocket.com/blg/graphql-signup" target="_blank" rel="noopener noreferrer">https://logrocket.com/signup/</a><p>LogRocket 就像是网络和移动应用的DVR，记录下你网站上发生的每一件事。您可以汇总并报告有问题的GraphQL请求，以快速了解根本原因，而不是猜测问题发生的原因。此外，您可以跟踪Apollo客户机状态并检查GraphQL查询的键值对。</p><p>LogRocket检测您的应用程序以记录基线性能计时，如页面加载时间、到达第一个字节的时间、慢速网络请求，还记录Redux、NgRx和Vuex操作/状态。</p><a class="signup" href="https://lp.logrocket.com/blg/graphql-signup" target="_blank" rel="noopener noreferrer">Start monitoring for free</a><p>.</p></div>


</div><p>LogRocket检测您的应用程序以记录基线性能计时，如页面加载时间、到达第一个字节的时间、慢速网络请求，还记录Redux、NgRx和Vuex操作/状态。</p><a class="signup" href="https://lp.logrocket.com/blg/node-signup" target="_blank" rel="noopener noreferrer">Start monitoring for free</a><p>. </p></div>
</div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
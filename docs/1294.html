<html>
<head>
<title>Next.js vs. React: The developer experience - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>Next.js vs. React:开发者体验- LogRocket博客</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/next-js-vs-react-developer-experience/#0001-01-01">https://blog.logrocket.com/next-js-vs-react-developer-experience/#0001-01-01</a></blockquote><div><article class="article-post">
<p><em> <strong>编者按</strong>:本文于2022年2月3日更新，纳入了关于<a href="https://reactjs.org/blog/2021/06/08/the-plan-for-react-18.html" target="_blank" rel="noopener"> React 18 </a>中开发者体验的信息。</em></p>
<p>当选择任何软件库或框架时，人们通常会考虑开发人员的体验。当我在这里说“开发人员体验”时，我的意思是说开发人员实际完成任务是什么样的。开发人员通常喜欢有趣且易于使用的库或框架。这是我们今天拥有领先的库和框架的主要原因。</p>
<p>在React的世界里，Next.js已经成为“立即进入角色”的流行框架。作为React的粉丝，我在几个月前开始使用Next.js，并且非常喜欢在我的项目中使用它。我非常喜欢它，甚至用Next.js重写了我的个人博客(查看<a href="https://rhythmandbinary.com/post/2020-06-08-hello-rhythmandbinary-com" target="_blank" rel="noopener">我在上面的帖子</a>)。</p>
<p>Next.js构建在React之上，提供了简化的开发体验。Next.js有一个小的学习曲线，但是即使是不熟悉前端世界的开发人员也可以相对较快地上手并运行。话虽如此，但用Next.js与React构建项目时，体验肯定是不一样的。</p>
<p>这篇文章比较了Next.js和React的开发者体验。我将首先介绍一些背景知识，然后深入到更具体的内容，讨论最初启动一个项目、构建页面、检索数据、使用文档以及使用Next.js和React执行高级操作的情况。</p>
<p>我将提到一个示例项目，你可以在<a href="https://github.com/andrewevans0102/developer-experience-react-nextjs" target="_blank" rel="noopener">我的GitHub repo这里</a>找到。这个项目展示了一个关于热播剧《曼达洛人》的粉丝网站的两种不同实现。项目中的<code>react</code>文件夹当然是React版本，<code>next.js</code>文件夹包含Next.js版本。这两个项目的工作，应该只需要标准的<code>npm install</code>启动和运行。</p>
<p>您可以使用以下内容跳转到教程的相关部分:</p>

<h2 id="how-nextjs-different-react">Next.js和React有什么不同？</h2>
<p>在我们深入实际的开发人员体验之前，了解一些背景知识会有所帮助。</p>
<p><img data-attachment-id="91295" data-permalink="https://blog.logrocket.com/next-js-vs-react-developer-experience/react-banner-2/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/11/React-banner.png" data-orig-size="730,177" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="React-banner" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/11/React-banner-300x73.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/11/React-banner.png" decoding="async" class="size-full wp-image-91295 aligncenter jetpack-lazy-image" src="../Images/964a03bc735c62aa35665372024bc96f.png" alt="A react banner" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2020/11/React-banner.png 730w, https://blog.logrocket.com/wp-content/uploads/2020/11/React-banner-300x73.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2020/11/React-banner.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/11/React-banner.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="91295" data-permalink="https://blog.logrocket.com/next-js-vs-react-developer-experience/react-banner-2/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/11/React-banner.png" data-orig-size="730,177" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="React-banner" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/11/React-banner-300x73.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/11/React-banner.png" decoding="async" loading="lazy" class="size-full wp-image-91295 aligncenter" src="../Images/964a03bc735c62aa35665372024bc96f.png" alt="A react banner" srcset="https://blog.logrocket.com/wp-content/uploads/2020/11/React-banner.png 730w, https://blog.logrocket.com/wp-content/uploads/2020/11/React-banner-300x73.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/11/React-banner.png"/></noscript>
<p>最初由脸书创建，如今已经成为前端世界最受欢迎的图书馆之一。React很容易扩展，可以包含路由等特性以及带有Redux等库的状态管理模式。React占用的空间很小，但几乎可以针对任何项目进行定制。更多关于React的高级信息，请查看<a href="https://reactjs.org/" target="_blank" rel="noopener">官方React文档</a>。</p>
<p><img data-attachment-id="91297" data-permalink="https://blog.logrocket.com/next-js-vs-react-developer-experience/nextjs-logo/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/11/Nextjs-logo.png" data-orig-size="366,150" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Nextjs-logo" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/11/Nextjs-logo-300x123.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/11/Nextjs-logo.png" decoding="async" class="size-full wp-image-91297 aligncenter jetpack-lazy-image" src="../Images/587557e18ff4dc065c259917bcdb7d57.png" alt="Next.js logo" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2020/11/Nextjs-logo.png 366w, https://blog.logrocket.com/wp-content/uploads/2020/11/Nextjs-logo-300x123.png 300w" data-lazy-sizes="(max-width: 366px) 100vw, 366px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2020/11/Nextjs-logo.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/11/Nextjs-logo.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="91297" data-permalink="https://blog.logrocket.com/next-js-vs-react-developer-experience/nextjs-logo/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/11/Nextjs-logo.png" data-orig-size="366,150" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Nextjs-logo" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/11/Nextjs-logo-300x123.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/11/Nextjs-logo.png" decoding="async" loading="lazy" class="size-full wp-image-91297 aligncenter" src="../Images/587557e18ff4dc065c259917bcdb7d57.png" alt="Next.js logo" srcset="https://blog.logrocket.com/wp-content/uploads/2020/11/Nextjs-logo.png 366w, https://blog.logrocket.com/wp-content/uploads/2020/11/Nextjs-logo-300x123.png 300w" sizes="(max-width: 366px) 100vw, 366px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/11/Nextjs-logo.png"/></noscript>
<p>Next.js 创建于React之上，旨在构建一个易于使用的开发框架。它是由Vercel(以前的Zeit)开发的，利用了React的许多流行特性。开箱即用，Next.js提供了预渲染、路由、代码分割和webpack支持等功能。关于Next.js的更多信息，请查看<a href="https://nextjs.org/docs/getting-started" target="_blank" rel="noopener">官方Next.js文档</a>。</p>
<h2 id="what-react-vs-nextjs-projects-look-like">React vs. Next.js项目是什么样子的？</h2>
<p>使用React，您可以通过在机器上安装Node.js并运行<code>npx create-react-app my-app</code>来启动并运行。这将创建一个基本的项目结构，以<code>src/App.js</code>文件作为应用程序的入口点。</p>
<p>您还将有一个<code>public</code>文件夹，您可以在其中存储资产，最初的脚手架包括一个服务人员和一个方法来引入<a href="https://blog.logrocket.com/testing-apps-with-jest-and-react-testing-library/" target="_blank" rel="noopener"> Jest </a>进行测试。最初的脚手架看起来像这样:</p>
<pre class="language-nohighlight hljs">.
├── README.md
├── package.json
├── node_modules
├── public
│   ├── favicon.ico
│   ├── index.html
│   ├── logo192.png
│   ├── logo512.png
│   ├── manifest.json
│   └── robots.txt
├── src
│   ├── App.css
│   ├── App.js
│   ├── App.test.js
│   ├── index.css
│   ├── index.js
│   ├── logo.svg
│   ├── reportWebVitals.js
│   └── setupTests.js
└── yarn.lock (or package-lock.json)
</pre>
<p>有了Next.js，运行<code>npx create-next-app</code>就可以开始了。这将搭建出一个项目，该项目已经有一个用于页面或路径的<code>pages</code>文件夹和一个用于托管您的资产的<code>public</code>目录。最初的脚手架看起来像这样:</p>
<pre class="language-nohighlight hljs">.
├── README.md
├── package.json
├── node_modules
├── pages
│   ├── _app.js
│   ├── api
│   └── index.js
├── public
│   ├── favicon.ico
│   └── vercel.svg
├── styles
│   ├── Home.module.css
│   └── globals.css
└── yarn.lock (package-lock.json)
</pre>
<p><code>pages</code>目录中的文件与应用程序中的路线相关。<code>public</code>目录保存你想要提供的静态文件或图片，可以直接访问——不需要使用<code>require</code>或其他传统的React方法将图片导入组件。</p>
<p>在<code>pages</code>目录中，您会看到一个<code>index.js</code>文件，这是您的应用程序的入口点。如果你想导航到其他页面，你可以使用带有<code>Link</code>的路由器，如下所示:</p>
<pre class="language-javascript hljs">        &lt;div className="header__links"&gt;
            &lt;Link href="/"&gt;
                &lt;a className="header__anchor"&gt;Home&lt;/a&gt;
            &lt;/Link&gt;
            &lt;Link href="/about"&gt;
                &lt;a className="header__anchor"&gt;About&lt;/a&gt;
            &lt;/Link&gt;
        &lt;/div&gt;
</pre>
<p>关于开发人员的体验，对于Next.js和React来说，最初的搭建过程非常简单。然而，React确实需要您添加像<a href="https://blog.logrocket.com/migrating-react-router-v6-complete-guide/" target="_blank" rel="noopener"> React Router </a>这样的库来进行路由，而Next.js通过<code>Link</code>组件提供了开箱即用的功能。</p>
<p>此外，你的应用程序的整体结构已经由Next.js引导，用<code>pages</code>目录保存你的容器等。</p>
<h2 id="building-pages">构建页面</h2>
<p>现在我们可以开始讨论React与Next.js的真实例子，以及我在开始时提到的示例应用程序。同样，你可以在回购协议中找到它。</p>
<p>使用React构建页面需要您创建一个组件，然后引入React Router来编排站点中的转换。如果您查看示例应用程序中的<code>react</code>文件夹，您会看到传统React应用程序可能会出现的情况:</p>
<pre class="language-javascript hljs">export default function App() {
    return (
        &lt;Router&gt;
            &lt;section&gt;
                &lt;Header /&gt;
                &lt;Switch&gt;
                    &lt;Route path="/episodes"&gt;
                        &lt;EpisodesPage /&gt;
                    &lt;/Route&gt;
                    &lt;Route path="/season2"&gt;
                        &lt;Season2Page /&gt;
                    &lt;/Route&gt;
                    &lt;Route path="/quotes"&gt;
                        &lt;QuotesPage /&gt;
                    &lt;/Route&gt;
                    &lt;Route path="/"&gt;
                        &lt;HomePage /&gt;
                    &lt;/Route&gt;
                &lt;/Switch&gt;
            &lt;/section&gt;
        &lt;/Router&gt;
    );
}
</pre>
<p>这里的<code>Header</code>、<code>EpisodesPage</code>、<code>Season2Page2</code>、<code>QuotesPage</code>和<code>HomePage</code>都是React Router路由URL路径进行渲染的组件。</p>
<p>如果你查看这个项目的<code>Next.js</code>文件夹，你会注意到这个项目更加精简，因为所有的路线都内置在<code>pages</code>文件夹中。<code>Header</code>组件使用<code>Link</code>路由到不同的页面，如下所示:</p>
<pre class="language-javascript hljs">import Link from "next/link";
const Header = () =&gt; {
    return (
        &lt;nav className="header"&gt;
            &lt;span&gt;
                &lt;Link href="/"&gt;Home&lt;/Link&gt;
            &lt;/span&gt;
            &lt;span&gt;
                &lt;Link href="/episodes"&gt;Episodes&lt;/Link&gt;
            &lt;/span&gt;
            &lt;span&gt;
                &lt;Link href="/season2"&gt;Season 2&lt;/Link&gt;
            &lt;/span&gt;
            &lt;span&gt;
                &lt;Link href="/quotes"&gt;Quotes&lt;/Link&gt;
            &lt;/span&gt;
        &lt;/nav&gt;
    );
};
export default Header;
</pre>
<p>Next.js项目的高级视图也显示了它是多么容易理解:</p>
<pre class="language-nohighlight hljs">.
├── README.md
├── package-lock.json
├── package.json
├── pages
│   ├── _app.js
│   ├── _document.js
│   ├── components
│   │   └── Header.js
│   ├── episodes.js
│   ├── index.js
│   ├── quotes.js
│   ├── season2.js
│   └── styles
│       ├── _contact.scss
│       ├── _episodes.scss
│       ├── _header.scss
│       ├── _home.scss
│       ├── _quotes.scss
│       ├── _season2.scss
│       └── styles.scss
├── public
│   ├── HomePage.jpg
│   └── favicon.ico
└── yarn.lock
</pre>
<p>当您想要为React项目构建页面时，您必须构建组件，然后将其添加到路由器。当您想要为Next.js项目构建页面时，您只需将页面添加到<code>pages</code>文件夹，并将必要的<code>Link</code>添加到<code>Header</code>组件。这使您的生活变得更容易，因为您编写的代码更少，并且项目很容易跟进。</p>
<h2 id="pulling-in-data">拉入数据</h2>
<p>对于任何应用程序，您总是需要检索数据。无论是静态站点还是利用多个API的站点，数据都是重要的组成部分。</p>
<p>如果您查看我的<a href="https://github.com/andrewevans0102/developer-experience-react-nextjs" target="_blank" rel="noopener">示例项目</a>中的<code>react</code>文件夹，您会看到<code>EpisodesPage</code>组件使用一个Redux动作来检索<code>episodes</code>数据，如下所示:</p>
<pre class="language-javascript hljs">    const dispatch = useDispatch();
    // first read in the values from the store through a selector here
    const episodes = useSelector((state) =&gt; state.Episodes.episodes);
    useEffect(() =&gt; {
        // if the value is empty, send a dispatch action to the store to load the episodes correctly
        if (episodes.length === 0) {
            dispatch(EpisodesActions.retrieveEpisodes());
        }
    });
    return (
        &lt;section className="episodes"&gt;
            &lt;h1&gt;Episodes&lt;/h1&gt;
            {episodes !== null &amp;&amp;
                episodes.map((episodesItem) =&gt; (
                    &lt;article key={episodesItem.key}&gt;
                        &lt;h2&gt;
                            &lt;a href={episodesItem.link}&gt;{episodesItem.key}&lt;/a&gt;
                        &lt;/h2&gt;
                        &lt;p&gt;{episodesItem.value}&lt;/p&gt;
                    &lt;/article&gt;
                ))}
            &lt;div className="episodes__source"&gt;
                &lt;p&gt;
                    original content copied from
                    &lt;a href="https://www.vulture.com/tv/the-mandalorian/"&gt;
                        here
                    &lt;/a&gt;
                &lt;/p&gt;
            &lt;/div&gt;
        &lt;/section&gt;
    );
</pre>
<p>Redux操作从本地文件中检索值:</p>
<pre class="language-javascript hljs">import episodes from '../../config/episodes';

// here we introduce a side effect
// best practice is to have these alongside actions rather than an "effects" folder
export function retrieveEpisodes() {
    return function (dispatch) {
        // first call get about to clear values
        dispatch(getEpisodes());
        // return a dispatch of set while pulling in the about information (this is considered a "side effect")
        return dispatch(setEpisodes(episodes));
    };
}
</pre>
<p>使用Next.js，您可以利用其内置的<a href="https://nextjs.org/docs/basic-features/data-fetching" target="_blank" rel="noopener">数据获取API</a>来格式化您的数据并预先呈现您的站点。你也可以做所有你通常用React钩子和API调用做的事情。使用Next.js拉入数据的额外优势是，生成的包是预先呈现的，这使得网站的消费者更容易使用。</p>
<p>在我的示例项目中，如果你转到<code>nextjs</code>文件夹和<code>episodes.js</code>页面，你会看到关于<em>曼达洛人</em>剧集的信息实际上是通过调用<code>getStaticProps</code>构建的，所以实际的数据检索只发生在网站首次构建时:</p>
<pre class="language-javascript hljs">function EpisodesPage({ episodes }) {
    return (
        &lt;&gt;
            &lt;section className="episodes"&gt;
                &lt;h1&gt;Episodes&lt;/h1&gt;
                {episodes !== null &amp;&amp;
                    episodes.map((episodesItem) =&gt; (
                        &lt;article key={episodesItem.key}&gt;
                            &lt;h2&gt;
                                &lt;a href={episodesItem.link}&gt;{episodesItem.key}&lt;/a&gt;
                            &lt;/h2&gt;
                            &lt;p&gt;{episodesItem.value}&lt;/p&gt;
                        &lt;/article&gt;
                    ))}
                &lt;div className="episodes__source"&gt;
                    &lt;p&gt;
                        original content copied from
                        &lt;a href="https://www.vulture.com/tv/the-mandalorian/"&gt;here&lt;/a&gt;
                    &lt;/p&gt;
                &lt;/div&gt;
            &lt;/section&gt;
        &lt;/&gt;
    );
}
export default EpisodesPage;
export async function getStaticProps(context) {
    const episodes= [...];
    return {
        props: { episodes }, // will be passed to the page component as props
    };
}
</pre>
<h2 id="more-advanced-actions">更高级的操作</h2>
<p>除了我们在这里介绍的基本功能，您最终还需要做一些更复杂的事情。</p>
<p>在React应用程序中，最常见的模式之一是使用Redux。Redux很棒，因为它扩展了处理应用程序状态的常用方法。无论您的应用程序在做什么，创建动作、缩减器、选择器和副作用的过程都可以很好地伸缩。</p>
<p>使用React，这就是定义一个存储，然后在整个应用程序中构建流的问题。我做的第一件事就是看看我能否在我的项目中用Next.js做到这一点。经过一些谷歌搜索(和一些失败的尝试)，我发现由于Next.js预先和重新呈现每个页面的方式，使用商店非常困难。有几个人已经用Next.js实现了Redux，但这并不像你在普通React应用中看到的那样简单。</p>
<p>Next.js没有使用Redux，而是使用支持预渲染的数据获取API。这些都很棒，因为你的网站变成了一组静态的片段，可以很容易地被网络爬虫读取，从而提高你的网站的搜索引擎优化。</p>
<p>这是一个巨大的胜利，因为JS包通常很难被爬虫理解。此外，您可以更灵活地使用这些API和构建时生成的资产，如RSS提要。</p>
<p>我的个人博客网站是用Next.js编写的。实际上，我通过使用Next.js附带的<code>getStaticProps</code> API构建了自己的RSS提要:</p>
<pre class="language-javascript hljs">export async function getStaticProps() {
  const allPosts = getAllPosts(["title", "date", "slug", "content", "snippet"]);

  allPosts.forEach(async (post) =&gt; {
    unified()
      .use(markdown)
      .use(html)
      .process(post.content, function (err, file) {
        if (err) throw err;
        post.content = file;
      });
  });

  const XMLPosts = getRssXml(allPosts);
  saveRSSXMLPosts(XMLPosts);

  return {
    props: { XMLPosts },
  };
}
</pre>
<p><code>getAllPosts</code>和<code>getRssXml</code>功能将Markdown转换成RSS标准。然后可以将它部署到我的站点，启用RSS提要。</p>
<p>当涉及到Redux或预渲染等更高级的功能时，React和Next.js都有权衡。适用于React的模式不一定适用于Next.js，这并不是一件坏事，因为Next.js有自己的优势。</p>
<p>总的来说，在实现更高级的操作时，开发人员使用Next.js的体验有时会比您通常在React项目中看到的更具指导性。</p>
<h2 id="working-documentation">使用文档</h2>
<p>对于任何软件项目，好的文档确实可以帮助你容易地使用工具，理解使用什么库，等等。React和Next.js都有很棒的文档选项。</p>
<p>正如我在介绍中提到的，Next.js有一套“边做边学”<a href="https://nextjs.org/learn/basics/create-nextjs-app" target="_blank" rel="noopener">的文档</a>，指导你如何做诸如路由和构建组件之类的事情。React也有类似的设置，有多个教程<a href="https://reactjs.org/tutorial/tutorial.html" target="_blank" rel="noopener">解释基础</a>。</p>
<p>有了React，你还可以依靠一个伟大的开发者社区，他们已经在<a href="https://blog.logrocket.com/tag/react/">博客文章</a>、YouTube视频、Stack Overflow甚至React文档本身中创建了内容。随着图书馆的成熟，这是经过多年发展建立起来的。</p>
<p>有了Next.js，正式教程的方式少了，GitHub问题和对话的方式多了。当我建立我的个人博客网站时，有时我不得不做大量的谷歌搜索来解决Next.js的问题。然而，Next.js的团队成员本身在开源世界中非常容易接近。</p>
<p>当我今年夏天早些时候在Next.js上写了一篇帖子时，Next.js团队成员之一的Tim Neutkens 实际上直接在Twitter上回复了我。他帮我解决了一个问题，和他一起工作真的很棒。让社区成员变得平易近人是一种巨大的力量。</p>
<p>在React社区中，有许多关键成员也同样容易接近。在React和Next.js中，活跃的社区提供了非常积极的开发人员体验。</p>
<h2 id="developer-experience-react-18">React 18中的开发者体验</h2>
<p>目前，Next.js和Create React App都在使用React 17 . 0 . 2版本。但是很快，React 18将会发布，这将为React开发者体验带来一些变化。</p>
<p>最大的变化之一将是新的<a href="https://blog.logrocket.com/exploring-react-18-three-new-apis/" target="_blank" rel="noopener"> React root API </a>，它改变了应用组件呈现到DOM的方式。在React 17和之前的版本中，这是通过使用<code>ReactDOM.render</code>方法完成的，该方法将JSX渲染到DOM目标:</p>
<pre class="language-javascript hljs">import * as ReactDOM from 'react-dom';
import App from 'App';

const container = document.getElementById('app');

// Initial render.
ReactDOM.render(&lt;App tab="home" /&gt;, container);

// During an update, React would access
// the root of the DOM element.
ReactDOM.render(&lt;App tab="profile" /&gt;, container);
</pre>
<p>使用新的根API，您将首先将DOM容器标识为根，然后向它呈现JSX。<br/>这使得多次调用变得不那么重复，同时对水合作用进行了一些更改，以更好地促进现代用例，如部分水合作用:</p>
<pre class="language-javascript hljs">import * as ReactDOM from 'react-dom';
import App from 'App';

const container = document.getElementById('app');

// Create a root.
const root = ReactDOM.createRoot(container);

// Initial render: Render an element to the root.
root.render(&lt;App tab="home" /&gt;);

// During an update, there's no need to pass the container again.
root.render(&lt;App tab="profile" /&gt;);
</pre>
<p>React还将尝试批处理状态更改，这意味着它会将状态更改分组到一个更新中，以减少重复呈现。在React 18之前，批处理只为来自事件处理程序的状态更改保留，但其他情况(如异步状态更改)不进行批处理(这意味着它们会触发单独的呈现)。在React 18中，所有的状态更新都将被批处理。</p>
<p>React 18中的另一大新增功能是<code>startTransition</code> API。在React 18之前，所有的状态变化都被同等优先处理，所以较大的状态变化会导致UI挂起，这不是最好的用户体验。</p>
<p>使用React 18，您可以将较慢的状态更改包装在一个<code>startTransition</code>回调中，这将允许React确保在处理状态更改时UI不会挂起:</p>
<pre class="language-javascript hljs">import { startTransition } from 'react';


// Urgent: important state changes the UI must wait for work like normal
urgentState(input);

// Mark any state updates inside as transitions
startTransition(() =&gt; {
  // Transition: state changes that shouldn't hang the UI
  nonUrgentState(input);
}); 
</pre>
<p>因此，如果在输入表单时触发上述操作，第一个状态更改将总是在我继续输入之前完成，但是“转换”状态更改将在额外输入时取消，而不是挂起UI直到它完成。你可以在这里阅读<a href="https://github.com/reactwg/react-18/discussions/41" target="_blank" rel="noopener">更多关于过渡的内容。</a></p>
<p>最后，React 18对其处理应用程序服务器端渲染的方式进行了一些架构上的改变，这将为Next.js、<a href="https://blog.logrocket.com/remix-guide-newly-open-sourced-react-framework/" target="_blank" rel="noopener"> Remix </a>和Gatsby等metaframeworks带来速度上的提升。不是整个应用程序必须完成服务器端渲染才能在用户浏览器中合成，而是使用流HTML完成的部分可以部分合成，使用户感觉加载时间更快。你可以在这里阅读更多关于这些<a href="https://github.com/reactwg/react-18/discussions/37" target="_blank" rel="noopener">对SSR的更新。</a></p>
<p>底线是React 18将为React和Next.js的开发者体验带来许多改进。</p>
<h2 id="final-thoughts-nextjs-vs-react">关于Next.js与React的最终想法</h2>
<p>开发者体验让工程师热爱他们的工作。我是一名专业的工程师，但是专业的环境并不总是有助于最好的开发者体验。</p>
<p>在一个完美的世界中，你会发现自己在一个伟大的工程师团队中，拥有伟大的产品、强大的用户社区和强大的工具。在现实世界中，你会发现其中的一些，但通常缺少其中的一个(或多个)。</p>
<p>React和Next.js都以自己的方式提供了优秀的开发者体验。React让你以自己想要的方式构建东西，并得到一个强大社区的支持。Next.js通过一些现成的工具和约定让您的生活变得更加轻松，并且它还受到一个非常活跃的开源社区的支持。</p>
<p>说到工具本身，React和Next.js都很容易上手。超越简单的“hello world”项目，找到帮助是相当容易的，无论是在文档中还是在社区资源中。</p>
<p>React和Next.js都有自己擅长的具体事情。正如我提到的，我用Next.js重写了我的个人博客，因为我是一个粉丝。对于静态站点来说，这是一个很好的工具，可以很容易地与我设置的CI/CD管道连接。此外，当我想为不同的页面向我的站点添加组件时，它很容易导航。</p>
<p>React对任何项目都是一个很好的补充，如果有机会，它还可以扩展。React比Next.js更通用只是因为它是一个库；由工程师决定其实现。</p>
<p>最终，React和Next.js都提供了坚实的开发人员体验。我希望我在这里所做的比较和讨论能给你一些启示，让你知道如何在你的项目中使用它们。我鼓励你看看它们，也看看我的示例项目。</p>
<p>感谢您阅读我的帖子！在<a href="https://www.andrewevans.dev" target="_blank" rel="noopener"> andrewevans.dev </a>上关注我，在<a href="https://twitter.com/AndrewEvans0102" target="_blank" rel="noopener"> @AndrewEvans0102 </a>的Twitter上与我联系。</p><div class="code-block code-block-17">
<div class="blog-plug inline-plug react-plug" vwo-el-id="26283398190">
<h2 vwo-el-id="41600691720"><a href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener"> LogRocket </a>:全面了解您的生产React应用</h2><p>调试React应用程序可能很困难，尤其是当用户遇到难以重现的问题时。如果您对监视和跟踪Redux状态、自动显示JavaScript错误以及跟踪缓慢的网络请求和组件加载时间感兴趣，</p><a href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" vwo-el-id="19356441070">try LogRocket</a><p>. </p><a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="19356441380">
<img class="first-react-image alignnone size-full wp-image-46 jetpack-lazy-image jetpack-lazy-image--handled" src="../Images/f300c244a1a1cf916df8b4cb02bec6c6.png" vwo-el-id="18272717540" data-lazy-loaded="1" data-original-src="https://files.readme.io/27c94e7-Image_2017-06-05_at_9.46.04_PM.png"/>
</a>
<a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="19356441690">
<img class="second-react-image alignnone size-full wp-image-46 jetpack-lazy-image jetpack-lazy-image--handled" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" vwo-el-id="30720362350" data-lazy-loaded="1" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/>
</a>
<p vwo-el-id="28675660440" class="">LogRocket 结合了会话回放、产品分析和错误跟踪，使软件团队能够创建理想的web和移动产品体验。这对你来说意味着什么？</p>
<p>LogRocket不是猜测错误发生的原因，也不是要求用户提供截图和日志转储，而是让您回放问题，就像它们发生在您自己的浏览器中一样，以快速了解哪里出错了。</p>
<p>不再有嘈杂的警报。智能错误跟踪允许您对问题进行分类，然后从中学习。获得有影响的用户问题的通知，而不是误报。警报越少，有用的信号越多。</p>
<p vwo-el-id="28675660750">LogRocket Redux中间件包为您的用户会话增加了一层额外的可见性。LogRocket记录Redux存储中的所有操作和状态。</p>
<p vwo-el-id="28675661060">现代化您调试React应用的方式— <a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="40093418840">开始免费监控</a>。</p>
</div></div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
<html>
<head>
<title>Create your first game in WebAssembly - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>在WebAssembly - LogRocket博客中创建您的第一个游戏</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/first-game-in-webassembly/#0001-01-01">https://blog.logrocket.com/first-game-in-webassembly/#0001-01-01</a></blockquote><div><article class="article-post">
<p>你有没有经历过将C/C++中的遗留代码移植到JavaScript的痛苦？你是否曾经希望可以重用你的遗留应用程序，或者在你的web应用程序中拥有接近原生的性能？</p>
<p>如果你对以上任何一个问题的回答是肯定的，WebAssembly可以帮上忙！</p>
<h2>了解WebAssembly</h2>
<p>根据<a href="https://developer.mozilla.org/en-US/docs/WebAssembly/Concepts#:~:text=WebAssembly%20is%20a%20low%2Dlevel%20assembly%2Dlike%20language%20with%20a,can%20run%20on%20the%20web." target="_blank" rel="noopener noreferrer">文档</a>:</p>
<blockquote><p>它是一种低级的类似汇编的语言，具有紧凑的二进制格式，以接近本机的性能运行，并为C/C++和Rust等语言提供编译目标，以便它们可以在web上运行。</p></blockquote>
<p>这基本上意味着，WebAssembly提供了一种将我们的C/C++代码转换成特定格式的方法，这种格式可以很容易地被使用。</p>
<h2>但是WebAssembly是怎么做到的呢？</h2>
<p>WebAssembly就像一种新的语言，但作为开发人员，您不必编写它，因为它充当了C/C++或Rust等低级语言的编译目标。</p>
<p>所以，当你有了你的C或C++应用程序，你可以把它编译成一个. wasm文件，然后可以把它导入到你的web应用程序中。</p>
<p>WebAssembly甚至允许您在JS应用程序之间传递和访问数据/变量。</p>
<p>本文在这里详细解释了【WebAssembly如何工作。</p>
<h2>使用WebAssembly的优势</h2>
<ul>
<li>你最终可以将性能密集型任务外包给C/C++或类似Rust的性能语言，如3D游戏、虚拟、增强现实或计算机视觉的计算</li>
<li>有大量用C/C++编写的惊人的遗留库，现在可以无缝集成到您的web应用程序中。你可以在这里找到其中的一些<a href="https://github.com/emscripten-core/emscripten/wiki/Porting-Examples-and-Demos#games-and-game-engines" target="_blank" rel="noopener noreferrer"/></li>
<li>你可以编写超级快速和漂亮的应用程序(例如，<a href="https://earth.google.com/web/@0,0,0a,22251752.77375655d,35y,0h,0t,0r" target="_blank" rel="noopener noreferrer">谷歌地球</a>)</li>
</ul>
<h2>WebAssembly为web提供了扩展功能</h2>
<p>现在我们已经看到了WebAssembly可以做什么，让我们创建我们的第一个游戏来看看它是如何工作的。</p>
<h2>在WASM创造你的第一个井字游戏</h2>
<p><img data-attachment-id="21417" data-permalink="https://blog.logrocket.com/first-game-in-webassembly/tictactoewasm/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/07/tictactoewasm.png" data-orig-size="1600,1136" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="tictactoewasm" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/07/tictactoewasm-300x213.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/07/tictactoewasm-1024x727.png" decoding="async" class="aligncenter size-full wp-image-21417 jetpack-lazy-image" src="../Images/d247ec40eaddee5e4319b7f2bb44389b.png" alt="tic tac toe WebAssembly" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2020/07/tictactoewasm.png 1600w, https://blog.logrocket.com/wp-content/uploads/2020/07/tictactoewasm-300x213.png 300w, https://blog.logrocket.com/wp-content/uploads/2020/07/tictactoewasm-1024x727.png 1024w, https://blog.logrocket.com/wp-content/uploads/2020/07/tictactoewasm-768x545.png 768w, https://blog.logrocket.com/wp-content/uploads/2020/07/tictactoewasm-1536x1091.png 1536w" data-lazy-sizes="(max-width: 1600px) 100vw, 1600px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2020/07/tictactoewasm.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/07/tictactoewasm.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="21417" data-permalink="https://blog.logrocket.com/first-game-in-webassembly/tictactoewasm/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/07/tictactoewasm.png" data-orig-size="1600,1136" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="tictactoewasm" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/07/tictactoewasm-300x213.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/07/tictactoewasm-1024x727.png" decoding="async" loading="lazy" class="aligncenter size-full wp-image-21417" src="../Images/d247ec40eaddee5e4319b7f2bb44389b.png" alt="tic tac toe WebAssembly" srcset="https://blog.logrocket.com/wp-content/uploads/2020/07/tictactoewasm.png 1600w, https://blog.logrocket.com/wp-content/uploads/2020/07/tictactoewasm-300x213.png 300w, https://blog.logrocket.com/wp-content/uploads/2020/07/tictactoewasm-1024x727.png 1024w, https://blog.logrocket.com/wp-content/uploads/2020/07/tictactoewasm-768x545.png 768w, https://blog.logrocket.com/wp-content/uploads/2020/07/tictactoewasm-1536x1091.png 1536w" sizes="(max-width: 1600px) 100vw, 1600px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/07/tictactoewasm.png"/></noscript><br/>
We will be building a 3×3 tic-tac-toe game. Our game logic includes:
<ul>
<li>计算哪个玩家赢了</li>
<li>计算是否没有赢家</li>
<li>指示待定移动</li>
</ul>
<p>整个游戏逻辑都是用C++写的。</p>
<h2>了解Emscripten</h2>
<p>正如我之前提到的，我们需要将C++应用程序转换为中间格式，即. wasm。为此，我们需要一个工具来将C++文件编译为这种格式。</p>
<p>有很多方法可以做到这一点，但是在这篇文章中，我将使用Emscripten。其原因是因为:</p>
<ol>
<li>它直接将你的C/C++代码转换成JavaScript，这意味着你甚至不需要写任何粘合代码来读取你的。wasm文件。这为您提供了足够的灵活性，使您可以只关注逻辑而不是实现</li>
<li>其次，从调用你的C++文件中编写的函数到你的JS文件来说，这是非常直观的。一旦我们深入研究代码，您就会看到这一点</li>
</ol>
<p>在你开始编码之前，确保你已经安装了Emscripten。你可以在这里了解更多关于T2的信息。</p>
<p>在我们开始之前，让我们先把我们的游戏分成几个易于管理的部分:</p>
<ol>
<li>我们必须用C++编写我们的游戏逻辑</li>
<li>使用Emscripten传输文件</li>
<li>在我们的游戏中调用C++函数</li>
</ol>
<p>最终的游戏代码可以在这里找到<a href="https://github.com/arwalokhandwala/tictactoe-game-wasm" target="_blank" rel="noopener noreferrer">。</a></p>
<h2>用C++编写我们的游戏逻辑</h2>
<p>游戏的逻辑写在<a href="https://github.com/arwalokhandwala/tictactoe-game-wasm/blob/master/tic_tac_toe.cpp" target="_blank" rel="noopener noreferrer"> tic_tac_toe.cpp文件</a>中。</p>
<p>首先，我们首先导入所有必需的脚本库:</p>
<pre>#include &lt;emscripten/bind.h&gt;
#include &lt;emscripten/val.h&gt;</pre>
<p>上面显示的代码导入了<a href="https://emscripten.org/docs/porting/connecting_cpp_and_javascript/embind" target="_blank" rel="noopener noreferrer"> Embind </a>，它用于将C++代码与JavaScript绑定在一起(也就是说，我们现在可以在C++代码中调用和操作JavaScript变量)。</p>
<p>接下来，我们继续讨论tic_tac_toe()，它包含了游戏的主要逻辑:</p>
<pre>val tic_tac_toe() {
    val board_values = val::global("BoardValues");
    val moves_pending_label = val::global("movesPendingLabel");
    val no_winner_label = val::global("noWinnerLabel");
    val empty_block = val::global("emptyBlock");
    bool moves_pending = false;

    val solutions[8][3]= {
        { board_values[0][0], board_values[0][1], board_values[0][2]},
        { board_values[1][0], board_values[1][1], board_values[1][2]},
        { board_values[2][0], board_values[2][1], board_values[2][2]},
        { board_values[0][0], board_values[1][0], board_values[2][0]},
        { board_values[0][1], board_values[1][1], board_values[2][1]},
        { board_values[0][2], board_values[1][2], board_values[2][2]},
        { board_values[0][0], board_values[1][1], board_values[2][2]},
        { board_values[0][2], board_values[1][1], board_values[2][0]},
    };

    for ( int i = 0; i &lt; 8; i++ ){
        if((solutions[i][0] != empty_block) &amp;&amp; (solutions[i][1] != empty_block) &amp;&amp; (solutions[i][2] != empty_block)&amp;&amp; (solutions[i][0] == solutions[i][1]) &amp;&amp; ( solutions[i][1] == solutions[i][2] )) {
            return solutions[i][1];
        } else if((solutions[i][0] == empty_block) || (solutions[i][1] == empty_block) || (solutions[i][2] == empty_block)){
            moves_pending = true;
        }
   }

   if (moves_pending) {
       return moves_pending_label;
   }
    
    return no_winner_label;
}
</pre>
<p>我们的函数签名<code>val tic_tac_toe()</code>声明函数返回的值是一个JavaScript变量。</p>
<p>所有的初始值都在我们的JavaScript中声明，现在我们需要一种方法来访问和操作这些初始值。</p>
<p>幸运的是，Embind提供了一种方法来实现这一点，它使用:</p>
<pre>val cpp_var_name = val::global("js_var_name");</pre>
<p>使用它，我们将导入所有必要的标签、游戏板值和游戏状态变量:</p>
<pre>val board_values = val::global("BoardValues");  // Object representing our 3*3 board
val moves_pending_label = val::global("movesPendingLabel"); // Label returned if there are any pending moves/blocks remaining
val no_winner_label = val::global("noWinnerLabel"); // Label indicating who won
val empty_block = val::global("emptyBlock"); //  Indicator for an empty cell on board
bool moves_pending = false;  // State variable indicating if any blocks are pending
</pre>
<p>现在，我们的下一步是创建一个解决方案矩阵，显示所有可能的解决方案。<code>val solutions[8][3]</code>，是一个8*3的数组，代表我们所有可能的解决方案组合。</p>
<blockquote><p>注意:可能有其他方法来实现井字游戏的解决方案，但是，为了简单起见，我们将列出所有可能的解决方案，并使用我们当前的棋盘值进行交叉验证，以检查是否有任何玩家获胜。</p></blockquote>
<p>现在，一旦我们有了所有可能的解决方案，我们将比较我们当前的棋盘值与这些解决方案，看看是否有任何一个玩家赢了。</p>
<p>如果我们当前的棋盘值与我们的任何解决方案相匹配，那么我们返回代表其中一个玩家的单元格值。然而，如果没有找到匹配，并且棋盘上有任何空单元格，则返回<code>moves_pending_label</code>，否则返回<code>no_winner_label</code>。</p>
<p>现在，让我们导出这个函数，以便在我们的web应用程序中调用它:</p>
<pre> EMSCRIPTEN_BINDINGS(my_module) {
    function("tic_tac_toe", &amp;tic_tac_toe);
}</pre>
<p>上面的代码允许我们现在使用<code>tic_tac_toe()</code>调用函数。当我们的粘合代码。js文件最初被加载。</p>
<h2>运输。cpp文件到。wasm和。js(粘合代码)</h2>
<p>曾经我们的。cpp文件准备好了，下一步是将文件传输到。wasm文件和。可以在我们的web应用程序中使用的js文件:</p>
<pre>emcc --bind -o tic_tac_toe.js tic_tac_toe.cpp</pre>
<p>上面的命令将我们的tic_tac_toe.cpp文件传输到两个新文件，即<a href="https://github.com/arwalokhandwala/tictactoe-game-wasm/blob/master/tic_tac_toe.wasm" target="_blank" rel="noopener noreferrer"> tic_tac_toe.wasm </a>和<a href="https://github.com/arwalokhandwala/tictactoe-game-wasm/blob/master/tic_tac_toe.js" target="_blank" rel="noopener noreferrer"> tic_tac_toe.js </a>。tic_tac_toe.js文件包含了加载我们的C++函数并将其公开为可以导入的模块所需的所有粘合代码。</p>
<h2>在我们的web应用程序中调用C++函数</h2>
<p>下面讨论的所有代码都可以在<a href="https://github.com/arwalokhandwala/tictactoe-game-wasm/blob/master/index.html" target="_blank" rel="noopener noreferrer">这里</a>找到。现在我们已经完全透明了。cpp文件，现在是我们准备调用tic_tac_toe()的JavaScript代码的时候了。</p>
<p>第一步是声明保存纸板初始值的变量，如前所述:</p>
<pre> var currentBoardValues = []
 var BoardValues = {0:[],1:[],2:[]}
 var movesPendingLabel = 'Moves still pending!';
 var emptyBlock = '';
 var noWinnerLabel = 'Oops! Looks like no one won :('
</pre>
<p>接下来，</p>
<pre>var Module = {
    onRuntimeInitialized: function() {
            Module.tic_tac_toe()
         }
 };</pre>
<p>你还记得我们的tic_tac_toe() C++函数，它是由Embind公开的，现在可以在Emscripten <a href="https://emscripten.org/docs/api_reference/module.html" target="_blank" rel="noopener noreferrer"> module </a>对象上使用。</p>
<p>然而，我们只能在tic_tac_toe()完全加载后调用它，也就是说，在运行时调用它。js胶水代码和。wasm文件)已初始化。为此，我们使用了<code>onRuntimeInitialized</code>回调，它将在运行时准备就绪时运行。</p>
<p>现在，每当任何玩家点击任何单元格，我们调用我们的C++函数作为<code>Module.tic_tac_toe()</code>，它将返回适当的结果。</p>
<p>瞧，我们在WebAssembly的第一个游戏已经准备好了！你可以点击查看最终游戏代码<a href="https://github.com/arwalokhandwala/tictactoe-game-wasm" target="_blank" rel="noopener noreferrer">。</a></p>
<h2>结论</h2>
<p>WebAssembly真的很了不起，它确实让我们做了以前不可能的事情。我希望这篇文章能帮助你迈出web组装之旅的第一步。</p><div class="code-block code-block-2">
<div class="blog-plug base-cta"><h2>使用<a class="signup" href="https://lp.logrocket.com/blg/signup" target="_blank" rel="noopener noreferrer"> LogRocket </a>消除传统错误报告的干扰</h2>
<a href="https://lp.logrocket.com/blg/signup" class="signup" target="_blank" rel="noopener noreferrer"><img class="alignnone size-full wp-image-46 jetpack-lazy-image" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/><noscript><img data-lazy-fallback="1" class="alignnone size-full wp-image-46" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/></noscript></a>
<p><a href="https://lp.logrocket.com/blg/signup" target="_blank" rel="noopener noreferrer"> LogRocket </a>是一个数字体验分析解决方案，它可以保护您免受数百个假阳性错误警报的影响，只针对几个真正重要的项目。LogRocket会告诉您应用程序中实际影响用户的最具影响力的bug和UX问题。</p>
<p>然后，使用具有深层技术遥测的会话重放来确切地查看用户看到了什么以及是什么导致了问题，就像你在他们身后看一样。</p>
<p>LogRocket自动聚合客户端错误、JS异常、前端性能指标和用户交互。然后LogRocket使用机器学习来告诉你哪些问题正在影响大多数用户，并提供你需要修复它的上下文。</p>
<p>关注重要的bug—<a class="signup" href="https://lp.logrocket.com/blg/signup-issue-free" target="_blank" rel="noopener noreferrer">今天就试试LogRocket】。</a></p></div></div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
<html>
<head>
<title>Comparing schema validation libraries: Zod vs. Yup - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>比较模式验证库:Zod与Yup - LogRocket博客</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/comparing-schema-validation-libraries-zod-vs-yup/#0001-01-01">https://blog.logrocket.com/comparing-schema-validation-libraries-zod-vs-yup/#0001-01-01</a></blockquote><div><article class="article-post">
<p>Web开发人员必须在他们的应用程序中处理大量复杂的数据交换。应用程序验证它们发送或接收的任何数据是很重要的，因为任何错误的数据类型都可能导致错误。意外的数据类型或值也可能会使处理它的应用程序崩溃，并导致其他不良后果，这是您希望不惜一切代价避免的。</p>
<p>模式验证是通过创建模式来验证数据的过程。模式的定义可以根据实现的不同而不同，但是在JavaScript中，模式通常是一种对象数据类型，用于验证所讨论的数据。</p>
<p>下面是一个简单的例子。</p>
<pre>var userDataSchema = {
  name: "string",
  age: "number"
}

var userData = {
  name: "Peter",
  age: "15"
}

function validateSchema(schema, data){
  for (var property in schema) {
    if(data[property] === undefined){
      console.error(property + " is required.")
    } else if ( typeof data[property] !== schema[property] ){
      console.error(property+ " must be of type "+ schema[property] + ", " +typeof data[property]+ " found.")
    } else {
      console.log(property + " is validated!")
    }
  }
}

validateSchema(userDataSchema, userData)
</pre>
<p>在上面的代码中，<code>userDataSchema</code>对象充当模式，验证<code>userData</code>对象具有<code>name</code>和<code>age</code>的属性。它还验证这些值的类型:<code>name</code>必须是一个<code>string</code>，而<code>age</code>必须是一个<code>number</code>。</p>
<p>当然，<code>validateSchema</code>函数对于任何严肃的应用来说都是不够的。要验证一个复杂的数据结构并确保它不会导致不必要的行为，您需要更强大的工具。这就是模式验证库的用武之地。</p>
<p>幸运的是，世界各地慷慨的JavaScript开发人员已经在npm上共享了无数开源模式验证库。到目前为止，<a href="https://github.com/jquense/yup" target="_blank" rel="noopener noreferrer">是的</a>是最流行的JavaScript模式验证库之一。但是最近出现了一个新的验证库，自从它在三月份发布以来，已经抢了一些Yup的风头。</p>
<p>Zod是一个模式验证库，旨在增强开发人员在处理模式验证时的体验。在本指南中，我将比较这些库，看看它们在验证常见数据模式(如原语、对象和数组)方面的表现如何。</p>
<h2 id="npmtrends">npm趋势</h2>
<p>首先，让我们回顾一下我在2020年4月19日从npm trends获得的一些一般图书馆统计数据。</p>
<p><img data-attachment-id="19697" data-permalink="https://blog.logrocket.com/comparing-schema-validation-libraries-zod-vs-yup/zod-yup-npm-trends-2/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/06/zod-yup-npm-trends-1.png" data-orig-size="720,427" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Zod versus Yup — npm trends" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/06/zod-yup-npm-trends-1-300x178.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/06/zod-yup-npm-trends-1.png" decoding="async" class="aligncenter size-full wp-image-19697 jetpack-lazy-image" src="../Images/67f9b09e3287ba921dbf9e6a592a75fe.png" alt="Zod Versus Yup — npm Trends" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2020/06/zod-yup-npm-trends-1.png 720w, https://blog.logrocket.com/wp-content/uploads/2020/06/zod-yup-npm-trends-1-300x178.png 300w" data-lazy-sizes="(max-width: 720px) 100vw, 720px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2020/06/zod-yup-npm-trends-1.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/06/zod-yup-npm-trends-1.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="19697" data-permalink="https://blog.logrocket.com/comparing-schema-validation-libraries-zod-vs-yup/zod-yup-npm-trends-2/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/06/zod-yup-npm-trends-1.png" data-orig-size="720,427" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Zod versus Yup — npm trends" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/06/zod-yup-npm-trends-1-300x178.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/06/zod-yup-npm-trends-1.png" decoding="async" loading="lazy" class="aligncenter size-full wp-image-19697" src="../Images/67f9b09e3287ba921dbf9e6a592a75fe.png" alt="Zod Versus Yup — npm Trends" srcset="https://blog.logrocket.com/wp-content/uploads/2020/06/zod-yup-npm-trends-1.png 720w, https://blog.logrocket.com/wp-content/uploads/2020/06/zod-yup-npm-trends-1-300x178.png 300w" sizes="(max-width: 720px) 100vw, 720px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/06/zod-yup-npm-trends-1.png"/></noscript>
<p>六年前发布的Yep显然是此时更受欢迎的选择。Zod的尺寸更小，可能是因为它没有Yup那么多API，但随着更多功能的开发，它肯定会增长。</p>
<h2 id="basicobjectvalidations">基本对象验证</h2>
<p>让我们从比较如何用每个服务验证一个简单对象及其属性开始。</p>
<p>下面是如何开始使用Yup进行验证。</p>
<pre>let yup = require('yup')

let schema = yup.object({
  name: yup.string().required(),
  age: yup.number()
})

schema
.isValid({
  name: 'John',
  age: true // wrong value
})
.then(function(valid) {
  console.log(valid)
})
</pre>
<p>我们用Yup的<code>.object</code>函数创建了一个对象模式。该模式有两个属性:</p>
<ol>
<li>一个<code>name</code>属性，它是一个字符串类型并且是必需的</li>
<li>一个数字类型的<code>age</code>属性，但不是必需的</li>
</ol>
<p>模式准备好之后，我们通过调用<code>.isValid</code>函数来验证数据。我们将具有<code>age</code>属性的对象作为布尔类型而不是数字，这导致函数返回<code>false</code>。</p>
<p>下面是如何用Zod进行验证。</p>
<pre>const userSchema = zod.object({
  name: zod.string(),
  age: zod.number().optional(),
})

userSchema.parse({
  name: "Jane",
  age: true // wrong value
})
</pre>
<p>与Yup不同，Zod假定所有的验证都是默认需要的。如果你想让它可选，用<code>.optional()</code>函数链接你的验证。</p>
<p>这两种验证一开始看起来是一样的，但是Zod实际上是在解析对象，而不是验证它。这意味着Zod获取给定的数据并试图将其返回。如果解析器遇到错误，它将终止运行时并抛出一个错误。</p>
<p>尽管Yup只验证数据并将错误处理留给您，但是Zod通过抛出错误将验证向前推进了一步。确保你写的程序不能继续运行。<br/>如果你想捕捉错误，将解析函数放在<code>try-catch</code>块中。</p>
<pre>try {
  userSchema.parse({
    name: "Jane",
    age: true // wrong value
  })
} catch (err) {
  console.log(err.message)
}
</pre>
<p>现在，您可以将错误优雅地记录到控制台中。</p>
<h2 id="primitivedatatypes">原始数据类型</h2>
<p>现在让我们比较一下库如何验证原始数据类型。下面是如何用Yup验证一个字符串:</p>
<pre>let schema = yup.string()

schema.isValid('hello')
.then(function(valid) {
  console.log(valid)
})
</pre>
<p>让我们对佐德做同样的事。</p>
<pre>let schema = zod.string()

try {
  schema.parse('hello')
} catch (err) {
  console.log(err.message)
}
</pre>
<p>如果解析没有通过，就会记录一个错误。到目前为止，Zod和Yup似乎都能够验证原始数据类型。此外，两者还可以检查您的字符串是否是有效的电子邮件地址:</p>
<pre>let yup = require('yup')

let schema = yup.string().email() // validate if the string is also a valid email address format

schema.isValid('<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="d5bdb0b9b9ba95b8b4bcb9fbb6bab8">[email protected]</a>')
.then(function(valid) {
  console.log(valid)
})
</pre>
<p>你需要用Zod手动验证电子邮件地址。可以使用regex，如下所示。</p>
<pre>let zod= require('zod')

let schema = zod.string().email()

try {
  schema.parse('hellomail.com')
} catch (err) {
  console.log(err.message)
}
</pre>
<p>Zod为验证数据类型实现了广泛的扩展。在下面的例子中，它验证数据是数字类型并且有一个正值——一个整数而不是一个浮点数。</p>
<pre>let schema = zod.object({
  age: zod
    .number()
    .positive()
    .int()
})
</pre>
<p>Yup也有自己的<a href="https://github.com/vriad/zod#numbers" target="_blank" rel="noopener noreferrer">数字模式</a>,有更多的验证，比如truncate和round，但是由于Zod正在积极开发中，它可能很快就会赶上来。</p>
<h2 id="literalvalidation">文字验证</h2>
<p>下面是如何用Yup执行文字验证。</p><div class="code-block code-block-54">
<hr/>
<h3>更多来自LogRocket的精彩文章:</h3>

<hr/></div>
<pre>let schema = yup.mixed().oneOf(['Tomato'])

schema.isValid('Tomato')
.then(function(valid){
  console.log(valid)
})
</pre>
<p>Yup的<code>mixed</code>函数可以匹配所有类型，通过使用<code>oneOf</code>函数，可以输入一个按字面意思取的值。</p>
<p>下面是Zod的文字验证:</p>
<pre>let schema = zod.literal('Tomato')

try {
  schema.parse('Tomato')
} catch (err) {
  console.log(err.message)
}
</pre>
<p>Zod中的文字验证更简单，因为它有一个<code>literal</code>函数可以用来做这件事。</p>
<h2 id="arrayvalidation">数组验证</h2>
<p>对于数组类型，Yup有几个有用的扩展来验证它的值。例如，您可以用<code>.min</code>和<code>.max</code>函数验证数组的最小或最大长度。您也可以使用<code>.of</code>功能检查其值的类型。</p>
<pre>// validate that the data is an array with number as its value. 
// The minimum value of the array is two
// The minimum length of the array is four
let schema = yup.array().of(yup.number().min(2)).min(4);

schema.isValid([2])
.then(function(valid) {
  console.log(valid) // false
})
</pre>
<p>Zod也可以像Yup一样验证数组，但是语法上有一点不同:</p>
<pre>let schema = zod.array(zod.string()).min(2).max(5)

try {
  schema.parse(['fish', 'meat', 'banana'])
} catch (err) {
  console.log(err.message) // Error non-number type
}
</pre>
<h2 id="functionvalidation">功能验证</h2>
<p>Zod可以验证一个函数并确保它的输入和输出类型是正确的。函数模式接受两个参数:形式为<code>tuple</code>的参数(<code>args</code>)和函数的返回类型。</p>
<p><code>tuple</code>是另一个特殊的Zod API，它创建一个具有固定数量的元素和各种数据类型的数组。</p>
<pre>const athleteSchema = zod.tuple([
  // takes an array of schemas
  zod.string(), // a string for name
  zod.number(), // a number for jersey
  zod.object({
    pointsScored: zod.number(),
  }), // an object with property pointsScored that has number value
]);
try {
  athleteSchema.parse(["James", 23, { pointsScored: 7 }])
} catch (err) {
  console.log(err.message)
}
</pre>
<p>解析到元组中的数据必须是与模式结构完全匹配的数组。通过使用元组，您可以根据需要向函数传递任意多的参数。</p>
<p>下面是函数模式的代码示例。它采用两个数字作为参数，并返回一个字符串。</p>
<pre>const args = zod.tuple([
  zod.number(), // arg1
  zod.number() // arg2
])
const returnType = zod.string()
const fnSumSchema = zod.function(args, returnType)

const mySum = fnSumSchema.validate((arg1, arg2) =&gt; {
  return arg1 + arg2 // TypeError. Should be string
})
const sumAsString = mySum(3, 4)
</pre>
<p>与我们目前看到的其他验证不同，Zod中的函数验证不使用相同的<code>.parse</code>来验证函数。</p>
<p>函数验证是Zod特有的；Yup没有等效的API来执行这项任务。</p>
<h2 id="typescriptsupport">类型脚本支持</h2>
<p>两个库都支持TypeScript。Zod提供了一流的TypeScript支持。这些库使您能够推断可用于验证数据的TypeScript类型别名。</p>
<p>简单地说，您可以通过从Yup或Zod的模式中创建一个<a href="https://www.typescriptlang.org/docs/handbook/advanced-types.html#type-aliases" target="_blank" rel="noopener noreferrer"> <code>type</code>别名</a>来验证一个变量是否是正确的数据类型。</p>
<pre>import * as yup from "yup";
import * as zod from "zod";

const yupSchema = yup.string()
type A = yup.InferType&lt;typeof yupSchema&gt;
const x: A = 12 // wrong, but nothing happens

const zodSchema = zod.string();
type B = zod.infer&lt;typeof zodSchema&gt;; // string
const y: B = 12; // TypeError
</pre>
<p>您可以使用TypeScript运行上面的脚本。注意，Zod实际上会抛出一个错误，而Yup什么也不做，尽管<code>x</code>的值应该是一个字符串而不是一个数字。</p>
<h2 id="zodsunionfunction">佐德联合函数</h2>
<p>Zod还有一些独特的API来定义可选的模式。例如，<a href="https://github.com/vriad/zod#unions" target="_blank" rel="noopener noreferrer">联合方法</a>可以用来组合“或”类型。例如，要创建数据为字符串或数字的模式:</p>
<pre>let zod= require('zod')

const stringOrNumber = zod.union([zod.string(), zod.number()]);

try {
  stringOrNumber.parse({});
} catch (err) {
  console.log(err.message) // Error non-string, non-number type
}
</pre>
<h2 id="zodsintersectionfunction">佐德相交函数</h2>
<p>Zod的另一个独特API是<a href="https://github.com/vriad/zod#unions" target="_blank" rel="noopener noreferrer">交集方法</a>，它对于组合两个模式，创建“模式混合”特别有用。例如:</p>
<pre>let zod= require('zod')

const HasId = zod.object({
  id: zod.number(),
});

const BaseTeacher = zod.object({
  name: zod.string(),
});

const Teacher = zod.intersection(BaseTeacher, HasId);

type Teacher = zod.infer&lt;typeof Teacher&gt;;
// { id:number; name:string };
</pre>
<h2 id="conclusion">结论</h2>
<p>从上面的比较中可以看出，Zod和Yup都有简单的API来使用模式验证数据。除了验证数据之外，Yup还有一些功能，比如number模式的truncate和round方法，这在特定情况下可能会派上用场。</p>
<p>就像Yup一样，Zod能够验证函数的输入和输出，以确保它拥有所有正确的数据。它还具有强大的TypeScript支持，可以在出现错误时终止运行时，而当推断的类型错误时，Yup什么也不做。更重要的是，Zod有一些独特的特性来定义可选的模式，比如union和intersection。</p>
<p>那么，您应该为您的下一个项目使用哪个模式验证库呢？这在很大程度上取决于您的应用需求。如果您要进行大量的表单验证，我建议您使用Yup，因为它的广泛功能涵盖了表单中使用的许多模式，甚至是您必须进行舍入的情景模式。</p>
<p>但是，如果您有大量的API数据交换，并且需要验证在客户端和服务器之间传递的所有数据，Zod可能是您的最佳选择——尤其是如果您使用TypeScript的话。</p><div class="code-block code-block-2">
<div class="blog-plug base-cta"><h2>使用<a class="signup" href="https://lp.logrocket.com/blg/signup" target="_blank" rel="noopener noreferrer"> LogRocket </a>消除传统错误报告的干扰</h2>
<a href="https://lp.logrocket.com/blg/signup" class="signup" target="_blank" rel="noopener noreferrer"><img class="alignnone size-full wp-image-46 jetpack-lazy-image" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/><noscript><img data-lazy-fallback="1" class="alignnone size-full wp-image-46" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/></noscript></a>
<p><a href="https://lp.logrocket.com/blg/signup" target="_blank" rel="noopener noreferrer"> LogRocket </a>是一个数字体验分析解决方案，它可以保护您免受数百个假阳性错误警报的影响，只针对几个真正重要的项目。LogRocket会告诉您应用程序中实际影响用户的最具影响力的bug和UX问题。</p>
<p>然后，使用具有深层技术遥测的会话重放来确切地查看用户看到了什么以及是什么导致了问题，就像你在他们身后看一样。</p>
<p>LogRocket自动聚合客户端错误、JS异常、前端性能指标和用户交互。然后LogRocket使用机器学习来告诉你哪些问题正在影响大多数用户，并提供你需要修复它的上下文。</p>
<p>关注重要的bug—<a class="signup" href="https://lp.logrocket.com/blg/signup-issue-free" target="_blank" rel="noopener noreferrer">今天就试试LogRocket】。</a></p></div></div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
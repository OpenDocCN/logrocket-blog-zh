<html>
<head>
<title>3 annotations to use in your GraphQL schema - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>在GraphQL schema - LogRocket博客中使用的3个注释</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/3-annotations-to-use-in-your-graphql-schema/#0001-01-01">https://blog.logrocket.com/3-annotations-to-use-in-your-graphql-schema/#0001-01-01</a></blockquote><div><article class="article-post">
<h3>介绍</h3>
<p>GraphQL的描述性查询语言和并行解析器架构已经帮助许多公司，如Shopify和Github，向他们的用户提供强大的数据API。</p>
<p>GraphQL的一个鲜为人知的特性叫做注释，现在被Apollo或Relay等库广泛使用，以提供更好的开发人员体验。</p>
<p>本文将向您介绍注释，并引导您了解3种有用注释的最常见用法。</p>
<h2>什么是注释？</h2>
<h3>句法</h3>
<p>帮助您遵循官方GraphQL规范的注释或<strong>指令</strong>是GraphQL语言的一个官方特性。</p>
<p>指令很容易被字符<code>@</code>识别，如下所示:</p>
<pre>&lt;code&gt;
query Hero($episode: Episode, $withFriends: Boolean!) {
  hero(episode: $episode) {
    name
    friends @include(if: $withFriends) {
      name
    }
  }
}
&lt;/code&gt;</pre>
<p>在本例中，<a href="https://graphql.org/learn/queries/#directives" target="_blank" rel="noopener noreferrer">取自官方GraphQL文档</a>，该指令的名称是“include”。</p>
<p>正如GraphQL文档中所写的，指令可以接收参数，并且可以应用于GraphQL文档中的许多地方。</p>
<p><strong>应用于查询字段的指令(Apollo客户端)</strong></p>
<pre>&lt;code&gt;
query GetCartItems {
    cartItems @client
}
&lt;/code&gt;</pre>
<p><strong>应用于类型定义的指令(阿波罗联盟)</strong></p>
<pre>&lt;code&gt;
type User @key(fields: "id") {
  id: ID!
  username: String!
}
&lt;/code&gt;</pre>
<p>为简单起见，本文只涵盖了指令可能位置的一个子集(主要是操作的字段)。</p>
<p>完整的可能位置列表可以在<a href="https://stackoverflow.com/a/61755619" target="_blank" rel="noopener noreferrer">这个优秀的堆栈溢出答案</a>中找到。</p>
<h3>目的</h3>
<p>指令可以被看作是GraphQL语法的缩写，它向GraphQL服务器或客户机传递额外的信息，以便执行查询或变异。</p>
<p><strong> GraphQL Server @include指令</strong></p>
<pre>&lt;code&gt;
query Hero($episode: Episode, $withFriends: Boolean!) {
  hero(episode: $episode) {
    name
    friends @include(if: $withFriends) {
      name
    }
  }
}
&lt;/code&gt;
</pre>
<p><code>@include</code>指令指示GraphQL服务器何时应该在响应<code>data</code> JSON主体中包含或不包含这些字段。</p>
<p><strong>阿波罗客户端<code>@client</code>指令</strong></p>
<pre>&lt;code&gt;
query GetCartItems {
    cartItems @client
}
&lt;/code&gt;
</pre>
<p>Apollo客户端“提供”指令<code>@client</code>作为指示字段值是应该在本地获取还是在GraphQL API上远程获取的简写。</p>
<p>我们将在下一节仔细研究一下<code>@client</code>指令。</p>
<h3>它是如何工作的？</h3>
<p>让我们分析一下<code>@include</code>指令在应用于以下查询时是如何工作的:</p>
<pre>&lt;code&gt;
query Hero($episode: Episode, $withFriends: Boolean!) {
  hero(episode: $episode) {
    name
    friends @include(if: $withFriends) {
      name
    }
  }
}
&lt;/code&gt;</pre>
<p><img data-attachment-id="24964" data-permalink="https://blog.logrocket.com/3-annotations-to-use-in-your-graphql-schema/directives-server-side/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/09/Directives-server-side.png" data-orig-size="797,291" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Directives-server-side" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/09/Directives-server-side-300x110.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/09/Directives-server-side.png" decoding="async" class="aligncenter wp-image-24964 jetpack-lazy-image" src="../Images/a662179d304605faabae7cc5251c8e1f.png" alt="Directives.png" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2020/09/Directives-server-side.png 797w, https://blog.logrocket.com/wp-content/uploads/2020/09/Directives-server-side-300x110.png 300w, https://blog.logrocket.com/wp-content/uploads/2020/09/Directives-server-side-768x280.png 768w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2020/09/Directives-server-side.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/09/Directives-server-side.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="24964" data-permalink="https://blog.logrocket.com/3-annotations-to-use-in-your-graphql-schema/directives-server-side/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/09/Directives-server-side.png" data-orig-size="797,291" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Directives-server-side" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/09/Directives-server-side-300x110.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/09/Directives-server-side.png" decoding="async" loading="lazy" class="aligncenter wp-image-24964" src="../Images/a662179d304605faabae7cc5251c8e1f.png" alt="Directives.png" srcset="https://blog.logrocket.com/wp-content/uploads/2020/09/Directives-server-side.png 797w, https://blog.logrocket.com/wp-content/uploads/2020/09/Directives-server-side-300x110.png 300w, https://blog.logrocket.com/wp-content/uploads/2020/09/Directives-server-side-768x280.png 768w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/09/Directives-server-side.png"/></noscript>
<p>当解析传入的操作(<code>Hero</code>查询)时，服务器浏览每个字段，调用解析器来获取适当的数据。</p>
<p>当到达<code>friends</code>字段时，GraphQL服务器会遇到<code>include</code>指令并调用它，以及字段定义和相关的解析器。</p>
<p>只有当<code>if</code>参数值为真时，<code>include</code>指令才会调用<code>friends</code>解析器。</p>
<p>总而言之，在服务器端，指令将字段解析器“包装”为:</p>
<ul>
<li>跳过解析器(例如:<code>@skip</code>或<code>@include</code>指令——见下一节)</li>
<li>调用解析程序后转换数据</li>
</ul>
<p>注释还允许您为操作(查询、突变)添加新的行为，或者为类型定义添加额外的信息。</p><div class="code-block code-block-54">
<hr/>
<h3>更多来自LogRocket的精彩文章:</h3>

<hr/></div>
<p>现在让我们通过回顾许多类型的指令变得更加实际，包括标准指令、Apollo定制指令和社区驱动指令。</p>
<h2>适用于您的应用的通用指令</h2>
<p>我们现在已经熟悉了指令语法和它们的内部工作方式。让我们来看看一些你可能已经使用过而没有注意到的。</p>
<h3>模式的标准指令</h3>
<p>以下指令由<a href="https://spec.graphql.org/draft/#sec-Type-System.Directives" target="_blank" rel="noopener noreferrer"> GraphQL规范</a>定义，旨在被任何GraphQL服务器(任何遵循GraphQL规范的服务器库，不仅仅是Apollo)支持。</p>
<p>该规范定义了三个指令，包括上一节中看到的<code>@include</code>指令。</p>
<h3><code>@skip</code></h3>
<p>只有当<code>if</code>参数值为假时，该指令才与<code>@include</code>指令相反，包括目标字段。</p>
<pre>&lt;code&gt;
query Hero($episode: Episode, $onlyHero: Boolean!) {
  hero(episode: $episode) {
    name
    friends @skip(if: $onlyHero) {
      name
    }
  }
}
&lt;/code&gt;</pre>
<h3><code>@deprecated</code></h3>
<p>与我们之前看到的指令不同，该指令旨在用于类型定义，而不是操作(查询/变异)，以提供关于类型本身的额外信息。</p>
<pre>&lt;code&gt;
type Hero {
    name: String!
    friends: [Hero!]!
    appearsIn: [Movie!]!
    appearsOn: [Movie!]! @deprecated(reason: "Use `appearsIn`.")
}
&lt;/code&gt;</pre>
<p>使用此指令来指示不推荐使用的字段有许多优点:</p>

<h3>客户端指令的现代用例</h3>
<p>Apollo Client在客户端使用了一些有趣的指令。客户端的指令行为与服务器端的稍有不同。</p>
<p>它是如何工作的？</p>
<p>客户端指令只在客户端定义，这意味着目标GraphQL服务器不应该接收它们。</p>
<p><img data-attachment-id="24965" data-permalink="https://blog.logrocket.com/3-annotations-to-use-in-your-graphql-schema/directives-client-side/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/09/Directives-client-side.png" data-orig-size="721,382" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Directives-client-side" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/09/Directives-client-side-300x159.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/09/Directives-client-side.png" decoding="async" class="aligncenter wp-image-24965 jetpack-lazy-image" src="../Images/9d224756e952c8383d1d0cd48e961ade.png" alt="Directives on the client side." data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2020/09/Directives-client-side.png 721w, https://blog.logrocket.com/wp-content/uploads/2020/09/Directives-client-side-300x159.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2020/09/Directives-client-side.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/09/Directives-client-side.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="24965" data-permalink="https://blog.logrocket.com/3-annotations-to-use-in-your-graphql-schema/directives-client-side/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/09/Directives-client-side.png" data-orig-size="721,382" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Directives-client-side" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/09/Directives-client-side-300x159.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/09/Directives-client-side.png" decoding="async" loading="lazy" class="aligncenter wp-image-24965" src="../Images/9d224756e952c8383d1d0cd48e961ade.png" alt="Directives on the client side." srcset="https://blog.logrocket.com/wp-content/uploads/2020/09/Directives-client-side.png 721w, https://blog.logrocket.com/wp-content/uploads/2020/09/Directives-client-side-300x159.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/09/Directives-client-side.png"/></noscript>
<p>上图中未显示的一个额外步骤是客户端指令可能会执行:</p>
<ul>
<li>在向GraphQL服务器发送查询之前</li>
<li>在从GraphQL服务器获得响应之后，在将结果传播到缓存和组件(钩子)之前</li>
</ul>
<p>总之，客户端指令可以与缓存数据交互，并提供缓存管理功能。</p>
<h2>客户端指令</h2>
<p>现在让我们看一些Apollo Client的客户端指令带来的特性的例子。</p>
<h3>阿波罗客户端<code>@client</code>指令</h3>
<p>如上所述，下面的GraphQL查询使用了一个名为<code>@client</code>的客户端指令。</p>
<pre>&lt;code&gt;
product(id: $productId) {
  name
  price
  isInCart @client
}
&lt;/code&gt;</pre>
<p>Apollo Clien  t提供的<code>@client</code>指令<a href="https://www.apollographql.com/docs/tutorial/local-state/" target="_blank" rel="noopener noreferrer">表示<code>isInCart</code>字段是本地的，这意味着不需要向GraphQL服务器请求来获取它的值。</a></p>
<p>如下图所示，我们的查询将分许多步骤执行:</p>
<ul>
<li>Apollo客户端从查询中提取本地字段(<code>@client</code>字段)</li>
<li>获取本地字段值</li>
<li>请求API(没有<code>@client</code>字段)</li>
<li>缓存来自API响应的远程字段</li>
<li>将所有字段返回给客户端(或<code>useQuery()</code>钩子)</li>
</ul>
<p><img data-attachment-id="24966" data-permalink="https://blog.logrocket.com/3-annotations-to-use-in-your-graphql-schema/queries-and-caches/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/09/queries-and-caches.png" data-orig-size="1310,680" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="queries-and-caches" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/09/queries-and-caches-300x156.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/09/queries-and-caches-1024x532.png" decoding="async" class="aligncenter wp-image-24966 jetpack-lazy-image" src="../Images/99ea8e2bd77ba1675233fca818578956.png" alt="Queries and caches." data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2020/09/queries-and-caches.png 1310w, https://blog.logrocket.com/wp-content/uploads/2020/09/queries-and-caches-300x156.png 300w, https://blog.logrocket.com/wp-content/uploads/2020/09/queries-and-caches-1024x532.png 1024w, https://blog.logrocket.com/wp-content/uploads/2020/09/queries-and-caches-768x399.png 768w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2020/09/queries-and-caches.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/09/queries-and-caches.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="24966" data-permalink="https://blog.logrocket.com/3-annotations-to-use-in-your-graphql-schema/queries-and-caches/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/09/queries-and-caches.png" data-orig-size="1310,680" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="queries-and-caches" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/09/queries-and-caches-300x156.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/09/queries-and-caches-1024x532.png" decoding="async" loading="lazy" class="aligncenter wp-image-24966" src="../Images/99ea8e2bd77ba1675233fca818578956.png" alt="Queries and caches." srcset="https://blog.logrocket.com/wp-content/uploads/2020/09/queries-and-caches.png 1310w, https://blog.logrocket.com/wp-content/uploads/2020/09/queries-and-caches-300x156.png 300w, https://blog.logrocket.com/wp-content/uploads/2020/09/queries-and-caches-1024x532.png 1024w, https://blog.logrocket.com/wp-content/uploads/2020/09/queries-and-caches-768x399.png 768w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/09/queries-and-caches.png"/></noscript>
<p><a href="https://www.apollographql.com/docs/react/local-state/local-state-management/" target="_blank" rel="noopener noreferrer">图来自官方Apollo React客户端文档</a></p>
<p>关于<code>@client</code>的使用，Apollo客户端有一些改进。以下查询仅使用本地字段，不会触发对GraphQL服务器的请求(因为没有远程字段):</p>
<pre>&lt;code&gt;
query GetCartItems {
    cartItems @client
}
&lt;/code&gt;</pre>
<p><code>GetCartItems</code>查询是Apollo GraphQL的“本地状态”用法的一个完美例子，由于directives语法带来了令人愉快的体验。</p>
<h3>阿波罗客户端<code>@export</code>指令</h3>
<p>另一个提供优秀开发人员体验的聪明用法是客户端<code>@export</code>指令:</p>
<pre>&lt;code&gt;
query CurrentUserPostCount($userId: Int!) {
  currentUserId @client @export(as: "userId")
  postCount(user: $userId)
}
&lt;/code&gt;</pre>
<p>这个指令由Apollo Client提供，允许您重用任何本地字段值(通过<code>@client</code>)作为字段的变量或当前操作的子查询。</p>
<p><code>CurrentUserPostCount</code>查询是Apollo提供的关于GraphQL状态管理的另一个流畅体验的例子。</p>
<p>如果不使用<code>@export</code>,就需要一个单独的查询和附加的逻辑来实现相同的GraphQL查询。</p>
<h2>3个强大的模式注释</h2>
<p>我们看到了由官方规范和主要库在客户端和服务器端提供的指令的好例子。</p>
<p>现在让我们关注3个强大的服务器端指令，您可以开始使用它们来增强您的GraphQL模式。</p>
<h3><strong> <code>@computed</code>指令</strong></h3>
<p>由<a href="https://github.com/graphql-community" target="_blank" rel="noopener noreferrer"> GraphQL社区组织</a>提供的<code>@computed</code>指令在解决一个普遍存在的问题上特别方便:重复和搭建。</p>
<p>很多时候，在现实世界的应用中，一些属性是简单地从现有的属性中计算或推导出来的。</p>
<p>为这些计算属性编写解析器既麻烦又不必要。</p>
<p>让我们来看看<code>@computed</code>的行动:</p>
<pre>&lt;code&gt;
type User {
  firstName: String
  lastName: String
  fullName: String @computed(value: "$firstName $lastName")
}

type Query {
  me: User
}

&lt;/code&gt;</pre>
<p>这里，<code>User.fullName</code>属性不需要resolver方法。<code>@computed</code>会在需要时自动计算适当的值。</p>
<p>完整的安装细节可在官方资料库中找到:</p>
<blockquote class="embedly-card" data-card-controls="1" data-card-align="center" data-card-theme="light">

<p>指令允许从定义了的字段创建计算属性。yarn add graphql-directive-computed-property该包需要graph QL和graphql-tools作为对等依赖查询:Result:Example:admin:String @ rest(URL:" $ { URL _ TO _ API } ")@ computed(value:"你是admin吗？$admin ")指令参数:计算值。它可以包含定义它的类型中的其他字段。</p>
</blockquote>
<p/>
<p>在您的模式上使用这个指令将有助于您保持解析器的伸缩性。</p>
<h3><strong>认证指令</strong></h3>
<p>现在让我们来解决一个更重要的挑战，再次借助于<a href="https://github.com/graphql-community" target="_blank" rel="noopener noreferrer"> GraphQL社区组织</a>包:<a href="https://github.com/graphql-community/graphql-directive-auth" target="_blank" rel="noopener noreferrer"> graphql-directive-auth </a>。</p>
<p>指令为认证和授权GraphQL APIs设计挑战提供了一个优雅的解决方案。</p>
<p><a href="https://github.com/graphql-community/graphql-directive-auth" target="_blank" rel="noopener noreferrer"> graphql-directive-auth </a>包提供了两个强大的指令:</p>
<ul>
<li><code>@isAuthenticated</code></li>
<li><code/><code>@hasRole(role: String)</code></li>
</ul>
<p>这两个指令都适用于字段定义，如下图所示:</p>
<pre>&lt;code&gt;
type Query {
  currentUser: User @isAuthenticated
  users: [User] @isAuthenticated
}

type User {
  id
  first_name
  last_name
  purchases: [Product!]! @hasRole('self', 'admin')
}
&lt;/code&gt;</pre>
<p>通过阅读该模式，我们了解到:</p>
<ul>
<li>只有经过身份验证的用户才能访问用户(当前用户和列表用户)</li>
<li>用户的购买只能由列出</li>
<li>管理</li>
<li>用户本身(“自我”)</li>
</ul>
<p>只有管理员才能运行以下查询，因为他是唯一可以访问所有用户的购买列表的用户:</p>
<pre>&lt;code&gt;
query {
  users {
    id
    first_name
    purchases {
      title
      price
    }
  }
}
&lt;/code&gt;</pre>
<p>graphql-directive-auth 依赖于JWT，以两种模式运行:</p>
<ul>
<li><a href="https://github.com/graphql-community/graphql-directive-auth#default" target="_blank" rel="noopener noreferrer">默认模式</a>期望每个请求携带一个带有JWT令牌的<code>Authorization</code>报头，该令牌携带一些<code>role</code>属性</li>
<li><a href="https://github.com/graphql-community/graphql-directive-auth#custom-behaviour-of-authentication-functions" target="_blank" rel="noopener noreferrer">自定义模式</a>允许您定义一个自定义方法来定义如何认证用户(<code>@isAuthenticated</code>)以及一个自定义方法来定义角色检查行为(<code>hasRole(role)</code>)。</li>
</ul>
<p>多亏了GraphQL指令，这个库提供了一种简单的方法来为您的GraphQL API添加可扩展的身份验证层。</p>
<p>完整的安装和自定义配置详细信息可在官方存储库中找到:</p>
<blockquote class="embedly-card" data-card-controls="1" data-card-align="center" data-card-theme="light">

<p>graphql-directive-auth的创建是为了帮助完成几乎每个API都面临的常见身份验证任务。yarn add graphql-directive-auth我们能够以两种不同的方式使用指令:要使用默认的指令行为，您需要设置APP_SECRET环境变量，仅此而已。</p>
</blockquote>
<p>格式化指令</p>
<h3>大多数前端应用程序选择在客户端进行所有的数据格式化，从而产生了数kb的第三方格式化库。</h3>
<p><a href="https://github.com/Saeris/graphql-directives#formatcurrenc" target="_blank" rel="noopener noreferrer">@ saeris/graph QL-directives</a>包提供了一组30个指令，允许您的前端让API完成所有繁重的格式化工作。</p>
<p>让我们强调一下最有趣的指令:</p>
<p>考虑到货币格式化这个复杂的主题，<code>@formatCurrency</code>尤其有趣。</p>
<pre>&lt;code&gt;
type Example {
  # Int | Float =&gt; String
  hourlyRate: Int @formatCurrency(
    defaultFormat = "$0,0.00" # String!
    defaultRoundingMode = HALF_AWAY_FROM_ZERO # RoundingMode!
  )
}

query ExampleQuery {
  getPerson {
    # Raw =&gt; Default Format =&gt; Requested Format
    # 1150 =&gt; $11.50 =&gt; EUR 11.5
    hourlyRate(format: "USD0,0.0", currency: "EUR") # =&gt; EUR 11.5
  }
}
&lt;/code&gt;</pre>
<p>有趣的是，作为一个类型定义指令，<code>@formatCurrency</code>增强了应用的字段解析器，允许客户在查询时传递可选的格式参数，如<code>format</code>或<code>currency</code>。</p>
<p>这同样适用于日期、数字、电话号码格式，以及20多条字符串和测量指令！</p>
<p>这个包绝对是现代GraphQL API的必备包。花点时间看看官方知识库:<a href="https://github.com/Saeris/graphql-directives#formatdate" target="_blank" rel="noopener noreferrer">https://github.com/Saeris/graphql-directives#formatdate</a></p>
<p>更进一步</p>
<h2>指令是扩展类型定义能力和GraphQL操作(查询和突变)执行的一种直观而灵活的方式。</h2>
<p>在服务器端，指令允许您向类型添加元数据(<code>@deprecated</code>，Apollo Federation指令)，优化查询(<code>@include</code>，<code>@skip</code>，以及转换数据(<code>@computed</code>)。</p>
<p>在客户端，指令主要用于定制缓存行为和添加一些本地状态管理功能(<code>@client</code>)。</p>
<p>然而，创建有用的通用指令是复杂的。</p>
<p>因此，指令的主要功能是编写自己的指令，以便:</p>
<p>避免在解析器之间重复逻辑，并将其作为指令重用(验证)</p>
<ul>
<li>向您的客户端公开自定义逻辑操作(格式化、自定义ACL)</li>
<li>构建指令是通过使用graphql-tools的<a href="https://www.graphql-tools.com/docs/legacy-schema-directives/#declaring-schema-directives" target="_blank" rel="noopener noreferrer">SchemaDirectiveVisitor API</a>实现的。</li>
</ul>
<p>学习这个API的一个很好的起点是专门针对这个主题的<a href="https://www.apollographql.com/docs/apollo-server/schema/creating-directives/#uppercasing-strings" target="_blank" rel="noopener noreferrer"> great Apollo文档页面</a>。</p>
<p>结论</p>
<h3>我希望这篇文章中推荐的三个注释能启发你写自己的注释。请注意，在GraphQL生态系统中，指令才刚刚开始，因为将来会有更多的特性出现<a href="https://www.youtube.com/watch?v=sMTNTy_aOU0" target="_blank" rel="noopener noreferrer">、@defer、@live、@specifiedBy </a>。</h3>
<p>监控生产中失败和缓慢的GraphQL请求</p><div class="code-block code-block-24">
<div class="blog-plug inline-plug graphql-plug"><h2>虽然GraphQL有一些调试请求和响应的特性，但确保GraphQL可靠地为您的生产应用程序提供资源是一件比较困难的事情。如果您对确保对后端或第三方服务的网络请求成功感兴趣，</h2><p>.</p><a href="https://lp.logrocket.com/blg/graphql-signup" target="_blank">try LogRocket</a><p>LogRocket 就像是网络和移动应用的DVR，记录下你网站上发生的每一件事。您可以汇总并报告有问题的GraphQL请求，以快速了解根本原因，而不是猜测问题发生的原因。此外，您可以跟踪Apollo客户机状态并检查GraphQL查询的键值对。</p><a class="signup" href="https://lp.logrocket.com/blg/graphql-signup" target="_blank" rel="noopener noreferrer"><img src="../Images/432a3823c85b3fb72a206e6236a29f48.png" data-lazy-src="https://files.readme.io/69aa835-Image_2019-11-09_at_1.28.05_PM.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" class=" jetpack-lazy-image" data-original-src="https://files.readme.io/69aa835-Image_2019-11-09_at_1.28.05_PM.png"/><noscript><img data-lazy-fallback="1" src="../Images/432a3823c85b3fb72a206e6236a29f48.png" data-original-src="https://files.readme.io/69aa835-Image_2019-11-09_at_1.28.05_PM.png"/></noscript><img class="alignnone size-full wp-image-46 jetpack-lazy-image" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/><noscript><img data-lazy-fallback="1" class="alignnone size-full wp-image-46" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/></noscript></a><a href="https://lp.logrocket.com/blg/graphql-signup" target="_blank" rel="noopener noreferrer">https://logrocket.com/signup/</a><p>LogRocket检测您的应用程序以记录基线性能计时，如页面加载时间、到达第一个字节的时间、慢速网络请求，还记录Redux、NgRx和Vuex操作/状态。</p><p>.</p><a class="signup" href="https://lp.logrocket.com/blg/graphql-signup" target="_blank" rel="noopener noreferrer">Start monitoring for free</a><p>.</p></div>


</div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
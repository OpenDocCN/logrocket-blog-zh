<html>
<head>
<title>Beyond cookies: Today's options for client-side data storage - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>超越cookies:今天客户端数据存储的选择</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/beyond-cookies-todays-options-for-client-side-data-storage/#0001-01-01">https://blog.logrocket.com/beyond-cookies-todays-options-for-client-side-data-storage/#0001-01-01</a></blockquote><div><article class="article-post">
<p>当cookies第一次被引入时，它是浏览器保存数据的唯一方式。从那以后，增加了新的选项Web存储API、<a href="https://blog.logrocket.com/cache-invalidation-strategies-using-indexeddb-in-angular-2/" target="_blank" rel="noopener noreferrer"> IndexedDB </a>以及其中的缓存API。那么，饼干死了吗？让我们来看看在浏览器中存储数据的每个选项。</p>
<h2>饼干</h2>
<p>Cookies是由服务器发送或在客户端设置的信息，保存在用户浏览器的本地。它们会自动附加到每个请求。由于HTTP是一种无状态协议，cookies允许将信息存储在客户机上，以便将额外的上下文传递给服务器。</p>
<p>Cookies有几个标志，对于提高应用程序数据的安全性非常有用。<code>HttpOnly</code>标志防止使用JavaScript访问cookie它们只有在附加到HTTP请求上时才可访问。这对于防止通过XSS(跨站点脚本)攻击暴露您的数据非常有用。</p>
<p>此外，<code>Secure</code>标志确保仅当通过HTTPS协议发送请求时才发送cookie。可以设置为<code>lax</code>或<code>strict</code>的<code>SameSite</code>标志(在此了解区别<a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Cookies#SameSite_cookies"/>)可用于帮助防止CSRF(跨站点请求伪造)请求。它告诉浏览器，如果请求是发送到与请求者在同一个域上的URL，就只发送cookies。</p>
<h3>你什么时候会用饼干？</h3>
<p>那么，在哪些情况下你可能会想伸手去拿饼干呢？最常见的用例之一是授权令牌。由于<code>HttpOnly</code>标志增加了一层额外的保护来抵御XSS攻击，<code>SameSite</code>可以防范CSRF，<code>Secure</code>可以确保您的cookie被加密，您的auth token就有了一层额外的保护。</p>
<p>由于auth令牌非常小，所以您不需要担心每个请求的大小会变大。此外，由于它们会自动附加到每个请求，使用cookies允许您在服务器上确定用户是否经过身份验证。这对于服务器呈现的内容非常有用，或者如果您希望在用户未经身份验证的情况下将他们重定向到登录页面，这也非常有用。</p>
<p>cookies的另一个好用途是存储用户的语言代码。因为在大多数请求中，您可能希望访问用户的语言，所以您可以利用它是自动附加的这一事实。</p>
<h3>你会如何使用cookies？</h3>
<p>既然我们已经讨论了为什么你可能想要使用cookie，让我们来看看<em>如何</em>使用cookie。要从服务器在客户机上设置cookie，在HTTP响应中添加一个<code>Set-Cookie</code>头。cookies应该是<code>key=value</code>的格式。例如，如果您从一个<a href="https://blog.logrocket.com/handling-and-dispatching-events-with-node-js/" target="_blank" rel="noopener noreferrer"> Node.js </a>应用程序设置cookies，您的代码可能如下所示:</p>
<pre>response.setHeader('Set-Cookie', ['user_lang=en-us', 'user_theme=dark_mode']);</pre>
<p>这将设置两个cookies:它将把<code>user_lang</code>设置为<code>en-us</code>，把<code>user_theme</code>设置为<code>dark_mode</code>。</p>
<p>客户端也可以操纵Cookies。要设置cookie，可以以<code>key=value</code>的格式给<code>document.cookie</code>赋值。如果密钥已经存在，它将被覆盖。</p>
<pre>document.cookie = 'user_lang=es-es';</pre>
<p>如果已经定义了<code>user_lang</code>，它现在将等于<code>es-es</code>。</p>
<p>您可以通过访问<code>document.cookie</code>值来读取所有的cookies。这将返回一串分号分隔的键/值对。</p>
<pre>document.cookie = 'user_lang=en-us';
document.cookie = 'user_theme=light_mode';
console.log(document.cookie); // 'user_lang=en-us; user_theme=light_mode;'</pre>
<p>为了提高键/值对的可访问性，可以使用以下函数将该字符串解析为一个对象:</p>
<pre>const parseCookies = x =&gt; x
  .split(';')
  .map(e =&gt; e.trim().split('='))
  .reduce((obj, [key, value]) =&gt; ({...obj, [key]: value}), {});</pre>
<p>如果您需要在cookie上设置一个标志，您可以在分号后添加它们。例如，如果您想在您的cookie上设置<code>Secure</code>和<code>SameSite</code>标志，您可以执行以下操作:</p>
<pre>document.cookie = 'product_ids=123,321;secure;samesite=lax'</pre>
<p>因为<code>HTTPOnly</code>被设计成只能在服务器上访问cookie，所以服务器只能<em>添加</em>。</p>
<p>除了这些安全标志，您还可以设置一个<code>Max-Age</code>(cookie应该持续的秒数)或一个<code>Expires</code>(cookie应该过期的日期)。如果两者都没有设置，cookie将在浏览器会话期间持续存在。如果用户使用匿名，当用户的会话关闭时，cookies将被删除。</p>
<p>由于处理cookies的界面不是最友好的，你可能想使用一个实用程序库，比如<code><a href="https://github.com/js-cookie/js-cookie" target="_blank" rel="noopener noreferrer">js-cookie</a></code>来方便使用。</p>
<h2>Web存储API</h2>
<p>一个更新的本地存储数据的选择是Web存储API。在HTML5中增加了Web存储API，包括<code>localStorage</code>和<code>sessionStorage</code>。虽然cookies通常处理服务器/客户端通信，但Web存储API最适合用于客户端专用数据。</p>
<p>既然我们已经有了cookies作为本地存储数据的选择，为什么还需要网络存储呢？我们已经提到的一个原因是:由于cookies会自动添加到每个HTTP请求中，请求的大小会变得很大。因此，与使用cookies相比，使用Web存储API可以存储更多的数据。</p>
<p>另一个优势是更直观的API。对于cookie，您需要手动解析cookie字符串来访问单独的键。网络存储使这变得更容易。如果您想设置或获取一个值，您可以运行<code>setItem</code>或<code>getItem</code>。</p>
<pre>localStorage.setItem('selected_tab', 'FAQ');
localSTorage.getItem('selected_tab'); // 'FAQ'</pre>
<p>键和值<em>都必须</em>是字符串；如果你想保存一个对象或数组，你可以通过在保存时调用<code>JSON.stringify()</code>和在读取时调用<code>JSON.parse()</code>来完成。</p>
<pre>const product = {
  id: '123',
  name: 'Coffee Beans',
};

localStorage.setItem('cached_product', JSON.stringify(product));
JSON.parse(localStorage.getItem('cached_product'));</pre>
<p>本地存储的另一个用例是在多个选项卡之间同步数据。通过为<code>'storage'</code>事件添加一个监听器，您可以在另一个选项卡/窗口中更新数据。</p>
<pre>window.addEventListener('storage', () =&gt; {
  console.log('local storage has been updated');
});</pre>
<p>仅当在另一个文档中修改了本地或会话存储<em>时，才会触发此事件，也就是说，您无法在当前浏览器选项卡中监听存储更改。不幸的是，在撰写本文时，存储事件监听器<a href="https://developer.mozilla.org/en-US/docs/Web/API/Window/storage_event#Browser_compatibility">还不能在Chrome </a>上工作。</em></p>
<p>那么，<code>localStorage</code>和<code>sessionStorage</code>有什么区别呢？与cookies不同，Web存储API没有过期或最大寿命特性。如果使用<code>localStorage</code>，数据将无限期保存，除非手动删除。您可以通过运行<code>localStorage.removeItem('key')</code>删除单个键的值，或者您可以通过运行<code>localStorage.clear()</code>清除<em>所有</em>的数据。</p>
<p>如果使用<code>sessionStorage</code>，数据将仅持续当前会话。如果您没有设置最大期限或过期时间，它将被视为类似于cookie的持久存储方式。在任一情况下，如果用户是匿名的，本地存储将不会在会话之间持续。</p>
<h2>索引b</h2>
<p>如果cookies和<code>localStorage</code>都不合适，还有另一个选择:IndexedDB，一个浏览器内数据库系统。</p>
<p>当<code>localStorage</code>同步执行它的所有方法时，IndexedDB异步调用它们。这允许在不阻塞代码其余部分的情况下访问数据。当您处理大量访问成本高昂的代码时，这非常有用。</p><div class="code-block code-block-54">
<hr/>
<h3>更多来自LogRocket的精彩文章:</h3>

<hr/></div>
<p>IndexedDB在存储数据的类型上也有更大的灵活性。虽然cookies和<code>localStorage</code>仅限于存储字符串，但IndexedDB可以存储任何类型的数据，这些数据可以被“结构化克隆算法”复制。这包括类型为<code>Object</code>、<code>Date</code>、<code>File</code>、<code>Blob</code>、<code>RegEx</code>、<a href="https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Structured_clone_algorithm#Supported_types">以及更多</a>的对象。</p>
<p>性能和灵活性提高的不利方面是IndexedDB的API更加低级和复杂。幸运的是，有许多实用程序库可以在这方面提供帮助。</p>
<p><code><a href="https://github.com/localForage/localForage">localForage</a></code>给出了一个更简单的类似于<code>localStorage</code>的API来索引DB。<a href="https://pouchdb.com/"> PouchDB </a>给出了一个可以与在线<a href="http://couchdb.apache.org/"> CouchDB </a>数据库同步的离线存储API。idb是一个很小的库，有一个更简单的基于promise的API。Dexie 在保持良好性能的同时，增加了一个更加健壮的查询API。根据您的用途，有许多选项可供选择。</p>
<h2>缓存API</h2>
<p>持久数据的另一个专用工具是缓存API。虽然它最初是为服务人员创建的，但它可以用来缓存任何网络请求。缓存API公开了<code>Window.caches</code>，它提供了保存和检索响应的方法。这允许您保存成对的<code>Requests</code>和<code>Responses</code>，以便以后访问。</p>
<p>例如，如果您想在从API请求响应之前检查浏览器的缓存，您可以执行以下操作:</p>
<pre>const apiRequest = new Request('https://www.example.com/items');
caches.open('exampleCache') // opens the cache
  .then(cache =&gt; {
    cache.match(apiRequest) // checks if the request is cached
      .then(cachedResponse =&gt; 
        cachedResponse || // return cachedReponse if available
        fetch(apiRequest) // otherwise, make new request
          .then(response =&gt; {
            cache.put(apiRequest, response); // cache the response
            return response;
          })
        })
    .then(res =&gt; console.log(res))
})</pre>
<p>第一次运行代码时，它将缓存响应。每次随后，请求都会被缓存，并且不会发出网络请求。</p>
<h2>最后</h2>
<p>在浏览器上存储数据的每种方法都有自己的用途。如果信息很小，很敏感，并且可能会在服务器上使用，那么cookies是一个不错的选择。如果您要保存较大且不太敏感的数据，Web存储API可能是更好的选择。</p>
<p>如果您打算存储大量的结构化数据，IndexedDB非常有用。缓存API用于存储HTTP请求的响应。根据你的需要，有很多工具可供选择。</p>
<h2>额外资源和进一步阅读</h2>
<p>您可以阅读MDN web文档，了解有关上述方法的更多信息:</p><div class="code-block code-block-2">
<div class="blog-plug base-cta"><h2>使用<a class="signup" href="https://lp.logrocket.com/blg/signup" target="_blank" rel="noopener noreferrer"> LogRocket </a>消除传统错误报告的干扰</h2>
<a href="https://lp.logrocket.com/blg/signup" class="signup" target="_blank" rel="noopener noreferrer"><img class="alignnone size-full wp-image-46 jetpack-lazy-image" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/><noscript><img data-lazy-fallback="1" class="alignnone size-full wp-image-46" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/></noscript></a>
<p><a href="https://lp.logrocket.com/blg/signup" target="_blank" rel="noopener noreferrer"> LogRocket </a>是一个数字体验分析解决方案，它可以保护您免受数百个假阳性错误警报的影响，只针对几个真正重要的项目。LogRocket会告诉您应用程序中实际影响用户的最具影响力的bug和UX问题。</p>
<p>然后，使用具有深层技术遥测的会话重放来确切地查看用户看到了什么以及是什么导致了问题，就像你在他们身后看一样。</p>
<p>LogRocket自动聚合客户端错误、JS异常、前端性能指标和用户交互。然后LogRocket使用机器学习来告诉你哪些问题正在影响大多数用户，并提供你需要修复它的上下文。</p>
<p>关注重要的bug—<a class="signup" href="https://lp.logrocket.com/blg/signup-issue-free" target="_blank" rel="noopener noreferrer">今天就试试LogRocket】。</a></p></div></div>


<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
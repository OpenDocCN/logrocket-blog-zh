<html>
<head>
<title>More alternatives to Moment.js - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>Moment.js - LogRocket博客的更多选择</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/more-alternatives-to-moment-js/#0001-01-01">https://blog.logrocket.com/more-alternatives-to-moment-js/#0001-01-01</a></blockquote><div><article class="article-post">
<p>毫无疑问，Moment.js是JavaScript生态系统中最受欢迎的库之一，但现在<a href="https://momentjs.com/docs/#/-project-status/" target="_blank" rel="noopener noreferrer">被认为是维护模式</a>中的遗留项目，并且不鼓励使用它，您可能正在寻找一些替代品。</p>
<p>起初，寻找一个替代库似乎不是一件容易的事情，因为使用Moment.js可以做很多事情。例如:</p>

<p>然而，大多数项目并不需要所有这些功能。虽然有些项目可能使用Moment.js以特定的方式格式化日期和时间(相对日期和时间更受欢迎)，但对于其他项目来说，更重要的是检查日期是在其他日期之前、之后还是之间，或者根据用户的区域设置显示日期。</p>
<p>所以很可能，许多项目可以通过使用本地JavaScript对象(比如<a href="https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Date" target="_blank" rel="noopener noreferrer"> Date </a>和<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl" target="_blank" rel="noopener noreferrer"> Intl </a>)的组合来满足他们的需求，也可以选择使用一个轻量级库来满足特定的目的。</p>
<p>去年，我写了一篇文章，回顾了国际化背景下Moment.js的替代方案。那篇文章中评论的库(<a href="https://moment.github.io/luxon/" target="_blank" rel="noopener noreferrer"> luxon </a>、<a href="https://date-fns.org/" target="_blank" rel="noopener noreferrer"> date-fns </a>、<a href="https://github.com/iamkun/dayjs" target="_blank" rel="noopener noreferrer"> day.js </a>)仍然是Moment.js的很好的替代，但是在本文中，我将评论另外三个库的功能:</p>

<p>此外，我将再次访问<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl/RelativeTimeFormat" target="_blank" rel="noopener noreferrer"> Intl。RelativeTimeFormat </a>对象，<a href="https://github.com/tc39/ecma402/pull/391" target="_blank" rel="noopener noreferrer">在2020年初</a>达到第4阶段，现在被更多的浏览器支持。</p>
<p>让我们开始吧。</p>
<h2>js-joda</h2>
<p>如果您使用过Java，那么学习如何使用这个库并不困难，因为它是Java 8中引入的日期/时间API的一个端口(它又基于库<a href="https://www.joda.org/joda-time/" target="_blank" rel="noopener noreferrer"> Joda-Time </a>，因此得名)。</p>
<p>js-joda被组织成一组不可变的核心类。主要的有:</p>
<ul>
<li><a href="https://js-joda.github.io/js-joda/class/packages/core/src/LocalDate.js~LocalDate.html" target="_blank" rel="noopener noreferrer"> LocalDate </a>，表示没有时间信息的日期。例如，<code>2020-12-01</code></li>
<li><a href="https://js-joda.github.io/js-joda/class/packages/core/src/LocalTime.js~LocalTime.html" target="_blank" rel="noopener noreferrer"> LocalTime </a>，代表时间。例如，<code>10:00:01.999999999</code></li>
<li><a href="https://js-joda.github.io/js-joda/class/packages/core/src/LocalDateTime.js~LocalDateTime.html" target="_blank" rel="noopener noreferrer"> LocalDateTime </a>，表示带有时间信息的日期。例如，<code>2020-12-01T10:00:01.999999999</code></li>
</ul>
<p>这些类不提供时区信息。为此，您必须使用<a href="https://js-joda.github.io/js-joda/class/packages/core/src/ZonedDateTime.js~ZonedDateTime.html" target="_blank" rel="noopener noreferrer"> ZonedDateTime </a>，它存储日期、时间和时区信息，以及<a href="https://js-joda.github.io/js-joda/class/packages/core/src/class/packages/core/src/ZoneId.js~ZoneId.html" target="_blank" rel="noopener noreferrer"> ZoneId </a>或<a href="https://js-joda.github.io/js-joda/class/packages/core/src/class/packages/core/src/ZoneOffset.js~ZoneOffset.html" target="_blank" rel="noopener noreferrer"> ZoneOffset </a>来处理特定的时区(您还需要导入包<code>@js-joda/timezone</code>)。</p>
<p>该库还提供了其他类(如<a href="https://js-joda.github.io/js-joda/class/packages/core/src/temporal/ChronoField.js~ChronoField.html" target="_blank" rel="noopener noreferrer"> ChronoField </a>)和类型来表示日期或时间的一部分(如<a href="https://js-joda.github.io/js-joda/class/packages/core/src/Month.js~Month.html" target="_blank" rel="noopener noreferrer">月</a>)。特别是，有一组表示数量和时间点的类:</p>
<ul>
<li><a href="https://js-joda.github.io/js-joda/class/packages/core/src/Duration.js~Duration.html" target="_blank" rel="noopener noreferrer">持续时间</a>，表示从纳秒到天的时间量。例如，2小时</li>
<li><a href="https://js-joda.github.io/js-joda/class/packages/core/src/Period.js~Period.html" target="_blank" rel="noopener noreferrer"> Period </a>，表示基于日期的时间量，使用日、月和年。例如，2年零5天</li>
<li><a href="https://js-joda.github.io/js-joda/class/packages/core/src/Instant.js~Instant.html" target="_blank" rel="noopener noreferrer">瞬间</a>，代表从<code>1970-01-01T00:00:00Z</code>开始测量的单个时间点(包括时区信息)。例如，<code>2020-12-01T10:00:47.202Z</code></li>
</ul>
<p>这些类中的大多数都有一个公共接口，所以它们可以用不同的方式实现相同的方法。例如，<a href="https://js-joda.github.io/js-joda/class/packages/core/src/temporal/Temporal.js~Temporal.html" target="_blank" rel="noopener noreferrer"> Temporal </a>提供了一个带有操作日期时间字段(如天或秒)的方法的契约，这些方法由<code>Instant</code>、<code>LocalTime</code>和<code>ZonedDateTime</code>等类实现。</p>
<p>这样，为了解析或创建日期-时间对象，所有的类都有不同的方法<code>of</code>、<code>from</code>、<code>parse</code>和<code>now</code>。以下是一些例子:</p>
<pre>// Creates a LocalDate object from a year, month, and dayOfMonth value
const ld1 = LocalDate.of(2020, Month.DECEMBER, 1);
// Creates a LocalTime object from an ISO 8601 string
const lt1 = LocalTime.parse("10:01:00.123456789");
// Creates a LocalDateTime object from the current datetime in UTC time
const ldt1 = LocalDateTime.now(ZoneOffset.UTC);
// Creates a ZonedDateTime ojbect from from a local date, time, and a time zone
const zdt1 = ZonedDateTime.of(ld1, lt1, ZoneId.of("Europe/Paris"));
// Creates an instant from the ZonedDateTime object
const i1 = Instant.from(zdt1);
// Creates a Period object from a text string such as PnYnMnD
const p1 = Period.parse("P1Y10M");
// Creates a Duration object from a number of standard hours (positive or negative)
const d1 = Duration.ofHours(-48);</pre>
<p><code>with*</code>方法可以用作setters(创建一个新的实例，因为一切都是不可变的):</p>
<pre>// Returns a copy of the LocalDate with the value 2020/12/3
const ld2 = ld1.withDayOfMonth(3);
// Returns a copy of the Instant object with the specified seconds but without changing the nanoseconds part
const i2 = i1.withFieldValue(ChronoField.INSTANT_SECONDS, 923232434);</pre>
<p>或者您可以使用<code>at*</code>方法来组合不同类型的两个实例:</p>
<pre>// Combines a LocalDate and a LocalTime object to create a new LocalDateTime
const ldt2 = ld1.atTime(lt1);
// Combines a LocalDateTime object and a time zone to create a ZonedDateTime object
const zdt2 = ldt1.atZone(ZoneId.of("+04:00"));</pre>
<p>类似地，查询和检查条件的方法从<code>is</code>开始:</p>
<pre>console.log(ld1.isLeapYear());
console.log(ldt1.isBefore(ldt2));</pre>
<p>并且有<code>plus</code>和<code>minus</code>方法来操作对象的日期/时间信息:</p>
<pre>// Add 10 minutes: 10:11:00.123456789
const lt2 = lt1.plusMinutes(10);
// Add a duration
const ldt3 = ldt1.plus(d1);
// Subtract one hour: 09:01:00.123456789
const lt3 = lt1.minus(1, ChronoUnit.HOURS);
// Substract a period
const zdt3 = zdt1.minusAmount(p1);</pre>
<p>关于日期格式，js-joda没有moment.js那么多选项，但是它有一组用于定制格式的<a href="https://js-joda.github.io/js-joda/manual/formatting.html" target="_blank" rel="noopener noreferrer">模式字符串</a>(与Java 中使用的<a href="https://docs.oracle.com/en/java/javase/15/docs/api/java.base/java/text/SimpleDateFormat.html">模式相同)。以下是一些例子:</a></p>
<pre>// 10:00
console.log(lt2.format(DateTimeFormatter.ofPattern("h:m")));
// 2019, 1
console.log(zdt3.format(DateTimeFormatter.ofPattern("y, Q")));</pre>
<p>然而，如果您的模式包含文本，您将不得不使用一个地区。</p>
<p>为此，将包<code>@js-joda/timezone</code>和<code>@js-joda/locale</code>一起导入，以导入所有的语言环境，或者一个单独的语言环境包(例如<code>@js-joda/locale_de</code>):</p>
<pre>import "@js-joda/timezone";
import { Locale } from "@js-joda/locale_de";

// ...

// Formatting text with the DE locate: Okt. 1 2:52 PM
console.log(
  ldt3.format(
    DateTimeFormatter.ofPattern("MMM d h:m a").withLocale(Locale.GERMAN)
  )
);</pre>
<p>你可以试试<a href="https://codesandbox.io/s/js-joda-example-88s9u" target="_blank" rel="noopener noreferrer">这个沙盒</a>里的所有例子。</p>
<h2>糖</h2>
<p>Sugar 是一个库，它提供了许多实用函数来处理数组、数字、对象、日期以及其他类型。</p>
<p>该库包含许多模块和聚合填充，总大小约为38k gzip。但是，如果您不打算使用完整的功能集，您有三种选择:</p>

<p>糖有三种使用方式:</p>
<ul>
<li>Default，使用<code>Sugar</code>全局对象，组织成与扩展本地类的模块相对应的名称空间。直接在对象上调用这些方法。例如，<code>Sugar.Date.create("2020-01-01")</code></li>
<li>Chainable，它使用Sugar名称空间作为构造函数来构建一个实例。例如，<code>new Sugar.Date("2020-01-01").isLeapYear().raw</code></li>
<li>扩展，将方法直接映射到本机类型:</li>
</ul>
<pre>Sugar.Date.extend();
console.log(new Date().isLeapYear());</pre>
<p>这里我将使用默认模式。</p>
<p>要创建一个实例，使用<code>create()</code>方法传递各种<a href="https://sugarjs.com/docs/#/DateParsing" target="_blank" rel="noopener noreferrer">格式</a>，其中许多是非传统格式:</p>
<pre>const d1 = Sugar.Date.create("last month");
const d2 = Sugar.Date.create("in 2 hours");
const d3 = Sugar.Date.create("20th of May");
const d4 = Sugar.Date.create("13 Jan 2014 11:00:00 CST");
const d5 = Sugar.Date.create("the 2nd Friday of October 2009");
const d6 = Sugar.Date.create("6-2017"); // months are zero-based, this is actually May, 2017
const d7 = Sugar.Date.create("5 minutes ago");</pre>
<p>你可以在库的<a href="https://github.com/andrewplummer/Sugar/blob/3ca57818332473b601434001ac1445552d7753ff/test/tests/date.js#L217" target="_blank" rel="noopener noreferrer">单元测试中看到很多如何创建日期的例子。</a></p>
<p>一旦创建了Sugar实例，就可以使用<code>set</code>方法对日期进行<a href="https://sugarjs.com/dates/#/Manipulating" target="_blank" rel="noopener noreferrer">操作，该方法还接受一个布尔参数来重置比传递的单位更具体的单位(记住月份是从零开始的):</a></p>
<pre>// Sets month to January
Sugar.Date.set(d1, { month: 0 });
// Sets day to 10 and reset hours to midnight
Sugar.Date.set(d2, { day: 10 }, true);</pre>
<p>在Sugar中，并不是所有的方法都是不可变的。在这里你可以找到改变日期对象的方法列表。</p>
<p>还有向前和向后移动日期的方法(分别为<code>advance()</code>和<code>rewind()</code>)，添加单个时间单位的方法<code>add*()</code>以及将日期移动到时间单位的开始或结束位置的方法(分别为<code>beginningOf*()</code>和<code>endOf*()</code>):</p>
<pre>// Shifts the date forward one month
Sugar.Date.advance(d3, { months: 1 }); // Keys can be singular too: month
// Shifts the date backwards 2 hours
Sugar.Date.rewind(d4, { hours: 2 });
// Adds 1 month
Sugar.Date.addMonths(d5, 1);
// Sets the date to Jan 1st at midgnight of the same year
Sugar.Date.beginningOfYear(d6);
// Sets the time to 11:59:59
Sugar.Date.endOfDay(d7);</pre>
<p>以<code>is</code>开头的方法允许我们比较或测试日期:</p>
<pre>// Is the year of d1 2020?
Sugar.Date.is(d1, '2020');
// Is d1 before January 2nd, 2020?
Sugar.Date.isBefore(d1, 'January 2nd, 2020');
// Is d1 after December 2018?
Sugar.Date.isAfter(d1, 'December 2018');
// Is d1 Friday?
Sugar.Date.isFriday(d1);
// Is d1 a date in the future?
Sugar.Date.isFuture(d1);
// Is d1 a weekday?
Sugar.Date.isWeekday(d1);</pre>
<p>Sugar还提供了一种方法，通过方法<code>*Since</code>、<code>*Ago</code>、<code>*Until</code>和<code>*FromNow</code>获得许多单位的时差:</p>
<pre>// How many months have passed since d4?
Sugar.Date.monthsSince(d4);
// How many years have passed between d4 and d5?
Sugar.Date.yearsSince(d4, d5);
// How many days ago was d4)
Sugar.Date.daysAgo(d4);
// How many hours aga from d5 was d4?
Sugar.Date.hoursAgo(d5, d4);
// How many weeks from d4 until now?
Sugar.Date.weeksUntil(d4);
// How many seconds until d5 from d4?
Sugar.Date.secondsUntil(d5, d4);
// How many ms from now to d4)
Sugar.Date.millisecondsFromNow(d4);</pre>
<p>但是我最喜欢Sugar的是它为格式化T2提供的所有选项。<code>format</code>方法支持两种类型的令牌，<a href="http://unicode.org/reports/tr35/tr35-6.html" target="_blank" rel="noopener noreferrer"> LDML、</a>和<a href="http://man7.org/linux/man-pages/man3/strftime.3.html" target="_blank" rel="noopener noreferrer"> strftime </a>。</p>
<p>LDML，这是一种既简短又容易记忆的格式(在此搜索标记列表<a href="https://sugarjs.com/dates/#/Formatting" target="_blank" rel="noopener noreferrer">):</a></p>
<pre>Sugar.Date.format(d3, "{Weekday}, {hours}:{mm}:{ss}{TT}"); // e.g. Saturday, 12:00:00AM</pre>
<p>以及strftime，用于其他编程语言，如<a href="https://www.programiz.com/python-programming/datetime/strftime" target="_blank" rel="noopener noreferrer"> Python </a>(此处搜索令牌列表<a href="https://sugarjs.com/dates/#/Formatting" target="_blank" rel="noopener noreferrer"/>):</p>
<pre>Sugar.Date.format(d3, "{Weekday}, {hours}:{mm}:{ss}{TT}"); // e.g. Saturday, 12:00:00AM</pre>
<p>此外，还有四种预定义的格式模式(<code>short</code>、<code>medium</code>、<code>long</code>和<code>full</code>):</p>
<pre>Sugar.Date.short(d6); // 01/01/2017
Sugar.Date.medium(d6); // January 1, 2017
Sugar.Date.long(d6); // January 1, 2017 12:00 AM
Sugar.Date.full(d6); // Sunday, January 1, 2017 12:00 AM</pre>
<p>以及自动选择最合适单位的两种相对时间方法(<code>relative</code>和<code>relativeTo</code>):</p>
<pre>Sugar.Date.relative(d2); // 2 weeks ago
Sugar.Date.relativeTo(d2, d5); // 10 years</pre>
<p>英语是自动包含的默认区域设置。在撰写本文时，Sugar支持<a href="https://github.com/andrewplummer/Sugar#date-locales" target="_blank" rel="noopener noreferrer"> 17个地区</a>，这些地区<a href="https://sugarjs.com/docs/#/DateLocales" target="_blank" rel="noopener noreferrer">包含在官方版本中，或者通过<a href="https://sugarjs.com/download/" target="_blank" rel="noopener noreferrer">下载</a>页面单独添加</a>。</p>
<p>区域设置可以用<code>setLocale</code>方法全局设置，或者作为参数传递给依赖于区域设置的方法，如<code>isLastWeek</code>(这样它就可以知道一周的开始)、<code>create()</code>或<code>relative()</code>:</p>
<pre>import "sugar-date/locales";

// Sets the locale to italian globaly
// Sugar.Date.setLocale("it");

// Parse the string with the spanish locale
const d8 = Sugar.Date.create("hace 5 dias", "es");

// Uses the default locale, english (or the one set with setLocale)
// It doesn't use the locale used to create the instance
Sugar.Date.full(d8);

// Uses the french locale
Sugar.Date.full(d8, "fr");</pre>
<p>你可以试试<a href="https://codesandbox.io/s/sugar-example-0btlf" target="_blank" rel="noopener noreferrer">这个沙盒</a>里的所有例子。</p>
<h2>时空</h2>
<p><a href="http://spacetime.how/" target="_blank" rel="noopener noreferrer"> Spacetime </a>是一个解析、操作、比较和格式化日期的库，特别关注<a href="https://github.com/spencermountain/spacetime/wiki/How-it-works" target="_blank" rel="noopener noreferrer">时区和夏令时(DST) </a>，以避免在使用不同DST规则的时区中操作时间时出现错误。</p>
<p>你必须注意一些<a href="https://github.com/spencermountain/spacetime#limitations--caveats" target="_blank" rel="noopener noreferrer">考虑事项</a>，然而，spacetime有一个与Moment.js非常相似的API(有一些很好的补充)，区别在于它的所有方法都是不可变的。</p>
<p>例如，可以使用多种输入格式和一些辅助方法创建时空实例:</p>
<pre>/ ISO Format
const s1 = spacetime("2020-12-01");
// As long date
const s2 = spacetime("Dec 02 2020 17:50");
// As epoch in ms
const s3 = spacetime(1606975200000);
// As an array (months are zero-based)
const s4 = spacetime([2020, 0, 1, 20, 0]);
// As an object (months are zero-based)
const s5 = spacetime({year:2020, month:0, date:1});
// Current time
const s6 = spacetime.now();
// Today at midgnight
const s7 = spacetime.today();
// Tomorrow at midnight
const s8 = spacetime.tomorrow();</pre>
<p>Getters和setters的处理方式与Moment.js相同，只是增加了一些有用的功能，如<code>season()</code>、<code>hourFloat()</code>和<code>progress()</code>:</p>
<pre>// Sets a new date based on s1 with 400 milliseconds
const s9 = s1.millisecond(400);
// Get milliseconds: 400
console.log("s9.milliseconds(): " + s9.millisecond());
// Get month (zero-based): 11
console.log("s9.month(): " + s9.month());
// Get day of year: 336
console.log("s9.dayOfYear(): " + s9.dayOfYear());
// Get day of year: winter
console.log("s9.season(): " + s9.season());
// Set the hour + minute in decimal form
const s10 = s2.hourFloat(16.5);
// Get the time: 4:30pm
console.log("s10.time(): " + s10.time());
// How far the moment lands between the start and end of the day/week/month/year (percentage-based)
console.log("s3.progress('year'): " + s3.progress('year'));</pre>
<p>查询或比较方法也是如此:</p>
<pre>// s3: 2020-12-03
// s4: 2020-01-01
console.log("s3.isAfter(s4): " + s3.isAfter(s4));
console.log("s3.isBefore(s4): " + s3.isBefore(s4));
console.log("s3.isEqual(s4): " + s3.isEqual(s4));
console.log("s3.leapYear(): " + s3.leapYear());
// Detect if two date/times are the same day, week, or year, etc
console.log("s3.isSame(s4, 'year'): " + s3.isSame(s4, "year"));
// Given a date amd a unit, count how many of them you'd need to make the dates equal
console.log("s3.diff(s4, 'day'): " + s3.diff(s4, "day"));
// Is daylight-savings-time activated right now, for this timezone?
console.log("s3.inDST(): " + s3.inDST());
// Does this timezone ever use daylight-savings?
console.log("s3.hasDST(): " + s3.hasDST());
// The current, DST-aware time-difference from UTC, in hours
console.log("s3.offset(): " + s3.offset());
// Checks if the current time is between 10pm and 8am
console.log("s3.isAsleep(): " + s3.isAsleep());</pre>
<p>以及操作方法:</p>
<pre>// s5: 2020-01-10 1:31pm
// Move to the first millisecond of the day, week, month, year, etc.
const s11 = s5.startOf('month'); // 2020-01-01 12:00am
// Move to the last millisecond of the day, week, month, year, etc.
const s12 = s5.endOf('week'); // 2020-01-12 11:59pm
// Increment the date/time by a number and unit
const s13 = s5.add(1, 'season') // 2020-05-10 1:31pm
// Decrease the date/time by a number and unit
const s14 = s5. subtract(2, 'years') // 2018-01-10 1:31pm
// Move forward/backward to the closest unit
const s15 = s5.nearest('hour'); // 2020-01-10 2:00pm
// Go to the beginning of the next unit
const s16 = s5.next('quarter'); // 2020-01-04 12:00am
// Go to the beginning of the previous unit
const s17 = s5.last('month'); // 2019-12-01 12:00am</pre>
<p>为了格式化日期和时间，Spacetime有一些预定义的<a href="https://github.com/spencermountain/spacetime/wiki/Formatting" target="_blank" rel="noopener noreferrer">格式</a>:</p>
<pre>s11.format('numeric-uk') // 01/01/2020
s12.format('iso-utc') // 2020-01-13T05:59:59.999Z
s13.format('mm/dd') // 05/10
s14.format('nice') // Jan 10th, 1:31pm  
s15.format('quarter') // Q1     
// They can be combined using this syntax
s16.format('{day} {date-ordinal}, {month-short} {year}')); // Sunday 1st, Dec 2019</pre>
<p>但是您也可以使用更标准的<a href="http://unicode.org/reports/tr35/tr35-25.html#Date_Format_Patterns" target="_blank" rel="noopener noreferrer">日期格式模式</a>:</p>
<pre>s17.unixFmt('yyyy/MM/dd h a')); // 2019/12/01 12 AM</pre>
<p>或相对时间的<code>since()</code>功能。例如，当您执行:</p>
<pre>spacetime('September 1 2020').since('September 30 2020')</pre>
<p>它将返回以下对象:</p>
<pre>{
   "diff": {
      "years": 0,
      "months": 0,
      "days": -29,
      "hours": 0,
      "minutes": 0,
      "seconds": 0
   },
   "rounded": "in 29 days",
   "qualified": "in 29 days",
   "precise": "in 29 days"
}</pre>
<p>关于时区，当你创建一个实例时，你可以传递一个额外的参数来指定时区(建议使用<a href="https://en.wikipedia.org/wiki/List_of_tz_database_time_zones" target="_blank" rel="noopener noreferrer"> IANA名</a>):</p>
<pre>const s18 = spacetime(1601521200000, "Europe/Paris");
const s19 = spacetime([2020, 0, 1, 20, 0], "Lima"); // America/Lima
const s20 = spacetime.now("-4h");</pre>
<p>但是一旦你有了一个实例，你也可以很容易地用<code>goto()</code>把它改成另一个时区(再次建议使用<a href="https://en.wikipedia.org/wiki/List_of_tz_database_time_zones" target="_blank" rel="noopener noreferrer"> IANA名字</a>):</p>
<pre>const s21 = s18.goto("Australia/Sydney"); // Oct 1 2020, 1:00pm
const s22 = s18.goto("GMT-5"); //-5 is actually +5</pre>
<p>此外，您可以获得一个数组，其中包含以您的本地时间为参考的一个小时范围内的所有时区:</p>
<pre>spacetime.whereIts('12:00pm', '2:00pm') // ["asia/seoul", "asia/tokyo", "pacific/palau", "australia/adelaide", ...]
spacetime.whereIts('10am') // Within an hour, from 10am to 11am</pre>
<p>并获取实例时区的元数据:</p>
<pre>s21.timezone();
/* Returns:
{
   "name": "Australia/Sydney",
   "hasDst": true,
   "default_offset": 10,
   "hemisphere": "South",
   "current": {
      "offset": 10,
      "isDST": false
   },
   "change": {
      "start": "04/05:03",
      "back": "10/04:02"
   }
}
*/</pre>
<p>你可以尝试这个<a href="https://codesandbox.io/s/spacetime-example-xnqg3" target="_blank" rel="noopener noreferrer">沙盒</a>中的所有例子。</p>
<h2>Intl.RelativeTimeFormat</h2>
<p>Moment.js最有用的特性之一是将日期显示为相对时间的能力:</p>
<pre>const start = moment('2020-12-01');
const end   = moment('2020-12-04');
start.to(end); // "in 3 days"
start.to(end, true); // "3 days"</pre>
<p>不是所有的库都提供这个功能，但是现在大多数浏览器都完全支持<code>Intl.RelativeTimeFormat</code>和<a href="https://caniuse.com/?search=Intl.RelativeTimeFormat" target="_blank" rel="noopener noreferrer">，这不再是个问题了。</a></p>
<p><code>Intl.RelativeTimeFormat</code>是一个标准的内置对象，允许您以本地化的方式将数字格式化为相对时间。</p>
<p>构造函数可选地接受两个参数，一个是<a href="https://www.techonthenet.com/js/language_tags.php" target="_blank" rel="noopener noreferrer"> BCP 47语言标签</a>(或者一个这样的字符串数组)，另一个是带有属性的对象，用于配置区域匹配算法、格式和输出消息的长度:</p>
<pre>const rtf = new Intl.RelativeTimeFormat("es", {
    localeMatcher: "best fit",
    numeric: "auto",
    style: "short"
});</pre>
<p>一旦有了这个对象的实例，就可以使用<code>format()</code>方法传递要在消息中使用的数值作为第一个参数，单位(如天或小时，单数或复数形式)作为第二个参数:</p>
<pre>rtf.format(-4, 'second'); // hace 4 s
rtf.format(-1, 'week'); // la semana pasada
rtf.format(3, 'quarter'); // dentro de 3 trim.
rtf.format(2, 'year'); // dentro de 2 a</pre>
<p>或者<code>formatToParts()</code>获得一个数组，其中消息的各个部分被分开:</p>
<pre>rtf.formatToParts(-4, 'second');
/* Returns:
[
   {
      "type": "literal",
      "value": "hace "
   },
   {
      "type": "integer",
      "value": "4",
      "unit": "second"
   },
   {
      "type": "literal",
      "value": " s"
   }
]
**/
</pre>
<p>如果你想知道如何得到数字部分，换句话说，就是两个日期之间经过的时间，看看这个StackOverflow答案,它共享下面的函数:</p>
<pre>// in miliseconds
var units = {
  year  : 24 * 60 * 60 * 1000 * 365,
  month : 24 * 60 * 60 * 1000 * 365/12,
  day   : 24 * 60 * 60 * 1000,
  hour  : 60 * 60 * 1000,
  minute: 60 * 1000,
  second: 1000
};

var rtf = new Intl.RelativeTimeFormat('en', { numeric: 'auto' });

var getRelativeTime = (d1, d2 = new Date()) =&gt; {
  var elapsed = d1 - d2;
  // "Math.abs" accounts for both "past" &amp; "future" scenarios
  for (var u in units)
    if (Math.abs(elapsed) &gt; units[u] || u == 'second')
      return rtf.format(Math.round(elapsed/units[u]), u);
}</pre>
<p>你可以试试<a href="https://codesandbox.io/s/intl-relativetimeformat-example-8ie8z" target="_blank" rel="noopener noreferrer">这个沙盒</a>里的所有例子。</p>
<h2>结论</h2>
<p>毫无疑问，Moment.js有很多替代品。在本文中，我们回顾了三个提供类似功能的库，并在某些情况下增加了一些有用的功能。</p>
<p>在我看来，这些库中的每一个都在不同的用例中表现得更好:</p>
<ul>
<li>js-joda 作为一个通用库非常有用，特别是如果你有Java背景的话</li>
<li>Sugar 特别适合格式化日期，而且由于它为<a href="https://sugarjs.com/docs/" target="_blank" rel="noopener noreferrer">提供了许多除日期</a>之外的其他类型的方法，它对应用程序的其他部分也很有用</li>
<li>由于Spacetime计算远程时间的方式和在时区之间转换的方法，Spacetime 特别适用于必须支持多个时区的情况。</li>
</ul>
<p>此外，现在浏览器对<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl" target="_blank" rel="noopener noreferrer"> JavaScript国际化API </a>的支持更加广泛，考虑一下轻量级库和本地特性的结合，或者甚至你需要一个外部库。</p>
<p>编码快乐！</p><div class="code-block code-block-28">
<div class="blog-plug inline-plug js-libraries-plug"><h2>您是否添加了新的JS库来提高性能或构建新特性？如果他们反其道而行之呢？</h2><p>毫无疑问，前端变得越来越复杂。当您向应用程序添加新的JavaScript库和其他依赖项时，您将需要更多的可见性，以确保您的用户不会遇到未知的问题。</p>
<p>LogRocket 是一个前端应用程序监控解决方案，可以让您回放JavaScript错误，就像它们发生在您自己的浏览器中一样，这样您就可以更有效地对错误做出反应。</p><a class="signup" href="https://lp.logrocket.com/blg/javascript-signup" target="_blank" rel="noopener noreferrer"><img class="alignnone size-full wp-image-46 jetpack-lazy-image" src="../Images/e8a0ab42befa3b3b1ae08c1439527dc6.png" alt="LogRocket Dashboard Free Trial Banner" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2019/10/errors-screenshot.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/10/errors-screenshot.png"/><noscript><img data-lazy-fallback="1" class="alignnone size-full wp-image-46" src="../Images/e8a0ab42befa3b3b1ae08c1439527dc6.png" alt="LogRocket Dashboard Free Trial Banner" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/10/errors-screenshot.png"/></noscript></a>
<a href="https://lp.logrocket.com/blg/javascript-signup" target="_blank" rel="noopener noreferrer">https://logrocket.com/signup/</a><p><a href="https://lp.logrocket.com/blg/javascript-signup" target="_blank" rel="noopener noreferrer"> LogRocket </a>可以与任何应用程序完美配合，不管是什么框架，并且有插件可以记录来自Redux、Vuex和@ngrx/store的额外上下文。您可以汇总并报告问题发生时应用程序的状态，而不是猜测问题发生的原因。LogRocket还可以监控应用的性能，报告客户端CPU负载、客户端内存使用等指标。</p><p>自信地构建— <a class="signup" href="https://lp.logrocket.com/blg/javascript-signup" target="_blank" rel="noopener noreferrer">开始免费监控</a>。</p></div>


</div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
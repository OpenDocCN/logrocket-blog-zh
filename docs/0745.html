<html>
<head>
<title>Snowpack vs. webpack: A build tool comparison - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>Snowpack与webpack:构建工具比较</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/snowpack-vs-webpack-build-tool-comparison/#0001-01-01">https://blog.logrocket.com/snowpack-vs-webpack-build-tool-comparison/#0001-01-01</a></blockquote><div><article class="article-post">
<p><em> <strong>编者按:</strong>这篇文章于2022年3月14日更新，包含了与Snowpack v3和webpack v5相关的信息。</em></p>
<p>很少有工具像webpack一样对JavaScript生态系统如此重要。JavaScript模块bundler于2012年推出，是现代JavaScript的基石和工程壮举。如果没有webpack带来的想法，JS生态系统就不会有今天。<a href="https://www.snowpack.dev" target="_blank" rel="noopener"> Snowpack </a>于2019年推出，作为现代JavaScript应用的下一代构建工具。它允许开发人员编写最新的ESNext JavaScript，无需配置，工具更简单，构建速度极快。</p>
<p>在没有从webpack在推动JS开发工具生态系统方面的遗产和影响中带走任何东西的情况下，许多开发人员问“Snowpack能取代webpack吗？”就不足为奇了承认这两种工具出现在JavaScript发展的不同时期是很重要的。webpack是在ES模块(ESM)存在之前推出的，Snowpack是在现代浏览器支持ESM和ESNext的时候推出的。</p>
<p>那么，考虑到所有这些，并从今天的生态系统的角度来看，Snowpack和webpack的表现如何呢？从一个切换到另一个有多容易？本文将尝试通过详细比较这两种工具的特性和优点来解决所有这些问题。我们还将分享一个开始使用Snowpack的指南。我们开始吧！</p>
<p>目录</p>

<p>在这里听我们关于Snowpack和webpack的播客。</p>
<p> </p>
<p> </p>
<p><strong>先决条件</strong></p>
<h2 id="prerequisites">对于本文的演示部分，您需要以下内容:</h2>
<p>用<a href="https://www.pika.dev/" target="_blank" rel="noopener"> ESM就绪代码</a>编写的JavaScript应用</p>
<ul>
<li>支持ES模块语法的现代浏览器，比如最近发布的Chrome、Firefox或Edge</li>
<li><strong> <em> N.B. </em> </strong>，现代浏览器的要求只适用于开发环境。一旦你用Snowpack创建了最终版本并将其推向生产，用户可以在任何现代或传统浏览器中查看你的站点。更多细节可以在<a href="https://www.snowpack.dev/concepts/build-pipeline#legacy-browser-support" target="_blank" rel="noopener">这里</a>找到。</li>
</ul>
<p>Snowpack是如何工作的？</p>
<h2 id="how-does-snowpack-work">Snowpack使用JavaScript的es模块系统，将文件更改直接即时写入浏览器，无需等待时间。与webpack这样的捆绑器不同，Snowpack只需构建一次文件，然后缓存文件。它只需要在发生更改时重建一个文件，并且重建只针对该单个文件。这被称为<a href="https://www.snowpack.dev/concepts/how-snowpack-works#unbundled-development" target="_blank" rel="noopener">非捆绑开发</a>，与webpack和旧的构建工具中的传统捆绑开发相反。稍后会有更多的细节。</h2>
<p>webpack是如何工作的？</p>
<h2 id="how-does-webpack-work">webpack是一个模块捆绑器，它获取大量的JavaScript文件，并将其转换为一个输出文件或几个较小的文件，您可以使用这些文件来运行您的应用程序。</h2>
<p>webpack创建一个依赖图来管理模块之间的依赖关系。随着加载器的加入，该工具还可以捆绑除JavaScript之外的其他文件类型，如CSS、PNG、JPG等等。这有效地允许您将所有静态资产——连同您的JavaScript——添加到依赖关系图中，这节省了您手动管理每个依赖关系的额外工作。</p>
<p>配置和学习曲线</p>
<h2 id="configuration-and-learning-curve">众所周知，webpack很难配置，尤其是对于初学者。但同样重要的是要记住，webpack能够做非常大、非常强大的东西，因此使用所有这些功能需要一些配置和知识是有道理的。尽管如此，即使在今天，也没有简单的命令来设置一个“简单”的webpack，它仍然需要很高的学习曲线，并理解它对大多数人的作用。</h2>
<p>相比之下，Snowpack不需要对大多数JavaScript应用进行任何配置。使用<a href="https://www.snowpack.dev/#automatic-installs-(recommended)" target="_blank" rel="noopener"> include </a>标志，您只需告诉它扫描您的哪些文件中的导入，如下所示:</p>
<p>就是这样！假设您的JavaScript文件都是有效的ESNext(即没有JSX或特殊语法)，它将安装您的所有依赖项，您可以将代码直接发送到浏览器/产品。但是关于ES模块的话题，你可能没有意识到大多数开发人员编写的导入并没有严格遵循ESM规范。</p>
<pre class="language-javascript hljs">npx snowpack --include './src/**.js'
</pre>
<p>让我们看看如何编写有效的ESM导入:</p>
<p>虽然大多数开发人员写的是<code>react</code>，而不是<code>react.js</code>，但是如果没有文件扩展名，浏览器就无法理解它，因为它不是一个有效的URL。Snowpack允许你将npm包捆绑成单个文件，所以它可以生成浏览器可以理解的扩展的<code>react.js</code>。虽然这可能是您的代码库的一个变化，幸运的是，它可以像几个查找并替换命令一样简单(例如，用<code>'/web_modules/react.js'</code>替换<code>'react'</code>)。</p>
<pre class="language-javascript hljs">-import React from 'react'; // 🚫 invalid ESM
+import React from '/web_modules/react.js'; // ✅ valid ESM
</pre>
<p>当谈到替代语法时，如<code>.jsx</code>、<code>.vue</code>或<code>.svelte</code>，Snowpack有一些<a href="https://github.com/pikapkg/snowpack-init">入门项目</a>，可以帮助你在那里开始运行。根据设置的不同，这可能意味着与webpack相同的配置级别，或者稍低一点！但是使用Snowpack很少会导致更多的管理。</p>
<p><strong>优势:🗻积雪场</strong></p>
<p>如果您在想“等等ESM导入可以在任何URL进行吗？哪怕是远程的？”那你就有大发现了！ESM可以使用远程URL，我们将在下面的使用CDN部分回到这一点。</p>
<blockquote><p>建筑开发</p></blockquote>
<h2 id="bundling-development">说到捆绑，Snowpack可以帮助构建处理，而不需要复杂的配置步骤。有了Snowpack，我们只需要构建每个文件一次，然后文件就永远被缓存了。这意味着Snowpack只在我们监视的文件发生全局变化时才重建单个文件。这不同于我们习惯于使用的旧捆绑工具，如webpack和<a href="https://parceljs.org" target="_blank" rel="noopener"> Parcel </a>，当单个文件发生变化时，它们会重建所有文件。</h2>
<p>本质上，Snowpack支持“非捆绑开发”流程，在开发模式下，只有被更改或更新的单个文件被发送到生产环境中。这都是因为ESM导入和导出语法。与其他构建工具不同，它们专注于“捆绑开发”。这意味着，我们所做的每一项更改都必须与应用程序中未更改的部分捆绑在一起，然后才能在浏览器中反映出来。</p>
<p><strong>优势:🗻积雪场</strong></p>
<p>构建时间</p>
<h2 id="build-time">webpack是一个转换代码的捆绑器。Snowpack是一个安装时工具，不做任何事情。webpack的捆绑能力虽然令人印象深刻，但也是有代价的，这意味着每次点击save ( <a href="https://medium.com/onfido-tech/speed-up-webpack-ff53c494b89c" target="_blank" rel="noopener">时都要等待JavaScript代码，而在大型应用程序上，这可能需要一分多钟来构建</a>！😱).</h2>
<p>直接为浏览器编写ES模块意味着无需等待，并且可以立即预览您的代码。webpack在每次保存时运行，而Snowpack只在安装新的npm包时运行。</p>
<p>更糟糕的是:通过捆绑，等待代码生成的时间与应用程序的大小成线性比例。也就是说，app越大，等待的时间越长。但是有了Snowpack，不管你的应用程序代码有多大，没有构建时间就意味着没有构建时间。乍看起来，节省几毫秒的时间似乎不多，但经过每天数百次的过程，几年后，这可能会成为你生命中的几个小时！</p>
<p><strong>优势:🗻积雪场</strong></p>
<p>贮藏</p>
<h2 id="caching">今天的大多数JavaScript应用程序都有2MB或更多的JS。让用户下载并执行那么多的JS会让用户<a href="https://v8.dev/blog/cost-of-javascript-2019" target="_blank" rel="noopener">的交互延迟很多秒</a>。因此，如果这对于第一次访问是不可避免的，至少，用户在以后的访问中应该避免这种情况。webpack的缓存策略围绕着<a href="https://webpack.js.org/guides/code-splitting/" target="_blank" rel="noopener">如何拆分代码</a>，或者不拆分。更改一行代码或一个依赖项将导致用户通过互联网重新下载大部分或全部代码。虽然您的webpack代码分割设置可以帮助减少这种情况，但在大多数情况下，它会导致用户重新下载比更改或更新的代码更多的代码。</h2>
<p>但是webpack还有一个更大的危险等待着我们——重复代码！当您开始拆分您的包时，如果您没有使用<a href="https://github.com/webpack-contrib/webpack-bundle-analyzer" target="_blank" rel="noopener"> webpack-bundle-analyzer </a>仔细分析它的所有内容，您很可能会有重复的代码。因此，如果用户访问你的应用程序，他们可能不仅会下载大量的JS，还可能会多次下载！</p>
<p><img decoding="async" src="../Images/935845cdf832ed3bc8393dbae68c51d4.png" alt="Caching." data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2020/03/caching.jpg?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" class=" jetpack-lazy-image" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/03/caching.jpg"/></p>
<p>Snowpack + ES模块遵循不同的策略。您没有捆绑任何东西，而是选择向浏览器显示ESM导入树。因为浏览器了解你的应用程序结构，它可以有效地直接获取它需要的东西，并且只获取它需要的东西。浏览器完成所有的工作，不需要你投入任何时间。此外，复制代码或依赖项是不可能的。</p><noscript><img data-lazy-fallback="1" decoding="async" src="../Images/935845cdf832ed3bc8393dbae68c51d4.png" alt="Caching." data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/03/caching.jpg"/></noscript>
<p>因此，当使用Snowpack + ESM时，如果您更改了代码或npm依赖项，访问您站点的用户只需下载发生更改的确切文件和依赖项，仅此而已。如果<code>react</code>的版本改变了，用户下载<code>react</code>的新版本和它从缓存中取出的所有东西。说到缓存，Snowpack真的大放异彩——在这方面，它几乎是<em>的完美之作。</em></p>
<p><strong>优势:🗻积雪场</strong></p>
<p>webpack的核心专长是捆绑，因此从设计上来说，它会尝试并组合任何代码和依赖项。很难配置webpack，因为一个更改的文件只会导致用户重新下载该文件。我之所以说“近乎完美”,是因为ESM还无法让你的应用程序代码“摇树”(详见“摇树”一节)。</p>
<blockquote><p>网络</p></blockquote>
<h2 id="network">如果你通读了这篇文章中的缓存部分，你可能会想到一个问题:webpack和Snowpack在网络性能方面有何不同？加载网络资产是这两种工具之间最复杂、最有趣、最微妙的比较之一。</h2>
<p>Snowpack的作者Fred K. Schott在<a href="https://dev.to/pika/a-future-without-webpack-ago" target="_blank" rel="noopener">一个没有网络包的未来</a>中更详细地谈到了这个主题。但是简单来说，Snowpack + ESM将导入树暴露给浏览器。这意味着浏览器下载并扫描一个<code>&lt;script&gt;</code>标签，然后在该文件中列出导入内容。然后，它扫描这些导入，以及这些导入的导入，直到到达“树”的最末端与webpack的捆绑相比，文件的爬行过程通常会导致更多的网络请求。但是要抓取的文件越多并不一定意味着速度越慢。</p>
<p>虽然减少你的请求数量看起来<a href="https://medium.com/webpack/webpack-http-2-7083ec3f3ce6" target="_blank" rel="noopener">像是捆绑</a>的一目了然的事情，而且，是的，捆绑文件几乎总是<a href="https://medium.com/@asyncmax/the-right-way-to-bundle-your-assets-for-faster-sites-over-http-2-437c37efe3ff" target="_blank" rel="noopener">提高每个单独文件的下载速度</a>，但现实是，现代JS应用程序的情况比网络请求的总和还要考虑更多的因素。其中包括:</p>
<p>你在应用中使用的异步语句越多，Snowpack和webpack的性能就越好，因为JS抓取是由你的应用决定的，而不是工具</p>
<ol>
<li>考虑到“使用CDNs”一节，你的应用程序利用CDNs越多，Snowpack和webpack的表现也越相似</li>
<li>如果使用积极获取资产的<a href="https://developers.google.com/web/fundamentals/primers/service-workers/" target="_blank" rel="noopener">服务工作者</a>,那么Snowpack和webpack也将表现类似，因为加载行为是由它决定的</li>
<li>让我们回顾一下，减少请求是webpack的亮点，但前提是您的应用程序包含对服务器上托管的其他模块的同步<code>import</code>语句。您提供的延迟加载代码越多，从远程CDN提供的模块越多，Snowpack和webpack在请求数量和整体网络速度方面的表现就越相似。</li>
</ol>
<p>更多来自LogRocket的精彩文章:</p><div class="code-block code-block-54">
<hr/>
<h3><strong>优势:📦webpack，但仅在初始无缓存加载时使用</strong></h3>

<hr/></div>
<p>使用cdn</p>
<h2 id="using-cdns">可以说，ESM最酷的特性是能够对远程模块使用<code>import</code>语句:</h2>
<p>这是巨大的！尽管成千上万的网站使用React，但大多数网站可能都有自己的版本，而不是使用CDN，这意味着当你浏览网页时，你可能已经下载了数百次相同版本的React，而且还在不断增加。尽管这不是网站的错——在2020年为npm依赖关系加载<code>&lt;script&gt;</code>标签是如此古老！它撤销了es模块给我们的所有工作。</p>
<pre class="language-javascript hljs">import preact from 'https://cdn.pika.dev/preact';

// ┳┻|
// ┻┳|_    Psst…
// ┳┻|•.•) this is a really
// ┳┻|⊂ﾉ   big deal
// ┻┳|
</pre>
<p>但有了ESM，你实际上可以从远程服务器加载模块——无论是像<a href="https://www.pika.dev/cdn" target="_blank" rel="noopener"> Pika </a>这样的CDN，还是你自己设置的普通CDN。</p>
<p>所以积雪场是明显的赢家，对吗？没那么快！虽然，是的，Snowpack确实支持远程模块开箱即用，但第三方<a href="https://github.com/ScriptedAlchemy/webpack-external-import" target="_blank" rel="noopener"> webpack插件</a>已经出现，允许您从其他webpack捆绑包导入外部包。不过现在已经集成到了<a href="https://webpack.js.org/blog/2020-10-10-webpack-5-release/" target="_blank" rel="noopener"> webpack v5版本</a>！想了解如何在webpack中原生导入远程URL，看看webpack的<a href="https://webpack.js.org/concepts/" target="_blank" rel="noopener">官方文档</a>。万岁，CDN！</p>
<p><strong>优势:👯‍♂️两个！</strong></p>
<p>树摇晃</p>
<h2 id="tree-shaking">如果你对这个术语不熟悉的话，抖动树是从你的应用程序中移除不用的代码的过程。比方说你安装并导入了<a href="https://bundlephobia.com/result?p=lodash@4.17.15" target="_blank" rel="noopener">重量级</a> <code>lodash</code>包到你的app里，但是最后没有使用。那不应该对你不利，对吗？有了摇树，你的应用就可以小到不能再小了。webpack实际上是摇树运动的典型代表。这是一个摇树怪兽，它为你做所有的事情，而不需要你配置任何东西。</h2>
<p>但是仅仅因为Snowpack是一个安装时工具并不意味着它不能动摇！当你运行<code>snowpack--optimize</code>，它可以<a href="https://www.snowpack.dev/#production-optimization" target="_blank" rel="noopener">树动摇你使用的依赖</a>。诚然，Snowpack不能动摇你的应用程序代码，但这也是因为它不接触你的应用程序代码。如果你的应用程序代码需要树抖动，你将不得不使用一个独立的工具Snowpack，由Rollup驱动。但是公平的评价是对每一个工具，两棵树都动摇了他们管理的所有代码。</p>
<p><strong>优势:👯‍♂️两个！</strong></p>
<p>灵活性</p>
<h2 id="flexibility">最后一个值得比较的是灵活性。当谈到Snowpack与webpack时，它们各自可以处理多少种不同的设置和应用类型？每一个给你多少控制独特的设置？</h2>
<p>虽然值得一提的是，Snowpack确实可以让你使用常见的设置，如<a href="https://github.com/pikapkg/snowpack-init" target="_blank" rel="noopener"> JSX +预动作</a>或<a href="https://github.com/jakedeichert/svelvet" target="_blank" rel="noopener">苗条</a>，但当谈到Snowpack时，有两件重要的事情需要考虑:</p>
<p>Snowpack需要<a href="https://www.pika.dev/registry" target="_blank" rel="noopener"> ESM就绪包</a>，这意味着你只能使用<a href="https://www.pika.dev/about/stats" target="_blank" rel="noopener">NPM包的一小部分</a></p>
<ol>
<li>尽管在本文中已经多次提到，Snowpack的设计不会触及你的应用程序代码；这要由你来配置</li>
<li>Snowpack旨在帮助您在不放弃npm包和JS生态系统的情况下，为浏览器编写ESM就绪代码。除此之外，就看你的了！</li>
</ol>
<p>如果你需要处理代码转换，翻译，缩小，等等。然后webpack就有了你需要的所有工具。</p>
<p>webpack不是唯一的工具——你可以单独使用Babel，或Rollup，或任何你需要的单独的东西，但当谈到“瑞士军刀”完整的包时，webpack是无与伦比的。尽管灵活性是一个模糊不清的术语，但是无论您需要什么，可能都有一个webpack插件可以满足您的需求。</p>
<p><strong>优势:📦网络包</strong></p>
<p>Snowpack比webpack好吗？</p>
<h2 id="is-snowpack-better-than-webpack">正如引言中所述，webpack和Snowpack问世相隔七年，webpack比它早了不少。两者都是在JavaScript历史的不同时期引入的。两者都试图解决引入时最普遍的问题。webpack想给JavaScript一个模块系统，集成包管理，捆绑。Snowpack希望清理工具，让浏览器在保持npm的同时处理JavaScript模块。同样，在比较它们时，不能低估webpack是一个里程碑式的成就，以及webpack在网络历史上是多么的基础(webpack甚至有一个<a href="https://en.wikipedia.org/wiki/Webpack" target="_blank" rel="noopener">维基百科页面</a>——有多少开源项目可以这样说呢？).</h2>
<p>也许你读到这篇文章的时候想知道“我应该用webpack还是Snowpack开始我的项目？”我会推荐Snowpack，但前提是你可以使用ESM就绪的软件包(你可以在<a href="https://pika.dev/registry" target="_blank" rel="noopener"> pika.dev </a>上搜索)。这是一个快速而轻松的过程，如果需要，您可以随时轻松地迁移到webpack。但是根据你的需要，你可能会发现上面的一个比较是你项目的核心，可能会给你任何一个方向的提示。</p>
<p><strong>开始使用Snowpack </strong></p>
<h2 id="get-started-with-snowpack">如果你决定在下一个JavaScript应用项目中尝试Snowpack，请跟随我们的指南。我们将引导您完成迁移开发环境的步骤，并使用Snowpack启动和运行您的应用。</h2>
<p>第一步。安装Snowpack <br/>使用以下安装命令安装带有npm或yarn的Snowpack。请注意，Snowpack的创建者建议尽可能在本地安装，而不是全局安装。</p>
<p>第二步。启动Snowpack命令行界面<br/>有三种方法可以在本地运行Snowpack CLI:</p>
<pre class="language-javascript hljs">id="globalinstallation"&gt;global installation
npm install -g snowpack

local installation per project
npm install --save-dev snowpack

local installation per project 
yarn add --dev snowpack
</pre>
<p>使用<code>root package.json</code>文件</p>
<ul>
<li>使用npm命令:<code>npx snowpack</code></li>
<li>使用纱线命令:<code>yarn snowpack</code></li>
<li>第三步。初始化应用程序<br/>创建一个新的应用程序项目，使用<a href="https://github.com/snowpackjs/snowpack/tree/master/create-snowpack-app" target="_blank" rel="noopener">创建Snowpack应用程序</a> (CSA)。使用CSA，您可以获得一个使用Snowpack的应用程序模板配置的新的初始化应用程序。Snowpack为React、Vue、Svelte和其他流行的框架提供了模板。</li>
</ul>
<p>下面是一个使用Snowpack模板进行React的初始化命令示例:</p>
<p>你也可以在<a href="https://www.snowpack.dev/#official-app-templates" target="_blank" rel="noopener"> Snowpack文档页面</a>上找到官方CSA模板列表。</p>
<pre class="language-javascript hljs">npx create-snowpack-app new-dir --template \[@snowpack/app-template-react\] [--use-yarn]</pre>
<p>第四步。将您现有的应用程序迁移到Snowpack <br/>使用您使用CSA模板创建的应用程序作为迁移您现有应用程序的起点。</p>
<p>Snowpack支持当今用于web开发的大多数技术，例如Babel、PostCSS、Create React App等等。很有可能，你的应用已经使用了这些支持的技术之一，所以迁移到Snowpack应该很容易。</p>
<p>事实上，如果您有一个现有的Create React App项目，您可以直接通过CSA运行它，而无需做任何更改。</p>
<p>要迁移应用程序，首先要使用您选择的CSA模板初始化一个新的应用程序项目(有关说明，请参见上一节)。接下来，复制现有应用程序站点的<code>src</code>和<code>public</code>目录中的所有文件。现在，启动您的开发服务器，使用以下命令在本地加载站点:<code>snowpack dev</code></p>
<p>现在是时候解决您可能遇到的任何问题了。如果你卡住了，查看<a href="https://www.snowpack.dev/#troubleshooting" target="_blank" rel="noopener">积雪文件</a>寻求帮助。</p>
<p>最后，当您准备好之后，使用:<code>snowpack build</code>命令构建您的生产站点。</p>
<p><strong>结论</strong></p>
<h2 id="conclusion">在本文中，我们比较了Snowpack和webpack JavaScript构建工具的特性和优势。我们还提供了一个逐步安装和运行Snowpack应用程序的指南。</h2>
<p>Snowpack让你在一个快如闪电的、非绑定的开发环境中工作，甚至让你的最终版本保持非绑定和可运行。在将应用推广到生产环境时，您还可以选择支持捆绑版本。你所要做的就是为你最喜欢的捆绑器添加正确的插件，或者甚至使用<a href="https://www.snowpack.dev/guides/plugins" target="_blank" rel="noopener"> Snowpack插件API </a>编写你自己的插件。</p>
<p>与webpack等传统打包工具相比，Snowpack具有以下优势:</p>
<p>更改会立即写入浏览器，无需等待重建</p>
<ul>
<li>无重复下载的高效缓存</li>
<li>由于Snowpack的ESM基础，能够从CDN服务器导入模块</li>
<li>简单易用的配置流程</li>
<li>简单学习曲线</li>
<li>请在评论中告诉我这个比较的结果，或者是否有你想看的其他比较！</li>
</ul>
<p>Let me know in the comments how this comparison stacked up, or if there are any other comparisons you’d like to see!</p>

<p class="clearfix"/>
 <p class="clearfix"/>
</article>

</div>    
</body>
</html>
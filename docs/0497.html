<html>
<head>
<title>Building a modal module for React with React-Router - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>用React-Router - LogRocket博客构建React的模态模块</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/building-a-modal-module-for-react-with-react-router/#0001-01-01">https://blog.logrocket.com/building-a-modal-module-for-react-with-react-router/#0001-01-01</a></blockquote><div><article class="article-post">
<p>模态对于在一个视图上显示另一个视图非常有用。</p>
<p>然而，当涉及到实现时，它们不仅仅是包装一切的绝对定位的<code>&lt;div&gt;</code>元素。尤其是当您需要动态URL、页面刷新或移动设备上的简单滚动交互时。</p>
<p>在本文中，我们将讨论模态的各个方面，并确定满足创建动态URL、页面刷新和其他特性的需求的解决方案。</p>
<p>在开始塑造模态组件之前，让我们从<strong> react-router </strong>包的一些基础开始。</p>
<p>我们将使用这个包中的四个组件:浏览器路由器、路由器、链路和交换机。</p>
<p>由于这不是一个<strong> react-router </strong>教程，我不会解释这些组件的作用。</p>
<p>然而，如果你想了解一些关于<strong>反应路由器</strong>的信息，你可以查看<a href="https://reacttraining.com/react-router/web/guides/quick-start" target="_blank" rel="noopener noreferrer">的这个</a>页面。</p>
<h3>基本路由</h3>
<p>首先，通过npm安装<code>react-router-dom</code>。</p>
<pre>npm install react-router-dom --save</pre>
<p>在应用程序的最顶层，使用<code>&lt;BrowserRouter/&gt;</code>组件包装应用程序。</p>
<pre>import { BrowserRouter } from "react-router-dom";

ReactDOM.render(
  &lt;BrowserRouter&gt;
    &lt;App /&gt;
  &lt;/BrowserRouter&gt;,
  document.getElementById('root')
);</pre>
<p>在<code>&lt;App/&gt;</code>中，您将需要指定路线，以便当其中一个——或者没有一个——匹配时，您可以呈现特定的视图。</p>
<p>假设我们有三个不同的组件要渲染:<code>&lt;Home/&gt;</code>、<code>&lt;About/&gt;</code>和<code>&lt;Contact/&gt;</code>。我们将创建一个导航菜单，它将始终显示在应用程序的顶部。</p>
<p>来自<code>react-router-dom</code>的<code>&lt;Link/&gt;</code>或<code>&lt;NavLink/&gt;</code>组件用于导航目的，而<code>&lt;NavLink/&gt;</code>具有当当前URL匹配时适用于特定样式的特殊功能。</p>
<p>就功能而言，你可以使用任何一个。</p>
<p>下面是导航菜单的基本结构，它相应地改变URL:</p>
<pre>render() {
  return (
    &lt;div className="app"&gt;
      &lt;div className="menu"&gt;
        &lt;Link className="link" to='/'&gt;Home&lt;/Link&gt;
        &lt;Link className="link" to='/about'&gt;About&lt;/Link&gt;
        &lt;Link className="link" to='/contact'&gt;Contact&lt;/Link&gt;
      &lt;/div&gt;
    &lt;/div&gt;
  );
}</pre>
<p>我们要做的下一件事是实现匹配URL并呈现特定组件的机制。</p>
<p><code>&lt;Switch/&gt;</code>呈现由它的<code>&lt;Route/&gt;</code>孩子指定的第一个匹配位置。当没有匹配时，返回最后一个<code>&lt;Route/&gt;</code>——通常是404页面。</p>
<pre>render() {
  return (
    &lt;div className="app"&gt;
      &lt;div className="menu"&gt;
        &lt;Link className="link" to='/'&gt;Home&lt;/Link&gt;
        &lt;Link className="link" to='/about'&gt;About&lt;/Link&gt;
        &lt;Link className="link" to='/contact'&gt;Contact&lt;/Link&gt;
      &lt;/div&gt;
      &lt;Switch&gt;
        &lt;Route exact path="/" component={Home} /&gt;
        &lt;Route exact path="/contact/" component={Contact} /&gt;
        &lt;Route exact path="/about" component={About} /&gt;
        &lt;Route&gt;{'404'}&lt;/Route&gt;
      &lt;/Switch&gt;
    &lt;/div&gt;
  );
}</pre>
<h3>创建模态组件</h3>
<p>到目前为止，我们已经实现了基本的路由结构。现在我们可以创建一个模态组件，并将其显示为一个覆盖图。</p>
<p>尽管有各种不同的方法来创建模态组件，我们将只讨论其中一种。</p>
<p>模态组件有一个跨越整个屏幕的包装元素——宽度和高度。</p>
<p>这个区域也作为一个<code>clickedOutside</code>探测器。那么实际的模态元素相对于该包装元素被定位。</p>
<p><img data-attachment-id="8531" data-permalink="https://blog.logrocket.com/building-a-modal-module-for-react-with-react-router/modal-router-element-nocdn/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2019/10/Modal-router-element-nocdn.png" data-orig-size="1582,542" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Modal-router-element-nocdn" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2019/10/Modal-router-element-nocdn-300x103.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2019/10/Modal-router-element-nocdn-1024x351.png" decoding="async" class="aligncenter wp-image-8531 jetpack-lazy-image" src="../Images/b7db27e2395036c00e9ea152d38fb51f.png" alt="An example of a modal router element." data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2019/10/Modal-router-element-nocdn.png 1582w, https://blog.logrocket.com/wp-content/uploads/2019/10/Modal-router-element-nocdn-300x103.png 300w, https://blog.logrocket.com/wp-content/uploads/2019/10/Modal-router-element-nocdn-768x263.png 768w, https://blog.logrocket.com/wp-content/uploads/2019/10/Modal-router-element-nocdn-1024x351.png 1024w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2019/10/Modal-router-element-nocdn.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/10/Modal-router-element-nocdn.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="8531" data-permalink="https://blog.logrocket.com/building-a-modal-module-for-react-with-react-router/modal-router-element-nocdn/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2019/10/Modal-router-element-nocdn.png" data-orig-size="1582,542" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Modal-router-element-nocdn" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2019/10/Modal-router-element-nocdn-300x103.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2019/10/Modal-router-element-nocdn-1024x351.png" decoding="async" loading="lazy" class="aligncenter wp-image-8531" src="../Images/b7db27e2395036c00e9ea152d38fb51f.png" alt="An example of a modal router element." srcset="https://blog.logrocket.com/wp-content/uploads/2019/10/Modal-router-element-nocdn.png 1582w, https://blog.logrocket.com/wp-content/uploads/2019/10/Modal-router-element-nocdn-300x103.png 300w, https://blog.logrocket.com/wp-content/uploads/2019/10/Modal-router-element-nocdn-768x263.png 768w, https://blog.logrocket.com/wp-content/uploads/2019/10/Modal-router-element-nocdn-1024x351.png 1024w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/10/Modal-router-element-nocdn.png"/></noscript>
<p>下面是一个<code>&lt;Modal/&gt;</code>功能组件的例子，它使用<code>withRouter</code> HOC(高阶组件)来访问路由器历史记录，并调用<code>goBack()</code>方法来更改应用程序URL，当点击<code>.modal-wrapper</code>关闭模态时。</p>
<p><code>onClick={e =&gt; e.stopPropagation()}</code>用于阻止点击事件的传播，并触发<code>.modal-wrapper</code>上的<code>onClick</code>，当实际的<code>.modal</code>元素被激活时，它将关闭模态。</p>
<pre>import React from 'react';
import { withRouter } from 'react-router-dom';

const Modal = () =&gt; (
  &lt;div
    role="button"
    className="modal-wrapper"
    onClick={() =&gt; this.props.history.goBack()}
  &gt;
    &lt;div
      role="button"
      className="modal"
      onClick={e =&gt; e.stopPropagation()}
    &gt;
      &lt;p&gt;
        CONTENT
      &lt;/p&gt;
    &lt;/div&gt;
  &lt;/div&gt;
);

export default withRouter(Modal);</pre>
<p>设计<code>.modal-wrapper</code>的样式同样重要。下面，您可以找到用于使其跨越整个屏幕并出现在内容上方的基本样式。</p>
<p>使用<code>-webkit-overflow-scrolling: touch</code>在iOS设备上启用弹性滚动。</p>
<pre>.modal-wrapper {
  position: fixed;
  left: 0;
  top: 0;
  width: 100%;
  height: 100vh;
  overflow-y: scroll;
  -webkit-overflow-scrolling: touch;
}</pre>
<h3>打开模式视图</h3>
<p>当特定的URL匹配时，我们创建的模态组件应该呈现在现有视图的顶部，这意味着我们必须以某种方式更改URL，以便路由机制可以决定呈现什么。</p>
<p>我们知道<code>&lt;Switch/&gt;</code>呈现第一个匹配的位置，但是一个模态叠加需要两个<code>&lt;Route/&gt;</code>组件同时呈现。</p>
<p>这可以通过将模态<code>&lt;Route/&gt;</code>从<code>&lt;Switch/&gt;</code>中取出并有条件地渲染来实现。</p>
<p>在这种情况下，我们应该能够检测一个模态是否是活动的。</p>
<p>最简单的方法是传递一个状态变量和一个<code>&lt;Link/&gt;</code>组件。</p>
<p>与我们使用<code>&lt;Link/&gt;</code>组件创建导航菜单的方式一样，我们将使用它来触发一个模态视图。</p>
<p>下面显示的用法让我们定义一个状态变量，然后在<code>location</code> prop中可用，我们可以使用<code>withRouter</code> HOC在任何组件中访问它。</p>
<pre>&lt;Link
  to={{
    pathname: '/modal/1',
    state: { modal: true }
  }}
&gt;
  Open Modal
&lt;/Link&gt;</pre>
<p>把这个放在你想放的任何地方。点击链接会将URL更改为<code>/modal/1</code>。</p>
<p>可能有几个不同名字的情态动词，如<code>modal/1</code>、<code>modal/2</code>等等。</p>
<p>在这种情况下，您不需要定义每个<code>&lt;Route/&gt;</code>来匹配单独的模态位置。为了在<code>/modal</code>路线下处理它们，使用下面的语法:</p>
<pre>&lt;Route exact <em>path</em>="/modal/:id"&gt;</pre>
<p>这使您可以通过<code>match.params</code>属性灵活地获得模态组件中硬编码的<code>:id</code>参数的值。</p>
<p>它还允许您根据打开的模式进行动态内容呈现。</p>
<h3>匹配模态位置</h3>
<p>这一部分特别重要，因为它确定了在现有视图上显示模式的机制，即使打开模式时位置参数发生了变化。</p>
<p>当我们单击前面定义的<code>Open Modal</code>链接时，它会将位置路径更改为<code>/modal/1</code>，这与<code>&lt;Switch/&gt;</code>中的任何内容都不匹配。</p>
<p>所以我们必须在某处定义下面的<code>&lt;Route/&gt;</code>。</p>
<pre>&lt;Route exact path="/modal/:id" component={Modal} /&gt;</pre>
<p>我们希望将<code>&lt;Modal/&gt;</code>组件显示为一个覆盖图。</p>
<p>然而，将它放在<code>&lt;Switch/&gt;</code>中会匹配它，并且只呈现<code>&lt;Modal/&gt;</code>组件。因此，不会有覆盖。</p>
<p>为了解决这个问题，我们需要用额外的条件在<code>&lt;Switch/&gt;</code>的内部和外部定义它。</p>
<hr/>
<p>下面，您将看到相同代码片段的修改版本。有几个变化。让我们快速列出它们:</p>
<ul>
<li>构造函数中定义了一个<code>previousLocation</code>变量。</li>
<li>
<p>定义了一个<code>isModal</code>变量，它依赖于其他一些值。</p>
</li>
<li>
<p><code>&lt;Switch/&gt;</code>正在使用一个<code><em>location</em></code>道具。</p>
</li>
<li>
<p>有两个<code>&lt;Route</code> <em> <code>exact</code> </em> <code><em>path</em>="/modal/:id" component={Modal} /&gt;</code>在<code>&lt;Switch/&gt;</code>内外都用，外面那个是有条件渲染的。</p>
</li>
</ul>
<p>当一个模态被打开时，我们需要存储之前的位置对象，并将其传递给<code>&lt;Switch/&gt;</code>，而不是让它默认使用当前的位置对象。</p>
<p>这基本上欺骗了<code>&lt;Switch/&gt;</code>认为它仍然在先前的位置——例如<code>/</code>——即使位置在模态打开后变成了<code>/modal/1</code>。</p>
<p>这可以通过将<code>location</code>支柱设置在<code>&lt;Switch/&gt;</code>上来实现。</p>
<p>当没有打开的模式时，下面的代码片段用当前位置对象替换<code>previousLocation</code>。</p>
<p>当你打开一个模态时，它不会修改<code>previousLocation</code>。</p>
<p>因此，我们可以将它传递给<code>&lt;Switch/&gt;</code>,让它认为我们仍然在同一个位置，即使我们通过打开一个模态改变了位置。</p>
<p>我们知道，当一个模态被打开时，<code>location</code>对象中名为<code>modal</code>的状态变量将被设置为<code>true</code>。</p>
<p>我们可以检查位置对象的状态是否已定义，以及是否将状态变量<code>modal</code>设置为<code>true</code>。</p>
<p>然而，在刷新页面的情况下，仅仅这两项检查是不够的。</p>
<p>虽然模态必须自己闭合，<code>location.state &amp;&amp; location.state.modal</code>仍然成立。</p>
<p>检查<code>this.previousLocation !== location</code>，我们可以确保刷新页面不会导致将<code>isModal</code>设置为<code>true</code>。</p>
<p>当模态路径被直接访问时，在我们的例子中是<code>modal/1</code>，那么没有检查是<code>true</code>。</p>
<p>现在我们可以使用这个布尔值来在<code>&lt;Switch/&gt;</code>外渲染<code>&lt;Route/&gt;</code>，并决定将哪个<code>location</code>对象传递给<code>&lt;Switch/&gt;</code>的<code>location</code>道具。</p>
<p>鉴于<code>&lt;Modal/&gt;</code>组件具有必要的样式，这导致两个不同的视图呈现在彼此之上。</p>
<pre>constructor(props){
  super(props);
  this.previousLocation = this.props.location;
}

componentWillUpdate() {
  const { location } = this.props;
  if (!(location.state &amp;&amp; location.state.modal)) {
    this.previousLocation = this.props.location;
  }
}  

render() {
  const { location } = this.props;
  const isModal = (
    location.state &amp;&amp;
    location.state.modal &amp;&amp;
    this.previousLocation !== location
  );

  return (
    &lt;div className="app"&gt;
      &lt;div className="menu"&gt;
        &lt;Link className="link" to='/'&gt;Home&lt;/Link&gt;
        &lt;Link className="link" to='/about'&gt;About&lt;/Link&gt;
        &lt;Link className="link" to='/contact'&gt;Contact&lt;/Link&gt;
      &lt;/div&gt;
      &lt;Switch location={isModal ? this.previousLocation : location}&gt;
        &lt;Route exact path="/" component={Home} /&gt;
        &lt;Route exact path="/contact/" component={Contact} /&gt;
        &lt;Route exact path="/about" component={About} /&gt;
        &lt;Route exact path="/modal/:id" component={Modal} /&gt;
        &lt;Route&gt;{'no match'}&lt;/Route&gt;
      &lt;/Switch&gt;
      {isModal
        ? &lt;Route exact path="/modal/:id" component={Modal} /&gt;
        : null
      }
    &lt;/div&gt;
  );
}</pre>
<h3>呈现不同的模式视图</h3>
<p>到目前为止，我们已经实现了我们的模态，确保在用打开的模态刷新页面时，或者在直接访问模态路径时，不会呈现覆盖图。</p>
<p>相反，我们只在<code>&lt;Switch/&gt;</code>中渲染匹配的<code>&lt;Route/&gt;</code>。</p>
<p>在这种情况下，您想要应用的样式可能是不同的，或者您可能想要显示不同的内容。</p>
<p>这很容易通过将<code>isModal</code>变量作为道具传递给<code>&lt;Modal/&gt;</code>组件来实现，如下所示。</p>
<p>然后，根据属性的值，您可以应用不同的样式或返回完全不同的标记。</p>
<pre>return (
  &lt;div className="app"&gt;
    &lt;div className="menu"&gt;
      &lt;Link className="link" to='/'&gt;Home&lt;/Link&gt;
      &lt;Link className="link" to='/about'&gt;About&lt;/Link&gt;
      &lt;Link className="link" to='/contact'&gt;Contact&lt;/Link&gt;
    &lt;/div&gt;
    &lt;Switch location={isModal ? this.previousLocation : location}&gt;
      &lt;Route exact path="/" component={Home} /&gt;
      &lt;Route exact path="/contact/" component={Contact} /&gt;
      &lt;Route exact path="/about" component={About} /&gt;
      &lt;Route exact path="/modal/:id" component={Modal} /&gt;
      &lt;Route&gt;{'no match'}&lt;/Route&gt;
    &lt;/Switch&gt;
    {isModal
      ? &lt;Route exact path="/modal/:id"&gt;
          &lt;Modal isModal /&gt;
        &lt;/Route&gt;
      : null
    }
  &lt;/div&gt;
);</pre>
<h3>防止在模式下滚动</h3>
<p>当你在一些浏览器上打开模态时，它可能会让下面的内容在模态下滚动，这不是一个理想的交互。</p>
<p>在<code>body</code>上使用<code>overflow: hidden</code>是阻止整个页面滚动的第一次尝试。</p>
<p>然而，尽管这种方法在桌面上运行良好，但在移动Safari上却失败了，因为它基本上忽略了<code>body</code>上的<code>overflow: hidden</code>。</p>
<p>有几个不同的npm包试图在几乎所有平台上解决这个滚动锁定问题。</p>
<p>我发现<a href="https://www.npmjs.com/package/body-scroll-lock" target="_blank" rel="noopener noreferrer">身体滚动锁</a>包非常有用。</p>
<p>从这个包中，您可以导入<code>disableBodyScroll</code>和<code>enableBodyScroll</code>函数，它们接受对您希望滚动持续的元素的引用作为输入。</p>
<p>当模式打开时，我们希望禁用整个页面的滚动，除了模式本身。</p>
<p>因此，当模态组件被挂载和卸载时，我们需要分别调用<code>disableBodyScroll</code>和<code>enableBodyScroll</code>函数。</p>
<p>为了获得对模态组件的父组件<code>&lt;div&gt;</code>的引用，我们可以使用React中的<code>createRef</code> API，并将其作为引用传递给父组件<code>&lt;div&gt;</code>。</p>
<p>下面的代码片段在模式打开时禁用滚动，在模式组件即将被卸载时再次启用滚动。</p>
<p>使用<code>this.modalRef</code>作为这些导入函数的输入可以防止模态组件的内容被滚动锁定。</p>
<p>在使用<code>disableBodyScroll</code>功能之前，我们需要做一个简单的检查。</p>
<p>这是因为当打开模式时，或者当直接访问模式路由时，如果页面被刷新，则模式组件可能会被装载。</p>
<p>在这两种情况下，都不应该禁用滚动。</p>
<p>我们已经将<code>isModal</code>变量作为道具传递给了<code>&lt;Modal/&gt;</code>组件来呈现不同的视图，所以我们可以使用这个道具来检查是否真的有模态。</p>
<p>下面是模态组件的修改版本:</p>
<pre>import { disableBodyScroll, enableBodyScroll } from 'body-scroll-lock';

class Modal extends Component {
  constructor(props) {
    super(props);
    this.modalRef = React.createRef();
  }
  
  componentDidMount() {
    const { isModal } = this.props;

    if (isModal) {
      disableBodyScroll(this.modalRef.current);
    }
  }
  
  componentWillUnmount() {
    enableBodyScroll(this.modalRef.current);
  }
  
  render() {
    return (
      &lt;div
        ref={this.modalRef}
        className="modal-wrapper"
        onClick={() =&gt; this.props.history.goBack()}
      &gt;
        &lt;div
          className="modal"
          onClick={e =&gt; e.stopPropagation()}
        &gt;
        &lt;/div&gt;
      &lt;/div&gt;
    )
  }
}</pre>
<h3>结论</h3>
<p>现在，您已经了解了模态视图是如何工作的，并且知道了在实现自己的集成时可能会遇到的一些问题。</p>
<p>对于完整的功能示例，请访问<a href="https://codesandbox.io/s/jolly-jones-cx4cw" target="_blank" rel="noopener noreferrer">这个</a>代码沙盒项目。</p><div class="code-block code-block-17">
<div class="blog-plug inline-plug react-plug" vwo-el-id="26283398190">
<h2 vwo-el-id="41600691720">使用LogRocket消除传统反应错误报告的噪音</h2>
<a href="https://lp.logrocket.com/blg/react-signup-issue-free" target="_blank" vwo-el-id="19356441070">LogRocket
</a><p>是一款React analytics解决方案，可保护您免受数百个误报错误警报的影响，只针对少数真正重要的项目。LogRocket告诉您React应用程序中实际影响用户的最具影响力的bug和UX问题。</p><a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="19356441380">
<img class="first-react-image alignnone size-full wp-image-46 jetpack-lazy-image jetpack-lazy-image--handled" src="../Images/f300c244a1a1cf916df8b4cb02bec6c6.png" vwo-el-id="18272717540" data-lazy-loaded="1" data-original-src="https://files.readme.io/27c94e7-Image_2017-06-05_at_9.46.04_PM.png"/>
</a>
<a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="19356441690">
<img class="second-react-image alignnone size-full wp-image-46 jetpack-lazy-image jetpack-lazy-image--handled" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" vwo-el-id="30720362350" data-lazy-loaded="1" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/>
</a>
<a href="https://lp.logrocket.com/blg/react-signup-issue-free" target="_blank" rel="noopener noreferrer" vwo-el-id="35866400580">LogRocket
</a><p>自动聚合客户端错误、反应错误边界、还原状态、缓慢的组件加载时间、JS异常、前端性能指标和用户交互。然后，LogRocket使用机器学习来通知您影响大多数用户的最具影响力的问题，并提供您修复它所需的上下文。</p><p vwo-el-id="28675661060">关注重要的React bug—<a class="signup" href="https://lp.logrocket.com/blg/react-signup-issue-free" target="_blank" rel="noopener noreferrer" vwo-el-id="40093418840">今天就试试LogRocket】。</a></p>
</div></div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
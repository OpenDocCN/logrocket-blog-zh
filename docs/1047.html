<html>
<head>
<title>Elegant data validation with Vest - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>使用Vest - LogRocket博客进行优雅的数据验证</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/elegant-data-validation-vest/#0001-01-01">https://blog.logrocket.com/elegant-data-validation-vest/#0001-01-01</a></blockquote><div><article class="article-post">
<p>还有什么比用测试代码的方式测试表单的有效性更优雅的呢？</p>
<p>Vest是一个强大的JavaScript数据验证库，它的语法来自现代JS框架，如Mocha或Jest。它是框架不可知的，所以你可以立刻把它放到你的代码中。</p>
<p>单元测试应用于数据验证？没错。</p>
<p>如果用摩卡，我们会这样做:</p>
<pre>import { assert } from 'chai'
let hello = () =&gt; 'Hello!'
assert.equal(hello, 'Hello!')
</pre>
<p>同样，使用Vest，我们可以做到这一点:</p>
<pre>import { enforce } from 'vest'
let hello = document.querySelector('#hello').value
enforce(hello).equals('Hello!')
</pre>
<h2>“吸烟”！"</h2>
<p>首先，我们需要导出一个验证函数——也称为suit——用于对作为对象传递的输入数据执行测试。</p>
<pre>import vest, { test, enforce } from 'vest'

const suitName = 'signUpSuit'

const validate = vest.create(suitName, formData =&gt; {

   test('username', 'Should not be empty', () =&gt; {
       enforce(formData.username).isNotEmpty()
   })

   test('password', 'Should be longer, () =&gt; {
       enforce(formData.password).longerThanOrEquals(8)
   })

   test('password_repeat', 'Should match password', () =&gt; {
       enforce(formData.password_repeat).equals(formData.password)
   })

})

export default validate
</pre>
<p>现在，我们可以简单地在逻辑中发生验证时调用它:</p>
<pre>import validate from './signup/validate.js'

let response = validate(formData)
</pre>
<p>Vest是一个通用的数据验证器，所以它不包含任何表单序列化方法——但是，收集数据非常容易！要么你写的是普通的JS:</p>
<pre>let formData = inputs.reduce((data, input) =&gt; {
   return {
       ...data,
       ...{ [input.name]: input.value }
   }
, {})
</pre>
<p>或者使用React这样的框架:</p>
<pre>const [formData, setFormData] = useState({})

const onInputChange = e =&gt; {
   setFormData(data =&gt; {
       ...data,
       ...{ [e.target.name]: e.target.value }
   })
}
</pre>
<p>现在我们知道了如何收集和传递数据，我们需要处理验证套装的结果，以便为用户定制适当的响应。</p>
<h2>“我们到了吗？”</h2>
<p>验证总是返回包含有用信息和方法池的对象:</p>
<pre>let response = validate(formData)
</pre>
<p>无论如何，在处理动态分配的变量时，代码会很快变得混乱。Vest提供了一个<code>.done()</code>方法，可以多次链接到验证函数。在这里，我们可以传递一个回调函数来优雅地处理响应:</p>
<pre>validate(formData).done(callback)
</pre>
<p>在回调函数之前指定一个可选键，我们可以显式地等待单个字段的验证。无论回调在链中的顺序如何，只有满足条件时才会执行回调。</p>
<pre>validate(formData)
   .done('username', usernameCallback)
   .done(formCallback)
</pre>
<h2>“我们需要一个反应小组！”</h2>
<p>为了检查是否有测试失败，我们需要调用<code>.hasErrors()</code>响应方法。</p>
<pre>if (response.hasErrors()) let errors = response.getErrors()
</pre>
<p>如果为真，可以从<code>.getErrors()</code>方法中以键值对象的形式访问错误的完整列表。对于每个没有通过测试的字段，将有一个包含错误消息列表的数组。</p>
<p>可以为单个字段提供多个测试，并且出现的顺序将反映在数组中。</p>
<pre>test('username', 'Cannot be empty', () =&gt; {
   enforce(formData.username).isNotEmpty()
})

test('username', 'Must be longer than 3 chars', () =&gt; {
   enforce(formData.username).isLongerOrEquals(4)
})
</pre>
<p>如果将名称传递给上述方法，将只返回该特定字段的错误:</p>
<pre>if (response.hasErrors('password')) {
   let passwordErrorMessage = response.getErrors('password')[0]
   // ...
</pre>
<p>当测试调用<code>vest.warn()</code>时，它的消息将可以从<code>.hasWarnings()</code>和<code>.getWarnings()</code>方法中访问。</p>
<p>这允许我们将响应消息分为两个不同的重要级别。</p>
<pre>test('username', 'Should not be a number', () =&gt; {
   vest.warn()
   enforce(formData.username).isNotNumeric()
})
</pre>
<h2>“请下一组。”</h2>
<p>可以对测试进行分组，以便在我们的逻辑的某一点上过滤应该测试哪些输入。这非常有用，例如，验证按顺序步骤发送数据的多页表单。</p>
<pre>const validate = vest.create(suitName, formData =&gt; {
   group('formPage1', () =&gt; {
       // test(...)
   })
})
</pre>
<p>从<code>.hasErrorsByGroup()</code>和<code>.getErrorsByGroup()</code>可访问分组验证结果:</p>
<pre>if (response.hasErrorsByGroup('formPage1')) {
   // ...
</pre>
<p>也可以使用<code>vest.skip()</code>过滤掉测试。该方法接受字段名或组名，并可用于在某些条件下避免测试。</p>
<pre>const validate = vest.create('purchaseSuit', formData =&gt; {
   if (!formData.coupon) vest.skip('coupon')
   // ...
</pre>
<h2>“我做实时的。”</h2>
<p>通过调用<code>vest.only()</code>，我们可以要求Vest只为特定的字段或组执行测试。</p>
<pre>const validate = vest.create('userSuit',
   (data = {}, inputName = '') =&gt; {
       if (inputName) vest.only(inputName)
       // ...
</pre>
<p>这在用户输入时实时验证数据时特别有用:</p>
<pre>const onInputChange = e =&gt; {
   validate({ [e.target.name]: e.target.value }, e.target.name)
       .done(e.target.name, callback)
}
</pre>
<p>默认情况下，Vest是有状态的，所以即使我们为单个字段传递数据——就像上面的例子一样——响应也会返回所有已经测试过的字段的最新验证结果，从而使更新我们的应用程序状态变得更加容易。</p>
<p>此外，最新的套装状态始终可从<code>vest.get(suitName)</code>访问，并可通过<code>vest.reset(suitName)</code>重置。</p>
<p>如果你想运行无状态，直接从Vest导入一个<code>validate()</code>函数，而不是创建一个新的。这更适合服务器端验证，在这种情况下，响应应该是等幂的。因此，使用:</p>
<pre>const response = validate('stateless', data =&gt; {
   // ...
})
</pre>
<p>而不是:</p>
<pre>const validate = vest.create('stateful', data =&gt; {
   // ...
})
</pre>
<h2>“为此，我们需要服务器！”</h2>
<p>Vest允许异步验证。这在我们需要对照数据库中的条目检查数据时特别有用，比如检查用户名是否已经被使用。</p>
<pre>test('username', 'Should not already exist', async () =&gt; {
   return await checkIfUserExists(formData.username)
})
</pre>
<p>请记住，异步响应可能会在其他同步测试已经运行完之后出现。一般来说，建议在所有同步请求运行之后，在suit逻辑的底端执行异步测试。</p><div class="code-block code-block-54">
<hr/>
<h3>更多来自LogRocket的精彩文章:</h3>

<hr/></div>
<p>在这种情况下，我们可以使用<code>vest.draft() </code>方法来保存服务器资源。这样，我们可以针对当前正在运行的套装的状态执行条件操作，并避免不必要的请求:</p>
<pre>test('username', 'Cannot be empty', () =&gt; {
   enforce(formData.username).isNotEmpty()
})
if (!vest.draft().hasErrors('username')) {
  test('username', 'Should not already exist', async () =&gt; {
       return await doesUserExist(formData.username)
   })
}
</pre>
<h2>“我们有一个规则。”</h2>
<p>规则可以链接在一起，如果缺省值不能满足您的需要，您可以简单地创建返回布尔值的定制逻辑，或者为了更好的可重用性，扩展缺省方法池:</p>
<pre>import { enforce } from 'vest'

const customRules = {
   isTruthyStr: value =&gt;
       ['true','on'].includes(String(value).toLowerCase()),
   isFalsyStr: value =&gt;
       ['false','off'].includes(String(value).toLowerCase()),
}

enforce.extend(customRules)
</pre>
<p>用Vest的<code>any()</code>，我们可以表达规则之间的一个逻辑OR。如果满足任何强制规则，则整个测试视为通过:</p>
<pre>test('comment', 'Must be at least 140 chars, if provided.',
   any(
       () =&gt; enforce(data.comment).isEmpty(),
       () =&gt; enforce(data.comment).longerThanOrEquals(140)
   )
)
</pre>
<h2>“上课，上课，上课。”</h2>
<p>一套量身定做的西装没有档次就什么都不是了吧？Vest提供了一个<code>classNames()</code>函数，这是一个基于验证状态将CSS类关联到DOM元素的强大方法:</p>
<pre>import classNames from 'vest/classNames'
const getFieldClass = classNames(response, {
  untested: 'is-untested',
  tested: 'is-tested',
  valid: 'is-valid',
  invalid: 'has-errors',
  warning: 'has-warnings',
})
</pre>
<p>这允许实时更新我们组件的外观:</p>
<pre>function InputText(props) {
   return &lt;input
       type='text'
       name={props.name}
       value={props.value}
       className={getFieldClass(props.name)}
       onChange={e =&gt; onInputChange(e)}
    /&gt;
}
</pre>
<p>通过这种方式，可以实时表达基于输入状态的复杂UI逻辑，而不会出现意大利面条！</p><div class="code-block code-block-28">
<div class="blog-plug inline-plug js-libraries-plug"><h2>您是否添加了新的JS库来提高性能或构建新特性？如果他们反其道而行之呢？</h2><p>毫无疑问，前端变得越来越复杂。当您向应用程序添加新的JavaScript库和其他依赖项时，您将需要更多的可见性，以确保您的用户不会遇到未知的问题。</p>
<p>LogRocket 是一个前端应用程序监控解决方案，可以让您回放JavaScript错误，就像它们发生在您自己的浏览器中一样，这样您就可以更有效地对错误做出反应。</p><a class="signup" href="https://lp.logrocket.com/blg/javascript-signup" target="_blank" rel="noopener noreferrer"><img class="alignnone size-full wp-image-46 jetpack-lazy-image" src="../Images/e8a0ab42befa3b3b1ae08c1439527dc6.png" alt="LogRocket Dashboard Free Trial Banner" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2019/10/errors-screenshot.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/10/errors-screenshot.png"/><noscript><img data-lazy-fallback="1" class="alignnone size-full wp-image-46" src="../Images/e8a0ab42befa3b3b1ae08c1439527dc6.png" alt="LogRocket Dashboard Free Trial Banner" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/10/errors-screenshot.png"/></noscript></a>
<a href="https://lp.logrocket.com/blg/javascript-signup" target="_blank" rel="noopener noreferrer">https://logrocket.com/signup/</a><p><a href="https://lp.logrocket.com/blg/javascript-signup" target="_blank" rel="noopener noreferrer"> LogRocket </a>可以与任何应用程序完美配合，不管是什么框架，并且有插件可以记录来自Redux、Vuex和@ngrx/store的额外上下文。您可以汇总并报告问题发生时应用程序的状态，而不是猜测问题发生的原因。LogRocket还可以监控应用的性能，报告客户端CPU负载、客户端内存使用等指标。</p><p>自信地构建— <a class="signup" href="https://lp.logrocket.com/blg/javascript-signup" target="_blank" rel="noopener noreferrer">开始免费监控</a>。</p></div>


</div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
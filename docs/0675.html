<html>
<head>
<title>Overcoming single-threaded limitations in React Native - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>克服React Native - LogRocket博客中的单线程限制</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/overcoming-single-threaded-limitations-in-react-native/#0001-01-01">https://blog.logrocket.com/overcoming-single-threaded-limitations-in-react-native/#0001-01-01</a></blockquote><div><article class="article-post">
<p>React Native旨在弥合软件开发中web和移动框架之间的差距。不幸的是，开发人员在使用React Native时会面临一些与性能相关的障碍。</p>
<p>每个框架都有其局限性，重要的是我们如何解决这些局限性并构建功能齐全的应用程序。在这篇博文中，我们将看看限制React Native性能的某些特性，以及我们如何减少它们的影响，以便用这个框架构建健壮的产品。</p>
<h2>React Native的架构——它是如何工作的</h2>
<p>为了理解问题，我们先来看看React Native的架构是如何工作的。有三个线程主要运行React本机应用程序:</p>
<ul>
<li>UI线程——这是用于在iOS设备中运行Swift/Objective C和在Android设备中运行Java/Kotlin的本机线程，应用程序的UI仅在该线程上操作。在这里，应用程序的<a href="https://facebook.github.io/react-native/docs/view" target="_blank" rel="noopener noreferrer">视图</a>被渲染，应用程序的用户可以与操作系统交互。这个线程中的大部分繁重工作都是由React Native执行的</li>
<li>JavaScript线程——这是通过<a href="https://v8.dev/" target="_blank" rel="noopener noreferrer"> JavaScript引擎</a>单独执行JavaScript的线程。应用程序的逻辑——包括显示哪些视图以及以何种方式显示——通常在这里配置</li>
<li>桥——React Native的桥支持UI和JS线程之间的通信</li>
</ul>
<p>现在，UI和JavaScript线程各自都很快，但是性能问题发生在它们通过桥进行通信的过程中。假设您在两个线程之间传递巨大的文件，这可能会降低性能。重要的是将桥两端之间的传递保持在最低限度，以避免任何类型的性能相关问题。</p>
<p>因为React有一个<a href="https://reactjs.org/docs/faq-internals.html" target="_blank" rel="noopener noreferrer">虚拟DOM </a>，所以它异步呈现JavaScript组件，并且在这个过程中，减少了需要通过桥发送的数据量。然而，这并不妨碍不时出现一些性能问题，让我们突出这些问题以及如何修复它们。</p>
<h2>单线程限制</h2>
<p>React Native本质上是单线程的。在其呈现过程中，当一个组件被呈现时，其他组件必须等待，而不是多个进程同时发生(多线程)。</p>
<p>事实证明，这对于那些可能希望同时实现多种功能的应用程序来说是一个巨大的挑战，例如需要实时聊天功能和实时流馈送的流媒体服务。具有更多RAM和处理能力的高端设备可能会运行良好，但更便宜的设备将无法运行像下面所示的<a href="https://mixer.com/" target="_blank" rel="noopener noreferrer"> Mixer </a>这样的应用程序:</p>
<figure id="attachment_14034" aria-describedby="caption-attachment-14034" class="wp-caption aligncenter"><img data-attachment-id="14034" data-permalink="https://blog.logrocket.com/overcoming-single-threaded-limitations-in-react-native/mixerscreenshot/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/02/mixerscreenshot.png" data-orig-size="320,568" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="mixerscreenshot" data-image-description="" data-image-caption="&lt;p&gt;Screenshot taken from Mixer, a live stream gaming app&lt;/p&gt;&#10;" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/02/mixerscreenshot-169x300.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/02/mixerscreenshot.png" decoding="async" class="wp-image-14034 size-full jetpack-lazy-image" src="../Images/a48847f53269b81c8a71a561fcdf585b.png" alt="Screenshot taken from Mixer, a live stream gaming app" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2020/02/mixerscreenshot.png 320w, https://blog.logrocket.com/wp-content/uploads/2020/02/mixerscreenshot-169x300.png 169w" data-lazy-sizes="(max-width: 320px) 100vw, 320px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2020/02/mixerscreenshot.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/02/mixerscreenshot.png"/><noscript><img data-lazy-fallback="1" data-attachment-id="14034" data-permalink="https://blog.logrocket.com/overcoming-single-threaded-limitations-in-react-native/mixerscreenshot/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/02/mixerscreenshot.png" data-orig-size="320,568" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="mixerscreenshot" data-image-description="" data-image-caption="&lt;p&gt;Screenshot taken from Mixer, a live stream gaming app&lt;/p&gt;&#10;" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/02/mixerscreenshot-169x300.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/02/mixerscreenshot.png" decoding="async" loading="lazy" class="wp-image-14034 size-full" src="../Images/a48847f53269b81c8a71a561fcdf585b.png" alt="Screenshot taken from Mixer, a live stream gaming app" srcset="https://blog.logrocket.com/wp-content/uploads/2020/02/mixerscreenshot.png 320w, https://blog.logrocket.com/wp-content/uploads/2020/02/mixerscreenshot-169x300.png 169w" sizes="(max-width: 320px) 100vw, 320px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/02/mixerscreenshot.png"/></noscript><figcaption id="caption-attachment-14034" class="wp-caption-text">Screenshot taken from Mixer, a live stream gaming app</figcaption></figure>
<p>解决应用程序中单线程限制的方法是让工程师构建可维护的扩展，这些扩展可以在React本机应用程序中处理多线程。一个扩展可以让你为一个应用程序提供定制的功能，否则它不会有。可以使用Java、Swift或Objective-C构建扩展。解决单线程问题的扩展的一个很好的例子是在React本机和本机组件之间建立桥梁。</p>
<p>在构建扩展时，重要的是在真实设备上执行测试，而不仅仅是在模拟器上，因为真实的应用程序很可能会超过应用程序的<a href="https://blog.swmansion.com/hunting-js-memory-leaks-in-react-native-apps-bd73807d0fde" target="_blank" rel="noopener noreferrer">内存限制</a>，从而导致内存泄漏(我们将在本文后面讨论)。苹果的<a href="https://help.apple.com/instruments/mac/current/" target="_blank" rel="noopener noreferrer"> Xcode Instruments </a>仍然是检查应用程序内存使用情况的便捷工具。</p>
<h2>慢速导航过渡</h2>
<p>React本机应用程序中单线程限制的另一种情况是在动画过渡期间。JavaScript线程负责控制React本机应用程序中的导航器动画。</p>
<p><img data-attachment-id="14037" data-permalink="https://blog.logrocket.com/overcoming-single-threaded-limitations-in-react-native/rntransitions/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/02/rntransitions.gif" data-orig-size="730,485" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="rntransitions" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/02/rntransitions-300x199.gif" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/02/rntransitions.gif" decoding="async" class="aligncenter wp-image-14037 size-full jetpack-lazy-image" src="../Images/de1b0e6b160c52c9523076fb515bbb72.png" alt="react native animations" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2020/02/rntransitions.gif?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/02/rntransitions.gif"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="14037" data-permalink="https://blog.logrocket.com/overcoming-single-threaded-limitations-in-react-native/rntransitions/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/02/rntransitions.gif" data-orig-size="730,485" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="rntransitions" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/02/rntransitions-300x199.gif" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/02/rntransitions.gif" decoding="async" loading="lazy" class="aligncenter wp-image-14037 size-full" src="../Images/de1b0e6b160c52c9523076fb515bbb72.png" alt="react native animations" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/02/rntransitions.gif"/></noscript>
<p>当React Native在JavaScript线程上运行动画时尝试渲染新屏幕时，会导致动画中断。React Native的<code>InteractionManager</code> API是改善慢速导航过渡的一个好方法。</p>
<p>假设你有一个做位置追踪的应用程序，用户可以通过列出位置的频繁变化来找到彼此。通过启动以特定时间间隔搜索位置的功能来列出位置变化。</p>
<pre>onChangeTab(event) {
    if (event === 1) {
        intervalId = BackgroundTimer.setInterval(() =&gt; {
            this.props.actions.getAllLocationAction();
        }, 5000);
    } else {
        BackgroundTimer.clearInterval(intervalId);
    }
    this.setState({
        activeTab: event
    });
}</pre>
<p>这种重复的动作必然会在组件之间的运动中产生一些滞后。为了在不降低UI渲染速度的情况下重复调用<code>onChangeTab</code>，我们将使用<code>InteractionManager</code> API中的<code>runAfter Interactions()</code>方法，该方法允许我们延迟所有操作，直到所有动画完成:</p>
<pre>import { InteractionManager } from 'react-native';

onChangeTab(event) {
    if (event === 1) {
        InteractionManager.runAfterInteractions(() =&gt; {
            this.props.dispatchTeamFetchStart();
        });
    }
    this.setState({
        activeTab: event
    });
}</pre>
<h2>内存泄漏</h2>
<p>Android和iOS平台上的React原生应用都在努力应对<a href="https://en.wikipedia.org/wiki/Memory_leak" target="_blank" rel="noopener noreferrer">内存泄漏</a>的问题。因为React原生应用由JavaScript支持，所以它们的内存由<a href="https://javascript.info/garbage-collection" target="_blank" rel="noopener noreferrer">垃圾收集器</a> r管理——一个后台进程，它不断地检查对象和模块，并从那些没有被根对象直接或间接引用的对象和模块中释放内存。</p>
<p>在JavaScript中，内存由<a href="https://en.wikipedia.org/wiki/Garbage_collection_(computer_science)" target="_blank" rel="noopener noreferrer">垃圾收集器(GC) </a>自动管理。简而言之，垃圾收集器是一个后台进程，它定期遍历已分配对象及其引用的图表。如果碰巧遇到图形的一部分没有被根对象(例如，堆栈上的变量或像<code>window</code>或<code>navigator</code>这样的全局对象)直接或间接引用，则整个部分可以从存储器中解除分配。</p>
<p>使用React Native的架构，每个模块都附加到一个根对象。核心React本机模块声明保存在主作用域中的变量。这些变量可以保留其他对象，防止它们被垃圾收集。</p>
<p>React原生应用中可能导致内存泄漏的一个常见做法是对闭包的不正确处理。闭包是从父作用域捕获变量的函数。查看下面的代码示例:</p>
<pre>var thisList = null;
var replaceList = function () {
  var originalList = thisList;
  var idle = function () {
    if (originalList)
      console.log("nice");
  };
  thisList = {
    thisArray: new Array(2000000).join('*'),
    thisMethod: function () {
      console.log(thisMessage);
    }
  };
};
setInterval(replaceList, 1000);</pre>
<p>在上面的代码示例中，每次调用<code>replaceList</code>时，<code>thisList</code>都会获得一个包含数组(<code>thisArray</code>)和方法<code>thisMessage</code>的对象。同时，变量<code>idle</code>持有一个引用<code>originalList</code>的闭包，T5引用它的父函数<code>replaceList</code>。为闭包<code>thisMethod</code>创建的作用域由变量<code>idle</code>共享，尽管它从未被使用过，但它对<code>originalList</code>的间接引用使它保持活动状态，不能被垃圾收集器收集。</p>
<p>因此，当重复调用<code>replaceList</code>时，可以观察到内存使用的稳定增长，当垃圾收集器运行时，这种增长不会变小。这意味着创建的每个闭包链表都带有对<code>thisArray</code>的间接引用，从而导致代价高昂的内存泄漏。</p>
<p>幸运的是，修复闭包导致的内存泄漏非常简单。在<code>replaceList</code>的末尾加上<code>originalList = null</code>就可以了。所以即使名字<code>originalList</code>仍然在<code>thisMethod</code>的词汇环境中，也不会有到父值<code>thisList</code>的链接:</p>
<pre>var thisList = null;
var replaceList = function () {
  var originalList = thisList;
  // Define a closure that references originalList but doesn't ever
  // actually get called. But because this closure exists,
  // originalList will be in the lexical environment for all
  // closures defined in replaceList, instead of being optimized
  // out of it. If this function is removed, there is no leak.
  var idle = function () {
    if (originalList)
      console.log("nice");
  };
  thisList = {
    thisArray: new Array(2000000).join('*'),
    thisMethod: function () {}
  };
  // If you add `originalList = null` here, there is no leak.
  originalList = null
};
setInterval(replaceList, 1000);</pre>
<p>在上面的代码示例中，虽然<code>thisList</code>可以访问<code>originalList</code>，但它并不使用它。但是因为<code>originalList</code>是词汇环境的一部分，<code>thisMethod</code>将持有对<code>originalList</code>的引用。因此，即使我们用没有有效方法引用旧值<code>thisList</code>的东西替换<code>thisList</code>，旧值也不会被垃圾收集器清除。如果有一个大对象被一些闭包使用，但没有被任何需要继续使用的闭包使用，那么只要确保一旦使用完局部变量就不再指向它。</p>
<h2>结论</h2>
<p>React Native是一个很棒的框架，融合了web和移动开发。只需使用一种语言——JavaScript，就可以为Android和iOS设备编写应用程序。虽然它在影响应用程序的整体性能方面可能有缺点，但这些缺点中的大部分都可以避免或改进，从而为移动应用程序创建整体更好的用户体验。</p>
<p> </p>
<p> </p><div class="code-block code-block-18">
<div class="blog-plug inline-plug react-native-plug"><h2><a href="https://lp.logrocket.com/blg/react-native-signup"> LogRocket </a>:即时重现React原生应用中的问题。</h2><a class="signup" href="https://lp.logrocket.com/blg/react-native-signup" target="_blank" rel="noopener noreferrer"><img class="alignnone size-full wp-image-46 jetpack-lazy-image" src="../Images/110055665562c1e02069b3698e6cc671.png" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2021/10/react-native-plug_v2-2.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2021/10/react-native-plug_v2-2.png"/><noscript><img data-lazy-fallback="1" class="alignnone size-full wp-image-46" src="../Images/110055665562c1e02069b3698e6cc671.png" data-original-src="https://blog.logrocket.com/wp-content/uploads/2021/10/react-native-plug_v2-2.png"/></noscript></a><p><a href="https://lp.logrocket.com/blg/react-native-signup" target="_blank" rel="noopener noreferrer"> LogRocket </a>是一款React原生监控解决方案，可帮助您即时重现问题、确定bug的优先级并了解React原生应用的性能。</p><p>LogRocket还可以向你展示用户是如何与你的应用程序互动的，从而帮助你提高转化率和产品使用率。LogRocket的产品分析功能揭示了用户不完成特定流程或不采用新功能的原因。</p><p>开始主动监控您的React原生应用— <a class="signup" href="https://lp.logrocket.com/blg/react-native-signup" target="_blank" rel="noopener noreferrer">免费试用LogRocket】。</a></p></div>
</div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
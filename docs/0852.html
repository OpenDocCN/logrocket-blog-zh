<html>
<head>
<title>Building a Trello clone with React Hooks and GraphQL - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>用React钩子和GraphQL - LogRocket博客构建一个Trello克隆</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/building-a-trello-clone-with-react-hooks-and-graphql/#0001-01-01">https://blog.logrocket.com/building-a-trello-clone-with-react-hooks-and-graphql/#0001-01-01</a></blockquote><div><article class="article-post">
<p>本文解释了如何使用React钩子和GraphqQL服务器构建一个类似Trello的应用程序。在进入应用程序之前，让我给你解释一下为什么我们需要构建它。</p>
<p>学习一个概念或技术应该在实践中结束。练习我们所学的是记忆概念的好方法。它会伴随你很长时间。这是我们制造特雷罗克隆体的主要原因。</p>
<p>同时，Trello包含了一些有趣的概念，如嵌套拖放、web套接字等。</p>
<p>现在，让我们看看如何构建这个应用程序。我们将首先为它开发后端，然后我们将开发前端。</p>
<h2>演示</h2>
<p><img data-attachment-id="18438" data-permalink="https://blog.logrocket.com/building-a-trello-clone-with-react-hooks-and-graphql/trello-demo/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/05/Trello-demo.gif" data-orig-size="730,456" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Trello-demo" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/05/Trello-demo-300x187.gif" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/05/Trello-demo.gif" decoding="async" class="aligncenter size-full wp-image-18438 jetpack-lazy-image" src="../Images/b01af900f7463f0e33d8100218b01812.png" alt="A gif of a Trello app." data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2020/05/Trello-demo.gif?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/05/Trello-demo.gif"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="18438" data-permalink="https://blog.logrocket.com/building-a-trello-clone-with-react-hooks-and-graphql/trello-demo/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/05/Trello-demo.gif" data-orig-size="730,456" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Trello-demo" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/05/Trello-demo-300x187.gif" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/05/Trello-demo.gif" decoding="async" loading="lazy" class="aligncenter size-full wp-image-18438" src="../Images/b01af900f7463f0e33d8100218b01812.png" alt="A gif of a Trello app." data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/05/Trello-demo.gif"/></noscript>
<h2>后端</h2>
<p>最初，我想用<a href="https://hasura.io/" target="_blank" rel="noopener noreferrer"> Hasura </a>，这是一个在几分钟内构建GraphQL的很棒的工具。</p>
<p>但是我们的应用程序需要一些不仅仅是CRUD的功能。尽管我们可以用Hasura编写自己的自定义解析器，但我想从头开始构建它，以便更容易地解释它。</p>
<p>在开始编写代码之前，让我们看看我们的应用程序中涉及了什么类型的实体。这里，我们有两个主要实体:</p>
<ul>
<li><strong>部分</strong>–包含所有的卡片。用户将创建一个部分，并在其中添加卡片。</li>
<li><strong>卡片</strong>–它们包含了所有的任务细节。用户创建了一个卡片，并将所有的任务细节存储在里面。<br/>T3<noscript>T5</noscript></li>
</ul>
<h2>属国</h2>
<ul>
<li><a href="https://www.npmjs.com/package/apollo-server-express" target="_blank" rel="noopener noreferrer">Apollo-server-express</a>–它有助于将Apollo graphQL服务器与ExpressJS连接起来</li>
<li><a href="https://www.npmjs.com/package/express" target="_blank" rel="noopener noreferrer">Express</a>–Express是运行服务器的Node.js框架</li>
<li>mongose–mongose连接express服务器和MongoDB</li>
<li>一个JavaScript实用程序库</li>
</ul>
<p><code>npm install apollo-server apollo-server-express express lodash mongoose</code></p>
<p>一旦我们安装了所需的依赖项，让我们创建GraphQL服务器。创建一个文件<code>server.js</code>并添加以下代码:</p>
<pre>const express = require("express");
const { ApolloServer, gql } = require("apollo-server-express");
const merge = require("lodash/merge");
const mongoose = require("mongoose");
const { PubSub } = require("apollo-server");
const { createServer } = require("http");
require("dotenv").config();

const typeDefs = gql``;

const resolvers = {};

const MONGO_USER = process.env.MONGO_USER || "root";
const MONGO_PASS = process.env.MONGODB_PASS;
mongoose
  .connect(
    `mongodb://${MONGO_USER}:${MONGO_PASS}@ds131902.mlab.com:31902/trello-hooks-graphql-clone`,
    { useNewUrlParser: true, useUnifiedTopology: true }
  )
  .then(() =&gt; {
    console.log("mongodb connected successfully");
    const server = new ApolloServer({
      typeDefs,
      resolvers
    });
    const app = express();
    server.applyMiddleware({ app });
    const httpServer = createServer(app);
    
    const PORT = process.env.PORT || 4444;
    httpServer.listen({ port: PORT }, () =&gt; {
      console.log(`Server is running in port ${PORT}`);
    });
  })
  .catch((err) =&gt; {
    console.log(err);
  });</pre>
<p>在上面的代码中，我们导入<code>ApolloServer</code>和<code>gql</code>来运行GraphQL服务器，导入Mongoose来连接MongoDB。</p>
<pre>const express = require("express");
const { ApolloServer, gql } = require("apollo-server-express");
const mongoose = require("mongoose");
const { PubSub } = require("apollo-server");
const { createServer } = require("http");
require("dotenv").config();</pre>
<p>之后，我们为Apollo GraphQL服务器定义了<code>typeDefinitions</code>和<code>resolvers</code>。</p>
<pre>const typeDefs = gql;

const resolvers = {};</pre>
<h3>类型定义</h3>
<p>它包含所有的GraphQL模式定义。这里，我们有两个实体:<strong>段</strong>和<strong>卡</strong>。大多数情况下，实体应该被定义为一种类型。</p>
<p>这里需要注意的一点是，GraphQL有两种根类型:</p>

<p>Query处理所有的获取操作，包括GET请求和REST API协议。变异处理数据操作，这是REST API中的POST请求。</p>
<h2>下决心者</h2>
<p>基本上，解析器解析我们在模式中定义的类型。例如，如果您在模式中定义了一个查询类型，那么它应该在解析器中被解析。</p>
<p>之后，我们需要将我们的服务器与MongoDB数据库连接起来。我们可以使用Mongoose connect方法来实现:</p>
<pre>const MONGO_USER = process.env.MONGO_USER || "root";
const MONGO_PASS = process.env.MONGODB_PASS;
mongoose
  .connect(
    `mongodb://${MONGO_USER}:${MONGO_PASS}@ds131902.mlab.com:31902/trello-hooks-graphql-clone`,
    { useNewUrlParser: true, useUnifiedTopology: true }
  )
  .then(() =&gt; {
    console.log("mongodb connected successfully");
  })
  .catch((err) =&gt; {
    console.log(err);
  });</pre>
<p>注意:我在这里使用的是<a href="http://mlab.com/" target="_blank" rel="noopener noreferrer"> mlab </a>托管服务。你可以在本地运行，或者使用一些托管服务，如<a href="http://mlab.com/" target="_blank" rel="noopener noreferrer"> mlab </a>或<a href="https://www.mongodb.com/cloud/atlas" target="_blank" rel="noopener noreferrer"> mongodb atlas </a>。</p>
<p>一旦我们与MongoDB成功连接，让我们创建我们的GraphQL服务器并运行它:</p>
<pre>const server = new ApolloServer({
      typeDefs,
      resolvers,
      context: () =&gt; ({
      }),
    });
    const app = express();
    server.applyMiddleware({ app });
    const httpServer = createServer(app);
    server.installSubscriptionHandlers(httpServer);
    const PORT = process.env.PORT || 4444;
    httpServer.listen({ port: PORT }, () =&gt; {
      console.log(`Server is running in port ${PORT}`);
    });</pre>
<p>到目前为止，我们已经建立了一个基本的GraphQL服务器，它与MongoDB数据库相连。现在，是时候在应用程序中创建业务逻辑了。</p>
<h3>文件结构</h3>
<p><img data-attachment-id="18449" data-permalink="https://blog.logrocket.com/building-a-trello-clone-with-react-hooks-and-graphql/card-mutation/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/05/card-mutation.png" data-orig-size="384,542" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="card-mutation" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/05/card-mutation-213x300.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/05/card-mutation.png" decoding="async" class="aligncenter wp-image-18449 jetpack-lazy-image" src="../Images/ceb56f2a40516d28e39ff58c91494cbe.png" alt="A card mutation dropdown menu." data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2020/05/card-mutation.png 384w, https://blog.logrocket.com/wp-content/uploads/2020/05/card-mutation-213x300.png 213w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2020/05/card-mutation.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/05/card-mutation.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="18449" data-permalink="https://blog.logrocket.com/building-a-trello-clone-with-react-hooks-and-graphql/card-mutation/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/05/card-mutation.png" data-orig-size="384,542" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="card-mutation" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/05/card-mutation-213x300.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/05/card-mutation.png" decoding="async" loading="lazy" class="aligncenter wp-image-18449" src="../Images/ceb56f2a40516d28e39ff58c91494cbe.png" alt="A card mutation dropdown menu." srcset="https://blog.logrocket.com/wp-content/uploads/2020/05/card-mutation.png 384w, https://blog.logrocket.com/wp-content/uploads/2020/05/card-mutation-213x300.png 213w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/05/card-mutation.png"/></noscript>
<p>我根据特征和实体来组织文件。他们被称为<a href="https://blog.risingstack.com/node-hero-node-js-project-structure-tutorial/" target="_blank" rel="noopener noreferrer">功能文件夹</a>。在每个实体或特性的内部，我有<code>index.js</code>，它是特定特性的根文件。</p>
<p><code>mutationResolvers</code>和<code>queryResolvers</code>文件夹处理查询和变异解析器，以及包含Mongoose模式模型的<code>model.js</code>文件。</p>
<h2>截面实体</h2>
<p>在为区段编写查询和变更之前，我们需要在我们的GraphQL SDL(模式定义语言)中创建区段类型。无论我们想在节中存储什么数据，都应该在类型中定义:</p>
<pre>type Section {
    id: ID!
    title: String!
    label: String!
    pos: Int!
    description: String
    cards: [Card]
 }</pre>
<p>为了更好地理解它，可以把它看作一个键值对:在左边，它将是keyname。在右边，它将是一个值类型。</p>
<p>这里，我们有值类型String和Int。</p>
<p>如果你仔细观察，我们会发现一个叫做卡片的值类型。虽然这是新的，但其他值类型很简单。</p>
<p>卡片是我们在开始时讨论过的实体。就像我们有一个叫做Section的类型。我们也有定制类型的卡。</p>
<p>为什么在类型部分中定义它？</p>
<p>在GraphQL中，我们称这些关系为<a href="https://www.apollographql.com/docs/apollo-server/schema/schema/#the-schema-definition-language" target="_blank" rel="noopener noreferrer">。</a></p>
<p>每个部分将包含许多卡片。这是1对N的关系。如果我们将其转换为GraphQL模式，它将类似于上面的类型。</p><div class="code-block code-block-54">
<hr/>
<h3>更多来自LogRocket的精彩文章:</h3>

<hr/></div>
<p>之后，我们需要为Section实体定义查询和变异类型:</p>
<pre>extend type Query {
    fetchSections: [Section]
  }
  extend type Mutation {
    insertSection(request: insertSectionInput): Section
    updateSectionPos(request: updateSectionPosInput): Section
  }</pre>
<p>这里，我们定义了查询类型<code>fetchSections</code>，这非常简单。</p>
<p>如果我们点击GraphQL查询，它应该返回所有的部分。</p>
<p>有趣的是，Mutation有两个操作字段:<code>insertSection</code>和<code>updateSectionPos</code>，还有一个参数。</p>
<p>每个根类型(查询和变异)都可以接受参数并返回数据。数据应该包括模式中定义的类型。</p>
<p><strong>重要提示</strong>:参数类型应该单独定义为GraphQL模式中的输入。您可以在GraphQL中使用Type关键字进行输入。</p>
<h2><code>index.js</code></h2>
<pre>const mutationResolvers = require("./mutationResolvers");
const queryResolvers = require("./queryResolvers");
const { gql } = require("apollo-server-express");
const sectionTypeDefs = gql`
  input insertSectionInput {
    title: String!
    label: String!
    pos: Int!
  }
  input updateSectionPosInput {
    sectionId: String!
    pos: Int!
  }
  type Section {
    id: ID!
    title: String!
    label: String!
    pos: Int!
    description: String
    cards: [Card]
  }
  extend type Query {
    hello: String
    fetchSections: [Section]
  }
  extend type Mutation {
    insertSection(request: insertSectionInput): Section
    updateSectionPos(request: updateSectionPosInput): Section
  }
`;
const sectionResolvers = {
  Query: {
    ...queryResolvers,
  },
  Mutation: {
    ...mutationResolvers,
  },
};
module.exports = {
  sectionTypeDefs,
  sectionResolvers,
};</pre>
<h2>模型</h2>
<p>在编写查询和变异的解析器之前，让我们为以下部分创建Mongoose模型:</p>
<pre>const Mongoose = require("mongoose");
const sectionSchema = new Mongoose.Schema({
  title: {
    type: String,
    required: true,
  },
  label: {
    type: String,
    required: true,
  },
  description: String,
  pos: {
    type: Number,
    required: true,
  },
});


class Section {
  static getSections() {
    return this.find().sort("pos").exec();
  }
  static getSectionById(sectionId) {
    return this.findOne({
      _id: Mongoose.mongo.ObjectID(sectionId),
    }).exec();
  }
  static insertSection(sectionInfo) {
    const section = this(sectionInfo);
    return section.save();
  }
  static updatePos(sectionId, pos) {
    return this.findOneAndUpdate(
      {
        _id: Mongoose.mongo.ObjectID(sectionId),
      },
      {
        $set: {
          pos,
        },
      },
      {
        new: true,
      }
    ).exec();
  }
}
sectionSchema.loadClass(Section);
module.exports = Mongoose.model("Section", sectionSchema);</pre>
<p>一旦我们为这个部分创建了模型，我们就可以直接将它导入到我们的解析器中，并在那里使用它。然而，这将在我们的解析器中创建一个依赖项，所以将依赖项注入解析器总是好的。</p>
<p>为此，我们有了GraphQL上下文。GraphQL上下文将与我们应用程序中的所有解析器共享。所以，我们可以在上下文中传递这个模型。</p>
<p>让我们这样做:</p>
<pre>const server = new ApolloServer({
      typeDefs,
      resolvers,
      context: () =&gt; ({
        card: cardModel,
        section: sectionModel
      }),
    });</pre>
<h2>变化</h2>
<p>让我们为Section实体编写变异解析器。它包含两个突变。它们是:</p>
<ul>
<li>插入部分</li>
<li>更新部分数据</li>
</ul>
<p><code>insertSection.js</code></p>
<pre>module.exports = async (__, args, cxt) =&gt; {
  try {
    const sectionInfo = {
      title: args.request.title,
      label: args.request.label,
      pos: args.request.pos,
    };
    const section = await cxt.section.insertSection(sectionInfo);
    cxt.publisher.publish(cxt.SUBSCRIPTION_CONSTANTS.SECTION_ADDED, {
      sectionAdded: section,
    });
    return section;
  } catch (e) {
    console.log(e);
    return null;
  }
};</pre>
<p>在这里，我们将数据插入Mongodb。这里需要注意的重要一点是，我们没有直接向这个解析器中导入任何东西，这使得测试过程更加容易。</p>
<h2>询问</h2>
<p>查询类似于GraphQL中的突变，除了它不改变数据库中的数据。</p>
<p>一旦我们完成了截面实体，让我们将它添加到我们的<code>server.js</code>文件中:</p>
<pre>const express = require("express");
const { ApolloServer, gql } = require("apollo-server-express");
const merge = require("lodash/merge");
const mongoose = require("mongoose");
const { createServer } = require("http");
require("dotenv").config();
const { sectionResolvers, sectionTypeDefs } = require("./section");
const sectionModel = require("./section/model");
const typeDefs = gql`
  ${cardTypeDefs}
`;

const customResolvers = {
  Section: {
    cards(parent, args, cxt) {
      return cxt.card.getCardBySectionId(parent._id);
    },
  },
};
const resolvers = merge(
  sectionResolvers,
);
const MONGO_USER = process.env.MONGO_USER || "root";
const MONGO_PASS = process.env.MONGODB_PASS;
mongoose
  .connect(
    `mongodb://${MONGO_USER}:${MONGO_PASS}@ds131902.mlab.com:31902/trello-hooks-graphql-clone`,
    { useNewUrlParser: true, useUnifiedTopology: true }
  )
  .then(() =&gt; {
    console.log("mongodb connected successfully");
    const server = new ApolloServer({
      typeDefs,
      resolvers,
      context: () =&gt; ({
        section: sectionModel
      }),
    });
    const app = express();
    server.applyMiddleware({ app });
    const httpServer = createServer(app);
    server.installSubscriptionHandlers(httpServer);
    const PORT = process.env.PORT || 4444;
    httpServer.listen({ port: PORT }, () =&gt; {
      console.log(`Server is running in port ${PORT}`);
    });
  })
  .catch((err) =&gt; {
    console.log(err);
  });</pre>
<p>点击此处查看完整的截面实体<a href="https://github.com/ganeshmani/react-hooks-graphql-trello-clone/tree/master/server/section" target="_blank" rel="noopener noreferrer">。</a></p>
<h2>卡实体</h2>
<p>卡的功能类似于第节。</p>
<p><img data-attachment-id="18455" data-permalink="https://blog.logrocket.com/building-a-trello-clone-with-react-hooks-and-graphql/card-entity/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/05/card-entity.png" data-orig-size="436,530" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="card-entity" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/05/card-entity-247x300.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/05/card-entity.png" decoding="async" class="aligncenter wp-image-18455 jetpack-lazy-image" src="../Images/a09ce97d109e98c60817efa93566ea25.png" alt="card entity." data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2020/05/card-entity.png 436w, https://blog.logrocket.com/wp-content/uploads/2020/05/card-entity-247x300.png 247w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2020/05/card-entity.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/05/card-entity.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="18455" data-permalink="https://blog.logrocket.com/building-a-trello-clone-with-react-hooks-and-graphql/card-entity/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/05/card-entity.png" data-orig-size="436,530" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="card-entity" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/05/card-entity-247x300.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/05/card-entity.png" decoding="async" loading="lazy" class="aligncenter wp-image-18455" src="../Images/a09ce97d109e98c60817efa93566ea25.png" alt="card entity." srcset="https://blog.logrocket.com/wp-content/uploads/2020/05/card-entity.png 436w, https://blog.logrocket.com/wp-content/uploads/2020/05/card-entity-247x300.png 247w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/05/card-entity.png"/></noscript>
<h3>模型</h3>
<pre>const Mongoose = require("mongoose");
const cardSchema = new Mongoose.Schema(
  {
    title: {
      type: String,
      required: true,
    },
    label: {
      type: String,
      required: true,
    },
    description: String,
    pos: {
      type: Number,
      required: true,
    },
    sectionId: {
      type: Mongoose.Schema.Types.ObjectId,
      ref: "Section",
    },
  },
  { timestamps: true }
);
class Card {
  static insertCard(cardInfo) {
    const card = this(cardInfo);
    return card.save();
  }
  static getCardBySectionId(sectionId) {
    return this.find({ sectionId }).sort("pos").exec();
  }
  static updatePos(cardId, pos, sectionId) {
    return this.findOneAndUpdate(
      {
        _id: Mongoose.mongo.ObjectID(cardId),
      },
      {
        $set: {
          pos,
          sectionId,
        },
      }
    ).exec();
  }
}
cardSchema.loadClass(Card);
module.exports = Mongoose.model("Card", cardSchema);</pre>
<p>其他功能类似于截面实体。你可以在这里查看完整的源代码。</p>
<h2>捐款</h2>
<p>我们来到了GraphQL服务器中另一个有趣的话题。订阅处理GraphQL中的web套接字连接。</p>
<p>让我们使用订阅为我们的GraphQL服务器实现web套接字。就像查询和变异一样，订阅是GraphQL中的一个根类型:</p>
<pre>const { PubSub } = require("apollo-server");

const typeDefs = gql`
type Subscription {
    sectionAdded: Section
    cardAdded: Card
    onSectionPosChange: Section
    onCardPosChange: Card
  }
`

const SubscriptionsResolvers = {
  Subscription: {
    sectionAdded: {
      subscribe: () =&gt;
        pubsub.asyncIterator([SUBSCRIPTION_CONSTANTS.SECTION_ADDED]),
    },
    cardAdded: {
      subscribe: () =&gt;
        pubsub.asyncIterator([SUBSCRIPTION_CONSTANTS.CARD_ADDED]),
    },
    onSectionPosChange: {
      subscribe: () =&gt;
        pubsub.asyncIterator([SUBSCRIPTION_CONSTANTS.ON_SECTION_POS_CHANGE]),
    },
    onCardPosChange: {
      subscribe: () =&gt;
        pubsub.asyncIterator([SUBSCRIPTION_CONSTANTS.ON_CARD_POS_CHANGE]),
    },
  },
};

const resolvers = merge(
  cardResolvers,
  sectionResolvers,
  SubscriptionsResolvers
);</pre>
<p>一旦我们在<code>server.js</code>中定义了订阅，我们需要在适当的变化中调用pub sub。</p>
<p>例如，在<code>insertSection.js</code>文件中，我们需要调用发布者来使订阅在我们的服务器上工作。</p>
<pre>cxt.publisher.publish(cxt.SUBSCRIPTION_CONSTANTS.CARD_ADDED, {
      cardAdded: card,
    });</pre>
<p>注意:我们将发布者依赖注入到解析器中，就像我们在模型中所做的一样。</p>
<p>完整的服务器代码可以在<a href="https://github.com/ganeshmani/react-hooks-graphql-trello-clone/tree/master/server" target="_blank" rel="noopener noreferrer">这里</a>找到。</p>
<h2>前端</h2>
<p>让我们开始构建应用程序中更有趣的部分。</p>
<pre>npx create-react-app trello-clone</pre>
<h3>属国</h3>
<ul>
<li><a href="https://www.apollographql.com/docs/react/api/react-hooks/" target="_blank" rel="noopener noreferrer">@ Apollo/React-Hooks</a>–使用React Hooks处理GraphQL操作，例如查询、变异和订阅。</li>
<li><a href="https://www.npmjs.com/package/graphql" target="_blank" rel="noopener noreferrer">GraphQL</a>–需要在客户端运行graph QL。</li>
<li><a href="https://www.npmjs.com/package/react-smooth-dnd" target="_blank" rel="noopener noreferrer">react-smooth-dnd</a>–处理React应用程序中发生的所有拖放操作。</li>
<li><a href="https://styled-components.com/" target="_blank" rel="noopener noreferrer">样式化组件</a>–我们将在应用程序中使用样式化组件。</li>
</ul>
<pre>npm install @apollo/react-hooks apollo-link apollo-link-http apollo-link-ws graphql graphql-tag react-smooth-dnd</pre>
<p>查看这篇<a href="https://blog.logrocket.com/comparing-hooks-libraries-for-graphql/" target="_blank" rel="noopener noreferrer">文章</a>，了解如何在React应用程序中设置GrapQL挂钩:</p>
<pre>import React from "react";
import "./App.css";
import Board from "./components/Board/Board";
import { ApolloProvider } from "@apollo/react-hooks";
import { HttpLink } from "apollo-link-http";
import { split } from "apollo-link";
import { getMainDefinition } from "apollo-utilities";
import { InMemoryCache } from "apollo-cache-inmemory";
import ApolloClient from "apollo-client";
import { WebSocketLink } from "apollo-link-ws";
const httpLink = new HttpLink({
  uri: "http://localhost:4444/graphql",
});
const wsLink = new WebSocketLink({
  uri: "ws://localhost:4444/graphql",
  options: {
    reconnect: true,
  },
});
const link = split(
  ({ query }) =&gt; {
    const { kind, operation } = getMainDefinition(query);
    return kind === "OperationDefinition" &amp;&amp; operation === "subscription";
  },
  wsLink,
  httpLink
);
const client = new ApolloClient({
  link,
  cache: new InMemoryCache(),
});
function App() {
  return (</pre>
<p>React中的组件</p>
<p><img data-attachment-id="18462" data-permalink="https://blog.logrocket.com/building-a-trello-clone-with-react-hooks-and-graphql/board-component-trello/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/05/board-component-trello.png" data-orig-size="607,271" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="board-component-trello" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/05/board-component-trello-300x134.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/05/board-component-trello.png" decoding="async" class="aligncenter wp-image-18462 jetpack-lazy-image" src="../Images/ef91a59749188c6d50d2e9b9a9639626.png" alt="board-component-trello.png" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2020/05/board-component-trello.png 607w, https://blog.logrocket.com/wp-content/uploads/2020/05/board-component-trello-300x134.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2020/05/board-component-trello.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/05/board-component-trello.png"/></p>
<pre>  );
}
export default App;</pre>
<h3>让我们创建电路板组件:</h3>
<p>在上面的代码中，cards容器功能以及Add Section按钮将触发GraphQL中的变异。</p><noscript><img data-lazy-fallback="1" data-attachment-id="18462" data-permalink="https://blog.logrocket.com/building-a-trello-clone-with-react-hooks-and-graphql/board-component-trello/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/05/board-component-trello.png" data-orig-size="607,271" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="board-component-trello" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/05/board-component-trello-300x134.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/05/board-component-trello.png" decoding="async" loading="lazy" class="aligncenter wp-image-18462" src="../Images/ef91a59749188c6d50d2e9b9a9639626.png" alt="board-component-trello.png" srcset="https://blog.logrocket.com/wp-content/uploads/2020/05/board-component-trello.png 607w, https://blog.logrocket.com/wp-content/uploads/2020/05/board-component-trello-300x134.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/05/board-component-trello.png"/></noscript>
<p>一旦添加了一个部分，subscription将返回数据并将其添加到我们在组件中定义的Boards状态。</p>
<pre>import React, { useState, useEffect } from "react";
import CardContainer from "./Cards/CardsContainer";
import { IoIosAdd } from "react-icons/io";
import sortBy from "lodash/sortBy";
import {
  BoardContainer,
  CardHorizontalContainer,
  AddSectionDiv,
  AddSectionForm,
  AddSectionLink,
  AddSectionLinkSpan,
  AddSectionLinkIconSpan,
  AddSectionInput,
  ActiveAddSectionInput,
  SubmitCardButtonDiv,
  SubmitCardButton,
  SubmitCardIcon,
} from "./board.styles";
const Board = () =&gt; {
  const [isAddSectionInputActive, setAddSectionInputActive] = useState(false);
  const [addSectionInpuText, setAddSectionInputText] = useState("");
  const [boards, setBoards] = useState([]);
  
  const onAddSectionSubmit = () =&gt; {
    if (addSectionInpuText) {
      //Add Section Logic comes here
    }
  };
  return (
    &lt;BoardContainer&gt;
      //Card Container Logic Comes Here
      &lt;AddSectionDiv onClick={() =&gt; setAddSectionInputActive(true)}&gt;
        &lt;AddSectionForm&gt;
          {isAddSectionInputActive ? (
            &lt;React.Fragment&gt;
              &lt;ActiveAddSectionInput
                onChange={(e) =&gt; setAddSectionInputText(e.target.value)}
              /&gt;
              &lt;SubmitCardButtonDiv&gt;
                &lt;SubmitCardButton
                  type="button"
                  value="Add Card"
                  onClick={onAddSectionSubmit}
                /&gt;
                &lt;SubmitCardIcon&gt;
                  &lt;IoIosAdd /&gt;
                &lt;/SubmitCardIcon&gt;
              &lt;/SubmitCardButtonDiv&gt;
            &lt;/React.Fragment&gt;
          ) : (
            &lt;React.Fragment&gt;
              &lt;AddSectionLink href="#"&gt;
                &lt;AddSectionLinkSpan&gt;
                  &lt;IoIosAdd size={28} /&gt;
                  Add another list
                &lt;/AddSectionLinkSpan&gt;
              &lt;/AddSectionLink&gt;
              &lt;AddSectionInput /&gt;
            &lt;/React.Fragment&gt;
          )}
        &lt;/AddSectionForm&gt;
      &lt;/AddSectionDiv&gt;
    &lt;/BoardContainer&gt;
  );
};
export default Board;</pre>
<p>让我们添加变异和初始获取查询，并在组件中导入React挂钩:</p>
<p>之后，定义查询、变异和订阅:</p>
<p>一旦它被定义，让我们对GraphQL操作使用React钩子。</p>
<pre>import { useMutation, useSubscription, useQuery } from "@apollo/react-hooks";
import gql from "graphql-tag";</pre>
<p><code>useQuery</code>返回负载、错误和数据值，我们可以用它们来显示状态。</p>
<pre>const BOARD_QUERY = gql`
  query {
    fetchSections {
      id
      title
      label
      pos
      description
      cards {
        id
        title
        label
        description
        pos
      }
    }
  }
`;
const BOARD_SUBSCRIPTION = gql`
  subscription {
    sectionAdded {
      id
      title
      label
      description
      pos
      cards {
        id
        title
        label
        pos
        description
      }
    }
  }
`;
const ADD_SECTION = gql`
  mutation AddSection($title: String!, $label: String!, $pos: Int!) {
    insertSection(request: { title: $title, label: $label, pos: $pos }) {
      title
      description
      id
      label
    }
  }
`;</pre>
<p>一旦我们得到数据，我们就在状态中设置它，并在组件中呈现它。</p>
<pre>const { loading, error, data } = useQuery(BOARD_QUERY);</pre>
<p>现在，让我们在组件中添加<code>useMutation</code>挂钩:</p>
<p>一切看起来都很棒。但是，当我们添加该部分时，它只会在用户刷新页面后才会反映出来。我们可以通过向我们的应用程序添加订阅来解决这个问题:</p>
<pre> useEffect(() =&gt; {
    if (data) {
      setBoards(data.fetchSections);
    }
  }, [data]);

//render
 {boards.length &gt; 0 &amp;&amp;
    boards.map((item, index) =&gt; (
      &lt;CardContainer item={item} key={index} boards={boards} /&gt;
  ))}</pre>
<p>我们已经成功地将API添加到组件中。让我们看看如何将拖放集成到我们的应用程序中。</p>
<pre>  const [AddSection, { insertSection }] = useMutation(ADD_SECTION);

  //when use clicks the add Section button
const onAddSectionSubmit = () =&gt; {
    if (addSectionInpuText) {
      AddSection({
        variables: {
          title: addSectionInpuText,
          label: addSectionInpuText,
          pos:
            boards &amp;&amp; boards.length &gt; 0
              ? boards[boards.length - 1].pos + 16384
              : 16384,
        },
      });
    }
  };</pre>
<p>拖放</p>
<pre>  const { data: { sectionAdded } = {} } = useSubscription(BOARD_SUBSCRIPTION);

//useEffect will be called whenever Subscriptions is called

useEffect(() =&gt; {
    if (sectionAdded) {
      setBoards(boards.concat(sectionAdded));
    }
  }, [sectionAdded]);</pre>
<p>首先，将所需的库导入我们的组件:</p>
<h3>之后，用Dnd容器包装我们的组件:</h3>
<p>查看此<a href="https://github.com/kutlugsahin/react-smooth-dnd" target="_blank" rel="noopener noreferrer">回购</a>以了解更多关于功能和道具的信息。</p>
<pre>import { Container } from "react-smooth-dnd";</pre>
<p>一旦我们包装了我们的组件，我们需要将一个函数绑定到<code>onDrop</code> props。</p>
<pre>&lt;Container
        orientation={"horizontal"}
        onDrop={onColumnDrop}
        onDragStart={() =&gt; {
          console.log("on drag start");
        }}
        getChildPayload={(index) =&gt; {
          return boards[index];
        }}
        dragHandleSelector=".column-drag-handle"
        dropPlaceholder={{
          animationDuration: 150,
          showOnTop: true,
          className: "cards-drop-preview",
        }}
      &gt;
    //Our Component comes here
   &lt;/Container&gt;</pre>
<p>有趣的部分来了:一旦我们得到了<code>removedIndex</code>、<code>addedIndex</code>和<code>payload</code>，我们就使用一个效用函数来计算更新后的位置。让我们看看它是如何工作的。</p>
<p>Trello POS的工作原理</p>
<pre>const onColumnDrop = ({ removedIndex, addedIndex, payload }) =&gt; {
    if (data) {
      let updatePOS = PosCalculation(
        removedIndex,
        addedIndex,
        data.fetchSections
      );
      let newBoards = boards.map((board) =&gt; {
        if (board.id === payload.id) {
          return { ...board, pos: updatePOS };
        } else {
          return board;
        }
      });
      let sortedBoards = sortBy(newBoards, [
        (board) =&gt; {
          return board.pos;
        },
      ]);
      setBoards([...sortedBoards]);
      
      //Graphql Mutation Comes Here
    }
  };</pre>
<p><img data-attachment-id="18469" data-permalink="https://blog.logrocket.com/building-a-trello-clone-with-react-hooks-and-graphql/if-position-is-moving-from-right-to-left/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/05/If-position-is-moving-from-right-to-left.png" data-orig-size="452,611" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="If-position-is-moving-from-right-to-left" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/05/If-position-is-moving-from-right-to-left-222x300.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/05/If-position-is-moving-from-right-to-left.png" decoding="async" class="aligncenter wp-image-18469 jetpack-lazy-image" src="../Images/0cf4c06504c2cc676686384f3f973d8d.png" alt="Diagram for moving a Trello card from right to left." data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2020/05/If-position-is-moving-from-right-to-left.png 452w, https://blog.logrocket.com/wp-content/uploads/2020/05/If-position-is-moving-from-right-to-left-222x300.png 222w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2020/05/If-position-is-moving-from-right-to-left.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/05/If-position-is-moving-from-right-to-left.png"/></p>
<h3>如果它从左向右移动，逻辑将是:</h3>
<p><img data-attachment-id="18470" data-permalink="https://blog.logrocket.com/building-a-trello-clone-with-react-hooks-and-graphql/if-position-is-moving-from-right-to-left-2/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/05/If-position-is-moving-from-right-to-left-1.png" data-orig-size="452,611" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="If-position-is-moving-from-right-to-left" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/05/If-position-is-moving-from-right-to-left-1-222x300.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/05/If-position-is-moving-from-right-to-left-1.png" decoding="async" class="aligncenter wp-image-18470 jetpack-lazy-image" src="../Images/c302d978021f66a6ff1e6efcf140857a.png" alt="Diagram of a Trello card from left to right." data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2020/05/If-position-is-moving-from-right-to-left-1.png 452w, https://blog.logrocket.com/wp-content/uploads/2020/05/If-position-is-moving-from-right-to-left-1-222x300.png 222w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2020/05/If-position-is-moving-from-right-to-left-1.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/05/If-position-is-moving-from-right-to-left-1.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="18469" data-permalink="https://blog.logrocket.com/building-a-trello-clone-with-react-hooks-and-graphql/if-position-is-moving-from-right-to-left/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/05/If-position-is-moving-from-right-to-left.png" data-orig-size="452,611" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="If-position-is-moving-from-right-to-left" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/05/If-position-is-moving-from-right-to-left-222x300.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/05/If-position-is-moving-from-right-to-left.png" decoding="async" loading="lazy" class="aligncenter wp-image-18469" src="../Images/0cf4c06504c2cc676686384f3f973d8d.png" alt="Diagram for moving a Trello card from right to left." srcset="https://blog.logrocket.com/wp-content/uploads/2020/05/If-position-is-moving-from-right-to-left.png 452w, https://blog.logrocket.com/wp-content/uploads/2020/05/If-position-is-moving-from-right-to-left-222x300.png 222w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/05/If-position-is-moving-from-right-to-left.png"/></noscript>
<p>让我们编写POS计算的功能:</p>
<p>之后，我们用一个新的pos更新状态，并调用一个GraphQL API来更新我们的服务器。</p><noscript><img data-lazy-fallback="1" data-attachment-id="18470" data-permalink="https://blog.logrocket.com/building-a-trello-clone-with-react-hooks-and-graphql/if-position-is-moving-from-right-to-left-2/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/05/If-position-is-moving-from-right-to-left-1.png" data-orig-size="452,611" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="If-position-is-moving-from-right-to-left" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/05/If-position-is-moving-from-right-to-left-1-222x300.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/05/If-position-is-moving-from-right-to-left-1.png" decoding="async" loading="lazy" class="aligncenter wp-image-18470" src="../Images/c302d978021f66a6ff1e6efcf140857a.png" alt="Diagram of a Trello card from left to right." srcset="https://blog.logrocket.com/wp-content/uploads/2020/05/If-position-is-moving-from-right-to-left-1.png 452w, https://blog.logrocket.com/wp-content/uploads/2020/05/If-position-is-moving-from-right-to-left-1-222x300.png 222w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/05/If-position-is-moving-from-right-to-left-1.png"/></noscript>
<p>卡片组件</p>
<pre>export default function (removedIndex, addedIndex, arr) {
  let pos;
  if (addedIndex === arr.length - 1) {
    pos = arr[arr.length - 1].pos + 16384;
  } else if (addedIndex === 0) {
    pos = arr[0].pos / 2;
  } else if (addedIndex &lt; removedIndex) {
    let beforePOS = arr[addedIndex - 1].pos;
    let afterPOS = arr[addedIndex].pos;
    pos = (beforePOS + afterPOS) / 2;
  } else if (addedIndex &gt; removedIndex) {
    let beforePOS = arr[addedIndex + 1].pos;
    let afterPOS = arr[addedIndex].pos;
    pos = (beforePOS + afterPOS) / 2;
  }
  return pos;
}</pre>
<p>卡片组件和拖放的功能将类似于我们在纸板组件中所做的。我会让你们把它当作一个练习，并在下面的评论中展示你们的进步。</p>
<h3>不过作为参考，看看这个<a href="https://github.com/ganeshmani/react-hooks-graphql-trello-clone" target="_blank" rel="noopener noreferrer">回购</a>。</h3>
<p>结论</p>
<p>正如我在本文开头所说，克隆一个应用程序将是学习一项技术/概念的好方法。试着自己重建它，并在下面的评论中告诉我进展如何。</p>
<h2>实践可以让你成为更好的开发者和问题解决者。</h2>
<p>编码快乐！</p>
<p>点击查看完整源代码<a href="https://github.com/ganeshmani/react-hooks-graphql-trello-clone" target="_blank" rel="noopener noreferrer">。</a></p>
<p>使用LogRocket消除传统反应错误报告的噪音</p>
<p>是一款React analytics解决方案，可保护您免受数百个误报错误警报的影响，只针对少数真正重要的项目。LogRocket告诉您React应用程序中实际影响用户的最具影响力的bug和UX问题。</p><div class="code-block code-block-17">
<div class="blog-plug inline-plug react-plug" vwo-el-id="26283398190">
<h2 vwo-el-id="41600691720">自动聚合客户端错误、反应错误边界、还原状态、缓慢的组件加载时间、JS异常、前端性能指标和用户交互。然后，LogRocket使用机器学习来通知您影响大多数用户的最具影响力的问题，并提供您修复它所需的上下文。</h2>
<a href="https://lp.logrocket.com/blg/react-signup-issue-free" target="_blank" vwo-el-id="19356441070">LogRocket
</a><p>关注重要的React bug—<a class="signup" href="https://lp.logrocket.com/blg/react-signup-issue-free" target="_blank" rel="noopener noreferrer" vwo-el-id="40093418840">今天就试试LogRocket】。</a></p><a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="19356441380">
<img class="first-react-image alignnone size-full wp-image-46 jetpack-lazy-image jetpack-lazy-image--handled" src="../Images/f300c244a1a1cf916df8b4cb02bec6c6.png" vwo-el-id="18272717540" data-lazy-loaded="1" data-original-src="https://files.readme.io/27c94e7-Image_2017-06-05_at_9.46.04_PM.png"/>
</a>
<a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="19356441690">
<img class="second-react-image alignnone size-full wp-image-46 jetpack-lazy-image jetpack-lazy-image--handled" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" vwo-el-id="30720362350" data-lazy-loaded="1" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/>
</a>
<a href="https://lp.logrocket.com/blg/react-signup-issue-free" target="_blank" rel="noopener noreferrer" vwo-el-id="35866400580">LogRocket
</a><p> automatically aggregates client side errors, React error boundaries, Redux state, slow component load times, JS exceptions, frontend performance metrics, and user interactions. Then LogRocket uses machine learning to notify you of the most impactful problems affecting the most users and provides the context you need to fix it.

</p><p vwo-el-id="28675661060">Focus on the React bugs that matter —
<a class="signup" href="https://lp.logrocket.com/blg/react-signup-issue-free" target="_blank" rel="noopener noreferrer" vwo-el-id="40093418840">try LogRocket today</a>.
</p>
</div></div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
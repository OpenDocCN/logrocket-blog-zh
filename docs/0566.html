<html>
<head>
<title>Web security 101 - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>网络安全101 -日志火箭博客</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/web-security-101/#0001-01-01">https://blog.logrocket.com/web-security-101/#0001-01-01</a></blockquote><div><article class="article-post">
<p>网络安全是一个巨大的话题。为了保证你的用户(和你自己)的安全，你需要注意的事情可能会很多。尽管如此，还是有一些概念和建议可以解决最重要的问题，并且易于学习和理解。让我们来看看。</p>
<h2>协议级别的安全性</h2>
<h3>使用HTTPs</h3>
<p>根据Firefox的数据，大约80%的页面加载使用HTTPs，所以这已经是一个很好的惯例了。使用HTTPs可以让您的用户拥有安全性和隐私。它会加密他们和你的服务器之间的信息，包括密码和其他敏感信息，如电子邮件，物理地址等。几年前，在你的服务器上设置HTTPs可能很难，而且很贵，但是现在多亏了<a href="https://letsencrypt.org/" target="_blank" rel="noopener noreferrer">让我们加密</a>，这变得容易多了，而且免费。</p>
<h3>明智地使用HTTP头</h3>
<p>浏览器有能力启用一些安全机制，但前提是你通过HTTP头告诉它们这样做。例如，您可以告诉浏览器禁止使用<code>X-Frame-Options</code>头在iframe中加载您的网站。这将防止您的用户成为点击劫持攻击的目标。</p>
<p>在helmetjs 网站上可以找到许多这样的标题和它们的作用。Helmet.js是一个优秀且易于使用的库，它允许你轻松地为<a href="https://expressjs.com/" target="_blank" rel="noopener noreferrer"> express </a>应用启用这些安全机制。</p>
<p>这些头大部分都很容易使用，然后我们有一个<code>Content-Security-Policy</code>头，有点复杂，默认情况下Helmet.js不启用。通过这个头，你可以配置哪些URL允许或不允许加载JavaScript、CSS、图像等。这个头的想法是减轻任何代码注入攻击。例如，如果攻击者知道如何在您的网站中注入JavaScript，他们可能会从您的用户那里收集一些信息，并通过AJAX发送到他们控制的服务器。但是，如果您正确设置了内容安全策略头(CSP ),即使他们可以注入JavaScript，他们也无法将窃取的信息发送到他们的服务器。</p>
<h3>不要通过HTTP状态代码泄露信息</h3>
<p>如果你在用户提供的URL中使用标识符(例如<a href="http://example.com/my-super-secret-project-name" rel="nofollow">http://example.com/my-super-secret-project-name</a>)，那么在实现授权时，如果资源存在但用户没有访问权，你就不应该返回403。如果您这样做，就等于暗示攻击者该资源是存在的。在这种情况下，您应该返回404，这样攻击者就不知道资源是否存在，他们只是没有访问它的权限，或者它根本不存在。</p>
<h2>证明</h2>
<p>在我看来，认证是web安全中最复杂的话题。你可以写一整本书，但仍然不能涵盖所有内容。然而，有几个方面是基本的，实现起来并不太难。</p>
<h3>如何存储用户密码</h3>
<p>当然，不要以纯文本形式存储密码。您需要以安全的方式存储一些东西，以便能够在用户登录时验证他们的密码。您不一定需要存储密码本身，而是存储一些允许您与用户在登录表单中输入的内容相匹配的内容。有一个很好的加密原语叫做hash，它允许你这么做。</p>
<p>哈希函数接收纯文本，并输出一个通常存储为十六进制字符的值。问题是从输出中计算纯文本是相当困难的。因此，即使有人能够窃取您的数据库，他们也很难从哈希中计算出密码。但是，如何使用散列函数呢？很简单！当用户第一次输入密码(或想要更改密码)时，您存储<code>hash(users_input)</code>，当他们登录时，您将存储的值与他们提供的密码<code>hash(password) == stored_value</code>进行比较。但是，你最好使用一个定时安全比较，比如<a href="https://nodejs.org/api/crypto.html#crypto_crypto_timingsafeequal_a_b" target="_blank" rel="noopener noreferrer"> crypto.timingSafeEqual </a>来避免定时攻击。</p>
<p>这是一个好的开始，但是还有几件事情需要记住。首先，您应该给密码加盐，因为普通的散列函数对于相同的输入将返回相同的输出。这意味着您可以用最常见的密码生成一个散列列表，如<code>hash('1234')</code>、<code>hash('love')</code>，并将其与数据库中存储的内容进行比较。如果你是一个拥有数据库的攻击者，这不会给你所有人的密码，但会给你很多密码！</p>
<p>这叫做<a href="https://en.wikipedia.org/wiki/Rainbow_table" target="_blank" rel="noopener noreferrer">彩虹桌</a>。为了防止这种情况，您可以生成一个随机数(称为salt ),以明文形式存储在密码哈希附近，然后用<code>hash(salt + password)</code>计算哈希。</p>
<p>还有什么？嗯，你也应该选择一个慢哈希函数或者多次哈希，因为有些哈希函数非常快，这是一个安全问题。为什么？因为如果攻击者真的对某人的密码/访问权感兴趣，他们可能会尝试数千或数百万个密码，看看他们能否破解散列。在这种情况下，如果散列函数很快，他们的工作就简单多了。然而，如果散列函数很慢(例如300毫秒对10毫秒)，你就让事情变得更慢。想象一下慢30倍可能意味着要花30年而不是1年才能破解。</p>
<p>我应该使用什么散列函数？好的，好问题。SHA和MD5等基本函数不适合哈希密码。对于散列密码，您更喜欢使用bcrypt、<a href="https://nodejs.org/api/crypto.html#crypto_crypto_scrypt_password_salt_keylen_options_callback" target="_blank" rel="noopener noreferrer"> scrypt </a>或<a href="https://nodejs.org/api/crypto.html#crypto_crypto_pbkdf2_password_salt_iterations_keylen_digest_callback" target="_blank" rel="noopener noreferrer"> pbkdf2 </a>。</p>
<h3>如何重置用户密码</h3>
<p>用户往往会忘记他们的密码，所以你需要一种机制，允许他们以某种方式识别自己，并能够设置一个新的密码。这可能很棘手，因为根据您的操作方式，您可能会引入安全漏洞。通常，你会发送一封电子邮件到他们的电子邮件地址，提供一个重置链接。此链接应该过期，并且应该具有一定的随机性，这样攻击者就无法建立重置链接。这是需要记住的两件基本事情。然而，还有许多其他的事情你可能想考虑进去，为此，我推荐<a href="https://www.troyhunt.com/everything-you-ever-wanted-to-know/" target="_blank" rel="noopener noreferrer">这个指南</a>。</p>
<h3>延迟错误的凭据响应</h3>
<p>如果您在操作系统的登录屏幕中输入了无效的凭据，您可能会意识到需要一点时间才能再次启用登录表单。这是为什么呢？很简单，出于同样的原因，我们希望我们的散列函数很慢，我们希望通过做得慢一点来减轻暴力攻击。速度太慢，对用户来说没什么大不了的，但对攻击者来说，这是一个大问题。</p>
<p>然而，这只能阻止不并行处理请求的简单暴力攻击。为了获得额外的保护，您应该按IP对登录尝试进行速率限制，如果您想要更加安全，为了避免来自不同IP的对同一用户的暴力攻击，您应该按用户帐户进行速率限制。</p>
<p>很复杂吧。是的，就像我说的，你可以写一整本书专门讨论这个话题。然而，一切都取决于你所掌握的信息的价值。</p>
<h3>无通行证通行</h3>
<p>如你所见，密码是有问题的。即使你做了所有正确的事情(比如正确地计算和存储哈希值，尽可能安全地执行重置功能，等等)，你也无法阻止人们在许多服务中重复使用相同的密码，或者选择一个他们身边的人可能会猜到的弱密码。有其他选择吗？嗯，有，这里有几个:</p>
<ul>
<li><strong>使用登录链接</strong>——一些应用程序(如Slack)允许你“发送一个神奇的链接”，让你访问该服务，而不是输入你的密码。这就像一个重置链接，但登录</li>
<li><strong>使用第三方服务实现认证/授权</strong>——有服务(比如<a href="https://auth0.com/" target="_blank" rel="noopener noreferrer"> Auth0 </a>)打理一切(包括2FA！实现起来相当复杂)并且您只需要使用他们的脚本和钩子来开始认证用户</li>
<li>使用Twitter、脸书、GitHub 等第三方提供商——使用这种方法，你的控制力不如前面列出的方法，而且不是所有用户都有这些服务的账户，所以你可能会留下一些用户，但这是另一种选择，通常很容易实现</li>
</ul>
<h2>应用层的安全性</h2>
<h3>跨站点请求伪造</h3>
<p>这是最常见的安全漏洞之一，修复起来并不困难。让我们看看它是如何工作的。实现会话管理的最常见方式是使用cookies。一旦用户通过身份验证，您就可以设置一个cookie，浏览器会接收到该cookie，并在每个请求中自动将其发送到服务器。这很棒也很简单。然而，让我们想想这个。攻击者创建了一个隐藏有<form action="”vulnerablewebsite/malicious_action”">的网站。想象一下，这是一个转移货物或金钱的网站，攻击者创建了一个URL，当提交时，将使登录用户向攻击者转移一些东西。</form></p>
<p>现在攻击者只需要向受害者发送一个包含<form>的恶意链接。一旦受害者访问了该链接，表单甚至可以以静默方式提交，并且请求会被自动验证，因为带有验证信息的cookie是由浏览器发送的。攻击者甚至不需要知道cookie的内容。恶意链接可以是托管在任何地方的网站，因为默认情况下，浏览器不会阻止表单包含指向其他域的URL。</form></p>
<p>如何才能避免这种情况？解决方案是生成一个令牌，并将这个令牌放在一个新的cookie和表单中的一个隐藏字段中。然后，当提交表单时，后端将检查cookie中的令牌是否等于表单中的令牌。攻击者看不到cookies，因此无法用有效的CSRF令牌创建表单。</p>
<p>如果您正在使用express，您可以使用将生成令牌的<a href="https://github.com/expressjs/csurf" target="_blank" rel="noopener noreferrer"> csurf </a>包，将它们放在cookies中并验证它们。</p>
<h2>SQL注入</h2>
<p>这可能是您可能遇到的最危险的安全漏洞，它包括修改输入参数来操纵应用程序代码中编写得很差的查询。例如，如果您的代码中有:</p>
<pre>query = "SELECT * FROM users WHERE login = '" + input_login + "';"</pre>
<p>攻击者可以发送恶意的<code>input_login</code>参数来改变SQL查询的意图，甚至包括由<code>;</code>分隔的多个句子。通过这种机制，攻击者可以绕过用户身份验证，甚至删除数据库中的记录。</p>
<p>避免这个问题的主要机制是对输入参数进行转义。任何好的SQL库都应该有办法实现这一点。例如，<a href="https://www.npmjs.com/package/pg" target="_blank" rel="noopener noreferrer"> pg </a>库允许您这样做:</p>
<pre>const text = 'INSERT INTO users(name, email) VALUES($1, $2) RETURNING *'
const values = ['brianc', '<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="197b6b7078773774377a786b756a7677597e74787075377a7674">[email protected]</a>']
const response = await client.query(text, values)
</pre>
<p>您使用占位符($1，$2)而不是手动插入值，库将使用值数组的转义版本替换这些占位符。</p>
<p>为了确保你永远不会忘记使用占位符，你可以设置一个linter来捕捉手动插入并给你一个错误。</p>
<h3>跨站点脚本(XSS)</h3>
<p>这是第三大安全漏洞。当web应用程序没有清理和/或转义值的输出时，就会发生这种情况。例如，如果您的应用程序允许用户相互发送消息，并且您在呈现您的站点时没有转义这些消息，如果用户在这些消息上插入HTML，浏览器将直接呈现和评估HTML，从而允许攻击者在其上插入JavaScript。</p><div class="code-block code-block-54">
<hr/>
<h3>更多来自LogRocket的精彩文章:</h3>

<hr/></div>
<p>所以需要对输出进行转义。比如在<a href="https://ejs.co/" target="_blank" rel="noopener noreferrer"> EJS </a>你会做:</p>
<pre>&lt;div&gt;&lt;%= message %&gt;&lt;/div&gt;</pre>
<p>如果<code>message</code>包含<code>&lt;script&gt;…&lt;/script&gt;</code>，模板引擎会将其转义到<code>&lt;script&gt;…&lt;/script&gt;</code>，浏览器不会评估脚本内容。</p>
<p>如果你想允许用户在他们的内容中使用一些HTML，但是你想避免XSS攻击，那么你应该首先清理HTML，只允许使用一些标签和属性。对于JavaScript，你有这个<a href="https://github.com/apostrophecms/sanitize-html" target="_blank" rel="noopener noreferrer">杀毒器</a>。</p>
<h2>小心外部链接</h2>
<p>有一种非常简单的攻击也非常容易避免，这就是我在这里提到它的原因。如果您的网站包含指向外部网站的链接，因为您将它们放在那里，或者因为用户可以在“信息”或他们的个人资料中或任何地方留下链接，您可能正在使用<code>&lt;a target="_blank"&gt;</code>在新窗口或标签中打开这些链接。这很好，但这是一个潜在的安全问题，因为目标网站可以通过使用<code>window.opener</code>访问原始选项卡。解决方法很简单，只需为<code>rel</code>属性使用这些值:</p>
<pre>&lt;a href=”...” target=”_blank” rel=”noopener noreferrer”&gt;Malicious link&lt;/a&gt;</pre>
<p>您应该对任何带有<code>target="_blank"</code>的链接都这样做，即使您知道您链接的网站没有恶意，因为它可能已经受到攻击，并且可能包含恶意的JavaScript代码。</p>
<h2>分析你的网站</h2>
<p>现在也有一些工具可以让你很容易地发现问题，包括安全问题。其中一个就是<a href="https://webhint.io/scanner/" target="_blank" rel="noopener noreferrer"> webhint </a>。它有一些捕捉问题的规则，比如糟糕的HTTP头、易受攻击的外部链接等。</p>
<p>如果你有兴趣深入研究这些主题，还有更高级的工具，如<a href="https://www.owasp.org/index.php/OWASP_Zed_Attack_Proxy_Project" target="_blank" rel="noopener noreferrer"> OWASP ZAP </a>。</p>
<h2>结论</h2>
<p>正如我所说的，web安全可能是压倒性的，但是我希望这篇文章让您了解最常见的攻击以及如何避免或减轻它们。让我们回顾一下最重要的事情:</p>
<ul>
<li>使用HTTPs</li>
<li>使用HTTP头来减少一些攻击</li>
<li>正确散列和重置密码，或者不设置密码</li>
<li>使用CSRF代币</li>
<li>执行SQL查询时转义输入参数</li>
<li>清理和/或转义HTML模板中的值</li>
<li>分析你的网站！</li>
</ul>
<p>使用<a class="signup" href="https://lp.logrocket.com/blg/signup" target="_blank" rel="noopener noreferrer"> LogRocket </a>消除传统错误报告的干扰</p><div class="code-block code-block-2">
<div class="blog-plug base-cta"><h2><a href="https://lp.logrocket.com/blg/signup" target="_blank" rel="noopener noreferrer"> LogRocket </a>是一个数字体验分析解决方案，它可以保护您免受数百个假阳性错误警报的影响，只针对几个真正重要的项目。LogRocket会告诉您应用程序中实际影响用户的最具影响力的bug和UX问题。</h2>
<a href="https://lp.logrocket.com/blg/signup" class="signup" target="_blank" rel="noopener noreferrer"><img class="alignnone size-full wp-image-46 jetpack-lazy-image" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/><noscript><img data-lazy-fallback="1" class="alignnone size-full wp-image-46" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/></noscript></a>
<p>然后，使用具有深层技术遥测的会话重放来确切地查看用户看到了什么以及是什么导致了问题，就像你在他们身后看一样。</p>
<p>LogRocket自动聚合客户端错误、JS异常、前端性能指标和用户交互。然后LogRocket使用机器学习来告诉你哪些问题正在影响大多数用户，并提供你需要修复它的上下文。</p>
<p>关注重要的bug—<a class="signup" href="https://lp.logrocket.com/blg/signup-issue-free" target="_blank" rel="noopener noreferrer">今天就试试LogRocket】。</a></p>
<p>Focus on the bugs that matter — <a class="signup" href="https://lp.logrocket.com/blg/signup-issue-free" target="_blank" rel="noopener noreferrer">try LogRocket today</a>.</p></div></div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
<html>
<head>
<title>19 awesome web utilities for Rust - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>Rust - LogRocket博客的19个令人敬畏的web实用程序</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/19-awesome-web-utilities-for-rust/#0001-01-01">https://blog.logrocket.com/19-awesome-web-utilities-for-rust/#0001-01-01</a></blockquote><div><article class="article-post">
<p>Rust是一种主要关注性能和安全的编程语言。它在语法上与C++相似，非常流行。事实上，<a href="https://insights.stackoverflow.com/survey/2020?utm_source=twitter&amp;utm_medium=social&amp;utm_campaign=dev-survey-2020#technology-most-loved-dreaded-and-wanted-languages-loved" target="_blank" rel="noopener noreferrer"> Stack Overflow的年度开发者调查</a>已经连续五年将Rust评为开发者最喜爱的语言。</p>
<p/>
<p>我最喜欢Rust的是它的静态类型，它允许使用<code>null</code>的概念。与其他静态类型编程语言不同，Rust使用可选类型对<code>null</code>概念进行编码，这意味着编译器要求您处理非case错误，以防止<code>TypeError: Cannot read property 'foo' of null</code>运行时错误。您得到的不是上面的运行时错误，而是一个很容易解决的编译时错误。</p>
<p>使用Rust，您还可以将数据存储在堆栈或堆上。这有助于您确定编译时不再需要哪些数据。</p>
<p>有各种各样的开源web实用程序可以用来增强Rust的功能。例如，尽管Rust的标准库不包含任何正则表达式解析器/匹配器，但<code>regex</code>实用程序提供了一个正则表达式解析器。使用<code>regex</code>，您可以搜索、拆分或替换文本。</p>
<p>看看下面的表达式，它可以让您快速搜索美国号码。</p>
<pre>let re = Regex::new("[0-9]{3}-[0-9]{3}-[0-9]{4}").unwrap();
let mat = re.find("phone: 111-222-3333").unwrap();
assert_eq!((mat.start(), mat.end()), (7, 19));
</pre>
<p>这只是一个例子，说明web实用程序如何帮助您将Rust应用程序提升到一个新的水平。在本指南中，我们将向您介绍19个最流行和最有用的Rust web实用程序:</p>
<ol>
<li><a href="#cookie">T2<code>cookie</code></a></li>
<li><a href="#clap">T2<code>clap</code></a></li>
<li><a href="#heim">T2<code>heim</code></a></li>
<li><a href="#tempfile">T2<code>tempfile</code></a></li>
<li><a href="#urlencoded">T2<code>urlencoded</code></a></li>
<li><a href="#bodyparser">T2<code>bodyparser</code></a></li>
<li><a href="#queryst">T2<code>queryst</code></a></li>
<li><a href="#scgi">T2<code>scgi</code></a></li>
<li><a href="#sass-rs">T2<code>sass-rs</code></a></li>
<li><a href="#ratelimit_meter">T2<code>ratelimit_meter</code></a></li>
<li><a href="#regex">T2<code>regex</code></a></li>
<li><a href="#chrono">T2<code>chrono</code></a></li>
<li><a href="#time">T2<code>time</code></a></li>
<li><a href="#backtrace">T2<code>backtrace</code></a></li>
<li><a href="#docopt">T2<code>docopt</code></a></li>
<li><a href="#structopt">T2<code>structopt</code></a></li>
<li><a href="#url">T2<code>url</code></a></li>
<li><a href="#robotparser">T2<code>robotparser</code></a></li>
<li><a href="#multipart">T2<code>multipart</code></a></li>
</ol>
<h2 id="cookie">1.<code>cookie</code></h2>
<p>该实用程序增强了HTTP cookie解析和cookie jar管理。这个库是在MIT和Apache 2.0下授权的。据<a href="https://crates.io/crates/cookie" target="_blank" rel="noopener noreferrer"> crates.io </a>称，它有62个版本，稳定的最新版本是0.14.2。在撰写本文时，<code>cookie</code>已经被下载了大约580万次。</p>
<h3><strong>特性</strong></h3>
<p>默认情况下，<code>cookie</code>的以下功能被禁用。</p>
<ul>
<li><code>percent-encode</code>允许对cookies中的名称和值进行百分比编码。<code>cookie:: parse_encoded()</code>方法允许在解析时对cookie的名称和值进行百分比解码。<code>cookie:: encoded</code>方法返回一个包装cookie的包装器，并用它的<code>Display</code>实现对cookie进行百分比编码</li>
<li><code>signed</code>允许使用<code>CookieJar::signed()</code>方法对cookies进行签名</li>
<li><code>private</code> —当您使用<code>CookieJar::private()</code>方法启用了<span> <span>私有</span> </span>功能时，cookies会在添加和检索时被加密、解密和验证</li>
<li>按键扩展自动启用<code>signed</code>和<code>private</code>功能，以及<code>Key::derive_from()</code>方法。使用<code>Key::derive_from()</code>方法，您可以得到一个适合在<code>single</code>或<code>private</code>罐子中使用的密钥结构，其长度比完整的密钥要短</li>
<li><code>secure</code>是一个元特性，可以在使能<code>signed</code>、<code>private</code>和<code>key-expansion</code>之间切换。通过将以下代码添加到您的<code>Cargo.toml</code>文件中来启用它:</li>
</ul>
<pre>[dependencies.cookie]
features = ["secure", "percent-encode"]
</pre>
<h2 id="clap">2.<code>clap</code></h2>
<p>在用Rust编写控制台应用程序时，<a href="https://docs.rs/clap/2.33.3/clap/" target="_blank" rel="noopener noreferrer"> <code>clap</code> </a>箱是解析和验证命令行参数和子命令的最佳工具。这个库获得了MIT的许可，发布了211个版本，其中最稳定的是2 . 33 . 3(3 . 0 . 0版本仍处于测试阶段)。在撰写本文时，它已经拥有超过<a href="https://crates.io/crates/clap" target="_blank" rel="noopener noreferrer">1500万的下载量</a>。</p>
<p>或者，您可以使用YAML文件来构建您的CLI，以保持Rust源代码的整洁。</p>
<h3>特征</h3>
<p>默认情况下，会启用以下内置功能。</p>
<ul>
<li>当用户输入错别字时，建议可以帮助他们，例如，<code>Did you mean '--myoption'?</code></li>
<li>彩色—错误消息彩色时更明显。此功能打开彩色错误消息，并且仅在非Windows操作系统上起作用</li>
<li>换行帮助—使用此功能，终端中的帮助会换行，而不是120个字符</li>
</ul>
<p>要禁用上述特性，请将以下代码添加到您的<code>cargo.toml</code>文件中。</p>
<pre>[dependencies.clap]
version = "~2.27.0"
default-features = false
</pre>
<p>您也可以通过将下面的代码粘贴到您的<code>cargo.toml</code>文件中，只启用您想要使用的功能。</p>
<pre>[dependencies.clap]
version = "~2.27.0"
default-features = false
# Cherry-pick the features you'd like to use
features = [ "suggestions", "color" ]
</pre>
<p>以下是选择加入的功能；它们不是内置的。</p>
<ul>
<li>YAML使您能够从一个<code>.yaml</code>文件构建您的CLI</li>
<li><code>unstable</code>使您能够使用不稳定的clap功能</li>
</ul>
<h2 id="&quot;heim'">3.<code>heim</code></h2>
<p><a href="https://docs.rs/heim/0.0.11/heim/" target="_blank" rel="noopener noreferrer"> <code>heim</code> </a>是一个跨平台的库，可用于系统信息抓取。它使用异步优先，并且是跨平台和模块化的。</p>
<p>图书馆的GitHub页面包括了一个有用的<code>heim</code>和其他箱子的比较。</p>
<p><code>heim</code><a href="https://crates.io/crates/heim" target="_blank" rel="noopener noreferrer">是否得到了麻省理工学院和阿帕奇2.0 </a>的许可。15个版本中最稳定的是0.0.10，0.10版本处于beta阶段。</p>
<h2 id="tempfile">4.<code>tempfile</code></h2>
<p><a href="https://docs.rs/tempfile/3.1.0/tempfile/" target="_blank" rel="noopener noreferrer"> <code>tempfile</code> </a>机箱包括<code>tempfile()</code>和<code>tempdir()</code>功能，可以创建临时文件和目录。比方说，你想创建一个文件，但不关心它的名字，因为它是一个临时文件，你可以删除它。<code>tempfile</code>库将使这个过程变得更容易，因为一旦你完成，它将删除文件。</p>
<p><code>tempfile()</code>函数依靠操作系统在你关闭最后一个句柄后立即删除临时文件，而<code>tempdir()</code>函数依靠Rust析构函数进行清理。如果析构函数不运行，<code>tempdir()</code>函数可能会失败，而<code>tempfile()</code>函数几乎不会失败，因为它依赖于计算机的操作系统。</p>
<p>这个库是在MIT和Apache 2.0下授权的，已经发布了<a href="https://crates.io/crates/tempfile" target="_blank" rel="noopener noreferrer"> 35个版本</a>，其最新的稳定版本是3.1.0。</p>
<h2 id="urlencoded">5.<code>urlencoded</code></h2>
<p>是一个用于Iron web框架的中间件，帮助你从GET和POST请求中解码URL数据。它将一个URL查询字符串解析成一个<code>HashMaps</code>,后者将键的字符串表示映射到字符串值的vec上。值存储在vec中，以确保如果一个键出现多次，不会丢失任何信息。查询字符串<code>d=b&amp;d=c</code>导致从<code>d</code>到<code>b</code>，<code>c</code>的映射。它解析web表单数据的POST请求主体(MIME类型:application/x-www-form-urlencoded)。</p>
<p>这个库是在MIT下许可的，发布了九个版本(最稳定的版本:0.6.0)，并且需要以下依赖项。</p>
<ul>
<li><code>bodyparser</code> ^0.8</li>
<li>铁&gt; =0.5，&lt; 0.7</li>
<li><code>plugin</code> ^0.2.6</li>
<li><code>url</code> ^1.6</li>
</ul>
<h2 id="bodyparser">6.<code>bodyparser</code></h2>
<p>Iron的核心中间件的一部分，<a href="https://docs.rs/bodyparser/0.8.0/bodyparser/" target="_blank" rel="noopener noreferrer"> <code>bodyparser</code> </a>顾名思义，是一个面向Iron的解析中间件。它包含以下功能:</p>
<ul>
<li><code>raw</code> —在Raw中，<code>bodyparser</code>对字符串执行正文解析</li>
<li><code>json</code>—<code>bodyparser</code>框架可以将主体解析成JSON</li>
<li>使用<a href="https://blog.logrocket.com/json-and-rust-why-serde_json-is-the-top-choice/" target="_blank" rel="noopener noreferrer"> Serde </a>将主体解析成一个结构</li>
</ul>
<p>这个库得到了麻省理工学院的许可，有15个版本。其当前最稳定的版本是<code>0.8.0</code>，它需要以下依赖项:</p>
<ul>
<li>铁&gt; =0.5，&lt; 0.7</li>
<li>执着的^0.4</li>
<li><code>plugin</code> ^0.2</li>
<li>塞尔德·^1.0</li>
<li><code>serde_json</code> ^1.0</li>
<li><code>serde_derive</code> ^1.0</li>
</ul>
<h2 id="queryst">7.<code>queryst</code></h2>
<p><a href="https://docs.rs/queryst/1.0.1/queryst/" target="_blank" rel="noopener noreferrer"> <code>queryst</code> </a>是一个Rust字符串解析库，使您能够将查询字符串解析为它们对应的JSON值。</p>
<p>通过将以下内容添加到您的<code>cargo.toml</code>文件来启用<code>queryst</code>库。</p>
<pre>[dependencies]
queryst = "1"
</pre>
<p>使用<code>queryst</code>，字符串<code>foo[bar]=baz</code>可以被解析为:</p>
<pre>{
  "foo": {
    "bar": "baz"
   }
}
</pre>
<p>URL编码的字符串也有效，可以解析为:</p>
<pre>parse('a%5Bb%5D=c');
// { "a": { "b": "c" } }
</pre>
<p>这个库得到了麻省理工学院的许可，已经发布了<a href="https://crates.io/crates/queryst" target="_blank" rel="noopener noreferrer"> 21个版本</a>。它的最新版本<code>2.0.2</code>需要以下依赖项。</p>
<ul>
<li>塞尔德·^1</li>
<li><code>serde_json</code> ^1</li>
<li><code>url</code> ^1</li>
<li><code>lazy_static</code> ^1 (optional)</li>
<li><code>regex</code> ^0.2 (optional)</li>
</ul>
<h2 id="scgi">8.<code>scgi</code></h2>
<p>简单通用网关接口(SCGI)是应用程序与HTTP服务器接口的协议。<a href="https://artemgr.github.io/rust-scgi/scgi/index.html" target="_blank" rel="noopener noreferrer"> <code>scgi</code> </a>是一种用于防锈的SCGI连接器。</p>
<p>该库得到了麻省理工学院和阿帕奇2.0(T2)的许可，已经发布了16个版本。最新版本是0.3.4，它需要<code>bufstream</code> ^0.1.1作为依赖项。</p>
<h2 id="sass-rs">9.<code>sass-rs</code></h2>
<p>Sass库的高级绑定是对<code>libsass</code>的包装。</p>
<p><a href="https://crates.io/crates/sass-rs" target="_blank" rel="noopener noreferrer"> <code>sass-rs</code> </a>在MIT下获得许可，已经发布了22个。稳定的、最新的库是<code>0.2.2</code>，它需要以下依赖项。</p>

<h2 id="ratelimit_meter">10.<code>ratelimit_meter</code></h2>
<p><a href="https://docs.rs/ratelimit_meter/5.0.0/ratelimit_meter/" target="_blank" rel="noopener noreferrer"> <code>ratelimit_meter</code> </a>是一个开源库，它实现了漏桶和漏桶的一个变体，即用于速率限制和调度的通用信元速率算法(GCRA)。与令牌桶算法不同，漏桶算法假设所有的工作单元具有相同的“权重”因此，它允许一些优化，这导致更简洁和快速的代码。</p>
<p>这个库得到了麻省理工学院的许可，并且已经发布了1 <a href="https://crates.io/crates/ratelimit_meter/1.0.0" target="_blank" rel="noopener noreferrer"> 7个版本</a>。<code>ratelimit_meter</code>的当前版本是5.0.0，需要以下依赖项。</p>
<ul>
<li><code>nonzero_ext</code> ^0.1.5</li>
<li><code>evmap</code> ^6.0.0 optional</li>
<li><code>parking_lot</code> ^0.9.0 optional</li>
<li><code>spin</code> ^0.5.0 optional</li>
<li><code>criterion</code> ^0.2.11</li>
<li><code>libc</code> ^0.2.41</li>
</ul>
<h2 id="regex">11.<code>regex</code></h2>
<p><a href="https://docs.rs/regex/1.4.2/regex/" target="_blank" rel="noopener noreferrer"> <code>regex</code> </a>是一个帮助你解析、编译、执行正则表达式的Rust库。使用<code>regex</code>，您可以匹配YYYY-MM-DD格式的日期，以打印年、月、时和日，甚至可以使用迭代器迭代文本。</p>
<p>要使用<code>regex</code>，请将以下内容添加到您的<code>cargo.toml</code>文件中。</p>
<pre>[dependencies]
regex = "1"
</pre>
<p>如果您使用的是Rust 2015，您需要将它添加到您的板条箱工具中:</p>
<pre>extern crate regex;
</pre>
<p>这个库是在MIT和Apache 2.0下授权的。它有<a href="https://crates.io/crates/regex" target="_blank" rel="noopener noreferrer"> 120个版本</a>，最新的是1.3.9。此版本需要下列依赖项。</p>
<ul>
<li><code>regex-syntax</code> ^0.6.18</li>
<li><code>aho-corasick</code> ^0.7.6 optional</li>
<li><code>memchr</code> ^2.2.1 optional</li>
<li><code>thread_local</code> ^1 optional</li>
<li><code>lazy_static</code> ^1</li>
<li><code>quickcheck</code> ^0.8</li>
<li><code>rand</code> ^0.6.5</li>
</ul>
<h2 id="chrono">12.<code>chrono</code></h2>
<p><a href="https://blog.logrocket.com/timezone-handling-in-rust-with-chrono-tz/" target="_blank" rel="noopener noreferrer"> <code>chrono</code> </a>是日期和时间的锈库。通过<code>chrono</code>，您可以使用<code>time</code>框中的<code>time::Duration</code>类型来表示时间跨度的大小。您还可以使用<code>DateTime</code>类型来表示时区中的日期和时间。<code>DateTime</code>类型必须从<code>TimeZone</code>对象中构造。这将定义本地日期如何与UTC日期相互转换。</p>
<p>这个库是在MIT或Apache-2.0下授权的，有<a href="https://crates.io/crates/chrono" target="_blank" rel="noopener noreferrer"> 66个发布版本</a>。最新最稳定的版本是0.4.18。</p>
<h3>默认功能</h3>
<ul>
<li><code>alloc</code>启用依赖于分配的特性(主要是字符串格式)</li>
<li><code>std</code>是<code>alloc</code>的超集，增加了与标准库类型和特征的互操作</li>
<li><code>clock</code>允许读取系统时间，不管<code>std::time::SystemTime</code>是否存在(取决于是否有<code>libc</code></li>
</ul>
<h3>可选功能</h3>
<ul>
<li><code>wasmbind</code>与<code>wasm-bind</code> gen及其<code>js-sys</code>项目无缝集成</li>
<li><code>serde</code>允许<a href="https://blog.logrocket.com/rust-serialization-whats-ready-for-production-today/" target="_blank" rel="noopener noreferrer">通过Serde进行Rust序列化和反序列化</a></li>
<li><code>unstable-locales</code>启用本地化并添加带有<code>_localized</code>后缀的各种方法</li>
</ul>
<h2 id="time">13.<code>time</code></h2>
<p><a href="https://docs.rs/time/0.2.22/time/" target="_blank" rel="noopener noreferrer"> <code>time</code> </a>库是一个开源的日期和时间库，它与标准库完全互操作，并且大部分与<code>#![no_std]</code>兼容。这个库有<a href="https://crates.io/crates/time" target="_blank" rel="noopener noreferrer"> 70个版本</a>，其最新、最稳定的版本是0.2.22。</p>
<h3>默认情况下启用的功能</h3>
<ul>
<li><code>std</code>启用依赖于标准库的各种其他功能</li>
<li><code>deprecated</code>允许支持从<code>time</code> 0.1开始的某些功能</li>
</ul>
<h3>默认情况下禁用的功能</h3>
<ul>
<li>启用对所有类型的Serde支持</li>
<li><code>rand</code>支持所有类型的rand</li>
<li><code>panicking-API</code>允许您在需要时使用<code>unwrap()</code>方法</li>
</ul>
<h2 id="backtrace">14.<code>backtrace</code></h2>
<p>构建<a href="https://doc.rust-lang.org/std/backtrace/index.html" target="_blank" rel="noopener noreferrer"> <code>backtrace</code> </a>库是为了通过允许以编程方式获取回溯来支持<code>RUST_BACKTRACE=1</code>标准库。</p>
<p>要使用<code>backtrace</code>，请将以下内容添加到您的<code>cargo.toml</code>文件中</p>
<pre>[dependencies]
backtrace = "0.3"
</pre>
<p>本库有<a href="https://crates.io/crates/backtrace" target="_blank" rel="noopener noreferrer"> 64版本发布</a>。最新的稳定版本是0.3.50，它需要以下依赖项。</p>
<ul>
<li><code>cfg</code>——如果^0.1.10</li>
<li><code>libc</code> ^0.2.45</li>
<li><code>rustc-demangle</code> ^0.1.4</li>
<li><code>addr2line</code> ^0.13.0 optional</li>
<li><code>backtrace-sys</code> ^0.1.35 optional</li>
<li><code>compiler_builtins</code> ^0.1.2 optional</li>
<li><code>cpp_demangle</code> ^0.3.0 optional</li>
<li><code>miniz_oxide</code> ^0.4.0 optional</li>
<li><code>object</code> ^0.20.0 optional</li>
<li><code>rustc-serialize</code> ^0.3 optional</li>
<li><code>rustc-std-workspace-core</code> ^1.0.0 optional</li>
<li><code>serde</code> ^1.0 optional</li>
<li><code>winapi</code> ^0.3.3 optional</li>
<li><code>libloading</code> ^0.6</li>
</ul>
<h2 id="docopt">15.<code>docopt</code></h2>
<p><a href="https://docs.rs/docopt/1.1.0/docopt/" target="_blank" rel="noopener noreferrer"> <code>docopt</code> </a>是一个命令行参数解析器。与其他解析器不同，这个解析器可以从用法字符串中派生出来。</p>
<p>要使用<code>docopt</code>，请将以下内容添加到您的<code>cargo.toml</code>文件中。</p>
<pre>[dependencies]
docopt = "1"
serde = { version = "1", features = ["derive"] }
</pre>
<p><code>docopt</code>有<a href="https://crates.io/crates/docopt" target="_blank" rel="noopener noreferrer"> 86个版本</a>，最新的是1.1.0。此版本需要以下依赖项:</p>
<ul>
<li><code>lazy_static</code> ^1.3</li>
<li><code>regex</code> ^1.1.5</li>
<li><code>serde</code> ^1.0</li>
<li><code>strsim</code> ^0.9</li>
</ul>
<h2 id="structopt">16.<code>structopt</code></h2>
<p><a href="https://docs.rs/structopt/0.3.20/structopt/" target="_blank" rel="noopener noreferrer"> <code>structopt</code> </a>将<code>clap</code>库与自定义驱动结合起来，通过定义一个结构来解析命令行参数。</p>
<p>要使用这个库，请将<code>structopt</code>添加到您的<code>cargo.toml</code>文件中:</p>
<pre>[dependencies]
structopt = "0.3"
</pre>
<p>然后，在您的rust文件中:</p>
<pre>use std::path::PathBuf;
use structopt::StructOpt;

/// A basic example
#[derive(StructOpt, Debug)]
#[structopt(name = "basic")]
struct Opt {
    /**this will return true if used in the command line. Note doc comment will
     be used for the help message of the flag. The name of the
     document by default, will be based on the name of the field.**/
    /// Activate debug mode
    #[structopt(short, long)]
    debug: bool,

    /// Verbose mode (-v, -vv, -vvv, etc.)
    #[structopt(short, long, parse(from_occurrences))]
    verbose: u8,

    /// Set speed
    #[structopt(short, long, default_value = "42")]
    speed: f64,

    /// Output file
    #[structopt(short, long, parse(from_os_str))]
    output: PathBuf,

    // the long option will be translated to kebab case by default,
    // i.e. `--nb-cars`.
    /// Number of cars
    #[structopt(short = "c", long)]
    nb_cars: Option&lt;i32&gt;,

    /// admin_level to consider
    #[structopt(short, long)]
    level: Vec&lt;String&gt;,

    /// Files to process
    #[structopt(name = "FILE", parse(from_os_str))]
    files: Vec&lt;PathBuf&gt;,
}

fn main() {
    let opt = Opt::from_args();
    println!("{:#?}", opt);
}
</pre>
<p><code>structopt</code>已经发布了<a href="https://crates.io/crates/structopt/0.1.3" target="_blank" rel="noopener noreferrer"> 52个版本</a>，最新版本是0.3.18。</p>
<h2 id="url">17.<code>url</code></h2>
<p><code><a href="https://docs.rs/url/2.1.1/url/" target="_blank" rel="noopener noreferrer">url</a></code>是Rust编程语言的URL标准的实现。URL标准定义了URL、域、IP地址、application/x-www-form-urlencoded格式以及它们的API。</p>
<p>这个图书馆有<a href="https://crates.io/crates/url" target="_blank" rel="noopener noreferrer"> 73个版本出版</a>。它最稳定的版本是<code>2.1.1</code>。</p>
<h2 id="robotparser"><strong> 18。<code>robotparser</code> </strong></h2>
<p><a href="https://docs.rs/robotparser/0.8.2/robotparser/" target="_blank" rel="noopener noreferrer"> <code>robotparser</code> </a>是一个用于Rust的<code>robots.txt</code>解析器。<code>robost.txt</code>文件告诉搜索引擎爬虫他们能或不能抓取哪些页面或文件。这是为了避免你的网站被过多的请求。</p>
<p>这个库得到了麻省理工学院的许可，已经出版了<a href="https://crates.io/crates/robotparser" target="_blank" rel="noopener noreferrer"> 18个版本</a>。最新的稳定版本是<code>0.10.2</code>，需要以下依赖项。</p>
<ul>
<li><code>url</code> ^1</li>
<li><code>reqwest</code> ^0.9 optional</li>
</ul>
<h2 id="multipart">19.<code>multipart</code></h2>
<p><a href="https://docs.rs/multipart/0.17.0/multipart/" target="_blank" rel="noopener noreferrer"> <code> multipart</code> </a>是HTTP文件上传的客户端和服务器端概念(内容类型为multipart/form-data的POST请求)。这个库支持各种同步API HTTP crates，包括<code>hyper</code>和<code>tiny_http</code>。</p>
<p><code>multipart</code>在麻省理工学院和阿帕奇2.0下获得许可，并且已经发布了<a href="https://crates.io/keywords/multipart" target="_blank" rel="noopener noreferrer"> 18个版本</a>。最新的稳定版本是<code>0.17.0</code>，需要以下依赖项。</p>
<ul>
<li><code>log</code> ^0.4</li>
<li><code>mime</code> ^0.3.14</li>
<li><code>mime_guess</code> ^2.0.1</li>
<li><code>rand</code> ^0.6</li>
<li><code>tempfile</code> ^3</li>
<li><code>buf_redux</code> ^0.8 optional</li>
<li><code>clippy</code> &gt; =0.0, &lt; 0.1 optional</li>
<li><code>httparse</code> ^1.2 optional</li>
<li><code>hyper</code> &gt; =0.9, &lt; 0.11 optional</li>
<li><code>iron</code> &gt; =0.4, &lt; 0.7 optional</li>
<li><code>lazy_static</code> ^1.2.0 optional</li>
<li><code>nickel</code> &gt; =0.10.1 optional</li>
<li><code>quick-error</code> ^1.2 optional</li>
<li><code>rocket</code> ^0.4 optional</li>
<li><code>safemem</code> ^0.3 optional</li>
<li><code>tiny_http</code> ^0.6 optional</li>
<li><code>twoway</code> ^0.1 optional</li>
<li><code>env_logger</code> ^0.5</li>
</ul>
<h2 id="conclusion">结论</h2>
<p>Rust的web实用程序太多了！希望本指南能为您提供选择合适的解决方案组合所需的背景，让您的Rust应用更上一层楼。</p>
<p>如果你想解析Rust中的命令行参数，<code>clap</code>、<code>docopt</code>和<code>structopt</code>都是不错的选择。当涉及到实现日期和时间相关的特性时，使用<code>chrono</code>和<code>time</code>是不会错的。对于创建临时文件，可以使用<code>tempfile</code>。</p><div class="code-block code-block-54">
<hr/>
<h3>更多来自LogRocket的精彩文章:</h3>

<hr/></div>
<p>Rust生态系统为解析cookes ( <code>cookie</code>)、string(<code>queryst</code>)和regular expression(<code>regex</code>)提供了优秀的工具。为了允许Rust在应用程序中读取传入请求的主体，您可能希望尝试使用<code>bodyparser</code>来解析请求的主体部分。</p>
<p>一如既往，最佳解决方案将取决于与您的Rust项目相关的独特目标、需求和挑战。</p><div class="code-block code-block-29">
<div class="blog-plug inline-plug rust-plug"><h2><a href="https://lp.logrocket.com/blg/rust-signup" target="_blank">log rocket</a>:Rust应用的web前端的全面可见性</h2><p>调试Rust应用程序可能很困难，尤其是当用户遇到难以重现的问题时。如果您对监控和跟踪Rust应用程序的性能、自动显示错误、跟踪缓慢的网络请求和加载时间感兴趣，</p><a href="https://lp.logrocket.com/blg/rust-signup" target="_blank">try LogRocket</a><p>. </p><a class="signup" href="https://lp.logrocket.com/blg/rust-signup" target="_blank" rel="noopener noreferrer"><img class="alignnone size-full wp-image-46 jetpack-lazy-image" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/><noscript><img data-lazy-fallback="1" class="alignnone size-full wp-image-46" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/></noscript></a><p>LogRocket 就像是网络和移动应用程序的DVR，记录你的Rust应用程序上发生的一切。您可以汇总并报告问题发生时应用程序的状态，而不是猜测问题发生的原因。LogRocket还可以监控应用的性能，报告客户端CPU负载、客户端内存使用等指标。</p><p>现代化调试Rust应用的方式— <a class="signup" href="https://lp.logrocket.com/blg/rust-signup" target="_blank" rel="noopener noreferrer">开始免费监控</a>。</p></div>


</div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
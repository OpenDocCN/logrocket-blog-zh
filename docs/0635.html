<html>
<head>
<title>Unsentimental versioning - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>无情的版本控制- LogRocket博客</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/unsentimental-versioning/#0001-01-01">https://blog.logrocket.com/unsentimental-versioning/#0001-01-01</a></blockquote><div><article class="article-post">
<p>我参与的大多数项目都试图遵循语义版本化，这可能是版本化软件最常用的策略之一。</p>
<p>它有明确严格的<a href="https://semver.org/" target="_blank" rel="noopener noreferrer">规范</a>。当开发人员试图遵循这个规范时，问题就出现了。</p>
<p>语义版本化是这样定义的:MAJOR。小补丁</p>
<ul>
<li>专业:突破性变化</li>
<li>次要:以向后兼容的方式添加功能</li>
<li>补丁:向后兼容的错误修复</li>
</ul>
<p>这通常意味着，在发布新版本时，开发人员必须经历自上一个版本以来的所有变更，以确定下一个版本号。</p>
<p>这可能是一项困难且耗时的任务。通常，这会导致<a href="http://sentimentalversioning.org/" target="_blank" rel="noopener noreferrer">感性版本化</a>。为了避免这一点，我们必须消除所有的人类互动。</p>
<figure id="attachment_12925" aria-describedby="caption-attachment-12925" class="wp-caption aligncenter"><img data-attachment-id="12925" data-permalink="https://blog.logrocket.com/unsentimental-versioning/bender-nocdn/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/01/bender-nocdn.png" data-orig-size="392,406" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="bender-nocdn" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/01/bender-nocdn-290x300.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/01/bender-nocdn.png" decoding="async" class="wp-image-12925 size-full jetpack-lazy-image" src="../Images/4efda0416276aaa01f7f76683c6a4471.png" alt="Bender wants to end sentimental versioning." data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2020/01/bender-nocdn.png 392w, https://blog.logrocket.com/wp-content/uploads/2020/01/bender-nocdn-290x300.png 290w" data-lazy-sizes="(max-width: 392px) 100vw, 392px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2020/01/bender-nocdn.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/01/bender-nocdn.png"/><noscript><img data-lazy-fallback="1" data-attachment-id="12925" data-permalink="https://blog.logrocket.com/unsentimental-versioning/bender-nocdn/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/01/bender-nocdn.png" data-orig-size="392,406" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="bender-nocdn" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/01/bender-nocdn-290x300.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/01/bender-nocdn.png" decoding="async" loading="lazy" class="wp-image-12925 size-full" src="../Images/4efda0416276aaa01f7f76683c6a4471.png" alt="Bender wants to end sentimental versioning." srcset="https://blog.logrocket.com/wp-content/uploads/2020/01/bender-nocdn.png 392w, https://blog.logrocket.com/wp-content/uploads/2020/01/bender-nocdn-290x300.png 290w" sizes="(max-width: 392px) 100vw, 392px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/01/bender-nocdn.png"/></noscript><figcaption id="caption-attachment-12925" class="wp-caption-text">Bender wants to end sentimental versioning.</figcaption></figure>
<p>我们可以通过使用<a href="https://semantic-release.gitbook.io/semantic-release/" target="_blank" rel="noopener noreferrer">语义发布</a>来实现。</p>
<p>这是安装在CI环境中的一个工具，它检查提交消息，并在此基础上自动导出下一个版本的下一个版本号。</p>
<p>这意味着所有团队成员在编写提交消息时必须使用相同的标准。常规提交是帮助我们实现这一目标的标准。</p>
<blockquote><p>传统的提交规范是提交消息之上的轻量级约定。它为创建显式提交历史提供了一组简单的规则，这使它成为编写自动化工具的坚实基础。</p></blockquote>
<p>因为我们已经确定人类是不可信的，所以我们将使用命令行工具来生成常规提交。</p>
<p>该工具将询问开发人员一些问题，并根据这些答案创建一条提交消息。</p>
<p>这个工具叫做<a href="https://commitizen.github.io/cz-cli/" target="_blank" rel="noopener noreferrer"> commitizen </a>，它非常适合标准化提交消息。您可以这样安装它:</p>
<pre>npm install -g commitizen</pre>
<p>装上之后一定要用<code>git cz</code>而不是<code>git commit -m "commit message"</code>。该过程如下所示:</p>
<p><img data-attachment-id="13383" data-permalink="https://blog.logrocket.com/unsentimental-versioning/commitzen-example/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/01/commitzen-example.gif" data-orig-size="730,297" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="commitzen demo" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/01/commitzen-example-300x122.gif" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/01/commitzen-example.gif" decoding="async" class="aligncenter size-full wp-image-13383 jetpack-lazy-image" src="../Images/60619127dae844ed54a70a729e2eafd0.png" alt="Commitzen Demo" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2020/01/commitzen-example.gif?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/01/commitzen-example.gif"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="13383" data-permalink="https://blog.logrocket.com/unsentimental-versioning/commitzen-example/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/01/commitzen-example.gif" data-orig-size="730,297" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="commitzen demo" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/01/commitzen-example-300x122.gif" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/01/commitzen-example.gif" decoding="async" loading="lazy" class="aligncenter size-full wp-image-13383" src="../Images/60619127dae844ed54a70a729e2eafd0.png" alt="Commitzen Demo" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/01/commitzen-example.gif"/></noscript>
<p>由这些问题生成的其他提交消息的示例:</p>
<table>
<thead>
<tr>
<th>提交消息</th>
<th>发布类型</th>
</tr>
</thead>
<tbody>
<tr>
<td>修复(用户):修复了正确的电子邮件地址验证</td>
<td>补丁发布</td>
</tr>
<tr>
<td>专长(用户):为用户添加中间名</td>
<td>功能发布</td>
</tr>
<tr>
<td>perf(用户):删除了用户的中间名。重大变更:中间名字段已被删除。</td>
<td>突破释放</td>
</tr>
</tbody>
</table>
<p>当我们以这种格式构造提交消息时，我们可以利用语义发布。它意味着在发布分支的每个成功构建之后，在CI环境中执行。</p>
<p>通过这种方式，没有人直接参与到发布过程中，并且发布保证是不浪漫和不感情用事的。</p>
<p>Semantic-release实际上是一个npm包，最初只用于节点项目。但是通过使用插件，它可以用于所有类型的项目。</p>
<p>这个插件叫做<a href="https://github.com/semantic-release/exec" target="_blank" rel="noopener noreferrer"> semantic-release/exec </a>，它为你提供新的版本号，让你执行自己的定制命令。</p>
<p>语义发布是这样安装的:</p>
<pre>npm install --save-dev semantic-release</pre>
<p>为了让它在circleci中工作，构建配置文件将如下所示:</p>
<pre>version: 2
jobs:
  release:
    docker:
      - image: circleci/node:8
    steps:
      - checkout
      - run: npm install
      - run: npx semantic-release

workflows:
  version: 2
  make_release:
    jobs:
      - release</pre>
<p>点击阅读关于CI环境的<a href="https://semantic-release.gitbook.io/semantic-release/recipes/recipes">设置的更多信息。</a></p>
<p>总而言之，我们现在在构建服务器上安装了<code>semantic-release</code>，它分析提交历史。</p>
<p>在<code>commitezen</code>(安装在开发人员的计算机上)的帮助下，提交消息遵循一个叫做<code>conventional commit</code>的标准。</p>
<p>这可能看起来有点过分，对于一些项目来说，可能就是这样。但是对于许多其他项目，特别是那些有许多人参与的项目，我真的认为这是需要考虑的事情。</p>
<p>尤其是当您发现自己开始变得不确定版本化过程的时候。</p>
<p>然后有一件事要做:将人类从过程中移除。</p>
<p>延伸阅读:</p>


<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
<html>
<head>
<title>React Navigation vs. React Native Navigation: Which is right for you? - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>React导航与React原生导航:哪个适合你？- LogRocket博客</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/react-navigation-vs-react-native-navigation/#0001-01-01">https://blog.logrocket.com/react-navigation-vs-react-native-navigation/#0001-01-01</a></blockquote><div><article class="article-post">
<p><em> <strong>编者按:</strong>本文于2021年9月更新，旨在解决React导航和React原生导航中关于API、状态管理和app架构的问题。这篇文章包含了作者的个人观点，这些观点是建立在使用React本地应用的多个导航库的经验之上的。</em></p>
<p>当使用React Native开发移动应用程序时，最重要的步骤之一是为您的项目选择完美的导航库。导航是应用程序的支柱，对用户体验有很大的影响。</p>
<p>没有任何单一的解决方案可以满足所有需求。有几个导航库可供我们选择。在这里，我们将比较React Navigation和其著名的替代产品React Native Navigation (RNN ),权衡为您的应用程序选择导航库的关键要素。</p>
<h2>什么是React导航？</h2>
<p>React Navigation是使用最广泛、开发最活跃的库之一。也是React原生团队推荐的<a href="https://facebook.github.io/react-native/docs/navigation" target="_blank" rel="noopener">方案之一。这是脸书推动最多的社区解决方案。</a></p>
<p>让我们分析一下React导航盛行的场景，以及一些不盛行的场景。在后一种情况下，我们将尝试分析你需要多少复杂性来实现你想要的特性，或者在这些情况下RNN会有多好。</p>
<h2>React导航与React本机导航的性能比较</h2>
<p>TL；DR: React导航使用库的组合来提供接近本地的体验，而RNN为每个屏幕使用本地片段。</p>
<p>为应用选择导航库时，性能是首要参数。每秒显示的帧数决定了界面的流畅度。大多数高性能应用程序总是保持60fps，尤其是在交互和过渡期间。</p>
<p>该基准留给我们大约16.67毫秒来完成生成下一帧所需的所有工作。如果我们错过了这个窗口，我们将会丢失一帧，这会使我们的用户界面看起来没有反应和笨拙。</p>
<p>在我们的React原生应用中，大多数业务逻辑驻留在JS线程上，包括API调用、状态管理和触摸事件的处理。React导航与应用程序的其他部分完全在同一个JavaScript线程上工作。</p>
<p>当您推送一个新的路由时，JS线程需要在屏幕上呈现组件，以便将正确的命令发送到本机端来创建后备视图。这可能会导致具有大量屏幕和复杂界面的应用程序出现性能瓶颈。</p>
<p>React Navigation依靠<a href="https://github.com/software-mansion/react-native-screens" target="_blank" rel="noopener">引擎罩下的react-native-screens </a>为其所有的导航器提供接近本地的体验。他们还拥有<a href="https://reactnavigation.org/docs/native-stack-navigator/" target="_blank" rel="noopener">原生堆栈导航器</a>，该导航器在iOS上使用原生API<code>UINavigationController</code>，在Android上使用原生API<code>Fragment</code>，因此导航具有与基于这些API原生构建的应用相同的性能特征。</p>
<p>与<a href="https://reactnavigation.org/docs/stack-navigator/" target="_blank" rel="noopener">基于JS的堆栈导航器</a>相比，这是以更少的定制为代价的。所有的动画都是使用内置导航器中的原生驱动完成的。除此之外，React导航使用<a href="https://github.com/software-mansion/react-native-reanimated" target="_blank" rel="noopener">React-native-realized v2</a>来提高手势释放的性能。</p>
<p>对于手势处理，<a href="https://blog.logrocket.com/react-native-gesture-handler-swipe-long-press-and-more/" target="_blank" rel="noopener">react-native-gesture-handler将手势从JS线程卸载到主线程</a>。Tab navigator使用<a href="https://github.com/satya164/react-native-tab-view" target="_blank" rel="noopener"> react-native-tab-view </a>引擎盖下；它利用<a href="https://github.com/callstack/react-native-pager-view" target="_blank" rel="noopener">反应本地页面视图</a>而不是复活和手势处理器。</p>
<p>这将提供本机UX并提高性能。这种库的组合有助于我们利用原生线程的所有优势，同时保持我们的导航栈更加以JS为中心。</p>
<p>与React导航相比，RNN在默认情况下会将你的所有屏幕都视为单独的React应用，这使得你的应用本质上更具性能。然而，这也带来了一些复杂性——尤其是在与像Redux和react-intl这样的库集成时，这些库要求您包装您的应用程序。我们将在稍后的集成比较中讨论这一点。但对于大规模应用程序，性能提升可以取代这一点。</p>
<h2>React导航中的API与React本机导航</h2>
<p>TL；DR: React Navigation有一个带有内置钩子的声明式API，而React Native Navigation有带有钩子社区库的命令式API。</p>
<p>React改变了我们对界面开发的看法。今天的开发人员寻找更多的声明式API，而不是命令式API。React Hooks在这个概念的基础上又加了一点冰。在React导航和React本机导航之间，前者提供的API更接近React组件API，更具声明性，并且更容易被React开发人员采用。虽然RNN依赖于命令式API，但这可能是他们的架构所必需的。至于钩子，<a href="https://github.com/underscopeio/react-native-navigation-hooks" target="_blank" rel="noopener"> RNN有一个社区库</a>，而React Navigation有内置钩子。</p>
<h2>状态管理和应用架构</h2>
<p>TL；DR:使用JS状态管理库时，React导航更加简单。RNN可能需要一些开箱即用的开发来集成这些库，<a href="https://wix.github.io/react-native-navigation/docs/third-party-react-context" target="_blank" rel="noopener">好的文档</a>弥补了这一点。</p>
<p>在使用RN应用程序时，我们通常使用不同的解决方案来管理应用程序的状态。我们可以使用Redux、MobX、React Query、React Context、XState或任何其他库。因为它以JS为中心，React Navigation不需要太多努力就可以将这些解决方案集成到应用程序中。然而，RNN为每个屏幕创建了新的片段，<a href="https://wix.github.io/react-native-navigation/docs/third-party-react-context" target="_blank" rel="noopener">需要一些变通方法来保持JS上下文在屏幕间的完整性</a>。这种变通方法对于来自web背景的开发人员来说可能有点痛苦，但是可以为大规模应用程序提供惊人的能力。</p>
<h2>在React导航和React本地导航中使用多个路由器</h2>
<p>TL；DR: React Navigation基于组件的API允许React风格的路由器隔离，而RNN使用<code>setRoot</code>在路由器之间移动。</p>
<p>在需要登录的应用程序中，开发人员通常喜欢不同的导航器来分别处理非登录和登录过程。使用React Navigation，这很容易实现，因为它是一个基于JS的导航器，并且提供了令人敬畏的API。使用多台路由器时，<a href="https://reactnavigation.org/docs/en/common-mistakes.html#explicitly-rendering-more-than-one-navigator" target="_blank" rel="noopener">请查看React Navigation </a>提供的指南，以避免任何麻烦。</p>
<p>相反，React Native Navigation允许您从应用程序中的任何位置设置导航的根，模拟您可以启动新活动或片段并清除现有堆栈的本机API。</p>
<h2>与其他第三方库集成</h2>
<p>TL；DR: React导航不太触及RN的核心架构，集成起来更简单。对于RNN来说，将RNN与第三方库集成在一起可能有点困难，但是他们完整的文档涵盖了如何做。</p>
<p>作为一个基于JavaScript的导航器，React Navigation可以与任何第三方库顺利集成，而RNN可能会受到与原生平台紧密耦合或需要包装在整个应用程序周围的库的影响。例如，RNN为集成像React Native脸书SDK这样的包提供了单独的指南。对于更多依赖原生库的应用程序来说，这可能是一个挑战，也可能是一个福音。</p>
<h2>与现有应用的集成</h2>
<p>TL；DR: React导航是棕色地带应用的英雄。RNN有一些这样做的技巧，但是图书馆不支持。</p>
<p>React Native的主要优势之一是它能够与您现有的任何本机应用程序集成。在这种情况下，与现有的原生解决方案相比，任何基于JS的导航器都工作得很好。这使得<a href="https://github.com/wix/react-native-navigation/issues/1234" target="_blank" rel="noopener"> React Navigation比RNN </a>更有优势，尤其是如果你希望用React Native为你现有应用的几个模块提供动力，就像脸书和许多其他棕色地带应用一样。</p>
<h2>两个库中的启动工作</h2>
<p>TL；DR:两个图书馆都有完整的文档，所以这里没有太大的区别。</p>
<p>如果你和你团队中的其他开发者没有本地应用开发的背景，你可能想要一个没有陡峭集成指南的解决方案。React导航只有在集成过程中稍有优势。</p>
<p>尽管有些开发人员有时发现很难开始，Wix 的这个<a href="https://wix.github.io/react-native-navigation/docs/installing" target="_blank" rel="noopener">官方指南可以帮助你开始工作。最近，RNN引入了一个基于</a><a href="https://wix.github.io/react-native-navigation/docs/installing/#installing-with-npx-rnn-link" target="_blank" rel="noopener"> npx的命令，将RNN安装在一个全新的React原生应用</a>中。Wix还有一个<a href="https://discordapp.com/channels/242515947020222464/339371162855276544" target="_blank" rel="noopener">有用的不和谐聊天</a>，可能是你遇到麻烦时的首选。</p>
<h2>React导航中的深度链接与React本机导航</h2>
<p>TL；DR:两个库都支持深度链接。</p>
<p>在社交媒体时代，大多数应用程序都有一种简单的方式，允许用户在他们的社交渠道上分享信息和活动。这要求我们在应用程序中启用深度链接。</p>
<p>假设您的应用程序显示博客，您希望用户在进入您的应用程序时直接登陆帖子屏幕。React Navigation和RNN目前都没有提供一种简单的方法来做到这一点。这两种方法在静态定义路线的情况下效果最佳。尽管您可以实现一些变通方法来实现这个特性，但这是以增加代码库的复杂性为代价的。</p>
<h2>开发团队和后盾</h2>
<p>TL；DR:两个库都是大规模团队和app开发和使用的。</p>
<p>当选择任何库时，可以显著影响应用程序的主要因素之一是维护该库的开发人员和贡献者的数量。React Navigation背后的团队由React本地核心和expo的积极贡献者组成。他们还在开发几个React原生应用，让他们对未来可能出现的问题有更广阔的视角。</p>
<p>今天，大量使用React Native构建的应用程序，包括CNN、彭博和城市词典，都在使用React导航。这里有一个<a href="https://twitter.com/notbrent/status/1116717557107417090" target="_blank" rel="noopener"> Twitter线程</a>列出了额外的应用程序。RNN得到了维克斯的支持。他们在生产中将其用于自己的应用程序，并专注于它的持续进步和发展。</p>
<h2>简而言之，反应导航与反应本地导航</h2>
<p>选择导航库是应用开发的关键一步。任何未经深思熟虑的决定都可能会损害应用程序的可伸缩性，或者在应用程序变大时产生其他问题。</p>
<p>依我看，React导航是目前最好的导航解决方案之一。它是一个被广泛采用的库，非常适合大多数用例。尽管存在某些已知的限制，但这是一个首选的解决方案。请记住，由于像react-native-screens和react-native-gesture-handler这样的库，它现在的性能得到了提升。</p>
<p>为了更深入的分析，你可以观看Brent Vatne 的这个<a href="https://www.youtube.com/watch?v=GBhdooVxX6Q" target="_blank" rel="noopener">精彩演讲，他是React Navigation的主要贡献者。Brent非常全面地比较了这两种导航解决方案。</a></p><div class="code-block code-block-17">
<div class="blog-plug inline-plug react-plug" vwo-el-id="26283398190">
<h2 vwo-el-id="41600691720"><a href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener"> LogRocket </a>:全面了解您的生产React应用</h2><p>调试React应用程序可能很困难，尤其是当用户遇到难以重现的问题时。如果您对监视和跟踪Redux状态、自动显示JavaScript错误以及跟踪缓慢的网络请求和组件加载时间感兴趣，</p><a href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" vwo-el-id="19356441070">try LogRocket</a><p>. </p><a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="19356441380">
<img class="first-react-image alignnone size-full wp-image-46 jetpack-lazy-image jetpack-lazy-image--handled" src="../Images/f300c244a1a1cf916df8b4cb02bec6c6.png" vwo-el-id="18272717540" data-lazy-loaded="1" data-original-src="https://files.readme.io/27c94e7-Image_2017-06-05_at_9.46.04_PM.png"/>
</a>
<a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="19356441690">
<img class="second-react-image alignnone size-full wp-image-46 jetpack-lazy-image jetpack-lazy-image--handled" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" vwo-el-id="30720362350" data-lazy-loaded="1" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/>
</a>
<p vwo-el-id="28675660440" class="">LogRocket 结合了会话回放、产品分析和错误跟踪，使软件团队能够创建理想的web和移动产品体验。这对你来说意味着什么？</p>
<p>LogRocket不是猜测错误发生的原因，也不是要求用户提供截图和日志转储，而是让您回放问题，就像它们发生在您自己的浏览器中一样，以快速了解哪里出错了。</p>
<p>不再有嘈杂的警报。智能错误跟踪允许您对问题进行分类，然后从中学习。获得有影响的用户问题的通知，而不是误报。警报越少，有用的信号越多。</p>
<p vwo-el-id="28675660750">LogRocket Redux中间件包为您的用户会话增加了一层额外的可见性。LogRocket记录Redux存储中的所有操作和状态。</p>
<p vwo-el-id="28675661060">现代化您调试React应用的方式— <a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="40093418840">开始免费监控</a>。</p><div class="code-block code-block-18">
<div class="blog-plug inline-plug react-native-plug"><h2><a href="https://lp.logrocket.com/blg/react-native-signup"> LogRocket </a>:即时重现React原生应用中的问题。</h2><a class="signup" href="https://lp.logrocket.com/blg/react-native-signup" target="_blank" rel="noopener noreferrer"><img class="alignnone size-full wp-image-46 jetpack-lazy-image" src="../Images/110055665562c1e02069b3698e6cc671.png" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2021/10/react-native-plug_v2-2.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2021/10/react-native-plug_v2-2.png"/><noscript><img data-lazy-fallback="1" class="alignnone size-full wp-image-46" src="../Images/110055665562c1e02069b3698e6cc671.png" data-original-src="https://blog.logrocket.com/wp-content/uploads/2021/10/react-native-plug_v2-2.png"/></noscript></a><p><a href="https://lp.logrocket.com/blg/react-native-signup" target="_blank" rel="noopener noreferrer"> LogRocket </a>是一款React原生监控解决方案，可帮助您即时重现问题、确定bug的优先级并了解React原生应用的性能。</p><p>LogRocket还可以向你展示用户是如何与你的应用程序互动的，从而帮助你提高转化率和产品使用率。LogRocket的产品分析功能揭示了用户不完成特定流程或不采用新功能的原因。</p><p>开始主动监控您的React原生应用— <a class="signup" href="https://lp.logrocket.com/blg/react-native-signup" target="_blank" rel="noopener noreferrer">免费试用LogRocket】。</a></p></div>
</div>
</div></div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
<html>
<head>
<title>Improve your webpack build with the DLL plugin - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>用DLL插件改进你的webpack构建</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/speed-up-your-webpack-build-with-the-dll-plugin/#0001-01-01">https://blog.logrocket.com/speed-up-your-webpack-build-with-the-dll-plugin/#0001-01-01</a></blockquote><div><article class="article-post">
<p>作为一名JavaScript开发人员，您可能有很多机会接触到webpack，无论是在用React捆绑前端资产还是传输一些TypeScript Node.js代码时。</p>
<p>大多数情况下，您不必直接与webpack交互。相反，您作为构建工具的依赖项间接地与webpack交互。但是如果您开发这些构建工具，或者管理您自己的webpack配置，本教程将帮助您缩短构建时间。</p>
<p>我们将使用DLL插件，webpack在其文档中承诺“极大地改善加载时间”。</p>
<h2>它是如何工作的？</h2>
<p>DLL插件创建了两个东西:</p>
<ul>
<li>一个<code>manifest.json</code>文件</li>
<li>不经常改变的一组模块</li>
</ul>
<p>如果没有启用DLL插件，webpack会编译您的代码库中的所有文件，不管它是否被修改过。这导致编译时间比需要的时间长。</p>
<p>但是有一种方法可以告诉webpack不要麻烦地重新编译几乎不变的库:例如，您的<code>node_modules</code>文件夹中的库。</p>
<p>这就是DLL插件的用武之地。它捆绑了您指定为很少更改的代码(例如，供应商库)，并且不再编译它们，极大地改进了构建时间。</p>
<p>DLL插件通过创建一个<code>manifest.json</code>文件来做到这一点。该文件用于将导入请求映射到捆绑模块。当从其他包向一个模块发出导入请求时，webpack检查在<code>manifest.json</code>文件中是否有一个条目指向该模块。如果是这样，它会跳过构建该模块。</p>
<h2>概观</h2>
<p>DLL插件应该用于很难改变的代码包，比如你的供应商包。因此，您需要一个单独的webpack配置文件。在此了解如何创建供应商捆绑包<a href="https://blog.logrocket.com/guide-performance-optimization-webpack/" target="_blank" rel="noopener noreferrer">。</a></p>
<p>在本教程中，我们将使用两种webpack配置。这些将被命名为<code>webpack.config.js</code>和<code>webpack.vendor.config.js</code>。</p>
<p><code>webpack.config.js</code>将是非供应商代码的主要配置；即经常修改的代码。</p>
<p><code>webpack.vendor.config.js</code>将用于你不变的包，就像<code>node_modules</code>中的库。</p>
<p>要使用DLL插件，必须在适当的webpack配置中安装两个插件:</p>
<p>DllReferencePlugin → <code>webpack.config.js</code> <br/> DllPlugin → <code>webpack.vendor.config.js</code></p>
<p>我们将使用webpack版本4.x，因为5.x仍处于测试阶段。但是，它们的配置相似。</p>
<h3>配置DLL插件(<code>webpack.vendor.config.js</code>)</h3>
<p>DLL插件有以下强制选项:</p>
<ul>
<li><code>name</code>:这是DLL函数的名称。什么都可以叫。我们将称之为<code>vendor_lib</code>。</li>
<li><code>path</code>:这是输出的清单json文件的路径。它必须是绝对路径。我们将把它存储在根目录下名为“build”的文件夹中。该文件将被称为<code>vendor-manifest.json</code>。</li>
</ul>
<p>为了指定路径，我们应该像这样使用<code>path.join</code>:</p>
<pre>path.join(__dirname, 'build', 'vendor-manifest.json')</pre>
<p>在<code>webpack.vendor.config.js</code>文件中，确保<code>output.library</code>与DLL插件<code>name</code>选项相同。</p>
<p>包括任意多的入口点。在这个例子中，我包含了一些非常重要的库。使用这个插件时，你的输出文件夹无关紧要。</p>
<p>下面是<code>webpack.vendor.config.js</code>现在的样子:</p>
<pre>var webpack = require('webpack')
const path = require('path');
module.exports = {
    mode: 'development',
    entry: {
        vendor: ['lodash', 'react', 'angular', 'bootstrap', 'd3', 'jquery', 'highcharts', 'vue']
    },
    output: {
        filename: 'vendor.bundle.js',
        path: path.join(__dirname, 'build'),
        library: 'vendor_lib'
    },
    plugins: [
        new webpack.DllPlugin({
            name: 'vendor_lib',
            path: path.join(__dirname, 'build', 'vendor-manifest.json')
        })
    ]
}</pre>
<h3>配置DllReferencePlugin ( <code>webpack.config.js</code>)</h3>
<p>DllReferencePlugin有两个必填字段:</p>
<ul>
<li><code>context</code>:这是包含构建文件夹的目录的绝对路径。在本教程中，将其作为<code>__dirname</code>。</li>
<li><code>manifest</code>:这是DLL的清单json文件的绝对路径。我们将把它设置为<code>path.join(__dirname, 'build', 'vendor-manifest.json')</code>。</li>
</ul>
<p>你的<code>webpack.config.js</code>应该是这样的:</p>
<pre>const webpack = require("webpack")
var path = require("path");
// const BundleAnalyzerPlugin = require('webpack-bundle-analyzer').BundleAnalyzerPlugin;
const SpeedMeasurePlugin = require("speed-measure-webpack-plugin");
const smp = new SpeedMeasurePlugin();
module.exports = smp.wrap({
  mode: 'development',
  entry: {
    app: ['./src/index.js']
  },
  output: {
    filename: 'main.bundle.js',
    path: path.join(__dirname, 'build')
  },
  plugins: [
    new webpack.DllReferencePlugin({
      context: __dirname,
      manifest: path.join(__dirname, 'build', 'vendor-manifest.json')
    }),
    // new BundleAnalyzerPlugin()
  ]
})</pre>
<p>至此，我们完成了DLL插件的设置。</p>
<h3>构建包</h3>
<h4>生成DLL <code>manifest.json</code></h4>
<p>您首先需要使用<code>webpack.vendor.config.js</code>配置运行webpack，它会生成<code>webpack.config.js</code>工作所需的<code>vendor.manifest.json</code>。这个构建可以在每个开发会话开始时完成，当它的配置发生变化时，或者当供应商捆绑包中的库版本发生变化时。</p>
<p>将这个脚本添加到您的<code>package.json</code>文件中。它将创建清单json文件和供应商包:</p>
<pre>"scripts": {
    "buildVendor": "webpack --config webpack.vendor.config"
}</pre>
<p>在随后的代码更改中，您只需使用<code>webpack.config.js</code>。</p>
<h4>构建主包</h4>
<p>然后为主包添加一个构建脚本:</p>
<pre>  "scripts": {
    "buildVendor": "webpack --config webpack.vendor.config",
    "build": "webpack --config webpack.config.js"
  }</pre>
<h2>基准</h2>
<p>为了测试这个插件，我在<code>src/index.js</code>文件中实例化了一个简单的Vue.js应用程序。它将导入一些重要的依赖项:</p>
<pre>import Vue from "vue"
import lodash from 'lodash'
import 'react'
import 'angular'
import 'bootstrap'
import 'd3'
import 'jquery'
import 'highcharts'
export default function createApp() {
  // vendor()
  const el = document.createElement("div")
  el.setAttribute("id", "app")
  document.body.appendChild(el)
  console.log("hello")
  new Vue({
    el: "#app",
    render: h =&gt; h("h1", "Hello world")
  })
}
document.addEventListener('DOMContentLoaded', () =&gt; {
  createApp()
})</pre>
<p>为了导入由webpack config创建的两个包，我们需要将以下脚本标记添加到<code>index.html</code>头中:</p>
<pre>&lt;head&gt;
  &lt;title&gt;Webpack DllPlugin Test&lt;/title&gt;
  &lt;script src="/build/vendor.bundle.js"&gt;&lt;/script&gt;
  &lt;script src="/build/main.bundle.js"&gt;&lt;/script&gt;
&lt;/head&gt;</pre>
<p>使用<a href="https://www.npmjs.com/package/speed-measure-webpack-plugin" target="_blank" rel="noopener noreferrer">speed-measure-web pack-plugin</a>测试包给出了以下基准:</p>
<p>规格:i5-6200U 8gb内存windows 10</p>
<p><strong>使用DllPlugin(平均3次构建)</strong> <br/>构建厂商捆绑:<br/>* 3370毫秒</p>
<p>建筑主束:<br/> 146.6ms</p>
<p><strong>无DllPlugin(平均3次构建)</strong> <br/>构建供应商捆绑:<br/>3312毫秒</p>
<p>建筑主包:<br/> 3583.6ms</p>
<p>假设您只在编码会话开始时构建了供应商包，并且在一个会话中重新加载了一百次，下面是您将花费在等待上的总时间:</p>
<p><strong>带DllPlugin</strong><br/>3370+(146.6 * 100)= 18030 ms</p><div class="code-block code-block-54">
<hr/>
<h3>更多来自LogRocket的精彩文章:</h3>

<hr/></div>
<p><strong>无DllPlugin</strong><br/>3312+(3583.6 * 100)= 361672 ms</p>
<p>这意味着构建时间减少了95%!带来难以置信的生产率提高。</p>
<h2>结论</h2>
<p>这种优化不会以任何方式应用到您的产品构建中。它只缓存指定的包来加速开发构建。</p>
<p>查看<a href="https://github.com/scroobius-pip/webpackdlltutorial" target="_blank" rel="noopener noreferrer"> GitHub repo </a>获取教程代码。</p><div class="code-block code-block-1">
<div class="blog-plug base-cta"><h2>使用<a class="signup" href="https://lp.logrocket.com/blg/signup" target="_blank" rel="noopener noreferrer"> LogRocket </a>消除传统错误报告的干扰</h2>
<a href="https://lp.logrocket.com/blg/signup" class="signup" target="_blank" rel="noopener noreferrer"><img class="alignnone size-full wp-image-46 jetpack-lazy-image" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/><noscript><img data-lazy-fallback="1" class="alignnone size-full wp-image-46" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/></noscript></a>
<p><a href="https://lp.logrocket.com/blg/signup" target="_blank" rel="noopener noreferrer"> LogRocket </a>是一个数字体验分析解决方案，它可以保护您免受数百个假阳性错误警报的影响，只针对几个真正重要的项目。LogRocket会告诉您应用程序中实际影响用户的最具影响力的bug和UX问题。</p>
<p>然后，使用具有深层技术遥测的会话重放来确切地查看用户看到了什么以及是什么导致了问题，就像你在他们身后看一样。</p>
<p>LogRocket自动聚合客户端错误、JS异常、前端性能指标和用户交互。然后LogRocket使用机器学习来告诉你哪些问题正在影响大多数用户，并提供你需要修复它的上下文。</p>
<p>关注重要的bug—<a class="signup" href="https://lp.logrocket.com/blg/signup-issue-free" target="_blank" rel="noopener noreferrer">今天就试试LogRocket】。</a></p></div></div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
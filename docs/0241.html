<html>
<head>
<title>Common JavaScript “gotchas” - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>常见的JavaScript“gotchas”-log rocket博客</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/common-javascript-gotchas-638bdea2a224/#0001-01-01">https://blog.logrocket.com/common-javascript-gotchas-638bdea2a224/#0001-01-01</a></blockquote><div><article class="article-post">
<p class="graf graf--p">自从我们克服了<a class="markup--anchor markup--p-anchor" href="https://en.wikipedia.org/wiki/ECMAScript#4th_Edition_%28abandoned%29" target="_blank" rel="noreferrer nofollow noopener" data-href="https://en.wikipedia.org/wiki/ECMAScript#4th_Edition_(abandoned)"> Harmony </a>以来，JavaScript已经获得了许多新的、甜蜜的特性，虽然更多的特性可以让我们编写出可读的、高质量的代码，但我们也很容易过分追求新的、闪亮的东西，并陷入一些潜在的陷阱。</p>
<p class="graf graf--p">让我们回顾一下我经常看到的一些困惑的来源，不管是新的还是旧的。</p>
<h3 class="graf graf--h3">箭头函数和对象文字</h3>
<p class="graf graf--p"><a class="markup--anchor markup--p-anchor" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions" target="_blank" rel="noreferrer nofollow noopener" data-href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions"> Arrow functions </a>提供了一个更简洁的语法，其中一个可用的特性是你可以把你的函数写成一个lambda表达式，带有一个隐式返回值。这对于函数式代码来说很方便，比如当您必须使用函数来映射数组时。这将是相当多的具有常规功能的空行。</p>
<p class="graf graf--p">例如:</p>
<pre class="graf graf--pre"><strong class="markup--strong markup--pre-strong">const</strong> numbers = [1, 2, 3, 4];
numbers.map(function(n) {
  return n * n;
});</pre>
<p class="graf graf--p">成为一个简洁易读的带有lambda风格箭头函数的一行程序:</p>
<pre class="graf graf--pre"><strong class="markup--strong markup--pre-strong">const</strong> numbers = [1, 2, 3, 4];
numbers.map(n =&gt; n * n);</pre>
<p class="graf graf--p">这个arrow函数的用例将会像预期的那样工作，它将值与自身相乘，然后返回一个包含<code>[1, 4, 9, 16]</code>的新数组。</p>
<p class="graf graf--p">但是，如果您尝试映射到对象中，但是语法并不像人们直觉上预期的那样，例如，假设我们尝试将数字映射到包含如下值的对象数组中:</p>
<pre class="graf graf--pre"><strong class="markup--strong markup--pre-strong">const</strong> numbers = [1, 2, 3, 4];
numbers.map(n =&gt; { value: n });</pre>
<p class="graf graf--p">这里的结果实际上将是一个包含未定义值的数组。虽然看起来我们在这里返回了一个对象，但是解释器看到了完全不同的东西。花括号被解释为arrow函数的块作用域，value语句实际上是一个标签。如果我们将上面的箭头函数外推至解释器实际执行的结果，它看起来会像这样:</p>
<pre class="graf graf--pre"><strong class="markup--strong markup--pre-strong">const</strong> numbers = [1, 2, 3, 4];
numbers.map(function(n) {
  value:
  n
  return;
});</pre>
<p class="graf graf--p">解决方法非常微妙，我们只需要将对象放在括号中，这样就可以将它变成一个表达式，而不是块语句，就像这样:</p>
<pre class="graf graf--pre">const numbers = [1, 2, 3, 4];
numbers.map(n =&gt; ({ value: n }));</pre>
<p class="graf graf--p">将计算出一个数组，该数组包含一个对象数组，其值与预期值相同。</p>
<figure class="graf graf--figure graf--layoutOutsetCenter"><a class="graf-imageAnchor" href="https://logrocket.com/signup/" target="_blank" rel="noopener noreferrer" data-href="https://logrocket.com/signup/" data-action="image-link" data-action-observe-only="true"><img decoding="async" class="graf-image jetpack-lazy-image" src="../Images/94b3e0f84b30cb0d321f60471481ab64.png" data-image-id="1*GPjaPKNNUYHU8EsA3Z0JGA.png" data-width="3212" data-height="750" data-lazy-src="https://storage.googleapis.com/blog-images-backup/1*GPjaPKNNUYHU8EsA3Z0JGA.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://storage.googleapis.com/blog-images-backup/1*GPjaPKNNUYHU8EsA3Z0JGA.png"/><noscript><img data-lazy-fallback="1" decoding="async" class="graf-image" src="../Images/94b3e0f84b30cb0d321f60471481ab64.png" data-image-id="1*GPjaPKNNUYHU8EsA3Z0JGA.png" data-width="3212" data-height="750" data-original-src="https://storage.googleapis.com/blog-images-backup/1*GPjaPKNNUYHU8EsA3Z0JGA.png"/></noscript></a></figure>
<h3 class="graf graf--h3">箭头函数和绑定</h3>
<p class="graf graf--p">关于箭头函数的另一个警告是，它们没有自己的<code>this</code>绑定，这意味着它们的<code>this</code>值将与封闭词法范围的<code>this</code>值相同。</p>
<p class="graf graf--p">因此，尽管语法被认为“更光滑”,但箭头函数不是好的“ol”函数的替代物。你很快会遇到这样的情况，你的<code>this</code>绑定不是你想象的那样。</p>
<p class="graf graf--p">例如:</p>
<pre class="graf graf--pre">let calculator = {
  value: 0,
  add: (values) =&gt; {
    this.value = values.reduce((a, v) =&gt; a + v, this.value);
  },
};
calculator.add([1, 2, 3]);
console.log(calculator.value);</pre>
<p class="graf graf--p">虽然人们可能认为这里的<code>this</code>绑定是那里的calculator对象，但实际上它将导致<code>this</code>要么是未定义的，要么是全局对象，这取决于代码是否在严格模式下运行。这是因为这里最接近的词法范围是全局范围，在未定义的严格模式下，否则，它就是浏览器中的窗口对象(或者Node.js兼容环境中的进程对象)。</p>
<p class="graf graf--p">常规函数确实有一个<code>this</code>绑定，当在一个对象上被调用时，它将指向该对象，所以使用常规函数仍然是成员函数的方法。</p>
<pre class="graf graf--pre"><strong class="markup--strong markup--pre-strong">let</strong> calculator = {
  value: 0,
  add(values) {
    <strong class="markup--strong markup--pre-strong">this</strong>.value = values.reduce((a, v) =&gt; a + v, <strong class="markup--strong markup--pre-strong">this</strong>.value);
  },
};
calculator.add([10, 10]);
console.log(calculator.value);</pre>
<p class="graf graf--p">此外，由于arrow函数没有<code>this</code>绑定<a class="markup--anchor markup--p-anchor" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/call" target="_blank" rel="noopener noreferrer" data-href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/call">function . prototype . call</a>,<a class="markup--anchor markup--p-anchor" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/bind" target="_blank" rel="noopener noreferrer" data-href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/bind">function . prototype . bind</a>和<a class="markup--anchor markup--p-anchor" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/apply" target="_blank" rel="noopener noreferrer" data-href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/apply"> Function.prototype.apply </a>也不能使用它们。当arrow函数被声明时,<code>this</code>绑定是固定的，不能改变。</p>
<p class="graf graf--p">因此，在下面的例子中，我们将遇到与前面相同的问题，当调用加法器的add函数时，<code>this</code>绑定是全局对象，尽管我们试图用<a class="markup--anchor markup--p-anchor" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/call" target="_blank" rel="noopener noreferrer" data-href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/call"> Function.prototype.call </a>覆盖它:</p>
<pre class="graf graf--pre"><strong class="markup--strong markup--pre-strong">const</strong> adder = {
  add: (values) =&gt; {
    <strong class="markup--strong markup--pre-strong">this</strong>.value = values.reduce((a, v) =&gt; a + v, <strong class="markup--strong markup--pre-strong">this</strong>.value);
  },
};
<strong class="markup--strong markup--pre-strong">let</strong> calculator = {
  value: 0
};
adder.call(calculator, [1, 2, 3]);</pre>
<p class="graf graf--p">箭头函数很简洁，但是在需要绑定的地方，它们不能代替常规的成员函数。</p>
<h3 class="graf graf--h3">自动分号插入</h3>
<p class="graf graf--p">虽然这不是新特性，但自动分号插入(ASI)是JavaScript中比较奇怪的特性之一，所以值得一提。理论上，大多数情况下可以省略分号(许多项目就是这样做的)。如果这个项目有先例，你应该遵循它，但是，你需要意识到ASI是一个特性，否则你最终会得到具有欺骗性的代码。</p>
<p class="graf graf--p">举以下例子:</p>
<pre class="graf graf--pre"><strong class="markup--strong markup--pre-strong">return</strong>
{
  value: 42
}</pre>
<p class="graf graf--p">人们可能会认为它会返回对象文字，但实际上它会返回undefined，因为分号的插入使它成为一个空的返回语句，后面跟着一个block语句和一个label语句。</p>
<p class="graf graf--p">换句话说，实际被解释的最终代码看起来更像下面这样:</p>
<pre class="graf graf--pre"><strong class="markup--strong markup--pre-strong">return</strong>;
{
  value: 42
};</pre>
<p class="graf graf--p">根据经验，即使使用分号，也不要以大括号、方括号或模板字符串开始一行，因为ASI总是出现。</p>
<h3 class="graf graf--h3">浅集</h3>
<p class="graf graf--p">集合是浅层的，这意味着具有相同值的重复数组和对象将导致集合中有多个条目。</p>
<p class="graf graf--p">例如:</p>
<pre class="graf graf--pre"><strong class="markup--strong markup--pre-strong">let</strong> set = <strong class="markup--strong markup--pre-strong">new</strong> Set();
set.add([1, 2, 3]);
set.add([1, 2, 3]);

console.log(set.length);</pre>
<p class="graf graf--p">这个集合的大小是2，如果你从引用的角度来考虑，这是有意义的，因为它们是不同的对象。</p>
<p class="graf graf--p">然而，字符串是不可变的，所以一个集合中的多个字符串如下:</p>
<pre class="graf graf--pre"><strong class="markup--strong markup--pre-strong">let</strong> set = <strong class="markup--strong markup--pre-strong">new</strong> Set();
set.add([1, 2, 3].join(','));
set.add([1, 2, 3].join(','));
console.log(set.size);</pre>
<p class="graf graf--p">将最终得到一个大小为1的集合，因为字符串是不可变的，并且被固定在JavaScript中，如果您发现自己需要存储一组可以序列化和反序列化的对象，这可以作为一种变通方法。</p>
<h3 class="graf graf--h3">类和时间死区</h3>
<p class="graf graf--p">在JavaScript中，常规函数被提升到词法范围的顶部，这意味着下面的例子将会如人们所预期的那样工作:</p>
<pre class="graf graf--pre"><strong class="markup--strong markup--pre-strong">let</strong> segment = <strong class="markup--strong markup--pre-strong">new</strong> Segment();
<strong class="markup--strong markup--pre-strong">
function</strong> Segment() {
  <strong class="markup--strong markup--pre-strong">this</strong>.x = 0;
  <strong class="markup--strong markup--pre-strong">this</strong>.y = 0;
}</pre>
<p class="graf graf--p">但是对于类来说就不一样了，类实际上并没有被提升，在你试图使用它们之前，需要在词法范围内被完全定义。</p>
<p class="graf graf--p">例如:</p>
<pre class="graf graf--pre"><strong class="markup--strong markup--pre-strong">let</strong> segment = <strong class="markup--strong markup--pre-strong">new</strong> Segment();

<strong class="markup--strong markup--pre-strong">class</strong> Segment {
  constructor() {
    <strong class="markup--strong markup--pre-strong">this</strong>.x = 0;
    <strong class="markup--strong markup--pre-strong">this</strong>.y = 0;
  }
}</pre>
<p class="graf graf--p">将导致ReferenceError，因为它们不像函数那样被提升。</p>
<h3 class="graf graf--h3">最后</h3>
<p class="graf graf--p">最后是一个有点特殊的例子，看看下面的片段:</p>
<pre class="graf graf--pre"><strong class="markup--strong markup--pre-strong">try</strong> {
  <strong class="markup--strong markup--pre-strong">return</strong> true;
} <strong class="markup--strong markup--pre-strong">finally</strong> {
  <strong class="markup--strong markup--pre-strong">return</strong> false;
}</pre>
<p class="graf graf--p">你认为它会返回什么值？答案既直观，同时也可能变得不直观。人们可能认为第一个return语句使函数实际返回并弹出调用堆栈，但这是该规则的例外，因为finally语句总是运行的，所以finally块中的return语句改为返回。</p><div class="code-block code-block-54">
<hr/>
<h3>更多来自LogRocket的精彩文章:</h3>

<hr/></div>
<h3 class="graf graf--h3">最后</h3>
<p class="graf graf--p">JavaScript容易学习，但很难掌握，换句话说，它容易出错，除非开发人员仔细了解他们在做什么和为什么要做什么。</p>
<p class="graf graf--p">对于ECMAScript 6来说尤其如此，尤其是它的甜蜜特性，尤其是箭头函数，一直都在出现。如果要我猜的话，我会说这是因为开发人员认为它们比常规函数更漂亮，但它们不是常规函数，也不能替代它们。</p>
<p class="graf graf--p">时不时的略读一下<a class="markup--anchor markup--p-anchor" href="https://www.ecma-international.org/ecma-262/9.0/index.html" target="_blank" rel="noreferrer nofollow noopener" data-href="https://www.ecma-international.org/ecma-262/9.0/index.html">说明书</a>也无妨。这不是世界上最令人兴奋的文档，但就规范而言，它还不错。</p>
<p class="graf graf--p">像AST Explorer这样的工具也有助于揭示一些正在发生的事情。在某些情况下，人类和计算机倾向于以不同的方式解析事物。</p>
<p class="graf graf--p">也就是说，我将把最后一个例子留给你们作为练习。</p><div class="code-block code-block-27">
<div class="blog-plug inline-plug vanilla-javascript-cta"><h2>通过理解上下文，更容易地调试JavaScript错误</h2>
<p>调试代码总是一项单调乏味的任务。但是你越了解自己的错误，就越容易改正。</p>
<p>LogRocket 让你以新的独特的方式理解这些错误。我们的前端监控解决方案跟踪用户与您的JavaScript前端的互动，让您能够准确找出导致错误的用户行为。</p>
<a href="https://lp.logrocket.com/blg/javascript-signup" class="signup" target="_blank" rel="noopener noreferrer"><img class="alignnone size-full wp-image-46 jetpack-lazy-image" src="../Images/cbfed9be3defcb505e662574769a7636.png" alt="LogRocket Dashboard Free Trial Banner" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2020/06/reproduce-javascript-errors.gif?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/06/reproduce-javascript-errors.gif"/><noscript><img data-lazy-fallback="1" class="alignnone size-full wp-image-46" src="../Images/cbfed9be3defcb505e662574769a7636.png" alt="LogRocket Dashboard Free Trial Banner" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/06/reproduce-javascript-errors.gif"/></noscript></a>
<p>LogRocket记录控制台日志、页面加载时间、堆栈跟踪、慢速网络请求/响应(带有标题+正文)、浏览器元数据和自定义日志。理解您的JavaScript代码的影响从来没有这么简单过！</p>
<a class="signup" href="https://lp.logrocket.com/blg/javascript-signup" target="_blank" rel="noopener noreferrer">Try it for free</a><p>.</p></div>


</div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
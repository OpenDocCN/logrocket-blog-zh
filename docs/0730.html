<html>
<head>
<title>How to use React Hooks with Firebase Firestore - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>如何使用Firebase Firestore - LogRocket博客的React挂钩</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/how-to-use-react-hooks-firebase-firestore/#0001-01-01">https://blog.logrocket.com/how-to-use-react-hooks-firebase-firestore/#0001-01-01</a></blockquote><div><article class="article-post">
<p><em> <strong>编者按</strong>:这篇文章最后更新于2022年2月2日，以反映<a href="https://firebase.google.com/support/releases" target="_blank" rel="noopener">对Firebase的最新更新</a>。</em></p>
<p>React钩子和Firebase有什么共同点？它们都加速了开发，减少了构建复杂的东西所需的代码量。</p>
<p>当您将Firestore的强大和简单与简单高效的React功能组件和挂钩结合起来时，您可以非常快速地将web应用程序与数据持久性结合起来，这实际上是非常令人难以置信的。在本文中，我们将学习如何将Firestore和React Hooks结合起来，创建一个简单高效的购物清单应用程序。</p>
<p>您可以通过此目录跳转到教程的特定部分:</p>

<h2 id="How-hooks-accelerate-development">钩子如何加速开发？</h2>
<p>首先，快速复习一下React钩子。钩子允许您将有状态逻辑定义为可重用的函数，可以在整个React应用程序中使用。钩子还使功能组件能够绑定到组件生命周期中，这在以前只有类组件才有可能。</p>
<p>当创建需要处理生命周期事件的组件时，React没有规定是否应该使用功能组件和钩子。或者更传统的类组件。</p>
<p>也就是说，函数组件和钩子已经迅速成为React开发者社区的一大亮点——这是有充分理由的。与类组件相比，函数组件和钩子大大减少了React应用程序的代码量和冗长性。</p>
<h2 id="how-firestore-accelerate-development">Firestore如何加速发展？</h2>
<p>Firebase是一个服务和工具的集合，开发人员可以将它们组合在一起，快速创建具有高级功能的web和移动应用程序。Firebase服务运行在谷歌云平台之上，这意味着高度的可靠性和可扩展性。</p>
<p>Firestore是Firebase中包含的服务之一。Firestore是一个基于云的、可扩展的NoSQL文档数据库。它最显著的特点之一是能够轻松地将数据的变化实时传输到网络和移动应用程序中。您将很快在一个示例应用程序中看到这一点。</p>
<p>Firestore身份验证和安全规则模型进一步加速了Web应用程序的开发。Firestore web API允许您的web应用程序直接从浏览器与Firestore数据库进行交互，而无需服务器端配置或代码。这实际上就像建立一个Firebase项目，将API集成到客户端JavaScript代码中，然后读取和写入数据一样简单。</p>
<p>React功能组件、钩子和Firestore web API相互补充得非常好。是时候看看所有这些是如何运作的了。让我们来看看一个示例杂货清单web应用程序及其部分代码。</p>
<h2 id="How-to-use-firebase-react-hooks">如何将Firebase与React挂钩一起使用:杂货清单web应用程序</h2>
<p>为了探索在Firebase中使用React钩子，我们需要一些示例代码。让我们以购物清单web应用程序为例。</p>
<p><img data-attachment-id="91073" data-permalink="https://blog.logrocket.com/how-to-use-react-hooks-firebase-firestore/grocery-list-web-app-2/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/03/Grocery-list-web-app-1.png" data-orig-size="730,386" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Grocery-list-web-app" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/03/Grocery-list-web-app-1-300x159.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/03/Grocery-list-web-app-1.png" decoding="async" class="size-full wp-image-91073 aligncenter jetpack-lazy-image" src="../Images/70fe6af9e38fd99959dc216d9ca4941b.png" alt="Grocery list web app" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2020/03/Grocery-list-web-app-1.png 730w, https://blog.logrocket.com/wp-content/uploads/2020/03/Grocery-list-web-app-1-300x159.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2020/03/Grocery-list-web-app-1.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/03/Grocery-list-web-app-1.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="91073" data-permalink="https://blog.logrocket.com/how-to-use-react-hooks-firebase-firestore/grocery-list-web-app-2/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/03/Grocery-list-web-app-1.png" data-orig-size="730,386" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Grocery-list-web-app" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/03/Grocery-list-web-app-1-300x159.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/03/Grocery-list-web-app-1.png" decoding="async" loading="lazy" class="size-full wp-image-91073 aligncenter" src="../Images/70fe6af9e38fd99959dc216d9ca4941b.png" alt="Grocery list web app" srcset="https://blog.logrocket.com/wp-content/uploads/2020/03/Grocery-list-web-app-1.png 730w, https://blog.logrocket.com/wp-content/uploads/2020/03/Grocery-list-web-app-1-300x159.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/03/Grocery-list-web-app-1.png"/></noscript>
<p>你可以<a href="https://fir-with-react-hooks.firebaseapp.com/" target="_blank" rel="noopener">亲自尝试一下购物清单网络应用</a>。请忽略从20世纪90年代网站墓地复活的CSS样式——UI设计显然不是我的强项。</p>
<p>如果你还没有试用过这个应用，你可能会想知道它是如何工作的。本质上，它允许你创建一个新的购物清单。杂货列表的URL可以与其他用户共享，然后他们可以加入该列表并添加自己的杂货项目。</p>
<p>食品清单上的商品一旦被添加到数据库中，就会立即出现在屏幕上。这就创造了一个共享的体验，多个用户可以同时向列表中添加项目，并看到彼此的添加内容。</p>
<p>杂货清单web应用程序完全是使用React函数组件和钩子构建的。杂货清单和用户数据被保存到Firestore。web应用程序本身使用Firebase主机托管。</p>
<p>在GitHub <a href="https://github.com/Tammibriggs/firebase-with-react-hooks" target="_blank" rel="noopener">的这个库</a>中可以找到杂货清单应用程序的完整源代码。</p>
<h2 id="Firebase-web-app-configuration-installation">Firebase web应用程序配置和初始化</h2>
<p>所有调用Firebase web API来检索或更新Firestore上的数据的调用都被集中在<code>src/services/firestore.js</code>中。在该文件的顶部，您会看到Firebase应用程序的初始化代码，如下所示:</p>
<pre class="language-javascript hljs">const firebaseConfig = {
    apiKey: process.env.REACT_APP_FIREBASE_API_KEY,
    authDomain: process.env.REACT_APP_FIREBASE_AUTH_DOMAIN,
    projectId: process.env.REACT_APP_FIREBASE_PROJECT_ID
};

const app = initializeApp(firebaseConfig);
const db = getFirestore(app)
</pre>
<p>在模块化Firebase SDK中，函数从各自的模块中独立导入，而不是像在Firebase v8中那样从一个名称空间链接。你会注意到<code>initializeApp</code>和<code>getFirestore</code>的用法。</p>
<p>为了使用Firebase服务，您必须为<code>initializeApp</code>函数提供一些配置，并初始化您想要使用的服务的一个实例(在本例中是Firestore)。每个服务的初始化都需要不同的函数，对于Firestore来说，就是<code>getFirestore</code>。</p>
<p>您需要向<code>initializeApp</code>函数提供的配置取决于您正在使用的Firebase服务。在本例中，我只使用Firestore，所以只需要一个API密钥、认证域和项目ID。一旦你创建了一个Firebase项目并添加了一个web应用程序，你可以在<a href="https://console.firebase.google.com/" target="_blank" rel="noopener"> Firebase控制台</a>的项目设置屏幕的<strong> General </strong>选项卡上找到你独特的配置设置。</p>
<p>乍一看，Firebase配置设置似乎应该是私有的，不应该在浏览器中公开。然而，事实并非如此；将它们包含在客户端JavaScript中是安全的。使用<a href="https://blog.logrocket.com/user-authentication-firebase-react-apps/" target="_blank" rel="noopener"> Firebase认证</a>和Firestore安全规则来保护您的应用程序。我不会进入那些细节，但你可以在这里阅读更多关于它的<a href="https://firebase.google.com/docs/firestore/security/get-started" target="_blank" rel="noopener">。</a></p>
<p>您可能还注意到，我用全局<code>process.env</code>对象上定义的React环境变量替换了配置值。您可能不希望在您的源代码存储库中包含这种配置，尤其是如果您的存储库是公开可用的，并且打算由其他开发人员共享和克隆。</p>
<p>开发人员一定会下载并运行您的代码，而不会意识到他们正在消耗您的Firebase资源。相反，我选择了包含一个样本<a href="https://github.com/Tammibriggs/firebase-with-react-hooks/blob/main/.env" target="_blank" rel="noopener">。env </a>文件，记录运行应用程序之前必须提供的配置设置。当我自己在本地运行应用程序时，我有自己的<code>.env.local</code>文件，它没有被签入源代码控制。</p>
<h2 id="writing-data-firestore">将数据写入firestorm</h2>
<p>一旦设置好Firebase配置，开始从Firestore数据库读写数据只需要很少的代码。</p>
<p>在其基本形式中，Firestore数据库由文档集合组成。一个文档可以包含多个不同类型的字段，包括一个允许您嵌套文档集合的子集合类型。所有这些结构都是在JavaScript代码调用Firebase API写入数据时动态生成的。</p><div class="code-block code-block-54">
<hr/>
<h3>更多来自LogRocket的精彩文章:</h3>

<hr/></div>
<p>向Firestore写入数据的函数有<code>setDoc</code>和<code>addDoc</code>。这两个函数在幕后做同样的事情，但区别在于它们的使用方式。当您使用<code>setDoc</code>创建文档时，您必须为该文档指定一个ID，而对于<code>addDoc</code>，Firestore会在提供收藏参考和文档数据时自动为您生成一个ID。</p>
<p>例如，下面的代码使用<code>addDoc</code>在<code>groceryLists</code>集合中创建新的杂货列表文档:</p>
<pre class="language-javascript hljs">export const createGroceryList = (userName) =&gt; {
    const groceriesColRef = collection(db, 'groceryLists')
    return addDoc(groceriesColRef, {
            created: serverTimestamp(),
            users: [{ name: userName }]
        });
};
</pre>
<p>你可以在找到如何使用<code>setDoc</code> <a href="https://firebase.google.com/docs/firestore/manage-data/add-data#add_a_document" target="_blank" rel="noopener">的例子。</a></p>
<p>使用上面的代码，当创建一个杂货列表文档时，我存储了创建该列表的用户的名字和创建该列表时的时间戳。当用户将他们的第一个商品添加到列表中时，文档中会创建一个<code>items</code>子集合来保存杂货列表中的商品。</p>
<p>Firebase控制台的数据库屏幕很好地显示了Firestore中您的收藏和文档的结构。</p>
<p><img data-attachment-id="91075" data-permalink="https://blog.logrocket.com/how-to-use-react-hooks-firebase-firestore/items-sub-collection-document-firestore/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/03/Items-Sub-collection-Document-Firestore.png" data-orig-size="730,342" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Items-Sub-collection-Document-Firestore" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/03/Items-Sub-collection-Document-Firestore-300x141.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/03/Items-Sub-collection-Document-Firestore.png" decoding="async" class="size-full wp-image-91075 aligncenter jetpack-lazy-image" src="../Images/1ac26196a0bd2aa95f5a793d19526a0a.png" alt="Items Sub-collection Of A Document In Firestore" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2020/03/Items-Sub-collection-Document-Firestore.png 730w, https://blog.logrocket.com/wp-content/uploads/2020/03/Items-Sub-collection-Document-Firestore-300x141.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2020/03/Items-Sub-collection-Document-Firestore.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/03/Items-Sub-collection-Document-Firestore.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="91075" data-permalink="https://blog.logrocket.com/how-to-use-react-hooks-firebase-firestore/items-sub-collection-document-firestore/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/03/Items-Sub-collection-Document-Firestore.png" data-orig-size="730,342" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Items-Sub-collection-Document-Firestore" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/03/Items-Sub-collection-Document-Firestore-300x141.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/03/Items-Sub-collection-Document-Firestore.png" decoding="async" loading="lazy" class="size-full wp-image-91075 aligncenter" src="../Images/1ac26196a0bd2aa95f5a793d19526a0a.png" alt="Items Sub-collection Of A Document In Firestore" srcset="https://blog.logrocket.com/wp-content/uploads/2020/03/Items-Sub-collection-Document-Firestore.png 730w, https://blog.logrocket.com/wp-content/uploads/2020/03/Items-Sub-collection-Document-Firestore-300x141.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/03/Items-Sub-collection-Document-Firestore.png"/></noscript>
<p>接下来，让我们看看杂货清单数据是如何存储在React组件状态中的。</p>
<h2 id="managing-grocery-list-state">管理杂货清单状态</h2>
<p>反应组件可以有状态。在钩子出现之前，如果你想使用React状态API，你的React组件必须是类组件。现在您可以创建一个使用内置<code>useState</code>钩子的函数组件。</p>
<p>在杂货清单web应用程序中，您会在<code>App</code>组件中找到一个这样的例子:</p>
<pre class="language-javascript hljs">function App() {
  const [user, setUser] = useState()
  const [groceryList, setGroceryList] = useState();
</pre>
<p><code>App</code>组件是杂货清单web应用程序的React组件层次结构中的顶级组件。它保持当前用户和杂货列表的状态，并在必要时与子组件共享该状态的各个部分。</p>
<p>钩子很容易理解和使用。它接受一个可选参数，该参数定义当组件的实例被挂载(或者，换句话说，被初始化)时要使用的初始状态。</p>
<p>它返回一对值，为此我使用了<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment" target="_blank" rel="noopener">析构赋值</a>来创建两个局部变量。例如，<code>user</code>让组件访问当前的用户状态，这恰好是一个包含用户名的字符串。然后<code>setUser</code>变量是一个函数，用于用新的用户名更新用户状态。</p>
<p>好的，太棒了——<code>useState</code>钩子让我们向函数组件添加状态。让我们更深入一点，看看如何将Firestore中现有的杂货列表对象加载到<code>App</code>组件的状态中，作为副作用。</p>
<h2 id="loading-state-firestore-side-effect">装载状态从火风暴作为副作用</h2>
<p>当一个杂货列表的链接与另一个用户共享时，该链接的URL使用<code>listId</code>查询参数标识该杂货列表。稍后我们将看一下如何访问该查询参数，但首先我们想看看当安装了<code>App</code>组件时，如何使用它从Firestore加载一个现有的杂货列表。</p>
<p>从后端获取数据是组件副作用的一个很好的例子。这就是内置的<code>useEffect</code>钩子发挥作用的地方。<code>useEffect</code>钩子告诉React在浏览器中呈现一个组件后执行一些动作或“副作用”。</p>
<p>我希望首先加载<code>App</code>组件，从Firestore获取杂货清单数据，并且只在该数据可用时才显示它。这样，即使Firestore调用很慢，用户也能很快在浏览器中看到一些内容。这种方法对提高用户对应用程序在浏览器中加载速度的感知有很大帮助。</p>
<p>下面是<code>useEffect</code>钩子在<code>App</code>组件中的样子:</p>
<pre class="language-javascript hljs">  useEffect(() =&gt; {
    if (groceryListId) {
      FirestoreService.getGroceryList(groceryListId)
        .then(groceryList =&gt; {
          if (groceryList.exists) {
            setError(null);
            setGroceryList(groceryList.data());
          } else {
            setError('grocery-list-not-found');
            setGroceryListId();
          }
        })
        .catch(() =&gt; setError('grocery-list-get-fail'));
    }
  }, [groceryListId, setGroceryListId]);
</pre>
<p><code>useEffect</code>钩子接受两个参数。第一个函数不接受任何参数，它定义了副作用的实际作用。我使用来自<code>firestore.js</code>脚本的<code>getGroceryList</code>函数来包装对Firebase API的调用，以从Firestore中检索杂货列表对象。</p>
<p>Firebase API返回一个承诺，该承诺解析一个<code><a href="https://firebase.google.com/docs/reference/js/firebase.firestore.DocumentSnapshot" target="_blank" rel="noopener">DocumentSnapshot</a></code>对象，该对象可能包含也可能不包含杂货列表，这取决于是否找到了该列表。如果promise拒绝，我会在组件的状态中存储一个错误代码，最终会在屏幕上显示一条友好的错误消息。</p>
<p>第二个参数是依赖项数组。从第一个参数开始，函数中使用的任何属性或状态变量都需要作为依赖项列出。</p>
<p>我们刚刚看到的副作用是从Firestore加载一个文档的单个实例，但是如果我们希望在文档发生变化时将所有的变化传输到文档中，该怎么办呢？</p>
<h2 id="streaming-data-react-real-time-firestore-side-effect">副作用是从Firestore获得实时反应的流数据</h2>
<p>React类组件提供了对各种生命周期函数的访问，比如<code>componentDidMount</code>和<code>componentWillUnmount</code>。如果您想在组件安装后订阅从Firestore web API返回的数据流，并在组件卸载前取消订阅(清理),这些函数是必需的。</p>
<p>同样的功能在带有<code>useEffect</code>钩子的React函数组件中也是可能的，它可以选择返回一个模仿<code>componentWillUnmount</code>的清理函数。</p>
<p>让我们以<code>Itemlist</code>组件中的副作用为例:</p>
<pre class="language-javascript hljs">useEffect(() =&gt; {
        const unsubscribe = FirestoreService.streamGroceryListItems(groceryListId,
            (querySnapshot) =&gt; {
                const updatedGroceryItems = 
                querySnapshot.docs.map(docSnapshot =&gt; docSnapshot.data());
                setGroceryItems(updatedGroceryItems);
            },
            (error) =&gt; setError('grocery-list-item-get-fail')
        );
        return unsubscribe;
    }, [groceryListId, setGroceryItems]);
</pre>
<p>当Firestore上的数据发生变化时，<code>streamGrocerylistItems</code>函数用于将变化传输到杂货列表文档的<code>items</code>子集合。它接受两个回调并返回一个<code>unsubscribe</code>函数。</p>
<p>第一个回调将包含一个<code>querySnapshot</code>，这是一个在<code>items</code>子集合中监听的文档数组。每次<code>items</code>子集合中的文档发生变化时，它都会更新，第二个回调用于处理监听错误。</p>
<p>在卸载<code>ItemList</code>组件之前，<code>unsubscribe</code>函数可以从停止Firestore数据流的效果中返回。例如，当用户单击链接创建一个新的杂货列表时，我想在显示“创建杂货列表”场景之前停止该流。</p>
<p>让我们仔细看看<code>streamGrocerylistItems</code>函数:</p>
<pre class="language-javascript hljs">export const streamGroceryListItems = (groceryListId, snapshot, error) =&gt; {
    const itemsColRef = collection(db, 'groceryLists', groceryListId, 'items')
    const itemsQuery = query(itemsColRef, orderBy('created'))
    return onSnapshot(itemsQuery, snapshot, error);
};
</pre>
<p>这里实时处理数据流的函数是<code>onSnapshot</code>。它可以接收一个查询、集合或文档的文档引用，作为第一个参数。</p>
<p>在这种情况下，我传递的是<code>itemsQuery</code>，它引用了<code>items</code>子集合。我传递的其他参数是我们前面提到的回调，它返回一个用于停止流的取消订阅函数。你可以在这里了解更多关于实时流是如何工作的<a href="https://firebase.google.com/docs/firestore/query-data/listen#web-version-9_5" target="_blank" rel="noopener">。</a></p>
<p>接下来，让我们看看如何创建一个定制钩子来封装一些共享状态和逻辑。</p>
<h2 id="wrapping-query-string-handling-logic-custom-hook">将查询字符串处理逻辑包装到自定义挂钩中</h2>
<p>我们希望杂货清单应用程序使用清单ID查询参数，并对更改做出反应。这对于封装杂货清单ID状态并使其与查询参数的值保持同步的自定义挂钩来说是一个很好的机会。</p>
<p>以下是自定义挂钩:</p>
<pre class="language-javascript hljs">function useQueryString(key) {
    const [ paramValue, setParamValue ] = useState(getQueryParamValue(key));

    const onSetValue = useCallback(
        newValue =&gt; {
            setParamValue(newValue);
            updateQueryStringWithoutReload(newValue ? `${key}=${newValue}` : '');
        },
        [key, setParamValue]
    );

    function getQueryParamValue(key) {
        return new URLSearchParams(window.location.search).get(key);
    }

    function updateQueryStringWithoutReload(queryString) {
        const { protocol, host, pathname } = window.location;
        const newUrl = `${protocol}//${host}${pathname}?${queryString}`;
        window.history.pushState({ path: newUrl }, '', newUrl);
    }
    return [paramValue, onSetValue];
}
</pre>
<p>我将<code>useQueryString</code>设计成一个通用钩子，可以重用它将任何状态与任何查询参数链接在一起，并保持两者同步。钩子有两个内部函数，用于获取和设置查询字符串参数。</p>
<p><code>getQueryParamValue</code>函数接受参数名并检索其值。<code>updateQueryStringWithoutReload</code>使用<a href="https://developer.mozilla.org/en-US/docs/Web/API/History_API" target="_blank" rel="noopener">历史API </a>来更新参数值，而不会导致浏览器重新加载。这很重要，因为我们想要一个无缝的用户体验，在创建新的购物清单时，不需要重新加载整个页面。</p>
<p>我使用<code>useState</code>钩子在钩子的状态中存储购物清单ID。我从钩子返回这个状态，方式类似于内置的<code>useState</code>钩子的工作方式。然而，我没有返回标准的<code>setParamValue</code>函数，而是返回了<code>onSetValue</code>，它充当了一个拦截器，只在状态值改变时才调用。</p>
<p><code>onSetValue</code>函数本身是内置<code>useCallback</code>钩子的一个实例。<code>useCallback</code>钩子返回一个记忆化的函数，只有当它的一个依赖关系改变时才会被调用。一个<code>useCallback</code>钩子使用的任何属性或状态变量必须包含在创建钩子时传递的第二个参数中提供的依赖数组中。<br/>最终结果是一个定制的钩子，它最初根据查询参数设置自己的状态，并在状态改变时更新参数。</p>
<p><code>useQueryParameter</code>钩子是一个高度可重用的定制钩子。如果我想定义一种新的状态类型，并存储在URL查询字符串中，我可以在以后重用它。唯一需要注意的是，状态必须是一种可以与字符串相互转换的原始数据类型。</p>
<h2 id="recap-where-explore-next">回顾和下一步探索的领域</h2>
<p>我们已经探索了一些内置的React钩子，比如<code>useState</code>、<code>useEffect</code>和<code>useCallback</code>，但是还有其他的钩子可以在你构建应用程序的时候帮助你。<a href="https://reactjs.org/docs/hooks-reference.html" target="_blank" rel="noopener"> React文档</a>非常清晰地涵盖了所有内置钩子。</p>
<p>我们已经研究了一些Firebase web APIs，它们允许您从Firestore创建、检索和传输数据，但是您还可以使用该API做许多其他事情。尝试亲自探索Firestore SDK文档。</p>
<p>购物清单网络应用程序也有很多可以改进的地方。尝试从GitHub 下载<a href="https://github.com/Tammibriggs/firebase-with-react-hooks/tree/main" target="_blank" rel="noopener">源代码，自己运行。不要忘记，您将需要创建自己的Firebase项目并填充。env文件，然后运行应用程序。克隆或分叉回购，并从中获得乐趣！</a></p><div class="code-block code-block-17">
<div class="blog-plug inline-plug react-plug" vwo-el-id="26283398190">
<h2 vwo-el-id="41600691720">使用LogRocket消除传统反应错误报告的噪音</h2>
<a href="https://lp.logrocket.com/blg/react-signup-issue-free" target="_blank" vwo-el-id="19356441070">LogRocket
</a><p>是一款React analytics解决方案，可保护您免受数百个误报错误警报的影响，只针对少数真正重要的项目。LogRocket告诉您React应用程序中实际影响用户的最具影响力的bug和UX问题。</p><a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="19356441380">
<img class="first-react-image alignnone size-full wp-image-46 jetpack-lazy-image jetpack-lazy-image--handled" src="../Images/f300c244a1a1cf916df8b4cb02bec6c6.png" vwo-el-id="18272717540" data-lazy-loaded="1" data-original-src="https://files.readme.io/27c94e7-Image_2017-06-05_at_9.46.04_PM.png"/>
</a>
<a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="19356441690">
<img class="second-react-image alignnone size-full wp-image-46 jetpack-lazy-image jetpack-lazy-image--handled" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" vwo-el-id="30720362350" data-lazy-loaded="1" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/>
</a>
<a href="https://lp.logrocket.com/blg/react-signup-issue-free" target="_blank" rel="noopener noreferrer" vwo-el-id="35866400580">LogRocket
</a><p>自动聚合客户端错误、反应错误边界、还原状态、缓慢的组件加载时间、JS异常、前端性能指标和用户交互。然后，LogRocket使用机器学习来通知您影响大多数用户的最具影响力的问题，并提供您修复它所需的上下文。</p><p vwo-el-id="28675661060">关注重要的React bug—<a class="signup" href="https://lp.logrocket.com/blg/react-signup-issue-free" target="_blank" rel="noopener noreferrer" vwo-el-id="40093418840">今天就试试LogRocket】。</a></p>
</div></div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
# 为什么不应该在 Flutter 中使用全局变量

> 原文：<https://blog.logrocket.com/why-not-use-global-variables-flutter/>

全局变量可能看起来是很棒的程序组件，因为它们被声明一次，可以被程序中的每个函数访问。然而，这些变量的成本比您想象的要高，主要是因为:

1.  如果你删除了一个全局变量，你就必须搜索整个程序，重构每个可以访问被删除的全局变量的函数
2.  它们很难测试，因为你必须在测试用例之间重置它们
3.  很难跟踪变化，因为每个函数都可以修改全局变量

所有上述原因阐明了为什么全局变量永远不应该在颤振中使用。在本教程中，我们将详细了解全局变量的缺点，并学习如何以更有效的方式管理状态。

### 目录

## 颤振中的全局变量是什么？

全局变量是公共变量，可以被 Flutter 程序中的每个方法和对象访问。

全局变量是局部变量的替代，局部变量是在一个方法中创建的，并在该方法中被访问。

局部变量和全局变量的区别在于，局部变量不能被同一程序中的其他方法访问，因此，与全局变量相比，局部变量的作用域有限。

## 颤振中使用全局变量的缺点

在颤振中使用全局变量已经受到了质疑和批评，并且经常被认为是不好的做法。以下是使用全局变量带来的缺点:

### 复杂的代码维护过程

更改或删除一个全局变量会触发一系列事件，因为使用该全局变量的小部件和方法会受到影响。

如果您想要更改一个全局变量，您必须分析每个访问全局变量的小部件将会受到什么影响，并做出具体和必要的更改。

如果你删除了一个全局变量，你必须搜索整个程序并重构每个可以访问被删除的全局变量的函数。

### 全局变量让单元测试变得痛苦

如果您更改了一个具有全局变量的模块，那么您将不得不为接下来的测试重置它。

理解使用全局变量的遗留代码很难，理解程序流如何工作更难。很难有效地测试你不理解的代码，调试也很难，因为你不知道谁改变了全局变量。

### 全局变量导致意大利面代码

很难跟踪变化，因为程序中的每个函数都可以修改全局变量。如果您正在构建一个大型应用程序，那么在 Flutter 中使用全局变量的情况就会升级。即使您正在构建小型的颤振应用程序，全局变量也是导致灾难的一个因素。

### 全局变量反对封装

全局变量使得封装无法实现，封装是一个 OOP 概念，将代码包装到一个单元中。封装使得维护代码变得安全和容易。如果你想有效地使用封装，你必须禁止全局变量。

管理全局变量需要很多规则，因为它们会产生大量代码。然而，有一些开发人员会使用全局变量，因为他们在一个小团队中，在某些情况下不利于变化。

但是，无论应用程序的大小如何，当需要维护代码时，全局变量都会带来挑战。如果有必要使用全局变量，至少要使它们不可变。

在下一部分中，您将学习状态管理库和包，它们以一种更好的方式呈现了管理变量状态的更好方法，而不会损害维护过程。

## 如何以更好的方式管理状态

Flutter 是一个跨平台的动态框架，收集和处理来自用户的数据。

从开关到单选按钮，必须有效地管理数据状态。然而，全局变量增加了应用程序数据流的复杂性。全局变量使数据很容易变异，这可能会导致处理从用户那里收集的数据时出现混乱。

像`provider`这样的状态管理包可以用来缓解全局变量带来的问题。以下是可用于管理状态的状态包管理器和库的列表:

### 提供者状态管理包

[`provider`](https://pub.dev/packages/provider) 状态管理器包广泛用于收集小部件状态数据，并在状态改变时更新小部件。

当使用提供者时，在数据突变的情况下，只有受影响的小部件会被更新。与到处变化的全局变量相比，提供者降低了复杂性。提供者从小部件收集数据，并监听小部件周围发生的数据变化。

这个包将应用程序状态从 UI 中分离出来，`provider`促进了应用程序的维护和测试。

* * *

### 更多来自 LogRocket 的精彩文章:

* * *

使用下面的代码片段添加并使用`provider`包插件:

```
dependencies:
  flutter:
    sdk: flutter

  provider: ^3.1.0

```

`provider`包还允许您与多个类共享小部件状态:

```
void main() {
  runApp(
    MultiProvider(
      providers: [
        ChangeNotifierProvider(create: (context) => CartModel()),
        Provider(create: (context) => SomeOtherClass()),
      ],
      child: const MyApp(),
    ),
  );
}

```

### GetX

GetX 是一个轻量级的 Flutter 库，它支持视图、依赖注入、表示层和依赖注入的分离，从而提高了可伸缩性。

它提供了以下功能:

*   状态管理
*   依赖注入
*   航行
*   路线管理

如果您正在寻找一个节省资源且消耗最小的库，GetX 是您的最佳选择。

要在 Flutter 应用程序 start 中开始使用 GetX，请将`get`添加到 pubspec.yaml 文件中:

```
dependencies:
  get:

```

接下来，导入使用 GetX 库函数和组件时需要的`get`文件:

```
import 'package:get/get.dart';

```

### Riverpod

[Riverpod](https://github.com/rrousselGit/riverpod) 项目类似于`provider`包——唯一的区别是它以单向方式分发数据。

这个状态管理器确保你的代码是可测试的和易读的，因为它移除了组合对象的嵌套。其特殊之处在于，它可以在编译过程中检测错误。这将节省您的时间，因为您将在错误在运行时添加到您的应用程序之前修复它们。

### Redux

[Redux](https://pub.dev/packages/redux#:~:text=Redux%20is%20a%20predictable%20state,Flutter%20using%20the%20flutter_redux%20package.) 是一个帮助你有效管理小部件数据状态的库。Redux 是一种架构，它以单向的方式在小部件之间分发状态数据。这个库很棒，因为它消除了状态重复，并且您可以测试状态结果是否为真。

### `SetState`法

之前，我们只讨论了管理状态的 Flutter 包和库。

有一个叫做`setState`的方法，当你的小部件改变数据值时可以调用这个方法。这将导致用户界面根据新的状态而改变。您可以添加在状态改变时执行某些操作的代码。下面是颤振中`setState`的一个基本实现:

```
class _MyHomePageState extends State<MyHomePage> {
  int _counter = 0;

  void _incrementCounter() {
    _counter++;
    setState(() {});
  }

```

## 结论

在本教程中，我们已经详细了解了什么是全局变量，以及为什么我们永远不应该在 Flutter 中使用它们。此外，我们还探索了各种状态管理库，您可以使用它们来更有效地管理状态。

## 使用 [LogRocket](https://lp.logrocket.com/blg/signup) 消除传统错误报告的干扰

[![LogRocket Dashboard Free Trial Banner](img/d6f5a5dd739296c1dd7aab3d5e77eeb9.png)](https://lp.logrocket.com/blg/signup)

[LogRocket](https://lp.logrocket.com/blg/signup) 是一个数字体验分析解决方案，它可以保护您免受数百个假阳性错误警报的影响，只针对几个真正重要的项目。LogRocket 会告诉您应用程序中实际影响用户的最具影响力的 bug 和 UX 问题。

然后，使用具有深层技术遥测的会话重放来确切地查看用户看到了什么以及是什么导致了问题，就像你在他们身后看一样。

LogRocket 自动聚合客户端错误、JS 异常、前端性能指标和用户交互。然后 LogRocket 使用机器学习来告诉你哪些问题正在影响大多数用户，并提供你需要修复它的上下文。

关注重要的 bug—[今天就试试 LogRocket】。](https://lp.logrocket.com/blg/signup-issue-free)
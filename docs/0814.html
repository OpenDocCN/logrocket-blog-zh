<html>
<head>
<title>An SEO approach to async components with loadable-components - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>一种用可加载组件实现异步组件的SEO方法</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/seo-approach-async-loadable-components/#0001-01-01">https://blog.logrocket.com/seo-approach-async-loadable-components/#0001-01-01</a></blockquote><div><article class="article-post">
<p>您曾经在异步加载组件时查看过网页的页面源代码吗？如果有，您可能已经注意到实际内容没有被呈现。</p>
<p>这是因为组件是在客户端异步加载的，这对SEO不利，因为爬虫在索引站点时无法获得实际内容。</p>
<p>本文将提供一种方法，通过使用<a href="https://github.com/gregberge/loadable-components"> loadable-components </a>异步加载组件，您可以获得两个世界的最佳效果。</p>
<p>在本文中，我们将使用现有的Gatsby项目。该项目已经使用了可加载组件，我们将看到如何更好地实现它的搜索引擎优化的目的。</p>
<h2>问题陈述</h2>
<p>我们有一个Gatsby站点，它使用来自内容管理系统Contentful的动态数据来呈现信息和模块。Gatsby站点是一个显示Contentful所有帖子的博客。这些帖子是在富文本编辑器中编写的，我们在代码库中使用富文本呈现器来解析富文本以反应组件。</p>
<p>然而，我们也希望能够在网站上显示除博客帖子之外的其他内容。为此，我们在Contentful: custom blocks中创建了一个新的内容类型。顾名思义，自定义块允许我们在网站上呈现自定义块(不一定是博客文章的内容)。</p>
<p>这就是挑战所在。与总是以文章格式呈现的博客帖子相反，定制块可能需要根据设计由不同的多个React组件呈现。例如，Contentful上有一个价格信息定制块的React组件，Contentful上有一个FAQ定制块的React组件，等等。</p>
<p>因此，为了实现这一点，下面有一个文件使用定制块的名称来呈现它自己的组件——也就是说，如果定制块的名称与<code>CUSTOM_BLOCKS</code>中的任何键匹配，那么相应的组件将被呈现。</p>
<pre>// blocks.js
import TestPage from './TestPage'
import PricingInfo from './PricingInfo'
import FAQInfo from './FAQInfo'

const CUSTOM_BLOCKS = {
  TestPage: TestPage,
  PricingInfo: PricingInfo,
  FAQInfo: FAQInfo,
}
export default CUSTOM_BLOCKS</pre>
<p>然后，可以在如下所示的代码片段中使用定制块，其中只有当与<code>customBlock.name</code>匹配时，才会返回<code>CustomBlockComponent</code>。</p>
<pre>// CustomBlock.js
import CUSTOM_BLOCKS from './blocks'

const CustomBlock = ({ customBlock }) =&gt; {
  const CustomBlockComponent = CUSTOM_BLOCKS[customBlock.name]
  if (!CustomBlockComponent) {
    return null
  }
  return &lt;CustomBlockComponent customBlock={customBlock} /&gt;
}

export default CustomBlock</pre>
<p>对于当前的实现，我们一次加载所有的定制块及其组件，即使我们并不需要它们。现在，它只是两个自定义块，但想象一下，如果它比这多得多。</p>
<h2>使用可加载组件</h2>
<p>这种情况正是<code>loadable/component</code>的用武之地。它允许我们只在需要的时候加载组件，即异步加载。让我们将<code>loadable/component</code>添加到上面分享的第一段代码中。</p>
<pre>// blocks.js
import loadable from '@loadable/component'

const CUSTOM_BLOCKS = {
  TestPage: loadable(() =&gt; import('./TestPage')),
  PricingInfo: loadable(() =&gt; import('./PricingInfo')),
  FAQInfo: loadable(() =&gt; import('./FAQInfo')),
}
export default CUSTOM_BLOCKS</pre>
<p>所有的定制块都是异步加载的，所以它们只在需要的时候才被加载，这反过来会导致代码的性能得到优化。</p>
<p>这就是为什么我们选择在我们的项目中使用可加载组件的原因，它似乎解决了我们最初遇到的问题。但是，使用loadable导入组件意味着自定义块的内容不会预呈现到静态HTML中。</p>
<p>举个例子，在下面的页面源代码中，我期望<code>Date One</code>文本出现在源代码中，但是没有。<code>Date One</code>文本在上面的一个定制块文件中，它需要一些JavaScript来评估，因此，它没有显示出来。</p>
<p><img data-attachment-id="17555" data-permalink="https://blog.logrocket.com/seo-approach-async-loadable-components/attachment/page-source-missing-components/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/04/page-source-missing-components.png" data-orig-size="730,446" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Page source missing async components" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/04/page-source-missing-components-300x183.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/04/page-source-missing-components.png" decoding="async" class="aligncenter size-full wp-image-17555 jetpack-lazy-image" src="../Images/fb4afca73ee8d96d726ce18fc2d72154.png" alt="Page Source Missing Async Components" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2020/04/page-source-missing-components.png 730w, https://blog.logrocket.com/wp-content/uploads/2020/04/page-source-missing-components-300x183.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2020/04/page-source-missing-components.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/04/page-source-missing-components.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="17555" data-permalink="https://blog.logrocket.com/seo-approach-async-loadable-components/attachment/page-source-missing-components/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/04/page-source-missing-components.png" data-orig-size="730,446" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Page source missing async components" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/04/page-source-missing-components-300x183.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/04/page-source-missing-components.png" decoding="async" loading="lazy" class="aligncenter size-full wp-image-17555" src="../Images/fb4afca73ee8d96d726ce18fc2d72154.png" alt="Page Source Missing Async Components" srcset="https://blog.logrocket.com/wp-content/uploads/2020/04/page-source-missing-components.png 730w, https://blog.logrocket.com/wp-content/uploads/2020/04/page-source-missing-components-300x183.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/04/page-source-missing-components.png"/></noscript>
<p>这就是我们在本文中试图解决的问题:如何异步加载组件，并确保内容在静态HTML中呈现。</p>
<h2>配置可加载组件</h2>
<p>我们可以通过对如何设置<code>loadable/component</code>做一些额外的配置来解决这个问题。我们已经在代码库中安装了<code>loadable/component</code>，但是我们需要做一些配置。首先，安装下面的依赖项。</p>
<pre>yarn add -D @loadable/babel-plugin @loadable/webpack-plugin babel-preset-gatsby</pre>
<p>接下来的事情是添加一个定制的Babel插件到项目中。为此，我们需要修改<code>.babelrc.js</code>文件。在插件数组中，添加下面一行:</p>
<pre>// .babelrc.js
{
  "plugins": [
    ...
    "@loadable/babel-plugin",
    ...
  ]
}</pre>
<p>接下来，我们将在<code>gatsby-node.js</code>文件中添加一个定制的webpack插件。</p>
<pre>// gatsby-node.js
const LoadablePlugin = require('@loadable/webpack-plugin')

exports.onCreateWebpackConfig = ({ stage, actions }) =&gt; {
  actions.setWebpackConfig({
    plugins: [new LoadablePlugin()],
  })
}
exports.onCreateBabelConfig = ({ actions }) =&gt; {
  actions.setBabelPlugin({
    name: `@loadable/babel-plugin`,
  })
}</pre>
<p>所有这一切的最后一步是确保定制块的内容用静态HTML预先呈现。一种方法是使用<code>loadable/components</code>的<code>fallback</code>道具。</p>
<h2>在静态HTML中预先呈现自定义块元素</h2>
<p>属性决定了当组件被异步加载时要显示什么。这将用于确保异步组件被呈现到静态HTML中。怎么会？</p>
<p>因此，对于异步组件，会发生以下情况:</p>
<ol>
<li>呈现静态HTML</li>
<li>React组件被合并到静态HTML中</li>
<li>因为异步组件需要时间来解析，所以当前的DOM被销毁，只有在完成加载后才会重新创建</li>
</ol>
<p>然后，我们可以利用第二步来获取并保存当前的静态HTML，然后使用它作为后备。这正是下面的代码片段所做的。如果您还记得上面的话，<code>CustomBlock.js</code>文件只是检查一个定制块组件是否存在，然后返回它。</p>
<p>现在它做的远不止这些:</p>
<ul>
<li>将<code>id</code>设置为<code>CustomBlock__</code>，加上当前的自定义块名称</li>
<li>添加一个回退属性，设置为从<code>getRenderedContent()</code>函数获取的HTML</li>
<li>最后，<code>getRenderedContent</code>函数检查HTML中是否存在带有ID的元素，如果是，则返回它<pre>// CustomBlock.js import * as React from 'react'  import CUSTOM_BLOCKS from './blocks'&lt;/p&gt;  &lt;p&gt;const getRenderedContent = customBlockName =&gt; {   if (typeof window === 'undefined') return ''   const element = window.document.querySelector(     &lt;code&gt;#CustomBlock__${customBlockName}&lt;/code&gt;   )   return element ? element.innerHTML : '' } const CustomBlock = ({ customBlock }) =&gt; {   const CustomBlockComponent = CUSTOM_BLOCKS[customBlock.name]   if (!CustomBlockComponent) {     return null   }   return (     &lt;section id={&lt;code&gt;CustomBlock__${customBlock.name}&lt;/code&gt;}&gt;       &lt;CustomBlockComponent         customBlock={customBlock}         fallback={           &lt;div             dangerouslySetInnerHTML={{               __html: getRenderedContent(customBlock.name),             }}           /&gt;         }       /&gt;     &lt;/section&gt;   ) } export default CustomBlock</pre></li>
</ul>
<p>这有点像黑客，但是我们可以看到页面源代码中异步组件的内容，这对SEO很有好处。</p>
<p>现在，我们可以使用以下命令构建站点并在生产中运行它:</p>
<pre>yarn build &amp;&amp; serve public</pre>
<p>日期现在出现在页面源中，这意味着定制块元素现在被预先呈现，这反过来意味着爬网程序可以成功地对该页面进行爬网。</p>
<p><img data-attachment-id="17556" data-permalink="https://blog.logrocket.com/seo-approach-async-loadable-components/attachment/page-source-components/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/04/page-source-components.png" data-orig-size="730,447" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Page source with async components" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/04/page-source-components-300x184.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/04/page-source-components.png" decoding="async" class="aligncenter size-full wp-image-17556 jetpack-lazy-image" src="../Images/b4f05d80467d8543f26b93d4144a5e88.png" alt="Page Source With Async Components" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2020/04/page-source-components.png 730w, https://blog.logrocket.com/wp-content/uploads/2020/04/page-source-components-300x184.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2020/04/page-source-components.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/04/page-source-components.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="17556" data-permalink="https://blog.logrocket.com/seo-approach-async-loadable-components/attachment/page-source-components/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/04/page-source-components.png" data-orig-size="730,447" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Page source with async components" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/04/page-source-components-300x184.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/04/page-source-components.png" decoding="async" loading="lazy" class="aligncenter size-full wp-image-17556" src="../Images/b4f05d80467d8543f26b93d4144a5e88.png" alt="Page Source With Async Components" srcset="https://blog.logrocket.com/wp-content/uploads/2020/04/page-source-components.png 730w, https://blog.logrocket.com/wp-content/uploads/2020/04/page-source-components-300x184.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/04/page-source-components.png"/></noscript>
<h2>结论</h2>
<p>为了模拟我在本文中解释的内容，有一个包含上述Gatsby项目代码库的<a href="https://github.com/yomete/loadable-components-seo"> GitHub </a>存储库。它还包含一个导出的内容丰富的空间，因此您可以设置它(通过导入到一个新的空间)并连接到Gatsby项目。</p><div class="code-block code-block-17">
<div class="blog-plug inline-plug react-plug" vwo-el-id="26283398190">
<h2 vwo-el-id="41600691720"><a href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener"> LogRocket </a>:全面了解您的生产React应用</h2><p>调试React应用程序可能很困难，尤其是当用户遇到难以重现的问题时。如果您对监视和跟踪Redux状态、自动显示JavaScript错误以及跟踪缓慢的网络请求和组件加载时间感兴趣，</p><a href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" vwo-el-id="19356441070">try LogRocket</a><p>. </p><a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="19356441380">
<img class="first-react-image alignnone size-full wp-image-46 jetpack-lazy-image jetpack-lazy-image--handled" src="../Images/f300c244a1a1cf916df8b4cb02bec6c6.png" vwo-el-id="18272717540" data-lazy-loaded="1" data-original-src="https://files.readme.io/27c94e7-Image_2017-06-05_at_9.46.04_PM.png"/>
</a>
<a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="19356441690">
<img class="second-react-image alignnone size-full wp-image-46 jetpack-lazy-image jetpack-lazy-image--handled" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" vwo-el-id="30720362350" data-lazy-loaded="1" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/>
</a>
<p vwo-el-id="28675660440" class="">LogRocket 结合了会话回放、产品分析和错误跟踪，使软件团队能够创建理想的web和移动产品体验。这对你来说意味着什么？</p>
<p>LogRocket不是猜测错误发生的原因，也不是要求用户提供截图和日志转储，而是让您回放问题，就像它们发生在您自己的浏览器中一样，以快速了解哪里出错了。</p>
<p>不再有嘈杂的警报。智能错误跟踪允许您对问题进行分类，然后从中学习。获得有影响的用户问题的通知，而不是误报。警报越少，有用的信号越多。</p>
<p vwo-el-id="28675660750">LogRocket Redux中间件包为您的用户会话增加了一层额外的可见性。LogRocket记录Redux存储中的所有操作和状态。</p>
<p vwo-el-id="28675661060">现代化您调试React应用的方式— <a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="40093418840">开始免费监控</a>。</p>
</div></div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>
 
</div>    
</body>
</html>
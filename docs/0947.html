<html>
<head>
<title>Strapi API creation: A quick guide - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>Strapi API创建:快速指南- LogRocket博客</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/strapi-api-creation-quick-guide/#0001-01-01">https://blog.logrocket.com/strapi-api-creation-quick-guide/#0001-01-01</a></blockquote><div><article class="article-post">
<p><em>编者按:这篇文章于2021年10月更新，以提高清晰度并删除过时的信息。</em></p>
<p>内容管理系统(CMSs)已经存在很长时间了。Strapi是Node.js的一个headless CMS，它提供了一个GUI来创建不同的内容类型，并将用户管理集成到平台中。它支持RESTful APIs和GraphQL。</p>
<p>此外，Strapi支持NoSQL和SQL数据库。更改数据库就像更改环境变量一样简单。</p>
<p>在本指南中，我们将介绍使用Strapi创建API的以下步骤:</p>

<h2 id="setting-up-work-environment">设置工作环境</h2>
<p>Strapi要求在您的系统上安装Node.js。它提供了一个样板文件生成器<code>create-strapi-app</code>，用于设置应用程序。可以使用npm通过以下命令进行全局安装。</p>
<pre>$ npm i -g create-strapi-app
</pre>
<p>使用<code>create-strapi-app</code>很简单；只需传递项目的名称。<code>--quickstart</code>将用默认设置创建一个项目。</p>
<pre>create-strapi-app my-blog --quickstart
</pre>
<p>在使用Strapi之前，您必须创建一个管理员用户。命令<code>npm run develop</code>在<code><a href="http://localhost:1337" rel="nofollow">http://localhost:1337</a></code>上启动服务器。管理员用户是使用<code><a href="http://localhost:1337/admin/auth/register" rel="nofollow">http://localhost:1337/admin/auth/register</a></code>创建的。</p>
<p><img decoding="async" class="aligncenter jetpack-lazy-image" src="../Images/86d67f40483c26a2bc12511d0a78cd7e.png" alt="Create the admin user" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2020/06/create-admin-user-e1592428017191.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/06/create-admin-user-e1592428017191.png"/></p><noscript><img data-lazy-fallback="1" decoding="async" loading="lazy" class="aligncenter" src="../Images/86d67f40483c26a2bc12511d0a78cd7e.png" alt="Create the admin user" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/06/create-admin-user-e1592428017191.png"/></noscript>
<p>一旦样板文件准备就绪，就可以使用admin UI来构建API的数据库模式。</p>
<h2 id="creating-your-strapi-database-schema">创建您的Strapi数据库模式</h2>
<p>Strapi为创建数据库模式提供了一个简单的UI。如果我们想改变我们的配置，我们必须编辑出我们的项目文件。例如，为了改变<code>env</code>变量，我们必须编辑<code>config/environments</code>文件夹。</p>
<p>Strapi包括一个内容构建器插件，它为创建数据库模式提供了一个很好的UI。该插件独立于数据库，相同的模式可以在SQL和NoSQL数据库中使用。</p>
<p>我们的演示网站将有一个博客收集类型和评论收集类型。博客将存储大部分内容，评论集合将存储用户信息和博客上的评论。</p>
<h3>创建收藏</h3>
<p>从在<code><a href="http://localhost:1337/admin" rel="nofollow">http://localhost:1337/admin</a></code>登录管理员开始。打开侧边栏上的<strong>内容类型构建器</strong>页面。</p>
<p><img decoding="async" class="aligncenter jetpack-lazy-image" src="../Images/5ae5126f2a79a139aebd65dd0f5db358.png" alt="Open the Content Types Builder page" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2020/06/content-types-builder-page.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/06/content-types-builder-page.png"/></p><noscript><img data-lazy-fallback="1" decoding="async" loading="lazy" class="aligncenter" src="../Images/5ae5126f2a79a139aebd65dd0f5db358.png" alt="Open the Content Types Builder page" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/06/content-types-builder-page.png"/></noscript>
<p>现在创建一个名为“Blog”的新集合来存储站点的博客。它将包含标题、图像和内容。</p>
<p><img decoding="async" class="aligncenter jetpack-lazy-image" src="../Images/906cd840bc03d0f9be021536696062d8.png" alt="Create the Blog collection" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2020/06/blog-collection.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/06/blog-collection.png"/></p><noscript><img data-lazy-fallback="1" decoding="async" loading="lazy" class="aligncenter" src="../Images/906cd840bc03d0f9be021536696062d8.png" alt="Create the Blog collection" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/06/blog-collection.png"/></noscript>
<p>接下来，创建一个名为“Comment”的集合。这将存储博客的评论，并包括内容、用户和博客文章的字段。<code>blog</code>字段存储相应博客文章的链接和创建给定评论的用户的详细信息。</p>
<p><img decoding="async" class="aligncenter jetpack-lazy-image" src="../Images/37e45197190ee67f1b79ae8a2ff05881.png" alt="Create the comment collection within the blog field" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2020/06/comment-collection-blog-field.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/06/comment-collection-blog-field.png"/></p><noscript><img data-lazy-fallback="1" decoding="async" loading="lazy" class="aligncenter" src="../Images/37e45197190ee67f1b79ae8a2ff05881.png" alt="Create the comment collection within the blog field" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/06/comment-collection-blog-field.png"/></noscript>
<p><img decoding="async" class="aligncenter jetpack-lazy-image" src="../Images/47ff7cf4232179c926906bfe92da54a7.png" alt="Create the comment collection user field" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2020/06/comment-collection-user-field.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/06/comment-collection-user-field.png"/></p><noscript><img data-lazy-fallback="1" decoding="async" loading="lazy" class="aligncenter" src="../Images/47ff7cf4232179c926906bfe92da54a7.png" alt="Create the comment collection user field" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/06/comment-collection-user-field.png"/></noscript>
<p>我们已经为评论创建了链接:一个链接到用户集合，另一个链接到博客集合。博客和用户集合没有关于链接的信息。现在我们的后端都设置好了。</p>
<h3>文档插件</h3>
<p>我们将从Marketplace部分安装文档插件，以便于访问API细节。这个插件将为API创建swagger规范。</p>
<p><img decoding="async" class="aligncenter jetpack-lazy-image" src="../Images/436ed9e7d28b4934187158e922f4f36c.png" alt="The Strapi plugins marketplace" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2020/06/plugins-marketplace.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/06/plugins-marketplace.png"/></p><noscript><img data-lazy-fallback="1" decoding="async" loading="lazy" class="aligncenter" src="../Images/436ed9e7d28b4934187158e922f4f36c.png" alt="The Strapi plugins marketplace" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/06/plugins-marketplace.png"/></noscript>
<h2 id="setting-up-strapi-jwt-based-authentication">设置Strapi基于JWT的身份验证</h2>
<p>身份验证是任何应用程序的重要元素。Strapi有现成的基于JWT的身份验证。</p>
<p>默认密钥用于签署JWT。可以在配置文件<code>/extensions/users-permissions/config/jwt.json</code>中更改签名密钥。用户注册和登录的API已经嵌入到平台中。</p>
<pre class="language-javascript hljs">{
  "jwtSecret": "f1b4e23e-480b-4e58-923e-b759a593c2e0"
}
</pre>
<p>我们将使用<code>local</code>提供者进行认证。该密码和电子邮件/用户名用于验证用户。如果我们点击侧边栏上的“Documentation ”,它会提供一个选项来查看swagger API文档。</p>
<p><img decoding="async" class="aligncenter jetpack-lazy-image" src="../Images/60a321120a9fdd8a4d15503f9d8d2eee.png" alt="API documentation" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2020/06/api-documentation.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/06/api-documentation.png"/></p><noscript><img data-lazy-fallback="1" decoding="async" loading="lazy" class="aligncenter" src="../Images/60a321120a9fdd8a4d15503f9d8d2eee.png" alt="API documentation" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/06/api-documentation.png"/></noscript>
<p>点击<strong>打开文档</strong>查看swagger API文档。导航至<strong>用户权限–用户</strong>访问API以创建用户和登录用户。</p>
<p><img decoding="async" class="aligncenter jetpack-lazy-image" src="../Images/e5e297abc6b75cd0a4fb0f7cf20c3df8.png" alt="Create a user and user login in the UsersPermissions - User section" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2020/06/userpermissions-user.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/06/userpermissions-user.png"/></p><noscript><img data-lazy-fallback="1" decoding="async" loading="lazy" class="aligncenter" src="../Images/e5e297abc6b75cd0a4fb0f7cf20c3df8.png" alt="Create a user and user login in the UsersPermissions - User section" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/06/userpermissions-user.png"/></noscript>
<p>我们将使用<code>/auth/local</code>和<code>/auth/local/register</code>。</p>
<h3>身份验证角色和权限</h3>
<p>默认情况下，Strapi有两个角色用于控制对内容的访问:public和authenticated。public角色是针对未经身份验证的用户的，而authenticated角色是针对—您猜对了—经过身份验证的用户的。</p>
<p>这些角色会根据用户的身份验证状态自动分配给用户。“公共”用户可以阅读博客和评论，“认证”用户可以在博客上发表评论和编辑评论。可以在<strong>角色和权限</strong>部分编辑角色。</p>
<p><img decoding="async" class="aligncenter jetpack-lazy-image" src="../Images/336734e708b7efa99a1b8236bfbc27b5.png" alt="Roles and Permissions" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2020/06/roles-and-permissions.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/06/roles-and-permissions.png"/></p><noscript><img data-lazy-fallback="1" decoding="async" loading="lazy" class="aligncenter" src="../Images/336734e708b7efa99a1b8236bfbc27b5.png" alt="Roles and Permissions" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/06/roles-and-permissions.png"/></noscript>
<p>在此屏幕上，您可以编辑公共角色以允许访问博客和评论。</p>
<p><img decoding="async" class="aligncenter jetpack-lazy-image" src="../Images/cd026d08779aaa9475cc60dd4bedd07a.png" alt="Public Roles Blogs and Comments" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2020/06/public-roles-blogs-and-comments.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/06/public-roles-blogs-and-comments.png"/></p><noscript><img data-lazy-fallback="1" decoding="async" loading="lazy" class="aligncenter" src="../Images/cd026d08779aaa9475cc60dd4bedd07a.png" alt="Public Roles Blogs and Comments" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/06/public-roles-blogs-and-comments.png"/></noscript>

<p>现在让我们给我们的演示网站添加评论。要添加评论，用户必须经过身份验证。<br/>我们需要通过为<code>Comment</code>集合定制控制器来控制对<code>comment collection</code>的写访问。每个集合的控制器都位于<code>api</code>文件夹中。要更改控制器，请编辑<code>api/comment/controllers/comment.js</code>。</p>
<p>我们需要安装<code>strapi-utils</code>来编辑我们的控制器。</p>
<pre>npm i strapi-utils


// file: api/comment/controllers/comment.js

const { sanitizeEntity } = require('strapi-utils');

module.exports = {
    // this method is called when api to create comment is called
    async create(ctx) {
        // add user from the request and add it to the body of request
        ctx.request.body.user = ctx.state.user.id;
        // call the function to creating comment with data
        let entity = await strapi.services.comment.create(ctx.request.body);
        // return data for api after removing field which are not exported
        return sanitizeEntity(entity, { model: strapi.models.comment });
    },
    async update(ctx) {
        // get the id of comment which is updated
        const { id } = ctx.params;
        // finding the comment for user and id
        const [comment] = await strapi.services.comment.find({
            id: ctx.params.id,
            'user.id': ctx.state.user.id,
        });
        // comment does not exist send error
        if (!comment) {
            return ctx.unauthorized(`You can't update this entry`);
        }
        // update the comment
        let entity = await strapi.services.comment.update({ id }, ctx.request.body);
         // return data for api after removing field which are not exported
        return sanitizeEntity(entity, { model: strapi.models.comment });
    },
    async delete(ctx) {
        // get the id of comment which is updated
        const { id } = ctx.params;
        // finding the comment for user and id
        const [comment] = await strapi.services.comment.find({
            id: ctx.params.id,
            'user.id': ctx.state.user.id,
        });
        // comment does not exist send error
        if (!comment) {
            return ctx.unauthorized(`You can't update this entry`);
        }
        // delete the comment
        let entity = await strapi.services.comment.delete({ id });
         // return data for api after removing field which are not exported
        return sanitizeEntity(entity, { model: strapi.models.comment });
    },
};
</pre>
<p>这里，我们只是在Strapi提供的函数上添加了一个额外的层，这样我们就可以将用户数据添加到请求体中。斯特拉皮处理其余的。</p>
<p>现在我们需要更改已经过认证的用户角色，这样用户就可以创建、编辑和删除评论。</p>
<p><img decoding="async" class="aligncenter jetpack-lazy-image" src="../Images/0305a8b6a710d1919681ebcab91ff250.png" alt="Authenticated User Role" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2020/06/authenticated-user-role.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/06/authenticated-user-role.png"/></p><noscript><img data-lazy-fallback="1" decoding="async" loading="lazy" class="aligncenter" src="../Images/0305a8b6a710d1919681ebcab91ff250.png" alt="Authenticated User Role" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/06/authenticated-user-role.png"/></noscript>
<h2 id="implementing-our-gatsby-frontend">实现我们的Gatsby前端</h2>
<p>对于前端，我们将使用<a href="https://blog.logrocket.com/is-gatsby-really-that-great-e7b19c4c1c05/" target="_blank" rel="noopener">盖茨比</a>。使用<code>gatsby new frontend</code>创建一个新的Gatsby项目。我们项目的文件结构如下。</p>
<pre>src/
├── components
│   ├── card.js
│   └── dialog.js
├── images
└── pages
    ├── 404.js
    ├── blog.js
    └── index.js
</pre>
<h3>前端组件</h3>
<p>让我们看看我们将在前端使用的组件。</p>
<ul>
<li>包含一个简单的卡片组件，显示作为道具提供给它的信息</li>
<li><code>dialog.js</code>包含一个登录和注册的对话框</li>
<li><code>blog.js</code>用于显示博客和评论</li>
<li>是主页，显示博客列表</li>
<li><code>404.js</code>未找到URL时显示错误</li>
</ul>
<h3>设计主页</h3>
<p><img decoding="async" class="aligncenter jetpack-lazy-image" src="../Images/2c102c2c3e45c2828b64851cb91370cf.png" alt="Blogs Homepage" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2020/06/blogs-homepage.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/06/blogs-homepage.png"/></p><noscript><img data-lazy-fallback="1" decoding="async" loading="lazy" class="aligncenter" src="../Images/2c102c2c3e45c2828b64851cb91370cf.png" alt="Blogs Homepage" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/06/blogs-homepage.png"/></noscript>
<p>向API <code>/blogs</code>发出GET请求，获取所有的博客文章。这映射到一个博客文章列表，并为每个博客文章显示一个卡片组件。它还包含显示登录/注册对话框的代码。</p>
<p>当用户点击一张卡片时，它会将他们导航到<code>/blog</code>页面。</p>
<pre class="language-javascript hljs">import React, { useState } from 'react';
import { makeStyles } from '@material-ui/core/styles';
import Grid from '@material-ui/core/Grid';
import Typography from '@material-ui/core/Typography';
import Card from "../components/card";
import Dialog from "../components/dialog"
import { Button } from '@material-ui/core';
const useStyles = makeStyles((theme) =&gt; ({
  root: {
    flexGrow: 1,
    textAlign: "center"
  },
  paper: {
    height: 500,
    width: 400,
  },
  control: {
    padding: theme.spacing(2),
  },
}));
export default function () {
  const classes = useStyles();
  const [blogs, setBlogs] = useState([])
  const [open, setOpen] = useState(false)
  const [login, setLogin] = useState(false)
  // fetch all blogs
  React.useEffect(() =&gt; {
    fetch("http://localhost:1337/blogs").then(res =&gt; res.json()).then(val =&gt; setBlogs(val))
  }, [])
  return (
    &lt;&gt;
    {/*dialog for authentication */}
      &lt;Dialog open={open} setOpen={setOpen} login={login} /&gt;
      &lt;Grid container className={classes.root} spacing={2}&gt;
        &lt;Grid item xs={12}&gt;
          &lt;Grid container justify="center"&gt;
            &lt;Grid item xs={10}&gt;
              &lt;Typography variant="h3" component="h2" gutterBottom gutterLeft&gt;Blogs&lt;/Typography&gt;
            &lt;/Grid&gt;
            {/*check if token is present or not */}
            {
              !localStorage.getItem("token") ? [&lt;Grid item xs={1}&gt;
                &lt;Button onClick={() =&gt; { setOpen(true); setLogin(true) }}&gt;Login&lt;/Button&gt;
              &lt;/Grid&gt;,
              &lt;Grid item xs={1}&gt;
                &lt;Button onClick={() =&gt; { setOpen(true); setLogin(false) }}&gt; Register&lt;/Button&gt;
              &lt;/Grid&gt;] : ""
            }
          &lt;/Grid&gt;
        &lt;/Grid&gt;
        &lt;Grid item xs={12}&gt;
          &lt;Grid container justify="center" spacing={10}&gt;
            {/*map through list of blog and create list of cards */}
            {blogs.map((value) =&gt; (
              &lt;Grid key={value} item&gt;
                &lt;Card value={value} /&gt;
              &lt;/Grid&gt;
            ))}
          &lt;/Grid&gt;
        &lt;/Grid&gt;
      &lt;/Grid&gt;
    &lt;/&gt;
  );
}
</pre>
<h3>设计我们的卡组件</h3>
<p><img decoding="async" class="aligncenter jetpack-lazy-image" src="../Images/164b950b9b5ebade1147bd7cf2df1041.png" alt="Card Component" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2020/06/card-component-e1592428315981.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/06/card-component-e1592428315981.png"/></p><noscript><img data-lazy-fallback="1" decoding="async" loading="lazy" class="aligncenter" src="../Images/164b950b9b5ebade1147bd7cf2df1041.png" alt="Card Component" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/06/card-component-e1592428315981.png"/></noscript>
<pre class="language-javascript hljs">import React from 'react';
import { makeStyles } from '@material-ui/core/styles';
import Card from '@material-ui/core/Card';
import CardHeader from '@material-ui/core/CardHeader';
import CardMedia from '@material-ui/core/CardMedia';
import CardContent from '@material-ui/core/CardContent';
import CardActions from '@material-ui/core/CardActions';
import Collapse from '@material-ui/core/Collapse';
import Typography from '@material-ui/core/Typography';
import { red } from '@material-ui/core/colors';
import { Link } from 'gatsby';
const useStyles = makeStyles((theme) =&gt; ({
  root: {
    maxWidth: 345,
  },
  media: {
    height: 0,
    paddingTop: '56.25%', // 16:9
  },
  expand: {
    transform: 'rotate(0deg)',
    marginLeft: 'auto',
    transition: theme.transitions.create('transform', {
      duration: theme.transitions.duration.shortest,
    }),
  },
  expandOpen: {
    transform: 'rotate(180deg)',
  },
  avatar: {
    backgroundColor: red[500],
  },
}));
export default function NewCard({ value }) {
  const classes = useStyles();
  return (
    &lt;Link to={`/blog`} state={{ value }}&gt;
      &lt;Card className={classes.root}&gt;
        &lt;CardHeader
          subheader={`Published On ${new Date(value.created_at).toLocaleDateString("in")}`}
        /&gt;
        &lt;CardMedia
          className={classes.media}
          image={"http://localhost:1337" + value.image.url}
        /&gt;
        &lt;CardContent&gt;
          &lt;Typography variant="body2" color="textSecondary" component="p"&gt;
            {value.title}
          &lt;/Typography&gt;
        &lt;/CardContent&gt;
      &lt;/Card&gt;&lt;/Link&gt;
  );
}
</pre>
<h3>设计博客页面</h3>
<p><img decoding="async" class="aligncenter jetpack-lazy-image" src="../Images/00ee6d3da697fa752d8b1b3293e23efe.png" alt="Demo blog page" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2020/06/blog-page.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/06/blog-page.png"/></p><noscript><img data-lazy-fallback="1" decoding="async" loading="lazy" class="aligncenter" src="../Images/00ee6d3da697fa752d8b1b3293e23efe.png" alt="Demo blog page" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/06/blog-page.png"/></noscript>
<p>我们将从传递给页面的location prop中获取博客的详细信息，并使用对<code>/comments?blog={{blog-id}}</code>的GET请求获取博客的评论。<code>blog-id</code>是当前博客的ID。</p>
<p>然后，我们将向<code>/comments</code>发出一个POST请求，请求头中带有JWT令牌。该令牌保存在本地存储中。</p>
<pre class="language-javascript hljs">import React, { useState, useEffect } from 'react';
import { makeStyles } from '@material-ui/core/styles';
import Grid from '@material-ui/core/Grid';
import Typography from '@material-ui/core/Typography';
import List from '@material-ui/core/List';
import ListItem from '@material-ui/core/ListItem';
import ListItemIcon from '@material-ui/core/ListItemIcon';
import ListItemText from '@material-ui/core/ListItemText';
import Avatar from '@material-ui/core/Avatar';
import { TextareaAutosize } from '@material-ui/core';
import Button from "@material-ui/core/Button"
const useStyles = makeStyles((theme) =&gt; ({
    root: {
        flexGrow: 1,
        textAlign: "center"
    },
    paper: {
        height: 500,
        width: 400,
    },
    control: {
        padding: theme.spacing(2),
    },
    content: {
        margin: "100px"
    }
}));
export default function ({ location }) {
    const classes = useStyles();
    const [comments, setComments] = useState([])
    const [content, setContent] = useState("")
    useEffect(() =&gt; {
        fetch(`http://localhost:1337/comments?blog=${location.state.value.id}`).then(res =&gt; res.json()).then(val =&gt; setComments(val))
    }, [])
    const submitComment = () =&gt; {
        fetch("http://localhost:1337/comments", {
            method: "post",
            headers: {
                "content-type": "application/json",
                authorization: `Bearer ${localStorage.getItem("token")}`
            },
            body: JSON.stringify({
                content,
                blog: location.state.value.id
            })
        }).then(() =&gt; fetch(`http://localhost:1337/comments?blog=${location.state.value.id}`).then(res =&gt; res.json()).then(val =&gt; setComments(val)))
    }
    return (
        &lt;&gt;
            &lt;Grid container className={classes.root} spacing={2}&gt;
                &lt;Grid item xs={12}&gt;
                    &lt;Grid container justify="center"&gt;
                        &lt;Grid item xs={10}&gt;
                            &lt;Typography variant="h3" component="h2" gutterBottom gutterLeft&gt;{location.state.value.title}&lt;/Typography&gt;
                        &lt;/Grid&gt;
                    &lt;/Grid&gt;
                &lt;/Grid&gt;
                &lt;Grid container justify="center"&gt;
                    &lt;img src={"http://localhost:1337" + location.state.value.image.url}&gt;&lt;/img&gt;
                &lt;/Grid&gt;
                &lt;Grid item xs={12} className={classes.content}&gt;
                    &lt;Grid container justify="center" spacing={10}&gt;
                        {location.state.value.content}
                    &lt;/Grid&gt;
                &lt;/Grid&gt;
                &lt;Typography variant="h4" component="h2" gutterBottom gutterLeft&gt;Comments&lt;/Typography&gt;
                &lt;Grid item xs={12}&gt;&lt;TextareaAutosize minLength={10} rowsMin={10} style={{ width: "100%" }} value={content} onChange={(e) =&gt; setContent(e.target.value)} /&gt;&lt;/Grid&gt;
                &lt;Grid item xs={12}&gt;&lt;Button onClick={submitComment}&gt;Submit comment&lt;/Button&gt;&lt;/Grid&gt;
                &lt;Grid item xs={12}&gt;
                    &lt;Grid container justify="left"&gt;
                        &lt;List&gt;
                            {
                                comments.map((val) =&gt; &lt;ListItem&gt;
                                    &lt;ListItemIcon&gt;&lt;Avatar&gt;{val.user.username[0]}&lt;/Avatar&gt;&lt;/ListItemIcon&gt;
                                    &lt;ListItemText primary={`${val.user.username} said  `} /&gt;
                                    &lt;ListItemText secondary={": " + val.content} /&gt;
                                &lt;/ListItem&gt;)
                            }
                        &lt;/List&gt;
                    &lt;/Grid&gt;
                &lt;/Grid&gt;
            &lt;/Grid&gt;
        &lt;/&gt;
    );
}
</pre>
<h2 id="adding-restful-login-dialog-component">添加RESTful登录对话框组件</h2>
<p>下面是我们的对话框组件在<a href="https://blog.logrocket.com/user-registration-authentication-strapi-next-js/">提示用户登录</a>时的样子。</p>
<p><img decoding="async" class="aligncenter jetpack-lazy-image" src="../Images/f02ccaa3a211e55c4f37ffeab0e5a1f5.png" alt="Sign-in prompt dialog component" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2020/06/dialog-component.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/06/dialog-component.png"/></p><noscript><img data-lazy-fallback="1" decoding="async" loading="lazy" class="aligncenter" src="../Images/f02ccaa3a211e55c4f37ffeab0e5a1f5.png" alt="Sign-in prompt dialog component" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/06/dialog-component.png"/></noscript>
<p>用用户名、电子邮件和密码向<code>/auth/local/register</code>发出用户注册的POST请求。当注册成功时，JWT令牌被返回并保存在本地存储中，以便以后使用。</p>
<p>对于登录，向<code>/auth/local</code>发出一个POST请求，其中包含两个字段:<code>identifier</code>和<code>password</code>。<code>identifier</code>可以是电子邮件或用户名。</p>
<pre class="language-javascript hljs">import React, { useState } from 'react';
import Button from '@material-ui/core/Button';
import TextField from '@material-ui/core/TextField';
import Dialog from '@material-ui/core/Dialog';
import DialogActions from '@material-ui/core/DialogActions';
import DialogContent from '@material-ui/core/DialogContent';
import DialogContentText from '@material-ui/core/DialogContentText';
import DialogTitle from '@material-ui/core/DialogTitle';
export default function FormDialog({ open, setOpen, login }) {
    const [pass, setPass] = useState("")
    const [email, setEmail] = useState("")
    const [user, setUser] = useState("")
    const handleSubmit = () =&gt; {
        if (!login)
            fetch("http://localhost:1337/auth/local/register", {
                method: "post",
                headers: {
                    "content-type": "application/json"
                },
                body: JSON.stringify({
                    password: pass,
                    email,
                    username: user
                })
            }).then((res) =&gt; res.json())
                .then(res =&gt; localStorage.setItem("token", res.jwt)).finally(() =&gt; setOpen(false))
        else
            fetch("http://localhost:1337/auth/local", {
                method: "post",
                headers: {
                    "content-type": "application/json"
                },
                body: JSON.stringify({
                    password: pass,
                    identifier: user || email
                })
            }).then((res) =&gt; res.json())
                .then(res =&gt; localStorage.setItem("token", res.jwt)).finally(() =&gt; setOpen(false))
    };
    const handleClose = () =&gt; {
        setOpen(false);
    };
    return (
        &lt;div&gt;
            &lt;Dialog open={open} onClose={handleClose} aria-labelledby="form-dialog-title"&gt;
                &lt;DialogTitle id="form-dialog-title"&gt;{login ? "Login" : "Register"}&lt;/DialogTitle&gt;
                &lt;DialogContent&gt;
                    &lt;DialogContentText&gt;
                        Please provide details
          &lt;/DialogContentText&gt;
                    &lt;TextField
                        autoFocus
                        margin="dense"
                        id="email"
                        label="Email Address"
                        type="email"
                        fullWidth
                        value={email}
                        onChange={(e) =&gt; { setEmail(e.target.value) }}
                    /&gt;
                    &lt;TextField
                        autoFocus
                        margin="dense"
                        id="username"
                        label="Username"
                        type="email"
                        fullWidth
                        value={user}
                        onChange={(e) =&gt; { setUser(e.target.value) }}
                    /&gt;
                    &lt;TextField
                        autoFocus
                        margin="dense"
                        id="password"
                        label="Password"
                        type="password"
                        fullWidth
                        value={pass}
                        onChange={(e) =&gt; { setPass(e.target.value) }}
                    /&gt;
                &lt;/DialogContent&gt;
                &lt;DialogActions&gt;
                    &lt;Button onClick={handleClose} color="primary"&gt;
                        Cancel
          &lt;/Button&gt;
                    &lt;Button onClick={handleSubmit} color="primary"&gt;
                        Submit
          &lt;/Button&gt;
                &lt;/DialogActions&gt;
            &lt;/Dialog&gt;
        &lt;/div&gt;
    );
}
</pre>
<h2 id="switching-sqlite-postgresql">从SQLite切换到PostgreSQL</h2>
<p>Strapi支持NoSQL和SQL数据库。更改数据库就像更改配置文件夹中的env变量一样简单。</p>
<p>默认情况下，Strapi使用SQLite，这有利于本地测试，但是在生产中，您应该使用生产就绪的数据库，例如<a href="https://blog.logrocket.com/getting-started-with-postgres-in-your-react-app/"> PostgreSQL </a>或MySQL。这里我们将使用PostgreSQL。</p>
<p>要更改数据库，请编辑<code>config/environments/production/database.json</code>文件。</p>
<pre class="language-json hljs">{
  "defaultConnection": "default",
  "connections": {
    "default": {
      "connector": "bookshelf",
      "settings": {
        "client": "postgres",
        "host": "${process.env.DATABASE_HOST }",
        "port": "${process.env.DATABASE_PORT }",
        "database": "${process.env.DATABASE_NAME }",
        "username": "${process.env.DATABASE_USERNAME }",
        "password": "${process.env.DATABASE_PASSWORD }"
      },
      "options": {}
    }
  }
}
</pre>
<p>现在，它将从生产环境变量中选择数据库凭证。</p>
<h2>结论</h2>
<p>现在你应该对Strapi有了基本的了解，对进一步的探索有了坚实的基础。我们演示了如何创建带有关系的数据库模式、实现身份验证、定制控制器以及过滤数据。</p>
<p>Strapi非常适合创建后端api。它高度可定制，支持广泛的集成。Strapi可以与Nuxt、React、Angular——实际上是任何前端框架一起使用。</p>
<div class="blog-plug inline-plug node-plug">
<h2>200只<img decoding="async" src="../Images/61167b9d027ca73ed5aaf59a9ec31267.png" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2019/10/green-check.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" class=" jetpack-lazy-image" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/10/green-check.png"/> <noscript> <img data-lazy-fallback="1" decoding="async" src="../Images/61167b9d027ca73ed5aaf59a9ec31267.png" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/10/green-check.png"/> </noscript>显示器出现故障，生产中网络请求缓慢</h2>
<p>部署基于节点的web应用程序或网站是容易的部分。确保您的节点实例继续为您的应用程序提供资源是事情变得更加困难的地方。如果您对确保对后端或第三方服务的请求成功感兴趣，请尝试LogRocket 。<a class="signup" href="https://logrocket.com/signup/" target="_blank" rel="noopener noreferrer"><img decoding="async" src="../Images/cae72fd2a54c5f02a6398c4867894844.png" alt="LogRocket Network Request Monitoring" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2019/12/network-request-filter-2-1.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" class=" jetpack-lazy-image" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/12/network-request-filter-2-1.png"/><noscript><img data-lazy-fallback="1" decoding="async" src="../Images/cae72fd2a54c5f02a6398c4867894844.png" alt="LogRocket Network Request Monitoring" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/12/network-request-filter-2-1.png"/></noscript></a><a href="https://logrocket.com/signup/" target="_blank" rel="noopener noreferrer">https://logrocket.com/signup/</a></p>
<p>LogRocket 就像是网络和移动应用程序的DVR，记录下用户与你的应用程序交互时发生的一切。您可以汇总并报告有问题的网络请求，以快速了解根本原因，而不是猜测问题发生的原因。</p>
<p>LogRocket检测您的应用程序以记录基线性能计时，如页面加载时间、到达第一个字节的时间、慢速网络请求，还记录Redux、NgRx和Vuex操作/状态。<a class="signup" href="https://logrocket.com/signup/" target="_blank" rel="noopener noreferrer">开始免费监控</a>。</p></div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
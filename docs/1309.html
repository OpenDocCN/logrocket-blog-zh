<html>
<head>
<title>Node.js 15: What’s new and how the developer experience has improved - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>Node.js 15:新增功能以及开发人员体验的改进</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/node-js-15-whats-new-and-how-the-developer-experience-has-improved/#0001-01-01">https://blog.logrocket.com/node-js-15-whats-new-and-how-the-developer-experience-has-improved/#0001-01-01</a></blockquote><div><article class="article-post">
<p><a href="https://nodejs.org/en/" target="_blank" rel="noopener noreferrer"> Node.js </a>的下一个主要版本现已发布。到目前为止，在Node.js 15系列发布中，我们已经看到了一些改进，一些新的JavaScript语言特性，甚至一些突破性的变化。</p>
<p>其中一些改进，比如新版的<a href="https://www.npmjs.com/" target="_blank" rel="noopener noreferrer"> NPM </a>，是实质性的，极大地改善了开发者的体验。其他变化，如N-API的新版本或对<a href="https://www.chromium.org/quic" target="_blank" rel="noopener noreferrer"> QUIC </a>协议的实验性支持，可能不会吸引大众，但对于确保Node.js继续可扩展并为web的未来做好准备同样重要。</p>
<p>让我们来看看有哪些新内容，以及您为什么应该关注。</p>
<blockquote><p>提示:Node.js 15不是一个长期支持(LTS)版本。对该版本的支持预计将在2021年6月结束，即第一个Node.js 16版本发布后不久。您可能希望暂时将生产应用程序保留在Node.js 14上。</p></blockquote>
<h2>NPM 7</h2>
<p>由于一系列新功能，NPM 7很可能是这次发布的最大头条。最大的特性是NPM工作区，它开始内置支持在单个文件系统中创建和管理多个NPM包。已经在积极使用<a href="https://yarnpkg.com/" target="_blank" rel="noopener noreferrer"> Yarn </a>包管理器或者<a href="https://lerna.js.org/" target="_blank" rel="noopener noreferrer"> Lerna </a>的开发者应该会看到与NPM工作空间实现的相似之处。</p>
<p>开始使用NPM工作空间相对容易。首先，在文件系统上排列所有的NPM包文件夹，创建一个引用每个文件夹的顶层package.json，并开始跨所有NPM包运行命令。</p>
<figure id="attachment_28632" aria-describedby="caption-attachment-28632" class="wp-caption aligncenter"><img data-attachment-id="28632" data-permalink="https://blog.logrocket.com/node-js-15-whats-new-and-how-the-developer-experience-has-improved/npm7-package-workspaces/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/11/NPM7-package-workspaces.png" data-orig-size="1020,718" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="NPM7-package-workspaces" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/11/NPM7-package-workspaces-300x211.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/11/NPM7-package-workspaces.png" decoding="async" class="wp-image-28632 jetpack-lazy-image" src="../Images/eebd9e10de0cd647a49ec76f34e3cb77.png" alt="NPM7 workspaces" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2020/11/NPM7-package-workspaces.png 1020w, https://blog.logrocket.com/wp-content/uploads/2020/11/NPM7-package-workspaces-300x211.png 300w, https://blog.logrocket.com/wp-content/uploads/2020/11/NPM7-package-workspaces-768x541.png 768w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2020/11/NPM7-package-workspaces.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/11/NPM7-package-workspaces.png"/><noscript><img data-lazy-fallback="1" data-attachment-id="28632" data-permalink="https://blog.logrocket.com/node-js-15-whats-new-and-how-the-developer-experience-has-improved/npm7-package-workspaces/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/11/NPM7-package-workspaces.png" data-orig-size="1020,718" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="NPM7-package-workspaces" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/11/NPM7-package-workspaces-300x211.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/11/NPM7-package-workspaces.png" decoding="async" loading="lazy" class="wp-image-28632" src="../Images/eebd9e10de0cd647a49ec76f34e3cb77.png" alt="NPM7 workspaces" srcset="https://blog.logrocket.com/wp-content/uploads/2020/11/NPM7-package-workspaces.png 1020w, https://blog.logrocket.com/wp-content/uploads/2020/11/NPM7-package-workspaces-300x211.png 300w, https://blog.logrocket.com/wp-content/uploads/2020/11/NPM7-package-workspaces-768x541.png 768w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/11/NPM7-package-workspaces.png"/></noscript><figcaption id="caption-attachment-28632" class="wp-caption-text">Here’s an NPM workspace example.</figcaption></figure>
<p>请记住，这是NPM工作区的初始实施。如果你是经验丰富的纱线或Lerna用户，你会注意到，许多表桩的能力仍然缺失。例如，使用NPM CLI<a href="https://github.com/npm/npm-v7-blog/issues/5" target="_blank" rel="noopener noreferrer">还无法</a>在工作区的特定包中执行脚本。我确信我们将会看到工作空间功能的迅速扩展。</p>
<blockquote><p>提示:您可以使用<code>--prefix</code>参数在工作区的特定包中运行脚本。例如，<code>npm run</code> <code>--``prefix recipe-generator test</code>会在当前工作区运行<code>recipe-generator</code>包中的<code>test</code>脚本。</p></blockquote>
<p>除了工作区之外，NPM 7中还引入了其他几项重大变化。</p>
<p>在NPM 6中，对等依赖基本上被忽略了。在NPM 7中，它们是默认安装的。你可以在<a href="https://github.com/npm/rfcs/blob/latest/implemented/0025-install-peer-deps.md" target="_blank" rel="noopener noreferrer"> NPM RFC0025 </a>中了解更多关于这一变化的信息。有趣的是，React开发人员社区可能影响了这一变化。</p>
<p>使用新的<code>npm exec</code>命令，在不安装NPM软件包的情况下运行它们已经成为核心NPM的一部分。这个新命令取代了<code>npx</code>，但行为也略有不同。为了向后兼容，<code>npx</code>被重写为使用<code>npm exec</code>但相同的CLI。你可以在<a href="https://docs.npmjs.com/cli/v7/commands/npm-exec" target="_blank" rel="noopener noreferrer"> NPM文档</a>中了解更多。</p>
<p>NPM现在支持yarn.lock文件。如果该文件存在，NPM将使用它来确定从哪里获取包。NPM甚至会在添加或删除软件包时更新它。没有用yarn.lock替换package-lock.json的计划，实际上，仍然生成并维护一个package-lock.json文件，作为包版本元数据的权威来源。</p>
<p>NPM有一个新的package-lock.json格式，现在支持确定性构建。简而言之，这意味着如果package-lock.json文件没有改变，NPM可以确保已安装软件包的版本在不同的构建中保持一致。一段时间以来，确定性构建一直是Yarn的一个特征。</p>
<p>这仅仅触及了NPM 7号的表面。你可以在这里阅读更多关于NPM 7 <a href="https://blog.npmjs.org/post/634067895980294144/release-v709" target="_blank" rel="noopener noreferrer">的新内容。</a></p>
<h2>V8 8.6</h2>
<p>Node.js 15将其使用的V8引擎版本从8.4提升到8.6。V8是Node.js运行的底层JavaScript引擎。</p>
<p>所以你为什么要在乎呢？因为V8定义了可供开发人员使用的JavaScript语言特性。虽然这个版本变动很小，但是有一些新的语言特性将减少您需要编写的代码量，并可能使您的代码更具可读性。</p>
<p>首先，有一些新的逻辑赋值操作符允许您有条件地为变量赋值:</p>
<pre>// new logical AND operator
let a = 1;
let b = 0;
a &amp;&amp;= 2;
b &amp;&amp;= 2;
console.log(a); // prints 2
console.log(b); // prints 0

// new logical OR operator
a = 1;
b = null;
a ||= 3;
b ||= 3;
console.log(a); // prints 1
console.log(b); // prints 3

// new logical nullish operator
a = 1;
b = null;
a ??= 4;
b ??= 4; 
console.log(a); // prints 1
console.log(b); // prints 4
</pre>
<p><code>Promise</code>对象有一个新的<code>any()</code>函数，它接受一个或多个承诺并返回首先解决的承诺。被拒绝的承诺被忽略。如果所有承诺都被拒绝，则返回一个新的<code>AggregateError</code>，其中包含所有被拒绝承诺的错误。</p>
<p>许多开发人员没有记住正则表达式语法。幸运的是，<code>String</code>对象现在有了一个新的<code>replaceAll()</code>函数，这意味着少了一个正则表达式，您需要查找它来替换所有出现的字符串。</p>
<p>就这么简单:<code>myString.replaceAll(``'``regex``'``,</code> <code>'``function``'``)</code>。</p>
<h2>对QUIC协议(HTTP/3)的实验性支持</h2>
<p>HTTP/1标准出现在1996年左右。近19年后，经过对原始标准的多次扩展，HTTP/2在2015年成为标准。</p>
<p>现在我们紧跟在HTTP/3之后，它将取代从TCP到QUIC的网络传输层协议。Node.js通过增加对QUIC协议的实验性支持，继续向开发人员社区承诺保持最新标准的领先地位。</p>
<p>好吧，标准正在以更快的速度发展，但是这对主流Node.js开发人员意味着什么呢？嗯，这可能意味着很多，取决于你正在建设什么。</p>
<p>如果您正在使用<code>net</code>模块在您的应用程序中创建套接字，您可以开始利用一组新的实验函数和对象来使用QUIC协议建立连接。与TCP相比，QUIC承诺减少延迟，TLS加密是内置的，等等。</p>
<h2>未处理的拒绝承诺</h2>
<p>Node.js 15中最大的突破性变化是如何处理未处理的拒绝承诺。在Node.js 14中，如果您没有显式处理被拒绝的承诺，您会看到以下警告:</p>
<pre>(node:764) UnhandledPromiseRejectionWarning: something happened
(Use `node --trace-warnings ...` to show where the warning was created)
(node:764) UnhandledPromiseRejectionWarning: Unhandled promise rejection. This error originated either by throwing inside of an async function without a catch block, or by rejecting a promise which was not handled with .catch(). To terminate the node process on unhandled promise rejection, use the CLI flag `--unhandled-rejections=strict` (see https://nodejs.org/api/cli.html#cli_unhandled_rejections_mode). (rejection id: 2)
(node:764) [DEP0018] DeprecationWarning: Unhandled promise rejections are deprecated. In the future, promise rejections that are not handled will terminate the Node.js process with a non-zero exit code.
</pre>
<p>Node.js 15中的警告现已被替换为一个错误:</p>
<pre>node:internal/process/promises:218
          triggerUncaughtException(err, true /* fromPromise */);
          ^

[UnhandledPromiseRejection: This error originated either by throwing inside of an async function without a catch block, or by rejecting a promise which was not handled with .catch(). The promise rejected with the reason "recipe 
could not be generated".] {
  code: 'ERR_UNHANDLED_REJECTION'
}
</pre>
<p>这种变化有可能影响许多应用程序，特别是对于过去忽略警告消息的开发人员。您可以通过使用新的<code>--unhandled-rejections=warn</code>参数启动Node.js来恢复这种行为。</p>
<h2>实验诊断通道模块</h2>
<p>Node.js 15.1.0引入了一个名为<code>diagnostics_channel</code>的新实验模块。该模块本质上启用了发布-订阅模式，开发人员可以使用该模式将任意数据发布到可供其他模块或应用程序使用的通道。该模块是有意通用的，可以以多种方式使用。</p>
<p>您可以导入并立即开始使用该模块:</p>
<pre>const diagnostics_channel = require('diagnostics_channel');
</pre>
<p>创建一个频道并向其发布消息实际上非常简单。此示例演示了如何创建通道并向其发布消息:</p>
<pre>const getData = filter =&gt; {
    const alertChannel = diagnostics_channel.channel('my-module.alert');

    return new Promise((resolve, reject) =&gt; {
        const data = doSomething(filter);
        if (data) {
            resolve(data);
        } else {
            const errorMessage = "data could not be retrieved";
            alertChannel.publish(errorMessage);
            reject(errorMessage);
        }
    });
}
</pre>
<p>使用来自通道的消息也同样简单。下面是一个示例，说明如何从另一个模块或应用程序订阅一个通道，并利用从该通道接收的数据:</p>
<pre>  const alertChannel = diagnostics_channel.channel('my-module.alert');
  alertChannel.subscribe(message =&gt; {
    console.log(`Alert received on my-module.alert channel: ${message}`);
  });
</pre>
<h2>其他显著变化</h2>
<p>与我们目前所看到的相比，该版本中还有一些其他值得注意的变化，这些变化可能不会影响太多的开发人员:</p>
<ul>
<li>N-API 7在这里。N-API是开发人员可以为Node.js构建本机附加组件的几种方法之一。N-API版本可以追溯到早在Node.js 6的早期LTS版本。N-API确保插件与过去、现在和未来的Node.js LTS版本保持兼容</li>
<li>已弃用的<code>node debug</code>命令现已移除。它被替换为<code>node inspect</code>，后者使用广泛采用的基于检查器的方法来调试Node.js</li>
<li><code>repl</code>模块中的几个不推荐使用的函数已被删除。删除不推荐使用的函数并不奇怪，但是如果您在应用程序中使用<code>repl</code>模块，那么回顾一下<a href="https://nodejs.org/en/blog/release/v15.0.0/" target="_blank" rel="noopener noreferrer">发行说明</a>可能是值得的</li>
</ul>
<h2>下一步是什么？</h2>
<p>我们可以期待更多Node.js 15次要版本和补丁发布，直到2021年4月。之后，我们将开始看到Node.js 16的最初几次迭代，这将是下一个LTS版本。</p><div class="code-block code-block-23">
<div class="blog-plug inline-plug node-plug"><h2>200只<img src="../Images/61167b9d027ca73ed5aaf59a9ec31267.png" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2019/10/green-check.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" class=" jetpack-lazy-image" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/10/green-check.png"/> <noscript> <img data-lazy-fallback="1" src="../Images/61167b9d027ca73ed5aaf59a9ec31267.png" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/10/green-check.png"/> </noscript>显示器出现故障，生产中网络请求缓慢</h2><p>部署基于节点的web应用程序或网站是容易的部分。确保您的节点实例继续为您的应用程序提供资源是事情变得更加困难的地方。如果您对确保对后端或第三方服务的请求成功感兴趣，</p><a href="https://lp.logrocket.com/blg/node-signup" target="_blank">try LogRocket</a><p>. </p><a class="signup" href="https://lp.logrocket.com/blg/node-signup" target="_blank" rel="noopener noreferrer"><img src="../Images/cae72fd2a54c5f02a6398c4867894844.png" alt="LogRocket Network Request Monitoring" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2019/12/network-request-filter-2-1.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" class=" jetpack-lazy-image" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/12/network-request-filter-2-1.png"/><noscript><img data-lazy-fallback="1" src="../Images/cae72fd2a54c5f02a6398c4867894844.png" alt="LogRocket Network Request Monitoring" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/12/network-request-filter-2-1.png"/></noscript></a><a href="https://lp.logrocket.com/blg/node-signup" target="_blank" rel="noopener noreferrer">https://logrocket.com/signup/</a><p>LogRocket 就像是网络和移动应用程序的DVR，记录下用户与你的应用程序交互时发生的一切。您可以汇总并报告有问题的网络请求，以快速了解根本原因，而不是猜测问题发生的原因。</p><p>LogRocket检测您的应用程序以记录基线性能计时，如页面加载时间、到达第一个字节的时间、慢速网络请求，还记录Redux、NgRx和Vuex操作/状态。</p><a class="signup" href="https://lp.logrocket.com/blg/node-signup" target="_blank" rel="noopener noreferrer">Start monitoring for free</a><p>. </p></div>
</div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
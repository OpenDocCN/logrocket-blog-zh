<html>
<head>
<title>Truly reactive programming with Svelte 3.0 - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>用苗条的3.0 - LogRocket博客进行真正的反应式编程</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/truly-reactive-programming-with-svelte-3-0-321b49b75969/#0001-01-01">https://blog.logrocket.com/truly-reactive-programming-with-svelte-3-0-321b49b75969/#0001-01-01</a></blockquote><div><article class="article-post">
<p>这个标题有点戏剧性，但话说回来，苗条和它背后的想法也是如此。如果你还不知道什么是苗条，那么系好安全带——你将见证一场革命，这将是一次旅程(对苗条团队没有压力😅).</p>
<p/>
<p>注意，这不是一个如何开始苗条身材的教程。已经有一个由Svelte团队开发的很棒的<a class="markup--anchor markup--p-anchor" href="https://svelte.dev/tutorial/basics" target="_blank" rel="noreferrer nofollow noopener" data-href="https://svelte.dev/tutorial/basics">一步一步的交互式教程</a>，可以让你轻松进入反应式编程的世界。</p>
<p><strong>免责声明依次:</strong>我不是编程摇滚明星，也不是什么都知道。我只是对每天都在进行的创新充满热情，并且我喜欢在可能的时候谈论它们——因此，这篇文章。对我说的一切都要持保留态度，如果我说了什么可笑的话，请告诉我。</p>
<p>好吧，让我们开始吧！</p>
<h2>但是首先，做出反应</h2>
<p>在我开始解释为什么我认为苗条是如此具有破坏性之前，让我们先来看看丹不久前发的这条推文，并剖析它的实际含义:</p>

<p/>
<p><strong>另一个免责声明:</strong>本文无意以任何方式抨击React。我只是决定使用React作为一个案例研究，因为大多数阅读本文的人都曾经使用过它。这是最好的例子来对比苗条。</p>
<p>Dan是什么意思，这对我们目前编写代码的方式有什么影响？为了回答这个问题，让我给你一个React如何在幕后工作的简化视图。</p>
<p>当你渲染一个React应用时，React会在一个叫做<a class="markup--anchor markup--p-anchor" href="https://reactjs.org/docs/faq-internals.html" target="_blank" rel="noreferrer nofollow noopener" data-href="https://reactjs.org/docs/faq-internals.html">虚拟DOM </a>的地方保存一份DOM副本。虚拟DOM充当React代码和浏览器绘制到DOM的内容之间的中间人。</p>
<p>然后，当你的数据改变时(也许你调用了<code>this.setState</code>或<code>useState</code>)，React会做一些工作来决定如何在屏幕上重新绘制你的UI。</p>
<p>它将虚拟DOM与真实DOM进行比较，以确定由于数据更新而发生了什么变化。然后，它只重画与虚拟DOM中的新副本不匹配的DOM部分，这样就不需要在每次发生变化时重画整个DOM。</p>
<p>现在，这非常快，因为更新虚拟DOM比更新真实DOM便宜得多，React只更新真实DOM中需要更新的部分。这篇文章更好地解释了这个过程。</p>
<p>但是对于这个实现，您可能已经注意到了一些东西。如果你不告诉React你的数据已经改变了(即通过调用<code>this.setState</code>或者钩子的等价物)，你的虚拟DOM不会改变，React也不会反应(ba dum tss！🤓).</p>
<p>这就是丹所说的反应不是完全反应的意思。React依靠你来跟踪你的应用程序的数据，并在数据发生变化时告诉它，这通常需要你做更多的工作。</p>
<h2>好的，现在变苗条</h2>
<p>Svelte是一种全新的构建UI的方式，它以一种惊人的快速、高效和真正反应式的方式，完全不需要使用虚拟DOM，使用的代码比使用任何其他框架或库都要少。</p>
<p>这听起来不错，但是你会问，它与其他无数的JavaScript库和框架有什么不同呢？我告诉你。</p>
<h3>1.真实反应性</h3>
<p>Svelte不是图书馆。苗条不是一个框架。相反，Svelte是一个编译器，它接收您的代码，并发出本机JavaScript，直接与您的DOM交互，不需要任何中介。</p>
<p>等等，什么？编译器？是的——一个编译器。这是一个非常好的想法，我不知道为什么直到现在才这么明显，我会告诉你为什么我认为它很酷。</p>
<p>下面是Rich Harris在YGLF 2019大会上的讲话:</p>
<blockquote><p>Svelte 3.0将反应性从组件API移到了语言中。</p></blockquote>
<p id="af40" class="graf graf--p graf-after--blockquote">那是什么意思？嗯，我们已经看到React(和大多数其他前端框架)如何要求您使用API来告诉它数据已经更改(再次通过调用<code>this.setState</code>或在它知道更新其虚拟DOM之前使用<code>useState)</code>)。</p>
<p id="65b1" class="graf graf--p graf-after--p">在React(以及大多数其他UI框架和库)中调用<code>this.setState</code>的需要意味着你的应用程序的反应性现在被绑定到一个特定的API，如果没有它，它将完全意识不到数据变化。</p>
<p id="42c3" class="graf graf--p graf-after--p">Svelte对此采取了另一种方法。</p>
<p id="2e7d" class="graf graf--p graf-after--p">它从运行代码的方式中获得了灵感。它不是从上到下运行代码，而是按照拓扑顺序运行。看看下面的代码片段，我们将按照拓扑顺序来解释它的含义。</p>
<pre>1. (() =&gt; {
2.   const square = number =&gt; number * number;
3.
4.   const secondNumber = square(firstNumber);
5.   const firstNumber = 42;
6.
7.   console.log(secondNumber);
8. })();</pre>
<p>现在，如果你从上到下运行这段代码，你会在第4行得到一个错误，因为<code>secondNumber</code>依赖于<code>firstNumber</code>，而此时它还没有被初始化。</p>
<p>如果您按照拓扑顺序运行相同的代码，您不会得到任何错误。怎么会这样编译器不会从头到尾运行这段代码；相反，它会查看所有的变量并生成一个依赖图(例如，谁先需要谁)。</p>
<p>在我们的例子中，这是一个关于编译器如何编译这些代码的可笑的简化视图。</p><div class="code-block code-block-54">
<hr/>
<h3>更多来自LogRocket的精彩文章:</h3>

<hr/></div>
<pre>1. Does this new variable 'square' depend on any other variable?
     - it doesn't, so I'll initialize it
2. Does this new variable 'secondNumber' depend on any other variable?
     - it depends on 'square' and 'firstNumber'. I already initialized 'square', but I haven't initialized 'firstNumber', which I will do  now.
3. OK, I've initialized 'firstNumber'. Now I can initialize 'secondNumber' using 'square' and 'firstNumber'
     - Do I have all the variables required to run this console.log  statement?
     - Yes, so I'll run it.</pre>
<p>乍一看，代码似乎是自上而下运行的，但是仔细观察，您会发现它实际上做了一些跳跃。</p>
<p>当它到达第4行时，编译器发现它没有<code>firstNumber</code>，所以它在那里暂停执行，并检查您的代码，看看您是否在任何地方定义了它。好吧，我们在第5行做了同样的事情，所以它先运行第5行，然后返回到第4行执行它。</p>
<blockquote><p><strong>TL；DR: </strong>如果语句A依赖于语句B，那么不管声明的顺序如何，语句B都会先运行。</p></blockquote>
<p>那么这如何适用于Svelte实现真实反应的方式呢？好吧，你可以用JavaScript中的标识符给一个语句加标签，那个操作看起来是这样的:<code>$: foo = bar</code>。所做的只是在<code>foo = bar</code>语句中添加一个名为<code>$</code>的标识符(如果没有提前定义<code>foo</code>，这个操作在严格模式下会失败)。</p>
<p>所以在这种情况下，当Svelte看到任何以<code>$:</code>为前缀的语句时，它知道左边的变量从右边的变量中导出它的值。我们现在有了一种将一个变量的值绑定到另一个变量的方法。</p>
<p>反应性！这意味着我们现在使用JavaScript API的核心部分来实现真正的反应，而不需要摆弄像<code>this.setState</code>这样的第三方API。</p>
<p>实际情况是这样的:</p>
<pre>1. // vanilla js
2. let foo = 10;
3. let bar = foo + 10; // bar is now 20
4. foo = bar // bar is still 20 (no reactivity)
5. bar = foo + 10 // now bar becomes 30
6. // svelte js
7. let foo = 10;
8. $: bar = foo + 10; // bar is now 20
9. foo = 15 // bar is now 25 because it is bound to the value of foo</pre>
<p>请注意，在上面的代码中，我们不需要将bar重新分配给新的值<code>foo</code>——无论是直接通过<code>bar = foo + 10;</code>还是通过调用像<code>this.setState({ bar = foo + 10 });</code>这样的API方法。它会自动为我们处理。</p>
<p>这意味着当你把<code>bar</code>改成等于15的时候，<code>foo</code>自动更新为25，不用调用API替你更新。斯维尔特已经知道了。</p>
<p>上面简单代码的编译版本看起来像这样:</p>
<pre>1. ... omitted for brevity ...
2. function instance($$self, $$props, $$invalidate) {
3.   let foo = 10; // bar is now 20
4.   $$invalidate('foo', foo = 15) // bar is now 25 because it is bound to the value of foo
5.   let bar;
6.   $$self.$$.update = ($$dirty = { foo: 1 }) =&gt; {
7.     if ($$dirty.foo) { $$invalidate('bar', bar = foo + 19); }
8.   };
9.   return { bar };
10. }
11. ... omitted for brevity ...</pre>
<p>花点时间认真研究上面这段代码。真的慢慢来。</p>
<p>你看到了在<code>bar</code>被定义之前<code>foo</code>的更新是如何发生的吗？这是因为编译器是按照拓扑顺序而不是严格的自上而下的顺序解析细长的代码。</p>
<p>Svelte正在对数据变化做出自己的反应。它不希望您担心跟踪什么时候改变了什么；它会自动知道。</p>
<blockquote><p><strong>注意</strong>:在第4行，<code>bar</code>的值直到下一个<a class="markup--anchor markup--p-anchor" href="https://www.youtube.com/watch?v=8aGhZQkoFbQ" target="_blank" rel="noopener noreferrer" data-href="https://www.youtube.com/watch?v=8aGhZQkoFbQ">事件循环</a>之后才会更新，一切都保持整洁。</p></blockquote>
<p>这使您不必担心在数据发生变化时手动更新状态。你可以整天专注于你的逻辑，而Svelte帮助你将你的用户界面与你的最新状态相协调。</p>
<h3>2.短暂</h3>
<p>还记得我说过Svelte允许你用更少的代码行做这么多事情吗？我是认真的。我将向您展示React中的一个简单组件及其在Svelte中的等效组件，您可以自己判断:</p>
<p><img decoding="async" class="graf-image jetpack-lazy-image" src="../Images/03b89b12e41a4ac6ca89053abdbc7eab.png" data-image-id="1*y8KNWov5UwulVryUPq6srw@2x.png" data-lazy-src="https://cdn-images-1.medium.com/max/1600/1*y8KNWov5UwulVryUPq6srw@2x.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://cdn-images-1.medium.com/max/1600/1*y8KNWov5UwulVryUPq6srw@2x.png"/></p><noscript><img data-lazy-fallback="1" decoding="async" class="graf-image" src="../Images/03b89b12e41a4ac6ca89053abdbc7eab.png" data-image-id="1*y8KNWov5UwulVryUPq6srw@2x.png" data-original-src="https://cdn-images-1.medium.com/max/1600/1*y8KNWov5UwulVryUPq6srw@2x.png"/></noscript>
<figure id="fc15" class="graf graf--figure graf-after--p"><figcaption class="imageCaption">17 vs. 29 lines of code</figcaption></figure>
<p>这两个应用程序在功能上完全相同，但你可以看到我们在React.js中要写多少代码——甚至不要让我开始使用Angular😂。</p>
<p><img decoding="async" class="graf-image jetpack-lazy-image" src="../Images/51980a4af46abefe43e006dcdedfe476.png" data-image-id="1*129rCsjvqwpczQ5Ld_U44A@2x.png" data-lazy-src="https://cdn-images-1.medium.com/max/1600/1*129rCsjvqwpczQ5Ld_U44A@2x.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://cdn-images-1.medium.com/max/1600/1*129rCsjvqwpczQ5Ld_U44A@2x.png"/></p><noscript><img data-lazy-fallback="1" decoding="async" class="graf-image" src="../Images/51980a4af46abefe43e006dcdedfe476.png" data-image-id="1*129rCsjvqwpczQ5Ld_U44A@2x.png" data-original-src="https://cdn-images-1.medium.com/max/1600/1*129rCsjvqwpczQ5Ld_U44A@2x.png"/></noscript>
<figure id="59a1" class="graf graf--figure graf-after--p"><figcaption class="imageCaption">I’m the oldest dev alive 😎</figcaption></figure>
<p>除了苗条的代码更悦目之外，它也更容易推理，因为它比React代码有更少的活动部分。我们不需要事件处理程序来更新输入元素的值——只需绑定值就足够了。</p>
<p>假设你刚刚开始学习web开发。哪个代码会让你更困惑？左边的那个，还是右边的那个？</p>
<p>虽然这似乎是一个微不足道的观点，但当您开始构建更大更复杂的应用程序时，编写更少的代码行是多么有用，这一点很快就会变得清楚。我个人发现自己花了几个小时试图理解我的队友编写的大型React组件是如何工作的。</p>
<p>我真诚地相信Svelte的简化API将允许我们更快地阅读和理解代码，提高我们的整体生产力。</p>
<h3>3.表演</h3>
<p>好了，我们已经看到，苗条是真正的反应，让你少花钱多办事。性能呢？完全用瘦体编写的应用程序的用户体验是什么样的？</p>
<p>React如此强大的原因之一是因为它如何使用虚拟DOM来更新应用程序UI的一些部分，从而消除了每次发生变化时重新绘制整个DOM的需要(这真的很昂贵)。</p>
<p>然而，这种方法的缺点是，如果组件的数据发生变化，React将重新呈现该组件及其所有子组件，不管子组件是否需要重新呈现。这也是React有<code>shouldComponentUpdate</code>、<code>useMemo</code>、<code>React.PureComponent</code>等API的原因。</p>
<p>如果使用虚拟DOM绘制状态变化的UI，这个问题将会一直存在。</p>
<p>Svelte不使用虚拟DOM，那么它如何解决重绘DOM以匹配应用程序状态的问题呢？让我再次引用Rich Harris精彩的YGLF演讲:</p>
<blockquote><p>框架不是组织代码的工具。它们是组织你思维的工具。</p></blockquote>
<p>上面的引用让Rich想到框架可以是在构建步骤中运行的东西，消除了代码在运行时需要中介的需要。这个想法就是为什么Svelte是一个编译器而不是一个框架。</p>
<p>这个简单的想法就是为什么苗条真的很快。Svelte将您的代码编译成一个高效的、低级的代码，直接与DOM交互。这当然很好，但是当数据改变时，Svelte如何解决重画整个DOM的问题呢？</p>
<p>区别在于像React这样的框架知道什么改变了，而Svelte做同样的事情。我们已经看到React是如何依赖你调用一个API方法来告诉它你的数据何时改变，但是对于Svelte，简单地使用赋值操作符<code>=</code>就足够了。</p>
<p>如果使用<code>=</code>操作符更新一个状态变量——比如说<code>foo</code>, Svelte将只更新依赖于<code>foo</code>的其他变量，就像我们前面看到的那样。这允许Svelte只重画DOM中以某种方式从<code>foo</code>获得值的部分。</p>
<p>因为这篇文章已经够长了，所以我将省略它的实际实现。你可以看看里奇·哈里斯本人对此的解释。</p>
<h2>最后的想法</h2>
<p>Svelte 3.0是软件开发领域最近发生的最好的事情之一。有些人可能会说这是夸大其词，但我不同意。Svelte及其执行背后的概念将使我们能够做更多的事情，同时向浏览器发送更少的样板JS。</p>
<p>反过来，这将允许更高性能、更轻量级的应用程序，并产生更易于阅读的代码。现在，Svelte会很快取代React、Angular或任何其他成熟的前端框架吗？</p>
<p>目前，我可以说答案是否定的。与那些相比，苗条相对较新，所以它需要时间来成长、成熟，并解决一些我们可能甚至不知道存在的问题。</p>
<p>就像React的问世改变了软件开发一样，Svelte也有可能改变我们对框架的看法，以及当我们创建新的思考框架时什么是可能的。</p>
<p>编码快乐！</p><div class="code-block code-block-17">
<div class="blog-plug inline-plug react-plug" vwo-el-id="26283398190">
<h2 vwo-el-id="41600691720"><a href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener"> LogRocket </a>:全面了解您的生产React应用</h2><p>调试React应用程序可能很困难，尤其是当用户遇到难以重现的问题时。如果您对监视和跟踪Redux状态、自动显示JavaScript错误以及跟踪缓慢的网络请求和组件加载时间感兴趣，</p><a href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" vwo-el-id="19356441070">try LogRocket</a><p>. </p><a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="19356441380">
<img class="first-react-image alignnone size-full wp-image-46 jetpack-lazy-image jetpack-lazy-image--handled" src="../Images/f300c244a1a1cf916df8b4cb02bec6c6.png" vwo-el-id="18272717540" data-lazy-loaded="1" data-original-src="https://files.readme.io/27c94e7-Image_2017-06-05_at_9.46.04_PM.png"/>
</a>
<a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="19356441690">
<img class="second-react-image alignnone size-full wp-image-46 jetpack-lazy-image jetpack-lazy-image--handled" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" vwo-el-id="30720362350" data-lazy-loaded="1" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/>
</a>
<p vwo-el-id="28675660440" class="">LogRocket 结合了会话回放、产品分析和错误跟踪，使软件团队能够创建理想的web和移动产品体验。这对你来说意味着什么？</p>
<p>LogRocket不是猜测错误发生的原因，也不是要求用户提供截图和日志转储，而是让您回放问题，就像它们发生在您自己的浏览器中一样，以快速了解哪里出错了。</p>
<p>不再有嘈杂的警报。智能错误跟踪允许您对问题进行分类，然后从中学习。获得有影响的用户问题的通知，而不是误报。警报越少，有用的信号越多。</p>
<p vwo-el-id="28675660750">LogRocket Redux中间件包为您的用户会话增加了一层额外的可见性。LogRocket记录Redux存储中的所有操作和状态。</p>
<p vwo-el-id="28675661060">现代化您调试React应用的方式— <a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="40093418840">开始免费监控</a>。</p>
</div></div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
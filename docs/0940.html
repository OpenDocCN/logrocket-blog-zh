<html>
<head>
<title>Creating a web server with Golang - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>用Golang - LogRocket博客创建web服务器</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/creating-a-web-server-with-golang/#0001-01-01">https://blog.logrocket.com/creating-a-web-server-with-golang/#0001-01-01</a></blockquote><div><article class="article-post">
<p>Go是创建简单而高效的web服务器和web服务的绝佳语言。它提供了一个内置的HTTP包，其中包含用于快速创建web或文件服务器的实用程序。</p>
<p>本教程的目标是创建一个可以接受GET请求并提供响应的web服务器。我们将使用服务器来服务静态文件，充当文件服务器。然后，我们将让web服务器响应来自表单提交的POST请求，比如联系表单。</p>
<p>事不宜迟，让我们探索如何用Go构建您的第一个web服务器。</p>
<h2>设置</h2>
<p>您需要Go版本1.11或更高版本来遵循本教程。</p>
<p>在本节中，我们将创建所有必要的文件并建立正确的文件结构。之后，我们将导入我们的包来测试设置是否工作。不要担心Golang web服务器的设置非常简单。</p>
<p>根据下面的结构创建下列文件和文件夹。文件<code>server.go</code>位于项目的根目录，文件夹<code>static</code>也是如此，它包含两个HTML文件:<code>index.html</code>和<code>form.html</code>。</p>
<pre>- server.go
- static/
- - index.html
- - form.html
</pre>
<p>现在让我们写一些代码。打开<code>server.go</code>文件，导入所需的包。我们将使用<code>fmt</code>向终端打印有用的数据，使用<code>log</code>打印致命错误，以防web服务器崩溃。</p>
<p><code>net/http</code>是最重要的包裹。它提供了创建HTTP客户端或服务器实现(如Golang web服务器)的所有功能。</p>
<pre>package main

import (
    "fmt"
    "log"
    "net/http"
)
</pre>
<p>最后，让我们在<code>server.go</code>文件中添加一个简单的<code>main()</code>函数，向终端打印一条消息。</p>
<pre>func main() {
    fmt.Printf("Starting server at port 8080\n")
}
</pre>
<p>要测试设置，用下面的命令启动虚拟服务器。</p>
<pre>go run server.go
</pre>
<p>如果您按照设置进行操作，您应该在终端中看到以下输出。</p>
<pre>Starting server at port 8080
</pre>
<p>如果一切顺利，下一步就是创建web服务器。</p>
<h2>使用获取路由启动web服务器</h2>
<p>在这个阶段，我们将创建一个web服务器，它实际上在端口8080上提供服务，并且可以响应传入的GET请求。</p>
<p>让我们修改<code>main()</code>函数中的代码，在端口8080启动一个web服务器。<code>ListenAndServe</code>方法由我们在第一步中导入的<code>http</code>包导出。这个方法允许我们启动web服务器并指定端口来监听传入的请求。</p>
<p>请注意，port参数需要以冒号加标点符号的字符串形式传递。第二个参数接受一个处理程序来为HTTP/2配置服务器。然而，这对于本教程并不重要，所以我们可以安全地将<code>nil</code>作为第二个参数传递。</p>
<pre> func main() {
    fmt.Printf("Starting server at port 8080\n")
    if err := http.ListenAndServe(":8080", nil); err != nil {
        log.Fatal(err)
    }
}
</pre>
<p>此时，服务器可以启动，但是它仍然不知道如何处理请求。我们需要将处理程序传递给服务器，以便它知道如何响应传入的请求以及接受哪些请求。</p>
<p>我们将使用<code>HandleFunc</code>函数向web服务器添加路由处理程序。第一个参数接受它需要监听<code>/hello</code>的路径。在这里，您告诉服务器监听任何对<code><a href="http://localhost:8080/hello" rel="nofollow">http://localhost:8080/hello</a></code>的请求。第二个参数接受一个函数，该函数包含正确响应请求的业务逻辑。</p>
<p>默认情况下，这个函数接受一个<code>ResponseWriter</code>来发回响应，接受一个<code>Request</code>对象来提供关于请求本身的更多信息。例如，您可以访问有关已发送邮件头的信息，这对验证请求很有用。</p>
<pre>func main() {
    http.HandleFunc("/hello", func(w http.ResponseWriter, r *http.Request){
        fmt.Fprintf(w, "Hello!")
    })


    fmt.Printf("Starting server at port 8080\n")
    if err := http.ListenAndServe(":8080", nil); err != nil {
        log.Fatal(err)
    }
}
</pre>
<p>如您所见，当我们将这个响应传递给<code>ResponseWriter</code>时，处理程序发送一个<code>“Hello!”</code>消息。</p><div class="code-block code-block-54">
<hr/>
<h3>更多来自LogRocket的精彩文章:</h3>

<hr/></div>
<p>现在让我们试试这个设置。用<code>go run server.go</code>启动网络服务器并访问<code><a href="http://localhost:8080/hello" rel="nofollow">http://localhost:8080/hello</a></code>。如果服务器回复了<code>"Hello!"</code>，你可以继续下一步，在这里你将学习如何为你的Golang web服务器路由增加基本的安全性。</p>
<h2>为路由添加基本安全性</h2>
<p>不言而喻，安全是重要的。让我们探讨一些基本策略来增强您的Go web服务器的安全性。</p>
<p>在此之前，我们应该花点时间增加代码的可读性。让我们创建<code>helloHandler</code>函数，它保存与<code>/hello</code>请求相关的所有逻辑。</p>
<pre>func helloHandler(w http.ResponseWriter, r *http.Request) {
    if r.URL.Path != "/hello" {
        http.Error(w, "404 not found.", http.StatusNotFound)
        return
    }

    if r.Method != "GET" {
        http.Error(w, "Method is not supported.", http.StatusNotFound)
        return
    }


    fmt.Fprintf(w, "Hello!")
}
</pre>
<p>这个处理程序使用<code>Request</code>对象来检查请求的路径是否正确。这是一个关于如何使用<code>Request</code>对象的非常基本的例子。</p>
<p>如果路径不正确，服务器会向用户返回一个<code>StatusNotFound</code>错误。要向用户写一个错误，可以使用<code>http.Error</code>方法。请注意，<code>StatusNotFound</code>代码对应于一个404错误。所有状态代码都可以在<a href="https://golang.org/pkg/net/http/#pkg-constants" target="_blank" rel="noopener noreferrer"> Golang文档</a>中找到。</p>
<p>接下来，我们添加一个检查来验证请求的类型。如果方法与<code>GET</code>不对应，服务器返回一个新的错误。当两个检查都通过时，服务器返回其成功响应<code>"Hello!"</code>。</p>
<p>我们需要做的最后一件事是修改我们的<code>main()</code>函数中的<code>handleFunc</code>函数，以接受上面的<code>helloHandler</code>函数。</p>
<pre>http.HandleFunc("/hello", helloHandler)
</pre>
<p>下面是你的<code>server.go</code>文件的完整代码。</p>
<pre>package main


import (
    "fmt"
    "log"
    "net/http"
)

func helloHandler(w http.ResponseWriter, r *http.Request) {
    if r.URL.Path != "/hello" {
        http.Error(w, "404 not found.", http.StatusNotFound)
        return
    }

    if r.Method != "GET" {
        http.Error(w, "Method is not supported.", http.StatusNotFound)
        return
    }


    fmt.Fprintf(w, "Hello!")
}


func main() {
    http.HandleFunc("/hello", helloHandler) // Update this line of code


    fmt.Printf("Starting server at port 8080\n")
    if err := http.ListenAndServe(":8080", nil); err != nil {
        log.Fatal(err)
    }
}
</pre>
<p>接下来，我们将使用<code>go run server.go</code>启动Go web服务器。您可以通过使用诸如<a href="https://www.postman.com/" target="_blank" rel="noopener noreferrer">邮递员</a>或<a href="https://curl.haxx.se/docs/httpscripting.html" target="_blank" rel="noopener noreferrer"> cURL </a>之类的工具向<code><a href="http://localhost:8080/hello" rel="nofollow">http://localhost:8080/hello</a></code>发送POST请求来测试您的安全性。</p>
<h2>启动静态web服务器</h2>
<p>在这一步中，我们将创建一个简单的文件服务器来托管静态文件。这将是对web服务器的一个非常简单的添加。</p>
<p>为了确保我们在web服务器上提供内容，让我们修改位于<code>static</code>文件夹中的<code>index.html</code>文件。为了简单起见，只需在文件中添加一个标题“T2”如果您愿意，您可以添加更多的文件或样式文件，使您的web服务器看起来更好一些。</p>
<pre>&lt;html&gt;
  &lt;head&gt;
    &lt;title&gt;Static Website&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;h2&gt;Static Website&lt;/h2&gt;
  &lt;/body&gt;
&lt;/html&gt;
</pre>
<p>为了服务于<code>static</code>文件夹，您必须向<code>server.go</code>添加两行代码。第一行代码使用<code>FileServer</code>函数创建文件服务器对象。这个函数接受一个<code>http.Dir</code>类型的路径。因此，我们必须将字符串路径<code>“./static”</code>转换为<code>http.Dir</code>路径类型。</p>
<p>不要忘记指定<code>Handle</code>路由，它接受路径和文件服务器。该函数的作用方式与<code>HandleFunc</code>函数相同，除了<a href="https://www.reddit.com/r/golang/comments/589wf4/whats_the_difference_between_httphandlefunc_and/" target="_blank" rel="noopener noreferrer">和</a>有一些小的不同。有关<a href="https://golang.org/pkg/net/http/#FileServer" target="_blank" rel="noopener noreferrer"> <code>FileServer</code>对象</a>的更多信息，请查看<a href="https://golang.org/pkg/net/http/#FileServer" target="_blank" rel="noopener noreferrer">文档</a>。</p>
<pre>func main() {
    fileServer := http.FileServer(http.Dir("./static")) // New code
    http.Handle("/", fileServer) // New code
    http.HandleFunc("/hello", helloHandler)


    fmt.Printf("Starting server at port 8080\n")
    if err := http.ListenAndServe(":8080", nil); err != nil {
        log.Fatal(err)
    }
}
</pre>
<p>是时候试试代码了。用<code>go run server.go</code>启动服务器并访问<code><a href="http://localhost:8080/" rel="nofollow">http://localhost:8080/</a></code>。你应该看到“<code>Static Website</code>”的标题。</p>
<h2>接受表单提交发布请求</h2>
<p>最后，web服务器必须响应表单提交。</p>
<p>让我们向<code>static</code>文件夹中的<code>form.html</code>文件添加一些内容。请注意，表单操作被发送到<code>/form</code>。这意味着表单中的POST请求将被发送到<code><a href="http://localhost:8080/form" rel="nofollow">http://localhost:8080/form</a></code>。表单本身要求输入两个变量:<code>name</code>和<code>address</code>。</p>
<pre>&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
  &lt;meta charset="UTF-8" /&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;div&gt;
  &lt;form method="POST" action="/form"&gt;     
      &lt;label&gt;Name&lt;/label&gt;&lt;input name="name" type="text" value="" /&gt;
      &lt;label&gt;Address&lt;/label&gt;&lt;input name="address" type="text" value="" /&gt;
      &lt;input type="submit" value="submit" /&gt;
  &lt;/form&gt;
&lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;
</pre>
<p>下一步是创建处理程序来接受<code>/form</code>请求。<code>form.html</code>文件已经通过文件服务器提供，并且可以通过<code><a href="http://localhost:8080/form.html" rel="nofollow">http://localhost:8080/form.html</a></code>访问。</p>
<p>首先，该函数必须调用<code>ParseForm()</code>来解析原始查询并更新<code>r.PostForm</code>和<code>r.Form</code>。这将允许我们通过<code>r.FormValue</code>方法访问<code>name</code>和<code>address</code>值。</p>
<p>在函数结束时，我们使用<code>fmt.Fprintf</code>将两个值都写入<code>ResponseWriter</code>。</p>
<pre>func formHandler(w http.ResponseWriter, r *http.Request) {
    if err := r.ParseForm(); err != nil {
        fmt.Fprintf(w, "ParseForm() err: %v", err)
        return
    }
    fmt.Fprintf(w, "POST request successful")
    name := r.FormValue("name")
    address := r.FormValue("address")

    fmt.Fprintf(w, "Name = %s\n", name)
    fmt.Fprintf(w, "Address = %s\n", address)
}
</pre>
<p>不要忘记给<code>main()</code>函数添加新的表单处理程序路径。</p>
<pre>http.HandleFunc("/form", formHandler)
</pre>
<p>现在，完整的代码如下所示。</p>
<pre>package main


import (
    "fmt"
    "log"
    "net/http"
)

func formHandler(w http.ResponseWriter, r *http.Request) {
    if err := r.ParseForm(); err != nil {
        fmt.Fprintf(w, "ParseForm() err: %v", err)
        return
    }
    fmt.Fprintf(w, "POST request successful")
    name := r.FormValue("name")
    address := r.FormValue("address")
    fmt.Fprintf(w, "Name = %s\n", name)
    fmt.Fprintf(w, "Address = %s\n", address)
}

func helloHandler(w http.ResponseWriter, r *http.Request) {
    if r.URL.Path != "/hello" {
        http.Error(w, "404 not found.", http.StatusNotFound)
        return
    }

    if r.Method != "GET" {
        http.Error(w, "Method is not supported.", http.StatusNotFound)
        return
    }


    fmt.Fprintf(w, "Hello!")
}


func main() {
    fileServer := http.FileServer(http.Dir("./static"))
    http.Handle("/", fileServer)
    http.HandleFunc("/form", formHandler)
    http.HandleFunc("/hello", helloHandler)


    fmt.Printf("Starting server at port 8080\n")
    if err := http.ListenAndServe(":8080", nil); err != nil {
        log.Fatal(err)
    }
}
</pre>
<h3>试用表单处理程序</h3>
<p>我们可以通过用<code>go run server.go</code>启动服务器来测试表单。服务器启动时，访问<code><a href="http://localhost:8080/form.html" rel="nofollow">http://localhost:8080/form.html</a></code>。您应该看到两个输入字段和一个提交按钮。</p>
<p><img data-attachment-id="20314" data-permalink="https://blog.logrocket.com/creating-a-web-server-with-golang/form-handler/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/06/form-handler.png" data-orig-size="720,86" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Form handler" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/06/form-handler-300x36.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/06/form-handler.png" decoding="async" class="aligncenter size-full wp-image-20314 jetpack-lazy-image" src="../Images/99e686ee0ea05b0d9be8831b67ec52b0.png" alt="Form Handler" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2020/06/form-handler.png 720w, https://blog.logrocket.com/wp-content/uploads/2020/06/form-handler-300x36.png 300w" data-lazy-sizes="(max-width: 720px) 100vw, 720px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2020/06/form-handler.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/06/form-handler.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="20314" data-permalink="https://blog.logrocket.com/creating-a-web-server-with-golang/form-handler/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/06/form-handler.png" data-orig-size="720,86" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Form handler" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/06/form-handler-300x36.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/06/form-handler.png" decoding="async" loading="lazy" class="aligncenter size-full wp-image-20314" src="../Images/99e686ee0ea05b0d9be8831b67ec52b0.png" alt="Form Handler" srcset="https://blog.logrocket.com/wp-content/uploads/2020/06/form-handler.png 720w, https://blog.logrocket.com/wp-content/uploads/2020/06/form-handler-300x36.png 300w" sizes="(max-width: 720px) 100vw, 720px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/06/form-handler.png"/></noscript>
<p>填完表格后，点击<code>submit</code>按钮。服务器应该处理您的POST请求，并在<code><a href="http://localhost:8080/form" rel="nofollow">http://localhost:8080/form</a></code>响应页面上显示结果，如下图所示。</p>
<p><img data-attachment-id="20315" data-permalink="https://blog.logrocket.com/creating-a-web-server-with-golang/form-result/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/06/form-result.png" data-orig-size="720,86" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Form result" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/06/form-result-300x36.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/06/form-result.png" decoding="async" class="aligncenter size-full wp-image-20315 jetpack-lazy-image" src="../Images/b2ca8ad687ac2249032bbf1c3da87d44.png" alt="Form Result" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2020/06/form-result.png 720w, https://blog.logrocket.com/wp-content/uploads/2020/06/form-result-300x36.png 300w" data-lazy-sizes="(max-width: 720px) 100vw, 720px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2020/06/form-result.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/06/form-result.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="20315" data-permalink="https://blog.logrocket.com/creating-a-web-server-with-golang/form-result/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/06/form-result.png" data-orig-size="720,86" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Form result" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/06/form-result-300x36.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/06/form-result.png" decoding="async" loading="lazy" class="aligncenter size-full wp-image-20315" src="../Images/b2ca8ad687ac2249032bbf1c3da87d44.png" alt="Form Result" srcset="https://blog.logrocket.com/wp-content/uploads/2020/06/form-result.png 720w, https://blog.logrocket.com/wp-content/uploads/2020/06/form-result-300x36.png 300w" sizes="(max-width: 720px) 100vw, 720px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/06/form-result.png"/></noscript>
<p>如果你看到上面的结果，你已经成功地创建了你的第一个Golang网络和文件服务器。恭喜你！</p>
<p>如果您想进一步探索Golang web服务器，Golang <a href="https://golang.org/pkg/net/http/#pkg-constants" target="_blank" rel="noopener noreferrer"> HTTP包文档</a>中有很多很好的例子。这篇关于<a href="https://golang.org/doc/articles/wiki/" target="_blank" rel="noopener noreferrer">用Go </a>编写web应用的教程是另一个很好的资源，它涵盖了大部分基础知识。</p><div class="code-block code-block-2">
<div class="blog-plug base-cta"><h2>使用<a class="signup" href="https://lp.logrocket.com/blg/signup" target="_blank" rel="noopener noreferrer"> LogRocket </a>消除传统错误报告的干扰</h2>
<a href="https://lp.logrocket.com/blg/signup" class="signup" target="_blank" rel="noopener noreferrer"><img class="alignnone size-full wp-image-46 jetpack-lazy-image" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/><noscript><img data-lazy-fallback="1" class="alignnone size-full wp-image-46" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/></noscript></a>
<p><a href="https://lp.logrocket.com/blg/signup" target="_blank" rel="noopener noreferrer"> LogRocket </a>是一个数字体验分析解决方案，它可以保护您免受数百个假阳性错误警报的影响，只针对几个真正重要的项目。LogRocket会告诉您应用程序中实际影响用户的最具影响力的bug和UX问题。</p>
<p>然后，使用具有深层技术遥测的会话重放来确切地查看用户看到了什么以及是什么导致了问题，就像你在他们身后看一样。</p>
<p>LogRocket自动聚合客户端错误、JS异常、前端性能指标和用户交互。然后LogRocket使用机器学习来告诉你哪些问题正在影响大多数用户，并提供你需要修复它的上下文。</p>
<p>关注重要的bug—<a class="signup" href="https://lp.logrocket.com/blg/signup-issue-free" target="_blank" rel="noopener noreferrer">今天就试试LogRocket】。</a></p></div></div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
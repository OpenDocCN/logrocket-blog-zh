<html>
<head>
<title>3 tips for implementing GraphQL in Golang - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>在Golang - LogRocket博客中实现GraphQL的3个技巧</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/3-tips-for-implementing-graphql-in-golang/#0001-01-01">https://blog.logrocket.com/3-tips-for-implementing-graphql-in-golang/#0001-01-01</a></blockquote><div><article class="article-post">
<h2>GraphQL是什么？</h2>
<p>后端技术专家通常会说GraphQL是继REST APIs之后的“闪亮的新成员”。最初由脸书开发，作为一个强大的内部使用的数据获取API，今天它每天支持数十亿次API调用。</p>
<p>官方文档将GraphQL定义为API的查询语言，它提供了API中数据的360度视图。但是来自自由代码阵营的定义说:</p>
<p>GraphQL是一种描述如何请求数据的语法，通常用于将数据从服务器加载到客户端。它让客户在请求中准确指定需要什么数据，从而更容易从多个来源中选择数据。”</p>
<h3>先决条件</h3>
<p>本教程将重点介绍用Golang实现GraphQL时需要注意的一些要点。为了跟进，强烈建议您具备以下工作知识:</p>

<h3>让我们复习一下GraphQL</h3>
<p>在任何讨论GraphQL的场景中，有些关键字会比其他关键字使用得更频繁。因此，有必要提醒我们自己其中的一些话:</p>
<p><strong> GraphQL类型</strong>:这些是GraphQL模式定义的最基本组成部分。它们是JSON字段，表示可以从服务中获取的对象种类。查看这个<a href="https://blog.logrocket.com/defining-types-for-your-graphql-api/" target="_blank" rel="noopener noreferrer">教程</a>来详细了解GraphQL类型。</p>
<p>作为一个例子，这里有一个作者的样本类型定义，它有三个字段:<code>name</code>、<code>id</code>和<code>book</code>:</p>
<pre>type author {
  name: String! //the `!` sign shows it’s required
  id: ID!
  book: String!
}</pre>
<p><strong> GraphQL查询</strong> : GraphQL查询是从GraphQL服务器请求或获取数据的一种方式。查询的结构将决定数据是取多还是取少。这个<a href="https://blog.logrocket.com/graphql-queries-in-simple-terms/" target="_blank" rel="noopener noreferrer">教程</a>详细解释了查询。</p>
<p>下面是一个关于作者姓名的示例查询，遵循我们上面的类型定义:</p>
<pre>query {                     
  authors {                 
    name      
  }
}</pre>
<p><strong> GraphQL模式</strong>:模式就像地图。它们通过描述数据在服务器中的关系来帮助我们理解数据。这有助于客户机在试图访问数据时知道如何组织它们的请求。它们是用SDLs编写的，即模式定义语言。</p>
<p><strong>解析器</strong>:解析器在服务器中寻找请求的数据。它们是特定于字段的函数。这是GraphQL用于为每个查询请求返回数据的唯一机制。</p>
<p><strong> GraphQL突变</strong>:突变用于创建和修改GraphQL中的对象，类似于REST APIs中的PUT和POST。它们遵循与查询类似的语法，除了它们需要以关键字<code>mutation</code>开始。</p>
<p><strong> GraphQL订阅</strong>:这是一个允许服务器为其配置的每个特定事件向其客户端发送数据的特性。为此，服务器与订阅它的客户机保持稳定的连接</p>
<h2>为什么用Golang的GraphQL？</h2>
<p>Go编程语言，也称为Golang，是一种通用编程语言，最初由Google设计。Golang因其简单性、并发性和快速性能以及许多其他漂亮的特性而名列前茅。因此，它仍然是实现GraphQL时的首选之一。</p>
<p>随着许多人开始意识到这对组合(GraphQL和Golang)的潜力，多年来软件工程师开始构建库来无缝集成GraphQL和Golang。</p>
<p>下面是一些使实现变得流畅的库:</p>
<ul>
<li><a href="https://github.com/graph-gophers/graphql-go" target="_blank" rel="noopener noreferrer"> Graph-gophers/graphql-go </a>:这提供了解析graphql模式语言的支持，同时在编译时给出解析器信息，而不必等到运行时才发现模式和解析器的问题。</li>
<li>GraphQL-go/graphql :它像其他库一样支持查询、突变和订阅。它还模拟了<a href="https://github.com/graphql/graphql-js" target="_blank" rel="noopener noreferrer"> GraphQL-js </a>库的正式实现</li>
<li>Gqlgen :这优先考虑类型安全，并且基于模式优先的方法。</li>
</ul>
<p>在本教程中，我们不会关注这些库的实现。然而，这些库中的每一个都有一个<code>examples</code>文件夹，您可以导航到这个文件夹，以便直接看到这些库是如何实现的。</p>
<h3>灯泡时刻来了</h3>
<p>让我们探讨一下GraphQL与Golang集成时可能遇到的一些场景，以及解决方案是什么。</p>
<h3>技巧#1:模式同质性</h3>
<p><code>graphql-go/graphql</code>是Golang中GraphQL的全功能实现，支持查询、突变和订阅，以及许多其他功能。</p>
<p>虽然这个库利用其他库来帮助您构建生产就绪的GraphQL服务器，但它是GraphQL.js的官方参考实现。换句话说，它是GraphQL.js库的Golang版本。</p>
<p>其与GraphQL.js几乎相同的API的优势使得阅读另一个为Node.js/JavaScript,编写的GraphQL模式变得如此容易，并且您仍然能够为Golang重写它。让我们来看看:</p>
<p><strong>用<code>graphql-go</code> </strong>为Golang定义GraphQL模式</p>
<p>我们导入<code>graphql-go</code>包，并用一个<code>hello</code>字段定义名为<code>BaseQuery</code>的GraphQL对象类型来创建模式。</p>
<pre>package main
 
import (
   "log"
   "github.com/graphql-go/graphql"
)
 
var queryType = graphql.NewObject(graphql.ObjectConfig{
   Name: "BaseQuery",
   Fields: graphql.Fields{
       "hello": &amp;graphql.Field{
           Type: graphql.String,
           Resolve: func(p types.ResolveParams) interface{} {
               return "World!"
           },
       },
   },
})
 
var Schema, err = graphql.NewSchema(graphql.SchemaConfig{
   Query: queryType,
})
if err != nil {
   log.Fatalf("failed to create new schema, error: %v", err)
}</pre>
<p>在模式创建之后创建GraphQL服务器遵循官方<code>graphql-go</code>文档<a href="https://github.com/graphql-go/graphql" target="_blank" rel="noopener noreferrer">这里</a>中强调的正常步骤。</p>
<p><strong>用GraphQL.js为JavaScript定义Graphql模式</strong></p>
<p>从下面的代码片段中，我们需要GraphQL包，并用一个<code>hello</code>字段定义名为<code>BaseQuery</code>的GraphQL对象类型。这与上面模式中强调的过程相似。</p>
<pre>var graphql = require('graphql');
 
var queryType = new graphql.GraphQLObjectType({
   name: 'BaseQuery',
   fields: {
       hello: {
           type: graphql.GraphQLString,
           resolve: function () {
               return 'World!';
           }
       }
   }
});
 
var schema = new graphql.GraphQLSchema({
   query: queryType
});</pre>
<p>仔细观察上面的两种表示，我们可以得出结论，无论您熟悉哪种编程语言，使用<code>graphql-go</code>库在Golang中实现GraphQL都是轻而易举的事情。</p>
<p>这是因为<code>graphql-go</code>库非常接近GraphQL.js的官方参考实现，这是我们选择的事实上的库。因此，它为GraphQL.js库提供了几乎相同的API。</p>
<h3>技巧2:解决n+1问题</h3>
<p>与每个API端点使用一个解析器的REST APIs不同，GraphQL为每个字段执行一个解析器。这意味着每个请求可能有太多额外的解析器，尤其是对于嵌套数据。这就是n+1问题。</p>
<p>下面是一个示例查询来进一步支持这一点:</p>
<pre>query {                     
 authors {            # fetches authors - query 1
   name      
   book {             # fetches books for each author (N queries for N authors)
     title
   }
 }
}                     # N+1 round trips</pre>
<p>以下是查询的响应:</p>
<pre>{
 "writers": [{
   "name": "Tom Wolfe",
   "book": {
     "title": "The Bonfire of the Vanities"
   }
 }, {
   "name": "ALice Walker",
   "book": {
     "title": "The Color Purple"
   }    
 }]
}</pre>
<p>上面的例子可能没有显示这种情况升级为问题的速度有多快。但是假设我们需要获取100个作者的数据，解析器要进行100+1次旅行来获取响应。同时，这可以在两次旅行中完成；即请求和响应。</p>
<p>解决这个问题的方法是批处理。</p><div class="code-block code-block-54">
<hr/>
<h3>更多来自LogRocket的精彩文章:</h3>

<hr/></div>
<p><strong>批处理</strong>是数据加载器的主要特性。<a href="https://github.com/graphql/dataloader" target="_blank" rel="noopener noreferrer">数据加载器</a>最初是由脸书在2010年为GraphQL.js开发的，用作应用程序数据提取层的一部分。它通过批处理和缓存在远程数据源上提供了一个简化且一致的API。然而，已经为<code>graphql-go</code>开发了其他几个数据加载器库，例如:</p>
<ul>
<li>graph-gophers/dataloader :这是官方facebook <a href="https://github.com/graphql/dataloader" target="_blank" rel="noopener noreferrer"> dataloader </a>(用JavaScript编写)在Golang中的复制实现</li>
<li>来自<a href="https://github.com/99designs/gqlgen" target="_blank" rel="noopener noreferrer"> gqlgen </a>作者的<a href="https://github.com/vektah/dataloaden" target="_blank" rel="noopener noreferrer"> Dataloaden </a>:这在Golang中生成类型安全的数据加载器，与<code>gglgen</code>库一起使用，用于区分类型安全的优先级。它也受到官方数据加载器库的启发</li>
</ul>
<p>和许多其他人。</p>
<p>数据加载器(不考虑库)通过允许解析器请求数据并返回对数据的承诺，而不是立即返回所请求的确切字段，来解决n+1问题。然后，对来自请求的所有响应进行批处理，并立即做出响应，因此有两个行程——请求和响应。</p>
<p>然而，让我们更详细地看看<code>graphql-gophers/dataloader</code>库。</p>
<p>这里有一个示例实现，演示了如何在没有缓存的情况下使用这个库。更多的例子，请点击库<a href="https://github.com/graph-gophers/dataloader/tree/master/example" target="_blank" rel="noopener noreferrer">的例子目录这里</a>。</p>
<pre>package no_cache_test
 
import (
 "context"
 "fmt"
 
 dataloader "github.com/graph-gophers/dataloader/v6"
)
 
func ExampleNoCache() {
 // go-cache will automaticlly cleanup expired items on given diration
 cache := &amp;dataloader.NoCache{}
 loader := dataloader.NewBatchedLoader(batchFunc, dataloader.WithCache(cache))
 
 result, err := loader.Load(context.TODO(), dataloader.StringKey("some key"))()
 if err != nil {
   // handle error
 }
 
 fmt.Printf("identity: %s", result)
 // Output: identity: some key
}
 
func batchFunc(_ context.Context, keys dataloader.Keys) []*dataloader.Result {
 var results []*dataloader.Result
 // do some pretend work to resolve keys
 for _, key := range keys {
   results = append(results, &amp;dataloader.Result{Data: key.String()})
 }
 return results
}</pre>
<h3>技巧#3:客户机-服务器数据模式不匹配</h3>
<p>通常，从头开始编写一个GraphQL后端需要复制大量相似的代码(模式)，例如不同但相似的数据库和API端点模式。</p>
<p>这是因为不同的模式影响了文档的存储方式。</p>
<p>例如:对来自<code>database</code>的作者的查询将返回一个<code>authorID</code>属性，但是对直接来自<code>server</code>的作者的相同查询将返回<code>author</code>属性。这使得很难在客户机和服务器之间共享代码来简化代码库。</p>
<pre>const fetchBookTitleClient = author =&gt; {
   return author.book.title
}
 
const fetchBookTitleServer = author =&gt; {
   const authorDeets = Books.findOne(author.bookId)
   return authorDeets.title
}</pre>
<p><strong>解决这个问题的方法是服务器-服务器查询</strong></p>
<p>回想起来，这是通过将GraphQL模式添加到GraphQL函数中实现的，如下所示:</p>
<pre>graphql(
 schema: GraphQLSchema,
 requestString: string,
 rootValue?: ?any,
 contextValue?: ?any,
 variableValues?: ?{[key: string]: any},
 operationName?: ?string
): Promise&lt;GraphQLResult&gt;</pre>
<p>但是在实现中，在我的代码中，我是这样运行服务器到服务器的查询的:</p>
<pre>const result = await graphql(executableSchema, query, {}, context, variables);</pre>
<p>这允许在不牺牲性能的情况下极大地简化代码。</p>
<h2>结论</h2>
<p>正如我们在本教程中所看到的，GraphQL不仅仅是一种API查询语言。它有可能在数据和API查询方面彻底改变游戏。</p>
<p>有了这样的潜力，GraphQL的全部优势必须由像Golang这样的编程语言来利用。</p>
<p>Go编程语言由于其并发性、简单性和快速的性能而轻而易举地名列榜首。</p>
<p>我希望你喜欢阅读这篇关于在Golang中实现GraphQL时遇到的问题的文章。请随意留下任何问题或反馈。</p><div class="code-block code-block-24">
<div class="blog-plug inline-plug graphql-plug"><h2>监控生产中失败和缓慢的GraphQL请求</h2><p>虽然GraphQL有一些调试请求和响应的特性，但确保GraphQL可靠地为您的生产应用程序提供资源是一件比较困难的事情。如果您对确保对后端或第三方服务的网络请求成功感兴趣，</p><a href="https://lp.logrocket.com/blg/graphql-signup" target="_blank">try LogRocket</a><p>.</p><a class="signup" href="https://lp.logrocket.com/blg/graphql-signup" target="_blank" rel="noopener noreferrer"><img src="../Images/432a3823c85b3fb72a206e6236a29f48.png" data-lazy-src="https://files.readme.io/69aa835-Image_2019-11-09_at_1.28.05_PM.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" class=" jetpack-lazy-image" data-original-src="https://files.readme.io/69aa835-Image_2019-11-09_at_1.28.05_PM.png"/><noscript><img data-lazy-fallback="1" src="../Images/432a3823c85b3fb72a206e6236a29f48.png" data-original-src="https://files.readme.io/69aa835-Image_2019-11-09_at_1.28.05_PM.png"/></noscript><img class="alignnone size-full wp-image-46 jetpack-lazy-image" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/><noscript><img data-lazy-fallback="1" class="alignnone size-full wp-image-46" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/></noscript></a><a href="https://lp.logrocket.com/blg/graphql-signup" target="_blank" rel="noopener noreferrer">https://logrocket.com/signup/</a><p>LogRocket 就像是网络和移动应用的DVR，记录下你网站上发生的每一件事。您可以汇总并报告有问题的GraphQL请求，以快速了解根本原因，而不是猜测问题发生的原因。此外，您可以跟踪Apollo客户机状态并检查GraphQL查询的键值对。</p><p>LogRocket检测您的应用程序以记录基线性能计时，如页面加载时间、到达第一个字节的时间、慢速网络请求，还记录Redux、NgRx和Vuex操作/状态。</p><a class="signup" href="https://lp.logrocket.com/blg/graphql-signup" target="_blank" rel="noopener noreferrer">Start monitoring for free</a><p>.</p></div>


</div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
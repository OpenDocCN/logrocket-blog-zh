<html>
<head>
<title>CSS utility classes: Your library of extendable styles - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>CSS实用程序类:你的可扩展样式库</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/css-utility-classes-library-extendable-styles/#0001-01-01">https://blog.logrocket.com/css-utility-classes-library-extendable-styles/#0001-01-01</a></blockquote><div><article class="article-post">
<p>使用CSS实用程序类进行构建对于生产力和组织来说是一个不可思议的提升。它允许你定义一个支持你所有风格的<code>property: value</code>对库，从一个目录管理。</p>
<p>在本文中，我们将讨论:</p>
<ol>
<li>什么是CSS实用程序类以及为什么应该使用它们</li>
<li>流行框架中的快速演示</li>
<li>如何构建自己的超级实用程序库</li>
</ol>
<h2>什么是实用程序类？</h2>
<p>实用程序类是自描述的、单一用途的CSS类:</p>
<pre>.flex {
  display: flex;
}</pre>
<p>开发者使用这些函数类来构建<em>而不需要</em>编写额外的CSS，因为如果样式在库中，你可以一遍又一遍地使用它…</p>
<pre>&lt;aside class="<strong>flex</strong> flex-column bg-black"&gt;
  &lt;div class="<strong>flex</strong> align-center justify-center"&gt;
    &lt;img src="#" /&gt;
  &lt;/div&gt;

  &lt;div class="<strong>flex</strong> flex-column"&gt;
    &lt;h1&gt;Jamie Thrift&lt;/h1&gt;
    &lt;p class="<strong>flex</strong> align-center"&gt;
      &lt;svg&gt;…&lt;/svg&gt;
      Head of HR
    &lt;/p&gt;
  &lt;/div&gt;
&lt;/aside&gt;</pre>
<p>这些类确切地告诉我们它们做什么，因此开发人员可以<em>可视化</em>这些元素将如何布局，而不需要浏览底层CSS。</p>
<p><img data-attachment-id="8627" data-permalink="https://blog.logrocket.com/css-utility-classes-library-extendable-styles/example-gif-1/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2019/10/example-gif-1.gif" data-orig-size="730,410" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="CSS utility class example gif" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2019/10/example-gif-1-300x168.gif" data-large-file="https://blog.logrocket.com/wp-content/uploads/2019/10/example-gif-1.gif" decoding="async" class="aligncenter size-full wp-image-8627 jetpack-lazy-image" src="../Images/76c07bb52e813ac0a9d047086cf680a6.png" alt="CSS Utility Class Example GIF" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2019/10/example-gif-1.gif?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/10/example-gif-1.gif"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="8627" data-permalink="https://blog.logrocket.com/css-utility-classes-library-extendable-styles/example-gif-1/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2019/10/example-gif-1.gif" data-orig-size="730,410" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="CSS utility class example gif" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2019/10/example-gif-1-300x168.gif" data-large-file="https://blog.logrocket.com/wp-content/uploads/2019/10/example-gif-1.gif" decoding="async" loading="lazy" class="aligncenter size-full wp-image-8627" src="../Images/76c07bb52e813ac0a9d047086cf680a6.png" alt="CSS Utility Class Example GIF" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/10/example-gif-1.gif"/></noscript>
<p> </p>
<h3>实用程序类是如何放在一起的？</h3>
<p>工具类是作为<strong>框架</strong>的一部分为你生成的。一些流行的工具和框架提供了<em>许多</em>现成的风格，所以你可以只使用<code>class="padding-10"</code>并且确信这种风格已经存在。其他人给你工具来定义<em>你的项目需要的工具。</em></p>
<p>通过在一个地方配置你的样式库，你可以避免在你的代码库中乱放离群值，也不会忘记什么是新的CSS，什么是已经在其他地方写好的。</p>
<p>使用实用程序极大地增强了项目的组织性，并提高了开发人员和最终用户的可预测性和一致性。</p>
<h3>… <em>就像</em>一个设计系统！</h3>
<p>这种思维模式也体现在UI设计阵营中，在那里有一种定义、重用和维护中央样式库的紧急实践。这些样式通常可以在<a href="https://blog.logrocket.com/building-design-system-grommet-storybook/">设计系统</a>的<a href="http://styleguides.io/">样式指南</a>部分找到。</p>
<p>样式指南主要包括颜色、排版、间距、网格和图标的基础。这些低层次的基本原则是一组规则，设计师遵循这些规则来创建一致的工作。</p>
<p><img data-attachment-id="8628" data-permalink="https://blog.logrocket.com/css-utility-classes-library-extendable-styles/styleguide-components/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2019/10/styleguide-components.png" data-orig-size="730,410" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Styleguide components example" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2019/10/styleguide-components-300x168.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2019/10/styleguide-components.png" decoding="async" class="aligncenter size-full wp-image-8628 jetpack-lazy-image" src="../Images/6cb47d975c3800b5ca50e3bde59f2df7.png" alt="Styleguide Components Example" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2019/10/styleguide-components.png 730w, https://blog.logrocket.com/wp-content/uploads/2019/10/styleguide-components-300x168.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2019/10/styleguide-components.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/10/styleguide-components.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="8628" data-permalink="https://blog.logrocket.com/css-utility-classes-library-extendable-styles/styleguide-components/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2019/10/styleguide-components.png" data-orig-size="730,410" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Styleguide components example" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2019/10/styleguide-components-300x168.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2019/10/styleguide-components.png" decoding="async" loading="lazy" class="aligncenter size-full wp-image-8628" src="../Images/6cb47d975c3800b5ca50e3bde59f2df7.png" alt="Styleguide Components Example" srcset="https://blog.logrocket.com/wp-content/uploads/2019/10/styleguide-components.png 730w, https://blog.logrocket.com/wp-content/uploads/2019/10/styleguide-components-300x168.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/10/styleguide-components.png"/></noscript>
<p>实用优先的CSS框架</p>
<h2>这些年来，有相当多的框架、库和工具在这一领域广受欢迎。这里是一些知名选项发布时的历史快速回顾，以及一些采用实用优先方法的开发人员的案例研究。</h2>
<p>2013</p>
<h3><strong>标语:</strong>“无副作用的快速模块化CSS”</h3>

<ul>
<li><strong>GitHub:</strong><a href="https://github.com/basscss/basscss" target="_blank" rel="noopener noreferrer">bascss/bascss</a></li>
<li>2014</li>
</ul>


<h3>2015</h3>


<h3>2017</h3>


<h3>2018</h3>


<h3>  </h3>


<p>将实用程序类付诸实践</p>
<h2>让我们构建一些简单的东西来看看这些实用程序类是如何工作的。这里，我们将复制您可能从<a href="https://stackoverflow.com/">堆栈溢出</a>中认出的author组件。</h2>
<p><img data-attachment-id="8631" data-permalink="https://blog.logrocket.com/css-utility-classes-library-extendable-styles/stack-overflow-author-component-example/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2019/10/stack-overflow-author-component-example.png" data-orig-size="195,91" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Stack Overflow author component" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2019/10/stack-overflow-author-component-example.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2019/10/stack-overflow-author-component-example.png" decoding="async" class="aligncenter size-full wp-image-8631 jetpack-lazy-image" src="../Images/00a442715c57982ee12ddb7b15581f49.png" alt="Stack Overflow Author Component Example" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2019/10/stack-overflow-author-component-example.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/10/stack-overflow-author-component-example.png"/></p>
<p>在这个例子中，我将使用来自<a href="https://tailwindcss.com/"> Tailwind CSS </a>的语法。</p><noscript><img data-lazy-fallback="1" data-attachment-id="8631" data-permalink="https://blog.logrocket.com/css-utility-classes-library-extendable-styles/stack-overflow-author-component-example/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2019/10/stack-overflow-author-component-example.png" data-orig-size="195,91" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Stack Overflow author component" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2019/10/stack-overflow-author-component-example.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2019/10/stack-overflow-author-component-example.png" decoding="async" loading="lazy" class="aligncenter size-full wp-image-8631" src="../Images/00a442715c57982ee12ddb7b15581f49.png" alt="Stack Overflow Author Component Example" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/10/stack-overflow-author-component-example.png"/></noscript>
<p>没有描述</p>
<blockquote class="embedly-card" data-card-controls="1" data-card-align="center" data-card-theme="light">

<p>No Description</p>
</blockquote>
<p>没什么可命名的</p>
<pre>&lt;div class="p-3"&gt;
  &lt;p class="text-gray-600"&gt;answered &lt;span title="2017-08-07 08:46:14Z"&gt;Aug 7 '17 at 8:46&lt;/span&gt;&lt;/p&gt;

  &lt;figure class="flex items-center mt-3"&gt;
    &lt;img class="w-10 h-10" src="https://assets-us-01.kc-usercontent.com/525f1d2d-c241-00a9-f169-8b2061aeb3da/e53a3a2b-f539-4ab9-a3ec-7cf7a2b6a664/aleksandra_zamojc.png" alt="Photo of Konrad Albrecht" /&gt;
    &lt;figcaption class="ml-2"&gt;
      &lt;p&gt;
        &lt;a class="text-blue-600" href="/user"&gt;Konrad Albrecht&lt;/a&gt;
      &lt;/p&gt;
      &lt;p class="flex items-center mt-1"&gt;
        &lt;span class="font-bold text-gray-800" title="reputation score"&gt;138&lt;/span&gt;
        &lt;span class="rounded-full w-2 h-2 bg-orange-400 ml-2"&gt;&lt;/span&gt;
        &lt;span class="ml-1 text-gray-600" title="badge count"&gt;10&lt;/span&gt;
      &lt;/p&gt;
    &lt;/figcaption&gt;
  &lt;/figure&gt;
&lt;/div&gt;</pre>
<h3>"一旦你给它起了名字，你就会爱上它。"</h3>
<blockquote><p>注意，这些标记都不要求我们给<em>命名任何东西</em>——因为<a href="https://seesparkbox.com/foundry/naming_css_stuff_is_really_hard">给东西命名很难</a>。我们不必致力于像<code>.user</code>或<code>.author</code>这样的结构……它允许我们更快地构建我们的组件，并留给我们更少的维护。如果我们稍后添加另一个包含作者的组件，我们不必重新考虑命名方案。</p></blockquote>
<p>可预测性</p>
<h3>说实话，在开始构建组件之前，我只快速浏览了一下<a href="https://tailwindcss.com/docs/">的Tailwind CSS文档</a>，并且我只需要查找两个我猜不到的类(<code>.rounded-full</code>和<code>items-center</code>)。</h3>
<p>这意味着构建一个组件可以发生在一个文件中，而不是在两个文件之间切换。</p>
<p><img data-attachment-id="8632" data-permalink="https://blog.logrocket.com/css-utility-classes-library-extendable-styles/component-flipping/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2019/10/component-flipping.gif" data-orig-size="730,410" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Component flipping" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2019/10/component-flipping-300x168.gif" data-large-file="https://blog.logrocket.com/wp-content/uploads/2019/10/component-flipping.gif" decoding="async" class="aligncenter size-full wp-image-8632 jetpack-lazy-image" src="../Images/9035269e8eb62dbe7f800bdd6172f340.png" alt="Component Flipping" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2019/10/component-flipping.gif?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/10/component-flipping.gif"/></p>
<p>潜在的不利因素是什么？</p><noscript><img data-lazy-fallback="1" data-attachment-id="8632" data-permalink="https://blog.logrocket.com/css-utility-classes-library-extendable-styles/component-flipping/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2019/10/component-flipping.gif" data-orig-size="730,410" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Component flipping" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2019/10/component-flipping-300x168.gif" data-large-file="https://blog.logrocket.com/wp-content/uploads/2019/10/component-flipping.gif" decoding="async" loading="lazy" class="aligncenter size-full wp-image-8632" src="../Images/9035269e8eb62dbe7f800bdd6172f340.png" alt="Component Flipping" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/10/component-flipping.gif"/></noscript>
<h1 id="whatarethepotentialdownsides">正如您在开发中采用的任何方法一样，总会有一些妥协。让我们探讨一下手头的一些复杂情况。</h1>
<p>类的长组合</p>
<h3>一行没有结尾、换行的文字很难解读。当我们编写普通的CSS时，我们有一些技术可以帮助我们扫描一组属性:</h3>
<p>每行一条规则</p>
<ul>
<li>刻痕</li>
<li>规则维护一个<a href="https://github.com/sds/scss-lint/blob/master/data/property-sort-orders/smacss.txt">属性排序顺序</a></li>
<li>断点可以嵌套在预处理/后处理中</li>
<li>当我们将这一长串样式重新放置到我们的标记中时，我们倾向于放弃上述内容，因为这会使我们的HTML变得非常冗长。这导致了非常长的类串，很难理解，甚至是lint。</li>
</ul>
<p>尝试在这里找到您想要调整的<strong>权重</strong>属性:</p>
<p>值得一提的是，这个示例甚至没有任何响应样式——如果要在一两个断点处更改属性，长度可能会增加一倍。</p>
<pre>&lt;a href="https://myurl.com/" class="bgcolor-blue <a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="4b292c662824272439662f2a392029273e2e0b23243d2e39">[email protected]</a> <a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="caa8ade7a9a5a6a5b8e7aeabb8a1a8a6bfaf8aaca5a9bfb9">[email protected]</a> radius-tlbr-3 radius-trbl-12 font-europa color-light-grey <a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="a3c0cccfccd18ed4cbcad7c6e3cbccd5c6d1">[email protected]</a> <a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="bdded2d1d2cf90cad5d4c9d8fddbd2dec8ce">[email protected]</a> weight-medium shadow-black-thin padv-3 padh-4 whitespace-nowrap size-6rem line-thin pos-relative <a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="3b4f544b16087b53544d5e49">[email protected]</a> <a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="a8dcc7d8859be8cec7cbdddb">[email protected]</a>"&gt;Incredible pace in this place&lt;/a&gt;</pre>
<p>文件大小管理</p>
<h3>如果我们全进去，一些框架为<em>的每个可能值</em>为<em>的每个属性</em>为每个断点和<em>每个状态</em>生成一个类。这是一个巨大的CSS垃圾箱，其中你可能只使用了1%。框架知道这一点，他们有自己的处理方法。</h3>
<p>Tailwind CSS (350kB minified)有一个关于<a href="https://tailwindcss.com/docs/controlling-file-size" target="_blank" rel="noopener noreferrer">控制文件大小</a>的章节，推荐设置<a href="https://www.purgecss.com/" target="_blank" rel="noopener noreferrer"> PurgeCSS </a>。</p>
<p>Purge将扫描你的项目文件，找到你让T2使用的类，并从你编译的CSS文件中删除其余的类。这意味着在你的构建中多了一个步骤，如果你的代码库相当大的话，甚至可能会延迟你的脚本运行。还可能有不准确的地方，你的编程语言模糊了你的类名(<code>class="bgcolor-${foo}"</code>)，这要担心。</p>
<p>复杂选择器</p>
<h3>CSS的许多最有用的快捷方式都可以在它强大的选择器中找到。例如，考虑一个当用户不与之交互时逐渐消失的表单部分:</h3>
<p>或者只是使用伪元素:</p>
<pre>.fieldset:not(:focus-within):not(:hover) {
  opacity: .5;
}</pre>
<p>或者甚至是像斑马条纹的表格行这样简单的东西:</p>
<pre>.title:after {
  position: absolute;
  bottom: -2px;
  left: 0;
  right: 0;
  border-bottom: 2px solid orange;
  content: '';
}</pre>
<p>要用(相当普遍！)这样的风格，您可能最终会在您的实用程序框架旁边维护一些定制的CSS，或者在iotaCSS 中使用<a href="https://www.iotacss.com/docs/components/" target="_blank" rel="noopener noreferrer">组件。</a></p>
<pre>.table-row:nth-child(odd) {
  background-color: grey;
}</pre>
<p>失去级联</p>
<h3>不仅如此，在布局元素时，能够使用级联瞄准也是一个巨大的时间节省——比如部署每个人都喜欢的<a href="https://alistapart.com/article/axiomatic-css-and-lobotomized-owls/" target="_blank" rel="noopener noreferrer">脑叶切除猫头鹰选择器</a>:</h3>
<p>我所见过的任何框架都没有默认提供这些节省时间的样式，这意味着您最终将在标记中添加更多的类来进行补偿。</p>
<pre>.margin-top-siblings-2 &gt; * + * {
  margin-top: 2rem;
}</pre>
<p>更多来自LogRocket的精彩文章:</p><div class="code-block code-block-54">
<hr/>
<h3>构建您自己的实用框架</h3>

<hr/></div>
<h2>在提供了关于实用程序类的故事的两个方面之后，我们肯定可以看到现有框架提供方式的改进空间。</h2>
<p>为了在SCSS建立我们自己的公用事业框架，我们将坚持以下原则:</p>
<p>只生成您需要的类</p>
<ul>
<li>减少编译CSS中的浪费</li>
<li>造型类型的自然分离</li>
<li>为了实现这一目标，我们将利用:</li>
</ul>
<p><code>%placeholders</code>和<code>@extend</code></p>
<ul>
<li>命名空间<a href="https://www.iotacss.com/docs/objects/" target="_blank" rel="noopener noreferrer">对象</a>和<a href="https://www.iotacss.com/docs/components/" target="_blank" rel="noopener noreferrer">组件</a> ( <code>.u-</code>、<code>.o-</code>、<code>.c-</code>)</li>
<li>循环和列表</li>
<li>为什么是命名空间？</li>
</ul>
<h3>通过为类类型使用一个小的名称空间，您就有了一种结构化的方式来指示一个类根据它的类型<em>做什么。</em>我们之前提到的大多数框架都不这么做，因为它们只是为了迎合<em>实用程序而编写的</em>。</h3>
<p>我们将在以下所有示例中使用名称空间。</p>
<p>定义样式的占位符</p>
<h3>占位符是SCSS制造的“幽灵”定义，用来定义一种风格。它们的独特之处在于，除非你在某处引用它们，否则它们不会编译T2。这就好像你定义了一个<code>$variable</code>但从未使用过它。</h3>
<p>因为占位符只有在我们需要的时候才会显示，所以我们也可以为每个断点和样式的状态变化创建一个占位符。</p>
<pre>// Define the placeholder…

%u-display-flex {
  display: flex;
}

// This will not compile, until…

.u-flex {
  @extend %u-display-flex;
}

// Now we have our utility class ready to use…

.u-flex {
  display: flex;
}</pre>
<p><code>@extend</code>应用我们的占位符</p>
<h3>定义了占位符后，我们现在可以决定如何使用它们。通过使用<code>@extend</code>(与<a href="https://tailwindcss.com/docs/extracting-components" target="_blank" rel="noopener noreferrer">的<code>@apply</code> </a>相反)，我们也减少了CSS中的重复。</h3>
<p>作为一个例子，让我们想象我们的许多组件使用一个特定的边界。如果我们的CSS内容是:</p>
<p>当我们一直使用低特异性的类时，我们可以将这些风格组合在一起，并得出最终结果:</p>
<pre>.c-sidebar {
  border: 1px solid #222;
}

.c-card {
  border: 1px solid #222;
}

.c-header {
  border: 1px solid #222;
}</pre>
<p><img data-attachment-id="8637" data-permalink="https://blog.logrocket.com/css-utility-classes-library-extendable-styles/repetition-vs-extend/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2019/10/repetition-vs-extend.png" data-orig-size="730,410" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Repeated styles vs. using @extend" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2019/10/repetition-vs-extend-300x168.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2019/10/repetition-vs-extend.png" decoding="async" class="aligncenter size-full wp-image-8637 jetpack-lazy-image" src="../Images/7176964c15baeaef52745626c7b3cc1d.png" alt="Repeated Styles vs. Using @extend" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2019/10/repetition-vs-extend.png 730w, https://blog.logrocket.com/wp-content/uploads/2019/10/repetition-vs-extend-300x168.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2019/10/repetition-vs-extend.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/10/repetition-vs-extend.png"/></p>
<pre>.c-sidebar {
  @extend %border-grey;
}

.c-card {
  @extend %border-grey;
}

.c-header {
  @extend %border-grey;
}

// Which compiles to…

.c-sidebar, 
.c-card, 
.c-header {
  border: 1px solid #222;
}</pre>
<p>我们的组件可以<code>@extend</code>我们库中的任何样式，通过引用一个占位符，我们知道我们没有创建一个浪费的新样式定义。让我们重写前面那个混乱的组件示例:</p><noscript><img data-lazy-fallback="1" data-attachment-id="8637" data-permalink="https://blog.logrocket.com/css-utility-classes-library-extendable-styles/repetition-vs-extend/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2019/10/repetition-vs-extend.png" data-orig-size="730,410" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Repeated styles vs. using @extend" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2019/10/repetition-vs-extend-300x168.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2019/10/repetition-vs-extend.png" decoding="async" loading="lazy" class="aligncenter size-full wp-image-8637" src="../Images/7176964c15baeaef52745626c7b3cc1d.png" alt="Repeated Styles vs. Using @extend" srcset="https://blog.logrocket.com/wp-content/uploads/2019/10/repetition-vs-extend.png 730w, https://blog.logrocket.com/wp-content/uploads/2019/10/repetition-vs-extend-300x168.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/10/repetition-vs-extend.png"/></noscript>
<p>组件内部嵌套</p>
<pre>.c-featured-link {
  @extend
  %u-pos-relative,
  %u-padv-3,
  %u-padh-4,
  %u-bgcolor-blue,
  %u-shadow-black-thin,
  %u-radius-tlbr-3,
  %u-radius-trbl-12,
  %u-weight-medium,
  %u-size-6rem,
  %u-line-thin,
  %u-font-europa,
  %u-color-light-grey,
  %u-whitespace-nowrap;
}</pre>
<h3>我们还可以通过嵌套断点和状态来极大地提高这些组件的可读性。</h3>
<p>制造我们需要的工具</p>
<pre>.c-featured-link {
  // …

  &amp;:hover,
  &amp;:focus {
    @extend 
    %u-top-3,
    %u-bg-color-darkblue,
    %u-color-white;
  }
}</pre>
<h3>最后，我将向您介绍SCSS实现上述目标所需的工具。我将首先描述它们是如何工作的，这样你就可以根据自己的喜好重新构建它们，然后提供一个链接到一个已经有一整套工作的<a href="https://github.com/wearelighthouse/stemCSS/">框架</a>。</h3>
<p>上面的mixin首先为在<code>$properties</code>参数中发送的每个属性创建一个占位符。然后，我们遍历在<code>$global-breakpoints</code>图中其他地方定义的所有断点，以确保我们也有断点占位符。</p>

<pre>@mixin make-placeholder($utility-name, $properties) {

  // No breakpoint
  %#{$utility-name} {
    @each $property, $value in $properties {
      #{$property}: $value;
    }
  }

  // Every breakpoint
  @each $breakpoint-key, $breakpoint-value in $global-breakpoints {
    %#{$utility-name + $global-breakpoint-separator + $breakpoint-key} {
      @include breakpoint($breakpoint-key) {
        @each $property, $value in $properties {
          #{$property}: $value;
        }
      }
    }
  }
}</pre>
<p>这将为我们提供如下占位符:</p>
<p>我们对@符号(我们的断点和状态标识符)进行了转义，因为它是一个无效字符；欢迎您选择自己的分隔符来替换它。</p>
<pre>@media (min-width: 600px) {
  %u-bgcolor-primary\@medium {
    background-color: blue;
  }
}</pre>
<p>正如我们需要的(在下一个mixin中)，直接从新的<code>%placeholder</code>创建一个实用程序类。</p>

<pre>@mixin make-class-from-placeholder($utility-name, $properties) {
  .#{$utility-name} {
    @extend %#{$utility-name};
  }
}</pre>
<p>最后一步是支持别名，这允许您决定是喜欢在类名(<code>justify-content-space-between</code>)中一个字母接一个字母，还是喜欢一个小的快捷方式(<code>jc-sb</code>)。</p>

<pre>@mixin make-utility($args) {

  $class: map-use(
    $args,
    class,
    false
  );

  $args: map-remove($args, class);

  // If 'alias' key exists in $args, use that for the placeholder-name,
  // otherwise use the key and value of the first property in $args
  $utility-name: map-use(
    $args,
    alias,
    first(map-keys($args)) + '-' + first(map-values($args))
  );

  $utility-name: 'u-' + $utility-name;

  $properties: map-remove($args, alias);

  @include make-placeholder($utility-name, $properties);

  @if ($class) {
    @include make-class-from-placeholder($utility-name, $properties);
  }

}</pre>
<p>这完全取决于您——较长的名称意味着任何开发人员都可以直接进入并立即知道模式，但是较短的名称更容易浏览和输入。</p>
<p>别名确定后(或留空)，我们将检查您是否希望使用Make Class并完成占位符。</p>
<p>用循环和控制指令把它们放在一起</p>
<h3>为了充分利用我们的占位符构建，您需要列出要添加到库中的属性和值。</h3>
<p>这里有几个有用的循环，可以帮你上路:</p>
<p>如果你想快速启动你自己的框架，你可以获取最新版本的<a href="https://github.com/wearelighthouse/stemCSS"> stemCSS </a>。</p>
<pre>@each $wrap in (nowrap, wrap, wrap-reverse) { 
  @include make-utility((
    alias: 'fw-' + $wrap,
    flex-wrap: $wrap
  ));
}


@each $property in (translateX, translateY) {
  @each $value in (-100, -50, 0, 50, 100) {
    @include make-utility((
      alias: $property + '-' + $value + $global-unit-percent,
      transform: $property + '(' + $value + '%)'
    ));
  }
}


@each $property in (margin-top, margin-right, margin-bottom, margin-left) {
  @for $value from 1 through 30 {
    @include make-utility((
      $property: #{$value + 'rem'};
    ));
  }
}</pre>
<p>摘要</p>
<h2>最近的工具和框架已经将实用程序类的概念推进到了主流，并且它们正在收获其特殊文档的好处(hat-tip to <a href="https://tailwindcss.com/"> Tailwind CSS </a>)。很明显，实用程序类改变了开发人员如何使用低特异性CSS类作为一致样式的方法的前景。</h2>
<p>样式表的未来会给我们带来什么？</p>
<p>你的前端是否占用了用户的CPU？</p><div class="code-block code-block-25">
<div class="blog-plug inline-plug css-plug"><h2>随着web前端变得越来越复杂，资源贪婪的特性对浏览器的要求越来越高。如果您对监控和跟踪生产环境中所有用户的客户端CPU使用、内存使用等感兴趣，</h2><p>.</p><a target="_blank" href="https://lp.logrocket.com/blg/css-signup">try LogRocket</a><p>LogRocket 就像是网络和移动应用的DVR，记录你的网络应用或网站上发生的一切。您可以汇总和报告关键的前端性能指标，重放用户会话和应用程序状态，记录网络请求，并自动显示所有错误，而不是猜测问题发生的原因。</p><a class="signup" href="https://lp.logrocket.com/blg/css-signup" target="_blank" rel="noopener noreferrer"><img class="alignnone size-full wp-image-46 jetpack-lazy-image" src="../Images/dacb06c713aec161ffeaffae5bd048cd.png" alt="LogRocket Dashboard Free Trial Banner" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2019/12/cpu-memory-usage.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/12/cpu-memory-usage.png"/><noscript><img data-lazy-fallback="1" class="alignnone size-full wp-image-46" src="../Images/dacb06c713aec161ffeaffae5bd048cd.png" alt="LogRocket Dashboard Free Trial Banner" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/12/cpu-memory-usage.png"/></noscript></a><a href="https://lp.logrocket.com/blg/css-signup" target="_blank" rel="noopener noreferrer">https://logrocket.com/signup/</a><p>现代化您调试web和移动应用的方式— <a class="signup" href="https://lp.logrocket.com/blg/css-signup" target="_blank" rel="noopener noreferrer">开始免费监控</a>。</p><p>Modernize how you debug web and mobile apps — <a class="signup" href="https://lp.logrocket.com/blg/css-signup" target="_blank" rel="noopener noreferrer">Start monitoring for free</a>.</p></div>
</div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
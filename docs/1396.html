<html>
<head>
<title>The async Cookie Store API: A new treat for web developers - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>异步Cookie Store API:web开发人员的新享受</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/the-async-cookie-store-api-a-new-treat-for-web-developers/#0001-01-01">https://blog.logrocket.com/the-async-cookie-store-api-a-new-treat-for-web-developers/#0001-01-01</a></blockquote><div><article class="article-post">
<h2>背景</h2>
<p>Cookies是在浏览器中存储信息的最古老的方式之一。它们被设计成一种为无状态HTTP协议存储有状态或会话信息的可靠机制。这种信息通常包括经过身份验证的用户的浏览活动或行为，例如他们访问过的页面或他们点击过的链接。</p>
<p>简单来说，cookies是这样工作的:在接收到一个HTTP请求后，服务器可以将一个或多个<a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Set-Cookie" target="_blank" rel="noopener"> <code>Set-Cookie</code> </a>头连同响应一起发送回客户端。cookie通常由这个客户端存储，然后它可以在一个<a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cookie" target="_blank" rel="noopener"> <code>Cookie</code> </a> HTTP头中与对同一个服务器的请求一起发送。因此，cookies用于判断请求是否来自同一个浏览器客户端会话。</p>
<h2>饼干的问题是</h2>
<p>虽然cookies解决了一个重要的用例，但它们也带来了许多问题。他们的接口相当复杂，因为保存所有的cookie(DOM的一部分)是有问题的。没有办法知道执行写操作的结果。文档脚本需要发出一个read或get请求来验证前一个write或create请求的结果。</p>
<p>另一个问题是，当cookie的属性被读取时，它们仍然需要被解析/序列化。这是因为它们都作为单个字符串返回，每个cookie的名称-值对连接成一个对列表，每个列表项用分号分隔。</p>
<p>这在通常管理cookie或执行诸如获取cookie、检查cookie的存在、检查cookie数据中特定值的存在等操作时提出了另一个挑战。</p>
<p>如今，开发者被强烈鼓励使用现代存储API,如IndexedDB或<code>localStorage</code>,在浏览器中存储会话数据。这是因为它们具有比cookie更大的存储限制，并且来自客户端的cookie信息从不发送到服务器。</p>
<p>但是，如果您仍然有很强的理由在项目中使用Cookie，那么您很幸运:async Cookie Store API提供了一种新的改进的做事方式。</p>
<h2>cookie如何工作:网络cookie行为初级读本</h2>
<p>在这里，我们将探索与cookies相关的行为和复杂性，以便我们可以开始欣赏新的异步API的有用性。</p>
<p>虽然cookies现在被广泛使用，但是它们的接口已经成为复杂性和性能问题的来源。<a href="https://developer.mozilla.org/en-US/docs/Web/API/Document/cookie" target="_blank" rel="noopener"> <code>document.cookie</code> </a>属性让我们读写与文档相关的cookies。该文档充当cookies实际值的获取器和设置器。</p>
<p>然而，每当我们使用<code>document.cookie</code> getter时，浏览器必须停止执行JavaScript，直到它获得我们请求的cookie信息。当然，这可能会导致用户界面/UX出现问题。下面我们来探讨一下读写cookie的操作，这样可以有更好的感受。</p>
<h3>获取饼干</h3>
<p>获取特定的cookie值似乎总是一件非常困难的事情。我们可以选择迭代<code>document.cookie</code>值，这是一个包含所有cookies的完整字符串。让我们看一个使用特定名称访问cookie值的示例:</p>
<pre>document.cookie = "name1=value1";
document.cookie = "name2=value2";
document.cookie = "name3=value3";

// to get a cookie value with name value2
const cookieValue = document.cookie
  .split('; ')
  .find(row =&gt; row.startsWith('name2'))
  .split('=')[1];

console.log(cookieValue) // value2
</pre>
<p>通过<a href="https://stackoverflow.com/questions/4825683/how-do-i-create-and-read-a-value-from-cookie" target="_blank" rel="noopener">这个持久的堆栈溢出线程</a>，一个更通用的方法是:</p>
<pre>const getCookie = (name) =&gt; {
  return document.cookie.split('; ').reduce((r, v) =&gt; {
    const parts = v.split('=')
    return parts[0] === name ? decodeURIComponent(parts[1]) : r
  }, '')
}
</pre>
<h3>设置cookies</h3>
<p>设置cookie值的API似乎太过时了——为什么？好吧，在设置cookie数据之后，我们没有办法知道cookie是否被成功创建。</p>
<p>一个解决方法是使用一个类似上面的<code>getCookie</code>函数，循环遍历cookie字符串，找到我们为cookie数据设置的值。</p>
<pre>document.cookie = "name=value";
</pre>
<p>设置cookie时的另一个问题是没有明确定义的机制来报告cookie存储错误。这当然是因为<code>document.cookie</code>是同步的。</p>
<h2>异步Cookie存储API简介</h2>
<p>厌倦了从<code>document.cookie</code>获取饼干的怪异方式？不确定您设置的cookie是否是实际创建的？本节将解决这些问题。</p>
<p>新的Cookie Store API旨在通过提供对<code>document.cookie</code>的异步替代并将这些Cookie暴露给<a href="https://blog.logrocket.com/every-website-deserves-a-service-worker/" target="_blank" rel="noopener">服务人员</a>来改善使用Cookie的所有缺点。该API为cookie管理提供了一种健壮且合理的方法。总的来说，API使以下工作变得更加容易:</p>
<ul>
<li>通过异步访问cookies来避免主线程上的过多活动</li>
<li>避免轮询cookie，因为现在可以观察或监控对cookie的更改</li>
<li>从服务人员处访问cookies</li>
</ul>
<blockquote><p><strong>注意</strong>:由于<code>document.cookie</code> API的同步设计，cookies以前是服务人员无法访问的。</p></blockquote>
<p>服务工作者需要能够读取和修改他们范围内的页面可访问的cookies，因为他们打算充当某种HTTP代理。此外，他们需要对会话状态的变化做出快速反应，这将有助于清除旧的或过时的缓存数据。</p>
<p>新的Cookie Store API包含了在文档和服务工作者中观察Cookie变化的方法(<a href="https://github.com/WICG/cookie-store/blob/main/explainer.md#reacting-to-session-state-changes" target="_blank" rel="noopener">而不是轮询</a>)。观察cookie变化的方法包括当cookie改变其值时激活服务工作者的能力。</p>
<h2>现在使用异步Cookie存储</h2>
<p>为了今天使用Cookie Store API，我们可以启用origin试用标志。然而，在撰写本文时，origin试用标志已经关闭，因为API目前正在根据社区反馈进行重大改进。origin试验预计将在维护和改进完成后重新开放。你可以在这里找到更多细节<a href="https://developers.google.com/web/updates/2018/09/asynchronous-access-to-http-cookies#status" target="_blank" rel="noopener">。</a></p>
<p>尽管如此，您仍然可以在本地进行尝试——可以在CLI上启用API，这可以在Chrome中为当前会话全局启用API。请参见下面的命令:</p>
<pre>chrome --enable-blink-features=CookieStore
</pre>
<p>或者，我们可以启用<code>chrome://flags</code>中的<code>#enable-experimental-web-platform-features</code>标志。</p>
<h3>使用Cookie Store API查询、修改和监控Cookie的介绍</h3>
<h4>查询/读取cookie</h4>
<p>文档窗口和服务工作者通过<a href="https://wicg.github.io/cookie-store/#globals" target="_blank" rel="noopener">全局对象</a>上的<a href="https://wicg.github.io/cookie-store/#dom-window-cookiestore" target="_blank" rel="noopener"> <code>cookieStore</code> </a>属性访问相同的查询API。<code><a href="https://wicg.github.io/cookie-store/#cookiestore" target="_blank" rel="noopener">CookieStore</a></code>上的<a href="https://wicg.github.io/cookie-store/#dom-cookiestore-get-options" target="_blank" rel="noopener"> <code>get()</code> </a>和<code><a href="https://wicg.github.io/cookie-store/#dom-cookiestore-getall-options" target="_blank" rel="noopener">getAll()</a></code>方法用于查询cookies。不要忘记，这将返回一个承诺，让我们可以轻松地检查错误。</p>
<p>他们采用相同的论点，可以是:</p>
<ul>
<li>一个名字</li>
<li>选项列表(这对于<code>getAll()</code>是可选的)</li>
</ul>
<p><code>get()</code>方法本质上是只返回第一个结果的<code>getAll()</code>的一种形式。这里有一个例子:</p>
<pre>try {
    const cookie = await cookieStore.get('session_id');
    if (cookie) {
    console.log(`Found ${cookie.name} cookie: ${cookie.value}`);
} else {
    console.log('Cookie not found');
}
} catch (error) {
  console.error(`Cookie store error: ${error}`);
}
</pre>
<p>由<code>get()</code>和<code>getAll()</code>返回的对象包含了cookie存储中的所有相关信息，而不仅仅是旧的<code>document.cookie</code> API中的<a href="https://wicg.github.io/cookie-store/#cookie-name" target="_blank" rel="noopener">名称</a>和<a href="https://wicg.github.io/cookie-store/#cookie-value" target="_blank" rel="noopener">值</a>。</p>
<h4>修改/写入cookie</h4>
<p>此外，文档和服务工作者都通过全局对象上的<code>cookieStore</code>属性访问相同的修改API。使用<code><a href="https://wicg.github.io/cookie-store/#dom-cookiestore-set" target="_blank" rel="noopener">set()</a></code>方法创建或修改(写入)Cookies。</p>
<pre>try {
    await cookieStore.set('opted_out', '1');
} catch (error) {
    console.error(`Failed to set cookie: ${error}`);
}
</pre>
<p>请记住，只有在<code>cookieStore.set</code>返回的承诺解决后，才能保证应用更改。</p>
<h4>删除cookie</h4>
<p>使用<code><a href="https://wicg.github.io/cookie-store/#dom-cookiestore-delete" target="_blank" rel="noopener">delete()</a></code>方法删除(过期)Cookies。</p>
<pre>try {
  await cookieStore.delete('session_id');
} catch (error) {
  console.error(`Failed to delete cookie: ${error}`);
}
</pre>
<p>在幕后，删除cookie是通过将cookie的到期日期更改为过去来完成的，这仍然有效。</p>
<h4>监控cookies</h4>
<p>Cookie Store API提供了另一种观察Cookie变化的方法，这种方法不需要轮询。从JavaScript访问cookies的一个流行应用程序是检测用户何时注销，并相应地更新UI。</p>
<p>所有相关的cookie更改都会触发更改事件。注册<code>change</code>事件的简单示例如下所示</p>
<pre>cookieStore.addEventListener('change', event =&gt; {
    console.log(`${event.changed.length} changed cookies`);
 for (const cookie in event.changed)
    console.log(`Cookie ${cookie.name} changed to ${cookie.value}`);
  for (const cookie in event.deleted)
    console.log(`Cookie ${cookie.name} deleted`);
});
</pre>
<p>这个API还被设计成允许浏览器出于性能原因批量改变事件。更多细节可以在这里找到<a href="https://github.com/WICG/cookie-store/blob/main/explainer.md#the-change-events-api" target="_blank" rel="noopener">。</a></p>
<h4>延伸至服务人员</h4>
<p>需要访问cookies <a href="https://github.com/w3c/ServiceWorker/issues/707" target="_blank" rel="noopener">的服务人员不能依靠同步的</a>，阻塞了<code>document.cookie</code>接口。这是因为服务人员不能阻止事件循环，因为这会干扰其他事件的处理。</p>
<p>然而，Cookie存储API是异步的，因此在服务人员中是允许的。请注意，服务人员有时可能需要cookie访问权限，例如:</p>
<ul>
<li>确保仅在代表未到期会话中的用户身份验证的cookies仍然存在时，才显示或发送私人数据</li>
<li>为了确保一个用户帐户的数据不会在会话cookie更改后意外显示</li>
</ul>
<p>在文档上下文和服务人员中，与cookies的交互方式是相同的。然而，在服务人员中观察cookie变化有点不同。这是因为叫醒一个服务人员可能相当昂贵；因此，需要对工作人员感兴趣的cookie更改进行明确的描述。</p>
<p>更多细节可在草案文件<a href="https://wicg.github.io/cookie-store/#service-worker-extensions" target="_blank" rel="noopener">这里</a>找到。另外，我们可以参考讲解文档中关于服务人员的<a href="https://github.com/WICG/cookie-store/blob/main/explainer.md#get-change-events-in-service-workers" target="_blank" rel="noopener">变更事件的部分。</a></p>
<h2>结论</h2>
<p>这个令人兴奋的提议为以下文档事件提供了异步cookie API:设置、删除和读取操作。也许最重要的是，它将允许服务人员读取cookies，这在今天是不可能的；从文档中读取和写入cookies目前是一个同步的过程，这导致了缓慢而恼人的页面加载时间。对cookies的异步访问满足了这些需求。</p>
<p>API包括一个<code>cookiechange</code>事件，它将唤醒服务人员。服务工作者中的Cookie更改事件是针对全局范围触发的，但是需要与服务工作者的注册相关联的显式订阅。更多详情<a href="https://github.com/WICG/cookie-store/blob/gh-pages/explainer.md#get-change-events-in-service-workers" target="_blank" rel="noopener">此处</a>。</p>
<p>该API还将有一个定义良好的机制来报告cookie存储错误。它还解决了一些已知的跨浏览器不兼容性以及规范和浏览器行为之间的差异。</p>
<p>目前，浏览器需要在每个HTTP请求中包含cookie的快照，这导致cookie更改在存储和网络堆栈之间传播。现代浏览器有高度优化的cookie存储实现，但我们永远无法使cookie像其他存储机制一样高效，因为其他存储机制不需要与网络堆栈对话。然而，该提议并不旨在改变网络层处理cookie的方式或cookie的一般安全模型</p>
<p>有关Cookie Store API的更多详细信息，您可以在此处查看提案文档/草案<a href="https://wicg.github.io/cookie-store/#intro" target="_blank" rel="noopener"/>、<a href="https://github.com/WICG/cookie-store/blob/main/explainer.md#introduction" target="_blank" rel="noopener">讲解材料</a>，以及<a href="https://github.com/WICG/cookie-store" target="_blank" rel="noopener"> GitHub repo </a>。关于cookie变更事件的细节可以在<a href="https://github.com/patrickkettner/cookie-change-events" target="_blank" rel="noopener">这里</a>找到。此外，您还可以将这个提议与另一个实现进行比较，这是一个简单、轻量级的JavaScript API，用于处理浏览器cookies。</p><div class="code-block code-block-27">
<div class="blog-plug inline-plug vanilla-javascript-cta"><h2>通过理解上下文，更容易地调试JavaScript错误</h2>
<p>调试代码总是一项单调乏味的任务。但是你越了解自己的错误，就越容易改正。</p>
<p>LogRocket 让你以新的独特的方式理解这些错误。我们的前端监控解决方案跟踪用户与您的JavaScript前端的互动，让您能够准确找出导致错误的用户行为。</p>
<a href="https://lp.logrocket.com/blg/javascript-signup" class="signup" target="_blank" rel="noopener noreferrer"><img class="alignnone size-full wp-image-46 jetpack-lazy-image" src="../Images/cbfed9be3defcb505e662574769a7636.png" alt="LogRocket Dashboard Free Trial Banner" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2020/06/reproduce-javascript-errors.gif?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/06/reproduce-javascript-errors.gif"/><noscript><img data-lazy-fallback="1" class="alignnone size-full wp-image-46" src="../Images/cbfed9be3defcb505e662574769a7636.png" alt="LogRocket Dashboard Free Trial Banner" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/06/reproduce-javascript-errors.gif"/></noscript></a>
<p>LogRocket记录控制台日志、页面加载时间、堆栈跟踪、慢速网络请求/响应(带有标题+正文)、浏览器元数据和自定义日志。理解您的JavaScript代码的影响从来没有这么简单过！</p>
<a class="signup" href="https://lp.logrocket.com/blg/javascript-signup" target="_blank" rel="noopener noreferrer">Try it for free</a><p>.</p></div>


</div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
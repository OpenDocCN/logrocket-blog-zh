<html>
<head>
<title>Throttling data requests with React Hooks - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>用React钩子抑制数据请求</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/throttling-data-requests-with-react-hooks/#0001-01-01">https://blog.logrocket.com/throttling-data-requests-with-react-hooks/#0001-01-01</a></blockquote><div><article class="article-post">
<p>当应用程序加载数据时，通常会发出相对较少的HTTP请求。例如，假设我们正在开发一个学生管理应用程序，那么一个“view”屏幕可能会发出一个HTTP请求，在显示之前加载该学生的数据。</p>
<p>有时候，应用程序需要发出大量的HTTP请求。假设有一个报告应用程序，它加载数据，然后出于演示目的对数据进行聚合。</p>
<p>这种需求提出了两个有趣的问题:</p>
<ol>
<li>我们如何逐步加载数据？</li>
<li>我们如何向用户呈现加载进度？</li>
</ol>
<p>在本教程中，我们将演示如何使用自定义的React钩子来解决这些问题。</p>
<h2 id="letsbringchrometoitsknees">让我们让Chrome屈服吧</h2>
<p>我们将通过使用<a href="https://create-react-app.dev/" target="_blank" rel="noopener noreferrer"> Create React App </a>构建一个TypeScript React app来开始我们的旅程。</p>
<pre>npx create-react-app throttle-requests-react-hook --template typescript
</pre>
<p>因为我们要进行一些异步调用，我们将通过使用广泛使用的<a href="https://github.com/streamich/react-use"> <code>react-use</code> </a>作为<a href="https://github.com/streamich/react-use/blob/master/docs/useAsync.md"> <code>useAsync</code> </a>钩子来简化代码。</p>
<pre>cd throttle-requests-react-hook
yarn add react-use
</pre>
<p>我们将用以下内容替换<code>App.css</code>文件:</p>
<pre>.App {
  text-align: center;
}

.App-header {
  background-color: #282c34;
  min-height: 100vh;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  font-size: calc(10px + 2vmin);
  color: white;
}

.App-labelinput &gt; * {
  margin: 0.5em;
  font-size:24px;
}

.App-link {
  color: #61dafb;
}

.App-button {
  font-size: calc(10px + 2vmin);
  margin-top: 0.5em;
  padding: 1em;
  background-color: cornflowerblue;
  color: #ffffff;
  text-align: center;
}

.App-progress {
  padding: 1em;
  background-color: cadetblue;
  color: #ffffff;
}

.App-results {
  display: flex;
  flex-wrap: wrap;
}

.App-results &gt; * {
  padding: 1em;
  margin: 0.5em;
  background-color: darkblue;
  flex: 1 1 300px;
}
</pre>
<p>然后，我们将把<code>App.tsx</code>内容替换为:</p>
<pre>import React, { useState } from "react";
import { useAsync } from "react-use";
import "./App.css";

function use10_000Requests(startedAt: string) {
  const responses = useAsync(async () =&gt; {
    if (!startedAt) return;

    // make 10,000 unique HTTP requests
    const results = await Promise.all(
      Array.from(Array(10_000)).map(async (_, index) =&gt; {
        const response = await fetch(
          `/manifest.json?querystringValueToPreventCaching=${startedAt}_request-${index}`
        );
        const json = await response.json();
        return json;
      })
    );

    return results;
  }, [startedAt]);

  return responses;
}


function App() {
  const [startedAt, setStartedAt] = useState("");
  const responses = use10_000Requests(startedAt);

  return (
    &lt;div className="App"&gt;
      &lt;header className="App-header"&gt;
        &lt;h1&gt;The HTTP request machine&lt;/h1&gt;
        &lt;button
          className="App-button"
          onClick={(_) =&gt; setStartedAt(new Date().toISOString())}
        &gt;
          Make 10,000 requests
        &lt;/button&gt;
        {responses.loading &amp;&amp; &lt;div&gt;{progressMessage}&lt;/div&gt;}
        {responses.error &amp;&amp; &lt;div&gt;Something went wrong&lt;/div&gt;}
        {responses.value &amp;&amp; (
          &lt;div className="App-results"&gt;
            {responses.value.length} requests completed successfully
          &lt;/div&gt;
        )}
      &lt;/header&gt;
    &lt;/div&gt;
  );
}

export default App;
</pre>
<p>我们构建的应用程序非常简单:这是一个按钮，当你按下它时，使用<a href="https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API" target="_blank" rel="noopener noreferrer">获取API </a>并行发出10，000个HTTP请求。本例中请求的数据是一个任意的JSON文件:<code>manifest.json</code>。如果你仔细观察，你会发现我们用URL做了一些querystring技巧来避免获取缓存数据。</p>
<p>事实上，对于这个演示，我们对这些HTTP请求的结果不感兴趣。相反，我们感兴趣的是浏览器如何应对这种方法(剧透:不太好)。值得考虑的是，从与浏览器运行在同一台机器上的服务器请求文本文件应该很快。</p>
<p>因此，我们将运行<code>yarn start</code>并转到<code><a href="http://localhost:3000" rel="nofollow">http://localhost:3000</a></code>以访问应用程序。在Devtools打开的情况下运行会导致以下不愉快的事件:</p>
<p><img data-attachment-id="27252" data-permalink="https://blog.logrocket.com/throttling-data-requests-with-react-hooks/i-want-it-all/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/10/i-want-it-all.gif" data-orig-size="720,327" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="HTTP request app built with React TypeScript" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/10/i-want-it-all-300x136.gif" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/10/i-want-it-all.gif" decoding="async" class="aligncenter size-full wp-image-27252 jetpack-lazy-image" src="../Images/24ca0b005fe3f7e1c5e8b01d7643265e.png" alt="HTTP Request Machine App Example" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2020/10/i-want-it-all.gif?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/10/i-want-it-all.gif"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="27252" data-permalink="https://blog.logrocket.com/throttling-data-requests-with-react-hooks/i-want-it-all/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/10/i-want-it-all.gif" data-orig-size="720,327" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="HTTP request app built with React TypeScript" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/10/i-want-it-all-300x136.gif" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/10/i-want-it-all.gif" decoding="async" loading="lazy" class="aligncenter size-full wp-image-27252" src="../Images/24ca0b005fe3f7e1c5e8b01d7643265e.png" alt="HTTP Request Machine App Example" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/10/i-want-it-all.gif"/></noscript>
<p>为了简洁起见，上面的gif已经做了很大的编辑。实际上，启动第一个请求需要20秒。在此之前，Chrome没有响应。当请求开始触发时，有相当数量的请求因<code>net::ERR_INSUFFICIENT_RESOURCES</code>而失败。被激发的请求在被执行之前处于“停滞”状态。这是<a href="https://developers.google.com/web/tools/chrome-devtools/network/reference#timing" target="_blank" rel="noopener noreferrer"> Chrome限制连接数</a>的结果(所有浏览器都这么做):</p>
<blockquote><p>已经有六个TCP连接为此源打开，这是极限。仅适用于HTTP/1.0和HTTP/1.1。</p></blockquote>
<p>总之，当前方法的问题有三个方面:</p>
<ol>
<li>浏览器变得没有响应</li>
<li>由于资源不足，HTTP请求失败</li>
<li>用户看不到与进度相关的信息</li>
</ol>
<h2 id="throttlemethis">掐死我</h2>
<p>我们可以实现一个节流器，而不是一次触发所有请求来敲打浏览器。限制是一种允许您限制操作执行速率的机制。</p>
<p>在这种情况下，我们希望限制HTTP请求的速率。throttle将解决前两个问题，本质上保持浏览器自由和简单，并确保请求被成功发送。我们也想让我们的用户了解进展情况。</p>
<p>是时候揭开<code>useThrottleRequests</code>的面纱了:</p>
<pre>import { useMemo, useReducer } from "react";
import { AsyncState } from "react-use/lib/useAsync";

/** Function which makes a request */
export type RequestToMake = () =&gt; Promise&lt;void&gt;;

/**
 * Given an array of requestsToMake and a limit on the number of max parallel requests
 * queue up those requests and start firing them
 * - inspired by Rafael Xavier's approach here: https://stackoverflow.com/a/48007240/761388
 *
 * @param requestsToMake
 * @param maxParallelRequests the maximum number of requests to make - defaults to 6
 */
async function throttleRequests(
  requestsToMake: RequestToMake[],
  maxParallelRequests = 6
) {
  // queue up simultaneous calls
  const queue: Promise&lt;void&gt;[] = [];
  for (let requestToMake of requestsToMake) {
    // fire the async function, add its promise to the queue,
    // and remove it from queue when complete
    const promise = requestToMake().then((res) =&gt; {
      queue.splice(queue.indexOf(promise), 1);
      return res;
    });
    queue.push(promise);

    // if the number of queued requests matches our limit then
    // wait for one to finish before enqueueing more
    if (queue.length &gt;= maxParallelRequests) {
      await Promise.race(queue);
    }
  }
  // wait for the rest of the calls to finish
  await Promise.all(queue);
}

/**
 * The state that represents the progress in processing throttled requests
 */
export type ThrottledProgress&lt;TData&gt; = {
  /** the number of requests that will be made */
  totalRequests: number;
  /** the errors that came from failed requests */
  errors: Error[];
  /** the responses that came from successful requests */
  values: TData[];
  /** a value between 0 and 100 which represents the percentage of requests that have been completed (whether successfully or not) */
  percentageLoaded: number;
  /** whether the throttle is currently processing requests */
  loading: boolean;
};

function createThrottledProgress&lt;TData&gt;(
  totalRequests: number
): ThrottledProgress&lt;TData&gt; {
  return {
    totalRequests,
    percentageLoaded: 0,
    loading: false,
    errors: [],
    values: [],
  };
}

/**
 * A reducing function which takes the supplied `ThrottledProgress` and applies a new value to it
 */
function updateThrottledProgress&lt;TData&gt;(
  currentProgress: ThrottledProgress&lt;TData&gt;,
  newData: AsyncState&lt;TData&gt;
): ThrottledProgress&lt;TData&gt; {
  const errors = newData.error
    ? [...currentProgress.errors, newData.error]
    : currentProgress.errors;

  const values = newData.value
    ? [...currentProgress.values, newData.value]
    : currentProgress.values;

  const percentageLoaded =
    currentProgress.totalRequests === 0
      ? 0
      : Math.round(
          ((errors.length + values.length) / currentProgress.totalRequests) * 100
        );

  const loading =
    currentProgress.totalRequests === 0
      ? false
      : errors.length + values.length &lt; currentProgress.totalRequests;

  return {
    totalRequests: currentProgress.totalRequests,
    loading,
    percentageLoaded,
    errors,
    values,
  };
}

type ThrottleActions&lt;TValue&gt; =
  | {
      type: "initialise";
      totalRequests: number;
    }
  | {
      type: "requestSuccess";
      value: TValue;
    }
  | {
      type: "requestFailed";
      error: Error;
    };

/**
 * Create a ThrottleRequests and an updater
 */
export function useThrottleRequests&lt;TValue&gt;() {
  function reducer(
    throttledProgressAndState: ThrottledProgress&lt;TValue&gt;,
    action: ThrottleActions&lt;TValue&gt;
  ): ThrottledProgress&lt;TValue&gt; {
    switch (action.type) {
      case "initialise":
        return createThrottledProgress(action.totalRequests);

      case "requestSuccess":
        return updateThrottledProgress(throttledProgressAndState, {
          loading: false,
          value: action.value,
        });

      case "requestFailed":
        return updateThrottledProgress(throttledProgressAndState, {
          loading: false,
          error: action.error,
        });
    }
  }

  const [throttle, dispatch] = useReducer(
    reducer,
    createThrottledProgress&lt;TValue&gt;(/** totalRequests */ 0)
  );

  const updateThrottle = useMemo(() =&gt; {
    /**
     * Update the throttle with a successful request
     * @param values from request
     */
    function requestSucceededWithData(value: TValue) {
      return dispatch({
        type: "requestSuccess",
        value,
      });
    }

    /**
     * Update the throttle upon a failed request with an error message
     * @param error error
     */
    function requestFailedWithError(error: Error) {
      return dispatch({
        type: "requestFailed",
        error,
      });
    }

    /**
     * Given an array of requestsToMake and a limit on the number of max parallel requests
     * queue up those requests and start firing them
     * - based upon https://stackoverflow.com/a/48007240/761388
     *
     * @param requestsToMake
     * @param maxParallelRequests the maximum number of requests to make - defaults to 6
     */
    function queueRequests(
      requestsToMake: RequestToMake[],
      maxParallelRequests = 6
    ) {
      dispatch({
        type: "initialise",
        totalRequests: requestsToMake.length,
      });

      return throttleRequests(requestsToMake, maxParallelRequests);
    }

    return {
      queueRequests,
      requestSucceededWithData,
      requestFailedWithError,
    };
  }, [dispatch]);

  return {
    throttle,
    updateThrottle,
  };
}
</pre>
<p><code>useThrottleRequests</code>钩子返回两个属性:</p>
<ol>
<li><code>throttle</code>，一个包含以下数据的<code>ThrottledProgress&lt;TData&gt;</code>:<ul>
<li><code>totalRequests</code>，将被提出的请求的数量</li>
<li><code>errors</code>，来自失败请求的错误</li>
<li><code>values</code>，来自成功请求的响应</li>
<li><code>percentageLoaded</code>，一个介于0和100之间的值，表示已完成(成功或失败)的请求的百分比</li>
<li><code>loading</code>，节流阀当前是否正在处理请求</li>
</ul>
</li>
<li><code>updateThrottle</code>，一个公开三个函数的对象:<ul>
<li><code>queueRequests</code>，将应该排队并以节流方式执行的请求传递给该函数</li>
<li><code>requestSucceededWithData</code>，请求成功提供数据时调用的函数</li>
<li><code>requestFailedWithError</code>，请求未能提供错误时调用的函数</li>
</ul>
</li>
</ol>
<p>用这么多词来形容我们的<code>useThrottleRequests</code>钩。通过迁移我们的<code>use10_000Requests</code>钩子来使用它，让我们看看它是什么样子。</p>
<p>这里有一个<code>App.tsx</code>的新实现:</p>
<pre>import React, { useState } from "react";
import { useAsync } from "react-use";
import { useThrottleRequests } from "./useThrottleRequests";
import "./App.css";

function use10_000Requests(startedAt: string) {
  const { throttle, updateThrottle } = useThrottleRequests();
  const [progressMessage, setProgressMessage] = useState("not started");

  useAsync(async() =&gt; {
      if (!startedAt) return;

      setProgressMessage("preparing");

      const requestsToMake = Array.from(Array(10_000)).map(
        (_, index) =&gt; async () =&gt; {
          try {
            setProgressMessage(`loading ${index}...`);

            const response = await fetch(
              `/manifest.json?querystringValueToPreventCaching=${startedAt}_request-${index}`
            );
            const json = await response.json();

            updateThrottle.requestSucceededWithData(json);
          } catch (error) {
            console.error(`failed to load ${index}`, error);
            updateThrottle.requestFailedWithError(error);
          }
        }
      );

      await updateThrottle.queueRequests(requestsToMake);

  }, [startedAt, updateThrottle, setProgressMessage]);

  return { throttle, progressMessage };
}

function App() {
  const [startedAt, setStartedAt] = useState("");

  const { progressMessage, throttle } = use10_000Requests(startedAt);

  return (
    &lt;div className="App"&gt;
      &lt;header className="App-header"&gt;
        &lt;h1&gt;The HTTP request machine&lt;/h1&gt;
        &lt;button
          className="App-button"
          onClick={(_) =&gt; setStartedAt(new Date().toISOString())}
        &gt;
          Make 10,000 requests
        &lt;/button&gt;
        {throttle.loading &amp;&amp; &lt;div&gt;{progressMessage}&lt;/div&gt;}
        {throttle.values.length &gt; 0 &amp;&amp; (
          &lt;div className="App-results"&gt;
            {throttle.values.length} requests completed successfully
          &lt;/div&gt;
        )}
        {throttle.errors.length &gt; 0 &amp;&amp; (
          &lt;div className="App-results"&gt;
            {throttle.errors.length} requests errored
          &lt;/div&gt;
        )}
      &lt;/header&gt;
    &lt;/div&gt;
  );
}

export default App;
</pre>
<p>看看新的<code>use10_000Requests</code>钩子，与我们之前的实现有一些细微的不同。首先，我们现在暴露了<code>throttle</code>，一个<code>ThrottleProgress&lt;TData&gt;</code>。我们更新的钩子也公开了一个<code>progressMessage</code>，它是一个简单的<code>string</code>，存储在<code>useState</code>中，我们在油门运行时更新它。</p>
<p>事实上，这里出现的信息并不有趣。<code>progressMessage</code>的存在只是为了说明您可以在请求完成时从请求中获取一些数据用于显示目的——例如，运行总数。</p>
<p>那么，我们的新钩子方法表现如何呢？</p>
<p><img data-attachment-id="27251" data-permalink="https://blog.logrocket.com/throttling-data-requests-with-react-hooks/i-want-it-all-with-hook/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/10/i-want-it-all-with-hook.gif" data-orig-size="730,332" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="HTTP request app built with React Hooks" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/10/i-want-it-all-with-hook-300x136.gif" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/10/i-want-it-all-with-hook.gif" decoding="async" class="aligncenter size-full wp-image-27251 jetpack-lazy-image" src="../Images/3f38a381127a395492fbb98e8804d6ad.png" alt="HTTP Request Machine App Example" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2020/10/i-want-it-all-with-hook.gif?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/10/i-want-it-all-with-hook.gif"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="27251" data-permalink="https://blog.logrocket.com/throttling-data-requests-with-react-hooks/i-want-it-all-with-hook/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/10/i-want-it-all-with-hook.gif" data-orig-size="730,332" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="HTTP request app built with React Hooks" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/10/i-want-it-all-with-hook-300x136.gif" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/10/i-want-it-all-with-hook.gif" decoding="async" loading="lazy" class="aligncenter size-full wp-image-27251" src="../Images/3f38a381127a395492fbb98e8804d6ad.png" alt="HTTP Request Machine App Example" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/10/i-want-it-all-with-hook.gif"/></noscript>
<p>它表现得非常好，确实！同样，为了简洁起见，上面的gif也经过了编辑。如果我们回顾以前的方法所面临的问题，我们如何比较？</p>
<ol>
<li>浏览器保持响应</li>
<li>浏览器不会遇到失败的HTTP请求</li>
<li>始终向用户显示进度的细节</li>
</ol>
<p>太棒了。</p>
<h2 id="whatshallwebuild">我们要建造什么？</h2>
<p>我们目前的例子肯定是人为的。让我们将<code>useThrottleRequests</code>挂钩应用到一个更现实的场景中。</p>
<p>我们将构建一个应用程序，给定GitHub上的一个repo，列出所有贡献者的博客。您可以在GitHub个人资料上指定博客URL许多人用这个来指定他们的Twitter个人资料。</p>
<p>多亏了优秀的<a href="https://docs.github.com/en/free-pro-team@latest/rest" target="_blank" rel="noopener noreferrer"> GitHub REST API </a>，我们可以构建这一点，它公开了我们目标的两个感兴趣的端点:列出存储库贡献者和获取用户。</p>
<h3 id="1listrepositorycontributors">1.列出存储库参与者</h3>
<p><a href="https://docs.github.com/en/free-pro-team@latest/rest/reference/repos#list-repository-contributors" target="_blank" rel="noopener noreferrer">列出存储库贡献者</a>列出位于此URL: <code>GET <a href="https://api.github.com/repos/" rel="nofollow">https://api.github.com/repos/</a>{owner}/{repo}/contributors</code>的指定存储库的贡献者。响应是一个对象数组，关键是一个指向用户API端点的<code>url</code>属性。</p>
<pre>[
  // ...
  {
    // ...
    "url": "https://api.github.com/users/octocat",
    // ...
  },
  // ...
]
</pre>
<h3 id="2getauser">2.获取用户</h3>
<p><a href="https://docs.github.com/en/free-pro-team@latest/rest/reference/users#get-a-user" target="_blank" rel="noopener noreferrer">获取一个用户</a>就是上面的<code>url</code>属性所引用的API。调用时，它返回一个对象，该对象表示有关用户的公开可用信息。</p>
<pre>{
  // ...
  "name": "The Octocat",
  // ...
  "blog": "https://github.blog",
  // ...
}
</pre>
<h2 id="bloggingdevsv10">博客开发1.0版</h2>
<p>我们现在准备好构建我们的博客开发应用程序。让我们将现有的<code>App.tsx</code>替换为:</p>
<pre>import React, { useCallback, useMemo, useState } from "react";
import { useAsync } from "react-use";
import { useThrottleRequests } from "./useThrottleRequests";
import "./App.css";

type GitHubUser = { name: string; blog?: string };

function timeout(ms: number) {
  return new Promise((resolve) =&gt; setTimeout(resolve, ms));
}

function useContributors(contributorsUrlToLoad: string) {
  const { throttle, updateThrottle } = useThrottleRequests&lt;GitHubUser&gt;();
  const [progressMessage, setProgressMessage] = useState("");

  useAsync(async () =&gt; {
    if (!contributorsUrlToLoad) return;

    setProgressMessage("loading contributors");

    // load contributors from GitHub
    const contributorsResponse = await fetch(contributorsUrlToLoad);
    const contributors: { url: string }[] = await contributorsResponse.json();

    setProgressMessage(`loading ${contributors.length} contributors...`);

    // For each entry in result, retrieve the given user from GitHub
    const requestsToMake = contributors.map(({ url }, index) =&gt; async () =&gt; {
      try {
        setProgressMessage(
          `loading ${index} / ${contributors.length}: ${url}...`
        );

        const response = await fetch(url);
        const json: GitHubUser = await response.json();

        // wait for 1 second before completing the request
        // - makes for better demos
        await timeout(1000);

        updateThrottle.requestSucceededWithData(json);
      } catch (error) {
        console.error(`failed to load ${url}`, error);
        updateThrottle.requestFailedWithError(error);
      }
    });

    await updateThrottle.queueRequests(requestsToMake);

    setProgressMessage("");
  }, [contributorsUrlToLoad, updateThrottle, setProgressMessage]);

  return { throttle, progressMessage };
}

function App() {
  // The owner and repo to query; we're going to default
  // to using DefinitelyTyped as an example repo as it
  // is one of the most contributed to repos on GitHub
  const [owner, setOwner] = useState("DefinitelyTyped");
  const [repo, setRepo] = useState("DefinitelyTyped");
  const handleOwnerChange = useCallback(
    (event: React.ChangeEvent&lt;HTMLInputElement&gt;) =&gt;
      setOwner(event.target.value),
    [setOwner]
  );
  const handleRepoChange = useCallback(
    (event: React.ChangeEvent&lt;HTMLInputElement&gt;) =&gt; setRepo(event.target.value),
    [setRepo]
  );

  const contributorsUrl = `https://api.github.com/repos/${owner}/${repo}/contributors`;

  const [contributorsUrlToLoad, setUrlToLoad] = useState("");
  const { progressMessage, throttle } = useContributors(contributorsUrlToLoad);

  const bloggers = useMemo(
    () =&gt; throttle.values.filter((contributor) =&gt; contributor.blog),
    [throttle]
  );

  return (
    &lt;div className="App"&gt;
      &lt;header className="App-header"&gt;
        &lt;h1&gt;Blogging devs&lt;/h1&gt;

        &lt;p&gt;
          Show me the{" "}
          &lt;a
            className="App-link"
            href={contributorsUrl}
            target="_blank"
            rel="noopener noreferrer"
          &gt;
            contributors for {owner}/{repo}
          &lt;/a&gt;{" "}
          who have blogs.
        &lt;/p&gt;

        &lt;div className="App-labelinput"&gt;
          &lt;label htmlFor="owner"&gt;GitHub Owner&lt;/label&gt;
          &lt;input
            id="owner"
            type="text"
            value={owner}
            onChange={handleOwnerChange}
          /&gt;
          &lt;label htmlFor="repo"&gt;GitHub Repo&lt;/label&gt;
          &lt;input
            id="repo"
            type="text"
            value={repo}
            onChange={handleRepoChange}
          /&gt;
        &lt;/div&gt;

        &lt;button
          className="App-button"
          onClick={(e) =&gt; setUrlToLoad(contributorsUrl)}
        &gt;
          Load bloggers from GitHub
        &lt;/button&gt;

        {progressMessage &amp;&amp; (
          &lt;div className="App-progress"&gt;{progressMessage}&lt;/div&gt;
        )}

        {throttle.percentageLoaded &gt; 0 &amp;&amp; (
          &lt;&gt;
            &lt;h3&gt;Behold {bloggers.length} bloggers:&lt;/h3&gt;
            &lt;div className="App-results"&gt;
              {bloggers.map((blogger) =&gt; (
                &lt;div key={blogger.name}&gt;
                  &lt;div&gt;{blogger.name}&lt;/div&gt;
                  &lt;a
                    className="App-link"
                    href={blogger.blog}
                    target="_blank"
                    rel="noopener noreferrer"
                  &gt;
                    {blogger.blog}
                  &lt;/a&gt;
                &lt;/div&gt;
              ))}
            &lt;/div&gt;
          &lt;/&gt;
        )}

        {throttle.errors.length &gt; 0 &amp;&amp; (
          &lt;div className="App-results"&gt;
            {throttle.errors.length} requests errored
          &lt;/div&gt;
        )}
      &lt;/header&gt;
    &lt;/div&gt;
  );
}

export default App;
</pre>
<p>该应用程序使用户能够进入GitHub项目的组织和存储库。然后，当单击按钮时，它会:</p>
<ul>
<li>加载贡献者</li>
<li>为每个贡献者加载单个用户(为每个贡献者加载单独的HTTP请求)</li>
<li>在加载时传达进度</li>
<li>加载用户时，为每个用户呈现一个带有列出的博客的磁贴</li>
</ul>
<p>为了让演示更加清晰，我们人为地将每个请求的持续时间降低了一秒钟。当你把它放在一起时，它看起来是这样的:</p>
<p><img data-attachment-id="27254" data-permalink="https://blog.logrocket.com/throttling-data-requests-with-react-hooks/blogging-devs-2/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/10/blogging-devs-1.gif" data-orig-size="730,332" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Blogging devs app example" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/10/blogging-devs-1-300x136.gif" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/10/blogging-devs-1.gif" decoding="async" class="aligncenter size-full wp-image-27254 jetpack-lazy-image" src="../Images/bb8a9cc4c648ba57b1ddb7a93977f67e.png" alt="Blogging Devs App Example" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2020/10/blogging-devs-1.gif?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/10/blogging-devs-1.gif"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="27254" data-permalink="https://blog.logrocket.com/throttling-data-requests-with-react-hooks/blogging-devs-2/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/10/blogging-devs-1.gif" data-orig-size="730,332" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Blogging devs app example" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/10/blogging-devs-1-300x136.gif" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/10/blogging-devs-1.gif" decoding="async" loading="lazy" class="aligncenter size-full wp-image-27254" src="../Images/bb8a9cc4c648ba57b1ddb7a93977f67e.png" alt="Blogging Devs App Example" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/10/blogging-devs-1.gif"/></noscript>
<p>我们构建了一个React钩子，它允许我们在不阻塞浏览器UI的情况下逐渐加载数据，并提供进度数据来通知用户。</p><div class="code-block code-block-17">
<div class="blog-plug inline-plug react-plug" vwo-el-id="26283398190">
<h2 vwo-el-id="41600691720"><a href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener"> LogRocket </a>:全面了解您的生产React应用</h2><p>调试React应用程序可能很困难，尤其是当用户遇到难以重现的问题时。如果您对监视和跟踪Redux状态、自动显示JavaScript错误以及跟踪缓慢的网络请求和组件加载时间感兴趣，</p><a href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" vwo-el-id="19356441070">try LogRocket</a><p>. </p><a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="19356441380">
<img class="first-react-image alignnone size-full wp-image-46 jetpack-lazy-image jetpack-lazy-image--handled" src="../Images/f300c244a1a1cf916df8b4cb02bec6c6.png" vwo-el-id="18272717540" data-lazy-loaded="1" data-original-src="https://files.readme.io/27c94e7-Image_2017-06-05_at_9.46.04_PM.png"/>
</a>
<a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="19356441690">
<img class="second-react-image alignnone size-full wp-image-46 jetpack-lazy-image jetpack-lazy-image--handled" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" vwo-el-id="30720362350" data-lazy-loaded="1" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/>
</a>
<p vwo-el-id="28675660440" class="">LogRocket 结合了会话回放、产品分析和错误跟踪，使软件团队能够创建理想的web和移动产品体验。这对你来说意味着什么？</p>
<p>LogRocket不是猜测错误发生的原因，也不是要求用户提供截图和日志转储，而是让您回放问题，就像它们发生在您自己的浏览器中一样，以快速了解哪里出错了。</p>
<p>不再有嘈杂的警报。智能错误跟踪允许您对问题进行分类，然后从中学习。获得有影响的用户问题的通知，而不是误报。警报越少，有用的信号越多。</p>
<p vwo-el-id="28675660750">LogRocket Redux中间件包为您的用户会话增加了一层额外的可见性。LogRocket记录Redux存储中的所有操作和状态。</p>
<p vwo-el-id="28675661060">现代化您调试React应用的方式— <a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="40093418840">开始免费监控</a>。</p>
</div></div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
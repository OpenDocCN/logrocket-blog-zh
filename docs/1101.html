<html>
<head>
<title>Understanding lifetimes in Rust - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>理解Rust - LogRocket博客中的生命周期</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/understanding-lifetimes-in-rust/#0001-01-01">https://blog.logrocket.com/understanding-lifetimes-in-rust/#0001-01-01</a></blockquote><div><article class="article-post">
<p>所以你决定再次尝试解决生锈的问题。上一次进行得相当顺利，除了与<a href="https://blog.logrocket.com/introducing-the-rust-borrow-checker/" target="_blank" rel="noopener noreferrer">借款检查器</a>的一些小问题。但是你熬过来了，并且对它在这个过程中是如何运作的有了更好的理解。也许到头来一切都值了？</p>
<p/>
<p>你已经有了一些宏伟的计划，你不会让借款检查阻止你。当你把你的想法印在键盘上并转化成纯粹的铁锈时，你几乎可以感觉到能量在你的血管中流动。这一定是你久闻的甜蜜感觉。</p>
<p>您保存您的项目，开始编译过程，然后…</p>
<pre>error[E0597]: `x` does not live long enough
</pre>
<p>你叹气。不要再这样了。</p>
<p>你深吸一口气，放下肩膀，再次阅读错误信息。"活得不够久"这到底是什么意思？</p>
<p>你已经遇到了Rust的另一个特性:寿命。</p>
<h2 id="introducinglifetimes">生命周期简介</h2>
<p>Rust编译器使用生存期来跟踪引用的有效期。检查证明资料是借货检查员的主要职责之一。生存期有助于借用检查器确保您永远不会有无效的引用。</p>
<p>生存期注释使您能够告诉借用检查器引用的有效时间。在许多情况下，借用检查器可以推断出正确的寿命，并自行处理一切。但通常需要你的帮助才能弄明白。</p>
<p>在本指南中，我们将回顾生存期和注释的基础知识，并演示如何使用它们。我们还将看看您可能遇到的一些常见场景，并演示如何用生存期来解决它们。要继续学习，您应该对Rust和它的一些概念有一个基本的了解(比如借用检查器)，但是不要特别深入。</p>
<h3 id="lifetimeannotations">生存期注释</h3>
<p>在我们进一步讨论之前，先简要说明一下生命周期的符号，因为它与其他语言中的符号有些不同。</p>
<p>生存期由一个前导撇号标注，后跟一个变量名。当谈到泛型生存期时，我们经常使用单个小写字母，从<code>'a</code>、<code>'b</code>等开始。然而，如果更适合你，没有什么可以阻止你使用更长、更有解释力的名字。</p>
<h3 id="whyweneedlifetimes">为什么我们需要寿命</h3>
<p>如果这是一个如此奇怪的特性，那么我们为什么需要寿命呢？答案在于Rust的所有权模型。借用检查器负责分配和释放内存，并确保没有引用指向已被释放的内存。像借用一样，生存期在编译时被检查，这意味着如果借用检查器认为引用无效，你的程序就不能编译。</p>
<p>特别是，当从函数返回引用以及创建带有引用的结构时，记住生存期非常重要。这两种情况都很常见，不明白怎么回事就容易迷路。</p>
<h3 id="theexplanatoryexample">解释性的例子</h3>
<p>最终，生存期是一个范围问题。当值超出范围时，它们会被删除，删除后对它们的任何引用都是无效的。</p>
<p>演示生命周期的最简单的方法就是下面这个例子，它无耻地剽窃/改编自官方书籍中关于生命周期的章节。</p>
<pre>// this code sample does *not* compile
{
    let x;
    {                           // create new scope
        let y = 42;
        x = &amp;y;
    }                           // y is dropped

    println!("The value of 'x' is {}.", x);
}
</pre>
<p>这段代码有两个不同的范围。当内部作用域关闭时，<code>y</code>被删除。此时，即使<code>x</code>在外部作用域中仍然可用，引用也是无效的，因为它所指向的值被丢弃了；<code>x</code>所指的价值“活得不够久”</p>
<p>用生存期术语来说，我们可以说外部作用域有生存期<code>'outer</code>，内部作用域有生存期<code>'inner</code>。在这种情况下，<code>'outer</code>显然比<code>'inner</code>活得长。当<code>'inner</code>结束时，所有具有该生命周期的值都失效。</p>
<h3 id="lifetimeelision">一生的梦想</h3>
<p>当编写接受引用作为参数的函数时，编译器可以在许多情况下推断出正确的生存期，从而省去您手动写出它们的麻烦。当生存期注释是隐式的时，我们称之为生存期省略。</p>
<p>编译器使用三个规则来判断是否可以省略生存期注释。这本书关于生存期省略的部分详细讨论了这些规则，但简短的形式是，如果下列情况之一为真，您可以在函数中省略生存期注释。</p>
<ul>
<li>该函数不返回引用</li>
<li>只有一个参考输入参数</li>
<li>该函数是一个方法，将<code>&amp;self</code>或<code>&amp;mut self</code>作为第一个参数</li>
</ul>
<h2 id="examplesandcommonproblems">示例和常见问题</h2>
<p>一生是很难理解的，一墙的文字不太可能真正帮助你理解它们是如何工作的。当然，获得正确理解的最好方法是自己体验生命周期并解决问题。也就是说，举几个例子就够了。</p>
<h3 id="returningreferencesfromfunctions">从函数返回引用</h3>
<p>如果没有传入引用，就不能从函数返回引用。如果你尝试的话，你会发现函数一返回，引用就无效了，你的程序就不能编译了。你可以使用<code>'static</code>寿命，但这可能不是你想要的。这也超出了本文的范围，所以让我们暂时忘记它。</p><div class="code-block code-block-54">
<hr/>
<h3>更多来自LogRocket的精彩文章:</h3>

<hr/></div>
<p>如果你的函数只有一个引用参数，那么没有注释也没问题。所有输出参考将被赋予与输入参数相同的寿命。因此，即使没有显式的生存期注释，这个简单的函数也可以很好地编译。</p>
<pre>fn f(s: &amp;str) -&gt; &amp;str {
    s
}
</pre>
<p>但是，如果您添加另一个输入字符串参数(即使您不使用它)，您将突然无法编译这个:</p>
<pre>// this code sample does *not* compile
fn f(s: &amp;str, t: &amp;str) -&gt; &amp;str {
    if s.len() &gt; 5 { s } else { t }
}
</pre>
<p>这是因为自动生命周期注释是如何工作的。当一个函数接受多个引用时，每个引用都有自己的<br/>生存期。我们知道返回的引用必须是作为输入参数接收的引用之一，但我们不知道是哪一个。下面的<code>'???</code>用什么代替？</p>
<pre>// this code sample does *not* compile
fn f&lt;'a, 'b&gt;(s: &amp;'a str, t: &amp;'b str) -&gt; &amp;'??? str {
    if s.len() &gt; 5 { s } else { t }
}
</pre>
<p>假设您想在这个函数之外使用返回值。你认为它的寿命有多长？唯一的保证是，返回的引用至少在传递给函数的最短引用期间有效。这告诉编译器，这两个引用在较短的生存期内肯定有效。除此之外没有任何保证。</p>
<p>实现这一点的方法是给两个输入参数相同的生存期注释。这就是我们如何告诉编译器，只要这两个输入参数都有效，返回值也有效。</p>
<pre>fn f&lt;'a&gt;(s: &amp;'a str, t: &amp;'a str) -&gt; &amp;'a str {
    if s.len() &gt; 5 { s } else { t }
}
</pre>
<p>如果从一个接受多个输入生存期参数的函数返回一个引用，但是您确切地知道要返回哪个参数，那么您可以对该特定生存期进行注释。这样，各世之间的关系就不重要了。</p>
<pre>fn f&lt;'a, 'b&gt;(s: &amp;'a str, _t: &amp;'b str) -&gt; &amp;'a str {
    s
}
</pre>
<h3 id="structswithreferences">带有引用的struts</h3>
<p>结构中的引用可能会很麻烦。你最好避开它们，转而使用自己的价值观。这样，您就不需要担心引用失效和生存期不够长。以我的经验，这通常也是你想要的。</p>
<p>但是，在某些情况下，带有引用的结构正是您想要的—特别是，如果您想要创建其他内容的视图。使用带有引用的结构是将一些数据组织到一个包中的好方法，这样不用移动或复制数据就可以更容易地处理。这意味着原始数据源仍然可以在其他地方被引用，这样就免去了克隆数据的麻烦。</p>
<p>例如，假设您想要找到一个段落的第一句和最后一句，并将它们保存在struct <code>S</code>中。因为不想复制数据，所以需要使用引用，并给它们终身注释。</p>
<pre>struct S&lt;'a&gt; {
    first: &amp;'a str,
    last: &amp;'a str,
}
</pre>
<p>您可以使用这样的函数来填充该结构。为了简单起见，我们假设句号是唯一使用的句尾标点符号。如果段落是空的，返回<code>None</code>，如果只有一个句子，使用它作为第一个和最后一个句子。</p>
<pre>fn try_create(paragraph: &amp;str) -&gt; Option&lt;S&gt; {
    let mut sentences = paragraph.split('.').filter(|s| !s.is_empty());
    match (sentences.next(), sentences.next_back()) {
        (Some(first), Some(last)) =&gt; Some(S { first, last }),
        (Some(first), None) =&gt; Some(S { first, last: first }),
        _ =&gt; None,
    }
}
</pre>
<p>您不需要在函数签名中标注生存期，因为编译器可以为您找出它。在这种情况下，实际上只有一种选择:输入字符串的生存期。很整洁，是吧？</p>
<h2 id="summaryandfurtherreading">总结和进一步阅读</h2>
<p>这只是对生存期和生存期注释的粗略浏览。我们掩饰了很多关于生命周期如何工作的更好更复杂的细节，但是我们覆盖了足够多的领域，当你遇到问题时，你应该能够对它们进行推理。</p>
<p>因为生存期是Rust如此重要的一部分，我鼓励您阅读“<a href="https://doc.rust-lang.org/book/title-page.html" target="_blank" rel="noopener noreferrer">Rust编程语言</a>”的“<a href="https://doc.rust-lang.org/book/ch10-03-lifetime-syntax.html">用生存期验证引用</a>”一章，以获得更全面的介绍。</p>
<p>此外，如果你觉得自己已经对生命周期有了很好的理解，但还想更深入一点，可以看看Jon Gjengset的精彩视频，<br/><a href="https://youtu.be/rAl-9HwD858" target="_blank" rel="noopener noreferrer">Rust Crust:Lifetime Annotations</a>，他在视频中探索了一个需要多个显式生命周期注释的案例。他还从总体上对终身注释做了很好的介绍，因此值得一看。</p><div class="code-block code-block-29">
<div class="blog-plug inline-plug rust-plug"><h2><a href="https://lp.logrocket.com/blg/rust-signup" target="_blank">log rocket</a>:Rust应用的web前端的全面可见性</h2><p>调试Rust应用程序可能很困难，尤其是当用户遇到难以重现的问题时。如果您对监控和跟踪Rust应用程序的性能、自动显示错误、跟踪缓慢的网络请求和加载时间感兴趣，</p><a href="https://lp.logrocket.com/blg/rust-signup" target="_blank">try LogRocket</a><p>. </p><a class="signup" href="https://lp.logrocket.com/blg/rust-signup" target="_blank" rel="noopener noreferrer"><img class="alignnone size-full wp-image-46 jetpack-lazy-image" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/><noscript><img data-lazy-fallback="1" class="alignnone size-full wp-image-46" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/></noscript></a><p>LogRocket 就像是网络和移动应用程序的DVR，记录你的Rust应用程序上发生的一切。您可以汇总并报告问题发生时应用程序的状态，而不是猜测问题发生的原因。LogRocket还可以监控应用的性能，报告客户端CPU负载、客户端内存使用等指标。</p><p>现代化调试Rust应用的方式— <a class="signup" href="https://lp.logrocket.com/blg/rust-signup" target="_blank" rel="noopener noreferrer">开始免费监控</a>。</p></div>


</div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
<html>
<head>
<title>Email crates for Rust: lettre and imap - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>Rust的电子邮件箱:lettre和imap - LogRocket博客</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/email-crates-for-rust-lettre-and-imap/#0001-01-01">https://blog.logrocket.com/email-crates-for-rust-lettre-and-imap/#0001-01-01</a></blockquote><div><article class="article-post">
<p>如今，大多数web应用程序都需要以某种方式与电子邮件交互，因此良好的语言支持至关重要。Rust当然有处理电子邮件的基本支持，但我不会说它能覆盖所有的用例。这个生态系统非常小，目前还没有很好地支持async/await。</p>
<p/>
<p>也就是说，尝试现有的解决方案，看看它们是如何工作的，这是一个有用的练习。在本教程中，我们将向您展示如何在Rust中发送电子邮件和连接到IMAP服务器。</p>
<h2 id="makingemailswithlettre">用信件创建电子邮件</h2>
<p>发送电子邮件最流行的板条箱是<a href="https://crates.io/crates/lettre" target="_blank" rel="noopener noreferrer"> <code>lettre</code> </a>。截至目前，letter (0.9)的最新稳定版本不包括异步API，但0.10版本也有alpha版本，支持异步via <a href="https://crates.io/crates/tokio" target="_blank" rel="noopener noreferrer"> <code>tokio</code> </a>和<a href="https://crates.io/crates/async-std" target="_blank" rel="noopener noreferrer"> <code>async-std</code> </a>。</p>
<p>让我们先来看看没有异步的当前版本，然后使用alpha版本将代码移植到异步实现。</p>
<p>将以下内容添加到<code>Cargo.toml</code>即可开始。</p>
<pre>[dependencies]
lettre = "0.9"
lettre_email = "0.9"
</pre>
<p>在0.9版本中，我们需要使用<code>lettre_email</code>来创建电子邮件，然后使用<code>lettre</code>来发送它们，所以我们需要指定两者。</p>
<p>首先创建一个基本的电子邮件。</p>
<pre>use lettre_email::EmailBuilder;

fn main() {
    let email = EmailBuilder::new()
        .to("<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="670f020b0b0827021f060a170b024904080a">[email protected]</a>")
        .from("<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="dcb1b99cb4b9b0b0b3f2bfb3b1">[email protected]</a>")
        .subject("Example subject")
        .text("Hello, world!")
        .build()
        .unwrap();
}
</pre>
<p>这使用构建器模式来创建表示电子邮件的数据结构。如果我们想指定一个名字和一个地址，我们可以使用一个元组，就像这样:</p>
<pre>let email = EmailBuilder::new()
    .to(("<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="bed6dbd2d2d1fedbc6dfd3ced2db90ddd1d3">[email protected]</a>", "Alice Smith"))
    .from(("<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="a9c4cce9c1ccc5c5c687cac6c4">[email protected]</a>", "Bob Smith"))
    .subject("Example subject")
    .text("Hello, world!")
    .build()
    .unwrap();
</pre>
<p>添加HTML主体就像在构建器上调用相应的方法一样简单。</p>
<pre>let email = EmailBuilder::new()
    .to("<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="254d4049494a65405d44485549400b464a48">[email protected]</a>")
    .from("<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="402d250028252c2c2f6e232f2d">[email protected]</a>")
    .subject("Example subject")
    .html("&lt;h1&gt;Hello, world!&lt;/h1&gt;")
    .build()
    .unwrap();
</pre>
<p>假设我们想在电子邮件中发送附件。以下是将本地文件附加到电子邮件的方法:</p>
<pre>use lettre_email::mime;
use lettre_email::EmailBuilder;
use std::path::Path;

fn main() {
    let email = EmailBuilder::new()
        .to("<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="3e565b5252517e5b465f534e525b105d5153">[email protected]</a>")
        .from("<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="b5d8d0f5ddd0d9d9da9bd6dad8">[email protected]</a>")
        .subject("Example subject")
        .html("&lt;h1&gt;Hello, world!&lt;/h1&gt;")
        .attachment_from_file(
            &amp;Path::new("path/to/file.pdf"), // Path to file on disk
            Some("Cookie-recipe.pdf"),      // Filename to use in the email
            &amp;mime::APPLICATION_PDF,
        )
        .unwrap()
        .build()
        .unwrap();
}
</pre>
<p>或者，我们可以使用<code>attachment(...)</code> builder方法直接从内存中发送一个字节向量，而不是磁盘上的一个文件。</p>
<p>对于我没有提到的东西，还有一些构建器方法，所以如果你想对电子邮件做些别的事情，看看<code>lettre_email::EmailBuilder</code> 的<a href="https://docs.rs/lettre_email/0.9.4/lettre_email/struct.EmailBuilder.html" target="_blank" rel="noopener noreferrer">文档。</a></p>
<h2 id="sendingemailswithlettre">用信件发送电子邮件</h2>
<p>有了lettre，我们可以使用任何实现了<a href="https://docs.rs/lettre/0.9.3/lettre/trait.Transport.html" target="_blank" rel="noopener noreferrer"> <code>lettre::Transport</code> </a>特征的东西来发送我们之前创建的电子邮件。</p>
<p>最容易上手的交通工具是<a href="https://docs.rs/lettre/0.9.3/lettre/stub/struct.StubTransport.html" target="_blank" rel="noopener noreferrer"> <code>StubTransport</code> </a>。顾名思义，这只是一个存根，而不是真正的传输。这对测试非常有用。</p>
<pre>use lettre::stub::StubTransport;
use lettre::Transport;
use lettre_email::EmailBuilder;

fn main() {
    let email = EmailBuilder::new()
        .to("<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="dab2bfb6b6b59abfa2bbb7aab6bff4b9b5b7">[email protected]</a>")
        .from("<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="8ee3ebcee6ebe2e2e1a0ede1e3">[email protected]</a>")
        .subject("Example subject")
        .html("&lt;h1&gt;Hello, world!&lt;/h1&gt;")
        .build()
        .unwrap();

    let mut mailer = StubTransport::new_positive();

    let result = mailer.send(email.into());

    println!("{:?}", result);
}
</pre>
<p>因为我们使用了<code>new_positive()</code>来创建存根传输，所以<code>send(...)</code>方法总是成功的。如果你想强制发送失败，查看文档中的<code>StubTransport::new(...)</code>。</p>
<p>为了让它实际发送电子邮件，我们只需要用一个真正的传输来替换存根<code>mailer</code>。对于这个例子，让我们使用<code>SmtpTransport</code>。</p>
<p>因为SMTP传输比存根有更多的配置选项，所以它使用一个名为<code>SmtpClient</code>的构建器。</p>
<pre>use lettre::smtp::authentication::Credentials;
use lettre::{SmtpClient, Transport};
use lettre_email::EmailBuilder;

fn main() {
    let email = EmailBuilder::new()
        .to("<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="fc9499909093bc99849d918c9099d29f9391">[email protected]</a>")
        .from("<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="aac7cfeac2cfc6c6c584c9c5c7">[email protected]</a>")
        .subject("Example subject")
        .html("&lt;h1&gt;Hello, world!&lt;/h1&gt;")
        .build()
        .unwrap();

    let mut mailer = SmtpClient::new_simple("smtp.hello.com")
        .unwrap()
        .credentials(Credentials::new("username".into(), "password".into()))
        .transport();

    let result = mailer.send(email.into());

    println!("{:?}", result);
}
</pre>
<p>现在，这实际上将通过您连接的SMTP服务器发送电子邮件。在这里，我们使用<code>new_simple(...)</code>创建了一个客户端，它使用提供的域构建一个加密传输来验证TLS证书。这是创建<code>SmtpTransport</code>的推荐方式。幸运的是，这也是最简单的。之后，我们只是传递一些凭证，然后发送电子邮件，就像一个存根。</p>
<h2 id="portingtoasyncawait">移植到异步/等待</h2>
<p>如果你喜欢生活在风口浪尖上，你可能想尝试一下lettre的alpha版本的异步支持。lettre的0.10版本也将在一个特性标志下包含电子邮件生成器，所以我们不再需要使用<code>lettre_email</code>。</p>
<p>首先，改变你的<code>Cargo.toml</code>依赖。</p>
<pre>[dependencies]
lettre = { version = "0.10.0-alpha.2", features = ["builder", "tokio02-native-tls"] }
tokio = { version = "0.2", features = ["macros"] }
</pre>
<p>注意，我们启用了构建电子邮件和tokio运行时支持的可选特性。</p>
<p>现在，创建和发送电子邮件的代码如下所示:</p>
<pre>use lettre::transport::smtp::authentication::Credentials;
use lettre::{AsyncSmtpTransport, Message, Tokio02Connector, Tokio02Transport};

#[tokio::main]
async fn main() {
    env_logger::init();

    let email = Message::builder()
        .to("<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="b8d0ddd4d4d7f8ddc0d9d5c8d4dd96dbd7d5">[email protected]</a>".parse().unwrap())
        .from("<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="650800250d0009090a4b060a08">[email protected]</a>".parse().unwrap())
        .subject("Example subject")
        .body("Hello, world!")
        .unwrap();

    let mailer = AsyncSmtpTransport::&lt;Tokio02Connector&gt;::relay("smtp.hello.com")
        .unwrap()
        .credentials(Credentials::new("username".into(), "password".into()))
        .build();

    let result = mailer.send(email).await;

    println!("{:?}", result);
}
</pre>
<p>这里的主要变化是我们用<code>lettre::Message</code>代替了<code>lettre_email::EmailBuilder</code>，用<code>lettre::AsyncSmtpTransport</code>代替了<code>lettre::SmtpClient</code>。小心这个版本中的其他重大变化。例如，我们现在需要在将地址传递给消息构建器函数中的<code>to(...)</code>和<code>from(...)</code>之前解析地址。</p>
<p>另外，请注意lettre 0.10是一个alpha版本，还不支持0.9的所有功能。大多数应用程序不需要异步就可以了，所以在这个版本稳定之前，请继续使用我们之前看到的同步版本。</p>
<h2 id="imap">因特网邮件访问协议</h2>
<p>对于许多应用程序来说，发送电子邮件更加重要，但是您可能会遇到监控和交互接收电子邮件的需求。目前在Rust中最好的方法是使用<code><a href="https://crates.io/crates/imap" target="_blank" rel="noopener noreferrer">imap</a></code>板条箱。像lettre的当前版本一样，这个机箱不提供异步API。</p>
<p>首先，创建一个包含这些依赖项的新项目。</p>
<pre>[dependencies]
imap = "2"
native-tls = "0.2"
</pre>
<p>接下来，连接到IMAP服务器。</p><div class="code-block code-block-54">
<hr/>
<h3>更多来自LogRocket的精彩文章:</h3>

<hr/></div>
<pre>use native_tls::TlsConnector;

fn main() {
    let domain = "imap.example.com";
    let tls = TlsConnector::builder().build().unwrap();
    let client = imap::connect((domain, 993), domain, &amp;tls).unwrap();
}
</pre>
<p>我们需要将域作为要连接的地址传递一次，并作为验证TLS证书的域传递一次。</p>
<p>客户端未经身份验证，接下来让我们登录。</p>
<pre>let mut imap_session = client.login("<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="5038353c3c3f103528313d203c357e333f3d">[email protected]</a>", "password").unwrap();
</pre>
<p>现在我们有了一个<a href="https://docs.rs/imap/2.3.0/imap/struct.Session.html" target="_blank" rel="noopener noreferrer"> <code>imap::Session</code> </a>可以用来与我们的远程邮箱进行交互。</p>
<p>例如，让我们阅读收件箱中前五封邮件的正文。</p>
<pre>imap_session.select("INBOX").unwrap();

let messages = imap_session.fetch("1,2,3,4,5", "RFC822").unwrap();

for message in messages.iter() {
    if let Some(body) = message.body() {
        println!("{}", std::str::from_utf8(body).unwrap());
    } else {
        println!("Message didn't have a body!");
    }
}

imap_session.logout().unwrap();
</pre>
<p>首先，我们选择想要使用的邮箱—在本例中是<code>"INBOX"</code>。然后，我们获取收件箱中的消息号<code>1</code>到<code>5</code>。您在fetch方法中看到的<code>"RFC822"</code>决定了电子邮件正文的格式。一旦我们得到一个包含消息的响应，我们就对它们进行迭代，提取每个主体并打印出来。最后，我们通过注销来结束我们的会话。</p>
<p>参见<a href="https://docs.rs/imap/2.3.0/imap/types/struct.Fetch.html" target="_blank" rel="noopener noreferrer"> <code>Fetch</code>类型</a>以获取关于您还能从消息中得到什么的文档。</p>
<p>除了阅读电子邮件，让我们来看看如何管理您的邮箱。</p>
<p>要创建和删除它们:</p>
<pre>imap_session.create("work").unwrap();
imap_session.delete("work").unwrap();
</pre>
<p>如果您尝试创建<code>"INBOX"</code>或已存在的邮箱，创建将会失败。同样，如果您尝试删除<code>"INBOX"</code>或不存在的邮箱，删除将会失败。</p>
<p>最后，让我们看看如何监视邮箱的变化。</p>
<pre>imap_session.select("INBOX").unwrap();
imap_session.idle().unwrap().wait();
</pre>
<p>在这里，<code>idle()</code>会返回一个<a href="https://docs.rs/imap/2.3.0/imap/extensions/idle/struct.Handle.html" target="_blank" rel="noopener noreferrer"> <code>Handle</code> </a>让我们可以<code>wait()</code>上。这将一直阻止，直到选定的邮箱发生更改。也可以使用<code>wait_keepalive()</code>通过keepalive等待，使用<code>wait_with_timeout(Duration)</code>通过超时阻塞。在检测到更改之前一直阻塞的能力很有帮助，因为它可以帮助我们避免在消耗更多资源的较慢的循环中进行轮询。</p>
<p>在我看来，<code>imap</code>有一个很好的API，很容易让你理解。如果你通读了<code>Session</code>的文档，你会对这个箱子还能做什么有一个很好的想法。</p>
<p>请记住，这些示例中使用的大多数方法都会发出网络请求，因此它们可能会失败。为了简单起见，我大量使用了<code>unwrap()</code>,但是您绝对应该在实际应用程序中处理错误。</p>
<h2 id="conclusion">结论</h2>
<p>总的来说，Rust的电子邮件支持并不出色——到目前为止。不使用async/await发送电子邮件有最好的支持，所以如果这就是你所需要的，你可能已经可以使用它了。如果你想处理收到的电子邮件，那么<code>imap</code>箱是你最好的选择。</p>
<p>我在本文中没有提到POP3，这是有充分理由的Rust中对POP3的支持实际上是不存在的。</p>
<p>对于电子邮件绝对需要async/await的应用程序，我还不会使用Rust。请注意，如果您只想将这些板条箱放入异步应用程序中，您可以使用异步运行时提供的线程池实现。比如<a href="https://docs.rs/tokio/0.2.22/tokio/task/index.html#spawn_blocking" target="_blank" rel="noopener noreferrer"> <code>tokio::task::spawn_blocking(...)</code> </a>。</p>
<p>Rust中的大部分网络生态系统已经非常稳固，所以我相信电子邮件的故事会随着时间的推移而改善。在那之前，你可能最好对大量使用电子邮件的应用程序使用另一种语言。</p><div class="code-block code-block-29">
<div class="blog-plug inline-plug rust-plug"><h2><a href="https://lp.logrocket.com/blg/rust-signup" target="_blank">log rocket</a>:Rust应用的web前端的全面可见性</h2><p>调试Rust应用程序可能很困难，尤其是当用户遇到难以重现的问题时。如果您对监控和跟踪Rust应用程序的性能、自动显示错误、跟踪缓慢的网络请求和加载时间感兴趣，</p><a href="https://lp.logrocket.com/blg/rust-signup" target="_blank">try LogRocket</a><p>. </p><a class="signup" href="https://lp.logrocket.com/blg/rust-signup" target="_blank" rel="noopener noreferrer"><img class="alignnone size-full wp-image-46 jetpack-lazy-image" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/><noscript><img data-lazy-fallback="1" class="alignnone size-full wp-image-46" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/></noscript></a><p>LogRocket 就像是网络和移动应用程序的DVR，记录你的Rust应用程序上发生的一切。您可以汇总并报告问题发生时应用程序的状态，而不是猜测问题发生的原因。LogRocket还可以监控应用的性能，报告客户端CPU负载、客户端内存使用等指标。</p><p>现代化调试Rust应用的方式— <a class="signup" href="https://lp.logrocket.com/blg/rust-signup" target="_blank" rel="noopener noreferrer">开始免费监控</a>。</p></div>


</div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
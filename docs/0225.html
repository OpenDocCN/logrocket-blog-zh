<html>
<head>
<title>The best React inline style libraries  compared - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>最佳React内联样式库比较</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/the-best-react-inline-style-libraries-comparing-radium-aphrodite-emotion-849ef148c473/#0001-01-01">https://blog.logrocket.com/the-best-react-inline-style-libraries-comparing-radium-aphrodite-emotion-849ef148c473/#0001-01-01</a></blockquote><div><article class="article-post">
<p>在任何重要的React应用程序中，如果管理不当，CSS样式会成为一个问题。</p>
<p>全局样式定义、<code>!important</code>规则无处不在、重用组件时灵活性低都是这些问题的例子。</p>
<p>这导致了使用CSS文件的传统方法的替代方法。例如，这里有一个关于<a class="markup--anchor markup--p-anchor" href="https://blog.logrocket.com/the-best-styling-in-react-tutorial-youve-ever-seen-676f1284b945" target="_blank" rel="noopener noreferrer" data-href="https://blog.logrocket.com/the-best-styling-in-react-tutorial-youve-ever-seen-676f1284b945">三种造型方法</a>的好帖子。</p>
<p>这篇文章是关于内联样式的。然而，我不会谈论<a class="markup--anchor markup--p-anchor" href="https://zhenyong.github.io/react/tips/inline-styles.html" target="_blank" rel="noopener noreferrer" data-href="https://zhenyong.github.io/react/tips/inline-styles.html">它们是什么</a>或<a class="markup--anchor markup--p-anchor" href="https://www.engineyard.com/blog/inline-styles-yes-or-no" target="_blank" rel="noopener noreferrer" data-href="https://www.engineyard.com/blog/inline-styles-yes-or-no">你是否应该使用它们</a>。</p>
<p>我将讨论将帮助您在React应用程序中使用内联样式的库——这些库允许您使用不直接支持的功能(如媒体查询)。</p>
<p>我来比较一下:</p>

<p>此列表是不考虑以下库的结果:</p>
<ul>
<li>似乎不再被维护了</li>
<li>似乎不受欢迎</li>
<li>不要将内联样式作为对象或字符串文字使用</li>
</ul>
<p>然而，和大多数这类文章一样，你可能不同意这个列表，所以请随意发表你最喜欢的库和它的特别之处的评论。</p>
<p>使用其中的每一个库，我将使用以下CSS规则来设计div元素的样式:</p>
<pre>background-color: #00ffff;
text-align: center;
width: 100%;
padding: 20px;
:hover {
  color: #ffffff;
  cursor: 'pointer'
}
@media (max-width: 700px) { 
  background-color: #ff0000;
}</pre>
<p>这将是结果:</p>
<p><img decoding="async" class="graf-image jetpack-lazy-image" src="../Images/d080fdb19ed6545af4e9ee97200b89ce.png" data-height="100" data-image-id="0*v1FfEhUCaYQ3XPy3" data-width="747" data-lazy-src="https://storage.googleapis.com/blog-images-backup/0*v1FfEhUCaYQ3XPy3?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://storage.googleapis.com/blog-images-backup/0*v1FfEhUCaYQ3XPy3"/></p><noscript><img data-lazy-fallback="1" decoding="async" class="graf-image" src="../Images/d080fdb19ed6545af4e9ee97200b89ce.png" data-height="100" data-image-id="0*v1FfEhUCaYQ3XPy3" data-width="747" data-original-src="https://storage.googleapis.com/blog-images-backup/0*v1FfEhUCaYQ3XPy3"/></noscript>
<p>在本文的最后，您会发现一个总结了这些库的特性的表格。</p>
<p>让我们从镭开始。</p>
<h2>镭</h2>
<p>在这里介绍的三个库中，<a class="markup--anchor markup--p-anchor" href="https://github.com/FormidableLabs/radium" target="_blank" rel="noopener noreferrer" data-href="https://github.com/FormidableLabs/radium">镭</a>是最受欢迎的一个，涉及<a class="markup--anchor markup--p-anchor" href="https://github.com/FormidableLabs/radium" target="_blank" rel="noopener noreferrer" data-href="https://github.com/FormidableLabs/radium"> GitHub stars </a>、<a class="markup--anchor markup--p-anchor" href="https://github.com/FormidableLabs/radium/issues" target="_blank" rel="noopener noreferrer" data-href="https://github.com/FormidableLabs/radium/issues"> issues </a>和<a class="markup--anchor markup--p-anchor" href="https://stackoverflow.com/search?q=radium" target="_blank" rel="noopener noreferrer" data-href="https://stackoverflow.com/search?q=radium"> StackOverflow questions </a>。</p>
<p>如果你已经有一些内联样式作为对象文字，你不需要修改它们来使用Radium。</p>
<p>例如，下面是对应于前面显示的CSS规则的样式对象:</p>
<pre>const styles = {
  panel: {
    backgroundColor: '#00ffff',
    textAlign: 'center',
    width: '100%',
    padding: '20px',
    ':hover': {
      color: '#ffffff',
      cursor: 'pointer'
    },
    '@media (max-width: 700px)': {
      backgroundColor: '#ff0000'
    }
  }
};</pre>
<p>除了悬停和媒体规则之外，它看起来像一个常规的内联样式，普通的内联样式不支持这些规则。</p>
<p>如果将此样式应用于组件:</p>
<pre>class App extends Component {
  render() {
    return (
      &lt;div style={styles.panel}&gt;
        React rocks!
      &lt;/div&gt;
    );
  }
}</pre>
<p>并运行应用程序，<code>div</code>元素将改变其样式，但它将忽略悬停和媒体规则。实际上，这个警告会显示在控制台中:</p>
<pre>Warning: Unsupported style property @media (max-width: 700px). Did you mean @media (maxWidth: 700px)?</pre>
<p>要使用镭，你首先要安装它:</p>
<pre>npm install --save radium</pre>
<p>然后导入或要求它:</p>
<pre>import Radium from 'radium';
// Or const Radium = require('radium');</pre>
<p>镭是一种<a class="markup--anchor markup--p-anchor" href="https://reactjs.org/docs/higher-order-components.html" target="_blank" rel="noopener noreferrer" data-href="https://reactjs.org/docs/higher-order-components.html">高阶成分(HOC) </a>。</p>
<p>它处理render方法中指定的组件的<code>style</code>属性，添加处理程序来更新交互样式(如hover)的状态，应用供应商前缀，合并样式等等。</p>
<p>你可以这样使用它:</p>
<pre>class App extends Component {
// ...
}
export default Radium(App);
// Or App = Radium(App);</pre>
<p>或者用<a class="markup--anchor markup--p-anchor" href="https://medium.com/@jihdeh/es7-decorators-in-reactjs-22f701a678cd" target="_blank" rel="noopener noreferrer" data-href="https://medium.com/@jihdeh/es7-decorators-in-reactjs-22f701a678cd"> ES7装饰者</a>:</p>
<pre>@Radium
class App extends Component {
// ...
}</pre>
<p>通常这就足够了，但是如果你使用媒体查询、<a class="markup--anchor markup--p-anchor" href="https://github.com/FormidableLabs/radium/tree/master/docs/api#keyframes" target="_blank" rel="noopener noreferrer" data-href="https://github.com/FormidableLabs/radium/tree/master/docs/api#keyframes">关键帧</a>或者一些镭插件，你还需要使用<a class="markup--anchor markup--p-anchor" href="https://github.com/FormidableLabs/radium/tree/master/docs/api#styleroot-component" target="_blank" rel="noopener noreferrer" data-href="https://github.com/FormidableLabs/radium/tree/master/docs/api#styleroot-component"> StyleRoot </a>组件来包装你的应用程序的顶层组件:</p>
<pre>ReactDOM.render(
    &lt;StyleRoot&gt;&lt;App /&gt;&lt;/StyleRoot&gt;,
    document.getElementById('root')
);</pre>
<p id="db74" class="graf graf--p graf-after--pre">现在，如果您运行应用程序，并检查<code>div</code>元素，您将看到:</p>
<pre>&lt;div id="root"&gt;
    &lt;div data-radium="true"&gt;
        &lt;div class="rmq-f7d82907" data-radium="true"
              style="background-color: rgb(0, 255, 255); text-align: center; width: 100%; padding: 20px;"&gt;
            React + Radium rocks!
        &lt;/div&gt;
        &lt;style&gt;
            @media (max-width: 700px){ 
                 .rmq-f7d82907{ background-color: #ff0000 !important; }
            }
        &lt;/style&gt;
    &lt;/div&gt;
&lt;/div&gt;</pre>
<p>注意，对于媒体查询，它在一个<code>style</code>元素中创建了一个具有随机名称的新CSS类。<a class="markup--anchor markup--p-anchor" href="https://github.com/FormidableLabs/radium/tree/master/docs/guides#media-queries" target="_blank" rel="noopener noreferrer" data-href="https://github.com/FormidableLabs/radium/tree/master/docs/guides#media-queries">根据文档</a>，它这样做是为了让媒体查询与<a class="markup--anchor markup--p-anchor" href="https://github.com/FormidableLabs/radium/tree/master/docs/api#configmatchmedia" target="_blank" rel="noopener noreferrer" data-href="https://github.com/FormidableLabs/radium/tree/master/docs/api#configmatchmedia">服务器端渲染</a>一起正确工作。</p>
<p>悬停效应呢？</p>
<p>当鼠标悬停在元素上时，它的<code>style</code>属性会更新以添加指定的悬停样式:</p>
<p><img decoding="async" class="graf-image jetpack-lazy-image" src="../Images/1e2a9cfae64451c9db52239612b11aab.png" data-height="66" data-image-id="0*d_QKsP2FHAOZqFuK" data-width="800" data-lazy-src="https://storage.googleapis.com/blog-images-backup/0*d_QKsP2FHAOZqFuK?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://storage.googleapis.com/blog-images-backup/0*d_QKsP2FHAOZqFuK"/></p><noscript><img data-lazy-fallback="1" decoding="async" class="graf-image" src="../Images/1e2a9cfae64451c9db52239612b11aab.png" data-height="66" data-image-id="0*d_QKsP2FHAOZqFuK" data-width="800" data-original-src="https://storage.googleapis.com/blog-images-backup/0*d_QKsP2FHAOZqFuK"/></noscript>
<p>您还可以在<code>style</code>属性中指定一组样式。当您需要根据属性值覆盖某些样式时，这很方便，例如:</p>
<pre>const styles = {
  panel: {
    ...
  },
  alert: {
     backgroundColor: 'red'
  }
};

class App extends Component {
  render() {
    return (
      &lt;div style={[
            styles.panel,
            this.props.alert &amp;&amp; styles.alert
        ]}
      &gt;
        React + Radium rocks!
      &lt;/div&gt;
    );
  }
}</pre>
<p>还有一个呈现样式元素的<a class="markup--anchor markup--p-anchor" href="https://github.com/FormidableLabs/radium/tree/master/docs/api#style-component" target="_blank" rel="noopener noreferrer" data-href="https://github.com/FormidableLabs/radium/tree/master/docs/api#style-component"> <code>Style</code>组件</a>，例如，它帮助您将CSS规则添加到<code>body</code>元素或应用于其他元素的范围类。</p>
<p>例如，这个:</p>
<pre>&lt;div className="local-scope" style={styles.panel}&gt;
    React + Radium &lt;span&gt;rocks!&lt;/span&gt;
      
    &lt;Style
        scopeSelector=".local-scope"
        rules={{
            fontWeight: 'bold',
            span: {
              textTransform: 'uppercase'
          }
        }}
    /&gt;
    &lt;Style rules={{
          body: {
              backgroundColor: 'black'
          }
        }}
    /&gt;
&lt;/div&gt;</pre>
<p>将呈现:</p>
<pre>&lt;div class="rmq-f7d82907 local-scope" data-radium="true" style="background-color: rgb(0, 255, 255); text-align: center; width: 100%; padding: 20px;"&gt;
    React + Radium &lt;span&gt;rocks!&lt;/span&gt;

    &lt;style&gt;
        .local-scope {
            font-weight: bold;
        }
        .local-scope span {
            text-transform: uppercase;
        }
    &lt;/style&gt;
    &lt;style&gt;
        body {
            background-color: black;
        }
    &lt;/style&gt;
&lt;/div&gt;</pre>
<p id="261a" class="graf graf--p graf-after--figure">另一方面，Radium的一个缺点是只支持三种状态:<code>:hover</code>、<code>:foucs</code>和<code>:active</code>，如果您的组件中有不止一个元素使用其中一种状态，<a class="markup--anchor markup--p-anchor" href="https://github.com/FormidableLabs/radium/tree/master/docs/faq#why-does-the-browser-state-of-a-child-element-not-reset-after-unmounting-and-remounting" target="_blank" rel="noopener noreferrer" data-href="https://github.com/FormidableLabs/radium/tree/master/docs/faq#why-does-the-browser-state-of-a-child-element-not-reset-after-unmounting-and-remounting">您需要提供一个惟一的密钥道具</a>。</p>
<p id="ae8c" class="graf graf--p graf-after--p">甚至有一个函数允许您查询这些状态，<a class="markup--anchor markup--p-anchor" href="https://github.com/FormidableLabs/radium/tree/master/docs/api#getstate" target="_blank" rel="noopener noreferrer" data-href="https://github.com/FormidableLabs/radium/tree/master/docs/api#getstate"> getState </a>:</p>
<pre>&lt;div style={styles.panel}&gt;
React + Radium rocks!
{ Radium.getState(this.state, null, ':hover') ? (
&lt;span&gt;Yeah!&lt;/span&gt;
    )
    : null
  }
&lt;/div&gt;</pre>
<p>然而，这意味着<a class="markup--anchor markup--p-anchor" href="https://github.com/FormidableLabs/radium/tree/master/docs/faq#how-do-i-use-pseudo-selectors-like-checked-last-before-or-after" target="_blank" rel="noopener noreferrer" data-href="https://github.com/FormidableLabs/radium/tree/master/docs/faq#how-do-i-use-pseudo-selectors-like-checked-last-before-or-after">你必须手动实现伪选择器</a>，比如<code>:checked</code>、<code>:last</code>、<code>:before</code>或<code>:after</code>。</p>
<p>另一个缺失的功能是对@font-face 的<a class="markup--anchor markup--p-anchor" href="https://github.com/FormidableLabs/radium/issues/716" target="_blank" rel="noopener noreferrer" data-href="https://github.com/FormidableLabs/radium/issues/716">支持。然而，Radium作为一个</a><a class="markup--anchor markup--p-anchor" href="https://github.com/FormidableLabs/radium/tree/master/docs/api#plugins" target="_blank" rel="noopener noreferrer" data-href="https://github.com/FormidableLabs/radium/tree/master/docs/api#plugins">插件</a>实现了它几乎所有的功能，你也可以使用插件API来实现定制的功能，比如<code>@font-faces</code>。</p>
<p>镭插件是一个接受一个<code>PluginConfig</code>对象并返回一个<code>PluginResult</code>对象的函数，它为每个具有样式属性的渲染元素调用一次。</p>
<p><a class="markup--anchor markup--p-anchor" href="https://github.com/FormidableLabs/radium/tree/master/src/plugins" target="_blank" rel="noopener noreferrer" data-href="https://github.com/FormidableLabs/radium/tree/master/src/plugins">这里</a>你可以看看镭包含的插件的源代码。在<a class="markup--anchor markup--p-anchor" href="https://github.com/ianobermiller" target="_blank" rel="noopener noreferrer" data-href="https://github.com/ianobermiller">伊恩·奥博米勒</a>的<a class="markup--anchor markup--p-anchor" href="https://github.com/ianobermiller/radium-plugin-friendly-pseudos" target="_blank" rel="noopener noreferrer" data-href="https://github.com/ianobermiller/radium-plugin-friendly-pseudos">这个库</a>中，你可以找到另一个插件的例子。</p>
<p>下面是用镭实现的基本例子:</p>
<p>阿佛洛狄忒</p>
<h2>Aphrodite 是另一个流行的用JavaScript编写CSS的库，但它采用的方法与Radium略有不同。</h2>
<p>首先，安装它:</p>
<p>同样，您有一个带有应用程序样式的对象:</p>
<pre>npm install --save aphrodite</pre>
<p>但是这一次，您必须将这个对象传递给函数<code>StyleSheet.create</code>:</p>
<pre>{
  panel: {
    backgroundColor: '#00ffff',
    textAlign: 'center',
    width: '100%',
    padding: '20px',
    ':hover': {
      color: '#ffffff',
      cursor: 'pointer'
    },
    '@media (max-width: 700px)': {
      backgroundColor: '#ff0000'
    }
  }
}</pre>
<p>反过来，来自该对象的样式被传递给<code>css</code>函数，结果在组件的<code>className</code>属性中使用:</p>
<pre>const styles = StyleSheet.create({
  panel: {
    backgroundColor: '#00ffff',
    textAlign: 'center',
    width: '100%',
    padding: '20px',
    ':hover': {
      color: '#ffffff',
      cursor: 'pointer'
    },
    '@media (max-width: 700px)': {
      backgroundColor: '#ff0000'
    }
  }
});</pre>
<p>请注意，Aphrodite使用的是<code>className</code>属性，而不是<code>style</code>属性。</p>
<pre>import { StyleSheet, css } from 'aphrodite';

const styles = //...

class App extends Component {
  render() {
    return (
      &lt;div className={css(styles.panel)}&gt;
        React + Aphrodite rocks!
      &lt;/div&gt;
    );
  }
}</pre>
<p>为了理解这一点，如果你打印出<code>css(styles.panel)</code>的结果，你将得到一个类名。在我的例子中，我得到了<code>panel_w3twfb</code>。</p>
<p>如果您看一下由<code>StyleSheet.create</code>返回的对象，您会看到类似这样的内容:</p>
<p>该函数返回一个对象，该对象包装了CSS规则并添加了一个<code>_name</code>属性，其值与<code>css</code>函数返回的值相同。</p>
<pre>{
  panel: {
    _len:188,
    _name:"panel_w3twfb",
    _definition: {
      backgroundColor:"#00ffff",
      textAlign:"center",
      width:"100%",
      padding:"20px",
      ":hover": {
        color:"#ffffff",
        cursor:"pointer"
      },
      "@media (max-width: 700px)": {
        backgroundColor:"#ff0000"
      }
    }
  }
}</pre>
<p>使用浏览器的检查工具，您将看到这个<code>panel_w3twfb</code>类的定义:</p>
<p>默认情况下，阿芙罗狄蒂追加！对所有CSS规则都很重要。如果你不想这样，你唯一需要做的就是导入<code>aphroidte/no-important</code>而不是<code>aphrodite</code>:</p>
<pre>.panel_w3twfb {
background-color: rgb(0, 255, 255) !important;
text-align: center !important;
width: 100% !important;
padding: 20px !important;
}</pre>
<p>此外，当标志<code>NODE_ENV</code>被设置为<code>production</code>或者如果您在<code>StyleSheet.create</code>之前调用<code>minify(true)</code>:</p>
<pre>import { StyleSheet, css } from 'aphrodite/no-important';</pre>
<p>Aphrodite将只保留CSS类名称中的哈希。在这种情况下，<code>w3twfb</code>。</p>
<pre>import { StyleSheet, css, minify } from 'aphrodite';
minify(true);
const styles = StyleSheet.create({
//...
});</pre>
<p>但是这个班在哪里？它没有被定义在<code>div</code>元素旁边或者文档体中的任何地方。</p>
<p>更多来自LogRocket的精彩文章:</p><div class="code-block code-block-54">
<hr/>
<h3>Aphrodite在文档的<code>&lt;head&gt;</code>元素中创建一个<code>style</code>元素来放置它生成的样式:</h3>

<hr/></div>
<p>但是，您可以用<code>data-aphrodite</code>属性创建一个样式元素，Aphrodite将使用它而不是创建一个。</p>
<pre>&lt;html lang="en"&gt;
  &lt;head&gt;
    ...
    &lt;style type="text/css" data-aphrodite=""&gt;&lt;/style&gt;
  &lt;/head&gt;
  &lt;body&gt;
    ...
  &lt;/body&gt;
&lt;/html&gt;</pre>
<p>Aphrodite将缓冲对样式的写入，以避免许多DOM修改。如果您在<code>componentDidMount</code>或<code>componentDidUpdate</code>中计算元素的尺寸，<a class="markup--anchor markup--p-anchor" href="https://github.com/Khan/aphrodite#style-injection-and-buffering" target="_blank" rel="noopener noreferrer" data-href="https://github.com/Khan/aphrodite#style-injection-and-buffering">文档建议</a>使用<code>setTimeout</code>或<code>flushToStyleTag</code>来确保所有样式都被正确注入。</p>
<p>那悬停风格和媒体询问呢？</p>
<p>他们还补充道:</p>
<p><img decoding="async" class="progressiveMedia-image js-progressiveMedia-image jetpack-lazy-image" src="../Images/be9600f6430356d268b6289e8e67746d.png" data-src="https://storage.googleapis.com/blog-images-backup/0*3dhxHi-zwifc_Y6d" data-lazy-src="https://storage.googleapis.com/blog-images-backup/0*3dhxHi-zwifc_Y6d?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://storage.googleapis.com/blog-images-backup/0*3dhxHi-zwifc_Y6d"/></p>
<pre>.panel_w3twfb:hover {
  color: rgb(255, 255, 255) !important;
  cursor: pointer !important;
}
@media (max-width: 700px) {
  .panel_w3twfb {
    background-color: rgb(255, 0, 0) !important;
  }
}</pre>
<p>与镭类似，您可以组合多种风格:</p><noscript><img data-lazy-fallback="1" decoding="async" class="progressiveMedia-image js-progressiveMedia-image" src="../Images/be9600f6430356d268b6289e8e67746d.png" data-src="https://storage.googleapis.com/blog-images-backup/0*3dhxHi-zwifc_Y6d" data-original-src="https://storage.googleapis.com/blog-images-backup/0*3dhxHi-zwifc_Y6d"/></noscript>
<p id="0a31" class="graf graf--p graf-after--figure">也和镭一样，对嵌套的支持有限。例如，<a class="markup--anchor markup--p-anchor" href="https://github.com/Khan/aphrodite/issues/319" target="_blank" rel="noopener noreferrer" data-href="https://github.com/Khan/aphrodite/issues/319">本期</a>展示了一个类似于Saas的类的例子，它包含了两个类，<code>jump-btn</code>和<code>disabled</code>:</p>
<pre>const styles = StyleSheet.create({
  panel: {
    ...
  },
  alert: {
     backgroundColor: 'red'
  }
});

class App extends Component {
  render() {
    return (
      &lt;div style={css(
            styles.panel,
            this.props.alert &amp;&amp; styles.alert
        )}
      &gt;
        React + Aphrodite rocks!
      &lt;/div&gt;
    );
  }
}</pre>
<p>因为只能嵌套伪选择器和媒体查询，所以必须用Aphrodite以如下方式编写:</p>
<pre>.jump-btn {
  width: 32px;
  height: 32px;
  background: url('jump_btn.png') no-repeat 0 0;
  &amp;.disabled {
    background-position: -32px 0;
  }
  ...
}</pre>
<p>然而，与镭不同的是，阿佛洛狄忒支持<a class="markup--anchor markup--p-anchor" href="https://github.com/Khan/aphrodite#font-faces" target="_blank" rel="noopener noreferrer" data-href="https://github.com/Khan/aphrodite#font-faces">字型面孔</a>:</p>
<pre>const styles = StyleSheet.create({
  jumpBtn: {
    width: 32,
    height: 32,
    background: 'background: url('jump_btn.png') no-repeat 0 0',
  },
  disabled: {
    backgroundPosition: '-32px 0',
  }
});
const classes = css(styles.jumpBtn, isDisabled &amp;&amp; styles.disabled);</pre>
<p>本机伪元素前后(注意，内容属性要求字符串值内有双引号或单引号):</p>
<pre>const raleway = {
    fontFamily: "Raleway",
    fontStyle: "normal",
    fontWeight: "normal",
    src: "local('Raleway'), local('Raleway-Regular'), url(https://fonts.gstatic.com/s/raleway/v12/1Ptug8zYS_SKggPNyCMIT5lu.woff2) format('woff2')"
};
const styles = StyleSheet.create({
  panel: {
    fontFamily: [raleway, 'sans-serif']
    ...
  }
});</pre>
<p>另一方面，阿芙罗狄蒂不像镭那样提供API。诚然，它以不同的方式工作，但它可能对某些情况有所帮助(例如，见<a class="markup--anchor markup--p-anchor" href="https://github.com/Khan/aphrodite/issues/239" target="_blank" rel="noopener noreferrer" data-href="https://github.com/Khan/aphrodite/issues/239">这里</a>和<a class="markup--anchor markup--p-anchor" href="https://github.com/Khan/aphrodite/issues/306" target="_blank" rel="noopener noreferrer" data-href="https://github.com/Khan/aphrodite/issues/306">这里</a>)。</p>
<pre>const styles = StyleSheet.create({
  panel: {
    ...
    ':after': {
        content: '" Aphrodite!"',
    }
});</pre>
<p>它提供了一个<a class="markup--anchor markup--p-anchor" href="https://github.com/Khan/aphrodite#advanced-extensions" target="_blank" rel="noopener noreferrer" data-href="https://github.com/Khan/aphrodite#advanced-extensions">扩展机制</a>，但是目前，它只允许你基于指定的样式生成新的选择器(它是库用来处理媒体查询和伪元素/类的<a class="markup--anchor markup--p-anchor" href="https://github.com/Khan/aphrodite/blob/master/src/generate.js" target="_blank" rel="noopener noreferrer" data-href="https://github.com/Khan/aphrodite/blob/master/src/generate.js">)。</a></p>
<p>这里你可以看到用阿芙罗狄蒂实现的基本例子:</p>
<p>情绪</p>
<p>最近，<a class="markup--anchor markup--p-anchor" href="https://medium.com/@kentcdodds" target="_blank" rel="noopener noreferrer" data-href="https://medium.com/@kentcdodds"> Kent C. Dodds </a>弃用了<a class="markup--anchor markup--p-anchor" href="https://github.com/paypal/glamorous" target="_blank" rel="noopener noreferrer" data-href="https://github.com/paypal/glamorous">魅力</a>(一个图书馆，否则会进入这个名单)而支持<a class="markup--anchor markup--p-anchor" href="https://github.com/emotion-js/emotion" target="_blank" rel="noopener noreferrer" data-href="https://github.com/emotion-js/emotion">情感</a>。他的理由:</p>
<h2>情感可以做光鲜亮丽所能做的一切</h2>
<p>情感比魅力能做的更多</p>
<ol>
<li>情感比魅力来得快</li>
<li>情感比魅力小</li>
<li>告诉我们这个图书馆的一些情况，对吗？</li>
<li>首先，安装它:</li>
</ol>
<p>再来一次，从包含应用程序样式的对象开始:</p>
<p>你只需要修改<code>:hover</code>伪类的格式。出发地:</p>
<pre>npm install --save emotion</pre>
<p>收件人:</p>
<pre>{
  panel: {
    backgroundColor: '#00ffff',
    textAlign: 'center',
    width: '100%',
    padding: '20px',
    ':hover': {
      color: '#ffffff',
      cursor: 'pointer'
    },
    '@media (max-width: 700px)': {
      backgroundColor: '#ff0000'
    }
  }
}</pre>
<p>情感类似于阿芙罗狄蒂。两者都使用了<code>className</code>属性和一个名为<code>css</code>的函数:</p>
<pre>':hover': {
  ...
}</pre>
<p><code>css</code>函数返回自动生成的CSS类的名称。在我的例子中，它返回了<code>css-4k75yl</code>。</p>
<pre>'&amp;:hover': {
  ...
}</pre>
<p>呈现的HTML如下所示:</p>
<pre>import { css } from 'emotion';

const styles = {
  panel: {
    // ...
  }
};

class App extends Component {
  render() {
    return (
      &lt;div className={css(styles.panel)}&gt;
        React + Emotion rocks!
      &lt;/div&gt;
    );
  }
}</pre>
<p>您可以在文档的<code>&lt;head&gt;</code>元素中找到这个类的定义:</p>
<p>或者，您还可以向style对象添加一个<a class="markup--anchor markup--p-anchor" href="https://emotion.sh/docs/labels" target="_blank" rel="noopener noreferrer" data-href="https://emotion.sh/docs/labels">标签属性</a>，以便向生成的CSS类追加一个自定义名称。</p>
<pre>&lt;div class="css-4k75yl"&gt;
  React + Emotion rocks!
&lt;/div&gt;</pre>
<p>例如，下面的定义:</p>
<pre>&lt;style data-emotion=""&gt;
  .css-4k75yl {
      background-color:#00ffff;
      text-align:center;
      width:100%;
      padding:20px;
  }
&lt;/style&gt;
&lt;style data-emotion=""&gt;
  .css-4k75yl:hover {
      color:#ffffff;cursor:pointer;
  }
&lt;/style&gt;
&lt;style data-emotion=""&gt;
  @media (max-width:700px) {
      .css-4k75yl {
          background-color:#ff0000;
      }
  }
&lt;/style&gt;</pre>
<p>会产生类名<code>css-4k75yl-my-name</code>。</p>
<p>所以这样看来，情感与阿芙罗狄蒂并没有什么不同:</p>
<pre>const styles = {
  panel: {
    backgroundColor: '#00ffff',
    textAlign: 'center',
    width: '100%',
    padding: '20px',
    '&amp;:hover': {
      color: '#ffffff',
      cursor: 'pointer'
    },
    '@media (max-width: 700px)': {
      backgroundColor: '#ff0000'
    },
    label: 'my-name'
  }
};</pre>
<p><img decoding="async" class="progressiveMedia-image js-progressiveMedia-image jetpack-lazy-image" src="../Images/ee5641289f0eef56223a3cb60acdbc4c.png" data-src="https://storage.googleapis.com/blog-images-backup/0*S7di8686qhxmZIPu" data-lazy-src="https://storage.googleapis.com/blog-images-backup/0*S7di8686qhxmZIPu?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://storage.googleapis.com/blog-images-backup/0*S7di8686qhxmZIPu"/></p>
<p>但是关于这个图书馆，它有比镭和阿佛洛狄忒更多的特征。</p>
<p>例如，有了情感，你还有两种方式来设计组件。</p><noscript><img data-lazy-fallback="1" decoding="async" class="progressiveMedia-image js-progressiveMedia-image" src="../Images/ee5641289f0eef56223a3cb60acdbc4c.png" data-src="https://storage.googleapis.com/blog-images-backup/0*S7di8686qhxmZIPu" data-original-src="https://storage.googleapis.com/blog-images-backup/0*S7di8686qhxmZIPu"/></noscript>
<p>代替对象文字，您将样式指定为一个<a class="markup--anchor markup--p-anchor" href="https://wesbos.com/tagged-template-literals/" target="_blank" rel="noopener noreferrer" data-href="https://wesbos.com/tagged-template-literals/">标记的模板</a>:</p>
<p>请注意，语法完全不同。这更像是CSS:</p>
<p>规则的名称不是大小写混合的</p>
<pre>const style = css`
  background-color: #00ffff;
  text-align: center;
  width: 100%;
  padding 20px;
  &amp;:hover {
    color: #ffffff;
    cursor: pointer;
  }
  @media (max-width: 700px) {
    background-color: #ff0000;
  }
`;

class App extends React.Component {
  render() {
    return (
      &lt;div className={style}&gt;
        React + Emotion rocks!
      &lt;/div&gt;
    );
  }
}</pre>
<p>不使用引号</p>
<ul>
<li>规则用分号分隔</li>
<li>另一方面，您也可以使用<a class="markup--anchor markup--p-anchor" href="https://emotion.sh/docs/styled" target="_blank" rel="noopener noreferrer" data-href="https://emotion.sh/docs/styled">样式函数</a>来样式化元素或组件。</li>
<li>为此，首先，您需要安装<code>react-emotion</code>(或者<code>preact-emotion</code>，如果您使用Preact的话):</li>
</ul>
<p>然后，调用该函数，首先传递HTML标记或React/Preact组件，然后传递带有以下样式的对象文字:</p>
<p>或者模板文字:</p>
<pre>npm install --save react-emotion</pre>
<p>并像使用其他组件一样使用新样式组件:</p>
<pre>import styled from 'react-emotion';

const MyDiv = styled('div')({
    backgroundColor: '#00ffff',
    textAlign: 'center',
    width: '100%',
    padding: '20px',
    '&amp;:hover': {
      color: '#ffffff',
      cursor: 'pointer'
    },
    '@media (max-width: 700px)': {
      backgroundColor: '#ff0000'
    }
  }
);</pre>
<p>当然，道具可以传递给这个组件，你可以根据道具改变它的样式:</p>
<pre>const MyDiv = styled('div')`
  background-color: #00ffff;
  text-align: center;
  width: 100%;
  padding 20px;
  &amp;:hover {
    color: #ffffff;
    cursor: pointer;
  }
  @media (max-width: 700px) {
    background-color: #ff0000;
  }
`;</pre>
<p>在样式化组件的<a class="markup--anchor markup--p-anchor" href="https://emotion.sh/docs/styled" target="_blank" rel="noopener noreferrer" data-href="https://emotion.sh/docs/styled">文档页面中，您可以查看更多配置选项。</a></p>
<pre>class App extends Component {
  render() {
    return (
      &lt;MyDiv&gt;
        React + Emotion rocks!
      &lt;/MyDiv&gt;
    );
  }
}</pre>
<p>您也可以组合样式:</p>
<pre>const MyDiv = styled('div')(props =&gt; ({
    backgroundColor: props.bc,
    textAlign: 'center',
    width: '100%',
    padding: '20px',
    '&amp;:hover': {
      color: '#ffffff',
      cursor: 'pointer'
    },
    '@media (max-width: 700px)': {
      backgroundColor: '#ff0000'
    }
}));

class App extends Component {
  render() {
    return (
      &lt;MyDiv bc='#00ffff'&gt;
        React + Emotion rocks!
      &lt;/MyDiv&gt;
    );
  }
}</pre>
<p>和情感将按照它们出现的顺序合并它们(注意类名的变化):</p>
<p>但是，与阿芙罗狄蒂不同的是，在组合多个类名时，Emotion提供了一些<a class="markup--anchor markup--p-anchor" href="https://emotion.sh/docs/cx" target="_blank" rel="noopener noreferrer" data-href="https://emotion.sh/docs/cx">高级选项</a>。</p>
<pre>const styles = {
  panel: {
    ...
  },
  alert: {
     backgroundColor: 'red'
  }
};

class App extends Component {
  render() {
    return (
      &lt;div style={css(
            styles.panel,
            this.props.alert &amp;&amp; styles.alert
        )}
      &gt;
        React + Emotion rocks!
      &lt;/div&gt;
    );
  }
}</pre>
<p>也不同于阿芙罗狄蒂(但类似于镭)，情感让你可以轻松指定全球风格:</p>
<pre>.css-17nr31q {
  background-color: #00ffff;
  text-align: center;
  width: 100%;
  padding: 20px;
  background-color: red;
}</pre>
<p>Emotion像其他库一样支持<a class="markup--anchor markup--p-anchor" href="https://emotion.sh/docs/ssr" target="_blank" rel="noopener noreferrer" data-href="https://emotion.sh/docs/ssr">服务器端渲染</a>和<a class="markup--anchor markup--p-anchor" href="https://emotion.sh/docs/keyframes" target="_blank" rel="noopener noreferrer" data-href="https://emotion.sh/docs/keyframes">关键帧</a>，但它对<a class="markup--anchor markup--p-anchor" href="https://emotion.sh/docs/nested" target="_blank" rel="noopener noreferrer" data-href="https://emotion.sh/docs/nested">嵌套选择器</a>有更好的支持，并且一些独特的东西是对<a class="markup--anchor markup--p-anchor" href="https://emotion.sh/docs/theming" target="_blank" rel="noopener noreferrer" data-href="https://emotion.sh/docs/theming">主题</a>的支持，由库<a class="markup--anchor markup--p-anchor" href="https://github.com/emotion-js/emotion/tree/master/packages/emotion-theming" target="_blank" rel="noopener noreferrer" data-href="https://github.com/emotion-js/emotion/tree/master/packages/emotion-theming"> emotion-theming </a>提供。</p>
<p>例如，在安装了<code>emotion-theming</code>之后:</p>
<pre>import { injectGlobal } from 'emotion'

injectGlobal`
  body {
    background-color: black;
  }
`
// Or injectGlobal({ body: { backgroundColor: 'black' } });
view raw</pre>
<p>您可以将背景颜色样式放在主题中，以便在其他组件之间共享:</p>
<p>在这里，您可以看到使用一个对象实现情感的基本示例:</p>
<pre>npm install --save emotion-theming</pre>
<p>You can put the background color style in a theme to share it across other components:</p>
<pre>import styled from 'react-emotion';
import { ThemeProvider } from 'emotion-theming';

const theme = {
  backgroundColor: '#00ffff'
};

const MyDiv = styled('div')(props =&gt; ({
  backgroundColor: props.theme.backgroundColor,
  textAlign: 'center',
  width: '100%',
  padding: '20px',
  '&amp;:hover': {
    color: '#ffffff',
    cursor: 'pointer'
  },
  '@media (max-width: 700px)': {
    backgroundColor: '#ff0000'
  },
}));

class App extends Component {
  render() {
    return (
      &lt;ThemeProvider theme={theme}&gt;
        &lt;MyDiv&gt;
          React + Emotion rocks!
        &lt;/MyDiv&gt;
      &lt;/ThemeProvider&gt;
    );
  }
}</pre>
<p>在这里，您可以看到它是使用标记模板实现的:</p>
<p>包扎</p>
<p>了解这些图书馆有多受欢迎的一个很好的页面是<a class="markup--anchor markup--p-anchor" href="http://www.npmtrends.com/" target="_blank" rel="noopener noreferrer" data-href="http://www.npmtrends.com/"> npm趋势</a>。这里是我写这篇文章时的统计数据的快照(<a class="markup--anchor markup--p-anchor" href="http://www.npmtrends.com/radium-vs-aphrodite-vs-emotion" target="_blank" rel="noopener noreferrer" data-href="http://www.npmtrends.com/radium-vs-aphrodite-vs-emotion">这里</a>你可以找到最近的):<canvas class="progressiveMedia-canvas js-progressiveMedia-canvas"/> <img decoding="async" class="progressiveMedia-image js-progressiveMedia-image aligncenter jetpack-lazy-image" src="../Images/697f91fe5c42889e02c244162118f671.png" data-src="https://storage.googleapis.com/blog-images-backup/1*ZDM_bZKCS_Z6jqdM1YaLAA.png" data-lazy-src="https://storage.googleapis.com/blog-images-backup/1*ZDM_bZKCS_Z6jqdM1YaLAA.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://storage.googleapis.com/blog-images-backup/1*ZDM_bZKCS_Z6jqdM1YaLAA.png"/></p>
<p>下面是这些库的功能总结:</p>
<h2>评估方面</h2>
<p>镭</p><noscript><img data-lazy-fallback="1" decoding="async" class="progressiveMedia-image js-progressiveMedia-image aligncenter" src="../Images/697f91fe5c42889e02c244162118f671.png" data-src="https://storage.googleapis.com/blog-images-backup/1*ZDM_bZKCS_Z6jqdM1YaLAA.png" data-original-src="https://storage.googleapis.com/blog-images-backup/1*ZDM_bZKCS_Z6jqdM1YaLAA.png"/></noscript>
<p>阿弗罗蒂</p>
<table class="js-csv-data csv-data js-file-line-container">
<thead>
<tr id="file-best-react-inline-style-libraries-28-csv-LC1" class="js-file-line">
<th>情感上的</th>
<th>许可证(l)</th>
<th>用它</th>
<th>用它</th>
</tr>
</thead>
<tbody>
<tr id="file-best-react-inline-style-libraries-28-csv-LC2" class="js-file-line">
<td id="file-best-react-inline-style-libraries-28-csv-L2" class="blob-num js-line-number" data-line-number="2">用它</td>
<td>最新版本(在撰写本文时)</td>
<td>0.24</td>
<td>2.2.2</td>
</tr>
<tr id="file-best-react-inline-style-libraries-28-csv-LC3" class="js-file-line">
<td id="file-best-react-inline-style-libraries-28-csv-L3" class="blob-num js-line-number" data-line-number="3">9.2.3</td>
<td>大小</td>
<td>17.9k(g压缩)</td>
<td>19.1千/6.15(千兆压缩)</td>
</tr>
<tr id="file-best-react-inline-style-libraries-28-csv-LC4" class="js-file-line">
<td id="file-best-react-inline-style-libraries-28-csv-L4" class="blob-num js-line-number" data-line-number="4">14.4k(核心)/5.58k(压缩)</td>
<td>证明文件</td>
<td>9.0/10.0</td>
<td>8.5/10.0</td>
</tr>
<tr id="file-best-react-inline-style-libraries-28-csv-LC5" class="js-file-line">
<td id="file-best-react-inline-style-libraries-28-csv-L5" class="blob-num js-line-number" data-line-number="5">9.0/10.0</td>
<td>语法类型</td>
<td>对象文字</td>
<td>对象文字</td>
</tr>
<tr id="file-best-react-inline-style-libraries-28-csv-LC6" class="js-file-line">
<td id="file-best-react-inline-style-libraries-28-csv-L6" class="blob-num js-line-number" data-line-number="6">对象文字/模板文字</td>
<td>CSS类型</td>
<td>样式类(某些情况下)</td>
<td>班</td>
</tr>
<tr id="file-best-react-inline-style-libraries-28-csv-LC7" class="js-file-line">
<td id="file-best-react-inline-style-libraries-28-csv-L7" class="blob-num js-line-number" data-line-number="7">班</td>
<td>自动修复</td>
<td>是</td>
<td>是</td>
</tr>
<tr id="file-best-react-inline-style-libraries-28-csv-LC8" class="js-file-line">
<td id="file-best-react-inline-style-libraries-28-csv-L8" class="blob-num js-line-number" data-line-number="8">是</td>
<td>服务器端渲染</td>
<td>是</td>
<td>是</td>
</tr>
<tr id="file-best-react-inline-style-libraries-28-csv-LC9" class="js-file-line">
<td id="file-best-react-inline-style-libraries-28-csv-L9" class="blob-num js-line-number" data-line-number="9">是</td>
<td>伪类(<code>:hover</code>；<code>nth-child</code>；等等)</td>
<td>仅支持<code>:hover</code>；<code>:focus</code>和<code>:active</code></td>
<td>是</td>
</tr>
<tr id="file-best-react-inline-style-libraries-28-csv-LC10" class="js-file-line">
<td id="file-best-react-inline-style-libraries-28-csv-L10" class="blob-num js-line-number" data-line-number="10">是</td>
<td>伪元素(<code>::after</code>；<code>::before</code>等。)</td>
<td>不</td>
<td>是</td>
</tr>
<tr id="file-best-react-inline-style-libraries-28-csv-LC11" class="js-file-line">
<td id="file-best-react-inline-style-libraries-28-csv-L11" class="blob-num js-line-number" data-line-number="11">是</td>
<td>媒体查询</td>
<td>是</td>
<td>是</td>
</tr>
<tr id="file-best-react-inline-style-libraries-28-csv-LC12" class="js-file-line">
<td id="file-best-react-inline-style-libraries-28-csv-L12" class="blob-num js-line-number" data-line-number="12">是</td>
<td>嵌套</td>
<td>是</td>
<td>有限的</td>
</tr>
<tr id="file-best-react-inline-style-libraries-28-csv-LC13" class="js-file-line">
<td id="file-best-react-inline-style-libraries-28-csv-L13" class="blob-num js-line-number" data-line-number="13">是</td>
<td>关键帧</td>
<td>是</td>
<td>是</td>
</tr>
<tr id="file-best-react-inline-style-libraries-28-csv-LC14" class="js-file-line">
<td id="file-best-react-inline-style-libraries-28-csv-L14" class="blob-num js-line-number" data-line-number="14">是</td>
<td>@font-face</td>
<td>不</td>
<td>是</td>
</tr>
<tr id="file-best-react-inline-style-libraries-28-csv-LC15" class="js-file-line">
<td id="file-best-react-inline-style-libraries-28-csv-L15" class="blob-num js-line-number" data-line-number="15">是</td>
<td>对主题的本机支持</td>
<td>不</td>
<td>不</td>
</tr>
<tr id="file-best-react-inline-style-libraries-28-csv-LC16" class="js-file-line">
<td id="file-best-react-inline-style-libraries-28-csv-L16" class="blob-num js-line-number" data-line-number="16">是</td>
<td>应用程序接口</td>
<td>是</td>
<td>不</td>
</tr>
<tr id="file-best-react-inline-style-libraries-28-csv-LC17" class="js-file-line">
<td id="file-best-react-inline-style-libraries-28-csv-L17" class="blob-num js-line-number" data-line-number="17">不</td>
<td>如果你问我，如果一切都一样，我会说我最喜欢的图书馆是阿芙罗狄蒂。</td>
<td>我觉得这个图书馆的平衡性最好。Radium缺少一些功能，尽管它很灵活并且有很好的文档，但它有太多的功能，有时使用起来有点复杂。如果你问我，如果一切都一样，我会说我最喜欢的图书馆是阿芙罗狄蒂。</td>
<td>但是当决定在您的项目中使用什么库时，最重要的事情是考虑与您的项目相关的方面。不要选择表中最有特性或通过的库。</td>
</tr>
</tbody>
</table>
<p>最后，也来看看这个<a class="markup--anchor markup--p-anchor" href="https://github.com/MicheleBertoli/css-in-js" target="_blank" rel="noopener noreferrer" data-href="https://github.com/MicheleBertoli/css-in-js">库</a>，在这里<a class="markup--anchor markup--p-anchor" href="https://github.com/MicheleBertoli" target="_blank" rel="noopener noreferrer" data-href="https://github.com/MicheleBertoli">米歇尔·贝托丽</a>比较了React的更多库，并为每个库实现了一个例子。</p>
<p>使用LogRocket消除传统反应错误报告的噪音</p>
<p>是一款React analytics解决方案，可保护您免受数百个误报错误警报的影响，只针对少数真正重要的项目。LogRocket告诉您React应用程序中实际影响用户的最具影响力的bug和UX问题。</p>
<p>自动聚合客户端错误、反应错误边界、还原状态、缓慢的组件加载时间、JS异常、前端性能指标和用户交互。然后，LogRocket使用机器学习来通知您影响大多数用户的最具影响力的问题，并提供您修复它所需的上下文。</p><div class="code-block code-block-17">
<div class="blog-plug inline-plug react-plug" vwo-el-id="26283398190">
<h2 vwo-el-id="41600691720">关注重要的React bug—<a class="signup" href="https://lp.logrocket.com/blg/react-signup-issue-free" target="_blank" rel="noopener noreferrer" vwo-el-id="40093418840">今天就试试LogRocket】。</a></h2>
<a href="https://lp.logrocket.com/blg/react-signup-issue-free" target="_blank" vwo-el-id="19356441070">LogRocket
</a><p> is a React analytics solution that shields you from the hundreds of false-positive errors alerts to just a few truly important items. LogRocket tells you the most impactful bugs and UX issues actually impacting users in your React applications.
</p><a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="19356441380">
<img class="first-react-image alignnone size-full wp-image-46 jetpack-lazy-image jetpack-lazy-image--handled" src="../Images/f300c244a1a1cf916df8b4cb02bec6c6.png" vwo-el-id="18272717540" data-lazy-loaded="1" data-original-src="https://files.readme.io/27c94e7-Image_2017-06-05_at_9.46.04_PM.png"/>
</a>
<a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="19356441690">
<img class="second-react-image alignnone size-full wp-image-46 jetpack-lazy-image jetpack-lazy-image--handled" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" vwo-el-id="30720362350" data-lazy-loaded="1" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/>
</a>
<a href="https://lp.logrocket.com/blg/react-signup-issue-free" target="_blank" rel="noopener noreferrer" vwo-el-id="35866400580">LogRocket
</a><p> automatically aggregates client side errors, React error boundaries, Redux state, slow component load times, JS exceptions, frontend performance metrics, and user interactions. Then LogRocket uses machine learning to notify you of the most impactful problems affecting the most users and provides the context you need to fix it.

</p><p vwo-el-id="28675661060">Focus on the React bugs that matter —
<a class="signup" href="https://lp.logrocket.com/blg/react-signup-issue-free" target="_blank" rel="noopener noreferrer" vwo-el-id="40093418840">try LogRocket today</a>.
</p>
</div></div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
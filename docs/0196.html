<html>
<head>
<title>Git workflow strategies for multiple teams - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>多个团队的Git工作流策略</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/git-workflow-strategies-multiple-teams-single-repository/#0001-01-01">https://blog.logrocket.com/git-workflow-strategies-multiple-teams-single-repository/#0001-01-01</a></blockquote><div><article class="article-post">
<p><strong> <em>编者按:</em> </strong> <em>本文于2022年5月12日更新，包含了使用Git工作流处理补丁的信息。</em></p>
<p>如果你以前经历过这种情况，请打断我:你要么是一个大型开发团队的一部分，要么目前正在管理这个团队，他们并不都使用相同的技术。为什么？嗯，你的团队可能由从事Java或Node.js的后端开发人员、从事Angular、React或Vue.js的前端开发人员组成，你甚至可能有几个从事Python工作的数据科学家。</p>
<p>最重要的是，每个人都说他们知道如何使用Git，但实际上，他们并不知道。他们通常使用他们选择的IDE来处理版本控制，点击选项而不知道他们到底在做什么。</p>
<p>通常，理性会指示这些团队分别处理他们的源代码，这意味着为每个代码库使用不同的存储库。这也将使他们能够拥有彼此独立的个人发展流。</p>
<p>也就是说，运气经常不在你这边，你只剩下一个存储库和三个不同的团队，试图学习如何一起工作。在这篇特别的文章中，我将处理这个场景，但是仅仅从源代码控制的角度。换句话说，如何创建一个有用的开发流程，允许每个人一起工作，而不会弄乱彼此的代码。</p>
<p>下面是我将讨论的一些Git工作流示例:</p>

<h2 id="traditional-branching-model">传统分支模型</h2>
<p>2010年，Vincent Driessen发表了一篇<a href="https://nvie.com/posts/a-successful-git-branching-model/" target="_blank" rel="noopener">非常有趣的文章</a>，描述了一种在开发团队中用Git处理版本控制的方法。</p>
<p>从本质上来说，那篇文章提出的(如果你想知道所有的细节，可以直接去读这篇文章，不需要花言巧语)是:</p>
<ul>
<li>为您需要处理的每个特性创建一个分支。这些分支将来自基础开发分支，所有的开发代码都驻留在那里</li>
<li>每个开发人员将致力于他们各自的特性分支，直到他们被认为准备好了</li>
<li>一旦准备好，它们将被合并回它们的源</li>
<li>当所有的特性都准备好了，您将从开发中创建一个发布分支，在那里只接受错误修复，以确保没有半成品特性被部署</li>
</ul>
<p>简而言之，这就是流程。当涉及到标记和修补程序时，还有一些其他的注意事项，但是我会让您阅读相关的原始文章。</p>
<p>因此，就像许多其他人一样，我将这种方法铭记于心，并且当同质团队在相同的代码上作为一个整体工作时，这种方法工作得非常好(以我的拙见)。</p>
<p>问题来了，当那不再是现实。</p>
<p>不要误解我的意思，如果您的团队精通该工具，该模型仍然有效。如果他们知道从存储库中提取意味着什么，或者如何正确地处理合并冲突，那么，无论如何，都要使用这个模型。</p>
<p>遗憾的是，情况并非总是如此，太多的开发人员在需要使用Git时，往往会忽略它的文档。当团队足够小时，这会导致一些小问题，或者会迫使他们选举队友来承担所有合并的责任。</p>
<p>也许你也经历过——你的团队中有一些开发人员非常了解这个工具，并且知道当他们使用它时会发生什么，所以他们往往是处理最复杂任务的人。</p>
<p>例如，您可能让这些开发人员在sprint 的<a href="https://blog.logrocket.com/product-management/what-is-sprint-planning-guide-meeting-agenda-cheat-sheet/" target="_blank" rel="noopener">开始时创建特性分支，然后一旦其他人认为代码准备好了，就负责合并。</a></p>
<p>在某些情况下，这可能是一种可行的设置，但毫无疑问，它会给那些特定的个人增加很多责任，并且肯定会占用他们的发展时间。</p>
<p>那么，如果我们不尝试调整我们的Git流，最坏会发生什么呢？</p>
<h2 id="common-git-workflow-problems-to-avoid">要避免的常见Git工作流问题</h2>
<p>让我分享一些我经历过的例子，这些例子让我想到了一种新的Git工作流方法。</p>
<h3 id="chaining-branches">链接分支</h3>
<p>流程规定每个新的分支需要来自主开发分支，这是为了避免从其他半成品分支带来不完整的代码。这里的问题是开发人员在创建他们的分支和使用另一个分支时没有注意，可能会错误地使用一个旧的分支作为源。</p>
<p>现在他们试图将他们的完整代码合并到开发中，可以理解，他们有很多合并冲突。如果开发人员只是接受他们的代码版本来解决问题，情况会变得更糟，因为在他们看来，他们的工作是最新的。</p>
<p>一旦这些都完成了，他们上传了他们的代码，是的，但是在这个过程中，他们也用旧的、未完成的版本覆盖了另一个团队的最新版本的代码。</p>
<p>让我们用一个非常简单的图表来看一下:</p>
<p><img decoding="async" class="aligncenter jetpack-lazy-image" src="../Images/35217a7f8e170335d14e775b5af438a2.png" alt="Git Workflow Diagram Showing Chaining Branches" data-lazy-src="https://storage.googleapis.com/blog-images-backup/1*olclSesYiEh1Ew80hlBoRQ.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://storage.googleapis.com/blog-images-backup/1*olclSesYiEh1Ew80hlBoRQ.png"/></p><noscript><img data-lazy-fallback="1" decoding="async" loading="lazy" class="aligncenter" src="../Images/35217a7f8e170335d14e775b5af438a2.png" alt="Git Workflow Diagram Showing Chaining Branches" data-original-src="https://storage.googleapis.com/blog-images-backup/1*olclSesYiEh1Ew80hlBoRQ.png"/></noscript>
<p>最后，从分支F2合并的代码有来自F1的未完成的代码。因为所有的团队共享同一个存储库，F1可能是特定于前端的分支，F2可能是后端团队的分支。你能想象后端的人把前端的代码搞乱会有多混乱吗？我可以告诉你，这不太好。</p>
<h3 id="premature-merges">过早合并</h3>
<p>与前面的问题类似，如果您将未完成的功能分支合并到开发中，只是为了看看它是如何工作的，或者(甚至更糟)为了确保没有冲突，您实际上是在用未完成的代码毒害主分支。</p><div class="code-block code-block-54">
<hr/>
<h3>更多来自LogRocket的精彩文章:</h3>

<hr/></div>
<p>下一个开发人员来了，并从基础分支创建了一个全新的分支，就像他们应该做的那样，将会带着你的代码。当他们决定将其合并回来时，假设您已经完成了代码并在他们之前将其合并，他们将不得不为您的代码解决合并冲突——而不是他们的！<strong> #WTF </strong></p>
<p>请看下一个流程图，它展示了这个具体的案例:</p>
<p><img decoding="async" class="aligncenter jetpack-lazy-image" src="../Images/db791e70c8fab9fee6916efcddb3fc16.png" alt="Git Workflow Diagram Showing Premature Merges" data-lazy-src="https://storage.googleapis.com/blog-images-backup/1*dBhtQJ9jUYf-WFPe6_PZjQ.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://storage.googleapis.com/blog-images-backup/1*dBhtQJ9jUYf-WFPe6_PZjQ.png"/></p><noscript><img data-lazy-fallback="1" decoding="async" loading="lazy" class="aligncenter" src="../Images/db791e70c8fab9fee6916efcddb3fc16.png" alt="Git Workflow Diagram Showing Premature Merges" data-original-src="https://storage.googleapis.com/blog-images-backup/1*dBhtQJ9jUYf-WFPe6_PZjQ.png"/></noscript>
<p>最后，结果还是和以前一样，你影响了别人的工作，却没有意识到。事实上，这些问题在进入生产之前是看不到的，所以您需要格外小心处理代码的方式。</p>
<p>还有其他方法来破坏您同事的代码，但是它们与这两个例子有些关系，正如您现在可能已经猜到的，实际的挑战不是流程本身，而是团队。</p>
<p>解决这个问题的最终方法是培训相关的开发人员，这样他们就不会犯同样的错误，但是如果你不能，或者他们不会学习(毕竟，人都会犯错),那么你的另一个选择就是调整你的流程，使你的损失最小化。</p>
<h2 id="new-git-workflow-approach">新的Git工作流方法</h2>
<p>我试图通过这个流程来缩小一个错误的影响范围。通过将代码划分成非常独立的分支，如果有人忘记了什么，或者只是不想按规则来玩，他们只会影响他们的直接队友，而不会影响团队的其他成员。</p>
<p>问题是无法避免的，这里的关键是不要让它们蔓延到其他团队，因为这样的话，修复它们就成了整个项目的任务，而如果只是前端或后端的问题，那个团队就可以自己处理了。</p>
<p>现在让我们来看看这个流程如何寻找两个团队的组合；您可以很容易地推断出项目中任意数量的子团队:</p>
<p><img decoding="async" class="aligncenter jetpack-lazy-image" src="../Images/5cd69d75b2614aaede4a701c1b4761d7.png" alt="Git Workflow Diagram Showing New Approach" data-lazy-src="https://storage.googleapis.com/blog-images-backup/1*itpxDlI13ocyw5n1dRkAWQ.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://storage.googleapis.com/blog-images-backup/1*itpxDlI13ocyw5n1dRkAWQ.png"/></p><noscript><img data-lazy-fallback="1" decoding="async" loading="lazy" class="aligncenter" src="../Images/5cd69d75b2614aaede4a701c1b4761d7.png" alt="Git Workflow Diagram Showing New Approach" data-original-src="https://storage.googleapis.com/blog-images-backup/1*itpxDlI13ocyw5n1dRkAWQ.png"/></noscript>
<p>我知道有很多台词，但是请耐心听我说。</p>
<p>这个流程试图展示两个团队(T1和T2)如何在sprint的时间内，以两种不同的方式(F1和F2)工作。</p>
<p>一切都很清楚，以下是细节:</p>
<ul>
<li>虚线箭头是自动发生的合并</li>
<li>T1Dev和T2Dev分别是每个团队的开发分支。它们内部的代码不应该混合，这是关键所在。这就像混合前端代码和数据科学代码(你就是不这样做)</li>
<li>T1Stable和T2Stable是相应的T1Dev和T2Dev的副本，但它们只包含稳定的代码。这是有保证的，因为只有当这些分支的特性被关闭时，合并才会发生(意味着QA团队已经批准了它们)</li>
<li>在每个sprint的开始，从他们相应的稳定分支为每个团队创建一个标签</li>
<li>从当前sprint的标签中创建新的特性分支</li>
<li>无论合并到基础开发分支中的是什么，都由开发人员进行测试。如果它像预期的那样工作，就会发出一个合并命令，这样代码就会被合并到QA分支中(并随后部署到该环境中，供该团队进行测试)</li>
<li>在sprint 的<a href="https://blog.logrocket.com/product-management/what-is-a-sprint-retrospective-templates-and-best-practices/" target="_blank" rel="noopener">结尾，稳定的代码被部署到产品中(通过将其合并到PROD分支中)</a></li>
</ul>
<p>我知道这听起来很多，可能看起来难以处理，但它有助于防止许多灾难。</p>
<p>让我解释一下。</p>
<p>标签确保在sprint中创建的所有分支都包含相同的源代码。这是非常重要的，因为如果您不这样做，您可能会在sprint开始一周后创建一个新的分支，其中包含任何部分测试的内容，而您的任何其他队友可能会将该部分测试合并到您团队的开发分支中。这基本上防止了你在合并自己的代码时，不情愿地从别人那里推广未完成的代码。</p>
<p>稳定的分支在将代码提升到产品的过程中帮助你(或者可能在那之前的一步，UAT)。你看，在一个理想的世界里，你只需要将你的QA分支提升到下一个环境中。但在现实中，总是会有遗留问题，要么是由于未完成的特性，要么是有缺陷的特性。</p>
<p>无论是哪种情况，这些代码都不足以脱离QA并投入生产，所以当设置下一个部署时，您需要手工挑选您的分支，只有那些得到批准的分支。这样，您已经为每个已经预先批准的团队建立了一个分支，所以您所要做的就是将这些分支合并到生产中，这样您就准备好了。</p>
<p>单独的开发分支(上面例子中的T1Dev和T2Dev)有助于隔离代码。您知道，将代码合并到这些分支中需要由开发人员自己来完成，正如我们在本文开始时所讨论的，您不能总是相信他们能够正确地完成这些工作。通过拥有单独的开发分支，您可以确保如果他们犯了任何错误，他们只会影响他们的团队，而不是整个项目。</p>
<p>根据要素的大小，您可能需要从要素分支创建几个单独的分支。你可以按照你认为合适的方式构建你的本地开发工作流，只要记住一件事:你做的任何事情都需要来自并进入特性分支，就是这样。</p>
<h2 id="hotfix-workflow">修补程序工作流</h2>
<p>当您处于需要紧急修复bug的情况时，最好的做法是创建一个热修复分支。这个分支通常是从主分支或者稳定发布分支中创建的。当应用程序被修补后，它将被合并回主分支，这代表了应用程序的线性发布时间线。</p>
<p>hotfixes的问题是，虽然在发布日期之后活跃的开发停止了，但是产品分支仍然被bug修复更新。</p>
<p>以下是设置修补程序工作流时要记住的一些提示:</p>
<ul>
<li>热修复分支是从主分支或主分支创建的</li>
<li>在修补程序分支上，应该只允许直接解决应用程序中的错误的提交</li>
<li>其他功能增强和较小的更改不应是提交的一部分</li>
<li>热修复分支应该与开发分支合并，然后由QA测试</li>
<li>一旦QA签署了构建，它就可以被合并到主分支中，然后被推到生产环境中</li>
<li>作为另一种选择，提交可以被挑选到主分支和开发分支中。</li>
</ul>
<p>热修复分支允许一个团队继续在开发或功能分支上工作，而另一个团队则忙于修复bug。如果开发人员试图将他们的功能分支合并到开发中，并且存在合并冲突，那么他们可能会接受他们自己的更改，并且意外地恢复错误修复。因此，所有的特性分支都应该定期与开发分支一起更新，以确保最新的代码被发送回开发分支。</p>
<h2 id="additional-git-workflow-recommendations">其他Git工作流建议</h2>
<p>这里还有一些流程之外的建议。虽然流程本身将有助于限制你的团队或队友可能犯下的任何无意错误的影响范围，但还有其他建议与之齐头并进，可以更好地防止这些错误。</p>
<h3 id="document-the-flow">记录流程</h3>
<p>需要记录开发流程，尤其是复杂的流程。每个人都需要能够准确理解什么时候需要发生什么，更重要的是如何去做。</p>
<p>换句话说，不要害怕编写万无一失的文档，牵着开发人员的手。这听起来可能很多，但是你将会写一次并经常使用它，特别是在你的项目开始时和每个新开发人员加入后。</p>
<p>一步一步的描述有助于他们避免猜测如何执行拉取或合并，并给他们一个处理这些任务的标准化方法，这样如果有任何疑问，任何人都可以回答。</p>
<h3 id="discuss-the-flow">讨论流程</h3>
<p>另一种形式的记录是面对面的问答，或者至少是在聚会或任何其他形式的成员现场聚会上，每个人都可以表达他们的疑问。</p>
<p>有时这些疑虑会凸显出你计划中的缺陷，所以，从另一方面来说，要对改变持开放态度。就像他们需要接受你的领导一样(如果你是那个创造流程的人)，你也需要接受你可能的疏忽，甚至是你错过的改进。要意识到这些事情可能会发生，在将计划发布给每个人之前，尝试与团队中更精通Git的成员一起审查计划。如果他们能接受，很有可能其他人也会接受。</p>
<h3 id="dont-be-afraid-to-enforce-some-standards">不要害怕执行一些标准</h3>
<p>还是那句话，有时候问题来自行动自由。如果使用Git的开发人员并不真正理解它是如何工作的，而是试图通过使用外部工具来弥补这一点，他们最终可能会比没有工具时带来更多的麻烦。</p>
<p>为了避免这种情况，请随意强制他们需要使用的Git客户端、他们需要工作的环境、文件夹结构，或者任何您认为可以简化他们处理源代码控制的任务的东西。我<a href="https://blog.logrocket.com/standards-and-why-you-need-them-b48309053e41" target="_blank" rel="noopener">写了一篇文章</a>,讲述了你将从实现的标准中获益，如果你有兴趣了解这个主题的话。</p>
<p>我在这里要做的一件事是强制使用内置Git的CLI客户机，然后在逐步文档中列出他们需要输入的每个命令。这样，这个任务对每个人来说都是不需要动脑筋的(这是理想的场景，让您的开发人员担心代码行，而不是Git行)。</p>
<h2 id="finalwords">最后的话</h2>
<p>本文到此为止；感谢您读到这里，请记住:</p>
<ul>
<li>并不是每个人都对Git有足够的了解，可以单独使用它</li>
<li>不是每个人都会承认这一点</li>
<li>标准的Git流并不总是您团队的正确选择</li>
<li>你的目标应该是当问题发生时(它们会发生)，有一个最小化附带损害的流程</li>
<li>您还应该致力于培训您的团队使用Git。起初可能看起来不像，但这是一项投资，它将使您避免由于不正确的合并而错过交付日期</li>
<li>试着提供尽可能多的关于这个过程的文档，并把它作为一个不断发展和变化的活文档</li>
</ul>
<p>再次感谢您的阅读。如果你愿意，请留下一个类似故事的评论，谈谈你在过去遇到过什么样的问题，是由于滥用Git，还是你用来避免它们的不同流程。</p>
<p>直到下一个！</p><div class="code-block code-block-2">
<div class="blog-plug base-cta"><h2>使用<a class="signup" href="https://lp.logrocket.com/blg/signup" target="_blank" rel="noopener noreferrer"> LogRocket </a>消除传统错误报告的干扰</h2>
<a href="https://lp.logrocket.com/blg/signup" class="signup" target="_blank" rel="noopener noreferrer"><img class="alignnone size-full wp-image-46 jetpack-lazy-image" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/><noscript><img data-lazy-fallback="1" class="alignnone size-full wp-image-46" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/></noscript></a>
<p><a href="https://lp.logrocket.com/blg/signup" target="_blank" rel="noopener noreferrer"> LogRocket </a>是一个数字体验分析解决方案，它可以保护您免受数百个假阳性错误警报的影响，只针对几个真正重要的项目。LogRocket会告诉您应用程序中实际影响用户的最具影响力的bug和UX问题。</p>
<p>然后，使用具有深层技术遥测的会话重放来确切地查看用户看到了什么以及是什么导致了问题，就像你在他们身后看一样。</p>
<p>LogRocket自动聚合客户端错误、JS异常、前端性能指标和用户交互。然后LogRocket使用机器学习来告诉你哪些问题正在影响大多数用户，并提供你需要修复它的上下文。</p>
<p>关注重要的bug—<a class="signup" href="https://lp.logrocket.com/blg/signup-issue-free" target="_blank" rel="noopener noreferrer">今天就试试LogRocket】。</a></p></div></div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
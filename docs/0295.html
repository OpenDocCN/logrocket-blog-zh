<html>
<head>
<title>8 DOM features you didn’t know existed - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>你不知道的8个DOM特性</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/8-dom-features-you-didnt-know-existed-ec2a0a28fd89/#0001-01-01">https://blog.logrocket.com/8-dom-features-you-didnt-know-existed-ec2a0a28fd89/#0001-01-01</a></blockquote><div><article class="article-post">
<div class="section-inner sectionLayout--insetColumn">
<p id="1a9d" class="graf graf--p graf-after--figure">随着最近对工具的关注越来越多，从所有的React和npm-install-everything帖子中休息一下，仔细看看一些在现代浏览器中工作的纯DOM和Web API特性是很好的。</p>
<p id="c528" class="graf graf--p graf-after--p">这篇文章将考虑八个鲜为人知的DOM特性，它们具有强大的浏览器支持。为了帮助解释每一个是如何工作的，我将包含许多交互式演示，供您自己尝试代码。</p>
<p id="28d5" class="graf graf--p graf-after--p">这些方法和属性没有陡峭的学习曲线，并且将很好地与您碰巧引入到项目中的任何工具集一起工作。</p>
</div>
<div class="section-inner sectionLayout--insetColumn">
<p id="671c" class="graf graf--p graf-after--figure">您肯定使用过<code>addEventListener()</code>来处理将事件附加到web文档中的元素。通常，<code>addEventListener()</code>呼叫看起来像这样:</p>
<pre id="8e55" class="graf graf--pre graf-after--p">element.addEventListener('click', doSomething, false);</pre>
<p id="6d6d" class="graf graf--p graf-after--pre">第一个参数是我要监听的事件。第二个参数是事件发生时将执行的回调函数。第三个参数是一个名为<code>useCapture</code>的布尔值，它指示您是否想要使用<a class="markup--anchor markup--p-anchor" href="https://www.sitepoint.com/event-bubbling-javascript/" target="_blank" rel="noopener noreferrer" data-href="https://www.sitepoint.com/event-bubbling-javascript/">事件冒泡或捕获</a>。</p>
<p id="2c29" class="graf graf--p graf-after--p">这些都是众所周知的(尤其是前两个)。但是也许你不知道<code>addEventListener()</code>也接受一个替换最终布尔值的参数。这个新参数是一个看起来像这样的<code>options</code>对象:</p>
<pre id="c76d" class="graf graf--pre graf-after--p">element.addEventListener('click', doSomething, {
  capture: false,
  once: true,
  passive: false
});</pre>
<p id="9306" class="graf graf--p graf-after--pre">注意，该语法允许定义三种不同的属性。下面是每个词的意思的简要概述:</p>
<ul class="postList">
<li id="71f4" class="graf graf--li graf-after--p"><strong class="markup--strong markup--li-strong">捕获</strong> —一个布尔值，与前面提到的<code><a class="markup--anchor markup--li-anchor" href="https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener#Parameters" target="_blank" rel="noopener noreferrer" data-href="https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener#Parameters">useCapture</a></code> <a class="markup--anchor markup--li-anchor" href="https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener#Parameters" target="_blank" rel="noopener noreferrer" data-href="https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener#Parameters">参数</a>相同</li>
<li id="86c6" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong"> once </strong> —一个布尔值，如果设置为<code>true</code>，则表示该事件只应在目标元素上运行一次，然后被删除</li>
<li id="2486" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">被动</strong> —一个最终布尔值，如果设置为<code>true</code>，则表明该函数永远不会调用<code>preventDefault()</code>，即使它包含在函数体中</li>
</ul>
<p id="4561" class="graf graf--p graf-after--li">这三个选项中最有趣的是<code>once</code>选项。这在许多情况下肯定会派上用场，并使您不必使用<code>removeEventListener()</code>或其他复杂的技术来强制单个事件触发。如果您使用过jQuery，您可能会熟悉该库中的一个类似特性，<a class="markup--anchor markup--p-anchor" href="http://api.jquery.com/one/" target="_blank" rel="noopener noreferrer" data-href="http://api.jquery.com/one/">。一()方法</a>。</p>
<p id="cd4f" class="graf graf--p graf-after--p">您可以在下面的代码栏中尝试一些使用<code>options</code>对象的代码:</p>
<p class="codepen" data-height="411" data-theme-id="0" data-default-tab="result" data-user="impressivewebs" data-slug-hash="GeJZYz" data-pen-title="Using addEventListener() with an `options` Object as Third Parameter">请看<a href="https://codepen.io"> CodePen </a>上Louis Lazaris(<a href="https://codepen.io/impressivewebs">@ impressive webs</a>)<br/>使用addEventListener()的笔<a href="https://codepen.io/impressivewebs/pen/GeJZYz/">，带一个‘options’对象作为第三参数</a>。</p>
<p/>
</div>
<p id="4c87" class="graf graf--p graf-after--figure">请注意，演示页面上的按钮只会追加一次文本。如果您将<code>once</code>值更改为<code>false</code>，然后多次单击按钮，则每次单击按钮时都会追加文本。</p>
<p id="a3aa" class="graf graf--p graf-after--p">浏览器对<code>options</code>对象的支持非常好:除了IE11 和更早的版本，所有的浏览器都支持它<a class="markup--anchor markup--p-anchor" href="https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener#Browser_compatibility" target="_blank" rel="noopener noreferrer" data-href="https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener#Browser_compatibility">，所以如果你不担心微软浏览器的早期版本，使用它是非常安全的。</a></p>
<h3 id="c19f" class="graf graf--h3 graf-after--p">scrollTo()方法用于在窗口或元素中平滑滚动</h3>
<p id="8cdf" class="graf graf--p graf-after--h3">平滑滚动一直是一种需要。当一个本地页面链接立即跳转到一个指定的位置时，这是不和谐的(如果你眨眼，你甚至可能错过跳转)。平滑滚动不仅好看，还能提高页面的UX。</p>
<p id="e0fb" class="graf graf--p graf-after--p">虽然这在过去已经使用jQuery插件完成了，但是现在使用<code>window.scrollTo()</code>方法只用一行JavaScript就可以实现。</p>
<p id="0c04" class="graf graf--p graf-after--p">将<code>scrollTo()</code>方法应用于Window对象，告诉浏览器滚动到页面上的指定位置。例如，下面是一个最简单的语法示例:</p>
<pre id="d08e" class="graf graf--pre graf-after--p"><code>window.scrollTo(0, 1000);</code></pre>
<p id="ed13" class="graf graf--p graf-after--pre">这将使窗口<code>0px</code>向右滚动(代表x坐标，或水平滚动)并使<code>1000px</code>向下滚动(垂直，这通常是您想要的)。但那样的话，滚动就不会是流畅的动画效果；页面会突然滚动，就像你使用一个指向指定散列URL的本地链接一样。</p>
<p id="66a6" class="graf graf--p graf-after--p">有时候这就是你想要的。但是为了获得平滑的滚动，你必须加入不太为人所知的<code>ScrollToOptions</code>对象，就像这样:</p>
<pre id="ef5e" class="graf graf--pre graf-after--p">window.scrollTo({
  top: 0,
  left: 1000,
  behavior: 'smooth'
});</pre>
<p id="7f99" class="graf graf--p graf-after--pre">这段代码相当于前面的例子，但是增加了<code>options</code>对象中<code>behavior</code>属性的<code>smooth</code>值。</p>
<p class="codepen" data-height="464" data-theme-id="0" data-default-tab="result" data-user="impressivewebs" data-slug-hash="pGYXgj" data-pen-title="Using Options with window.ScrollTo()">使用选项与窗口一起查看笔<a href="https://codepen.io/impressivewebs/pen/pGYXgj/"> <br/>。路易·拉扎勒斯(<a href="https://codepen.io/impressivewebs"> @impressivewebs </a> ) <br/>在<a href="https://codepen.io"> CodePen </a>上的ScrollTo() </a>。</p>
<p/>
<p id="e8a6" class="graf graf--p graf-after--figure">尝试在框中输入一个数字(最好是像<code>4000</code>这样的大数字)，并将“行为”选择框改为使用<code>smooth</code>或<code>auto</code>(这是<code>behavior</code>属性仅有的两个选项)。</p>
<p id="6b27" class="graf graf--p graf-after--p">关于此功能的一些注意事项:</p>
<ul class="postList">
<li id="daf8" class="graf graf--li graf-after--p">对<code>scrollTo()</code>的基本支持是全面的，但是<a class="markup--anchor markup--li-anchor" href="https://caniuse.com/#feat=element-scroll-methods" target="_blank" rel="noopener noreferrer" data-href="https://caniuse.com/#feat=element-scroll-methods">并不是所有的</a>浏览器都支持<code>options</code>对象</li>
<li id="bd48" class="graf graf--li graf-after--li">当应用于一个元素而不是窗口时，这个方法也可以工作</li>
<li id="ea64" class="graf graf--li graf-after--li">这些选项也适用于<code>scroll()</code>和<code>scrollBy()</code>方法</li>
</ul>
<h3 id="c9b3" class="graf graf--h3 graf-after--li">带有可选参数的setTimeout()和setInterval()</h3>
<p id="a58c" class="graf graf--p graf-after--h3">在许多情况下，使用<code>window.setTimeout()</code>和<code>window.setInterval()</code>制作基于时间的动画现在已经被性能更友好的<code>window.requestAnimationFrame()</code>所取代。但是有些情况下<code>setTimeout()</code>或<code>setInterval()</code>是正确的选择，所以了解一下这些方法鲜为人知的特性是有好处的。</p>
<p id="f683" class="graf graf--p graf-after--p">通常你会看到这些方法的语法如下:</p>
<pre id="a695" class="graf graf--pre graf-after--p">let timer = window.setInterval(doSomething, 3000);
function doSomething () {
  // Something happens here...
}</pre>
<p id="de53" class="graf graf--p graf-after--pre">这里,<code>setInterval()</code>调用传入两个参数:回调函数和时间间隔。有了<code>setTimeout()</code>,这将运行一次，而在这种情况下，它将无限期地运行，直到我在传入定时器变量的同时调用<code>window.clearTimeout()</code>。</p>
<p id="4095" class="graf graf--p graf-after--p">很简单。但是如果我想让我的回调函数接受参数呢？好吧，这些定时器方法最近增加了以下功能:</p>
<pre>let timer = window.setInterval(doSomething, 3000, 10, 20);
function doSomething (a, b) {
  // Something happens here…
}</pre>
<p id="1642" class="graf graf--p graf-after--pre">注意，我在我的<code>setInterval()</code>调用中增加了两个参数。然后，我的<code>doSomething()</code>函数接受这些参数，并根据需要操纵它们。</p>
<p id="3927" class="graf graf--p graf-after--p">这里有一个CodePen演示，它使用<code>setTimeout()</code>演示了这是如何工作的:</p>
<p class="codepen" data-height="527" data-theme-id="0" data-default-tab="result" data-user="impressivewebs" data-slug-hash="PgoNEj" data-pen-title="Optional Parameters with window.setTimeout()">参见<a href="https://codepen.io"> CodePen </a>上Louis Lazaris(<a href="https://codepen.io/impressivewebs">@ impressive webs</a>)【T5)的window.setTimeout() 的Pen <a href="https://codepen.io/impressivewebs/pen/PgoNEj/"> <br/>可选参数。</a></p>
<p/>
<p id="365f" class="graf graf--p graf-after--figure">当您单击该按钮时，将使用两个传入的值进行计算。这些值可以通过页面上的数字输入进行更改。</p>
<p id="09e2" class="graf graf--p graf-after--p">至于浏览器支持，这方面似乎有不一致的信息，但似乎所有正在使用的浏览器都支持可选参数功能，包括IE10。</p>
<h3 id="ecb8" class="graf graf--h3 graf-after--p">单选按钮和复选框的defaultChecked属性</h3>
<p id="ddc1" class="graf graf--p graf-after--h3">你可能知道，对于单选按钮和复选框，如果你想获取或设置<code>checked</code>属性，你可以使用<code>checked</code>属性，就像这样(假设<code>radioButton</code>是对一个特定表单输入的引用):</p>
<pre id="27e6" class="graf graf--pre graf-after--p">console.log(radioButton.checked); // true
radioButton.checked = false;
console.log(radioButton.checked); // false</pre>
<p id="26a2" class="graf graf--p graf-after--pre">但是还有一个名为<code>defaultChecked</code>的属性，它可以应用于单选按钮或复选框组，以找出组中的哪一个最初被设置为<code>checked</code>。</p>
<p id="5733" class="graf graf--p graf-after--p">以下是一些HTML示例:</p>
<pre id="3be7" class="graf graf--pre graf-after--p">&lt;form id="form"&gt;
  &lt;input type="radio" value="one" name="setOne"&gt; One
  &lt;input type="radio" value="two" name="setOne" checked&gt; Two&lt;br /&gt;
  &lt;input type="radio" value="three" name="setOne"&gt; Three
&lt;/form&gt;</pre>
<p id="96f7" class="graf graf--p graf-after--pre">这样，即使在选中的单选按钮被更改后，我也可以遍历输入并找出最初选中的是哪一个，如下所示:</p>
<pre id="e6e6" class="graf graf--pre graf-after--p">for (i of myForm.setOne) {
  if (i.defaultChecked === true) {
    console.log(‘i.value’);
  }
}</pre>
<p id="a1fa" class="graf graf--p graf-after--pre">下面是一个CodePen演示程序，它将显示当前选中的单选按钮或默认选中的单选按钮，这取决于您使用的按钮:</p>
<p class="codepen" data-height="539" data-theme-id="0" data-default-tab="result" data-user="impressivewebs" data-slug-hash="qwWoOr" data-pen-title="defaultChecked on Radio Buttons">请看<a href="https://codepen.io"> CodePen </a>上Louis Lazaris(<a href="https://codepen.io/impressivewebs">@ impressive webs</a>)<br/>的笔<a href="https://codepen.io/impressivewebs/pen/qwWoOr/"> <br/>默认勾选单选按钮</a>。</p>
<p/>
<p id="ca53" class="graf graf--p graf-after--figure">该示例中的<code>defaultChecked</code>选项将始终是“Two”单选按钮。如上所述，这也可以通过复选框组来实现。尝试更改HTML中的默认选中选项，然后再次尝试该按钮。</p>
<p id="b385" class="graf graf--p graf-after--p">这是另一个用一组复选框做同样事情的演示:</p>
<p class="codepen" data-height="534" data-theme-id="0" data-default-tab="result" data-user="impressivewebs" data-slug-hash="wZMJYQ" data-pen-title="defaultChecked on Checkboxes">请看<a href="https://codepen.io"> CodePen </a>上Louis Lazaris(<a href="https://codepen.io/impressivewebs">@ impressive webs</a>)<br/>的<a href="https://codepen.io/impressivewebs/pen/wZMJYQ/">笔<br/>默认勾选复选框</a>。</p>
<p/>
<p id="466b" class="graf graf--p graf-after--figure">在这种情况下，您会注意到其中两个复选框是默认选中的，所以当使用<code>defaultChecked</code>查询时，这两个复选框都将返回<code>true</code>。</p>
<h3 id="e962" class="graf graf--h3 graf-after--p">用normalize()和wholeText操作文本节点</h3>
<p id="b3c0" class="graf graf--p graf-after--h3">HTML文档中的文本节点可能很挑剔，尤其是在动态插入或创建节点时。例如，如果我有下面的HTML:</p>
<pre id="06ae" class="graf graf--pre graf-after--p">&lt;p id="el"&gt;This is the initial text.&lt;/p&gt;</pre>
<p id="f099" class="graf graf--p graf-after--pre">然后，我可以向段落元素添加一个文本节点:</p>
<pre id="65c8" class="graf graf--pre graf-after--p">let el = document.getElementById('el');
el.appendChild(document.createTextNode(' Some more text.'));
console.log(el.childNodes.length); // 2</pre>
<p id="0c44" class="graf graf--p graf-after--pre">请注意，在追加了文本节点之后，我记录了段落中子节点的长度，它显示有两个节点。这些节点是单个文本字符串，但是因为文本是动态追加的，所以它们被视为单独的节点。</p><div class="code-block code-block-54">
<hr/>
<h3>更多来自LogRocket的精彩文章:</h3>

<hr/></div>
<p id="1d5e" class="graf graf--p graf-after--p">在某些情况下，如果将文本视为单个文本节点会更有帮助，这使得文本更容易操作。这就是<code>normalize()</code>和<code>wholeText()</code>的用武之地。</p>
<p id="c5d6" class="graf graf--p graf-after--p"><code>normalize()</code>方法可用于合并单独的文本节点:</p>
<pre id="312e" class="graf graf--pre graf-after--p">el.normalize();
console.log(el.childNodes.length); // 1</pre>
<p id="616f" class="graf graf--p graf-after--pre">在一个元素上调用<code>normalize()</code>将会合并该元素中任何相邻的文本节点。如果碰巧有一些HTML散布在相邻的文本节点中，HTML将保持原样，而所有相邻的文本节点将被合并。</p>
<p id="44c8" class="graf graf--p graf-after--p">但是，如果出于某种原因，我希望保持文本节点分离，但我仍然希望能够将文本作为一个单元来获取，那么这就是<code>wholeText</code>的用处。因此，我可以在相邻的文本节点上这样做，而不是调用<code>normalize()</code>:</p>
<pre id="afb7" class="graf graf--pre graf-after--p">console.log(el.childNodes[0].wholeText);
// This is the initial text. Some more text.
console.log(el.childNodes.length); // 2</pre>
<p id="687b" class="graf graf--p graf-after--pre">只要我没有调用<code>normalize()</code>，文本节点的长度将保持在<code>2</code>，我可以使用<code>wholeText</code>记录整个文本。但是请注意一些事情:</p>
<ul class="postList">
<li id="b1af" class="graf graf--li graf-after--p">我必须在一个文本节点上调用<code>wholeText</code>，而不是元素(因此代码中的<code>el.childNodes[0]</code>；<code>el.childNodes[1]</code>也行)</li>
<li id="73c4" class="graf graf--li graf-after--li">文本节点必须是相邻的，没有HTML分隔它们</li>
</ul>
<p id="e039" class="graf graf--p graf-after--li">在这个CodePen演示中，你可以看到这两个特性，以及正在使用的<a class="markup--anchor markup--p-anchor" href="https://codepen.io/impressivewebs/pen/ZZzrBV?editors=0011" target="_blank" rel="noopener noreferrer" data-href="https://codepen.io/impressivewebs/pen/ZZzrBV?editors=0011">方法。打开CodePen控制台或浏览器的开发人员工具控制台，查看生成的日志。</a></p>
<h3 id="8769" class="graf graf--h3 graf-after--p">insertadjacentelemont_)和insertadjacenttext_)</h3>
<p id="d97a" class="graf graf--p graf-after--h3">你们中的许多人可能都熟悉<code>insertAdjacentHTML()</code>方法，这种方法允许你轻松地将一串文本或HTML添加到页面中与其他元素相关的特定位置。</p>
<p id="51db" class="graf graf--p graf-after--p">但是您可能没有意识到，该规范还包括两个以相似方式工作的相关方法:<code>insertAdjacentElement()</code>和<code>insertAdjacentText()</code>。</p>
<p id="5016" class="graf graf--p graf-after--p"><code>insertAdjacentHTML()</code>的缺陷之一是插入的内容必须是字符串的形式。所以如果你包含HTML，它必须这样声明:</p>
<pre id="4f0f" class="graf graf--pre graf-after--p">el.insertAdjacentHTML('beforebegin', '&lt;p&gt;&lt;b&gt;Some example&lt;/b&gt; text goes here.&lt;/p&gt;');</pre>
<p id="9e00" class="graf graf--p graf-after--pre">然而，使用<code>insertAdjacentElement()</code>，第二个参数可以是一个元素引用:</p>
<pre id="0675" class="graf graf--pre graf-after--p">let el = document.getElementById('example'),
addEl = document.getElementById('other');
el.insertAdjacentElement('beforebegin', addEl);</pre>
<p id="598a" class="graf graf--p graf-after--pre">这个方法的有趣之处在于，它不仅会将引用的元素添加到指定的位置，还会将元素从文档中的原始位置移除。所以这是一种将元素从DOM中的一个位置转移到另一个位置的简单方法。</p>
<p id="214d" class="graf graf--p graf-after--p">这里有一个使用<code>insertAdjacentElement()</code>的CodePen演示。按钮点击有效地“移动”了目标元素:</p>
<p class="codepen" data-height="605" data-theme-id="0" data-default-tab="result" data-user="impressivewebs" data-slug-hash="MRjOpj" data-pen-title="Using insertAdjacentElement() to Change an Element's Location">在<a href="https://codepen.io"> CodePen </a>上看到Louis Lazaris(<a href="https://codepen.io/impressivewebs">@ impressive webs</a>)<br/>用insertAdjacentElement()改变一个元素的位置的笔<a href="https://codepen.io/impressivewebs/pen/MRjOpj/">。</a></p>
<p/>
<p><code>insertAdjacentText()</code>方法的工作方式类似，但是所提供的文本字符串将被专门作为文本插入，即使它包含HTML。请注意下面的演示:</p>
<p class="codepen" data-height="441" data-theme-id="0" data-default-tab="result" data-user="impressivewebs" data-slug-hash="MRymba" data-pen-title="Using insertAdjacentText() with HTML Tags">在<a href="https://codepen.io"> CodePen </a>上看到Louis Lazaris(<a href="https://codepen.io/impressivewebs">@ impressive webs</a>)<br/>使用带有HTML标签的insertAdjacentText()的笔<a href="https://codepen.io/impressivewebs/pen/MRymba/">。</a></p>
<p/>
<p id="158a" class="graf graf--p graf-after--figure">您可以将自己的文本添加到输入字段，然后使用按钮将其添加到文档中。请注意，任何特殊字符(如HTML标签)都将作为HTML实体插入，与<code>insertAdjacentHTML()</code>相比，该方法的行为有所不同。</p>
<p id="7334" class="graf graf--p graf-after--p">所有三种方法(<code>insertAdjacentHTML()</code>、<code>insertAdjacentElement()</code>和<code>insertAdjacentText()</code>)都为第一个参数取相同的值。这些论点是:</p>
<ul class="postList">
<li id="7cc1" class="graf graf--li graf-after--p"><code>beforebegin</code>:插入在方法被调用的元素之前</li>
<li id="f8b4" class="graf graf--li graf-after--li"><code>afterbegin</code>:插入元素内部，第一个子元素之前</li>
<li id="71e6" class="graf graf--li graf-after--li"><code>beforeend</code>:插入元素内部，在它的最后一个子元素之后</li>
<li id="19ac" class="graf graf--li graf-after--li"><code>afterend</code>:插入元素后</li>
</ul>
<h3 id="1ead" class="graf graf--h3 graf-after--li">event.detail属性</h3>
<p id="6daf" class="graf graf--p graf-after--h3">正如已经讨论过的，使用熟悉的<code>addEventListener()</code>方法将事件附加到web页面的元素上。例如:</p>
<pre id="757b" class="graf graf--pre graf-after--p">btn.addEventListener('click', function () {
  // do something here...
}, false);</pre>
<p id="aec0" class="graf graf--p graf-after--pre">当使用<code>addEventListener()</code>时，您可能有必要防止函数调用中的默认浏览器行为。例如，也许您想拦截对<code>&lt;a&gt;</code>元素的点击，并用JavaScript处理这些点击。你应该这样做:</p>
<pre id="e8f4" class="graf graf--pre graf-after--p">btn.addEventListener('click', function (e) {
  // do something here...
  e.preventDefault();
}, false);</pre>
<p id="3885" class="graf graf--p graf-after--pre">这里使用的是<code>preventDefault()</code>，它是传统说法<code>return false</code>的现代翻版。这要求您将<code>event</code>对象传递到函数中，因为在该对象上调用了<code>preventDefault()</code>方法。</p>
<p id="856b" class="graf graf--p graf-after--p">但是你可以用那个<code>event</code>对象做更多的事情。事实上，当使用某些事件时(例如，<code>click</code>、<code>dbclick</code>、<code>mouseup</code>、<code>mousedown</code>)，这些事件会公开一个叫做<a class="markup--anchor markup--p-anchor" href="https://developer.mozilla.org/en-US/docs/Web/API/UIEvent" target="_blank" rel="noopener noreferrer" data-href="https://developer.mozilla.org/en-US/docs/Web/API/UIEvent"> UIEvent接口</a>的东西。正如MDN所指出的，这个界面上的许多特性都被否决或者没有标准化。但是最有趣和有用的是<code>detail</code>属性，它是官方规范的<a class="markup--anchor markup--p-anchor" href="https://w3c.github.io/uievents/#dom-uievent-detail" target="_blank" rel="noopener noreferrer" data-href="https://w3c.github.io/uievents/#dom-uievent-detail">部分。</a></p>
<p id="76f7" class="graf graf--p graf-after--p">下面是它在同一个事件侦听器示例中的样子:</p>
<pre id="0e04" class="graf graf--pre graf-after--p">btn.addEventListener('click', function (e) {
  // do something here...
  console.log(e.detail);
}, false);</pre>
<p id="86a0" class="graf graf--p graf-after--pre">我已经设置了一个CodePen演示程序，使用许多不同的事件来演示结果:</p>
<p class="codepen" data-height="594" data-theme-id="0" data-default-tab="result" data-user="impressivewebs" data-slug-hash="QoZoQe" data-pen-title="Using the event.detail Property">在<a href="https://codepen.io"> CodePen </a>上查看Louis Lazaris(<a href="https://codepen.io/impressivewebs">@ impressive webs</a>)<br/>使用event.detail属性的笔<a href="https://codepen.io/impressivewebs/pen/QoZoQe/">。</a></p>
<p/>
<p id="19ad" class="graf graf--p graf-after--figure">演示中的每个按钮都将按照按钮文本描述的方式做出响应，并显示一条显示当前点击次数的消息。一些需要注意的事项:</p>
<ul class="postList">
<li id="813b" class="graf graf--li graf-after--p">WebKit浏览器允许无限制的点击次数，除了在<code>dbclick</code>上，它总是两次。Firefox最多只允许点击三次，然后重新开始计数</li>
<li id="73b8" class="graf graf--li graf-after--li">我已经包括了<code>blur</code>和<code>focus</code>来证明这些不符合条件，并且将总是返回0(即没有点击)</li>
<li id="6ae3" class="graf graf--li graf-after--li">IE11等老浏览器的行为非常不一致</li>
</ul>
<p id="a242" class="graf graf--p graf-after--li">请注意，该演示包括一个很好的使用案例，即模拟三次点击事件的能力:</p>
<pre id="0261" class="graf graf--pre graf-after--p">btnT.addEventListener('click', function (e) {
  if (e.detail === 3) {
    trpl.value = 'Triple Click Successful!';
  }
}, false);</pre>
<p id="0091" class="graf graf--p graf-after--pre">如果所有浏览器的点击次数都超过了三次，那么您也可以检测到更高的点击次数，但我认为对于大多数目的来说，三次点击事件就足够了。</p>
<h3 id="e544" class="graf graf--h3 graf-after--p">scrollHeight和scrollWidth属性</h3>
<p id="0067" class="graf graf--p graf-after--h3"><code>scrollHeight</code>和<code>scrollWidth</code>属性可能听起来很熟悉，因为您可能会将它们与其他与宽度和高度相关的DOM特性相混淆。例如，<code>offsetWidth</code>和<code>offsetHeight</code>属性将返回一个元素的高度或宽度，而不考虑溢出。</p>
<p id="02f8" class="graf graf--p graf-after--p">例如，请注意下面的演示:</p>
<p class="codepen" data-height="700" data-theme-id="0" data-default-tab="result" data-user="impressivewebs" data-slug-hash="WWxEpX" data-pen-title="offsetHeight Doesn't Count Past CSS Overflow">请看<a href="https://codepen.io"> CodePen </a>上Louis Lazaris(<a href="https://codepen.io/impressivewebs">@ impressive webs</a>)<br/>的笔<a href="https://codepen.io/impressivewebs/pen/WWxEpX/">off the height not Count Past CSS溢出</a>。</p>
<p/>
<p id="5634" class="graf graf--p graf-after--figure">演示中的列具有相同的内容。左侧栏的<code>overflow</code>设置为<code>auto</code>，而右侧栏的<code>overflow</code>设置为<code>hidden</code>。<code>offsetHeight</code>属性为每个返回相同的值，因为它不考虑可滚动或隐藏区域；它只测量元素的实际高度，包括任何垂直填充和边框。</p>
<p id="bca6" class="graf graf--p graf-after--p">另一方面，名副其实的<code>scrollHeight</code>属性将计算元素的完整高度，包括可滚动(或隐藏)区域:</p>
<p class="codepen" data-height="752" data-theme-id="0" data-default-tab="result" data-user="impressivewebs" data-slug-hash="EJyvoB" data-pen-title="scrollHeight Measures an Element's Full Scrollable Area">参见<a href="https://codepen.io"> CodePen </a>上Louis Lazaris(<a href="https://codepen.io/impressivewebs">@ impressive webs</a>)<br/>的Pen <a href="https://codepen.io/impressivewebs/pen/EJyvoB/"> <br/> scrollHeight测量一个元素的全滚动区</a>。</p>
<p/>
<p id="d2ba" class="graf graf--p graf-after--figure">上面的演示和前面的一样，只是它使用了<code>scrollHeight</code>来获取每一列的高度。再次注意，两列的值是相同的。但这一次是一个高得多的数字，因为溢出区也被算作高度的一部分。</p>
<p id="93a2" class="graf graf--p graf-after--p">上面的例子集中在元素高度上，这是最常见的用例，但是你也可以使用<code>offsetWidth</code>和<code>scrollWidth</code>，它们可以以同样的方式应用于水平滚动。</p>
<h3 id="6e48" class="graf graf--h3 graf-after--p">结论</h3>
<p id="8309" class="graf graf--p graf-after--h3">这就是DOM特性的列表，这些可能是我在过去几年中遇到的最有趣的特性，所以我希望在不久的将来，这些特性中至少有一个是你能够在项目中使用的。</p>
<p id="423f" class="graf graf--p graf-after--p">请在评论中告诉我你以前是否使用过其中的一个，或者你是否能为其中的任何一个想到一些有趣的用例。</p><div class="code-block code-block-23">
<div class="blog-plug inline-plug node-plug"><h2>200只<img src="../Images/61167b9d027ca73ed5aaf59a9ec31267.png" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2019/10/green-check.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" class=" jetpack-lazy-image" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/10/green-check.png"/> <noscript> <img data-lazy-fallback="1" src="../Images/61167b9d027ca73ed5aaf59a9ec31267.png" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/10/green-check.png"/> </noscript>显示器出现故障，生产中网络请求缓慢</h2><p>部署基于节点的web应用程序或网站是容易的部分。确保您的节点实例继续为您的应用程序提供资源是事情变得更加困难的地方。如果您对确保对后端或第三方服务的请求成功感兴趣，</p><a href="https://lp.logrocket.com/blg/node-signup" target="_blank">try LogRocket</a><p>. </p><a class="signup" href="https://lp.logrocket.com/blg/node-signup" target="_blank" rel="noopener noreferrer"><img src="../Images/cae72fd2a54c5f02a6398c4867894844.png" alt="LogRocket Network Request Monitoring" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2019/12/network-request-filter-2-1.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" class=" jetpack-lazy-image" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/12/network-request-filter-2-1.png"/><noscript><img data-lazy-fallback="1" src="../Images/cae72fd2a54c5f02a6398c4867894844.png" alt="LogRocket Network Request Monitoring" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/12/network-request-filter-2-1.png"/></noscript></a><a href="https://lp.logrocket.com/blg/node-signup" target="_blank" rel="noopener noreferrer">https://logrocket.com/signup/</a><p>LogRocket 就像是网络和移动应用程序的DVR，记录下用户与你的应用程序交互时发生的一切。您可以汇总并报告有问题的网络请求，以快速了解根本原因，而不是猜测问题发生的原因。</p><p>LogRocket检测您的应用程序以记录基线性能计时，如页面加载时间、到达第一个字节的时间、慢速网络请求，还记录Redux、NgRx和Vuex操作/状态。</p><a class="signup" href="https://lp.logrocket.com/blg/node-signup" target="_blank" rel="noopener noreferrer">Start monitoring for free</a><p>. </p></div>
</div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
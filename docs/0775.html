<html>
<head>
<title>How to create a backend API with Rust and Postgres - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>如何用Rust和Postgres创建后端API</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/create-backend-api-with-rust-postgres/#0001-01-01">https://blog.logrocket.com/create-backend-api-with-rust-postgres/#0001-01-01</a></blockquote><div><article class="article-post">
<p><strong> <em>编者按</em> </strong> <em>:本帖更新于2022年2月22日，修复了与Diesel的连接并做了其他改进。</em></p>
<p>有相当多的框架使得创建REST API变得容易，同时减少了您必须编写的样板文件的数量。我个人更喜欢Rust，因为它简单、类型强、<a href="https://benchmarksgame-team.pages.debian.net/benchmarksgame/fastest/rust-go.html" target="_blank" rel="noopener">速度极快、</a><a href="https://msrc-blog.microsoft.com/2019/07/22/why-rust-for-safe-systems-programming/" target="_blank" rel="noopener">比几乎任何语言都安全。</a></p>
<p/>
<p>要继续学习本教程，您需要对API开发有一个基本的了解。你至少要明白<a href="https://blog.logrocket.com/crud-with-node-graphql-react/" target="_blank" rel="noopener"> CRUD </a>的概念。</p>
<p>我们将涵盖:</p>

<h2 id="project-requirements">项目要求</h2>
<p>在我们深入编码之前，让我们确定我们将构建什么，并回顾一些基本的需求和假设来完成演示。</p>
<p>我们将为一个样本员工管理应用程序创建所有的CRUD API端点。这将是一个基本项目，旨在展示用Rust编写API的所有基本构件。</p>
<p>我选择了Actix web 3.0框架，因为它是最流行的框架之一，有很好的文档，并且使用了类似于Node.js 中的<a href="https://blog.logrocket.com/build-rest-api-node-express-mysql/" target="_blank" rel="noopener"> Express的模式。其他受欢迎的替代品包括</a><a href="https://rocket.rs/" target="_blank" rel="noopener">火箭</a>和<a href="https://github.com/carllerche/tower-web" target="_blank" rel="noopener">塔</a>。</p>
<p>我们的数据层将由Postgres和Diesel组成，用<a href="https://diesel.rs/" target="_blank" rel="noopener"> Diesel </a>作为ORM和查询构建器。</p>
<h3>要知道的术语</h3>
<p>我写这个指南是为了让对Rust语言有基本了解的人容易理解，但是为了清楚起见，这里有一些你应该熟悉的术语。</p>
<ul>
<li>Spawn blocking:这是一种试图对抗执行繁重/长时间调用任务的线程(例如，从数据库中检索大量记录)。这个过程有助于产生新级别的线程，以避免异步函数中的延迟</li>
<li>异步(async/await):一个内置函数，用作编写异步行为的<code>async</code> / <code>await</code>工具</li>
</ul>
<h2 id="rust-project-setup-structure">Rust项目设置和结构</h2>
<p>首先，让我们看看如何建立一个基本的Rust项目，构建文件夹，并安装依赖项。如果您来自Node.js背景，您应该已经熟悉使用<code>npm</code>进行包管理和注册。Rust中的对等物称为<code>cargo</code>。</p>
<p>不幸的是，在撰写本文时，<code>cargo</code>还没有自动更新依赖项的方法，除了使用一个名为<a href="https://crates.io/crates/cargo-update%22" target="_blank" rel="noopener"> <code>cargo-update</code> </a>或<code>cargo install --force crate-name</code>的箱子，您也可以决定在<code>cargo.toml</code>文件中写出依赖项的名称和版本。</p>
<p>如果您没有安装Rust，请遵循<a href="https://www.rust-lang.org/tools/install" target="_blank" rel="noopener">安装指南</a>。否则，创建一个新项目。</p>
<pre class="language-bash hljs">cargo new emply
</pre>
<h3>项目结构</h3>
<p>以下是该项目的文件夹结构；你也可以选择你想要的结构。这意味着文件的命名约定是不言自明的。</p>
<pre class="language-plaintext hljs">employee/
  - src/
    - employees/
      - mod.rs
      - model.rs
      - routes.rs
    - db.rs
    - error_handlers.rs
    - main.rs
  - .env
  - Cargo.toml
</pre>
<p>我们的<code>mod.rs</code>文件有助于管理<code>employees</code>目录中文件的相对路径，如下所示:</p>
<pre class="language-rust hljs">mod model;
mod routes;
pub use model::*;
pub use routes::init_routes;
</pre>
<p>这是我们的应用程序的<code>Cargo.toml</code>文件:</p>
<pre class="language-json hljs">[package]
name = "employee"
version = "0.1.0"
authors = ["Ola John &lt;<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="395853505b56405c175655584a4c575258575450795b5a5e4955584d5057505657175a5654">[email protected]</a>&gt;"]
edition = "2018"
# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html
[dependencies]
actix-web = "3.0"
actix-rt = "1.0"
chrono = { version = "0.4", features = ["serde"] }
dotenv = "0.11"
diesel = { version = "1.4", features = ["postgres", "r2d2", "uuid", "chrono"] }
diesel_migrations = "1.4"
env_logger = "0.6"
lazy_static = "1.4"
listenfd = "0.3"
serde = "1.0"
serde_json = "1.0"
r2d2 = "0.8"
uuid = { version = "0.6", features = ["serde", "v4"] }
</pre>
<p>这是我们的主程序，包含一些板条箱和配置:</p>
<ul>
<li><a href="https://crates.io/crates/listenfd" target="_blank" rel="noopener"> listenfd </a>:当检测到文件有变化时重启服务器</li>
<li>dotenv :帮助管理我们的环境变量</li>
<li><code>db::init()</code>:启动数据库连接的函数，从另一个名为<code>db.rs</code>的文件中引用</li>
<li><code>employees::init_routes</code>:抽象出本项目中使用的所有路线的函数</li>
</ul>
<p>代码的另一部分是关于<code>listenfd</code>机箱的<code>actix-web</code>服务器设置。</p>
<pre class="language-rust hljs">#[actix_rt::main]
async fn main() -&gt; std::io::Result&lt;()&gt; {
    dotenv().ok();
    db::init();
    let mut listenfd = ListenFd::from_env();
    let mut server = HttpServer::new(|| App::new().configure(employees::init_routes));
    server = match listenfd.take_tcp_listener(0)? {
        Some(listener) =&gt; server.listen(listener)?,
        None =&gt; {
            let host = env::var("HOST").expect("Please set host in .env");
            let port = env::var("PORT").expect("Please set port in .env");
            server.bind(format!("{}:{}", host, port))?
        }
    };
    server.run().await
}
</pre>
<h2 id="creating-api-endpoints">创建API端点</h2>
<p>我们的端点是在名为<code>routes.rs</code>的文件中创建的。我们的路由也需要返回JSON响应，这就是为什么我们添加了<a href="https://serde.rs/" target="_blank" rel="noopener"> serde crate </a>来处理服务器上数据的序列化和反序列化。</p>
<p>我们CRUD操作的终点包括:</p>
<ul>
<li>   <ul>
<li>获取所有员工:<code>/employees</code></li>
<li>获取单个员工:<code>/employees/{id}</code></li>
<li>添加员工:<code>/employees</code></li>
<li>更新员工:<code>/employee/{id}</code></li>
<li>删除员工:<code>/employee/{id}</code></li>
</ul>
</li>
</ul>
<pre class="language-rust hljs">#[get("/employees")]
async fn find_all() -&gt; Result&lt;HttpResponse, CustomError&gt; {
    let employees = web::block(|| Employees::find_all()).await.unwrap();
    Ok(HttpResponse::Ok().json(employees))
}
#[get("/employees/{id}")]
async fn find(id: web::Path) -&gt; Result&lt;HttpResponse, CustomError&gt; {
    let employee = Employees::find(id.into_inner())?;
    Ok(HttpResponse::Ok().json(employee))
}
#[post("/employees")]
async fn create(employee: web::Json) -&gt; Result&lt;HttpResponse, CustomError&gt; {
    let employee = Employees::create(employee.into_inner())?;
    Ok(HttpResponse::Ok().json(employee))
}
#[put("/employees/{id}")]
async fn update(
    id: web::Path,
    employee: web::Json,
) -&gt; Result&lt;HttpResponse, CustomError&gt; {
    let employee = Employees::update(id.into_inner(), employee.into_inner())?;
    Ok(HttpResponse::Ok().json(employee))
}
#[delete("/employees/{id}")]
async fn delete(id: web::Path) -&gt; Result&lt;HttpResponse, CustomError&gt; {
    let deleted_employee = Employees::delete(id.into_inner())?;
    Ok(HttpResponse::Ok().json(json!({ "deleted": deleted_employee })))
}
pub fn init_routes(config: &amp;mut web::ServiceConfig) {
    config.service(find_all);
    config.service(find);
    config.service(create);
    config.service(update);
    config.service(delete);
}</pre>
<p>创建异步函数是为了将我们所有的CRUD操作抽象成一个名为<code>Employees</code>的实现类型。它们返回<code>Result&lt;HttpResponse, CustomError&gt;</code>，其中<code>CustomError</code>在我们的<code>error_handler.rs</code>文件中声明，这更像是拥有一个定制的异常处理程序。</p>
<p>如上所述，我们在一个名为<code>init_routes()</code>的函数中注册了我们的路线，以获得一个更清晰、更模块化的代码。</p>
<p>注意，我们添加了<code>spawn blocking</code>来获取所有雇员的端点，以便在我们从数据库中查询大量记录的情况下，该流程不会阻塞其他任务的执行。</p>
<pre class="language-rust hljs">let employees = web::block(|| Employees::find_all()).await.unwrap();
</pre>
<h2 id="setting-up-postgres-connection">设置我们的Postgres连接</h2>
<p><code>db.rs</code>文件包含到我们的PostgreSQL数据库的连接池，<code>connection()</code>和<code>init()</code>被用作其他文件中可访问性的公共函数。我们还使用<a href="https://crates.io/crates/lazy_static" target="_blank" rel="noopener"> <code>lazy_static</code>机箱</a>来要求静态代码在运行时执行，以便进行初始化；在这种情况下，它是我们的数据库连接。</p>
<pre class="language-rust hljs">use crate::error_handler::CustomError;
use diesel::pg::PgConnection;
use diesel::r2d2::ConnectionManager;
use lazy_static::lazy_static;
use r2d2;
use std::env;
type Pool = r2d2::Pool&lt;ConnectionManager&lt;PgConnection&gt;&gt;;
pub type DbConnection = r2d2::PooledConnection&lt;ConnectionManager&lt;PgConnection&gt;&gt;;
embed_migrations!();
lazy_static! {
    static ref POOL: Pool = {
        let db_url = env::var("DATABASE_URL").expect("Database url not set");
        let manager = ConnectionManager::&lt;PgConnection&gt;::new(db_url);
        Pool::new(manager).expect("Failed to create db pool")
    };
}
pub fn init() {
    lazy_static::initialize(&amp;POOL);
    let conn = connection().expect("Failed to get db connection");
    embedded_migrations::run(&amp;conn).unwrap();
}
pub fn connection() -&gt; Result&lt;DbConnection, CustomError&gt; {
    POOL.get()
        .map_err(|e| CustomError::new(500, format!("Failed getting db connection: {}", e)))
}
</pre>
<h2 id="using-diesel-set-up-orm">使用柴油来建立我们的ORM</h2>
<p>Diesel被用作我们的对象关系映射器(ORM ),方便查询和数据库表的对象映射。查看<a href="https://diesel.rs/" target="_blank" rel="noopener"> diesel.rs </a>获取设置和安装的完整指南。</p>
<pre class="language-rust hljs">#[derive(Serialize, Deserialize, AsChangeset, Insertable)]
#[table_name = "employees"]
pub struct Employee {
    pub first_name: String,
    pub last_name: String,
    pub department: String,
    pub salary: i32,
    pub age: i32,
}

#[derive(Serialize, Deserialize, Queryable)]
pub struct Employees {
    pub id: i32,
    pub first_name: String,
    pub last_name: String,
    pub department: String,
    pub salary: i32,
    pub age: i32,
}

impl Employees {
    pub fn find_all() -&gt; Result&lt;Vec&lt;Self&gt;, CustomError&gt; {
        let conn = db::connection()?;
        let employees = employees::table.load::&lt;Employees&gt;(&amp;conn)?;
        Ok(employees)
    }
    pub fn find(id: i32) -&gt; Result&lt;Self, CustomError&gt; {
        let conn = db::connection()?;
        let employee = employees::table.filter(employees::id.eq(id)).first(&amp;conn)?;
        Ok(employee)
    }
    pub fn create(employee: Employee) -&gt; Result&lt;Self, CustomError&gt; {
        let conn = db::connection()?;
        let employee = Employee::from(employee);
        let employee = diesel::insert_into(employees::table)
            .values(employee)
            .get_result(&amp;conn)?;
        Ok(employee)
    }
    pub fn update(id: i32, employee: Employee) -&gt; Result&lt;Self, CustomError&gt; {
        let conn = db::connection()?;
        let employee = diesel::update(employees::table)
            .filter(employees::id.eq(id))
            .set(employee)
            .get_result(&amp;conn)?;
        Ok(employee)
    }
    pub fn delete(id: i32) -&gt; Result&lt;usize, CustomError&gt; {
        let conn = db::connection()?;
        let res = diesel::delete(employees::table.filter(employees::id.eq(id))).execute(&amp;conn)?;
        Ok(res)
    }
}
impl Employee {
    fn from(employee: Employee) -&gt; Employee {
        Employee {
            first_name: employee.first_name,
            last_name: employee.last_name,
            department: employee.department,
            salary: employee.salary,
            age: employee.age,
        }
    }
}
</pre>
<p>Diesel模型映射用于标识表中的列。宏<code>AsChangeset</code>、<code>Insertable</code>和<code>Queryable</code>被指定执行诸如查询记录和在我们的表上插入的操作。<code>serde</code> crate还可以序列化和反序列化注释，并用于将我们的模型与JSON相互转换。</p>
<pre class="language-rust hljs">// Insertion and other operation
#[derive(Serialize, Deserialize, AsChangeset, Insertable)]
#[table_name = "employees"]
pub struct Employee {
    pub first_name: String,
    pub last_name: String,
    pub department: String,
    pub salary: i32,
    pub age: i32,
}
// Diesel ORM object mapping for to query table
#[derive(Serialize, Deserialize, Queryable)]
pub struct Employees {
    pub id: i32,
    pub first_name: String,
    pub last_name: String,
    pub department: String,
    pub salary: i32,
    pub age: i32,
}
</pre>
<h2 id="running-rust-api-demo-app">运行我们的Rust API演示应用</h2>
<p>让我们测试一下一切是否如预期的那样工作。如果您运行<code>cargo watch</code>命令，您应该能够通过您的API端点从数据库中创建、读取、更新和删除(CRUD)一个雇员。</p>
<p><img data-attachment-id="96716" data-permalink="https://blog.logrocket.com/create-backend-api-with-rust-postgres/crud-operations-api-built-rust-postgres/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/04/crud-operations-api-built-rust-postgres.png" data-orig-size="730,617" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="crud-operations-api-built-rust-postgres" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/04/crud-operations-api-built-rust-postgres-300x254.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/04/crud-operations-api-built-rust-postgres.png" decoding="async" class="aligncenter size-full wp-image-96716 jetpack-lazy-image" src="../Images/b12aaabbb5586bc9b849452e89f95cc9.png" alt="CRUD operations in an API built with Rust and Postgres" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2020/04/crud-operations-api-built-rust-postgres.png 730w, https://blog.logrocket.com/wp-content/uploads/2020/04/crud-operations-api-built-rust-postgres-300x254.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2020/04/crud-operations-api-built-rust-postgres.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/04/crud-operations-api-built-rust-postgres.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="96716" data-permalink="https://blog.logrocket.com/create-backend-api-with-rust-postgres/crud-operations-api-built-rust-postgres/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/04/crud-operations-api-built-rust-postgres.png" data-orig-size="730,617" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="crud-operations-api-built-rust-postgres" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/04/crud-operations-api-built-rust-postgres-300x254.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/04/crud-operations-api-built-rust-postgres.png" decoding="async" loading="lazy" class="aligncenter size-full wp-image-96716" src="../Images/b12aaabbb5586bc9b849452e89f95cc9.png" alt="CRUD operations in an API built with Rust and Postgres" srcset="https://blog.logrocket.com/wp-content/uploads/2020/04/crud-operations-api-built-rust-postgres.png 730w, https://blog.logrocket.com/wp-content/uploads/2020/04/crud-operations-api-built-rust-postgres-300x254.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/04/crud-operations-api-built-rust-postgres.png"/></noscript>
<p>在<a href="https://github.com/olajohn-ajiboye/Rust-Rest-API" target="_blank" rel="noopener"> GitHub </a>上查看本教程引用的完整代码。</p>
<h2>结论</h2>
<p>您现在应该理解了如何使用Actix在Rust中创建API端点和处理简单的请求响应周期。我们讨论了如何构建端点来处理基本的CRUD操作，用Diesel ORM管理数据。</p>
<p>我真正喜欢用Rust构建API的地方是，它通过让你批判性地思考你的代码来实施良好的实践。如果你的代码可以编译，那么实际上就可以保证它能完成预期的任务。</p>
<p>如需深入了解，请参考已完成的<a href="https://github.com/iamhabbeboy/rest-api-actix-web" target="_blank" rel="noopener"> GitHub repo </a>。</p><div class="code-block code-block-29">
<div class="blog-plug inline-plug rust-plug"><h2><a href="https://lp.logrocket.com/blg/rust-signup" target="_blank">log rocket</a>:Rust应用的web前端的全面可见性</h2><p>调试Rust应用程序可能很困难，尤其是当用户遇到难以重现的问题时。如果您对监控和跟踪Rust应用程序的性能、自动显示错误、跟踪缓慢的网络请求和加载时间感兴趣，</p><a href="https://lp.logrocket.com/blg/rust-signup" target="_blank">try LogRocket</a><p>. </p><a class="signup" href="https://lp.logrocket.com/blg/rust-signup" target="_blank" rel="noopener noreferrer"><img class="alignnone size-full wp-image-46 jetpack-lazy-image" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/><noscript><img data-lazy-fallback="1" class="alignnone size-full wp-image-46" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/></noscript></a><p>LogRocket 就像是网络和移动应用程序的DVR，记录你的Rust应用程序上发生的一切。您可以汇总并报告问题发生时应用程序的状态，而不是猜测问题发生的原因。LogRocket还可以监控应用的性能，报告客户端CPU负载、客户端内存使用等指标。</p><p>现代化调试Rust应用的方式— <a class="signup" href="https://lp.logrocket.com/blg/rust-signup" target="_blank" rel="noopener noreferrer">开始免费监控</a>。</p></div>


</div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
<html>
<head>
<title>React Native vs. Ionic - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>React Native vs. Ionic - LogRocket博客</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/react-native-vs-ionic/#0001-01-01">https://blog.logrocket.com/react-native-vs-ionic/#0001-01-01</a></blockquote><div><article class="article-post">
<p><em> <strong>编者按</strong>:本文由<a href="https://blog.logrocket.com/author/shadmirza/">沙德·米尔扎</a>于2023年2月8日进行最后一次审核和准确性更新。</em></p>
<p>截至2023年2月，<a href="https://explodingtopics.com/blog/mobile-internet-traffic">60%的网站流量来自使用移动设备的人</a>。因此，开发优秀的移动应用程序的需求与日俱增，构建移动应用程序的方法也越来越多。</p>
<p>随着对混合应用的需求不断增加，新的框架正在出现，帮助我们快速构建跨平台的应用。这是对SwitchUI、React Native、Cordova、Xamarin、Ionic、Jetpack Compose和Flutter等现有框架的补充。</p>
<p>今天，我们将使用Ionic和React Native构建一个应用程序，根据一系列标准来比较这两个框架。我们将理解这两个框架的亮点以及它们之间的权衡。开始吧！</p>
<p><em>向前跳跃</em>:</p>

<h2 id="ionic-framework">离子框架</h2>
<p>Ionic是一个开源UI工具包，用于使用web技术构建高性能、高质量的移动应用。它是平台不可知的，这意味着我们可以使用React、Angular甚至Vue来构建应用。</p>
<p>您可以使用HTML、CSS、JavaScript和Ionic UI工具包的组件快速构建Ionic应用程序，这些组件在每个平台上都很漂亮。这些高级组件构成了Ionic应用程序的构建模块。我们为web构建Ionic应用程序，并在WebView wrapper的帮助下将其部署到Android和iOS设备上。这种应用程序被称为混合应用程序。</p>
<p>因为所有的设备都使用同一个web应用程序，我们可以在所有平台上共享代码，节省时间。离子应用是网络第一，所以支持本机功能，如相机，全球定位系统等。，多走了一步。</p>
<p>我们必须安装插件，为每一个本地功能，我们想用科尔多瓦或电容器。拥有使用原生特性的可能性，以及使用HTML和CSS迭代的速度，使得Ionic成为构建跨平台混合应用程序的绝佳选择。</p>
<h2 id="building-ionic-app">构建Ionic应用程序</h2>
<p>我们将使用React和Ionic构建一个基本的石头、剪子、布游戏。这个演示将帮助我们理解和比较Ionic开发工作流程和ReactNative。</p>
<p>首先，让我们安装<code>@ionic/cli</code>包来帮助我们启动一个Ionic应用程序:</p>
<pre class="language-bash hljs">npm install -g @ionic/cli
</pre>
<p>现在，我们可以使用这个包来创建我们的应用程序:</p>
<pre class="language-bash hljs">ionic start ionic-rock-paper-scissors blank --type react
</pre>
<p>注意上面命令中的<code>--type react</code>。这意味着我们选择React作为我们的框架。也可以挑Angular或者Vue。</p>
<p>一旦我们的应用程序创建完成，我们可以使用下面的命令启动本地开发服务器:</p>
<pre class="language-javascript hljs">ionic serve 
</pre>
<p>它应该会在您的浏览器中打开应用程序:</p>
<p><img data-attachment-id="160545" data-permalink="https://blog.logrocket.com/react-native-vs-ionic/attachment/opening-ionic-app/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2019/07/opening-ionic-app.png" data-orig-size="730,470" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Opening the Ionic app" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2019/07/opening-ionic-app-300x193.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2019/07/opening-ionic-app.png" decoding="async" class="aligncenter size-full wp-image-160545 jetpack-lazy-image" src="../Images/8dfa61ce7edb8d525a44a929ebd9eb07.png" alt="Opening The Ionic App" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2019/07/opening-ionic-app.png 730w, https://blog.logrocket.com/wp-content/uploads/2019/07/opening-ionic-app-300x193.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2019/07/opening-ionic-app.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/07/opening-ionic-app.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="160545" data-permalink="https://blog.logrocket.com/react-native-vs-ionic/attachment/opening-ionic-app/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2019/07/opening-ionic-app.png" data-orig-size="730,470" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Opening the Ionic app" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2019/07/opening-ionic-app-300x193.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2019/07/opening-ionic-app.png" decoding="async" loading="lazy" class="aligncenter size-full wp-image-160545" src="../Images/8dfa61ce7edb8d525a44a929ebd9eb07.png" alt="Opening The Ionic App" srcset="https://blog.logrocket.com/wp-content/uploads/2019/07/opening-ionic-app.png 730w, https://blog.logrocket.com/wp-content/uploads/2019/07/opening-ionic-app-300x193.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/07/opening-ionic-app.png"/></noscript>
<p>如果您注意到文件夹结构，我们已经创建了一个<code>src</code>文件夹，并添加了一些样板文件。这很有帮助，因为我们可以开始更改一些引导代码，并在浏览器上看到我们的更改。</p>
<p><code>/pages</code>目录包括我们的应用程序包含的所有页面。我们现在对<code>home.jsx</code>页面很满意，但是我们可以随时添加更多。</p>
<p>类似地，<code>/components</code>目录包含了所有的组件。我们可以创建一个新的组件<code>GameContainer.jsx</code>，并开始编写我们的代码。</p>
<h3 id="add-ui-game-ionic">在Ionic中为游戏添加用户界面</h3>
<p>让我们开始添加一些JSX，这将渲染应用程序。之后我们将开始添加逻辑:</p>
<pre class="language-css hljs">import { IonButton } from "@ionic/react";
import "./GameContainer.css";

const GameContainer = () =&gt; {
  return (
    &lt;div className="container"&gt;
      &lt;div className="user-choice"&gt;
        &lt;IonButton color="primary" onClick={() =&gt; onSelect("rock")}&gt;
          Rock 🪨
        &lt;/IonButton&gt;
        &lt;IonButton color="secondary" onClick={() =&gt; onSelect("paper")}&gt;
          Paper 📄
        &lt;/IonButton&gt;
        &lt;IonButton color="tertiary" onClick={() =&gt; onSelect("scissors")}&gt;
          Scissor ✂️
        &lt;/IonButton&gt;
      &lt;/div&gt;
    &lt;/div&gt;
  );
};

export default GameContainer;
</pre>
<p>我们添加了三个按钮来帮助用户进行选择。如果你仔细注意，我们使用的是<code>@ionic/react</code>包中的<code>IonicButton</code>。<code>IonicButton</code>是爱奥尼亚提供的高级构建模块之一。它们在Ionic世界中被称为组件，我们可以直接在我们的Ionic app中使用它们。</p>
<p>Ionic有大量这样的组件，帮助我们快速构建应用原型。你可以在他们的文档网站上查看这些组件。</p>
<p>因为我们正在使用React，所以我们可以使用state并构建我们的应用程序的逻辑。让我们从添加一些状态和处理程序开始。请遵循代码块中的注释:</p>
<pre class="language-javascript hljs">// create a tuple that helps us choose between rock paper scissors from a random index
const choiceArray = ["rock", "paper", "scissors"];

// create state to save user and computer choice
const [userChoice, setUserChoice] = useState(null);
const [compChoice, setCompChoice] = useState(null);

// save winner or draw in winner state
const [winner, setWinner] = useState(null);

// create states for scoreboard
const [userScore, setUserScore] = useState(0);
const [compScore, setCompScore] = useState(0);

// add onSelect handler to save user and computer choice
const onSelect = (choice) =&gt; {
  setUserChoice(choice);
  setCompChoice(getComputerChoice());
};

// add a helper function to get a random choice for computer
const getComputerChoice = () =&gt; {
  const random = Math.floor(Math.random() * 3);
  return choiceArray[random];
};
</pre>
<p>现在我们已经初始化了状态并添加了选择处理程序，我们可以编写选择获胜者的逻辑了:</p>
<pre class="language-javascript hljs">// add a helper function to select the winner
const getWinner = useCallback(() =&gt; {
  if (userChoice === null) return null;
  if (userChoice === compChoice) return "draw";
  if (priorityMap[userChoice] === compChoice) {
    return "user";
  }
  return "computer";
}, [userChoice, compChoice]);

// select the winner whenever user and computer choice are updated
useEffect(() =&gt; {
  const whoWon = getWinner();
  if (!whoWon) return;
  setWinner(whoWon);

  // update the scoreboard
  if (whoWon === "user") {
    setUserScore((prevValue) =&gt; prevValue + 1);
  }
  if (whoWon === "computer") {
    setCompScore((prevValue) =&gt; prevValue + 1);
  }
}, [userChoice, compChoice, getWinner]);
</pre>
<p>我们选择赢家的逻辑就完成了。现在，让我们在JSX中快速添加获奖者信息和记分牌:</p>
<pre class="language-javascript hljs">return (
  &lt;div className="container"&gt;
    // add scoreboard
    &lt;div className="score-sheet"&gt;
      &lt;h2&gt;Score&lt;/h2&gt;
      &lt;div className="score-container"&gt;
        &lt;div className="score-board"&gt;
          &lt;p className="score-name"&gt;User&lt;/p&gt;
          &lt;p className="score-value"&gt;{userScore}&lt;/p&gt;
        &lt;/div&gt;
        &lt;div className="score-board"&gt;
          &lt;p className="score-name"&gt;Computer&lt;/p&gt;
          &lt;p className="score-value"&gt;{compScore}&lt;/p&gt;
        &lt;/div&gt;
      &lt;/div&gt;
    &lt;/div&gt;
    &lt;div&gt;
      {winner &amp;&amp; (
        &lt;p className="winner-text"&gt;
          You selected {userChoice} while computer selected {compChoice}
        &lt;/p&gt;
      )}
      {winner &amp;&amp;
        (winner === "draw" ? (
          &lt;p className="winner-text"&gt;Match was a draw&lt;/p&gt;
        ) : (
          &lt;p className="winner-text"&gt;{winner} is winner&lt;/p&gt;
        ))}
    &lt;/div&gt;
    &lt;div className="user-choice"&gt;
      &lt;IonButton color="primary" onClick={() =&gt; onSelect("rock")}&gt;
        Rock 🪨
      &lt;/IonButton&gt;
      &lt;IonButton color="secondary" onClick={() =&gt; onSelect("paper")}&gt;
        Paper 📄
      &lt;/IonButton&gt;
      &lt;IonButton color="tertiary" onClick={() =&gt; onSelect("scissors")}&gt;
        Scissor ✂️
      &lt;/IonButton&gt;
    &lt;/div&gt;
  &lt;/div&gt;
);
</pre>
<p>我们的应用程序已经完成，但我们还没有完成。我们讨论了Ionic如何让我们通过插件来挂钩本地特性。让我们添加一个选项，通过移动设备上支持的Share API来共享游戏结果。</p>
<blockquote><p>注意:支持Web共享API，但需要更加可靠。</p></blockquote>
<p>首先安装<code>@capacitor/share</code>插件:</p>
<pre class="language-javascript hljs">npm install @capacitor/share
npx cap sync
</pre>
<p>现在，我们可以通过一个按钮来处理共享:</p>
<pre class="language-javascript hljs">// import Icon 
import { IonButton, IonIcon } from "@ionic/react";
import { shareOutline } from "ionicons/icons";
// import the plugin
import { Share } from '@capacitor/share';

// add a share handler function
const handleResultShare = async () =&gt; {
    await Share.share({
      title: 'Checkout my result in rock, paper, scissors',
      text: `My score is User: ${userScore} and Computer: ${compScore}`,
      url: 'http://gameurl.com/',
      dialogTitle: 'Share with buddies',
    });
  }

// add a button in jsx
&lt;IonButton
  className="share-button"
  color="primary"
  expand="block"
  onClick={handleResultShare}
&gt;
  Share &lt;IonIcon slot="end" icon={shareOutline}&gt;&lt;/IonIcon&gt;
&lt;/IonButton&gt;
</pre>
<blockquote><p>您可以根据自己的喜好更新CSS。</p></blockquote>
<p>您也可以使用以下命令在模拟器中预览应用程序:</p>
<pre class="language-css hljs">ionic capacitor run ios -l --external
</pre>
<p>这是游戏应该有的样子，还有分享动作:</p>
<p> </p>

<p>我们的应用程序现在已经完成了！Ionic应用程序能够支持PWA。如果您查看<code>index.js</code>文件，您会看到已经添加了服务人员:</p>
<pre class="language-javascript hljs">// If you want your app to work offline and load faster, you can change
// unregister() to register() below. Note this comes with some pitfalls.
// Learn more about service workers: https://cra.link/PWA
serviceWorkerRegistration.unregister();
</pre>
<p>Ionic中的PWA是一个可选功能。您可以将其更改为注册一名服务人员，我们的应用程序将支持PWA:</p>
<pre class="language-javascript hljs">serviceWorkerRegistration.register();
</pre>
<p>PWA需要一个清单文件和一个服务人员。多亏了Ionic，它还被添加到了公共文件夹中，你可以根据自己的需要进行定制。</p>
<p>这将允许我们的应用程序离线工作，加载速度更快。您可以在<a href="https://ionicframework.com/docs/react/pwa">文档页面上阅读有关Ionic PWA的更多信息。</a></p>
<p>完整的代码可以在<a href="https://github.com/iamshadmirza/ionic-rock-paper-scissors"> GitHub库</a>上找到。</p>
<p>我们来讨论一下选择爱奥尼亚的利与弊。</p>
<h3 id="ionic-pros">Ionic pros</h3>
<p>我们使用了<code>IonicButton</code>，一个来自离子库中的现成组件。Ionic提供了大量这样的组件，帮助我们快速制作原型。这些组件都是精心打造的，在Android、iOS和网络上看起来都很不错。我们不必担心跨平台的样式和一致性。</p><div class="code-block code-block-54">
<hr/>
<h3>更多来自LogRocket的精彩文章:</h3>

<hr/></div>
<p>Ionic几乎没有学习曲线；我们可以使用普通的HTML、CSS和JavaScript。任何web开发者都可以从第一天开始构建混合应用。Ionic对于我们想要使用的框架也很灵活。我们可以在反应、角度或Vue中选择任何一个。</p>
<p>另外，开发只需要一个浏览器；不用担心安装XCode或者Android Studio进行开发。此外，各种各样的插件可用于挂钩本机功能。</p>
<p>最后，对PWA的一流支持允许应用程序离线工作，获得推送通知，加载更快，并提供更像应用程序的感觉。</p>
<h3 id="ionic-cons">离子cons</h3>
<p>该应用程序主要是一个包装在WebView中的网页，性能不如真正的原生应用程序。</p>
<p>添加原生功能需要一个额外的步骤，并且您必须为您想要使用的每个功能安装原生插件。</p>
<p>UI组件是一致的，这意味着它们跨平台看起来是一样的。这既是优点也是缺点，因为每个论坛都有自己的设计语言。Android和iOS的观感不一样，这是一个Ionic app很难得到的。</p>
<p>最后，由于性能瓶颈，任何动画密集型应用在Ionic上都表现不佳。</p>
<h2 id="react-native">反应自然</h2>
<p>React Native是一个用于构建跨平台应用的开源库，它是基于React的，因为它使用了驱动React的相同引擎。</p>
<p>与Ionic不同，React原生应用是真正的原生应用。React Native提供的组件是围绕其本机对应组件的JavaScript包装器。编译后的应用将是真正的原生应用，就像使用Android Swift或XCode一样。</p>
<p>这是一个巨大的优势，因为原生应用程序可以更有效地使用设备，并提供原生体验。</p>
<p>React Native也有丰富的原生组件库，每个平台都遵循不同的设计语言。单一的代码库有助于我们构建跨平台的应用程序，在Android和iOS上都能提供原生的感觉。</p>
<p>使用React Native的几家知名公司是脸书、Instagram、Flipkart、比特币基地和Discord。</p>
<p>我们来搭建一个app，详细了解一下React Native。</p>
<h3 id="building-react-native-app">构建React本机应用程序</h3>
<p>我们将构建和以前一样的石头、布、剪刀游戏，但是使用React Native。这将帮助我们理解框架之间的核心差异。</p>
<p>Expo是现在启动React原生项目的最佳方式，我们将使用它来快速启动React原生应用:</p>
<pre class="language-bash hljs">npx create-expo-app rn-rock-paper-scissors
</pre>
<p>一旦我们的应用程序创建完成，我们就可以启动本地开发服务器:</p>
<pre class="language-bash hljs">npm run ios
</pre>
<p>这将在模拟器中打开应用程序:</p>
<p><img data-attachment-id="160555" data-permalink="https://blog.logrocket.com/react-native-vs-ionic/attachment/opening-app-simulator/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2019/07/opening-app-simulator.png" data-orig-size="564,919" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Opening the app in the simulator" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2019/07/opening-app-simulator-184x300.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2019/07/opening-app-simulator.png" decoding="async" class="aligncenter size-full wp-image-160555 jetpack-lazy-image" src="../Images/7b9cc390940db9e161c0b127f53ed719.png" alt="Opening The App In The Simulator" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2019/07/opening-app-simulator.png 564w, https://blog.logrocket.com/wp-content/uploads/2019/07/opening-app-simulator-184x300.png 184w" data-lazy-sizes="(max-width: 564px) 100vw, 564px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2019/07/opening-app-simulator.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/07/opening-app-simulator.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="160555" data-permalink="https://blog.logrocket.com/react-native-vs-ionic/attachment/opening-app-simulator/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2019/07/opening-app-simulator.png" data-orig-size="564,919" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Opening the app in the simulator" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2019/07/opening-app-simulator-184x300.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2019/07/opening-app-simulator.png" decoding="async" loading="lazy" class="aligncenter size-full wp-image-160555" src="../Images/7b9cc390940db9e161c0b127f53ed719.png" alt="Opening The App In The Simulator" srcset="https://blog.logrocket.com/wp-content/uploads/2019/07/opening-app-simulator.png 564w, https://blog.logrocket.com/wp-content/uploads/2019/07/opening-app-simulator-184x300.png 184w" sizes="(max-width: 564px) 100vw, 564px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/07/opening-app-simulator.png"/></noscript>
<p>我们需要创建一个文件夹结构，就像前面的Ionic项目一样。它让我们可以根据自己的需要自由定制，但需要我们付出额外的努力。</p>
<p>我要让它和Ionic项目里的那个差不多。<code>/screens</code>目录将包括我们应用程序的所有屏幕。类似地，<code>/components</code>目录将包含所有组件。所有的东西都会被包在一个<code>src</code>文件夹里。</p>
<h3 id="add-ui-game-react-native">在React Native中为游戏添加UI</h3>
<p>让我们开始添加一些JSX，这将渲染应用程序。我们将首先开始创建一个屏幕。在<code>screens</code>文件夹中添加一个文件<code>Home.jsx</code>:</p>
<pre class="language-javascript hljs">// src/screens/Home.jsx
import { View, Text } from 'react-native'
import React from 'react'

const Home = () =&gt; {
  return (
    &lt;View&gt;
      &lt;Text&gt;Home&lt;/Text&gt;
    &lt;/View&gt;
  )
}

export default Home
</pre>
<p>如果你仔细观察，你会发现我们正在从<code>react-native</code>包装中进口<code>View</code>和<code>Text</code>组件。这些是React Native提供的原生组件，还有很多类似的组件。</p>
<p>Ionic为我们提供了丰富的现成组件。在这点上，React Native是不受欢迎的。它只在本地UI组件上提供了一个JavaScript包装器；我们可以自己设计。</p>
<p>但是感谢丰富的社区，我们有许多组件库可用。我们将安装<code>react-native-elements</code>，它就是这样一个库。</p>
<p>运行以下命令从npm安装React本机元素:</p>
<pre class="language-bash hljs">npm install @rneui/themed @rneui/base
</pre>
<p>我们还需要另一个名为<code>react-native-safe-area-context</code>的包。让我们也快速安装它:</p>
<pre class="language-bash hljs">npx expo install react-native-safe-area-context
</pre>
<p>这将安装一个支持Expo的版本<code>react-native-safe-area-context</code>。</p>
<p>现在我们已经准备好构建我们的游戏了。因为我们使用React，所以状态和其他逻辑将与Ionic相同，只有组件的用法不同:</p>
<pre class="language-javascript hljs">import React, { useEffect, useState, useCallback } from "react";
import { Button, Header } from "@rneui/base";
import { StyleSheet, Text } from "react-native";
import { View } from "react-native";
import { EvilIcons } from "@expo/vector-icons";
import { useSafeAreaInsets } from "react-native-safe-area-context";

const choiceArray = ["rock", "paper", "scissors"];
const priorityMap = {
  scissors: "paper",
  rock: "scissors",
  paper: "rock",
};

const Home = () =&gt; {
  const { bottom } = useSafeAreaInsets();
  const [userChoice, setUserChoice] = useState(null);
  const [compChoice, setCompChoice] = useState(null);
  const [winner, setWinner] = useState(null);
  const [userScore, setUserScore] = useState(0);
  const [compScore, setCompScore] = useState(0);

  const onSelect = (choice) =&gt; {
    setUserChoice(choice);
    setCompChoice(getComputerChoice());
  };

  const getComputerChoice = () =&gt; {
    const random = Math.floor(Math.random() * 3);
    return choiceArray[random];
  };

  const getWinner = useCallback(() =&gt; {
    if (userChoice === null) return null;
    if (userChoice === compChoice) return "draw";
    if (priorityMap[userChoice] === compChoice) {
      return "user";
    }
    return "computer";
  }, [userChoice, compChoice]);

  useEffect(() =&gt; {
    const whoWon = getWinner();
    if (!whoWon) return;
    setWinner(whoWon);
    if (whoWon === "user") {
      setUserScore((prevValue) =&gt; prevValue + 1);
    }
    if (whoWon === "computer") {
      setCompScore((prevValue) =&gt; prevValue + 1);
    }
  }, [userChoice, compChoice, getWinner]);

  return (
    &lt;&gt;
      &lt;Header
        centerComponent={{ text: "Rock Paper Scissors", style: styles.heading }}
      /&gt;
      &lt;View style={{ flex: 1, paddingBottom: bottom }}&gt;
        &lt;View style={styles.scoreSheet}&gt;
          &lt;Text style={styles.scoreHeading}&gt;Score&lt;/Text&gt;
          &lt;View style={styles.scoreContainer}&gt;
            &lt;View style={styles.scoreBoard}&gt;
              &lt;Text style={styles.scoreName}&gt;User&lt;/Text&gt;
              &lt;Text style={styles.scoreValue}&gt;{userScore}&lt;/Text&gt;
            &lt;/View&gt;
            &lt;View style={styles.scoreBoard}&gt;
              &lt;Text style={styles.scoreName}&gt;Computer&lt;/Text&gt;
              &lt;Text style={styles.scoreValue}&gt;{compScore}&lt;/Text&gt;
            &lt;/View&gt;
          &lt;/View&gt;
          &lt;Text style={styles.winnerText}&gt;
            You selected {userChoice} while computer selected {compChoice}
          &lt;/Text&gt;
          {winner &amp;&amp;
            (winner === "draw" ? (
              &lt;Text style={styles.winnerText}&gt;Match was a draw&lt;/Text&gt;
            ) : (
              &lt;Text style={styles.winnerText}&gt;{winner} is winner&lt;/Text&gt;
            ))}
        &lt;/View&gt;
        &lt;View style={styles.btnWrapper}&gt;
          &lt;Button
            title="Rock 🪨"
            size="sm"
            buttonStyle={styles.button}
            containerStyle={styles.btnContainer}
            onPress={() =&gt; onSelect("rock")}
          /&gt;
          &lt;Button
            title="Paper 📄"
            size="sm"
            buttonStyle={[styles.button, { backgroundColor: "tomato" }]}
            containerStyle={styles.btnContainer}
            onPress={() =&gt; onSelect("paper")}
          /&gt;
          &lt;Button
            title="Scissor ✂️"
            size="sm"
            buttonStyle={[styles.button, { backgroundColor: "green" }]}
            containerStyle={styles.btnContainer}
            onPress={() =&gt; onSelect("scissors")}
          /&gt;
        &lt;/View&gt;
      &lt;/View&gt;
    &lt;/&gt;
  );
};

const styles = StyleSheet.create({
  heading: {
    color: "white",
    fontSize: 16,
    fontWeight: "600",
  },
  scoreSheet: {
    flex: 1,
    flexDirection: "column",
    alignItems: "center",
  },
  scoreHeading: {
    fontSize: 32,
    fontWeight: "800",
    alignSelf: "center",
  },
  scoreContainer: {
    flexDirection: "row",
    alignSelf: "center",
    marginTop: 12,
  },
  scoreBoard: {
    flexDirection: "column",
    alignItems: "center",
    marginHorizontal: 10,
    marginBottom: 26,
  },
  scoreName: {
    fontSize: 18,
    fontWeight: "700",
  },
  scoreValue: {
    fontSize: 32,
  },
  winnerText: {
    fontSize: 16,
    fontWeight: "700",
    marginTop: 10,
    textAlign: "center",
  },
  button: {
    backgroundColor: "rgba(78, 116, 289, 1)",
    borderRadius: 3,
    width: 100,
    paddingVertical: 10,
  },
  shareBtn: {
    backgroundColor: "teal",
    alignSelf: "flex-end",
    margin: 5,
  },
  btnWrapper: {
    flexDirection: "row",
    width: "100%",
    justifyContent: "space-around",
  },
});

export default Home;
</pre>
<p>我们看到了如何在Ionic中安装共享插件。这已经没有必要了，因为React Native对一些常见的原生特性如<code>Share</code>有一流的支持。您可以直接从<code>react-native</code>包中导入<code>Share</code>并开始使用:</p>
<pre class="language-javascript hljs">// add import
import { Share } from 'react-native';

// add a share handler function
const handleResultShare = async () =&gt; {
  await Share.share({
    title: "Checkout my result in rock, paper, scissors",
    message: `My score is User: ${userScore} and Computer: ${compScore}`,
    url: "http://gameurl.com/",
  });
};

// add a button to handle share functionality
&lt;Button
  title="Share"
  icon={&lt;EvilIcons name="share-apple" size={28} color="white" /&gt;}
  iconRight
  buttonStyle={[styles.button, styles.shareBtn]}
  onPress={handleResultShare}
/&gt;;
</pre>
<p>让我们来看看实际的分享表:</p>

<p> </p>
<p>我们的应用程序现在已经完成了！完整的代码可以在<a href="https://github.com/iamshadmirza/rn-rock-paper-scissors"> GitHub库</a>上找到。</p>
<p>现在，我们来讨论一下选择React Native的好处和坏处。</p>
<h3 id="react-native-pros">反应本土专业人士</h3>
<ul>
<li>默认情况下，使用React Native构建的应用程序是高性能的。React Native提供的组件提供了类似本机的性能和感觉</li>
<li>因为我们使用的是原生组件，所以结果与使用Android Studio或XCode构建的组件没有区别</li>
<li>大部分代码在Android和iOS之间共享，节省了大量开发时间</li>
<li>诸如动画、相机、视频回放和无限列表等计算繁重的任务可以添加到React本机应用程序中</li>
<li>一个支持许多第三方库的丰富社区，使得快速添加复杂功能变得更加容易</li>
<li>与其他应用相比，测试React本地应用更容易</li>
<li>React Native是非单调性的，所以我们可以使用我们选择的任何组件库</li>
<li>它还可以使用<code>react-native-web</code>转换成一个web应用，最终帮助我们在Android、iOS和web之间共享，同时保持移动设备的性能</li>
<li>在React本地应用上添加可访问性和离线支持要容易得多</li>
</ul>
<h3 id="react-native-cons">应对本土的不利因素</h3>
<p>由于React Native的非个人化特性，构建缓慢的应用程序非常容易。未优化的组件和内存泄漏经常被忽略，导致应用程序性能不佳。</p>
<p>此外，调试仍然是React原生生态系统中的一个难点。社区正在努力改进它，但这需要时间。</p>
<p>一个React的原生开发者经常要和原生代码交互，这有点困难。对于有网络背景的人来说，学习曲线可能有点困难。</p>
<p>虽然你可以构建任何复杂的动画或计算繁重的应用程序，但我们不能忽视使它具有高性能的努力。创建一个流畅的动画是一项具有挑战性的任务，需要专业知识。</p>
<p>许多本机功能依赖于设备，导致一些设备上的功能运行不正常。这使得调试和支持每一个设备变得困难，因为API在旧设备上经常被否决。</p>
<p>最后，React Native是变化最快的生态系统之一。您今天编写的许多代码很快就会过时，需要重构，要赶上并保持最新需要付出很多努力。</p>
<h2 id="ionic-vs-react-native">离子型与反应型</h2>
<p>我们已经讨论了Ionic和React Native的优缺点；现在，让我们根据下面的一些特性来比较一下这两者。</p>
<h3 id="ionic-platform-agnostic">Ionic是平台不可知的，而React Native只是用于React</h3>
<p>Ionic最大的优势是，它与React、Angular和Vue一起开发可以在移动和网络上使用的应用程序。相比之下，React Native主要是基于React的移动app开发库。</p>
<p>React Native通过React的优化渲染使用本地组件，并且只针对移动设备(使用<code>react-native-web</code>可以提供web支持，但是需要更加可靠)。这使得React Native对于使用React之外的框架的开发人员来说有点困难。</p>
<h3 id="hybrid-vs-native">混血儿与本地人</h3>
<p>Ionic应用被称为混合应用。我们在WebView包装器中使用HTML、CSS和JavaScript为web构建应用程序。Ionic的组件提供了足够的样式，在两个平台上都很好看。然而，它们仍然不是本地的Ionic应用程序导致网站/PWAs在浏览器中运行。</p>
<p>另一方面，React本机应用程序是真正的本机应用程序，因为该应用程序是使用本机组件构建的。它具有原生应用的感觉和性能，与使用Java/Kotlin或Swift构建的应用没有区别。</p>
<p>虽然Ionic应用对于大型用例来说已经足够好了，但它们无法与使用React Native构建的真正本机应用的性能相媲美。它缺乏本机应用程序所能提供的性能、感觉和可访问性优势。</p>
<p>虽然这两个框架都允许我们共享代码，但混合应用程序方法提供了web、Android和iOS之间几乎完全共享的代码。React Native的代码共享相对于我们想要支持的每个平台来说稍微少一些，并且经常需要有条件的改变。</p>
<h3 id="pwa">艾滋病患者</h3>
<p>Ionic的混合性质使其非常适合PWA。如今，默认情况下，每个Ionic应用程序都包含PWA支持。它帮助用户获得类似应用程序的感觉和一些离线好处。</p>
<p>React Native没有PWA支持，需要额外一步才能获得PWA的好处。离线支持很难添加到React本地应用中。</p>
<h3 id="native-apis">本机API</h3>
<p>React Native对大多数原生API提供一流的支持，而Ionic需要安装一个插件。我们已经在上面通过添加共享功能构建的应用程序中看到了这一点。</p>
<p>Ionic支持广泛的原生功能，我们可以通过电容插件快速挂钩，但数量仍然有限。React Native有一个庞大的第三方包社区，让我们可以挂钩任何功能，不管它们有多复杂。</p>
<p>比如React Native最近开始支持<code>react-native-skia</code>。Skia是Google Chrome和Chrome OS、Android、Flutter、Mozilla Firefox、Firefox OS以及许多其他产品的图形引擎。在Skia引擎的帮助下，现在可以在React Native中构建更复杂的动画甚至草图应用程序。</p>
<p>由于React Native真正的本机性质，它可以访问UI线程并毫不费力地绘制图形，而不会影响性能。像这样的支持在离子世界里是非常有限的。</p>

<p>Ionic和React Native的技术进步和学习资源都有所改善。随着时间推移，这导致两种框架的适应性增加。这意味着如今构建跨平台应用比三年前要容易得多。</p>
<p>React Native看到了开发社区对构建跨平台应用程序的持续兴趣。随之而来的是巨大的增长和许多大型科技公司的押注。你可以在下面的图表中看到更多关于JS状态调查的信息:</p>
<p><img data-attachment-id="160565" data-permalink="https://blog.logrocket.com/react-native-vs-ionic/attachment/state-js-survey/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2019/07/state-js-survey.png" data-orig-size="730,437" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="The state of JS survey" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2019/07/state-js-survey-300x180.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2019/07/state-js-survey.png" decoding="async" class="aligncenter size-full wp-image-160565 jetpack-lazy-image" src="../Images/d8a9bd23ea75798205777355e435b988.png" alt="The State Of JS Survey" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2019/07/state-js-survey.png 730w, https://blog.logrocket.com/wp-content/uploads/2019/07/state-js-survey-300x180.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2019/07/state-js-survey.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/07/state-js-survey.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="160565" data-permalink="https://blog.logrocket.com/react-native-vs-ionic/attachment/state-js-survey/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2019/07/state-js-survey.png" data-orig-size="730,437" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="The state of JS survey" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2019/07/state-js-survey-300x180.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2019/07/state-js-survey.png" decoding="async" loading="lazy" class="aligncenter size-full wp-image-160565" src="../Images/d8a9bd23ea75798205777355e435b988.png" alt="The State Of JS Survey" srcset="https://blog.logrocket.com/wp-content/uploads/2019/07/state-js-survey.png 730w, https://blog.logrocket.com/wp-content/uploads/2019/07/state-js-survey-300x180.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/07/state-js-survey.png"/></noscript>
<p>在同一类别中包含其他玩家，如Flutter和SwiftUI，使得构建真正的原生应用程序而不是行为类似于应用程序的东西变得容易得多。</p>
<p>这可能是社区对Ionic的兴趣在过去几年中略有下降的原因，尽管Ionic已经增加了改进和原生插件支持:</p>
<p><img data-attachment-id="160567" data-permalink="https://blog.logrocket.com/react-native-vs-ionic/attachment/ionic-state-js-survey/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2019/07/ionic-state-js-survey.png" data-orig-size="730,424" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Ionic in the state of JS survey" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2019/07/ionic-state-js-survey-300x174.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2019/07/ionic-state-js-survey.png" decoding="async" class="aligncenter size-full wp-image-160567 jetpack-lazy-image" src="../Images/0a95ade27fb1500bbbb1386d461061a8.png" alt="Ionic In The State Of JS Survey" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2019/07/ionic-state-js-survey.png 730w, https://blog.logrocket.com/wp-content/uploads/2019/07/ionic-state-js-survey-300x174.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2019/07/ionic-state-js-survey.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/07/ionic-state-js-survey.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="160567" data-permalink="https://blog.logrocket.com/react-native-vs-ionic/attachment/ionic-state-js-survey/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2019/07/ionic-state-js-survey.png" data-orig-size="730,424" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Ionic in the state of JS survey" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2019/07/ionic-state-js-survey-300x174.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2019/07/ionic-state-js-survey.png" decoding="async" loading="lazy" class="aligncenter size-full wp-image-160567" src="../Images/0a95ade27fb1500bbbb1386d461061a8.png" alt="Ionic In The State Of JS Survey" srcset="https://blog.logrocket.com/wp-content/uploads/2019/07/ionic-state-js-survey.png 730w, https://blog.logrocket.com/wp-content/uploads/2019/07/ionic-state-js-survey-300x174.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/07/ionic-state-js-survey.png"/></noscript>
<p>React Native在GitHub上有大约108k颗恒星，而Ionic有48.6k颗恒星。React Native的崛起要比Ionic快得多:</p>
<p><img data-attachment-id="160570" data-permalink="https://blog.logrocket.com/react-native-vs-ionic/attachment/github-stars-ionic-react-native/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2019/07/github-stars-ionic-react-native.png" data-orig-size="730,445" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="GitHub stars for Ionic and React Native over time" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2019/07/github-stars-ionic-react-native-300x183.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2019/07/github-stars-ionic-react-native.png" decoding="async" class="aligncenter size-full wp-image-160570 jetpack-lazy-image" src="../Images/230739f6fcd7d71e1c5d80baf70e0c51.png" alt="GitHub Stars For Ionic And React Native Over Time" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2019/07/github-stars-ionic-react-native.png 730w, https://blog.logrocket.com/wp-content/uploads/2019/07/github-stars-ionic-react-native-300x183.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2019/07/github-stars-ionic-react-native.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/07/github-stars-ionic-react-native.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="160570" data-permalink="https://blog.logrocket.com/react-native-vs-ionic/attachment/github-stars-ionic-react-native/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2019/07/github-stars-ionic-react-native.png" data-orig-size="730,445" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="GitHub stars for Ionic and React Native over time" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2019/07/github-stars-ionic-react-native-300x183.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2019/07/github-stars-ionic-react-native.png" decoding="async" loading="lazy" class="aligncenter size-full wp-image-160570" src="../Images/230739f6fcd7d71e1c5d80baf70e0c51.png" alt="GitHub Stars For Ionic And React Native Over Time" srcset="https://blog.logrocket.com/wp-content/uploads/2019/07/github-stars-ionic-react-native.png 730w, https://blog.logrocket.com/wp-content/uploads/2019/07/github-stars-ionic-react-native-300x183.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/07/github-stars-ionic-react-native.png"/></noscript>
<p>如果我们比较不同时间的排名，React Native(包括Expo)是第三大最受欢迎的应用构建方式。相比之下，爱奥尼亚排名第九:</p>
<p><img data-attachment-id="160572" data-permalink="https://blog.logrocket.com/react-native-vs-ionic/attachment/ranking-over-time/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2019/07/ranking-over-time.png" data-orig-size="730,752" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Ranking over time" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2019/07/ranking-over-time-291x300.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2019/07/ranking-over-time.png" decoding="async" class="aligncenter size-full wp-image-160572 jetpack-lazy-image" src="../Images/3e437a4d51924b9ab77e4f43a3caca56.png" alt="Ranking Over Time" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2019/07/ranking-over-time.png 730w, https://blog.logrocket.com/wp-content/uploads/2019/07/ranking-over-time-291x300.png 291w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2019/07/ranking-over-time.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/07/ranking-over-time.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="160572" data-permalink="https://blog.logrocket.com/react-native-vs-ionic/attachment/ranking-over-time/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2019/07/ranking-over-time.png" data-orig-size="730,752" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Ranking over time" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2019/07/ranking-over-time-291x300.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2019/07/ranking-over-time.png" decoding="async" loading="lazy" class="aligncenter size-full wp-image-160572" src="../Images/3e437a4d51924b9ab77e4f43a3caca56.png" alt="Ranking Over Time" srcset="https://blog.logrocket.com/wp-content/uploads/2019/07/ranking-over-time.png 730w, https://blog.logrocket.com/wp-content/uploads/2019/07/ranking-over-time-291x300.png 291w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/07/ranking-over-time.png"/></noscript>
<p>总的来说，无论我们是在谈论GitHub明星、第三方解决方案的数量，还是开发者社区的兴趣，React Native在社区方面都取得了成功。</p>
<blockquote><p>更多信息可在JS 2022 页面的<a href="https://2022.stateofjs.com/en-US/libraries/mobile-desktop/">状态中找到。</a></p></blockquote>
<h3 id="debugging">排除故障</h3>
<p>Ionic和React本机支持调试工具以及良好的旧控制台日志。我们可以在Chrome或Safari中使用web inspector来调试Ionic应用程序，而React Native则有Flipper这样的工具。</p>
<p>React Native允许您更深入地分析应用程序，并审核性能和其他指标。相比之下，Ionic应用程序必须手动依赖浏览器来检查不同的改进领域。Ionic中缺少这样的工具使得React Native成为这一类别中的赢家，尽管这两个框架都需要更好的调试支持。</p>
<h3 id="app-size">应用程序大小</h3>
<p>因为Ionic在WebView包装器中提供了一个web应用程序，所以它的应用程序相对较小。相比之下，React Native将所有编译后的代码捆绑在一起，并将其发送给最终用户，从而导致应用程序变得更大。</p>
<p>在这两种情况下，应用程序的大小仍然很小(大约16 MB)，任何用户都可以轻松下载。这使得两个框架都适合应用程序开发，而不管它们的大小差异。</p>
<h3 id="updates">更新</h3>
<p>Ionic应用得益于即时更新，因为它采用了网络优先的方式。一旦您更新了代码，更改就会立即反映出来。如果您需要对原生插件进行任何更改，您只需重新构建应用并提交到商店。</p>
<p>默认情况下，React Native要求您在每次需要更改某些内容时进行构建。但是有了CodePush，我们可以通过OTA(空中下载)向用户推送更新，而无需他们安装新版本。这需要额外的工作来设置，并且管理起来比更新web代码更昂贵。此外，只要原生依赖关系没有变化，CodePush更新就以应用程序为目标，管理应用程序的版本以实现更新有点棘手。</p>
<h2 id="conclusion">结论</h2>
<p>选择正确的框架总是取决于您正在构建的应用程序的需求和您目前拥有的技能。</p>
<p>PWA，移动和web之间的代码共享，以及原生插件支持，使Ionic成为各种应用程序的绝佳选择。你可以更好地构建一个像新闻订阅或电子商务网站这样的应用程序。许多像麦当劳和JustWatch这样的大公司都使用Ionic，并开发出了很棒的应用程序。只有当你的应用程序计算量很大时，Ionic才会开始挣扎。</p>
<p>如果你的用例有流畅的应用动画，比如访问相机模块，渲染大规模数据集的图表等，React Native会好得多。React Native对原生组件的访问给人一种真正的原生感觉，这对于一些公司来说是必不可少的。除了性能，丰富的第三方库使得在React Native中构建复杂的功能变得容易。</p>
<p>平台收益呢？如果你有精通Angular和Vue的开发人员，那么选择Ionic将大大减少开发时间。Ionic对Vue、React和Angular的适应性使其易于接近，并且几乎没有学习曲线。</p>
<p>开发人员使用React Native并不总是轻而易举的事情，尤其是如果他们不熟悉React的话。因此，人才库在选择技术组合时起着至关重要的作用，而这一点经常被忽视。</p>
<p>对于Ionic和React Native，React开发人员的学习曲线是相似的。因此，如果你有一个React开发团队，这取决于你对应用的期望。</p><div class="code-block code-block-18">
<div class="blog-plug inline-plug react-native-plug"><h2><a href="https://lp.logrocket.com/blg/react-native-signup"> LogRocket </a>:即时重现React原生应用中的问题。</h2><a class="signup" href="https://lp.logrocket.com/blg/react-native-signup" target="_blank" rel="noopener noreferrer"><img class="alignnone size-full wp-image-46 jetpack-lazy-image" src="../Images/110055665562c1e02069b3698e6cc671.png" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2021/10/react-native-plug_v2-2.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2021/10/react-native-plug_v2-2.png"/><noscript><img data-lazy-fallback="1" class="alignnone size-full wp-image-46" src="../Images/110055665562c1e02069b3698e6cc671.png" data-original-src="https://blog.logrocket.com/wp-content/uploads/2021/10/react-native-plug_v2-2.png"/></noscript></a><p><a href="https://lp.logrocket.com/blg/react-native-signup" target="_blank" rel="noopener noreferrer"> LogRocket </a>是一款React原生监控解决方案，可帮助您即时重现问题、确定bug的优先级并了解React原生应用的性能。</p><p>LogRocket还可以向你展示用户是如何与你的应用程序互动的，从而帮助你提高转化率和产品使用率。LogRocket的产品分析功能揭示了用户不完成特定流程或不采用新功能的原因。</p><p>开始主动监控您的React原生应用— <a class="signup" href="https://lp.logrocket.com/blg/react-native-signup" target="_blank" rel="noopener noreferrer">免费试用LogRocket】。</a></p></div>
</div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
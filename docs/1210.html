<html>
<head>
<title>Transpiling PHP code from 8.0 to 7.x via Rector - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>通过Rector - LogRocket博客将PHP代码从8.0移植到7.x</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/transpiling-php-code-from-8-0-to-7-x-via-rector/#0001-01-01">https://blog.logrocket.com/transpiling-php-code-from-8-0-to-7-x-via-rector/#0001-01-01</a></blockquote><div><article class="article-post">
<p>PHP 8.0将于今年年底发布。是否有可能立即将其引入我们的项目？或者，我们会不会因为它使用了带有遗留代码的框架或CMS而无法做到这一点？</p>
<p>这种担忧影响到每一个基于PHP的项目——无论是基于Laravel、Symfony、Drupal、vanilla PHP还是其他——但对于WordPress来说尤其紧迫，其社区目前正在试图寻找解决方案。</p>
<p>在今年12月即将发布的新版本中，WordPress应该将其最低要求的PHP版本从5.6升级到7.1。然而，已经决定暂时取消PHP版本升级，因为几乎24%的安装仍然运行在PHP 5.6或7.0上:</p>
<figure id="attachment_26447" aria-describedby="caption-attachment-26447" class="wp-caption aligncenter"><img data-attachment-id="26447" data-permalink="https://blog.logrocket.com/transpiling-php-code-from-8-0-to-7-x-via-rector/wp-php-version-stats/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/10/wp-php-version-stats.png" data-orig-size="730,591" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="WordPress PHP version stats" data-image-description="" data-image-caption="&lt;p&gt;September 2020 WordPress usage stats, via wordpress.org/about/stats.&lt;/p&gt;&#10;" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/10/wp-php-version-stats-300x243.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/10/wp-php-version-stats.png" decoding="async" class="size-full wp-image-26447 jetpack-lazy-image" src="../Images/421c537a699545a1ccf4e2e5c0e16cf7.png" alt="WordPress PHP Version Stats" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2020/10/wp-php-version-stats.png 730w, https://blog.logrocket.com/wp-content/uploads/2020/10/wp-php-version-stats-300x243.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2020/10/wp-php-version-stats.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/10/wp-php-version-stats.png"/><noscript><img data-lazy-fallback="1" data-attachment-id="26447" data-permalink="https://blog.logrocket.com/transpiling-php-code-from-8-0-to-7-x-via-rector/wp-php-version-stats/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/10/wp-php-version-stats.png" data-orig-size="730,591" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="WordPress PHP version stats" data-image-description="" data-image-caption="&lt;p&gt;September 2020 WordPress usage stats, via wordpress.org/about/stats.&lt;/p&gt;&#10;" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/10/wp-php-version-stats-300x243.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/10/wp-php-version-stats.png" decoding="async" loading="lazy" class="size-full wp-image-26447" src="../Images/421c537a699545a1ccf4e2e5c0e16cf7.png" alt="WordPress PHP Version Stats" srcset="https://blog.logrocket.com/wp-content/uploads/2020/10/wp-php-version-stats.png 730w, https://blog.logrocket.com/wp-content/uploads/2020/10/wp-php-version-stats-300x243.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/10/wp-php-version-stats.png"/></noscript><figcaption id="caption-attachment-26447" class="wp-caption-text">September 2020 WordPress usage stats, via wordpress.org/about/stats.</figcaption></figure>
<p>在这种情况下，有人提议开始为最低版本的升级制定一个固定的时间表，在升级到新的PHP版本和为旧版本提供安全补丁之间提供一个折衷方案:</p>
<figure id="attachment_26448" aria-describedby="caption-attachment-26448" class="wp-caption aligncenter"><img data-attachment-id="26448" data-permalink="https://blog.logrocket.com/transpiling-php-code-from-8-0-to-7-x-via-rector/wp-fixed-update-schedule/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/10/wp-fixed-update-schedule.png" data-orig-size="730,411" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="WordPress fixed update schedule" data-image-description="" data-image-caption="&lt;p&gt;Proposed fixed updated schedule.&lt;/p&gt;&#10;" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/10/wp-fixed-update-schedule-300x169.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/10/wp-fixed-update-schedule.png" decoding="async" class="size-full wp-image-26448 jetpack-lazy-image" src="../Images/96f836e3ee3c91454eaa06f84a183459.png" alt="WordPress Fixed Update Schedule" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2020/10/wp-fixed-update-schedule.png 730w, https://blog.logrocket.com/wp-content/uploads/2020/10/wp-fixed-update-schedule-300x169.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2020/10/wp-fixed-update-schedule.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/10/wp-fixed-update-schedule.png"/><noscript><img data-lazy-fallback="1" data-attachment-id="26448" data-permalink="https://blog.logrocket.com/transpiling-php-code-from-8-0-to-7-x-via-rector/wp-fixed-update-schedule/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/10/wp-fixed-update-schedule.png" data-orig-size="730,411" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="WordPress fixed update schedule" data-image-description="" data-image-caption="&lt;p&gt;Proposed fixed updated schedule.&lt;/p&gt;&#10;" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/10/wp-fixed-update-schedule-300x169.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/10/wp-fixed-update-schedule.png" decoding="async" loading="lazy" class="size-full wp-image-26448" src="../Images/96f836e3ee3c91454eaa06f84a183459.png" alt="WordPress Fixed Update Schedule" srcset="https://blog.logrocket.com/wp-content/uploads/2020/10/wp-fixed-update-schedule.png 730w, https://blog.logrocket.com/wp-content/uploads/2020/10/wp-fixed-update-schedule-300x169.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/10/wp-fixed-update-schedule.png"/></noscript><figcaption id="caption-attachment-26448" class="wp-caption-text">Proposed fixed updated schedule.</figcaption></figure>
<p>不管这个固定的时间表是否被批准，对于想要使用PHP最新改进的开发者来说，情况看起来很糟糕。主题和插件不受WordPress PHP要求的限制，所以它们可能已经要求7.1或更高版本。然而，这样做限制了他们的潜在影响力。</p>
<p>例如，目前只有10.7%的安装运行在PHP 7.4上，我们可以预计在PHP 8.0发布后会立即运行的会更少。这些数字使得在代码库中引入<a href="https://php.watch/versions/7.4/typed-properties">类型属性</a>或<a href="https://php.watch/versions/8.0/union-types">联合类型</a>以及其他有价值的特性变得非常困难。</p>
<p>一位开发人员的评论传达了某种绝望感:</p>
<blockquote><p>因此，这实际上意味着，如果我们想在2023年12月之前支持所有WordPress版本，在它发布三年后，我们不能在主题/插件中使用PHP 8语法。这非常令人失望。</p></blockquote>
<p>有什么办法可以改善今天的情况吗？或者我们需要等三年才能在WordPress主题和插件中使用PHP 8代码？(届时它将<a href="https://www.php.net/supported-versions.php">达到其寿命终点</a>！)</p>
<h2>巴别塔指明了方向</h2>
<p><a href="https://en.wikipedia.org/wiki/Source-to-source_compiler"> transpiler </a>是“一种翻译器，它以用编程语言编写的程序的源代码作为输入，并以相同或不同的编程语言产生等价的源代码。”</p>
<p>transpiling的一个典型模型是<a href="https://babeljs.io/"> Babel </a>，这是一个工具链，允许我们将ECMAScript 2015+代码转换为JavaScript的向后兼容版本。多亏了Babel，开发人员可以使用新的JavaScript语言特性将他们的源代码转换成可以在旧浏览器上执行的JavaScript版本。</p>
<p>例如，Babel将ES2015箭头函数转换为其等效的ES5函数:</p>
<pre>// Babel Input: ES2015 arrow function
[1, 2, 3].map((n) =&gt; n + 1);

// Babel Output: ES5 equivalent
[1, 2, 3].map(function(n) {
  return n + 1;
});</pre>
<p>继ES2015之后，PHP 7.4也引入了<a href="https://www.php.net/manual/en/functions.arrow.php">箭头函数</a>作为匿名函数的语法糖，这从PHP 5.3开始就得到支持:</p>
<pre class="language-php">// PHP 7.4: arrow function
$nums = array_map(fn($n) =&gt; $n + 1, [1, 2, 3]);

// PHP 5.3: anonymous function
$nums = array_map(
  function ($n) {
    return $n + 1;
  },
  [1, 2, 3]
);</pre>
<p>有了PHP的transpiling工具，我们可以编写PHP 7.4的arrow函数，并将它们转换成等价的匿名函数，这些函数可以运行在从5.3开始的任何版本的PHP上。</p>
<p>这将使开发者能够将PHP 7.4的特性用于他们的WordPress主题和插件，同时仍然允许运行旧版本(如PHP 7.1)的用户安装他们的软件。</p>
<h2>升级开发工具链</h2>
<p>transpiling的另一个好处是可以访问用于开发的较新版本的库。</p>
<p>测试框架<a href="https://phpunit.de/"> PHPUnit </a>就是如此。就目前的PHP 5.6而言，WordPress无法超越PHPUnit的7.x版本，结果是<a href="https://core.trac.wordpress.org/ticket/46149">测试套件无法针对PHP 8 </a>进行测试。</p>
<p>用PHP 7.3+(或PHP 7.1+)编码，然后将代码转换成产品，将使我们能够升级到PHPUnit的9.x(或8.x)版本，并使测试套件现代化。</p>
<h2>评估新功能是否可以传输</h2>
<p>新PHP版本中引入的特性可以大致分为以下几类:</p>
<ul>
<li>新语法作为一些现有功能的语法糖</li>
<li>全新特性的新语法</li>
<li>新函数、类、接口、常数和异常的实现</li>
</ul>
<p>上面演示的PHP 7.4中引入的arrow函数是一个现有特性的新语法的例子。从新版本到旧版本的语法转换将执行相同的功能；因此，这些特性可以被编译，结果代码将没有缺点。</p>
<p>我们来分析一下其他案例。</p>
<h3>为开发提供新功能</h3>
<p>类型化属性(在PHP 7.4中引入)和联合类型(在PHP 8.0中引入)为全新的特性引入了新的语法:</p>
<pre class="language-php">class User
{
  // Typed properties
  private int $id;
  private string $name;
  private bool $isAdmin;

  // Union types (in params and return declaration)
  public function getID(string|int $domain): string|int
  {
    if ($this-&gt;isAdmin) {
      return $domain . $this-&gt;name;
    }
    return $domain . $this-&gt;id;
  }
}</pre>
<p>这些特性不能在以前的PHP版本中直接复制。在transpiled代码中，我们最接近它们的方式是完全删除它们，并使用docblock标签来描述它们的性质:</p>
<pre class="language-php">class User
{
  /** @var int */
  private $id;
  /** @var string */
  private $name;
  /** @var bool */
  private $isAdmin;

  /**
   * @param string|int $domain
   * @return string|int
   */
  public function getID($domain)
  {
    if ($this-&gt;isAdmin) {
      return $domain . $this-&gt;name;
    }
    return $domain . $this-&gt;id;
  }
}</pre>
<p>对于包含这两个特性的代码，其transpiled代码将在PHP 7.3及以下版本中编译，但新特性将会消失。</p>
<p>然而，更有可能的是，它们的缺失并不重要:这些特性在开发过程中主要用于验证我们代码的正确性(借助于额外的工具，比如用于测试的PHPUnit和用于静态分析的<a href="https://phpstan.org/"> PHPStan </a>)。如果我们的代码有错误，并且在生产中失败，那么不管有没有这些新特性，它都会失败；最多，错误消息会有所不同。</p>
<p>因此，代码的不完美转换仍然足以满足我们的需求，并且该代码可以被编译用于生产。</p>
<h3 id="avoiding-features-needed-on-runtime">避免运行时需要的特性</h3>
<p>在以前的版本中没有对等的新特性，并且在运行时(在生产中)需要的新特性不能被删除，否则应用程序将会有不同的行为。</p>
<p>PHP 7.4中引入的<code><a href="https://www.php.net/manual/en/class.weakreference.php">WeakReference</a></code>类就是一个例子，它支持销毁一个我们仍然持有引用的对象:</p>
<pre class="language-php">$obj = new stdClass;
$weakref = WeakReference::create($obj);
var_dump($weakref-&gt;get());
unset($obj);
var_dump($weakref-&gt;get());</pre>
<p>这将打印:</p>
<pre class="language-php">object(stdClass)#1 (0) {
}
NULL</pre>
<p>使用PHP 7.3，除非删除对对象的所有引用，否则对象不会被销毁:</p>
<pre class="language-php">$obj = new stdClass;
$array = [$obj];
var_dump($array);
unset($obj);
var_dump($array);</pre>
<p>这将打印:</p>
<pre class="language-php">array(1) {
  [0]=&gt;
  object(stdClass)#412 (0) {
  }
}
array(1) {
  [0]=&gt;
  object(stdClass)#412 (0) {
  }
}</pre>
<p>因此，我们需要找出新的行为是否可以接受。例如，运行transpiled <code>WeakReference</code>类的应用程序可能会消耗更多的内存，这可能是可以接受的，但是如果我们的逻辑需要在取消设置后断言一个对象是<code>null</code>，那么它将失败。</p>
<h3 id="backporting-functionalities">反向移植功能</h3>
<p>最后，还有新实现的功能:函数、类、接口、常数和异常。</p>
<p>没有必要转运它们；一个简单得多的解决方案是对它们进行反向移植，也就是说，为较低的PHP版本提供相同的实现。</p>
<p>例如，PHP 8.0中引入的函数<code>str_contains</code>可以这样实现:</p>
<pre class="language-php">if (!defined('PHP_VERSION_ID') || (defined('PHP_VERSION_ID') &amp;&amp; PHP_VERSION_ID &lt; 80000)) {
  if (!function_exists('str_contains')) {
    /**
     * Checks if a string contains another
     *
     * @param string $haystack The string to search in
     * @param string $needle The string to search
     * @return boolean Returns TRUE if the needle was found in haystack, FALSE otherwise.
     */
    function str_contains(string $haystack, string $needle): bool
    {
      return strpos($haystack, $needle) !== false;
    }
  }
}</pre>
<p>方便的是，我们甚至不需要实现反向移植代码，因为Symfony已经提供了这些polyfill库:</p>

<h2>通过Rector传输PHP代码</h2>
<p>是时候从理论转向实践，开始编译我们的PHP代码了。</p>
<p><a href="https://github.com/rectorphp/rector/"> Rector </a>是一个重构工具，可以对代码进行即时升级和重构。它基于流行的<a href="https://github.com/nikic/PHP-Parser"> PHP解析器</a>库。</p>
<p>Rector执行以下操作序列:</p>
<ol>
<li>将PHP代码解析成AST(<a href="https://en.wikipedia.org/wiki/Abstract_syntax_tree">抽象语法树</a>的缩写),这使得能够操纵其结构和内容</li>
<li>应用规则在AST的选定节点上执行转换</li>
<li>将新的AST转储回文件，从而存储转换后的PHP代码</li>
</ol>
<p>按照这个顺序，我们将只关注第二步:为Rector提供转换规则。</p>
<h3>描述规则</h3>
<p>规则的目标是将节点从AST从<code>A</code>转换到<code>B</code>。为了描述这个操作，我们使用应用于最终结果的diff格式:删除(属于状态<code>A</code>)显示为红色，添加(属于状态<code>B</code>)显示为绿色。</p>
<p>例如，这是规则<a href="https://github.com/rectorphp/rector/blob/master/docs/rector_rules_overview.md#downgradenullcoalescingoperatorrector">降级空合并操作符</a>的差异，它取代了PHP 7.4中引入的<code>??=</code>操作符:</p>
<pre class="diff hljs">function run(array $options)
{
<span class="hljs-deletion">-  $options['limit'] ??= 10;</span>
<span class="hljs-addition">+  $options['limit'] = $array['limit'] ?? 10;</span>

  // do something
  // ...
}</pre>
<h3>浏览目录规则列表</h3>
<p>Rector拥有<a href="https://github.com/rectorphp/rector/blob/master/docs/rector_rules_overview.md">近600条</a> <a href="https://github.com/rectorphp/rector/blob/master/docs/rector_rules_overview.md">目前可用的</a> <a href="https://github.com/rectorphp/rector/blob/master/docs/rector_rules_overview.md">规则</a>可供应用。然而，他们中的大多数是为了现代化代码(例如，从PHP 7.1到PHP 7.4)，这与我们的目标相反。</p>
<p>我们可以使用的规则是“降级”集合下的规则:</p>

<p>这些集合中的每一个规则都将代码从提到的版本转换成之前版本的等价代码。然后，<code>DowngradePhp80</code>下的一切将代码从PHP 8.0转换到7.4。</p>
<p>将它们加起来，目前有16条这样的规则，这在某种程度上使我们能够将代码从PHP 8.0向下转换到PHP 7.0。</p>
<p>我们需要解锁PHP 8.0和PHP 7.0之间所有新特性的剩余转换已经被记录了。欢迎每个人对开源项目做出贡献，并执行这些规则中的任何一条。</p>
<h3>运行控制器</h3>
<p>在<a href="https://github.com/rectorphp/rector#install">安装了Rector </a>之后，我们必须创建文件<code>rector.php</code>(默认情况下在项目的根目录下)来定义要执行的规则集，我们<a href="https://github.com/rectorphp/rector#running-rector">通过在命令行中执行以下命令来运行它</a>:</p>
<pre>vendor/bin/rector process src</pre>
<p>请注意，源代码——在本例中，位于<code>src/</code>下——将被转换覆盖，因此降级代码必须与持续集成相集成，以产生新的资产(例如，在部署期间)。</p>
<p>要预览转换而不应用它们，运行带有<code>--dry-run</code>的命令:</p>
<pre>vendor/bin/rector process src --dry-run</pre>
<p>我们来看看如何配置<code>rector.php</code>。要将代码从PHP 7.4降级到7.1，我们必须执行集合<code>downgrade-php74</code>和<code>downgrade-php72</code>(目前没有为PHP 7.3实现的集合):</p>
<pre class="language-php">&lt;?php

declare(strict_types=1);

use Rector\Core\Configuration\Option;
use Symfony\Component\DependencyInjection\Loader\Configurator\ContainerConfigurator;
use Rector\Set\ValueObject\SetList;

return static function (ContainerConfigurator $containerConfigurator): void {
  // get parameters
  $parameters = $containerConfigurator-&gt;parameters();

  // paths to refactor; solid alternative to CLI arguments
  $parameters-&gt;set(Option::PATHS, [
    __DIR__ . '/src',
  ]);

  // here we can define, what sets of rules will be applied
  $parameters-&gt;set(Option::SETS, [
    SetList::DOWNGRADE_PHP74,
    SetList::DOWNGRADE_PHP72,
  ]);

  // is your PHP version different from the one your refactor to? [default: your PHP version]
  $parameters-&gt;set(Option::PHP_VERSION_FEATURES, '7.1');
};</pre>
<p>用<code>--dry-run</code>运行命令以diff格式显示结果(删除用红色，添加用绿色):</p>
<figure id="attachment_26450" aria-describedby="caption-attachment-26450" class="wp-caption aligncenter"><img data-attachment-id="26450" data-permalink="https://blog.logrocket.com/transpiling-php-code-from-8-0-to-7-x-via-rector/running-rector/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/10/running-rector.gif" data-orig-size="688,553" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Running Rector" data-image-description="" data-image-caption="&lt;p&gt;Running Rector with –dry-run.&lt;/p&gt;&#10;" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/10/running-rector-300x241.gif" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/10/running-rector.gif" decoding="async" class="size-full wp-image-26450 jetpack-lazy-image" src="../Images/3e054f42636477d857fe072c56c92930.png" alt="Running Rector with --dry-run" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2020/10/running-rector.gif?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/10/running-rector.gif"/><noscript><img data-lazy-fallback="1" data-attachment-id="26450" data-permalink="https://blog.logrocket.com/transpiling-php-code-from-8-0-to-7-x-via-rector/running-rector/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/10/running-rector.gif" data-orig-size="688,553" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Running Rector" data-image-description="" data-image-caption="&lt;p&gt;Running Rector with –dry-run.&lt;/p&gt;&#10;" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/10/running-rector-300x241.gif" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/10/running-rector.gif" decoding="async" loading="lazy" class="size-full wp-image-26450" src="../Images/3e054f42636477d857fe072c56c92930.png" alt="Running Rector with --dry-run" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/10/running-rector.gif"/></noscript><figcaption id="caption-attachment-26450" class="wp-caption-text">Running Rector with –dry-run.</figcaption></figure>
<p>最终结果是使用PHP 7.4的特性编写的代码，但是被转换成可以部署到PHP 7.1的代码。</p>
<h2>结论</h2>
<p>我们如何在开发人员访问最新工具和语言特性的愿望和通过制作可以在尽可能多的环境中安装的软件来提高他们的代码质量的需求之间做出妥协？</p>
<p>运输是一种解决方案。这不是一个新的概念:如果我们制作网站，我们很可能已经在使用Babel来传输JavaScript代码，即使我们没有意识到这一点，因为它可能被集成到某个框架中。</p>
<p>我们可能没有意识到的是，有一个名为Rector的工具可以转换PHP代码。有了这个工具，我们可以编写包含PHP 8.0特性的代码，并将其部署到运行较低版本PHP的环境中，一直到PHP 7.0。太棒了。</p>
<p>祝运输愉快！</p><div class="code-block code-block-2">
<div class="blog-plug base-cta"><h2>使用<a class="signup" href="https://lp.logrocket.com/blg/signup" target="_blank" rel="noopener noreferrer"> LogRocket </a>消除传统错误报告的干扰</h2>
<a href="https://lp.logrocket.com/blg/signup" class="signup" target="_blank" rel="noopener noreferrer"><img class="alignnone size-full wp-image-46 jetpack-lazy-image" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/><noscript><img data-lazy-fallback="1" class="alignnone size-full wp-image-46" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/></noscript></a>
<p><a href="https://lp.logrocket.com/blg/signup" target="_blank" rel="noopener noreferrer"> LogRocket </a>是一个数字体验分析解决方案，它可以保护您免受数百个假阳性错误警报的影响，只针对几个真正重要的项目。LogRocket会告诉您应用程序中实际影响用户的最具影响力的bug和UX问题。</p>
<p>然后，使用具有深层技术遥测的会话重放来确切地查看用户看到了什么以及是什么导致了问题，就像你在他们身后看一样。</p>
<p>LogRocket自动聚合客户端错误、JS异常、前端性能指标和用户交互。然后LogRocket使用机器学习来告诉你哪些问题正在影响大多数用户，并提供你需要修复它的上下文。</p>
<p>关注重要的bug—<a class="signup" href="https://lp.logrocket.com/blg/signup-issue-free" target="_blank" rel="noopener noreferrer">今天就试试LogRocket】。</a></p></div></div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
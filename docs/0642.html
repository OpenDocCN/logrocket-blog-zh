<html>
<head>
<title>Integrating web workers in a React app with Comlink - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>用Comlink - LogRocket Blog在React应用程序中集成网络工作者</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/integrating-web-workers-in-a-react-app-with-comlink/#0001-01-01">https://blog.logrocket.com/integrating-web-workers-in-a-react-app-with-comlink/#0001-01-01</a></blockquote><div><article class="article-post">
<p>JavaScript是出了名的单线程。然而，如果你正在为web开发，你可能很清楚这是不太准确的。还有<a href="https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Using_web_workers">网络工作者</a>:</p>
<blockquote><p>工作者是使用运行命名的JavaScript文件的构造器(例如，<code>Worker()</code>)创建的对象——该文件包含将在工作者线程中运行的代码；工作线程在不同于当前窗口的另一个全局上下文中运行。</p></blockquote>
<p>既然有办法使用其他线程进行后台处理，为什么不是一直都这样呢？嗯，有很多原因，不仅仅是与网络工作者互动的礼仪。请考虑下面的示例，该示例说明了如何将计算移入worker:</p>
<pre>// main.js
function add2NumbersUsingWebWorker() {
    const myWorker = new Worker("worker.js");

    myWorker.postMessage([42, 7]);
    console.log('Message posted to worker');

    myWorker.onmessage = function(e) {
        console.log('Message received from worker', e.data);
    }
}

add2NumbersUsingWebWorker();

// worker.js
onmessage = function(e) {
  console.log('Worker: Message received from main script');
  const result = e.data[0] * e.data[1];
  if (isNaN(result)) {
    postMessage('Please write two numbers');
  } else {
    const workerResult = 'Result: ' + result;
    console.log('Worker: Posting message back to main script');
    postMessage(workerResult);
  }
}</pre>
<p>这不简单；很难理解正在发生的事情。此外，这种方法只支持单个方法调用。我更愿意写一些看起来更像这样的东西:</p>
<pre>// main.js
function add2NumbersUsingWebWorker() {
    const myWorker = new Worker("worker.js");

    const total = myWorker.add2Numbers([42, 7]);
    console.log('Message received from worker', total);
}

add2NumbersUsingWebWorker();

// worker.js
export function add2Numbers(firstNumber, secondNumber) {
  const result = firstNumber + secondNumber;
  return (isNaN(result))
    ? 'Please write two numbers'
    : 'Result: ' + result;
}</pre>
<p>有一种方法可以做到这一点，使用谷歌制作的名为<a href="https://github.com/GoogleChromeLabs/comlink"> Comlink </a>的库。这篇文章将展示我们如何使用它。我们将使用TypeScript和webpack。我们还将研究如何将这种方法集成到React应用程序中。</p>
<h2>一个网络工作者的用例</h2>
<p>让我们为自己制作一个TypeScript web应用程序。为此，我们将使用<code>create-react-app</code>:</p>
<pre>npx create-react-app webworkers-comlink-typescript-react --template typescript</pre>
<p>在<code>index.tsx</code>旁边创建一个<code>takeALongTimeToDoSomething.ts</code>文件:</p>
<pre>export function takeALongTimeToDoSomething() {
    console.log('Start our long running job...');
    const seconds = 5;
    const start = new Date().getTime();
    const delay = seconds * 1000;

    while (true) {
        if ((new Date().getTime() - start) &gt; delay) {
            break;
        }
    }
    console.log('Finished our long running job');
}</pre>
<p>向<code>index.tsx</code>添加以下代码:</p>
<pre>import { takeALongTimeToDoSomething } from './takeALongTimeToDoSomething';

// ...

console.log('Do something');
takeALongTimeToDoSomething();
console.log('Do another thing');</pre>
<p>当我们的应用程序运行时，我们会看到这种行为:</p>
<p><img data-attachment-id="13078" data-permalink="https://blog.logrocket.com/integrating-web-workers-in-a-react-app-with-comlink/blocking-process/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/01/blocking-process.gif" data-orig-size="730,279" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Blocked UI" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/01/blocking-process-300x115.gif" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/01/blocking-process.gif" decoding="async" class="aligncenter wp-image-13078 size-full jetpack-lazy-image" src="../Images/7b80e1c784aa18c58206b2624ca86a53.png" alt="Blocked UI" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2020/01/blocking-process.gif?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/01/blocking-process.gif"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="13078" data-permalink="https://blog.logrocket.com/integrating-web-workers-in-a-react-app-with-comlink/blocking-process/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/01/blocking-process.gif" data-orig-size="730,279" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Blocked UI" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/01/blocking-process-300x115.gif" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/01/blocking-process.gif" decoding="async" loading="lazy" class="aligncenter wp-image-13078 size-full" src="../Images/7b80e1c784aa18c58206b2624ca86a53.png" alt="Blocked UI" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/01/blocking-process.gif"/></noscript>
<p>应用程序启动并将<code>Do something</code>和<code>Start our long running job...</code>记录到控制台。然后它阻塞用户界面，直到<code>takeALongTimeToDoSomething</code>函数完成运行。在此期间，屏幕是空的，没有反应。这是很差的用户体验。</p>
<h2>你好<code>worker-plugin</code>和<code>comlink</code></h2>
<p>要开始使用Comlink，我们需要弹出我们的<code>create-react-app</code>应用程序。<code>create-react-app</code>的工作方式是通过给你一个设置来处理一个典型的web应用程序的大部分需求。当您遇到不支持的用例时，您可以运行<code>yarn eject</code>命令来直接访问您的设置的配置。</p>
<p>Web workers目前在日常开发中并不常用。因此，对于受<code>create-react-app</code>支持的员工来说，还没有一个“即插即用”的解决方案。有许多潜在的方法来支持这个用例，您可以跟踪针对涵盖这个用例的<code>create-react-app</code>发生的各种讨论。现在，让我们弹出:</p>
<pre>yarn eject</pre>
<p>然后，让我们安装将要使用的软件包:</p>
<ul>
<li>这个webpack插件自动编译web workers中加载的模块</li>
<li>这个库提供了我们希望从工作人员那里得到的类似RPC的体验</li>
</ul>
<pre>yarn add comlink worker-plugin</pre>
<p>我们现在需要调整我们的<code>webpack.config.js</code>来使用<code>worker-plugin</code>:</p>
<pre>const WorkerPlugin = require('worker-plugin');

// ....

    plugins: [
      new WorkerPlugin(),

// ....</pre>
<p>请注意在<code>webpack.config.js</code>中有许多<code>plugins</code>语句。你要顶级的那个；留意<code>new HtmlWebpackPlugin</code>陈述，并将你的<code>new WorkerPlugin(),</code>放在那之前。</p>
<h2>使我们缓慢的过程工作化</h2>
<p>现在，我们准备将我们的长时间运行的流程转移到一个worker中。在<code>src</code>文件夹中，创建一个名为<code>my-first-worker</code>的新文件夹。我们的工人将住在这里。在这个文件夹中，我们将添加一个<code>tsconfig.json</code>文件:</p>
<pre>{
  "compilerOptions": {
    "strict": true,
    "target": "esnext",
    "module": "esnext",
    "lib": [
      "webworker",
      "esnext"
    ],
    "moduleResolution": "node",
    "noUnusedLocals": true,
    "sourceMap": true,
    "allowJs": false,
    "baseUrl": "."
  }
}</pre>
<p>该文件的存在是为了告诉TypeScript这是一个web worker。请注意<code>"lib": [ "webworker"</code>的用法，它就是这样做的。</p>
<p>除了<code>tsconfig.json</code>文件，让我们创建一个<code>index.ts</code>文件。这将是我们的工人:</p>
<pre>import { expose } from 'comlink';
import { takeALongTimeToDoSomething } from '../takeALongTimeToDoSomething';

const exports = {
    takeALongTimeToDoSomething
};
export type MyFirstWorker = typeof exports;

expose(exports);</pre>
<p>我们的小工档案里发生了很多事。让我们一条一条地看这个声明:</p>
<pre>import { expose } from 'comlink';</pre>
<p>这里我们从Comlink导入了<code>expose</code>方法。Comlink的目标是使一个线程中公开的值在另一个线程中可用。<code>expose</code>方法可以被看作是<code>export</code>的Comlink等价物。它用于导出我们的worker的RPC样式签名。我们稍后会看到它的用途。</p>
<pre>import { takeALongTimeToDoSomething } from '../takeALongTimeToDoSomething';</pre>
<p>这里我们将导入我们之前编写的<code>takeALongTimeToDoSomething</code>函数，这样我们就可以在我们的worker中使用它。</p>
<pre>const exports = {
    takeALongTimeToDoSomething
};</pre>
<p>在这里，我们正在创建面向公众的API，我们将公开它。</p>
<pre>export type MyFirstWorker = typeof exports;</pre>
<p>我们希望我们的工人是强类型的。这一行创建了一个名为<code>MyFirstWorker</code>的类型，它是从我们的<code>exports</code>对象文本中派生出来的。</p>
<pre>expose(exports);</pre>
<p>最后，我们使用Comlink公开了<code>exports</code>。我们完了——我们的工人完了。现在让我们消费它。让我们更改我们的<code>index.tsx</code>文件来使用它。替换我们进口的<code>takeALongTimeToDoSomething</code>:</p>
<pre>import { takeALongTimeToDoSomething } from './takeALongTimeToDoSomething';</pre>
<p>通过从Comlink导入<code>wrap</code>,创建了一个本地<code>takeALongTimeToDoSomething</code>函数，该函数包装了与我们的工人的交互:</p>
<pre>import { wrap } from 'comlink';

function takeALongTimeToDoSomething() {
    const worker = new Worker('./my-first-worker', { name: 'my-first-worker', type: 'module' });
    const workerApi = wrap&lt;import('./my-first-worker').MyFirstWorker&gt;(worker);
    workerApi.takeALongTimeToDoSomething();    
}</pre>
<p>现在，我们准备使用卸载到web worker中的函数来演示我们的应用程序。它现在的行为如下:</p>
<p><img data-attachment-id="13081" data-permalink="https://blog.logrocket.com/integrating-web-workers-in-a-react-app-with-comlink/non-blocking-process/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/01/non-blocking-process.gif" data-orig-size="730,286" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Non-blocked UI" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/01/non-blocking-process-300x118.gif" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/01/non-blocking-process.gif" decoding="async" class="aligncenter size-full wp-image-13081 jetpack-lazy-image" src="../Images/be745fd462be9fc817e2849db34d737b.png" alt="Non-blocked UI" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2020/01/non-blocking-process.gif?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/01/non-blocking-process.gif"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="13081" data-permalink="https://blog.logrocket.com/integrating-web-workers-in-a-react-app-with-comlink/non-blocking-process/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/01/non-blocking-process.gif" data-orig-size="730,286" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Non-blocked UI" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/01/non-blocking-process-300x118.gif" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/01/non-blocking-process.gif" decoding="async" loading="lazy" class="aligncenter size-full wp-image-13081" src="../Images/be745fd462be9fc817e2849db34d737b.png" alt="Non-blocked UI" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/01/non-blocking-process.gif"/></noscript>
<p>这里有一些令人兴奋的事情需要注意:</p>
<ol>
<li>应用程序现在是非阻塞的。我们长期运行的函数现在不会阻止用户界面的更新</li>
<li>该功能通过由<code>worker-plugin</code>和<code>comlink</code>创建的<code>my-first-worker.chunk.worker.js</code>被延迟加载</li>
</ol>
<h2>在React中使用web workers</h2>
<p>到目前为止，我们展示的例子展示了如何使用web workers以及为什么您可能想要这样做。然而，这与真实世界的用例相去甚远。让我们进行下一步，将我们的web worker应用程序插入到React应用程序中。那会是什么样子？让我们找出答案。</p>
<p>我们将把<code>index.tsx</code>返回到它的初始状态。然后，我们将制作一个简单的加法器函数，它接受一些值并返回它们的总和。对于我们的<code>takeALongTimeToDoSomething.ts</code>模块，让我们添加:</p>
<pre>export function takeALongTimeToAddTwoNumbers(number1: number, number2: number) {
    console.log('Start to add...');
    const seconds = 5;
    const start = new Date().getTime();
    const delay = seconds * 1000;
    while (true) {
        if ((new Date().getTime() - start) &gt; delay) {
            break;
        }
    }
    const total = number1 + number2;
    console.log('Finished adding');
    return total;
}</pre>
<p>让我们开始在React组件中使用长期运行的计算器。我们将更新我们的<code>App.tsx</code>来使用这个函数并创建一个简单的加法器组件:</p>
<pre>import React, { useState } from "react";
import "./App.css";
import { takeALongTimeToAddTwoNumbers } from "./takeALongTimeToDoSomething";

const App: React.FC = () =&gt; {
  const [number1, setNumber1] = useState(1);
  const [number2, setNumber2] = useState(2);

  const total = takeALongTimeToAddTwoNumbers(number1, number2);

  return (
    &lt;div className="App"&gt;
      &lt;h1&gt;Web Workers in action!&lt;/h1&gt;

      &lt;div&gt;
        &lt;label&gt;Number to add: &lt;/label&gt;
        &lt;input
          type="number"
          onChange={e =&gt; setNumber1(parseInt(e.target.value))}
          value={number1}
        /&gt;
      &lt;/div&gt;
      &lt;div&gt;
        &lt;label&gt;Number to add: &lt;/label&gt;
        &lt;input
          type="number"
          onChange={e =&gt; setNumber2(parseInt(e.target.value))}
          value={number2}
        /&gt;
      &lt;/div&gt;
      &lt;h2&gt;Total: {total}&lt;/h2&gt;
    &lt;/div&gt;
  );
};

export default App;</pre>
<p>当您尝试时，您会注意到输入一个数字会在添加数字时锁定用户界面五秒钟。从光标停止闪烁到屏幕更新，UI无响应:</p>
<p><img data-attachment-id="13082" data-permalink="https://blog.logrocket.com/integrating-web-workers-in-a-react-app-with-comlink/blocking-process-react/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/01/blocking-process-react.gif" data-orig-size="544,248" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Blocked UI in our React app" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/01/blocking-process-react-300x137.gif" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/01/blocking-process-react.gif" decoding="async" class="aligncenter size-full wp-image-13082 jetpack-lazy-image" src="../Images/7b1d42ecde3da829f998357315886613.png" alt="Blocked UI In Our React App" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2020/01/blocking-process-react.gif?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/01/blocking-process-react.gif"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="13082" data-permalink="https://blog.logrocket.com/integrating-web-workers-in-a-react-app-with-comlink/blocking-process-react/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/01/blocking-process-react.gif" data-orig-size="544,248" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Blocked UI in our React app" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/01/blocking-process-react-300x137.gif" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/01/blocking-process-react.gif" decoding="async" loading="lazy" class="aligncenter size-full wp-image-13082" src="../Images/7b1d42ecde3da829f998357315886613.png" alt="Blocked UI In Our React App" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/01/blocking-process-react.gif"/></noscript>
<p>到目前为止，很经典。让我们把它网络化吧！</p>
<p>我们将更新我们的<code>my-first-worker/index.ts</code>来导入这个新函数:</p>
<pre>import { expose } from "comlink";
import {
  takeALongTimeToDoSomething,
  takeALongTimeToAddTwoNumbers
} from "../takeALongTimeToDoSomething";

const exports = {
  takeALongTimeToDoSomething,
  takeALongTimeToAddTwoNumbers
};
export type MyFirstWorker = typeof exports;

expose(exports);</pre>
<p>除了我们的<code>App.tsx</code>文件，让我们创建一个<code>App.hooks.ts</code>文件。</p>
<pre>import { wrap, releaseProxy } from "comlink";
import { useEffect, useState, useMemo } from "react";

/**
 * Our hook that performs the calculation on the worker
 */
export function useTakeALongTimeToAddTwoNumbers(
  number1: number,
  number2: number
) {
  // We'll want to expose a wrapping object so we know when a calculation is in progress
  const [data, setData] = useState({
    isCalculating: false,
    total: undefined as number | undefined
  });

  // acquire our worker
  const { workerApi } = useWorker();

  useEffect(() =&gt; {
    // We're starting the calculation here
    setData({ isCalculating: true, total: undefined });

    workerApi
      .takeALongTimeToAddTwoNumbers(number1, number2)
      .then(total =&gt; setData({ isCalculating: false, total })); // We receive the result here
  }, [workerApi, setData, number1, number2]);

  return data;
}

function useWorker() {
  // memoise a worker so it can be reused; create one worker up front
  // and then reuse it subsequently; no creating new workers each time
  const workerApiAndCleanup = useMemo(() =&gt; makeWorkerApiAndCleanup(), []);

  useEffect(() =&gt; {
    const { cleanup } = workerApiAndCleanup;

    // cleanup our worker when we're done with it
    return () =&gt; {
      cleanup();
    };
  }, [workerApiAndCleanup]);

  return workerApiAndCleanup;
}

/**
 * Creates a worker, a cleanup function and returns it
 */
function makeWorkerApiAndCleanup() {
  // Here we create our worker and wrap it with comlink so we can interact with it
  const worker = new Worker("./my-first-worker", {
    name: "my-first-worker",
    type: "module"
  });
  const workerApi = wrap&lt;import("./my-first-worker").MyFirstWorker&gt;(worker);

  // A cleanup function that releases the comlink proxy and terminates the worker
  const cleanup = () =&gt; {
    workerApi[releaseProxy]();
    worker.terminate();
  };

  const workerApiAndCleanup = { workerApi, cleanup };

  return workerApiAndCleanup;
}</pre>
<p><code>useWorker</code>和<code>makeWorkerApiAndCleanup</code>函数构成了可共享工人挂钩方法的基础。这将需要很少的工作来参数化它们，所以这可以用在其他地方。这超出了本文的范围，但是完成起来非常简单。</p>
<p>考验的时候到了！我们将改变我们的<code>App.tsx</code>来使用新的<code>useTakeALongTimeToAddTwoNumbers</code>钩子:</p>
<pre>import React, { useState } from "react";
import "./App.css";
import { useTakeALongTimeToAddTwoNumbers } from "./App.hooks";

const App: React.FC = () =&gt; {
  const [number1, setNumber1] = useState(1);
  const [number2, setNumber2] = useState(2);

  const total = useTakeALongTimeToAddTwoNumbers(number1, number2);

  return (
    &lt;div className="App"&gt;
      &lt;h1&gt;Web Workers in action!&lt;/h1&gt;

      &lt;div&gt;
        &lt;label&gt;Number to add: &lt;/label&gt;
        &lt;input
          type="number"
          onChange={e =&gt; setNumber1(parseInt(e.target.value))}
          value={number1}
        /&gt;
      &lt;/div&gt;
      &lt;div&gt;
        &lt;label&gt;Number to add: &lt;/label&gt;
        &lt;input
          type="number"
          onChange={e =&gt; setNumber2(parseInt(e.target.value))}
          value={number2}
        /&gt;
      &lt;/div&gt;
      &lt;h2&gt;
        Total:{" "}
        {total.isCalculating ? (
          &lt;em&gt;Calculating...&lt;/em&gt;
        ) : (
          &lt;strong&gt;{total.total}&lt;/strong&gt;
        )}
      &lt;/h2&gt;
    &lt;/div&gt;
  );
};

export default App;</pre>
<p>现在我们的计算发生在主线程之外，UI不再被阻塞！</p>
<p><img data-attachment-id="13083" data-permalink="https://blog.logrocket.com/integrating-web-workers-in-a-react-app-with-comlink/non-blocking-process-react/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/01/non-blocking-process-react.gif" data-orig-size="544,248" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Non-blocked UI in our React app" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/01/non-blocking-process-react-300x137.gif" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/01/non-blocking-process-react.gif" decoding="async" class="aligncenter size-full wp-image-13083 jetpack-lazy-image" src="../Images/ae72473608e4f3ec40b206ba3436c379.png" alt="Non-blocked UI In Our React App" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2020/01/non-blocking-process-react.gif?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/01/non-blocking-process-react.gif"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="13083" data-permalink="https://blog.logrocket.com/integrating-web-workers-in-a-react-app-with-comlink/non-blocking-process-react/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/01/non-blocking-process-react.gif" data-orig-size="544,248" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Non-blocked UI in our React app" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/01/non-blocking-process-react-300x137.gif" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/01/non-blocking-process-react.gif" decoding="async" loading="lazy" class="aligncenter size-full wp-image-13083" src="../Images/ae72473608e4f3ec40b206ba3436c379.png" alt="Non-blocked UI In Our React App" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/01/non-blocking-process-react.gif"/></noscript><div class="code-block code-block-17">
<div class="blog-plug inline-plug react-plug" vwo-el-id="26283398190">
<h2 vwo-el-id="41600691720"><a href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener"> LogRocket </a>:全面了解您的生产React应用</h2><p>调试React应用程序可能很困难，尤其是当用户遇到难以重现的问题时。如果您对监视和跟踪Redux状态、自动显示JavaScript错误以及跟踪缓慢的网络请求和组件加载时间感兴趣，</p><a href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" vwo-el-id="19356441070">try LogRocket</a><p>. </p><a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="19356441380">
<img class="first-react-image alignnone size-full wp-image-46 jetpack-lazy-image jetpack-lazy-image--handled" src="../Images/f300c244a1a1cf916df8b4cb02bec6c6.png" vwo-el-id="18272717540" data-lazy-loaded="1" data-original-src="https://files.readme.io/27c94e7-Image_2017-06-05_at_9.46.04_PM.png"/>
</a>
<a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="19356441690">
<img class="second-react-image alignnone size-full wp-image-46 jetpack-lazy-image jetpack-lazy-image--handled" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" vwo-el-id="30720362350" data-lazy-loaded="1" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/>
</a>
<p vwo-el-id="28675660440" class="">LogRocket 结合了会话回放、产品分析和错误跟踪，使软件团队能够创建理想的web和移动产品体验。这对你来说意味着什么？</p>
<p>LogRocket不是猜测错误发生的原因，也不是要求用户提供截图和日志转储，而是让您回放问题，就像它们发生在您自己的浏览器中一样，以快速了解哪里出错了。</p>
<p>不再有嘈杂的警报。智能错误跟踪允许您对问题进行分类，然后从中学习。获得有影响的用户问题的通知，而不是误报。警报越少，有用的信号越多。</p>
<p vwo-el-id="28675660750">LogRocket Redux中间件包为您的用户会话增加了一层额外的可见性。LogRocket记录Redux存储中的所有操作和状态。</p>
<p vwo-el-id="28675661060">现代化您调试React应用的方式— <a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="40093418840">开始免费监控</a>。</p><div class="code-block code-block-21">
<div class="blog-plug inline-plug typescript-plug"><h2><a class="signup" href="https://lp.logrocket.com/blg/typescript-signup" target="_blank" rel="noopener noreferrer"> LogRocket </a>:全面了解您的网络和移动应用</h2>
<a href="https://lp.logrocket.com/blg/typescript-signup" class="signup" target="_blank" rel="noopener noreferrer"><img class="alignnone size-full wp-image-46 jetpack-lazy-image" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/><noscript><img data-lazy-fallback="1" class="alignnone size-full wp-image-46" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/></noscript></a>
<p>LogRocket 是一个前端应用程序监控解决方案，可以让您回放问题，就像问题发生在您自己的浏览器中一样。LogRocket不需要猜测错误发生的原因，也不需要向用户询问截图和日志转储，而是让您重放会话以快速了解哪里出错了。它可以与任何应用程序完美配合，不管是什么框架，并且有插件可以记录来自Redux、Vuex和@ngrx/store的额外上下文。</p>
<p>除了记录Redux操作和状态，LogRocket还记录控制台日志、JavaScript错误、堆栈跟踪、带有头+正文的网络请求/响应、浏览器元数据和自定义日志。它还使用DOM来记录页面上的HTML和CSS，甚至为最复杂的单页面和移动应用程序重新创建像素级完美视频。</p>
<a class="signup" href="https://lp.logrocket.com/blg/typescript-signup" target="_blank" rel="noopener noreferrer">Try it for free</a><p>.</p></div>
</div>
</div></div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
<html>
<head>
<title>How to implement every JavaScript array method - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>如何实现每一个JavaScript数组方法- LogRocket博客</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/javascript-array-methods/#0001-01-01">https://blog.logrocket.com/javascript-array-methods/#0001-01-01</a></blockquote><div><article class="article-post">
<p>为了在给定的数组上使用一个方法，我们键入<code>[].methodName</code>。它们都在<code>Array.prototype</code>对象中定义。然而，在这里，我们不会使用这些；相反，我们将从简单的方法开始定义我们自己的版本，并在这些基础上构建，直到我们得到所有的版本。</p>
<p>没有比把东西拆开再组装起来更好的学习方法了。请注意，在我们的实现工作时，我们不会覆盖现有的方法，因为这从来都不是一个好主意(我们导入的一些包可能依赖于它)。此外，这将允许我们比较我们的版本与原始方法的差异。</p>
<p>所以与其写这个:</p>
<pre>Array.prototype.map = function map() {
 <em>// implementation</em>
};</pre>
<p>我们要这样做:</p>
<pre>function map(array) {
 <em>// takes an array as the first argument
 // implementation</em>
}</pre>
<p>我们也可以通过使用<code>class</code>关键字并扩展<code>Array</code>构造函数来实现我们的方法，如下所示:</p>
<pre>class OwnArray extends Array {
 public constructor(...args) {
   super(...args);
 }

 public map() {
   <em>// implementation</em>
   return this;
 }
}</pre>
<p>唯一的区别是，我们将使用关键字<code>this</code>，而不是使用<code>array</code>参数。</p>
<p>然而，我觉得这会带来不必要的混乱，所以我们将坚持第一种方法。</p>
<p>解决了这个问题，让我们通过实现最简单的方法开始吧——<code>forEach</code>方法！</p>
<h2>迭代集合</h2>

<p><code>Array.prototype.forEach</code>方法接受一个回调函数，并对<a href="https://blog.logrocket.com/writing-for-readability-with-declarative-arrays-64f0b1a807f3/" target="_blank" rel="noopener noreferrer">数组</a>中的每一项执行该函数，而不会以任何方式改变数组。</p>
<pre>[1, 2, 3, 4, 5].forEach(value =&gt; console.log(value));</pre>
<h4>履行</h4>
<pre>function forEach(array, callback) {
 const { length } = array;

 for (let index = 0; index &lt; length; index += 1) {
   const value = array[index];
   callback(value, index, array);
 }
}</pre>
<p>我们遍历数组并对每个元素执行回调。这里需要注意的重要一点是，该方法不返回任何东西——因此，在某种程度上，它返回<code>undefined</code>。</p>
<h4>方法链接</h4>
<p>使用数组方法的好处是可以将操作链接在一起。考虑以下代码:</p>
<pre>function getTodosWithCategory(todos, category) {
 return todos
   .filter(todo =&gt; todo.category === category)
   .map(todo =&gt; normalizeTodo(todo));
}</pre>
<p>这样，我们就不必将<code>map</code>的结果保存到变量中，通常会得到更好看的代码。</p>
<p>可惜，<code>forEach</code>不返回输入数组！这意味着我们不能进行以下操作:</p>
<pre><em>// Won't work!</em>
function getTodosWithCategory(todos, category) {
 return todos
   .filter(todo =&gt; todo.category === category)
   .forEach((value) =&gt; console.log(value))
   .map(todo =&gt; normalizeTodo(todo));
}</pre>
<p>这里的<code>console.log</code>当然是没用的。</p>
<h4>日志记录实用程序功能</h4>
<p>我已经编写了一个简单的实用函数，它将更好地解释每个方法做什么:它接受什么作为输入，它返回什么，以及它是否改变了数组。</p>
<pre>function logOperation(operationName, array, callback) {
 const input = [...array];
 const result = callback(array);

 console.log({
   operation: operationName,
   arrayBefore: input,
   arrayAfter: array,
   mutates: mutatesArray(input, array), // shallow check
   result,
 });
}</pre>
<p>下面是为我们的<code>forEach</code>实现运行的实用函数:</p>
<pre>logOperation('forEach', [1, 2, 3, 4, 5], array =&gt; forEach(array, value =&gt; console.log(value)));</pre>
<pre>{
  operation: 'forEach',
  arrayBefore: [ 1, 2, 3, 4, 5 ],
  arrayAfter: [ 1, 2, 3, 4, 5 ],
  mutates: false,
  result: undefined
}</pre>
<p>由于我们将方法实现为函数，所以我们必须使用下面的语法:<code>forEach(array, ...)</code>而不是<code>array.forEach(...)</code>。</p>
<p>注意:我还为每种方法创建了测试用例，以确保它们如预期的那样工作——你可以在库中找到它们<a href="https://github.com/maciejcieslar/array-methods">。</a></p>

<p>最常用的方法之一就是<code>Array.prototype.map</code>。它让我们通过将现有值转换成新值来创建一个新数组。</p>
<pre>[1, 2, 3].map(number =&gt; number * 5);
<em>// -&gt; [5, 10, 15]</em></pre>
<h4>履行</h4>
<pre>function map(array, callback) {
 const result = [];
 const { length } = array;

 for (let index = 0; index &lt; length; index += 1) {
   const value = array[index];

   result[index] = callback(value, index, array);
 }

 return result;
}</pre>
<p>提供给该方法的回调将旧值作为参数，并返回一个新值，然后将其保存在新数组中的同一索引下，这里称为<code>result</code>。</p>
<p>这里需要注意的是，我们返回了一个新的数组；我们不修改旧的。这是一个重要的区别，因为数组和对象在这里是作为引用传递的。如果你对引用和价值的事情感到困惑，<a href="https://codeburst.io/explaining-value-vs-reference-in-javascript-647a975e12a0">这里有一篇很棒的文章</a>。</p>
<pre>logOperation('map', [1, 2, 3, 4, 5], array =&gt; map(array, value =&gt; value + 5));</pre>
<pre>{
  operation: 'map',
  input: [ 1, 2, 3, 4, 5 ],
  output: [ 6, 7, 8, 9, 10 ],
  mutates: false
}</pre>

<p>另一个非常有用的方法是<code>Array.prototype.filter</code>。顾名思义，它过滤掉回调返回的值是<code>false</code>。每个值都保存在一个新数组中，稍后返回。</p>
<pre>[1, 2, 3, 4, 5].filter(number =&gt; number &gt;= 3);
<em>// -&gt; [3, 4, 5]</em></pre>
<h4>履行</h4>
<pre>function filter(array, callback) {
 const result = [];

 const { length } = array;

 for (let index = 0; index &lt; length; index += 1) {
   const value = array[index];

   if (callback(value, index, array)) {
     push(result, value);
   }
 }

 return result;
}</pre>
<p>我们获取每个值，并检查所提供的回调是否返回了<code>true</code>或<code>false</code>，并适当地将该值附加到新创建的数组或丢弃它。</p>
<p>注意，这里我们对<code>result</code>数组使用了<code>push</code>方法，而不是将值保存在输入数组中的相同索引处。这样，<code>result</code>就不会因为丢弃的值而出现空槽。</p>
<pre>logOperation('filter', [1, 2, 3, 4, 5], array =&gt; filter(array, value =&gt; value &gt;= 2));</pre>
<pre>{
  operation: 'filter',
  input: [ 1, 2, 3, 4, 5 ],
  output: [ 2, 3, 4, 5 ],
  mutates: false
}</pre>

<p>诚然，<code>reduce</code>方法是更复杂的方法之一。然而，其使用的广泛性不能被夸大，因此很好地掌握它是如何工作的是至关重要的。它接受一个数组并输出一个值。从某种意义上来说，它<em>将</em>数组降低到那个值。</p>
<p>这个值是如何计算的，确切地说，是需要在回调中指定的。让我们考虑一个例子——对<code>reduce</code>最简单的用法，也就是对一组数字求和:</p>
<pre> [1, 2, 3, 4, 5, 6, 7, 8, 9, 10].reduce((sum, number) =&gt; {
   return sum + number;
 }, 0) <em>// -&gt; 55</em></pre>
<p>注意这里的回调是如何接受两个参数的:<code>sum</code>和<code>number</code>。第一个总是前一次迭代返回的结果，第二个是我们当前在循环中考虑的数组元素。</p>
<p>所以在这里，当我们在数组上迭代时，<code>sum</code>将包含到循环的当前索引为止的数字的总和，因为每次迭代我们只是将数组的当前值加到它上面。</p>
<h4>履行</h4>
<pre>function reduce(array, callback, initValue) {
 const { length } = array;

 let acc = initValue;
 let startAtIndex = 0;

 if (initValue === undefined) {
   acc = array[0];
   startAtIndex = 1;
 }

 for (let index = startAtIndex; index &lt; length; index += 1) {
   const value = array[index];
   acc = callback(acc, value, index, array);
 }

 return acc;
}</pre>
<p>我们创建两个变量，<code>acc</code>和<code>startAtIndex</code>，并用它们的默认值初始化它们，分别是参数<code>initValue</code>和<code>0</code>。</p>
<p>然后，我们检查<code>initValue</code>是否未定义。如果是，我们必须将数组的第一个值设置为初始值，为了不重复计算初始元素，将<code>startAtIndex</code>设置为<code>1</code>。</p><div class="code-block code-block-54">
<hr/>
<h3>更多来自LogRocket的精彩文章:</h3>

<hr/></div>
<p>每次迭代，<code>reduce</code>方法将回调的结果保存在累加器(<code>acc</code>)中，然后在下一次迭代中可用。对于第一次迭代，累加器被设置为<code>initValue</code>或<code>array[0]</code>。</p>
<pre>logOperation('reduce', [1, 2, 3, 4, 5], array =&gt; reduce(array, (sum, number) =&gt; sum + number, 0));</pre>
<pre>{
  operation: 'reduce',
  arrayBefore: [ 1, 2, 3, 4, 5 ],
  arrayAfter: [ 1, 2, 3, 4, 5 ],
  mutates: false,
  result: 15
}</pre>
<h2>搜索</h2>
<p>对数组的什么操作比搜索某个特定值更常见？这里有一些方法可以帮助我们做到这一点。</p>

<p>顾名思义，<code>findIndex</code>帮助我们找到数组内部给定值的索引。</p>
<pre>[1, 2, 3, 4, 5, 6, 7].findIndex(value =&gt; value === 5); <em>// 4</em></pre>
<p>该方法为数组中的每一项执行提供的回调，直到回调返回<code>true</code>。然后，该方法返回当前索引。如果找不到值，则返回<code>-1</code>。</p>
<h4>履行</h4>
<pre>function findIndex(array, callback) {
 const { length } = array;

 for (let index = 0; index &lt; length; index += 1) {
   const value = array[index];

   if (callback(value, index, array)) {
     return index;
   }
 }

 return -1;
}</pre>
<pre>logOperation('findIndex', [1, 2, 3, 4, 5], array =&gt; findIndex(array, number =&gt; number === 3));</pre>
<pre>{
  operation: 'findIndex',
  arrayBefore: [ 1, 2, 3, 4, 5 ],
  arrayAfter: [ 1, 2, 3, 4, 5 ],
  mutates: false,
  result: 2
}</pre>

<p><code>find</code>与<code>findIndex</code>的唯一区别在于它返回实际值而不是其索引。在我们的实现中，我们可以重用已经实现的<code>findIndex</code>。</p>
<pre>[1, 2, 3, 4, 5, 6, 7].findIndex(value =&gt; value === 5); <em>// 5</em></pre>
<h4>履行</h4>
<pre>function find(array, callback) {
 const index = findIndex(array, callback);

 if (index === -1) {
   return undefined;
 }

 return array[index];
}</pre>
<pre>logOperation('find', [1, 2, 3, 4, 5], array =&gt; find(array, number =&gt; number === 3));</pre>
<pre>{
  operation: 'find',
  arrayBefore: [ 1, 2, 3, 4, 5 ],
  arrayAfter: [ 1, 2, 3, 4, 5 ],
  mutates: false,
  result: 3
}</pre>

<p><code>indexOf</code>是另一种获取给定值索引的方法。然而，这一次我们将实际值作为参数而不是函数来传递。同样，为了简化实现，我们可以使用之前实现的<code>findIndex</code>！</p>
<pre>[3, 2, 3].indexOf(3); <em>// -&gt; 0</em></pre>
<h4>履行</h4>
<pre>function indexOf(array, searchedValue) {
 return findIndex(array, value =&gt; value === searchedValue);
}</pre>
<p>基于我们正在搜索的值，我们向<code>findIndex</code>提供一个适当的回调。</p>
<pre>logOperation('indexOf', [1, 2, 3, 4, 5], array =&gt; indexOf(array, 3));</pre>
<pre>{
  operation: 'indexOf',
  arrayBefore: [ 1, 2, 3, 4, 5 ],
  arrayAfter: [ 1, 2, 3, 4, 5 ],
  mutates: false,
  result: 2
}</pre>

<p><code>lastIndexOf</code>的工作方式与<code>indexOf</code>相同，只是它从数组的末尾开始。我们也(像<code>indexOf</code>)将我们正在寻找的值作为参数而不是回调来传递。</p>
<pre>[3, 2, 3].lastIndexOf(3); <em>// -&gt; 2</em></pre>
<h4>履行</h4>
<pre>function lastIndexOf(array, searchedValue) {
 for (let index = array.length - 1; index &gt; -1; index -= 1) {
   const value = array[index];

   if (value === searchedValue) {
     return index;
   }
 }

 return -1;
}</pre>
<p>我们对<code>findIndex</code>做了同样的事情，但是我们没有执行回调，而是比较了<code>value</code>和<code>searchedValue</code>。如果比较产生<code>true</code>，我们返回索引；如果我们没有找到值，我们返回<code>-1</code>。</p>
<pre>logOperation('lastIndexOf', [1, 2, 3, 4, 5, 3], array =&gt; lastIndexOf(array, 3));</pre>
<pre>{
  operation: 'lastIndexOf',
  arrayBefore: [ 1, 2, 3, 4, 5, 3 ],
  arrayAfter: [ 1, 2, 3, 4, 5, 3 ],
  mutates: false,
  result: 5
}</pre>

<p>当我们想要检查一个数组的所有元素是否满足给定的条件时，<code>every</code>方法就派上了用场。</p>
<pre>[1, 2, 3].every(value =&gt; Number.isInteger(value)); <em>// -&gt; true</em></pre>
<p>您可以将<code>every</code>方法视为逻辑<em>和</em>的数组等价物。</p>
<h4>履行</h4>
<pre>function every(array, callback) {
 const { length } = array;

 for (let index = 0; index &lt; length; index += 1) {
   const value = array[index];

   if (!callback(value, index, array)) {
     return false;
   }
 }

 return true;
}</pre>
<p>我们对每个值执行回调。如果<code>false</code>在任一点被返回，我们退出循环，整个方法返回<code>false</code>。如果循环在没有触发<code>if</code>语句的情况下终止(所有元素产生<code>true</code>，该方法返回<code>true</code>。</p>
<pre>logOperation('every', [1, 2, 3, 4, 5], array =&gt; every(array, number =&gt; Number.isInteger(number)));</pre>
<pre>{
  operation: 'every',
  arrayBefore: [ 1, 2, 3, 4, 5 ],
  arrayAfter: [ 1, 2, 3, 4, 5 ],
  mutates: false,
  result: true
}</pre>

<p>现在来看看<code>every</code> : <code>some</code>完全相反的情况。即使回调只有一次执行返回<code>true</code>，函数也会返回<code>true</code>。与<code>every</code>方法类似，您可以将<code>some</code>方法视为逻辑<em>或</em>的数组等价物。</p>
<pre>[1, 2, 3, 4, 5].some(number =&gt; number === 5); <em>// -&gt; true</em></pre>
<h4>履行</h4>
<pre>function some(array, callback) {
 const { length } = array;

 for (let index = 0; index &lt; length; index += 1) {
   const value = array[index];

   if (callback(value, index, array)) {
     return true;
   }
 }

 return false;
}</pre>
<p>我们对每个值执行回调。如果<code>true</code>在任一点被返回，我们退出循环，整个方法返回<code>true</code>。如果循环在没有触发<code>if</code>语句的情况下终止(所有元素产生<code>false</code>，该方法返回<code>false</code>。</p>
<pre>logOperation('some', [1, 2, 3, 4, 5], array =&gt; some(array, number =&gt; number === 5));</pre>
<pre>{
  operation: 'some',
  arrayBefore: [ 1, 2, 3, 4, 5 ],
  arrayAfter: [ 1, 2, 3, 4, 5 ],
  mutates: false,
  result: true
}</pre>

<p><code>includes</code>方法的工作方式类似于<code>some</code>方法，但是我们提供了一个值作为参数来比较元素，而不是回调。</p>
<pre>[1, 2, 3].includes(3); <em>// -&gt; true</em></pre>
<h4>履行</h4>
<pre>function includes(array, searchedValue) {
 return some(array, value =&gt; value === searchedValue);
}</pre>
<pre>logOperation('includes', [1, 2, 3, 4, 5], array =&gt; includes(array, 5));</pre>
<pre>{
  operation: 'includes',
  arrayBefore: [ 1, 2, 3, 4, 5 ],
  arrayAfter: [ 1, 2, 3, 4, 5 ],
  mutates: false,
  result: true
}</pre>
<h2>变平</h2>
<p>有时我们的数组变得有两到三层深，我们想把它们变平，也就是减少它们嵌套的程度。例如，假设我们想要将所有的值带到顶层。对我们有帮助的是，该语言增加了两个新的内容:<code>flat</code>和<code>flatMap</code>方法。</p>

<p><code>flat</code>方法通过从嵌套数组中取出值来减少嵌套的深度。</p>
<pre>[1, 2, 3, [4, 5, [6, 7, [8]]]].flat(1); <em>// -&gt; [1, 2, 3, 4, 5, [6, 7, [8]]]</em></pre>
<p>由于我们作为参数提供的级别是<code>1</code>，因此只有第一级数组被展平；其余的保持不变。</p>
<pre>[1, 2, 3, [4, 5]].flat(1) <em>// -&gt; [1, 2, 3, 4, 5]</em></pre>
<h4>履行</h4>
<pre>function flat(array, depth = 0) {
 if (depth &lt; 1 || !Array.isArray(array)) {
   return array;
 }

 return reduce(
   array,
   (result, current) =&gt; {
     return concat(result, flat(current, depth - 1));
   },
   [],
 );
}</pre>
<p>首先，我们检查深度参数是否小于<code>1</code>。如果是，就意味着没有什么要展平的，我们应该简单地返回数组。</p>
<p>其次，我们检查<code>array</code>参数实际上是否属于<code>Array</code>类型，因为如果不是，那么扁平化的概念就没有意义，所以我们简单地返回这个参数。</p>
<p>我们使用了以前实现过的<code>reduce</code>函数。我们从一个空数组开始，然后取<code>array</code>的每个值并展平它。</p>
<p>注意，我们用<code>(depth - 1)</code>调用<code>flat</code>函数。对于每个调用，我们递减<code>depth</code>参数，以免导致无限循环。一旦展平完成，我们将返回值追加到<code>result</code>数组中。</p>
<p>注意:<code>concat</code>函数在这里用来合并两个数组。该功能的实现解释如下。</p>
<pre>logOperation('flat', [1, 2, 3, [4, 5, [6]]], array =&gt; flat(array, 2));</pre>
<pre>{
  operation: 'flat',
  arrayBefore: [ 1, 2, 3, [ 4, 5, [Array] ] ],
  arrayAfter: [ 1, 2, 3, [ 4, 5, [Array] ] ],
  mutates: false,
  result: [ 1, 2, 3, 4, 5, 6 ]
}</pre>

<p><code>flatMap</code>，顾名思义，是<code>flat</code>和<code>map</code>的组合。首先，我们根据回调进行映射，然后将结果拉平。</p>
<p>在上面的<code>map</code>方法中，对于每个值，我们精确地返回一个值。这样，一个有三个元素的数组在映射后仍然有三个元素。使用<code>flatMap</code>，在所提供的回调函数中，我们可以返回一个数组，该数组稍后会被展平。</p>
<pre>[1, 2, 3].flatMap(value =&gt; [value, value, value]); <em>// [1, 1, 1, 2, 2, 2, 3, 3, 3]</em></pre>
<p>每个返回的数组都被展平，我们得到的不是一个嵌套了三个数组的数组，而是一个包含九个元素的数组。</p>
<h4>履行</h4>
<pre>function flatMap(array, callback) {
 return flat(map(array, callback), 1);
}</pre>
<p>按照上面的解释，我们首先使用<code>map</code>，然后将得到的数组平铺一层。</p>
<pre>logOperation('flatMap', [1, 2, 3], array =&gt; flatMap(array, number =&gt; [number, number]));</pre>
<pre>{
  operation: 'flatMap',
  arrayBefore: [ 1, 2, 3 ],
  arrayAfter: [ 1, 2, 3 ],
  mutates: false,
  result: [ 1, 1, 2, 2, 3, 3 ]
}</pre>
<h2>连接、追加和反转数组</h2>

<p>正如您刚才看到的，<code>concat</code>方法对于合并两个或多个数组非常有用。它被广泛使用，因为它不会改变数组；相反，它返回一个新数组，所有提供的数组都合并到这个新数组中。</p>
<pre>[1, 2, 3].concat([4, 5], 6, [7, 8]) <em>// -&gt; [1, 2, 3, 4, 5, 6, 7, 8]</em></pre>
<h4>履行</h4>
<pre>function concat(array, ...values) {
 const result = [...array];
 const { length } = values;

 for (let index = 0; index &lt; length; index += 1) {
   const value = values[index];

   if (Array.isArray(value)) {
     push(result, ...value);
   } else {
     push(result, value);
   }
 }

 return result;
}</pre>
<p><code>concat</code>将一个数组作为第一个参数，将数量不确定的值作为第二个参数，这些值<em>可以是</em>数组(也可以是其他任何值，比如原始值)。</p>
<p>首先，我们通过复制提供的数组来创建<code>result</code>数组(使用<em> spread </em>操作符，它将提供的数组的值传播到一个新的数组中)。然后，当我们迭代提供的其余值时，我们检查该值是否是一个数组。如果是，我们使用<code>push</code>函数将其值追加到<code>result</code>数组中。</p>
<p>如果我们做了<code>push(result, value)</code>，我们将只把数组作为一个元素添加。相反，通过使用扩展操作符<code>push(result, ...value)</code>，我们将数组的所有值追加到<code>result</code>数组中。在某种程度上，我们将数组展平一层深度！</p>
<p>否则，如果当前值不是一个数组，我们也将该值推送到<code>result</code>数组——当然，这次没有使用<em> spread </em>操作符。</p>
<pre>logOperation('concat', [1, 2, 3, 4, 5], array =&gt; concat(array, 1, 2, [3, 4]));</pre>
<pre>{
  arrayAfter: [ 1, 2, 3, 4, 5 ],
  mutates: false,
  result: [
    1, 2, 3, 4, 5,
    1, 2, 3, 4
  ]
}</pre>

<p><code>join</code>方法将一个数组转换成一个字符串，用一个选择的字符串来分隔值。</p>
<pre>['Brian', 'Matt', 'Kate'].join(', ') <em>// -&gt; Brian, Matt, Kate</em></pre>
<h4>履行</h4>
<pre>function join(array, joinWith) {
 return reduce(
   array,
   (result, current, index) =&gt; {
     if (index === 0) {
       return current;
     }

     return `${result}${joinWith}${current}`;
   },
   '',
 );
}</pre>
<p>我们使用了<code>reduce</code>函数:我们将提供的数组传递给它，并将初始值设置为一个空字符串。到目前为止很简单。</p>
<p>对<code>reduce</code>的回调是神奇的地方:reduce遍历提供的数组并将结果字符串组合在一起，在数组的值之间放置所需的分隔符(作为<code>joinWith</code>传递)。</p>
<p><code>array[0]</code>值需要一些特殊的处理，因为在那一点上<code>result</code>仍然是未定义的(它是一个空字符串)，我们也不希望在第一个元素前面有分隔符(<code>joinWith</code>)。</p>
<pre>logOperation('join', [1, 2, 3, 4, 5], array =&gt; join(array, ', '));</pre>
<pre>{
  operation: 'join',
  arrayBefore: [ 1, 2, 3, 4, 5 ],
  arrayAfter: [ 1, 2, 3, 4, 5 ],
  mutates: false,
  result: '1, 2, 3, 4, 5'
}</pre>

<p><code>reverse</code>方法颠倒数组中值的顺序。</p>
<pre>[1, 2, 3].reverse(); <em>// -&gt; [3, 2, 1]</em></pre>
<h4>履行</h4>
<pre>function reverse(array) {
 const result = [];

 const lastIndex = array.length - 1;

 for (let index = lastIndex; index &gt; -1; index -= 1) {
   const value = array[index];
   result[lastIndex - index] = value;
 }

 return result;
}</pre>
<p>想法很简单:首先，我们定义一个空数组，并保存作为参数提供的数组的最后一个索引。我们反向迭代所提供的数组，将每个值保存在数组<code>result</code>中的<code>(lastIndex - index)</code>位置，然后返回。</p>
<pre>logOperation('reverse', [1, 2, 3, 4, 5], array =&gt; reverse(array));</pre>
<pre>{
  operation: 'reverse',
  arrayBefore: [ 1, 2, 3, 4, 5 ],
  arrayAfter: [ 1, 2, 3, 4, 5 ],
  mutates: false,
  result: [ 5, 4, 3, 2, 1 ]
}</pre>
<h2>添加、移除和追加值</h2>

<p><code>shift</code>方法将一个数组的值下移一个索引，通过这样做删除第一个值，然后返回该值。</p>
<pre>[1, 2, 3].shift(); <em>// -&gt; 1</em></pre>
<h4>履行</h4>
<pre>function shift(array) {
 const { length } = array;
 const firstValue = array[0];

 for (let index = 1; index &lt; length; index += 1) {
   const value = array[index];
   array[index - 1] = value;
 }

 array.length = length - 1;

 return firstValue;
}</pre>
<p>我们首先保存所提供的数组的原始长度及其初始值(当我们将所有内容移动1时，我们将删除该值)。然后我们遍历数组，将每个值下移一个索引。一旦完成，我们更新数组的长度并返回曾经的初始值。</p>
<pre>logOperation('shift', [1, 2, 3, 4, 5], array =&gt; shift(array));</pre>
<pre>{
  operation: 'shift',
  arrayBefore: [ 1, 2, 3, 4, 5 ],
  arrayAfter: [ 2, 3, 4, 5 ],
  mutates: true,
  result: 1
}</pre>

<p><code>unshift</code>方法将一个或多个值添加到数组的开头，并返回该数组的长度。</p>
<pre>[2, 3, 4].unshift(1); <em>// -&gt; [1, 2, 3, 4]</em></pre>
<h4>履行</h4>
<pre>function unshift(array, ...values) {
 const mergedArrays = concat(values, ...array);
 const { length: mergedArraysLength } = mergedArrays;

 for (let index = 0; index &lt; mergedArraysLength; index += 1) {
   const value = mergedArrays[index];
   array[index] = value;
 }

 return array.length;
}</pre>
<p>我们首先连接<code>values</code>(作为参数传递的单个值)和<code>array</code>(我们想要取消移位的数组)。这里需要注意的是，<code>values</code>排在第一位；它们将被放置在原始数组的前面。</p>
<p>然后，我们保存这个新数组的长度，并对其进行迭代，将其值保存在原始数组中，并覆盖原来的数组。</p>
<pre>logOperation('unshift', [1, 2, 3, 4, 5], array =&gt; unshift(array, 0));</pre>
<pre>{
  operation: 'unshift',
  arrayBefore: [ 1, 2, 3, 4, 5 ],
  arrayAfter: [ 0, 1, 2, 3, 4, 5 ],
  mutates: true,
  result: 6
}</pre>

<p>从数组中取出一个值很简单:我们只需使用它的索引来引用它。然而，有时我们想从数组中取出更大的一部分——比方说，一次取出三个或四个元素。这时<code>slice</code>方法就派上用场了。</p>
<p>我们指定开始和结束索引，然后<code>slice</code>将从原始数组中这些索引处截取的数组交给我们。但是，请注意，end index参数不是包含性的；在下面的例子中，只有索引<code>3</code>、<code>4</code>和<code>5</code>的元素进入结果数组。</p>
<pre>[1, 2, 3, 4, 5, 6, 7].slice(3, 6); <em>// -&gt; [4, 5, 6]</em></pre>
<h4>履行</h4>
<pre>function slice(array, startIndex = 0, endIndex = array.length) {
 const result = [];

 for (let index = startIndex; index &lt; endIndex; index += 1) {
   const value = array[index];

   if (index &lt; array.length) {
     push(result, value);
   }
 }

 return result;
}</pre>
<p>我们从<code>startIndex</code>到<code>endIndex</code>迭代数组，并将每个值推送到<code>result</code>。我们在这里还使用了默认的参数，这样当没有参数被传递时，<code>slice</code>方法简单地创建了一个数组的副本。我们通过默认将<code>startIndex</code>设置为<code>0</code>并将<code>endIndex</code>设置为数组的长度来实现这一点。</p>
<p>注意:<code>if</code>语句确保我们<code>push</code>只有在给定索引下的值存在于原始数组中。</p>
<pre>logOperation('slice', [1, 2, 3, 4, 5], array =&gt; slice(array, 1, 3));</pre>
<pre>{
  operation: 'slice',
  arrayBefore: [ 1, 2, 3, 4, 5 ],
  arrayAfter: [ 1, 2, 3, 4, 5 ],
  mutates: false,
  result: [ 2, 3 ]
}</pre>

<p><code>splice</code>方法同时从数组中删除给定数量的值，并在它们的位置插入一些其他值。虽然一开始并不明显，但我们可以添加比移除更多的值，反之亦然。</p>
<p>首先，我们指定起始索引，然后指定要删除多少个值，剩下的参数是要插入的值。</p>
<pre>const arr = [1, 2, 3, 4, 5];

arr.splice(0, 2, 3, 4, 5);

arr <em>// -&gt; [3, 4, 5, 3, 4, 5]</em></pre>
<h4>履行</h4>
<pre>function splice&lt;T&gt;(array: T[], insertAtIndex: number, removeNumberOfElements: number, ...values: T[]) {
  const firstPart = slice(array, 0, insertAtIndex);
  const secondPart = slice(array, insertAtIndex + removeNumberOfElements);

  const removedElements = slice(array, insertAtIndex, insertAtIndex + removeNumberOfElements);

  const joinedParts = firstPart.concat(values, secondPart);
  const { length: joinedPartsLength } = joinedParts;

  for (let index = 0; index &lt; joinedPartsLength; index += 1) {
    array[index] = joinedParts[index];
  }

  array.length = joinedPartsLength;

  return removedElements;
}</pre>
<p>想法是在<code>insertAtIndex</code>和<code>insertAtIndex + removeNumberOfElements</code>进行两次切割。这样，我们把<code>slice</code>原来的阵列分成了三块。第一个片段(<code>firstPart</code>)和第三个片段(这里称为<code>secondPart</code>)将进入最终的数组。</p>
<p>我们将在这两者之间插入作为参数传递的值。我们用<code>concat</code>方法来做这件事。剩下的中间部分是<code>removedElements</code>，我们最后返回。</p>
<pre>logOperation('splice', [1, 2, 3, 4, 5], array =&gt; splice(array, 1, 3));</pre>
<pre>{
  operation: 'splice',
  arrayBefore: [ 1, 2, 3, 4, 5 ],
  arrayAfter: [ 1, 5 ],
  mutates: true,
  result: [ 2, 3, 4 ]
}</pre>

<p>方法删除数组的最后一个值并返回它。</p>
<pre>[1, 2, 3].pop(); <em>// -&gt; 3</em></pre>
<h4>履行</h4>
<pre>function pop(array) {
 const value = array[array.length - 1];

 array.length = array.length - 1;

 return value;
}</pre>
<p>首先，我们将数组的最后一个值保存在一个变量中。然后，我们简单地将数组的长度减一，结果删除了最后一个值。</p>
<pre>logOperation('pop', [1, 2, 3, 4, 5], array =&gt; pop(array));</pre>
<pre>{
  operation: 'pop',
  arrayBefore: [ 1, 2, 3, 4, 5 ],
  arrayAfter: [ 1, 2, 3, 4 ],
  mutates: true,
  result: 5
}</pre>

<p><code>push</code>方法让我们在数组末尾追加值。</p>
<pre>[1, 2, 3, 4].push(5); <em>// -&gt; [1, 2, 3, 4, 5]</em></pre>
<h4>履行</h4>
<pre>export function push(array, ...values) {
 const { length: arrayLength } = array;
 const { length: valuesLength } = values;

 for (let index = 0; index &lt; valuesLength; index += 1) {
   array[arrayLength + index] = values[index];
 }

 return array.length;
}</pre>
<p>首先，我们保存原始数组的长度，以及在它们各自的变量中要追加多少值。然后，我们迭代所提供的值，并将它们追加到原始数组中。</p>
<p>我们从<code>index = 0</code>开始循环，所以每一次迭代我们都把数组的长度加到<code>index</code>。这样，我们不会覆盖原始数组中的任何值，而是实际追加它们。</p>
<pre>logOperation('push', [1, 2, 3, 4, 5], array =&gt; push(array, 6, 7));</pre>
<pre>{
  operation: 'push',
  arrayBefore: [ 1, 2, 3, 4, 5 ],
  arrayAfter: [
    1, 2, 3, 4,
    5, 6, 7
  ],
  mutates: true,
  result: 7
}</pre>

<p>当我们想要用占位符值填充一个空数组时,<code>fill</code>方法很有用。如果我们想创建一个具有指定数量的<code>null</code>元素的数组，我们可以这样做:</p>
<pre>[...Array(5)].fill(null) <em>// -&gt; [null, null, null, null, null]</em></pre>
<h4>履行</h4>
<pre>function fill(array, value, startIndex = 0, endIndex = array.length) {
 for (let index = startIndex; index &lt;= endIndex; index += 1) {
   array[index] = value;
 }

 return array;
}</pre>
<p>所有的<code>fill</code>方法实际上只是在指定的索引范围内替换数组的值。如果未提供该范围，该方法将替换数组的所有值。</p>
<pre>logOperation('fill', [...new Array(5)], array =&gt; fill(array, 0));</pre>
<pre>{
  operation: 'fill',
  arrayBefore: [ undefined, undefined, undefined, undefined, undefined ],
  arrayAfter: [ 0, 0, 0, 0, 0 ],
  mutates: true,
  result: [ 0, 0, 0, 0, 0 ]
}</pre>
<h2>带发电机</h2>
<p>最后三种方法的特殊之处在于它们返回生成器的方式。如果您不熟悉生成器，可以跳过它们，因为您可能不会很快使用它们。</p>

<p><code>values</code>方法返回一个生成数组值的生成器。</p>
<pre>const valuesGenerator = values([1, 2, 3, 4, 5]);

valuesGenerator.next(); <em>// { value: 1, done: false }</em></pre>
<h4>履行</h4>
<pre>function values(array) {
 const { length } = array;

 function* createGenerator() {
   for (let index = 0; index &lt; length; index += 1) {
     const value = array[index];
     yield value;
   }
 }

 return createGenerator();
}</pre>
<p>首先，我们定义<code>createGenerator</code>函数。在其中，我们迭代数组并产生每个值。</p>

<p><code>keys</code>方法返回一个生成数组索引的生成器。</p>
<pre>const keysGenerator = keys([1, 2, 3, 4, 5]);

keysGenerator.next(); <em>// { value: 0, done: false }</em></pre>
<h4>履行</h4>
<pre>function keys(array) {
 function* createGenerator() {
   const { length } = array;

   for (let index = 0; index &lt; length; index += 1) {
     yield index;
   }
 }

 return createGenerator();
}</pre>
<p>实现是完全一样的，但是这一次，我们产生一个索引，而不是一个值。</p>

<p><code>entries</code>方法返回一个生成索引-值对的生成器。</p>
<pre>const entriesGenerator = entries([1, 2, 3, 4, 5]);

entriesGenerator.next(); <em>// { value: [0, 1], done: false }</em></pre>
<h4>履行</h4>
<pre>function entries(array) {
 const { length } = array;

 function* createGenerator() {
   for (let index = 0; index &lt; length; index += 1) {
     const value = array[index];
     yield [index, value];
   }
 }

 return createGenerator();
}</pre>
<p>同样的实现，但是现在我们将索引和值组合在一起，并在一个数组中生成它们。</p>
<h2>摘要</h2>
<p>有效地使用数组的方法是成为优秀开发人员的基础。熟悉他们内部错综复杂的运作是我所知道的最好的擅长方式。</p>
<p>注意:我没有在这里介绍<code>sort</code>和<code>toLocaleString</code>，因为它们的实现过于复杂，对我来说，对初学者来说太复杂了。我也没有讨论<code>copyWithin</code>，因为它从来没有被使用过——它绝对没有用。</p><div class="code-block code-block-27">
<div class="blog-plug inline-plug vanilla-javascript-cta"><h2>通过理解上下文，更容易地调试JavaScript错误</h2>
<p>调试代码总是一项单调乏味的任务。但是你越了解自己的错误，就越容易改正。</p>
<p>LogRocket 让你以新的独特的方式理解这些错误。我们的前端监控解决方案跟踪用户与您的JavaScript前端的互动，让您能够准确找出导致错误的用户行为。</p>
<a href="https://lp.logrocket.com/blg/javascript-signup" class="signup" target="_blank" rel="noopener noreferrer"><img class="alignnone size-full wp-image-46 jetpack-lazy-image" src="../Images/cbfed9be3defcb505e662574769a7636.png" alt="LogRocket Dashboard Free Trial Banner" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2020/06/reproduce-javascript-errors.gif?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/06/reproduce-javascript-errors.gif"/><noscript><img data-lazy-fallback="1" class="alignnone size-full wp-image-46" src="../Images/cbfed9be3defcb505e662574769a7636.png" alt="LogRocket Dashboard Free Trial Banner" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/06/reproduce-javascript-errors.gif"/></noscript></a>
<p>LogRocket记录控制台日志、页面加载时间、堆栈跟踪、慢速网络请求/响应(带有标题+正文)、浏览器元数据和自定义日志。理解您的JavaScript代码的影响从来没有这么简单过！</p>
<a class="signup" href="https://lp.logrocket.com/blg/javascript-signup" target="_blank" rel="noopener noreferrer">Try it for free</a><p>.</p></div>


</div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
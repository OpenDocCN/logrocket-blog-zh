<html>
<head>
<title>GraphQL vs. REST: What you didn’t know - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>GraphQL与REST:你所不知道的</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/graphql-vs-rest-what-you-didnt-know/#0001-01-01">https://blog.logrocket.com/graphql-vs-rest-what-you-didnt-know/#0001-01-01</a></blockquote><div><article class="article-post">
<h2>介绍</h2>
<p>近年来，GraphQL已经被API开发人员广泛采用。GraphQL灵活的查询语言、强类型模式、对客户端数据需求的关注、工具、社区和生态系统使其成为面向客户端的应用程序和API作者的绝佳选择。</p>
<p>开源工具和库的快速发展支持了不断增长的GraphQL社区，在这个阶段，GraphQL对于前端和后端开发人员来说都是一项需要理解的重要技术。</p>
<p>GraphQL通常是在与REST的比较中引入的，但在这一点上，这些比较非常常见，涵盖了GraphQL和REST之间的许多基本差异。本文不再重复这些观点，而是将重点放在GraphQL和REST之间一些更细微的差异上。</p>
<p>这里的信息应该对任何希望理解更高级主题的GraphQL初学者或考虑采用或迁移到GraphQL的团队有益。总的来说，本文将讨论三个主要话题:</p>
<ol>
<li>HTTP语义</li>
<li>请求错误</li>
<li>安全影响</li>
</ol>
<h2 id="http">REST直接利用HTTP</h2>
<h3>HTTP语义</h3>
<p>web服务的REST APIs倾向于构建在HTTP之上，并利用核心HTTP特性，例如<a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods" target="_blank" rel="noreferrer noopener"> HTTP请求方法</a>、<a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Status" target="_blank" rel="noreferrer noopener"> HTTP响应状态代码</a>和<a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Caching" target="_blank" rel="noreferrer noopener"> HTTP缓存</a>。</p>
<p>例如，想象一个典型的REST API端点<code>/user</code>。一个设计良好的REST API会有类似于<code>GET /user</code>、<code>POST /user</code>、<code>PUT /user</code>和<code>DELETE /user</code>的各种操作，分别对应于获取、创建、更新和删除一个用户资源。</p>
<p>这些语义用HTTP进行了标准化，并允许API用户从API获得可预测和可理解的行为。一个好的REST API将为它支持的各种资源重用这些语义，并且消费者应该很容易理解什么API请求对应于特定的资源操作。</p>
<p>相比之下，GraphQL提供了三种基本的模式类型:<code>Query</code>、<code>Mutation</code>和<code>Subscription</code>。获取数据被归入查询，而突变描述了创建、更改或删除数据的操作。</p>
<p>然而，这些操作的实现完全取决于GraphQL API的作者，并且该规范对资源如何建模没有任何限制。GraphQL的重点更多的是如何查询数据，而不是如何对资源建模。</p>
<p>GraphQL服务器可能会提供一个用户查询和相关的变异，比如<code>updateUser</code>、<code>deleteUser</code>等等。但是这些名字都很主观。也许用户查询被称为<code>getUser</code>或<code>fetchUser</code>，而不仅仅是<code>user</code>。也许更新操作叫做<code>changeUser</code>甚至<code>putUser</code>。在GraphQL API中，这些相关的“用户”操作并没有内在的联系。</p>
<p>GraphQL提供了很好的API文档和内置的可发现性，以及诸如模式自省和GraphQL接口之类的工具，但是您可以想象如何在一个具有几十或几百个已定义对象类型的GraphQL模式中更新一些资源是多么困难。</p>
<p>这比依赖HTTP动词(如<code>GET</code>、<code>PUT</code>和<code>POST</code>)要简单得多，这些动词都在单个资源端点上操作。再次强调，重要的是要记住，在实践中，REST APIs经常会偏离严格遵循HTTP，并且它并不总是像针对您正在寻找的特定操作使用特定的HTTP动词那样简单。</p>
<h3>贮藏</h3>
<p>REST APIs也可以充分利用<a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Caching" target="_blank" rel="noreferrer noopener" aria-label=" (opens in a new tab)"> HTTP缓存</a>。通常，web应用程序将返回带有响应数据的HTTP标头，这些标头向客户端提供有关如何缓存返回数据的信息。</p>
<p>现代浏览器附带了HTTP缓存实现，可以在HTTP层自动提供缓存。这允许应用程序缓存经常请求的资源，而无需在客户端代码中包含任何特定的逻辑。应用程序可以只查询资源，任何缓存的资源都应该立即返回。这对性能、用户体验和网络数据使用非常重要。</p>
<p>在GraphQL应用程序中，客户端请求都是HTTP POST请求，完全绕过了标准的HTTP缓存机制。正因为如此，GraphQL客户端应用程序倾向于使用像<a href="https://www.apollographql.com/" target="_blank" rel="noreferrer noopener"> Apollo </a>或<a href="https://facebook.github.io/relay/" target="_blank" rel="noreferrer noopener"> Relay </a>这样的GraphQL客户端库。这些库为被查询的数据提供了一种缓存机制，这种机制依赖于被查询对象类型的全局惟一id(更多关于GraphQL缓存的信息，请点击)。</p>
<p>这非常强大，但是需要开发人员做更多的工作才能获得缓存的全部好处。它还引入了一个新的表面错误，这可能很难跟踪和修复(<a href="https://kamranicus.com/posts/2018-03-06-graphql-apollo-object-caching" target="_blank" rel="noreferrer noopener">一个例子</a>)。这种额外的复杂性可能很难理解，并且可能会增加新工程师入职时听到的声音。</p>
<h2>响应错误</h2>
<h3>错误代码</h3>
<p>正如HTTP请求使用标准化的HTTP动词来描述不同类型的操作一样，HTTP提供了特定的失败代码来描述响应错误状态。例如，告诉任何开发人员一个状态代码为<code>401</code>、<code>404</code>或<code>500</code>的请求失败，他们会立即明白这意味着什么以及为什么请求失败(如果他们也知道状态代码为<code>418</code>会加分！).</p>
<p>此错误代码是response对象的一部分，可以被解析并用于以编程方式确定应用程序如何响应失败的请求。例如，<code>404</code>表示找不到资源，<code>401</code>表示用户无权执行他们请求的任何操作。</p>
<p>此外，每个HTTP请求都会明确地导致成功或失败状态。很明显，应用程序“知道”HTTP请求的结果。</p>
<p>然而，在GraphQL中，情况完全不同。首先，GraphQL查询可以映射到许多不同的解析函数，其中任何一个都可能失败。因此，响应可能同时部分成功，部分失败。例如，考虑这样一个GraphQL模式:</p>
<figure class="wp-block-image"><img data-attachment-id="3265" data-permalink="https://blog.logrocket.com/graphql-vs-rest-what-you-didnt-know/attachment/sample-graphql-schema/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2019/06/sample-graphql-schema.png" data-orig-size="1322,1168" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Sample GraphQL schema" data-image-description="" data-image-caption="&lt;p&gt;Sample GraphQL schema.&lt;/p&gt;&#10;" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2019/06/sample-graphql-schema-300x265.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2019/06/sample-graphql-schema-1024x905.png" decoding="async" class="wp-image-3265 jetpack-lazy-image" src="../Images/272e75c7ff6376f14a517eac6635a7a1.png" alt="Sample GraphQL Schema" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2019/06/sample-graphql-schema.png 1322w, https://blog.logrocket.com/wp-content/uploads/2019/06/sample-graphql-schema-300x265.png 300w, https://blog.logrocket.com/wp-content/uploads/2019/06/sample-graphql-schema-768x679.png 768w, https://blog.logrocket.com/wp-content/uploads/2019/06/sample-graphql-schema-1024x905.png 1024w" data-lazy-sizes="(max-width: 1322px) 100vw, 1322px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2019/06/sample-graphql-schema.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/06/sample-graphql-schema.png"/><noscript><img data-lazy-fallback="1" data-attachment-id="3265" data-permalink="https://blog.logrocket.com/graphql-vs-rest-what-you-didnt-know/attachment/sample-graphql-schema/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2019/06/sample-graphql-schema.png" data-orig-size="1322,1168" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Sample GraphQL schema" data-image-description="" data-image-caption="&lt;p&gt;Sample GraphQL schema.&lt;/p&gt;&#10;" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2019/06/sample-graphql-schema-300x265.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2019/06/sample-graphql-schema-1024x905.png" decoding="async" loading="lazy" class="wp-image-3265" src="../Images/272e75c7ff6376f14a517eac6635a7a1.png" alt="Sample GraphQL Schema" srcset="https://blog.logrocket.com/wp-content/uploads/2019/06/sample-graphql-schema.png 1322w, https://blog.logrocket.com/wp-content/uploads/2019/06/sample-graphql-schema-300x265.png 300w, https://blog.logrocket.com/wp-content/uploads/2019/06/sample-graphql-schema-768x679.png 768w, https://blog.logrocket.com/wp-content/uploads/2019/06/sample-graphql-schema-1024x905.png 1024w" sizes="(max-width: 1322px) 100vw, 1322px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/06/sample-graphql-schema.png"/></noscript><figcaption>Sample GraphQL schema.</figcaption></figure>
<p>以及对一些数据的查询:</p>
<figure class="wp-block-image"><img data-attachment-id="3266" data-permalink="https://blog.logrocket.com/graphql-vs-rest-what-you-didnt-know/attachment/sample-data-query/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2019/06/sample-data-query.png" data-orig-size="944,854" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Sample data query" data-image-description="" data-image-caption="&lt;p&gt;Sample data query.&lt;/p&gt;&#10;" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2019/06/sample-data-query-300x271.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2019/06/sample-data-query.png" decoding="async" class="wp-image-3266 jetpack-lazy-image" src="../Images/be09507f93ec1f8c98f48e2ab3e45b1a.png" alt="Sample Data Query" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2019/06/sample-data-query.png 944w, https://blog.logrocket.com/wp-content/uploads/2019/06/sample-data-query-300x271.png 300w, https://blog.logrocket.com/wp-content/uploads/2019/06/sample-data-query-768x695.png 768w" data-lazy-sizes="(max-width: 944px) 100vw, 944px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2019/06/sample-data-query.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/06/sample-data-query.png"/><noscript><img data-lazy-fallback="1" data-attachment-id="3266" data-permalink="https://blog.logrocket.com/graphql-vs-rest-what-you-didnt-know/attachment/sample-data-query/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2019/06/sample-data-query.png" data-orig-size="944,854" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Sample data query" data-image-description="" data-image-caption="&lt;p&gt;Sample data query.&lt;/p&gt;&#10;" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2019/06/sample-data-query-300x271.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2019/06/sample-data-query.png" decoding="async" loading="lazy" class="wp-image-3266" src="../Images/be09507f93ec1f8c98f48e2ab3e45b1a.png" alt="Sample Data Query" srcset="https://blog.logrocket.com/wp-content/uploads/2019/06/sample-data-query.png 944w, https://blog.logrocket.com/wp-content/uploads/2019/06/sample-data-query-300x271.png 300w, https://blog.logrocket.com/wp-content/uploads/2019/06/sample-data-query-768x695.png 768w" sizes="(max-width: 944px) 100vw, 944px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/06/sample-data-query.png"/></noscript><figcaption>Sample data query.</figcaption></figure>
<p>现在，假设查询对象<code>user</code>、<code>posts</code>和<code>comments</code>有不同的解析函数，并且<code>posts</code>和<code>comments</code>的解析器由于某种原因失败了。您将会收到如下响应数据:</p>
<figure class="wp-block-image"><img data-attachment-id="3267" data-permalink="https://blog.logrocket.com/graphql-vs-rest-what-you-didnt-know/attachment/partial-error-response/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2019/06/partial-error-response.png" data-orig-size="1322,1554" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Partial error response" data-image-description="" data-image-caption="&lt;p&gt;Partial error response.&lt;/p&gt;&#10;" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2019/06/partial-error-response-255x300.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2019/06/partial-error-response-871x1024.png" decoding="async" class="wp-image-3267 jetpack-lazy-image" src="../Images/cd598b057e0a709deb300c8efb85b77a.png" alt="Partial Error Response" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2019/06/partial-error-response.png 1322w, https://blog.logrocket.com/wp-content/uploads/2019/06/partial-error-response-255x300.png 255w, https://blog.logrocket.com/wp-content/uploads/2019/06/partial-error-response-768x903.png 768w, https://blog.logrocket.com/wp-content/uploads/2019/06/partial-error-response-871x1024.png 871w" data-lazy-sizes="(max-width: 1322px) 100vw, 1322px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2019/06/partial-error-response.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/06/partial-error-response.png"/><noscript><img data-lazy-fallback="1" data-attachment-id="3267" data-permalink="https://blog.logrocket.com/graphql-vs-rest-what-you-didnt-know/attachment/partial-error-response/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2019/06/partial-error-response.png" data-orig-size="1322,1554" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Partial error response" data-image-description="" data-image-caption="&lt;p&gt;Partial error response.&lt;/p&gt;&#10;" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2019/06/partial-error-response-255x300.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2019/06/partial-error-response-871x1024.png" decoding="async" loading="lazy" class="wp-image-3267" src="../Images/cd598b057e0a709deb300c8efb85b77a.png" alt="Partial Error Response" srcset="https://blog.logrocket.com/wp-content/uploads/2019/06/partial-error-response.png 1322w, https://blog.logrocket.com/wp-content/uploads/2019/06/partial-error-response-255x300.png 255w, https://blog.logrocket.com/wp-content/uploads/2019/06/partial-error-response-768x903.png 768w, https://blog.logrocket.com/wp-content/uploads/2019/06/partial-error-response-871x1024.png 871w" sizes="(max-width: 1322px) 100vw, 1322px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/06/partial-error-response.png"/></noscript><figcaption>Partial error response.</figcaption></figure>
<p>我们来看看发生了什么！整个查询没有失败。事实上，即使<code>user</code>查询失败，您也会得到类似的失败响应。整个响应返回HTTP状态代码<code>200</code>；HTTP层没有成败之分。</p>
<p>此外，对于GraphQL请求，没有整体成功或失败的感觉(除非请求与提供的模式不匹配或者存在网络错误)，因为一些对象可能被成功提取，而其他对象可能导致错误。</p>
<p>要开始理解请求的错误状态，您必须尝试直接解析响应数据。如果仔细观察，<code>errors</code>响应是一个对象数组，其中每个对象都包含一些关于失败的特定查询<code>path</code>的信息。</p>
<p>您将看到一个序列化的消息，其中包含一个原因，它只是一个字符串。确定特定查询是否失败以及失败的原因包括解析这个错误数组以及解析每个错误对象。</p><div class="code-block code-block-54">
<hr/>
<h3>更多来自LogRocket的精彩文章:</h3>

<hr/></div>
<p>您需要构建一些特定的逻辑来提取错误信息，并尝试确定失败的原因。提取状态代码或任何服务器发送的错误消息并不容易，因为GraphQL字符串将整个错误响应放入这个<code>message</code>字段。</p>
<p>与REST API相比，使用GraphQL跟踪这些不同的失败模式并为您的应用程序确定正确的结果并不简单，在REST API中，每个请求都有明确的成功或失败状态，如果失败，还有明确的失败原因。此外，GraphQL仍在发展，错误处理的故事很可能会随着时间的推移而改进。</p>
<h2>GraphQL安全影响</h2>
<h3>模式自省</h3>
<p>GraphQL向API消费者呈现了一个非常不同的API表面。例如，默认情况下，大多数GraphQL服务器实现都提供模式自省或信息性错误消息，例如:</p>
<pre>"message": "Cannot query field \"login\" on type \"Mutation\". Did you mean \"loginUser\"?",</pre>
<p>通过禁用自省等特性来混淆生产中的GraphQL模式，将使任何不良行为者更难理解如何针对您的API发出请求(同样，他们总是可以猜测或观察来自您的应用程序的网络流量，以理解您的API接受什么数据)。</p>
<p>这里另一个非常酷的模式是使用持久化查询，专门将应用程序使用的查询列入白名单，并将它们映射到某个哈希或键。然后，您的请求实际上提供了那个键，而不是查询名称本身。</p>
<p>此外，您的GraphQL服务器可以被设计为拒绝任何与白名单查询模式不匹配的查询。这减少了网络带宽的使用，并提高了应用程序的安全性，因为有人试图误用您的API，从而增加了很多摩擦。关于持久化查询的更多信息，您可以在这里<a href="https://blog.apollographql.com/persisted-graphql-queries-with-apollo-client-119fd7e6bba5" target="_blank" rel="noreferrer noopener"/>或者这里<a href="https://medium.com/@coreyclark/graphql-persisted-queries-using-get-requests-8a6704aba9eb" target="_blank" rel="noreferrer noopener"/>查看。</p>
<h3>限速</h3>
<p>通常，应用程序在每个用户、每个请求甚至每个IP的基础上限制API的速率，以控制使用并减少DDoS尝试或其他API误用。这对于传统的REST API来说相当简单。</p>
<p>但是，使用GraphQL，您可以在一个查询中对整个GraphQL模式发出一个请求。或者，您可以对相同的数据发出几个较小的请求。如何有效地限制这些不同的使用模式？</p>
<p>GraphQL的新兴实践是在每个对象或每个字段的基础上限制速率和/或使用查询成本/复杂性分析来实现速率限制。查询复杂性是一种静态分析查询的方法，用于确定服务器处理查询的复杂程度。</p>
<p>例如，在一次查询中请求几十个文档将比只查询一个文档更“复杂”。成本/复杂性可以通过查询深度、数量、限制(分页偏移量)等来衡量。这个想法是根据请求的复杂程度来限制请求的速率，而不是根据特定时间段内请求的数量。</p>
<p>已经有许多为此目的而设计的开源工具和库——例如，<code><a href="https://github.com/teamplanes/graphql-rate-limit" target="_blank" rel="noreferrer noopener">graphql-rate-limit</a></code>、<code><a href="https://github.com/pa-bru/graphql-cost-analysis" target="_blank" rel="noreferrer noopener">graphql-cost-analysis</a></code>、<code><a href="https://github.com/4Catalyzer/graphql-validation-complexity" target="_blank" rel="noreferrer noopener">graphql-validation-complexity</a></code>和<code><a href="https://github.com/slicknode/graphql-query-complexity" target="_blank" rel="noreferrer noopener">graphql-query-complexity</a></code>。</p>
<p>要了解这方面的更多信息，请看一下<a href="https://developer.github.com/v4/guides/resource-limitations/" target="_blank" rel="noreferrer noopener"> GitHub对其公共v4 API的资源限制</a>的描述，该API依赖于GraphQL。这是一个非常有趣的、真实的例子，说明了这个问题是如何处理的。</p>
<h3>DDoS攻击</h3>
<p>除了查询复杂性之外，现代web应用程序需要认识到的一个常见安全漏洞是分布式拒绝服务(DDoS)攻击，在这种攻击中，一个不良行为者协调许多机器对一个应用程序发出大量请求，以使系统离线。</p>
<p>其他服务器也存在这种漏洞，但是在GraphQL服务器的情况下，您的API模式可能会暴露潜在的复杂且昂贵的查询模式，这很容易使您的系统崩溃。想象一下对某个博客的查询，该博客的评论系统允许递归地回复评论，如下所示:</p>
<figure class="wp-block-image"><img data-attachment-id="3268" data-permalink="https://blog.logrocket.com/graphql-vs-rest-what-you-didnt-know/attachment/expensive-graphql-query/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2019/06/expensive-graphql-query.png" data-orig-size="924,994" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="A very expensive GraphQL query" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2019/06/expensive-graphql-query-279x300.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2019/06/expensive-graphql-query.png" decoding="async" class="wp-image-3268 jetpack-lazy-image" src="../Images/8f9cf3bff862475d00ea352d020838a3.png" alt="Expensive GraphQL Query" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2019/06/expensive-graphql-query.png 924w, https://blog.logrocket.com/wp-content/uploads/2019/06/expensive-graphql-query-279x300.png 279w, https://blog.logrocket.com/wp-content/uploads/2019/06/expensive-graphql-query-768x826.png 768w" data-lazy-sizes="(max-width: 924px) 100vw, 924px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2019/06/expensive-graphql-query.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/06/expensive-graphql-query.png"/><noscript><img data-lazy-fallback="1" data-attachment-id="3268" data-permalink="https://blog.logrocket.com/graphql-vs-rest-what-you-didnt-know/attachment/expensive-graphql-query/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2019/06/expensive-graphql-query.png" data-orig-size="924,994" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="A very expensive GraphQL query" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2019/06/expensive-graphql-query-279x300.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2019/06/expensive-graphql-query.png" decoding="async" loading="lazy" class="wp-image-3268" src="../Images/8f9cf3bff862475d00ea352d020838a3.png" alt="Expensive GraphQL Query" srcset="https://blog.logrocket.com/wp-content/uploads/2019/06/expensive-graphql-query.png 924w, https://blog.logrocket.com/wp-content/uploads/2019/06/expensive-graphql-query-279x300.png 279w, https://blog.logrocket.com/wp-content/uploads/2019/06/expensive-graphql-query-768x826.png 768w" sizes="(max-width: 924px) 100vw, 924px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/06/expensive-graphql-query.png"/></noscript><figcaption>A very expensive query.</figcaption></figure>
<p>并不是所有的GraphQL模式都会公开这样的查询，但是这种查询的计算和返回代价可能会非常高。一个坏人用一台机器就能发出几十个这样的请求，并有可能使您的系统瘫痪。</p>
<p>这将是一种独特而罕见的情况，但重要的是要意识到；攻击者肯定热衷于寻找这样的技巧。上面提到的方法，如通过查询成本限制速率或使用持久化查询，可以用来缓解类似这样的问题。<a href="https://blog.apollographql.com/securing-your-graphql-api-from-malicious-queries-16130a324a6b" target="_blank" rel="noreferrer noopener">本文</a>更深入地讨论了如何保护GraphQL应用程序。</p>
<h2>结论</h2>
<p>GraphQL采用了一种完全不同的API设计方法，带来了许多好处和优势，但也带来了独特的挑战和差异。GraphQL、REST或任何其他方法都没有好坏之分，但它们都有自己独特的设计考虑、约束和权衡。</p>
<p>在这里，我们看到了GraphQL和REST之间一些更高级的差异。我们讨论了HTTP语义、错误处理和安全含义，REST开发人员在采用GraphQL时可能会发现这些内容出乎意料。</p>
<p>希望本文有助于阐明GraphQL和REST之间的一些更微妙的差异，并能帮助您更好地理解在考虑任一选择时的权衡和妥协。</p><div class="code-block code-block-24">
<div class="blog-plug inline-plug graphql-plug"><h2>监控生产中失败和缓慢的GraphQL请求</h2><p>虽然GraphQL有一些调试请求和响应的特性，但确保GraphQL可靠地为您的生产应用程序提供资源是一件比较困难的事情。如果您对确保对后端或第三方服务的网络请求成功感兴趣，</p><a href="https://lp.logrocket.com/blg/graphql-signup" target="_blank">try LogRocket</a><p>.</p><a class="signup" href="https://lp.logrocket.com/blg/graphql-signup" target="_blank" rel="noopener noreferrer"><img src="../Images/432a3823c85b3fb72a206e6236a29f48.png" data-lazy-src="https://files.readme.io/69aa835-Image_2019-11-09_at_1.28.05_PM.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" class=" jetpack-lazy-image" data-original-src="https://files.readme.io/69aa835-Image_2019-11-09_at_1.28.05_PM.png"/><noscript><img data-lazy-fallback="1" src="../Images/432a3823c85b3fb72a206e6236a29f48.png" data-original-src="https://files.readme.io/69aa835-Image_2019-11-09_at_1.28.05_PM.png"/></noscript><img class="alignnone size-full wp-image-46 jetpack-lazy-image" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/><noscript><img data-lazy-fallback="1" class="alignnone size-full wp-image-46" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/></noscript></a><a href="https://lp.logrocket.com/blg/graphql-signup" target="_blank" rel="noopener noreferrer">https://logrocket.com/signup/</a><p>LogRocket 就像是网络和移动应用的DVR，记录下你网站上发生的每一件事。您可以汇总并报告有问题的GraphQL请求，以快速了解根本原因，而不是猜测问题发生的原因。此外，您可以跟踪Apollo客户机状态并检查GraphQL查询的键值对。</p><p>LogRocket检测您的应用程序以记录基线性能计时，如页面加载时间、到达第一个字节的时间、慢速网络请求，还记录Redux、NgRx和Vuex操作/状态。</p><a class="signup" href="https://lp.logrocket.com/blg/graphql-signup" target="_blank" rel="noopener noreferrer">Start monitoring for free</a><p>.</p></div>


</div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
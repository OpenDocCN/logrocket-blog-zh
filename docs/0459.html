<html>
<head>
<title>New and potential ES2019 JavaScript features every developer should be excited about - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>每个开发人员都应该为ES2019新的和潜在的JavaScript特性感到兴奋</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/new-es2019-javascript-features-every-developer-should-be-excited-about/#0001-01-01">https://blog.logrocket.com/new-es2019-javascript-features-every-developer-should-be-excited-about/#0001-01-01</a></blockquote><div><article class="article-post">
<p>自早期以来，JavaScript已经走过了漫长的道路，增加了许多新的内容和特性，旨在使这种语言更加用户友好，更加简洁。下面是一些我觉得很有趣的JavaScript新增内容。</p>
<p>其中一些功能已经在Node、Chrome、Firefox和Safari中可用，而其他功能仍处于提案阶段。</p>
<h2>可选链接</h2>
<p>使用<code>?.</code>操作符完成可选链接。它主要确保问号之前的值既不是未定义的也不是空的。这在评估深度嵌套对象的属性时非常有用。</p>
<p>在评估属性之前，需要确保<code>?.</code>操作符存在。</p>
<p>考虑下面的例子:</p>
<pre>const users = [
  {
   name: "Olagunju Gbolahan",
   occupation: "Software Developer",
   sayName(){
    console.log(`my name is ${this.name}`);
   },
   address: { office: "New York" }
  },
  { name: "Olawaseyi Moses" },
  { name: "Tunde Ednut" }
];</pre>
<p>让我们考虑用户数组中的第二个用户:</p>
<pre>const secondUser = users[1];</pre>
<p>我们可能想要得到这个用户的办公室地址。在可选的链接操作符出现之前，我们必须通过一个相对低效的过程来获取这些信息:</p>
<pre>const theAddress = secondUser.address &amp;&amp; secondUser.address.office;
console.log(theAddress); // undefined</pre>
<p>如果我们有一个深度嵌套的对象，我们必须在每一层使用<code>&amp;&amp;</code>操作符来检查它的值是否存在。</p>
<p>但是对于可选的链接，我们只需执行以下操作:</p>
<pre>const theAddress = secondUser?.address?.office;
console.log(theAddress); // undefined</pre>
<p>我们还可以对对象方法使用可选的链接，以在执行之前确认它们的存在:</p>
<pre>const firstUser = users[0];
console.log(firstUser.sayName?.()); // my name is Olagunju Gbolahan</pre>
<p>如果对象上不存在具有给定名称的方法，它将简单地返回<code>undefined</code>。</p>
<pre>console.log(firstUser.sayOccupation?.()); // undefined</pre>
<p>因为可选的链接操作符还没有被添加到JavaScript规范中，所以它仍然处于<a href="https://github.com/tc39/proposal-optional-chaining" target="_blank" rel="noopener noreferrer">提议阶段</a>。</p>
<p>你现在可以用<a href="https://babeljs.io/docs/en/babel-plugin-proposal-optional-chaining" target="_blank" rel="noopener noreferrer">babel-plugin-proposal-optional-chaining</a>插件使用它。</p>
<h2>可选catch绑定</h2>
<p>当我们预先知道我们的错误是什么，并且我们不想要多余的未使用的变量时，这个特性就派上了用场。</p>
<p>考虑传统的尝试和捕捉块:</p>
<pre>try {
  const parsedJsonData = JSON.parse(obj);
} catch (error) {
  //the variable error has to be declared whether used or unused
  console.log(obj);
}</pre>
<p>但是通过添加可选的catch绑定，我们不必提供未使用的变量——特别是当我们的try块有默认值时。</p>
<pre>function getName () {
  let name = "Gbolahan Olagunju";
  try {
    name = obj.details.name
  } catch {}
  console.log(name);
}</pre>
<h2>管道运营商</h2>
<p>这是Javascript的新增内容之一，目前处于第一阶段。</p>
<p>它本质上有助于使对同一个参数的几个函数调用可读。</p>
<p>它通过将表达式的值作为参数传递给函数来实现这一点。考虑在没有管道操作符<code>|&gt;</code>的情况下调用以下函数。</p>
<pre>const capitalize = (input) =&gt;  input[0].toUpperCase() + input.substring(1);
const removeSpaces = (input) =&gt; input.trim();
const repeat = (input) =&gt; `${input}, ${input}`;</pre>
<pre>const withoutpipe = repeat(capitalize(removeSpaces('    i am gbols    ')));
console.log(withoutpipe); // I am gbols, I am gbols</pre>
<p>但是使用管道操作符，可读性可以大大提高:</p>
<pre>const withpipe = '    i am gbols    '
                |&gt; removeSpaces
                |&gt; capitalize
                |&gt; repeat;
console.log(withpipe); // // I am gbols, I am gbols</pre>
<h2>String.trimStart和String.trimEnd</h2>
<p>这正式命名为trimRight和trimLeft，但在ES2019中，这些名称被更改为别名trimStart和trimEnd，以使用户更直观。</p>
<p>考虑下面的例子:</p>
<pre>let message = "     Welcome to LogRocket      ";
message.trimStart(); // "Welcome to LogRocket      "
message.trimEnd(); // "Welcome to LogRocket";</pre>
<h2>对象. fromEntries</h2>
<p>在讨论Object.fromEntries之前，先讨论Object.entries是很重要的。</p>
<p>ES2017规范中添加了Object.entries方法，以提供一种将对象转换为其等效数组的方法，从而授予其访问所有数组方法进行处理的权限。</p>
<p>考虑以下对象:</p>
<pre>const devs = {
  gbols: 5,
  andrew: 3,
  kelani: 10,
  dafe: 8,
};
const arrOfDevs = Object.entries(devs);
console.log(arrOfDevs);
//[
//  ["gbols", 5]
//  ["andrew", 3]
//  ["kelani", 10]
//  ["dafe", 8]
//]</pre>
<p>现在，我们可以在阵列上使用<code>filter</code>方法来获取具有5年以上经验的开发人员:</p>
<pre>const expDevs = arrOfDevs.filter(([name, yrsOfExp]) =&gt; yrsOfExp &gt; 5);
console.log(expDevs);
//[
//  ["kelani", 10]
//  ["dafe", 8]
//]</pre>
<p>于是问题出现了:没有简单的方法将结果转换回对象。通常，我们会编写自己的代码将它转换回对象:</p>
<pre>const expDevsObj = {};
for (let [name, yrsOfExp] of expDevs) {
expDevsObj[name] = yrsOfExp;
}
console.log(expDevsObj);
//{
 //dafe: 8
 //kelani: 10
//}</pre>
<p>但是随着Object.fromEntries的引入，我们可以通过一次滑动来实现这一点:</p>
<pre>console.log(Object.fromEntries(expDevs));
//{
 //dafe: 8
 //kelani: 10
//}</pre>
<h2>平的</h2>
<p>通常，由于API调用，我们需要处理深度嵌套的数组。在这种情况下，展平数组就显得尤为重要。</p>
<p>考虑下面的例子:</p>
<pre>const developers = [
  {
    name: 'Gbolahan Olagunju',
    yrsOfExp: 6,
    stacks: ['Javascript', 'NodeJs', ['ReactJs', ['ExpressJs', 'PostgresSql']]]
  },
  {
    name: 'Daniel Show',
    yrsOfExp: 2,
    stacks: ['Ruby', 'Jest', ['Rails', ['JQuery', 'MySql']]]
  },
  {
    name: 'Edafe Emunotor',
    yrsOfExp: 9,
    stacks: ['PHP', 'Lumen', ['Angular', 'NgRx']]
  }
];</pre>
<pre>const allStacks = developers.map(({stacks}) =&gt; stacks);
console.log(allStacks);
// [
// ['Javascript', 'NodeJs', ['ReactJs', ['ExpressJs', 'PostgresSql']]]
// ['Ruby', 'Jest', ['Rails', ['JQuery', 'MySql']]]
// ['PHP', 'Lumen', ['Angular', 'NgRx']]
// ]</pre>
<p><code>allstacks</code>变量包含深度嵌套的数组。要展平这个数组，我们可以使用Array.prototype.flat。</p>
<p>方法如下:</p>
<pre>const flatSingle = allStacks.flat();
console.log(flatSingle);
//[
// "JavaScript",
//  "NodeJs",
// ['ReactJs', ['ExpressJs', 'PostgresSql']]]
// "Ruby",
// "Jest",
// ['Rails', ['JQuery', 'MySql']]]
// "PHP",
// "Lumen"
// ["Angular", "NgRx"]
//]</pre>
<p>从上面我们可以推断出，数组已经扁平化了一级，这是array.prototype.flat的默认参数。</p><div class="code-block code-block-54">
<hr/>
<h3>更多来自LogRocket的精彩文章:</h3>

<hr/></div>
<p>我们可以向flat方法传递一个参数，以确定我们想要展平的程度。</p>
<p>defaults参数的值为1。为了完全展平数组，我们可以传递一个无穷大的参数。<code>Infinity</code>参数完全展平数组，而不管数组的深度。</p>
<p>方法如下:</p>
<pre>const completelyFlat = allStacks.flat(Infinity);
console.log(completelyFlat);
//[
// "JavaScript",
// "NodeJs",
// "ReactJs",
// "ExpressJs",
// "PostgresSql",
// "Ruby",
// "Jest",
// "Rails",
// "JQuery",
// "MySql",
// "PHP",
// "Lumen",
// "Angular",
// "NgRx"
//]</pre>
<h2>平面地图</h2>
<p>FlatMap是调用深度为1的Map方法和flat方法的组合。它通常非常有用，因为它以非常高效的方式做同样的事情。</p>
<p>下面是一个同时使用map和flatMap的简单示例:</p>
<pre>let arr = ['my name is Gbols', ' ', 'and i am great developer']; 
console.log(arr.map(word =&gt; word.split(' ')));
//[
// ["my", "name", "is", "Gbols"],
// ["", ""],
// ["and", "i", "am", "great", "developer"]
//]</pre>
<pre>console.log(arr.flatMap(word =&gt; word.split(' ')));
//[ "my"
//  "name"
//  "is"
//  "Gbols"
//   ""
//   ""
//   "and"
//   "i"
//   "am"
//   "great"
//   "developer"
//]</pre>
<div class="inline-plug cro18">
<h2>实现新的JS特性？了解JavaScript错误如何影响用户。</h2>
<p>追踪生产JavaScript异常或错误的原因是耗时且令人沮丧的。如果您对监控JavaScript错误感兴趣，并想看看它们是如何影响用户的，<a href="https://logrocket.com/signup/">试试LogRocket </a>。<a class="signup" href="https://logrocket.com/signup/" target="_blank" rel="noopener noreferrer"><img data-attachment-id="46" data-permalink="https://blog.logrocket.com/vuex-showdown-mutations-vs-actions/1d0cd-1s_rmyo6nbrasp-xtvbaxfg/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg-e1565635879164.png" data-orig-size="730,412" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="LogRocket dashboard free trial banner" data-image-description="&lt;p&gt;LogRocket is working on the perfect frontend bug report. Try it free today.&lt;/p&gt;&#10;" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg-e1565635879164.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg-e1565635879164.png" decoding="async" class="alignnone size-full wp-image-46 jetpack-lazy-image" src="../Images/e8a0ab42befa3b3b1ae08c1439527dc6.png" alt="LogRocket Dashboard Free Trial Banner" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2019/10/errors-screenshot.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/10/errors-screenshot.png"/><noscript><img data-lazy-fallback="1" data-attachment-id="46" data-permalink="https://blog.logrocket.com/vuex-showdown-mutations-vs-actions/1d0cd-1s_rmyo6nbrasp-xtvbaxfg/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg-e1565635879164.png" data-orig-size="730,412" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="LogRocket dashboard free trial banner" data-image-description="&lt;p&gt;LogRocket is working on the perfect frontend bug report. Try it free today.&lt;/p&gt;&#10;" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg-e1565635879164.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg-e1565635879164.png" decoding="async" class="alignnone size-full wp-image-46" src="../Images/e8a0ab42befa3b3b1ae08c1439527dc6.png" alt="LogRocket Dashboard Free Trial Banner" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/10/errors-screenshot.png"/></noscript></a><a href="https://logrocket.com/signup/" target="_blank" rel="noopener noreferrer">https://logrocket.com/signup/</a></p>
<p>LogRocket 就像是网络应用的DVR，记录下你网站上发生的每一件事。LogRocket使您能够聚合和报告错误，以查看它们发生的频率以及它们影响了多少用户群。您可以轻松地重放发生错误的特定用户会话，以查看导致错误的用户操作。</p>
<p>LogRocket让你的应用程序记录带有标题+正文的请求/响应，以及关于用户的上下文信息，以全面了解问题。它还记录页面上的HTML和CSS，甚至可以重建最复杂的单页面应用程序的像素级完美视频。</p>
<p>增强您的JavaScript错误监控能力–––<a class="signup" href="https://logrocket.com/signup/" target="_blank" rel="noopener noreferrer">开始免费监控</a>。</p>
</div>
<h2>结论</h2>
<p>在本文中，我们列举了JavaScript新增功能的诸多好处。这些增加通过减少冗长和增加可读性来增强开发人员的体验。</p>
<p>下面，看看我们没有提到的几个新特性:<br/><a href="https://github.com/tc39/proposal-well-formed-stringify" target="_blank" rel="noopener noreferrer">JSON . stringify</a><br/><a href="https://tc39.es/ecma262/#sec-array.prototype.sort" target="_blank" rel="noopener noreferrer">排序稳定性</a></p>

<p class="clearfix"/>
<p class="clearfix"/>
</article>
 
</div>    
</body>
</html>
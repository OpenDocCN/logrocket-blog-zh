<html>
<head>
<title>UI testing using QA Wolf - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>使用QA Wolf - LogRocket博客进行UI测试</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/ui-testing-using-qa-wolf/#0001-01-01">https://blog.logrocket.com/ui-testing-using-qa-wolf/#0001-01-01</a></blockquote><div><article class="article-post">
<h2>介绍</h2>
<p>我们都知道，确保我们不仅编写了高质量、简洁、可维护的代码，而且创建了与所有产品需求保持一致的特性，这些特性不会在开发人员忽略的新场景开始时中断，这是多么重要。在过去的二十年里，这就是测试驱动开发方法为自己赢得了一个好名字的地方。对于外行来说，总结一下TDD，它是我们在开发任何新特性时遵循这些步骤的地方:</p>
<ul>
<li>创建一个我们希望在开发特性时通过的新测试</li>
<li>运行所有测试，查看新添加的测试是否失败</li>
<li>根据需求对功能进行编码</li>
<li>再次运行测试，查看失败的测试现在是否通过</li>
</ul>
<p><img data-attachment-id="25450" data-permalink="https://blog.logrocket.com/ui-testing-using-qa-wolf/attachment/tdd/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/09/tdd.png" data-orig-size="730,409" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="tdd" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/09/tdd-300x168.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/09/tdd.png" decoding="async" class="aligncenter size-full wp-image-25450 jetpack-lazy-image" src="../Images/6f954a09323ebc89f9db31ca3069013a.png" alt="test driven development methodology " data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2020/09/tdd.png 730w, https://blog.logrocket.com/wp-content/uploads/2020/09/tdd-300x168.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2020/09/tdd.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/09/tdd.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="25450" data-permalink="https://blog.logrocket.com/ui-testing-using-qa-wolf/attachment/tdd/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/09/tdd.png" data-orig-size="730,409" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="tdd" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/09/tdd-300x168.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/09/tdd.png" decoding="async" loading="lazy" class="aligncenter size-full wp-image-25450" src="../Images/6f954a09323ebc89f9db31ca3069013a.png" alt="test driven development methodology " srcset="https://blog.logrocket.com/wp-content/uploads/2020/09/tdd.png 730w, https://blog.logrocket.com/wp-content/uploads/2020/09/tdd-300x168.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/09/tdd.png"/></noscript>
<p>虽然这对于开发REST APIs(具有强大的预定义契约)来说效果很好，但是当我们试图将其应用于UI开发时，效果就不那么好了。这有几个原因，尽管最突出的一个原因是UI测试主要分为两类:</p>
<ul>
<li>对于渲染页面上的任何动作元素(如按钮)，模拟其上的动作(点击),并检查特定的动作处理程序(点击监听器)是否被触发，或者是否达到特定的UI状态(也称为功能测试)</li>
<li>无论渲染了什么，检查它和最后渲染的东西(DOM树)之间是否有任何差异(也称为快照测试)。上面提到的几点使得在UI开发中遵循TDD方法变得困难，因为在开始UI开发之前，没有任何东西可以在“之上”编写测试。此外，为了测试单击按钮时发生的任何行为，我们首先需要从呈现的DOM中获取按钮元素。这一点，以及为了开始测试通常必须编写的大量样板代码，使得测试UI的障碍如此之高，以至于很多时候，它被完全忽略了。这就是像<a href="https://www.qawolf.com/"> QA wolf </a>这样的框架派上用场的地方</li>
</ul>
<h2>什么是QA狼？</h2>
<p>QA Wolf是一个承诺简化用户界面测试过程的工具。正如前面所讨论的，编写UI测试的困难部分是模拟用户动作以达到我们实际想要断言的状态，这正是QA wolf为我们简化的部分。根据QA Wolf主页，它将我们的动作转换为playright/Jest代码，而无需编写任何样板文件。这是因为QA Wolf使用chromium浏览器实例和puppeteer来实际运行我们的UI代码以及捕获UI交互，以便自动生成测试。该框架还设置了许多安全网，负责所有必要的日常工作，例如:</p>
<ul>
<li>在运行任何测试之前，等待页面完全加载</li>
<li>选择尽可能好的元素选择器来准确地挑选正确的元素</li>
</ul>
<p><img data-attachment-id="25453" data-permalink="https://blog.logrocket.com/ui-testing-using-qa-wolf/attachment/qawolf/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/09/qawolf.png" data-orig-size="730,409" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="qawolf" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/09/qawolf-300x168.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/09/qawolf.png" decoding="async" class="aligncenter size-full wp-image-25453 jetpack-lazy-image" src="../Images/d783bbf7a5b27444327029cbe20c123f.png" alt="QA wolf methodology " data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2020/09/qawolf.png 730w, https://blog.logrocket.com/wp-content/uploads/2020/09/qawolf-300x168.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2020/09/qawolf.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/09/qawolf.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="25453" data-permalink="https://blog.logrocket.com/ui-testing-using-qa-wolf/attachment/qawolf/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/09/qawolf.png" data-orig-size="730,409" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="qawolf" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/09/qawolf-300x168.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/09/qawolf.png" decoding="async" loading="lazy" class="aligncenter size-full wp-image-25453" src="../Images/d783bbf7a5b27444327029cbe20c123f.png" alt="QA wolf methodology " srcset="https://blog.logrocket.com/wp-content/uploads/2020/09/qawolf.png 730w, https://blog.logrocket.com/wp-content/uploads/2020/09/qawolf-300x168.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/09/qawolf.png"/></noscript>
<p>通过使用交互式REPL来试验断言、选择器和定制代码，它还允许更高级别的定制。不仅如此，QA Wolf还帮助测试用例的CI集成以及跨浏览器测试，这是UI测试的另一个难点。</p>
<h2>QA Wolf入门</h2>
<p>让我们开始吧，将QA Wolf集成到React项目中，看看它实际上有多简单。你可以在GitHub上查看这个<a href="https://github.com/kokanek/web-socket-chat" target="_blank" rel="noopener noreferrer">库</a>,然后用它来玩QA Wolf。这是一个基于网络套接字的聊天客户端/服务器项目。我们将使用React开发的客户端来测试这个框架。因此，以下是开始的步骤。按照Github页面上提到的步骤，确保首先启动客户端和服务器。</p>
<ul>
<li>转到<strong> webServerClient </strong>文件夹，运行<code>npm init qawolf</code>命令。您将被要求指定创建测试的目录。选择了<code>.qawolf</code></li>
<li>QA Wolf init完成后，运行命令<code>npx qawolf create url first</code>来创建您的第一个测试。其中URL应该替换为客户端URL，即<a href="http://localhost:1992" target="_blank" rel="noopener noreferrer"> http://localhost:1992 </a>，这样命令就变成了<code>npx qawolf create <a href="http://localhost:1992" rel="nofollow">http://localhost:1992</a> first</code></li>
<li>现在，在CLI中，您将看到一个等待输入的提示，显示<code>QA Wolf is ready to create code!</code>，选择<em>保存并退出</em>。只需按回车键，测试用例就会被创建</li>
</ul>
<p><img data-attachment-id="25457" data-permalink="https://blog.logrocket.com/ui-testing-using-qa-wolf/attachment/screen1/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/09/screen1.png" data-orig-size="1094,202" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="screen1" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/09/screen1-300x55.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/09/screen1-1024x189.png" decoding="async" class="aligncenter size-full wp-image-25457 jetpack-lazy-image" src="../Images/146bcf010863f4d0228d22eb8035a785.png" alt="Terminal with words &quot;QA wolf is ready to create code! Edit your code at .qawolf//first.test.js: Save and Exit, Open REPL to run code, discard and exit" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2020/09/screen1.png 1094w, https://blog.logrocket.com/wp-content/uploads/2020/09/screen1-300x55.png 300w, https://blog.logrocket.com/wp-content/uploads/2020/09/screen1-1024x189.png 1024w, https://blog.logrocket.com/wp-content/uploads/2020/09/screen1-768x142.png 768w" data-lazy-sizes="(max-width: 1094px) 100vw, 1094px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2020/09/screen1.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/09/screen1.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="25457" data-permalink="https://blog.logrocket.com/ui-testing-using-qa-wolf/attachment/screen1/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/09/screen1.png" data-orig-size="1094,202" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="screen1" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/09/screen1-300x55.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/09/screen1-1024x189.png" decoding="async" loading="lazy" class="aligncenter size-full wp-image-25457" src="../Images/146bcf010863f4d0228d22eb8035a785.png" alt="Terminal with words &quot;QA wolf is ready to create code! Edit your code at .qawolf//first.test.js: Save and Exit, Open REPL to run code, discard and exit" srcset="https://blog.logrocket.com/wp-content/uploads/2020/09/screen1.png 1094w, https://blog.logrocket.com/wp-content/uploads/2020/09/screen1-300x55.png 300w, https://blog.logrocket.com/wp-content/uploads/2020/09/screen1-1024x189.png 1024w, https://blog.logrocket.com/wp-content/uploads/2020/09/screen1-768x142.png 768w" sizes="(max-width: 1094px) 100vw, 1094px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/09/screen1.png"/></noscript>
<p>您会注意到在<code>webSocketClient</code>目录中创建了一个<code>.qawolf</code>文件夹。在目录中，查找名为<code>first.test.js</code>的文件。它应具有以下功能:</p>
<pre>test("first", async () =&gt; {
  await page.goto("http://localhost:1992");
  await qawolf.create();
});
</pre>
<p>这就对了。我们创造了第一个测试。</p>
<ul>
<li>运行命令<code>npx qawolf test</code>就这样。您的第一个测试用例被执行。尽管我们在技术上没有断言任何东西，但它仍然是一个测试案例</li>
</ul>
<p><img data-attachment-id="25460" data-permalink="https://blog.logrocket.com/ui-testing-using-qa-wolf/attachment/testpassed/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/09/testpassed.png" data-orig-size="518,232" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="testpassed" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/09/testpassed-300x134.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/09/testpassed.png" decoding="async" class="aligncenter size-full wp-image-25460 jetpack-lazy-image" src="../Images/f358467ffcbfe0896585f88fc641b4a8.png" alt="passed .qawolf/first.test.js" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2020/09/testpassed.png 518w, https://blog.logrocket.com/wp-content/uploads/2020/09/testpassed-300x134.png 300w" data-lazy-sizes="(max-width: 518px) 100vw, 518px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2020/09/testpassed.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/09/testpassed.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="25460" data-permalink="https://blog.logrocket.com/ui-testing-using-qa-wolf/attachment/testpassed/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/09/testpassed.png" data-orig-size="518,232" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="testpassed" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/09/testpassed-300x134.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/09/testpassed.png" decoding="async" loading="lazy" class="aligncenter size-full wp-image-25460" src="../Images/f358467ffcbfe0896585f88fc641b4a8.png" alt="passed .qawolf/first.test.js" srcset="https://blog.logrocket.com/wp-content/uploads/2020/09/testpassed.png 518w, https://blog.logrocket.com/wp-content/uploads/2020/09/testpassed-300x134.png 300w" sizes="(max-width: 518px) 100vw, 518px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/09/testpassed.png"/></noscript>
<p>恭喜你！我们的第一次QA Wolf测试已经通过。</p>
<h2>创建我们第一个有意义的测试</h2>
<p>既然我们已经熟悉了QA Wolf的工作方式，让我们进入第一个有意义的测试设置。这里有一个我们想要测试的场景:</p>
<ul>
<li>调出聊天客户端界面</li>
<li>键入聊天用户名，然后按enter键登录</li>
<li>检查聊天用户名是否保存在状态中</li>
</ul>
<p>从QA wolf测试方法中可以明显看出，我们知道QA Wolf会为我们处理前两步，我们只需要担心第三步。因此，让我们用下面的命令创建一个新的测试:</p>
<pre>npx qawolf create http://localhost:1992 verify_username</pre>
<p>测试开始后，我们在输入字段中输入文本“Bob ”,然后按回车键。在下一个屏幕上，我们看到了<code>WebSocket Chat: Bob</code>，其中<code>Bob</code>是我们输入的用户名。一旦发生这种情况，关闭浏览器，<em>保存并退出</em>测试。</p>
<p>我们看到一个名为<code>verify_username.test.js</code>的新文件被创建，测试通过以下步骤创建:</p>
<pre>test("verify_username", async () =&gt; {
  await page.goto("http://localhost:1992/");
  await page.click(".ant-input");
  await page.fill(".ant-input", "Bob");
  await page.press(".ant-input", "Enter");
});

</pre>
<p>现在，让我们添加验证用户名是否被添加到标题的步骤，为此，将这一行添加到测试<code>await qawolf.assertElementText(page, '#main-heading', 'Bob', { timeout: 3000 })</code>。<code>qawolf.assertElementText</code> API检查带有提供的选择器的元素是否包含文本(<code>Websocket Chat: Bob</code>包含文本Bob)并且我们的测试用例通过。</p>
<pre>test("verify_username", async () =&gt; {
  await page.goto("http://localhost:1992/");
  await page.click(".ant-input");
  await page.fill(".ant-input", "Bob");
  await page.press(".ant-input", "Enter");
  await qawolf.assertElementText(page, '#main-heading', 'Bob', { timeout: 3000 });
});
</pre>
<p>为了检查测试是否工作，使用命令<br/> <code>npx qawolf test verify_username</code>运行测试，测试通过。要使测试失败，只需将<code>assertElementText</code>中的文本<code>Bob</code>改为Alice，然后再次运行测试。显然，它失败了。</p>
<p>还要注意，在创建的<code>verify_username.test.js</code>文件中，浏览器和页面实例与它们的木偶师相似，因为QA Wolf在木偶师之上工作。所以，你可以参考这个关于<a href="https://pptr.dev/#?product=Puppeteer&amp;version=v5.2.1&amp;show=api-class-browser" target="_blank" rel="noopener noreferrer">浏览器</a>和<a href="https://pptr.dev/#?product=Puppeteer&amp;version=v5.2.1&amp;show=api-class-page" target="_blank" rel="noopener noreferrer">页面</a>的文档，尝试不同的可用API。例如，获取一个渲染页面的截图就像添加这一行代码<code>await page.screenshot({path: 'screenshot.png'})</code>一样简单，并且您会得到一个保存在项目文件夹中的<code>screenshot.png</code>。</p>
<h2>使用QA Wolf进行快照测试</h2>
<p>这是关于行为/单元测试的部分。但是，在我们的用例中，我们想要类似这样的东西:</p>
<ul>
<li>在执行几次交互后，在UI中达到特定的状态</li>
<li>捕获整个呈现的用户界面</li>
<li>下次运行测试时，执行相同的步骤</li>
<li>捕获新呈现的用户界面</li>
<li>将当前呈现的用户界面与以前的进行比较</li>
</ul>
<p>上面列出的用例称为快照测试，这也是测试UI时常用的技术之一。让我们看看如何使用QA Wolf实现同样的功能。</p>
<p>创建新的测试并执行以下步骤:</p>
<ol>
<li><code>npx qawolf create <a href="http://localhost:1992" rel="nofollow">http://localhost:1992</a> snapshot</code></li>
<li>输入用户名Bob，点击<em>登录</em></li>
<li>输入消息<em>嘿！</em>并按下<em>进入</em>，你会在屏幕上看到信息</li>
<li>输入另一条消息<em>你好！</em>并按下<em>再次输入</em></li>
<li>保存并关闭测试</li>
</ol>
<p>您可以看到一个名为<code>snapshot.test.js</code>的新文件，其内容如下:</p>
<pre>test("snapshot", async () =&gt; {  
  await page.goto("http://localhost:1992/");
  await page.click(".ant-input");
  await page.fill(".ant-input", "Bob");
  await page.press(".ant-input", "Enter");
  await page.click(".ant-input");
  await page.fill(".ant-input", "Hey!");
  await page.press(".ant-input", "Enter");
  await page.fill(".ant-input", "Hi there!");
  await page.press(".ant-input", "Enter");
}
</pre>
<p>在最后添加这两行来捕获快照:</p>
<pre>const hits = await page.$('#messages');
expect(await hits.evaluate((node) =&gt; node.outerHTML)).toMatchSnapshot();
</pre>
<p>这些行所做的事情非常简单。我们首先从页面中获取带有消息ID的元素，并对该节点的内容进行快照。</p>
<p>使用命令<code>npx qawolf test snapshot</code>运行这个快照测试，您应该看到用所需的快照创建了一个<code>__snapshots__</code>文件夹。</p>
<p>下次我们再次运行测试时，QA Wolf执行与发送这些消息完全相同的步骤，再次拍摄快照，并在呈现的输出不同时警告我们。</p>
<p>如果我们想测试它，我们可以很容易地在第65行的<code>src/index.js</code>中添加一个冒号(<code>:</code>)，就像这样:</p>
<pre>title={message.user+":"}
</pre>
<p>用<code>npx qawolf test snapshot</code>再次运行测试。这一次，快照失败，同时突出显示在两个消息中显示的用户名添加了一个冒号。</p>
<h2>选择器特异性和QA Wolf</h2>
<p>如前所述，我们创建了一个测试用例来验证登录用户的名字是否被附加到标题上。在该测试用例的第二行中，我们用代码行<code>await page.click(".ant-input");</code>模拟了对<em>输入字段</em>的点击</p>
<p>代码只是要求点击页面中类名为<code>ant-input</code>的元素，结果是搜索(文本输入)字段。但是，如果我们将CSS ID应用到输入字段会怎么样呢？让我们试试那个。打开<code>src/index.js</code>并导航到第84行的搜索组件。只需向组件添加一个ID，使其看起来像这样:</p>
<pre>&lt;Search
   id="username"
   placeholder="Enter Username"
   enterButton="Login"
   size="large"
   onSearch={value =&gt; this.setState({ isLoggedIn: true, userName: value })}
/&gt;
</pre>
<p>现在，运行命令来创建一个新的测试用例:</p>
<pre>npx qawolf create http://localhost:1992 test_add_id</pre>
<p>并按照步骤创建一个测试。这一次，<code>.qawolf</code>文件夹中的<code>test_add_id.test.js</code>看起来像这样:</p>
<pre>test("test_add_id", async () =&gt; {
  await page.goto("http://localhost:1992/");
  await page.click("#username");
  await page.fill("#username", "Bob");
  await page.press("#username", "Enter");
});
</pre>
<p>注意第2行生成的代码被替换为<code>await page.click("#username");</code>，它现在检查一个更具体的标识符(<code>a CSS id</code>)而不是一个通用的标识符(<code>a CSS class</code>)。这就是QA Wolf默认为我们做的事情。它挑选出最合适的、特定的标识符，以便我们的测试正确运行。</p>
<h2>其他显著特征</h2>
<p>除了选择器特性和带有文本比较和快照的断言之外，还有一些其他显著的特性可以帮助我们浏览开发过程中遇到的日常场景。这个<a href="https://docs.qawolf.com/docs/api/qawolf/create" target="_blank" rel="noopener noreferrer"> API页面</a>把它们都列出来了。它们包括:</p>
<ul>
<li>让我们将页面的当前状态(cookies、localStorage、sessionStorage)保存到指定的JSON文件中</li>
<li>让我们通过从指定的JSON文件中读取来设置页面的当前状态。<code>saveState</code>和<code>setState</code>一起让我们在运行测试时处理诸如会话管理之类的事情，<a href="https://docs.qawolf.com/docs/handle_sign_in" target="_blank" rel="noopener noreferrer">下面是</a>的做法</li>
<li>如果我们想要修改测试用例的设置，API调用允许我们添加到一个已经存在的测试用例中</li>
<li>这让我们可以根据索引等待任何其他页面</li>
<li><code>scroll</code>它通过指定<code>x</code>值和<code>y</code>值来帮助我们模拟某个元素的滚动</li>
</ul>
<h2>结论</h2>
<p>QA Wolf是一个工具，通过在内部运行Chromium和Puppeteer来帮助我们减轻与设置UI测试相关的焦虑。通过与UI交互来创建测试用例，然后在生成的用户界面的任何部分进行断言，听起来像是进行UI测试的自然方法。如果你过去使用过复杂的UI测试框架，现在正在寻找更无缝的体验，QA Wolf绝对值得一试。</p><div class="code-block code-block-2">
<div class="blog-plug base-cta"><h2>使用<a class="signup" href="https://lp.logrocket.com/blg/signup" target="_blank" rel="noopener noreferrer"> LogRocket </a>消除传统错误报告的干扰</h2>
<a href="https://lp.logrocket.com/blg/signup" class="signup" target="_blank" rel="noopener noreferrer"><img class="alignnone size-full wp-image-46 jetpack-lazy-image" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/><noscript><img data-lazy-fallback="1" class="alignnone size-full wp-image-46" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/></noscript></a>
<p><a href="https://lp.logrocket.com/blg/signup" target="_blank" rel="noopener noreferrer"> LogRocket </a>是一个数字体验分析解决方案，它可以保护您免受数百个假阳性错误警报的影响，只针对几个真正重要的项目。LogRocket会告诉您应用程序中实际影响用户的最具影响力的bug和UX问题。</p>
<p>然后，使用具有深层技术遥测的会话重放来确切地查看用户看到了什么以及是什么导致了问题，就像你在他们身后看一样。</p>
<p>LogRocket自动聚合客户端错误、JS异常、前端性能指标和用户交互。然后LogRocket使用机器学习来告诉你哪些问题正在影响大多数用户，并提供你需要修复它的上下文。</p>
<p>关注重要的bug—<a class="signup" href="https://lp.logrocket.com/blg/signup-issue-free" target="_blank" rel="noopener noreferrer">今天就试试LogRocket】。</a></p></div></div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
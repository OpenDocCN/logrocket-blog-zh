<html>
<head>
<title>Crafting build pipelines with Docker - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>用Docker - LogRocket博客制作管道</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/crafting-build-pipelines-with-docker/#0001-01-01">https://blog.logrocket.com/crafting-build-pipelines-with-docker/#0001-01-01</a></blockquote><div><article class="article-post">
<p>大家都知道<a href="https://blog.logrocket.com/docker-for-front-end-developers/" target="_blank" rel="noopener noreferrer"> Docker </a>。它是无处不在的应用程序打包和分发工具，似乎从无到有，接管了我们的行业！如果你正在阅读这篇文章，这意味着你已经理解了Docker的基础知识，并且现在正在寻求创建一个更复杂的构建管道。</p>
<p>在过去，优化我们的Docker图像是一项具有挑战性的工作。在应用程序投入生产之前，各种各样的魔术被用来减小它们的大小。现在情况不同了，因为Docker增加了对多阶段构建的支持。</p>
<p>在本文中，我们将探讨如何为Node.js应用程序使用多阶段构建。例如，我们将使用一个<a href="https://blog.logrocket.com/7-bad-excuses-for-not-using-typescript-dbf5e603a9a8/" target="_blank" rel="noopener noreferrer"> TypeScript </a>构建过程，但是同样的事情也适用于任何构建管道。因此，即使您更喜欢使用Babel，或者您可能需要构建一个React客户端，Docker多阶段构建也可以为您工作。</p>
<p>这篇文章附带的代码是GitHub 上的<a href="https://github.com/ashleydavis/docker-nodejs-basic-example">，在这里可以找到一个多阶段类型脚本构建的docker文件示例。</a></p>
<h2>Node.js的基本单级docker文件</h2>
<p>让我们从Node.js的一个基本Docker文件开始，我们可以将正常的Docker构建过程可视化，如下面的图1所示。</p>
<figure id="attachment_6125" aria-describedby="caption-attachment-6125" class="wp-caption aligncenter"><img data-attachment-id="6125" data-permalink="https://blog.logrocket.com/crafting-build-pipelines-with-docker/attachment/normal-build-process-docker/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2019/09/normal-build-process-docker.png" data-orig-size="730,240" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Normal Docker build process" data-image-description="" data-image-caption="&lt;p&gt;Figure 1: Normal Docker build process.&lt;/p&gt;&#10;" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2019/09/normal-build-process-docker-300x99.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2019/09/normal-build-process-docker.png" decoding="async" class="size-full wp-image-6125 jetpack-lazy-image" src="../Images/24a1999572e2567601212a677b3207ba.png" alt="Normal Docker Build Process" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2019/09/normal-build-process-docker.png 730w, https://blog.logrocket.com/wp-content/uploads/2019/09/normal-build-process-docker-300x99.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2019/09/normal-build-process-docker.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/09/normal-build-process-docker.png"/><noscript><img data-lazy-fallback="1" data-attachment-id="6125" data-permalink="https://blog.logrocket.com/crafting-build-pipelines-with-docker/attachment/normal-build-process-docker/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2019/09/normal-build-process-docker.png" data-orig-size="730,240" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Normal Docker build process" data-image-description="" data-image-caption="&lt;p&gt;Figure 1: Normal Docker build process.&lt;/p&gt;&#10;" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2019/09/normal-build-process-docker-300x99.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2019/09/normal-build-process-docker.png" decoding="async" loading="lazy" class="size-full wp-image-6125" src="../Images/24a1999572e2567601212a677b3207ba.png" alt="Normal Docker Build Process" srcset="https://blog.logrocket.com/wp-content/uploads/2019/09/normal-build-process-docker.png 730w, https://blog.logrocket.com/wp-content/uploads/2019/09/normal-build-process-docker-300x99.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/09/normal-build-process-docker.png"/></noscript><figcaption id="caption-attachment-6125" class="wp-caption-text">Figure 1: Normal Docker build process.</figcaption></figure>
<p>我们使用<code>docker build</code>命令将Docker文件转换成Docker图像。然后，我们使用<code>docker run</code>命令将我们的图像实例化到Docker容器中。</p>
<p>下面清单1中的Dockerfile只是Node.js的一个标准的普通Dockerfile。我们在这里所做的就是复制<code>package.json</code>，安装生产依赖项，复制源代码，最后启动应用程序。</p>
<p>这个docker文件是针对常规JavaScript应用程序的，所以我们还不需要构建过程。我只向您展示这个简单的docker文件，以便您可以将它与我即将向您展示的多阶段docker文件进行比较。</p>
<h5>清单1:node . js的普通docker文件</h5>
<pre>FROM node:10.15.2

WORKDIR /usr/src/app
COPY package*.json ./
RUN npm install --only=production
COPY ./src ./src
EXPOSE 3000
CMD npm start</pre>
<p>清单1是一个非常普通的Docker文件。事实上，在引入多阶段构建之前，所有的Docker文件看起来都很像这样。既然Docker支持多阶段构建，我们可以将简单的Dockerfile想象成图2所示的单阶段构建过程。</p>
<figure id="attachment_6128" aria-describedby="caption-attachment-6128" class="wp-caption aligncenter"><img data-attachment-id="6128" data-permalink="https://blog.logrocket.com/crafting-build-pipelines-with-docker/attachment/single-stage-build-pipeline-docker/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2019/09/single-stage-build-pipeline-docker.png" data-orig-size="730,299" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Single-stage Docker build pipeline" data-image-description="" data-image-caption="&lt;p&gt;Figure 2: A single-stage build pipeline.&lt;/p&gt;&#10;" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2019/09/single-stage-build-pipeline-docker-300x123.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2019/09/single-stage-build-pipeline-docker.png" decoding="async" class="size-full wp-image-6128 jetpack-lazy-image" src="../Images/fec04469552fa90f8547c27712f891ad.png" alt="Single-Stage Docker Build Pipeline" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2019/09/single-stage-build-pipeline-docker.png 730w, https://blog.logrocket.com/wp-content/uploads/2019/09/single-stage-build-pipeline-docker-300x123.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2019/09/single-stage-build-pipeline-docker.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/09/single-stage-build-pipeline-docker.png"/><noscript><img data-lazy-fallback="1" data-attachment-id="6128" data-permalink="https://blog.logrocket.com/crafting-build-pipelines-with-docker/attachment/single-stage-build-pipeline-docker/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2019/09/single-stage-build-pipeline-docker.png" data-orig-size="730,299" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Single-stage Docker build pipeline" data-image-description="" data-image-caption="&lt;p&gt;Figure 2: A single-stage build pipeline.&lt;/p&gt;&#10;" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2019/09/single-stage-build-pipeline-docker-300x123.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2019/09/single-stage-build-pipeline-docker.png" decoding="async" loading="lazy" class="size-full wp-image-6128" src="../Images/fec04469552fa90f8547c27712f891ad.png" alt="Single-Stage Docker Build Pipeline" srcset="https://blog.logrocket.com/wp-content/uploads/2019/09/single-stage-build-pipeline-docker.png 730w, https://blog.logrocket.com/wp-content/uploads/2019/09/single-stage-build-pipeline-docker-300x123.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/09/single-stage-build-pipeline-docker.png"/></noscript><figcaption id="caption-attachment-6128" class="wp-caption-text">Figure 2: A single-stage build pipeline.</figcaption></figure>
<h2>需要多个阶段</h2>
<p>在构建我们的映像时，我们已经可以在docker文件中运行我们想要的任何命令，那么为什么我们还需要一个多阶段的构建呢？</p>
<p>为了找出原因，让我们升级我们的简单Dockerfile来包含一个TypeScript构建过程。清单2展示了升级后的Dockerfile。我把更新的线加粗了，这样你就可以很容易地把它们挑出来。</p>
<h5>清单2:我们已经升级了简单的Dockerfile，以包含一个TypeScript构建过程</h5>
<pre>FROM node:10.15.2

WORKDIR /usr/src/app
COPY package*.json ./
<strong>COPY tsconfig.json ./
RUN npm install</strong>
COPY ./src ./src
<strong>RUN npm run build</strong>
EXPOSE 80
CMD npm start</pre>
<p>我们可以很容易地直接看到这导致的问题。要亲自查看它，您应该从这个映像实例化一个容器，然后打开它并检查它的文件系统。</p>
<p>我这样做了，并使用Linux tree命令列出了容器中的所有目录和文件。您可以在图3中看到结果。</p>
<p>请注意，我们无意中在产品映像中包含了开发和构建过程的所有碎片。这包括我们的原始TypeScript源代码(我们在生产中不使用它)，TypeScript编译器本身(我们也不在生产中使用它)，加上我们可能已经安装到Node.js项目中的任何其他开发依赖项。</p>
<figure id="attachment_6130" aria-describedby="caption-attachment-6130" class="wp-caption aligncenter"><img data-attachment-id="6130" data-permalink="https://blog.logrocket.com/crafting-build-pipelines-with-docker/attachment/docker-container-contents/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2019/09/docker-container-contents.png" data-orig-size="730,812" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Docker container contents" data-image-description="" data-image-caption="&lt;p&gt;FIgure 3: The debris from development and the build process is bloating our production Docker image.&lt;/p&gt;&#10;" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2019/09/docker-container-contents-270x300.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2019/09/docker-container-contents.png" decoding="async" class="size-full wp-image-6130 jetpack-lazy-image" src="../Images/367faabf0405f0c82a100f0c88ac055e.png" alt="Docker Container Contents" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2019/09/docker-container-contents.png 730w, https://blog.logrocket.com/wp-content/uploads/2019/09/docker-container-contents-270x300.png 270w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2019/09/docker-container-contents.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/09/docker-container-contents.png"/><noscript><img data-lazy-fallback="1" data-attachment-id="6130" data-permalink="https://blog.logrocket.com/crafting-build-pipelines-with-docker/attachment/docker-container-contents/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2019/09/docker-container-contents.png" data-orig-size="730,812" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Docker container contents" data-image-description="" data-image-caption="&lt;p&gt;FIgure 3: The debris from development and the build process is bloating our production Docker image.&lt;/p&gt;&#10;" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2019/09/docker-container-contents-270x300.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2019/09/docker-container-contents.png" decoding="async" loading="lazy" class="size-full wp-image-6130" src="../Images/367faabf0405f0c82a100f0c88ac055e.png" alt="Docker Container Contents" srcset="https://blog.logrocket.com/wp-content/uploads/2019/09/docker-container-contents.png 730w, https://blog.logrocket.com/wp-content/uploads/2019/09/docker-container-contents-270x300.png 270w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/09/docker-container-contents.png"/></noscript><figcaption id="caption-attachment-6130" class="wp-caption-text">FIgure 3: The debris from development and the build process is bloating our production Docker image.</figcaption></figure>
<p>请记住，这只是一个微不足道的项目，所以我们实际上并没有看到太多的cruft留在我们的生产形象。但是您可以想象这对一个有许多源文件、许多开发依赖项和生成临时文件的更复杂的构建过程的真实应用程序来说是多么糟糕！</p>
<p>我们不希望生产中出现这种额外的膨胀。额外的尺寸使我们的集装箱更大。当我们的容器比需要的大时，这意味着我们没有有效利用我们的资源。容器表面积的增加也可能是一个安全问题，在这种情况下，我们通常倾向于最小化应用程序可攻击的表面积。</p>
<p>如果我们可以扔掉我们不想要的文件，只保留我们想要的文件，这不是很好吗？这正是Docker多阶段构建可以为我们做的。</p>
<h2>用多阶段构建制作Dockerfile文件</h2>
<p>我们将把Dockerfile分成两个阶段。图4显示了拆分后我们的构建管道的样子。</p>
<figure id="attachment_6132" aria-describedby="caption-attachment-6132" class="wp-caption aligncenter"><img data-attachment-id="6132" data-permalink="https://blog.logrocket.com/crafting-build-pipelines-with-docker/attachment/multi-stage-docker-build-pipeline/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2019/09/multi-stage-docker-build-pipeline.png" data-orig-size="730,299" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Multi-stage Docker build pipeline" data-image-description="" data-image-caption="&lt;p&gt;Figure 4: A multi-stage Docker build pipeline to build TypeScript.&lt;/p&gt;&#10;" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2019/09/multi-stage-docker-build-pipeline-300x123.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2019/09/multi-stage-docker-build-pipeline.png" decoding="async" class="size-full wp-image-6132 jetpack-lazy-image" src="../Images/5a9f17beec7804689ee65684fb74421f.png" alt="Multi-Stage Docker Build Pipeline" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2019/09/multi-stage-docker-build-pipeline.png 730w, https://blog.logrocket.com/wp-content/uploads/2019/09/multi-stage-docker-build-pipeline-300x123.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2019/09/multi-stage-docker-build-pipeline.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/09/multi-stage-docker-build-pipeline.png"/><noscript><img data-lazy-fallback="1" data-attachment-id="6132" data-permalink="https://blog.logrocket.com/crafting-build-pipelines-with-docker/attachment/multi-stage-docker-build-pipeline/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2019/09/multi-stage-docker-build-pipeline.png" data-orig-size="730,299" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Multi-stage Docker build pipeline" data-image-description="" data-image-caption="&lt;p&gt;Figure 4: A multi-stage Docker build pipeline to build TypeScript.&lt;/p&gt;&#10;" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2019/09/multi-stage-docker-build-pipeline-300x123.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2019/09/multi-stage-docker-build-pipeline.png" decoding="async" loading="lazy" class="size-full wp-image-6132" src="../Images/5a9f17beec7804689ee65684fb74421f.png" alt="Multi-Stage Docker Build Pipeline" srcset="https://blog.logrocket.com/wp-content/uploads/2019/09/multi-stage-docker-build-pipeline.png 730w, https://blog.logrocket.com/wp-content/uploads/2019/09/multi-stage-docker-build-pipeline-300x123.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/09/multi-stage-docker-build-pipeline.png"/></noscript><figcaption id="caption-attachment-6132" class="wp-caption-text">Figure 4: A multi-stage Docker build pipeline to build TypeScript.</figcaption></figure>
<p>我们新的多阶段构建管道有两个阶段:<em>构建阶段1 </em>是构建我们的类型脚本代码；<em>构建阶段2 </em>创造了我们的生产码头工人形象。在这条流水线的末端产生的最终Docker图像只包含它需要的，而忽略了我们不想要的cruft。</p>
<p>为了创建我们的两阶段构建管道，我们基本上只需在一个文件中创建两个Docker文件。清单3展示了添加了多个阶段的docker文件。第一个<code>FROM</code>命令启动第一阶段，第二个<code>FROM</code>命令启动第二阶段。</p>
<p>将它与常规的单级docker文件进行比较，您会发现它实际上看起来像是两个docker文件挤在了一起。</p>
<h5>清单3:用于构建类型脚本代码的多阶段docker文件</h5>
<pre># 
# Build stage 1.
# This state builds our TypeScript and produces an intermediate Docker image containing the compiled JavaScript code.
#
FROM node:10.15.2

WORKDIR /usr/src/app
COPY package*.json ./
COPY tsconfig.json ./
RUN npm install
COPY ./src ./src
RUN npm run build

#
# Build stage 2.
# This stage pulls the compiled JavaScript code from the stage 1 intermediate image.
# This stage builds the final Docker image that we'll use in production.
#
FROM node:10.15.2

WORKDIR /usr/src/app
COPY package*.json ./
RUN npm install --only=production
<strong>COPY --from=0 /usr/src/app/build ./build</strong>
EXPOSE 80
CMD npm start</pre>
<p>为了创建这个多阶段docker文件，我简单地将清单2分成几个独立的docker文件。第一阶段仅包含构建TypeScript代码所需的内容。第二阶段仅包含生成最终成品Docker映像所需的内容。然后，我将这两个docker文件合并成一个文件。</p>
<p>最需要注意的是第二阶段<code>--from</code>的使用。在清单3中，我用粗体显示了这一行，这样您就可以很容易地识别出来。这是我们用来从第一阶段提取构建文件的语法，我们在这里称之为<em>阶段0 </em>。我们将编译好的JavaScript文件从第一阶段拖到第二阶段。</p>
<p>我们可以很容易地检查以确保我们得到了想要的结果。在创建了新的映像并实例化了一个容器之后，我开始检查文件系统的内容。您可以在图5中看到，我们已经成功地从生产映像中移除了碎片。</p>
<figure id="attachment_6135" aria-describedby="caption-attachment-6135" class="wp-caption aligncenter"><img data-attachment-id="6135" data-permalink="https://blog.logrocket.com/crafting-build-pipelines-with-docker/attachment/cleaned-docker-container-contents/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2019/09/cleaned-docker-container-contents.png" data-orig-size="730,650" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Cleaned Docker container contents" data-image-description="" data-image-caption="&lt;p&gt;Figure 5: We have removed the debris of development from our Docker image.&lt;/p&gt;&#10;" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2019/09/cleaned-docker-container-contents-300x267.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2019/09/cleaned-docker-container-contents.png" decoding="async" class="size-full wp-image-6135 jetpack-lazy-image" src="../Images/ce33aa36d893cce6a2e0129877ca944c.png" alt="Cleaned Docker Container Contents" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2019/09/cleaned-docker-container-contents.png 730w, https://blog.logrocket.com/wp-content/uploads/2019/09/cleaned-docker-container-contents-300x267.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2019/09/cleaned-docker-container-contents.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/09/cleaned-docker-container-contents.png"/><noscript><img data-lazy-fallback="1" data-attachment-id="6135" data-permalink="https://blog.logrocket.com/crafting-build-pipelines-with-docker/attachment/cleaned-docker-container-contents/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2019/09/cleaned-docker-container-contents.png" data-orig-size="730,650" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Cleaned Docker container contents" data-image-description="" data-image-caption="&lt;p&gt;Figure 5: We have removed the debris of development from our Docker image.&lt;/p&gt;&#10;" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2019/09/cleaned-docker-container-contents-300x267.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2019/09/cleaned-docker-container-contents.png" decoding="async" loading="lazy" class="size-full wp-image-6135" src="../Images/ce33aa36d893cce6a2e0129877ca944c.png" alt="Cleaned Docker Container Contents" srcset="https://blog.logrocket.com/wp-content/uploads/2019/09/cleaned-docker-container-contents.png 730w, https://blog.logrocket.com/wp-content/uploads/2019/09/cleaned-docker-container-contents-300x267.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/09/cleaned-docker-container-contents.png"/></noscript><figcaption id="caption-attachment-6135" class="wp-caption-text">Figure 5: We have removed the debris of development from our Docker image.</figcaption></figure>
<p>现在，我们的映像中有更少的文件，更小，表面积更小。耶！任务完成。</p>
<p>但是，这具体意味着什么呢？</p>
<h2>多阶段构建的效果</h2>
<p>新的构建管道对我们的生产形象到底有什么影响？</p>
<p>我测量了前后的结果。清单2生成的单级图像重955MB。在转换成清单3中的多阶段构建之后，映像现在达到902MB。这是一个合理的缩减—我们从映像中删除了53MB！</p>
<p>虽然53MB看起来很多，但实际上我们只削减了超过5%的大小。我知道你现在要说什么:<em>但是Ash，我们的形象仍然巨大无比！在这个图像中仍然有太多的膨胀。</em></p>
<p>嗯，为了让我们的图像更小，我们现在需要使用<code>alpine</code>，或者精简的Node.js基础图像。我们可以通过将第二个构建阶段从<code>node:10.15.2</code>改为<code>node:10.15.2-alpine</code>来实现。</p>
<p>这将我们的生产映像缩减到73MB，这是一个巨大的胜利！现在，我们从丢弃垃圾中得到的节约更像是高达60%。好了，我们现在真的有进展了！</p>
<p>这突出了多阶段构建的另一个好处:我们可以为每个构建阶段使用单独的Docker基础映像。这意味着您可以通过使用不同的基础映像来自定义每个构建阶段。</p>
<p>假设您有一个阶段依赖于不同映像中的一些工具，或者您创建了一个为您的构建过程定制的特殊Docker映像。这给了我们在构建构建管道时很大的灵活性。</p>
<h2>它是如何工作的？</h2>
<p>您可能已经猜到了这一点:每个阶段或构建过程都会产生自己单独的Docker映像。您可以在图6中看到这是如何工作的。</p>
<p>由一个阶段产生的Docker图像可以被后面的阶段使用。一旦产生了最终图像，所有的中间图像都被丢弃；我们拿走我们想要的最终图像，其余的被扔掉。</p>
<figure id="attachment_6137" aria-describedby="caption-attachment-6137" class="wp-caption aligncenter"><img data-attachment-id="6137" data-permalink="https://blog.logrocket.com/crafting-build-pipelines-with-docker/attachment/each-stage-creates-image/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2019/09/each-stage-creates-image.png" data-orig-size="730,337" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Each stage of the build produces an image" data-image-description="" data-image-caption="&lt;p&gt;Figure 6: Each stage of a multi-stage Docker build produces an image.&lt;/p&gt;&#10;" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2019/09/each-stage-creates-image-300x138.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2019/09/each-stage-creates-image.png" decoding="async" class="size-full wp-image-6137 jetpack-lazy-image" src="../Images/edc4b975028d3abec7c821497955695c.png" alt="Each Stage In The Build Produces An Image" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2019/09/each-stage-creates-image.png 730w, https://blog.logrocket.com/wp-content/uploads/2019/09/each-stage-creates-image-300x138.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2019/09/each-stage-creates-image.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/09/each-stage-creates-image.png"/><noscript><img data-lazy-fallback="1" data-attachment-id="6137" data-permalink="https://blog.logrocket.com/crafting-build-pipelines-with-docker/attachment/each-stage-creates-image/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2019/09/each-stage-creates-image.png" data-orig-size="730,337" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Each stage of the build produces an image" data-image-description="" data-image-caption="&lt;p&gt;Figure 6: Each stage of a multi-stage Docker build produces an image.&lt;/p&gt;&#10;" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2019/09/each-stage-creates-image-300x138.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2019/09/each-stage-creates-image.png" decoding="async" loading="lazy" class="size-full wp-image-6137" src="../Images/edc4b975028d3abec7c821497955695c.png" alt="Each Stage In The Build Produces An Image" srcset="https://blog.logrocket.com/wp-content/uploads/2019/09/each-stage-creates-image.png 730w, https://blog.logrocket.com/wp-content/uploads/2019/09/each-stage-creates-image-300x138.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/09/each-stage-creates-image.png"/></noscript><figcaption id="caption-attachment-6137" class="wp-caption-text">Figure 6: Each stage of a multi-stage Docker build produces an image.</figcaption></figure>
<h2>添加更多阶段</h2>
<p>没有必要在两个阶段停下来，尽管这通常是所需要的；我们可以根据需要添加任意多个阶段。图7示出了一个具体的例子。</p>
<p>这里，我们在第一阶段构建类型脚本代码，在第二阶段构建React客户端。此外，还有第三个阶段，根据前两个阶段的结果生成最终图像。</p>
<figure id="attachment_6153" aria-describedby="caption-attachment-6153" class="wp-caption aligncenter"><img data-attachment-id="6153" data-permalink="https://blog.logrocket.com/crafting-build-pipelines-with-docker/attachment/more-complicated-build-process/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2019/09/more-complicated-build-process.png" data-orig-size="730,441" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="More complex build processes" data-image-description="" data-image-caption="&lt;p&gt;Figure 7: Using a Docker multi-stage build, we can create more complex build pipelines.&lt;/p&gt;&#10;" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2019/09/more-complicated-build-process-300x181.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2019/09/more-complicated-build-process.png" decoding="async" class="size-full wp-image-6153 jetpack-lazy-image" src="../Images/e9f33be4fdaab4df6d8186b57b2c643c.png" alt="Creating More Complex Build Processes" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2019/09/more-complicated-build-process.png 730w, https://blog.logrocket.com/wp-content/uploads/2019/09/more-complicated-build-process-300x181.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2019/09/more-complicated-build-process.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/09/more-complicated-build-process.png"/><noscript><img data-lazy-fallback="1" data-attachment-id="6153" data-permalink="https://blog.logrocket.com/crafting-build-pipelines-with-docker/attachment/more-complicated-build-process/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2019/09/more-complicated-build-process.png" data-orig-size="730,441" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="More complex build processes" data-image-description="" data-image-caption="&lt;p&gt;Figure 7: Using a Docker multi-stage build, we can create more complex build pipelines.&lt;/p&gt;&#10;" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2019/09/more-complicated-build-process-300x181.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2019/09/more-complicated-build-process.png" decoding="async" loading="lazy" class="size-full wp-image-6153" src="../Images/e9f33be4fdaab4df6d8186b57b2c643c.png" alt="Creating More Complex Build Processes" srcset="https://blog.logrocket.com/wp-content/uploads/2019/09/more-complicated-build-process.png 730w, https://blog.logrocket.com/wp-content/uploads/2019/09/more-complicated-build-process-300x181.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/09/more-complicated-build-process.png"/></noscript><figcaption id="caption-attachment-6153" class="wp-caption-text">Figure 7: Using a Docker multi-stage build, we can create more complex build pipelines.</figcaption></figure>
<h2>专业提示</h2>
<p>现在是时候给你留下一些高级技巧供你自己探索了:</p>
<ol>
<li>您可以命名您的构建阶段！您不必将它们保留为默认的0、1等。命名您的构建阶段将使您的docker文件更具可读性。</li>
<li>了解您对基础映像的选择。使用正确的基础映像可以在构建您的构建管道时消除很多困惑。</li>
<li>如果构建过程的复杂性失控，构建一个定制的基础映像。</li>
<li>可以从外部图片拉！就像您从早期阶段提取文件一样，您也可以从发布到Docker存储库的图像中提取文件。这给了你一个选择，如果它很贵并且不经常改变的话，你可以在早期构建阶段进行预烘焙。</li>
</ol>
<h2>结论和资源</h2>
<p>Docker多阶段构建使我们能够创建更复杂的构建管道，而不必求助于魔术。它们帮助我们精简我们的生产Docker图像并消除臃肿。它们还允许我们结构化和模块化我们的构建过程，这使得孤立地测试我们的构建过程的部分变得更加容易。</p>
<p>因此，请享受Docker多阶段构建的乐趣，不要忘记看看GitHub 上的<a href="https://github.com/ashleydavis/docker-nodejs-basic-example">示例代码。</a></p>
<p>这里还有关于多阶段构建的Docker文档。</p><div class="code-block code-block-15">
<h2>关于作者:</h2>
<p>Ashley Davis是一名经验丰富的软件开发人员和作家。他是类似于T1的CTO，帮助企业使用机器学习来管理他们的数字资产。</p>
<p>Ash也是Data-Forge Notebook的开发者，这是一个笔记本式的应用程序，用于用JavaScript和TypeScript进行原型开发、探索性编码和数据分析。</p>
<p>Ash是《与JavaScript的数据角力》和《T2引导微服务》的作者。要了解Ash的最新工作，请在Twitter 上关注<a href="https://twitter.com/ashleydavis75">他，并关注他的博客</a><a href="http://www.the-data-wrangler.com/">数据辩论者</a>。</p><div class="code-block code-block-23">
<div class="blog-plug inline-plug node-plug"><h2>200只<img src="../Images/61167b9d027ca73ed5aaf59a9ec31267.png" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2019/10/green-check.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" class=" jetpack-lazy-image" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/10/green-check.png"/> <noscript> <img data-lazy-fallback="1" src="../Images/61167b9d027ca73ed5aaf59a9ec31267.png" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/10/green-check.png"/> </noscript>显示器出现故障，生产中网络请求缓慢</h2><p>部署基于节点的web应用程序或网站是容易的部分。确保您的节点实例继续为您的应用程序提供资源是事情变得更加困难的地方。如果您对确保对后端或第三方服务的请求成功感兴趣，</p><a href="https://lp.logrocket.com/blg/node-signup" target="_blank">try LogRocket</a><p>. </p><a class="signup" href="https://lp.logrocket.com/blg/node-signup" target="_blank" rel="noopener noreferrer"><img src="../Images/cae72fd2a54c5f02a6398c4867894844.png" alt="LogRocket Network Request Monitoring" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2019/12/network-request-filter-2-1.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" class=" jetpack-lazy-image" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/12/network-request-filter-2-1.png"/><noscript><img data-lazy-fallback="1" src="../Images/cae72fd2a54c5f02a6398c4867894844.png" alt="LogRocket Network Request Monitoring" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/12/network-request-filter-2-1.png"/></noscript></a><a href="https://lp.logrocket.com/blg/node-signup" target="_blank" rel="noopener noreferrer">https://logrocket.com/signup/</a><p>LogRocket 就像是网络和移动应用程序的DVR，记录下用户与你的应用程序交互时发生的一切。您可以汇总并报告有问题的网络请求，以快速了解根本原因，而不是猜测问题发生的原因。</p><p>LogRocket检测您的应用程序以记录基线性能计时，如页面加载时间、到达第一个字节的时间、慢速网络请求，还记录Redux、NgRx和Vuex操作/状态。</p><a class="signup" href="https://lp.logrocket.com/blg/node-signup" target="_blank" rel="noopener noreferrer">Start monitoring for free</a><p>. </p></div>
</div>
</div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
<html>
<head>
<title>Understanding (and effectively using) asynchronous JavaScript - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>理解(并有效地使用)异步JavaScript - LogRocket博客</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/understanding-asynchronous-javascript/#0001-01-01">https://blog.logrocket.com/understanding-asynchronous-javascript/#0001-01-01</a></blockquote><div><article class="article-post">
<p>JavaScript已经成为当今世界上最流行的语言之一。它是一种单线程语言，这意味着一次只能做一件事。在异步JavaScript——使用promises和async/await——被添加到JavaScript之前，这一直是一个限制。</p>
<p>在本文中，我们将学习如何更有效地使用异步JavaScript。</p>
<h2>介绍</h2>
<p>JavaScript是一种单线程语言，这意味着它一次只允许执行一个逻辑，因此你不能执行会阻塞JavaScript主线程的复杂的长函数。为了解决这个问题，回调——即作为参数传递给其他函数的<a href="https://www.javascripttutorial.net/javascript-function/" target="_blank" rel="noopener noreferrer">函数</a>—被用来执行异步函数。使用异步JavaScript，可以在不阻塞JavaScript主线程的情况下执行大型函数。</p>
<p>为了更好地理解这一点，让我们看看什么是同步和异步JavaScript。</p>
<h2>同步JavaScript</h2>
<p>顾名思义，同步JavaScript意味着按顺序或次序。在这里，每个函数或程序都是按顺序执行的，在执行下一个函数之前，每个函数或程序都要等待第一个函数执行，同步代码从上到下执行。</p>
<p>为了更好地理解同步JavaScript，让我们看看下面的代码:</p>
<pre>let a = 5;
let b = 10;
console.log(a);
console.log(b);</pre>
<p>这是结果:</p>
<p><img data-attachment-id="28465" data-permalink="https://blog.logrocket.com/understanding-asynchronous-javascript/synchronousjs/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/11/synchronousjs.png" data-orig-size="843,310" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="synchronousjs" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/11/synchronousjs-300x110.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/11/synchronousjs.png" decoding="async" class="aligncenter size-full wp-image-28465 jetpack-lazy-image" src="../Images/4e2bc39460897ab2afc9097d7a4a8434.png" alt="synchronous JavaScript functions displaying function results, 5 and 10, in the console" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2020/11/synchronousjs.png 843w, https://blog.logrocket.com/wp-content/uploads/2020/11/synchronousjs-300x110.png 300w, https://blog.logrocket.com/wp-content/uploads/2020/11/synchronousjs-768x282.png 768w" data-lazy-sizes="(max-width: 843px) 100vw, 843px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2020/11/synchronousjs.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/11/synchronousjs.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="28465" data-permalink="https://blog.logrocket.com/understanding-asynchronous-javascript/synchronousjs/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/11/synchronousjs.png" data-orig-size="843,310" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="synchronousjs" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/11/synchronousjs-300x110.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/11/synchronousjs.png" decoding="async" loading="lazy" class="aligncenter size-full wp-image-28465" src="../Images/4e2bc39460897ab2afc9097d7a4a8434.png" alt="synchronous JavaScript functions displaying function results, 5 and 10, in the console" srcset="https://blog.logrocket.com/wp-content/uploads/2020/11/synchronousjs.png 843w, https://blog.logrocket.com/wp-content/uploads/2020/11/synchronousjs-300x110.png 300w, https://blog.logrocket.com/wp-content/uploads/2020/11/synchronousjs-768x282.png 768w" sizes="(max-width: 843px) 100vw, 843px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/11/synchronousjs.png"/></noscript>
<p>这里，JavaScript引擎执行等式中的第一行，在本例中是5，然后执行第二行代码，将10输出到控制台。如果我们添加任何其他代码行，JavaScript引擎会根据我们添加它的位置来执行它，这就是同步JavaScript所需要的，一种执行代码的顺序方式。</p>
<h2>异步JavaScript</h2>
<p>现在，我们对同步JavaScript的工作原理有了一个概念，让我们来谈谈异步JavaScript。为了解释这一点，让我们看看下面的代码:</p>
<pre>console.log("Hello.");
setTimeout(function() {
  console.log("Goodbye!");
}, 3000);
console.log("Hello again!");</pre>
<p>与我们的另一个例子不同，JavaScript引擎不会同步执行上面的代码。让我们看看下面的输出:</p>
<p><img data-attachment-id="28466" data-permalink="https://blog.logrocket.com/understanding-asynchronous-javascript/asynchronousjavascript/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/11/asynchronousjavascript.png" data-orig-size="859,294" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="asynchronousjavascript" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/11/asynchronousjavascript-300x103.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/11/asynchronousjavascript.png" decoding="async" class="aligncenter size-full wp-image-28466 jetpack-lazy-image" src="../Images/eb440283a55ce97e71b676cdf951ed22.png" alt="&quot;Hello!&quot;, &quot;Hello again!&quot;, and &quot;Goodbye&quot; all logged in the console" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2020/11/asynchronousjavascript.png 859w, https://blog.logrocket.com/wp-content/uploads/2020/11/asynchronousjavascript-300x103.png 300w, https://blog.logrocket.com/wp-content/uploads/2020/11/asynchronousjavascript-768x263.png 768w" data-lazy-sizes="(max-width: 859px) 100vw, 859px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2020/11/asynchronousjavascript.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/11/asynchronousjavascript.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="28466" data-permalink="https://blog.logrocket.com/understanding-asynchronous-javascript/asynchronousjavascript/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/11/asynchronousjavascript.png" data-orig-size="859,294" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="asynchronousjavascript" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/11/asynchronousjavascript-300x103.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/11/asynchronousjavascript.png" decoding="async" loading="lazy" class="aligncenter size-full wp-image-28466" src="../Images/eb440283a55ce97e71b676cdf951ed22.png" alt="&quot;Hello!&quot;, &quot;Hello again!&quot;, and &quot;Goodbye&quot; all logged in the console" srcset="https://blog.logrocket.com/wp-content/uploads/2020/11/asynchronousjavascript.png 859w, https://blog.logrocket.com/wp-content/uploads/2020/11/asynchronousjavascript-300x103.png 300w, https://blog.logrocket.com/wp-content/uploads/2020/11/asynchronousjavascript-768x263.png 768w" sizes="(max-width: 859px) 100vw, 859px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/11/asynchronousjavascript.png"/></noscript>
<p>在代码中，我们将<code>Hello</code>记录到我们的控制台，接下来我们编写了一个函数，它将在三秒钟后将<code>Goodbye</code>记录到我们的控制台，代码的最后一部分将<code>Hello again</code>记录到我们的控制台。这里，JavaScript引擎遍历第一个函数并执行它，将<code>Hello</code>打印到控制台，转到下一个函数，它看到<code>setTimeout</code>函数，而不是等待三秒来打印函数，而是转到最后一个函数并执行它，打印<code>Hello again</code>，等待三秒，然后执行第二个函数。</p>
<p>因此，对于异步JavaScript，JavaScript在执行函数时不会等待响应，而是继续执行其他函数。让我们看看异步JavaScript的执行方式。</p>
<h2>编写异步JavaScript的方法</h2>
<p>用JavaScript编写异步代码有两种方式，promises和async/await。</p>
<h2>承诺</h2>
<p>只有当某个标准为真时，承诺才会通过。有了JavaScript的承诺，我们可以推迟代码执行，直到异步请求完成，这样其他函数就可以继续运行，而不会阻塞线程。</p>
<p>Promises是一种编写异步JavaScript的新方法，它通常是一个具有三种主要状态的对象，包括:</p>
<ul>
<li>“待定”——承诺通过或失败之前的初始状态</li>
<li>决心——成功的承诺</li>
<li>拒绝——失败的承诺</li>
</ul>
<p>为了更好地理解这一点，让我们在下面创建一个承诺:</p>
<pre>const hungry = true;
const eat = new Promise(function(resolve, reject) {
  if (hungry) {
      const fastfood = {
        activity: 'Cook noodles',
        location: 'Market Square'
      };
  resolve(fastfood)
  } else {
    reject(new Error('Not hungry'))
    }
});</pre>
<p>在上面的代码中，如果<code>hungry</code>为真，解析返回带有<code>fastfood</code>的数据的承诺，带有一个表示<code>Cook noodles</code>的活动，否则返回一个表示<code>Not hungry</code>的错误对象。</p>
<h2>用承诺</h2>
<p>让我们更进一步，使用上面初始化的承诺，我们可以将<code>.then()</code>和一个<code>.catch()</code>方法链接到下面的承诺:</p>
<pre>const willEat = function() {
  eat
    .then(function(hungry) {
      console.log('Going to eat noodles!')
      console.log(hungry)
    })
    .catch(function(error) {
        console.log(error.message)
    })
}

willEat();</pre>
<p>在上面的代码中，我们创建了一个名为<code>willEat()</code>的新函数，承诺为<code>eat</code>，接下来我们使用<code>.then()</code>来添加一个包含我们承诺的解析的函数。然后我们添加了一个<code>.catch()</code>方法来返回我们的承诺中的错误消息。</p>
<p>由于饥饿值为真，当我们调用我们的<code>willEat()</code>函数时，我们应该得到下面的结果:</p>
<pre>Going to eat noodles!
{
  activity: 'Cook noodles',
  location: 'Market square'
}</pre>
<p>如果我们将hungry的值更改为false，我们的承诺将显示一个失败承诺的状态，在我们的例子中是<code>not hungry</code>。我们可以通过创建一个新的承诺来进一步推进我们的承诺，这个新的承诺将从我们之前的示例中获取参数:</p>
<pre>const foodTour = function(fastfood) {
  return new Promise(function(resolve, reject) {
    const response = `I'm going on a food tour at
        ${fastfood.location`;

    resolve(response)
  });
}</pre>
<p>在上面的代码中，我们创建了一个名为<code>foodTour</code>的新承诺，它从前面的示例中获取<code>fastfood</code>值，并在前面的示例中使用位于<code>fastfood</code>位置的模板字符串来解析响应。</p>
<h2>异步/等待</h2>
<p>Async/await是在(ES2017+)版本中添加的，是<em>语法糖</em>使得用JavaScript写承诺更容易。Async/await帮助您编写异步工作的看起来同步的JavaScript代码。</p>
<p>一个异步函数返回一个承诺，如果函数返回一个值，这个承诺就用这个值来解析，但是如果异步函数抛出一个错误，这个承诺就用这个值来拒绝。下面让我们创建一个简单的异步函数:</p>
<pre>async function favoriteDrink() {
    return 'Monster energy drink'
}</pre>
<p>这里，我们声明了一个名为<code>favoriteDrink()</code>的函数，它返回<code>Monster energy drink</code>。如果一个承诺在一个异步函数中被拒绝，它会显示一个拒绝的方法，如下所示:</p>
<pre>async function() {
  throw 3;
}</pre>
<p>Await位于异步函数中，以确保函数中返回的所有承诺都是同步的。对于async/await，不使用回调。<code>try</code>和<code>catch</code>方法也用于获得异步函数的拒绝值。让我们使用前面的例子创建一个包装在<code>try…catch</code>方法中的异步/等待函数:</p>
<pre>async function willEat() {
  try {
    let fastfood = await eat;
    let response = await foodTour(fastfood);
  console.log(response);
  } catch(error) {
      console.log(error.message);
    }
}

willEat();</pre>
<p>在这里，我们将之前的示例转换为使用封装在<code>try…catch</code>方法中的async/await，我们将响应记录为之前的示例，它返回字符串<code>I'm going on a food tour at Market Square</code>。</p>
<h2>用JavaScript发出异步请求</h2>
<p>最近在JavaScript中，<code>fetch()</code> API已经被用于URL的API请求。在此之前，使用XMLHttpRequest发出请求。有了<code>ES2017+</code>，使用fetch API和async/await，您可以向URL端点发出异步请求，首先您需要将函数定义为异步函数，并在<code>json</code>中等待响应，然后返回您的数据。为了更好地解释这一点，让我们看看下面的代码:</p>
<pre>async function getJobAsync()
{
  let response = await fetch(`https://cors-anywhere.herokuapp.com/https://jobs.github.com/positions.json`);
  let data = await response.json()
  return data;
}
getJobAsync('jobPositionHere')
  .then(data =&gt; console.log(data));</pre>
<p>在上面的代码中，我们编写了一个异步函数<code>getJobAsync()</code>,它向一个外部URL发出一个获取请求，接下来我们等待一个<code>json</code>格式的<code>response</code>,然后一旦请求得到解决就返回数据。这就是如何使用异步JavaScript发出异步请求。让我们看看下图中函数的结果。</p>
<p><img data-attachment-id="28468" data-permalink="https://blog.logrocket.com/understanding-asynchronous-javascript/jobsasyncrequest/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/11/jobsasyncrequest.png" data-orig-size="730,323" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="jobsasyncrequest" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/11/jobsasyncrequest-300x133.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/11/jobsasyncrequest.png" decoding="async" class="aligncenter size-full wp-image-28468 jetpack-lazy-image" src="../Images/7e9afbb7ef59791ca33ab68851369834.png" alt="jobs requested shown in the console " data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2020/11/jobsasyncrequest.png 730w, https://blog.logrocket.com/wp-content/uploads/2020/11/jobsasyncrequest-300x133.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2020/11/jobsasyncrequest.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/11/jobsasyncrequest.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="28468" data-permalink="https://blog.logrocket.com/understanding-asynchronous-javascript/jobsasyncrequest/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/11/jobsasyncrequest.png" data-orig-size="730,323" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="jobsasyncrequest" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/11/jobsasyncrequest-300x133.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/11/jobsasyncrequest.png" decoding="async" loading="lazy" class="aligncenter size-full wp-image-28468" src="../Images/7e9afbb7ef59791ca33ab68851369834.png" alt="jobs requested shown in the console " srcset="https://blog.logrocket.com/wp-content/uploads/2020/11/jobsasyncrequest.png 730w, https://blog.logrocket.com/wp-content/uploads/2020/11/jobsasyncrequest-300x133.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/11/jobsasyncrequest.png"/></noscript>
<p>接下来，我们将看看如何从异步API调用返回响应。</p>
<h2>从异步调用返回响应</h2>
<p>在JavaScript、回调和承诺中，有许多方法可以从异步调用返回响应。假设您正在进行一个异步调用，并且您希望调用的结果来自函数，这可以使用async/await来完成，让我们在下面的代码中进一步解释这一点:</p>
<pre>const getResult = async (request) =&gt; {
        let response = await new Promise((resolve, reject) =&gt; {
                request((err, res, body) =&gt; {
                        if (err) return reject(err);
                        try{
                                resolve(JSON.parse(body));
                        } catch(error) {
                                reject(error);
                        }
                });
        });

        try{
                console.log(response);
        }
        catch(err){
                console.error(err);
        }
}

getResult();
console.log('This is how to return async JavaScript');</pre>
<p>在上面的代码块中，我们将来自请求的响应包装在一个承诺中，然后等待它被解决或拒绝，同时也等待承诺返回一个响应。在JavaScript操作中，建议将代码包装在一个<code>try…catch</code>方法中，以便处理函数中可能出现的错误。最后，我们在程序结束时调用函数，并在控制台中记录消息<code>This is how to return async JavaScript</code>，这是我们在JavaScript、回调或async/await中响应异步调用的方式。</p>
<h2>结论</h2>
<p>在本文中，我们学习了什么是异步JavaScript，以及如何使用promises和async/await编写异步JavaScript。我们还看到了如何使用fetch API和async/await发送请求，以及如何返回对异步调用的响应。你可以在这里阅读更多关于异步JavaScript的内容。</p><div class="code-block code-block-27">
<div class="blog-plug inline-plug vanilla-javascript-cta"><h2>通过理解上下文，更容易地调试JavaScript错误</h2>
<p>调试代码总是一项单调乏味的任务。但是你越了解自己的错误，就越容易改正。</p>
<p>LogRocket 让你以新的独特的方式理解这些错误。我们的前端监控解决方案跟踪用户与您的JavaScript前端的互动，让您能够准确找出导致错误的用户行为。</p>
<a href="https://lp.logrocket.com/blg/javascript-signup" class="signup" target="_blank" rel="noopener noreferrer"><img class="alignnone size-full wp-image-46 jetpack-lazy-image" src="../Images/cbfed9be3defcb505e662574769a7636.png" alt="LogRocket Dashboard Free Trial Banner" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2020/06/reproduce-javascript-errors.gif?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/06/reproduce-javascript-errors.gif"/><noscript><img data-lazy-fallback="1" class="alignnone size-full wp-image-46" src="../Images/cbfed9be3defcb505e662574769a7636.png" alt="LogRocket Dashboard Free Trial Banner" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/06/reproduce-javascript-errors.gif"/></noscript></a>
<p>LogRocket记录控制台日志、页面加载时间、堆栈跟踪、慢速网络请求/响应(带有标题+正文)、浏览器元数据和自定义日志。理解您的JavaScript代码的影响从来没有这么简单过！</p>
<a class="signup" href="https://lp.logrocket.com/blg/javascript-signup" target="_blank" rel="noopener noreferrer">Try it for free</a><p>.</p></div>


</div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
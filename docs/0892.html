<html>
<head>
<title>React form validation solutions: An ultimate roundup - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>React表单验证解决方案:终极综述</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/react-form-validation-sollutions-ultimate-roundup/#0001-01-01">https://blog.logrocket.com/react-form-validation-sollutions-ultimate-roundup/#0001-01-01</a></blockquote><div><article class="article-post">
<p><em> <strong>编者按:</strong>这篇文章于2022年3月23日更新，包含了关于下列React表单验证解决方案的更新信息。</em></p>
<p>作为开发人员，通常最好不要重新发明轮子。这就是为什么实施解决方案的第一步是寻找现有的解决方案。这就是React所要做的——创建可重用的组件，这样我们就不会重复自己的工作。</p>
<p>在本文中，我们将了解React中一些最流行的表单管理和验证解决方案:</p>

<p>我们开始吧！</p>

<p>没有Formik，关于React form解决方案的综述是不完整的。GitHub上有30k stars，它基本上是React中最流行的构建和管理表单的库。Formik是一个可伸缩的、高性能的表单助手，具有最小的API。它处理表单状态管理、验证和错误处理。</p>
<p><strong>安装</strong></p>
<pre class="language-bash hljs">yarn add formik
</pre>
<p><strong>基本用法</strong> <br/>下面是如何使用最基本形式的Formik。钩子是封装所有优点的地方。要使用它，只需要传入一个包含每个表单字段默认值的对象<code>initialValues</code>。以及当表单验证通过时被调用的<code>onSubmit</code>处理程序。</p>
<p>当调用<code>useFormik</code>时，它返回事件处理程序和表单状态，我们可以用它们来指定何时触发表单验证。验证规则是通过<code>validate</code>属性添加的。回调函数作为该属性的值传递。也是验证单个表单字段的地方。每个字段的<code>onChange</code>事件都会触发验证。这意味着默认情况下，当用户更新第一个字段的值时，表单中的所有其他字段也会触发它们的验证码。</p>
<p>我们并不真的想要那样，这就是为什么我们需要从<code>useFormik</code>的返回对象中提取出<code>handleBlur</code>和<code>touched</code>。前者允许我们从字段中监听模糊事件，而后者允许我们检查用户是否已经访问了字段。从那里，我们可以通过<code>errors</code>检查错误:</p>
<pre class="language-react hljs">import React from "react";
import { useFormik } from "formik";

function FormikComponent() {
  function validate(values) {
    const errors = {};
    if (!values.favoriteFood) {
      errors.favoriteFood = "Required";
    }

    if (!values.favoritePlace) {
      errors.favoritePlace = "Required";
    }
    return errors;
  }

  const {
    handleSubmit,
    handleChange,
    handleBlur,
    touched,
    values, // use this if you want controlled components
    errors,
  } = useFormik({
    initialValues: {
      favoriteFood: "",
      favoritePlace: "",
    },
    validate,
    onSubmit: (values) =&gt; {
      console.log(JSON.stringify(values));
      // values = {"favoriteFood":"ramen","favoritePlace":"mountains"}
    },
  });

  return (
    &lt;form onSubmit={handleSubmit}&gt;
      &lt;label htmlFor="favoriteFood"&gt;Favorite Food:&lt;/label&gt;
      &lt;input
        type="text"
        name="favoriteFood"
        onChange={handleChange}
        onBlur={handleBlur}
      /&gt;
      {touched.favoriteFood &amp;&amp; errors.favoriteFood
        ? &lt;div&gt;errors.favoriteFood&lt;/div&gt;
        : null}

      &lt;label htmlFor="favoritePlace"&gt;Favorite place:&lt;label&gt;
      &lt;input
        type="text"
        name="favoritePlace"
        onChange={handleChange}
        onBlur={handleBlur}
      /&gt;

      {touched.favoritePlace &amp;&amp; errors.favoritePlace
        ? &lt;div&gt;errors.favoritePlace&lt;/div&gt;
        : null}

      &lt;button type="submit"&gt;submit&lt;/button&gt;
    &lt;/form&gt;    
  );
}

export default App;
</pre>
<p>上面的例子很好，但是在更复杂的表单上可能会很快失控。为此，我们可以使用<a href="https://github.com/jquense/yup" target="_blank" rel="noopener">是的</a>库。Yup是一个模式构建器，用于解析值并验证它们。您可以使用以下命令安装它:</p>
<pre class="language-bash hljs">yarn add yup
</pre>
<p>要使用Yup，你所要做的就是用<code>validationSchema</code>替换<code>validate</code>。这是专门为Yup集成而创建的:</p>
<pre class="language-react hljs">import * as Yup from "yup";

function App() {
  const schema = Yup.object({
    favoriteFood: Yup.string().required("Required"),
    favoritePlace: Yup.string().required("Required"),
  });

  const { ... } = useFormik = ({
    // ...
    validationSchema: schema // replace validate with this
  });
}
</pre>
<p><strong>总结</strong></p>


<p>React Final Form是一个框架无关的表单验证库，没有任何依赖性。<a href="https://github.com/final-form/final-form" target="_blank" rel="noopener">最终形式</a>是实际库的名称，而React最终形式是React包装器。它是基于订阅的，所以当表单状态更新时，只有特定的表单字段才会更新。</p>
<p><strong>安装</strong></p>
<pre class="language-bash hljs">yarn add final-form react-final-form
</pre>
<p><strong>基本用法</strong> <br/>用React最终表单验证表单有两种方式:<a href="https://final-form.org/docs/react-final-form/examples/record-level-validation" target="_blank" rel="noopener">记录级</a>和<a href="https://final-form.org/docs/react-final-form/examples/field-level-validation" target="_blank" rel="noopener">字段级</a>。记录级别与使用Formik的方式非常相似。就像Formik一样，您也可以轻松地使用Yup来实现验证规则。验证表单的方式取决于表单的复杂程度。如果您的表单相当简单，您可以坚持使用字段级验证。否则，使用记录级别。</p>
<p>下面是一个使用Yup进行记录级验证的例子。这要求我们使用最终表单库中的<code>setIn</code>实用函数将默认的错误对象转换成使用点括号语法的对象(例如<code>people[0].name.first</code>)。在下面的代码中，你可以看到它的工作方式类似于Formik。尽管它依赖于使用定制组件(<code>&lt;Form&gt;</code>和<code>&lt;Field&gt;</code>)来包装原始的HTML元素，为其提供状态和输入回调:</p>
<pre class="language-react hljs">import React from "react";
import { setIn } from "final-form";
import { Form, Field } from "react-final-form";
import * as Yup from "yup";

const schema = Yup.object({
  favoriteFood: Yup.string().required("Required"),
});

const validate = async (values) =&gt; {
  try {
    await schema.validate(values, { abortEarly: false });
  } catch (err) {
    const errors = err.inner.reduce((formError, innerError) =&gt; {
      return setIn(formError, innerError.path, innerError.message);
    }, {});

    return errors;
  }
};

const onSubmit = (values) =&gt; {
  console.log("values: ", values);
};

function FinalFormComponent() {
  return (
    &lt;Form
      onSubmit={onSubmit}
      validate={validate}
      render={({ handleSubmit, form, submitting, pristine, values }) =&gt; (
        &lt;form onSubmit={handleSubmit}&gt;
          &lt;Field name="favoriteFood"&gt;
            {({ input, meta }) =&gt; (
              &lt;div&gt;
                &lt;label&gt;Favorite Food&lt;/label&gt;
                &lt;input {...input} type="text" placeholder="favoriteFood" /&gt;
                {meta.error &amp;&amp; meta.touched &amp;&amp; &lt;span&gt;{meta.error}&lt;/span&gt;}
              &lt;/div&gt;
            )}
          &lt;/Field&gt;
          &lt;button type="submit"&gt;submit&lt;/button&gt;
        &lt;/form&gt;
      )}
    /&gt;
  );
}
</pre>
<p>下面是使用字段级验证的方法:</p>
<pre class="language-react hljs">import React from "react";
import { Form, Field } from "react-final-form";

const onSubmit = (values) =&gt; {
  console.log("values: ", values);
};

const required = (value) =&gt; (value ? undefined : "Required");

function FinalFormComponent() {
  return (
    &lt;Form
      onSubmit={onSubmit}
      render={({ handleSubmit, form, submitting, pristine, values }) =&gt; (
        &lt;form onSubmit={handleSubmit}&gt;
          &lt;div&gt;
            &lt;Field name="favoriteFood" validate={required}&gt;
              {({ input, meta }) =&gt; (
                &lt;div&gt;
                  &lt;label&gt;Favorite Food&lt;/label&gt;
                  &lt;input {...input} type="text" placeholder="Favorite food" /&gt;
                  {meta.error &amp;&amp; meta.touched &amp;&amp; &lt;div&gt;{meta.error}&lt;/div&gt;}
                &lt;/div&gt;
              )}
            &lt;/Field&gt;
          &lt;/div&gt;
          &lt;button type="submit"&gt;submit&lt;/button&gt;
        &lt;/form&gt;
      )}
    /&gt;
  );
}

export default FinalFormComponent;
</pre>
<p><strong>总结</strong></p>
<ul>
<li>React最终形式不依赖于任何库</li>
<li>它允许您管理哪些表单元素收到表单状态更改的通知。这使得它非常有性能</li>
<li>支持反作用挂钩</li>
<li>通过Yup库支持基于模式的验证</li>
<li>依赖于充当HTML表单元素包装器的自定义组件</li>
<li>依赖React上下文API为每个表单字段提供表单状态数据</li>
<li>React最终版本重<a href="https://bundlephobia.com/result?p=react-final-form@6.4.0" target="_blank" rel="noopener"> 3.2kB </a>，这意味着与最终版本的<a href="https://bundlephobia.com/result?p=final-form@4.19.1" target="_blank" rel="noopener"> 5.1kB </a>相比，它是非常轻量级的</li>
</ul>

<p>Unform是React的一个注重性能的表单库。它通过使用不受控制的表单组件来实现这一点。</p>
<p><strong>安装</strong></p>
<pre class="language-bash hljs">yarn add @unform/core @unform/web yup
</pre>
<p><strong>基本用法</strong><br/>un forma要求你创建自己的定制组件，在那里你使用<code>useField</code>钩子来访问字段数据和与字段交互的方法。在下面的代码中，我们只提取了<code>error</code>和<code>clearError</code>，这样我们就可以显示和清除验证错误消息:</p>
<pre class="language-react hljs">import React, { useRef } from "react";
import { useField } from "@unform/core";
export default function Input({ name, ...inputProps }) {
  const inputRef = useRef(null);
  const { error, clearError } = useField(name);

  return (
    &lt;&gt;
      &lt;input ref={inputRef} onFocus={clearError} {...inputProps} /&gt;
      {error &amp;&amp; &lt;span&gt;{error}&lt;/span&gt;}
    &lt;/&gt;
  );
}
</pre>
<p>一旦有了自定义组件，现在就可以将它包含在表单中。un format使用一个<code>Form</code>组件作为表单字段的容器。这是添加<code>ref</code>和<code>onSubmit</code>处理程序的地方。在下面的例子中，我们也使用了Yup进行验证。Unform不包括自己的验证库，因此您可以使用任何想要的验证表单:</p>
<pre class="language-react hljs">import React, { useRef } from "react";
import * as Yup from "yup";

import { Form } from "@unform/web";
import Input from "./components/Input";

function UnformComponent() {
  const formRef = useRef(null);

  async function handleSubmit(data) {
    try {
      formRef.current.setErrors({});
      const schema = Yup.object().shape({
        email: Yup.string().email().required()
      });
      await schema.validate(data, {
        abortEarly: false,
      });
      console.log(data);

    } catch (err) {
      const validationErrors = {};
      if (err instanceof Yup.ValidationError) {
        err.inner.forEach((error) =&gt; {
          validationErrors[error.path] = error.message;
        });
        formRef.current.setErrors(validationErrors);
      }
    }
  }

  return (
    &lt;Form ref={formRef} onSubmit={handleSubmit}&gt;
      &lt;Input name="email" type="email" /&gt;
      &lt;button type="submit"&gt;submit&lt;/button&gt;
    &lt;/Form&gt;
  );
}

export default UnformComponent;
</pre>
<blockquote><p>注意:如果您计划进一步探索这个库，请确保只遵循使用版本2的教程。更好的是，只要坚持<a href="https://unform-rocketseat.vercel.app/" target="_blank" rel="noopener">官方文件</a>。这是因为有些教程使用版本1。您可以很快确定它使用的是版本1，因为它使用自定义表单组件。版本2包含了原始HTML元素的使用。查看<a href="https://unform-rocketseat.vercel.app/migration-guide" target="_blank" rel="noopener">移民指南</a>了解更多信息。</p></blockquote>
<p><strong>总结</strong></p>
<ul>
<li>支持React挂钩——这使得代码更容易阅读和维护</li>
<li><a href="https://unform-rocketseat.vercel.app/guides/react-native" target="_blank" rel="noopener">通过使用<code>@unform/mobile</code>包支持React Native </a></li>
<li>使用HTML元素而不是自定义组件。集成是通过使用<code>useField</code> API实现的</li>
<li>通过表单引用提供对表单数据、错误和方法的轻松访问</li>
<li>通过使用点符号作为输入名称，支持复杂的表单结构</li>
<li>需要创建自定义表单输入组件才能使用</li>
<li>统一内核重<a href="https://bundlephobia.com/result?p=@unform/core@2.1.0" target="_blank" rel="noopener"> 3.7kB </a>统一网页重<a href="https://bundlephobia.com/result?p=@unform/web@2.1.0" target="_blank" rel="noopener"> 606字节</a></li>
</ul>

<p>React Form提供了在React中管理表单状态和验证表单的钩子。</p>
<p><strong>安装</strong></p>
<pre class="language-bash hljs">yarn add react-form
</pre>
<p><strong>基本用法</strong>这为您提供了存储字段错误的属性。通常，您只想在用户已经“触及”特定字段时显示错误。这就是<code>isTouched</code>属性允许您检查的内容。</p>
<p>要验证字段，需要传递一个包含验证函数的对象:</p>
<pre class="language-react hljs">import React from "react";
import { useField } from "react-form";

function Field({ name }) {
  const {
    value = "",
    meta: { error, isTouched },
    getInputProps,
  } = useField(name, {
    validate: (value) =&gt; {
      if (!value) {
        return `${name} is required.`;
      }
      return false;
    },
  });

  return (
    &lt;&gt;
      &lt;input type="text" {...getInputProps()} value={value} /&gt;
      {isTouched &amp;&amp; error ? &lt;span&gt;{error}&lt;/span&gt; : null}
    &lt;/&gt;
  );
}

export default Field;
</pre>
<p>一旦有了定制字段组件，现在就可以使用<code>useForm</code>钩子来验证表单。</p>
<p>注意<code>Form</code>组件是从<code>useForm</code>中提取的:</p>
<pre class="language-react hljs">import React from "react";
import { useForm } from "react-form";
import Field from "./components/Field";

function ReactFormComponent() {
  const {
    Form,
    meta: { isSubmitting },
  } = useForm({
    onSubmit: async (values, instance) =&gt; {
      console.log("submit: ", values);
    },
  });

  return (
    &lt;Form&gt;
      &lt;label&gt;
        Favorite Food: &lt;Field name={"favoriteFood"} /&gt;
      &lt;/label&gt;

      &lt;div&gt;
        &lt;button type="submit"&gt;Submit&lt;/button&gt;
      &lt;/div&gt;
    &lt;/Form&gt;
  );
}

export default ReactFormComponent;
</pre>
<p><strong>总结</strong></p>
<ul>
<li>通过使用<code>useForm</code>支持反作用钩</li>
<li>使用记忆进行快速重新渲染</li>
<li>缩小和压缩后，React Form的重量为4.5kB</li>
</ul>

<p>一个简单的React组件，允许您使用JSON schema构建和验证HTML表单。默认情况下，它附带了简单的表单验证。诸如<code>required</code>和<code>minLength</code>之类的验证规则内置于其中。如果您想使用更高级的验证规则，您必须自己编写它们。</p><div class="code-block code-block-54">
<hr/>
<h3>更多来自LogRocket的精彩文章:</h3>

<hr/></div>
<p>目前支持HTML表单语义的Bootstrap和Material UI。但是你也可以使用自己的HTML表单模板。</p>
<p>这个库在构建表单时非常灵活。唯一的缺点是完全使用它需要一点学习曲线，因为本质上您是在使用API来构建表单。</p>
<p>安装 <br/>这个库有两个内置的主题可以使用。默认情况下，有引导程序:</p>
<pre class="language-bash hljs">yarn add @rjsf/core
</pre>
<p>但是如果你想使用Material UI，安装如下:</p>
<pre class="language-bash hljs">yarn add @rjsf/material-ui
</pre>
<p><strong>基本用法</strong> <br/>使用函数库有三个步骤:</p>
<ol>
<li>指定您的模式</li>
<li>添加您的自定义格式和验证规则</li>
<li>使用组件</li>
</ol>
<p>当您指定模式时，可以添加数据类型、标签以及用户输入需要遵循的可选自定义格式。如果您的任何字段有自定义格式，您还需要向<code>Form</code>组件提供<code>customFormats</code>属性。默认情况下，只有当用户提交时，表单才会被验证。但是您也可以将<code>liveValidate</code>属性设置为<code>true</code>，这样它将在用户输入数据时验证字段。对于自定义验证，您可以提供<code>validate</code>道具。这是用于验证表单中特定字段的验证函数。最后，<code>onSubmit</code>函数只有在所有字段都通过验证后才会执行:</p>
<pre class="language-react hljs">import React, { Component } from "react";
import { render } from "react-dom";
import Form from "@rjsf/core";

const schema = {
  type: "object",
  required: ["email", "age"],
  properties: {
    email: { type: "string", email: "Email Address", format: "email_address" },
    age: { type: "number" },
    done: { type: "boolean", title: "Done?", default: false },
  },
};

const customFormats = {
  email_address: /\<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="0b58204b">[email protected]</a>\S+\.\S+/,
};

function validate(formData, errors) {
  if (formData.age &lt; 18) {
    errors.age.addError("You should be 18 years old or older.");
  }
  return errors;
}

const onSubmit = ({ formData }, e) =&gt; console.log("submit: ", formData);

function ReactJsonSchemaComponent() {
  return (
    &lt;Form
      schema={schema}
      onSubmit={onSubmit}
      liveValidate={true}
      noHtml5Validate={true}
      showErrorList={false}
      customFormats={customFormats}
      validate={validate}
    /&gt;
  );
}

export default ReactJsonSchemaComponent;
</pre>
<p><strong>总结</strong></p>
<ul>
<li>基于JSON模式自动生成表单并应用验证规则</li>
<li>支持引导和材料UI HTML语义</li>
<li>由于其广泛的API，需要一点学习曲线</li>
<li>缩小和压缩后，React-json-schema-form的重量为1.3kB</li>
</ul>

<p>React Hook Form是一个轻量级的React表单验证库，主要使用钩子向HTML输入元素添加表单验证。如果您正在寻找一个高性能且易于使用的现代表单验证库，请选择这个库。</p>
<p>在这篇文章提到的所有库中。React钩子形式需要编写最少的代码来使用它。这只是一个两步的过程:使用钩子，然后在你的字段中添加一个引用。</p>
<p>这个库的另一个伟大之处是它有非常好的文档和大量的例子。您可以找到几乎所有您能想到的用例的指南，比如与现有表单集成，或者如何将它与UI库(如Material UI)一起使用。</p>
<p><strong>安装</strong></p>
<pre class="language-bash hljs">yarn add react-hook-form
</pre>
<p><strong>基本用法</strong><br/><code>useForm</code>钩子提供了实现表单验证所需的所有数据和方法。您需要将字段的名称作为强制参数传递给<code>register()</code>方法，这样字段就可以在表单中被唯一地标识。接下来，调用并析构输入组件上的<code>register()</code>方法。这就是将不受控制的组件注册到钩子中的原因。它要求你通过你需要的验证规则。或者，您也可以通过<code>message</code>属性传递您想要显示的错误消息。</p>
<p>在下面的例子中，我们使用了<code>required</code>和<code>pattern</code>规则来验证电子邮件字段:</p>
<pre class="language-react hljs">import React from 'react';
import { useForm } from "react-hook-form";

function ReactHookFormComponent() {
  const { register, handleSubmit, formState: {errors} } = useForm();
  const onSubmit = data =&gt; console.log(data);
  // {"email":"<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="3a5b58597a5d575b535614595557">[email protected]</a>"}

  return (
    &lt;form onSubmit={handleSubmit(onSubmit)}&gt;
      &lt;input {...register("email", { required: true, pattern: /\<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="4f1c640f">[email protected]</a>\S+\.\S+/ })} /&gt;
      {errors.email?.type === 'required' &amp;&amp; &lt;span&gt; This field is required&lt;/span&gt;}
      {errors.email?.type === 'pattern' &amp;&amp; &lt;span&gt; Invalid email&lt;/span&gt;}

      &lt;button type="submit"&gt;submit&lt;/button&gt;
    &lt;/form&gt;
  );
}

export default ReactHookFormComponent;
</pre>
<p><strong>总结</strong></p>
<ul>
<li>使用不受控制的表单验证来获得最佳性能</li>
<li>通过使用验证规则，如<code>required</code>、<code>min</code>、<code>max</code>、<code>pattern</code>和<a href="https://developer.mozilla.org/en-US/docs/Learn/Forms/Form_validation" target="_blank" rel="noopener">等</a>，与现有的HTML表单验证标准保持一致</li>
<li>支持本机反应。只需将HTML表单元素替换为React本地等价元素(例如<code>TextInput</code>)</li>
<li>React钩子形式不依赖于任何库</li>
<li>使您能够隔离组件并重新渲染以提高性能</li>
<li>有一个<a href="https://react-hook-form.com/form-builder" target="_blank" rel="noopener">表单生成器实用程序</a>，如果你想快速创建简单的表单</li>
<li>通过Yup库支持基于模式的验证</li>
<li>有很好的文档和示例用法</li>
<li>缩小和压缩后，React Hook Form的重量为9kB</li>
</ul>

<p>Redux Form允许你管理你的表单状态(表单输入值，表单错误等)。)通过Redux的方式。Redux Form使用存储来跟踪表单状态，因此这个库的主要缺点是它的性能。即使您已经在应用程序中使用Redux，也只在您需要现有Redux状态和表单数据之间的紧密耦合时才使用它。</p>
<p><strong>安装</strong></p>
<pre class="language-bash hljs">yarn add redux-form redux react-redux
</pre>
<p><strong>基本用法</strong> <br/>要使用Redux形式，需要从<code>redux-form</code>中提取<code>Field</code>分量和<code>reduxForm</code>高阶分量。在最低配置下，您只需要为表单传递一个惟一的名称(在本例中是<code>bio</code>)。但是在这里，我们也传入了一个验证函数。这在用户提交表单时执行。</p>
<p>要创建一个输入字段，可以使用<code>Field</code>组件。这里，我们传入用于渲染的<code>type</code>、<code>name</code>、<code>component</code>和<code>label</code>。<code>renderField()</code>函数负责返回输入组件。除了呈现标签和输入，它还呈现错误消息。这是通过Redux表单的<code>Field</code>组件实现的:</p>
<pre class="language-react hljs">import React from 'react';
import { Field, reduxForm } from 'redux-form';

const validate = values =&gt; {
  const errors = {}
  if (!values.name) {
    errors.name = 'Required';
  }

  if (!values.email) {
    errors.email = 'Required';
  } else if (!/\<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="f1a2dab1">[email protected]</a>\S+\.\S+/i.test(values.email)) {
    errors.email = 'Invalid email address'
  }
  return errors;
}

const renderField = ({
  input,
  label,
  type,
  meta: { touched, error }
}) =&gt; (
  &lt;div&gt;
    &lt;label&gt;{label}&lt;/label&gt;
    &lt;div&gt;
      &lt;input {...input} placeholder={label} type={type} /&gt;
      {touched &amp;&amp; (error &amp;&amp; &lt;span&gt;{error}&lt;/span&gt;)}
    &lt;/div&gt;
  &lt;/div&gt;
);

let BioForm = props =&gt; {
  const { handleSubmit } = props;
  return (
    &lt;form onSubmit={handleSubmit}&gt;
      &lt;div&gt;
        &lt;Field type="text" name="name" component={renderField} label="Name" /&gt;
      &lt;/div&gt;
      &lt;div&gt;
        &lt;Field type="email" name="email" component={renderField} label="Email" /&gt;
      &lt;/div&gt;
      &lt;button type="submit"&gt;Submit&lt;/button&gt;
    &lt;/form&gt;
  );
}

BioForm = reduxForm({
  form: 'bio',
  validate
})(BioForm);

export default BioForm;
</pre>
<p>要将所有这些放在一起，将<code>formReducer</code>包含到现有的reducers中，然后将一个<code>onSubmit</code>处理程序传递给表单组件:</p>
<pre class="language-react hljs">import React, { Component } from 'react';
import { createStore, combineReducers } from 'redux';
import { reducer as formReducer } from 'redux-form';
import { Provider } from 'react-redux';
import BioForm from './components/BioForm';

const rootReducer = combineReducers({
  // your existing reducers..
  form: formReducer
});

const store = createStore(rootReducer);

class ReduxFormComponent extends Component {
  submit = values =&gt; {
    console.log('submit: ', values);
  }

  render() {
    return (
      &lt;Provider store={store}&gt;
        &lt;BioForm onSubmit={this.submit} /&gt;
      &lt;/Provider&gt;
    );
  }
}

export default ReduxFormComponent;
</pre>
<p><strong>总结</strong></p>
<ul>
<li>Redux Form通过Redux库管理表单状态</li>
<li>比这里提到的大多数库都要重。重量<a href="https://bundlephobia.com/result?p=redux-form@7.1.2" target="_blank" rel="noopener"> 24.4kB </a>(缩小+gzip)</li>
<li>Redux格式只能与React和Redux一起使用</li>
<li>Redux表单只有在现有Redux状态和表单数据之间需要紧密耦合时才有用</li>
</ul>

<p>Formsy是React的一个表单输入生成器和验证器。它对表单验证规则使用简单的语法。它还包括不同表单状态的处理程序，比如<code>onSubmit</code>和<code>isValid</code>。如果您正在寻找构建和管理表单的一体化解决方案，Formsy是一个不错的选择。这个库最大的缺点是不支持React钩子。</p>
<p><strong>安装</strong></p>
<pre class="language-bash hljs">yarn add formsy-react
</pre>
<p><strong>基本用法</strong> <br/> Formsy类似于Unform，它要求你创建自己的定制组件，用<code>withFormsy</code>高阶组件包装。这提供了操作输入组件和有条件地显示错误消息所需的所有属性和方法:</p>
<pre class="language-react hljs">import React, { Component } from 'react';
import { withFormsy } from 'formsy-react';

class FormsyInput extends Component {
  constructor(props) {
    super(props);
    this.changeValue = this.changeValue.bind(this);
  }

  changeValue(event) {
    this.props.setValue(event.currentTarget.value);
  }

  render() {
    const errorMessage = this.props.errorMessage;

    return (
      &lt;div&gt;
        &lt;input onChange={this.changeValue} type="text" value={this.props.value || ''} /&gt;
        &lt;span&gt;{!this.props.isPristine ? errorMessage : ''}&lt;/span&gt;
      &lt;/div&gt;
    );
  }
}

export default withFormsy(FormsyInput);
</pre>
<p>一旦创建了自定义组件，现在就可以在表单中使用它了。要创建一个表单，应该使用<code>Formsy</code>组件。这就需要<code>onValidSubmit</code>道具了。只有当所有表单字段都有有效输入时，才会执行此操作。在下面的例子中，我们使用了<code>isEmail</code>验证器，但是还有<a href="https://github.com/formsy/formsy-react/blob/master/API.md#validators" target="_blank" rel="noopener">许多其他的</a>可以使用:</p>
<pre class="language-react hljs">import React, { Component } from 'react';
import Formsy from 'formsy-react';
import FormsyInput from './components/FormsyInput';

export default class App extends Component {

  submit(model) {
    console.log('valid form: ', model);
    // {email: "<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="7c1d1e1f3c1b111d1510521f1311">[email protected]</a>"}
  }

  render() {
    return (
      &lt;Formsy onValidSubmit={this.submit}&gt;
        &lt;FormsyInput name="email" validations="isEmail" validationError="This is not a valid email" required /&gt;
        &lt;button type="submit"&gt;
          Submit
        &lt;/button&gt;
      &lt;/Formsy&gt;
    );
  }
}
</pre>
<p><strong>总结</strong></p>
<ul>
<li>Formsy是较早的React表单验证库之一</li>
<li>包括自己的验证规则，如<code>isEmail</code>和<code>isUrl</code></li>
<li>需要创建自定义表单输入组件才能使用</li>
<li>没有对React钩子的官方支持，这使得代码看起来更加复杂</li>
<li>缩小和压缩后，Formsy的重量为9.9kB</li>
</ul>

<p>简单的React验证器是一个受Laravel启发的React表单验证库。在本文讨论的所有库中，这个库拥有最多的<a href="https://github.com/dockwa/simple-react-validator#rules" target="_blank" rel="noopener">内置验证规则</a>。</p>
<p><strong>安装</strong></p>
<pre class="language-bash hljs">yarn add simple-react-validator
</pre>
<p><strong>基本用法</strong><br/>GitHub repo中的例子并没有真正使用钩子，所以你必须再深入一点，找出如何使用钩子。在下面的代码中，您可以看到它主要使用受控组件，因此您必须独立管理表单状态。这个库的另一个缺点是每次需要显示错误消息时都必须使用<code>forceUpdate</code>:</p>
<pre class="language-react hljs">import React, { useState, useRef } from "react";
import SimpleReactValidator from "simple-react-validator";

function SimpleReactValidatorComponent() {
  const [email, setEmail] = useState("");
  const simpleValidator = useRef(new SimpleReactValidator());
  const [, forceUpdate] = useState();

  const form = React.createRef();

  const submitForm = () =&gt; {
    const formValid = simpleValidator.current.allValid();
    if (!formValid) {
      simpleValidator.current.showMessages(true);
      forceUpdate(1)
    } else {
      console.log('submit form.');
    }
  };

  return (
    &lt;form ref={form}&gt;
      &lt;label&gt;Email&lt;/label&gt;
      &lt;input
        name="email"
        type="text"
        value={email}
        onChange={(e) =&gt; setEmail(e.target.value)}
        onBlur={() =&gt; {
          simpleValidator.current.showMessageFor("email")
          forceUpdate(1);
        }}
      /&gt;

      {simpleValidator.current.message("email", email, "required|email")}
      &lt;button type="button" onClick={submitForm}&gt;submit&lt;/button&gt;
    &lt;/form&gt;
  );
}

export default SimpleReactValidatorComponent;
</pre>
<p><strong>总结</strong></p>
<ul>
<li>许多基于Laravel的内置验证规则</li>
<li>将状态用于窗体状态管理</li>
<li>对错误消息提供本地化支持</li>
<li>没有官方的React钩子支持</li>
<li>当缩小和压缩时，简单的React验证程序重<a href="https://bundlephobia.com/result?p=simple-react-validator@1.4.6" target="_blank" rel="noopener"> 4kB </a></li>
</ul>

<p><code>rc-field-form</code>是一个高性能的表单组件库，具有强大的类型脚本支持。文档没有详细解释这个库的用法。你必须理解来自<a href="https://github.com/react-component/field-form/tree/master/docs/examples" target="_blank" rel="noopener">例子</a>的用例。</p>
<p><strong>安装</strong></p>
<pre class="language-bash hljs">yarn add rc-field-form
</pre>
<p><strong>基本</strong> <strong> u <em> <em/> </em> </strong>贤者<br/><code>&lt;Form /&gt;</code>组件用于包装表单输入字段。当表单成功提交后，<code>onFinish</code> prop用表单值触发回调函数。类似地，当表单中出现错误时，<code>onFinishFailed</code> prop会调用一个带有错误值的回调函数。</p>
<p>您可以用<code>&lt;Field /&gt;</code>组件包装您的定制<code>&lt;Input /&gt;</code>组件，并为输入字段传递<code>name</code>和验证规则。<code>Form.useForm()</code>钩子可以用来访问表单中的错误和值。</p>
<pre class="language-react hljs">import Form, { Field } from "rc-field-form";
const Input = ({ value = "", ...props }) =&gt; &lt;input value={value} {...props} /&gt;;

const Demo = () =&gt; {
  const [form] = Form.useForm();
  const onSubmit = (v) =&gt; {
    console.log(v);
  };

  const onError = (errors) =&gt; {
    console.log(errors);
  };

  const renderFieldErrors = (errors) =&gt;
    errors.map((err) =&gt; &lt;p key={err}&gt;{err}&lt;/p&gt;);

  return (
    &lt;Form form={form} onFinish={onSubmit} onFinishFailed={onError}&gt;
      {() =&gt; {
        const emailErrors = form.getFieldError("email");
        return (
          &lt;&gt;
            &lt;Field name="email" rules={[{ required: true, type: "email" }]}&gt;
              &lt;Input placeholder="Email" /&gt;
            &lt;/Field&gt;
            {renderFieldErrors(emailErrors)}
            &lt;div&gt;
              &lt;button&gt;Submit&lt;/button&gt;
            &lt;/div&gt;
          &lt;/&gt;
        );
      }}
    &lt;/Form&gt;
  );
};
</pre>
<p><strong>总结</strong></p>
<ul>
<li>支持反应和反应原生</li>
<li>具有类型脚本支持</li>
<li>利用<a href="https://github.com/yiminghe/async-validator/" target="_blank" rel="noopener">异步验证器</a>库进行验证</li>
<li>内置<a href="https://github.com/yiminghe/async-validator/" target="_blank" rel="noopener">挂钩支架</a></li>
<li>缩小和压缩后，rc-field-form的重量高达<a href="https://bundlephobia.com/package/rc-field-form@1.24.0" target="_blank" rel="noopener"> 16.6kB </a></li>
</ul>
<h2 id="form-validation-libraries-to-avoid">要避免的表单验证库</h2>
<p>如果你正在开始一个新项目，或者只是在寻找一个现代的、积极维护的库，最好避免下面的库。这些库要么不再被主动维护，要么使用过时的React API:</p>

<h2 id="other-form-libraries">其他表单库</h2>
<p>下面是其他表单库的列表。这些库的功能与我们已经介绍过的库基本相同，所以我将让您自己探索它们:</p>

<h2 id="conclusion">结论</h2>
<p>在本文中，我们看了一些最流行和最有趣的React表单验证库。如您所见，它们中的大多数都有类似的直观API来管理表单和验证错误。根据您的需求，每种方法都有其优缺点。但是在大多数情况下，使用Formik、React Final Form或React Hook Form都不会出错。</p>
<p>本文只是对React可用表单解决方案的总结。如果需要更技术性的对比，一定要看下面:<a href="https://blog.logrocket.com/react-hook-form-vs-formik-a-technical-and-performance-comparison/" target="_blank" rel="noopener"> React Hook Form vs. Formik:一个技术和性能的对比</a>。</p><div class="code-block code-block-17">
<div class="blog-plug inline-plug react-plug" vwo-el-id="26283398190">
<h2 vwo-el-id="41600691720">使用LogRocket消除传统反应错误报告的噪音</h2>
<a href="https://lp.logrocket.com/blg/react-signup-issue-free" target="_blank" vwo-el-id="19356441070">LogRocket
</a><p>是一款React analytics解决方案，可保护您免受数百个误报错误警报的影响，只针对少数真正重要的项目。LogRocket告诉您React应用程序中实际影响用户的最具影响力的bug和UX问题。</p><a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="19356441380">
<img class="first-react-image alignnone size-full wp-image-46 jetpack-lazy-image jetpack-lazy-image--handled" src="../Images/f300c244a1a1cf916df8b4cb02bec6c6.png" vwo-el-id="18272717540" data-lazy-loaded="1" data-original-src="https://files.readme.io/27c94e7-Image_2017-06-05_at_9.46.04_PM.png"/>
</a>
<a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="19356441690">
<img class="second-react-image alignnone size-full wp-image-46 jetpack-lazy-image jetpack-lazy-image--handled" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" vwo-el-id="30720362350" data-lazy-loaded="1" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/>
</a>
<a href="https://lp.logrocket.com/blg/react-signup-issue-free" target="_blank" rel="noopener noreferrer" vwo-el-id="35866400580">LogRocket
</a><p>自动聚合客户端错误、反应错误边界、还原状态、缓慢的组件加载时间、JS异常、前端性能指标和用户交互。然后，LogRocket使用机器学习来通知您影响大多数用户的最具影响力的问题，并提供您修复它所需的上下文。</p><p vwo-el-id="28675661060">关注重要的React bug—<a class="signup" href="https://lp.logrocket.com/blg/react-signup-issue-free" target="_blank" rel="noopener noreferrer" vwo-el-id="40093418840">今天就试试LogRocket】。</a></p>
</div></div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
<html>
<head>
<title>Using Vuex 4 with Vue 3 - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>使用Vuex 4和Vue 3 - LogRocket博客</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/using-vuex-4-with-vue-3/#0001-01-01">https://blog.logrocket.com/using-vuex-4-with-vue-3/#0001-01-01</a></blockquote><div><article class="article-post">
<p>编者按:这篇文章在2021年8月被审查和更新，以包括新的信息。</p>
<h2>Vue 3中Vuex还有存在的必要吗？</h2>
<p>Vue 3中的组合API附带了一些特性，如<a href="https://blog.logrocket.com/provide-inject-vue-js-3-composition-api/" target="_blank" rel="noopener">提供/注入API </a>和一个新的反应系统，它允许我们在组件外部创建独立的反应变量，并将其导入到我们想要使用的任何组件中。</p>
<p>这两者都可以做Vuex的工作，但不足以完全取代Vuex。我们来看看为什么Vuex是仍然有必要的，即使是在Vue 3中。</p>
<p>首先，Vuex提供了Vue 3特性所没有的高级调试功能。这对开发人员来说是一个巨大的奖励，因为没有人愿意花那么多时间去调试！</p>
<p>其次，Vuex有扩展其功能的插件。大多数插件的功能都可以用组合API来复制，但是Vuex做得更好，结构更有条理。</p>
<p>简短的回答是:是的。Vuex是Vue应用的首选状态管理解决方案，<a href="https://next.vuex.vuejs.org/" target="_blank" rel="noopener"> Vuex 4 </a>是与Vue 3兼容的版本。</p>
<p>但是，请注意，使用Vuex进行状态管理取决于应用程序的复杂性。在一个大的应用程序中，Vuex可能是多余的，在这种情况下，Provide/Inject API或Composition API的反应特性可能是一个更好的选择。如果您需要进一步的信息，您可以阅读更多关于<a href="https://blog.logrocket.com/do-you-really-need-vuex/" target="_blank" rel="noopener">何时以及何时不使用Vuex </a>的信息。</p>
<p>在本教程中，我们将探索如何使用Vuex 4与Vue 3。</p>
<h2>正在安装vuex for vue 3</h2>
<p>我们可以通过几种方式用Vue 3安装Vuex，其中一种就是使用script标签。</p>
<p>要使用脚本标记方法，我们可以编写:</p>
<pre>&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
  &lt;head&gt;
    &lt;script src="https://unpkg.com/<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="f5838090b59b908d81">[email protected]</a>"&gt;&lt;/script&gt;
    &lt;script src="https://unpkg.com/<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="394f4c5c41790d17091709">[email protected]</a>/dist/vuex.global.js"&gt;&lt;/script&gt;
    &lt;title&gt;App&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;div id="app"&gt;
      &lt;button&gt;increment&lt;/button&gt;
      &lt;p&gt;&lt;/p&gt;
    &lt;/div&gt;
    &lt;script&gt;

      const app = Vue.createApp();
      app.mount("#app");
    &lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;
</pre>
<p>上面，我们添加了Vuex 4和Vue的脚本，然后我们可以在代码中使用Vuex全局对象。</p>
<h2>创建数据存储</h2>
<p>Vuex <code>store</code>是一个对象，它包装了我们应用程序的所有状态，并使我们能够访问诸如突变、动作和getters之类的特性，以便在我们的组件中访问或更新全局状态。</p>
<p>为了创建一个存储，我们用一个对象调用<code>Vuex.Store</code>构造函数，这个对象包括我们想要添加的状态和突变，以创建一个基本的存储。</p>
<p><code>States</code>是在我们的Vuex商店中存储数据的属性；他们让我们从Vue 3应用的任何地方访问数据。</p>
<p>一旦我们创建了我们的商店，我们将它传递给<code>Vue.createApp</code>方法，以将商店添加到我们的应用程序中。<code>app.use(store);</code>方法调用让我们可以使用Vue 3应用程序中的商店。</p>
<p>然后，我们定义应用程序的状态，在本例中是<code>count</code>，并创建变异<code>increment</code>，这样我们就可以调用它来更新<code>count</code>的值。突变是让我们修改Vuex存储中的状态的功能。</p>
<p>然后，我们可以使用<code>this.$store</code>属性来获取状态并操作我们的存储。<code>this.$store.commit</code>方法让我们将突变提交给存储。</p>
<p>我们提交存储中的<code>increment</code>突变来更新<code>count</code>状态。因此，当我们在模板代码中单击increment按钮时，<code>count</code> Vuex状态将随着<code>count</code> computed属性一起更新。</p>
<p>下面是我们的代码应该是什么样子:</p>
<pre>&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
  &lt;head&gt;
    &lt;script src="https://unpkg.com/<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="cabcbfaf8aa4afb2be">[email protected]</a>"&gt;&lt;/script&gt;
    &lt;script src="https://unpkg.com/<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="403635253800746e706e70">[email protected]</a>/dist/vuex.global.js"&gt;&lt;/script&gt;
    &lt;title&gt;App&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;div id="app"&gt;
      &lt;button @click="increment"&gt;increment&lt;/button&gt;
      &lt;p&gt;{{count}}&lt;/p&gt;
    &lt;/div&gt;
    &lt;script&gt;
      const store = new Vuex.Store({
        state: {
          count: 0
        },
        mutations: {
          increment(state) {
            state.count++;
          }
        }
      });

      const app = Vue.createApp({
        methods: {
          increment() {
            this.$store.commit("increment");
          }
        },
        computed: {
          count() {
            return this.$store.state.count;
          }
        }
      });
      app.use(store);
      app.mount("#app");
    &lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;
</pre>
<h2>使用getters在Vue 3中添加存储状态</h2>
<p>为了更容易地将存储状态添加到我们的应用程序中，我们可以使用getters。Getters是返回一个状态的函数，或者返回已经被操作或与其他值组合的状态。</p>
<p>例如，我们可以通过编写以下内容来添加一个getter:</p>
<pre>&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
  &lt;head&gt;
    &lt;script src="https://unpkg.com/<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="88fefdedc8e6edf0fc">[email protected]</a>"&gt;&lt;/script&gt;
    &lt;script src="https://unpkg.com/<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="681e1d0d10285c46584658">[email protected]</a>/dist/vuex.global.js"&gt;&lt;/script&gt;
    &lt;title&gt;App&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;div id="app"&gt;
      &lt;button @click="increment"&gt;increment&lt;/button&gt;
      &lt;p&gt;{{doubleCount}}&lt;/p&gt;
    &lt;/div&gt;
    &lt;script&gt;
      const store = new Vuex.Store({
        state: {
          count: 0
        },
        mutations: {
          increment(state) {
            state.count++;
          }
        },
        getters: {
          doubleCount: (state) =&gt; {
            return state.count * 2;
          }
        }
      });

      const app = Vue.createApp({
        methods: {
          increment() {
            this.$store.commit("increment");
          }
        },
        computed: {
          ...Vuex.mapGetters(["doubleCount"])
        }
      });
      app.use(store);
      app.mount("#app");
    &lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;
</pre>
<p>我们添加了<code>doubleCount</code> getter，它返回乘以2的<code>count</code>状态。然后，在组件中，我们用getter的名称调用<code>Vuex.mapGetters</code>方法，将它映射到一个计算属性。我们在模板中也有它，所以我们可以看到它的值。</p>
<p>如果我们想要一个方法作为getter，我们可以在getter中返回一个函数。例如，我们可以写:</p>
<pre>&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
  &lt;head&gt;
    &lt;script src="https://unpkg.com/<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="f2848797b29c978a86">[email protected]</a>"&gt;&lt;/script&gt;
    &lt;script src="https://unpkg.com/<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="81f7f4e4f9c1b5afb1afb1">[email protected]</a>/dist/vuex.global.js"&gt;&lt;/script&gt;
    &lt;title&gt;App&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;div id="app"&gt;
      &lt;div&gt;
        &lt;p&gt;{{getTodoById(1).text}}&lt;/p&gt;
      &lt;/div&gt;
    &lt;/div&gt;
    &lt;script&gt;
      const store = new Vuex.Store({
        state: {
          todos: [
            { id: 1, text: "drink", done: true },
            { id: 2, text: "sleep", done: false }
          ]
        },
        getters: {
          getTodoById: (state) =&gt; (id) =&gt; {
            return state.todos.find((todo) =&gt; todo.id === id);
          }
        }
      });

      const app = Vue.createApp({
        computed: {
          ...Vuex.mapGetters(["getTodoById"])
        }
      });
      app.use(store);
      app.mount("#app");
    &lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;
</pre>
<p>我们有了<code>todos</code> Vuex存储状态，我们想通过它的<code>id</code>属性值从中获得一个条目。为此，我们有了<code>getTodosById</code> getter方法，它返回一个函数。该函数随后通过调用<code>find</code>从<code>state.todos</code>数组中返回条目，以通过其<code>id</code>值获得值。</p>
<p>在组件中，我们以同样的方式调用<code>Vuex.mapGetters</code>来将方法映射到计算的属性。然后，我们可以调用它返回的函数，通过它的<code>id</code>值来获取待办事项。因此，<code>'drink'</code>应该显示在浏览器屏幕上，因为这里有<code>id: 1</code>。</p>
<h2>用突变修改状态</h2>
<p>我们在前面的例子中已经看到了一个突变。这只是一种我们可以用来修改状态的方法。</p><div class="code-block code-block-54">
<hr/>
<h3>更多来自LogRocket的精彩文章:</h3>

<hr/></div>
<p>一个突变方法可以接受一个有效载荷，这个有效载荷可以用来修改一个状态值。例如，我们可以写:</p>
<pre>&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
  &lt;head&gt;
    &lt;script src="https://unpkg.com/<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="11676474517f746965">[email protected]</a>"&gt;&lt;/script&gt;
    &lt;script src="https://unpkg.com/<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="83f5f6e6fbc3b7adb3adb3">[email protected]</a>/dist/vuex.global.js"&gt;&lt;/script&gt;
    &lt;title&gt;App&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;div id="app"&gt;
      &lt;button @click="increment"&gt;increment&lt;/button&gt;
      &lt;p&gt;{{count}}&lt;/p&gt;
    &lt;/div&gt;
    &lt;script&gt;
      const store = new Vuex.Store({
        state: {
          count: 0
        },
        mutations: {
          increment(state, n) {
            state.count += n;
          }
        }
      });
      const app = Vue.createApp({
        methods: {
          increment() {
            this.$store.commit("increment", 5);
          }
        },
        computed: {
          count() {
            return this.$store.state.count;
          }
        }
      });
      app.use(store);
      app.mount("#app");
    &lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;
</pre>
<p>我们的<code>increment</code>突变方法有一个<code>n</code>参数，用于增加<code>count</code>状态的值。然后，我们调用带有第二个参数的<code>this.$store.commit</code>方法，将值传递给<code>increment</code>方法。<code>n</code>现在应该是<code>5</code>，所以<code>count</code> Vuex状态将增加5。</p>
<h2>对象样式变异提交</h2>
<p>在某些情况下，我们可能需要传递多个数据属性来更新我们的Vuex状态，我们可以利用对象样式提交。这也有助于使我们的提交更具描述性。</p>
<p>例如，我们可以写:</p>
<pre>&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
  &lt;head&gt;
    &lt;script src="https://unpkg.com/<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="a0d6d5c5e0cec5d8d4">[email protected]</a>"&gt;&lt;/script&gt;
    &lt;script src="https://unpkg.com/<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="82f4f7e7fac2b6acb2acb2">[email protected]</a>/dist/vuex.global.js"&gt;&lt;/script&gt;
    &lt;title&gt;App&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;div id="app"&gt;
      &lt;button @click="increment"&gt;increment&lt;/button&gt;
      &lt;p&gt;{{count}}&lt;/p&gt;
    &lt;/div&gt;
    &lt;script&gt;
      const store = new Vuex.Store({
        state: {
          count: 0
        },
        mutations: {
          increment(state, { amount }) {
            state.count += amount;
          }
        }
      });
      const app = Vue.createApp({
        methods: {
          increment() {
            this.$store.commit({
              type: "increment",
              amount: 5
            });
          }
        },
        computed: {
          count() {
            return this.$store.state.count;
          }
        }
      });
      app.use(store);
      app.mount("#app");
    &lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;
</pre>
<p>在这个代码片段中，我们用一个具有<code>type</code>和<code>amount</code>属性的对象调用了<code>this.$store.commit</code>。</p>
<p><code>type</code>属性用于查找要调用的变异方法的名称。因此，我们将调用<code>increment</code>突变方法，因为这是<code>type</code>的值。其他属性将与我们作为<code>increment</code>方法的第二个参数传递的对象一起传递。</p>
<p>因此，我们从第二个参数<code>increment</code>中获取<code>amount</code>属性，并使用它来更新Vuex商店的<code>count</code>状态。</p>
<h2>带动作的Vuex中的异步编码</h2>
<p>突变确实有一些局限性。变异方法必须是同步的，这样就可以用Vuex跟踪它们的执行顺序。然而，Vuex有动作方法，让我们运行突变来修改状态。</p>
<p>动作可以运行任何类型的代码，包括异步代码。例如，我们可以写:</p>
<pre>&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
  &lt;head&gt;
    &lt;script src="https://unpkg.com/<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="ff898a9abf919a878b">[email protected]</a>"&gt;&lt;/script&gt;
    &lt;script src="https://unpkg.com/<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="443231213c04706a746a74">[email protected]</a>/dist/vuex.global.js"&gt;&lt;/script&gt;
    &lt;title&gt;App&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;div id="app"&gt;
      &lt;p&gt;{{answer}}&lt;/p&gt;
    &lt;/div&gt;
    &lt;script&gt;
      const store = new Vuex.Store({
        state: {
          answer: ""
        },
        mutations: {
          setAnswer(state, answer) {
            state.answer = answer;
          }
        },
        actions: {
          async getAnswer(context) {
            const res = await fetch("https://yesno.wtf/api");
            const answer = await res.json();
            context.commit("setAnswer", answer);
          }
        }
      });
      const app = Vue.createApp({
        mounted() {
          this.$store.dispatch("getAnswer");
        },
        computed: {
          answer() {
            return this.$store.state.answer;
          }
        }
      });
      app.use(store);
      app.mount("#app");
    &lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;
</pre>
<p>这将添加<code>setAnswer</code>动作，该动作作为<code>actions</code>属性的方法添加。<code>context</code>参数有<code>commit</code>方法，让我们提交突变。参数是突变的名称。</p>
<p><code>getAnswer</code>动作方法是异步的，它调用<code>context.commit</code>方法来提交<code>setAnswer</code>变异。第二个参数中的<code>answer</code>作为<code>answer</code>参数的值被传递给<code>setAnswer</code>方法，并被设置为<code>state.answer</code>属性的值。</p>
<p>然后，在组件中，我们可以通过使用<code>this.$store.state.answer</code>属性来获取<code>answer</code>。在<code>mounted</code>钩子中，我们调用<code>this.$store.dispatch("getAnswer");</code>来调度<code>getAnswer</code>动作。因此，我们应该在模板中看到一个带有答案的对象。</p>
<p><img data-attachment-id="65007" data-permalink="https://blog.logrocket.com/using-vuex-4-with-vue-3/object-answer-result/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/10/object-answer-result.jpeg" data-orig-size="730,351" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;1&quot;}" data-image-title="object-answer-result" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/10/object-answer-result-300x144.jpeg" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/10/object-answer-result.jpeg" decoding="async" class="aligncenter size-full wp-image-65007 jetpack-lazy-image" src="../Images/fccc0fb7cf214090b99a72cd6dabdb78.png" alt="The result of the getAnswer action" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2020/10/object-answer-result.jpeg 730w, https://blog.logrocket.com/wp-content/uploads/2020/10/object-answer-result-300x144.jpeg 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2020/10/object-answer-result.jpeg?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/10/object-answer-result.jpeg"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="65007" data-permalink="https://blog.logrocket.com/using-vuex-4-with-vue-3/object-answer-result/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/10/object-answer-result.jpeg" data-orig-size="730,351" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;1&quot;}" data-image-title="object-answer-result" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/10/object-answer-result-300x144.jpeg" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/10/object-answer-result.jpeg" decoding="async" loading="lazy" class="aligncenter size-full wp-image-65007" src="../Images/fccc0fb7cf214090b99a72cd6dabdb78.png" alt="The result of the getAnswer action" srcset="https://blog.logrocket.com/wp-content/uploads/2020/10/object-answer-result.jpeg 730w, https://blog.logrocket.com/wp-content/uploads/2020/10/object-answer-result-300x144.jpeg 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/10/object-answer-result.jpeg"/></noscript>
<h2>结论</h2>
<p>Vuex 4和以前版本的Vuex没有太大的不同；v4更新主要是为了<a href="https://blog.logrocket.com/handling-authentication-vuejs-using-vuex-vue-router-and-auth0/" target="_blank" rel="noopener">与Vue 3 </a>的兼容性。</p>
<p>它有相同的部分，如getters、mutations和actions，用于获取和设置Vuex存储状态。</p><div class="code-block code-block-20">
<div class="blog-plug inline-plug vue-inline"><h2>像用户一样体验您的Vue应用</h2><p>调试Vue.js应用程序可能会很困难，尤其是当用户会话期间有几十个(如果不是几百个)突变时。如果您对监视和跟踪生产中所有用户的Vue突变感兴趣，</p><a href="https://lp.logrocket.com/blg/vue-signup" target="_blank">try LogRocket</a><p>. </p><a class="signup" href="https://lp.logrocket.com/blg/vue-signup" target="_blank" rel="noopener noreferrer"><img class="alignnone size-full wp-image-46 jetpack-lazy-image" src="../Images/0d269845910c723dd7df26adab9289cb.png" alt="LogRocket Dashboard Free Trial Banner" data-lazy-src="https://files.readme.io/00591d0-687474703a2f2f692e696d6775722e636f6d2f6a3049327856572e706e67.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://files.readme.io/00591d0-687474703a2f2f692e696d6775722e636f6d2f6a3049327856572e706e67.png"/><noscript><img data-lazy-fallback="1" class="alignnone size-full wp-image-46" src="../Images/0d269845910c723dd7df26adab9289cb.png" alt="LogRocket Dashboard Free Trial Banner" data-original-src="https://files.readme.io/00591d0-687474703a2f2f692e696d6775722e636f6d2f6a3049327856572e706e67.png"/></noscript></a><a href="https://lp.logrocket.com/blg/vue-signup" target="_blank" rel="noopener noreferrer">https://logrocket.com/signup/</a><p>LogRocket 就像是网络和移动应用程序的DVR，记录你的Vue应用程序中发生的一切，包括网络请求、JavaScript错误、性能问题等等。您可以汇总并报告问题发生时应用程序的状态，而不是猜测问题发生的原因。</p><p>LogRocket Vuex插件将Vuex突变记录到LogRocket控制台，为您提供导致错误的环境，以及出现问题时应用程序的状态。</p><p>现代化您调试Vue应用的方式- <a class="signup" href="https://lp.logrocket.com/blg/vue-signup" target="_blank" rel="noopener noreferrer">开始免费监控</a>。</p></div>


</div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
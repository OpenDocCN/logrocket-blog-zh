<html>
<head>
<title>What are React pure functional components? - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>什么是React纯功能组件？- LogRocket博客</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/what-are-react-pure-functional-components/#0001-01-01">https://blog.logrocket.com/what-are-react-pure-functional-components/#0001-01-01</a></blockquote><div><article class="article-post">
<p><strong> <em>编者按:</em> </strong> <em>本帖更新于2022年3月23日，以确保所有包都是最新的。</em></p>
<p>React是一个用于构建用户界面组件的开源JavaScript库。作为2021年最受欢迎的前端库之一，React在撰写本文时拥有近570万用户和庞大的开发者社区。React可以在从网络到移动设备的各种平台上运行。</p>
<p>在本教程中，我们将学习如何使用<a href="https://reactjs.org/docs/react-api.html#reactpurecomponent"> <code>React.PureComponent</code> </a>和<a href="https://reactjs.org/docs/react-api.html#reactmemo"> <code>React.memo()</code> API </a>来记忆React中的功能组件。首先，在深入一个示例之前，我们将介绍React组件的一些基础知识。我们开始吧！</p>
<h2>目录</h2>

<p>您可以在<a href="https://github.com/reactjs/rfcs"> React RFCs存储库</a>上跟上React框架的变化和建议。</p>
<h2 id="what-are-react-components">什么是React组件？</h2>
<p>像大多数现代JavaScript框架一样，React是基于组件的。组件通常被定义为其状态和属性的函数。</p>
<h3 id="react-functional-class-components">对功能组件和类组件进行反应</h3>
<p>React支持两种类型的组件，类组件和功能组件。一个<a href="https://blog.logrocket.com/fundamentals-functional-programming-react/">功能组件是一个返回JSX </a>的普通JavaScript函数。类组件是一个JavaScript类，它扩展了<code>React.Component</code>并在呈现方法中返回JSX。</p>
<p>下面的代码片段显示了一个简单的<code>ReactHeader</code>组件，它被定义为类组件和功能组件:</p>
<pre class="“language-react">// CLASS COMPONENT
class ReactHeader extends React.Component {
  render() {
    return (
      &lt;h1&gt;
        React {this.props.version || 17} Documentation
      &lt;/h1&amp;gt;
    )
  }
}


// FUNCTIONAL COMPONENT
function ReactHeader(props) {
  return (
    &lt;h1&gt;
      React {props.version || 17} Documentation
    &lt;/h1&gt;
  )
}
</pre>
<p>要复习React功能组件，请查看此视频教程:</p>
<p><iframe loading="lazy" src="https://www.youtube.com/embed/Cla1WwguArA" frameborder="0" allowfullscreen="allowfullscreen">视频</iframe></p>
<h2 id="what-is-pure-component-react">React中的纯成分是什么？</h2>
<p>基于函数式编程范例中的纯概念，如果一个函数满足以下两个条件，则称它是纯的:</p>
<ul>
<li>它的返回值仅由其输入值决定</li>
<li>对于相同的输入值，其返回值总是相同的</li>
</ul>
<p>如果React组件为相同的状态和属性呈现相同的输出，则认为它是纯的。对于这种类型的类组件，React提供了<code>PureComponent</code>基类。扩展<code>React.PureComponent</code>类的类组件被视为纯组件。</p>
<p>纯组件有一些性能改进和渲染优化，因为React为它们实现了<a href="https://reactjs.org/docs/react-component.html#shouldcomponentupdate"> <code>shouldComponentUpdate()</code> </a>方法，并对道具和状态进行了简单的比较。</p>
<h2 id="how-does-pure-component-work-react">纯组件如何在React中工作？</h2>
<p>实际上，React pure组件看起来像下面的代码:</p>
<pre class="“language-react">import React from 'react';

class PercentageStat extends React.PureComponent {

  render() {
    const { label, score = 0, total = Math.max(1, score) } = this.props;

    return (
      &lt;div&gt;
        &lt;h6&gt;{ label }&lt;/h6&gt;
        &lt;span&gt;{ Math.round(score / total * 100) }%&lt;/span&gt;
      &lt;/div&gt;
    )
  }

}

export default PercentageStat;
</pre>
<h2 id="are-react-functional-components-pure">React功能成分是否纯净？</h2>
<p>功能组件在React中非常有用，尤其是当您想要将状态管理从组件中分离出来时。这就是为什么<a href="https://blog.logrocket.com/react-component-design-patterns-2022/">它们经常被称为无状态组件</a>。</p>
<p>然而，功能组件不能利用<code>React.PureComponent</code>带来的性能改进和渲染优化，因为根据定义，它们不是类。</p>
<p>如果您希望React将一个功能组件作为一个纯组件对待，那么您必须将这个功能组件转换成一个扩展<code>React.PureComponent</code>的类组件。</p>
<p>看看下面这个简单的例子:</p>
<pre class="“language-react">// FUNCTIONAL COMPONENT
function PercentageStat({ label, score = 0, total = Math.max(1, score) }) {
  return (
    &lt;div&gt;
      &lt;h6&gt;{ label }&lt;/h6&gt;
      &lt;span&gt;{ Math.round(score / total * 100) }%&lt;/span&gt;
    &lt;/div&gt;
  )
}


// CONVERTED TO PURE COMPONENT
class PercentageStat extends React.PureComponent {

  render() {
    const { label, score = 0, total = Math.max(1, score) } = this.props;

    return (
      &lt;div&gt;
        &lt;h6&gt;{ label }&lt;/h6&gt;
        &lt;span&gt;{ Math.round(score / total * 100) }%&lt;/span&gt;
      &lt;/div&gt;
    )
  }

}
</pre>
<h2 id="using-pure-hoc-recompose">使用重组中的<code>{ pure }</code> HOC</h2>
<p>优化一个功能组件以便React可以把它当作一个纯组件来处理，这不一定要求你把组件转换成类组件。</p>
<p><a href="https://github.com/acdlite/recompose">重组</a>包提供了广泛的<a href="https://reactjs.org/docs/higher-order-components.html">高阶组件(hoc)</a>集合，对于处理功能组件非常有用。重新组合包导出一个<a href="https://github.com/acdlite/recompose/blob/master/docs/API.md#pure"> <code>[{ pure }]</code> </a> HOC，它试图通过阻止对组件的更新来优化React组件，除非一个属性发生了变化，并使用<code>shallowEqual()</code>来测试变化。</p>
<p>使用纯HOC，我们的功能组件可以包装如下:</p>
<pre class="“language-react">import React from 'react';
import { pure } from 'recompose';

function PercentageStat({ label, score = 0, total = Math.max(1, score) }) {
  return (
    &lt;div&gt;
      &lt;h6&gt;{ label }&lt;/h6&gt;
      &lt;span&gt;{ Math.round(score / total * 100) }%&lt;/span&gt;
    &lt;/div&gt;
  )
}

// Wrap component using the `pure` HOC from recompose
export default pure(PercentageStat);
</pre>
<h2 id="how-to-react-memo">如何使用<code>React.memo()</code></h2>
<p>使用<code><a href="https://github.com/acdlite/recompose/blob/master/docs/API.md#pure">React.memo()</a></code>，你可以创建记忆化的功能组件，避免使用简单的道具比较来渲染不必要的更新。</p>
<p>使用<code>React.memo()</code> API，前面的功能组件可以包装如下:</p>
<pre class="“language-react">import React, { memo } from 'react';

function PercentageStat({ label, score = 0, total = Math.max(1, score) }) {
  return (
    &lt;div&gt;
      &lt;h6&gt;{ label }&lt;/h6&gt;
      &lt;span&gt;{ Math.round(score / total * 100) }%&lt;/span&gt;
    &lt;/div&gt;
  )
}

// Wrap component using `React.memo()`
export default memo(PercentageStat);
</pre>
<h3 id="react-memo-api-implementation"><code>React.memo()</code> API实现细节</h3>
<p>关于<code>React.memo()</code> API的实现，有一些事情值得考虑。</p>
<p>例如，<code>React.memo()</code>是一个高阶分量。它将一个React组件作为其第一个参数，并返回一个特殊类型的React组件，该组件允许渲染器在记忆输出的同时渲染组件。因此，如果组件的道具是浅相等的，<code>React.memo()</code>组件将保释出更新。</p>
<p><code>React.memo()</code>适用于所有React组件。传递给<code>React.memo()</code>的第一个参数可以是任何类型的React组件。但是，对于类组件，你应该使用<code>React.PureComponent</code>而不是<code>React.memo()</code>。<code>React.memo()</code>也使用<code>ReactDOMServer</code>处理服务器渲染的组件。</p>
<h3 id="custom-bailout-condition">自定义紧急救助条件</h3>
<p><code>React.memo()</code> API可以接受第二个参数，即<code>arePropsEqual()</code>函数。<code>React.memo()</code>的默认行为是肤浅地比较组件道具。但是，使用<code>arePropsEqual()</code>功能，您可以自定义组件更新的紧急情况。<code>arePropsEqual()</code>功能由两个参数<code>prevProps</code>和<code>nextProps</code>定义。</p>
<p>当道具被比较为相等时,<code>arePropsEqual()</code>函数返回<code>true</code>,从而防止组件被重新渲染，当道具不相等时，它返回<code>false</code>。</p>
<p>在类组件中，<code>arePropsEqual()</code>函数的行为非常类似于<code>shouldComponentUpdate()</code>生命周期方法，但方式相反。以下代码片段使用了自定义紧急救助条件:</p>
<pre class="“language-react">import React, { memo } from 'react';

function PercentageStat({ label, score = 0, total = Math.max(1, score) }) {
  return (
    &lt;div&gt;
      &lt;h6&gt;{ label }&lt;/h6&gt;
      &lt;span&gt;{ Math.round(score / total * 100) }%&lt;/span&gt;
    &lt;/div&gt;
  )
}

function arePropsEqual(prevProps, nextProps) {
  return prevProps.label === nextProps.label; 
}

// Wrap component using `React.memo()` and pass `arePropsEqual`
export default memo(PercentageStat, arePropsEqual);
</pre>
<p>我们使用严格的等号运算符<code>===</code>,因为我们想在不进行转换的情况下检查值和它们的类型之间的相等性。例如，<code>"1"</code>和<code>1</code>是不一样的。他们之间的松散平等将返回真实，<code>"1" == 1 // true</code>。但是，严格的平等将是虚假的，<code>"1"=== 1 // false</code>。所以，我们要进行严格的比较。</p>
<h2 id="conclusion">结论</h2>
<p>有了<code>React.memo()</code> API，您可以享受使用功能组件和优化组件带来的性能优势。</p>
<p>在本文中，我们详细探讨了<code>React.memo()</code> API。首先，我们讨论了React中功能组件和类组件之间的区别，然后我们回顾了纯组件，学习了如何将功能组件转换为类组件。</p>
<p>我希望你喜欢这篇文章，如果你有任何问题，一定要留下评论。编码快乐！</p>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
<html>
<head>
<title>Introduction to headless browser testing - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>无头浏览器测试介绍</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/introduction-to-headless-browser-testing-44b82310b27c/#0001-01-01">https://blog.logrocket.com/introduction-to-headless-browser-testing-44b82310b27c/#0001-01-01</a></blockquote><div><article class="article-post">
<figure><img decoding="async" src="../Images/0f66ca2b38fba382ad65c24871e939e5.png" data-height="3000" data-width="5000" data-lazy-src="https://storage.googleapis.com/blog-images-backup/1*IVuEXYhSMgexLakn3afoNQ.jpeg?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" class=" jetpack-lazy-image" data-original-src="https://storage.googleapis.com/blog-images-backup/1*IVuEXYhSMgexLakn3afoNQ.jpeg"/><noscript><img data-lazy-fallback="1" decoding="async" src="../Images/0f66ca2b38fba382ad65c24871e939e5.png" data-height="3000" data-width="5000" data-original-src="https://storage.googleapis.com/blog-images-backup/1*IVuEXYhSMgexLakn3afoNQ.jpeg"/></noscript></figure>
<p>无头测试是一种在没有<em>头、</em>的情况下运行浏览器UI测试的方式，这意味着没有浏览器UI，没有任何种类的GUI。这很有用，因为当运行测试时，特别是在CI环境中，没有人“观看”视觉效果，所以不需要浏览器GUI的额外开销。</p>
<p>使用无头浏览器/执行无头测试的最大原因之一是性能，因为它让您在真实的浏览器环境中更快地运行测试。无头浏览器避免了<em> draw </em>操作，该操作处理UI及其各种像素在屏幕上的呈现。有了无头测试，我们忽略了那些<em>绘制</em>操作，无头引擎只是在后台运行相同的测试，不需要用户界面。</p>
<figure><img decoding="async" src="../Images/94b3e0f84b30cb0d321f60471481ab64.png" data-height="750" data-width="3212" data-lazy-src="https://storage.googleapis.com/blog-images-backup/1*GPjaPKNNUYHU8EsA3Z0JGA.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" class=" jetpack-lazy-image" data-original-src="https://storage.googleapis.com/blog-images-backup/1*GPjaPKNNUYHU8EsA3Z0JGA.png"/><noscript><img data-lazy-fallback="1" decoding="async" src="../Images/94b3e0f84b30cb0d321f60471481ab64.png" data-height="750" data-width="3212" data-original-src="https://storage.googleapis.com/blog-images-backup/1*GPjaPKNNUYHU8EsA3Z0JGA.png"/></noscript></figure>
<h3>作为开发人员，无头测试对你有什么帮助？</h3>
<p>通过使用无头测试，您可以保证得到一个更轻量级、资源更少、执行速度更快的脚本化自动化。您可以编写一个UI测试并将其集成到您的构建过程中，然后在后台运行它，而不是手动浏览每个页面并检查错误。</p>
<p>无头测试帮助你修复一些潜在的怪癖，这些怪癖对你的用户来说是个问题。这有助于确保一个应用程序在交付时很少或很少出现错误。</p>
<p>最后，通过无头测试，您可以生成网站的截图和pdf，从网站上抓取内容，自动提交表单，并模拟键盘输入。</p>
<h3>无头测试工具</h3>
<p>有各种各样的工具可以帮助进行无头测试，但是，我们将只关注下面的工具，因为它们易于使用。</p>
<ol>
<li>幻象</li>
<li>可怕的</li>
<li>无头铬合金</li>
<li>操纵木偶的人</li>
</ol>
<h3>幻象</h3>
<p>PhantomJS是一个可以用JavaScript API编写脚本的无头WebKit。它对各种web标准提供快速的本地支持。</p>
<p>它适用于无头网站测试、屏幕捕捉、页面自动化和网络监控。</p>
<p>幻像的一个主要用例是web应用程序的无头测试。它适用于一般的基于命令行的测试，在预提交钩子内，并作为持续集成系统的一部分。</p>
<p>PhantomJS支持使用<a href="http://casperjs.org/" target="_blank" rel="noopener noreferrer"> CasperJS </a>进行无头测试。CasperJS是一个针对幻想曲的导航脚本&amp;测试工具。它允许您使用高级功能和直接的界面来构建完整的导航场景，以完成各种规模的任务。</p>
<figure class="wp-caption"><img decoding="async" src="../Images/92e75a990f14a556f990feccce1c08e7.png" data-height="315" data-width="562" data-lazy-src="https://storage.googleapis.com/blog-images-backup/1*z4Xh7DGygNEDkhOy0udMjA.jpeg?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" class=" jetpack-lazy-image" data-original-src="https://storage.googleapis.com/blog-images-backup/1*z4Xh7DGygNEDkhOy0udMjA.jpeg"/><noscript><img data-lazy-fallback="1" decoding="async" src="../Images/92e75a990f14a556f990feccce1c08e7.png" data-height="315" data-width="562" data-original-src="https://storage.googleapis.com/blog-images-backup/1*z4Xh7DGygNEDkhOy0udMjA.jpeg"/></noscript><figcaption class="wp-caption-text">CasperJS</figcaption></figure>
<p>CasperJS附带了一个基本的测试套件，允许您运行全功能测试，还允许您通过web抓取从不包含API的网页中捕获数据。</p>
<p>要开始使用PhantomJS和CasperJS，首先必须全局安装PhantomJS。</p>
<pre># To install PhantomJS, run the command below
brew install phantomjs</pre>
<p>创建一个项目文件夹来执行测试。在那个文件夹中，用<code>npm init -y</code>初始化<code>npm</code>。接下来要做的是，将CasperJS添加到项目中。</p>
<pre>npm i casperjs</pre>
<p>接下来，让我们使用CasperJS搜索Google，并在终端中显示Google搜索的结果。</p>
<p>创建一个名为<code>caspergoogle.js</code>的文件，并用以下代码进行编辑:</p>
<figure/>
<p>在上面的代码块中，我们使用CasperJS来刮Google.com。我们使用CasperJS的API来模拟在Google.com上输入一个查询，然后在终端上显示结果。</p>
<p>我们首先创建了一个<code>links</code>数组，然后创建了一个Casper实例。</p>
<p><code>getLinks()</code>函数首先用<code>document.querySelectorAll('h3 a')</code>获取每个谷歌搜索结果的标题，然后用标准的<code>Array</code>聚合结果链接。我们等待页面用<code>this.waitForSelector()</code>函数加载，然后我们模拟用<code>this.fill()</code>函数在谷歌中输入搜索查询。</p>
<p>结果显示在终端中，在<code>casper.run()</code>功能内有<code>this.echo</code>。</p>
<p>运行命令<code>casperjs caspergoogle.js</code>查看代码的输出。如果一切正常，您应该会看到Google搜索的结果很好地显示在您的终端上。</p><div class="code-block code-block-54">
<hr/>
<h3>更多来自LogRocket的精彩文章:</h3>

<hr/></div>
<h3>可怕的</h3>
<p><a href="http://www.nightmarejs.org/" target="_blank" rel="noopener noreferrer">梦魇</a>是来自<a href="https://segment.com/" target="_blank" rel="noopener noreferrer">段</a>的高级浏览器自动化库。Nightmare公开了一些模拟用户动作的简单方法(如<code>goto</code>、<code>type</code>和<code>click</code>)，API感觉每个脚本块都是同步的，而不是深度嵌套的回调。</p>
<p>它最初是为跨没有API的站点自动执行任务而设计的，但最常用于UI测试和爬行。</p>
<p>要开始使用梦魇，你必须安装梦魇软件包。</p>
<pre>npm i nightmare</pre>
<p>让我们用梦魇写一个基本的测试。该测试检查网站是否加载成功。为此，我们需要<code>mocha</code>。<a href="https://mochajs.org/" target="_blank" rel="noopener noreferrer"> Mocha </a>是一个运行在节点和浏览器上的Javascript测试框架。</p>
<figure class="wp-caption"><img decoding="async" src="../Images/afbf9bccbf5a7f5f65bac3da8c3f7fbe.png" data-height="466" data-width="1000" data-lazy-src="https://storage.googleapis.com/blog-images-backup/1*XW6oOLoieyRtcSrfSSGSvA.jpeg?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" class=" jetpack-lazy-image" data-original-src="https://storage.googleapis.com/blog-images-backup/1*XW6oOLoieyRtcSrfSSGSvA.jpeg"/><noscript><img data-lazy-fallback="1" decoding="async" src="../Images/afbf9bccbf5a7f5f65bac3da8c3f7fbe.png" data-height="466" data-width="1000" data-original-src="https://storage.googleapis.com/blog-images-backup/1*XW6oOLoieyRtcSrfSSGSvA.jpeg"/></noscript><figcaption class="wp-caption-text">Mocha</figcaption></figure>
<p>使用以下命令安装Mocha和Nightmare作为开发依赖项:</p>
<pre>npm install --save-dev mocha
npm install --save-dev nightmare</pre>
<p>在同一个文件夹中，创建一个名为<code>test.js</code>的文件，并用以下代码编辑它:</p>
<p/>
<p>在上面的代码块中，我们写了一个测试来检查一个网站是否加载成功，没有任何错误。在第二个<code>describe()</code>块中，我们编写了一个测试用例，其中我们使用Nightmare导航到一个站点，并查看是否有任何错误。</p>
<h3>无头铬合金</h3>
<p>无头Chrome是一种在无头环境中运行Chrome浏览器的方式，以帮助自动化测试。它在最新版本的谷歌浏览器(59+)中可用。</p>
<p>Headless Chrome将Chrome和Blink渲染引擎提供的所有现代web平台功能都带到了命令行中。这是一种与网站互动的方式，不需要在屏幕上有一个窗口。</p>
<p>使用无头Chrome非常容易，因为你只需要一个终端和最新版本的Chrome。</p>
<pre>chrome --headless --disable-gpu</pre>
<p>上面的命令有可能会返回一个<code>chrome command not found</code>错误。要解决这个问题，你需要为你的Chrome安装创建一个别名。</p>
<p>运行以下命令，将<code>chrome</code>命令添加为别名。</p>
<pre>## For MacOS
## Use this for Google Chrome
alias chrome="/Applications/Google Chrome.app/Contents/MacOS/Google Chrome"
## Use this for Chrome Canary
alias chrome-canary="/Applications/Google Chrome Canary.app/Contents/MacOS/Google Chrome Canary"
## Use this for Chromium
alias chromium="/Applications/Chromium.app/Contents/MacOS/Chromium"</pre>
<p>让我们用无头Chrome执行一些基本任务。</p>
<p><strong>创建特定页面的PDF。</strong></p>
<pre>chrome --headless --disable-gpu --print-to-pdf
https://www.logrocket.com/</pre>
<p>这应该会生成整个网站的标题为<code>output.pdf</code>的PDF。</p>
<p><strong>截图</strong></p>
<pre>chrome --headless --disable-gpu --screenshot
https://www.logrocket.com/</pre>
<p>这将生成一个标题为<code>screenshot.png</code>的网站可见视窗的截图。</p>
<figure><img decoding="async" src="../Images/fc8481ed2797b8e708f42ec2d3a43c56.png" data-height="600" data-width="800" data-lazy-src="https://storage.googleapis.com/blog-images-backup/1*e8-caCvQvS6tCUBdb42gmA.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" class=" jetpack-lazy-image" data-original-src="https://storage.googleapis.com/blog-images-backup/1*e8-caCvQvS6tCUBdb42gmA.png"/><noscript><img data-lazy-fallback="1" decoding="async" src="../Images/fc8481ed2797b8e708f42ec2d3a43c56.png" data-height="600" data-width="800" data-original-src="https://storage.googleapis.com/blog-images-backup/1*e8-caCvQvS6tCUBdb42gmA.png"/></noscript></figure>
<p>要使用自定义大小来截取屏幕截图，您可以轻松地将<code>--window-size</code>标志添加到命令中。</p>
<pre>chrome --headless --disable-gpu --screenshot --window-size=1280,1696
https://www.logrocket.com/</pre>
<p>如果你想让Headless Chrome更进一步，通过编写节点代码以编程的方式执行任务/测试，这就是木偶师的用武之地。</p>
<h3>操纵木偶的人</h3>
<p>木偶师是Chrome团队开发的一个节点库。它提供了一个高级API来控制无头Chrome。它类似于上面的Phantom和NightmareJS等其他自动化测试库，但它只适用于最新版本的Chrome (Chrome 59+)。</p>
<p>Puppeteer API可用于截屏、创建pdf、导航页面和从页面获取信息。我们将编写一些示例代码来查看木偶师的工作。</p>
<p><strong>截图</strong></p>
<p>用npm包安装木偶师:</p>
<pre>npm i puppeteer</pre>
<p>此外，创建一个JavaScript文件，我们将在其中编写代码来演示木偶师，您可以将其命名为<code>puppeteer.js</code>。用下面的代码编辑新创建的文件。</p>
<p/>
<p>上面的代码块有助于使用木偶师截取一个特定站点(logrocket.com)的屏幕截图。整个代码被包装在一个异步函数中，浏览器被启动。然后创建一个页面，我们使用<code>goto()</code>功能导航到我们想要截屏的网站。</p>
<p>如果你想要一个完整的页面截图，你可以通过在<code>page.screenshot()</code>函数中设置<code>fullPage</code>为<code>true</code>来轻松实现。</p>
<pre>await page.screenshot({ path: 'https://logrocket.com', fullPage: true})</pre>
<p>在您的终端中运行命令<code>node puppeteer.js</code>，您应该在项目目录中看到标题为<code>LR.png</code>的截图。</p>
<figure class="wp-caption"><img decoding="async" src="../Images/10ed909fb6f44a4f24fc6fcb01ced727.png" data-height="600" data-width="800" data-lazy-src="https://storage.googleapis.com/blog-images-backup/1*nujdk2UYdVXHwoiXLBuNLg.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" class=" jetpack-lazy-image" data-original-src="https://storage.googleapis.com/blog-images-backup/1*nujdk2UYdVXHwoiXLBuNLg.png"/><noscript><img data-lazy-fallback="1" decoding="async" src="../Images/10ed909fb6f44a4f24fc6fcb01ced727.png" data-height="600" data-width="800" data-original-src="https://storage.googleapis.com/blog-images-backup/1*nujdk2UYdVXHwoiXLBuNLg.png"/></noscript></figure>
<p>木偶师代码截图</p>
<p><strong>生成一个PDF </strong></p>
<p>在同一个文件夹中，创建一个名为<code>puppeteerpdf.js</code>的JavaScript文件，并用以下代码进行编辑:</p>
<p/>
<p>上面的代码块有助于使用Puppeteer生成一个网站的PDF。整个代码被包装在一个异步函数中，浏览器被启动。然后创建一个页面，我们使用<code>goto()</code>功能导航到我们想要生成PDF的网站。</p>
<p>代码的<code>waitUntil: 'networkidle'</code>行意味着只有当网络活动保持“空闲”至少<code>networkIdleTimeout</code> ms(默认为1000ms)时，站点的导航才被认为是完成的。<code>page.pdf()</code>功能创建PDF文件。</p>
<p>在您的终端中运行命令<code>node puppeteerpdf.js</code>，您应该在项目目录中看到一个名为<code>YE.pdf</code>的PDF文件。</p>
<p><strong>从页面中提取值</strong></p>
<p>我们用Puppeteer做的最后一件事是以编程方式导航到一个页面，自动化表单提交和键盘输入，然后显示表单提交的结果。</p>
<p>创建一个名为<code>puppeteersearch.js</code>的文件，并用下面的代码进行编辑:</p>
<p/>
<p>在上面的代码块中，木偶师启动一个无头浏览器并导航到<code>google.com</code>。然后，我们使用<code>page.type()</code>函数定义要输入的查询，并使用<code>page.click()</code>函数模拟点击。</p>
<p><code>page.waitForSelector()</code>功能用于等待选择器，以检查是否加载了所需的内容。在这种情况下，使用<code>h3 a</code>选择器。</p>
<figure><img decoding="async" src="../Images/2a1ef7067e43f40b3d408ffeef154b29.png" data-height="702" data-width="1276" data-lazy-src="https://storage.googleapis.com/blog-images-backup/1*2vhvHwzhW6wIcO8M6JpYbw.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" class=" jetpack-lazy-image" data-original-src="https://storage.googleapis.com/blog-images-backup/1*2vhvHwzhW6wIcO8M6JpYbw.png"/><noscript><img data-lazy-fallback="1" decoding="async" src="../Images/2a1ef7067e43f40b3d408ffeef154b29.png" data-height="702" data-width="1276" data-original-src="https://storage.googleapis.com/blog-images-backup/1*2vhvHwzhW6wIcO8M6JpYbw.png"/></noscript></figure>
<p><code>page.evaluate()</code>函数允许我们在页面的上下文中运行脚本。上面的函数从Google搜索结果中获取所有链接，并将它们存储在一个数组中。</p>
<p>最后，我们将结果记录到控制台。运行命令<code>node puppeteersearch.js</code>,您应该会在终端上看到自动谷歌搜索的结果。</p>
<h3>结论</h3>
<p>在本文中，我们已经看到了作为开发人员，无头测试是如何帮助您的，并且还探索了一些无头测试工具和示例。</p>
<p>无头测试在web开发中是非常有用的工具。借助Headless测试，您可以生成网站的截图和pdf，从网站上抓取内容，自动提交表单，以及模拟键盘输入。</p>
<p>当与一个无头浏览器结合时，它允许你在一个成熟的浏览器中做你能做的任何事情，而不需要浏览器。</p>
<p><strong>进一步的学习资源</strong></p>
<ol>
<li><a href="https://segment.com/blog/ui-testing-with-nightmare/" target="_blank" rel="noopener noreferrer">用梦魇进行UI测试</a></li>
<li>谷歌浏览器的傀儡师</li>
<li><a href="https://developers.google.com/web/updates/2017/04/headless-chrome" target="_blank" rel="noopener noreferrer">无头浏览器入门</a></li>
<li><a href="https://developers.google.com/web/updates/2017/06/headless-karma-mocha-chai" target="_blank" rel="noopener noreferrer">使用无头浏览器进行自动化测试</a></li>
<li><a href="http://www.nightmarejs.org/" target="_blank" rel="noopener noreferrer">噩梦</a></li>
<li><a href="http://docs.casperjs.org/en/latest/index.html" target="_blank" rel="noopener noreferrer">卡斯珀吉斯</a></li>
</ol>
<p> </p><div class="code-block code-block-23">
<div class="blog-plug inline-plug node-plug"><h2>200只<img src="../Images/61167b9d027ca73ed5aaf59a9ec31267.png" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2019/10/green-check.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" class=" jetpack-lazy-image" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/10/green-check.png"/> <noscript> <img data-lazy-fallback="1" src="../Images/61167b9d027ca73ed5aaf59a9ec31267.png" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/10/green-check.png"/> </noscript>显示器出现故障，生产中网络请求缓慢</h2><p>部署基于节点的web应用程序或网站是容易的部分。确保您的节点实例继续为您的应用程序提供资源是事情变得更加困难的地方。如果您对确保对后端或第三方服务的请求成功感兴趣，</p><a href="https://lp.logrocket.com/blg/node-signup" target="_blank">try LogRocket</a><p>. </p><a class="signup" href="https://lp.logrocket.com/blg/node-signup" target="_blank" rel="noopener noreferrer"><img src="../Images/cae72fd2a54c5f02a6398c4867894844.png" alt="LogRocket Network Request Monitoring" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2019/12/network-request-filter-2-1.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" class=" jetpack-lazy-image" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/12/network-request-filter-2-1.png"/><noscript><img data-lazy-fallback="1" src="../Images/cae72fd2a54c5f02a6398c4867894844.png" alt="LogRocket Network Request Monitoring" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/12/network-request-filter-2-1.png"/></noscript></a><a href="https://lp.logrocket.com/blg/node-signup" target="_blank" rel="noopener noreferrer">https://logrocket.com/signup/</a><p>LogRocket 就像是网络和移动应用程序的DVR，记录下用户与你的应用程序交互时发生的一切。您可以汇总并报告有问题的网络请求，以快速了解根本原因，而不是猜测问题发生的原因。</p><p>LogRocket检测您的应用程序以记录基线性能计时，如页面加载时间、到达第一个字节的时间、慢速网络请求，还记录Redux、NgRx和Vuex操作/状态。</p><a class="signup" href="https://lp.logrocket.com/blg/node-signup" target="_blank" rel="noopener noreferrer">Start monitoring for free</a><p>. </p></div>
</div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
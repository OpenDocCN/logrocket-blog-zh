<html>
<head>
<title>Amp performance with React Server-side rendering - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>React服务器端渲染的Amp性能- LogRocket博客</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/improve-app-performance-react-server-side-rendering/#0001-01-01">https://blog.logrocket.com/improve-app-performance-react-server-side-rendering/#0001-01-01</a></blockquote><div><article class="article-post">
<p><strong> <em>编者按:</em> </strong> <em>本文于2022年5月4日更新，包括Create React App的更新信息，以及关于其他SSR框架的细节。</em></p>
<p>在本文中，我们将研究web应用程序的不同类型的呈现。我们将仔细研究React中的服务器端渲染，并检查服务器端渲染相对于传统客户端渲染的优势。</p>
<p><em>向前跳转:</em></p>

<h2 id="rendering-with-create-react-app">使用Create React应用程序渲染</h2>
<p>你们中的许多人可能会使用React CLI，更好的名称是<a href="https://create-react-app.dev" target="_blank" rel="noopener"> Create React App (CRA) </a>，来启动和运行应用程序。这种方法有许多优点；然而，用CRA建造也有一些缺点。</p>
<p>例如，当你从一个用CRA初始化的网络应用程序中<code>view source</code>浏览一个网页时，你会注意到它几乎是一个空页面，只有<code>&lt;head&gt;</code>部分，而在<code>&lt;body&gt;</code>中几乎没有任何内容。</p>
<p>这里有一个例子:</p>
<figure id="attachment_112002" aria-describedby="caption-attachment-112002" class="wp-caption aligncenter"><img data-attachment-id="112002" data-permalink="https://blog.logrocket.com/improve-app-performance-react-server-side-rendering/react-app-initialized-using-create-react-app/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/12/react-app-initialized-using-create-react-app.png" data-orig-size="720,390" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="React app initialized using Create React App" data-image-description="" data-image-caption="&lt;p&gt;React app initialized using Create React App.&lt;/p&gt;&#10;" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/12/react-app-initialized-using-create-react-app-300x163.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/12/react-app-initialized-using-create-react-app.png" decoding="async" class="wp-image-112002 size-full jetpack-lazy-image" src="../Images/1356b5fad03bb8f88609a045197c593c.png" alt="React App Initialized Using Create React App" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2020/12/react-app-initialized-using-create-react-app.png 720w, https://blog.logrocket.com/wp-content/uploads/2020/12/react-app-initialized-using-create-react-app-300x163.png 300w" data-lazy-sizes="(max-width: 720px) 100vw, 720px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2020/12/react-app-initialized-using-create-react-app.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/12/react-app-initialized-using-create-react-app.png"/><noscript><img data-lazy-fallback="1" data-attachment-id="112002" data-permalink="https://blog.logrocket.com/improve-app-performance-react-server-side-rendering/react-app-initialized-using-create-react-app/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/12/react-app-initialized-using-create-react-app.png" data-orig-size="720,390" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="React app initialized using Create React App" data-image-description="" data-image-caption="&lt;p&gt;React app initialized using Create React App.&lt;/p&gt;&#10;" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/12/react-app-initialized-using-create-react-app-300x163.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/12/react-app-initialized-using-create-react-app.png" decoding="async" loading="lazy" class="wp-image-112002 size-full" src="../Images/1356b5fad03bb8f88609a045197c593c.png" alt="React App Initialized Using Create React App" srcset="https://blog.logrocket.com/wp-content/uploads/2020/12/react-app-initialized-using-create-react-app.png 720w, https://blog.logrocket.com/wp-content/uploads/2020/12/react-app-initialized-using-create-react-app-300x163.png 300w" sizes="(max-width: 720px) 100vw, 720px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/12/react-app-initialized-using-create-react-app.png"/></noscript><figcaption id="caption-attachment-112002" class="wp-caption-text">React app initialized using Create React App.</figcaption></figure>
<p>这是因为CRA在客户端渲染你的应用程序，这意味着构建。js文件首先被下载到用户的浏览器，然后页面的其余部分开始加载。这增加了初始加载时间，并且一些web爬网程序无法对网站进行索引。</p>
<p>有没有更好的方法来渲染你的app？是啊！</p>
<p>这就是React的服务器端渲染的用武之地。</p>
<p>在本文中，我想向您介绍使用React的服务器端呈现(SSR)、使用它的原因以及一些在服务器端呈现React的流行框架。我还想谈谈SSR React什么时候没有意义。本文面向已经在客户端使用React的开发人员。</p>
<p>在深入研究React的服务器端呈现之前，让我们回顾一些不同类型的web应用程序，以便更好地理解SSR应用程序的好处。</p>
<h2 id="what-is-server-side-rendering">什么是服务器端渲染？</h2>
<p>服务器端渲染是指网页上的内容使用JavaScript在服务器上渲染，而不是在浏览器上渲染。例如，对于一个典型的PHP或WordPress站点，页面是从通过HTTP传输的内容中加载的，这些内容是在服务器上呈现的，并且是完全呈现的HTML。</p>
<p>这与用CRA构建的React应用程序形成对比，React应用程序只向客户端发送一个. js文件，客户端的浏览器JavaScript引擎在。js文件已加载。传统SSR语言/框架的例子有PHP、Java、ASP.NET和Node.js</p>
<p>在客户端库涌入之前，传统的SSR应用程序在早期网络中占主导地位。现在，服务器端渲染的React应用程序为服务器使用Node，这是与传统服务器渲染应用程序的一个关键区别(我们将在本文后面看到如何实现)。</p>
<p>与客户端渲染的应用程序相比，SSR应用程序提供了更快的初始加载时间和更好的SEO性能，但也有一些缺点。首先，每个请求都会导致一个新页面从服务器重新呈现到浏览器。这意味着每次向服务器发送请求时，所有的脚本、样式和模板都要在浏览器上重新加载，导致用户体验不佳。</p>
<h2 id="what-are-single-page-applications">什么是单页应用程序？</h2>
<p>单页应用程序(spa)或客户端呈现(CSR)应用程序使用JavaScript在浏览器中呈现内容，而不是在每次向服务器发送请求时都刷新页面。服务器发送原始HTML文档，同时内容通过浏览器的JavaScript呈现到HTML文档中。</p>
<h2 id="what-are-static-generated-applications">什么是静态生成的应用程序？</h2>
<p>静态生成的应用程序是使用静态站点生成器(如Gatsby)预先生成的，并作为静态HTML页面存储在托管服务器上。将这些静态文件部署到静态托管服务器不需要节点或其他服务器端支持。因此，当应用程序第一次在浏览器中加载时，您总是可以立即获得全部内容，然后应用程序将像常规SPA一样运行。</p>
<p>静态生成的应用程序不支持实时渲染。因此，在构建实时web应用程序(如论坛或聊天应用程序)时，这种类型的呈现并不是一个好的选择。</p>
<h2 id="why-move-to-react-server-side-rendering">为什么要转向React服务器端渲染？</h2>
<p>正如我之前所说，服务器端呈现最初意味着从服务器呈现和加载每个页面。然而，随着服务器端(通用)React的引入，情况略有不同。</p>
<p>初始页面从服务器呈现，这意味着后续页面直接从客户端加载。因此，您拥有了两个世界的优势——初始服务器端内容的强大功能加上快速的后续加载，后者只请求未来请求所需的内容。</p>
<p>除了上述好处之外，当您迁移到SSR时，您还可以获得其他一些好处:</p>
<h3 id="increased-performance">提高性能</h3>
<p><a href="https://twitter.com/arunoda" target="_blank" rel="noopener"> Arunoda Susiripala </a>，以前是来自<a href="https://youtu.be/ms2aOV06_qk" target="_blank" rel="noopener">Vercel的工程师，谈到性能</a>是转向服务器端渲染的主要原因。SSR意味着初始加载不需要加载器或旋转器。这意味着，一般来说，<a href="https://blog.logrocket.com/next-js-vs-create-react-app/" target="_blank" rel="noopener"> SSR会跑赢南车</a>。</p>
<p>SSR应用程序将JavaScript和CSS分成块，优化资源，并在服务器上呈现页面，然后提供给客户端浏览器，从而加快初始加载时间。</p>
<p>更快的加载速度为最终用户带来了更好的体验。这是许多大公司在他们的网站上采用SSR方法的原因之一。</p>
<h3 id="enhanced-seo">增强的搜索引擎优化</h3>
<p>到目前为止，您可能已经听说Google now抓取用JavaScript构建的web应用程序，所以您最好准备好服务器端呈现的内容，以便Google和其他搜索引擎抓取您的站点。<a href="https://10up.github.io/Engineering-Best-Practices/react/" target="_blank" rel="noopener">每10up </a>:</p>
<blockquote><p>注意，到目前为止，Google和Bing可以索引同步JavaScript应用程序——同步是关键词。如果您的应用程序以加载微调器开始，然后通过Ajax获取内容，爬虫将只等待几秒钟加载完成。这意味着如果在SEO很重要的页面上异步获取内容，SSR可能是必要的。</p></blockquote>
<p>借助SSR搜索引擎，爬虫可以探索页面，以提高应用程序的SEO性能。这是因为在提供给客户端之前，所有页面都在服务器上呈现了相关的元数据、段落和标题，使您能够获得传统网站SEO的好处。</p>
<h3 id="improved-user-experience">改善用户体验</h3>
<p>初始加载后，通用SSR应用程序的行为就像典型的spa一样，页面和路由之间的转换是无缝的。只有数据被来回发送，HTML内容容器不被重新呈现。</p>
<h3 id="enhanced-social-sharing">增强社交分享</h3>
<p>SSR的另一个优势是，当你通过社交媒体分享网页内容时，你会得到一个精心制作的片段和特色图片。当你只有客户端渲染的应用时，这是不可能的。</p>
<p>例如，当在LinkedIn上共享时，服务器端呈现的React应用程序看起来是这样的:</p>
<figure id="attachment_112006" aria-describedby="caption-attachment-112006" class="wp-caption aligncenter"><img data-attachment-id="112006" data-permalink="https://blog.logrocket.com/improve-app-performance-react-server-side-rendering/sharing-server-rendered-app-social-media/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/12/sharing-server-rendered-app-social-media.png" data-orig-size="693,784" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Sharing server-rendered app social media" data-image-description="" data-image-caption="&lt;p&gt;Sharing a server-rendered app on social media.&lt;/p&gt;&#10;" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/12/sharing-server-rendered-app-social-media-265x300.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/12/sharing-server-rendered-app-social-media.png" decoding="async" class="wp-image-112006 size-full jetpack-lazy-image" src="../Images/f6b91b4a2a018f1b2413156ce4577b09.png" alt="Sharing Server-Rendered App Social Media" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2020/12/sharing-server-rendered-app-social-media.png 693w, https://blog.logrocket.com/wp-content/uploads/2020/12/sharing-server-rendered-app-social-media-265x300.png 265w" data-lazy-sizes="(max-width: 693px) 100vw, 693px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2020/12/sharing-server-rendered-app-social-media.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/12/sharing-server-rendered-app-social-media.png"/><noscript><img data-lazy-fallback="1" data-attachment-id="112006" data-permalink="https://blog.logrocket.com/improve-app-performance-react-server-side-rendering/sharing-server-rendered-app-social-media/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/12/sharing-server-rendered-app-social-media.png" data-orig-size="693,784" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Sharing server-rendered app social media" data-image-description="" data-image-caption="&lt;p&gt;Sharing a server-rendered app on social media.&lt;/p&gt;&#10;" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/12/sharing-server-rendered-app-social-media-265x300.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/12/sharing-server-rendered-app-social-media.png" decoding="async" loading="lazy" class="wp-image-112006 size-full" src="../Images/f6b91b4a2a018f1b2413156ce4577b09.png" alt="Sharing Server-Rendered App Social Media" srcset="https://blog.logrocket.com/wp-content/uploads/2020/12/sharing-server-rendered-app-social-media.png 693w, https://blog.logrocket.com/wp-content/uploads/2020/12/sharing-server-rendered-app-social-media-265x300.png 265w" sizes="(max-width: 693px) 100vw, 693px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/12/sharing-server-rendered-app-social-media.png"/></noscript><figcaption id="caption-attachment-112006" class="wp-caption-text">Sharing a server-rendered app on social media.</figcaption></figure>
<h2 id="get-started-with-server-side-rendering-in-react">React中的服务器端渲染入门</h2>
<p>在没有框架的情况下开始是可能的，但我不推荐这种方法，因为React SSR应用程序中有许多考虑因素和移动部分。例如，您必须自己处理捆绑、缩小和热重新加载(以及更多)。</p>
<p>然而，如果你想走这条路，我推荐你阅读罗杰·金的教程。</p>
<h3 id="react-ssr-frameworks">React SSR框架</h3>
<p>如果你想在服务器端渲染React，我建议选择一个框架。以下是一些可以考虑的框架:</p>
<h3 id="next-js">Next.js</h3>
<p>Next.js是一个拥有强大社区的伟大框架。Next.js提供了很多内置特性，你不必担心捆绑、缩小或热重装。您可以将页面创建为文件中的React组件。</p>
<p>如果您使用过PHP，您可能会习惯于此。除了社区和支持，还有许多大公司在生产中使用Next.js，包括<a href="https://hyperion.alpha.spectrum.chat/next-js/general/companies-sites-using-next-js~e425a8b6-c9cb-4cd1-90bb-740fb3bd7541" target="_blank" rel="noopener"> npm、网飞和Auth0 </a>。</p>
<h3 id="razzle">狂欢</h3>
<p>贾里德·帕尔默的项目Razzle最近获得了很多关注。来自<a href="https://github.com/jaredpalmer/razzle" target="_blank" rel="noopener">其GitHub页面</a>:</p>
<blockquote><p>“Razzle是一个工具，它将SSR所需的所有复杂配置抽象为一个单一的依赖项，为您提供令人惊叹的开发人员体验<a href="https://github.com/facebookincubator/create-react-app" target="_blank" rel="noopener"> create-react-app </a>，但将应用程序的其余架构决策(关于框架、路由和数据获取)留给您自己。”</p></blockquote>
<p>Razzle很容易上手，默认使用React Router 4(不像Next.js没有内置路由器)。</p>
<h3 id="remix">再搅拌</h3>
<p>Remix是一个React框架，具有服务器端渲染、简单的数据获取和变化以及灵活的开发者体验，这使得构建具有良好用户体验的web应用变得容易。</p>
<p>Remix通过利用分布式系统和原生浏览器功能，而不是笨拙的静态构建，提供了快速的页面加载和流畅的过渡。因为它使用Web Fetch API而不是Node，所以它可以在任何地方运行。</p>
<h3 id="additional-alternatives">其他备选方案</h3>
<p>React不是银弹。也许你的团队更熟悉Vue或另一个JavaScript框架。也许静态站点最适合你的用例。如果您不想使用React，或者您想使用静态站点生成器，有几个备选方案。</p>
<h4 id="nuxt-js">Nuxt.js</h4>
<p><a href="https://nuxtjs.org/" target="_blank" rel="noopener"> Nuxt.js </a>是Vue.js的服务器端渲染框架，在Vue.js社区很受欢迎。如果你正在Vue.js世界中寻找Next.js或Razzle的替代品，请尝试一下。</p>
<h4 id="angular-universal">角度通用</h4>
<p><a href="https://angular.io/" target="_blank" rel="noopener"> Angular </a>还通过<a href="https://angular.io/guide/universal" target="_blank" rel="noopener"> Angular Universal </a>为服务器端渲染和预渲染解决方案提供支持。如果你正在角度世界中寻找Next.js、remix或Razzle的替代品，请尝试一下。</p>
<h4 id="sveltekit">苗条套装</h4>
<p>SvelteKit是一个基于T2的开源框架，用于快速开发高性能的网络应用。它还包括服务器端渲染，可以按应用程序或页面进行配置，允许您在不需要时关闭SSR。</p>
<h4 id="gatsby">盖茨比（姓）</h4>
<p>你会看到几乎所有流行的JavaScript开发人员都在谈论<a href="https://gatsbyjs.org/" target="_blank" rel="noopener"> Gatsby </a>。基于React的静态站点生成器<a href="https://blog.logrocket.com/is-gatsby-really-that-great-e7b19c4c1c05/" target="_blank" rel="noopener">凭借其出色的UX(用户体验)和DX(开发者体验)赢得了许多</a>的芳心。</p>
<p>准确的说，它在运行时不做SSR。相反，Gatsby在构建时使用Node.js进行服务器端呈现，在部署站点时创建静态HTML、CSS和js。</p>
<p>这导致极快的加载时间，并有进一步的优化，如基于路由的代码分割和预取。</p>
<h2 id="example-server-side-rendering-in-react">示例:React中的服务器端渲染</h2>
<p>几个月前，我探索了SSR React应用程序，并用Next.js创建了一个应用程序，并将其托管在Now上——一个无服务器平台。注意，Next和Now都来自一家名为<a href="https://vercel.com/" target="_blank" rel="noopener"> Vercel </a>的公司，该公司在教育开发人员关于React和无服务器技术方面做得非常好，同时还提供其他出色的产品。</p>
<p>我的应用程序从WooCommerce(一个WordPress电子商务插件)REST API端点获取数据，并将其显示在Next.js应用程序中。你可以在<a href="https://github.com/m-muhsin/woocommerce-next" target="_blank" rel="noopener"> GitHub </a>上查看我的应用，在这里看一下<a href="https://woocommerce-next.now.sh/" target="_blank" rel="noopener">的演示。</a></p>
<h2 id="do-you-always-need-ssr">你总是需要SSR吗？</h2>
<p>简单来说，答案是否定的。并非所有的应用都需要服务器端渲染，尤其是带有仪表盘和认证的应用，它们不需要SEO或通过社交媒体分享。此外，构建服务器渲染的React应用程序的专业知识高于使用create-react-app初始化的应用程序。</p>
<p>最重要的是，SSR React应用程序在资源方面花费更多，因为您需要保持节点服务器正常运行。当您希望为React应用程序选择服务器端呈现时，有时您可能更适合采用无服务器方式。</p>
<h2 id="conclusion">结论</h2>
<p>客户端渲染的React应用程序很棒，但在服务器上渲染应用程序有明显的好处。</p>
<p>正如我们在本帖中提到的，好处包括:</p>
<ol>
<li>表演</li>
<li>搜索引擎可见性</li>
<li>用户体验</li>
<li>社交分享</li>
</ol>
<p>我强烈建议您探索React应用程序的服务器端渲染，并在您的下一个产品中使用它来查看这些好处。</p><div class="code-block code-block-17">
<div class="blog-plug inline-plug react-plug" vwo-el-id="26283398190">
<h2 vwo-el-id="41600691720">使用LogRocket消除传统反应错误报告的噪音</h2>
<a href="https://lp.logrocket.com/blg/react-signup-issue-free" target="_blank" vwo-el-id="19356441070">LogRocket
</a><p>是一款React analytics解决方案，可保护您免受数百个误报错误警报的影响，只针对少数真正重要的项目。LogRocket告诉您React应用程序中实际影响用户的最具影响力的bug和UX问题。</p><a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="19356441380">
<img class="first-react-image alignnone size-full wp-image-46 jetpack-lazy-image jetpack-lazy-image--handled" src="../Images/f300c244a1a1cf916df8b4cb02bec6c6.png" vwo-el-id="18272717540" data-lazy-loaded="1" data-original-src="https://files.readme.io/27c94e7-Image_2017-06-05_at_9.46.04_PM.png"/>
</a>
<a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="19356441690">
<img class="second-react-image alignnone size-full wp-image-46 jetpack-lazy-image jetpack-lazy-image--handled" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" vwo-el-id="30720362350" data-lazy-loaded="1" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/>
</a>
<a href="https://lp.logrocket.com/blg/react-signup-issue-free" target="_blank" rel="noopener noreferrer" vwo-el-id="35866400580">LogRocket
</a><p>自动聚合客户端错误、反应错误边界、还原状态、缓慢的组件加载时间、JS异常、前端性能指标和用户交互。然后，LogRocket使用机器学习来通知您影响大多数用户的最具影响力的问题，并提供您修复它所需的上下文。</p><p vwo-el-id="28675661060">关注重要的React bug—<a class="signup" href="https://lp.logrocket.com/blg/react-signup-issue-free" target="_blank" rel="noopener noreferrer" vwo-el-id="40093418840">今天就试试LogRocket】。</a></p>
</div></div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
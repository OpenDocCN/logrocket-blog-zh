<html>
<head>
<title>6 cutting-edge JavaScript features you can use today - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>你今天可以使用的6个前沿JavaScript特性</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/6-cutting-edge-javascript-features-you-can-use-today/#0001-01-01">https://blog.logrocket.com/6-cutting-edge-javascript-features-you-can-use-today/#0001-01-01</a></blockquote><div><article class="article-post">
<p>对于一名JavaScript程序员来说，这是一个激动人心的时刻。Web技术正以更快的速度向前发展，浏览器供应商不再羞于立即实现新的创新功能。开发中的这种转变意味着程序员需要不断更新他们的技能，以保持他们角色的竞争力。</p>
<p>在本文中，我们将看看现代浏览器最近实现的六个ES2020和ES2021特性，并了解它们如何帮助JavaScript开发人员编写更少错误、更高效的代码。</p>
<h2><code>BigInt</code></h2>
<p>在JavaScript中处理大整数时，我们经常不得不使用第三方库，因为<code>Number</code>类型无法安全地表示大于2 <sup> 53 </sup>的整数值。</p>
<p>考虑下面的例子:</p>
<pre>console.log(9999999999999999);    // =&gt; 10000000000000000</pre>
<p>在这段代码中，<code>9999999999999999</code>被舍入到<code>10000000000000000</code>，因为它大于<code>Number</code>类型支持的最大整数。如果不小心，这种舍入会危及程序的安全性。</p>
<p>这是另一个例子:</p>
<pre>// notice the last digit
9800000000000007 === 9800000000000008;    // =&gt; true</pre>
<p>幸运的是，ECMAScript最近引入了<code>BigInt</code>数据类型，它提供了一种简单的方法来表示大于<code>Number</code>所支持范围的整数。</p>
<p>可以通过将<code>n</code>加到整数的上来创建一个<code>BigInt</code>。</p>
<p>比较:</p>
<pre>console.log(9800000000000007n);    // =&gt; 9800000000000007n
console.log(9800000000000007);     // =&gt; 9800000000000008</pre>
<p>也可以使用构造函数:</p>
<pre>BigInt('9800000000000007');    // =&gt; 9800000000000007n</pre>
<p>现在，您可以在标准JavaScript中对大整数执行算术运算，而不必使用变通方法:</p>
<pre>9999999999999999 * 3;      // =&gt; 30000000000000000

// with BigInt, integer overflow won’t be an issue
9999999999999999n * 3n;    // =&gt; 29999999999999997n</pre>
<p>理解<code>Number</code>和<code>BigInt</code>是两种不同的数据类型很重要，不能用严格的相等运算符来比较它们:</p>
<pre>5n === 5;     // =&gt; false
 
typeof 5n;    // =&gt; bigint
typeof 5;     // =&gt; number</pre>
<p>但是，您仍然可以使用相等运算符，因为它会在比较之前将操作数隐式转换为相同的类型:</p>
<pre>5n == 5; // =&gt; true</pre>
<p>您可以像对<code>Number</code> s一样对<code>BigInt</code> s执行算术运算:</p>
<pre>50n + 30n;    // =&gt; 80n
50n - 30n;    // =&gt; 20n
50n * 20n;    // =&gt; 1000n
50n / 5n;     // =&gt; 10n
56n % 10n;    // =&gt; 6n
50n ** 4n;    // =&gt; 6250000n</pre>
<p>递增、递减和一元求反运算符也能按预期工作。但是，一元加号(<code>+</code>)操作符是一个例外，将它应用到<code>BigInt</code>会导致一个<code>TypeError</code>:</p>
<pre>let x = 50n;
++x;    // =&gt; 51n
--x;    // =&gt; 50n
 
-50n;    // =&gt; -50n
+50n;    // =&gt; TypeError: Cannot convert a BigInt value to a number</pre>
<h2>看涨凝聚算子</h2>
<p>ES2020为JavaScript语言添加了另一个短路操作符:nullish合并(<code>??</code>)操作符。该操作符不同于现有的短路操作符，它检查其左操作数是否为nullish ( <code>null</code>或<code>undefined</code>)而不是falsy。</p>
<p>换句话说，<code>??</code>只有在其左操作数为<code>null</code>或<code>undefined</code>时才返回其右操作数:</p>
<pre>null ?? 2; // =&gt; 2
undefined ?? 2; // =&gt; 2

0 ?? 2; // =&gt; 0
false ?? true; // =&gt; false</pre>
<p>另一方面，如果左边的操作数是<code>0</code>、<code>-0</code>、<code>0n</code>、<code>false</code>、<code>""</code>(空字符串)、<code>null</code>、<code>undefined</code>或<code>NaN</code>，则逻辑OR ( <code>||</code>)运算符返回其右边的操作数。比较:</p>
<pre>null || 2;       // =&gt; 2
undefined || 2;  // =&gt; 2

0 || 2;           // =&gt; 2
false || true;    // =&gt; true</pre>
<p><code>??</code>在为属性或变量设置默认值时特别方便。例如:</p>
<pre>function Config(darkMode)  {
    this.darkMode = darkMode ?? true;
    // …
}
 
new Config(null);     // =&gt; {darkMode: true}
new Config();         // =&gt; {darkMode: true}
new Config(false);    // =&gt; {darkMode: false}</pre>
<p>在给定值为null或没有给定值的情况下，<code>Config</code>构造函数为<code>darkMode</code>属性提供默认值。</p>
<p><code>??</code>在使用DOM APIs时也很有用:</p>
<pre>// querySelector() returns null when the element doesn’t exist in the document
const elem = document.querySelector('elem') ?? document.createElement('elem');</pre>
<p>请记住，在表达式中使用<code>??</code>和其他短路操作符时，必须用括号表示求值顺序，否则代码会抛出错误。</p>
<p>括号还有助于提高代码的可读性:</p>
<pre>false || (true ?? true);   // no error
false || true ?? true;     // =&gt; SyntaxError</pre>
<h2><code>Promise.any()</code></h2>
<p>ES2015用两种方法引入了promise对象:<code>Promise.all()</code>和<code>Promise.race()</code>。ES2021通过添加<code>Promise.any()</code>进一步增强了JavaScript异步能力。这个新方法返回一个承诺，当给定iterable中的一个承诺实现时，该承诺实现；如果所有承诺都拒绝，则返回拒绝。</p>
<p>下面是它的工作原理:</p>
<pre>const promise = Promise.any([
    Promise.reject('Error'),
    fetch('https://www.google.com/images/branding/googlelogo/2x/googlelogo_color_92x30dp.png', {mode: 'no-cors'}).then(() =&gt; 'google.com'),
    fetch('https://en.wikipedia.org/static/images/project-logos/enwiki.png', {mode: 'no-cors'}).then(() =&gt; 'wikipedia.org'),
    fetch('https://s.w.org/images/home/swag_col-1.jpg?1', {mode: 'no-cors'}).then(() =&gt; 'w.org')
]);
 
promise.then((fastest) =&gt; {
    // the first promise that fulfills
    console.log(fastest);
}).catch((error) =&gt; {
    console.log(error);
});</pre>
<p>这段代码执行三个获取请求。一旦一个承诺被实现，它就返回一个实现了该承诺的值的承诺。<code>Promise.any()</code>与<code>Promise.race()</code>的不同之处在于它如何处理拒绝。只有当iterable中的所有承诺都被拒绝时，<code>Promise.any()</code>返回的承诺才会被拒绝:</p>
<pre>const promise = Promise.any([
    Promise.reject('Exception1'),
    Promise.reject('Exception2'),
    Promise.reject('Exception3')
]);
 
promise.then((response) =&gt; {
    // ...
}).catch((e) =&gt; {
    console.log(e.errors);
});
 
// logs:
// =&gt; ["Exception1", "Exception2", "Exception3"]</pre>
<p>注意所有承诺的拒绝值是如何作为数组传递给<code>catch()</code>方法的。或者，您可以使用<code>async</code>和<code>await</code>来处理结果:</p>
<pre>(async () =&gt; {
    try {
        result = await Promise.any([
            Promise.reject('Exception1'),
            Promise.reject('Exception2'),
            Promise.resolve('Success!')
        ]);
 
        console.log(result);
    } catch(e) {
        console.log(e);
    }
})();
 
// logs:
// =&gt; Success!</pre>
<h2><code>Promise.allSettled()</code></h2>
<p>最近添加到promise对象中的另一个有用的方法是<code>Promise.allSettled()</code>。这个方法是对现有的<code>Promise.all()</code>方法的补充，旨在返回所有承诺的结果——无论是拒绝还是履行。</p>
<p>这里有一个例子:</p>
<pre>const p1 = Promise.resolve('Success');
const p2 = Promise.reject('Exception');
const p3 = Promise.resolve(123);
 
Promise.allSettled([p1, p2, p3]).then((response) =&gt; {
    response.forEach(result =&gt; console.log(result.value || result.reason))
});

// logs:
// =&gt; Success
// =&gt; Error!
// =&gt; 123</pre>
<p>注意所有承诺的结果是如何作为数组传递给<code>then()</code>的。在<code>then()</code>内部，一个<code>forEach()</code>方法在数组的元素上循环。如果<code>||</code>操作符的左操作数不是<code>undefined</code>，它将被记录到控制台。否则，承诺已被拒绝，并且将记录正确的操作数。</p>
<p>相比之下，<code>Promise.all()</code>承诺人一拒绝，马上拒绝。</p>
<h2>可选链接运算符</h2>
<p>可选的链接操作符(<code>?.</code>)允许您访问嵌套的属性，而无需验证链中的每个属性。</p>
<p>考虑下面的例子:</p>
<pre>const obj = {};
const nickname = obj?.user?.profile?.nickname;
 
console.log(nickname);    // =&gt; undefined</pre>
<p>这段代码试图将嵌套属性的值赋给一个常数。但是，在<code>obj</code>中没有这样的属性。另外，<code>user</code>和<code>profile</code>不存在。但是由于可选的链接操作符，代码返回<code>undefined</code>而不是抛出一个错误。</p>
<p>使用常规的链接操作符，您会得到一个错误:</p>
<pre>const obj = {};
const nickname = obj.user.profile.nickname;
 
console.log(nickname);    // =&gt; TypeError</pre>
<p>调用对象的方法时，也可以使用可选的链接运算符:</p>
<pre>const obj = {};
const value = obj.myMethod?.();
 
console.log(value);    // =&gt; undefined</pre>
<p>这里，<code>myMethod</code>在<code>obj</code>中不存在；然而，因为它是使用可选的链接操作符调用的，所以返回值是<code>undefined</code>。同样，使用常规的链接操作符，您会得到一个错误。</p>
<p>但是如果你想动态地访问一个属性呢？<code>?.[]</code>标记允许您使用括号符号引用变量。</p>
<p>它是这样工作的:</p>
<pre>const obj = {
    user: {
      id: 123
    }
};
 
const prop = 'nickname';
const nickname = obj?.user?.profile?.[prop];
 
console.log(nickname);    // =&gt; undefined</pre>
<h2><code>globalThis</code></h2>
<p>尽管创建JavaScript的目的是为了在web浏览器中执行复杂的功能，但它现在可以在完全不同的环境中运行，如服务器、智能手机甚至机器人。因为每个环境都有自己的对象模型，所以您需要使用不同的语法来访问全局对象。</p>
<p>在浏览器环境中，您可以使用<code>window</code>、<code>frames</code>或<code>self</code>。在Web Workers中，你可以使用<code>self</code>。在Node中，你可以使用<code>global</code>。这种差异使得web开发人员更难编写可移植的JavaScript程序。</p><div class="code-block code-block-54">
<hr/>
<h3>更多来自LogRocket的精彩文章:</h3>

<hr/></div>
<p><code>globalThis</code>在所有环境中提供单一通用属性来访问全局对象:</p>
<pre>// browser environment
console.log(globalThis);    // =&gt; Window {...}
 
// web worker environment
console.log(globalThis);    // =&gt; DedicatedWorkerGlobalScope {...}
 
// node environment
console.log(globalThis);    // =&gt; Object [global] {...}</pre>
<p>以前，开发人员必须编写额外的检查，以确保他们引用正确的属性。有了<code>globalThis</code>，这就不再需要了，代码将在窗口和非窗口上下文中工作。请记住，您可能仍然需要使用polyfill来向后兼容旧版本的浏览器。</p>
<h2>结论</h2>
<p>JavaScript正在快速发展，有趣的新特性不时被添加到语言中。在本文中，我们研究了六个新的JavaScript特性，包括<code>BigInt</code>、nullish合并操作符、<code>Promise.any()</code>、<code>Promise.allSettled()</code>、可选的链接操作符和<code>globalThis</code>。</p>
<p><code>BigInt</code>允许表示大的整数值。nullish合并运算符为JavaScript带来了一个新的短路运算符。<code>Promise.any()</code>和<code>Promise.allSettled()</code>允许进一步控制异步操作。可选的链接操作符简化了对嵌套属性的访问。并且<code>globalThis</code>在所有环境中提供单一的通用属性来访问全局对象。</p>
<p>要获得最新功能的更新，请查看已完成提案的列表。如果你有任何问题，欢迎在评论中提问，我也在<a href="https://twitter.com/FarazKelhini" target="_blank" rel="noopener noreferrer">推特</a>上。</p><div class="code-block code-block-27">
<div class="blog-plug inline-plug vanilla-javascript-cta"><h2>通过理解上下文，更容易地调试JavaScript错误</h2>
<p>调试代码总是一项单调乏味的任务。但是你越了解自己的错误，就越容易改正。</p>
<p>LogRocket 让你以新的独特的方式理解这些错误。我们的前端监控解决方案跟踪用户与您的JavaScript前端的互动，让您能够准确找出导致错误的用户行为。</p>
<a href="https://lp.logrocket.com/blg/javascript-signup" class="signup" target="_blank" rel="noopener noreferrer"><img class="alignnone size-full wp-image-46 jetpack-lazy-image" src="../Images/cbfed9be3defcb505e662574769a7636.png" alt="LogRocket Dashboard Free Trial Banner" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2020/06/reproduce-javascript-errors.gif?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/06/reproduce-javascript-errors.gif"/><noscript><img data-lazy-fallback="1" class="alignnone size-full wp-image-46" src="../Images/cbfed9be3defcb505e662574769a7636.png" alt="LogRocket Dashboard Free Trial Banner" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/06/reproduce-javascript-errors.gif"/></noscript></a>
<p>LogRocket记录控制台日志、页面加载时间、堆栈跟踪、慢速网络请求/响应(带有标题+正文)、浏览器元数据和自定义日志。理解您的JavaScript代码的影响从来没有这么简单过！</p>
<a class="signup" href="https://lp.logrocket.com/blg/javascript-signup" target="_blank" rel="noopener noreferrer">Try it for free</a><p>.</p></div>


</div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
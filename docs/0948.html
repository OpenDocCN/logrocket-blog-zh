<html>
<head>
<title>Slimming down your bundle size - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>减肥你的包大小-日志火箭博客</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/slimming-down-your-bundle-size/#0001-01-01">https://blog.logrocket.com/slimming-down-your-bundle-size/#0001-01-01</a></blockquote><div><article class="article-post">
<p>即使我们今天有更快的计算机和移动设备，我们作为开发人员也应该考虑我们作为一个整体来构建产品的受众。并不是每个人都可以使用相同类型的快速设备或使用最快的互联网。因此，我们需要更广泛地看待性能问题。可以通过许多不同的方式来追求性能，但是对于本文，我们将重点关注前端性能。我们更仔细地研究了这一方面，并对这一领域可能的改进提出了建议。</p>
<h2>前端性能</h2>
<p>前端性能优化至关重要，因为<a href="http://www.stevesouders.com/blog/2012/02/10/the-performance-golden-rule/" target="_blank" rel="noopener noreferrer">它约占用户响应时间</a>的80-90%。因此，当用户等待页面加载时，大约80-90%的时间是由于前端相关的代码和资产。<a href="http://www.stevesouders.com/" target="_blank" rel="noopener noreferrer">下图</a>显示了LinkedIn要加载的前端/后端资产的比例。</p>
<figure id="attachment_20506" aria-describedby="caption-attachment-20506" class="wp-caption aligncenter"><img data-attachment-id="20506" data-permalink="https://blog.logrocket.com/slimming-down-your-bundle-size/frontendloadtimes/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/06/frontendloadtimes.png" data-orig-size="536,405" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="frontendloadtimes" data-image-description="" data-image-caption="&lt;p&gt;Source: http://www.stevesouders.com/&lt;/p&gt;&#10;" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/06/frontendloadtimes-300x227.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/06/frontendloadtimes.png" decoding="async" class="size-full wp-image-20506 jetpack-lazy-image" src="../Images/4fc7b33693a8c4528d97a482c181c327.png" alt="Source: http://www.stevesouders.com/" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2020/06/frontendloadtimes.png 536w, https://blog.logrocket.com/wp-content/uploads/2020/06/frontendloadtimes-300x227.png 300w" data-lazy-sizes="(max-width: 536px) 100vw, 536px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2020/06/frontendloadtimes.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/06/frontendloadtimes.png"/><noscript><img data-lazy-fallback="1" data-attachment-id="20506" data-permalink="https://blog.logrocket.com/slimming-down-your-bundle-size/frontendloadtimes/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/06/frontendloadtimes.png" data-orig-size="536,405" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="frontendloadtimes" data-image-description="" data-image-caption="&lt;p&gt;Source: http://www.stevesouders.com/&lt;/p&gt;&#10;" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/06/frontendloadtimes-300x227.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/06/frontendloadtimes.png" decoding="async" loading="lazy" class="size-full wp-image-20506" src="../Images/4fc7b33693a8c4528d97a482c181c327.png" alt="Source: http://www.stevesouders.com/" srcset="https://blog.logrocket.com/wp-content/uploads/2020/06/frontendloadtimes.png 536w, https://blog.logrocket.com/wp-content/uploads/2020/06/frontendloadtimes-300x227.png 300w" sizes="(max-width: 536px) 100vw, 536px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/06/frontendloadtimes.png"/></noscript><figcaption id="caption-attachment-20506" class="wp-caption-text">Source: <a href="http://www.stevesouders.com/" rel="nofollow">http://www.stevesouders.com/</a></figcaption></figure>
<p>前端加载时间的很大一部分花费在执行JavaScript文件和呈现页面上。但是提高前端性能的一个关键部分是减少应该通过网络下载的JavaScript包的大小。JavaScript包越小，用户访问页面的速度就越快。</p>
<p><a href="https://www.keycdn.com/support/the-growth-of-web-page-size" target="_blank" rel="noopener noreferrer">如果我们查看历史数据</a>，我们可以看到2010年JavaScript文件的平均大小为2KB。但是随着JavaScript的发展，新的JavaScript库的引入，像<a href="https://angular.io/" target="_blank" rel="noopener noreferrer"> Angular </a>或<a href="https://reactjs.org/" target="_blank" rel="noopener noreferrer"> React、</a>以及<a href="https://en.wikipedia.org/wiki/Single-page_application" target="_blank" rel="noopener noreferrer">单页应用</a>的概念，平均JavaScript资产大小已经<a href="https://www.keycdn.com/support/the-growth-of-web-page-size" target="_blank" rel="noopener noreferrer">增加到2016年的357 kb</a>。我们需要利用这些新技术找到更好的解决方案。但是我们也需要考虑一些可能的方法来提高它们的性能，比如减少整个JavaScript包的大小。但是在深入这个主题之前，我们需要熟悉JavaScript包。它们到底是什么？</p>
<h2>JavaScript包</h2>
<p>您的前端应用程序需要一堆JavaScript文件来运行。这些文件可以是内部依赖的格式，就像您自己编写的JavaScript文件一样。它们也可以是您用来构建应用程序的外部依赖项和库，如<a href="https://reactjs.org/" target="_blank" rel="noopener noreferrer"> React </a>、<a href="https://lodash.com/" target="_blank" rel="noopener noreferrer"> lodash </a>或<a href="https://jquery.com/" target="_blank" rel="noopener noreferrer"> jQuery </a>。因此，为了让您的页面第一次加载，应用程序需要能够访问这些JavaScript文件。那么我们如何揭露他们呢？</p>
<p>在过去，公开JavaScript文件的方式要简单得多。大多数网页不需要很多JavaScript资源。由于我们无法获得<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/import" target="_blank" rel="noopener noreferrer">要求</a>依赖的标准方式，我们不得不依靠使用全局依赖。假设我们既需要jQuery，也需要保存所有应用程序JavaScript逻辑的<code>main.js</code>和<code>other.js</code>。我们能够公开这些依赖关系的方式如下所示:</p>
<pre>&lt;script src="/js/main.js"&gt;&lt;/script&gt;
&lt;script src="/js/other.js"&gt;&lt;/script&gt;
&lt;script src="//code.jquery.com/jquery-1.12.0.min.js"&gt;&lt;/script&gt;</pre>
<p>对于这个问题，这是一个简单的解决方案，但是在扩展应用程序时很快就失控了。例如，如果<code>main.js</code>的变化依赖于<code>other.js</code>中的代码，我们需要像这样重新排序我们的脚本标签:</p>
<pre>&lt;script src="/js/other.js"&gt;&lt;/script&gt;
&lt;script src="/js/main.js"&gt;&lt;/script&gt;
&lt;script src="//code.jquery.com/jquery-1.12.0.min.js"&gt;&lt;/script&gt;</pre>
<p>正如我们所见，大规模管理这样的代码结构会很快变得一团糟。但是过了一段时间，在应用程序中有了更好的解决方案。例如，如果你使用的是<a href="https://nodejs.org/en/" target="_blank" rel="noopener noreferrer"> NodeJS </a>，你可以依赖NodeJS自己的模块系统(基于<a href="http://wiki.commonjs.org/wiki/Modules/1.1" target="_blank" rel="noopener noreferrer"> commonJS规范</a>)。这将允许您使用<a href="https://nodejs.org/en/knowledge/getting-started/what-is-require/" target="_blank" rel="noopener noreferrer">要求函数</a>来要求依赖关系。因此，在节点环境中，我们上面的代码片段应该是这样的:</p>
<pre>&lt;script&gt;
  var jQuery = require('jquery')
  var main = require('./js/main')
  var other = require('./js/other')
&lt;/script&gt;</pre>
<p>现在，您不仅仅需要几个JavaScript文件来运行您的应用程序。您的应用程序的JavaScript依赖项可能包括数百或数千个文件，很明显不可能像上面的代码片段那样列出它们。这有几个原因:</p>
<ul>
<li>当应用程序的不同部分需要不同的依赖关系时，将JavaScript资产分离到不同的文件中确实需要大量的HTTP请求。这将不是高性能的，需要很多时间</li>
<li>此外，NodeJS <code>require</code>是同步的，但是我们希望它是异步的，并且如果资产还没有下载，就不要阻塞主线程</li>
</ul>
<p>因此，最好的方法似乎是将所有的JavaScript代码放在一个JavaScript文件中，并处理其中的所有依赖关系。嗯，这是一个JavaScript捆绑器的基本工作。尽管不同的捆扎机对此可以有不同的策略。让我们进一步探讨一下，看看捆扎机是如何做到这一点的。然后，我们将看看是否有额外的改进可以实现更小的包大小，从而获得更高的性能。出于本文的目的，我们将使用<a href="https://webpack.js.org/" target="_blank" rel="noopener noreferrer"> Webpack </a>作为捆绑器，这是最著名的选项之一。</p>
<h2>使用Webpack构建示例包</h2>
<p>让我们从建立一个简单的Webpack项目开始。我们将使用基本包来启动一个简单的web应用程序项目。<a href="https://www.npmjs.com/package/react" target="_blank" rel="noopener noreferrer"> React </a>，<a href="https://www.npmjs.com/package/react-dom" target="_blank" rel="noopener noreferrer"> ReactDOM </a>作为UI框架，<a href="https://blog.logrocket.com/why-you-should-use-swc/" target="_blank" rel="noopener noreferrer"> SWC作为Babel </a>更快的替代方案用于transpilation，以及一系列Webpack工具和加载器。这就是我们的<code><a href="https://docs.npmjs.com/files/package.json" target="_blank" rel="noopener noreferrer">package.json</a></code>的样子:</p>
<pre>// package.json

{
  "name": "project",
  "version": "1.0.0",
  "main": "index.js",
  "scripts": {
    "test": "echo \"Error: no test specified\" &amp;&amp; exit 1",
    "build": "rm -rf ./dist &amp;&amp; webpack",
    "start": "webpack-dev-server"
  },
  "keywords": [],
  "author": "",
  "license": "MIT",
  "devDependencies": {
    "@swc/core": "^1.1.39",
    "css-loader": "^3.4.0",
    "html-loader": "^0.5.5",
    "html-webpack-plugin": "^3.2.0",
    "sass-loader": "^8.0.0",
    "style-loader": "^1.1.1",
    "swc-loader": "^0.1.9",
    "webpack": "^4.41.4",
    "webpack-cli": "^3.3.10",
    "webpack-dev-server": "^3.10.1"
  },
  "dependencies": {
    "react": "^16.12.0",
    "react-dom": "^16.12.0",
    "regenerator-runtime": "^0.13.5"
  }
}</pre>
<p>我们还需要一个<a href="https://webpack.js.org/configuration/" target="_blank" rel="noopener noreferrer"> <code>webpack.config.js</code> </a>，它是我们的Webpack命令的配置入口点。该文件中有几个选项，但让我们澄清几个重要的选项:</p>
<ul>
<li><code><a href="https://webpack.js.org/configuration/mode/" target="_blank" rel="noopener noreferrer">mode</a></code> —这是Webpack的一个选项，根据它被传递到的选项，它知道它是否应该进行任何优化。我们稍后将进一步讨论这一点</li>
<li><code><a href="https://webpack.js.org/configuration/output/" target="_blank" rel="noopener noreferrer">output</a></code> —该选项告诉Webpack应该在根级别将组装的包加载或放置在哪里。它接受路径和文件名</li>
<li><code><a href="https://webpack.js.org/plugins/html-webpack-plugin/" target="_blank" rel="noopener noreferrer">HTMLWebpackPlugin</a></code> —此选项有助于我们更轻松地使用Webpack捆绑包提供HTML文件</li>
<li>这些加载器插件帮助你将大多数现代编码语言特性转换成所有浏览器都能理解的代码</li>
</ul>
<pre>// global dependencies
const path = require('path');
const HTMLWebpackPlugin = require("html-webpack-plugin");

module.exports = {
  mode: "production",
  // DOC: https://webpack.js.org/configuration/output/
  output: {
    path: path.resolve(__dirname, './dist'),
    filename: 'index_bundle.js'
  },
  // DOC: https://webpack.js.org/configuration/dev-server/
  devServer: {
    contentBase: path.join(__dirname, 'dist'),
    compress: true,
    port: 9000
  },
  module: {
    rules: [
        {
        test: /\.jsx?$/ ,
        exclude: /(node_modules|bower_components)/,
        use: {
            // `.swcrc` in the root can be used to configure swc
            loader: "swc-loader"
        }
      },
      {
        test: /\.html$/,
        use: [
          {
            loader: "html-loader",
            options: { minimize: true }
          }
        ]
      },
      {
        test: /\.scss/i,
        use: ["style-loader", "css-loader", "sass-loader"]
      }
    ]
  },
  plugins: [
    // DOC: https://webpack.js.org/plugins/html-webpack-plugin/
    new HTMLWebpackPlugin({
      filename: "./index.html",
      template: path.join(__dirname, 'public/index.html')
    })
  ]
};</pre>
<h2>测量和分析</h2>
<p>现在，是时候为我们的Webpack构建进行一些初始测量了。当Webpack进行编译时，我们需要对构建的模块、编译速度和生成的依赖图进行某种统计。Webpack已经<a href="https://webpack.js.org/api/stats/" target="_blank" rel="noopener noreferrer">为我们提供了工具</a>来获取这些统计数据，只需运行一个简单的CLI命令:</p>
<pre>webpack-cli --profile --json &gt; compilation-stats.json</pre>
<p>通过传递<code>--json &gt; compilation-stats.json</code>，我们告诉Webpack生成构建统计数据和依赖图，作为一个具有我们指定名称的json文件。通过传递<code>--profile</code>标志，我们可以获得关于单个模块的更详细的构建统计信息。运行这个命令后，你会得到一个<code>json</code>文件，其中包含了很多有用的信息。但是为了使事情变得简单，我们将使用一个推荐的工具来可视化所有这些构建统计数据。你所需要做的就是将<code>compilation-stats.json</code>拖到这个<a href="http://webpack.github.io/analyse/" target="_blank" rel="noopener noreferrer">官方分析工具</a>中的指定区域。这样做之后，我们得到以下结果。</p>
<h2>网络包分析</h2>
<p>我们得到了下表，其中包含关于Webpack构建分析的一般信息:</p>
<table>
<thead>
<tr>
<th>用于编译的Webpack版本</th>
<th>4.43.0 </th>
</tr>
</thead>
<tbody>
<tr>
<td>编译特定哈希</td>
<td><strong> a770d6c609235bbb24fe </strong></td>
</tr>
<tr>
<td>编译时间(毫秒)</td>
<td><strong> 522 </strong></td>
</tr>
<tr>
<td>模块数量</td>
<td><strong> 8 </strong></td>
</tr>
<tr>
<td>组块数量</td>
<td><strong> 1 </strong></td>
</tr>
<tr>
<td>资产数量</td>
<td><strong> 2 </strong></td>
</tr>
</tbody>
</table>
<h2>依赖图</h2>
<p>如果我们单击dependency部分，我们会得到一个类似的图表，其中显示了我们的应用程序中不同的依赖关系，每个依赖关系的详细信息，以及它们是如何相互连接的。</p>
<p> </p>
<figure id="attachment_20523" aria-describedby="caption-attachment-20523" class="wp-caption aligncenter"><img data-attachment-id="20523" data-permalink="https://blog.logrocket.com/slimming-down-your-bundle-size/dependencygraph/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/06/Dependencygraph.png" data-orig-size="730,428" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Dependencygraph" data-image-description="" data-image-caption="&lt;p&gt;Dependency Graph&lt;/p&gt;&#10;" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/06/Dependencygraph-300x176.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/06/Dependencygraph.png" decoding="async" class="size-full wp-image-20523 jetpack-lazy-image" src="../Images/032187a4edc81f5a8790dcee8a882569.png" alt="Dependency graph" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2020/06/Dependencygraph.png 730w, https://blog.logrocket.com/wp-content/uploads/2020/06/Dependencygraph-300x176.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2020/06/Dependencygraph.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/06/Dependencygraph.png"/><noscript><img data-lazy-fallback="1" data-attachment-id="20523" data-permalink="https://blog.logrocket.com/slimming-down-your-bundle-size/dependencygraph/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/06/Dependencygraph.png" data-orig-size="730,428" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Dependencygraph" data-image-description="" data-image-caption="&lt;p&gt;Dependency Graph&lt;/p&gt;&#10;" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/06/Dependencygraph-300x176.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/06/Dependencygraph.png" decoding="async" loading="lazy" class="size-full wp-image-20523" src="../Images/032187a4edc81f5a8790dcee8a882569.png" alt="Dependency graph" srcset="https://blog.logrocket.com/wp-content/uploads/2020/06/Dependencygraph.png 730w, https://blog.logrocket.com/wp-content/uploads/2020/06/Dependencygraph-300x176.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/06/Dependencygraph.png"/></noscript><figcaption id="caption-attachment-20523" class="wp-caption-text">Dependency Graph</figcaption></figure>
<p>现在，这些构建统计数据非常有用，但是由于我们将只专注于精简和优化我们的包大小，我们将使用一个名为<a href="https://github.com/webpack-contrib/webpack-bundle-analyzer" target="_blank" rel="noopener noreferrer"> webpack-bundle-analyzer </a>的专门Webpack工具。此工具将允许您可视化Webpack输出文件的大小，并向您显示一个交互式的可缩放树状图。让我们为我们的项目设置它。第一件事是安装软件包:</p>
<pre>npm install --save-dev webpack-bundle-analyzer</pre>
<p>接下来我们需要做的是在<code>webpack.config.js</code>文件中设置相关的配置:</p>
<pre>const BundleAnalyzerPlugin = require('webpack-bundle-analyzer').BundleAnalyzerPlugin;

module.exports = {
  plugins: [
    new BundleAnalyzerPlugin()
  ]
}</pre>
<p>现在您所要做的就是在您的<code>package.json</code>中挂接一个脚本来运行分析器:</p>
<pre>"scripts": {
  "bundle-report": "webpack-bundle-analyzer --port 4200 compilation-stats.json"
}</pre>
<p>因此，在运行<code>npm run-script bundle-report</code>之后，我们得到了包中内容的可视化表示，并看到它们中的哪些占据了大部分大小。这是我们项目的情况:</p>
<figure id="attachment_20530" aria-describedby="caption-attachment-20530" class="wp-caption aligncenter"><img data-attachment-id="20530" data-permalink="https://blog.logrocket.com/slimming-down-your-bundle-size/webpackbundleanalyzer/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/06/webpackbundleanalyzer.png" data-orig-size="730,428" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="webpackbundleanalyzer" data-image-description="" data-image-caption="&lt;p&gt;Webpack bundle analyzer&lt;/p&gt;&#10;" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/06/webpackbundleanalyzer-300x176.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/06/webpackbundleanalyzer.png" decoding="async" class="size-full wp-image-20530 jetpack-lazy-image" src="../Images/18c84a7c92408330ffe1d7ce3ef78301.png" alt="webpack bundle analyzer" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2020/06/webpackbundleanalyzer.png 730w, https://blog.logrocket.com/wp-content/uploads/2020/06/webpackbundleanalyzer-300x176.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2020/06/webpackbundleanalyzer.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/06/webpackbundleanalyzer.png"/><noscript><img data-lazy-fallback="1" data-attachment-id="20530" data-permalink="https://blog.logrocket.com/slimming-down-your-bundle-size/webpackbundleanalyzer/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/06/webpackbundleanalyzer.png" data-orig-size="730,428" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="webpackbundleanalyzer" data-image-description="" data-image-caption="&lt;p&gt;Webpack bundle analyzer&lt;/p&gt;&#10;" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/06/webpackbundleanalyzer-300x176.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/06/webpackbundleanalyzer.png" decoding="async" loading="lazy" class="size-full wp-image-20530" src="../Images/18c84a7c92408330ffe1d7ce3ef78301.png" alt="webpack bundle analyzer" srcset="https://blog.logrocket.com/wp-content/uploads/2020/06/webpackbundleanalyzer.png 730w, https://blog.logrocket.com/wp-content/uploads/2020/06/webpackbundleanalyzer-300x176.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/06/webpackbundleanalyzer.png"/></noscript><figcaption id="caption-attachment-20530" class="wp-caption-text">Webpack bundle analyzer</figcaption></figure>
<p>如我们所见，React依赖项占据了包的大部分大小。让我们看看对此我们能做些什么，来帮助我们减少总的包大小。</p>
<h2>捆绑包优化#1:在生产模式下运行Webpack</h2>
<p>这种优化包和减少总包大小的策略简单明了。Webpack有一个产品标志(<code>-p</code>)，它很少进行开箱即用的优化。因此，如果我们用下面的命令运行我们的构建脚本，我们应该得到一些优化:</p>
<pre>// via command-line
 webpack-cli -p

// via package.json script
"scripts": {
  "build": "rm -rf ./dist &amp;&amp; webpack -p",
},</pre>
<p>运行这个之后，我们可以看到我们的包大小将从<strong> 970KB </strong>减少到<strong> 128KB </strong>。但是Webpack是如何用这样一个简单的命令来管理这种剧烈的优化的呢？这主要有两个原因:</p>
<ul>
<li>在引擎盖下，React将使用一个名为<a href="http://lisperator.net/uglifyjs/" target="_blank" rel="noopener noreferrer"> UglifyJS </a>的插件，该插件通过删除任何不必要的空白或未使用的代码来处理代码缩减和死代码消除。</li>
<li>它还将<code>NODE_ENV</code>设置为生产。这样，像React这样的包就不会包含调试代码</li>
</ul>
<p>这是减少我们的包大小和减少用户加载时间的一个很好的步骤。让我们看看我们还能做什么。</p>
<h2>捆绑包优化#2:安装轻量级替代库</h2>
<p>React的包大小仍然有点大(在我们的项目中是124KB)，即使在我们之前进行了优化之后。在检查webpack-bundle-analyzer报告时，我们可以看到React占用了我们的包大小的很大一部分。因此，我们将考虑用一个名为<a href="https://preactjs.com/" target="_blank" rel="noopener noreferrer"> preact </a>的React的更轻版本来替换它，只有3KB大小。</p>
<p>当我们将这个包作为依赖项安装时，我们同时获得了React API的核心和DOM支持；作为一个额外的步骤，我们可以安装<a href="https://github.com/preactjs/preact-compat" target="_blank" rel="noopener noreferrer"> preact-compat </a>作为2KB大小的react的兼容层。这样，在我们的项目中，我们可以直接使用preact来替代react。Preact比react更具性能，正如我们在下面不同库之间的性能比较中所看到的，这些库用于构建一个简单的“待办事项”MVC基准:</p>
<figure id="attachment_20536" aria-describedby="caption-attachment-20536" class="wp-caption aligncenter"><img data-attachment-id="20536" data-permalink="https://blog.logrocket.com/slimming-down-your-bundle-size/developit/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/06/developit.png" data-orig-size="1150,938" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="developit" data-image-description="" data-image-caption="&lt;p&gt;Source: https://developit.github.io/&lt;/p&gt;&#10;" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/06/developit-300x245.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/06/developit-1024x835.png" decoding="async" class="size-full wp-image-20536 jetpack-lazy-image" src="../Images/62b20963f56790048768c4f8e05ce220.png" alt="https://developit.github.io/" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2020/06/developit.png 1150w, https://blog.logrocket.com/wp-content/uploads/2020/06/developit-300x245.png 300w, https://blog.logrocket.com/wp-content/uploads/2020/06/developit-1024x835.png 1024w, https://blog.logrocket.com/wp-content/uploads/2020/06/developit-768x626.png 768w" data-lazy-sizes="(max-width: 1150px) 100vw, 1150px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2020/06/developit.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/06/developit.png"/><noscript><img data-lazy-fallback="1" data-attachment-id="20536" data-permalink="https://blog.logrocket.com/slimming-down-your-bundle-size/developit/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/06/developit.png" data-orig-size="1150,938" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="developit" data-image-description="" data-image-caption="&lt;p&gt;Source: https://developit.github.io/&lt;/p&gt;&#10;" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/06/developit-300x245.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/06/developit-1024x835.png" decoding="async" loading="lazy" class="size-full wp-image-20536" src="../Images/62b20963f56790048768c4f8e05ce220.png" alt="https://developit.github.io/" srcset="https://blog.logrocket.com/wp-content/uploads/2020/06/developit.png 1150w, https://blog.logrocket.com/wp-content/uploads/2020/06/developit-300x245.png 300w, https://blog.logrocket.com/wp-content/uploads/2020/06/developit-1024x835.png 1024w, https://blog.logrocket.com/wp-content/uploads/2020/06/developit-768x626.png 768w" sizes="(max-width: 1150px) 100vw, 1150px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/06/developit.png"/></noscript><figcaption id="caption-attachment-20536" class="wp-caption-text">Source: <a href="https://developit.github.io/" rel="nofollow">https://developit.github.io/</a></figcaption></figure>
<p>所以现在，我们将为我们的项目安装Preact，看看它如何影响我们的包大小。我们首先安装preact和preact-compat:</p>
<pre>npm install preact preact-compat</pre>
<p>然后我们只需要在<code>wepack.config.js</code>中设置<code>alias</code> config，使这个库与所有React代码兼容:</p>
<pre>// webpack.config.js

resolve: {
  alias: {
    "react": "preact-compat",
    "react-dom": "preact-compat"
  }
},</pre>
<p>因此，在设置并运行我们的<code>npm run-script bundle-report</code>之后，我们得到了下面的包分析。在这个交互图中，我们可以看到，与之前的124KB相比，React相关的包大小现在缩小到了23KB左右。这对我们来说是一个很大的缩减:</p>
<p><img data-attachment-id="20538" data-permalink="https://blog.logrocket.com/slimming-down-your-bundle-size/webpackbundleanalyzer1/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/06/webpackbundleanalyzer1.png" data-orig-size="730,428" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="webpackbundleanalyzer1" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/06/webpackbundleanalyzer1-300x176.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/06/webpackbundleanalyzer1.png" decoding="async" class="aligncenter size-full wp-image-20538 jetpack-lazy-image" src="../Images/d024ad1e1f0992e162aa203114cc4098.png" alt="webpack bundle analyzer" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2020/06/webpackbundleanalyzer1.png 730w, https://blog.logrocket.com/wp-content/uploads/2020/06/webpackbundleanalyzer1-300x176.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2020/06/webpackbundleanalyzer1.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/06/webpackbundleanalyzer1.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="20538" data-permalink="https://blog.logrocket.com/slimming-down-your-bundle-size/webpackbundleanalyzer1/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/06/webpackbundleanalyzer1.png" data-orig-size="730,428" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="webpackbundleanalyzer1" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/06/webpackbundleanalyzer1-300x176.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/06/webpackbundleanalyzer1.png" decoding="async" loading="lazy" class="aligncenter size-full wp-image-20538" src="../Images/d024ad1e1f0992e162aa203114cc4098.png" alt="webpack bundle analyzer" srcset="https://blog.logrocket.com/wp-content/uploads/2020/06/webpackbundleanalyzer1.png 730w, https://blog.logrocket.com/wp-content/uploads/2020/06/webpackbundleanalyzer1-300x176.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/06/webpackbundleanalyzer1.png"/></noscript>
<p>使用<code>webpack-bundle-analyzer</code>可以让我们直观地看到应用程序中安装的包。如果一个包占用了很多空间，我们可以考虑用一个更轻的版本库来代替它(就像我们上面做的)。</p>
<h2>结论</h2>
<p>到目前为止，我们能够将我们的包的大小从970Kb减少到23KB，这是我们的包大小的42倍。此外，请记住，我们的项目结构和依赖项都很小，但是主动为更大更复杂的项目减少捆绑包的大小会更有益。</p>
<p>下面是一些潜在的后续步骤，您可以采取这些步骤来减少包的大小和加载时间，并提高性能。</p>
<ul>
<li>考虑重写大型库，因为您可能不需要它的所有功能。例如，许多开发人员使用<a href="https://momentjs.com/" target="_blank" rel="noopener noreferrer"> Moment.js </a>来解析和验证JavaScript中的日期，这是一个很大的问题，但是并不是每个人都需要整个库来进行简单的日期解析。考虑编写简单的实用函数，而不是依赖大型库</li>
<li>检查您是否仅使用库的一个功能模块，该模块可以单独导入，而无需导入整个库。这个用例的一个很好的例子是<a href="https://lodash.com/" target="_blank" rel="noopener noreferrer"> lodash </a>，您可以单独导入它的任何库实用函数</li>
<li>最后考虑<a href="https://webpack.js.org/guides/code-splitting/" target="_blank" rel="noopener noreferrer">代码拆分</a>。并不是每一个依赖项都需要在每次页面加载时加载，所以将它们单独捆绑在一起是有意义的。例如，外部NPM依赖项不会像我们的应用程序代码那样改变很多。因此，将它们分割成一个单独的包将允许浏览器在它们没有被改变时缓存它们，从而减少每次页面加载需要加载的包的数量</li>
</ul>
<h2>资源</h2>

<p>使用LogRocket消除传统反应错误报告的噪音</p>
<div class="code-block code-block-17">
<div class="blog-plug inline-plug react-plug" vwo-el-id="26283398190">
<h2 vwo-el-id="41600691720">是一款React analytics解决方案，可保护您免受数百个误报错误警报的影响，只针对少数真正重要的项目。LogRocket告诉您React应用程序中实际影响用户的最具影响力的bug和UX问题。</h2>
<a href="https://lp.logrocket.com/blg/react-signup-issue-free" target="_blank" vwo-el-id="19356441070">LogRocket
</a><p>自动聚合客户端错误、反应错误边界、还原状态、缓慢的组件加载时间、JS异常、前端性能指标和用户交互。然后，LogRocket使用机器学习来通知您影响大多数用户的最具影响力的问题，并提供您修复它所需的上下文。</p><a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="19356441380">
<img class="first-react-image alignnone size-full wp-image-46 jetpack-lazy-image jetpack-lazy-image--handled" src="../Images/f300c244a1a1cf916df8b4cb02bec6c6.png" vwo-el-id="18272717540" data-lazy-loaded="1" data-original-src="https://files.readme.io/27c94e7-Image_2017-06-05_at_9.46.04_PM.png"/>
</a>
<a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="19356441690">
<img class="second-react-image alignnone size-full wp-image-46 jetpack-lazy-image jetpack-lazy-image--handled" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" vwo-el-id="30720362350" data-lazy-loaded="1" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/>
</a>
<a href="https://lp.logrocket.com/blg/react-signup-issue-free" target="_blank" rel="noopener noreferrer" vwo-el-id="35866400580">LogRocket
</a><p>关注重要的React bug—<a class="signup" href="https://lp.logrocket.com/blg/react-signup-issue-free" target="_blank" rel="noopener noreferrer" vwo-el-id="40093418840">今天就试试LogRocket】。</a></p><p vwo-el-id="28675661060">Focus on the React bugs that matter —
<a class="signup" href="https://lp.logrocket.com/blg/react-signup-issue-free" target="_blank" rel="noopener noreferrer" vwo-el-id="40093418840">try LogRocket today</a>.
</p>
</div></div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
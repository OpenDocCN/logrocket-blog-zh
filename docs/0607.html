<html>
<head>
<title>How to create a React Native app with PostgreSQL and GraphQL: Part 2 - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>如何用PostgreSQL和GraphQL创建React本地应用程序:第2部分- LogRocket博客</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/how-to-create-a-react-native-app-with-postgresql-and-graphql-part-2/#0001-01-01">https://blog.logrocket.com/how-to-create-a-react-native-app-with-postgresql-and-graphql-part-2/#0001-01-01</a></blockquote><div><article class="article-post">
<p>在<a href="https://blog.logrocket.com/create-a-react-native-app-with-postgresql-and-graphql-part-1/" target="_blank" rel="noopener noreferrer">上一篇文章</a>中，我们用NodeJS和Express创建了一个GraphQL服务器。现在，我们将使用React本地移动应用程序来消费我们创建的服务器中的端点。React Native允许我们开发可以在iOS和Android设备上运行的应用程序。我们将利用<a href="https://expo.io" target="_blank" rel="noopener noreferrer">博览会</a>来启动我们的应用程序，这也将使我们能够快速构建和部署我们的应用程序。</p>
<p>借助Expo，我们还可以在移动设备或网络浏览器上运行我们的应用程序。在我们开始之前，需要在全球范围内安装Expo，为此，运行:</p>
<pre>npm install expo-cli --global</pre>
<p>现在你已经准备好开始了。</p>
<h2>设置应用程序</h2>
<p>要创建应用程序，请运行以下命令:</p>
<pre>expo init apollo-react-native-app</pre>
<p>这将生成一个示例应用程序，您可以在自己的智能手机上通过Expo应用程序访问它，而无需安装它。要做到这一点，你需要从iOS版的<a href="https://apps.apple.com/app/apple-store/id982107779" target="_blank" rel="noopener noreferrer">苹果应用商店</a>或安卓版的<a href="https://play.google.com/store/apps/details?id=host.exp.exponent&amp;referrer=www" target="_blank" rel="noopener noreferrer">谷歌游戏商店</a>下载应用。</p>
<p>通过在终端中从项目的根目录运行<code>expo start</code>来启动应用程序，它会向您显示一个二维码，您可以在Expo应用程序中扫描该二维码，并查看React原生应用程序的实例。很漂亮，对吧？</p>
<p>现在我们已经为我们的应用程序设置了准系统，让我们通过配置我们的Apollo客户机把它连接到GraphQL。</p>
<h2>配置Apollo客户端和基础应用程序</h2>
<p>React 的<a href="https://www.apollographql.com/docs/react/" target="_blank" rel="noopener noreferrer"> Apollo客户端是一个完整的状态管理库，它将负责请求、缓存和管理GraphQL服务器提供的数据，就像我们在</a><a href="https://blog.logrocket.com/create-a-react-native-app-with-postgresql-and-graphql-part-1/" target="_blank" rel="noopener noreferrer">第1部分</a>中构建的一样。我们将在应用程序的入口点<code>App.js</code>设置客户端。但是首先，我们需要通过运行下面的命令来安装必要的依赖项:</p>
<pre>npm install apollo-client apollo-cache-inmemory apollo-link-http react-apollo --save</pre>
<h3>这些包是做什么的？</h3>
<ul>
<li><code>apollo-client</code> —如上所述，这负责与服务器的任何数据交换以及状态管理和缓存</li>
<li><code>apollo-cache-inmemory</code> —从<a href="https://www.apollographql.com/docs/react/caching/cache-configuration/" target="_blank" rel="noopener noreferrer"> Apollo Client 2.0 </a>开始，缓存功能被抽象到<code>apollo-cache-inmemory</code>以利用缓存功能，而无需依赖Redux</li>
<li><code>apollo-link-http</code> —处理网络请求，如获取和发送数据</li>
<li><code>react-apollo</code> —将提供一个<code>ApolloProvider</code>，它将包装应用程序并负责状态管理，类似于React的上下文API</li>
</ul>
<p>现在我们已经了解了应用程序中每个部分的作用，让我们开始设置。在<code>App.js</code>中，导入这些依赖项并如下设置您的客户端:</p>
<pre>import * as React from "react";
import { Platform, StatusBar, StyleSheet, View } from "react-native";

import { AppLoading } from "expo";

import { Asset } from "expo-asset";
import * as Font from "expo-font";

import { InMemoryCache } from "apollo-cache-inmemory";
import { ApolloClient } from "apollo-client";
import { HttpLink } from "apollo-link-http";
import { ApolloProvider } from "react-apollo";

import AppNavigator from "./navigation/AppNavigator";

//Define your client for your ApolloProvider connecting to your graphql server.
const client = new ApolloClient({
  // initialize cache
  cache: new InMemoryCache(),
  //Assign your link with a new instance of a HttpLink linking to your graphql server
  link: new HttpLink({
    uri: "https://graphql-server-node-js-103.herokuapp.com/graphql"
  })
});

const styles = StyleSheet.create({
  container: {
    flex: 1
  }
});

export default class App extends React.Component {
  state = {
    isLoadingComplete: false
  };

  loadResourcesAsync = async () =&gt; {
    await Promise.all([
      Asset.loadAsync([
        // load assets here
      ]),
      Font.loadAsync({
        // load fonts here
      })
    ]);
  };

  handleLoadingError = () =&gt; {
    // Any error handling can be done here
  };

  handleFinishLoading = () =&gt; {
    this.setState({ isLoadingComplete: true });
  };

  render() {
    const { isLoadingComplete } = this.state;
    const { skipLoadingScreen } = this.props;
    if (!isLoadingComplete &amp;&amp; !skipLoadingScreen) {
      return (
        &lt;AppLoading
          startAsync={this.loadResourcesAsync}
          onError={this.handleLoadingError}
          onFinish={this.handleFinishLoading}
        /&gt;
      );
    }
    return (
      &lt;ApolloProvider client={client}&gt;
        &lt;View style={styles.container}&gt;
          &lt;AppNavigator /&gt;
        &lt;/View&gt;
      &lt;/ApolloProvider&gt;
    );
  }
}</pre>
<p>在上面的客户端配置中，我们的<code>ApolloClient</code>有两个参数，<code>cache</code>是来自<code>apollo-cache-inmemory</code>的<code>inMemoryCache</code>的一个实例，它处理数据缓存以加速应用程序，而<code>apollo-link-http</code>的<code>link</code>是一个终止链接，它通过HTTP连接从GraphQL端点获取GraphQL结果。出于本文的目的，我们将它链接到我们后端服务器的一个已部署实例，但是如果您愿意，可以随意地用您自己的本地运行服务器替换它。</p>
<p>客户端配置然后通过<code>ApolloProvider</code>高阶组件作为<code>client</code>道具传递给应用程序，允许应用程序获得我们上面设置的所有功能。</p>
<p>另外一个组件<code>AppLoading</code>也是从Expo中导入的，它是一个React组件，告诉Expo如果它是应用程序中第一个也是唯一一个呈现的组件，就保持应用程序加载屏幕打开。该组件允许应用程序在启动之前加载应用程序所需的任何资产，这创造了更好的用户体验。</p>
<p>在我们的例子中需要三个道具:</p>
<ul>
<li><code>startAsync (<em>func</em>)</code>–返回<code>Promise</code>的<code>function</code>，当应用程序加载完所需的数据和资产时，<code>Promise</code>应该会解析</li>
<li><code>onError (<em>func</em>)</code>–如果<code>startAsync</code>抛出一个错误，它被捕获并传递到提供给<code>onError</code>的函数中</li>
<li><code>onFinish (<em>func</em>)</code>–当<code>startAsync</code>决定或拒绝时调用。这应该用于设置状态和卸载<code>AppLoading</code>组件</li>
</ul>
<p>您可能已经注意到了上面代码中的一些额外设置，不要担心，我们很快会详细介绍每个部分的作用。</p>
<h2>创造我们的航海家</h2>
<p>我们在上面的设置中有一个<code>AppNavigator</code>组件，它负责在我们的应用程序中使用<code><a href="https://reactnavigation.org/en/" target="_blank" rel="noopener noreferrer">react-navigation</a></code>进行路由。这是我们接下来要设置的。</p>
<p>为此，我们需要首先安装一些依赖项:</p>
<pre>npm install react-navigation react-navigation-transistions</pre>
<p>这两个包一起工作，让我们的应用程序可以在屏幕之间平滑过渡，<code>react-navigation</code>处理路由和导航，而<code>react-navigation-transitions</code>允许我们在屏幕之间创建自定义过渡。</p>
<p>在项目的根目录下创建一个<code>navigation</code>文件夹，并在其中创建三个文件<code>AppNavigator.js</code>、<code>MainTabNavigator.js</code>和<code>styles.js</code>。</p>
<p>就像之前一样，我们首先声明我们的风格:</p>
<pre>//styled.js
import styled from "styled-components/native";

const MenuStyle = {
  backgroundColor: "#fcfaf7",
  borderBottomWidth: 0,
  elevation: 0
};

const IconStyle = styled.Image`
  height: 24;
  width: 24;
`;

export { MenuStyle, IconStyle };</pre>
<p>接下来，我们使用来自<code>react-navigation</code>的<code>createStackNavigator</code>来为你的应用程序提供一种在屏幕之间转换的方法，其中每个新屏幕都放在堆栈的顶部。</p>
<p>它有两个参数，第一个是包含我们的路线配置(<code>routeConfig</code>)的对象，第二个是导航器配置(<code>StackNavigatorConfig</code>):</p>
<pre>//MainTabNavigator.js
import React from "react";
import { createStackNavigator } from "react-navigation";
import { fromBottom } from "react-navigation-transitions";
import { TouchableOpacity, View } from "react-native";

import HomeScreen from "../screens/HomeScreen";
import AddNoteScreen from "../screens/AddNoteScreen";
import { Images } from "../constants";
import { MenuStyle, IconStyle } from "./styled";

//Assign your goback navigator to variable call goBackHeader
const goBackHeader = goBack =&gt; (
  &lt;TouchableOpacity
    activeOpacity={1}
    style={{ paddingHorizontal: 20 }}
    onPress={() =&gt; goBack()}
  &gt;
    &lt;View&gt;
      &lt;IconStyle source={Images.back} style={{ height: 15, width: 9 }} /&gt;
    &lt;/View&gt;
  &lt;/TouchableOpacity&gt;
);

const HomeStack = createStackNavigator(
  {
    Home: {
      screen: HomeScreen,
      navigationOptions: ({ navigation: { goBack } }) =&gt; ({
        headerStyle: MenuStyle
      })
    },
    NewNote: {
      screen: AddNoteScreen,
      navigationOptions: ({ navigation: { goBack } }) =&gt; ({
        headerStyle: MenuStyle,
        headerLeft: () =&gt; goBackHeader(goBack)
      })
    }
  },
  {
    transitionConfig: ({ scenes }) =&gt; {
      const nextScene = scenes[scenes.length - 1];
      if (nextScene.route.routeName === "NewNote") return fromBottom(550);
    }
  }
);

export default HomeStack;</pre>
<p>对于我们的<code>routeConfig</code>，我们有两个屏幕<code>Home</code>和<code>NewNote</code>，我们将很快创建它们。每个屏幕都被声明为一个对象，其中包含<code>screen</code>和<code>navigationOptions</code>。在这种情况下，<code>screen</code>映射到要为该屏幕呈现的React组件上，而<code>navigationOptions</code>可用于将多个<a href="https://reactnavigation.org/docs/en/stack-navigator.html#navigationoptions-for-screens-inside-of-the-navigator" target="_blank" rel="noopener noreferrer">选项</a>传递给每个组件。</p>
<p>我们已经通过了以下两个选项，它们是:</p>
<ul>
<li><code>headerLeft</code>–返回React元素并显示在表头左侧的函数。当一个函数被使用时，它在呈现时会接收到许多参数(<code>onPress</code>、<code>title</code>、<code>titleStyle</code>等等)</li>
<li><code>headerStyle</code>–页眉的样式对象</li>
</ul>
<p>在<code>NewNote</code>屏幕上，我们传递了<code>headerStyle</code>和<code>headerLeft</code>，在那里我们映射了一个使用<code>goBackHeader</code>函数声明的后退按钮组件。这个组件采用了一个<code>goBack</code>道具，它是我们从react-navigation的<code>navigate</code>道具中解构出来的。<code>goBack</code>是关闭活动屏幕并在堆栈中向后移动的功能，类似于浏览器上的后退按钮。</p>
<p>我们的<code>StackNavigatorConfig</code>只是一个包含<code>transitionConfig</code>的对象，我们用它来创建一个定制的过渡，使我们的新屏幕从下向上而不是水平(默认)进入视图。</p>
<p>然后，我们将我们的<code>HomeStack</code>传递给<code>createSwitchNavigator</code>，并将其传递给<code>createAppContainer</code>来创建一个应用程序容器，它将帮助您将顶级导航器链接到应用程序环境。<code>SwitchNavigator</code>的目的是一次只显示一个屏幕。</p>
<pre>//AppNavigator.js
import React from 'react';
import { createAppContainer, createSwitchNavigator } from 'react-navigation';

import MainTabNavigator from './MainTabNavigator';

export default createAppContainer(
  createSwitchNavigator({
    Main: MainTabNavigator,
  })
);</pre>
<p>你可以在<a href="https://reactnavigation.org/docs/en/getting-started.html" target="_blank" rel="noopener noreferrer">反应导航文档</a>中读到更多关于<code>createSwitchNavigator</code>和<code>createStackNavigator</code>的信息。</p>
<h2>创建组件</h2>
<p>我们的应用程序将有几个可重用的组件，这些组件将组成它的各种屏幕，这就是我们在使用React Native时引用页面的方式。因此，在构建应用程序的各种屏幕之前，我们会先构建这些组件。</p>
<p>在我们的例子中，我们有四个主要组件将在我们的应用程序中重用，<code>Button</code>、<code>Card</code>、<code>TextInput</code>和<code>KeyboardWrapper</code>。在项目的根目录下创建一个<code>components</code>文件夹，并在其中为每个组件创建一个文件夹。</p>
<p>我们还有一些资产和常量，将在整个应用程序中使用。资产主要是字体和图像。运行<code>mkdir assets</code>在项目根目录下创建一个<code>assets</code>文件夹，并将<a href="https://github.com/jimmykimani/GraphQL-Server-Tutorial-with-Apollo-and-React-Native/tree/setup/apollo-react-native/assets" target="_blank" rel="noopener noreferrer">这个文件夹</a>的内容复制到其中。您现在可以导入它们以在应用程序中使用。</p>
<p>也创建一个<code>constants</code>文件夹，它将保存我们在应用程序中可能用到的任何常量变量，并有助于方便参考。</p>
<p>在constants文件夹中创建一个<code>Colors.js</code>文件，这个文件将保存我们在应用程序中使用的颜色，看起来像这样:</p>
<pre>const white = "#ffffff";
const darkGray = "#595A5A";
const orange = "#FFA500";
const mediumGray = "#9B9B9B";
const strokeGray = "#E6E6E6";

export { orange, darkGray, white, mediumGray, strokeGray };</pre>
<p>在constants文件夹中，创建一个<code>Images.js</code>并添加以下代码:</p>
<pre>const Images = {
  more: require("../assets/images/more.png"),
  back: require("../assets/images/back.png"),
  menu: require("../assets/images/menu.png")
};
export default Images;</pre>
<p>这使得导入图像以供使用变得更加容易。</p>
<p>我们还将有一个<code>Layout.js</code>文件，我们将在其中设置应用程序的基本布局。</p>
<pre>import { Dimensions } from 'react-native';

const width = Dimensions.get('window').width;
const height = Dimensions.get('window').height;

export default {
  window: {
    width,
    height,
  },
  isSmallDevice: width &lt; 375,
};</pre>
<p>通过从目录中的一个<code>index.js</code>文件导出声明的常量，可以使从<code>constants</code>目录导入变得更加容易。以下是你如何利用这些图像来做到这一点:</p>
<pre>import Images from "./Images";
export { Images };</pre>
<p>既然我们已经建立了主要的资源，让我们开始创建我们将要重用的单独的组件。</p>
<h2>纽扣</h2>
<p>让我们创建我们的第一个组件，一个<code>Button</code>组件，在<code>Button</code>目录中创建两个文件<code>index.js</code>和<code>styled.js</code>。在<code>styled.js</code>中放置以下代码，它将使用<a href="https://www.styled-components.com/" target="_blank" rel="noopener noreferrer">样式组件</a>处理<code>Button</code>组件的基本样式:</p>
<pre>import styled from "styled-components/native";
const white = "#FFFFFF";

const baseButtonStyles = `
  letter-spacing: 0.5px;
  font-size: 12px;
  color: ${white}
`;

const ButtonStyle = `
  ${baseButtonStyles}
  background-color:#4A4A4A;
    color: ${white}
`;

const StyledButton = styled.TouchableOpacity`
  ${ButtonStyle}
  align-items: center;
`;

const StyledButtonText = styled.Text`
  color: ${white};
  line-height: 19px;
`;

const ButtonText = styled.Text`
  font-family: WorkSans-SemiBold;
  color: ${white};
  line-height: 19px;
  justify-content: center;
  align-items: center;
`;

export { ButtonText, StyledButtonText, StyledButton };</pre>
<p>现在在<code>index.js</code>中添加以下内容:</p>
<pre>import React from "react";
import { ifIphoneX } from "react-native-iphone-x-helper";

import { StyledButtonText, StyledButton } from "./styled";

const Button = props =&gt; {
  const { title, ...rest } = props;
  return (
    &lt;StyledButton
      activeOpacity={0.7}
      color={"#4A4A4A"}
      underlayColor={"#4A4A4A"}
      {...rest}
    &gt;
      &lt;StyledButtonText
        style={{
          ...ifIphoneX(
            {
              paddingTop: 27,
              paddingBottom: 50
            },
            {
              paddingTop: 27,
              paddingBottom: 26
            }
          )
        }}
      &gt;
        {title.toUpperCase()}
      &lt;/StyledButtonText&gt;
    &lt;/StyledButton&gt;
  );
};

export default Button;</pre>
<p>我们导入在<code>styled.js</code>中声明的样式化组件，并用它们来创建我们的按钮。你还会注意到我们已经从<a href="https://github.com/ptelad/react-native-iphone-x-helper" target="_blank" rel="noopener noreferrer">react-native-iPhone-X-helper</a>导入了<code>ifIphoneX</code>，这有助于我们解释iPhone X、XS、XS Max &amp; XR的布局差异。这种方法允许我们在考虑iPhone X的情况下创建样式表。接受两个参数，第一个是iPhone X上的样式，第二个是常规样式，并相应地应用它们。</p>
<h2>卡片</h2>
<p>接下来，我们将创建我们的<code>Card</code>组件，这将是我们的主要显示组件，我们将使用卡片来显示每个笔记。正如我们对按钮所做的一样，我们将首先在一个<code>styled.js</code>中创建我们的样式化组件:</p>
<pre>import styled from "styled-components/native";
import {
  strokeGray,
  darkGray,
  white,
  mediumGray
} from "../../constants/Colors";

const CardContainer = styled.View`
  background-color: #d8d8d8;
  border-style: solid;
  width: 100%;
  padding: 16px 16px 16px 16px;
  text-align: center;
  border-radius: 9px;
  margin-bottom: 20px;
`;

const TimestampContainer = styled.Text`
  font-size: 10px;
  text-transform: uppercase;
  line-height: 12px;
  color: ${mediumGray};
  padding-top: 16px;
`;

const EditWrapper = styled.TouchableOpacity`
  margin-left: auto;
  margin-top: 5px;
`;

const EditIcon = styled.Image`
  height: 4px;
  width: 20px;
`;

const CardText = styled.Text`
  font-weight: 500;
  color: ${darkGray};
  line-height: 23px;
  font-size: 16px;
  width: 90%;
`;

const HeaderContainer = styled.View`
  display: flex;
  flex-direction: row;
`;

export {
  CardContainer,
  TimestampContainer,
  EditWrapper,
  EditIcon,
  CardText,
  HeaderContainer
};
</pre>
<p>然后我们将它们导入到<code>index.js</code>中，就像我们对按钮所做的那样:</p>
<pre>import React from "react";
import PropTypes from "prop-types";
import { Images } from "../../constants";

import {
  CardContainer,
  TimestampContainer,
  EditWrapper,
  EditIcon,
  CardText,
  HeaderContainer
} from "./styled";

const NoteCard = props =&gt; {
  const { onOptions, noteText } = props;
  return (
    &lt;CardContainer&gt;
      &lt;HeaderContainer&gt;
        &lt;CardText&gt;{noteText}&lt;/CardText&gt;
        &lt;EditWrapper onPress={onOptions}&gt;
          &lt;EditIcon source={Images.more} /&gt;
        &lt;/EditWrapper&gt;
      &lt;/HeaderContainer&gt;
      &lt;TimestampContainer&gt;1 hour ago&lt;/TimestampContainer&gt;
    &lt;/CardContainer&gt;
  );
};
export default NoteCard;</pre>
<h2>键盘包装</h2>
<p>该组件触发移动设备上的虚拟键盘，我们使用React Native的<code><a href="https://facebook.github.io/react-native/docs/keyboardavoidingview" target="_blank" rel="noopener noreferrer">KeyboardAvoidingView</a></code>组件，该组件允许视图通过相应地调整其大小和位置来移动虚拟键盘:</p>
<pre>import React from "react";
import { KeyboardAvoidingView, Platform } from "react-native";
import { Header } from "react-navigation";
import { ifIphoneX } from "react-native-iphone-x-helper";
import PropTypes from "prop-types";

const KeyboardWrapper = props =&gt; {
  const { children } = props;

  return (
    &lt;KeyboardAvoidingView
      behavior={Platform.OS === "android" ? null : "padding"}
      keyboardVerticalOffset={
        ifIphoneX ? Header.HEIGHT + 1 : Header.HEIGHT + 18
      }
      style={{ flex: 1 }}
    &gt;
      {children}
    &lt;/KeyboardAvoidingView&gt;
  );
};

KeyboardWrapper.propTypes = {
  children: PropTypes.node.isRequired
};

export default KeyboardWrapper;</pre>
<h2>TextInput组件</h2>
<p>这个组件正如它的名字所暗示的那样，充当我们文本的输入，并带有一个占位符。首先，让我们在<code>styled.js</code>中声明我们的风格:</p>
<pre>import styled from "styled-components/native";

const BaseStyles = `

  border-width: 1px;
  border-style: solid;
  width: 100%;
  padding: 10px 16px;
`;
const InputStyles = `
  ${BaseStyles}
  font-size: 16px;
`;

const StyledTextArea = styled.TextInput`
  ${InputStyles}
  flex: 1;
  background-color: transparent;
  border-radius: 0;
  padding-left: 0px;
  border-width: 0;
  font-size: 20px;
  margin-bottom: 0;
  color: #ffffff;
  /* font-family: WorkSans-Regular; */
`;

export { StyledTextArea };</pre>
<p>现在，让我们创建占位符，我们将使用样式化组件创建的<code>Text</code>元素包装在以类似方式创建的<code>TouchableOpacity</code>元素中。这允许应用程序通过拉起键盘让您键入笔记来响应您触摸占位符:</p>
<pre>import React from "react";
import styled from "styled-components/native";

const chGray = "#E6E4E3";

const RowContainer = styled.TouchableOpacity`
  flex-direction: row;
  width: 100%;
  background-color: ${chGray};
  border-radius: 30px;
  width: 100%;
  margin-bottom: 24px;
  padding: 8px 16px;
`;

const StyledTextInput = styled.Text`
  /* font-family: WorkSans-Regular; */
  color: #4a4a4a;
  opacity: 0.8;
  font-size: 14px;
  line-height: 22px;
`;

const TextPlaceHolder = props =&gt; {
  const { text, onHolderPress } = props;
  return (
    &lt;RowContainer activeOpacity={1} onPress={onHolderPress}&gt;
      &lt;StyledTextInput&gt;{text}&lt;/StyledTextInput&gt;
    &lt;/RowContainer&gt;
  );
};

export default TextPlaceHolder;</pre>
<p>现在让我们创建我们的<code>TextArea</code>组件，它是我们输入的文本将出现的地方，我们已经在<code>styled.js</code>中将它创建为<code>StyledTextArea</code>,这里我们只是将一些常量(特别是占位符文本颜色)和一些属性传递给它:</p>
<pre>import React from "react";
import { mediumGray } from "../../constants/Colors";

import { StyledTextArea } from "./styled";

const TextArea = props =&gt; {
  const { ...rest } = props;
  return (
    &lt;StyledTextArea
      keyboardAppearance="dark"
      placeholderTextColor={"#4a4a4a"}
      {...rest}
    /&gt;
  );
};

export default TextArea;</pre>
<p>现在让我们导出<code>index.js</code>中的所有内容，以便更清晰地导入其他文件:</p>
<pre>import TextPlaceHolder from "./Placeholder";
import TextArea from "./TextArea";

export { TextPlaceHolder, TextArea };</pre>
<h2>创建屏幕并添加GraphQL集成</h2>
<p>屏幕是我们应用程序的页面，每个页面都由许多协同工作的组件组成。我们的应用程序有两个主屏幕。就像我们的组件一样，我们将首先使用styled-components来定义一个<code>styled.js</code>文件中的屏幕元素的样式:</p>
<pre>import styled from "styled-components/native";

const Container = styled.View`
  flex: 1;
  padding: 20px;
  background-color: #fcfaf7;
`;

const NotesContainer = styled.View`
  flex: 1;
  background-color: #fcfaf7;
`;

const NotesWrapper = styled.View`
  padding: 20px;
`;

const PlaceholdeWrapper = styled.View`
  padding-top: 12px;
`;

const HeaderText = styled.Text`
  font-weight: 900;
  font-size: 36px;
  padding-bottom: 20px;
  color: #b89b72;
`;

export {
  Container,
  PlaceholdeWrapper,
  NotesContainer,
  NotesWrapper,
  HeaderText
};</pre>
<h2>主屏幕</h2>
<p>主屏幕将是中心屏幕，我们创建的所有笔记都将在这里显示。这是我们查看和删除注释的地方，当它为空(没有添加注释)时，对于iPhone用户来说，它看起来像这样:</p>
<p><img data-attachment-id="12205" data-permalink="https://blog.logrocket.com/how-to-create-a-react-native-app-with-postgresql-and-graphql-part-2/attachment/nonotesadded/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/01/nonotesadded.jpeg" data-orig-size="591,1280" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="nonotesadded" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/01/nonotesadded-139x300.jpeg" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/01/nonotesadded-473x1024.jpeg" decoding="async" class="aligncenter wp-image-12205 size-large jetpack-lazy-image" src="../Images/45145a02ee68e49597d717b0dfb8d28b.png" alt="empty notes for iphone users" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2020/01/nonotesadded-473x1024.jpeg 473w, https://blog.logrocket.com/wp-content/uploads/2020/01/nonotesadded-139x300.jpeg 139w, https://blog.logrocket.com/wp-content/uploads/2020/01/nonotesadded.jpeg 591w" data-lazy-sizes="(max-width: 473px) 100vw, 473px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2020/01/nonotesadded-473x1024.jpeg?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/01/nonotesadded-473x1024.jpeg"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="12205" data-permalink="https://blog.logrocket.com/how-to-create-a-react-native-app-with-postgresql-and-graphql-part-2/attachment/nonotesadded/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/01/nonotesadded.jpeg" data-orig-size="591,1280" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="nonotesadded" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/01/nonotesadded-139x300.jpeg" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/01/nonotesadded-473x1024.jpeg" decoding="async" loading="lazy" class="aligncenter wp-image-12205 size-large" src="../Images/45145a02ee68e49597d717b0dfb8d28b.png" alt="empty notes for iphone users" srcset="https://blog.logrocket.com/wp-content/uploads/2020/01/nonotesadded-473x1024.jpeg 473w, https://blog.logrocket.com/wp-content/uploads/2020/01/nonotesadded-139x300.jpeg 139w, https://blog.logrocket.com/wp-content/uploads/2020/01/nonotesadded.jpeg 591w" sizes="(max-width: 473px) 100vw, 473px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/01/nonotesadded-473x1024.jpeg"/></noscript>
<p>一旦添加了注释，它将看起来像这样:</p>
<p><img data-attachment-id="12207" data-permalink="https://blog.logrocket.com/how-to-create-a-react-native-app-with-postgresql-and-graphql-part-2/attachment/notes/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/01/notes.jpeg" data-orig-size="591,1280" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="notes" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/01/notes-139x300.jpeg" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/01/notes-473x1024.jpeg" decoding="async" class="aligncenter wp-image-12207 size-large jetpack-lazy-image" src="../Images/160eaed498ac7bb2f5dbeb233533a6a8.png" alt="ui with notes added" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2020/01/notes-473x1024.jpeg 473w, https://blog.logrocket.com/wp-content/uploads/2020/01/notes-139x300.jpeg 139w, https://blog.logrocket.com/wp-content/uploads/2020/01/notes.jpeg 591w" data-lazy-sizes="(max-width: 473px) 100vw, 473px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2020/01/notes-473x1024.jpeg?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/01/notes-473x1024.jpeg"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="12207" data-permalink="https://blog.logrocket.com/how-to-create-a-react-native-app-with-postgresql-and-graphql-part-2/attachment/notes/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/01/notes.jpeg" data-orig-size="591,1280" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="notes" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/01/notes-139x300.jpeg" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/01/notes-473x1024.jpeg" decoding="async" loading="lazy" class="aligncenter wp-image-12207 size-large" src="../Images/160eaed498ac7bb2f5dbeb233533a6a8.png" alt="ui with notes added" srcset="https://blog.logrocket.com/wp-content/uploads/2020/01/notes-473x1024.jpeg 473w, https://blog.logrocket.com/wp-content/uploads/2020/01/notes-139x300.jpeg 139w, https://blog.logrocket.com/wp-content/uploads/2020/01/notes.jpeg 591w" sizes="(max-width: 473px) 100vw, 473px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/01/notes-473x1024.jpeg"/></noscript>
<p>在screens目录中，创建一个<code>HomeScreen.js</code>文件，我们将使用这个文件。</p>
<p>首先，让我们为屏幕导入一些组件和依赖项，并将GraphQL <code>query</code>和<code>mutation</code>变量分别定义为<code>GET_NOTES</code>和<code>DELETE_NOTE</code>。我们这样做是为了告诉API我们希望返回哪些数据以供使用:</p>
<pre>import React, { Component } from "react";
import {
  ScrollView,
  FlatList,
  ActivityIndicator,
  View,
  Alert
} from "react-native";
import ActionSheet from "react-native-actionsheet";
//Import the Query component from react apollo that will responsible for retrieving data from your graphql server.
import { Query, Mutation } from "react-apollo";
//import gql from graphql-tag for making queries to our graphql server.
import gql from "graphql-tag";

import { Container, PlaceholdeWrapper, HeaderText } from "./styled";
import { Button, NoteCard, TextPlaceHolder } from "../components";

//Define your query variable which is the query responsible for retrieving data
//This will query all notes
const GET_NOTES = gql`
  query {
    notes {
      id
      text
    }
  }
`;

const DELETE_NOTE = gql`
  mutation DeleteNote($id: ID!) {
    deleteNote(id: $id) {
      id
      text
    }
  }
`;</pre>
<p>接下来，让我们定义我们的<code>HomeScreen</code>类组件并添加一些实用函数，它们将负责以下目的:</p>
<ul>
<li><code>_addNewNote</code> —将用户导航至<code>New Note</code>屏幕</li>
<li><code>_renderItem</code> —呈现便笺</li>
<li><code>_showEditDeleteOptions</code> —为给定注释选择编辑/删除选项，如下所示:</li>
</ul>
<p><img data-attachment-id="12211" data-permalink="https://blog.logrocket.com/how-to-create-a-react-native-app-with-postgresql-and-graphql-part-2/attachment/showdeleteoptions/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/01/showDeleteOptions.jpeg" data-orig-size="591,1280" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="showDeleteOptions" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/01/showDeleteOptions-139x300.jpeg" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/01/showDeleteOptions-473x1024.jpeg" decoding="async" class="aligncenter wp-image-12211 size-large jetpack-lazy-image" src="../Images/8e3253d9f0b1d24d1f4985992e5a6302.png" alt="showDeleteOptions" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2020/01/showDeleteOptions-473x1024.jpeg 473w, https://blog.logrocket.com/wp-content/uploads/2020/01/showDeleteOptions-139x300.jpeg 139w, https://blog.logrocket.com/wp-content/uploads/2020/01/showDeleteOptions.jpeg 591w" data-lazy-sizes="(max-width: 473px) 100vw, 473px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2020/01/showDeleteOptions-473x1024.jpeg?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/01/showDeleteOptions-473x1024.jpeg"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="12211" data-permalink="https://blog.logrocket.com/how-to-create-a-react-native-app-with-postgresql-and-graphql-part-2/attachment/showdeleteoptions/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/01/showDeleteOptions.jpeg" data-orig-size="591,1280" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="showDeleteOptions" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/01/showDeleteOptions-139x300.jpeg" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/01/showDeleteOptions-473x1024.jpeg" decoding="async" loading="lazy" class="aligncenter wp-image-12211 size-large" src="../Images/8e3253d9f0b1d24d1f4985992e5a6302.png" alt="showDeleteOptions" srcset="https://blog.logrocket.com/wp-content/uploads/2020/01/showDeleteOptions-473x1024.jpeg 473w, https://blog.logrocket.com/wp-content/uploads/2020/01/showDeleteOptions-139x300.jpeg 139w, https://blog.logrocket.com/wp-content/uploads/2020/01/showDeleteOptions.jpeg 591w" sizes="(max-width: 473px) 100vw, 473px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/01/showDeleteOptions-473x1024.jpeg"/></noscript>
<ul>
<li><code>_deletePostPrompt</code> —提示用户删除或取消删除注释</li>
<li><code>_deleteNote</code> —提示给定音符上的GraphQL <code>delete</code>突变</li>
</ul>
<pre>class HomeScreen extends Component {
  constructor(props) {
    super(props);
    this.state = {
      noteId: null
    };
  }

  _addNewNote = () =&gt; {
    const { navigation } = this.props;
    navigation.navigate("NewNote", {});
  };

  _renderItem({ item }) {
    //Return the UI
    // It will return a list of all notes
    return (
      &lt;NoteCard
        noteText={item.text}
        onOptions={() =&gt; this._showEditDeleteOptions(item.id)}
      /&gt;
    );
  }

  _showEditDeleteOptions = async noteId =&gt; {
    await this.setState({ noteId });
    this.deleteActionSheet.show();
  };

  _deletePostPrompt = noteId =&gt; {
    Alert.alert("Delete Note ?", null, [
      {
        text: "Delete",
        onPress: () =&gt; {
          this._deleteNote({ noteId });
        }
      },
      {
        text: "Cancel",
        style: "cancel"
      }
    ]);
  };

  _deleteNote = noteId =&gt; {
    &lt;Mutation
      mutation={DELETE_NOTE}
      update={store =&gt; {
        const storeNotes = store.readQuery({ query: GET_NOTES });
        const data = storeNotes.notes.filter(note =&gt; note.id !== noteId);
        store.writeQuery({
          query: GET_NOTES,
          data: { notes: [...data] }
        });
      }}
    &gt;
    &lt;/Mutation&gt;;
  };

 //render here

export default HomeScreen;</pre>
<p>使用react-apollo的<code>Query</code>组件获取并显示注释，该组件接受一个<code>query</code>属性，该属性是我们希望从GraphQL API中获取的数据的描述。然后，根据获取的数据以及错误和加载状态，有条件地将UI呈现为其子组件。我们将把它包含在我们的渲染函数中，我们将用这个替换<code>//render here</code>注释:</p>
<pre>render() {
  const { noteId } = this.state;
  return (
    &lt;Container&gt;
      &lt;View&gt;
        &lt;ActionSheet
          ref={o =&gt; (this.deleteActionSheet = o)}
          options={["Delete", "Cancel"]}
          cancelButtonIndex={1}
          destructiveButtonIndex={0}
          onPress={index =&gt; {
            if (index === 0) this._deletePostPrompt(noteId);
          }}
        /&gt;
      &lt;/View&gt;
      &lt;ScrollView showsVerticalScrollIndicator={false}&gt;
        &lt;HeaderText&gt;My Notes&lt;/HeaderText&gt;
        &lt;PlaceholdeWrapper&gt;
          &lt;TextPlaceHolder
            onHolderPress={() =&gt; this._addNewNote()}
            text={"Add new note"}
          /&gt;
        &lt;/PlaceholdeWrapper&gt;
        &lt;Query query={GET_NOTES}&gt;
          {/* The props.children of the Query will be a callback with a response, and error parameter. */}
          {(response, error, loading) =&gt; {
            if (error) {
              return &lt;Text style={styles.errorText}&gt;{error}&lt;/Text&gt;;
            }
            if (loading) {
              return &lt;ActivityIndicator /&gt;;
            }
            //If the response is done, then will return the FlatList
            if (response) {
              //Return the FlatList if there is not an error.
              return (
                &lt;FlatList
                  data={response.data.notes}
                  renderItem={item =&gt; this._renderItem(item)}
                /&gt;
              );
            }
          }}
        &lt;/Query&gt;
      &lt;/ScrollView&gt;
    &lt;/Container&gt;
  );
}
}</pre>
<p>在上面的例子中，从我们的端点获取的包含注释的任何数据都被传递到<code>FlatList</code>组件，然后该组件通过<code>renderItem</code> prop呈现一个卡片列表。<code>renderItem</code> prop通常是一个函数，它从一段数据中返回一个要呈现的React组件。</p>
<p>使用react-apollo的<code>Mutation</code>组件删除注释，该组件接受一个<code>mutation</code>属性，该属性是一个GraphQL文档，描述了要删除的注释的细节。它还需要一个<code>update</code>道具，这个函数更新缓存以反映删除一个注释后的变化。</p>
<h2>添加NoteScreen</h2>
<p><code>AddNote</code>是负责接收用户输入的屏幕，并通过将数据传递给我们的GraphQL API来使用它创建新的便笺。我们将在一个文件中创建它:</p>
<pre>import * as WebBrowser from "expo-web-browser";
import React, { Component } from "react";
import { ScrollView } from "react-native";
//import Mutation component for performing queries.
import { Mutation } from "react-apollo";
// import gql from graphql-tag to define your graphql schema
import gql from "graphql-tag";

import { NotesContainer, NotesWrapper } from "./styled";
import { Button, TextArea, KeyboardWrapper } from "../components";

const CREATE_NOTE = gql`
  mutation CreateNote($text: String!) {
    createNewNote(text: $text) {
      id
      text
    }
  }
`;

const GET_NOTES = gql`
  query {
    notes {
      id
      text
    }
  }
`;

class AddNoteScreen extends Component {
  constructor(props) {
    super(props);
    this.state = {
      note: ""
    };
  }

  _addNote = postAction =&gt; {
    const { note } = this.state;
    const { navigation } = this.props;
    return (
      &lt;Button
        onPress={() =&gt;
          postAction({
            variables: { text: note }
          }).then(navigation.goBack())
        }
        title={"Add new note"}
      /&gt;
    );
  };

  render() {
    const { note } = this.state;

    return (
      &lt;KeyboardWrapper&gt;
        &lt;NotesContainer&gt;
          &lt;ScrollView&gt;
            &lt;NotesWrapper&gt;
              &lt;TextArea
                autoFocus
                value={note}
                returnKeyType="next"
                placeholder={"Jot Something"}
                //onChangeText is basically a simplified version of onChange,
                //so you can easily use it, without the hassle of going through event.target.value to get changed value.
                onChangeText={text =&gt; this.setState({ note: text })}
              /&gt;
            &lt;/NotesWrapper&gt;
          &lt;/ScrollView&gt;
          &lt;Mutation
            mutation={CREATE_NOTE}
            update={(store, { data: { createNewNote } }) =&gt; {
              const data = store.readQuery({ query: GET_NOTES });
              store.writeQuery({
                query: GET_NOTES,
                data: { notes: data.notes.concat([createNewNote]) }
              });
            }}
          &gt;
            {(postAction, { loading, error }) =&gt; {
              return this._addNote(postAction);
            }}
          &lt;/Mutation&gt;
        &lt;/NotesContainer&gt;
      &lt;/KeyboardWrapper&gt;
    );
  }
}

export default AddNoteScreen;</pre>
<p>以下是在用户键入任何文本之前，带有占位符的屏幕外观:</p>
<p><img data-attachment-id="12215" data-permalink="https://blog.logrocket.com/how-to-create-a-react-native-app-with-postgresql-and-graphql-part-2/attachment/addanewnote/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/01/addanewnote.jpeg" data-orig-size="591,1280" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="addanewnote" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/01/addanewnote-139x300.jpeg" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/01/addanewnote-473x1024.jpeg" decoding="async" class="aligncenter wp-image-12215 size-large jetpack-lazy-image" src="../Images/2a8aba4669fd4bc9c964576ffd52b360.png" alt="add a new note" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2020/01/addanewnote-473x1024.jpeg 473w, https://blog.logrocket.com/wp-content/uploads/2020/01/addanewnote-139x300.jpeg 139w, https://blog.logrocket.com/wp-content/uploads/2020/01/addanewnote.jpeg 591w" data-lazy-sizes="(max-width: 473px) 100vw, 473px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2020/01/addanewnote-473x1024.jpeg?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/01/addanewnote-473x1024.jpeg"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="12215" data-permalink="https://blog.logrocket.com/how-to-create-a-react-native-app-with-postgresql-and-graphql-part-2/attachment/addanewnote/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/01/addanewnote.jpeg" data-orig-size="591,1280" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="addanewnote" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/01/addanewnote-139x300.jpeg" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/01/addanewnote-473x1024.jpeg" decoding="async" loading="lazy" class="aligncenter wp-image-12215 size-large" src="../Images/2a8aba4669fd4bc9c964576ffd52b360.png" alt="add a new note" srcset="https://blog.logrocket.com/wp-content/uploads/2020/01/addanewnote-473x1024.jpeg 473w, https://blog.logrocket.com/wp-content/uploads/2020/01/addanewnote-139x300.jpeg 139w, https://blog.logrocket.com/wp-content/uploads/2020/01/addanewnote.jpeg 591w" sizes="(max-width: 473px) 100vw, 473px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/01/addanewnote-473x1024.jpeg"/></noscript>
<p>我们的<code>AddNoteScreen</code>使用GraphQL的<code>Mutation</code>组件创建一个新的笔记，类似于我们删除笔记的方式。在这种情况下，<code>mutation</code>属性是一个GraphQL文档，包含要创建的新便笺的详细信息，它接受一个文本参数，即组成便笺内容的文本字符串。</p>
<p><code>Mutation</code>也采用了一个<code>update</code>属性，类似于删除一个注释时的做法，该属性负责用新创建的注释更新缓存。</p>
<p>组件之间的一个主要区别是它们的子组件。<code>Query</code>将React节点作为其子节点，根据运行查询的结果呈现UI。另一方面，<code>Mutation</code>有一个函数作为它的子函数，这个函数触发了我们的GraphQL API上的一个突变。</p>
<p>输入文本后，您的<code>NewNote</code>屏幕看起来是这样的:</p>
<p><img data-attachment-id="12218" data-permalink="https://blog.logrocket.com/how-to-create-a-react-native-app-with-postgresql-and-graphql-part-2/attachment/typenewnote/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/01/typenewnote.jpeg" data-orig-size="591,1280" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="typenewnote" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/01/typenewnote-139x300.jpeg" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/01/typenewnote-473x1024.jpeg" decoding="async" class="aligncenter wp-image-12218 size-large jetpack-lazy-image" src="../Images/28561d5abb4675548f3870eee59ea5d5.png" alt="type new note" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2020/01/typenewnote-473x1024.jpeg 473w, https://blog.logrocket.com/wp-content/uploads/2020/01/typenewnote-139x300.jpeg 139w, https://blog.logrocket.com/wp-content/uploads/2020/01/typenewnote.jpeg 591w" data-lazy-sizes="(max-width: 473px) 100vw, 473px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2020/01/typenewnote-473x1024.jpeg?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/01/typenewnote-473x1024.jpeg"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="12218" data-permalink="https://blog.logrocket.com/how-to-create-a-react-native-app-with-postgresql-and-graphql-part-2/attachment/typenewnote/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/01/typenewnote.jpeg" data-orig-size="591,1280" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="typenewnote" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/01/typenewnote-139x300.jpeg" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/01/typenewnote-473x1024.jpeg" decoding="async" loading="lazy" class="aligncenter wp-image-12218 size-large" src="../Images/28561d5abb4675548f3870eee59ea5d5.png" alt="type new note" srcset="https://blog.logrocket.com/wp-content/uploads/2020/01/typenewnote-473x1024.jpeg 473w, https://blog.logrocket.com/wp-content/uploads/2020/01/typenewnote-139x300.jpeg 139w, https://blog.logrocket.com/wp-content/uploads/2020/01/typenewnote.jpeg 591w" sizes="(max-width: 473px) 100vw, 473px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/01/typenewnote-473x1024.jpeg"/></noscript>
<h2>结论</h2>
<p>React Native和GraphQL配合得非常好，可以创建一个优秀的移动应用程序。React Native允许开发人员创建“一次编写，随处运行”的应用程序，因为它与Android和iOS都兼容。GraphQL允许应用程序只获取它们需要的特定信息，从而使它们更加高效。总的来说，这两种技术是构建移动应用程序时要考虑的很好的选择。您可以利用本文提供的信息，尝试为我们构建的应用程序创建一个编辑特性。</p><div class="code-block code-block-17">
<div class="blog-plug inline-plug react-plug" vwo-el-id="26283398190">
<h2 vwo-el-id="41600691720">使用LogRocket消除传统反应错误报告的噪音</h2>
<a href="https://lp.logrocket.com/blg/react-signup-issue-free" target="_blank" vwo-el-id="19356441070">LogRocket
</a><p>是一款React analytics解决方案，可保护您免受数百个误报错误警报的影响，只针对少数真正重要的项目。LogRocket告诉您React应用程序中实际影响用户的最具影响力的bug和UX问题。</p><a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="19356441380">
<img class="first-react-image alignnone size-full wp-image-46 jetpack-lazy-image jetpack-lazy-image--handled" src="../Images/f300c244a1a1cf916df8b4cb02bec6c6.png" vwo-el-id="18272717540" data-lazy-loaded="1" data-original-src="https://files.readme.io/27c94e7-Image_2017-06-05_at_9.46.04_PM.png"/>
</a>
<a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="19356441690">
<img class="second-react-image alignnone size-full wp-image-46 jetpack-lazy-image jetpack-lazy-image--handled" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" vwo-el-id="30720362350" data-lazy-loaded="1" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/>
</a>
<a href="https://lp.logrocket.com/blg/react-signup-issue-free" target="_blank" rel="noopener noreferrer" vwo-el-id="35866400580">LogRocket
</a><p>自动聚合客户端错误、反应错误边界、还原状态、缓慢的组件加载时间、JS异常、前端性能指标和用户交互。然后，LogRocket使用机器学习来通知您影响大多数用户的最具影响力的问题，并提供您修复它所需的上下文。</p><p vwo-el-id="28675661060">关注重要的React bug—<a class="signup" href="https://lp.logrocket.com/blg/react-signup-issue-free" target="_blank" rel="noopener noreferrer" vwo-el-id="40093418840">今天就试试LogRocket】。</a></p>
</div></div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
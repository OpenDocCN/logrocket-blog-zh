<html>
<head>
<title>How TypeScript breaks referential transparency - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>TypeScript如何打破引用透明性</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/how-typescript-breaks-referential-transparency-7a82c0345f2c/#0001-01-01">https://blog.logrocket.com/how-typescript-breaks-referential-transparency-7a82c0345f2c/#0001-01-01</a></blockquote><div><article class="article-post">
<figure><img decoding="async" src="../Images/e0465458bc8b697a2b039c0df88e0b99.png" data-height="630" data-width="1200" data-lazy-src="https://storage.googleapis.com/blog-images-backup/1*KTh3puTlJIF6vAuUUu_LAQ.jpeg?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" class=" jetpack-lazy-image" data-original-src="https://storage.googleapis.com/blog-images-backup/1*KTh3puTlJIF6vAuUUu_LAQ.jpeg"/><noscript><img data-lazy-fallback="1" decoding="async" src="../Images/e0465458bc8b697a2b039c0df88e0b99.png" data-height="630" data-width="1200" data-original-src="https://storage.googleapis.com/blog-images-backup/1*KTh3puTlJIF6vAuUUu_LAQ.jpeg"/></noscript></figure>
<p>您是否曾经在TypeScript中分解出一个常量，却让类型检查器开始报告一些神秘的错误？这有一个根本原因。在这篇文章中，我将展示这个问题的几个例子，解释它为什么会发生，并提出一些可能的解决方法。</p>
<h3>JavaScript中的引用透明性</h3>
<p>假设我们有一个函数<code>purchase</code>，它为我们购买了一件产品:</p>
<figure>
<pre><code>function purchase(product) { /* ... */ }
purchase('Macbook Air');</code></pre>
</figure>
<p>我们称之为“内嵌表单”在JavaScript中，您可以将内联参数分解到一个变量中，并传递一个引用，而无需更改代码的行为:</p>
<figure>
<pre><code>const product = 'Macbook Air';
purchase(product);  // reference form</code></pre>
</figure>
<p>这有时被称为参照透明性或替代原则。它指的是你可以用它的值替换一个表达式而不改变行为的思想。这与代码没有副作用密切相关，并且有助于对程序正确性的推理。</p>
<p>只要不改变求值的顺序，在JavaScript中以这种方式分解变量应该不会改变表达式的结果。</p>
<h3>类型脚本中的引用透明性</h3>
<p>在JavaScript中分解变量是可行的，但是在TypeScript中呢？</p>
<figure>
<pre><code>export function purchase(what: string) { /* ... */ }

purchase('Macbook Air');  // Inline

const product = 'Macbook Air';
purchase(product);  // reference</code></pre>
</figure>
<p>到目前为止一切顺利！</p>
<p>现在让我们把它变得更复杂一点，假设我们正在使用地图可视化，它允许我们以编程方式平移地图:</p>
<figure>
<pre><code>// Parameter is a (latitude, longitude) pair.
function panTo(where: [number, number]) { /* ... */ }

// Inline:
panTo([10, 20]);  // inline: ok

// Reference:
const loc = [10, 20];
panTo(loc);  // reference. Will this work?</code></pre>
</figure>
<p>如果你在<a href="http://www.typescriptlang.org/play/#src=export%20function%20panTo%28where%3A%20%5Bnumber%2C%20number%5D%29%20%7B%20%7D%0D%0A%0D%0Aconst%20loc%20%3D%20%5B10%2C%2020%5D%3B%0D%0ApanTo%28loc%29%3B%0D%0A" target="_blank" rel="noopener noreferrer"> TypeScript playground </a>中运行这个，你会得到一个错误:</p>
<figure><img decoding="async" src="../Images/ed3880a7a169293ed5e34bb3052ff972.png" data-height="338" data-width="1136" data-lazy-src="https://storage.googleapis.com/blog-images-backup/0*lLuI-Bz-o5n4oKb-?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" class=" jetpack-lazy-image" data-original-src="https://storage.googleapis.com/blog-images-backup/0*lLuI-Bz-o5n4oKb-"/><noscript><img data-lazy-fallback="1" decoding="async" src="../Images/ed3880a7a169293ed5e34bb3052ff972.png" data-height="338" data-width="1136" data-original-src="https://storage.googleapis.com/blog-images-backup/0*lLuI-Bz-o5n4oKb-"/></noscript></figure>
<p>相关部分是这样的:</p>
<pre>Argument of type ‘number[]’ is not assignable to parameter of type '[number, number]'.</pre>
<p>你可以将鼠标放在<a href="http://www.typescriptlang.org/play/#src=export%20function%20panTo%28where%3A%20%5Bnumber%2C%20number%5D%29%20%7B%20%7D%0D%0A%0D%0Aconst%20loc%20%3D%20%5B10%2C%2020%5D%3B%0D%0ApanTo%28loc%29%3B%0D%0A" target="_blank" rel="noopener noreferrer">打字稿游戏场</a>的<code>loc</code>符号上，以便更清楚地了解正在发生的事情:</p>
<figure><img decoding="async" src="../Images/b1da736b922acf5efd81c042f0d82132.png" data-height="120" data-width="438" data-lazy-src="https://storage.googleapis.com/blog-images-backup/0*oAbjC3RK0qk3XRWn?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" class=" jetpack-lazy-image" data-original-src="https://storage.googleapis.com/blog-images-backup/0*oAbjC3RK0qk3XRWn"/><noscript><img data-lazy-fallback="1" decoding="async" src="../Images/b1da736b922acf5efd81c042f0d82132.png" data-height="120" data-width="438" data-original-src="https://storage.googleapis.com/blog-images-backup/0*oAbjC3RK0qk3XRWn"/></noscript></figure>
<p>TypeScript已经将<code>loc</code>的类型推断为<code>number[]</code>，即长度未知的数字数组。当这被传递给<code>panTo</code>时，TypeScript检查<code>number[]</code>(一个数字数组)是否可赋给<code>[number, number]</code>(一对数字)。这不是因为有些数组没有两个元素。因此出现了错误。</p>
<p>为什么TypeScript推断类型为<code>number[]</code>而不是<code>[number, number]</code>？因为这是有效的JavaScript:</p>
<figure>
<pre><code>const loc = [10, 20];
loc.push(30);</code></pre>
</figure>
<p>换句话说，JavaScript中的<code>const</code>并不深奥。您不能重新分配<code>loc</code>，但可以修改它。一些语言(例如C++)允许你对精确的常量深度建模，但是JavaScript和TypeScript <a href="https://github.com/Microsoft/TypeScript/issues/26979" target="_blank" rel="noopener noreferrer">不允许。</a></p>
<p>那么如何解决这个问题呢？一种简单的方法是在代码中加入<code>any</code>类型，以有效地消除警告:</p>
<figure>
<pre><code>const loc: any = [10, 20];
panTo(loc);
const loc = [10, 20];
panTo(loc as any);</code></pre>
</figure>
<p>如果您打算这样做，后一种形式更可取，因为<code>any</code>的作用域是函数调用，不会阻止对代码中其他地方的<code>loc</code>使用进行类型检查。</p>
<p>更好的解决方案是准确地告诉TypeScript您的意思:</p>
<figure>
<pre><code>const loc: [number, number] = [10, 20];
panTo(loc);</code></pre>
</figure>
<p>这有点冗长，但就类型安全而言，这是最好的解决方案。</p>
<h3>推理和字符串类型</h3>
<p>前面的例子表明，引用透明性可以打破元组类型。但这并不是唯一可能出现的情况。</p>
<p>让我们从帖子的开头重新回顾一下购买示例。让我们使用字符串文字类型的联合来细化允许您购买的产品类型:</p>
<figure>
<pre><code>type Product = 'iPad' | 'Mac Mini' | 'Macbook Air' | 'Macbook Pro';
export function purchase(what: Product) {
 // mine bitcoin…
 // send to apple…
}</code></pre>
</figure>
<p>购买内联表达式和通过引用购买都有效:</p>
<figure>
<pre><code>purchase('Macbook Air');
const newToy = 'Macbook Air';
purchase(newToy);  // ok</code></pre>
</figure>
<p>然而，如果我们使用<code>let</code>而不是<code>const</code>，TypeScript会抱怨:</p>
<figure><img decoding="async" src="../Images/9829e20a042199c3d3147d74103926b7.png" data-height="254" data-width="1188" data-lazy-src="https://storage.googleapis.com/blog-images-backup/0*FVK6fNBJZHHsNDSj?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" class=" jetpack-lazy-image" data-original-src="https://storage.googleapis.com/blog-images-backup/0*FVK6fNBJZHHsNDSj"/><noscript><img data-lazy-fallback="1" decoding="async" src="../Images/9829e20a042199c3d3147d74103926b7.png" data-height="254" data-width="1188" data-original-src="https://storage.googleapis.com/blog-images-backup/0*FVK6fNBJZHHsNDSj"/></noscript></figure>
<p>错误在于<code>Argument of type ‘string’ is not assignable to parameter of type ‘Product’</code>。使用<code>let</code>告诉TypeScript我们希望允许<code>newToy</code>被重新分配。TypeScript不知道我们希望为<code>newToy</code>允许的可能值的域，所以它猜测<code>string</code>。当我们使用<code>const</code>时，它不能被重新分配，因此TypeScript可以推断出更窄的字符串文字类型<code>"Macbook Air"</code>。</p>
<p>和以前一样，解决方案是告诉TypeScript我们的意思:</p>
<figure>
<pre><code>let newToy: Product = 'Macbook Air';
purchase(newToy); // ok</code></pre>
</figure>
<p>因为<code>const</code>很肤浅，它不是解决这类问题的灵丹妙药。当推断对象中属性的类型时，仍然会出现这种情况。例如:</p>
<figure><img decoding="async" src="../Images/d550df9274ff1e06e6d95a8c19ed9958.png" data-height="312" data-width="1176" data-lazy-src="https://storage.googleapis.com/blog-images-backup/0*bpXKXVNNbnPSE4KO?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" class=" jetpack-lazy-image" data-original-src="https://storage.googleapis.com/blog-images-backup/0*bpXKXVNNbnPSE4KO"/><noscript><img data-lazy-fallback="1" decoding="async" src="../Images/d550df9274ff1e06e6d95a8c19ed9958.png" data-height="312" data-width="1176" data-original-src="https://storage.googleapis.com/blog-images-backup/0*bpXKXVNNbnPSE4KO"/></noscript></figure>
<p>和之前一样，错误在于<code>'string' is not assignable to type 'Product'</code>。这是因为<code>what</code>的类型被推断为<code>string</code>以允许这种模式:</p>
<figure>
<pre><code>const order = {
  what: 'Macbook Air',
  how: 'bitcoin'
};
order.what = 'Lenovo'; // valid</code></pre>
</figure>
<p>和以前一样，解决方案是告诉TypeScript您的意思。一种方法是使用类型转换:</p>
<figure>
<pre><code>const order = {
  what: 'Macbook Air' as Product, // or "as 'MacbookAir'"
  how: 'bitcoin'
};
purchase(order.what); // ok</code></pre>
</figure>
<p>另一种是通过定义一个<code>Order</code>接口来指定其属性的精确类型:</p>
<figure>
<pre><code>interface Order {
  what: Product;
  how: 'bitcoin' | 'usd';
}
const order: Order = {
  what: 'Macbook Air',
  how: 'bitcoin'
};
purchase(order.what); // ok</code></pre>
</figure>
<p>如果您遇到这样的错误，涉及到对第三方库的调用，那么您最好的办法是在类型声明中找到相关的类型。让我们看一个真实世界的例子。</p>
<h3>推理和反应</h3>
<p>下面是一些React代码，它使用<a href="https://github.com/alex3165/react-mapbox-gl/" target="_blank" rel="noopener noreferrer"> react-mapbox-gl </a>包装器呈现了一个<a href="https://docs.mapbox.com/mapbox-gl-js/api/" target="_blank" rel="noopener noreferrer"> Mapbox GL </a>地图:</p>
<figure>
<pre><code>import * as React from 'react';
import ReactMapboxGl from 'react-mapbox-gl';

const Map = ReactMapboxGl({
  accessToken: '....',
});

export function render(): JSX.Element {
  return (
    &lt;Map
      style="mapbox://styles/mapbox/streets-v9"
      center={[-73.991284, 40.741263]}
      zoom={[14.5]}
      pitch={[45]}
      bearing={[-17.6]}
    &gt;
        { /* ... */ }
    &lt;/Map&gt;
  );
}</code></pre>
</figure>
<p>如果我们将初始视口分解成一个常数，我们会得到一个很长的错误:</p>
<figure><img decoding="async" src="../Images/6aa3f2f068f1f6ce84e958dd9b13955f.png" data-height="1132" data-width="1148" data-lazy-src="https://storage.googleapis.com/blog-images-backup/0*534CmZ9gjroI_fBR?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" class=" jetpack-lazy-image" data-original-src="https://storage.googleapis.com/blog-images-backup/0*534CmZ9gjroI_fBR"/><noscript><img data-lazy-fallback="1" decoding="async" src="../Images/6aa3f2f068f1f6ce84e958dd9b13955f.png" data-height="1132" data-width="1148" data-original-src="https://storage.googleapis.com/blog-images-backup/0*534CmZ9gjroI_fBR"/></noscript></figure>
<p>相关的一点是:</p>
<pre>Types of property 'center' are incompatible.
 Type 'number[]' is missing the following properties from type '[number, number]': 0, 1</pre>
<p><code>center</code> prop应该是<code>[number, number]</code>(一对数字)，但是TypeScript已经推断出<code>INIT_VIEW.center</code>的类型为<code>number[]</code>(一个数组)。所以这真的是和以前一样的问题！和以前一样，最好的解决方案是为<code>INIT_VIEW</code>指定一个类型。</p>
<p>但是如果你查看react-mapbox-gl 的<a href="https://github.com/alex3165/react-mapbox-gl/blob/005a7a1d903dd0f7d64035bfc3d3cd30fdafbe7e/src/map.tsx#L45-L61" target="_blank" rel="noopener noreferrer">类型，最接近的是<code>Props</code>结构，它包含了<code>INIT_VIEW</code>中的所有属性，还有一些:</a></p>
<figure>
<pre><code>export interface Props {
  style: string | MapboxGl.Style;
  center?: [number, number];
  zoom?: [number];
  maxBounds?: MapboxGl.LngLatBounds | FitBounds;
  fitBounds?: FitBounds;
  fitBoundsOptions?: FitBoundsOptions;
  bearing?: [number];
  pitch?: [number];
  containerStyle?: React.CSSProperties;
  className?: string;
  movingMethod?: 'jumpTo' | 'easeTo' | 'flyTo';
  animationOptions?: Partial&lt;AnimationOptions&gt;;
  flyToOptions?: Partial&lt;FlyToOptions&gt;;
  children?: JSX.Element | JSX.Element[] | Array&lt;JSX.Element | undefined&gt;;
}</code></pre>
</figure>
<p>所以我们不能只写<code>const INIT_VIEW: Props</code>来解决问题，因为我们的常量没有所需的<code>style</code>属性。所以我们需要调整类型。最简单的方法是使用<code><a href="https://netbasal.com/getting-to-know-the-partial-type-in-typescript-ecfcfbc87cb6" target="_blank" rel="noopener noreferrer">Partial</a></code>，这使得一个类型中的所有属性都是可选的:</p>
<figure>
<pre><code>const INIT_VIEW: Partial&lt;Props&gt; = {
  center: [-73.991284, 40.741263],
  zoom: [14.5],
  pitch: [45],
  bearing: [-17.6],
};

export function render(): JSX.Element {
  return (
    &lt;Map
      style="mapbox://styles/mapbox/streets-v9"
      {...INIT_VIEW}  // ok
    &gt;
        { /* ... */ }
    &lt;/Map&gt;
  );
}</code></pre>
</figure>
<p>只要你想提取的所有属性都是可选的，这个技巧就有效。如果我们还想去掉<code>style</code>(这是必需的)，那么我们会得到一个错误:<code>Property 'style' is optional in type …</code>。通过使用<code>Partial</code>，我们已经告诉TypeScript忘记我们已经显式设置了<code>style</code>。</p>
<p>一种解决方案是使用<code><a href="https://levelup.gitconnected.com/advanced-typescript-types-with-examples-1d144e4eda9e" target="_blank" rel="noopener noreferrer">Pick</a></code>提取感兴趣的属性及其类型。与<code>Partial</code>不同，这将跟踪我们设置了哪些属性，哪些属性没有设置:</p>
<figure>
<pre><code>const INIT_VIEW: Pick&lt;MapProps, 'center'|'zoom'|'pitch'|'bearing'|'style'&gt; = {
  center: [-73.991284, 40.741263],
  zoom: [14.5],
  pitch: [45],
  bearing: [-17.6],
  style: "mapbox://styles/mapbox/streets-v9"
};</code></pre>
</figure>
<p>不幸的是，我们不得不重复打字中的键。幸运的是，您可以使用StackOverflow中的这个<a href="https://stackoverflow.com/a/46101222/388951" target="_blank" rel="noopener noreferrer">古怪的技巧</a>来定义一个帮助器来为您推断密钥:</p>
<figure>
<pre><code>const inferPick = &lt;V extends {}&gt;() =&gt; &lt;K extends keyof V&gt;(x: Pick&lt;V, K&gt;): Pick&lt;V, K&gt; =&gt; x;

const INIT_VIEW = inferPick&lt;MapProps&gt;()({
  center: [-73.991284, 40.741263],
  zoom: [14.5],
  pitch: [45],
  bearing: [-17.6],
  style: "mapbox://styles/mapbox/streets-v9"
});</code></pre>
</figure>
<p>包装器是不幸的，但是缺少重复使得这是一个更好的解决方案。任何缩小器都应该能够删除函数调用。</p>
<p>如果常量(ala<a href="https://facebook.github.io/react-native/docs/style" target="_blank" rel="noopener noreferrer">style sheet . create in React Native</a>)有几种可能，那么情况就有点复杂了。您可以尝试一种索引类型:</p>
<pre><code>const views: {[viewName: string]: Partial&lt;Props&gt;} = {
 nyc: …,
 sf: …
};</code></pre>
<p>这是可行的，但是它会阻止TypeScript标记像<code>views.london</code>这样的无效引用。您可以使用与上一个类似的技巧来解决这个问题:</p>
<figure>
<pre><code>const inferKeys = &lt;V extends {}&gt;() =&gt; &lt;K extends string&gt;(x: Record&lt;K,V&gt;): Record&lt;K,V&gt; =&gt; x;

const INIT_VIEW = inferKeys&lt;Partial&lt;MapProps&gt;&gt;()({
  nyc: {
    center: [-73.991284, 40.741263],
    zoom: [14.5],
    pitch: [45],
    bearing: [-17.6],
  },
  sf: {
    center: [-73.991284, 40.741263],
    zoom: [14.5],
    pitch: [45],
    bearing: [-17.6],
  }
});

export function render(): JSX.Element {
  return (
    &lt;Map
      style="mapbox://styles/mapbox/streets-v9"
      {...INIT_VIEW.nyc}  // ok
    &gt;
        { /* ... */ }
    &lt;/Map&gt;
  );
}</code></pre>
</figure>
<h3>结论</h3>
<p>当您提取一个常量并遇到一个令人困惑的TypeScript错误时，您可能会遇到一个关于类型推断和引用透明性的<a href="https://github.com/Microsoft/TypeScript/issues/27502" target="_blank" rel="noopener noreferrer">问题</a>。正如我们在这篇文章中看到的，解决方案通常是找到或创建一个可以在作业中使用的类型。有时这很容易，有时却不容易。</p>
<p>这是学习TypeScript的一个难点，因为它会产生复杂的错误，涉及TypeScript的类型系统的高级元素，以进行简单、有效的代码转换。TypeScript团队有着为这类问题提出巧妙解决方案的历史，他们正在积极讨论这个问题。敬请关注！</p><div class="code-block code-block-17">
<div class="blog-plug inline-plug react-plug" vwo-el-id="26283398190">
<h2 vwo-el-id="41600691720">使用LogRocket消除传统反应错误报告的噪音</h2>
<a href="https://lp.logrocket.com/blg/react-signup-issue-free" target="_blank" vwo-el-id="19356441070">LogRocket
</a><p>是一款React analytics解决方案，可保护您免受数百个误报错误警报的影响，只针对少数真正重要的项目。LogRocket告诉您React应用程序中实际影响用户的最具影响力的bug和UX问题。</p><a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="19356441380">
<img class="first-react-image alignnone size-full wp-image-46 jetpack-lazy-image jetpack-lazy-image--handled" src="../Images/f300c244a1a1cf916df8b4cb02bec6c6.png" vwo-el-id="18272717540" data-lazy-loaded="1" data-original-src="https://files.readme.io/27c94e7-Image_2017-06-05_at_9.46.04_PM.png"/>
</a>
<a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="19356441690">
<img class="second-react-image alignnone size-full wp-image-46 jetpack-lazy-image jetpack-lazy-image--handled" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" vwo-el-id="30720362350" data-lazy-loaded="1" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/>
</a>
<a href="https://lp.logrocket.com/blg/react-signup-issue-free" target="_blank" rel="noopener noreferrer" vwo-el-id="35866400580">LogRocket
</a><p>自动聚合客户端错误、反应错误边界、还原状态、缓慢的组件加载时间、JS异常、前端性能指标和用户交互。然后，LogRocket使用机器学习来通知您影响大多数用户的最具影响力的问题，并提供您修复它所需的上下文。</p><p vwo-el-id="28675661060">关注重要的React bug—<a class="signup" href="https://lp.logrocket.com/blg/react-signup-issue-free" target="_blank" rel="noopener noreferrer" vwo-el-id="40093418840">今天就试试LogRocket】。</a></p><div class="code-block code-block-21">
<div class="blog-plug inline-plug typescript-plug"><h2><a class="signup" href="https://lp.logrocket.com/blg/typescript-signup" target="_blank" rel="noopener noreferrer"> LogRocket </a>:全面了解您的网络和移动应用</h2>
<a href="https://lp.logrocket.com/blg/typescript-signup" class="signup" target="_blank" rel="noopener noreferrer"><img class="alignnone size-full wp-image-46 jetpack-lazy-image" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/><noscript><img data-lazy-fallback="1" class="alignnone size-full wp-image-46" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/></noscript></a>
<p>LogRocket 是一个前端应用程序监控解决方案，可以让您回放问题，就像问题发生在您自己的浏览器中一样。LogRocket不需要猜测错误发生的原因，也不需要向用户询问截图和日志转储，而是让您重放会话以快速了解哪里出错了。它可以与任何应用程序完美配合，不管是什么框架，并且有插件可以记录来自Redux、Vuex和@ngrx/store的额外上下文。</p>
<p>除了记录Redux操作和状态，LogRocket还记录控制台日志、JavaScript错误、堆栈跟踪、带有头+正文的网络请求/响应、浏览器元数据和自定义日志。它还使用DOM来记录页面上的HTML和CSS，甚至为最复杂的单页面和移动应用程序重新创建像素级完美视频。</p>
<a class="signup" href="https://lp.logrocket.com/blg/typescript-signup" target="_blank" rel="noopener noreferrer">Try it for free</a><p>.</p></div>
</div>
</div></div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
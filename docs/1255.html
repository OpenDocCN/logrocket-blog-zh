<html>
<head>
<title>JWT authentication in Rust - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>Rust - LogRocket博客中的JWT认证</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/jwt-authentication-in-rust/#0001-01-01">https://blog.logrocket.com/jwt-authentication-in-rust/#0001-01-01</a></blockquote><div><article class="article-post">
<p>JSON Web token(jwt)是一种安全地表示系统间属性或声明的标准。它们可以以客户机-服务器的方式使用，以实现无状态授权，而cookies本质上是有状态的。</p>
<p/>
<p>然而，它们比这更灵活，还可以用在许多其他方面。一个突出的用例是微服务架构中的安全用户状态传播。在这样的设置中，jwt的用例可以完全局限于后端，前端有状态授权机制。登录后，会话令牌被映射到JWT，然后在微服务集群中用于授权请求(访问控制)，以及分发用户状态(信息分发)。</p>
<p>这样做的好处是，其他服务或客户端不需要重新提取信息，这些信息存储在JWT中。例如，用户角色、用户电子邮件或您需要定期访问的任何内容都可以编码到JWT中。因为jwt是加密签名的，所以存储在其中的数据是安全的，不容易被操纵。</p>
<p>在本教程中，我们将解释如何在Rust web应用程序中使用jwt实现身份验证和授权。我们不会详细讨论jwt本身；关于这个话题已经有了大量的资源。</p>
<p>我们将构建的示例将更多地关注JWTs的访问控制部分，因此我们将只在令牌中保存用户ID和用户角色——这是我们确保用户被允许访问资源所需的一切。</p>
<p>与安全相关的博客帖子一样，这里有一个简短的免责声明:这篇博客帖子中显示的代码还没有准备好投入生产，不应该复制/粘贴。这个例子的唯一目的是展示在构建身份验证/授权系统时可能会用到的一些概念、技术和库。</p>
<p>说完了，让我们开始吧！</p>
<h2 id="setup">设置</h2>
<p>接下来，您需要一个最新的Rust安装(1.39+)和一个发送HTTP请求的工具，比如cURL。</p>
<p>首先，创建一个新的Rust项目。</p>
<pre>cargo new rust-jwt-example
cd rust-jwt-example
</pre>
<p>接下来，编辑<code>Cargo.toml</code>文件并添加您需要的依赖项。</p>
<pre>[dependencies]
jsonwebtoken = "=7.2"
tokio = { version = "0.2", features = ["macros", "rt-threaded", "sync", "time"] }
warp = "0.2"
serde = {version = "1.0", features = ["derive"] }
serde_json = "1.0"
thiserror = "1.0"
chrono = "0.4"
</pre>
<p>我们将使用轻量级warp库构建web应用程序，该库使用tokio作为其异步运行时。我们将使用Serde进行JSON处理，使用Thiserror和Chrono分别处理错误和日期。</p>
<p>为了处理JSON Web令牌，我们将使用名为<a href="https://crates.io/crates/jsonwebtoken" target="_blank" rel="noopener noreferrer"> jsonwebtoken </a>的机箱，这是一个成熟的、在Rust生态系统中广泛使用的工具。</p>
<h2 id="webserver">网络服务器</h2>
<p>我们将从创建一个简单的web服务器开始，该服务器有几个端点和一个内存用户存储。在实际应用中，我们可能会有一个用于用户存储的数据库。但是，因为这对我们的例子来说并不重要，我们将简单地把它们硬编码在内存中。</p>
<pre>type Result&lt;T&gt; = std::result::Result&lt;T, error::Error&gt;;
type WebResult&lt;T&gt; = std::result::Result&lt;T, Rejection&gt;;
type Users = Arc&lt;RwLock&lt;HashMap&lt;String, User&gt;&gt;&gt;;
</pre>
<p>这里我们为<code>Result</code>定义了两个助手类型，指定了一个内部结果类型用于在整个应用程序中传播错误，一个外部结果类型用于向调用者发送错误。</p>
<p>我们还定义了<code>Users</code>类型，它是一个共享的<code>HashMap</code>。这是我们的内存用户存储，我们可以这样初始化它:</p>
<pre>mod auth;
mod error;

#[derive(Clone)]
pub struct User {
    pub uid: String,
    pub email: String,
    pub pw: String,
    pub role: String,
}

#[tokio::main]
async fn main() {
    let users = Arc::new(RwLock::new(init_users()));
    ...
}

fn init_users() -&gt; HashMap&lt;String, User&gt; {
    let mut map = HashMap::new();
    map.insert(
        String::from("1"),
        User {
            uid: String::from("1"),
            email: String::from("<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="700503150230050315021c111e145e131f1d">[email protected]</a>"),
            pw: String::from("1234"),
            role: String::from("User"),
        },
    );
    map.insert(
        String::from("2"),
        User {
            uid: String::from("2"),
            email: String::from("<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="d1b0b5bcb8bf91b0b5bcb8bfb0a5a8ffb2bebc">[email protected]</a>"),
            pw: String::from("4321"),
            role: String::from("Admin"),
        },
    );
    map
}
</pre>
<p>我们使用一个<code>HashMap</code>，它使我们能够很容易地通过用户的ID进行搜索。该映射被包装在一个<code>RwLock</code>中，因为多个线程可以同时访问用户映射。这也是它最终被放入<code>Arc</code>的原因——一个原子的、引用计数的智能指针——它使我们能够在线程之间共享这个映射。</p>
<p>由于我们正在构建一个异步web服务，并且我们无法预先知道我们的处理程序未来将在哪些线程上运行，所以我们需要使我们传递的所有内容都是线程安全的。</p>
<p>我们将用两个用户设置用户映射:一个角色为<code>User</code>，另一个角色为<code>Admin</code>。稍后，我们将创建端点，这些端点只能由<code>Admin</code>角色访问。这样，我们可以测试我们的授权逻辑是否按预期工作。</p>
<p>由于我们使用warp，我们还需要构建一个过滤器来将用户地图传递给端点。</p>
<pre>fn with_users(users: Users) -&gt; impl Filter&lt;Extract = (Users,), Error = Infallible&gt; + Clone {
    warp::any().map(move || users.clone())
}
</pre>
<p>完成第一步设置后，我们可以定义一些基本的路由并启动web服务器。</p>
<pre>#[tokio::main]
async fn main() {
    let users = Arc::new(RwLock::new(init_users()));

    let login_route = warp::path!("login")
        .and(warp::post())
        .and_then(login_handler);

    let user_route = warp::path!("user")
        .and_then(user_handler);
    let admin_route = warp::path!("admin")
        .and_then(admin_handler);

    let routes = login_route
        .or(user_route)
        .or(admin_route)
        .recover(error::handle_rejection);

    warp::serve(routes).run(([127, 0, 0, 1], 8000)).await;
}

pub async fn login_handler() -&gt; WebResult&lt;impl Reply&gt; {
    Ok("Login")
}

pub async fn user_handler() -&gt; WebResult&lt;impl Reply&gt; {
    Ok("User")
}

pub async fn admin_handler() -&gt; WebResult&lt;impl Reply&gt; {
    Ok("Admin")
}
</pre>
<p>在上面的代码片段中，我们定义了三个处理程序:</p>
<ul>
<li><code>POST /login</code> —使用电子邮件和密码登录</li>
<li><code>GET /user</code> —每个用户的端点</li>
<li><code>GET /admin</code> —仅供管理员使用的终端</li>
</ul>
<p>先不要担心<code>.recover(error::handle_rejection)</code>；稍后我们将处理错误处理。</p>
<h2 id="authentication">证明</h2>
<p>让我们构建登录功能，以便用户和管理员可以进行身份验证。</p>
<p>第一步是获取<code>login_handler</code>中的凭证。</p>
<pre>#[derive(Deserialize)]
pub struct LoginRequest {
    pub email: String,
    pub pw: String,
}

#[derive(Serialize)]
pub struct LoginResponse {
    pub token: String,
}
</pre>
<p>这是我们为登录机制定义的API。客户机发送一封电子邮件和密码，并接收一个JSON Web令牌作为响应，然后客户机可以使用这个令牌通过将这个令牌放入<code>Authorization: Bearer $token</code>头字段来发出认证请求。</p>
<p>我们把这个定义为<code>login_handler</code>的一个体，就像这样:</p>
<pre>async fn main() {
    ...
    let login_route = warp::path!("login")
        .and(warp::post())
        .and(with_users(users.clone()))
        .and(warp::body::json())
        .and_then(login_handler);
    ...
}
</pre>
<p>在<code>login_handler</code>中，签名和实现更改为:</p>
<pre>pub async fn login_handler(users: Users, body: LoginRequest) -&gt; WebResult&lt;impl Reply&gt; {
    match users.read() {
        Ok(read_handle) =&gt; {
            match read_handle
                .iter()
                .find(|(_uid, user)| user.email == body.email &amp;&amp; user.pw == body.pw)
            {
                Some((uid, user)) =&gt; {
                    let token = auth::create_jwt(&amp;uid, &amp;Role::from_str(&amp;user.role))
                        .map_err(|e| reject::custom(e))?;
                    Ok(reply::json(&amp;LoginResponse { token }))
                }
                None =&gt; Err(reject::custom(WrongCredentialsError)),
            }
        }
        Err(_) =&gt; Err(reject()),
    }
}
</pre>
<p>这里发生了什么事？首先，我们通过调用<code>.read()</code>来访问共享的<code>Users</code>地图，这为我们提供了地图上的读锁。这就是我们目前所需要的。</p><div class="code-block code-block-54">
<hr/>
<h3>更多来自LogRocket的精彩文章:</h3>

<hr/></div>
<p>然后，我们迭代这个只读版本的用户映射，试图找到一个具有传入主体中提供的<code>email</code>和<code>pw</code>的用户。</p>
<p>如果我们没有找到用户，我们返回一个<code>WrongCredentialsError</code>，告诉用户他们没有使用有效的凭证。否则，我们用现有用户的用户ID和角色调用<code>auth::create_jwt</code>，这将返回一个<code>token</code>。这是我们返回给调用者的内容。</p>
<p>接下来我们来看看<code>auth</code>模块。</p>
<p>在<code>auth.rs</code>中，我们首先定义一些有用的数据类型和常量。</p>
<pre>const BEARER: &amp;str = "Bearer ";
const JWT_SECRET: &amp;[u8] = b"secret";

#[derive(Clone, PartialEq)]
pub enum Role {
    User,
    Admin,
}

impl Role {
    pub fn from_str(role: &amp;str) -&gt; Role {
        match role {
            "Admin" =&gt; Role::Admin,
            _ =&gt; Role::User,
        }
    }
}

impl fmt::Display for Role {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter&lt;'_&gt;) -&gt; fmt::Result {
        match self {
            Role::User =&gt; write!(f, "User"),
            Role::Admin =&gt; write!(f, "Admin"),
        }
    }
}

#[derive(Debug, Deserialize, Serialize)]
struct Claims {
    sub: String,
    role: String,
    exp: usize,
}
</pre>
<p><code>Role</code>枚举仅仅是<code>Admin</code>和<code>User</code>角色的映射，所以我们不需要处理字符串，这对于像这样的安全关键的东西来说太容易出错了。</p>
<p>我们还定义了helper方法，在来自<code>Role</code>枚举的字符串之间进行转换，因为这个角色保存在JWT中。</p>
<p>另一个重要类型是<code>Claims</code>。这是我们将保存在内部并期望我们的jwt的数据。<code>sub</code>描绘了所谓的主体，所以在这种情况下是“谁”。<code>exp</code>是令牌的到期日期。我们还将用户<code>role</code>作为自定义数据点放在那里。</p>
<p>这两个常量是预期的<code>Authorization</code>头的前缀和非常重要的<code>JWT_SECRET</code>。这是我们用来签署JSON Web令牌的密钥。在真实的系统中，这将是一个很长的、安全存储的、定期更改的字符串。如果这个秘密泄露出去，任何人都可以解码用这个秘密创建的所有jwt。例如，您还可以为每个用户使用不同的密码，这样，在数据泄露的情况下，只需更改这个密码，您就可以轻松地使用户的所有令牌失效。</p>
<p>接下来我们来看看<code>create_jwt</code>函数。</p>
<pre>use jsonwebtoken::{decode, encode, Algorithm, DecodingKey, EncodingKey, Header, Validation};

pub fn create_jwt(uid: &amp;str, role: &amp;Role) -&gt; Result&lt;String&gt; {
    let expiration = Utc::now()
        .checked_add_signed(chrono::Duration::seconds(60))
        .expect("valid timestamp")
        .timestamp();

    let claims = Claims {
        sub: uid.to_owned(),
        role: role.to_string(),
        exp: expiration as usize,
    };
    let header = Header::new(Algorithm::HS512);
    encode(&amp;header, &amp;claims, &amp;EncodingKey::from_secret(JWT_SECRET))
        .map_err(|_| Error::JWTTokenCreationError)
}
</pre>
<p>首先，我们计算这个令牌的到期日期。在这种情况下，我们只将其设置为未来60秒。这对测试来说很好，因为我们不必等待令牌过期很久。</p>
<p>可以使用不同的策略来定义到期集，但是由于这些令牌是安全关键的，并且包含敏感的信息，因此它们肯定会在某个时候到期。一些系统依赖于刷新令牌机制，设置短的(几分钟/几小时)过期时间，并向调用者提供刷新令牌，如果旧令牌过期，可以使用该刷新令牌来获得新令牌。</p>
<p>接下来，我们用用户的ID、用户的角色和到期日期创建<code>Claims</code>结构。之后是我们与<code>jsonwebtoken</code>箱子的第一次互动。</p>
<p>如果你以前和jwt打过交道，你会知道它们由三部分组成:</p>
<ol>
<li>页眉</li>
<li>有效载荷</li>
<li>签名</li>
</ol>
<p>这反映在这里，因为我们创建了一个新的头部和编码这个头部，加上我们的有效载荷(索赔)与上述秘密。如果失败，我们将返回一个错误。否则，我们返回结果JWT。</p>
<p>现在用户可以登录我们的服务，但是我们还没有处理授权的机制。我们接下来会看到这一点。</p>
<h2 id="authorization">批准</h2>
<p>我们待在<code>auth.rs</code>模块内。因为我们使用warp，所以向我们的处理程序添加额外功能(比如中间件)的最佳方式是使用过滤器。</p>
<p>所以我们定义了一个<code>with_auth</code>过滤器。</p>
<pre>use warp::{
    filters::header::headers_cloned,
    http::header::{HeaderMap, HeaderValue, AUTHORIZATION},
    reject, Filter, Rejection,
};

pub fn with_auth(role: Role) -&gt; impl Filter&lt;Extract = (String,), Error = Rejection&gt; + Clone {
    headers_cloned()
        .map(move |headers: HeaderMap&lt;HeaderValue&gt;| (role.clone(), headers))
        .and_then(authorize)
}
</pre>
<p>例如，可以使用<code>.and(with_auth(Role::Admin)</code>将这个过滤器添加到端点，这意味着这个处理程序只能由具有<code>Admin</code>角色的用户访问。</p>
<p>因为在现实世界的系统中，我们很可能在这一步中连接到数据库、缓存或其他外部系统，所以我决定创建一个<code>async</code>过滤器。在这种情况下，这并不是严格必需的，但是在用户存储不是静态的内存映射的任何情况下，它都会派上用场。</p>
<p>我们需要采取几个步骤来授权用户:</p>
<ul>
<li>获取<code>Authorization</code>头；如果它不存在，就失败</li>
<li>验证标头，确保它具有有效的格式(<code>Bearer $JWT</code>)；如果不是这样，就失败</li>
<li>从标题中提取JWT字符串；如果这不起作用，就失败</li>
<li>解码JWT；如果无效或过期，则失败</li>
<li>检查保存在JWT中的角色，并与给定的<code>role</code>进行比较；例如，如果JWT角色是<code>User</code>，但是端点需要<code>Admin</code>，则失败</li>
<li>从JWT中提取<code>uid</code>,将其传递给修饰的处理程序</li>
</ul>
<p>那可是好几步啊！我们需要小心处理错误，因为这里的任何错误都会导致严重的漏洞。</p>
<p>在上面的<code>with_auth</code>函数中，我们使用<code>headers_cloned()</code> warp过滤器来获取存储在map中的请求头的副本。然后我们将它与<code>role</code>捆绑在一起，并将其传递给<code>authorize</code>函数，这是授权功能的核心。</p>
<pre>async fn authorize((role, headers): (Role, HeaderMap&lt;HeaderValue&gt;)) -&gt; WebResult&lt;String&gt; {
    match jwt_from_header(&amp;headers) {
        Ok(jwt) =&gt; {
            ...
        }
        Err(e) =&gt; return Err(reject::custom(e)),
    }
}
</pre>
<p>由于这是一个<code>async</code>函数，我们需要在过滤器中使用<code>and_then</code>。正如我在上面提到的，在这个例子中这是不必要的，但是在一个真实的例子中，你也可以在这里传递一个外部系统的句柄，你可能需要它来进行授权。例如，用于将会话令牌映射到内部令牌或获取一些所需元数据的缓存或数据库。</p>
<p>在这个例子中，我们首先使用头文件映射调用<code>jwt_from_header</code>函数，从<code>Authorization</code>头文件中获取JWT。</p>
<pre>fn jwt_from_header(headers: &amp;HeaderMap&lt;HeaderValue&gt;) -&gt; Result&lt;String&gt; {
    let header = match headers.get(AUTHORIZATION) {
        Some(v) =&gt; v,
        None =&gt; return Err(Error::NoAuthHeaderError),
    };
    let auth_header = match std::str::from_utf8(header.as_bytes()) {
        Ok(v) =&gt; v,
        Err(_) =&gt; return Err(Error::NoAuthHeaderError),
    };
    if !auth_header.starts_with(BEARER) {
        return Err(Error::InvalidAuthHeaderError);
    }
    Ok(auth_header.trim_start_matches(BEARER).to_owned())
}
</pre>
<p>这个函数执行前两步，检查<code>Authorization</code>头是否存在，是否有效，是否包含<code>Bearer</code>前缀，并提取JWT。如果一切顺利，它将这个字符串返回给调用者。</p>
<p>回到<code>authorize</code>函数，下一步是<code>decode</code>JWT以获得有效的<code>Claims</code>结构。</p>
<pre>async fn authorize((role, headers): (Role, HeaderMap&lt;HeaderValue&gt;)) -&gt; WebResult&lt;String&gt; {
    match jwt_from_header(&amp;headers) {
        Ok(jwt) =&gt; {
            let decoded = decode::&lt;Claims&gt;(
                &amp;jwt,
                &amp;DecodingKey::from_secret(JWT_SECRET),
                &amp;Validation::new(Algorithm::HS512),
            )
            .map_err(|_| reject::custom(Error::JWTTokenError))?;

            if role == Role::Admin &amp;&amp; Role::from_str(&amp;decoded.claims.role) != Role::Admin {
                return Err(reject::custom(Error::NoPermissionError));
            }

            Ok(decoded.claims.sub)
        }
        Err(e) =&gt; return Err(reject::custom(e)),
    }
}
</pre>
<p>如果JWT过期、格式错误或以任何方式无效，此解码步骤将失败，我们将在此停止。<code>jsonwebtoken</code>库甚至为验证步骤提供了一些定制选项，这在<a href="https://docs.rs/jsonwebtoken/7.2.0/jsonwebtoken/struct.Validation.html" target="_blank" rel="noopener noreferrer">官方文档</a>中有很好的描述。</p>
<p>如果验证成功，我们可以检查用户角色。如果我们在一个<code>Admin</code>端点，JWT角色也需要是<code>Admin</code>。如果不是，我们扔一个<code>NoPermissionError</code>。</p>
<p>因为我们只有这两个角色，所以这个检查相当容易，但是如果有几个角色，就会变得相当复杂。以安全和可维护的方式处理这种访问控制的一个有用的库是<a href="https://github.com/casbin/casbin-rs" target="_blank" rel="noopener noreferrer"> casbin </a>，它也有一个维护良好的Rust crate。</p>
<p>一旦用户通过了角色检查，我们就在修饰的处理程序中传递用户的ID。这很有用，因为用户的身份将与许多个性化端点相关，例如获取用户配置文件或个人数据。</p>
<p>这就完成了<code>with_auth</code>过滤器，我们只需要在<code>main</code>中为我们的处理程序使用它。</p>
<pre>async fn main() {
    ...
    let user_route = warp::path!("user")
        .and(with_auth(Role::User))
        .and_then(user_handler);
    let admin_route = warp::path!("admin")
        .and(with_auth(Role::Admin))
        .and_then(admin_handler);
    ...
}

pub async fn user_handler(uid: String) -&gt; WebResult&lt;impl Reply&gt; {
    Ok(format!("Hello User {}", uid))
}

pub async fn admin_handler(uid: String) -&gt; WebResult&lt;impl Reply&gt; {
    Ok(format!("Hello Admin {}", uid))
}
</pre>
<p>那很容易！只需用过滤器修饰现有的处理程序，并将传入的用户ID放入处理程序签名中。我们还打印了这个用户ID，以便以后测试。</p>
<h2 id="errorhandling">错误处理</h2>
<p>就安全性而言，良好的错误处理至关重要。您不希望有一个向外部泄露太多信息的无所不包的处理程序。错误应该对调用者有所帮助，而不会泄露系统内部工作的任何信息。</p>
<p>在<code>error.rs</code>模块中，我们首先定义一个自定义的<code>Error</code>类型，一个<code>ErrorResponse</code>类型，并实现warp的<code>Reject</code>特征，这样这些错误就可以用于从处理程序返回。</p>
<pre>#[derive(Error, Debug)]
pub enum Error {
    #[error("wrong credentials")]
    WrongCredentialsError,
    #[error("jwt token not valid")]
    JWTTokenError,
    #[error("jwt token creation error")]
    JWTTokenCreationError,
    #[error("no auth header")]
    NoAuthHeaderError,
    #[error("invalid auth header")]
    InvalidAuthHeaderError,
    #[error("no permission")]
    NoPermissionError,
}

#[derive(Serialize, Debug)]
struct ErrorResponse {
    message: String,
    status: String,
}

impl warp::reject::Reject for Error {}
</pre>
<p>最后，我们添加了最初在<code>main</code>中使用的<code>handle_rejection</code>函数。</p>
<pre>pub async fn handle_rejection(err: Rejection) -&gt; std::result::Result&lt;impl Reply, Infallible&gt; {
    let (code, message) = if err.is_not_found() {
        (StatusCode::NOT_FOUND, "Not Found".to_string())
    } else if let Some(e) = err.find::&lt;Error&gt;() {
        match e {
            Error::WrongCredentialsError =&gt; (StatusCode::FORBIDDEN, e.to_string()),
            Error::NoPermissionError =&gt; (StatusCode::UNAUTHORIZED, e.to_string()),
            Error::JWTTokenError =&gt; (StatusCode::UNAUTHORIZED, e.to_string()),
            Error::JWTTokenCreationError =&gt; (
                StatusCode::INTERNAL_SERVER_ERROR,
                "Internal Server Error".to_string(),
            ),
            _ =&gt; (StatusCode::BAD_REQUEST, e.to_string()),
        }
    } else if err.find::&lt;warp::reject::MethodNotAllowed&gt;().is_some() {
        (
            StatusCode::METHOD_NOT_ALLOWED,
            "Method Not Allowed".to_string(),
        )
    } else {
        eprintln!("unhandled error: {:?}", err);
        (
            StatusCode::INTERNAL_SERVER_ERROR,
            "Internal Server Error".to_string(),
        )
    };

    let json = warp::reply::json(&amp;ErrorResponse {
        status: code.to_string(),
        message,
    });

    Ok(warp::reply::with_status(json, code))
}
</pre>
<p>大部分都是样板文件，用于处理warp中的拒绝，并在最后将它们转换成JSON响应。</p>
<p>有趣的部分是当我们处理我们的自定义类型时。在这种情况下，我们映射可能发生在状态代码上的错误。由于我们将错误的<code>Display</code>实现定义为只包含一个有用的错误消息，我们可以简单地将错误字符串化。</p>
<p>如果您将内部上下文添加到您的错误中，您应该非常小心，并且总是定义新的、轻量级的和有限的错误，以便向外部公开与安全相关的错误。您绝不会想要泄露任何关于内部工作的信息，比如堆栈跟踪。</p>
<p>在真实的系统中，定义一个额外的<code>SecurityError</code>类型也是有意义的，它被精心设计为不包含任何有意义的信息，并且完美地映射到每一个可能的与auth相关的情况。</p>
<h2 id="testing">测试</h2>
<p>既然身份验证和授权机制都实现了，最后一步就是看它是否工作。</p>
<p>我们可以使用<code>cargo run</code>启动服务器，这将在端口8000上本地启动一个web服务器。</p>
<p>然后，我们可以作为<code>User</code>登录并尝试访问两个端点:</p>
<pre>curl http://localhost:8000/login -d '{"email": "<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="84f1f7e1f6c4f1f7e1f6e8e5eae0aae7ebe9">[email protected]</a>", "pw": "1234"}' -H 'Content-Type: application/json'

{"token":"eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzUxMiJ9.eyJzdWIiOiIxIiwicm9sZSI6IlVzZXIiLCJleHAiOjE2MDMxMzQwODl9.dWnt5vfcGdwypEQUr3bLMrZYfdyxj3v6-io6VREWHXebMUCKBddf9xGcz4vHrCXruzx42zrS3Kygiqw3xV8W-A"}

curl http://localhost:8000/user -H 'Authorization: Bearer eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzUxMiJ9.eyJzdWIiOiIxIiwicm9sZSI6IlVzZXIiLCJleHAiOjE2MDMxMzQwODl9.dWnt5vfcGdwypEQUr3bLMrZYfdyxj3v6-io6VREWHXebMUCKBddf9xGcz4vHrCXruzx42zrS3Kygiqw3xV8W-A' -H 'Content-Type: application/json'

Hello User 1

curl http://localhost:8000/admin -H 'Authorization: Bearer eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzUxMiJ9.eyJzdWIiOiIxIiwicm9sZSI6IlVzZXIiLCJleHAiOjE2MDMxMzQwODl9.dWnt5vfcGdwypEQUr3bLMrZYfdyxj3v6-io6VREWHXebMUCKBddf9xGcz4vHrCXruzx42zrS3Kygiqw3xV8W-A' -H 'Content-Type: application/json'

{"message":"no permission","status":"401 Unauthorized"}
</pre>
<p>到目前为止，一切顺利。登录成功并返回了有效的JWT。我们使用这个JWT向<code>/user</code>和<code>/admin</code>发出认证请求。第一个如预期的那样工作了，第二个返回了一个错误。</p>
<p>接下来让我们试试管理员:</p>
<pre>curl http://localhost:8000/login -d '{"email": "<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="85e4e1e8ecebc5e4e1e8ecebe4f1fcabe6eae8">[email protected]</a>", "pw": "4321"}' -H 'Content-Type: application/json'

{"token":"eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzUxMiJ9.eyJzdWIiOiIyIiwicm9sZSI6IkFkbWluIiwiZXhwIjoxNjAzMTM0MjA1fQ.uYglVKRvb3h0bDC0Uz8FwGTu4v__Rl3toVI9fMI4_IT8keKde_SZRFQ4ii_PKzI4wjmDsZlnpULe6Tg0vWfEnw"}

curl http://localhost:8000/admin -H 'Authorization: Bearer eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzUxMiJ9.eyJzdWIiOiIyIiwicm9sZSI6IkFkbWluIiwiZXhwIjoxNjAzMTM0MjA1fQ.uYglVKRvb3h0bDC0Uz8FwGTu4v__Rl3toVI9fMI4_IT8keKde_SZRFQ4ii_PKzI4wjmDsZlnpULe6Tg0vWfEnw' -H 'Content-Type: application/json'

Hello Admin 2

curl http://localhost:8000/user -H 'Authorization: Bearer eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzUxMiJ9.eyJzdWIiOiIyIiwicm9sZSI6IkFkbWluIiwiZXhwIjoxNjAzMTM0MjA1fQ.uYglVKRvb3h0bDC0Uz8FwGTu4v__Rl3toVI9fMI4_IT8keKde_SZRFQ4ii_PKzI4wjmDsZlnpULe6Tg0vWfEnw' -H 'Content-Type: application/json'

Hello User 2
</pre>
<p>太好了！管理员可以访问两个端点，并且我们记录了正确的用户ID。如果这是一个真实的系统，我们将为验证、成功和错误情况编写一套详尽的测试。</p>
<p>模糊与身份验证相关的端点也是增加实现健壮性的好方法。没有什么比发送数十亿个随机值到某个东西中更能确保没有奇怪的边缘情况了！</p>
<p>你可以在<a href="https://github.com/zupzup/rust-jwt-example" target="_blank" rel="noopener noreferrer"> GitHub </a>上找到完整的示例代码。</p>
<h2 id="conclusion">结论</h2>
<p>在本教程中，我们使用JSON Web令牌实现了一个基本的身份验证和授权模型。</p>
<p>在Rust生态系统中，板条箱是一个成熟且广泛使用的选项。虽然我们在这个例子中使用了warp，但是这里使用的思想和技术可以很好地移植到任何其他Rust web框架中。</p>
<p>jwt是处理授权和安全有效地分发信息的强大工具，Rust社区再次证明了它的能力——这是它在web服务领域日益成熟的一个很好的标志。</p><div class="code-block code-block-29">
<div class="blog-plug inline-plug rust-plug"><h2><a href="https://lp.logrocket.com/blg/rust-signup" target="_blank">log rocket</a>:Rust应用的web前端的全面可见性</h2><p>调试Rust应用程序可能很困难，尤其是当用户遇到难以重现的问题时。如果您对监控和跟踪Rust应用程序的性能、自动显示错误、跟踪缓慢的网络请求和加载时间感兴趣，</p><a href="https://lp.logrocket.com/blg/rust-signup" target="_blank">try LogRocket</a><p>. </p><a class="signup" href="https://lp.logrocket.com/blg/rust-signup" target="_blank" rel="noopener noreferrer"><img class="alignnone size-full wp-image-46 jetpack-lazy-image" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/><noscript><img data-lazy-fallback="1" class="alignnone size-full wp-image-46" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/></noscript></a><p>LogRocket 就像是网络和移动应用程序的DVR，记录你的Rust应用程序上发生的一切。您可以汇总并报告问题发生时应用程序的状态，而不是猜测问题发生的原因。LogRocket还可以监控应用的性能，报告客户端CPU负载、客户端内存使用等指标。</p><p>现代化调试Rust应用的方式— <a class="signup" href="https://lp.logrocket.com/blg/rust-signup" target="_blank" rel="noopener noreferrer">开始免费监控</a>。</p></div>


</div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
<html>
<head>
<title>Creating CRUD Firebase documents in Angular - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>在Angular - LogRocket博客中创建CRUD Firebase文档</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/creating-a-crud-firebase-documents-in-angular/#0001-01-01">https://blog.logrocket.com/creating-a-crud-firebase-documents-in-angular/#0001-01-01</a></blockquote><div><article class="article-post">
<p>Firebase是Google开发的一个开发平台，安装起来既快捷又简单。在本教程中，我们将设置一个集成Firebase/Firestore和Angular的基本应用程序。我们将使用一个名为AngularFire的包——Firebase的官方角度库——以及Firebase SDK本身。</p>
<p>使用云服务变得越来越流行，因为它节省了时间，而不必创建自己的安全性、维护等。有了谷歌的Firebase，我们将建立一个免费的Firestore作为我们的数据库。</p>
<p>Firebase也提供了一个实时数据库，但是它把所有东西都存储在一个大的JSON树中。</p>
<p>这使得数据库更简单，但通过我们将使用的云Firestore，有了灵活的文档，使其对于更大的数据更具可伸缩性。如果你不熟悉数据库，Firestore也更快，总体上更直观。</p>
<h2>设置Firebase控制台</h2>
<p>首先，您需要在Firebase控制台上设置您的项目。先去<a href="https://console.firebase.google.com/" target="_blank" rel="noopener noreferrer">这里</a>找控制台。</p>
<p>创建一个项目，给它起一个名字，然后完成所有步骤。完成后，您将看到项目概述。</p>
<p>不，我们需要添加一个应用程序。您应该在项目概述页面上。在这里你会看到“从添加Firebase到你的应用开始”。</p>
<p>通过点击“&gt;”按钮(这是为了添加一个web应用程序)来完成此操作。你可以在这里设置主机，但我们不会在本教程中涉及。</p>
<p>继续注册应用程序。在下一页，您将看到设置Firebase SDK的脚本。这些是有用的，但是我们将在后面看到如果你在这一页上错过了它们，如何得到我们需要的一切。继续，继续安慰。</p>
<h2>初始化firestorm并创建第一个文档</h2>
<p>在Firebase控制台的左侧窗格中，您可以在“开发”下找到“数据库”选项卡。点击它，你将被带到一个页面，在那里你可以点击“创建数据库”。将出现一个模式，您可以在其中选择生产模式或测试模式；我们想要测试模式。这是不安全的，但对测试来说很好。</p>
<p>如果继续，您将被要求选择一个位置。去挑选一个合适的。按下“完成”后，将需要几分钟来设置Firestore。</p>
<p>当完成时，你将在你的Firestore。继续并选择“开始收集”。</p>
<p><img data-attachment-id="23368" data-permalink="https://blog.logrocket.com/creating-a-crud-firebase-documents-in-angular/next-firebase-project/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/08/next-firebase-project.png" data-orig-size="700,400" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="next-firebase-project" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/08/next-firebase-project-300x171.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/08/next-firebase-project.png" decoding="async" class="aligncenter wp-image-23368 jetpack-lazy-image" src="../Images/54ac17803c2c8ed52ad6db1dcceb0663.png" alt="A screengrab of the console for setting up your Firebase project." data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2020/08/next-firebase-project.png 700w, https://blog.logrocket.com/wp-content/uploads/2020/08/next-firebase-project-300x171.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2020/08/next-firebase-project.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/08/next-firebase-project.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="23368" data-permalink="https://blog.logrocket.com/creating-a-crud-firebase-documents-in-angular/next-firebase-project/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/08/next-firebase-project.png" data-orig-size="700,400" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="next-firebase-project" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/08/next-firebase-project-300x171.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/08/next-firebase-project.png" decoding="async" loading="lazy" class="aligncenter wp-image-23368" src="../Images/54ac17803c2c8ed52ad6db1dcceb0663.png" alt="A screengrab of the console for setting up your Firebase project." srcset="https://blog.logrocket.com/wp-content/uploads/2020/08/next-firebase-project.png 700w, https://blog.logrocket.com/wp-content/uploads/2020/08/next-firebase-project-300x171.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/08/next-firebase-project.png"/></noscript>
<p>它将要求您创建一个收藏ID；对于我们的例子，我们就把它命名为“testCollection”。点击下一步，它会带你到创建你的第一个文件的形式。</p>
<p>我们会将文档ID留空，Firestore会自动为您生成。在字段下，只需输入“字段”。然后，您将看到默认类型为“string”。现在没有理由改变这一点，所以就让它保持原样吧。在“值”下，键入“值1”。点击保存，你会看到你已经创建了你的第一份文件！</p>
<p>对于我们后面的例子，让我们创建第二个文档。在中间一栏，您会看到“+添加文档”继续点击它，您将返回到文档创建表单。</p>
<p>在这里，只需在字段下键入“字段”,在值下键入“值2”。单击保存。现在我们有两份文件。</p>
<h2>开始一个新的角度项目</h2>
<p>让我们用Angular CLI(命令行界面)制作我们的前端项目。打开终端窗口并全局安装Angular CLI:</p>
<pre>npm install -g @angular/cli</pre>
<p>安装后，您可以运行<code>ng</code>命令。</p>
<p>在终端中，键入以下内容:</p>
<pre>ng new your-app-name</pre>
<p>您可以随意命名您的项目。</p><div class="code-block code-block-54">
<hr/>
<h3>更多来自LogRocket的精彩文章:</h3>

<hr/></div>
<p>一旦开始，Angular CLI将引导您完成几个配置选项。</p>
<p>您可以添加路由，然后选择希望Angular为您的应用程序生成的样式表格式。</p>
<p>在这之后，它将通过其余部分，并创建您的角度应用程序。</p>
<p>完成后，继续将终端目录更改为我们刚刚创建的目录:</p>
<pre>cd your-app-name</pre>
<p>在Angular应用的目录中，你可以在本地运行<code>ng serve</code> build并服务你的应用。</p>
<h2>在Angular应用程序中设置Firebase</h2>
<p>让我们通过在Angular项目目录下的终端中运行以下命令来获得Firebase SDK:</p>
<pre>npm i --save firebase</pre>
<p>现在，Firebase已添加到您的项目中。</p>
<p>转到Firebase控制台。在左侧菜单中，您会看到“项目概述”，旁边有一个齿轮图标。单击图标，然后在弹出窗口中单击项目设置。在这里，转到常规选项卡，并滚动到底部。</p>
<p>在“Firebase SDK snippet”下，单击CDN旁边的单选按钮(默认为自动)。在这里，您可以找到将您的应用程序连接到Firebase所需的一切。F</p>
<p>找到<code>firebaseConfig</code>变量——我们需要将该信息复制到Angular应用程序中。看起来是这样的(除了所有内容都会正确填写):</p>
<pre>var firebaseConfig = {
  apiKey: "************************************",
  authDomain: "*************.firebaseapp.com",
  databaseURL: "https://************.firebaseio.com",
  projectId: "***************",
  storageBucket: "****************.appspot.com",
  messagingSenderId: "*************",
  appId: "********************************",
  measurementId: "****************",
};</pre>
<p>在Angular应用程序中，导航到生成的文件<code>app.module.ts</code>(如果您通过CLI创建了Angular项目:<code>src &gt; app &gt; app.module.ts</code>)。在这个文件中，你可以粘贴整个<code>firebaseConfig</code>变量(就在imports下面就可以了)。</p>
<p>下一步是下载npm包<code>angular/fire</code>。有了这个包，你将能够轻松地与Firebase交互。</p>
<p>您可以使用以下代码行在项目中安装该包:</p>
<pre>npm i angular/fire</pre>
<p>安装后，我们可以将它添加到<code>app.module.ts</code>文件中:</p>
<pre>import { AngularFireModule } from @angular/fire';</pre>
<p>现在，在导入数组中，通过添加以下代码行来初始化应用程序中的Firebase:</p>
<pre>AngularFireModule.initializeApp(firebaseConfig)</pre>
<p>这个导入一般是针对Firebase的，但是如果我们想要添加某些服务，您将需要单独添加这些服务。</p>
<p>对于Firestore，在文件顶部添加以下内容:</p>
<pre>import { AngularFirestoreModule } from '@angular/fire/firestore';</pre>
<p>然后，在底部附近的导入数组中:</p>
<pre>AngularFirestoreModule</pre>
<h2>在应用程序中实现</h2>
<p>此时，在我们的Angular应用程序中创建一两个组件可能是有意义的。您可以在项目中使用CLI在应用程序中创建新组件。</p>
<p>让我们通过在终端中键入命令来创建一个home组件:</p>
<pre>ng g c home</pre>
<p>“g . c”代表“生成组件”。这将生成一个主文件夹，下面有四个文件:一个HTML文件、一个SCSS文件(或者您正在使用的任何样式)、一个类型脚本文件和一个. spec文件。</p>
<p>如果您想跳过添加。规格文件，将此标志添加到您的生成命令中:</p>
<pre>ng g c home --skipTests=true</pre>
<p>我们将在我们的home组件中执行我们的逻辑，但是不要忘记将它添加到我们的<code>app.component.html</code>文件中。您总是可以将home组件添加到路由器中，但是为了简单起见，让我们只将它添加到HTML中。</p>
<p>如果您像我一样设置了一个home组件，那么选择器将是“app-home ”,所以您可以像这样将它添加到<code>app.component.html</code>文件中的某个位置</p>
<pre>&lt;app-home&gt;&lt;/app-home&gt;</pre>
<p>之后，让我们开始在home组件中进行操作。</p>
<p>之前，我们在Firestore中创建了一个名为<code>testCollection</code>的集合；其中有两个文档或对象。让我们先来看看“阅读”这两篇来自Firestore的文档。</p>
<h2>阅读</h2>
<p>在<code>home.component.ts</code>文件中，我们可以通过我们的Angular/fire包导入Firestore:</p>
<pre>import { AngularFirestore } from "@angular/fire/firestore";</pre>
<p>导入后，我们可以像这样在构造函数中初始化它:</p>
<pre>constructor(private firestore: AngularFirestore) {}</pre>
<p>那就是给我们进口的<code>AngularFirestore</code>起“Firestore”的别名——给它起你喜欢的任何名字。</p>
<p><code>ngOnInit</code>函数是一个从Firestore直接读取gitgo的完美地方。</p>
<p>看一下这段代码:</p>
<pre>this.firestore
  .collection("testCollection")
  .get()
  .subscribe((ss) =&gt; {
    ss.docs.forEach((doc) =&gt; {
      this.myArray.push(doc.data());
    });
  });</pre>
<p>让我们一步一步来:正如您可能知道的，<code>this.firestore</code>指的是我们在构造函数中为<code>AngularFirestore</code>创建的别名。</p>
<p><code>.collection('testCollection')</code>是我们如何引用我们之前创建的集合，而<code>.get()</code>只是简单地获取整个集合(我们稍后将讨论查询集合中的单个文档)。</p>
<p>当我们<code>.subscribe</code>到firestore时，它本质上是异步等待API返回数据。从技术上来说，subscribe来自RxJS，是一个可观察对象，当有变化时会更新。</p>
<p>现在，Firestore总是返回数据的快照，这就是为什么我们给它起了别名<code>ss</code>。在我们数据库的快照下面是docs，这是我们想要的数据，我们可以使用<code>.forEach</code>数组方法来循环遍历docs数组。</p>
<p>在上面的例子中，我们从Firebase Firestore获得了<code>doc.data()</code>。这将是整个文档，在我们的例子中是一个具有一个属性的对象。因此，当我们将它推入数组时，我们需要将数组初始化为以下代码:</p>
<pre>myArray: any[] = []</pre>
<p>这允许我们在HTML中看到它，删除那里的内容，并用以下内容替换它:</p>
<pre>&lt;ul&gt;
        &lt;li *ngFor='let doc of myArray'&gt;
            {{doc.field}}
        &lt;/li&gt;
    &lt;/ul</pre>
<p><img data-attachment-id="23369" data-permalink="https://blog.logrocket.com/creating-a-crud-firebase-documents-in-angular/complete-list/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/08/complete-list.png" data-orig-size="542,268" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="complete-list" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/08/complete-list-300x148.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/08/complete-list.png" decoding="async" class="aligncenter wp-image-23369 jetpack-lazy-image" src="../Images/ee83c3681f2ed90ecf46a4b36ac5bcb2.png" alt="A complete list in HTML with two values." data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2020/08/complete-list.png 542w, https://blog.logrocket.com/wp-content/uploads/2020/08/complete-list-300x148.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2020/08/complete-list.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/08/complete-list.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="23369" data-permalink="https://blog.logrocket.com/creating-a-crud-firebase-documents-in-angular/complete-list/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/08/complete-list.png" data-orig-size="542,268" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="complete-list" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/08/complete-list-300x148.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/08/complete-list.png" decoding="async" loading="lazy" class="aligncenter wp-image-23369" src="../Images/ee83c3681f2ed90ecf46a4b36ac5bcb2.png" alt="A complete list in HTML with two values." srcset="https://blog.logrocket.com/wp-content/uploads/2020/08/complete-list.png 542w, https://blog.logrocket.com/wp-content/uploads/2020/08/complete-list-300x148.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/08/complete-list.png"/></noscript>
<p>太好了！我们已经成功地从Firestore中读取了数据。</p>
<h2>写</h2>
<p>首先，我们把<code>ReactFormsModule</code>加到<code>app.module.ts</code>上，像这样:</p>
<pre>import { ReactiveFormsModule } from "@Angular/forms";</pre>
<p>另外，将<code>ReactiveFormsModule</code>添加到底部附近的导入数组中。</p>
<p>在我们的<code>home.component.html</code>文件中，让我们添加一个表单来捕获和发送新数据。写下这样的话:</p>
<pre>&lt;form [formGroup]="this.form"&gt;
  &lt;input
    placeholder="New Value"
    formControlName="newValue"
    type="text"
    class="input-field col s12"
  /&gt;
  &lt;button (click)="onSubmit()"&gt;
    Submit
  &lt;/button&gt;
&lt;/form&gt;</pre>
<p>现在，如果您使用了上面的HTML，将下面的导入添加到我们的<code>home.component.ts</code>文件中:</p>
<pre>import { FormControl, FormGroup } from "@Angular/forms";</pre>
<p>然后，在我们的类中，添加:</p>
<pre>form = new FormGroup({
        newValue: new FormControl('')
    })`</pre>
<p>这将接受来自HTML，表单和我们的输入，与<code>newValue</code>的<code>formControlName</code>。</p>
<p>因此，我们将从HTML中获取用户输入的字符串，并将其作为Firestore中新文档的值发送。我们可以通过使用以下函数来实现:</p>
<pre>onSubmit() {
        this.firestore.collection('testCollection').add({
            field: this.form.value.newValue
        })
        .then(res =&gt; {
            console.log(res);
            this.form.reset();
        })
        .catch(e =&gt; {
            console.log(e);
        })
    }</pre>
<p>与我们在Firestore上阅读的方式相同，我们这次将使用相同的参考资料来收集我们的产品:</p>
<pre>this.firestore.collection('testCollection')</pre>
<p>这一次，我们将添加一个带有<code>.add</code>的文档。我们希望将对象与我们收到的文本一起添加:</p>
<pre>.add({field: this.form.valule.newValue})</pre>
<p>这可能看起来很奇怪，但这是因为我们正在获取表单的值。在那里，我们得到我们命名为<code>newValue</code>的属性。所以才是<code>value.newValue</code>。</p>
<p>函数的其余部分只是一个<code>.then</code>和<code>.catch</code>来处理Firestore的响应。</p>
<p>当写入Firestore时，响应(成功时)将是一个大而奇怪的对象。</p>
<p>因为我们没有读取任何内容，所以这些处理程序的唯一用途是在我们写完Firestore后想立即做点什么(就像我们在调用<code>.reset()</code>清除表单时所做的那样)。</p>
<p>如果您继续运行这个应用程序(<code>ng serve</code>)，您会注意到在输入一个新值并提交给Firebase之后，它不会出现在我们的列表中。如果写入成功，您可以刷新页面，它应该会显示出来。这是为什么呢？</p>
<p>这是因为在我们写信给我们的Firestore后，我们没有阅读新的变化。按照我们当前的<code>ngOnInit</code>函数的设置方式，我们没有观察到变化。</p>
<p>为了查看新数据，我们需要改变读取数据的方式:</p>
<pre>ngOnInit() {
        this.docs = [];
        const collectionRef = this.db.collection('testCollection');
        const collectionInstance = collectionRef.valueChanges();
        collectionInstance.subscribe(ss =&gt; this.myArray = ss);
    }</pre>
<p>现在我们已经订阅了。您会看到，在向数据库添加新文档后，它也会被添加到我们应用程序的列表中。主要区别是我们现在订阅了<code>.valueChanges()</code>。</p>
<h2>询问</h2>
<p>让我们添加另一个表单，我们可以使用它来根据文档的值查询Firestore:</p>
<pre>&lt;form [formGroup]="this.secondForm"&gt;
  &lt;input
    placeholder="value1"
    formControlName="valueToGet"
    type="text"
    class="input-field col s12"
  /&gt;
  &lt;button (click)="onQuery()"&gt;
    Query
  &lt;/button&gt;
&lt;/form&gt;</pre>
<p>为简单起见，它与第一种形式完全一样，只是名称和功能不同。请随意命名，但要确保使用新名称，而不是我们在之前的表单中使用的名称。</p>
<p>在typescript文件中，确保在类的顶部初始化窗体:</p>
<pre>secondForm = new FormGroup({ valueToGet: new FormControl('') })</pre>
<p>同样，在我们初始化所有东西的地方，添加<code>single: any;</code>作为变量来放置我们查询的文档，添加<code>message: string;</code>作为错误消息的变量。</p>
<p>至此，让我们开始构建我们的<code>onQuery</code>函数。</p>
<pre>onQuery() {
    if (!this.secondForm.value.valueToGet) {
      this.message = 'Cannot be empty';
      this.single = null;
    } else {
      this.firestore.collection('testCollection', ref =&gt; ref.where("field", "==", this.secondForm.value.valueToGet)).get()
        .subscribe(ss =&gt; {
          if (ss.docs.length === 0) {
            this.message = 'Document not found! Try again!';
            this.single = null;
          } else {
            ss.docs.forEach(doc =&gt; {
              this.message = '';
              this.single = doc.data();
            })
          }
        })
    }
  }</pre>
<p>首先，我们看看用户是否输入了任何东西。输入可以在<code>this.secondForm.value.valueToGet</code>中找到。</p>
<p>因此，如果它是空的，我们希望返回一条消息，而不是发送一个空字符串来查询Firebase。在这个“if”检查中，我还要确保我们的“single”变量是空的，因为我们以前可能已经成功地查询过了，但是现在我们只想发送表单不能为空的消息。</p>
<p>如果它不是空的，我们继续查询我们的Firestore。您会注意到“collection”参数中的一些新内容——在Angular中，我们实际上是在该参数中进行查询的。<code>ref</code>是对集合的引用，<code>.where</code>是在Firestore集合中查询文档的最常见方式。</p>
<p>在<code>.where</code>方法中，我们首先告诉Firebase在每个文档中查询什么字段。我们所有的字段都是简单的“字段”，所以这很容易。</p>
<p>然后，我们用一个比较器，<code>==</code>，就是问字段<code>isEqual</code>是否。您也可以使用其他比较器，如<code>&lt;</code>、<code>&gt;=</code>等。</p>
<p>最后，第三个参数告诉Firebase将该字段与什么进行比较——在我们的例子中，我们希望将来自用户的输入值放在这里，并查看它是否在Firestore的任何地方显示为一个值。</p>
<p>关于Firestore限制的快速说明:使用<code>.where</code>方法进行查询是有限制的。</p>
<p>你可以检查有没有差一个字母的东西，或者是小写的，而Firestore把它保存为大写，它不会返回它。你可以在前端做些事情来帮忙，比如让每个用户输入的内容都是小写的，以匹配Firestore，但这只能做到这一步。</p>
<p>当然，你可以把整个Firestore拉到前端(就像我们正在做的那样)。虽然查询会更好，但如果你的Firestore很大，可能就不理想了。进行全文搜索的建议方式是使用<a href="https://firebase.google.com/docs/firestore/solutions/search" target="_blank" rel="noopener noreferrer"> Algolia </a>。</p>
<p>我们将<code>.get()</code>因为我们正在读取值，我们将<code>.subscribe</code>像我们读取整个集合时一样。</p>
<p>然而，在我们从Firestore获得快照后，我们希望进行“if”检查，以查看是否有任何内容被返回。即使Firestore中没有匹配项，您也可以查看快照，看它是否不会为空。</p>
<p>但是，如果我们的查询没有匹配项，快照上的<code>docs</code>属性将为空(确切地说是一个空数组)。这就是我们如何判断我们的查询是否匹配任何东西。</p>
<p>同样，我们将发回消息并将变量<code>single</code>设置为空。如果我们确实找到了匹配，那么我们想做相反的事情，将消息设置为空，并将变量<code>single</code>设置为返回的数据。</p>
<p>现在我们有了数据，让我们回到<code>home.component.html</code>。让我们添加一些HTML来处理我们的“消息”和“单个”变量:</p>
<pre>&lt;p style="color: red;"&gt;{{message || null}}&lt;/p&gt;

&lt;div *ngIf="single"&gt;
  &lt;h1&gt;{{single.field}}&lt;/h1&gt;
  &lt;button style="background-color: lightblue"&gt;Edit&lt;/button&gt;
  &lt;button style="background-color: red"&gt;Delete&lt;/button&gt;
&lt;/div&gt;</pre>
<p>这里很简单。我们使用<code>*ngIf</code>指令只显示找到的匹配文档。您应该还记得，如果没有找到“single ”,我们将它设置为null，这样整个<code>*ngIf</code> <code>div</code>都将被隐藏。“消息”也是如此，如果它被设置为空字符串。</p>
<p>您还会注意到我们为下一部分添加了按钮，因为我们仍然需要能够编辑和删除！</p>
<h2>更新</h2>
<p>从现在开始，获取我们查询的文档的<code>id</code>将会对我们有很大的帮助。</p>
<p>我们知道我们只会编辑或删除那个被查询的文档，所以让我们获取它的<code>id</code>。正如你可能注意到的，当我们从我们的应用程序创建文档时，我们没有给它们一个<code>id</code>。</p>
<p>另外，当我们一开始在Firestore中创建文档时，我们让Firestore自动生成<code>id</code>s；同样的情况也发生在我们通过应用程序创建的应用程序上。那么，我们如何得到<code>id</code> s呢？</p>
<p>在我们的<code>onQuery</code>函数中，让我们像这样设置对数据库查询的引用:</p>
<pre>const docRef = this.firestore.collection('testCollection', ref =&gt; ref.where("field", "==", this.secondForm.value.valueToGet));</pre>
<p>断开<code>.get()</code>和其后的所有内容，然后，在另一行，使用我们的引用，像这样:</p>
<pre>docRef.get().subscribe(ss =&gt; ...)</pre>
<p>…等等。本质上是一回事。</p>
<p>现在，在subscribe方法下面，让我们添加另一行来获取文档<code>id</code>:</p>
<pre>docRef.snapshotChanges().forEach((changes) =&gt; {
  changes.map((a) =&gt; {
    this.id = a.payload.doc.id;
  });
});</pre>
<p>显然，我们需要在顶部初始化<code>this.id</code>:<code>id: string = ''</code>。但是，现在我们已经有了在将要创建的编辑和删除函数中使用的id。</p>
<p>回到我们的<code>home.component.html</code>文件，将我们之前创建的编辑按钮更改为以下内容:</p>
<pre>&lt;button style='background-color: lightblue' (click)='openEdit()'&gt;Edit&lt;/button&gt;</pre>
<p>使用这个<code>openEdit()</code>函数，在我们的TypeScript文件中，我们可以初始化一个编辑变量:</p>
<pre>edit: boolean = false</pre>
<p>并创建<code>openEdit</code>函数来切换它:</p>
<pre>openEdit() { this.edit = !this.edit};</pre>
<p>每次调用该函数，都会使编辑变量从false变为true，或者从true变为false。</p>
<p>现在，在我们的HTML文件中，添加下面的表单。当edit为真时，它将出现:</p>
<pre>&lt;form *ngIf="edit" [formGroup]="this.editForm"&gt;
  &lt;input
    placeholder="{{single.field}}"
    formControlName="replaceValue"
    type="text"
    class="input-field col s12"
  /&gt;
  &lt;button (click)="onRename()"&gt;
    Rename
  &lt;/button&gt;
&lt;/form&gt;
&lt;p style="color: red;"&gt;{{message2 || null}}&lt;/p&gt;</pre>
<p>又是另一种形式。这里重要的一点是我们不会覆盖整个文档——我们会保留<code>id</code>,但是这个字段会变成我们在这里输入的内容——这是我们的目标。</p>
<p>在<code>home.component.ts</code>中，初始化<code>message2</code>变量来处理一个空输入，并初始化表单，就像我们对其他表单所做的那样。然后创建一个<code>onRename</code>函数。</p>
<pre>onRename() {
        if (!this.editForm.value.replaceValue) {
            this.message2 = "Cannot Be Empty!";
        } else {
            this.firestore.collection('testCollection').doc(this.id).update({ field: this.editForm.value.replaceValue });
            this.edit = false;
            this.message2 = '';
            this.single = null;
        }
    }</pre>
<p>这里有一些新的东西需要注意。</p>
<p>首先，我们使用<code>.doc</code>方法，并放入我们从前面的步骤中得到的<code>id</code>。它基于<code>id</code>而不是查询来获取文档。</p>
<p>接下来，我们使用<code>.update</code>方法。这只会覆盖我们指定的属性，而不是覆盖整个文档的<code>.set</code>。换句话说，如果我们在文档中有三个字段，我们可以用如下的更新方法只覆盖其中一个。</p>
<p>我们再次重读了Firestore上的文档列表。然后，我们可以压缩单个查询、编辑框和之前存在的任何消息。</p>
<h2>删除</h2>
<p>我们要做的删除基本上与我们的更新相同，只是我们将使用delete方法。</p>
<p>首先，在我们的html中，让我们更改删除按钮:</p>
<pre>&lt;button style='background-color: red' (click)='delete()'&gt;Delete&lt;/button&gt;</pre>
<p>现在，要做的就是创建<code>delete</code>函数。</p>
<p>在允许用户删除对象之前，放入一个警告可能是明智的。将以下代码添加到TypeScript文件中:</p>
<pre>delete() {
        if (confirm('Delete?')) {
            this.db.collection('testCollection').doc(this.id).delete();
            this.edit = false;
            this.single = null;
        }
    }</pre>
<p><code>confirm('Delete')</code>会弹出一个在删除前必须确认的警告——它只是避免用户无意中删除一些东西。</p>
<p>之后，我们简单地通过存储的<code>id</code>获取文档，并对其调用delete方法。就这么简单。</p>
<h2>结论</h2>
<p>您现在已经成功创建了一个可以创建、阅读、更新和删除Firestore文档的Angular应用程序！如你所见，Firebase Firestore易于使用，随时可用。这可以很容易地升级到数千个复杂的文档。</p>
<p>既然你已经对Firestore的基础有了很好的了解，那就来看看<a href="https://firebase.google.com/docs/firestore/solutions" target="_blank" rel="noopener noreferrer">官方文档</a>中更高级的主题吧。</p><div class="code-block code-block-19">
<div class="blog-plug inline-plug angular-plug"><h2>像用户一样体验Angular应用程序</h2><p>调试Angular应用程序可能很困难，尤其是当用户遇到难以重现的问题时。如果您对监视和跟踪生产中所有用户的角度状态和动作感兴趣，</p><a href="https://lp.logrocket.com/blg/angular-signup">try LogRocket</a><p>. </p><a class="signup" href="https://lp.logrocket.com/blg/angular-signup" target="_blank" rel="noopener noreferrer"><img class="alignnone size-full wp-image-46 jetpack-lazy-image" src="../Images/2794ac39244976f37c4941d9a910be23.png" alt="LogRocket Dashboard Free Trial Banner" data-lazy-src="https://files.readme.io/610d6a7-687474703a2f2f692e696d6775722e636f6d2f696147547837412e706e67.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://files.readme.io/610d6a7-687474703a2f2f692e696d6775722e636f6d2f696147547837412e706e67.png"/><noscript><img data-lazy-fallback="1" class="alignnone size-full wp-image-46" src="../Images/2794ac39244976f37c4941d9a910be23.png" alt="LogRocket Dashboard Free Trial Banner" data-original-src="https://files.readme.io/610d6a7-687474703a2f2f692e696d6775722e636f6d2f696147547837412e706e67.png"/></noscript></a><a href="https://lp.logrocket.com/blg/angular-signup" target="_blank" rel="noopener noreferrer">https://logrocket.com/signup/</a><p>LogRocket 就像是网络和移动应用程序的DVR，记录你网站上发生的一切，包括网络请求、JavaScript错误等等。您可以汇总并报告问题发生时应用程序的状态，而不是猜测问题发生的原因。</p><p>LogRocket NgRx插件将角度状态和动作记录到LogRocket控制台，为您提供导致错误的环境，以及出现问题时应用程序的状态。</p><p>现代化调试Angular应用的方式- <a class="signup" href="https://lp.logrocket.com/blg/angular-signup" target="_blank" rel="noopener noreferrer">开始免费监控</a>。</p></div>
</div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
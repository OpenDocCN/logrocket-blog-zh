<html>
<head>
<title>TDD with React Test Renderer - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>带有React测试呈现器的TDD</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/tdd-with-react-test-renderer/#0001-01-01">https://blog.logrocket.com/tdd-with-react-test-renderer/#0001-01-01</a></blockquote><div><article class="article-post">
<p>众所周知，酶已经成为React组件测试的事实标准，但是还有其他好的选择。</p>
<p>例如:React测试渲染器。</p>
<p>我个人喜欢测试渲染器，因为它的工作方式:它将React组件渲染成易于使用和理解的纯JavaScript对象。</p>
<p>React测试渲染器的另一个优点是它由脸书的核心团队维护，并且总是最新的。</p>
<p>React测试渲染器有很棒的文档，我就不赘述了。相反，我想用一个测试驱动开发(TDD)方法的例子来说明一些最常见的用例。</p>
<h2>设置</h2>
<p>测试渲染器有一个非常简单的设置过程——只需安装lib，您就可以开始了:</p>
<pre>npm install --save-dev react-test-renderer</pre>
<p>通常，我们需要一个组件来开始编写测试，但是React Test Renderer使我们能够在组件实现之前编写测试。</p>
<blockquote><p><strong>注意:</strong>这样做的原因是，当你测试函数时，TDD的工作就像一种魅力，所以考虑到大多数React组件都是纯功能组件，TDD在这里应用得非常好，特别是与React测试渲染器一起。</p>
<p>有时，在复杂逻辑的情况下，从测试开始编写组件甚至更快，因为您需要更少的迭代和调试。</p></blockquote>
<p>让我们考虑一个简单组件的要求:</p>
<ul>
<li>它需要一个类<code>btn-group</code></li>
<li>它应该能够呈现它的孩子</li>
</ul>
<h2>测试<code>className</code></h2>
<p>首先，我们需要测试一个空组件的类(就像我们遵循TDD一样):</p>
<pre>import React from "react";
  // [ 1 ] import the React Test Renderer
  import { create } from "react-test-renderer";

  const BtnGroup = () =&gt; null;
  
  test("the className of the component includes btn-group", () =&gt; {
    // [ 2 ] boilerplate code
    const root = create(&lt;BtnGroup /&gt;).root;

    // [ 3 ] query for element
    const element = root.findByType("div");

    // [ 4 ] assert that className to include btn-group
    expect(element.props.className.includes("btn-group")).toBe(true);
  });</pre>
<p>测试有三个步骤:测试实例创建、元素查询和断言。</p>
<p>现在让我们跳过更深入的解释，专注于修复测试。起初，它会打破(如预期的那样):</p>
<pre>No instances found with node type: "undefined"</pre>
<p>这意味着我们需要添加某种类型的节点。在我们的例子中，类型应该是<code>&lt;div&gt;</code>:</p>
<pre>const BtnGroup = () =&gt; &lt;div /&gt;;</pre>
<p>一旦我们更改了代码，文件监视器再次运行测试，我们会收到一条更新的消息:</p>
<pre>expect(received).toEqual(expected) // deep equality

Expected: "btn-group"
Received: undefined</pre>
<p>我们已经断言。为了通过第一个测试，我们现在需要做的就是添加一个<code>className</code>道具:</p>
<pre>const BtnGroup = () =&gt; &lt;div className="btn-group" /&gt;;</pre>
<p>这一改变之后，我们将看到有益的绿色信息:</p>
<p><img data-attachment-id="9198" data-permalink="https://blog.logrocket.com/tdd-with-react-test-renderer/screenshot-test-nocdn/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2019/11/Screenshot-test-nocdn.png" data-orig-size="416,192" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Screenshot-test-nocdn" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2019/11/Screenshot-test-nocdn-300x138.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2019/11/Screenshot-test-nocdn.png" decoding="async" class="aligncenter wp-image-9198 jetpack-lazy-image" src="../Images/059ca05b125b47c08335a3f27cacc98a.png" alt="Screenshot of a green test" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2019/11/Screenshot-test-nocdn.png 416w, https://blog.logrocket.com/wp-content/uploads/2019/11/Screenshot-test-nocdn-300x138.png 300w" data-lazy-sizes="(max-width: 600px) 100vw, 600px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2019/11/Screenshot-test-nocdn.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/11/Screenshot-test-nocdn.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="9198" data-permalink="https://blog.logrocket.com/tdd-with-react-test-renderer/screenshot-test-nocdn/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2019/11/Screenshot-test-nocdn.png" data-orig-size="416,192" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Screenshot-test-nocdn" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2019/11/Screenshot-test-nocdn-300x138.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2019/11/Screenshot-test-nocdn.png" decoding="async" loading="lazy" class="aligncenter wp-image-9198" src="../Images/059ca05b125b47c08335a3f27cacc98a.png" alt="Screenshot of a green test" srcset="https://blog.logrocket.com/wp-content/uploads/2019/11/Screenshot-test-nocdn.png 416w, https://blog.logrocket.com/wp-content/uploads/2019/11/Screenshot-test-nocdn-300x138.png 300w" sizes="(max-width: 600px) 100vw, 600px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/11/Screenshot-test-nocdn.png"/></noscript>
<p>一旦测试通过，我们就可以放慢速度，一行一行地重新检查测试代码。下面是代码:</p>
<pre>import React from "react";
  // [ 1 ] import the React Test Renderer
  import { create } from "react-test-renderer";

  const BtnGroup = () =&gt; null;
  
  test("the className of the component includes btn-group", () =&gt; {
    // [ 2 ] boilerplate code
    const root = create(&lt;BtnGroup /&gt;).root;

    // [ 3 ] query for element
    const element = root.findByType("div");

    // [ 4 ] assert that className to include btn-group
    expect(element.props.className.includes("btn-group")).toBe(true);
  });</pre>
<p>[ 1 ]测试渲染器只有一种创建组件的方法，即<code>create</code>方法，所以只需导入并使用它。</p>
<p>[ 2 ]创建组件时，获取测试实例是React测试呈现器的标准样板代码。</p>
<p>[ 3 ]在测试渲染器中查询元素主要有两种方式:按类型和按属性。当周围没有其他容器时，我更喜欢按类型查询，就像当前的例子一样。稍后我们将讨论其他方法。</p>
<p>[ 4 ]这个断言是不言自明的；只要检查一下<code>className</code> prop值是否包含<code>btn-group</code>就可以了。</p>
<h2>测试儿童</h2>
<p>让我们继续向已有的<code>BtnGroup</code>组件添加功能，因为我们知道我们需要满足以下要求:</p>
<p>它应该能够呈现它的孩子。</p>
<p>测试<code>children</code>道具非常简单。我们只需要确保传递的值与呈现的结果相匹配:</p>
<pre>import React from "react";
import { create } from "react-test-renderer";

const BtnGroup = () =&gt; &lt;div className="btn-group" /&gt;;

test("renders BtnGroup component with children", () =&gt; {
  // [ 6 ] child text
  const text = "child";

  // boilerplate code, already mentioned in [ 2 - 3 ] above
  const instance = create(&lt;BtnGroup&gt;{text}&lt;/BtnGroup&gt;).root;

  // query for element
  const element = instance.findByType("div");

  // assert child to match text passed
  expect(element.props.children).toEqual(text);
  });</pre>
<p>[ 6 ]我们传递给组件的值和我们用来断言它的值应该是相同的。</p>
<p>由于我们使用的是TDD，您可能认为测试会在这里中断。然而，React支持将子组件传递给开箱即用的组件，因此我们的测试将是绿色的。</p>
<p>如果您想知道测试是否成功运行，您可以用console.log打印元素值。</p>
<p>输出如下所示:</p>
<p><img data-attachment-id="9369" data-permalink="https://blog.logrocket.com/tdd-with-react-test-renderer/console-log-nocdn/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2019/11/console-log-nocdn.png" data-orig-size="280,82" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="console-log-nocdn" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2019/11/console-log-nocdn.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2019/11/console-log-nocdn.png" decoding="async" class="aligncenter wp-image-9369 jetpack-lazy-image" src="../Images/243ea7760208fbd578bd42894b7fe072.png" alt="Console log" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2019/11/console-log-nocdn.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/11/console-log-nocdn.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="9369" data-permalink="https://blog.logrocket.com/tdd-with-react-test-renderer/console-log-nocdn/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2019/11/console-log-nocdn.png" data-orig-size="280,82" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="console-log-nocdn" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2019/11/console-log-nocdn.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2019/11/console-log-nocdn.png" decoding="async" loading="lazy" class="aligncenter wp-image-9369" src="../Images/243ea7760208fbd578bd42894b7fe072.png" alt="Console log" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/11/console-log-nocdn.png"/></noscript>
<h2>测试任何道具</h2>
<p>让我们继续为我们的组件添加要求:它应该呈现任何通过的道具。</p>
<p>这里有一个测试:</p>
<pre>import React from "react";
  import { create } from "react-test-renderer";

  // the component is still not updated as we use TDD
  const BtnGroup = () =&gt; &lt;div className="btn-group" /&gt;;

  test("renders BtnGroup component with custom props", () =&gt; {
    // generate some custom props
    const props = { id: "awesome-button-id", className: "mb-3", children: "child" };

    // boilerplate code
    const instance = create(&lt;BtnGroup {...props} /&gt;).root;
    
    // get element by component name
    const element = instance.findByType("div");

    // assert if an additional className was added to existing one
    expect(element.props.className).toEqual("btn-group mb-3");
    // assert "id" prop to match passed one
    expect(element.props.id).toEqual(props.id);
    // assert "children" to match passed
    expect(element.props.children).toEqual(children);
  });</pre>
<p>测试的代码看起来已经很熟悉了；我们只是检查传递的属性值是否匹配。</p>
<p>现在，测试将中断并发出以下消息:</p>
<pre>Expected: "btn-group mb-3"
Received: "btn-group"</pre>
<p>现在发生的是，我们需要真正开始传递道具。否则，<code>btn-group</code>将一直存在:</p>
<pre>const BtnGroup = props =&gt; &lt;div className="btn-group" {...props} /&gt;;</pre>
<p>这就是测试派上用场的地方。我们有另一条消息告诉我们,<code>className</code>的情况很特殊:</p>
<pre>Expected: "btn-group mb-3"
Received: "mb-3"</pre>
<p>现在，传递的道具替换了我们组件已经有的道具；在我们的例子中，<code>btn-group</code>被替换为<code>mb-3</code>。</p>
<p>我们应该修改组件的代码来解决这个问题，这样它就能以不同的方式处理<code>className</code>:</p>
<pre>const BtnGroup = ({className = "", ...rest}) =&gt;
    &lt;div {...rest} className={`btn-group ${className}`} /&gt;;</pre>
<p>这里的技巧是析构道具，这样需要特殊处理的物品就有了它们的名字，所有其他道具都合并到一个<code>rest</code>对象中。</p>
<p>同样，<code>children</code> prop不需要特殊的方法，尽管它们现在作为一个常规的prop被传递，而不是在组件的主体中。</p>
<p>现在，测试应该又变绿了。所有以前编写的测试也将是绿色的:</p>
<p><img data-attachment-id="9201" data-permalink="https://blog.logrocket.com/tdd-with-react-test-renderer/screenshot-green-test-pass-2-nocdn/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2019/11/Screenshot-green-test-pass-2-nocdn.png" data-orig-size="418,285" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Screenshot-green-test-pass-2-nocdn" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2019/11/Screenshot-green-test-pass-2-nocdn-300x205.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2019/11/Screenshot-green-test-pass-2-nocdn.png" decoding="async" class="aligncenter wp-image-9201 jetpack-lazy-image" src="../Images/9e3fb4e824e83498ffc561680f12f725.png" alt="Screenshot 2 of a passed test" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2019/11/Screenshot-green-test-pass-2-nocdn.png 418w, https://blog.logrocket.com/wp-content/uploads/2019/11/Screenshot-green-test-pass-2-nocdn-300x205.png 300w" data-lazy-sizes="(max-width: 600px) 100vw, 600px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2019/11/Screenshot-green-test-pass-2-nocdn.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/11/Screenshot-green-test-pass-2-nocdn.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="9201" data-permalink="https://blog.logrocket.com/tdd-with-react-test-renderer/screenshot-green-test-pass-2-nocdn/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2019/11/Screenshot-green-test-pass-2-nocdn.png" data-orig-size="418,285" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Screenshot-green-test-pass-2-nocdn" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2019/11/Screenshot-green-test-pass-2-nocdn-300x205.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2019/11/Screenshot-green-test-pass-2-nocdn.png" decoding="async" loading="lazy" class="aligncenter wp-image-9201" src="../Images/9e3fb4e824e83498ffc561680f12f725.png" alt="Screenshot 2 of a passed test" srcset="https://blog.logrocket.com/wp-content/uploads/2019/11/Screenshot-green-test-pass-2-nocdn.png 418w, https://blog.logrocket.com/wp-content/uploads/2019/11/Screenshot-green-test-pass-2-nocdn-300x205.png 300w" sizes="(max-width: 600px) 100vw, 600px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/11/Screenshot-green-test-pass-2-nocdn.png"/></noscript>
<blockquote><p><strong>注意:</strong>我在这里留了一个<code>console.log</code>来展示你如何随时检查输出。</p></blockquote>
<p>如您所见，我们所做的所有断言——就目前而言——只是检查字符串是否匹配。但是如果需要检查项目的数量，我们可以在测试渲染器中使用这个方便的方法:<code>testInstance.findAllByType()</code>。</p>
<p>让我们看看它是如何工作的。</p>
<h2>测试项目数量</h2>
<p>为了演示如何在React测试渲染器中计数项目，我们应该有一些组件来渲染数组或列表。因此，要求是组件应该呈现一个具有正确项目计数的列表。</p>
<p>为了遵循TDD，我们将从一个呈现空<code>ul</code>标签的空功能组件开始:</p>
<pre>const ProductList = ({ list }) =&gt; &lt;ul /&gt;;</pre>
<p>我们可以写一个测试:</p>
<pre>import React from "react";
  import { create } from "react-test-renderer";

  test("renders a list of items with correct items count", () =&gt; {
    // prepare the list for testing
    const list = [{ id: 1, text: "first item" }, { id: 2, text: "second item" }];

    // boilerplate code
    const root = create(&lt;ProductList list={list} /&gt;).root;
    
    // [ 7 ] get list items
    const elementList = root.findAllByType("li");

    // assert if the length match with original list passed as a prop
    expect(elementList.length).toEqual(list.length);
  });</pre>
<p>该测试的目标是检查渲染节点的数量是否等于传递的项目的数量。</p>
<p>最初，测试将中断，并显示以下消息:</p>
<p><img data-attachment-id="9215" data-permalink="https://blog.logrocket.com/tdd-with-react-test-renderer/screenshot-production-list-nocdn/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2019/11/Screenshot-production-list-nocdn.png" data-orig-size="554,216" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Screenshot-production-list-nocdn" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2019/11/Screenshot-production-list-nocdn-300x117.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2019/11/Screenshot-production-list-nocdn.png" decoding="async" class="aligncenter wp-image-9215 jetpack-lazy-image" src="../Images/e020ae1c74632d83ac82392321128150.png" alt="Screenshot production list" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2019/11/Screenshot-production-list-nocdn.png 554w, https://blog.logrocket.com/wp-content/uploads/2019/11/Screenshot-production-list-nocdn-300x117.png 300w" data-lazy-sizes="(max-width: 600px) 100vw, 600px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2019/11/Screenshot-production-list-nocdn.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/11/Screenshot-production-list-nocdn.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="9215" data-permalink="https://blog.logrocket.com/tdd-with-react-test-renderer/screenshot-production-list-nocdn/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2019/11/Screenshot-production-list-nocdn.png" data-orig-size="554,216" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Screenshot-production-list-nocdn" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2019/11/Screenshot-production-list-nocdn-300x117.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2019/11/Screenshot-production-list-nocdn.png" decoding="async" loading="lazy" class="aligncenter wp-image-9215" src="../Images/e020ae1c74632d83ac82392321128150.png" alt="Screenshot production list" srcset="https://blog.logrocket.com/wp-content/uploads/2019/11/Screenshot-production-list-nocdn.png 554w, https://blog.logrocket.com/wp-content/uploads/2019/11/Screenshot-production-list-nocdn-300x117.png 300w" sizes="(max-width: 600px) 100vw, 600px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/11/Screenshot-production-list-nocdn.png"/></noscript>
<p>为了修复测试，我们应该在容器中呈现带有<code>li</code>标签的列表项:</p>
<pre>const ProductList = ({ list }) =&gt; &lt;ul&gt;
    {list.map(li =&gt; &lt;li key={li.id}&gt;{li.text}&lt;/li&gt;)}
&lt;/ul&gt;;</pre>
<p>现在测试是绿色的，我们可以讨论代码了。</p>
<p>[ 7 ]为了专门查询类型为<code>li</code>的节点，我使用了返回所有标签为<code>li</code>的元素的<code>testInstance.findAllByType()</code>方法。</p>
<p>也有一些其他的方法来搜索多个项目:<code>testInstance.findAll()</code>和<code>testInstance.findAllByProps()</code>。当您需要检查总数时，第一种方法很有用，而当您想要计算特定属性时，第二种方法很方便，例如，所有具有特定<code>className</code>的节点。</p>
<h2>测试文本</h2>
<p>在大多数情况下，只测试项目数量是不够的，您还需要测试用户可以阅读的实际文本。</p>
<p>React测试渲染器中没有用于此目的的特定功能，但是如果您考虑到文本只能在儿童中找到，那么编写该功能非常容易。</p>
<pre>import React from "react";
  import { create } from "react-test-renderer";

  test("renders all items with correct text", () =&gt; {
    // [ 8 ] prepare the list for testing
    const list = [{ id: 1, text: "first item" }, { id: 2, text: 33 }];

    // boilerplate code
    const root = create(&lt;ProductList list={list} /&gt;).root;

    // get list items
    const elementList = root.findAllByType("li");

    // [ 10 ] Iterate over all items and search for text occurence in children
    elementList.forEach((el, index) =&gt; {
        // [ 11 ] convert text to string
        expect(el.children.includes(`${list[index].text}`)).toBe(true);
    });
  });</pre>
<p>有了[ 8 ]中所有条目的列表，我们可以迭代组件的节点，并确保找到每个文本[ 10 ]。</p>
<p>只要组件内部没有任何过滤或排序逻辑，并且只是按原样呈现一个列表，这个测试就会立即显示为绿色，因此我们不必在测试中更改任何代码行。</p>
<p>这里唯一需要添加的是，无论传递的值类型是什么，呈现的文本总是一个字符串。</p>
<h2>测试事件处理程序和挂钩</h2>
<p>由于Hooks API，一些功能组件不仅仅依赖于props，还拥有自己的状态管理。考虑一个具有以下要求的toggler组件的经典示例:</p>
<ul>
<li>应该呈现一个按钮</li>
<li>应该在按钮点击时切换孩子</li>
</ul>
<p>这意味着单击时子视图的可见性会改变。</p>
<p>这里有一个你可以编写的测试的例子:</p>
<pre>import React from "react";
import { create, act } from "react-test-renderer"

// let component to be a fragment for start
const VisibilityToggler = () =&gt; &lt;&gt;&lt;/&gt;;

test("should toggle children nodes on button click", () =&gt; {
  const root = create(
    &lt;VisibilityToggler&gt;
      &lt;div&gt;awecome content&lt;/div&gt;
    &lt;/VisibilityToggler&gt;
  ).root;

  // helper to get nodes other than "button"
  const getChildrenCount = () =&gt;
    root.findAll(node =&gt; node.type !== "button").length;

  // assert that button exists
  expect(root.findAllByType("button").length).toEqual(1);

  // query for a button
  const button = root.findAllByType("button")[0];

  // remember initial nodes count (before toggle)
  const initialCount = getChildrenCount();

  // trigger a hook by calling onClick of a button
  act(button.props.onClick);
  const countAfterFirstClick = getChildrenCount();

  // assert that nodes count after a click is greater than before
  expect(countAfterFirstClick &gt; initialCount).toBe(true);

  // trigger another click
  act(button.props.onClick);
  const countAfterSecondClick = getChildrenCount();

  // check that nodes were toggled off and the count of rendered nodes match initial
  expect(countAfterSecondClick === initialCount).toBe(true);
});</pre>
<p>这个测试看起来很庞大，所以我们不要试图马上修复它。首先，让我们讨论一下代码。</p>
<p>[ 12 ]这里发生了一件新的事情:<code>act()</code>方法被用来包装事件处理程序调用。</p>
<p>为什么我们要？我们应该如何记住这样做？第二个答案很简单:不需要记住，因为React测试渲染器会检查代码，并打印一个带有原因的警告。</p>
<p>当编写UI测试时，像呈现、用户事件或数据获取这样的任务可以被认为是与用户界面交互的“单元”。</p>
<p>React提供了一个名为<code>act()</code>的助手，确保在您从文档中做出任何断言之前，与这些“单元”相关的所有更新都已被处理并应用到DOM。</p>
<p>换句话说，<code>act()</code>方法“等待”React更新，并使异步代码看起来同步，非常类似于ES7的<code>await</code>。</p>
<p>在这个阶段，测试找不到按钮并中断:</p>
<p><img data-attachment-id="9213" data-permalink="https://blog.logrocket.com/tdd-with-react-test-renderer/screenshot-fail-4-nocdn/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2019/11/Screenshot-fail-4-nocdn.png" data-orig-size="477,224" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Screenshot-fail-4-nocdn" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2019/11/Screenshot-fail-4-nocdn-300x141.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2019/11/Screenshot-fail-4-nocdn.png" decoding="async" class="aligncenter wp-image-9213 jetpack-lazy-image" src="../Images/43fae2e4c6b6d3b14d31004d9f42d5c5.png" alt="Screenshot 4 " data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2019/11/Screenshot-fail-4-nocdn.png 477w, https://blog.logrocket.com/wp-content/uploads/2019/11/Screenshot-fail-4-nocdn-300x141.png 300w" data-lazy-sizes="(max-width: 600px) 100vw, 600px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2019/11/Screenshot-fail-4-nocdn.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/11/Screenshot-fail-4-nocdn.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="9213" data-permalink="https://blog.logrocket.com/tdd-with-react-test-renderer/screenshot-fail-4-nocdn/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2019/11/Screenshot-fail-4-nocdn.png" data-orig-size="477,224" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Screenshot-fail-4-nocdn" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2019/11/Screenshot-fail-4-nocdn-300x141.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2019/11/Screenshot-fail-4-nocdn.png" decoding="async" loading="lazy" class="aligncenter wp-image-9213" src="../Images/43fae2e4c6b6d3b14d31004d9f42d5c5.png" alt="Screenshot 4 " srcset="https://blog.logrocket.com/wp-content/uploads/2019/11/Screenshot-fail-4-nocdn.png 477w, https://blog.logrocket.com/wp-content/uploads/2019/11/Screenshot-fail-4-nocdn-300x141.png 300w" sizes="(max-width: 600px) 100vw, 600px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/11/Screenshot-fail-4-nocdn.png"/></noscript>
<p>要解决这个问题，让我们添加一个按钮:</p>
<pre>const VisibilityToggler = () =&gt; &lt;&gt;&lt;button /&gt;&lt;/&gt;;</pre>
<p>按钮存在，但是没有找到<code>onClick</code>方法:</p>
<p><img data-attachment-id="9207" data-permalink="https://blog.logrocket.com/tdd-with-react-test-renderer/screenshot-fail-nocdn/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2019/11/Screenshot-fail-nocdn.png" data-orig-size="436,168" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Screenshot-fail-nocdn" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2019/11/Screenshot-fail-nocdn-300x116.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2019/11/Screenshot-fail-nocdn.png" decoding="async" class="aligncenter wp-image-9207 jetpack-lazy-image" src="../Images/5233c209161b95128090d9784df4d068.png" alt="Screenshot of a failed test" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2019/11/Screenshot-fail-nocdn.png 436w, https://blog.logrocket.com/wp-content/uploads/2019/11/Screenshot-fail-nocdn-300x116.png 300w" data-lazy-sizes="(max-width: 600px) 100vw, 600px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2019/11/Screenshot-fail-nocdn.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/11/Screenshot-fail-nocdn.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="9207" data-permalink="https://blog.logrocket.com/tdd-with-react-test-renderer/screenshot-fail-nocdn/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2019/11/Screenshot-fail-nocdn.png" data-orig-size="436,168" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Screenshot-fail-nocdn" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2019/11/Screenshot-fail-nocdn-300x116.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2019/11/Screenshot-fail-nocdn.png" decoding="async" loading="lazy" class="aligncenter wp-image-9207" src="../Images/5233c209161b95128090d9784df4d068.png" alt="Screenshot of a failed test" srcset="https://blog.logrocket.com/wp-content/uploads/2019/11/Screenshot-fail-nocdn.png 436w, https://blog.logrocket.com/wp-content/uploads/2019/11/Screenshot-fail-nocdn-300x116.png 300w" sizes="(max-width: 600px) 100vw, 600px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/11/Screenshot-fail-nocdn.png"/></noscript>
<p>不要忘记添加一个按钮:</p>
<pre>const VisibilityToggler = () =&gt; &lt;&gt;&lt;button /&gt;&lt;/&gt;;</pre>
<p>这是添加<code>onClick</code>处理程序后您将收到的下一条消息:</p>
<p><img data-attachment-id="9208" data-permalink="https://blog.logrocket.com/tdd-with-react-test-renderer/screenshot-2-fail-red-nocdn/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2019/11/Screenshot-2-fail-red-nocdn.png" data-orig-size="542,228" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Screenshot-2-fail-red-nocdn" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2019/11/Screenshot-2-fail-red-nocdn-300x126.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2019/11/Screenshot-2-fail-red-nocdn.png" decoding="async" class="aligncenter wp-image-9208 jetpack-lazy-image" src="../Images/2a8fb28bc5ae142e7afce2a8f682629c.png" alt="Screenshot fail red" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2019/11/Screenshot-2-fail-red-nocdn.png 542w, https://blog.logrocket.com/wp-content/uploads/2019/11/Screenshot-2-fail-red-nocdn-300x126.png 300w" data-lazy-sizes="(max-width: 600px) 100vw, 600px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2019/11/Screenshot-2-fail-red-nocdn.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/11/Screenshot-2-fail-red-nocdn.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="9208" data-permalink="https://blog.logrocket.com/tdd-with-react-test-renderer/screenshot-2-fail-red-nocdn/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2019/11/Screenshot-2-fail-red-nocdn.png" data-orig-size="542,228" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Screenshot-2-fail-red-nocdn" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2019/11/Screenshot-2-fail-red-nocdn-300x126.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2019/11/Screenshot-2-fail-red-nocdn.png" decoding="async" loading="lazy" class="aligncenter wp-image-9208" src="../Images/2a8fb28bc5ae142e7afce2a8f682629c.png" alt="Screenshot fail red" srcset="https://blog.logrocket.com/wp-content/uploads/2019/11/Screenshot-2-fail-red-nocdn.png 542w, https://blog.logrocket.com/wp-content/uploads/2019/11/Screenshot-2-fail-red-nocdn-300x126.png 300w" sizes="(max-width: 600px) 100vw, 600px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/11/Screenshot-2-fail-red-nocdn.png"/></noscript>
<p>最后，我们准备添加一些带有钩子的状态管理:</p>
<pre>const VisibilityToggler = ({ children }) =&gt; {
  const [isVisible, setVisibility] = useState(false);
  const toggle = () =&gt; setVisibility(!isVisible);
  return (
    &lt;&gt;
      &lt;button onClick={toggle}&gt;toggle&lt;/button&gt;
      {isVisible &amp;&amp; children}
    &lt;/&gt;
  );
};</pre>
<p>现在点击一个按钮将状态变量<code>isVisible</code>切换到相反的值(<code>true</code>或<code>false</code>)，这反过来导致在<code>true</code>的情况下渲染<code>children</code>，在<code>false</code>的情况下跳过渲染<code>children</code>。</p>
<p>所有测试现在都应该是绿色的。您可以在此处找到该示例的完整源代码:</p>
<p><img data-attachment-id="9211" data-permalink="https://blog.logrocket.com/tdd-with-react-test-renderer/screenshot-passed-test-3-nocdn/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2019/11/Screenshot-passed-test-3-nocdn.png" data-orig-size="295,213" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Screenshot-passed-test-3-nocdn" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2019/11/Screenshot-passed-test-3-nocdn.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2019/11/Screenshot-passed-test-3-nocdn.png" decoding="async" class="aligncenter wp-image-9211 jetpack-lazy-image" src="../Images/315fcf2c15277f0df21ee92c18e25d63.png" alt="Screenshot of three complete passed test" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2019/11/Screenshot-passed-test-3-nocdn.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/11/Screenshot-passed-test-3-nocdn.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="9211" data-permalink="https://blog.logrocket.com/tdd-with-react-test-renderer/screenshot-passed-test-3-nocdn/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2019/11/Screenshot-passed-test-3-nocdn.png" data-orig-size="295,213" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Screenshot-passed-test-3-nocdn" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2019/11/Screenshot-passed-test-3-nocdn.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2019/11/Screenshot-passed-test-3-nocdn.png" decoding="async" loading="lazy" class="aligncenter wp-image-9211" src="../Images/315fcf2c15277f0df21ee92c18e25d63.png" alt="Screenshot of three complete passed test" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/11/Screenshot-passed-test-3-nocdn.png"/></noscript>
<h2>结论</h2>
<p>尽管React Test Renderer通常与快照测试相关联，但它仍然可以用于针对您的组件做出特定的断言，对于大多数常见的用例来说，这已经足够准确了。</p>
<p>我个人喜欢它，因为它有一个干净的API，它很简单，并且很容易与TDD一起使用。希望你也喜欢！</p><div class="code-block code-block-17">
<div class="blog-plug inline-plug react-plug" vwo-el-id="26283398190">
<h2 vwo-el-id="41600691720">使用LogRocket消除传统反应错误报告的噪音</h2>
<a href="https://lp.logrocket.com/blg/react-signup-issue-free" target="_blank" vwo-el-id="19356441070">LogRocket
</a><p>是一款React analytics解决方案，可保护您免受数百个误报错误警报的影响，只针对少数真正重要的项目。LogRocket告诉您React应用程序中实际影响用户的最具影响力的bug和UX问题。</p><a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="19356441380">
<img class="first-react-image alignnone size-full wp-image-46 jetpack-lazy-image jetpack-lazy-image--handled" src="../Images/f300c244a1a1cf916df8b4cb02bec6c6.png" vwo-el-id="18272717540" data-lazy-loaded="1" data-original-src="https://files.readme.io/27c94e7-Image_2017-06-05_at_9.46.04_PM.png"/>
</a>
<a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="19356441690">
<img class="second-react-image alignnone size-full wp-image-46 jetpack-lazy-image jetpack-lazy-image--handled" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" vwo-el-id="30720362350" data-lazy-loaded="1" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/>
</a>
<a href="https://lp.logrocket.com/blg/react-signup-issue-free" target="_blank" rel="noopener noreferrer" vwo-el-id="35866400580">LogRocket
</a><p>自动聚合客户端错误、反应错误边界、还原状态、缓慢的组件加载时间、JS异常、前端性能指标和用户交互。然后，LogRocket使用机器学习来通知您影响大多数用户的最具影响力的问题，并提供您修复它所需的上下文。</p><p vwo-el-id="28675661060">关注重要的React bug—<a class="signup" href="https://lp.logrocket.com/blg/react-signup-issue-free" target="_blank" rel="noopener noreferrer" vwo-el-id="40093418840">今天就试试LogRocket】。</a></p>
</div></div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
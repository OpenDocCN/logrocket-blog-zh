<html>
<head>
<title>Building a JavaScript router using History API - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>使用历史API构建JavaScript路由器</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/building-a-javascript-router-using-history-api/#0001-01-01">https://blog.logrocket.com/building-a-javascript-router-using-history-api/#0001-01-01</a></blockquote><div><article class="article-post">
<p>在本文中，我们将构建一个客户端路由系统。客户端路由是一种路由类型，用户在应用程序中导航时，即使页面的URL发生变化，也不会重新加载整个页面，而是显示新的内容。</p>
<p>为了构建这个，我们需要一个简单的服务器来服务我们的<code>index.html</code>文件。准备好了吗？我们开始吧。</p>
<p>首先，设置一个新的node.js应用程序并创建项目结构:</p>
<pre>npm init -y
npm install express morgan nodemon --save
touch server.js
mkdir public &amp;&amp; cd public
touch index.html &amp;&amp; touch main.js file
cd ..
</pre>
<p><code>npm init</code>命令将为我们的应用程序创建一个<code>package.json</code>文件。我们将安装<code>Express</code>和<code>Morgan</code>，它们将用于运行我们的服务器和记录我们的路线。</p>
<p>我们还将创建一个<code>server.js</code>文件和一个公共目录，我们将在其中写入我们的视图。一旦我们对文件做了任何更改，Nodemon 将重启我们的应用程序。</p>
<h2>设置服务器</h2>
<p>让我们使用Express通过修改<code>server.js</code>文件来创建一个简单的服务器:</p>
<pre>const express = require('express');
const morgan = require('morgan');
const app = express();

app.use(morgan('dev'));
app.use(express.static('public'))

app.get('*', (req, res) =&gt; {
    res.sendFile(__dirname + '/public/index.html')
})
app.listen(7000, () =&gt; console.log("App is listening on port 7000"))
</pre>
<p>现在我们可以通过运行<code>nodemon server.js</code>来启动我们的应用程序。让我们为HTML创建一个简单的样板文件:</p>
<pre>&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;
    &lt;meta charset="UTF-8"&gt;
    &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;
    &lt;title&gt;Document&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;h1&gt;Javascript Routing&lt;/h1&gt;
    &lt;div id="app"&gt;
    &lt;/div&gt;

    &lt;script src="main.js"&gt;&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</pre>
<p>这里，我们将链接<code>main.js</code>文件，以便我们可以在任何时间点操作DOM。</p>
<h2>实施路由系统</h2>
<p>让我们转到<code>main.js</code>文件，写下我们所有的路由器逻辑。我们所有的代码都将被包装在<code>window.onload</code>中，这样它们只在网页完全加载了所有内容后才执行脚本。</p>
<p>接下来，我们将创建一个路由器实例，它是一个带有两个参数的函数。第一个参数是路线的名称，第二个参数是一个数组，它包含了我们定义的所有路线。这个路由将有两个属性:路由的名称和路由的路径。</p>
<pre>window.onload = () =&gt; {
// get root div for rendering
    let root = document.getElementById('app');

  //router instance
    let Router = function (name, routes) {
        return {
            name,
            routes
        }
    };

 //create the route instance
    let routerInstance = new Router('routerInstance', [{
            path: "/",
            name: "Root"
        },
        {
            path: '/about',
            name: "About"
        },
        {
            path: '/contact',
            name: "Contact"
        }
    ])

}
</pre>
<p>我们可以获得页面的当前路径，并显示基于该路径的模板。返回页面的当前路径，我们可以将这段代码用于我们的DOM:</p>
<pre> let currentPath = window.location.pathname;
    if (currentPath === '/') {
        root.innerHTML = 'You are on Home page'
    } else {
        // check if route exist in the router instance 
        let route = routerInstance.routes.filter(r =&gt; r.path === currentPath)[0];
        if (route) {
            root.innerHTML = `You are on the ${route.name} path`
        } else {
            root.innerHTML = `This route is not defined`
        }
    }
</pre>
<p>我们将使用<code>currentPath</code>变量来检查route实例中是否定义了路由。如果路由存在，我们将呈现一个简单的HTML模板。如果没有，我们将在页面上显示<code>This route is not defined</code>。</p>
<p>请随意显示您选择的任何形式的错误。例如，如果路由不存在，您可以让它重定向回主页。</p>
<h3>添加路由器链接</h3>
<p>为了浏览页面，我们可以添加路由器链接。就像使用<a href="https://angular.io/" target="_blank" rel="noopener noreferrer"> Angular </a>一样，您可以传递一个<code>routerLink</code>，它将具有您想要导航到的路径的值。为了实现这一点，让我们添加一些链接到我们的<code>index.html</code>文件:</p>
<pre>&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;
    &lt;meta charset="UTF-8"&gt;
    &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;
    &lt;title&gt;Document&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;nav&gt;
        &lt;button router-link="/"&gt;Home&lt;/button&gt;
        &lt;button router-link="/about"&gt;About&lt;/button&gt;
        &lt;button router-link="/contact"&gt;Contact&lt;/button&gt;
        &lt;button router-link="/unknown"&gt;Error&lt;/button&gt;
    &lt;/nav&gt;
    &lt;h1&gt;Javascript Routing&lt;/h1&gt;
    &lt;div id="app"&gt;
    &lt;/div&gt;

    &lt;script src="main.js"&gt;&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</pre>
<p>注意我们传入的<code>router-link</code>属性——这是我们将用于路由的属性。</p>
<p>我们将创建一个存储所有<code>router-link</code>的变量，并将其存储在一个数组中:</p>
<pre>let definedRoutes = Array.from(document.querySelectorAll('[router-link]'));
</pre>
<p>在一个数组中存储了我们的路由器链接之后，我们可以遍历它们并添加一个click事件监听器来调用<code>navigate()</code>函数:</p>
<pre> //iterate over all defined routes
    definedRoutes.forEach(route =&gt; {
        route.addEventListener('click', navigate, false)
    })
</pre>
<h3>定义导航功能</h3>
<p>导航功能将使用<a href="https://developer.mozilla.org/en-US/docs/Web/API/History_API" target="_blank" rel="noopener noreferrer"> Javascript历史API </a>来导航。<code>history.pushState()</code>方法向浏览器的会话历史堆栈添加一个状态。</p>
<p>单击该按钮时，我们将接收该按钮的路由器链接属性，然后使用<code>history.pushState()</code>导航到该路径，然后更改呈现的HTML模板:</p>
<pre>  // method to navigate
    let navigate = e =&gt; {
        let route = e.target.attributes[0].value;

        // redirect to the router instance
        let routeInfo = routerInstance.routes.filter(r =&gt; r.path === route)[0]
        if (!routeInfo) {
            window.history.pushState({}, '', 'error')
            root.innerHTML = `This route is not Defined`
        } else {
            window.history.pushState({}, '', routeInfo.path)
            root.innerHTML = `You are on the ${routeInfo.name} path`
        }
    }
</pre>
<p>如果一个导航链接有一个路由器链接没有在<code>routeInstance</code>中定义，它将把推送状态设置为<code>error</code>并在模板上呈现<code>This route is not Defined</code>。</p>
<p>接下来，您应该考虑将路线存储在一个单独的文件中，这使得代码更整洁，如果有任何错误也更容易调试。现在，创建一个<code>routes.js</code>文件，并将路由构造器和路由器实例提取到这个新文件中:</p>
<pre>//router instance
let Router = function (name, routes) {
    return {
        name,
        routes
    }
};
let routerInstance = new Router('routerInstance', [{
        path: "/",
        name: "Root"
    },
    {
        path: '/about',
        name: "About"
    },
    {
        path: '/contact',
        name: "Contact"
    }
])

export default routerInstance
</pre>
<p>导出该文件可以让其他JavaScript文件访问它。我们可以将它导入我们的main.js文件:</p>
<pre>import routerInstance from './routes.js'
</pre>
<p>这将抛出一个错误。要解决这个问题，请将index.html文件中的脚本标记修改为:</p>
<pre>&lt;script type="module" src="main.js"&gt;&lt;/script&gt;
</pre>
<p>添加模块类型指定了哪些变量和函数可以在模块外部访问。</p>
<h2>结论</h2>
<p>理解如何用普通的JavaScript实现路由系统使开发人员更容易使用框架路由库，如<a href="https://router.vuejs.org/"> Vue.js Router </a>。我们这里的代码可以在单个页面应用程序中重用，这在没有框架的情况下是非常完美的。要获得源代码，请查看<a href="https://github.com/Wisdom132/jsrouter" target="_blank" rel="noopener noreferrer"> GitHub </a>。</p><div class="code-block code-block-27">
<div class="blog-plug inline-plug vanilla-javascript-cta"><h2>通过理解上下文，更容易地调试JavaScript错误</h2>
<p>调试代码总是一项单调乏味的任务。但是你越了解自己的错误，就越容易改正。</p>
<p>LogRocket 让你以新的独特的方式理解这些错误。我们的前端监控解决方案跟踪用户与您的JavaScript前端的互动，让您能够准确找出导致错误的用户行为。</p>
<a href="https://lp.logrocket.com/blg/javascript-signup" class="signup" target="_blank" rel="noopener noreferrer"><img class="alignnone size-full wp-image-46 jetpack-lazy-image" src="../Images/cbfed9be3defcb505e662574769a7636.png" alt="LogRocket Dashboard Free Trial Banner" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2020/06/reproduce-javascript-errors.gif?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/06/reproduce-javascript-errors.gif"/><noscript><img data-lazy-fallback="1" class="alignnone size-full wp-image-46" src="../Images/cbfed9be3defcb505e662574769a7636.png" alt="LogRocket Dashboard Free Trial Banner" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/06/reproduce-javascript-errors.gif"/></noscript></a>
<p>LogRocket记录控制台日志、页面加载时间、堆栈跟踪、慢速网络请求/响应(带有标题+正文)、浏览器元数据和自定义日志。理解您的JavaScript代码的影响从来没有这么简单过！</p>
<a class="signup" href="https://lp.logrocket.com/blg/javascript-signup" target="_blank" rel="noopener noreferrer">Try it for free</a><p>.</p></div>


</div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
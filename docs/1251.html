<html>
<head>
<title>Timezone handling in Rust with Chrono-TZ - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>用Chrono-TZ - LogRocket博客处理Rust中的时区</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/timezone-handling-in-rust-with-chrono-tz/#0001-01-01">https://blog.logrocket.com/timezone-handling-in-rust-with-chrono-tz/#0001-01-01</a></blockquote><div><article class="article-post">
<p>当在现代web应用程序中处理日期和时间时——尤其是为来自世界各地的用户提供服务的应用程序——处理时区可能会成为一个问题。</p>
<p/>
<p>根据不同的用例，时区可能会相当棘手。快速浏览一下<a href="https://www.iana.org/time-zones" target="_blank" rel="noopener noreferrer"> IANA时区数据库</a>及其发布历史，您会注意到另一个问题:时区可以改变。仅仅在过去的五年里，朝鲜、俄罗斯、海地、智利等地就发生了时区变化。其中一些变化包括增加或取消夏令时，其他的基于不同的因素。</p>
<p>如果您需要在应用程序中使用准确的时区，保持时区的最新是非常重要的。例如，假设您想在某个时间点向所有用户发送一封电子邮件或通知。根据国家通知的时间和数据库变化传播的速度，可能会有一段时间你的应用程序中的时区完全错误。</p>
<p>在本教程中，我们将向您展示如何使用<a href="https://github.com/chronotope/chrono" target="_blank" rel="noopener noreferrer"> Chrono </a>和<a href="https://github.com/chronotope/chrono-tz" target="_blank" rel="noopener noreferrer"> Chrono-TZ </a>库来处理Rust中的日期和时区。Chrono是处理Rust中的日期和时间的首选机箱，而Chrono-TZ是处理时区的扩展。</p>
<p>我们将构建一个简单的web服务，使用户能够以<a href="https://www.ietf.org/rfc/rfc3339.txt" target="_blank" rel="noopener noreferrer"> RFC3339 </a>格式(“1996-12-19T16:39:57+02:00”)添加日期，其中包括时区。然后，这些日期被保存在内存中，用户可以获取它们并将其转换为自己选择的时区。</p>
<p>在构建这个应用程序时，我们将演示如何在Rust中解析和格式化日期，以及如何解析和转换时区。</p>
<h2 id="setup">设置</h2>
<p>接下来，您需要一个最新的Rust安装(1.39+)和一个发送HTTP请求的工具，比如cURL。</p>
<p>首先，创建一个新的Rust项目。</p>
<pre>cargo new rust-timezone-example
cd rust-timezone-example
</pre>
<p>接下来，编辑<code>Cargo.toml</code>文件并添加必要的依赖项。</p>
<pre>[dependencies]
tokio = { version = "0.2", features = ["macros", "rt-threaded", "sync"] }
warp = "0.2"
chrono = { version = "0.4", features = ["serde"] }
chrono-tz = "0.5"
serde = {version = "1.0", features = ["derive"] }
serde_json = "1.0"
</pre>
<p>该服务将使用下面的tokio用warp编写。我们将使用<code>serde</code>来反序列化传入的请求负载。</p>
<h2 id="datastorage">数据存储</h2>
<p>我们将使用共享数据向量形式的内存数据存储机制。</p>
<pre>use chrono::prelude::*;
use tokio::sync::RwLock;
use std::sync::Arc;

type Dates = Arc&lt;RwLock&lt;Vec&lt;DateTime&lt;Utc&gt;&gt;&gt;&gt;;
</pre>
<p>类型描述了我们的数据存储。它前面有一个有点吓人的类型列表，但实际上没什么特别的。</p>
<p>让我们从里到外。我们将在<code>UTC</code>中保存日期。这样，我们就不必跟踪即将到来的日期的时区；我们可以简单地在它们之间转换。<code>DateTime</code>和<code>Utc</code>类型来自Chrono的前奏。</p>
<p>我们想要保存一个日期列表，所以这些日期被放入一个<code>Vec</code>中。因为我们将使用它作为异步web服务的数据存储，所以我们可能会从不同的线程中读取和写入这个数据存储，可能是在同一时间。出于这个原因，我们将在它周围放置一个来自tokio运行时的async <code>RwLock</code>,这样任何想要访问它的人都必须获得一个锁。一个<code>RwLock</code>授予多个读者一个锁，但是一次只能有一个写锁处于活动状态。这保证了我们不会有任何数据竞争。</p>
<p>最后，我们将全部内容放在一个<code>Arc</code>——一个原子引用计数的智能指针——中，这样我们就可以以一种内存安全的方式跨线程共享它。</p>
<h2 id="webserver">网络服务器</h2>
<p>下一步是建立一个基本的web服务，并将其与这个临时的数据存储连接起来。先说<code>main</code>中的warp服务器。</p>
<pre>use warp::{http::StatusCode, reply, Filter, Rejection, Reply};
use std::convert::Infallible;

#[tokio::main]
async fn main() {
    let dates: Dates = Arc::new(RwLock::new(Vec::new()));

    let create_route = warp::path("create")
        .and(warp::post())
        .and(with_dates(dates.clone()))
        .and(warp::body::json())
        .and_then(create_handler);
    let fetch_route = warp::path("fetch")
        .and(warp::get())
        .and(warp::path::param())
        .and(with_dates(dates.clone()))
        .and_then(fetch_handler);

    println!("Server started at localhost:8080");
    warp::serve(create_route.or(fetch_route))
        .run(([0, 0, 0, 0], 8080))
        .await;
}

fn with_dates(dates: Dates) -&gt; impl Filter&lt;Extract = (Dates,), Error = Infallible&gt; + Clone {
    warp::any().map(move || dates.clone())
}
</pre>
<p>我们创建两条路线，一条是到<code>POST /create</code>的，一条是到<code>GET /fetch/$timezone</code>的。在这两种情况下，我们通过一个名为<code>with_dates</code>的扭曲过滤器将在<code>main</code>开始时初始化的<code>dates</code>数据存储传递给处理程序，该过滤器只是将一个原子引用复制到处理程序中。</p>
<p><code>create</code>端点也接受类型为<code>DateTimeRequest</code>的有效负载。</p>
<pre>use serde::Deserialize;

#[derive(Deserialize)]
struct DateTimeRequest {
    date_time: String,
}
</pre>
<p>最后，我们需要为这些路由定义两个占位符处理函数。</p>
<pre>type Result&lt;T&gt; = std::result::Result&lt;T, Rejection&gt;;

async fn create_handler(dates: Dates, body: DateTimeRequest) -&gt; Result&lt;impl Reply&gt; {
    Ok("")
}

async fn fetch_handler(time_zone: String, dates: Dates) -&gt; Result&lt;impl Reply&gt; {
    Ok("")
}
</pre>
<p>这些还没有做任何有趣的事情，但这是我们接下来要解决的问题。</p><div class="code-block code-block-54">
<hr/>
<h3>更多来自LogRocket的精彩文章:</h3>

<hr/></div>
<h2 id="creatingdates">创建日期</h2>
<p>对于用于创建日期的端点，第一步是将传入的<code>body.date_time</code>字符串解析为有效的日期。然后，如果成功了，我们将把日期转换成UTC，并把它推送到数据存储，返回一个成功消息。</p>
<p>让我们来看看这个翻译成Rust的代码。</p>
<pre>async fn create_handler(dates: Dates, body: DateTimeRequest) -&gt; Result&lt;impl Reply&gt; {
    let dt: DateTime&lt;FixedOffset&gt; = match DateTime::parse_from_rfc3339(&amp;body.date_time) {
        Ok(v) =&gt; v,
        Err(e) =&gt; {
            return Ok(reply::with_status(
                format!("could not parse date: {}", e),
                StatusCode::BAD_REQUEST,
            ))
        }
    };

    dates.write().await.push(dt.with_timezone(&amp;Utc));

    Ok(reply::with_status(
        format!("Added date with timezone: {} as UTC", dt.timezone()),
        StatusCode::OK,
    ))
}
</pre>
<p>我们使用Chrono的<code>DateTime::parse_from_rfc3339</code>函数来解析日期。这里出来的是一个<code>DateTime&lt;FixedOffset</code>。偏移量描述了时区。在Chrono中，还有更多的方法来解析任意的用户定义格式的日期。</p>
<p>如果失败，我们将返回一个错误。否则，我们使用<code>dates.write().await</code>获得数据存储的写锁，并将转换为<code>UTC</code>的日期推送到日期向量。</p>
<p>最后，我们向用户返回一条成功消息，向他们显示从传入日期开始解析的时区。</p>
<h2 id="fetchingdates">获取日期</h2>
<p>要获取所有保存的日期，用户可以使用<code>GET /fetch/$timezone</code>端点，其中<code>$timezone</code>可能是类似于<code>UTC</code>、<code>GMT</code>、<code>Africa/Algiers</code>或任意<a href="https://docs.rs/chrono-tz/0.5.3/chrono_tz/enum.Tz.html">多个时区</a>的Chrono-TZ和IANA支持。</p>
<p>对于像<code>Europe/Vienna</code>这样的情况，当调用端点时，调用者需要对<code>/</code>到<code>%2F</code>进行url编码，我们必须再次对其进行url解码。对于这个基本示例，我们将做一个简单的替换来处理这种情况。</p>
<p>下一步是解析即将到来的时区，如果它是一个有效的时区，那么将所有保存的日期转换成这个时区后返回给用户。</p>
<p>让我们来看一个可能的解决方案:</p>
<pre>async fn fetch_handler(time_zone: String, dates: Dates) -&gt; Result&lt;impl Reply&gt; {
    let parsed_time_zone = time_zone.replace("%2F", "/");
    let tz: Tz = match parsed_time_zone.parse() {
        Ok(v) =&gt; v,
        Err(e) =&gt; {
            return Ok(reply::with_status(
                format!("could not parse timezone: {}", e),
                StatusCode::BAD_REQUEST,
            ))
        }
    };

    Ok(
        match serde_json::to_string(
            &amp;dates
                .read()
                .await
                .iter()
                .map(|t: &amp;DateTime&lt;Utc&gt;| t.with_timezone(&amp;tz).to_rfc3339())
                .collect::&lt;Vec&lt;_&gt;&gt;(),
        ) {
            Ok(v) =&gt; reply::with_status(v, StatusCode::OK),
            Err(e) =&gt; {
                return Ok(reply::with_status(
                    format!("could not serialize json: {}", e),
                    StatusCode::INTERNAL_SERVER_ERROR,
                ))
            }
        },
    )
}
</pre>
<p>在我们的替换策略之后，我们使用<code>.parse()</code>函数将传入的字符串解析为<code>chrono_tz::Tz</code>。如果失败，我们将返回一个错误。</p>
<p>否则，下一步是使用<code>dates.read().await</code>获取数据存储上的读锁，然后迭代向量，使用<code>.with_timezone</code>助手将日期内的UTC日期映射到给定的时区。</p>
<p>最后，我们将日期转换为RFC3339日期字符串，以与输入保持一致。然后，生成的向量被序列化为JSON并返回给用户。</p>
<p>就是这样！让我们看看它是否如我们预期的那样工作。</p>
<p>首先，使用<code>cargo run</code>运行服务器，然后使用cURL创建一个日期。</p>
<pre>curl -X POST http://localhost:8080/create -d '{"date_time": "1996-12-19T16:39:57+02:00"}' -H "content-type: application/json"
Added date with timezone: +02:00 as UTC
</pre>
<p>到目前为止，一切顺利。让我们先用UTC取它。</p>
<pre>curl http://localhost:8080/fetch/UTC
["1996-12-19T14:39:57+01:00"]
</pre>
<p>然后在另一个时区:非洲/阿尔及尔，也就是UTC+01:00。</p>
<pre>curl http://localhost:8080/fetch/Africa%2FAlgiers
["1996-12-19T15:39:57+00:00"]
</pre>
<p>非常好！我们在UTC+02:00保存了一个日期，然后用少了两个小时的UTC和少了一个小时的UTC+01:00<code>Africa/Algiers</code>获取。</p>
<p>您可以尝试不同时区的组合，从中获得乐趣。查看GitHub 上的完整示例代码。</p>
<h2 id="conclusion">结论</h2>
<p>时间和日期的处理，尤其是对于时区，是一件棘手的事情。幸运的是，Rust的生态系统为我们提供了所有需要的工具。</p>
<p>Chrono库是健壮的、完整的和广泛使用的，它们有很好的API。诸如此类的板条箱使得处理时区的技术方面不成问题。如果不考虑奇怪的API、不一致和bug，处理与日期和时间相关的实际业务问题已经够困难的了。</p><div class="code-block code-block-29">
<div class="blog-plug inline-plug rust-plug"><h2><a href="https://lp.logrocket.com/blg/rust-signup" target="_blank">log rocket</a>:Rust应用的web前端的全面可见性</h2><p>调试Rust应用程序可能很困难，尤其是当用户遇到难以重现的问题时。如果您对监控和跟踪Rust应用程序的性能、自动显示错误、跟踪缓慢的网络请求和加载时间感兴趣，</p><a href="https://lp.logrocket.com/blg/rust-signup" target="_blank">try LogRocket</a><p>. </p><a class="signup" href="https://lp.logrocket.com/blg/rust-signup" target="_blank" rel="noopener noreferrer"><img class="alignnone size-full wp-image-46 jetpack-lazy-image" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/><noscript><img data-lazy-fallback="1" class="alignnone size-full wp-image-46" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/></noscript></a><p>LogRocket 就像是网络和移动应用程序的DVR，记录你的Rust应用程序上发生的一切。您可以汇总并报告问题发生时应用程序的状态，而不是猜测问题发生的原因。LogRocket还可以监控应用的性能，报告客户端CPU负载、客户端内存使用等指标。</p><p>现代化调试Rust应用的方式— <a class="signup" href="https://lp.logrocket.com/blg/rust-signup" target="_blank" rel="noopener noreferrer">开始免费监控</a>。</p></div>


</div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
<html>
<head>
<title>Intro to Postgres + GraphQL with PostGraphile - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>Postgres + GraphQL简介</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/intro-to-postgres-graphql-with-postgraphile/#0001-01-01">https://blog.logrocket.com/intro-to-postgres-graphql-with-postgraphile/#0001-01-01</a></blockquote><div><article class="article-post">
<h2>介绍</h2>
<p><a href="https://graphql.org/" target="_blank" rel="noopener noreferrer"> GraphQL </a>是一个与服务器端数据通信的奇妙解决方案，它允许开发人员创建快速可靠的API，通过允许那些与服务器交互的人指定服务器所需数据的精确结构，来解决数据的<a href="https://stackoverflow.com/questions/44564905/what-is-over-fetching-or-under-fetching" target="_blank" rel="noopener noreferrer">过度获取和不足获取</a>的问题。这意味着为那些使用GraphQL APIs构建应用程序的人提供更好的开发人员体验，也为最终用户提供更快的应用程序。</p>
<p>PostGraphile ，以前被称为PostGraphQL，在将这两种技术结合起来方面做得很好，允许开发人员快速组装一个全功能的GraphQL服务器，在PostgreSQL数据库上存储数据。PostGraphile利用数据库驱动的开发从Postgres数据库模式生成和更新您的Graphql服务器，自动检测您对模式所做的更改，并相应地更新您的服务器。</p>
<p>用他们自己的话说:</p>
<blockquote><p>PostgreSQL已经有了惊人的授权和关系基础设施，为什么还要在自定义API中复制这种逻辑呢？</p></blockquote>
<p>PostGraphile处理高性能和符合标准的GraphQL API层的创建，允许开发人员专注于产品。这也大大减少了开发时间。</p>
<p>PostGraphile还拥有一个强大的插件系统，有几个由社区开发的插件可以帮助它以各种方式扩展功能。</p>
<p>在本文中，我们将了解如何使用PostGraphile在几分钟内启动并运行一个全功能的服务器。</p>
<h2>后图形用法</h2>
<p>PostGraphile有三种主要用途:</p>
<ul>
<li>使用PostGraphile CLI——这是直接从终端启动PostGraphile API的最简单快捷的方法。这是我们今天要讲的</li>
<li>作为中间件——这种方式将从<code>postgraphile</code>包导入的PostGraphile实例挂载到NodeJS服务器上</li>
<li>通过docker——这是通过将PostGraphile作为Docker映像提取并作为CLI选项传递给Docker容器来实现的</li>
</ul>
<h2>入门指南</h2>
<p>为了使用PostGraphile，你需要安装Node.js v8.6或更高版本，如果你还没有安装，你可以在Node <a href="https://nodejs.org/en/" target="_blank" rel="noopener noreferrer">网站</a>上找到。</p>
<p>您还需要PostgreSQL v9.6.0或更高版本，可以在PostgreSQL <a href="https://www.postgresql.org/download/" target="_blank" rel="noopener noreferrer">下载页面</a>上找到。</p>
<h2>数据库设置</h2>
<p>一旦安装了这两个组件，就需要创建数据库。首先，确保Postgres正在运行。为此，请在终端中运行以下命令:</p>
<pre>psql</pre>
<p>如果您遇到下面的错误，这可能意味着Postgres还没有运行:</p>
<pre>psql: could not connect to server: No such file or directory
        Is the server running locally and accepting
        connections on Unix domain socket "/tmp/.s.PGSQL.5432"?</pre>
<p>要解决这个问题，请启动。对于使用自制软件的mac用户，运行:</p>
<pre>brew services start postgres</pre>
<p>对于windows用户:</p>
<ul>
<li>通过<code>Winkey + R</code>打开运行窗口</li>
<li>类型<code>services.msc</code></li>
<li>基于安装的版本搜索Postgres服务</li>
<li>单击停止、启动或重新启动服务选项</li>
</ul>
<p>对于Linux用户，运行:</p>
<pre>sudo service postgresql start</pre>
<p>Postgres运行后，通过运行以下命令为您的应用程序创建一个数据库:</p>
<pre>createdb testdb</pre>
<p>这将创建一个名为“testdb”的数据库，我们将使用它来创建我们的示例API。现在，您可以使用数据库名称或URL运行<code>psql</code>来访问它，并对它运行SQL查询，对我们来说，这看起来像这样:</p>
<pre>psql testdb</pre>
<p>或者</p>
<pre>psql postgres:///testdb</pre>
<h2>安装海报</h2>
<p>通过运行以下命令，可以使用<a href="https://www.npmjs.com/" target="_blank" rel="noopener noreferrer"> npm </a>轻松地全局安装PostGraphile:</p>
<pre>npm install -g postgraphile</pre>
<p>现在您已经安装了Postgraphile，您可以通过运行以下命令来查看CLI标志:</p>
<pre>postgraphile --help</pre>
<p>要运行PostGraphile，您将使用与用于<code>psql</code>相同的URL，并添加数据库名称:</p>
<pre>postgraphile -c "postgres:///testdb"</pre>
<p>其中<code>-c</code>是连接字符串(默认为<code>postgres:///</code>)，<code>-s</code>是模式名(默认为“公共”)，<code>-a</code>启用中继支持，<code>-j</code>启用动态JSON。</p>
<p>当PostGraphile运行时，它给出两个端点:</p>

<p>第一个端点供您的应用程序与之对话，第二个端点可以在web浏览器中打开，让您通过<code>GraphiQL</code> ( <a href="https://github.com/graphql/graphiql" target="_blank" rel="noopener noreferrer">一个可视化的GraphQL explorer </a>)访问您的数据库。</p>
<p>太好了！现在我们已经设置了postgrapile，我们可以开始定义我们的数据库结构，这将反过来允许postgrapile更新我们的API。</p>
<h2>模式和表</h2>
<p>正如在<a href="https://www.postgresql.org/docs/12/ddl-schemas.html" target="_blank" rel="noopener noreferrer"> postgres文档</a>中所描述的，一个数据库包含一个或多个命名的<strong>模式</strong>或<strong>名称空间</strong>，其中包含我们存储数据的表。模式还包含其他种类的命名对象，包括数据类型、函数和运算符。相同的对象名可以在不同的模式中使用，不会产生冲突。例如，<code>schema1</code>和<code>myschema</code>都可以包含名为<code>mytable</code>的表格。与数据库不同，模式不是严格分离的。如果用户有权限，则可以访问他们所连接的数据库中的任何模式中的对象。</p>
<p>与数据库一起创建的默认模式是<code>public</code>，大多数用户只处理这个模式。在PostGraphile中，建议使用模式来帮助组织您的应用程序——您可以为将向GraphQL公开的表使用一个模式，为应该完全私有的表使用另一个模式(例如，您存储散列用户密码的地方),并且您也可以根据对您的应用程序有意义的内容使用其他模式。</p>
<p>博士后文档中提供的模式示例如下:</p>
<ul>
<li><code>app_public</code>–暴露给GraphQL的表格和函数</li>
<li><code>app_hidden</code>–与<code>app_public</code>相同的权限，但不暴露于GraphQL</li>
<li><code>app_private</code>–需要提升权限才能访问的秘密</li>
</ul>
<p>对于我们的应用程序，我们将保持简单，只需通过从Postgres CLI运行以下命令来创建我们自己的模式，我们将称之为<code>test_schema</code>:</p>
<pre>CREATE SCHEMA test_schema;</pre>
<p>一个模式可以包含几个表，例如，让我们在<code>test_schema</code>中创建两个表，一个包含作者，另一个包含这些作者发表的文章。我们将通过给出每个表的结构来做到这一点。</p>
<p><code>authors</code>表将有一个充当主键的<code>id</code>、唯一标识他们的用户名以及名、姓和简历。</p>
<p>另一方面，<code>posts</code>表将有一个作为主键的<code>id</code>，一个作为其标题的<code>headline</code>字段，一个<code>body</code>以及<code>created_at</code>。还有一个字段，这是<code>author_id</code>，它通过创建一个外键链接来引用<code>authors</code>表，这创建了一个一对多的关系，其中一个作者可以有几篇文章:</p>
<pre>CREATE TABLE test_schema.authors (
  id serial PRIMARY KEY,
  username text NOT NULL unique,
  firstname text NOT NULL,
  lastname text NOT NULL,
  bio text
);

create table test_schema.posts (
  id serial primary key,
  headline text not null,
  body text,
  -- `references` 👇  sets up the foreign key relation
  author_id int4 references test_schema.authors(id),
  created_at timestamptz NOT NULL DEFAULT now()
);</pre>
<p>现在让我们在数据库中插入一些数据。让我们创建两个用户:</p>
<pre>INSERT INTO test_schema.authors (username, firstname, lastname, bio) VALUES
('austinroy', 'Austin', 'Roy', 'Gamer, developer, blogger'),
('darthvader', 'Anakin', 'Skywalker', 'Former Jedi, Dark Lord of the Sith trying to save Padme');</pre>
<p>让我们验证数据是否已按预期输入到数据库中:</p>
<pre>SELECT * FROM test_schema.authors;</pre>
<p>结果应该显示如下所示创建的两个条目。<br/> <img data-attachment-id="13952" data-permalink="https://blog.logrocket.com/intro-to-postgres-graphql-with-postgraphile/testdb/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/02/testdb.png" data-orig-size="730,83" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="testdb" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/02/testdb-300x34.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/02/testdb.png" decoding="async" class="aligncenter wp-image-13952 size-full jetpack-lazy-image" src="../Images/bdbbddb6f832b8501a986eca978e4810.png" alt="test database" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2020/02/testdb.png 730w, https://blog.logrocket.com/wp-content/uploads/2020/02/testdb-300x34.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2020/02/testdb.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/02/testdb.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="13952" data-permalink="https://blog.logrocket.com/intro-to-postgres-graphql-with-postgraphile/testdb/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/02/testdb.png" data-orig-size="730,83" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="testdb" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/02/testdb-300x34.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/02/testdb.png" decoding="async" loading="lazy" class="aligncenter wp-image-13952 size-full" src="../Images/bdbbddb6f832b8501a986eca978e4810.png" alt="test database" srcset="https://blog.logrocket.com/wp-content/uploads/2020/02/testdb.png 730w, https://blog.logrocket.com/wp-content/uploads/2020/02/testdb-300x34.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/02/testdb.png"/></noscript>
<h2>GraphQL交互</h2>
<p>您可以使用下面显示的查询在GraphQL(服务器提供的graph QL的可视化浏览器)上查询上述数据，它应该按照预期返回数据。这可以通过将下面声明的<code>query</code>发送到<a href="http://localhost:5000/graphiql" target="_blank" rel="noopener noreferrer">http://localhost:5000/graphiql</a>上的服务器来完成，以返回保存的某些细节。</p>
<p>您可能已经注意到，在Postgres中使用<code>snake_case</code>声明的一些变量在GraphQL API中已经被转换为<code>camelCase</code>，这是此类API的标准。这是因为后缀法应用了<a href="https://www.graphile.org/postgraphile/inflection/" target="_blank" rel="noopener noreferrer">词尾变化</a>的概念，将事物映射到更自然的名字上，同时避免冲突。它还有助于命名目标类型和引用列，如<code>postsByAuthorId</code>。</p>
<pre>query {
  allAuthors{
    nodes {
      username
      firstname
      lastname
      bio
    }
  }
}</pre>
<p><img data-attachment-id="13954" data-permalink="https://blog.logrocket.com/intro-to-postgres-graphql-with-postgraphile/graphiql/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/02/graphiql.png" data-orig-size="730,440" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="graphiql" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/02/graphiql-300x181.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/02/graphiql.png" decoding="async" class="aligncenter wp-image-13954 size-full jetpack-lazy-image" src="../Images/4db22d508a36a9d3f0be8204ac785f46.png" alt="graphiql example" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2020/02/graphiql.png 730w, https://blog.logrocket.com/wp-content/uploads/2020/02/graphiql-300x181.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2020/02/graphiql.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/02/graphiql.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="13954" data-permalink="https://blog.logrocket.com/intro-to-postgres-graphql-with-postgraphile/graphiql/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/02/graphiql.png" data-orig-size="730,440" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="graphiql" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/02/graphiql-300x181.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/02/graphiql.png" decoding="async" loading="lazy" class="aligncenter wp-image-13954 size-full" src="../Images/4db22d508a36a9d3f0be8204ac785f46.png" alt="graphiql example" srcset="https://blog.logrocket.com/wp-content/uploads/2020/02/graphiql.png 730w, https://blog.logrocket.com/wp-content/uploads/2020/02/graphiql-300x181.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/02/graphiql.png"/></noscript>
<p>就这样，我们在Postgres数据库上建立并运行了一个完整的GraphQL服务器。为了利用我们的服务器，让我们使用GraphiQL来创建我们的第一篇文章。我们将通过执行PostGraphile为我们生成的createPost <code>Mutation</code>来实现这一点。</p>
<p>首先，我们需要在GraphiQL中定义我们的查询，它看起来像这样:</p>
<pre>mutation createPost($input: CreatePostInput!){
  createPost(input: $input){
    post{
      headline
      body
      createdAt
    }
  }
}</pre>
<p>这利用提供的<code>input</code>来创建一个新的帖子，并从帖子中返回选定的字段。我选择返回文章标题、正文和创建时间，忽略ID。您可以通过将值包含在变异中来选择想要返回的值。</p>
<p>您可能想知道<code>input</code>在哪里被传递给上面的突变。我们将在当前隐藏的<strong>查询变量</strong>部分分别声明它们。要打开它，只需点击屏幕底部的<strong>查询变量</strong>面板，并输入以下代码:</p>
<pre>{
  "input":
          {
      "post": {
        "headline": "Obi Wan",
        "body": "Hello There",
        "authorId": 1
      }
    }
}</pre>
<p>带有作为输入传递的变量的对象应该以JSON格式声明，不带任何尾随逗号，以避免被GraphiQL无效，GraphiQL会执行它自己的检查。</p>
<p>这是它在你的浏览器中的样子。</p>
<p><img data-attachment-id="13957" data-permalink="https://blog.logrocket.com/intro-to-postgres-graphql-with-postgraphile/queryvariables/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/02/queryvariables.png" data-orig-size="730,438" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="queryvariables" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/02/queryvariables-300x180.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/02/queryvariables.png" decoding="async" class="aligncenter wp-image-13957 size-full jetpack-lazy-image" src="../Images/7192d6d0f77f7a57813957a33bd5e746.png" alt="" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2020/02/queryvariables.png 730w, https://blog.logrocket.com/wp-content/uploads/2020/02/queryvariables-300x180.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2020/02/queryvariables.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/02/queryvariables.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="13957" data-permalink="https://blog.logrocket.com/intro-to-postgres-graphql-with-postgraphile/queryvariables/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/02/queryvariables.png" data-orig-size="730,438" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="queryvariables" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/02/queryvariables-300x180.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/02/queryvariables.png" decoding="async" loading="lazy" class="aligncenter wp-image-13957 size-full" src="../Images/7192d6d0f77f7a57813957a33bd5e746.png" alt="" srcset="https://blog.logrocket.com/wp-content/uploads/2020/02/queryvariables.png 730w, https://blog.logrocket.com/wp-content/uploads/2020/02/queryvariables-300x180.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/02/queryvariables.png"/></noscript>
<p>这些只是PostGraphile从我们提供的数据库模式中为我们生成的几个<code>Queries</code>和<code>Mutations</code>中的两个。其中包括:</p>
<ul>
<li><code>allAuthors</code>–通过一组<code>Author</code>(获取所有作者的所有数据的GraphQL对象类型)读取并启用分页</li>
<li><code>allPosts</code>–通过一组<code>Posts</code>(获取所有作者的所有数据的GraphQL对象类型)读取并启用分页</li>
<li><code>authorByUsername</code>–返回与给定用户名匹配的<code>Author</code></li>
<li><code>author</code>–返回与给定的<code>id</code>匹配的<code>Author</code></li>
<li><code>post</code>–返回与给定的<code>id</code>匹配的<code>Post</code></li>
<li><code>createAuthor</code>–根据给定的有效载荷创建一个<code>Author</code></li>
<li><code>updateAuthor</code>–如果有匹配的<code>id</code>，则从给定的有效载荷更新一个<code>Author</code></li>
<li><code>deleteAuthor</code>–如果有匹配的<code>id</code>，则从给定的有效载荷中删除一个<code>Author</code></li>
<li><code>createPost</code>–根据给定的有效载荷创建一个<code>Post</code></li>
<li><code>updatePost</code>–如果有匹配的<code>id</code>，则从给定的有效载荷更新一个<code>Post</code></li>
<li><code>deletePost</code>–如果有匹配的<code>id</code>，则从给定的有效载荷中删除一个<code>Post</code></li>
</ul>
<p>除了处理您可能需要的大多数CRUD功能之外，PostGraphile还记录了大多数GraphQL类型(查询和变化)的用法，使得生成的API对于任何希望使用它的人来说都非常容易使用。</p>
<h2>带有智能注释的文档</h2>
<p>您可能已经注意到了数据类型，即作者和帖子尚未记录。这可以通过使用智能注释来快速修复。为了说明这一点，让我们添加一些文档来解释我们的<code>authors</code>表。</p>
<p>要向我们的<code>authors</code>表添加注释，在Postgres中运行以下命令:</p>
<pre>COMMENT ON TABLE test_schema.authors IS 'Author on the platform';</pre>
<p>当你检查GraphiQL中的<code>Author</code>类型时，它从“无描述”变成了“平台上的作者”，如这张截图所示。</p>
<p><img data-attachment-id="13960" data-permalink="https://blog.logrocket.com/intro-to-postgres-graphql-with-postgraphile/documentationwithcomments/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/02/documentationwithcomments.png" data-orig-size="351,727" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="documentationwithcomments" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/02/documentationwithcomments-145x300.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/02/documentationwithcomments.png" decoding="async" class="aligncenter wp-image-13960 size-full jetpack-lazy-image" src="../Images/b10f9294d546c529bb5dd94cbeb7349a.png" alt="documentation with smart comments" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2020/02/documentationwithcomments.png 351w, https://blog.logrocket.com/wp-content/uploads/2020/02/documentationwithcomments-145x300.png 145w" data-lazy-sizes="(max-width: 351px) 100vw, 351px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2020/02/documentationwithcomments.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/02/documentationwithcomments.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="13960" data-permalink="https://blog.logrocket.com/intro-to-postgres-graphql-with-postgraphile/documentationwithcomments/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/02/documentationwithcomments.png" data-orig-size="351,727" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="documentationwithcomments" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/02/documentationwithcomments-145x300.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/02/documentationwithcomments.png" decoding="async" loading="lazy" class="aligncenter wp-image-13960 size-full" src="../Images/b10f9294d546c529bb5dd94cbeb7349a.png" alt="documentation with smart comments" srcset="https://blog.logrocket.com/wp-content/uploads/2020/02/documentationwithcomments.png 351w, https://blog.logrocket.com/wp-content/uploads/2020/02/documentationwithcomments-145x300.png 145w" sizes="(max-width: 351px) 100vw, 351px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/02/documentationwithcomments.png"/></noscript>
<h2>结论</h2>
<p>PostGraphile是一个强大的工具，它可以帮助开发人员快速、轻松地建立在PostgreSQL数据库上运行的功能全面且健壮的GraphQL APIs。这使他们能够构建快速可靠的API，运行在安全稳定的数据库上，具有几个强大的特性。它也是一个非常容易使用的工具，可以大大加快这些API的开发时间，让开发人员专注于解决问题，而不是设置应用程序。本文只涵盖了PostGraphile必须提供的众多功能的一个子集，您可以通过查看完整的<a href="https://www.graphile.org/postgraphile/" target="_blank" rel="noopener noreferrer">文档</a>来了解更多。</p><div class="code-block code-block-24">
<div class="blog-plug inline-plug graphql-plug"><h2>监控生产中失败和缓慢的GraphQL请求</h2><p>虽然GraphQL有一些调试请求和响应的特性，但确保GraphQL可靠地为您的生产应用程序提供资源是一件比较困难的事情。如果您对确保对后端或第三方服务的网络请求成功感兴趣，</p><a href="https://lp.logrocket.com/blg/graphql-signup" target="_blank">try LogRocket</a><p>.</p><a class="signup" href="https://lp.logrocket.com/blg/graphql-signup" target="_blank" rel="noopener noreferrer"><img src="../Images/432a3823c85b3fb72a206e6236a29f48.png" data-lazy-src="https://files.readme.io/69aa835-Image_2019-11-09_at_1.28.05_PM.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" class=" jetpack-lazy-image" data-original-src="https://files.readme.io/69aa835-Image_2019-11-09_at_1.28.05_PM.png"/><noscript><img data-lazy-fallback="1" src="../Images/432a3823c85b3fb72a206e6236a29f48.png" data-original-src="https://files.readme.io/69aa835-Image_2019-11-09_at_1.28.05_PM.png"/></noscript><img class="alignnone size-full wp-image-46 jetpack-lazy-image" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/><noscript><img data-lazy-fallback="1" class="alignnone size-full wp-image-46" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/></noscript></a><a href="https://lp.logrocket.com/blg/graphql-signup" target="_blank" rel="noopener noreferrer">https://logrocket.com/signup/</a><p>LogRocket 就像是网络和移动应用的DVR，记录下你网站上发生的每一件事。您可以汇总并报告有问题的GraphQL请求，以快速了解根本原因，而不是猜测问题发生的原因。此外，您可以跟踪Apollo客户机状态并检查GraphQL查询的键值对。</p><p>LogRocket检测您的应用程序以记录基线性能计时，如页面加载时间、到达第一个字节的时间、慢速网络请求，还记录Redux、NgRx和Vuex操作/状态。</p><a class="signup" href="https://lp.logrocket.com/blg/graphql-signup" target="_blank" rel="noopener noreferrer">Start monitoring for free</a><p>.</p></div>


</div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
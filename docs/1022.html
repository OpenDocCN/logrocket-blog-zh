<html>
<head>
<title>Emotion in React - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>React - LogRocket博客中的情感</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/emotion-in-react/#0001-01-01">https://blog.logrocket.com/emotion-in-react/#0001-01-01</a></blockquote><div><article class="article-post">
<p>CSS-in-JS是解决CSS问题和设计现代应用程序时常用的概念。当开始一个新项目时，决定使用哪个CSS-in-JS库可能很棘手。</p>
<p>我们经常遇到的一个问题是，大多数时候，我们构建的应用程序会被很多人使用。一个应用程序可以迅速扩展到数百万用户，这取决于它的成功，如果为您的项目选择了错误的CSS-in-JS库，将来可能会付出巨大的代价。</p>
<p>CSS-in-JS库的生态系统每天都在变得越来越好，库变得越来越成熟和健壮，新的特性和支持正在被添加，曾经很难解决的问题变得越来越容易。</p>
<p>Emotion是这些CSS-in-JS库中较为成熟和一致的一个，<a href="https://github.com/emotion-js/emotion/graphs/contributors" target="_blank" rel="noopener noreferrer">这要归功于整个社区的参与</a>。在这篇文章中，我们将学习更多关于情感的知识，并了解它给我们的应用程序带来的特性和优势。</p>
<h2>情绪</h2>
<p>Emotion是一个高性能、灵活、高性能的CSS-in-JS库。Emotion帮助我们以更快的方式设计我们的应用程序，使用一个体面和一致的CSS组合。</p>
<p>以下是情感的一些特征。</p>
<h2>表演</h2>
<p>Emotion是一个真正的表演库，因为它使用了来自一个名为<a href="https://github.com/threepointone/glam" target="_blank" rel="noopener noreferrer"> glam </a>的库的哲学。其理念是在不牺牲运行时成本的情况下获得最佳的运行时性能。</p>
<p>结果是一个超级快速和小型的库，非常适合原型和设计系统。有了情感，对象可以在任何地方使用，并且很容易与数组组合。</p>
<h2>框架不可知</h2>
<p>Emotion是一个与框架无关的库，这意味着它可以在不同的框架和库中使用。你可以用同样强大的API和特性在任何地方使用它。这不是情感独有的东西，我们还有其他一些框架不可知的CSS-in-JS库。然而，在不同的项目中重用情感的想法很吸引人，因为，例如，你可以仅仅使用情感来构建一个支持网络和移动的完整设计系统。</p>
<p>Emotion有一个名为<code>@emotion/native</code>的包，是为React Native本身准备的，所以开发者不需要在web上使用Emotion，在mobile上使用另一个CSS-in-JS库。</p>
<p>要开始使用Emotion设计React原生应用，您只需安装软件包:</p>
<pre>yarn add @emotion/core @emotion/native</pre>
<h2>没有额外设置</h2>
<p>Emotion无需额外设置即可开始使用。它支持嵌套选择器、媒体查询和自动供应商前缀。它真的是可组合的，非常适合原型开发，你可以只使用<code>CSS</code>函数和<code>cx</code>来组合你的应用程序中的所有东西。</p>
<p>要开始使用Emotion，您只需安装软件包:</p>
<pre>yarn add emotion</pre>
<p>现在，您可以使用情感创建您的第一个样式化组件了:</p>
<pre>import { css, cx } from 'emotion'

render(
  &lt;div
    className={css`
      padding: 10px;
      background-color: red;
      font-size: 16px;
      border-radius: 6px;
    `}
  &gt;
    Emotion CSS-in-JS
  &lt;/div&gt;
)</pre>
<p>Emotion在某些方面仍然不同于其他著名的库，如styled-components和Radium。让我们来了解一下Emotion与其他CSS-in-JS库的区别，以及是什么让它如此高性能和灵活。</p>
<h2>式样</h2>
<p>有不同的情感包，它们是为不同的用例而创建的。当在一个应用程序中使用Emotion时，你需要知道这些包之间的区别，这样你就不会安装超过你需要的东西和增加你的包的大小。</p>
<p><code>emotion</code>包是框架不可知的，所以如果你决定在其他不使用React的应用程序中使用Emotion，这是适合你的包:</p>
<pre>yarn add emotion</pre>
<p><code>@emotion/core</code>包需要React，所以如果您在React应用程序中使用情感，这是一个合适的包:</p>
<pre>yarn add @emotion/core</pre>
<h2>CSS prop</h2>
<p>与其他著名的CSS-in-JS库相比，我们注意到的第一个区别是样式。使用情感设计组件的主要方法是使用<code>CSS</code>道具。</p>
<p>prop允许我们将样式直接应用到组件或元素上，而不必创建一个样式化的组件。有两种方法可以正确使用<code>CSS</code>道具。</p>
<p>首先，如果你在一个项目中工作，你能够配置一个定制的babel配置，你必须在你的<code>.babelrc</code>中使用<code>@emotion/babel-preset-css-prop</code>:</p>
<pre> {
  "presets": ["@emotion/babel-preset-css-prop"]
}</pre>
<p>如果您正在使用一些样板文件或启动程序，如<a href="https://github.com/facebook/create-react-app" target="_blank" rel="noopener noreferrer"> create-react-app </a>，您可能无法配置自定义的babel配置，您将需要使用第二个选项，JSX杂注。</p>
<p>你所要做的就是在使用CSS prop的文件顶部使用JSX杂注，并从<code>@emotion/core</code>导入<code>jsx</code>，就像这样:</p>
<pre>/** @jsx jsx */
import { jsx } from '@emotion/core'</pre>
<p>JSX杂注基本上是一段代码，告诉巴别塔插件使用<code>jsx</code>函数而不是<code>React.createElement</code>。</p>
<p>现在，您可以在文件的任何元素中使用<code>CSS</code> prop:</p>
<pre>/** @jsx jsx */
import { jsx } from '@emotion/core'
import React from "react";
const Header = () =&gt; {
  return (
    &lt;header&gt;
      &lt;h3 css={{ color: 'lightgreen'}}&gt;Hello World!&lt;/h3&gt;
    &lt;/header&gt;
  )
};</pre>
<p><code>CSS</code>道具的一个很好的特性是，通过使用一个接受主题作为<code>CSS</code>道具的函数，我们可以默认访问主题:</p>
<pre>/** @jsx jsx */
import { jsx } from '@emotion/core'
import React from "react";
const Header = () =&gt; {
  return (
   &lt;header&gt;
     &lt;h3 css={theme =&gt; ({ color: theme.color.primary}) }&gt;Hello World!&lt;/h3&gt;
   &lt;/header&gt;
  )
};</pre>
<h2>风格API</h2>
<p>现在很多人都在使用样式组件，另一个著名的CSS-in-JS库。他们可能会错过的一个功能是<code>styled.div</code>风格的API，这就是为什么Emotion有一个名为<code>@emotion/styled</code>的包。</p>
<p>要使用这种风格的API，我们所要做的就是使用以下命令安装<code>@emotion/styled</code>包:</p>
<pre>yarn add @emotion/styled</pre>
<p>现在我们可以使用样式API结合模板文字非常容易地创建样式:</p>
<pre>import styled from '@emotion/styled';

const Button = styled.button`
  width: 100px;
  height: 40px;
  background-color: black;
  color: white;
`;</pre>
<h2>主题</h2>
<p>Emotion也支持主题化，要使用它，我们需要做的就是安装<code>emotion-theming</code>包:</p>
<pre>yarn add emotion-theming</pre>
<p><code>emotion-theming</code>包提供了<code>ThemeProvider</code>，我们应该将这个提供者添加到我们应用程序的顶层，然后我们就可以使用<code>props.theme</code>访问样式化组件中的主题:</p>
<pre>import { ThemeProvider } from 'emotion-theming';

const theme = {
  colors: {
    primary: 'black',
    secondary: 'blue'
  },
  breakpoints: {
    sm: 380,
    md: 720,
  }
}

const App = () =&gt; {
  return (
    &lt;ThemeProvider theme={theme}&gt;
      ...
    &lt;/ThemeProvider&gt;
  )
}</pre>
<h2>媒体查询</h2>
<p>使用情感处理媒体查询很简单。例如，假设我们有一个断点数组:</p>
<pre>const breakpoints = [576, 768, 992, 1200];</pre>
<p>我们可以创建一个助手函数来返回我们想要的断点，就像这样:</p>
<pre>const mq = (n) =&gt; `@media (min-width: ${breakpoints[n]}px)`;</pre>
<p>现在，在我们的样式化组件中，我们简单地使用我们的<code>mq</code>助手函数并传递我们想要的媒体查询:</p>
<pre> const Text = styled.h3`
  font-size: 16px;
  color: black;
  font-family: Inter;
  ${mq(1)} {
    color: green;
  }
  ${mq(2)} {
    color: hotpink;
  }
`;</pre>
<h2>默认SSR</h2>
<p>服务器端渲染是一种流行的技术，如果你使用的是<code>@emotion/core</code>和<code>@emotion/styled</code>包，它可以带着情感开箱即用。</p>
<p>默认的方法是使用React中的<code>renderToString</code>,它将在元素上方插入一个<code>&lt;style&gt;</code>标签:</p>
<pre>import { renderToString } from 'react-dom/server'
import App from './App'

let html = renderToString(&lt;App /&gt;)</pre>
<p>高级方法只是以防你需要使用<code>nth child</code>或类似的选择器，因为默认方法不是最好的。它需要多几行代码，但它工作得很好。</p>
<p>在您的服务器中，放置以下代码:</p>
<pre>import { CacheProvider } from '@emotion/core'
import { renderToString } from 'react-dom/server'
import createEmotionServer from 'create-emotion-server'
import createCache from '@emotion/cache'

const cache = createCache()
const { extractCritical } = createEmotionServer(cache)

let element = (
  &lt;CacheProvider value={cache}&gt;
    &lt;App /&gt;
  &lt;/CacheProvider&gt;
)

let { html, css, ids } = extractCritical(renderToString(element))

res
  .status(200)
  .header('Content-Type', 'text/html')
  .send(`&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;
    &lt;meta charset="UTF-8"&gt;
    &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;
    &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt;
    &lt;title&gt;My site&lt;/title&gt;
    &lt;style data-emotion-css="${ids.join(' ')}"&gt;${css}&lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div id="root"&gt;${html}&lt;/div&gt;

    &lt;script src="./bundle.js"&gt;&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;`);</pre>
<p>现在，在客户端，您需要做的是:</p>
<pre>const cache = createCache();

ReactDOM.hydrate(
  &lt;CacheProvider value={cache}&gt;
    &lt;App /&gt;
  &lt;/CacheProvider&gt;,
  document.getElementById('root')
);</pre>
<h2>我应该用情感吗？</h2>
<p>与其他库(如styled-components)相比，Emotion是一个真正高性能且一致的CSS-in-JS库。这两个库之间有很多内容和比较，说<a href="https://medium.com/@tkh44/emotion-ad1c45c6d28b" target="_blank" rel="noopener noreferrer"> Emotion比styled-components快25倍</a>等等。即使去年发布了styled-components v5，Emotion仍然比styled-components有一点优势，因为它的包更小，运行时间更快。除了性能和运行时，两个库都有<a href="https://spectrum.chat/styled-components/general/emotion-vs-styled-components~706ff9c8-f06d-4433-a42c-cc158d385089" target="_blank" rel="noopener noreferrer">几乎相同的功能和特性</a>。</p>
<p>那么，该不该用情感呢？这个问题没有确切的答案，因为它取决于很多因素。</p><div class="code-block code-block-54">
<hr/>
<h3>更多来自LogRocket的精彩文章:</h3>

<hr/></div>
<p>如果这是你第一次使用CSS-in-JS库，你可能想从样式组件开始。为了更好地理解CSS-in-JS，styled-components将更好地为您服务，并有助于理解CSS-in-JS的基本概念以及它如何在实际项目中工作。社区提供了大量的内容，你可以很快了解CSS-in-JS。</p>
<p>你以前用过CSS-in-JS库，并且正在寻找一个更小更快的库吗？我会带着感情走。如果您习惯于在项目中使用CSS-in-JS库，那么您会确切地知道如何以及何时使用它。Emotion真的可以帮助你进入下一个层次，使用CSS-in-JS构建更具性能和可伸缩性的应用程序。</p>
<h2>结论</h2>
<p>在本文中，我们了解了更多关于Emotion的内容，这是一个强大的、高性能的CSS-in-JS库，它有很多不错的特性。我们学习了情感的核心，我们使用了道具，并学习了主题化。</p><div class="code-block code-block-17">
<div class="blog-plug inline-plug react-plug" vwo-el-id="26283398190">
<h2 vwo-el-id="41600691720">使用LogRocket消除传统反应错误报告的噪音</h2>
<a href="https://lp.logrocket.com/blg/react-signup-issue-free" target="_blank" vwo-el-id="19356441070">LogRocket
</a><p>是一款React analytics解决方案，可保护您免受数百个误报错误警报的影响，只针对少数真正重要的项目。LogRocket告诉您React应用程序中实际影响用户的最具影响力的bug和UX问题。</p><a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="19356441380">
<img class="first-react-image alignnone size-full wp-image-46 jetpack-lazy-image jetpack-lazy-image--handled" src="../Images/f300c244a1a1cf916df8b4cb02bec6c6.png" vwo-el-id="18272717540" data-lazy-loaded="1" data-original-src="https://files.readme.io/27c94e7-Image_2017-06-05_at_9.46.04_PM.png"/>
</a>
<a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="19356441690">
<img class="second-react-image alignnone size-full wp-image-46 jetpack-lazy-image jetpack-lazy-image--handled" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" vwo-el-id="30720362350" data-lazy-loaded="1" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/>
</a>
<a href="https://lp.logrocket.com/blg/react-signup-issue-free" target="_blank" rel="noopener noreferrer" vwo-el-id="35866400580">LogRocket
</a><p>自动聚合客户端错误、反应错误边界、还原状态、缓慢的组件加载时间、JS异常、前端性能指标和用户交互。然后，LogRocket使用机器学习来通知您影响大多数用户的最具影响力的问题，并提供您修复它所需的上下文。</p><p vwo-el-id="28675661060">关注重要的React bug—<a class="signup" href="https://lp.logrocket.com/blg/react-signup-issue-free" target="_blank" rel="noopener noreferrer" vwo-el-id="40093418840">今天就试试LogRocket】。</a></p>
</div></div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
<html>
<head>
<title>What’s new in TypeScript 4.0 - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>TypeScript 4.0中的新特性- LogRocket博客</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/whats-new-in-typescript-4-0/#0001-01-01">https://blog.logrocket.com/whats-new-in-typescript-4-0/#0001-01-01</a></blockquote><div><article class="article-post">
<p>TypeScript 4.0是TypeScript编程语言的一个重要里程碑，目前已经超越3.9成为最新的稳定版本。在这篇文章中，我们将看看TypeScript 4.0提供的新特性。</p>
<h2>入门指南</h2>
<p>要开始使用4.0，您可以通过NuGet 或通过NPM安装它<a href="https://www.nuget.org/packages/Microsoft.TypeScript.MSBuild/4.0.0-beta" target="_blank" rel="noopener noreferrer">:</a></p>
<pre>npm i typescript</pre>
<p>您可以使用<a href="https://www.typescriptlang.org/play?ts=4.0.0-beta" target="_blank" rel="noopener noreferrer"> TypeScript playground </a>或支持TypeScript的文本编辑器来测试代码。我推荐使用<a href="https://marketplace.visualstudio.com/items?itemName=TypeScriptTeam.TypeScript-40beta" target="_blank" rel="noopener noreferrer">的Visual Studio代码</a>，你可以在这里得到设置<a href="https://code.visualstudio.com/Docs/languages/typescript#_using-newer-typescript-versions" target="_blank" rel="noopener noreferrer">的说明</a>。</p>
<h2>特征</h2>
<h3>可变元组类型</h3>
<p>简而言之，我们可以说TypeScript是强类型JavaScript。这意味着它要求开发人员准确地指定他们的数据类型的格式，因此，它允许编译器在编译时捕捉类型错误，从而提供更好的开发人员体验。</p>
<blockquote><p>这种精确指定数据类型格式的过程称为类型声明或类型定义，也称为类型化或简单类型。</p></blockquote>
<p>利用这个特性，TypeScript将类型赋予高阶函数，如<code>curry</code>、<code>concat</code>和<code>apply</code>。这些函数采用可变数量的参数。</p>
<p>考虑下面的<code>concat</code>函数的一个小例子:</p>
<pre>function simpleConcat(arr1, arr2) {
  return [...arr1, ...arr2];
}
console.log(simpleConcat([1,2,3], [5,6])) // [1, 2, 3, 5, 6]</pre>
<p>目前没有简单的方法在TypeScript中键入它。目前唯一可用的类型策略是编写重载。</p>
<blockquote><p><a href="https://www.typescriptlang.org/docs/handbook/functions.html#overloads" target="_blank" rel="noopener noreferrer">函数或方法重载</a>指的是TypeScript中的一个特性，它允许我们创建多个同名但参数或类型数量不同的函数。</p></blockquote>
<p>考虑一下这个:</p>
<pre>function concat1&lt;T&gt;(arr1: [T], arr2: []): [T] {
    return [...arr1, ...arr2]
}
function concat2&lt;T1, T2&gt;(arr1: [T1, T2], arr2: []): [T1, T2] {
    return [...arr1, ...arr2]
};
function concat6&lt;T1, T2, T3, T4, T5, T6&gt;(arr1: [T1, T2, T3, T4, T5, T6], arr2: []): [T1, T2, T3, T4, T5, T6] {
    return [...arr1, ...arr2]
}
function concat7&lt;T1, T2, T3, T4, T5, T6, A1, A2, A3, A4&gt;(arr1: [T1, T2, T3, T4, T5, T6], arr2: [A1, A2, A3, A4]): [T1, T2, T3, T4, T5, T6, A1, A2, A3, A4] {
    return [...arr1, ...arr2]
}
console.log("concated 1", concat1([1], []))
console.log("concated 2", concat2([1,2], []))
console.log("concated 6", concat6([1,2,3,4,5,6], []))
console.log("concated 10", concat10([1,2,3,4,5,6], [10, 11, 12, 13]))</pre>
<p>从上面的例子中我们可以看到，重载的数量随着数组中项目数量的增加而增加，这是次优的。在<code>concat6</code>中，即使第二个数组为空，我们也不得不编写6个重载，而在<code>concat10</code>中，当第二个数组只有4个元素时，这很快就增加了10个重载。</p>
<p>此外，我们只能为我们编写的重载获取正确的类型。</p>
<p>TypeScript 4.0带来了显著的推理改进。它允许元组类型中的spread元素是通用的，并且可以出现在元组中的任何位置。</p>
<p>在旧版本中，REST元素必须是元组类型中的最后一个。如果不是这样，TypeScript将抛出一个错误:</p>
<pre>// Tuple speard items are generic
function concatNumbers&lt;T extends Number[]&gt;(arr: readonly [Number, ...T]) {
  // return something
}

// spread occuring anywhere in the tuble valid in 4.0 beta.
type Name = [string, string];
type ID = [number, number];
type DevTuples = [...Name, ...Numbers]</pre>
<p>有了这两个补充，我们可以为我们的<code>concat</code>函数编写一个更好的函数签名:</p>
<pre>type Arr = readonly any[];
function typedConcat&lt;T extends Arr, U extends Arr&gt;(arr1: T, arr2: U): [...T, ...U] {
    return [...arr1, ...arr2];
}
console.log("concated", typedConcat([1,2,3,4,5], [66,77,88,99]))
</pre>
<h3>标记元组元素</h3>
<p>这是对TypeScript的一个简洁的补充，旨在提高代码的可读性。</p>
<p>考虑下面的代码:</p>
<pre>type Period = [Date, Date]; // Example 1 older version

type Period = [StartDate: Date, EndDate: Date]; // Example 2 4.0 beta

function getAge(): [birthDay: Date, today: Date] {
  // ...
}</pre>
<p>以前，TypeScript开发人员使用注释来描述元组，因为类型本身(日期、数字、字符串)不足以描述元素所代表的内容。</p>
<p>从我们上面的小例子来看，“例2”可读性更好，因为在元组中添加了标签。</p>
<blockquote><p>当标记元组时，必须标记元组中的所有项目。</p></blockquote>
<p>考虑下面的代码:</p>
<pre>type Period = [startDate: Date, Date]; // incorrect
type Period = [StartDate: Date, EndDate: Date]; // correct</pre>
<h3>从构造函数推断类属性</h3>
<p>在TypeScript 4.0中，当<code>noImplicitAny</code>被启用时，我们现在可以使用控制流分析来确定类中属性的类型。让我们用一些代码示例来详细说明这一点。</p>
<p>考虑下面的代码:</p>
<pre>// Compile with --noImplicitAny
class CalArea {
    Square;  // string | number
    constructor(area: boolean, length: number, breadth: number) {
        if (!area) {
            this.Square = "No area available";
        }
        else {
            this.Square = length * breadth;
        }
    }
}</pre>
<p>以前，如果启用了<code>noImplicitAny</code>，上面的代码将无法编译。这是因为属性类型只能从直接初始化中推断出来，所以它们的类型必须要么显式定义，要么使用初始初始化器。</p>
<p>但是TypeScript 4.0可以使用构造函数中<code>this.Square</code>赋值的控制流分析来确定<code>Square</code>的类型。</p>
<h3>短路赋值运算符</h3>
<p>目前，在JavaScript中，许多二元运算符可以与赋值运算符组合在一起，形成复合赋值运算符。这些运算符对两个操作数执行二元运算符的运算，并将值赋给左操作数:</p>
<pre>// compound operators
foo += bar // foo = foo + bar
foo -= bar // foo = foo - bar
foo *= bar // foo = foo * bar
foo /= bar // foo = foo/bar
foo %= bar // foo = foo % bar</pre>
<p>这份清单还在继续，但有三个例外:</p>
<pre>|| // logical or operator
&amp;&amp; // logical and operator
?? // nullish coalescing operator</pre>
<p>TypeScript 4.0 beta允许我们将这三个运算符与赋值运算符结合起来，从而形成三个新的复合运算符:</p>
<pre>x ||= y // x || (x = y)
x &amp;&amp;= y // x &amp;&amp; (x = y)
x ??= y // x ?? (x = y )</pre>
<h3><code>unknown</code>上的<code>catch</code>子句绑定</h3>
<p>以前，当我们在TypeScript中使用<code>try … catch</code>语句时，catch子句总是被类型化为<code>any</code>，因此，我们的错误处理代码缺乏任何类型安全，这应该可以防止无效操作。我将在下面详细介绍一些代码示例:</p>
<pre>try {
  // ...
}catch(error) {
  error.message
  error.toUpperCase()
  error.toFixed()
  // ...
}</pre>
<p>从上面的代码中我们可以看到，我们被允许做任何我们想做的事情——这实际上是我们不想要的。</p>
<p>TypeScript 4.0旨在通过允许我们将catch变量的类型设置为<code>unknown</code>来解决这个问题。这更安全，因为这意味着提醒我们在代码中进行手动类型检查:</p>
<pre> try {
  // ...
}catch(error: unknown) {
  if(typeof error === "String") {
    error.toUpperCase()
  }

  if(typeof error === "number") {
    error.toFixed()
  }
  // ...
}</pre>
<h2>定制JSX工厂</h2>
<p>TypeScript已经支持<code>jsxFactory</code>编译器选项，但是，这个特性添加了一个新的编译器选项，称为<code>jsxFragmentFactory</code>，它使用户能够在<code>tsconfig.json</code>中定制React.js片段工厂:</p>
<pre>{
  "compilerOptions": {
    "target": "esnext",
    "module": "commonjs",
    "jsx": "react", // React jsx compiler option
    "jsxFactory": "createElement", // transforms jsx using createElement
    "jsxFragmentFactory": "Fragment" // transforms jsx using Fragment
  }
}</pre>
<p>上面的<code>tsconfig.json</code>配置以一种与React兼容的方式转换<code>JSX</code>，因此像<code>&lt;article /&gt;</code>这样的<code>JSX</code>片段将会用<code>createElement</code>而不是<code>React.createElement</code>来转换。此外，它告诉TypeScript使用<code>Fragment</code>而不是<code>React.Fragment</code>进行<code>JSX</code>转换。</p>
<h2>值得注意的提及</h2>
<p>TypeScript 4.0还在<code>--build</code>模式场景中提供了巨大的性能改进，并允许我们在利用<code>--incremental</code>编译的同时使用<code>--noEmit</code>标志。这在旧版本中是可能的。</p>
<p>此外，还有一些编辑器改进，如<code>@deprecated</code> JSDoc注释识别，更智能的自动导入，启动时的部分编辑模式(旨在加快启动时间)。</p>
<h2>结论</h2>
<p>TypeScript 4.0于8月18日发布，所有这些令人兴奋的功能和改进都随之推出。毫无疑问，这些将改善开发人员的体验和使用TypeScript的效率。你可以在这里找到更多关于4.0 <a href="https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-0.html" target="_blank" rel="noopener noreferrer">的细节。</a></p><div class="code-block code-block-21">
<div class="blog-plug inline-plug typescript-plug"><h2><a class="signup" href="https://lp.logrocket.com/blg/typescript-signup" target="_blank" rel="noopener noreferrer"> LogRocket </a>:全面了解您的网络和移动应用</h2>
<a href="https://lp.logrocket.com/blg/typescript-signup" class="signup" target="_blank" rel="noopener noreferrer"><img class="alignnone size-full wp-image-46 jetpack-lazy-image" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/><noscript><img data-lazy-fallback="1" class="alignnone size-full wp-image-46" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/></noscript></a>
<p>LogRocket 是一个前端应用程序监控解决方案，可以让您回放问题，就像问题发生在您自己的浏览器中一样。LogRocket不需要猜测错误发生的原因，也不需要向用户询问截图和日志转储，而是让您重放会话以快速了解哪里出错了。它可以与任何应用程序完美配合，不管是什么框架，并且有插件可以记录来自Redux、Vuex和@ngrx/store的额外上下文。</p>
<p>除了记录Redux操作和状态，LogRocket还记录控制台日志、JavaScript错误、堆栈跟踪、带有头+正文的网络请求/响应、浏览器元数据和自定义日志。它还使用DOM来记录页面上的HTML和CSS，甚至为最复杂的单页面和移动应用程序重新创建像素级完美视频。</p>
<a class="signup" href="https://lp.logrocket.com/blg/typescript-signup" target="_blank" rel="noopener noreferrer">Try it for free</a><p>.</p></div>
</div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
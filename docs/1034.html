<html>
<head>
<title>CSS variables: Scoping - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>CSS变量:作用域- LogRocket博客</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/css-variables-scoping/#0001-01-01">https://blog.logrocket.com/css-variables-scoping/#0001-01-01</a></blockquote><div><article class="article-post">
<p>我们可以像在其他编程语言中声明变量一样在CSS中声明变量。</p>
<p>我们在CSS中声明一个被赋值的变量。然后可以在CSS规则集中使用该变量。</p>
<p>例如，在JavaScript中，我们使用关键字<code>let</code>、<code>var</code>和<code>const</code>来声明变量:</p>
<pre>let nine = 9;
var ten = 10;
var eight = 8;</pre>
<p>然后，我们通过引用它们的变量名来使用它们:</p>
<pre>&gt;&gt; nine
9
&gt;&gt;  ten
10
&gt;&gt; eight 
8</pre>
<p>我们也可以在CSS中这样做。要在CSS中声明变量，我们使用以下格式:</p>
<pre>--varName</pre>
<p>在CSS中，它看起来像这样:</p>
<pre>body {
    --mainColor: limegreen;
}</pre>
<p>假设我们声明了一个名为<code>--mainColor</code>值为<code>limegreen</code>的变量。这个变量包含一个颜色名称。</p>
<p>为了使用CSS中的变量，我们使用<code>var()</code>:</p>
<pre>var(--varName);</pre>
<p><code>var</code>将检索传递给它的变量的值，并用值替换它本身:</p>
<pre>body {
    --mainColor: limegreen;
}

div {
    color: var(--mainColor);
}</pre>
<p>这里，<code>div</code>使用<code>var</code>函数消耗<code>mainColor</code>变量。<code>var</code>将从<code>--mainColor</code>中检索值<code>limegreen</code>，并用<code>--mainColor</code>变量的值<code>limegreen</code>代替自己。</p>
<p>因此,<code>div</code>元素中文本节点的颜色将是浅绿色。换句话说，CSS代码将转换为:</p>
<pre>body {
    --mainColor: limegreen;
}

div {
    color: limegreen;
}</pre>
<h2>辖域</h2>
<p>CSS层次结构中声明CSS变量的位置将决定它在整个层次结构的较低级别中的可见性级别。</p>
<p>在整个页面中使用的CSS变量在<code>:root</code>伪选择器或<code>html</code>选择器中声明。</p>
<p>这是因为页面上的所有元素都包含在一个HTML元素中，所以在HTML元素或其<code>:root</code>选择器中声明的CSS变量对于其子元素的使用是可见的。</p>
<p><code>:root</code>是附加到文档中HTML元素根的伪选择器。在RSS文档中，<code>:root</code>元素被附加到RSS元素上。</p>
<p>通常，CSS变量仅对声明它的父元素的子元素可见。</p>
<p>现在，我们有了这个:</p>
<pre>&lt;body&gt;
    &lt;div&gt;Div 1&lt;/div&gt;
    &lt;div&gt;Div 2&lt;/div&gt;
&lt;/body&gt;</pre>
<p><code>body</code>元素是其子元素<code>div</code>、<code>Div 1</code>和<code>Div 2</code>的父元素。</p>
<p>所以这是可行的:</p>
<pre>body {
    --bgColor: limegreen;
}

div {
    background: var(--bgColor);
}</pre>
<p>CSS变量<code>bgColor</code>在body元素中声明，并在<code>div</code>中使用，以将div元素的背景设置为浅绿色。</p>
<p>这对我们的两个div元素是可见的，因为它们是body元素的子元素，body元素是声明它所使用的CSS变量的地方。</p>
<p>现在，如果反过来是正确的:</p>
<pre>body {
    background: var(--bgColor);
}

div {
    --bgColor: limegreen;
}

&lt;body&gt;
    &lt;div&gt;Div 1&lt;/div&gt;
    &lt;div&gt;Div 2&lt;/div&gt;
&lt;/body&gt;</pre>
<p><code>--bgColor</code>变量在div元素中声明，在body元素中使用。现在，body元素位于div元素之上，所以body元素看不到<code>--bgColor</code>变量。因此，主体元素的背景不会变成石灰绿色。</p>
<p>在这种情况下，<code>--bgColor</code>变量对于div元素下面的元素是可见的:</p>
<pre>body {
    background: var(--bgColor);
}

div {
    --bgColor: limegreen;
}

p {
    background: var(--bgColor);
}

&lt;body&gt;
    &lt;div&gt;Div 1
        &lt;p&gt;Paragraph 1&lt;/p&gt;
    &lt;/div&gt;
    &lt;div&gt;Div 2
        &lt;p&gt;Paragraph 2&lt;/p&gt;
    &lt;/div&gt;
&lt;/body&gt;
</pre>
<p><code>--bgColor</code>变量将对<code>p</code>元素可见，因为它们是<code>div</code>的子元素。</p>
<p>我们在这里可以看到CSS变量的可见性依赖于一种父子关系。子元素在其父元素的范围内，因此它可以在父元素的范围内使用CSS变量声明。</p>
<p>主题化是用CSS变量完成的，主题化通常会传播整个DOM树，所以CSS变量通常设置在<code>html</code>元素或<code>:root</code>元素中。这是因为没有元素放在HTML元素之外:</p>
<pre>:root {
    --bgColor: lightcoral;
    --mainColor: limegreen;
    --borderColor: seagreen;
}</pre>
<p>在极少数情况下，当我们想要使用CSS变量来主题化DOM树的一部分或DOM分支时，我们将在DOM分支的根元素中设置CSS变量，这样它将沿着分支树向下传播。</p>
<pre>&lt;html&gt;
    &lt;body&gt;
        &lt;div class="branch"&gt;
            &lt;p&gt;
                Paragraph 1
            &lt;/p&gt;
        &lt;/div&gt;
        &lt;p&gt;
            Paragraph 2
        &lt;/p&gt;
    &lt;/body&gt;
&lt;/html&gt;
```
```css
.branch {
    --brBgColor: palevioletred;
    --brMainColor: blueviolet;
}

p {
    background: var(--brBgColor);
    color: var(--brMainColor);
}</pre>
<p>在<code>div.branch</code>中声明的CSS变量对于<code>p</code>元素<code>Paragraph 1</code>将是可见的，因为它是<code>div</code>的子元素，类名为<code>branch</code>。背景颜色和文本颜色将分别被涂成<code>palevioletred</code>和<code>blueviolet</code>颜色。</p>
<p>元素<code>Paragraph 2</code>不会受到样式的影响，因为CSS变量<code>--brBgColor</code> <code>--brMainColor</code>对它来说是不可见的。这是因为它不是<code>div.branch</code>的子元素。</p>
<p>这就是CSS变量的作用域。</p>
<h3>全球范围</h3>
<p>在<code>:root</code>选择器中声明的CSS变量被认为是在全局范围内。这意味着可以在CSSOM中的任何地方访问它们。</p>
<p>为什么有效？</p><div class="code-block code-block-54">
<hr/>
<h3>更多来自LogRocket的精彩文章:</h3>

<hr/></div>
<p>就像我们之前了解到的一样，<code>:root</code>选择器附加在文档的根目录下。web文档中的所有元素都在根文档下，所以在<code>:root</code>中声明的CSS变量将级联到文档的所有级别。或者，文档中的所有元素都可以看到声明的CSS变量。</p>
<h3>局部范围</h3>
<p>就像在<code>:root</code>选择器中一样，CSS变量也可以在CSSOM层次结构的所有级别或特定的选择器中声明。</p>
<p>现在，在这些级别或选择器中声明的CSS变量只对选择器及其子节点是可见的或局部的。</p>
<h3>提升</h3>
<p>CSS变量被提升，并且在浏览器中呈现相应HTML元素的样式之前，它们被移动到CSSOM的顶部。</p>
<p>就像在JavaScript中，CSS变量是可以被吊起来的。这意味着CSS变量可以在声明之前使用。</p>
<pre>var num2 = 90

var add = num1 + num2

var num1 = 10

log(add)</pre>
<p>在上面的例子中，<code>num1</code>变量在声明之前就被使用了。也就是说<code>num1</code>被吊起来了。运行代码时，add将记录100。尽管在声明之前首先被使用，JavaScript仍然能够获得值并执行操作。</p>
<p>CSS变量也是如此:</p>
<pre>body {
    background-color: var(--bgColor);
}

:root {
    --bgColor: rgb(221, 221, 221);
}</pre>
<p>如您所见，CSS变量<code>--bgColor</code>在被声明到<code>:root</code>伪选择器之前就被使用了。代码运行得非常好！</p>
<p>所以，CSS变量可以先访问，后声明。这使得CSS变量成为一个非常强大的特性。</p>
<h2>检查支持</h2>
<p>CSS变量在主流浏览器中得到广泛支持，尽管在Chrome和Firefox的旧版本中可能缺乏支持。IE和Edge对CSS变量的支持正在进行中。</p>
<p>因为不是所有的浏览器都支持CSS变量，所以我们可以使用<code>@supports</code>来检测CSS变量特性支持。</p>
<pre>@supports(--bgColor: rgb(221, 221, 221)) {

}</pre>
<p>第二个选项是设置回退值:</p>
<pre>:root {
    --primaryColor: blue;
}

button {
    color: blue;
    color: var(--primaryColor);
}</pre>
<p>我们在带有颜色<code>blue</code>的<code>:root</code>选择器中设置了一个<code>--primaryColor</code>变量。然而，我们不确定运行CSS的浏览器是否支持CSS变量。为了让代码工作，我们在按钮选择器中添加了一个回退值。这确保了按钮在不支持CSS变量的浏览器中使用我们的原色。</p>
<h2>使用CSS变量的优势</h2>
<h3>主题</h3>
<p>CSS变量作用域改进了我们在CSS中添加和修改主题的方式。有了CSS变量，CSS中的主题化就不需要额外的不同主题的样式表了。相反，你需要做的就是更新CSS变量。</p>
<h3><strong>造型</strong></h3>
<blockquote><p>利用CSS变量范围改进了样式表的大小、特异性和语义。</p></blockquote>
<p>假设我们有一个按钮:</p>
<pre>button {
    padding: 10px 5px;
}</pre>
<p>具有不同的按钮样式:</p>
<pre>.btn-danger {
    background-color: orange;
}

.btn-success {
    background-color: lightblue;
}</pre>
<p>有了CSS变量，我们不必在每个按钮样式中都定义<code>background-color</code>。</p>
<pre>button {
    --btnBgColor: blue;
    padding: 10px 5px;
    background-color: var(--btnBgColor);
}

.btn-danger {
    --btnBgColor: orange;
}

.btn-success {
    --btnBgColor: lightblue;
}</pre>
<p>我们简单地在每个按钮样式中分配新的值。我们不再需要覆盖基本样式。</p>
<p>看到了吗？CSS变量非常强大，作用域特性使它们成为简洁、模块化设计系统的理想工具。</p>
<h2>结论</h2>
<p>我们今天刚刚处理了CSS中的一个潜在错误。</p>
<p>正如我们在JavaScript和其他语言中有作用域一样，在CSS变量中也是如此。我们已经看到了CSS变量的一个主要应用:主题化。它能给我们提供更多的东西。</p>
<p>如果你对此有任何问题，或者我应该添加，纠正或删除的任何内容，请随时评论，发电子邮件或发短信给我。</p><div class="code-block code-block-25">
<div class="blog-plug inline-plug css-plug"><h2>你的前端是否占用了用户的CPU？</h2><p>随着web前端变得越来越复杂，资源贪婪的特性对浏览器的要求越来越高。如果您对监控和跟踪生产环境中所有用户的客户端CPU使用、内存使用等感兴趣，</p><a target="_blank" href="https://lp.logrocket.com/blg/css-signup">try LogRocket</a><p>.</p><a class="signup" href="https://lp.logrocket.com/blg/css-signup" target="_blank" rel="noopener noreferrer"><img class="alignnone size-full wp-image-46 jetpack-lazy-image" src="../Images/dacb06c713aec161ffeaffae5bd048cd.png" alt="LogRocket Dashboard Free Trial Banner" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2019/12/cpu-memory-usage.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/12/cpu-memory-usage.png"/><noscript><img data-lazy-fallback="1" class="alignnone size-full wp-image-46" src="../Images/dacb06c713aec161ffeaffae5bd048cd.png" alt="LogRocket Dashboard Free Trial Banner" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/12/cpu-memory-usage.png"/></noscript></a><a href="https://lp.logrocket.com/blg/css-signup" target="_blank" rel="noopener noreferrer">https://logrocket.com/signup/</a><p>LogRocket 就像是网络和移动应用的DVR，记录你的网络应用或网站上发生的一切。您可以汇总和报告关键的前端性能指标，重放用户会话和应用程序状态，记录网络请求，并自动显示所有错误，而不是猜测问题发生的原因。</p><p>现代化您调试web和移动应用的方式— <a class="signup" href="https://lp.logrocket.com/blg/css-signup" target="_blank" rel="noopener noreferrer">开始免费监控</a>。</p></div>
</div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
<html>
<head>
<title>Cache invalidation strategies using IndexedDB in Angular 2+ - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>Angular 2+ - LogRocket博客中使用IndexedDB的缓存失效策略</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/cache-invalidation-strategies-using-indexeddb-in-angular-2/#0001-01-01">https://blog.logrocket.com/cache-invalidation-strategies-using-indexeddb-in-angular-2/#0001-01-01</a></blockquote><div><article class="article-post">
<p>创建离线优先的web应用程序不是一项简单的任务。需要考虑的因素很多(超出了一篇文章所能涵盖的范围)，并且存在许多潜在的陷阱。然而，关于在用户的浏览器中存储数据，需要考虑两个非常重要的问题:在哪里存储数据，以及如何确保数据不会过时。</p>
<p>假设您的任务是构建一个销售点(POS)应用程序，该应用程序需要能够在网络连接不良的地区运行。缓存产品信息、客户和购买数据需要大量的规划。你如何设计你的应用程序，使其具有低网络占用空间？您将数据存储在哪里，以确保在无法访问网络的情况下可以访问这些数据？您如何确保运行该应用程序的所有设备都使用相同的数据集？</p>
<h2>存储选项</h2>
<p>在web开发领域，客户端缓存数据并不是一个新概念。<a href="https://developer.mozilla.org/en-US/docs/Web/API/Web_Storage_API" target="_blank" rel="noreferrer noopener" aria-label=" (opens in a new tab)"> HTML Web存储</a>从2009年开始所有主流浏览器都支持，一些前端框架内置了缓存机制。</p>
<p><a href="https://rxjs.dev/" target="_blank" rel="noreferrer noopener" aria-label=" (opens in a new tab)"> RxJS库</a>有两个操作符可以用来缓存HTTP调用:<code><a href="https://rxjs.dev/api/operators/publishReplay" target="_blank" rel="noreferrer noopener" aria-label=" (opens in a new tab)">publishReplay()</a></code>和<code><a href="https://rxjs.dev/api/operators/refCount" target="_blank" rel="noreferrer noopener" aria-label="refCount() (opens in a new tab)">refCount()</a></code>。使用这两个操作符来缓存从一个可观察对象最后发出的值是在Angular中实现缓存的一种廉价而快速的方法，特别是如果您的数据不经常改变的话。如果您的数据经常更改，或者您的应用程序需要完全支持离线，您会希望使用浏览器存储。</p>
<p>由于其易用性和成熟性，<a href="https://developer.mozilla.org/en-US/docs/Web/API/Window/localStorage" target="_blank" rel="noreferrer noopener" aria-label=" (opens in a new tab)"> localStorage API </a>是一个诱人的候选。然而，它也有缺点。在大多数浏览器中，你只能存储大约5MB的数据。对于许多场景来说，这已经足够了，但是如果您计划开发一个离线优先的应用程序，您很快就会发现自己已经达到了这个极限。它还是同步的，这意味着如果您不断地访问localStorage API，页面上的其余JS将需要等待操作完成。使用localStorage作为主要的客户端数据存储机制来开发离线优先的渐进式web应用程序是一场艰苦的战斗。</p>
<p>幸运的是，我们有<a href="https://developer.mozilla.org/en-US/docs/Web/API/IndexedDB_API" target="_blank" rel="noreferrer noopener" aria-label=" (opens in a new tab)"> IndexedDB </a>。IndexedDB是一个异步的客户端NoSQL存储，目前被超过90%的用户浏览器所支持。在Chrome、Firefox和Edge中，IndexedDB的存储配额是根据可用磁盘空间确定的，在某些情况下，还会根据卷大小进行分层。在所有现代浏览器中，存储限制至少是50MB，所以可以放心地假设您将能够存储比localStorage提供的5MB更多的内容。在许多情况下(尤其是在桌面设备上)，存储千兆字节的数据是可能的。</p>
<p>与任何技术一样，IndexedDB也有一些缺点。这个API相当笨重，而且不像localStorage那么简单。</p>
<p>下面是一个非常基本的例子，说明如何使用IndexedDB API创建一个事务并插入一个项目。</p>
<pre class="wp-block-preformatted">function insertIntoDB() {&#13;
    // Create a product to be inserted into the database&#13;
    var products = [&#13;
      { id: 1, name: 'T-Shirt', price: 10 }&#13;
    ];&#13;
&#13;
    // Create a transaction for inserting into the DB&#13;
    var transaction = db.transaction(["products"], "readwrite");&#13;
    var objectStore = transaction.objectStore("products");&#13;
    &#13;
    // Finally add the item. This returns an IDBRequest object&#13;
    var objectStoreRequest = objectStore.add(products[0]);&#13;
    &#13;
    objectStoreRequest.onsuccess = function(event) {&#13;
      // Success callback&#13;
    };&#13;
&#13;
    objectStoreRequest.onerror = function(event) {&#13;
      // Error callback&#13;
    };&#13;
};</pre>
<p>这个例子假设您已经创建了数据库，并定义了模式，这本身就是一个复杂的过程。</p>
<p>不幸的是，处理默认IndexedDB API所需的工作可能会让许多开发人员感到厌烦，并导致他们为了localStorage诱人的易用性而牺牲可伸缩性和性能。我不怪他们，除非你想困在回调地狱，否则我会建议避免默认的IndexedDB API。</p>
<p>如果你正在使用Angular2+,你很有可能想要使用RxJS Observables来管理你的异步任务(比如IndexedDB存储和检索)。幸运的是，有一些很棒的Angular2+库对IndexedDB进行了改进，为它提供了一个类似于localStorage的API，但具有异步客户端存储的优势。尤其是，<code><a href="https://github.com/cyrilletuzi/angular-async-local-storage" target="_blank" rel="noreferrer noopener" aria-label=" (opens in a new tab)">@ngx-pwa/local-storage</a></code>是一个很棒的Angular应用程序库。这个API非常简单，它内置了对RxJS Observables的支持。</p>
<p>下面是一个使用<code>@ngx-pwa/local-storage</code>将项目保存到IndexedDB的示例:</p>
<pre class="wp-block-preformatted">// Notice how the API looks just like localStorage. Simple, and familiar.&#13;
this.localStorage.setItem('products', products).subscribe(() =&gt; {});&#13;
&#13;
// ...and it can be simplified even further with auto-subscription:&#13;
this.localStorage.setItemSubscribe('products', products);</pre>
<p>界面更加简洁，不需要使用回调、设置事务或管理数据库。</p>
<h2>保持数据新鲜(缓存失效)</h2>
<p>假设您已经决定使用IndexedDB，下一个关键的决定将是如何确保您的缓存数据保持最新。每当用户执行一个动作时，您可以按需发出HTTP请求，但是这有损于整体用户体验。你最终会使用更多的带宽，当你受到用户网络的支配时，不可能保证一致的用户体验。</p>
<p>缓存失效绝不是一个容易解决的挑战。菲尔·卡尔顿(Phil Karlton)的名言(尽管是开玩笑的)是有原因的:</p>
<blockquote class="wp-block-quote"><p>"计算机科学中只有两个难题:缓存失效和命名事物."</p></blockquote>
<p>下面提出的每个策略都有缺点和权衡。如果你的应用程序在线时，你的用户需要获得最新的数据，那么你要为此付出代价。</p>
<p>您存储的数据类型以及数据生命周期的具体环境也会影响您选择的策略。就本文而言，我们将使用销售点(POS) web应用程序的理论场景，该应用程序在用户的浏览器中缓存可销售的产品。</p>
<h3><strong>轮询</strong></h3>
<p>轮询是最简单的缓存失效策略之一，可以通过多种方式实现。有两种主要的轮询类型–短轮询和长轮询。在我看来，服务器发送的事件或WebSockets几乎总是长轮询技术的更好替代方案。对于本文，我们将只讨论短轮询。然而，如果您有兴趣学习更多关于长轮询技术的知识，我建议从<a href="https://en.wikipedia.org/wiki/Comet_(programming)" target="_blank" rel="noreferrer noopener" aria-label=" (opens in a new tab)"> Comet </a>及其包含的策略开始。</p>
<p>一个简单的短轮询示例检索要在POS应用程序上显示和缓存的产品列表，如下所示:</p>
<pre class="wp-block-preformatted">import { HttpClient } from '@angular/common/http';&#13;
import { Injectable } from '@angular/core';&#13;
import { Observable, interval } from 'rxjs';&#13;
import { map, tap, concatMap } from 'rxjs/operators';&#13;
import { LocalStorage } from '@ngx-pwa/local-storage';&#13;
&#13;
interface Product { &#13;
  id: number, &#13;
  name: string, &#13;
  price: number &#13;
} &#13;
&#13;
@Injectable({&#13;
  providedIn: 'root'&#13;
})&#13;
export class PollingService {&#13;
  private api = 'http://localhost:3000';&#13;
  &#13;
  constructor(&#13;
    private http: HttpClient,&#13;
    private localStorage: LocalStorage&#13;
  ) {}&#13;
  &#13;
  public poll(): void {&#13;
    interval(10000) // Poll every 10s&#13;
      .pipe(&#13;
        // concatMap ensures that each request completes before the next one begins.&#13;
        // Use of concatMap becomes increasingly important as your polling frequency goes up.&#13;
        concatMap(() =&gt; this.updateCache())&#13;
      ).subscribe();&#13;
  }&#13;
  &#13;
  private updateCache(): Observable&lt;Product[]&gt; {&#13;
    return this.localStorage.getItem&lt;any&gt;('products').pipe(&#13;
      concatMap(() =&gt; {&#13;
        return this.getProducts().pipe(&#13;
          tap(products =&gt; {&#13;
            if (products.length) {&#13;
              // This will set a Product[] in IndexedDB with a key of 'products'&#13;
              this.localStorage.setItemSubscribe('products', products);&#13;
            }&#13;
          }),&#13;
          map(products =&gt; {&#13;
            return products;&#13;
          })&#13;
        );&#13;
      })&#13;
    );&#13;
  }&#13;
  &#13;
  private getProducts(): Observable&lt;Product[]&gt; {&#13;
    return this.http.get&lt;Product[]&gt;(`${this.api}/products`)&#13;
      .pipe(&#13;
        map(products =&gt; {&#13;
          return products;&#13;
        }),&#13;
      );&#13;
  }&#13;
}</pre>
<p>该服务包含三个功能:<code>poll()</code>、<code>updateCache()</code>和<code>getProducts()</code>。<code>poll()</code>函数每十秒钟调用一次<code>updateCache()</code>，然后触发对服务器的HTTP请求。如果数据被返回，那么它被存储在IndexedDB中。</p>
<p>短轮询有一些缺点。每当没有新数据要检索时，任何HTTP请求都是浪费带宽。在实际场景中，每十秒钟轮询一次“list”端点也会给数据库带来不必要的压力。有一些方法可以帮助提高轮询的效率，但是它们涉及到后端基础设施的改变。我不会深入探讨，但是通过使用<code>updatedAt</code>时间戳，您可以在轮询时潜在地减少数据库的负载。</p>
<p>假设我们的<code>/products</code>端点返回给我们这样的对象:</p>
<pre class="wp-block-preformatted">[&#13;
  { "id": 1, "name": "T-Shirt", "price": 10, "updatedAt": "2019-04-23T18:25:43.511Z"},&#13;
  { "id": 2, "name": "Mug", "price": 5, "updatedAt": "2018-04-23T19:22:13.601Z"}&#13;
]</pre>
<p>我们可以使用<code>updatedAt</code>属性来告诉服务器我们拥有的数据版本。在上面的<code>PollingService</code>示例中的<code>getProducts()</code>函数中，我们可以传递IndexedDB中最近的<code>updatedAt</code>时间戳，作为HTTP请求中的URL参数。</p>
<p>在后端，您可以简单地运行一个查询来找出最后一个产品是何时添加或修改的:</p>
<pre class="wp-block-preformatted">SELECT TOP 1 updatedAt&#13;
FROM products&#13;
ORDER BY updatedAt DESC</pre>
<p>如果来自客户端的时间戳与来自查询的时间戳不同，那么显然产品已经被添加、删除或修改，我们应该运行一个查询来获取所有产品。如果时间戳与查询中的时间戳匹配，那么我们可以简单地向客户端返回一个特殊的响应，指定缓存是最新的。</p>
<p>这种时间戳策略还可以与服务器发送的事件和WebSockets结合使用，以确保数据在网络连接丢失后保持新鲜。</p>
<p>然而，我们对时间戳策略做了一个大的假设。我们假设检查时间戳所需的时间远远少于从后端数据库列出所有产品所需的时间。根据您的数据库、索引和总体后端基础设施的不同，差异可能可以忽略不计。</p>
<h3>服务器发送的事件</h3>
<p>服务器发送事件(SSE) API是一种HTML规范，用于从服务器向客户端单向发送数据，它经常被WebSockets忽略和掩盖。与WebSockets相比，SSE最大的吸引力在于它的易用性。与WebSockets不同，SSE是通过HTTP协议传输的，带有一种特殊的MIME类型<code>text/event-stream</code>。因此，使用您现有的服务器基础设施来实现SSE是非常容易的。不幸的是，任何版本的Internet Explorer或Edge都不支持T2。然而，有<a href="https://github.com/Yaffle/EventSource" target="_blank" rel="noreferrer noopener" aria-label=" (opens in a new tab)">多填充物</a>可用。</p>
<p>从Angular内部处理SSE非常简单。每个事件都有一个<code>type</code>和<code>data</code>。对于我们的例子，我们希望在产品被添加、更新或删除时得到通知。我们的假设是后端为每一个发送不同类型的事件。因此，我们为每种类型的事件附加一个侦听器:</p>
<pre class="wp-block-preformatted">import { Injectable } from '@angular/core';&#13;
import { LocalStorage } from '@ngx-pwa/local-storage';&#13;
&#13;
interface Product { &#13;
  id: number, &#13;
  name: string, &#13;
  price: number &#13;
} &#13;
&#13;
@Injectable({&#13;
  providedIn: 'root'&#13;
})&#13;
export class ServerSentEventService {&#13;
  private api = 'http://localhost:3000/stream';&#13;
  private eventSource: EventSource;&#13;
  &#13;
  constructor(&#13;
    private localStorage: LocalStorage&#13;
  ) {&#13;
    this.eventSource = new EventSource(this.api);&#13;
  }&#13;
  &#13;
  public listen(): void {&#13;
    this.eventSource.addEventListener('productAdd', (message: MessageEvent) =&gt; this.addProductToCache(message));&#13;
    this.eventSource.addEventListener('productUpdate', (message: MessageEvent) =&gt; this.updateProductInCache(message));&#13;
    this.eventSource.addEventListener('productDelete', (message: MessageEvent) =&gt; this.deleteProductFromCache(message));&#13;
  }&#13;
  &#13;
  ...&#13;
}</pre>
<p>我们已经设置了侦听器，所以现在我们需要做的就是更新我们的缓存。当事件被触发时，根据事件的类型，监听器的一个回调函数将被触发。当接收到一个<code>productAdd</code>事件时，我们只想将来自<code>MessageEvent</code>的产品对象附加到我们当前的IndexedDB缓存中。同样，对于<code>productUpdate</code>和<code>productDelete</code>，我们希望从我们的IndexedDB数据库中检索项目，并进行必要的调整。</p>
<p>下面是一个在收到SSE时从IndexedDB中添加、更新或删除项目所需的实现的工作示例。</p>
<pre class="wp-block-preformatted">import { Injectable } from '@angular/core';&#13;
import { LocalStorage } from '@ngx-pwa/local-storage';&#13;
&#13;
interface Product { &#13;
  id: number, &#13;
  name: string, &#13;
  price: number &#13;
} &#13;
&#13;
@Injectable({&#13;
  providedIn: 'root'&#13;
})&#13;
export class ServerSentEventService {&#13;
  private api = 'http://localhost:3000/stream';&#13;
  private eventSource: EventSource;&#13;
  &#13;
  constructor(&#13;
    private localStorage: LocalStorage&#13;
  ) {&#13;
    this.eventSource = new EventSource(this.api);&#13;
  }&#13;
  &#13;
  public listen(): void {&#13;
    this.eventSource.addEventListener('productAdd', (message: MessageEvent) =&gt; this.addProductToCache(message));&#13;
    this.eventSource.addEventListener('productUpdate', (message: MessageEvent) =&gt; this.updateProductInCache(message));&#13;
    this.eventSource.addEventListener('productDelete', (message: MessageEvent) =&gt; this.deleteProductFromCache(message));&#13;
  }&#13;
  &#13;
  private addProductToCache(eventMessage: MessageEvent): void {&#13;
    this.localStorage.getItem&lt;Product[]&gt;('products').subscribe((products: Product[]) =&gt; {&#13;
      products = products || []; &#13;
      let eventMessageProduct: Product = JSON.parse(eventMessage.data);&#13;
      products.push(eventMessageProduct);&#13;
&#13;
      this.localStorage.setItemSubscribe('products', products);&#13;
    });&#13;
  }&#13;
  &#13;
  private updateProductInCache(eventMessage: MessageEvent): void {&#13;
    this.localStorage.getItem&lt;Product[]&gt;('products').subscribe((products: Product[]) =&gt; {&#13;
      let eventMessageProduct: Product = JSON.parse(eventMessage.data);&#13;
      let productIndex = products.findIndex((product =&gt; product.id === eventMessageProduct.id));&#13;
      products[productIndex] = eventMessageProduct;&#13;
&#13;
      this.localStorage.setItemSubscribe('products', products);&#13;
    });&#13;
  }&#13;
  &#13;
  private deleteProductFromCache(eventMessage: MessageEvent): void {&#13;
    this.localStorage.getItem&lt;Product[]&gt;('products').subscribe((products: Product[]) =&gt; {&#13;
      let eventMessageProduct: Product = JSON.parse(eventMessage.data);&#13;
      products = products.filter(item =&gt; item.id !== eventMessageProduct.id)&#13;
&#13;
      this.localStorage.setItemSubscribe('products', products);&#13;
    });&#13;
  }&#13;
}</pre>
<p>如您所见，在所有场景中，我们从IndexedDB数据库中加载现有产品，并对数组中的对象进行调整。在每种情况下，这些操作后面都有一个<code>setItem</code>。</p><div class="code-block code-block-54">
<hr/>
<h3>更多来自LogRocket的精彩文章:</h3>

<hr/></div>
<p>然而，这种策略有一个明显的缺陷。如果客户端的internet连接丢失，或者与服务器的连接终止，我们如何知道在重新连接时数据不会过时？</p>
<p>重新连接到事件流是微不足道的(在一些浏览器中会自动发生)，但总有可能会错过一些事件。这对于SSE和WebSockets都是一个警告，每当应用程序重新获得网络连接时，都需要使用缓存刷新(例如，使用轮询部分中描述的时间戳)。要检测网络连接状态，您可以使用<code><a href="https://developer.mozilla.org/en-US/docs/Web/API/NavigatorOnLine/onLine" target="_blank" rel="noreferrer noopener" aria-label=" (opens in a new tab)">navigator.onLine</a></code>属性。</p>
<p>除了在互联网连接断开时刷新缓存之外，每当用户在您的应用程序上启动新会话时(例如，用户登录)，您都需要强制刷新缓存。</p>
<h3>websocket</h3>
<p>与服务器发送的事件类似，WebSockets (WS)允许数据从服务器实时传输到客户端。然而，WebSocket协议允许双向数据传输——也就是说，数据可以通过同一连接从客户端传输到服务器。IE和MS Edge都支持WebSockets，这使得它成为SSE的一个很好的替代品。</p>
<p>然而，有一个问题。WebSockets使用自己的协议，而不是HTTP，所以要利用WebSockets，您需要设置一个服务器来处理WebSocket协议。</p>
<p>除此之外，建立一个监听传入消息的WebSocket连接相当简单。</p>
<pre class="wp-block-preformatted">import { Injectable } from '@angular/core';&#13;
import { webSocket, WebSocketSubject } from "rxjs/webSocket";&#13;
import { LocalStorage } from '@ngx-pwa/local-storage';&#13;
&#13;
interface Product { &#13;
  id: number, &#13;
  name: string, &#13;
  price: number &#13;
} &#13;
&#13;
interface Message {&#13;
  action: string,&#13;
  data: Product&#13;
}&#13;
&#13;
@Injectable({&#13;
  providedIn: 'root'&#13;
})&#13;
export class WebSocketService {&#13;
  private api = 'ws://localhost:3000/echo';&#13;
  private subject: WebSocketSubject&lt;string&gt;;&#13;
&#13;
  constructor(&#13;
    private localStorage: LocalStorage&#13;
  ) {}&#13;
  &#13;
  public connect(): void {&#13;
    this.subject = webSocket(this.api);&#13;
    this.subject.subscribe(&#13;
      message =&gt; this.dispatchMessage(message)&#13;
    );&#13;
  }&#13;
  &#13;
  private dispatchMessage(message: string): void {&#13;
    let parsedMessage: Message = JSON.parse(message);&#13;
    switch(parsedMessage.action) {&#13;
      case 'add':&#13;
        this.addProductToCache(parsedMessage);&#13;
      case 'update':&#13;
        this.updateProductInCache(parsedMessage);&#13;
      case 'delete':&#13;
        this.deleteProductFromCache(parsedMessage);&#13;
    }&#13;
  }&#13;
  ...&#13;
}</pre>
<p>与SSE不同，通过WebSockets接收的消息没有<code>type</code>属性。WebSocket消息只是一个字符串值，没有额外的元数据。因为有多种可能的操作，我们需要扩展从服务器发送的JSON对象，以包含所需的操作(例如，添加、更新或删除)。对此的另一个解决方案是为每种类型的操作打开一个到不同端点的连接。</p>
<p>我们在示例顶部通过接口定义的<code>Message</code>类型有这个额外的<code>action</code>参数。然后,<code>dispatchMessage()</code>函数可以使用它来决定对包含数据的缓存执行什么操作。此时，每个添加、更新和删除函数的逻辑在功能上仍然与SSE示例中的相同。</p>
<p>与我们的SSE示例类似，每当应用程序上线时，无论是在初次登录时，还是在网络中断后，WebSockets都需要与信息的初始获取一起使用。</p>
<h2>结论</h2>
<p>在本文中，我们探讨了渐进式web应用程序的客户端数据存储位置，以及保持数据新鲜的缓存失效策略。</p>
<p>IndexedDB是客户端存储的一个很好的解决方案，它可以通过使用第三方库得到增强，这些库为存储和检索提供了更干净的API。</p>
<p>有多种工具可用于更新客户端缓存，但是(不频繁的)轮询与可以将数据从服务器实时推送到客户端的技术(服务器发送的事件或WebSockets)相结合，可以确保缓存尽快更新，同时最大限度地减少不必要的网络开销。</p><div class="code-block code-block-19">
<div class="blog-plug inline-plug angular-plug"><h2>像用户一样体验Angular应用程序</h2><p>调试Angular应用程序可能很困难，尤其是当用户遇到难以重现的问题时。如果您对监视和跟踪生产中所有用户的角度状态和动作感兴趣，</p><a href="https://lp.logrocket.com/blg/angular-signup">try LogRocket</a><p>. </p><a class="signup" href="https://lp.logrocket.com/blg/angular-signup" target="_blank" rel="noopener noreferrer"><img class="alignnone size-full wp-image-46 jetpack-lazy-image" src="../Images/2794ac39244976f37c4941d9a910be23.png" alt="LogRocket Dashboard Free Trial Banner" data-lazy-src="https://files.readme.io/610d6a7-687474703a2f2f692e696d6775722e636f6d2f696147547837412e706e67.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://files.readme.io/610d6a7-687474703a2f2f692e696d6775722e636f6d2f696147547837412e706e67.png"/><noscript><img data-lazy-fallback="1" class="alignnone size-full wp-image-46" src="../Images/2794ac39244976f37c4941d9a910be23.png" alt="LogRocket Dashboard Free Trial Banner" data-original-src="https://files.readme.io/610d6a7-687474703a2f2f692e696d6775722e636f6d2f696147547837412e706e67.png"/></noscript></a><a href="https://lp.logrocket.com/blg/angular-signup" target="_blank" rel="noopener noreferrer">https://logrocket.com/signup/</a><p>LogRocket 就像是网络和移动应用程序的DVR，记录你网站上发生的一切，包括网络请求、JavaScript错误等等。您可以汇总并报告问题发生时应用程序的状态，而不是猜测问题发生的原因。</p><p>LogRocket NgRx插件将角度状态和动作记录到LogRocket控制台，为您提供导致错误的环境，以及出现问题时应用程序的状态。</p><p>现代化调试Angular应用的方式- <a class="signup" href="https://lp.logrocket.com/blg/angular-signup" target="_blank" rel="noopener noreferrer">开始免费监控</a>。</p></div>
</div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
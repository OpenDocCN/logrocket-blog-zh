<html>
<head>
<title>How React Hooks can replace React Router - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>React钩子如何取代React路由器</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/how-react-hooks-can-replace-react-router/#0001-01-01">https://blog.logrocket.com/how-react-hooks-can-replace-react-router/#0001-01-01</a></blockquote><div><article class="article-post">
<p><em> <strong>编者按</strong>:这个React Hooks和React Router教程最后一次更新是在2021年2月10日，更新了过时的信息，包括了React Router的新信息。</em></p>
<p>自从<a href="https://blog.logrocket.com/frustrations-with-react-hooks/" target="_blank" rel="noopener noreferrer"> React Hooks </a>的出现，很多事情都变了。一些我们以前没有争议的事情已经开始引起关注。钩子带来的特性和可能性重新定义了我们在React中处理某些概念的方式，路由恰好是其中之一。</p>
<p>在我们继续之前，我想提一下这篇文章并不是以任何方式攻击React路由器或者贬低它的重要性。相反，我们将探索其他可能性，看看我们如何使用钩子来改善React应用程序中的路由体验。</p>
<p>为此，出于演示目的，我们将参考React路由器和<a href="https://github.com/Paratron/hookrouter" target="_blank" rel="noopener noreferrer"> hooksrouter </a>。首先，让我们仔细看看React路由器。</p>
<p><span class="embed-youtube"> <iframe loading="lazy" class="youtube-player" src="https://www.youtube.com/embed/RI_SRAztbsg?version=3&amp;rel=1&amp;showsearch=0&amp;showinfo=1&amp;iv_load_policy=1&amp;fs=1&amp;hl=en-US&amp;autohide=2&amp;wmode=transparent" allowfullscreen="true" sandbox="allow-scripts allow-same-origin allow-popups allow-presentation">视频</iframe> </span></p>
<h2>什么是React路由器？</h2>
<p>React Router 是React应用程序中一种流行的管理路由的声明方式。它消除了在React应用程序中为所有页面和屏幕手动设置路径所带来的压力。React路由器输出三个主要组件来帮助我们实现路由——路由、链路和浏览器路由器。</p>
<h2>React路由器有必要吗？</h2>
<p>对于某些只需要基本导航和路由功能的项目来说，React router可能有些大材小用。在这种情况下，React路由器根本没有必要。也就是说，React Router具有丰富的导航组件，这些组件以声明方式与您的应用程序组合在一起，这对于React应用程序中更大、更复杂的导航需求非常有用。对于React本机应用程序来说，它也很棒。</p>
<h2>React路由器内置React吗？</h2>
<p>不，React路由器没有内置React。它是一个独立的路由库，构建在React之上，专门用于在React应用程序中提供路由和导航功能。当将React路由器添加到React应用程序中时，您从它自己的模块中导入它，就像这样:</p>
<pre><b>import</b><span> { </span><span>Router</span><span>, </span><span>Route</span><span>, </span><span>Switch</span><span> } </span><b>from</b> <span>"react-router"</span><span>;</span></pre>
<p>然而，你不应该像那样直接把它安装到你的项目中。如果你正在编写一个将在浏览器中运行的应用程序，你应该安装R  <span> eact路由器DOM。</span></p>
<h2>我需要React Router和React Router DOM吗？</h2>
<p><b/> <span>不需要R </span> <span> eact路由器</span> <span>和React路由器DOM一起。R </span> <span> eact路由器DOM </span> <span>默认情况下让你访问React路由器。如果您发现自己两者都在使用，那么可以去掉React Router，因为您已经将它作为一个依赖项安装在React Router DOM中了。但是，请注意，React路由器DOM仅在浏览器上可用，因此您只能将其用于web应用程序</span></p>
<h2>React路由器中的路由</h2>
<p>如果您正在构建一个React应用程序，并且有三个页面，下面是您通常如何使用React路由器实现路由:</p>
<pre>import Users from "./components/Users";
import Contact from "./components/Contact";
import About from "./components/About";
function App() {
  return (
    &lt;div&gt;
      &lt;Router&gt;
        &lt;div&gt;
          &lt;Route path="/about" component={About} /&gt;
          &lt;Route path="/users" component={Users} /&gt;
          &lt;Route path="/contact" component={Contact} /&gt;
        &lt;/div&gt;
      &lt;/Router&gt;
    &lt;/div&gt;
  );
}</pre>
<p>从React Router包中导入的<code>&lt;Route/&gt;</code>组件接受两个道具，一个是引导用户到指定路径的<code>path</code>,另一个是定义该路径内容的<code>component</code>。</p>
<h2>路径选择的钩子</h2>
<p>感谢<a href="https://www.reddit.com/user/chris_engel/" target="_blank" rel="noopener noreferrer">克里斯·恩格尔</a>提供的<a href="https://www.npmjs.com/package/hookrouter" target="_blank" rel="noopener noreferrer"> hookrouter </a>工具，我们将重点讲解这个工具，让大家了解这些演示。hookrouter模块导出一个<code>useRoutes()</code>钩子，该钩子评估预定义的routes对象并返回结果。在routes对象中，您将路由定义为键，它们的值作为函数，当路由匹配时将调用这些函数。这里有一个实际的演示:</p>
<pre>import React from "react";
import Users from "./components/Users";
import Contact from "./components/Contact";
import About from "./components/About";
const routes = {
  "/": () =&gt; &lt;Users /&gt;,
  "/about": () =&gt; &lt;About /&gt;,
  "/contact": () =&gt; &lt;Contact /&gt;
};
export default routes;</pre>
<p>我个人喜欢这个方法。为什么？因为我们不用做那么多工作。使用React Router，我们必须在应用程序中为所有单独的路由呈现<code>&lt;Route/&gt;</code>组件。更不用说我们传递给它的所有道具了。回到钩子，我们可以在应用程序中使用这个定义的<code>Routes</code>,只需将它传递给<code>useRoutes()</code>钩子:</p>
<pre>import {useRoutes} from 'hookrouter';
import Routes from './router'

function App() {
  const routeResult = useRoutes(Routes)
  return routeResult
}</pre>
<p>这为我们提供了与React路由器路由演示完全相同的结果，但实现更简洁、更轻便。</p>
<p>在<a href="https://codesandbox.io/s/react-router-demo-hook-routing-1j8jc" target="_blank" rel="noopener"> CodeSandbox </a>上查看这个可编辑的代码示例。</p>
<h2>React路由器导航</h2>
<p>React Router还让我们可以访问<code>&lt;Link/&gt;</code>组件。它帮助我们在React应用程序中定制路线导航和管理交互式路线。我们有一个包含三条路线的react应用程序，让我们在屏幕上呈现这些路线，并在单击时导航到它们:</p>
<pre>import { Route, Link, BrowserRouter as Router } from "react-router-dom";
import Users from "./components/Users";
import Contact from "./components/Contact";
import About from "./components/About";

function App() {
  return (
    &lt;div className="App"&gt;
      &lt;Router&gt;
        &lt;div&gt;
          &lt;ul&gt;
            &lt;li&gt;
              &lt;Link to="/about"&gt;About&lt;/Link&gt;
            &lt;/li&gt;
            &lt;li&gt;
              &lt;Link to="/users"&gt;Users&lt;/Link&gt;
            &lt;/li&gt;
            &lt;li&gt;
              &lt;Link to="/contact"&gt;Contact&lt;/Link&gt;
            &lt;/li&gt;
          &lt;/ul&gt;
          &lt;Route path="/about" component={About} /&gt;
          &lt;Route path="/users" component={Users} /&gt;
          &lt;Route path="/contact" component={Contact} /&gt;
        &lt;/div&gt;
      &lt;/Router&gt;
    &lt;/div&gt;
  );
}</pre>
<p>这就创建了我们在应用程序中从一个页面到另一个页面所需的导航。这是我们正在做的事情的直观表示。<br/> <img data-attachment-id="3606" data-permalink="https://blog.logrocket.com/how-react-hooks-can-replace-react-router/reactrouterdemohook/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2019/07/reactrouterdemohook.gif" data-orig-size="600,418" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="reactrouterdemohook" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2019/07/reactrouterdemohook-300x209.gif" data-large-file="https://blog.logrocket.com/wp-content/uploads/2019/07/reactrouterdemohook.gif" decoding="async" class="aligncenter wp-image-3606 jetpack-lazy-image" src="../Images/42dea2e5ced00520041527f9ea6f4eae.png" alt="" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2019/07/reactrouterdemohook.gif?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/07/reactrouterdemohook.gif"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="3606" data-permalink="https://blog.logrocket.com/how-react-hooks-can-replace-react-router/reactrouterdemohook/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2019/07/reactrouterdemohook.gif" data-orig-size="600,418" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="reactrouterdemohook" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2019/07/reactrouterdemohook-300x209.gif" data-large-file="https://blog.logrocket.com/wp-content/uploads/2019/07/reactrouterdemohook.gif" decoding="async" loading="lazy" class="aligncenter wp-image-3606" src="../Images/42dea2e5ced00520041527f9ea6f4eae.png" alt="" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/07/reactrouterdemohook.gif"/></noscript>
<p>这里有一个<a href="https://codesandbox.io/s/react-router-demo-uq9je?from-embed" target="_blank" rel="noopener">可编辑代码的例子</a>。</p>
<h2>反应式导航的替代钩子</h2>
<p>hookrouter模块将HTML锚标记<code>&lt;a/&gt;</code>包装为<code>&lt;A/&gt;</code>。它可以作为一个React组件来访问，并且与本机<code>&lt;a/&gt;</code>标签完全兼容。唯一的区别是，它将导航推送到历史堆栈，而不是实际加载一个新页面。</p>
<pre>const routes = {
  "/user": () =&gt; &lt;Users /&gt;,
  "/about": () =&gt; &lt;About /&gt;,
  "/contact": () =&gt; &lt;Contact /&gt;
};

function App() {
  const routeResult = useRoutes(routes);
  return (
    &lt;div className="App"&gt;
      &lt;A href="/user"&gt;Users Page&lt;/A&gt;
      &lt;A href="/about"&gt;About Page&lt;/A&gt;
      &lt;A href="/contact"&gt;Contacts Page&lt;/A&gt;
      {routeResult}
    &lt;/div&gt;
  );
}</pre>
<p><img data-attachment-id="3606" data-permalink="https://blog.logrocket.com/how-react-hooks-can-replace-react-router/reactrouterdemohook/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2019/07/reactrouterdemohook.gif" data-orig-size="600,418" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="reactrouterdemohook" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2019/07/reactrouterdemohook-300x209.gif" data-large-file="https://blog.logrocket.com/wp-content/uploads/2019/07/reactrouterdemohook.gif" decoding="async" class="aligncenter wp-image-3606 jetpack-lazy-image" src="../Images/42dea2e5ced00520041527f9ea6f4eae.png" alt="" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2019/07/reactrouterdemohook.gif?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/07/reactrouterdemohook.gif"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="3606" data-permalink="https://blog.logrocket.com/how-react-hooks-can-replace-react-router/reactrouterdemohook/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2019/07/reactrouterdemohook.gif" data-orig-size="600,418" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="reactrouterdemohook" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2019/07/reactrouterdemohook-300x209.gif" data-large-file="https://blog.logrocket.com/wp-content/uploads/2019/07/reactrouterdemohook.gif" decoding="async" loading="lazy" class="aligncenter wp-image-3606" src="../Images/42dea2e5ced00520041527f9ea6f4eae.png" alt="" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/07/reactrouterdemohook.gif"/></noscript>
<p>这里有一个<a href="https://codesandbox.io/s/react-router-demo-hook-navigation-5omyh" target="_blank" rel="noopener">互动演示</a>。</p>
<h2>程序导航</h2>
<p>hookrouter模块让我们可以访问一个<code>navigate()</code>钩子函数，我们可以将一个URL传递给它，它会将用户导航到那个URL。对<code>navigate()</code>函数的每一次调用都是一次前进导航，因此，用户可以点击浏览器的后退按钮返回到上一个URL。</p>
<pre>navigate('/user/');</pre>
<p>这是默认情况下发生的。但是，如果您需要不同的行为，您可以进行替换导航。怎么会？你可能会问，<code>navigation()</code>钩子主要接受三个参数— <code>navigate(url, [replace], [queryParams])</code>第二个参数用于影响替换行为。它会删除当前的历史记录条目，并用新条目替换它。要达到这种效果，只需将其参数设置为<code>true</code>。</p>
<pre>navigate('/user', true);</pre>
<h2>反应路由器交换机</h2>
<p>通常，当定义的导航路线不匹配时，React Router使用<code>&lt;Switch/&gt;</code>组件来呈现默认页面。通常，它会呈现一个404页面，让用户知道所选的路线没有在应用程序中定义。为此，我们将所有呈现的路线包装在<code>&lt;Switch/&gt;</code>组件中，并呈现404页面，而不为其定义<code>path</code>道具:</p>
<pre>import { Route, Link, BrowserRouter as Router, Switch } from "react-router-dom";
import Users from "./components/Users";
import Contact from "./components/Contact";
import Home from "./components/About";
import NoPageFound from "./components/NoPageFound.js";

function App() {
  return (
    &lt;div className="App"&gt;
      &lt;Router&gt;
        &lt;div&gt;
          &lt;ul&gt;
            &lt;li&gt;
              &lt;Link to="/"&gt;Home&lt;/Link&gt;
            &lt;/li&gt;
            &lt;li&gt;
              &lt;Link to="/users"&gt;Users&lt;/Link&gt;
            &lt;/li&gt;
            &lt;li&gt;
              &lt;Link to="/contact"&gt;Contact&lt;/Link&gt;
            &lt;/li&gt;
          &lt;/ul&gt;
          &lt;Switch&gt;
            &lt;Route exact path="/" component={Home} /&gt;
            &lt;Route path="/users" component={Users} /&gt;
            &lt;Route path="/contact" component={Contact} /&gt;
            &lt;Route component={NoPageFound} /&gt;
          &lt;/Switch&gt;
        &lt;/div&gt;
      &lt;/Router&gt;
    &lt;/div&gt;
  );
}</pre>
<p>这样，无论何时到达未定义的路径，React Router都会呈现<code>NopageFound</code>组件。这是一种非常敏锐的方式，让用户在浏览React站点时随时知道他们在哪里，正在发生什么。</p>
<p>这里有一个<a href="https://codesandbox.io/s/react-router-demo-switch-nvux9" target="_blank" rel="noopener">可编辑代码的例子</a>。</p>
<h2>替代开关的挂钩</h2>
<p>因为我们定义了一个保存所有路线路径的<code>routes</code>对象，并简单地将该对象传递给<code>useRoutes()</code>钩子，所以有条件地呈现路线变得非常简单。如果我们定义了一个<code>NoPageFound</code>文件，在默认情况下，当选择的路线没有定义时，我们只需要传递这个文件和我们的结果函数一起进行渲染，如下所示:</p>
<pre>import { useRoutes, A } from "hookrouter";
import routes from "./router";
import NoPageFound from "./components/NoPageFound";
function App() {
  const routeResult = useRoutes(routes);
  return (
    &lt;div className="App"&gt;
      &lt;A href="/user"&gt;Users Page&lt;/A&gt; &lt;br /&gt;
      &lt;A href="/about"&gt;About Page&lt;/A&gt;
      &lt;br /&gt;
      &lt;A href="/contact"&gt;Contacts Page&lt;/A&gt; &lt;br /&gt;
      {routeResult || &lt;NoPageFound /&gt;}
    &lt;/div&gt;
  );
}</pre>
<p><img data-attachment-id="3615" data-permalink="https://blog.logrocket.com/how-react-hooks-can-replace-react-router/alternativetoswitch/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2019/07/alternativetoswitch.gif" data-orig-size="600,423" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="alternativetoswitch" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2019/07/alternativetoswitch-300x212.gif" data-large-file="https://blog.logrocket.com/wp-content/uploads/2019/07/alternativetoswitch.gif" decoding="async" class="aligncenter wp-image-3615 jetpack-lazy-image" src="../Images/e6e884d57312766ec7c0933aac7705da.png" alt="" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2019/07/alternativetoswitch.gif?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/07/alternativetoswitch.gif"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="3615" data-permalink="https://blog.logrocket.com/how-react-hooks-can-replace-react-router/alternativetoswitch/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2019/07/alternativetoswitch.gif" data-orig-size="600,423" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="alternativetoswitch" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2019/07/alternativetoswitch-300x212.gif" data-large-file="https://blog.logrocket.com/wp-content/uploads/2019/07/alternativetoswitch.gif" decoding="async" loading="lazy" class="aligncenter wp-image-3615" src="../Images/e6e884d57312766ec7c0933aac7705da.png" alt="" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/07/alternativetoswitch.gif"/></noscript>
<p>与使用React Router中的<code>&lt;Switch&gt;</code>组件来呈现默认页面相比，我认为这似乎更干净，可读性更好。</p>
<p>看看这个<a href="https://codesandbox.io/s/react-router-demo-hook-switch-alternative-nfqew" target="_blank" rel="noopener">例子</a>。</p>
<h2>反应路由器重定向</h2>
<p>当我们希望动态地将用户从一个路由引导到另一个路由时，就会发生重定向。例如，在登录期间，当用户成功登录时，我们希望将他们从<code>('/login')</code>路由重定向到<code>('/dashboard')</code>路由。</p>
<p>有了React Router，我们可以用几种方式做到这一点——使用历史对象或<code>&lt;Redirect/&gt;</code>组件。例如，如果我们有一个登录表单，当用户登录时，我们可以利用浏览器的历史对象将用户推至<code>'/dashboard'</code>路线:</p>
<pre>import React from 'react'
class Login extends React.Component {
  loginUser = () =&gt; {
  // if (user is logged in successfully)
    this.props.history.push('/dashboard')
  }
  render() {
    return (
      &lt;form&gt;
        &lt;input type="name" /&gt;
        &lt;input type="email" /&gt;
        &lt;button onClick={this.loginUser}&gt;Login&lt;/button&gt;
      &lt;/form&gt;
    )
  }
}
export default Login</pre>
<p>因此，我们也可以使用React Router中可用的<code>&lt;Redirect/&gt;</code>组件来动态重定向用户。</p>
<h2>重定向的替代钩子</h2>
<p>hookrouter模块导出一个<code>useRedirect()</code>钩子，它可以将源路由和目标路由作为参数。</p>
<pre>useRedirect('/user', '/dashboard');</pre>
<p>每当<code>'/user'</code>路径匹配时，这将自动将用户重定向到<code>'/dashboard'</code>路径。例如，如果我们不想显示任何用户，而是自动将用户从重定向到他们的<code>'/dashboard'</code>，我们可以这样定义我们的应用程序:</p>
<pre>import {useRoutes, useRedirect} from 'hookrouter';
import dashboard from "./components/Dashboard";
const routes = {
    '/home': () =&gt; &lt;Users /&gt;,
    '/dashboard': () =&gt; &lt;Dashboard /&gt;
};
const Users = () =&gt; {
    useRedirect('/user', '/dashboard');
    const routeResult = useRoutes(routes);
    return routeResult
}</pre>
<p>这是这个过程的视觉输出:</p>
<p><img data-attachment-id="3616" data-permalink="https://blog.logrocket.com/how-react-hooks-can-replace-react-router/alternativestoredirects/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2019/07/alternativestoredirects.gif" data-orig-size="600,414" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="alternativestoredirects" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2019/07/alternativestoredirects-300x207.gif" data-large-file="https://blog.logrocket.com/wp-content/uploads/2019/07/alternativestoredirects.gif" decoding="async" class="aligncenter wp-image-3616 jetpack-lazy-image" src="../Images/0e661785efdb6ea8abf8af9a41d6b613.png" alt="" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2019/07/alternativestoredirects.gif?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/07/alternativestoredirects.gif"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="3616" data-permalink="https://blog.logrocket.com/how-react-hooks-can-replace-react-router/alternativestoredirects/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2019/07/alternativestoredirects.gif" data-orig-size="600,414" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="alternativestoredirects" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2019/07/alternativestoredirects-300x207.gif" data-large-file="https://blog.logrocket.com/wp-content/uploads/2019/07/alternativestoredirects.gif" decoding="async" loading="lazy" class="aligncenter wp-image-3616" src="../Images/0e661785efdb6ea8abf8af9a41d6b613.png" alt="" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/07/alternativestoredirects.gif"/></noscript>
<p>值得注意的是,<code>useRedirect()</code>钩子触发了替换导航意图。因此，导航历史记录中将只有一个条目。这意味着如果从<code>'/user'</code>到<code>'/dashboard'</code>发生重定向，就像我们在上一个片段中显示的那样，<code>'/user'</code>路由将不会出现在浏览历史中。我们将只有<code>'/dashboard'</code>路线。</p>
<h2>用React路由器处理URL参数</h2>
<p>URL参数帮助我们根据组件的动态URL来呈现组件。它的工作方式与嵌套路由类似，但是在这种情况下，路由并没有完全改变，而是在更新。</p>
<p>例如，如果我们的应用程序中有不同的用户，用他们各自的路线来区分他们是有意义的，比如<code>'user/user1/'</code>和<code>'users/user2/'</code>等。为此，我们需要使用URL参数。在React Router中，我们简单地将一个以冒号开头的占位符(如<code>id</code>)传递给<code>&lt;Route/&gt;</code>组件中的<code>path</code>属性:</p>
<pre>&lt;Route path="users/:id" component={Users} /&gt;</pre>
<p>现在，如果您在浏览器上导航到<code>'users/1'</code>，这个特定的用户将出现在您的<code>Users.js</code>道具中。</p>
<p><img data-attachment-id="3617" data-permalink="https://blog.logrocket.com/how-react-hooks-can-replace-react-router/alternativestorouter/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2019/07/alternativestorouter.png" data-orig-size="791,320" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="alternativestorouter" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2019/07/alternativestorouter-300x121.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2019/07/alternativestorouter.png" decoding="async" class="aligncenter wp-image-3617 jetpack-lazy-image" src="../Images/69b84531f17e37e79b9615316d8f4edf.png" alt="" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2019/07/alternativestorouter.png 791w, https://blog.logrocket.com/wp-content/uploads/2019/07/alternativestorouter-300x121.png 300w, https://blog.logrocket.com/wp-content/uploads/2019/07/alternativestorouter-768x311.png 768w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2019/07/alternativestorouter.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/07/alternativestorouter.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="3617" data-permalink="https://blog.logrocket.com/how-react-hooks-can-replace-react-router/alternativestorouter/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2019/07/alternativestorouter.png" data-orig-size="791,320" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="alternativestorouter" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2019/07/alternativestorouter-300x121.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2019/07/alternativestorouter.png" decoding="async" loading="lazy" class="aligncenter wp-image-3617" src="../Images/69b84531f17e37e79b9615316d8f4edf.png" alt="" srcset="https://blog.logrocket.com/wp-content/uploads/2019/07/alternativestorouter.png 791w, https://blog.logrocket.com/wp-content/uploads/2019/07/alternativestorouter-300x121.png 300w, https://blog.logrocket.com/wp-content/uploads/2019/07/alternativestorouter-768x311.png 768w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/07/alternativestorouter.png"/></noscript>
<h2>处理URL参数的钩子替代方法</h2>
<p>与React Router相比，hookrouter处理URL参数的方式没有太大区别。构造是相同的(例如，您可以使用冒号和参数名将URL参数传递给目标路由)。</p>
<p>然而，路由挂钩的工作方式仍然有所不同。它读取所有的URL参数，并将它们放入一个对象中。它使用您在routes对象中定义的键来实现这一点。然后，所有命名的参数将作为组合对象转发到您的路径结果函数。</p>
<pre>const routes = {
  '/user/:id': ({id}) =&gt; &lt;User userId={id} /&gt;
}</pre>
<p>使用对象析构，我们只需从props对象中获取<code>id</code>属性，然后将它应用到我们的组件上。这样，我们可以获得与React路由器完全相同的结果。</p><div class="code-block code-block-54">
<hr/>
<h3>更多来自LogRocket的精彩文章:</h3>

<hr/></div>
<h2>结论</h2>
<p>正如我在本文开头所说，目的是为您提供React项目中的另一种路由方式。React路由器是一个很棒的工具，但是，我认为随着钩子的出现，React中的很多东西都发生了变化，这也包括路由的工作方式。如果在较小的项目中处理路线，这个基于钩子的模块提供了一个更加灵活和干净的方法。如果你像我一样喜欢尝试新工具，我鼓励你尝试一下。</p>
<p>还有很多其他方面我们还没有在这篇文章中涉及，比如这两个工具如何处理嵌套路由等等。点击了解更多关于hookrouter模块<a href="https://github.com/Paratron/hookrouter" target="_blank" rel="noopener noreferrer">的信息。</a></p><div class="code-block code-block-17">
<div class="blog-plug inline-plug react-plug" vwo-el-id="26283398190">
<h2 vwo-el-id="41600691720">使用LogRocket消除传统反应错误报告的噪音</h2>
<a href="https://lp.logrocket.com/blg/react-signup-issue-free" target="_blank" vwo-el-id="19356441070">LogRocket
</a><p>是一款React analytics解决方案，可保护您免受数百个误报错误警报的影响，只针对少数真正重要的项目。LogRocket告诉您React应用程序中实际影响用户的最具影响力的bug和UX问题。</p><a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="19356441380">
<img class="first-react-image alignnone size-full wp-image-46 jetpack-lazy-image jetpack-lazy-image--handled" src="../Images/f300c244a1a1cf916df8b4cb02bec6c6.png" vwo-el-id="18272717540" data-lazy-loaded="1" data-original-src="https://files.readme.io/27c94e7-Image_2017-06-05_at_9.46.04_PM.png"/>
</a>
<a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="19356441690">
<img class="second-react-image alignnone size-full wp-image-46 jetpack-lazy-image jetpack-lazy-image--handled" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" vwo-el-id="30720362350" data-lazy-loaded="1" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/>
</a>
<a href="https://lp.logrocket.com/blg/react-signup-issue-free" target="_blank" rel="noopener noreferrer" vwo-el-id="35866400580">LogRocket
</a><p>自动聚合客户端错误、反应错误边界、还原状态、缓慢的组件加载时间、JS异常、前端性能指标和用户交互。然后，LogRocket使用机器学习来通知您影响大多数用户的最具影响力的问题，并提供您修复它所需的上下文。</p><p vwo-el-id="28675661060">关注重要的React bug—<a class="signup" href="https://lp.logrocket.com/blg/react-signup-issue-free" target="_blank" rel="noopener noreferrer" vwo-el-id="40093418840">今天就试试LogRocket】。</a></p>
</div></div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
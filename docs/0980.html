<html>
<head>
<title>A deep dive into queues in Node.js - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>深入探究Node.js - LogRocket博客中的队列</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/a-deep-dive-into-queues-in-node-js/#0001-01-01">https://blog.logrocket.com/a-deep-dive-into-queues-in-node-js/#0001-01-01</a></blockquote><div><article class="article-post">
<p>排队是Node.js中用于有效处理异步操作的一项重要技术。</p>
<p>在本文中，我们将深入探讨Node.js中的队列:它们是什么，它们如何工作(与事件循环一起)，以及它们的各种类型。</p>
<h2>Node.js中的队列是什么？</h2>
<p>队列是Node.js中用于适当组织异步操作的数据结构。这些操作以不同的形式存在，包括HTTP请求、读写文件操作、流等等。</p>
<p>在Node.js中处理异步操作可能具有挑战性。</p>
<p>根据网络强度，HTTP请求期间可能会出现不可预测的延迟(或者更糟，没有结果)。根据文件的大小，尝试使用Node.js读取或写入文件时也可能会有延迟。</p>
<p>与计时器和许多其他操作类似，异步操作的完成也可能是无限期的。</p>
<p>对于这些不同的持续时间，Node.js需要能够有效地处理所有这些操作。</p>
<p>Node.js不能处理基于first-start-first-handle或first-finish-first-handle的操作。</p>
<p>这可能不是一个好选择的一个原因是，一个异步操作可能包含另一个异步操作。</p>
<p>为第一个异步进程留出空间意味着必须先完成内部异步进程，然后才能考虑队列中的其他异步操作。</p>
<p>需要考虑的场景很多，所以最好的选择是有一个规则。这条规则影响事件循环和队列在Node.js中的工作方式。</p>
<p>让我们简单看看Node.js是如何处理异步操作的。</p>
<h2>调用堆栈、事件循环和回调队列</h2>
<p>调用堆栈跟踪当前正在执行的函数及其运行位置。当一个函数将要被执行时，它被添加到调用堆栈中。</p>
<p>这有助于JavaScript在执行一个函数后返回它的步骤。</p>
<p>回调队列是当异步操作在后台完成时，保存这些操作的回调函数的队列。</p>
<p>他们以先进先出的方式工作。在本文的后面，我们将研究不同类型的回调队列。</p>
<p>注意Node.js负责每一个异步活动，因为JavaScript可以用它的单线程性质阻塞线程。</p>
<p>它还负责在完成后台操作后向回调队列添加函数。JavaScript与回调队列无关。</p><div class="code-block code-block-54">
<hr/>
<h3>更多来自LogRocket的精彩文章:</h3>

<hr/></div>
<p>同时，事件循环不断检查调用堆栈是否为空，这样它就可以从回调队列中选取一个函数并添加到调用堆栈中。事件循环仅在所有同步操作都已执行时检查队列。</p>
<p>那么，事件循环按照什么顺序从队列中选择回调函数呢？</p>
<p>首先，让我们看看五种主要类型的回调队列。</p>
<h2>回调队列的类型</h2>
<h3>我排队</h3>
<p>IO操作是指涉及外部设备(如计算机内部设备)的操作。常见的操作包括读写文件操作、网络操作等。</p>
<p>这些操作应该是异步的，因为它们留给Node.js来处理。JavaScript无法访问计算机的内部。</p>
<p>当要执行这样的操作时，JavaScript会将它们转移到Node.js中进行后台处理。</p>
<p>完成后，它们被传输到IO回调队列，以便事件循环传输到调用堆栈执行。</p>
<h3>计时器队列</h3>
<p>涉及Node.js (如<code>setTimeout()</code>和<code>setInterval()</code>)的<a href="https://nodejs.org/en/docs/guides/timers-in-node/%5C" target="_blank" rel="noopener noreferrer">定时器特性的每个操作都被添加到定时器队列中。</a></p>
<p>注意<a href="https://dillionmegida.com/p/browser-apis-and-javascript/#javascript-on-nodejs" target="_blank" rel="noopener noreferrer"> JavaScript本身没有定时器特性</a>。</p>
<p>它使用Node.js提供的timer API(包含<code>setTimeout</code>)来执行与时间相关的操作。因此，计时器操作是异步的。</p>
<p>无论持续时间是2秒还是0秒，JavaScript都会将与时间相关的操作交给Node.js，然后完成这些操作并将其添加到计时器队列中。</p>
<p>例如:</p>
<pre>setTimeout(function() {
        console.log('setTimeout');
    }, 0)
    console.log('yeah')


    # result
    yeah
    setTimeout</pre>
<p>在处理异步操作的同时，JavaScript继续执行其他操作。只有当所有同步操作都被处理后，事件循环才会进入回调队列。</p>
<h3>微任务队列</h3>
<p>该队列分为两个队列:</p>

<p>事件循环执行的每次迭代称为一个节拍。</p>
<p><code>process.nextTick</code>是一个在下一个tick执行函数的函数(也叫事件循环的下一次迭代)。微任务队列存储这样的函数，以便它们可以在下一个节拍被执行。</p>
<p>这意味着事件循环必须在继续处理其他队列之前不断检查微任务队列中的这种功能。</p>
<ul>
<li>第二队列保存被<code><a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Promise" target="_blank" rel="noopener noreferrer">promises</a></code>延迟的功能。</li>
</ul>
<p>正如我们已经看到的，在IO和定时器队列中，所有关于异步操作的事情都交给了异步函数</p>
<p>承诺不一样。在promises中，一个初始变量存储在JavaScript内存中(你可能见过，<code>&lt;Pending&gt;</code>)。</p>
<p>当异步操作完成时，Node.js将该函数(附属于承诺)放入微任务队列中。同时，它用得到的结果更新JavaScript内存中的变量，这样函数就不会用<code>&lt;Pending&gt;</code>运行。</p>
<p>以下代码解释了承诺的工作原理:</p>
<pre>let prom = new Promise(function (resolve, reject) {
        // delay execution
        setTimeout(function () {
            return resolve("hello");
        }, 2000);
    });
    console.log(prom);
    // Promise { &lt;pending&gt; }
    
    prom.then(function (response) {
        console.log(response);
    });
    // after 2000ms,
    // hello</pre>
<p>关于微任务队列需要注意的一个重要特性是，事件循环在处理其他队列之前，会反复检查和执行微任务队列中的函数。</p>
<p>例如，当微任务队列完成时，比方说，一个定时器操作执行一个承诺操作，事件循环将在转移到定时器队列中的其他函数之前处理该承诺操作。</p>
<p>因此，微任务qeuue的优先级高于其他队列。</p>
<h3>检查队列(也称为立即队列)</h3>
<p>在IO队列中的所有回调函数被执行之后，这个队列中的回调函数被立即执行。</p>
<p><code>setImmediate</code>是用于向该队列添加函数的函数。</p>
<p>例如:</p>
<pre>const fs = require('fs');
setImmediate(function() {
    console.log('setImmediate');
})
// assume this operation takes 1ms
fs.readFile('path-to-file', function() {
    console.log('readFile')
})
// assume this operation takes 3ms
do...while...</pre>
<p>当这个程序被执行时，Node.js将<code>setImmediate</code>的回调函数添加到检查队列中。由于整个程序尚未完成，事件循环不会检查任何队列。</p>
<p><code>readFile</code>操作是异步的，所以交给Node.js，程序继续执行。</p>
<p><code>do while</code>操作持续3毫秒。在此期间，<code>readFile</code>操作完成并被推送到IO队列。完成此操作后，事件循环开始检查队列。</p>
<p>尽管检查队列首先被填充，但只有在IO队列为空之后才会被考虑。因此，<code>readFile</code>在<code>setImmediate</code>之前被记录到控制台。</p>
<h3>关闭队列</h3>
<p>此队列存储与关闭事件操作相关联的函数。</p>
<p>例子包括如下:</p>
<ul>
<li><a href="https://nodejs.org/api/stream.html#stream_event_close" target="_blank" rel="noopener noreferrer">流关闭事件</a>，当流关闭时发出。它表示不会再发出更多的事件。</li>
<li>服务器关闭时发出的<a href="https://nodejs.org/api/http.html#http_event_close" target="_blank" rel="noopener noreferrer"> http关闭事件</a>。</li>
</ul>
<p>这些被认为是优先级最低的队列，因为这里的操作发生在较晚的时间。</p>
<p>在处理promise的函数之前，您不会希望在<code>close</code>事件中执行回调函数。当服务器已经关闭时，这个承诺函数会做什么？</p>
<h3>队列的顺序</h3>
<p>微任务队列被赋予最高优先级，然后是定时器队列、I/O队列、检查队列，最后是关闭队列。</p>
<h2>回调队列的一个例子</h2>
<p>让我们看一个更大的例子来说明队列的类型和顺序:</p>
<pre>const fs = require("fs");

// assume this operation takes a 2ms
fs.writeFile('./new-file.json', '...', function() {
    console.log('writeFile')
})

// assume this takes 10ms to complete
fs.readFile("./file.json", function(err, data) {
    console.log("readFile");
});

// don't assume, this actually takes 1ms
setTimeout(function() {
    console.log("setTimeout");
}, 1000);

// assume this operation takes 3ms
while(...) {
    ...
}

setImmediate(function() {
    console.log("setImmediate");
});

// promise that takes 4ms to resolve
let promise = new Promise(function (resolve, reject) {
    setTimeout(function () {
        return resolve("promise");
    }, 4000);
});
promise.then(function(response) {
    console.log(response)
})

console.log("last line");</pre>
<p>下面是程序流程:</p>
<p>0毫秒时，程序开始。</p>
<p><code>fs.writeFile</code>在Node.js将回调函数添加到IO队列之前，在后台需要2ms。</p>
<p><code>fs.readFile</code>在Node.js将回调函数添加到IO队列之前，在后台花费10ms。</p>
<p><code>setTimeout</code>在Node.js将回调函数添加到定时器队列之前，在后台需要1ms。</p>
<p>现在，while操作(它是同步的)需要3毫秒。在此期间，线程被阻塞(记住JavaScript是单线程的)。</p>
<p>同样在此期间，<code>setTimeout</code>和<code>fs.writeFile</code>操作完成，它们的回调函数被分别添加到定时器和IO队列中。</p>
<p>现在的队列是:</p>
<pre>// queues
Timer = [
    function () {
        console.log("setTimeout");
    },
];
IO = [
    function () {
        console.log("writeFile");
    },
];</pre>
<p><code>setImmediate</code>将回调函数添加到检查队列中:</p>
<pre>js
// queues
Timer...
IO...
Check = [
    function() {console.log("setImmediate")}
]</pre>
<p>在将promise操作添加到微任务队列之前，需要4毫秒的时间(在后台)进行解析。</p>
<p>最后一行是同步的，所以会立即执行:</p>
<pre># results
"last line"</pre>
<p>所有同步活动都已完成，因此事件循环开始检查队列。它从定时器队列开始，因为微任务队列是空的:</p>
<pre>// queues
Timer = [] // now empty
IO...
Check...


# results
"last line"
"setTimeout"</pre>
<p>当事件循环继续执行队列中的回调函数时，<code>promise</code>操作完成并被添加到微任务队列中:</p>
<pre>// queues
    Timer = [];
    Microtask = [
        function (response) {
            console.log(response);
        },
    ];
    IO = []; // now empty
    Check = []; // now empty immediately after IO


    # results
    "last line"
    "setTimeout"
    "writeFile"
    "setImmediate"</pre>
<p>几秒钟后，<code>readFile</code>操作完成并被添加到IO队列:</p>
<pre>// queues
    Timer = [];
    Microtask = []; // now empty
    IO = [
        function () {
            console.log("readFile");
        },
    ];
    Check = [];


    # results
    "last line"
    "setTimeout"
    "writeFile"
    "setImmediate"
    "promise"</pre>
<p>最后，执行所有回调函数:</p>
<pre>// queues
    Timer = []
    Microtask = []
    IO = [] // now empty again
    Check = [];


    # results
    "last line"
    "setTimeout"
    "writeFile"
    "setImmediate"
    "promise"
    "readFile"</pre>
<p>这里需要注意三件事:</p>
<ul>
<li>异步操作在被添加到队列之前取决于它们的持续时间。它们不依赖于它们在程序中的排列顺序。</li>
<li>事件循环在每次迭代处理其他队列之前，不断检查微任务队列。</li>
<li>即使在后台有另一个IO操作(<code>readFile</code>)时，事件循环也执行检查队列中的功能。它这样做是因为，在那个时候，IO队列是空的。请记住，检查队列回调是在IO队列中的所有函数执行完之后立即运行的。</li>
</ul>
<h3>结论</h3>
<p>JavaScript是单线程的。每一个异步函数都由Node.js与计算机的内部功能一起处理。</p>
<p>Node.js负责将回调函数(通过JavaScript附加到异步操作)添加到回调队列中。事件循环确定在每次迭代中接下来要执行的回调函数。</p>
<p>理解队列在Node.js中的工作方式可以让您更好地理解它，因为队列是环境的核心特性之一。Node.js最流行的定义是<code>non-blocking</code>，意思是异步操作被正确处理。</p>
<p>这个特性是通过事件循环和回调队列实现的。</p><div class="code-block code-block-23">
<div class="blog-plug inline-plug node-plug"><h2>200只<img src="../Images/61167b9d027ca73ed5aaf59a9ec31267.png" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2019/10/green-check.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" class=" jetpack-lazy-image" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/10/green-check.png"/> <noscript> <img data-lazy-fallback="1" src="../Images/61167b9d027ca73ed5aaf59a9ec31267.png" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/10/green-check.png"/> </noscript>显示器出现故障，生产中网络请求缓慢</h2><p>部署基于节点的web应用程序或网站是容易的部分。确保您的节点实例继续为您的应用程序提供资源是事情变得更加困难的地方。如果您对确保对后端或第三方服务的请求成功感兴趣，</p><a href="https://lp.logrocket.com/blg/node-signup" target="_blank">try LogRocket</a><p>. </p><a class="signup" href="https://lp.logrocket.com/blg/node-signup" target="_blank" rel="noopener noreferrer"><img src="../Images/cae72fd2a54c5f02a6398c4867894844.png" alt="LogRocket Network Request Monitoring" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2019/12/network-request-filter-2-1.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" class=" jetpack-lazy-image" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/12/network-request-filter-2-1.png"/><noscript><img data-lazy-fallback="1" src="../Images/cae72fd2a54c5f02a6398c4867894844.png" alt="LogRocket Network Request Monitoring" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/12/network-request-filter-2-1.png"/></noscript></a><a href="https://lp.logrocket.com/blg/node-signup" target="_blank" rel="noopener noreferrer">https://logrocket.com/signup/</a><p>LogRocket 就像是网络和移动应用程序的DVR，记录下用户与你的应用程序交互时发生的一切。您可以汇总并报告有问题的网络请求，以快速了解根本原因，而不是猜测问题发生的原因。</p><p>LogRocket检测您的应用程序以记录基线性能计时，如页面加载时间、到达第一个字节的时间、慢速网络请求，还记录Redux、NgRx和Vuex操作/状态。</p><a class="signup" href="https://lp.logrocket.com/blg/node-signup" target="_blank" rel="noopener noreferrer">Start monitoring for free</a><p>. </p></div>
</div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
<html>
<head>
<title>Why you should use SWC (and not Babel) - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>为什么你应该使用SWC(而不是巴别塔)</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/why-you-should-use-swc/#0001-01-01">https://blog.logrocket.com/why-you-should-use-swc/#0001-01-01</a></blockquote><div><article class="article-post">
<h2>巴别塔是什么？</h2>
<p>Babel 是一个帮助我们<a href="https://scotch.io/tutorials/javascript-transpilers-what-they-are-why-we-need-them" target="_blank" rel="noopener noreferrer">将较新版本的JavaScript代码</a>如<a href="https://www.w3schools.com/js/js_es6.asp" target="_blank" rel="noopener noreferrer"> ES6 </a>转换成较旧版本的JavaScript代码的工具——它甚至可以帮助你转换<a href="https://iamturns.com/typescript-babel/" target="_blank" rel="noopener noreferrer"> TypeScript </a>。</p>
<p>Babel根据您为其定义的配置读取源代码，并编译更新的JavaScript特性，如<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions" target="_blank" rel="noopener noreferrer">箭头功能</a>或<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Optional_chaining" target="_blank" rel="noopener noreferrer">可选链接</a>。巴别塔的三个主要工具就是如此:</p>
<ul>
<li>首先，Babel的<a href="https://github.com/babel/babel/tree/master/packages/babel-parser" target="_blank" rel="noopener noreferrer">解析器</a>获取JavaScript代码，并将其转换为一个<a href="https://en.wikipedia.org/wiki/Abstract_syntax_tree" target="_blank" rel="noopener noreferrer">抽象语法树(AST) </a>，这是计算机可以理解的源代码结构</li>
<li>接下来，Babel的<a href="https://github.com/babel/babel/tree/master/packages/babel-traverse" target="_blank" rel="noopener noreferrer">遍历器</a>获取AST，研究它并将其修改为我们在Babel配置中定义的预期代码</li>
<li>最后，Babel的<a href="https://github.com/babel/babel/tree/master/packages/babel-generator" target="_blank" rel="noopener noreferrer">生成器</a>会将修改后的AST翻译回常规代码</li>
</ul>
<figure id="attachment_19604" aria-describedby="caption-attachment-19604" class="wp-caption aligncenter"><img data-attachment-id="19604" data-permalink="https://blog.logrocket.com/why-you-should-use-swc/ast/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/06/ast.png" data-orig-size="880,228" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="ast" data-image-description="" data-image-caption="&lt;p&gt;Source: https://www.sitepoint.com/understanding-asts-building-babel-plugin/&lt;/p&gt;&#10;" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/06/ast-300x78.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/06/ast.png" decoding="async" class="size-full wp-image-19604 jetpack-lazy-image" src="../Images/6e34b11189d2b95000ef4f131a3e77d2.png" alt="abstract syntax tree " data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2020/06/ast.png 880w, https://blog.logrocket.com/wp-content/uploads/2020/06/ast-300x78.png 300w, https://blog.logrocket.com/wp-content/uploads/2020/06/ast-768x199.png 768w" data-lazy-sizes="(max-width: 880px) 100vw, 880px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2020/06/ast.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/06/ast.png"/><noscript><img data-lazy-fallback="1" data-attachment-id="19604" data-permalink="https://blog.logrocket.com/why-you-should-use-swc/ast/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/06/ast.png" data-orig-size="880,228" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="ast" data-image-description="" data-image-caption="&lt;p&gt;Source: https://www.sitepoint.com/understanding-asts-building-babel-plugin/&lt;/p&gt;&#10;" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/06/ast-300x78.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/06/ast.png" decoding="async" loading="lazy" class="size-full wp-image-19604" src="../Images/6e34b11189d2b95000ef4f131a3e77d2.png" alt="abstract syntax tree " srcset="https://blog.logrocket.com/wp-content/uploads/2020/06/ast.png 880w, https://blog.logrocket.com/wp-content/uploads/2020/06/ast-300x78.png 300w, https://blog.logrocket.com/wp-content/uploads/2020/06/ast-768x199.png 768w" sizes="(max-width: 880px) 100vw, 880px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/06/ast.png"/></noscript><figcaption id="caption-attachment-19604" class="wp-caption-text">Source: <a href="https://www.sitepoint.com/understanding-asts-building-babel-plugin/" rel="nofollow">https://www.sitepoint.com/understanding-asts-building-babel-plugin/</a></figcaption></figure>
<h2>巴别尔的选择(写于铁锈)</h2>
<p><a href="https://swc-project.github.io/" target="_blank" rel="noopener noreferrer"> SWC </a>也是一个JavaScript翻译程序，它是用<a href="https://www.rust-lang.org/" target="_blank" rel="noopener noreferrer"> Rust </a>编写的，比<a href="https://swc-project.github.io/blog/2020/01/31/perf-swc-vs-babel" target="_blank" rel="noopener noreferrer">Babel</a>快得多。Rust以其性能和可靠性而闻名，并鼓励许多企业用它重写部分或全部代码。例如:</p>

<p>Rust如此高性能的原因之一是其处理<a href="https://en.wikipedia.org/wiki/Garbage_collection_(computer_science)" target="_blank" rel="noopener noreferrer">垃圾收集</a>的方式，这是一种内存管理方法，通过不再使用内存资源的数据对象来释放内存资源。由于Rust决定哪些内存资源在编译时不再需要，并且不必连续运行，因此处理时间减少，而性能提高。</p>
<p>众所周知，代码转换是一个昂贵的过程，这就是为什么用Rust编写的转换程序性能更高。我们将进一步探索这一点，但首先，我们应该确定我们是否需要一个transpiler:</p>
<h2>为什么我们需要一个运输工具？</h2>
<p>在某些情况下，可能不需要使用transpiler:</p>
<ul>
<li>如果您正在构建一个简单的项目，该项目主要依赖于一个支持良好的JavaScript版本，如<a href="https://www-archive.mozilla.org/js/language/E262-3.pdf" target="_blank" rel="noopener noreferrer"> ES3 </a>。例如，运行这段代码可以在几乎所有的浏览器上运行，所以如果您的JavaScript用法主要是这样的，那么没有transpiler也没问题:</li>
</ul>
<pre>// we print it, but we don't agree with it
function saySomething (something) {
    console.log(`${something}. But don't tell anyone.`);
}

saySomething("I don't like Javascript!");</pre>
<ul>
<li>如果您正在构建一个简单的项目，它依赖于较新版本的JavaScript，比如arrow函数，但是您需要支持的浏览器也支持这些新特性。例如，在较新版本的Chrome (45+)中运行以下代码应该没问题:</li>
</ul>
<p><img data-attachment-id="19609" data-permalink="https://blog.logrocket.com/why-you-should-use-swc/caniuse-2/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/06/caniuse.png" data-orig-size="730,223" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="caniuse" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/06/caniuse-300x92.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/06/caniuse.png" decoding="async" class="aligncenter size-full wp-image-19609 jetpack-lazy-image" src="../Images/dafa75a3c98fe85bd2937ebad60ea0af.png" alt="can I use arrow functions" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2020/06/caniuse.png 730w, https://blog.logrocket.com/wp-content/uploads/2020/06/caniuse-300x92.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2020/06/caniuse.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/06/caniuse.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="19609" data-permalink="https://blog.logrocket.com/why-you-should-use-swc/caniuse-2/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/06/caniuse.png" data-orig-size="730,223" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="caniuse" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/06/caniuse-300x92.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/06/caniuse.png" decoding="async" loading="lazy" class="aligncenter size-full wp-image-19609" src="../Images/dafa75a3c98fe85bd2937ebad60ea0af.png" alt="can I use arrow functions" srcset="https://blog.logrocket.com/wp-content/uploads/2020/06/caniuse.png 730w, https://blog.logrocket.com/wp-content/uploads/2020/06/caniuse-300x92.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/06/caniuse.png"/></noscript>
<pre>// we print it, but we don't agree with it
const saySomething = something =&gt; {
  console.log(`${something}. But don't tell anyone.`);
};

saySomething("I don't like Javascript!");</pre>
<p>除了这些情况，应用程序中需要transpiler是必要的。浏览器使用不同类型的JavaScript引擎，如<a href="https://v8.dev/" target="_blank" rel="noopener noreferrer">V8</a>(Chrome)<a href="https://developer.mozilla.org/en-US/docs/Mozilla/Projects/SpiderMonkey" target="_blank" rel="noopener noreferrer">蜘蛛猴</a> (Firefox)，以及<a href="https://en.wikipedia.org/wiki/Chakra_(JScript_engine)" target="_blank" rel="noopener noreferrer"> Chakra </a> (IE)。这意味着即使有一个标准的JavaScript规范，在不同的浏览器中获得标准的时间和它们的支持水平也有很大的不同。</p>
<p>这就是为什么我们需要在许多不同的浏览器上一致地处理我们的JavaScript代码，而不用担心破坏什么东西或者失去使用新特性的机会。</p>
<p>我们对transpilers的依赖不仅仅局限于将<a href="https://www.w3schools.com/js/js_es6.asp" target="_blank" rel="noopener noreferrer"> ES6 </a>或<a href="https://www.typescriptlang.org/" target="_blank" rel="noopener noreferrer">打字稿</a>转换为<a href="https://www.w3schools.com/js/js_es5.asp" target="_blank" rel="noopener noreferrer">ES5</a>；transpilers今天为我们带来了JavaScript的未来，并让我们处理许多JavaScript转换的情况，如<a href="https://blog.logrocket.com/5-es2019-features-you-can-use-today/" target="_blank" rel="noopener noreferrer"> ES2019 </a>。对于今天的JavaScript开发人员来说，这是一个非常强大的工具。</p>
<p>所以我们已经确定了为什么我们需要运输钳。现在是时候用一个简单的设置来测试SWC的使用情况了，稍后将它的相对性能和速度与Babel进行比较。</p>
<h2>SWC用法</h2>
<p>SWC可以作为一个软件包从NPM软件包管理器安装。</p>
<p>首先，在您的根目录下开始运行这个命令:</p>
<pre>// use `cd` to go to the right directory and then run
mkdir swc_project

// initialize a package.json
npm init

// install swc core as well as its cli tool
npm install --save-dev @swc/core @swc/cli</pre>
<p>通过运行这个命令，我们现在拥有了SWC核心和CLI。核心包将帮助我们进行构建设置，而<a href="https://swc-project.github.io/docs/usage-cli" target="_blank" rel="noopener noreferrer">CLI包</a>可以在终端中用命令运行。</p>
<p>作为第一步，我们关注CLI工具来传输我们的JavaScript文件。假设我们在根目录下有下面的JavaScript文件:</p>
<pre>//  async.js
const fetch = require("node-fetch");

async function getData() {
    let res = await fetch("https://jsonplaceholder.typicode.com/todos/1");
    let json = await res.json();
    console.log('data', json);
}

getData();
// result:
// ▶Object {userId: 1, id: 1, title: "delectus aut autem", completed: false}</pre>
<p>您可以运行以下命令对该文件进行编译，如下所示:</p>
<pre>// running this command will emit the transpiled data to stdout
// and it will be printed out in the terminal
npx swc async.js

// running this will create a new file called `output.js`
// with the transpiled data
npx swc async.js -o output.js

// running this will create a new directory called `transpiledDir`
// and will transpile all th files in the original dir
npx swc src -d transpiledDir</pre>
<p>注意——要查看传输文件的样子，您可以使用这个<a href="https://swc-playground.now.sh/" target="_blank" rel="noopener noreferrer"> SWC游乐场</a>。</p>
<p>现在，作为第二步，我们希望将SWC作为一个工具包含在我们的构建系统中。对于这一个，我们想使用<a href="https://webpack.js.org/" target="_blank" rel="noopener noreferrer"> Webpack </a>作为一个更高级和可配置的构建器。</p>
<p>首先，让我们看看我们的<code>package.json</code>如何寻找Webpack和SWC的设置。有了这个设置，我们可以运行<code>npm run-script build</code>让webpack构建我们的包；此外，我们可以运行<code>npm run-script start</code>来让Webpack服务于我们的应用程序:</p>
<pre>{
  "name": "swc-project",
  "version": "1.0.0",
  "scripts": {
    "test": "echo \"Error: no test specified\" &amp;&amp; exit 1",
    "build": "rm -rf ./dist &amp;&amp; webpack",
    "start": "webpack-dev-server"
  },
  "license": "MIT",
  "devDependencies": {
    "@swc/core": "^1.1.39",
    "css-loader": "^3.4.0",
    "html-loader": "^0.5.5",
    "html-webpack-plugin": "^3.2.0",
    "sass-loader": "^8.0.0",
    "style-loader": "^1.1.1",
    "swc-loader": "^0.1.9",
    "webpack": "^4.41.4",
    "webpack-cli": "^3.3.10",
    "webpack-dev-server": "^3.10.1"
  },
  "dependencies": {
    "node-fetch": "2.6.0",
    "react": "^16.12.0",
    "react-dom": "^16.12.0",
    "regenerator-runtime": "^0.13.5"
  }
}</pre>
<p>我们上面构建和启动应用程序的配置存储在一个<code><a href="https://webpack.js.org/configuration/" target="_blank" rel="noopener noreferrer">webpack.config.js</a></code>文件中，Webpack会自动获取该文件。这个文件中有几件事情:</p>
<ul>
<li>我们正在为Webpack设置名称和位置，以输出您的包、资产和文件，包括所有传输的文件</li>
<li><code><a href="https://webpack.js.org/configuration/dev-server/" target="_blank" rel="noopener noreferrer">devServer</a></code>:我们通过这个配置来服务我们的Webpack应用程序，告诉Webpack从哪里提供内容，并定义一个端口来监听请求</li>
<li>我们定义这个插件是为了让提供包含Webpack包的HTML文件的过程变得更容易</li>
</ul>
<p>但是这个配置中最重要的部分是<a href="https://swc-project.github.io/docs/usage-swc-loader" target="_blank" rel="noopener noreferrer"> <code>swc-loader</code> </a>，它允许我们用。<code>js</code>或<code>.jsx</code>文件扩展名:</p>
<pre>// global dependencies
const path = require('path');
const HTMLWebpackPlugin = require("html-webpack-plugin");

module.exports = {
  mode: "development",
  output: {
    path: path.resolve(__dirname, './dist'),
    filename: 'index_bundle.js'
  },
  devServer: {
    contentBase: path.join(__dirname, 'dist'),
    compress: true,
    port: 9000
  },
  module: {
    rules: [
        {
        test: /\.jsx?$/ ,
        exclude: /(node_modules|bower_components)/,
        use: {
            // `.swcrc` in the root can be used to configure swc
            loader: "swc-loader"
        }
      },
      {
        test: /\.html$/,
        use: [
          {
            loader: "html-loader",
            options: { minimize: true }
          }
        ]
      },
      {
        test: /\.scss/i,
        use: ["style-loader", "css-loader", "sass-loader"]
      }
    ]
  },
  plugins: [
    new HTMLWebpackPlugin({
      filename: "./index.html",
      template: path.join(__dirname, 'public/index.html')
    })
  ]
};</pre>
<p>随着在我们的Webpack配置中设置好<code>swc-loader</code>,我们已经完成了JavaScript文件传输的一半。然而，我们仍然需要指导SWC如何转移我们的文件。原来，SWC有一个类似于Babel的方法，在根目录下定义一个名为<a href="https://swc-project.github.io/docs/configuring-swc.html" target="_blank" rel="noopener noreferrer">的配置文件。swcrc </a>。让我们看看这个配置对于一个想要传输文件类型脚本的项目是什么样子的。</p>
<p>在这个配置中，我们使用<code>test</code>配置作为一个<a href="https://en.wikipedia.org/wiki/Regular_expression" target="_blank" rel="noopener noreferrer">正则表达式</a>，只匹配文件扩展名为<code>.ts</code>的文件。此外，通过<code>jsx.parser</code>配置，我们将指导SWC使用哪个解析器进行编译(可能是<code>typescript / ecmascript</code>)。</p>
<p>然而，我们仍然可以通过定义哪些翻译选项用于我们的用例来控制语法解析。例如，在这个例子中，我们对传输Typescript<a href="https://www.typescriptlang.org/docs/handbook/decorators.html" target="_blank" rel="noopener noreferrer">decorator</a>和<a href="https://basarat.gitbook.io/typescript/project/dynamic-import-expressions" target="_blank" rel="noopener noreferrer"> dynamic imports </a>感兴趣，但是忽略传输文件扩展名为<code>.tsx</code>的文件:</p>
<pre>// .swcrc

{
  "test": ".*.ts$",
  "jsc": {
    "parser": {
      "syntax": "typescript",
      "tsx": false,
      "decorators": true,
      "dynamicImport": true
    }
  }
}</pre>
<p>现在，假设我们想在上面的<code>webpack SWC</code>示例中使用<code><a href="https://reactjs.org/" target="_blank" rel="noopener noreferrer">React</a></code>。我们知道，在React中，我们可以使用一个名为<code>.jsx</code>的文件扩展名来编写React组件:</p>
<pre>// App.jsx

// global dependencies
import React from 'react';
import ReactDOM from 'react-dom';

const App = () =&gt; {
  return &lt;h1&gt;My SWC App&lt;/h1&gt;;
};

ReactDOM.render(&lt;App /&gt;, document.querySelector("#root"));</pre>
<p>通过Webpack提供这个文件需要正确的<code>webpack loader</code>,我们已经在上面定义了它。它还要求在<code>.swcrc</code>文件中有正确的翻译设置。现在，通过这种方法，我们使用了现代JavaScript的最新功能(<a href="https://medium.com/@selvaganesh93/javascript-whats-new-in-ecmascript-2019-es2019-es10-35210c6e7f4b" target="_blank" rel="noopener noreferrer"> ES2019 </a>)并在传输时支持<code>.jsx</code>文件。此外，如果我们的React项目需要额外的transpilation设置，我们手头有<a href="https://swc-project.github.io/docs/configuring-swc" target="_blank" rel="noopener noreferrer">大量的设置</a>:</p>
<pre>// .swcrc

{
    "jsc": {
      "parser": {
        "syntax": "ecmascript",
        "jsx": true
      }
    }
  }</pre>
<h2>巴别尔和SWC的速度比较</h2>
<p>正如我们之前所讨论的，transpiler的速度至关重要，因为它是构建过程的一部分，对于许多开发人员来说，在这方面节省的任何时间都是宝贵的。让我们来看看这两个工具在速度方面的比较。</p>
<p>首先，我们以一种人工的方式比较它们，也就是以同步的方式运行巴别塔和SWC的代码转换。众所周知，JavaScript是单线程的，在现实应用中不可能以异步方式运行繁重的计算。但是这仍然会给我们一个速度比较的指标。让我们看看在单核CPU上运行的这些基准比较(由SWC项目的<a href="https://swc-project.github.io/blog/2020/01/31/perf-swc-vs-babel#benchmark-for-many-works" target="_blank" rel="noopener noreferrer">维护者执行的测试):</a></p>
<table>
<thead>
<tr>
<th><span>变换</span></th>
<th><span>速度(操作/秒)</span></th>
<th><span>样品运行</span></th>
</tr>
</thead>
<tbody>
<tr>
<td>SWC (ES3)</td>
<td>每秒616次运算</td>
<td>88</td>
</tr>
<tr>
<td>巴别塔(第五章)</td>
<td>每秒34.05次运算</td>
<td>58</td>
</tr>
</tbody>
</table>
<p>这表明，尽管SWC的ES3改造过程成本更高，但与巴别塔相比，SWC的传输速度还是很明显的。</p>
<p>现在，如果我们想对一个更真实的场景进行基准测试，我们可以针对<code><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/all" target="_blank" rel="noopener noreferrer">await Promise.all()</a></code>运行示例，这是一个处理JavaScript中的操作的更昂贵和真实的场景。在这个基准测试中，CPU内核的数量和并行计算开始发挥作用。<a href="https://swc-project.github.io/blog/2020/01/31/perf-swc-vs-babel" target="_blank" rel="noopener noreferrer">在</a>运行的另一个基准测试中，进行了两个实验。两者都使用了一台带有8个CPU内核和4个并行度<strong>的计算机。</strong></p>
<p>第一个实验是在<strong> 4 </strong>的承诺下进行的:</p>
<table>
<thead>
<tr>
<th>改变</th>
<th>速度(操作/秒)</th>
<th>样品运行</th>
</tr>
</thead>
<tbody>
<tr>
<td>SWC (ES3)</td>
<td><strong> 1704 </strong>操作/秒</td>
<td>73</td>
</tr>
<tr>
<td>巴别塔(第五章)</td>
<td>27.28次/秒</td>
<td>40</td>
</tr>
</tbody>
</table>
<p>第二个实验用<strong> 100 </strong>承诺:</p>
<table>
<thead>
<tr>
<th>改变</th>
<th>速度(操作/秒)</th>
<th>样品运行</th>
</tr>
</thead>
<tbody>
<tr>
<td>SWC (ES3)</td>
<td><strong> 2199 </strong>操作/秒</td>
<td>54</td>
</tr>
<tr>
<td>巴别塔(第五章)</td>
<td><strong> 32 </strong>操作/秒</td>
<td>6</td>
</tr>
</tbody>
</table>
<blockquote><p>注意——如果您有兴趣自己运行测试并比较这些基准，您可以克隆<a href="https://github.com/swc-project/node-swc" target="_blank" rel="noopener noreferrer">这个存储库</a>,然后在终端中运行以下命令:</p></blockquote>
<pre>// clone and cd into the cloned repository
cd node-swc

// Node.js benchmark runner, modelled after Mocha and bencha, based on Benchmark.js.
npm i benchr -g

// run the multicore.js or any other benchmarks under /benches directory
benchr ./benches/multicore.js
</pre>
<p>我们在这些数字中可以发现的主要问题是，随着Babel在<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/EventLoop" target="_blank" rel="noopener noreferrer">事件循环</a>上工作，Babel在异步操作中的性能正在下降。这与SWC形成对比，后者运行在一个<a href="https://nodejs.org/api/worker_threads.html" target="_blank" rel="noopener noreferrer">工作线程</a>上，可以很好地随着CPU内核数量的增加而扩展。</p>
<p>总的来说，我们看到这两种工具之间明显的速度差距，因为在单线程和CPU核心上，SWC往往比Babel快大约<strong> 20 </strong>倍，而在多核异步操作过程中，则快大约<strong> 60 </strong>倍。</p>
<h2>结论</h2>
<p>我们在本文中一起介绍了trans piler的基础知识，并从设置、执行和速度的角度比较了两种JavaScript transpilers。通过这样做，我们了解到:</p>
<ul>
<li>它们的构建工作流的设置是相似的</li>
<li>然而，与巴贝尔相比，SWC有明显的速度优势</li>
</ul>
<p>因此，如果您正在使用Babel并考虑转换以获得更快的构建时间，请确保:</p>

<p>话虽如此，SWC背后的想法听起来很有希望，我们都将关注它的进展。</p>
<h2>资源</h2>

<p>使用<a class="signup" href="https://lp.logrocket.com/blg/signup" target="_blank" rel="noopener noreferrer"> LogRocket </a>消除传统错误报告的干扰</p><div class="code-block code-block-2">
<div class="blog-plug base-cta"><h2><a href="https://lp.logrocket.com/blg/signup" target="_blank" rel="noopener noreferrer"> LogRocket </a>是一个数字体验分析解决方案，它可以保护您免受数百个假阳性错误警报的影响，只针对几个真正重要的项目。LogRocket会告诉您应用程序中实际影响用户的最具影响力的bug和UX问题。</h2>
<a href="https://lp.logrocket.com/blg/signup" class="signup" target="_blank" rel="noopener noreferrer"><img class="alignnone size-full wp-image-46 jetpack-lazy-image" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/><noscript><img data-lazy-fallback="1" class="alignnone size-full wp-image-46" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/></noscript></a>
<p>然后，使用具有深层技术遥测的会话重放来确切地查看用户看到了什么以及是什么导致了问题，就像你在他们身后看一样。</p>
<p>LogRocket自动聚合客户端错误、JS异常、前端性能指标和用户交互。然后LogRocket使用机器学习来告诉你哪些问题正在影响大多数用户，并提供你需要修复它的上下文。</p>
<p>关注重要的bug—<a class="signup" href="https://lp.logrocket.com/blg/signup-issue-free" target="_blank" rel="noopener noreferrer">今天就试试LogRocket】。</a></p>
<p>Focus on the bugs that matter — <a class="signup" href="https://lp.logrocket.com/blg/signup-issue-free" target="_blank" rel="noopener noreferrer">try LogRocket today</a>.</p></div></div>

<p class="clearfix"/>
 <p class="clearfix"/>
</article>

</div>    
</body>
</html>
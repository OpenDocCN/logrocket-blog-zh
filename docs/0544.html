<html>
<head>
<title>React Hooks vs. Redux: Do Hooks and Context replace Redux? - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>React钩子vs. Redux:钩子和上下文会取代Redux吗？- LogRocket博客</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/react-hooks-context-redux-state-management/#0001-01-01">https://blog.logrocket.com/react-hooks-context-redux-state-management/#0001-01-01</a></blockquote><div><article class="article-post">
<p><em> <b>编者按:</b>本文最后更新于2022年6月15日，以反映React v18中所做的更改。</em></p>
<p>Redux Toolkit降低了将Redux引入我们的应用程序的复杂性。然而，除了React v16.8中引入的<code>useContext</code>和<code>useReducer</code>钩子之外，通过使用React上下文API，我们可以实现健壮的状态管理并避免prop drilling，而无需导入额外的库。</p>
<p>在最好的情况下，这使它成为React应用程序中状态管理的一个不完美的解决方案。然而，太多的React开发人员默认使用Redux进行状态管理，而没有考虑其他选择。</p>
<p>在本教程中，我们将向您介绍用于状态管理的<a href="https://reactjs.org/docs/context.html"> React上下文API </a>，并解释React钩子和上下文API如何取代Redux。</p>
<p>我们将讨论以下内容:</p>

<p>如果你更喜欢视觉学习，下面的视频描述了React Context API，并提供了为什么应该用React钩子和上下文替换Redux的一些理由。</p>
<p><span class="embed-youtube"> <iframe loading="lazy" class="youtube-player" src="https://www.youtube.com/embed/eBYJ7O482Dc?version=3&amp;rel=1&amp;showsearch=0&amp;showinfo=1&amp;iv_load_policy=1&amp;fs=1&amp;hl=en-US&amp;autohide=2&amp;start=1&amp;wmode=transparent" allowfullscreen="true" sandbox="allow-scripts allow-same-origin allow-popups allow-presentation">视频</iframe> </span></p>

<p>为了在React中处理断开的组件之间的数据，开发人员使用prop drilling。</p>
<p>没有组件可以访问的全局状态。因此，如果您想将数据从顶级组件传递到第五级组件，那么您必须将数据作为道具传递到树的每一级，直到到达您想要的组件。</p>
<p>这导致编写大量额外的代码，并且赋予组件永远不会使用的属性也会影响它们的架构设计。</p>
<p>为了解决这个问题，我们需要提供一个所有组件都可以访问的全局状态，不管它们的嵌套有多深。</p>
<p>通过解决这个问题，Redux，一个用于管理应用程序状态的开源JavaScript库，成为React开发人员的首选解决方案。</p>
<h2 id="why-switch-react-hooks-context">Redux vs. React钩子和上下文API</h2>
<p>在某种程度上，Redux对于React应用程序中的状态管理非常有效，并且有一些优点。然而，它的冗长使它很难学习，并且使它工作所需的额外代码会引入许多不必要的复杂性。</p>
<p>另一方面，有了React Hooks和<a href="https://podcasts.apple.com/us/podcast/podrocket-a-web-development-podcast-from-logrocket/id1539945251"> <code>useContext</code> API </a>，就不需要安装外部库或者添加一堆文件和文件夹来让我们的应用工作。这使得它成为React应用程序中处理全局状态管理的更简单、更直接的方法。</p>
<p>让我们仔细看看Redux、React Hooks和Context API，看看它们是如何工作的，开发人员在使用这些工具时面临哪些挑战，以及使用React Hooks和Context如何帮助您克服一些与Redux相关的常见问题。</p>
<h2 id="what-redux">Redux是什么？</h2>
<p>根据<a href="https://redux.js.org/"> Redux文档</a>，Redux是JavaScript应用程序的可预测状态容器，它帮助我们编写行为一致、在不同环境中运行且易于测试的应用程序。</p>
<p>正确钻取一个缺点是，它要求我们编写大量额外的代码来从顶级组件访问数据。对于Redux，这个缺点变得更加严重，因为它需要额外的代码来设置全局状态。Redux需要三个主要的构建部分来运行:动作、reducers和存储。</p>
<h3 id="actions">行动</h3>
<p>动作是用于向Redux存储发送数据的对象。它们通常有两个属性:一个<code>type</code>属性用于描述动作做什么，一个<code>payload</code>属性包含应该在应用程序状态中更改的信息:</p>
<pre class="language-javascript">// action.js
const reduxAction = payload =&gt; {
  return {
    type: 'action description',
    payload
  }
};

export default reduxAction;
</pre>
<p><code>type</code>通常全部大写，单词之间用下划线隔开。比如<code>SIGNUP_USER</code>或者<code>DELETE_USER_DATA</code>。</p>
<h3 id="reducers">还原剂</h3>
<p>Reducers是实现动作行为的纯函数。它们获取当前应用程序状态，执行一个操作，然后返回一个新状态:</p>
<pre class="language-javascript">const reducer = (state, action) =&gt; {
  const { type, payload } = action;
  switch(type){
    case "action type":
      return {
        ["action description"]: payload
      };
    default:
      return state;
  }
};

export default reducer;
</pre>
<h3 id="store">商店</h3>
<p>应用程序的状态保存在存储中。任何Redux应用程序中只有一个商店:</p>
<pre class="language-javascript">import { createStore } from 'redux'

const store = createStore(componentName);
</pre>
<p>由于我们的应用程序只能有一个Redux存储，为了给所有组件创建一个根Redux，我们需要Redux的<a href="https://redux.js.org/api/combinereducers"> <code>combineReducers</code> </a>方法。设置Redux需要大量的代码，想象一下当我们有多个组件要处理时，我们的代码库会是什么样子。</p>
<p>尽管Redux解决了我们的状态管理问题，但它使用起来确实非常耗时，有一个困难的学习曲线，并且给我们的应用程序带来了全新的复杂性。</p>
<p>幸运的是，React上下文API解决了这个问题。当与React Hooks结合使用时，我们有了一个状态管理解决方案，它的设置耗时更少，具有更简单的学习曲线，并且需要最少的代码。</p>
<h2 id="what-react-context-api">什么是React上下文API？</h2>
<p>React v16.3中引入了新的上下文API。React上下文使您能够共享React组件树的全局数据，如当前已验证的用户、主题或首选语言。</p>
<p>根据<a href="https://reactjs.org/docs/context.html"> React文档</a> , <span>上下文提供了一种通过组件树传递数据的方式，而不必在每一层手动向下传递属性。</span>本质上，React上下文API是React管理不直接连接的多个组件中的状态的方式。</p>
<p>为了创建上下文，我们将使用React的<code>createContext</code>方法，该方法接受一个参数作为其默认值:</p>
<pre class="language-javascript">import React, {createContext} from 'react';

const newContext = createContext({ color: 'black' });
</pre>
<p><code>createContext</code>方法返回一个带有<code>Provider</code>和<code>Consumer</code>组件的对象:</p>
<pre class="language-javascript">const { Provider, Consumer } = newContext;
</pre>
<p><code>Provider</code>组件使状态对所有子组件可用，不管它们在组件层次结构中的嵌套有多深。<code>Provider</code>组件接收一个<code>value</code>道具，我们将在这里传递当前值:</p>
<pre class="language-javascript">&lt;Provider value={color: 'blue'}&gt;
  {children}
&lt;/Provider&gt;
</pre>
<p>顾名思义，<code>Consumer</code>消耗来自<code>Provider</code>的数据，而不需要任何道具钻探:</p>
<pre class="language-javascript">&lt;Consumer&gt;
  {value =&gt; &lt;span&gt;{value}&lt;/span&gt;}}
&lt;/Consumer&gt;
</pre>
<p>如果没有钩子，与Redux相比，上下文API可能看起来不怎么样。但是，当与<code>useReducer</code>挂钩结合使用时，我们有了一个最终解决React中状态管理问题的解决方案。</p>
<h2 id="what-react-hooks"><strong>什么是React钩子？</strong></h2>
<p>钩子是一种能够在基础代码中执行定制代码的函数。钩子本质上是特殊的函数，允许我们钩入React的核心特性。</p>
<p>React钩子通过允许我们容易地处理功能组件的状态管理，提供了一种编写基于类的组件的替代方法。</p><div class="code-block code-block-54">
<hr/>
<h3>更多来自LogRocket的精彩文章:</h3>

<hr/></div>
<h3 id="usecontext-hook"><code>useContext</code>钩子</h3>
<p>您可能已经注意到，在描述React Context API时，我们需要将我们的内容包装在一个<code>Consumer</code>组件中，然后传递一个函数作为子组件，这样我们就可以访问或使用我们的状态。</p>
<p>这样做会引入不必要的组件嵌套，并增加代码的复杂性。挂钩让事情变得更加干净和简单。要用<code>useContext</code>钩子访问我们的状态，我们只需要用我们创建的<code>context</code>作为它的参数来调用它:</p>
<pre class="language-javascript">const newContext = React.createContext({ color: 'black' });

const value = useContext(newContext);

console.log(value); // this will return { color: 'black' }
</pre>
<p>现在，我们可以简单地通过<code>value</code>变量访问我们的状态，而不是将我们的内容包装在<code>Consumer</code>组件中。</p>
<h3 id="usereducer-hook"><code>useReducer</code>钩子</h3>
<p>React v16.8附带了<code>useReducer</code>钩子。就像JavaScript中的<code>reduce()</code>方法一样，<code>useReducer</code>钩子接收两个值作为它的参数，一个reducer函数和一个初始状态。然后，它返回一个新状态:</p>
<pre class="language-javascript">const [state, dispatch] = useReducer((state, action) =&gt; {
  const { type } = action;
  switch(action) {
    case 'action description':
      const newState = // do something with the action
      return newState;
    default:
      throw new Error()
  }
}, []);
</pre>
<p>在上面的代码块中，我们定义了状态和一个相应的方法<code>dispatch</code>来处理它。当我们调用<code>dispatch</code>方法时，<code>useReducer()</code>钩子将根据我们的方法在其动作参数中接收到的<code>type</code>执行一个动作:</p>
<pre class="language-javascript">...
return (
  &lt;button onClick={() =&gt;
    dispatch({ type: 'action type'})}&gt;
  &lt;/button&gt;
)
</pre>
<h2 id="usereducer-hook-react-context">如何在React上下文中使用<code>useReducer</code>钩子</h2>
<h3>建立我们的商店</h3>
<p>现在我们已经知道了上下文API和<code>useReducer</code>钩子是如何单独工作的，让我们看看当我们将它们结合起来为我们的应用程序获得理想的全局状态管理解决方案时会发生什么。</p>
<p>我们将在一个<code>store.js</code>文件中创建我们的全局状态:</p>
<pre class="language-javascript">// store.js
import React, {createContext, useReducer} from 'react';

const initialState = {};
const store = createContext(initialState);
const { Provider } = store;

const StateProvider = ( { children } ) =&gt; {
  const [state, dispatch] = useReducer((state, action) =&gt; {
    switch(action.type) {
      case 'action description':
        const newState = // do something with the action
        return newState;
      default:
        throw new Error();
    };
  }, initialState);

  return &lt;Provider value={{ state, dispatch }}&gt;{children}&lt;/Provider&gt;;
};

export { store, StateProvider }
</pre>
<p>在我们的<code>store.js</code>文件中，我们使用React中的<code>createContext()</code>方法来创建一个新的上下文。</p>
<p>记住，<code>createContext()</code>方法返回一个带有<code>Provider</code>和<code>Consumer</code>组件的对象。这一次，我们将只在需要访问我们的状态时使用<code>Provider</code>组件和<code>useContext</code>钩子。</p>
<p>注意我们是如何在<code>StateProvider</code>中使用<code>useReducer</code>钩子的。当我们需要操作我们的状态时，我们将调用<code>dispatch</code>方法并传入一个对象，将期望的<code>type</code>作为它的参数。</p>
<p>在我们的<code>StateProvider</code>中，我们用一个<code>state</code>的<code>value</code>道具和来自<code>useReducer</code>钩子的<code>dispatch</code>返回了我们的<code>Provider</code>组件。</p>
<h3>全局访问状态</h3>
<p>为了全局访问我们的状态，我们需要在我们的<code>StoreProvider</code>中包装我们的根<code>&lt;App/&gt;</code>组件，然后在我们的<code>ReactDOM.render()</code>函数中呈现它:</p>
<pre class="language-javascript">// root index.js file
import { createRoot } from "react-dom/client";
import App from './App';
import { StateProvider } from './store.js';

const rootElement = document.getElementById("root");
const root = createRoot(rootElement);

root.render(
  &lt;StateProvider&gt;
    &lt;App /&gt;
  &lt;/StateProvider&gt;
);
</pre>
<p>现在，我们的存储库<code>context</code>可以从组件树中的任何组件访问。为此，我们将从React导入<code>useContext</code>钩子，从我们的<code>./store.js</code>文件导入<code>store</code>:</p>
<pre class="language-javascript">// exampleComponent.js
import React, { useContext } from 'react';
import { store } from './store.js';

const ExampleComponent = () =&gt; {
  const globalState = useContext(store);
  console.log(globalState); // this will return { color: red }
};
</pre>
<h3>从状态中添加和移除数据</h3>
<p>我们已经看到了如何访问我们的全局状态。为了从我们的状态中添加和删除数据，我们将需要来自我们的<code>store</code>上下文的<code>dispatch</code>方法。我们只需要调用<code>dispatch</code>方法，并传入一个带有<code>type</code>参数的对象，即在我们的<code>StateProvider</code>组件中定义的动作描述:</p>
<pre class="language-javascript">// exampleComponent.js
import React, { useContext } from 'react';
import { store } from './store.js';

const ExampleComponent = () =&gt; {
  const globalState = useContext(store);
  const { dispatch } = globalState;

  dispatch({ type: 'action description' })
};

</pre>
<h2>结论</h2>
<p>在本教程中，我们探索了在React应用程序中使用Redux进行状态管理和使用React上下文API 以及<code>useContext</code>钩子和<code>useReducer</code>钩子的<a href="https://blog.logrocket.com/react-context-api-deep-dive-examples/">之间的区别。当我们使用Redux进行状态管理时，我们必须处理prop drilling，这意味着我们必须编写大量额外的代码来启动应用程序。通过使用上下文在组件中嵌套组件，父组件的所有功能在子组件中都可用。</a></p>
<p>我希望你喜欢这篇文章，如果你有任何问题，一定要留下评论。</p><div class="code-block code-block-17">
<div class="blog-plug inline-plug react-plug" vwo-el-id="26283398190">
<h2 vwo-el-id="41600691720"><a href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener"> LogRocket </a>:全面了解您的生产React应用</h2><p>调试React应用程序可能很困难，尤其是当用户遇到难以重现的问题时。如果您对监视和跟踪Redux状态、自动显示JavaScript错误以及跟踪缓慢的网络请求和组件加载时间感兴趣，</p><a href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" vwo-el-id="19356441070">try LogRocket</a><p>. </p><a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="19356441380">
<img class="first-react-image alignnone size-full wp-image-46 jetpack-lazy-image jetpack-lazy-image--handled" src="../Images/f300c244a1a1cf916df8b4cb02bec6c6.png" vwo-el-id="18272717540" data-lazy-loaded="1" data-original-src="https://files.readme.io/27c94e7-Image_2017-06-05_at_9.46.04_PM.png"/>
</a>
<a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="19356441690">
<img class="second-react-image alignnone size-full wp-image-46 jetpack-lazy-image jetpack-lazy-image--handled" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" vwo-el-id="30720362350" data-lazy-loaded="1" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/>
</a>
<p vwo-el-id="28675660440" class="">LogRocket 结合了会话回放、产品分析和错误跟踪，使软件团队能够创建理想的web和移动产品体验。这对你来说意味着什么？</p>
<p>LogRocket不是猜测错误发生的原因，也不是要求用户提供截图和日志转储，而是让您回放问题，就像它们发生在您自己的浏览器中一样，以快速了解哪里出错了。</p>
<p>不再有嘈杂的警报。智能错误跟踪允许您对问题进行分类，然后从中学习。获得有影响的用户问题的通知，而不是误报。警报越少，有用的信号越多。</p>
<p vwo-el-id="28675660750">LogRocket Redux中间件包为您的用户会话增加了一层额外的可见性。LogRocket记录Redux存储中的所有操作和状态。</p>
<p vwo-el-id="28675661060">现代化您调试React应用的方式— <a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="40093418840">开始免费监控</a>。</p>
</div></div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
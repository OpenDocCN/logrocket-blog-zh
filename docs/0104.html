<html>
<head>
<title>JavaScript ES6: 5 new abstractions to improve your code - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>JavaScript ES6: 5改进您的代码日志博客的新抽象</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/javascript-es6-5-new-abstractions-to-improve-your-code-54a369e82407/#0001-01-01">https://blog.logrocket.com/javascript-es6-5-new-abstractions-to-improve-your-code-54a369e82407/#0001-01-01</a></blockquote><div><article class="article-post">
<h4>利用强大的ES6特性编写更好、更优雅、更可预测的JavaScript。</h4>
<figure><img decoding="async" src="../Images/27268f7348e26bf6469661470c4fe7a8.png" data-height="1217" data-width="2000" data-lazy-src="https://storage.googleapis.com/blog-images-backup/1*JioH6ER4FMK_jUbZpIwf7w.jpeg?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" class=" jetpack-lazy-image" data-original-src="https://storage.googleapis.com/blog-images-backup/1*JioH6ER4FMK_jUbZpIwf7w.jpeg"/><noscript><img data-lazy-fallback="1" decoding="async" src="../Images/27268f7348e26bf6469661470c4fe7a8.png" data-height="1217" data-width="2000" data-original-src="https://storage.googleapis.com/blog-images-backup/1*JioH6ER4FMK_jUbZpIwf7w.jpeg"/></noscript></figure>
<p>JavaScript是一种非常强大的编程语言，可以在各种平台上运行，尤其是随着像<em> Node.js </em>这样的JavaScript运行时的出现。不同类别和水平的程序员越来越多地采用这种语言。</p>
<p>和大多数事情一样，自语言诞生以来，它的各种版本都有不少变化。然而，该语言的ES6规范(<em>通常称为ES2015 </em>)增加了许多语法改进和新功能。这使得编写JavaScript程序更高效，更少出错，而且更有趣。</p>
<p>这些新特性和语法改进包括:<em>类</em>，<em>模块</em>，<em>承诺</em>，<em>模板文字</em>，<em>析构</em>，<em>箭头函数</em>，<em>生成器</em>，<em>集合和映射</em>，<em>符号</em>，以及<em>类型化数组</em>，<em>代理</em>，</p>
<p>在本文中，我们将探索ES6的五个特性，并考虑如何利用它们来改进JavaScript代码。以下是感兴趣的特性:</p>
<ol>
<li><em>模板文字</em></li>
<li><em>默认和休息参数</em></li>
<li><em>箭头功能</em></li>
<li><em>解构</em></li>
<li><em>类</em></li>
</ol>
<hr/>
<figure><a href="https://logrocket.com/signup/" target="_blank" rel="noopener noreferrer"><img decoding="async" src="../Images/94b3e0f84b30cb0d321f60471481ab64.png" data-height="750" data-width="3212" data-lazy-src="https://storage.googleapis.com/blog-images-backup/1*GPjaPKNNUYHU8EsA3Z0JGA.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" class=" jetpack-lazy-image" data-original-src="https://storage.googleapis.com/blog-images-backup/1*GPjaPKNNUYHU8EsA3Z0JGA.png"/><noscript><img data-lazy-fallback="1" decoding="async" src="../Images/94b3e0f84b30cb0d321f60471481ab64.png" data-height="750" data-width="3212" data-original-src="https://storage.googleapis.com/blog-images-backup/1*GPjaPKNNUYHU8EsA3Z0JGA.png"/></noscript></a></figure>
<h3>1.模板文字</h3>
<p>在ES6中，引入了模板文字来处理一些与格式化和表示字符串相关的挑战。使用模板文字，您可以轻松地创建多行字符串。它还可以执行增强的字符串替换，并对看似危险的字符串(如要嵌入到HTML中的字符串)进行适当的格式化。</p>
<p>在ES6之前，字符串由一对<em>单引号</em> ( <code>‘string’</code>)或一对<em>双引号</em> ( <code>“string”</code>)分隔。在ES6中，字符串也可以用一对<em>反勾</em> ( <code>`string`</code>)来分隔。这样的字符串被称为<strong>模板文字</strong>。</p>
<p>正如单引号和双引号分隔符一样，如果字符串包含反勾号字符，反勾号也可以在模板文本中转义。要对模板文本中的反勾号字符进行转义，必须在反勾号字符之前放置一个反斜杠(<code/>)。但是请注意，在模板文本中，单引号和双引号不需要转义。</p>
<p>这里有一个简单的例子:</p>
<figure>
<pre><code>const greeting = `Good morning!`;
const shortcut = ``cmd` + `shift` + `G``;

console.log(greeting); // "Good morning!"
console.log(shortcut); // "`cmd` + `shift` + `G`"</code></pre>
</figure>
<p>以这种方式使用模板文字与使用由引号分隔的常规JavaScript字符串没有什么不同。当处理<em>多行字符串</em>、<em>字符串替换、</em>和<em>标记模板</em>时，我们开始获得真正的优势。</p>
<h4>多行字符串</h4>
<p>在ES6之前，JavaScript中的字符串被限制为一行。然而，在开始新行之前用反斜杠(<code/>)结束一行使得创建看似多行的字符串成为可能，即使新行不在字符串中输出:</p>
<figure>
<pre><code>const message = "Hello Glad, 
Your meeting is scheduled for noon today.";

console.log(message);
// Hello Glad, Your meeting is scheduled for noon today.</code></pre>
</figure>
<p>如果你想在字符串中输出一个换行符，你需要在换行符前使用换行符转义序列(<code>n</code>):</p>
<figure>
<pre><code>const message = "Hello Glad,n
Your meeting is scheduled for noon today.";

console.log(message);
// Hello Glad,
// Your meeting is scheduled for noon today.</code></pre>
</figure>
<blockquote><p>使用ES6模板文本，字符串输出时格式保持不变。</p></blockquote>
<p>字符串中的所有换行符和空格都被保留，这使得无需任何附加语法就可以轻松创建多行字符串。然而，由于保留了空白，所以在缩进字符串时应该小心。</p>
<p>考虑这个例子:</p>
<figure>
<pre><code>const html = (`
&lt;html&gt;
  &lt;body&gt;
    Template literals are super cool.
  &lt;/body&gt;
&lt;/html&gt;
`).trim();

console.log(html);
// &lt;html&gt;
//   &lt;body&gt;
//     Template literals are super cool.
//   &lt;/body&gt;
// &lt;/html&gt;</code></pre>
</figure>
<p>请注意，新行和缩进保留在字符串中。<code>trim()</code>方法也用于删除html字符串开头和结尾的任何换行符和空格。</p>
<h4>字符串替换</h4>
<p>模板文字也使字符串替换变得有趣。在ES6之前，<em>字符串连接</em>严重依赖于创建动态字符串。</p>
<p>这里有一个简单的例子:</p>
<figure>
<pre><code>const price = 24.99;

console.log("The item costs $" + price + " on the online store.");
// The item costs $24.99 on the online store.</code></pre>
</figure>
<p>使用ES6模板文字，可以按如下方式进行替换:</p>
<figure>
<pre><code>const price = 24.99;

console.log(`The item costs $${price} on the online store.`);
// The item costs $24.99 on the online store.</code></pre>
</figure>
<p>字符串替换由开始的<code>${</code>和结束的<code>}</code>分隔，并且可以在两者之间包含任何有效的JavaScript表达式。</p>
<p>在前面的例子中，我们将一个简单变量的值代入模板文本。假设我们想在商店所有商品的价格上增加10%的折扣。</p>
<p>它看起来是这样的:</p>
<figure>
<pre><code>const price = 24.99;
const discount = 10;

console.log(`The item costs $${(price * (100 - discount) / 100).toFixed(2)} on the online store.`);
// The item costs $22.49 on the online store.</code></pre>
</figure>
<p>这里，我们用一个JavaScript表达式的值来替代计算折扣价的值。</p>
<blockquote><p>模板文字本身就是JavaScript表达式，因此可以嵌套在其他模板文字中。</p></blockquote>
<h4>模板标签</h4>
<p>有了带标签的模板，您甚至可以更好地控制模板文字的替换和转换。一个<em>模板标签</em>仅仅是一个定义模板文字应该如何转换的函数。</p>
<p>模板标签函数可以接受多个参数。第一个参数是包含模板文本中所有文本字符串的数组。其余的参数对应于模板文本中的替换。因此，第二个参数对应于第一个替换，第三个参数对应于第二个替换，依此类推。</p>
<p>这里有一个简单的例子。给定以下模板文字:</p>
<pre><code>`The price of ${quantity} units of the item on the online store is $${quantity * price}.`</code></pre>
<p>为此模板文本传递给模板标记的第一个参数将是文本字符串数组，如下所示:</p>
<figure>
<pre><code>[
  'The price of ',
  ' units of the item on the online store is $',
  '.'
]</code></pre>
</figure>
<p>第二个参数将是<code>quantity</code>的值，第三个参数将是<code>(quantity * price)</code>的值。</p>
<p>让我们继续创建一个名为<code>pricing</code>的模板标签，我们可以用它来转换定价摘要。这将确保价格值四舍五入到小数点后两位。它还将确保在任何价格转换成<code>USD</code>之前的<code>$</code>货币符号。</p>
<p>下面是函数:</p>
<figure>
<pre><code>function pricing(literals, ...replacements) {
  // Initialize the final string
  let finalString = '';
  
  for (let i = 0; i &lt; replacements.length; i++) {
    // Get the current literal and replacement
    const literal = literals[i];
    const replacement = replacements[i];
    
    // Trim trailing whitespaces from the current literal
    const trimmed = literal.trimRight();
    const length = trimmed.length;
    
    // Check if current replacement is a number
    const isNumber = typeof replacement === 'number';
    
    // Check if current literal string ends with $
    const isPrice = /$$/.test(trimmed);
    
    // Check if number is followed by literal that ends with $
    // and use the desired formatting
    finalString += (isNumber &amp;&amp; isPrice)
      ? `${trimmed.substr(0, length - 1).trimRight()} USD ${replacement.toFixed(2)}`
      : `${literal}${replacement}`;
  }
  
  // Attach the last literal to the final string
  return finalString + literals[literals.length - 1];
}</code></pre>
</figure>
<p>您会注意到，在这段代码中，我们使用了一个名为<code>replacements</code>的rest参数来捕获模板文本中的所有替换。<em>我们将在下一节</em>中了解更多关于休息参数的信息。</p><div class="code-block code-block-54">
<hr/>
<h3>更多来自LogRocket的精彩文章:</h3>

<hr/></div>
<p>现在我们已经创建了一个模板标签，使用它是最简单的部分。</p>
<blockquote><p>要使用模板标签，只需在模板文字的第一个反勾号(<code>`</code>)分隔符之前附加模板标签的名称。</p></blockquote>
<p>下面是一个使用我们刚刚创建的<code>pricing</code>模板标签的例子:</p>
<figure>
<pre><code>const price = 24.99;
const discount = 10;
const quantity = 4;

const totalPrice = quantity * price * (100 - discount) / 100;

// WITHOUT TEMPLATE TAG
console.log(`The price of ${quantity} units of the item on the online store is $${totalPrice}.`);
// The price of 4 units of the item on the online store is $89.964.


// WITH TEMPLATE TAG (pricing)
console.log(pricing`The price of ${quantity} units of the item on the online store is $${totalPrice}.`);
// The price of 4 units of the item on the online store is USD 89.96.</code></pre>
</figure>
<hr/>
<h3>2.默认和静止参数</h3>
<p>JavaScript中的函数是非常重要的对象。很有可能你遇到过这样的说法:</p>
<blockquote><p>“职能是一等公民”。</p></blockquote>
<p>JavaScript函数也是如此，因为你可以在你的程序中传递它们，就像你传递其他常规值一样。</p>
<p>然而，JavaScript函数在ES6之前没有任何显著的语法改进。在ES6中，我们现在有了一些语法上的改进，比如<em>默认参数</em>、<em> rest参数</em>、<em>箭头函数</em>等。</p>
<h4>默认参数</h4>
<p>在ES6之前，基本上没有为函数参数设置默认值的语法。然而，当调用时没有向函数参数传递值时，有一些为函数参数设置后备值的技巧。这里有一个简单的例子:</p>
<figure>
<pre><code>// METHOD 1: Short-circuiting
// Using the logical OR (||) operator
function convertToBase(number, base) {
  number = parseInt(number) || 0;
  base = parseInt(base) || 10;
  
  return number.toString(base);
}

// METHOD 2: Ternary (?:) operator
// With additional type check (safer option)
function convertToBase(number, base) {
  number = (typeof number !== "undefined") ? parseInt(number) : 0;
  base = (typeof base !== "undefined") ? parseInt(base) : 10;
  
  return number.toString(base);
}</code></pre>
</figure>
<p>在这个代码片段中，我们已经能够为函数参数设置默认值。因此，这些参数的行为就像它们是可选的一样，因为当参数没有被传递时，会使用回退值。</p>
<p>在ES6中，您可以用默认值初始化函数参数，当参数未被传递或为<code>undefined</code>时将使用该默认值。下面是我们如何用默认参数重写之前的<code>convertToBase()</code>函数:</p>
<figure>
<pre><code>function convertToBase(number = 0, base = 10) {
  return parseInt(number).toString(parseInt(base));
}</code></pre>
</figure>
<p>ES6中的命名函数参数具有与<code>let</code>声明相同的行为。ES6中的默认值不仅限于文字值或原始值。</p>
<blockquote><p>任何JavaScript表达式也可以用作函数参数的默认值。</p></blockquote>
<p>这里有一个例子:</p>
<figure>
<pre><code>function getDefaultNumberBase() {
  return 10;
}

function convertToBase(number = 0, base = getDefaultNumberBase()) {
  return parseInt(number).toString(parseInt(base));
}</code></pre>
</figure>
<p>这里，我们使用来自<code>getDefaultNumberBase()</code>的返回值作为<code>base</code>参数的默认值。当设置另一个参数的默认值时，您甚至可以使用前一个参数的值。这里有一个例子:</p>
<pre><code>function cropImage(width, height = width) {
<em>// ...implementation
</em>}</code></pre>
<p>在这个代码片段中，<code>height</code>参数将被设置为<code>width</code>参数的值，只要它没有被传递或者它是<code>undefined</code>。</p>
<p>尽管在设置默认值时可以使用以前的参数值，但不能使用在函数体内声明的变量。这是因为默认参数有自己的作用域，它与函数体的作用域是分开的。</p>
<h4>休息参数</h4>
<p><code>arguments</code>对象是在调用时捕获传递给函数的所有参数的最终手段。这使得创建可以接受不同数量参数的重载函数成为可能。</p>
<blockquote><p>然而，<code>arguments</code>对象虽然类似于数组，但在对其执行某些数组操作之前，需要将其转换为实际的数组。</p></blockquote>
<p>这里有一个简单的例子:</p>
<figure>
<pre><code>function sum() {
  // Convert arguments to array
  var args = Array.prototype.slice.call(arguments);
  
  // Compute sum using array reduce()
  return args.reduce(function(a, b) { return a + Number(b) }, 0);
}</code></pre>
</figure>
<p>该函数计算传递给它的任意数量的参数之和。如果参数不是一个<code>number</code>，它会尝试使用<code>Number()</code>全局函数将其转换为一个数字。如果没有参数被传递，它将返回<code>0</code>。注意，为了使用<code>reduce()</code>方法，<code>arguments</code>对象首先被转换成一个数组，并赋给了<code>args</code>变量。</p>
<p>在ES6中，引入了<em>静止参数</em>。一个<strong> rest参数</strong> <strong>仅仅是一个</strong> <strong>命名的函数参数，前面有三个点</strong> ( <code>...</code>)。rest参数被赋予一个数组，该数组包含传递给函数的其余参数。下面是我们如何使用rest参数重写之前的<code>sum()</code>函数:</p>
<figure>
<pre><code>function sum(...args) {
  // Compute sum using array reduce()
  return args.reduce((a, b) =&gt; a + Number(b), 0);
}</code></pre>
</figure>
<p>关于rest参数的使用，有几点值得注意。</p>
<ol>
<li>一个函数只能有一个rest参数。</li>
<li>
<p>rest参数(如果存在)必须是最后一个参数。</p>
</li>
<li>
<p>rest参数与<code>arguments</code>对象不同。它只捕获其他命名参数之后剩余的参数，而<code>arguments</code>对象捕获传递给函数的所有参数。</p>
</li>
<li>
<p>rest参数不能在对象文本设置器中使用。</p>
</li>
</ol>
<h4>传播算子</h4>
<p>假设我们有一个包含班级学生分数的数组，我们想计算学生的平均分数。基本上，我们将首先计算分数的总和，然后将总和除以分数的数量。</p>
<p>我们可以使用在上一节中创建的<code>sum()</code>函数来计算分数的总和。然而，问题是我们有一个分数数组和sum expects数字作为参数。</p>
<p>在ES6之前，<code>Function.prototype.apply()</code>方法可以用来处理这样的情况。此方法将一个数组作为其第二个参数，该参数表示调用函数时应该使用的参数。</p>
<p>这里有一个例子:</p>
<figure>
<pre><code>const scores = [42, 68, 49, 83, 72, 65, 77, 74, 86, 51, 69, 47, 53, 58, 51];
const totalScore = sum.apply(null, scores);
const averageScore = totalScore / scores.length;

console.log(totalScore); // 945
console.log(averageScore); // 63</code></pre>
</figure>
<p>在ES6中，引入了一个新的操作符，称为<em>扩展操作符</em> ( <code>...</code>)。它与rest参数密切相关，对于处理数组和其他<em>迭代</em>非常有用。使用扩展运算符，我们可以如下计算<code>totalScore</code>:</p>
<pre><code>const totalScore = sum(...scores);</code></pre>
<blockquote><p>因此，对于大多数用例，spread操作符是对<code>Function.prototype.apply()</code>方法的一个很好的替代。</p></blockquote>
<h3>3.箭头功能</h3>
<p>ES6中另一个非常重要的语法改进是引入了<em>箭头函数</em>。Arrow函数使用了一种全新的语法，当以它们最适合的方式使用时，它提供了一些很大的优势。</p>
<p>箭头函数的语法省略了<code>function</code>关键字。此外，使用<em>箭头</em> ( <code>=&gt;</code>)将函数参数与函数体分开，因此得名<em>箭头函数</em>。</p>
<p>尽管箭头函数比常规函数更紧凑、更短，但它们在某些定义使用方式的方面与常规函数有很大不同:</p>
<ol>
<li>箭头函数不能用作构造函数，它们没有原型。因此，在箭头函数中使用<code>new</code>关键字通常会导致错误。</li>
<li>
<p>箭头函数没有<code>arguments</code>对象，因此函数参数必须使用命名参数和rest参数。也不允许使用重复的命名参数。</p>
</li>
<li>
<p>箭头函数内部的<code>this</code>绑定不能修改，它总是指向最近的非箭头父函数。</p>
</li>
</ol>
<h4>箭头函数语法</h4>
<p>箭头函数可能看起来略有不同，这取决于您想要实现的目标。</p>
<p>让我们来看看一些表格:</p>
<p><strong>无参数</strong></p>
<p>如果arrow函数没有参数，则必须在箭头(<code>=&gt;</code>)前使用一对空括号(<code>()</code>)，如下面的代码片段所示。</p>
<figure>
<pre><code>// USING REGULAR FUNCTION
const getTimestamp = function() {
  return +new Date;
}

// USING ARROW FUNCTION
const getTimestamp = () =&gt; {
  return +new Date;
}</code></pre>
</figure>
<p>对于像这样只返回JavaScript表达式值的非常简单的箭头函数，可以省略函数体周围的关键字<code>return</code>和一对花括号(<code>{}</code>)。</p>
<p>因此，arrow函数可以重写为:</p>
<pre><code>const getTimestamp = () =&gt; +new Date;</code></pre>
<p>但是，如果从arrow函数返回一个对象文字，则需要用一对括号(<code>()</code>)将它括起来，否则JavaScript引擎会将对象文字的花括号(<code>{}</code>)视为包含函数体，这将导致语法错误。这里有一个例子:</p>
<figure>
<pre><code>// Returned object literal wrapped in parentheses
const getProfile = () =&gt; ({
  name: 'Glad Chinda',
  gender: 'Male',
  birthday: 'August 15'
});</code></pre>
</figure>
<p><strong>带参数</strong></p>
<p>对于只接受一个命名参数的箭头函数，可以省略参数列表周围的括号对，如下面的代码片段所示:</p>
<figure>
<pre><code>// Pair of parentheses is omitted
const computeSquare = num =&gt; num * num;</code></pre>
</figure>
<p>但是，有些情况下不能省略参数列表周围的括号。下面是一些这样的情况:</p>
<ol>
<li>当有多个命名参数时</li>
</ol>
<figure>
<pre><code>// Pair of parentheses cannot be omitted
const addNumbers = (numA, numB) =&gt; numA + numB;</code></pre>
</figure>
<p>2.当有默认参数时，即使它是唯一的参数</p>
<figure>
<pre><code>// The traditional function body wrapped in curly braces
// is used here to aid readability.
// Pair of parentheses cannot be omitted

const factorial = (n = 1) =&gt; {
  return (n &lt;= 1) ? 1 : n * factorial(n - 1);
}</code></pre>
</figure>
<p>3.当有rest参数时，即使它是唯一的参数</p>
<figure>
<pre><code>// Pair of parentheses cannot be omitted
const range = (...numbers) =&gt; Math.max(...numbers) - Math.min(...numbers);</code></pre>
</figure>
<p>4.当有一个析构参数时，即使它是唯一的参数</p>
<figure>
<pre><code>// Pair of parentheses cannot be omitted
const extractName = ({ name = null }) =&gt; name;

console.log(extractName({
  name: 'Glad Chinda',
  role: 'author'
})); // "Glad Chinda"</code></pre>
</figure>
<p><strong>传统功能体</strong></p>
<p>如前所示，非常简单的箭头函数只返回JavaScript表达式的值，可以省略函数体周围的关键字<code>return</code>和一对花括号(<code>{}</code>)。但是，如果您愿意，您仍然可以使用传统的函数体，尤其是当函数有多个语句时。</p>
<figure>
<pre><code>const snakeCase = value =&gt; {
  const regex = /[A-Z][^A-Z]+/g;
  const withoutSpaces = value.trim().replace(/s+/g, '_');
  
  const caps = withoutSpaces.match(regex);
  const splits = withoutSpaces.split(regex);
  
  let finalString = splits.shift();
  
  for (let i = 0; i &lt; splits.length; i++) {
    finalString += `${caps[i]}_${splits[i]}_`;
  }
  
  return finalString
    .toLowerCase()
    .replace(/_+/g, '_')
    .replace(/^_?(.+?)_?$/, '$1');
}</code></pre>
</figure>
<p>上面的函数试图模仿JavaScript库<em> Lodash </em>的<code>snakeCase()</code>方法。这里，我们必须使用传统的用花括号(<code>{}</code>)括起来的函数体，因为函数体内有如此多的JavaScript语句。</p>
<blockquote><p>与常规函数不同，箭头函数不存在<code>arguments</code>对象。但是，他们可以访问非箭头父函数的<code>arguments</code>对象。</p></blockquote>
<figure>
<pre><code>function fetchLastScore() {
  return () =&gt; {
    console.log(arguments[arguments.length - 1]);
  }
}

fetchLastScore(42, 68, 49, 83, 72)(); // 72</code></pre>
</figure>
<h4>立即调用函数表达式(IIFEs)</h4>
<p>JavaScript中函数的一个有用应用是在<em>立即调用函数表达式(IIFEs) </em>中观察到的，这些函数是<strong> <em>函数，它们被立即定义和调用，而不保存对函数</em> </strong>的引用。这种函数应用通常见于一次性初始化脚本、JavaScript库，这些脚本库公开了类似<em> jQuery </em>等模块化公共接口。</p>
<p>使用常规的JavaScript函数，IIFEs通常采用以下形式之一:</p>
<figure>
<pre><code>// FIRST FORM:
// Wrap the function expression in parentheses
// The invocation expression comes afterwards

(function(a, b) {
  // ...function body here
})(arg1, arg2);


// SECOND FORM:
// Wrap the function expression together with
// the invocation expression in parentheses

(function(a, b) {
  // ...function body here
}(arg1, arg2));</code></pre>
</figure>
<p>如果arrow函数用括号括起来，arrow函数语法也可以与IIFEs一起使用。</p>
<figure>
<pre><code>// IIFE: With Arrow Function
// The arrow function is called immediately with a list of arguments
// and the return value is assigned to the `compute` variable

const compute = ((...numbers) =&gt; {

  // Private members
  
  const length = numbers.length;
  const min = Math.min(...numbers);
  const max = Math.max(...numbers);
  
  const sum = numbers.reduce((a, b) =&gt; a + Number(b), 0);
  
  // Expose an inteface of public methods
  
  return {
    sum: () =&gt; sum,
    avg: () =&gt; sum / length,
    range: () =&gt; max - min
  };
  
})(42, 68, 49, 83, 72, 65, 77, 74, 86, 51, 69, 47, 53, 58, 51);


// Access the exposed public methods

console.log(compute.sum()); // 945
console.log(compute.avg()); // 63
console.log(compute.range()); // 44</code></pre>
</figure>
<h4>回调函数</h4>
<p>回调函数在异步程序中大量使用，在数组方法中也大量使用，如<code>map()</code>、<code>filter()</code>、<code>forEach()</code>、<code>reduce()</code>、<code>sort()</code>、<code>find()</code>、<code>findIndex()</code>等。</p>
<blockquote><p>箭头函数非常适合用作回调函数。</p></blockquote>
<p>在前面的代码片段中，我们看到了arrow函数如何与<code>reduce()</code>一起使用来计算一组数字的总和。使用箭头功能更紧凑、更整洁。同样，这里是比较:</p>
<figure>
<pre><code>// WITHOUT ARROW FUNCTION
const sum = numbers.reduce(function(a, b) {
  return a + Number(b);
}, 0);

// WITH ARROW FUNCTION
const sum = numbers.reduce((a, b) =&gt; a + Number(b), 0);</code></pre>
</figure>
<p>让我们做一些更复杂的事情来演示如何使用arrow函数作为数组回调来帮助我们用更少的代码完成更多的工作。我们将模仿JavaScript库<em> Lodash </em>的<code>flattenDeep()</code>方法。此方法递归展平数组。然而，在我们的实现中，我们将递归地展平传递给函数的参数数组。</p>
<p>下面是<code>flattenDeep()</code>函数的代码片段:</p>
<figure>
<pre><code>const flattenDeep = (...args) =&gt; args.reduce(
  (a, b) =&gt; [].concat(a, Array.isArray(b) ? flattenDeep(...b) : b)
);
</code></pre>
</figure>
<p>这就是箭头函数在用作回调函数时有多酷，尤其是在使用接受回调函数的数组方法时。</p>
<h4>这和箭头功能</h4>
<p>许多JavaScript程序中混淆和错误的一个主要来源是<code>this</code>的值解析。</p>
<blockquote><p>根据函数调用的范围和上下文，解析为不同的值。</p></blockquote>
<p>例如，当使用<code>new</code>关键字调用一个函数时，<code>this</code>指向由构造函数创建的实例，然而，当没有使用<code>new</code>关键字调用同一个函数时，<code>this</code>指向全局对象(在<em>非严格模式下</em>)，该对象在浏览器环境中是<code>window</code>对象。</p>
<p>这里有一个简单的例子。在下面的代码片段中，不带<code>new</code>关键字调用<code>Person()</code>会意外创建一个名为<code>name</code>的全局变量，因为该函数处于<em>非严格模式</em>。</p>
<figure>
<pre><code>function Person(name) {
  this.name = name;
}

var person = Person('Glad Chinda');

console.log(person); // undefined
console.log(name); // "Glad Chinda"
console.log(window.name); // "Glad Chinda"</code></pre>
</figure>
<p>与<code>this</code>混淆的另一个常见原因是DOM事件监听器。</p>
<blockquote><p>在事件监听器中，<code>this</code>指向事件所指向的DOM元素。</p></blockquote>
<p>考虑下面的代码片段:</p>
<figure>
<pre><code>function ScrollController(offset) {
  this.offsets = { offsetY: offset };
}

ScrollController.prototype.registerScrollHandler = function() {
  window.addEventListener('scroll', function(event) {
    if (window.scrollY === this.offsets.offsetY) {
      console.log(`${this.offsets.offsetY}px`);
    }
  }, false);
}

var controller = new ScrollController(100);
controller.registerScrollHandler();</code></pre>
</figure>
<p>这段代码看起来一切都很好。但是，当您开始垂直滚动浏览器窗口时，您会看到控制台上记录了一个错误。错误的原因是<code>this.offsets</code>是<code>undefined</code>，我们试图访问<code>undefined</code>的<code>offsetY</code>属性。</p>
<p>问题是:<strong>怎么可能</strong> <code><strong>this.offsets</strong></code> <strong>就是</strong> <code><strong>undefined</strong></code> <strong>？</strong></p>
<p>这是因为事件侦听器中的<code>this</code>的值不同于封闭原型函数中的<code>this</code>的值。事件监听器中的<code>this</code>指向<code>window</code>，T3是事件目标，<code>offsets</code>在<code>window</code>上不作为属性存在。因此，事件监听器内部的<code>this.offsets</code>是<code>undefined</code>。</p>
<p><code>Function.prototype.bind()</code>可用于显式设置函数的<code>this</code>绑定。下面是如何通过使用<code>Function.prototype.bind()</code>显式设置<code>this</code>绑定来修复错误:</p>
<figure>
<pre><code>// Using .bind() on event listener to resolve the value of `this`

ScrollController.prototype.registerScrollHandler = function() {
  this.element.addEventListener('scroll', (function(event) {
    if (window.scrollY === this.offsets.offsetY) {
      console.log(`${this.offsets.offsetY}px`);
    }
  }).bind(this), false);
}</code></pre>
</figure>
<p>在这里，我们用圆括号将事件侦听器包装起来，并调用了从封闭原型函数传递值<code>this</code>的<code>bind()</code>方法。调用<code>bind()</code>实际上会返回一个带有指定<code>this</code>绑定的新函数。现在一切都很完美，没有任何错误。</p>
<blockquote><p>对于ES6箭头功能，没有<code>this</code>绑定。因此，箭头函数使用来自其最近的非箭头函数祖先的值<code>this</code>。</p></blockquote>
<p>在像我们这样的情况下，不使用实际返回新函数的<code>bind()</code>,我们可以使用箭头函数——因为来自封闭原型函数的<code>this</code>绑定被保留。</p>
<p>这是:</p>
<figure>
<pre><code>// Using arrow function for event listener

ScrollController.prototype.registerScrollHandler = function() {
  this.element.addEventListener('scroll', event =&gt; {
    if (window.scrollY === this.offsets.offsetY) {
      console.log(`${this.offsets.offsetY}px`);
    }
  }, false);
}</code></pre>
</figure>
<hr/>
<h3>4.解构</h3>
<p>析构是JavaScript语法的另一个非常重要的改进。<em>析构</em>使得从复杂结构(如数组和对象)中访问局部变量并为其赋值成为可能，无论这些值在父数组或对象中的嵌套有多深。析构有两种形式:<strong>析构对象</strong>和<strong>析构数组</strong>。</p>
<h4>对象析构</h4>
<p>为了说明对象析构，假设我们有一个国家对象，如下所示:</p>
<figure>
<pre><code>const country = {
  name: 'Nigeria',
  region: 'Africa',
  codes: {
    cca2: 'NG',
    dialcode: '+234'
  },
  cities: [
    'Lagos',
    'Abuja',
    'Port Harcourt',
    'Benin',
    'Ibadan',
    'Calabar',
    'Warri'
  ]
}</code></pre>
</figure>
<p>我们想向游客展示一些关于这个国家的信息。下面的代码片段展示了一个非常基本的<code>countryInfo()</code>函数，它就是这样做的:</p>
<figure>
<pre><code>function countryInfo(country) {
  const name = country.name;
  const region = country.region || 'the world';
  const code2 = country.codes.cca2;
  const dialcode = country.codes.dialcode;
  const cities = country.cities;
  
  return (
`
COUNTRY TIPS:

${name}(${code2}) is one of the largest countries in ${region}.
There are so many important cities you can visit in ${name}
and here are some of them:

${cities.slice(0, 3).join(', ')} and ${cities.slice(3).length} others.

Phone numbers in ${name} usually begin with ${dialcode}.
`
  ).trim();
}

console.log(countryInfo(country));

// COUNTRY TIPS:
//
// Nigeria(NG) is one of the largest countries in Africa.
// There are so many important cities you can visit in Nigeria
// and here are some of them:
//
// Lagos, Abuja, Port Harcourt and 4 others.
//
// Phone numbers in Nigeria usually begin with +234.</code></pre>
</figure>
<p>在这个代码片段中，我们已经能够从country对象中提取一些值，并将它们分配给<code>countryInfo()</code>函数中的局部变量——效果非常好。</p>
<p>使用ES6析构，我们可以提取这些值，并用更优雅、更简洁的语法将它们赋给变量。下面是旧代码片段和ES6析构的比较:</p>
<figure>
<pre><code>// OLD METHOD
const name = country.name;
const region = country.region || 'the world';
const code2 = country.codes.cca2;
const dialcode = country.codes.dialcode;
const cities = country.cities;

// ES6 DESTRUCTURING
const {
  name,
  region = 'the world',
  codes: { cca2: code2, dialcode },
  cities
} = country;</code></pre>
</figure>
<p>上面代码片段中的这种析构形式被称为<em>对象析构</em>——因为我们从一个对象中提取值并将它们赋给局部变量。</p>
<blockquote><p>对于对象析构，在赋值表达式的左边使用对象文字。</p></blockquote>
<p>您甚至可以对函数参数使用对象析构，如下面的代码片段所示:</p>
<figure>
<pre><code>const person = {
  name: 'Glad Chinda',
  birthday: 'August 15'
}

// FUNCTION WITHOUT DESTRUCTURED PARAMETERS
function aboutPerson(person = {}) {
  const { name, birthday, age = 'just a few' } = person;
  
  console.log(`My name is ${name} and I'm ${age} years old. I celebrate my birthday on ${birthday} every year.`);
}

// FUNCTION WITH DESTRUCTURED PARAMETERS
function aboutPerson({ name, birthday, age = 'just a few' } = {}) {
  console.log(`My name is ${name} and I'm ${age} years old. I celebrate my birthday on ${birthday} every year.`);
}

aboutPerson(person);

// My name is Glad Chinda and I'm just a few years old. I celebrate my birthday on August 15 every year.</code></pre>
</figure>
<h4>数组破坏</h4>
<p>数组析构用于从数组中提取值并将它们赋给局部变量。假设我们将一种颜色的RGB(红绿蓝)值表示为数组，如下所示:</p>
<pre><code>const color = [240, 80, 124];</code></pre>
<p>我们想要显示给定颜色的RGB值。下面是如何通过数组析构来实现的。</p>
<figure>
<pre><code>// Array Destructuring
const [red, green, blue] = color;

console.log(`R: ${red}, G: ${green}, B: ${blue}`);
// R: 240, G: 80, B: 124</code></pre>
</figure>
<blockquote><p>对于数组析构，数组文字用在赋值表达式的左边。</p></blockquote>
<p>通过数组析构，可以跳过不需要的赋值。假设我们只想要颜色的蓝色值。下面是我们如何跳过红色和绿色值，而不把它们赋给局部变量。</p>
<figure>
<pre><code>const [,, blue] = color;

console.log(`B: ${blue}`);
// B: 124</code></pre>
</figure>
<p>数组析构也可以和函数参数一起使用，就像对象析构一样。然而，还有其他一些方法可以用来解决常见的问题。</p>
<p>一个非常重要的用例是在<strong>交换变量</strong>。假设我们想在数据库中搜索存储在两个日期之间的记录。我们可以编写一个简单的函数，接受两个<code>Date</code>对象:<code>fromDate</code>和<code>toDate</code>，如下所示:</p>
<pre><code>function fetchDatabaseRecords(fromDate, toDate) {
<em>// ...execute database query
</em>}</code></pre>
<p>我们希望确保<code>fromDate</code>总是在<code>toDate</code>之前——因此我们希望在<code>fromDate</code>在<code>toDate</code>之后的情况下简单地交换日期。下面是我们如何使用数组析构来交换日期:</p>
<figure>
<pre><code>function fetchDatabaseRecords(fromDate, toDate) {
  if (fromDate &gt; toDate) {
    // swap the dates using array destructuring
    [fromDate, toDate] = [toDate, fromDate];
  }
  
  // ...execute database query
}</code></pre>
</figure>
<blockquote><p>关于析构的更详细的指南，你可以看看<a href="https://codeburst.io/es6-destructuring-the-complete-guide-7f842d08b98f" target="_blank" rel="noopener noreferrer"> ES6析构:完整指南</a>。</p></blockquote>
<hr/>
<h3>5.班级</h3>
<p>类是一些JavaScript开发人员长期以来一直想要的一个特性，尤其是那些以前有过其他面向对象编程语言经验的人。JavaScript ES6语法增强最终包括了类。</p>
<p>尽管类现在是JavaScript的一部分，但它们的行为方式与其他经典编程语言并不完全相同。它们更像是以前模拟基于类的行为的方法的语法糖。因此，它们仍然基于JavaScript的原型继承模型工作。</p>
<p>在ES6之前，类是使用<em>构造函数</em>模拟的，实例方法基本上是通过增强构造函数的原型创建的。因此，当用关键字<code>new</code>调用构造函数时，它返回一个构造函数类型的实例，该实例可以访问其原型中的所有方法。<code>this</code>的值指向构造函数实例。</p>
<p>这里有一个例子:</p>
<figure>
<pre><code>// The Rectangle constructor
function Rectangle(length, breadth) {
  this.length = length || 10;
  this.breadth = breadth || 10;
}

// An instance method
Rectangle.prototype.computeArea = function() {
  return this.length * this.breadth;
}

// Create an instance using the new keyword
var rectangle = new Rectangle(50, 20);

console.log(rectangle.computeArea()); // 1000

// rectangle is also an instance of Object
// Due to JavaScript's prototypal inheritance
console.log(rectangle instanceof Rectangle); // true
console.log(rectangle instanceof Object); // true</code></pre>
</figure>
<h4>类别语法</h4>
<p>类和函数在很多方面都很相似。正如函数一样，可以使用<em>类声明</em>和<em>类表达式</em>使用<code>class</code>关键字来定义类。</p>
<blockquote><p>与函数一样，类是第一手公民，可以作为值在程序中传递。</p></blockquote>
<p>然而，类和函数之间有一些显著的不同。</p>
<ol>
<li>类声明没有被提升，其行为类似于<code>let</code>声明。</li>
<li>
<p>类构造函数必须总是用<code>new</code>调用，而类方法不能用<code>new</code>调用。</p>
</li>
<li>
<p>类定义代码总是处于<em>严格模式</em>。</p>
</li>
<li>
<p>所有的类方法都是不可枚举的。</p>
</li>
<li>
<p>不能从类内部修改类名。</p>
</li>
</ol>
<p>下面是我们之前使用类语法重写的<code>Rectangle</code>类型:</p>
<figure>
<pre><code>class Rectangle {
  // The class constructor
  constructor(length, breadth) {
    this.length = length || 10;
    this.breadth = breadth || 10;
  }
  
  // An instance method
  computeArea() {
    return this.length * this.breadth;
  }
}

// Create an instance using the new keyword
const rectangle = new Rectangle(50, 20);

console.log(rectangle.computeArea()); // 1000

// rectangle is also an instance of Object
// Due to JavaScript's prototypal inheritance
console.log(rectangle instanceof Rectangle); // true
console.log(rectangle instanceof Object); // true

console.log(typeof Rectangle); // function
console.log(typeof Rectangle.prototype.computeArea); // function</code></pre>
</figure>
<p>这里，我们使用一个特殊的<code>constructor()</code>方法来定义类构造函数逻辑，并设置所有的实例属性。事实上，无论何时在一个类上使用<code>typeof</code>操作符，它都会返回<code>“function”</code>——无论是否为该类显式定义了构造函数。</p>
<p>还要注意的是，<code>computeArea()</code>实例方法实际上是添加到底层类构造函数的原型对象中的。这就是为什么在<code>Rectangle.prototype.computeArea</code>上使用<code>typeof</code>操作符也会返回<code>“function”</code>的原因。</p>
<p>基于这些相似性，您可以得出这样的结论:类语法主要是在前面用于创建自定义类型的方法之上的语法糖。</p>
<p>让我们看另一个稍微复杂一点的例子，演示如何使用类表达式并将类作为参数传递给函数。</p>
<figure>
<pre><code>// An anonymous class expression
// assigned to a variable
const Rectangle = class {

  // The class constructor
  constructor(length, breadth) {
    this.length = length || 10;
    this.breadth = breadth || 10;
  }
  
  // An instance method
  computeArea() {
    return this.length * this.breadth;
  }
  
}

// A class passed as argument to a function
// Notice how the class is instantiated with new
const computeArea = (Shape, ...dimensions) =&gt; {
  return (new Shape(...dimensions)).computeArea();
}

console.log(computeArea(Rectangle, 50, 20)); // 1000</code></pre>
</figure>
<p>这里，我们首先创建了一个匿名的类表达式，并将其赋给了<code>Rectangle</code>变量。接下来，我们创建了一个函数，它接受一个<code>Shape</code>类作为第一个参数，接受实例化<code>Shape</code>的维度作为剩余的参数。代码片段假设它接收的任何<code>Shape</code>类都实现了<code>computeArea()</code>方法。</p>
<h4>扩展类</h4>
<p>就像其他面向对象的编程语言一样，JavaScript类具有类扩展的功能。因此，可以从<em>父</em>类创建具有修改功能的<em>派生</em>或<em>子</em>类。</p>
<p>假设我们有一个用于创建矩形的<code>Rectangle</code>类，我们想要创建一个用于创建等长和等宽的矩形(正方形)的<code>Square</code>类。我们可以这样做:</p>
<figure>
<pre><code>class Rectangle {
  constructor(length, breadth) {
    this.length = length || 10;
    this.breadth = breadth || 10;
  }
  
  computeArea() {
    return this.length * this.breadth;
  }
}

// The Square class extends the Rectangle class
class Square extends Rectangle {

  constructor(length) {
    // super() calls the constructor of the parent class
    super(length, length);
  }
  
}

const square = new Square;

// Square inherits the methods and properties of Rectangle
console.log(square.length); // 10
console.log(square.breadth); // 10
console.log(square.computeArea()); // 100

// square is also an instance of Rectangle
console.log(square instanceof Square); // true
console.log(square instanceof Rectangle); // true</code></pre>
</figure>
<p>首先，注意<code>extends</code>关键字的使用，它表明我们想要从父类创建一个派生类。</p>
<blockquote><p>派生类继承父类原型中的所有属性和方法，包括构造函数。</p></blockquote>
<p>还要注意，我们使用一个<code>super</code>引用从派生类的构造函数中调用父类的构造函数。当您想要增强派生类中继承方法的功能时，这非常有用。</p>
<p>例如，从<code>Square</code>类中调用<code>super.computeArea()</code>将调用在<code>Rectangle</code>类中实现的<code>computeArea()</code>方法。</p>
<blockquote><p>对<code>super()</code>的调用必须在每个派生类的构造函数中进行，并且必须在引用<code>this</code>之前进行。</p></blockquote>
<p>这是因为调用<code>super()</code>设置了<code>this</code>的值。然而，<code>super()</code>不应该在非派生类中使用，因为它被认为是一个语法错误。</p>
<p>创建派生类不仅限于扩展类。派生类通常是通过扩展任何可以用作构造函数并且具有原型的JavaScript表达式来创建的，比如JavaScript函数。因此，以下是可能的:</p>
<figure>
<pre><code>function Person(name) {
  this.name = name || 'Glad Chinda';
}

Person.prototype.getGender = function() {
  return this.gender;
}

class Male extends Person {
  constructor(name) {
    super(name);
    this.gender = 'MALE';
  }
}

const me = new Male;

// Male inherits the methods and properties of Person
console.log(me.getGender()); // "MALE"

// me is also an instance of Person
console.log(me instanceof Male); // true
console.log(me instanceof Person); // true</code></pre>
</figure>
<h4>静态类成员</h4>
<p id="4e05" class="graf graf--p graf-after--h4">到目前为止，我们一直在看<em class="markup--em markup--p-em">实例方法</em>和<em class="markup--em markup--p-em">属性</em>。有时候你需要直接应用于类的<em class="markup--em markup--p-em">静态方法</em>或<em class="markup--em markup--p-em">属性</em>，并且不会从一个实例改变到另一个实例。在ES6之前，静态成员可以按如下方式添加:</p>
<pre>function Lion() {
  // constructor function
}

// Static property
Lion.category = 'ANIMAL';

// Static method
Lion.animalType = function() {
  return 'CAT';
}

console.log(Lion.category); // "ANIMAL"
console.log(Lion.animalType()); // "CAT"
</pre>
<p>对于ES6类，<code>static</code>关键字被放在方法名之前，以表明该方法是一个<em class="markup--em markup--p-em">静态方法</em>。然而，<em class="markup--em markup--p-em">静态属性</em>不能从类内部创建。下面是我们如何创建静态成员:</p>
<pre>class Lion {
  // Static method
  static animalType() {
    return 'CAT';
  }
}

// Static property
Lion.category = 'ANIMAL';

console.log(Lion.category); // "ANIMAL"
console.log(Lion.animalType()); // "CAT"</pre>
<blockquote><p>静态类成员也由派生类继承。它们可以被派生类重写，就像实例方法和属性一样。</p></blockquote>
<p id="7ad2" class="graf graf--p graf-after--pullquote">这里有一个简单的例子:</p>
<pre>class Lion {
  // Static method
  static animalType() {
    return 'CAT';
  }
}

// Static property
Lion.category = 'ANIMAL';

// Derived Lioness class
class Lioness extends Lion {

  // Override static method
  static animalType() {
    return `${super.animalType()}::LION`;
  }
  
}

console.log(Lioness.category); // "ANIMAL"
console.log(Lioness.animalType()); // "CAT::LION"</pre>
<h4 id="725b" class="graf graf--h4 graf-after--figure">更多功能</h4>
<p id="7f2f" class="graf graf--p graf-after--h4">还有几个值得考虑的类特性，其中之一是<strong class="markup--strong markup--p-strong"> <em class="markup--em markup--p-em">访问器属性</em> </strong>。在需要在类原型上有属性的情况下，它们会非常有用。</p>
<p id="a9e5" class="graf graf--p graf-after--p">这里有一个简单的例子:</p>
<pre>class Person {
  constructor(firstname, lastname) {
    this.firstname = firstname || 'Glad';
    this.lastname = lastname || 'Chinda';
  }
  
  get fullname() {
    return `${this.firstname} ${this.lastname}`;
  }
  
  set fullname(value) {
    const [ firstname, lastname ] = value.split(' ');
    if (firstname) this.firstname = firstname;
    if (lastname) this.lastname = lastname;
  }
}

const me = new Person;
console.log(me.fullname); // "Glad Chinda"

me.fullname = "Jamie";
console.log(me.fullname); // "Jamie Chinda"

me.fullname = "John Doe (Junior)";
console.log(me.fullname); // "John Doe"</pre>
<p id="8be7" class="graf graf--p graf-after--figure">类的另一个非常类似于对象文字的好特性是能够为类成员使用<strong class="markup--strong markup--p-strong"> <em class="markup--em markup--p-em">计算名称</em> </strong>。这些计算出的名称也可以用于访问者属性。</p>
<blockquote id="2857" class="graf graf--pullquote graf-after--p"><p>计算出的名称通常是包含在一对<em class="markup--em markup--pullquote-em">方括号</em> ([])之间的JavaScript表达式。</p></blockquote>
<p id="ffc1" class="graf graf--p graf-after--pullquote">这里有一个简单的例子:</p>
<pre>const prefix = 'compute';

class Square {
  constructor(length) {
    this.length = length || 10;
  }
  
  // A computed class method
  [`${prefix}${Square.prototype.constructor.name}Area`]() {
    return this.length * this.length;
  }
}

const square = new Square;
console.log(square.computeSquareArea()); // 100</pre>
<h3 id="9c76" class="graf graf--h3 graf-after--figure">结论</h3>
<p id="b986" class="graf graf--p graf-after--h3">尽管这是一篇很长的文章，但我坚信我们大多数人都已经学会了一些使用JavaScript ES6新特性来改进代码的方法。</p>
<p id="ab3b" class="graf graf--p graf-after--p">在编写改进的代码时，还应该考虑其他超越ES6的特性，如<em class="markup--em markup--p-em"> ES6模块</em>、<em class="markup--em markup--p-em">承诺</em>、<em class="markup--em markup--p-em">异步函数</em>、<em class="markup--em markup--p-em">生成器</em>等。</p>
<h4 id="8ab2" class="graf graf--h4 graf-after--p">鼓掌并跟随</h4>
<p id="dc06" class="graf graf--p graf-after--h4">如果你觉得这篇文章很有见地，如果你不介意的话，请随意鼓掌。</p>
<p id="904e" class="graf graf--p graf-after--p">你也可以在Medium ( <a class="markup--user markup--p-user" href="https://medium.com/@gladchinda" target="_blank" rel="noopener noreferrer" data-href="https://medium.com/@gladchinda" data-anchor-type="2" data-user-id="ddcd0e9719e5" data-action-value="ddcd0e9719e5" data-action="show-user-card" data-action-type="hover"> Glad Chinda </a>)上关注我，获取更多对你有帮助的有见地的文章。你也可以在推特上关注我(<a class="markup--anchor markup--p-anchor" href="https://twitter.com/@gladchinda" target="_blank" rel="noopener noreferrer" data-href="https://twitter.com/@gladchinda"> @gladchinda </a>)。</p>
<p id="41f9" class="graf graf--p graf-after--p graf--trailing"><strong class="markup--strong markup--p-strong"> <em class="markup--em markup--p-em">享受编码……</em></strong></p><div class="code-block code-block-2">
<div class="blog-plug base-cta"><h2>使用<a class="signup" href="https://lp.logrocket.com/blg/signup" target="_blank" rel="noopener noreferrer"> LogRocket </a>消除传统错误报告的干扰</h2>
<a href="https://lp.logrocket.com/blg/signup" class="signup" target="_blank" rel="noopener noreferrer"><img class="alignnone size-full wp-image-46 jetpack-lazy-image" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/><noscript><img data-lazy-fallback="1" class="alignnone size-full wp-image-46" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/></noscript></a>
<p><a href="https://lp.logrocket.com/blg/signup" target="_blank" rel="noopener noreferrer"> LogRocket </a>是一个数字体验分析解决方案，它可以保护您免受数百个假阳性错误警报的影响，只针对几个真正重要的项目。LogRocket会告诉您应用程序中实际影响用户的最具影响力的bug和UX问题。</p>
<p>然后，使用具有深层技术遥测的会话重放来确切地查看用户看到了什么以及是什么导致了问题，就像你在他们身后看一样。</p>
<p>LogRocket自动聚合客户端错误、JS异常、前端性能指标和用户交互。然后LogRocket使用机器学习来告诉你哪些问题正在影响大多数用户，并提供你需要修复它的上下文。</p>
<p>关注重要的bug—<a class="signup" href="https://lp.logrocket.com/blg/signup-issue-free" target="_blank" rel="noopener noreferrer">今天就试试LogRocket】。</a></p></div></div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
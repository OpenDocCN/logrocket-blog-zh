<html>
<head>
<title>React Redux connect(): When and how to use it - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>React Redux connect():何时以及如何使用它</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/react-redux-connect-when-how-use/#0001-01-01">https://blog.logrocket.com/react-redux-connect-when-how-use/#0001-01-01</a></blockquote><div><article class="article-post">
<p><strong> <em>编者按:</em> </strong> <em>本文最后一次更新是在2022年6月16日，包括了React功能组件中<code>useDispatch</code>和<code>useSelector</code>钩子的使用。</em></p>
<p>React提供了两种向组件提供数据的主要机制，props和state。Props是只读的，允许父组件将属性传递给子组件。状态是局部的，封装在组件中。它可以在组件生命周期的任何时候发生变化。</p>
<p>由于状态是构建动态React应用程序的一种非常强大的机制，因此正确的状态管理至关重要。已经有几个库为管理应用程序状态提供了结构良好的架构，比如Flux、Redux和MobX等等。</p>
<p>在本指南中，我们将向您展示如何使用<a href="https://github.com/reduxjs/react-redux"> React Redux </a>使用Redux管理React应用程序中的状态。我们假设您已经对React和Redux架构和API有了基本的了解。我们开始吧！</p>

<h2 id="what-redux">Redux是什么？</h2>
<p>Redux是JavaScript应用程序的可预测状态容器，范围从普通应用程序到框架应用程序。Redux占用空间非常小，但它仍然允许您编写可以在任何环境中运行的一致的应用程序:</p>
<p><img data-attachment-id="121213" data-permalink="https://blog.logrocket.com/simple-redux-store-example/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/06/simple-redux-store-example.png" data-orig-size="720,671" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="simple-redux-store-example" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/06/simple-redux-store-example-300x280.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/06/simple-redux-store-example.png" decoding="async" class="aligncenter wp-image-121213 size-full jetpack-lazy-image" src="../Images/0ef1b6251e812a46dddadf49f71c017f.png" alt="Simple Redux Store Example" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2022/06/simple-redux-store-example.png 720w, https://blog.logrocket.com/wp-content/uploads/2022/06/simple-redux-store-example-300x280.png 300w" data-lazy-sizes="(max-width: 720px) 100vw, 720px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2022/06/simple-redux-store-example.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/06/simple-redux-store-example.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="121213" data-permalink="https://blog.logrocket.com/simple-redux-store-example/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/06/simple-redux-store-example.png" data-orig-size="720,671" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="simple-redux-store-example" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/06/simple-redux-store-example-300x280.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/06/simple-redux-store-example.png" decoding="async" loading="lazy" class="aligncenter wp-image-121213 size-full" src="../Images/0ef1b6251e812a46dddadf49f71c017f.png" alt="Simple Redux Store Example" srcset="https://blog.logrocket.com/wp-content/uploads/2022/06/simple-redux-store-example.png 720w, https://blog.logrocket.com/wp-content/uploads/2022/06/simple-redux-store-example-300x280.png 300w" sizes="(max-width: 720px) 100vw, 720px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/06/simple-redux-store-example.png"/></noscript>
<p>如果您是Redux社区的新手，并且对围绕Redux的许多设计模式和评论感到不知所措，您应该尝试一下<a href="https://blog.logrocket.com/smarter-redux-with-redux-toolkit/"> Redux Toolkit </a>，这是一个官方的、固执己见的、包含电池的工具集，用于高效的Redux开发。</p>
<p>Redux Toolkit消除了许多对Redux的批评，有助于弥合围绕Redux最佳实践和模式的知识差距。</p>
<h2 id="what-redux-connect">Redux <code>connect()</code>是什么？</h2>
<p>React Redux包为Redux状态容器提供了React绑定，使得将React应用连接到Redux存储非常容易。这允许您根据React应用程序组件与Redux存储的连接，将它们分为表示组件和容器组件。</p>
<p>表示组件只关心事物的外观。他们不知道Redux状态。表示组件从props获取数据，并可能触发通过props传递给它们的回调。另一方面，容器组件负责事情如何工作，并且完全知道Redux状态。它们通常是使用React Redux创建的，可能会调度Redux操作。它们还订阅Redux状态的更改。</p>
<p>值得注意的是，2019年，Redux作者丹·阿布拉莫夫(Dan Abramov)在修订他2015年关于表示和容器组件的博文时反对这种方法。从7.1版本开始，Redux支持React钩子，这意味着您可以在功能组件中使用Redux和钩子，而不是使用Redux <code>connect()</code>。</p>
<p>也就是说，理解将业务逻辑从表示组件中分离出来的核心概念是有用的，因为这可以简化许多复杂问题的解决。在本指南中，我们将关注使用React Redux连接到Redux状态的容器组件。</p>
<h2 id="connect-app-redux-store">如何将应用程序连接到Redux商店</h2>
<p>React Redux包公开了一个非常简单的接口。你只需要关心两个部分。首先，<code>&lt;Provider store&gt;</code>包装了React应用程序，并使Redux状态对应用程序层次结构中的所有容器组件可用。另一方面，<code>connect([mapStateToProps], [mapDispatchToProps], [mergeProps],[options])</code>创建了一个更高阶的组件，用于从基础反应组件中生成容器组件。</p>
<p>您可以在项目中安装React Redux，如下所示:</p>
<pre class="language-bash">npm install react-redux --save
</pre>
<p>假设您已经为React应用程序设置了一个Redux store，您可以使用以下代码将应用程序连接到Redux store:</p>
<pre class="language-javascript">import React from 'react';
import ReactDOM from 'react-dom';
import { Provider } from 'react-redux';
import createStore from './createReduxStore';

const store = createStore();
const rootElement = document.getElementById('root');

ReactDOM.render((
 &lt;Provider store={store}&gt;
  &lt;AppRootComponent /&gt;
 &lt;/Provider&gt;
), rootElement);
</pre>
<p>有了这个设置，您现在可以使用<code>connect()</code> API在<code>AppRootComponent</code>的层次结构中创建连接到Redux存储的容器组件。</p>
<h2 id="use-connect-redux">Redux中何时使用<code>connect()</code></h2>
<p>让我们来看看一些适合使用<code>connect()</code>的常见场景。</p>
<h3 id="creating-container-components">创建容器组件</h3>
<p>React Redux <code>connect()</code> API用于创建连接到Redux存储的容器元素。Redux存储是使用<a href="https://reactjs.org/docs/context.html"> React上下文</a>从组件的最顶层祖先派生的。如果您只是创建一个表示性的组件，那么您不需要<code>connect()</code>。</p>
<p>无论您是想从Redux store获取数据、在Redux store上调度操作，还是想在React组件中两者都做，您都可以通过将组件包装在由<code>connect()</code>返回的更高级组件中，使其成为容器组件:</p>
<pre class="language-javascript">import React from 'react';
import { connect } from 'react-redux';
import Profile from './components/Profile';

function ProfileContainer(props) {
  return (
    props.loggedIn
      ? &lt;Profile profile={props.profile} /&gt;
      : &lt;div&gt;Please login to view profile.&lt;/div&gt;
  )
}

const mapStateToProps = function(state) {
  return {
    profile: state.user.profile,
    loggedIn: state.auth.loggedIn
  }
}

export default connect(mapStateToProps)(ProfileContainer);
</pre>
<h3 id="avoiding-manual-subscription">避免手动订阅Redux存储</h3>
<p>您可以自己创建一个容器组件，并使用<code>store.subscribe()</code>手动订阅Redux存储。然而，使用<code>connect()</code>带来了一些性能改进和优化，您可能无法在您的应用程序中实现。</p>
<p>在下面的代码片段中，我们尝试手动创建一个容器组件，并将其连接到Redux存储。与前面的代码片段一样，我们订阅了商店以实现类似的功能:</p>
<pre class="language-javascript">import React, { Component } from 'react';
import store from './reduxStore';
import Profile from './components/Profile';

class ProfileContainer extends Component {

  state = this.getCurrentStateFromStore()


  getCurrentStateFromStore() {
    return {
      profile: store.getState().user.profile,
      loggedIn: store.getState().auth.loggedIn
    }
  }


  updateStateFromStore = () =&gt; {
    const currentState = this.getCurrentStateFromStore();


    if (this.state !== currentState) {
      this.setState(currentState);
    }
  }


  componentDidMount() {
    this.unsubscribeStore = store.subscribe(this.updateStateFromStore);
  }


  componentWillUnmount() {
    this.unsubscribeStore();
  }


  render() {
    const { loggedIn, profile } = this.state;


    return (
      loggedIn
        ? &lt;Profile profile={profile} /&gt;
        : &lt;div&gt;Please login to view profile.&lt;/div&gt;
    )
  }


}

export default ProfileContainer;
</pre>
<p><code>connect()</code>还提供了额外的灵活性，允许您配置容器组件来接收基于最初传递给它们的属性的动态属性。这对于基于道具选择Redux状态的一部分或者将动作创建者绑定到道具中的特定变量非常有用。</p>
<p>最佳实践是<a href="https://blog.logrocket.com/8-definitive-rules-building-apps-redux/">每个应用</a>只使用一个Redux store，但是如果您的项目需要多个Redux store，<code>connect()</code>允许您轻松指定容器组件应该连接到哪个store。</p>
<h2 id="react-redux-react-context">React Redux与React Context</h2>
<p>很多开发者觉得<a href="https://blog.logrocket.com/use-hooks-and-context-not-react-and-redux/"> React Context是Redux </a>的替代品。在我看来，事实并非如此。上下文不是为全局状态管理设计的；更确切地说，上下文是为了避免对组件树的钻取。</p>
<p>对于大中型应用程序，全局状态管理是可维护性和可伸缩性的关键。事实上，Connect和Redux通常使用React上下文向连接的组件提供数据。它增加了几层额外的不变性和记忆性，使应用程序更具性能。</p>
<h2 id="how-redux-connect-works">Redux <code>connect()</code>是如何工作的？</h2>
<p>React Redux提供的<code>connect()</code>函数最多可以接受四个参数，所有参数都是可选的。调用<code>connect()</code>函数返回一个高阶组件，可以用来包装任何React组件。</p>
<p>由于更高阶的组件是由<code>connect()</code>返回的，所以必须使用基本的React组件再次调用它，以将其转换为容器组件:</p>
<pre class="language-javascript">const ContainerComponent = connect()(BaseComponent);
// Here is the signature of the connect() function:
connect([mapStateToProps], [mapDispatchToProps], [mergeProps], [options])
</pre>
<h3 id="using-mapstatetoprops">在React Redux中使用<code>mapStateToProps</code></h3>
<p>下面的参数是一个返回普通对象或另一个函数的函数:</p>
<pre class="language-javascript">mapStateToProps(state, [ownProps]) =&gt; stateProps
</pre>
<p>传递该参数会使容器组件订阅Redux存储更新，这意味着每次存储更新时都会调用<code>mapStateToProps</code>函数。如果您对存储更新不感兴趣，可以将其保留为未定义或null。</p>
<p><code>mapStateToProps</code>是用两个参数声明的。第一个参数是Redux存储的当前状态。第二个参数是可选的，是传递给组件的props对象:</p>
<pre class="language-javascript">const mapStateToProps = function(state) {
  return {
    profile: state.user.profile,
    loggedIn: state.auth.loggedIn
  }
}

export default connect(mapStateToProps)(ProfileComponent);
</pre>
<p>如果从<code>mapStateToProps</code>返回一个普通对象，则返回的<code>stateProps</code>对象被合并到组件的道具中。您可以在组件中访问这些属性，如下所示:</p>
<pre class="language-javascript">function ProfileComponent(props) {
  return (
    props.loggedIn
      ? &lt;Profile profile={props.profile} /&gt;
      : &lt;div&gt;Please login to view profile.&lt;/div&gt;
  )
}
</pre>
<p>但是，如果返回一个函数，该函数将被用作组件的每个实例的<code>mapStateToProps</code>。这对于提高渲染性能和记忆非常有用。</p>
<p>为了让你的应用更有性能，Redux建议使用<a href="https://github.com/reduxjs/reselect">重新选择</a>，这可以帮助你<a href="https://blog.logrocket.com/options-caching-react/">从全球商店中只选择所需的数据块</a>。选择器可以计算派生数据，以保持您的存储最小化，还可以为选择添加记忆，以获得更好的应用程序性能。</p>
<p>下面的参数可以是返回普通对象或其他函数的对象或函数:</p>
<pre class="language-javascript">mapDispatchToProps(dispatch, [ownProps]) =&gt; dispatchProps
</pre>
<p>为了更好地说明<code>mapDispatchToProps</code>是如何工作的，你需要一些动作创建器。例如，假设您有以下动作创建者。您可以在组件中使用dispatch prop，如下所示:</p>
<pre class="language-javascript">export const writeComment = (comment) =&gt; ({
  comment,
  type: 'WRITE_COMMENT'
});

export const updateComment = (id, comment) =&gt; ({
  id,
  comment,
  type: 'UPDATE_COMMENT'
});

export const deleteComment = (id) =&gt; ({
  id,
  type: 'DELETE_COMMENT'
});
</pre>
<h3 id="default-implementation">默认实现</h3>
<p>如果您没有提供自己的<code>mapDispatchToProps</code>对象或函数，将使用默认实现，它只是将商店的dispatch方法作为道具注入到组件中:</p>
<pre class="language-javascript">import React from 'react';
import { connect } from 'react-redux';
import { updateComment, deleteComment } from './actions';

function Comment(props) {
  const { id, content } = props.comment;


  // Invoking the actions via props.dispatch()
  const editComment = () =&gt; props.dispatch(updateComment(id, content));
  const removeComment = () =&gt; props.dispatch(deleteComment(id));


  return (
    &lt;div&gt;
      &lt;p&gt;{ content }&lt;/p&gt;
      &lt;button type="button" onClick={editComment}&gt;Edit Comment&lt;/button&gt;
      &lt;button type="button" onClick={removeComment}&gt;Remove Comment&lt;/button&gt;
    &lt;/div&gt;
  )
}

export default connect()(Comment);
</pre>
<h3 id="passing-object">传递对象</h3>
<p>如果为此参数传递了一个对象，则该对象中的每个函数都将被视为Redux操作的创建者，并被包装到对store的dispatch方法的调用中。所以可以直接调用。由此产生的<code>dispatchProps</code>动作创建者的对象将被合并到组件的道具中。</p>
<p>以下代码片段显示了如何通过提供动作创建者的对象来定义<code>mapDispatchToProps</code>,以及如何将动作创建者用作React组件的道具:</p>
<pre class="language-javascript">import React from 'react';
import { connect } from 'react-redux';
import { updateComment, deleteComment } from './actions';

function Comment(props) {
  const { id, content } = props.comment;


  // Invoking the actions directly as component props
  const editComment = () =&gt; props.updatePostComment(id, content);
  const removeComment = () =&gt; props.deletePostComment(id);


  return (
    &lt;div&gt;
      &lt;p&gt;{ content }&lt;/p&gt;
      &lt;button type="button" onClick={editComment}&gt;Edit Comment&lt;/button&gt;
      &lt;button type="button" onClick={removeComment}&gt;Remove Comment&lt;/button&gt;
    &lt;/div&gt;
  )
}

// Object of action creators
const mapDispatchToProps = {
  updatePostComment: updateComment,
  deletePostComment: deleteComment
}

export default connect(null, mapDispatchToProps)(Comment);
</pre>
<h3 id="passing-function">传递函数</h3>
<p>如果传递了一个函数，那么您需要返回一个对象<code>dispatchProps</code>,该对象使用store的dispatch方法绑定动作创建者。该函数将商店的发货作为其第一个参数。像使用<code>mapStateToProps</code>一样，它也可以将可选的<code>ownProps</code>作为第二个参数，该参数映射到传递给组件的原始属性。</p>
<p>如果这个函数返回另一个函数，那么返回的函数将被用作<code>mapDispatchToProps</code>,这对提高渲染性能和记忆很有用。</p>
<p>Redux提供的<code>bindActionCreators()</code>助手可以在这个函数中使用，将动作创建者绑定到商店的dispatch方法。</p><div class="code-block code-block-54">
<hr/>
<h3>更多来自LogRocket的精彩文章:</h3>

<hr/></div>
<p>下面的代码片段展示了如何通过提供一个函数来定义<code>mapDispatchToProps</code>，以及如何使用<code>bindActionCreators()</code>助手将评论动作创建者绑定到React组件的<code>props.actions</code>:</p>
<pre class="language-javascript">import React from 'react';
import { connect } from 'react-redux';
import { bindActionCreators } from 'redux';
import * as commentActions from './actions';

function Comment(props) {
  const { id, content } = props.comment;
  const { updateComment, deleteComment } = props.actions;


  // Invoking the actions from props.actions
  const editComment = () =&gt; updateComment(id, content);
  const removeComment = () =&gt; deleteComment(id);


  return (
    &lt;div&gt;
      &lt;p&gt;{ content }&lt;/p&gt;
      &lt;button type="button" onClick={editComment}&gt;Edit Comment&lt;/button&gt;
      &lt;button type="button" onClick={removeComment}&gt;Remove Comment&lt;/button&gt;
    &lt;/div&gt;
  )
}

const mapDispatchToProps = (dispatch) =&gt; {
  return {
    actions: bindActionCreators(commentActions, dispatch)
  }
}

export default connect(null, mapDispatchToProps)(Comment);


mergeProps(stateProps, dispatchProps, ownProps) =&gt; props
</pre>
<p>如果该参数被传递，它将是一个带有三个参数的函数:</p>
<ul>
<li><code>stateProps</code>:调用<code>mapStateToProps()</code>返回的道具对象</li>
<li><code>dispatchProps</code>:来自<code>mapDispatchToProps()</code>的动作创作者道具对象</li>
<li><code>ownProps</code>:组件收到的原始道具</li>
</ul>
<p>该函数返回一个普通的props对象，该对象将被传递给包装的组件。这对于根据道具有条件地映射Redux存储的部分状态或动作创建者非常有用。</p>
<p>当未提供此函数时，默认实现如下:</p>
<pre class="language-javascript">const mergeProps = (stateProps, dispatchProps, ownProps) =&gt; {
  return Object.assign({}, ownProps, stateProps, dispatchProps)
}
</pre>
<h3 id="options"><code>options</code></h3>
<p>如果指定的话，<code>options</code>对象包含修改<code>connect()</code>行为的选项。<code>connect()</code>是<code>connectAdvanced()</code>的一个特殊实现，它接受了<code>connectAdvanced()</code>可用的大部分选项以及一些附加选项。</p>
<p>你可以参考<a href="https://react-redux.js.org/api/connect#options-object"> <code>options</code>对象文档</a>来查看<code>connect()</code>可用的所有选项，并了解它们如何修改它的行为。深入研究这个API将有助于您理解Redux是如何工作的，以及使用它比使用其他状态管理模式有什么好处。</p>
<p>让我们探索一下<code>options</code>对象的API。它使用了<code>context? object</code>和一个<code>pure</code>布尔。它还允许您将全局存储旁边的自定义上下文传递给容器。</p>
<p><code>pure</code> boolean允许Redux了解容器是否是纯的，这意味着除了它的道具和状态之外，它不依赖于任何东西。默认情况下，这是正确的，但是我们可以利用以下API来覆盖默认检查:</p>
<pre class="language-javascript">areStatesEqual?: (next: Object, prev: Object) =&gt; boolean; 
areOwnPropsEqual?: (next: Object, prev: Object) =&gt; boolean; 
areStatePropsEqual?: (next: Object, prev: Object) =&gt; boolean; 
areMergedPropsEqual?: (next: Object, prev: Object) =&gt; boolean;
</pre>
<p>默认情况下，所有这些方法都使用浅层比较来确定更改。我们可以为性能密集型容器覆盖它，但是这样做要小心，因为它可能会在任何时候破坏容器。</p>
<p>最后，<code>options</code>对象API使用了<code>forwardRef: boolean</code>，这在您想要从外部访问容器的实例方法时非常有用。</p>
<h2 id="how-to-use-connect">如何使用<code>connect()</code></h2>
<p>在使用<code>connect()</code>将一个常规的React组件转换成容器组件之前，您必须指定该组件将连接到的Redux存储。</p>
<p>假设您有一个名为<code>NewComment</code>的容器组件，用于向帖子添加新评论，并显示一个提交评论的按钮。该组件可能类似于下面的代码片段:</p>
<pre class="language-javascript">import React from 'react';
import { connect } from 'react-redux';

class NewComment extends React.Component {

  input = null

  writeComment = evt =&gt; {
    evt.preventDefault();
    const comment = this.input.value;

    comment &amp;&amp; this.props.dispatch({ type: 'WRITE_COMMENT', comment });
  }

  render() {
    const { id, content } = this.props.comment;

    return (
      &lt;div&gt;
        &lt;input type="text" ref={e =&gt; this.input = e} placeholder="Write a comment" /&gt;
        &lt;button type="button" onClick={this.writeComment}&gt;Submit Comment&lt;/button&gt;
      &lt;/div&gt;
    )
  }

}

export default connect()(NewComment);
</pre>
<p>为了在应用程序中实际使用该组件，您必须指定该组件将连接到哪个Redux存储。否则，您将得到一个错误。这可以通过两种方式之一来实现。</p>
<h3 id="set-store-prop-container-component">在容器组件上设置存储属性</h3>
<p>首先，您可以通过将对Redux store的引用作为组件的<code>store</code>属性的值来指定组件上的Redux store:</p>
<pre class="language-javascript">import React from 'react';
import store from './reduxStore';
import NewComment from './components/NewComment';

function CommentsApp(props) {
  return &lt;NewComment store={store} /&gt;
}
</pre>
<h3 id="set-store-prop-provider-component">在一个<code>&lt;Provider&gt;</code>组件上设置商店道具</h3>
<p>如果您希望只为您的应用程序设置一次Redux store，那么在一个<code>&lt;Provider&gt;</code>组件上设置store prop是一个不错的选择。对于只使用一个Redux商店的应用程序来说，通常就是这种情况。</p>
<p>React Redux提供了一个<code>&lt;Provider&gt;</code>组件，可以用来包装根应用程序组件。它接受一个<code>store</code>属性，该属性需要一个对您希望应用程序使用的Redux存储的引用。使用React的上下文机制，将<code>store</code>传递给应用层次结构中的容器组件:</p>
<pre class="language-javascript">import React from 'react';
import ReactDOM from 'react-dom';
import store from './reduxStore';
import { Provider } from 'react-redux';
import NewComment from './components/NewComment';

function CommentsApp(props) {
  return &lt;NewComment /&gt;
}

ReactDOM.render((
  &lt;Provider store={store}&gt;
    &lt;CommentsApp /&gt;
  &lt;/Provider&gt;
), document.getElementById('root'))
</pre>
<h2 id="accessing-ownprops">访问<code>ownProps</code></h2>
<p>如前所述，传递给<code>connect()</code>的<code>mapStateToProps</code>和<code>mapDispatchToProps</code>函数可以用组件的<code>ownProps</code>作为第二个参数来声明。</p>
<p>然而，有一个警告。如果声明的函数的强制参数的数量少于两个，那么<code>ownProps</code>将永远不会被传递。但是，如果函数声明时没有强制参数或者至少有两个参数，那么<code>ownProps</code>就通过了。让我们回顾几个潜在的场景。</p>
<h3 id="declared-no-parameters">声明时没有参数</h3>
<pre class="language-javascript">const mapStateToProps = function() {
      console.log(arguments[0]); // state
      console.log(arguments[1]); // ownProps
    };</pre>
<p>在上面的示例中，<code>ownProps</code>被传递，因为该函数是在没有强制参数的情况下声明的。因此，下面的代码也将以类似的方式工作，使用<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/rest_parameters"> ES6 rest参数语法</a>:</p>
<pre class="language-javascript">const mapStateToProps = function(...args) {
  console.log(args[0]); // state
  console.log(args[1]); // ownProps
};
</pre>
<h3 id="declared-one-parameter">用一个参数声明</h3>
<p>在下面的代码中，只有一个参数<code>state</code>。所以，<code>arguments[1]</code>是<code>undefined</code>因为<code>ownProps</code>没有通过:</p>
<pre class="language-javascript">const mapStateToProps = function(state) {
      console.log(state); // state
      console.log(arguments[1]); // undefined
    };</pre>
<h3 id="declared-one-default-parameter">用一个默认参数声明</h3>
<p>在下面的代码中，只有一个强制参数<code>state</code>。第二个<code>ownProps</code>参数是可选的，因为已经为它指定了一个默认值。由于只有一个强制参数，<code>ownProps</code>没有被传递，因此，它映射到分配给它的默认值，<code>{}</code>:</p>
<pre class="language-javascript">const mapStateToProps = function(state, ownProps = {}) {
console.log(state); // state
console.log(ownProps); // {}
};</pre>
<h3 id="declared-two-parameters">用两个参数声明</h3>
<pre class="language-javascript">const mapStateToProps = function(state, ownProps) {
      console.log(state); // state
      console.log(ownProps); // ownProps
    };</pre>
<p>上面的代码非常简单。<code>ownProps</code>被传递，因为该函数是用两个强制参数声明的。</p>
<h2 id="react-redux-functional-components">功能组件中的反应冗余</h2>
<p>React Redux包引入了<code>useSelector</code>和<code>useDispatch</code>挂钩，我们可以使用它们轻松地挂钩到Redux存储并将动作分派到存储，而无需使用<code>connect</code>函数:</p>
<pre class="language-javascript">import { useSelector, useDispatch } from 'react-redux'
</pre>
<p><code>useAppSelector</code>用于从存储状态中读取一个值，它还订阅状态的更新。<code>useDispatch</code>挂钩用于向减速器功能分派动作。</p>
<p>现在，让我们通过重写我们的<code>NewComment</code>组件来演示如何使用这两个钩子，当前看起来像下面的代码:</p>
<pre class="language-javascript">import React from 'react';
import { connect } from 'react-redux';

class NewComment extends React.Component {

  input = null

  writeComment = evt =&gt; {
    evt.preventDefault();
    const comment = this.input.value;

    comment &amp;&amp; this.props.dispatch({ type: 'WRITE_COMMENT', comment });
  }

  render() {
    const { id, content } = this.props.comment;

    return (
      &lt;div&gt;
        &lt;input type="text" ref={e =&gt; this.input = e} placeholder="Write a comment" /&gt;
        &lt;button type="button" onClick={this.writeComment}&gt;Submit Comment&lt;/button&gt;
      &lt;/div&gt;
    )
  }

}

export default connect()(NewComment);
</pre>
<p>让我们使用React Redux挂钩<code>useSelector</code>和<code>useDispatch</code>重写它:</p>
<pre class="language-javascript">import React, { useRef } from "react";
import { useSelector, useDispatch } from "react-redux";

function NewComment() {
  const input = useRef();

  const dispatch = useDispatch();
  const { id, content } = useSelector((state) =&gt; state.comment);

  const writeComment = (evt) =&gt; {
    evt.preventDefault();
    const comment = input.current.value;
    comment &amp;&amp; dispatch({ type: "WRITE_COMMENT", comment });
  };

  return (
    &lt;div&gt;
      &lt;input type="text" ref={input} placeholder="Write a comment" /&gt;
      &lt;button type="button" onClick={writeComment}&gt;
        Submit Comment
      &lt;/button&gt;
    &lt;/div&gt;
  );
}

export default NewComment;
</pre>
<p>在上面的代码中，我们将<code>NewComment</code>组件从类组件转换为功能组件。像<code>useDipatch</code>和<code>useSelector</code>这样的钩子只在React功能组件中使用。</p>
<p>注意我们是如何调用<code>useDispatch</code>钩子的，它返回一个<code>dispatch</code>函数。我们使用<code>dispatch</code>向商店发送动作。用回调函数调用<code>useSelector</code>钩子，回调函数将接收状态。</p>
<p>请注意，在回调函数中，我们只返回了<code>comment</code>状态，因为这是我们想要在这个组件中使用的。使用React Redux钩子，我们移除了<code>connect</code>函数。不再需要它，因为<code>useSelector</code>已经返回了存储状态的一部分并订阅了它。</p>
<p>每当<code>comment</code>状态改变时，<code>useSelector</code>就会得到通知，并使<code>NewComment</code>组件重新渲染以显示新的状态。</p>
<h2 id="conclusion">结论</h2>
<p>在本指南中，我们已经介绍了何时以及如何使用React Redux <code>connect()</code> API来创建连接到Redux状态的容器组件。如上所述，如果你是Redux新手，强烈推荐使用Redux Toolkit，它可以<a href="https://blog.logrocket.com/smarter-redux-with-redux-toolkit/">帮助你快速入门</a>。我们还简要介绍了React Redux <code>connect()</code> API的一种替代方式，即<code>useSelector</code>和<code>useDispatch</code>挂钩，它们在React功能组件中工作。</p>
<p>虽然本指南涵盖了对<code>connect()</code> API及其用法的大部分剖析，但它并没有广泛展示用例示例。你可以在<a href="https://react-redux.js.org/api/connect">这份文件</a>中找到更多。</p>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
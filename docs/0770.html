<html>
<head>
<title>What’s new in React Table v7? - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>React Table v7有什么新特性？- LogRocket博客</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/building-styling-tables-react-table-v7/#0001-01-01">https://blog.logrocket.com/building-styling-tables-react-table-v7/#0001-01-01</a></blockquote><div><article class="article-post">
<p>众所周知，用React创建表格是一件痛苦的事情。因此，毫不奇怪，有许多库可以让React应用程序更容易地创建表格。其中一个包是<a href="https://blog.logrocket.com/complete-guide-building-smart-data-table-react/" target="_blank" rel="noopener"> <code>react-table</code> </a>。它提供了一个现代的、基于Hooks的API，让我们可以在React中轻松地创建表格。</p>
<p>在最新的主要版本中，<a href="https://github.com/tannerlinsley/react-table/releases/tag/v7.0.0" target="_blank" rel="noopener"> React Table v7 </a>，创建者Tanner Linsley旨在将整个库重构为一个UI、样式和标记无关的表构建工具，该工具专门使用钩子。</p>
<p>在本教程中，我们将告诉你所有你需要知道的关于最新版本的<code>react-table</code>(在撰写本文时，最新的版本是<a href="https://github.com/tannerlinsley/react-table/releases" target="_blank" rel="noopener"> React Table v7.6.3 </a>)，概述React Table v7附带的主要变化和新特性，并通过一个基本示例来查看它们的运行情况。</p>
<p>我们将讨论以下内容:</p>

<h2 id="introducing">React表v7简介</h2>
<p>2020年3月，React Table创建者Tanner Linsley发布了<a href="https://github.com/tannerlinsley/react-table/releases/tag/v7.0.0" target="_blank" rel="noopener"> React Table v7 </a>，他将其描述为“一年多来将整个库重构为一个只有钩子的UI/样式/标记不可知的表构建实用程序的工作的高潮。”</p>
<p><iframe loading="lazy" src="https://www.youtube.com/embed/fwOZUU3OqmY" frameborder="0" allowfullscreen="allowfullscreen">视频</iframe></p>
<p>React Table v7由一组React挂钩和插件组成，旨在帮助您将复杂数据网格的逻辑特性组合成一个单一的、高性能的、可扩展的和非独立的API，该API由主<code>useTable</code>挂钩返回。</p>
<p>作为一个无头工具，React Table v7不呈现或提供现成的数据表UI元素。这意味着您负责使用React Table提供的钩子的状态和回调来呈现您自己的表标记。</p>
<h2 id="new">React表7中的新特性</h2>
<p>根据<a href="https://github.com/tannerlinsley/react-table/releases/tag/v7.0.0" target="_blank" rel="noopener">发布说明</a>，React Table 7向该库引入了以下特性:</p>
<ul>
<li>自动开箱即用、完全可控的API</li>
<li>排序(多且稳定)</li>
<li>过滤</li>
<li>旋转和聚集</li>
<li>行选择和扩展</li>
<li>列排序</li>
<li>服务器端/受控数据/状态</li>
</ul>
<p>最新版本中的更改和新功能旨在使React Table更加:</p>
<ul>
<li>轻量级(5kb-14kb+，取决于使用的功能和树摇动)</li>
<li>无头(100%可定制，自带用户界面)</li>
<li>可制作动画</li>
<li>可虚拟化</li>
<li>可调整大小的</li>
<li>可扩展(通过一个新的基于钩子的插件系统)</li>
</ul>
<p>如上所述，<code>react-table</code>的最新小版本是2021年1月11日发布的<a href="https://www.npmjs.com/package/react-table?activeTab=versions" target="_blank" rel="noopener">反应表v7.6.3 </a>。前往npm获取React表的完整<a href="https://www.npmjs.com/package/react-table?activeTab=versions" target="_blank" rel="noopener">版本历史。</a></p>
<h2 id="creating">用React Table v7创建基本表</h2>
<p>使用react-table在React应用程序中创建一个基本表格很容易。运行以下命令进行安装:</p>
<pre class="sh">npm i react-table</pre>
<p>那么我们可以如下使用它:</p>
<pre class="js">import React from "react";
import { useTable } from "react-table";

const data = [
  { firstName: "jane", lastName: "doe", age: 20 },
  { firstName: "john", lastName: "smith", age: 21 }
];

const columns = [
  {
    Header: "Name",
    columns: [
      {
        Header: "First Name",
        accessor: "firstName"
      },
      {
        Header: "Last Name",
        accessor: "lastName"
      }
    ]
  },
  {
    Header: "Other Info",
    columns: [
      {
        Header: "Age",
        accessor: "age"
      }
    ]
  }
];

const Table = ({ columns, data }) =&gt; {
  const {
    getTableProps,
    getTableBodyProps,
    headerGroups,
    rows,
    prepareRow
  } = useTable({
    columns,
    data
  });

  return (
    &lt;table {...getTableProps()}&gt;
      &lt;thead&gt;
        {headerGroups.map(headerGroup =&gt; (
          &lt;tr {...headerGroup.getHeaderGroupProps()}&gt;
            {headerGroup.headers.map(column =&gt; (
              &lt;th {...column.getHeaderProps()}&gt;{column.render("Header")}&lt;/th&gt;
            ))}
          &lt;/tr&gt;
        ))}
      &lt;/thead&gt;
      &lt;tbody {...getTableBodyProps()}&gt;
        {rows.map((row, i) =&gt; {
          prepareRow(row);
          return (
            &lt;tr {...row.getRowProps()}&gt;
              {row.cells.map(cell =&gt; {
                return &lt;td {...cell.getCellProps()}&gt;{cell.render("Cell")}&lt;/td&gt;;
              })}
            &lt;/tr&gt;
          );
        })}
      &lt;/tbody&gt;
    &lt;/table&gt;
  );
};

export default function App() {
  return (
    &lt;div className="App"&gt;
      &lt;Table columns={columns} data={data} /&gt;
    &lt;/div&gt;
  );
}</pre>
<p>在上面的代码中，我们从react-table包中导入了<code>useTable</code>钩子。然后我们创建了<code>data</code>来用数据填充表格:</p>
<pre class="js">const data = [
  { firstName: "jane", lastName: "doe", age: 20 },
  { firstName: "john", lastName: "smith", age: 21 }
];</pre>
<p>我们只是将属性放在对象中，为表行添加额外的数据。</p>
<p>我们可以用下面的代码在列表中创建列:</p>
<pre class="js">const columns = [
  {
    Header: "Name",
    columns: [
      {
        Header: "First Name",
        accessor: "firstName"
      },
      {
        Header: "Last Name",
        accessor: "lastName"
      }
    ]
  },
  {
    Header: "Other Info",
    columns: [
      {
        Header: "Age",
        accessor: "age"
      }
    ]
  }
];</pre>
<p><code>Header</code>属性包含将要显示的名称字符串，而<code>accessor</code>属性是数组条目对象中的属性名。</p>
<p>在<code>Table</code>组件代码中，我们有:</p>
<pre class="js">const Table = ({ columns, data }) =&gt; {
  const {
    getTableProps,
    getTableBodyProps,
    headerGroups,
    rows,
    prepareRow
  } = useTable({
    columns,
    data
  });

  return (
    &lt;table {...getTableProps()}&gt;
      &lt;thead&gt;
        {headerGroups.map(headerGroup =&gt; (
          &lt;tr {...headerGroup.getHeaderGroupProps()}&gt;
            {headerGroup.headers.map(column =&gt; (
              &lt;th {...column.getHeaderProps()}&gt;{column.render("Header")}&lt;/th&gt;
            ))}
          &lt;/tr&gt;
        ))}
      &lt;/thead&gt;
      &lt;tbody {...getTableBodyProps()}&gt;
        {rows.map((row, i) =&gt; {
          prepareRow(row);
          return (
            &lt;tr {...row.getRowProps()}&gt;
              {row.cells.map(cell =&gt; {
                return &lt;td {...cell.getCellProps()}&gt;{cell.render("Cell")}&lt;/td&gt;;
              })}
            &lt;/tr&gt;
          );
        })}
      &lt;/tbody&gt;
    &lt;/table&gt;
  );
};</pre>
<p><code>useTable</code>钩子从道具中取出<code>column</code>和<code>data</code>，道具来源于我们之前定义的那些对象和数组。我们从从<code>useTable</code>钩子返回的对象中得到<code>getTableProps</code>和<code>getTableBodyProps</code>的函数。</p>
<p>在<code>th</code>标签中调用<code>getHeaderProps()</code>函数，并扩展以填充标题。这样，我们将由<code>getTableBodyProps()</code>函数返回的道具传递给<code>tbody</code>来展开道具，以正确地样式化和对齐列。</p>
<p>从<code>useTable</code>钩子返回的<code>prepareRow(row);</code>创建行条目，在调用函数改变了适当位置的<code>row</code>对象后，可以自动填充这些行条目。</p>
<p>然后我们有:</p>
<pre class="js">{rows.map((row, i) =&gt; {
  prepareRow(row);
  return (
   &lt;tr {...row.getRowProps()}&gt;
     {row.cells.map(cell =&gt; {
       return &lt;td {...cell.getCellProps()}&gt;{cell.render("Cell")}&lt;/td&gt;;
     })}
   &lt;/tr&gt;
  );
})}</pre>
<p>这将通过从<code>getCellProps()</code>方法中获取项目，然后从返回的对象中填充值来自动填充单元格。我们调用了<code>cell.render("Cell")</code>来将每个<code>td</code>呈现为一个单元格。</p>
<p>最后，在<code>App</code>中，我们使用了<code>Table</code>组件，它带有<code>column</code>和<code>data</code>道具。这些值是我们之前创建的<code>columns</code>和<code>data</code>对象。</p>
<p>表中的项目显示在两个窗格中。左侧窗格有两列的<strong>姓名</strong>标题:<strong>名</strong>和<strong>姓</strong>。然后，右边的窗格显示了带有<strong>年龄</strong>列的<strong>其他信息</strong>标题。</p>
<h2 id="adding">添加页脚</h2>
<p>我们可以通过向out列对象添加一个<code>Footer</code>属性来添加一个页脚。我们可以编写以下代码来实现这一点:</p>
<pre class="js">import React from "react";
import { useTable } from "react-table";

const data = [
  { firstName: "jane", lastName: "doe", age: 20 },
  { firstName: "john", lastName: "smith", age: 21 }
];

const columns = [
  {
    Header: "Name",
    Footer: "Name",
    columns: [
      {
        Header: "First Name",
        accessor: "firstName"
      },
      {
        Header: "Last Name",
        accessor: "lastName"
      }
    ]
  },
  {
    Header: "Other Info",
    Footer: "Other Info",
    columns: [
      {
        Header: "Age",
        accessor: "age",
        Footer: info =&gt; {
          const total = React.useMemo(
            () =&gt; info.rows.reduce((sum, row) =&gt; row.values.age + sum, 0),
            [info.rows]
          );

          return &lt;&gt;Average Age: {total / info.rows.length}&lt;/&gt;;
        }
      }
    ]
  }
];

const Table = ({ columns, data }) =&gt; {
  const {
    getTableProps,
    getTableBodyProps,
    headerGroups,
    footerGroups,
    rows,
    prepareRow
  } = useTable({
    columns,
    data
  });

  return (
    &lt;table {...getTableProps()}&gt;
      &lt;thead&gt;
        {headerGroups.map(headerGroup =&gt; (
          &lt;tr {...headerGroup.getHeaderGroupProps()}&gt;
            {headerGroup.headers.map(column =&gt; (
              &lt;th {...column.getHeaderProps()}&gt;{column.render("Header")}&lt;/th&gt;
            ))}
          &lt;/tr&gt;
        ))}
      &lt;/thead&gt;
      &lt;tbody {...getTableBodyProps()}&gt;
        {rows.map((row, i) =&gt; {
          prepareRow(row);
          return (
            &lt;tr {...row.getRowProps()}&gt;
              {row.cells.map(cell =&gt; {
                return &lt;td {...cell.getCellProps()}&gt;{cell.render("Cell")}&lt;/td&gt;;
              })}
            &lt;/tr&gt;
          );
        })}
      &lt;/tbody&gt;
      &lt;tfoot&gt;
        {footerGroups.map(group =&gt; (
          &lt;tr {...group.getFooterGroupProps()}&gt;
            {group.headers.map(column =&gt; (
              &lt;td {...column.getFooterProps()}&gt;{column.render("Footer")}&lt;/td&gt;
            ))}
          &lt;/tr&gt;
        ))}
      &lt;/tfoot&gt;
    &lt;/table&gt;
  );
};

export default function App() {
  return (
    &lt;div className="App"&gt;
      &lt;Table columns={columns} data={data} /&gt;
    &lt;/div&gt;
  );
}</pre>
<p>在上面的代码中，我们将<code>Footer</code>属性添加到了<code>columns</code>数组，如下所示:</p>
<pre class="js">const columns = [
  {
    Header: "Name",
    Footer: "Name",
    columns: [
      {
        Header: "First Name",
        accessor: "firstName"
      },
      {
        Header: "Last Name",
        accessor: "lastName"
      }
    ]
  },
  {
    Header: "Other Info",
    Footer: "Other Info",
    columns: [
      {
        Header: "Age",
        accessor: "age",
        Footer: info =&gt; {
          const total = React.useMemo(
            () =&gt; info.rows.reduce((sum, row) =&gt; row.values.age + sum, 0),
            [info.rows]
          );

          return &lt;&gt;Average Age: {total / info.rows.length}&lt;/&gt;;
        }
      }
    ]
  }
];</pre>
<p>我们将<code>Footer</code>属性添加到每个对象的顶层。</p>
<p>此外，我们为Age列的对象中的<code>Footer</code>属性添加了一个函数。</p>
<p>年龄列的对象中的<code>Footer</code>属性是:</p>
<pre class="js">info =&gt; {
  const total = React.useMemo(
    () =&gt; info.rows.reduce((sum, row) =&gt; row.values.age + sum, 0),
    [info.rows]
  );

  return &lt;&gt;Average Age: {total / info.rows.length}&lt;/&gt;;
}</pre>
<p>它采用了包含所有表格数据的<code>info</code>对象。然后，我们对每个条目的所有<code>age</code>属性值求和，并除以<code>info.row.length</code>，得出平均年龄。这显示在表格底部的<strong>年龄</strong>栏下。</p>
<p>平均值会随着行的变化而变化，因为我们有<code>[info.rows]</code>，它会观察行中变化的值，并在行发生变化时重新计算值。</p>
<h2 id="sorting">整理</h2>
<p>我们可以通过调用几个函数给表格添加排序。我们必须将<code>useSortBy</code>钩子作为<code>useTable</code>钩子的第二个参数传入，以获得表中的排序能力。</p>
<p>然后，在我们的JSX代码中，我们必须传入<code>column.getSortByToggleProps()</code>到<code>column.getHeaderProps</code>来获得呈现列中列的排序顺序。</p>
<p>我们可以通过使用<code>column.isSorted</code>和<code>column.isSortedDesc</code>来检查一列的排序顺序，分别检查一列是按升序还是降序排序的。</p>
<p>此外，我们可以向列数组条目添加一个<code>sortType</code>属性，这样我们就可以指定排序类型。例如，我们可以编写以下代码来为我们的表添加基本排序:</p>
<pre class="js">import React from "react";
import { useTable, useSortBy } from "react-table";

const data = [
  { firstName: "jane", lastName: "doe" },
  { firstName: "john", lastName: "smith" }
];

const columns = [
  {
    Header: "Name",
    columns: [
      {
        Header: "First Name",
        accessor: "firstName",
        sortType: "basic"
      },
      {
        Header: "Last Name",
        accessor: "lastName",
        sortType: "basic"
      }
    ]
  }
];

const Table = ({ columns, data }) =&gt; {
  const {
    getTableProps,
    getTableBodyProps,
    headerGroups,
    rows,
    prepareRow
  } = useTable(
    {
      columns,
      data
    },
    useSortBy
  );

  return (
    &lt;table {...getTableProps()}&gt;
      &lt;thead&gt;
        {headerGroups.map(headerGroup =&gt; (
          &lt;tr {...headerGroup.getHeaderGroupProps()}&gt;
            {headerGroup.headers.map(column =&gt; (
              &lt;th {...column.getHeaderProps(column.getSortByToggleProps())}&gt;
                {column.render("Header")}
                &lt;span&gt;
                  {column.isSorted ? (column.isSortedDesc ? " 🔽" : " 🔼") : ""}
                &lt;/span&gt;
              &lt;/th&gt;
            ))}
          &lt;/tr&gt;
        ))}
      &lt;/thead&gt;
      &lt;tbody {...getTableBodyProps()}&gt;
        {rows.map((row, i) =&gt; {
          prepareRow(row);
          return (
            &lt;tr {...row.getRowProps()}&gt;
              {row.cells.map(cell =&gt; {
                return &lt;td {...cell.getCellProps()}&gt;{cell.render("Cell")}&lt;/td&gt;;
              })}
            &lt;/tr&gt;
          );
        })}
      &lt;/tbody&gt;
    &lt;/table&gt;
  );
};

export default function App() {
  return (
    &lt;div className="App"&gt;
      &lt;Table columns={columns} data={data} /&gt;
    &lt;/div&gt;
  );
}</pre>
<p>在上面的代码中，我们指定<code>sortType</code>是<code>'basic'</code>，这样单词按字母顺序排序，数字按数字顺序排序。</p><div class="code-block code-block-54">
<hr/>
<h3>更多来自LogRocket的精彩文章:</h3>

<hr/></div>
<p>然后我们通过书写来呈现<code>thead</code>:</p>
<pre class="js">&lt;thead&gt;
  {headerGroups.map(headerGroup =&gt; (
    &lt;tr {...headerGroup.getHeaderGroupProps()}&gt;
      {headerGroup.headers.map(column =&gt; (
        &lt;th {...column.getHeaderProps(column.getSortByToggleProps())}&gt;
          {column.render("Header")}
          &lt;span&gt;
            {column.isSorted ? (column.isSortedDesc ? " 🔽" : " 🔼") : ""}
          &lt;/span&gt;
        &lt;/th&gt;
      ))}
    &lt;/tr&gt;
  ))}
&lt;/thead&gt;</pre>
<p>这将添加图标，用于指示每列的排序顺序，并获取列的排序顺序。</p>
<p>写完代码后，我们会在列标题的右边看到一个排序按钮，我们可以点击它来对列进行排序。</p>
<h2 id="filtering">过滤</h2>
<p>过滤比创建简单的表或排序更复杂。我们必须创建一个带有输入控件的组件，我们可以用它来过滤我们的项目。输入组件将把从<code>useTable</code>返回的函数作为道具，并在输入中调用它们。</p>
<p>例如，我们可以编写以下代码来实现这一点:</p>
<pre class="js">import React from "react";
import { useTable, useFilters, useGlobalFilter } from "react-table";

const data = [
  { firstName: "jane", lastName: "doe", age: 20 },
  { firstName: "john", lastName: "smith", age: 21 }
];

const columns = [
  {
    Header: "Name",
    columns: [
      {
        Header: "First Name",
        accessor: "firstName",
        filter: "text"
      },
      {
        Header: "Last Name",
        accessor: "lastName",
        filter: "text"
      }
    ]
  },
  {
    Header: "Other Info",
    columns: [
      {
        Header: "Age",
        accessor: "age",
        filter: "text"
      }
    ]
  }
];

const DefaultColumnFilter = ({
  column: { filterValue, preFilteredRows, setFilter }
}) =&gt; {
  const count = preFilteredRows.length;

  return (
    &lt;input
      value={filterValue || ""}
      onChange={e =&gt; {
        setFilter(e.target.value || undefined);
      }}
      placeholder={`Search ${count} records...`}
    /&gt;
  );
};

const GlobalFilter = ({
  preGlobalFilteredRows,
  globalFilter,
  setGlobalFilter
}) =&gt; {
  const count = preGlobalFilteredRows &amp;&amp; preGlobalFilteredRows.length;

  return (
    &lt;span&gt;
      Search:{" "}
      &lt;input
        value={globalFilter || ""}
        onChange={e =&gt; {
          setGlobalFilter(e.target.value || undefined); // Set undefined to remove the filter entirely
        }}
        placeholder={`${count} records...`}
        style={{
          border: "0"
        }}
      /&gt;
    &lt;/span&gt;
  );
};

const Table = ({ columns, data }) =&gt; {
  const filterTypes = React.useMemo(
    () =&gt; ({
      text: (rows, id, filterValue) =&gt; {
        return rows.filter(row =&gt; {
          const rowValue = row.values[id];
          return rowValue !== undefined
            ? String(rowValue)
                .toLowerCase()
                .startsWith(String(filterValue).toLowerCase())
            : true;
        });
      }
    }),
    []
  );

  const defaultColumn = React.useMemo(
    () =&gt; ({
      Filter: DefaultColumnFilter
    }),
    []
  );

  const {
    getTableProps,
    getTableBodyProps,
    headerGroups,
    rows,
    prepareRow,
    state,
    visibleColumns,
    preGlobalFilteredRows,
    setGlobalFilter
  } = useTable(
    {
      columns,
      data,
      defaultColumn,
      filterTypes
    },
    useFilters,
    useGlobalFilter
  );

  return (
    &lt;table {...getTableProps()}&gt;
      &lt;thead&gt;
        {headerGroups.map(headerGroup =&gt; (
          &lt;tr {...headerGroup.getHeaderGroupProps()}&gt;
            {headerGroup.headers.map(column =&gt; (
              &lt;th {...column.getHeaderProps()}&gt;
                {column.render("Header")}
                &lt;div&gt;{column.canFilter ? column.render("Filter") : null}&lt;/div&gt;
              &lt;/th&gt;
            ))}
          &lt;/tr&gt;
        ))}
        &lt;tr&gt;
          &lt;th
            colSpan={visibleColumns.length}
            style={{
              textAlign: "left"
            }}
          &gt;
            &lt;GlobalFilter
              preGlobalFilteredRows={preGlobalFilteredRows}
              globalFilter={state.globalFilter}
              setGlobalFilter={setGlobalFilter}
            /&gt;
          &lt;/th&gt;
        &lt;/tr&gt;
      &lt;/thead&gt;
      &lt;tbody {...getTableBodyProps()}&gt;
        {rows.map((row, i) =&gt; {
          prepareRow(row);
          return (
            &lt;tr {...row.getRowProps()}&gt;
              {row.cells.map(cell =&gt; {
                return &lt;td {...cell.getCellProps()}&gt;{cell.render("Cell")}&lt;/td&gt;;
              })}
            &lt;/tr&gt;
          );
        })}
      &lt;/tbody&gt;
    &lt;/table&gt;
  );
};

export default function App() {
  return (
    &lt;div className="App"&gt;
      &lt;Table columns={columns} data={data} /&gt;
    &lt;/div&gt;
  );
}</pre>
<p>在上面的代码中，我们添加了如下的<code>GlobalFilter</code>组件:</p>
<pre class="js">const GlobalFilter = ({
  preGlobalFilteredRows,
  globalFilter,
  setGlobalFilter
}) =&gt; {
  const count = preGlobalFilteredRows &amp;&amp; preGlobalFilteredRows.length;

  return (
    &lt;span&gt;
      Search:{" "}
      &lt;input
        value={globalFilter || ""}
        onChange={e =&gt; {
          setGlobalFilter(e.target.value || undefined);
        }}
        placeholder={`${count} records...`}
        style={{
          border: "0"
        }}
      /&gt;
    &lt;/span&gt;
  );
};</pre>
<p>这用于通过调用作为props传入的<code>setGlobalFilter</code>函数来搜索数据中存在的所有列。<code>preGlobalFilteredRows</code>是一个数组，我们可以在其中计算要搜索的行数。</p>
<p>然后，在<code>Table</code>组件中，我们添加了以下代码:</p>
<pre class="js">const filterTypes = React.useMemo(
  () =&gt; ({
    text: (rows, id, filterValue) =&gt; {
      return rows.filter(row =&gt; {
        const rowValue = row.values[id];
        return rowValue !== undefined
          ? String(rowValue)
              .toLowerCase()
              .startsWith(String(filterValue).toLowerCase())
          : true;
      });
    }
  }),
  []
);

const defaultColumn = React.useMemo(
  () =&gt; ({
    Filter: DefaultColumnFilter
  }),
  []
);

const {
  getTableProps,
  getTableBodyProps,
  headerGroups,
  rows,
  prepareRow,
  state,
  visibleColumns,
  preGlobalFilteredRows,
  setGlobalFilter
} = useTable(
  {
    columns,
    data,
    defaultColumn,
    filterTypes
  },
  useFilters,
  useGlobalFilter
);</pre>
<p><code>defaultColumn</code>有一个缓存的对象，其<code>DefaultColumnFilter</code>设置如下:</p>
<pre class="js">const DefaultColumnFilter = ({
  column: { filterValue, preFilteredRows, setFilter }
}) =&gt; {
  const count = preFilteredRows.length;

  return (
    &lt;input
      value={filterValue || ""}
      onChange={e =&gt; {
        setFilter(e.target.value || undefined);
      }}
      placeholder={`Search ${count} records...`}
    /&gt;
  );
};</pre>
<p><code>defaultColumn</code>缓存用于搜索单个列的输入组件。我们还有<code>filterTypes</code>常量，它包含我们用来搜索表的过滤器的缓存值。</p>
<p>我们有一个带有<code>text</code>方法的对象，用于在我们键入时搜索我们要寻找的条目。在该方法中，我们调用了<code>rows</code>上的<code>filter</code>来返回以给定搜索字符串开始的项目，该字符串存储在<code>filterValue</code>中。</p>
<p>我们还使用了更多从<code>useTable</code>钩子返回的属性，并向钩子传递了更多的参数，包括<code>useFilters</code>和<code>useGlobalFilter</code>钩子，让我们分别按列和全局进行过滤。</p>
<p>此外，我们将<code>defaultColumn</code>和<code>filterTypes</code>对象添加到第一个参数中的对象，让我们设置默认情况下用于过滤的组件。<code>filterTypes</code>让我们将值设置为我们创建的函数的名称，该函数用于从数据数组中返回过滤后的数据。</p>
<p>最后，我们得到两个输入来分别过滤每一列，还有一个输入可以从全局过滤所有列中的项目。</p>

<p>我们可以使用<code>usePagination</code>钩子添加分页，它作为<code>useTable</code>钩子的参数传入。</p>
<p>然后,<code>useTable</code>钩子返回一堆与分页相关的变量，我们用它们来跟踪分页并导航到不同的页面。</p>
<p>要制作一个带有分页的简单表格，我们可以编写以下代码:</p>
<pre class="js">import React from "react";
import { useTable, usePagination } from "react-table";

const firstNames = ["jane", "john", "alex"];
const lastName = ["smith", "jones"];

const data = Array(100)
  .fill()
  .map(a =&gt; ({
    firstName: firstNames[Math.floor(Math.random() * firstNames.length)],
    lastName: lastName[Math.floor(Math.random() * lastName.length)],
    age: Math.ceil(75 * Math.random())
  }));

const columns = [
  {
    Header: "Name",
    columns: [
      {
        Header: "First Name",
        accessor: "firstName"
      },
      {
        Header: "Last Name",
        accessor: "lastName"
      }
    ]
  },
  {
    Header: "Other Info",
    columns: [
      {
        Header: "Age",
        accessor: "age"
      }
    ]
  }
];

const Table = ({ columns, data }) =&gt; {
  const {
    getTableProps,
    getTableBodyProps,
    headerGroups,
    prepareRow,
    page,
    canPreviousPage,
    canNextPage,
    pageOptions,
    pageCount,
    gotoPage,
    nextPage,
    previousPage,
    setPageSize,
    state: { pageIndex, pageSize }
  } = useTable(
    {
      columns,
      data,
      initialState: { pageIndex: 0 }
    },
    usePagination
  );

  return (
    &lt;&gt;
      &lt;table {...getTableProps()}&gt;
        &lt;thead&gt;
          {headerGroups.map(headerGroup =&gt; (
            &lt;tr {...headerGroup.getHeaderGroupProps()}&gt;
              {headerGroup.headers.map(column =&gt; (
                &lt;th {...column.getHeaderProps()}&gt;{column.render("Header")}&lt;/th&gt;
              ))}
            &lt;/tr&gt;
          ))}
        &lt;/thead&gt;
        &lt;tbody {...getTableBodyProps()}&gt;
          {page.map((row, i) =&gt; {
            prepareRow(row);
            return (
              &lt;tr {...row.getRowProps()}&gt;
                {row.cells.map(cell =&gt; {
                  return (
                    &lt;td {...cell.getCellProps()}&gt;{cell.render("Cell")}&lt;/td&gt;
                  );
                })}
              &lt;/tr&gt;
            );
          })}
        &lt;/tbody&gt;
      &lt;/table&gt;
      &lt;div&gt;
        &lt;button onClick={() =&gt; gotoPage(0)} disabled={!canPreviousPage}&gt;
          {"&lt;&lt;"}
        &lt;/button&gt;{" "}
        &lt;button onClick={() =&gt; previousPage()} disabled={!canPreviousPage}&gt;
          {"&lt;"}
        &lt;/button&gt;{" "}
        &lt;button onClick={() =&gt; nextPage()} disabled={!canNextPage}&gt;
          {"&gt;"}
        &lt;/button&gt;{" "}
        &lt;button onClick={() =&gt; gotoPage(pageCount - 1)} disabled={!canNextPage}&gt;
          {"&gt;&gt;"}
        &lt;/button&gt;{" "}
        &lt;span&gt;
          Page{" "}
          &lt;strong&gt;
            {pageIndex + 1} of {pageOptions.length}
          &lt;/strong&gt;{" "}
        &lt;/span&gt;
        &lt;span&gt;
          | Go to page:{" "}
          &lt;input
            type="number"
            defaultValue={pageIndex + 1}
            onChange={e =&gt; {
              const page = e.target.value ? Number(e.target.value) - 1 : 0;
              gotoPage(page);
            }}
            style={{ width: "100px" }}
          /&gt;
        &lt;/span&gt;{" "}
        &lt;select
          value={pageSize}
          onChange={e =&gt; {
            setPageSize(Number(e.target.value));
          }}
        &gt;
          {[10, 20, 30, 40, 50].map(pageSize =&gt; (
            &lt;option key={pageSize} value={pageSize}&gt;
              Show {pageSize}
            &lt;/option&gt;
          ))}
        &lt;/select&gt;
      &lt;/div&gt;
    &lt;/&gt;
  );
};

export default function App() {
  return (
    &lt;div className="App"&gt;
      &lt;Table columns={columns} data={data} /&gt;
    &lt;/div&gt;
  );
}</pre>
<p>在上面的代码中，我们生成了100个带有随机姓名和页面的数组条目。标题与上面的简单表格示例相同。</p>
<p>在<code>Table</code>组件中，我们有:</p>
<pre class="js">const {
  getTableProps,
  getTableBodyProps,
  headerGroups,
  prepareRow,
  page,
  canPreviousPage,
  canNextPage,
  pageOptions,
  pageCount,
  gotoPage,
  nextPage,
  previousPage,
  setPageSize,
  state: { pageIndex, pageSize }
} = useTable(
  {
    columns,
    data,
    initialState: { pageIndex: 0 }
  },
  usePagination
);</pre>
<p>这样，我们可以获得分页所需的各种数据，比如<code>pageSize</code>改变每页显示的项目数。</p>
<p><code>canPreviousPage</code>和<code>canNextPage</code>分别告诉我们是否可以移动到上一页或下一页。<code>pageCount</code>有总页数，<code>gotoPage</code>是一个让我们跳到给定页码的功能。<code>previousPage</code>和<code>nextPage</code>也是让我们导航到给定页面的功能。</p>
<p>它们在下面的<code>div</code>中用于在页面间导航:</p>
<pre class="js">&lt;div&gt;
  &lt;button onClick={() =&gt; gotoPage(0)} disabled={!canPreviousPage}&gt;
    {"&lt;&lt;"}
  &lt;/button&gt;{" "}
  &lt;button onClick={() =&gt; previousPage()} disabled={!canPreviousPage}&gt;
    {"&lt;"}
  &lt;/button&gt;{" "}
  &lt;button onClick={() =&gt; nextPage()} disabled={!canNextPage}&gt;
    {"&gt;"}
  &lt;/button&gt;{" "}
  &lt;button onClick={() =&gt; gotoPage(pageCount - 1)} disabled={!canNextPage}&gt;
    {"&gt;&gt;"}
  &lt;/button&gt;{" "}
  &lt;span&gt;
    Page{" "}
    &lt;strong&gt;
      {pageIndex + 1} of {pageOptions.length}
    &lt;/strong&gt;{" "}
  &lt;/span&gt;
  &lt;span&gt;
    | Go to page:{" "}
    &lt;input
      type="number"
      defaultValue={pageIndex + 1}
      onChange={e =&gt; {
        const page = e.target.value ? Number(e.target.value) - 1 : 0;
        gotoPage(page);
      }}
      style={{ width: "100px" }}
    /&gt;
  &lt;/span&gt;{" "}
  &lt;select
    value={pageSize}
    onChange={e =&gt; {
      setPageSize(Number(e.target.value));
    }}
  &gt;
    {[10, 20, 30, 40, 50].map(pageSize =&gt; (
      &lt;option key={pageSize} value={pageSize}&gt;
        Show {pageSize}
      &lt;/option&gt;
    ))}
  &lt;/select&gt;
&lt;/div&gt;</pre>
<p>然后我们得到一个表，它的列与上面的例子相同，但是添加了分页按钮。我们也可以使用下拉菜单来改变每个页面的大小。</p>
<h2 id="integration">将React表v7与材质UI集成</h2>
<p><code>react-table</code>包与材料UI集成，让我们创建一个遵循材料设计规范的表格。</p>
<p>要安装材料UI，我们运行:</p>
<pre class="sh">npm install @material-ui/core</pre>
<p>然后我们可以使用Material UI的表格组件和<code>react-table</code>来创建表格，如下所示:</p>
<pre class="js">import React from "react";
import { useTable } from "react-table";
import MaUTable from "@material-ui/core/Table";
import TableBody from "@material-ui/core/TableBody";
import TableCell from "@material-ui/core/TableCell";
import TableHead from "@material-ui/core/TableHead";
import TableRow from "@material-ui/core/TableRow";

const data = [
  { firstName: "jane", lastName: "doe", age: 20 },
  { firstName: "john", lastName: "smith", age: 21 }
];

const columns = [
  {
    Header: "Name",
    columns: [
      {
        Header: "First Name",
        accessor: "firstName"
      },
      {
        Header: "Last Name",
        accessor: "lastName"
      }
    ]
  },
  {
    Header: "Other Info",
    columns: [
      {
        Header: "Age",
        accessor: "age"
      }
    ]
  }
];

const Table = ({ columns, data }) =&gt; {
  const { getTableProps, headerGroups, rows, prepareRow } = useTable({
    columns,
    data
  });

  return (
    &lt;MaUTable {...getTableProps()}&gt;
      &lt;TableHead&gt;
        {headerGroups.map(headerGroup =&gt; (
          &lt;TableRow {...headerGroup.getHeaderGroupProps()}&gt;
            {headerGroup.headers.map(column =&gt; (
              &lt;TableCell {...column.getHeaderProps()}&gt;
                {column.render("Header")}
              &lt;/TableCell&gt;
            ))}
          &lt;/TableRow&gt;
        ))}
      &lt;/TableHead&gt;
      &lt;TableBody&gt;
        {rows.map((row, i) =&gt; {
          prepareRow(row);
          return (
            &lt;TableRow {...row.getRowProps()}&gt;
              {row.cells.map(cell =&gt; {
                return (
                  &lt;TableCell {...cell.getCellProps()}&gt;
                    {cell.render("Cell")}
                  &lt;/TableCell&gt;
                );
              })}
            &lt;/TableRow&gt;
          );
        })}
      &lt;/TableBody&gt;
    &lt;/MaUTable&gt;
  );
};

export default function App() {
  return (
    &lt;div className="App"&gt;
      &lt;Table columns={columns} data={data} /&gt;
    &lt;/div&gt;
  );
}</pre>
<p>在上面的代码中，我们使用了材质UI组件来呈现表格，但是数据是由<code>react-table</code>填充的。我们调用了在简单表格示例中使用的相同方法来用数据填充行和列。</p>
<p>因此，我们得到了与简单表格示例相同的数据和列，但是它遵循了材料设计，而不是没有样式。</p>
<div class="blog-plug cro21">
<h2>不要忘记表格呈现对性能的影响。尝试使用<a href="https://www2.logrocket.com/react-performance-monitoring"> LogRocket </a>来监控React应用。</h2>
<p>大型表会占用用户的CPU。使用LogRocket，您可以看到表和组件对所有用户的影响。如果您对监视和跟踪Redux状态、自动显示JavaScript错误、跟踪缓慢的网络请求和组件加载时间感兴趣，请尝试LogRocket 。【T2<img data-attachment-id="46" data-permalink="https://blog.logrocket.com/vuex-showdown-mutations-vs-actions/1d0cd-1s_rmyo6nbrasp-xtvbaxfg/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg-e1565635879164.png" data-orig-size="730,412" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="LogRocket dashboard free trial banner" data-image-description="&lt;p&gt;LogRocket is working on the perfect frontend bug report. Try it free today.&lt;/p&gt;&#10;" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg-e1565635879164.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg-e1565635879164.png" decoding="async" class="alignnone size-full wp-image-46 jetpack-lazy-image" src="../Images/f300c244a1a1cf916df8b4cb02bec6c6.png" data-lazy-src="https://files.readme.io/27c94e7-Image_2017-06-05_at_9.46.04_PM.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://files.readme.io/27c94e7-Image_2017-06-05_at_9.46.04_PM.png"/><noscript><img data-lazy-fallback="1" data-attachment-id="46" data-permalink="https://blog.logrocket.com/vuex-showdown-mutations-vs-actions/1d0cd-1s_rmyo6nbrasp-xtvbaxfg/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg-e1565635879164.png" data-orig-size="730,412" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="LogRocket dashboard free trial banner" data-image-description="&lt;p&gt;LogRocket is working on the perfect frontend bug report. Try it free today.&lt;/p&gt;&#10;" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg-e1565635879164.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg-e1565635879164.png" decoding="async" class="alignnone size-full wp-image-46" src="../Images/f300c244a1a1cf916df8b4cb02bec6c6.png" data-original-src="https://files.readme.io/27c94e7-Image_2017-06-05_at_9.46.04_PM.png"/></noscript><a class="signup" href="https://www2.logrocket.com/react-performance-monitoring" target="_blank" rel="noopener noreferrer"><img data-attachment-id="46" data-permalink="https://blog.logrocket.com/vuex-showdown-mutations-vs-actions/1d0cd-1s_rmyo6nbrasp-xtvbaxfg/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg-e1565635879164.png" data-orig-size="730,412" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="LogRocket dashboard free trial banner" data-image-description="&lt;p&gt;LogRocket is working on the perfect frontend bug report. Try it free today.&lt;/p&gt;&#10;" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg-e1565635879164.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg-e1565635879164.png" decoding="async" class="alignnone size-full wp-image-46 jetpack-lazy-image" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/><noscript><img data-lazy-fallback="1" data-attachment-id="46" data-permalink="https://blog.logrocket.com/vuex-showdown-mutations-vs-actions/1d0cd-1s_rmyo6nbrasp-xtvbaxfg/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg-e1565635879164.png" data-orig-size="730,412" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="LogRocket dashboard free trial banner" data-image-description="&lt;p&gt;LogRocket is working on the perfect frontend bug report. Try it free today.&lt;/p&gt;&#10;" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg-e1565635879164.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg-e1565635879164.png" decoding="async" loading="lazy" class="alignnone size-full wp-image-46" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/></noscript></a></p>
<p>LogRocket 就像是网络应用程序的DVR，记录React应用程序上发生的一切。您可以汇总并报告问题发生时应用程序的状态，而不是猜测问题发生的原因。LogRocket还可以监控应用程序的性能，报告客户端CPU负载、客户端内存使用等指标。</p>
<p>LogRocket Redux中间件包为您的用户会话增加了一层额外的可见性。LogRocket记录Redux存储中的所有操作和状态。</p>
<p>现代化您调试React应用的方式— <a class="signup" href="https://www2.logrocket.com/react-performance-monitoring" target="_blank" rel="noopener noreferrer">开始免费监控</a>。</p>
</div>
<h2>结论</h2>
<p>正如我们所看到的，react-table能够创建具有许多功能的表，而不必自己从头开始创建。</p>
<p>它为我们提供了一个基于钩子的API来创建表，这很重要，因为一些开发人员现在想转而使用带有钩子的函数组件。</p>
<p>还有很多例子可以展示react-table在官方GitHub repo 上可以做什么。有些例子是从他们官网上的例子简化而来的。</p>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
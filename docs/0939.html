<html>
<head>
<title>Migrating from Gatsby to Next.js - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>从Gatsby迁移到Next.js - LogRocket博客</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/migrating-from-gatsby-to-next-js/#0001-01-01">https://blog.logrocket.com/migrating-from-gatsby-to-next-js/#0001-01-01</a></blockquote><div><article class="article-post">
<h2>介绍</h2>
<p>像许多开发人员一样，我喜欢将我的博客作为个人游乐场来尝试最新的技术。我的博客是用<a href="https://www.gatsbyjs.org/" target="_blank" rel="noopener noreferrer"> Gatsby </a>写的，但最近我把它迁移到了<a href="https://nextjs.org/" target="_blank" rel="noopener noreferrer"> Next.js </a>。在这篇文章中，我将谈谈我的经历，哪些进展顺利，哪些进展不顺利。</p>
<p>请记住，虽然Gatsby和Next.js在功能上有重叠，但这两个工具在功能集、解决的问题和理念上有很大不同。如果你对这两个框架之间的全面比较感兴趣，我建议阅读<a href="https://blog.logrocket.com/next-js-vs-gatsbyjs-a-developers-perspective/" target="_blank" rel="noopener noreferrer"> Next.js vs. GatsbyJS:一个开发者的视角</a>。</p>
<p>请注意，自从那篇文章发表以来，这两个工具都得到了很多很好的更新，尤其是Next.js，所以一定要看看<a href="https://github.com/gatsbyjs/gatsby/blob/7afdfceb4cbd36a545896998152b9e606dde0e79/packages/gatsby/CHANGELOG.md" target="_blank" rel="noopener noreferrer"> Gatbsy的changelog </a>和<a href="https://nextjs.org/blog" target="_blank" rel="noopener noreferrer"> Next.js博客</a>。</p>
<h2>要求</h2>
<p>我最初开始使用Gatsby的原因是因为我想要编写代码的方式，并且我想要实现的设计需要对构建过程有更多的控制。</p>
<p>博客工具的问题是，虽然它们提供了很多现成的功能，但它们只提供了这么多的灵活性，所以对于没有包括在内的功能，我不得不不断说服自己，我并不真的<em>需要</em>它们，但我希望我唯一的约束是我有时间做什么，而不是我的工具支持什么。</p>
<p>除此之外，我想将多个帖子组合成一系列帖子，添加一个模糊搜索栏以便于查找帖子，并使用<a href="https://mdxjs.com" target="_blank" rel="noopener noreferrer"> MDX </a>将markdown不支持的自定义功能插入到我的帖子中。理想情况下，我想将我的博客作为一个React应用程序来创作，但将其构建为一个不依赖于JavaScript的静态网站。</p>
<p>最初，我尝试使用Next.js，但当时它仍然是v4.1.4，而在撰写本文时是v9.3，它没有我需要的所有功能，如静态导出，所以我继续搜索。</p>
<p>最终，盖茨比引起了我的注意，随着时间的推移，我设法用它建立了我的博客。然而，学习盖茨比并不容易。</p>
<h2>起点:盖茨比</h2>
<p>我对GraphQL本身完全陌生，更不用说Gatsby构建网站的编程方法了，这对我来说是一个巨大的学习曲线。通过大量的实践，我对Gatsby已经驾轻就熟了，最终，它给了我迫切想要的东西——能够作为一个React应用程序来创作我的博客。</p>
<p>虽然Gatsby提取数据和构建页面的编程方法对我来说似乎有些间接，但我不能否认它有多么强大，我可以用它做几乎任何我想做的事情，这是我第一次不受工具的约束。我添加的一个功能是将相关的文章组合成系列，这样我就可以像这样显示单独的部分:</p>
<p><img data-attachment-id="20279" data-permalink="https://blog.logrocket.com/migrating-from-gatsby-to-next-js/attachment/mockingwithjest/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/06/mockingwithjest.png" data-orig-size="730,356" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="mockingwithjest" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/06/mockingwithjest-300x146.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/06/mockingwithjest.png" decoding="async" class="aligncenter size-full wp-image-20279 jetpack-lazy-image" src="../Images/06a92982423f18dd76b7087b7008e580.png" alt="mocking with jest" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2020/06/mockingwithjest.png 730w, https://blog.logrocket.com/wp-content/uploads/2020/06/mockingwithjest-300x146.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2020/06/mockingwithjest.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/06/mockingwithjest.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="20279" data-permalink="https://blog.logrocket.com/migrating-from-gatsby-to-next-js/attachment/mockingwithjest/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/06/mockingwithjest.png" data-orig-size="730,356" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="mockingwithjest" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/06/mockingwithjest-300x146.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/06/mockingwithjest.png" decoding="async" loading="lazy" class="aligncenter size-full wp-image-20279" src="../Images/06a92982423f18dd76b7087b7008e580.png" alt="mocking with jest" srcset="https://blog.logrocket.com/wp-content/uploads/2020/06/mockingwithjest.png 730w, https://blog.logrocket.com/wp-content/uploads/2020/06/mockingwithjest-300x146.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/06/mockingwithjest.png"/></noscript>
<p>我的<a href="https://github.com/silvenon/silvenon.com/blob/c2331c8b85b305501c5d5b1c5087526df7a21e5a/gatsby-node.js" target="_blank" rel="noopener noreferrer"> gatsby-node.js </a>只有200行代码，它有各种各样的功能，像语言、类别、分页、文章系列、草稿，我甚至可以通过编程添加<a href="https://docs.netlify.com/routing/redirects/" target="_blank" rel="noopener noreferrer"> Netlify重定向</a>！</p>
<p>有很多盖茨比插件可以执行非常有趣的任务，我<a href="https://www.npmjs.com/search?q=author%3Asilvenon%20gatsby-plugin" target="_blank" rel="noopener noreferrer">甚至自己也做了一些。这个生态系统允许我轻松地为我的博客建立一个站点地图和一个提要。</a></p>
<p>但是，我对Gatsby的主要痛点是GraphQL，尤其是结合类型检查。我经常不得不编写大型查询，然后为它们编写类型，如果我想要某种类型的安全，重复相同的数据结构，然后访问所有这些深度嵌套的数据，经常使用析构来使它更容易…我从来没有完全习惯它，它总是感觉冗长。</p>
<p>尽管我设法实现了我想要的每一个特性，但我开始希望有一个更简单的替代方案来帮助我更快地工作。这时候我开始注意到Next.js，它只是在9.3版本更新，包括<a href="https://nextjs.org/blog/next-9-3#next-gen-static-site-generation-ssg-support" target="_blank" rel="noopener noreferrer">静态站点生成</a>。</p>
<h2>目的地:Next.js</h2>
<p>从开发人员的角度来看，Next.js要容易得多。然而，迁移所有这些逻辑是一个相当大的挑战，我不得不做出许多改变来适应这个新环境，但是主要的挑战无疑是MDX。当我使用Gatsby的时候，我的博客文章在一个单独的目录中，在那里它们被Gatsby的MDX插件处理。这样，他们的数据就可以通过GraphQL输出到任何地方——front matter、exported values、body等。我还附加了我自己的自定义字段，如URL和关于系列的各种数据。这让我对输出有了很大的控制权。</p>
<p>Next.js也有一个<a href="https://www.npmjs.com/package/@next/mdx" target="_blank" rel="noopener noreferrer">官方MDX插件</a>，但它所做的只是添加了Webpack loader，而<a href="https://github.com/gatsbyjs/gatsby/tree/00e08792ce08be904ff4a7a53c70ce70b7649f0b/packages/gatsby-plugin-mdx" target="_blank" rel="noopener noreferrer"> Gatsby的MDX插件</a>做的要多得多。起初，我认为这可以在Next.js中通过动态路由和用于markdown的<a href="https://nextjs.org/blog/next-9-3#next-gen-static-site-generation-ssg-support" target="_blank" rel="noopener noreferrer">静态站点生成</a>来实现，因为它可以在构建时编译成静态HTML，但是MDX是一种不同的格式:虽然它看起来像是Markdown的超集，但它实际上是JSX的超集，因为它编译成React组件，并且它支持模块和定制组件，所以MDX文件应该像所有其他组件一样对待。这意味着我必须把我的文章放在<code>pages</code>目录中，所以没有办法添加像默认布局或列出文章这样的行为。或者有吗？</p>
<p>MDX的官方Next.js插件并不是唯一的一个，<a href="https://www.npmjs.com/search?q=next+mdx" target="_blank" rel="noopener noreferrer">还有更多的</a>，有些是专门为博客优化的。最受欢迎的选择是<a href="https://github.com/hashicorp/next-mdx-enhanced" target="_blank" rel="noopener noreferrer"> next-mdx-enhanced </a>，它支持默认布局和frontmatter。如果这就是你所需要的，那么宾果！现在只剩下列表帖子了。</p>
<p>如果你需要的只是提取标题、发布日期和文章链接之类的标题信息，你可以通过遍历<code><a href="https://nextjs.org/docs/basic-features/data-fetching#getstaticprops-static-generation" target="_blank" rel="noopener noreferrer">getStaticProps</a></code>中的文件系统，从文件路径计算URL，并使用<a href="https://github.com/jonschlinkert/gray-matter" target="_blank" rel="noopener noreferrer"> gray-matter </a>之类的工具来提取标题信息。</p>
<p>然而，我不想牺牲我和盖茨比在一起的任何特点，所以我必须有所创新。我知道理解并试图复制Gatsby的MDX插件的所有逻辑将花费我太多的时间，但我想尽可能多地了解它，以获得一些灵感，这使我开始更深入地研究<a href="https://unifiedjs.com/" target="_blank" rel="noopener noreferrer">统一的</a>生态系统。</p>
<p>随着时间的推移，我意识到我可以通过创建自定义注释和重新键入插件来编辑内容，这也是Gatsby的插件所做的事情。我可以通过编辑AST来添加布局导出语句、JSX摘录、关于系列的数据。</p>
<p>进入所有这些特性可能是一个单独的职位，所以我只是给你一个例子；这是我写的一个注释插件的简化版本，用来给我的帖子添加一个默认布局:</p>
<pre>const u = require('unist-builder')

const defaultLayout = ({ importFrom }) =&gt; (tree) =&gt; {
  tree.children.unshift(
    u('import', `import DefaultLayout from ${JSON.stringify(importFrom)}`),
  )

  tree.children.push(
    u('export', {
      default: true,
      value: `export default DefaultLayout`,
    }),
  )
}

module.exports = defaultLayout</pre>
<p>我在<code>next.config.js</code>中应用MDX插件时把它加到了<code>remarkPlugins</code>:</p>
<pre>const defaultLayout = require('./plugins/remark-mdx-default-layout')
const withMdx = require('@next/mdx')({
  remarkPlugins = [
    [defaultLayout, { importFrom: '../../components/DefaultLayout' })],
  ],
})

module.exports = withMdx({
  pageExtensions: ['js', 'jsx', 'mdx'],
})</pre>
<p>很简单，不是吗？</p>
<p>列出帖子是一个单独的挑战。起初，似乎可以在<code>getStaticProps</code>中完成，但是不可能在那里导入模块，这是访问导出元数据的唯一方式，并且为每个帖子维护一个导入语句列表是不可伸缩的。然而，有一个中间地带。用<a href="https://github.com/kentcdodds/babel-plugin-codegen" target="_blank" rel="noopener noreferrer"> babel-plugin-codegen </a>生成那些导入语句。</p>
<p>这个插件的好处一开始有点难以理解，这就是为什么像这样的真实世界用例是最好的理解方式。这是我想要的代码:</p>
<pre>import * as PostOne from './posts/one'
import * as PostTwo from './posts/two'
import * as PostThree from './posts/three'
// ...

const posts = [
  PostOne,
  PostTwo,
  PostThree,
  // ...
]</pre>
<p>我使用名称空间导入(用<code>* as</code>)，这样我就可以访问从帖子中导出的所有元数据。</p>
<p>我首先将babel-plugin-codegen添加到我的babel配置中，从而生成了这段代码:</p>
<pre>module.exports = {
  presets: ['next/babel'],
  plugins: ['codegen'],
}</pre>
<p>然后，我编写了一个脚本来生成上述代码:</p>
<pre>const fs = require('fs')
const path = require('path')
const posts = fs.readdirSync(path.join(process.cwd(), 'pages/posts'))

const importStatements = []
const importNames = []
let result = ''

posts.forEach((post, index) =&gt; {
  importStatements.push(`import * as Post${index + 1} from './posts/${path.basename(post, '.mdx')}'`)
  importNames.push(`Post${index + 1}`)
})

result += importStatements.join('\n')
result += '\n\n'
result += `const posts = [${importNames.join(', ')}]`

module.exports = result</pre>
<p>最后，我使用babel-plugin-codegen的导入注释导入了脚本:</p>
<pre>import /* codegen */ posts from '../codegen/posts-list'</pre>
<p>现在，我可以随心所欲地呈现我的帖子列表，例如:</p>
<pre>&lt;ul&gt;
  {posts.map(({ frontmatter, path }) =&gt; (
    &lt;li key={path}&gt;
      &lt;Link href={path}&gt;{frontmatter.title}&lt;/Link&gt;
    &lt;/li&gt;
  ))}
&lt;/ul&gt;</pre>
<p>当然，您会希望在出版日期之前订购它们。</p>
<p>我想解决的最后两个问题是站点地图和提要。</p>
<p>为了生成站点地图，我找到了<a href="https://www.npmjs.com/package/nextjs-sitemap-generator" target="_blank" rel="noopener noreferrer"> nextjs-sitemap-generator </a>，它做得很好，也很容易使用:</p>
<pre>const sitemap = require('nextjs-sitemap-generator')
const path = require('path')

await sitemap({
  baseUrl: 'https://silvenon.com',
  ignoreIndexFiles: true,
  pagesDirectory: path.join(process.cwd(), 'out'),
  targetDirectory: path.join(process.cwd(), 'out'),
})</pre>
<p>生成提要需要更多的工作。幸运的是，我可以重用许多从我的帖子中提取元数据的功能，并使用<a href="https://www.npmjs.com/package/feed" target="_blank" rel="noopener noreferrer"> feed </a>包来创建提要。下面是一个添加提要的示例，为了简洁起见，省略了提取元数据的逻辑:</p>
<pre>const feed = require('feed')

posts.forEach(({ frontmatter, path, excerpt }) =&gt; {
  feed.addItem({
    title: frontmatter.title,
    id: `https://silvenon.com${path}`,
    link: `https://silvenon.com${path}`,
    description: excerpt,
    author: [
      {
        name: 'Matija Marohnić',
        email: '<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="cba6aabfa2a1aae5a6aab9a4a3a5a2a88baca6aaa2a7e5a8a4a6">[email protected]</a>',
        link: 'https://silvenon',
      },
    ],
    date: new Date(frontmatter.published),
  })
})</pre>
<p>阅读readme以获得创建提要的完整说明。</p>
<h2>结论</h2>
<p>博客是一种特殊类型的网站，在某些方面比较简单，在其他方面，它们可能相当复杂，尤其是我的博客。为工作选择正确的工具通常很困难，因为没有经验很难准确评估工具在实践中是否有效，这就是为什么在实际尝试之前阅读一下选项是好的。</p>
<p>然而，使用Next.js进行静态导出仍然是相当新的，特别是考虑到关键特性仅仅在几个月前才登陆，所以我很好奇我是否能完成它。MDX被证明是唯一似乎无法克服的障碍，因为生态系统还没有准备好，但有许多伟大的事情即将到来<a href="https://github.com/mdx-js/mdx/issues/1041" target="_blank" rel="noopener noreferrer"> MDX v2 </a>可能会解决我遇到的大多数问题，所以请密切关注！</p><div class="code-block code-block-30">
<div class="blog-plug inline-plug next-plug"><h2><a href="https://lp.logrocket.com/blg/nextjs-signup" target="_blank"> LogRocket </a>:全面了解生产Next.js应用</h2><p>调试下一个应用程序可能会很困难，尤其是当用户遇到难以重现的问题时。如果您对监视和跟踪状态、自动显示JavaScript错误、跟踪缓慢的网络请求和组件加载时间感兴趣，</p><a href="https://lp.logrocket.com/blg/nextjs-signup" target="_blank">try LogRocket</a><p>. </p><a class="signup" href="https://lp.logrocket.com/blg/nextjs-signup" target="_blank" rel="noopener noreferrer"><img class="alignnone size-full wp-image-46 jetpack-lazy-image" src="../Images/f300c244a1a1cf916df8b4cb02bec6c6.png" data-lazy-src="https://files.readme.io/27c94e7-Image_2017-06-05_at_9.46.04_PM.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://files.readme.io/27c94e7-Image_2017-06-05_at_9.46.04_PM.png"/><noscript><img data-lazy-fallback="1" class="alignnone size-full wp-image-46" src="../Images/f300c244a1a1cf916df8b4cb02bec6c6.png" data-original-src="https://files.readme.io/27c94e7-Image_2017-06-05_at_9.46.04_PM.png"/></noscript></a><a class="signup" href="https://lp.logrocket.com/blg/nextjs-signup" target="_blank" rel="noopener noreferrer"><img class="alignnone size-full wp-image-46 jetpack-lazy-image" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/><noscript><img data-lazy-fallback="1" class="alignnone size-full wp-image-46" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/></noscript></a><p>LogRocket 就像是网络和移动应用的DVR，记录下你的Next.js应用上发生的一切。您可以汇总并报告问题发生时应用程序的状态，而不是猜测问题发生的原因。LogRocket还可以监控应用程序的性能，报告客户端CPU负载、客户端内存使用等指标。</p><p>LogRocket Redux中间件包为您的用户会话增加了一层额外的可见性。LogRocket记录Redux存储中的所有操作和状态。</p><p>让您调试Next.js应用的方式现代化— <a class="signup" href="https://lp.logrocket.com/blg/nextjs-signup" target="_blank" rel="noopener noreferrer">开始免费监控</a>。</p></div></div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
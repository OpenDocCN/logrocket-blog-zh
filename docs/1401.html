<html>
<head>
<title>Advanced React Hooks: Creating custom reusable Hooks - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>高级React钩子:创建定制的可重用钩子</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/advanced-react-hooks-creating-custom-reusable-hooks/#0001-01-01">https://blog.logrocket.com/advanced-react-hooks-creating-custom-reusable-hooks/#0001-01-01</a></blockquote><div><article class="article-post">
<p>React钩子在React 16.8.0版本中首次引入，是允许开发人员增强功能组件的新API。使我们有可能用功能组件做以前只能用类做的事情。</p>
<p>因此，我们可以在不编写类的情况下使用状态和其他React特性。</p>
<p>自从它们被引进以来，<code>Hooks</code>已经对React生态系统产生了巨大的影响。它们永远改变了React应用的构建方式。</p>
<p>在本文中，我们将看看可重用的<code>Hook</code>模式的实际应用。当我们考虑这些时，重要的是要提到<code>Hooks</code>是可组合的，这意味着您可以在您的自定义<code>Hook</code>中调用另一个<code>Hook</code>。</p>
<h2>可重用<code>Hook</code>模式的用例</h2>
<p>下面让我们考虑一些可重用的<code>Hook</code>模式:</p>
<h3>使用<code>useIsMounted</code>挂钩</h3>
<p>在React中，一旦一个组件是<code>unmounted</code>，它就不会再是<code>mounted</code>，这就是为什么我们不在一个<code><a href="https://reactjs.org/docs/react-component.html#componentwillunmount" target="_blank" rel="noopener">unmounted</a></code> <a href="https://reactjs.org/docs/react-component.html#componentwillunmount" target="_blank" rel="noopener">组件</a>中设置状态。这是因为它永远不会被重新渲染。</p>
<p><img data-attachment-id="30643" data-permalink="https://blog.logrocket.com/advanced-react-hooks-creating-custom-reusable-hooks/unmounted-example-app/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/12/unmounted-example-app.png" data-orig-size="730,441" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="An example app that is unmounted" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/12/unmounted-example-app-300x181.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/12/unmounted-example-app.png" decoding="async" class="aligncenter size-full wp-image-30643 jetpack-lazy-image" src="../Images/3b2af1fff7e8daff9d6b09a94322fc06.png" alt="An Example of an App That Is Unmounted" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2020/12/unmounted-example-app.png 730w, https://blog.logrocket.com/wp-content/uploads/2020/12/unmounted-example-app-300x181.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2020/12/unmounted-example-app.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/12/unmounted-example-app.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="30643" data-permalink="https://blog.logrocket.com/advanced-react-hooks-creating-custom-reusable-hooks/unmounted-example-app/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/12/unmounted-example-app.png" data-orig-size="730,441" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="An example app that is unmounted" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/12/unmounted-example-app-300x181.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/12/unmounted-example-app.png" decoding="async" loading="lazy" class="aligncenter size-full wp-image-30643" src="../Images/3b2af1fff7e8daff9d6b09a94322fc06.png" alt="An Example of an App That Is Unmounted" srcset="https://blog.logrocket.com/wp-content/uploads/2020/12/unmounted-example-app.png 730w, https://blog.logrocket.com/wp-content/uploads/2020/12/unmounted-example-app-300x181.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/12/unmounted-example-app.png"/></noscript>
<p>上图展示了这个问题的一个小的人为的<a href="https://codesandbox.io/s/jovial-cache-5y56e?fontsize=14&amp;hidenavigation=1&amp;theme=dark" target="_blank" rel="noopener">示例应用</a>。</p>
<p>在上面的应用中，<code>Dev component</code>只有在<code>showDev state</code>为真时才会被渲染。点击<code>stop button</code>切换<code>showDev state</code>的值。因此，当<code>showDev</code>为假时<code>unmounting</code>发生<code>Dev component</code>。</p>
<p>下面是<code>Dev component</code>的实现。</p>
<pre>function Dev() {
  const [devProfile, setDevProfile] = useState("Fetching Dev...");
  const getDevProfile = () =&gt; {
    setTimeout(() =&gt; setDevProfile("Lawrence Eagles"), 4000);
  };
  useEffect(() =&gt; {
    getDevProfile();
  });
  return (
    &lt;div className="mb-4 text-center"&gt;
      &lt;p&gt;{devProfile}&lt;/p&gt;
    &lt;/div&gt;
  );
}
</pre>
<p>从上面的代码我们可以看到，一旦组件<code>mounts</code>，就调用了<code>getDevProfile</code>函数。这需要<code>4000 milliseconds</code>运行，然后用<code>Lawrence Eagles</code>更新<code>devProfile state</code>。</p>
<p>如果我们在<code>4000 milliseconds</code>之前<code>unmount</code><code>Dev component</code>(通过点击<code>stop button</code>)，React会显示上图所示的警告错误。</p>
<p>虽然此错误不会破坏用户界面，但它会导致内存泄漏，从而影响性能。</p>
<p>为了避免这个问题，一些开发人员这样做:</p>
<pre>if (this.isMounted()) { // This is bad.
  this.setState({...});
}
</pre>
<p>但是React团队考虑使用<code><a href="https://reactjs.org/blog/2015/12/16/ismounted-antipattern.html" target="_blank" rel="noopener">isMounted function</a></code>作为反模式，所以他们建议您自己跟踪<code>mounted status</code>。</p>
<pre>  useEffect(() =&gt; {
    let isMounted = true; // sets mounted flag true
    return () =&gt; {
      // simulate an api call and update state here
      isMounted = false;
    }; // use effect cleanup to set flag false, if unmounted
  }, []);
  return isMounted;
};</pre>
<p>我们的目标是将上述逻辑抽象成一个自定义的<code>Hook</code>，我们可以在代码中重用它；因此，我们保留我们的代码<code>DRY</code>。</p>
<p>为此，将上面的所有样板代码封装到一个自定义的<code>Hook</code> ( <code>useIsMounted Hook</code>)中，如下所示:</p>
<pre>import { useEffect, useState } from "react";
const useIsMounted = () =&gt; {
  const [isMounted, setIsMouted] = useState(false);
  useEffect(() =&gt; {
    setIsMouted(true);
    return () =&gt; setIsMouted(false);
  }, []);
  return isMounted;
};
export default useIsMounted;
</pre>
<p>现在我们可以像这样在我们的应用程序中使用它:</p>
<pre>function Dev() {
  const isMounted = useIsMounted();
  const [devProfile, setDevProfile] = useState("Fetching Dev...");
  useEffect(() =&gt; {
    function getDevProfile() {
      setTimeout(() =&gt; {
        if (isMounted) setDevProfile("Lawrence Eagles");
      }, 4000);
    }
    getDevProfile();
  });
  return (
    &lt;div className="mb-4 text-center"&gt;
      &lt;p&gt;{devProfile}&lt;/p&gt;
    &lt;/div&gt;
  );
}
</pre>
<p>上面的<a href="https://codesandbox.io/s/sad-fog-32lz3?fontsize=14&amp;hidenavigation=1&amp;theme=dark" target="_blank" rel="noopener">代码</a>保证了只有当组件仍然是<code>mounted</code>的时候状态才会被更新。</p>
<h3><code>useLoading Hook</code></h3>
<p>这是一个经过深思熟虑的可重用的<code>Hook</code>，在有许多链接到资源的按钮的场景中，一旦组件<code>mounts</code>被加载，它就可以节省时间。</p>
<p>通常，当<code>async call</code>运行以获取资源时，会有某种类型的<code>Loading..</code>微调器。</p>
<p>挑战在于这些按钮的数量会随着资源的增加而增加，这会使我们的组件因不同的<code>loading states</code>而变得混乱。</p>
<p>考虑这个<a href="https://codesandbox.io/s/summer-bash-hqf9h?file=/src/App.js" target="_blank" rel="noopener">代码</a>:</p>
<pre>import "./styles.css";
import React, { useState, useEffect } from "react";
export default function App() {
  const delay = (ms) =&gt; new Promise((resolve) =&gt; setTimeout(resolve, ms));
  const [isLoadingDev, setIsLoadingDev] = useState(true);
  const [isLoadingStack, setIsLoadingStack] = useState(true);
  const fetchDevs = async () =&gt; {
    console.log("this might take some time....");
    await delay(4000);
    setIsLoadingDev(false);
    console.log("Done!");
  };
  const fetchStacks = async () =&gt; {
    console.log("this might take some time....");
    await delay(5000);
    setIsLoadingStack(false);
    console.log("Done!");
  };
  useEffect(() =&gt; {
    fetchDevs();
    fetchStacks();
  }, []);

  return (
    &lt;div className="app 
     container 
     d-flex 
     flex-column 
     justify-content-center 
     align-items-center"
    &gt;
      &lt;article className="d-flex flex-column my-2"&gt;
        &lt;p className="text-center"&gt;Welcome to Dev Hub&lt;/p&gt;
      &lt;/article&gt;
      &lt;article className="d-flex flex-column"&gt;
        &lt;button className="m-2 p-3 btn btn-success btn-sm"&gt;
          {isLoadingDev ? "Loading Devs..." : "View Devs"}
        &lt;/button&gt;
        &lt;button className="m-2 p-3 btn btn-success btn-sm"&gt;
          {isLoadingStack ? "Loading Stacks..." : "View Stacks"}
        &lt;/button&gt;
      &lt;/article&gt;
    &lt;/div&gt;
  )
}
</pre>
<p>在上面的代码中，<code>fetchDev</code>和<code>fetchStacks</code>函数被设计成模拟一个<code>async request</code>。一旦组件<code>mounts</code>被调用，当这些功能完成时，按钮中的消息改变。</p>
<p>每个按钮的<code>loading status</code>由一个<code>useState</code>初始化处理，随着我们加载更多的资源，它的数量会增加。</p>
<p>这段代码不是<code>DRY</code>，重复是产生错误的原因。</p>
<p>我们可以通过创建一个可重用的<code>useLoading Hook</code>来重构上面的代码，如下所示:</p>
<pre>import { useState } from "react";
const useLoading = (action) =&gt; {
  const [loading, setLoading] = useState(false);
  const doAction = (...args) =&gt; {
    setLoading(true);
    return action(...args).finally(() =&gt; setLoading(false));
  };
  return [doAction, loading];
};
export default useLoading;
</pre>
<p>这个钩子接受一个<code>async function</code>并返回一个包含该函数和<code>loading status</code>的数组。</p><div class="code-block code-block-54">
<hr/>
<h3>更多来自LogRocket的精彩文章:</h3>

<hr/></div>
<p>我们还能够将我们的<code>useState</code>逻辑抽象到这个组件，我们只需要一次初始化。</p>
<p>我们可以在代码中使用它，就像这样:</p>
<pre>import "./styles.css";
import React, { useEffect } from "react";
import useLoading from "./useLoading";
export default function App() {
  const delay = (ms) =&gt; new Promise((resolve) =&gt; setTimeout(resolve, ms));
  const fetchDevs = async () =&gt; {
    console.log("this might take some time....");
    await delay(4000);
    console.log("Done!");
  };
  const fetchStacks = async () =&gt; {
    console.log("this might take some time....");
    await delay(5000);
    console.log("Done!");
  };
  const [getDev, isLoadingDev] = useLoading(fetchDevs);
  const [getStacks, isLoadingStack] = useLoading(fetchStacks);
  useEffect(() =&gt; {
    getDev();
    getStacks();
  }, []);
  return (
    &lt;div className="app 
         container 
         d-flex 
         flex-column 
         justify-content-center 
         align-items-center"
    &gt;
      &lt;article className="d-flex flex-column my-2"&gt;
        &lt;p className="text-center"&gt;Welcome to Dev Hub&lt;/p&gt;
      &lt;/article&gt;
      &lt;article className="d-flex flex-column"&gt;
        &lt;button className="m-2 p-3 btn btn-success btn-sm"&gt;
          {isLoadingDev ? "Loading Devs..." : `View Devs`}
        &lt;/button&gt;
        &lt;button className="m-2 p-3 btn btn-success btn-sm"&gt;
          {isLoadingStack ? "Loading Stacks..." : "View Stacks"}
        &lt;/button&gt;
      &lt;/article&gt;
    &lt;/div&gt;
  );
}
</pre>
<p>这里，我们用<code>array destructuring</code>来得到<code>async action function</code>和<code>loading status</code>。</p>
<pre>  const [getDev, isLoadingDev] = useLoading(fetchDevs);
  const [getStacks, isLoadingStack] = useLoading(fetchStacks);
</pre>
<p>然后在<code>useEffect Hook</code>和视图中使用。结果是一个干净的代码，更容易维护。</p>
<p>同样，在所有的<code>loading status</code>完成之后，我们现在可以轻松地做一些事情，比如渲染一个组件，更新状态等等。</p>
<pre>if(isLoadingDev &amp;&amp; isLoadingStack) {
  // do somthing
}

return {
  // normal component view
}
</pre>
<h2>结论</h2>
<p>我希望在这次演讲之后，你能理解保留你的代码的必要性，并准备好开始编写定制的可重用代码。</p>
<p>这只是创建可重用定制<code>Hooks</code>的高级模式的两个例子，现在希望你可以创建自己的高级模式。</p>
<p>你可以在这里阅读更多关于打造自己的<code>Hooks</code> <a href="https://reactjs.org/docs/hooks-custom.html" target="_blank" rel="noopener">的内容。</a></p><div class="code-block code-block-17">
<div class="blog-plug inline-plug react-plug" vwo-el-id="26283398190">
<h2 vwo-el-id="41600691720"><a href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener"> LogRocket </a>:全面了解您的生产React应用</h2><p>调试React应用程序可能很困难，尤其是当用户遇到难以重现的问题时。如果您对监视和跟踪Redux状态、自动显示JavaScript错误以及跟踪缓慢的网络请求和组件加载时间感兴趣，</p><a href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" vwo-el-id="19356441070">try LogRocket</a><p>. </p><a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="19356441380">
<img class="first-react-image alignnone size-full wp-image-46 jetpack-lazy-image jetpack-lazy-image--handled" src="../Images/f300c244a1a1cf916df8b4cb02bec6c6.png" vwo-el-id="18272717540" data-lazy-loaded="1" data-original-src="https://files.readme.io/27c94e7-Image_2017-06-05_at_9.46.04_PM.png"/>
</a>
<a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="19356441690">
<img class="second-react-image alignnone size-full wp-image-46 jetpack-lazy-image jetpack-lazy-image--handled" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" vwo-el-id="30720362350" data-lazy-loaded="1" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/>
</a>
<p vwo-el-id="28675660440" class="">LogRocket 结合了会话回放、产品分析和错误跟踪，使软件团队能够创建理想的web和移动产品体验。这对你来说意味着什么？</p>
<p>LogRocket不是猜测错误发生的原因，也不是要求用户提供截图和日志转储，而是让您回放问题，就像它们发生在您自己的浏览器中一样，以快速了解哪里出错了。</p>
<p>不再有嘈杂的警报。智能错误跟踪允许您对问题进行分类，然后从中学习。获得有影响的用户问题的通知，而不是误报。警报越少，有用的信号越多。</p>
<p vwo-el-id="28675660750">LogRocket Redux中间件包为您的用户会话增加了一层额外的可见性。LogRocket记录Redux存储中的所有操作和状态。</p>
<p vwo-el-id="28675661060">现代化您调试React应用的方式— <a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="40093418840">开始免费监控</a>。</p>
</div></div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
<html>
<head>
<title>Router options compared: Vue Router, Voie, Vue-routisan and Vue-route - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>路由器选项比较:Vue路由器，Voie，Vue-routisan和Vue-route - LogRocket博客</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/router-options-compared/#0001-01-01">https://blog.logrocket.com/router-options-compared/#0001-01-01</a></blockquote><div><article class="article-post">
<h2>介绍</h2>
<p>现代web框架的出现改变了开发人员思考和构建软件的方式。我们现在可以使用灵活的框架(名字真的很酷)——比如<a href="https://angular.io/" target="_blank" rel="noopener noreferrer"> Angular </a>、<a href="https://reactjs.org/" target="_blank" rel="noopener noreferrer"> React </a>和<a href="https://vuejs.org/" target="_blank" rel="noopener noreferrer">Vue</a>——轻松地创建吸引人的界面。</p>
<p> </p>
<p>使用现代前端框架的一些好处包括:</p>
<p> </p>
<p><a href="https://www.freecodecamp.org/news/reacts-jsx-vs-vue-s-templates-a-showdown-on-the-front-end-b00a70470409/" target="_blank" rel="noopener noreferrer">模板系统</a></p>
<ul>
<li>渐进式web应用程序(PWA)功能</li>
<li>反应性(数据绑定)</li>
<li>最佳化</li>
<li>按指定路线发送</li>
<li>单页应用程序(SPA)</li>
<li> </li>
</ul>
<p>每个框架都有解决问题的独特方式，但是框架的一般概念规定了它们之间的基本相似性。在本文中，我们将探讨客户端路由、其重要性以及Vue路由器——我们用于Vue应用的首选路由器。</p>
<p> </p>
<p>SPA是在整个交互过程中在单个页面的空间内显示动态内容的web应用程序。SPA的工作是当用户从一个页面切换到另一个页面时，巧妙地替换应用程序的用户界面。</p>
<p> </p>
<p>SPA知道如何使用路由器进行页面转换。路由器负责URL地址栏和正在显示的界面之间的同步。在web开发中，有两种向web浏览器呈现内容的基本方法:</p>
<p>客户端</p>
<p>服务器端</p>
<ol>
<li>使用服务器端方法，每当需要新内容时，客户端都会向服务器发出请求。这样做的明显缺点是，在与后端资源的交互中，它可能会重复浪费时间。好的一面是——这对SEO来说很好，因为爬虫机器人提供了索引内容。</li>
<li> </li>
</ol>
<p>使用客户端方法，web应用程序最初将从后端服务器请求一个页面— <code>index.html</code> —然后在第一次请求之后，将动态获取额外的数据(使用一个<code>[XHR](<a href="https://www.w3schools.com/xml/xml_http.asp" rel="nofollow">https://www.w3schools.com/xml/xml_http.asp</a>)</code>对象)。应用程序的进一步路由将由客户端JavaScript处理。</p>
<p> </p>
<p>让我们定义一下我们的讨论主题——路由器:</p>
<p> </p>
<p>路由器是一种将当前显示的视图与地址栏同步的工具。换句话说，它是一个现代web应用程序的组件，当URL地址发生变化时，它触发视图的更新。</p>
<p> </p>
<p>我们将把Vue看作是令人感兴趣的渐进式JavaScript框架。它有一个名为<a href="https://router.vuejs.org/" target="_blank" rel="noopener noreferrer"> Vue Router的官方路由器模块。</a>该路由器一直由维护Vue框架的同一批人维护。</p>
<blockquote class="wp-block-quote">
<p>什么是Vue路由器？</p>
</blockquote>
<p>Vue路由器是<a href="http://vuejs.org/" target="_blank" rel="noopener noreferrer"> Vue </a>的官方路由器。它与Vue core深度融合，让用Vue建造spa变得轻而易举。Vue路由器的一些功能包括:</p>
<p> </p>
<p> </p>
<h2>让我们通过设置和使用Vue路由器来了解它的一些好处。</h2>
<p>使用Vue路由器</p>
<p>虽然有很多方法可以建立一个Vue项目，但是对于本教程来说，我们首选的方法是使用<a href="https://cli.vuejs.org/" target="_blank" rel="noopener noreferrer"> vue-cli。</a>vue-CLI让我们能够快速搭建和服务Vue项目。在撰写本文时，我们将使用该工具的最新版本(版本3)——如果您还没有安装它，您可以在这里安装<a href="https://cli.vuejs.org/" target="_blank" rel="noopener noreferrer">。</a></p>
<p> </p>

<p><strong>创建新项目</strong></p>
<p> </p>
<p>我们可以用这个命令创建一个新的Vue项目:</p>
<h2> </h2>
<p> </p>
<p>系统会提示您选择一个预设，选择默认(babel，eslint)。</p>
<p> </p>
<h3><strong>安装Vue路由器</strong></h3>
<p> </p>
<p>让我们将Vue路由器添加到我们的项目中:</p>
<p>
</p>
<pre>vue create routerapp</pre>
<p>
</p>
<p>注意:如果你使用纱线，这将是<code>yarn add vue-router</code>。如果您喜欢通过脚本标签使用Vue，您可以在这个脚本中包含Vue路由器:<code>&lt;script src="https://unpkg.com/vue-router"&gt;&lt;/script&gt;</code></p>
<p> </p>
<h3><strong>配置</strong> <strong> r </strong> <strong>外</strong></h3>
<p> </p>
<p>我们已经成功安装了Vue路由器，但是Vue无法知道它的存在。我们将在<code>src/main.js</code>文件中明确告诉Vue使用Vue路由器:</p>
<p> </p>
<pre>npm install vue-router</pre>
<p> </p>
<blockquote class="wp-block-quote">
<p>注意:如果您尝试保存，您的IDE可能会显示错误，但这只是因为我们尚未创建— routes —文件夹。我们接下来将创建它，所以现在忽略这个错误。</p>
</blockquote>
<p> </p>
<h3>我们已经包含了对一个尚未创建的文件夹<code>./routes</code>的引用。该文件夹将包含一个文件，我们将在其中定义路线和它们映射到的视图。</h3>
<p> </p>
<p>我们调用了<code>Vue.use()</code>并传入了<code>VueRouter</code>对象，这样我们就可以访问任何组件中的路由器。让我们在<code>src</code>目录下创建<code>routes</code>文件夹。我们还将在<code>src/routes</code>文件夹中创建一个<code>index.js</code>文件，用于保存我们的路线定义。</p>
<p> </p>
<pre>import Vue from 'vue'&#13;
import App from './App.vue'&#13;
import VueRouter from 'vue-router'&#13;
import routes from './routes'&#13;
&#13;
Vue.use(VueRouter)&#13;
const router = new VueRouter({&#13;
  routes&#13;
})&#13;
&#13;
Vue.config.productionTip = false&#13;
&#13;
new Vue({&#13;
  render: h =&gt; h(App),&#13;
  router&#13;
}).$mount('#app')</pre>
<p>打开<code>src/routes/index.js</code>文件并粘贴以下代码片段:</p>
<blockquote class="wp-block-quote">
<p>Note: Your IDE might display an error if you try to save but this is only because we haven’t created the — routes — folder yet. We will create it next, so ignore the error for now.</p>
</blockquote>
<p>注意:和以前一样，我们引用了一些尚未创建的文件。现在忽略任何lint错误。我们将很快创建这些视图文件。</p>
<p>在上面的代码片段中，我们定义了一些路线及其视图。我们导入了两个组件视图(我们将很快创建它们)并将它们作为组件添加到<code>routes</code>数组中。这就是我们使用Vue路由器定义新路由的方式。</p>
<p><strong>构建组件</strong></p>
<p>让我们创建<code>Home</code>和<code>About</code>组件:</p>
<p><code>Home</code>组件是我们希望用户在页面加载时看到的默认组件</p>
<p><code>About</code>组件显示应用程序的一些信息</p>
<pre>import Home from '../components/Home'&#13;
import About from '../components/About'&#13;
&#13;
const routes = [&#13;
    {&#13;
        path: '/',&#13;
        name: 'home',&#13;
        component: Home&#13;
    },&#13;
    {&#13;
        path: '/about',&#13;
        name: 'about',&#13;
        component: About&#13;
    }&#13;
]&#13;
export default routes</pre>
<p>在<code>components</code>目录中创建一个<code>home.vue</code>文件，并粘贴到以下代码片段中:</p>
<blockquote class="wp-block-quote">
<p>很好，我们刚刚定义了主页的标记，现在让我们在<code>components</code>目录下创建一个— <code>about.vue</code> —文件，并粘贴以下内容:</p>
</blockquote>
<p>我们已经构建了这两个组件，但是为了让我们看到Vue路由器的平滑过渡，我们必须使用<code>&lt;router-view/&gt;</code>标签。当这个标签被定义时，它根据URL地址栏自动控制显示哪个视图。我们把这个标签放在哪里？</p>
<h3>让我们打开父组件— <code>src/App.vue</code> —并对其进行编辑，使其具有两个组件的两个链接，并使用<code>&lt;router-view/&gt;.</code>打开文件并粘贴到以下代码片段中来显示正确的视图:</h3>
<p>现在让我们测试应用程序。使用终端导航到<code>src</code>目录，并为应用程序提供服务:</p>
<ol>
<li>最后一个命令将启动开发服务器，并在本地地址上呈现应用程序—<a href="http://localhost:8080/" rel="nofollow">http://localhost:8080/</a>—让我们在浏览器上访问它:</li>
<li>在上面的屏幕记录中，我们可以看到应用程序如何在主页和关于页面之间切换，而不会导致浏览器窗口的重新加载。这就是现代网络框架中路由器的力量。再来看看Vue路由器的其他一些功能和特点。</li>
</ol>
<p><strong>切换到</strong> <strong>历史模式</strong></p>
<pre>&lt;template&gt;&#13;
 &lt;div class="home"&gt;&#13;
   &lt;h2&gt;THIS IS THE HOME VIEW&lt;/h2&gt;&#13;
 &lt;/div&gt;&#13;
&lt;/template&gt;&#13;
&lt;script&gt;&#13;
&#13;
export default {&#13;
 name: "home"&#13;
};&#13;
&#13;
&lt;/script&gt;&#13;
&lt;style scoped&gt;&#13;
.home {&#13;
 width: 100%;&#13;
 height: 50vh;&#13;
 background: rgb(25, 169, 241);&#13;
}&#13;
h2 {&#13;
 padding: 15px 0px 0px 0px;&#13;
 margin: 0px;&#13;
 text-align: center;&#13;
 font-size: 24px;&#13;
}&#13;
&lt;/style&gt;&#13;
</pre>
<p>您会注意到在应用程序的URL地址栏中有一个“#”。这是因为，默认情况下，Vue Router使用URL哈希来模拟完整的URL，这样当URL更改时，页面不会重新加载。我们可以切换模式，将其更改为历史模式，利用<code>history.pushState</code> API来实现URL导航，而无需重新加载页面。</p>
<pre>&lt;template&gt;&#13;
  &lt;div class="about"&gt;&#13;
    &lt;h2&gt;THIS IS THE ABOUT VIEW&lt;/h2&gt;&#13;
  &lt;/div&gt;&#13;
&lt;/template&gt;&#13;
&lt;script&gt;&#13;
&#13;
export default {&#13;
  name: "about"&#13;
};&#13;
&#13;
&lt;/script&gt;&#13;
&lt;style scoped&gt;&#13;
.about {&#13;
  width: 100%;&#13;
  height: 50vh;&#13;
  background: rgb(243, 245, 145);&#13;
}&#13;
h2 {&#13;
  padding: 15px 0px 0px 0px;&#13;
  margin: 0px;&#13;
  text-align: center;&#13;
  font-size: 24px;&#13;
}&#13;
&lt;/style&gt;</pre>
<p>让我们通过更新<code>src/main.js</code>文件中的代码切换到历史模式:</p>
<p>很好，现在让我们转到网络浏览器，我们可以看到“#”消失了，历史模式被激活:</p>
<pre>&lt;template&gt;&#13;
  &lt;div id="app"&gt;&#13;
    &lt;nav&gt;&#13;
      &lt;router-link to="/"&gt;Home&lt;/router-link&gt;&#13;
      &lt;router-link to="/about"&gt;About&lt;/router-link&gt;&#13;
    &lt;/nav&gt;&#13;
    &lt;router-view/&gt;&#13;
  &lt;/div&gt;&#13;
&lt;/template&gt;&#13;
&lt;script&gt;&#13;
&#13;
export default {&#13;
  name: "app"&#13;
};&#13;
&#13;
&lt;/script&gt;&#13;
&lt;style&gt;&#13;
&#13;
#app {&#13;
  max-width: 896px;&#13;
  margin: 0 auto;&#13;
}&#13;
&#13;
nav {&#13;
  padding: 10px;&#13;
  border: 1px solid grey;&#13;
}&#13;
&#13;
nav a {&#13;
  color: white;&#13;
  padding: 5px;&#13;
  background: grey;&#13;
  border-radius: 3.5px;&#13;
  text-decoration: none;&#13;
}&#13;
&#13;
a:first-child {&#13;
  margin-right: 15px;&#13;
}&#13;
&#13;
&lt;/style&gt;</pre>
<p>我们几乎没有探索Vue路由器的功能和特性，但这里有一些其他的特性供好奇者参考:</p>
<pre>$ cd src&#13;
$ vue serve</pre>
<p><a href="https://router.vuejs.org/guide/essentials/dynamic-matching.html" target="_blank" rel="noopener noreferrer">动态</a> <a href="https://router.vuejs.org/guide/essentials/dynamic-matching.html"> r </a> <a href="https://router.vuejs.org/guide/essentials/dynamic-matching.html" target="_blank" rel="noopener noreferrer">郊游</a></p>
<figure class="wp-block-image"><img data-attachment-id="3469" data-permalink="https://blog.logrocket.com/router-options-compared/image_preview-5/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2019/06/image_preview-5.gif" data-orig-size="730,356" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="image_preview (5)" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2019/06/image_preview-5-300x146.gif" data-large-file="https://blog.logrocket.com/wp-content/uploads/2019/06/image_preview-5.gif" decoding="async" class="alignnone wp-image-3469 size-full jetpack-lazy-image" src="../Images/baba2229c44ef276488b56798c4e9e1e.png" alt="" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2019/06/image_preview-5.gif?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/06/image_preview-5.gif"/><noscript><img data-lazy-fallback="1" data-attachment-id="3469" data-permalink="https://blog.logrocket.com/router-options-compared/image_preview-5/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2019/06/image_preview-5.gif" data-orig-size="730,356" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="image_preview (5)" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2019/06/image_preview-5-300x146.gif" data-large-file="https://blog.logrocket.com/wp-content/uploads/2019/06/image_preview-5.gif" decoding="async" loading="lazy" class="alignnone wp-image-3469 size-full" src="../Images/baba2229c44ef276488b56798c4e9e1e.png" alt="" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/06/image_preview-5.gif"/></noscript></figure>
<p><a href="https://router.vuejs.org/guide/essentials/nested-routes.html" target="_blank" rel="noopener noreferrer">嵌套</a> <a href="https://router.vuejs.org/guide/essentials/nested-routes.html"> r </a> <a href="https://router.vuejs.org/guide/essentials/nested-routes.html" target="_blank" rel="noopener noreferrer"> outes </a></p>
<h3><a href="https://router.vuejs.org/api/#router-view-props" target="_blank" rel="noopener noreferrer">道具</a></h3>
<p><a href="https://router.vuejs.org/guide/advanced/navigation-guards.html#global-before-guards" target="_blank" rel="noopener noreferrer">路线守卫</a></p>
<p><a href="https://router.vuejs.org/api/#exact-active-class" target="_blank" rel="noopener noreferrer">保持组件存活</a>等</p>
<pre>import Vue from 'vue'&#13;
import App from './App.vue'&#13;
import VueRouter from 'vue-router'&#13;
import routes from './routes'&#13;
&#13;
Vue.use(VueRouter)&#13;
const router = new VueRouter({&#13;
  mode: 'history', // add this&#13;
  routes&#13;
})&#13;
&#13;
Vue.config.productionTip = false&#13;
new Vue({&#13;
  render: h =&gt; h(App),&#13;
  router&#13;
}).$mount('#app')</pre>
<p>在下一节中，我们来看看Vue路由器的一些替代方案。</p>
<figure class="wp-block-image"><img data-attachment-id="3467" data-permalink="https://blog.logrocket.com/router-options-compared/image_preview-4-2/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2019/06/image_preview-4-1.gif" data-orig-size="730,356" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="image_preview (4)" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2019/06/image_preview-4-1-300x146.gif" data-large-file="https://blog.logrocket.com/wp-content/uploads/2019/06/image_preview-4-1.gif" decoding="async" class="aligncenter wp-image-3467 size-full jetpack-lazy-image" src="../Images/69151e4ca19e9bc47978f7b2ae0d1841.png" alt="" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2019/06/image_preview-4-1.gif?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/06/image_preview-4-1.gif"/><noscript><img data-lazy-fallback="1" data-attachment-id="3467" data-permalink="https://blog.logrocket.com/router-options-compared/image_preview-4-2/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2019/06/image_preview-4-1.gif" data-orig-size="730,356" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="image_preview (4)" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2019/06/image_preview-4-1-300x146.gif" data-large-file="https://blog.logrocket.com/wp-content/uploads/2019/06/image_preview-4-1.gif" decoding="async" loading="lazy" class="aligncenter wp-image-3467 size-full" src="../Images/69151e4ca19e9bc47978f7b2ae0d1841.png" alt="" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/06/image_preview-4-1.gif"/></noscript></figure>
<p>Vue的替代路由器选项</p>
<ol>
<li>有时，您可能想为您的Vue应用程序使用不同的路由器。在这种情况下，以下是一些值得考虑的替代方案:</li>
<li>瞧</li>
<li>根据官方npm <a href="https://www.npmjs.com/package/voie" target="_blank" rel="noopener noreferrer">页面</a>的定义，Voie是一个简单的路由器，用于在<a href="http://vuejs.org/" target="_blank" rel="noopener noreferrer"> Vue </a>建立强大的水疗中心。与围绕URL组织的Vue路由器不同，Voie是围绕<em>州</em>组织的。基于Voie的应用程序基本上是<a href="https://en.wikipedia.org/wiki/Finite-state_machine" target="_blank" rel="noopener noreferrer">有限状态机</a>——状态只是应用程序中一个名为的逻辑“位置”的<em>。</em></li>
<li>每个状态可以<em>可选地</em>有一个:</li>
<li>URL模式</li>
</ol>
<p>Vue组件</p>
<h2>输入钩子以用数据填充状态</h2>
<p>让胡克去收拾东西</p>
<h2>状态被组织成层次结构:子状态将从父状态继承参数和数据。如果子状态有一个组件，它将被呈现在由<code>&lt;v-view&gt;</code>指令指示的父(或最近的祖先)状态指定的位置。</h2>
<p>让我们来看看这个例子:</p>
<p>注意:Voie仍在积极开发中，因此报告的问题将随着开发的进展而得到解决。</p>
<ul>
<li><strong>安装</strong></li>
<li>Voie可以使用以下命令与npm一起安装:</li>
<li><strong>用法和语法</strong></li>
<li>让我们来看看这个例子:</li>
</ul>
<p>在上面的代码片段中，访问<code>/user/123</code>将从服务器获取id为<code>123</code>的用户，然后呈现以下标记(假设用户的名字是“Alice”):</p>
<p><strong>注意:</strong> <a href="http://vuejs.org/guide/components.html#Fragment_Instance" target="_blank" rel="noopener noreferrer">片段实例</a>不支持作为组件。换句话说，确保所有组件都包含一个没有流控制指令(<code>v-if</code>、<code>v-for</code>等)的顶级元素。)</p>
<blockquote class="wp-block-quote">
<p><strong>进一步学习</strong></p>
</blockquote>
<h3>访问官方npm <a href="https://www.npmjs.com/package/voie" target="_blank" rel="noopener noreferrer">页面</a>了解更多关于其他Voie的概念，包括:</h3>
<p>州经理</p>
<pre class="wp-block-code"><code> npm i --save voie</code></pre>
<h3>状态定义</h3>
<p>运行状态管理器</p>
<pre>app.add('user', {&#13;
 path: '/user/:userId',&#13;
 redirect: 'user.dashboard',   // specify "default" sub-state&#13;
 enter: (ctx) =&gt; {             // can return a Promise&#13;
   return fetch('/user/' + ctx.params.userId)&#13;
     .then(res =&gt; res.json())&#13;
     .then(data = ctx.data.user = data);&#13;
 },&#13;
 component: {&#13;
   template: '&lt;div class="user-layout"&gt;&lt;v-view&gt;&lt;/v-view&gt;&lt;/div&gt;'&#13;
 }&#13;
});&#13;
&#13;
app.add('user.dashboard', {&#13;
 component: {&#13;
   template: '&lt;h1&gt;Hello, {{ user.name }}!&lt;/h1&gt;'&#13;
 }&#13;
});</pre>
<p>状态层级</p>
<pre>&lt;div class="user-layout"&gt;&#13;
  &lt;h1&gt;Hello, Alice!&lt;/h1&gt;&#13;
&lt;/div&gt;</pre>
<blockquote class="wp-block-quote">
<p>导航状态</p>
</blockquote>
<h3>进入/离开</h3>
<p>每次之前/之后</p>
<ul>
<li>改变方向</li>
<li>状态转换</li>
<li>因素</li>
<li>历史设置</li>
<li>视图-鲁西坦</li>
<li>Vue作为一个web框架的发展曲线中的一个重要时期是当Laravel开始提供包含<a href="https://getbootstrap.com/" target="_blank" rel="noopener noreferrer"> Bootstrap </a>和<a href="https://vuejs.org/" target="_blank" rel="noopener noreferrer"> Vue的前端样板文件时。</a>这导致Vue成为许多Laravel开发人员首选的前端框架。也就是说，Vue-routisan是一个基于Laravel路由系统的Vue路由系统。</li>
<li><strong>安装</strong></li>
<li>我们可以使用以下命令将Vue-routisan与npm一起安装:</li>
<li><strong>用法与</strong> <strong>用法</strong> <strong>用法</strong></li>
<li><code>view()</code>方法分别接收<code>path</code>和<code>component</code>路径选项。如果定义了视图解析器，可以直接指定组件的名称:</li>
<li>如果没有视图解析器，它将是:</li>
</ul>
<h2><strong>什么是</strong> <strong>视图解析器？</strong></h2>
<p>视图解析器允许<code>view()</code>方法为您的路线自动要求组件。这可以让你在定义路线时避免重复的<code>import</code>和<code>require</code>。视图解析器是可选的。如果您选择不配置它，您可以<code>import</code>一个组件，并将其作为<code>view()</code>方法的第二个参数直接传递:</p>
<h3><strong>取名</strong> <strong> r </strong> <strong> outes </strong></h3>
<p><code>name()</code>方法在<em>路由实例上设置<code>name</code>选项:</em></p>
<pre class="wp-block-code"><code>npm install vue-routisan</code></pre>
<h3><strong>嵌套</strong> <strong> r </strong> <strong> outes </strong></h3>
<p><code>children()</code>方法在<em>路由实例上设置<code>children</code>选项:</em></p>
<pre>Route.view('/', 'Home');</pre>
<p><strong>更进一步</strong> <strong> l </strong> <strong>赚</strong></p>
<pre>import Home from './views/Home';&#13;
 &#13;
Route.view('/', Home);</pre>
<h3>访问官方npm <a href="https://www.npmjs.com/package/vue-routisan" target="_blank" rel="noopener noreferrer">页面</a>了解其他Vue-routisan概念，包括:</h3>
<p>路由组</p>
<pre>import Route from 'vue-routisan';&#13;
 &#13;
Route.setViewResolver((component) =&gt; {&#13;
    return require('./views/' + component).default;&#13;
});</pre>
<h3>路线前缀</h3>
<p>自动格式化的路径</p>
<pre>Route.view('/user/profile', 'Profile').name('profile');</pre>
<h3>检索所有路线</h3>
<p>导航防护装置</p>
<pre>Route.view('/user', 'User').children(() =&gt; {&#13;
    Route.view('', 'UserList');&#13;
    Route.view(':id', 'UserDetails');&#13;
    Route.view(':id/edit', 'UserEdit');&#13;
});</pre>
<h3>重定向路由</h3>
<p>Vue路线</p>
<ul>
<li>Vue-route是Vue.js的路由指令，灵感来自于<code>ng-view.</code>，它允许你在<code>$root</code> Vue对象上声明你的路由:</li>
<li>然后，您可以用最少的标记来引用它:</li>
<li><strong>安装和配置</strong></li>
<li>我们可以使用以下命令通过npm安装Vue-route:</li>
<li>要求并安装插件:</li>
<li>把<code>&lt;div v-route&gt;&lt;/div&gt;</code>放到你的主模板中。</li>
</ul>
<h2>将您的路线传送到应用程序的<code>$root</code>虚拟机。</h2>
<p>转换、保持活动和其他指令</p>
<pre>var root = new Vue({&#13;
    el: 'body',&#13;
 &#13;
    routes: {&#13;
        '/home': {&#13;
            componentId: 'fg-home',&#13;
            isDefault: true&#13;
        },&#13;
        '/items/:item': {&#13;
            componentId: 'fg-item',&#13;
            afterUpdate: 'updateHeader',&#13;
            data: {&#13;
                defaultColor: '#3453DD'&#13;
            }&#13;
        },&#13;
        options: {&#13;
            hashbang: true&#13;
        }&#13;
    }&#13;
});</pre>
<p>如果您想在页面之间添加自定义过渡，建议将它们放在每个页面的组件模板上。在<code>v-route</code>元素上放置任何东西只有在你改变这个元素时才会被激活(例如用一个<code>v-if</code>指令)。根据示例，这将是:</p>
<pre>&lt;body&gt;&#13;
    &lt;div v-route&gt;&lt;/div&gt;&#13;
&lt;/body&gt;</pre>
<h3><strong>更进一步</strong> <strong> l </strong> <strong>赚</strong></h3>
<ul>
<li>访问官方npm <a href="https://www.npmjs.com/package/vue-route" target="_blank" rel="noopener noreferrer">页面</a>了解其他Vue路线概念，包括:</li>
</ul>
<pre>npm i vue-route --save</pre>
<ul>
<li>位置概念</li>
</ul>
<pre>var Vue = require('vue'),&#13;
    route = require('vue-route');&#13;
 &#13;
Vue.use(route);</pre>
<ul>
<li>路线参数</li>
<li>子路由</li>
</ul>
<h2>结论</h2>
<p>在本文中，我们了解了客户端和服务器端呈现的应用程序之间的一些差异。我们还看到了客户端路由的一些优势，以及它如何增强我们的web应用程序的性能。</p>
<pre>&lt;div class="Home" v-transition="homeTransition"&gt;...&lt;/div&gt;</pre>
<h3>除了Vue路由器的替代品之外，我们还进一步了解了Vue和Vue路由器(Vue的官方路由器)。如果您一直在寻找Vue路由器的替代方案，您应该尝试熟悉上面列出的选项之一。</h3>
<p>像用户一样体验您的Vue应用</p>
<ul>
<li>调试Vue.js应用程序可能会很困难，尤其是当用户会话期间有几十个(如果不是几百个)突变时。如果您对监视和跟踪生产中所有用户的Vue突变感兴趣，</li>
<li>. </li>
<li>LogRocket 就像是网络和移动应用程序的DVR，记录你的Vue应用程序中发生的一切，包括网络请求、JavaScript错误、性能问题等等。您可以汇总并报告问题发生时应用程序的状态，而不是猜测问题发生的原因。</li>
</ul>
<h2>LogRocket Vuex插件将Vuex突变记录到LogRocket控制台，为您提供导致错误的环境，以及出现问题时应用程序的状态。</h2>
<p>现代化您调试Vue应用的方式- <a class="signup" href="https://lp.logrocket.com/blg/vue-signup" target="_blank" rel="noopener noreferrer">开始免费监控</a>。</p>
<p>We further went on to learn about Vue and Vue Router (the official router for Vue) in addition to alternatives to Vue Router. If you’ve been looking to explore an alternative to Vue Router, you should try getting acquainted with one of the options listed above.</p><div class="code-block code-block-20">
<div class="blog-plug inline-plug vue-inline"><h2>Experience your Vue apps exactly how a user does</h2><p> Debugging Vue.js applications can be difficult, especially when there are dozens, if not hundreds of mutations during a user session. If you’re interested in monitoring and tracking Vue mutations for all of your users in production, </p><a href="https://lp.logrocket.com/blg/vue-signup" target="_blank">try LogRocket</a><p>. </p><a class="signup" href="https://lp.logrocket.com/blg/vue-signup" target="_blank" rel="noopener noreferrer"><img class="alignnone size-full wp-image-46 jetpack-lazy-image" src="../Images/0d269845910c723dd7df26adab9289cb.png" alt="LogRocket Dashboard Free Trial Banner" data-lazy-src="https://files.readme.io/00591d0-687474703a2f2f692e696d6775722e636f6d2f6a3049327856572e706e67.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://files.readme.io/00591d0-687474703a2f2f692e696d6775722e636f6d2f6a3049327856572e706e67.png"/><noscript><img data-lazy-fallback="1" class="alignnone size-full wp-image-46" src="../Images/0d269845910c723dd7df26adab9289cb.png" alt="LogRocket Dashboard Free Trial Banner" data-original-src="https://files.readme.io/00591d0-687474703a2f2f692e696d6775722e636f6d2f6a3049327856572e706e67.png"/></noscript></a><a href="https://lp.logrocket.com/blg/vue-signup" target="_blank" rel="noopener noreferrer">https://logrocket.com/signup/</a><p><a href="https://lp.logrocket.com/blg/vue-signup" target="_blank" rel="noopener noreferrer">LogRocket</a> is like a DVR for web and mobile apps, recording literally everything that happens in your Vue apps including network requests, JavaScript errors, performance problems, and much more. Instead of guessing why problems happen, you can aggregate and report on what state your application was in when an issue occurred. </p><p>The LogRocket Vuex plugin logs Vuex mutations to the LogRocket console, giving you context around what led to an error, and what state the application was in when an issue occurred.</p><p>Modernize how you debug your Vue apps - <a class="signup" href="https://lp.logrocket.com/blg/vue-signup" target="_blank" rel="noopener noreferrer">Start monitoring for free</a>.</p></div>


</div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
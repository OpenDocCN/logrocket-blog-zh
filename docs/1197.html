<html>
<head>
<title>Working with context, helpers, and advanced properties in Nuxt.js - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>在Nuxt.js - LogRocket博客中使用上下文、助手和高级属性</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/working-with-context-helpers-and-advanced-properties-in-nuxt-js/#0001-01-01">https://blog.logrocket.com/working-with-context-helpers-and-advanced-properties-in-nuxt-js/#0001-01-01</a></blockquote><div><article class="article-post">
<h3>快速小结</h3>
<p>Nuxt有很多有用的特性和概念，使得应用程序的开发变得简单和无缝。在本教程中，我们将看看这些概念(例如，上下文)以及它们如何在开发中有所帮助。</p>
<p>我们还将关注像<code>router</code>属性这样的特性，如何配置它来做更多默认的事情，以及它在哪里有用。</p>
<h2>介绍</h2>
<p>Nuxt是一个框架，旨在给你一个遵循Vue官方指导方针的强大架构。</p>
<p>它可增量采用，可用于创建从静态登录页面到复杂的企业级web应用程序的所有内容。我们将看看Nuxt中一些非常有用的特性。</p>
<p>它们包括:</p>
<ul>
<li>语境</li>
<li>助手</li>
<li>加载属性</li>
</ul>
<p>一些特性可以根据个人喜好进行配置，而其他特性可以提供一种更简单的方式来执行应用程序中的困难/复杂功能(例如，Nuxt助手)。</p>
<p>在本教程结束时，读者应该:</p>
<ul>
<li>很好地理解上下文对象，如何使用它的属性，以及在哪里可以使用它</li>
<li>了解Nuxt助手以及如何使用它们</li>
<li>能够配置Nuxt加载组件并创建自定义加载组件</li>
</ul>
<h2>语境</h2>
<p><img data-attachment-id="26346" data-permalink="https://blog.logrocket.com/working-with-context-helpers-and-advanced-properties-in-nuxt-js/nuxt-context/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/10/Nuxt-context.png" data-orig-size="730,516" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Nuxt-context" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/10/Nuxt-context-300x212.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/10/Nuxt-context.png" decoding="async" class="aligncenter size-full wp-image-26346 jetpack-lazy-image" src="../Images/1254ce50d2a1c7213d33d1b6231e7c04.png" alt="A chart displaying the workings of Nuxt context." data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2020/10/Nuxt-context.png 730w, https://blog.logrocket.com/wp-content/uploads/2020/10/Nuxt-context-300x212.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2020/10/Nuxt-context.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/10/Nuxt-context.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="26346" data-permalink="https://blog.logrocket.com/working-with-context-helpers-and-advanced-properties-in-nuxt-js/nuxt-context/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/10/Nuxt-context.png" data-orig-size="730,516" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Nuxt-context" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/10/Nuxt-context-300x212.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/10/Nuxt-context.png" decoding="async" loading="lazy" class="aligncenter size-full wp-image-26346" src="../Images/1254ce50d2a1c7213d33d1b6231e7c04.png" alt="A chart displaying the workings of Nuxt context." srcset="https://blog.logrocket.com/wp-content/uploads/2020/10/Nuxt-context.png 730w, https://blog.logrocket.com/wp-content/uploads/2020/10/Nuxt-context-300x212.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/10/Nuxt-context.png"/></noscript>
<p>Nuxt <code>context</code>是Nuxt生命周期钩子中提供的关于应用程序当前请求的额外数据集合。这个对象可用于一些Nuxt函数，如<code>asyncData</code>和<code>nuxtServerInit</code>。</p>
<p>虽然我们在Vuex商店中也有一个<code>context</code>，它与这个不同，因为Vuex商店<code>context</code>提供了关于你的商店的附加信息(像<code>commit</code>和<code>state</code>)，但是Nuxt <code>context</code>提供了关于整个应用程序的额外数据(像<code>query</code>、<code>params</code>和<code>store</code>)。</p>
<p><code>context</code>对象可以分为三部分。</p>
<p>即:</p>
<ul>
<li>随时可用</li>
<li>可用的服务器端</li>
<li>可用客户端</li>
</ul>
<h3>随时可用</h3>
<p>这包括在<code>context</code>对象中始终可用的属性，而不管应用程序的状态如何——即客户端和服务器端。</p>
<p>这意味着这些属性可以在应用程序的整个状态中随时使用。</p>
<p>始终可用的属性示例包括:</p>
<ul>
<li><code>app</code>:这是你所有插件<code>$axios</code>、<code>store</code>、<code>router</code>所在的属性。在<code>app</code>属性下可用的一些属性也可以直接在<code>context</code>对象下找到，例如<code>store</code>和<code>$axios</code>(如果安装了nuxt Axios模块)。</li>
<li><code>store</code>:此属性包含关于您的商店的所有信息(getters、state、mutation和actions ),只有在您的应用程序中启用了Vuex商店时才可用。有了这个属性，您可以在像中间件和插件文件夹这样的地方访问您的存储。</li>
<li><code>route</code>:这个属性包含了你的路线信息——比如<code>fullPath</code>、<code>params</code>和<code>query</code>都可以在这里找到。在为应用程序创建特定路线和路线属性的中间件时，这很方便。</li>
<li><code>params</code>:该属性可用于访问某些页面的路由参数。这在创建依赖于路由参数值进行操作的中间件时，或者在利用<code>asyncData</code>、<code>fetch</code>或插件时非常有用。如上所述，这也可以通过访问<code>route</code>属性下的参数来实现。</li>
<li><code>query</code>:该属性与<code>route</code>属性下的属性相同。它包含当前路线的查询值，在<code>asyncData</code>、<code>fetch</code>中创建中间件和插件时会很有用。</li>
<li><code>env</code>:访问环境变量的一种方法是调用<code>process.env.VARIABLE_NAME</code>。在Nuxt中，使用上下文对象中的<code>env</code>属性可以找到我们所有的环境变量。我相信这是一个更短更干净的方法来访问你的env变量。</li>
<li><code>isDev</code>:这个属性和Vue apps中的<code>process.env.NODE_ENV</code>的作用是一样的，它帮助你决定你的应用是开发还是生产模式。但是在这种情况下，它返回一个布尔值，这意味着它在开发阶段是<code>true</code>，在生产阶段是<code>false</code>。</li>
<li><code>isHMR</code>:布尔值，让您知道方法/中间件是否是从webpack热模块替换中调用的(仅在开发模式下的客户端为真)。</li>
<li><code>redirect</code>:这种方法的工作方式与<a href="https://www.smashingmagazine.com/2020/08/vue-router-features/" target="_blank" rel="noopener noreferrer"> Vue导航卫士</a>中的<code>next()</code>类似，都是用来重定向到不同的路线。在为您的应用程序编写身份验证中间件时，如果您试图在未授权用户不满足访问特定路由的要求时将他们重定向到不同的路由，该属性会很方便。</li>
<li><code>error</code>:该方法用于将错误状态和消息传递给错误页面。它通常接受一个对象<code>statusCode</code>和<code>message</code>，这个对象总是呈现在你的应用程序的错误页面上。</li>
</ul>
<h3>可用的服务器端</h3>
<p>这些属性只有在服务器端(<code>asyncData</code> &amp; <code>nuxtServerInit</code>)访问<code>context</code>对象时才可用，在客户端工作时不能使用/访问。</p>
<p>这些属性包括:</p>
<ul>
<li><code>req&lt;/code</code></li>
<li><code>res</code></li>
<li><code>beforeNuxtRender</code></li>
</ul>
<h3>可用客户端</h3>
<p>这些是<code>context</code>对象中的属性，它们只在客户端可用并且总是可用，不能在服务器端访问。</p>
<p>这些属性包括:</p>

<h2>助手</h2>
<p>Nuxt有一个专门的助手，旨在改善用户体验，并在某些情况下作为逃生出口。它可以通过Vue组件中的<code>this.$nuxt</code>访问，也可以通过客户端的<code>window.$nuxt</code>访问。</p>
<p>该助手下可用的属性和方法包括:</p>
<ul>
<li>使用<code>isOffline</code> / <code>isOnline</code>检查用户的网络连接状态</li>
<li>使用<code>refresh()</code>更新应用程序的状态</li>
<li>使用<code>$loading</code>控制Nuxt加载器</li>
</ul>
<h3><code>isOffline</code>和<code>isOnline</code></h3>
<p>这两个属性提供了一种检查用户internet连接的方法。这意味着您不需要担心编写自己的自定义函数来帮助在您的Nuxt应用程序中确定这一点。这些属性在每次使用时都返回<code>Boolean</code>值。</p>
<p>也就是说，对于离线用户，<code>this.$nuxt.isOffline</code>将返回<code>true</code>，而<code>this.$nuxt.isOnline</code>将返回<code>false</code>，反之亦然，如果用户有网络连接的话。</p>
<h3><code>refresh()</code></h3>
<p>在开发过程中，有些情况下，用户与应用程序的交互可能需要您更新显示给用户的数据。</p>
<p>如果您使用应用程序的<code>methods</code>中的<code>normal functions</code>获取数据，这可能不是问题，但是当使用<code>asyncData</code>或<code>fetch</code>在服务器端获取数据时，更新这些数据的唯一干净的方法是刷新页面，最终刷新整个应用程序。</p><div class="code-block code-block-54">
<hr/>
<h3>更多来自LogRocket的精彩文章:</h3>

<hr/></div>
<p>使用<code>refresh()</code>方法，您可以通过在方法或内联(直接连接到事件监听器)中调用<code>this.$nuxt.refresh()</code>来更新数据，而无需刷新应用程序。</p>
<h3><code>$loading</code></h3>
<p>在开发过程中，当用户在应用程序上执行某些操作时，您可能希望Nuxt中的加载指示器出现。</p>
<p>使用<code>$loading</code>属性，这可以通过调用<code>this.$nuxt.$loading.start()</code>来启动加载动画或者调用<code>this.$nuxt.$loading.finish()</code>来停止动画来实现。</p>
<h2>负载特性</h2>
<p>默认情况下，Nuxt附带了一个默认的加载器组件，在路由之间切换时会被激活。默认情况下，加载组件的<code>color</code>为黑色，当出现错误时，它会变为红色。</p>
<p>使用loading属性可以在Nuxt中修改这个加载组件的更多属性。同时，该组件可以被禁用，也可以完全替换为另一个组件。</p>
<p>要修改这些属性，您只需在配置文件(<code>nuxt.config.js</code>)中添加一个<code>loading</code>属性。让我们看看这个属性下的一些可用属性，以及如何修改它们。</p>
<p><strong> nuxt.config.js </strong></p>
<pre>export default {
  loading: {
    color: '#eee', // color of the loading component
    height: '5px', // height of the loading component
    throttle: 500, // set a delay in ms before loading starts
    duration: 3000 // how long it would take for the loader to go from start to finish
  }
}</pre>
<p>这里，我们更改了加载组件的<code>color</code>、<code>height</code>、<code>throttle</code>和<code>duration</code>，如果您现在尝试在路由之间切换，您应该会看到应用程序中反映了这一更改。</p>
<p>“加载”属性下的其他可用属性包括:</p>
<ul>
<li><code>failedColor</code>:用于设置失败导航/请求的颜色(默认为红色)，接受字符串</li>
<li><code>continuous</code>:用于控制当请求/导航过程花费的时间超过<code>duration</code>时，加载组件是否应该重新启动。它接受布尔值，其默认值为false</li>
<li><code>css</code>:该选项用于决定组件是否使用默认的CSS样式。它接受一个布尔值，默认情况下，它被设置为true</li>
<li><code>rtl</code>:控制加载组件的方向(<code>rtl</code>是从右到左的简称)。默认情况下，它被设置为<code>false</code>,因此，加载组件从左侧开始，并移动到右侧</li>
</ul>
<p>Nuxt还允许您通过调用<code>this.$nuxt.$loading.start()</code>来启动加载组件，并通过调用<code>this.$nuxt.$loading.finish()</code>来停止加载组件。</p>
<p>当您想要在同一页面上使用加载动画时，例如对服务器的API请求，以及常规导航用例之外的事情，这就很方便了。</p>
<p>如果您不想要默认的加载器，您可以禁用它或者创建您自己的定制组件并将其传递给<code>loading</code>属性，这样Nuxt将自动调用它。</p>
<p>要禁用加载组件，请将<code>false</code>传递给配置文件或特定页面中的<code>loading</code>属性:</p>
<p><strong> nuxt.config.js </strong></p>
<pre>loading: false</pre>
<p>或者，如果希望更好地控制加载组件的工作方式，可以创建自定义加载组件。</p>
<p>您的自定义组件必须具有以下属性，因为这些属性对于您的组件准确工作是必不可少的。</p>
<ul>
<li>组件的<code>data()</code>中的一个布尔值，用于控制加载器组件的活动状态，默认情况下设置为false</li>
<li><code>start</code>–该方法通过将布尔值从1设置为真来启动加载动画</li>
<li><code>finish</code>–该方法通过将布尔值从1设置为假来停止加载动画</li>
</ul>
<h2>结论</h2>
<p>我们已经查看了Nuxt上下文对象、所有属性，以及如何在我们的应用程序中使用它们。我们还研究了Nuxt中的一些助手，它们是什么，我们如何使用它们来简化开发，以及它们给了我们多大的灵活性。</p>
<p>最后，我们查看了加载属性，如何配置默认的加载组件，以及如何在我们的应用程序中创建定制的加载组件。</p>
<h3>进一步阅读</h3>

<p>使用<a class="signup" href="https://lp.logrocket.com/blg/signup" target="_blank" rel="noopener noreferrer"> LogRocket </a>消除传统错误报告的干扰</p><div class="code-block code-block-2">
<div class="blog-plug base-cta"><h2><a href="https://lp.logrocket.com/blg/signup" target="_blank" rel="noopener noreferrer"> LogRocket </a>是一个数字体验分析解决方案，它可以保护您免受数百个假阳性错误警报的影响，只针对几个真正重要的项目。LogRocket会告诉您应用程序中实际影响用户的最具影响力的bug和UX问题。</h2>
<a href="https://lp.logrocket.com/blg/signup" class="signup" target="_blank" rel="noopener noreferrer"><img class="alignnone size-full wp-image-46 jetpack-lazy-image" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/><noscript><img data-lazy-fallback="1" class="alignnone size-full wp-image-46" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/></noscript></a>
<p>然后，使用具有深层技术遥测的会话重放来确切地查看用户看到了什么以及是什么导致了问题，就像你在他们身后看一样。</p>
<p>LogRocket自动聚合客户端错误、JS异常、前端性能指标和用户交互。然后LogRocket使用机器学习来告诉你哪些问题正在影响大多数用户，并提供你需要修复它的上下文。</p>
<p>关注重要的bug—<a class="signup" href="https://lp.logrocket.com/blg/signup-issue-free" target="_blank" rel="noopener noreferrer">今天就试试LogRocket】。</a></p>
<p>Focus on the bugs that matter — <a class="signup" href="https://lp.logrocket.com/blg/signup-issue-free" target="_blank" rel="noopener noreferrer">try LogRocket today</a>.</p></div></div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
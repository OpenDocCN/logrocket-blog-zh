<html>
<head>
<title>Creating offline web apps with AWS Amplify DataStore - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>用AWS Amplify DataStore创建离线web应用程序</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/creating-offline-web-apps-with-aws-amplify-datastore/#0001-01-01">https://blog.logrocket.com/creating-offline-web-apps-with-aws-amplify-datastore/#0001-01-01</a></blockquote><div><article class="article-post">
<p>在当今世界，似乎每个人都是联系在一起的。你在家、在工作、在火车上都随身带着智能手机，一切都很好。</p>
<p>好吧，至少直到他们不是。</p>
<p>甚至在我居住的地方(德国斯图加特——一个60万人口的城市)，也有我没有任何移动互联网连接的地方。</p>
<p>在市中心的一个地铁站，我的连接总是掉线。如果我不得不等待下一趟火车，我就只能用智能手机上的东西了，其他什么也做不了。</p>
<p>不一定非要这样。</p>
<p>借助DataStore library——面向前端开发人员的Amplify无服务器框架的最新成员——您现在可以通过几行代码为您的移动应用添加离线功能。</p>
<p>在本文中，我将向您展示如何将AWS Amplify添加到React项目中，并在AWS上启用离线功能以及与云后端的同步。</p>
<p>这些要点将用一个简单的杂货清单应用程序来说明。</p>
<h2>先决条件</h2>
<p>Amplify CLI在后台使用<a href="https://docs.aws.amazon.com/cli/latest/userguide/cli-chap-welcome.html" target="_blank" rel="noopener noreferrer"> AWS CLI </a>，因此您需要在开始之前对其进行正确设置。</p>
<p>你还需要Node.js版本12和NPM版本6。</p>
<p>我使用了<a href="https://console.aws.amazon.com/cloud9/" target="_blank" rel="noopener noreferrer"> Cloud9 IDE </a>，因为它预装了AWS CLI、Node.js和NPM。</p>
<h3>CLI安装</h3>
<p>首先，你需要安装两个CLI:<code>create-react-app</code>和<code>amplify</code>。</p>
<pre>$ npm i -g create-react-app @aws-amplify/cli</pre>
<p>我们在这里使用create-react-app CLI，因为它允许您非常容易地与服务人员一起设置react应用程序。当没有互联网连接时，服务人员需要在浏览器中显示该应用程序。</p>
<p>离线时在浏览器中显示页面只是工作的一半。您在使用应用程序时对数据所做的更新需要保存在某个地方，稍后再同步回您的后端。</p>
<p>这就是Amplify框架发挥作用的地方。它允许您在CLI的帮助下创建AWS支持的无服务器后端，并通过JavaScript库简化您的前端到这些后端服务的连接。</p>
<h3>项目设置</h3>
<p>如果您正在使用Cloud9并希望使用它的本地AWS概要文件，您必须向AWS概要文件添加一个符号链接。Cloud9创建并管理一个<code>credentials</code>文件，但是Amplify搜索一个配置文件。</p>
<pre>$ ln -s ~/.aws/credentials ~/.aws/config</pre>
<p>要初始化React项目并向其中添加Amplify服务，请使用以下命令:</p>
<pre>$ create-react-app grocerize
$ cd grocerize
$ amplify init</pre>
<p>Amplify的init命令会问你几个问题。您可以使用默认值回答所有这些问题—只有environment命令需要一些输入。这里可以用“dev”。</p>
<p>它将在云中为您创建部署基础架构。</p>
<p>在这之后，您应该有一个名为grocerize的React项目目录。在它应该是一个有一些文件的放大目录。</p>
<h2>添加AWS后端服务</h2>
<p>你需要两个后端服务:<code>auth</code>和<code>api</code>。</p>
<p>这两个将允许您的用户登录，然后处理所有需要完成的同步工作，因此您的用户的数据不会留在他们的设备上。</p>
<h3>添加身份验证</h3>
<p>您可以通过将<code>auth</code>类别添加到您的Amplify项目来添加认证。这是通过以下命令完成的:</p>
<pre>$ amplify add auth</pre>
<p>同样，您可以使用该命令的默认值。它将以CloudFormation模板的形式创建基础架构代码。</p><div class="code-block code-block-54">
<hr/>
<h3>更多来自LogRocket的精彩文章:</h3>

<hr/></div>
<p>这些将在以后用于创建一个Amazon Cognito的无服务器认证服务。</p>
<h2>添加GraphQL API</h2>
<p>GraphQL是用于保持用户的本地数据与云同步的机制的核心。</p>
<p>您需要使用以下命令通过Amplify CLI添加支持同步的GraphQL API:</p>
<pre>$ amplify add api</pre>
<p>在这里，您必须选择“GraphQL”，给API一个口语名称—最好使用您的React项目名称“grocerize”—并使用“Amazon Cognito User Pool”作为默认授权类型，这样API就可以使用我们在前面一步中添加的auth类别。</p>
<p>这里的下一个问题很重要:</p>
<p>"您想为GraphQL API配置高级设置吗？"</p>
<p>是的，你想这么做！如果不这样做，您将得到一个不支持同步的普通GraphQL API，然后数据存储库只能在以后脱机工作。</p>
<p>在你回答了这个问题“是”之后，你将会被问几个额外的问题。</p>
<p>以下是您最终获得“支持同步的GraphQL API”所需的答案:</p>
<pre>? Configure additional auth types? No
? Configure conflict detection? Yes
? Select the default resolution strategy Auto Merge
? Do you have an annotated GraphQL schema? No
? Do you want a guided schema creation? Yes
? What best describes your project: Single object with fields...
? Do you want to edit the schema now? No</pre>
<p>冲突检测是这里的重要部分。如果你想了解更多细节，你可以在<a href="https://aws-amplify.github.io/docs/js/datastore#conflict-resolution" target="_blank" rel="noopener noreferrer"> Amplify文档</a>中阅读。</p>
<p>在我们添加了<code>api</code>类别之后，Amplify CLI创建了一些CloudFormation模板，我们可以使用它们来获得在云中初始化的AWS AppSync、Lambda和DynamoDB驱动的后端。</p>
<h3>生成数据模型</h3>
<p>下一步是为数据存储库生成模型。</p>
<p>数据存储以不同的编程语言实现，适用于不同的平台，如Web、Android和iOS。</p>
<p>在为您使用的语言生成模型代码时，它使用GraphQL作为事实的来源。</p>
<p>首先，您需要在以下位置更新GraphQL模式:</p>
<pre>grocerize/amplify/backend/api/grozerize/schema.graphql</pre>
<p>只需用以下代码替换该文件的内容:</p>
<pre>type Item @model @auth(rules: [{allow: owner}]) {
  id: ID!
  name: String!
  amount: Int!
  purchased: Boolean
}</pre>
<p>该模式将创建一个单一类型，它由云中的DynamoDB表支持，并由Cognitos授权机制保护。只有它的创建者可以读取或写入它。</p>
<p>这种型号是我们购物清单上的一项。它有一个名字，一个数量，和一个购买状态。</p>
<p>要将模型作为JavaScript类用于React项目，您需要运行Amplify的代码生成器，如下所示:</p>
<pre>$ amplify codegen models</pre>
<p>之后，应该会出现一个新目录<code>grocerize/src/models</code>。它保存JavaScript文件，Amplify的数据存储库以后可以使用这些文件。</p>
<h2>部署后端服务</h2>
<p>到目前为止，您只部署了Amplify工作所需的基础设施，即部署支持您的应用程序的实际服务。</p>
<p>要部署它们，只需使用以下命令:</p>
<pre>$ amplify push</pre>
<p>如果要求您生成GraphQL查询代码，您可以拒绝。我们不会直接使用GraphQL，而是通过DataStore来使用，在上一步中我们已经为它生成了模型。</p>
<p>只有4个CLI命令，我们有一个成熟的AWS支持的无服务器后端。今天的技术让前端开发人员能够做的事情是不是很疯狂？</p>
<p>该命令需要几分钟才能完成。然后，您有了一个新的JavaScript文件<code>grocerize/src/aws-exports.js</code>，其中包含所有AWS凭证，您可以在以后使用这些凭证来配置您的前端。</p>
<h2>连接前端</h2>
<p>要连接到前端，您需要安装Amplify JavaScript库并从您的GraphQL代码生成模型。</p>
<h3>安装前端库</h3>
<p>要将React前端连接到新部署的无服务器后端，您需要放大JavaScript库。</p>
<p>您可以使用npm安装它们:</p>
<pre>$ npm i @aws-amplify/core \
@aws-amplify/auth \
@aws-amplify/ui-react \
@aws-amplify/datastore</pre>
<p>核心包主要包含用于连接云服务的基本Amplify代码。</p>
<p><code>ui-react</code>包包含注册和登录的React组件。</p>
<p>它建立在<code>auth</code>包的基础上，该包执行实际的认证工作。</p>
<p><code>datastore</code>包用于在本地存储数据，并通过GraphQL将其同步到云端。</p>
<h3>更新前端代码</h3>
<p>现在，您必须实现实际的前端代码。第一部分是<code>grocerize/src/index.js</code>。</p>
<p>用以下代码替换其内容:</p>
<pre>import React from 'react';
import ReactDOM from 'react-dom';
import Amplify from "@aws-amplify/core";
import "@aws-amplify/auth";

import awsconfig from "./aws-exports";
import App from './App';
import * as serviceWorker from './serviceWorker';

Amplify.configure(awsconfig);

ReactDOM.render(
  &lt;React.StrictMode&gt;
    &lt;App /&gt;
  &lt;/React.StrictMode&gt;,
  document.getElementById('root')
);

serviceWorker.register();</pre>
<p>那么，让我们看看这里发生了什么。</p>
<p>其中大部分仍然是一个基本的React设置。当您之前使用<code>amplify push</code>命令部署我们的基础设施时，您使用由Amplify CLI生成的<code>aws-exports.js</code>文件配置了Amplify库。</p>
<p>对底部的<code>serviceWorker.register()</code>的最后一次调用将使我们的React项目能够被渲染，即使服务器不再可达，从而使它离线可用。</p>
<p>下一个要更新的文件是<code>grocerize/src/App.js</code>。用以下代码替换其内容:</p>
<pre>import React from "react";
import { DataStore, Predicates } from "@aws-amplify/datastore";
import { withAuthenticator } from "@aws-amplify/ui-react";
import { Item } from "./models";

class App extends React.Component {
  state = {
    itemName: "",
    itemAmount: 0,
    items: [],
  };

  async componentDidMount() {
    await this.loadItems();
    DataStore.observe(Item).subscribe(this.loadItems);
  }

  loadItems = async () =&gt; {
    const items = await DataStore.query(Item, Predicates.ALL);
    this.setState({ items });
  };

  addItem = async () =&gt; {
    await DataStore.save(
    new Item({
        name: this.state.itemName,
        amount: this.state.itemAmount,
        purchased: false,
    })
    );
    this.setState({itemAmount: 0, itemName: ""});
  }

  purchaseItem = (item) =&gt; () =&gt;
    DataStore.save(
    Item.copyOf(item, (updated) =&gt; {
        updated.purchased = !updated.purchased;
    })
    );

  removeItem = (item) =&gt; () =&gt; DataStore.delete(item);

  render() {
    const { itemAmount, itemName, items } = this.state;

    return (
    &lt;div style={{ maxWidth: 500, margin: "auto" }}&gt;
        &lt;h1&gt;GROCERIZE&lt;/h1&gt;
        &lt;h2&gt;Your Personal Grocery List&lt;/h2&gt;
        &lt;p&gt;Add items to your grocery list!&lt;/p&gt;
        &lt;input
        placeholder="Gorcery Item"
        value={itemName}
        onChange={(e) =&gt; this.setState({ itemName: e.target.value })}
        /&gt;
        &lt;input
        placeholder="Amount"
        type="number"
        value={itemAmount}
        onChange={(e) =&gt;
            this.setState({ itemAmount: parseInt(e.target.value) })
        }
        /&gt;
        &lt;button onClick={this.addItem}&gt;Add&lt;/button&gt;
        &lt;h2&gt;Groceries:&lt;/h2&gt;
        &lt;ul style={{listStyleType:"none"}}&gt;
        {items.map((item) =&gt; (
            &lt;li key={item.id} style={{fontWeight: item.purchased? 100 : 700}}&gt;
            &lt;button onClick={this.removeItem(item)}&gt;remove&lt;/button&gt;
            &lt;input type="checkbox" checked={item.purchased} onChange={this.purchaseItem(item)}/&gt;
            {" " + item.amount}x {item.name}
            &lt;/li&gt;
        ))}
        &lt;/ul&gt;
    &lt;/div&gt;
    );
  }
}

export default withAuthenticator(App);</pre>
<p>这段代码是我们的应用程序使用的唯一屏幕。</p>
<p>在顶部，我们导入数据存储库、从GraphQL模式生成的项目模型以及用于身份验证的更高阶组件。</p>
<p>App组件使用数据存储在呈现时加载所有项目。</p>
<p>第一次呈现项目后，组件使用其<code>loadItems</code>方法订阅数据存储中任何项目的更改。</p>
<p>该方法将收集所有项目，并重新呈现屏幕。</p>
<p><code>loadItems</code>、<code>addItem</code>、<code>purchaseItem</code>和<code>removeItem</code>方法构成了该应用的基本CRUD操作。编程模型非常简单，因为您在本地存储您的数据，这几乎是即时发生的，并且在后台一切都与您的云基础架构同步。</p>
<p>在应用程序组件被导出之前，它被打包到<code>withAuthenticator</code>高阶组件中，该组件将在用户可以与应用程序交互之前显示一个登录屏幕。</p>
<h2>使用应用程序</h2>
<p>要启动开发服务器，只需运行以下命令:</p>
<pre>$ npm start</pre>
<p>如果在浏览器中打开开发服务器URL，将会提示您注册。</p>
<p>正如您在注册和登录过程中看到的，后端预配置了安全密码要求和电子邮件激活。这都是可以配置的。</p>
<p>登录后，你可以随心所欲地创建你的购物清单。</p>
<p>如果你在智能手机上使用这个应用程序，当你在杂货店里的互联网连接断开时，你仍然可以与你的购物清单互动，检查你买了什么，等等。</p>
<p>当连接稍后恢复时，您的所有更改都将同步到后端，因此您可以在另一台设备上修改它们。</p>
<h2>结论</h2>
<p>AWS Amplify对于前端开发人员来说是一个非常强大的工具，新的数据存储及其离线和同步功能使其工作起来更加愉快。</p>
<p>编程模型保持简单，所有繁重的工作都由数据存储在后台完成。</p>
<p>在几分钟内，您可以创建一个无服务器的后端，拥有普通移动应用程序所需的一切，Amplify使用CloudFormation来部署AWS服务的事实使其具有多功能性，经得起未来的考验。</p>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
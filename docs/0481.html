<html>
<head>
<title>Exploring NodeGUI and React NodeGUI: Electron alternatives - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>探索NodeGUI和React NodeGUI:电子替代品</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/nodegui-react-nodegui-electron-alternatives/#0001-01-01">https://blog.logrocket.com/nodegui-react-nodegui-electron-alternatives/#0001-01-01</a></blockquote><div><article class="article-post">
<p><em> <strong>编者按</strong>:本文最后更新于2021年12月16日。</em></p>
<p>与Electron类似，<a href="https://github.com/nodegui/nodegui"> NodeGUI </a>是一个开源框架，用于构建跨平台的本机桌面应用程序，采用JavaScript和类似CSS的样式。您可以从一个代码库在Mac、Windows和Linux上运行NodeGUI应用程序。</p>
<p>NodeGUI与Electron的区别在于，它由<a href="https://www.qt.io/"> Qt5 </a>提供支持，这对于性能和内存来说都非常出色，但它确实迫使人们使用它们的组件，而不是像Electron那样使用HTML。</p>
<p>在本文中，我们将探索NodeGUI框架，主要关注React NodeGUI模块，它使开发人员能够使用本机React和强大的CSS样式构建高性能的本机和跨平台桌面应用程序。</p>
<p>我们将开发一个可以在Linux、Mac和Windows操作系统上工作的系统实用程序监视器应用程序。我们还将使用<a href="https://github.com/nodegui/react-nodegui-starter"> react-node-gui-starter </a>项目来引导我们的应用程序并快速启动和运行。</p>
<h3>先决条件</h3>
<p>要跟随本教程，请确保具备以下条件:</p>
<ul>
<li>Node.js已安装</li>
<li>IDE</li>
<li>终端应用程序，如用于Mac的iTerm2和用于Windows的Hyper</li>
<li>熟悉TypeScript、React和CSS</li>
</ul>
<h3>目录</h3>

<h2 id="building-system-utility-monitor-application">构建系统实用程序监视器应用程序</h2>
<p>我们将构建一个简单的应用程序，动态显示操作系统的CPU、内存和磁盘空间，以及一些与操作系统相关的附加统计信息。</p>
<p>你可以在这个<a href="https://github.com/nodegui/react-nodegui-starter"> GitHub repo </a>上访问这个项目的代码。最终结果将如下图所示:</p>
<p><img data-attachment-id="83401" data-permalink="https://blog.logrocket.com/nodegui-react-nodegui-electron-alternatives/final-system-utility-monitor-application/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2019/10/final-system-utility-monitor-application.png" data-orig-size="494,485" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="final-system-utility-monitor-application" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2019/10/final-system-utility-monitor-application-300x295.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2019/10/final-system-utility-monitor-application.png" decoding="async" class="aligncenter wp-image-83401 size-full jetpack-lazy-image" src="../Images/162464655e8466bf5534502368073ad2.png" alt="Final System Utility Monitor Application" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2019/10/final-system-utility-monitor-application.png 494w, https://blog.logrocket.com/wp-content/uploads/2019/10/final-system-utility-monitor-application-300x295.png 300w" data-lazy-sizes="(max-width: 494px) 100vw, 494px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2019/10/final-system-utility-monitor-application.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/10/final-system-utility-monitor-application.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="83401" data-permalink="https://blog.logrocket.com/nodegui-react-nodegui-electron-alternatives/final-system-utility-monitor-application/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2019/10/final-system-utility-monitor-application.png" data-orig-size="494,485" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="final-system-utility-monitor-application" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2019/10/final-system-utility-monitor-application-300x295.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2019/10/final-system-utility-monitor-application.png" decoding="async" loading="lazy" class="aligncenter wp-image-83401 size-full" src="../Images/162464655e8466bf5534502368073ad2.png" alt="Final System Utility Monitor Application" srcset="https://blog.logrocket.com/wp-content/uploads/2019/10/final-system-utility-monitor-application.png 494w, https://blog.logrocket.com/wp-content/uploads/2019/10/final-system-utility-monitor-application-300x295.png 300w" sizes="(max-width: 494px) 100vw, 494px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/10/final-system-utility-monitor-application.png"/></noscript>
<h2 id="settingup-react-nodegui-project">设置我们的React节点GUI项目</h2>
<p>首先，在您的终端应用程序中运行以下代码，这将克隆启动应用程序:</p>
<pre class="language-bash hljs"># Clone this repository
git clone https://github.com/nodegui/react-nodegui-starter

# Go into the repository
cd react-nodegui-starter

# Install dependencies
npm install
</pre>
<p>我们需要再安装一个npm包，以便访问我们的系统信息:</p>
<pre class="language-bash hljs">npm i node-os-utils
</pre>
<p><a href="https://www.npmjs.com/package/node-os-utils"> node-os-utils </a>是一个操作系统实用程序库。有些方法是Node.js库的包装器，有些是模块进行的计算。</p>
<h2 id="application-scripts-development">应用程序脚本和开发</h2>
<p>starter应用程序提供了一些我们可以运行的npm脚本:</p>
<pre class="language-bash hljs">"build": "webpack -p",
"start": "webpack &amp;&amp; qode ./dist/index.js",
"debug": "webpack &amp;&amp; qode --inspect ./dist/index.js",
"start:watch": "nodemon -e js,ts,tsx --ignore dist/ --ignore node_modules/ --exec npm start"
</pre>
<p>对于开发，我们将运行以下命令:</p>
<pre class="language-bash hljs">npm run start:watch
</pre>
<p>运行上面的命令将启动应用程序，并允许热重装。您可能已经注意到了一个新的窗口加载，它是跨平台的React NodeGUI桌面应用程序。</p>
<h2 id="globals-systems-details-helper">全局和系统详细信息帮助程序</h2>
<p>首先，我们想要创建一个<code>globals.ts</code>文件，在这里我们将存储与我们的应用程序相关的全局信息。在<code>src</code>目录中，创建一个名为<code>helpers</code>的目录。在<code>helpers</code>中，创建一个名为<code>globals.ts</code>的文件，并添加以下代码:</p>
<pre class="language-typescript hljs">const colors = {
    red: '#FF652F',
    yellow: '#FFE400',
    green: '#14A76C'
}

const labels = {
    free: 'Free',
    used: 'Used'
}

export const globals = {      
    colors,
    labels
}
</pre>
<p>在上面的代码片段中，我们创建了两个对象，<code>colors</code>和<code>labels</code>，我们将把它们添加到<br/> <code>globals</code>对象中，然后导出。注意，我们在globals对象中只使用了<code>colors</code>和<code>labels</code>变量名，这是ES6中的<code>Object</code>属性值简写。</p>
<p>如果您想定义一个对象，它的键与作为属性传入的变量同名，您可以使用简写方式，只需传递键名。</p>
<p><code><a href="https://developer.mozilla.org/en-US/docs/web/javascript/reference/statements/export">export</a></code>语句用于在创建JavaScript模块时从模块中导出函数、对象或基元值，因此其他程序也可以使用<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/import"> <code>import</code> </a>语句。</p>
<p>接下来，我们将在<code>systemDetails.ts</code>文件中使用<code>globals.ts</code>文件，我们也可以在<code>helpers</code>目录中创建该文件:</p>
<pre class="language-typescript hljs">// Import External Dependencies
const osu = require('node-os-utils')

// Destructure plugin modules
const {os, cpu, mem, drive} = osu

// Import Globals
import { globals } from "./globals"

// Use ASYNC function to handle promises
export const systemDetails = async () =&gt; {
    // Static Details
    const platform = cpu.model()
    const operatingSystem = await os.oos()
    const ip = os.ip()
    const osType = os.type()
    const arch = os.arch()

    // CPU Usage
    const cpuUsed= await cpu.usage()
    const cpuFree = await cpu.free()

    // Memory Usage
    const memUsed = await mem.used()
    const memFree = await mem.free()

    // Disk Space Usage
    const driveInfo = await drive.info()
    const memUsedPercentage = memUsed.usedMemMb / memUsed.totalMemMb * 100
    const memFreePercentage = memFree.freeMemMb / memFree.totalMemMb * 100

    const systemInformation = {
      staticDetails: {
        platform,
        operatingSystem,
        ip,
        osType,
        arch
      },
      cpuDetails: {
        cpuUsed: {
          usage: cpuUsed,
          label: globals.labels.used,
          color: globals.colors.red
        },
        cpuFree: {
          usage: cpuFree,
          label: globals.labels.free,
          color: globals.colors.green
        }
      },
      memoryDetails: {
        memUsed: {
          usage: memUsedPercentage,
          label: globals.labels.used,
          color: globals.colors.red
        },
        memFree: {
          usage: memFreePercentage,
          label: globals.labels.free,
          color: globals.colors.green
        }
      },
      driveDetails: {
        spaceUsed: {
          usage: driveInfo.usedPercentage,
          label: globals.labels.used,
          color: globals.colors.red
        },
        spaceFree: {
          usage: driveInfo.freePercentage,
          label: globals.labels.free,
          color: globals.colors.green
        }
      }
    }
    return systemInformation
}
</pre>
<p>我们需要<a href="https://www.npmjs.com/package/node-os-utils"> node-os-utils </a> npm包，我们将使用它来获取我们所有的系统信息。node-os-utils主要依赖于本机Node.js库，这使得它与NodeGUI非常兼容。</p>
<p>接下来，我们使用<a href="https://hacks.mozilla.org/2015/05/es6-in-depth-destructuring/"> JavaScript ES6析构</a>将变量分配给我们将在node-os-utils包中使用的函数。</p>
<p>我们导入自己创建的<code>globals</code>对象。就像我们在<code>globals.ts</code>文件中使用export语句一样，我们现在再次使用它，但是这一次，我们将导出异步函数<code>systemDetails</code>。</p>
<p>node-os-utils库主要使用<a href="https://alligator.io/js/promises-es6/"> JavaScript和ES6 promises </a>返回数据，允许我们使用async/await函数检索数据。使用async/ await，我们可以在后台执行异步任务的同时编写完全同步的代码。我个人发现，使用async/await函数会产生非常干净、简洁和可读的代码。</p>
<p>为了获得系统信息，我们将在返回承诺的函数调用前使用node-os-utils库和<code>await</code>操作符。在node-os-utils库描述中，您可以确切地看到每个函数调用返回的内容:</p>
<p><img data-attachment-id="83403" data-permalink="https://blog.logrocket.com/nodegui-react-nodegui-electron-alternatives/await-operator-function-call-returns/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2019/10/await-operator-function-call-returns.png" data-orig-size="730,323" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="await-operator-function-call-returns" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2019/10/await-operator-function-call-returns-300x133.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2019/10/await-operator-function-call-returns.png" decoding="async" class="aligncenter wp-image-83403 size-full jetpack-lazy-image" src="../Images/f9a8d04aad56854357a7534361c05af7.png" alt="Await Operator Function Call Returns" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2019/10/await-operator-function-call-returns.png 730w, https://blog.logrocket.com/wp-content/uploads/2019/10/await-operator-function-call-returns-300x133.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2019/10/await-operator-function-call-returns.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/10/await-operator-function-call-returns.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="83403" data-permalink="https://blog.logrocket.com/nodegui-react-nodegui-electron-alternatives/await-operator-function-call-returns/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2019/10/await-operator-function-call-returns.png" data-orig-size="730,323" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="await-operator-function-call-returns" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2019/10/await-operator-function-call-returns-300x133.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2019/10/await-operator-function-call-returns.png" decoding="async" loading="lazy" class="aligncenter wp-image-83403 size-full" src="../Images/f9a8d04aad56854357a7534361c05af7.png" alt="Await Operator Function Call Returns" srcset="https://blog.logrocket.com/wp-content/uploads/2019/10/await-operator-function-call-returns.png 730w, https://blog.logrocket.com/wp-content/uploads/2019/10/await-operator-function-call-returns-300x133.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/10/await-operator-function-call-returns.png"/></noscript>
<h2 id="node-os-utils-functions">node-os-utils函数</h2>
<p>然后，我们使用函数调用返回的所有值来创建由<code>systemDetails</code>函数返回的<code>systemInformation</code>对象。现在，我们准备使用<code>systemInformation</code>并创建应用程序接口。</p>
<h2 id="application-interface-design">应用程序界面和设计</h2>
<p>在这个阶段，我们的应用程序看起来不太像，但是我们将要改变这一点。在<code>src</code>目录中，创建一个<code>components</code>目录，并添加以下三个组件文件:</p>
<ul>
<li><code>InnerContainer.tsx</code></li>
<li><code>statsColumn.tsx</code></li>
<li><code>statsRow.tsx</code></li>
</ul>
<p>接下来，我们需要更新<code>src</code>目录中的<code>index.tsx</code>文件。首先，让我们删除应用程序中不会用到的所有代码，留下一个干净的<code>index.tsx</code>文件，如下所示:</p>
<pre class="language-typescript hljs">// Import External Dependencies
import {Window, Renderer, View, Text} from "@nodegui/react-nodegui"
import React, { useState, useEffect } from "react"

// Import System Details
import { systemDetails } from "./helpers/systemDetails"

// Application width and height
const fixedSize = { width: 490, height: 460 }

// Function React Component
const App = () =&gt; {
  return (
    &lt;Window minSize={fixedSize} maxSize={fixedSize} styleSheet={styleSheet}&gt;
      &lt;View id="container"&gt;
        &lt;Text id="header"&gt;System Utility Monitor&lt;/Text&gt;
      &lt;/View&gt;
    &lt;/Window&gt;
  )
}

// Application Stylesheets
const styleSheet = `
  #container {
    flex: 1;
    flex-direction: column;
    min-height: '100%';
    align-items: 'center';
    justify-content: 'center';
  }
`

// Render the application
Renderer.render(&lt;App /&gt;)
</pre>
<p>如果你以前用过React Native，上面的语法可能看起来很熟悉；与React Native类似，我们没有使用HTML的自由。相反，我们使用框架提供的预定义组件，如<code>View</code>和<code>Text</code>。</p>
<p>在上面的代码中，我们再次使用JavaScript ES6析构语法导入模块和函数。然后我们声明一个常量<code>fixedSize</code>，我们将使用它来指定应用程序窗口的最小和最大宽度。</p>
<p>接下来，我们将创建一个功能性的React组件，我们将在其中构建应用程序。我们不会涉及React的基础知识，所以如果你不熟悉React钩子，一定要查看一些教程。<br/>如果你想更深入地了解React理论，可以看看这篇详细描述了<a href="https://www.robinwieruch.de/react-function-component/"> React功能组件</a>的复杂性的文章。此外，查看React钩子上的官方React文档,它可以从React v 16.8获得，是对框架的一个很好的补充。</p>
<p>NodeGUI React框架的第一个组件是<code><a href="https://docs.nodegui.org/#/api/QMainWindow">&lt;Window/&gt;</a></code>组件。一个<code>QMainWindow</code>提供了一个主应用程序窗口。NodeGui中的每个小部件都应该是QMainWindow的子部件或嵌套子部件。NodeGui中的QMainWindow还负责其子节点的FlexLayout计算。</p>
<p>我们提供<code>&lt;Window/&gt;</code>组件<code>minSize</code>、<code>maxSize</code>和<code>styleSheet</code>道具。第22行声明了<code>styleSheet</code>常量。嵌套在<code>&lt;Window/&gt;</code>组件中的是一个<code>&lt;View/&gt;</code>组件。一个<code>QWidget</code>可以用来封装其他部件并提供结构。它的功能类似于网络世界中的<code>div</code>。在<code>&lt;View/&gt;</code>组件中有一个<code>&lt;Text/&gt;</code>组件，一个<code>QLabel</code>组件提供了添加和操作文本的能力。</p>
<p>然后我们声明一个<code>styleSheet</code>常量，它是一个模板字符串。模板文字是允许嵌入表达式的字符串文字。您可以对模板文字使用多行字符串和字符串插值功能。在ES2015规范的早期版本中，它们被称为模板字符串。</p>
<p>NodeGUI框架并不支持所有的CSS属性，在某些情况下，需要参考<a href="https://doc.qt.io/archives/qt-4.8/stylesheet-reference.html#list-of-properties"> Qt文档</a>来确定使用哪一个。因此，造型可能有点棘手。</p>
<p>例如，属性<code>overflow:scroll</code>在Qt CSS中不存在，因此需要为该功能实现其他解决方法，如这个<a href="https://github.com/nodegui/react-nodegui/issues/22"> GitHub问题线程</a>。</p>
<p>关于Flexbox支持，NodeGUI框架按照<a href="https://yogalayout.com/"> Yoga框架</a>支持所有属性和所有布局，这也被React Native和ComponentKit等框架使用。</p>
<p>最后，我们将呈现我们的应用程序。既然应用程序的基础已经就绪，我们需要集成系统信息，并使用我们创建的组件显示它。</p>
<h2 id="initial-data-object-react-hooks">反应钩子的初始数据对象</h2>
<p>在我们使用系统数据之前，我们需要一个初始数据对象，应用程序将在使用从<code>systemDetails</code>函数返回的数据填充之前使用这个对象。在<code>helpers</code>目录中，创建一个新文件<code>initialData.ts</code>，并添加以下代码:</p>
<pre class="language-typescript hljs">export const initialData = {
    staticDetails:{
      platform: 'Loading System Data...',
      operatingSystem: '',
      ip: '',
      osType: '',
      arch: ''
    },
    cpuDetails:{
      cpuUsed: {
        usage: '',
        label: 'Loading',
        color: ''
      },
      cpuFree: {
        usage: '',
        label: 'Loading',
        color: ''
      }
    },
    memoryDetails:{
      memUsed: {
        usage: '',
        label: 'Loading',
        color: ''
      },
      memFree: {
        usage: '',
        label: 'Loading',
        color: ''
      }
    },
    driveDetails: {
      spaceUsed: {
        usage: '',
        label: 'Loading',
        color: ''
      },
      spaceFree: {
        usage: '',
        label: 'Loading',
        color: ''
      }
    }
  }
</pre>
<p>如您所见，这模仿了由<code>systemDetails</code>函数返回的<code>systemInformation</code>对象。让我们把它添加到<code>index.ts</code>文件中，如下所示:</p>
<pre class="language-typescript hljs">...
// Import System Details
import { systemDetails } from "./helpers/systemDetails"
import { initialData } from "./helpers/initialData"
...
</pre>
<h2 id="putting-data-to-use">将数据投入使用</h2>
<p>React钩子可能是我在过去几年中JavaScript生态系统中最喜欢的发展之一，它允许清晰、简洁的代码易于阅读和维护。</p>
<p>让我们从实现我们之前导入的React <code>setState</code>钩子开始。在<code>App</code> functional React组件中添加以下代码:</p>
<pre class="language-typescript hljs">  // Array destructure data and setData function
  const [data, setData] = useState(initialData)
</pre>
<p>这里有很多东西需要解开，尤其是如果你是React Hooks的新手。要了解更多信息，我建议观看以下视频:</p>
<p><span class="embed-youtube"> <iframe loading="lazy" class="youtube-player" src="https://www.youtube.com/embed/mxK8b99iJTg?version=3&amp;rel=1&amp;showsearch=0&amp;showinfo=1&amp;iv_load_policy=1&amp;fs=1&amp;hl=en-US&amp;autohide=2&amp;wmode=transparent" allowfullscreen="true" sandbox="allow-scripts allow-same-origin allow-popups allow-presentation">视频</iframe> </span></p>
<p>如果我们<code>console.log()</code>数据常量，我们将看到我们的<code>initialData</code>对象已经被分配给数据常量。现在，让我们再次使用一些析构来为应用程序中的静态数据分配我们需要的变量:</p>
<pre class="language-typescript hljs">  //Get Static Data
  const {platform, operatingSystem, ip, osType, arch} = data.staticDetails
</pre>
<p>目前，<code>data</code>常量仍然指向我们创建的<code>initialData</code>对象。让我们使用<code>useEffect()</code>钩子用来自<code>systemsDetail</code>函数的数据更新我们的状态。我们可以通过将下面的代码添加到<code>index.tsx</code>文件中，就在<code>useState()</code>钩子之后:</p>
<pre class="language-typescript hljs">...
const [data, setData] = useState(initialData)

useEffect(() =&gt; {
  const getSystemData = async () =&gt; {
    const sysData : any = await systemDetails()
    setData(sysData)
  }
  getSystemData()
})

//Get Static Data
...
</pre>
<p>现在，如果我们<code>console.log()</code>这个数据常量，我们会看到它不断地被新数据更新。请务必仔细阅读<a href="https://dev.to/n1ru4l/homebrew-react-hooks-useasynceffect-or-how-to-handle-async-operations-with-useeffect-1fa8"> <code>useEffect</code>钩子和异步/等待功能</a>。</p>
<p>我们可以在应用程序标题下添加以下代码，它将显示系统平台:</p>
<pre class="language-typescript hljs">&lt;Text id="subHeader"&gt;{platform}&lt;/Text&gt;
</pre>
<p>现在，我们已经为我们的应用程序打下了基础。我们需要的只是建筑和装饰。</p>
<h2 id="styling-components">样式和组件</h2>
<p>让我们首先用下面的代码替换<code>index.tsx</code>文件中的<code>styleSheet</code>常量:</p>
<pre class="language-typescript hljs">// Application Stylesheets
const styleSheet = `
  #container {
    flex: 1;
    flex-direction: column;
    min-height: '100%';
    height: '100%';
    justify-content: 'space-evenly';
    background-color: #272727;
  }
  #header {
    font-size: 22px;
    padding: 5px 10px 0px 10px;
    color: white;
  }
  #subHeader {
    font-size: 14px;
    padding: 0px 10px 10px 10px;
    color: white;
  }
`
</pre>
<p>到目前为止，我们已经使用了相当标准的CSS样式，但是随着我们的继续，我们将会看到一些边缘情况。让我们用下面的代码填充第一个组件<code>StatsRow.tsx</code>文件:</p>
<pre class="language-typescript hljs">// Import External Dependencies
import React from 'react'
import {View} from "@nodegui/react-nodegui"

export const StatsRow = (props: { children: React.ReactNode; }) =&gt; {
  return (
      &lt;View id="systemStats" styleSheet={styleSheet}&gt;
          {props.children}
      &lt;/View&gt;
  )
}

const styleSheet = `
  #systemStats {
    width: 470;
    height: 180;
    flex: 1;
    flex-direction: row;
    justify-content: 'space-between';
    margin-horizontal: 10px;
  }
`
</pre>
<p>注意上面的<code>props.children</code>属性及其与TypeScript一起使用的语法。让我们通过向<code>index.tsx</code>文件添加以下代码来导入<code>StatsRow</code>组件:</p>
<pre class="language-typescript hljs">...
// Import Components
import {StatsRow} from "./components/StatsRow"
...
</pre>
<p>我们将使用<code>StatsRow</code>组件在我们的应用程序中创建两行，但是在使用它之前，让我们先通过添加以下代码来填充<code>innerContainer.tsx</code>:</p>
<pre class="language-typescript hljs">// Import External Dependencies
import React from 'react'
import {View, Text} from "@nodegui/react-nodegui"

// Set Types
type InnerContainerColumnProps = {
    title: string
}

export const InnerContainer: React.FC&lt;InnerContainerColumnProps&gt; = props =&gt; {
  // Desctructure props
  const {title, children} = props

  return (
      &lt;View id="innerContainer" styleSheet={styleSheet}&gt;        
          &lt;Text id="headText"&gt;{title}&lt;/Text&gt;
          &lt;View id="stats"&gt;
            {children}
          &lt;/View&gt;
      &lt;/View&gt;
  )
}

const styleSheet = `
  #innerContainer {
    height: 180;
    width: 230;
    background: #111111;
    border-radius: 5px;
  }
  #stats {
    flex-direction: row;
    align-items: 'flex-start';
    justify-content: 'flex-start';
  }

  #headText {
      margin: 5px 5px 5px 0;
      font-size: 18px;
      color: white;
  }
`
</pre>
<p>注意，我们已经涵盖了上面的大部分代码，但是我们需要采取一些额外的措施来在我们的React组件中容纳<a href="https://blog.logrocket.com/using-typescript-with-react-tutorial-examples/"> TypeScript。</a>将以下代码添加到<code>index.tsx</code>文件中:</p>
<pre class="language-typescript hljs">...
// Import Components
import {StatsRow} from "./components/StatsRow"
import {InnerContainer} from "./components/InnerContainer"
...
</pre>
<p>让我们完成最后一个组件，<code>StatsColumn.tsx</code>，然后将它们一起放到<code>index.tsx</code>文件中。我将把代码分成两部分，我们应该把它们结合起来；第一部分是没有样式的组件，第二部分是样式:</p>
<pre class="language-typescript hljs">// Import External Dependencies
import React from 'react'
import {View, Text} from "@nodegui/react-nodegui"

// Set Types
type StatsColumnProps = {
    label: string,
    usage: number,
    color: string
}

export const StatsColumn: React.FC&lt;StatsColumnProps&gt; = props =&gt; {
    // Destructure props
    const {usage, color, label} = props

    // Create Label with usage amount and percentage
    const percentageTextLabel = `${label} ${Math.round(usage * 100) / 100}%`

    // Create Dynamic Style Sheet
    const dynamicStyle = `
        height: ${usage};
        background-color: ${color};
    `

    return (
        &lt;View id="statsContainer" styleSheet={statsContainer}&gt;
            &lt;View id="columnContainer" styleSheet={columnContainer}&gt;   
                &lt;View id="innerColumn" styleSheet={dynamicStyle}&gt;&lt;/View&gt;
            &lt;/View&gt;
            &lt;Text id="statsLabel" styleSheet={statsLabel}&gt;{percentageTextLabel}&lt;/Text&gt;
        &lt;/View&gt;
    )
}
</pre>
<p>我们使用这个组件来创建图形效果，正如您在最终的应用程序屏幕截图中看到的那样。我们将<code>label</code>、<code>usage</code>和<code>color</code>属性传递给组件，我们将使用它们来动态更新组件。</p>
<p>在前面的代码块下，继续添加以下代码片段:</p>
<pre class="language-typescript hljs">const statsContainer = `
    #statsContainer {
        height: '140';
        text-align:center;
        justify-content: 'center';
        align-items: 'center';
        justify-content: 'space-between';
        width: 100%;
        flex: 1 0 100%;
        margin-horizontal: 5px;
    }
`

const columnContainer = `
    #columnContainer{
        height: 100%;
        flex: 1 0 100%;
        flex-direction: column-reverse;
        background-color: #747474;
        width: 100%;
    }
`

const statsLabel = `
    #statsLabel {
        height: 40;
        color: white;
        font-size: 14px;
        width: 100%;        
        qproperty-alignment: 'AlignCenter';
        color: white;
    }
`
</pre>
<p>创建<code>styleSheet</code>块的另一种方法是将每个样式属性声明为自己的常量。然而，您使用的方法并没有太大的区别，它更多的是开发者的偏好。</p>
<p>您可能还注意到了CSS属性<code>qproperty-alignment:'AlignCenter';</code>，这是一个用于对齐文本的Qt属性。我花了一些时间来解决这个问题，所以如果你遇到类似的警告，你可以使用这个<a href="https://doc.qt.io/qt-5/stylesheet-syntax.html"> Qt样式表参考</a>。</p>
<h2 id="adding-styles">添加样式</h2>
<p>让我们将最终组件导入到<code>index.tsx</code>文件中:</p>
<pre class="language-typescript hljs">// Import Components
import {StatsRow} from "./components/StatsRow"
import {InnerContainer} from "./components/InnerContainer"
import {StatsColumn} from "./components/StatsColumn"
</pre>
<p>向<code>index.tsx</code>文件中的<code>styleSheet</code>常量添加以下样式:</p>
<pre class="language-typescript hljs">...
  #subHeader {
    font-size: 14px;
    padding: 0px 10px 10px 10px;
    color: white;
  }

  #headText {
    margin: 5px 5px 5px 0;
    font-size: 18px;
    color: white;
  }
  #infoText {
    padding: 5px 0 0 5px;
    color: white;
  }
  #informationContainer {
    height: 180;
    width: 230;
    background: #111111;
    border-radius: 5px;
  }
...
</pre>
<p>现在，让我们为我们的应用程序添加第一部分内容。在<code>index.tsx</code>文件中的<code>&lt;Textid="subHeader"&gt;</code>组件下，添加以下代码:</p>
<pre class="language-typescript hljs">...
&lt;StatsRow&gt;
   &lt;View id="informationContainer" styleSheet={styleSheet}&gt;
      &lt;Text id="headText"&gt;System Information&lt;/Text&gt;
      &lt;Text id="infoText"&gt;{operatingSystem}&lt;/Text&gt;
      &lt;Text id="infoText"&gt;{osType}&lt;/Text&gt;
      &lt;Text id="infoText"&gt;{ip}&lt;/Text&gt;
      &lt;Text id="infoText"&gt;{arch}&lt;/Text&gt;
    &lt;/View&gt;
&lt;/StatsRow&gt;
...
</pre>
<p>由于样式不能被子组件继承的警告，我们需要在主<code>&lt;Window&gt;</code>组件中引用<code>&lt;View id="informationContainer"&gt;</code>中的<code>styleSheet</code>之后再引用它。</p><div class="code-block code-block-54">
<hr/>
<h3>更多来自LogRocket的精彩文章:</h3>

<hr/></div>
<p>您会注意到，现在，我们的应用程序第一次开始像一个实际的应用程序。让我们添加创建图表的代码。在<code>useEffect()</code>挂钩下面，添加以下代码:</p>
<pre class="language-javascript hljs">const renderCpuDetails = () =&gt; {
  const cpuDetails = data.cpuDetails
  return Object.keys(cpuDetails).map((key) =&gt; {
      const stat = cpuDetails[key]
      return &lt;StatsColumn label={stat.label} usage={stat.usage} color={stat.color}  /&gt;
  })
}

const renderMemoryDetails = () =&gt; {
  const memDetails = data.memoryDetails
  return Object.keys(memDetails).map((key) =&gt; {
      const stat = memDetails[key]
      return &lt;StatsColumn label={stat.label} usage={stat.usage} color={stat.color}  /&gt;
  })
}

const renderDriveDetails = () =&gt; {
  const driveDetails = data.driveDetails
  return Object.keys(driveDetails).map((key) =&gt; {
      const stat: any = driveDetails[key]
      return &lt;StatsColumn label={stat.label} usage={stat.usage} color={stat.color}  /&gt;
  })
}
</pre>
<p>在上面的代码中，我们循环遍历各自的对象键，然后使用这些值作为<code>&lt;StatsColumn/&gt;</code>组件的道具。</p>
<p>然后，我们可以在代码中使用这些函数，方法是用以下内容更新<code>index.tsx</code>文件:</p>
<pre class="language-typescript hljs">&lt;StatsContainer&gt;
    &lt;View id="informationContainer" styleSheet={styleSheet}&gt;
      &lt;Text id="headText"&gt;System Information&lt;/Text&gt;
      &lt;Text id="infoText"&gt;{operatingSystem}&lt;/Text&gt;
      &lt;Text id="infoText"&gt;{osType}&lt;/Text&gt;
      &lt;Text id="infoText"&gt;{ip}&lt;/Text&gt;
      &lt;Text id="infoText"&gt;{arch}&lt;/Text&gt;
    &lt;/View&gt;
  &lt;InnerContainer title={"Disk Space"}&gt;
    {renderDriveDetails()}
  &lt;/InnerContainer&gt;
&lt;/StatsContainer&gt;
&lt;StatsContainer&gt;
  &lt;InnerContainer title={"CPU Usage"}&gt;
    {renderCpuDetails()}
  &lt;/InnerContainer&gt;
  &lt;InnerContainer title={"Memory Usage"}&gt;
    {renderMemoryDetails()}
  &lt;/InnerContainer&gt;
&lt;/StatsContainer&gt;
</pre>
<p>在上面的代码中，我们执行了之前声明的三个函数，这三个函数依次呈现了<code>Disk Space</code>、<code>CPU Usage</code>和<code>Memory Usage</code>列。</p>
<h2 id="conclusion">结论</h2>
<p>在本文中，我们探索了NodeGUI框架和React NodeGUI模块，方法是构建一个系统实用程序监视应用程序，该应用程序动态显示操作系统的CPU、内存和磁盘空间，以及一些与操作系统相关的统计数据。现在，您应该熟悉NodeGUI作为电子产品的替代产品的优势。我希望你喜欢这篇文章！</p><div class="code-block code-block-17">
<div class="blog-plug inline-plug react-plug" vwo-el-id="26283398190">
<h2 vwo-el-id="41600691720">使用LogRocket消除传统反应错误报告的噪音</h2>
<a href="https://lp.logrocket.com/blg/react-signup-issue-free" target="_blank" vwo-el-id="19356441070">LogRocket
</a><p>是一款React analytics解决方案，可保护您免受数百个误报错误警报的影响，只针对少数真正重要的项目。LogRocket告诉您React应用程序中实际影响用户的最具影响力的bug和UX问题。</p><a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="19356441380">
<img class="first-react-image alignnone size-full wp-image-46 jetpack-lazy-image jetpack-lazy-image--handled" src="../Images/f300c244a1a1cf916df8b4cb02bec6c6.png" vwo-el-id="18272717540" data-lazy-loaded="1" data-original-src="https://files.readme.io/27c94e7-Image_2017-06-05_at_9.46.04_PM.png"/>
</a>
<a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="19356441690">
<img class="second-react-image alignnone size-full wp-image-46 jetpack-lazy-image jetpack-lazy-image--handled" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" vwo-el-id="30720362350" data-lazy-loaded="1" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/>
</a>
<a href="https://lp.logrocket.com/blg/react-signup-issue-free" target="_blank" rel="noopener noreferrer" vwo-el-id="35866400580">LogRocket
</a><p>自动聚合客户端错误、反应错误边界、还原状态、缓慢的组件加载时间、JS异常、前端性能指标和用户交互。然后，LogRocket使用机器学习来通知您影响大多数用户的最具影响力的问题，并提供您修复它所需的上下文。</p><p vwo-el-id="28675661060">关注重要的React bug—<a class="signup" href="https://lp.logrocket.com/blg/react-signup-issue-free" target="_blank" rel="noopener noreferrer" vwo-el-id="40093418840">今天就试试LogRocket】。</a></p>
</div></div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
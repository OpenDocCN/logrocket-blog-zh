<html>
<head>
<title>Security for full-stack web developers :  Part 3 - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>全栈web开发人员的安全性:第3部分- LogRocket博客</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/security-for-fullstack-web-developers-part-3-aaf81da57acb/#0001-01-01">https://blog.logrocket.com/security-for-fullstack-web-developers-part-3-aaf81da57acb/#0001-01-01</a></blockquote><div><div class="section-content">
<div class="section-inner sectionLayout--insetColumn">
<figure class="graf graf--figure"><img decoding="async" class="graf-image jetpack-lazy-image" src="../Images/381c550d7b7bc919ab36d5a93b8868fd.png" data-image-id="1*yJekr73XZxsxUyMxI6C9ow.jpeg" data-width="5184" data-height="3456" data-lazy-src="https://storage.googleapis.com/blog-images-backup/1*yJekr73XZxsxUyMxI6C9ow.jpeg?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://storage.googleapis.com/blog-images-backup/1*yJekr73XZxsxUyMxI6C9ow.jpeg"/><noscript><img data-lazy-fallback="1" decoding="async" class="graf-image" src="../Images/381c550d7b7bc919ab36d5a93b8868fd.png" data-image-id="1*yJekr73XZxsxUyMxI6C9ow.jpeg" data-width="5184" data-height="3456" data-original-src="https://storage.googleapis.com/blog-images-backup/1*yJekr73XZxsxUyMxI6C9ow.jpeg"/></noscript></figure>
<p class="graf graf--p">在这篇文章中，我想探讨一下web应用程序安全中最危险的元素——那些涉及用户和会话的元素。从后端的角度来看，用户和身份验证是我们的web应用程序的两个最深刻的属性，但我想从前端的角度来看这些属性。尽管处理像用户凭证安全这样的问题非常重要，但我们往往会忽略前端用户和会话安全问题的重要性，如cookie盗窃和跨站点请求伪造(CSRF)。</p>
<p class="graf graf--p">让我们首先讨论它到底是什么，以及我认为我们如何在现代web应用程序中完全减轻它。</p>
<h3 class="graf graf--h3">跨站点请求伪造(CSRF)</h3>
<p class="graf graf--p">跨站点请求伪造一直处于web应用程序安全的最前沿，比我们任何人想起来的都要长。它是如何工作的？本质上，恶意代理在用户登录和授权时从一个应用程序向另一个应用程序发送(伪造的)请求。恶意代理进入<strong class="markup--strong markup--p-strong">并且</strong>改变被请求应用上的受限动作，被请求应用完全相信这些改变是合法的。</p>
<p class="graf graf--p">让我展示给你看。</p>
<p class="graf graf--p">想象一下，如果你愿意，我是一个滥用安全的恶棍。想象一下，我碰巧知道Twitter没有CSRF保护。(是的，这仅仅是一个练习。不要有任何想法。)我还意识到，大多数访问我的网络应用的人可能会让他们的Twitter保持登录状态。这意味着他们的浏览器中存储了一个cookie。</p>
<p class="graf graf--p">在我的网络应用上，我可以嵌入这样的东西:</p>
<pre>&lt;form action="https://twitter.com/tweet" method="POST" id="sendTweet"&gt;
&lt;input type="hidden" name="tweet" value="Hey!  Check out my awesome spam site - spam.com"&gt;</pre>
<p class="graf graf--p">当浏览器加载我的web应用程序时，它也会加载此表单(完全不可见。然后，我还会嵌入一小段JS来发布表单，而您永远不会知道:</p>
<pre class="graf graf--pre"><code>document.getElementById("sendTweet").submit();</code></pre>
<p class="graf graf--p">酷毙了。我刚刚用你的账号发了一条微博，根本不需要知道你的用户名和密码。你存储在浏览器中的cookie允许我的应用程序发送一个伪造的请求，假装是你——如果Twitter没有CSRF缓解，它也会成功的！</p>
<p class="graf graf--p">也许更好的方法是将它与您自己的web应用程序联系起来，使用这样的场景，像我们大多数人一样，您可能有一个为您自己的用户设置的路线来改变他们的用户配置文件。<code>/user/profile </code>可能是最常见的例子，考虑到大多数滥用安全的恶棍都知道这一点(包括我自己)，向您的web应用程序发送POST请求，用新的电子邮件地址更新用户的个人资料是微不足道的。</p>
<p class="graf graf--p">虽然这似乎不是一个明显的问题，但是一旦用户的电子邮件地址被更改，我就可以为该用户帐户发出密码重置。当然，新的密码会发送到我在用户资料中留下的任何电子邮件地址。此时，用户帐户已完全受损。任何敏感数据现在都在我手里，而且，为了避免我们忘记，我是一个恶棍。可怕的东西。</p>
<p class="graf graf--p">多年来，我们一直试图通过检查HTTP头(如<code>Origin </code>和<code>Referer</code>)来解决CSRF请求。虽然这些已经提供了相当强大的保护几年，现在有一个简单的指令，一旦应用，将完全减轻CSRF攻击。</p>
<p class="graf graf--p">进入<a class="markup--anchor markup--p-anchor" href="https://tools.ietf.org/html/draft-west-first-party-cookies-07" target="_blank" rel="noopener noreferrer" data-href="https://tools.ietf.org/html/draft-west-first-party-cookies-07"><strong class="markup--strong markup--p-strong"><em class="markup--em markup--p-em">same site</em></strong>cookie指令</a>。SameSite 相对较新，仍然鲜为人知。实质上，一旦应用了<em class="markup--em markup--p-em"> SameSite </em>指令，它将告诉浏览器<strong class="markup--strong markup--p-strong">当外部(跨站点)URL发出请求时，永远不要</strong>发送cookie。我们可以通过如下方式修改我们的cookies来应用该指令:</p>
<pre class="graf graf--pre"><code>Set-Cookie: sess=sessionid123; path=/; <strong class="markup--strong markup--pre-strong">SameSite</strong></code></pre>
<p class="graf graf--p">真的就这么简单。我不会建议现在就删除你现有的CSRF保护，但我绝对会建议在你的web应用程序中包含该指令。</p>
</div>
<div class="section-inner sectionLayout--outsetColumn">
<figure class="graf graf--figure graf--layoutOutsetCenter"><a class="graf-imageAnchor" href="https://logrocket.com/signup/" target="_blank" rel="noopener noreferrer" data-href="https://logrocket.com/signup/" data-action="image-link" data-action-observe-only="true"><img decoding="async" class="graf-image jetpack-lazy-image" src="../Images/94b3e0f84b30cb0d321f60471481ab64.png" data-image-id="1*GPjaPKNNUYHU8EsA3Z0JGA.png" data-width="3212" data-height="750" data-lazy-src="https://storage.googleapis.com/blog-images-backup/1*GPjaPKNNUYHU8EsA3Z0JGA.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://storage.googleapis.com/blog-images-backup/1*GPjaPKNNUYHU8EsA3Z0JGA.png"/><noscript><img data-lazy-fallback="1" decoding="async" class="graf-image" src="../Images/94b3e0f84b30cb0d321f60471481ab64.png" data-image-id="1*GPjaPKNNUYHU8EsA3Z0JGA.png" data-width="3212" data-height="750" data-original-src="https://storage.googleapis.com/blog-images-backup/1*GPjaPKNNUYHU8EsA3Z0JGA.png"/></noscript></a></figure>
</div>
<div class="section-inner sectionLayout--insetColumn">
<h3 class="graf graf--h3">饼干</h3>
<p class="graf graf--p">正如我在介绍中提到的，我在本系列中的第一篇文章谈到了几个cookie指令——即<code>HTTPOnly </code>和<code>Secure </code>。众所周知，cookies是我们web应用程序的一个重要特性，它携带的数据主要涉及我们的用户会话。虽然简单地执行上述指令就足以保护您的cookie，并防止攻击，但我们实际上可以将cookie的安全性提高一步。</p>
<p class="graf graf--p"><em class="markup--em markup--p-em"> Cookie前缀</em>是一种相对未被充分利用的技术，我们可以利用它来确保cookie <em class="markup--em markup--p-em">是</em>安全的:</p>
<p class="graf graf--p"><strong class="markup--strong markup--p-strong"><em class="markup--em markup--p-em"/></strong><code><strong class="markup--strong markup--p-strong"><em class="markup--em markup--p-em">__Secure </em></strong></code><strong class="markup--strong markup--p-strong"><em class="markup--em markup--p-em">前缀</em></strong>–如果cookie的名称以“__Secure”开头，则cookie必须是:</p>
<ul class="postList">
<li class="graf graf--li">设置一个“<em class="markup--em markup--li-em">安全</em>属性</li>
<li class="graf graf--li">从其方案被用户<br/>代理视为安全的URL设置</li>
</ul>
<p class="graf graf--p">当从任何来源设置时，下列cookie将被拒绝，因为没有设置“安全”标志:</p>
<pre class="graf graf--pre"><code>Set-Cookie: __Secure-sess=12345; Domain=myapp.com</code></pre>
<p class="graf graf--p">如果从安全来源(如<code>https:// </code>)设置，则以下内容将被接受，否则将被拒绝:</p>
<pre class="graf graf--pre"><code>Set-Cookie: __Secure-sess=12345; Secure; Domain=myapp.com</code></pre>
<p class="graf graf--p">除了<code>__Secure </code>前缀，我们还有<code>__Host </code>前缀:</p>
<p class="graf graf--p"><strong class="markup--strong markup--p-strong"><em class="markup--em markup--p-em"/></strong><code><strong class="markup--strong markup--p-strong"><em class="markup--em markup--p-em">__Host </em></strong></code><strong class="markup--strong markup--p-strong"><em class="markup--em markup--p-em">前缀</em></strong>–如果cookie的名称以“__Host”开头，则cookie必须是:</p>
<ul class="postList">
<li class="graf graf--li">用“安全”属性设置</li>
<li class="graf graf--li">从URI设置，其“方案”被用户代理认为是“安全的”</li>
<li class="graf graf--li">仅发送给设置cookie的主机。也就是说，从“https://example.com”<em class="markup--em markup--li-em">设置的名为“__Host-cookie1”的cookie不能包含“域”属性(因此将只发送到“example . com”，而不是“subdomain.example.com”)</em></li>
<li class="graf graf--li">发送给每个主机请求。也就是说，名为“__Host-cookie1”的cookie必须包含一个值为“/”的“Path”属性</li>
</ul>
<p class="graf graf--p">以下cookies将始终被拒绝:</p>
<pre class="graf graf--pre"><code class="markup--code markup--pre-code">Set-Cookie: __Host-sess=12345
Set-Cookie: __Host-sess=12345; Secure
Set-Cookie: __Host-sess=12345; Domain=example.com
Set-Cookie: __Host-sess=12345; Domain=example.com; Path=/
Set-Cookie: __Host-sess=12345; Secure; Domain=example.com; Path=/</code></pre>
<p class="graf graf--p">如果从安全来源(如<code><a href="https://" rel="nofollow">https:// </a></code>)设置，则以下内容将被接受，否则将被拒绝:</p>
<pre class="graf graf--pre"><code>Set-Cookie: __Host-sess=12345; Secure; Path=/</code></pre>
<p class="graf graf--p">通过设置这些前缀，任何兼容的浏览器都会强制使用它们。</p>
<p class="graf graf--p">现在，如果我们包括我的第一篇文章中的提示，以及上面的提示，我们可以使<strong class="markup--strong markup--p-strong"> <em class="markup--em markup--p-em">最安全的cookie成为可能的</em> </strong>:</p>
<pre class="graf graf--pre"><code>Set-Cookie: __Host-sess=id123; path=/; Secure; HttpOnly; SameSite</code></pre>
<p class="graf graf--p">在这个最安全的cookie中，我们使用了<code>__Host</code>前缀，这意味着必须设置<code>Secure</code>属性，并且必须由安全主机提供服务。没有设置<code>Domain</code>属性，并且<code>Path</code>是<code>/</code>。我们设置了<code>HttpOnly</code>用于XSS保护，并启用<em class="markup--em markup--p-em">同一个站点</em>来防止CSRF。当然，对于很多人来说，这不会是最好或最实用的解决方案，但理论上来说，它是我们可以从web应用程序设置的最安全的cookie。</p><div class="code-block code-block-2">
<div class="blog-plug base-cta"><h2>使用<a class="signup" href="https://lp.logrocket.com/blg/signup" target="_blank" rel="noopener noreferrer"> LogRocket </a>消除传统错误报告的干扰</h2>
<a href="https://lp.logrocket.com/blg/signup" class="signup" target="_blank" rel="noopener noreferrer"><img class="alignnone size-full wp-image-46 jetpack-lazy-image" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/><noscript><img data-lazy-fallback="1" class="alignnone size-full wp-image-46" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/></noscript></a>
<p><a href="https://lp.logrocket.com/blg/signup" target="_blank" rel="noopener noreferrer"> LogRocket </a>是一个数字体验分析解决方案，它可以保护您免受数百个假阳性错误警报的影响，只针对几个真正重要的项目。LogRocket会告诉您应用程序中实际影响用户的最具影响力的bug和UX问题。</p>
<p>然后，使用具有深层技术遥测的会话重放来确切地查看用户看到了什么以及是什么导致了问题，就像你在他们身后看一样。</p>
<p>LogRocket自动聚合客户端错误、JS异常、前端性能指标和用户交互。然后LogRocket使用机器学习来告诉你哪些问题正在影响大多数用户，并提供你需要修复它的上下文。</p>
<p>关注重要的bug—<a class="signup" href="https://lp.logrocket.com/blg/signup-issue-free" target="_blank" rel="noopener noreferrer">今天就试试LogRocket】。</a></p></div></div>
</div>
</div>
</div>    
</body>
</html>
<html>
<head>
<title>The dialog element: The way to create tomorrow’s modal windows - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>对话框元素:创建未来模态窗口的方法</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/the-dialog-element-the-way-to-create-tomorrows-modal-windows-f1d4ab14380b/#0001-01-01">https://blog.logrocket.com/the-dialog-element-the-way-to-create-tomorrows-modal-windows-f1d4ab14380b/#0001-01-01</a></blockquote><div><article class="article-post">
<h3>概观</h3>
<p>对话框是一种常见的用户界面设计模式，在网站上反复出现——如此频繁，以至于W3C提出了一些标准化的HTML标记来描述对话框窗口。</p>
<p>用其他HTML标记和CSS创建的传统对话框已经在大多数前端框架中实现了很长一段时间，这可能仍然是一条路要走，因为HTML对话框元素仍然具有有限的浏览器支持。</p>
<p>但是如果前端框架仍然是更好的选择，为什么还要创建标准化的对话框元素呢？</p>
<p>有很多原因，但其中最主要的是屏幕阅读器的可访问性，以及使搜索引擎爬虫和机器学习代理能够解释对话窗口。随着浏览器支持的不断改进，这个标准将成为创建模式窗口的明确选择。</p>
<p>首先，我们将关注对话框元素的HTML标记，然后我们将在后面添加一些JavaScript。</p>
<p>文件夹结构可能如下所示:</p>
<p><strong> <em>项目<br/>|—</em></strong><em>index.html<br/></em><strong><em>|—</em></strong><em>app . js<br/></em><strong><em>|—</em><em>main . CSS</em></strong></p>
<figure><a href="https://logrocket.com/signup/" target="_blank" rel="noopener noreferrer"><img decoding="async" src="../Images/e18e0769df17c13e116ad4fd8dfd8166.png" data-height="560" data-width="2400" data-lazy-src="https://storage.googleapis.com/blog-images-backup/1*wV7zU6J05BL3bphzMlB2rA.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" class=" jetpack-lazy-image" data-original-src="https://storage.googleapis.com/blog-images-backup/1*wV7zU6J05BL3bphzMlB2rA.png"/><noscript><img data-lazy-fallback="1" decoding="async" src="../Images/e18e0769df17c13e116ad4fd8dfd8166.png" data-height="560" data-width="2400" data-original-src="https://storage.googleapis.com/blog-images-backup/1*wV7zU6J05BL3bphzMlB2rA.png"/></noscript></a></figure>
<h3>我们对话窗口背后的HTML</h3>
<p>在<em>index.html</em>文件中，让我们创建带有开始和结束标签的对话框元素:</p>
<figure class="wp-caption">
<pre><code>&lt;!doctype html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;title&gt;HTML Dialog Element&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;dialog&gt;
    &lt;/dialog&gt;
  &lt;/body&gt;
  <a href="http://app.js">http://app.js</a>
&lt;/html&gt;</code></pre><figcaption class="wp-caption-text">Creating a <strong>&lt;dialog&gt;</strong> element.</figcaption></figure>
<p>然而，这还不会在页面上显示任何内容。为了让它出现，我们需要将布尔属性<strong> open </strong>添加到对话框元素:</p>
<figure class="wp-caption">
<pre><code>&lt;!doctype html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;title&gt;HTML Dialog Element&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;dialog open&gt;
    &lt;/dialog&gt;
  &lt;/body&gt;
  <a href="http://app.js">http://app.js</a>
&lt;/html&gt;
</code></pre><figcaption class="wp-caption-text">Adding boolean attribute <strong>open </strong>to the <strong>&lt;dialog&gt; </strong>element to make it appear on the page.</figcaption></figure>
<p>在对话框元素中，我们将创建一个简单的表单，包含类型为<code>text</code>的文本输入和类型为<code>submit</code>的按钮:</p>
<figure>
<pre><code>&lt;!doctype html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;title&gt;HTML Dialog Element&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;dialog open&gt;
      &lt;form method="dialog"&gt;
        &lt;input type="text"&gt;
        &lt;button type="submit"&gt;SUBMIT&lt;/button&gt;
      &lt;/form&gt;
    &lt;/dialog&gt;
  &lt;/body&gt;
  <a href="http://app.js">http://app.js</a>
&lt;/html&gt;
</code></pre>
</figure>
<blockquote><p><strong>注意:</strong>这里我设置了一个<strong>窗体</strong>到<strong>对话框</strong>的<strong>方法</strong>。这是一个新的表单方法，它与父对话框元素协同工作。当按下提交按钮时，<strong>将提交</strong>表格，<strong>关闭</strong>对话框<strong/>。</p></blockquote>
<figure class="wp-caption"><img decoding="async" src="../Images/b8e2940714dd92850ff538b1542b2381.png" data-height="540" data-width="960" data-lazy-src="https://storage.googleapis.com/blog-images-backup/0*ilyONnjoBVqvV9iP?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" class=" jetpack-lazy-image" data-original-src="https://storage.googleapis.com/blog-images-backup/0*ilyONnjoBVqvV9iP"/><noscript><img data-lazy-fallback="1" decoding="async" src="../Images/b8e2940714dd92850ff538b1542b2381.png" data-height="540" data-width="960" data-original-src="https://storage.googleapis.com/blog-images-backup/0*ilyONnjoBVqvV9iP"/></noscript><figcaption class="wp-caption-text">Dialog window disappearing after pressing the submit button.</figcaption></figure>
<p>现在我们将创建一些按钮，允许我们使对话框窗口重新出现。这些将需要JavaScript来工作，我们将在后面添加。</p>
<figure class="wp-caption">
<pre><code>&lt;!doctype html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;title&gt;HTML Dialog Element&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;dialog open&gt;
      &lt;form method="dialog"&gt;
        &lt;input type="text"&gt;
        &lt;button type="submit"&gt;OK&lt;/button&gt;
      &lt;/form&gt;
    &lt;/dialog&gt;
    
    &lt;button id="openDialog"&gt;Dialog&lt;/button&gt;
    &lt;button id="openModalDialog"&gt;Modal Dialog&lt;/button&gt;
  &lt;/body&gt;
  <a href="http://app.js">http://app.js</a>
&lt;/html&gt;
</code></pre><figcaption class="wp-caption-text">Added two buttons with the <strong>IDs</strong> <strong>“openDialog”</strong> and <strong>“openModalDialog”</strong>.</figcaption></figure>
<p>因此，这里我们创建了两个按钮:一个ID为<code>openDialog</code>，另一个ID为<code>openModalDialog</code>。一旦我们添加了一些JavaScript，第一个按钮将打开对话框，就像我们上面看到的一样。但是，第二个按钮将打开一个对话框窗口，阻止其他页面交互。</p>
<p>这是一种常见的设计模式，因为当对话框窗口打开时，您通常需要用户在继续使用应用程序的其余部分之前执行某种交互。</p>
<p>为了编写JavaScript，我将从对话框元素中移除<strong>打开属性</strong>，然后添加一个<strong> ID属性</strong>，这样我们就可以用JavaScript选择它，就像按钮一样。</p>
<figure class="wp-caption">
<pre><code>&lt;!doctype html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;title&gt;HTML Dialog Element&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;dialog id="dialogWindow"&gt;
      &lt;form method="dialog"&gt;
        &lt;input type="text"&gt;
        &lt;button type="submit"&gt;OK&lt;/button&gt;
      &lt;/form&gt;
    &lt;/dialog&gt;
    
    &lt;button id="openDialog"&gt;Open Dialog&lt;/button&gt;
    &lt;button id="openModalDialog"&gt;Open Modal Dialog&lt;/button&gt;
  &lt;/body&gt;
  <a href="http://app.js">http://app.js</a>
&lt;/html&gt;
</code></pre><figcaption class="wp-caption-text">Replaced <strong>open</strong> attribute of <strong>&lt;dialog&gt;</strong> element with the ID of name <strong>“dialogWindow”</strong>.</figcaption></figure>
<h3>我们的对话窗口的JavaScript</h3>
<p>在JavaScript ( <em> app.js </em>)文件中，我们将在一个匿名函数中编写基于事件的代码，该代码将在页面加载时执行。</p>
<p>首先，我们将收集页面上的元素，以及变量——<strong>对话窗口</strong>和<strong>两个按钮</strong>。我们将为每个对象创建一个变量，并通过它们的ID获取它们。</p>
<figure class="wp-caption">
<pre><code>(function() {
   
  let openDialog = document.getElementById('openDialog');
  let openModalDialog = document.getElementById('openModalDialog');
  let dialogWindow = document.getElementById('dialogWindow');
  
})();

</code></pre><figcaption class="wp-caption-text">Getting the two buttons and dialog window by their IDs.</figcaption></figure>
<p>接下来，我们将创建两个事件侦听器，每个按钮一个。</p>
<h4>1.用于正常打开对话窗口的EventListener</h4>
<p>我们将添加一个<code>EventListener</code>到<code>openDialog</code>按钮，这样当它被点击时，功能<code>show()</code>将被执行。<code>show()</code>函数在页面上显示对话框元素的方式与我们之前在HTML中使用<strong>打开属性</strong>时的方式相同。</p>
<figure class="wp-caption">
<pre><code>(function() {
   
  let openDialog = document.getElementById('openDialog');
  let openModalDialog = document.getElementById('openModalDialog');
  let dialogWindow = document.getElementById('dialogWindow');
  
  openDialog.addEventListener('click', () =&gt; {
    dialogWindow.show();
  })
   
})();

</code></pre><figcaption class="wp-caption-text">EventListener for opening the dialog window normally.</figcaption></figure>
<figure class="wp-caption"><img decoding="async" src="../Images/fdf1685b2d02d096e24d7dd0b9ae9426.png" data-height="540" data-width="960" data-lazy-src="https://storage.googleapis.com/blog-images-backup/0*iDxI67SdJFan0KqS?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" class=" jetpack-lazy-image" data-original-src="https://storage.googleapis.com/blog-images-backup/0*iDxI67SdJFan0KqS"/><noscript><img data-lazy-fallback="1" decoding="async" src="../Images/fdf1685b2d02d096e24d7dd0b9ae9426.png" data-height="540" data-width="960" data-original-src="https://storage.googleapis.com/blog-images-backup/0*iDxI67SdJFan0KqS"/></noscript><figcaption class="wp-caption-text">EventListener for opening the dialog window normally.</figcaption></figure>
<blockquote><p><strong>注意:</strong>我已经设计了按钮的样式，这样它们就可以在上面的GIF上看到，但这不会以任何方式影响功能。</p></blockquote>
<h4>2.用于将对话框窗口作为模式窗口打开的EventListener</h4>
<p>我们将为打开的模态窗口对话框做和上面一样的事情:添加一个<code>EventListener</code>到<code>openModalDialog</code>按钮，这样当它被点击时，函数<code>showModal()</code>将被执行。</p>
<p>所以在这里，我们使用的不是<code>show()</code>函数，而是<code>showModal()</code>函数，它仍然会显示对话窗口。但这一次，页面的其余部分将有一个灰色的透明覆盖层，将阻止任何其他鼠标点击。</p>
<figure class="wp-caption">
<pre><code>(function() {
   
  let openDialog = document.getElementById('openDialog');
  let openModalDialog = document.getElementById('openModalDialog');
  let dialogWindow = document.getElementById('dialogWindow');
  
  openDialog.addEventListener('click', () =&gt; {
    dialogWindow.show();
  })

  openModalDialog.addEventListener('click', () =&gt; {
    dialogWindow.showModal();
  })
})();

</code></pre><figcaption class="wp-caption-text">EventListener for opening the dialog window as a modal window.</figcaption></figure>
<figure class="wp-caption"><img decoding="async" src="../Images/f3a17e50afb398b194878bd09125d944.png" data-height="540" data-width="960" data-lazy-src="https://storage.googleapis.com/blog-images-backup/0*fr9OZ6qH79posWYp?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" class=" jetpack-lazy-image" data-original-src="https://storage.googleapis.com/blog-images-backup/0*fr9OZ6qH79posWYp"/><noscript><img data-lazy-fallback="1" decoding="async" src="../Images/f3a17e50afb398b194878bd09125d944.png" data-height="540" data-width="960" data-original-src="https://storage.googleapis.com/blog-images-backup/0*fr9OZ6qH79posWYp"/></noscript><figcaption class="wp-caption-text">Dialog window as a modal window.</figcaption></figure>
<h3>浏览器支持和聚合填充</h3>
<p>聚合填充是一段代码，它实现了特定web浏览器本身不支持的功能。通常，他们首先检查浏览器是否支持API，如果可用就使用它；否则，他们实现自己的逻辑，使其在浏览器上工作。</p>
<p>目前，只有Chrome和Opera完全支持HTML对话框元素，为了在Firefox中使用它，用户必须<strong>显式启用</strong>该功能。</p>
<p>但是我们仍然可以在其他浏览器(Safari，IE等)中使用HTML对话框元素。)使用由谷歌Chrome维护的dialog-polyfill。polyfill将增加对不支持的浏览器的支持；还支持IE9及以上版本。</p><div class="code-block code-block-54">
<hr/>
<h3>更多来自LogRocket的精彩文章:</h3>

<hr/></div>
<p>有几点需要注意:在我们的JavaScript ( <em> app.js </em>)文件中添加polyfill不会以任何方式影响Chrome和Opera上的HTML对话框元素。只会有一个<em> app.js </em>文件。</p>
<p>此外，如果我们只想在Chrome或Opera上使用HTML对话框元素，我们就不需要polyfill。但是如果我们想在所有的浏览器上使用它——很可能是这种情况——我们将不得不使用polyfill，直到其他浏览器完全支持它。</p>
<p>更新后的文件夹结构可能如下所示:</p>
<p><strong> <em>项目<br/>|—</em></strong><em>index.html<br/></em><strong><em>|—</em></strong><em>app . js<br/></em><strong><em>|—</em><em>main . CSS<br/></em><strong><em>|—</em></strong><em>对话框-poly fill . CSS<br/></em><strong><em>|—</em></strong></strong></p>
<h4>使用聚合填料</h4>
<ol>
<li>将CSS <code><a href="https://github.com/GoogleChrome/dialog-polyfill/blob/master/dist/dialog-polyfill.css" target="_blank" rel="noopener noreferrer">dialog-polyfill.css</a></code>包含在文档的头部。</li></ol>
<figure class="wp-caption">

<pre><code>&lt;!doctype html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;title&gt;HTML Dialog Element&lt;/title&gt;
    &lt;link rel="stylesheet" href="dialog-polyfill.css"&gt;
    &lt;link rel="stylesheet" href="main.css"&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;dialog id="dialogWindow"&gt;
      &lt;form method="dialog"&gt;
        &lt;input type="text"&gt;
        &lt;button type="submit"&gt;OK&lt;/button&gt;
      &lt;/form&gt;
    &lt;/dialog&gt;

    &lt;button id="openDialog" class="button"&gt;Open Dialog&lt;/button&gt;
    &lt;button id="openModalDialog" class="button"&gt;Open Modal Dialog&lt;/button&gt;
  &lt;/body&gt;
  <a href="http://app.js">http://app.js</a>
&lt;/html&gt;
</code></pre><figcaption class="wp-caption-text">Included<strong> dialog-polyfill.css</strong>.</figcaption></figure>
<p>2.在引用<code>dialogPolyfill</code>之前，在任何地方包含JavaScript <code><a href="https://github.com/GoogleChrome/dialog-polyfill/blob/master/dist/dialog-polyfill.js" target="_blank" rel="noopener noreferrer">dialog-polyfill.js</a></code>。</p>
<figure class="wp-caption">
<pre><code>&lt;!doctype html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;title&gt;HTML Dialog Element&lt;/title&gt;
    &lt;link rel="stylesheet" href="dialog-polyfill.css"&gt;
    &lt;link rel="stylesheet" href="main.css"&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;dialog id="dialogWindow"&gt;
      &lt;form method="dialog"&gt;
        &lt;input type="text"&gt;
        &lt;button type="submit"&gt;OK&lt;/button&gt;
      &lt;/form&gt;
    &lt;/dialog&gt;

    &lt;button id="openDialog" class="button"&gt;Open Dialog&lt;/button&gt;
    &lt;button id="openModalDialog" class="button"&gt;Open Modal Dialog&lt;/button&gt;
  &lt;/body&gt;
  <a href="http://dialog-polyfill.js">http://dialog-polyfill.js</a>
  <a href="http://app.js">http://app.js</a>
&lt;/html&gt;
</code></pre><figcaption class="wp-caption-text">Included<strong> dialog-polyfill.js</strong></figcaption></figure>
<p>3.在HTML文档中创建<code>&lt;dialog&gt;</code>元素(上面我们已经创建了一个)。</p>
<ol>
<li>使用<code>dialogPolyfill.registerDialog()</code>函数注册元素，一次传递一个节点。<br/> <figure class="wp-caption"/></li>
</ol>
<pre><code>(function() {

    let openDialog = document.getElementById('openDialog');
    let openModalDialog = document.getElementById('openModalDialog');
    let dialogWindow = document.getElementById('dialogWindow');

    dialogPolyfill.registerDialog(dialogWindow);

    openDialog.addEventListener('click', () =&gt; {
      dialogWindow.show();
    })

    openModalDialog.addEventListener('click', () =&gt; {
      dialogWindow.showModal();
    })
  })();
</code></pre><figcaption class="wp-caption-text">Registered dialog polyfill using <strong>dialogPolyfill.registerDialog()</strong> function in app.js.</figcaption>
<p>5.使用你的<code>&lt;dialog&gt;</code>元素。</p>
<figure><img decoding="async" src="../Images/cecaee1b8e1452d4a85622bfb39a8aa6.png" data-height="540" data-width="960" data-lazy-src="https://storage.googleapis.com/blog-images-backup/0*sRd_XIbZO7hTBfZF?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" class=" jetpack-lazy-image" data-original-src="https://storage.googleapis.com/blog-images-backup/0*sRd_XIbZO7hTBfZF"/><noscript><img data-lazy-fallback="1" decoding="async" src="../Images/cecaee1b8e1452d4a85622bfb39a8aa6.png" data-height="540" data-width="960" data-original-src="https://storage.googleapis.com/blog-images-backup/0*sRd_XIbZO7hTBfZF"/></noscript></figure>
<figure class="wp-caption"><img decoding="async" src="../Images/477ad0f97150cb86088f592d3b94d3f5.png" data-height="540" data-width="960" data-lazy-src="https://storage.googleapis.com/blog-images-backup/0*lOJ6AKXKWEnln7nb?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" class=" jetpack-lazy-image" data-original-src="https://storage.googleapis.com/blog-images-backup/0*lOJ6AKXKWEnln7nb"/><noscript><img data-lazy-fallback="1" decoding="async" src="../Images/477ad0f97150cb86088f592d3b94d3f5.png" data-height="540" data-width="960" data-original-src="https://storage.googleapis.com/blog-images-backup/0*lOJ6AKXKWEnln7nb"/></noscript><figcaption class="wp-caption-text">Safari browser <strong>before adding polyfill</strong> (left) vs. <strong>after adding polyfill </strong>(right).</figcaption></figure>
<p>现在我们已经介绍了HTML中对话框元素的基本要素。如果你有兴趣了解更多，可以考虑阅读来自<a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/dialog" target="_blank" rel="noopener noreferrer"> Mozilla </a>和<a href="https://caniuse.com/#feat=dialog" target="_blank" rel="noopener noreferrer">我可以使用……</a>以及<a href="https://html.spec.whatwg.org/multipage/interactive-elements.html#the-dialog-element" target="_blank" rel="noopener noreferrer">官方规范</a>的资源。</p>
<p>我希望这篇文章对你有所帮助。我希望听到您的反馈！</p>
<p><strong>感谢您的阅读！</strong></p><div class="code-block code-block-2">
<div class="blog-plug base-cta"><h2>使用<a class="signup" href="https://lp.logrocket.com/blg/signup" target="_blank" rel="noopener noreferrer"> LogRocket </a>消除传统错误报告的干扰</h2>
<a href="https://lp.logrocket.com/blg/signup" class="signup" target="_blank" rel="noopener noreferrer"><img class="alignnone size-full wp-image-46 jetpack-lazy-image" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/><noscript><img data-lazy-fallback="1" class="alignnone size-full wp-image-46" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/></noscript></a>
<p><a href="https://lp.logrocket.com/blg/signup" target="_blank" rel="noopener noreferrer"> LogRocket </a>是一个数字体验分析解决方案，它可以保护您免受数百个假阳性错误警报的影响，只针对几个真正重要的项目。LogRocket会告诉您应用程序中实际影响用户的最具影响力的bug和UX问题。</p>
<p>然后，使用具有深层技术遥测的会话重放来确切地查看用户看到了什么以及是什么导致了问题，就像你在他们身后看一样。</p>
<p>LogRocket自动聚合客户端错误、JS异常、前端性能指标和用户交互。然后LogRocket使用机器学习来告诉你哪些问题正在影响大多数用户，并提供你需要修复它的上下文。</p>
<p>关注重要的bug—<a class="signup" href="https://lp.logrocket.com/blg/signup-issue-free" target="_blank" rel="noopener noreferrer">今天就试试LogRocket】。</a></p></div></div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
<html>
<head>
<title>Popular React Hook libraries - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>流行的React钩子库</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/popular-react-hook-libraries/#0001-01-01">https://blog.logrocket.com/popular-react-hook-libraries/#0001-01-01</a></blockquote><div><article class="article-post">
<p>React生态系统的旅程真的很有趣。自从React 16.3 中的<a href="https://reactjs.org/blog/2018/03/01/sneak-peek-beyond-react-16.html" target="_blank" rel="noopener noreferrer">时间切片和悬念等功能出现以来，我们已经有了一系列来自牛逼的React团队的有趣概念，但没有一个像React Hooks那样引人注目，React Hooks在</a><a href="https://reactjs.org/blog/2019/02/06/react-v16.8.0.html" target="_blank" rel="noopener noreferrer"> React 16.8 </a>中首次稳定发布。</p>
<p>提供一种更简洁的方式来编写代码，同时不必担心向后兼容性问题，这意味着可以肯定地说，钩子将会继续存在。在这篇博文中，我将描述钩子是如何成为救生员的。我将举例说明几个用例，这些用例以流行的React Hook库为特色——包括主流的和定制的(由像你我这样的爱好者创建的)。让我们开始吧。</p>
<h2>什么是React钩子？</h2>
<p>基本上，钩子提供了传递状态和属性的媒介，而不必创建类组件。采用基于功能的方法，通过钩子，我们可以将逻辑从UI中分离出来，这样它也可以在应用程序的其他部分重用。看看下面的两个代码示例:</p>
<pre>import React, { Component } from "react";
class MovieButton extends Component {
  constructor() {
    super();
    this.state = { buttonText: "Click to purchase movie tickets" };
    this.handleClick = this.handleClick.bind(this);
  }
  handleClick() {
    this.setState(() =&gt; {
      return { buttonText: "Enjoy your movie!" };
    });
  }
  render() {
    const { buttonText } = this.state;
    return &lt;button onClick={this.handleClick}&gt;{buttonText}&lt;/button&gt;;
  }
}
export default MovieButton</pre>
<p>上面的要点显示了当点击按钮时，<code>setState</code>如何改变<code>MovieButton</code>的内部状态。使用钩子，可以描述这种内部状态变化，而不必依赖于类、构造函数或setState:</p>
<pre>import React, { useState } from "react";
export default function MovieButton() {
  const [buttonText, setButtonText] = useState("Click to purchase movie tickets");
  function handleClick() {
    return setButtonText("Enjoy your movie!");
  }
  return &lt;button onClick={handleClick}&gt;{buttonText}&lt;/button&gt;;
}</pre>
<p>我选择先展示<code>useState</code>，因为它是引入React生态系统的第一个<a href="https://reactjs.org/docs/hooks-intro.html" target="_blank" rel="noopener noreferrer">。<code>useState</code>用于管理组件的本地状态，并在重新渲染之间保存它。令人着迷的是，该组件不必是ES6类组件——一个基本的JavaScript函数就可以了，我们完成了同样的事情，同时减少了十行代码。通过包含一对变量来实现<code>useState</code>——一个表示组件的实际开始状态，另一个表示您希望组件的状态更新到什么状态。</a></p>
<h2>主流的React钩子库</h2>
<h3>状态和数据提取</h3>
<p>假设我想只用钩子创建一个应用程序。最有可能的是，我必须在某个时候获取数据。一个好的方法是从需要定义状态的地方开始定义状态。首先，我将创建一个组件，并从API中获取数据，由该组件呈现:</p>
<pre>import React, { useState, useEffect } from "react";

const URL = "https://api.punkapi.com/v2/beers";
export default function Landing() {
  const [beer, setBeer] = useState([]);
  useEffect(() =&gt; {
    fetch(URL)
      .then(response =&gt; response.json())
      .then(beer =&gt; setBeer(beer));
  });
}</pre>
<p>这就把我们带到了<code>useEffect</code>钩。<code>useEffect</code>钩子允许您直接在功能组件内部处理生命周期事件。像设置订阅和获取数据这样的活动，我们可以使用生命周期方法如<code>componentDidMount()</code>来完成，现在可以通过<code>useEffect</code>来处理。根据<a href="https://reactjs.org/docs/hooks-effect.html" target="_blank" rel="noopener noreferrer"> React的文档</a>:</p>
<blockquote><p>useEffect与React类生命周期方法中的componentDidMount、componentDidUpdate和componentWillUnmount的作用相同，但是统一到一个API中</p></blockquote>
<p>所以在上面的例子中，我没有使用类组件，而是创建了一个函数，并在<code>useEffect</code>中调用了<code>fetch</code>方法。这里也不需要使用<code>this.setState</code>来更新状态，因为我创建了<code>setBeer</code>，一个从<code>useState</code>钩子中提取的随机函数。</p>
<p>如果您一直遵循这一点，并尝试使用上面的代码示例运行应用程序，您应该会遇到一个非常难看的无限循环:</p>
<p><span class="embed-youtube"> <iframe loading="lazy" class="youtube-player" src="https://www.youtube.com/embed/5w0snGY1w2Q?version=3&amp;rel=1&amp;showsearch=0&amp;showinfo=1&amp;iv_load_policy=1&amp;fs=1&amp;hl=en-US&amp;autohide=2&amp;wmode=transparent" allowfullscreen="true" sandbox="allow-scripts allow-same-origin allow-popups allow-presentation">视频</iframe> </span></p>
<p>为什么？<code>useEffect</code>的作用与<code>componentDidMount</code>、<code>componentDidUpdate</code>和<code>componentWillUnmount</code>相同。因为<code>setBeer()</code>在每次数据获取后更新<code>beer</code>的状态，所以组件被更新并且<code>useEffect</code>继续再次获取数据。</p>
<p>为了避免这个bug，我们需要通过提供一个空数组作为<code>useEffect</code>的第二个参数来指定我们只想在组件挂载时获取数据:</p>
<pre>import React, { useState, useEffect } from "react";

const URL = "https://api.punkapi.com/v2/beers";
export default function Landing() {
  const [beer, setBeer] = useState([]);
  useEffect(() =&gt; {
    fetch(URL)
      .then(response =&gt; response.json())
      .then(beer =&gt; setBeer(beer));
  }, {});
}</pre>
<h3>表单处理</h3>
<p>通过定制钩子(目前在生态系统中有大量的钩子)，React允许您重用和共享少量的逻辑。根据经验，当一个组件中有大量逻辑时，这是一个信号，表明您应该重构它并分发一些逻辑以避免组件膨胀。让我们依靠自定义挂钩来创建某种与我们的应用程序的交互性——比如一个用户可以提交数据的表单。react-hook-form 是一个完全用钩子构建的库，提供表单验证。我们会像安装npm包一样将它包含在我们的应用程序中:</p>
<pre>npm i react-hook-form
</pre>
<p>然后导入我们需要的自定义钩子——<code>useForm</code>:</p>
<pre>import React from "react";
import useForm from "react-hook-form";

const active = {
  fontSize: "15px"
};
export default function Purchase() {
  const { register, handleSubmit, errors } = useForm();
  const onSubmit = data =&gt; {  // upload the data retreived from the form to a database, return value to a user, etc
    console.log(data);
  };

  return (
    &lt;div&gt;
      &lt;form onSubmit={handleSubmit(onSubmit)}&gt;
        &lt;label&gt;Full Name&lt;/label&gt;
        &lt;input name="fullname" ref={register} /&gt;
        &lt;label&gt;Beer Name&lt;/label&gt;
        &lt;input
          name="beerName"
          ref={register({ required: true, maxLength: 10 })}
        /&gt;

        &lt;select style={active} name="Title" ref={register({ required: true })}&gt;
          &lt;option value=""&gt;Select...&lt;/option&gt;
          &lt;option value="six-pack"&gt;Six Pack&lt;/option&gt;
          &lt;option value="twelve-pack"&gt;Twelve Pack&lt;/option&gt;
        &lt;/select&gt;
        &lt;label&gt;
          &lt;input type="checkbox" placeholder="+18" name="+18" ref={register} /&gt;I
          am 18 and above
        &lt;/label&gt;
        {errors.beerType &amp;&amp; &lt;p&gt;This field is required&lt;/p&gt;}
        &lt;input type="submit" value="Pay Here" /&gt;
      &lt;/form&gt;
    &lt;/div&gt;
  );
}</pre>
<p>工作原理概述:</p>
<p><span class="embed-youtube"> <iframe loading="lazy" class="youtube-player" src="https://www.youtube.com/embed/ojVqNiAJdGM?version=3&amp;rel=1&amp;showsearch=0&amp;showinfo=1&amp;iv_load_policy=1&amp;fs=1&amp;hl=en-US&amp;autohide=2&amp;wmode=transparent" allowfullscreen="true" sandbox="allow-scripts allow-same-origin allow-popups allow-presentation">视频</iframe> </span></p>
<h2>按指定路线发送</h2>
<p>该应用程序正在逐步扩展，在这一点上，如果能包含每个具有多个组件的应用程序所需的内容(路线)就太好了。我们将利用<code><a href="https://www.npmjs.com/package/hookrouter" target="_blank" rel="noopener noreferrer">hooksrouter</a></code>——一个很棒的库，它导出一个定制的钩子<code>useRoutes</code>:</p>
<pre>npm i hookrouter</pre>
<p><code>useRoutes</code>评估预定义的路线对象，并在路线匹配时返回结果:</p>
<pre>import React from "react";
import Purchase from "./components/Purchase";
import Landing from "./components/Landing";
import HomePage from "./components/HomePage";
const Routes = {
  "/": () =&gt; ,
  "/purchase": () =&gt; ,
  "/landing": () =&gt; 
};

export default Routes;</pre>
<p>这减少了我们在使用传统react路由器时必须编写的过多代码，因为我们会在应用程序中为所有单独的路线渲染<code>&lt;Route/&gt;</code>组件，并在其中传递属性。现在，我们所要做的就是导入<code>Routes</code>组件并将其传递给<code>useRoutes</code>钩子:</p>
<pre>// index.js or where you choose to render your entire app from
import { useRoutes } from "hookrouter";
import Routes from "./router";

function App() {
  const routeResult = useRoutes(Routes);
  return &lt;div&gt;{routeResult}&lt;/div&gt;;
}</pre>
<p>让我们看看在应用程序中导航是什么感觉:</p>
<p><span class="embed-youtube"> <iframe loading="lazy" class="youtube-player" src="https://www.youtube.com/embed/0shA2ukTvsY?version=3&amp;rel=1&amp;showsearch=0&amp;showinfo=1&amp;iv_load_policy=1&amp;fs=1&amp;hl=en-US&amp;autohide=2&amp;wmode=transparent" allowfullscreen="true" sandbox="allow-scripts allow-same-origin allow-popups allow-presentation">视频</iframe> </span></p>
<h2>处理复杂的状态管理</h2>
<p>当然<code>useState</code>是用来管理状态的，但是如果你的应用程序变得越来越复杂，你必须在一个状态对象中处理多个状态转换，那该怎么办呢？这正是<code>useReducer</code>钩子的用处。当您必须处理多个对象或数组中的数据，并且还要保持这些数据的可维护性和可预测性时，<code>useReducer</code>是首选。为了描述这个<code>useReducer</code>钩子，我将在应用程序中添加一个具有多状态架构的页面——也许是一个用户可以创建自己的啤酒配方的地方:</p>
<pre>import React, { useReducer } from "react";

const myStyle = {
  color: "white",
  fontSize: "20px"
};

export default function Recipe() {
  const initialState = {
    RecipePrice: 0,
    recipe: {
      price: 100,
      name: "Oompa Loompa",
      image:
        "https://res.cloudinary.com/fullstackmafia/image/upload/v1568016744/20110111-132155-Homebrew-Grain_uihhas.jpg",
      ingredients: []
    },
    stockpile: [
      { id: "1", name: "Extra Pale Malt", price: 10 },
      { id: "2", name: "Ahtanum Hops", price: 6 },
      { id: "3", name: "Wyeast 1056", price: 8 },
      { id: "4", name: "Chinook", price: 5 }
    ]
  };
  const reducer = (state, action) =&gt; {
    switch (action.type) {
      case "REMOVE_ITEM":
        return {
          ...state,
          RecipePrice: state.RecipePrice - action.item.price,
          recipe: {
            ...state.recipe,
            ingredients: state.recipe.ingredients.filter(
              y =&gt; y.id !== action.item.id
            )
          },
          stockpile: [...state.stockpile, action.item]
        };
      case "ADD_ITEM":
        return {
          ...state,
          RecipePrice: state.RecipePrice + action.item.price,
          recipe: {
            ...state.recipe,
            ingredients: [...state.recipe.ingredients, action.item]
          },
          stockpile: state.stockpile.filter(x =&gt; x.id !== action.item.id)
        };
      default:
        return state;
    }
  };

  const [state, dispatch] = useReducer(reducer, initialState);

  const removeFeature = item =&gt; {
    dispatch({ type: "REMOVE_ITEM", item });
  };

  const addItem = item =&gt; {
    dispatch({ type: "ADD_ITEM", item });
  };

  return (
    &lt;div className="boxes" style={myStyle}&gt;
      &lt;div className="box"&gt;
    &lt;h4&gt;Ingredients Stockpile&lt;/h4&gt;
        &lt;figure&gt;
          &lt;img width={"300px"} src={state.recipe.image} alt="my recipe" /&gt;
        &lt;/figure&gt;
        &lt;h2&gt;{state.recipe.name}&lt;/h2&gt;
        &lt;pre&gt;Amount: ${state.recipe.price}&lt;/pre&gt;
        &lt;div className="content"&gt;
          &lt;h5&gt;Added ingredients:&lt;/h5&gt;
          {state.recipe.ingredients.length ? (
            &lt;ol type="1"&gt;
              {state.recipe.ingredients.map(item =&gt; (
                &lt;li key={item.id}&gt;
                  &lt;button
                    onClick={() =&gt; removeFeature(item)}
                    className="button"
                  &gt;
                    REMOVE FROM LIST
                  &lt;/button&gt;
                  {item.name}
                &lt;/li&gt;
              ))}
            &lt;/ol&gt;
          ) : (
            &lt;pre&gt;You can purchase items from the stockpile.&lt;/pre&gt;
          )}
        &lt;/div&gt;
      &lt;/div&gt;
      &lt;div className="box"&gt;
        &lt;div className="content"&gt;
          {state.stockpile.length ? (
            &lt;ol type="1"&gt;
              {state.stockpile.map(item =&gt; (
                &lt;li key={item.id}&gt;
                  &lt;button onClick={() =&gt; addItem(item)} className="button"&gt;
                    ADD TO LIST
                  &lt;/button&gt;
                  {item.name} (+{item.price})
                &lt;/li&gt;
              ))}
            &lt;/ol&gt;
          ) : (
            &lt;pre&gt;Nice looking recipe!&lt;/pre&gt;
          )}
        &lt;/div&gt;

        &lt;div className="content"&gt;
          &lt;h4&gt;Total Amount: ${state.recipe.price + state.RecipePrice}&lt;/h4&gt;
        &lt;/div&gt;
      &lt;/div&gt;
    &lt;/div&gt;
  );
}</pre>
<p>如果您熟悉Redux，您会在上面的代码示例中认出<code>line 54</code>，其中<code>useReducer</code>接受一个带有组件初始状态和动作的reducer通常是一个用于根据需要更新组件状态的调度方法。因此，使用reducers，我们可以将多个状态合并成一个状态，而不是创建一个以上的单个状态挂钩。让我们看看这个组件是如何工作的:</p>
<p><span class="embed-youtube"> <iframe loading="lazy" class="youtube-player" src="https://www.youtube.com/embed/yLiC3nEM7o0?version=3&amp;rel=1&amp;showsearch=0&amp;showinfo=1&amp;iv_load_policy=1&amp;fs=1&amp;hl=en-US&amp;autohide=2&amp;wmode=transparent" allowfullscreen="true" sandbox="allow-scripts allow-same-origin allow-popups allow-presentation">视频</iframe> </span></p>
<h2>挂钩收藏</h2>
<p>自从Hooks发布以来，React社区的热情令人惊叹。大量的定制钩子被创造出来，描绘出令人敬畏的功能。你一定要看看的自定义React钩子集合包括:</p>
<p><a href="https://github.com/nikgraf/react-hooks" target="_blank" rel="noopener noreferrer">React钩子集合</a>，包含300多个定制钩子——其中最受欢迎的是<code>useArray</code>——一个为数组操作提供多种方法的钩子，数组操作是开发人员的日常工作。让我们更新我们的应用程序，加入<code>useArray</code>钩子:</p>
<pre>import React from "react";
import { useArray } from "react-hanger";

const myStyle = {
  color: "white"
};
export default function App() {
  const todos = useArray(["35cl", "50cl", "60cl"]);
  return (
    &lt;div style={myStyle}&gt;
      &lt;h3&gt;Measures&lt;/h3&gt;
      &lt;button
        onClick={() =&gt;
          todos.add(Math.floor(Math.random() * (60 - 35 + 1)) + 35 + "cl")
        }
      &gt;
        CUSTOM
      &lt;/button&gt;

      &lt;ul&gt;
        {todos.value.map((todo, i) =&gt; (
          &lt;div&gt;
            &lt;li key={i}&gt;{todo}&lt;/li&gt;
            &lt;button onClick={() =&gt; todos.removeIndex(i)}&gt;
              Remove from list
            &lt;/button&gt;
          &lt;/div&gt;
        ))}
      &lt;/ul&gt;
      &lt;button onClick={todos.clear}&gt;clear&lt;/button&gt;
    &lt;/div&gt;
  );
}</pre>
<p>让我们看看它是如何工作的:</p>
<p><span class="embed-youtube"> <iframe loading="lazy" class="youtube-player" src="https://www.youtube.com/embed/dN3BSnw8NgU?version=3&amp;rel=1&amp;showsearch=0&amp;showinfo=1&amp;iv_load_policy=1&amp;fs=1&amp;hl=en-US&amp;autohide=2&amp;wmode=transparent" allowfullscreen="true" sandbox="allow-scripts allow-same-origin allow-popups allow-presentation">视频</iframe> </span></p>
<p>我真正感兴趣的另一个集合是<code><a href="https://github.com/gragland/usehooks" target="_blank" rel="noopener noreferrer">useHooks</a></code>，它包含了<code>useLockBodyScroll</code>，一个阻止用户滚动特定组件的钩子。我观察到这个钩子与React内置的<code>useLayoutEffect</code>钩子一起工作——它从DOM读取布局并同步重新渲染。要实现<code>useLockBodyScroll</code>，首先需要将其定义为一个函数:</p>
<pre>import { useLayoutEffect } from "react";

export default function useLockBodyScroll() {
  useLayoutEffect(() =&gt; {
    // Get original value of body overflow
    const originalStyle = window.getComputedStyle(document.body).overflow;
    // Prevent scrolling on mount
    document.body.style.overflow = "hidden";
    // Re-enable scrolling when component unmounts
    return () =&gt; (document.body.style.overflow = originalStyle);
  }, []); // Empty array ensures effect is only run on mount and unmount
}</pre>
<p>然后将其导入到所需的组件中:</p>
<pre>import useLockBodyScroll from "./useLockBodyScroll";

export default function Landing() {
    useLockBodyScroll();
    const [data, setData] = useState([]);
    useEffect(() =&gt; {
        fetch(URL)
            .then(response =&gt; response.json())
            .then(data =&gt; setData(data));
    }, []);
    return ( &lt;
        div &gt;
        &lt;
        button &gt;
        &lt;
        A style = {
            {
                textDecoration: "none"
            }
        }
        href = "/" &gt;
        HOME &lt;
        /A&gt;{" "} &lt;
        br / &gt;
        &lt;
        /button&gt; {
            data.map(item =&gt; ( &lt;
                Item.Group key = {
                    item.id
                }
                style = {
                    divStyle
                } &gt;
                &lt;
                Item &gt;
                &lt;
                Item.Image width = "80"
                size = "tiny"
                src = {
                    item.image_url
                }
                alt = "Beer Flask" /
                &gt;
                &lt;
                Item.Content &gt;
                &lt;
                Item.Header &gt; {
                    item.name
                } &lt; /Item.Header&gt; &lt;
                Item.Extra &gt; {
                    item.tagline
                } &lt; /Item.Extra&gt; &lt;
                Item.Meta style = {
                    {
                        lineHeight: 1.5
                    }
                } &gt; {
                    item.description
                } &lt;
                /Item.Meta&gt; &lt;
                /Item.Content&gt; &lt;
                /Item&gt; &lt;
                /Item.Group&gt;
            ))
        } &lt;
        /div&gt;
    );
}</pre>
<p>让我们看看它是如何工作的。浏览器中应该没有滚动条:</p>
<p><span class="embed-youtube"> <iframe loading="lazy" class="youtube-player" src="https://www.youtube.com/embed/-0SG_EYI-0g?version=3&amp;rel=1&amp;showsearch=0&amp;showinfo=1&amp;iv_load_policy=1&amp;fs=1&amp;hl=en-US&amp;autohide=2&amp;wmode=transparent" allowfullscreen="true" sandbox="allow-scripts allow-same-origin allow-popups allow-presentation">视频</iframe> </span></p>
<p>现在，我们的应用程序已经完成了。我是不是忘了一件你觉得超级重要的事？欢迎您改进CodeSandbox中的演示。</p>
<p>摘要</p>
<h2>我认为勾手是很长一段时间内最伟大的反应。尽管到目前为止已经取得了很大成就，但我们还有很多事情要做。在React爱好者中，某些论坛一直在争论React提供创建定制钩子的工具会导致生态系统中钩子的过载——类似于jQuery插件发生的情况。你对钩子有什么看法？你最近发现了哪些很棒的钩子？请在下面的评论中告诉我。干杯。</h2>
<p> </p>
<p> </p>
<p><a href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener"> LogRocket </a>:全面了解您的生产React应用</p><div class="code-block code-block-17">
<div class="blog-plug inline-plug react-plug" vwo-el-id="26283398190">
<h2 vwo-el-id="41600691720">调试React应用程序可能很困难，尤其是当用户遇到难以重现的问题时。如果您对监视和跟踪Redux状态、自动显示JavaScript错误以及跟踪缓慢的网络请求和组件加载时间感兴趣，</h2><p>. </p><a href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" vwo-el-id="19356441070">try LogRocket</a><p>LogRocket 结合了会话回放、产品分析和错误跟踪，使软件团队能够创建理想的web和移动产品体验。这对你来说意味着什么？</p><a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="19356441380">
<img class="first-react-image alignnone size-full wp-image-46 jetpack-lazy-image jetpack-lazy-image--handled" src="../Images/f300c244a1a1cf916df8b4cb02bec6c6.png" vwo-el-id="18272717540" data-lazy-loaded="1" data-original-src="https://files.readme.io/27c94e7-Image_2017-06-05_at_9.46.04_PM.png"/>
</a>
<a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="19356441690">
<img class="second-react-image alignnone size-full wp-image-46 jetpack-lazy-image jetpack-lazy-image--handled" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" vwo-el-id="30720362350" data-lazy-loaded="1" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/>
</a>
<p vwo-el-id="28675660440" class="">LogRocket不是猜测错误发生的原因，也不是要求用户提供截图和日志转储，而是让您回放问题，就像它们发生在您自己的浏览器中一样，以快速了解哪里出错了。</p>
<p>不再有嘈杂的警报。智能错误跟踪允许您对问题进行分类，然后从中学习。获得有影响的用户问题的通知，而不是误报。警报越少，有用的信号越多。</p>
<p>LogRocket Redux中间件包为您的用户会话增加了一层额外的可见性。LogRocket记录Redux存储中的所有操作和状态。</p>
<p vwo-el-id="28675660750">现代化您调试React应用的方式— <a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="40093418840">开始免费监控</a>。</p>
<p vwo-el-id="28675661060">Modernize how you debug your React apps —
<a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="40093418840">start monitoring for free</a>.
</p>
</div></div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
<html>
<head>
<title>Building a long-press directive in Vue - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>在Vue - LogRocket博客中构建一个长按指令</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/building-a-long-press-directive-in-vue-3408d60fb511/#0001-01-01">https://blog.logrocket.com/building-a-long-press-directive-in-vue-3408d60fb511/#0001-01-01</a></blockquote><div><article class="article-post">
<p>你是否曾经想通过按住一个按钮几秒钟来执行你的Vue应用程序中的一个功能？</p>
<p>你有没有想过在你的应用程序中创建一个按钮来帮助清除单个输入(或者按住一个按钮清除整个输入)？</p>
<p>你有吗？很好。我也是。你来对地方了。</p>
<p>本文将解释如何通过按下(或按住)按钮来执行功能和移除输入。</p>
<p>首先，我将解释如何在VanillaJS中实现这一点。然后，为它创建一个Vue指令。</p>
<p>系好安全带。我要让你大吃一惊了。</p>
<h2>理论</h2>
<p>为了实现长按，用户需要按住按钮几秒钟。</p>
<p>为了在代码中复制这一点，我们需要监听鼠标“点击”按钮被按下的时间，启动一个计时器，不管我们希望用户在执行功能之前按住按钮多长时间，并在设定的时间过去后执行功能。</p>
<p>相当简单！然而，我们需要知道用户何时按下按钮。</p>
<h2>操作方法</h2>
<p>当用户点击一个按钮时，在点击事件之前会触发另外两个事件:<code>mousedown</code>和<code>mouseup</code>。</p>
<p>当用户按下鼠标按钮时会调用<code>mousedown</code>事件，而当用户释放按钮时会调用<code>mouseup</code>事件。</p>
<p>我们需要做的就是:</p>
<ol>
<li>一旦<code>mousedown</code>事件发生，启动定时器</li>
<li>一旦在2秒标记之前触发了<code>mouseup</code>事件，即一个完整的点击事件，清除该定时器并且不执行该功能</li>
</ol>
<p>只要计时器在到达我们设置的时间之前没有被清零——即<code>mouseup</code>事件没有被触发——我们就可以说用户没有释放按钮。因此，它被认为是一个长按，然后我们可以继续执行上述功能。</p>
<h2>实际的</h2>
<p>让我们深入研究代码，完成这项工作。</p>
<p>首先，我们必须定义三件事，即:</p>
<ol>
<li>存储计时器的变量</li>
<li>启动定时器的启动功能</li>
<li>取消定时器的取消功能</li>
</ol>
<h3>可变的</h3>
<p>这个变量基本上保存了<code>setTimeout</code>的值，所以当<code>mouseup</code>事件发生时我们可以取消它。</p>
<p>我们将变量设置为<code>null</code>,这样我们就可以在取消它之前检查变量以了解当前是否有一个活动的计时器。</p>
<h3>启动功能</h3>
<p>这个函数由一个<a class="markup--anchor markup--p-anchor" href="https://www.w3schools.com/jsref/met_win_settimeout.asp" target="_blank" rel="noopener noreferrer" data-href="https://www.w3schools.com/jsref/met_win_settimeout.asp"> <code>setTimeout</code> </a>组成，它基本上是Javascript中的一个方法，允许我们在函数中指定的特定持续时间后执行函数。</p>
<p>记住，在创建点击事件的过程中，有两个事件被触发。但是我们需要启动计时器的是<code>mousedown</code>事件。因此，如果是点击事件，我们不需要启动计时器。</p>
<h3>取消功能</h3>
<p>这个函数基本上如其名所言，取消调用start函数时创建的<code>setTimeout</code>。</p>
<p>为了取消<code>setTimeout</code>，我们将使用JavaScript中的<code><a class="markup--anchor markup--p-anchor" href="https://www.w3schools.com/jsref/met_win_cleartimeout.asp" target="_blank" rel="noopener noreferrer" data-href="https://www.w3schools.com/jsref/met_win_cleartimeout.asp">clearTimeout</a></code>方法，它基本上清除了用<code><a class="markup--anchor markup--p-anchor" href="https://www.w3schools.com/jsref/met_win_settimeout.asp" target="_blank" rel="noopener noreferrer" data-href="https://www.w3schools.com/jsref/met_win_settimeout.asp">setTimeout()</a></code>方法设置的计时器。</p>
<p>在使用<code>clearTimeout</code>之前，我们首先需要检查<code>pressTimer</code>变量是否被设置为空。如果它没有被设置为空，这意味着有一个活动的计时器。所以，我们需要清除计时器，并且，你猜对了，将<code>pressTimer</code>变量设置为<code>null</code>。</p><div class="code-block code-block-54">
<hr/>
<h3>更多来自LogRocket的精彩文章:</h3>

<hr/></div>
<p>一旦触发了<code>mouseup</code>事件，这个函数就会被调用。</p>
<h3>设置触发器</h3>
<p>剩下的就是给你想要添加长按效果的按钮添加事件监听器。</p>
<pre>addEventListener("mousedown", start);
addEventListener("click", cancel);</pre>
<h3>用Vue指令来包装这一切</h3>
<p>当创建一个Vue指令时，Vue允许我们定义一个全局的或者局部的指令给一个组件，但是在这篇文章中我们将走全局路线。</p>
<p>让我们构建实现这一点的指令。</p>
<p>首先，我们必须声明自定义指令的名称。</p>
<p>这基本上注册了一个名为<code>v-longpress</code>的全局定制指令。</p>
<p>接下来，我们添加带有一些参数的<code>bind</code> <a class="markup--anchor markup--p-anchor" href="https://vuejs.org/v2/guide/custom-directive.html#Hook-Functions" target="_blank" rel="noopener noreferrer" data-href="https://vuejs.org/v2/guide/custom-directive.html#Hook-Functions">钩子函数</a>，它允许我们引用指令绑定到的元素，获取传递给指令的值，并识别指令使用的组件。</p>
<pre>Vue.directive('longpress', {
  bind: function (el, binding, vNode) {
    
  }
}</pre>
<p>接下来，我们在bind函数中添加长按JavaScript代码。</p>
<pre>Vue.directive('longpress', {
    bind: function (el, binding, vNode) {

        // Define variable
        let pressTimer = null

        // Define funtion handlers
        // Create timeout ( run function after 1s )
        let start = (e) =&gt; {

            if (e.type === 'click' &amp;&amp; e.button !== 0) {
                return;
            }

            if (pressTimer === null) {
                pressTimer = setTimeout(() =&gt; {
                    // Execute something !!!
                }, 1000)
            }
        }

        // Cancel Timeout
        let cancel = (e) =&gt; {
            // Check if timer has a value or not
            if (pressTimer !== null) {
                clearTimeout(pressTimer)
                pressTimer = null
            }
        }

        // Add Event listeners
        el.addEventListener("mousedown", start);
        // Cancel timeouts if this events happen
        el.addEventListener("click", cancel);
        el.addEventListener("mouseout", cancel);
    }
})</pre>
<p>接下来，我们需要添加一个函数来运行将被传递给<code>longpress</code>指令的方法。</p>
<pre>Vue.directive('longpress', {
    bind: function (el, binding, vNode) {

        // Define variable
        let pressTimer = null

        // Define funtion handlers
        // Create timeout ( run function after 1s )
        let start = (e) =&gt; {

            if (e.type === 'click' &amp;&amp; e.button !== 0) {
                return;
            }

            if (pressTimer === null) {
                pressTimer = setTimeout(() =&gt; {
                    // Execute function
                    handler()
                }, 1000)
            }
        }

        // Cancel Timeout
        let cancel = (e) =&gt; {
            // Check if timer has a value or not
            if (pressTimer !== null) {
                clearTimeout(pressTimer)
                pressTimer = null
            }
        }
        // Run Function
        const handler = (e) =&gt; {
            // Execute method that is passed to the directive
            binding.value(e)
        }

        // Add Event listeners
        el.addEventListener("mousedown", start);

        // Cancel timeouts if this events happen
        el.addEventListener("click", cancel);
        el.addEventListener("mouseout", cancel);
        
    }
})</pre>
<p>现在，我们可以在我们的Vue应用程序中使用该指令，它将正常工作，直到用户在指令值中添加一个不是函数的值。因此，一旦发生这种情况，我们必须通过警告用户来防止这种情况。</p>
<p>为了警告用户，我们向bind函数添加了以下内容:</p>
<pre>// Make sure expression provided is a function
if (typeof binding.value !== 'function') {
  // Fetch name of component
  const compName = vNode.context.name
  // pass warning to console
  let warn = `[longpress:] provided expression '${binding.expression}' is not a function, but has to be`
  if (compName) { warn += `Found in component '${compName}' ` }
  console.warn(warn)
}</pre>
<p>最后，如果这项指令也适用于触摸设备，那就太好了。所以我们为<code><a class="markup--anchor markup--p-anchor" href="https://developer.mozilla.org/en-US/docs/Web/Events/touchstart" target="_blank" rel="noopener noreferrer" data-href="https://developer.mozilla.org/en-US/docs/Web/Events/touchstart">touchstart</a></code>、<code><a class="markup--anchor markup--p-anchor" href="https://developer.mozilla.org/en-US/docs/Web/Events/touchend" target="_blank" rel="noopener noreferrer" data-href="https://developer.mozilla.org/en-US/docs/Web/Events/touchend">touchend</a></code>、<code><a class="markup--anchor markup--p-anchor" href="https://developer.mozilla.org/en-US/docs/Web/Events/touchcancel" target="_blank" rel="noopener noreferrer" data-href="https://developer.mozilla.org/en-US/docs/Web/Events/touchcancel">touchcancel</a></code>添加事件监听器。</p>
<p>将所有东西放在一起:</p>
<pre>Vue.directive('longpress', {
    bind: function (el, binding, vNode) {
        // Make sure expression provided is a function
        if (typeof binding.value !== 'function') {
            // Fetch name of component
            const compName = vNode.context.name
            // pass warning to console
            let warn = `[longpress:] provided expression '${binding.expression}' is not a function, but has to be`
            if (compName) { warn += `Found in component '${compName}' ` }

            console.warn(warn)
        }

        // Define variable
        let pressTimer = null

        // Define funtion handlers
        // Create timeout ( run function after 1s )
        let start = (e) =&gt; {

            if (e.type === 'click' &amp;&amp; e.button !== 0) {
                return;
            }

            if (pressTimer === null) {
                pressTimer = setTimeout(() =&gt; {
                    // Run function
                    handler()
                }, 1000)
            }
        }

        // Cancel Timeout
        let cancel = (e) =&gt; {
            // Check if timer has a value or not
            if (pressTimer !== null) {
                clearTimeout(pressTimer)
                pressTimer = null
            }
        }
        // Run Function
        const handler = (e) =&gt; {
            binding.value(e)
        }

        // Add Event listeners
        el.addEventListener("mousedown", start);
        el.addEventListener("touchstart", start);
        // Cancel timeouts if this events happen
        el.addEventListener("click", cancel);
        el.addEventListener("mouseout", cancel);
        el.addEventListener("touchend", cancel);
        el.addEventListener("touchcancel", cancel);
    }
})</pre>
<p>现在参考我们的Vue组件:</p>
<pre>&lt;template&gt;
    &lt;div&gt;
        &lt;button v-longpress="incrementPlusTen" @click="incrementPlusOne"&gt;{{value}}&lt;/button&gt;
    &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
export default {
    data() {
        return {
            value: 10
        }
    },
    methods: {
        // Increment value plus one
        incrementPlusOne() {
            this.value++
        },
        // increment value plus 10
        incrementPlusTen() {
            this.value += 10
        }
    }
}
&lt;/script&gt;</pre>
<h2>结论</h2>
<p>如果你想了解更多关于自定义指令、可用的钩子函数、可以传递给钩子函数的参数以及函数shorthands的信息，伟大的guys @vuejs已经做了很好的解释<a class="markup--anchor markup--p-anchor" href="https://vuejs.org/v2/guide/custom-directive.html" target="_blank" rel="noopener noreferrer" data-href="https://vuejs.org/v2/guide/custom-directive.html">这里</a>。</p>
<p>干杯！！！</p><div class="code-block code-block-20">
<div class="blog-plug inline-plug vue-inline"><h2>像用户一样体验您的Vue应用</h2><p>调试Vue.js应用程序可能会很困难，尤其是当用户会话期间有几十个(如果不是几百个)突变时。如果您对监视和跟踪生产中所有用户的Vue突变感兴趣，</p><a href="https://lp.logrocket.com/blg/vue-signup" target="_blank">try LogRocket</a><p>. </p><a class="signup" href="https://lp.logrocket.com/blg/vue-signup" target="_blank" rel="noopener noreferrer"><img class="alignnone size-full wp-image-46 jetpack-lazy-image" src="../Images/0d269845910c723dd7df26adab9289cb.png" alt="LogRocket Dashboard Free Trial Banner" data-lazy-src="https://files.readme.io/00591d0-687474703a2f2f692e696d6775722e636f6d2f6a3049327856572e706e67.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://files.readme.io/00591d0-687474703a2f2f692e696d6775722e636f6d2f6a3049327856572e706e67.png"/><noscript><img data-lazy-fallback="1" class="alignnone size-full wp-image-46" src="../Images/0d269845910c723dd7df26adab9289cb.png" alt="LogRocket Dashboard Free Trial Banner" data-original-src="https://files.readme.io/00591d0-687474703a2f2f692e696d6775722e636f6d2f6a3049327856572e706e67.png"/></noscript></a><a href="https://lp.logrocket.com/blg/vue-signup" target="_blank" rel="noopener noreferrer">https://logrocket.com/signup/</a><p>LogRocket 就像是网络和移动应用程序的DVR，记录你的Vue应用程序中发生的一切，包括网络请求、JavaScript错误、性能问题等等。您可以汇总并报告问题发生时应用程序的状态，而不是猜测问题发生的原因。</p><p>LogRocket Vuex插件将Vuex突变记录到LogRocket控制台，为您提供导致错误的环境，以及出现问题时应用程序的状态。</p><p>现代化您调试Vue应用的方式- <a class="signup" href="https://lp.logrocket.com/blg/vue-signup" target="_blank" rel="noopener noreferrer">开始免费监控</a>。</p></div>


</div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
<html>
<head>
<title>How to create a custom Vuex plugin - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>如何创建一个定制的Vuex插件日志博客</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/how-to-create-a-custom-vuex-plugin/#0001-01-01">https://blog.logrocket.com/how-to-create-a-custom-vuex-plugin/#0001-01-01</a></blockquote><div><article class="article-post">
<p>Vuex插件是Vuex中最先进和最有用的概念之一。他们有各种各样的用例，从数据持久性到<a href="https://github.com/Kaperskyguru/vuex-slack-notifier"> Slack通知器</a>，再到增强Vuex本身。</p>
<p>Vuex插件只是一个接收商店作为唯一参数的函数。简单来说，插件就是在Vuex中调用某种类型的突变或动作时触发/调用的功能。</p>
<p>在本教程中，我们将带你了解如何创建一个定制的Vuex插件。</p>
<h2 id="subscribingtomutationhooks">订阅突变挂钩</h2>
<p>在订阅变异钩子的时候，记住插件是不允许直接变异状态的。它们只能通过Vuex突变来引发变化。</p>
<p>突变挂钩公开了两个属性:</p>
<ol>
<li><code>mutation.type</code>用于确定被触发的突变/动作的名称</li>
<li><code>mutation.payload</code>用于检索要提交的数据<pre>export default (store) =&gt; { store.subscribe((mutation) =&gt; { if (mutation.type === "STORE_ERRORS") { // Alert Slack here console.log(mutation.type, mutation.payload) } }); };</pre></li>
</ol>
<h2 id="subscribingtoactionhooks">订阅动作挂钩</h2>
<p>除了向<code>type</code>和<code>payload</code>发送关于被调用的Vuex动作的信息，而不是变异信息之外，<code>subscribeAction()</code>的工作方式与<code>subscribe()</code>完全相同。</p>
<pre>  store.subscribeAction((action) =&gt; {
    if (action.type === "getTodos") {
      // Alert Slack here
      console.log(action.type, action.payload)
    }
  });
</pre>
<p>Vuex 3.1.0中增加了<code>subscribeAction</code>。如果你还没有，你可能想升级它。</p>
<h2 id="buildingslacknotifiervuexplugin">构建松弛通知器Vuex插件</h2>
<p>让我们结合目前所学的知识来构建一个定制的Vuex插件，它将在提交状态时通知Slack通道任何错误。</p>
<h3 id="createpluginclass">创建<code>plugin</code>类</h3>
<p>在<code>plugins</code>文件夹中创建一个文件</p>
<pre>mkdir plugins

touch SlackNotifier.js</pre>
<h3 id="createstore_errorsmutation">创造<code>STORE_ERRORS</code>突变</h3>
<p>接下来，我们将创建一个名为<code>STORE_ERRORS</code>的Vuex变异。您可以实现这种Vuex变异来存储状态中的错误，或者使用各种包(如sweetalert)来显示错误警报。</p>
<p>在我们的例子中，我们将简单地把错误发送给我们的<code>ErrorService</code>来处理并在我们的组件上显示它们。</p>
<pre>  mutations: {
    // ....

    STORE_ERRORS: (state, error) =&gt; {
      // Call Error Service here
      ErrorService.onError(error);

      // Store error to state(optional)
      if (error.response) {
        state.errors = error.response;
      }
    },

    // ...
  },
</pre>
<p>每当这个Vuex突变被调用时，我们希望我们的Vuex插件触发并发送错误到Slack。</p>
<h2 id="buildingtheslacknotifier">建筑<code>SlackNotifier</code></h2>
<p>打开你的<code>SlackNotifier</code>类并粘贴下面的代码。请记住修改您的代码，以适应您想要观察的Vuex突变和动作的类型。在我们的例子中，是<code>STORE_ERRORS</code>突变和我们所有的Vuex动作(你可能想也可能不想这么做)。</p>
<pre>import axios from "axios";
const url = // Your Slack Webhook here;
export default (store) =&gt; {
  store.subscribe((mutation) =&gt; {
    if (mutation.type === "STORE_ERRORS") {
      // Alert Slack here
      errorSlackAlert(mutation.payload);
    }
  });
  store.subscribeAction((action) =&gt; {
    // Alert Slack here
    vuexActionSlackAlert(action.type);
  });
};
function vuexActionSlackAlert(type) {
  const data = {
    username: "Action Notifier",
    icon_emoji: ":bangbang:",
  };
  data.text = `Vuex "${type}" action was excuted`;
  data.attachments = [];
  data.attachments = [
    {
      color: "#eed140",
      fields: [
        {
          title: "Environment",
          value: "Development",
          short: true,
        },
      ],
    },
  ];
  postToSlack(data);
}
function errorSlackAlert(payload) {
  const data = {
    username: "Error Notifier",
    icon_emoji: ":bangbang:",
  };
  data.text = payload.message;
  if (payload.resource) {
    data.text = payload.resource.message;
  }
  data.attachments = [];
  data.attachments = [
    {
      color: "#eed140",
      fields: [
        {
          title: "Environment",
          value: "Development",
          short: true,
        },
        {
          title: "StackTrace",
          value: payload.fileName,
          short: true,
        },
      ],
    },
  ];
  postToSlack(data);
}
function postToSlack(message) {
  axios
    .post(url, JSON.stringify(message))
    .then((result) =&gt; console.log(result))
    .catch((error) =&gt; console.log(error));
}
</pre>
<p>阅读<a href="https://api.slack.com/messaging/webhooks" target="_blank" rel="noopener noreferrer">官方文档</a>了解更多关于Slack API的信息。</p>
<p>让我们接触到所有的Vuex突变。每当调用或执行变异时，检查以确保调用的变异类型与<code>STORE_ERRORS</code>匹配。如果是的话，调用<code>errorSlackAlert</code>来传递<code>payload</code>，它会根据Slack的要求格式化消息。然后，调用<code>postToSlack</code>将消息发布到Slack webhook。</p>
<p><img decoding="async" src="../Images/ea78edc648997be78b76b8a7fb5d7036.png" alt="Slack Error Notifier Bot" data-lazy-src="https://paper-attachments.dropbox.com/s_CC026314000B9A7BE4928E193CAC7DE55580F1C451BD150293CA75B75BF9DE40_1595648917938_file.jpeg?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" class=" jetpack-lazy-image" data-original-src="https://paper-attachments.dropbox.com/s_CC026314000B9A7BE4928E193CAC7DE55580F1C451BD150293CA75B75BF9DE40_1595648917938_file.jpeg"/></p><noscript><img data-lazy-fallback="1" decoding="async" src="../Images/ea78edc648997be78b76b8a7fb5d7036.png" alt="Slack Error Notifier Bot" data-original-src="https://paper-attachments.dropbox.com/s_CC026314000B9A7BE4928E193CAC7DE55580F1C451BD150293CA75B75BF9DE40_1595648917938_file.jpeg"/></noscript>
<p>同样的事情也发生在<code>store.subscribeAction(…….)</code>上，除了这次我们不检查任何特定类型的Vuex动作，而是通知Slack任何被触发的动作。</p>
<p><img decoding="async" src="../Images/ee3774161bbccb218b87e139f10718c6.png" alt="Slack Action Notifier Bot" data-lazy-src="https://paper-attachments.dropbox.com/s_CC026314000B9A7BE4928E193CAC7DE55580F1C451BD150293CA75B75BF9DE40_1595648895758_file.jpeg?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" class=" jetpack-lazy-image" data-original-src="https://paper-attachments.dropbox.com/s_CC026314000B9A7BE4928E193CAC7DE55580F1C451BD150293CA75B75BF9DE40_1595648895758_file.jpeg"/></p><noscript><img data-lazy-fallback="1" decoding="async" src="../Images/ee3774161bbccb218b87e139f10718c6.png" alt="Slack Action Notifier Bot" data-original-src="https://paper-attachments.dropbox.com/s_CC026314000B9A7BE4928E193CAC7DE55580F1C451BD150293CA75B75BF9DE40_1595648895758_file.jpeg"/></noscript>
<h2 id="conclusion">结论</h2>
<p>如果你已经做到这一步，你应该对Vuex中的插件有更深的理解。你还应该拥有构建自己的定制Vuex插件所需的经验和知识。</p>
<p>如果你想为Github上的<a href="https://github.com/Kaperskyguru/vuex-slack-notifier" target="_blank" rel="noopener noreferrer"> Vuex Slack通知程序做贡献，</a>发送一个PR😎</p><div class="code-block code-block-20">
<div class="blog-plug inline-plug vue-inline"><h2>像用户一样体验您的Vue应用</h2><p>调试Vue.js应用程序可能会很困难，尤其是当用户会话期间有几十个(如果不是几百个)突变时。如果您对监视和跟踪生产中所有用户的Vue突变感兴趣，</p><a href="https://lp.logrocket.com/blg/vue-signup" target="_blank">try LogRocket</a><p>. </p><a class="signup" href="https://lp.logrocket.com/blg/vue-signup" target="_blank" rel="noopener noreferrer"><img class="alignnone size-full wp-image-46 jetpack-lazy-image" src="../Images/0d269845910c723dd7df26adab9289cb.png" alt="LogRocket Dashboard Free Trial Banner" data-lazy-src="https://files.readme.io/00591d0-687474703a2f2f692e696d6775722e636f6d2f6a3049327856572e706e67.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://files.readme.io/00591d0-687474703a2f2f692e696d6775722e636f6d2f6a3049327856572e706e67.png"/><noscript><img data-lazy-fallback="1" class="alignnone size-full wp-image-46" src="../Images/0d269845910c723dd7df26adab9289cb.png" alt="LogRocket Dashboard Free Trial Banner" data-original-src="https://files.readme.io/00591d0-687474703a2f2f692e696d6775722e636f6d2f6a3049327856572e706e67.png"/></noscript></a><a href="https://lp.logrocket.com/blg/vue-signup" target="_blank" rel="noopener noreferrer">https://logrocket.com/signup/</a><p>LogRocket 就像是网络和移动应用程序的DVR，记录你的Vue应用程序中发生的一切，包括网络请求、JavaScript错误、性能问题等等。您可以汇总并报告问题发生时应用程序的状态，而不是猜测问题发生的原因。</p><p>LogRocket Vuex插件将Vuex突变记录到LogRocket控制台，为您提供导致错误的环境，以及出现问题时应用程序的状态。</p><p>现代化您调试Vue应用的方式- <a class="signup" href="https://lp.logrocket.com/blg/vue-signup" target="_blank" rel="noopener noreferrer">开始免费监控</a>。</p></div>


</div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
<html>
<head>
<title>Creating a full-stack MERN application using JWT authentication: Part 3 - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>使用JWT认证创建全栈MERN应用程序:第3部分</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/mern-app-jwt-authentication-part-3/#0001-01-01">https://blog.logrocket.com/mern-app-jwt-authentication-part-3/#0001-01-01</a></blockquote><div><article class="article-post">
<p>这是我们关于使用JWT认证创建全栈MERN应用程序系列的第二部分的继续。如果你还没有阅读第二部分<a href="https://blog.logrocket.com/mern-app-jwt-authentication-part-2/"/>，请阅读额外的上下文以便你能更好地理解这篇文章。你也可以<a href="https://blog.logrocket.com/mern-app-jwt-authentication-part-1/">在这里阅读第一部分</a>。</p>
<p>到目前为止，我们已经有了一个可以在服务器端生成JSON Web令牌的系统。让我们通过在前端构建一个React单页面应用程序来开始使用它。</p>
<h2>创建React应用程序</h2>
<p>我首先推荐的是环境设置。在经历了Wes Bos 的<a href="https://wesbos.com/courses/">课程后，我更倾向于使用Visual Studio代码(我一开始很讨厌它，因为它是一个</a><a href="https://blog.praveen.science/my-personal-development-environment/">完全不同的开发环境</a>，忠实于Sublime Text)。</p>
<p>创建新的React应用程序最简单的方法是使用简单的<a href="https://facebook.github.io/create-react-app/"> <code>create-react-app</code> </a>。导航到终端中的客户端目录，然后运行:</p>
<pre>➜  FrontEnd git:(master) $ npx create-react-app .</pre>
<p>这里的<code><a href="https://www.npmjs.com/package/npx">npx</a></code>不是输入错误，而是正确的命令。<code>create-react-app</code>应用程序安装像<code>react</code>、<code>react-dom</code>和<code>react-scripts</code>这样的包。一旦完成，您就有了全新的React应用程序。</p>
<h2>确保HTTPS的安全</h2>
<p>我们今天访问的几乎所有网站都受到HTTPS的保护。如果你的还没有，<a href="https://developers.google.com/web/fundamentals/security/encrypt-in-transit/why-https">应该是</a>。使用HTTPS保护您的服务器还将确保您无法从不受HTTPS保护的服务器向此服务器发送请求。这给使用本地开发环境的开发人员带来了一个问题，因为他们都是在开箱即用的<code><a href="http://localhost" rel="nofollow">http://localhost</a></code>上运行的。</p>
<p>当我们使用不同的认证机制、支付网关和类似的技术时，我们肯定需要用HTTPS保护我们的本地开发环境，不仅要使它们工作，还要模拟生产服务器。你有一个简单的方法使用React来使用HTTPS，你可以在"<a href="https://blog.praveen.science/using-reacts-proxy-to-get-ahead-of-cors/">使用React的代理来超越CORS &amp;使用HTTPS进行API调用</a>"</p>
<h2>安装依赖项</h2>
<p>因为应用程序是使用<code>create-react-app</code>构建的，所以所有东西都是默认安装的。主要依赖关系包括:</p>
<ul>
<li><code>react</code></li>
<li><code>react-dom</code></li>
<li><code>react-scripts</code></li>
</ul>
<p><code>react-scripts</code>实际上是一个完整的包，包含了将React JSX和ES6+转换成基于ES5的JavaScript所需的所有依赖项(比如<code>webpack</code>和<code>babel</code>)。除了上面的依赖项，我们可能还需要一些。</p>
<p>我们将使用的一个主要的样式相关的包是<a href="https://www.npmjs.com/package/node-sass"> <code>node-sass</code> </a>，用于将<a href="https://sass-lang.com/"> SCSS </a>编译成CSS。另一个值得注意的是用于触发HTTP <code>GET</code>、<code>POST</code>、<code>PUT</code>和<code>DELETE</code>调用的<a href="https://github.com/axios/axios"> <code>axios</code> AJAX库</a>。这只是一个漂亮的<a href="https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API"> <code>fetch()</code> API </a>的包装器。</p>
<p>让我们通过使用我们最喜欢的<code>npm install</code>命令来安装上面两个依赖项。您可以使用<code>npm install</code>安装多个包，方法是使用空格分隔的库名来指定它们，如下所示:</p>
<pre>➜  FrontEnd git:(master) $ npm install axios node-sass
npm WARN <a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="2e5a5d035e405e6e1f001e001f">[email protected]</a> requires a peer of <a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="a3d7dad3c6d0c0d1cad3d7e3">[email protected]</a>* but none is installed. You must install peer dependencies yourself.

+ <a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="a7c6dfcec8d4e79789969f8997">[email protected]</a>
installed 1 package and audited 36854 packages in 8.074s</pre>
<h3>同行要求</h3>
<p>在任何情况下，如果您为React应用程序使用TypeScript，您可能需要使用<code>npm</code>为<code><a href="https://www.npmjs.com/package/ts-pnp">ts-pnp</a></code>安装<code><a href="https://www.npmjs.com/package/typescript">typescript</a></code>包，这是一个低级包，它导出一个函数来实现来自<code>CompilerHost</code> 的<a href="https://github.com/Microsoft/TypeScript/wiki/Using-the-Compiler-API%23customizing-module-resolution"> <code>resolveModuleName</code>钩子:</a></p>
<pre>➜  FrontEnd git:(master) npm install typescript
+ <a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="cbbfb2bbaeb8a8b9a2bbbf8bf8e5ffe5">[email protected]</a>5
added 1 package from 1 contributor, updated 1 package and audited 36855 packages in 8.982s
➜  FrontEnd git:(master) npm install axios
+ <a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="98f9e0f1f7ebd8a8b6a9a0b6a8">[email protected]</a>
updated 1 package and audited 36855 packages in 8.959s</pre>
<p>您可以看到，一旦安装了<code>typescript</code>包，错误就消失了。</p>
<h2>使用React的代理</h2>
<p>在开发阶段，我们可以在React web应用程序中设置一个简单的代理服务器来模拟API调用的真实环境。这非常重要，因为我们将只使用域的相对URL来进行API调用，所有调用都将使用前缀<code>/api/</code>进行路由。</p>
<p>我们需要做的就是在我们的<code>package.json</code>文件中添加一个新行来获得这个特性。考虑到我们的Express.js API服务器——我们在<a href="/">的上一篇文章</a>中构建的——运行在端口<code>3100</code>上，我们应该使用以下更改让React dev服务器(CRA/webpack)知道:</p>
<pre>{
  "name": "client",
  "version": "0.1.0",
  "proxy": "http://localhost:3100/",    // Set the proxy this way. All the unrouted requests will go here.
  "private": true,
  // Other stuff.
}</pre>
<h2>设置AJAX调用</h2>
<p>这是文章现在的主要症结。我们需要为所有AJAX调用设置一个包装器，然后我们需要为每个服务设置包装器。作为服务调用方，你可以更好地调用它们——这将是最好的方法。</p>
<p>为了了解如何用Axios启动AJAX调用，让我们只关注最常见的<code>GET</code>和<code>POST</code>请求。请记住，Axios返回了一个我们需要进一步处理的承诺。</p>
<h3>导入Axios</h3>
<p>你可以通过它的包导入Axios。简单的导入就可以了，不需要到处导入；这就是为什么我们有服务调用者包装器。</p>
<pre>import Axios from "axios";</pre>
<p>许多人使用<code>Axios</code>或<code>axios</code>，但这真的无关紧要，因为这是默认导入。默认导入没有命名，所以您可以拥有任何东西。你甚至可以有这样的东西:</p>
<pre>import Praveen from "axios";</pre>
<p>它工作起来完美无缺。我们暂时用<code>Axios</code>吧。😇</p>
<h3>HTTP <code>GET</code>和<code>POST</code>请求</h3>
<p>HTTP <code>GET</code>和<code>POST</code>请求是API请求的两个基本方法(或动词)。执行HTTP <code>GET</code>请求的最简单方法如下。假设我们正在点击<code>/user</code> API端点来检索关于以<code>name</code>为<code>praveen</code>的用户的详细信息:</p>
<pre>// Make a request for a user with a given name.
axios.get("/user?name=praveen")
  .then(function (response) {
    console.log(response);
  })
  .catch(function (error) {
    console.log(error);
  });</pre>
<p>上面的请求也可以这样写:</p>
<pre>// Optionally, the request above could also be done as:
axios.get("/user", {
  params: {
    name: "praveen"
  }
})
  .then(function (response) {
    console.log(response);
  })
    .catch(function (error) {
    console.log(error);
  });</pre>
<p>第二个参数是<code>data</code>参数。无论如何，如果你有一个要发送的对象，你可以这样发送。</p>
<p><code>POST</code>请求是类似的。首先你需要将方法改为<code>axios.post()</code>，并且你将给出<code>data</code>参数。例如，让我们尝试用<code>name</code>参数创建一个用户:</p>
<pre>axios.post("/user", {
  firstName: "Praveen",
  lastName: "Kumar",
  name: "praveen"
})
  .then(function(response) {
    console.log(response);
  })
  .catch(function(error) {
    console.log(error);
  });</pre>
<p>很棒，对吧？你可以在这里查看Axios和<code>fetch()</code>之间的一些<a href="https://blog.logrocket.com/axios-or-fetch-api/">差异。</a></p>
<h2>JSON Web令牌认证</h2>
<p>继续，这个应用程序的主要原因是演示客户端的<a href="https://jwt.io/"> JSON Web Token (JWT) </a>认证。让我们看一下JWT认证工作流。</p>
<p>首先，客户机向服务器发出一个HTTP <code>POST</code>请求，然后服务器创建一个JSON Web令牌并发送给客户机。客户端然后在本地存储JWT(使用一个<code>localStorage</code>或变量)并在<code>Authorization</code>头上发送它。</p>
<p>当向服务器发出一个<code>POST</code>请求时，JWT作为一个字符串令牌以如下格式发送:</p>
<p><img data-attachment-id="6745" data-permalink="https://blog.logrocket.com/mern-app-jwt-authentication-part-3/jwt-string-format-2/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2019/09/jwt-string-format.png" data-orig-size="730,198" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="JWT string format" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2019/09/jwt-string-format-300x81.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2019/09/jwt-string-format.png" decoding="async" class="aligncenter size-full wp-image-6745 jetpack-lazy-image" src="../Images/671993af75e831f54e97ed94f57dd20f.png" alt="JWT String Format" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2019/09/jwt-string-format.png 730w, https://blog.logrocket.com/wp-content/uploads/2019/09/jwt-string-format-300x81.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2019/09/jwt-string-format.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/09/jwt-string-format.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="6745" data-permalink="https://blog.logrocket.com/mern-app-jwt-authentication-part-3/jwt-string-format-2/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2019/09/jwt-string-format.png" data-orig-size="730,198" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="JWT string format" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2019/09/jwt-string-format-300x81.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2019/09/jwt-string-format.png" decoding="async" loading="lazy" class="aligncenter size-full wp-image-6745" src="../Images/671993af75e831f54e97ed94f57dd20f.png" alt="JWT String Format" srcset="https://blog.logrocket.com/wp-content/uploads/2019/09/jwt-string-format.png 730w, https://blog.logrocket.com/wp-content/uploads/2019/09/jwt-string-format-300x81.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/09/jwt-string-format.png"/></noscript>
<p>有三个部分——报头、有效载荷和签名。签名部分仅用于验证JWT，由于我们在客户端，验证需要<code>secret-key</code>，所以我们将<strong>而不是</strong>在客户端验证令牌——尽管这是可能的。我们只需要有效载荷部分。</p>
<h3>安装JWT图书馆</h3>
<p>为了解析JWT，我们将使用我们在服务器端用来生成JWT的同一个库。<code><a href="https://www.npmjs.com/package/jsrsasign">jsrsasign</a></code>在客户端也运行良好。让我们使用<code>npm install</code>将它安装在客户端React应用程序上，如下所示:</p>
<pre>➜  FrontEnd git:(master) npm install jsrsasign
npm WARN <a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="e39790ce938d93a3d2cdd3cdd2">[email protected]</a> requires a peer of <a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="24505d54415747564d545064">[email protected]</a>* but none is installed. You must install peer dependencies yourself.

+ <a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="5f352c2d2c3e2c3638311f67716f716e6d">[email protected]</a>
added 1 package from 1 contributor and removed 1 package in 18.476s</pre>
<p>以上是软件包的典型安装。您可能会遇到同样的<code><a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="52262b22372131203b222612">[email protected]</a>*</code>对等依赖问题，如果您在应用程序中使用TypeScript，最好安装任何版本的<code>typescript</code>。</p>
<h3>将<code>jsrsasign</code>导入React应用程序</h3>
<p>安装完成后，只需在React应用程序中使用普通导入即可使用该库:</p>
<pre>import JSRSASign from "jsrsasign";</pre>
<p>您将从该库中使用的最常见的函数有:</p>
<ul>
<li><strong><code><a href="https://kjur.github.io/jsrsasign/api/symbols/global__.html#b64utos">b64utos()</a></code>:</strong><code>b64utos()</code>函数用于将Base64URL编码的字符串转换为ASCII字符串。注意，这个函数不能用于Base64URL编码的非ASCII字符。</li>
<li><strong><code><a href="https://kjur.github.io/jsrsasign/api/symbols/KJUR.jws.JWS.html#.readSafeJSONString">WS.readSafeJSONString()</a></code>:</strong><code>JWS.readSafeJSONString()</code>函数读取一个字符串<code>"s"</code>作为JSON对象，如果它是安全的。如果字符串<code>"s"</code>是一个格式错误的JSON字符串，或者不是JSON字符串，则返回null否则，它返回一个JSON对象。</li>
</ul>
<h2>从创建React应用程序中清除</h2>
<p>到目前为止，我们已经设置好了大部分环境和依赖项。此时，我们应该从自动生成的CRA存储库中删除并更改一些内容。我们要做的第一件事是<a href="https://github.com/praveenscience/JWT-MERN-FullStack/commit/2952aef355d1adf2979738c300555e009a0f0b39">删除所有的CSS文件和默认的React标志</a>，并删除已删除文件的导入。</p>
<h3>组织文件</h3>
<p>我也遵循我自己为我的React应用程序设计的模式，这将是“类别优先”的模型。我将所有内容按照它们在React中的位置进行分类，并将<code>src</code>文件夹简化为:</p>
<ul>
<li><code>actions</code>:包含所有的Redux动作。<em>(当前项目未实施…) </em></li>
<li><code>components</code>:包含所有的React组件。如果组件有依赖组件，它们以分层的方式驻留在这里。</li>
<li>可能会使主要组件混乱的实用功能。<em>(当前项目未实施…) </em></li>
<li><code>reducers</code>:包含所有的Redux Reducers。<em>(当前项目未实施…) </em></li>
<li><code>services</code>:包含所有使用Axios的AJAX URLs和服务调用。</li>
<li>包含所有用于造型的SCSS文件。在<code>index.js</code>中只导入了一个文件</li>
<li><code>tests</code>:包含所有与测试相关的文件。<em>(不在当前项目范围内……)</em></li>
<li><code>index.js</code>:服务器启动时加载的主文件，包含样式和App组件。</li>
</ul>
<h3>更新主应用程序组件</h3>
<p>我们将把我们的<code>App.js</code>从<code>src</code>文件夹移到<code>components/App.js</code>。让我们也从<code>App.js</code>中删除不必要和未使用的导入，将其精简为以下内容:</p>
<pre>import React from "react";

function App() {
  return (
    &lt;div className="App"&gt;
      &lt;p&gt;Hello World!&lt;/p&gt;
    &lt;/div&gt;
  );
}

export default App;</pre>
<h3>更新公共HTML</h3>
<p>有了上面的文件组织，我们应该做的下一个更改是主<code>public/index.html</code>文件，它首先在浏览器上加载，并加载我们的React应用程序。修改包括改变标题，包括字体，CSS框架，以及我们项目中的引导等等。<a href="https://github.com/praveenscience/JWT-MERN-FullStack/blob/master/client/public/index.html">最终文件</a>如下所示(无注释):</p>
<pre>&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
  &lt;head&gt;
    &lt;meta charset="utf-8" /&gt;
    &lt;link rel="shortcut icon" href="%PUBLIC_URL%/favicon.ico" /&gt;
    &lt;meta name="viewport" content="width=device-width, initial-scale=1" /&gt;
    &lt;meta name="theme-color" content="#000000" /&gt;
    &lt;meta name="description" content="Creating a Full Stack MERN Application using JWT Authentication" /&gt;
    &lt;link rel="apple-touch-icon" href="logo512.png" /&gt;
    &lt;link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" /&gt;
    &lt;link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" /&gt;
    &lt;link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,600,600i&amp;display=swap" /&gt;
    &lt;link rel="manifest" href="%PUBLIC_URL%/manifest.json" /&gt;
    &lt;title&gt;Creating a Full Stack MERN Application using JWT Authentication&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;noscript&gt;You need to enable JavaScript to run this app.&lt;/noscript&gt;
    &lt;div id="root"&gt;&lt;/div&gt;
  &lt;/body&gt;
&lt;/html&gt;</pre>
<h3>风格</h3>
<p>更新HTML文件后，接下来是CSS部分。我们去掉了所有的CSS文件，只有一个主<code>styles/App.scss</code>。注意，这是一个SCSS文件，所以没有安装<code>node-sass</code>它不会运行。一旦我们在<code>styles</code>目录中创建了<code>App.scss</code>，让我们将<code>index.js</code>改为使用SCSS文件而不是CSS文件:</p>
<pre>- import './index.css';
+ import "./styles/App.scss";</pre>
<p>包含在<code>index.js</code>中的<code>styles/App.scss</code>文件最初看起来像这样:</p>
<pre>body {
  margin: 0;
  padding: 0;
  list-style: none;
}
.App {
  &amp;,
  * {
    margin: 0;
    padding: 0;
    list-style: none;
  }
}</pre>
<p>尽管我们不包括本文中的测试，但请确保从<code>tests/App.test.js</code>中移除未使用和过时的导入，然后我们可以安全地忘记应用程序其余部分的<code>tests</code>目录。</p>
<h2>登录表单</h2>
<p>让我们快速构建一个简单的表单来帮助我们获取用户名和密码。有多种方法可以获取这些信息；我们来回顾一下我最喜欢的一个。</p>
<p>我们将使用组件状态来存储输入的当前值，并且基于此，我们将更新它们。在React中有许多构建表单的解决方案，但是我将在后面介绍它们。</p>
<h3>构建表单</h3>
<p>因为表单将是一个组件，而React就是关于组件的，所以让我们在<code>App.js</code>旁边创建一个登录组件，比如说<code>components/Login.js</code>。让我们使用Bootstrap的<a href="https://getbootstrap.com/docs/4.3/components/forms/">表单</a>和<a href="https://getbootstrap.com/docs/4.3/components/card/">卡片</a>布局构建一个漂亮的表单。但在此之前，让我们先用如下所示的基本框架创建登录组件:</p>
<pre>import React, { Component } from "react";

class Login extends Component {
  render() {
    return (
      &lt;div className="login"&gt;

      &lt;/div&gt;
    );
  }
}
export default Login;</pre>
<p>现在让我们将它导入到<code>App.js</code>中并使用它。您不需要添加<code>.js</code>扩展名，因为它是一个JavaScript文件。</p>
<pre>import React from "react";
// Importing the Login Component
import Login from "./Login";

function App() {
  return (
    &lt;div className="App"&gt;
      {/* Import the Login */}
      &lt;Login /&gt;
    &lt;/div&gt;
  );
}</pre>
<p>在Bootstrap的<a href="https://getbootstrap.com/docs/4.3/layout/grid/">网格系统</a>的帮助下，为表单创建一个漂亮的居中布局变得更加容易。我做了一个简单的例子，看起来像这样:</p>
<pre>import React, { Component } from "react";

class Login extends Component {
  render() {
    return (
      &lt;div className="login"&gt;
        &lt;div className="container"&gt;
          &lt;div className="row"&gt;
            &lt;div className="col-6 offset-3"&gt;
              &lt;div className="card"&gt;
                &lt;div className="card-body"&gt;
                  &lt;h5 className="card-title"&gt;Sign In&lt;/h5&gt;
                  &lt;h6 className="card-subtitle mb-2 text-muted"&gt;
                    Please sign in to continue.
                  &lt;/h6&gt;
                  &lt;form&gt;
                    &lt;div className="form-group"&gt;
                      &lt;label htmlFor="exampleInputEmail1"&gt;Email address&lt;/label&gt;
                      &lt;input
                        type="email"
                        className="form-control"
                        id="exampleInputEmail1"
                        aria-describedby="emailHelp"
                        placeholder="Enter email"
                      /&gt;
                    &lt;/div&gt;
                    &lt;div className="form-group"&gt;
                      &lt;label htmlFor="exampleInputPassword1"&gt;Password&lt;/label&gt;
                      &lt;input
                        type="password"
                        className="form-control"
                        id="exampleInputPassword1"
                        placeholder="Password"
                      /&gt;
                    &lt;/div&gt;
                    &lt;button type="submit" className="btn btn-success"&gt;
                      Submit
                    &lt;/button&gt;
                  &lt;/form&gt;
                &lt;/div&gt;
              &lt;/div&gt;
            &lt;/div&gt;
          &lt;/div&gt;
        &lt;/div&gt;
      &lt;/div&gt;
    );
  }
}
export default Login;</pre>
<p>上面的完整表格是从React的官方文档中截取的。我已经把所有的<code>class=</code>改成了<code>className=</code>，把<code>for=</code>改成了<code>htmlFor=</code>，因为<code>class</code>和<code>for</code>是JavaScript中的保留关键字。</p>
<p>我们需要对上面的表格做很多修改。让我们也开始组织一些造型。main <code>App.scss</code>看起来很小，因为大多数重置CSS现在将由Bootstrap处理。</p>
<pre>body {
  font-family: "Open Sans", "Segoe UI", sans-serif;
}
.App {
  @import "login";
}</pre>
<p>创建文件<code>_login.scss</code>将允许我们将内容导入到<code>.App</code>类下的<code>App.scss</code>中。我们将把与表单相关的样式放在<code>_login.scss</code>中，如下所示:</p>
<pre>.login {
  margin-top: 50px;
  .card {
    border-radius: 10px;
    &amp;-body {
      overflow: hidden;
      padding-top: 10px;
      border-radius: 10px;
      background-color: rgba(#f90, 0.15);
      form {
        margin: 10px -20px -20px;
        padding: 15px;
        background-color: #fff;
        border-top: 1px solid rgba(#000, 0.125);
      }
    }
  }
}</pre>
<p>使用上面的代码，表单看起来位于页面的中心，类似于下图。</p>
<p><img data-attachment-id="6746" data-permalink="https://blog.logrocket.com/mern-app-jwt-authentication-part-3/sign-in-form/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2019/09/sign-in-form.png" data-orig-size="549,321" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Our app’s sign-in form" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2019/09/sign-in-form-300x175.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2019/09/sign-in-form.png" decoding="async" class="aligncenter size-full wp-image-6746 jetpack-lazy-image" src="../Images/e1926bfe4cd1ad9d344aa3a228236137.png" alt="Our App's Sign-In Form" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2019/09/sign-in-form.png 549w, https://blog.logrocket.com/wp-content/uploads/2019/09/sign-in-form-300x175.png 300w" data-lazy-sizes="(max-width: 549px) 100vw, 549px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2019/09/sign-in-form.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/09/sign-in-form.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="6746" data-permalink="https://blog.logrocket.com/mern-app-jwt-authentication-part-3/sign-in-form/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2019/09/sign-in-form.png" data-orig-size="549,321" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Our app’s sign-in form" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2019/09/sign-in-form-300x175.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2019/09/sign-in-form.png" decoding="async" loading="lazy" class="aligncenter size-full wp-image-6746" src="../Images/e1926bfe4cd1ad9d344aa3a228236137.png" alt="Our App's Sign-In Form" srcset="https://blog.logrocket.com/wp-content/uploads/2019/09/sign-in-form.png 549w, https://blog.logrocket.com/wp-content/uploads/2019/09/sign-in-form-300x175.png 300w" sizes="(max-width: 549px) 100vw, 549px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/09/sign-in-form.png"/></noscript>
<h3>跟踪状态</h3>
<p>通过使用<a href="https://chrome.google.com/webstore/detail/react-developer-tools/fmkadmapgofadopljbjfkapdkoienihi"> React开发工具</a>来检查组件的状态会更容易，但是如果我们在表单的右边有一个漂亮的跟踪器会更好。我想让React应用程序使用<code><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify">JSON.stringify()</a></code>和<code>&lt;pre&gt;</code>以漂亮的格式显示<code>state</code>的内容。</p>
<p>除了<code>App.scss</code>，<code>Login</code>还有一个不错的样式，看起来像这样:</p>
<pre>pre {
  font-family: "Monaco", "Consolas", monospace;
  border: 1px solid #ccc;
  background-color: #f5f5f5;
  padding: 3px;
  border-radius: 3px;
  line-height: 1;
  height: 100%;
}
&lt;div className="login"&gt;
  &lt;div className="container"&gt;
    &lt;div className="row"&gt;
      {/* Removed the Offset */}
      &lt;div className="col-6"&gt;
        &lt;div className="card"&gt;
          &lt;div className="card-body"&gt;
            &lt;h5 className="card-title"&gt;Sign In&lt;/h5&gt;
            {/************************/}
            {/* That unchanged form! */}
            {/************************/}
          &lt;/div&gt;
        &lt;/div&gt;
      &lt;/div&gt;
      &lt;div className="col-6"&gt;
        &lt;pre&gt;
          State Data
          &lt;br /&gt;
          &lt;br /&gt;
          {JSON.stringify(this.state, null, 2)}
        &lt;/pre&gt;
      &lt;/div&gt;
    &lt;/div&gt;
  &lt;/div&gt;
&lt;/div&gt;</pre>
<p>页面现在看起来像这样:</p>
<p><img data-attachment-id="6747" data-permalink="https://blog.logrocket.com/mern-app-jwt-authentication-part-3/state-data-sign-in-form/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2019/09/state-data-sign-in-form.png" data-orig-size="730,210" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="State data alongside sign-in form" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2019/09/state-data-sign-in-form-300x86.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2019/09/state-data-sign-in-form.png" decoding="async" class="aligncenter size-full wp-image-6747 jetpack-lazy-image" src="../Images/29db884e73fc2fe2f93758088b266140.png" alt="State Data Alongside Sign-In Form" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2019/09/state-data-sign-in-form.png 730w, https://blog.logrocket.com/wp-content/uploads/2019/09/state-data-sign-in-form-300x86.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2019/09/state-data-sign-in-form.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/09/state-data-sign-in-form.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="6747" data-permalink="https://blog.logrocket.com/mern-app-jwt-authentication-part-3/state-data-sign-in-form/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2019/09/state-data-sign-in-form.png" data-orig-size="730,210" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="State data alongside sign-in form" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2019/09/state-data-sign-in-form-300x86.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2019/09/state-data-sign-in-form.png" decoding="async" loading="lazy" class="aligncenter size-full wp-image-6747" src="../Images/29db884e73fc2fe2f93758088b266140.png" alt="State Data Alongside Sign-In Form" srcset="https://blog.logrocket.com/wp-content/uploads/2019/09/state-data-sign-in-form.png 730w, https://blog.logrocket.com/wp-content/uploads/2019/09/state-data-sign-in-form-300x86.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/09/state-data-sign-in-form.png"/></noscript>
<p>我们完全忘了把它和<code>state</code>联系起来！我们需要像这样设置元素的<code>value</code>和<code>onChange</code>事件。首先，让我们初始化<code>Login</code>组件中的<code>state</code>。不仅如此，我们还需要为表单元素更改正确的名称。</p>
<pre>import React, { Component } from "react";

class Login extends Component {
  state = {
    Username: "",
    Password: ""
  };
  render() {
    return (
      &lt;div className="login"&gt;
        &lt;div className="container"&gt;
          &lt;div className="row"&gt;
            &lt;div className="col-6"&gt;
              &lt;div className="card"&gt;
                &lt;div className="card-body"&gt;
                  &lt;h5 className="card-title"&gt;Sign In&lt;/h5&gt;
                  &lt;h6 className="card-subtitle mb-2 text-muted"&gt;
                    Please sign in to continue.
                  &lt;/h6&gt;
                  &lt;form&gt;
                    &lt;div className="form-group"&gt;
                      &lt;label htmlFor="Username"&gt;Username&lt;/label&gt;
                      &lt;input
                        type="Username"
                        className="form-control"
                        id="Username"
                        placeholder="Username"
                      /&gt;
                    &lt;/div&gt;
                    &lt;div className="form-group"&gt;
                      &lt;label htmlFor="Password"&gt;Password&lt;/label&gt;
                      &lt;input
                        type="password"
                        className="form-control"
                        id="Password"
                        placeholder="Password"
                      /&gt;
                    &lt;/div&gt;
                    &lt;button type="submit" className="btn btn-success"&gt;
                      Submit
                    &lt;/button&gt;
                  &lt;/form&gt;
                &lt;/div&gt;
              &lt;/div&gt;
            &lt;/div&gt;
            &lt;div className="col-6"&gt;
              &lt;pre&gt;
                State Data
                &lt;br /&gt;
                &lt;br /&gt;
                {JSON.stringify(this.state, null, 2)}
              &lt;/pre&gt;
            &lt;/div&gt;
          &lt;/div&gt;
        &lt;/div&gt;
      &lt;/div&gt;
    );
  }
}
export default Login;</pre>
<h3>处理输入更改</h3>
<p>现在让我们开始写<code>handleChange()</code>函数。我们不打算在构造函数中使用绑定，因为如果我们使用胖箭头函数就没有必要了，所以让我们用它们来定义事件处理程序。</p>
<pre>handleChange = e =&gt; {
  // Here, e is the event.
  // e.target is our element.
  // All we need to do is to update the current state with the values here.
  this.setState({
    [e.target.name]: e.target.value
  });
};</pre>
<p>这将更新同名的状态变量。</p>
<h3>移除重复和与状态的双向绑定</h3>
<p>我们可以清楚地看到代码中有重复。让我们使用一个可能类型的数组，并尝试使用一个循环完整地呈现它。我们可以替换这两个输入，并将输入值绑定到状态，从而使它们成为受控组件。</p>
<pre>{["Username", "Password"].map((i, k) =&gt; (
  &lt;div className="form-group" key={k}&gt;
    &lt;label htmlFor={i}&gt;{i}&lt;/label&gt;
    &lt;input
      type={i === "Password" ? "password" : "text"}
      name={i}
      className="form-control"
      id={i}
      placeholder={i}
      value={this.state[i]}
      onChange={this.handleChange}
    /&gt;
  &lt;/div&gt;
))}</pre>
<p>目前上面的代码没有任何变化，除了当您尝试在表单上键入一些内容时，您可以看到它也反映在右侧的状态数据中。</p>
<p>你可以看到我写了<code>Praveen Kumar</code>和<code>$uper$ecretPa$$w0rd</code>，你可以清楚地看到它反映在我们下面的<code>&lt;pre&gt;</code>标签中。</p>
<p><img data-attachment-id="6758" data-permalink="https://blog.logrocket.com/mern-app-jwt-authentication-part-3/sign-in-form-entry-state/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2019/09/sign-in-form-entry-state.png" data-orig-size="730,212" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Sign-in form entry reflected in state" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2019/09/sign-in-form-entry-state-300x87.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2019/09/sign-in-form-entry-state.png" decoding="async" class="aligncenter size-full wp-image-6758 jetpack-lazy-image" src="../Images/771942760d4feb80b4574392172078bc.png" alt="From Entry Reflected In State" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2019/09/sign-in-form-entry-state.png 730w, https://blog.logrocket.com/wp-content/uploads/2019/09/sign-in-form-entry-state-300x87.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2019/09/sign-in-form-entry-state.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/09/sign-in-form-entry-state.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="6758" data-permalink="https://blog.logrocket.com/mern-app-jwt-authentication-part-3/sign-in-form-entry-state/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2019/09/sign-in-form-entry-state.png" data-orig-size="730,212" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Sign-in form entry reflected in state" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2019/09/sign-in-form-entry-state-300x87.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2019/09/sign-in-form-entry-state.png" decoding="async" loading="lazy" class="aligncenter size-full wp-image-6758" src="../Images/771942760d4feb80b4574392172078bc.png" alt="From Entry Reflected In State" srcset="https://blog.logrocket.com/wp-content/uploads/2019/09/sign-in-form-entry-state.png 730w, https://blog.logrocket.com/wp-content/uploads/2019/09/sign-in-form-entry-state-300x87.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/09/sign-in-form-entry-state.png"/></noscript>
<h3>防止默认提交</h3>
<p>当你点击提交按钮时，表单做的下一件事需要被阻止，因为我们使用AJAX调用与我们的REST API通信，这是我们在<a href="https://blog.logrocket.com/mern-app-jwt-authentication-part-2/">上一篇文章</a>中构建的。让我们为此编写一个表单处理程序:</p>
<pre>handleSubmit = e =&gt; {
  // Here, e is the event.
  // Let's prevent the default submission event here.
  e.preventDefault();
  // We can do something when the button is clicked.
  // Here, we can also call the function that sends a request to the server.
};</pre>
<p>让我们也将它添加到<code>&lt;form&gt;</code>的<code>onSubmit</code>事件处理程序中:</p>
<pre>&lt;form onSubmit={this.handleSubmit}&gt;</pre>
<p>现在，提交表单和重新加载页面的默认操作被阻止。但是这里我们还需要使用Axios向我们创建的REST API端点发送一个AJAX请求。让我们继续为我们的前端应用程序创建服务调用。</p>
<h2>创建服务呼叫</h2>
<p>所有的服务调用都应该在<code>services</code>目录中，我们应该只在这个目录中使用我们的Axios库。目前，我们的服务器中没有任何端点来处理用户身份验证。我们目前仅有的端点是JWT函数，如<code>GenerateJWT</code>、<code>DecodeJWT</code>和<code>ValidateJWT</code>，分别用于生成、解码和验证jwt。</p>
<p>让我们通过创建一个具有以下框架的<code>services/JWTService.js</code>文件来使用它们，该文件导入Axios并导出上述调用的函数:</p>
<pre>import axios from "axios";

export const GenerateJWT = (header, claims, key, cb) =&gt; {
  // Send request to /api/GenerateJWT
};
export const DecodeJWT = (sJWS, cb) =&gt; {
  // Send request to /api/DecodeJWT
};
export const ValidateJWT = (header, token, key, cb) =&gt; {
  // Send request to /api/ValidateJWT
};</pre>
<p>使用Axios，一个<code>POST</code>请求调用看起来像这样:</p>
<pre>axios
  .post(URL, {
    postData
  })
  .then(function(res) {
    // Log the response.
    console.log(res);
  })
  .catch(function(err) {
    // Log the error.
    console.log(err);
  });</pre>
<h3>JWT函数的服务调用</h3>
<p>完成以上工作后，我们可以开始以这种方式向正确的端点发送请求:</p>
<pre>import axios from "axios";

export const GenerateJWT = (header, claims, key, cb) =&gt; {
  // Send POST request to /api/GenerateJWT
  axios
    .post("/api/GenerateJWT", {
      header,
      claims,
      key
    })
    .then(function(res) {
      cb(res);
    })
    .catch(function(err) {
      console.log(err);
    });
};
export const DecodeJWT = (sJWS, cb) =&gt; {
  // Send POST request to /api/DecodeJWT
  axios
    .post("/api/DecodeJWT", {
      sJWS
    })
    .then(function(res) {
      cb(res);
    })
    .catch(function(err) {
      console.log(err);
    });
};
export const ValidateJWT = (header, token, key, cb) =&gt; {
  // Send POST request to /api/ValidateJWT
  axios
    .post("/api/ValidateJWT", {
      header,
      token,
      key
    })
    .then(function(res) {
      cb(res);
    })
    .catch(function(err) {
      console.log(err);
    });
};</pre>
<p>请注意，所有请求都是相对于当前域的，以确保我们不会遇到CORS问题，因为我们已经将请求代理到服务器。</p>
<h3>服务器密钥的默认值</h3>
<p>正如我们所知，JWT的密钥是敏感的，所以我们不能从客户端发送密钥。将密钥存储在客户端的任何地方(无论是JavaScript、HTML、cookies还是本地存储)绝对是一件荒谬的事情，因为它很容易被发现和泄露。</p>
<p>让我们更新我们的服务器端<code>server.js</code>来使用一些默认值，比如<code>key = "$PraveenIsAwesome!"</code>，以防客户端不发送密钥。</p>
<pre>app.post("/api/GenerateJWT", (req, res) =&gt; {
  let { header, claims, key } = req.body;
  // In case, due to security reasons, if the client doesn't send a key,
  // use our default key.
  key = key || "$PraveenIsAwesome!";
  res.json(GenerateJWT(header, claims, key));
});
app.post("/api/DecodeJWT", (req, res) =&gt; {
  res.json(DecodeJWT(req.body.sJWS));
});
app.post("/api/ValidateJWT", (req, res) =&gt; {
  let { header, token, key } = req.body;
  // In case, due to security reasons, if the client doesn't send a key,
  // use our default key.
  key = key || "$PraveenIsAwesome!";
  res.json(ValidateJWT(header, token, key));
});</pre>
<h2>服务器端日志记录</h2>
<p>让所有的日志都就位总是一个好的做法，尤其是在服务器端。我们必须确定发出了什么请求，请求到达了哪里。</p>
<p>在与Apache和nginx相同的标准中为我们做这件事的一个包是<a href="https://www.npmjs.com/package/morgan"> <code>morgan</code> </a>。是Node.js的HTTP请求记录器中间件，我们可以在服务器端使用<code>npm</code>安装<code>morgan</code>:</p>
<pre>➜  Server git:(master) $ npm install morgan</pre>
<h3><code>morgan</code>和requiring with Express的语法</h3>
<p>我们将能够通过要求模块来包含中间件:</p>
<pre>var morgan = require('morgan')</pre>
<p>由于我们正处于开发阶段，我们可以使用<code>"dev"</code>格式。</p>
<pre>app.use(morgan("dev"));</pre>
<p>使用给定的<code>format</code>和<code>options</code>创建一个新的morgan logger中间件函数。<code>format</code>参数可以是一个预定义名称的字符串(参见下面的名称)，一个格式字符串，或者一个将产生日志条目的函数。</p>
<p>将使用三个参数调用<code>format</code>函数，<code>tokens</code>、<code>req</code>和<code>res</code>，其中<code>tokens</code>是具有所有已定义令牌的对象，<code>req</code>是HTTP请求，<code>res</code>是HTTP响应。该函数应该返回一个作为日志行的字符串或<code>undefined</code> / <code>null</code>来跳过日志记录。</p>
<p><code>dev</code>格式给出了一个简明的输出，用响应状态来表示，供开发使用。对于服务器错误代码,<code>:status</code>令牌将显示为红色，对于客户端错误代码显示为黄色，对于重定向代码显示为青色，对于所有其他代码显示为无色。</p>
<pre>:method :url :status :response-time ms - :res[content-length]</pre>
<h2>回到客户端</h2>
<p>我们必须快速更改服务器端的一些元素，现在我们已经完成了，让我们让前端与REST API对话。</p>
<h3>呼叫JWT服务</h3>
<p>让我们调用<code>GenerateJWT</code>服务并在客户端显示它。这里要做的第一件事是从<code>services/JWTService.js</code>导入服务。你不需要添加<code>.js</code>扩展名，因为它是一个JavaScript文件。</p>
<pre>import { GenerateJWT } from "../services/JWTService";</pre>
<p>现在让我们更新<code>handleSubmit</code>函数，从<code>JWTService</code>调用<code>GenerateJWT</code>函数。注意，我们向函数的第三个参数发送了一个<code>null</code>值，它实际上接收了密钥。由于隐私问题，我们不打算存储任何密钥，我们将让服务器处理这些密钥。</p>
<pre>handleSubmit = e =&gt; {
  // Here, e is the event.
  // Let's prevent the default submission event here.
  e.preventDefault();
  // We can do something when the button is clicked.
  // Here, we can also call the function that sends a request to the server.
  // Get the username and password from the state.
  const { Username, Password } = this.state;
  const claims = {
    Username,
    Password
  };
  const header = {
    alg: "HS512",
    typ: "JWT"
  };
  GenerateJWT(header, claims, null, res =&gt; {
    if (res.status === 200) {
      this.setState({ Response: res.data });
    } else {
      this.setState({ Response: "Error!" });
    }
  });
};</pre>
<p>接下来要做的是在我们的<code>&lt;pre&gt;</code>中添加另一个部分，以清楚地显示<code>LoginData</code>和<code>ResponseData</code>(仅当收到响应时):</p>
<pre>&lt;pre&gt;
  State Data
  &lt;br /&gt;
  &lt;br /&gt;
  {JSON.stringify(
    {
      Username: this.state.Username,
      Password: this.state.Password
    },
    null,
    2
  )}
  {this.state.Response &amp;&amp; (
    &lt;&gt;
      &lt;br /&gt;
      &lt;br /&gt;
      Response Data (JWT)
      &lt;br /&gt;
      &lt;br /&gt;
      {this.state.Response}
     &lt;/&gt;
  )}
&lt;/pre&gt;</pre>
<p>更新<code>&lt;pre&gt;</code>标签的样式是值得的，因为响应是一个需要分解的巨大的JWT字符串。让我们添加<code>white-space: pre-wrap;</code>和<code>word-break: break-all;</code>来打断它显示的线条。</p>
<pre>pre {
  font-family: "Monaco", "Consolas", monospace;
  white-space: pre-wrap;
  word-break: break-all;
  border: 1px solid #ccc;
  background-color: #f5f5f5;
  padding: 3px;
  border-radius: 3px;
  line-height: 1;
  height: 100%;
}</pre>
<p>一旦你输入用户名和密码，并按下<strong>提交</strong>，你将会看到如下内容:</p>
<p><img data-attachment-id="6759" data-permalink="https://blog.logrocket.com/mern-app-jwt-authentication-part-3/sign-in-form-jwt-generated-state/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2019/09/sign-in-form-jwt-generated-state.png" data-orig-size="730,210" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Sign-in form with generated JWT in state" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2019/09/sign-in-form-jwt-generated-state-300x86.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2019/09/sign-in-form-jwt-generated-state.png" decoding="async" class="aligncenter size-full wp-image-6759 jetpack-lazy-image" src="../Images/a8e1e7b9a358d0bf595be0af634bc7bb.png" alt="Sign-In Form With Generated JWT" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2019/09/sign-in-form-jwt-generated-state.png 730w, https://blog.logrocket.com/wp-content/uploads/2019/09/sign-in-form-jwt-generated-state-300x86.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2019/09/sign-in-form-jwt-generated-state.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/09/sign-in-form-jwt-generated-state.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="6759" data-permalink="https://blog.logrocket.com/mern-app-jwt-authentication-part-3/sign-in-form-jwt-generated-state/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2019/09/sign-in-form-jwt-generated-state.png" data-orig-size="730,210" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Sign-in form with generated JWT in state" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2019/09/sign-in-form-jwt-generated-state-300x86.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2019/09/sign-in-form-jwt-generated-state.png" decoding="async" loading="lazy" class="aligncenter size-full wp-image-6759" src="../Images/a8e1e7b9a358d0bf595be0af634bc7bb.png" alt="Sign-In Form With Generated JWT" srcset="https://blog.logrocket.com/wp-content/uploads/2019/09/sign-in-form-jwt-generated-state.png 730w, https://blog.logrocket.com/wp-content/uploads/2019/09/sign-in-form-jwt-generated-state-300x86.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/09/sign-in-form-jwt-generated-state.png"/></noscript>
<h3>解码JWT数据</h3>
<p>解码接收到的JWT可以在客户端和服务器端完成。因为我们处理的是REST APIs，所以让我们尝试在服务器端解码并通过AJAX接收它。我们将再次改变<code>handleSubmit</code>事件来处理JWT的解码。首先，让我们从同一个文件中导入<code>DecodeJWT</code>函数:</p>
<pre>import { GenerateJWT, DecodeJWT } from "../services/JWTService";</pre>
<p>现在我们需要修改我们的<code>handleSubmit</code>函数来使用上面的函数:</p>
<pre>handleSubmit = e =&gt; {
  // Here, e is the event.
  // Let's prevent the default submission event here.
  e.preventDefault();
  // We can do something when the button is clicked.
  // Here, we can also call the function that sends a request to the server.
  // Get the username and password from the state.
  const { Username, Password } = this.state;
  const claims = {
    Username,
    Password
  };
  const header = {
    alg: "HS512",
    typ: "JWT"
  };
  GenerateJWT(header, claims, null, res =&gt; {
    if (res.status === 200) {
      this.setState({ Response: res.data }, () =&gt; {
        // Once we get the data, let us decode the data.
        DecodeJWT(this.state.Response, data =&gt;
          this.setState({ Data: data.data })
        );
      });
    } else {
      this.setState({ Response: "Error!" });
    }
  });
};</pre>
<p>我们也可以通过添加以下内容来显示来自状态查看器<code>&lt;pre&gt;</code>标签中状态的<code>Data</code>中的数据:</p>
<pre>{this.state.Data &amp;&amp; (
  &lt;&gt;
    &lt;br /&gt;
    &lt;br /&gt;
    Decoded Data
    &lt;br /&gt;
    &lt;br /&gt;
    {JSON.stringify(this.state.Data, null, 2)}
  &lt;/&gt;
)}</pre>
<p>酷！现在，如果我们尝试输入相同的用户名和密码，然后按回车键或提交表单，我们将看到如下内容:</p>
<p><img data-attachment-id="6761" data-permalink="https://blog.logrocket.com/mern-app-jwt-authentication-part-3/sign-in-form-jwt-decoded-data/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2019/09/sign-in-form-jwt-decoded-data.png" data-orig-size="730,209" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Sign-in form with JWT decoded in state" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2019/09/sign-in-form-jwt-decoded-data-300x86.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2019/09/sign-in-form-jwt-decoded-data.png" decoding="async" class="aligncenter size-full wp-image-6761 jetpack-lazy-image" src="../Images/0ad49cce74c46d41fce77313a34355af.png" alt="SIgn-In Form With JWT Decoded In State" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2019/09/sign-in-form-jwt-decoded-data.png 730w, https://blog.logrocket.com/wp-content/uploads/2019/09/sign-in-form-jwt-decoded-data-300x86.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2019/09/sign-in-form-jwt-decoded-data.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/09/sign-in-form-jwt-decoded-data.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="6761" data-permalink="https://blog.logrocket.com/mern-app-jwt-authentication-part-3/sign-in-form-jwt-decoded-data/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2019/09/sign-in-form-jwt-decoded-data.png" data-orig-size="730,209" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Sign-in form with JWT decoded in state" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2019/09/sign-in-form-jwt-decoded-data-300x86.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2019/09/sign-in-form-jwt-decoded-data.png" decoding="async" loading="lazy" class="aligncenter size-full wp-image-6761" src="../Images/0ad49cce74c46d41fce77313a34355af.png" alt="SIgn-In Form With JWT Decoded In State" srcset="https://blog.logrocket.com/wp-content/uploads/2019/09/sign-in-form-jwt-decoded-data.png 730w, https://blog.logrocket.com/wp-content/uploads/2019/09/sign-in-form-jwt-decoded-data-300x86.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/09/sign-in-form-jwt-decoded-data.png"/></noscript>
<h2>登录后屏幕</h2>
<p>登录屏幕和注销屏幕之间肯定是有区别的。在<code>state</code>中，我们将解码后的数据存储在<code>Data</code>下。如果设置了内容，我们可以<em>假设</em>用户已经成功完成了登录过程，并为他们显示一个不同的屏幕。有了一个简单的<code>if ... else ...</code>条件，我们就可以开始了:</p>
<pre>&lt;div className="col-6"&gt;
  &lt;div className="card"&gt;
    {this.state.Data ? (
      &lt;div className="card-body"&gt;
        {/* Show the signed in screen */}
      &lt;/div&gt;
    ) : (
      &lt;div className="card-body"&gt;
        {/* Show the original signed out form */}
      &lt;/div&gt;
    )}
  &lt;/div&gt;
&lt;/div&gt;</pre>
<p>有了上面的指导，我们可以创建新的组件，或者只是使用条件并使其更容易，因为有一些<code>setState</code>和<code>state</code>函数要使用。我们可以显示一个简单的屏幕，如下所示，上面写着<code>Hello {Username}! How are you?</code>。</p>
<pre>&lt;div className="col-6"&gt;
  &lt;div className="card"&gt;
    {this.state.Data ? (
      &lt;div className="card-body"&gt;
        &lt;h5 className="card-title"&gt;Successfully Signed In&lt;/h5&gt;
        &lt;p className="text-muted"&gt;
          Hello {this.state.Data.Username}! How are you?
        &lt;/p&gt;
      &lt;/div&gt;
    ) : (
      &lt;div className="card-body"&gt;
        &lt;h5 className="card-title"&gt;Sign In&lt;/h5&gt;
        &lt;h6 className="card-subtitle mb-2 text-muted"&gt;
          Please sign in to continue.
        &lt;/h6&gt;
        &lt;form onSubmit={this.handleSubmit}&gt;
          {["Username", "Password"].map((i, k) =&gt; (
            &lt;div className="form-group" key={k}&gt;
              &lt;label htmlFor={i}&gt;{i}&lt;/label&gt;
              &lt;input
                type={i === "Password" ? "password" : "text"}
                name={i}
                className="form-control"
                id={i}
                placeholder={i}
                value={this.state[i]}
                onChange={this.handleChange}
              /&gt;
            &lt;/div&gt;
          ))}
          &lt;button type="submit" className="btn btn-success"&gt;
            Submit
          &lt;/button&gt;
        &lt;/form&gt;
      &lt;/div&gt;
    )}
  &lt;/div&gt;
&lt;/div&gt;</pre>
<p>当用户使用任何用户名和密码登录时，上面的代码呈现在我们的浏览器上，就像这样。这里没有进行身份验证；我们只是根据用户创建的用户名和密码生成一个<code>claim</code>。我已经给出了<code>Dummy User</code>和<code>Dummy Password</code>作为用户名和密码，我的登录界面如下:</p>
<p><img data-attachment-id="6753" data-permalink="https://blog.logrocket.com/mern-app-jwt-authentication-part-3/signed-in-form-with-state/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2019/09/signed-in-form-with-state.png" data-orig-size="730,203" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Signed-in form" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2019/09/signed-in-form-with-state-300x83.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2019/09/signed-in-form-with-state.png" decoding="async" class="aligncenter size-full wp-image-6753 jetpack-lazy-image" src="../Images/393141f50e2efa0500acbcbbd0bae889.png" alt="Signed-In Form" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2019/09/signed-in-form-with-state.png 730w, https://blog.logrocket.com/wp-content/uploads/2019/09/signed-in-form-with-state-300x83.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2019/09/signed-in-form-with-state.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/09/signed-in-form-with-state.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="6753" data-permalink="https://blog.logrocket.com/mern-app-jwt-authentication-part-3/signed-in-form-with-state/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2019/09/signed-in-form-with-state.png" data-orig-size="730,203" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Signed-in form" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2019/09/signed-in-form-with-state-300x83.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2019/09/signed-in-form-with-state.png" decoding="async" loading="lazy" class="aligncenter size-full wp-image-6753" src="../Images/393141f50e2efa0500acbcbbd0bae889.png" alt="Signed-In Form" srcset="https://blog.logrocket.com/wp-content/uploads/2019/09/signed-in-form-with-state.png 730w, https://blog.logrocket.com/wp-content/uploads/2019/09/signed-in-form-with-state-300x83.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/09/signed-in-form-with-state.png"/></noscript>
<h3>注销流程</h3>
<p>在您实现了登录过程之后，我们还必须为用户提供一种退出的方法。我们需要做的就是使用<code>setState</code>清除我们<code>state</code>的<code>Respose</code>和<code>Data</code>，用户就被注销了。</p>
<p>我们可以使用一个简单的<code>&lt;button&gt;</code>，并使用<code>btn-link</code>类将其样式化为一个带有Bootstrap的链接。当使用一个按钮时，请不要忘记阻止重新加载页面的默认事件:</p>
<pre>&lt;p className="mb-0"&gt;
  You might want to{" "}
  &lt;button
    className="btn btn-link"
    onClick={e =&gt; {
      e.preventDefault();
      this.setState({ Response: null, Data: null });
    }}
    &gt;
    sign out
  &lt;/button&gt;
  .
&lt;/p&gt;</pre>
<p>现在屏幕看起来像这样，有一个段落和退出链接:</p>
<p><img data-attachment-id="6748" data-permalink="https://blog.logrocket.com/mern-app-jwt-authentication-part-3/signed-in-form-sign-out-option/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2019/09/signed-in-form-sign-out-option.png" data-orig-size="730,205" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Signed-in form with sign-out option" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2019/09/signed-in-form-sign-out-option-300x84.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2019/09/signed-in-form-sign-out-option.png" decoding="async" class="aligncenter size-full wp-image-6748 jetpack-lazy-image" src="../Images/60cbcdbb69aa62541c348f04e0675abf.png" alt="Signed-In Form With Sign-Out Option" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2019/09/signed-in-form-sign-out-option.png 730w, https://blog.logrocket.com/wp-content/uploads/2019/09/signed-in-form-sign-out-option-300x84.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2019/09/signed-in-form-sign-out-option.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/09/signed-in-form-sign-out-option.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="6748" data-permalink="https://blog.logrocket.com/mern-app-jwt-authentication-part-3/signed-in-form-sign-out-option/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2019/09/signed-in-form-sign-out-option.png" data-orig-size="730,205" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Signed-in form with sign-out option" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2019/09/signed-in-form-sign-out-option-300x84.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2019/09/signed-in-form-sign-out-option.png" decoding="async" loading="lazy" class="aligncenter size-full wp-image-6748" src="../Images/60cbcdbb69aa62541c348f04e0675abf.png" alt="Signed-In Form With Sign-Out Option" srcset="https://blog.logrocket.com/wp-content/uploads/2019/09/signed-in-form-sign-out-option.png 730w, https://blog.logrocket.com/wp-content/uploads/2019/09/signed-in-form-sign-out-option-300x84.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/09/signed-in-form-sign-out-option.png"/></noscript>
<h2>持久数据</h2>
<p>目前我们正在开发一个基于JavaScript的应用程序。当您重新加载屏幕时，它很可能会清除会话数据和存储在内存中的任何数据。我们需要以某种方式保存这些数据，否则我们将丢失状态信息。</p>
<p>我们可以通过使用带有<code>httpOnly</code>标志的<code>httpOnly</code>cookie来避免有人劫持会话信息的风险。这将使浏览器无法读取任何cookie，而是允许您使用服务器端cookie而不是<code>localStorage</code>。如果你想更多地了解这种方法，请阅读杰夫·阿特伍德的这篇<a href="https://blog.codinghorror.com/protecting-your-cookies-httponly/">好文章。</a></p>
<p>相反，我们可以在本地存储中临时存储像JWT这样的内容，尽管出于安全考虑，一般不建议这样做。首先需要做的是检查浏览器中的存储支持。这可以通过以下代码来完成:</p>
<pre>if (typeof Storage !== "undefined") {
  localStorage.setItem( key, value );
  localStorage.getItem( key );
}</pre>
<p>因此，使用上面的代码，让我们添加用于在本地存储中保存JWT的代码:</p>
<pre>GenerateJWT(header, claims, null, res =&gt; {
  if (res.status === 200) {
    this.setState({ Response: res.data }, () =&gt; {
      // Check if local storage is supported.
      if (typeof Storage !== "undefined") {
        localStorage.setItem("JWT", res.data);
      }
      DecodeJWT(this.state.Response, data =&gt;
        this.setState({ Data: data.data })
      );
    });
  } else {
    this.setState({ Response: "Error!" });
  }
});</pre>
<h3>从本地存储加载数据</h3>
<p>正如我们有文档'<code>ready()</code>事件或<code>window</code> s' <code>load()</code>事件一样，对于React中的每个组件，都有一个名为<code>[componentDidMount()](<a href="https://reactjs.org/docs/react-component.html#componentdidmount" rel="nofollow">https://reactjs.org/docs/react-component.html#componentdidmount</a>)</code>的生命周期方法，它在组件被挂载(插入到树中)时执行。</p>
<p>如果我们需要从远程端点加载数据，这是实例化网络请求的好地方。现在，我们只需要使用本地存储来加载数据。</p>
<pre>componentDidMount() {
  if (typeof Storage !== "undefined") {
    // When this component loads, check if JWT is already saved in the local storage.
    if (localStorage.getItem("JWT") !== null) {
      // If there's something, try to parse and sign the current user in.
      this.setState({ Response: localStorage.getItem("JWT") });
      DecodeJWT(localStorage.getItem("JWT"), data =&gt;
        this.setState({ Data: data.data })
      );
    }
  }
}</pre>
<p>在这里，除了<code>Username</code>和<code>Password</code>，我们能够恢复会话。但是正如我们已经看到了如何加载数据一样，我们还必须在退出系统时清除数据。一般来说，保持函数分离是一个好主意，不要像我们以前使用的那样使用内联函数来退出应用程序。现在让我们创建一个<code>SignOutUser</code>函数:</p>
<pre>SignOutUser = e =&gt; {
  e.preventDefault();
  this.setState({ Response: null, Data: null });
  if (typeof Storage !== "undefined") {
    // When this component loads, check if JWT is already saved in the local storage.
    if (localStorage.getItem("JWT") !== null) {
      localStorage.removeItem("JWT");
    }
  }
};</pre>
<p>并将其绑定到注销按钮:</p>
<pre>&lt;button
  className="btn btn-link"
  onClick={this.SignOutUser}
&gt;
  sign out
&lt;/button&gt;</pre>
<p>现在，当你刷新或重新加载浏览器时，唯一丢失的是<code>Username</code>和<code>Password</code> <code>Response</code>数据。您可以比较登录页面和重新加载页面之间的差异。</p>
<figure id="attachment_6764" aria-describedby="caption-attachment-6764" class="wp-caption aligncenter"><img data-attachment-id="6764" data-permalink="https://blog.logrocket.com/mern-app-jwt-authentication-part-3/signed-in-page-2/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2019/09/signed-in-page-1.png" data-orig-size="730,205" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Signed-in page" data-image-description="" data-image-caption="&lt;p&gt;Signed-in page.&lt;/p&gt;&#10;" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2019/09/signed-in-page-1-300x84.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2019/09/signed-in-page-1.png" decoding="async" class="size-full wp-image-6764 jetpack-lazy-image" src="../Images/e999dfb4460f20ff925eb8c7d3811c9d.png" alt="Signed-In Page" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2019/09/signed-in-page-1.png 730w, https://blog.logrocket.com/wp-content/uploads/2019/09/signed-in-page-1-300x84.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2019/09/signed-in-page-1.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/09/signed-in-page-1.png"/><noscript><img data-lazy-fallback="1" data-attachment-id="6764" data-permalink="https://blog.logrocket.com/mern-app-jwt-authentication-part-3/signed-in-page-2/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2019/09/signed-in-page-1.png" data-orig-size="730,205" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Signed-in page" data-image-description="" data-image-caption="&lt;p&gt;Signed-in page.&lt;/p&gt;&#10;" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2019/09/signed-in-page-1-300x84.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2019/09/signed-in-page-1.png" decoding="async" loading="lazy" class="size-full wp-image-6764" src="../Images/e999dfb4460f20ff925eb8c7d3811c9d.png" alt="Signed-In Page" srcset="https://blog.logrocket.com/wp-content/uploads/2019/09/signed-in-page-1.png 730w, https://blog.logrocket.com/wp-content/uploads/2019/09/signed-in-page-1-300x84.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/09/signed-in-page-1.png"/></noscript><figcaption id="caption-attachment-6764" class="wp-caption-text">Signed-in page.</figcaption></figure>
<figure id="attachment_6765" aria-describedby="caption-attachment-6765" class="wp-caption aligncenter"><img data-attachment-id="6765" data-permalink="https://blog.logrocket.com/mern-app-jwt-authentication-part-3/reloaded-page/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2019/09/reloaded-page.png" data-orig-size="730,205" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Reloaded page" data-image-description="" data-image-caption="&lt;p&gt;Reloaded page.&lt;/p&gt;&#10;" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2019/09/reloaded-page-300x84.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2019/09/reloaded-page.png" decoding="async" class="size-full wp-image-6765 jetpack-lazy-image" src="../Images/0fc6290ea354bd42564c5d71ab4706db.png" alt="Reloaded Page" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2019/09/reloaded-page.png 730w, https://blog.logrocket.com/wp-content/uploads/2019/09/reloaded-page-300x84.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2019/09/reloaded-page.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/09/reloaded-page.png"/><noscript><img data-lazy-fallback="1" data-attachment-id="6765" data-permalink="https://blog.logrocket.com/mern-app-jwt-authentication-part-3/reloaded-page/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2019/09/reloaded-page.png" data-orig-size="730,205" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Reloaded page" data-image-description="" data-image-caption="&lt;p&gt;Reloaded page.&lt;/p&gt;&#10;" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2019/09/reloaded-page-300x84.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2019/09/reloaded-page.png" decoding="async" loading="lazy" class="size-full wp-image-6765" src="../Images/0fc6290ea354bd42564c5d71ab4706db.png" alt="Reloaded Page" srcset="https://blog.logrocket.com/wp-content/uploads/2019/09/reloaded-page.png 730w, https://blog.logrocket.com/wp-content/uploads/2019/09/reloaded-page-300x84.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/09/reloaded-page.png"/></noscript><figcaption id="caption-attachment-6765" class="wp-caption-text">Reloaded page.</figcaption></figure>
<p>第二个图像中唯一缺少的是用户输入的状态数据。一旦你点击退出链接，你将回到应用程序的原始状态。</p>
<figure id="attachment_6767" aria-describedby="caption-attachment-6767" class="wp-caption aligncenter"><img data-attachment-id="6767" data-permalink="https://blog.logrocket.com/mern-app-jwt-authentication-part-3/signed-out-page/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2019/09/signed-out-page.png" data-orig-size="730,210" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Signed-out page" data-image-description="" data-image-caption="&lt;p&gt;Signed-out page.&lt;/p&gt;&#10;" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2019/09/signed-out-page-300x86.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2019/09/signed-out-page.png" decoding="async" class="size-full wp-image-6767 jetpack-lazy-image" src="../Images/2cd3fd7598b9174b02d6d63fbb436ff8.png" alt="Signed-Out Page" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2019/09/signed-out-page.png 730w, https://blog.logrocket.com/wp-content/uploads/2019/09/signed-out-page-300x86.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2019/09/signed-out-page.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/09/signed-out-page.png"/><noscript><img data-lazy-fallback="1" data-attachment-id="6767" data-permalink="https://blog.logrocket.com/mern-app-jwt-authentication-part-3/signed-out-page/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2019/09/signed-out-page.png" data-orig-size="730,210" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Signed-out page" data-image-description="" data-image-caption="&lt;p&gt;Signed-out page.&lt;/p&gt;&#10;" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2019/09/signed-out-page-300x86.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2019/09/signed-out-page.png" decoding="async" loading="lazy" class="size-full wp-image-6767" src="../Images/2cd3fd7598b9174b02d6d63fbb436ff8.png" alt="Signed-Out Page" srcset="https://blog.logrocket.com/wp-content/uploads/2019/09/signed-out-page.png 730w, https://blog.logrocket.com/wp-content/uploads/2019/09/signed-out-page-300x86.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/09/signed-out-page.png"/></noscript><figcaption id="caption-attachment-6767" class="wp-caption-text">Signed-out page.</figcaption></figure>
<h2>认证的验证</h2>
<p>在向服务器发送请求之前验证用户输入总是一个更好的主意。在我们发出AJAX请求之前，我们必须检查有效的案例，然后发出请求。这有助于减少客户端向服务器发出的请求数量。例如，在这里，让我们确保两个输入都至少有三个字符长。</p>
<pre>handleSubmit = e =&gt; {
  // Here, e is the event.
  // Let's prevent the default submission event here.
  e.preventDefault();
  // We can do something when the button is clicked.
  // Here, we can also call the function that sends a request to the server.
  // Get the username and password from the state.
  const { Username, Password } = this.state;
  // Right now it even allows empty submissions.
  // At least we shouldn't allow empty submission.
  if (Username.trim().length &lt; 3 || Password.trim().length &lt; 3) {
    // If either of Username or Password is empty, set an error state.
    this.setState({ Error: "You have to enter both username and password." });
    // Stop proceeding.
    return false;
  }
  const claims = {
    Username,
    Password
  };
  const header = {
    alg: "HS512",
    typ: "JWT"
  };
  GenerateJWT(header, claims, null, res =&gt; {
    if (res.status === 200) {
      this.setState({ Response: res.data }, () =&gt; {
        if (typeof Storage !== "undefined") {
          localStorage.setItem("JWT", res.data);
        }
        DecodeJWT(this.state.Response, data =&gt;
          this.setState({ Data: data.data })
        );
      });
    } else {
      this.setState({ Response: "Error!" });
    }
  });
};</pre>
<p>我们还可以向用户显示一条错误消息，让他们知道阻止他们继续操作的错误。在我们这里应该是，<code>"You have to enter both username and password."</code>。</p>
<pre>{this.state.Error &amp;&amp; (
  &lt;div className="alert alert-danger text-center"&gt;
    &lt;p className="m-0"&gt;{this.state.Error}&lt;/p&gt;
  &lt;/div&gt;
)}</pre>
<h2>结论</h2>
<p>到目前为止，我们已经成功地创建了一个基本系统，它与REST端点对话并提供响应，根据需要改变状态，并显示正确的内容。它也有一个持久的登录。</p>
<p>下一篇文章将讨论如何创建用户，在服务器端验证用户，并生成不同类型的响应，如找不到用户、无效凭证等。我们将从服务器的示例存储和验证用户开始。别忘了回来看看最后的部分！</p><div class="code-block code-block-17">
<div class="blog-plug inline-plug react-plug" vwo-el-id="26283398190">
<h2 vwo-el-id="41600691720">使用LogRocket消除传统反应错误报告的噪音</h2>
<a href="https://lp.logrocket.com/blg/react-signup-issue-free" target="_blank" vwo-el-id="19356441070">LogRocket
</a><p>是一款React analytics解决方案，可保护您免受数百个误报错误警报的影响，只针对少数真正重要的项目。LogRocket告诉您React应用程序中实际影响用户的最具影响力的bug和UX问题。</p><a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="19356441380">
<img class="first-react-image alignnone size-full wp-image-46 jetpack-lazy-image jetpack-lazy-image--handled" src="../Images/f300c244a1a1cf916df8b4cb02bec6c6.png" vwo-el-id="18272717540" data-lazy-loaded="1" data-original-src="https://files.readme.io/27c94e7-Image_2017-06-05_at_9.46.04_PM.png"/>
</a>
<a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="19356441690">
<img class="second-react-image alignnone size-full wp-image-46 jetpack-lazy-image jetpack-lazy-image--handled" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" vwo-el-id="30720362350" data-lazy-loaded="1" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/>
</a>
<a href="https://lp.logrocket.com/blg/react-signup-issue-free" target="_blank" rel="noopener noreferrer" vwo-el-id="35866400580">LogRocket
</a><p>自动聚合客户端错误、反应错误边界、还原状态、缓慢的组件加载时间、JS异常、前端性能指标和用户交互。然后，LogRocket使用机器学习来通知您影响大多数用户的最具影响力的问题，并提供您修复它所需的上下文。</p><p vwo-el-id="28675661060">关注重要的React bug—<a class="signup" href="https://lp.logrocket.com/blg/react-signup-issue-free" target="_blank" rel="noopener noreferrer" vwo-el-id="40093418840">今天就试试LogRocket】。</a></p>
</div></div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
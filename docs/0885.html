<html>
<head>
<title>How to improve developer experience with React Suspense in Concurrent Mode - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>如何在并发模式下用React悬念改善开发者体验</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/improve-developer-experience-with-react-suspense-in-concurrent-mode/#0001-01-01">https://blog.logrocket.com/improve-developer-experience-with-react-suspense-in-concurrent-mode/#0001-01-01</a></blockquote><div><article class="article-post">
<h2>介绍</h2>
<p><a href="https://reactjs.org/docs/concurrent-mode-suspense.html" target="_blank" rel="noopener noreferrer"> React暂停数据获取</a>是即将到来的React版本中的一个预期新功能。尽管在当前版本的React中可以使用数据获取的技术悬念，但新的<a href="https://reactjs.org/docs/concurrent-mode-intro.html" target="_blank" rel="noopener noreferrer">并发模式</a>启用了一种新的数据获取模式，称为<a href="https://reactjs.org/docs/concurrent-mode-suspense.html#approach-3-render-as-you-fetch-using-suspense" target="_blank" rel="noopener noreferrer">即取即渲染</a>。并发模式下的新钩子<a href="https://reactjs.org/docs/concurrent-mode-reference.html#usetransition" target="_blank" rel="noopener noreferrer"> useTransition、</a>简化了挂起状态的显示。</p>
<p>本文从开发人员体验的角度描述了并发模式下的React suspension意味着什么。我们将看到传统模式下的传统数据获取如何在并发模式下完成。我们将在具体案例中展示伪代码，以比较传统模式和新模式之间的差异。我们还将引入支持新模式的库。</p>
<h2>案例1:有许多负载指示器</h2>
<p>一个最典型的数据获取挂钩可以这样实现:</p>
<pre>const useFetch = (url) =&gt; {
  const [loading, setLoading] = useState(false);
  const [result, setResult] = useState();
  useEffect(() =&gt; {
    const fetchData = async () =&gt; {
      setLoading(true);
      const response = await fetch(url);
      const result = await response.json();
      setResult(result);
      setLoading(false);
    };
    fetchData();
  }, [url]);
  return { loading, result };
};
</pre>
<p>这种基于<code>useEffect</code>的<code>useFetch</code>非常方便，直到今天还经常被使用。它在组件中是这样使用的:</p>
<pre>const Component = ({ url }) =&gt; {
  const { loading, result } = useFetch(url);
  if (loading) return &lt;Loading /&gt;;
  return &lt;Result result={result} /&gt;
};
</pre>
<p>然而，一个典型的问题是加载标志。因为这个加载标志和钩子共存，这往往会导致UI中出现很多加载指示器。我们可以从技术上创建一个统一的加载组件，并提升父组件中的加载状态。如果你能控制所有的异步钩子，这将是可能的。但是，如果您使用的库不支持您的统一模式，那么您就不走运了。我们需要一个整个社区都能接受的官方模式。</p>
<p>React悬念会解决这个问题。暂挂处理统一的装载状态，而不是每个钩子处理装载状态。带着悬念，代码将如下所示:</p>
<pre>const Component = () =&gt; {
  const { result } = useFetchWithSuspense(somethingPrepared);
  return &lt;Result result={result} /&gt;
};

const App = () =&gt; (
  &lt;Suspense fallback={&lt;Loading /&gt;}&gt;
    &lt;Component /&gt;
  &lt;/Suspense&gt;
);
</pre>
<p>有了这个模式，我们不再需要考虑每个组件的加载状态。如果我们有一个好的<code>useFetchWithSuspense</code>钩子，那么用更少的代码就可以得到一个统一的加载指示器。</p>
<h2>案例useEffect回调函数运行太晚</h2>
<p>作为基于<code>useEffect</code>的<code>useFetch</code>(如前一节所示)，它在<code>useEffect</code>中调用一个fetch函数。<code>useEffect</code>仅在完成所有组件渲染后运行该功能。如果一个应用足够小，这可能不是一个UI问题。</p>
<p>假设我们有一个“下一步”按钮来触发获取新数据:</p>
<pre>const Component = ({ url, initialIndex }) =&gt; {
  const [index, setIndex] = useState(initialIndex);
  const { loading, result } = useFetch(`${url}?index=${index}`);
  const onClick = () =&gt; {
    setIndex(index + 1);
  };
  if (loading) return &lt;Loading /&gt;;
  return (
    &lt;div&gt;
      &lt;button onClick={onClick}&gt;Next&lt;/button&gt;
      &lt;Result result={result} /&gt;
      &lt;VeryHugeComponent /&gt;
    &lt;/div&gt;
  );
};
</pre>
<p>现在，问题是<code>VeryHugeComponent</code>是否需要时间来渲染。它只会在完成所有渲染后开始获取更多数据。为了克服这个问题，我们可以采用<a href="https://reactjs.org/docs/concurrent-mode-suspense.html#approach-2-fetch-then-render-not-using-suspense" target="_blank" rel="noopener noreferrer">提取然后渲染</a>的方法:</p>
<pre>const fetchData = async () =&gt; {
  const response = await fetch(url);
  const result = await response.json();
  return result;
};

const initialResult = await fetchData(...); // top-level await is not ideal

const Component = ({ url, initialIndex, initialResult }) =&gt; {
  const [index, setIndex] = useState(initialIndex);
  const [loading, setLoading] = useState(false);
  const [result, setResult] = useState(initialResult);
  const onClick = async () =&gt; {
    setLoading(true);
    setResult(await fetchData(`${url}?index=${index}`));    
    setIndex(index + 1);
    setLoading(false);
  };
  if (loading) return &lt;Loading /&gt;;
  return (
    &lt;div&gt;
      &lt;button onClick={onClick}&gt;Next&lt;/button&gt;
      &lt;Result result={result} /&gt;
      &lt;VeryHugeComponent /&gt;
    &lt;/div&gt;
  );
};
</pre>
<p>在上面的例子中，数据提取在渲染之前在回调中开始。它不会等待<code>VeryHugeComponent</code>渲染。</p>
<p>注意<code>initialResult</code>是如何创建的，这可能不是一个好模式，因为它在顶层运行异步初始化。为了一致性，在渲染之前准备好<code>initialResult</code>可能更好，或者我们可以使用渲染时提取模式进行初始渲染:</p>
<p>使用React悬念，上面显示的代码将变成如下所示:</p>
<pre>const Component = ({ url, initialIndex, initialResult }) =&gt; {
  const [index, setIndex] = useState(initialIndex);
  const [result, setResult] = useState(initialResult);
  const onClick = async () =&gt; {
    setResult(fetchDataWithSuspense(`${url}?index=${index}`));    
    setIndex(index + 1);
  };
  return (
    &lt;div&gt;
      &lt;button onClick={onClick}&gt;Next&lt;/button&gt;
      &lt;Result result={result} /&gt;
      &lt;VeryHugeComponent index={index} /&gt;
    &lt;/div&gt;
  );
};
</pre>
<p>除了我们不再关心加载状态之外，这在并发模式下还有一个好处。假设<code>VeryHugeComponent</code>有一个<code>index</code>道具，它可以在获取数据的过程中进行渲染。</p>
<p>下图显示了四种不同的数据获取模式。提取时渲染模式在渲染之前开始数据提取，同时允许React尽可能多地渲染，直到数据提取完成。</p>
<p><img data-attachment-id="19093" data-permalink="https://blog.logrocket.com/improve-developer-experience-with-react-suspense-in-concurrent-mode/attachment/renderasyoufetch/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/05/renderasyoufetch.png" data-orig-size="730,589" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="renderasyoufetch" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/05/renderasyoufetch-300x242.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/05/renderasyoufetch.png" decoding="async" class="aligncenter size-full wp-image-19093 jetpack-lazy-image" src="../Images/0c0baff668e0ab3c5d8f49b4263a72fc.png" alt="render as you fetch " data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2020/05/renderasyoufetch.png 730w, https://blog.logrocket.com/wp-content/uploads/2020/05/renderasyoufetch-300x242.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2020/05/renderasyoufetch.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/05/renderasyoufetch.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="19093" data-permalink="https://blog.logrocket.com/improve-developer-experience-with-react-suspense-in-concurrent-mode/attachment/renderasyoufetch/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/05/renderasyoufetch.png" data-orig-size="730,589" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="renderasyoufetch" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/05/renderasyoufetch-300x242.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/05/renderasyoufetch.png" decoding="async" loading="lazy" class="aligncenter size-full wp-image-19093" src="../Images/0c0baff668e0ab3c5d8f49b4263a72fc.png" alt="render as you fetch " srcset="https://blog.logrocket.com/wp-content/uploads/2020/05/renderasyoufetch.png 730w, https://blog.logrocket.com/wp-content/uploads/2020/05/renderasyoufetch-300x242.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/05/renderasyoufetch.png"/></noscript>
<h2>案例3:数据获取瀑布</h2>
<p>通常在传统的Web API中，您需要多次获取数据才能显示一个页面。例如，让我们考虑一个显示博客帖子和帖子的“赞数”的应用程序。使用基于<code>useEffect</code>的<code>useFetch</code>，呈现时提取模式的代码将如下所示:</p>
<pre>const BlogPosts = () =&gt; {
  const { loading, result } = useFetch(...);
  if (loading) return &lt;Loading /&gt;;
  return (
    &lt;ul&gt;
      {result.map(postId =&gt; (
        &lt;BlogPost key={postId} id={id} /&gt;
      ))}
    &lt;/ul&gt;
  );
};

const BlogPost = ({ postId }) =&gt; {
  const { loading, result } = useFetch(`...${postId}`);
  if (loading) return &lt;Loading /&gt;;
  return (
    &lt;li&gt;
      &lt;h1&gt;{result.title}&lt;/h1&gt;
      &lt;p&gt;{result.content}&lt;/p&gt;
      &lt;BlogLikeCount postId={postId} /&gt;
    &lt;/li&gt;
  );
};

const BlogLikeCount = ({ postId }) =&gt; {
  const { loading, result } = useFetch(`...${postId}`);
  if (loading) return &lt;Loading /&gt;;
  return &lt;span&gt;{result.count}&lt;/span&gt;;
};
</pre>
<p>这在某种程度上是一个假设的例子，但关键是将可视化组件和数据获取联系起来会导致瀑布。在这种情况下，我们可以更早地获取“like count”。我们实际上可以这样做——在<code>BlogPost</code>中提取“like count ”,这是提取然后渲染的模式。</p>
<p>使用“随取随渲染”模式，您需要更改心智模式。组件只关心渲染，不关心数据获取。有了这个心智模型，同样的例子看起来会是这样的:</p>
<pre>const BlogPosts = ({ posts }) =&gt; {
  return (
    &lt;ul&gt;
      {posts.map(post =&gt; (
        &lt;BlogPost key={post.id} post={post} /&gt;
      ))}
    &lt;/ul&gt;
  );
};

const BlogPost = ({ post }) =&gt; {
  return (
    &lt;li&gt;
      &lt;h1&gt;{post.title}&lt;/h1&gt;
      &lt;p&gt;{post.content}&lt;/p&gt;
      &lt;BlogLikeCount like={post.like} /&gt;
    &lt;/li&gt;
  );
};

const BlogLikeCount = ({ like }) =&gt; {
  return &lt;span&gt;{like.count}&lt;/span&gt;;
};
</pre>
<p>这段代码没有什么令人惊讶的地方。它只是像处理同步数据一样处理异步数据。然而，这在普通的JavaScript中通常是不可能的。这是可能的反应悬念。实现一个允许这种模式的库并不简单。您希望控制并行和顺序加载模式。尤其是，允许增量加载会变得有点棘手。(感兴趣的可以看看react-suspension-fetch是怎么解决的。)</p>
<h2>案例4:烦人的useEffect/useCallback deps数组</h2>
<p>可以说<code>useEffect</code>被过度用于数据抓取。函数通常是可组合的，有一个大的<code>useEffect</code>回调是没有意义的。如果你试图分割成更小的函数，你需要用<code>useCallback</code>包装一个函数。代码将如下所示:</p>
<pre>const Component = ({ id1, id2 }) =&gt; {
  const [loading, setLoading] = useState(false);
  const [result, setResult] = useState(initialResult);
  const fetchItem1 = useCallback(async () =&gt; {
    const item1 = await fetchItem(id1);
    return item1;
  }, [id1]);
  const fetchItem2 = useCallback(async () =&gt; {
    const item2 = await fetchItem(id2);
    return item2;
  }, [id2]);
  const fetchContent = useCallback(async () =&gt; {
    const [item1, item2] = await Promise.all([fetchItem1(), fetchItem2()]);
    return { item1, item2 };
  }, [fetchItem1, fetchItem2]);
  useEffect(() =&gt; {
    const fetchData = async () =&gt; {
      setLoading(true);
      setResult(await fetchContent());
      setLoading(false);
    };
    fetchData();
  }, [fetchContent]);
  if (loading) return &lt;Loading /&gt;;
  return &lt;Result result={result} /&gt;
};
</pre>
<p>这也是一个假设的例子。没有eslint-plugin-react-hooks包中的exhaustive-deps规则，我们无法安全地编写这种代码，因为开发人员经常会犯错误。一般来说，不太适合数据获取或异步功能。即取即渲染模式允许在没有useEffect的情况下进行数据提取，这从我们这里释放了这个烦人的deps问题。结果就像这样简单。</p>
<pre>const Component = ({ item1, item2 }) =&gt; {
  return &lt;Result result={{ item1, item2 }} /&gt;
};
</pre>
<h2>用于数据提取的暂记库</h2>
<p>我已经开发了几个用于数据获取的React库。最值得注意的是，这些库尽可能地鼓励“取即渲染”模式。有了这些库，我们在前面章节中的讨论实际上是可行的。</p>

<p>这是一个非常原始的库，可以从一个异步函数中创建一个支持悬念的数据。在React中，数据几乎可以被视为同步数据。它是用代理实现的。由于缓存在对象本身中，如果不再被引用，可以安全地对其进行垃圾收集。前面几节中的示例代码就是基于这一点而创建的。</p>

<p>因为react-suspension-fetch太原始，我们需要一个更加面向用例的库。这是一个结合了反应暂停提取和反应路由器的库。它允许我们根据路线变化获取数据。</p>

<p>这是另一个原始图书馆。与react-suspension-fetch不同，它提供了Hooks API。它不依赖于隐式缓存，而是使用显式存储。</p>
<p>上面这些库被设计成不依赖全局缓存。以下是具有全局缓存的各种库:</p>

<h2>结论</h2>
<p>我们仍处于新时代的开端。并发模式尚未发布，库也远未成熟。现在还不确定React中数据获取的最佳实践是什么。然而，这项新技术似乎很有前途。React悬念数据获取通常是为了更好的用户体验，但本文更多地从开发人员体验的角度进行解释。从技术上来说，相同的用户体验可以用当前的技术来完成，而没有任何悬念。总体来说，可以说创造更好的用户体验需要更好的开发者体验。</p><div class="code-block code-block-17">
<div class="blog-plug inline-plug react-plug" vwo-el-id="26283398190">
<h2 vwo-el-id="41600691720">使用LogRocket消除传统反应错误报告的噪音</h2>
<a href="https://lp.logrocket.com/blg/react-signup-issue-free" target="_blank" vwo-el-id="19356441070">LogRocket
</a><p>是一款React analytics解决方案，可保护您免受数百个误报错误警报的影响，只针对少数真正重要的项目。LogRocket告诉您React应用程序中实际影响用户的最具影响力的bug和UX问题。</p><a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="19356441380">
<img class="first-react-image alignnone size-full wp-image-46 jetpack-lazy-image jetpack-lazy-image--handled" src="../Images/f300c244a1a1cf916df8b4cb02bec6c6.png" vwo-el-id="18272717540" data-lazy-loaded="1" data-original-src="https://files.readme.io/27c94e7-Image_2017-06-05_at_9.46.04_PM.png"/>
</a>
<a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="19356441690">
<img class="second-react-image alignnone size-full wp-image-46 jetpack-lazy-image jetpack-lazy-image--handled" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" vwo-el-id="30720362350" data-lazy-loaded="1" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/>
</a>
<a href="https://lp.logrocket.com/blg/react-signup-issue-free" target="_blank" rel="noopener noreferrer" vwo-el-id="35866400580">LogRocket
</a><p>自动聚合客户端错误、反应错误边界、还原状态、缓慢的组件加载时间、JS异常、前端性能指标和用户交互。然后，LogRocket使用机器学习来通知您影响大多数用户的最具影响力的问题，并提供您修复它所需的上下文。</p><p vwo-el-id="28675661060">关注重要的React bug—<a class="signup" href="https://lp.logrocket.com/blg/react-signup-issue-free" target="_blank" rel="noopener noreferrer" vwo-el-id="40093418840">今天就试试LogRocket】。</a></p>
</div></div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
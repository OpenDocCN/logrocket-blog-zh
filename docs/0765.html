<html>
<head>
<title>Image styling and filters using WebAssembly - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>使用WebAssembly - LogRocket博客的图像样式和过滤器</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/image-styling-and-filters-using-webassembly/#0001-01-01">https://blog.logrocket.com/image-styling-and-filters-using-webassembly/#0001-01-01</a></blockquote><div><article class="article-post">
<p>WebAssembly、WebGL和WebGPU等Web解决方案的存在是为了充分利用用户目前拥有的强大计算能力。</p>
<p>WebAssembly (Wasm)是一种运行在web上的通用、低级字节码。作为低级二进制代码，它比今天浏览器附带的JavaScript引擎执行的代码更小，性能更好。</p>
<p>Wasm允许开发人员使用Rust、<a href="https://blog.logrocket.com/the-introductory-guide-to-assemblyscript/">类类型脚本编译器AssemblyScript </a>和Emscripten (C/C++)等语言进行编码，并向下编译为Wasm格式。Wasm提供了一种紧凑的二进制格式，具有可预测的性能，可以与JavaScript一起运行。它目前可以在所有主流浏览器中使用，也可以在服务器上运行。</p>
<p>如果您已经熟悉WebAssembly，请随意跳过下一节，在这一节中，我们将学习在浏览器中使用它的基础知识。</p>
<h2>热身:Wasm的你好！</h2>
<p>从我们的JavaScript执行Wasm二进制文件(反之亦然)需要一些样板代码。幸运的是，我们有<a href="https://github.com/emscripten-core/emscripten"> Emscripten编译器</a>，它为我们完成了所有繁重的工作，并为我们提供了一个JavaScript文件。</p>
<h3>设置脚本</h3>
<p>我们将使用C/C++来编写我们的Wasm代码，因此我们需要<code>emsdk</code>，它是Emscripten的工具，可以获得编译器和所有其他您需要的工具。</p>
<p><img data-attachment-id="16202" data-permalink="https://blog.logrocket.com/image-styling-and-filters-using-webassembly/attachment/activating-emsdk/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/03/activating-emsdk.png" data-orig-size="730,215" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Activating emsdk" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/03/activating-emsdk-300x88.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/03/activating-emsdk.png" decoding="async" class="aligncenter size-full wp-image-16202 jetpack-lazy-image" src="../Images/a30aa2202ab023f7886eb2b8f96a233c.png" alt="Activating emsdk" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2020/03/activating-emsdk.png 730w, https://blog.logrocket.com/wp-content/uploads/2020/03/activating-emsdk-300x88.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2020/03/activating-emsdk.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/03/activating-emsdk.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="16202" data-permalink="https://blog.logrocket.com/image-styling-and-filters-using-webassembly/attachment/activating-emsdk/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/03/activating-emsdk.png" data-orig-size="730,215" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Activating emsdk" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/03/activating-emsdk-300x88.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/03/activating-emsdk.png" decoding="async" loading="lazy" class="aligncenter size-full wp-image-16202" src="../Images/a30aa2202ab023f7886eb2b8f96a233c.png" alt="Activating emsdk" srcset="https://blog.logrocket.com/wp-content/uploads/2020/03/activating-emsdk.png 730w, https://blog.logrocket.com/wp-content/uploads/2020/03/activating-emsdk-300x88.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/03/activating-emsdk.png"/></noscript>
<p>最后一个命令设置了路径，这样它就可以找到<code>emcc</code>、Emscripten编译器工具以及我们需要的所有东西。</p>
<h3>怀旧场景:写一些C</h3>
<p>一旦编译器设置完成，让我们开始编写C代码并把它编译成Wasm。这是一个用c语言编写的hello world的小例子。</p>
<p><img data-attachment-id="16203" data-permalink="https://blog.logrocket.com/image-styling-and-filters-using-webassembly/attachment/hello-world-example-2/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/03/hello-world-example.png" data-orig-size="730,259" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Hello world example in C" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/03/hello-world-example-300x106.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/03/hello-world-example.png" decoding="async" class="aligncenter size-full wp-image-16203 jetpack-lazy-image" src="../Images/158691e7159df3fc697a8f6eaebf38eb.png" alt="Hello World Example In C" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2020/03/hello-world-example.png 730w, https://blog.logrocket.com/wp-content/uploads/2020/03/hello-world-example-300x106.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2020/03/hello-world-example.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/03/hello-world-example.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="16203" data-permalink="https://blog.logrocket.com/image-styling-and-filters-using-webassembly/attachment/hello-world-example-2/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/03/hello-world-example.png" data-orig-size="730,259" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Hello world example in C" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/03/hello-world-example-300x106.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/03/hello-world-example.png" decoding="async" loading="lazy" class="aligncenter size-full wp-image-16203" src="../Images/158691e7159df3fc697a8f6eaebf38eb.png" alt="Hello World Example In C" srcset="https://blog.logrocket.com/wp-content/uploads/2020/03/hello-world-example.png 730w, https://blog.logrocket.com/wp-content/uploads/2020/03/hello-world-example-300x106.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/03/hello-world-example.png"/></noscript>
<p>这里将为我们完成所有繁重的编译和转换工作。一个简单的<code>emcc</code>命令将返回Wasm就绪代码，用于我们的web应用程序。这是:</p>
<p><img data-attachment-id="16204" data-permalink="https://blog.logrocket.com/image-styling-and-filters-using-webassembly/attachment/running-emcc-command/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/03/running-emcc-command.png" data-orig-size="730,166" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Running the emcc command" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/03/running-emcc-command-300x68.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/03/running-emcc-command.png" decoding="async" class="aligncenter size-full wp-image-16204 jetpack-lazy-image" src="../Images/b0340c29453147a3f7e1747093d5465d.png" alt="Running The emcc Command" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2020/03/running-emcc-command.png 730w, https://blog.logrocket.com/wp-content/uploads/2020/03/running-emcc-command-300x68.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2020/03/running-emcc-command.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/03/running-emcc-command.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="16204" data-permalink="https://blog.logrocket.com/image-styling-and-filters-using-webassembly/attachment/running-emcc-command/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/03/running-emcc-command.png" data-orig-size="730,166" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Running the emcc command" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/03/running-emcc-command-300x68.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/03/running-emcc-command.png" decoding="async" loading="lazy" class="aligncenter size-full wp-image-16204" src="../Images/b0340c29453147a3f7e1747093d5465d.png" alt="Running The emcc Command" srcset="https://blog.logrocket.com/wp-content/uploads/2020/03/running-emcc-command.png 730w, https://blog.logrocket.com/wp-content/uploads/2020/03/running-emcc-command-300x68.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/03/running-emcc-command.png"/></noscript>
<p>输出文件<code>hello.js</code>可以通过使用Node:</p>
<p><img data-attachment-id="16205" data-permalink="https://blog.logrocket.com/image-styling-and-filters-using-webassembly/attachment/testing-hello-js/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/03/testing-hello.js.png" data-orig-size="730,203" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Testing the hello.js file" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/03/testing-hello.js-300x83.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/03/testing-hello.js.png" decoding="async" class="aligncenter size-full wp-image-16205 jetpack-lazy-image" src="../Images/d98b6d42fc146e329d74421e7bed6126.png" alt="Testing The hello.js File In Node" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2020/03/testing-hello.js.png 730w, https://blog.logrocket.com/wp-content/uploads/2020/03/testing-hello.js-300x83.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2020/03/testing-hello.js.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/03/testing-hello.js.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="16205" data-permalink="https://blog.logrocket.com/image-styling-and-filters-using-webassembly/attachment/testing-hello-js/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/03/testing-hello.js.png" data-orig-size="730,203" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Testing the hello.js file" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/03/testing-hello.js-300x83.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/03/testing-hello.js.png" decoding="async" loading="lazy" class="aligncenter size-full wp-image-16205" src="../Images/d98b6d42fc146e329d74421e7bed6126.png" alt="Testing The hello.js File In Node" srcset="https://blog.logrocket.com/wp-content/uploads/2020/03/testing-hello.js.png 730w, https://blog.logrocket.com/wp-content/uploads/2020/03/testing-hello.js-300x83.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/03/testing-hello.js.png"/></noscript>
<p>因为我们的目标是一个web平台，所以让它在我们的web应用程序中运行。</p>
<h2>行动时间:在我们的网络应用中执行</h2>
<p>我们写的C代码只是为了检查我们的设置是否正确。在这里，对于我们的web应用程序，让我们尝试使用Wasm计算一个给定数字的平方根。下面是我们的C代码的样子:</p>
<pre>#include &lt;math.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;

extern "C" {
  float getSqrt (float num) {
    return sqrt(num);
  }

  float getSqr (float num) {
    return num * num;
  }
}
</pre>
<p>这里，<code>extern "C"</code>块中定义的方法是可以从JS代码中访问的方法。除了将这些方法放在那个块中，我们将在编译器选项中把它们称为<code>EXPORTED_FUNCTIONS</code>。</p>
<p>我们还将在编译命令中添加一个优化级别。优化级别越高，编译代码所需的时间越长，但生成的代码性能会更好。你可以在这里阅读这些优化<a href="https://emscripten.org/docs/optimizing/Optimizing-Code.html#how-to-optimize-code">。</a></p>
<p>因此，我们的新编译命令将如下所示:</p>
<pre>emcc -o hello.js hello.cpp -Os \
-s WASM=1 \
-s EXPORTED_FUNCTIONS="['_getSqrt','_getSqr']";
</pre>
<p>由于我们将使用用所有现代JS工具构建的React应用程序，我们将调整由<code>emcc</code>生成的JS文件。我们将在JS文件的末尾发送一个<code>DoneEvent</code>,以了解Wasm和JS文件何时对我们的应用程序可用。下面是如何做到这一点:</p>
<pre>sed -i .bak 's/else{doRun()}/&amp;window.wasmScript.dispatchEvent(window.wasmDoneEvent);/' hello.js
</pre>
<p>请注意，我们已经将事件<code>wasmDoneEvent</code>添加到了<code> wasmScript</code>中。</p>
<p>现在我们的Wasm和JS包装器已经准备好了，我们可以将它们导入到React应用程序中来看看它的运行情况。这是我们加载Wasm模块的代码的样子:</p>
<pre>const WASM_URL = "./hello.wasm";
const WASM_JS_URL = "./hello.js";

const getWASMModule = () =&gt; {
  return new Promise((resolve, reject) =&gt; {
    if (!("WebAssembly" in window)) {
    console.warn("Your Browser doesn't support WASM");
        reject("Your Browser doesn't support WASM");
    }
    fetch(WASM_URL).then(response =&gt; {
      return response.arrayBuffer();
    }).then(buffer =&gt; {
      const wasmModule = new WebAssembly.Module(buffer);
      const script = document.createElement("script");

        // Adding event listener with callback
        script.addEventListener("wasmDone", buildWam);
       script.src = WASM_JS_URL;


        // Adding global script instance
       window.wasmScript = script;

       // Adding global event 
        window.wasmDoneEvent = new Event("wasmDone");
       document.body.appendChild(script);

        function buildWam() {
         Module.wasmBinary = buffer;
        console.log("Emscripten boilerplate loaded.");
        const wasmMethods = {};
        wasmMethods["getSqrt"] = function(number) {
          return _getSqrt(number);
        };
          wasmMethods["getSqr"] = function(number) {
           return _getSqr(number);
         };
         resolve(wasmMethods);
       }
    });
  });
};
</pre>
<p>正如我们所看到的，这个函数将解析为一个带有Wasm方法包装的对象。这就结束了我们在React应用程序中使用WebAssembly的基本介绍。现在让我们开始着手手头的任务。</p>
<h2>使用WebAssembly的图像过滤器</h2>
<p>让我们进入今天的焦点:使用Wasm对图像应用滤镜。我们将把我们的图像转换成一个线性数组，因为Wasm工作在线性内存上。由于每个像素的颜色都可以用RGB格式来表示，因此我们将每个像素视为一个四维RGBA(红色、绿色、蓝色和alpha)颜色空间。每个维度的范围从0到255，假设24位颜色。</p>
<h3>从JavaScript开始:获取图像数据</h3>
<p>我们将通过将图像渲染到HTML画布中来提取图像数据。看看从提供的URL获取图像数据的实用函数。</p>
<pre>function toCanvas(source) {
    if (source instanceof HTMLCanvasElement) {
        return source;
    }
    const canvas = document.createElement("canvas");
    canvas.width = source.videoWidth || source.naturalWidth || source.width;
    canvas.height = source.videoHeight || source.naturalHeight || source.height;
    canvas.getContext("2d").drawImage(source, 0, 0, canvas.width, canvas.height);
    return canvas;
}

export function getImageData({ url, width = 244, height = 224 }) {
    console.assert(url);
    return new Promise((resolve, reject) =&gt; {
        const img = new Image();
        img.crossOrigin = "anonymous";
        img.src = url;
        img.width = width;
        img.height = height;
        img.onload = function() {
            var canvas = toCanvas(img);
            resolve(
                canvas.getContext("2d").getImageData(0, 0, canvas.width, canvas.height)
            );
        };
        img.onerror = function(e) {
            reject(e);
        };
    });
}
</pre>
<p>这个方法创建一个新的<code>Image</code>对象，一旦图像被加载，它将在画布上绘制图像。从canvas中，它返回线性数组的图像数据，其中数组的每四个元素代表一个像素的红色、绿色、蓝色和alpha通道。</p>
<h3>大众</h3>
<p>在Wasm端，我们将收到一个从canvas中提取的线性数组形式的图像。Wasm代码将对图像的每个像素进行更改，以应用不同的滤镜。让我们来看看一个灰度效果的实现。</p>
<pre>void grayScale (unsigned char* data, int len) {
  for (int i = 0; i &lt; len; i += 4) {
    int r = data[i];
    int g = data[i+1];
    int b = data[i+2];
    int a = data[i+3];
    data[i] = r;
    data[i+1] = r;
    data[i+2] = r;
    data[i+3] = a;
  }
}
</pre>
<p>上面的方法以数组的形式接收图像及其长度。它遍历所有像素，并将其绿色和蓝色通道设置为与红色相同，以创建灰度效果。</p>
<h3>进出Wasm的图像数据</h3>
<p>跨WebAssembly和JavaScript共享内存不是一件容易的事情。谢天谢地，Emscripten为我们做了所有繁重的工作。它公开了为Wasm分配和释放内存的<code>_malloc </code>和<code>_free</code>方法。我们将把JS数组转换成无符号整数数组，并将其复制到为Wasm分配的内存中。下面是我们的代码在JS端的样子:</p>
<pre>function(imageData) {
  const { length } = imageData;
  const memory = _malloc(length); // Allocating WASM memory
  HEAPU8.set(imageData, memory); // Copying JS image data to WASM memory
  _grayScale(memory, length); // Calling WASM method
  const filteredImageData = HEAPU8.subarray(memory, memory + length); // Converting WASM data to JS Image data
  _free(memory); // Freeing WASM memory
  return filteredImageData;
};
</pre>
<h3>渲染带效果的图像</h3>
<p>答对了。该图像数据可用于渲染具有该效果的图像。这是如何做到的:</p>
<pre>function writeImageDataToCanvas(canvas, data, width, height) {
    canvas.width = width;
    canvas.height = height;
    var context = canvas.getContext("2d");
    var imageData = context.createImageData(width, height);
    imageData.data.set(data);
    context.putImageData(imageData, 0, 0);
    return canvas;
}
</pre>
<h2>多一些效果</h2>
<p>为了更好的理解上下文，这里有更多的效果。</p>
<h3>转化的</h3>
<p>反转效果与JS侧的灰度效果相同。它将遵循相同的步骤，但是Wasm方法的<code>_grayscale</code>调用将被替换为<code>_invert</code>。下面是这种效果的Wasm实现:</p>
<pre>void invert (unsigned char* data, int len) {
  for (int i = 0; i &lt; len; i += 4) {
    data[i] = 255 - data[i]; //r
    data[i+1] = 255 - data[i+1]; //g
    data[i+2] = 255 - data[i+2]; //b
  }
}
</pre>
<h3>噪音</h3>
<p>很少有图像过滤器需要将通道处理为浮点值，但噪声是其中之一。对于这种过滤器，我们将转换我们的图像数据阵列以及其他所需的变化。该过滤器的JS端将是:</p>
<pre>function(imageData) {
  const { length } = imageData;
  const memory = _malloc(length * Float32Array.BYTES_PER_ELEMENT);
  HEAPF32.set(imageData, memory / Float32Array.BYTES_PER_ELEMENT);
  _noise(memory, length);
  const filtered = HEAPF32.subarray(
    memory / Float32Array.BYTES_PER_ELEMENT,
    memory / Float32Array.BYTES_PER_ELEMENT + length
  );
  _free(memory);
  return filtered;
};
</pre>
<p>而Wasm部分看起来像这样:</p>
<pre>  void noise (float* data, int len) {
    int random; 
    for (int i = 0; i &lt; len; i += 4) {
      random = (rand() % 70) - 35;
      data[i] = data[i] + random; //r
      data[i+1] = data[i+1] + random; //g
      data[i+2] = data[i+2] + random; //b
    }
  }
</pre>
<h3>使变亮</h3>
<p>这个滤镜类似于反转和灰度，除了它需要一个额外的亮度参数。以下是Wasm的实现:</p>
<pre>void brighten (unsigned char* data, int len, int brightness) {
    for (int i = 0; i &lt; len; i += 4) {
      data[i]   + brightness &gt; 255 ? 255 : data[i]   += brightness;
      data[i+1] + brightness &gt; 255 ? 255 : data[i+1] += brightness;
      data[i+2] + brightness &gt; 255 ? 255 : data[i+2] += brightness;
    }
}
</pre>
<h2>包装它</h2>
<p>如果充分利用其潜力，WebAssembly毫无疑问可以彻底改变现代前端。通过使用线性内存和适当的数据结构，Wasm可以以比JS更高效的方式执行CPU密集型任务。</p>
<p>尽管Wasm还很不成熟，但它最近已经取得了一些重大进展。像Emscripten这样的工具做了很多繁重的工作，使Wasm更容易，更容易被许多前端开发人员使用。</p><div class="code-block code-block-54">
<hr/>
<h3>更多来自LogRocket的精彩文章:</h3>

<hr/></div>
<p>虽然Wasm在Go、Rust和AssemblyScript中也可用，但我们在用例中使用了C++。对于许多开发人员来说，这种多种多样的选项使其更加直观。在Wasm和WebGL等技术的帮助下，这十年将会看到更强大的前端和复杂的体验，这些技术让网络变得伟大！</p>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
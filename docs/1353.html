<html>
<head>
<title>Rust and gRPC: A complete guide - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>Rust和gRPC:一个完整的指南</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/rust-and-grpc-a-complete-guide/#0001-01-01">https://blog.logrocket.com/rust-and-grpc-a-complete-guide/#0001-01-01</a></blockquote><div><article class="article-post">
<p>gRPC是Google开发的开源远程过程调用系统。gRPC允许系统在数据中心内外进行通信，有效地将数据从移动设备、物联网设备和后端传输到其他设备。</p>
<p/>
<p>gRPC附带了对负载平衡、认证、跟踪等的可插拔支持。，支持HTTP/2上的双向流，并提供了10种语言的惯用实现。</p>
<p>此外，gRPC可以生成高效的客户端库，并使用协议缓冲区格式通过网络传输数据。协议缓冲区是用于数据传输的二进制格式。因为协议缓冲区是二进制的，所以可以快速序列化。每个消息的结构必须预先定义。</p>
<h2 id="grpcsupportinrustlang">防锈gRPC支架</h2>
<p>Rust社区开发了许多gRPC实现，特别是<code>tonic</code>和<code>grpc</code>机箱。两者都提供了gRPC协议的完整实现。</p>
<h3 id="tonichttpscratesiocratestonic">什么是<code>tonic</code>？</h3>
<p><a href="https://crates.io/crates/tonic" target="_blank" rel="noopener noreferrer"> <code>tonic</code> </a>是一个快速生产就绪的gRPC库，开箱即可支持异步/等待。它注重灵活性和可靠性。<code>tonic</code>通过HTTP/2全面实施gRPC协议。<code>tonic</code>内置了对Rustlang编译协议缓冲区的支持。它还支持单向和双向流。</p>
<h3 id="grpchttpscratesiocratesgrpc">什么是<code>grpc</code>？</h3>
<p><a href="https://crates.io/crates/grpc" target="_blank" rel="noopener noreferrer"> <code>grpc</code> </a>还没有做好生产准备但值得关注。机箱有一个有效的gRPC协议实现，并支持TLS。</p>
<p>为了展示<code>tonic</code>和<code>grpc</code>的作用，我们来创建一个演示gRPC应用程序。</p>
<h2 id="creatingagrpcappusingtonic">使用<code>tonic</code>构建gRPC应用程序</h2>
<p>我们将从使用<code>cargo new grpc-demo-tonic</code>创建一个Rust项目开始。创建<code>src/server.rs</code>和<code>src/client.rs</code>来分别保存gRPC服务器和客户端的代码。我们将添加一个<code>build.rs</code>来编译协议缓冲区。</p>
<p>一些基本的样板文件，比如<code>build.rs</code>，是编译协议缓冲区对代码进行Rust所必需的。还需要对<code>Cargo.toml</code>和文件结构进行一些更改。</p>
<p><code>Cargo.toml</code>:</p>
<pre>[package]
name = "grpc-demo-tonic"
version = "0.1.0"
authors = ["anshul &lt;<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="9dfcf3eef5e8f1faf2f8f1aca8aca4a4a4ddfaf0fcf4f1b3fef2f0">[email protected]</a>&gt;"]
edition = "2018"

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[dependencies]

# server binary
[[bin]]
    name = "server"
    path = "src/server.rs"

# client binary
[[bin]]
    name = "client"
    path = "src/client.rs"
</pre>
<p><em>文件结构</em></p>
<pre>├── build.rs
├── Cargo.lock
├── Cargo.toml
├── src
    ├── client.rs
    └── server.rs
</pre>
<p>首先创建一个协议缓冲文件。</p>
<pre>    // version of protocol buffer used
    syntax = "proto3";

    // package name for the buffer will be used later
    package hello;

    // service which can be executed
    service Say {
    // function which can be called
      rpc Send (SayRequest) returns (SayResponse);
    }

    // argument
    message SayRequest {
    // data type and position of data
      string name = 1;
    }

    // return value
    message SayResponse {
    // data type and position of data
      string message = 1;
    }



We can include generated rust code in-app using `tonic`. Let’s create an `hello.rs` file to reuse in both server and client.

    // this would include code generated for package hello from .proto file
    tonic::include_proto!("hello");
</pre>
<h3 id="creatingserver">使用<code>tonic</code>创建gRPC服务器</h3>
<p>通过为结构实现<code>Say</code>特征来创建服务。该服务可能包括多个RPC。由于Rust不支持异步特征，我们必须使用一个<code>asyc_trait</code>宏来克服这个限制。</p>
<p>将以下代码添加到<code>server.rs</code>。</p>
<pre>    use tonic::{transport::Server, Request, Response, Status};
    use hello::say_server::{Say, SayServer};
    use hello::{SayResponse, SayRequest};
    mod hello; 

    // defining a struct for our service
    #[derive(Default)]
    pub struct MySay {}

    // implementing rpc for service defined in .proto
    #[tonic::async_trait]
    impl Say for MySay {
    // our rpc impelemented as function
        async fn send(&amp;self,request:Request&lt;SayRequest&gt;)-&gt;Result&lt;Response&lt;SayResponse&gt;,Status&gt;{
    // returning a response as SayResponse message as defined in .proto
            Ok(Response::new(SayResponse{
    // reading data from request which is awrapper around our SayRequest message defined in .proto
                 message:format!("hello {}",request.get_ref().name),
            }))
        }
    }

    #[tokio::main]
    async fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    // defining address for our service
        let addr = "[::1]:50051".parse().unwrap();
    // creating a service
        let say = MySay::default();
        println!("Server listening on {}", addr);
    // adding our service to our server.
        Server::builder()
            .add_service(SayServer::new(say))
            .serve(addr)
            .await?;
        Ok(())
    }
</pre>
<p>上面的例子使用<code>tokio</code>作为异步运行时和执行器。这个<code>MySay</code>结构实现了服务<code>Say</code>。由<code>tonic</code>提供的<code>Server</code>类型接受服务并在给定的地址上创建一个支持gRPC协议的HTTP服务器。</p>
<h3 id="creatingclient">使用<code>tonic</code>创建gRPC客户端</h3>
<p>因为gRPC以机器可读的格式定义请求和响应，所以我们不需要实现客户端代码。协议缓冲区编译器生成的代码已经包含了您可以通过直接导入来使用的客户端代码。</p>
<pre>use hello::say_client::SayClient;
use hello::SayRequest;
mod hello;
#[tokio::main]
async fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
// creating a channel ie connection to server
    let channel = tonic::transport::Channel::from_static("http://[::1]:50051")
    .connect()
    .await?;
// creating gRPC client from channel
    let mut client = SayClient::new(channel);
// creating a new Request
    let request = tonic::Request::new(
        SayRequest {
           name:String::from("anshul")
        },
    );
// sending request and waiting for response
    let response = client.send(request).await?.into_inner();
    println!("RESPONSE={:?}", response);
    Ok(())
}
</pre>
<p><img data-attachment-id="29718" data-permalink="https://blog.logrocket.com/rust-and-grpc-a-complete-guide/output-cargo-run-bin-server/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/11/output-cargo-run-bin-server.png" data-orig-size="523,139" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Output for cargo run–bin client" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/11/output-cargo-run-bin-server-300x80.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/11/output-cargo-run-bin-server.png" decoding="async" class="aligncenter size-full wp-image-29718 jetpack-lazy-image" src="../Images/c67335b9169da838f98a1a49ae1e4dd7.png" alt="Output for cargo run–bin client" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2020/11/output-cargo-run-bin-server.png 523w, https://blog.logrocket.com/wp-content/uploads/2020/11/output-cargo-run-bin-server-300x80.png 300w" data-lazy-sizes="(max-width: 523px) 100vw, 523px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2020/11/output-cargo-run-bin-server.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/11/output-cargo-run-bin-server.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="29718" data-permalink="https://blog.logrocket.com/rust-and-grpc-a-complete-guide/output-cargo-run-bin-server/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/11/output-cargo-run-bin-server.png" data-orig-size="523,139" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Output for cargo run–bin client" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/11/output-cargo-run-bin-server-300x80.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/11/output-cargo-run-bin-server.png" decoding="async" loading="lazy" class="aligncenter size-full wp-image-29718" src="../Images/c67335b9169da838f98a1a49ae1e4dd7.png" alt="Output for cargo run–bin client" srcset="https://blog.logrocket.com/wp-content/uploads/2020/11/output-cargo-run-bin-server.png 523w, https://blog.logrocket.com/wp-content/uploads/2020/11/output-cargo-run-bin-server-300x80.png 300w" sizes="(max-width: 523px) 100vw, 523px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/11/output-cargo-run-bin-server.png"/></noscript>
<p>为了测试我们的小应用程序，运行<code>cargo run --bin server</code>，然后运行<code>cargo run --bin client</code>。</p>
<h2 id="creatingagrpcappusinggrpc">使用<code>grpc</code>构建gRPC应用程序</h2>
<p>首先，使用<code>cargo new grpc-demo-grpc</code>创建一个Rust项目。我们需要添加两个二进制文件:服务器和客户端，就像在<code>tonic</code>演示中一样。我们还必须添加<code>proto/hello.proto</code>文件和<code>build.rs</code></p>
<p><code>Cargo.toml</code>:</p>
<pre>[package]
name = "grpc-demo-grpc"
version = "0.1.0"
authors = ["anshul &lt;<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="c3a2adb0abb6afa4aca6aff2f6f2fafafa83a4aea2aaafeda0acae">[email protected]</a>&gt;"]
edition = "2018"

[[bin]]
name="server"
path="./src/server.rs"

[[bin]]
name="client"
path="./src/client.rs"


[dependencies]
protobuf        = "2"
httpbis         = { git = "https://github.com/stepancheg/rust-http2" }
grpc ="*"
grpc-protobuf="*"

[build-dependencies]
protoc-rust-grpc = "0.8.2"
</pre>
<p><code>build.rs</code>:</p>
<p><code>protoc_rust_grpc</code>需要<code>protoc</code>编译器中的路径变量。可以从<a href="https://grpc.io/docs/protoc-installation/">官网</a>下载。</p>
<pre>fn main() {
    // compile protocol buffer using protoc
    protoc_rust_grpc::Codegen::new()
    .out_dir("src")
    .input("./proto/hello.proto")
    .rust_protobuf(true)
    .run()
    .expect("error compiling protocol buffer");
}
</pre>
<h3 id="creatingserver-1">使用<code>grpc</code>创建服务器</h3>
<p><code>grpc</code>板条箱的API与<code>tonic</code>板条箱的API非常相似。和<code>tonic</code>一样，<code>grpc</code>为gRPC通信生成代码。</p>
<p>为了创建服务，<code>Say</code>特征是在<code>struct</code>上实现的。被实现的<code>struct</code>被传递给由<code>grpc</code>机箱提供的<code>ServerBuilder</code>上的<code>add_server</code>方法。</p>
<pre>use grpc::{ServerHandlerContext,ServerRequestSingle,ServerResponseUnarySink};
// importing generated gRPC code
use hello_grpc::*;
// importing types for messages
use hello::*;
mod hello;
mod hello_grpc;
struct MySay;
impl Say for MySay {
    // rpc for service
    fn send(
        &amp;self,
        _: ServerHandlerContext,
        req: ServerRequestSingle&lt;SayRequest&gt;,
        resp: ServerResponseUnarySink&lt;SayResponse&gt;,
    ) -&gt; grpc::Result&lt;()&gt; {
        // create Response
        let mut r = SayResponse::new();
        let name = if req.message.get_name().is_empty() {
            "world"
        } else {
            req.message.get_name()
        };
        // sent the response
        println!("greeting request from {}", name);
        r.set_message(format!("Hello {}", name));
        resp.finish(r)
    }
}


fn main() {

    let port =50051;
    // creating server
    let mut server = grpc::ServerBuilder::new_plain();
    // adding port to server for http
    server.http.set_port(port);
    // adding say service to server
    server.add_service(SayServer::new_service_def(MySay));
    // running the server
    let _server = server.build().expect("server");
    println!(
        "greeter server started on port {}",
        port,
    );
    // stopping the program from finishing
    loop {
        std::thread::park();
    }
}
</pre>
<h3>使用<code>grpc</code>创建客户端</h3>
<p>进行RPC调用就像创建客户机和发送数据一样简单。您只需创建一个请求并通过客户端发送它，然后等待响应。</p>
<pre>use std::env;
use std::sync::Arc;

// importing generated gRPC code
use hello_grpc::*;
// importing types for messages
use hello::*;
mod hello;
mod hello_grpc;

use grpc::ClientStub;
use grpc::ClientStubExt;
use futures::executor;
fn main() {

    let name = "anshul";
    let port =50051;
    let client_conf = Default::default();
// create a client
    let client=SayClient::new_plain("::1", port, client_conf).unwrap();
// create request
    let mut req = SayRequest::new();
    req.set_name(name.to_string());
// send the request
    let resp = client
        .send(grpc::RequestOptions::new(), req)
        .join_metadata_result();
// wait for response
    println!("{:?}", executor::block_on(resp));
}
</pre>
<p><img data-attachment-id="29717" data-permalink="https://blog.logrocket.com/rust-and-grpc-a-complete-guide/rpc-call-response/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/11/rpc-call-response.png" data-orig-size="720,61" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="RPC call response" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/11/rpc-call-response-300x25.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/11/rpc-call-response.png" decoding="async" class="aligncenter size-full wp-image-29717 jetpack-lazy-image" src="../Images/68688fc2cbb1094bcebbd4cd76f62740.png" alt="RPC Call Response" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2020/11/rpc-call-response.png 720w, https://blog.logrocket.com/wp-content/uploads/2020/11/rpc-call-response-300x25.png 300w" data-lazy-sizes="(max-width: 720px) 100vw, 720px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2020/11/rpc-call-response.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/11/rpc-call-response.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="29717" data-permalink="https://blog.logrocket.com/rust-and-grpc-a-complete-guide/rpc-call-response/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/11/rpc-call-response.png" data-orig-size="720,61" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="RPC call response" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/11/rpc-call-response-300x25.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/11/rpc-call-response.png" decoding="async" loading="lazy" class="aligncenter size-full wp-image-29717" src="../Images/68688fc2cbb1094bcebbd4cd76f62740.png" alt="RPC Call Response" srcset="https://blog.logrocket.com/wp-content/uploads/2020/11/rpc-call-response.png 720w, https://blog.logrocket.com/wp-content/uploads/2020/11/rpc-call-response-300x25.png 300w" sizes="(max-width: 720px) 100vw, 720px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/11/rpc-call-response.png"/></noscript>
<h2 id="conclusion">结论</h2>
<p>Rust对gRPC有极好的支持。特别是一个快速的、生产就绪的gRPC实施。</p>
<p>在本教程中，我们学习了如何使用<code>tonic</code>和<code>grpc</code>板条箱创建gRPC应用程序。我们探索了协议缓冲区，并演练了如何编译它来信任代码。</p>
<p><code>tonic</code>和<code>grpc</code>都支持使用<code>nativetls</code>机箱进行基于TLS的认证。这只是冰山一角；<code>tonic</code>和<code>grpc</code>都几乎完全实现了错误处理、负载平衡和认证。</p>
<p>这里有一个快速的视觉对比:</p>
<table>
<tbody>
<tr>
<td><strong>功能</strong></td>
<td><strong>T2<code>tonic</code></strong></td>
<td><strong>T2<code>grpc</code></strong></td>
</tr>
<tr>
<td>生产就绪</td>
<td>是</td>
<td>不</td>
</tr>
<tr>
<td>完全异步/等待支持</td>
<td>是</td>
<td>不</td>
</tr>
<tr>
<td>请求和响应流</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>基于TLS的身份验证</td>
<td>是</td>
<td>是</td>
</tr>
</tbody>
</table>
<p><a href="https://lp.logrocket.com/blg/rust-signup" target="_blank">log rocket</a>:Rust应用的web前端的全面可见性</p><div class="code-block code-block-29">
<div class="blog-plug inline-plug rust-plug"><h2>调试Rust应用程序可能很困难，尤其是当用户遇到难以重现的问题时。如果您对监控和跟踪Rust应用程序的性能、自动显示错误、跟踪缓慢的网络请求和加载时间感兴趣，</h2><p>. </p><a href="https://lp.logrocket.com/blg/rust-signup" target="_blank">try LogRocket</a><p>LogRocket 就像是网络和移动应用程序的DVR，记录你的Rust应用程序上发生的一切。您可以汇总并报告问题发生时应用程序的状态，而不是猜测问题发生的原因。LogRocket还可以监控应用的性能，报告客户端CPU负载、客户端内存使用等指标。</p><a class="signup" href="https://lp.logrocket.com/blg/rust-signup" target="_blank" rel="noopener noreferrer"><img class="alignnone size-full wp-image-46 jetpack-lazy-image" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/><noscript><img data-lazy-fallback="1" class="alignnone size-full wp-image-46" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/></noscript></a><p>现代化调试Rust应用的方式— <a class="signup" href="https://lp.logrocket.com/blg/rust-signup" target="_blank" rel="noopener noreferrer">开始免费监控</a>。</p><p>Modernize how you debug your Rust apps — <a class="signup" href="https://lp.logrocket.com/blg/rust-signup" target="_blank" rel="noopener noreferrer">start monitoring for free</a>.</p></div>


</div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
<html>
<head>
<title>What’s coming in Babel 8 - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>巴别塔8 - LogRocket博客有什么消息</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/whats-coming-in-babel-8/#0001-01-01">https://blog.logrocket.com/whats-coming-in-babel-8/#0001-01-01</a></blockquote><div><article class="article-post">
<p>TC39 ( <a href="https://www.ecma-international.org/memento/tc39-rf-tg.htm" target="_blank" rel="noopener noreferrer">技术委员会39</a>——在“ECMAScript”规范下对JavaScript语言进行标准化的机构)发布了JavaScript的ES2015版本，俗称ES6。开发人员越来越多地采用ES6，但浏览器并不支持ES2015的所有功能，因此需要工具来使用JavaScript编程语言的最新功能。</p>
<p>最初名为<a href="https://babeljs.io/blog/2015/02/15/not-born-to-die" target="_blank" rel="noopener noreferrer"> 6to5 </a>的Babel 正是做到了这一点——它使得将ES6代码转换成可以由旧的JavaScript引擎运行的向后兼容版本成为可能。将一种语言编写的代码编译成同一种语言的另一种形式的过程称为Transpiling(转换+编译)，在这种情况下，将ES6+编写的JavaScript代码转换成ES5。</p>
<h2>巴别塔是什么？</h2>
<p>根据平台<a href="https://babeljs.io/docs/en/index.html" target="_blank" rel="noopener noreferrer">官方文件</a>:</p>
<blockquote><p>Babel是一个工具链，主要用于将ECMAScript 2015+代码转换为当前和旧版本浏览器或环境中向后兼容的JavaScript版本</p></blockquote>
<p>Babel是一个JavaScript transpiler，它提供了旧环境中JavaScript语言的新特性。它提供了可用的<a href="https://babeljs.io/docs/en/presets" target="_blank" rel="noopener noreferrer">预置</a>和<a href="https://babeljs.io/docs/en/plugins" target="_blank" rel="noopener noreferrer">插件</a>，使代码转换、语法转换和多填充功能成为可能，这些功能在您的目标环境中是不存在的。</p>
<p>在这篇文章中，我们将会看到巴别塔工具的第8版在之前版本的一些特性和改进。</p>
<h2>新JSX变换</h2>
<p>在这个<a href="https://github.com/reactjs/rfcs/blob/createlement-rfc/text/0000-create-element-changes.md" target="_blank" rel="noopener noreferrer"> RFC </a>中的React团队已经提供了创建JSX元素的新方法，并简化了<code>React.createElement()</code>的工作方式。</p>
<p>巴别塔8将包括一个新的<a href="https://github.com/reactjs/rfcs/blob/createlement-rfc/text/0000-create-element-changes.md" target="_blank" rel="noopener noreferrer"> JSX变换</a>，这将使JSX元素<a href="https://babeljs.io/docs/en/babel-preset-react" target="_blank" rel="noopener noreferrer">的创建和实例化在React和React-like库中得到相当大的改进。</a></p>
<p>这个新的转换将支持<code>React.jsx</code>而不是<code>React.createElement</code>。它还会在需要的时候自动导入<code>"react"</code>，这样你就不用手动导入<code>"react"</code>了。</p>
<p>这种转换还具有以下行为:</p>
<ul>
<li>把孩子当作道具而不是明确的论据</li>
<li>单独传递<code>key</code>作为显式参数，而不是通过道具</li>
<li>处于开发模式<ul>
<li>传递一个标志来确定它是否是静态的</li>
<li>与其他道具分开传递<code>__source</code>和<code>__self</code></li>
</ul>
</li>
</ul>
<pre>React.createElement(type, props, children)</pre>
<p>成为</p>
<pre>React.jsx(type, props, key)</pre>
<p>例如，该输入:</p>
<pre>function Foo() {
  return &lt;div /&gt;;
}</pre>
<p>会变成:</p>
<pre>import { jsx as _jsx } from "react/jsx-runtime";
function Foo() {
  return _jsx("div", ...);
}</pre>
<p>您可以通过将<code>{ "runtime": "automatic" }</code>(相对于<code>"classic"</code>)传递给<code>@babel/preset-react</code>(或<code>@babel/plugin-transform-react-jsx</code>)来启用这个新的转换:</p>
<pre>{
  "presets": [
    ["@babel/preset-react", {
      "runtime": "automatic"
    }]
  ]
}</pre>
<p>从巴别塔8开始，<code>"automatic"</code>将是默认运行时。</p>
<p>您还可以通过安装<a href="https://reactjs.org/blog/2019/10/22/react-release-channels.html#experimental-channel" target="_blank" rel="noopener noreferrer">实验版</a>来尝试React中用于实例化JSX元素的新功能，因为它尚未在稳定版中提供:</p>
<pre>npm install <a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="acdec9cdcfd8ecc9d4dcc9dec5c1c9c2d8cdc0">[email protected]</a> <a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="1765727674633a73787a57726f6772657e7a727963767b">[email protected]</a></pre>
<h2>完全支持TypeScript 3.8</h2>
<p>此版本还将包括对<a href="https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-8.html" target="_blank" rel="noopener noreferrer"> TypeScript 3.8 </a>的全面支持，该版本引入了显式的仅类型导入和导出(即<code>export type { foo }</code>)，在Babel的第8版中，您将能够显式地将导入和导出标记为仅类型:</p>
<pre>import type { SomeThing } from "./some-module.js";

export type { SomeThing };</pre>
<p>这将允许Babel安全地决定哪些导入或导出用于类型，哪些用于值。</p>
<h2>使用流/类型脚本时维护类字段</h2>
<p>这个特性会让Babel忽略未初始化的类字段，如果流插件在类属性插件之前运行，或者类属性插件没有使用，就会发生这种情况。</p>
<p>Babel目前转换如下声明的代码:</p>
<pre>class Foo { x: string }</pre>
<p>成为:</p>
<pre>class Foo {}</pre>
<p>这个特性在版本8中将会看到相同代码:</p>
<pre>class Foo { x }</pre>
<p>希望保持旧行为的用户可以使用流评论(如<a href="https://github.com/facebook/flow/issues/6811#issuecomment-496808192" target="_blank" rel="noopener noreferrer">官方推荐的</a>):</p>
<pre>class Bar extends Foo {
  x: ?number;
  /*:: y: number; */
}</pre>
<p>或者使用添加到类属性插件(<a href="https://github.com/babel/babel/pull/9141" target="_blank" rel="noopener noreferrer"> #9141 </a>)的<code>ignoreUninitialized</code>选项。</p>
<h2>放弃对<code>core-js 2</code>的支持</h2>
<p>Babel将不再支持版本2的core-js，这是JavaScript标准库的一个聚合填充，支持最新的ECMAScript标准和库提议。</p>
<p>Babel将放弃对它的支持，因为它在V8浏览器引擎(最流行的JavaScript引擎和支持Chrome的引擎)上引入了去优化。这个问题会影响正则表达式、迭代器、一些数组方法、类型化数组、promises，有时会导致大约100倍的性能下降。</p>
<p>巴别塔8将使用<a href="https://github.com/zloirock/core-js/blob/master/docs/2019-03-19-core-js-3-babel-and-a-look-into-the-future.md" target="_blank" rel="noopener noreferrer"> core-js版本3 </a>。</p>
<h2>使用useSpread变换JSX扩散属性</h2>
<p>这个特性改变了<code>transform-react-jsx</code>插件的当前行为，它通过使用巴别塔的<code>extend</code>助手或者调用<code>Object.assign</code>来处理道具传播<code>{...Props}</code>。使用此功能，您现在可以使用spread运算符将此类实例转换为内嵌对象。</p>
<p>根据<a href="https://github.com/babel/babel/pull/10572" target="_blank" rel="noopener noreferrer">文档</a>，您可以使用<code>@babel/preset-react</code>或<code>@babel/plugin-transform-react-jsx</code>的<code>useSpread</code>选项来启用它:</p>
<pre>{
 presets: [
  ["@babel/react", { useSpread: true }]
  ]
}</pre>
<p>如果您的代码需要在不支持对象传播的环境中运行，您可以使用<code>@babel/preset-env</code>(推荐)或<code>@babel/plugin-proposal-object-rest-spread</code>。</p>
<p>如果你想将<code>Object.assign</code>下传到Babel的<code>_extends</code>助手(这是当前的默认行为)，你还需要启用<code>@babel/plugin-transform-object-assign</code>。</p>
<h2>禁用子模块导出</h2>
<p>Babel 8将不允许导入不同包的内部文件，它将在每个包中添加<code>exports: false</code>,明确声明每个包不提供子模块导出。</p>
<p>尝试类似<code>import "@babel/core/src/config"</code>的东西会失败，因为这个文件属于内部实现细节。</p>
<h2><code>Declare</code>流程中的字段</h2>
<p>流团队为类字段添加了对<code>declare</code>修饰符的支持，因为类字段提议指定未初始化的类字段被初始化为<code>undefined</code>。这与巴别塔对心流的处理截然不同，它只是忽略了它们。</p>
<p>Babel 8在类字段中包含对<code>declare</code>关键字的支持:</p>
<pre>class Foo {
  x: ?string; // A "real" field
  declare y: number; // A type-only field
}</pre>
<h2>入门指南</h2>
<p>让我们看看如何在我们的项目中开始使用Babel。</p>
<p>本教程假设读者具备以下条件:</p>

<p>安装<a href="https://babeljs.io/docs/en/babel-cli" target="_blank" rel="noopener noreferrer"> Babel CLI </a>工具，这个工具允许我们从命令行编译JavaScript文件。</p>
<p>我们可以通过运行以下命令在本地安装Babel CLI:</p>
<pre>#Using NPM
npm install --save-dev @babel/core @babel/cli

#Using Yarn
yarn add -D @babel/core @babel/cli</pre>
<p>运行这个命令后，您应该会看到在您的<code>package.json</code>文件中作为<code>devDependencies</code>添加的包。</p>
<p>要编译文件，请运行命令</p>
<pre>npx babel filename.js</pre>
<p>或者，如果希望将编译后的代码输出到文件中，也可以运行以下命令:</p>
<pre>npx babel filename.js -o compiled-filename.js</pre>
<p>你也可以使用<a href="https://babeljs.io/repl" target="_blank" rel="noopener noreferrer">在线回复</a>来编译你的代码。</p>
<h2>结论</h2>
<p>为了减轻开发人员从Babel 5迁移到Babel 6，然后从Babel 6迁移到Babel 7的痛苦。Babel 8将只包含一些突破性的变化，并为它们提供一个简单的迁移策略。</p>
<p>Babel 8目前完成了不到50%，没有设定的到期日期，预计将在8.0.0中首次出现突破性的变化，然后将在同一天发布一个次要版本，其中将包含所有错误修复和新功能，否则将在8.0.0中发布。</p>
<p>Babel是一个重要的工具，几乎每一个JavaScript工具都依赖于它，你可以阅读<a href="https://github.com/babel/babel/issues/10746" target="_blank" rel="noopener noreferrer">发布计划</a>并查看预计将发布的其他功能<a href="https://github.com/babel/babel/milestone/16" target="_blank" rel="noopener noreferrer"/>。</p>
<p>你怎么想呢?哪些新功能让你印象深刻？请在评论区告诉我。</p><div class="code-block code-block-2">
<div class="blog-plug base-cta"><h2>使用<a class="signup" href="https://lp.logrocket.com/blg/signup" target="_blank" rel="noopener noreferrer"> LogRocket </a>消除传统错误报告的干扰</h2>
<a href="https://lp.logrocket.com/blg/signup" class="signup" target="_blank" rel="noopener noreferrer"><img class="alignnone size-full wp-image-46 jetpack-lazy-image" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/><noscript><img data-lazy-fallback="1" class="alignnone size-full wp-image-46" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/></noscript></a>
<p><a href="https://lp.logrocket.com/blg/signup" target="_blank" rel="noopener noreferrer"> LogRocket </a>是一个数字体验分析解决方案，它可以保护您免受数百个假阳性错误警报的影响，只针对几个真正重要的项目。LogRocket会告诉您应用程序中实际影响用户的最具影响力的bug和UX问题。</p>
<p>然后，使用具有深层技术遥测的会话重放来确切地查看用户看到了什么以及是什么导致了问题，就像你在他们身后看一样。</p>

<p>LogRocket自动聚合客户端错误、JS异常、前端性能指标和用户交互。然后LogRocket使用机器学习来告诉你哪些问题正在影响大多数用户，并提供你需要修复它的上下文。</p>
<p>关注重要的bug—<a class="signup" href="https://lp.logrocket.com/blg/signup-issue-free" target="_blank" rel="noopener noreferrer">今天就试试LogRocket】。</a></p></div></div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
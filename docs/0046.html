<html>
<head>
<title>How to control your deployments and versioning with semantic-release &amp; friends - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>如何使用semantic-release &amp; friends-log rocket博客控制您的部署和版本控制</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/never-guess-about-project-history-again-31f65091f668/#0001-01-01">https://blog.logrocket.com/never-guess-about-project-history-again-31f65091f668/#0001-01-01</a></blockquote><div><article class="article-post">
<p><em>不再猜测项目历史</em></p>
<figure><img decoding="async" src="../Images/2330ad08b19c8ff92dc381a7e4259f87.png" data-height="628" data-width="1198" data-lazy-src="https://storage.googleapis.com/blog-images-backup/1*-0hawDLsHJI19yFsuGHU9Q.jpeg?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" class=" jetpack-lazy-image" data-original-src="https://storage.googleapis.com/blog-images-backup/1*-0hawDLsHJI19yFsuGHU9Q.jpeg"/><noscript><img data-lazy-fallback="1" decoding="async" src="../Images/2330ad08b19c8ff92dc381a7e4259f87.png" data-height="628" data-width="1198" data-original-src="https://storage.googleapis.com/blog-images-backup/1*-0hawDLsHJI19yFsuGHU9Q.jpeg"/></noscript></figure>
<p>当谈到软件开发的生产力时，知识就是力量。项目管理工具行业——帮助开发团队了解他们所处的位置——是巨大的。但是软件开发人员有一个未被充分利用的工具，可以用来提供更多的信息——<strong>版本控制。</strong></p>
<p>软件项目的生命被<em>发布</em>打断。在开放源码中，它们可以发布给包管理器。在软件商店中，我们通常谈论的是生产服务器的部署。</p>
<p>不管它们是什么，对于发布来说非常有用的知识是<em>它们何时</em>发生以及<em>它们包含了什么</em>。在一个足够大的项目中，保留变更日志和标记发布是很常见的，但是当你不得不<a href="https://en.wikipedia.org/wiki/Release_early,_release_often" target="_blank" rel="noopener noreferrer">尽早发布并且经常发布</a>的时候，谁有时间做这些呢？</p>
<p>通常，它看起来像这样:</p>
<p>上一次发布发生在一周前，现在我们已经完成了一个新的、必要的特性，让我们再做一个。</p>
<p>还有什么发生了变化，总体变化的规模/影响有多大，这个问题仍然没有答案。实质上，我们只是希望我们没有忘记任何重要的事情。</p>
<figure><a href="https://logrocket.com/for/bug-tracking-tools/" target="_blank" rel="noopener noreferrer"><img decoding="async" class="alignnone jetpack-lazy-image" src="../Images/94b3e0f84b30cb0d321f60471481ab64.png" alt="" data-height="750" data-width="3212" data-lazy-src="https://storage.googleapis.com/blog-images-backup/1*GPjaPKNNUYHU8EsA3Z0JGA.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://storage.googleapis.com/blog-images-backup/1*GPjaPKNNUYHU8EsA3Z0JGA.png"/><noscript><img data-lazy-fallback="1" decoding="async" loading="lazy" class="alignnone" src="../Images/94b3e0f84b30cb0d321f60471481ab64.png" alt="" data-height="750" data-width="3212" data-original-src="https://storage.googleapis.com/blog-images-backup/1*GPjaPKNNUYHU8EsA3Z0JGA.png"/></noscript></a></figure>
<h3>所以让我们把所有这些自动化吧</h3>
<p>这一切都始于一条<strong>提交消息</strong>。结构化提交消息将是自动化过程的基础。另一个使用的git实体是一个<strong>标签</strong>——它将标记每个版本。基于自上一次发布以来的提交消息中的信息，将准备下一次发布——或者不准备，如果自上一次发布以来的更改不需要它。整洁，对不对？</p>
<p><em>以下所有内容在该存储库中均可用:</em></p>
<blockquote class="embedly-card" data-card-controls="1" data-card-align="center" data-card-theme="light">

<p>此时您不能执行该操作。您已使用另一个标签页或窗口登录。您已在另一个标签页或窗口中注销。重新加载以刷新您的会话。重新加载以刷新您的会话。</p>
</blockquote>
<p/>
<h4><a href="https://github.com/adekbadek/semantic-release-demo/commit/7de4583e2f3288fcc55ec10190d40525988a660e" target="_blank" rel="noopener noreferrer">步骤1 </a>:结构化提交消息</h4>
<p>首先，帮助构建提交消息:<a href="https://commitizen.github.io/cz-cli/" target="_blank" rel="noopener noreferrer">提交</a>。用<code>$ npm i -D commitizen</code>安装，然后设置使用<a href="https://github.com/conventional-changelog/conventional-changelog" target="_blank" rel="noopener noreferrer">常规变更日志</a> : <code>$ npx commitizen init cz-conventional-changelog -D -E</code>。然后添加一个将调用<code>git-cz</code>(commit izen的二进制代码)的npm脚本，并在git中暂存更改后，运行它。现在您应该会看到这个欢迎提示:</p>
<figure><img decoding="async" src="../Images/e89a9b956938d9d52bebd3a98a02b222.png" data-height="195" data-width="814" data-lazy-src="https://storage.googleapis.com/blog-images-backup/1*i-C_2JpIMgaRbVeaL3qa8g.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" class=" jetpack-lazy-image" data-original-src="https://storage.googleapis.com/blog-images-backup/1*i-C_2JpIMgaRbVeaL3qa8g.png"/><noscript><img data-lazy-fallback="1" decoding="async" src="../Images/e89a9b956938d9d52bebd3a98a02b222.png" data-height="195" data-width="814" data-original-src="https://storage.googleapis.com/blog-images-backup/1*i-C_2JpIMgaRbVeaL3qa8g.png"/></noscript></figure>
<h4>步骤2:确保符合git挂钩</h4>
<p>很好。但是和其他人以及你未来的自己一起工作意味着有人可能会忘记使用commitizen并破坏整个系统。幸运的是，git提供了一个叫做<a href="https://git-scm.com/book/en/v2/Customizing-Git-Git-Hooks" target="_blank" rel="noopener noreferrer">钩子</a>的东西！如果您查看一个新存储库的<code>.git/hooks</code>,您会看到一堆<code>*.sample</code>文件——钩子就是bash脚本，当某些动作发生时就会触发。但是当你有npm的时候，谁会在bash中编码呢？只需<code>$ npm i -D husky</code>,看着钩子文件夹被你不必写的脚本填充。<a href="https://github.com/typicode/husky" target="_blank" rel="noopener noreferrer"> Husky </a>是一个基于package.json中的config做挂钩业务的工具。</p>
<p>现在让我们为这些提交消息获取一个linter。首先，安装它— <code>$ npm i -D <a title="Twitter profile for @commitlint" href="https://twitter.com/commitlint" target="_blank" rel="noopener noreferrer">@commitlint</a>/{config-conventional,cli}</code>。然后，创建<code>commitlint.config.js</code>配置文件:</p>
<pre>module.exports = {extends: ['<a title="Twitter profile for @commitlint/config-conventional" href="https://twitter.com/commitlint/config-conventional" target="_blank" rel="noopener noreferrer">@commitlint/config-conventional</a>']}</pre>
<p>之后，在package.json中为husky提供一些信息:</p>
<pre>“husky”: {
  “hooks”: {
    “commit-msg”: “commitlint -E HUSKY_GIT_PARAMS”
  } 
}</pre>
<p>就是这样！尝试将文件添加到git staging中，并使用一条莫名其妙的提交消息提交——husky要咬人了！</p>
<h4>步骤3:持续集成</h4>
<p>现在我们保证了提交消息是有意义的(或者至少是格式化的)。本教程主角时间:进入语义-发布:<code>$ npm i -D semantic-release</code>。与此同时，添加一个将调用它的npm脚本(只是<code>“semantic-release”: “semantic-release”</code>)。</p>
<p>默认情况下，该工具旨在在npm上发布——如果您的计划中没有，那么必须执行一些默认配置覆盖。在package.json中添加一个<code>“release”</code>键，内容如下:</p>
<pre>"plugins": [
  "<a title="Twitter profile for @semantic" href="https://twitter.com/semantic" target="_blank" rel="noopener noreferrer">@semantic</a>-release/commit-analyzer",
  "<a title="Twitter profile for @semantic" href="https://twitter.com/semantic" target="_blank" rel="noopener noreferrer">@semantic</a>-release/release-notes-generator",
  [
    "<a title="Twitter profile for @semantic" href="https://twitter.com/semantic" target="_blank" rel="noopener noreferrer">@semantic</a>-release/npm",
    {
      "npmPublish": false
    }
  ],
  "<a title="Twitter profile for @semantic" href="https://twitter.com/semantic" target="_blank" rel="noopener noreferrer">@semantic</a>-release/github"
]</pre>
<p>Semantic-release将在GitHub(和npm)中完成它的工作，从CI服务器运行——在本例中是CircleCI。因此，它需要通过<em>令牌</em>访问GitHub和npm，这些令牌必须添加到CI的设置中:</p>
<figure class="wp-caption"><img decoding="async" src="../Images/b2f17ca48c44c11da6558a1bdd9031df.png" data-height="720" data-width="1176" data-lazy-src="https://storage.googleapis.com/blog-images-backup/1*UU1v3xMShYEaK0jq2zix3w.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" class=" jetpack-lazy-image" data-original-src="https://storage.googleapis.com/blog-images-backup/1*UU1v3xMShYEaK0jq2zix3w.png"/><noscript><img data-lazy-fallback="1" decoding="async" src="../Images/b2f17ca48c44c11da6558a1bdd9031df.png" data-height="720" data-width="1176" data-original-src="https://storage.googleapis.com/blog-images-backup/1*UU1v3xMShYEaK0jq2zix3w.png"/></noscript><figcaption class="wp-caption-text">(ignore the NPM_TOKEN if you don’t plan to publish on npm)</figcaption></figure>
<p>如您所见，令牌需要作为名为<code>GITHUB_TOKEN</code>和<code>NPM_TOKEN</code>的环境变量可用。现在让我们为CircleCI添加一个名为<code>.circleci/config.yml</code>的配置——这个配置有点臃肿，所以你可以<a href="https://github.com/adekbadek/semantic-release-demo/blob/master/.circleci/config.yml" target="_blank" rel="noopener noreferrer">从这里</a>复制它。</p>
<p>一切都准备好了！如果CI看到一个应该触发发布的提交消息(就像那些以<code>feat</code>或<code>fix</code>开始的消息)，所有这些都会自动发生。GitHub上将发布一个版本和标签，除非有不同的配置，npm上将发布一个新的包版本。</p>
<p>很好。</p>
<h4>步骤4:生成变更日志</h4>
<p>但是，有一个问题。实际上是两个。在发布之后，<code>package.json</code>中的<code>version</code>字段保持不变，那么在未来会有如此大帮助的变更日志在哪里呢？别担心，只差两个变化:</p>
<p>首先安装一些额外的包:<code>$ npm i -D <a title="Twitter profile for @semantic" href="https://twitter.com/semantic" target="_blank" rel="noopener noreferrer">@semantic</a>-release/changelog <a title="Twitter profile for @semantic" href="https://twitter.com/semantic" target="_blank" rel="noopener noreferrer">@semantic</a>-release/git</code>。然后，将该配置添加到<code>package.json</code>的<code>“release”</code>部分:</p>
<pre>"prepare": [
   "<a title="Twitter profile for @semantic" href="https://twitter.com/semantic" target="_blank" rel="noopener noreferrer">@semantic</a>-release/changelog",
   "<a title="Twitter profile for @semantic" href="https://twitter.com/semantic" target="_blank" rel="noopener noreferrer">@semantic</a>-release/npm",
   {
    "path": "<a title="Twitter profile for @semantic" href="https://twitter.com/semantic" target="_blank" rel="noopener noreferrer">@semantic</a>-release/git",
     "assets": [
      "package.json",
      "package-lock.json",
      "CHANGELOG.md"
    ],
    "message": "chore(release): ${nextRelease.version} [skip ci]nn${nextRelease.notes}"
  }
]</pre>
<p>这将告诉<code>semantic-release</code>生成一个变更日志，然后在版本发布完成后添加一个提交。你可以在这个部分调整更多的设置，更多信息请访问<a href="https://semantic-release.gitbook.io/semantic-release/" target="_blank" rel="noopener noreferrer">语义发布文档</a>。</p>
<p>有了这样的设置，发布将不会是一时兴起，而是基于代码的变化。当它发生时，将会生成一个变更日志，这样每个人都知道<em>在随后的版本中</em>发生了什么，以及<em>什么时候</em>发生了。</p>
<h3>这些版本号是什么意思？</h3>
<p>正如你可能注意到的，一个发布被标记为<em>版本</em>。使用语义发布，版本中的数字遵循一个叫做<a href="https://semver.org/" target="_blank" rel="noopener noreferrer">语义版本化</a>(又名SemVer)的系统。简而言之，这些表示<strong>大调</strong>、<strong>小调</strong>和<strong>补丁</strong>版本。当添加向后兼容的错误修复时，补丁号会增加，次要:向后兼容的功能，主要:重大更改(与之前的版本不兼容)。</p>
<p>语义版本化对于你的用户(或者客户)来说是很重要的——这样他们就知道他们对一个新版本有什么期望，以及自从他们最后一次使用/看到这个项目以来有什么变化。如果某人使用的上一个版本是<code>1.0.1</code>而当前版本是<code>1.1.42</code>，那么他们知道在此期间，bug修复比添加的特性要多得多。</p>
<p>语义版本化可以与<a href="http://sentimentalversioning.org/" target="_blank" rel="noopener noreferrer">情感版本化</a>相对，在情感版本化中，版本号以不一致的方式递增，实际上它们没有任何意义。</p>
<h3>为什么不呢？</h3>
<p>所有这些设置可能看起来有点大材小用，对于由一个人维护的小型项目来说可能是这样。但是我已经感谢过自己很多次了，因为我在一开始就设置了它，我确信我会尽可能地再次使用它。在git中拥有如此多的信息非常令人放心，因为它不会过时，并且与代码紧密相关。</p>
<p>至于其他疑虑:</p>
<blockquote><p>我只需要看一眼git log diff就可以了。</p></blockquote>
<p>从本质上来说，日志不应该被完整地阅读。它的信噪比很弱。</p>
<blockquote><p>结构化提交消息实在是太烦人了！</p></blockquote>
<p>有一个不可读的提交历史更是如此。尝试在没有任何关于何时引入了bug的信息的情况下进行调试。</p>
<blockquote><p>我很习惯无意义的提交消息…</p></blockquote>
<p>必须指定提交的内容会让开发人员对提交的更改三思而行。如果您不确定提交的类型，可能更改也不是很清楚？</p>
<p>感谢阅读！</p><div class="code-block code-block-2">
<div class="blog-plug base-cta"><h2>使用<a class="signup" href="https://lp.logrocket.com/blg/signup" target="_blank" rel="noopener noreferrer"> LogRocket </a>消除传统错误报告的干扰</h2>
<a href="https://lp.logrocket.com/blg/signup" class="signup" target="_blank" rel="noopener noreferrer"><img class="alignnone size-full wp-image-46 jetpack-lazy-image" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/><noscript><img data-lazy-fallback="1" class="alignnone size-full wp-image-46" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/></noscript></a>
<p><a href="https://lp.logrocket.com/blg/signup" target="_blank" rel="noopener noreferrer"> LogRocket </a>是一个数字体验分析解决方案，它可以保护您免受数百个假阳性错误警报的影响，只针对几个真正重要的项目。LogRocket会告诉您应用程序中实际影响用户的最具影响力的bug和UX问题。</p>
<p>然后，使用具有深层技术遥测的会话重放来确切地查看用户看到了什么以及是什么导致了问题，就像你在他们身后看一样。</p>
<p>LogRocket自动聚合客户端错误、JS异常、前端性能指标和用户交互。然后LogRocket使用机器学习来告诉你哪些问题正在影响大多数用户，并提供你需要修复它的上下文。</p>
<p>关注重要的bug—<a class="signup" href="https://lp.logrocket.com/blg/signup-issue-free" target="_blank" rel="noopener noreferrer">今天就试试LogRocket】。</a></p></div></div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
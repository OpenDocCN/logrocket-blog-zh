<html>
<head>
<title>Improve site performance by inlining your CSS - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>通过内嵌你的CSS - LogRocket博客来提高网站性能</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/improve-site-performance-inlining-css/#0001-01-01">https://blog.logrocket.com/improve-site-performance-inlining-css/#0001-01-01</a></blockquote><div><article class="article-post">
<p>当你第一次开始构建一个网站或应用程序时，你的<code>index.html</code>文件是你所能得到的最好的。</p>
<p>是的，您可以设置缓存、HTTP/2和其他服务器端优化，但最终，您将为您的用户提供一个<code>index.html</code>文件，该文件开始时是空的，随着您发布特性、修复bug、添加第三方脚本以及调整项目生命周期中的许多其他有趣的事情，它会逐渐变大。</p>
<p>所有这些变化都会导致网站性能的“千刀万剐”。页面开始加载缓慢，感觉滞后，用户参与度下降。你需要找到一些方法回到你曾经有过的精彩表现，但是怎么做呢？</p>
<p>提高站点性能的方法之一是内联CSS。本文通过提问和回答一系列问题来解释内联CSS的“是什么”和“如何”。</p>
<h2>CSS如何影响性能？</h2>
<p>在我们深入了解内联CSS的含义以及如何实现之前，首先理解CSS如何影响性能是很重要的。虽然JavaScript和图像通常在负面影响性能指标方面发挥更大的作用，但CSS也可以发挥重要作用。</p>
<p>当浏览器访问一个URL时，它从服务器返回的第一个东西是HTML文件。然后，它开始解析这个文件，停下来请求一路上找到的任何链接依赖项。它首先检查文档的<code>&lt;head&gt;</code>，在开始进入<code>&lt;body&gt;</code>呈现页面之前寻找任何必要的东西。</p>
<p>CSS被视为一种<a href="https://developers.google.com/web/fundamentals/performance/critical-rendering-path/render-blocking-css">呈现阻塞资源</a>——也就是说，如果您在文档的<code>&lt;head&gt;</code>中包含任何形式的<code>&lt;link href="style.css" rel="stylesheet"&gt;</code>，浏览器将触发一个额外的请求，请求服务器在开始为用户呈现页面之前检索样式表。</p>
<p>虽然我们的互联网提供商、基础设施和服务器每年都在变得越来越快，但天下没有免费的午餐。每个对服务器的网络请求都有时间成本，在浏览器开始呈现页面之前完成的请求是最昂贵的。</p>
<p>最简单的形式是，内联CSS是一种避免或推迟第二次(或更多次)网络请求的方法，在此之前，用户可以看到页面上的任何内容。</p>
<h2>在解决性能问题之前，您应该做些什么？</h2>
<p>在试图改善你的网站性能之前，重要的是首先要衡量当前的性能。挑选一些度量标准来衡量(这里有一些关于什么的好主意<a href="https://web.dev/user-centric-performance-metrics/">这里有</a>)并获得你的站点表现的基线。</p>
<p>虽然这篇文章和其他文章中的所有内容在理论上都是正确的，但在实践中事情总是不同的。所以先测量，尝试一些事情，再测量，如果没有得到你期望的结果，那么就恢复。如果你在实施一些改变后衡量出积极的结果，那么你就有一个很好的成功故事与你的团队或经理分享。</p>
<h2>什么是内联？</h2>
<p>内联是将一部分代码直接集成到它将被使用的地方的实践，消除了计算机进行函数调用或一些其他类型的查找的需要。这个<a href="https://gcc.gnu.org/onlinedocs/gcc/Inline.html">让代码更快</a>。</p>
<p>虽然内联术语最初来自C编程语言，但其概念和名称已经在web开发中找到了自己的方式。就CSS而言，性能的提高来自于将样式直接内联到HTML文档中，这样就不需要浏览器在获取呈现阻塞样式之前发出网络请求。</p>
<h2>应该避免哪种类型的内联？</h2>
<p>如果您对内联CSS进行任何研究，您可能会发现一些以下述方式内联样式的建议:</p>
<pre>&lt;p style="font-size: 20px; font-weight: bold;"&gt;Some text&lt;/p&gt;</pre>
<p>这确实是真正的内联，因为不需要网络请求来获取外部样式表，甚至不需要浏览器将CSS类名应用于元素。然而，您几乎不应该以这种方式内联CSS，因为具有讽刺意味的是，当运行时响应性是度量单位时，它会引入某些性能损失。</p>
<p>以下是您应该几乎总是避免以这种方式内联CSS的一些原因:</p>
<h3>渲染阻塞加载时间</h3>
<p>这又回到了CSS是一个渲染阻塞资源的概念。虽然这通常是在网络请求的上下文中考虑的，但也可能是浏览器解析和理解所有CSS所花费的时间。</p>
<p>假设您希望避免加载外部CSS样式表，因此单独内联DOM中的每个元素。您可能会得到许多重复的样式，这些样式可能是原子CSS类名，也可能是特定类型元素的常规类名。正如一个开发人员的基准测试表明的那样，内联样式化每个HTML元素会显著影响第一次“T2”绘制的时间。</p>
<h3>风格的复制</h3>
<p>在每种情况下，敲打“不要重复自己”的鼓点既不必要也没有帮助，但是对于内联CSS，如果每个元素不是单独设计的，您将省去很多麻烦。是的，有一些方法可以将样式定义为一个可重用的对象，并将这些样式扩展到每个元素中，但是在某种程度上，单独设计每个元素的样式会使未来的重构变得更加困难。</p>
<h3>风格的特异性</h3>
<p>如果样式的重复还不足以警告“立即返回”，那么现在是时候记住内联样式具有<a href="https://developer.mozilla.org/en-US/docs/Learn/CSS/Building_blocks/Cascade_and_inheritance#Understanding_the_cascade">高特异性</a>，因此只能通过使用<code>!important</code>声明来覆盖。</p>
<p>为了描绘一幅完整的画面，以这种方式内联CSS并不总是对性能或可维护性有害。</p>
<p>想象一下，当用户与站点交互时，一些JavaScript动态地在DOM中添加或删除元素。在这种情况下，浏览器已经完成了下载、解析和呈现任务，性能(大部分)不再是问题。但是如果在浏览器加载页面时内联将出现在DOM中的CSS，应该避免这种方式的内联。</p>
<h2>你应该考虑什么类型的内联？</h2>
<p>虽然上一节不鼓励一种内联CSS的形式，但是有另一种内联方法在运行时响应方面更有效。不是像这样链接到外部CSS文件:</p>
<pre>&lt;head&gt;
  ...
  &lt;link href="styles.css" rel="stylesheet"&gt;
&lt;/head&gt;</pre>
<p>您可以直接将样式(或其中的一部分)包含在文档头中，如下所示:</p>
<pre>&lt;head&gt;
  ...
  &lt;style type="text/css"&gt;
body{background:#fff;color:#000;margin:0}.link{color:#1a0dab}.ts{border-collapse:collapse}.ts td{padding:0}.g{line-height:1.2;text-align:left;width:600px}.ti{display:inline;display:inline-table}
  &lt;/style&gt;
&lt;/head&gt;</pre>
<p>这解决了浏览器在能够呈现页面之前需要发送额外的网络请求的问题，也解决了尝试内联每个单独元素的问题。我们现在可以像平常一样，通过给元素一个link类<code>&lt;a href="some-link" class="link"&gt;Some link&lt;/a&gt;</code>来设置页面中所有链接的样式。</p>
<p>成功！我们现在能够减少网络请求的数量，同时尽可能快地为DOM提供渲染所需的样式。一切都好，对吧？</p>
<p>差不多了。</p><div class="code-block code-block-54">
<hr/>
<h3>更多来自LogRocket的精彩文章:</h3>

<hr/></div>
<p>软件开发是关于权衡的。为了追求更好的性能，我们需要确定我们愿意做出什么样的权衡。我们消除了一个网络请求(好)，但我们只是把这些千字节转移到HTML文件，使它成为一个更大的下载(坏)。</p>
<p>天下没有免费的午餐！为了消除同步网络请求，在接受更大的HTML文件的开销方面需要做一些平衡，但是在某些时候，如果在头中放入太多样式，性能指标实际上会受到影响。</p>
<p>这里要观察的是，当我们只在文档头中内联关键的CSS(关键字是critical)时，内联CSS使事情对度量更有性能，比如第一次内容丰富的绘制。您站点的样式表可能包含许多许多样式，用户在第一次加载您的页面时会看到这些样式。</p>
<p>例如，当浏览器第一次绘制站点时，页脚的样式就不需要了。也许第一幅画只需要标题、英雄和一些内容样式。初始加载时浏览器视窗中显示的内容可以被认为是“关键的”。</p>
<p>回到权衡、消除网络请求和确保HTML文件不会变得太大的讨论上来，值得一提的是，围绕页面所有关键资源的大小限制为14KB的想法给出了一些建议。如果你想更深入地了解这个想法，以下三个链接会很有帮助:</p>

<p>最后，就内联CSS和性能而言，重要的是不要将站点的所有CSS都放入头部。如果内联太多，性能影响会比开始时更差。</p>
<h2>那么剩下的风格呢？</h2>
<p>所以我们现在已经看到了内联关键CSS可以对我们的站点产生积极的性能影响。我们已经从文档头中移除了外部样式表的链接，弄清楚了什么是“关键的”CSS，并将其作为内联样式包含在文档头中，但是页面的其余部分仍然需要样式。我们如何设计页面的其余部分呢？</p>
<p>我们可以将页面的其余(非关键)样式保存在外部样式表中，并推迟下载，直到浏览器完成呈现阻塞工作，如下所示:</p>
<pre>&lt;head&gt;
  ...
  &lt;style type="text/css"&gt;
    /* inlined styles */
  &lt;/style&gt;
  &lt;link rel="stylesheet" href="styles.css" media="print" onload="this.media='all'"&gt;
&lt;/head&gt;</pre>
<p>注意，也可以用JavaScript请求外部样式表并将其添加到DOM中。然而，通过使用传统的链接，浏览器能够<a href="https://calendar.perfplanet.com/2016/a-tale-of-four-caches/">将响应存储在其内存缓存</a>中，这对于JavaScript解决方案来说更难实现。如果链接中的媒体类型对你来说读起来很奇怪，我鼓励你<a href="https://www.filamentgroup.com/lab/load-css-simpler/">阅读这篇文章</a>，它解释了这是如何工作的，以及这种方法为什么比使用链接预取更可取。</p>
<p>至此，我们已经拥有了整个页面所需的所有样式，但是关键样式被内联，非关键样式稍后被异步加载。您的用户能够注意到的唯一区别是页面似乎加载得更快了！</p>
<h2>有哪些工具可用？</h2>
<p>实话实说:如果您的项目由一两个页面组成，内联关键CSS并预加载其余部分的想法似乎相当简单。只需做一点调查，看看哪些类在不同的设备纵横比上首先可见，将它们内联，并预加载其余的类。</p>
<p>但是添加数百个不同的页面和一整个团队的开发人员都在不同的部分工作，你可以很快看到跟踪关键和非关键的风格是多么麻烦，如果不是不可能的话。这里的一些工具会对我们有很大的帮助。</p>
<p>你知道Chrome有一个工具可以找到<a href="https://developers.google.com/web/tools/chrome-devtools/coverage">未使用的JavaScript和CSS代码</a>吗？这个覆盖特性是相当手动的，但是可以帮助您发现当您第一次加载页面，然后滚动或点击页面时，页面上的哪些样式是未使用的。</p>
<p>有一个名为<a href="https://github.com/pocketjoso/penthouse"> Penthouse </a>的项目可以为你的网页生成关键的CSS。这个工具的作者还在Penthouse上运行了一个带有自动化和其他功能的付费服务。</p>
<p>Addy Osmani有一个名为<a href="https://github.com/addyosmani/critical"> Critical </a>的工具，可以从HTML中提取和内嵌关键路径CSS。他还<a href="https://project-awesome.org/addyosmani/critical-path-css-tools">维护了一份其他关键CSS工具的列表</a>，非常值得深入研究。</p>
<p>最终，这样一个任务的工具实际上依赖于框架、构建过程和你用来开发你的站点的其他库。我建议您仔细阅读Addy的工具列表，看看是否有任何工具可以在您的堆栈中使用。</p><div class="code-block code-block-25">
<div class="blog-plug inline-plug css-plug"><h2>你的前端是否占用了用户的CPU？</h2><p>随着web前端变得越来越复杂，资源贪婪的特性对浏览器的要求越来越高。如果您对监控和跟踪生产环境中所有用户的客户端CPU使用情况、内存使用情况等感兴趣，</p><a target="_blank" href="https://lp.logrocket.com/blg/css-signup">try LogRocket</a><p>.</p><a class="signup" href="https://lp.logrocket.com/blg/css-signup" target="_blank" rel="noopener noreferrer"><img class="alignnone size-full wp-image-46 jetpack-lazy-image" src="../Images/dacb06c713aec161ffeaffae5bd048cd.png" alt="LogRocket Dashboard Free Trial Banner" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2019/12/cpu-memory-usage.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/12/cpu-memory-usage.png"/><noscript><img data-lazy-fallback="1" class="alignnone size-full wp-image-46" src="../Images/dacb06c713aec161ffeaffae5bd048cd.png" alt="LogRocket Dashboard Free Trial Banner" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/12/cpu-memory-usage.png"/></noscript></a><a href="https://lp.logrocket.com/blg/css-signup" target="_blank" rel="noopener noreferrer">https://logrocket.com/signup/</a><p>LogRocket 就像是网络和移动应用的DVR，记录你的网络应用或网站上发生的一切。您可以汇总和报告关键的前端性能指标，重放用户会话和应用程序状态，记录网络请求，并自动显示所有错误，而不是猜测问题发生的原因。</p><p>现代化您调试web和移动应用的方式— <a class="signup" href="https://lp.logrocket.com/blg/css-signup" target="_blank" rel="noopener noreferrer">开始免费监控</a>。</p></div>
</div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
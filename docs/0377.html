<html>
<head>
<title>Maintaining state variables in React - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>在React - LogRocket博客中维护状态变量</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/react-url-state/#0001-01-01">https://blog.logrocket.com/react-url-state/#0001-01-01</a></blockquote><div><article class="article-post">
<p>如果你知道如何让事情井然有序，那么在React中管理页面之间的活动会很容易。每次有变化时，向下传递和向上传递道具的方式是有意义的，但很容易变得混乱。</p>
<p>慢慢来。</p>
<p>通过把你的组件分成两个简单的类别，并把每个页面的职责分开，你就不需要传递这么多的道具(并把它们放在地址栏里)。</p>
<h2 id="page-components-vs-block-components">页面组件与块组件</h2>
<p>让我们从将应用程序分解成与应用程序本身的功能相关的HTML块开始。如果您曾经使用过CMS，那么您可能已经熟悉了将“页面”与“内容块”分开管理的概念。</p>
<h3>示例:</h3>
<p>一个应用程序有一个博客文章对象。有一个特定于该单个博客帖子的页面，但也有该博客的简短形式的单独表示。也许有一个博客主页，每页有10篇文章，也许有一个主页的“最新文章”部分，也许有一个作者页面，上面有他们撰写的每篇文章。</p>
<p>博客<em>页面</em>是关于个人博客文章的所有内容，但是博客<em>区块</em>是可以在我们想要的任何地方使用的东西，不管上下文如何。为了在React中将您的功能分离到页面中，而不牺牲在页面之间传递信息的能力，您的应用程序必须由许多可以使用任意数量块组件的页面组件构成，这一点很重要。</p>
<p>稍后会有更多的介绍。</p>
<h2 id="tying-pages-to-urls">将页面绑定到URL</h2>
<p>有几种方法可以做到这一点，但没有一种是React自带的。有许多很好的选择，但我最喜欢的是反应路由器。因为我在为web做这个例子，我们将使用<code>react-router-dom</code>，但是也有React Native的选项。以下是其工作原理的基础。</p>
<ul>
<li>一个组件(通常称为<code>App</code>)是拥有路由器并管理历史对象*作为其状态和道具的一部分的顶级组件。</li>
<li>多个(页面)组件或呈现函数根据当前地址栏中的URL选择在页面上放置什么。</li>
<li>其余的功能根据需要放入页面中。</li>
</ul>
<ul>
<li>这是重要的一点。</li>
</ul>
<p>您知道DOM已经有了一个包含URL所有属性的对象吗？帮我个忙，在这个浏览器标签中进入你的控制台，输入<code>window.history</code>并检查一下。</p>
<p>很酷，对吧？它的伟大之处在于它可以管理你在哪里，你在哪里使用… (drumroll) state！有空的时候去看看文档吧，因为你可以用历史对象做一些很酷的事情。</p>
<p>大多数路由的工作方式是将你的顶层组件绑定到历史上，并用你的浏览器历史来管理<em>它的状态</em>。它还包含了很多很酷的能力，打破了网址段，和参数。</p>
<h2 id="okay-so-seriously-what-do-i-do-with-that">好吧，说真的，我该怎么办？</h2>
<p>这就是酷的地方。通过将history对象传递到页面组件的props中，您可以将状态变量(即使它们在顶层发生了变化)向下维护到每个页面中，甚至维护到页面之间。利用这一点，您可以将其他块组件放在您想要的任何位置，并且您有一种整洁的方式来管理与应用程序页面相关的任何信息。</p>
<h3>第一步:页面</h3>
<p>让我们回到我们的博客例子。如果没有路由器，你需要在主页和博客文章页面之间创建一个单独的状态文件，但是有了路由器，你可以将参数传入URL，甚至可以用它来动态设置URL。</p>
<p>看看这个:</p>
<pre><code class="javascript hljs"><span class="hljs-keyword">import</span> React, { Component } <span class="hljs-keyword">from</span> <span class="hljs-string">"react"</span>
<span class="hljs-keyword">import</span> { BrowserRouter <span class="hljs-keyword">as</span> Router, Route } <span class="hljs-keyword">from</span> <span class="hljs-string">"react-router-dom"</span>

component App extends Component {
  render () {
    <span class="hljs-keyword">return</span> (
      &lt;div className="app"&gt;
        &lt;Router&gt;
          &lt;Route path="/" exact component={HomePage} /&gt;
          &lt;Route path="/blog" exact component={BlogPage} /&gt;
          &lt;Route path="/blog/:id" exact component={BlogPostPage} /&gt;
        &lt;/Router&gt;
      &lt;/div&gt;
    )
  }
}</code></pre>
<p>通过这三行代码，您已经建立了三个独立的页面，它们共享博客文章的内容，并且可以呈现相同的组件，而无需传递大量的道具。您甚至会注意到，我已经为名为<code>id</code>的博客文章ID包含了URL参数。</p>
<h3 id="step-2-mapping-the-history">步骤2:映射历史</h3>
<p>通过获取URL的动态部分(博客文章的ID)并将其移动到一个参数中，我们可以避免应用程序需要任何关于博客数据库的知识。</p>
<p>这意味着巨大的处理节省。如果在那个<code>/blog</code> URL中有一个CRUD接口，<code>BlogPostPage</code>可以管理所有这些。更好的是，你可以通过Redux依赖一个缩减器来管理所有的本地商店，这样<code>App</code>只负责确保正确的页面显示。</p>
<p>这是<code>BlogPostPage</code>开始时的样子:</p>
<pre><code class="javascript hljs"><span class="hljs-keyword">import</span> React, { Component } <span class="hljs-keyword">from</span> <span class="hljs-string">"react"</span>

component BlogPostPage extends Component {
  state = {
    <span class="hljs-attr">postId</span>: <span class="hljs-keyword">this</span>.props.match.params.id
  }
  
  componentDidMount () {
    
  }
  
  render () { ... }
}</code></pre>
<h3 id="step-3-the-fun-stuff">第三步:有趣的东西</h3>
<p>默认情况下,<code>react-router</code>包含了获取参数、散列或任何你想在URL中检查的东西的能力。其中的每一项都可以立即用于页面组件:</p>
<p>参数(对于命名变量):<code>this.props.match.params</code></p>
<p>哈希(非常适合锚链接):<code>this.props.location.hash</code></p>
<p>查询参数(用于搜索或其他查询):<code>this.props.location.search</code></p>
<p>所有URL段(如果您需要对路径进行更精细的控制):<code>this.props.location.pathname</code></p>
<p>如果您将<em>个路径嵌套在一起，这也是可行的:</em></p>
<pre><code class="javascript hljs"><span class="hljs-keyword">return</span> (
  &lt;div className="app"&gt;
    &lt;Router&gt;
      &lt;Route path="/" exact component={HomePage} /&gt;
      &lt;Route path="/blog" exact component={BlogPage} /&gt;
      &lt;Route path="/blog/:id" exact component={BlogPostPage} /&gt;
      &lt;Route path="/user" exact component={UserProfile} /&gt;
      &lt;Route path="/user/settings" exact component={UserSettings} /&gt;
    &lt;/Router&gt;
  &lt;/div&gt;
)</code></pre>
<h2 id="conclusion">结论</h2>
<p>经过一些重构后，你可以把你的应用程序的每一页想象成独立的迷你应用程序，只负责它们自己的特性，并把页面之间重复的特性分解成在每一页上使用的块组件。这让你的状态和道具变少，责任变小。</p><div class="code-block code-block-17">
<div class="blog-plug inline-plug react-plug" vwo-el-id="26283398190">
<h2 vwo-el-id="41600691720"><a href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener"> LogRocket </a>:全面了解您的生产React应用</h2><p>调试React应用程序可能很困难，尤其是当用户遇到难以重现的问题时。如果您对监视和跟踪Redux状态、自动显示JavaScript错误以及跟踪缓慢的网络请求和组件加载时间感兴趣，</p><a href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" vwo-el-id="19356441070">try LogRocket</a><p>. </p><a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="19356441380">
<img class="first-react-image alignnone size-full wp-image-46 jetpack-lazy-image jetpack-lazy-image--handled" src="../Images/f300c244a1a1cf916df8b4cb02bec6c6.png" vwo-el-id="18272717540" data-lazy-loaded="1" data-original-src="https://files.readme.io/27c94e7-Image_2017-06-05_at_9.46.04_PM.png"/>
</a>
<a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="19356441690">
<img class="second-react-image alignnone size-full wp-image-46 jetpack-lazy-image jetpack-lazy-image--handled" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" vwo-el-id="30720362350" data-lazy-loaded="1" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/>
</a>
<p vwo-el-id="28675660440" class="">LogRocket 结合了会话回放、产品分析和错误跟踪，使软件团队能够创建理想的web和移动产品体验。这对你来说意味着什么？</p>
<p>LogRocket不是猜测错误发生的原因，也不是要求用户提供截图和日志转储，而是让您回放问题，就像它们发生在您自己的浏览器中一样，以快速了解哪里出错了。</p>
<p>不再有嘈杂的警报。智能错误跟踪允许您对问题进行分类，然后从中学习。获得有影响的用户问题的通知，而不是误报。警报越少，有用的信号越多。</p>
<p vwo-el-id="28675660750">LogRocket Redux中间件包为您的用户会话增加了一层额外的可见性。LogRocket记录Redux存储中的所有操作和状态。</p>
<p vwo-el-id="28675661060">现代化您调试React应用的方式— <a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="40093418840">开始免费监控</a>。</p>
</div></div>
<hr/>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
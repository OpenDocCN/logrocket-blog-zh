<html>
<head>
<title>Comparing Next.js and After.js for SSR React apps - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>比较SSR React应用程序的Next.js和after . js-log rocket博客</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/comparing-next-js-after-js/#0001-01-01">https://blog.logrocket.com/comparing-next-js-after-js/#0001-01-01</a></blockquote><div><article class="article-post">
<p><em> <strong>编者按:</strong> </em> <em>本帖于2021年12月1日更新，新增代码块及相关信息。</em></p>
<p><a href="https://blog.logrocket.com/tag/nextjs/" target="_blank" rel="noopener"> Next.js </a>和<a href="https://github.com/jaredpalmer/after.js/" target="_blank" rel="noopener"> After.js </a>都是框架，让我们可以构建服务器端渲染的React应用，而无需从create-react-app项目中从头开始设置SSR。在本文中，我们将比较Next.js和After.js，并探索它们的差异。</p>
<h2 id="differencesbetweennextjsandafterjs">Next.js与After.js</h2>
<p>Next.js和After.js的主要区别在于路由机制。</p>
<p>使用Next.js，我们不直接指定路线；相反，我们让Next.js自动处理路由。它通过检查项目的文件结构并将URL直接映射到组件，从而将URL映射到我们的组件。</p>
<p>使用After.js，我们需要显式地指定路由。After.js使用<a href="https://reactrouter.com/" target="_blank" rel="noopener"> React路由器</a>进行路由。</p>
<p>大多数其他特性，比如数据获取和页面创建方式，在这两者之间是非常相似的。创建项目的方式与创建自己的CLI程序的方式非常相似。</p>
<p>创建Next.js项目最简单的方法是使用create-next-app。要开始，请运行:</p>
<pre>npx <a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="debdacbbbfaabbf3b0bba6aaf3bfaeae9eb2bfaabbadaa">[email protected]</a>
# or
yarn create next-app
Note: For a Typescript project, add a ​​--typescript flag to this command.</pre>
<p>为了创建After.js项目，我们运行:</p>
<pre>yarn global add create-after-app
// or
npm install -g create-after-app
create-after-app myapp</pre>
<p>注意:在撰写本文时，After.js抛出了一个React路由器最新版本的错误(参见这里的GitHub问题)。一个快速的解决方法是删除我们的<code>node_modules</code>文件夹并更新<code>package.json</code>，就像这样:</p>
<pre>"dependencies": {
    ...
    "react-router-dom": "^5.3.0"
  }</pre>
<p>一旦完成，我们可以用<code>yarn install</code>或<code>npm install</code>重新安装软件包。</p>
<h2>在Next.js和After.js中创建页面</h2>
<p>Next.js和After.js都允许我们通过添加React组件来创建页面。举例来说，我们将使用带有Next.js和After.js的<a href="https://newsapi.org/">新闻API </a>创建一个应用程序。我们所要做的就是创建组件，然后它将显示在我们的应用程序中。</p>
<p>为了从新闻API中获取数据，我们将使用<a href="https://github.com/developit/unfetch/tree/master/packages/isomorphic-unfetch" target="_blank" rel="noopener">同构解锁</a>包。我们可以通过在新创建的项目中运行以下命令来获得它:</p>
<pre>npm i isomorphic-unfetch
// or
yarn add isomorphic-unfetch</pre>
<p>我们还需要一个来自新闻API的API键，我们可以免费创建。</p>
<p>在Next.js中，如果我们在<code>pages</code>文件夹中创建页面，我们可以通过同名的URL导航到它。</p>
<p>例如，在Next.js中，我们可以在<code>pages</code>文件夹中创建<code>index.js</code>，如下所示:</p>
<pre>import NavBar from '../components/navbar'
import fetch from 'isomorphic-unfetch';
import HeadTag from '../components/head-tag';

export async function getStaticProps() {
  const res = await fetch(`https://newsapi.org/v2/top-headlines/?language=en&amp;apiKey=${process.env.NEWS_API_KEY}`)
  const data = await res.json()
  return {
    props: {
      data,
    },
  }
}

const Home = ({ data }) =&gt; (
  &lt;div&gt;
    &lt;HeadTag /&gt;
    &lt;NavBar /&gt;
    {(data.articles) &amp;&amp; data.articles.map(a =&gt; (
      &lt;div key={a.title}&gt;
        &lt;h1&gt;{a.title}&lt;/h1&gt;
        &lt;p&gt;{a.description}&lt;/p&gt;
        &lt;p&gt;{a.content}&lt;/p&gt;
      &lt;/div&gt;
    ))}
  &lt;/div&gt;
)

export default Home</pre>
<p><code>getStaticProps</code>函数将让我们获取数据，然后我们可以从组件中同名的props中获取数据。</p>
<p>我们可以在<code>about.js</code>中创建一个关于页面，如下:</p>
<pre>import NavBar from '../components/navbar'
import HeadTag from '../components/head-tag'

const Home = () =&gt; (
  &lt;div&gt;
    &lt;HeadTag /&gt;
    &lt;NavBar /&gt;
    &lt;p&gt;This is a news app.&lt;/p&gt;
  &lt;/div&gt;
)

export default Home</pre>
<p>现在，我们可以通过分别转到<code>/</code>和<code>/about</code>来直接导航到它们。</p>
<p>在我们的根项目中创建了<code>components</code>文件夹之后，我们可以通过创建以下文件来创建我们可以在页面上引用的组件:</p>
<pre>//head-tag.js

import Head from 'next/head'

const HeadTag = () =&gt; (
  &lt;Head&gt;
    &lt;title&gt;News App&lt;/title&gt;
  &lt;/Head&gt;
)

export default HeadTag</pre>
<pre>//navbar.js

import Link from 'next/link'

const NavBar = () =&gt; (
  &lt;nav&gt;
    &lt;Link href="/"&gt;
      &lt;a&gt;Home&lt;/a&gt;
    &lt;/Link&gt;

    &lt;Link href="/about"&gt;
      &lt;a&gt;About&lt;/a&gt;
    &lt;/Link&gt;
  &lt;/nav&gt;
)

export default NavBar</pre>
<p>在我们的After.js应用程序中，我们在<code>src</code>文件夹中创建了以下组件:</p>
<pre>//Home.js

import React, { Component } from 'react';
import NavBar from './NavBar';
import fetch from 'isomorphic-unfetch';

class Home extends Component {
  static async getInitialProps() {
    const res = await fetch(`https://newsapi.org/v2/top-headlines/?language=en&amp;apiKey=${process.env.RAZZLE_APIKEY}`)
    const data = await res.json();
    return { data };
  }

  render() {
    const { data } = this.props;
    return (
      &lt;div&gt;
        &lt;NavBar /&gt;
        {data.articles.map(a =&gt; (
          &lt;div key={a.title}&gt;
            &lt;h1&gt;{a.title}&lt;/h1&gt;
            &lt;p&gt;{a.description}&lt;/p&gt;
            &lt;p&gt;{a.content}&lt;/p&gt;
          &lt;/div&gt;
        ))}
      &lt;/div&gt;
    );
  }
}

export default Home;</pre>
<p>我们在<code>initialProps</code>静态方法中获取数据，然后我们可以通过props访问它。</p>
<pre>//About.js

import React, { Component } from 'react';
import NavBar from './NavBar';

class About extends Component {
  render() {
    return (
      &lt;div&gt;
        &lt;NavBar /&gt;
        &lt;p&gt;This is a new app&lt;/p&gt;
      &lt;/div&gt;
    );
  }
}

export default About;</pre>
<p>我们在页面中引用的组件可以在同一个文件夹中创建:</p>
<pre>// NavBar.js
import React from 'react';
import { Link } from 'react-router-dom';

class NavBar extends React.Component {

  render() {
    return (
      &lt;div&gt;
        &lt;Link to="/"&gt;Home&lt;/Link&gt;
        &lt;Link to="/about"&gt;About&lt;/Link&gt;
      &lt;/div&gt;
    );
  }
}

export default NavBar;</pre>
<p>正如我们所见，这些都只是标准组件。不同的是，我们在After.js中使用了React Router的<code>Link</code>组件用于页面导航链接，而在Next.js项目中，我们使用Next.js自己的<code>Link</code>组件添加页面导航。</p>
<p>也就是说，在每个框架中，创建页面的体验几乎是相同的。</p>
<h2>Next.js与After.js中的路由</h2>
<p>路由是Next.js和After.js很不一样的地方。</p>
<p><a href="https://blog.logrocket.com/prefetching-dynamic-routing-next-js/" target="_blank" rel="noopener">next . js’routing</a>开箱即用，没有太多麻烦。一旦我们创建了页面，我们就可以直接导航到它们，或者通过由<code>Link</code>组件呈现的链接导航到它们。</p>
<p>另一方面，After.js要复杂得多。如果我们有一个使用<code>getInitialProps</code>方法获取数据的页面组件，那么我们不能将它作为异步组件添加到routes文件中。</p>
<p>在After.js项目的<code>src</code>文件夹中的<code>routes.js</code>文件中，我们有:</p>
<pre>import React from 'react';

import { asyncComponent } from '@jaredpalmer/after';
import Home from './Home';

export default [
  {
    path: '/',
    exact: true,
    component: Home,
  },
  {
    path: '/about',
    exact: true,
    component: asyncComponent({
      loader: () =&gt; import('./About'), // required
      Placeholder: () =&gt; &lt;div&gt;...LOADING...&lt;/div&gt;, // this is optional, just returns null by default
    }),
  },
];</pre>
<p>About.js在渲染之前不会获取数据，所以我们可以将它作为异步路由。然而，<code>Home</code>组件不能作为异步路由包含进来，因为我们有<code>getInitialProps</code>异步方法来获取数据。</p>
<p>在Next.js项目中，路由更容易处理。使用After.js可以更好地配置路由，但是我们必须自己配置。</p>
<h2>Next.js和After.js中的数据提取</h2>
<p>Next.js和After.js中的数据提取都是在组件第一次呈现时完成的。从上一节我们可以看到，Next.js项目中的<code>index.js</code>在async <code>getStaticProps</code>函数中获取数据。</p>
<p>在After.js项目中，我们使用component类的<code>getInitialProps</code>静态方法在呈现页面之前提取数据。</p>
<p>在这两个组件中，获取的数据在组件中作为道具可用。</p>
<p><a href="https://blog.logrocket.com/handling-data-fetching-next-js-useswr/" target="_blank" rel="noopener">在Next.js </a>中，为环境变量增加了内置支持。我们所需要的就是在我们的根项目中创建一个<code>.env.local file</code>,并添加:</p>
<pre>NEWS_API_KEY=</pre>
<p>一旦保存，文件将自动加载，变量将用于我们的应用程序。</p>
<p>而且，在After.js项目中，环境变量存储在<code>.env</code>文件中，我们可以在项目中使用的环境变量的键必须以<code>RAZZLE_</code>为前缀。</p>
<p>例如，我们可以这样写:</p>
<pre>RAZZLE_APIKEY=your_api_key</pre>
<p>在这两个框架中，环境变量都是作为<code>process.env</code>对象的属性提供的。</p>
<h2>结论</h2>
<p>Next.js和After.js都可以用来构建服务器端呈现的项目。它们有助于轻松构建服务器端渲染应用。</p>
<p>Next.js和After.js的主要区别在于路由。Next.js根据组件的名称以及组件文件是否在<code>pages</code>文件夹中，将URL映射到组件。相比之下，After.js使用React路由器进行路由，我们必须自己进行配置。</p><div class="code-block code-block-17">
<div class="blog-plug inline-plug react-plug" vwo-el-id="26283398190">
<h2 vwo-el-id="41600691720">使用LogRocket消除传统反应错误报告的噪音</h2>
<a href="https://lp.logrocket.com/blg/react-signup-issue-free" target="_blank" vwo-el-id="19356441070">LogRocket
</a><p>是一款React analytics解决方案，可保护您免受数百个误报错误警报的影响，只针对少数真正重要的项目。LogRocket告诉您React应用程序中实际影响用户的最具影响力的bug和UX问题。</p><a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="19356441380">
<img class="first-react-image alignnone size-full wp-image-46 jetpack-lazy-image jetpack-lazy-image--handled" src="../Images/f300c244a1a1cf916df8b4cb02bec6c6.png" vwo-el-id="18272717540" data-lazy-loaded="1" data-original-src="https://files.readme.io/27c94e7-Image_2017-06-05_at_9.46.04_PM.png"/>
</a>
<a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="19356441690">
<img class="second-react-image alignnone size-full wp-image-46 jetpack-lazy-image jetpack-lazy-image--handled" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" vwo-el-id="30720362350" data-lazy-loaded="1" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/>
</a>
<a href="https://lp.logrocket.com/blg/react-signup-issue-free" target="_blank" rel="noopener noreferrer" vwo-el-id="35866400580">LogRocket
</a><p>自动聚合客户端错误、反应错误边界、还原状态、缓慢的组件加载时间、JS异常、前端性能指标和用户交互。然后，LogRocket使用机器学习来通知您影响大多数用户的最具影响力的问题，并提供您修复它所需的上下文。</p><p vwo-el-id="28675661060">关注重要的React bug—<a class="signup" href="https://lp.logrocket.com/blg/react-signup-issue-free" target="_blank" rel="noopener noreferrer" vwo-el-id="40093418840">今天就试试LogRocket】。</a></p>
</div></div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
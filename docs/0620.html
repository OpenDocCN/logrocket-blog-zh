<html>
<head>
<title>Is TypeScript worth it? - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>TypeScript值得吗？- LogRocket博客</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/is-typescript-worth-it/#0001-01-01">https://blog.logrocket.com/is-typescript-worth-it/#0001-01-01</a></blockquote><div><article class="article-post">
<p>在我开始之前，我想让陪审团知道，在很大程度上，我是一个打字爱好者。它是我做的前端React项目和任何后端节点工作的主要编程语言。我同意，但是我确实有一些困扰我的疑问，我想在这篇文章中讨论一下。至少三年来，我除了打字稿之外什么也没写，写了无数份合同，所以打字稿<em>是在做正确的事情，或者是在满足需求。</em></p>
<p>TypeScript克服了一些不可克服的困难，成为前端编程领域的主流。TypeScript在这篇文章中排名第七，列出了最受欢迎的编程语言。</p>
<p>无论您是否使用TypeScript，以下实践应该适用于任何软件团队，无论其规模如何:</p>
<ul>
<li>写得好的单元测试应该覆盖尽可能多的被认为合理的产品代码</li>
<li>结对编程——多一双眼睛可以捕捉到比语法错误更多的东西</li>
<li>一个好的同行评审过程——适当的同行评审可以发现许多机器无法发现的错误</li>
<li>使用棉绒，如<a href="https://eslint.org/" target="_blank" rel="noopener noreferrer"> eslint </a></li>
</ul>
<p>TypeScript可以在这些之上增加额外的安全层，但我觉得它在受欢迎的编程语言列表中远远落后。</p>
<h2>TypeScript不是健全的类型系统</h2>
<p>我认为这可能是当前TypeScript版本的主要问题，但是首先，让我定义一下什么是<em>健全的</em>和<em>不健全的</em>类型系统。</p>
<h2>健康</h2>
<p>一个<em>声音</em>类型的系统可以确保你的程序不会进入无效状态。例如，如果一个表达式的静态类型是<code>string</code>，那么在运行时，当你对它求值时，你只能得到一个<code>string</code>。</p>
<p>在声音类型系统中，你不应该在编译时<strong>或运行时</strong>处于表达式与预期类型不匹配的位置。</p>
<p>当然，合理与否有不同的程度，合理与否可以有不同的解释。TypeScript在一定程度上是合理的，并捕获以下类型错误:</p>
<pre>// Type 'string' is not assignable to type 'number'
const increment = (i: number): number =&gt; { return i + "1"; }

// Argument of type '"98765432"' is not assignable to parameter of type 'number'.
const countdown: number = increment("98765432");</pre>
<h2>不健全</h2>
<p>Typescript完全坦率地承认100%的可靠性不是一个目标，TypeScript 的<a href="https://github.com/Microsoft/TypeScript/wiki/TypeScript-Design-Goals" target="_blank" rel="noopener noreferrer">非目标列表中的第三个非目标明确指出:</a></p>
<blockquote><p>应用一个可靠的或“可证明正确的”类型系统。相反，在正确性和生产力之间取得平衡。</p></blockquote>
<p>这意味着不能保证变量在运行时有一个已定义的类型。我可以用下面这个有点做作的例子来说明这一点:</p>
<pre>interface A {
    x: number;
}

let a: A = {x: 3}
let b: {x: number | string} = a; 
b.x = "unsound";
let x: number = a.x; // unsound

a.x.toFixed(0); // WTF is it?</pre>
<p>上面的代码是<em>不健全的</em>，因为从<code>A</code>接口得知<code>a.x</code>是一个数字。不幸的是，在一些重新分配诡计之后，它以字符串结束，并且下面的代码在运行时编译但是出错。</p>
<p>不幸的是，这里显示的表达式编译时没有任何错误:</p>
<pre>a.x.toFixed(0);</pre>
<p>我认为这可能是TypeScript最大的问题，因为健全不是目标。我仍然遇到许多运行时错误，这些错误没有被<code>tsc</code>编译器标记出来，如果TypeScript有一个健全的系统，这些错误就会被标记出来。对于这种方法，TypeScript同时站在了健康和不健康的阵营中。这种折中的方法是通过<code>any</code>类型来实现的，我将在后面提到。</p>
<p>我仍然不得不写同样多的测试，我发现这令人沮丧。当我第一次开始使用TypeScript时，我错误地认为我可以停止编写这么多单元测试的苦差事。</p>
<p>TypeScript挑战现状，声称降低使用类型的认知开销比类型可靠性更重要。</p>
<p>我理解为什么TypeScript走上了这条路，有一种观点认为，如果一个健全的类型系统得到100%的保证，那么TypeScript的采用率就不会这么高。这被证明是错误的，因为随着Flutter现在被广泛使用，dart语言终于开始流行了。可靠性是dart语言的一个目标，这里的<a href="https://dart.dev/guides/language/sound-dart" target="_blank" rel="noopener noreferrer">将讨论这个目标。</a></p>
<p>TypeScript的不健全性和暴露严格类型的各种方式使得它不那么有效，并且不幸地使它现在<strong>比什么都没有</strong>要好。我的愿望是，随着TypeScript越来越受欢迎，有更多的编译器选项可供使用，以使高级用户能够努力实现100%的可靠性。</p>
<h2>TypeScript不保证任何运行时类型检查</h2>
<p>运行时类型检查不是TypeScript的目标之一，所以这个愿望可能永远不会实现。例如，当处理从API调用返回的JSON有效负载时，运行时类型检查将是有益的。如果我们能够在类型级别控制这一点，那么整个错误类别和许多单元测试就不需要存在了。</p>
<p>我们不能在运行时保证任何事情，所以这可能会发生:</p>
<pre>const getFullName = async (): string =&gt; {
  const person: AxiosResponse = await api();
  
  //response.name.fullName may result in undefined at runtime
  return response.name.fullName
}</pre>
<p>有一些像<a href="https://github.com/gcanti/io-ts" target="_blank" rel="noopener noreferrer"> io-ts </a>这样的支持库，这很好，但是可能意味着你必须复制你的模型。</p>
<h2>可怕的类型和严格选项</h2>
<p>类型就是这个意思，编译器允许任何操作或赋值。</p>
<p>TypeScript对于小事情来说工作得很好，但是人们倾向于用超过一分钟的时间来打任何东西。我最近做了一个Angular项目，看到了很多这样的代码:</p>
<pre>export class Person {
 public _id: any;
 public name: any;
 public icon: any;</pre>
<p>TypeScript让你忘记了类型系统。</p>
<p>你可以用一个<code>any</code>造型把任何东西炸出来:</p>
<pre>("oh my goodness" as any).ToFixed(1); // remember what I said about soundness?</pre>
<p><code>strict</code>编译器选项启用了以下编译器设置，这些设置确实使事情变得更加合理:</p>
<ul>
<li><code> --strictNullChecks</code></li>
<li><code>--noImplicitAny</code></li>
<li><code> --noImplicitThis</code></li>
<li><code> --alwaysStrict</code></li>
</ul>
<p>还有eslint规则<a href="https://github.com/typescript-eslint/typescript-eslint/blob/master/packages/eslint-plugin/docs/rules/no-explicit-any.md" target="_blank" rel="noopener noreferrer">@ typescript-eslint/no-explicit-any</a>。</p>
<p><code>any</code>的泛滥会破坏你打字的正确性。</p>
<h2>结论</h2>
<p>我必须重申，我是一个TypeScript迷，我在日常工作中使用它，但我确实觉得它不够好，炒作并不完全合理。Airbnb声称，38%的bug可以通过TypeScript来防止。我非常怀疑这个精确的百分比。TypeScript不是对现有的良好实践的涡轮增压。我仍然需要写同样多的测试。你可能会争辩说，我正在编写更多的代码，我可能不得不编写类型测试。我仍然会遇到意外的运行时错误。</p>
<p>TypeScript提供了以上的基本类型检查，但是健全性和运行时类型检查并不是目标，这使得TypeScript处于一个不幸的中途站，一只脚处于一个更好的世界，一只脚处于我们当前所处的位置。</p>
<p>TypeScript的亮点在于它有很好的IDE支持，比如vscode，如果我们输入错误，它可以提供可视化的反馈。</p>
<figure id="attachment_12577" aria-describedby="caption-attachment-12577" class="wp-caption aligncenter"><img data-attachment-id="12577" data-permalink="https://blog.logrocket.com/is-typescript-worth-it/squigly/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/01/squigly.png" data-orig-size="352,128" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="squigly" data-image-description="" data-image-caption="&lt;p&gt;TypeScript error in vscode&lt;/p&gt;&#10;" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/01/squigly-300x109.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/01/squigly.png" decoding="async" class="wp-image-12577 size-full jetpack-lazy-image" src="../Images/be93d8b595b7c3dd2e48818c1a873805.png" alt="typescript error in vscode" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2020/01/squigly.png 352w, https://blog.logrocket.com/wp-content/uploads/2020/01/squigly-300x109.png 300w" data-lazy-sizes="(max-width: 352px) 100vw, 352px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2020/01/squigly.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/01/squigly.png"/><noscript><img data-lazy-fallback="1" data-attachment-id="12577" data-permalink="https://blog.logrocket.com/is-typescript-worth-it/squigly/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/01/squigly.png" data-orig-size="352,128" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="squigly" data-image-description="" data-image-caption="&lt;p&gt;TypeScript error in vscode&lt;/p&gt;&#10;" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/01/squigly-300x109.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/01/squigly.png" decoding="async" loading="lazy" class="wp-image-12577 size-full" src="../Images/be93d8b595b7c3dd2e48818c1a873805.png" alt="typescript error in vscode" srcset="https://blog.logrocket.com/wp-content/uploads/2020/01/squigly.png 352w, https://blog.logrocket.com/wp-content/uploads/2020/01/squigly-300x109.png 300w" sizes="(max-width: 352px) 100vw, 352px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/01/squigly.png"/></noscript><figcaption id="caption-attachment-12577" class="wp-caption-text">TypeScript error in vscode</figcaption></figure>
<p>重构也通过TypeScript得到了增强，当对修改后的代码运行TypeScript编译器时，代码中的中断(如方法签名中的更改)会被立即识别出来。</p>
<p>TypeScript实现了良好的类型检查，肯定比没有类型检查器或只是普通的eslint要好，但我觉得它可以做得更多，足够的编译器选项可以提供给我们这些想要更多的人。</p><div class="code-block code-block-21">
<div class="blog-plug inline-plug typescript-plug"><h2><a class="signup" href="https://lp.logrocket.com/blg/typescript-signup" target="_blank" rel="noopener noreferrer"> LogRocket </a>:全面了解您的网络和移动应用</h2>
<a href="https://lp.logrocket.com/blg/typescript-signup" class="signup" target="_blank" rel="noopener noreferrer"><img class="alignnone size-full wp-image-46 jetpack-lazy-image" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/><noscript><img data-lazy-fallback="1" class="alignnone size-full wp-image-46" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/></noscript></a>
<p>LogRocket 是一个前端应用程序监控解决方案，可以让您回放问题，就像问题发生在您自己的浏览器中一样。LogRocket不需要猜测错误发生的原因，也不需要向用户询问截图和日志转储，而是让您重放会话以快速了解哪里出错了。它可以与任何应用程序完美配合，不管是什么框架，并且有插件可以记录来自Redux、Vuex和@ngrx/store的额外上下文。</p>
<p>除了记录Redux操作和状态，LogRocket还记录控制台日志、JavaScript错误、堆栈跟踪、带有头+正文的网络请求/响应、浏览器元数据和自定义日志。它还使用DOM来记录页面上的HTML和CSS，甚至为最复杂的单页面和移动应用程序重新创建像素级完美视频。</p>
<a class="signup" href="https://lp.logrocket.com/blg/typescript-signup" target="_blank" rel="noopener noreferrer">Try it for free</a><p>.</p></div>
</div>
<h2/>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
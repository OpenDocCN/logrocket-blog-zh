<html>
<head>
<title>Avoid overfetching with properly designed GraphQL resolvers - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>避免过度使用正确设计的GraphQL解析器</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/properly-designed-graphql-resolvers/#0001-01-01">https://blog.logrocket.com/properly-designed-graphql-resolvers/#0001-01-01</a></blockquote><div><article class="article-post">
<h2>介绍</h2>
<p>如果您正在阅读这篇文章，那么我假设您对GraphQL带来的好处深信不疑。您可能听说过，GraphQL解决了REST的一个基本问题，即数据的过提取和欠提取。</p>
<p>当您为移动优先应用构建服务器时，这些问题会变得更加明显。在REST中，有两种方法可以构建和设计新的需求:</p>
<ul>
<li>创建新的端点</li>
<li>通过获取现有端点的额外信息来重用现有端点</li>
</ul>
<p>这两种方法都有自己的权衡:第一种选择将导致更多的往返，如果移动用户处于不稳定的网络条件下，这是不理想的；第二种选择会不必要地浪费带宽。</p>
<p>我们可以用GraphQL很好地解决这两个问题，因为它承诺给我们所要求的。但是如果你不了解GraphQL解析器的特性，即使使用GraphQL也可能会遇到过度提取的问题。设计良好的解析器是获得GraphQL好处的基础。</p>
<h2>查询的简要回顾</h2>
<p>简单地说，解析器是解析GraphQL类型的值或GraphQL类型的字段的函数。然而，在我们进入解析器设计过程之前，让我们简要地看一下GraphQL查询类型。</p>
<p>真正让GraphQL查询成功的是它们看起来像JSON，并且每个人都非常了解JSON。为了便于解释，让我们设计一个GraphQL API，用于从学校数据库中获取数据，该数据库中有学生和课程信息。</p>
<p>假设您正在编写一个如下所示的查询:</p>
<pre>query {
  student(id: "student1") {
    name,
    courses {
      title
    }
  }
}</pre>
<p>在这个查询命中相应的解析器之前，它被解析成树/图。您可能已经知道，查询是一种根类型。这意味着查询将是树的根节点，如下所示:</p>
<p><img data-attachment-id="20283" data-permalink="https://blog.logrocket.com/properly-designed-graphql-resolvers/query-tree-diagram/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/06/query-tree-diagram.png" data-orig-size="730,884" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="GraphQL query tree diagram" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/06/query-tree-diagram-248x300.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/06/query-tree-diagram.png" decoding="async" class="aligncenter size-full wp-image-20283 jetpack-lazy-image" src="../Images/e1d8a9e892e522677ca0d8d1b1220693.png" alt="GraphQL Query Tree Diagram" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2020/06/query-tree-diagram.png 730w, https://blog.logrocket.com/wp-content/uploads/2020/06/query-tree-diagram-248x300.png 248w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2020/06/query-tree-diagram.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/06/query-tree-diagram.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="20283" data-permalink="https://blog.logrocket.com/properly-designed-graphql-resolvers/query-tree-diagram/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/06/query-tree-diagram.png" data-orig-size="730,884" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="GraphQL query tree diagram" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/06/query-tree-diagram-248x300.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/06/query-tree-diagram.png" decoding="async" loading="lazy" class="aligncenter size-full wp-image-20283" src="../Images/e1d8a9e892e522677ca0d8d1b1220693.png" alt="GraphQL Query Tree Diagram" srcset="https://blog.logrocket.com/wp-content/uploads/2020/06/query-tree-diagram.png 730w, https://blog.logrocket.com/wp-content/uploads/2020/06/query-tree-diagram-248x300.png 248w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/06/query-tree-diagram.png"/></noscript>
<p>如您所见，query是根节点，而student、name、courses和title是子节点。在到达解析器之前，GraphQL查询被解析成这样的树。这种可视化查询的方式很有用，因为高效的解析器是基于查询的实际结构设计的。</p>
<p>继续前进。现在我们知道了如何将查询可视化为树，让我们继续编写解析器。GraphQL中的解析器具有以下结构:</p>
<pre>const resolvers = {
  Query: {
    student: (root, args, context, info) =&gt; { return students[args['id']] }
  }
}</pre>
<ul>
<li><code>root</code>–表示来自父类型的结果</li>
<li><code>args</code>–传递给解析器的参数</li>
<li><code>context</code>–一个可变对象，可用于存储/传递会话数据、req (in Express)等常见配置。</li>
<li><code>info</code>–包含<code>fieldName</code>、<code>fieldNodes</code>、<code>returnType</code>等字段信息。</li>
</ul>
<p>就像我之前提到的，解析器可以为每种类型和每种字段编写。让我们继续为<code>Student</code>类型编写一个解析器。我们的模式文件如下所示:</p>
<pre>  type Query {
    student(id: String!): Student
  }

  type Course {
    id: String!
    title: String
  }

  type Student {
    id: String!
    name: String
    courses: [Course]
  }</pre>
<p>我喜欢将解析器保存在一个单独的文件中。为了这个例子，我将数据存储在全局变量中。我的<code>resolvers.js</code>文件是这样的:</p>
<pre>var students = {
  'student1': {
    id: 'student1',
    name: 'karthik',
    courses: ['math101', 'geography201']
  },
  'student2': {
    id: 'student2',
    name: 'john',
    courses: ['physics201', 'chemistry103']
  },
};


var courses = {
  'math101': {
    id: 'math101',
    title: 'Intro to algebra',
  },
  'geography201': {
    id: 'geography201',
    title: 'Intro to maps',
  },
  'physics201': {
    id: 'physics201',
    title: 'Intro to physics',
  },
  'chemistry103': {
    id: 'chemistry103',
    title: 'Intro to organic chemistry',
  },
};

const resolvers = {
  Query: {
    student: (root, args, context, info) =&gt; { 
      return students[args['id']]
    }
  }
}

module.exports = resolvers
</pre>
<p>正如我们所见，<code>student</code>的解析器在其<code>args</code>中接受一个<code>id</code>，并从<code>students</code>对象中返回相应的学生:</p>
<p><img data-attachment-id="20284" data-permalink="https://blog.logrocket.com/properly-designed-graphql-resolvers/student-query-results/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/06/student-query-results.png" data-orig-size="730,332" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Student query results" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/06/student-query-results-300x136.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/06/student-query-results.png" decoding="async" class="aligncenter size-full wp-image-20284 jetpack-lazy-image" src="../Images/6b19424792e61216c66aa0c885e3d953.png" alt="Student Query Results" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2020/06/student-query-results.png 730w, https://blog.logrocket.com/wp-content/uploads/2020/06/student-query-results-300x136.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2020/06/student-query-results.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/06/student-query-results.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="20284" data-permalink="https://blog.logrocket.com/properly-designed-graphql-resolvers/student-query-results/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/06/student-query-results.png" data-orig-size="730,332" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Student query results" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/06/student-query-results-300x136.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/06/student-query-results.png" decoding="async" loading="lazy" class="aligncenter size-full wp-image-20284" src="../Images/6b19424792e61216c66aa0c885e3d953.png" alt="Student Query Results" srcset="https://blog.logrocket.com/wp-content/uploads/2020/06/student-query-results.png 730w, https://blog.logrocket.com/wp-content/uploads/2020/06/student-query-results-300x136.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/06/student-query-results.png"/></noscript>
<p>好了，我们刚刚看到了传递的参数ID<code>"student1"</code>是如何通过解析器的参数<code>"args"</code>命中解析器的。让我们探讨一下其他论点。</p>
<h3><code>root</code></h3>
<p>每个graphQL类型都有一个默认的解析器。当您没有为类型或字段编写解析器时，GraphQL会自动在根中查找与字段或类型同名的属性。默认的解析器如下所示:</p>
<pre>const resolvers = {
  Query: {
    student: (root, args, context, info) =&gt; { 
      return students[args['id']]
    },
  },
  Student: {
    name: (root, args, context, info) =&gt; {
      return root.name;
    }
  }
}

module.exports = resolvers</pre>
<p>在第8–9行，我基本上实现了默认的<code>name </code>字段解析器的功能。如果你想测试理论，返回一个静态字符串，而不是<code>root.name</code>。您会注意到它将所有查询的静态字符串返回给<code>student(id)</code>。</p>
<h3><code>context</code></h3>
<p><code>context</code>可用于在解析器之间传递信息。例如，如果您想将<code>req </code>对象传递给所有字段，您可以简单地通过添加<code>req</code>来改变<code>context</code>。</p>
<p>好吧！最基本的东西。让我们看看设计旋变器时可能会不知不觉地遇到的一些潜在问题，以及如何克服这些问题。</p>
<h2>解决方案的问题</h2>
<h3>过度蚀刻</h3>
<p>是啊！你没看错。这不正是我们远离休息的原因吗？绝对的！但是，由于我们设计解析器的方式，有些情况下我们可能会经历过蚀刻。</p>
<p>例如，如果您想为<code>student</code>类型的<code>"courses" </code>编写一个解析器，并通过<code>student</code>查询获取课程，我们可以这样做:</p>
<pre>const resolvers = {
  Query: {
    student: (root, args, context, info) =&gt; {
      const studentCourses = students[args['id']]['courses'].map(id =&gt; {return courses[id]})
      return {
        ...students[args['id']],
        "courses": studentCourses
      }
    },
  },
  Student: {
    name: (root, args, context, info) =&gt; {
      return root.name;
    }
  }
}
</pre>
<p><img data-attachment-id="20285" data-permalink="https://blog.logrocket.com/properly-designed-graphql-resolvers/student-courses-query-results/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/06/student-courses-query-results.png" data-orig-size="730,448" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Student courses query results" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/06/student-courses-query-results-300x184.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/06/student-courses-query-results.png" decoding="async" class="aligncenter size-full wp-image-20285 jetpack-lazy-image" src="../Images/bb58eba49e2d62a6cf86ae6fe7cbe992.png" alt="Student Courses Query Results" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2020/06/student-courses-query-results.png 730w, https://blog.logrocket.com/wp-content/uploads/2020/06/student-courses-query-results-300x184.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2020/06/student-courses-query-results.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/06/student-courses-query-results.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="20285" data-permalink="https://blog.logrocket.com/properly-designed-graphql-resolvers/student-courses-query-results/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/06/student-courses-query-results.png" data-orig-size="730,448" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Student courses query results" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/06/student-courses-query-results-300x184.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/06/student-courses-query-results.png" decoding="async" loading="lazy" class="aligncenter size-full wp-image-20285" src="../Images/bb58eba49e2d62a6cf86ae6fe7cbe992.png" alt="Student Courses Query Results" srcset="https://blog.logrocket.com/wp-content/uploads/2020/06/student-courses-query-results.png 730w, https://blog.logrocket.com/wp-content/uploads/2020/06/student-courses-query-results-300x184.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/06/student-courses-query-results.png"/></noscript>
<h4>问题1:如果我们编写一个只询问学生<code>id</code>和<code>name</code>的查询，会发生什么？</h4>
<p>我们仍然会不必要地执行第4行中的操作。在现实世界中，这甚至可能是一个昂贵的API调用。但是当GraphQL解析查询时，它会将多余的数据丢弃。</p>
<p>从表面上看，我们似乎仍然只是得到了我们想要的。但是在幕后，由于我们设计解析器的方式，我们已经迫使我们的服务器过度提取。</p>
<p><strong>解决方案:</strong>将<code>courses</code>解析器移动到<code>courses</code>字段。</p>
<pre>const resolvers = {
  Query: {
    student: (root, args, context, info) =&gt; {
      return students[args['id']];
    },
  },
  Student: {
    name: (root, args, context, info) =&gt; {
      return root.name;
    },
    courses: (root, args, context, info) =&gt; {
      return root.courses.map(id =&gt; courses[id]);
    }
  }
}</pre>
<p>请注意我是如何利用<code>root </code>论点为我所用的。这就是为什么将查询可视化为树并理解根节点以及如何使用它很有用的确切原因。现在，如果我们只查询<code>id</code>和<code>name</code>，我们没有不必要的解析课程的风险。</p>
<p>太好了！那么采用这种模式能解决我们所有的问题吗？可惜没有！</p>
<h4>问题2:如果我们编写一个查询，只获取课程的数据，会发生什么？</h4>
<p>你可能认为它只会解析<code>courses</code>解析器。但是，再一次，想想树——首先解决的是什么？<code>student</code>解析器！</p>
<p><code>student</code>节点是<code>courses</code>节点的父节点，GraphQL以<a href="https://en.wikipedia.org/wiki/Breadth-first_search">广度优先搜索</a>的方式解析，这意味着在<code>courses</code>节点之前解析<code>student</code>节点，以便填充<code>courses</code>节点的<code>root </code>参数。</p>
<p>再次，我们遇到过度蚀刻。现在该怎么办？</p>
<p>让我们将<code>student</code>解析器移到它的字段中，并分别解析这些字段。</p><div class="code-block code-block-54">
<hr/>
<h3>更多来自LogRocket的精彩文章:</h3>

<hr/></div>
<pre>const resolvers = {
  Query: {
    student: (root, args, context, info) =&gt; {
      return args['id'];
    },
  },
  Student: {
    id: (root, args, context, info) =&gt; {
      return students[root]['id'];
    },
    name: (root, args, context, info) =&gt; {
      return students[root]['name'];
    },
    courses: (root, args, context, info) =&gt; {
      return students[root]['courses'].map(id =&gt; courses[id]);
    }
  }
}
</pre>
<p>注意我是如何从<code>student</code>解析器返回<code>id </code>并将关注点转移到各个字段的。各个字段现在负责解析其值。</p>
<p>好的，太好了！那么这是否解决了我们现在过度蚀刻的问题呢？的确如此，但有一个警告。</p>
<h4>问题3:如果我们查询<code>id</code>、<code>name</code>和<code>courses</code>，会发生什么？</h4>
<p><code>student</code>对象被提取两次，分别用于<code>id </code>和<code>name</code>。但是<code>courses</code>对象只取了一个。如果我们以这样一种更清晰、更易测试的方式编写代码，那么这种重复请求的问题就更容易解决了。</p>
<p>通过简单地查看在解析器中使用这个API的类型的字段数量，我们可以清楚地看到一个特定的API将被调用多少次。幸运的是，有一些解决方案可以帮助解决请求重复问题:</p>

<p>这个问题在GraphQL中也被称为N + 1问题，因为我们调用一次来解析student，调用N次来解析嵌套在根类型(<code>student</code>)中的N个类型。</p>
<h4>有必要在我的GraphQL服务器中使用这些解决方案吗？</h4>
<p>看情况！如果您已经拥有用于与底层数据库对话的丰富的数据库API(或ORM)代码库，并且如果您怀疑其中一些调用将被重用来解析您的GraphQL模式中的不同字段，那么采用如上所述的重复数据删除解决方案来充分实现GraphQL的性能优势是一个很好的实践。</p>
<p>您可能已经注意到，我们在第9行和第12行重复地做类似的操作。在现实世界的项目中，这可能是一个API调用，多次调用API来解析不同的字段可能表面上看起来很糟糕，并诱使您重构它。</p>
<p>但是理解它所解决的问题要重要得多。当您设置了重复数据删除解决方案时，可能只进行一次API调用，然后缓存起来供重用。</p>
<h2>数据库调用</h2>
<p>到目前为止，我们已经看到了在编写解析器时如何避免一些常见的问题。现在，让我们看看如何构建数据库调用，以及有哪些选项可供我们使用。</p>
<h3>MySQL/PostgreSQL</h3>
<p>如果你使用的是SQL数据库，你可能已经使用了类似于<a href="https://sequelize.org/master/"> sequelize </a>或<a href="https://www.sqlalchemy.org/"> sqlalchemy </a>的ORM从你的数据库中获取数据。如果是这样的话，在解析器函数中调用序列化API是最理想的。这样，您可以确定特定于该特定字段的呼叫范围。</p>
<p>使用解析器的<code>context </code>字段传递数据库配置通常也是一个好主意。</p>
<h3>MongoDB</h3>
<p>对于MongoDB，您可以在解析器中直接使用Mongo<a href="https://docs.mongodb.com/manual/crud/">CRUD</a>API。</p>
<h2>结论</h2>
<p>我希望你喜欢阅读这篇关于GraphQL解析器的文章，也希望你觉得它有用。请随意留下任何问题或反馈。🙂</p><div class="code-block code-block-24">
<div class="blog-plug inline-plug graphql-plug"><h2>监控生产中失败和缓慢的GraphQL请求</h2><p>虽然GraphQL有一些调试请求和响应的特性，但确保GraphQL可靠地为您的生产应用程序提供资源是一件比较困难的事情。如果您对确保对后端或第三方服务的网络请求成功感兴趣，</p><a href="https://lp.logrocket.com/blg/graphql-signup" target="_blank">try LogRocket</a><p>.</p><a class="signup" href="https://lp.logrocket.com/blg/graphql-signup" target="_blank" rel="noopener noreferrer"><img src="../Images/432a3823c85b3fb72a206e6236a29f48.png" data-lazy-src="https://files.readme.io/69aa835-Image_2019-11-09_at_1.28.05_PM.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" class=" jetpack-lazy-image" data-original-src="https://files.readme.io/69aa835-Image_2019-11-09_at_1.28.05_PM.png"/><noscript><img data-lazy-fallback="1" src="../Images/432a3823c85b3fb72a206e6236a29f48.png" data-original-src="https://files.readme.io/69aa835-Image_2019-11-09_at_1.28.05_PM.png"/></noscript><img class="alignnone size-full wp-image-46 jetpack-lazy-image" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/><noscript><img data-lazy-fallback="1" class="alignnone size-full wp-image-46" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/></noscript></a><a href="https://lp.logrocket.com/blg/graphql-signup" target="_blank" rel="noopener noreferrer">https://logrocket.com/signup/</a><p>LogRocket 就像是网络和移动应用的DVR，记录下你网站上发生的每一件事。您可以汇总并报告有问题的GraphQL请求，以快速了解根本原因，而不是猜测问题发生的原因。此外，您可以跟踪Apollo客户机状态并检查GraphQL查询的键值对。</p><p>LogRocket检测您的应用程序以记录基线性能计时，如页面加载时间、到达第一个字节的时间、慢速网络请求，还记录Redux、NgRx和Vuex操作/状态。</p><a class="signup" href="https://lp.logrocket.com/blg/graphql-signup" target="_blank" rel="noopener noreferrer">Start monitoring for free</a><p>.</p></div>


</div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
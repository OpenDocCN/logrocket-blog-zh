<html>
<head>
<title>PRPL pattern: Solutions for modern web app optimization - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>PRPL模式:现代web应用优化的解决方案</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/prpl-pattern-solutions-for-modern-web-app-optimization/#0001-01-01">https://blog.logrocket.com/prpl-pattern-solutions-for-modern-web-app-optimization/#0001-01-01</a></blockquote><div><article class="article-post">
<h2>什么是PRPL模式？</h2>
<p>PRPL是一种模式，用于构建具有出色用户体验的可伸缩、快速的现代web应用程序。</p>
<p>PRPL是以下单词的首字母缩写:</p>
<ul>
<li><strong>推送</strong>(或<strong>预载</strong>)最重要的资源</li>
<li><strong>尽快渲染</strong>初始路线</li>
<li><strong>预缓存</strong>剩余资产</li>
<li><strong>惰性负载</strong>其他路线和非关键资产</li>
</ul>
<p>PRPL架构是由谷歌Chrome团队构思的，旨在提高网络速度。</p>
<p>这个PRPL是多年来开发的一个个人优化技巧，旨在促进更快的网络体验。这是随着服务工作者、后台同步、缓存API、优先级提示和预取的出现而出现的。</p>
<p>具体来说，当手机离线或处于数据保护模式时，PRPL适用于网络较弱的手机。</p>
<p>在本帖中，我们将看看PRPL的每个单元。</p>
<h3>p–推动(或预载)</h3>
<p>这告诉浏览器预先获取资源并将其存储在浏览器中。因此，当我们需要资源时，可以从浏览器中快速检索资源，而无需通过网络获取资源。这是通过使用<code>rel="preload"</code>完成的。</p>
<blockquote><p>Preload是一个声明性的获取请求，告诉浏览器尽快请求资源。通过在你的HTML文档头添加一个带有<code>rel="preload"</code>的<code>&lt;link&gt;</code>标签来预加载关键资源。</p></blockquote>
<p>为了预加载一个资源，我们使用link标签并为其添加<code>rel='preload'</code>属性。</p>
<pre>&lt;link rel="preload" as="style" href="style.css"&gt;</pre>
<p>这将把资源<code>style.css</code>作为样式表预加载。<code>as='style'</code>告诉浏览器要预加载的资源是一个样式表，应该这样加载。</p>
<p>可以预加载的资源包括:</p>
<ul>
<li>网页</li>
<li>JS文件</li>
<li>CSS文件</li>
<li>媒体文件(音频、图像、视频、文档和Web字体)</li>
<li>DNS查找</li>
</ul>
<pre>&lt;link rel="preload" href="/your/webpage/link"&gt;</pre>
<pre>&lt;link rel="preload" href="/your/js/file/link"&gt;</pre>
<pre>&lt;link rel="preload" href="/your/css/file/link"&gt;</pre>
<pre>&lt;link rel="preload" href="/your/audio/file/link"&gt;</pre>
<pre>&lt;link rel="preload" href="/your/audio/file/link"&gt;</pre>
<pre>&lt;link rel="preload" href="/your/video/file/link"&gt;</pre>
<pre>&lt;link rel="preload" href="/your/image/file/link"&gt;</pre>
<pre>&lt;link rel="preload" href="/your/document/file/link"&gt;</pre>
<pre>&lt;link rel="preload" href="/your/webfont/file/link"&gt;</pre>
<p>预装和预取基本相同。</p>
<p>预取包括一个过程，通过这个过程，浏览器获取一个<code>&lt;link&gt;</code>标签的资源，并将其存储在其本地缓存中。当用户最终通过<code>&lt;link&gt;</code>标签请求页面时，浏览器为用户提供缓存的页面。这加快了网页的加载和渲染速度。</p>
<p>为了预取资源，我们使用了<code>rel="prefetch"</code>属性。</p>
<pre>&lt;link rel="prefetch"&gt;</pre>
<p>这将预取那里的任何资源，就像预加载一样。</p>
<h3>r–初始渲染</h3>
<p>这是一条规则，规定web应用程序的初始路由应该尽可能快地呈现，并且初始路由不应该延迟加载。</p>
<p>我们称之为最初的心满意足的绘画。无论应用程序做什么，它必须在浏览器上快速生成第一个画图。为了优化第一个内容丰富的绘画，我们必须消除渲染阻塞资源，优化CSS交付，并使用SSR。</p>
<p>这主要适用于JS框架，因为它们在浏览器/客户端呈现其有效负载，所以如果应用程序的有效负载很大，您会看到它必须在呈现其内容之前加载JS/CSS资产。</p>
<p>因此，您的web应用程序上的SSR将有助于在服务器中呈现web应用程序，并在其余的JS/CSS到达之前生成第一幅画。<br/>例如，在React中，我们可以使用<code>ReactDOMServer</code>构建一个服务器端渲染的应用。</p>
<p>让我们看一个例子:</p>
<pre>import React from "react" import ReactDOM from "react-dom" import App from "App"

ReactDOM.hydrate(&lt;App /&gt;, window.root)</pre>
<p>我们使用<code>ReactDOM.hydrate</code>而不是render，因为我们想让React DOM renderer知道我们正在服务器端渲染后重新水合应用程序。这意味着React DOM呈现器将从服务器获得呈现。它会先显示这个。然后，应用程序组件将从浏览器中进行反应。</p><div class="code-block code-block-54">
<hr/>
<h3>更多来自LogRocket的精彩文章:</h3>

<hr/></div>
<p>接下来，我们的Express服务器应该是这样的:</p>
<pre>import fs from "fs" import React from "react" import App from "./App" import ReactDOMServer from "react-dom/server"

...

app.get("/", (req, res, next) =&gt; { // This would render the &lt;App /&gt; and return it as string. const app = ReactDOMServer.renderToString(&lt;App /&gt;)

fs.readFile("./build/index.html", (err, data) =&gt; {
    // We read the index.html file, replace the `div#root` with the rendered App component and send it to the browser.
    return res.send(data.replace("&lt;div id='root'&gt;&lt;/div&gt;", "&lt;div id='root'&gt;" + app + "&lt;/div&gt;"))
})
})

...</pre>
<p>有了上面的代码，我们的React应用程序现在支持SSR了。它会在渲染整个负载之前渲染第一个绘画。</p>
<p>CSS交付包括将重要的CSS内联到HTML中，因此交付速度很快。</p>
<p>所有这些都将帮助您的web应用程序快速呈现初始路线，并在其余有效负载到达之前与用户进行交互。它提高了性能和用户体验。</p>
<h3>p–预缓存</h3>
<p>这是一种将资产缓存在浏览器中的技术，这样当发出对资产的请求时，就可以从缓存中处理这些请求，而不会中断用户体验。这在手机离线时很有帮助。</p>
<p>因此，用户看到的不是网络故障，而是缓存的资产。当手机上线时，资产会从网络上刷新。</p>
<p>预缓存由服务人员完成，主要用于PWAs。</p>
<p>服务人员的预缓存有不同的策略:</p>
<ul>
<li><strong> Stale-while-revalidate </strong>:该策略检查缓存中的响应。如果它是可用的，它被传递，并且缓存被重新验证。如果它不可用，服务工作者从网络获取响应并缓存它。</li>
<li><strong>先缓存</strong> <span>:该策略会先在缓存中寻找响应。如果发现之前缓存了任何响应，它将返回并服务于缓存。如果没有，它将从网络中获取响应，服务它，并缓存它以备下次使用。</span></li>
<li><strong>网络优先</strong> <span>:该策略将尝试从网络获取响应。如果成功，它将缓存响应并返回响应。如果网络出现故障，它将退回到缓存并在那里提供响应。</span></li>
<li><strong>仅缓存</strong> <span>:该策略仅从缓存<strong>响应</strong>。它不会退回到网络。</span></li>
<li><strong>仅网络</strong> <span>:该策略仅使用网络来获取和提供响应。它不会回退到任何缓存。</span></li>
</ul>
<p>Google有一个名为<a href="https://developers.google.com/web/tools/workbox" target="_blank" rel="noopener noreferrer"> Workbox </a>的库。它旨在为维护服务工作者的缓存提供工具，也提供了我们刚才看到的缓存策略供选择。</p>
<p>让我们看一个如何使用Workbox进行预缓存的例子。</p>
<p>使用Workbox，我们设置路线和我们想要使用的缓存策略。Workbox将监听路由请求，并确定如何缓存和响应请求。</p>
<pre>import { registerRoute } from 'workbox-routing'; import { NetworkFirst } from 'workbox-strategies';

registerRoute(

// We are caching the style resources.
({request}) =&gt; request.destination === 'style',

// We are setting the style cahcing to use the
// StaleWhileRevalidate strategy.
// Use cache but update in the background.
new StaleWhileRevalidate()
);</pre>
<p>上面是一个简单的例子，展示了如何在Workbox中缓存我们的样式资源来使用<code>StaleWhileRevalidate</code>策略。这将缓存我们所有的样式文件，以便在重载时更快地获取。它们在有网络的时候从后台悄悄更新。</p>
<pre>registerRoute( ({request}) =&gt; request.destination === 'script', new NetworkFirst() );</pre>
<p>这里，我们所有的JavaScript文件都是使用<code>NetworkFirst</code>策略缓存的。当通过网络提取失败时，从缓存中提取它们。</p>
<h3>l–延迟加载</h3>
<p>这是将web应用程序中的路线和资产的加载推迟到其他时间。</p>
<p>应用程序性能最重要的概念是<strong>响应时间</strong>和<strong>资源消耗</strong>。它们不可避免地会发生。任何地方都可能出现问题，在问题发生之前发现并解决问题非常重要。</p>
<p>延迟加载有助于将许多web应用程序性能问题的风险降至最低。惰性加载检查我们上面列出的概念:</p>
<ul>
<li><strong>响应时间</strong>:这是web应用程序加载和UI界面响应用户所需的时间。延迟加载通过代码分割和加载所需的包来优化响应时间。</li>
<li><strong>资源消耗</strong>:人类是没有耐心的生物。我们不喜欢一个网站的加载时间超过3秒。在那段时间里，70%的人会放弃。网络应用不应该花这么长时间来加载。因此，为了减少加载的资源量，延迟加载只加载当时必需的代码包。</li>
</ul>
<p>惰性加载可以在Chrome中本地完成，无需外部库的帮助。换句话说，浏览器本身将支持延迟加载。</p>
<p>这很简单，只需将<code>loading</code>属性添加到我们想要延迟加载的资源中。例如，我们有一个图像:</p>
<pre>&lt;img src="./big-image.jpg" /&gt;</pre>
<p>为了本地延迟加载上面的图像，我们只需添加值为<code>"lazy"</code>的<code>loading</code>属性:</p>
<pre>&lt;img src="./big-image.jpg" loading="lazy" /&gt;</pre>
<p><code>loading</code>属性是关键。它告诉浏览器，除非被告知，否则不要急切地加载这个资源。这个属性可以包含在<code>image</code>、<code>iframe</code>、<code>video</code>和<code>audio</code>标签中，以便延迟加载它们。</p>
<p><code>loading</code>属性有不同的值可供我们选择:</p>
<ul>
<li><strong> lazy </strong>:这个值让浏览器推迟资源的加载，直到它进入浏览器的视窗。</li>
<li><strong> auto </strong>:这表示没有资源的延迟加载。</li>
<li><strong> eager </strong>:这将立即加载资源，而不会延迟加载。</li>
</ul>
<p>惰性加载也可以使用交叉点观察器API以编程方式完成。Angular、React和Vue中的库使用交集观察者来延迟加载组件和资源。</p>
<h3>结论</h3>
<p>在这篇文章中，我们介绍了什么是PRPL。它是由现代web标准设定的模式或集合技术，指示如何优化我们的web应用程序以提高效率。我们继续研究它的不同技术，从预加载和预取到延迟加载。</p>
<p>我会说标准已经定了。我们只需要跟随他们来制作速度惊人的现代网络应用程序。</p>
<p>未来就在这里。</p>
<p>如果你对此有任何问题，或者我应该添加、更正或删除的任何内容，请随时评论、发电子邮件或给我发短信。</p><div class="code-block code-block-25">
<div class="blog-plug inline-plug css-plug"><h2>你的前端是否占用了用户的CPU？</h2><p>随着web前端变得越来越复杂，资源贪婪的特性对浏览器的要求越来越高。如果您对监控和跟踪生产环境中所有用户的客户端CPU使用情况、内存使用情况等感兴趣，</p><a target="_blank" href="https://lp.logrocket.com/blg/css-signup">try LogRocket</a><p>.</p><a class="signup" href="https://lp.logrocket.com/blg/css-signup" target="_blank" rel="noopener noreferrer"><img class="alignnone size-full wp-image-46 jetpack-lazy-image" src="../Images/dacb06c713aec161ffeaffae5bd048cd.png" alt="LogRocket Dashboard Free Trial Banner" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2019/12/cpu-memory-usage.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/12/cpu-memory-usage.png"/><noscript><img data-lazy-fallback="1" class="alignnone size-full wp-image-46" src="../Images/dacb06c713aec161ffeaffae5bd048cd.png" alt="LogRocket Dashboard Free Trial Banner" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/12/cpu-memory-usage.png"/></noscript></a><a href="https://lp.logrocket.com/blg/css-signup" target="_blank" rel="noopener noreferrer">https://logrocket.com/signup/</a><p>LogRocket 就像是网络和移动应用的DVR，记录你的网络应用或网站上发生的一切。您可以汇总和报告关键的前端性能指标，重放用户会话和应用程序状态，记录网络请求，并自动显示所有错误，而不是猜测问题发生的原因。</p><p>现代化您调试web和移动应用的方式— <a class="signup" href="https://lp.logrocket.com/blg/css-signup" target="_blank" rel="noopener noreferrer">开始免费监控</a>。</p></div>
</div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
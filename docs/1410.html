<html>
<head>
<title>What’s new in MobX 6.0 - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>MobX 6.0的新特性- LogRocket博客</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/whats-new-in-mobx-6-0/#0001-01-01">https://blog.logrocket.com/whats-new-in-mobx-6-0/#0001-01-01</a></blockquote><div><article class="article-post">
<p>要使一个库广为人知并在React中广泛使用，需要满足很多要求。特别是对于状态管理库，库所基于的核心概念对于开发人员是否会采用该框架有很大的影响。</p>
<p>MobX被社区采用并用于许多不同项目的原因之一是因为它的理念。一个非常直接、简单、健壮和非个性化的库，MobX只会变得更好久而久之。几乎没有样板文件的状态管理库使开发人员的工作变得更加容易，这也是MobX相对于React中其他传统状态管理库的主要优势之一。</p>
<p>MobX是React 中最常用的状态管理库之一，它现在有了一个<a href="https://mobx.js.org/README.html" target="_blank" rel="noopener">新版本</a>，引入了一些变化，以使该库更加简单、健壮和可伸缩。MobX不是React应用程序的专有库，它也可以用于其他JavaScript库和框架。</p>
<p>我们将探索MobX 6.0版本中的新特性，并了解如何将我们的代码从旧版本迁移到最新版本。</p>
<h2>MobX</h2>
<p>如果您还没有尝试过MobX，我将向您展示关于MobX如何真正工作的一些概念。在React应用程序中使用MobX有很多好处，可以使它更具可伸缩性、更健壮和更简单。来自<a href="https://mobx.js.org/README.html#introduction" target="_blank" rel="noopener">文档。</a></p>
<blockquote><p>任何可以从应用程序状态派生的东西都应该是。自动地。</p></blockquote>
<p>基本上，MobX有四个您应该记住的重要概念:</p>
<p><em> Observables </em>负责跟踪数据结构(类、对象、数组、引用)。每当我们商店中的价值发生变化时，MobX都会为我们跟踪新的价值:</p>
<pre>import { observable } from "mobx";
class Store {
  @observable counter = 0;
}</pre>
<p><em>动作</em>负责修改我们的状态。每当我们想要更新一个值时，我们需要执行一个动作。动作总是在响应事件、单击按钮或提交表单时发生，例如:</p>
<pre>import { observable } from "mobx";
class Store {
  @observable counter = 0;
  @action increment() {
    this.counter++;
  }

  @action decrement() {
    this.counter--;
  }
}</pre>
<p>行动负责改变和修正我们的观察。在MobX中，默认情况下，没有办法在动作之外更新状态。这条规则使您的代码库和状态更加可预测、无错误和健壮。</p>
<p><em>计算的</em>值用于导出可观察信息。它们是一个跟踪您的状态的函数，每当它发生变化时，它们的返回值也会发生变化:</p>
<pre>import { observable } from "mobx";
class Store {
  @observable counter = 0;
  @action increment() {
    this.counter++;
  }

  @action decrement() {
    this.counter--;
  }

  @computed counterMoreThan10() {
    return this.counter &gt; 10;
  }
}</pre>
<p><em>反应</em>与计算值非常相似，但不同之处在于它会触发副作用，并在可观察到的变化时发生，反应的目标是自动执行副作用。</p>
<p>现在我们已经对MobX的核心概念有了一点了解，让我们来了解一下6.0版本中真正发生了什么变化，以及它的API是如何变得更容易使用和更强大的。</p>
<h2>MobX 6.0</h2>
<p>几个月前，MobX 6的提案是由库的创建者Michel west strate T1提出的。随着许多关于新版本的提议，关于MobX即将到来的新版本中应该包含什么和应该删除什么有很多讨论。</p>
<p>这些是新MobX 6.0中的变化和新功能:</p>
<h2>装修工</h2>
<p>众所周知，很多项目都使用了JavaScript decorators，比如Angular、NestJS，当然还有MobX。装饰者目前正处于第二阶段提案阶段，看起来它不会很快得到支持。</p>
<p>在新的6.0版本中最有争议的一点是装饰者是否应该被放弃以获得一些优势，比如:</p>
<ul>
<li>与标准的现代JavaScript更加兼容</li>
<li>在大多数设置中开箱即用(例如<a href="https://github.com/facebook/create-react-app" target="_blank" rel="noopener">创建-反应-应用</a>)</li>
<li>减少包的大小</li>
</ul>
<p>在MobX中不再需要decorator，尽管在以前的版本中没有decorator也可以使用这个库，但是很多开发人员一开始并不喜欢MobX，仅仅是因为decorator的使用。</p>
<p>例如，这是MobX在以前版本中使用装饰器的一个例子:</p>
<pre>import { observable } from "mobx";
class Store {
  @observable counter = 0;
  @action increment() {
    this.counter++;
  }

  @action decrement() {
    this.counter--;
  }

  @computed counterMoreThan10() {
    return this.counter &gt; 10;
  }
}</pre>
<p>这是MobX在6.0版本中的一个例子:</p>
<pre>import {
  observable,
  action,
  computed,
  makeObservable
} from "mobx";
class Store {
  counter = 0;
  constructor() {
    makeObservable(this, {
      counter: observable,
      increment: action,
      decrement: action,
      counterMoreThan10: computed
    });
  }
  increment() {
    this.counter++;
  }
  decrement() {
    this.counter--;
  }
  get counterMoreThan10() {
    return this.counter &gt; 10;
  }
}</pre>
<p>对于一些开发人员来说，没有decorators的语法更干净、更简单，<a href="https://github.com/mobxjs/mobx/issues/2325" target="_blank" rel="noopener">对于其他人来说，开发人员的体验变得更差了</a>。</p>
<p>事实是<code>makeObservable</code>实用函数使得集成更加容易，不再需要仅仅因为decorators而下载和使用许多不同的包。</p>
<p><code>makeObservable</code>实用函数应该包装在<code>constructor</code>方法中，并且对于状态的每个属性，为了使其可见，应该使用注释来指定:</p>
<pre>constructor() {
  makeObservable(this, {
    counter: observable,
    increment: action,
    decrement: action,
    counterMoreThan10: computed
  });
}</pre>
<p>装饰器仍然可以在MobX中使用，但是我们仍然需要向类中添加一个构造函数，使用<code>makeObservable</code>实用函数，我们可以省略第二个参数:</p>
<pre>class Store {
  @observable counter = 0;
  constructor() {
    makeObservable(this);
  }
  @action increment() {
    this.counter++;
  }
  @action decrement() {
    this.counter--;
  }
  @computed get counterMoreThan10() {
    return this.counter &gt; 10;
  }
}</pre>
<h2>自动观察</h2>
<p>在6.0版本中引入的<code>makeAutoObservable</code>实用函数比<code>makeObservable</code>实用函数更强大。</p>
<p>默认情况下，它使所有属性都是可观察的，尽管您仍然可以用特定的注释来覆盖:</p>
<pre>class Store {
  counter = 0;
  constructor() {
    makeAutoObservable(this);
  }
  increment() {
    this.counter++;
  }
  decrement() {
    this.counter--;
  }
  get counterMoreThan10() {
    return this.counter &gt; 10;
  }
}</pre>
<p>这个<code>makeAutoObservable</code>确实是MobX新版本中最重要和最棒的变化之一。这对开发人员来说更容易，消除了提及他们在商店中可能拥有的每个可观察的、动作和计算的值的需要。</p>
<h2>委托书</h2>
<p>MobX有几种不同的配置方式，为了在一些JavaScript引擎中使用它，需要做一些事情。</p>
<p>在MobX 5.0中，需要对代理的支持，这一需求导致了一些JavaScript引擎的支持问题，特别是对于Internet Explorer和React Native(取决于引擎)。</p>
<p>在幕后，MobX使用代理来使数组和普通对象可见。问题是它会给一些不支持代理的JavaScript引擎带来一些问题。在MobX 6.0中，仍然支持和需要代理，但是现在有一种方法可以通过使用<code>configure</code>函数来禁用它:</p>
<pre>import { configure } from "mobx";
configure({     
  useProxies: "never"
})
</pre>
<h2>结论</h2>
<p>多年来维护和更新一个库并不是一件容易的事情，MobX社区应该为此受到表扬。这个库一直在变得越来越好，并且从一开始就遵循它的理念，"<em>任何可以从应用程序状态中派生出来的东西，都应该被派生出来。自动”。</em></p><div class="code-block code-block-17">
<div class="blog-plug inline-plug react-plug" vwo-el-id="26283398190">
<h2 vwo-el-id="41600691720"><a href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener"> LogRocket </a>:全面了解您的生产React应用</h2><p>调试React应用程序可能很困难，尤其是当用户遇到难以重现的问题时。如果您对监视和跟踪Redux状态、自动显示JavaScript错误以及跟踪缓慢的网络请求和组件加载时间感兴趣，</p><a href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" vwo-el-id="19356441070">try LogRocket</a><p>. </p><a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="19356441380">
<img class="first-react-image alignnone size-full wp-image-46 jetpack-lazy-image jetpack-lazy-image--handled" src="../Images/f300c244a1a1cf916df8b4cb02bec6c6.png" vwo-el-id="18272717540" data-lazy-loaded="1" data-original-src="https://files.readme.io/27c94e7-Image_2017-06-05_at_9.46.04_PM.png"/>
</a>
<a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="19356441690">
<img class="second-react-image alignnone size-full wp-image-46 jetpack-lazy-image jetpack-lazy-image--handled" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" vwo-el-id="30720362350" data-lazy-loaded="1" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/>
</a>
<p vwo-el-id="28675660440" class="">LogRocket 结合了会话回放、产品分析和错误跟踪，使软件团队能够创建理想的web和移动产品体验。这对你来说意味着什么？</p>
<p>LogRocket不是猜测错误发生的原因，也不是要求用户提供截图和日志转储，而是让您回放问题，就像它们发生在您自己的浏览器中一样，以快速了解哪里出错了。</p>
<p>不再有嘈杂的警报。智能错误跟踪允许您对问题进行分类，然后从中学习。获得有影响的用户问题的通知，而不是误报。警报越少，有用的信号越多。</p>
<p vwo-el-id="28675660750">LogRocket Redux中间件包为您的用户会话增加了一层额外的可见性。LogRocket记录Redux存储中的所有操作和状态。</p>
<p vwo-el-id="28675661060">现代化您调试React应用的方式— <a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="40093418840">开始免费监控</a>。</p>
</div></div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
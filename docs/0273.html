<html>
<head>
<title>When to use `never` and `unknown` in TypeScript - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>在TypeScript - LogRocket博客中何时使用“从不”和“未知”</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/when-to-use-never-and-unknown-in-typescript-5e4d6c5799ad/#0001-01-01">https://blog.logrocket.com/when-to-use-never-and-unknown-in-typescript-5e4d6c5799ad/#0001-01-01</a></blockquote><div><div class="section-inner sectionLayout--insetColumn">
<h3 class="graf graf--h3">用集合论解释的类型</h3>
<p class="graf graf--p">当你深入到一个基本定义时，一个<em class="markup--em markup--p-em">类型</em>就是一组可能的值，仅此而已。例如，TypeScript中的类型<code>string</code>是所有可能字符串的集合。类型<code>Date</code>是<code>Date</code>类的所有实例的集合(加上所有结构兼容的对象)，类型<code>Iterable&lt;T&gt;</code>是为给定类型的迭代值实现iterable接口的所有对象的集合。</p>
<p class="graf graf--p">TypeScript特别忠实于类型的集合论基础；在其他特性中，TypeScript具有联合和交集类型。像<code>string | number</code>这样的类型被称为“联合”类型，因为它实际上是所有字符串集合和所有数字集合的联合。</p>
<figure class="graf graf--figure"><img decoding="async" class="graf-image jetpack-lazy-image" src="../Images/145b4d21ba48c019b7875a8835d64fbc.png" data-image-id="1*ZUSJpOOStqTRvCZ8GucxSw.png" data-width="1401" data-height="837" data-lazy-src="https://cdn-images-1.medium.com/max/1600/1*ZUSJpOOStqTRvCZ8GucxSw.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://cdn-images-1.medium.com/max/1600/1*ZUSJpOOStqTRvCZ8GucxSw.png"/><noscript><img data-lazy-fallback="1" decoding="async" class="graf-image" src="../Images/145b4d21ba48c019b7875a8835d64fbc.png" data-image-id="1*ZUSJpOOStqTRvCZ8GucxSw.png" data-width="1401" data-height="837" data-original-src="https://cdn-images-1.medium.com/max/1600/1*ZUSJpOOStqTRvCZ8GucxSw.png"/></noscript><figcaption class="imageCaption">The set `string | number` contains both the `string` and `number` sets.</figcaption></figure>
<p class="graf graf--p">因为<code>string | number</code>包含所有的<code>string</code>和所有的<code>number</code>值，所以它被称为<code>string</code>和<code>number</code>的超类型。</p>
<p class="graf graf--p"><code>unknown</code>是所有可能值的集合。任何值都可以赋给类型为<code>unknown</code>的变量。这意味着<code>unknown</code>是所有其他类型的超类型。<code>unknown</code>因此被称为<em class="markup--em markup--p-em">顶级</em>型。</p>
<figure class="graf graf--figure"><img decoding="async" class="graf-image jetpack-lazy-image" src="../Images/c558060017faf5b76a6325fddbb2f2b9.png" data-image-id="1*S0YZx_0dFeAvp2uB28MthA.png" data-width="1400" data-height="1028" data-lazy-src="https://cdn-images-1.medium.com/max/1600/1*S0YZx_0dFeAvp2uB28MthA.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://cdn-images-1.medium.com/max/1600/1*S0YZx_0dFeAvp2uB28MthA.png"/><noscript><img data-lazy-fallback="1" decoding="async" class="graf-image" src="../Images/c558060017faf5b76a6325fddbb2f2b9.png" data-image-id="1*S0YZx_0dFeAvp2uB28MthA.png" data-width="1400" data-height="1028" data-original-src="https://cdn-images-1.medium.com/max/1600/1*S0YZx_0dFeAvp2uB28MthA.png"/></noscript><figcaption class="imageCaption">The set `unknown` contains all other sets.</figcaption></figure>
<p class="graf graf--p"><code>never</code>是空集。没有可以分配给类型为<code>never</code>的变量的值。事实上，将值的类型解析为<code>never</code>是错误的，因为这将是一个矛盾。空集可以放入任何其他集，所以<code>never</code>是所有其他类型的子类型。这就是为什么<code>never</code>被称为<em class="markup--em markup--p-em">底</em>型。<a class="markup--anchor markup--p-anchor" href="#4f3d" data-href="#4f3d"> </a></p>
<figure class="graf graf--figure"><img decoding="async" class="graf-image jetpack-lazy-image" src="../Images/045767035b42aab7bb352477e915fbe1.png" data-image-id="1*uDmxpUKCQ8gQjxKPwlJHTg.png" data-width="1400" data-height="1028" data-is-featured="true" data-lazy-src="https://cdn-images-1.medium.com/max/1600/1*uDmxpUKCQ8gQjxKPwlJHTg.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://cdn-images-1.medium.com/max/1600/1*uDmxpUKCQ8gQjxKPwlJHTg.png"/><noscript><img data-lazy-fallback="1" decoding="async" class="graf-image" src="../Images/045767035b42aab7bb352477e915fbe1.png" data-image-id="1*uDmxpUKCQ8gQjxKPwlJHTg.png" data-width="1400" data-height="1028" data-is-featured="true" data-original-src="https://cdn-images-1.medium.com/max/1600/1*uDmxpUKCQ8gQjxKPwlJHTg.png"/></noscript><figcaption class="imageCaption">The empty set, `never`, exists as a point inside every other set.</figcaption></figure>
<p class="graf graf--p">底部和顶部类型的有用属性是分别关于并集和交集操作的<em class="markup--em markup--p-em">标识元素</em>。对于任何类型<code>T</code>:</p>
<pre>T | never ⇒ T
T &amp; unknown ⇒ T</pre>
<p class="graf graf--p">这类似于一个数字加零不会改变它的想法，同样的道理也适用于一个数字乘以一。零是加法的单位元，一是乘法的单位元。</p>
<p class="graf graf--p">具有空集的并集不会添加任何东西，所以<code>never</code>是关于并集的恒等式。交集选择两个集合之间的公共元素，但是<code>unknown</code>包含了一切，所以<code>unknown</code>是关于交集的同一性。</p>
<p class="graf graf--p"><code>never</code>是类型联合中唯一可以“分解”的类型，这使得它在某些情况下是不可或缺的，我们将在下一节中看到。</p>
<h3 class="graf graf--h3">代表永远不会发生的事情</h3>
<p class="graf graf--p">让我们编写一些发出网络请求的代码，但是如果请求时间太长，就会失败。我们可以通过使用<code>Promise.race</code>将网络响应的承诺与给定时间长度后拒绝的承诺结合起来。下面是构造第二个承诺函数:</p>
<pre>function timeout(ms: number): Promise&lt;never&gt; {
  return new Promise((_, reject) =&gt;
    setTimeout(() =&gt; reject(new Error("Timeout elapsed")), ms)
  )
}</pre>
<p class="graf graf--p">注意返回类型:因为<code>timeout</code>从不调用<code>resolve</code>,所以我们可以为promise类型参数使用任何类型，不会有矛盾。但是最特别的类型是<code>never</code>。(我所说的“最具体”是指代表最小可能值集的类型)。</p>
<p class="graf graf--p">现在让我们看看<code>timeout</code>的实际情况:</p>
<pre>async function fetchPriceWithTimeout(tickerSymbol: string): Promise&lt;number&gt; {
  const stock = await Promise.race([
    fetchStock(tickerSymbol), // returns `Promise&lt;{ price: number }&gt;`
    timeout(3000)
  ])
  return stock.price
}</pre>
<p class="graf graf--p">这个很好用。但是编译器如何从那个<code>Promise.race</code>调用中推断出正确的返回类型呢？<code>race</code>返回单个承诺以及第一个承诺结算的结果或失败。在这个例子中，<code>Promise.race</code>的签名是这样的:</p>
<pre>// `Promise.race` specialized for two inputs.
// The real signature is more general than this.
function race&lt;A, B&gt;(inputs: [Promise&lt;A&gt;, Promise&lt;B&gt;]): Promise&lt;A | B&gt;</pre>
<p class="graf graf--p">输出承诺中解析值的类型是输入解析类型的并集。上面的例子结合了<code>fetchStock</code>和<code>timeout</code>，所以输入承诺解析类型是<code>{ price: number }</code>和<code>never</code>，输出解析类型(变量<code>stock</code>的类型)应该是<code>{ price: number } | never</code>。因为<code>never</code>是相对于unions的恒等式，该类型简化为<code>{ price: number }</code>，这正是我们想要的。</p>
<p class="graf graf--p">如果我们使用除了<code>never</code>之外的任何类型作为<code>timeout</code>中返回类型的参数，事情就不会这么简单了。如果我们使用了<code>any</code>，我们将失去类型检查的好处，因为<code>{ price: number } | any</code>等同于<code>any</code>。</p>
<p class="graf graf--p">如果我们使用了<code>unknown</code>，那么<code>stock</code>的类型将会是<code>{ price: number } | unknown</code>，简化为<code>unknown</code>。在这种情况下，如果不进一步缩小类型，我们将无法访问<code>price</code>属性，因为关于<code>price</code>属性存在的信息将会丢失。</p>
<h3 class="graf graf--h3">使用<code>`never</code>删除条件类型</h3>
<p class="graf graf--p">你会经常看到在<a class="markup--anchor markup--p-anchor" href="https://www.typescriptlang.org/docs/handbook/advanced-types.html#conditional-types" target="_blank" rel="noopener noreferrer" data-href="https://www.typescriptlang.org/docs/handbook/advanced-types.html#conditional-types">条件类型</a>中使用<code>never</code>来删除不想要的案例。例如，这些条件类型从函数类型中提取参数和返回类型:</p>
<pre>type Arguments&lt;T&gt; = T extends (...args: infer A) =&gt; any ? A : never
type Return&lt;T&gt; = T extends (...args: any[]) =&gt; infer R ? R : never

function time&lt;F extends Function&gt;(fn: F, ...args: Arguments&lt;F&gt;): Return&lt;F&gt; {
  console.time()
  const result = fn(...args)
  console.timeEnd()
  return result
}</pre>
<p class="graf graf--p">如果<code>T</code>是一个函数类型，那么编译器推断它的参数类型或者返回类型。但是如果<code>T</code>不是一个函数类型，那么对于<code>Arguments&lt;T&gt;</code>或者<code>Return&lt;T&gt;</code>来说就没有合理的结果。我们在每个条件的else分支中使用<code>never</code>,使该情况成为错误:</p>
<pre>// Error: Type '3' is not assignable to type 'never'.
const x: Return&lt;"not a function type"&gt; = 3</pre>
<p class="graf graf--p">条件修剪对于缩小联合类型也很有用。TypeScript的库包括从联合类型中移除了<code>null</code>和<code>undefined</code>的<code>NonNullable&lt;T&gt;</code>类型(<a class="markup--anchor markup--p-anchor" href="https://github.com/Microsoft/TypeScript/blob/eb2297df022f6b1f284aff96e93c06097bb01ea5/lib/lib.es5.d.ts#L1459" target="_blank" rel="noopener noreferrer" data-href="https://github.com/Microsoft/TypeScript/blob/eb2297df022f6b1f284aff96e93c06097bb01ea5/lib/lib.es5.d.ts#L1459">源</a>)。定义如下:</p>
<pre>type NonNullable&lt;T&gt; = T extends null | undefined ? never : T;</pre>
<p class="graf graf--p">这是因为条件类型<a class="markup--anchor markup--p-anchor" href="https://www.typescriptlang.org/docs/handbook/advanced-types.html#distributive-conditional-types" target="_blank" rel="noopener noreferrer" data-href="https://www.typescriptlang.org/docs/handbook/advanced-types.html#distributive-conditional-types">将</a>分布在类型联合上。给定形式为<code>T extends U ? X : Y</code>的任何类型，当联合类型替换<code>T</code>时，该类型会扩展以将条件分布到该联合类型的每个分支:</p>
<pre>// if T = A | B

T extends U ? X : T == (A extends U ? X : A) | (B extends U ? X : B)</pre>
<p class="graf graf--p">在每个联合分支中，<code>T</code>的每一次出现都被替换联合类型中的一个成分替换。如果<code>T</code>出现在true case而不是false case中，或者出现在更大的类型表达式中，这也适用:</p>
<pre>// if T = A | B

T extends U ? SomeGeneric&lt;T&gt; : Y
  == (A extends U ? SomeGeneric&lt;A&gt; : Y) | (B extends U ? SomeGeneric&lt;B&gt; : Y)</pre>
<p class="graf graf--p">所以像<code>NonNullable&lt;string | null&gt;</code>这样的类型按照以下步骤进行解析:</p>
<pre>NonNullable&lt;string | null&gt;
  // The conditional distributes over each branch in `string | null`.
  == (string extends null | undefined ? never : string) | (null extends null | undefined ? never : null)

  // The conditional in each union branch is resolved.
  == string | never

  // `never` factors out of the resulting union type.
  == string</pre>
<p class="graf graf--p">结果是给定一个联合类型<code>NonNullable&lt;T&gt;</code>产生一个潜在的缩小类型，使用<code>never</code>来删除不需要的联合分支。</p>
<h3 class="graf graf--h3">对于可以是任何值的值，使用<code>`unknown</code></h3>
<p class="graf graf--p">任何值都可以赋给类型为<code>unknown</code>的变量。因此，当一个值可能有任何类型，或者不方便使用更具体的类型时，就使用<code>unknown</code>。例如，一个漂亮的打印函数应该能够接受任何类型的值:</p>
<pre>function prettyPrint(x: unknown): string {
  if (Array.isArray(x)) {
    return "[" + x.map(prettyPrint).join(", ") + "]"
  }
  if (typeof x === "string") {
    return `"${x}"`
  }
  if (typeof x === "number") {
    return String(x)
  } 
  return "etc."
}</pre>
<p class="graf graf--p">你不能直接用一个<code>unknown</code>值做很多事情。但是您可以使用类型保护来缩小类型，并对缩小类型上的代码块进行准确的类型检查。</p>
<p class="graf graf--p">在TypeScript 3.0之前，编写<code>prettyPrint</code>的最佳方式是使用<code>any</code>作为<code>x</code>的类型。类型收缩处理<code>any</code>的方式与处理<code>unknown</code>的方式基本相同；所以编译器可以检查我们是否正确地使用了<code>map</code>和<code>join</code>，在这种情况下<code>x</code>被缩小为一个数组类型，而不管我们是使用<code>any</code>还是<code>unknown</code>。但是使用<code>unknown</code>将拯救我们，如果我们犯了一个错误，我们认为类型已经被缩小，但实际上，它没有:</p>
<pre>import isArray from "isarray"

function prettyPrint(x: any): string {
  if (isArray(x)) { // whoops - this `isArray` is not a type guard!
    return "[" + x.mop(prettyPrint).join(", ") + "]"
  }
  /* snip */
  return "etc."
}</pre>
<p class="graf graf--p">isarray包不包含将<code>isArray</code>函数转变为类型保护的类型定义。但是我们可能在没有意识到细节的情况下使用isarray。因为<code>isArray</code>不是一个类型守卫，而我们用<code>any</code>做<code>x</code>的类型，<code>x</code>的类型在<code>if</code>体内依然是<code>any</code>。因此，编译器不会捕捉到这个版本的<code>prettyPrint</code>中的错别字。如果<code>x</code>的类型是<code>unknown</code>，我们会得到这个错误:</p>
<blockquote class="graf graf--blockquote"><p><em class="markup--em markup--blockquote-em">对象属于“未知”类型。</em></p></blockquote>
<p class="graf graf--p">此外，使用<code>any</code>会让你通过执行不一定安全的操作来作弊。让你保持诚实。</p>
<h3 class="graf graf--h3">如何在<code>`never`</code>、<code>`unknown`</code>、<code>`any`</code>之间选择</h3>
<p class="graf graf--p"><code>prettyPrint</code>中的类型<code>x</code>和<code>timeout</code>的返回类型中的承诺类型参数都是值可以有任何类型的情况。不同之处在于，在<code>timeout</code>中，promise resolution值可以是任何类型，因为它永远不会存在。</p>
<ul class="postList">
<li class="graf graf--li">在没有或不应该有值的位置使用<code>never</code>。</li>
<li class="graf graf--li">在有值的地方使用<code>unknown</code>,但是它可能有任何类型。</li>
<li class="graf graf--li">避免使用<code>any</code>，除非你真的需要一个不安全的逃生出口。</li>
</ul>
<p class="graf graf--p">一般来说，使用最具体的类型将工作。<code>never</code>是最具体的类型，因为没有比空集更小的集合。<code>unknown</code>是最不具体的类型，因为它包含所有可能的值。<code>any</code>不是一个集合，它破坏了类型检查；所以，尽可能假装它不存在。</p>
</div>
</div>    
</body>
</html>
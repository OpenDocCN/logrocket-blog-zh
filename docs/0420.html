<html>
<head>
<title>The state of semantic JSX - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>语义JSX的现状</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/semantic-jsx/#0001-01-01">https://blog.logrocket.com/semantic-jsx/#0001-01-01</a></blockquote><div><article class="article-post">
  <p>为web创建平台一直以来都很简单，只需学习编写HTML，加入一些CSS的外观和感觉，然后，可能还需要一点JavaScript或任何其他功能性脚本语言。</p>
<p>然而，随着JavaScript组件框架的出现，许多概念开始发挥作用，比如样式化组件和JSX( <a href="https://www.reactenlightenment.com/react-jsx/5.1.html" target="_blank" rel="noopener noreferrer"> React </a>)(以及许多其他概念)。这些框架最有趣的部分是将网页分解成特定的组件，只有当用户界面需要它们时才导入它们。</p>
<p>这就引出了一个问题，这会影响网络的工作方式吗？这样会好点吗？我们还能写语义代码吗？组件的单一入口点是否使得获取可访问的<a href="https://blog.logrocket.com/8-dom-features-you-didnt-know-existed-ec2a0a28fd89/" target="_blank" rel="noopener noreferrer"> DOM </a>树变得困难？让我们找出答案。</p>
<h2>TL；速度三角形定位法(dead reckoning)</h2>
<p>在本文中，我们将在<a href="https://reactjs.org" target="_blank" rel="noopener noreferrer"> ReactJS </a>应用程序中实现可访问性特性。我们将看看如何在基于组件的应用程序中实现这一点，同时使用<a href="https://reactjs.org/docs/fragments.html#short-syntax" target="_blank" rel="noopener noreferrer"> React片段</a>避免不必要的div导入。我们还将了解焦点管理的概念以及<code>ref</code>如何在ReactJS中帮助实现这一概念。</p>
<h2>先决条件</h2>
<p>在我们进一步讨论之前，本文假设:</p>
<ul>
<li><a href="https://nodejs.org/" target="_blank" rel="noopener noreferrer"> Node.js ≥v6 </a>安装在您的机器上</li>
<li>您的机器上安装了npm </li>
<li>您的机器上安装了React版本16.8或更高版本</li>
<li><a href="https://www.npmjs.com/package/create-react-app" target="_blank" rel="noopener noreferrer"> Create-react-app </a>已安装在您的机器上</li>
<li>你有网页可及性的基本知识</li>
<li>你对<a href="https://reactjs.org" target="_blank" rel="noopener noreferrer">反应</a>有一个基本的了解</li>
</ul>
<h2>易接近</h2>
<p>让一个web项目具有可访问性可能会让人感觉力不从心，但这真的就像实现一种更具语义的方法来编写代码以支持所有用户一样简单。这一点的基础是<a href="https://medium.com/the-school-of-do/making-accessibility-accessible-the-pour-principles-f5ad21eda12f" target="_blank" rel="noopener noreferrer"> POUR </a>原则，该原则指导建立可访问的网站。</p>
<p>简单来说就是倒的意思——<em>可感知的</em>、<em>可操作的</em>、<em>可理解的</em>、<em>健壮的</em>。</p>
<p><strong>可感知的</strong>:这意味着网页应该可以通过浏览器或辅助技术(如屏幕阅读器和屏幕放大器)为感官(视觉、触觉和听觉)所用。</p>
<p><strong>可操作</strong>:这意味着用户可以使用鼠标、键盘或辅助设备与所有控件和交互元素进行交互。在焦点管理部分，我们将探讨如何使平台具有可操作性。</p>
<p>可理解的:在这方面，我们考虑语言的使用，包括尽可能减少拼写错误和复杂的语法。</p>
<p>健壮:这意味着整个网络的一致性。这意味着你的平台必须在所有平台上以同样的方式工作。</p>
<h2>React应用程序可以被访问吗？</h2>
<p>这个问题我们听过很多次了。其原因是React应用程序依赖于所谓的虚拟DOM，每当应用程序的一部分由于更改而必须重新呈现时，都会构建该虚拟DOM。分解组件只接受单个根元素(主要是一个div)。这不是语义性的，不会被屏幕阅读器之类的辅助工具识别。</p>
<p>然而，React中的可访问性可以通过多种方式实现，本文将对此进行讨论。</p>
<h2>React JSX的可访问性</h2>
<p>为了实现语义JSX，有一些工具和实践可以帮助您的React应用程序更加用户友好。我们将在这一部分讨论这些工具和实践。</p>
<h2>在碎片反应之前</h2>
<p>在我们全面了解React片段对于React可访问性的重要性之前，让我们先了解语义JSX在React片段之前是如何实现的，以便理解它的重要性。</p>
<p><strong> 1。使用<code>Div</code>标签</strong>导入元素</p>
<p>通常，当学习构建React应用程序时，我们会学习将特定组件的代码包装在一个<code>div</code>或<code>span</code>标签中。大多数React开发人员使用<code>div</code>标签来确保代码作为一个块到达其导入的位置。现在，所有这些只是在另一个<code>div</code>中返回一个<code>div</code>，这阻止了编写语义JSX。</p>
<p><strong>这种方法的缺点</strong></p>
<p>当处理这样的导入时，我们所做的是用<code>div</code>标签构建React的虚拟DOM，这些标签最终将作为非语义HTML呈现在主Dom中，这使得屏幕阅读器很难解释。</p>
<p><strong> 2。使用数组作为入口点</strong></p>
<p>因为React组件只将单个根元素返回到另一个父组件中，所以我们可以决定通过返回一个值数组将子组件中的信息映射到父组件，如下所示:</p>
<pre>import React from 'react'
    function NameList() {
     return (
      [
       &lt;h2 key="1"&gt; List of Developers in Nigeria &lt;/h2&gt;,
       &lt;li key="2"&gt; Obinna &lt;/li&gt;
       &lt;li key="3"&gt; Kofo &lt;/li&gt;
       &lt;li key="4"&gt; Jola &lt;/li&gt;
      ]
     )
    }
    export default NameList</pre>
<p>这是可行的，尽管它导致在DOM中呈现可能不需要的额外元素。还必须总是映射出具有唯一键的元素数组，这可以看作是大量的语法使用。</p>
<h2>使用反应片段</h2>
<p>为了解决不必要的导入问题，在<a href="https://reactjs.org/blog/2019/02/06/react-v16.8.0.html" target="_blank" rel="noopener noreferrer"> React v16.8 </a>中引入了一个解决方案。<a href="https://reactjs.org/docs/fragments.html#short-syntax" target="_blank" rel="noopener noreferrer">片段</a>帮助你在不增加额外节点到DOM的情况下对孩子列表进行分组。基本上，fragments所做的是，通过完全按照我们编写的方式创建虚拟DOM，帮助保证子组件到父组件的更多语义输入。</p>
<p>例如，一个简单的用例是使用旧语法调用<code>&lt;tr&gt;</code>(表格滚动)中的<code>&lt;td&gt;</code>(表格数据)标签:</p>
<pre>class Table extends React.Component {
  render() {
    return (
      &lt;table&gt;
        &lt;tr&gt;
          &lt;Columns /&gt;
        &lt;/tr&gt;
      &lt;/table&gt;
    );
  }
}</pre>
<p>在列组件中，我们会有这样的内容:</p>
<pre>class Columns extends React.Component {
  render() {
    return (
      &lt;div&gt;
        &lt;td&gt;Hello&lt;/td&gt;
        &lt;td&gt;World&lt;/td&gt;
      &lt;/div&gt;
    );
  }
}</pre>
<p>但是为了避免无效的HTML错误，<code>&lt;Columns /&gt;</code>在呈现时需要返回多个<code>&lt;td&gt;</code>元素，而不是一个<code>div</code>。上面的输出将如下所示:</p>
<pre>&lt;table&gt;
  &lt;tr&gt;
    &lt;div&gt;
      &lt;td&gt;Hello&lt;/td&gt;
      &lt;td&gt;World&lt;/td&gt;
    &lt;/div&gt;
  &lt;/tr&gt;
&lt;/table&gt;</pre>
<p>对于片段，这是这样解决的:</p>
<pre>class Columns extends React.Component {
  render() {
    return (
      &lt;React.Fragment&gt;
        &lt;td&gt;Hello&lt;/td&gt;
        &lt;td&gt;World&lt;/td&gt;
      &lt;/React.Fragment&gt;
    );
  }
}</pre>
<p>片段可以像这样使用<code>&lt;React.Fragment&gt;</code>或者使用空标签<code>&lt;&gt;</code>。</p>
<h2>使用片段时需要注意的事项</h2>
<ul>
<li>当使用空标签时，它不支持使用键来映射数据</li>
<li>键是目前唯一受<code>&lt;React.Fragment&gt;</code>标签支持的属性</li>
</ul>
<h2>这对编写语义JSX有什么帮助？</h2>
<p>React Fragments帮助改善语义JSX的明显方式是通过消除DOM树中不必要的<code>div</code>标签，它还允许我们编写更多的语义HTML，如前所述，这是可访问代码的基础。实现可访问性的其他技巧包括:</p>
<ul>
<li>将<code>div</code>改为一篇文章/部分会产生巨大的不同</li>
<li>使用h1–h6作为标题，通知屏幕阅读器页面部分</li>
<li>使用链接进行导航</li>
<li>用一个按钮处理所有点击功能</li>
<li>如果元素不在屏幕上，请确保将其可见性设置为隐藏</li>
<li>充分利用<a href="https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/Roles/heading_role" target="_blank" rel="noopener noreferrer"> ARIA </a>,它有助于将语义行为添加到非隐式语义的元素中，例如，侧边栏应该使用aria-expand让屏幕读者知道</li>
<li>给按钮贴标签，提供按钮功能的附加信息</li>
</ul>
<h2>焦点和焦点管理</h2>
<p>焦点是指当你发送信息时，接收输入的计算机屏幕的控制，这通常与键盘有关。每当你试图填写表格或使用网页的特定部分时，你必须把它放在焦点上。现在，这对于那些宁愿使用键盘使用<code>tab</code>和<code>shift</code>键来导航平台或者有某种运动障碍的用户来说很重要。</p>
<h3>焦点管理:</h3>
<p>精心规划的焦点管理对于确保舒适的用户体验非常重要。这意味着将光标从应用程序的一部分移动到另一部分。为了帮助用户(大多数是运动障碍者)在应用程序的预期流程中使用键盘导航平台。有些元素是隐式聚焦的，比如表单元素、锚元素，而其他元素则不是(比如<code>p</code>、<code>h2</code>标签)。</p>
<h2>使用<code>ref</code>在React中实现焦点管理</h2>
<p>为了使用React聚焦一个元素，我们创建了一个函数<a href="https://reactjs.org/docs/refs-and-the-dom.html" target="_blank" rel="noopener noreferrer"> Ref </a>，这是一个设置在我们想要引用的元素上的属性，它允许我们在React中选择并引用页面上的一个实际DOM节点。</p>
<pre>&lt;div
  ref ={
    (loadingNames)=&gt; {
        this.loadingNames = loadingNames;
    }
  }
  tabIndex = "-1"
&gt;
Loading List of Names...
&lt;/div&gt;</pre>
<p>上面的代码将div的<code>ref</code>分配给类属性<code>this.loadingNames</code>来实现一个ref。我们使用<a href="https://reactjs.org/docs/react-component.html" target="_blank" rel="noopener noreferrer">componentdimount</a>生命周期，然后像这样调用<code>ref</code>元素的focus元素:</p>
<pre>componentDidMount(){
    this.loadingNames.focus()
    }</pre>
<p>因此，当名字列表加载时，键盘焦点指示器会在内容上放置一个焦点环。</p>
<p>使用<code><a href="https://reactjs.org/docs/refs-and-the-dom.html" target="_blank" rel="noopener noreferrer">ref</a></code>的另一个用例是确保我们在使用<a href="https://reactjs.org/docs/refs-and-the-dom.html" target="_blank" rel="noopener noreferrer"> react-router </a>时将焦点转移到新页面，通过调用页面顶部的<code>ref</code>并使用户从<code>&lt;link&gt;</code>连接到的新页面的顶部导航。</p>
<pre>&lt;div
ref={
  (topOfNewPage)=&gt;{
    this.topOfNewPage = topOfNewPage;
  }
}
 tabIndex = "-1"
 aria-labelledby = "pageHeading"
&gt;
  &lt;Header / &gt;
    &lt;h1 id ="pageHeading"&gt; &lt;/h1&gt;
   &lt;Footer/&gt;
&lt;/div&gt;</pre>
<p>像这样使用ref:</p>
<pre>componentDidMount(){
this.topOfNewPage.focus()
}</pre>
<p>随着<a href="https://reactjs.org/blog/2019/02/06/react-v16.8.0.html" target="_blank" rel="noopener noreferrer"> React v16.8 </a>的发布，有了一种使用<code>React.createRef()</code> API编写<code>refs</code>的方法。你可以在<a href="https://reactjs.org/docs/refs-and-the-dom.html#callback-refs" target="_blank" rel="noopener noreferrer">官方文档</a>中找到更多信息。</p>
<h2>实现语义JSX时的其他有用提示</h2>
<h3>1.使用componentDidMount设置页面标题</h3>
<p>这有助于增加<a href="https://searchengineland.com/guide/what-is-seo" target="_blank" rel="noopener noreferrer"> SEO </a>，也可以更新浏览器标签中的内容，这也使屏幕阅读器能够更好地了解他们在应用程序中的当前位置。</p>
<pre>componentDidMount(){
    document.title = 'Input your page title '
    }</pre>
<p>其他的方法是使用像<a href="https://www.npmjs.com/package/react-document-title" target="_blank" rel="noopener noreferrer"> react-document-title </a>和<a href="https://www.npmjs.com/package/react-helmet" target="_blank" rel="noopener noreferrer">react-头盔</a>这样的包，它们可以通过<a href="https://www.npmjs.com/" target="_blank" rel="noopener noreferrer"> NPM安装到项目中。</a></p>
<h3>2.react accessibility linter(eslint-plugin-jsx-a11y)</h3>
<p>使用linter有助于通过检查由团队或个人确定的代码标准编写的代码来确定干净的代码。使用eslint-plugin-jsx-a11ylinter，我们可以建立一个更容易使用的react应用程序。您还可以将它配置为与您的文本编辑器一起工作，以便获得实时错误输出。也可以使用<a href="https://www.npmjs.com/" target="_blank" rel="noopener noreferrer"> NPM </a>进行安装。</p>
<pre>npm install eslint esline-plugin-jsx-a11y --save-dev</pre>
<h3>3.编写语义HTML</h3>
<p>大多数情况下，编写具有语义的代码可以大大有助于一个更易访问的平台，在本文的前面，我陈述了实现这一点的方法。同时参考本<a href="https://www.w3.org/WAI/standards-guidelines/wcag/" target="_blank" rel="noopener noreferrer">指南</a>可以对此有所帮助。</p>
<h2>结论</h2>
<p>在本文中，我们试图理解应用于React应用程序的web可访问性的基础知识，并从总体上了解一些可访问性原则。我希望我们在构建React应用程序时将这些实践付诸实践，为每个人提供一个更好的web。编码快乐！😄</p><div class="code-block code-block-54">
<hr/>
<h3>更多来自LogRocket的精彩文章:</h3>

<hr/></div>
<div class="code-block code-block-17">
<div class="blog-plug inline-plug react-plug" vwo-el-id="26283398190">
<h2 vwo-el-id="41600691720">使用LogRocket消除传统反应错误报告的噪音</h2>
<a href="https://lp.logrocket.com/blg/react-signup-issue-free" target="_blank" vwo-el-id="19356441070">LogRocket
</a><p>是一款React analytics解决方案，可保护您免受数百个误报错误警报的影响，只针对少数真正重要的项目。LogRocket告诉您React应用程序中实际影响用户的最具影响力的bug和UX问题。</p><a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="19356441380">
<img class="first-react-image alignnone size-full wp-image-46 jetpack-lazy-image jetpack-lazy-image--handled" src="../Images/f300c244a1a1cf916df8b4cb02bec6c6.png" vwo-el-id="18272717540" data-lazy-loaded="1" data-original-src="https://files.readme.io/27c94e7-Image_2017-06-05_at_9.46.04_PM.png"/>
</a>
<a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="19356441690">
<img class="second-react-image alignnone size-full wp-image-46 jetpack-lazy-image jetpack-lazy-image--handled" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" vwo-el-id="30720362350" data-lazy-loaded="1" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/>
</a>
<a href="https://lp.logrocket.com/blg/react-signup-issue-free" target="_blank" rel="noopener noreferrer" vwo-el-id="35866400580">LogRocket
</a><p>自动聚合客户端错误、反应错误边界、还原状态、缓慢的组件加载时间、JS异常、前端性能指标和用户交互。然后，LogRocket使用机器学习来通知您影响大多数用户的最具影响力的问题，并提供您修复它所需的上下文。</p><p vwo-el-id="28675661060">关注重要的React bug—<a class="signup" href="https://lp.logrocket.com/blg/react-signup-issue-free" target="_blank" rel="noopener noreferrer" vwo-el-id="40093418840">今天就试试LogRocket】。</a></p>
</div></div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
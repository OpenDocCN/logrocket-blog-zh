<html>
<head>
<title>Refactoring legacy code with Jest snapshots - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>用Jest快照重构遗留代码</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/refactoring-legacy-code-with-jest-snapshots-e290ceccccc3/#0001-01-01">https://blog.logrocket.com/refactoring-legacy-code-with-jest-snapshots-e290ceccccc3/#0001-01-01</a></blockquote><div><article class="article-post">
<figure><img decoding="async" src="../Images/3851d56fd8c98b8b11fa9acf1dc6f35d.png" data-height="700" data-width="1240" data-lazy-src="https://storage.googleapis.com/blog-images-backup/1*8w0j8pkYujof3_aTmOWkRA.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" class=" jetpack-lazy-image" data-original-src="https://storage.googleapis.com/blog-images-backup/1*8w0j8pkYujof3_aTmOWkRA.png"/><noscript><img data-lazy-fallback="1" decoding="async" src="../Images/3851d56fd8c98b8b11fa9acf1dc6f35d.png" data-height="700" data-width="1240" data-original-src="https://storage.googleapis.com/blog-images-backup/1*8w0j8pkYujof3_aTmOWkRA.png"/></noscript></figure>
<p>快照测试在测试React应用程序或其他基于组件的ui时非常流行。然而，这并不完全没有戏剧性——许多人喜欢快照是因为它们的易用性和快速引导测试组合的能力，而其他人则觉得快照的长期影响可能弊大于利。</p>
<p>最终，快照测试只是我们工具带中的另一个工具。虽然许多人可能在如何使用快照测试和何时使用快照测试的问题上存在分歧，但知道它的存在并在我们需要时可用还是很好的。</p>
<p>老实说，我对快照的立场是——我倾向于对快照不太感兴趣的阵营。然而，我最近遇到了一些遗留代码的情况，感觉快照测试是完美的匹配。使用快照作为重构工具帮助我成功地处理和重构了一些在我加入公司之前很久编写的棘手代码。</p>
<h3>什么是快照测试？</h3>
<p>如果你不熟悉快照测试，我们将做一点复习。在快照测试中，测试第一次运行时，会拍摄代码输出的“图片”。这个“图片”被保存到代码库中的一个文本文件中，所有后续的测试运行都使用这个图片作为参考——如果你的代码输出产生了一个相同的快照，那么测试就通过了。但是，如果输出与保存的快照不同，测试将失败。</p>
<p>下面是一个在<a href="https://jestjs.io/" target="_blank" rel="noopener noreferrer"> Jest </a>中快照测试的例子:</p>
<figure>
<pre><code>import renderer from "react-test-renderer";

function Test({ message }) {
  return {message};
}

test("renders", () =&gt; {
  const wrapper = renderer.create(&lt;Test message="test" /&gt;);

  expect(wrapper.toJSON()).toMatchSnapshot();
});</code></pre>
</figure>
<p>第一次运行该测试后，它将创建一个快照文件，将来的测试运行将使用该文件作为参考。快照文件看起来如下所示:</p>
<figure>
<pre>// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`renders 1`] = `
&lt;div&gt;
  test
&lt;/div&gt;
`;</pre>
<p>在我开始使用<a href="https://jestjs.io/docs/en/snapshot-testing" target="_blank" rel="noopener noreferrer"> J </a> est之前，我从未听说过快照测试——我不确定Jest团队是否发明了快照测试，但<a href="https://jestjs.io/docs/en/snapshot-testing" target="_blank" rel="noopener noreferrer">他们肯定推广了它</a>！乍一看，快照非常方便——不用编写自己的断言，您只需生成测试来查看您的代码是否有问题。既然计算机可以自动解决我们的问题，为什么还要浪费时间呢？Jest甚至让自动修复你的快照变得超级容易。这意味着即使你有一个失败的测试，你也只需一次按键就可以修复所有的测试。</p></figure>
<figure/>
<h3>当快照测试并不像人们所说的那样好的时候</h3>
<p>乍一看，快照测试听起来像是梦想成真——我所要做的就是编写一段代码来生成快照，我就可以“免费”进行这些超级详细的测试了？已经拿走我的钱了！</p>
<p>然而，在我从事快照测试的过去几年中，我发现快照引入了许多棘手的问题，使得它们难以维护。而且不止我一个！例如，<a href="https://engineering.ezcater.com/the-case-against-react-snapshot-testing" target="_blank" rel="noopener noreferrer">这家公司决定放弃快照</a>并写了相关的文章。或者考虑这条推文:</p>

<p/>
<p>这并不是说快照测试不好！毕竟，每个工具都有利弊，当我们评估使用工具时，承认它的弱点是值得的。以下是我不太喜欢在测试套件中使用快照的几个原因。</p>
<h4>快照容易损坏</h4>
<p>快照通常用于测试<em>组件树</em>或<em>大型对象。</em>然而，由于快照拍摄了组件/对象中每个细节的<em>照片，即使是最轻微的改变(比如修复CSS类中的一个错别字)也会使快照测试失败。结果，即使代码仍然工作，测试也会中断<em>。</em>这些假阴性产生了大量噪音，削弱了你对测试套件的信心。</em></p>
<h4>快照测试非常容易创建，失败的快照也很容易修复</h4>
<p>你可能会想，“这不是一件好事吗？”毕竟，在通过测试套件之外按一次键听起来像是梦想成真。然而，因为测试很容易创建/更新，所以经常发生的是开发人员不太关心快照测试。</p>
<p>根据我的经验，开发人员通常只是简单地按下按钮来更新快照<em>,而不会查看发生了什么变化或者代码是否被破坏。</em>虽然可以像对待代码一样重视快照(这也是<a href="https://jestjs.io/" target="_blank" rel="noopener noreferrer"> Jest docs </a>中的建议)，但这需要大量的努力。更多时候，我的经验是看到工程师盲目地更新快照，继续他们的一天(我自己过去也这样做过很多次😱).</p>
<h4>快照会让你对测试套件的健壮性产生错误的信心</h4>
<p>使用快照很容易生成大量的测试覆盖。如果您的团队有一个所有代码都必须满足的覆盖率阈值，快照可以让您轻而易举地达到覆盖率数字。然而，<em>测试覆盖率本身并不足以用来评估你的测试套件的质量。虽然测试覆盖率是查看测试套件中的差距的一个有价值的工具，但是它不能告诉您测试是否脆弱，您的代码是否经得起边缘情况，或者测试是否准确地测试了业务需求。</em></p>
<h3>Jest快照的亮点——重构遗留代码</h3>
<p>虽然我不喜欢让快照成为我的测试套件的“长期居民”,但实际上我已经遇到了一些它们真正闪耀的用例。比如重构遗留代码。</p>
<p>我们很少开始一项工作就投入到新项目中——我们得到的是已经存在多年的代码库。当我们这样做的时候，如果我们不小心的话，这些项目可能会很快从空白变成噩梦般的代码库。在你职业生涯中的某个时刻，你将不得不处理你没有写的“遗留代码”。而且很多时候那些代码库是没有任何测试的。</p>
<p>当您开始向这个遗留代码添加特性时，您会面临一个两难的境地。您可能需要重构代码以适应新的业务需求，但是您不想冒破坏某些东西的风险。为了安全地重构，您需要某种类型的测试。</p>
<p>问题是，停下来为遗留代码编写测试有时感觉像是一种你没有的奢侈。毕竟，您有截止日期要赶，并且您最终找到了需要修改这些遗留代码的地方。如果你休息时间太长，你可能会失去你已经建立起来的环境！</p>
<p>在这种情况下，快照实际上对我们非常有用。这里有一个快照测试工作流程，我发现它在处理遗留代码时非常有用。</p>
<h4>第一步:写快照来覆盖你能想到的尽可能多的输入</h4>
<p>通读遗留代码，并尝试了解它可能拥有的各种输入。但是，您不需要计算输出！对于每个输入变量，创建一个快照测试。这有助于您了解您正在使用的代码实际上会产生什么输出。</p>
<h4>步骤2:开始重构</h4>
<p>既然你有这个庞大的快照测试安全网可以依靠，那就开始重构吧。记住，这种用快照重构的方法只有在<em>你根本不改变输出</em>的情况下才是好的。因此，如果使用React组件并更改渲染输出，快照将会失败。这并不是世界末日，只要确保检查<em>为什么</em>快照失败，以及改变是否真的是有意的。</p>
<h4>步骤3:丢弃快照，编写一些更集中的测试</h4>
<p>一旦完成重构，您就可以安全地替换这些快照，而不用担心忘记您想要如何重构遗留代码。然而，由于上面讨论的原因，您可能不希望这些快照长期驻留在您的测试套件中。既然代码没有改变，你可以安全地开始<em>重构你的测试</em>。为了使您的测试更具长期弹性，您可能想要考虑进行每个快照测试，并用一个更集中的断言来替换它。例如，我们可以用这个使用<code>react-testing-library</code>和<code>jest-dom</code>的测试代替之前的快照测试。</p>
<figure>
<pre><code>import { render } from "react-testing-library";
import "jest-dom/extend-expect";

function Test({ message }) {
  return {message};
}

test("renders", () =&gt; {
  const { getByText } = render(&lt;Test message="test" /&gt;);

  expect(getByText("test")).toBeInTheDocument();
});</code></pre>
</figure>
<p>当然，这不是一个非常复杂的测试——组件没有任何重构的逻辑！这些更有针对性的主张将经得起时间的考验(双关语😂)更好，因为组件随着未来需求而变化。</p>
<h3>结论</h3>
<p>在我短暂的职业生涯中，我见过很多没有经过测试就由早已离开公司的人编写的代码。众所周知，棘手、密集、难以阅读的代码对团队士气有负面影响，随着时间的推移，代码应该被精心重构以适应新的需求。</p>
<p>然而，嘲笑或抱怨棘手的遗留代码不应该是我们的默认反应——相反，我们应该尝试总是让代码保持比我们发现它时更好的状态。</p>
<p>这说起来容易做起来难，尤其是当我们试图满足一个紧迫的期限，或者如果我们害怕接触代码，以免我们打破了一些东西。这种使用Jest快照的方法对我来说非常有用，我希望你也会发现它很有用！</p>
<p>感谢阅读！如果你喜欢这篇文章，一定要在Twitter上关注我——我一定会在我写的任何新文章上发布链接。如果您已经有了一些快照测试的成功案例，请不要犹豫，立即联系我们！</p><div class="code-block code-block-17">
<div class="blog-plug inline-plug react-plug" vwo-el-id="26283398190">
<h2 vwo-el-id="41600691720"><a href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener"> LogRocket </a>:全面了解您的生产React应用</h2><p>调试React应用程序可能很困难，尤其是当用户遇到难以重现的问题时。如果您对监视和跟踪Redux状态、自动显示JavaScript错误以及跟踪缓慢的网络请求和组件加载时间感兴趣，</p><a href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" vwo-el-id="19356441070">try LogRocket</a><p>. </p><a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="19356441380">
<img class="first-react-image alignnone size-full wp-image-46 jetpack-lazy-image jetpack-lazy-image--handled" src="../Images/f300c244a1a1cf916df8b4cb02bec6c6.png" vwo-el-id="18272717540" data-lazy-loaded="1" data-original-src="https://files.readme.io/27c94e7-Image_2017-06-05_at_9.46.04_PM.png"/>
</a>
<a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="19356441690">
<img class="second-react-image alignnone size-full wp-image-46 jetpack-lazy-image jetpack-lazy-image--handled" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" vwo-el-id="30720362350" data-lazy-loaded="1" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/>
</a>
<p vwo-el-id="28675660440" class="">LogRocket 结合了会话回放、产品分析和错误跟踪，使软件团队能够创建理想的web和移动产品体验。这对你来说意味着什么？</p>
<p>LogRocket不是猜测错误发生的原因，也不是要求用户提供截图和日志转储，而是让您回放问题，就像它们发生在您自己的浏览器中一样，以快速了解哪里出错了。</p>
<p>不再有嘈杂的警报。智能错误跟踪允许您对问题进行分类，然后从中学习。获得有影响的用户问题的通知，而不是误报。警报越少，有用的信号越多。</p>
<p vwo-el-id="28675660750">LogRocket Redux中间件包为您的用户会话增加了一层额外的可见性。LogRocket记录Redux存储中的所有操作和状态。</p>
<p vwo-el-id="28675661060">现代化您调试React应用的方式— <a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="40093418840">开始免费监控</a>。</p>
</div></div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
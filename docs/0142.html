<html>
<head>
<title>CRUD REST API with Node.js, Express, and PostgreSQL - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>带有Node.js、Express和PostgreSQL - LogRocket博客的CRUD REST API</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/crud-rest-api-node-js-express-postgresql/#0001-01-01">https://blog.logrocket.com/crud-rest-api-node-js-express-postgresql/#0001-01-01</a></blockquote><div><article class="article-post">
<p><strong> <em>编者按:</em> </strong> <em>本帖更新于</em> <em> 06月</em> <em> 2022以反映对pgAdmin客户端的更新。</em></p>
<p>对于现代web开发人员来说，知道如何使用API来促进软件系统之间的通信是至关重要的。在本教程中，我们将学习如何在Node.js环境中创建一个CRUD RESTful API，该环境运行在Express服务器上并使用PostgreSQL数据库。我们还将通过使用<a href="https://node-postgres.com/"> node-postgres </a>将Express服务器与PostgreSQL连接起来。</p>
<p>我们的API将能够处理对应于PostgreSQL数据库的HTTP请求方法，API从该数据库获取数据。您还将学习如何安装PostgreSQL并通过命令行界面使用它。</p>
<p>我们的目标是允许在API上进行CRUD操作，<code>GET</code>、<code>POST</code>、<code>PUT</code>和<code>DELETE</code>，这些操作将运行相应的数据库命令。为此，我们将为每个端点设置一个路由，并为每个查询设置一个函数。</p>
<p>我们将详细介绍以下内容:</p>

<p>要跟随本教程，您需要:</p>
<ul>
<li>熟悉JavaScript语法和基础知识</li>
<li>使用命令行的基本知识</li>
<li>已安装Node.js和npm</li>
</ul>
<p>教程的完整代码可以在这个<a href="https://github.com/nemo0/node-postgres-crud-api"> GitHub repo </a>上获得。我们开始吧！</p>
<h2 id="what-restful-api">什么是RESTful API？</h2>
<p>表述性状态转移(REST)为web服务定义了一套标准。API是软件程序用来相互通信的接口。因此，RESTful API是符合REST架构风格和约束的API。REST系统是无状态的、可伸缩的、可缓存的，并且具有统一的接口。</p>
<h2 id="what-crud-api">什么是CRUD API？</h2>
<p>构建API时，您希望您的模型提供四个基本功能。它应该能够创建、读取、更新和删除资源。这组基本操作通常被称为CRUD。</p>
<p>RESTful APIs通常利用HTTP请求。REST环境中最常见的四种HTTP方法是<code>GET</code>、<code>POST</code>、<code>PUT</code>和<code>DELETE</code>，开发人员可以通过这些方法创建CRUD系统。</p>
<ul>
<li><code>Create</code>:使用<code>HTTP POST</code>方法在REST环境中创建一个资源</li>
<li><code>Read</code>:使用<code>GET</code>方法读取资源，在不改变数据的情况下检索数据</li>
<li><code>Update</code>:使用<code>PUT</code>方法更新资源</li>
<li><code>Delete</code>:使用<code>DELETE</code>方法从系统中删除资源</li>
</ul>
<h2 id="what-express">什么是快递？</h2>
<p>根据官方<a href="https://expressjs.com/"> Express文档</a>，Express是Node.js的一个快速、无主见、极简的web框架，Express是Node.js最流行的框架之一，事实上，MERN中的E、MEVN和MEAN stack都代表Express。</p>
<p>尽管Express是极简的，但它也非常灵活，这导致了各种Express中间件的<a href="https://blog.logrocket.com/express-middleware-a-complete-guide/">开发，您可以使用这些中间件来解决几乎任何可以想象的任务或问题。</a></p>
<h2 id="what-postgresql">PostgreSQL是什么？</h2>
<p>PostgreSQL，通常被称为Postgres，是一个免费、开源的关系数据库管理系统。您可能熟悉其他一些类似的数据库系统，如MySQL、Microsoft SQL Server或MariaDB，它们与PostgreSQL竞争。</p>
<p>PostgreSQL是一个健壮的关系数据库，自1997年就已经存在，可用于所有主流操作系统、Linux、Windows和macOS。由于PostgreSQL以稳定性、可扩展性和符合标准而闻名，所以它是开发人员和公司的热门选择。</p>
<p>还可以使用<a href="https://sequelize.org/"> Sequelize </a>创建Node.js RESTful CRUD API。<a href="https://blog.logrocket.com/using-sequelize-with-typescript/"> Sequelize是一个基于promise的Node.js ORM </a>，用于for Postgres、MySQL、MariaDB、SQLite和Microsoft SQL Server。</p>
<p>有关如何在Node.js REST API中使用Sequelize的更多信息，请查看下面的视频教程:</p>
<p><span class="embed-youtube"> <iframe loading="lazy" class="youtube-player" src="https://www.youtube.com/embed/VDgXAw7VynQ?version=3&amp;rel=1&amp;showsearch=0&amp;showinfo=1&amp;iv_load_policy=1&amp;fs=1&amp;hl=en-US&amp;autohide=2&amp;wmode=transparent" allowfullscreen="true" sandbox="allow-scripts allow-same-origin allow-popups allow-presentation">视频</iframe> </span></p>
<h2 id="what-node-postgres">什么是node-postgres？</h2>
<p>node-postgres 或pg是Node.js的非阻塞PostgreSQL客户端。本质上，node-postgres是Node.js模块的集合，用于与PostgreSQL数据库接口。</p>
<p>node-postgres支持的许多特性包括回调、承诺、异步/等待、连接池、预处理语句、游标、富类型解析和C/C++绑定。</p>
<h2 id="creating-postgresql-database">创建PostgreSQL数据库</h2>
<p>我们将通过安装PostgreSQL、创建一个新用户、创建一个数据库以及用一个模式和一些数据初始化一个表来开始本教程。</p>
<h3>装置</h3>
<p>如果你用的是Windows，下载一个PostgreSQL的<a href="https://www.postgresql.org/download/windows/"> Windows安装程序</a>。</p>
<p>如果你使用的是Mac，本教程假设你已经在电脑上安装了<a href="https://brew.sh/"> Homebrew </a>作为安装新程序的软件包管理器。如果没有，只需点击链接并按照说明进行操作。</p>
<p>打开端子，用<code>brew</code>安装<code>postgresql</code>:</p>
<pre class="language-bash">brew install postgresql
</pre>
<p>你可能会在网页上看到说明，显示的是<code>brew install postgres</code>而不是<code>postgresql</code>；这两个选项都将在您的计算机上安装PostgreSQL。</p>
<p>安装完成后，我们希望让<code>postgresql</code>启动并运行，这可以通过<code>services start</code>来实现:</p>
<pre class="language-javascript">brew services start postgresql
==&gt; Successfully started `postgresql` (label: homebrew.mxcl.postgresql)
</pre>
<p>如果您想在任何时候停止<code>postgresql</code>服务，您可以运行<code>brew services stop postgresql</code>。</p>
<p>安装PostgreSQL后，接下来，我们将连接到<code>postgres</code>命令行，在这里我们可以运行SQL命令。</p>
<h2 id="postgresql-command-prompt">PostgreSQL命令提示符</h2>
<p><code>psql</code>是PostgreSQL交互终端。运行<code>psql</code>会将您连接到一个PostgreSQL主机。运行<code>psql --help</code>将为您提供更多关于与<code>psql</code>连接的可用选项的信息:</p>
<ul>
<li><code>-h</code> : <code>--host=HOSTNAME</code>:数据库服务器主机或套接字目录；默认是<code>local socket</code></li>
<li><code>-p</code> : <code>--port=PORT</code>:数据库服务器端口；默认是<code>5432</code></li>
<li><code>-U</code> : <code>--username=USERNAME</code>:数据库用户名；默认是<code>your_username</code></li>
<li><code>-w</code> : <code>--no-password</code>:从不提示输入密码</li>
<li><code>-W</code> : <code>--password</code>:强制密码提示，应该自动出现</li>
</ul>
<p>我们将用默认的登录信息和无选项标志连接到默认的<code>postgres</code>数据库:</p>
<pre class="language-javascript">psql postgres
</pre>
<p>你会发现我们建立了新的联系。我们现在在数据库<code>postgres</code>的<code>psql</code>中。提示符以一个<code>#</code>结尾，表示我们作为超级用户或root登录:</p>
<pre class="language-javascript">postgres=#
</pre>
<p><code>psql</code>中的命令以反斜杠<code>\</code>开始。为了测试我们的第一个命令，我们可以使用<code>\conninfo</code>命令检查我们连接到了什么数据库、用户和端口。</p>
<pre class="language-javascript">postgres=# \conninfo
You are connected to database "postgres" as user "your_username" via socket in "/tmp" at port "5432".
</pre>
<p>下面的参考表包括一些我们将在本教程中使用的常用命令:</p>
<ul>
<li><code>\q</code>:退出<code>psql</code>连接</li>
<li><code>\c</code>:连接到新的数据库</li>
<li><code>\dt</code>:列出所有表格</li>
<li><code>\du</code>:列出所有角色</li>
<li><code>\list</code>:列出数据库</li>
</ul>
<p>让我们创建一个新的数据库和用户，这样我们就不会使用默认帐户，这些帐户拥有超级用户权限。</p>
<h2 id="creating-role-postgres">在Postgres中创建角色</h2>
<p>首先，我们将创建一个名为<code>me</code>的角色，并给它一个密码<code>password</code>。角色可以充当用户或组。在这种情况下，我们将以用户身份使用它:</p>
<pre class="language-javascript">postgres=# CREATE ROLE me WITH LOGIN PASSWORD 'password';
</pre>
<p>我们希望<code>me</code>能够创建一个数据库:</p>
<pre class="language-javascript">postgres=# ALTER ROLE me CREATEDB;
</pre>
<p>您可以运行<code>\du</code>来列出所有角色和用户:</p>
<pre class="language-javascript">me          | Create DB                           | {}
postgres    | Superuser, Create role, Create DB   | {}
</pre>
<p>现在，我们想从<code>me</code>用户创建一个数据库。使用<code>\q</code>退出默认会话:</p>
<pre class="language-javascript">postgres=# \q
</pre>
<p>我们回到了电脑的默认终端连接。现在，我们将连接<code>postgres</code>和<code>me</code>:</p>
<pre class="language-javascript">psql -d postgres -U me
</pre>
<p>我们的提示符现在显示的是<code>postgres=&gt;</code>，而不是<code>postgres=#</code>，这意味着我们不再以超级用户的身份登录。</p>
<h2 id="creating-database-postgres">在Postgres中创建数据库</h2>
<p>我们可以使用SQL命令创建一个数据库，如下所示:</p>
<pre class="language-javascript">postgres=&gt; CREATE DATABASE api;
</pre>
<p>使用<code>\list</code>命令查看可用的数据库:</p>
<pre class="language-javascript">Name    |    Owner    | Encoding |   Collate   |    Ctype    |
api     | me          | UTF8     | en_US.UTF-8 | en_US.UTF-8 |
</pre>
<p>让我们使用<code>\c</code> connect命令通过<code>me</code>连接到新的<code>api</code>数据库:</p>
<pre class="language-javascript">postgres=&gt; \c api
You are now connected to database "api" as user "me".
api=&gt;
</pre>
<p>我们的提示现在显示我们已连接到<code>api</code>。</p>
<h2 id="creating-table-postgres">在Postgres中创建表格</h2>
<p>最后，在<code>psql</code>命令提示符下，我们将创建一个名为<code>users</code>的表，它有三个字段、两个<code>VARCHAR</code>类型和一个自动递增的<code>PRIMARY KEY</code> ID:</p>
<pre class="language-javascript">api=&gt;
CREATE TABLE users (
  ID SERIAL PRIMARY KEY,
  name VARCHAR(30),
  email VARCHAR(30)
);
</pre>
<p>在PostgreSQL中创建和使用表时，确保不要使用反勾<code>`</code>字符。虽然在MySQL中允许使用反斜线，但在PostgreSQL中是无效的。还要确保在<code>CREATE TABLE</code>命令中没有尾随逗号。</p><div class="code-block code-block-54">
<hr/>
<h3>更多来自LogRocket的精彩文章:</h3>

<hr/></div>
<p>让我们通过向<code>users</code>添加两个条目来添加一些数据:</p>
<pre class="language-javascript">INSERT INTO users (name, email)
  VALUES ('Jerry', '<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="3c56594e4e457c59445d514c5059125f5351">[email protected]</a>'), ('George', '<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="482f2d273a2f2d082d30292538242d662b2725">[email protected]</a>');
</pre>
<p>让我们通过获取<code>users</code>中的所有条目来确保以上信息被正确添加:</p>
<pre class="language-javascript">api=&gt; SELECT * FROM users;
id |  name  |       email        
----+--------+--------------------
  1 | Jerry  | <a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="86ece3f4f4ffc6e3fee7ebf6eae3a8e5e9eb">[email protected]</a>
  2 | George | <a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="f7909298859092b7928f969a879b92d994989a">[email protected]</a>
</pre>
<p>现在，我们有了一个用户、数据库、表和一些数据。我们可以开始构建Node.js RESTful API来连接存储在PostgreSQL数据库中的数据。</p>
<p>至此，我们已经完成了所有PostgreSQL任务，可以开始设置Node.js应用程序和Express服务器了。</p>
<h2 id="setting-up-express-server">设置Express服务器</h2>
<p>要设置Node.js应用程序和Express服务器，首先要为项目创建一个目录:</p>
<pre class="language-javascript">mkdir node-api-postgres
cd node-api-postgres
</pre>
<p>您可以运行<code>npm init -y</code>来创建一个<code>package.json</code>文件，或者将下面的代码复制到一个<code>package.json</code>文件中:</p>
<pre class="language-javascript">{
  "name": "node-api-postgres",
  "version": "1.0.0",
  "description": "RESTful API with Node.js, Express, and PostgreSQL",
  "main": "index.js",
  "license": "MIT"
}
</pre>
<p>我们希望为服务器和节点安装Express-postgres以连接到PostgreSQL:</p>
<pre class="language-javascript">npm i express pg
</pre>
<p>现在，我们已经将依赖关系加载到了<code>node_modules</code>和<code>package.json</code>中。</p>
<p>创建一个<code>index.js</code>文件，我们将用它作为服务器的入口点。在顶部，我们将需要<code>express</code>模块、内置的<a href="http://expressjs.com/en/resources/middleware/body-parser.html"> <code>body-parser</code>中间件</a>，并且我们将设置我们的<code>app</code>和<code>port</code>变量:</p>
<pre class="language-javascript">const express = require('express')
const bodyParser = require('body-parser')
const app = express()
const port = 3000

app.use(bodyParser.json())
app.use(
  bodyParser.urlencoded({
    extended: true,
  })
)
</pre>
<p>我们将告诉route在根<code>/</code> URL上寻找<code>GET</code>请求，并返回一些JSON:</p>
<pre class="language-javascript">app.get('/', (request, response) =&gt; {
  response.json({ info: 'Node.js, Express, and Postgres API' })
})
</pre>
<p>现在，将应用程序设置为监听您设置的端口:</p>
<pre class="language-javascript">app.listen(port, () =&gt; {
  console.log(`App running on port ${port}.`)
})
</pre>
<p>从命令行，我们可以通过点击<code>index.js</code>来启动服务器:</p>
<pre class="language-javascript">node index.js
App running on port 3000.
</pre>
<p>在你的浏览器的地址栏转到<code><a href="http://localhost:3000" rel="nofollow">http://localhost:3000</a></code>，你会看到我们之前设置的JSON:</p>
<pre class="language-javascript">{
  info: "Node.js, Express, and Postgres API"
}
</pre>
<p>Express服务器现在正在运行，但是它只发送一些我们创建的静态JSON数据。下一步是从Node.js连接到PostgreSQL，以便能够进行动态查询。</p>
<h2 id="connectingtoapostgresdatabaseusingaclient">使用客户端连接到Postgres数据库</h2>
<p>访问Postgres数据库的一个流行客户端是<a href="https://www.pgadmin.org/"> pgAdmin </a>客户端。pgAdmin应用程序可用于各种平台。如果你想为你的Postgres数据库设计一个图形用户界面，你可以去<a href="https://www.pgadmin.org/download/">下载页面</a>下载必要的软件包。</p>
<p>使用pgAdmin创建和查询数据库很简单。你需要点击顶部菜单上的<strong>对象</strong>选项，选择<strong>创建</strong>，选择<strong>数据库</strong>来创建一个新的连接。所有的数据库都可以在侧边菜单上找到。通过选择适当的数据库，您可以高效地查询或运行SQL查询:</p>
<p><img data-attachment-id="114793" data-permalink="https://blog.logrocket.com/create-query-datebase/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/06/create-query-datebase.png" data-orig-size="730,391" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="create-query-database" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/06/create-query-datebase-300x161.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/06/create-query-datebase.png" decoding="async" class="aligncenter wp-image-114793 size-full jetpack-lazy-image" src="../Images/d148592304aec41eec99faefeef177f8.png" alt="Create Query Database" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2022/06/create-query-datebase.png 730w, https://blog.logrocket.com/wp-content/uploads/2022/06/create-query-datebase-300x161.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2022/06/create-query-datebase.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/06/create-query-datebase.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="114793" data-permalink="https://blog.logrocket.com/create-query-datebase/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/06/create-query-datebase.png" data-orig-size="730,391" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="create-query-database" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/06/create-query-datebase-300x161.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/06/create-query-datebase.png" decoding="async" loading="lazy" class="aligncenter wp-image-114793 size-full" src="../Images/d148592304aec41eec99faefeef177f8.png" alt="Create Query Database" srcset="https://blog.logrocket.com/wp-content/uploads/2022/06/create-query-datebase.png 730w, https://blog.logrocket.com/wp-content/uploads/2022/06/create-query-datebase-300x161.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/06/create-query-datebase.png"/></noscript>
<h2 id="connecting-postgres-database-node-js">从Node.js连接到Postgres数据库</h2>
<p>我们将使用<a href="https://node-postgres.com/"> node-postgres </a>模块来创建一个连接池。因此，我们不必在每次查询时都打开和关闭客户机。</p>
<p>生产池的一个流行选项是使用<code><a href="https://pgbouncer.github.io/">pgBouncer</a></code>，这是PostgreSQL的一个轻量级连接池。</p>
<p>创建一个名为<code>queries.js</code>的文件，并设置PostgreSQL连接的配置:</p>
<pre class="language-javascript">const Pool = require('pg').Pool
const pool = new Pool({
  user: 'me',
  host: 'localhost',
  database: 'api',
  password: 'password',
  port: 5432,
})
</pre>
<p>在生产环境中，您可能希望将配置详细信息放在一个具有限制性权限的单独文件中，这样就不能从版本控制中访问它。但是，为了简化本教程，我们将把它保存在与查询相同的文件中。</p>
<p>本教程的目的是允许在API上进行CRUD操作，<code>GET</code>、<code>POST</code>、<code>PUT</code>和<code>DELETE</code>，这些操作将运行相应的数据库命令。为此，我们将为每个端点设置一个路由，并为每个查询设置一个函数。</p>
<h2 id="creating-routes-crud-operations">为CRUD操作创建路线</h2>
<p>我们将为六条路线创建六个函数，如下所示。首先，为每条路线创建所有的函数。然后，导出这些函数，以便可以访问它们:</p>
<ul>
<li><code>GET</code> : <code>/</code> | <code>displayHome()</code></li>
<li><code>GET</code> : <code>/users</code> | <code>getUsers()</code></li>
<li><code>GET</code> : <code>/users/:id</code> | <code>getUserById()</code></li>
<li><code>POST</code> : <code>/users</code> | <code>createUser()</code></li>
<li><code>PUT</code> : <code>/users/:id</code> | <code>updateUser()</code></li>
<li><code>DELETE</code> : <code>/users/:id</code> | <code>deleteUser()</code></li>
</ul>
<p>在<code>index.js</code>中，我们为根端点制作了一个<code>app.get()</code>，其中包含一个函数。现在，在<code>queries.js</code>中，我们将创建显示所有用户、显示单个用户、创建新用户、更新现有用户和删除用户的端点。</p>
<h3><code>GET</code>所有用户</h3>
<p>我们的第一个端点将是一个<code>GET</code>请求。我们可以将接触到数据库的原始SQL放在<code>pool.query()</code>中。我们将<code>SELECT</code>所有用户并按ID排序。</p>
<pre class="language-javascript">const getUsers = (request, response) =&gt; {
  pool.query('SELECT * FROM users ORDER BY id ASC', (error, results) =&gt; {
    if (error) {
      throw error
    }
    response.status(200).json(results.rows)
  })
}
</pre>
<h3><code>GET</code>单个用户通过ID</h3>
<p>对于我们的<code>/users/:id</code>请求，我们将通过URL获得自定义的<code>id</code>参数，并使用一个<code>WHERE</code>子句来显示结果。</p>
<p>在SQL查询中，我们在寻找<code>id=$1</code>。在这个实例中，<code>$1</code>是PostgreSQL本身使用的一个带编号的占位符，而不是您可能从SQL的其他变体中识别的<code>?</code>占位符:</p>
<pre class="language-javascript">const getUserById = (request, response) =&gt; {
  const id = parseInt(request.params.id)

  pool.query('SELECT * FROM users WHERE id = $1', [id], (error, results) =&gt; {
    if (error) {
      throw error
    }
    response.status(200).json(results.rows)
  })
}
</pre>
<h3><code>POST</code>新用户</h3>
<p>API将把一个<code>GET</code>和<code>POST</code>请求带到<code>/users</code>端点。在<code>POST</code>请求中，我们将添加一个新用户。在这个函数中，我们从请求体中提取了<code>name</code>和<code>email</code>属性，并插入了带有<code>INSERT</code>的值:</p>
<pre class="language-javascript">const createUser = (request, response) =&gt; {
  const { name, email } = request.body

  pool.query('INSERT INTO users (name, email) VALUES ($1, $2) RETURNING *', [name, email], (error, results) =&gt; {
    if (error) {
      throw error
    }
    response.status(201).send(`User added with ID: ${results.rows[0].id}`)
  })
}
</pre>
<h3><code>PUT</code>更新现有用户中的数据</h3>
<p><code>/users/:id</code>端点也将接受两个HTTP请求，一个是我们为<code>getUserById</code>创建的<code>GET</code>,另一个是修改现有用户的<code>PUT</code>。对于这个查询，我们将结合我们在<code>GET</code>和<code>POST</code>中学到的知识来使用<code>UPDATE</code>子句。</p>
<p>值得注意的是,<code>PUT</code>是幂等的，这意味着完全相同的调用可以反复进行，并将产生相同的结果。<code>PUT</code>与<code>POST</code>不同，完全相同的呼叫不断重复，会不断产生新的数据用户:</p>
<pre class="language-javascript">const updateUser = (request, response) =&gt; {
  const id = parseInt(request.params.id)
  const { name, email } = request.body

  pool.query(
    'UPDATE users SET name = $1, email = $2 WHERE id = $3',
    [name, email, id],
    (error, results) =&gt; {
      if (error) {
        throw error
      }
      response.status(200).send(`User modified with ID: ${id}`)
    }
  )
}
</pre>
<h3><code>DELETE</code>一个用户</h3>
<p>最后，我们将使用<code>/users/:id</code>上的<code>DELETE</code>子句删除一个特定的ID用户。这个调用非常类似于我们的<code>getUserById()</code>功能:</p>
<pre class="language-javascript">const deleteUser = (request, response) =&gt; {
  const id = parseInt(request.params.id)

  pool.query('DELETE FROM users WHERE id = $1', [id], (error, results) =&gt; {
    if (error) {
      throw error
    }
    response.status(200).send(`User deleted with ID: ${id}`)
  })
}
</pre>
<h2 id="exporting-crud-functions-rest-api">在REST API中导出CRUD函数</h2>
<p>要从<code>index.js</code>访问这些功能，我们需要导出它们。我们可以用<code>module.exports</code>来实现，创建一个函数对象。因为我们使用的是ES6语法，我们可以写<code>getUsers</code>而不是<code>getUsers:getUsers</code>等等:</p>
<pre class="language-javascript">module.exports = {
  getUsers,
  getUserById,
  createUser,
  updateUser,
  deleteUser,
}
</pre>
<p>我们完整的<code>queries.js</code>文件如下:</p>
<pre class="language-javascript">const Pool = require('pg').Pool
const pool = new Pool({
  user: 'me',
  host: 'localhost',
  database: 'api',
  password: 'password',
  port: 5432,
})
const getUsers = (request, response) =&gt; {
  pool.query('SELECT * FROM users ORDER BY id ASC', (error, results) =&gt; {
    if (error) {
      throw error
    }
    response.status(200).json(results.rows)
  })
}

const getUserById = (request, response) =&gt; {
  const id = parseInt(request.params.id)

  pool.query('SELECT * FROM users WHERE id = $1', [id], (error, results) =&gt; {
    if (error) {
      throw error
    }
    response.status(200).json(results.rows)
  })
}

const createUser = (request, response) =&gt; {
  const { name, email } = request.body

  pool.query('INSERT INTO users (name, email) VALUES ($1, $2)', [name, email], (error, results) =&gt; {
    if (error) {
      throw error
    }
    response.status(201).send(`User added with ID: ${results.insertId}`)
  })
}

const updateUser = (request, response) =&gt; {
  const id = parseInt(request.params.id)
  const { name, email } = request.body

  pool.query(
    'UPDATE users SET name = $1, email = $2 WHERE id = $3',
    [name, email, id],
    (error, results) =&gt; {
      if (error) {
        throw error
      }
      response.status(200).send(`User modified with ID: ${id}`)
    }
  )
}

const deleteUser = (request, response) =&gt; {
  const id = parseInt(request.params.id)

  pool.query('DELETE FROM users WHERE id = $1', [id], (error, results) =&gt; {
    if (error) {
      throw error
    }
    response.status(200).send(`User deleted with ID: ${id}`)
  })
}

module.exports = {
  getUsers,
  getUserById,
  createUser,
  updateUser,
  deleteUser,
}
</pre>
<h2 id="setting-up-crud-functions-rest-api">在REST API中设置CRUD函数</h2>
<p>现在我们有了所有的查询，我们需要将它们放入到<code>index.js</code>文件中，并为我们创建的所有查询函数创建端点路由。</p>
<p>为了从<code>queries.js</code>获取所有导出的函数，我们将<code>require</code>该文件并将其赋给一个变量:</p>
<pre class="language-javascript">const db = require('./queries')
</pre>
<p>现在，对于每个端点，我们将设置HTTP请求方法、端点URL路径和相关函数:</p>
<pre class="language-javascript">app.get('/users', db.getUsers)
app.get('/users/:id', db.getUserById)
app.post('/users', db.createUser)
app.put('/users/:id', db.updateUser)
app.delete('/users/:id', db.deleteUser)
</pre>
<p>下面是我们完整的<code>index.js</code>文件，API服务器的入口点:</p>
<pre class="language-javascript">const express = require('express')
const bodyParser = require('body-parser')
const app = express()
const db = require('./queries')
const port = 3000

app.use(bodyParser.json())
app.use(
  bodyParser.urlencoded({
    extended: true,
  })
)

app.get('/', (request, response) =&gt; {
  response.json({ info: 'Node.js, Express, and Postgres API' })
})

app.get('/users', db.getUsers)
app.get('/users/:id', db.getUserById)
app.post('/users', db.createUser)
app.put('/users/:id', db.updateUser)
app.delete('/users/:id', db.deleteUser)

app.listen(port, () =&gt; {
  console.log(`App running on port ${port}.`)
})
</pre>
<p>有了这两个文件，我们就有了服务器、数据库和API。您可以再次点击<code>index.js</code>来启动服务器:</p>
<pre class="language-javascript">node index.js
App running on port 3000.
</pre>
<p>现在，如果您转到<code><a href="http://localhost:3000/users" rel="nofollow">http://localhost:3000/users</a></code>或<code><a href="http://localhost:3000/users/1" rel="nofollow">http://localhost:3000/users/1</a></code>，您将看到两个<code>GET</code>请求的JSON响应。</p>
<p>为了测试我们的<code>POST</code>、<code>PUT</code>和<code>DELETE</code>请求，我们可以使用像Postman这样的工具或者像<a href="https://www.thunderclient.com/"> Thunder Client </a>这样的VS代码扩展来发送HTTP请求。您还可以使用<a href="https://curl.se/"> curl </a>，这是一个已经在您的终端上可用的命令行工具。</p>
<p>使用Postman或Thunder客户端工具可以很容易地用不同的HTTP方法查询端点。只需输入您的URL，选择特定的HTTP方法，如果端点是PUT或POST路由，则插入JSON值，然后点击<strong> send </strong>:</p>
<p><img data-attachment-id="114795" data-permalink="https://blog.logrocket.com/add-new-user-thunderclient-vscode/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/06/add-new-user-thunderclient-vscode.png" data-orig-size="730,359" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="add-new-user-thunderclient-vscode" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/06/add-new-user-thunderclient-vscode-300x148.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/06/add-new-user-thunderclient-vscode.png" decoding="async" class="aligncenter wp-image-114795 size-full jetpack-lazy-image" src="../Images/9284d1295fa4b1f07244f4bc46b3d4e1.png" alt="Add New User Thunderclient Vscode" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2022/06/add-new-user-thunderclient-vscode.png 730w, https://blog.logrocket.com/wp-content/uploads/2022/06/add-new-user-thunderclient-vscode-300x148.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2022/06/add-new-user-thunderclient-vscode.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/06/add-new-user-thunderclient-vscode.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="114795" data-permalink="https://blog.logrocket.com/add-new-user-thunderclient-vscode/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/06/add-new-user-thunderclient-vscode.png" data-orig-size="730,359" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="add-new-user-thunderclient-vscode" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/06/add-new-user-thunderclient-vscode-300x148.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/06/add-new-user-thunderclient-vscode.png" decoding="async" loading="lazy" class="aligncenter wp-image-114795 size-full" src="../Images/9284d1295fa4b1f07244f4bc46b3d4e1.png" alt="Add New User Thunderclient Vscode" srcset="https://blog.logrocket.com/wp-content/uploads/2022/06/add-new-user-thunderclient-vscode.png 730w, https://blog.logrocket.com/wp-content/uploads/2022/06/add-new-user-thunderclient-vscode-300x148.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/06/add-new-user-thunderclient-vscode.png"/></noscript>
<p>上面的例子显示了发送一个<code>POST</code>请求到指定的路由。<code>POST</code>选项表明这是一个<code>POST</code>请求。方法旁边的URL是API端点，JSON内容是要发送到端点的数据。你同样可以选择不同的路线。</p>
<h2 id="conclusion">结论</h2>
<p>现在，您应该有了一个运行在Node.js上的API服务器，并连接到一个活动的PostgreSQL数据库。在本教程中，我们学习了如何在命令行中安装和设置PostgreSQL，创建用户、数据库和表，以及运行SQL命令。我们还学习了如何创建一个可以处理多种HTTP方法的Express服务器，并使用<code>pg</code>模块从Node.js连接到PostgreSQL。</p>
<p>有了这些知识，您应该能够构建这个API，并将其用于您自己的个人或专业开发项目。</p>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
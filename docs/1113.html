<html>
<head>
<title>Building a password hasher in Node.js - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>在Node.js - LogRocket博客中构建密码散列器</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/building-a-password-hasher-in-node-js/#0001-01-01">https://blog.logrocket.com/building-a-password-hasher-in-node-js/#0001-01-01</a></blockquote><div><article class="article-post">
<p>哈希是指使用算法将任意大小的数据映射到固定长度。这是一个单向函数，主要用于身份验证。</p>
<p>在本教程中，我们将向您展示如何构建一个密码散列器来散列和存储数据库中的用户凭证。</p>
<p>为此，我们将使用一种称为salt hashing的技术。salt是一个随机的数据片段，用作散列数据或密码的单向函数的附加输入。Salts用于保护存储中的密码，因此您可以避免在数据库中存储明文密码。</p>
<p>根据salt散列技术，我们将获取用户输入的密码和随机字符串(salt)，使用合适的加密散列算法对组合字符串进行散列，并将结果存储在数据库中。</p>
<h2 id="prerequisites"><strong>先决条件</strong></h2>
<p>要跟随本教程，您需要:</p>
<ul>
<li>基本了解Node.js</li>
<li>安装了代码编辑器，如VS代码</li>
<li>邮递员已安装</li>
<li>MongoDB设置</li>
</ul>
<h2 id="writingthehashingfunctions">编写散列函数</h2>
<p>基本上，我们将有三个功能来执行以下任务。</p>
<ol>
<li>生成salt(随机加密字符串)</li>
<li>散列数据</li>
<li>比较哈希值</li>
</ol>
<p>要设置Node.js应用程序，您需要一个<code>package.json</code>文件来记录依赖关系。要创建它，请在您的终端上运行以下命令。</p>
<pre>npm init -y
</pre>
<p>接下来，创建一个<code>index.js</code>文件。这是应用程序的根，我们将在这里编写所有的哈希代码。</p>
<pre>touch index.js
</pre>
<p>这将创建<code>index.js</code>文件。</p>
<p>将以下内容添加到您的<code>index.js</code>文件中。</p>
<pre>console.log(`Hello...I'm a nodejs developer`)
</pre>
<p>然后，在您的终端上运行<code>node index</code>。如果控制台上有<code>Hello...I'm a nodejs developer</code>字样，就可以开始了。</p>
<p>我们首先需要Node.js加密模块，然后创建一个简单的函数来记录控制台上的函数。</p>
<pre>'use strict';
let crypto = require('crypto');
// logger 
let logger = func =&gt; {
    console.log(func);
};
</pre>
<p>下一步是创建一个函数来生成随机盐。这个函数将接受一个数字作为参数来定义盐的长度。我们将添加一个简单的验证器来检查数字是否大于15。</p>
<pre>let generateSalt = rounds =&gt; {
    if (rounds &gt;= 15) {
        throw new Error(`${rounds} is greater than 15,Must be less that 15`);
    }
    if (typeof rounds !== 'number') {
        throw new Error('rounds param must be a number');
    }
    if (rounds == null) {
        rounds = 12;
    }
    return crypto.randomBytes(Math.ceil(rounds / 2)).toString('hex').slice(0, rounds);
};
logger(generateSalt(12))
</pre>
<p>在控制台上运行<code>node index</code>打印生成的随机字符串。<code>.toString('hex')</code>方法将字符串转换成十六进制格式，而<code>slice(0, rounds)</code>只返回所需值的数字。</p>
<p>接下来，我们将定义散列算法来执行散列和加盐逻辑。我们将使用<code>**crypto.createHmac(algorithm, key[, options])**</code>，它创建并返回一个使用给定的<code>algorithm</code>和<code>key</code>的<code>Hmac</code>对象。我们还将使用<code>sha512</code>算法。第二个参数将是关键，这是我们传递盐的地方。</p>
<pre>let hasher = (password, salt) =&gt; {
    let hash = crypto.createHmac('sha512', salt);
    hash.update(password);
    let value = hash.digest('hex');
    return {
        salt: salt,
        hashedpassword: value
    };
};
</pre>
<p>有了这个定义，我们将编写我们的散列函数，它将调用hasher函数。我们将在这里执行所有的验证，比如确保salt是一个字符串，提供了一个简单的密码，并且在参数中提供了password和salt。</p>
<pre>let hash = (password, salt) =&gt; {
    if (password == null || salt == null) {
        throw new Error('Must Provide Password and salt values');
    }
    if (typeof password !== 'string' || typeof salt !== 'string') {
        throw new Error('password must be a string and salt must either be a salt string or a number of rounds');
    }
    return hasher(password, salt);
};
logger(hash('Wisdom', generateSalt(12)))
</pre>
<p>首先验证是否提供了salt和普通密码，然后检查password和salt是否都是字符串类型。</p>
<p>使用我们的日志功能来测试您的功能。运行<code>node index</code>将在控制台上打印散列密码和salt。</p><div class="code-block code-block-54">
<hr/>
<h3>更多来自LogRocket的精彩文章:</h3>

<hr/></div>
<pre>{
  salt: 'f844b09ff50c',
  hashedpassword: '2d2528d4534394d1e2702f53826d11c16ed4422f6bd466745cb4f1aa0e042b52b98fc5e65b86d73a6ce4807679b773fb955c4824b0471015354e1a872d42cb62'
}
</pre>
<p>复制并保存在一个变量中。我们稍后将使用它来测试比较密码功能。</p>
<p>在此之前，我们必须定义比较密码函数。这实际上将使用相同的算法来散列输入的密码，然后测试新的散列是否与存储的散列匹配。</p>
<pre>let compare = (password, hash) =&gt; {
    hash = {
        salt: 'f844b09ff50c',
        hashedpassword: '2d2528d4534394d1e2702f53826d11c16ed4422f6bd466745cb4f1aa0e042b52b98fc5e65b86d73a6ce4807679b773fb955c4824b0471015354e1a872d42cb62'
    }
    if (password == null || hash == null) {
        throw new Error('password and hash is required to compare');
    }
    if (typeof password !== 'string' || typeof hash !== 'object') {
        throw new Error('password must be a String and hash must be an Object');
    }
    let passwordData = hasher(password, hash.salt);
    if (passwordData.hashedpassword === hash.hashedpassword) {
        return true;
    }
    return false
};
logger(compare('wisdom'))
</pre>
<p>这个函数接受输入的密码和一个散列作为参数。出于测试目的，我们将使用我们得到的salt和hashed密码来测试compare password函数。</p>
<p>我们将编写一些验证来检查是否提供了密码或哈希，以及密码的类型是否是字符串，哈希的类型是否是对象，其中包含salt值和哈希密码。</p>
<p>然后，我们将使用相同的<code>hasher</code>函数散列新输入的密码，然后检查新散列密码是否等于存储在数据库中的密码。如果匹配，则返回值<code>true</code>；否则，它将成为<code>false</code>。</p>
<p>要使用hasher函数，您必须通过在文件末尾添加以下内容来导出它。</p>
<pre> module.exports = {
    generateSalt,
    hash,
    compare
}
</pre>
<h2 id="usingourhashingfunctioninourapplication">散列函数在起作用</h2>
<p>现在我们可以开始使用hasher函数来注册和登录用户。我们将通过以下方式简化事情:</p>
<ul>
<li>设置简单快速服务器</li>
<li>设置MongoDB</li>
<li>创建必要的路线</li>
</ul>
<p>让我们创建一个<code>test.js</code>文件。这是我们测试哈希模块的地方。</p>
<p>首先安装以下软件包。</p>
<ul>
<li>用于设置我们的服务器和路线</li>
<li><code>mongoose</code>对于MongoDB的连接和查询</li>
<li><code>morgan</code>为伐木路线</li>
<li><code>body-parser</code>接受JSON类型的请求</li>
</ul>
<p>要安装这些，请打开您的终端并运行:</p>
<pre>npm i express mongoose morgan body-parser --save
</pre>
<p>这将安装所有的包并在<code>package.json</code>文件中记录活动。</p>
<p>它还将创建一个<code>node_modules</code>文件夹，我们需要向其中添加一个<code>.gitignore</code>文件，这样它就不会在Git上被提交。</p>
<p>我们需要修改<code>test.js</code>中的代码。</p>
<pre>const express = require('express');
const morgan = require('morgan');
const bodyParser = require('body-parser');
const mongoose = require('mongoose');
const port = process.env.PORT || 5000;
const app = express();

// Defining middlewares
app.use(morgan('dev'));
app.use(bodyParser.json());

mongoose.Promise = global.Promise;
// Connecting to the database
mongoose.connect('mongodb://localhost:27017/hasher', {
    useNewUrlParser: true
}).then(() =&gt; {
    console.log("Successfully connected to the database");
}).catch(err =&gt; {
    console.log('Could not connect to the database. Exiting now...', err);
    process.exit();
});



app.listen(port, () =&gt; {
    console.log('App is Running on port', port)
});
</pre>
<p>在这里，我们需要安装和配置所有的包。我们使用<code>mongoDB</code>ORM(mongose)连接到MongoDB本地服务器，然后使用express的实例监听一个<code>PORT</code>。</p>
<p>下一步是使用Mongoose定义我们的<code>User</code>模型。创建一个<code>user.model.js</code>文件并添加以下内容。</p>
<pre>const mongoose = require('mongoose');
const userSchema = mongoose.Schema({
    name: {
        type: String,
        required: true
    },
    email: {
        type: String,
        required: true
    },
    password: {
        type:Object,
        required: true
    }
}, {
    timestamps: true
});
module.exports = mongoose.model('User', userSchema);
</pre>
<p>我们现在可以定义我们的注册和登录路径来测试hasher。</p>
<p>我们将创建一个<code>user.routes.js</code>。为了简单起见，我们将在一个文件中编写我们的写逻辑和业务逻辑。</p>
<p>首先定义注册路由。</p>
<pre> module.exports = (app) =&gt; {
     const User = require('./user.model')
     const {
         generateSalt,
         hash,
         compare
     } = require('./index');
     let salt = generateSalt(10);
     app.post('/register', async (req, res) =&gt; {
         try {
             let user = new User({
                 name: req.body.name,
                 email: req.body.email,
                 password: await hash(req.body.password, salt) // dont remove the await
             })
             let response = await user.save();
             res.status(200).json({
                 status: "Success",
                 data: response
             })
         } catch (err) {
             //handle error
         }
     });
 }
</pre>
<p>接下来，在<code>test.js</code>文件中注册。这必须归入猫鼬构型。</p>
<pre>require('./user.routes')(app);
</pre>
<p>现在我们可以测试注册路由。打开您的邮递员，按照您定义的模式向<code>/register</code>发出post请求。</p>
<p><img data-attachment-id="24192" data-permalink="https://blog.logrocket.com/building-a-password-hasher-in-node-js/postman-request-register/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/09/postman-request-register.png" data-orig-size="720,470" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Testing the register route via POSTMAN" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/09/postman-request-register-300x196.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/09/postman-request-register.png" decoding="async" class="aligncenter size-full wp-image-24192 jetpack-lazy-image" src="../Images/371d20d693214de18ff8327791d1d2a3.png" alt="Testing the register Route via POSTMAN" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2020/09/postman-request-register.png 720w, https://blog.logrocket.com/wp-content/uploads/2020/09/postman-request-register-300x196.png 300w" data-lazy-sizes="(max-width: 720px) 100vw, 720px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2020/09/postman-request-register.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/09/postman-request-register.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="24192" data-permalink="https://blog.logrocket.com/building-a-password-hasher-in-node-js/postman-request-register/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/09/postman-request-register.png" data-orig-size="720,470" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Testing the register route via POSTMAN" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/09/postman-request-register-300x196.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/09/postman-request-register.png" decoding="async" loading="lazy" class="aligncenter size-full wp-image-24192" src="../Images/371d20d693214de18ff8327791d1d2a3.png" alt="Testing the register Route via POSTMAN" srcset="https://blog.logrocket.com/wp-content/uploads/2020/09/postman-request-register.png 720w, https://blog.logrocket.com/wp-content/uploads/2020/09/postman-request-register-300x196.png 300w" sizes="(max-width: 720px) 100vw, 720px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/09/postman-request-register.png"/></noscript> <img data-attachment-id="24193" data-permalink="https://blog.logrocket.com/building-a-password-hasher-in-node-js/testing-code-postman/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/09/testing-code-postman.png" data-orig-size="720,470" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Testing the register route via POSTMAN" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/09/testing-code-postman-300x196.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/09/testing-code-postman.png" decoding="async" class="aligncenter size-full wp-image-24193 jetpack-lazy-image" src="../Images/0bdb3eae9e13927ea7e0112f28e708d5.png" alt="Testing the register Route via POSTMAN" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2020/09/testing-code-postman.png 720w, https://blog.logrocket.com/wp-content/uploads/2020/09/testing-code-postman-300x196.png 300w" data-lazy-sizes="(max-width: 720px) 100vw, 720px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2020/09/testing-code-postman.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/09/testing-code-postman.png"/><noscript><img data-lazy-fallback="1" data-attachment-id="24193" data-permalink="https://blog.logrocket.com/building-a-password-hasher-in-node-js/testing-code-postman/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/09/testing-code-postman.png" data-orig-size="720,470" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Testing the register route via POSTMAN" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/09/testing-code-postman-300x196.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/09/testing-code-postman.png" decoding="async" loading="lazy" class="aligncenter size-full wp-image-24193" src="../Images/0bdb3eae9e13927ea7e0112f28e708d5.png" alt="Testing the register Route via POSTMAN" srcset="https://blog.logrocket.com/wp-content/uploads/2020/09/testing-code-postman.png 720w, https://blog.logrocket.com/wp-content/uploads/2020/09/testing-code-postman-300x196.png 300w" sizes="(max-width: 720px) 100vw, 720px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/09/testing-code-postman.png"/></noscript>
<p>在这里，我们将我们的<code>hashedpassword</code>和<code>salt</code>存储在数据库中。</p>
<p>接下来，实现登录路由。</p>
<pre> app.post('/login', async (req, res) =&gt; {
         try {
             let {
                 email,
                 password
             } = req.body;
             let user = await User.findOne({
                 email: email
             })
             if (!user) {
                 return res.status(400).json({
                     type: "Not Found",
                     msg: "Wrong Login Details"
                 })
             }
             let match = await compare(password, user.password);
             if (match) {
                 res.status(200).json({
                     status: "Success",
                     message: "Correct Details",
                     data: user
                 })
             }
         } catch (err) {
             // handle error
         }
     })
</pre>
<p>确保将其添加到<code>exports</code>对象中。移除<code>index.js</code>文件中比较函数中的<code>hash</code>对象。</p>
<pre>// hash = {
    //     salt: 'f844b09ff50c',
    //     hashedpassword: '2d2528d4534394d1e2702f53826d11c16ed4422f6bd466745cb4f1aa0e042b52b98fc5e65b86d73a6ce4807679b773fb955c4824b0471015354e1a872d42cb62'
    // }
</pre>
<p>在POSTMAN上测试您的代码将产生以下结果。</p>
<p><img data-attachment-id="24193" data-permalink="https://blog.logrocket.com/building-a-password-hasher-in-node-js/testing-code-postman/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/09/testing-code-postman.png" data-orig-size="720,470" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Testing the register route via POSTMAN" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/09/testing-code-postman-300x196.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/09/testing-code-postman.png" decoding="async" class="aligncenter size-full wp-image-24193 jetpack-lazy-image" src="../Images/0bdb3eae9e13927ea7e0112f28e708d5.png" alt="Testing the register Route via POSTMAN" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2020/09/testing-code-postman.png 720w, https://blog.logrocket.com/wp-content/uploads/2020/09/testing-code-postman-300x196.png 300w" data-lazy-sizes="(max-width: 720px) 100vw, 720px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2020/09/testing-code-postman.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/09/testing-code-postman.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="24193" data-permalink="https://blog.logrocket.com/building-a-password-hasher-in-node-js/testing-code-postman/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/09/testing-code-postman.png" data-orig-size="720,470" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Testing the register route via POSTMAN" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/09/testing-code-postman-300x196.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/09/testing-code-postman.png" decoding="async" loading="lazy" class="aligncenter size-full wp-image-24193" src="../Images/0bdb3eae9e13927ea7e0112f28e708d5.png" alt="Testing the register Route via POSTMAN" srcset="https://blog.logrocket.com/wp-content/uploads/2020/09/testing-code-postman.png 720w, https://blog.logrocket.com/wp-content/uploads/2020/09/testing-code-postman-300x196.png 300w" sizes="(max-width: 720px) 100vw, 720px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/09/testing-code-postman.png"/></noscript>
<p>我们的密码哈希器工作正常！</p>
<h2 id="conclusion">结论</h2>
<p>在本指南中，我们演示了salting如何在Node.js crypto中工作。它仍然有一些缺陷，所以我不建议在生产中使用它。更好的工具，比如<code>Bcrypt</code>，更适合生产应用。</p>
<p>源代码可以在<a href="https://github.com/Wisdom132/nodehasher" target="_blank" rel="noopener noreferrer"> GitHub </a>上获得。</p><div class="code-block code-block-23">
<div class="blog-plug inline-plug node-plug"><h2>200只<img src="../Images/61167b9d027ca73ed5aaf59a9ec31267.png" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2019/10/green-check.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" class=" jetpack-lazy-image" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/10/green-check.png"/> <noscript> <img data-lazy-fallback="1" src="../Images/61167b9d027ca73ed5aaf59a9ec31267.png" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/10/green-check.png"/> </noscript>显示器出现故障，生产中网络请求缓慢</h2><p>部署基于节点的web应用程序或网站是容易的部分。确保您的节点实例继续为您的应用程序提供资源是事情变得更加困难的地方。如果您对确保对后端或第三方服务的请求成功感兴趣，</p><a href="https://lp.logrocket.com/blg/node-signup" target="_blank">try LogRocket</a><p>. </p><a class="signup" href="https://lp.logrocket.com/blg/node-signup" target="_blank" rel="noopener noreferrer"><img src="../Images/cae72fd2a54c5f02a6398c4867894844.png" alt="LogRocket Network Request Monitoring" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2019/12/network-request-filter-2-1.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" class=" jetpack-lazy-image" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/12/network-request-filter-2-1.png"/><noscript><img data-lazy-fallback="1" src="../Images/cae72fd2a54c5f02a6398c4867894844.png" alt="LogRocket Network Request Monitoring" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/12/network-request-filter-2-1.png"/></noscript></a><a href="https://lp.logrocket.com/blg/node-signup" target="_blank" rel="noopener noreferrer">https://logrocket.com/signup/</a><p>LogRocket 就像是网络和移动应用程序的DVR，记录下用户与你的应用程序交互时发生的一切。您可以汇总并报告有问题的网络请求，以快速了解根本原因，而不是猜测问题发生的原因。</p><p>LogRocket检测您的应用程序以记录基线性能计时，如页面加载时间、到达第一个字节的时间、慢速网络请求，还记录Redux、NgRx和Vuex操作/状态。</p><a class="signup" href="https://lp.logrocket.com/blg/node-signup" target="_blank" rel="noopener noreferrer">Start monitoring for free</a><p>. </p></div>
</div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
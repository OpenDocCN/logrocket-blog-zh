<html>
<head>
<title>Switching to Parcel from webpack - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>从webpack切换到包裹- LogRocket博客</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/switching-to-parcel-from-webpack/#0001-01-01">https://blog.logrocket.com/switching-to-parcel-from-webpack/#0001-01-01</a></blockquote><div><article class="article-post">
<p>在过去的一年中，您可能已经听说了一种叫做Parcel的新构建工具。</p>
<p>对于那些不知道的人来说，Parcel将自己描述为<em>“一个web应用捆绑商，以其开发者经验而与众不同。它利用多核处理提供极快的性能，并且不需要任何配置。</em></p>
<p>现在构建工具来了又去，webpack和Browserify等工具仍在使用，那么为什么我们需要一个新的工具，为什么我要花时间写关于package的文章呢？</p>
<h2 id="because-webpack-is-great-but-it-s-not-beginner-friendly-">因为webpack很棒，但它对初学者并不友好</h2>
<p>一开始，我不得不说，我认为webpack有很多很棒的用例，在web开发中肯定有它的位置。但是尽管webpack帮助简化了web开发过程，但它需要大量的初始设置。</p>
<p>大多数web开发人员通常只需要一个处理萨斯/SCSS、CSS供应商前缀、巴别塔和代码精简器的设置。我们可能还希望在每个文件名的末尾添加散列，从而破坏缓存。哦，如果我们的构建工具也知道如何在开发过程中构建一个实时服务器，那么我会给你一些加分！</p>
<p>因此，即使大多数开发设置将总是(并且仅仅)使用前面提到的，当使用webpack时，我们总是必须设置它。这是包裹进入虚拟水的地方。</p>
<h2 id="the-setup">设置</h2>
<p>为了演示这一点，我们将采用一个典型的webpack设置，它具有前面提到的所有插件，然后将其替换为package。</p>
<p>准备好了吗？</p>
<p>让我们看一下我们的<code>webpack.config.js</code>文件，看看我们到底要转换什么:</p>
<pre>module.exports = {
  entry: { main: './src/js/main.js' },
  output: {
    path: path.resolve(__dirname, 'dist'),
    filename: '[name].[chunkhash].js'
  },
  module: {
    rules: [
      {
        test: /\.js$/,
        exclude: /node_modules/,
        use: {
          loader: "babel-loader"
        }
      },
      {
        test: /\.s[c|a]ss$/,
        use: ['style-loader', MiniCssExtractPlugin.loader, 'css-loader', 'postcss-loader', 'sass-loader']
      }
    ]
  },
  plugins: [
    new CleanWebpackPlugin('dist', {}),
    new MiniCssExtractPlugin({
      filename: 'style.[contenthash].css',
    }),
    new HtmlWebpackPlugin({
      inject: false,
      hash: true,
      template: './src/html/index.html',
      filename: 'index.html'
    }),
    new WebpackMd5Hash()
  ]
};</pre>
<p>为了完成这个设置，除了安装<code>webpack</code>和<code>webpack-cli</code>之外，我还必须安装以下依赖项:<code>autoprefixer</code>、<code>babel-core</code>、<code>babel-loader, babel-preset-env</code>、<code>clean-webpack-plugin</code>、<code>css-loader</code>、<code>extract-text-webpack-plugin</code>、<code>html-webpack-plugin</code>、<code>mini-css-extract-plugin</code>、<code>node-sass</code>、<code>postcss-loader</code>、<code>sass-loader</code>、<code>style-loader</code>和<code>webpack-md5-hash</code>。我还需要建立一个<code>postcss.config.js</code>文件，以便供应商前缀能够工作。</p>
<p>正如你所看到的，对于2018年的开发者来说，获得通常相当正常的设置涉及到相当多的配置。</p>
<h2 id="the-switch">开关</h2>
<p>简单回顾一下，为了与我们的webpack设置保持一致，我们希望我们的包裹设置能够处理以下事情:</p>
<ul>
<li>萨斯Sass</li>
<li>巴别塔；</li>
<li>供应商前缀；</li>
<li>代码精简；</li>
<li>缓存破坏/散列；</li>
<li>现场服务器搅打。</li>
</ul>
<p>那么，我们如何用Parcel实现完全相同的设置呢？</p>
<p>首先，我们必须通过在终端中运行下面的命令来安装包:<code>npm install -g parcel-bundler</code>。你会注意到我已经在全球范围内安装了它；这使我们可以运行parcel命令，而无需包含整个文件路径。</p>
<p>如果您愿意，您可以选择省略<code>-g</code>并将它安装在项目内部。我发现当我尝试使用本地版本时，我不得不在终端中运行确切的文件路径，因为输入<code>parcel</code>根本不起作用。相反，我不得不在终端运行<code>node node_modules/parcel-bundler/bin/cli.js</code>。</p>
<p>然后，我创建了一个初始项目结构，如下所示:</p>
<p><em>/距离</em></p>
<p><em> /src/js/script.js </em></p>
<p><em>/src/SCS/styles . SCS</em></p>
<p><em>Index.html</em></p>
<p>我进入项目根目录，在终端中运行<code>npm init -y</code>，以便创建一个<code>package.json</code>文件。</p>
<p>我在<code>script.js</code>和<code>styles.scss</code>中放了一些初始代码作为测试代码。没什么特别的:我在<code>script.js</code>创建了一个const，看看它是否会被编译成var，并写了一些非常基本的嵌套SCSS代码，看看它是否会被编译成CSS。</p>
<p>因此，关于Parcel的奇妙之处在于，它将简单地查看您在<code>index.html</code>中拥有的任何脚本标签，并将传输它找到的代码。</p><div class="code-block code-block-54">
<hr/>
<h3>更多来自LogRocket的精彩文章:</h3>

<hr/></div>
<p>所以在我们的例子中，我在我的<code>index.html</code>中有如下内容:</p>
<pre>&lt;html&gt;
  &lt;body&gt;
    &lt;h1&gt;Hello, Parcel!&lt;/h1&gt;
    &lt;script src="src/js/script.js"&gt;&lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;</pre>
<p>然后我从终端运行<code>parcel index.html</code>，几秒钟后，Parcel已经将一些文件编译到了<code>/dist</code>目录中，并在端口1234启动了一个本地服务器。我打开浏览器，进入<code>localhost:1234</code>，我的代码就在那里！我检查了编译后的脚本文件(它也有一个哈希后缀来处理缓存破坏),可以看到const确实被转换成了var。</p>
<p>所以在我不需要配置任何东西的情况下，Parcel已经整理出了一个本地服务器，使用Babel将ES6代码向下传输到ES5，甚至负责文件散列！我也不必写任何特殊的东西来告诉Parcel输入和输出文件在哪里。这是非常甜蜜的！</p>
<p>后来我甚至发现，我们可以让Parcel打开您的默认浏览器并加载页面，只需在您的命令末尾添加<code>-open</code>(因此我们将改为运行<code>parcel index.html -open</code>)。</p>
<h2 id="but-wait-a-second-where-s-my-css-file">但是等一下，我的CSS文件呢？</h2>
<p>嗯，我还没有引用过它，所以我想我们需要解决这个问题。</p>
<p>所以我必须安装<code>node-sass</code>才能让它工作。我在候机厅跑了<code>npm install node-sass</code>。然后，我在我的<code>script.js</code>文件的顶部添加了<code>import '../scss/styles.scss'</code>，运行<code>parcel index.html</code>，令我惊讶的是，package把一切都整理好了。</p>
<p>我在我的dist文件夹中有一个单独的文件，用于HTML、CSS和JS——它也用了package 2.28s来编译一切，这相当快！在dist版本的<code>index.html</code>中，Parcel甚至在CSS文件中添加了一个链接标签，在最初的src版本中，我甚至都懒得对其进行排序！</p>
<p>我还应该注意到，据我所知，导入也可以使用普通的旧CSS，所以如果我没有使用SCSS，我可以导入普通的CSS并跳过<code>node-sass</code>的npm安装。</p>
<h2 id="okay-but-what-about-adding-vendor-prefixes">好吧，但是添加供应商前缀呢？</h2>
<p>我在我的SCSS中添加了一个<code>::placeholder</code>标签，看看会发生什么，但是编译的CSS代码不包含任何前缀。原来这是Parcel在其设置中包含的另一个东西！我们所要做的就是在我们项目的根目录下包含一个<code>.postcssrc</code>文件(在我们的<code>index.html</code>文件旁边),并在其中包含以下内容:</p>
<pre>{
    "plugins": {
        "autoprefixer": true
    }
}</pre>
<p>我再次运行包<code>index.html</code>，检查输出的CSS文件，它现在有一堆厂商前缀样式用于<code>::placeholder</code>——哇！</p>
<p>在这一点上，您可能想知道package如何在没有<code>.babelrc</code>文件的情况下使用Babel，因为我们需要一个<code>.postcssrc</code>文件来处理供应商前缀。事实证明，Parcel是为Babel预先配置的，可以为市场份额超过1%的浏览器编译代码。所以，如果你想找一个更小众的目标，你只需要一个<code>.babelrc</code>文件。</p>
<h2 id="okay-so-the-final-test-here-is-code-minification-">好了，这里的最后一个测试是代码缩减</h2>
<p>到目前为止，我的代码还没有被精简，我想这是意料之中的，因为我还在开发环境中。让我们看看运行<code>parcel build index.html</code>会发生什么。</p>
<p>不会吧！HTML缩小了，CSS缩小了，JS缩小了！一切都被缩小了！</p>
<p>因此，令人惊讶的是，package已经处理了我们的webpack设置所处理的一切，并且只需要两部分配置:</p>
<ol>
<li><code>npm install node-sass</code></li>
<li>一个<code>.postcssrc</code>文件</li>
</ol>
<p>对我来说，这是一个不可思议的壮举，并且我可以看到这对于希望使用现代工具的新开发人员和想要快速设置或者已经厌倦了webpack的复杂性的有经验的开发人员来说是非常有用的。</p>
<h2 id="conclusion">结论</h2>
<p>我喜欢包裹的功能。这感觉像是一个超级接近于零的配置设置，这对于加速开发过程来说是非常棒的，因为它让我专注于构建东西而不是配置设置。</p>
<p>它做我需要它做的一切，没有头痛。</p>
<p>在编译上也比webpack快很多！<em>我应该指出，我确实注意到我的2015款Macbook Air上的风扇不时发出声音，我只能想象这是由于使用多核处理的包裹——所以它比webpack构建得更快，但需要你的计算机做更多的工作。</em></p>
<p>我想澄清的一件事是，这种“零配置”的想法总的来说有点误导。整个“零配置”概念的大部分只是简单地归结为在设置中抽象掉了多少东西。</p>
<p>默认情况下，webpack试图尽可能地扩展，而默认情况下，Parcel提供了许多最常用的特性。这对我们大多数人来说都是轻而易举的事。令人惊讶的是，这甚至是可能的，但我只是想阐明这一点，因为我认为理解我们正在使用的工具正在为我们做什么是超级重要的。</p>
<p>最后，你一定要给帕奇一个机会。但是现在还不要排除webpack，如果你发现自己需要一个更少人走的路，它可能就是你的路线。</p><div class="code-block code-block-25">
<div class="blog-plug inline-plug css-plug"><h2>你的前端是否占用了用户的CPU？</h2><p>随着web前端变得越来越复杂，资源贪婪的特性对浏览器的要求越来越高。如果您对监控和跟踪生产环境中所有用户的客户端CPU使用、内存使用等感兴趣，</p><a target="_blank" href="https://lp.logrocket.com/blg/css-signup">try LogRocket</a><p>.</p><a class="signup" href="https://lp.logrocket.com/blg/css-signup" target="_blank" rel="noopener noreferrer"><img class="alignnone size-full wp-image-46 jetpack-lazy-image" src="../Images/dacb06c713aec161ffeaffae5bd048cd.png" alt="LogRocket Dashboard Free Trial Banner" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2019/12/cpu-memory-usage.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/12/cpu-memory-usage.png"/><noscript><img data-lazy-fallback="1" class="alignnone size-full wp-image-46" src="../Images/dacb06c713aec161ffeaffae5bd048cd.png" alt="LogRocket Dashboard Free Trial Banner" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/12/cpu-memory-usage.png"/></noscript></a><a href="https://lp.logrocket.com/blg/css-signup" target="_blank" rel="noopener noreferrer">https://logrocket.com/signup/</a><p>LogRocket 就像是网络和移动应用的DVR，记录你的网络应用或网站上发生的一切。您可以汇总和报告关键的前端性能指标，重放用户会话和应用程序状态，记录网络请求，并自动显示所有错误，而不是猜测问题发生的原因。</p><p>现代化您调试web和移动应用的方式— <a class="signup" href="https://lp.logrocket.com/blg/css-signup" target="_blank" rel="noopener noreferrer">开始免费监控</a>。</p></div>
</div>
<hr/>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
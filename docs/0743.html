<html>
<head>
<title>The single-page application must die - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>单页应用程序必须死-日志火箭博客</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/the-single-page-application-must-die/#0001-01-01">https://blog.logrocket.com/the-single-page-application-must-die/#0001-01-01</a></blockquote><div><article class="article-post">
<p><em>免责声明</em>这里的观点很大程度上是我自己的，而不是LogRocket的观点。</p>
<p>另一个免责声明是，在过去的十年里，我几乎只从事各种各样的单页应用程序。</p>
<h2>SPA之旅(单页应用程序)</h2>
<p>单页应用程序的一个可能定义是:</p>
<blockquote><p>单页应用程序是只需要在web浏览器中加载一个页面的web应用程序。</p></blockquote>
<p>我对单页应用程序的定义是任何只依赖客户端渲染(CSR)的应用程序。</p>
<p>对高度交互式用户界面(UI)的日益渴求导致越来越多的JavaScript代码被推送到浏览器。Javascript MV*框架是从杂乱无章的代码库中发展出来的，旨在拨乱反正。</p>
<p><a href="https://backbonejs.org/" target="_blank" rel="noopener noreferrer"> Backbone.js </a>是第一个JavaScript MV*框架，它打开了通往地狱的闸门，让大量的JavaScript被发送到浏览器并被浏览器解析。这导致浏览器中运行的JavaScript从REST API调用的JSON响应而不是服务器呈现动态HTML。臭名昭著的loading spinner现在从原始沼泽中脱颖而出，在web开发的历史时间线上占据了一席之地。</p>
<p>紧跟在Backbone.js之后的是街区新成员<a href="https://emberjs.com/" target="_blank" rel="noopener noreferrer"> EmberJS </a>、<a href="https://angularjs.org/" target="_blank" rel="noopener noreferrer"> AngularJS </a>和当前的热门人物<a href="https://reactjs.org/" target="_blank" rel="noopener noreferrer"> React </a>。今天，使用JavaScript MV*框架可能比不使用更常见，因为我们希望我们的web应用程序像它们的桌面应用程序一样运行。</p>
<p>我不打算列出通常对SPA(单页应用程序)的抱怨，包括SEO、性能问题和代码复杂性。我相信这些问题有可行的解决方案，比如为网络爬虫提供不同的内容，为性能问题进行代码分割。</p>
<h2>渐进增强是平衬</h2>
<blockquote><p>构建适合每个人的网络</p></blockquote>
<p>我对单页面应用程序的主要问题是，它们通常不会使用<a href="https://www.gov.uk/service-manual/technology/using-progressive-enhancement" target="_blank" rel="noopener noreferrer">渐进增强</a>开始使用。</p>
<p>渐进增强曾经是阿杜流行的概念，但SPA的兴起使其停滞不前，因为开发人员更愿意处理只有现代浏览器才允许的崭新而闪亮的世界。发展中国家网速慢的用户或者某些辅助技术的用户怎么办？我们睁一只眼闭一只眼，以确保我们的简历保持相关性。</p>
<p>如果您使用React、Angular、Ember或其他什么工具中的CLI工具创建一个新的SPA，那么您是在假设您正在处理一个乌托邦世界。该代码预计将运行在一个现代化的浏览器上，该浏览器运行在一个高速网络上，具有各种功能。</p>
<p>渐进增强的广义定义是:</p>
<blockquote><p>渐进式改进是一种网页设计策略，首先强调核心网页内容。然后，在最终用户的浏览器/互联网连接允许的情况下，这种策略会在内容之上逐步添加更细致、技术上更严格的呈现层和功能。—维基百科</p></blockquote>
<p>这意味着我们从最小的分母开始，并添加JavaScript等增强功能，而不是从一个前提开始，即<a href="https://developer.mozilla.org/en-US/docs/Web/API/Service_Worker_API" target="_blank" rel="noopener noreferrer">服务工作者</a>将充当代理并缓存内容以供重复访问。</p>
<p>如果我们想要更广泛的浏览器和设备网络，那么我们需要确保我们第一次访问一个站点时，第一个页面请求是服务器呈现的，最好是来自同构的web应用程序。</p>
<p>如果我们采用这种方法，那么我们的网站可以在禁用JavaScript的情况下工作，这是渐进增强的圣杯。</p>
<p>我们还应该使用与渐进式web应用程序(PWA)相关的技术，稍后会详细介绍。</p>
<h2>React应用程序中的服务器端呈现(SSR)与客户端呈现(CSR)</h2>
<p>我将使用React作为示例框架来概述这两种类型的呈现之间的差异。</p>
<p>主要区别在于，对于服务器端呈现(SSR ),服务器对浏览器的响应是准备好呈现的页面的HTML，而对于客户端呈现(CSR ),浏览器得到的是一个相当空的文档，其中包含指向JavaScript和CSS的链接。</p>
<p>在这两种情况下，React都需要下载，并经历构建虚拟DOM和附加事件以使页面交互的相同过程——但对于SSR，用户可以在所有这些发生的同时开始查看页面。对于CSR世界，您需要等待上述所有情况发生，然后将虚拟DOM移动到浏览器DOM，以便页面可见。</p>
<p>服务器端渲染的性能优势被夸大了，并被歪曲成事实，就像一个政客在被揭露时使用的一样。</p>
<h2>单页应用程序和渐进式web应用程序</h2>
<p>PWA是一个web应用程序，它使用现代web功能向用户提供类似应用程序的体验。前面的定义是一个非常空泛的解释，但我认为任何申请要成为PWA，都必须满足以下三个标准:</p>
<ul>
<li>使用HTTPS服务(安全)</li>
<li>拥有一个包含最少图标的有效web清单文件</li>
<li>向获取事件处理程序注册一个服务工作器，并提供最低限度的脱机支持</li>
</ul>
<h2>应用程序外壳模型</h2>
<p>出于某种原因，许多人认为渐进式网络应用程序(PWA)是单页应用程序(SPA ),因为他们经常使用谷歌推广的<a href="https://developers.google.com/web/fundamentals/architecture/app-shell" target="_blank" rel="noopener noreferrer">应用程序外壳模型</a>。</p>
<p>应用程序的外壳在<em>应用程序外壳模型的上下文中</em>是为渐进式web应用程序的用户界面提供动力所需的最少的HTML、CSS和JavaScript，并且是确保可靠的良好性能的组件之一。</p>
<pre>&lt;!doctype html&gt;
&lt;html lang="en"&gt;

&lt;head&gt;
  &lt;meta charset="utf-8"&gt;
  &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;
  &lt;meta name="theme-color" content="#000000"&gt;
  &lt;link rel="shortcut icon" href="/favicon.ico"&gt;
  &lt;title&gt;My PWA&lt;/title&gt;
&lt;/head&gt;

&lt;body&gt;
  &lt;div id="root"&gt;&lt;/div&gt;
&lt;/body&gt;

&lt;/html&gt;</pre>
<p>第一次加载应该很快，并立即缓存。<strong>缓存</strong>意味着shell文件通过网络加载一次，然后保存到本地设备。用户随后每次打开应用程序时，shell文件都会从本地设备的缓存中加载，这导致启动速度极快。</p>
<p>如果你用<a href="https://github.com/facebook/create-react-app" target="_blank" rel="noopener noreferrer"> create-react-app </a>创建一个新的应用程序，那么<a href="https://github.com/GoogleChrome/workbox" target="_blank" rel="noopener noreferrer"> workbox npm包</a>也会被安装，它是一个渐进式web应用程序的库集合。workbox生成的index.html是一个基本的HTML文件，其中包含webpack在构建时添加的JavaScript脚本标签和CSS链接标签。</p>
<p>这种方法依赖于主动缓存shell(使用<a href="https://developers.google.com/web/fundamentals/primers/service-workers" target="_blank" rel="noopener noreferrer">服务工作者</a>让应用程序运行。接下来，使用JavaScript为每个页面加载动态内容。一个应用程序外壳模型导致极快的重复访问和类似本机的交互。</p>
<p>由<code>create-react-app</code>生成的代码仅由客户端渲染。没有服务器为第一次加载生成完整的HTML请求。我们期待代码运行在具有现代功能的现代浏览器上。这个世界没有进步的想法。</p><div class="code-block code-block-54">
<hr/>
<h3>更多来自LogRocket的精彩文章:</h3>

<hr/></div>
<h2>混合方法将渐进式增强添加到渐进式web应用程序中</h2>
<p>这两种方法都有一定的优势，所以最佳方法是利用两者的优势。</p>
<p>如果您恰当地使用了服务器端呈现，那么服务器最初应该用一个完整的HTML文档来响应任何导航请求，其中包含特定于所请求的URL的内容，而不是一个简单的应用程序外壳。</p>
<p>不支持服务工作者的浏览器可以继续向服务器发送导航请求，服务器可以继续用完整的HTML文档响应它们。</p>
<p>下面是一个渲染函数，我用它来服务器渲染React组件。我正在使用<a href="https://loadable-components.com/" target="_blank" rel="noopener noreferrer">可加载组件</a> <code>ChunkExtractor</code>来加载足够的JavaScript和CSS，用于使用代码分割的特定URL。</p>
<pre>export async function render({ req, res }: RendererOptions): Promise&lt;void&gt; {
  const extractor = new ChunkExtractor({
    entrypoints: ['client'],
    statsFile,
  });

  const context: StaticRouterContext = {};

  const html = renderToString(
    extractor.collectChunks(
      &lt;StaticRouter location={req.url} context={context}&gt;
        &lt;Routes /&gt;
      &lt;/StaticRouter&gt;,
    ),
  );

  res.status(HttpStatusCode.Ok).send(`
    &lt;!doctype html&gt;
    &lt;html lang="en"&gt;
      &lt;head&gt;
        &lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8"&gt;
        &lt;meta httpEquiv="X-UA-Compatible" content="IE=edge" /&gt;
        &lt;meta charSet="utf-8" /&gt;
        &lt;meta name="viewport" content="width=device-width, initial-scale=1" /&gt;
        ${extractor.getStyleTags()}   
      &lt;/head&gt;
      &lt;body&gt;
        &lt;div id="root"&gt;${html}&lt;/div&gt;
        ${extractor.getScriptTags()}
      &lt;/body&gt;
    &lt;/html&gt;
`);
}</pre>
<p>在第一次加载时，会呈现一个完整的HTML文档，即使禁用了JavaScript，它仍然可以工作。</p>
<p>一旦第一次加载完成，<a href="https://reacttraining.com/react-router/web/guides/quick-start" target="_blank" rel="noopener noreferrer"> react-router的浏览器路由器</a>接管导航的控制，并有效地触发客户端渲染。</p>
<pre>import React from 'react';
import { Routes } from '../../routes';
import { BrowserRouter } from 'react-router-dom';

export const App: React.FC = () =&gt; (
  &lt;BrowserRouter&gt;
    &lt;Routes /&gt;
  &lt;/BrowserRouter&gt;
);</pre>
<h2>服务人员呢？</h2>
<p>这种加载内容的方法使用的混合策略不依赖于服务人员，因此即使不支持服务人员的浏览器也可以从实现中受益。</p>
<p>对于支持服务人员的浏览器，我们仍然可以利用应用程序外壳模型。每当用户触发应用程序内部的导航时，服务工作人员拦截fetch事件上的请求，并将响应添加到<a href="https://developer.mozilla.org/en-US/docs/Web/API/Cache" target="_blank" rel="noopener noreferrer">缓存</a>。下一次导航到同一个URL被触发时，服务人员可以从缓存中加载内容并立即交付，而无需通过网络。</p>
<p>服务人员为所有导航请求返回相同的应用程序外壳HTML文档。</p>
<h2>服务人员实施</h2>
<p>为了让应用程序外壳工作，我们需要让服务人员缓存一个通用的应用程序外壳HTML文件。我们可以在服务器上配置一个类似<code>/app-shell</code>的特殊路径来返回一个骨架HTML文件，让服务工人在安装服务工人的时候取回来。</p>
<p>我使用webpack和<a href="https://developers.google.com/web/tools/workbox/modules/workbox-webpack-plugin" target="_blank" rel="noopener noreferrer"> workbox-webpack-plugin </a>来生成服务工作者配置文件。</p>
<p>下面是一个服务人员模板文件的缩小版本。</p>
<pre>self.__precacheManifest = [].concat(self.__precacheManifest || []);
 
// active new service worker as long as it's installed
workbox.clientsClaim();
workbox.skipWaiting();
 
// suppress warnings if revision is not provided
workbox.precaching.suppressWarnings();
 
// precahce and route asserts built by webpack
workbox.precaching.precacheAndRoute(self.__precacheManifest, {});
 
// return app shell for all navigation requests
workbox.routing.registerNavigationRoute('/app-shell');</pre>
<p>在上面的代码中，<code>self.__precacheManifest</code>变量存储了所有需要预缓存的URL。</p>
<p>对<code>workbox.precaching.precacheAndRoute()</code>的调用告诉服务工作者在其安装过程中获取并缓存所有这些URL，并使用缓存的版本来服务所有未来匹配的请求。</p>
<p><code>workbox.routing.registerNavigationRoute('/app-shell');</code>指示服务人员，每当有新URL的导航请求时，不返回该URL的HTML，而是返回以前缓存的shell HTML文件。</p>
<p>我们所需要的只是在我们的express应用程序中返回应用程序外壳框架的路径:</p>
<pre>app.use('/app-shell', (req, res) =&gt; {
  res.status(HttpStatusCode.Ok).send(`
    &lt;!doctype html&gt;
    &lt;html lang="en"&gt;
      &lt;head&gt;
        &lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8"&gt;
        &lt;meta httpEquiv="X-UA-Compatible" content="IE=edge" /&gt;
        &lt;meta charSet="utf-8" /&gt;
        &lt;meta name="viewport" content="width=device-width, initial-scale=1" /&gt;
      &lt;!-- css link tags --&gt;
      &lt;/head&gt;
      &lt;body&gt;
        &lt;div id="root"&gt;&lt;/div&gt;
       &lt;!-- js script tags --&gt;
      &lt;/body&gt;
    &lt;/html&gt;
  `);
});</pre>
<p>令我惊讶的是，这种模式并不普遍。我认为这是开创性的。</p>
<h2>收场白</h2>
<p>单页应用程序让渐进式改进退居二线。JAMstack和其他类似的框架对渐进式增强视而不见，对我来说这是一种倒退。我们将旧设备视为向后兼容。网络经常被吹捧为人人共享，但在这个世界上并非如此。</p>
<p>遵循应用程序外壳模型的渐进式网络应用程序速度极快，但前提是你使用的浏览器支持服务人员。使用从同构的JavaScript应用程序呈现完整的HTML文档，然后让服务人员介入，这是我们应该努力的方向。我们还没有进入乌托邦，但我们可以给境况不佳的进步增强运动注入一些活力。</p><div class="code-block code-block-2">
<div class="blog-plug base-cta"><h2>使用<a class="signup" href="https://lp.logrocket.com/blg/signup" target="_blank" rel="noopener noreferrer"> LogRocket </a>消除传统错误报告的干扰</h2>
<a href="https://lp.logrocket.com/blg/signup" class="signup" target="_blank" rel="noopener noreferrer"><img class="alignnone size-full wp-image-46 jetpack-lazy-image" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/><noscript><img data-lazy-fallback="1" class="alignnone size-full wp-image-46" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/></noscript></a>
<p><a href="https://lp.logrocket.com/blg/signup" target="_blank" rel="noopener noreferrer"> LogRocket </a>是一个数字体验分析解决方案，它可以保护您免受数百个假阳性错误警报的影响，只针对几个真正重要的项目。LogRocket会告诉您应用程序中实际影响用户的最具影响力的bug和UX问题。</p>
<p>然后，使用具有深层技术遥测的会话重放来确切地查看用户看到了什么以及是什么导致了问题，就像你在他们身后看一样。</p>
<p>LogRocket自动聚合客户端错误、JS异常、前端性能指标和用户交互。然后LogRocket使用机器学习来告诉你哪些问题正在影响大多数用户，并提供你需要修复它的上下文。</p>
<p>关注重要的bug—<a class="signup" href="https://lp.logrocket.com/blg/signup-issue-free" target="_blank" rel="noopener noreferrer">今天就试试LogRocket】。</a></p></div></div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
<html>
<head>
<title>Testing React applications in 2019 - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>2019年测试React应用- LogRocket博客</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/testing-react-applications-in-2019/#0001-01-01">https://blog.logrocket.com/testing-react-applications-in-2019/#0001-01-01</a></blockquote><div><article class="article-post">
<p>测试是软件开发中一个非常有争议的概念。虽然很难让每个人都同意进行测试的最佳方式或最佳工具，甚至是测试的优先级别，但我们都同意这是任何产品的一个非常重要的方面，并且应该这样对待。</p>
<p>在本帖中，我们将仔细看看测试React应用程序的一些最佳方法。我们将在这里解释的概念显然适用于其他JavaScript框架，如Vue，甚至其他语言。然而，为了精确起见，我们将在<a href="https://reactjs.org" target="_blank" rel="noopener noreferrer"> React </a>中进行演示。</p>
<p>在我们开始之前，值得注意的是这篇文章并不是对测试的全面介绍。它对您应该在React中进行测试的方式有更大的启发(如果您还没有的话)。</p>
<h2>先决条件</h2>
<p>在我们进一步讨论之前，本文假设:</p>
<ul>
<li><a href="https://nodejs.org/" target="_blank" rel="noopener noreferrer"> Node.js ≥v6 </a>安装在您的机器上</li>
<li>您的机器上安装了npm </li>
<li>您机器上安装的React版本16.8或更高版本</li>
<li>安装在您机器上的<a href="https://www.npmjs.com/package/create-react-app" target="_blank" rel="noopener noreferrer"> Create-react-app </a></li>
<li>你对<a href="https://reactjs.org" target="_blank" rel="noopener noreferrer">反应</a>有一个基本的了解</li>
</ul>
<h2>一般测试概念</h2>
<p>如果你对<a href="https://blog.logrocket.com/experimental-node-js-testing-the-new-performance-hooks-31fcdd2a747e/" target="_blank" rel="noopener noreferrer">测试</a>的概念完全陌生，可以这样想——测试是一种让你自动化应用程序活动的方式，而不必手动检查组件中的每个功能是否做了它应该做的事情。当然，这并不是测试的全部，但是它给了你一个开始的总体思路。</p>
<p>测试同样有助于代码审核。如果您有多个参与者在同一个项目上工作，测试可以帮助您为代码库的各个部分指定确切的功能。因此，检测系统中的问题并提供修复变得非常容易。</p>
<h2>JavaScript测试框架</h2>
<p>迄今为止，Jest仍然是最受欢迎的JavaScript框架，在Github上拥有超过27k颗星。它由脸书建造，并继续由脸书的Jest团队维护和支持。Jest是React推荐的零配置javascript测试框架，非常容易使用。它在2019年获得了超过900名贡献者的JavaScript社区的认可。</p>
<p>其他受欢迎的替代品是摩卡咖啡和T2茉莉。Mocha号称是使用最多的JavaScript测试框架。它在<a href="https://github.com/mochajs/mocha" target="_blank" rel="noopener noreferrer"> Github </a>上有超过18k颗星星。除了庞大的生态系统，Mocha还提供了完善的选项和大量的文档。它也非常灵活，可以进行很多扩展。</p>
<p>另一方面，Jasmine已经被证明是官方推荐的测试框架。它在Github 上有超过<a href="https://github.com/jasmine/jasmine" target="_blank" rel="noopener noreferrer"> 14k颗星星，也是拥有最多资源和社区支持的最古老的测试框架之一。甚至Jest也是建立在Jasmine之上的。</a></p>
<p>考虑到这些框架，值得注意的是没有明确的“最佳”框架。从长远来看，一切都取决于什么对你最有利。在本帖中，我们将使用Jest进行演示。</p>
<h2>配置Jest</h2>
<p>默认情况下，create-react-app带有这些配置。然而，为了灵活性和完整性，我们演示了如何为客户端手动配置带有<a href="https://webpack.js.org/" target="_blank" rel="noopener noreferrer"> webpack </a>的<a href="https://jestjs.io/" target="_blank" rel="noopener noreferrer"> Jest </a>。</p>
<p>步骤1:在您的项目目录<br/>上运行<code>npm install --save-dev jest</code>步骤2:在您的应用程序中的<code>package.json</code>文件中添加一个测试脚本:</p>
<pre>"script":{
  "test": "jest"
}</pre>
<p>第3步:接下来，我们必须设置<code>.babelrc.js</code>文件，因为我们在<code>package.json</code>中有一个指向它的预置。Jest会自动提取该文件，并将其应用到我们所有的测试中</p>
<pre>const isTest = String(process.env.NODE_ENV ) === 'test'
module.export = {
  presets: [['env', {modules: isTest ? 'commonjs' : false}], 'react'],
  plugins: [
  'syntax-dynamic-import',
  'transform-object-rest-spread',
],
}</pre>
<p>有了这个，<a href="https://blog.logrocket.com/choosing-between-babel-and-typescript-4ed1ad563e41/" target="_blank" rel="noopener noreferrer"> babel </a>现在可以识别出我们正在通过测试，然后将我们所有的ESmodules移植到CommonJS。</p>
<h2>测试React应用</h2>
<p>有许多方法可以测试React应用程序。我们将会看到其中的一些。</p>
<h3>单元测试反应组件</h3>
<p>单元测试包括独立测试软件的单个单元/组件，以验证其正确性。现在，我们如何在React应用程序中实现这一点呢？如果我们在一个<code>login.js</code>文件中有一个登录组件，如下所示:</p>
<pre>function Login({ onSubmit }) {
  return (
    &lt;div&gt;
      &lt;Form
        onSubmit={e =&gt; {
          e.preventDefault()
          const { username, password } = e.target.elements
          onSubmit({
            username: username.value,
            password: password.value,
          })
        }}
      &gt;
        &lt;label style={{ justifySelf: 'right' }} htmlFor="username-input"&gt;
          Username
        &lt;/label&gt;
        &lt;Input
          id="username-input"
          placeholder="Username..."
          name="username"
          style={{ flex: 1 }}
        /&gt;
        &lt;label style={{ justifySelf: 'right' }} id="password-input"&gt;
          Password
        &lt;/label&gt;
        &lt;Input
          placeholder="Password..."
          type="password"
          name="password"
          aria-labelledby="password-input"
        /&gt;
      &lt;/Form&gt;
    &lt;/div&gt;
  )
}</pre>
<p>上面的代码是一个简单的登录组件，我们将在一个<code>login.test.js</code>文件中进行测试。</p>
<pre>import React from 'react'
import ReactDOM from 'react-dom'
import Login from '../login'
  test('calls onSubmit with the username and password when submitted',() =&gt; {
    const handleSubmit = jest.fn()
    const container = document.createElement('div')
    const form = container.querySelector('form')
    const {username, password} = form.element 
    username.value = 'Kenny'
    passwords.value = 'pineapples'
    
    form.dispatchEvent(new window.event('submit'))
      expect(handleSubmit).toHaveBeenCalledTimes(1)
      expect(handleSubmit).toHaveBeenCalledWith({
        username: username.value,
        password: password.value, 
      })
  ReactDOM.render(&lt;Login onSubmit = {handleSubmit} /&gt;, container)
  })</pre>
<p>测试寻找一个<code>div</code>并将它传递给一个容器变量。然后从这个容器变量中，我们通过调用它的<code>querySelector('form')</code>来创建一个表单。</p>
<p>接下来，我们使用对象析构从<code>form.element</code>中获取字段。因为在提交事件上调用了<code>dispatchEvent()</code>，我们可以测试表单要做什么，或者当提交事件被触发时它应该有什么值。这表明事件应该触发一次，并且在触发时应该有用户名和密码。</p>
<pre>form.dispatchEvent(new window.event('submit'))
  expect(handleSubmit).toHaveBeenCalledTimes(1)
  expect(handleSubmit).toHaveBeenCalledWith({
  username: username.value,
  password: password.value, 
})
</pre>
<p>当然，我们可以用<code>npm run test</code>来运行测试。</p>
<h3>快照测试</h3>
<p>以前，我们能够测试一个特定的组件，以确保它们像预期的那样运行，但有一件事我们还没有做，那就是测试用户界面的结构。我们可以通过快照测试做到这一点。考虑下面的例子:</p>
<pre>render(){
  &lt;div&gt;
    &lt;p&gt; Current count: {this.state.count}&lt;/p&gt;
    &lt;button className = 'increment'
      onClick ={this.increment}&gt;
        + 
    &lt;/button&gt;
    &lt;button className = 'decrement'
      onClick ={this.decrement}&gt;
        -
    &lt;/button&gt;
  &lt;/div&gt;
}</pre>
<p>想象一下，如果一个组件有一个特定的格式，比如一个递增按钮在一个递减按钮之前，当这是真的时候测试通过。如果设计者改变了这种格式，实际上也就改变了呈现给DOM的格式。那么我们如何避免对DOM的渲染函数的意外更改呢？</p>
<p>快照测试帮助您在给定的时间获取组件的快照，并存储它之前在DOM上呈现的内容。因此，当您运行组件的测试时，Jest会让您知道您渲染的内容是否与它已经有的快照不同。您可以接受更改，也可以收到更改通知。</p>
<p>为了执行这个测试，我们将使用<code>react-test-renderer</code>表单，它将给出我们在特定时间的测试的JSON表示。然后，我们将使用Jest存储该数据:</p>
<pre>import React form 'react'
import Counter from './counter'
import {shallow} from 'enzyme'
import renderer from 'react-test-renderer'

describe('Counter component', () =&gt; {
it('matches the snapshot', () =&gt; {
  const tree = renderer.create(&lt; Counter/&gt;).toJson()
expect(tree).toMatchSnapshot()
})
it('start with a count of 0', () =&gt; {
  const wrapper =shallow(&lt;Counter/&gt;)
  const text = wwrapper.find('p').text()
  expect(tesxt).toEqual('Current count: 0')
})
it('can increment the count when the button is clicked', ()=&gt;{
const wrapper = shallow(&lt;Counter/&gt;)
}</pre>
<p>首先，我们得到一个将存储在Jest中的<code>counter</code>组件的JSON表示。<code>expect``()</code>方法将树作为一个参数，这就是导致与下一次重新渲染进行比较的原因。</p>
<h3>集成测试</h3>
<p>如前所述，集成测试是将单个单元作为一个组进行组合和测试。例如，如果我们有两个功能在一个上下文中一起工作，我们将使用一个集成测试来确保它们能够正确地相互交互。让我们考虑最简单的用例——在一个组件中将两个数字相加。</p>
<pre>export const add = (x,y)=&gt; x + y

export const total = (Tax,price) =&gt; {
  return "$" + add(Tax, price)
}</pre>
<p>然后在<code>app.test.js</code>中我们做:</p>
<pre>import {add,total} from './App' 

test('add', () =&gt; {
  expect(add(1,2)).toBe(3)
})

test('total', () =&gt;{
  expect(total(5,20)).toBe($25);
})</pre>
<h2>推荐的测试工具</h2>
<h3>反应测试库</h3>
<p>我个人认为这是测试React组件的一个很好的工具。它从用户的角度解决测试问题。它也非常有用，因为它处理特定的元素标签，而不是UI的组成。为了演示这个库是如何工作的，让我们重构之前使用这个库编写的单元测试。</p>
<pre>import React from 'react'
import ReactDOM from 'react-dom'
import {render,simulate} from 'react-testing-library'
import Login from '../login'

test('calls onSubmit with the username and password when submitted',() =&gt; {
const fakeuser = generate.loginForm
const handleSubmit = jest.fn()
const {container,getByLabelText, getByText} = render(&lt;login onSubmit= {handleSubmit}/&gt;)
const usernameNode = getByLabelText('username')
const passwordNode= getByLabelText('password')
const formNode = container.querySelector('form')
const submitButtonNode = getByText('submit')

</pre>
<p>在上面的例子中，我们通过获取与元素相关联的名称来更加关注测试元素，而不是被UI所困扰。这是使用该文库优于其他替代物如enzyme和cypress的主要优势。</p>
<h2>结论</h2>
<p>在这篇文章中，我们看了测试React应用程序的各种方法以及测试的重要性。我希望这篇文章能帮助你理解测试在React中的重要性，并向你展示如何进行测试。</p><div class="code-block code-block-17">
<div class="blog-plug inline-plug react-plug" vwo-el-id="26283398190">
<h2 vwo-el-id="41600691720">使用LogRocket消除传统反应错误报告的噪音</h2>
<a href="https://lp.logrocket.com/blg/react-signup-issue-free" target="_blank" vwo-el-id="19356441070">LogRocket
</a><p>是一款React analytics解决方案，可保护您免受数百个误报错误警报的影响，只针对少数真正重要的项目。LogRocket告诉您React应用程序中实际影响用户的最具影响力的bug和UX问题。</p><a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="19356441380">
<img class="first-react-image alignnone size-full wp-image-46 jetpack-lazy-image jetpack-lazy-image--handled" src="../Images/f300c244a1a1cf916df8b4cb02bec6c6.png" vwo-el-id="18272717540" data-lazy-loaded="1" data-original-src="https://files.readme.io/27c94e7-Image_2017-06-05_at_9.46.04_PM.png"/>
</a>
<a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="19356441690">
<img class="second-react-image alignnone size-full wp-image-46 jetpack-lazy-image jetpack-lazy-image--handled" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" vwo-el-id="30720362350" data-lazy-loaded="1" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/>
</a>
<a href="https://lp.logrocket.com/blg/react-signup-issue-free" target="_blank" rel="noopener noreferrer" vwo-el-id="35866400580">LogRocket
</a><p>自动聚合客户端错误、反应错误边界、还原状态、缓慢的组件加载时间、JS异常、前端性能指标和用户交互。然后，LogRocket使用机器学习来通知您影响大多数用户的最具影响力的问题，并提供您修复它所需的上下文。</p><p vwo-el-id="28675661060">关注重要的React bug—<a class="signup" href="https://lp.logrocket.com/blg/react-signup-issue-free" target="_blank" rel="noopener noreferrer" vwo-el-id="40093418840">今天就试试LogRocket】。</a></p>
</div></div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
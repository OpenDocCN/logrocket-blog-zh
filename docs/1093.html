<html>
<head>
<title>Template rendering in Rust - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>Rust - LogRocket博客中的模板渲染</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/template-rendering-in-rust/#0001-01-01">https://blog.logrocket.com/template-rendering-in-rust/#0001-01-01</a></blockquote><div><article class="article-post">
<p>在本教程中，我们将研究使用模板编写web应用程序的老派方法，所有的渲染都发生在服务器端。</p>
<p/>
<p>模板引擎的Rust生态系统惊人地强大，所以我们可以在几个viablew选项中进行选择。对于本教程，我选择使用<a href="https://github.com/djc/askama/" target="_blank" rel="noopener noreferrer"> Askama </a>，因为它似乎是最成熟的引擎之一。其他选项包括<a href="https://github.com/botika/yarte" target="_blank" rel="noopener noreferrer">亚尔特</a>、<a href="https://github.com/Keats/tera" target="_blank" rel="noopener noreferrer">特拉</a>和<a href="https://github.com/Kogia-sima/sailfish" target="_blank" rel="noopener noreferrer">旗鱼</a>等等。</p>
<p>Askama基于广泛使用的<a href="https://palletsprojects.com/p/jinja/" target="_blank" rel="noopener noreferrer"> Jinja </a>项目，所以如果你以前使用过它，语法会有些熟悉。</p>
<p>此外，Askama从你的模板中创建实际的Rust代码，这意味着模板在编译时被检查，渲染速度快如闪电。这是以能够在运行时动态更改和重新加载模板为代价的。我确信最终会有人实现一些巧妙的解决方法，但是在撰写本文的时候，它并不工作。</p>
<p>Askama的API很简单，而且基于Jinja，非常强大。</p>
<p>为了查看这个模板练习的效果，我们将使用warp web服务器和纯服务器端呈现的模板创建一个简单的具有CRUD功能的书店应用程序。</p>
<h2 id="setup">设置</h2>
<p>为了跟进，您需要一个相当新的Rust安装(1.39+)和一个web浏览器。</p>
<p>首先，创建一个新的Rust项目。</p>
<pre>cargo new rust-templating-example
cd rust-templating-example
</pre>
<p>接下来，编辑<code>Cargo.toml</code>文件并添加您需要的依赖项。</p>
<pre>tokio = { version = "0.2", features = ["macros", "rt-threaded"] }
warp = "0.2"
thiserror = "1.0"
askama = "0.8"
serde = {version = "1.0", features = ["derive"] }
chrono = { version = "0.4", features = ["serde"] }
uuid = { version = "0.8", features = ["serde", "v4"] }
</pre>
<p>我们需要warp和tokio用于web服务器，Serde用于反序列化传入的请求负载。如上所述，我们将使用Askama进行模板化，我们还将添加uuid、chrono和thiserror来分别处理唯一的id、日期和错误。</p>
<h2 id="datastorage">数据存储</h2>
<p>为了实现任何类似CRUD的功能，我们需要某种形式的数据存储。在这个简单的例子中，我们将选择共享的<code>Vec</code>书籍，其形式为:</p>
<pre>type DB = Arc&lt;RwLock&lt;Vec&lt;Book&gt;&gt;&gt;;
</pre>
<p>只需将书保存在一个共享的<code>Vec</code>中，它由一个读/写锁保护，并放入一个<code>Arc</code>智能指针，这样你就可以在线程之间传递它。稍后我们将看到如何访问和改变我们的非持久数据存储。</p>
<pre>let db = DB::default();
</pre>
<p>创建一个简单的扭曲过滤器，将其传递给处理程序。</p>
<pre>fn with_db(db: DB) -&gt; impl Filter&lt;Extract = (DB,), Error = Infallible&gt; + Clone {
    warp::any().map(move || db.clone())
}
</pre>
<p>接下来，我们来看看什么是<code>Book</code>。</p>
<pre>#[derive(Clone, Debug)]
pub struct Book {
    pub id: String,
    pub name: String,
    pub author: String,
    pub language: String,
    pub pages: i32,
    pub added_at: DateTime&lt;Utc&gt;,
}
</pre>
<p>我们还将为我们的变形处理程序定义一个有用的<code>WebResult</code>类型来减少输入。</p>
<pre>type WebResult&lt;T&gt; = std::result::Result&lt;T, Rejection&gt;;
</pre>
<p>基本设置完成后，让我们定义一个欢迎处理程序来迎接访问者。</p>
<p>这让我们开始创建我们的第一个模板。</p>
<pre>let welcome_route = warp::path::end().and_then(handler::welcome_handler);
</pre>
<h2 id="ourfirsttemplate">创建第一个模板</h2>
<p>在<code>handler</code>模块中，为您希望在欢迎页面上显示给用户的内容创建一个数据结构。</p>
<pre>use askama::Template;

#[derive(Template)]
#[template(path = "welcome.html")]
struct WelcomeTemplate&lt;'a&gt; {
    title: &amp;'a str,
    body: &amp;'a str,
}
</pre>
<p>在这种情况下，我们将限制自己使用两个硬编码的字符串作为页面的标题和正文。</p>
<p>接下来，让我们看看<code>welcome.html</code>文件，默认情况下，它位于<code>./templates/</code>文件夹中。</p><div class="code-block code-block-54">
<hr/>
<h3>更多来自LogRocket的精彩文章:</h3>

<hr/></div>
<pre>{% include "header.html" %}
&lt;div class="entry"&gt;
    &lt;h1&gt;{{title}}&lt;/h1&gt;
    &lt;div class="body"&gt;
        {{body}}
    &lt;/div&gt;
&lt;/div&gt;
{% include "footer.html" %}
</pre>
<p>因为您不想将页面的顶部和底部复制/粘贴到每个模板中，所以包括<code>header.html</code>和<code>footer.html</code>文件。</p>
<pre>&lt;html&gt;
    &lt;head&gt;
        &lt;title&gt;Bookstore&lt;/title&gt;
        {% include "css.html" %}
    &lt;/head&gt;
    &lt;body&gt;
    &lt;div&gt;
        &lt;h1&gt;Bookstore&lt;/h1&gt;
    &lt;/div&gt;
    {% include "menu.html" %}
    &lt;hr /&gt;
</pre>
<p>标题包括一些CSS和一个硬编码的菜单。</p>
<pre>&lt;style&gt;
    td, th {
        padding: 8px;
    }
    th {
        text-align: left;
    }
&lt;/style&gt;


&lt;div class="menu"&gt;
    &lt;span class="menuitem"&gt;
        &lt;a href = "/books/list"&gt;Books&lt;/a&gt;
    &lt;/span&gt;
&lt;/div&gt;
</pre>
<p>最后，页脚:</p>
<pre>    &lt;/body&gt;
&lt;/html&gt;
</pre>
<p>如您所见，如果我们将<code>welcome.html</code>的内容放在代码片段中，我们会得到一个完整的HTML页面。</p>
<p>那么，我们怎样才能真正创造出HTML的美好呢？让我们看看<code>handler</code>模块中的<code>welcome_handler</code>函数。</p>
<pre>pub async fn welcome_handler() -&gt; WebResult&lt;impl Reply&gt; {
    let template = WelcomeTemplate {
        title: "Welcome",
        body: "To The Bookstore!",
    };
    let res = template
        .render()
        .map_err(|e| reject::custom(TemplateError(e)))?;
    Ok(html(res))
}
</pre>
<p>概括一下，首先我们创建了一个<code>WelcomeTemplate</code>结构的实例，并在其上调用了<code>render()</code>，它返回了一个<code>Result</code>。然后我们处理错误，并简单地将warp的<code>reply::html</code>函数呈现的结果返回给客户端。</p>
<p>那很容易！</p>
<p>我们还想实现完整的CRUD功能，所以接下来让我们看看如何做一些更高级的事情。</p>
<h2 id="otherhandlers">其他处理者</h2>
<p>让我们一次为我们的warp服务器定义所有的处理器，这样我们就可以对我们需要实现的东西有一个大概的了解。</p>
<pre>let books_routes = books
    .and(new)
    .and(warp::get())
    .and_then(handler::new_book_handler)
    .or(books
        .and(new)
        .and(warp::post())
        .and(warp::body::form())
        .and(with_db(db.clone()))
        .and_then(handler::create_book_handler))
    .or(books
        .and(edit)
        .and(warp::get())
        .and(warp::path::param())
        .and(with_db(db.clone()))
        .and_then(handler::edit_book_handler))
    .or(books
        .and(edit)
        .and(warp::post())
        .and(warp::path::param())
        .and(warp::body::form())
        .and(with_db(db.clone()))
        .and_then(handler::do_edit_book_handler))
    .or(books
        .and(delete)
        .and(warp::get())
        .and(warp::path::param())
        .and(with_db(db.clone()))
        .and_then(handler::delete_book_handler))
    .or(books
        .and(list)
        .and(warp::get())
        .and(with_db(db.clone()))
        .and_then(handler::books_list_handler));
</pre>
<p>这需要相当多的处理程序，但是请记住，对于创建和编辑书籍这样的交互式操作，我们需要两个端点:一个用于显示表单，另一个用于处理表单。</p>
<p>这就是<code>new_book_handler</code>，它只是一个GET端点，和<code>create_book_handler</code>，它接收一个<code>form</code>体，并且是一个POST端点。</p>
<p>将上面定义的基于数据内存的数据存储传递给每个处理程序。处理程序需要访问数据并为编辑和删除端点定义<code>path::param</code>,因为它们将接收图书的ID进行操作。</p>
<p>让我们从最简单的端点开始:列出书籍。</p>
<pre>#[derive(Template)]
#[template(path = "book/list.html")]
struct BooklistTemplate&lt;'a&gt; {
    books: &amp;'a Vec&lt;Book&gt;,
}

pub async fn books_list_handler(db: DB) -&gt; WebResult&lt;impl Reply&gt; {
    match db.read() {
        Ok(books) =&gt; {
            let template = BooklistTemplate {
                books: &amp;books,
            };
            let res = template
                .render()
                .map_err(|e| reject::custom(TemplateError(e)))?;
            Ok(html(res))
        }
        Err(_) =&gt; Err(reject::custom(DBAccessError)),
    }
}
</pre>
<p>如您所见，我们使用了<code>book/list.html</code>作为模板，因此我们可以使用文件夹来构建模板。</p>
<p>然后，我们在共享数据存储上获得一个读锁，如果可以的话，只需将books向量的引用传递给模板。</p>
<p>如果一个错误发生了，我们把它转换成我们的一个自定义错误，稍后我们会看到，并返回它。</p>
<p>该模板如下所示:</p>
<pre>{% include "../header.html" %}
&lt;a href="/books/new"&gt;Add Book&lt;/a&gt;
&lt;table&gt;
    &lt;tr&gt;
        &lt;th&gt;id&lt;/th&gt;
        &lt;th&gt;name&lt;/th&gt;
        &lt;th&gt;author&lt;/th&gt;
        &lt;th&gt;language&lt;/th&gt;
        &lt;th&gt;pages&lt;/th&gt;
        &lt;th&gt;added&lt;/th&gt;
        &lt;th&gt;edit&lt;/th&gt;
        &lt;th&gt;delete&lt;/th&gt;
    &lt;/tr&gt;
{% for book in books %}
    &lt;tr&gt;
        &lt;td&gt;{{ book.id }}&lt;/td&gt;
        &lt;td&gt;{{ book.name }}&lt;/td&gt;
        &lt;td&gt;{{ book.author }}&lt;/td&gt;
        &lt;td&gt;{{ book.language }}&lt;/td&gt;
        &lt;td&gt;{{ book.pages }}&lt;/td&gt;
        &lt;td&gt;{{ book.added_at }}&lt;/td&gt;
        &lt;td&gt;&lt;a href="{{"/books/edit/{}"|format(book.id)}}"&gt;edit&lt;/a&gt;&lt;/td&gt;
        &lt;td&gt;&lt;a href="{{"/books/delete/{}"|format(book.id)}}"&gt;delete&lt;/a&gt;&lt;/td&gt;
    &lt;?tr&gt;
{% endfor %}
&lt;/table&gt;
{% include "../footer.html" %}
</pre>
<p>同样，我们包含了页眉和页脚，创建了一个添加新书的按钮，并创建了一个表——是的，一个老式的HTML表——来显示书籍。</p>
<p>在表头之后，我们遍历了给定的<code>BooklistTemplate</code>结构中的<code>book</code>,并简单地显示了值。</p>
<p>对于编辑和删除链接，我们使用了<code>format</code>函数，通过管道语法将图书ID转换成格式字符串。</p>
<p>既然我们能读书，为什么不创造一本书呢？接下来我们来看看<code>new_book_handler</code>。</p>
<pre>#[derive(Template)]
#[template(path = "book/new.html")]
struct NewBookTemplate {}

pub async fn new_book_handler() -&gt; WebResult&lt;impl Reply&gt; {
    let template = NewBookTemplate {};
    let res = template
        .render()
        .map_err(|e| reject::custom(TemplateError(e)))?;
    Ok(html(res))
}
</pre>
<p>这是新的—没有任何内容的模板结构。在这种情况下，我们简单地使用它来定义使用哪个模板。然后，它被实例化和渲染。</p>
<p>模板只是一个表单，其中的<code>action</code>指向<code>POST /books/new</code>:</p>
<pre>{% include "../header.html" %}
&lt;h2&gt;Add New Book&lt;/h2&gt;
&lt;table&gt;
    &lt;form action="/books/new" method="post"&gt;
        &lt;tr&gt;
            &lt;td&gt;Name:&lt;/td&gt;
            &lt;td&gt;&lt;input type="text" name="name" /&gt;&lt;/td&gt;
        &lt;tr/&gt;
        &lt;tr&gt;
            &lt;td&gt;Author:&lt;/td&gt;
            &lt;td&gt;&lt;input type="text" name="author" /&gt;&lt;/td&gt;
        &lt;tr/&gt;
        &lt;tr&gt;
            &lt;td&gt;Language:&lt;/td&gt;
            &lt;td&gt;&lt;input type="text" name="language" value="de" /&gt;&lt;/td&gt;
        &lt;tr/&gt;
        &lt;tr&gt;
            &lt;td&gt;Pages:&lt;/td&gt;
            &lt;td&gt;&lt;input type="text" name="pages" value="300" /&gt;&lt;/td&gt;
        &lt;tr/&gt;
        &lt;tr&gt;
            &lt;td colspan="2"&gt;&lt;button type="submit"&gt;Send&lt;/button&gt;&lt;/td&gt;
        &lt;tr/&gt;
    &lt;/form&gt;
&lt;/table&gt;
{% include "../footer.html" %}
</pre>
<p>一旦表单被填写和发送，它将触发<code>create_book_handler</code>，我们接下来会看到:</p>
<pre>pub async fn create_book_handler(body: BookRequest, db: DB) -&gt; WebResult&lt;impl Reply&gt; {
    let new_book = Book {
        id: Uuid::new_v4().to_string(),
        name: body.name,
        author: body.author,
        language: body.language,
        pages: body.pages,
        added_at: Utc::now(),
    };
    match db.write() {
        Ok(mut books) =&gt; {
            books.push(new_book);
        }
        Err(_) =&gt; return Err(reject::custom(DBAccessError)),
    };
    books_list_handler(db).await
}
</pre>
<p>这个处理程序没有模板，因为如果操作成功，我们将简单地把用户送回图书列表。</p>
<p>因为我们之前定义了一个<code>warp::body::form</code>，所以我们得到了一个容易反序列化的传递给处理程序的<code>BookRequest</code>对象。</p>
<pre>#[derive(Serialize, Deserialize, Debug)]
pub struct BookRequest {
    pub name: String,
    pub author: String,
    pub language: String,
    pub pages: i32,
}
</pre>
<p>基于这个有效载荷，我们可以创建一个新的<code>Book</code>，它使用<code>uuid</code>生成一个惟一的ID，使用<code>chrono</code>生成当前的UTC日期。</p>
<p>然后，我们在“数据库”上获得一个写锁，并将这本书添加到图书列表中。</p>
<p>我们已经成功了一半。让我们继续编辑和删除书籍。</p>
<h2 id="editanddelete">编辑和删除</h2>
<p>一旦我们有了一些书，我们可能会想要改变它们。毕竟，错误时有发生，拼写错误的作者姓名会很尴尬。因为任何人都会犯错误，拼写错误的作者可能会很尴尬。</p>
<p>为此，我们需要实现两个<code>edit</code>处理程序:</p>
<pre>#[derive(Template)]
#[template(path = "book/edit.html")]
struct EditBookTemplate&lt;'a&gt; {
    book: &amp;'a Book,
}

pub async fn edit_book_handler(id: String, db: DB) -&gt; WebResult&lt;impl Reply&gt; {
    let book = match db.read() {
        Ok(books) =&gt; match books.iter().find(|b| b.id == id) {
            Some(book) =&gt; book.clone(),
            None =&gt; return Err(reject::custom(BookNotFoundError)),
        },
        Err(_) =&gt; return Err(reject::custom(DBAccessError)),
    };

    let template = EditBookTemplate { book: &amp;book };
    let res = template
        .render()
        .map_err(|e| reject::custom(TemplateError(e)))?;
    Ok(html(res))
}
</pre>
<p>在这种情况下，我们需要一个新的模板:<code>EditBookTemplate</code>。实际上，通常可以创建一个用于创建和编辑的模板，并简单地设置值(如果有的话)。但是这增加了模板的复杂性——在我看来，即使在编译时对它们进行了检查，这也不是一个真正有趣的地方。</p>
<p>对于<code>edit</code>表单，我们需要在我们的“数据库”中找到具有给定ID的书，否则返回一个错误。如果找到了这本书，对它的引用将被添加到<code>EditBookTemplate</code>中，并呈现给用户</p>
<p>用于编辑的模板如下所示:</p>
<pre>{% include "../header.html" %}
&lt;h2&gt;Edit Book&lt;/h2&gt;
&lt;table&gt;
    &lt;form action="{{"/books/edit/{}"|format(book.id)}}" method="post"&gt;
        &lt;tr&gt;
            &lt;td&gt;Name:&lt;/td&gt;
            &lt;td&gt;&lt;input type="text" name="name" value="{{ book.name }}"/&gt;&lt;/td&gt;
        &lt;tr/&gt;
        &lt;tr&gt;
            &lt;td&gt;Author:&lt;/td&gt;
            &lt;td&gt;&lt;input type="text" name="author" value="{{ book.author }}"/&gt;&lt;/td&gt;
        &lt;tr/&gt;
        &lt;tr&gt;
            &lt;td&gt;Language:&lt;/td&gt;
            &lt;td&gt;&lt;input type="text" name="language" value="{{ book.language }}"/&gt;&lt;/td&gt;
        &lt;tr/&gt;
        &lt;tr&gt;
            &lt;td&gt;Pages:&lt;/td&gt;
            &lt;td&gt;&lt;input type="text" name="pages" value="{{ book.pages }}" /&gt;&lt;/td&gt;
        &lt;tr/&gt;
        &lt;tr&gt;
            &lt;td colspan="2"&gt;&lt;button type="submit"&gt;Send&lt;/button&gt;&lt;/td&gt;
        &lt;tr/&gt;
    &lt;/form&gt;
&lt;/table&gt;
{% include "../footer.html" %}
</pre>
<p>这与创建新书的表单非常相似，不同之处在于我们设置了每个输入字段的<code>value</code>，并将表单动作设置为<code>POST /books/edit/$bookId</code>。</p>
<p>一旦表单被发送，我们就被传送到<code>do_edit_book_handler</code>，它有一个<code>BookRequest</code>，类似于<code>create_book_handler</code>，还有一个ID。</p>
<pre>pub async fn do_edit_book_handler(id: String, body: BookRequest, db: DB) -&gt; WebResult&lt;impl Reply&gt; {
    match db.write() {
        Ok(mut books) =&gt; match books.iter_mut().find(|b| b.id == id) {
            Some(ref mut book) =&gt; {
                book.name = body.name;
                book.language = body.language;
                book.author = body.author;
                book.pages = body.pages;
            }
            None =&gt; return Err(reject::custom(BookNotFoundError)),
        },
        Err(_) =&gt; return Err(reject::custom(DBAccessError)),
    };
    books_list_handler(db).await
}
</pre>
<p>因为我们正在操作数据，所以我们需要再次获得一个写锁，并搜索具有给定ID的书。如果它不存在，我们返回一个错误。否则，我们简单地用身体的数据在适当的地方改变这本书。</p>
<p>我们需要实现的最后一个操作是<code>delete</code>，相对于<code>edit</code>来说比较简单。</p>
<pre>pub async fn delete_book_handler(id: String, db: DB) -&gt; WebResult&lt;impl Reply&gt; {
    match db.write() {
        Ok(mut books) =&gt; {
            let mut delete_idx = None;
            for (i, b) in books.iter().enumerate() {
                if b.id == id {
                    delete_idx = Some(i);
                }
            }
            match delete_idx {
                Some(i) =&gt; {
                    books.remove(i);
                }
                None =&gt; return Err(reject::custom(BookNotFoundError)),
            }
        }
        Err(_) =&gt; return Err(reject::custom(DBAccessError)),
    };
    books_list_handler(db).await
}
</pre>
<p>我们不再需要模板，因为我们只是执行操作并将用户重定向回图书列表。除此之外，这是和以前一样的把戏:获得一个写锁，寻找这本书并删除它，如果没有找到就返回一个错误。</p>
<h2 id="basicerrorhandling">基本错误处理</h2>
<p>因为这不是一个JSON API，在这里我们只能返回一个带有错误消息和状态代码的JSON对象，所以我们需要创建一个向用户显示错误的模板。</p>
<pre>{% include "header.html" %}
&lt;div class="error"&gt;
    &lt;h1&gt;Error&lt;/h1&gt;
    &lt;div class="body"&gt;
        An Error Occurred: &lt;br /&gt;&lt;br /&gt;
        {{ message }}
    &lt;/div&gt;
&lt;/div&gt;
{% include "footer.html" %}
</pre>
<p>在这种非常基本的情况下，这可能不是特别有帮助，但至少用户可以往回导航，并了解出了什么问题。</p>
<p>最后，让我们将所有东西连接到一个warp web服务器上。</p>
<pre>    let routes = welcome_route
        .or(books_routes)
        .recover(error::handle_rejection);

    println!("Started on port 8080");
    warp::serve(routes).run(([0, 0, 0, 0], 8080)).await;
</pre>
<p><code>error</code>模块中的<code>handle_rejection</code>函数如下所示:</p>
<pre>#[derive(Error, Debug)]
pub enum Error {
    #[error("error accessing the database")]
    DBAccessError,
    #[error("book not found")]
    BookNotFoundError,
    #[error("templating error: {0}")]
    TemplateError(#[from] askama::Error),
}

#[derive(Template)]
#[template(path = "error.html")]
struct ErrorTemplate {
    message: &amp;'static str,
}

impl warp::reject::Reject for Error {}

pub async fn handle_rejection(err: Rejection) -&gt; std::result::Result&lt;impl Reply, Infallible&gt; {
    let code;
    let message;

    if err.is_not_found() {
        code = StatusCode::NOT_FOUND;
        message = "Not Found";
    } else if let Some(_) = err.find::&lt;warp::filters::body::BodyDeserializeError&gt;() {
        code = StatusCode::BAD_REQUEST;
        message = "Invalid Body";
    } else if let Some(e) = err.find::&lt;Error&gt;() {
        match e {
            Error::DBAccessError =&gt; {
                code = StatusCode::BAD_REQUEST;
                message = "there was an error accessing the database";
            }
            _ =&gt; {
                eprintln!("unhandled application error: {:?}", err);
                code = StatusCode::INTERNAL_SERVER_ERROR;
                message = "Internal Server Error";
            }
        }
    } else {
        eprintln!("unhandled error: {:?}", err);
        code = StatusCode::INTERNAL_SERVER_ERROR;
        message = "Internal Server Error";
    }

    let template = ErrorTemplate { message };

    match template.render() {
        Ok(v) =&gt; Ok(reply::with_status(html(v), code)),
        Err(_) =&gt; Ok(reply::with_status(
            html(String::from(message)),
            StatusCode::INTERNAL_SERVER_ERROR,
        )),
    }
}
</pre>
<p>首先，我们定义了一个自定义的<code>Error</code>枚举，它实现了warp的<code>Reject</code>特征，这使我们能够从处理程序中返回它。我们有访问“数据库”的错误案例，找不到书的错误案例，以及呈现模板时的错误案例。</p>
<p>我们还用上面定义的<code>error.html</code>模板和一条错误消息定义了<code>ErrorTemplate</code>。</p>
<p>接下来，我们检查不同的错误情况，设置一些有用的错误消息和响应代码，最后，呈现<code>ErrorTemplate</code>。如果在这里渲染失败，我们只能给用户发送一个没有模板的消息<code>INTERNAL_SERVER_ERROR</code>。</p>
<p>就是这样！如果您用<code>cargo run</code>启动这个应用程序，并导航到<code><a href="http://localhost:8080" rel="nofollow">http://localhost:8080</a></code>，您将看到一个设计非常棒的、完全由服务器呈现的UI，您可以与之交互。</p>
<p><img data-attachment-id="23787" data-permalink="https://blog.logrocket.com/template-rendering-in-rust/bookstore-app-example/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/08/bookstore-app-example.jpeg" data-orig-size="720,160" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;1&quot;}" data-image-title="Bookstore app example" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/08/bookstore-app-example-300x67.jpeg" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/08/bookstore-app-example.jpeg" decoding="async" class="aligncenter size-full wp-image-23787 jetpack-lazy-image" src="../Images/a81260d4f6859853a5a938edcb2ab742.png" alt="Bookstore App Example" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2020/08/bookstore-app-example.jpeg 720w, https://blog.logrocket.com/wp-content/uploads/2020/08/bookstore-app-example-300x67.jpeg 300w" data-lazy-sizes="(max-width: 720px) 100vw, 720px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2020/08/bookstore-app-example.jpeg?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/08/bookstore-app-example.jpeg"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="23787" data-permalink="https://blog.logrocket.com/template-rendering-in-rust/bookstore-app-example/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/08/bookstore-app-example.jpeg" data-orig-size="720,160" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;1&quot;}" data-image-title="Bookstore app example" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/08/bookstore-app-example-300x67.jpeg" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/08/bookstore-app-example.jpeg" decoding="async" loading="lazy" class="aligncenter size-full wp-image-23787" src="../Images/a81260d4f6859853a5a938edcb2ab742.png" alt="Bookstore App Example" srcset="https://blog.logrocket.com/wp-content/uploads/2020/08/bookstore-app-example.jpeg 720w, https://blog.logrocket.com/wp-content/uploads/2020/08/bookstore-app-example-300x67.jpeg 300w" sizes="(max-width: 720px) 100vw, 720px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/08/bookstore-app-example.jpeg"/></noscript>
<p>你可以在<a href="https://github.com/zupzup/rust-templating-example" target="_blank" rel="noopener noreferrer"> GitHub </a>上找到这个例子的完整代码。</p>
<h2 id="conclusion">结论</h2>
<p>在本教程中，我们以服务器端呈现的web应用程序为例，演示了如何在Rust中进行安全、高性能的模板呈现。</p>
<p>模板引擎可以用于广泛的用例。Rust中的库生态系统给人留下了深刻的印象，并且已经为个别用例提供了许多不同的选项。</p><div class="code-block code-block-29">
<div class="blog-plug inline-plug rust-plug"><h2><a href="https://lp.logrocket.com/blg/rust-signup" target="_blank">log rocket</a>:Rust应用的web前端的全面可见性</h2><p>调试Rust应用程序可能很困难，尤其是当用户遇到难以重现的问题时。如果您对监控和跟踪Rust应用程序的性能、自动显示错误、跟踪缓慢的网络请求和加载时间感兴趣，</p><a href="https://lp.logrocket.com/blg/rust-signup" target="_blank">try LogRocket</a><p>. </p><a class="signup" href="https://lp.logrocket.com/blg/rust-signup" target="_blank" rel="noopener noreferrer"><img class="alignnone size-full wp-image-46 jetpack-lazy-image" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/><noscript><img data-lazy-fallback="1" class="alignnone size-full wp-image-46" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/></noscript></a><p>LogRocket 就像是网络和移动应用程序的DVR，记录你的Rust应用程序上发生的一切。您可以汇总并报告问题发生时应用程序的状态，而不是猜测问题发生的原因。LogRocket还可以监控应用的性能，报告客户端CPU负载、客户端内存使用等指标。</p><p>现代化调试Rust应用的方式— <a class="signup" href="https://lp.logrocket.com/blg/rust-signup" target="_blank" rel="noopener noreferrer">开始免费监控</a>。</p></div>


</div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
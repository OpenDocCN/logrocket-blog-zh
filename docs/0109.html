<html>
<head>
<title>React onClick event handlers: A complete guide - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>React onClick事件处理程序:完整指南</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/react-onclick-event-handlers-guide/#0001-01-01">https://blog.logrocket.com/react-onclick-event-handlers-guide/#0001-01-01</a></blockquote><div><article class="article-post">
<p><em> <strong>编者按:</strong>这篇文章于2022年7月8日更新，以确保关于React 18的一切都是最新的，并在React with TypeScript 中添加了一个关于<a href="#type-checking-react-typescript">类型检查的部分。</a></em></p>
<p>在本教程中，我们将回顾React的<code>onClick</code>事件处理程序的基础，包括事件监听、处理自定义事件以及使用TypeScript对事件处理程序进行类型检查。</p>
<p>我们将涵盖的内容:</p>

<h2 id="what-event-handlers-react">React中的事件处理程序是什么？</h2>
<p>事件处理程序决定每当触发事件时要采取的操作。这可能是按钮点击或文本输入的改变。</p>
<p>本质上，事件处理程序使用户能够与React应用程序进行交互。用React元素处理事件类似于在DOM元素上处理事件，除了一些小的例外。</p>
<p>如果你熟悉标准HTML和JavaScript中事件的工作方式，那么学习如何在React中处理事件应该很容易。</p>
<h2 id="what-onclick-handler-react">React中的<code>onClick</code>处理程序是什么？</h2>
<p>React <code>onClick</code>事件处理程序使您能够调用一个函数，并在用户单击应用程序中的一个元素(如按钮)时触发一个动作。</p>
<p>事件名称是在camelCase中编写的，所以在React应用程序中，<code>onclick</code>事件被写成<code>onClick</code>。另外，<a href="https://reactjs.org/docs/handling-events.html" target="_blank" rel="noreferrer noopener"> React事件处理程序</a>出现在花括号内。</p>
<p>以下面这个用HTML编写的简单例子为例:</p>
<pre class="language-html hljs">&lt;button onclick="sayHello()"&gt;
  Say Hello
&lt;button&gt;
</pre>
<p>在React应用程序中，这个<code>button onClick</code>事件将被写成如下形式:</p>
<pre class="language-javascript hljs">&lt;button onClick={sayHello}&gt;
  Say Hello
&lt;button&gt;
</pre>
<p>另一个关键区别是，在React中您必须显式调用<code>preventDefault</code>，而在HTML中，您可以简单地返回<code>false</code>以避免默认行为。</p>
<p>以下示例显示了如何在默认情况下阻止链接打开新页面:</p>
<pre class="language-html hljs">&lt;a href="#" onclick="console.log('The link was clicked.'); return false"&gt;
  Click me
&lt;/a&gt;
</pre>
<p>您可以在React中编写如下内容:</p>
<pre class="language-javascript hljs">function ActionLink() {
  const handleClick = (e) =&gt; {
    e.preventDefault();
    console.log('The link was clicked.');
  }

  return (
    &lt;button onClick={handleClick}&gt;
      Click me
    &lt;/button&gt;
  );
}
</pre>
<h2 id="what-synthetic-events-react">React中的合成事件是什么？</h2>
<p><a href="https://blog.logrocket.com/getting-started-react-synthetic-event/" target="_blank" rel="noreferrer noopener"> React实现了一个合成事件系统</a>，为React应用和界面带来了一致性和高性能。它通过规范化事件来实现一致性，使它们在不同的浏览器和平台上具有相同的属性。</p>
<p>合成事件是围绕浏览器本机事件的跨浏览器包装。它与浏览器的本地事件具有相同的接口，包括<code>stopPropagation()</code>和<code>preventDefault()</code>，除了这些事件在所有浏览器中的工作方式相同。</p>
<p>它通过自动使用事件委托来实现高性能。实际上，React不会将事件处理程序附加到节点本身。相反，单个事件监听程序附加到文档的根。触发事件时，“反应”会将其映射到适当的组件元素。</p>
<h2 id="react-event-listeners">反应事件侦听器</h2>
<p>为了让<a href="https://www.pluralsight.com/guides/event-listeners-in-react-components" target="_blank" rel="noreferrer noopener">监听React </a>中的事件，向目标元素添加<code>onClick</code>属性——它是事件处理程序。这指定了单击该元素时要执行的功能，如下所示:</p>
<pre class="language-javascript hljs">import React from "react";

const ShowAlertComponent = () =&gt; {
  const showAlert = () =&gt; {
    alert("I'm an alert");
  }

  return &lt;button onClick={showAlert}&gt;Show alert&lt;/button&gt;;
}
export default ShowAlertComponent;
</pre>
<p>在上面的例子中，<code>onClick</code>属性被设置为作为事件目标的<code>showAlert</code>函数，当单击按钮时，它显示警告消息“我是一个警告”。</p>
<h2 id="handling-events-react-components">处理React组件中的事件</h2>
<p>有几种方法可以处理功能性React组件中的事件。我们将在这里讨论其中的五个。</p>
<h3 id="call-inline-function-onclick-event-handler">在<code>onClick</code>事件处理程序中调用内联函数</h3>
<p>内联函数允许您直接在JSX中编写事件处理代码。请参见下面的示例:</p>
<pre class="language-html hljs">import React from "react";

const App = () =&gt; {
  return (
    &lt;button onClick={() =&gt; alert("Hello!")}&gt;Say Hello&lt;/button&gt;
  );
};

export default App;
</pre>
<p>这通常用于避免JSX之外的额外函数声明，尽管如果内联函数的内容太多，可读性会更差，也更难维护。</p>
<h3 id="update-state-inside-onclick-event-handler">更新<code>onClick</code>事件处理程序中的状态</h3>
<p>假设您的React应用程序要求您在一个<code>onClick</code>事件处理程序中更新本地状态。下面是如何做到这一点:</p>
<pre class="language-javascript hljs">import React, { useState } from "react";

const App = () =&gt; {
  const [count, setCount] = useState(0);
  return (
    &lt;div&gt;
      &lt;p&gt;{count}&lt;/p&gt;
      &lt;button onClick={() =&gt; setCount(count + 1)}&gt;Increment&lt;/button&gt;
      &lt;button onClick={() =&gt; setCount(count - 1)}&gt;Decrement&lt;/button&gt;
    &lt;/div&gt;
  );
};

export default App;
</pre>
<p>在上面的例子中，<code>useState</code>的值被<code>Increment</code>和<code>Decrement</code>按钮修改，这两个按钮在<code>onClick</code>事件处理程序中有一个更新函数<code>setCount</code>。</p>
<h3 id="call-multiple-functions-onclick-event-handler">在一个<code>onClick</code>事件处理程序中调用多个函数</h3>
<p><code>onClick</code>事件处理程序也允许你调用多个函数。</p>
<pre class="language-javascript hljs">import React, { useState } from "react";

const App = () =&gt; {
  const [count, setCount] = useState(0);
  const sayHello = () =&gt; {
    alert("Hello!");
  };

  return (
    &lt;div&gt;
      &lt;p&gt;{count}&lt;/p&gt;
      &lt;button
        onClick={() =&gt; {
          sayHello();
          setCount(count + 1);
        }}
      &gt;
        Say Hello and Increment
      &lt;/button&gt;
    &lt;/div&gt;
  );
};

export default App;
</pre>
<p>在上面的代码块中，单击按钮会增加本地状态并发出一条消息。这两个动作都由<code>onClick</code>事件处理程序中的独立函数执行。</p>
<h3 id="pass-parameter-onclick-event-handler">将参数传递给<code>onClick</code>事件处理程序</h3>
<p>事件处理程序的另一个常见用例是将参数传递给函数，以便以后使用。例如:</p>
<pre class="language-javascript hljs">import React from "react";

const App = () =&gt; {
  const sayHello = (name) =&gt; {
    alert(`Hello, ${name}!`);
  };

  return (
    &lt;button
      onClick={() =&gt; {
        sayHello("Yomi");
      }}
    &gt;
      Say Hello
    &lt;/button&gt;
  );
};

export default App;
</pre>
<p>这里，<code>sayHello</code>函数接受一个名称作为参数，然后用它来定制警告消息。在这种情况下，该函数接受“金尤美”这个名称，这样在单击时，按钮显示“你好，金尤美！”作为它的信息。</p>
<h3 id="use-synthetic-events-onclick-event-handler">直接在<code>onClick</code>事件处理程序中使用合成事件</h3>
<p>您也可以在<code>onClick</code>事件处理程序中直接使用合成事件。在下面的例子中，按钮的值是通过<code>e.target.value</code>获得的，然后用来警告一条消息。</p>
<pre class="language-javascript hljs">import React from "react";

const App = () =&gt; {
  return (
    &lt;button value="Hello!" onClick={(e) =&gt; alert(e.target.value)}&gt;
      Say Hello
    &lt;/button&gt;
  );
};

export default App;
</pre>
<h2 id="custom-components-events-react">React中的自定义组件和事件</h2>
<p>当谈到React中的事件时，只允许DOM元素拥有事件处理程序。以带有<code>onClick</code>事件的组件<code>CustomButton</code>为例。由于上述原因，此按钮不会响应点击。</p>
<p>那么我们如何在React 中为<a href="https://blog.logrocket.com/build-react-custom-component-library-theme-ui/" target="_blank" rel="noreferrer noopener">定制组件处理事件呢？</a></p>
<p>通过在<code>CustomButton</code>组件中呈现一个DOM元素并将<code>onClick</code> prop传递给它。我们的<code>CustomButton</code>本质上是点击事件的一个传递。</p>
<pre><code>import React from "react";

const CustomButton = ({ onPress }) =&gt; {
  return (
    &lt;button type="button" onClick={onPress}&gt;
      Click on me
    &lt;/button&gt;
  );
};

const App = () =&gt; {
  const handleEvent = () =&gt; {
    alert("I was clicked");
  };
  return &lt;CustomButton onPress={handleEvent} /&gt;;
};

export default App;
</code></pre>
<p>在上面的例子中，<code>CustomButton</code>组件被传递了一个<code>onPress</code>的属性，然后这个属性被传递到<code>button</code>的<code>onClick</code>中。</p>
<h2 id="type-checking-react-typescript">React with TypeScript中的类型检查</h2>
<p>这是一个关于如何在React中为事件处理添加类型检查的例子。<code>ChangeEvent</code>类型从React导入，并用于从<code>input</code>元素传递的事件。</p>
<pre class="language-javascript hljs">import {useState, ChangeEvent} from "react";

const InputComponent = () =&gt; {
  const [email, setEmail] = useState&lt;string&gt;('');

  const onChange = (e: ChangeEvent&lt;HTMLInputElement&gt;): void =&gt; {
    setEmail(e.target.value);
  };

  return &lt;input type="text" placeholder="Enter email address" onChange={onChange} value={email} /&gt;;
}
export default InputComponent;
</pre>
<p>让我们看看一个完整的表单，以及如何为输入和表单提交向事件处理程序添加类型。</p>
<pre class="language-javascript hljs">import { useState, ChangeEvent, FormEvent } from 'react';

export default function App() {
  const [email, setEmail] = useState&lt;string&gt;('');
  const [password, setPassword] = useState&lt;string&gt;('');

  const handleSubmit = (event: FormEvent) =&gt; {
    console.log('Form was submitted!');
  };

  const handleEmailChange = (event: ChangeEvent&lt;HTMLInputElement&gt;) =&gt; {
    setEmail(event.target.value);
  };

  const handlePasswordChange = (event: ChangeEvent&lt;HTMLInputElement&gt;) =&gt; {
    setPassword(event.target.value);
  };

  return (
    &lt;div className="App"&gt;
      &lt;form onSubmit={handleSubmit}&gt;
        &lt;input type="text" placeholder="Enter email address" onChange={handleEmailChange} value={email} /&gt;
        &lt;input type="password" placeholder="Enter password" onChange={handlePasswordChange} value={password} /&gt;
        &lt;button type="submit"&gt;Submit&lt;/button&gt;
      &lt;/form&gt;
    &lt;/div&gt;
  );
}
</pre>
<p>React提供了一个您可以使用的<code>FormEvent</code>类型，并将其传递给<code>handleSubmit</code>函数。要了解React事件处理程序的更多信息，请查看React提供的事件处理程序类型的<a href="https://blog.logrocket.com/build-react-custom-component-library-theme-ui/" target="blank" rel="noreferrer noopener">详尽列表。</a></p>
<h2 id="conclusion">结论</h2>
<p>事件处理程序决定事件发生时应该采取什么行动。<code>onClick</code>事件用于监听DOM元素上的点击事件。</p>
<p>我们还回顾了功能组件中<code>onClick</code>事件处理程序的一些常见用例，比如更新状态、调用多个函数和使用合成事件。</p>
<p>我们讨论了<code>onClick</code>事件处理程序如何在定制组件中工作，最后我们看了如何给事件处理程序添加类型。</p><div class="code-block code-block-17">
<div class="blog-plug inline-plug react-plug" vwo-el-id="26283398190">
<h2 vwo-el-id="41600691720">使用LogRocket消除传统反应错误报告的噪音</h2>
<a href="https://lp.logrocket.com/blg/react-signup-issue-free" target="_blank" vwo-el-id="19356441070">LogRocket
</a><p>是一款React analytics解决方案，可保护您免受数百个误报错误警报的影响，只针对少数真正重要的项目。LogRocket告诉您React应用程序中实际影响用户的最具影响力的bug和UX问题。</p><a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="19356441380">
<img class="first-react-image alignnone size-full wp-image-46 jetpack-lazy-image jetpack-lazy-image--handled" src="../Images/f300c244a1a1cf916df8b4cb02bec6c6.png" vwo-el-id="18272717540" data-lazy-loaded="1" data-original-src="https://files.readme.io/27c94e7-Image_2017-06-05_at_9.46.04_PM.png"/>
</a>
<a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="19356441690">
<img class="second-react-image alignnone size-full wp-image-46 jetpack-lazy-image jetpack-lazy-image--handled" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" vwo-el-id="30720362350" data-lazy-loaded="1" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/>
</a>
<a href="https://lp.logrocket.com/blg/react-signup-issue-free" target="_blank" rel="noopener noreferrer" vwo-el-id="35866400580">LogRocket
</a><p>自动聚合客户端错误、反应错误边界、还原状态、缓慢的组件加载时间、JS异常、前端性能指标和用户交互。然后，LogRocket使用机器学习来通知您影响大多数用户的最具影响力的问题，并提供您修复它所需的上下文。</p><p vwo-el-id="28675661060">关注重要的React bug—<a class="signup" href="https://lp.logrocket.com/blg/react-signup-issue-free" target="_blank" rel="noopener noreferrer" vwo-el-id="40093418840">今天就试试LogRocket】。</a></p>
</div></div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
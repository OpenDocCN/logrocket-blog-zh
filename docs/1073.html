<html>
<head>
<title>Creating your first CRUD with Facebook's Recoil - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>用脸书的反冲火箭博客创建你的第一个CRUD</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/crud-with-facebook-recoil/#0001-01-01">https://blog.logrocket.com/crud-with-facebook-recoil/#0001-01-01</a></blockquote><div><article class="article-post">
<p>到目前为止，Redux 一直是React应用状态管理的领导者。GitHub上有超过53K颗星，它是成熟的、健壮的，并受到其社区的高度支持。</p>
<p>反冲是脸书团队解决同一问题的新赌注。在用反冲工作了一段时间后，我的一个主要感受是这种完全处于反应世界的感觉(并不奇怪)。学习曲线低于Redux和其他类似的libs，可能是因为它的简单性质。</p>
<p>反冲是基于原子和选择器的。简而言之，原子是存储状态值的全局单元，而选择器是从全局存储中检索计算值的“getters”。</p>
<p>然而，我们的重点不是详细解释这个库。你可以在这里阅读<a href="https://blog.logrocket.com/simple-state-management-recoil/"/>——你应该这样做。</p>
<p>我们的目标是在实践中探索后坐力的一些主要特征。为此，让我们用React、<a href="https://reactjs.org/docs/create-a-new-react-app.html"> create-react-app </a>、<a href="https://react-bootstrap.github.io/"> react-bootstrap </a>(为了便于设计和填充)以及状态管理反冲来创建一个功能完整的产品CRUD。</p>
<p>在文章的最后，这将是我们的CRUD应用程序:</p>
<p><img data-attachment-id="23399" data-permalink="https://blog.logrocket.com/crud-with-facebook-recoil/finished-crud-app/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/08/finished-crud-app.png" data-orig-size="730,416" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Our finished CRUD app" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/08/finished-crud-app-300x171.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/08/finished-crud-app.png" decoding="async" class="aligncenter size-full wp-image-23399 jetpack-lazy-image" src="../Images/7027e7f38c1ff512e1afc3b6cec9ad13.png" alt="Our Finished CRUD App" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2020/08/finished-crud-app.png 730w, https://blog.logrocket.com/wp-content/uploads/2020/08/finished-crud-app-300x171.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2020/08/finished-crud-app.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/08/finished-crud-app.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="23399" data-permalink="https://blog.logrocket.com/crud-with-facebook-recoil/finished-crud-app/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/08/finished-crud-app.png" data-orig-size="730,416" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Our finished CRUD app" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/08/finished-crud-app-300x171.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/08/finished-crud-app.png" decoding="async" loading="lazy" class="aligncenter size-full wp-image-23399" src="../Images/7027e7f38c1ff512e1afc3b6cec9ad13.png" alt="Our Finished CRUD App" srcset="https://blog.logrocket.com/wp-content/uploads/2020/08/finished-crud-app.png 730w, https://blog.logrocket.com/wp-content/uploads/2020/08/finished-crud-app-300x171.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/08/finished-crud-app.png"/></noscript>
<p>所以，我们开门见山吧。</p>
<h2>设置</h2>
<p>首先，您应该检查您是否已经安装了Node。在本教程中，我们将使用Yarn命令(可选)，所以最好<a href="https://classic.yarnpkg.com/en/docs/install">也安装</a>。在这个例子中，我们还将使用VS代码作为IDE。</p>
<p>通过命令行进入您选择的文件夹并运行:</p>
<pre>npx create-react-app recoil-products-crud 
cd recoil-products-crud</pre>
<p>遵循默认选项，直到结束。现在，让我们安装所需的依赖项。为此，运行以下命令:</p>
<pre>yarn add recoil bootstrap react-bootstrap uuid</pre>
<p><code>uuid</code>模块将帮助我们为产品列表生成随机id。</p>
<p>由于Bootstrap将负责页面元素的设计，让我们将它的CSS导入添加到<code>index.js</code>文件中，同时添加其余的初始反冲设置:</p>
<pre>import React from "react";
import ReactDOM from "react-dom";
import App from "./App";
import { RecoilRoot } from "recoil";
import * as serviceWorker from "./serviceWorker";

import "bootstrap/dist/css/bootstrap.min.css";

ReactDOM.render(
    &lt;React.StrictMode&gt;
        &lt;RecoilRoot&gt;
            &lt;App /&gt;
        &lt;/RecoilRoot&gt;
    &lt;/React.StrictMode&gt;,
    document.getElementById("root")
);

serviceWorker.unregister();</pre>
<p>反应<code>App</code>必须始终被<code>RecoilRoot</code>标签包裹，以启用反冲功能。</p>
<p>项目的最终结构如下所示(请确保在您的项目中复制它):</p>
<pre>recoil-products-crud
|----- src
        |----- components
      |----- AddProduct.js
      |----- ListProducts.js
      |----- FilterProduct.js
      |----- modals
          |----- EditModal.js
          |----- DeleteModal.js
        |----- store
      |----- atom.js
      |----- index.js
      |----- selector.js
|----- index.js
|----- App.js
|----- serviceWorker.js</pre>
<h2>反冲设置</h2>
<p>我们的应用程序将提供四个默认的CRUD操作，加上按产品名称过滤结果的能力。这将允许我们探索一下选择器的特性。</p>
<p>因此，我们需要两个不同的原子:一个用来存储注册产品的原始列表，另一个用来在过滤操作发生后保存过滤列表的状态。</p>
<p>让我们从<code>atom.js</code>代码开始:</p>
<pre>import { atom } from "recoil";

export const products = atom({
  key: "products",
  default: [],
});

export const filterProductsValue = atom({
  key: "filterProductsValue",
  default: "",
});</pre>
<p>到目前为止非常简单。我们刚刚创建了两个需要的原子，每个原子都有一个惟一的键和默认值(现在都是空的)。</p>
<p>接下来，转到<code>selector.js</code>内容:</p>
<pre>import { selector } from "recoil";
import { products, filterProductsValue } from ".";

export const filterProducts = selector({
  key: "filterProducts",
  get: ({ get }) =&gt; {
    const productsState = get(products);
    const filterProductsValueState = get(filterProductsValue);

    if (filterProductsValueState.length) {
      return productsState.filter(
        (item) =&gt; item.name.includes(filterProductsValueState.trim()) &amp;&amp; item
      );
    }
    return products;
  },
});</pre>
<p>这里，我们从反冲中导入<code>selector</code>函数。注意，选择器也需要一个唯一的键；他们是国家价值观的探寻者。<code>get</code>值接收过滤代码，在我们的例子中，过滤代码将首先恢复产品列表和输入的过滤文本，最后在前一个列表中执行搜索。</p>
<p>对于许多不同的搜索需求，可以创建许多新的选择器。如果您的选择器代码变得太大，您应该考虑将它们组织在不同的分类JavaScript文件中。</p>
<p>让我们用<code>index.js</code>的代码来结束这一部分:</p>
<pre>export { products, filterProductsValue } from "./atom";
export { filterProducts } from "./selector";</pre>
<p>在这里，我们只是将原子和选择器统一在一个地方。无论何时你需要它们，只需导入<code>store</code>。</p>
<h2>组件</h2>
<p>显然，没有React组件，我们的反冲代码无法单独工作。所以，让我们继续他们的建设。我们将从较低的组件(模态)到较高的组件这样做。</p>
<p>该示例将有两个模态:一个用于产品的编辑，另一个用于产品的删除。下面是<code>DeleteModal.js</code>文件的代码:</p>
<pre>import React from "react";
import { Button, Modal } from "react-bootstrap";
import { useRecoilState } from "recoil";

import { products } from "../../store";

const DeleteModal = (props) =&gt; {
  const { show, id, handleClose } = props;

  const [productList, setProductList] = useRecoilState(products);
  const product = productList.length
    ? productList.find((item) =&gt; item.id === id)
    : null;
  const index = productList.findIndex((item) =&gt; item === product);

  const deleteProduct = () =&gt; {
    setProductList(removeProduct(productList, index));
    handleClose();
  };

  return (
    &lt;&gt;
      {product ? (
        &lt;Modal show={show} onHide={handleClose}&gt;
          &lt;Modal.Header closeButton&gt;
            &lt;Modal.Title&gt;Delete the Product&lt;/Modal.Title&gt;
          &lt;/Modal.Header&gt;
          &lt;Modal.Body&gt;Are you sure?&lt;/Modal.Body&gt;
          &lt;Modal.Footer&gt;
            &lt;Button variant="secondary" onClick={() =&gt; handleClose()}&gt;
              Close
            &lt;/Button&gt;
            &lt;Button variant="primary" onClick={() =&gt; deleteProduct()}&gt;
              Yes, Do it.
            &lt;/Button&gt;
          &lt;/Modal.Footer&gt;
        &lt;/Modal&gt;
      ) : (
        ""
      )}
    &lt;/&gt;
  );
};

function removeProduct(products, i) {
  return [...products.slice(0, i), ...products.slice(i + 1)];
}

export default DeleteModal;</pre>
<p>这个模态接收两个属性作为道具:决定模态是否应该显示的布尔值和被选择进行编辑的用户的<code>id</code>。</p>
<p>注意<code>useRecoilState</code>功能的使用。它相当于React的<code>useState</code>，分别检索州的产品列表和它的setter函数。</p>
<p>之后，我们循环产品列表，根据在<code>props</code>中收到的ID以及在同一个数组中的<code>index</code>来查找产品。这些值将有助于其他功能。</p>
<p><code>deleteProduct</code>函数只是在反冲状态下替换由<code>removeProduct</code>函数返回的更新列表。该函数又从数组中删除相应的乘积，给出作为参数传递的索引。</p>
<p>确保总是在通过<code>handleClose</code>功能完成目标后关闭模态。</p>
<p>现在，进入第二个模态，即<code>EditModal.js</code>:</p>
<pre>import React, { useState } from "react";
import { Button, Form, Modal } from "react-bootstrap";
import { useRecoilState } from "recoil";
import { products } from "../../store";

const EditModal = (props) =&gt; {
  const { show, id, handleClose } = props;

  const [productList, setProductList] = useRecoilState(products);
  const product = productList.length
    ? productList.find((item) =&gt; item.id === id)
    : null;
  const index = productList.findIndex((item) =&gt; item === product);

  const [name, setName] = useState("");
  const [color, setColor] = useState("");
  const [size, setSize] = useState(0.0);
  const [quantity, setQuantity] = useState(0);

  const onChangeName = (e) =&gt; {
    setName(e.target.value);
  };

  const onChangeColor = (e) =&gt; {
    setColor(e.target.value);
  };

  const onChangeSize = (e) =&gt; {
    setSize(e.target.value);
  };

  const onChangeQuantity = (e) =&gt; {
    setQuantity(e.target.value);
  };

  const updateProduct = () =&gt; {
    const newList = replaceProduct(productList, index, {
      ...product,
      name: name,
      color: color,
      size: size,
      quantity: quantity,
    });

    setProductList(newList);
    handleClose();
  };

  return (
    &lt;&gt;
      {product ? (
        &lt;Modal show={show} onHide={handleClose}&gt;
          &lt;Modal.Header closeButton&gt;
            &lt;Modal.Title&gt;Edit the Product&lt;/Modal.Title&gt;
          &lt;/Modal.Header&gt;
          &lt;Modal.Body&gt;
            &lt;Form&gt;
              &lt;Form.Group controlId="name"&gt;
                &lt;Form.Label&gt;Name&lt;/Form.Label&gt;
                &lt;Form.Control
                  type="text"
                  placeholder="Enter the Product Name"
                  defaultValue={product.name}
                  onChange={(e) =&gt; onChangeName(e)}
                /&gt;
              &lt;/Form.Group&gt;

              &lt;Form.Group controlId="color"&gt;
                &lt;Form.Label&gt;Color&lt;/Form.Label&gt;
                &lt;Form.Control
                  type="text"
                  placeholder="Enter the Product Color"
                  defaultValue={product.color}
                  onChange={(e) =&gt; onChangeColor(e)}
                /&gt;
              &lt;/Form.Group&gt;

              &lt;Form.Group controlId="size"&gt;
                &lt;Form.Label&gt;Size&lt;/Form.Label&gt;
                &lt;Form.Control
                  type="number"
                  placeholder="Enter the Product Size"
                  defaultValue={product.size}
                  onChange={(e) =&gt; onChangeSize(e)}
                /&gt;
              &lt;/Form.Group&gt;

              &lt;Form.Group controlId="quantity"&gt;
                &lt;Form.Label&gt;Quantity&lt;/Form.Label&gt;
                &lt;Form.Control
                  type="number"
                  placeholder="Enter the Product Quantity"
                  defaultValue={product.quantity}
                  onChange={(e) =&gt; onChangeQuantity(e)}
                /&gt;
              &lt;/Form.Group&gt;
            &lt;/Form&gt;
          &lt;/Modal.Body&gt;
          &lt;Modal.Footer&gt;
            &lt;Button variant="secondary" onClick={() =&gt; handleClose()}&gt;
              Close
            &lt;/Button&gt;
            &lt;Button variant="primary" onClick={() =&gt; updateProduct()}&gt;
              Save Changes
            &lt;/Button&gt;
          &lt;/Modal.Footer&gt;
        &lt;/Modal&gt;
      ) : (
        ""
      )}
    &lt;/&gt;
  );
};

function replaceProduct(products, i, newVal) {
  return [...products.slice(0, i), newVal, ...products.slice(i + 1)];
}

export default EditModal;</pre>
<p>它的大部分内容与形式构成有关。我们的表单中有四个字段，每个字段都必须有一个本地状态表示(通过钩子)作为常量。这样，我们可以在将它们发送到反冲状态之前操纵它们的值。</p>
<p>每个字段还必须有其对应的<code>onChangeXX</code>函数，该函数会根据用户输入的内容来刷新它们的值。注意，我们还引用了同一个产品的列表、索引和setter函数，就像我们在另一个模型中所做的那样。</p><div class="code-block code-block-54">
<hr/>
<h3>更多来自LogRocket的精彩文章:</h3>

<hr/></div>
<p><code>updateProduct</code>功能通过产生新列表(带有用户在模态字段中输入的更新值)并将其设置为反冲状态来起作用。对于这个任务，它使用了清单末尾的助手函数<code>replaceProduct</code>。</p>
<h2>列出产品</h2>
<p>我们的应用程序中的列表栏将负责显示模态，这些模态将依次被每个相应的动作按钮触发。</p>
<p>这是<code>ListProduct.js</code>文件的内容:</p>
<pre>import React, { useState } from "react";
import { Table, Button } from "react-bootstrap";

import { useRecoilValue, useResetRecoilState } from "recoil";
import { filterProducts, filterProductsValue, products } from "../store";
import EditModal from "./modals/EditModal";
import DeleteModal from "./modals/DeleteModal";

const ListProducts = () =&gt; {
  const productsState = useRecoilValue(filterProducts);
  const resetList = useResetRecoilState(products);
  const resetfilterProductsValue = useResetRecoilState(filterProductsValue);

  // Modals
  const [showEdit, setShowEdit] = useState(false);
  const [showDelete, setShowDelete] = useState(false);
  const [userId4Actions, setUserId4Actions] = useState(0);

  const handleEditClose = () =&gt; setShowEdit(false);
  const handleEditShow = () =&gt; setShowEdit(true);

  const handleDeleteClose = () =&gt; setShowDelete(false);
  const handleDeleteShow = () =&gt; setShowDelete(true);

  const resetAtoms = () =&gt; {
    resetList();
    resetfilterProductsValue();
  };

  const editProduct = (id) =&gt; {
    handleEditShow();
    setUserId4Actions(id);
  };

  const deleteProduct = (id) =&gt; {
    handleDeleteShow();
    setUserId4Actions(id);
  };

  return (
    &lt;&gt;
      &lt;h3&gt;List&lt;/h3&gt;

      &lt;Table striped bordered hover responsive&gt;
        &lt;thead&gt;
          &lt;tr&gt;
            &lt;th&gt;Name&lt;/th&gt;
            &lt;th&gt;Color&lt;/th&gt;
            &lt;th&gt;Size&lt;/th&gt;
            &lt;th&gt;Quantity&lt;/th&gt;
            &lt;th&gt;Actions&lt;/th&gt;
          &lt;/tr&gt;
        &lt;/thead&gt;
        &lt;tbody&gt;
          {!productsState.length ? (
            &lt;tr&gt;
              &lt;td colSpan="5" style={{ textAlign: "center" }}&gt;
                No products here.
              &lt;/td&gt;
            &lt;/tr&gt;
          ) : (
            productsState.map((item, index) =&gt; (
              &lt;tr key={item.id}&gt;
                &lt;td&gt;{item.name}&lt;/td&gt;
                &lt;td&gt;{item.color}&lt;/td&gt;
                &lt;td&gt;{item.size}&lt;/td&gt;
                &lt;td&gt;{item.quantity}&lt;/td&gt;
                &lt;td colSpan="2"&gt;
                  &lt;Button
                    variant="secondary"
                    onClick={() =&gt; editProduct(item.id)}
                  &gt;
                    Edit
                  &lt;/Button&gt;{" "}
                  {" | "}
                  &lt;Button
                    variant="danger"
                    onClick={() =&gt; deleteProduct(item.id)}
                  &gt;
                    Delete
                  &lt;/Button&gt;
                &lt;/td&gt;
              &lt;/tr&gt;
            ))
          )}
        &lt;/tbody&gt;
      &lt;/Table&gt;

      &lt;Button variant="secondary" size="lg" onClick={() =&gt; resetAtoms()}&gt;
        Clear Data
      &lt;/Button&gt;

      &lt;EditModal
        show={showEdit}
        id={userId4Actions}
        handleClose={handleEditClose}
      /&gt;

      &lt;DeleteModal
        show={showDelete}
        id={userId4Actions}
        handleClose={handleDeleteClose}
      /&gt;
    &lt;/&gt;
  );
};

export default ListProducts;</pre>
<p>这里的主要目标是在一个引导表中展示产品列表。注意，这里我们通过<code>useRecoilValue</code>函数以不同的方式从反冲状态中恢复产品列表。它只返回存储区中的当前值，没有设置器。右下方的另外两个用于重置状态值。</p>
<p>接下来，我们有显示和隐藏模态的辅助常数。我们将在清单代码中管理这个功能，通过props传递各自的值。</p>
<p>然后，我们有三个主要功能:</p>
<ol>
<li><code>resetAtoms</code>–顾名思义，它们利用反冲重置功能将列表和搜索文本重置为初始值</li>
<li><code>editProduct</code>–切换编辑模式并将当前用户的ID设置为本地状态</li>
<li><code>deleteProduct</code>–切换删除模式并将当前用户的ID设置为本地状态</li>
</ol>
<p>在<code>render</code>函数中，注意我们还检查产品列表的存在，以便显示正确的消息。</p>
<h2>添加表单</h2>
<p>现在是实现<code>AddProduct</code>组件的时候了，该组件将向列表提供表单中的产品值。</p>
<p>以下是<code>AddProduct.js</code>文件的内容:</p>
<pre>import React, { useState } from "react";
import { Button, Form } from "react-bootstrap";

import { useSetRecoilState } from "recoil";
import { v4 as uuid4 } from "uuid";
import { products } from "../store";

const AddProduct = () =&gt; {
  const [name, setName] = useState("");
  const [color, setColor] = useState("");
  const [size, setSize] = useState(0.0);
  const [quantity, setQuantity] = useState(0);
  const setProducts = useSetRecoilState(products);

  const onChangeName = (e) =&gt; {
    setName(e.target.value);
  };

  const onChangeColor = (e) =&gt; {
    setColor(e.target.value);
  };

  const onChangeSize = (e) =&gt; {
    setSize(e.target.value);
  };

  const onChangeQuantity = (e) =&gt; {
    setQuantity(e.target.value);
  };

  const addProduct = () =&gt; {
    setProducts((oldList) =&gt; [
      ...oldList,
      {
        id: uuid4(),
        name: name,
        color: color,
        size: size,
        quantity: quantity,
      },
    ]);

    resetForm();
  };

  const resetForm = () =&gt; {
    setName("");
    setColor("");
    setSize(0.0);
    setQuantity(0);
  };

  return (
    &lt;Form&gt;
      &lt;Form.Group controlId="name"&gt;
        &lt;Form.Label&gt;Name:&lt;/Form.Label&gt;
        &lt;Form.Control
          type="text"
          value={name}
          placeholder="Enter the Product Name"
          onChange={(e) =&gt; onChangeName(e)}
        /&gt;
      &lt;/Form.Group&gt;

      &lt;Form.Group controlId="color"&gt;
        &lt;Form.Label&gt;Color:&lt;/Form.Label&gt;
        &lt;Form.Control
          type="text"
          value={color}
          placeholder="Enter the Product Color"
          onChange={(e) =&gt; onChangeColor(e)}
        /&gt;
      &lt;/Form.Group&gt;

      &lt;Form.Group controlId="size"&gt;
        &lt;Form.Label&gt;Size:&lt;/Form.Label&gt;
        &lt;Form.Control
          type="number"
          value={size}
          placeholder="Enter the Product Size"
          onChange={(e) =&gt; onChangeSize(e)}
        /&gt;
      &lt;/Form.Group&gt;

      &lt;Form.Group controlId="quantity"&gt;
        &lt;Form.Label&gt;Quantity:&lt;/Form.Label&gt;
        &lt;Form.Control
          type="number"
          value={quantity}
          placeholder="Enter the Product Quantity"
          onChange={(e) =&gt; onChangeQuantity(e)}
        /&gt;
      &lt;/Form.Group&gt;

      &lt;Button variant="primary" size="lg" onClick={() =&gt; addProduct()}&gt;
        Add
      &lt;/Button&gt;
    &lt;/Form&gt;
  );
};

export default AddProduct;</pre>
<p>创建表单与编辑模式非常相似，因为这里也有相同的字段。我们有相同的<code>onChange</code>函数，以及本地状态属性。</p>
<p>函数<code>addProduct</code>添加新产品，将更新后的数组设置为反冲状态，并重置表单。</p>
<p>到目前为止，根据前面组件的知识，这里没有太多要添加的。</p>
<h2>过滤产品</h2>
<p>过滤器组件也非常简单。它由一个收集过滤文本的文本字段和一个清除过滤文本的按钮组成。过滤将在对字段的任何改变下执行，而不是普通的按钮点击。</p>
<p>这是<code>FilterProducts.js</code>文件:</p>
<pre>import React from "react";
import { useRecoilState } from "recoil";

import { filterProductsValue } from "../store";
import { Form, Button } from "react-bootstrap";

const FilterProducts = () =&gt; {
  const [filterProductsState, filterProducts] = useRecoilState(
    filterProductsValue
  );

  const filter = (event) =&gt; {
    const { value } = event.target;
    filterProducts(value);
  };

  const clearFilter = () =&gt; filterProducts("");

  return (
    &lt;Form&gt;
      &lt;Form.Group controlId="name"&gt;
        &lt;Form.Label&gt;Filter:&lt;/Form.Label&gt;
        &lt;Form.Control
          type="text"
          placeholder="Filter by Product Name"
          value={filterProductsState}
          onChange={(e) =&gt; filter(e)}
        /&gt;
      &lt;/Form.Group&gt;

      &lt;Button variant="info" onClick={() =&gt; clearFilter()}&gt;
        Clear Filter
      &lt;/Button&gt;
    &lt;/Form&gt;
  );
};

export default FilterProducts;</pre>
<p>最后，我们只需要在应用程序的根文件<code>App.js</code>中组织组件。</p>
<p>将以下代码放入其中:</p>
<pre>import React from "react";
import Container from "react-bootstrap/Container";
import { Row, Col } from "react-bootstrap";

import AddProduct from "./components/AddProduct";
import FilterProducts from "./components/FilterProducts";
import ListProducts from "./components/ListProducts";

function App() {
  return (
    &lt;Container className="p-3"&gt;
      &lt;div className="py-5 text-center"&gt;
        &lt;h1&gt;Product's CRUD&lt;/h1&gt;
        &lt;p className="lead"&gt;
          Go ahead and play with a CRUD made with React, Bootstrap and Recoil.js
        &lt;/p&gt;
      &lt;/div&gt;
      &lt;Row&gt;
        &lt;Col&gt;
          &lt;AddProduct /&gt;
        &lt;/Col&gt;
        &lt;Col className="col-8"&gt;
          &lt;FilterProducts /&gt;
          &lt;hr /&gt;
          &lt;ListProducts /&gt;
        &lt;/Col&gt;
      &lt;/Row&gt;
    &lt;/Container&gt;
  );
}

export default App;</pre>
<p>这里没什么特别的，只是普通的代码。您可以随意处理组件的配置，只需知道每个组件如何适应基于react-bootstrap CSS类的屏幕。</p>
<h2>结论</h2>
<p>就这样——现在是你试验这个例子的时候了。只需运行通常的<code>npm start</code>并检查在浏览器中运行的示例。</p>
<p>同样，反冲代码中React的味道对lib是一个很好的补充，尤其是如果你已经在使用React钩子的话。</p>
<p>事实上，别忘了查看一下官方文件。他们不仅会在现在，而且会在每一个主要版本发布后引导你了解这个库是如何运作的，以及你如何从中获得最大的利益。</p>
<p>你可以在我的GitHub中的这里找到这个例子的代码。</p><div class="code-block code-block-17">
<div class="blog-plug inline-plug react-plug" vwo-el-id="26283398190">
<h2 vwo-el-id="41600691720">使用LogRocket消除传统反应错误报告的噪音</h2>
<a href="https://lp.logrocket.com/blg/react-signup-issue-free" target="_blank" vwo-el-id="19356441070">LogRocket
</a><p>是一款React analytics解决方案，可保护您免受数百个误报错误警报的影响，只针对少数真正重要的项目。LogRocket告诉您React应用程序中实际影响用户的最具影响力的bug和UX问题。</p><a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="19356441380">
<img class="first-react-image alignnone size-full wp-image-46 jetpack-lazy-image jetpack-lazy-image--handled" src="../Images/f300c244a1a1cf916df8b4cb02bec6c6.png" vwo-el-id="18272717540" data-lazy-loaded="1" data-original-src="https://files.readme.io/27c94e7-Image_2017-06-05_at_9.46.04_PM.png"/>
</a>
<a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="19356441690">
<img class="second-react-image alignnone size-full wp-image-46 jetpack-lazy-image jetpack-lazy-image--handled" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" vwo-el-id="30720362350" data-lazy-loaded="1" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/>
</a>
<a href="https://lp.logrocket.com/blg/react-signup-issue-free" target="_blank" rel="noopener noreferrer" vwo-el-id="35866400580">LogRocket
</a><p>自动聚合客户端错误、反应错误边界、还原状态、缓慢的组件加载时间、JS异常、前端性能指标和用户交互。然后，LogRocket使用机器学习来通知您影响大多数用户的最具影响力的问题，并提供您修复它所需的上下文。</p><p vwo-el-id="28675661060">关注重要的React bug—<a class="signup" href="https://lp.logrocket.com/blg/react-signup-issue-free" target="_blank" rel="noopener noreferrer" vwo-el-id="40093418840">今天就试试LogRocket】。</a></p>
</div></div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
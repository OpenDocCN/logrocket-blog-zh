<html>
<head>
<title>Improving JavaScript performance with GPU.js - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>使用GPU.js提高JavaScript性能- LogRocket博客</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/improving-javascript-performance-with-gpu-js/#0001-01-01">https://blog.logrocket.com/improving-javascript-performance-with-gpu-js/#0001-01-01</a></blockquote><div><article class="article-post">
<p>你有没有尝试过运行复杂的计算或运算，却发现它花费了你无穷无尽的时间，减慢了你的进程？</p>
<p>有很多方法可以解决这个问题，比如使用web workers或者后台线程。GPU从你的CPU中带走处理负载，给你的CPU更多空间用于其他进程。与此同时，web workers仍然在您的CPU上运行，但是在不同的线程上。</p>
<p>在这本初学者指南中，我们将演示如何使用<a href="https://gpu.rocks/#/" target="_blank" rel="noopener noreferrer"> GPU.js </a>来执行复杂的数学计算，并提高JavaScript应用的性能。</p>
<h2 id="whatisgpujs">GPU.js是什么？</h2>
<p>GPU.js是为web构建的JavaScript加速库，Node.js用于图形处理单元(GPGPU)上的通用编程。它允许您将复杂和耗时的计算交给GPU，而不是CPU，以获得更快的计算和操作。还有一个后备选项:在GPU不在您的系统上的情况下，这些函数仍将在您的常规JavaScript引擎上运行。</p>
<p>当您的系统需要执行复杂的计算时，您实际上是将这一负担交给了系统的GPU，而不是CPU，从而提高了处理速度和时间。</p>
<p>高性能计算是使用GPU.js的主要优势之一。如果您希望在没有任何WebGL知识的情况下在浏览器中开始并行计算，GPU.js是您的理想选择。</p>
<h2 id="whyyoushouldusegpujs">为什么应该使用GPU.js</h2>
<p>有数不清的理由让你应该使用GPU来执行复杂的计算，太多了，无法在一篇文章中探究。下面是使用GPU的一些最值得注意的好处。</p>
<ul>
<li>GPU可用于执行大规模并行GPGPU计算。这就是需要异步完成的计算类型</li>
<li>当GPU在系统中不可用时，它优雅地退回到JavaScript</li>
<li>GPU目前运行在浏览器和Node.js上，这是加速计算繁重的网站的理想选择</li>
<li>构建GPU.js时考虑了JavaScript，因此函数使用合法的JavaScript语法</li>
</ul>
<p>如果你认为你的处理器能够胜任这个任务，并且你不需要GPU.js，看看下面用这个GPU和CPU运行计算的结果。</p>
<figure id="attachment_28716" aria-describedby="caption-attachment-28716" class="wp-caption aligncenter"><img data-attachment-id="28716" data-permalink="https://blog.logrocket.com/improving-javascript-performance-with-gpu-js/gpujs-texture-mode/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/11/gpujs-texture-mode.png" data-orig-size="730,562" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="GPU.js texture mode" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/11/gpujs-texture-mode-300x231.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/11/gpujs-texture-mode.png" decoding="async" class="wp-image-28716 size-full jetpack-lazy-image" src="../Images/535703a68c0a12c64fa0b8fd7e2d88ae.png" alt="GPU.js Texture Mode" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2020/11/gpujs-texture-mode.png 730w, https://blog.logrocket.com/wp-content/uploads/2020/11/gpujs-texture-mode-300x231.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2020/11/gpujs-texture-mode.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/11/gpujs-texture-mode.png"/><noscript><img data-lazy-fallback="1" data-attachment-id="28716" data-permalink="https://blog.logrocket.com/improving-javascript-performance-with-gpu-js/gpujs-texture-mode/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/11/gpujs-texture-mode.png" data-orig-size="730,562" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="GPU.js texture mode" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/11/gpujs-texture-mode-300x231.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/11/gpujs-texture-mode.png" decoding="async" loading="lazy" class="wp-image-28716 size-full" src="../Images/535703a68c0a12c64fa0b8fd7e2d88ae.png" alt="GPU.js Texture Mode" srcset="https://blog.logrocket.com/wp-content/uploads/2020/11/gpujs-texture-mode.png 730w, https://blog.logrocket.com/wp-content/uploads/2020/11/gpujs-texture-mode-300x231.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/11/gpujs-texture-mode.png"/></noscript><figcaption id="caption-attachment-28716" class="wp-caption-text">Source: <a href="https://hackernoon.com/hn-images/1*FHKg0VBQi_S-sMlLKdJ-MQ.png">Hackernoon</a></figcaption></figure>
<p>可以看到，GPU比CPU快22.97倍。</p>
<h2 id="howgpujsworks">GPU.js如何工作</h2>
<p>考虑到这种速度水平，JavaScript生态系统就好像有了一个可以乘坐的火箭。GPU帮助网站加载速度更快，尤其是那些必须在首页执行复杂计算的网站。你不再需要担心使用后台线程和加载程序，因为GPU运行计算的速度比普通CPU快22.97倍。</p>
<p><code>gpu.createKernel</code>方法从一个JavaScript函数创建一个GPU加速内核。</p>
<p>将内核函数与GPU并行运行会加快计算速度，根据硬件的不同，速度会提高1到15倍。</p>
<h2 id="gettingstartedwithgpujs">GPU.js入门</h2>
<p>为了展示如何使用GPU.js更快地计算一个复杂的计算，让我们来做一个快速、实用的演示。</p>
<p>安装:</p>
<pre>sudo apt install mesa-common-dev libxi-dev  // using Linux
</pre>
<p>npm:</p>
<pre>npm install gpu.js --save

// OR

yarn add gpu.js
</pre>
<p>在您的节点项目中需要GPU.js。</p>
<pre>import { GPU } from ('gpu.js')

// OR
const { GPU } = require('gpu.js')

const gpu = new GPU();
</pre>
<h2 id="multiplicationdemo">乘法演示</h2>
<p>在下面的例子中，计算是在GPU上并行完成的。</p>
<p>首先，生成大量数据。</p>
<pre>  const getArrayValues = () =&gt; {

    //Create 2D arrary here
    const values = [[], []]

    // Insert Values into first array
    for (let y = 0; y &lt; 600; y++){
      values[0].push([])
      values[1].push([])

      // Insert values into second array
      for (let x = 0; x &lt; 600; x++){
        values\[0\][y].push(Math.random())
        values\[1\][y].push(Math.random())
      }
    }

    //Return filled array
    return values
  }
</pre>
<p>创建内核(运行在GPU上的函数的另一种说法)。</p>
<pre>  const gpu = new GPU();

  // Using `createKernel()` method to multiply the array
  const multiplyLargeValues = gpu.createKernel(function(a, b) {
    let sum = 0;
    for (let i = 0; i &lt; 600; i++) {
      sum += a\[this.thread.y\][i] * b\[i\][this.thread.x];
    }
    return sum;
  }).setOutput([600, 600])
</pre>
<p>用矩阵作为参数调用内核。</p>
<pre>  const largeArray = getArrayValues()
  const out = multiplyLargeValues(largeArray[0], largeArray[1])
</pre>
<p>输出:</p>
<pre>console.log(out\[y\][x]) // Logs the element at the xth row and the yth column of the array
console.log(out\[10\][12]) // Logs the element at the 10th row and the 12th column of the output array
</pre>
<h2 id="runninggpubenchmarks">运行GPU基准测试</h2>
<p>您可以按照<a href="https://github.com/gpujs/benchmark" target="_blank" rel="noopener noreferrer"> GitHub </a>上指定的步骤运行您的基准。</p>
<pre>npm install @gpujs/benchmark

const benchmark = require('@gpujs/benchmark')

const benchmarks = benchmark.benchmark(options);
</pre>
<p><code>options</code>对象包含可以传递给基准的各种配置。</p><div class="code-block code-block-54">
<hr/>
<h3>更多来自LogRocket的精彩文章:</h3>

<hr/></div>
<p>前往GPU.js官方网站查看完整的计算基准。这将有助于您理解使用GPU.js进行复杂计算可以获得多少速度。</p>
<h2 id="conclusion">结论</h2>
<p>在本教程中，我们详细探讨了GPU.js，分析了它的工作原理，并演示了如何执行并行计算。我们还展示了如何在Node.js应用程序中设置GPU.js。</p>
<p>继续编码！</p><div class="code-block code-block-28">
<div class="blog-plug inline-plug js-libraries-plug"><h2>您是否添加了新的JS库来提高性能或构建新特性？如果他们反其道而行之呢？</h2><p>毫无疑问，前端变得越来越复杂。当您向应用程序添加新的JavaScript库和其他依赖项时，您将需要更多的可见性，以确保您的用户不会遇到未知的问题。</p>
<p>LogRocket 是一个前端应用程序监控解决方案，可以让您回放JavaScript错误，就像它们发生在您自己的浏览器中一样，这样您就可以更有效地对错误做出反应。</p><a class="signup" href="https://lp.logrocket.com/blg/javascript-signup" target="_blank" rel="noopener noreferrer"><img class="alignnone size-full wp-image-46 jetpack-lazy-image" src="../Images/e8a0ab42befa3b3b1ae08c1439527dc6.png" alt="LogRocket Dashboard Free Trial Banner" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2019/10/errors-screenshot.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/10/errors-screenshot.png"/><noscript><img data-lazy-fallback="1" class="alignnone size-full wp-image-46" src="../Images/e8a0ab42befa3b3b1ae08c1439527dc6.png" alt="LogRocket Dashboard Free Trial Banner" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/10/errors-screenshot.png"/></noscript></a>
<a href="https://lp.logrocket.com/blg/javascript-signup" target="_blank" rel="noopener noreferrer">https://logrocket.com/signup/</a><p><a href="https://lp.logrocket.com/blg/javascript-signup" target="_blank" rel="noopener noreferrer"> LogRocket </a>可以与任何应用程序完美配合，不管是什么框架，并且有插件可以记录来自Redux、Vuex和@ngrx/store的额外上下文。您可以汇总并报告问题发生时应用程序的状态，而不是猜测问题发生的原因。LogRocket还可以监控应用的性能，报告客户端CPU负载、客户端内存使用等指标。</p><p>自信地构建— <a class="signup" href="https://lp.logrocket.com/blg/javascript-signup" target="_blank" rel="noopener noreferrer">开始免费监控</a>。</p></div>


</div>

<p class="clearfix"/>
<p class="clearfix"/>
 </article>

</div>    
</body>
</html>
<html>
<head>
<title>Procedural macros in Rust - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>Rust - LogRocket博客中的过程宏</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/procedural-macros-in-rust/#0001-01-01">https://blog.logrocket.com/procedural-macros-in-rust/#0001-01-01</a></blockquote><div><article class="article-post">
<p>如果您使用Rust已经有一段时间了，那么您可能会遇到过程宏，或者简称为proc宏，不管您是否意识到了这一点。最流行的proc宏很可能是<a href="https://serde.rs/"> Serde的</a>为<a href="https://blog.logrocket.com/rust-serialization-whats-ready-for-production-today/" target="_blank" rel="noopener"> <code>serialize</code>和<code>deserialize</code> </a>派生的宏；如果你曾经使用过<a href="https://rocket.rs/" target="_blank" rel="noopener">Rocket web framework</a>、<a href="https://github.com/rustwasm/wasm-bindgen" target="_blank" rel="noopener"> wasm-bindgen项目</a>或者任何数量的其他库，你可能也会遇到它们。</p>
<p/>
<p>在本教程中，我们将告诉你你需要知道的关于Rust中程序宏的一切。我们将讨论以下内容:</p>

<h2 id="whatare">Rust中的程序宏是什么？</h2>
<p>简而言之，<a href="https://blog.rust-lang.org/2018/12/21/Procedural-Macros-in-Rust-2018.html" target="_blank" rel="noopener">过程宏</a>允许你获取一段Rust代码，分析它，并从中生成更多Rust代码。这是元编程的一种形式，一种使用Rust编写Rust代码的方式。</p>
<p>在《星球大战II:克隆人的进攻》中，机器人C-3PO跌跌撞撞地走过一家机器人制造厂，说道:“机器制造机器？多么乖张。”</p>
<p>就我个人而言，我会说“棒极了”，但这可能是一个品味问题。</p>
<p>Anyway, proc macros allow you to generate Rust code at compile time. It’s a fairly advanced topic, but a very, very powerful feature of the Rust language.</p>
<h3 id="declarativemacros">声明宏和过程宏</h3>
<p>Rust有两种不同的宏:声明性宏(用<code>macro_rules!</code>声明)和过程性宏。这两种类型的宏都允许您编写更多代码，并在编译时进行评估，但它们的工作方式非常不同。</p>
<p><a href="https://doc.rust-lang.org/book/ch15-04-rc.html" target="_blank" rel="noopener">声明性宏</a>(通俗地说——有些令人困惑——简称为“宏”)使您能够编写类似于<code>match</code>表达式的东西，对您作为参数提供的Rust代码进行操作。它使用您提供的代码来生成替换宏调用的代码。从某种意义上说，<a href="https://blog.thomasheartman.com/posts/save-on-typing-and-improve-legibility-with-rusts-macros" target="_blank" rel="noopener">声明性宏只是复杂的文本替换</a>。</p>
<p><iframe loading="lazy" src="https://www.youtube.com/embed/q6paRBbLgNw" frameborder="0" allowfullscreen="allowfullscreen">视频</iframe></p>
<p>另一方面，过程宏允许您对给出的Rust代码的抽象语法树(AST)进行操作。就函数签名而言，proc宏是从一个<code>TokenStream</code>(或两个)到另一个<code>TokenStream</code>的函数，其中输出代替了宏调用。这允许您在编译时检查Rust代码，并基于程序的AST促进复杂的代码生成。</p>
<p>简而言之，声明性宏允许您匹配代码模式，并基于该模式生成代码。过程性宏允许您在生成输出之前检查和操作提供给您的代码，这给了您更多的能力。</p>
<h3 id="derivefunction">派生、类函数和属性宏</h3>
<p>有三种类型的<a href="https://doc.rust-lang.org/reference/procedural-macros.html" target="_blank" rel="noopener">程序宏</a>:派生宏、类功能宏和属性宏。它们都在<code>TokenStreams</code>上操作，但操作方式略有不同。</p>
<ul>
<li>派生宏作用于结构、枚举和联合，并使用<code>#[derive(MyMacro)]</code>声明进行注释。它们还可以声明助手属性，这些属性可以附加到项的成员(如枚举变量或结构字段)</li>
<li>类似函数的宏类似于声明性宏，它们是用宏调用操作符<code>!</code> <span>调用的，看起来像函数调用。它们对你放在括号里的代码进行操作</span></li>
<li>属性宏定义新的外部属性，<span>，可以附加到项目上。它们类似于派生宏，但是可以附加到更多的项目上，比如特征定义和函数</span></li>
</ul>
<h2 id="creatingaderive">在Rust中创建衍生宏</h2>
<p>让我们把手弄脏一点。现在我们已经对什么是proc宏有了一个大致的概念，让我们创建一个简单的来感受一下。我们将创建一个derive宏，它打印有关它所附加的结构、枚举或联合的信息，包括它是哪种类型的项以及它有哪些成员或变量(如果有的话)。</p>
<p>创建程序宏板条箱时，你需要做的第一件事是让Cargo在你的<code>Cargo.toml</code>文件中知道这一点。您可以通过添加如下所示的条目来实现这一点:</p>
<pre class="toml language-toml">[lib]
proc-macro = true
</pre>
<p>在我们的例子中，为了测试这个宏，我们将使用Cargo的workspaces特性，并创建一个主可执行文件(<code>main.rs</code>)和一个保存proc宏的库(<code>derive-macro/src/lib.rs</code>)。整个目录结构如下所示:</p>
<pre>.
├── Cargo.toml
├── derive-macro
│   ├── Cargo.toml
│   └── src
│       └── lib.rs
└── main.rs
&gt;</pre>
<p>顶层的<code>Cargo.toml</code>文件包含关于我们的二进制文件及其依赖项的信息:</p>
<pre class="toml language-toml">[package]
name = "proc_macros"
version = "0.1.0"
edition = "2018"
publish = false

[workspace]

[[bin]]
name = "proc-macros"
path = "main.rs"

[dependencies]
derive-macro = { path = "derive-macro" }
</pre>
<p><code>derive-macro/Cargo.toml</code>包含proc宏项目的依赖项以及前面提到的<code>proc-macro = true</code>注释。</p>
<pre class="toml language-toml">[package]
name = "derive-macro"
version = "0.1.0"
edition = "2018"

[lib]
proc-macro = true

[dependencies]
syn = { version = "1.0", features = ["full"] }
quote = "1.0"
proc-macro2 = "1.0"
</pre>
<h2 id="writingaprocedural">在Rust中编写程序宏</h2>
<p>对编写proc宏的全面介绍超出了本文的范围。相反，请参考本教程末尾提到的<a href="#furtherreading">资源</a>。</p>
<p>不过，我要做的是用<a href="https://docs.rs/syn/1.0.53/syn/" target="_blank" rel="noopener"> <code>syn</code> </a>、<a href="https://docs.rs/quote/1.0.7/quote/" target="_blank" rel="noopener"> <code>quote</code> </a>和<a href="https://docs.rs/proc-macro2/0.4.30/proc_macro2/" target="_blank" rel="noopener"> <code>proc_macro2</code> </a>板条箱给你看一个简单的例子。当使用proc宏时，这些是你的面包和黄油。</p>
<p>如前所述，我们希望我们的宏描述它所附加的项目。让我们看看这是如何在<code>derive-macro/src/lib.rs</code>中处理的:</p>
<pre class="rust language-rust">use proc_macro::{self, TokenStream};
use quote::quote;
use syn::{parse_macro_input, DataEnum, DataUnion, DeriveInput, FieldsNamed, FieldsUnnamed};

#[proc_macro_derive(Describe)]
pub fn describe(input: TokenStream) -&gt; TokenStream {
    let DeriveInput { ident, data, .. } = parse_macro_input!(input);

    let description = match data {
    syn::Data::Struct(s) =&gt; match s.fields {
        syn::Fields::Named(FieldsNamed { named, .. }) =&gt; {
        let idents = named.iter().map(|f| &amp;f.ident);
        format!(
            "a struct with these named fields: {}",
            quote! {#(#idents), *}
        )
        }
        syn::Fields::Unnamed(FieldsUnnamed { unnamed, .. }) =&gt; {
        let num_fields = unnamed.iter().count();
        format!("a struct with {} unnamed fields", num_fields)
        }
        syn::Fields::Unit =&gt; format!("a unit struct"),
    },
    syn::Data::Enum(DataEnum { variants, .. }) =&gt; {
        let vs = variants.iter().map(|v| &amp;v.ident);
        format!("an enum with these variants: {}", quote! {#(#vs),*})
    }
    syn::Data::Union(DataUnion {
        fields: FieldsNamed { named, .. },
        ..
    }) =&gt; {
        let idents = named.iter().map(|f| &amp;f.ident);
        format!("a union with these named fields: {}", quote! {#(#idents),*})
    }
    };

    let output = quote! {
    impl #ident {
        fn describe() {
        println!("{} is {}.", stringify!(#ident), #description);
        }
    }
    };

    output.into()
}
</pre>
<p>第一步是把我们收到的<code>TokenStream</code>作为一个参数。我们使用<code>syn</code>的<a href="https://docs.rs/syn/1.0.52/syn/macro.parse_macro_input.html"> <code>parse_macro_input</code> </a>宏来解析它。这使我们能够访问<code>ident</code>(该项目的标识符、名称)和关于该项包含什么的数据。我们对这些数据进行匹配，以确定该项是结构、枚举还是联合。如果它是一个结构，我们做进一步的匹配来检查它是否有字段以及它们是否被命名。根据项目的种类，我们检查它的字段或变量，并创建一个描述它的字符串。</p>
<p>虽然<code>syn</code>箱给了我们解析传入的<code>TokenStream</code>并对其进行处理的能力，但是<code>quote</code>箱让我们生成新的Rust代码。<a href="https://docs.rs/quote/1.0.7/quote/macro.quote.html" target="_blank" rel="noopener"> <code>quote</code>宏</a>可以让我们写出几乎规律的Rust代码，可以变成实际的Rust代码。奇怪的语法(如<code>quote! {#(#idents), *}</code>)是我们如何做变量插值和重复。</p>
<p>对于这个宏，让我们把它放在<code>main.rs</code>文件中:</p>
<pre class="rust language-rust">use derive_macro::Describe;

#[derive(Describe)]
struct MyStruct {
    my_string: String,
    my_enum: MyEnum,
    my_number: f64,
}

#[derive(Describe)]
struct MyTupleStruct(u32, String, i8);

#[derive(Describe)]
enum MyEnum {
    VariantA,
    VariantB,
}

#[derive(Describe)]
union MyUnion {
    unsigned: u32,
    signed: i32,
}

fn main() {
    MyStruct::describe();
    MyTupleStruct::describe();
    MyEnum::describe();
    MyUnion::describe();
}
</pre>
<p>运行该程序将产生如下所示的输出。</p>
<pre>MyStruct is a struct with these named fields: my_string, my_enum, my_number.
MyTupleStruct is a struct with 3 unnamed fields.
MyEnum is an enum with these variants: VariantA, VariantB.
MyUnion is a union with these named fields: unsigned, signed.
</pre>
<h2 id="furtherreading"><span>延伸阅读</span></h2>
<p>过程宏是Rust语言的一个非常强大的特性，并且具有不可思议的潜力。但是它们也非常复杂，需要一些时间和深思熟虑的努力才能真正理解和适应。</p>
<p>本指南高度概括了它们是什么以及如何开始使用它们。如果你想往兔子洞更深处爬，我推荐以下资源:</p>

<p> </p>
<div class="code-block code-block-29">
<div class="blog-plug inline-plug rust-plug"><h2><a href="https://lp.logrocket.com/blg/rust-signup" target="_blank">log rocket</a>:Rust应用的web前端的全面可见性</h2><p>调试Rust应用程序可能很困难，尤其是当用户遇到难以重现的问题时。如果您对监控和跟踪Rust应用程序的性能、自动显示错误、跟踪缓慢的网络请求和加载时间感兴趣，</p><a href="https://lp.logrocket.com/blg/rust-signup" target="_blank">try LogRocket</a><p>. </p><a class="signup" href="https://lp.logrocket.com/blg/rust-signup" target="_blank" rel="noopener noreferrer"><img class="alignnone size-full wp-image-46 jetpack-lazy-image" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/><noscript><img data-lazy-fallback="1" class="alignnone size-full wp-image-46" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/></noscript></a><p>LogRocket 就像是网络和移动应用程序的DVR，记录你的Rust应用程序上发生的一切。您可以汇总并报告问题发生时应用程序的状态，而不是猜测问题发生的原因。LogRocket还可以监控应用的性能，报告客户端CPU负载、客户端内存使用等指标。</p><p>现代化调试Rust应用的方式— <a class="signup" href="https://lp.logrocket.com/blg/rust-signup" target="_blank" rel="noopener noreferrer">开始免费监控</a>。</p></div>


</div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
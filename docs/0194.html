<html>
<head>
<title>An intro to Zero Server, a new tool to simplify web development - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>零服务器介绍，简化web开发的新工具</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/an-intro-to-zero-server-a-new-tool-to-simplify-web-development-42bee961e5d1/#0001-01-01">https://blog.logrocket.com/an-intro-to-zero-server-a-new-tool-to-simplify-web-development-42bee961e5d1/#0001-01-01</a></blockquote><div><article class="article-post">
<p>Zero Server是一个应用捆绑器，用于简化web开发。它通过自动为您完成，消除了包裹管理和路由的麻烦。如<a class="markup--anchor markup--p-anchor" href="https://zeroserver.io/" target="_blank" rel="noopener noreferrer" data-href="https://zeroserver.io/">网站</a>所述:</p>
<blockquote><p>这就像在一个混合的<a href="https://github.com/remoteinterview/zero/blob/master/docs/nodejs/README.md" target="_blank" rel="noopener noreferrer"> Node.js </a>、<a href="https://github.com/remoteinterview/zero/blob/master/docs/react/README.md" target="_blank" rel="noopener noreferrer"> React </a>、<a href="https://github.com/remoteinterview/zero/blob/master/docs/html/README.md" target="_blank" rel="noopener noreferrer"> HTML </a>、<a href="https://github.com/remoteinterview/zero/blob/master/docs/mdx/README.md" target="_blank" rel="noopener noreferrer"> MDX </a>、<a href="https://github.com/remoteinterview/zero/blob/master/docs/vue/README.md" target="_blank" rel="noopener noreferrer"> Vue </a>和<a href="https://github.com/remoteinterview/zero/blob/master/docs/static/README.md" target="_blank" rel="noopener noreferrer">静态文件</a>中编写你的代码并把它们全部放在一个文件夹中一样简单。零将为他们所有人服务。Zero抽象了路由、捆绑和传输的常用项目配置，使其更容易开始。</p></blockquote>
<p>Zero Server提供了几个特性，使其成为开发下一个web应用程序的绝佳选择:</p>
<h3>自动配置</h3>
<p>您的项目文件夹不需要配置文件。您只需放置您的代码，它就会自动编译、打包并提供服务。</p>
<h3>基于文件系统的路由</h3>
<p>如果你的代码驻留在<code>./api/login.js</code>中，它在<code><a href="http://&lt;SERVER&gt;/api/login" rel="nofollow">http://&lt;SERVER&gt;/api/login</a></code>被暴露。</p>
<h3>自动依赖关系解析</h3>
<p>如果一个文件做了<code>require('underscore')</code>，它会自动安装并解析。您总是可以创建自己的<code>package.json</code>文件来安装软件包的特定版本。</p>
<h3>多种语言</h3>
<p>Zero旨在支持用多种语言编写的代码，所有代码都在一个项目下。想象一下:</p>
<ul>
<li>将Tensorflow模型作为Python API公开</li>
<li>使用React页面来消费它</li>
<li>在Node.js中编写用户登录代码</li>
<li>HTML或Markdown/MDX混合格式的登录页面</li>
</ul>
<p>您可以将所有这些作为单个web应用程序放在单个项目文件夹下。</p>
<h3>改进的错误处理</h3>
<p>每个端点都在自己的进程中运行。因此，如果<code>/api/login</code>由于某种原因崩溃，它不会影响<code>/chatroom</code>页面或<code>/api/chat</code> API。当下一个用户访问崩溃的端点时，它们会自动重新启动。</p>
<p>在本教程中，我们将学习如何使用零服务器建立一个应用程序，并通过构建一个小型React电子商务应用程序来演示这个过程。让我们开始吧。</p>
<h2>先决条件</h2>
<p>要学习本教程，您需要对React和Node.js有一个基本的了解。HTML/CSS知识也是必需的，但不是强制性的。</p>
<p>为了构建所需的应用程序，我们将使用以下几个工具:</p>

<h3>探索零服务器</h3>
<p>要开始使用Zero，您需要首先在开发机器上全局安装它。为此，请在终端中键入以下内容:</p>
<pre>npm install -g zero</pre>
<p>完成后，您就可以开始使用它的功能构建您的应用程序了。让我们做一个快速演示，看看Zero的独特之处。创建一个名为<code> zero的测试文件夹，并定义以下文件夹结构:</code></p>
<pre>zero/
         api/</pre>
<p>在<code>api</code>文件夹中，创建一个<code>time.js</code>文件，并向其中添加以下代码:</p>
<pre>// api/time.js
    const moment = require("moment")
    
    module.exports = (req, res) =&gt; {
      var time = moment().format('LT');   // 11:51 AM
      res.send({time: time })
    }</pre>
<p>在我们的文件中，我们:</p>
<ul>
<li>导入<code>moment.js</code></li>
<li>导出一个接受<code>Request</code>和<code>Response</code>对象的函数(<a href="https://expressjs.com/en/4x/api.html#res" target="_blank" rel="noopener noreferrer"> like Express </a>)</li>
</ul>
<p>就是这样！您的API已经准备好了。现在，当你运行你的服务器时，Zero做两件事:</p>
<ul>
<li>自动安装并使<code>moment.js</code>可供您在文件中使用</li>
<li>将您新创建的API暴露给URL <code>/api/time</code></li>
</ul>
<p>要运行您的文件，通过您的终端导航到创建的文件夹，并键入命令<code>**zero**</code>。完成后，您应该会在终端中看到以下内容:</p>
<p><img decoding="async" class="graf-image jetpack-lazy-image" src="../Images/44e304f2b52cd25ac0f3ad24978efc14.png" data-image-id="0*Nk0qAX-eFTu7yS-t.png" data-width="763" data-height="56" data-lazy-src="https://storage.googleapis.com/blog-images-backup/0*Nk0qAX-eFTu7yS-t.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://storage.googleapis.com/blog-images-backup/0*Nk0qAX-eFTu7yS-t.png"/></p><noscript><img data-lazy-fallback="1" decoding="async" class="graf-image" src="../Images/44e304f2b52cd25ac0f3ad24978efc14.png" data-image-id="0*Nk0qAX-eFTu7yS-t.png" data-width="763" data-height="56" data-original-src="https://storage.googleapis.com/blog-images-backup/0*Nk0qAX-eFTu7yS-t.png"/></noscript>
<p>现在，当您在浏览器中访问<a href="http://localhost:3000/" target="_blank" rel="noopener noreferrer"> http://localhost:3000 </a>时，您会看到:</p>
<p><img decoding="async" class="graf-image jetpack-lazy-image" src="../Images/7b71dd6cd0dbbc3c22154b25e79f5407.png" data-image-id="0*nisjjkCBjJpNscT1.png" data-width="720" data-height="367" data-lazy-src="https://storage.googleapis.com/blog-images-backup/0*nisjjkCBjJpNscT1.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://storage.googleapis.com/blog-images-backup/0*nisjjkCBjJpNscT1.png"/></p><noscript><img data-lazy-fallback="1" decoding="async" class="graf-image" src="../Images/7b71dd6cd0dbbc3c22154b25e79f5407.png" data-image-id="0*nisjjkCBjJpNscT1.png" data-width="720" data-height="367" data-original-src="https://storage.googleapis.com/blog-images-backup/0*nisjjkCBjJpNscT1.png"/></noscript>
<p>如您所见，无需安装任何库或配置路由，您已经实现了一个基本的API。Zero通过在幕后为您完成所有这些工作来减少您的工作量。这样，您就可以专注于对您的项目真正重要的东西:您的代码。</p>
<p>现在我们有了一个正在运行的API，让我们看看如何在前端使用React来使用它。在目录的根目录下，创建一个<code>index.jsx</code>，并向其中添加以下代码行:</p>
<pre>// ./index.jsx
   
    import React from 'react'
    
    export default class extends React.Component {
      static async getInitialProps(){
        var json = await fetch("/api/time").then((resp) =&gt; resp.json())
        return {time: json.time}
      }
    
      render() {
        return &lt;p&gt;Current time is: {this.props.time}&lt;/p&gt;
      }
    }</pre>
<p>在我们的文件中，我们初始化了一个标准的React组件，并为初始数据填充增加了一个钩子。</p>
<p><code>getInitialProps</code>是页面加载时由<code>zero</code>调用的一个<code>async</code>静态方法。这个方法可以返回一个普通的对象，这个对象填充了<code>props</code>。</p>
<p>现在，转到这个网址:<a href="http://localhost:3000/" target="_blank" rel="noopener noreferrer"> http://localhost:3000 </a>。在获取您之前创建的API端点时，您应该看到React呈现的当前服务器时间:</p>
<p><img decoding="async" class="graf-image jetpack-lazy-image" src="../Images/bce7812c3e7db0cef550859f64799827.png" data-image-id="0*sbU9F9wSLdeEeLs7.png" data-width="726" data-height="464" data-lazy-src="https://storage.googleapis.com/blog-images-backup/0*sbU9F9wSLdeEeLs7.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://storage.googleapis.com/blog-images-backup/0*sbU9F9wSLdeEeLs7.png"/></p><noscript><img data-lazy-fallback="1" decoding="async" class="graf-image" src="../Images/bce7812c3e7db0cef550859f64799827.png" data-image-id="0*sbU9F9wSLdeEeLs7.png" data-width="726" data-height="464" data-original-src="https://storage.googleapis.com/blog-images-backup/0*sbU9F9wSLdeEeLs7.png"/></noscript>
<p>就是这样！您已经创建了一个没有任何安装或额外配置的基本应用程序。这是非常强大的，它是零服务器的基础。</p>
<p><strong>注意</strong>，你可以随时创建自己的<code>package.json</code>文件来安装软件包的特定版本。</p>
<h2>用零服务器引导电子商务应用程序</h2>
<p>现在我们已经了解了Zero是如何工作的，让我们继续引导一个小的电子商务应用程序。</p>
<p>更新您的文件夹结构，如下所示:</p>
<pre>zero/
         api/
         components/
           Product.jsx
           ProductList.jsx
           Total.jsx
         index.jsx</pre>
<p>在我们的组件目录中，我们定义了三个文件:</p>
<ul>
<li>产品组件来保存单个产品的数据</li>
<li>一个用于服务、获取和展示产品的组件</li>
<li>一个<code>Total</code>组件来存储我们当前的购物车数据</li>
</ul>
<p>最后，我们的<code>**index.jsx**</code>将容纳我们所有的组件。如上所述，Zero目前支持以下语言:</p>

<p>为了区分Node.js和React，Zero使用文件扩展名。您需要用扩展名<code>jsx</code>命名React组件，用扩展名<code>js</code>命名节点API，以使Zero能够正确处理您的文件。</p>
<h2>创建我们的组件</h2>
<p>首先，让我们定义我们的<code>Product</code>组件。打开文件并添加以下代码行:</p>
<pre>// ./components/Product.jsx
    import React from 'react'
    import 'bootstrap/dist/css/bootstrap.css';
    
    export default class Product extends React.Component {
      constructor(props) {
        super(props);
        this.state = {
          qty: 0
        };
        this.add = this.add.bind(this);
        this.subtract = this.subtract.bind(this);
        this.showInfo = this.showInfo.bind(this);
      }
    
      add() {
        this.setState({
          qty: this.state.qty + 1
        });
        this.props.handleTotal(this.props.price);
      }
    
      subtract() {
        this.setState({
          qty: this.state.qty - 1
        });
        this.props.handleTotal(-this.props.price);
      }
    
      showInfo() {
        this.props.handleShow(this.props.info);
      }
    
      render() {
        return (
          &lt;div&gt;
            &lt;div className="row form-group"&gt;
              &lt;div className="col-sm-10"&gt;
                &lt;h4&gt;{this.props.name}: ${this.props.price}&lt;/h4&gt;
              &lt;/div&gt;
              &lt;div className="col-sm-2 text-right"&gt;qty: {this.state.qty}&lt;/div&gt;
            &lt;/div&gt;
            &lt;div className="row btn-toolbar"&gt;
              &lt;div className="col-6"&gt;
                &lt;button className="btn btn-outline-primary"&gt;
                  show info
                &lt;/button&gt;
              &lt;/div&gt;
              &lt;div className="col-6 text-right"&gt;
                &lt;button className="btn btn-outline-primary" onClick={this.add}&gt;
                  +1
                &lt;/button&gt;
                &lt;button className="btn btn-outline-primary" onClick={this.subtract} disabled={this.state.qty &lt; 1}&gt;
                  -1
                &lt;/button&gt;
              &lt;/div&gt;
            &lt;/div&gt;
            &lt;hr /&gt;
          &lt;/div&gt;
        );
      }
    }</pre>
<p>这里，我们显示了一个产品，并定义了从状态中添加和删除商品的函数，当前购物车数据就存储在状态中。</p>
<p>在我们创建我们的<code>ProductList</code>组件之前，让我们创建我们的<code>Total</code>组件。这将包含当前的购物车状态。打开你的<code>Total.jsx</code>，添加下面几行代码:</p>
<pre>// ./components/Total.jsx
    
    import React from 'react'
    import 'bootstrap/dist/css/bootstrap.css';
    
    export default class Total extends React.Component {
      constructor(props) {
        super(props);
      }
      render() {
        let total = this.props.total.toFixed(2);
        let tax = (this.props.total * 0.15).toFixed(2);
        let totalIncTax = (+total + +tax).toFixed(2);
        let mystyle = {
          borderTop: "1px solid #ddd",
          marginTop: "10px"
        };
        return (
          &lt;div style={{"marginTop": "30px", "backgroundColor":"#F6F6F6","padding": "10px"}}&gt;
            &lt;h3 className="row" style={{ fontWeight: 400 }}&gt;
              &lt;span className="col-6"&gt;total price:&lt;/span&gt;
              &lt;span className="col-6 text-right"&gt;${total}&lt;/span&gt;
            &lt;/h3&gt;
            &lt;h3 className="row" style={{ fontWeight: 400 }}&gt;
              &lt;span className="col-6"&gt;tax (15%):&lt;/span&gt;
              &lt;span className="col-6 text-right"&gt;${tax}&lt;/span&gt;
            &lt;/h3&gt;
            &lt;h3 className="row" style={mystyle}&gt;
              &lt;span className="col-6"&gt;tota inc tax:&lt;/span&gt;
              &lt;span className="col-6 text-right"&gt;${totalIncTax}&lt;/span&gt;
            &lt;/h3&gt;
    
          &lt;/div&gt;
        );
      }
    }</pre>
<p>在我们的<code>Total.jsx</code>文件中，我们计算购物车中产品的总额和应税金额。</p>
<p>为了让我们的<code>ProductList.jsx</code>文件显示产品列表，让我们添加以下代码:</p>
<pre>// ./components/ProductList.jsx
    import React from 'react'
    import Total from './Total'
    import Product from './Product'
    
    export default class Products extends React.Component {
      constructor(props) {
        super(props);
    
        this.state = {
          total: 0,
          productList: [
                        {
                          "name": "Berries",
                          "price": 23.54,
                          "description": "Sweet popsicles to help with the heat"
                        },
                        {
                          "name": "Orange",
                          "price": 10.33,
                          "description": "Mouth watering burger."
                        },
                        {
                          "name": "Lemons",
                          "price": 12.13,
                          "description": "Sumptuous egg sandwich"
                        }
          ],
        };
    
        this.calculateTotal = this.calculateTotal.bind(this);
      }
    
      showProduct(info){
        alert(`Details: ${info}`)
      }
    
      calculateTotal(price) {
        this.setState({
          total: this.state.total + price
        });
      }
    
      render() {
        if (!this.state.productList) return &lt;p&gt;loading products! &lt;/p&gt;
    
        var component = this;
        var products = this.state.productList.map(function(product) {
          return (
            &lt;Product
              name={product.name}
              price={product.price}
              info={product.description}
              handleShow={component.showProduct}
              handleTotal={component.calculateTotal}
            /&gt;
          );
        });
    
        return (
          &lt;div&gt;
            {products}
            &lt;Total total={this.state.total} /&gt;
          &lt;/div&gt;
        );
      }
    }</pre>
<p>该组件做三件事:</p>
<ul>
<li>设置我们的初始产品数据</li>
<li>定义函数来处理我们的应用程序的一部分，如计算购物车中商品的总价</li>
<li>将数据作为道具向下传递给其他组件</li>
</ul>
<p>还剩下最后一步，在屏幕上查看我们的产品。我们需要做的就是将我们的<code>ProductList.jsx</code>导入到我们的索引组件中。更新您的<code>index.jsx</code>,如下所示:</p>
<pre>// ./index.jsx
    import React from 'react'
    import ProductList from './components/ProductList'
    
    export default class extends React.Component {
    
      render() {
        return &lt;ProductList /&gt;
      }
    }</pre>
<p>现在，通过在终端中键入<code>zero</code>来启动您的服务器。一旦你访问<a href="http://localhost:3000/" target="_blank" rel="noopener noreferrer"> http://localhost:3000 </a>，你会看到这个屏幕:</p>
<figure><img decoding="async" class="graf-image jetpack-lazy-image" src="../Images/1f330b7f12dab6c8c0e760e11865da97.png" data-image-id="0*IJHpeWLo9GYr84dP.png" data-width="901" data-height="683" data-lazy-src="https://storage.googleapis.com/blog-images-backup/0*IJHpeWLo9GYr84dP.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://storage.googleapis.com/blog-images-backup/0*IJHpeWLo9GYr84dP.png"/><noscript><img data-lazy-fallback="1" decoding="async" class="graf-image" src="../Images/1f330b7f12dab6c8c0e760e11865da97.png" data-image-id="0*IJHpeWLo9GYr84dP.png" data-width="901" data-height="683" data-original-src="https://storage.googleapis.com/blog-images-backup/0*IJHpeWLo9GYr84dP.png"/></noscript></figure>
<p>就是这样！我们已经创建了一个工作的React应用程序，无需安装或配置路线，或任何其他麻烦！全拜零服务器所赐。</p>
<h2>结论</h2>
<p>在本教程中，我们构建了一个简单的React应用程序，可以在其中添加和删除购物车中的商品。我们已经能够使用Zero Server编写我们的应用程序，而不需要任何额外的配置或包管理。</p>
<p>Zero是一个强大的工具，有可能加速你的web开发。请务必<a href="https://github.com/remoteinterview/zero/tree/master/docs" target="_blank" rel="noopener noreferrer">检查文档</a>。编码快乐！</p><div class="code-block code-block-17">
<div class="blog-plug inline-plug react-plug" vwo-el-id="26283398190">
<h2 vwo-el-id="41600691720">使用LogRocket消除传统反应错误报告的噪音</h2>
<a href="https://lp.logrocket.com/blg/react-signup-issue-free" target="_blank" vwo-el-id="19356441070">LogRocket
</a><p>是一款React analytics解决方案，可保护您免受数百个误报错误警报的影响，只针对少数真正重要的项目。LogRocket告诉您React应用程序中实际影响用户的最具影响力的bug和UX问题。</p><a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="19356441380">
<img class="first-react-image alignnone size-full wp-image-46 jetpack-lazy-image jetpack-lazy-image--handled" src="../Images/f300c244a1a1cf916df8b4cb02bec6c6.png" vwo-el-id="18272717540" data-lazy-loaded="1" data-original-src="https://files.readme.io/27c94e7-Image_2017-06-05_at_9.46.04_PM.png"/>
</a>
<a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="19356441690">
<img class="second-react-image alignnone size-full wp-image-46 jetpack-lazy-image jetpack-lazy-image--handled" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" vwo-el-id="30720362350" data-lazy-loaded="1" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/>
</a>
<a href="https://lp.logrocket.com/blg/react-signup-issue-free" target="_blank" rel="noopener noreferrer" vwo-el-id="35866400580">LogRocket
</a><p>自动聚合客户端错误、反应错误边界、还原状态、缓慢的组件加载时间、JS异常、前端性能指标和用户交互。然后，LogRocket使用机器学习来通知您影响大多数用户的最具影响力的问题，并提供您修复它所需的上下文。</p><p vwo-el-id="28675661060">关注重要的React bug—<a class="signup" href="https://lp.logrocket.com/blg/react-signup-issue-free" target="_blank" rel="noopener noreferrer" vwo-el-id="40093418840">今天就试试LogRocket】。</a></p>
</div></div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
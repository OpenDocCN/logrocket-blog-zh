<html>
<head>
<title>When to use HTML5’s canvas - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>何时使用HTML5的canvas - LogRocket博客</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/when-to-use-html5s-canvas-ce992b100ee8/#0001-01-01">https://blog.logrocket.com/when-to-use-html5s-canvas-ce992b100ee8/#0001-01-01</a></blockquote><div><article class="article-post">
<figure>
<p><img decoding="async" data-height="700" data-width="1240" src="../Images/3000451e38acc9165016011ded1265b0.png" data-lazy-src="https://storage.googleapis.com/blog-images-backup/1*sQuSbqYHW-38cJXo3RsvWA.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" class=" jetpack-lazy-image" data-original-src="https://storage.googleapis.com/blog-images-backup/1*sQuSbqYHW-38cJXo3RsvWA.png"/></p><noscript><img data-lazy-fallback="1" decoding="async" data-height="700" data-width="1240" src="../Images/3000451e38acc9165016011ded1265b0.png" data-original-src="https://storage.googleapis.com/blog-images-backup/1*sQuSbqYHW-38cJXo3RsvWA.png"/></noscript><br/>
</figure>
<p>HTML5 canvas有潜力成为web的主要部分，除了广泛的网页支持之外，还享有无处不在的浏览器和平台支持，因为<a href="https://w3techs.com/technologies/details/ml-html/all/all" target="_blank" rel="noopener noreferrer">近90%的网站</a>已经移植到HTML5。那么，为什么<em>的画布还没有成为网络的主要部分呢？</em></p>
<figure>
<p><a href="https://logrocket.com/signup/" target="_blank" rel="noopener noreferrer"><img decoding="async" data-height="750" data-width="3212" src="../Images/94b3e0f84b30cb0d321f60471481ab64.png" data-lazy-src="https://storage.googleapis.com/blog-images-backup/1*GPjaPKNNUYHU8EsA3Z0JGA.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" class=" jetpack-lazy-image" data-original-src="https://storage.googleapis.com/blog-images-backup/1*GPjaPKNNUYHU8EsA3Z0JGA.png"/><noscript><img data-lazy-fallback="1" decoding="async" data-height="750" data-width="3212" src="../Images/94b3e0f84b30cb0d321f60471481ab64.png" data-original-src="https://storage.googleapis.com/blog-images-backup/1*GPjaPKNNUYHU8EsA3Z0JGA.png"/></noscript></a>T6】</p></figure>
<h3>关于画布你需要知道什么</h3>
<p>StackOverflow 上的<a href="https://stackoverflow.com/tags" target="_blank" rel="noopener noreferrer"> canvas标签占所有问题的不到百分之二，谷歌趋势显示</a><a href="https://trends.google.com/trends/explore?cat=5&amp;date=today%205-y&amp;geo=US&amp;q=canvas" target="_blank" rel="noopener noreferrer">对“canvas”的搜索在过去五年里没有超过四倍</a>。有许多可能的解释，但我们不讨论它的过去，而是讨论HTML5画布的优点和表面上的缺点——包括针对这些缺点的经过时间考验的解决方案。以下是对各种绘图技术及其主要优缺点的简要总结:</p>
<ul>
<li><strong>文档对象模型(DOM) </strong>:我们将要讨论的三种技术中最熟悉的一种。虽然灵活且易于使用，提供了像<a href="https://developer.mozilla.org/en-US/docs/Web/Guide/Events/Event_handlers" target="_blank" rel="noopener noreferrer">点击事件处理程序</a>这样的便利设施，但是典型的div还是有开销的。它的主要卖点是<em>易用性</em>，它的致命弱点是在内存和渲染速度方面的<em>效率</em>。</li>
<li><strong>可缩放矢量图形(SVG) </strong>:易用性和细粒度控制的中间标志。SVG同样也是DOM的一部分，但顾名思义，它是为高保真、大型图形而设计的。与DOM不同，SVG支持广泛的预置形状，如圆形或多边形。它最大的亲是<em>大显卡</em>，它的败笔是<em>多显卡</em>。</li>
<li>html 5 canvas:canvas给了开发者对渲染更精细的控制，但代价是必须手动管理每个细节，比如悬停状态。canvas最大的优势恰恰与SVG相反:它非常擅长管理<em>许多对象</em>。</li>
<li>WebGL :这些技术中的最新技术和成熟的3D引擎。这可以通过Canvas的3D上下文访问，但也支持2D；此外，由于级别极低，它非常高效:WebGL可以处理许多对象<em>和</em>大型对象。</li>
</ul>
<p>总之，上面的列表提供了一系列抽象层，其中最少的抽象是最高效的(canvas和WebGL)，最多的抽象是最低效的(SVG和DOM)。然而，canvas和WebGL选项都有一些额外的优势，无论是老的还是新的，这使得它作为一个中间地带更有吸引力:第三方库增加了易用性和对异步渲染的支持，使它更加高效:</p>
<p>第三方库:许多第三方库在WebGL和canvas之上提供了抽象，在DOM提供的抽象和canvas缺乏的抽象之间提供了一个中间地带。正如我们下面的备忘单将要讨论的，一些第三方库另外在渲染技术之间切换以最大化效率，消除了你选择的需要。以下是几个最流行的canvas和webGL渲染库:</p>
<ul>
<li><a href="http://www.pixijs.com/" target="_blank" rel="noopener noreferrer"><strong>pixi . js</strong></a>(22.4k stars，创建于2013): 2D WebGL渲染器，具有画布回退功能，强调速度，支持自己的插件</li>
<li><a href="https://createjs.com/easeljs" target="_blank" rel="noopener noreferrer"><strong>EaselJS</strong></a>(7.2k stars，创建于2011):画布上的交互式对象模型，支持鼠标交互和嵌套对象</li>
<li><a href="http://fabricjs.com/" target="_blank" rel="noopener noreferrer"><strong>fabric . js</strong></a>(12.3k stars，创建于2008):画布上的交互式对象模型，通过SVG到画布和画布到SVG的转换支持SVG</li>
</ul>
<p><strong>屏外画布:</strong>为了进一步增强画布性能，利用<a href="https://developer.mozilla.org/en-US/docs/Web/API/OffscreenCanvas" target="_blank" rel="noopener noreferrer">屏外画布</a>。当然，只有谷歌Chrome 支持<a href="https://caniuse.com/#search=offscreen%20canvas" target="_blank" rel="noopener noreferrer">，Opera和Firefox也提供实验性支持。然而，屏幕外画布可以显著提高性能:屏幕外画布可以用来更有效地预渲染昂贵的视觉效果，如文本(</a><a href="https://jsperf.com/render-vs-prerender/3" target="_blank" rel="noopener noreferrer"> jsperf </a>)，使用web workers，画布渲染可以卸载到异步线程(<a href="https://developers.google.com/web/updates/2018/08/offscreen-canvas" target="_blank" rel="noopener noreferrer">讨论</a>、<a href="https://devnook.github.io/OffscreenCanvasDemo/keep-ui-responsive.html" target="_blank" rel="noopener noreferrer">演示</a>)。</p>
<p>简而言之，canvas和WebGL比DOM更具性能，有了第三方库，其易用性不相上下；此外，越来越多的浏览器支持额外的web标准有可能进一步提高画布的性能。这两个好处结合起来，有可能进一步推动画布在网站上的应用，降低准入门槛，增加使用画布的好处。为了理解为什么画布比DOM快得多，我们需要理解<em>渲染风格</em>。</p>
<h3>关于图形你需要知道什么</h3>
<p>为了解释画布的功效，我们必须区分计算机图形学中的两种渲染风格:<strong>即时模式</strong>和<strong>保留模式</strong>，分别由画布和DOM表示。</p>
<p>在<strong>即时模式</strong>中，客户端发出调用，导致图形对象的即时显示。在我们的例子中，每个canvas函数调用都会导致一个图形对象被立即绘制出来。不管画布的哪个部分被更新，整个画布每次都必须被重画，除非客户端已经进行了优化。这意味着客户端必须在画布中维护一个对象模型。下面，蓝色代表像素和API调用你作为开发者直接控制。</p>
<figure>
<p><img decoding="async" data-height="540" data-width="960" src="../Images/96ad4f7793d4f538a9925c491690d8cb.png" data-lazy-src="https://storage.googleapis.com/blog-images-backup/0*PjjQ-EjNIOnJL-xL.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" class=" jetpack-lazy-image" data-original-src="https://storage.googleapis.com/blog-images-backup/0*PjjQ-EjNIOnJL-xL.png"/></p><noscript><img data-lazy-fallback="1" decoding="async" data-height="540" data-width="960" src="../Images/96ad4f7793d4f538a9925c491690d8cb.png" data-original-src="https://storage.googleapis.com/blog-images-backup/0*PjjQ-EjNIOnJL-xL.png"/></noscript><br/>
</figure>
<p>相比之下，在<strong>保留模式</strong>中，客户端调用<em>不会</em>导致图形对象的立即显示。相反，客户端调用update一个内部模型。在我们的例子中，开发人员指定HTML和相关的CSS，浏览器处理何时以及如何显示这些图形。这允许浏览器进一步优化何时呈现哪些对象。例如，对requestAnimationFrame的调用就受益于这种内置的优化。下面，蓝色(再次)代表API调用你作为开发者直接控制。然而，红色代表浏览器为您处理的抽象，包括维护内部模型和更新图形对象。</p>
<figure>
<p><img decoding="async" data-height="540" data-width="960" src="../Images/37b5c52f6dfbc423d1d22a4410bc6a2e.png" data-lazy-src="https://storage.googleapis.com/blog-images-backup/0*CfiDoT4IrA8xbdPR.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" class=" jetpack-lazy-image" data-original-src="https://storage.googleapis.com/blog-images-backup/0*CfiDoT4IrA8xbdPR.png"/></p><noscript><img data-lazy-fallback="1" decoding="async" data-height="540" data-width="960" src="../Images/37b5c52f6dfbc423d1d22a4410bc6a2e.png" data-original-src="https://storage.googleapis.com/blog-images-backup/0*CfiDoT4IrA8xbdPR.png"/></noscript><br/>
</figure>
<p>前者，即时模式，提供了灵活性，但需要干预细节。而后者，保留模式，限制了灵活性，但抽象掉了细节。这些范例分别解释了画布和DOM背后的哲学。下面，我们更详细地概述这两种操作模式的含义。</p>
<h3>备忘单:利弊</h3>
<p>这里有一个简短的备忘单，概述了上面列出的每种方法的优缺点。这些优点和缺点很大程度上源于前面提到的渲染风格；我们只概述了几个最紧迫的问题。对于我们下面的比较，将SVG和DOM结合起来作为竞争者是值得的，因为它们有相同的优点和缺点以及相似的接口。</p>
<p><strong>文档对象模型(DOM) </strong>和<strong>支持向量图形(SVG) </strong>:</p>
<p><strong>优点</strong> : <em>易用性</em></p>
<ul>
<li>响应是内建的，并且很容易用适当的CSS来支持</li>
<li>重绘帧是通过浏览器渲染自动处理的</li>
<li>动画是预先设计好的，可配置的，可通过CSS扩展</li>
<li>(顾名思义)支持对象级交互，比如单击一个div</li>
<li><a href="https://blog.logrocket.com/the-noobs-guide-to-3d-transforms-with-css-7370aafd9edf" target="_blank" rel="noopener noreferrer">用于转换的硬件加速</a></li>
</ul>
<p><strong>缺点</strong> : <em>效率低下</em></p>
<ul>
<li>不适合复杂的图形:内存密集型，将导致渲染缓慢</li>
<li>对渲染、动画等的粗略控制。抽象限制了可定制性</li>
</ul>
<p><strong> HTML5画布</strong></p>
<p><strong>优点:</strong> <em>表演</em></p>
<ul>
<li>快速灵活:对像素渲染的时间和方式进行精细控制</li>
<li>所有渲染、动画等的硬件加速。</li>
<li>对于复杂的图形和有许多对象要操作的情况，比SVG更好</li>
</ul>
<p><strong>缺点:</strong> <em>抽象少(但这可以用第三方库克服)</em></p>
<ul>
<li>没有内置的对象级交互，因为画布在像素级基础上工作</li>
<li>绘制大型对象或管理大型画布时速度较慢</li>
<li>不会自动调整显示像素比率，导致文本模糊</li>
<li>增加了动画、基本配置等的代码复杂性。</li>
</ul>
<p><strong> WebGL </strong></p>
<p><strong>优点:</strong> <em>高性能</em></p>
<ul>
<li>最快和最灵活的:与屏幕上像素的低层次交互</li>
<li>在这里的三个选项中，只有技术针对3D渲染进行了优化</li>
<li>所有渲染、转换、动画等的硬件加速。</li>
</ul>
<p><strong>缺点:</strong> <em>甚至更少的抽象(但是这可以通过第三方库来克服)</em></p>
<ul>
<li>需要了解3D渲染和数学</li>
<li>甚至进一步增加了动画、基本配置等的代码复杂性。</li>
</ul>
<p>注意，在上面的每个选项中，正如我们在canvas介绍中提到的，代码复杂性可以通过一个适当的库很容易地得到改善；例如，3D webGL的一个流行选择是<a href="http://threejs.org" target="_blank" rel="noopener noreferrer"> three.js </a>，2D webGL的一个流行选择是<a href="http://www.pixijs.com/" target="_blank" rel="noopener noreferrer"> pixi.js </a>。这些库中的每一个都抽象出细节，并且消除了对先决知识的需要。有了正确的库，作为开发人员，您可以在上述三种方法之间进行插入，并在必要时切换后端。事实上，一些库已经自动为您切换后端。例如，数据可视化库<a href="https://d3js.org/" target="_blank" rel="noopener noreferrer"> d3.js </a>在从2D切换到3D时从SVG切换到webGL，pixi.js在需要的地方使用带有画布回退的webGL。</p>
<p>有了上面的优点和缺点，您现在就有了何时使用哪种技术的粗略指导原则。这里有几个场景来进一步说明上面的列表，列举了几个常见的场景以及每种场景使用哪种技术。</p>
<p>具有静态用户界面的游戏，如分数显示和固定选项菜单</p>
<ul>
<li>因为你界面的大部分是固定的，可以从<em>而不是</em>重绘中受益</li>
</ul>
<p>游戏的核心显示，有数百甚至数千个动画、移动的角色</p>
<ul>
<li><strong>画布</strong>对于图形的复杂性，除了大量的实体</li>
<li><strong> WebGL </strong>用于三维游戏</li>
</ul>
<p>带有基本动画的网站标志</p>
<ul>
<li><strong> SVG </strong>，因为这个logo在所有分辨率下都应该是清晰的，SVG不需要外部库也支持。CSS可以提供基本的动画。值得一提的是canvas大材小用。</li>
</ul>
<p>鉴于以上高层次的概述，我们现在将深入到更具体的数字:下面的基准将更精确地量化权衡，并为您提供数字，以此为基础进行更细粒度的决策。</p>
<h3>基准</h3>
<p>在这个实验部分，我们将回答两个关于SVG和canvas之间权衡的问题。</p>
<ol>
<li>每种技术最适用于多少对象？</li>
<li>每种技术最适合什么尺寸的物体？</li>
</ol>
<p>对于那些希望重现这些结果的人来说，值得一提的是实验设置:以下实验是在配备英特尔Iris Plus显卡的2018 Macbook Pro上的谷歌Chrome v73上运行的。每个实验下面都会有源代码。</p>
<p><strong>每种技术最适用于多少个对象？</strong></p>
<p>下面，我们以千为单位，对每个对象的速度进行基准测试。注意，SVG在任何时候都不是canvas的对手。但是，请注意这个比例相当大，绘制多达100万个对象的渲染时间。对于更少的对象，差异很小，但相差一个数量级:要绘制1000个对象，SVG需要大约10毫秒，而canvas需要1毫秒。这种差异只会随着对象越来越多而放大，但即使对于相当数量的对象，这种差异也是微不足道的。</p>
<figure>
<p><img decoding="async" data-height="371" data-width="600" src="../Images/6f6c3f6e3060c3546ed08f68b4ecf015.png" data-lazy-src="https://storage.googleapis.com/blog-images-backup/0*GHn4jn17jWBh5yrW.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" class=" jetpack-lazy-image" data-original-src="https://storage.googleapis.com/blog-images-backup/0*GHn4jn17jWBh5yrW.png"/></p><noscript><img data-lazy-fallback="1" decoding="async" data-height="371" data-width="600" src="../Images/6f6c3f6e3060c3546ed08f68b4ecf015.png" data-original-src="https://storage.googleapis.com/blog-images-backup/0*GHn4jn17jWBh5yrW.png"/></noscript><br/>
</figure>
<p>每种技术最适合什么尺寸的物体？</p>
<ul>
<li>单独改变对象的大小并不会明显改变渲染时间，正如这个JSFiddle所演示的:<a href="https://jsfiddle.net/alvinwan/0mbnLfod/" target="_blank" rel="noopener noreferrer">https://jsfiddle.net/alvinwan/0mbnLfod/</a>我们将对象的大小从10，000 x 10，000调整到1百万x 1百万，所有这些都需要大约1毫秒。使用SVG进行的类似实验同样没有显示出渲染时间的明显差异</li>
<li>更改画布大小同样不会影响渲染时间。无论是在10，000 x 10，000的画布上还是在100 x 100的画布上，绘制10，000个对象都需要大约8毫秒，<a href="https://jsfiddle.net/alvinwan/08m42e56/8/" target="_blank" rel="noopener noreferrer">https://jsfiddle.net/alvinwan/08m42e56/8/</a></li>
</ul>
<p>给定当前的实验设置，似乎对象的大小和画布的大小并不影响画布或SVG技术。</p>
<p>总之，当处理成百上千的对象时，DOM渲染的开销更大；在这种情况下，canvas是明显的赢家。然而，画布和SVG对于对象大小都是不变的。鉴于最终的统计结果，画布在性能方面明显胜出。</p>
<h3>结论</h3>
<p>这只是围绕浏览器的画布和其他图形技术的性能讨论的开始。即使在决定使用SVG、canvas、webGL或它们的某种组合之后，还有一些常用操作的效率问题，比如画布绘制和多边形填充、如何高效地重绘、多个画布是否值得开销等等。性能优化是无止境的，组合这三种技术的组合方式只会使问题更加复杂。然而，归根结底，简单性也是同样重要的因素，上面的备忘单应该足以让您确定是否需要进一步的性能调查；对于一个博文里的动画人物来说，可能不值得。对于以实时多人游戏为特色的整版互动游戏来说，每一盎司都很重要。</p><div class="code-block code-block-2">
<div class="blog-plug base-cta"><h2>使用<a class="signup" href="https://lp.logrocket.com/blg/signup" target="_blank" rel="noopener noreferrer"> LogRocket </a>消除传统错误报告的干扰</h2>
<a href="https://lp.logrocket.com/blg/signup" class="signup" target="_blank" rel="noopener noreferrer"><img class="alignnone size-full wp-image-46 jetpack-lazy-image" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/><noscript><img data-lazy-fallback="1" class="alignnone size-full wp-image-46" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/></noscript></a>
<p><a href="https://lp.logrocket.com/blg/signup" target="_blank" rel="noopener noreferrer"> LogRocket </a>是一个数字体验分析解决方案，它可以保护您免受数百个假阳性错误警报的影响，只针对几个真正重要的项目。LogRocket会告诉您应用程序中实际影响用户的最具影响力的bug和UX问题。</p>
<p>然后，使用具有深层技术遥测的会话重放来确切地查看用户看到了什么以及是什么导致了问题，就像你在他们身后看一样。</p>
<p>LogRocket自动聚合客户端错误、JS异常、前端性能指标和用户交互。然后LogRocket使用机器学习来告诉你哪些问题正在影响大多数用户，并提供你需要修复它的上下文。</p>
<p>关注重要的bug—<a class="signup" href="https://lp.logrocket.com/blg/signup-issue-free" target="_blank" rel="noopener noreferrer">今天就试试LogRocket】。</a></p></div></div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
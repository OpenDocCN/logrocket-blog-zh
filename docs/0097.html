<html>
<head>
<title>Using the JavaScript Either monad for error handling - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>使用JavaScript或monad进行错误处理</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/javascript-either-monad-error-handling/#0001-01-01">https://blog.logrocket.com/javascript-either-monad-error-handling/#0001-01-01</a></blockquote><div><article class="article-post">
<p><em> <strong>编者按:</strong>本帖于2021年9月更新相关信息和编辑过的代码块。</em></p>
<p>让我们来谈谈如何处理错误。JavaScript为我们提供了处理异常的内置语言特性。我们将潜在有问题的代码包装在<code>try...catch</code>语句中。这让我们在try部分编写“快乐路径”,然后在catch部分处理任何异常。</p>
<p>这不是一件坏事。它让我们专注于手头的任务，而不必考虑每一个可能发生的错误。这肯定比用无休止的<code>if</code>语句把我们的代码弄得乱七八糟要好。</p>
<p>如果没有<code>try...catch</code>，检查每个函数调用的结果是否有意外值会变得很乏味。异常和<code>try...catch</code>块是有作用的，但是它们有一些问题，并且它们不是处理错误的唯一方法。在本文中，我们将看看如何使用任一单子作为<code>try...catch</code>的替代。</p>
<p>在我们继续之前有几件事。在本文中，我们假设你已经知道了<a href="https://jrsinclair.com/articles/2016/gentle-introduction-to-functional-javascript-functions/#composition" target="_blank" rel="noopener noreferrer">函数组合</a>和<a href="https://jrsinclair.com/articles/2016/gentle-introduction-to-functional-javascript-functions/#currying" target="_blank" rel="noopener noreferrer">奉承</a>。如果你需要一分钟来温习这些，那完全没问题。还有一个警告，如果你以前没有遇到过像单子这样的东西，它们可能看起来真的…不一样。使用这样的工具需要思维的转变。</p>
<p>如果你一开始感到困惑，不要担心。每个人都这样。我在最后列出了一些可能有帮助的参考资料。但是不要放弃。一旦你进入其中，这东西是令人陶醉的。</p>
<figure/>
<h2>在JavaScript中处理异常和<code>try...catch</code>块</h2>
<p>在我们深入探讨异常的问题之前，让我们先讨论一下它们为什么存在。我们有像异常和<code>try…catch</code>块这样的东西是有原因的。他们并不总是坏的。</p>
<p>为了探究这个主题，我们将尝试解决一个示例问题。我试图让它至少半真实。假设我们正在编写一个函数来显示通知列表。我们已经设法从服务器上取回了数据。但是，不管出于什么原因，后端工程师决定以CSV格式而不是JSON格式发送它。原始数据可能如下所示:</p>
<pre>timestamp,content,viewed,href
2018-10-27T05:33:34+00:00,@madhatter invited you to tea,unread,https://example.com/invite/tea/3801
2018-10-26T13:47:12+00:00,@queenofhearts mentioned you in 'Croquet Tournament' discussion,viewed,https://example.com/discussions/croquet/1168
2018-10-25T03:50:08+00:00,@cheshirecat sent you a grin,unread,https://example.com/interactions/grin/88</pre>
<p>现在，最终，我们希望将这段代码呈现为HTML。它可能看起来像这样:</p>
<pre>&lt;ul class="MessageList"&gt;
  &lt;li class="Message Message--viewed"&gt;
    &lt;a href="https://example.com/invite/tea/3801" class="Message-link"&gt;@madhatter invited you to tea&lt;/a&gt;
    &lt;time datetime="2018-10-27T05:33:34+00:00"&gt;27 October 2018&lt;/time&gt;
  &lt;li&gt;
  &lt;li class="Message Message--viewed"&gt;
    &lt;a href="https://example.com/discussions/croquet/1168" class="Message-link"&gt;@queenofhearts mentioned you in 'Croquet Tournament' discussion&lt;/a&gt;
    &lt;time datetime="2018-10-26T13:47:12+00:00"&gt;26 October 2018&lt;/time&gt;
  &lt;/li&gt;
  &lt;li class="Message Message--viewed"&gt;
    &lt;a href="https://example.com/interactions/grin/88" class="Message-link"&gt;@cheshirecat sent you a grin&lt;/a&gt;
    &lt;time datetime="2018-10-25T03:50:08+00:00"&gt;25 October 2018&lt;/time&gt;
  &lt;/li&gt;
&lt;/ul&gt;</pre>
<p>为了使问题简单，现在，我们只关注处理CSV数据的每一行。我们从几个简单的函数开始处理行。我们将使用第一个来分割字段:</p>
<pre>function splitFields(row) {
    return row.split(',');
}</pre>
<p>现在，这个函数被过分简化了，因为这是一个关于错误处理的教程，而不是CSV解析。如果其中一条消息中有一个逗号，那就大错特错了。请不要使用这样的代码来解析真实的CSV数据。如果您确实需要解析CSV数据，请使用经过良好测试的CSV解析库，比如<a href="https://www.papaparse.com/" target="_blank" rel="noopener"> Papa Parse </a>。</p>
<p>分割数据后，我们希望创建一个对象，其中的字段名与CSV标题相匹配。我们假设已经解析了标题行。注意，如果行的长度与标题行不匹配，我们会抛出一个错误(<code>_.zipObject</code>是一个<a href="https://lodash.com/"> lodash函数</a>):</p>
<pre>function zipRow(headerFields, fieldData) {
    if (headerFields.length !== fieldData.length) {
        throw new Error("Row has an unexpected number of fields");
    }
    return _.zipObject(headerFields, fieldData);
}</pre>
<p>之后，我们将使用国际化API向对象添加一个人类可读的日期，这样我们就可以在模板中将其打印出来。请注意，对于无效日期，它会引发一个错误:</p>
<pre>function addDateStr(messageObj) {
    const errMsg = 'Unable to parse date stamp in message object';
    const d = new Date(messageObj.datestamp);
    if (isNaN(d)) {
        throw new Error(errMsg);
    }

    const datestr = Intl.DateTimeFormat('en-US', {year: 'numeric', month: 'long', day: 'numeric'}).format(d);
    return {datestr, ...messageObj};
}
</pre>
<p>最后，我们将对象传递给一个模板函数，得到一个HTML字符串:</p>
<pre>const rowToMessage = _.template(`&lt;li class="Message Message--&lt;%= viewed %&gt;"&gt;
  &lt;a href="&lt;%= href %&gt;" class="Message-link"&gt;&lt;%= content %&gt;&lt;/a&gt;
  &lt;time datetime="&lt;%= datestamp %&gt;"&gt;&lt;%= datestr %&gt;&lt;/time&gt;
&lt;li&gt;`);</pre>
<p>如果我们最终发现了一个错误，最好也能打印出来:</p>
<pre>const showError = _.template(`&lt;li class="Error"&gt;&lt;%= message %&gt;&lt;/li&gt;`);</pre>
<p>一旦所有这些都准备好了，我们就可以把它们放在一起创建我们的函数来处理每一行:</p>
<pre>function processRow(headerFieldNames, row) {
    try {
        fields = splitFields(row);
        rowObj = zipRow(headerFieldNames, fields);
        rowObjWithDate = addDateStr(rowObj);
        return rowToMessage(rowObj);
    } catch(e) {
        return showError(e);
    }
}</pre>
<p>我们有了示例函数。就JavaScript代码而言，这还不算太糟。但是让我们仔细看看我们是如何管理这里的异常的。</p>
<h2>JavaScript中使用<code>try...catch</code>处理异常的好处</h2>
<p>那么，<code>try...catch</code>有什么好的呢？需要注意的是，在上面的例子中，<code>try</code>块中的任何步骤都可能抛出错误。在<code>zipRow()</code>和<code>addDateStr()</code>中，我们故意抛出错误。如果出现问题，我们只需简单地<code>catch</code>错误，并在页面上显示错误消息。</p>
<p>没有这种机制，代码会变得非常难看。这是没有例外的情况下可能的样子。我们不会抛出异常，而是假设我们的函数将返回null:</p>
<pre>function processRowWithoutExceptions(headerFieldNames, row) {
    fields = splitFields(row);
    rowObj = zipRow(headerFieldNames, fields);
    if (rowObj === null) {
        return showError(new Error('Encountered a row with an unexpected number of items'));
    }

    rowObjWithDate = addDateStr(rowObj);
    if (rowObjWithDate === null) {
        return showError(new Error('Unable to parse date in row object'));
    }

    return rowToMessage(rowObj);
}</pre>
<p>如你所见，我们以大量的<code>if</code>语句结束。代码更加冗长，很难理解主要的逻辑。此外，我们没有办法让每一步都告诉我们错误信息应该是什么，或者它们失败的原因(除非我们用全局变量做些手脚。)所以，我们要猜测，如果函数返回null就显式调用<code>showError()</code>。毫无例外，代码更加混乱，更难理解。</p>
<p>但是再看看有异常处理的版本。它给了我们一个清晰的“快乐路径”和异常处理代码的分离。尝试的部分是快乐之路，捕捉的部分是悲伤之路(可以这么说)。所有的异常处理都发生在一个地方。我们可以让单个函数告诉我们失败的原因。</p>
<p>总的来说，看起来还不错。事实上，我认为我们大多数人会认为第一个例子是一段简洁的代码。为什么我们需要另一种方法？</p>
<h2><code>try...catch</code>异常处理的问题</h2>
<p>异常的好处是让你忽略那些讨厌的错误条件。但不幸的是，他们做得有点太好了。你只需抛出一个异常，然后继续前进。我们可以稍后想出在哪里抓到它。我们都<em>打算</em>把那块<code>try…catch</code>放在适当的位置。真的，我们有。但是它应该去哪里并不总是很明显。忘记一个太容易了。在您意识到之前，您的应用程序就崩溃了。</p>
<p>另一件要考虑的事情是异常使我们的代码不纯。<a href="https://drboolean.gitbooks.io/mostly-adequate-guide-old/content/ch3.html" target="_blank" rel="noopener noreferrer">为什么功能纯度是一件好事</a>是一个完全不同的讨论。但是让我们考虑一下函数纯洁性的一个小方面:引用透明性。</p>
<p>对于给定的输入，引用透明的函数总是给出相同的结果。但是对于抛出异常的函数就不能这么说了。在任何时候，它们都可能抛出一个异常，而不是返回值。这使得思考一段代码实际上在做什么变得更加复杂。</p>
<p>但是如果我们可以两者兼得呢？如果我们能想出一种纯粹的方法来处理错误会怎么样？</p>
<h2>JavaScript中的错误处理</h2>
<p>如果我们要编写自己的纯错误处理代码，那么我们需要始终返回值。那么，作为第一次尝试，如果我们失败时返回一个<code>Error</code>对象会怎么样呢？也就是说，无论我们在哪里抛出一个错误，我们只是返回它。可能看起来像这样:</p>
<pre>function processRowReturningErrors(headerFieldNames, row) {
    fields = splitFields(row);
    rowObj = zipRow(headerFieldNames, fields);
    if (rowObj instanceof Error) {
        return showError(rowObj);
    }

    rowObjWithDate = addDateStr(rowObj);
    if (rowObjWithDate instanceof Error) {
        return showError(rowObjWithDate);
    }

    return rowToMessage(rowObj);
}</pre>
<p>这只是版本上非常轻微的改进，没有例外。但是这样更好。我们已经将错误消息的责任转移到了单独的函数中。但仅此而已。我们仍然拥有所有那些<code>if</code>声明。如果有某种方法可以封装模式，那就太好了。换句话说，如果我们知道我们有一个错误，就不要去运行剩下的代码了。</p>
<h3>多态性</h3>
<p>那么，我们该怎么做呢？这是个棘手的问题。但是用多态的魔力是可以实现的。如果你以前没有遇到过多态性，不要担心。它的全部意思是“为不同类型的实体提供一个单一的接口。”在JavaScript中，我们通过创建具有相同名称和签名的方法的对象来做到这一点，但是我们给它们不同的行为。</p>
<p>多态性的一个经典例子是应用程序日志。我们可能希望根据所处的环境将日志发送到不同的地方。因此，我们定义了两个logger对象:</p>
<pre>const consoleLogger = {
    log: function log(msg) {
        console.log('This is the console logger, logging:', msg);
    }
};

const ajaxLogger = {
    log: function log(msg) {
        return fetch('https://example.com/logger', {method: 'POST', body: msg});
    }
};</pre>
<p>这两个对象都定义了一个需要单个字符串参数的log函数。但是他们的行为不同。它的美妙之处在于，我们可以编写调用<code>.log()</code>的代码，但不关心它使用的是哪个对象。可能是一辆<code>consoleLogger</code>或者一辆<code>ajaxLogger</code>。两种方式都可以。例如，下面的代码将同样适用于这两个对象:</p>
<pre>function log(logger, message) {
    logger.log(message);
}</pre>
<p>另一个例子是所有JS对象上的<code>.toString()</code>方法。我们可以在我们创建的任何类上写一个<code>.toString()</code>方法。所以，也许我们可以创建两个不同的实现<code>.toString()</code>的类。我们称它们为<code>Left</code>和<code>Right</code>(我一会儿会解释为什么):</p>
<div>
<pre>class Left {
  constructor(val) {
    this._val = val;
  }
  toString() {
    const str = this._val.toString();
    return `Left(${str})`;
  }
}</pre>
</div>
<div>
<pre>class Right {
  constructor(val) {
    this._val = val;
  }
  toString() {
    const str = this._val.toString();
    return `Right(${str})`;
  }
}</pre>
</div>
<p>现在，让我们创建一个在这两个对象上调用<code>.toString()</code>的函数:</p>
<pre>function trace(val) {
    console.log(val.toString());
    return val;
}

trace(new Left('Hello world'));
// ⦘ Left(Hello world)

trace(new Right('Hello world'));
// ⦘ Right(Hello world);</pre>
<p>我知道这并不令人惊讶。但关键是我们有两种不同的行为使用同一个接口——这就是多态性。但是请注意一些有趣的事情。我们使用了多少<code>if</code>语句？零。没有。我们已经创建了两种不同的行为，没有一个单独的<code>if</code>语句。也许我们可以用这样的东西来处理我们的错误…</p>
<h2><code>Left</code>和<code>Right</code></h2>
<p>回到我们的问题，我们想为我们的代码定义一条快乐的路径和一条悲伤的路径。在快乐的道路上，我们只是快乐地运行我们的代码，直到错误发生或我们完成。如果我们最终走上了这条可悲的道路，我们就不会再费心去尝试运行代码了。</p><div class="code-block code-block-54">
<hr/>
<h3>更多来自LogRocket的精彩文章:</h3>

<hr/></div>
<p>现在，我们可以调用我们的两个类<code>Happy</code>和<code>Sad</code>来表示两条路径。但是我们将遵循其他编程语言和库使用的命名约定。这样，如果你进一步阅读，就不会那么困惑了。因此，为了符合惯例，我们将我们的悲伤路径称为<code>Left</code>，将我们的快乐路径称为<code>Right</code>。</p>
<p>让我们创建一个方法，如果我们在快乐的道路上，它将接受一个函数并运行它，但是如果我们在悲伤的道路上，则忽略它:</p>
<div>
<pre>/**
*Left represents the sad path.
*/
class Left {
    constructor(val) {
        this._val = val;
    }
    runFunctionOnlyOnHappyPath(fn) {
        // Left is the sad path. Do nothing with fn
    }
    toString() {
        const str = this._val.toString();
        return `Left(${str})`;
    }
}
</pre>
</div>
<div>
<pre>/**
*Right represents the happy path.
*/
class Right {
constructor(val) {
    this._val = val;
}
runFunctionOnlyOnHappyPath(fn) {
    return fn(this._val);
}
toString() {
    const str = this._val.toString();
    return `Right(${str})`;
}
}</pre>
</div>
<p>然后我们可以这样做:</p>
<pre>const leftHello  = new Left('Hello world');
const rightHello = new Right('Hello world');

leftHello.runFunctionOnlyOnHappyPath(trace);
// does nothing


rightHello.runFunctionOnlyOnHappyPath(trace);
// ⦘ Hello world
// ￩ "Hello world"</pre>
<h3>使用<code>.map()</code></h3>
<p>我们离有用的东西越来越近了，但还没到那一步。我们的<code>.runFunctionOnlyOnHappyPath()</code>方法返回<code>_value</code>属性。这很好，但是如果我们想要运行多个函数，这就很不方便了。</p>
<p>为什么？因为我们不再知道我们是在快乐的道路上还是悲伤的道路上。一旦我们在<code>Left</code>或<code>Right</code>之外取值，这些信息就消失了。因此，我们可以做的是返回一个<code>Left</code>或<code>Right</code>，并在其中添加一个新的<code>_value</code>。我们会缩短这个名字。</p>
<p>我们正在做的是将一个函数从普通值的世界映射到<code>Left</code>和<code>Right</code>的世界。所以我们称这种方法为<code>.map()</code>:</p>
<div>
<pre>/**
*Left represents the sad path.
*/
class Left {
    constructor(val) {
        this._val = val;
    }
    map() {
        // Left is the sad path
        // so we do nothing
        return this;
    }
    toString() {
        const str = this._val.toString();
        return `Left(${str})`;
    }
}</pre>
</div>
<div>
<pre>/**
*Right represents the happy path
*/
class Right {
    constructor(val) {
        this._val = val;
    }
    map(fn) {
        return new Right(
            fn(this._val)
        );
    }
    toString() {
        const str = this._val.toString();
        return `Right(${str})`;
    }
}</pre>
</div>
<p>有了这些，我们可以使用<code>Left</code>或<code>Right</code>和<a href="https://en.wikipedia.org/wiki/Fluent_interface" target="_blank" rel="noopener noreferrer">流畅的语法</a>:</p>
<pre>const leftHello        = new Left('Hello world');
const rightHello       = new Right('Hello world');
const worldToLogRocket = str =&gt; str.replace(/world/, 'LogRocket');

leftHello.map(worldToLogRocket).map(trace);
// Doesn't print anything to the console
// ￩ Left(Hello world)

rightHello.map(worldToLogRocket).map(trace);
// ⦘ Hello LogRocket
// ￩ Right(Hello LogRocket)</pre>
<p>我们有效地创造了两条赛道。我们可以通过调用<code>new Right()</code>把一条数据放在右轨，通过调用<code>new Left()</code>把一条数据放在左轨。</p>
<figure><img data-attachment-id="69201" data-permalink="https://blog.logrocket.com/javascript-either-monad-error-handling/javascript-monad-either-error-handling-left-track-right-track/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2018/12/javascript-monad-either-error-handling-left-track-right-track--e1632851711161.png" data-orig-size="730,451" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="javascript-monad-either-error-handling-left-track-right-track" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2018/12/javascript-monad-either-error-handling-left-track-right-track--300x185.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2018/12/javascript-monad-either-error-handling-left-track-right-track--1024x633.png" decoding="async" class="aligncenter size-full wp-image-69201 jetpack-lazy-image" src="../Images/6d1a9a6e771a7a59712c53d0b9cc8303.png" alt="javascript monad either error handling left track right track" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2018/12/javascript-monad-either-error-handling-left-track-right-track--e1632851711161.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2018/12/javascript-monad-either-error-handling-left-track-right-track--e1632851711161.png"/><noscript><img data-lazy-fallback="1" data-attachment-id="69201" data-permalink="https://blog.logrocket.com/javascript-either-monad-error-handling/javascript-monad-either-error-handling-left-track-right-track/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2018/12/javascript-monad-either-error-handling-left-track-right-track--e1632851711161.png" data-orig-size="730,451" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="javascript-monad-either-error-handling-left-track-right-track" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2018/12/javascript-monad-either-error-handling-left-track-right-track--300x185.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2018/12/javascript-monad-either-error-handling-left-track-right-track--1024x633.png" decoding="async" loading="lazy" class="aligncenter size-full wp-image-69201" src="../Images/6d1a9a6e771a7a59712c53d0b9cc8303.png" alt="javascript monad either error handling left track right track" data-original-src="https://blog.logrocket.com/wp-content/uploads/2018/12/javascript-monad-either-error-handling-left-track-right-track--e1632851711161.png"/></noscript></figure>
<p>如果我们沿着正确的轨迹绘制地图，我们会沿着快乐的路径处理数据。如果我们最终走上了左边的路，什么也不会发生。我们只是不断地传递值。比方说，如果我们将一个<code>Error</code>放在左边的轨道上，那么我们就会得到一个与<code>try…catch</code>非常相似的东西。</p>
<figure><img data-attachment-id="69206" data-permalink="https://blog.logrocket.com/javascript-either-monad-error-handling/javascript-monad-either-error-handling-left-track-right-track-map/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2018/12/javascript-monad-either-error-handling-left-track-right-track-map-e1632851850101.png" data-orig-size="730,451" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="javascript-monad-either-error-handling" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2018/12/javascript-monad-either-error-handling-left-track-right-track-map-300x185.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2018/12/javascript-monad-either-error-handling-left-track-right-track-map-1024x633.png" decoding="async" class="aligncenter size-full wp-image-69206 jetpack-lazy-image" src="../Images/310c8efdd9c2923b521e7e616a186a89.png" alt="javascript monad either error handling left track right track" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2018/12/javascript-monad-either-error-handling-left-track-right-track-map-e1632851850101.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2018/12/javascript-monad-either-error-handling-left-track-right-track-map-e1632851850101.png"/><noscript><img data-lazy-fallback="1" data-attachment-id="69206" data-permalink="https://blog.logrocket.com/javascript-either-monad-error-handling/javascript-monad-either-error-handling-left-track-right-track-map/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2018/12/javascript-monad-either-error-handling-left-track-right-track-map-e1632851850101.png" data-orig-size="730,451" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="javascript-monad-either-error-handling" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2018/12/javascript-monad-either-error-handling-left-track-right-track-map-300x185.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2018/12/javascript-monad-either-error-handling-left-track-right-track-map-1024x633.png" decoding="async" loading="lazy" class="aligncenter size-full wp-image-69206" src="../Images/310c8efdd9c2923b521e7e616a186a89.png" alt="javascript monad either error handling left track right track" data-original-src="https://blog.logrocket.com/wp-content/uploads/2018/12/javascript-monad-either-error-handling-left-track-right-track-map-e1632851850101.png"/></noscript></figure>
<p>随着我们的继续，一直写“向左还是向右”会有点痛苦。所以我们将左右组合一起称为“任一”不是向左就是向右。</p>
<h3>在JavaScript中创建任一对象的快捷方式</h3>
<p>因此，下一步将是重写我们的示例函数，使它们返回一个要么。左边为一个<code>Error</code>，右边为一个值。但是，在我们这样做之前，让我们去掉一些乏味的东西。我们将写一些小的快捷方式。</p>
<p>第一个是名为<code>.of()</code>的静态方法。它所做的只是返回一个<code>new Left</code>或<code>new Right</code>。代码可能如下所示:</p>
<pre>Left.of = function of(x) {
    return new Left(x);
};

Right.of = function of(x) {
    return new Right(x);
};</pre>
<p>老实说，我甚至觉得<code>Left.of()</code>和<code>Right.of()</code>写起来很乏味。所以我倾向于创建更短的快捷方式，叫做<code>left()</code>和<code>right()</code>:</p>
<pre>function left(x) {
    return Left.of(x);
}

function right(x) {
    return Right.of(x);
}</pre>
<p>有了这些，我们就可以开始重写我们的应用程序功能了:</p>
<pre>function zipRow(headerFields, fieldData) {
    const lengthMatch = (headerFields.length == fieldData.length);
    return (!lengthMatch)
        ? left(new Error("Row has an unexpected number of fields"))
        : right(_.zipObject(headerFields, fieldData));
}

function addDateStr(messageObj) {
    const errMsg = 'Unable to parse date stamp in message object';
    const d = new Date(messageObj.datestamp);
    if (isNaN(d)) { return left(new Error(errMsg));  }

    const datestr = Intl.DateTimeFormat('en-US', {year: 'numeric', month: 'long', day: 'numeric'}).format(d);
    return right({datestr, ...messageObj});
}
</pre>
<p>修改后的功能与旧的没有太大区别。我们只是将返回值包装在<code>left</code>或<code>right</code>中，这取决于我们是否发现了错误。</p>
<p>完成这些后，我们可以开始重写处理单行的主函数。我们首先用<code>right()</code>将行字符串放入一个要么中，然后映射<code>splitFields()</code>来分割它:</p>
<pre>function processRow(headerFields, row) {
    const fieldsEither   = right(row).map(splitFields);
   // …
}</pre>
<p>这工作得很好，但是当我们尝试用<code>zipRow()</code>做同样的事情时，我们遇到了麻烦:</p>
<pre>function processRow(headerFields, row) {
    const fieldsEither   = right(row).map(splitFields);
    const rowObj         = fieldsEither.map(zipRow /* wait. this isn't right */);
    // ...
}</pre>
<p>这是因为<code>zipRow()</code>需要两个参数。但是我们传递给<code>.map()</code>的函数只能从<code>._value</code>属性中获得一个值。解决这个问题的一个方法是创建一个curried版本的<code>zipRow()</code>。函数currying就是简单地将一个函数的参数划分到多个调用中，利用闭包来传递已经部分应用的函数。它可能看起来像这样:</p>
<pre>function zipRow(headerFields) {
    return function zipRowWithHeaderFields(fieldData) {
        const lengthMatch = (headerFields.length == fieldData.length);
        return (!lengthMatch)
            ? left(new Error("Row has an unexpected number of fields"))
            : right(_.zipObject(headerFields, fieldData));
    };
}</pre>
<p>这个微小的变化使得转换<code>zipRow()</code>变得更加容易，因此它将与<code>.map()</code>很好地配合工作:</p>
<pre>function processRow(headerFields, row) {
    const fieldsEither   = right(row).map(splitFields);
    const rowObj         = fieldsEither.map(zipRow(headerFields));
    // ... But now we have another problem ...
}</pre>
<h3><code>.join()</code></h3>
<p>使用<code>.map()</code>来运行<code>splitFields()</code>是可以的，因为<code>splitFields()</code>也不返回an。但是当我们开始运行<code>zipRow()</code>时，我们遇到了一个问题。调用<code>zipRow()</code>返回一个要么。所以，如果我们使用<code>.map()</code>，我们最终会把一个要么放在一个要么里面。如果我们再往前走，我们就会被卡住，除非我们在<code>.map()</code>内运行<code>.map()</code>。</p>
<p>这不会有什么效果的。我们需要某种方法将那些嵌套的连接在一起。因此，我们将编写一个名为<code>.join()</code>的新方法:</p>
<div>
<pre>/**
*Left represents the sad path.
*/
class Left {
    constructor(val) {
        this._val = val;
    }
    map() {
        // Left is the sad path
        // so we do nothing
        return this;
    }
    join() {
        // On the sad path, we don't
        // do anything with join
        return this;
    }
    toString() {
        const str = this._val.toString();
        return `Left(${str})`;
    }
}</pre>
</div>
<div>
<pre>/**
*Right represents the happy path
*/
class Right {
    constructor(val) {
        this._val = val;
    }
    map(fn) {
        return new Right(
            fn(this._val)
        );
    }
    join() {
        if ((this._val instanceof Left)
            || (this._val instanceof Right))
        {
            return this._val;
        }
        return this;
    }
    toString() {
        const str = this._val.toString();
        return `Right(${str})`;
    }
}</pre>
</div>
<p>现在我们可以自由地解开我们的价值观:</p>
<pre>function processRow(headerFields, row) {
    const fieldsEither   = right(row).map(splitFields);
    const rowObj         = fieldsEither.map(zipRow(headerFields)).join();
    const rowObjWithDate = rowObj.map(addDateStr).join();
    // Slowly getting better... but what do we return?
}</pre>
<h3><code>.chain()</code></h3>
<p>我们已经走得更远了。但是每次都记得打电话<code>.join()</code>很烦。这种同时调用<code>.map()</code>和<code>.join()</code>的模式非常常见，我们将为它创建一个快捷方法。我们称它为<code>.chain()</code>，因为它允许我们将返回<code>Left</code>或<code>Right</code>的函数链接在一起:</p>
<div>
<pre>/**
*Left represents the sad path.
*/
class Left {
    constructor(val) {
        this._val = val;
    }
    map() {
        // Left is the sad path
        // so we do nothing
        return this;
    }
    join() {
        // On the sad path, we don't
        // do anything with join
        return this;
    }
    chain() {
        // Boring sad path,
        // do nothing.
        return this;
    }
    toString() {
        const str = this._val.toString();
        return `Left(${str})`;
    }
}</pre>
</div>
<div>
<pre>/**
*Right represents the happy path
*/
class Right {
    constructor(val) {
        this._val = val;
    }
    map(fn) {
        return new Right(
            fn(this._val)
        );
    }
    join() {
        if ((this._val instanceof Left)
            || (this._val instanceof Right)) {
            return this._val;
        }
        return this;
    }
    chain(fn) {
        return fn(this._val);
    }
    toString() {
        const str = this._val.toString();
        return `Right(${str})`;
    }
}</pre>
</div>
<p>回到我们的铁路轨道类比，<code>.chain()</code>允许我们在遇到错误时切换轨道。不过，用图表来展示更容易。</p>
<figure><img data-attachment-id="69209" data-permalink="https://blog.logrocket.com/javascript-either-monad-error-handling/javascript-monad-either-error-handling-left-track-right-track-chain/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2018/12/javascript-monad-either-error-handling-left-track-right-track-chain-e1632851936239.png" data-orig-size="730,451" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="javascript-monad-either-error-handling left track right track chain" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2018/12/javascript-monad-either-error-handling-left-track-right-track-chain-300x185.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2018/12/javascript-monad-either-error-handling-left-track-right-track-chain-1024x633.png" decoding="async" class="aligncenter size-full wp-image-69209 jetpack-lazy-image" src="../Images/a9d7bf29d07e63d4f9630b2d8c72a7ad.png" alt="javascript monad either error handling left track right track chain" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2018/12/javascript-monad-either-error-handling-left-track-right-track-chain-e1632851936239.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2018/12/javascript-monad-either-error-handling-left-track-right-track-chain-e1632851936239.png"/><noscript><img data-lazy-fallback="1" data-attachment-id="69209" data-permalink="https://blog.logrocket.com/javascript-either-monad-error-handling/javascript-monad-either-error-handling-left-track-right-track-chain/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2018/12/javascript-monad-either-error-handling-left-track-right-track-chain-e1632851936239.png" data-orig-size="730,451" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="javascript-monad-either-error-handling left track right track chain" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2018/12/javascript-monad-either-error-handling-left-track-right-track-chain-300x185.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2018/12/javascript-monad-either-error-handling-left-track-right-track-chain-1024x633.png" decoding="async" loading="lazy" class="aligncenter size-full wp-image-69209" src="../Images/a9d7bf29d07e63d4f9630b2d8c72a7ad.png" alt="javascript monad either error handling left track right track chain" data-original-src="https://blog.logrocket.com/wp-content/uploads/2018/12/javascript-monad-either-error-handling-left-track-right-track-chain-e1632851936239.png"/></noscript></figure>
<p>有了这些，我们的代码就更清晰了:</p>
<pre>function processRow(headerFields, row) {
    const fieldsEither   = right(row).map(splitFields);
    const rowObj         = fieldsEither.chain(zipRow(headerFields));
    const rowObjWithDate = rowObj.chain(addDateStr);
    // Slowly getting better... but what do we return?
}</pre>
<h3>实施<code>get() method</code></h3>
<p>我们几乎完成了对<code>processRow()</code>函数的修改。但是当我们返回值的时候会发生什么呢？最终，我们想根据我们是左撇子还是右撇子采取不同的行动。因此，我们将编写一个相应地采取不同操作的函数:</p>
<pre>function either(leftFunc, rightFunc, e) {
    return (e instanceof Left) ? leftFunc(e.get()) : rightFunc(e.get());
}
</pre>
<p>我们需要在<code>Left</code>和<code>Right</code>上实现那个<code>get() method</code>，这将允许我们解开潜在的值，现在我们已经准备好使用它了:</p>
<pre>/**
*Left represents the sad path.
*/
class Left {
    constructor(val) {
        this._val = val;
    }
    map() {
        // Left is the sad path
        // so we do nothing
        return this;
    }
    join() {
        // On the sad path, we don't
        // do anything with join
        return this;
    }
    chain() {
        // Boring sad path,
        // do nothing.
        return this;
    }
    get() {
        return this._val;
    }
    toString() {
        const str = this._val.toString();
        return `Left(${str})`;
    }
}
/**
*Right represents the happy path
*/
class Right {
    constructor(val) {
        this._val = val;
    }
    map(fn) {
        return new Right(
            fn(this._val)
        );
    }
    join() {
        if ((this._val instanceof Left)
            || (this._val instanceof Right)) {
            return this._val;
        }
        return this;
    }
    chain(fn) {
        return fn(this._val);
    }
    get() {
        return this._val;
    }
    toString() {
        const str = this._val.toString();
        return `Right(${str})`;
    }
}</pre>
<p>我们现在能够完成我们的<code>processRow</code>功能了:</p>
<pre>function processRow(headerFields, row) {
    const fieldsEither   = right(row).map(splitFields);
    const rowObj         = fieldsEither.chain(zipRow(headerFields));
    const rowObjWithDate = rowObj.chain(addDateStr);
    return either(showError, rowToMessage, rowObjWithDate);
}
</pre>
<p>而且，如果我们感觉特别聪明，我们可以用流畅的语法来写它:</p>
<pre>function processRow(headerFields, row) {
    const rowObjWithDate = right(row)
        .map(splitFields)
        .chain(zipRow(headerFields))
        .chain(addDateStr);
    return either(showError, rowToMessage, rowObjWithDate);
}</pre>
<p>两个版本都非常简洁。一点也看不见。并且在我们的顶层函数中没有<code>if</code>语句。如果某个函数有问题，我们会在最后显示一条错误消息。请注意，在<code>processRow()</code>中，我们唯一一次提到左或右是在我们调用<code>right()</code>的最开始。对于其余的，我们只是使用<code>.map()</code>和<code>.chain()</code>方法来应用下一个函数。</p>
<h3><code>.ap()</code>和<code>lift</code></h3>
<p>这看起来不错，但我们还需要考虑最后一种情况。继续这个例子，让我们看看如何处理整个CSV数据，而不仅仅是每一行。我们需要一个或三个助手函数:</p>
<pre>function splitCSVToRows(csvData) {
    // There should always be a header row... so if there's no
    // newline character, something is wrong.
    return (csvData.indexOf('\n') &lt; 0)
        ? left('No header row found in CSV data')
        : right(csvData.split('\n'));
}

function processRows(headerFields, dataRows) {
    // Note this is Array map, not Either map.
    return dataRows.map(row =&gt; processRow(headerFields, row));
}

function showMessages(messages) {
    return `&lt;ul class="Messages"&gt;${messages.join('\n')}&lt;/ul&gt;`;
}</pre>
<p>因此，我们有一个助手函数，它将CSV数据分成行。我们得到一个要么回来。现在，我们可以使用<code>.map()</code>和一些lodash函数从数据行中分离出标题行。但是我们最终陷入了一个有趣的境地…</p>
<pre>function csvToMessages(csvData) {
    const csvRows      = splitCSVToRows(csvData);
    const headerFields = csvRows.map(_.head).map(splitFields);
    const dataRows     = csvRows.map(_.tail);
    // What’s next?
}</pre>
<p>我们已经准备好用<code>processRows()</code>映射我们的标题字段和数据行。但是<code>headerFields</code>和<code>dataRows</code>都被包裹在一个要么里面。我们需要某种方法将<code>processRows()</code>转换成一个可以同时使用的函数。作为第一步，我们将库里<code>processRows</code>:</p>
<pre>function processRows(headerFields) {
    return function processRowsWithHeaderFields(dataRows) {
        // Note this is Array map, not Either map.
        return dataRows.map(row =&gt; processRow(headerFields, row));
    };
}</pre>
<p>现在，有了这个，我们可以运行一个实验。我们有<code>headerFields</code>，它是一个包裹在数组周围的要么。如果我们用<code>headerFields</code>调用<code>processRows()</code>上的<code>.map()</code>，会发生什么？</p>
<pre>function csvToMessages(csvData) {
    const csvRows      = splitCSVToRows(csvData);
    const headerFields = csvRows.map(_.head).map(splitFields);
    const dataRows     = csvRows.map(_.tail);

    // How will we pass headerFields and dataRows to
    // processRows() ?
    const funcInEither = headerFields.map(processRows);
}</pre>
<p>这里使用<code>.map()</code>调用<code>processRows()</code>的外部函数，而不是内部函数。换句话说，<code>processRows()</code>返回一个我们仍然需要执行的函数。而且因为是<code>.map()</code>，我们还是得到一个要么回。</p>
<p>所以我们最终得到了一个要么里面的函数。我用变量名透露了一点。<code>funcInEither</code>是一个要么。它包含一个接受字符串数组并返回不同字符串数组的函数。我们需要某种方法来获取那个函数，并用<code>dataRows</code>中的值调用它。</p>
<p>要做到这一点，我们需要在我们的左右类中再添加一个方法。我们称之为<code>.ap()</code>，因为<a href="https://github.com/fantasyland/fantasy-land#ap-method" target="_blank" rel="noopener noreferrer">标准告诉我们</a>。记住它的方法是回忆一下<code>ap</code>是“应用”的缩写。它帮助我们将值应用于函数。</p>
<p>像往常一样，左派的方法什么也做不了:</p>
<pre>/* Rest of Left class is hidden to save space */

    // Ap In Left (the sad path)
    ap() {
        return this;
    }</pre>
<p>对于正确的类，变量名表明我们期望另一个包含函数:</p>
<pre>    // In Right (the happy path)
    ap(otherEither) {
        const functionToRun = otherEither.get();
        return this.map(functionToRun);
    }
</pre>
<p>有了这些，我们就可以完成我们的主要功能了:</p>
<pre>function csvToMessages(csvData) {
    const csvRows      = splitCSVToRows(csvData);
    const headerFields = csvRows.map(_.head).map(splitFields);
    const dataRows     = csvRows.map(_.tail);
    const funcInEither = headerFields.map(processRows);
    const messagesArr  = dataRows.ap(funcInEither);
    return either(showError, showMessages, messagesArr);
}</pre>
<p>现在，<a href="https://jrsinclair.com/articles/2018/how-to-deal-with-dirty-side-effects-in-your-pure-functional-javascript/#combiningeffects" target="_blank" rel="noopener noreferrer">我已经在</a>之前提到过这一点，但是我发现<code>.ap()</code>有点难以理解。<a href="#74cd"> </a>另一种思考方式是这样说:“我有一个函数，它通常采用两个普通值。我想把它变成一个接受两个中任何一个的函数。”现在我们有了<code>.ap()</code>，我们可以写一个函数来完成这个任务。</p>
<p>我们称它为<code>liftA2()</code>，因为这是一个标准的名字。它采用一个普通的函数，要求有两个参数，并“提升”它来处理应用程序。(应用程序是有一个<code>.ap()</code>方法和一个<code>.of()</code>方法的东西。)所以，<code>liftA2()</code>是“提升可应用的，两个参数”的简称</p>
<p>因此，<code>liftA2()</code>可能是这样的:</p>
<pre>function liftA2(func) {
    return function runApplicativeFunc(a, b) {
        return b.ap(a.map(func));
    };
}</pre>
<p>所以，我们的顶级函数会这样使用它:</p>
<pre>function csvToMessages(csvData) {
    const csvRows      = splitCSVToRows(csvData);
    const headerFields = csvRows.map(_.head).map(splitFields);
    const dataRows     = csvRows.map(_.tail);
    const processRowsA = liftA2(processRows);
    const messagesArr  = processRowsA(headerFields, dataRows);
    return either(showError, showMessages, messagesArr);
}</pre>
<h2>在JavaScript中使用任一单子</h2>
<p>为什么这比抛出异常要好呢？好吧，让我们先想想为什么我们喜欢异常。</p>
<p>如果我们没有异常，我们将不得不到处写很多<code>if</code>语句。我们将永远按照这样的思路编写代码，“如果最后一件事成功了，继续下去；否则，处理错误。我们必须在整个代码中处理这些错误。这使得很难了解正在发生的事情。抛出异常允许我们在出错时跳出程序流。所以我们不必写所有那些<code>if</code>语句；我们可以专注于快乐的道路。</p>
<p>但是有一个问题。例外隐藏的有点太多了。当你抛出一个异常时，你把处理错误变成了其他函数的问题。但是忽略异常太容易了，让它一路冒泡到程序的顶部。</p>
<p>这两种方法的好处在于，它允许您跳出主程序流，就像遇到异常时一样。但它是诚实的。你要么往右，要么往左。你不能假装左手是不可能的；最终，您必须通过类似于<code>either()</code>调用的方式来提取价值。</p>
<p>我知道这听起来很痛苦。但是看看我们写的代码(不是这两个类，而是使用它们的函数)。那里没有很多异常处理代码。事实上，几乎没有，除了<code>csvToMessages()</code>和<code>processRow()</code>结尾的<code>either()</code>调用。这就是关键所在——无论使用哪种方法，您都可以获得不会意外忘记的纯粹的错误处理，但不会在代码中到处添加缩进。</p>
<p>这并不是说你永远不应该使用<code>try…catch</code>。有时这是工作的正确工具，这没什么。但它不是<em>唯一的</em>工具。使用任何一个都给了我们一些<code>try…catch</code>无法比拟的优势。</p>
<p>所以，也许什么时候可以试一试。即使一开始有点棘手，我想你会慢慢喜欢上它的。如果你尝试一下，请不要使用本教程中的实现。尝试一个历史悠久的图书馆，如<a href="https://evilsoft.github.io/crocks/" target="_blank" rel="noopener noreferrer">克罗克</a>、<a href="https://sanctuary.js.org/" target="_blank" rel="noopener noreferrer">避难所</a>、<a href="https://folktale.origamitower.com/" target="_blank" rel="noopener noreferrer">民间故事</a>或<a href="https://monet.github.io/monet.js/" target="_blank" rel="noopener noreferrer">莫奈</a>。它们得到了更好的维护，为了简单起见，我在这里掩盖了一些东西。</p>
<h2>进一步阅读</h2>

<hr/>
<ol>
<li>stroustup，b，2012，<a href="http://www.stroustrup.com/glossary.html#Gpolymorphism" target="_blank" rel="noopener noreferrer">bjarne stroustup的C++术语表</a></li>
<li>事实上，幻境规范以一种令人困惑的方式定义了<code>.ap()</code>,这并没有帮助。它使用与大多数其他语言定义它的方式相反的顺序。</li>
</ol>
<p> </p><div class="code-block code-block-27">
<div class="blog-plug inline-plug vanilla-javascript-cta"><h2><a class="signup" href="https://lp.logrocket.com/blg/javascript-signup" target="_blank" rel="noopener noreferrer">log火箭</a>:通过理解上下文更容易调试JavaScript错误</h2>
<p>调试代码总是一项单调乏味的任务。但是你越了解自己的错误，就越容易改正。</p>
<p>LogRocket 让你以新的独特的方式理解这些错误。我们的前端监控解决方案跟踪用户与您的JavaScript前端的互动，让您能够准确找出导致错误的用户行为。</p>
<a href="https://lp.logrocket.com/blg/javascript-signup" class="signup" target="_blank" rel="noopener noreferrer"><img class="alignnone size-full wp-image-46 jetpack-lazy-image" src="../Images/cbfed9be3defcb505e662574769a7636.png" alt="LogRocket Dashboard Free Trial Banner" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2020/06/reproduce-javascript-errors.gif?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/06/reproduce-javascript-errors.gif"/><noscript><img data-lazy-fallback="1" class="alignnone size-full wp-image-46" src="../Images/cbfed9be3defcb505e662574769a7636.png" alt="LogRocket Dashboard Free Trial Banner" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/06/reproduce-javascript-errors.gif"/></noscript></a>
<p>LogRocket记录控制台日志、页面加载时间、堆栈跟踪、慢速网络请求/响应(带有标题+正文)、浏览器元数据和自定义日志。理解您的JavaScript代码的影响从来没有这么简单过！</p>
<a class="signup" href="https://lp.logrocket.com/blg/javascript-signup" target="_blank" rel="noopener noreferrer">Try it for free</a><p>.</p></div>


</div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
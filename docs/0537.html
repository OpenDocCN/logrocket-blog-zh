<html>
<head>
<title>Natural language processing with Node.js - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>使用Node.js的自然语言处理- LogRocket博客</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/natural-language-processing-node-js/#0001-01-01">https://blog.logrocket.com/natural-language-processing-node-js/#0001-01-01</a></blockquote><div><article class="article-post">
<p><strong> <em>编者按:</em> </strong> <em>本文最后一次更新于2023年1月4日，以确保所有信息与Node.js的最新版本兼容，并添加关于其他NLP库的信息，如NLP.js和Compromise.cool. </em></p>
<p>互联网促进了大量非结构化文本数据的永无止境的创建。幸运的是，我们有现代系统可以理解这种数据。</p>
<p>现代计算机系统可以使用一种叫做<a href="https://en.wikipedia.org/wiki/Natural_language_processing">自然语言处理(NLP) </a>的底层技术来理解自然语言。</p>
<p>Python通常是NLP的首选语言，因为它有丰富的语言处理包，比如自然语言工具包。然而，JavaScript正在快速发展，npm的存在使其开发者能够访问大量的包，包括为不同语言执行NLP的包。</p>
<p>在本文中，我们将重点介绍如何使用Node开始使用NLP。我们将使用一个叫做natural的JavaScript库。通过将自然库添加到我们的项目中，我们的代码将能够解析、解释、操作和理解来自用户输入的自然语言。</p>
<p>本文将仅仅触及NLP的表面，但是对于已经在Python中使用NLP并希望过渡到Node以获得相同结果的开发人员来说，它将非常有用。完全的新手也会学到很多关于NLP作为一种技术及其在Node上的用法。</p>
<p>向前跳:</p>

<h2 id="what-natural-language-processing">什么是自然语言处理？</h2>
<p>自然语言处理技术可以将人类语言作为输入进行处理，并执行以下一项或多项操作:</p>
<ul>
<li><a href="https://en.wikipedia.org/wiki/Sentiment_analysis">情绪分析</a>(是正面陈述还是负面陈述？)</li>
<li>话题分类(是关于什么的？)</li>
<li>根据这一陈述决定应该采取什么行动</li>
<li><a href="http://nlp_architect.nervanasys.com/intent.html">意图提取</a>(这种说法背后的意图是什么？)</li>
</ul>
<blockquote><p>NLP是语言学、计算机科学、信息工程和人工智能的一个分支，涉及计算机和人类(自然)语言之间的交互，特别是如何对计算机进行编程以处理和分析大量自然语言数据。</p></blockquote>
<p>NLP的重要实现离我们不远了，因为我们的大多数设备都集成了AI、ML和NLP来增强人机通信。下面是一些常见的自然语言处理的例子。</p>
<h3>搜索引擎</h3>
<p>最有用的技术之一是谷歌搜索引擎。你输入文本，就会收到数百万条相关的回复结果。这是可能的，因为NLP技术可以理解输入并执行一系列逻辑操作。这也是为什么谷歌搜索能够理解你的意图，并在你拼写错误时向你建议正确的拼写。</p>
<h3>智能虚拟助理</h3>
<p>Siri、Alexa和Google Assistant等虚拟助手展示了NLP实现的高级水平。收到您的口头输入后，它们可以识别意图，执行操作，并以自然语言发回响应。</p>
<h3>智能聊天机器人</h3>
<p>聊天机器人可以分析大量的文本数据，并根据大数据及其检测意图的能力给出不同的响应。这给人一种自然对话而不是与机器对话的总体感觉。</p>
<h3>垃圾邮件过滤器</h3>
<p>您是否注意到电子邮件客户端在过滤收件箱中的垃圾邮件方面不断进步？这是可能的，因为过滤引擎可以理解电子邮件的内容——主要使用<a href="https://en.wikipedia.org/wiki/Naive_Bayes_spam_filtering">贝叶斯垃圾邮件过滤</a>——并决定它是否是垃圾邮件。</p>
<p>上面的用例表明AI、ML和NLP已经在web上被大量使用。因为人类使用自然语言与网站进行交互，所以我们应该建立具有NLP能力的网站。</p>
<h2 id="prerequisites">先决条件</h2>
<ol>
<li>Node.js的基础知识</li>
<li>为运行节点代码而设置的系统</li>
</ol>
<p>要按照本文编写代码，您需要创建一个<code>index.js</code>文件并粘贴您想要尝试的代码片段，然后用Node运行该文件。我们开始吧！</p>
<h2 id="installation">装置</h2>
<p>我们可以通过运行以下命令来安装natural:</p>
<pre class="language-javascript hljs">npm install natural
</pre>
<p>下一节中以下每个使用示例的源代码都可以在<a href="https://github.com/Jordanirabor/nlp-node-natural-article"> GitHub </a>上获得。你可以随意复制它，叉它，或者提交一个问题。</p>
<h3 id="usage">使用</h3>
<p>让我们学习如何使用<a href="https://www.npmjs.com/package/natural"> natural </a>执行一些基本但重要的NLP任务。</p>
<h3 id="tokenization">标记化</h3>
<p><a href="https://en.wikipedia.org/wiki/Natural_language_processing">记号化</a>是将输入的字符或单词分割/拆分成称为“记号”的更小部分的过程标记可以是字符、单词或子单词。标记化是自然语言处理的第一步，需要收集数据并将其分解成机器可以理解的部分。</p>
<p>例如，我们来看文本<a href="https://en.wikipedia.org/wiki/String_(computer_science)">字符串</a> : <code>The quick brown fox jumps over the lazy dog</code></p>
<p>字符串没有像使用自然语言的人所做的那样，隐式地用空格分割。原始输入(43个字符)必须使用给定的空格分隔符(即匹配字符串<code>" "</code>或正则表达式<code>/\s{1}/</code>)显式拆分成9个标记。</p>
<p><a href="https://www.npmjs.com/package/natural"> natural </a>附带了许多智能记号赋予器算法，可以将文本分解成记号数组。下面的代码片段展示了单词tokenizer的用法:</p>
<pre class="language-javascript hljs">// index.js

var natural = require('natural');
var tokenizer = new natural.WordTokenizer();

console.log(tokenizer.tokenize("The quick brown fox jumps over the lazy dog"));
</pre>
<p>使用Node运行此命令会产生以下输出:</p>
<pre class="language-javascript hljs">[ 'The',
  'quick',
  'brown',
  'fox',
  'jumps',
  'over',
  'the',
  'lazy',
  'dog' ]
</pre>
<h2 id="stemming">堵塞物</h2>
<p>词干化是将一个单词缩减为其<a href="https://en.wikipedia.org/wiki/Word_stem">词干</a>(也称为基础或<a href="https://en.wikipedia.org/wiki/Root_(linguistics)">词根</a>形式)的行为。词干是人工智能检索和提取以及语言形态学的一个特征。它被搜索引擎用来索引单词。例如，像cats、catlike和caty这样的词将被分解到词根cat。</p>
<p>Natural目前支持两种词干算法:<a href="http://tartarus.org/martin/PorterStemmer/index.html"> Porter </a>和<a href="https://www.scientificpsychic.com/paice/paice.html"> Lancaster </a> (Paice/Husk)。下面是使用波特算法实现词干提取的代码片段:</p>
<pre class="language-javascript hljs">// index.js

const natural = require('natural');

console.log(natural.PorterStemmer.tokenizeAndStem("I can see that we are going to be friends"))
</pre>
<p>从上面的代码中，我们使用Porter算法下的<code>tokenizeAndStem()</code>方法将字符串分解为单个单词，并将每个单词还原为它们的基本形式。结果是一组词干标记:</p>
<pre class="language-javascript hljs">[ 'go', 'friend' ]
</pre>
<blockquote><p><strong>注意:</strong>，在上面的结果中，算法已经删除了停用词。停用词是自然语言处理前过滤掉的词(如<em> be </em>、<em> an </em>、<em>到</em>都是停用词)。</p></blockquote>
<h2 id="porter-algorithm-vs-lancaster-algorithm">波特算法与兰卡斯特算法</h2>
<p>波特算法是最著名和最古老的词干算法，因为它是最不积极的。词干相当清楚易懂。波特词干分析器是一种后缀剥离算法。本质上，它使用预先定义的原则将单词分解成最基本的形式。Porter stemmer采用了50多条规则，分为五个阶段和几个子步骤，以消除频繁出现的后缀。</p>
<p>这些规则的一些例子是:</p>
<ul>
<li>ATOR--&gt;(操作员--&gt;操作)</li>
<li>SSES -&gt;党卫军(压迫-&gt;压迫)</li>
<li>s--&gt;(规则--&gt;规则)</li>
<li>离子-&gt;(预测-&gt;)预测</li>
<li>ING -&gt;(去-&gt;去，来-&gt;来)</li>
</ul>
<p>另一方面，兰开斯特是相当积极的，由于其紧凑的截词风格，这使得它令人难以置信的令人费解。因为茎失去了一些相关性，它是最少使用的。超过100条规则组成了Lancaster stemmer，大约是Porter stemmer的两倍。作者使用了不同于波特词干规则的符号来定义规则。每个规则由五部分组成，其中两部分是可选的。</p>
<p>这些规则的一些例子是:</p>
<ul>
<li>" nois4j &gt; ":用" j "替换结尾" sion ",并再次应用词干分析器</li>
<li>" sei3y &gt; ":如果单词以" ies "结尾，那么用" y "替换最后三个字母，然后再次对缩写形式应用词干分析器</li>
<li>“mu*2。”:如果单词以“um”结尾，并且单词完整，则删除最后两个字母并终止</li>
</ul>
<h2 id="measuring-similarity-between-words-string-distance">测量单词之间的相似性(字符串距离)</h2>
<p>Natural提供了计算字符串距离、<a href="https://en.wikipedia.org/wiki/Hamming_distance">汉明距离</a>、<a href="https://en.wikipedia.org/wiki/Jaro%E2%80%93Winkler_distance"> Jaro-Winkler </a>、<a href="https://en.wikipedia.org/wiki/Levenshtein_distance"> Levenshtein距离</a>和<a href="https://en.wikibooks.org/wiki/Algorithm_Implementation/Strings/Dice%27s_coefficient">骰子系数</a>的四种算法的实现。使用这些算法，我们可以判断两个字符串是否匹配。为了这个项目，我们将使用汉明距离。</p>
<p>汉明距离通过计算不同字符的数量来测量两个等长字符串之间的距离。第三个参数指示是否应该忽略该案例。默认情况下，该算法区分大小写。</p>
<p>下面是一个代码片段，展示了如何使用卷边算法来计算字符串距离:</p>
<pre class="language-javascript hljs">// index.js

var natural = require('natural');

console.log(natural.HammingDistance("karolin", "kathrin", false));
console.log(natural.HammingDistance("karolin", "kerstin", false));
console.log(natural.HammingDistance("short string", "longer string", false));
</pre>
<p>输出:</p>
<pre class="language-javascript hljs">3
3
-1
</pre>
<p>前两个比较返回<code>3</code>，因为三个字母不同。最后一个函数返回<code>-1</code>，因为被比较的字符串长度不同。</p>
<h2 id="classification">分类</h2>
<p>文本分类，也称为文本标记，是将文本分类到有组织的组中的过程。也就是说，如果我们有一个新的未知语句，我们的处理系统可以根据它的内容决定它最适合哪个类别。</p>
<p>自动文本分类的一些最常见的用例包括:</p>
<ul>
<li>情感分析</li>
<li>话题检测</li>
<li>语言检测</li>
</ul>
<p>natural目前支持两种分类器:<a href="https://en.wikipedia.org/wiki/Naive_Bayes_classifier">朴素贝叶斯</a>和<a href="https://en.wikipedia.org/wiki/Logistic_regression">逻辑回归</a>。以下示例使用了<code>BayesClassifier</code>类:</p>
<pre class="language-javascript hljs">// index.js

var natural = require('natural');

var classifier = new natural.BayesClassifier();
classifier.addDocument('i am long qqqq', 'buy');
classifier.addDocument('buy the q\'s', 'buy');
classifier.addDocument('short gold', 'sell');
classifier.addDocument('sell gold', 'sell');
classifier.train();

console.log(classifier.classify('i am short silver'));
console.log(classifier.classify('i am long copper'));
</pre>
<p>在上面的代码中，我们在样本文本上训练了分类器。它将使用合理的默认值对文本进行分词和词干处理。根据示例文本，控制台将记录以下输出:</p>
<pre class="language-javascript hljs">sell
buy
</pre>
<h2 id="sentiment-analysis">情感分析</h2>
<p><span> <a href="https://en.wikipedia.org/wiki/Sentiment_analysis">情感分析</a>，</span>也称为意见挖掘或情感AI，是NLP最常用的应用之一，它从口头或书面语言中识别和提取观点，以确定一个人的情感。</p>
<p>为了评估一条信息是正面的、负面的还是中性的，利用了情感分析。企业使用情感分析来监控品牌认知度和消费者反馈，以了解产品的表现如何，以及需要什么来增加销售额。</p>
<p>Natural支持这样的算法，即通过将每个单词的极性相加，并用句子的长度将其标准化，来计算每段文本的情感。如果出现否定，结果就是否定的。</p><div class="code-block code-block-54">
<hr/>
<h3>更多来自LogRocket的精彩文章:</h3>

<hr/></div>
<p>下面是它的用法示例:</p>
<pre class="language-javascript hljs">// index.js

var natural = require('natural');
var Analyzer = natural.SentimentAnalyzer;
var stemmer = natural.PorterStemmer;
var analyzer = new Analyzer("English", stemmer, "afinn");

// getSentiment expects an array of strings
console.log(analyzer.getSentiment(["I", "don't", "want", "to", "play", "with", "you"]));
</pre>
<p>该构造函数有三个参数:</p>
<ul>
<li>语言</li>
<li>斯特梅尔:为了增加情感分析器的覆盖范围，可以提供一个词干分析器</li>
<li>词汇:设置词汇的类型。<code>"afinn"</code>、<code>"senticon"</code>或<code>"pattern"</code>为有效值</li>
</ul>
<p>运行上面的代码会产生以下输出:</p>
<pre class="language-javascript hljs">0.42857142857142855 // indicates a relatively negative statement
</pre>
<h2 id="phonetic-matching">语音匹配</h2>
<p>使用natural，我们可以使用语音匹配来比较两个拼写不同但发音相似的单词。这里有一个使用<code>metaphone.compare()</code>方法的例子:</p>
<pre class="language-javascript hljs">// index.js

var natural = require('natural');
var metaphone = natural.Metaphone;
var soundEx = natural.SoundEx;

var wordA = 'phonetics';
var wordB = 'fonetix';

if (metaphone.compare(wordA, wordB))
    console.log('They sound alike!');

// We can also obtain the raw phonetics of a word using process()
console.log(metaphone.process('phonetics'));
</pre>
<p>我们还使用<code>process()</code>获得了一个单词的原始语音。当我们运行上面的代码时，我们得到以下输出:</p>
<pre class="language-javascript hljs">They sound alike!
FNTKS
</pre>
<h2 id="spell-check">拼写检查</h2>
<p>当用户通过搜索栏或输入字段向web应用程序提供输入时，可能会出现打字错误。Natural有一个概率拼写检查器，可以使用来自文本语料库的一组标记来建议拼写错误的单词。</p>
<p>为了简单起见，让我们使用两个单词的数组(也称为语料库)来探索一个示例:</p>
<pre class="language-javascript hljs">// index.js

var natural = require('natural');

var corpus = ['something', 'soothing'];
var spellcheck = new natural.Spellcheck(corpus);

console.log(spellcheck.getCorrections('soemthing', 1)); 
console.log(spellcheck.getCorrections('soemthing', 2));
</pre>
<p>它会建议距离输入单词最大编辑距离的更正(按概率降序排列)。一的最大距离将覆盖80%到95%的拼写错误。在两个距离之后，它变得非常慢。</p>
<p>我们从运行代码中得到以下输出:</p>
<pre class="language-javascript hljs">[ 'something' ]
[ 'something', 'soothing' ]
</pre>
<h2 id="other-nlp-libraries">其他NLP库</h2>
<h3>NLP . JSP</h3>
<p>由AXA集团创建，<a href="https://github.com/axa-group/nlp.js"> NLP.js </a>是一个用于bot开发的NLP包，支持40种语言。它提供实体提取、情感分析、自动语言识别和其他功能。它是创建聊天机器人的理想Node.js库:</p>
<pre class="language-javascript hljs">const { NlpManager } = require('node-nlp');

const manager = new NlpManager({ languages: ['en'], forceNER: true });

// Adds the utterances and intents for the NLP
manager.addDocument('en', 'bye bye take care', 'greetings.bye');
manager.addDocument('en', 'okay see you later', 'greetings.bye');
manager.addDocument('en', 'hello', 'greetings.hello');
manager.addDocument('en', 'hi', 'greetings.hello');

// Train also the NLG
manager.addAnswer('en', 'greetings.bye', 'Till next time');
manager.addAnswer('en', 'greetings.bye', 'see you soon!');
manager.addAnswer('en', 'greetings.hello', 'Hey there!');
manager.addAnswer('en', 'greetings.hello', 'Greetings!');

// Train and save the model.
(async() =&gt; {
    await manager.train();
    manager.save();
    const response = await manager.process('en', 'I should go now');
    console.log(response);
})();
</pre>
<h3 id="compromisecool">妥协，酷</h3>
<p>Compromise.cool是一个非常用户友好的轻量级库。通过将文本转换成数据，它可以用来在你的浏览器中运行NLP，并做出合理的结论。妥协只在英语中起作用。</p>
<p>下面是一个简单的代码片段:</p>
<pre class="language-javascript hljs">import nlp from 'compromise'

var doc = nlp('Sam is coming')
doc.verbs().toNegative()
// 'Sam is not coming'
</pre>
<h3 id="wink">眨眼</h3>
<p>Wink为各种任务提供了NLP功能，包括增强否定、控制省略、生成单词的语法、词干和语音代码。它提供了一个API集合，用于处理字符串，如名称、句子、段落和标记，它们都表示为字符串或单词的数组。它们为许多ML应用程序执行必要的预处理，包括分类和语义搜索:</p>
<pre class="language-javascript hljs">// Load wink-nlp-utils
var nlp = require( 'wink-nlp-utils' );

// Extract person's name from a string:
var name = nlp.string.extractPersonsName( 'Dr. Sarah Connor M. Tech., PhD. - AI' );
console.log( name );
// -&gt; 'Sarah Connor'

// Remove stop words:
var t = nlp.tokens.removeWords( [ 'mary', 'had', 'a', 'little', 'lamb' ] );
console.log( t );
// -&gt; [ 'mary', 'little', 'lamb' ]
</pre>
<h2 id="conclusion">结论</h2>
<p>下面是到目前为止我们在本文中学到的内容的一个快速总结:</p>
<ul>
<li>计算机系统变得越来越智能，可以使用NLP从大量非结构化文本数据中提取意义</li>
<li>Python有丰富的智能包来执行AI、ML和NLP任务，但JavaScript发展非常迅速，其包管理器有大量能够处理自然语言的包</li>
<li>Natural是一个JavaScript包，在执行NLP操作时非常健壮，并且对于每个任务都有许多算法可供选择</li>
</ul>
<p>下一节中以下每个使用示例的源代码是GitHub 上的<a href="https://github.com/Jordanirabor/nlp-node-natural-article">。请随意克隆它、派生它或提交一个问题。</a></p><div class="code-block code-block-23">
<div class="blog-plug inline-plug node-plug"><h2>200只<img src="../Images/61167b9d027ca73ed5aaf59a9ec31267.png" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2019/10/green-check.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" class=" jetpack-lazy-image" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/10/green-check.png"/> <noscript> <img data-lazy-fallback="1" src="../Images/61167b9d027ca73ed5aaf59a9ec31267.png" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/10/green-check.png"/> </noscript>显示器出现故障，生产中网络请求缓慢</h2><p>部署基于节点的web应用程序或网站是容易的部分。确保您的节点实例继续为您的应用程序提供资源是事情变得更加困难的地方。如果您对确保对后端或第三方服务的请求成功感兴趣，</p><a href="https://lp.logrocket.com/blg/node-signup" target="_blank">try LogRocket</a><p>. </p><a class="signup" href="https://lp.logrocket.com/blg/node-signup" target="_blank" rel="noopener noreferrer"><img src="../Images/cae72fd2a54c5f02a6398c4867894844.png" alt="LogRocket Network Request Monitoring" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2019/12/network-request-filter-2-1.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" class=" jetpack-lazy-image" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/12/network-request-filter-2-1.png"/><noscript><img data-lazy-fallback="1" src="../Images/cae72fd2a54c5f02a6398c4867894844.png" alt="LogRocket Network Request Monitoring" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/12/network-request-filter-2-1.png"/></noscript></a><a href="https://lp.logrocket.com/blg/node-signup" target="_blank" rel="noopener noreferrer">https://logrocket.com/signup/</a><p>LogRocket 就像是网络和移动应用程序的DVR，记录下用户与你的应用程序交互时发生的一切。您可以汇总并报告有问题的网络请求，以快速了解根本原因，而不是猜测问题发生的原因。</p><p>LogRocket检测您的应用程序以记录基线性能计时，如页面加载时间、到达第一个字节的时间、慢速网络请求，还记录Redux、NgRx和Vuex操作/状态。</p><a class="signup" href="https://lp.logrocket.com/blg/node-signup" target="_blank" rel="noopener noreferrer">Start monitoring for free</a><p>. </p></div>
</div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
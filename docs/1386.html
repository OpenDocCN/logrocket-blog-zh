<html>
<head>
<title>Using WatermelonDB for offline data sync - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>使用WatermelonDB进行离线数据同步</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/watermelondb-offline-data-sync/#0001-01-01">https://blog.logrocket.com/watermelondb-offline-data-sync/#0001-01-01</a></blockquote><div><article class="article-post">
<h2>概述</h2>
<p>这篇文章可以被看作是上一篇文章的续篇，在上一篇文章中，我写道<a href="https://blog.logrocket.com/offline-app-react-native-watermelondb/">用React Native </a>构建了一个离线体重追踪应用。然而，这并不意味着你需要先阅读整篇文章。</p>
<p>我们将使用我们在那篇文章中编写的代码作为这篇文章的起点，但这篇文章的目标是演示如何将WatermelonDB的同步功能与AdonisJs服务器端API应用程序连接起来。</p>
<h2>探索WatermelonDB的离线功能</h2>
<p>如上所述，作为起点，我们将使用我们在另一篇博文中构建的应用程序。在我们继续之前，让我们创建一个包含React Native和AdonisJs应用程序的文件夹，然后请从这里克隆存储库<a href="https://github.com/foysalit/weightress-app-blog/tree/v1">并检查<strong>分支v1 </strong>:</a></p>
<pre>mkdir weightress &amp;&amp; cd $_
git clone &lt;https://github.com/foysalit/weightress-app-blog.git&gt; app &amp;&amp; cd $_
git checkout v1
yarn</pre>
<p>一旦您安装了代码及其所有依赖项，您应该能够使用您的设备或仿真器在您选择的平台上启动应用程序。我正在使用一个物理Android设备进行测试，所以我将写下这种特殊情况下的步骤，但是其他情况下的步骤应该也是类似的。</p>
<p>连接设备后，只需在终端的一个窗口中运行<code>yarn start</code>,在另一个窗口中运行<code>yarn android</code>。这将在您的设备上启动应用程序。</p>
<p>如果你已经有了一个用WatermelonDB构建的应用程序，并希望与它同步数据，请随意使用，但请记住，你的数据结构将与我们的不同。同样地，表、模式等。将需要进行相应的调整。</p>
<p>总结一下目前的情况，我们有一个应用程序，让我们将一些数据输入到一个名为<code>weights</code>的表中，我们希望通过REST API调用将这些数据与某个服务器同步。由于这是离线应用程序的一个非常常见的要求——能够在设备外部保持数据同步——WatermelonDB自带了这个功能。</p>
<p>让我们看看如何利用它。让我们在<code>data/</code>文件夹中创建一个名为<code>sync.ts</code>的文件，并放入以下代码:</p>
<pre>import {synchronize} from '@nozbe/watermelondb/sync';
import {database} from './database';
// your_local_machine_ip_address usually looks like 192.168.0.x
// on *nix system, you would find it out by running the ifconfig command
const SYNC_API_URL = 'http://&lt;your_local_machine_ip_address&gt;:3333/sync';
export async function sync() {
  await synchronize({
    database,
    pullChanges: async ({lastPulledAt}) =&gt; {
      const response = await fetch(SYNC_API_URL, {
        body: JSON.stringify({lastPulledAt}),
      });
      if (!response.ok) {
        throw new Error(await response.text());
      }

      const {changes, timestamp} = await response.json();
      return {changes, timestamp};
    },
    pushChanges: async ({changes, lastPulledAt}) =&gt; {
      const response = await fetch(
        `${SYNC_API_URL}?lastPulledAt=${lastPulledAt}`,
        {
          method: 'POST',
          body: JSON.stringify(changes),
        },
      );
      if (!response.ok) {
        throw new Error(await response.text());
      }
    },
  });
}</pre>
<p>我们使用来自WatermelonDB的<code>synchronize</code>函数(需要一个数据库实例)、一个<code>pullChanges</code>函数和一个<code>pushChanges</code>函数。数据库实例已经从<code>database.ts</code>文件中导出，所以我们导入并传递它。</p>
<p><code>pullChanges</code>从远程数据源引入数据，并用远程数据更新本地数据库。在函数体中，我们使用WatermelonDB提供的<code>lastPulledAt</code>时间戳向<code>SYNC_API_URL</code>端点发出一个<code>GET</code>请求。该URL指向<code>&lt;your_local_machine_ip_address&gt;:3333/sync</code>，一旦我们构建出Adonis应用程序，就可以使用它。</p>
<blockquote><p><strong>注意</strong>:我们不能在React本地代码中使用<code>localhost:3333</code>，因为我们的应用程序将在不同的设备上运行，而该设备的本地主机与运行Adonis应用程序的机器的本地主机不同。这就是为什么你必须使用IP地址。</p></blockquote>
<p>请注意，在请求响应中，我们期望收到一个带有更改和时间戳属性的对象。这是我们<em>必须</em>从<code>pullChanges</code>函数调用返回的内容，以便与WatermelonDB的同步实现兼容。</p>
<p><code>pushChanges</code>是将本地数据发送到远程数据源的函数。自然，我们向我们的<code>SYNC_API_URL</code>发出一个<code>POST</code>请求，在请求体中，我们附加了WatermelonDB提供给我们的<code>changes</code>变量。</p>
<p>注意，我们没有从函数中返回任何东西，但是如果API请求没有返回OK状态，我们将抛出一个错误。这是至关重要的，因为通过抛出一个错误，我们可以确保如果推送在服务器端以某种方式中断，WatermelonDB会做它的事情来确保数据完整性得到维护。</p>
<h2>使用AdonisJs生成我们的API应用程序</h2>
<p>Adonis附带了一个方便的样板生成器命令。要运行它，确保您在<code>weightress/</code>文件夹中并运行命令<code>yarn create adonis-ts-app api</code>。你会得到几个问题；提供如下的答案，你将会看到一个名为<code>api</code>的目录。</p>
<p><img data-attachment-id="30349" data-permalink="https://blog.logrocket.com/watermelondb-offline-data-sync/adonisjs-boilerplate-generator/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/12/adonisjs-boilerplate-generator.png" data-orig-size="730,395" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Running the AdonisJs boilerplate generator" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/12/adonisjs-boilerplate-generator-300x162.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/12/adonisjs-boilerplate-generator.png" decoding="async" class="aligncenter size-full wp-image-30349 jetpack-lazy-image" src="../Images/9dbcf6e11c7445d7a59478ce4c2f9a57.png" alt="Running the AdonisJs Boilerplate Generator" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2020/12/adonisjs-boilerplate-generator.png 730w, https://blog.logrocket.com/wp-content/uploads/2020/12/adonisjs-boilerplate-generator-300x162.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2020/12/adonisjs-boilerplate-generator.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/12/adonisjs-boilerplate-generator.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="30349" data-permalink="https://blog.logrocket.com/watermelondb-offline-data-sync/adonisjs-boilerplate-generator/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/12/adonisjs-boilerplate-generator.png" data-orig-size="730,395" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Running the AdonisJs boilerplate generator" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/12/adonisjs-boilerplate-generator-300x162.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/12/adonisjs-boilerplate-generator.png" decoding="async" loading="lazy" class="aligncenter size-full wp-image-30349" src="../Images/9dbcf6e11c7445d7a59478ce4c2f9a57.png" alt="Running the AdonisJs Boilerplate Generator" srcset="https://blog.logrocket.com/wp-content/uploads/2020/12/adonisjs-boilerplate-generator.png 730w, https://blog.logrocket.com/wp-content/uploads/2020/12/adonisjs-boilerplate-generator-300x162.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/12/adonisjs-boilerplate-generator.png"/></noscript>
<p>Adonis使用一个名为Ace的包来构建和运行CLI命令。然而，要开始使用它，您需要首先编译代码。不要担心——这就像运行一个yarn命令一样简单。只需运行<code>cd api &amp;&amp; yarn build</code>，您应该会看到如下输出:</p>
<p><img data-attachment-id="30351" data-permalink="https://blog.logrocket.com/watermelondb-offline-data-sync/compiling-adonisjs-code-ace/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/12/compiling-adonisjs-code-ace-e1607522635806.png" data-orig-size="730,120" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Compiling the AdonisJs code to use Ace" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/12/compiling-adonisjs-code-ace-300x49.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/12/compiling-adonisjs-code-ace-e1607522635806.png" decoding="async" class="aligncenter wp-image-30351 size-full jetpack-lazy-image" src="../Images/398d8a508a7d4c9b320a0e7b201b703e.png" alt="Compiling Our AdonisJS Code to Use Ace" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2020/12/compiling-adonisjs-code-ace-e1607522635806.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/12/compiling-adonisjs-code-ace-e1607522635806.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="30351" data-permalink="https://blog.logrocket.com/watermelondb-offline-data-sync/compiling-adonisjs-code-ace/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/12/compiling-adonisjs-code-ace-e1607522635806.png" data-orig-size="730,120" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Compiling the AdonisJs code to use Ace" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/12/compiling-adonisjs-code-ace-300x49.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/12/compiling-adonisjs-code-ace-e1607522635806.png" decoding="async" loading="lazy" class="aligncenter wp-image-30351 size-full" src="../Images/398d8a508a7d4c9b320a0e7b201b703e.png" alt="Compiling Our AdonisJS Code to Use Ace" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/12/compiling-adonisjs-code-ace-e1607522635806.png"/></noscript>
<p> </p>
<p>现在，我们在这个应用程序中需要做的第一件事是将我们在WatermelonDB中的数据结构复制到我们的服务器数据库中。在这种情况下，我选择MySQL作为数据库，Lucid作为与数据库通信的ORM。</p>
<p>同样，AdonisJs可以方便地引导与数据库相关的所有东西。运行以下命令将这一切整合在一起:</p>
<pre>yarn add @adonisjs/<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="4d21382e24290d2c213d252c">[email protected]</a>
node ace invoke @adonisjs/lucid
yarn build</pre>
<p>第二个命令将要求您选择一个数据库提供者。我选择MySQL，但是你也可以随意选择你喜欢的数据库，因为它在这篇文章中不会有太大的不同。这是我的终端窗口的输出，供参考:</p>
<p><img data-attachment-id="30352" data-permalink="https://blog.logrocket.com/watermelondb-offline-data-sync/choosing-mysql-db-provider/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/12/choosing-mysql-db-provider.png" data-orig-size="730,164" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Choosing MySQL as the DB provider" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/12/choosing-mysql-db-provider-300x67.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/12/choosing-mysql-db-provider.png" decoding="async" class="aligncenter size-full wp-image-30352 jetpack-lazy-image" src="../Images/377a6209403eae6eca91fe6334d1c2e5.png" alt="Choosing MySQL as the DB Provider" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2020/12/choosing-mysql-db-provider.png 730w, https://blog.logrocket.com/wp-content/uploads/2020/12/choosing-mysql-db-provider-300x67.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2020/12/choosing-mysql-db-provider.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/12/choosing-mysql-db-provider.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="30352" data-permalink="https://blog.logrocket.com/watermelondb-offline-data-sync/choosing-mysql-db-provider/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/12/choosing-mysql-db-provider.png" data-orig-size="730,164" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Choosing MySQL as the DB provider" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/12/choosing-mysql-db-provider-300x67.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/12/choosing-mysql-db-provider.png" decoding="async" loading="lazy" class="aligncenter size-full wp-image-30352" src="../Images/377a6209403eae6eca91fe6334d1c2e5.png" alt="Choosing MySQL as the DB Provider" srcset="https://blog.logrocket.com/wp-content/uploads/2020/12/choosing-mysql-db-provider.png 730w, https://blog.logrocket.com/wp-content/uploads/2020/12/choosing-mysql-db-provider-300x67.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/12/choosing-mysql-db-provider.png"/></noscript>
<p>现在，为了连接到MySQLdb，我们需要添加凭证作为env变量。阿多尼斯让处理这些变得很容易。打开。env文件，您应该会看到类似这样的内容:</p>
<pre>DB_CONNECTION=mysql
DB_HOST=127.0.0.1
DB_USER=lucid
DB_PASSWORD=
DB_NAME=lucid</pre>
<p>调整这些变量的值，以匹配您的本地或远程MySQL数据库的凭证，以确保应用程序可以连接到它。</p>
<p>在我们开始编写应用程序代码之前，让我们确保我们的数据库已经设置好，可以支持来自应用程序的数据。说到模式管理，通过迁移来做总是更好更容易，所以我们将从创建其中一个开始:<code>node ace make:migration weights</code>。这将在<code>database/migrations/</code>文件夹中放置一个新文件。打开该文件，并用以下代码替换内容:</p>
<pre>import BaseSchema from '@ioc:Adonis/Lucid/Schema'

export default class Weights extends BaseSchema {
  protected tableName = 'weights'

  public async up () {
    this.schema.createTable(this.tableName, (table) =&gt; {
      table.increments('id')
      table.double('weight')
      table.string('note')
      table.timestamps(true)
    })
  }

  public async down () {
    this.schema.dropTable(this.tableName)
  }
}</pre>
<p>当迁移运行时，这将在我们的MySQL数据库中创建一个名为<code>weights</code>的新表，其中有一个自动递增的<code>id</code>列；一个可以保存浮点数的<code>weight</code>列；名为<code>note</code>的字符串列；以及一个名为<code>timestamps</code>的栏目，由美少年自动添加名为<code>created_at</code>和<code>updated_at</code>的栏目。</p>
<p>如您所见，这与我们在WatermelonDB中的<code>weights</code>表模式几乎完全相同，除了一些MySQL特有的东西，如<code>PRIMARY KEY</code>列。您可以将它与React本机应用程序代码中的<code>data/schema.ts</code>文件中的模式代码进行匹配。</p>
<p>最后，不要忘记<code>run yarn build &amp;&amp; node ace migration:run</code>以便在您的数据库上运行这个迁移。</p>
<p>现在，为了从Adonis应用程序中交流/操作这些数据，我们需要一个模型。让我们通过运行<code>node ace make:model weight</code>来实现这一点，这将在<code>app/models/Weight.ts</code>中生成一个新文件。将该文件中的代码替换为:</p>
<pre>import { DateTime } from 'luxon'
import { BaseModel, column } from '@ioc:Adonis/Lucid/Orm'

export default class Weight extends BaseModel {
  @column({ isPrimary: true })
  public id: number

  @column()
  public weight: number

  @column()
  public note: string

  @column.dateTime({ autoCreate: true })
  public createdAt: DateTime

  @column.dateTime({ autoCreate: true, autoUpdate: true })
  public updatedAt: DateTime
}</pre>
<p>唯一的新行是<code>weight</code>和<code>note</code>列定义。这确保了这两个属性都可以在该模型的代码中公开访问。这也非常类似于我们对WatermelonDB的模型定义；你可以把它和文件<code>data/weight.ts</code>进行比对。</p>
<h2>为同步构建我们的REST API端点</h2>
<p>到目前为止，我们已经在API中构建了“引擎盖下的机器”。现在是时候使用这种机制来构建我们的REST API同步端点了，这也是我们对React原生应用程序的期望。如果您还记得，我们只需要一个位于<code>/sync</code>的端点，但是它必须能够服务于<code>GET</code>和<code>POST</code>请求。</p><div class="code-block code-block-54">
<hr/>
<h3>更多来自LogRocket的精彩文章:</h3>

<hr/></div>
<p>我们从在<code>start/routes.ts</code>文件中添加这两行开始:</p>
<pre>Route.get('sync', 'SyncsController.push');
Route.post('sync', 'SyncsController.pull');</pre>
<p>这告诉Adonis使<code>/sync</code>端点可用，并对<code>GET</code>请求使用<code>push</code>方法，对<code>POST</code>请求使用<code>pull</code>方法，这两个方法都来自一个神秘的<code>SyncsController</code>类。我们将马上讨论控制器，但是注意这里的命名可能有点混乱。</p>
<p>但是，如果从API服务器的数据库角度来看，<code>GET</code>请求是由来自WatermelonDB的<code>pullChanges</code>调用生成的，WatermelonDB是来自该数据库的POV的远程数据。因此，从这方面来说，这与将数据从这方面推送到远程源是一样的。</p>
<p>类似地，来自WatermelonDB的<code>pushChanges</code>调用生成一个<code>POST</code>请求，这类似于来自服务器数据库的POV的一个<code>pull</code>动作。有点晕，不用想太多。</p>
<p>现在我们来看看<code>SyncsController</code>。当在路由定义中的指定端点接收到请求时，控制器方法被触发。让我们通过运行<code>node ace make:controller sync</code>来生成我们的同步控制器，这将在<code>app/Controllers/Http/SyncsController.ts</code>创建一个新文件。</p>
<p>现在打开文件，放入以下代码:</p>
<pre>import { DateTime } from 'luxon'
import {RequestContract} from '@ioc:Adonis/Core/Request'
import { HttpContextContract } from '@ioc:Adonis/Core/HttpContext'
import Weight from 'App/Models/Weight'

const getSafeLastPulledAt = (request: RequestContract) =&gt; {
  const lastPulledAt = request.input('lastPulledAt')
  if (lastPulledAt !== 'null') {
    return DateTime.fromMillis(parseInt(lastPulledAt)).toString()
  }
  return DateTime.fromMillis(1).toString()
}

export default class SyncsController {
  public async pull ({ request }: HttpContextContract) {
    const changes = request.input('changes')

    if (changes?.weights?.created?.length &gt; 0) {
      await Weight.createMany(changes.weights.created.map(remoteEntry =&gt; ({
        note: remoteEntry.note,
        weight: remoteEntry.weight,
        watermelonId: remoteEntry.id,
        createdAt: DateTime.fromMillis(parseInt(remoteEntry.created_at)),
      })))
    }

    if (changes?.weights?.updated?.length &gt; 0) {
      const updateQueries = changes.weights.updated.map(remoteEntry =&gt; {
        return Weight.query().where('watermelonId', remoteEntry.id).update({
          note: remoteEntry.note,
          weight: remoteEntry.weight,
        })
      })
      await Promise.all(updateQueries)
    }

    if (changes?.weights?.deleted?.length &gt; 0) {
      await Weight.query().where('watermelon_id', changes.weights.deleted).exec()
    }
  }
  public async push ({request}: HttpContextContract) {
    const lastPulledAt = getSafeLastPulledAt(request)
    const created = await Weight.query().where('created_at', '&gt;', lastPulledAt).exec()
    const updated = await Weight.query().where('updated_at', '&gt;', lastPulledAt).exec()
    return {
      changes: {
        weights: {
          created,
          updated,
          deleted: [],
        },
      },
      timestamp: Date.now(),
    }
  }
}</pre>
<p>好了，这里发生了很多事情，所以让我们一次解开一个方法。<code>pull</code>方法接收一个属性名为<code>changes</code>的对象，它是一个对象。该对象将包含自上次同步以来发生的所有数据库更改，以每个表/集合的名称为关键字。</p>
<p>所以在我们这种情况下，应该看到关键<code>weights</code>。对于每个表，我们有三个数组属性:<code>created</code>，包含所有的新条目；<code>updated</code>，包含所有修改的条目；和<code>deleted</code>，包含自上次同步以来所有删除的条目(在我们的例子中，来自<code>weights</code>表)。</p>
<p>因此，如果在<code>created</code>输入中有任何条目，我们映射数组中的所有条目，并使用<code>Weight.createMany()</code>方法，将所有这些条目插入到我们的服务器端数据库中。</p>
<p>注意，我们正在将<code>created_at</code>转换成一个<code>DateTime</code>实例；WatermelonDB时间戳是只包含数字的Unix时间戳，与Lucid ORM的<code>datetime</code>字段不直接兼容。注意，我们还插入了来自WatermelonDB的<code>id</code>字段，并且我们看到了为什么在接下来的行中需要它。</p>
<p>在服务器端更新时，我们在客户机条目和服务器条目之间的唯一参考点是WatermelonDB生成的ID，这就是为什么我们在同步创建的条目时将它保存在服务器端DB上。因此，为了更新，我们遍历<code>updated</code>输入数组中的所有条目，并使用<code>Weight.query().where('watermelonId', remoteEntry.id).update</code>更新条目。</p>
<p>这里有一点性能问题，因为对于更新数组中的每个条目，我们都要对数据库运行一次更新查询。随着用户群的增长，这可能会很快堵塞我们的数据库，所以请密切关注。最后，我们使用<code>Promise.all</code>等待所有这些查询完成。</p>
<p>删除有点不同。WatermelonDB只发送被删除条目的id，所以我们要做的就是删除所有匹配这些id的条目。</p>
<p><code>push</code>端点有一个类似于<code>pull</code>的接口。它必须返回一个<code>changes</code>属性和一个<code>timestamp</code>属性。<code>timestamp</code>属性非常重要，因为在从客户端成功拉取之后，它将被WatermelonDB保存。</p>
<p>下一次它请求另一个pull时，它将发送先前保存的时间戳，让我们的服务器知道上一次成功同步发生的时间。这就是为什么当请求pull时，WatermelonDB会发送一个<code>'lastPulledAt'</code>输入。对于第一次同步，它将被设置为<code>null</code>，所以为了翻译这个输入，我们有一个叫做<code>getSafeLastPulledAt</code>的帮助函数。</p>
<p>在<code>changes</code>中，我们数据库中的每个表/集合应该有一个属性；所以，在我们的例子中，它只包含<code>weights</code>。其中的每一个都将包含<code>created</code>、<code>updated</code>和<code>deleted</code>属性。出于本文的目的，由于我们的用户界面还不允许删除应用程序中的条目，我们将只处理<code>created</code>和<code>updated</code>同步。</p>
<p>使用<code>lastPulledAt</code>时间戳，我们查询数据库中的所有条目，以找到自那以后更新或创建的条目，并在响应中发送它。这就是我们的服务器端应用程序所需要的一切。</p>
<h2>实现同步指示器UX</h2>
<p>在这篇文章的开始，我们只定义了触发同步过程的<code>sync</code>函数。然而，为了使所有这些工作，我们仍然需要通过调用<code>sync</code>函数来触发流程。这可以通过多种方式实现——按需、自动或两者结合。</p>
<p>出于本文的目的，我们将仅通过在每次打开应用时触发<code>sync</code>来构建自动方法。当同步发生时，我们还应该向用户显示某种同步正在进行的指示。我们将在一个组件中构建所有这些。在<code>components/sync-indicator.tsx</code>中创建一个新文件，并放入以下代码:</p>
<pre>import React, {useEffect, useState} from 'react';
import {View, Text} from 'react-native';
import {syncStyles} from './styles';
import {sync} from '../data/sync';

const SyncIndicator = () =&gt; {
  const [syncState, setSyncState] = useState&lt;string&gt;('Syncing data...');

  useEffect(() =&gt; {
    sync()
      .then(() =&gt; setSyncState(''))
      .catch(() =&gt; setSyncState('Sync failed!'));
  });

  if (!syncState) {
    return null;
  }

  return (
    &lt;View style={syncStyles.container}&gt;
      &lt;Text style={syncStyles.text}&gt;{syncState}&lt;/Text&gt;
    &lt;/View&gt;
  );
};

export default SyncIndicator;</pre>
<p>这是一个非常简单的组件，只有一个本地状态，<code>syncState</code>。它最初被设置为<strong>同步数据……</strong>，因为在打开时，这个组件每次都会被加载，我们会触发同步。</p>
<p>一旦组件被加载到视图中，我们就使用<code>useEffect</code>启动<code>sync()</code>函数，当它没有错误地完成时，我们将<code>syncState</code>设置为一个空字符串来标记它完成。如果同步承诺抛出错误，我们将<code>syncState</code>设置为<em>同步失败！</em>让用户知道。</p>
<p>按照这个逻辑，如果<code>syncState</code>为空，我们干脆什么都不渲染。否则，我们用从<code>styles.ts</code>文件导入的一些样式显示<code>syncState</code>文本。让我们来看看风格的定义:</p>
<pre>export const syncStyles = {
  container: {
    paddingVertical: 5,
    alignItems: 'center',
    backgroundColor: primaryColor,
  },
  text: {
    color: '#FFFFFF',
  },
};</pre>
<p>这将在同步状态文本上设置一个背景颜色，使其易于看到。现在我们要做的就是把这个组件放到我们的应用程序中。打开<code>App.tsx</code>文件并在<code><a href="https://blog.logrocket.com/common-bugs-react-native-scrollview/">ScrollView</a></code>区域的顶部呈现组件:</p>
<pre>import Creator from './components/creator'; 
// import the sync indicator
import SyncIndicator from './components/sync-indicator';
// … previous code
&lt;StatusBar /&gt; 
&lt;SafeAreaView&gt;
  // render the sync indicator
  &lt;SyncIndicator /&gt;
  &lt;ScrollView contentInsetAdjustmentBehavior="automatic"&gt;</pre>
<p>现在，如果你打开应用程序并留意运行AdonisJs应用程序的终端窗口，你应该会在屏幕顶部看到一些小文本，上面写着<strong>同步数据……</strong>，它最终会消失，这意味着同步成功。你也可以把你的<code>SYNC_API_URL</code>改成一个随机的URL来模拟同步失败。在这种情况下，您会看到一个<strong>同步失败！</strong>消息。</p>
<p>这是我的设备截图:</p>
<p><img data-attachment-id="30354" data-permalink="https://blog.logrocket.com/watermelondb-offline-data-sync/syncing-data-message-screenshot/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/12/syncing-data-message-screenshot.jpg" data-orig-size="554,1200" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;1&quot;}" data-image-title="Showing the syncing data message" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/12/syncing-data-message-screenshot-139x300.jpg" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/12/syncing-data-message-screenshot-473x1024.jpg" decoding="async" class="aligncenter size-full wp-image-30354 jetpack-lazy-image" src="../Images/9a7fe0b8334557e004af6f4dc36bbae3.png" alt="Device Screenshot Displaying Syncing Data Message" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2020/12/syncing-data-message-screenshot.jpg 554w, https://blog.logrocket.com/wp-content/uploads/2020/12/syncing-data-message-screenshot-139x300.jpg 139w, https://blog.logrocket.com/wp-content/uploads/2020/12/syncing-data-message-screenshot-473x1024.jpg 473w" data-lazy-sizes="(max-width: 554px) 100vw, 554px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2020/12/syncing-data-message-screenshot.jpg?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/12/syncing-data-message-screenshot.jpg"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="30354" data-permalink="https://blog.logrocket.com/watermelondb-offline-data-sync/syncing-data-message-screenshot/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/12/syncing-data-message-screenshot.jpg" data-orig-size="554,1200" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;1&quot;}" data-image-title="Showing the syncing data message" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/12/syncing-data-message-screenshot-139x300.jpg" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/12/syncing-data-message-screenshot-473x1024.jpg" decoding="async" loading="lazy" class="aligncenter size-full wp-image-30354" src="../Images/9a7fe0b8334557e004af6f4dc36bbae3.png" alt="Device Screenshot Displaying Syncing Data Message" srcset="https://blog.logrocket.com/wp-content/uploads/2020/12/syncing-data-message-screenshot.jpg 554w, https://blog.logrocket.com/wp-content/uploads/2020/12/syncing-data-message-screenshot-139x300.jpg 139w, https://blog.logrocket.com/wp-content/uploads/2020/12/syncing-data-message-screenshot-473x1024.jpg 473w" sizes="(max-width: 554px) 100vw, 554px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/12/syncing-data-message-screenshot.jpg"/></noscript>
<h2>测试离线同步行为</h2>
<p>是时候试驾一下了。离线支持的应用程序有点难以测试，尤其是因为在各种场景中可能会出现很多边缘情况。以下是测试和验证基本离线行为是否正常的方法。</p>
<p>打开飞行模式以切断设备上的所有网络连接。然后添加一个新的体重条目，并确认该条目显示在图表上。这也会触发<strong>同步失败！</strong>出现错误，因为它试图将新条目与服务器同步。</p>
<p>现在关闭你的应用程序，关闭飞行模式，然后重新打开应用程序。您应该会在同步指示器中看到<strong>正在同步数据… </strong>消息，该消息最终会消失。在服务器端，如果检查数据库，在飞行模式下添加的条目应该是可见的。</p>
<p>整个AdonisJs应用<a href="https://github.com/foysalit/weightress-app-server">可以在这里</a>找到。</p>
<h2>从这里去哪里</h2>
<p>首先，恭喜你！您现在是一个体重跟踪应用程序的所有者，该应用程序具有完全的离线支持。然而，你可能会同意，这可能不会击败谷歌健康或苹果健康。幸运的是，有很多东西可以完善这一点，以与专业建造的体重跟踪平台竞争。</p>
<p>这里有一些小点子，你可以把它们加入到这个应用中来改进它:</p>
<ol>
<li>离线同步很容易出错。仅仅告诉你的用户同步失败是没有任何帮助的。您可以构建一个详细的错误查看器，向用户显示同步过程中出现了什么错误，以及他们如何克服错误来同步他们的数据。</li>
<li>对于离线应用程序，与服务器同步是不错的，但最终，你必须假设用户会想把他们的数据带回家，而不是保存在某个地方的服务器上。因此，建立一种方法来导出他们的所有数据，并将其导入到应用程序中。</li>
<li>有时，同步可能会部分失败。例如，如果用户在离线模式下添加了五个条目，出于某种原因，在同步期间，其中四个可能会保存在数据库中，但一个可能会失败。拥有一个失败条目的列表可能是有益的，因为您可以要求用户只为失败的条目触发同步，或者要求他们重新插入那些失败的条目。</li>
</ol>
<p>如果你在应用程序中构建了以上的一个或任何一个——甚至更多——请随意<a href="https://twitter.com/foysalit?lang=en">给我一声</a>,我会很乐意审查你的代码。一路平安！</p><div class="code-block code-block-18">
<div class="blog-plug inline-plug react-native-plug"><h2><a href="https://lp.logrocket.com/blg/react-native-signup"> LogRocket </a>:即时重现React原生应用中的问题。</h2><a class="signup" href="https://lp.logrocket.com/blg/react-native-signup" target="_blank" rel="noopener noreferrer"><img class="alignnone size-full wp-image-46 jetpack-lazy-image" src="../Images/110055665562c1e02069b3698e6cc671.png" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2021/10/react-native-plug_v2-2.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2021/10/react-native-plug_v2-2.png"/><noscript><img data-lazy-fallback="1" class="alignnone size-full wp-image-46" src="../Images/110055665562c1e02069b3698e6cc671.png" data-original-src="https://blog.logrocket.com/wp-content/uploads/2021/10/react-native-plug_v2-2.png"/></noscript></a><p><a href="https://lp.logrocket.com/blg/react-native-signup" target="_blank" rel="noopener noreferrer"> LogRocket </a>是一款React原生监控解决方案，可帮助您即时重现问题、确定bug的优先级并了解React原生应用的性能。</p><p>LogRocket还可以向你展示用户是如何与你的应用程序互动的，从而帮助你提高转化率和产品使用率。LogRocket的产品分析功能揭示了用户不完成特定流程或不采用新功能的原因。</p><p>开始主动监控您的React原生应用— <a class="signup" href="https://lp.logrocket.com/blg/react-native-signup" target="_blank" rel="noopener noreferrer">免费试用LogRocket】。</a></p></div>
</div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
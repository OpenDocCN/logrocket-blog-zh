<html>
<head>
<title>Is Go overtaking Node.js? - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>是Go超车Node.js？- LogRocket博客</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/go-overtaking-node-js/#0001-01-01">https://blog.logrocket.com/go-overtaking-node-js/#0001-01-01</a></blockquote><div><article class="article-post">
<p><em> <strong>编者按:</strong>本帖更新于2022年3月16日，删除并更正了过时的信息。</em></p>
<p>Go和Node.js都是在2009年首次发布，用于开发服务器端和网络应用程序。</p>
<p>Go可以解决很多问题，包括系统、大数据、机器学习、视频编辑和音频等等。它还具有与C相同的性能，因为它编译成机器代码，不需要虚拟机或解释器。</p>
<p>在你认为这篇文章是另一场“科技战争”之前，我建议你放慢脚步，继续读下去。这只是Go和Node.js的对比，我会在这里分享两者的优劣。</p>
<p>因此，虽然Go是一个强大的工具，但我并不是在这里拒绝Node.js。此外，它本质上取决于您想要用哪一个来构建。</p>
<p>Node.js和Go非常快，非常适合多线程程序(Node是单线程的，但它可以很好地完成工作，这使得多线程变得没有必要)。</p>
<p>好吧，我们别闹了。在本文中，我们将看看这两个强大工具的优缺点，看看它们如何处理不同的情况，了解它们的可伸缩性，并回答这个问题，“是Go超越Node.js吗？”</p>

<h2 id="go-vs-node-js">Go vs. Node.js</h2>
<p>Node.js是用JavaScript构建跨平台应用程序的最流行的环境。它有助于构建快速和可伸缩的服务器端应用程序，其强大的特性包括事件驱动和非阻塞I/O模型。</p>
<p>另一方面，Go是一种开源的、静态类型的、编译的、跨平台的、快速的和多用途的语言，它提供了最大的并发性、自动内存管理和用于结构类型检查的动态接口。</p>
<p>Go在语法和速度上和C类似。它也类似于C++，因为它是编译的，是一种通用语言。</p>
<p>不要用这些介绍性的或基础的东西来烦你，它们都是流行的和不断发展的，并且基于不同的项目工作得最好，但是我们将深入研究利弊以确定哪个适合你的项目。</p>
<h3 id="concurrency">并发</h3>
<h4>Go擅长并发吗？</h4>
<p><a href="https://blog.logrocket.com/concurrency-patterns-golang-waitgroups-goroutines/"> Go使用协程</a>处理并发，这被称为Goroutines。这些函数或方法与其他函数或方法同时运行。通道使通信能够在处理共享内存时避免竞争情况。</p>
<p>Goroutines是围棋的强势方面；如果一个大型项目需要同时处理几个请求，Go将会执行。然而，Node.js的情况并非如此。</p>
<h4>Node对并发性好吗？</h4>
<p>Node.js是一个使用事件回调机制的单线程工具。这意味着每个函数或方法都以线性顺序执行。</p>
<p>回调是一个在函数完成执行后执行的函数，这意味着我们只能决定等待函数的结果稍后完成。所以，Node.js缺乏并发性。</p>
<p>说到并发性，Go是必然的赢家。</p>
<h3 id="error-handling">错误处理</h3>
<h4>Go的错误处理好吗？</h4>
<p>与使用异常方法处理错误的Node.js不同，Go使用显式样式。没有意外的未捕获的异常。例如，对于每个Go项目，您经常会看到以下代码:</p>
<pre class="language-go hljs">if err != nil {
    return err
}
</pre>
<p>对于一个围棋门外汉来说，这听起来可能是多余的，但围棋的主要目标之一是作为每项功能的一等公民接受错误，这是一种“计划失败，而不是成功”的心态。</p>
<p>使用if <code>err != nil</code>返回值或错误，这有助于您注意到必须首先处理失败。没有必要围绕<code>try catch</code>，它处理每一个可能的异常。</p>
<p>linters的另一个优点是，当你忽略一个错误时，它们会抓住你。</p>
<h4>Node.js中的错误处理是什么？</h4>
<p>关于Node.js，<a href="https://blog.logrocket.com/error-handling-node-js/">错误处理不清楚，不明确</a>。下面的代码正确地处理了错误，但是没有明确或正确地处理出错的地方。错误只会传到控制台，不允许负全部责任。</p>
<pre class="language-javascript hljs">try {
    operation1();
    operation2();
    operation3();
} catch (e) {
    console.error(e);
}
</pre>
<p>Go在处理错误时使用了一种训练有素、有条不紊的编码方式，是这里的赢家。</p>
<h3 id="scalability">可量测性</h3>
<h4>Go可扩展吗？</h4>
<p>一开始，Go就在可伸缩性方面胜过Node.js，因为它支持并发性，这有助于处理并行任务。Go每秒可以管理1000个并发请求，让Go更胜一筹。</p>
<h4>Node.js扩展性强吗？</h4>
<p>Node.js的弱点是它在单线程机制上工作，这意味着任务是一个接一个地执行的，这使得它的可伸缩性较差。但是，它确实允许事件回调的并发性，但是这些并不有效，与并行性<strong> <em>相去甚远。</em>T3】</strong></p>
<p>这并不意味着Node.js也不可伸缩，但是Go在并发性方面做得更好，内存效率也更高。因此，如果您有一个CPU密集型应用程序，Go就是您应该去的地方。</p>
<h3 id="developer-salaries">开发人员工资</h3>
<p>根据Stackoverflow 2021年开发者调查，Go以76800美元的年薪轻松超过Node.js，而Node.js开发者的年薪为56860美元。</p>
<p><img data-attachment-id="101206" data-permalink="https://blog.logrocket.com/go-overtaking-node-js/stack-overflow-high-pay-go-node-js/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/12/stack-overflow-high-pay-go-node-js.png" data-orig-size="730,571" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Stack Overflow high pay Go Node.js" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/12/stack-overflow-high-pay-go-node-js-300x235.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/12/stack-overflow-high-pay-go-node-js.png" decoding="async" class="aligncenter size-full wp-image-101206 jetpack-lazy-image" src="../Images/d1c9f46a3a2403a7ab9745ad23cd8d02.png" alt="Stack Overflow High Pay Go Node.js Scatter Plot" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2020/12/stack-overflow-high-pay-go-node-js.png 730w, https://blog.logrocket.com/wp-content/uploads/2020/12/stack-overflow-high-pay-go-node-js-300x235.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2020/12/stack-overflow-high-pay-go-node-js.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/12/stack-overflow-high-pay-go-node-js.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="101206" data-permalink="https://blog.logrocket.com/go-overtaking-node-js/stack-overflow-high-pay-go-node-js/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/12/stack-overflow-high-pay-go-node-js.png" data-orig-size="730,571" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Stack Overflow high pay Go Node.js" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/12/stack-overflow-high-pay-go-node-js-300x235.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/12/stack-overflow-high-pay-go-node-js.png" decoding="async" loading="lazy" class="aligncenter size-full wp-image-101206" src="../Images/d1c9f46a3a2403a7ab9745ad23cd8d02.png" alt="Stack Overflow High Pay Go Node.js Scatter Plot" srcset="https://blog.logrocket.com/wp-content/uploads/2020/12/stack-overflow-high-pay-go-node-js.png 730w, https://blog.logrocket.com/wp-content/uploads/2020/12/stack-overflow-high-pay-go-node-js-300x235.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/12/stack-overflow-high-pay-go-node-js.png"/></noscript>
<p>在这一点上，这甚至不是一场战斗。</p>
<h3 id="performance">表演</h3>
<h4>Golang是表演型的吗？</h4>
<p>对于原始性能，<a href="https://blog.logrocket.com/benchmarking-golang-improve-function-performance/"> Go开发者已经表示，它在速度和性能方面表现出了与C和C++相同的特性</a>，这真的很好。</p>
<p>通过其内存管理(垃圾收集器)，它可以清除未使用的内存，从而降低因内存泄漏而带来的安全风险。</p>
<p><a href="https://blog.logrocket.com/building-microservices-go-gin/"> Go甚至适合构建微服务</a>,因为它具有处理重负载、高速度和支持并发的能力。事实上，它编译成一个相对较小的、静态链接的本地二进制文件，具有相对较小的、固定的运行时开销，这使得它适合安装在Docker容器中。</p>
<h4>Node.js性能高吗？</h4>
<p>就原始性能而言，Node.js与Go相比并不出色，但在现场性能中，一切都与Go一样。</p>

<p>在库和包方面，Go的开发工具比Node.js少。仅仅这一点就意味着开发人员仍然需要为Go应用程序进行大量的手动设置，包括彻底的研究。</p>
<p>Node.js有一个很大的社区，为开发者提供了很多库和包。这个大型社区还在Stackoverflow这样的平台上提供了更多的支持，有助于在构建产品时提高生产率。</p>
<p>在比较开发工具和社区时，Node.js轻松胜出。</p>
<h2>结论</h2>
<p>比较了这两种工具后，Go和Node.js都有各自的优缺点，但是，尽管Go的性能很好，但Go似乎比它的对手更可靠。</p>
<p>在全球范围内，Go开发人员的工资往往比Node.js高，错误处理似乎也处理得很好，这并不是说<code>try catch</code>不好，但是对错误负全责对程序员来说应该很重要。</p>
<p>我们不应该忘记Go的竞争条件检测，这在创建多线程应用程序时是一件好事，因为一些进程可能会以意想不到的顺序完成。</p>
<p>此外，Go是一种编译语言，可以提高应用程序的速度。</p>
<p>正如你所看到的，围棋赢得了一些战斗，但仍然很难给它颁奖，因为很难说哪个更好。这取决于您想要构建的应用程序。</p>
<p>必须处理一千个请求的应用程序将同时使用Go to scale。</p>
<p>此外，虽然Go对于必须处理高负载的微服务和企业项目来说也是非常棒和完美的，但Node.js仍然有许多针对每个挑战的开发工具，从而减少了开发时间。</p>
<p>但是，您可能需要考虑项目的类型(我一直在重复这一点)、规模和结构，以实现您的最终目标。</p><div class="code-block code-block-23">
<div class="blog-plug inline-plug node-plug"><h2>200只<img src="../Images/61167b9d027ca73ed5aaf59a9ec31267.png" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2019/10/green-check.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" class=" jetpack-lazy-image" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/10/green-check.png"/> <noscript> <img data-lazy-fallback="1" src="../Images/61167b9d027ca73ed5aaf59a9ec31267.png" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/10/green-check.png"/> </noscript>显示器出现故障，生产中网络请求缓慢</h2><p>部署基于节点的web应用程序或网站是容易的部分。确保您的节点实例继续为您的应用程序提供资源是事情变得更加困难的地方。如果您对确保对后端或第三方服务的请求成功感兴趣，</p><a href="https://lp.logrocket.com/blg/node-signup" target="_blank">try LogRocket</a><p>. </p><a class="signup" href="https://lp.logrocket.com/blg/node-signup" target="_blank" rel="noopener noreferrer"><img src="../Images/cae72fd2a54c5f02a6398c4867894844.png" alt="LogRocket Network Request Monitoring" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2019/12/network-request-filter-2-1.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" class=" jetpack-lazy-image" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/12/network-request-filter-2-1.png"/><noscript><img data-lazy-fallback="1" src="../Images/cae72fd2a54c5f02a6398c4867894844.png" alt="LogRocket Network Request Monitoring" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/12/network-request-filter-2-1.png"/></noscript></a><a href="https://lp.logrocket.com/blg/node-signup" target="_blank" rel="noopener noreferrer">https://logrocket.com/signup/</a><p>LogRocket 就像是网络和移动应用程序的DVR，记录下用户与你的应用程序交互时发生的一切。您可以汇总并报告有问题的网络请求，以快速了解根本原因，而不是猜测问题发生的原因。</p><p>LogRocket检测您的应用程序以记录基线性能计时，如页面加载时间、到达第一个字节的时间、慢速网络请求，还记录Redux、NgRx和Vuex操作/状态。</p><a class="signup" href="https://lp.logrocket.com/blg/node-signup" target="_blank" rel="noopener noreferrer">Start monitoring for free</a><p>. </p></div>
</div>

<p class="clearfix"/>
<p class="clearfix"/>
 </article>

</div>    
</body>
</html>
<html>
<head>
<title>ES modules in Node.js 12, from experimental to release - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>Node.js 12中的ES模块，从实验到发布- LogRocket博客</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/es-modules-in-node-js-12-from-experimental-to-release/#0001-01-01">https://blog.logrocket.com/es-modules-in-node-js-12-from-experimental-to-release/#0001-01-01</a></blockquote><div><article class="article-post">
<p>不同形式的模块化在JavaScript生态系统中已经存在多年了。开发人员使用定义良好的规范(如AMD或CommonJS)以及简单的编码模式(如揭示模块模式)来获得良好模块化解决方案的好处。</p>
<p>模块可以在浏览器的客户端使用，也可以在<a href="https://blog.logrocket.com/web-analytics-with-node-js/" target="_blank" rel="noopener noreferrer"> Node.js </a>的服务器端使用。有时，使用像Babel这样的工具将代码从一种模块格式转换成另一种格式。所有这些导致了混乱而复杂的JavaScript模块状态。</p>
<p>输入es模块—更具体地说，是Node.js中的ES模块。</p>
<blockquote><p>提示:本文主要关注Node.js中的es模块。查看"<a href="https://medium.com/computed-comparisons/commonjs-vs-amd-vs-requirejs-vs-es6-modules-2e814b114a0b" target="_blank" rel="noopener noreferrer">common js vs AMD vs require js vs ES6 Modules</a>"可以很好地比较非Node.js特有的模块系统。</p></blockquote>
<h2 id="abriefhistory">ES模块支持简史</h2>
<p>让我们看一下es模块支持的一些重要里程碑:</p>

<ul>
<li>【2015年6月–2017年9月:各大浏览器增加对隐藏在开发者旗帜后面的ES模块的实验性支持。使用ES模块开发JavaScript的主要方法是使用Babel之类的工具编译代码。</li>
</ul>
<ul>
<li>【2017年9月: <a href="https://nodejs.org/de/blog/release/v8.5.0/"> Node.js v8.5 </a>包含对es模块的实验支持。</li>
</ul>
<ul>
<li>【2017年9月-2018年5月:各大浏览器开始支持无开发者标志的ES模块规范，包括:</li>
</ul>
<ol>
<li>   <ol>
<li>2017年9月5日，Chrome 61 </li>
<li><strong> Safari 11 </strong>，2017年9月18日</li>
<li>2018年5月8日，火狐60 </li>
</ol>
</li>
</ol>
<ul>
<li>【2018年10月:创建新的模块实施计划。该计划包括用新的实现替换当前实验性实现的几个阶段，从第一天起就遵循三个指导原则:</li>
</ul>
<ol>
<li>   <ol>
<li>符合ES规范</li>
<li>节点应该尽可能用浏览器的方式做事</li>
<li>不要破坏现有的CommonJS模块</li>
</ol>
</li>
</ol>
<blockquote><p>提示:Node.js模块团队已经为新的实现提供了一套更详细的指导原则。</p></blockquote>
<ul>
<li>【2019年10月:节点12进入长期支持。目标是发布对ES模块的全面支持。</li>
</ul>
<h3>什么是ES模块支持，为什么它对Node.js如此重要？</h3>
<p>有几个原因。首先，所有主流浏览器都已经支持ES模块——你可以<a href="https://caniuse.com/#feat=es6-module" target="_blank" rel="noopener noreferrer">在这里</a>亲眼看看。在Node.js中支持服务器端的ES模块将允许全栈开发人员自然地为客户机和服务器编写模块化的、可重用的JavaScript。</p>
<p>另一方面，Node.js中的实验性特性在未来版本中可能会发生非向后兼容的变化或删除。也就是说，实验性ES模块支持已经在Node中存在了几年，预计在2019年10月之前不会发生显著变化。</p>
<h2 id="modulesinnodejscurrentstate">Node.js中的模块</h2>
<h3>什么是CommonJS模块？</h3>
<p>Node.js中的模块目前(2019年年中，撰写本文时)事实上的标准是CommonJS。CommonJS模块是在normal中定义的。js文件使用<code>module.exports</code>。模块可以稍后在其他。带有<code>require()</code>功能的js文件。例如:</p>
<pre>// foo.js
module.exports = function() { 
  return 'Hello foo!';
}

// index.js
var foo = require('./foo');
console.log(foo()); // Hello foo!</pre>
<p>使用Node运行这个带有<code>node index.js</code>的例子。</p>
<h3>ES模块</h3>
<p>从Node v8.5开始，开发人员已经能够使用<code>--experimental-modules</code>标志运行对ES模块规范的各种支持。从节点v12.4开始，可以在中定义模块。mjs文件(或。js文件<a href="https://nodejs.org/api/esm.html" target="_blank" rel="noopener noreferrer">特定情况下</a>。例如:</p>
<pre>// foo.mjs
export function foo() { 
  return 'Hello foo!'; 
}

// index.mjs
import { foo } from './foo.mjs';
console.log(foo()); // Hello foo!</pre>
<p>使用Node运行这个带有<code>node --experimental-modules index.mjs</code>的例子。</p>
<h3>在同一应用程序中使用CommonJS和ES模块</h3>
<p>在某些方面，在浏览器中支持es模块可能比在Node中支持ES模块简单一些，因为Node已经有了一个定义良好的CommonJS模块系统。幸运的是，社区在确保开发者可以同时使用这两种类型的模块，甚至可以从一种模块导入到另一种模块方面做了出色的工作。</p>
<p>例如，假设我们有两个模块。第一个是CommonJS模块，第二个是ES模块(注意不同的文件扩展名):</p>
<pre>// cjs-module-a.js
module.exports = function() {
  return 'I am CJS module A';
};

// esm-module-a.mjs
export function esmModuleA() {
  return 'I am ESM Module A';
};
export default esmModuleA;
</pre>
<p>要在ES模块脚本中使用CommonJS模块(注意。mjs扩展和<code>import</code>关键字的使用):</p>
<pre>// index.mjs
import esmModuleA from './esm-module-a.mjs';
import cjsModuleA from './cjs-module-a.js';
console.log(`esmModuleA loaded from an ES Module: ${esmModuleA()}`);
console.log(`cjsModuleA loaded from an ES Module: ${cjsModuleA()}`);</pre>
<p>使用Node运行这个带有<code>node --experimental-modules index.mjs</code>的例子。</p>
<p>要在标准CommonJS脚本中使用ES模块(注意。js扩展和<code>require()</code>函数的使用):</p>
<pre>// index.js
// synchronously load CommonJS module
const cjsModuleA = require('./cjs-module-a');
console.log(`cjsModuleA loaded synchronously from an CJS Module: ${cjsModuleA()}`);

// asynchronously load ES module using CommonJS
async function main() {
  const {esmModuleA} = await import('./esm-module-a.mjs');
  console.log(`esmModuleA loaded asynchronously from a CJS module: ${esmModuleA()}`);
}
main();
</pre>
<p>这些例子提供了如何在同一个应用程序中一起使用CommonJS和es模块的基本演示。请参阅Gil Tayar的“<a href="https://medium.com/@giltayar/native-es-modules-in-nodejs-status-and-future-directions-part-i-ee5ea3001f71" target="_blank" rel="noopener noreferrer">NodeJS中的本地es模块:现状和未来方向，第一部分</a>”，深入了解CommonJS和ES模块互操作性。</p>
<h2 id="modulesinnodejsfuturestate">Node.js中的模块:未来状态</h2>
<p>在撰写本文时，新模块实施计划正处于第三阶段(也是最后一个阶段)。第3阶段计划在节点12 LTS发布的同时完成，届时ES模块支持将在没有<code>-experimental-modules</code>标志的情况下可用。</p>
<p>阶段3可能会带来一些大的改进来完善ES模块的实现。</p>
<h3>装载机解决方案</h3>
<p>开发者希望模块加载系统灵活且功能齐全。以下是Node.js模块加载器解决方案开发中的一些关键特性:</p>
<ul>
<li><strong>代码覆盖/插装:</strong>使开发者工具能够检索关于CJS和ESM模块使用的数据。</li>
</ul>
<ul>
<li><strong>可插拔加载器:</strong>允许开发者在他们的包中包含加载器插件，这些插件可以定义从特定的文件扩展名或mimetypes加载模块的新行为，甚至是没有扩展名的文件。</li>
</ul>
<ul>
<li><strong>运行时加载器:</strong>允许导入语句中引用的文件在导入时(运行时)被传输。</li>
</ul>
<ul>
<li><strong>模块的任意来源:</strong>允许从文件系统以外的来源加载模块(例如，从URL加载模块)。</li>
</ul>
<ul>
<li>模拟模块:允许在测试时用模拟来替换模块。</li>
</ul>
<p>您可以<a href="https://github.com/nodejs/modules/#features" target="_blank" rel="noopener noreferrer">在此</a>查看完整列表。</p>
<h3><code>package.json</code>中的<code>"exports"</code>对象</h3>
<p>虽然命名和语法不是最终的，但是这里的想法是在<code>package.json</code>文件中的某个地方有一个对象，允许包为包内的不同组件提供“漂亮的”入口点。以这个<code>package.json</code>作为一个可能实现的例子:</p>
<pre>{
  "name": "@myorg/mypackage",
  "version": "1.0.0",
  "type": "module",
  "main": "./dist/index.js",
  "exports": {
    ".": "./src/mypackage.mjs",
    "./data": "./data/somedir/someotherdir/index.mjs"
  }
}</pre>
<p>开发人员可以像这样导入<code>@myorg/mypackage</code>的数据组件:</p>
<pre>import { MyModule } from '@myorg/mypackage/data</pre>
<h3>用包的名称引用包根</h3>
<p>当从同一个包中的另一个模块引用一个模块时，您可能会以如下所示的大量回溯结束:</p>
<pre>import coolcomponent from '../../../coolcomponent/module.js</pre>
<p>如果实现了这一改变，那么回溯可以被替换为对<code>package.json</code>中定义的包名的引用。新代码将如下所示:</p>
<pre>import coolcomponent from 'mypackage/coolcomponent/module.js</pre>
<h3>支持双ESM/CommonJS包</h3>
<p>允许npm包同时包含CJS和es模块对于确保有一条向后兼容的、开发人员友好的路径从CommonJS迁移到ES模块非常重要。这通常被称为“双模式”支持。</p>
<p>双模支持的现状方法是将现有的<code>package.json</code>中的<code>main</code>入口点指向一个CommonJS入口点。如果一个npm包包含ES模块并且开发者想要使用它们，他们需要使用深度导入来访问那些模块(例如，<code>import 'pkg/module.mjs'</code>)。这是可能随Node.js 12 LTS一起发布的双模式解决方案。</p>
<p>还有其他一些支持双模式的提议。这个<a href="https://github.com/nodejs/modules/issues/273" target="_blank" rel="noopener noreferrer">被广泛争论的提议</a>包括一些选项，使开发者更容易用两个独立的实现(ESM和CJS)来发布包，但是这个提议没有达成共识。</p>
<p>一个更新的关于ESM 的<code>require</code>的<a href="https://github.com/nodejs/modules/issues/299">提议提出了一个不同的方法，允许开发者用<code>require()</code>解析ES模块。该提案仍然开放，但已被搁置，不太可能被纳入节点12 LTS。</a></p>
<h2 id="helloesmodulesgoodbyecommonjs">ES模块与CommonJS</h2>
<p>虽然目标是ES模块最终取代Node.js中的CommonJS模块，但是没有人知道未来会怎样——也不知道CommonJS模块支持多久会消失。但有一点是肯定的:节点开发人员已经花费了相当多的时间和精力来确保无缝过渡到没有CommonJS的未来。</p>
<p>他们在确保两种模块类型之间的互操作性，同时尽量不引入太多新的双模式API方面做了出色的工作，一旦关键部分完成迁移，并且到了从Node中移除对CommonJS的支持的时候，这些新的双模式API就会变得毫无用处。</p>
<p>那么什么时候会从Node.js中移除CommonJS呢？让我们做一个疯狂的、毫无根据的预测，假设节点18有一个<code>--experimental-no-commonjs-modules</code>，节点20是最后的日落。跨浏览器、服务器和JavaScript运行的任何地方的模块化JavaScript的未来是令人兴奋的！</p><div class="code-block code-block-23">
<div class="blog-plug inline-plug node-plug"><h2>200只<img src="../Images/61167b9d027ca73ed5aaf59a9ec31267.png" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2019/10/green-check.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" class=" jetpack-lazy-image" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/10/green-check.png"/> <noscript> <img data-lazy-fallback="1" src="../Images/61167b9d027ca73ed5aaf59a9ec31267.png" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/10/green-check.png"/> </noscript>显示器出现故障，生产中网络请求缓慢</h2><p>部署基于节点的web应用程序或网站是容易的部分。确保您的节点实例继续为您的应用程序提供资源是事情变得更加困难的地方。如果您对确保对后端或第三方服务的请求成功感兴趣，</p><a href="https://lp.logrocket.com/blg/node-signup" target="_blank">try LogRocket</a><p>. </p><a class="signup" href="https://lp.logrocket.com/blg/node-signup" target="_blank" rel="noopener noreferrer"><img src="../Images/cae72fd2a54c5f02a6398c4867894844.png" alt="LogRocket Network Request Monitoring" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2019/12/network-request-filter-2-1.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" class=" jetpack-lazy-image" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/12/network-request-filter-2-1.png"/><noscript><img data-lazy-fallback="1" src="../Images/cae72fd2a54c5f02a6398c4867894844.png" alt="LogRocket Network Request Monitoring" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/12/network-request-filter-2-1.png"/></noscript></a><a href="https://lp.logrocket.com/blg/node-signup" target="_blank" rel="noopener noreferrer">https://logrocket.com/signup/</a><p>LogRocket 就像是网络和移动应用程序的DVR，记录下用户与你的应用程序交互时发生的一切。您可以汇总并报告有问题的网络请求，以快速了解根本原因，而不是猜测问题发生的原因。</p><p>LogRocket检测您的应用程序以记录基线性能计时，如页面加载时间、到达第一个字节的时间、慢速网络请求，还记录Redux、NgRx和Vuex操作/状态。</p><a class="signup" href="https://lp.logrocket.com/blg/node-signup" target="_blank" rel="noopener noreferrer">Start monitoring for free</a><p>. </p></div>
</div>

 <p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
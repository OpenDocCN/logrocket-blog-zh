<html>
<head>
<title>Setting up a TypeScript and Gatsby project with GraphQL - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>使用GraphQL - LogRocket Blog设置TypeScript和Gatsby项目</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/set-up-typescript-gatsby-project-graphql/#0001-01-01">https://blog.logrocket.com/set-up-typescript-gatsby-project-graphql/#0001-01-01</a></blockquote><div><article class="article-post">
<p><em> <strong>编者按</strong>:本文最后更新于2022年4月27日，以反映《盖茨比》的最新更新。</em></p>
<p>Gatsby是一个基于React的免费开源框架，帮助开发人员使用现代web技术构建高速网站和应用程序。</p>
<p>Gatsby附带了服务器端渲染等功能，提供了生成静态渐进式web应用程序(pwa)的能力。您还可以获得现成的代码和数据分割。Gatsby只加载关键的HTML、CSS、数据和JavaScript，这样你的站点可以尽可能快地加载。</p>
<p>TypeScript是JavaScript的超集，主要提供可选的静态类型、类和接口。使用TypeScript，您可以及早发现错误，从而使您成为更高效的开发人员，同时利用现有的JavaScript社区。</p>
<p>在本文中，我们将从一个Gatsby项目开始，把它变成一个TypeScript应用程序。您可以跟随Gatsby应用程序的<a href="https://github.com/AlexMercedCoder/gatsby-typescript-blog-tutorial">库。我们开始吧！</a></p>
<h2>目录</h2>

<h2 id="how-to-set-up-gatsby-app">如何设置盖茨比应用程序</h2>
<p>要设置Gatsby应用程序，您首先需要安装Gatsby CLI T1，它可以让您快速创建新的Gatsby支持的站点，并运行开发Gatsby站点的命令。通过运行下面的命令，您可以用Yarn全局安装Gatsby:</p>
<pre>yarn global add gatsby-cli
</pre>
<p>或者，您可以使用npm:</p>
<pre>npm install -g gatsby-cli
</pre>
<p>接下来，我们将使用Gatsby CLI工具创建一个Gatsby站点。首先，我们将获取一个启动项目，Gatsby blog starter。starter附带了启动和运行所需的主要Gatsby配置文件。它还使用GraphQL为博客获取数据:</p>
<pre>gatsby new my-blog-starter https://github.com/gatsbyjs/gatsby-starter-blog
</pre>
<p>上面的命令将博客的所有文件放到一个文件夹中，然后安装应用程序运行所需的所有必需的依赖项。您可以导航到新站点的目录并启动它，看看是否一切都按预期运行。在终端中运行以下命令:</p>
<pre>cd my-blog-starter
yarn develop
</pre>
<p>如果不使用纱线，则<code>npm run develop</code>或<code>gatsby develop</code>也可以。</p>
<p>一旦完成了<code>yarn develop</code>命令，您就可以在浏览器中打开一个新的标签，并导航到<code><a href="http://localhost:8000" rel="nofollow">http://localhost:8000</a></code>来查看Gatsby应用程序的运行情况:</p>
<p><img data-attachment-id="106309" data-permalink="https://blog.logrocket.com/gatsby-starter-blog-homepage/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/04/gatsby-starter-blog-homepage.png" data-orig-size="730,445" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="gatsby-starter-blog-homepage" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/04/gatsby-starter-blog-homepage-300x183.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/04/gatsby-starter-blog-homepage.png" decoding="async" class="aligncenter wp-image-106309 size-full jetpack-lazy-image" src="../Images/40a1f69d49e736aaeb90c1afb5ee491e.png" alt="Gatsby Starter Blog Homepage" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2022/04/gatsby-starter-blog-homepage.png 730w, https://blog.logrocket.com/wp-content/uploads/2022/04/gatsby-starter-blog-homepage-300x183.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2022/04/gatsby-starter-blog-homepage.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/04/gatsby-starter-blog-homepage.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="106309" data-permalink="https://blog.logrocket.com/gatsby-starter-blog-homepage/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/04/gatsby-starter-blog-homepage.png" data-orig-size="730,445" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="gatsby-starter-blog-homepage" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/04/gatsby-starter-blog-homepage-300x183.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/04/gatsby-starter-blog-homepage.png" decoding="async" loading="lazy" class="aligncenter wp-image-106309 size-full" src="../Images/40a1f69d49e736aaeb90c1afb5ee491e.png" alt="Gatsby Starter Blog Homepage" srcset="https://blog.logrocket.com/wp-content/uploads/2022/04/gatsby-starter-blog-homepage.png 730w, https://blog.logrocket.com/wp-content/uploads/2022/04/gatsby-starter-blog-homepage-300x183.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/04/gatsby-starter-blog-homepage.png"/></noscript>
<h2 id="gatsby-graphql">使用Gatsby和GraphQL</h2>
<p>GraphQL是一种查询语言，允许你将数据放入你的网站。Gatsby使用GraphQL作为其管理站点数据的接口。在我们看到Gatsby如何轻松地集成GraphQL之前，让我们先看看Gatsby附带的一些文件和文件夹，以及它们的作用。</p>
<p>目录包含了所有与你的站点前端显示相关的代码，比如你的站点标题或者页面模板。<code>prettierrc</code>是<a href="https://blog.logrocket.com/using-prettier-eslint-automate-formatting-fixing-javascript/">“漂亮”的配置文件，这是一个帮助你保持代码格式</a>一致的工具。</p>
<p>在<code>gatsby-browser.js</code>文件中，Gatsby期望找到<a href="https://www.gatsbyjs.org/docs/browser-apis/"> Gatsby浏览器API</a>的任何用法，这些API允许定制和扩展影响浏览器的默认Gatsby设置。</p>
<p><code>gatsby-config.js</code>是Gatsby站点的主要配置文件。在这里，您可以指定关于您的站点的信息，或者元数据，比如站点标题、描述、您想要包含的Gatsby插件等等。</p>
<p>在<code>gatsby-node.js</code>文件中，盖茨比希望找到<a href="https://www.gatsbyjs.org/docs/node-apis/">盖茨比节点API</a>的任何用法。这些允许定制和扩展影响站点构建过程的默认Gatsby设置。</p>
<p>最后，<code>gatsby-ssr.js</code>文件是Gatsby期望找到<a href="https://www.gatsbyjs.org/docs/ssr-apis/"> Gatsby服务器端呈现API</a>用法的地方，如果有的话。这些允许影响服务器端呈现的缺省Gatsby设置的定制。</p>
<p>Gatsby还支持其他获取数据的方法，所以不必使用GraphQL。您可以使用<code>createPages</code> API将非结构化数据直接拉入Gatsby页面，而不是通过GraphQL数据层。Gatsby可以通过两种方式从GraphQL获取数据，即页面查询和StaticQuery。</p>
<h3 id="page-query">页面查询</h3>
<p>我们可以使用Gatsby的标签在GraphQL 页面中查询数据。在<code>gatsby-config</code>文件中，在文件顶部的第二行到第十行，声明了关于站点的信息，特别是<code>siteMetadata</code>对象:</p>
<pre>siteMetadata: {
  title: `Gatsby Starter Blog`,
  author: `Kyle Mathews`,
  description: `A starter blog demonstrating what Gatsby can do.`,
  siteUrl: `https://gatsby-starter-blog-demo.netlify.com/`,
  social: {
    twitter: `kylemathews`,
  },
},
</pre>
<p>让我们看看如何使用GraphQL在组件中获取上述数据。<code>src/pages</code>文件夹中的<code>404.js</code>文件是一个使用GraphQL通过页面查询获取数据的例子。如果您向下滚动到文件底部的第24行到第32行，您应该会看到类似下面的代码片段:</p>
<pre>export const pageQuery = graphql`
  query {
    site {
      siteMetadata {
        title
      }
    }
  }
`
</pre>
<p>上面的代码片段是一个GraphQL查询，我们获取站点的<code>siteMetadata</code>信息，特别是文件的标题。从上面的查询中检索到的数据可以在组件的呈现函数中使用，如下面同一个文件所示:</p>
<pre>const { data } = this.props
const siteTitle = data.site.siteMetadata.title
</pre>
<h3 id="static-query">静态查询</h3>
<p>您可以使用<a href="https://www.gatsbyjs.org/docs/static-query/"> StaticQuery </a>在Gatsby中查询数据，这是一个编写时更新的API，允许组件通过GraphQL查询检索数据。除了使用StaticQuery，我们还将使用名为<a href="https://www.gatsbyjs.org/docs/use-static-query/"> <code>useStaticQuery</code> </a>的钩子版本的StaticQuery。</p>
<p>位于<code>src/components</code>文件夹中的<code>seo.js</code>文件是一个使用StaticQuery的组件示例:</p>
<pre>import { useStaticQuery, graphql } from "gatsby"

// ...

function SEO({ description, lang, meta, title }) {
  const { site } = useStaticQuery(
    graphql`
      query {
        site {
          siteMetadata {
            title
            description
            author
          }
        }
      }
    `
  )

  // ...
}
</pre>
<p>正如你在上面的代码块中看到的，我们首先从Gatsby导入了<code>useStaticQuery</code>方法。<code>useStaticQuery</code>方法允许React组件通过GraphQL查询检索数据，该查询将被解析、评估并注入到组件中。</p>
<p>上面的GraphQL查询从<code>gatsby-config.js</code>文件中查询站点标题、描述和作者。</p>
<h2 id="integrate-typescript-gatsby-app">如何将TypeScript集成到Gatsby应用程序中</h2>
<p>为了将TypeScript集成到Gatsby应用程序中，我们需要安装一些依赖项:</p>
<pre>yarn add gatsby-plugin-typescript
yarn add typescript --dev
</pre>
<p>或者</p>
<pre>npm install gatsby-plugin-typescript
npm install --save-dev typescript 
</pre>
<p><a href="https://www.gatsbyjs.org/packages/gatsby-plugin-typescript/"> <code>gatsby-plugin-typescript</code> </a>是将所有<code>.js</code>文件改为<code>.tsx</code>文件所需的盖茨比插件。它负责类型检查和传输类型脚本代码。</p>
<p>一旦安装了依赖项，我们可以将<code>gatsby-plugin-typescript</code>添加到<code>gatsby-config.js</code>文件中gatsby-plugin-react-helmet之后:</p>
<pre>`gatsby-plugin-react-helmet`,
    `gatsby-plugin-typescript`,
</pre>
<p>接下来，将<code>eslintrc.js</code>和<code>tsconfig.json</code>添加到代码库的根目录中。<code>eslintrc.js</code>包含有助于林挺打字稿文件的规则集，而<code>tsconfig.json</code>包含有助于确定项目中打字稿行为的规则集。下面的代码输入<code>eslintrc.js</code>:</p>
<pre>module.exports = {
  parser: '@typescript-eslint/parser', // Specifies the ESLint parser
  extends: [
    'eslint:recommended',
    'plugin:react/recommended',
    'plugin:@typescript-eslint/recommended',
    'prettier/@typescript-eslint',
    'plugin:prettier/recommended'
  ],
  settings: {
    react: {
      version: 'detect'
    }
  },
  env: {
    browser: true,
    node: true,
    es6: true
  },
  plugins: ['@typescript-eslint', 'react'],
  parserOptions: {
    ecmaFeatures: {
      jsx: true
    },
    ecmaVersion: 2018, // Allows for the parsing of modern ECMAScript features
    sourceType: 'module' // Allows for the use of imports
  },
  rules: {
    'react/prop-types': 'off', // Disable prop-types as we use TypeScript for type checking
    '@typescript-eslint/explicit-function-return-type': 'off'
  },
  overrides: [
    // Override some TypeScript rules just for .js files
    {
      files: ['*.js'],
      rules: {
        '@typescript-eslint/no-var-requires': 'off' //
      }
    }
  ]
};
</pre>
<p>下面的代码放在<code>tsconfig.json</code>中:</p>
<pre>// tsconfig.json
{
  "compilerOptions": {
    "module": "commonjs",
    "target": "esnext",
    "jsx": "preserve",
    "lib": ["dom", "esnext"],
    "strict": true,
    "noEmit": true,
    "isolatedModules": true,
    "esModuleInterop": true,
    "noUnusedLocals": false,
    "allowJs": true
  },
  "exclude": ["node_modules", "public", ".cache"]
}
</pre>
<p>这个<code>.eslintrc.js</code>文件使用了一些我们需要用来帮助林挺我们的TypeScript项目的包。您可以使用下面的命令安装它们:</p>
<pre>yarn add -D @typescript-eslint/eslint-plugin @typescript-eslint/parser @types/react-helmet eslint
</pre>
<p>或者</p>
<pre>npm install --save-dev @typescript-eslint/eslint-plugin @typescript-eslint/parser eslint @types/react-helmet --force
</pre>
<p>此外，我们需要向<code>package.json</code>文件添加一个脚本，我们可以用它来对整个代码库进行类型检查:</p>
<pre>"scripts": {
    // ...
    "type-check": "tsc --noEmit"
  }
</pre>
<p>现在，我们可以将必要的<code>.js</code>文件重命名为<code>.tsx</code>文件。除了重命名文件，我们还为任何属性定义了TypeScript接口。</p>
<h3 id="biojs"><code>bio.js</code></h3>
<p>让我们从<code>bio.js</code>文件开始。重命名文件或简单地更改扩展名，使它现在是<code>src/components/bio.tsx</code>。</p>
<h3 id="layoutjs"><code>layout.js</code></h3>
<p>接下来，我们将<code>layout.js</code>文件的扩展名改为<code>.tsx</code>。打开文件，用下面的代码片段编辑它:</p>
<pre>import * as React from "react"
import { Link } from "gatsby"

interface Props {
  location: Location
  title: string
  children?: any
}
const Layout = ({ location, title, children }: Props) =&gt; {
  const rootPath = `${__PATH_PREFIX__}/`
  const isRootPath = location.pathname === rootPath
  let header
  if (isRootPath) {
    header = (
      &lt;h1 className="main-heading"&gt;
        &lt;Link to="/"&gt;{title}&lt;/Link&gt;
      &lt;/h1&gt;
    )
  } else {
    header = (
      &lt;Link className="header-link-home" to="/"&gt;
        {title}
      &lt;/Link&gt;
    )
  }
  return (
    &lt;div className="global-wrapper" data-is-root-path={isRootPath}&gt;
      &lt;header className="global-header"&gt;{header}&lt;/header&gt;
      &lt;main&gt;{children}&lt;/main&gt;
      &lt;footer&gt;
        © {new Date().getFullYear()}, Built with
        {` `}
        &lt;a href="https://www.gatsbyjs.com"&gt;Gatsby&lt;/a&gt;
      &lt;/footer&gt;
    &lt;/div&gt;
  )
}
export default Layout
</pre>
<p>在上面的代码块中，我们为组件的道具创建了一个接口。在TypeScript中，<a href="https://www.typescriptlang.org/docs/handbook/interfaces.html">接口</a>有助于形成实体的规范。一个接口通常包含所有属性的名称以及它们的类型。</p>
<h3 id="seojs"><code>seo.js</code></h3>
<p>将<code>seo.js</code>文件的扩展名改为<code>.tsx</code>，然后打开该文件，用下面的代码片段编辑它:</p>
<pre>/**
 * SEO component that queries for data with
 *  Gatsby's useStaticQuery React hook
 *
 * See: https://www.gatsbyjs.com/docs/use-static-query/
 */
import * as React from "react"
import PropTypes from "prop-types"
import { Helmet } from "react-helmet"
import { useStaticQuery, graphql } from "gatsby"

interface Props {
  description?: string
  lang?: string
  meta?: []
  title: string
}
interface Meta {
  property?: string,
  name?: string,
  content: string
}
const Seo = ({ description, lang, meta, title }:Props) =&gt; {
  const { site } = useStaticQuery(
    graphql`
      query {
        site {
          siteMetadata {
            title
            description
            social {
              twitter
            }
          }
        }
      }
    `
  )
  const metaDescription = description || site.siteMetadata.description
  const defaultTitle = site.siteMetadata?.title
  let typeSafeMeta: Array&lt;Meta&gt;
  if (meta instanceof Array){
    typeSafeMeta = meta
  } else {
    typeSafeMeta = []
  }
  return (
    &lt;Helmet
      htmlAttributes={{
        lang,
      }}
      title={title}
      titleTemplate={defaultTitle ? `%s | ${defaultTitle}` : ''}
      meta={[
        {
          name: `description`,
          content: metaDescription,
        },
        {
          property: `og:title`,
          content: title,
        },
        {
          property: `og:description`,
          content: metaDescription,
        },
        {
          property: `og:type`,
          content: `website`,
        },
        {
          name: `twitter:card`,
          content: `summary`,
        },
        {
          name: `twitter:creator`,
          content: site.siteMetadata?.social?.twitter || ``,
        },
        {
          name: `twitter:title`,
          content: title,
        },
        {
          name: `twitter:description`,
          content: metaDescription,
        },
        ...typeSafeMeta
      ]}
    /&gt;
  )
}
Seo.defaultProps = {
  lang: `en`,
  meta: [],
  description: ``,
}
Seo.propTypes = {
  description: PropTypes.string,
  lang: PropTypes.string,
  meta: PropTypes.arrayOf(PropTypes.object),
  title: PropTypes.string.isRequired,
}
export default Seo
</pre>
<p>像在<code>layout.tsx</code>文件中一样，我们也为组件的道具和元标签数组定义了一个接口，并做了一些小的调整，以确保我们符合头盔道具的类型。</p>
<h3 id="404js"><code>404.js</code></h3>
<p>接下来，我们导航到<code>404.js</code>文件。导航到<code>src/pages</code>文件夹，将扩展名改为<code>.tsx</code>，然后打开文件，用下面的代码片段编辑它:</p>
<pre>import * as React from "react"
import { graphql } from "gatsby"
import Layout from "../components/layout"
import Seo from "../components/seo"

interface Props {
  data: {
    site: {
      siteMetadata: {
        title: string
      }
    }
  }
  location?: any
}
const NotFoundPage = ({ data, location }: Props) =&gt; {
  const siteTitle = data.site.siteMetadata.title
  return (
    &lt;Layout location={location} title={siteTitle}&gt;
      &lt;Seo title="404: Not Found" /&gt;
      &lt;h1&gt;404: Not Found&lt;/h1&gt;
      &lt;p&gt;You just hit a route that doesn&amp;#39;t exist... the sadness.&lt;/p&gt;
    &lt;/Layout&gt;
  )
}
export default NotFoundPage
export const pageQuery = graphql`
  query {
    site {
      siteMetadata {
        title
      }
    }
  }
`
</pre>
<p>在上面的代码块中，我们为组件的props定义了一个接口。</p>
<h3><code>index.js</code></h3>
<p>接下来，我们将<code>index.js</code>文件中的扩展名改为<code>.tsx</code>，然后打开该文件，用下面的代码片段编辑它:</p>
<pre>import * as React from "react"
import { Link, graphql } from "gatsby"
import Bio from "../components/bio"
import Layout from "../components/layout"
import Seo from "../components/seo"

interface Props {
  data: {
    allMarkdownRemark: any
    site: {
      siteMetadata: {
        title: string
      }
    }
  },
  location?: any
}
const BlogIndex = ({ data, location }:Props) =&gt; {
  const siteTitle = data.site.siteMetadata?.title || `Title`
  const posts = data.allMarkdownRemark.nodes
  if (posts.length === 0) {
    return (
      &lt;Layout location={location} title={siteTitle}&gt;
        &lt;Seo title="All posts" /&gt;
        &lt;Bio /&gt;
        &lt;p&gt;
          No blog posts found. Add markdown posts to "content/blog" (or the
          directory you specified for the "gatsby-source-filesystem" plugin in
          gatsby-config.js).
        &lt;/p&gt;
      &lt;/Layout&gt;
    )
  }
  return (
    &lt;Layout location={location} title={siteTitle}&gt;
      &lt;Seo title="All posts" /&gt;
      &lt;Bio /&gt;
      &lt;ol style={{ listStyle: `none` }}&gt;
        {posts.map((post:any) =&gt; {
          const title = post.frontmatter.title || post.fields.slug
          return (
            &lt;li key={post.fields.slug}&gt;
              &lt;article
                className="post-list-item"
                itemScope
                itemType="http://schema.org/Article"
              &gt;
                &lt;header&gt;
                  &lt;h2&gt;
                    &lt;Link to={post.fields.slug} itemProp="url"&gt;
                      &lt;span itemProp="headline"&gt;{title}&lt;/span&gt;
                    &lt;/Link&gt;
                  &lt;/h2&gt;
                  &lt;small&gt;{post.frontmatter.date}&lt;/small&gt;
                &lt;/header&gt;
                &lt;section&gt;
                  &lt;p
                    dangerouslySetInnerHTML={{
                      __html: post.frontmatter.description || post.excerpt,
                    }}
                    itemProp="description"
                  /&gt;
                &lt;/section&gt;
              &lt;/article&gt;
            &lt;/li&gt;
          )
        })}
      &lt;/ol&gt;
    &lt;/Layout&gt;
  )
}
export default BlogIndex
export const pageQuery = graphql`
  query {
    site {
      siteMetadata {
        title
      }
    }
    allMarkdownRemark(sort: { fields: [frontmatter___date], order: DESC }) {
      nodes {
        excerpt
        fields {
          slug
        }
        frontmatter {
          date(formatString: "MMMM DD, YYYY")
          title
          description
        }
      }
    }
  }
`
</pre>
<p>正如在前面的代码块中看到的，我们为组件的prop定义了一个接口，并在我们的posts映射中添加了一个<code>any</code>类型以避免错误。</p>
<h3 id="blog-post-js"><code>blog-post.js</code></h3>
<p>对于<code>src/components</code>文件夹中的<code>blog-post.js</code>文件，我们必须为道具定义一个接口。将扩展名改为<code>.tsx</code>，然后打开文件，用下面的代码片段编辑它:</p>
<pre>import * as React from "react"
import { Link, graphql } from "gatsby"
import Bio from "../components/bio"
import Layout from "../components/layout"
import Seo from "../components/seo"

interface Props {
  data: {
    markdownRemark: any
    site: {
      siteMetadata: {
        title: string
      }
    }
  }
  pageContext?: any,
  location?: any
}
const BlogPostTemplate = ({ data, location }) =&gt; {
  const post = data.markdownRemark
  const siteTitle = data.site.siteMetadata?.title || `Title`
  const { previous, next } = data
  return (
    &lt;Layout location={location} title={siteTitle}&gt;
      &lt;Seo
        title={post.frontmatter.title}
        description={post.frontmatter.description || post.excerpt}
      /&gt;
      &lt;article
        className="blog-post"
        itemScope
        itemType="http://schema.org/Article"
      &gt;
        &lt;header&gt;
          &lt;h1 itemProp="headline"&gt;{post.frontmatter.title}&lt;/h1&gt;
          &lt;p&gt;{post.frontmatter.date}&lt;/p&gt;
        &lt;/header&gt;
        &lt;section
          dangerouslySetInnerHTML={{ __html: post.html }}
          itemProp="articleBody"
        /&gt;
        &lt;hr /&gt;
        &lt;footer&gt;
          &lt;Bio /&gt;
        &lt;/footer&gt;
      &lt;/article&gt;
      &lt;nav className="blog-post-nav"&gt;
        &lt;ul
          style={{
            display: `flex`,
            flexWrap: `wrap`,
            justifyContent: `space-between`,
            listStyle: `none`,
            padding: 0,
          }}
        &gt;
          &lt;li&gt;
            {previous &amp;&amp; (
              &lt;Link to={previous.fields.slug} rel="prev"&gt;
                ← {previous.frontmatter.title}
              &lt;/Link&gt;
            )}
          &lt;/li&gt;
          &lt;li&gt;
            {next &amp;&amp; (
              &lt;Link to={next.fields.slug} rel="next"&gt;
                {next.frontmatter.title} →
              &lt;/Link&gt;
            )}
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/nav&gt;
    &lt;/Layout&gt;
  )
}
export default BlogPostTemplate
export const pageQuery = graphql`
  query BlogPostBySlug(
    $id: String!
    $previousPostId: String
    $nextPostId: String
  ) {
    site {
      siteMetadata {
        title
      }
    }
    markdownRemark(id: { eq: $id }) {
      id
      excerpt(pruneLength: 160)
      html
      frontmatter {
        title
        date(formatString: "MMMM DD, YYYY")
        description
      }
    }
    previous: markdownRemark(id: { eq: $previousPostId }) {
      fields {
        slug
      }
      frontmatter {
        title
      }
    }
    next: markdownRemark(id: { eq: $nextPostId }) {
      fields {
        slug
      }
      frontmatter {
        title
      }
    }
  }
`
</pre>
<p>在再次运行应用程序之前，我们需要编辑<code>gatsby-node.js</code>文件。在该文件中，我们声明了用于呈现博客文章页面的组件的路径。我们需要将该文件的扩展名从<code>.js</code>改为<code>.tsx</code>。打开第七行的<code>gatsby-node.js</code>文件，用下面的代码编辑它:</p>
<pre>const blogPost = path.resolve(`./src/templates/blog-post.tsx`)
</pre>
<p>完成后，重启Gatsby应用程序，尝试查看位于<code>localhost:8000</code>的博客。现在应该可以正常工作了！</p>
<h2 id="conclusion">结论</h2>
<p>在本文中，我们研究了Gatsby及其在GraphQL和TypeScript中的用法。我们看到了如何使用接口为组件构造数据或道具。我们还学习了如何使用GraphQL通过页面查询或StaticQuery在Gatsby应用程序中获取数据。我希望你喜欢这篇文章，并快乐编码！</p><div class="code-block code-block-21">
<div class="blog-plug inline-plug typescript-plug"><h2><a class="signup" href="https://lp.logrocket.com/blg/typescript-signup" target="_blank" rel="noopener noreferrer"> LogRocket </a>:全面了解您的网络和移动应用</h2>
<a href="https://lp.logrocket.com/blg/typescript-signup" class="signup" target="_blank" rel="noopener noreferrer"><img class="alignnone size-full wp-image-46 jetpack-lazy-image" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/><noscript><img data-lazy-fallback="1" class="alignnone size-full wp-image-46" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/></noscript></a>
<p>LogRocket 是一个前端应用程序监控解决方案，可以让您回放问题，就像问题发生在您自己的浏览器中一样。LogRocket不需要猜测错误发生的原因，也不需要向用户询问截图和日志转储，而是让您重放会话以快速了解哪里出错了。它可以与任何应用程序完美配合，不管是什么框架，并且有插件可以记录来自Redux、Vuex和@ngrx/store的额外上下文。</p>
<p>除了记录Redux操作和状态，LogRocket还记录控制台日志、JavaScript错误、堆栈跟踪、带有头+正文的网络请求/响应、浏览器元数据和自定义日志。它还使用DOM来记录页面上的HTML和CSS，甚至为最复杂的单页面和移动应用程序重新创建像素级完美视频。</p><div class="code-block code-block-24">
<div class="blog-plug inline-plug graphql-plug"><h2>监控生产中失败和缓慢的GraphQL请求</h2><p>虽然GraphQL有一些调试请求和响应的特性，但确保GraphQL可靠地为您的生产应用程序提供资源是一件比较困难的事情。如果您对确保对后端或第三方服务的网络请求成功感兴趣，</p><a href="https://lp.logrocket.com/blg/graphql-signup" target="_blank">try LogRocket</a><p>.</p><a class="signup" href="https://lp.logrocket.com/blg/graphql-signup" target="_blank" rel="noopener noreferrer"><img src="../Images/432a3823c85b3fb72a206e6236a29f48.png" data-lazy-src="https://files.readme.io/69aa835-Image_2019-11-09_at_1.28.05_PM.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" class=" jetpack-lazy-image" data-original-src="https://files.readme.io/69aa835-Image_2019-11-09_at_1.28.05_PM.png"/><noscript><img data-lazy-fallback="1" src="../Images/432a3823c85b3fb72a206e6236a29f48.png" data-original-src="https://files.readme.io/69aa835-Image_2019-11-09_at_1.28.05_PM.png"/></noscript><img class="alignnone size-full wp-image-46 jetpack-lazy-image" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/><noscript><img data-lazy-fallback="1" class="alignnone size-full wp-image-46" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/></noscript></a><a href="https://lp.logrocket.com/blg/graphql-signup" target="_blank" rel="noopener noreferrer">https://logrocket.com/signup/</a><p>LogRocket 就像是网络和移动应用的DVR，记录下你网站上发生的每一件事。您可以汇总并报告有问题的GraphQL请求，以快速了解根本原因，而不是猜测问题发生的原因。此外，您可以跟踪Apollo客户机状态并检查GraphQL查询的键值对。</p><p>LogRocket检测您的应用程序以记录基线性能计时，如页面加载时间、到达第一个字节的时间、慢速网络请求，还记录Redux、NgRx和Vuex操作/状态。</p><a class="signup" href="https://lp.logrocket.com/blg/graphql-signup" target="_blank" rel="noopener noreferrer">Start monitoring for free</a><p>.</p></div>


</div>
<a class="signup" href="https://lp.logrocket.com/blg/typescript-signup" target="_blank" rel="noopener noreferrer">Try it for free</a><p>.</p></div>
</div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
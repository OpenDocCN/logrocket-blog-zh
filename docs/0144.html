<html>
<head>
<title>Custom responsive behavior using custom CSS properties - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>使用自定义CSS属性的自定义响应行为</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/custom-responsive-behaviour-using-custom-css-properties-14e2ed8a578f/#0001-01-01">https://blog.logrocket.com/custom-responsive-behaviour-using-custom-css-properties-14e2ed8a578f/#0001-01-01</a></blockquote><div><article class="article-post">
<figure><img decoding="async" src="../Images/36efba16a1e7a9b8faa6d11a99797240.png" data-height="702" data-width="1832" data-lazy-src="https://storage.googleapis.com/blog-images-backup/1*vuH0AlKsDuRalaGMcEtOXA.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" class=" jetpack-lazy-image" data-original-src="https://storage.googleapis.com/blog-images-backup/1*vuH0AlKsDuRalaGMcEtOXA.png"/><noscript><img data-lazy-fallback="1" decoding="async" src="../Images/36efba16a1e7a9b8faa6d11a99797240.png" data-height="702" data-width="1832" data-original-src="https://storage.googleapis.com/blog-images-backup/1*vuH0AlKsDuRalaGMcEtOXA.png"/></noscript></figure>
<p>在2012年，自定义属性作为“变量”被引入CSS变量模块。后来，“变量”被重命名为“自定义属性”，根据CSS <a href="https://www.w3.org/TR/css-variables-1/#defining-variables" target="_blank" rel="noopener noreferrer">规范</a>它将支持除变量替换之外的“其他东西”。</p>
<p>这些“其他的事情”似乎直到现在才发生。自2015年以来，该模块仍然是一个候选推荐，尽管主要浏览器都支持它。</p>
<p>自定义属性可以像通常的CSS属性一样使用。它们由两个前导破折号定义，后跟您选择的标识符，并且可以在任何CSS块中定义:</p>
<pre>.some-selector {
  --my-var: value;
}</pre>
<p>该值可以是对CSS属性有效的任何表达式。</p>
<p>自定义属性参与级联，即它们被继承并可在媒体查询块中使用。要将<code>--my-var</code>用作变量，只需在另一个属性的值中引用它:</p>
<pre>.other-selector {
  background-color: var(--my-var);
}</pre>
<p>关于“变量”用法更详尽的描述，请看这里:<a href="https://developer.mozilla.org/en-US/docs/Web/CSS/Using_CSS_variables" target="_blank" rel="noopener noreferrer">https://developer . Mozilla . org/en-US/docs/Web/CSS/Using _ CSS _ variables</a></p>
<figure><a href="https://logrocket.com/signup/" target="_blank" rel="noopener noreferrer"><img decoding="async" src="../Images/94b3e0f84b30cb0d321f60471481ab64.png" data-height="750" data-width="3212" data-lazy-src="https://storage.googleapis.com/blog-images-backup/1*GPjaPKNNUYHU8EsA3Z0JGA.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" class=" jetpack-lazy-image" data-original-src="https://storage.googleapis.com/blog-images-backup/1*GPjaPKNNUYHU8EsA3Z0JGA.png"/><noscript><img data-lazy-fallback="1" decoding="async" src="../Images/94b3e0f84b30cb0d321f60471481ab64.png" data-height="750" data-width="3212" data-original-src="https://storage.googleapis.com/blog-images-backup/1*GPjaPKNNUYHU8EsA3Z0JGA.png"/></noscript></a></figure>
<h4>“其他事情”的问题</h4>
<p>当你在CSS中定义新的自定义属性而不在<code>var()</code>表达式中使用它时，没有人会听你的。因此不会产生自定义布局或行为。当然，可以从JavaScript中检索给定元素的自定义属性值:</p>
<pre><code>window.getComputedStyle(element).getPropertyValue("--my-var");</code></pre>
<p>这很好，但不一定有意义。在JavaScript中，您可以直接为元素编写自定义行为，而不是在CSS中为给定的选择器定义一个自定义属性，然后使用上面的代码读取该属性，并根据读取的值编写自定义行为。</p>
<p>您可以使用媒体查询来创建响应行为。然后，<code>getPropertyValue</code>读取的值将取决于浏览器的当前指标。这也可以直接在JavaScript中实现，直接在代码中查询浏览器指标，或者使用<code>matchMedia</code>查看当前应用的媒体查询。</p>
<h4>真正有意义的地方:框架</h4>
<p>当您编写自己的代码时，自定义CSS属性没有多大帮助。然而，如果你把它们理解为一个提供定制行为的框架的API，那就完全不同了。在这里，行为(框架)的程序员和用户是不同的人。因此，用户不一定想要钻研代码来修改行为。</p>
<p>今天的许多框架都是由CSS类(如引导或布尔玛)或HTML属性(Angular，Vue)控制的。自定义CSS属性是指定参数的第三种方式，可能证明是定义响应行为的非常有效的方式。</p>
<p>在下一章中，自定义CSS属性的可能性将在layJS框架示例中解释。</p>
<h4>具有图层的响应动画用户界面</h4>
<p>LayerJS是一个用简单的HTML标记创建动画分层用户界面的框架。它提供了一个通用的概念，通用的UI模式(菜单、滑块、折叠、视差、缩放)可以简单地定义为动态的、重叠的层。</p>
<p>它的行为可以由HTML属性控制，或者由上面描述的自定义CSS属性控制。在接下来的章节中，我们用它来创建一个菜单，它在桌面上从侧面移动，在手机上以全屏方式淡入。</p>
<h4>创建侧菜单</h4>
<p>在layerJS中，一切都发生在一个“阶段”中。舞台是一个视口，它定义了事情应该发生的区域。在我们的例子中，我们希望所有的事情都在浏览器窗口中发生，所以我们将主体定义为一个阶段。</p>
<p>我们希望菜单出现在主要内容之上，所以我们在stage内部定义了两个层，一个用于菜单，一个用于内容。</p>
<p>在菜单层中，我们创建了一个包含菜单实际内容的“框架”,在内容层中，我们创建了一个包含页面内容的框架。</p>
<p>我们不想显示菜单，最初我们设置菜单层的默认框架为“！无”:</p>
<pre>&lt;body lj-type="stage"&gt;
  &lt;div id="lcontent" lj-type="layer"&gt;
    &lt;div id="home" lj-type="frame"&gt;
      ... content ...
    &lt;/div&gt;
    ... optional: more content frames
  &lt;/div&gt;
  &lt;div id="lmenu" lj-type="layer" lj-default-frame="!none"&gt;
    &lt;div id="menu" lj-type="frame"&gt;
      ... menu items
    &lt;/div&gt;
  &lt;/div&gt;
&lt;/div&gt;</pre>
<p>现在我们定义UI的行为。这种行为基本上是如何将帧适应/定位到舞台中，以及如何制作动画。我们选择在左侧以浏览器全高显示菜单，宽度固定。这通过将<code>lj-fit-to</code>设置为<code>responsive-height</code>来完成。过渡由<code>lj-transition</code>定义:</p>
<pre>#menu {
  --lj-fit-to: responsive-height;
  --lj-transition: left;
  width: 200px;
}</pre>
<h4>让它有反应</h4>
<p>为了使这种行为具有响应性，我们简单地用不同的参数为移动屏幕定义CSS子句——菜单应该充满整个屏幕，并且应该淡入:</p>
<pre>@media (max-width: 600px) {
  #menu {
    --lj-fit-to: responsive;
    --lj-transition: fade;
  }
}</pre>
<p>你可以在JSBin 这里找到一个<strong>活生生的例子</strong> <a href="https://jsfiddle.net/thomnah/d87kjg3r/" target="_blank" rel="noopener noreferrer">。点击“菜单”打开和关闭它。确保调整输出部分的大小，以查看响应行为。</a></p>
<p>这个例子展示了自定义CSS属性是如何作为一种方便的方法来以响应的方式控制框架行为的。最大的优点是，该框架不必对响应性在特定情况下应该如何工作做出任何假设。用户很可能会使用一个网格系统，或者至少是一组断点，框架会无缝地集成到这个概念中。</p>
<h3>结论</h3>
<p>layerJS尤其受益于自定义CSS属性。它提供了从嵌套层中构建任意用户界面的概念。它并不直接实现响应特性，而是让用户决定这些层的内容在不同设备上应该是什么样子。</p>
<p>通过自定义CSS属性，用户不仅可以定义布局，还可以定义响应方式的行为。关于layerJS概念的解释，请看项目主页上的<a href="https://layerjs.org" target="_blank" rel="noopener noreferrer">动画。关于如何用layerJS构建ui的简单介绍可以在</a><a href="https://medium.com/layerjs/getting-started-with-layerjs-17f679452c8d" target="_blank" rel="noopener noreferrer">这里</a>找到。</p><div class="code-block code-block-25">
<div class="blog-plug inline-plug css-plug"><h2>你的前端是否占用了用户的CPU？</h2><p>随着web前端变得越来越复杂，资源贪婪的特性对浏览器的要求越来越高。如果您对监控和跟踪生产环境中所有用户的客户端CPU使用情况、内存使用情况等感兴趣，</p><a target="_blank" href="https://lp.logrocket.com/blg/css-signup">try LogRocket</a><p>.</p><a class="signup" href="https://lp.logrocket.com/blg/css-signup" target="_blank" rel="noopener noreferrer"><img class="alignnone size-full wp-image-46 jetpack-lazy-image" src="../Images/dacb06c713aec161ffeaffae5bd048cd.png" alt="LogRocket Dashboard Free Trial Banner" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2019/12/cpu-memory-usage.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/12/cpu-memory-usage.png"/><noscript><img data-lazy-fallback="1" class="alignnone size-full wp-image-46" src="../Images/dacb06c713aec161ffeaffae5bd048cd.png" alt="LogRocket Dashboard Free Trial Banner" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/12/cpu-memory-usage.png"/></noscript></a><a href="https://lp.logrocket.com/blg/css-signup" target="_blank" rel="noopener noreferrer">https://logrocket.com/signup/</a><p>LogRocket 就像是网络和移动应用的DVR，记录你的网络应用或网站上发生的一切。您可以汇总和报告关键的前端性能指标，重放用户会话和应用程序状态，记录网络请求，并自动显示所有错误，而不是猜测问题发生的原因。</p><p>现代化您调试web和移动应用的方式— <a class="signup" href="https://lp.logrocket.com/blg/css-signup" target="_blank" rel="noopener noreferrer">开始免费监控</a>。</p></div>
</div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
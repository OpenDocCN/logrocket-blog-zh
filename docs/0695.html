<html>
<head>
<title>Writing reusable end-to-end tests with TestCafe - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>用TestCafe - LogRocket博客编写可重用的端到端测试</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/writing-reusable-end-to-end-tests-with-testcafe/#0001-01-01">https://blog.logrocket.com/writing-reusable-end-to-end-tests-with-testcafe/#0001-01-01</a></blockquote><div><article class="article-post">
<p>端到端测试包括测试应用程序的流程。</p>
<p>这通常包括测试用户与应用程序交互的各种方式。</p>
<p>它有助于确定应用程序是否按预期工作。</p>
<p>由于开发前端应用程序的复杂性增加，端到端测试或UI测试在过去几年中得到了越来越多的采用，这伴随着不同的团队为相同的代码库做出贡献。</p>
<p>因此，有些失误可能不一定被预先建立的测试方法所涵盖，例如单元测试或集成测试，这就产生了端到端测试的需求。</p>
<p>在本文中，我们将使用TestCafe作为我们选择的工具。其他值得一提的框架还有<a href="https://www.cypress.io/" target="_blank" rel="noopener noreferrer"> cypress.io </a>、<a href="http://www.nightmarejs.org/" target="_blank" rel="noopener noreferrer">夜魔</a>和<a href="https://selenium.dev/" target="_blank" rel="noopener noreferrer">硒</a>。</p>
<h2>如何运行测试用例</h2>
<p>我们将通过查看以下内容来深入探讨TestCafe:</p>
<ul>
<li>构建测试的方法</li>
<li>编写可重用的函数</li>
<li>测试后进行清理</li>
<li>执行断言</li>
</ul>
<p>首先，您需要在本地机器上安装Node.js。</p>
<p>如果没有，这里有他们<a href="https://nodejs.org/en/" target="_blank" rel="noopener noreferrer">官网</a>的链接。</p>
<p>一旦完成Node.js的安装，您还需要安装TestCafe。</p>
<p>我将添加<code>-g</code>标志来全局安装它，这样我就不必为每个项目安装它。</p>
<p>下面是完成这项工作的命令:</p>
<pre>npm install -g testcafe</pre>
<p>我们将把https://en.wikipedia.org/作为我们的首选网站。</p>
<p>让我们创建一个脚本来运行我们的测试写入:</p>
<pre>mkdir testcafe-sample
cd testcafe-sample 
touch test.js</pre>
<p>内部Test.js:</p>
<pre>import { Selector, ClientFunction } from 'testcafe';

const getLocation = ClientFunction(() =&gt; document.location.href);</pre>
<pre>fixture `My first fixture`
    .page `https://www.wikipedia.org/`;
    test('users can search', async t =&gt; {
      await t
      .click(Selector('#searchInput'))
      .typeText(Selector('#searchInput'), 'vikings')
      .click(Selector('button[type=submit]'))
      .expect(getLocation()).contains('en.wikipedia.org/wiki/Vikings');
    });</pre>
<p>我们通过在终端中运行以下命令来运行它:</p>
<pre>testcafe chrome test.js</pre>
<p><img data-attachment-id="14611" data-permalink="https://blog.logrocket.com/writing-reusable-end-to-end-tests-with-testcafe/attachment/writing-reusable-tests-testcafe/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/02/writing-reusable-tests-testcafe.png" data-orig-size="760,314" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="writing-reusable-tests-testcafe" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/02/writing-reusable-tests-testcafe-300x124.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/02/writing-reusable-tests-testcafe.png" decoding="async" class="aligncenter wp-image-14611 jetpack-lazy-image" src="../Images/47fafc68f4520e9345da49709e4b1a16.png" alt="An example of the output of a test on TestCafe to a console ." data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2020/02/writing-reusable-tests-testcafe.png 760w, https://blog.logrocket.com/wp-content/uploads/2020/02/writing-reusable-tests-testcafe-300x124.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2020/02/writing-reusable-tests-testcafe.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/02/writing-reusable-tests-testcafe.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="14611" data-permalink="https://blog.logrocket.com/writing-reusable-end-to-end-tests-with-testcafe/attachment/writing-reusable-tests-testcafe/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/02/writing-reusable-tests-testcafe.png" data-orig-size="760,314" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="writing-reusable-tests-testcafe" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/02/writing-reusable-tests-testcafe-300x124.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/02/writing-reusable-tests-testcafe.png" decoding="async" loading="lazy" class="aligncenter wp-image-14611" src="../Images/47fafc68f4520e9345da49709e4b1a16.png" alt="An example of the output of a test on TestCafe to a console ." srcset="https://blog.logrocket.com/wp-content/uploads/2020/02/writing-reusable-tests-testcafe.png 760w, https://blog.logrocket.com/wp-content/uploads/2020/02/writing-reusable-tests-testcafe-300x124.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/02/writing-reusable-tests-testcafe.png"/></noscript>
<p>我们通过传递给选择器函数的CSS选择器来选择页面上的内容。</p>
<p>我们也有<code>ClientFunction</code>让我们接触像<code>window.location</code>这样的本地API。</p>
<p>我们已经测试了用户可以搜索。</p>
<p>我们还将测试用户是否可以登录现有帐户。</p>
<p>为了本文的目的，我创建了一个示例帐户。</p>
<p>下面是实现这一点的代码:</p>
<pre>   test('users can login to an existing account', async t =&gt; {
      await t
      .click(Selector('button[type=submit]'))
      .click(Selector('#pt-login'))
      .expect(getLocation()).contains('UserLogin'); //asserts that we are on the login page.
      await t
      .click(Selector('#wpName1'))
      .typeText(Selector('#wpName1'), 'Johnny Dowe')
      .click(Selector('#wpPassword1'))
      .typeText(Selector('#wpPassword1'), '96#<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="a7e4ead6cee7">[email protected]</a>_in8*wR')
      .click(Selector('button#wpLoginAttempt'))
      .expect(getLocation()).contains('search');
    });</pre>
<p>模拟普通用户在使用我们的应用程序时会遵循的流程很重要，所以我们将把它提取到一个单独的函数中。</p>
<pre>const login = t =&gt; {
await t
      .click(Selector('button[type=submit]'))
      .click(Selector('#pt-login'))
      .expect(getLocation()).contains('UserLogin'); //asserts that we are on the login page.
      await t
      .click(Selector('#wpName1'))
      .typeText(Selector('#wpName1'), 'Johnny Dowe')
      .click(Selector('#wpPassword1'))
      .typeText(Selector('#wpPassword1'), '96#<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="440709352d04">[email protected]</a>_in8*wR')
      .click(Selector('button#wpLoginAttempt'))
      .expect(getLocation()).contains('search');
}</pre>
<p>类似地，我们可以有一个功能，帮助用户在我们的应用程序上执行一个操作后注销。</p>
<p>在这里，我们将使用维基百科作为参考。</p>
<p>流程:</p>
<p>登录为65030年的网址</p><div class="code-block code-block-54">
<hr/>
<h3>更多来自LogRocket的精彩文章:</h3>

<hr/></div>
<p>假设我们想为维基百科写一些代码——使用我们的可重用函数，伪代码看起来像这样:</p>
<pre>test('users should be able to contribute', async t =&gt; {
      await login(t);
      /*
      some code to contribute to wikipedia
      */
      await logout(t);
    });</pre>
<p>我们可以在行动中看到可重用性，每当我们想要执行一个动作时，我们都有一个流程。</p>
<p>我们将假设一些事情来运行这个例子。</p>
<p>首先，我们假设我们在桌面上运行应用程序。</p>
<p>我们可以通过调整窗口大小来模拟手机环境。</p>
<p>下面是可以做到这一点的示例代码:</p>
<pre>fixture`some description`
  .page`some url`
  .beforeEach(async t =&gt; {
    await t.resizeWindow(375, 667);
  });</pre>
<p>我使用了一个示例帐户，由于维基百科设置的安全措施，该帐户在运行几次测试套件后可能会被停用。</p>
<p>您可以创建自己的帐户，并使用新的详细信息运行脚本。</p>
<p>测试脚本可能会在你运行时失败，这是因为维基百科的网站布局方式，所以选择器可能不适用。</p>
<p>错误消息总是在控制台中报告。</p>
<p>下面是它最有可能的样子:</p>
<p><img data-attachment-id="14614" data-permalink="https://blog.logrocket.com/writing-reusable-end-to-end-tests-with-testcafe/attachment/aversion-error/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/02/aversion-error.png" data-orig-size="1288,322" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="aversion-error" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/02/aversion-error-300x75.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/02/aversion-error-1024x256.png" decoding="async" class="aligncenter wp-image-14614 jetpack-lazy-image" src="../Images/17ed7d9e4ca6e3ee74e137aafa542256.png" alt="An image displaying errors logged into the console found through an end-to-end test." data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2020/02/aversion-error.png 1288w, https://blog.logrocket.com/wp-content/uploads/2020/02/aversion-error-300x75.png 300w, https://blog.logrocket.com/wp-content/uploads/2020/02/aversion-error-1024x256.png 1024w, https://blog.logrocket.com/wp-content/uploads/2020/02/aversion-error-768x192.png 768w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2020/02/aversion-error.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/02/aversion-error.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="14614" data-permalink="https://blog.logrocket.com/writing-reusable-end-to-end-tests-with-testcafe/attachment/aversion-error/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/02/aversion-error.png" data-orig-size="1288,322" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="aversion-error" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/02/aversion-error-300x75.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/02/aversion-error-1024x256.png" decoding="async" loading="lazy" class="aligncenter wp-image-14614" src="../Images/17ed7d9e4ca6e3ee74e137aafa542256.png" alt="An image displaying errors logged into the console found through an end-to-end test." srcset="https://blog.logrocket.com/wp-content/uploads/2020/02/aversion-error.png 1288w, https://blog.logrocket.com/wp-content/uploads/2020/02/aversion-error-300x75.png 300w, https://blog.logrocket.com/wp-content/uploads/2020/02/aversion-error-1024x256.png 1024w, https://blog.logrocket.com/wp-content/uploads/2020/02/aversion-error-768x192.png 768w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/02/aversion-error.png"/></noscript>
<h2>结论</h2>
<p>在这篇文章中，我们讨论了如何使用<code>Testcafe</code>直观的API在web应用程序上编写端到端的测试。</p>
<p>关于TestCafe，还有很多东西我没有涉及到，但是我希望这能让你了解如何开始使用TestCafe。</p>
<p>这里有一个<a href="https://github.com/gbols/testcafe" target="_blank" rel="noopener noreferrer">存储库</a>，它包含了所有用于参考的代码。</p><div class="code-block code-block-2">
<div class="blog-plug base-cta"><h2>使用<a class="signup" href="https://lp.logrocket.com/blg/signup" target="_blank" rel="noopener noreferrer"> LogRocket </a>消除传统错误报告的干扰</h2>
<a href="https://lp.logrocket.com/blg/signup" class="signup" target="_blank" rel="noopener noreferrer"><img class="alignnone size-full wp-image-46 jetpack-lazy-image" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/><noscript><img data-lazy-fallback="1" class="alignnone size-full wp-image-46" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/></noscript></a>
<p><a href="https://lp.logrocket.com/blg/signup" target="_blank" rel="noopener noreferrer"> LogRocket </a>是一个数字体验分析解决方案，它可以保护您免受数百个假阳性错误警报的影响，只针对几个真正重要的项目。LogRocket会告诉您应用程序中实际影响用户的最具影响力的bug和UX问题。</p>
<p>然后，使用具有深层技术遥测的会话重放来确切地查看用户看到了什么以及是什么导致了问题，就像你在他们身后看一样。</p>
<p>LogRocket自动聚合客户端错误、JS异常、前端性能指标和用户交互。然后LogRocket使用机器学习来告诉你哪些问题正在影响大多数用户，并提供你需要修复它的上下文。</p>
<p>关注重要的bug—<a class="signup" href="https://lp.logrocket.com/blg/signup-issue-free" target="_blank" rel="noopener noreferrer">今天就试试LogRocket】。</a></p><div class="code-block code-block-23">
<div class="blog-plug inline-plug node-plug"><h2>200只<img src="../Images/61167b9d027ca73ed5aaf59a9ec31267.png" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2019/10/green-check.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" class=" jetpack-lazy-image" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/10/green-check.png"/> <noscript> <img data-lazy-fallback="1" src="../Images/61167b9d027ca73ed5aaf59a9ec31267.png" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/10/green-check.png"/> </noscript>显示器出现故障，生产中网络请求缓慢</h2><p>部署基于节点的web应用程序或网站是容易的部分。确保您的节点实例继续为您的应用程序提供资源是事情变得更加困难的地方。如果您对确保对后端或第三方服务的请求成功感兴趣，</p><a href="https://lp.logrocket.com/blg/node-signup" target="_blank">try LogRocket</a><p>. </p><a class="signup" href="https://lp.logrocket.com/blg/node-signup" target="_blank" rel="noopener noreferrer"><img src="../Images/cae72fd2a54c5f02a6398c4867894844.png" alt="LogRocket Network Request Monitoring" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2019/12/network-request-filter-2-1.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" class=" jetpack-lazy-image" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/12/network-request-filter-2-1.png"/><noscript><img data-lazy-fallback="1" src="../Images/cae72fd2a54c5f02a6398c4867894844.png" alt="LogRocket Network Request Monitoring" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/12/network-request-filter-2-1.png"/></noscript></a><a href="https://lp.logrocket.com/blg/node-signup" target="_blank" rel="noopener noreferrer">https://logrocket.com/signup/</a><p>LogRocket 就像是网络和移动应用程序的DVR，记录下用户与你的应用程序交互时发生的一切。您可以汇总并报告有问题的网络请求，以快速了解根本原因，而不是猜测问题发生的原因。</p><p>LogRocket检测您的应用程序以记录基线性能计时，如页面加载时间、到达第一个字节的时间、慢速网络请求，还记录Redux、NgRx和Vuex操作/状态。</p><a class="signup" href="https://lp.logrocket.com/blg/node-signup" target="_blank" rel="noopener noreferrer">Start monitoring for free</a><p>. </p></div>
</div>
</div></div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
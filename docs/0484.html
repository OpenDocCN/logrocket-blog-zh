<html>
<head>
<title>GraphQL fragments explained - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>GraphQL片段解释- LogRocket博客</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/graphql-fragments-explained/#0001-01-01">https://blog.logrocket.com/graphql-fragments-explained/#0001-01-01</a></blockquote><div><div class="mainheading">


<h1 class="posttitle">GraphQL片段解释</h1>
<h2 class="post-subtitle"><span class="post-date"><time class="post-date">2019年10月10日</time> </span> <span class="dot"/> <span class="readingtime"> 2分钟阅读</span> <span class="wordcount"> 683 </span> <span class="logrocket_editor"/></h2>
<p>什么是GraphQL片段？</p>
</div>
<article class="article-post">
<h2>在这篇文章中，我们将了解GraphQL中的<strong>片段</strong>是什么。一个<a href="https://graphql.org/learn/queries/#fragments" target="_blank" rel="noopener noreferrer"> GraphQL片段</a>是查询的一个可重用部分。在GraphQL中，您可能会遇到需要在不同的查询中查询相同字段的情况。如果您注意到您的查询在多个区域中有许多重复的字段，您可以将它们合并到一个称为片段的可重用单元中。</h2>
<p>GraphQL片段允许您构建多个字段，并将它们包含在多个查询中。你可以把它看作编程语言中的函数，是可重用的单元。</p>
<p>GraphQL片段是一个GraphQL查询的可重用单元，它创建了一个共享的查询逻辑。</p>
<p>GraphQL片段的组成部分</p>
<h2>让我们用下面的示例结构来看看GraphQL片段的不同部分:</h2>
<p>片段由三个独特的部分组成:</p>
<pre>fragment Name on TypeName {
  field1
  field2
  field3
}</pre>
<p><strong> Name </strong>:这是片段的唯一名称(每个片段可以有自己的名称)</p>
<ul>
<li><strong> TypeName </strong>:片段将要使用的对象的类型。这表明这个片段是在GraphQL模式的哪个嵌套对象上创建的</li>
<li><strong>主体</strong>:最后一部分是片段的主体。片段的主体定义了将被查询的字段</li>
<li>使用GraphQL片段的好处</li>
</ul>
<h2>那么，为什么GrapQL查询中的片段很酷呢？</h2>
<p><strong>可重用性</strong>——使用片段，您可以将您的查询组织成可重用的单元</p>
<ul>
<li><strong>缓存</strong>–<a href="https://www.apollographql.com/docs/react/caching/cache-interaction/" target="_blank" rel="noopener noreferrer">graph QL客户端</a>利用片段来提供缓存选项</li>
<li>创建GraphQL片段</li>
</ul>
<h2>让我们通过一些例子来学习如何创建GraphQL片段。对于这篇博文中的例子，我使用的是<a href="https://developer.github.com/v4/" target="_blank" rel="noopener noreferrer"> GitHub的公共API </a>并针对它编写查询。您可以登录您的GitHub帐户，并从<a href="https://developer.github.com/v4/explorer/" target="_blank" rel="noopener noreferrer"> GitHub GraphQL Explorer </a>执行查询。</h2>
<p>注意，我们多次查询<strong>所有者</strong>字段中的相同字段。这是创建片段的好地方:</p>
<p>我们可以重写我们的查询来使用一个片段。片段是用关键字fragment创建的。</p>
<pre>{
  googleRepo: repository (owner:"google", name:"WebFundamentals") {
    name
    owner {
      id,
      avatarUrl
      resourcePath
      url
    }
  }
  facebookRepo: repository (owner:"facebook", name:"react") {
    name
    owner {
      id,
      avatarUrl
      resourcePath
      url
    }
  }
}</pre>
<p>我们可以创建一个名为<code>ownerInfo</code>的片段。在创建片段时，我们必须让GraphQL知道它是在哪个字段上创建的。在我们的例子中，我们在<code>RepositoryOwner</code>字段上创建片段。在我们的片段定义中，我们可以包含我们在<code>RepositoryOwner</code>对象上查询的所有字段。我们将<code>id</code>、<code>avatarUrl</code>、<code>resourcePath</code>和<code>url</code>作为字段添加到我们的片段中。</p>
<p>使用GraphQL片段</p>
<pre>// fragment ownerInfo for RepositoryOwner fields
fragment ownerInfo on RepositoryOwner {
  id
  avatarUrl
  resourcePath
  url
}</pre>
<h2>然后，您可以在查询中使用我们在前面的示例中创建的片段，方法是使用…运算符并提供片段的名称，如下所示:</h2>
<p>下面显示的代码片段是使用片段后的JSON响应。注意，使用片段不会对返回的响应有任何改变。片段只是让你的查询简洁、易读和可重用。它对返回的查询响应没有影响。</p>
<pre>// GraphQL Query with fragments

{
  googleRepo: repository(owner: "google", name: "WebFundamentals") {
    name
    owner {
      ...ownerInfo //fragment
    }
  }
  facebookRepo: repository(owner: "facebook", name: "react") {
    name
    owner {
     ...ownerInfo //fragment
    }
  }
}</pre>
<p>结论</p>
<pre>// GraphQL JSON Response

{
  "data": {
    "googleRepo": {
      "name": "WebFundamentals",
      "owner": {
        "id": "MDEyOk9yZ2FuaXphdGlvbjEzNDIwMDQ=",
        "avatarUrl": "https://avatars1.githubusercontent.com/u/1342004?v=4",
        "resourcePath": "/google",
        "url": "https://github.com/google"
      }
    },
    "facebookRepo": {
      "name": "react",
      "owner": {
        "id": "MDEyOk9yZ2FuaXphdGlvbjY5NjMx",
        "avatarUrl": "https://avatars3.githubusercontent.com/u/69631?v=4",
        "resourcePath": "/facebook",
        "url": "https://github.com/facebook"
      }
    }
  }
}</pre>
<h2>我希望您喜欢编写一些GraphQL查询。如果你有兴趣进一步了解GraphQL，并对GraphQL有一个全面的了解，你可以在Pluralsight上查看我的课程<a href="https://app.pluralsight.com/library/courses/graphql-big-picture/table-of-contents" target="_blank" rel="noopener noreferrer"> GraphQL: The Big Picture </a>。</h2>
<p>资源:<br/><a href="https://graphql.org/" target="_blank" rel="noopener noreferrer">https://graphql.org/</a><br/><a href="https://graphql.org/learn/" target="_blank" rel="noopener noreferrer">https://graphql.org/learn/</a><br/><a href="https://www.graphql.com/" target="_blank" rel="noopener noreferrer">https://www.graphql.com/</a></p>
<p>如果您有任何意见，请在下面发表您的意见，并与您的团队和朋友分享这篇文章。</p>
<p> </p>
<p>监控生产中失败和缓慢的GraphQL请求</p><div class="code-block code-block-24">
<div class="blog-plug inline-plug graphql-plug"><h2>虽然GraphQL有一些调试请求和响应的特性，但确保GraphQL可靠地为您的生产应用程序提供资源是一件比较困难的事情。如果您对确保对后端或第三方服务的网络请求成功感兴趣，</h2><p>.</p><a href="https://lp.logrocket.com/blg/graphql-signup" target="_blank">try LogRocket</a><p>LogRocket 就像是网络和移动应用的DVR，记录下你网站上发生的每一件事。您可以汇总并报告有问题的GraphQL请求，以快速了解根本原因，而不是猜测问题发生的原因。此外，您可以跟踪Apollo客户机状态并检查GraphQL查询的键值对。</p><a class="signup" href="https://lp.logrocket.com/blg/graphql-signup" target="_blank" rel="noopener noreferrer"><img src="../Images/432a3823c85b3fb72a206e6236a29f48.png" data-lazy-src="https://files.readme.io/69aa835-Image_2019-11-09_at_1.28.05_PM.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" class=" jetpack-lazy-image" data-original-src="https://files.readme.io/69aa835-Image_2019-11-09_at_1.28.05_PM.png"/><noscript><img data-lazy-fallback="1" src="../Images/432a3823c85b3fb72a206e6236a29f48.png" data-original-src="https://files.readme.io/69aa835-Image_2019-11-09_at_1.28.05_PM.png"/></noscript><img class="alignnone size-full wp-image-46 jetpack-lazy-image" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/><noscript><img data-lazy-fallback="1" class="alignnone size-full wp-image-46" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/></noscript></a><a href="https://lp.logrocket.com/blg/graphql-signup" target="_blank" rel="noopener noreferrer">https://logrocket.com/signup/</a><p>LogRocket检测您的应用程序以记录基线性能计时，如页面加载时间、到达第一个字节的时间、慢速网络请求，还记录Redux、NgRx和Vuex操作/状态。</p><p>.</p><a class="signup" href="https://lp.logrocket.com/blg/graphql-signup" target="_blank" rel="noopener noreferrer">Start monitoring for free</a><p>.</p></div>


</div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
<html>
<head>
<title>What’s new in Create React App 2 - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>Create React App 2 - LogRocket博客的新特性</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/whats-new-in-create-react-app-2-fe8f4f448c75/#0001-01-01">https://blog.logrocket.com/whats-new-in-create-react-app-2-fe8f4f448c75/#0001-01-01</a></blockquote><div><article class="article-post">
<figure><img decoding="async" src="../Images/dce42f0cba033688f96fbb39f16d35d4.png" data-height="630" data-width="1200" data-lazy-src="https://storage.googleapis.com/blog-images-backup/1*MmSekcpfVq3Ckath3wlJ_Q.jpeg?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" class=" jetpack-lazy-image" data-original-src="https://storage.googleapis.com/blog-images-backup/1*MmSekcpfVq3Ckath3wlJ_Q.jpeg"/><noscript><img data-lazy-fallback="1" decoding="async" src="../Images/dce42f0cba033688f96fbb39f16d35d4.png" data-height="630" data-width="1200" data-original-src="https://storage.googleapis.com/blog-images-backup/1*MmSekcpfVq3Ckath3wlJ_Q.jpeg"/></noscript></figure>
<p><a href="https://github.com/facebook/create-react-app/releases/tag/v2.1.0" target="_blank" rel="noopener noreferrer"> Create React App 2.1 </a>，2018年10月底发布，增加了对TypeScript的官方支持。这一点，加上Create React App第二版带来的所有改进和特性，大大降低了创建和配置React App的复杂性。</p>
<p>在本文中，我将介绍Create React App 2的以下特性:</p>
<ul>
<li>类型脚本支持</li>
<li>服务人员(默认情况下未注册)</li>
<li>Sass、CSS模块和PostCSS</li>
<li>反应片段短语法</li>
<li>巴别塔宏</li>
<li>自定义代理实现</li>
<li>纱线即插即用模式</li>
</ul>
<p>关于所有特性的完整列表(和一些突破性的变化)，你可以查看关于这个版本的官方帖子和这个项目的<a href="https://github.com/facebook/create-react-app/blob/master/CHANGELOG.md#203-october-1-2018" target="_blank" rel="noopener noreferrer">变更日志</a>。</p>
<figure/>
<h4>类型脚本支持</h4>
<p>对于新的应用程序，您只需使用<code>--typescript</code>选项执行create-react-app:</p>
<pre>npx create-react-app sample-typescript-app --typescript</pre>
<p>如果npx没有执行最新版本(在撰写本文时是2.1.1)，请指定create-react-app的版本:</p>
<pre>npx <a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="fc9f8e999d8899d18e999d9f88d19d8c8cbcced2cdd2cd">[email protected]</a> sample-typescript-app --typescript</pre>
<p>这将安装与TypeScript相关的包并创建一个默认的<code>tsconfig.json</code>文件。以下是该命令输出的摘录:</p>
<pre>Installing react, react-dom, and react-scripts...
+ <a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="8bf9eeeae8ffa6efe4e6cbbabda5bda5b8">[email protected]</a>
+ <a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="4c3e292d2f380c7d7a627a627f">[email protected]</a>
+ <a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="4634232725326b3525342f363235067468776877">[email protected]</a>
+ @types/<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="1664737775623b72797b5627203826382f">[email protected]</a>
+ @types/<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="196b7c787a6d59282f372e372a">[email protected]</a>
+ @types/<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="4e242b3d3a0e7c7d607d6077">[email protected]</a>
+ @types/<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="452b2a21200574756b74776b73">[email protected]</a>
+ <a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="403439302533233229303400736e716e76">[email protected]</a>
...
We detected TypeScript in your project (srcApp.test.tsx) and created a tsconfig.json file for you.
Your tsconfig.json has been populated with default values.</pre>
<p>然而，文件<code>src/App.tsx</code>将与其JavaScript副本相同，例如，如果您像这样向文件添加一个功能组件:</p>
<figure>
<pre><code>
//...
const Content = (props) =&gt; {
  return &lt;div&gt;&lt;h1&gt;{props.title}&lt;/h1&gt;{props.text}&lt;/div&gt;;
 }

class App extends Component {
  // ...
}
</code></pre>
</figure>
<p>将抛出一个关于<code>props</code>参数类型的错误:</p>
<figure><img decoding="async" src="../Images/b8f51bc06f0edefcfffbebe0dabf9ee4.png" data-height="226" data-width="1048" data-lazy-src="https://storage.googleapis.com/blog-images-backup/0*D1eYgpP1HejmRs7U?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" class=" jetpack-lazy-image" data-original-src="https://storage.googleapis.com/blog-images-backup/0*D1eYgpP1HejmRs7U"/><noscript><img data-lazy-fallback="1" decoding="async" src="../Images/b8f51bc06f0edefcfffbebe0dabf9ee4.png" data-height="226" data-width="1048" data-original-src="https://storage.googleapis.com/blog-images-backup/0*D1eYgpP1HejmRs7U"/></noscript></figure>
<p>因为现在，你必须使用<a href="https://www.sohamkamani.com/blog/react/2018-08-22-using-react-with-typescript/" target="_blank" rel="noopener noreferrer"> React声明一个类型定义。SFC </a>:</p>
<pre><code>interface ContentProps {
  title: string,
  text: string,
 }

const Content: React.SFC&lt;ContentProps&gt; = (props) =&gt; {
  return &lt;div&gt;&lt;h1&gt;{props.title}&lt;/h1&gt;{props.text}&lt;/div&gt;;
}</code></pre>
<p>如果您的IDE支持它(下图中的Visual Studio代码)，它会向您显示组件属性的类型，还会捕捉类型错误:</p>
<figure><img decoding="async" src="../Images/e60f58ee19d69798a16f80133683937c.png" data-height="105" data-width="556" data-lazy-src="https://storage.googleapis.com/blog-images-backup/0*bMmEwUtCY8FhwCR3?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" class=" jetpack-lazy-image" data-original-src="https://storage.googleapis.com/blog-images-backup/0*bMmEwUtCY8FhwCR3"/><noscript><img data-lazy-fallback="1" decoding="async" src="../Images/e60f58ee19d69798a16f80133683937c.png" data-height="105" data-width="556" data-original-src="https://storage.googleapis.com/blog-images-backup/0*bMmEwUtCY8FhwCR3"/></noscript></figure>
<p>另一方面，要将TypeScript添加到现有的Create React App应用程序，首先，手动安装与TypeScript相关的包:</p>
<pre>npm install --save typescript @types/node @types/react @types/react-dom @types/jest</pre>
<p>接下来，将文件的扩展名从<code>*.js</code>更改为<code>*.tsx</code>，并重启应用程序(如果它正在运行的话)。</p>
<h4>默认情况下，服务人员是未注册的</h4>
<p>Create React App创建的项目结构保持不变。</p>
<p>唯一的变化与服务人员有关。</p>
<p>首先，文件<code>src/registerServiceWorker.js</code>被重命名为<code>src/serviceWorker.js</code>，现在，在这个文件内部，一个<code>config</code>对象被传递给函数<code>registerValidSW</code>以启用回调<code>onUpdate</code>和<code>onSuccess</code>:</p>
<figure><img decoding="async" src="../Images/873c7049715bd203835403af942f799d.png" data-height="736" data-width="1600" data-lazy-src="https://storage.googleapis.com/blog-images-backup/0*0LAwUAe3CT2yNC64?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" class=" jetpack-lazy-image" data-original-src="https://storage.googleapis.com/blog-images-backup/0*0LAwUAe3CT2yNC64"/><noscript><img data-lazy-fallback="1" decoding="async" src="../Images/873c7049715bd203835403af942f799d.png" data-height="736" data-width="1600" data-original-src="https://storage.googleapis.com/blog-images-backup/0*0LAwUAe3CT2yNC64"/></noscript></figure>
<p>第二个变化是在<code>src/index.js</code>中，默认情况下服务人员是未注册的:</p>
<figure>
<pre><code>// If you want your app to work offline and load faster, you can change
// unregister() to register() below. Note this comes with some pitfalls.
// Learn more about service workers: http://bit.ly/CRA-PWA
serviceWorker.unregister();</code></pre>
</figure>
<p>你可以在这里了解更多关于服务人员和渐进式网络应用的信息<a href="https://facebook.github.io/create-react-app/docs/making-a-progressive-web-app" target="_blank" rel="noopener noreferrer">。</a></p>
<h4>Sass、CSS模块和PostCSS</h4>
<p>Create React App 2为您提供了更多选项来设计您的应用程序，而无需复杂的配置、弹出应用程序或使用<a href="https://github.com/timarney/react-app-rewired" target="_blank" rel="noopener noreferrer"> react-app-rewired </a>。</p>
<p>第一个选项是<a href="https://sass-lang.com/" target="_blank" rel="noopener noreferrer"> Sass </a>。要使用它，首先安装<a href="https://github.com/sass/node-sass" target="_blank" rel="noopener noreferrer"> node-sass </a>:</p>
<pre>npm install --save node-sass</pre>
<p>现在你可以创建一个Sass文件(<code>src/Message.scss</code>)。例如:</p>
<figure>
<pre><code>$theme-color: green;
```
.my-message {
  color: $theme-color;
}</code></pre>
</figure>
<p>并以这种方式在组件(<code>src/Message.js</code>)中使用它:</p>
<figure>
<pre><code>import React from 'react'
import './Message.scss'
const Message = props =&gt; {
  return &lt;li className={my-message}&gt; {children} &lt;li&gt;
}
export default Message;</code></pre>
</figure>
<p>另一方面，使用<a href="https://www.javascriptstuff.com/what-are-css-modules/" target="_blank" rel="noopener noreferrer"> CSS模块</a>，你不需要安装更多的依赖项，你只需要遵循<code>[name].module.css</code>文件命名约定。</p>
<p>例如，如果您有一个<code>Message.js</code>组件(如前面的例子所示)，您可以在文件<code>Message.module.css</code>中定义它的样式(记住，使用CSS模块，您可以<a href="https://bambielli.com/til/2017-08-11-css-modules-composes/" target="_blank" rel="noopener noreferrer">组成</a>类):</p>
<figure>
<pre><code>.my-theme {
  color: green;
}
.my-message {
  composes: my-theme;
  font-size: 20px;
}</code></pre>
</figure>
<p>在组件中，使用如下样式:</p>
<figure>
<pre><code>import styles from './Message.module.css'
// ...
&lt;li className={styles.my-message}&gt; {children} &lt;/li&gt;</code></pre>
</figure>
<p>这样，在运行时，将生成一个具有半随机名称的CSS类，以便在本地将这些样式限定在组件范围内:</p>
<pre>&lt;li class="Message_my-message_tp3lv"&gt;&lt;/li&gt;</pre>
<p>此外，Create React App 2中还包含了<a href="https://github.com/luisrudge/postcss-flexbugs-fixes" target="_blank" rel="noopener noreferrer">postscs-flex bugs-fixes</a>和<a href="https://github.com/csstools/postcss-preset-env" target="_blank" rel="noopener noreferrer">postscs-preset-env</a>(<a href="https://github.com/facebook/create-react-app/blob/master/packages/react-scripts/config/webpack.config.js#L104" target="_blank" rel="noopener noreferrer">仅支持</a>的<a href="https://preset-env.cssdb.org/features#stage-3" target="_blank" rel="noopener noreferrer"> stage3+功能</a>)，这意味着会自动添加供应商前缀，并为旧浏览器填充新的css功能。你可以在这里了解更多<a href="https://facebook.github.io/create-react-app/docs/post-processing-css" target="_blank" rel="noopener noreferrer">。</a></p>
<h3>反应片段短语法</h3>
<p>React 16.2添加了对<a href="https://reactjs.org/blog/2017/11/28/react-v16.2.0-fragment-support.html" target="_blank" rel="noopener noreferrer">片段</a>的支持，以从组件的渲染方法中返回多个子组件，这已经有一段时间了:</p>
<figure>
<pre><code>render() {
  return (
    &lt;React.Fragment&gt;
      &lt;h1&gt;My Messages&lt;/h2&gt;
      &lt;p&gt;Message 1&lt;/p&gt;
      &lt;p&gt;Message 2&lt;/p&gt;
    &lt;/React.Fragment&gt;
  );
}</code></pre>
</figure>
<p>然而，作为JSX片段语法(或简称语法):</p>
<figure>
<pre><code>render() {
  return (
    &lt;&gt;
      &lt;h1&gt;My Messages&lt;/h2&gt;
      &lt;p&gt;Message 1&lt;/p&gt;
      &lt;p&gt;Message 2&lt;/p&gt;
    &lt;/&gt;
  );
}</code></pre>
</figure>
<p>它只受Babel 7支持，你现在可以使用它，因为Create React App 2使用这个版本的Babel。</p>
<p>然而，记住<code>&lt;&gt;&lt;/&gt;</code>只是<code>&lt;React.Fragment&gt;</code>的语法糖，但是没有使用键或其他属性的选项。</p>
<h3>巴别塔宏</h3>
<p>在Create React App 2的上下文中，Babel宏允许您使用特殊类型的Babel插件，而无需任何配置。</p>
<p>让我解释一下。</p>
<p>巴别塔插件允许你在编译时操作和转换代码。例如，有一个<a href="https://babeljs.io/docs/en/babel-plugin-transform-arrow-functions" target="_blank" rel="noopener noreferrer">插件</a>可以转换箭头功能:</p>
<pre>const a = (b) =&gt; b;</pre>
<p>普通JavaScript函数:</p>
<pre>const a = function (b) {
  return b;
};</pre>
<p>然而，Babel插件的一个问题是，你必须配置每一个你想使用的插件。通常，这是在<code>.babel.rc</code>中完成的，但是当使用Create React App时，除非弹出应用程序，否则无法访问该文件。</p>
<p>幸运的是，有<a href="https://www.npmjs.com/package/babel-plugin-macros" target="_blank" rel="noopener noreferrer"> babel-plugin-macros </a>，一个为…宏定义标准接口的插件(即执行构建时转换的插件)。</p>
<p>这样，你只需要将这个插件添加到你的项目中(这就是Create React App所做的)就可以使用任意数量的宏。</p>
<p>由于宏是在编译时处理的，在运行时并不需要，所以它们应该被指定为<code>devDependencies</code>。</p>
<p>您可以在<a href="https://www.npmjs.com/search?q=keywords:babel-plugin-macros" target="_blank" rel="noopener noreferrer"> npm中搜索关键字babel-plugin-macros </a>来查找宏。</p>
<p>以Babel插件/宏<a href="https://github.com/vinhlh/tagged-translations" target="_blank" rel="noopener noreferrer">标记翻译</a>为例，它在编译时翻译文本。</p>
<p>只需将此库添加到Create React应用程序项目中:</p>
<pre>npm install --save-dev tagged-translations</pre>
<p>在项目的根目录下添加文件<code>translations/default.json</code>,翻译如下:</p>
<pre>{
  "Hello world": "Hola mundo"
}</pre>
<p>并在你的组件中使用它作为一个宏(不是作为一个插件，<a href="https://github.com/kentcdodds/babel-plugin-macros#whats-the-difference-between-babel-plugins-and-macros" target="_blank" rel="noopener noreferrer">有区别</a>):</p>
<figure>
<pre><code>import t from 'tagged-translations/macro'

class App extends Component {
  render() {
    return (
      &lt;div className="App"&gt;
          {t`Hello world`}
      &lt;/div&gt;
    );
  }
}</code></pre>
</figure>
<p>如下图所示，在编译时创建包时会发生转换:</p>
<figure><img decoding="async" src="../Images/ac135a22c9b58b387b8c54f620c2b0ec.png" data-height="405" data-width="954" data-lazy-src="https://storage.googleapis.com/blog-images-backup/0*TdByJTaiKWD2jFw2?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" class=" jetpack-lazy-image" data-original-src="https://storage.googleapis.com/blog-images-backup/0*TdByJTaiKWD2jFw2"/><noscript><img data-lazy-fallback="1" decoding="async" src="../Images/ac135a22c9b58b387b8c54f620c2b0ec.png" data-height="405" data-width="954" data-original-src="https://storage.googleapis.com/blog-images-backup/0*TdByJTaiKWD2jFw2"/></noscript></figure>
<h3>自定义代理实现</h3>
<p>在Create React App的第一个版本中，当发出API请求时，您可以选择对请求的完整URL进行硬编码，如下所示:</p>
<figure>
<pre><code>fetch('http://localhost:3001/messages')
  .then(res =&gt; {
    // ...
})</code></pre>
</figure>
<p>或者在<code>package.json</code>文件中添加一个代理字段:</p>
<pre>'proxy': 'http://localhost:3001/'</pre>
<p>要在<code>fetch</code>调用中只使用资源的路径:</p>
<figure>
<pre><code>fetch('/messages')
  .then(res =&gt; {
    // ...
})</code></pre>
</figure>
<p>使用Create React App 2，除了上面显示的方法，您还可以通过安装<a href="https://github.com/chimurai/http-proxy-middleware" target="_blank" rel="noopener noreferrer"> http-proxy-middleware </a>来配置自定义代理:</p>
<pre>npm install --save http-proxy-middleware</pre>
<p>并创建文件<code>src/setupProxy.js</code>来配置代理:</p>
<figure>
<pre><code>const proxy = require('http-proxy-middleware');
module.exports = function(app) {
  // ...
};</code></pre>
</figure>
<p>当应用程序启动时，这个文件将被自动导入，它让您可以访问一个<a href="https://expressjs.com/" target="_blank" rel="noopener noreferrer"> Express </a>实例来做类似这样的事情:</p>
<figure>
<pre><code>const proxy = require('http-proxy-middleware');
module.exports = function(app) {
  app.use(proxy('/api', { target: 'http://localhost:3001/' }));
  app.use(proxy('/public', { target: 'http://localhost:3002/' }));
};</code></pre>
</figure>
<h4>纱线即插即用模式</h4>
<p>纱线即插即用模式允许您的应用程序在没有<code>node_modules</code>目录的情况下工作。</p>
<p>通过这种方式，应用程序依赖项从Yarn的缓存中加载，而不需要在安装步骤中将它们复制到<code>node_modules</code>目录中。这有一个额外的好处，就是可以更快地创建应用程序。</p>
<p>要使用该功能，您需要<a href="https://yarnpkg.com/lang/en/docs/install/" target="_blank" rel="noopener noreferrer"> Yarn 1.12+ </a>，Node.js 8.9+，并确保使用选项<code>--use-pnp</code>创建您的React应用程序:</p>
<pre>npx create-react-app light-app --use-pnp</pre>
<p>如果命令执行成功，在文件<code>package.json</code>中，你会发现一个额外的配置选项:</p>
<pre>{
  ...
  "installConfig": {
    "pnp": true
  },
  ...
}</pre>
<p>此外，您将获得一个<code>.pnp</code>目录，该目录链接到Yarn的缓存目录和文件<code>.pnp.js</code>，后者验证依赖关系并提供从全局缓存而不是从<code>node_modules</code>目录中搜索它们的能力。</p>
<p>这是一个实验性的特性(在我写这篇文章的时候),所以它可能不能在所有情况下工作(例如，我没有在我的Windows 10机器上工作),也不能与直接处理<code>node_modules</code>目录的工具一起工作。</p>
<h3>结论</h3>
<p>Create React App 2增加了更多的选项来简化React应用程序的创建和配置。我个人认为最有帮助的三个新功能是TypeScript、Saas和Babel macros。</p>
<p>然而，我不得不说，对于一个现有的应用程序，如果你不需要这些新功能，或者如果你有一个使用<a href="https://github.com/timarney/react-app-rewired" target="_blank" rel="noopener noreferrer"> react-app-rewired </a>或<a href="https://github.com/sharegate/craco" target="_blank" rel="noopener noreferrer"> craco </a>的工作配置，它可能不值得升级。</p>
<p>即使是Create React App团队<a href="https://reactjs.org/blog/2018/10/01/create-react-app-v2.html" target="_blank" rel="noopener noreferrer">也建议这样做</a>:</p>
<blockquote><p>不要觉得升级什么都有压力。如果您对当前的特性集、其性能和可靠性感到满意，您可以继续使用当前的版本！在生产中切换到2.0版本之前，让它稳定一点也是一个好主意。</p></blockquote>
<p>但是对于新的应用程序，您可以随意使用许多新功能。</p>
<p>黑客快乐！</p><div class="code-block code-block-54">
<hr/>
<h3>更多来自LogRocket的精彩文章:</h3>

<hr/></div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
<html>
<head>
<title>Using ES modules in Node.js - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>在Node.js - LogRocket博客中使用ES模块</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/es-modules-in-node-today/#0001-01-01">https://blog.logrocket.com/es-modules-in-node-today/#0001-01-01</a></blockquote><div><article class="article-post">
<p><em> <strong>编者按:</strong>本文更新于2021年3月3日。</em></p>
<h2>介绍</h2>
<blockquote><p>"在软件可以重用之前，它首先必须是可用的."–<a href="https://en.wikipedia.org/wiki/Ralph_Johnson_(computer_scientist)">拉尔夫·约翰逊</a></p></blockquote>
<p><a href="https://en.wikipedia.org/wiki/Module">模块</a>是软件程序的独立构件。它们基本上是一种设计模式，在编程语言中实现了<a href="https://en.wikipedia.org/wiki/Modular_programming">m</a>T4】模块化设计的特性。模块系统支持多种语言，并且非常流行，因为处理、打包和管理依赖关系的方式决定了处理大型且不断增长的源代码的难易程度。</p>
<p>在模块化设计中，为了可重用性、灵活性和降低复杂性，与特定特性或功能相关的业务逻辑以标准化格式进行打包(模块化)。由于没有全局变量或共享状态，这种设置提供了一个松散耦合的系统，因为有一个平滑的通信接口。</p>
<p>尽管模块的概念根据语言的不同而有很大的不同，但它们类似于Java等语言中的T2命名空间的概念。模块通过将代码库分成可重用的组件来实现代码组织，这样每个组件执行单独的功能，并且可以组合或组成更大的功能或整个应用程序。</p>
<p>在Node.js中，<a href="https://nodejs.org/docs/latest/api/modules.html#modules_modules">模块系统</a>已经从早期采用<a href="https://requirejs.org/docs/commonjs.html"> CommonJS </a>走了很长一段路。今天，<a href="https://nodejs.org/dist/latest-v13.x/docs/api/esm.html#esm_ecmascript_modules"> ECMAScript模块</a> (ES模块)，现在已经稳定并适合生产使用，是封装代码以在客户端和服务器端JavaScript中重用的官方标准。</p>
<h2 id="tableofcontents">目录</h2>
<p>在本文中，我们将学习Node中的ES模块。然而，我们将简要探讨用CommonJS处理和组织服务器端代码的其他方法。</p>
<p>为什么？以便我们有一个参考点来认识ES模块的好处。实质上，我们将了解它试图解决的挑战，这些挑战是早期模块系统无法解决的。</p>
<p>我们将会看到:</p>
<ul>
<li><strong>ES模块简介</strong> —在这里，我们以激动人心的方式介绍ES模块</li>
<li><strong>ES模块简史</strong> —在这里，我们了解从早期的模块系统到ES模块的过渡。我们还将简要考察这些模块系统之间的互操作性</li>
<li><strong>在节点</strong>中增加对es模块的支持—在这里，我们了解如何在节点中增加对ES模块的支持。我们还将学习如何迁移旧的代码库来开始使用ES模块</li>
<li><strong>比较和对比特性</strong> —在这里，我们将了解这两种模块系统的特性以及它们之间的比较</li>
<li><strong>最后，ES模块向前移动</strong></li>
</ul>
<h2 id="prerequisites">先决条件</h2>
<p>为了轻松地学习本教程，建议安装最新版本的Node.js。关于如何操作的说明可在<a href="https://nodejs.org/en/">节点文档</a>中找到。</p>
<p>此外，为了更好地理解上下文，读者可能需要对Node中的<a href="https://requirejs.org/docs/commonjs.html"> CommonJS </a>模块系统有相当的了解。对于今天学习Node.js模块系统或者在自己的节点项目中应用ES模块的新人来说，同样是欢迎的。</p>
<h2 id="introducingesmodules">什么是ES模块？</h2>
<p>随着Node版本15.3.0的发布(目前版本为15.11.0)，<a href="https://nodejs.org/api/esm.html#esm_introduction"> ES模块</a>现在可以在没有实验标志的情况下使用，因为它们现在是稳定的，并且与NPM生态系统兼容。关于稳定性指数的细节可以在node.js ESM文档中找到<a href="https://nodejs.org/api/documentation.html" target="_blank" rel="noopener">这里</a>。在ES模块中，使用<code>import</code>和<code>export</code>关键字来定义模块，而不是使用CommonJS中的<code>require()</code>函数。下面是它们的使用方法:</p>
<pre>export function sayLanguage(language) {
    console.log(`I love ${language}!`);
  }

//f.js


import {sayLanguage} from './f.js';

console.log(sayLanguage('JavaScript'));

//g.js

{
  "name": "esm",
  "version": "1.0.0",
  "description": "",
  "main": "index.js",
  "scripts": {
    "test": "echo \"Error: no test specified\" &amp;&amp; exit 1"
  },
  "type": "module",
  "author": "",
  "license": "ISC"
}
//package.json
</pre>
<blockquote><p><strong>注意</strong>:读者应该注意上面package.json文件中的type字段。为了能够加载一个ES模块，我们需要在这个文件中设置“type”:“module ”,或者，作为替代，我们可以使用。mjs文件扩展名。js文件扩展名。此外，从节点版本12.7.0和13.2.0，加载ECMAScript模块不再需要我们传递任何命令行标志。</p></blockquote>
<pre>Alexs-MacBook-Pro:esm terra-alex.$ node g.js
I love JavaScript!
undefined
Alexs-MacBook-Pro:esm terra-alex.$</pre>
<p>上面显示了运行我们的代码的结果/终端输出。</p>
<h2>今天在Node中增加了对ES模块的支持</h2>
<p>这种支持以前是在<code>--experimental-module</code>旗的后面。目前，从版本13.14.0到14.0.0，不再需要这样做，实现现在是稳定的，现在可以与早期的commonJS模块系统一起使用。</p>
<p>以<code>.mjs</code>或<code>.js</code>扩展名结尾的文件(最近的<code>package.json</code>文件带有<code>field</code>类型)被视为es模块，如前所示。因此，本质上，当我们在与上面的<code>package.json</code>相同的文件夹中运行<code>node g.js</code>时，该文件被视为一个ESM。此外，如果我们将字符串参数传递给带有标志<code>--input-type=module</code>的Node.js标准输入，那么它就是一个ESM。更多细节可以在<a href="https://nodejs.org/api/packages.html#packages_determining_module_system">这里</a>找到。</p>
<p>需要注意的是，在ESM中，如果没有父<code>package.json</code>文件中的<code>type</code>字段或上面指定的其他方式，Node会抛出如下所示的错误:</p>
<pre>(node:2844) Warning: To load an ES module, set "type": "module" in the package.json or use the .mjs extension.(Use `node --trace-warnings ...` to show where the warning was created). Also, as an aside, we cannot make use of import statements outside of modules.</pre>
<h2>包范围</h2>
<p>如前所述，由父<code>package.json</code>文件及其下所有文件夹中的<code>type</code>标志定义的包范围存在于该包的当前范围中。此外，以<code>.mjs</code>扩展名结尾的文件总是作为es模块加载，而不管那个包的范围。</p>
<p>同样，所有其他形式的没有扩展名并且在父<code>package.json</code>文件中没有<code>type</code>标志的文件都被视为CommonJS。此外，以<code>.cjs</code>扩展名结尾的文件被视为CJS模块，而不考虑包的范围。</p>
<p>重要的是要知道，因为Node.js现在同时支持ES模块和commonJS模块，所以包作者需要始终确保他们的package.json文件中的<code>type</code>字段始终被包含，而不管模块类型如何。这允许向后兼容；例如，在Node.js的默认类型改变的情况下，Node将知道如何处理或解释我们程序中的文件。更多详情<a href="https://nodejs.org/api/packages.html#packages_determining_module_system" target="_blank" rel="noopener">此处</a>。</p>
<h2>ES模块中的导入和导出语法</h2>
<p>在ES模块中，说明符类似于在关键字<code>from</code>之后使用的基于字符串的文件路径。有两种<a href="https://nodejs.org/api/esm.html#esm_resolution_algorithm">算法</a>来加载一个ES模块说明符和确定一个解析的URL的模块格式。下面显示了一个示例:</p>
<pre>import {cat} from 'animals';</pre>
<p>例如，本例中的<code>animal</code>说明符是一个npm包。引用说明符的其他方式包括绝对和相对文件路径或URL，以及其他包中的路径。文档的<a href="https://nodejs.org/api/esm.html#esm_import_specifiers">部分</a>给出了示例。</p>
<blockquote><p><strong>注意</strong> : Node.js内置模块现在可以由14.13.1版的绝对URL字符串加载或引用，当使用import关键字时，必须提供文件扩展名来解析相对或绝对URL说明符。</p></blockquote>
<p>虽然<code>import</code>语句只允许在ES模块中使用，但是它们可以引用ESM或CommonJS模块。例如:</p>
<pre>import packageMain from 'commonjs-package'; // Works

import { method } from 'commonjs-package'; // Errors</pre>
<blockquote><p><strong>注意</strong> : <a href="https://nodejs.org/api/esm.html#esm_import_statements">引用JSON或Wasm等其他类型文件的导入语句</a>仍然是实验性的，需要分别传递<code>--experimental-json-modules</code>和<code>--experimental-wasm-modules</code>标志，因为它们只在commonJS中受支持。从节点版本14.8.0开始，我们能够在不传递CLI标志的情况下利用顶级await。包括在ESM的异步函数(也称为顶级await)之外使用await关键字的详细信息，可以在<a href="https://nodejs.org/api/esm.html#esm_experimental_json_modules" target="_blank" rel="noopener">这里</a>找到。</p></blockquote>
<p>对于ES模块中的导出，我们可以利用以下内容:</p>

<blockquote><p><strong>注意</strong>:所有内置节点包都支持上述所有类型的导出(命名，默认)。自节点版本14.13.0起，增加了对在ESM中检测名为exports的CommonJS的支持。</p></blockquote>
<h2>包入口点</h2>
<p>在项目的<code>package.json</code>文件中，现在有两个字段可以定义包的入口点:<code>main</code>和<code>exports</code>。虽然<code>main</code>字段仅定义了包的主入口点，但是<code>exports</code>字段提供了一种替代方式，在此可以定义主入口点，同时还提供了封装包的好处。</p>
<p>包中的模块文件可以通过在包名后附加一个路径来访问。另一种方式是如果包的<code>package.json</code>包含一个<code>exports</code>字段，包内的文件只能通过<code>exports</code>对象中定义的路径访问。</p>
<p>例如，要为一个包设置主入口点，建议在包的<code>package.json</code>文件中定义<code>exports</code>和<code>main</code>。更多细节可以在<a href="https://nodejs.org/api/esm.html#esm_package_entry_points" target="_blank" rel="noopener">文档</a>中找到。</p>
<h2 id="commonjsmodulesystem">CommonJS模块系统</h2>
<p>在引入ES模块之前，社区非常依赖CommonJS来打包服务器端JavaScript代码。在CommonJS模块系统中，每个文件都被视为一个模块，它通过使用<a href="https://github.com/nodejs/ecmascript-modules/blob/modules-lkgr/doc/api/modules.md#exports"> <code>exports</code>对象</a>来公开一组API(通过一个定义良好的接口)。为了更好地理解这一点，下面是一个使用由模块系统创建的对象的示例:</p>
<pre>function sayName(name) {
    console.log(`My name is ${name}.`)
  };

function sayAge(age){
  console.log(`I'm ${age} years old.`)
  };


module.exports = {sayName, sayAge};
//a.js</pre>
<p>要使用这些函数(作为模块导入到不同的文件中)，我们可以使用<a href="https://github.com/nodejs/ecmascript-modules/blob/modules-lkgr/doc/api/modules.md#requireid"> <code>require</code>函数</a>。基于公开的API的模块类型，它接受由相对或绝对路径或名称指定的模块标识符(ID ),如下所示:</p>
<pre>const {sayName, sayAge} = require('./a') 
// assuming a.js is in the same folder path

console.log(sayName('Alex')) // My name is Alex.

console.log(sayAge(25)) // I'm 25 years old.

//b.js
//TO RUN THE CODE SAMPLE TYPE: $ node b.js on your terminal</pre>
<p>正如我们在上面看到的，<code>require</code>对象返回/导入从<code>a.js</code>文件导出的模块内容。为了了解更多关于<code>module</code>、<code>export</code>和<code>require</code>关键字的<a href="https://github.com/nodejs/node/blob/7c63bc6540f4ad21f911f38f8708ed988f433ce7/lib/internal/modules/cjs/loader.js#L166">实现</a>，我们可以在这里查看模块包装<a href="https://github.com/nodejs/ecmascript-modules/blob/modules-lkgr/doc/api/modules.md#the-module-wrapper">。</a></p>
<p>CommonJS规范也可以在<a href="https://github.com/commonjs/commonjs/blob/master/docs/specs/modules/1.0.html.markdown">这里</a>获得。规范<a href="https://github.com/commonjs/commonjs/blob/master/docs/specs/modules/1.0.html.markdown#commonjs-modules">强调了</a>一个模块系统为了支持其他模块系统并与之互操作而必须具备的最少特性。</p>
<p>CommonJS实现允许定义文件加载的结构。在这种方法中，同步加载或解析其他文件所需的代码。由于这个原因，捕捉和检测故障点或调试代码变得更加容易和简单。</p>
<p>为什么？因为模块或导出文件中存在的变量在该模块的作用域内，或者是该模块的私有变量，而不在全局作用域内，所以这样的错误被正确地传播。此外，由于关注点的巨大分离，模块从父级加载到子级，沿着依赖图向下遍历。</p>
<blockquote><p><strong>注意</strong>:当包装函数返回时，exports对象被缓存，然后作为<code>require()</code>方法的返回值返回。这就像一个循环。怎么会？在下一次调用<code>module.exports</code>方法时，重复使用包装函数包装模块的相同过程。但是必须检查该模块是否已经存储在高速缓存中。</p></blockquote>
<p>包装函数的签名如下所示:</p>
<pre>(function(exports, require, module, __filename, __dirname) {
// Module code actually lives in here
});</pre>
<p>接受ID和父模块作为参数的<code>Module</code>对象包含<code>export</code>对象:</p>
<pre>function Module(id = '', parent) {
  this.id = id;
  this.path = path.dirname(id);
  this.exports = {};
  this.parent = parent;
  updateChildren(parent, this, false);
  this.filename = null;
  this.loaded = false;
  this.children = [];
};</pre>
<p><code>updateChildren</code>方法扫描文件路径，直到到达文件系统的根目录。它的工作是用新的<code>parent</code>更新<code>Module</code>对象的<code>children</code>属性，视情况而定。下面是签名:</p>
<pre>function updateChildren(parent, child, scan) {
  const children = parent &amp;&amp; parent.children;
  if (children &amp;&amp; !(scan &amp;&amp; children.includes(child)))
   children.push(child);
}</pre>
<p>让我们看一个例子来更好地理解这一点。在上面的<code>b.js</code>文件中，添加这行代码来打印模块和参数对象:</p>
<pre>console.log(module, arguments);</pre>
<p>运行<code>node b.js</code>后，我们得到以下输出:</p>
<pre><a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="deacbbaab7b0bf9ebfb2bba6">[email protected]</a> es-modules in Node % node b.js
My name is Alex.
undefined
I'm 25 years old.
undefined
&lt;ref *1&gt; Module {
  id: '.',
  path: '/Users/retina/Desktop/es-modules in Node',
  exports: {},
  parent: null,
  filename: '/Users/retina/Desktop/es-modules in Node/b.js',
  loaded: false,
  children: [
    Module {
      id: '/Users/retina/Desktop/es-modules in Node/a.js',
      path: '/Users/retina/Desktop/es-modules in Node',
      exports: [Object],
      parent: [Circular *1],
      filename: '/Users/retina/Desktop/es-modules in Node/a.js',
      loaded: true,
      children: [],
      paths: [Array]
    }
  ],
  paths: [
    '/Users/retina/Desktop/es-modules in Node/node_modules',
    '/Users/retina/Desktop/node_modules',
    '/Users/retina/node_modules',
    '/Users/node_modules',
    '/node_modules'
  ]
} [Arguments] {
  '0': {},
  '1': [Function: require] {
    resolve: [Function: resolve] { paths: [Function: paths] },
    main: Module {
      id: '.',
      path: '/Users/retina/Desktop/es-modules in Node',
      exports: {},
      parent: null,
      filename: '/Users/retina/Desktop/es-modules in Node/b.js',
      loaded: false,
      children: [Array],
      paths: [Array]
    },
    extensions: [Object: null prototype] {
      '.js': [Function (anonymous)],
      '.json': [Function (anonymous)],
      '.node': [Function (anonymous)]
    },
    cache: [Object: null prototype] {
      '/Users/retina/Desktop/es-modules in Node/b.js': [Module],
      '/Users/retina/Desktop/es-modules in Node/a.js': [Module]
    }
  },
  '2': Module {
    id: '.',
    path: '/Users/retina/Desktop/es-modules in Node',
    exports: {},
    parent: null,
    filename: '/Users/retina/Desktop/es-modules in Node/b.js',
    loaded: false,
    children: [ [Module] ],
    paths: [
      '/Users/retina/Desktop/es-modules in Node/node_modules',
      '/Users/retina/Desktop/node_modules',
      '/Users/retina/node_modules',
      '/Users/node_modules',
      '/node_modules'
    ]
  },
  '3': '/Users/retina/Desktop/es-modules in Node/b.js',
  '4': '/Users/retina/Desktop/es-modules in Node'
}</pre>
<p>如上图，我们可以看到第6行的<a href="https://github.com/nodejs/node/blob/master/lib/internal/modules/cjs/loader.js#L156">模块对象</a>的所有属性，包括<code>filename</code>、<code>id</code>、<code>children</code>、路径深度等。此外，我们可以看到<code>argument</code>对象，它由<code>export</code>对象、<code>require</code>函数、文件和文件夹路径以及<code>Module</code>组成(这本质上是包装器函数所做的，但是它执行包含在文件/模块中的代码)。</p>
<p>最后，作为练习，我们可以继续在<code>b.js</code>文件中打印<code>require</code>函数。要了解更多关于<code>require</code>函数的输出，我们可以查看这一节节点源代码中的<a href="https://github.com/nodejs/node/blob/master/lib/internal/modules/cjs/loader.js#L1087">实现</a>。</p>
<blockquote><p><strong>注意</strong>:要特别强调<code><a href="https://github.com/nodejs/node/blob/master/lib/internal/modules/cjs/loader.js#L890:8">load</a></code>和<code>validateString</code>方法。<code>validateString</code>方法，顾名思义，检查传入的模块ID是否是有效的字符串。要在更高的层次上理解require函数，您可以查看节点文档的<a href="https://nodejs.org/en/knowledge/getting-started/what-is-require/">知识部分</a>。</p></blockquote>
<h2>两个模块系统的互操作性</h2>
<p>在CommonJS中，<a href="https://github.com/nodejs/ecmascript-modules/blob/modules-lkgr/doc/api/modules.md#the-module-wrapper">模块在运行时被评估之前被包装成函数</a>。对于ES模块，通过<code>import</code>和<code>export</code> <a href="https://github.com/nodejs/node-eps/blob/master/002-es-modules.md#21-types">绑定</a>提供的代码重用在被评估之前已经被<a href="https://github.com/nodejs/node-eps/blob/master/002-es-modules.md#31-async-loading">异步创建或加载</a>。要了解ESM在引擎盖下是如何工作的，你可以查看这里的<a href="https://github.com/nodejs/node-eps/blob/master/002-es-modules.md#22-operations"/>。现在让我们进一步探索🙂</p>
<p>为了快速比较，CommonJS模块在其生命周期中会经历以下阶段:</p>
<p><em>解析—&gt;加载—&gt;包装—&gt;评估—&gt;缓存</em></p>
<p>这证实了一个事实，即对于CommonJS，在模块被包装和评估之前，没有办法确定什么作为模块导出。这对于ES模块来说非常不同，因为在代码被评估之前，导入的符号已经被语言解析和理解了。</p>
<p>当代码被解析时，就在它被评估之前，一个内部的<a href="https://tc39.es/ecma262/#sec-source-text-module-records">模块记录</a>被创建，并且只有在这个数据结构是格式良好的之后，文件才被解析并且代码被评估。</p>
<p>例如:</p>
<pre>//d.mjs
const check = () =&gt; {
  console.log('Just checking`);
};
export.check = check;


//e.mjs assuming they are on the same folder path
import {check} from './d'</pre>
<p>在上面的<code>e.mjs</code>文件中，Node.js在进一步执行或评估这段代码之前解析并验证导入。对于CommonJS模块来说，情况并非如此:只有在模块被包装和评估之后，导出的符号才是已知的。</p>
<p>这种不兼容性是负责ECMAScript的标准机构打算为ESM和节点的现有CommonJS模块系统实现互操作性的众多原因之一。</p>
<p>此外，<a href="https://nodejs.org/api/esm.html#esm_customizing_esm_specifier_resolution_algorithm">当前说明符解析</a>并不支持CommonJS加载器的所有默认行为。其中一个主要区别是文件扩展名的自动解析和导入包含索引文件的目录的能力。</p>
<p>例如，如果我们从一个有<code>index.js</code>的目录中执行<code>import './directory'</code>，ES模块不会像在CommonJS中那样在指定的文件夹中寻找一个<code>index.js</code>文件。相反，它会抛出一个错误。这可以通过传递实验标志<code>--experimental-specifier-resolution=[mode]</code>来修复。更多详情<a href="https://nodejs.org/api/esm.html#esm_customizing_esm_specifier_resolution_algorithm" target="_blank" rel="noopener">此处</a>。</p>
<blockquote><p><strong>注意</strong>:为了定制默认的模块解析，可以选择通过Node.js的<code>--experimental-loader ./loader-name.mjs</code>参数提供加载器挂钩。加载器API目前正在重新设计，这意味着它们将来会改变。</p></blockquote>
<p>此外，虽然import语句可以引用ES模块和commonJS模块，但是只允许在ES模块中使用import语句。但是，对于加载ES模块，commonJS支持动态导入表达式。另外，可以使用<code>module.createRequire()</code>方法在ESM中构造一个require函数。</p>
<p>关于与CommonJS互操作性的更多细节可以在文档的这个<a href="https://nodejs.org/api/esm.html#esm_interoperability_with_commonjs">部分</a>中找到。</p>
<h2 id="featuresofbothmodulesystems">两种模块系统的特点</h2>
<ul>
<li>CommonJS和ES模块都支持动态<code>import()</code>。它可以用来包含CommonJS代码中的ES模块文件</li>
<li>ECMAScript 6还提供了可以从URL加载的模块，而CommonJS仅限于相对和绝对文件路径。这一新的改进不仅使加载变得更加复杂，而且速度也很慢</li>
<li>Node.js不理解的格式的源代码可以转换成JavaScript。更多详情可在<a href="https://nodejs.org/api/esm.html#esm_transpiler_loader">这里</a>找到</li>
<li>ESM中对<a href="https://github.com/WICG/import-maps#extension-less-imports">无扩展主入口点</a>的支持已经取消</li>
<li><a href="https://github.com/tc39/proposal-import-meta"> proposal-import-meta </a>提供当前es模块文件的绝对URL。它目前是TC39规范中的第4阶段提案</li>
<li>动态导入可用于导入ES和CommonJS模块。在CommonJS模块中，它可以用来加载es模块。请注意，它返回一个承诺</li>
<li>使用<code>import</code>关键字时，必须提供文件扩展名。必须完全指定目录索引(如<code>'./database/index.js'</code>)</li>
<li>通过使用<a href="https://nodejs.org/api/esm.html#esm_conditional_exports">有条件的出口，双CommonJS和ESM现在是可能的。</a>现在，Node.js可以运行ES模块入口点，一个包可以同时包含CommonJS和ESM入口点</li>
<li>从14.13.1版本开始，ESM增加了对使用<code>node: URLs</code>加载Node.js内置模块的支持，允许内置模块被有效的绝对URL字符串引用</li>
</ul>
<blockquote><p><strong>注意</strong>:函数<code>require</code>不应该在ES模块中使用。这是因为ES模块是异步执行的。要从CommonJS模块加载ES模块，我们可以利用<code>import()</code>。</p></blockquote>
<p>读者还应该注意到，ESM和commonJS模块之间仍然存在一些已知的差异。例如，ESM导入目前不支持本机模块。此外，ES模块加载器有自己的缓存系统，不依赖于commonJS术语中的<code>require.cache</code>。</p>
<p>其他包括在commonJS模块系统中发现的<em> _filename </em>或<em> _dirname </em>不可用。ESM通过使用<code>import.meta.url</code>提供了复制这种行为的其他方式。</p>
<p>关于es模块和commonJS模块之间差异的更多细节，读者可以查看文档的这一<a href="https://nodejs.org/api/esm.html#esm_differences_between_es_modules_and_commonjs" target="_blank" rel="noopener">部分。</a></p>
<h2 id="esmodulesmovingforward">ES模块向前发展</h2>
<p>ES模块不再被标记为实验性的，并且从节点版本15.3.0开始，在技术实现方面是稳定的。这意味着它们现在可以用于生产了。因此，挑战在于包的作者、维护者和开发者明确定义<code>package.json</code>文件中的类型字段和规范中讨论的其他有用的约定。关于这个的更多细节可以在这里找到<a href="https://nodejs.org/api/esm.html#esm_writing_dual_packages_while_avoiding_or_minimizing_hazards" target="_blank" rel="noopener">。</a></p>
<p>如今，在一个应用程序中同时使用CommonJS和ESM是可能的，但是摩擦更少。但是当然，CommonJS模块需要知道正在加载的模块是CommonJS模块还是es模块，因为后者只是异步加载的。</p>
<p>文件的<a href="https://nodejs.org/api/packages.html#packages_dual_commonjs_es_module_packages" target="_blank" rel="noopener">包装章节</a>详细介绍了与双包装危害相关的问题以及避免或减少这些危害的方法。</p>
<p>此外，根据ESM规范，默认情况下，与CommonJS模块一样，使用import关键字并不能完成带有文件扩展名的文件路径。所以这个也要事先明确说明。更多细节可在概述两个模块系统之间差异的章节<a href="https://nodejs.org/docs/latest-v15.x/api/esm.html#esm_differences_between_es_modules_and_commonjs" target="_blank" rel="noopener">中找到。</a></p>
<h2 id="conclusionandnextsteps">结论</h2>
<p>在引入ES6标准之前，在服务器端JavaScript中没有任何组织源代码的本机实现。社区非常依赖CommonJS模块格式。</p>
<p>如今，随着ES模块的引入和API的稳定，开发人员可以享受到与发布规范相关的许多好处。本文强调了这两种模块系统之间的转换及其互操作性。</p><div class="code-block code-block-54">
<hr/>
<h3>更多来自LogRocket的精彩文章:</h3>

<hr/></div>
<p>请注意，本文没有介绍加载器API，因为它们仍然是实验性的，在未来的版本中肯定会有所变化。要了解更多信息，请查看文档的本节。</p>
<p>像<a href="https://babeljs.io/"> Babel </a>和<a href="https://github.com/standard-things/esm#readme"> esm </a>这样的工具，可以将新的语法翻译成与旧环境兼容的代码，这种转换变得更加容易。</p>
<p>从长远来看，整个起草过程是重要的一步，为今后的进一步改进铺平了道路。如果你有任何问题，请在下面的评论区告诉我，或者给我的<a href="https://twitter.com/alex_nnakwue"> Twitter账号</a>发消息。感谢阅读🙂</p><div class="code-block code-block-23">
<div class="blog-plug inline-plug node-plug"><h2>200只<img src="../Images/61167b9d027ca73ed5aaf59a9ec31267.png" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2019/10/green-check.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" class=" jetpack-lazy-image" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/10/green-check.png"/> <noscript> <img data-lazy-fallback="1" src="../Images/61167b9d027ca73ed5aaf59a9ec31267.png" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/10/green-check.png"/> </noscript>显示器出现故障，生产中网络请求缓慢</h2><p>部署基于节点的web应用程序或网站是容易的部分。确保您的节点实例继续为您的应用程序提供资源是事情变得更加困难的地方。如果您对确保对后端或第三方服务的请求成功感兴趣，</p><a href="https://lp.logrocket.com/blg/node-signup" target="_blank">try LogRocket</a><p>. </p><a class="signup" href="https://lp.logrocket.com/blg/node-signup" target="_blank" rel="noopener noreferrer"><img src="../Images/cae72fd2a54c5f02a6398c4867894844.png" alt="LogRocket Network Request Monitoring" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2019/12/network-request-filter-2-1.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" class=" jetpack-lazy-image" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/12/network-request-filter-2-1.png"/><noscript><img data-lazy-fallback="1" src="../Images/cae72fd2a54c5f02a6398c4867894844.png" alt="LogRocket Network Request Monitoring" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/12/network-request-filter-2-1.png"/></noscript></a><a href="https://lp.logrocket.com/blg/node-signup" target="_blank" rel="noopener noreferrer">https://logrocket.com/signup/</a><p>LogRocket 就像是网络和移动应用程序的DVR，记录下用户与你的应用程序交互时发生的一切。您可以汇总并报告有问题的网络请求，以快速了解根本原因，而不是猜测问题发生的原因。</p><p>LogRocket检测您的应用程序以记录基线性能计时，如页面加载时间、到达第一个字节的时间、慢速网络请求，还记录Redux、NgRx和Vuex操作/状态。</p><a class="signup" href="https://lp.logrocket.com/blg/node-signup" target="_blank" rel="noopener noreferrer">Start monitoring for free</a><p>. </p></div>
</div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
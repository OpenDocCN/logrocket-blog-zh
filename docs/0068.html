<html>
<head>
<title>Maximizing Debuggability with Redux - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>使用Redux - LogRocket博客最大化可调试性</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/maximizing-debuggability-with-redux-79b2ad07b64c/#0001-01-01">https://blog.logrocket.com/maximizing-debuggability-with-redux-79b2ad07b64c/#0001-01-01</a></blockquote><div><div class="mainheading">


 
<h1 class="posttitle">使用Redux最大化可调试性</h1>
<h2 class="post-subtitle"/>
<p><span class="post-date"><time class="post-date">2017年5月8日</time> </span> <span class="dot"/> <span class="readingtime"> 2分钟阅读</span> <span class="wordcount"> 574 </span> <span class="logrocket_editor"/></p>
</div>
<article class="article-post">
<figure>
<p><img decoding="async" data-height="734" data-width="1766" src="../Images/7eb40948c35d94f4a1960bac7b1e272a.png" data-lazy-src="https://storage.googleapis.com/blog-images-backup/1*WmXD6cob1lj38L5StDAUfQ.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" class=" jetpack-lazy-image" data-original-src="https://storage.googleapis.com/blog-images-backup/1*WmXD6cob1lj38L5StDAUfQ.png"/></p><noscript><img data-lazy-fallback="1" decoding="async" data-height="734" data-width="1766" src="../Images/7eb40948c35d94f4a1960bac7b1e272a.png" data-original-src="https://storage.googleapis.com/blog-images-backup/1*WmXD6cob1lj38L5StDAUfQ.png"/></noscript><br/>
</figure>
<p>在我的上一篇博客文章<a href="https://blog.logrocket.com/redux-logging-in-production-3b2a4816b713" target="_blank" rel="noopener noreferrer"> Redux登录生产</a>中，我讨论了使用Redux最重要的好处之一——可调试性。通过使用像LogRocket这样的前端日志工具，开发人员可以通过检查导致bug的<code>actions</code>和<code>state</code>变更，轻松理解并修复产品中棘手的bug。</p>
<p>虽然这些信息在任何Redux应用程序中都非常有用，但是通过设计一个考虑到日志的应用程序，我们还可以实现更多。在这篇文章中，我将介绍一些库和抽象，它们通过将尽可能多的应用程序数据放入Redux，使Redux日志<em>更加有用。</em></p>
<h3>数据提取</h3>
<p>通过网络获取/发送数据是任何应用程序中最容易出错的部分之一。连接、意外数据或不正确的逻辑都可能导致问题。轮询、重试逻辑、乐观突变等使事情变得更加复杂。</p>
<p>像GraphQL的<strong> apollo-client </strong>和REST的<strong> redux-query </strong>这样的库都有助于通过redux从网络获取数据。它们使用Redux作为持久层，这意味着在调试问题时，您可以检查您的Redux日志，以查看这些客户端获取了哪些数据以及正在进行的请求的状态。</p>
<p>让我们看看redux-query生成的Redux日志:</p>
<figure>
<p><img decoding="async" data-height="840" data-width="2108" src="../Images/cfd85784ef658620bfa7257829f1cbbe.png" data-lazy-src="https://storage.googleapis.com/blog-images-backup/1*H_xAHVS6vKHer0velgQXnw.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" class=" jetpack-lazy-image" data-original-src="https://storage.googleapis.com/blog-images-backup/1*H_xAHVS6vKHer0velgQXnw.png"/></p><noscript><img data-lazy-fallback="1" decoding="async" data-height="840" data-width="2108" src="../Images/cfd85784ef658620bfa7257829f1cbbe.png" data-original-src="https://storage.googleapis.com/blog-images-backup/1*H_xAHVS6vKHer0velgQXnw.png"/></noscript><br/>
</figure>
<p>这里我们看到了<code>REQUEST_START</code>动作，它对应于一个被初始化的查询。查看action有效负载，我们可以看到请求中的所有信息，这使得调试变得很容易。一旦收到响应，<code>redux-query</code>就会发出一个<code>REQUEST_SUCCESS</code>动作，包含关于响应的所有信息。</p>
<p>记录请求和响应只是<code>redux-query</code>魔力的一部分。深入到<code>store</code>我们看到一个键<code>queries</code>，在那里<code>redux-query</code>保持其内部状态。</p>
<figure>
<p><img decoding="async" data-height="452" data-width="1260" src="../Images/7ff19e4cafcec7e1a224d341dfd99f5c.png" data-lazy-src="https://storage.googleapis.com/blog-images-backup/1*LAQZ7wqFPZRBnh5qOz9hzA.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" class=" jetpack-lazy-image" data-original-src="https://storage.googleapis.com/blog-images-backup/1*LAQZ7wqFPZRBnh5qOz9hzA.png"/></p><noscript><img data-lazy-fallback="1" decoding="async" data-height="452" data-width="1260" src="../Images/7ff19e4cafcec7e1a224d341dfd99f5c.png" data-original-src="https://storage.googleapis.com/blog-images-backup/1*LAQZ7wqFPZRBnh5qOz9hzA.png"/></noscript><br/>
</figure>
<p>上面，我们看到了应用程序执行的每个查询的对象(一个到<code>reddit.com/r/frontend.json</code>，一个到<code>reddit.com/r/reactjs.json</code>)。在调试问题时，我们可以深入这个状态对象，查看正在进行的请求、<code>queryCount</code>(如果我们对查询进行轮询)和计时的信息。</p>
<p>在Redux中存储这些信息非常重要，因为它将所有网络活动的完整上下文放在Redux日志中。</p>
<figure>
<p><a href="https://logrocket.com/signup/" target="_blank" rel="noopener noreferrer"><img decoding="async" data-height="750" data-width="3212" src="../Images/94b3e0f84b30cb0d321f60471481ab64.png" data-lazy-src="https://storage.googleapis.com/blog-images-backup/1*GPjaPKNNUYHU8EsA3Z0JGA.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" class=" jetpack-lazy-image" data-original-src="https://storage.googleapis.com/blog-images-backup/1*GPjaPKNNUYHU8EsA3Z0JGA.png"/><noscript><img data-lazy-fallback="1" decoding="async" data-height="750" data-width="3212" src="../Images/94b3e0f84b30cb0d321f60471481ab64.png" data-original-src="https://storage.googleapis.com/blog-images-backup/1*GPjaPKNNUYHU8EsA3Z0JGA.png"/></noscript></a>T6】</p></figure>
<h4>滚动您自己的数据获取“框架”</h4>
<p>如果您喜欢更简单的方法，您可以通过在查询和从网络接收数据时简单地分派显式操作来构建自己的数据获取“框架”。</p>
<p>例如，假设我们正在构建一个博客应用程序。在查询帖子时，我们会调度<code>POSTS_QUERY_INIT</code>。然后，缩减器可以适当地更新状态，以表明posts查询正在进行中。</p>
<pre>postsQuery: {<br/>  url: 'api.blog.com/posts',<br/>  isPending: true,<br/>  ...<br/>}</pre>
<p>在<code>thunk</code>或<code>saga</code>中，我们会调用<code>fetch</code>，当承诺完成时，我们会发出类似<code>POSTS_QUERY_SUCCESS</code>或<code>POSTS_QUERY_FAILURE</code>的动作。这将相应地将状态更新为:</p>
<pre>postsQuery: {<br/>  url: 'api.blog.com/posts',<br/>  isPending: true,<br/>  data: [...],<br/>}</pre>
<p>这个例子并不全面，但是它的思想是，通过为请求生命周期的每个部分显式地使用Redux操作，可以很容易地调试任何潜在的竞争条件或网络错误。</p>
<h3>TL；速度三角形定位法(dead reckoning)</h3>
<p>使用通过Redux处理数据的库和模式，通过留下丰富的审计线索，有助于构建更多可调试的应用程序。</p>
<p>当设计一个新特性时，问问自己它是否容易出错，以及能够在Redux日志中查看它的状态是否有助于解决未来的bug。</p><div class="code-block code-block-2">
<div class="blog-plug base-cta"><h2>使用<a class="signup" href="https://lp.logrocket.com/blg/signup" target="_blank" rel="noopener noreferrer"> LogRocket </a>消除传统错误报告的干扰</h2>
<a href="https://lp.logrocket.com/blg/signup" class="signup" target="_blank" rel="noopener noreferrer"><img class="alignnone size-full wp-image-46 jetpack-lazy-image" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/><noscript><img data-lazy-fallback="1" class="alignnone size-full wp-image-46" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/></noscript></a>
<p><a href="https://lp.logrocket.com/blg/signup" target="_blank" rel="noopener noreferrer"> LogRocket </a>是一个数字体验分析解决方案，它可以保护您免受数百个假阳性错误警报的影响，只针对几个真正重要的项目。LogRocket会告诉您应用程序中实际影响用户的最具影响力的bug和UX问题。</p>
<p>然后，使用具有深层技术遥测的会话重放来确切地查看用户看到了什么以及是什么导致了问题，就像你在他们身后看一样。</p>
<p>LogRocket自动聚合客户端错误、JS异常、前端性能指标和用户交互。然后LogRocket使用机器学习来告诉你哪些问题正在影响大多数用户，并提供你需要修复它的上下文。</p>
<p>关注重要的bug—<a class="signup" href="https://lp.logrocket.com/blg/signup-issue-free" target="_blank" rel="noopener noreferrer">今天就试试LogRocket】。</a></p></div></div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
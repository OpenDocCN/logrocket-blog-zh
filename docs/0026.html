<html>
<head>
<title>How to use React createRef - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>如何使用React createRef - LogRocket博客</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/react-createref-guide/#0001-01-01">https://blog.logrocket.com/react-createref-guide/#0001-01-01</a></blockquote><div><article class="article-post">
<p><strong> <em>编者按:</em></strong>T5】本指南使用React  <em> <code>createRef</code>最后一次更新是在2022年11月15日，包括了React引用的常见错误和用ref存储变异状态的信息。</em></p>
<p>如果你已经开发web应用足够长的时间，你可能已经使用过JavaScript <a href="https://developer.mozilla.org/en-US/docs/Web/API/Document_Object_Model/Introduction"> DOM </a>库，比如<a href="http://jquery.com/"> jQuery </a>、<a href="https://mootools.net/"> Mootools </a>、<a href="http://prototypejs.org/learn/"> Prototype.js </a>等等。这些库给交互式web应用程序的构建带来了重大转变。有了DOM抽象API，操作web应用程序的内容变得容易多了。</p>
<p>例如，您会发现自己在用jQuery做这样的事情:</p>
<pre class="language-javascript hljs">​​$('#button').on('click', function(evt) {
​​  evt.preventDefault();
​​  var content = $('
​​Random Post Title
​​Random post text.
​​');
​​
​​  $('#element').append(content);
​​});</pre>
<p>如今，像<a href="https://blog.logrocket.com/tag/react/"> React </a>、<a href="https://blog.logrocket.com/tag/angular/"> Angular </a>和<a href="https://blog.logrocket.com/tag/vue/"> Vue.js </a>这样的JavaScript框架通常用于构建现代应用程序。这些框架都是基于组件的架构。虽然您可以通过利用它们的内置功能做很多事情，但有时您需要与实际的DOM进行交互来实现一些本机行为。大多数现代框架都提供API，通过这些API可以访问应用程序的原生DOM表示，React也不例外。</p>
<p>在本教程中，我们将考虑如何在React应用程序中与DOM交互。我们还将看到如何使用React v16.3中引入的<code>React.createRef()</code>特性，以及React更高版本中引入的<code>useRef</code>钩子。要了解React中虚拟DOMs的更多信息，请查看本<a href="https://blog.logrocket.com/what-virtual-dom-react/">指南</a>。</p>
<p><em>向前跳转:</em></p>

<h2 id="react-refs-dom">什么是React refs和DOM？</h2>
<p>React提供了一个称为<a href="https://blog.logrocket.com/complete-guide-react-refs/"> refs </a>的特性，允许从组件访问DOM。您只需将ref附加到应用程序中的一个元素上，就可以从组件中的任何地方访问该元素的DOM。</p>
<p><a href="https://reactjs.org/docs/refs-and-the-dom.html"> React文档</a>将refs称为工具，用于提供对render方法中创建的React元素和DOM节点的直接访问。一般来说，只有当使用<a href="https://blog.logrocket.com/the-beginners-guide-to-mastering-react-props-3f6f01fd7099/">状态和道具</a>的机制无法实现所需的交互时，才应该考虑使用refs。</p>
<p>但是，在一些情况下，使用ref是合适的。其中之一是在与第三方DOM库集成时。此外，深度交互，如处理文本选择或管理媒体回放行为，需要相应元素上的refs。您可以查看我们的<a href="https://blog.logrocket.com/react-reference-guide-refs-dom/#creatingrefs"> React参考指南</a>了解更多信息。</p>
<h2 id="creating-refs-react">在React中创建引用</h2>
<p>在React中创建引用有四种主要方式。以下是不同方法的列表，从最古老的开始:</p>
<ol>
<li>字符串引用(传统方法)</li>
<li>回调参考</li>
<li><code>React.createRef</code>(来自React v16.3)</li>
<li><code>useRef</code>钩子(来自React v16.8)</li>
</ol>
<h3 id="string-refs-react">React中的字符串引用</h3>
<p>在React应用程序中创建引用的传统方式是使用字符串引用。这是最古老的方法，被视为传统方法，已被弃用。字符串引用是通过向所需元素添加一个<code>ref</code>属性并为<code>ref</code>传递一个<code>string</code>名称作为其值来创建的。</p>
<p>这里有一个简单的例子:</p>
<pre class="language-javascript hljs">class MyComponent extends React.Component {

  constructor(props) {
    super(props);
    this.toggleInputCase = this.toggleInputCase.bind(this);
    this.state = { uppercase: false };
  }
  
  toggleInputCase() {
    const isUpper = this.state.uppercase;
    
    // Accessing the ref using this.refs.inputField
    const value = this.refs.inputField.value;
    
    this.refs.inputField.value =
      isUpper
        ? value.toLowerCase()
        : value.toUpperCase();
        
    this.setState({ uppercase: !isUpper });
  }

  render() {
    return (
      &lt;div&gt;
        {/* Creating a string ref named: inputField */}
        &lt;input type="text" ref="inputField" /&gt;
        
        &lt;button type="button" onClick={this.toggleInputCase}&gt;
          Toggle Case
        &lt;/button&gt;
      &lt;/div&gt;
    );
  }
  
}</pre>
<p>这里，我们创建了一个简单的React组件，它呈现一个<code>&lt;input&gt;</code>元素和一个<code>&lt;button&gt;</code>元素，允许我们在大写和小写之间切换输入的大小写。</p>
<p>我们用设置为<code>false</code>的<code>uppercase</code>属性来初始化组件的状态。这个属性允许我们确定输入的当前大小写。</p>
<p>重点是我们在<code>&lt;input&gt;</code>元素上创建的字符串ref。我们还制作了一个名为<code>inputField</code>的<code>&lt;input&gt;</code>参考。后来，在<code>&lt;button&gt;</code>的<a href="https://blog.logrocket.com/react-onclick-event-handlers-guide/"> <code>onClick</code>事件处理程序</a>中，我们通过<code>this.refs.inputField</code>访问ref。然后，我们操纵<code>&lt;input&gt;</code>的DOM来改变输入的值。</p>
<p>下面是一个交互的示例演示:</p>
<p><img data-attachment-id="144334" data-permalink="https://blog.logrocket.com/react-createref-guide/attachment/react-ref-input-example/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/12/React-ref-input-example.png" data-orig-size="730,411" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="React string ref example" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/12/React-ref-input-example-300x169.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/12/React-ref-input-example.png" decoding="async" class="aligncenter size-full wp-image-144334 jetpack-lazy-image" src="../Images/42d40f59100860e39c8a295580c47edc.png" alt="React String Ref Example" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2020/12/React-ref-input-example.png 730w, https://blog.logrocket.com/wp-content/uploads/2020/12/React-ref-input-example-300x169.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2020/12/React-ref-input-example.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/12/React-ref-input-example.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="144334" data-permalink="https://blog.logrocket.com/react-createref-guide/attachment/react-ref-input-example/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/12/React-ref-input-example.png" data-orig-size="730,411" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="React string ref example" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/12/React-ref-input-example-300x169.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/12/React-ref-input-example.png" decoding="async" loading="lazy" class="aligncenter size-full wp-image-144334" src="../Images/42d40f59100860e39c8a295580c47edc.png" alt="React String Ref Example" srcset="https://blog.logrocket.com/wp-content/uploads/2020/12/React-ref-input-example.png 730w, https://blog.logrocket.com/wp-content/uploads/2020/12/React-ref-input-example-300x169.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/12/React-ref-input-example.png"/></noscript>
<p>尽管这是一个如何使用refs的简单示例，但它向我们展示了如何在React组件中使用字符串refs。如前所述，不鼓励在React应用程序中使用字符串引用。</p>
<h3 id="using-callback-refs-react">在React中使用回调引用</h3>
<p>回调引用使用回调函数来创建引用，而不是将引用的名称作为字符串传递。如果您使用的是早于v16.3 的<a href="https://reactjs.org/docs/refs-and-the-dom.html#callback-refs"> React版本，这应该是您创建引用的首选方法。</a></p>
<p>回调函数接收<code>React Component</code>实例或<code>HTML DOM</code>元素作为其参数，可以在其他地方存储和访问。使用回调<code>ref</code>，我们之前的代码片段将变成如下:</p>
<pre class="language-javascript hljs">class MyComponent extends React.Component {

  constructor(props) {
    super(props);
    this.toggleInputCase = this.toggleInputCase.bind(this);
    this.state = { uppercase: false };
  }
  
  toggleInputCase() {
    const isUpper = this.state.uppercase;
    
    // Accessing the ref using this.inputField
    const value = this.inputField.value;
    
    this.inputField.value =
      isUpper
        ? value.toLowerCase()
        : value.toUpperCase();
        
    this.setState({ uppercase: !isUpper });
  }

  render() {
    return (
      &lt;div&gt;
        {/* Creating a callback ref and storing it in this.inputField */}
        &lt;input type="text" ref={elem =&gt; this.inputField = elem} /&gt;
        
        &lt;button type="button" onClick={this.toggleInputCase}&gt;
          Toggle Case
        &lt;/button&gt;
      &lt;/div&gt;
    );
  }
  
}</pre>
<p>在这方面，我们做了两项重大改变。首先，我们使用回调函数定义了<code>ref</code>，并将其存储在<code>this.inputField</code>中，如下所示:</p>
<pre class="language-javascript hljs">&lt;input type="text" ref={elem =&gt; this.inputField = elem} /&gt;</pre>
<p>然后，在事件处理程序中，我们使用<code>this.inputField</code>而不是<code>this.refs.inputField</code>来访问<code>ref</code>。</p>
<p>当使用内联回调函数<code>refs</code>时，正如我们在例子中所做的，重要的是要知道对于组件的每次更新，回调函数被调用两次——第一次使用<code>null</code>,然后再次使用<code>DOM</code>元素。</p>
<p>然而，创建回调函数作为组件类的<code>bound</code>方法可以用来避免这种行为。使用回调函数创建引用可以让您更好地控制如何创建、设置和取消设置引用。</p>
<h2 id="examples-react-create-ref">使用<code>React.createRef()</code>的例子</h2>
<p>从React v16.3开始，<a href="https://blog.logrocket.com/modern-api-data-fetching-methods-react/"> React API </a>包含了一个<code>createRef()</code>方法，它可以用来创建引用，就像我们使用回调函数一样。只需通过调用<code>React.createRef()</code>创建一个引用，并将结果<code>ref</code>分配给一个元素。</p>
<p>使用<code>React.createRef()</code>，我们之前的例子现在看起来像这样:</p>
<pre class="language-javascript hljs">class MyComponent extends React.Component {

  constructor(props) {
    super(props);
    this.inputField = React.createRef();
    this.toggleInputCase = this.toggleInputCase.bind(this);
    this.state = { uppercase: false };
  }
  
  toggleInputCase() {
    const isUpper = this.state.uppercase;
    
    // Accessing the ref using this.inputField.current
    const value = this.inputField.current.value;
    
    this.inputField.current.value =
      isUpper
        ? value.toLowerCase()
        : value.toUpperCase();
        
    this.setState({ uppercase: !isUpper });
  }

  render() {
    return (
      &lt;div&gt;
        {/* Referencing the ref from this.inputField */}
        &lt;input type="text" ref={this.inputField} /&gt;
        
        &lt;button type="button" onClick={this.toggleInputCase}&gt;
          Toggle Case
        &lt;/button&gt;
      &lt;/div&gt;
    );
  }
  
}</pre>
<p>在这里，我们看到了一些变化。首先，在<code>constructor()</code>中，我们使用<code>React.createRef()</code>创建了一个<code>ref</code>，并将其存储在<code>this.inputField</code>中，如下所示:</p>
<pre class="language-javascript hljs">this.inputField = React.createRef();</pre>
<p>接下来，在事件处理程序中，我们使用<code>this.inputField.current</code>而不是<code>this.inputField</code>来访问<code>ref</code>。这对于用<code>React.createRef()</code>创建的refs来说是值得注意的。在ref的<code>current</code>属性中可以访问对节点的引用。</p>
<p>最后，我们将<code>ref</code>传递给<code>&lt;input&gt;</code>组件，如下所示:</p>
<pre class="language-javascript hljs">&lt;input type="text" ref={this.inputField} /&gt;</pre>
<p>我们已经探索了在React应用程序中创建refs的各种方法。在接下来的几节中，我们将进一步了解<code>React.createRef</code>更有趣的特征。</p>
<h3 id="working-react-hook">使用React <code>useRef</code>钩子</h3>
<p>随着React v16的发布，<a href="https://blog.logrocket.com/react-reference-guide-hooks-api/"> Hooks API </a>已经成为React应用程序中抽象和重用代码的事实手段。一个这样的钩子是<a href="https://blog.logrocket.com/usestate-vs-useref/"> <code>useRef</code> </a>，它允许我们在<a href="https://blog.logrocket.com/fundamentals-functional-programming-react/">功能组件</a>中创建和使用引用。</p>
<p>值得注意的是，即使使用了<code>useRef</code>钩子，默认情况下，您仍然不能在函数组件上使用ref属性，因为我们不能创建函数的实例。我们将在本文后面讨论如何通过<a href="https://blog.logrocket.com/cleaning-up-the-dom-with-forwardref-in-react/"> ref转发</a>来解决这个问题。</p>
<p>要使用<code>useRef</code>钩子，你将<code>ref.current</code>应该引用的对象传入<code>useRef</code>钩子并调用它。这个钩子调用应该返回一个<code>ref</code>对象，您可以像使用前面讨论的<code>createRef</code>方法一样使用它。</p>
<p>如果我们使用<code>useRef</code>钩子，我们之前的例子应该是这样的:</p>
<pre class="language-javascript hljs">const MyComponent = () =&gt; {
    const [uppercase, setUppercase] = React.useState(false)
    const inputField = React.useRef(null)
    const toggleInputCase = () =&gt; {
        // Accessing the ref using inputField.current
        const value = inputField.current.value;
        inputField.current.value = uppercase ? value.toLowerCase() : value.toUpperCase();
        setUppercase(previousValue =&gt; !previousValue)
    }

    return(
       &lt;div&gt;
           {/* Referencing the ref from this.inputField */}
           &lt;input type="text" ref={inputField} /&gt;
           &lt;button type="button" onClick={toggleInputCase}&gt;
                Toggle Case  
           &lt;/button&gt;
       &lt;/div&gt;</pre>
<p>如您所见，代码与<code>React.createRef</code>实现非常相似。我们使用<code>useRef</code>钩子创建一个<code>ref</code>，并将这个<code>ref</code>传递给<code>&lt;input&gt;</code>的ref属性。</p>
<p><code>&lt;button&gt;</code>的事件处理程序的流程与之前相同。我们根据状态变量<code>uppercase</code>的当前值，更新我们的<code>ref</code>所指向的HTML元素的<code>value</code>属性(可以使用<code>ref.current</code>来访问它)。</p>
<h2 id="building-component-refs-react">React中的建筑构件参照</h2>
<p>在上一节中，我们看到了如何使用<code>React.createRef</code> API创建引用。实际的引用存储在<code>ref</code>的<code>current</code>属性中。</p>
<p>在我们的示例中，我们只在React应用程序中创建了对DOM节点的引用。但是也可以创建refs来反应组件，这将使我们能够访问这些组件的<code>instance</code>方法。</p>
<p>请记住，我们只能在<code>class</code>组件上创建引用，因为它们在挂载时会创建该类的<code>instance</code>。不能在功能元件上使用参照。</p>
<p>让我们考虑一个在React组件上使用refs的非常简单的例子。在本例中，我们将创建两个组件:</p>
<ul>
<li><code>FormInput</code>:这个组件将包装一个<code>&lt;input&gt;</code>元素，并提供一个方法来知道输入何时包含一些值，以及一个方法来选择输入文本</li>
<li><code>MyComponent</code>:当<strong>选中</strong>时，包装<code>FormInput</code>组件和一个按钮来选择输入中的文本</li>
</ul>
<p>以下是组件的代码片段:</p>
<pre class="language-javascript hljs">class FormInput extends React.Component {

  constructor(props) {
    super(props);
    this.textInput = React.createRef();
  }
  
  hasText() {
    return this.textInput.current.value.length &gt; 0;
  }
  
  selectInputText() {
    this.textInput.current.select();
  }
  
  render() {
    return (</pre>
<p>像以前一样，我们使用<code>React.createRef()</code>创建了一个<code>ref</code>，并将<code>ref</code>添加到了<code>render</code>函数中的<code>&lt;input&gt;</code>元素中。我们创造了两种方法:</p>
<ul>
<li><code>hasText()</code>:返回一个<code>Boolean</code>，表示<code>input</code>元素的值不为空。因此，它在为空时返回<code>false</code>。否则，它返回<code>true</code></li>
<li><code>selectInputText()</code>:选择<code>input</code>中的整个文本</li>
</ul>
<p>注意，通过访问我们创建的<code>ref</code>:<code>this.textInput.current</code>的<code>current</code>属性，我们在方法中获得了对<code>input</code>的引用。</p>
<p>现在，让我们创建<code>MyComponent</code>。以下是代码片段:</p>
<pre class="language-javascript hljs">const MyComponent = (props) =&gt; {

  const formInput = React.createRef();
  
  const inputSelection = () =&gt; {
    const input = formInput.current;
    
    if (input.hasText()) {
      input.selectInputText();
    }
  };
  
  return (
    &lt;div&gt;
      &lt;button type="button" onClick={inputSelection}&gt;
        Select Input
      &lt;/button&gt;
      
      &lt;FormInput ref={formInput} /&gt;
    &lt;/div&gt;
  );
  
};</pre>
<p>在这个代码片段中，我使用了一个函数组件而不是类组件，因为这是一个无状态组件。我还想用这个组件来演示如何在函数组件中使用refs。</p>
<p>这里，我们使用<code>React.createRef()</code>创建一个<code>ref</code>，并将其存储在<code>formInput</code>常量中。注意，我们没有使用<code>this</code>，因为功能组件不是类，也不创建实例。</p><div class="code-block code-block-54">
<hr/>
<h3>更多来自LogRocket的精彩文章:</h3>

<hr/></div>
<p>注意，在<code>render()</code>方法中，我们将自己创建的<code>ref</code>添加到了之前制作的<code>&lt;FormInput&gt;</code>组件中。与前面向DOM节点添加引用的例子不同，在这里，我们向组件添加一个引用。</p>
<p>此外，只能为类组件而不是功能组件创建引用。<code>FormInput</code>是一个类组件，所以我们可以创建对它的引用。然而，我们可以在功能组件中使用ref，就像我们在这个例子中使用<code>formInput</code>一样。</p>
<p>最后，在<code>inputSelection()</code>函数中，我们像以前一样使用<code>ref</code>的<code>current</code>属性访问对组件的引用。</p>
<p>我们可以访问<code>FormInput</code>组件的<code>hasText()</code>和<code>selectInputText()</code>方法，因为引用指向了<code>FormInput</code>组件的一个实例。这验证了为什么不能为功能元件创建参照。</p>
<p>这是一个交互的示例演示:</p>
<p><img data-attachment-id="144337" data-permalink="https://blog.logrocket.com/react-createref-guide/attachment/react-create-ref-current/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/12/react-create-ref-current.gif" data-orig-size="730,411" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="React createRef form component example" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/12/react-create-ref-current-300x169.gif" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/12/react-create-ref-current.gif" decoding="async" class="aligncenter size-full wp-image-144337 jetpack-lazy-image" src="../Images/4d8ce520c273c05e040877705b6f2287.png" alt="React createRef Form Component Example" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2020/12/react-create-ref-current.gif?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/12/react-create-ref-current.gif"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="144337" data-permalink="https://blog.logrocket.com/react-createref-guide/attachment/react-create-ref-current/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/12/react-create-ref-current.gif" data-orig-size="730,411" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="React createRef form component example" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/12/react-create-ref-current-300x169.gif" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/12/react-create-ref-current.gif" decoding="async" loading="lazy" class="aligncenter size-full wp-image-144337" src="../Images/4d8ce520c273c05e040877705b6f2287.png" alt="React createRef Form Component Example" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/12/react-create-ref-current.gif"/></noscript>
<h2 id="refs-controlled-uncontrolled">受控和非受控元件中的参考</h2>
<p>React中的所有组件在默认情况下都是受控的，因为React负责在表单数据更改时处理组件的更新。</p>
<p>在React中处理不受控制的组件时，引用非常方便。这是因为当表单数据改变时，您不使用事件处理程序来更新<code>state</code>,而是依靠refs从DOM中获取表单值。你可以在这里了解更多关于<a href="https://blog.logrocket.com/controlled-vs-uncontrolled-components-in-react/">非受控组件的信息。</a></p>
<h3 id="controlled-components">受控组件</h3>
<p>让我们先创建一个简单的受控组件，然后创建一个非受控组件，来演示如何使用refs从DOM中获取表单值:</p>
<pre class="language-javascript hljs">class ControlledFormInput extends React.Component {
  constructor(props) {
    super(props);
    this.handleChange = this.handleChange.bind(this);
    this.state = { value: "Glad" };
  }
    
  handleChange(evt) {
    this.setState({ value: evt.target.value });
  }
  
  render() {
    return (
      &lt;div&gt;
        &lt;h1&gt;Hello {this.state.value}!&lt;/h1&gt;
        &lt;input type="text" value={this.state.value} onChange={this.handleChange} placeholder="Enter your name" /&gt;
      &lt;/div&gt;
    )
  }
}</pre>
<p>上面的代码片段显示了一个包含<code>&lt;input&gt;</code>元素的受控组件。注意，<code>&lt;input&gt;</code>的值来自州的<code>value</code>属性。我们将状态上的<code>value</code>初始化为<code>"Glad"</code>(这是我的名字)。</p>
<p>另外，请注意，我们使用了<code>handleChange()</code>事件处理程序，用从访问<code>evt.target.value</code>中获得的<code>input</code>元素的值来更新<code>state</code>中的<code>value</code>属性。</p>
<p>这是一个交互的示例演示:</p>
<p><img data-attachment-id="144340" data-permalink="https://blog.logrocket.com/react-createref-guide/attachment/react-create-ref-target-value/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/12/react-create-ref-target-value.png" data-orig-size="730,411" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="React createRef target value example" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/12/react-create-ref-target-value-300x169.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/12/react-create-ref-target-value.png" decoding="async" class="aligncenter size-full wp-image-144340 jetpack-lazy-image" src="../Images/66c5cb1e7996f817f38c87fccc2e287f.png" alt="React createRef Target Value Example" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2020/12/react-create-ref-target-value.png 730w, https://blog.logrocket.com/wp-content/uploads/2020/12/react-create-ref-target-value-300x169.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2020/12/react-create-ref-target-value.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/12/react-create-ref-target-value.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="144340" data-permalink="https://blog.logrocket.com/react-createref-guide/attachment/react-create-ref-target-value/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/12/react-create-ref-target-value.png" data-orig-size="730,411" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="React createRef target value example" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/12/react-create-ref-target-value-300x169.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/12/react-create-ref-target-value.png" decoding="async" loading="lazy" class="aligncenter size-full wp-image-144340" src="../Images/66c5cb1e7996f817f38c87fccc2e287f.png" alt="React createRef Target Value Example" srcset="https://blog.logrocket.com/wp-content/uploads/2020/12/react-create-ref-target-value.png 730w, https://blog.logrocket.com/wp-content/uploads/2020/12/react-create-ref-target-value-300x169.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/12/react-create-ref-target-value.png"/></noscript>
<h3 id="uncontrolled-components">非受控元件中的参考</h3>
<p>以下是组件的非受控版本:</p>
<pre class="language-javascript hljs">class UncontrolledFormInput extends React.Component {
  constructor(props) {
    super(props);
    this.inputField = React.createRef();
    this.handleChange = this.handleChange.bind(this);
    this.state = { value: "Glad" };
  }

  handleChange(evt) {
    this.setState({ value: this.inputField.current.value });
  }

  render() {
    return (
      &lt;div&gt;
        &lt;h1&gt;Hello {this.state.value}!&lt;/h1&gt;
        {/* Attach the created ref: this.inputField */}
        &lt;input type="text" ref={this.inputField} defaultValue={this.state.value} onChange={this.handleChange} placeholder="Enter your name" /&gt;
      &lt;/div&gt;
    )
  }
}</pre>
<p>我们对之前组件的非受控版本做了一些更改。首先，我们使用<code>React.createRef()</code>创建一个<code>ref</code>，并将其存储在<code>this.inputField</code>实例属性中。我们还在<code>render()</code>方法中将<code>ref</code>附加到<code>&lt;input&gt;</code>。</p>
<p>我们还使用<code>defaultValue</code>属性将<code>this.state.value</code>指定为<code>&lt;input&gt;</code>元素的默认值——这只在输入值第一次改变之前有用。</p>
<p>如果我们使用了<code>value</code>属性为<code>input</code>指定一个默认值，我们将不再从<code>input</code>获得更新的值。这是因为<code>value</code> prop会自动覆盖React中DOM中的值。</p>
<p>最后，在我们的事件处理程序中，我们使用<code>ref</code>而不是事件对象来访问<code>input</code>元素的值:</p>
<pre class="language-javascript hljs">this.setState({ value: this.inputField.current.value });

Instead of doing this:

this.setState({ value: evt.target.value });</pre>
<p>演示与受控版本相同。这是一个交互的示例演示:</p>
<p><img data-attachment-id="144342" data-permalink="https://blog.logrocket.com/react-createref-guide/attachment/react-create-ref-uncontrolled-component-demo/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/12/react-create-ref-uncontrolled-component-demo.gif" data-orig-size="730,411" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="React createRef uncontrolled component demo" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/12/react-create-ref-uncontrolled-component-demo-300x169.gif" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/12/react-create-ref-uncontrolled-component-demo.gif" decoding="async" class="aligncenter size-full wp-image-144342 jetpack-lazy-image" src="../Images/89873e145b8471ab9f0d9dc0bc1316bb.png" alt="React createRef Uncontrolled Component Demo" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2020/12/react-create-ref-uncontrolled-component-demo.gif?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/12/react-create-ref-uncontrolled-component-demo.gif"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="144342" data-permalink="https://blog.logrocket.com/react-createref-guide/attachment/react-create-ref-uncontrolled-component-demo/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/12/react-create-ref-uncontrolled-component-demo.gif" data-orig-size="730,411" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="React createRef uncontrolled component demo" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/12/react-create-ref-uncontrolled-component-demo-300x169.gif" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/12/react-create-ref-uncontrolled-component-demo.gif" decoding="async" loading="lazy" class="aligncenter size-full wp-image-144342" src="../Images/89873e145b8471ab9f0d9dc0bc1316bb.png" alt="React createRef Uncontrolled Component Demo" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/12/react-create-ref-uncontrolled-component-demo.gif"/></noscript>
<h2 id="ref-forwarding-react">反应中的参考转发</h2>
<p>通常，React组件不能访问其子组件中使用的引用。虽然根据<a href="https://reactjs.org/docs/forwarding-refs.html"> React文档</a>的说法，这很好，因为它防止了组件依赖于彼此的引用，但是在某些情况下，您可能需要访问子组件的DOM元素。</p>
<p>例如，假设您有一个在整个React应用程序中使用的自定义文本字段组件。在大多数情况下，这个文本字段组件将呈现一个带有一些定制的标准HTML <code>&lt;input&gt;</code>文本字段，很可能是通过props:</p>
<pre class="language-javascript hljs">const TextField = ({placeholder}) =&gt; {
return (
&lt;input type: "text" placeholder={placeholder}. /&gt;
);
}</pre>
<p>如果我们想直接访问<code>TextField</code>的父组件中的<code>input</code>元素来执行一些功能，比如选择文本，默认情况下没有办法这样做。然而，我们可以采用两种方法来实现这一点。</p>
<p>第一种方法是将<code>TextField</code>转换成一个类组件，并在指向<code>&lt;input&gt;</code>的<code>TextField</code>组件中创建一个<code>ref</code>。因为<code>TextField</code>是一个类组件，我们可以从父组件访问它的方法。我们现在可以在<code>TextField</code>中创建一个方法来选择(突出显示)<code>&lt;input&gt;'s</code>文本。</p>
<p>我们的第二个选择是在父组件中创建<code>ref</code>对象，并将<code>ref</code>转发到<code>TextField</code>的<code>&lt;input&gt;</code>元素。这叫做<a href="https://blog.logrocket.com/cleaning-up-the-dom-with-forwardref-in-react/"> ref转发</a>。</p>
<p>引用转发允许我们在父组件中创建一个<code>ref</code>,并将该<code>ref</code>转发给其子组件。这允许我们在DOM级别上与这些子组件中的HTML元素进行交互。</p>
<p>下面是我们如何使用引用转发来实现我们的目标:</p>
<pre class="language-javascript hljs">const Parent = () =&gt; {
    const inputRef = React.useRef(null);
    const selectInputText = (e) =&gt; {
        inputRef.current.select()
    }
    return (
        &lt;div&gt;
            &lt;TextField ref = {inputRef} placeholder="I am a text field!"/&gt;
            &lt;button onClick={selectInputText}&gt;Select Text&lt;/button&gt;
        &lt;/div&gt;
    );
}</pre>
<p>如您所见，我们在<code>Parent</code>中创建了一个ref对象，并将其传递给了<code>TextField</code>组件。在<code>TextField</code>组件中，我们使用了<code>forwardRef</code>函数，它接收一个功能组件作为参数，并将ref作为第二个参数传递给它。</p>
<p>然后，我们将这个<code>ref</code>传递给我们的<code>&lt;input&gt;</code>元素的ref属性。在<code>Parent</code>中创建的<code>ref</code>现在引用了这个<code>&lt;input&gt;</code>元素，并可以与之交互。</p>
<p>请注意，即使我们可以将引用传递给一个功能组件，这个引用也不能用于访问该功能组件本地的函数和变量。</p>
<p>最后，引用也可以转发给类组件，如下所示:</p>
<pre class="language-javascript hljs">const ComponentB = React.forwardRef(({ placeholder }, ref) =&gt; {
    return (
         
    );
}
)</pre>
<h2 id="common-errors-react-refs">React引用的常见错误</h2>
<p>在React中使用refs时，您可能会遇到问题— <code>"TypeError: Cannot read properties of undefined"</code>。当您试图在赋值之前访问<code>ref</code>对象的<code>.current</code>属性时，会发生此错误。</p>
<h3 id="refs-return-undefined-null">Refs返回未定义或null</h3>
<p>我们用一个例子来理解这个。看看下面的代码片段:</p>
<pre class="language-javascript hljs">import { useEffect, useRef } from "react";

const App = () =&gt; {
  const inputRef = useRef();

  useEffect(() =&gt; {
    inputRef.current.focus();
  }, []);

  return (
    &lt;div&gt;
      &lt;h1&gt;Hello World!&lt;/h1&gt;
      &lt;input ref={inputRef} /&gt;
    &lt;/div&gt;
  );
}

export default App;</pre>
<p>这里，我们有一个引用输入字段的<code>ref</code>对象。一旦呈现了<code>App</code>组件，输入字段就会被聚焦。</p>
<p>让我们考虑当页面加载时输入字段应该是隐藏的，只有当点击页面上的<strong>按钮</strong>时才出现。简单吧？您可以使用一个状态变量来控制<code>input</code>的可见性:</p>
<pre class="language-javascript hljs">import { useEffect, useRef, useState } from "react";

const App = () =&gt; {
  const inputRef = useRef();
  const [isHidden, setHidden] = useState(true);

  useEffect(() =&gt; {
    inputRef.current.focus();
  }, []);

  return (
    &lt;div&gt;
      &lt;h1&gt;Hello World!&lt;/h1&gt;
      {!isHidden &amp;&amp; &lt;input ref={inputRef} /&gt;}
      &lt;button onClick={() =&gt; setHidden((isHidden) =&gt; !isHidden)}&gt;
        {isHidden ? "Show Input" : "Hide Input"}
      &lt;/button&gt;
    &lt;/div&gt;
  );
};</pre>
<p>但是，当您检查上述代码的输出时，您会注意到一个错误屏幕:</p>
<p><img data-attachment-id="144344" data-permalink="https://blog.logrocket.com/react-createref-guide/attachment/react-create-ref-error/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/12/react-create-ref-error.png" data-orig-size="730,488" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="React createRef error message" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/12/react-create-ref-error-300x201.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/12/react-create-ref-error.png" decoding="async" class="aligncenter size-full wp-image-144344 jetpack-lazy-image" src="../Images/4ec958eb712d77d8c0fc2d428f74ba70.png" alt="React createRef Error Message" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2020/12/react-create-ref-error.png 730w, https://blog.logrocket.com/wp-content/uploads/2020/12/react-create-ref-error-300x201.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2020/12/react-create-ref-error.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/12/react-create-ref-error.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="144344" data-permalink="https://blog.logrocket.com/react-createref-guide/attachment/react-create-ref-error/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/12/react-create-ref-error.png" data-orig-size="730,488" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="React createRef error message" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/12/react-create-ref-error-300x201.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/12/react-create-ref-error.png" decoding="async" loading="lazy" class="aligncenter size-full wp-image-144344" src="../Images/4ec958eb712d77d8c0fc2d428f74ba70.png" alt="React createRef Error Message" srcset="https://blog.logrocket.com/wp-content/uploads/2020/12/react-create-ref-error.png 730w, https://blog.logrocket.com/wp-content/uploads/2020/12/react-create-ref-error-300x201.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/12/react-create-ref-error.png"/></noscript>
<p>这是因为在React呈现输入的<code>DOM</code>元素之前，<code>ref</code>对象没有任何值，并且由于<code>ref</code>的默认值是未定义的，所以会出现错误<code>"Cannot read property of undefined"</code>。</p>
<p>如果将<code>null</code>作为初始值传递，错误将是<code>"Cannot read property of null"</code>。这两个错误意味着相同的事情:当您读取<code>.current</code>属性时，<code>ref</code>对象没有任何值。</p>
<p>要解决这个问题，您可以在<code>useEffect</code>回调中使用<code>isHidden</code>状态，并且在<code>isHidden</code>状态为<code>false</code>时只关注输入字段:</p>
<pre class="language-javascript hljs">...

useEffect(() =&gt; {
  if(!isHidden) inputRef.current.focus();
}, [isHidden]);

...
</pre>
<h2 id="storing-mutating-state-react-ref">用React ref存储变异状态</h2>
<p>除了直接访问DOM元素，refs还可以有可变的值。ref对象是可变的，这意味着您可以通过给<code>.current</code>属性赋值来更新它的值。但是它和状态变量有什么不同呢？</p>
<ul>
<li>ref值在组件重新呈现时保持不变</li>
<li>与状态变量不同，如果ref值改变，它不会触发组件重新呈现</li>
</ul>
<p>看看下面的例子:</p>
<pre class="language-javascript hljs">import { useEffect, useRef, useState } from "react";

const App = () =&gt; {
  const inputRef = useRef();
  const [isHidden, setHidden] = useState(true);
  const buttonClicks = useRef(0);

  useEffect(() =&gt; {
    if(!isHidden) inputRef.current.focus();
  }, [isHidden]);

  const handleToggle = () =&gt; {
    buttonClicks.current++;
    setHidden((isHidden) =&gt; !isHidden);
  };

  return (
    &lt;div&gt;
      &lt;h1&gt;Hello World!&lt;/h1&gt;
      {!isHidden &amp;&amp; &lt;input ref={inputRef} /&gt;}
      &lt;button onClick={handleToggle}&gt;
        {isHidden ? "Show Input" : "Hide Input"}
      &lt;/button&gt;
      &lt;button onClick={() =&gt; alert(`button clicks: ${buttonClicks.current}`)}&gt;
        Alert Button Clicks
      &lt;/button&gt;
    &lt;/div&gt;
  );
};</pre>
<p>这里，<code>ref</code>用于跟踪按钮点击。当<code>buttonClick</code> ref的值改变时，不会触发重新渲染。因此，它提高了组件的可用性和性能。避免不必要的重新渲染对于优化UI的性能来说是微不足道的。</p>
<p>您可以使用ref来存储UI上不需要的值。这里需要注意的重要一点是，由于引用不会触发重新渲染，所以您不应该在组件的JSX中使用它的值，因为它是不可预测的，会导致错误。如果您希望基于数据在JSX中显示或拥有一些逻辑，那么最好使用状态变量。</p>
<h2>结论</h2>
<p>在本教程中，我们考虑了在React应用程序中与DOM交互的各种方法。我们还看到了如何在React中使用<code>React.createRef()</code>方法和<code>useRef</code>钩子来简化创建refs。</p>
<p>您现在也知道了我们如何在不受控制的组件中使用refs。您可以参考React文档来了解更多关于如何使用refs的信息。</p>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
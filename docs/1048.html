<html>
<head>
<title>Scheduling tasks in Node.js using node-cron - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>使用node-cron - LogRocket Blog在Node.js中调度任务</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/task-scheduling-or-cron-jobs-in-node-using-node-cron/#0001-01-01">https://blog.logrocket.com/task-scheduling-or-cron-jobs-in-node-using-node-cron/#0001-01-01</a></blockquote><div><article class="article-post">
<p>没有一个开发者愿意把所有的时间都花在系统维护和管理、日常数据库备份、定期下载文件和邮件等繁琐的任务上。你更愿意专注于富有成效的任务，而不是跟踪这些烦人的杂务何时需要完成。当然，你更愿意在床上睡觉，而不是在某个不吉利的时间起床，睡眼惺忪地盯着显示器，运行那些在服务器资源消耗率较低时执行效果最好的任务。</p>
<p>这就是任务调度发挥作用的地方。</p>
<p>任务调度使您能够调度任意代码(方法/函数)和命令在固定的日期和时间、重复的时间间隔或指定的时间间隔后执行。在Linux操作系统中，任务调度通常由操作系统级的cron等实用服务来处理。对于Node.js应用程序，类似cron的功能是使用诸如<a href="https://github.com/kelektiv/node-cron" target="_blank" rel="noopener noreferrer"> node-cron </a>之类的包实现的，它自称是“NodeJs纯JavaScript中的微型任务调度程序”</p>
<p>cron的动作由一个<a href="https://www.gnu.org/software/mcron/manual/html_node/Crontab-file.html" target="_blank" rel="noopener noreferrer"> crontab </a> (cron表)文件驱动，这个文件是一个包含cron守护进程指令的配置文件。node-cron模块允许您使用完整的crontab语法在node中调度任务。</p>
<p>crontab语法如下所示:</p>
<pre> # ┌────────────── second (optional)
 # │ ┌──────────── minute
 # │ │ ┌────────── hour
 # │ │ │ ┌──────── day of month
 # │ │ │ │ ┌────── month
 # │ │ │ │ │ ┌──── day of week
 # │ │ │ │ │ │
 # │ │ │ │ │ │
 # * * * * * *
</pre>
<p>允许的cron值包括以下内容。</p>
<table>
<tbody>
<tr>
<td><strong>字段</strong></td>
<td><strong>值</strong></td>
</tr>
<tr>
<td><code>second</code></td>
<td>0–59</td>
</tr>
<tr>
<td><code>minute</code></td>
<td>0–59</td>
</tr>
<tr>
<td><code>hour</code></td>
<td>0–23</td>
</tr>
<tr>
<td><code>day of the month</code></td>
<td>1–31</td>
</tr>
<tr>
<td><code>month</code></td>
<td>1–12(或姓名)</td>
</tr>
<tr>
<td><code>day of the week</code></td>
<td>0–7(或名称，0或7是星期日)</td>
</tr>
</tbody>
</table>
<pre/>
<h2 id="usingnodecron">使用节点克隆</h2>
<p>使用npm安装node-cron。</p>
<pre>npm install --save node-cron
</pre>
<h3>任务调度语法</h3>
<pre>cron.schedule(cronExpression: string, task: Function, options: Object)
</pre>
<h3>选择</h3>
<ul>
<li><code>scheduled</code>:一个<code>boolean</code>，用于设置创建的任务是否被调度(默认为<code>true</code>)</li>
<li><code>timezone</code>:用于作业调度的时区</li>
</ul>
<p>看看下面的例子。</p>
<pre>import * as cron from 'node-cron'
cron.schedule('5 * * * * *', () =&gt; {
  console.log('running a task every minute at the 5th second');
});
</pre>
<p>时间规范的位置、二、三、四、五和六中的星号(<code>*</code>)类似于文件组或通配符，用于时间划分；它们分别指定“每分钟”、“每小时”、“每月的每一天”、“一周的每一天”。</p>
<p>下面的代码将在每天早上5:03(35)运行。</p>
<pre>import * as cron from 'node-cron'
cron.schedule('3 5 * * *', () =&gt; {
  console.log('running a task every day at 5:03 am');
});
</pre>
<h2>任务计划提示和技巧</h2>
<p>既然我们已经了解了基础知识，让我们做一些更有趣的事情。</p>
<p>假设您想在每周五下午4点运行一个特定的任务，代码如下所示:</p>
<pre>import * as cron from 'node-cron'
cron.schedule('0 16 * * friday', () =&gt; {
  console.log('running a task every Friday at 4:00 pm');
});
</pre>
<p>或者您可能需要运行季度数据库备份。crontab语法没有“一个月的最后一天”的选项，所以您可以使用下个月的第一天，如下所示。</p>
<pre>import * as cron from 'node-cron'
cron.schedule('2 3 1 1,4,7,10 *', () =&gt; {
  console.log('running a task every quater on the first day of the month');
});
</pre>
<p>以下显示了在上午10:05到下午6:05之间每小时运行5分钟的任务</p>
<pre>import * as cron from 'node-cron'
cron.schedule('5 10-18 * * *', () =&gt; {
  console.log('running a task five minutes past every hour between 10am and 6pm');
});
</pre>
<p>有些情况下，您可能需要每两小时、三小时或四小时运行一次任务。您可以通过按所需的时间间隔来划分时间，比如每四个小时运行一次<code>*/4</code>，或者在上午12点到下午12点之间每三个小时运行一次<code>0-12/3</code>。</p>
<p>分钟也可以类似划分。例如，<code>minutes</code>位置的表达式<code>*/10</code>表示“每10分钟运行一次作业”</p>
<p>以下任务在上午8点到下午5点58分之间每两小时运行五分钟</p>
<pre>import * as cron from 'node-cron'
cron.schedule('*/5 8-18/2 * * *', () =&gt; {
  console.log('running a task every two hours between 8 a.m. and 5:58 p.m.');
});
</pre>
<h2 id="scheduledtaskmethods"><strong>预定任务方法</strong></h2>
<p>在我们结束之前，让我们回顾一些关键的预定任务方法。</p>
<h3>开始一项任务</h3>
<p>当您将<code>scheduled</code>选项值设置为<code>false</code>时，任务将被调度，但不能启动，即使cron表达式滴答。</p>
<p>要启动这样一个任务，需要调用调度任务<code>start</code>方法。</p>
<pre>const cron = require('node-cron');

import * as cron from 'node-cron'
const task = cron.schedule('*/5 8-18/2 * * *', () =&gt; {
  console.log('running a task every two hours between 8 a.m. and 5:58 p.m.');
});
task.start();
</pre>
<h3>停止任务</h3>
<p>如果需要停止一个任务的运行，您可以使用调度任务<code>stop</code>方法将<code>scheduled</code>选项设置为<code>false</code>。除非重新启动，否则不会执行该任务。</p>
<pre>const cron = require('node-cron');

import * as cron from 'node-cron'
const task = cron.schedule('*/5 8-18/2 * * *', () =&gt; {
  console.log('running a task every two hours between 8 a.m. and 5:58 p.m.');
});
task.stop();
</pre>
<h3>破坏任务</h3>
<p><code>destroy</code>方法停止一个任务并完全销毁它。</p>
<pre>const cron = require('node-cron');

import * as cron from 'node-cron'
const task = cron.schedule('*/5 8-18/2 * * *', () =&gt; {
  console.log('running a task every two hours between 8 a.m. and 5:58 p.m.');
});
task.destroy();
</pre>
<p><strong>结论</strong></p>
<p>在本教程中，我们介绍了大多数node-cron特性，您将需要这些特性来安排单调乏味的任务，并把自己从更重要——也更有成就感——的工作中解放出来。</p><div class="code-block code-block-54">
<hr/>
<h3>更多来自LogRocket的精彩文章:</h3>

<hr/></div>
<div class="code-block code-block-23">
<div class="blog-plug inline-plug node-plug"><h2>200只<img src="../Images/61167b9d027ca73ed5aaf59a9ec31267.png" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2019/10/green-check.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" class=" jetpack-lazy-image" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/10/green-check.png"/> <noscript> <img data-lazy-fallback="1" src="../Images/61167b9d027ca73ed5aaf59a9ec31267.png" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/10/green-check.png"/> </noscript>显示器出现故障，生产中网络请求缓慢</h2><p>部署基于节点的web应用程序或网站是容易的部分。确保您的节点实例继续为您的应用程序提供资源是事情变得更加困难的地方。如果您对确保对后端或第三方服务的请求成功感兴趣，</p><a href="https://lp.logrocket.com/blg/node-signup" target="_blank">try LogRocket</a><p>. </p><a class="signup" href="https://lp.logrocket.com/blg/node-signup" target="_blank" rel="noopener noreferrer"><img src="../Images/cae72fd2a54c5f02a6398c4867894844.png" alt="LogRocket Network Request Monitoring" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2019/12/network-request-filter-2-1.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" class=" jetpack-lazy-image" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/12/network-request-filter-2-1.png"/><noscript><img data-lazy-fallback="1" src="../Images/cae72fd2a54c5f02a6398c4867894844.png" alt="LogRocket Network Request Monitoring" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/12/network-request-filter-2-1.png"/></noscript></a><a href="https://lp.logrocket.com/blg/node-signup" target="_blank" rel="noopener noreferrer">https://logrocket.com/signup/</a><p>LogRocket 就像是网络和移动应用程序的DVR，记录下用户与你的应用程序交互时发生的一切。您可以汇总并报告有问题的网络请求，以快速了解根本原因，而不是猜测问题发生的原因。</p><p>LogRocket检测您的应用程序以记录基线性能计时，如页面加载时间、到达第一个字节的时间、慢速网络请求，还记录Redux、NgRx和Vuex操作/状态。</p><a class="signup" href="https://lp.logrocket.com/blg/node-signup" target="_blank" rel="noopener noreferrer">Start monitoring for free</a><p>. </p></div>
</div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
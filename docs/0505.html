<html>
<head>
<title>Add interactivity to your CLIs with React - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>使用React - LogRocket博客为您的CLIs添加交互性</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/add-interactivity-to-your-clis-with-react/#0001-01-01">https://blog.logrocket.com/add-interactivity-to-your-clis-with-react/#0001-01-01</a></blockquote><div><article class="article-post">
<p>命令行界面(或CLI)最近变得越来越交互。它们接受用户输入，呈现多种多样的用户界面，拥有改进的设计，而且目前使用起来通常更加愉快。</p>
<p>由于这些进步，CLI不再是核心程序员的专利。越来越多的人开始通过图形用户界面使用CLI。</p>
<p>以Jest为例:它提供了一种用户友好的交互式观看模式，无需任何GUI。然而，创建这样的CLI并不是一件容易的事情。</p>
<p>将某些内容呈现到终端基本上包括将多个字符串连接在一起，并将它们写入输出流。</p>
<p>这段代码可能很难测试，因为它通常不能很好地与代码库的其余部分分离。</p>
<p>交互性是另一个令人头疼的问题，因为工具主要解决特定的问题，比如问用户一个问题，让他们从一系列问题中选择答案。</p>
<p>如果我们有一个平台来构建交互式命令行应用程序，为我们提供创建任何可以想象的用户界面的构件，会怎么样？</p>
<p>更好的是，如果这些积木也是组件呢？</p>
<p>这就是<a href="https://reactjs.org/" target="_blank" rel="noopener noreferrer">反应</a>和<a href="https://github.com/vadimdemedes/ink" target="_blank" rel="noopener noreferrer">墨迹</a>的地方。</p>
<p>React允许您在组件中构建终端输出，就像您为浏览器构建应用程序一样。</p>
<p>Ink获取这些组件并将其呈现到终端，从而将您从手动组装终端输出的负担中解脱出来。</p>
<p>以下是在终端中使用墨迹创建一个简单计数器的简单方法:</p>
<pre>const React = require('react');
const {render, Text, Color} = require('ink');
const useAutoCounter = require('@use-it/auto-counter');

const Counter = () =&gt; {
  // Count from zero to infinity every 100ms
  const count = useAutoCounter(0, 100);

  return (
    &lt;Text&gt;
      Count: &lt;Color green&gt;{count}&lt;/Color&gt;
    &lt;/Text&gt;
  );
};

render(&lt;Counter/&gt;);</pre>
<p>这里有一个自动计数器的例子。</p>
<p>值得注意的是，Ink不仅可以呈现像<code>Text</code>、<code>Color</code>和<code>Box</code>这样的组件，还可以让你使用Flexbox来布局这些组件，就像在使用CSS的浏览器中一样。</p>
<p>得益于React和Ink，您可以导入第三方组件，并在您的终端应用程序中混合和匹配它们。</p>
<p>这在以前是不容易实现的。有各种你可以重用的组件，从<a href="https://github.com/vadimdemedes/ink-text-input" target="_blank" rel="noopener noreferrer">文本输入</a>、<a href="https://github.com/vadimdemedes/ink-select-input" target="_blank" rel="noopener noreferrer">可选列表</a>、<a href="https://github.com/vadimdemedes/ink-spinner" target="_blank" rel="noopener noreferrer">微调器</a>和<a href="https://github.com/brigand/ink-progress-bar" target="_blank" rel="noopener noreferrer">进度条</a>到<a href="https://github.com/sindresorhus/ink-link" target="_blank" rel="noopener noreferrer">链接</a>(是的，终端中的链接)，以及<a href="https://github.com/kevva/ink-image" target="_blank" rel="noopener noreferrer">图像</a>(是的，终端中的图像！)</p>
<p>像<a href="https://www.gatsbyjs.org/" target="_blank" rel="noopener noreferrer"> Gatsby </a>和<a href="https://www.shopify.com/" target="_blank" rel="noopener noreferrer"> Shopify </a>这样的公司，以及像<a href="https://parceljs.org/" target="_blank" rel="noopener noreferrer"> Parcel </a>和<a href="https://node-tap.org/" target="_blank" rel="noopener noreferrer"> Tap </a>这样受欢迎的项目，已经在使用Ink来构建和渲染他们的CLI的用户界面。</p>
<p>让我们找出原因。</p>
<h3>使用React和Ink创建CLI</h3>
<p>现在，让我们亲身体验一下这种神奇的感觉，并使用React和Ink创建我们自己的命令行应用程序。</p>
<p>我们将构建一个小工具，它在当前目录中搜索文件，然后在用户喜欢的代码编辑器中打开它。</p>
<p>在本教程结束时，我们将有一个类似这样的交互式CLI。</p>
<p>事情是这样的:</p>
<ol>
<li>用户输入搜索查询，将文件名与当前目录中的文件名进行比较</li>
<li>搜索结果作为用户类型列出，允许用户选择要在代码编辑器中打开的文件</li>
</ol>
<h3>入门指南</h3>
<p>让我们跳过样板文件，使用<a href="https://github.com/vadimdemedes/create-ink-app" target="_blank" rel="noopener noreferrer"> create-ink-app </a>，它搭建了一个预配置了React和ink的新CLI，因此我们可以立即开始构建我们的工具。你可能听说过<code>create-react-app</code>，它做了同样的工作，但在浏览器中的React应用程序。</p>
<p>创建一个名为<code>search</code>(这将是我们CLI的名称)的新目录，并在其中运行<code>create-ink-app</code>:</p>
<pre>$ mkdir search
$ cd search
$ npx create-ink-app</pre>
<p>为您安装所有依赖项可能需要几分钟时间。完成后，您应该会看到以下输出:</p>
<p><img data-attachment-id="8842" data-permalink="https://blog.logrocket.com/add-interactivity-to-your-clis-with-react/projects-logrocket-search/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2019/10/Projects-logrocket-search.png" data-orig-size="730,486" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Projects-logrocket-search" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2019/10/Projects-logrocket-search-300x200.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2019/10/Projects-logrocket-search.png" decoding="async" class="aligncenter size-full wp-image-8842 jetpack-lazy-image" src="../Images/e4d79b950fb99b976e784a57446a5675.png" alt="An example to illustrate how to add interactivity to your CLIs in React" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2019/10/Projects-logrocket-search.png 730w, https://blog.logrocket.com/wp-content/uploads/2019/10/Projects-logrocket-search-300x200.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2019/10/Projects-logrocket-search.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/10/Projects-logrocket-search.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="8842" data-permalink="https://blog.logrocket.com/add-interactivity-to-your-clis-with-react/projects-logrocket-search/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2019/10/Projects-logrocket-search.png" data-orig-size="730,486" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Projects-logrocket-search" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2019/10/Projects-logrocket-search-300x200.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2019/10/Projects-logrocket-search.png" decoding="async" loading="lazy" class="aligncenter size-full wp-image-8842" src="../Images/e4d79b950fb99b976e784a57446a5675.png" alt="An example to illustrate how to add interactivity to your CLIs in React" srcset="https://blog.logrocket.com/wp-content/uploads/2019/10/Projects-logrocket-search.png 730w, https://blog.logrocket.com/wp-content/uploads/2019/10/Projects-logrocket-search-300x200.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/10/Projects-logrocket-search.png"/></noscript>
<p>此时，<code>search</code> CLI已经在您的环境中可用，您可以尝试运行它:</p>
<pre>$ search</pre>
<p>如果一切正常，您应该会看到一条“你好，陌生人”的消息，其中“陌生人”是绿色的。</p>
<p>如果你看一下<code>search</code>目录，你会发现<code>cli.js</code>和<code>ui.js</code>文件。为了简化本教程，我们将只使用<code>ui.js</code>，因为那是我们CLI的用户界面实现的地方。</p>
<p>用这个替换<code>create-ink-app</code>为我们搭建的<code>ui.js</code>的源代码，这样我们可以从头开始:</p>
<pre>'use strict';
    const React = require('react');
    const {Box} = require('ink');
    
    const App = () =&gt; {
      return (
        &lt;Box/&gt;
      );
    };
    
    module.exports = App;</pre>
<p>如果运行它，将不会呈现任何内容，因为<code>App</code>返回一个空的<code>Box</code>组件。<code>Box</code>组件被用作其他组件如<code>Text</code>或<code>Color</code>的容器。</p><div class="code-block code-block-54">
<hr/>
<h3>更多来自LogRocket的精彩文章:</h3>

<hr/></div>
<p>每个<code>Box</code>组件水平对齐其子组件，类似于浏览器中应用了<code>display: flex</code>的<code>div</code>元素。</p>
<h3>添加搜索输入</h3>
<p>我们的CLI需要做的第一件事是接受和处理用户输入。</p>
<p>我们需要安装<code>ink-text-input</code>组件来轻松实现它，它已经处理了光标管理和用户输入记录之类的事情。</p>
<pre>$ npm install ink-text-input</pre>
<p>现在，我们将向CLI添加一个<code>TextInput</code>组件。</p>
<p><code>TextInput</code>组件不处理输入状态，所以我们需要传递带有当前输入值的<code>value</code>属性和一个<code>onChange</code>处理程序，以便在用户输入更多字符时更新它。</p>
<p>当用户还没有输入任何文本时，将显示通过<code>placeholder</code>属性传递的文本。</p>
<pre>'use strict';
const React = require('react');
const {Box} = require('ink');
const TextInput = require('ink-text-input').default;

const App = () =&gt; {
  const [value, setValue] = React.useState('');

  return (
    &lt;Box&gt;
      &lt;TextInput
        placeholder="Enter your search query..."
        value={value}
        onChange={setValue}
      /&gt;
    &lt;/Box&gt;
  );
};

module.exports = App;</pre>
<p>如果您现在尝试在终端中运行<code>search</code>命令，您应该会看到“输入您的搜索查询…”文本，并且能够键入您想要的任何文本。</p>
<p>您还应该能够使用光标在您输入的文本值内左右移动。</p>
<p>让我们将<code>value</code>和<code>setValue</code>分别重命名为<code>searchQuery</code>和<code>setSearchQuery</code>，以更好地反映这个变量的用途。</p>
<p>我们还将使用<code>Color</code>组件在文本输入前添加一个漂亮的绿色箭头，以便更好地突出显示:</p>
<pre>'use strict';
const React = require('react');
const {Box, Color} = require('ink');
const TextInput = require('ink-text-input').default;

const App = () =&gt; {
  const [searchQuery, setSearchQuery] = React.useState('');

  return (
    &lt;Box&gt;
      &lt;Color green&gt;❯ &lt;/Color&gt;
      &lt;TextInput
        placeholder="Enter your search query..."
        value={searchQuery}
        onChange={setSearchQuery}
      /&gt;
    &lt;/Box&gt;
  );
};

module.exports = App;</pre>
<p>如果您再次运行<code>search</code>命令，您应该会在您正在键入的文本前看到一个漂亮的绿色箭头。</p>
<h3>在当前目录中搜索匹配的文件</h3>
<p>现在，让我们添加一个实际的搜索功能。</p>
<p>当用户键入他们的查询时，我们将在整个目录中搜索匹配该查询的文件。</p>
<p>为此，我们将安装两个新模块——<a href="https://github.com/sindresorhus/globby" target="_blank" rel="noopener noreferrer">glob by</a>和<a href="https://github.com/atom/fuzzaldrin" target="_blank" rel="noopener noreferrer"> fuzzaldrin </a>。Globby返回当前目录中所有文件的列表，而fuzzaldrin搜索该列表以查看是否有文件名匹配搜索查询。</p>
<pre>$ npm install globby fuzzaldrin</pre>
<p>为了加快搜索速度，我们只需要扫描一次目录，然后继续用不同的搜索查询过滤它。</p>
<p>为此，我们将使用一个带有空依赖列表的<code>useEffect</code>钩子，这使得它在组件第一次呈现后只执行一次。</p>
<p>我们还将通过名为<code>files</code>的<code>useState</code>创建一个新的状态变量，在这里我们将存储所有文件的列表。</p>
<pre>'use strict';
const React = require('react');
const {Box, Color} = require('ink');
const TextInput = require('ink-text-input').default;
const globby = require('globby');

const App = () =&gt; {
  const [searchQuery, setSearchQuery] = React.useState('');
  const [files, setFiles] = React.useState([]);

  React.useEffect(() =&gt; {
    globby(['**/*', '!node_modules']).then(files =&gt; {
      setFiles(files);
    });
  });

  return (
    &lt;Box&gt;
      &lt;Color green&gt;❯ &lt;/Color&gt;
      &lt;TextInput
        placeholder="Enter your search query..."
        value={searchQuery}
        onChange={setSearchQuery}
      /&gt;
    &lt;/Box&gt;
  );
};

module.exports = App;</pre>
<p>有两个模式被传递给<code>globby</code>，每个模式执行以下操作:</p>
<ul>
<li><code>**/*</code>–发出信号递归搜索所有目录(查找所有嵌套文件)</li>
<li><code>!node_modules</code>-发出忽略<code>node_modules</code>目录的信号，因为您通常不希望在依赖项中搜索</li>
</ul>
<p>接下来，由于我们已经在<code>searchQuery</code>中存储了当前的搜索查询，我们可以立即用<code>fuzzaldrin</code>过滤<code>files</code>数组以获得我们的搜索结果。</p>
<p>Fuzzaldrin足够快，我们可以在每次渲染时执行它。</p>
<pre>'use strict';
const React = require('react');
const {Box, Color} = require('ink');
const TextInput = require('ink-text-input').default;
const globby = require('globby');
const fuzzaldrin = require('fuzzaldrin');

const App = () =&gt; {
  const [searchQuery, setSearchQuery] = React.useState('');
  const [files, setFiles] = React.useState([]);

  React.useEffect(() =&gt; {
    globby(['**/*', '!node_modules']).then(files =&gt; {
      setFiles(files);
    });
  });

  const searchResults = fuzzaldrin.filter(files, searchQuery);

  return (
    &lt;Box&gt;
      &lt;Color green&gt;❯ &lt;/Color&gt;
      &lt;TextInput
        placeholder="Enter your search query..."
        value={searchQuery}
        onChange={setSearchQuery}
      /&gt;
    &lt;/Box&gt;
  );
};

module.exports = App;</pre>
<h3>显示结果列表</h3>
<p>现在，我们需要显示结果列表，并允许我们的CLI用户选择他们想要的文件。</p>
<p>我们可以使用<code>ink-select-input</code>模块，它提供了一个实现选择列表的<code>SelectInput</code>组件。要安装此组件，请运行以下命令:</p>
<pre>$ npm install ink-select-input</pre>
<p>接下来，我们将通过添加一个<code>SelectInput</code>组件和一个选项列表来修改我们的<code>ui.js</code>文件。</p>
<p>不过，中间还有一步。</p>
<p>在我们当前的代码中，<code>searchResults</code>是一个字符串数组，其中每一项都是一个文件路径。然而，<code>SelectInput</code>需要一个对象数组，其中每个对象如下所示:</p>
<pre>{
  label: "Label of item, displayed to the user",
  value: "Internal value, not displayed to the user"
}</pre>
<p>为了传递一个<code>SelectInput</code>能够理解的条目列表，我们需要更新<code>searchResults</code>数组来包含如下对象:</p>
<pre>'use strict';
const React = require('react');
const {Box, Color} = require('ink');
const TextInput = require('ink-text-input').default;
const SelectInput = require('ink-select-input').default;
const globby = require('globby');
const fuzzaldrin = require('fuzzaldrin');

const App = () =&gt; {
  const [searchQuery, setSearchQuery] = React.useState('');
  const [files, setFiles] = React.useState([]);

  React.useEffect(() =&gt; {
    globby(['**/*', '!node_modules']).then(files =&gt; {
      setFiles(files);
    });
  });

  const searchResults = fuzzaldrin.filter(files, searchQuery).map(file =&gt; ({
    label: file,
    value: file
  }));

  return (
    &lt;Box flexDirection="column"&gt;
      &lt;Box&gt;
        &lt;Color green&gt;❯ &lt;/Color&gt;
        &lt;TextInput
          placeholder="Enter your search query..."
          value={searchQuery}
          onChange={setSearchQuery}
        /&gt;
      &lt;/Box&gt;
      
      &lt;SelectInput
        limit={5}
        items={searchResults}
      /&gt;
    &lt;/Box&gt;
  );
};

module.exports = App;</pre>
<p>注意，我还添加了一个<code>limit={5}</code>属性，所以列表一次最多只显示5个项目。</p>
<p>如果项目的数量实际上大于5，列表将变得可滚动。多酷啊。</p>
<p>您可能也注意到了，我将整个输出打包在<code>&lt;Box flexDirection="column"&gt;</code>中。</p>
<p>我这样做是为了把搜索结果放在搜索输入的下面。否则它们将会并排水平显示。</p>
<p>让我们看看我们的CLI是什么样子的！运行<code>search</code>命令，您应该会看到类似这样的内容:<img data-attachment-id="8844" data-permalink="https://blog.logrocket.com/add-interactivity-to-your-clis-with-react/logrocket-search-master-nocdn/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2019/10/logrocket-search-master-nocdn.png" data-orig-size="730,486" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="logrocket-search-master-nocdn" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2019/10/logrocket-search-master-nocdn-300x200.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2019/10/logrocket-search-master-nocdn.png" decoding="async" class="aligncenter size-full wp-image-8844 jetpack-lazy-image" src="../Images/808be7520b5eab03d97f18c278ba0fda.png" alt="LogRocket search Master" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2019/10/logrocket-search-master-nocdn.png 730w, https://blog.logrocket.com/wp-content/uploads/2019/10/logrocket-search-master-nocdn-300x200.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2019/10/logrocket-search-master-nocdn.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/10/logrocket-search-master-nocdn.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="8844" data-permalink="https://blog.logrocket.com/add-interactivity-to-your-clis-with-react/logrocket-search-master-nocdn/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2019/10/logrocket-search-master-nocdn.png" data-orig-size="730,486" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="logrocket-search-master-nocdn" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2019/10/logrocket-search-master-nocdn-300x200.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2019/10/logrocket-search-master-nocdn.png" decoding="async" loading="lazy" class="aligncenter size-full wp-image-8844" src="../Images/808be7520b5eab03d97f18c278ba0fda.png" alt="LogRocket search Master" srcset="https://blog.logrocket.com/wp-content/uploads/2019/10/logrocket-search-master-nocdn.png 730w, https://blog.logrocket.com/wp-content/uploads/2019/10/logrocket-search-master-nocdn-300x200.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/10/logrocket-search-master-nocdn.png"/></noscript>
<p>默认情况下，它显示当前目录中的所有文件。你可以用箭头键在列表中上下移动。</p>
<p>如果您输入一个搜索查询，它应该会用只匹配搜索模式的文件来过滤列表。</p>
<h3>在代码编辑器中打开选定的文件</h3>
<p>现在让我们添加最后一个缺失的部分——选择文件并在用户首选的代码编辑器中打开它们。我们需要安装一个<code>open-editor</code>依赖项，它会为我们完成这项工作。</p>
<pre>$ npm install open-editor</pre>
<p>在我们开始之前，首先检查一下您是否有首选的代码编辑器是很重要的。</p>
<p>您可以通过在终端中运行以下命令来验证这一点:</p>
<pre>$ echo $EDITOR</pre>
<p>如果命令运行成功，可以跳过下一段。</p>
<p>如果它没有输出任何东西，这意味着您需要设置一个首选的代码编辑器。</p>
<p>出于本教程的目的，我们将只为当前终端会话设置它。</p>
<p>但是，最好在您的配置文件中设置它，比如<code>.bashrc</code>或<code>.zshrc</code>。下面是几个如何选择不同的代码编辑器作为首选编辑器的示例:</p>
<pre># Set Atom as preferred editor
export EDITOR=atom

# Set Sublime Text as preferred editor
export EDITOR=subl

# Set Vim as preferred editor
export EDITOR=vim</pre>
<p>接下来，让我们向<code>SelectInput</code>组件添加一个<code>onSelect</code>处理程序。这个处理程序将从<code>searchResults</code>数组中接收一个项目，我们将使用它在用户编辑器中打开一个文件。</p>
<pre>'use strict';
const React = require('react');
const {Box, Color} = require('ink');
const TextInput = require('ink-text-input').default;
const SelectInput = require('ink-select-input').default;
const globby = require('globby');
const fuzzaldrin = require('fuzzaldrin');
const openEditor = require('open-editor');

const App = () =&gt; {
  const [searchQuery, setSearchQuery] = React.useState('');
  const [files, setFiles] = React.useState([]);

  React.useEffect(() =&gt; {
    globby(['**/*', '!node_modules']).then(files =&gt; {
      setFiles(files);
    });
  });

  const searchResults = fuzzaldrin.filter(files, searchQuery).map(file =&gt; ({
    label: file,
    value: file
  }));

  const handleSelect = searchResult =&gt; {
    openEditor([
      {
        file: searchResult.value,
        line: 1,
        column: 1
      }
    ]);
  };

  return (
    &lt;Box flexDirection="column"&gt;
      &lt;Box&gt;
        &lt;Color green&gt;❯ &lt;/Color&gt;
        &lt;TextInput
          placeholder="Enter your search query..."
          value={searchQuery}
          onChange={setSearchQuery}
        /&gt;
      &lt;/Box&gt;

      &lt;SelectInput
        limit={5}
        items={searchResults}
        onSelect={handleSelect}
      /&gt;
    &lt;/Box&gt;
  );
};

module.exports = App;</pre>
<p>瞧啊。我们自己的带有React和Ink的命令行应用已经准备好了。</p>
<h3>后续步骤</h3>
<p>尝试进一步发展此CLI以增强您的Ink知识。</p>
<p>你可以在文件列表加载时添加一个<a href="https://github.com/vadimdemedes/ink-spinner" target="_blank" rel="noopener noreferrer">加载微调器</a>，让用户选择<a href="https://github.com/karaggeorge/ink-multi-select" target="_blank" rel="noopener noreferrer">多个文件</a>，添加一个<a href="https://github.com/sindresorhus/ink-big-text" target="_blank" rel="noopener noreferrer">大的花哨标志</a>，或者做任何想到的事情。</p>
<h3>结论</h3>
<p>如您所见，当您手头有合适的工具时，构建交互式CLI并不可怕。</p>
<p>凭借React的卓越功能，将用户界面拆分成组件比以往任何时候都更容易。</p>
<p>重要的是要记住，React的范围远远超出了浏览器中的应用程序。</p>
<p>人们使用React构建移动、VR以及现在的终端应用。我相信我们会看到更多React方法大放异彩的环境。</p>
<p>不要停止你的好奇心。</p><div class="code-block code-block-17">
<div class="blog-plug inline-plug react-plug" vwo-el-id="26283398190">
<h2 vwo-el-id="41600691720">使用LogRocket消除传统反应错误报告的噪音</h2>
<a href="https://lp.logrocket.com/blg/react-signup-issue-free" target="_blank" vwo-el-id="19356441070">LogRocket
</a><p>是一款React analytics解决方案，可保护您免受数百个误报错误警报的影响，只针对少数真正重要的项目。LogRocket告诉您React应用程序中实际影响用户的最具影响力的bug和UX问题。</p><a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="19356441380">
<img class="first-react-image alignnone size-full wp-image-46 jetpack-lazy-image jetpack-lazy-image--handled" src="../Images/f300c244a1a1cf916df8b4cb02bec6c6.png" vwo-el-id="18272717540" data-lazy-loaded="1" data-original-src="https://files.readme.io/27c94e7-Image_2017-06-05_at_9.46.04_PM.png"/>
</a>
<a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="19356441690">
<img class="second-react-image alignnone size-full wp-image-46 jetpack-lazy-image jetpack-lazy-image--handled" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" vwo-el-id="30720362350" data-lazy-loaded="1" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/>
</a>
<a href="https://lp.logrocket.com/blg/react-signup-issue-free" target="_blank" rel="noopener noreferrer" vwo-el-id="35866400580">LogRocket
</a><p>自动聚合客户端错误、反应错误边界、还原状态、缓慢的组件加载时间、JS异常、前端性能指标和用户交互。然后，LogRocket使用机器学习来通知您影响大多数用户的最具影响力的问题，并提供您修复它所需的上下文。</p><p vwo-el-id="28675661060">关注重要的React bug—<a class="signup" href="https://lp.logrocket.com/blg/react-signup-issue-free" target="_blank" rel="noopener noreferrer" vwo-el-id="40093418840">今天就试试LogRocket】。</a></p>
</div></div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
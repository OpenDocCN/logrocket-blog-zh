<html>
<head>
<title>CRUD with React and GraphQL: A complete tutorial with examples - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>使用React和GraphQL的CRUD:一个完整的示例教程</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/crud-react-graphql-examples/#0001-01-01">https://blog.logrocket.com/crud-react-graphql-examples/#0001-01-01</a></blockquote><div><article class="article-post">
<p><em> <strong>编者按</strong>:这个React和GraphQL CRUD教程最后一次更新是在2021年4月30日。</em></p>
<p>在本教程中，我们将向您展示如何使用GraphQL和React实现简单的端到端CRUD操作。我们将回顾使用<a href="https://blog.logrocket.com/react-hooks-cheat-sheet-unlock-solutions-to-common-problems-af4caf699e70/" target="_blank" rel="noopener"> React钩子</a>读取和改变数据的简单例子。我们还将展示如何用<a href="https://blog.logrocket.com/data-retrieval-in-graphql-with-react-apollo/" target="_blank" rel="noopener"> Apollo客户端</a>实现认证、错误处理、缓存和乐观UI。</p>
<p>以下是我们将要介绍的内容:</p>

<h2 id="react">什么是反应？</h2>
<p><a href="https://reactjs.org/" target="_blank" rel="noopener"> React </a>是一个用于构建用户界面的JavaScript库。它旨在帮助构建应用程序的前端，包括处理web和移动应用程序的视图层。</p>
<p>React是基于组件的，这意味着React应用程序的各个部分被分解成更小的组件，然后组织在更高级别的组件中。这些高级组件是应用程序最终结构的定义所在。</p>
<p>React支持可重用组件，因此您可以创建一个组件，并在应用程序的不同部分多次使用它。这有助于减少臃肿的代码，并更容易遵循<a href="https://en.wikipedia.org/wiki/Don%27t_repeat_yourself" target="_blank" rel="noopener"> DRY原则</a>。</p>
<h2 id="graphql">GraphQL是什么？</h2>
<p>GraphQL是一种用于API的查询语言，也是用现有数据完成查询的运行时。简单来说，GraphQL是一种描述如何请求数据的语法。它通常用于从服务器向客户端加载数据。</p>
<p>GraphQL通过将所有请求抽象到一个端点来降低构建API的复杂性。与传统的REST APIs不同，它是声明性的，这意味着无论请求什么都会被返回。</p>
<h3 id="whentousegraphql">何时使用GraphQL</h3>
<p>当然，并不是所有的项目都需要graph QL——它仅仅是一个整合数据的工具。它有定义良好的模式，所以我们肯定不会过度提取。但是如果我们已经有了一个稳定的RESTful API系统，我们依赖于来自单一数据源的数据，我们就不需要GraphQL 。</p>
<p>例如，假设我们正在为自己创建一个博客，我们决定在一个MongoDB数据库中存储、检索和交流数据。在这种情况下，我们没有做任何架构上复杂的事情，也不需要GraphQL。</p>
<p><span>另一方面，假设我们有一个完全成熟的产品，它依赖于来自多个来源的数据(例如，MongoDB、MySQL、Postgres和其他API)。在这种情况下，我们<a href="https://blog.logrocket.com/graphql-vs-rest-what-you-didnt-know/" target="_blank" rel="noopener">应该使用GraphQL </a>。</span></p>
<p>例如，如果我们正在为自己设计一个作品集网站，我们想要来自社交媒体和GitHub的数据(以显示贡献)，我们也有自己的数据库来维护一个博客，我们可以使用GraphQL来编写业务逻辑和模式。它将把数据整合为单一的真实来源。</p>
<p>一旦我们有了将正确的数据分发到前端的解析器功能，我们将能够轻松地管理单个数据源中的数据。</p>
<h2 id="crud">什么是CRUD？</h2>
<p>在构建API时，您希望您的模型提供四个基本功能:它应该能够<a href="https://blog.logrocket.com/nodejs-expressjs-postgresql-crud-rest-api-example/#whatisacrudapi" target="_blank" rel="noopener">创建、读取、更新和删除资源</a>。这组基本操作通常被称为<a href="https://www.codecademy.com/articles/what-is-crud" target="_blank" rel="noopener"> CRUD </a>。</p>
<p>RESTful APIs通常利用HTTP请求。REST环境中最常见的四种HTTP方法是<code><span class="pln">GET</span></code>、<code><span class="pln">POST</span></code>、<code><span class="pln">PUT</span></code>和<code><span class="pln">DELETE</span></code>，开发人员可以通过这些方法<a href="https://blog.logrocket.com/creating-a-crud-api-with-node-express-and-grpc/" target="_blank" rel="noopener">创建CRUD系统</a>。</p>
<h2 id="crudwithgraphqlserver">使用<code>graphql-server</code>的CRUD</h2>
<p>在本节中，我们将查看一些GraphQL CRUD示例，以帮助您理解CRUD操作如何在React和GraphQL应用程序中工作。</p>
<h3>设置服务器</h3>
<p>我们将使用<a href="https://www.npmjs.com/package/express-graphql"> <code>express-graphql</code> </a>剥离一个简单的GraphQL服务器，并将其连接到MySQL数据库。源代码和MySQL文件都在这个<a href="https://github.com/AvanthikaMeenakshi/graphqlReactBoilerplate">仓库</a>里。</p>
<p>GraphQL服务器构建在模式和解析器之上。作为第一步，我们构建一个模式(定义类型、查询、变异和订阅)。这个模式描述了整个应用程序的结构。</p>
<p>其次，对于模式中定义的内容，我们正在构建各自的解析器来计算和分发数据。解析器将动作与功能进行映射；对于typedef中声明的每个查询，我们创建一个解析器来返回数据。</p>
<p>最后，我们通过定义端点和传递配置来完成服务器设置。我们将<code>/graphql</code>初始化为应用程序的端点。我们将构建的模式和根解析器传递给<code>graphqlHTTP</code>中间件。</p>
<p>除了模式和根解析器，我们还启用了<a href="https://www.npmjs.com/package/graphiql"> GraphiQL </a>游乐场。GraphQL是一个交互式浏览器内GraphQL IDE，它帮助我们处理我们构建的GraphQL查询。</p>
<pre>var express = require('express');
var graphqlHTTP = require('express-graphql');
var { buildSchema } = require('graphql');

var schema = buildSchema(`
  type Query {
    hello: String
  }
`);

var root = {
  hello: () =&gt; "World"
};

var app = express();

app.use('/graphql', graphqlHTTP({
  schema: schema,
  rootValue: root,
  graphiql: true,
}));

app.listen(4000);

console.log('Running a GraphQL API server at localhost:4000/graphql');</pre>
<p>一旦服务器准备就绪，用<code>node index.js</code>运行应用程序将在<code><a href="http://localhost:4000/graphql" rel="nofollow">http://localhost:4000/graphql</a></code>启动服务器。我们可以查询hello并得到字符串“World”作为响应。</p>
<h3>连接数据库</h3>
<p>我将建立与MySQL数据库的连接，如下所示:</p>
<pre>var mysql = require('mysql');

app.use((req, res, next) =&gt; {
  req.mysqlDb = mysql.createConnection({
    host     : 'localhost',
    user     : 'root',
    password : '',
    database : 'userapp'
  });
  req.mysqlDb.connect();
  next();
});</pre>
<p>我们可以连接多个数据库/源，并在解析器中整合它们。我在这里连接到一个MySQL数据库。我在本文中使用的数据库转储在GitHub存储库中。</p>
<h2 id="readingandwritingdatawithgraphql">使用GraphQL读写数据</h2>
<p>我们使用查询和突变来读取和修改<code>data-sources</code>中的数据。在这个例子中，我定义了一个通用的queryDB函数来帮助查询数据库。</p>
<h3>问题</h3>
<p>列出和查看数据的所有SELECT语句(或读操作)都放在<code>type Query</code> typedef中。我们在这里定义了两个查询:一个列出数据库中的所有用户，另一个按id查看单个用户。</p>
<ol>
<li><strong>列出数据:</strong>为了列出用户，我们定义了一个名为<code>User</code>的GraphQL模式对象类型，它表示我们可以从<code>getUsers</code>查询中获取或期望的内容。然后我们定义<code>getUsers</code>查询来返回一组用户</li>
<li><strong>查看单个记录:</strong>为了查看单个记录，我们将<code>id</code>作为我们定义的<code>getUserInfo</code>查询的参数。它在数据库中查询该特定id，并将数据返回给前端</li>
</ol>
<p><img data-attachment-id="5219" data-permalink="https://blog.logrocket.com/crud-react-graphql-examples/graphiql-demo/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2019/08/graphiql-demo.gif" data-orig-size="730,333" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="GraphiQl demo returning an array of users" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2019/08/graphiql-demo-300x137.gif" data-large-file="https://blog.logrocket.com/wp-content/uploads/2019/08/graphiql-demo.gif" decoding="async" class="aligncenter size-full wp-image-5219 jetpack-lazy-image" src="../Images/d44779672f722e8a8293f82bf4361223.png" alt="GraphiQL Demo Returning Array Of Users" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2019/08/graphiql-demo.gif?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/08/graphiql-demo.gif"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="5219" data-permalink="https://blog.logrocket.com/crud-react-graphql-examples/graphiql-demo/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2019/08/graphiql-demo.gif" data-orig-size="730,333" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="GraphiQl demo returning an array of users" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2019/08/graphiql-demo-300x137.gif" data-large-file="https://blog.logrocket.com/wp-content/uploads/2019/08/graphiql-demo.gif" decoding="async" loading="lazy" class="aligncenter size-full wp-image-5219" src="../Images/d44779672f722e8a8293f82bf4361223.png" alt="GraphiQL Demo Returning Array Of Users" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/08/graphiql-demo.gif"/></noscript>
<p>现在我们已经将获取所有记录和按ID查看记录的查询放在一起，当我们试图从GraphiQL中查询用户时，它将在屏幕上列出一组用户！</p>
<pre>var schema = buildSchema(`
  type User {
    id: String
    name: String
    job_title: String
    email: String
  }
  type Query {
    getUsers: [User],
    getUserInfo(id: Int) : User
  }
`);

const queryDB = (req, sql, args) =&gt; new Promise((resolve, reject) =&gt; {
    req.mysqlDb.query(sql, args, (err, rows) =&gt; {
        if (err)
            return reject(err);
        rows.changedRows || rows.affectedRows || rows.insertId ? resolve(true) : resolve(rows);
    });
});

var root = {
  getUsers: (args, req) =&gt; queryDB(req, "select * from users").then(data =&gt; data),
  getUserInfo: (args, req) =&gt; queryDB(req, "select * from users where id = ?", [args.id]).then(data =&gt; data[0])
};</pre>
<h3>突变</h3>
<p>数据库的写操作——创建、更新、删除——通常在突变下定义。GraphQL引擎以连续的方式执行变异。查询是并行执行的。</p>
<ol>
<li>创建数据:我们已经定义了一个变体<code>createUser</code>，它采用指定的参数在MySQL数据库中创建数据。</li>
<li>更新或删除数据:类似于查看记录，更新(<code>updateUserInfo</code>)和删除(<code>deleteUser</code>)以id为参数，修改数据库。</li>
</ol>
<p>这些函数用一个布尔值来表示是否发生了变化。</p>
<pre>var schema = buildSchema(`
  type Mutation {
    updateUserInfo(id: Int, name: String, email: String, job_title: String): Boolean
    createUser(name: String, email: String, job_title: String): Boolean
    deleteUser(id: Int): Boolean
  }
`);

var root = {
  updateUserInfo: (args, req) =&gt; queryDB(req, "update users SET ? where id = ?", [args, args.id]).then(data =&gt; data),
  createUser: (args, req) =&gt; queryDB(req, "insert into users SET ?", args).then(data =&gt; data),
  deleteUser: (args, req) =&gt; queryDB(req, "delete from users where id = ?", [args.id]).then(data =&gt; data)
};</pre>
<p>既然我们已经设置并排序了服务器端的东西，让我们尝试将后端连接到我们的React应用程序。</p>
<h2 id="crudinreact">使用<code>graphql-client</code>反应中的积垢</h2>
<p>一旦我们有了服务器，创建客户机逻辑来显示和改变数据就很容易了。Apollo客户端有助于状态管理和缓存。它也是高度抽象和快速的:所有用于检索数据、跟踪加载和错误状态以及更新UI的逻辑都由<code>useQuery</code>钩子封装。</p>
<h3>连接到<code>graphql-server</code></h3>
<p>我创建了一个CRA样板文件，并安装了<a href="https://www.npmjs.com/package/graphql"/>、<a href="https://www.npmjs.com/package/apollo-boost"> <code>apollo-boost</code> </a>和<a href="https://www.npmjs.com/package/@apollo/react-hooks"> <code>@apollo/react-hooks</code> </a>。我们初始化Apollo客户机，并让它挂钩作出反应。</p>
<pre>import React from 'react';
import ReactDOM from 'react-dom';
import App from './App';
import ApolloClient from 'apollo-boost';
import { ApolloProvider } from '@apollo/react-hooks';

const client = new ApolloClient({
  uri: 'http://localhost:4000/graphql'
});

ReactDOM.render(
  &lt;ApolloProvider client={client}&gt;
    &lt;App /&gt;
  &lt;/ApolloProvider&gt;,
  document.getElementById('root')
);</pre>
<h3>读取和改变数据</h3>
<p>我已经在我的源代码的<code>Queries</code>文件夹中管理了所有的GraphQL查询。我将使用<code>useQuery</code>钩子从服务器请求数据，该钩子构建在React钩子API之上。它有助于将数据引入UI。</p>
<p>GraphQL查询通常包装在<code>gql</code>函数中。<code>gql</code>帮助将查询字符串转换成查询文档。下面是我们如何在应用程序中定义查询。</p>
<pre>import { gql } from 'apollo-boost';

export const GET_USERS = gql`
  {
    getUsers {
      id,
      name,
      job_title,
      email
    }
  }
`;

export const VIEW_USERS = gql`
  query ($id: Int){
    getUserInfo(id: $id) {
      id,
      name,
      job_title,
      email
    }
  }
`;

export const ADD_USER = gql`
  mutation($name: String, $email: String, $job_title: String) {
    createUser (name: $name, email: $email, job_title: $job_title)
  }
`;

export const EDIT_USER = gql`
  mutation($id: Int, $name: String, $email: String, $job_title: String) {
    updateUserInfo (id: $id, name: $name, email: $email, job_title: $job_title)
  }
`;

export const DELETE_USER = gql`
  mutation($id: Int) {
    deleteUser(id: $id)
  }
`</pre>
<p>一旦设置了<code>ApolloProvider</code>,我们就可以从我们的GraphQL服务器请求数据。我们将试图进行的查询传递给<code>useQuery</code>钩子，它将为我们提供结果。</p>
<p>我做了两个有参数和没有参数的查询，来展示我们应该如何在前端处理查询和变异。<code>useQuery</code>为我们跟踪<code>error</code>和<code>loading</code>状态，并将反映在关联对象中。一旦服务器发送结果，它将通过数据属性反映出来。</p>
<pre>import React from 'react';
import { useQuery } from '@apollo/react-hooks';
import { GET_USERS, VIEW_USERS } from "./Queries";
import { Card, CardBody, CardHeader, CardSubtitle, Spinner } from 'reactstrap';

function App() {
  const getAllUsers = useQuery(GET_USERS);
  const userInfo = useQuery(VIEW_USERS, { variables: { id: 1 }});
  if (getAllUsers.loading || userInfo.loading) return &lt;Spinner color="dark" /&gt;;
  if (getAllUsers.error || userInfo.error) return &lt;React.Fragment&gt;Error :(&lt;/React.Fragment&gt;;

  return (
    &lt;div className="container"&gt;
      &lt;Card&gt;
        &lt;CardHeader&gt;Query - Displaying all data&lt;/CardHeader&gt;
        &lt;CardBody&gt;
          &lt;pre&gt;
            {JSON.stringify(getAllUsers.data, null, 2)}
          &lt;/pre&gt;
        &lt;/CardBody&gt;
      &lt;/Card&gt;
      &lt;Card&gt;
        &lt;CardHeader&gt;Query - Displaying data with args&lt;/CardHeader&gt;
        &lt;CardBody&gt;
          &lt;CardSubtitle&gt;Viewing a user by id&lt;/CardSubtitle&gt;
          &lt;pre&gt;
            {JSON.stringify(userInfo.data, null, 2)}
          &lt;/pre&gt;
        &lt;/CardBody&gt;
      &lt;/Card&gt;
    &lt;/div&gt;
  )
}

export default App;
</pre>
<p>与查询类似，变异将使用相同的<code>useQuery</code>钩子，并将数据作为变量传递给查询。</p>
<pre>const deleteMutation = useQuery(DELETE_USER, { variables: { id: 8 }});
const editMutation = useQuery(EDIT_USER, { variables: { id: 9, name: "Username", email: "email", job_title: "job" }});
const createMutation = useQuery(ADD_USER, { variables: { name: "Username", email: "email", job_title: "job" }});</pre>
<div class="inline-plug cro19">
<h2>200只<img decoding="async" src="../Images/61167b9d027ca73ed5aaf59a9ec31267.png" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2019/10/green-check.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" class=" jetpack-lazy-image" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/10/green-check.png"/> <noscript> <img data-lazy-fallback="1" decoding="async" src="../Images/61167b9d027ca73ed5aaf59a9ec31267.png" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/10/green-check.png"/> </noscript>监视器在生产中出现故障和缓慢的GraphQL请求</h2>
<p>虽然GraphQL有一些调试请求和响应的功能，但确保GraphQL在生产中继续为您的应用程序提供资源却变得更加困难。如果您对确保对后端或第三方服务的请求成功感兴趣，请尝试LogRocket 。<a class="signup" href="https://logrocket.com/signup/" target="_blank" rel="noopener noreferrer"><img data-attachment-id="46" data-permalink="https://blog.logrocket.com/vuex-showdown-mutations-vs-actions/1d0cd-1s_rmyo6nbrasp-xtvbaxfg/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg-e1565635879164.png" data-orig-size="730,412" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="LogRocket dashboard free trial banner" data-image-description="&lt;p&gt;LogRocket is working on the perfect frontend bug report. Try it free today.&lt;/p&gt;&#10;" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg-e1565635879164.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg-e1565635879164.png" decoding="async" class="alignnone size-full wp-image-46 jetpack-lazy-image" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/><noscript><img data-lazy-fallback="1" data-attachment-id="46" data-permalink="https://blog.logrocket.com/vuex-showdown-mutations-vs-actions/1d0cd-1s_rmyo6nbrasp-xtvbaxfg/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg-e1565635879164.png" data-orig-size="730,412" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="LogRocket dashboard free trial banner" data-image-description="&lt;p&gt;LogRocket is working on the perfect frontend bug report. Try it free today.&lt;/p&gt;&#10;" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg-e1565635879164.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg-e1565635879164.png" decoding="async" loading="lazy" class="alignnone size-full wp-image-46" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/></noscript></a><a href="https://logrocket.com/signup/" target="_blank" rel="noopener noreferrer">https://logrocket.com/signup/</a></p>
<p>LogRocket 就像是网络应用的DVR，记录下你网站上发生的每一件事。您可以汇总并报告有问题的GraphQL请求，以快速了解根本原因，而不是猜测问题发生的原因。</p>
<p>LogRocket检测您的应用程序以记录基线性能计时，如页面加载时间、到达第一个字节的时间、慢速网络请求以及日志Redux、NgRx。和Vuex动作/状态。<a class="signup" href="https://logrocket.com/signup/" target="_blank" rel="noopener noreferrer">开始免费监控</a>。</p>
</div>
<h2>结论</h2>
<p>哒哒！我们只是用GraphQL做了端到端的CRUD操作。在客户端，引入React钩子后，读取和改变数据变得非常简单。Apollo Client还提供了身份验证、更好的错误处理、缓存和乐观UI。</p>
<p>订阅是GraphQL中另一个有趣的概念。有了这个应用程序作为样板，我们可以继续试验其他类似的概念！</p>
<p>编码快乐！</p><div class="code-block code-block-17">
<div class="blog-plug inline-plug react-plug" vwo-el-id="26283398190">
<h2 vwo-el-id="41600691720">使用LogRocket消除传统反应错误报告的噪音</h2>
<a href="https://lp.logrocket.com/blg/react-signup-issue-free" target="_blank" vwo-el-id="19356441070">LogRocket
</a><p>是一款React analytics解决方案，可保护您免受数百个误报错误警报的影响，只针对少数真正重要的项目。LogRocket告诉您React应用程序中实际影响用户的最具影响力的bug和UX问题。</p><a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="19356441380">
<img class="first-react-image alignnone size-full wp-image-46 jetpack-lazy-image jetpack-lazy-image--handled" src="../Images/f300c244a1a1cf916df8b4cb02bec6c6.png" vwo-el-id="18272717540" data-lazy-loaded="1" data-original-src="https://files.readme.io/27c94e7-Image_2017-06-05_at_9.46.04_PM.png"/>
</a>
<a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="19356441690">
<img class="second-react-image alignnone size-full wp-image-46 jetpack-lazy-image jetpack-lazy-image--handled" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" vwo-el-id="30720362350" data-lazy-loaded="1" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/>
</a>
<a href="https://lp.logrocket.com/blg/react-signup-issue-free" target="_blank" rel="noopener noreferrer" vwo-el-id="35866400580">LogRocket
</a><p>自动聚合客户端错误、反应错误边界、还原状态、缓慢的组件加载时间、JS异常、前端性能指标和用户交互。然后，LogRocket使用机器学习来通知您影响大多数用户的最具影响力的问题，并提供您修复它所需的上下文。</p><p vwo-el-id="28675661060">关注重要的React bug—<a class="signup" href="https://lp.logrocket.com/blg/react-signup-issue-free" target="_blank" rel="noopener noreferrer" vwo-el-id="40093418840">今天就试试LogRocket】。</a></p>
</div></div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
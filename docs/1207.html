<html>
<head>
<title>How JavaScript closures work, in plain English - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>JavaScript闭包如何工作，用简单的英语——log rocket博客</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/how-javascript-closures-work-in-plain-english/#0001-01-01">https://blog.logrocket.com/how-javascript-closures-work-in-plain-english/#0001-01-01</a></blockquote><div><article class="article-post">
<p>JavaScript是一种被广泛采用的语言，可以用来构建任何东西，从简单的登录页面到生产级的全栈应用程序。随着JavaScript和编程的发展，开发人员开始意识到面向对象编程(OOP)范式对于大多数用例来说是不可取的。函数式编程作为许多与OOP相关的棘手问题的解决方案而出现。</p>
<p>闭包是函数式编程领域中一个被广泛讨论的话题，但是它们的定义通常很松散，并且使用技术术语。我们将尽力用通俗的语言解释JavaScript闭包是如何工作的。</p>
<p>学完本教程后，您应该明白:</p>
<ul>
<li>如何识别闭包</li>
<li>什么是闭包，它的行为与执行上下文和调用堆栈有什么关系</li>
<li>闭包的常见用例</li>
</ul>
<h2>理解JavaScript闭包</h2>
<p>我们将从展示闭包是什么样子开始。</p>
<pre>function makeCounter() {
  let count = 0;
  return function increment() {
    count += 1;
    return count;
  };
};

const countIncrementor = makeCounter();
countIncrementor(); // returns 1
countIncrementor(); // returns 2</pre>
<p>尝试自己运行代码。从技术上讲，名为<code>makeCounter</code>的函数返回另一个名为<code>increment</code>的函数。即使在执行了<code>makeCount</code>函数之后，这个<code>increment</code>函数也可以访问<code>count</code>变量。这里闭包的一部分是<code>count</code>变量；即使在<code>makeCounter</code>完成之后，当它被定义时，它也可用于<code>increment</code>函数。另一部分是<code>increment</code>功能。</p>
<p>想象你有一栋房子和一个围绕着它的花园。一旦你打开了通向花园的门，又关上了，你就不能再打开它了——花园变得无法进入。你饿了，幸运的是，你的花园里有一棵橘子树和一棵苹果树。你拿一个小包，摘一个橘子和一个苹果，然后回到你的房子里。记住，你不能再出去了。</p>
<p>现在，一旦你在你的房子里，你可以把橘子或苹果从袋子里拿出来，当你再饿的时候就吃。这个例子中的小袋子是封闭的。一个闭包包含了所有的变量和函数，当你在花园里的时候，甚至当你在房子里不能再出去的时候。</p>
<p>让我们看看这是如何在代码中实现的:</p>
<pre>function makeFruitGarden() {
  let fruits = ['apple', 'orange'];
  return function() {
    return fruits.pop();
  };
};

const consumeFruit = makeFruitGarden();
consumeFruit(); // returns orange
consumeFruit(); // returns apple</pre>
<p>因为当执行<code>makeFruitGarden</code>时，返回的函数可以使用<code>fruits</code>变量，所以<code>fruits</code>变量和内部函数成为闭包。每当执行<code>consumeFruit</code>时，返回一个<code>fruit</code>——来自<code>fruits</code>数组的最后一个元素，因为<code>pop()</code>正在被使用。一旦两种水果都吃完了，就没什么可吃的了。</p>
<h2>理解词汇范围</h2>
<p>要真正理解闭包，您应该熟悉术语“作用域”相对于你所指的任何事物，词法范围是当前环境的一个奇特术语。</p>
<p>在下面的例子中，名为<code>myName</code>的变量的作用域称为“全局作用域”。</p>
<pre>// global scope
const<span> myName = </span><span>"John Doe"</span>

function displayName<span>() {</span>
<span>   // local/function scope</span>
<span>   </span><span>console</span><span>.log(myName);</span>
<span>};</span>

<span>displayName()</span></pre>
<p>在阅读<code>var</code>如何不是块范围的以及<code>const</code> / <code>let</code>如何是块范围的时，你可能已经看到了这个概念。值得注意的是，在JavaScript中，函数总是创建自己的作用域。这被称为<code>local</code>或<code>function</code>范围，如代码示例所示。</p>
<p>如果你一直在关注，你可能会认为<code>myName</code>和<code>displayName</code>是闭包的一部分。你是对的！但是因为这里的函数和变量存在于全局范围内，所以称之为闭包没有太大的价值。</p>
<p>JavaScript中有许多类型的作用域，但是对于闭包，有三种作用域您应该知道:</p>
<ol>
<li><strong>全局范围</strong>是每个人居住的默认范围。把它当成你的街道</li>
<li><strong>外部函数作用域</strong>是返回函数的函数。它有自己的范围。把它当成你的花园</li>
<li><strong>内部/局部函数作用域</strong>是成为闭包的返回函数。把它当成你的房子</li>
</ol>
<p>现在让我们深入一些用例。</p>
<h2>闭包的常见用例</h2>
<h3>携带</h3>
<p>函数currying是函数式编程中另一个强大的概念。要在JavaScript中实现curried函数，可以使用闭包。</p>
<p>Currying一个函数可以描述为转换一个函数，并且是这样执行的:<code>add(1, 2, 3)</code>到<code>add(1)(2)(3)</code>。</p>
<pre>function add(a) { 
  return function(b) {
    return function(c) {
      return a + b + c;
    };
  };
};

add(1)(2)(3) // returns 6</pre>
<p><code>add</code>函数接受一个参数，然后返回两个嵌套在一起的函数。currying的目标是接受一堆参数，最终得到一个值。</p>
<h3>高阶函数</h3>
<p>高阶函数的目标是将函数作为参数并返回结果。像<code>map</code>和<code>reduce</code>这样的数组方法就是高阶函数的例子。</p>
<pre>const arrayOfNumbers = [1, 2, 3];
const displayNumber = (num) =&gt; {
  console.log(num);
}
arrayOfNumbers.forEach(displayNumber)</pre>
<p>这里的<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach" target="_blank" rel="noopener noreferrer"> <code>Array.prototype.forEach</code> </a>高阶函数接受<code>displayNumber</code>作为参数，然后对<code>arrayOfNumbers</code>中的每个元素执行。如果您使用过Vue或React之类的UI框架，您可能会对高阶组件很熟悉，它们本质上与高阶函数是一回事。</p>
<p>那么高阶函数和currying有什么区别呢？高阶函数将函数作为参数返回值，而curried函数将函数作为结果返回，最终得到一个值。</p>
<h3>DOM元素管理器</h3>
<p>这是一种常见的设计模式，通常用于获取和设置DOM元素的属性。在下面的例子中，我们将制作一个元素管理器来设计元素的样式。</p><div class="code-block code-block-54">
<hr/>
<h3>更多来自LogRocket的精彩文章:</h3>

<hr/></div>
<pre>function makeStyleManager(selector) {
    const element = document.querySelector(selector);
    const currentStyles = {...window.getComputedStyle(element)};
 
    return {
        getStyle: function(CSSproperty) {
            return currentStyles[CSSproperty];
        },
        setStyle: function(CSSproperty, newStyle) {
            element.style[CSSproperty] = newStyle;
        },
    };
};

const bodyStyleManager = makeStyleManager('body');
bodyStyleManager.getStyle('background-color'); // returns rgb(0,0,0)
bodyStyleManager.setStyle('background-color', 'red'); // sets bg color to red</pre>
<p><code>makeStyleManager</code>返回一个对象，该对象提供对两个函数的访问，这两个函数是闭包的一部分，与<code>element</code>和<code>currentStyles</code>变量在一起。即使在<code>makeStyleManager</code>已经完成执行之后，<code>getStyle</code>和<code>setStyle</code>函数仍然可以访问变量。</p>
<h2>结论</h2>
<p>JavaScript闭包可能很难理解，即使对于有专业经验的开发人员来说也是如此。理解闭包最终会让你成为更好的开发人员。</p>
<p>当闭包被用在看起来奇怪或者没有意义的代码库中时，你现在应该能够识别它了。闭包是函数式编程中的一个关键概念，我希望这篇指南能帮助你在掌握它的过程中向前迈进一步。</p><div class="code-block code-block-27">
<div class="blog-plug inline-plug vanilla-javascript-cta"><h2>通过理解上下文，更容易地调试JavaScript错误</h2>
<p>调试代码总是一项单调乏味的任务。但是你越了解自己的错误，就越容易改正。</p>
<p>LogRocket 让你以新的独特的方式理解这些错误。我们的前端监控解决方案跟踪用户与您的JavaScript前端的互动，让您能够准确找出导致错误的用户行为。</p>
<a href="https://lp.logrocket.com/blg/javascript-signup" class="signup" target="_blank" rel="noopener noreferrer"><img class="alignnone size-full wp-image-46 jetpack-lazy-image" src="../Images/cbfed9be3defcb505e662574769a7636.png" alt="LogRocket Dashboard Free Trial Banner" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2020/06/reproduce-javascript-errors.gif?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/06/reproduce-javascript-errors.gif"/><noscript><img data-lazy-fallback="1" class="alignnone size-full wp-image-46" src="../Images/cbfed9be3defcb505e662574769a7636.png" alt="LogRocket Dashboard Free Trial Banner" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/06/reproduce-javascript-errors.gif"/></noscript></a>
<p>LogRocket记录控制台日志、页面加载时间、堆栈跟踪、慢速网络请求/响应(带有标题+正文)、浏览器元数据和自定义日志。理解您的JavaScript代码的影响从来没有这么简单过！</p>
<a class="signup" href="https://lp.logrocket.com/blg/javascript-signup" target="_blank" rel="noopener noreferrer">Try it for free</a><p>。</p></div>


</div>
<h3>进一步阅读</h3>


<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
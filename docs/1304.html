<html>
<head>
<title>Your reference guide to using TypeScript in React - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>React - LogRocket博客中使用TypeScript的参考指南</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/your-reference-guide-to-using-typescript-in-react/#0001-01-01">https://blog.logrocket.com/your-reference-guide-to-using-typescript-in-react/#0001-01-01</a></blockquote><div><article class="article-post">
<p>JavaScript的一个问题是它的动态类型特性，这意味着数据和变量类型在运行时之前是未知的。这可能会有很多副作用。例如，由于变量可以是任何东西，这可能会在您的代码库中造成混乱。</p>
<p>为了解决这个问题，微软发布了<a href="https://www.typescriptlang.org/" target="_blank" rel="noopener noreferrer"> TypeScript </a>。TypeScript的首席架构师安德斯·海尔斯伯格说，“如果我们可以用大规模应用程序开发所缺少的东西来增强JavaScript，比如静态类型、类[和]模块……会怎么样？这就是TypeScript的意义所在。”</p>
<p>TypeScript立即成为最广泛使用的JavaScript静态类型版本。它使JavaScript开发人员能够静态地输入数据和变量。很快，它被引入到<a href="https://reactjs.org/" target="_blank" rel="noopener noreferrer"> React.js </a>中，使React开发人员能够用TypeScript编写他们的React应用程序。</p>
<p>但这是有代价的:TypeScript的类型和语法可能很难跟上，尤其是在与React一起使用时。</p>
<p>React有很多特性，比如props，class组件，function组件，function params，组件生命周期钩子，成员属性。因为在TypeScript中输入这些内容并不容易，所以本文旨在作为初学者和高级React开发人员的快速参考和学习指南。</p>
<p>有了它，您将能够在React中快速查找最佳实践和通用TS类型。准备好了吗？让我们开始吧。</p>
<h2 id="typescripttypings">打字稿</h2>
<p>TypeScript有一个typings文件夹，用于保存扩展名为*.d.ts的文件。这些文件包括推断值将采取什么形状的接口。这就是TypeScript将数据类型引入JavaScript的原因。</p>
<p>接口描述了值的样子:</p>
<pre>type AppState {
    propOne: number;
    propTwo: string
}
</pre>
<p><code>AppState</code>描述其数据类型的值看起来像什么。首先，我们推断它将是一个拥有属性<code>propOne</code>和<code>propTwo</code>的对象，前者是数字类型，后者是字符串类型。将boolean类型赋给<code>propOne</code>会导致TypeScript抛出TypeError。</p>
<p>当我们在React项目中包含TypeScript时，每个React元素都有一个定义其形状的接口。让我们从功能组件开始。</p>
<h2 id="functioncomponent">功能组件</h2>
<p>函数组件是在React中返回JSX元素的普通函数，用于创建视图。最初，它们是无状态的组件，但是随着React钩子的出现，它们可以变成有状态的和智能的/</p>
<p>定义一个React函数组件采用<code>React.FunctionComponent</code>形状:</p>
<pre>function App: React.FunctionComponent&lt;&gt; {
    return (
        &lt;&gt;
            // ...
        &lt;/&gt;
    )
}
</pre>
<p>我们也可以使用简写<code>React.FC:</code></p>
<pre>function App: React.FC&lt;&gt; {
    return (
        &lt;&gt;
            // ...
        &lt;/&gt;
    )
}
</pre>
<p><code>React.FunctionComponent</code>或<code>React.FC</code>明确描述了函数组件的返回类型。</p>
<p>我们可以在箭头<code>&lt;&gt;</code>中键入道具定义。</p>
<pre>type AppProps = {
    message: string;
    age: number;
};
</pre>
<p><code>AppProps</code>是传递给<code>App</code>的道具将接受的接口，因此我们可以编写下面的<code>App</code>组件，如果它将接受道具的话:</p>
<pre>type AppProps {
    message: string;
    age: number;
}

function App: React.FC&lt;AppProps&gt;(props: AppProps) {
    return (
        &lt;&gt;
            // ...
        &lt;/&gt;
    )
}
</pre>
<p>我们可以使用<code>?</code>在输入中设置可选值:</p>
<pre>type AppProps {
    message: string;
    age?: number;
}
</pre>
<p>现在，年龄属性变成可选的。可以呈现<code>App</code>组件，省略其props对象中的age属性。</p>
<p>我们可以省略箭头<code>&lt;&gt;</code>中的类型声明。</p>
<pre>function App&lt;{message: string; age: number;}&gt;({message: string; age: number;}: AppProps) {
    // ...
}
</pre>
<p>功能组件中的内部函数可以被类型化，如下所示:</p>
<pre>function App&lt;{message: string; age: number;}&gt;({message: string; age: number;}: AppProps) {
    // ...

    function clickHandler (val: number) {
        // ...
    }

    return (
        &lt;&gt;
            &lt;button onClick={() =&gt; clickHandler(45)}            
        &lt;/&gt;
    )
}
</pre>
<h2 id="classcomponent">类别组件</h2>
<p>类组件用于在React中创建视图。它们本质上是积木。一个React应用程序可以包含许多这样的元素，它们定义了一个小的UI单元应该如何显示。</p>
<p>类组件有生命周期挂钩，我们可以在组件生命周期的任何状态下运行定制代码。</p>
<p>他们使用<code>React.Component&lt;&gt;</code>:</p>
<pre>class App extends React.Component&lt;&gt; {
    // ...    
}
</pre>
<h2>道具和状态</h2>
<p>您可以为类组件提供属性和状态类型参数:</p>
<pre>type AppProps = {
    message: string;
    age: number;
};

type AppState = {
    id: number;
};

class App extends React.Component&lt;AppProps, AppState&gt; {
    state: AppState = {
        id: 0
    };

    // ...    
}
</pre>
<p>道具类型<code>AppProps</code>插在状态类型<code>AppState</code>之前的<code>&lt;&gt;</code>箭头之间。</p>
<h2>类方法</h2>
<p>如果您有类方法的参数，这些参数可以是:</p>
<pre>class App extends React.Component&lt;AppProps, AppState&gt; {
    state: AppState = {
        id: 0
    };

    clickHandler = (val: number) =&gt; {
        // ...
    }

    render() {
        return (
            &lt;&gt;
                &lt;button onClick={() =&gt; this.clickHandler(90)}&gt;Click&lt;/button&gt;
            &lt;/&gt;
        )
    }
}
</pre>
<h1 id="functioncomponentsanddefaultpropstyping">功能组件和<code>defaultProps</code>打字</h1>
<p><span> <code>defaultProps</code>用于定义传递给React组件的props参数的默认值。<code>defaultProps</code>有助于防止在运行时一个假定可用的道具丢失时出现错误。<code>defaultValues</code>内的值立刻成为道具的值。</span></p>
<p>在函数组件中包含<code>defaultProps</code>时，<code>React.Fc</code>被删除，因为类型推理中的一些边缘情况在TypeScript中仍然是一个问题。</p>
<p>这意味着道具像平常一样使用:</p>
<pre>type AppProps = { message: string; age: number } &amp; typeof defaultProps;
const defaultProps = {
    message: "",
    age: 0
};

function App(props: AppProps) {
    // ...
};

App.defaultProps = defaultProps;
</pre>
<h2 id="formsandevents">表单和事件</h2>
<p><span>表格一般用于收集内部状态的信息。它们主要用于登录和注册页面，以便表单可以收集提交的信息并发送到服务器进行处理。</span></p>
<p><code>React.FormEvent</code>用于从元素中概括事件类型。</p>
<pre>class App extends React.Component&lt;&gt; {
    clickHandler = (e: React.FormEvent&lt;HTMLButtonElement&gt;) =&gt; {
        // ...
    }

    changeHandler = (e: React.FormEvent&lt;HTMLInputElement&gt;) =&gt; {
        // ...
    }

    render() {
        return (
            &lt;div&gt;
                &lt;button onClick={this.clickHandler}&gt;Click&lt;/button&gt;
                &lt;input type="text" onChange={this.changeHandler} /&gt;
            &lt;/div&gt;
        )
    }
}
</pre>
<p><code>clickHandler</code>和<code>changeHandler</code>论元<code>e</code>都具有<code>React.FormEvent</code>类型。</p><div class="code-block code-block-54">
<hr/>
<h3>更多来自LogRocket的精彩文章:</h3>

<hr/></div>
<p>我们可以省略用<code>React.FormEvent</code>键入处理程序的参数，而是键入处理程序的返回值。这是通过使用<code>React.ChangeEventHandler</code>完成的:</p>
<pre>class App extends React.Component&lt;&gt; {
    clickHandler: React.FormEvent&lt;HTMLButtonElement&gt; = (e) =&gt; {
        // ...
    }

    changeHandler: React.FormEvent&lt;HTMLInputElement&gt; = (e) =&gt; {
        // ...
    }

    render() {
        return (
            &lt;div&gt;
                &lt;button onClick={this.clickHandler}&gt;Click&lt;/button&gt;
                &lt;input type="text" onChange={this.changeHandler} /&gt;
            &lt;/div&gt;
        )
    }
}
</pre>
<p><code>React.ChangeEvent&lt;T&gt;</code>是可用于键入事件处理程序参数的事件类型:</p>
<pre>class App extends React.Component&lt;&gt; {
    clickHandler = (e: React.ChangeEvent&lt;HTMLButtonElement&gt;) =&gt; {
        // ...
    }

    changeHandler = (e: React.ChangeEvent&lt;HTMLInputElement&gt;) =&gt; {
        // ...
    }

    render() {
        return (
            &lt;div&gt;
                &lt;button onClick={this.clickHandler}&gt;Click&lt;/button&gt;
                &lt;input type="text" onChange={this.changeHandler} /&gt;
            &lt;/div&gt;
        )
    }
}
</pre>
<p>注意<code>T</code>是注册事件的元素的类型。</p>
<h3 id="button">纽扣</h3>
<p><span>这描述了React。按钮元素的ChangeEvent类型。按钮是HTMLButtonElement类的实例。这里，<code>T</code>会是<code>HTMLButtonElement</code>，并做出反应。变化事件将是<code>React.ChangeEvent</code>。</span></p>
<h3 id="inputs">输入</h3>
<p><span>这描述了所有输入元素的<code>React.ChangeEvent</code>:“文本”、“密码”、“颜色”、“按钮”、“媒体”等。它们都是HTMLInputElement类的实例。</span>对于所有类型=[“文本”、“密码”等]</p>
<p><code>T</code>将是<code>HTMLTnputElement</code>。做出反应。变化事件将是<code>React.ChangeEvent</code>。</p>
<h3 id="textarea">文本区域</h3>
<p><span>此指反应过来。文本区域元素的ChangeEvent和文本区域元素是HTMLTextAreaElement的实例。</span></p>
<p><code>T</code>将是<code>HTMLTextAreaElement</code>。<br/>做出反应。变化事件将是<code>React.ChangeEvent</code>。</p>
<h3 id="select">挑选</h3>
<p>Select元素用于创建一个带有选项的下拉列表。Select元素是HTMLSelectElement的实例。</p>
<p><code>T</code>将是<code>HTMLSelectElement</code>。做出反应。变化事件将是<code>React.ChangeEvent</code>。</p>
<h3 id="form">形式</h3>
<p>Form elements从DOM中收集信息。表单元素是HTMLFormElement的实例。t将<code>HTMLFormElement</code>。做出反应。ChangeEvent将是<code>React.ChangeEvent</code>。</p>
<h3 id="videoaudio">视频、音频</h3>
<p>视频用于在浏览器上播放视频。video元素是HTMLVideoElement的一个实例。这描述了如何设置React。表单元素中的ChangeEvent。</p>
<p><code>T</code>将是<code>HTMLVideoElement</code>。<br/>做出反应。变化事件将是<code>React.ChangeEvent</code>。</p>
<p><span>反过来，Audio用来播放音频文件(mp3，aac等。)在浏览器中。音频元素是HTMLAudioElement的实例。</span></p>
<p><code>T</code>将是<code>HTMLAudioElement</code>。<br/>做出反应。变化事件将是<code>React.ChangeEvent</code>。</p>
<h3><code>React.SyntheticEvent</code></h3>
<p>当您不关心事件的类型时，可以使用这种类型:</p>
<pre>class App extends React.Component&lt;&gt; {
    submitHandler = (e: React.SyntheticEvent) =&gt; {
        // ...
    }

    render() {
        return (
            &lt;form onSubmit={this.submitHandler}&gt;
                ...
            &lt;/form&gt;
        )
    }
}
</pre>
<h3>钩住</h3>
<p>react 16.8+支持钩子。它们允许我们在功能组件中使用状态。</p>
<h3><code>useState</code></h3>
<p><span>这用于设置功能组件中的状态，该状态在组件的整个生命周期中保持有效。</span></p>
<pre>const [state, setState] = useState(0)
</pre>
<p>我们可以推断出<code>state</code>是一个数字，而<code>setState</code>是一个接受数字的函数。</p>
<pre>const [state, setState] = useState&lt;number, (v: boolean) =&gt; : void &gt;(0)
</pre>
<p>如果国家接受一个对象:</p>
<pre>type StateObject = {
    loading: boolean
}

const [state, setState] = useState&lt;StateObject, (boolean) =&gt; : void &gt;({loading: true})
</pre>
<p>很多时候，<code>useState</code>的初始值是<code>null</code>。我们可以使用联合类型显式声明类型，如下所示:</p>
<pre>const [state, setState] = useState&lt;StateObject | null, (boolean) =&gt; : void &gt;(null)
</pre>
<p>这个<code>StateObject | null</code>告诉TypeScript状态可以是<code>StateObject</code>类型或者是<code>null</code>类型。</p>
<h3><strong>T2<code>useReducer</code></strong></h3>
<p>允许我们维护状态，同时从我们的功能组件向商店发送动作。它有一个初始状态和一个缩减函数:</p>
<pre>const intialState = {
    loggedIn: false
}

function reducer(state, action) {
    // ...    
}

const [state, dispatch ] = useReducer(initialState, reducer)
</pre>
<p>我们可以定义状态的类型，然后根据返回类型键入reducer函数。可以基于reducer函数上的动作参数类型来确定分派的类型:</p>
<pre>type LogginState = {
    loggedIn: boolean;
};

type ActionType = {
    type: string;
    payload: boolean;
};

const intialState: LogginState = {
    loggedIn: false
}

function reducer(state: LogginState, action: ActionType): LogginState {
    // ...    
}

const [state, dispatch ] = useReducer&lt;LogginState, (v: ActionType) =&gt; : void&gt;(initialState, reducer)
</pre>
<h3><code>useRef</code></h3>
<p><span> <code>useRef</code>允许我们访问React节点中的引用，并在组件的整个生命周期中维护它们。</span></p>
<p><code>null</code>类型大多被传递给<code>useRef</code>，所以类型应该是这样的:</p>
<pre>const ref= useRef&lt;HTMLElement | null&gt;(null)
</pre>
<p>我们可以更具体地说明我们试图引用的元素的类型:</p>
<pre>// this types useRef to button elements
const buttonRef= useRef&lt;HTMLButtonElement | null&gt;(null)

// this types useRef to input elements
const inputRef= useRef&lt;HTMLInputElement | null&gt;(null)
</pre>
<p>另外，<code>useRef</code>可以用在<code>React.Component</code>上:</p>
<pre>const inputRef= useRef&lt;React.Component | null&gt;(null)
</pre>
<h3><strong>使用上下文</strong></h3>
<p>useContext允许我们在功能组件的整个生命周期中创建和维护上下文。上下文是使用React上下文API创建的。</p>
<p>下面是如何使用<code>useContext</code>和<code>createContext</code>来创建一个上下文:</p>
<pre>const authContext = createContext({isAuth: true})
const context = useContext(authContext)
</pre>
<p><code>createContext</code>的缺省值类型将构成其参数类型的基础:</p>
<pre>type AuthType = {
    isAuth: boolean;
};

const authContext = createContext&lt;AuthType&gt;({isAuth: true})
</pre>
<p>另外，<code>useContext</code>参数类型将是<code>AuthType</code>:</p>
<pre>const context = useContext&lt;AuthType&gt;(authContext)
</pre>
<h2 id="conclusion">结论</h2>
<p>希望你发现这个指南信息丰富，有帮助。你还可以在<a href="https://github.com/typescript-cheatsheets/react" target="_blank" rel="noopener noreferrer"> this Github repo </a>中阅读更多关于React TypeScript类型推断的内容。</p><div class="code-block code-block-17">
<div class="blog-plug inline-plug react-plug" vwo-el-id="26283398190">
<h2 vwo-el-id="41600691720"><a href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener"> LogRocket </a>:全面了解您的生产React应用</h2><p>调试React应用程序可能很困难，尤其是当用户遇到难以重现的问题时。如果您对监视和跟踪Redux状态、自动显示JavaScript错误以及跟踪缓慢的网络请求和组件加载时间感兴趣，</p><a href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" vwo-el-id="19356441070">try LogRocket</a><p>. </p><a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="19356441380">
<img class="first-react-image alignnone size-full wp-image-46 jetpack-lazy-image jetpack-lazy-image--handled" src="../Images/f300c244a1a1cf916df8b4cb02bec6c6.png" vwo-el-id="18272717540" data-lazy-loaded="1" data-original-src="https://files.readme.io/27c94e7-Image_2017-06-05_at_9.46.04_PM.png"/>
</a>
<a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="19356441690">
<img class="second-react-image alignnone size-full wp-image-46 jetpack-lazy-image jetpack-lazy-image--handled" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" vwo-el-id="30720362350" data-lazy-loaded="1" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/>
</a>
<p vwo-el-id="28675660440" class="">LogRocket 结合了会话回放、产品分析和错误跟踪，使软件团队能够创建理想的web和移动产品体验。这对你来说意味着什么？</p>
<p>LogRocket不是猜测错误发生的原因，也不是要求用户提供截图和日志转储，而是让您回放问题，就像它们发生在您自己的浏览器中一样，以快速了解哪里出错了。</p>
<p>不再有嘈杂的警报。智能错误跟踪允许您对问题进行分类，然后从中学习。获得有影响的用户问题的通知，而不是误报。警报越少，有用的信号越多。</p>
<p vwo-el-id="28675660750">LogRocket Redux中间件包为您的用户会话增加了一层额外的可见性。LogRocket记录Redux存储中的所有操作和状态。</p>
<p vwo-el-id="28675661060">现代化您调试React应用的方式— <a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="40093418840">开始免费监控</a>。</p><div class="code-block code-block-21">
<div class="blog-plug inline-plug typescript-plug"><h2><a class="signup" href="https://lp.logrocket.com/blg/typescript-signup" target="_blank" rel="noopener noreferrer"> LogRocket </a>:全面了解您的网络和移动应用</h2>
<a href="https://lp.logrocket.com/blg/typescript-signup" class="signup" target="_blank" rel="noopener noreferrer"><img class="alignnone size-full wp-image-46 jetpack-lazy-image" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/><noscript><img data-lazy-fallback="1" class="alignnone size-full wp-image-46" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/></noscript></a>
<p>LogRocket 是一个前端应用程序监控解决方案，可以让您回放问题，就像问题发生在您自己的浏览器中一样。LogRocket不需要猜测错误发生的原因，也不需要向用户询问截图和日志转储，而是让您重放会话以快速了解哪里出错了。它可以与任何应用程序完美配合，不管是什么框架，并且有插件可以记录来自Redux、Vuex和@ngrx/store的额外上下文。</p>
<p>除了记录Redux操作和状态，LogRocket还记录控制台日志、JavaScript错误、堆栈跟踪、带有头+正文的网络请求/响应、浏览器元数据和自定义日志。它还使用DOM来记录页面上的HTML和CSS，甚至为最复杂的单页面和移动应用程序重新创建像素级完美视频。</p>
<a class="signup" href="https://lp.logrocket.com/blg/typescript-signup" target="_blank" rel="noopener noreferrer">Try it for free</a><p>.</p></div>
</div>
</div></div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
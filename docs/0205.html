<html>
<head>
<title>JavaScript typeof: Understanding type checking in JavaScript - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>JavaScript typeof:理解JavaScript - LogRocket博客中的类型检查</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/javascript-typeof-2511d53a1a62/#0001-01-01">https://blog.logrocket.com/javascript-typeof-2511d53a1a62/#0001-01-01</a></blockquote><div><article class="article-post">
<p>每种编程语言的一个非常重要的方面是它的类型系统和数据类型。对于像Java这样的严格类型编程语言，变量被定义为特定的类型，将变量限制为只包含该类型的值。</p>
<blockquote><p>然而，JavaScript是一种动态类型语言，尽管存在一些支持严格类型的扩展，如<a href="https://www.typescriptlang.org/" target="_blank" rel="noopener noreferrer"> TypeScript </a>。</p></blockquote>
<p>使用JavaScript，有可能一个变量开始时包含一个<code>string</code>，而在其生命周期的很长一段时间后，变成对一个<code>object</code>的引用。甚至在脚本执行过程中，JavaScript引擎会隐式强制值的类型。类型检查对于编写可预测的JavaScript程序非常重要。</p>
<blockquote><p>JavaScript有一个非常基本的用于类型检查的操作符<code><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/typeof" target="_blank" rel="noopener noreferrer">typeof</a></code>。</p></blockquote>
<p>但是，您会注意到使用这个操作符可能会产生误导，这一点我们将在本文中讨论。</p>
<h2 id="JavaScriptdatatypes">javascript日期</h2>
<p>在看用<code>typeof</code>进行类型检查之前，看一下JavaScript数据类型是很重要的。虽然本文没有深入讨论JavaScript数据类型的细节，但是随着研究的深入，您可以收集到一些信息。</p>
<p>在ES6之前，JavaScript有六种数据类型。在ES6规范中，增加了<code>Symbol</code>类型。以下是所有类型的列表:</p>
<ol>
<li>线</li>
<li>数字</li>
<li>布尔型(值<code>true</code>和<code>false</code>)</li>
<li>null(值<code>null</code>)</li>
<li>未定义(值<code>undefined</code>)</li>
<li>标志</li>
<li>目标</li>
</ol>
<p>前六种数据类型被称为<strong>原始类型</strong>。除了前六种数据类型之外，其他数据类型都是一个<em>对象</em>，并且可以被称为<strong>引用类型</strong>。一个<em>对象</em>类型只是名称和值对形式的属性集合。</p>
<p>注意列表中的<code>null</code>和<code>undefined</code>是原始的JavaScript数据类型，每个数据类型只包含一个值。</p>
<p>你可能会开始想:那么<em>数组</em>、<em>函数</em>、<em>正则表达式</em>等等呢？它们都是特殊种类的物体。</p>
<ul>
<li>一个<code><strong>array</strong></code>是一种特殊的对象，它是一个有序的编号值集合，具有特殊的语法和特征，这使得对它的处理不同于对常规对象的处理。</li>
<li><code><strong>function</strong></code>是一种特殊的对象，有一个可执行脚本块与之相关联。脚本块通过调用函数来执行。它还有一个特殊的语法和特征，使它不同于其他常规对象。</li>
</ul>
<p>JavaScript有几个对象类构造函数，用于创建其他类型的<em>对象</em>，例如:</p>
<ul>
<li><code>Date</code> —用于创建日期对象</li>
<li><code>RegExp</code> —用于创建正则表达式</li>
<li><code>Error</code> —用于创建JavaScript错误</li>
</ul>
<h2>使用<code>typeof</code>进行类型检查</h2>
<h3>句法</h3>
<p>JavaScript中的<code>typeof</code>操作符是一个一元操作符(只接受一个操作数),其计算结果是一个指示其操作数类型的字符串。就像其他一元运算符一样，它放在操作数之前，用空格隔开:</p>
<pre>typeof 53; <em>// "number"</em></pre>
<p>然而，有一种替代语法允许您像函数调用一样使用<code>typeof</code>,方法是将其操作数放在括号中。这对于对JavaScript表达式返回的值进行类型检查非常有用:</p>
<pre>typeof(typeof 53); <em>// "string"</em></pre>
<h3>错误安全</h3>
<p>在ES6之前，<code>typeof</code>操作符总是返回一个字符串，而不管它被用于哪个操作数。</p>
<blockquote><p>对于未声明的标识符，<code>typeof</code>将返回<code>“undefined”</code>，而不是抛出一个<code>ReferenceError</code>。</p></blockquote>
<pre>console.log(undeclaredVariable === undefined); // ReferenceError
console.log(typeof undeclaredVariable === 'undefined'); // tru</pre>
<p>然而，在ES6中，使用<code>let</code>或<code>const</code>关键字声明的块范围变量，如果在初始化之前与<code>typeof</code>操作符一起使用，仍然会抛出一个<code>ReferenceError</code>。这是因为:</p>
<blockquote><p>块范围的变量保持在<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/let#Temporal_Dead_Zone" target="_blank" rel="noopener noreferrer">时间死区</a>中，直到它们被初始化:</p></blockquote>
<pre>// Before block-scoped identifier: typeof =&gt; ReferenceError

console.log(typeof tdzVariable === 'undefined'); // ReferenceError

const tdzVariable = 'I am initialized.';</pre>
<h3>类型检查</h3>
<p>下面的代码片段显示了使用<code>typeof</code>操作符对公共值进行的类型检查:</p>
<pre>console.log(typeof ""); // "string"
console.log(typeof "hello"); // "string"
console.log(typeof String("hello")); // "string"
console.log(typeof new String("hello")); // "object"

console.log(typeof 0); // "number"
console.log(typeof -0); // "number"
console.log(typeof 0xff); // "number"
console.log(typeof -3.142); // "number"
console.log(typeof Infinity); // "number"
console.log(typeof -Infinity); // "number"
console.log(typeof NaN); // "number"
console.log(typeof Number(53)); // "number"
console.log(typeof new Number(53)); // "object"

console.log(typeof true); // "boolean"
console.log(typeof false); // "boolean"
console.log(typeof new Boolean(true)); // "object"

console.log(typeof undefined); // "undefined"

console.log(typeof null); // "object"

console.log(typeof Symbol()); // "symbol"

console.log(typeof []); // "object"
console.log(typeof Array(5)); // "object"

console.log(typeof function() {}); // "function"
console.log(typeof new Function); // "function"

console.log(typeof new Date); // "object"

console.log(typeof /^(.+)$/); // "object"
console.log(typeof new RegExp("^(.+)$")); // "object"

console.log(typeof {}); // "object"
console.log(typeof new Object); // "object"</pre>
<p>注意，所有的对象类型构造函数，当用关键字<code>new</code>实例化时，总是有一个类型<code>“object”</code>。唯一的例外是<code>Function</code>构造函数。</p>
<p>以下是结果的简单总结:</p>
<table>
<thead>
<tr>
<th>价值</th>
<th>类型of</th>
</tr>
</thead>
<tbody>
<tr>
<td><code><span class="kwd">undefined</span></code></td>
<td><code><span class="str">"undefined"</span></code></td>
</tr>
<tr>
<td><code><span class="kwd">null</span></code></td>
<td><code><span class="str">"object"</span></code></td>
</tr>
<tr>
<td><code><span class="kwd">true</span></code>或<code><span class="kwd">false</span></code></td>
<td><code><span class="str">"boolean"</span></code></td>
</tr>
<tr>
<td>所有数字或<code><span class="kwd">NaN</span></code></td>
<td><code><span class="str">"number"</span></code></td>
</tr>
<tr>
<td>所有字符串</td>
<td><code><span class="str">"string"</span></code></td>
</tr>
<tr>
<td>所有符号</td>
<td><code><span class="str">"symbol"</span></code></td>
</tr>
<tr>
<td>所有功能</td>
<td><code><span class="str">"function"</span></code></td>
</tr>
<tr>
<td>所有阵列</td>
<td><code><span class="str">"object"</span></code></td>
</tr>
<tr>
<td>本地对象</td>
<td><code><span class="str">"object"</span></code></td>
</tr>
<tr>
<td>宿主对象</td>
<td><em>取决于实施</em></td>
</tr>
<tr>
<td>其他对象</td>
<td><code><span class="str">"object"</span></code></td>
</tr>
</tbody>
</table>
<h2>更好的类型检查</h2>
<p>上一节的类型检查结果表明，一些值将需要额外的检查来进一步区分它们。例如:当使用<code>typeof</code>操作符完成类型检查时，<code>null</code>和<code>[]</code>都是<code>“object”</code>类型。</p>
<p>对价值的额外检查可以通过利用一些其他特征来完成:</p>
<ul>
<li>使用<code>instanceof</code>操作符</li>
<li>检查对象的<code>constructor</code>属性</li>
<li>使用对象的<code>toString()</code>方法检查对象类</li>
</ul>
<h3>检查是否为空</h3>
<p>正如您已经看到的，使用<code>typeof</code>操作符检查<code>“null”</code>值没有任何好处。检查<code>“null”</code>值的最好方法是对该值和<code>null</code>关键字进行严格的相等比较，如下面的代码片段所示。</p>
<pre>function isNull(value) {
  return value === null;
}</pre>
<p>这里使用严格的相等运算符(<code>===</code>)非常重要。下面的代码片段使用<code>undefined</code>值说明了这种重要性:</p>
<pre>console.log(undefined == null); // true
console.log(undefined === null); // false</pre>
<h3>正在检查NaN</h3>
<p><code>NaN</code>是算术运算导致未定义的值无法表示时收到的特殊值。比如:<code>(0 / 0) =&gt; NaN</code>。同样，当试图将一个没有原始数字表示的非数值转换成一个数字时，结果是<code>NaN</code>。</p>
<blockquote><p>任何涉及到<code>NaN</code>的算术运算将总是计算为<code>NaN</code>。</p></blockquote>
<p>如果你真的想在任何形式的算术运算中使用一个值，那么你要确保这个值不是<code>NaN</code>。</p>
<p>使用<code>typeof</code>操作符检查<code>NaN</code>值返回<code>“number”</code>。要检查<code>NaN</code>值，您可以使用全局<code>isNaN()</code>函数，或者最好使用ES6:</p>
<pre>console.log(isNaN(NaN)); // true
console.log(isNaN(null)); // false
console.log(isNaN(undefined)); // true
console.log(isNaN(Infinity)); // false

console.log(Number.isNaN(NaN)); // true
console.log(Number.isNaN(null)); // false
console.log(Number.isNaN(undefined)); // false
console.log(Number.isNaN(Infinity)); // false</pre>
<blockquote><p><code>NaN</code>值有一个非常特殊的特征。通过比较，它是唯一不等于任何其他值的JavaScript值，包括它本身:</p></blockquote>
<pre>var x = NaN;

console.log(x == NaN); // false
console.log(x === NaN); // false</pre>
<p>您可以按如下方式检查<code>NaN</code>:</p>
<pre><code>function isNan(value) {
  return value !== value;
}</code></pre>
<p>上述函数非常类似于ES6中添加的<code>Number.isNaN()</code>的实现，因此可以用作非ES6环境的polyfill，如下所示:</p>
<pre>Number.isNaN = Number.isNaN || (function(value) {
  return value !== value;
})</pre>
<p>最后，您可以利用ES6中添加的<code>Object.is()</code>函数来测试值是否为<code>NaN</code>。<code>Object.is()</code>函数检查两个值是否相同:</p>
<pre>function isNan(value) {
  return Object.is(value, Number.NaN);
}</pre>
<h3>检查数组</h3>
<p>使用<code>typeof</code>检查数组将返回<code>“object”</code>。有几种方法可以更好地检查数组，如下面的代码片段所示:</p>
<pre>// METHOD 1: constructor property
// Not reliable
function isArray(value) {
  return typeof value == 'object' &amp;&amp; value.constructor === Array;
}

// METHOD 2: instanceof
// Not reliable since an object's prototype can be changed
// Unexpected results within frames
function isArray(value) {
  return value instanceof Array;
}

// METHOD 3: Object.prototype.toString()
// Better option and very similar to ES6 Array.isArray()
function isArray(value) {
  return Object.prototype.toString.call(value) === '[object Array]';
}

// METHOD 4: ES6 Array.isArray()
function isArray(value) {
  return Array.isArray(value);
}</pre>
<h2>泛型类型检查</h2>
<p>正如数组一样，<code>Object.prototype.toString()</code>方法对于检查任何JavaScript值的对象类型非常有用。当使用<code>call()</code>或<code>apply()</code>在一个值上调用它时，它以<code><strong>[object Type]</strong></code>的格式返回对象类型，其中<code>Type</code>是对象类型。</p>
<p>考虑下面的代码片段:</p>
<pre>function type(value) {
  var regex = /^[object (S+?)]$/;
  var matches = Object.prototype.toString.call(value).match(regex) || [];
  
  return (matches[1] || 'undefined').toLowerCase();
}</pre>
<p>下面的代码片段显示了使用刚刚创建的<code>type()</code>函数进行类型检查的结果:</p>
<pre>console.log(type('')); // "string"
console.log(type('hello')); // "string"
console.log(type(String('hello'))); // "string"
console.log(type(new String('hello'))); // "string"

console.log(type(0)); // "number"
console.log(type(-0)); // "number"
console.log(type(0xff)); // "number"
console.log(type(-3.142)); // "number"
console.log(type(Infinity)); // "number"
console.log(type(-Infinity)); // "number"
console.log(type(NaN)); // "number"
console.log(type(Number(53))); // "number"
console.log(type(new Number(53))); // "number"

console.log(type(true)); // "boolean"
console.log(type(false)); // "boolean"
console.log(type(new Boolean(true))); // "boolean"

console.log(type(undefined)); // "undefined"

console.log(type(null)); // "null"

console.log(type(Symbol())); // "symbol"
console.log(type(Symbol.species)); // "symbol"

console.log(type([])); // "array"
console.log(type(Array(5))); // "array"

console.log((function() { return type(arguments) })()); // "arguments"

console.log(type(function() {})); // "function"
console.log(type(new Function)); // "function"

console.log(type(class {})); // "function"

console.log(type({})); // "object"
console.log(type(new Object)); // "object"

console.log(type(/^(.+)$/)); // "regexp"
console.log(type(new RegExp("^(.+)$"))); // "regexp"

console.log(type(new Date)); // "date"
console.log(type(new Set)); // "set"
console.log(type(new Map)); // "map"
console.log(type(new WeakSet)); // "weakset"
console.log(type(new WeakMap)); // "weakmap"</pre>
<h2>额外的事实:一切都不是物体</h2>
<p>很有可能在某个时候，你可能会遇到这样一句话:</p>
<blockquote><p>" JavaScript中的一切都是对象."—(错误)</p></blockquote>
<p>这可能会非常误导人，事实上，<strong>不是真的</strong>。JavaScript中的一切都不是对象。原语不是对象。</p>
<p>你可能会开始疑惑——如果原语不是对象，为什么我们可以对它们进行以下操作？</p>
<ul>
<li><code><strong>(“Hello World!”).length</strong></code> —获取字符串的<code>length</code>属性</li>
<li><code><strong>(“Another String”)[8]</strong></code> —获取索引处字符串的字符<code>8</code></li>
<li><code><strong>(53.12345).toFixed(2)</strong></code> —在数字上调用<code>Number.prototype.toFixed()</code>方法</li>
</ul>
<p>我们之所以可以用原语来实现这些，是因为JavaScript引擎隐式地为原语创建了一个对应的<strong> <em>包装对象</em> </strong>，并在其上调用方法或访问属性。</p>
<p>当值返回后，包装对象被丢弃并从内存中移除。对于前面列出的操作，JavaScript引擎隐式执行以下操作:</p>
<pre>// wrapper object: new String("Hello World!")
(new String("Hello World!")).toLowerCase();

// wrapper object: new String("Another String")
(new String("Another String"))[8];

// wrapper object: new Number(53.12345)
(new Number(53.12345)).toFixed(2);</pre>
<h2>结论</h2>
<p>在本文中，您已经了解了JavaScript类型系统及其数据类型，以及如何使用<code>typeof</code>操作符执行类型检查。</p>
<p>您还看到了使用<code>typeof</code>操作符进行类型检查会产生多大的误导。最后，您看到了为某些数据类型实现可预测类型检查的几种方法。</p>
<p>如果你有兴趣获得一些关于JavaScript <code>typeof</code>操作符的附加信息，你可以参考<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/typeof" target="_blank" rel="noopener noreferrer">这篇文章</a>。</p>
<p>快乐编码…</p><div class="code-block code-block-27">
<div class="blog-plug inline-plug vanilla-javascript-cta"><h2>通过理解上下文，更容易地调试JavaScript错误</h2>
<p>调试代码总是一项单调乏味的任务。但是你越了解自己的错误，就越容易改正。</p>
<p>LogRocket 让你以新的独特的方式理解这些错误。我们的前端监控解决方案跟踪用户与您的JavaScript前端的互动，让您能够准确找出导致错误的用户行为。</p>
<a href="https://lp.logrocket.com/blg/javascript-signup" class="signup" target="_blank" rel="noopener noreferrer"><img class="alignnone size-full wp-image-46 jetpack-lazy-image" src="../Images/cbfed9be3defcb505e662574769a7636.png" alt="LogRocket Dashboard Free Trial Banner" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2020/06/reproduce-javascript-errors.gif?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/06/reproduce-javascript-errors.gif"/><noscript><img data-lazy-fallback="1" class="alignnone size-full wp-image-46" src="../Images/cbfed9be3defcb505e662574769a7636.png" alt="LogRocket Dashboard Free Trial Banner" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/06/reproduce-javascript-errors.gif"/></noscript></a>
<p>LogRocket记录控制台日志、页面加载时间、堆栈跟踪、慢速网络请求/响应(带有标题+正文)、浏览器元数据和自定义日志。理解您的JavaScript代码的影响从来没有这么简单过！</p>
<a class="signup" href="https://lp.logrocket.com/blg/javascript-signup" target="_blank" rel="noopener noreferrer">Try it for free</a><p>.</p></div>


</div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
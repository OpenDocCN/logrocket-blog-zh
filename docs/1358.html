<html>
<head>
<title>Implementing animated toasts in React - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>在React - LogRocket博客中实现动画祝酒</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/implementing-animated-toasts-in-react/#0001-01-01">https://blog.logrocket.com/implementing-animated-toasts-in-react/#0001-01-01</a></blockquote><div><article class="article-post">

<p>toast是一个UI元素，它以不中断的方式向用户提供消息。它们通常从屏幕底部弹出，过一会儿就消失了。</p>
<p>出于本文的目的，假设我们想要构建祝酒词，这样，在挂载时，它们会淡入屏幕的右下方。当我们添加另一个吐司时，前一个吐司应该会活跃起来，新的吐司在最后淡入。为此，我们将使用帧运动和反应门户。</p>
<p>我们还希望有一个功能，关闭所有的祝酒词在一起。为此，最好有一个专门负责祝酒的中央政府管理机构。我们将使用Zustand。</p>
<p>它还能让我们做一些高级的事情，比如设置屏幕上可以显示多少祝酒词的限制，以及设置祝酒词应该消失的默认持续时间。然而，实现高级的东西留给读者作为练习。</p>
<p>这将是成品:</p>
<p><img data-attachment-id="29899" data-permalink="https://blog.logrocket.com/implementing-animated-toasts-in-react/react-toasts-implementation-preview/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/12/react-toasts-implementation-preview.gif" data-orig-size="730,819" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="React toasts implementation preview" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/12/react-toasts-implementation-preview-267x300.gif" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/12/react-toasts-implementation-preview.gif" decoding="async" class="aligncenter size-full wp-image-29899 jetpack-lazy-image" src="../Images/3f3b742c5be20a249e007cd356759fbb.png" alt="Preview of Our React Toasts Implementation" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2020/12/react-toasts-implementation-preview.gif?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/12/react-toasts-implementation-preview.gif"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="29899" data-permalink="https://blog.logrocket.com/implementing-animated-toasts-in-react/react-toasts-implementation-preview/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/12/react-toasts-implementation-preview.gif" data-orig-size="730,819" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="React toasts implementation preview" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/12/react-toasts-implementation-preview-267x300.gif" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/12/react-toasts-implementation-preview.gif" decoding="async" loading="lazy" class="aligncenter size-full wp-image-29899" src="../Images/3f3b742c5be20a249e007cd356759fbb.png" alt="Preview of Our React Toasts Implementation" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/12/react-toasts-implementation-preview.gif"/></noscript>
<p>你可以在这个代码沙箱中玩<a href="https://codesandbox.io/s/simple-toast-with-zustand-framer-motion-re7hr?file=/src/App.js:572-678">演示。</a></p>
<h2>React toast实现的结构</h2>
<p>对于我们的动画祝酒词，我们将像制作图书馆一样对待它。该库可以有许多部分，但只有一部分向用户公开。我们将创建一个包含三个部分的<code>Toasts.js</code>文件:</p>
<ol>
<li><strong>我们的Zustand存储的一个钩子</strong>:我们通过向它传递初始状态和更新方法来初始化一个Zustand存储。然后它返回一个<a href="https://blog.logrocket.com/react-custom-hooks-and-the-death-of-render-props-a0ce5cba387f/">定制钩子</a>，我们将在<code>Toast</code>组件和<code>useToastControls</code>钩子中使用它。</li>
<li><strong> <code>Toast</code>组件</strong>:该组件从Zustand定制钩子中获取商店状态，并决定是否应该呈现toast内容。</li>
<li><strong> <code>useToastControls</code>自定义挂钩</strong>:我们不能让用户完全访问Zustand商店，所以我们将导出这个自定义挂钩。</li>
</ol>
<h2>我们烤面包的用法</h2>
<p>在我们开始实现上述每一项之前，让我们看看它将如何被典型地使用:</p>
<pre>import { Toast, useToastControls } from "./Toasts";
function App() {
 const { show, closeAll } = useToastControls();
 return (
   &lt;div className="app"&gt;
     &lt;button onClick={() =&gt; show('toast-first')}&gt;Show Toast&lt;/button&gt;
     &lt;button onClick={closeAll}&gt;Close all&lt;/button&gt;
     &lt;Toast uniqueId="toast-first" className="toast-blue"&gt;
       Hey! I'm a toast
     &lt;/Toast&gt;
   &lt;/div&gt;
 );
}
</pre>
<p>我们可以渲染任意数量的<code>Toast</code>组件，但是每个组件都应该有一个<code>uniqueId</code>道具。</p>
<p>我们还可以选择给toast一些类或内容来呈现在里面。<code>useToastsControl</code>定制钩子将会给我们类似于<code>show</code>、<code>close</code>和<code>closeAll</code>的方法。为了显示一个祝酒词，我们必须将这个祝酒词的<code>uniqueId</code>传递给<code>show</code>方法。</p>
<p>因为我们需要使用React portals来呈现toast，所以我们需要一个已经存在于页面中的DOM节点。为此，我们将把<code>index.html</code>(在CRA应用程序中)改为:</p>
<pre> &lt;div id="root"&gt;&lt;/div&gt;
 &lt;div id="toasts-portal"&gt;&lt;/div&gt;
</pre>
<p>我们还将添加一些CSS来定位右下角的<code>#toasts-portal</code>容器。然后我们将把它做成一个flexbox，这样烤面包片就可以堆叠在一起，中间留有空隙。</p>
<pre class="language-css">#toasts-portal {  
  position: absolute;
  bottom: 20px;
  right: 20px;
  display: flex;
  flex-direction: column;
  align-items: flex-end;
  gap: 30px;
}</pre>
<h2>实施时间！</h2>
<p>现在我们知道了它将如何被使用，让我们继续实现<code>Toasts.js</code>文件的三个部分。</p>
<h3>祖斯坦德商店</h3>
<p>Zustand是一个小型的(~700B)状态管理库。它的工作方式是我们用回调函数调用<code>create</code>方法。这个函数返回一个存储对象。我们可以在存储中保存各种状态，以及可以更新状态的方法。</p>
<p>然后，<code>create</code>方法返回一个定制钩子，在我们的例子中，我们将其命名为<code>useToastStore</code>。我们可以在任何React组件中调用这个自定义钩子来访问保存在Zustand存储中的状态和方法。</p>
<blockquote><p><strong>side note:</strong>Zustand的伟大之处在于，我们并不局限于一个商店，我们可以针对不同的使用情况创建多个商店。就像吐司一样，模态可以有自己的存储，API缓存可以有不同的存储，用户会话管理也可以有不同的存储，等等。如果一个存储中的某些状态发生变化，则只有使用该存储的组件才会重新呈现，而无需任何额外的比较。</p></blockquote>
<p>在<code>Toasts.js</code>中，Zustand店是这样做的。请记住，它不是导出的:</p>
<pre>const useToastStore = create((set, get) =&gt; ({
 toastList: new Set(),
 show(toastId) {
   const { toastList } = get();
   const newToastList = new Set(toastList);
   newToastList.add(toastId);
   set({
     toastList: newToastList
   });
 },
 close(toastId) {
   const { toastList } = get();
   const newToastList = new Set(toastList);
   newToastList.delete(toastId);
   set({
     toastList: newToastList
   });
 },
 closeAll() {
   const newToastList = new Set();
   set({
     toastList: newToastList
   });
 }
}));
</pre>
<p>回调函数返回一个状态名为<code>toastList</code>的对象和三个方法:<code>show</code>、<code>close</code>和<code>closeAll</code>。</p>
<p><code>toastList</code>状态是一个<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set"> <code>Set</code>对象</a>，我们将在其中存储当前显示在屏幕上的toast IDs列表。为什么我选择了<code>Set</code>？因为它确保了其中的每个ID都是唯一的。此外，我厌倦了对所有事情都使用数组。</p>
<p>然后，这些方法负责从<code>toastList</code>添加或删除toast IDs。<code>show</code>方法接受一个<code>toastId</code>作为参数。它通过调用<code>get</code>方法获得<code>toastList</code>状态，然后用现有<code>toastList</code>的值创建一个新的<code>Set</code>实例。</p>
<p>之后，<code>toastId</code>被加到<code>newToastList</code>上。最后，我们使用<code>set</code>方法将<code>toastList</code>状态设置为<code>newToastList</code>。</p>
<p><code>closeAll</code>方法只是将<code>toastList</code>设置为一个空的<code>Set</code>实例。我们需要在每个方法中创建一个新的<code>Set</code>实例的原因是，就像在React中一样，Zustand中的状态更新需要是不可变的。</p>
<p>此外，如果您想知道这些<code>get</code>和<code>set</code>方法来自哪里，请检查回调函数的开头——它接收这些方法作为参数。</p>
<h3><code>Toast</code>组件</h3>
<p><code>Toast</code>组件完成了大部分繁重的工作，所以我们将一步一步地实现它:</p>
<ol>
<li>访问商店并检查它是否应该呈现任何内容</li>
<li>如果内容呈现，则制作动画</li>
<li>声明一段时间后自动关闭的效果</li>
</ol>
<h4>步骤1:进入商店</h4>
<p>在组件内部，我们称之为<code>useToastStore</code>定制钩子。默认情况下，它会返回存储中的所有内容。这意味着如果存储中有任何变化，那么<code>Toast</code>组件将重新呈现。</p>
<p>如果你有小商店，那么这不是一个问题。但是当它成为一个问题时，你可以这样做:</p>
<pre>import shallow from "zustand/shallow";
export function Toast(props) {
 const { uniqueId, config = {}, className, children } = props;
 const { duration = 3500, role = "status" } = config;
 const { toastList, close } = useToastStore(
   (store) =&gt; ({
     toastList: store.toastList,
     close: store.close
   }),
   shallow
 );
 const isShown = toastList.has(uniqueId);
 return (); // will be expanded in the next step
}
</pre>
<p>因为我们只需要<code>toastList</code>状态和<code>close</code>方法，所以我们可以有选择地从商店中只挑选这两个。这是通过将一个选择器函数传递给<code>useToastStore</code>来完成的。选择器返回一个对象，所以我们也会告诉<code>useToastStore</code>对选择器返回的数据进行浅层比较。这与新的Redux挂钩的使用方式类似。</p>
<p>现在我们已经有了来自商店的<code>toastList</code>和来自<code>Toast</code>组件道具的<code>uniqueId</code>，我们可以用<code>toastList.has</code>方法检查<code>uniqueId</code>是否属于<code>toastList</code>。我们将它的结果存储在<code>isShown</code>变量中，我们将在下一步中使用它。</p><div class="code-block code-block-54">
<hr/>
<h3>更多来自LogRocket的精彩文章:</h3>

<hr/></div>
<h4>步骤2:制作内容动画</h4>
<p>我们需要在<code>"#toasts-portal"</code> DOM节点中呈现toast的内容，以便它总是从屏幕底部进入。为此，我们将使用门户。</p>
<p>为了让输入动画工作，我们将使用来自Framer Motion的<code>motion</code>实用程序。当<code>isShown</code>为真时，<code>motion.div</code>组件将挂载，它将从<code>initial</code>属性中提供的值转换为<code>animate</code>属性的值。</p>
<p>但是当<code>isShown</code>变为false并且<code>motion.div</code>组件卸载时，我们也想要一个退出动画。为此，我们需要将所有东西包装在<code>AnimatePresence</code>组件中，并将一个惟一的键传递给<code>motion.div</code>组件。然后我们可以使用<code>exit</code>道具指定退出动画。注意<code>AnimatePresence</code>将保持安装状态，与<code>isShown</code>无关。</p>
<p>另一件有趣的事情是，我们将一个布局道具传递给了<code>motion.div</code>，这确保了一个祝酒词的向上移动也是动画的。除此之外，它只是一个简单的div，包含类、相关的ARIA角色和子元素。</p>
<pre>import { AnimatePresence, motion } from "framer-motion";
export function Toast(props) {
 // stuff from previous step
 return createPortal(
   &lt;AnimatePresence&gt;
     {isShown &amp;&amp; (
       &lt;motion.div
         key={uniqueId}
         layout
         initial={{ opacity: 0, y: 50, scale: 0.3 }}
         animate={{ opacity: 1, y: 0, scale: 1 }}
         exit={{ opacity: 0, y: 20, scale: 0.5 }}
         className={cn("toast", className)}
         role={role}
       &gt;
         {children}
       &lt;/motion.div&gt;
     )}
   &lt;/AnimatePresence&gt;,
   document.querySelector("#toasts-portal")
 );
}
</pre>
<h4>步骤3:声明关闭自身的效果</h4>
<p>组件的最后一部分是声明一个关闭toast的效果。在给定的持续时间之后，我们调用Zustand商店的<code>close</code>方法，并将<code>uniqueId</code>道具作为其参数。</p>
<pre>import { useEffect } from "react";
export function Toast(props) {
 const isShown = toastList.has(uniqueId);
 useEffect(() =&gt; {
   if (!duration || !isShown) {
     return;
   }
   const timeoutId = setTimeout(() =&gt; {
     close(uniqueId);
   }, duration);
   return () =&gt; {
     clearTimeout(timeoutId);
   };
 }, [uniqueId, isShown, duration, close]);
}
</pre>
<p>至此，我们已经完成了<code>Toast</code>组件的实现。下一部分是我添加的一点额外的东西，只是为了展示一个库如何隐藏内部实现细节。</p>
<h3><code>useToastControls</code>定制挂钩</h3>
<p>我们的toast实现封装了向用户显示消息的逻辑。好处是内部实现可以在不破坏任何用户代码的情况下改变。</p>
<p>在<code>Toasts.js</code>中，Zustand商店是一个实现细节。它包含了<code>toastList</code>集合。如果用户获得了<code>toastList</code>的访问权限，他们可能会随心所欲地修改它，从而导致错误。因此，我们希望添加约束，这样用户可以调用<code>show</code>、<code>close</code>和<code>closeAll</code>方法，但不能直接修改<code>toastList</code>状态。</p>
<p>为此，我们定制了一个钩子来选择<code>show</code>、<code>close</code>和<code>closeAll </code>方法并返回它们。现在我们可以导出这个定制钩子。</p>
<pre>export function useToastControls() {
 const controls = useToastStore(
   (store) =&gt; ({
     show: store.show,
     close: store.close,
     closeAll: store.closeAll
   }),
   shallow
 );
 return controls;
}
</pre>
<h2>结论</h2>
<p>把所有东西放在一起，你可以看到我们完成的<code>Toasts.js</code>在这个<a href="https://codesandbox.io/s/simple-toast-with-zustand-framer-motion-re7hr?file=/src/Toasts.js:1005-1035">代码沙箱</a>中是什么样子。</p>
<p>我希望你喜欢这篇文章，并且至少学到了一个新东西。您可以<a href="https://twitter.com/dev__adi">在Twitter </a>上关注我，获取关于新文章的更新，并讨论各种web开发主题。</p><div class="code-block code-block-17">
<div class="blog-plug inline-plug react-plug" vwo-el-id="26283398190">
<h2 vwo-el-id="41600691720"><a href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener"> LogRocket </a>:全面了解您的生产React应用</h2><p>调试React应用程序可能很困难，尤其是当用户遇到难以重现的问题时。如果您对监视和跟踪Redux状态、自动显示JavaScript错误以及跟踪缓慢的网络请求和组件加载时间感兴趣，</p><a href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" vwo-el-id="19356441070">try LogRocket</a><p>. </p><a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="19356441380">
<img class="first-react-image alignnone size-full wp-image-46 jetpack-lazy-image jetpack-lazy-image--handled" src="../Images/f300c244a1a1cf916df8b4cb02bec6c6.png" vwo-el-id="18272717540" data-lazy-loaded="1" data-original-src="https://files.readme.io/27c94e7-Image_2017-06-05_at_9.46.04_PM.png"/>
</a>
<a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="19356441690">
<img class="second-react-image alignnone size-full wp-image-46 jetpack-lazy-image jetpack-lazy-image--handled" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" vwo-el-id="30720362350" data-lazy-loaded="1" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/>
</a>
<p vwo-el-id="28675660440" class="">LogRocket 结合了会话回放、产品分析和错误跟踪，使软件团队能够创建理想的web和移动产品体验。这对你来说意味着什么？</p>
<p>LogRocket不是猜测错误发生的原因，也不是要求用户提供截图和日志转储，而是让您回放问题，就像它们发生在您自己的浏览器中一样，以快速了解哪里出错了。</p>
<p>不再有嘈杂的警报。智能错误跟踪允许您对问题进行分类，然后从中学习。获得有影响的用户问题的通知，而不是误报。警报越少，有用的信号越多。</p>
<p vwo-el-id="28675660750">LogRocket Redux中间件包为您的用户会话增加了一层额外的可见性。LogRocket记录Redux存储中的所有操作和状态。</p>
<p vwo-el-id="28675661060">现代化您调试React应用的方式— <a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="40093418840">开始免费监控</a>。</p>
</div></div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
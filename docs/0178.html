<html>
<head>
<title>Leveraging the Console API in React apps - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>在React apps - LogRocket博客中利用控制台API</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/leveraging-the-console-api-in-react-apps-44df6d1ebeb2/#0001-01-01">https://blog.logrocket.com/leveraging-the-console-api-in-react-apps-44df6d1ebeb2/#0001-01-01</a></blockquote><div><div class="mainheading">


<h1 class="posttitle">在React应用中利用控制台API</h1>
<h2 class="post-subtitle"/>
<p><span class="post-date"><time class="post-date">2017年3月15日</time> </span> <span class="dot"/> <span class="readingtime"> 2分钟阅读</span> <span class="wordcount"> 740 </span> <span class="logrocket_editor"/></p>
</div>
<article class="article-post">
<p>大多数JavaScript开发人员都熟悉<code>console</code> API，尤其是<code>console.log()</code>。然而，有许多鲜为人知的控制台方法在开发和调试工作流中都非常有用。在这篇文章中，我将演示其中的一些方法，并展示它们在构建React应用程序时如何特别有用。</p>
<h4>Console.time()</h4>
<p><code>time</code>方法允许您测量不同事件之间的时间:</p>
<figure><img decoding="async" src="../Images/5b516c05365a78816cecf2dfc8a2bc87.png" data-height="546" data-width="1462" data-lazy-src="https://storage.googleapis.com/blog-images-backup/1*d3nq-yHbFKzN6pe5Rwt6Og.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" class=" jetpack-lazy-image" data-original-src="https://storage.googleapis.com/blog-images-backup/1*d3nq-yHbFKzN6pe5Rwt6Og.png"/><noscript><img data-lazy-fallback="1" decoding="async" src="../Images/5b516c05365a78816cecf2dfc8a2bc87.png" data-height="546" data-width="1462" data-original-src="https://storage.googleapis.com/blog-images-backup/1*d3nq-yHbFKzN6pe5Rwt6Og.png"/></noscript></figure>
<figure><img decoding="async" src="../Images/7ee8b9f6fb0d09b82686ce3814769337.png" data-height="194" data-width="484" data-lazy-src="https://storage.googleapis.com/blog-images-backup/1*Y8K-mZtJn4MdBhiQ4mvQtw.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" class=" jetpack-lazy-image" data-original-src="https://storage.googleapis.com/blog-images-backup/1*Y8K-mZtJn4MdBhiQ4mvQtw.png"/><noscript><img data-lazy-fallback="1" decoding="async" src="../Images/7ee8b9f6fb0d09b82686ce3814769337.png" data-height="194" data-width="484" data-original-src="https://storage.googleapis.com/blog-images-backup/1*Y8K-mZtJn4MdBhiQ4mvQtw.png"/></noscript></figure>
<p>对于每个计时器，您可以指定一个名称(在本例中为“Timer 1”)，以便在控制台中查看结果。给定计时器的<code>console.time</code>和<code>console.timeEnd</code>不必在同一个闭包里——它们在你的应用程序中是全局的。如果您希望对跨不同React组件或Redux操作发生的事务进行计时，这是很有帮助的。例如，通过在Redux动作分派周围放置一个计时器，可以看到动作的效果在UI中传播需要多长时间。</p>
<p>在组件级别，<code>console.time</code>让您看到给定组件挂载和渲染大约需要多长时间:</p>
<figure><img decoding="async" src="../Images/1c5fcff27319a0ac76b299f79629883b.png" data-height="714" data-width="1360" data-lazy-src="https://storage.googleapis.com/blog-images-backup/1*Pkz5LQUk46OPFQBwTsCKiQ.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" class=" jetpack-lazy-image" data-original-src="https://storage.googleapis.com/blog-images-backup/1*Pkz5LQUk46OPFQBwTsCKiQ.png"/><noscript><img data-lazy-fallback="1" decoding="async" src="../Images/1c5fcff27319a0ac76b299f79629883b.png" data-height="714" data-width="1360" data-original-src="https://storage.googleapis.com/blog-images-backup/1*Pkz5LQUk46OPFQBwTsCKiQ.png"/></noscript></figure>
<p>在这里，我们在组件的<code>constructor</code>中启动计时器，并在<code>componentDidMount</code>中结束它，它为第一个挂载+渲染周期计时。</p>
<h4>Console.count()</h4>
<figure><img decoding="async" src="../Images/8cd969208b63ad16f061c4f0d043e131.png" data-height="218" data-width="1140" data-lazy-src="https://storage.googleapis.com/blog-images-backup/1*inDLI7qg9yNCnrE_JZAmrw.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" class=" jetpack-lazy-image" data-original-src="https://storage.googleapis.com/blog-images-backup/1*inDLI7qg9yNCnrE_JZAmrw.png"/><noscript><img data-lazy-fallback="1" decoding="async" src="../Images/8cd969208b63ad16f061c4f0d043e131.png" data-height="218" data-width="1140" data-original-src="https://storage.googleapis.com/blog-images-backup/1*inDLI7qg9yNCnrE_JZAmrw.png"/></noscript></figure>
<figure><img decoding="async" src="../Images/b5566cba092f768ff58ea5cccf12ffe7.png" data-height="170" data-width="772" data-lazy-src="https://storage.googleapis.com/blog-images-backup/1*Vu3Bi2c667dh_jh0egCo_w.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" class=" jetpack-lazy-image" data-original-src="https://storage.googleapis.com/blog-images-backup/1*Vu3Bi2c667dh_jh0egCo_w.png"/><noscript><img data-lazy-fallback="1" decoding="async" src="../Images/b5566cba092f768ff58ea5cccf12ffe7.png" data-height="170" data-width="772" data-original-src="https://storage.googleapis.com/blog-images-backup/1*Vu3Bi2c667dh_jh0egCo_w.png"/></noscript></figure>
<p><code>console.count()</code>是一个恰当命名的计算给定值的方法。这不需要过多的解释，但是我会注意到它有助于计算组件的<code>render</code>方法被调用的次数。这在调试性能问题时非常有用，并且不需要手动计算组件的render方法中打印了多少次<code>console.log()</code>。</p>
<h4>Console.group()</h4>
<figure><img decoding="async" src="../Images/598e1f6e96a3e73a419c16a350aa9dcb.png" data-height="230" data-width="556" data-lazy-src="https://storage.googleapis.com/blog-images-backup/1*sGy1nnWCxPpglqgnPQsnKg.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" class=" jetpack-lazy-image" data-original-src="https://storage.googleapis.com/blog-images-backup/1*sGy1nnWCxPpglqgnPQsnKg.png"/><noscript><img data-lazy-fallback="1" decoding="async" src="../Images/598e1f6e96a3e73a419c16a350aa9dcb.png" data-height="230" data-width="556" data-original-src="https://storage.googleapis.com/blog-images-backup/1*sGy1nnWCxPpglqgnPQsnKg.png"/></noscript></figure>
<p><code>console.group()</code>允许您在控制台的可扩展选项卡下将日志分组。这有助于将相关日志放在一起，而不会让控制台变得太嘈杂。</p>
<p>添加一个<code>console.group()</code>语句后，所有后续的日志语句都放在组标题下。要停止在组中放置日志，只需添加<code>console.groupEnd()</code>。</p>
<p>上面的输出对应于在React组件的构造函数中启动一个控制台组:<code>console.group('ListView Component')</code>。每个后续日志只是各自生命周期方法中的一个<code>console.log()</code>语句。将日志分组到单个组件中有助于保持控制台的整洁，并且更容易找到与感兴趣的组件相关联的日志。</p>
<h4>通过LogRocket使用控制台API</h4>
<p>在过去，控制台API主要在开发过程中使用，但是随着生产前端日志记录工具的流行，如<a href="https://logrocket.com" target="_blank" rel="noopener noreferrer"> LogRocket </a>捕获所有控制台输出，在前端代码中有策略地放置日志语句已经成为越来越普遍的做法。这在许多情况下是有帮助的。</p>
<figure><img decoding="async" src="../Images/5ae42f74c342d9fae99d9786b17f0239.png" data-height="228" data-width="1228" data-lazy-src="https://storage.googleapis.com/blog-images-backup/1*jm5u5OqLtZnsGkd_xw5kqQ.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" class=" jetpack-lazy-image" data-original-src="https://storage.googleapis.com/blog-images-backup/1*jm5u5OqLtZnsGkd_xw5kqQ.png"/><noscript><img data-lazy-fallback="1" decoding="async" src="../Images/5ae42f74c342d9fae99d9786b17f0239.png" data-height="228" data-width="1228" data-original-src="https://storage.googleapis.com/blog-images-backup/1*jm5u5OqLtZnsGkd_xw5kqQ.png"/></noscript></figure>
<figure><img decoding="async" src="../Images/fccc56c74127228efb7cf1a815fd9d68.png" data-height="180" data-width="914" data-lazy-src="https://storage.googleapis.com/blog-images-backup/1*mLs1vzMsz4k14S6EV6f8GA.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" class=" jetpack-lazy-image" data-original-src="https://storage.googleapis.com/blog-images-backup/1*mLs1vzMsz4k14S6EV6f8GA.png"/><noscript><img data-lazy-fallback="1" decoding="async" src="../Images/fccc56c74127228efb7cf1a815fd9d68.png" data-height="180" data-width="914" data-original-src="https://storage.googleapis.com/blog-images-backup/1*mLs1vzMsz4k14S6EV6f8GA.png"/></noscript></figure>
<p>当试图理解一个bug报告时，知道bug发生前给定变量的值通常是有帮助的。在该变量周围添加一个日志语句(例如<code>console.log('EVENT_COUNT', eventCount)</code>)意味着下一次出现bug时，该变量的值将被捕获到日志中。</p>
<p>虽然错误报告工具(如Sentry、BugSnag等)对于捕获异常非常有用，但通常会出现一些“软”错误，不值得全面警惕。一个例子可能是应用程序的意外状态，或者是<em>不应该</em>发生但不是显式错误的边缘情况。对于这些情况，使用<code>console.warn</code>和<code>console.error</code>来表示条件会有所帮助。然后，在调查错误报告时，您可以查看会话日志，看看是否出现了任何这样的警告或错误。LogRocket还允许您搜索所有<em>会话的日志，因此您可以回答诸如“这个边缘情况实际上发生了多少次”之类的问题！</em></p>
<h4>额外收获:控制台风格的乐趣</h4>
<p>如果你曾经打开过facebook.com的控制台，你会看到他们警告不要在控制台上粘贴可疑的JavaScript。</p>
<figure><img decoding="async" src="../Images/4fdebf40e9a582e4b93f6756b5601671.png" data-height="330" data-width="1392" data-lazy-src="https://storage.googleapis.com/blog-images-backup/1*UPSWk_Pj9FIybwsIukL_tQ.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" class=" jetpack-lazy-image" data-original-src="https://storage.googleapis.com/blog-images-backup/1*UPSWk_Pj9FIybwsIukL_tQ.png"/><noscript><img data-lazy-fallback="1" decoding="async" src="../Images/4fdebf40e9a582e4b93f6756b5601671.png" data-height="330" data-width="1392" data-original-src="https://storage.googleapis.com/blog-images-backup/1*UPSWk_Pj9FIybwsIukL_tQ.png"/></noscript></figure>
<p>为了达到这种效果，他们使用了<code>%c</code>操作符，当它被添加到一个记录的字符串中时，应用来自下一个参数的CSS。</p>
<figure><img decoding="async" src="../Images/6c66baa25be0e291745d9df401df3c58.png" data-height="306" data-width="1260" data-lazy-src="https://storage.googleapis.com/blog-images-backup/1*m-RlaME_Fm7oGEVdzm-aJg.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" class=" jetpack-lazy-image" data-original-src="https://storage.googleapis.com/blog-images-backup/1*m-RlaME_Fm7oGEVdzm-aJg.png"/><noscript><img data-lazy-fallback="1" decoding="async" src="../Images/6c66baa25be0e291745d9df401df3c58.png" data-height="306" data-width="1260" data-original-src="https://storage.googleapis.com/blog-images-backup/1*m-RlaME_Fm7oGEVdzm-aJg.png"/></noscript></figure>
<figure><img decoding="async" src="../Images/9f1fedc7eecfa9af4135a7a539fcb529.png" data-height="110" data-width="420" data-lazy-src="https://storage.googleapis.com/blog-images-backup/1*42FP7E5Rj0xWLGGBg3loqw.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" class=" jetpack-lazy-image" data-original-src="https://storage.googleapis.com/blog-images-backup/1*42FP7E5Rj0xWLGGBg3loqw.png"/><noscript><img data-lazy-fallback="1" decoding="async" src="../Images/9f1fedc7eecfa9af4135a7a539fcb529.png" data-height="110" data-width="420" data-original-src="https://storage.googleapis.com/blog-images-backup/1*42FP7E5Rj0xWLGGBg3loqw.png"/></noscript></figure>
<p>除了这种类型的警告，我不知道这个API有太多的用例，但是如果你已经找到了一种创造性的使用方法，请在评论中说出来🙂</p>
<h4>进一步阅读</h4>

<p>使用LogRocket消除传统反应错误报告的噪音</p><div class="code-block code-block-17">
<div class="blog-plug inline-plug react-plug" vwo-el-id="26283398190">
<h2 vwo-el-id="41600691720">是一款React analytics解决方案，可保护您免受数百个误报错误警报的影响，只针对少数真正重要的项目。LogRocket告诉您React应用程序中实际影响用户的最具影响力的bug和UX问题。</h2>
<a href="https://lp.logrocket.com/blg/react-signup-issue-free" target="_blank" vwo-el-id="19356441070">LogRocket
</a><p>自动聚合客户端错误、反应错误边界、还原状态、缓慢的组件加载时间、JS异常、前端性能指标和用户交互。然后，LogRocket使用机器学习来通知您影响大多数用户的最具影响力的问题，并提供您修复它所需的上下文。</p><a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="19356441380">
<img class="first-react-image alignnone size-full wp-image-46 jetpack-lazy-image jetpack-lazy-image--handled" src="../Images/f300c244a1a1cf916df8b4cb02bec6c6.png" vwo-el-id="18272717540" data-lazy-loaded="1" data-original-src="https://files.readme.io/27c94e7-Image_2017-06-05_at_9.46.04_PM.png"/>
</a>
<a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="19356441690">
<img class="second-react-image alignnone size-full wp-image-46 jetpack-lazy-image jetpack-lazy-image--handled" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" vwo-el-id="30720362350" data-lazy-loaded="1" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/>
</a>
<a href="https://lp.logrocket.com/blg/react-signup-issue-free" target="_blank" rel="noopener noreferrer" vwo-el-id="35866400580">LogRocket
</a><p>关注重要的React bug—<a class="signup" href="https://lp.logrocket.com/blg/react-signup-issue-free" target="_blank" rel="noopener noreferrer" vwo-el-id="40093418840">今天就试试LogRocket】。</a></p><p vwo-el-id="28675661060">Focus on the React bugs that matter —
<a class="signup" href="https://lp.logrocket.com/blg/react-signup-issue-free" target="_blank" rel="noopener noreferrer" vwo-el-id="40093418840">try LogRocket today</a>.
</p>
</div></div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
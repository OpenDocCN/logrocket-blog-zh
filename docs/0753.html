<html>
<head>
<title>Building a tab control component for iOS and Android with React Native - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>用React Native - LogRocket Blog为iOS和Android构建一个选项卡控件组件</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/tab-control-component-ios-android-react-native/#0001-01-01">https://blog.logrocket.com/tab-control-component-ios-android-react-native/#0001-01-01</a></blockquote><div><article class="article-post">
<p>选项卡控件是移动应用程序的重要组件。它使用户能够在屏幕之间导航，或者通过在视图之间切换来访问屏幕内容的不同部分。</p>
<p>作为一名移动应用开发者，你通常会在iOS上使用一个<a href="https://developer.apple.com/design/human-interface-guidelines/ios/controls/segmented-controls/">分段控件</a>。</p>
<figure id="attachment_15887" aria-describedby="caption-attachment-15887" class="wp-caption aligncenter"><img data-attachment-id="15887" data-permalink="https://blog.logrocket.com/tab-control-component-ios-android-react-native/ios-segmented-control-designs/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/03/ios-segmented-control-designs.png" data-orig-size="730,574" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="iOS segmented control designs" data-image-description="" data-image-caption="&lt;p&gt;iOS segmented control designs by Roman Kamushken.&lt;/p&gt;&#10;" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/03/ios-segmented-control-designs-300x236.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/03/ios-segmented-control-designs.png" decoding="async" class="size-full wp-image-15887 jetpack-lazy-image" src="../Images/8205823d252abcaa49c06aa0d781feaa.png" alt="iOS Segmented Control Designs" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2020/03/ios-segmented-control-designs.png 730w, https://blog.logrocket.com/wp-content/uploads/2020/03/ios-segmented-control-designs-300x236.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2020/03/ios-segmented-control-designs.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/03/ios-segmented-control-designs.png"/><noscript><img data-lazy-fallback="1" data-attachment-id="15887" data-permalink="https://blog.logrocket.com/tab-control-component-ios-android-react-native/ios-segmented-control-designs/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/03/ios-segmented-control-designs.png" data-orig-size="730,574" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="iOS segmented control designs" data-image-description="" data-image-caption="&lt;p&gt;iOS segmented control designs by Roman Kamushken.&lt;/p&gt;&#10;" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/03/ios-segmented-control-designs-300x236.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/03/ios-segmented-control-designs.png" decoding="async" loading="lazy" class="size-full wp-image-15887" src="../Images/8205823d252abcaa49c06aa0d781feaa.png" alt="iOS Segmented Control Designs" srcset="https://blog.logrocket.com/wp-content/uploads/2020/03/ios-segmented-control-designs.png 730w, https://blog.logrocket.com/wp-content/uploads/2020/03/ios-segmented-control-designs-300x236.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/03/ios-segmented-control-designs.png"/></noscript><figcaption id="caption-attachment-15887" class="wp-caption-text">iOS segmented control designs by Roman Kamushken.</figcaption></figure>
<p>在Android上，你通常会根据<a href="https://material.io/components/tabs/">材料设计准则</a>使用<a href="https://material.io/develop/android/components/tab-layout/">标签布局</a>。</p>
<figure id="attachment_15888" aria-describedby="caption-attachment-15888" class="wp-caption aligncenter"><img data-attachment-id="15888" data-permalink="https://blog.logrocket.com/tab-control-component-ios-android-react-native/material-design-tab/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/03/material-design-tab.png" data-orig-size="300,533" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Material Design tab example" data-image-description="" data-image-caption="&lt;p&gt;Example of a Material Design tab.&lt;/p&gt;&#10;" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/03/material-design-tab-169x300.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/03/material-design-tab.png" decoding="async" class="size-full wp-image-15888 jetpack-lazy-image" src="../Images/4d342783f3713117d1a5ff4d5f1ba005.png" alt="Material Design Tab Example" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2020/03/material-design-tab.png 300w, https://blog.logrocket.com/wp-content/uploads/2020/03/material-design-tab-169x300.png 169w" data-lazy-sizes="(max-width: 300px) 100vw, 300px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2020/03/material-design-tab.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/03/material-design-tab.png"/><noscript><img data-lazy-fallback="1" data-attachment-id="15888" data-permalink="https://blog.logrocket.com/tab-control-component-ios-android-react-native/material-design-tab/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/03/material-design-tab.png" data-orig-size="300,533" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Material Design tab example" data-image-description="" data-image-caption="&lt;p&gt;Example of a Material Design tab.&lt;/p&gt;&#10;" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/03/material-design-tab-169x300.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/03/material-design-tab.png" decoding="async" loading="lazy" class="size-full wp-image-15888" src="../Images/4d342783f3713117d1a5ff4d5f1ba005.png" alt="Material Design Tab Example" srcset="https://blog.logrocket.com/wp-content/uploads/2020/03/material-design-tab.png 300w, https://blog.logrocket.com/wp-content/uploads/2020/03/material-design-tab-169x300.png 169w" sizes="(max-width: 300px) 100vw, 300px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/03/material-design-tab.png"/></noscript><figcaption id="caption-attachment-15888" class="wp-caption-text">Example of a Material Design tab.</figcaption></figure>
<p>本文的目标是开发一个React本地组件，在iOS上呈现一个分段控件，在Android上呈现一个选项卡组件。说到实现，我重用状态管理和数据流的代码，因为它们是独立于平台的。</p>
<p>特定于平台的代码——例如，由于不同的UI模式——在React本机机制的帮助下使用，如<a href="https://reactnative.dev/docs/platform-specific-code#platform-module">平台</a>模块，以区分iOS和Android(以及<a href="https://necolas.github.io/react-native-web/docs/?path=/docs/overview-getting-started--page"> web </a>)。我对组件的要求是:</p>
<ul>
<li>Android组件符合材料设计准则</li>
<li>iOS组件设计强烈倾向于iOS 13的分段控制设计。我的模板是iOS 13上的苹果地图</li>
<li>我不试图为不同的操作系统版本实现不同的设计(例如，没有为使用iOS 12的用户提供分段控制的iOS 12设计)</li>
</ul>
<h2>演示应用程序</h2>
<p>下面的动画gif演示了作为本文主题的选项卡控件。</p>
<p><img data-attachment-id="15890" data-permalink="https://blog.logrocket.com/tab-control-component-ios-android-react-native/tab-component-demo/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/03/tab-component-demo.gif" data-orig-size="730,503" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Tab component demo" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/03/tab-component-demo-300x207.gif" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/03/tab-component-demo.gif" decoding="async" class="aligncenter size-full wp-image-15890 jetpack-lazy-image" src="../Images/acfc266d525ef6015321b5d2299b465f.png" alt="Tab Component Demo" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2020/03/tab-component-demo.gif?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/03/tab-component-demo.gif"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="15890" data-permalink="https://blog.logrocket.com/tab-control-component-ios-android-react-native/tab-component-demo/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/03/tab-component-demo.gif" data-orig-size="730,503" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Tab component demo" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/03/tab-component-demo-300x207.gif" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/03/tab-component-demo.gif" decoding="async" loading="lazy" class="aligncenter size-full wp-image-15890" src="../Images/acfc266d525ef6015321b5d2299b465f.png" alt="Tab Component Demo" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/03/tab-component-demo.gif"/></noscript>
<p>我想把重点放在开发这样一个组件的重要方面。出于这个原因，我把这个例子分解成了要点。</p>
<p>关于分段控制，我实现了一个版本，使用交互概念的运动动画来可视化活动标签之间的转换。在上面的动画gif中，你可以看到这个UX图案的样子。</p>
<p>你可以在<a href="https://github.com/doppelmutzi/expo-snack-RN-tab-control">我的GitHub项目</a>中找到代码，也可以通过我的<a href="https://snack.expo.io/@doppelmutzi/tab-control-(segmented-control-on-ios-and-tab-layout-on-android)">世博小吃</a>快速访问。</p>
<p data-snack-id="@doppelmutzi/tab-control-(segmented-control-on-ios-and-tab-layout-on-android)" data-snack-platform="web" data-snack-preview="true" data-snack-theme="light"/>
<p/>
<h2><code>TabControl</code> —接口和实现</h2>
<p>组件的接口看起来像这样。</p>
<pre>&lt;TabControl
  values={["Giannis", "LeBron", "Luka"]}
  onChange={value =&gt; {
    if (value === "Giannis") {
      setImgSource(sourceUriGiannis);
    } else if (value === "LeBron") {
      setImgSource(sourceUriLeBron);
    } else {
      setImgSource(sourceUriLuka);
    }
  }}
  renderSeparators={showSeparatorsIos}
/&gt;</pre>
<p>您必须传入一个呈现为标签的数组<code>values</code>。当用户点击一个选项卡时，就会调用<code>onChange</code> prop。回调函数获取活动选项卡的标签。在演示项目中，我使用该值来设置图像源(<code>setImgSource</code>)，以便在用户按tab键时改变背景图像。</p>
<p>让我们深入研究一下<code>TabControl</code>组件的实现细节。</p>
<pre>import {
  // ...
  Platform
} from "react-native";
import iosTabControlStyles from "./iOSTabControlStyles";
import androidTabControlStyles from "./androidTabControlStyles";
const isIos = Platform.OS === "ios";
const wrapperStyles = StyleSheet.create({
  outerGapStyle: isIos ? { padding: theme.spacing.s } : { padding: 0 }
});
const tabControlStyles = isIos ? iosTabControlStyles : androidTabControlStyles;
const TabControl = ({ values, onChange, renderSeparators }) =&gt; {
  const [selectedIndex, setSelectedIndex] = useState(0);
  const handleIndexChange = index =&gt; {
    setSelectedIndex(index);
    onChange(values[index]);
  };
  return (
    &lt;View style={wrapperStyles.outerGapStyle}&gt;
      &lt;SegmentedControl
        values={values}
        selectedIndex={selectedIndex}
        onIndexChange={handleIndexChange}
        renderSeparators={renderSeparators}
      /&gt;
    &lt;/View&gt;
  );
};
</pre>
<p>我利用React Native的平台API在两个移动平台上不同地呈现组件。我创建了一个布尔变量(<code>isIos</code>)来执行整个组件的平台检查。</p>
<pre>import iosTabControlStyles from "./iOSTabControlStyles";
import androidTabControlStyles from "./androidTabControlStyles";
const isIos = Platform.OS === "ios";
const wrapperStyles = StyleSheet.create({
  outerGapStyle: isIos ? { padding: theme.spacing.s } : { padding: 0 }
});
const tabControlStyles = isIos ? iosTabControlStyles : androidTabControlStyles;
</pre>
<p>使用<code>wrapperStyles</code>对象，您可以看到我是如何定义不同的样式属性的。在Android上，组件应该横跨整个视口宽度，但在iOS上，左右两侧应该有一个小间隙。</p>
<p>根据平台的不同，<code>iOSTabControlStyles</code>或<code>androidTabControlStyles</code>被分配给<code>tabControlStyles</code>。该对象保存实际的样式，可以从整个组件的不同部分进行访问。这个概念背后的思想是两个导入的样式对象有相同的“接口”再来看看安卓风格(<code>androidTabControlStyles.js</code>)。</p>
<pre>import { StyleSheet } from "react-native";
import theme from "../theme";
const { tabsContainerColor, borderColor, activeTextColor } = theme.color;
export const androidTabBarHeight = 40;
const fontStyles = {
  fontFamily: theme.fontFamily.normal,
  fontSize: theme.fontSize.l,
  color: activeTextColor
};
const gap = theme.spacing.s;
export default StyleSheet.create({
  tabsContainerStyle: {
    backgroundColor: tabsContainerColor,
    height: androidTabBarHeight
  },
  tabStyle: {
    flex: 1,
    paddingVertical: gap,
    paddingHorizontal: 2 * gap
  },
  tabTextStyle: { ...fontStyles, alignSelf: "center" },
  activeTabStyle: {
    borderBottomWidth: theme.spacing.xs,
    borderBottomColor: borderColor
  },
  activeTabTextStyle: {
    ...fontStyles
  },
  firstTabStyle: {},
  lastTabStyle: {}
});
</pre>
<p>颜色、间距或字体的具体值在导入的<code>theme.js</code>文件中定义。例如，<code>theme.fontSize.l</code>指定大字体大小。</p>
<p>iOS的样式表对象具有相同的结构(<code>iOSTabControlStyles.js</code>)。当然，价值观不同。以下道具类型显示了“接口”</p>
<pre>  import { ViewPropTypes } from "react-native";
  // ...
  const styleShape = PropType.shape({
    tabsContainerStyle: ViewPropTypes.styles,
    tabStyle: ViewPropTypes.styles,
    tabTextStyle: ViewPropTypes.styles,
    activeTabStyle: ViewPropTypes.styles,
    activeTabTextStyle: ViewPropTypes.styles,
    firstTabStyle: ViewPropTypes.styles,
    lastTabStyle: ViewPropTypes.styles
  });
</pre>
<p><code>TabControl</code>组件假设这些属性存在于样式表对象中。为了清楚起见，我将跳过iOS样式表对象的细节。</p>
<p><code>TabControl</code>是存储所选索引的有状态组件(<code>selectedIndex</code>)。此外，它还定义了一个函数(<code>handleIndexChange</code>)来更改选中的索引，并调用传递的<code>onChange</code>回调函数——在我们的例子中，是更改背景图像。</p>
<pre>const TabControl = ({ values, onChange, renderSeparators }) =&gt; {
  const [selectedIndex, setSelectedIndex] = useState(0);
  const handleIndexChange = index =&gt; {
    setSelectedIndex(index);
    onChange(values[index]);
  };
  return (
    &lt;View style={wrapperStyles.outerGapStyle}&gt;
      &lt;SegmentedControl
        values={values}
        selectedIndex={selectedIndex}
        onIndexChange={handleIndexChange}
        renderSeparators={renderSeparators}
      /&gt;
    &lt;/View&gt;
  );
};
</pre>
<p>该组件在具有上述水平填充的容器内呈现一个<code>SegmentedControl</code>组件。<code>values</code>和<code>renderSeparators</code>，一个控制分隔符是否应该在iOS上呈现的布尔标志，作为props与press handler和活动选项卡的索引一起传递。</p>
<h2><code>SegmentedControl</code> —在平台无关的容器中呈现标签</h2>
<p><code>SegmentedControl</code>负责为<code>tabValues</code>数组的每个条目渲染一个<code>Tab</code>组件。</p><div class="code-block code-block-54">
<hr/>
<h3>更多来自LogRocket的精彩文章:</h3>

<hr/></div>
<pre>function SegmentedControl({
  values: tabValues,
  selectedIndex,
  onIndexChange,
  renderSeparators,
}) {
  return (
    &lt;Container
      style={tabControlStyles}
      numberValues={tabValues.length}
      activeTabIndex={selectedIndex}
    &gt;
      {tabValues.map((tabValue, index) =&gt; (
        &lt;Tab
          label={tabValue}
          onPress={() =&gt; {
            onIndexChange(index);
          }}
          isActive={selectedIndex === index}
          isFirst={index === 0}
          isLast={index === tabValues.length - 1}
          renderLeftSeparator={
            renderSeparators &amp;&amp; shouldRenderLeftSeparator(index, selectedIndex)
          }
          key={tabValue}
        /&gt;
      ))}
    &lt;/Container&gt;
  );
}</pre>
<p>选项卡标签和选项卡按压回调函数被传递给<code>Tab</code>组件。<code>isActive</code>、<code>isFirst</code>和<code>isLast</code>告诉<code>Tab</code>组件正确的上下文以不同的方式呈现标签(例如，Android上活动标签的下边框)。上下文由当前索引和选定索引决定。</p>
<p><code>renderLeftSeperators</code>代表一个布尔标志，决定是否应该呈现标签左侧的分隔符(这是实现决定)。</p>
<p>我将跳过函数<code>shouldRenderLeftSeparator</code>的实现细节。简而言之，如果标签不是第一个或活动标签，或者如果前一个标签构成了活动标签，则为iOS平台上的所有标签呈现标签的分隔符。</p>
<h2><code>Container</code>—iOS上带运动动画的水平布局组件</h2>
<p><code>Container</code>组件在iOS和Android上呈现不同。当然，<code>children</code>道具构成了<code>Tab</code>组件图。<code>numberValues</code>和<code>activeTabIndex</code>用于计算动画的新状态。</p>
<pre>function Container({
  children,
  numberValues,
  style,
  activeTabIndex
}) {
  const { tabStyle, activeTabStyle, tabsContainerStyle } = style;
  const margin = theme.spacing.s;
  const [moveAnimation] = useState(new Animated.Value(0));
  const [containerWidth, setContainerWidth] = useState(0);
  useEffect(() =&gt; {
    const leftVal = (containerWidth / numberValues) * activeTabIndex;
    Animated.timing(moveAnimation, {
      toValue: leftVal,
      duration: 250
      // not supported by native animated module
      // useNativeDriver: true
    }).start();
  }, [containerWidth, activeTabIndex]);
  return isIos ? (
    &lt;View
      style={[
        {
          marginHorizontal: margin,
          flexDirection: "row",
          position: "relative"
        },
        tabsContainerStyle
      ]}
      onLayout={event =&gt; {
        setContainerWidth(event.nativeEvent.layout.width);
      }}
    &gt;
      &lt;Animated.View
        style={{
          // works too
          // width: `${100 / numberValues}%`,
          width: containerWidth / numberValues,
          left: moveAnimation,
          top: iosTabVerticalSpacing,
          bottom: iosTabVerticalSpacing,
          position: "absolute",
          ...tabStyle,
          ...activeTabStyle
        }}
      &gt;&lt;/Animated.View&gt;
      {children}
    &lt;/View&gt;
  ) : (
    &lt;View
      style={[
        { marginHorizontal: margin, flexDirection: "row" },
        tabsContainerStyle
      ]}
    &gt;
      {children}
    &lt;/View&gt;
  );
}
</pre>
<p>容易的部分是安卓版(三元运算符的第二种表达)。这只是一小段JSX代码，它将<code>children</code>包装在一个<code>View</code>标签中，并在左右两边留出一些空白(<code>marginHorizontal</code>)。</p>
<p>与W3C/web版本的Flexbox相比，默认方向是<code>column</code>，所以需要<code>flexDirection: "row"</code>并排显示选项卡。</p>
<p><code>tabsContainerStyle</code>是从传递的<code>style</code>属性中析构出来的，定义了容器组件的背景色和高度(<code>androidTabControlStyles.js</code>)。</p>
<pre>return isIos ? (
    // iOS version / animation code
  ) : (
    // Android version
    &lt;View
      style={[
        { marginHorizontal: margin, flexDirection: "row" },
        tabsContainerStyle
      ]}
    &gt;
      {children}
    &lt;/View&gt;
  )
</pre>
<p>iOS版本更复杂。</p>
<pre>// ...
  const [moveAnimation] = useState(new Animated.Value(0));
  const [containerWidth, setContainerWidth] = useState(0);
  useEffect(() =&gt; {
    const leftVal = (containerWidth / numberValues) * activeTabIndex;
    Animated.timing(moveAnimation, {
      toValue: leftVal,
      duration: 250
      // not supported by native animated module
      // useNativeDriver: true
    }).start();
  }, [containerWidth, activeTabIndex]);
  return isIos ? (
    &lt;View
      style={[
        {
          marginHorizontal: margin,
          flexDirection: "row",
          position: "relative"
        },
        tabsContainerStyle
      ]}
      onLayout={event =&gt; {
        setContainerWidth(event.nativeEvent.layout.width);
      }}
    &gt;
      &lt;Animated.View
        style={{
          width: containerWidth / numberValues,
          left: moveAnimation,
          top: iosTabVerticalSpacing,
          bottom: iosTabVerticalSpacing,
          position: "absolute",
          ...tabStyle,
          ...activeTabStyle
        }}
      &gt;&lt;/Animated.View&gt;
      {children}
    &lt;/View&gt;
  ) : (
    // Android version
  )
</pre>
<p>我决定使用两个状态对象来管理动画。<code>containerWidth</code>保存容器对象的宽度。<code>setContainerWidth</code>在分配给<code>View</code>的<code>onLayout</code>道具的回调函数中被调用。<code>event.nativeEvent.layout.width</code>返回组件的实际宽度。</p>
<p>分配给<code>style</code>道具的数组看起来非常类似于上面描述的Android版本。唯一的区别是<code>position: "relative"</code>，因为活动选项卡动画(<code>Animated.View</code>)的实现使用绝对定位。</p>
<pre>&lt;View style={[
    {
      marginHorizontal: margin,
      flexDirection: "row",
      position: "relative"
    },
    tabsContainerStyle
  ]}
  onLayout={event =&gt; {
    setContainerWidth(event.nativeEvent.layout.width);
  }}&gt;
  &lt;Animated.View&gt;
    // ...
  &lt;/Animated.View&gt;
  {children}
&lt;/View&gt;
</pre>
<p><a href="https://reactnative.dev/docs/animated">动画</a>是React Native的动画库。<code>Animated.View</code>是绝对定位在相对定位的父组件中的增强<code>View</code>组件。</p>
<p>它没有任何子元素，因为唯一的目的是有一个带背景色和圆角的样式化组件，通过更新<code>left</code>属性在水平轴上显示动画。</p>
<p><code>width</code>是根据制表符的数量(<code>numberValues</code>)和容器的宽度(<code>containerWidth</code>)动态计算的。<code>top</code>和<code>bottom</code>用来增加一些垂直间距。</p>
<pre>&lt;Animated.View
  style={{
    width: containerWidth / numberValues,
    left: moveAnimation,
    top: iosTabVerticalSpacing,
    bottom: iosTabVerticalSpacing,
    position: "absolute",
    ...tabStyle,
    ...activeTabStyle
  }}&gt;
&lt;/Animated.View&gt;
{children}
</pre>
<p>最后，我们还要看一下<code>useEffect</code>钩子，在这里<code>left</code>道具的值被计算出来，然后被动画(<code>Animated.timing()</code>)使用。</p>
<pre>useEffect(() =&gt; {
  const leftVal = (containerWidth / numberValues) * activeTabIndex;
  Animated.timing(moveAnimation, {
    toValue: leftVal,
    duration: 250
  }).start();
}, [containerWidth, activeTabIndex]);
</pre>
<p>可以看到，<code>useEffect</code>的依赖数组包含了<code>containerWidth</code>和<code>activeTabIndex</code> ( <code>numberValues</code>不变)。只要其中一个值发生变化，动画就会更新，并且活动选项卡指示器组件会在250毫秒内沿水平轴移动到新位置。</p>
<h2><code>Tab</code> —平台无关的抽象</h2>
<p>接下来是<code>Tab</code>组件，它为两个操作系统呈现一个<code>Text</code>组件及其相关样式(<code>tabTextStyle</code>)。</p>
<pre>function Tab({
  label,
  onPress,
  isActive,
  isFirst,
  isLast,
  renderLeftSeparator
}) {
  const {
    tabStyle,
    tabTextStyle,
    activeTabStyle,
    activeTabTextStyle,
    firstTabStyle,
    lastTabStyle
  } = tabControlStyles;
  return (
    &lt;OsSpecificTab
      isActive={isActive}
      onPress={onPress}
      style={[
        tabStyle,
        !isIos &amp;&amp; isActive &amp;&amp; activeTabStyle,
        isFirst &amp;&amp; firstTabStyle,
        isLast &amp;&amp; lastTabStyle
      ]}
      renderLeftSeparator={renderLeftSeparator}
    &gt;
      &lt;Text style={[tabTextStyle, isActive &amp;&amp; activeTabTextStyle]}&gt;
        {label}
      &lt;/Text&gt;
    &lt;/OsSpecificTab&gt;
  );
}
const OsSpecificTab = (props) =&gt; {
  return isIos ? &lt;IosTab {...props} /&gt; : &lt;AndroidTab {...props} /&gt;;
};
</pre>
<p>如果选项卡处于活动状态，则添加附加样式(<code>activeTabTextStyle</code>)。容器组件<code>OsSpecificTab</code>用<code>onPress</code>处理程序和该选项卡是否活动的提示来调用(<code>isActive</code>)。</p>
<p>一个数组被分配给<code>style</code>属性。如果制表符代表第一个或最后一个制表符，则其他样式被插入到该数组中。仅适用于Android版本，当选项卡处于活动状态时(<code>activeTabStyle</code>)会添加样式，以呈现底部边框作为视觉指示器</p>
<p>如上所述，iOS的active选项卡的实现是不同的，因此，该信息与组件树的这一层无关。</p>
<p><code>OsSpecificTab</code>非常简单:它只是渲染一个<code>IosTab</code>或<code>AndroidTab</code>组件，并为其分配所有道具。</p>
<h2><code>AndroidTab</code>和<code>IosTab</code> —依赖于平台的实现</h2>
<p>最后，让我们看看实际的选项卡实现。<code>AnroidTab</code>的实现利用了<code><a href="https://reactnative.dev/docs/touchablenativefeedback">TouchableNativeFeedback</a></code>，这是一个Android专用的API，用于添加原生外观。</p>
<p>代替奇怪的彩色背景，我们给<code>background</code>道具分配了一个波纹效果。<code>child</code>容器是一个普通的被样式化的<code>View</code>组件(<code>tabControlStyle</code>)。</p>
<pre>const AndroidTab = ({ children, style: tabControlStyle, onPress }) =&gt; (
  &lt;TouchableNativeFeedback
    onPress={onPress}
    background={TouchableNativeFeedback.Ripple(theme.color.ripple, true)}&gt;
    &lt;View style={tabControlStyle}&gt;{children}&lt;/View&gt;
  &lt;/TouchableNativeFeedback&gt;
);
</pre>
<p><code>IosTab</code>看起来有点不一样。</p>
<pre>const IosTab = ({
  children,
  style: tabControlStyle,
  onPress,
  renderLeftSeparator
}) =&gt; (
  &lt;View style={{ flex: 1, flexDirection: "row", alignItems: "center" }}&gt;
    {renderLeftSeparator &amp;&amp; (
      &lt;View
        style={{
          height: "50%",
          width: 1,
          backgroundColor: theme.color.separator
        }}
      &gt;&lt;/View&gt;
    )}
    &lt;TouchableWithoutFeedback onPress={onPress}&gt;
      &lt;View style={tabControlStyle}&gt;{children}&lt;/View&gt;
    &lt;/TouchableWithoutFeedback&gt;
  &lt;/View&gt;
);
</pre>
<p>基于布尔标志<code>renderLeftSeparator</code>的值，垂直分隔符元素呈现在<code>TouchableWithoutFeedback</code>组件的左侧(垂直居中，容器高度的50%)。和Android标签一样，<code>children</code>道具被一个普通的<code>View</code>组件包装，这个组件被设计了样式。</p>
<h2>为原生用户体验做出更大贡献</h2>
<p>除了像<code><a href="https://reactnative.dev/docs/touchablehighlight">TouchableHighlight</a></code>或<code>TouchableNativeFeedback</code>这样的东西(用于Android上的连锁反应)，还有更多改进原生外观和感觉的可能性。例如，通过<a href="https://docs.expo.io/versions/latest/sdk/haptics/#hapticsnotificationasynctype"> Expo Haptics </a>，可以为iOS和Android添加触觉反馈。</p>
<p>在我的应用程序中，我只需在<code>SegmentedControl</code>组件的<code>onPress</code>回调中添加一行。就这样——很酷，是吧？</p>
<pre>import * as Haptics from "expo-haptics";
// ...
&lt;Tab
  label={tabValue}
  onPress={() =&gt; {
    onIndexChange(index);
    Haptics.notificationAsync(Haptics.NotificationFeedbackType.Success);
  }}
  // ...
  &gt;
// ...
</pre>
<p>但是，等等——可能还有更酷的事情。和苹果地图一样，你也可以左右滑动来改变活跃标签。使用<a href="https://software-mansion.github.io/react-native-gesture-handler/">react-native-gesture-handler</a>，可以扩展我们的组件，使其在iOS上具有滑动功能。因此，我必须扩展一下<code>Container</code>组件。</p>
<pre>import { PanGestureHandler } from "react-native-gesture-handler";
// ...
function Container({
  children,
  numberValues,
  style,
  activeTabIndex,
  onIndexChange // this callback is passed by SegmentedControl
}) {
  // ...
  useEffect(() =&gt; {
    // ...
  }, [containerWidth, activeTabIndex]);
  const onGestureEvent = evt =&gt; {
    const tabWidth = containerWidth / numberValues;
    let index = Math.floor(evt.nativeEvent.x / tabWidth);
    if (index &gt; numberValues - 1) index = numberValues - 1;
    else if (index &lt; 0) index = 0;
    if (index !== activeTabIndex) {
      onIndexChange(index);
    }
  };
  return isIos ? (
    &lt;PanGestureHandler onGestureEvent={onGestureEvent}&gt;
      &lt;View style={[
          {
            marginHorizontal: margin,
            flexDirection: "row",
            position: "relative"
          },
          tabsContainerStyle
        ]}
        onLayout={event =&gt; {
          setContainerWidth(event.nativeEvent.layout.width);
        }}&gt;
        // ...
      &lt;/View&gt;
    &lt;/PanGestureHandler&gt;
  ) : (
    // Android
  );
}
</pre>
<p>我们将iOS版本的JSX代码(即三元运算符的第一个表达式)包装在一个<code>PanGestureHandler</code>中。每当用户执行滑动手势时，就会调用<code>onGestureEvent</code>函数。</p>
<p>在这个函数中，我们计算新的索引并调用<code>onIndexChange</code>回调。回调函数需要通过<code>SegmentedControl</code>来传递。在以前的版本中，这是不需要的，因为索引仅通过点击来改变，因此，<code>activeTabIndex</code>就足够了。</p>
<pre>const tabWidth = containerWidth / numberValues;
let index = Math.floor(evt.nativeEvent.x / tabWidth);
</pre>
<p>我们利用了<code>PanGestureHandler</code> 的<a href="https://software-mansion.github.io/react-native-gesture-handler/docs/handler-pan.html#x"> x属性，该属性构成了手指相对于我们的<code>Container</code>组件的当前位置的坐标。有了这些信息和标签宽度，我们就可以计算新的索引。</a></p>
<h2>技术障碍和可能的进一步发展</h2>
<p>我还没有成功结合“iOS变种2和3”(看看上面的动画gif)。正如你在苹果地图上看到的，切换标签时有一个运动动画，点击时有一个缩放动画(即标签缩小了一点)。</p>
<p>欢迎你用我的<a href="https://github.com/doppelmutzi/react-native-tab-control"> GitHub项目</a>来试试。使用基于绝对定位的方法，我遇到了一个分层问题(<code>z-index</code>)，即选项卡没有定位在选项卡标签的下面。下面是带有缩放动画的iOS变体的代码。如果你有如何结合这两种变体的想法，请在评论部分告诉我。</p>
<pre>const IosScaleTab = ({
  isActive,
  children,
  style: tabControlStyle,
  onPress,
  renderLeftSeparator
}) =&gt; {
  const scaleValue = new Animated.Value(0);
  const activeTabScale = scaleValue.interpolate({
    inputRange: [0, 0.5, 1],
    outputRange: [1, 0.97, 0.95]
  });
  const transformStyle = { transform: [{ scale: activeTabScale }] };
  const animatedViewStyle = [isActive ? transformStyle : {}, tabControlStyle];
  const timingProps = {
    toValue: 1,
    duration: 50,
    easing: Easing.linear,
    useNativeDriver: true
  };
  return (
    &lt;View style={{ flex: 1, flexDirection: "row", alignItems: "center" }}&gt;
      {renderLeftSeparator &amp;&amp; (
        &lt;View
          style={{
            height: "50%",
            width: 1,
            backgroundColor: theme.color.separator
          }}
        &gt;&lt;/View&gt;
      )}
      &lt;TouchableWithoutFeedback
        onPressIn={() =&gt; {
          Animated.timing(scaleValue, timingProps).start();
          onPress();
        }}
        onPressOut={() =&gt; {
          Animated.timing(scaleValue, {
            ...timingProps,
            toValue: 0
          }).start();
        }}
      &gt;
        &lt;Animated.View style={animatedViewStyle}&gt;{children}&lt;/Animated.View&gt;
      &lt;/TouchableWithoutFeedback&gt;
    &lt;/View&gt;
  );
};
</pre>
<p>同样，这个动画是用<code>Animated</code> API实现的。在<code>interpolate</code>函数的帮助下，我们在50毫秒的时间内将<code>transform</code>样式属性的<code>scale</code>值从100%更改为95%(参见<code>outputRange</code>)。</p>
<p>这些动画样式(<code>transformStyle</code>)仅在选项卡激活时应用。我使用<code>Easing.linear</code>作为由三个值组成的<code>inputRange</code>的缓和函数。</p>
<p>整个动画以<code>TouchableWithoutFeedback</code>组件的<code>onPressIn</code>道具拉开序幕。如果用户停止按下按钮，就会调用<code>onPressOut</code>回调函数，该函数会将活动标签的大小动画化回原来的大小。</p>
<p>从<code>timingProps</code>对象可以看出，对于这个动画，可以利用本地驱动程序(<code>useNativeDriver: true</code>)来提高性能。不幸的是，这在我们的运动动画中是不可能的，因为<code>left</code>属性是随时间变化的。</p>
<h2>现有库</h2>
<p>在这篇文章的准备过程中，我搜索了现有的React本地库，这些库提供了类似Android的选项卡和/或类似iOS的分段控件。<a href="https://www.codeinwp.com/blog/react-native-component-libraries/">这篇文章</a>很好地概述了2020年的组件库。</p>
<p><a href="https://docs.nativebase.io/Components.html#tabs-def-headref"> NativeBase.io </a>根据Material Design guidelines提供了一个tab组件，在Android和iOS上看起来差不多。Android版本看起来像我上面的实现。如果你的项目的目标是拥有一个原生的iOS外观和感觉，那么这个组件没有为你提供一个合适的iOS版本。</p>
<p>UI Kitten 提供了一个标签视图组件，可以用于Android。它使您能够使用带图标和不带图标的标签。还是那句话，iOS没有优化版本。</p>
<p>一个漂亮的选项卡视图组件也可以从<a href="https://github.com/react-native-community/react-native-tab-view"> React Native社区</a>获得。同样，该组件是根据Android材料设计准则设计的，在两种操作系统上看起来都很相似。</p>
<p>在我的研究中，我还没有找到一个基于iOS 13设计的分段控制实现的例子。以下组件灵感来自iOS 12。</p>
<p>直到最近，React原生团队还为iOS 提供了一个<a href="https://reactnative.dev/docs/segmentedcontrolios">分段控制组件。但是，此组件已被弃用。相反，他们推荐使用</a><a href="https://github.com/react-native-community/segmented-control">@ react-native-community/segmented-control</a>。</p>
<p>在撰写本文时，该组件仅提供了一种iOS 12设计。<a href="https://avocode.com/nachos-ui/docs/#!/Showcase/SegmentedControlButton"> Nachos UI套件</a>提供了一个基本的分段控制组件。以下GitHub项目已经实现了分段控制组件，但其中一些项目似乎不再维护:</p>

<h2>结论</h2>
<p>如你所见，更复杂的部分是这个组件的iOS版本。由于我主要是iOS用户，我可能会错过一些Android版本的设计概念。如果为了更好的Android用户体验还有更多工作要做，请在评论区告诉我。</p>
<p>当然，与本机实现相比，这种方法有一些缺点。为每个操作系统版本实现和维护不同的设计非常困难(例如，iOS 12和iOS 13上的分段控件的外观和感觉是不同的)。我觉得没这个必要。但是，最后还是要看项目！</p>
<p>如果我基于本文描述的概念在GitHub上开发一个库，你觉得有用吗？让我知道你的想法。</p><div class="code-block code-block-18">
<div class="blog-plug inline-plug react-native-plug"><h2><a href="https://lp.logrocket.com/blg/react-native-signup"> LogRocket </a>:即时重现React原生应用中的问题。</h2><a class="signup" href="https://lp.logrocket.com/blg/react-native-signup" target="_blank" rel="noopener noreferrer"><img class="alignnone size-full wp-image-46 jetpack-lazy-image" src="../Images/110055665562c1e02069b3698e6cc671.png" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2021/10/react-native-plug_v2-2.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2021/10/react-native-plug_v2-2.png"/><noscript><img data-lazy-fallback="1" class="alignnone size-full wp-image-46" src="../Images/110055665562c1e02069b3698e6cc671.png" data-original-src="https://blog.logrocket.com/wp-content/uploads/2021/10/react-native-plug_v2-2.png"/></noscript></a><p><a href="https://lp.logrocket.com/blg/react-native-signup" target="_blank" rel="noopener noreferrer"> LogRocket </a>是一款React原生监控解决方案，可帮助您即时重现问题、确定bug的优先级并了解React原生应用的性能。</p><p>LogRocket还可以向你展示用户是如何与你的应用程序互动的，从而帮助你提高转化率和产品使用率。LogRocket的产品分析功能揭示了用户不完成特定流程或不采用新功能的原因。</p><p>开始主动监控您的React原生应用— <a class="signup" href="https://lp.logrocket.com/blg/react-native-signup" target="_blank" rel="noopener noreferrer">免费试用LogRocket】。</a></p></div>
</div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
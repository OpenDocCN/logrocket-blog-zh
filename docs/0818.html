<html>
<head>
<title>Playwright vs. Puppeteer: Which should you choose? - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>剧作家和木偶师:你应该选择哪一个？- LogRocket博客</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/playwright-vs-puppeteer/#0001-01-01">https://blog.logrocket.com/playwright-vs-puppeteer/#0001-01-01</a></blockquote><div><article class="article-post">
<p><a href="https://github.com/microsoft/playwright">剧作家</a>是一个用于浏览器自动化的<a href="https://nodejs.org"> Node.js </a>库。<a href="https://pptr.dev/">木偶师</a>也是一个用于浏览器自动化的Node.js库。让我们看看是什么让它们变得有趣，并考虑在决定使用哪一个时应该考虑的因素。</p>
<h2>历史背景</h2>
<p>首先了解一些历史背景可能会有所帮助。</p>
<p>浏览器自动化并不是一项新技术。<a href="https://www.selenium.dev/"> Selenium </a>自2004年就已经出现，在很长一段时间里，它都是这一类别的首选工具。虽然它的主要用例是为网站实现测试套件，但程序员也用它来做一些事情，比如在网站不提供API时截屏或自动化任务。</p>
<p>然而，Selenium有一个不可靠的名声。硒测试通常是不可靠的，由于难以重现的不明显的原因而间歇性地失败。</p>
<p>Selenium也相当耗费资源，部分原因是它通常用于运行完整的浏览器。最终，程序员开始在某些情况下使用<a href="https://en.wikipedia.org/wiki/Headless_browser">无头浏览器</a>。这些浏览器完成了完整浏览器的大部分工作，但它们实际上并不呈现UI。<a href="https://en.wikipedia.org/wiki/PhantomJS">幻想曲</a>是其中比较受欢迎的一种。</p>
<p>无头浏览器可以很好地测试简单的网站，但要测试网站可以做的一切，他们需要通过支持各种网络标准尽可能接近地模拟完整的浏览器。然而全面的支持是一个<a href="https://drewdevault.com/2020/03/18/Reckless-limitless-scope.html">几乎不可能完成的任务</a>，因为浏览器已经变得如此复杂。</p>
<p>更复杂的网站也需要更多的测试，所以过去的无头浏览器的主要问题是，当你想更多地使用它们时，它们变得越来越不可用。</p>
<p>2017年，情况发生了显著变化。PhantomJS的作者反对它，他这样做的<a href="https://groups.google.com/forum/m/#!topic/phantomjs/9aI5d-LDuNE">动力</a>是谷歌宣布的<a href="https://developers.google.com/web/updates/2017/04/headless-chrome">无头Chrome </a>，它首先在Chrome 59中可用。当年晚些时候，火狐<a href="https://www.ghacks.net/2017/09/01/first-look-at-firefoxs-headless-mode/">又推出了无头模式</a>。这些发展使得针对人们实际使用的相同浏览器编写高效的测试和脚本成为可能。</p>
<h2>操纵木偶的人</h2>
<p>几个月后，谷歌继headless Chrome之后发布了Puppeteer的公开版本。Chrome DevTools团队开发了它，这使它比类似的项目具有更大的优势，因为它拥有来自同一家公司的机构支持，该公司制造了世界上使用最广泛的浏览器<a href="https://en.wikipedia.org/wiki/Usage_share_of_web_browsers">。</a></p>
<p>木偶师可以驱动Chrome或者<a href="https://en.wikipedia.org/wiki/Chromium_(web_browser)">Chromium</a>(Chrome所基于的开源浏览器)，默认情况下，安装木偶师也会下载Chromium的兼容版本。这避免了可能发生的情况，即您的浏览器最终获得了破坏Puppeteer的更新。</p>
<p>Puppeteer使浏览器自动化入门变得容易。这部分是因为它与浏览器的交互方式。Selenium使用<a href="https://www.w3.org/TR/webdriver/"> WebDriver协议</a>，它需要运行一个服务器，作为Selenium和浏览器之间的中介。比如有<a href="https://chromedriver.chromium.org/"> ChromeDriver </a>、<a href="https://github.com/mozilla/geckodriver"> geckodriver </a>(针对火狐)，还有<a href="https://developer.apple.com/documentation/webkit/testing_with_webdriver_in_safari"> safaridriver </a>。这种对特殊服务器的要求增加了复杂性。</p>
<p>相比之下，木偶师使用非标准的<a href="https://github.com/WICG/devtools-protocol/"> DevTools协议</a>控制Chrome，因此它直接与浏览器对话，并通过Selenium提供额外的功能，如<a href="https://pptr.dev/#?product=Puppeteer&amp;version=master&amp;show=api-pagesetrequestinterceptionvalue">拦截网络请求</a>。</p>
<p>我曾使用Puppeteer进行网站测试，并在TurboTax 中自动输入数据，在这两种情况下，这都是一个相对轻松的过程。</p>
<h2>剧作家</h2>
<p>当微软在2020年1月31日发布了剧作家的第一个公开版本时，我们获得了一个新的选择。</p>
<p>如果你比较一下剧作家和木偶师<a href="https://github.com/puppeteer/puppeteer/graphs/contributors">的贡献者页面，你会注意到木偶师的前两名贡献者现在都在为剧作家工作。木偶团队实质上是从谷歌转移到了微软，变成了剧作家团队。</a></p>
<p>因此，剧作家在许多方面与木偶戏演员非常相似。API方法在大多数情况下是相同的，并且在默认情况下，剧作家也捆绑了兼容的浏览器。</p>
<p>剧作家最大的差异化点是跨浏览器支持。它可以驱动Chromium、WebKit(Safari的浏览器引擎)和Firefox。你可以在<a href="https://aslushnikov.github.io/isplaywrightready/">剧作家准备好了吗？</a>网站。</p>
<p>然而，剧作家团队对跨浏览器支持的方法是有争议的。他们给剧作家提供了WebKit和Firefox的补丁版本。他们的<a href="https://github.com/microsoft/playwright#q-what-browser-versions-does-playwright-use">回应</a>是他们只修补了WebKit和Firefox调试协议，而不是实际的渲染引擎。</p>
<p>然而，这些变化还没有与WebKit和Firefox团队一起开发。虽然这些变化最终可能会被合并进来，但这并不能保证。剧作家团队可能不得不无限期地维护这些更改，这可能会影响剧作家跨浏览器支持的长期可靠性。</p>
<p>开始一个新的库也允许剧作家团队以突破性的方式使API更符合人体工程学。例如，默认情况下，剧作家的<code>page.click</code>等待元素可用和可见。</p>
<p>这并不意味着木偶师不会在新的主要版本中得到类似的改进。这只是意味着，就目前而言，在某些情况下，剧作家可以更容易地使用。</p>
<p>最后一个值得注意的区别是，剧作家有一个更强大的浏览器上下文功能，允许您用一个浏览器实例模拟多个设备。</p>
<pre>const { chromium, devices } = require("playwright");

(async () =&gt; {
    const browser = await chromium.launch();

    for (const deviceName of ["iPhone 11", "iPad Pro 11"]) {
        const context = await browser.newContext({
            ...devices[deviceName]
        });
        const page = await context.newPage();
        await page.goto('http://github.com');
        await page.screenshot({
            path: `github-${deviceName.replace(/ /g, "-")}.png`
        });
    }

    await browser.close();
})();</pre>
<p>就cookies、本地存储等而言，每个浏览器上下文都与其他上下文相隔离。，并且每个上下文下面还可以有多个页面。</p>
<h2>选择图书馆</h2>
<p>因为剧作家和木偶师基本上是由同一个团队开发的，并且有如此相似的API，所以从木偶师转移到剧作家<a href="https://medium.com/@davert/puppeteer-to-playwright-migration-guide-6c86ea66e85e">并不是</a> ' <a href="https://medium.com/@davert/puppeteer-to-playwright-migration-guide-6c86ea66e85e">太难</a>。然而，你不应该仅仅因为剧作家是新的就选择剧作家而不是木偶师——剧作家还没有达到1.0版本，所以API <a href="https://github.com/microsoft/playwright#q-is-playwright-ready">可能会在那之前得到突破性的变化</a>。</p>
<p>我认为要考虑的三个主要因素是跨浏览器支持、长期库支持和您的浏览器自动化的特定用例。</p>
<p>对于跨浏览器支持，重要的是要知道木偶师<a href="https://github.com/puppeteer/puppeteer/releases/tag/v2.1.0">最近增加了</a>对驱动Firefox的实验性支持，并且能够在不修补Firefox的情况下做到这一点。</p>
<pre>const browser = await puppeteer.launch({product: "firefox"});</pre>
<p>然而，<a href="https://github.com/puppeteer/puppeteer/issues/4887">似乎没有任何关于WebKit的木偶师支持的公开工作。注意，即使是iOS </a><a href="https://stackoverflow.com/a/48541760/1481479">上的第三方浏览器也被要求</a>使用WebKit作为它们的引擎。因此，如果对你的iOS用户进行测试很重要，那么剧作家应该很有吸引力。</p>
<p>另一方面，许多团队认为测试多个浏览器(通常是Chrome)不值得边际收益。剧作家可以改变这种计算，因为它使跨浏览器支持更容易，但这仍然是坚持使用木偶师的潜在原因。</p>
<p>你也要考虑什么图书馆未来发展前景比较好。我们不确定剧作家修补Firefox和WebKit的方法是否能长期奏效。</p>
<p>然而，乐观的一个理由是，剧作家团队首先给了我们这些工具。新的木偶团队将不得不表明，它可以在改善各自的图书馆方面与剧作家团队保持同步。</p>
<p>无论如何，我很感激木偶师仍在积极开发中，绝不是因为最初的开发者离开了就放弃的项目。这是得到Chrome团队支持的一个好处。</p>
<p>最后，决定取决于您的用例。如果你正在做一些像自动化网站工作流程或截图的事情，跨浏览器支持可能对你来说并不重要。</p>
<p>如果硒对你有效，坚持使用硒或你目前正在使用的任何东西也是有意义的。web开发社区积累了多年关于Selenium的智慧和工具，您不必仅仅因为有了新的选择就放弃它。</p>
<p>具体测试来说，<a href="https://www.cypress.io/">柏树</a>也成为了热门选择。它有一个<a href="https://www.cypress.io/how-it-works">独特的方法</a>与你的网站代码一起运行，使测试更加可靠。它<a href="https://www.cypress.io/blog/2020/02/06/introducing-firefox-and-edge-support-in-cypress-4-0/">最近增加了</a> beta版火狐和Edge支持。</p>
<h2>结论</h2>
<p>总的来说，我很高兴浏览器自动化领域存在良性竞争。我希望它们能互相推动，变得更好，让浏览器自动化变得越来越容易和可靠。</p>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
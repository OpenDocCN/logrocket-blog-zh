<html>
<head>
<title>GraphQL queries explained in simple terms - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>用简单的术语解释GraphQL查询</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/graphql-queries-in-simple-terms/#0001-01-01">https://blog.logrocket.com/graphql-queries-in-simple-terms/#0001-01-01</a></blockquote><div><article class="article-post">
<p>GraphQL是一种用于API的查询语言。这是脸书在2015年开源的<a href="https://github.com/graphql" target="_blank" rel="noopener noreferrer"/>，从那以后作为REST 的<a href="https://blog.logrocket.com/graphql-vs-rest-what-you-didnt-know/" target="_blank" rel="noopener noreferrer">替代品而广受欢迎。创建GraphQL是为了在客户机和服务器之间有更好的通信。在这篇博文中，我们将学习GraphQL查询是什么，甚至自己写一些。</a></p>
<p>您可以将GraphQL查询想象成REST中的GET请求。GraphQL查询用于向GraphQL服务器查询客户端需要的数据。GraphQL的有趣之处在于，客户可以根据自己的需求编写定制的查询。这意味着GraphQL使客户端能够使用查询准确地询问他们想要的内容，并返回仅包含所询问内容的响应。这种方法给了客户端更多的权力。</p>
<p>为了进一步理解这一点，让我们探索一下构成GraphQL查询的概念。</p>
<h2>入门:使用GitHub的公共API</h2>
<p>为了演示和学习GraphQL查询，我将使用公众可用的<a href="https://developer.github.com/v4/" target="_blank" rel="noopener noreferrer"> GitHub API </a>。你可以跟着打开https://developer.github.com/v4/explorer/的<a href="https://developer.github.com/v4/explorer/" target="_blank" rel="noopener noreferrer"/>。确保您已登录GitHub帐户来运行查询。</p>
<p>在GitHub GraphQL explorer上，我们可以开始在左侧输入我们的查询，然后点击play在右侧查看JSON响应。我们还可以浏览右侧的API文档。资源管理器是针对GraphQL APIs编写查询的好方法。</p>
<p><img data-attachment-id="6068" data-permalink="https://blog.logrocket.com/graphql-queries-in-simple-terms/githubapi/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2019/09/githubapi.png" data-orig-size="730,324" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="githubapi" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2019/09/githubapi-300x133.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2019/09/githubapi.png" decoding="async" class="aligncenter wp-image-6068 jetpack-lazy-image" src="../Images/b89fc8b4032420c1bb5e008c1e1cc090.png" alt="githubapi" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2019/09/githubapi.png 730w, https://blog.logrocket.com/wp-content/uploads/2019/09/githubapi-300x133.png 300w" data-lazy-sizes="(max-width: 752px) 100vw, 752px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2019/09/githubapi.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/09/githubapi.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="6068" data-permalink="https://blog.logrocket.com/graphql-queries-in-simple-terms/githubapi/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2019/09/githubapi.png" data-orig-size="730,324" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="githubapi" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2019/09/githubapi-300x133.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2019/09/githubapi.png" decoding="async" loading="lazy" class="aligncenter wp-image-6068" src="../Images/b89fc8b4032420c1bb5e008c1e1cc090.png" alt="githubapi" srcset="https://blog.logrocket.com/wp-content/uploads/2019/09/githubapi.png 730w, https://blog.logrocket.com/wp-content/uploads/2019/09/githubapi-300x133.png 300w" sizes="(max-width: 752px) 100vw, 752px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/09/githubapi.png"/></noscript>
<p>菲尔茨</p>
<h2>GraphQL查询就是询问对象上的特定字段<a href="https://graphql.org/learn/queries/#fields" target="_blank" rel="noopener noreferrer">和</a>。</h2>
<p>GraphQL查询由字段组成。我将针对GitHub API编写我们的第一个查询。在这个查询中，我们查询字段<em>查看器</em>，并在其中查询字段<em>名称。</em></p>
<p><strong> <em>提示</em> </strong>:在浏览器上点击Ctrl+Space，将会显示所有可以根据API查询的可用字段。</p>
<p>这是我们收到的GraphQL响应。请注意，我们得到的正是我们所要求的。我们得到了JSON格式的查看者的名字。所有响应都包装在<em>数据</em>对象中。太好了！您编写了第一个GraphQL查询。让我们进一步了解查询。</p>
<pre>// GraphQL Query
{
  viewer {
    name
  }
}</pre>
<p>争论</p>
<pre>// GraphQL Response JSON
{
  "data": {
    "viewer": {
      "name": "Adhithi Ravichandran"
    }
  }
}</pre>
<h2><strong>参数可以传递给GraphQL中的字段和嵌套对象。这有助于消除从API获取数据的多次往返。</strong></h2>
<p>在GraphQL中，我们可以选择将参数值传递给字段，请求特定的数据。通过这样做，它不同于REST方法，并且消除了到多个端点的多次往返的需要。到API服务器的多次往返可能很繁琐，并且性能很高。使用REST，我们只能向URL传递一组参数。而使用GraphQL，您可以向每个字段和嵌套对象传递参数，完全消除了多次API获取。一个简单的查询就可以从API中获取我们需要的所有数据。</p>
<p>现在让我们针对<em>存储库</em>字段进行查询。这个字段需要我们传递两个参数，<em>的所有者</em>和<em>的名字。</em>我传递<em> google </em>作为拥有者，你可以传递你选择的任何其他组织作为参数。除此之外，我们还需要传递存储库的名称<em>和</em>。</p>
<p>我们从服务器返回的JSON响应如下。我们现在有了从服务器请求的<em>存储库</em>信息。通过传递不同的参数集，您可以进一步研究这个查询。</p>
<pre>// GraphQL Query with Arguments
{
  repository (owner:"google", name:"WebFundamentals") {
    name
    owner {
      id
    }
  }
}</pre>
<p>别名</p>
<pre>// GraphQL Response JSON
{
  "data": {
    "repository": {
      "name": "WebFundamentals",
      "owner": {
        "id": "MDEyOk9yZ2FuaXphdGlvbjEzNDIwMDQ="
      }
    }
  }
}</pre>
<h2>如果您想用多个参数查询同一个字段，该怎么办？有时，您可能会使用不同的参数集来查找同一字段的信息。您可以在GraphQL中使用Alias来实现这一点。</h2>
<p><strong>别名有助于查询相同的字段，在GraphQL中有不同的参数。</strong></p>
<p>让我们在前面的查询中添加更多内容。假设我想查询同一个字段<em>存储库，</em>，但是这次除了Google存储库之外，我还想查询脸书存储库。这导致GraphQL中的字段冲突。为了克服这一点，我们引入了别名。</p>
<p>提供别名后，我们的查询现在没有错误，可以运行了。JSON响应返回同一字段上两个参数的数据。每个响应都包含在别名中。我们在<em> googleRepo </em>和<em> facebookRepo </em>对象<em>中有响应。</em></p>
<pre>// GraphQL Query Aliases
{
  // alias "googleRepo"
  googleRepo: repository (owner:"google", name:"WebFundamentals") {
    name
    owner {
      id
    }
  }
  // alias "facebookRepo"
  facebookRepo: repository (owner:"facebook", name:"react") {
    name
    owner {
      id
    }
  }
}</pre>
<p>碎片</p>
<pre>// GraphQL JSON Response

{
  "data": {
    "googleRepo": {
      "name": "WebFundamentals",
      "owner": {
        "id": "MDEyOk9yZ2FuaXphdGlvbjEzNDIwMDQ="
      }
    },
    "facebookRepo": {
      "name": "react",
      "owner": {
        "id": "MDEyOk9yZ2FuaXphdGlvbjY5NjMx"
      }
    }
  }
}</pre>
<h2>编写GraphQL查询时一个有用的概念是<strong>片段。</strong>如果您注意到您的查询在多个区域中有许多重复的字段，您可以将它们合并成一个可重用的单元，称为片段。</h2>
<p>片段让你构建多个字段，并在多个查询中包含它们。这就像一个功能也是一个可重用的单元。</p>
<p>让我们看看下面的查询。注意，我们多次查询<em>所有者</em>字段中的相同字段。这是使用片段的好地方。</p>
<p>更多来自LogRocket的精彩文章:</p><div class="code-block code-block-54">
<hr/>
<h3>我们可以重写我们的查询来使用一个片段。片段是用关键字<strong> fragment </strong>创建的，并且可以使用唯一的名称。这与用编程语言编写函数是同一个概念。</h3>

<hr/></div>
<pre>{
  googleRepo: repository (owner:"google", name:"WebFundamentals") {
    name
    owner {
      id,
      avatarUrl
      resourcePath
      url
    }
  }
  facebookRepo: repository (owner:"facebook", name:"react") {
    name
    owner {
      id,
      avatarUrl
      resourcePath
      url
    }
  }
}</pre>
<p>我们可以创建一个名为<em> ownerInfo的片段。在创建片段时，我们必须让GraphQL知道它是在哪个字段上创建的。在我们的例子中，我们在<em> RepositoryOwner </em>字段上创建片段。在我们的片段定义中，我们可以包含我们在<em> RepositoryOwner </em>对象<em>上查询的所有字段。</em>我们将<em> id、avatarUrl、resourcePath </em>和<em> url </em>作为字段添加到我们的片段中。</em></p>
<p>然后，通过使用…运算符并提供片段的名称，您可以在查询中使用该片段，如下所示:</p>
<p>下面显示的代码是使用片段后的JSON响应。请注意，使用片段返回的响应不会有任何可见的变化。片段只是让你的查询看起来简洁易读。它对返回的查询响应没有影响。</p>
<pre>// GraphQL Query with fragments

{
  googleRepo: repository(owner: "google", name: "WebFundamentals") {
    name
    owner {
      ...ownerInfo //fragment
    }
  }
  facebookRepo: repository(owner: "facebook", name: "react") {
    name
    owner {
     ...ownerInfo //fragment
    }
  }
}

// fragment ownerInfo for RepositoryOwner fields
fragment ownerInfo on RepositoryOwner {
  id
  avatarUrl
  resourcePath
  url
}</pre>
<p>操作名称</p>
<pre>// GraphQL JSON Response

{
  "data": {
    "googleRepo": {
      "name": "WebFundamentals",
      "owner": {
        "id": "MDEyOk9yZ2FuaXphdGlvbjEzNDIwMDQ=",
        "avatarUrl": "https://avatars1.githubusercontent.com/u/1342004?v=4",
        "resourcePath": "/google",
        "url": "https://github.com/google"
      }
    },
    "facebookRepo": {
      "name": "react",
      "owner": {
        "id": "MDEyOk9yZ2FuaXphdGlvbjY5NjMx",
        "avatarUrl": "https://avatars3.githubusercontent.com/u/69631?v=4",
        "resourcePath": "/facebook",
        "url": "https://github.com/facebook"
      }
    }
  }
}</pre>
<h2>到目前为止，我们一直在编写查询，但没有为查询提供名称。当有多个查询时，为查询提供一个名称将确保可读性。</h2>
<p><strong>操作名是GraphQL操作的一个有意义且明确的名称。</strong></p>
<p>让我们在这里为我们的查询命名。我们可以使用关键字<em>查询</em>并提供我们选择的名称。</p>
<p>结论</p>
<pre>query repos{
  googleRepo: repository(owner: "google", name: "WebFundamentals") {
    name
    owner {
      ...ownerInfo
    }
  }
}</pre>
<h2>我希望您喜欢编写一些GraphQL查询。如果你有兴趣进一步了解GraphQL，并对GraphQL有一个全面的了解，你可以查看我在GraphQL上的<a href="https://app.pluralsight.com/library/courses/graphql-big-picture/table-of-contents" target="_blank" rel="noopener noreferrer"> Pluralsight </a>课程。</h2>
<p><strong>其他资源:</strong><br/><a href="https://graphql.org" target="_blank" rel="noopener noreferrer">https://graphql.org</a>/<br/><a href="https://graphql.org/learn/" target="_blank" rel="noopener noreferrer">https://graphql.org/learn/</a><br/><a href="https://www.graphql.com/" target="_blank" rel="noopener noreferrer">https://www.graphql.com/</a></p>
<p>如果您有任何意见，请发表在下面，并与您的团队和朋友分享这篇文章。</p>
<p>监控生产中失败和缓慢的GraphQL请求</p><div class="code-block code-block-24">
<div class="blog-plug inline-plug graphql-plug"><h2>虽然GraphQL有一些调试请求和响应的特性，但确保GraphQL可靠地为您的生产应用程序提供资源是一件比较困难的事情。如果您对确保对后端或第三方服务的网络请求成功感兴趣，</h2><p>.</p><a href="https://lp.logrocket.com/blg/graphql-signup" target="_blank">try LogRocket</a><p>LogRocket 就像是网络和移动应用的DVR，记录下你网站上发生的每一件事。您可以汇总并报告有问题的GraphQL请求，以快速了解根本原因，而不是猜测问题发生的原因。此外，您可以跟踪Apollo客户机状态并检查GraphQL查询的键值对。</p><a class="signup" href="https://lp.logrocket.com/blg/graphql-signup" target="_blank" rel="noopener noreferrer"><img src="../Images/432a3823c85b3fb72a206e6236a29f48.png" data-lazy-src="https://files.readme.io/69aa835-Image_2019-11-09_at_1.28.05_PM.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" class=" jetpack-lazy-image" data-original-src="https://files.readme.io/69aa835-Image_2019-11-09_at_1.28.05_PM.png"/><noscript><img data-lazy-fallback="1" src="../Images/432a3823c85b3fb72a206e6236a29f48.png" data-original-src="https://files.readme.io/69aa835-Image_2019-11-09_at_1.28.05_PM.png"/></noscript><img class="alignnone size-full wp-image-46 jetpack-lazy-image" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/><noscript><img data-lazy-fallback="1" class="alignnone size-full wp-image-46" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/></noscript></a><a href="https://lp.logrocket.com/blg/graphql-signup" target="_blank" rel="noopener noreferrer">https://logrocket.com/signup/</a><p>LogRocket检测您的应用程序以记录基线性能计时，如页面加载时间、到达第一个字节的时间、慢速网络请求，还记录Redux、NgRx和Vuex操作/状态。</p><p>.</p><a class="signup" href="https://lp.logrocket.com/blg/graphql-signup" target="_blank" rel="noopener noreferrer">Start monitoring for free</a><p>.</p></div>


</div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
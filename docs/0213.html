<html>
<head>
<title>Beyond REST — Using GraphQL to shape your data - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>超越REST——使用GraphQL塑造您的数据日志博客</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/beyond-rest-using-graphql-to-shape-your-data-6a04650e6242/#0001-01-01">https://blog.logrocket.com/beyond-rest-using-graphql-to-shape-your-data-6a04650e6242/#0001-01-01</a></blockquote><div><article class="article-post">
<figure><img decoding="async" src="../Images/d37674863342e843215a043ef3a57fa5.png" data-height="1280" data-width="1920" data-lazy-src="https://storage.googleapis.com/blog-images-backup/1*i0_DqUnyzbBVwF31kchSng.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" class=" jetpack-lazy-image" data-original-src="https://storage.googleapis.com/blog-images-backup/1*i0_DqUnyzbBVwF31kchSng.png"/><noscript><img data-lazy-fallback="1" decoding="async" src="../Images/d37674863342e843215a043ef3a57fa5.png" data-height="1280" data-width="1920" data-original-src="https://storage.googleapis.com/blog-images-backup/1*i0_DqUnyzbBVwF31kchSng.png"/></noscript></figure>
<h3>概观</h3>
<p>GraphQL是一个令人兴奋的API，用于专门查询和操纵分层数据。与REST相比，它非常灵活，有很好的工具，并提供了很多好处。</p>
<p>脸书在2012年开发了它，并使用它来驱动其庞大的社交图。GraphQL <a href="http://graphql.org/users/" target="_blank" rel="noopener noreferrer">在2015年开源后，采用率飙升</a>。</p>
<p>在本教程中，您将学习GraphQL的原理，它与REST的比较，如何实现查询，以及构建一个很酷的React应用程序来访问Github GraphQL。</p>
<h3>图形SQL？</h3>
<p>GraphQL首先是一种查询语言和规范，它为前端开发人员提供了查询图形和分层数据的强大能力。</p>
<p>使用GraphQL，您可以通过一次调用获取不同深度的许多资源。但是，GraphQL并没有就此止步。它还支持数据、变量甚至订阅(通过WebSockets)的变化。</p>
<p>GraphQL的基础是它的类型系统。有像字符串和整数这样的基本类型，也有具有命名属性的复杂类型。每个属性都有一个类型，可以是基本的，也可以是复杂的。</p>
<p>这就是等级制度的由来。当复杂类型具有本身就是复杂类型的属性时。特定的GraphQL应用程序有一个定义所有类型的模式。最好的部分是GraphQL支持自省，您可以查询它的模式来发现所有类型及其属性。</p>
<figure><a href="https://logrocket.com/signup/" target="_blank" rel="noopener noreferrer"><img decoding="async" src="../Images/94b3e0f84b30cb0d321f60471481ab64.png" data-height="750" data-width="3212" data-lazy-src="https://storage.googleapis.com/blog-images-backup/1*GPjaPKNNUYHU8EsA3Z0JGA.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" class=" jetpack-lazy-image" data-original-src="https://storage.googleapis.com/blog-images-backup/1*GPjaPKNNUYHU8EsA3Z0JGA.png"/><noscript><img data-lazy-fallback="1" decoding="async" src="../Images/94b3e0f84b30cb0d321f60471481ab64.png" data-height="750" data-width="3212" data-original-src="https://storage.googleapis.com/blog-images-backup/1*GPjaPKNNUYHU8EsA3Z0JGA.png"/></noscript></a></figure>
<p>让我们看一个模式定义语言的简单例子。这里有两种类型:玩家和团队。一个队可以有很多球员，一个球员属于一个队。此外，球队和球员都有名字和他们赢得的冠军数。</p>
<pre>type Player {
 id: ID
 name: String!
 team: Team!
 championshipCount: Integer!
}

type Team {
 id: ID
 name: String!
 players: [Player!]!
 championshipCount: Integer!
}</pre>
<p>请注意，team的players属性实际上是一个player对象数组。ID属性是GraphQL本身提供的基本类型。感叹号表示属性不能为空。你可以在这里找到完整的规格。</p>
<p>查询也是类型。下面是一个返回所有玩家的简单查询:</p>
<pre>type Query {
 allPlayers: [Player!]!
}</pre>
<p>为了创造新的玩家，我们可以定义一个突变:</p>
<pre>type Mutation {
 createPlayer(name: String, 
 championshipCount: Int, 
 teamId: String): Player
}</pre>
<p>这看起来很像一个函数，但它是一个类型。解析/解析客户端发送的GraphQL表达式并应用它们是服务器的工作。</p>
<p>GraphQL的另一个有趣之处是它的工具。我非常喜欢交互式图形浏览器<a href="https://github.com/graphql/graphiql" target="_blank" rel="noopener noreferrer"> GraphiQL </a>。它允许您尝试不同的查询，同时显示目标GraphQL模式，甚至具有自动完成和内置的<br/>验证。</p>
<p>这是一个在https://graphql.github.io/swapi-graphql从星球大战电影模式中查询飞船的例子。</p>
<p><img data-attachment-id="1518" data-permalink="https://blog.logrocket.com/beyond-rest-using-graphql-to-shape-your-data-6a04650e6242/attachment/1_ai1yxsm_lk_rwt1y-_4dmg/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2018/06/1_ai1Yxsm_Lk_rWt1Y-_4DMg.png" data-orig-size="1095,792" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="1_ai1Yxsm_Lk_rWt1Y-_4DMg" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2018/06/1_ai1Yxsm_Lk_rWt1Y-_4DMg-300x217.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2018/06/1_ai1Yxsm_Lk_rWt1Y-_4DMg-1024x741.png" decoding="async" class="aligncenter wp-image-1518 size-large jetpack-lazy-image" src="../Images/26016cd0e0d25cead123d27f64255369.png" alt="" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2018/06/1_ai1Yxsm_Lk_rWt1Y-_4DMg-1024x741.png 1024w, https://blog.logrocket.com/wp-content/uploads/2018/06/1_ai1Yxsm_Lk_rWt1Y-_4DMg-300x217.png 300w, https://blog.logrocket.com/wp-content/uploads/2018/06/1_ai1Yxsm_Lk_rWt1Y-_4DMg-768x555.png 768w, https://blog.logrocket.com/wp-content/uploads/2018/06/1_ai1Yxsm_Lk_rWt1Y-_4DMg.png 1095w" data-lazy-sizes="(max-width: 1024px) 100vw, 1024px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2018/06/1_ai1Yxsm_Lk_rWt1Y-_4DMg-1024x741.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2018/06/1_ai1Yxsm_Lk_rWt1Y-_4DMg-1024x741.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="1518" data-permalink="https://blog.logrocket.com/beyond-rest-using-graphql-to-shape-your-data-6a04650e6242/attachment/1_ai1yxsm_lk_rwt1y-_4dmg/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2018/06/1_ai1Yxsm_Lk_rWt1Y-_4DMg.png" data-orig-size="1095,792" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="1_ai1Yxsm_Lk_rWt1Y-_4DMg" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2018/06/1_ai1Yxsm_Lk_rWt1Y-_4DMg-300x217.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2018/06/1_ai1Yxsm_Lk_rWt1Y-_4DMg-1024x741.png" decoding="async" loading="lazy" class="aligncenter wp-image-1518 size-large" src="../Images/26016cd0e0d25cead123d27f64255369.png" alt="" srcset="https://blog.logrocket.com/wp-content/uploads/2018/06/1_ai1Yxsm_Lk_rWt1Y-_4DMg-1024x741.png 1024w, https://blog.logrocket.com/wp-content/uploads/2018/06/1_ai1Yxsm_Lk_rWt1Y-_4DMg-300x217.png 300w, https://blog.logrocket.com/wp-content/uploads/2018/06/1_ai1Yxsm_Lk_rWt1Y-_4DMg-768x555.png 768w, https://blog.logrocket.com/wp-content/uploads/2018/06/1_ai1Yxsm_Lk_rWt1Y-_4DMg.png 1095w" sizes="(max-width: 1024px) 100vw, 1024px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2018/06/1_ai1Yxsm_Lk_rWt1Y-_4DMg-1024x741.png"/></noscript>
<h3>GraphQL与。休息一下</h3>
<p>如果你眯着眼睛看，REST和GraphQL看起来非常相似。两者都遵循严格的概念框架，都使用HTTP作为传输，并且通常都使用JSON作为有效负载。</p>
<p>然而，相似之处到此为止。REST(表述性状态转移)将世界视为一组资源，您可以在这些资源上执行CRUD(创建、读取、更新和删除)操作。它与HTTP动词紧密耦合，旨在利用缓存等web基础设施。这是一个巧妙的想法，但是事实证明，严格使用基于资源的观点来对真实世界的领域建模是相当困难的。出于实际原因，开发人员很快偏离了纯REST方法，但仍然称他们的API为RESTful。</p>
<p>另一方面，GraphQL将世界视为具有属性的连接实体的图形。这种节点、边和属性视图对于建模世界来说更加自然，并且受到正式模式的支持。</p>
<p>此外，GraphQL解决了REST APIs一直难以解决的可怕的N+1问题。假设我们将《星球大战》电影建模为REST API。我们将为电影、角色、导演、星际飞船、行星等设置单独的端点。每个资源将由ID标识。</p>
<p>现在，让我们尝试获取一些嵌套信息，例如，让我们获取每部电影的导演姓名、所有角色以及每个角色的姓名、眼睛颜色和星球名称。要获得这些信息，首先我们需要获取所有的电影(1个查询返回N个结果)。电影资源将包含其导演的ID和角色ID列表。现在，对于每部电影，我们需要访问每部电影的导演端点并获取导演(N个查询返回1个结果)，然后我们需要聚合所有电影的所有角色id，删除重复项并访问每部电影的角色端点。一旦我们得到了角色，我们需要让每个角色到达行星的终点并取回它的母星。</p>
<p>如果你遵循严格的休息原则，那就没有办法了。你可以设计一个定制的端点，就像电影和他们的导演和角色和他们的家一样。但是，这不是REST，它感觉很笨拙，而且每当前端决定他们需要一些其他方法来查询数据时，您必须不断更改后端以支持不同的定制端点。</p>
<p>REST的另一个问题是过度获取。无论何时获得资源，都会获得它的所有属性或字段。通常，一个资源(或实体)会有许多属性，但是您只对名称或标题或所有属性的其他子集感兴趣。对于REST，没有办法指定它。</p>
<p>同样，您可以想出一种方法将它编码到查询参数中，但是想想如果您也有定制的端点来获取分层数据，那将是多么麻烦。您必须为查询中的每个实体类型指定您感兴趣的属性。GraphQL的查询语言通过其层次结构支持准确地获取您自然想要的内容，由于其模式，甚至可以生成工具和代码来自动验证它。</p>
<p>最后，但同样重要的是，GraphQL超越了HTTP，支持WebSockets上的订阅。客户端创建与服务器的稳定连接，这可以将事件推送到客户端。</p>
<h3>Raw GraphQL诉Apollo GraphQL客户端</h3>
<p>没有订阅的基本GraphQL的编程API非常简单。有一个HTTP端点、一个定义良好的模式和一个定义良好的查询语言，让您可以发送一个JSON blob来按照您想要的方式分割数据。当然，当您需要遍历大型数据集时，GraphQL也支持分页。因此，您可以使用任何HTTP客户端来查询(或改变)任何GraphQL服务。</p><div class="code-block code-block-54">
<hr/>
<h3>更多来自LogRocket的精彩文章:</h3>

<hr/></div>
<p>如果您不需要订阅(或者您连接到的GraphQL服务器没有定义任何订阅)，您可以在React应用程序中使用标准的fetch API(或Axios)。然而，如果你想将订阅整合到你的应用程序中，我推荐使用<a href="https://www.apollographql.com/docs/react/essentials/get-started.html" target="_blank" rel="noopener noreferrer"> Apollo客户端库</a>。</p>
<p>Apollo客户端还增加了一些其他不错的功能，比如:</p>
<ul>
<li>声明性数据提取</li>
<li>自动缓存</li>
<li>混合本地和远程数据</li>
</ul>
<p>让我们关注基本的GraphQL React以及如何将其与React应用程序集成。Apollo客户端的魔力只会妨碍理解正在发生的事情，如果不是不可能的话，也会使理解变得更加困难。</p>
<h3>了解GitHub GraphQL API</h3>
<p>GitHub(或者应该说微软GitHub？)公开了一个非常复杂和深入的<a href="https://developer.github.com/v4" target="_blank" rel="noopener noreferrer"> GraphQL API </a>。该模式非常精细，包含许多类型，表示GitHub的深层对象模型。</p>
<p>下面是Github GraphQL API支持的类型列表，每种类型都有几个示例:</p>
<ul>
<li>查询(字段、连接)</li>
<li>突变(createProject，addStar)</li>
<li>对象(责备、提交、提交注释)</li>
<li>接口(参与者，可分配)</li>
<li>枚举(GistPrivacy，DeploymentState)</li>
<li>联合(RequestedReviewer，MilestoneItem)</li>
<li>InputObjects (CommitAuthor，ReleaseOrder)</li>
<li>标量(URI，GitTimestamp)</li>
</ul>
<p>值得注意的是，不支持订阅。</p>
<p>我没有数过，但是很容易就有一百多种不同的类型反映了GitHub的每一个可编程和可搜索的方面。</p>
<p>GitHub甚至嵌入了一个GraphiQL <a href="https://developer.github.com/v4/explorer/" target="_blank" rel="noopener noreferrer"> explorer </a>,你可以玩它来熟悉它提供的丰富选项。右侧的模式面板为所有根类型提供了即时参考，当您将它与自动完成功能结合使用时，结果是一种非常直观的交互式体验。</p>
<p>下面是一个屏幕截图，展示了右边的模式文档(带超链接)和左边的自动完成:</p>
<figure><img decoding="async" src="../Images/961e87ec7ced5fd6fd1b86f6a7e990d8.png" data-height="632" data-width="1183" data-lazy-src="https://storage.googleapis.com/blog-images-backup/1*ECP8UrVkXFXlBBRKIhaV0Q.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" class=" jetpack-lazy-image" data-original-src="https://storage.googleapis.com/blog-images-backup/1*ECP8UrVkXFXlBBRKIhaV0Q.png"/><noscript><img data-lazy-fallback="1" decoding="async" src="../Images/961e87ec7ced5fd6fd1b86f6a7e990d8.png" data-height="632" data-width="1183" data-original-src="https://storage.googleapis.com/blog-images-backup/1*ECP8UrVkXFXlBBRKIhaV0Q.png"/></noscript></figure>
<p>让我们疯狂吧。微软最近已经成为开源的典范(这还不是最疯狂的部分)。下面的查询怎么样:获得微软存储库的总数及其累积的磁盘使用量+三个最受欢迎的微软回购(基于按流行度排序的星级数),对于每个回购显示项目的名称、url、星级数和最后提交作者的用户名(URL)。</p>
<p>以下是GraphQL查询:</p>
<pre>{
  organization(login: "Microsoft") {
    repositories(first: 3, 
                 orderBy: { field: STARGAZERS, 
                             direction: DESC }) {
      totalCount
      totalDiskUsage
      nodes {
        name
        homepageUrl
        stargazers {
          totalCount
        }
        commitComments(last: 1) {
          nodes {
            author {
              url
            }
          }
        }        
      }
    }
  }
}</pre>
<p>结果相当可观。微软在Github上有1841个Git存储库，总磁盘使用量约为44 GB(我从交互文档中了解到的单位是千字节)。排名前3的项目是VSCode (52，314 ★)、TypeScript (35，065 ★)和令人惊讶的认知工具包(14，590 ★)。</p>
<p>以下是完整的JSON回应:</p>
<pre>{
  "data": {
    "organization": {
      "repositories": {
        "totalCount": 1841,
        "totalDiskUsage": 44528492,
        "nodes": [
          {
            "name": "vscode",
            "homepageUrl": "<a href="https://code.visualstudio.com" target="_blank" rel="noopener noreferrer">https://code.visualstudio.com</a>",
            "stargazers": {
              "totalCount": 52314
            },
            "commitComments": {
              "nodes": [
                {
                  "author": {
                    "url": "<a href="https://github.com/CruiseMan" target="_blank" rel="noopener noreferrer">https://github.com/CruiseMan</a>"
                  }
                }
              ]
            }
          },
          {
            "name": "TypeScript",
            "homepageUrl": "<a href="http://www.typescriptlang.org" target="_blank" rel="noopener noreferrer">http://www.typescriptlang.org</a>",
            "stargazers": {
              "totalCount": 35065
            },
            "commitComments": {
              "nodes": [
                {
                  "author": {
                    "url": "<a href="https://github.com/adiebohi" target="_blank" rel="noopener noreferrer">https://github.com/adiebohi</a>"
                  }
                }
              ]
            }
          },
          {
            "name": "CNTK",
            "homepageUrl": "<a href="https://docs.microsoft.com/cognitive-toolkit/" target="_blank" rel="noopener noreferrer">https://docs.microsoft.com/cognitive-toolkit/</a>",
            "stargazers": {
              "totalCount": 14590
            },
            "commitComments": {
              "nodes": [
                {
                  "author": {
                    "url": "<a href="https://github.com/tprimak" target="_blank" rel="noopener noreferrer">https://github.com/tprimak</a>"
                  }
                }
              ]
            }
          }
        ]
      }
    }
  }
}</pre>
<p>我邀请你，勇敢的读者，从Github的<a href="https://developer.github.com/v3/" target="_blank" rel="noopener noreferrer"> REST API </a>中提取同样的信息。告诉我你进行了多少次API调用，获取了多少冗余数据。</p>
<h3>React应用程序中的GraphQL查询</h3>
<p>好吧，GraphQL很酷。让我们看看它在React应用程序中是如何工作的。</p>
<p>具有讽刺意味的是，<a href="https://gitlab.com/the-gigi/react-graphql-github" target="_blank" rel="noopener noreferrer">演示应用</a>存储在GitLab上。这与微软最近的公告无关。我在<a href="https://github.com/the-gigi/" target="_blank" rel="noopener noreferrer"> GitHub </a>和<a href="https://gitlab.com/the-gigi" target="_blank" rel="noopener noreferrer"> GitLab </a>上有很多项目，我计划继续使用这两个项目。该应用程序在GitHub GraphQL API中查询最近的<a href="https://kubernetes.io/" target="_blank" rel="noopener noreferrer"> Kubernetes </a>版本，并将它们显示在一个表格中。</p>
<p>我关心Kubernetes版本，因为PacktPub最近出版了我的书<a href="https://www.amazon.com/Mastering-Kubernetes-Master-container-management/dp/1788999789" target="_blank" rel="noopener noreferrer">掌握Kubernetes </a>的第二版，这是最新的1.10 Kubernetes版本。我正在密切关注Alpha和Beta版本，以保持对最新发展的了解。</p>
<p>下面是我将使用的查询:</p>
<figure><img decoding="async" src="../Images/67718fc404a4cc70914667487448206f.png" data-height="755" data-width="1438" data-lazy-src="https://storage.googleapis.com/blog-images-backup/1*Oy8lXHb7xYX7qFpLU75cSw.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" class=" jetpack-lazy-image" data-original-src="https://storage.googleapis.com/blog-images-backup/1*Oy8lXHb7xYX7qFpLU75cSw.png"/><noscript><img data-lazy-fallback="1" decoding="async" src="../Images/67718fc404a4cc70914667487448206f.png" data-height="755" data-width="1438" data-original-src="https://storage.googleapis.com/blog-images-backup/1*Oy8lXHb7xYX7qFpLU75cSw.png"/></noscript></figure>
<p>这是应用程序本身:</p>
<figure><img decoding="async" src="../Images/0b9492b1b057b0d3666a676c4838d3f7.png" data-height="1132" data-width="1108" data-lazy-src="https://storage.googleapis.com/blog-images-backup/1*4pSMbE56nu8M6ajQWUrKvw.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" class=" jetpack-lazy-image" data-original-src="https://storage.googleapis.com/blog-images-backup/1*4pSMbE56nu8M6ajQWUrKvw.png"/><noscript><img data-lazy-fallback="1" decoding="async" src="../Images/0b9492b1b057b0d3666a676c4838d3f7.png" data-height="1132" data-width="1108" data-original-src="https://storage.googleapis.com/blog-images-backup/1*4pSMbE56nu8M6ajQWUrKvw.png"/></noscript></figure>
<p>我为我糟糕的设计技巧道歉。</p>
<h3>钻研代码</h3>
<p>无论如何，这个应用是基于<a href="https://github.com/facebook/create-react-app" target="_blank" rel="noopener noreferrer">创建-反应-应用</a>的。很少有理由以任何其他方式在2018年启动React项目。</p>
<p>让我们直接进入代码。</p>
<p>有一个主应用程序组件、一个数据表单组件和一个发布列表组件。该应用负责与Github API服务器的所有交互。DataFetchForm是一个负责获取Github访问令牌的表单，该令牌是向Github GraphQL服务器认证应用程序所必需的。ReleaseList是一个简单的功能组件，它显示带有每个版本名称及其发布时间的表格。</p>
<h4>数据表单组件</h4>
<p>该组件在其状态中存储令牌(最初为空)以及在其props中接收的onFetch回调。</p>
<pre>import React, {Component} from 'react'

class DataFetchForm extends Component {
  constructor(props) {
    super(props)
    this.state = {
      onFetch: props.onFetch,
      token: '',
    }
  }</pre>
<p>render()方法显示带有auth令牌(security，first)的密码输入字段的表单。对吗？)和一个“获取”提交按钮。仅当您输入令牌时,“获取”按钮才会启用。每当您更改令牌的值时，就会调用onChange()方法，当您单击“fetch”时，就会调用onFetch()方法。</p>
<pre>render = () =&gt; {
    return (
        &lt;form onSubmit={this.onSubmit}&gt;
        &lt;label&gt;
          Auth token:
          &lt;input type="password" 
                 value={this.state.token} 
                 onChange={this.onChange}
          /&gt;
        &lt;/label&gt;
        &lt;input type="submit" 
               value="Fetch" 
               disabled={this.state.token === ''}
        /&gt;
      &lt;/form&gt;
    )
  }</pre>
<p>onChange()方法只存储当前状态的auth令牌:</p>
<pre>onChange = event =&gt; this.setState({…this.state, token: event.target.value})</pre>
<p>onSubmit()方法调用onFetch()回调函数，该函数是作为prop从其父方法接收的，并向其传递auth令牌:</p>
<pre>onSubmit = event =&gt; {
     this.state.onFetch(this.state.token)
     event.preventDefault()
 }</pre>
<h4>ReleaseList组件</h4>
<p>此组件在esch行中显示一个带有发布名称和发布日期的表。它的名气在于它可以忽略发行前的版本。它还将发布时间戳转换成更人性化的日期字符串。然后，它构建了一个名为“行”的数组，并把它们放在表格样板的中间。</p>
<pre>import React from 'react'
import '../App.css'

const ReleaseList = ({count, releases, includePrerelease}) =&gt; {
  if (releases.length === 0) {
    return null
  }
  if (!includePrerelease) {
    releases = releases.filter(r =&gt; !r.isPrerelease)
  }

let rows = releases.map(r =&gt; &lt;tr key={r.name}&gt;
                                  &lt;td&gt;{r.name}&lt;/td&gt;
                                  &lt;td&gt;{(new Date(r.publishedAt)).toDateString()}&lt;/td&gt;
                                &lt;/tr&gt;)
  return  &lt;table&gt;
            &lt;thead&gt;
              &lt;tr&gt;
                &lt;td&gt;Name&lt;/td&gt;
                &lt;td&gt;Published On&lt;/td&gt;
              &lt;/tr&gt;
            &lt;/thead&gt;
            &lt;tbody&gt;
              {rows}
            &lt;/tbody&gt;
          &lt;/table&gt;
}

export default ReleaseList</pre>
<p>如果你一定要欣赏这个网页设计的经典杰作，你可以看看<a href="https://gitlab.com/the-gigi/react-graphql-github/blob/master/src/App.css" target="_blank" rel="noopener noreferrer"> App.css文件</a>。</p>
<h4>应用程序组件</h4>
<p>应用组件是酷小子。它从导入React、各种组件、css文件和<a href="https://github.com/axios/axios" target="_blank" rel="noopener noreferrer"> Axios </a>(比内置的fetch API更好的HTTP客户端)开始。然后，它定义GitHub GraphQL API端点和请求发布的数量。州政府只是保留了一份最初为空的释放名单。</p>
<pre>import React, {Component} from 'react'
import './App.css'
import ReleaseList from "./components/ReleaseList"
import DataFetchForm from "./components/DataFetchForm"
import axios from 'axios'

const githubApiUrl = '<a href="https://api.github.com/graphql%27" target="_blank" rel="noopener noreferrer">https://api.github.com/graphql'</a>
const releaseCount = 10

class App extends Component {
  constructor(props) {
    super(props)
    this.state = {
      releases: []
    }
  }</pre>
<p>render()方法也很普通。它显示标题、数据获取表单(向其传递onFetch()方法)以及最后的ReleaseList，其中包含发布计数、来自状态的发布列表以及false以忽略预发布发布。</p>
<pre id="6ac2" class="graf graf--pre graf-after--p">render() {
    return (
      &lt;div className="App"&gt;
        &lt;header className="App-header"&gt;
          &lt;h1 className="App-title"&gt;
            React + GraphQL + Github API Demo App
          &lt;/h1&gt;
        &lt;/header&gt;
        &lt;h2 className="App-intro"&gt;
          Kubernetes Releases
        &lt;/h2&gt;
        &lt;DataFetchForm onFetch={this.onFetch}/&gt;
        &lt;ReleaseList count={releaseCount} 
                     releases={this.state.releases} 
                     includePrerelease={false}/&gt;
      &lt;/div&gt;
    )
  }
}</pre>
<p>好了，我们开始吧。当用户在dataFetch表单中单击fetch按钮时，就会调用onFetch()方法。查询字符串是多行GraphQL查询。注意，它必须以一个“查询”键盘开始，这在graphiql explorer中是不需要的。releaseCount从文件顶部的常量注入。</p>
<p>然后，它调用makes axios.post()传递jsonified查询和auth令牌。当结果返回时，它只是存储状态中的版本。提取数据需要使用<strong>r . data . data . repository . releases . nodes</strong>进行一些钻取，但这并不太糟糕。稍后，ReleaseList组件将从这些数据中获得意义。</p>
<pre>onFetch = (token) =&gt; {
    const query = `
      query { 
        repository(name: kubernetes, owner: kubernetes) {
          releases(first: ${releaseCount}, 
                   orderBy: { field: CREATED_AT, direction: DESC}) {
            totalCount
            nodes {
              name
              publishedAt
              isPrerelease
            }
          }
        }
      }
    `
axios.post(githubApiUrl, 
               JSON.stringify({query}), 
               {headers: {Authorization: `bearer ${token}`}})
      .then(r =&gt; {
        this.setState({...this.state, releases: r.data.data.repository.releases.nodes})
      })
      .catch(e =&gt; console.log(e))
  }</pre>
<h3>结论</h3>
<p>GraphQL是一个强大而灵活的工具，用于对分层数据进行切片和切块。它解决了REST APIs存在的一些重要问题，并拥有出色的工具和社区。</p>
<p>GitHub API是一个全面的、设计良好的GraphQL API，它展示了GraphQL在现实世界中的优势。我展示的演示应用程序展示了将GraphQL集成到React应用程序中是多么容易，即使没有像ApolloClient这样花哨的库。</p>
<p>现在，该是你玩GraphQL和构建酷东西的时候了。</p><div class="code-block code-block-17">
<div class="blog-plug inline-plug react-plug" vwo-el-id="26283398190">
<h2 vwo-el-id="41600691720"><a href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener"> LogRocket </a>:全面了解您的生产React应用</h2><p>调试React应用程序可能很困难，尤其是当用户遇到难以重现的问题时。如果您对监视和跟踪Redux状态、自动显示JavaScript错误以及跟踪缓慢的网络请求和组件加载时间感兴趣，</p><a href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" vwo-el-id="19356441070">try LogRocket</a><p>. </p><a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="19356441380">
<img class="first-react-image alignnone size-full wp-image-46 jetpack-lazy-image jetpack-lazy-image--handled" src="../Images/f300c244a1a1cf916df8b4cb02bec6c6.png" vwo-el-id="18272717540" data-lazy-loaded="1" data-original-src="https://files.readme.io/27c94e7-Image_2017-06-05_at_9.46.04_PM.png"/>
</a>
<a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="19356441690">
<img class="second-react-image alignnone size-full wp-image-46 jetpack-lazy-image jetpack-lazy-image--handled" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" vwo-el-id="30720362350" data-lazy-loaded="1" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/>
</a>
<p vwo-el-id="28675660440" class="">LogRocket 结合了会话回放、产品分析和错误跟踪，使软件团队能够创建理想的web和移动产品体验。这对你来说意味着什么？</p>
<p>LogRocket不是猜测错误发生的原因，也不是要求用户提供截图和日志转储，而是让您回放问题，就像它们发生在您自己的浏览器中一样，以快速了解哪里出错了。</p>
<p>不再有嘈杂的警报。智能错误跟踪允许您对问题进行分类，然后从中学习。获得有影响的用户问题的通知，而不是误报。警报越少，有用的信号越多。</p>
<p vwo-el-id="28675660750">LogRocket Redux中间件包为您的用户会话增加了一层额外的可见性。LogRocket记录Redux存储中的所有操作和状态。</p>
<p vwo-el-id="28675661060">现代化您调试React应用的方式— <a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="40093418840">开始免费监控</a>。</p>
</div></div>
<hr/>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
<html>
<head>
<title>Rust and Node.js: A match made in heaven - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>Rust和Node.js:天作之合</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/rust-and-node-js-a-match-made-in-heaven/#0001-01-01">https://blog.logrocket.com/rust-and-node-js-a-match-made-in-heaven/#0001-01-01</a></blockquote><div><article class="article-post">
<p>Node.js是一个非常流行的用于编写后端应用程序的JavaScript运行时。它的灵活性和非阻塞特性使它成为API消费的首选。</p>
<p/>
<p>由于它是一种脚本语言，JavaScript可能相当慢。但得益于V8优化，对于实际应用来说已经足够快了。也就是说，Node.js不适合重载；因为它是单线程的，所以阻塞主线程进行长时间的计算是很危险的。这就是<a href="https://blog.logrocket.com/node-js-multithreading-what-are-worker-threads-and-why-do-they-matter-48ab102f8b10/" target="_blank" rel="noopener noreferrer">工作线程</a>的用武之地。Node.js支持工作线程，因此可以用来执行长时间的计算。</p>
<p>尽管工作线程很棒，JavaScript仍然很慢。此外，工作线程并非在所有受支持的LTS版本的Node中都可用。幸运的是，我们可以使用Rust为Node.js构建一个原生插件。FFI是另一种选择，但它比插件方法慢。Rust运行速度极快，并且具有无所畏惧的并发性。由于Rust有一个非常小的运行时(或者“非运行时”)，我们的二进制文件也应该非常小。</p>
<h2 id="whatisrust">什么是铁锈？</h2>
<p>Rust是Mozilla开发的一种系统编程语言。默认情况下，它可以调用C库，并包括对将函数导出到C的一流支持。</p>
<p>Rust为你提供了低级的控制和高级的人体工程学。它让您可以控制内存管理，而没有与这些控制相关的麻烦。它还提供零成本的抽象，因此您只需为您使用的东西付费。</p>
<p>Rust可以通过各种方法在Node.js上下文中调用。我在下面列出了一些最广泛使用的。</p>
<ul>
<li>你可以从Node.js和Rust中使用FFI，但是这非常慢</li>
<li>您可以使用WebAssembly创建一个<code>node_module</code>，但是Node.js的所有功能都不可用</li>
<li>你可以使用本地插件</li>
</ul>
<h2 id="whatisanativeaddon">什么是本地插件？</h2>
<p>Node.js插件是用C++编写的动态链接的共享对象。您可以使用<code>require()</code>函数将它们加载到Node.js中，并像普通Node.js模块一样使用它们。它们主要提供Node.js中运行的JavaScript和C/C++库之间的接口。</p>
<p>一个本地插件提供了一个简单的接口，通过在V8运行时加载它来与另一个二进制文件一起工作。这是非常快速和安全的跨语言通话。目前，Node.js支持两种类型的插件方法:C++插件和N-API C++/C插件。</p>
<h3>C++插件</h3>
<p>C++插件是一个可以由Node.js挂载并在运行时使用的对象。由于C++是编译语言，所以这些插件非常快。C++拥有大量可用于生产的库，可用于扩展Node.js生态系统。许多流行的库使用本地插件来提高性能和代码质量。</p>
<h3>N-API C++/C插件</h3>
<p>C++插件的主要问题是，每当底层JavaScript运行时发生变化时，都需要重新编译它们。这导致了维护插件的问题。N-API试图通过引入标准应用程序二进制接口(ABI)来消除这种情况。C头文件保持向后兼容。这意味着您可以将为Node.js的特定版本编译的插件与比编译它的版本更高的任何版本一起使用。你可以用这个方法来实现你的插件。</p>
<h2 id="wheredoesrustcomein">铁锈是从哪里来的？</h2>
<p>Rust可以模仿C库的行为。换句话说，它以C能够理解和使用的格式导出函数。Rust调用C函数来访问和使用Node.js提供的API。这些API提供了创建JavaScript字符串、数组、数字、错误、对象、函数等的方法。但是我们需要告诉Rust这些外部函数、结构、指针等等。看起来像。</p>
<pre>#[repr(C)]
struct MyRustStruct {
    a: i32,
}
extern "C" fn rust_world_callback(target: *mut RustObject, a: i32) {
    println!("Function is called from C world", a);
    unsafe {
        // Do something on rust struct
        (*target).a = a;
    }
}
extern {
   fn register_callback(target: *mut MyRustStruct,
                        cb: extern fn(*mut MyRustStruct, i32)) -&gt; i32;
   fn trigger_callback();
}
</pre>
<p>Rust以不同的方式在内存中放置结构，所以我们需要告诉它使用C使用的样式。手工创建这些函数会很痛苦，所以我们将使用一个名为<code>nodejs-sys</code>的箱子，它使用<code>bindgen</code>为N-API创建一个很好的定义。</p>
<p><code>bindgen</code>自动生成到C和C++库的Rust FFI绑定。</p>
<p>注意:前面会有很多不安全的代码，大多是外部函数调用。</p>
<p><img data-attachment-id="17600" data-permalink="https://blog.logrocket.com/rust-and-node-js-a-match-made-in-heaven/joker-dont-say-i-didnt-warn-you-gif/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/04/joker-dont-say-i-didnt-warn-you-gif.gif" data-orig-size="220,199" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Joker GIF: “Don’t say I didn’t warn you”" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/04/joker-dont-say-i-didnt-warn-you-gif.gif" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/04/joker-dont-say-i-didnt-warn-you-gif.gif" decoding="async" class="aligncenter size-full wp-image-17600 jetpack-lazy-image" src="../Images/9059d25396121088a425f04a37ef74aa.png" alt="GIF of the Joker Saying &quot;Don't Say I Didn't Warn You&quot;" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2020/04/joker-dont-say-i-didnt-warn-you-gif.gif?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/04/joker-dont-say-i-didnt-warn-you-gif.gif"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="17600" data-permalink="https://blog.logrocket.com/rust-and-node-js-a-match-made-in-heaven/joker-dont-say-i-didnt-warn-you-gif/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/04/joker-dont-say-i-didnt-warn-you-gif.gif" data-orig-size="220,199" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Joker GIF: “Don’t say I didn’t warn you”" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/04/joker-dont-say-i-didnt-warn-you-gif.gif" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/04/joker-dont-say-i-didnt-warn-you-gif.gif" decoding="async" loading="lazy" class="aligncenter size-full wp-image-17600" src="../Images/9059d25396121088a425f04a37ef74aa.png" alt="GIF of the Joker Saying &quot;Don't Say I Didn't Warn You&quot;" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/04/joker-dont-say-i-didnt-warn-you-gif.gif"/></noscript>
<h2 id="settingupyourproject">设置您的项目</h2>
<p>对于本教程，您必须在系统上安装<a href="https://nodejs.org/" target="_blank" rel="noopener noreferrer"> Node.js </a>和<a href="https://www.rust-lang.org/" target="_blank" rel="noopener noreferrer"> Rust </a>，以及<a href="https://github.com/rust-lang/cargo/" target="_blank" rel="noopener noreferrer"> Cargo </a>和<a href="https://www.npmjs.com/" target="_blank" rel="noopener noreferrer"> npm </a>。我建议用<a href="https://rustup.rs/" target="_blank" rel="noopener noreferrer"> Rustup </a>安装Rust，用<a href="https://github.com/nvm-sh/nvm" target="_blank" rel="noopener noreferrer"> nvm </a>安装Node.js。</p>
<p>创建一个名为<code>rust-addon</code>的目录，并通过运行<code>npm init</code>初始化一个新的npm项目。接下来，启动一个名为<code>cargo init --lib</code>的货运项目。您的项目目录应该如下所示:</p>
<pre>├── Cargo.toml
├── package.json
└── src
    └── lib.rs
</pre>
<h3>配置Rust编译到插件</h3>
<p>我们需要Rust编译成动态C库或对象。在Linux上配置cargo编译成<code>.so</code>文件，在OS X上编译成<code>.dylib</code>，在Windows上编译成<code>.dll</code>。Rust可以使用Rustc标志或Cargo生成许多不同类型的库。</p>
<pre>[package]
name = "rust-addon"
version = "0.1.0"
authors = ["Anshul Goyal &lt;<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="2e4f405d465b4249414b421f1b1f1717176e49434f4742004d4143">[email protected]</a>&gt;"]
edition = "2018"
# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[lib]
crate-type=["cdylib"]

[dependencies]
nodejs-sys = "0.2.0"
</pre>
<p><code>lib</code>键提供了配置Rustc的选项。<code>name</code>键以<code>lib{name}</code>的形式给出了共享对象的库名，而<code>type</code>提供了它应该被编译到的库的类型——例如<code>cdylib</code>、<code>rlib</code>等。创建一个动态链接的C库。这个共享对象的行为就像一个C库。</p>
<h3>N-API入门</h3>
<p>让我们创建我们的N-API库。我们需要添加一个依赖项。<code>nodejs-sys</code>提供<code>napi-header</code>文件所需的绑定。<code>napi_register_module_v1</code>是插件的入口点。<a href="https://nodejs.org/api/n-api.html#n_api_module_registration" target="_blank" rel="noopener noreferrer"> N-API文档</a>推荐<code>N-API_MODULE_INIT</code>宏用于模块注册，编译成<code>napi_register_module_v1</code>函数。</p>
<p>Node.js调用这个函数，并给它提供一个名为<code>napi_env</code>的不透明指针，这个指针指的是JavaScript运行时的模块配置，还有<code>napi_value</code>。后者是另一个表示JavaScript值的不透明指针，实际上是一个称为导出的对象。这些导出与JavaScript中的<code>require</code>函数提供给Node.js模块的导出相同。</p>
<pre>use nodejs_sys::{napi_create_string_utf8, napi_env, napi_set_named_property, napi_value};
use std::ffi::CString;
#[no_mangle]
pub unsafe extern "C" fn napi_register_module_v1(
    env: napi_env,
    exports: napi_value,
) -&gt; nodejs_sys::napi_value {
// creating a C string
    let key = CString::new("hello").expect("CString::new failed");
// creating a memory location where the pointer to napi_value will be saved
    let mut local: napi_value = std::mem::zeroed();
// creating a C string
    let value = CString::new("world!").expect("CString::new failed");
// creating napi_value for the string
    napi_create_string_utf8(env, value.as_ptr(), 6, &amp;mut local);
// setting the string on the exports object
    napi_set_named_property(env, exports, key.as_ptr(), local);
// returning the object 
    exports
}
</pre>
<p>Rust用<code>String</code>类型表示自己拥有的字符串，用<code>str</code>原语表示借用的字符串片段。两者都是UTF-8编码，中间可能包含空字节。如果你看看组成字符串的字节，其中可能有一个<code>\0</code>。<code>String</code>和<code>str</code>都显式存储它们的长度；像C字符串一样，字符串末尾没有空终止符。</p>
<p>Rust字符串与C中的字符串非常不同，所以我们需要将Rust字符串更改为C字符串，然后才能在N-API函数中使用then。由于<code>exports</code>是由<code>exports</code>表示的对象，我们可以添加函数、字符串、数组或任何其他JavaScript对象作为键值对。</p>
<p>要向JavaScript对象添加一个键，可以使用N-API <code>napi_set_named_property</code>提供的方法。这个函数接受我们想要添加属性的对象；指向将用作我们属性的键的字符串的指针；指向JavaScript值的指针，可以是字符串、数组等。；和<code>napi_env</code>，它充当Rust和Node.js之间的锚。</p><div class="code-block code-block-54">
<hr/>
<h3>更多来自LogRocket的精彩文章:</h3>

<hr/></div>
<p>您可以使用N-API函数来创建任何JavaScript值。例如，我们在这里使用<code>napi_create_string_utf8</code>来创建一个字符串。我们在环境中传递了一个指向字符串的指针，字符串的长度，以及一个指向空内存位置的指针，它可以在那里写入指向新创建的值的指针。所有这些代码都是不安全的，因为它包含了许多对外部函数的调用，而编译器不能提供Rust保证。最后，我们通过在模块上设置一个值为<code>world!</code>的属性，返回了提供给我们的模块。</p>
<p>重要的是要明白<code>nodejs-sys</code>只是为你正在使用的函数提供了必要的定义，而不是它们的实现。N-API实现包含在Node.js中，您可以从Rust代码中调用它。</p>
<h2 id="usingtheaddoninnodejs">使用Node.js中的插件</h2>
<p>下一步是为不同的操作系统添加链接配置，然后就可以编译它了。</p>
<p>创建一个<code>build.rs</code>文件来添加一些配置标志，用于链接不同操作系统上的N-API文件。</p>
<pre>fn main() {
    println!("cargo:rustc-cdylib-link-arg=-undefined");
    if cfg!(target_os = "macos") {
        println!("cargo:rustc-cdylib-link-arg=dynamic_lookup");
    }
}
</pre>
<p>您的目录应该如下所示:</p>
<pre>├── build.rs
├── Cargo.lock
├── Cargo.toml
├── index.node
├── package.json
├── src
    └── lib.rs
</pre>
<p>现在你需要编译你的Rust插件。您可以使用简单的命令<code>cargo build --release</code>非常容易地做到这一点。这将需要一些时间在第一次运行。</p>
<p>在您的模块被编译之后，从<code>./target/release/libnative.so</code>到您的根目录创建这个二进制文件的副本，并将其重命名为<code>index.node</code>。由cargo创建的二进制文件可能有不同的扩展名或名称，这取决于您的机箱设置和操作系统。</p>
<p>现在，您可以要求Node.js中的文件并使用它。您也可以在脚本中使用它。例如:</p>
<pre>let addon=require('./index.node');
console.log(addon.hello);
</pre>
<p><img data-attachment-id="17601" data-permalink="https://blog.logrocket.com/rust-and-node-js-a-match-made-in-heaven/using-addon-in-node/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/04/using-addon-in-node.png" data-orig-size="511,196" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Using the addon in Node" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/04/using-addon-in-node-300x115.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/04/using-addon-in-node.png" decoding="async" class="aligncenter size-full wp-image-17601 jetpack-lazy-image" src="../Images/46d5fe94a0d67ee5f8673b736ed6ea95.png" alt="Using the Addon in Node" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2020/04/using-addon-in-node.png 511w, https://blog.logrocket.com/wp-content/uploads/2020/04/using-addon-in-node-300x115.png 300w" data-lazy-sizes="(max-width: 511px) 100vw, 511px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2020/04/using-addon-in-node.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/04/using-addon-in-node.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="17601" data-permalink="https://blog.logrocket.com/rust-and-node-js-a-match-made-in-heaven/using-addon-in-node/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/04/using-addon-in-node.png" data-orig-size="511,196" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Using the addon in Node" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/04/using-addon-in-node-300x115.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/04/using-addon-in-node.png" decoding="async" loading="lazy" class="aligncenter size-full wp-image-17601" src="../Images/46d5fe94a0d67ee5f8673b736ed6ea95.png" alt="Using the Addon in Node" srcset="https://blog.logrocket.com/wp-content/uploads/2020/04/using-addon-in-node.png 511w, https://blog.logrocket.com/wp-content/uploads/2020/04/using-addon-in-node-300x115.png 300w" sizes="(max-width: 511px) 100vw, 511px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/04/using-addon-in-node.png"/></noscript>
<p>接下来，我们将继续创建函数、数组和承诺，并使用<code>libuv thread-pool</code>在不阻塞主线程的情况下执行繁重的任务。</p>
<h2 id="adeepdiveintonapi">深入探究N-API</h2>
<p>现在您知道了如何使用N-API和Rust实现通用模式。一个非常常见的模式是导出函数，库或节点模块的用户可以调用它。让我们从创建一个函数开始。</p>
<p>您应该使用<code>napi_create_function</code>来创建您的函数，以便您可以从Node.js中使用它们。</p>
<h3>创建函数</h3>
<p>JavaScript函数也由<code>napi_value</code>指针表示。N-API函数非常容易创建和使用。</p>
<pre>use nodejs_sys::{
    napi_callback_info, napi_create_function, napi_create_string_utf8, napi_env,
    napi_set_named_property, napi_value,
};
use std::ffi::CString;
pub unsafe extern "C" fn say_hello(env: napi_env, _info: napi_callback_info) -&gt; napi_value {
// creating  a javastring string
    let mut local: napi_value = std::mem::zeroed();
    let p = CString::new("Hello from rust").expect("CString::new    failed");
    napi_create_string_utf8(env, p.as_ptr(), 13, &amp;mut local);
// returning the javascript string
    local
}
#[no_mangle]
pub unsafe extern "C" fn napi_register_module_v1(
    env: napi_env,
    exports: napi_value,
) -&gt; nodejs_sys::napi_value {
// creating a C String
    let p = CString::new("myFunc").expect("CString::new failed");
// creating a location where pointer to napi_value be written
    let mut local: napi_value = std::mem::zeroed();
    napi_create_function(
        env,
// pointer to function name
        p.as_ptr(),
// length of function name
        5,
// rust function
        Some(say_hello),
// context which can be accessed by the rust function
        std::ptr::null_mut(),
// output napi_value
        &amp;mut local,
    );
// set function as property 
    napi_set_named_property(env, exports, p.as_ptr(), local);
// returning exports
    exports
}
</pre>
<p><img data-attachment-id="17602" data-permalink="https://blog.logrocket.com/rust-and-node-js-a-match-made-in-heaven/rust-function-created-with-n-api/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/04/rust-function-created-with-n-api.png" data-orig-size="458,204" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Function created with N-API" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/04/rust-function-created-with-n-api-300x134.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/04/rust-function-created-with-n-api.png" decoding="async" class="aligncenter size-full wp-image-17602 jetpack-lazy-image" src="../Images/db6677419eeca4b746ed9fd06847c236.png" alt="Function Created With N-API" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2020/04/rust-function-created-with-n-api.png 458w, https://blog.logrocket.com/wp-content/uploads/2020/04/rust-function-created-with-n-api-300x134.png 300w" data-lazy-sizes="(max-width: 458px) 100vw, 458px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2020/04/rust-function-created-with-n-api.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/04/rust-function-created-with-n-api.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="17602" data-permalink="https://blog.logrocket.com/rust-and-node-js-a-match-made-in-heaven/rust-function-created-with-n-api/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/04/rust-function-created-with-n-api.png" data-orig-size="458,204" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Function created with N-API" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/04/rust-function-created-with-n-api-300x134.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/04/rust-function-created-with-n-api.png" decoding="async" loading="lazy" class="aligncenter size-full wp-image-17602" src="../Images/db6677419eeca4b746ed9fd06847c236.png" alt="Function Created With N-API" srcset="https://blog.logrocket.com/wp-content/uploads/2020/04/rust-function-created-with-n-api.png 458w, https://blog.logrocket.com/wp-content/uploads/2020/04/rust-function-created-with-n-api-300x134.png 300w" sizes="(max-width: 458px) 100vw, 458px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/04/rust-function-created-with-n-api.png"/></noscript>
<p>在上面的例子中，我们在Rust中创建了一个名为<code>say_hello</code>的函数，当JavaScript调用这个函数时就会执行这个函数。我们使用<code>napi_create_function</code>创建了一个函数，它接受以下参数:</p>
<ul>
<li>环境的<code>napi_env</code>价值</li>
<li>提供给JavaScript函数的函数名字符串</li>
<li>函数名字符串的长度</li>
<li>JavaScript调用新创建的函数时执行的函数</li>
<li>用户稍后可以传递并从Rust函数中访问的上下文数据</li>
<li>一个空的内存地址，可以保存指向JavaScript函数的指针</li>
<li>当您创建这个函数时，将它作为属性添加到您的<code>exports</code>对象，这样您就可以在JavaScript中使用它</li>
</ul>
<p>Rust端的函数必须具有与示例中所示相同的签名。接下来我们将讨论如何使用<code>napi_callback_info</code>访问函数内部的参数。我们可以通过函数和其他参数来访问它。</p>
<h3>访问参数</h3>
<p>函数参数非常重要。N-API提供了访问这些参数的方法。<code>napi_callback_info</code>在代码的JavaScript端向指针提供函数的详细信息。</p>
<pre>use nodejs_sys::{
    napi_callback_info, napi_create_double, napi_create_function, napi_env, napi_get_cb_info,
    napi_get_value_double, napi_set_named_property, napi_value,
};
use std::ffi::CString;

pub unsafe extern "C" fn add(env: napi_env, info: napi_callback_info) -&gt; napi_value {
// creating a buffer where napi_value of argument be written
    let mut buffer: [napi_value; 2] = std::mem::MaybeUninit::zeroed().assume_init();
// max number of arguments
    let mut argc = 2 as usize;
// getting arguments and value of this
    napi_get_cb_info(
        env,
        info,
        &amp;mut argc,
        buffer.as_mut_ptr(),
        std::ptr::null_mut(),
        std::ptr::null_mut(),
    );
// converting napi to f64
    let mut x = 0 as f64;
    let mut y = 0 as f64;
    napi_get_value_double(env, buffer[0], &amp;mut x);
    napi_get_value_double(env, buffer[1], &amp;mut y);
// creating the return value
    let mut local: napi_value = std::mem::zeroed();
    napi_create_double(env, x + y, &amp;mut local);
// returning the result
    local
}

#[no_mangle]
pub unsafe extern "C" fn napi_register_module_v1(
    env: napi_env,
    exports: napi_value,
) -&gt; nodejs_sys::napi_value {
// creating a function name
    let p = CString::new("myFunc").expect("CString::new failed");
    let mut local: napi_value = std::mem::zeroed();
// creating the function
    napi_create_function(
        env,
        p.as_ptr(),
        5,
        Some(add),
        std::ptr::null_mut(),
        &amp;mut local,
    );
// setting function as property
    napi_set_named_property(env, exports, p.as_ptr(), local);
// returning exports
    exports
}
</pre>
<p><img data-attachment-id="17603" data-permalink="https://blog.logrocket.com/rust-and-node-js-a-match-made-in-heaven/accessing-arguments-n-api/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/04/accessing-arguments-n-api.png" data-orig-size="406,181" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Accessing arguments with N-API" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/04/accessing-arguments-n-api-300x134.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/04/accessing-arguments-n-api.png" decoding="async" class="aligncenter size-full wp-image-17603 jetpack-lazy-image" src="../Images/c1ae090b4dafd1b9bcf1d4bfcf426ffe.png" alt="Accessing Arguments With N-API" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2020/04/accessing-arguments-n-api.png 406w, https://blog.logrocket.com/wp-content/uploads/2020/04/accessing-arguments-n-api-300x134.png 300w" data-lazy-sizes="(max-width: 406px) 100vw, 406px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2020/04/accessing-arguments-n-api.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/04/accessing-arguments-n-api.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="17603" data-permalink="https://blog.logrocket.com/rust-and-node-js-a-match-made-in-heaven/accessing-arguments-n-api/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/04/accessing-arguments-n-api.png" data-orig-size="406,181" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Accessing arguments with N-API" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/04/accessing-arguments-n-api-300x134.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/04/accessing-arguments-n-api.png" decoding="async" loading="lazy" class="aligncenter size-full wp-image-17603" src="../Images/c1ae090b4dafd1b9bcf1d4bfcf426ffe.png" alt="Accessing Arguments With N-API" srcset="https://blog.logrocket.com/wp-content/uploads/2020/04/accessing-arguments-n-api.png 406w, https://blog.logrocket.com/wp-content/uploads/2020/04/accessing-arguments-n-api-300x134.png 300w" sizes="(max-width: 406px) 100vw, 406px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/04/accessing-arguments-n-api.png"/></noscript>
<p>使用<code>napi_get_cb_info</code>获取参数。必须提供以下参数:</p>
<ul>
<li><code>napi_env</code></li>
<li>信息指针</li>
<li>预期参数的数量</li>
<li>参数可以写成<code>napi_value</code>的缓冲区</li>
<li>存储用户在创建JavaScript函数时提供的元数据的内存位置</li>
<li>可以写入该值指针的内存位置</li>
</ul>
<p>我们需要创建一个带有内存位置的数组，在这里C可以写一个指向参数的指针，我们可以将这个指针缓冲区传递给N-API函数。我们也得到<code>this</code>，但是在这个例子中我们没有使用它。</p>
<h3>使用字符串参数</h3>
<p>大多数时候，您需要在JavaScript中处理字符串。创建和获取字符串的值都非常简单。使用<code>napi_get_value_string_utf8</code>并调用这个函数两次:第一次获取长度，第二次获取字符串的值。</p>
<pre>use nodejs_sys::{
    napi_callback_info, napi_create_function, napi_env, napi_get_cb_info, napi_get_undefined,
    napi_get_value_string_utf8, napi_set_named_property, napi_value,
};

use std::ffi::CString;

pub unsafe extern "C" fn print(env: napi_env, info: napi_callback_info) -&gt; napi_value {
// creating a buffer of arguments
    let mut buffer: [napi_value; 1] = std::mem::MaybeUninit::zeroed().assume_init();
    let mut argc = 1 as usize;
// getting arguments
    napi_get_cb_info(
        env,
        info,
        &amp;mut argc,
        buffer.as_mut_ptr(),
        std::ptr::null_mut(),
        std::ptr::null_mut(),
    );
    let mut len = 0;
// getting length by passing null buffer
    napi_get_value_string_utf8(env, buffer[0], std::ptr::null_mut(), 0, &amp;mut len);
    let size = len as usize;
// creating a buffer where string can be placed
    let mut ve: Vec&lt;u8&gt; = Vec::with_capacity(size + 1);
    let raw = ve.as_mut_ptr();
// telling rust not manage the vector
    std::mem::forget(ve);
    let mut cap = 0;
// getting the string value from napi_value
    let _s = napi_get_value_string_utf8(env, buffer[0], raw as *mut i8, size + 1, &amp;mut cap);
    let s = String::from_raw_parts(raw, cap as usize, size);
// printing the string
    println!("{}", s);
// creating an undefined
    let mut und: napi_value = std::mem::zeroed();
    napi_get_undefined(env, &amp;mut und);
// returning undefined
    und
}

#[no_mangle]
pub unsafe extern "C" fn napi_register_module_v1(
    env: napi_env,
    exports: napi_value,
) -&gt; nodejs_sys::napi_value {
    let p = CString::new("myFunc").expect("CString::new failed");
    let mut local: napi_value = std::mem::zeroed();
    napi_create_function(
        env,
        p.as_ptr(),
        5,
        Some(print),
        std::ptr::null_mut(),
        &amp;mut local,
    );
    napi_set_named_property(env, exports, p.as_ptr(), local);
    exports
}
</pre>
<p><img data-attachment-id="17604" data-permalink="https://blog.logrocket.com/rust-and-node-js-a-match-made-in-heaven/string-arguments-n-api/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/04/string-arguments-n-api.png" data-orig-size="412,216" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="String arguments in N-API" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/04/string-arguments-n-api-300x157.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/04/string-arguments-n-api.png" decoding="async" class="aligncenter size-full wp-image-17604 jetpack-lazy-image" src="../Images/e8be508a3ec3ffc71c73ce767bb309d7.png" alt="String Arguments in N-API" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2020/04/string-arguments-n-api.png 412w, https://blog.logrocket.com/wp-content/uploads/2020/04/string-arguments-n-api-300x157.png 300w" data-lazy-sizes="(max-width: 412px) 100vw, 412px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2020/04/string-arguments-n-api.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/04/string-arguments-n-api.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="17604" data-permalink="https://blog.logrocket.com/rust-and-node-js-a-match-made-in-heaven/string-arguments-n-api/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/04/string-arguments-n-api.png" data-orig-size="412,216" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="String arguments in N-API" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/04/string-arguments-n-api-300x157.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/04/string-arguments-n-api.png" decoding="async" loading="lazy" class="aligncenter size-full wp-image-17604" src="../Images/e8be508a3ec3ffc71c73ce767bb309d7.png" alt="String Arguments in N-API" srcset="https://blog.logrocket.com/wp-content/uploads/2020/04/string-arguments-n-api.png 412w, https://blog.logrocket.com/wp-content/uploads/2020/04/string-arguments-n-api-300x157.png 300w" sizes="(max-width: 412px) 100vw, 412px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/04/string-arguments-n-api.png"/></noscript>
<p>您需要向<code>napi_create_string_utf8</code>传递一些参数来创建一个字符串。如果将空指针作为缓冲区传递，则给出字符串的长度。下列参数是必需的:</p>
<ul>
<li><code>napi_env</code></li>
<li><code>napi_value</code>指针指向<code>javascript side</code>中的字符串</li>
<li>如果null给出了字符串的长度，则将字符串写入的缓冲区</li>
<li>缓冲区的长度</li>
<li>写入缓冲区的字节数</li>
</ul>
<h2 id="workingwithpromisesandlibuvthreadpool">使用promises和libuv线程池</h2>
<p>阻塞Node.js的主线程来做计算并不是一个好主意。您可以使用libuv线程来完成繁重的工作。</p>
<p>首先，创造一个承诺。承诺会根据你工作的成功来拒绝或解决。为此，您需要创建三个函数。第一个函数从JavaScript世界调用，控制权将传递给第二个函数，第二个函数运行在libuv线程上，不能访问JavaScript。第三个函数可以访问JavaScript端，在第二个函数完成后调用。您可以对libuv线程使用<code>napi_create_async_work</code>方法。</p>
<h3>创造承诺</h3>
<p>要创建承诺，只需使用<code>napi_create_promise</code>。这将提供一个指针<code>napi_deferred</code>，它可以使用以下函数解决或拒绝承诺:</p>
<ul>
<li><code>napi_resolve_deferred</code></li>
<li><code>napi_reject_deferred</code></li>
</ul>
<h3>错误处理</h3>
<p>您可以使用<code>napi_create_error</code>和<code>napi_throw_error</code>从Rust代码中创建并抛出一个错误。每个N-API函数都返回一个<code>napi_status</code>，应该检查。</p>
<h3>真实代码</h3>
<p>以下示例显示了如何调度异步工作。</p>
<pre>use nodejs_sys::{
    napi_async_work, napi_callback_info, napi_create_async_work, napi_create_error,
    napi_create_function, napi_create_int64, napi_create_promise, napi_create_string_utf8,
    napi_deferred, napi_delete_async_work, napi_env, napi_get_cb_info, napi_get_value_int64,
    napi_queue_async_work, napi_reject_deferred, napi_resolve_deferred, napi_set_named_property,
    napi_status, napi_value,
};
use std::ffi::c_void;
use std::ffi::CString;

#[derive(Debug, Clone)]
struct Data {
    deferred: napi_deferred,
    work: napi_async_work,
    val: u64,
    result: Option&lt;Result&lt;u64, String&gt;&gt;,
}

pub unsafe extern "C" fn feb(env: napi_env, info: napi_callback_info) -&gt; napi_value {
    let mut buffer: Vec&lt;napi_value&gt; = Vec::with_capacity(1);
    let p = buffer.as_mut_ptr();
    let mut argc = 1 as usize;
    std::mem::forget(buffer);
    napi_get_cb_info(
        env,
        info,
        &amp;mut argc,
        p,
        std::ptr::null_mut(),
        std::ptr::null_mut(),
    );
    let mut start = 0;
    napi_get_value_int64(env, *p, &amp;mut start);
    let mut promise: napi_value = std::mem::zeroed();
    let mut deferred: napi_deferred = std::mem::zeroed();
    let mut work_name: napi_value = std::mem::zeroed();
    let mut work: napi_async_work = std::mem::zeroed();
    let async_name = CString::new("async fibonaci").expect("Error creating string");
    napi_create_string_utf8(env, async_name.as_ptr(), 13, &amp;mut work_name);
    napi_create_promise(env, &amp;mut deferred, &amp;mut promise);
    let v = Data {
        deferred,
        work,
        val: start as u64,
        result: None,
    };
    let data = Box::new(v);
    let raw = Box::into_raw(data);
    napi_create_async_work(
        env,
        std::ptr::null_mut(),
        work_name,
        Some(perform),
        Some(complete),
        std::mem::transmute(raw),
        &amp;mut work,
    );
    napi_queue_async_work(env, work);
    (*raw).work = work;
    promise
}

pub unsafe extern "C" fn perform(_env: napi_env, data: *mut c_void) {
    let mut t: Box&lt;Data&gt; = Box::from_raw(std::mem::transmute(data));
    let mut last = 1;
    let mut second_last = 0;
    for _ in 2..t.val {
        let temp = last;
        last = last + second_last;
        second_last = temp;
    }
    t.result = Some(Ok(last));
    Box::into_raw(task);
}

pub unsafe extern "C" fn complete(env: napi_env, _status: napi_status, data: *mut c_void) {
    let t: Box&lt;Data&gt; = Box::from_raw(std::mem::transmute(data));
    let v = match t.result {
        Some(d) =&gt; match d {
            Ok(result) =&gt; result,
            Err(_) =&gt; {
                let mut js_error: napi_value = std::mem::zeroed();
                napi_create_error(
                    env,
                    std::ptr::null_mut(),
                    std::ptr::null_mut(),
                    &amp;mut js_error,
                );
                napi_reject_deferred(env, t.deferred, js_error);
                napi_delete_async_work(env, t.work);
                return;
            }
        },
        None =&gt; {
            let mut js_error: napi_value = std::mem::zeroed();
            napi_create_error(
                env,
                std::ptr::null_mut(),
                std::ptr::null_mut(),
                &amp;mut js_error,
            );
            napi_reject_deferred(env, t.deferred, js_error);
            napi_delete_async_work(env, t.work);
            return;
        }
    };
    let mut obj: napi_value = std::mem::zeroed();
    napi_create_int64(env, v as i64, &amp;mut obj);
    napi_resolve_deferred(env, t.deferred, obj);

    napi_delete_async_work(env, t.work);
}

#[no_mangle]
pub unsafe extern "C" fn napi_register_module_v1(
    env: napi_env,
    exports: napi_value,
) -&gt; nodejs_sys::napi_value {
    let p = CString::new("myFunc").expect("CString::new failed");
    let mut local: napi_value = std::mem::zeroed();
    napi_create_function(
        env,
        p.as_ptr(),
        5,
        Some(feb),
        std::ptr::null_mut(),
        &amp;mut local,
    );
    napi_set_named_property(env, exports, p.as_ptr(), local);
    exports
}
</pre>
<p>我们创建了一个结构来存储指向我们的<code>napi_async_work</code>和<code>napi_deferred</code>以及输出的指针。最初，输出是<code>None</code>。然后我们创建了一个承诺，它提供了一个保存在我们的数据中的<code>deferred</code>。这些数据在我们所有的功能中都是可用的。</p>
<p>接下来，我们将数据转换成原始数据，并通过其他回调函数将其传递给<code>napi_create_async_work</code>函数。我们返回我们创建的承诺，执行<code>perform</code>，并将我们的数据转换回struct。</p>
<p>一旦<code>perform</code>在libuv线程上完成，就会从主线程中调用<code>complete</code>，以及之前操作的状态和我们的数据。现在，我们可以拒绝或解决我们的工作，并从队列中删除工作。</p>
<h2>让我们浏览一下代码</h2>
<p>创建一个名为<code>feb</code>的函数，它将被导出到JavaScript。这个函数将返回一个承诺，并为libuv线程池调度工作。</p>
<p>您可以通过创建一个承诺，使用<code>napi_create_async_work</code>，并向其传递两个函数来实现这一点。一个在libuv线程上执行，另一个在主线程上执行。</p>
<p>因为您只能从主线程执行JavaScript，所以您必须只从主线程解析或拒绝承诺。代码包含大量不安全的函数。</p>
<h3><code>feb</code>功能</h3>
<pre>pub unsafe extern "C" fn feb(env: napi_env, info: napi_callback_info) -&gt; napi_value {
    let mut buffer: Vec&lt;napi_value&gt; = Vec::with_capacity(1);
    let p = buffer.as_mut_ptr();
    let mut argc = 1 as usize;
    std::mem::forget(buffer);
// getting arguments for the function
    napi_get_cb_info(
        env,
        info,
        &amp;mut argc,
        p,
        std::ptr::null_mut(),
        std::ptr::null_mut(),
    );
    let mut start = 0;
// converting the napi_value to u64 number
    napi_get_value_int64(env, *p, &amp;mut start);
// promise which would be returned
    let mut promise: napi_value = std::mem::zeroed();
// a pointer to promise to resolve is or reject it
    let mut deferred: napi_deferred = std::mem::zeroed();
// a pointer to our async work name used for debugging
    let mut work_name: napi_value = std::mem::zeroed();
// pointer to async work 
    let mut work: napi_async_work = std::mem::zeroed();
    let async_name = CString::new("async fibonaci").expect("Error creating string");
// creating a string for name
    napi_create_string_utf8(env, async_name.as_ptr(), 13, &amp;mut work_name);
// creating a promise
    napi_create_promise(env, &amp;mut deferred, &amp;mut promise);
    let v = Data {
        deferred,
        work,
        val: start as u64,
        result: None,
    };
// creating a context which can be saved to share state between our functions
    let data = Box::new(v);
// converting it to raw pointer
    let raw = Box::into_raw(data);
// creating the work
    napi_create_async_work(
        env,
        std::ptr::null_mut(),
        work_name,
        Some(perform),
        Some(complete),
        std::mem::transmute(raw),
        &amp;mut work,
    );
// queuing to execute the work
    napi_queue_async_work(env, work);
// setting pointer to work that can be used later
    (*raw).work = work;
// retuning the pormise
    promise
}
</pre>
<h3><code>perform</code>功能</h3>
<pre>pub unsafe extern "C" fn perform(_env: napi_env, data: *mut c_void) {
// getting the shared data and converting the in box
    let mut t: Box&lt;Data&gt; = Box::from_raw(std::mem::transmute(data));
    let mut last = 1;
    let mut second_last = 0;
    for _ in 2..t.val {
        let temp = last;
        last = last + second_last;
        second_last = temp;
    }
// setting the result on shared context
    t.result = Some(Ok(last));
// telling the rust to not to drop the context data
    Box::into_raw(t);
}
</pre>
<h3><code>complete</code>功能</h3>
<pre>pub unsafe extern "C" fn complete(env: napi_env, _status: napi_status, data: *mut c_void) {
// getting the shared context
    let t: Box&lt;Data&gt; = Box::from_raw(std::mem::transmute(data));
    let v = match task.result {
        Some(d) =&gt; match d {
            Ok(result) =&gt; result,
            Err(_) =&gt; {
// if there is error just throw an error
// creating error
                let mut js_error: napi_value = std::mem::zeroed();
                napi_create_error(
                    env,
                    std::ptr::null_mut(),
                    std::ptr::null_mut(),
                    &amp;mut js_error,
                );
// rejecting the promise with error
                napi_reject_deferred(env, task.deferred, js_error);
// deleting the task from the queue
                napi_delete_async_work(env, task.work);
                return;
            }
        },
        None =&gt; {
// if no result is found reject with error
// creating an error
            let mut js_error: napi_value = std::mem::zeroed();
            napi_create_error(
                env,
                std::ptr::null_mut(),
                std::ptr::null_mut(),
                &amp;mut js_error,
            );
// rejecting promise with error
            napi_reject_deferred(env, task.deferred, js_error);
// deleting the task from queue
            napi_delete_async_work(env, task.work);
            return;
        }
    };
// creating the number
    let mut obj: napi_value = std::mem::zeroed();
    napi_create_int64(env, v as i64, &amp;mut obj);
// resolving the promise with result
    napi_resolve_deferred(env, t.deferred, obj);
// deleting the work
    napi_delete_async_work(env, t.work);
}
</pre>
<h2 id="conclusion">结论</h2>
<p>说到可以用N-API做什么，这只是冰山一角。我们讨论了一些模式并涵盖了基础知识，比如如何导出函数，创建常用的JavaScript类型，比如字符串、数字、数组、对象等。，获取函数的上下文(即获取函数中的参数和<code>this</code>)等。</p>
<p>我们还深入研究了如何使用<code>libuv</code>线程并创建一个<code>async_work</code>来在后台执行繁重的计算。最后，我们创建并使用了JavaScript的promises，并学习了如何在N-API中进行错误处理。</p>
<p>如果你不想手工编写所有的代码，有很多库可供使用。这些提供了很好的抽象，但是缺点是它们不支持所有的特性。</p>

<p> </p><div class="code-block code-block-23">
<div class="blog-plug inline-plug node-plug"><h2>200只<img src="../Images/61167b9d027ca73ed5aaf59a9ec31267.png" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2019/10/green-check.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" class=" jetpack-lazy-image" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/10/green-check.png"/> <noscript> <img data-lazy-fallback="1" src="../Images/61167b9d027ca73ed5aaf59a9ec31267.png" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/10/green-check.png"/> </noscript>显示器出现故障，生产中网络请求缓慢</h2><p>部署基于节点的web应用程序或网站是容易的部分。确保您的节点实例继续为您的应用程序提供资源是事情变得更加困难的地方。如果您对确保对后端或第三方服务的请求成功感兴趣，</p><a href="https://lp.logrocket.com/blg/node-signup" target="_blank">try LogRocket</a><p>. </p><a class="signup" href="https://lp.logrocket.com/blg/node-signup" target="_blank" rel="noopener noreferrer"><img src="../Images/cae72fd2a54c5f02a6398c4867894844.png" alt="LogRocket Network Request Monitoring" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2019/12/network-request-filter-2-1.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" class=" jetpack-lazy-image" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/12/network-request-filter-2-1.png"/><noscript><img data-lazy-fallback="1" src="../Images/cae72fd2a54c5f02a6398c4867894844.png" alt="LogRocket Network Request Monitoring" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/12/network-request-filter-2-1.png"/></noscript></a><a href="https://lp.logrocket.com/blg/node-signup" target="_blank" rel="noopener noreferrer">https://logrocket.com/signup/</a><p>LogRocket 就像是网络和移动应用程序的DVR，记录下用户与你的应用程序交互时发生的一切。您可以汇总并报告有问题的网络请求，以快速了解根本原因，而不是猜测问题发生的原因。</p><p>LogRocket检测您的应用程序以记录基线性能计时，如页面加载时间、到达第一个字节的时间、慢速网络请求，还记录Redux、NgRx和Vuex操作/状态。</p><a class="signup" href="https://lp.logrocket.com/blg/node-signup" target="_blank" rel="noopener noreferrer">Start monitoring for free</a><p>. </p></div>
</div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
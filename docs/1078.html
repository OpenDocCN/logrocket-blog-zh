<html>
<head>
<title>Creating a Gatsby blog from scratch - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>从头开始创建盖茨比博客</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/creating-a-gatsby-blog-from-scratch/#0001-01-01">https://blog.logrocket.com/creating-a-gatsby-blog-from-scratch/#0001-01-01</a></blockquote><div><article class="article-post">
<p>欢迎来到Gatsby(或Gatby.js)，这是一个强大的静态站点生成框架，它利用了GraphQL和React。随着时间的推移，盖茨比的知名度越来越高，越来越多的人开始使用它。其中一个原因是它能够帮助你直接快速地创建一个简单的静态网站。</p>
<p>你只需拿出他们的一个入门套件，在Netlify上注册一个账户，然后你就有了一个网站。</p>
<p>我以前也是这样建立网站的。我看到了一个可以毫不费力地立即创建博客的机会，于是就去了。但是后来当我试图在我的博客上添加一些复杂的逻辑时，出现了一个问题。我真的不明白幕后发生了什么。盖茨比在做什么，为什么看起来那么神奇？因此，我决定后退一步，从头开始创建一个盖茨比博客。</p>
<p>在这篇文章中，我将分享如何从一个简单的盖茨比初学者工具包建立一个博客，并解释盖茨比是如何在幕后工作的。这篇文章应该能让你明白这个固执己见的静态网站框架是如何运作的，以及你如何定制它来满足你的需求。</p>
<h2>所需工具</h2>
<p>在我们开始之前，您需要在您的机器上设置一些东西。</p>
<p>快速检查你的终端中是否有带<code>node --version</code>的Node.js。你应该用Node.js得到npm，但是用<code>npm --version</code>快速检查一下。如果两个命令都返回一个版本，就可以开始了。如果没有，你可以遵循npm网站上的<a href="https://www.npmjs.com/get-npm" target="_blank" rel="noopener noreferrer">指示。</a></p>
<p>现在我们已经解决了这个问题，我们可以在本地安装Gatsby CLI。需要Gatsby CLI来调用命令，这些命令将生成我们的repo，启动我们的开发服务器，甚至构建我们博客的生产代码。要安装它，您可以执行以下操作:</p>
<pre>npm install -g gatsby-cli</pre>
<p>快速验证盖茨比安装了<code>gatsby --version</code>。在安装并检查了我们开始开发所需的所有东西之后，我们可以开始深入研究了。</p>
<h2>正在初始化回购</h2>
<p>要开始这个博客，我们将使用来自Gatsby的简单的<a href="https://github.com/gatsbyjs/gatsby-starter-hello-world" target="_blank" rel="noopener noreferrer"> hello-world启动工具包</a>。这个工具包是一个简约的，一开始不会给你太多。我们这样做是为了更好地理解盖茨比及其内在。如果你想快速建立你的网站，你可以随时选择加入<a href="https://www.gatsbyjs.org/starters/?v=2" target="_blank" rel="noopener noreferrer">盖茨比的其他工具包</a>。</p>
<p>让我们创建我们的工作目录:</p>
<pre>gatsby new my-new-blog https://github.com/gatsbyjs/gatsby-starter-hello-world</pre>
<p>在Gatsby CLI完成所有安装后，我们可以使用<code>cd my-new-blog</code>进入我们博客的目录，并使用<code>gatsby develop</code>启动服务器。这个命令将为我们设置一些东西，并使我们的网站在<code><a href="http://localhost:8000/" rel="nofollow">http://localhost:8000/</a></code>可用。</p>
<p>打开就能看到平常的“Hello world！”。耶！我们的博客与生俱来。但是刚才发生了什么？是的，我们在终端上运行了几个命令，并在我们的新博客上向全世界问好，但这是怎么发生的呢？让我们从查看<code>src/pages/index.js</code>文件开始:</p>
<pre>import React from "react"

export default function Home() {
  return &lt;div&gt;Hello world!&lt;/div&gt;
}</pre>
<p>一个非常简单的React组件，它只是向世界问好。当我们运行<code>gatsby develop</code>时，它会识别<code>src/pages/index.js</code>文件，并将其视为我们博客根页面的逻辑。盖茨比自己发现了这一点，这就是为什么我们在访问索引页面时会看到“Hello world”文本。</p>
<p>如果你试图对这个文件做一些改变，监视我们目录中所有改变的服务器会自动更新网站。多整洁啊！</p>
<p>只有一个文件并使用Gatsby听起来有些矫枉过正(确实如此)。这就是为什么我们会在我们的博客上添加内容，并解释整个过程。</p>
<h2>盖茨比和GraphQL</h2>
<p>GraphQL是一种查询您的API并获取您需要的数据的语言，非常强调一个请求就能完成。能够在一个请求中收集大量数据意味着您不必多次往返于您的服务器。</p>
<p>除此之外，您还需要定义一个模式作为查询的基础。盖茨比很聪明地做到了这一点。为了更好地理解Gatsby和GraphQL是如何工作的，让我们首先向我们的网站添加一些数据。</p>
<p>你可能想添加的第一件事是关于你的博客的一些一般信息——例如，你的网站的标题和描述对任何访问者都是有用的。让我们在<code>gatsby-config.js</code>文件中定义这些数据。我们将在以后的一些其他工作中使用这个文件，但是现在，让我们这样做:</p>
<pre>module.exports = {
  /* Your site config here */
  siteMetadata: {
    title: 'My New Blog',
    description: 'This is my awesome blog I made from scratch!'  
  },
  plugins: [],
}</pre>
<p>现在，让我们在浏览器中向用户显示这些数据。如果我们转到<code>src/pages/index.js</code>，我们可以添加一个简单的GraphQL查询来获取我们刚刚添加的数据:</p>
<pre>import React from "react"
import { graphql } from "gatsby"

export default function Home({ data }) {
  const { title, description } = data.site.siteMetadata

  return (
    &lt;div&gt;
      &lt;h1&gt;{title}&lt;/h1&gt;
      &lt;p&gt;{description}&lt;/p&gt;
    &lt;/div&gt;
  )
}

export const pageQuery = graphql`
  query MetadataQuery {
    site {
      siteMetadata {
        title
        description
      }
    }
  }
`</pre>
<p>在文件的底部，我们将放置GraphQL查询，该查询将获取我们之前添加到<code>gastby-config.js</code>中的标题和描述。GraphQL使这些数据可用，Gatsby进行提取。我们不必显式调用查询。获取将在构建过程中为我们完成。</p>
<p>这种高效的构建过程就是Gatsby被定义为“快得令人作呕”的原因，因为它在数据加载到浏览器之前就完成了所有的页面数据获取。当然，您可以在组件中编写一些额外的获取逻辑，但是这些逻辑不会以相同的方式加载。</p>
<p>Gatsby将在构建过程中(当我们运行<code>gatsby develop</code>时)通过识别在<code>src/pages/index.js</code>中有一些GraphQL逻辑来使这些数据对GraphQL可用。此外，我们添加到<code>gatsby-config.js</code>中的<code>siteMetadata</code>对象将对GraphQL可用。</p>
<p>如果您愿意，可以在<code><a href="http://localhost:8000/___graphiql" rel="nofollow">http://localhost:8000/___graphiql</a></code>查看GraphiQL工具中还有什么可用的。当您运行服务器时，您可以在本地使用它。</p>
<p>我们成功地将一些数据放入我们的单页博客中，并且我们设法弄清楚盖茨比是如何处理数据的。但这仍然不在有人会读的博客附近。我们需要让它变得友好一点。再加一张可爱狗狗的图片，为《盖茨比》中添加和读取文件做铺垫。</p>
<h2>管理图片</h2>
<p>为了让我们的博客更吸引人，我们将添加一张图片。我会把我在网上找到的一张可爱狗狗的图片添加到一个新的目录:<code>src/images</code>。</p>
<p>最终的路径应该是这样的:<code>src/images/cute-dog.jpg</code>。为了以Gatsby的方式显示这个图像，我们需要安装一个Gatsby插件。插件是有用的库，在构建盖茨比网站时让我们的生活变得更容易，有很多有用的插件你可以在这里浏览<a href="https://www.gatsbyjs.org/plugins/" target="_blank" rel="noopener noreferrer">。主要思想是不要为通常的任务和功能编写解决方案，比如</a><a href="https://www.gatsbyjs.org/packages/gatsby-plugin-seo/" target="_blank" rel="noopener noreferrer"> SEO </a>、<a href="https://www.gatsbyjs.org/packages/gatsby-plugin-feed" target="_blank" rel="noopener noreferrer"> RSS </a>、离线支持，以及——你猜对了——<a href="https://www.gatsbyjs.org/packages/gatsby-image" target="_blank" rel="noopener noreferrer">图片</a>。</p>
<p>我们将要使用的这个叫做<a href="https://www.gatsbyjs.org/packages/gatsby-source-filesystem/" target="_blank" rel="noopener noreferrer"> gatsby-source-filesystem </a>。从它的名字就可以看出它与文件有某种联系。你是正确的！这个插件将帮助我们使用GraphQL查询可爱的小狗图片。</p>
<p>要安装它，请运行以下命令:</p>
<pre>npm install --save gatsby-source-filesystem</pre>
<p>然后，如果你记得<code>gatsby-config.js</code>，我们会用它告诉盖茨比我们有它的插件，就像这样:</p>
<pre>module.exports = {
  /* Your site config here */
  siteMetadata: {
    title: "Myasd New Blog",
    description: "This is my awesome blog I made from scratch!",
  },
  plugins: [
    {
      resolve: `gatsby-source-filesystem`,
      options: {
        name: `images`,
        path: `${__dirname}/src/images/`,
      },
    },
  ],
}</pre>
<p>除了我们在上一步中添加的数据，我们现在添加了关于<code>gatsby-source-filesystem</code>插件的细节。在选项中，我们指定了源的名称——“images”——并指定了图像所在的路径。</p>
<p>定义名称是一个重要的步骤，您可能想知道为什么我们需要设置它。Gatsby可以从不同的来源读取数据——不仅仅是我们的文件系统。来源的另一个例子是<a href="https://wordpress.com/" target="_blank" rel="noopener noreferrer"> WordPress </a>或<a href="https://www.contentful.com/" target="_blank" rel="noopener noreferrer">contentiful</a>。因此，我们的文件系统只是我们可以存储图像或博客文章的一种可能性，为“图像”设置一个<code>name</code>可以帮助我们区分不同的来源，并在将来以另一种方式处理它们。</p>
<p>无论如何，在我们添加插件后，如果我们在终端中查看我们正在运行的服务器，应该会有以下消息:</p>
<pre>warn develop process needs to be restarted to apply the changes to gatsby-config.js</pre>
<p>我们需要重启服务器，让Gatsby获得新的插件。让我们重新启动服务器。众所周知，盖茨比<a href="https://github.com/gatsbyjs/gatsby/issues/18048" target="_blank" rel="noopener noreferrer">的</a>和<code>npm install</code>有问题，所以如果你在添加<code>gatsby-source-filesystem</code>插件时遇到错误，请确保添加<code>rm -rf node_modules &amp;&amp; npm install</code>或<code>npm install react react-dom gatsby</code>。</p>
<p>服务器启动后，我们可以尝试获取我们的<code>src/pages/index.js</code>文件中的图像:</p>
<pre>import React from "react"
import { graphql } from "gatsby"

export default function Home({ data }) {
  const { title, description } = data.site.siteMetadata

  return (
    &lt;div&gt;
      &lt;h1&gt;{title}&lt;/h1&gt;
      &lt;p&gt;{description}&lt;/p&gt;

      &lt;img alt="Cute dog" src={data.image.publicURL} /&gt;
    &lt;/div&gt;
  )
}

export const pageQuery = graphql`
  query MetadataQuery {
    site {
      siteMetadata {
        title
        description
      }
    }

    image: file(base: { eq: "cute-dog.jpg" }) {
      publicURL
    }
  }
`</pre>
<p>我们扩展了GraphQL查询来搜索名为“cute-dog.jpg”的文件。然后，我们告诉GraphQL将该文件命名为image，这样我们就可以在代码的后面有意义地引用它。最后，在我们的代码中，我们放置了一个JSX图像标签，并在那里引用了该图像的公共URL。</p>
<p>瞧，我们得到了显示在我们页面上的图像:</p>
<p><img data-attachment-id="23475" data-permalink="https://blog.logrocket.com/creating-a-gatsby-blog-from-scratch/homepage-of-blog/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/08/homepage-of-blog.png" data-orig-size="730,653" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="homepage-of-blog" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/08/homepage-of-blog-300x268.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/08/homepage-of-blog.png" decoding="async" class="aligncenter size-full wp-image-23475 jetpack-lazy-image" src="../Images/7a34f2e7676d47615ea3e4d7900e4a1d.png" alt="The homepage of our Gatsby blog with a picture of a dog." data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2020/08/homepage-of-blog.png 730w, https://blog.logrocket.com/wp-content/uploads/2020/08/homepage-of-blog-300x268.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2020/08/homepage-of-blog.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/08/homepage-of-blog.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="23475" data-permalink="https://blog.logrocket.com/creating-a-gatsby-blog-from-scratch/homepage-of-blog/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/08/homepage-of-blog.png" data-orig-size="730,653" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="homepage-of-blog" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/08/homepage-of-blog-300x268.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/08/homepage-of-blog.png" decoding="async" loading="lazy" class="aligncenter size-full wp-image-23475" src="../Images/7a34f2e7676d47615ea3e4d7900e4a1d.png" alt="The homepage of our Gatsby blog with a picture of a dog." srcset="https://blog.logrocket.com/wp-content/uploads/2020/08/homepage-of-blog.png 730w, https://blog.logrocket.com/wp-content/uploads/2020/08/homepage-of-blog-300x268.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/08/homepage-of-blog.png"/></noscript>
<p>我们建立的一切都很好，但我们的博客上仍然没有任何博客帖子，所以让我们在下一章添加它们。</p>
<h2>处理降价文件</h2>
<p>自从杰基尔T2时代以来，使用Markdown这种轻量级标记语言编写内容变得流行起来。我们将为我们的博客做同样的事情。让我们在<code>src/blog/my-first-post.md</code>中添加我们的第一篇博文:</p>
<pre>---
title: Awesome Blog Post Title
author: Nikola
date: 2020-07-15
---

## Introduction to my blog post

Great content of my first blog</pre>
<p>顶部是代表帖子一般信息的封面内容。接下来是内容。让我们不要一开始就在这里撒野，使用简单的内容，我们可以在以后的基础上构建。</p>
<p>因为我们添加了<code>src/blog</code>目录，并且我们计划在那里存储所有的Markdown文件，所以让我们在我们的<code>gatsby-config.js</code>中定义它:</p>
<pre>  plugins: [
    {
      resolve: `gatsby-source-filesystem`,
      options: {
        name: `images`,
        path: `${__dirname}/src/images/`,
      },
    },
    {
      resolve: `gatsby-source-filesystem`,
      options: {
        name: `blog`,
        path: `${__dirname}/src/blog/`,
      },
    },
  ],</pre>
<p>现在我们有两个盖茨比应该知道的地方:<code>src/images</code>和<code>src/blog</code>。我们可以继续使用与获取图像类似的查询，但是让我们<a href="https://www.gatsbyjs.org/packages/gatsby-transformer-remark/">试试Gatsby提供的</a>插件<code>gatsby-transformer-remark</code>。这个插件允许你使用<a href="https://remark.js.org/" target="_blank" rel="noopener noreferrer"> Remark </a>，一个降价处理器，并减少花费在解析所有降价文件上的时间。</p>
<p>您可以使用以下方式安装此插件:</p>
<pre>npm install --save gatsby-transformer-remark</pre>
<p>放在<code>gatsby-config.js</code>里面:</p>
<pre>  plugins: [
    {
      resolve: `gatsby-source-filesystem`,
      options: {
        name: `images`,
        path: `${__dirname}/src/images/`,
      },
    },
    {
      resolve: `gatsby-source-filesystem`,
      options: {
        name: `blog`,
        path: `${__dirname}/src/blog/`,
      },
    },
    `gatsby-transformer-remark`,
  ],</pre>
<p>现在我们重启<code>gatsby develop</code>服务器。完美！为了展示我们的博客文章，我们将在<code>src/pages/blog.js</code>中为它创建一个单独的页面:</p>
<pre>import React from "react"
import { graphql } from "gatsby"

export default function Blog({ data }) {
  const { posts } = data.blog

  return (
    &lt;div&gt;
      &lt;h1&gt;My blog posts&lt;/h1&gt;

      {posts.map(post =&gt; (
        &lt;article key={post.id}&gt;
          &lt;h2&gt;{post.frontmatter.title}&lt;/h2&gt;
          &lt;small&gt;{post.frontmatter.author}, {post.frontmatter.date}&lt;/small&gt;
          &lt;p&gt;{post.excerpt}&lt;/p&gt;
        &lt;/article&gt;
      ))}
    &lt;/div&gt;
  )
}

export const pageQuery = graphql`
  query MyQuery {
    blog: allMarkdownRemark {
      posts: nodes {
        frontmatter {
          date(fromNow: true)
          title
          author
        }
        excerpt
        id
      }
    }
  }
`</pre>
<p>这里，我们使用<code>allMarkdownRemark</code>查询所有的降价文件，它可以从我们安装的插件<code>gatsby-transformer-remark</code>中获得。</p>
<p>这使得我们可以直接获取包括<code>date</code>、<code>title</code>和<code>author</code>在内的前端物质。我们还可以向<code>date(fromNow: true)</code>传递一个参数，它显示相对时间，例如，“5天前”如果没有<code>gatsby-transformer-remark</code>，我们将不得不以某种方式自己解析它。</p>
<p>然后，在博客组件中，我们向用户列出所有的博客文章及其信息。请注意，我们没有任何博客文章的链接，但我们稍后会添加。</p>
<p>幸运的是，盖茨比将接受所有这些变化，并在<code>/blog</code>时打开新的一页。如果我们转到<code>/blog</code>，我们应该会看到这样的内容:</p>
<p><img data-attachment-id="23476" data-permalink="https://blog.logrocket.com/creating-a-gatsby-blog-from-scratch/introduction-to-blog-post/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/08/introduction-to-blog-post.png" data-orig-size="396,175" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="introduction-to-blog-post" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/08/introduction-to-blog-post-300x133.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/08/introduction-to-blog-post.png" decoding="async" class="aligncenter wp-image-23476 jetpack-lazy-image" src="../Images/fe89264b0c9905bedf4afa99916f8996.png" alt="introduction-to-our-blog-post.png" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2020/08/introduction-to-blog-post.png 396w, https://blog.logrocket.com/wp-content/uploads/2020/08/introduction-to-blog-post-300x133.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2020/08/introduction-to-blog-post.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/08/introduction-to-blog-post.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="23476" data-permalink="https://blog.logrocket.com/creating-a-gatsby-blog-from-scratch/introduction-to-blog-post/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/08/introduction-to-blog-post.png" data-orig-size="396,175" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="introduction-to-blog-post" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/08/introduction-to-blog-post-300x133.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/08/introduction-to-blog-post.png" decoding="async" loading="lazy" class="aligncenter wp-image-23476" src="../Images/fe89264b0c9905bedf4afa99916f8996.png" alt="introduction-to-our-blog-post.png" srcset="https://blog.logrocket.com/wp-content/uploads/2020/08/introduction-to-blog-post.png 396w, https://blog.logrocket.com/wp-content/uploads/2020/08/introduction-to-blog-post-300x133.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/08/introduction-to-blog-post.png"/></noscript>
<p>您可以在<code>src/blog</code>中添加另一个Markdown文件，它将自动被Gatsby获取。</p>
<p><img data-attachment-id="23467" data-permalink="https://blog.logrocket.com/creating-a-gatsby-blog-from-scratch/my-blog-posts/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/08/my-blog-posts.png" data-orig-size="393,285" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="my-blog-posts" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/08/my-blog-posts-300x218.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/08/my-blog-posts.png" decoding="async" class="aligncenter wp-image-23467 jetpack-lazy-image" src="../Images/79c2f4a49d36a56596950d7badc3960a.png" alt="A screenshot of the HTML of your Gatsby blog." data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2020/08/my-blog-posts.png 393w, https://blog.logrocket.com/wp-content/uploads/2020/08/my-blog-posts-300x218.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2020/08/my-blog-posts.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/08/my-blog-posts.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="23467" data-permalink="https://blog.logrocket.com/creating-a-gatsby-blog-from-scratch/my-blog-posts/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/08/my-blog-posts.png" data-orig-size="393,285" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="my-blog-posts" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/08/my-blog-posts-300x218.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/08/my-blog-posts.png" decoding="async" loading="lazy" class="aligncenter wp-image-23467" src="../Images/79c2f4a49d36a56596950d7badc3960a.png" alt="A screenshot of the HTML of your Gatsby blog." srcset="https://blog.logrocket.com/wp-content/uploads/2020/08/my-blog-posts.png 393w, https://blog.logrocket.com/wp-content/uploads/2020/08/my-blog-posts-300x218.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/08/my-blog-posts.png"/></noscript>
<p>相当酷！但是我如何访问一篇独立的博客文章呢？这就是事情变得棘手的地方。请继续阅读，了解如何做到这一点。</p>
<h2>动态创建页面</h2>
<p>要创建所有博客文章的链接，我们需要告诉Gatsby为我们创建它们。这一部分是你应该保持大部分注意力的地方，因为我们现在开始玩Gatsby的内部。到目前为止，我们已经安装了插件，添加了数据，并编写了一些Markdown和JSX，但现在是时候开始了。</p>
<h3>摆弄节点</h3>
<p>首先，让我们了解一下《盖茨比》中的“节点”一词。正如<a href="https://www.gatsbyjs.org/docs/node-interface/" target="_blank" rel="noopener noreferrer"> Gatsby docs所说</a>，节点是Gatsby数据系统的中心。在Gatsby中，我们添加的所有数据都表示为节点对象。</p>
<p>如果您回过头来查看我们获取所有降价帖子的查询，您会发现我们查询的是<code>nodes</code>。<code>gatsby-source-filesystem</code>“扫描”我们告诉它的目录，并为这些目录中的每个文件创建节点。然后<code>gatsby-markdown-remark</code>来了，解析节点内的数据，并向那些节点对象添加额外的字段。</p>
<p>此外，Gatsby还根据这些节点的内容总结并提出了这些节点的GraphQL模式。哇，可能一次要接受很多东西。我敢打赌，如果我们看到一个例子，它会更容易。</p>
<p>让我们从为我们的每篇博客文章创建一个slug开始。例如，由于我们添加了<code>src/blog/my-first-post.md</code>，我们希望在访问<code>/my-first-post</code>时看到那篇博文。为此，我们将利用<code>gatsby-source-filesystem</code>自带的<code>createFilePath</code>功能来完成这项工作。</p>
<p>刚刚创建了一个slug，我们还将创建一个我们在上一节中描述的节点。制作slug最好的地方是盖茨比公开的<code><a href="https://www.gatsbyjs.org/docs/node-apis/#onCreateNode" target="_blank" rel="noopener noreferrer">onCreateNode</a></code> API。像我们这样的插件和用户可以在创建或更新节点时使用<code>onCreateNode</code>来定制节点或做其他事情。</p>
<p>像这样的逻辑放在<code>gatsby-node.js</code>中，我们将创建一个新文件:</p>
<pre>const { createFilePath } = require(`gatsby-source-filesystem`)

exports.onCreateNode = ({ node, getNode, actions }) =&gt; {
  const { createNodeField } = actions

  if (node.internal.type === `MarkdownRemark`) {
    const slug = createFilePath({ node, getNode, basePath: `pages` })

    createNodeField({
      node,
      name: `slug`,
      value: slug,
    })
  }
}</pre>
<p>如果您继续并重新启动服务器，快速打开本地GraphiQL工具(<code><a href="http://localhost:8000/___graphiql" rel="nofollow">http://localhost:8000/___graphiql</a></code>)，并使用以下查询来查询slugs:</p>
<pre>{
  allMarkdownRemark {
    edges {
      node {
        fields {
          slug
        }
      }
    }
  }
}</pre>
<p>您应该会看到我们之前添加的两篇Markdown博客文章:</p>
<p><img data-attachment-id="23466" data-permalink="https://blog.logrocket.com/creating-a-gatsby-blog-from-scratch/code-explorer-graphql/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/08/code-explorer-graphql.png" data-orig-size="1139,449" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="code-explorer-graphql" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/08/code-explorer-graphql-300x118.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/08/code-explorer-graphql-1024x404.png" decoding="async" class="aligncenter wp-image-23466 jetpack-lazy-image" src="../Images/850fbe487ed26d335081a4c674d1833e.png" alt="A code explorer with GraphQL." data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2020/08/code-explorer-graphql.png 1139w, https://blog.logrocket.com/wp-content/uploads/2020/08/code-explorer-graphql-300x118.png 300w, https://blog.logrocket.com/wp-content/uploads/2020/08/code-explorer-graphql-1024x404.png 1024w, https://blog.logrocket.com/wp-content/uploads/2020/08/code-explorer-graphql-768x303.png 768w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2020/08/code-explorer-graphql.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/08/code-explorer-graphql.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="23466" data-permalink="https://blog.logrocket.com/creating-a-gatsby-blog-from-scratch/code-explorer-graphql/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/08/code-explorer-graphql.png" data-orig-size="1139,449" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="code-explorer-graphql" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/08/code-explorer-graphql-300x118.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/08/code-explorer-graphql-1024x404.png" decoding="async" loading="lazy" class="aligncenter wp-image-23466" src="../Images/850fbe487ed26d335081a4c674d1833e.png" alt="A code explorer with GraphQL." srcset="https://blog.logrocket.com/wp-content/uploads/2020/08/code-explorer-graphql.png 1139w, https://blog.logrocket.com/wp-content/uploads/2020/08/code-explorer-graphql-300x118.png 300w, https://blog.logrocket.com/wp-content/uploads/2020/08/code-explorer-graphql-1024x404.png 1024w, https://blog.logrocket.com/wp-content/uploads/2020/08/code-explorer-graphql-768x303.png 768w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/08/code-explorer-graphql.png"/></noscript>
<p>相当整洁！我们告诉Gatsby用字段<code>slug</code>展开每个Markdown节点，我们可以用它将用户重定向到我们的博客文章。</p>
<p>但是等等，如果你尝试访问<code>/another-blog-post</code>，会得到404。这很好，因为我们没有创建实际的页面，我们只是生成了slugs。按照下一节学习如何做到这一点。</p>
<h3>以编程方式生成页面</h3>
<p>幸运的是，Gatsby公开了API，这让我们可以做到这一点。但是，在我们继续向<code>gatsby-node.js</code>添加更多逻辑之前，我们需要做一些别的事情。由于Gatsby页面使用React，因此每个页面都需要一个React组件来呈现数据。为此，我们将为我们的博客文章创建一个组件，并将其放入<code>src/templates/blog-post.js</code>:</p>
<pre>import React from "react"

export default function BlogPost() {
  return &lt;div&gt;Hello blog post&lt;/div&gt;
}</pre>
<p>如您所见，它是一个简单的组件，不利用任何数据。我们以后会改变这一点。我们必须有某种React组件来告诉Gatsby呈现我们的博客帖子。</p>
<p>至此，让我们给<code>gatsby-node.js</code>添加一些逻辑来创建实际的博客文章页面:</p>
<pre>const path = require(`path`)
const { createFilePath } = require(`gatsby-source-filesystem`)

exports.onCreateNode = ({ node, getNode, actions }) =&gt; {
  const { createNodeField } = actions

  if (node.internal.type === `MarkdownRemark`) {
    const slug = createFilePath({ node, getNode, basePath: `pages` })

    createNodeField({
      node,
      name: `slug`,
      value: slug,
    })
  }
}

exports.createPages = async ({ graphql, actions }) =&gt; {
  const { createPage } = actions
  const result = await graphql(`
    query {
      allMarkdownRemark {
        edges {
          node {
            fields {
              slug
            }
          }
        }
      }
    }
  `)

  result.data.allMarkdownRemark.edges.forEach(({ node }) =&gt; {
    createPage({
      path: node.fields.slug,
      component: path.resolve(`./src/templates/blog-post.js`),
      context: {
        // Data passed to context is available
        // in page queries as GraphQL variables.
        slug: node.fields.slug,
      },
    })
  })
}</pre>
<p>我们在页面创建逻辑中添加了看似很多的代码。简而言之，事情是这样的:</p>
<ul>
<li>我们查询所有的降价页面并得到它们的slugs</li>
<li>然后，我们遍历所有这些并调用<code>createPage</code></li>
<li>在<code>createPage</code>中，我们指定了页面的路径，我们刚刚添加的组件<code>src/templates/blog-post.js</code>，并且我们传入了上下文，稍后我们将对此进行解释</li>
</ul>
<p>如果您继续并重启您的服务器并尝试访问<code><a href="http://localhost:8000/my-first-post/" rel="nofollow">http://localhost:8000/my-first-post/</a></code>，您应该会看到我们之前在组件中添加的简单的“Hello blog post”文本。相反，我们应该看到我们放在降价文件中的内容。</p>
<p>让我们把<code>src/templates/blog-post.js</code>改成这样:</p>
<pre>import React from "react"
import { graphql } from "gatsby"

export default function BlogPost({ data }) {
  const post = data.markdownRemark

  return (
    &lt;div&gt;
      &lt;h1&gt;{post.frontmatter.title}&lt;/h1&gt;
      &lt;small&gt;{post.frontmatter.date}&lt;/small&gt;
      &lt;div dangerouslySetInnerHTML={{ __html: post.html }} /&gt;
    &lt;/div&gt;
  )
}
export const query = graphql`
  query BlogQuery($slug: String!) {
    markdownRemark(fields: { slug: { eq: $slug } }) {
      html
      frontmatter {
        title
        date
      }
    }
  }
`
</pre>
<p>现在，我们使用Markdown文件中的数据，而不是只显示“Hello blog post”需要注意的一点是，我们使用了在<code>gatsby-node.js</code>中创建页面时指定的<code>$slug</code>变量。</p>
<p><code>slug</code>也可以作为<code>BlogPost</code>组件内部的道具。使用我们在<code>createPage</code>中定义的<code>slug</code>，我们然后查询匹配节点的Markdown节点。然后，在组件中，我们使用在查询中指定的字段来正确显示博客文章。如果你现在打开<code><a href="http://localhost:8000/my-first-post/" rel="nofollow">http://localhost:8000/my-first-post/</a></code>，你应该会看到你在Markdown文件中定义的博文。</p>
<p>这是相当激烈的，试图创建slugs和页面，并显示文件内的数据。恭喜你走到这一步！作为蛋糕上的樱桃，让我们通过从我们的博客页面链接到那些博客帖子来把它绑起来。</p>
<h2>收尾工作</h2>
<p>如你所知，我们创建了<code>/blog</code>页面，但是我们没有从主页链接到它。让我们快速添加到<code>src/pages/index.js</code>中:</p>
<pre>&lt;Link to="/blog"&gt;Read my blog&lt;/Link&gt;</pre>
<p>然后，让我们从博客页面链接到每篇博文:</p>
<pre>import React from "react"
import { graphql, Link } from "gatsby"

export default function Blog({ data }) {
  const { posts } = data.blog

  return (
    &lt;div&gt;
      &lt;h1&gt;My blog posts&lt;/h1&gt;

      {posts.map(post =&gt; (
        &lt;article key={post.id}&gt;
          &lt;Link to={post.fields.slug}&gt;
            &lt;h2&gt;{post.frontmatter.title}&lt;/h2&gt;
          &lt;/Link&gt;
          &lt;small&gt;
            {post.frontmatter.author}, {post.frontmatter.date}
          &lt;/small&gt;
          &lt;p&gt;{post.excerpt}&lt;/p&gt;
        &lt;/article&gt;
      ))}
    &lt;/div&gt;
  )
}

export const pageQuery = graphql`
  query MyQuery {
    blog: allMarkdownRemark {
      posts: nodes {
        fields {
          slug
        }
        frontmatter {
          date(fromNow: true)
          title
          author
        }
        excerpt
        id
      }
    }
  }
`</pre>
<p>我们从Gatsby导入了<code>Link</code>组件，它将为我们处理路由。然后，我们在GraphQL查询中查询这个slug。我们稍后使用这个slug来形成每个博客文章的链接。就是这样！你刚刚用盖茨比从头开始建立了一个简单的博客。</p>
<h3>可以尝试的想法</h3>
<p>我们建立的博客帖子看起来还远未完成，但从现在开始应该会很容易。你已经具备了扩展博客的所有基础。以下是一些你可以尝试的想法:</p>
<ul>
<li>将博客文章路径切换到从<code>/blog/*</code>(提示:当我们调用<code>createPage</code>时编辑<code>path</code>变量)</li>
<li>显示主页上的所有帖子</li>
<li>给你的博客添加一些风格</li>
<li>部署它，让世界知道你要说什么！</li>
</ul>
<h2>结论</h2>
<p>为成功而喝彩！如果您已经到了这一步，那么您应该已经学会了如何构建一个简单的博客，并且对Gatbsy的内部有了一个高层次的理解。现在，节点的概念和Gatsby处理数据的方式对您来说应该是轻而易举的事情。还有，我希望盖茨比的魔法对你来说有点去神秘化了。</p>
<p>总而言之，Gatsby是一个快速建立静态站点的好工具。有许多其他的工具和方法来实现它，但是理解本质和幕后发生的事情总是朝着正确的方向迈出的一步。我希望这些知识能在未来伴随你，帮助你建立伟大的网站。</p>
<p>如果你喜欢这篇文章，考虑与你的朋友和同事分享。</p>
<p>下次见，干杯！</p>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
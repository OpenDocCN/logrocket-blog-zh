<html>
<head>
<title>4 3D rendering engines every game developer should know - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>每个游戏开发者都应该知道的4个3D渲染引擎</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/top-4-3d-rendering-engines-available-in-js/#0001-01-01">https://blog.logrocket.com/top-4-3d-rendering-engines-available-in-js/#0001-01-01</a></blockquote><div><article class="article-post">
<p>开发游戏的一半乐趣在于构建复杂的动画，为游戏注入活力，吸引用户。你可以花无数的时间在<a href="https://blog.logrocket.com/top-6-javascript-and-html5-game-engines/" target="_blank" rel="noopener noreferrer">游戏引擎</a>中挖掘动作，物理引擎挖掘动态，音频引擎挖掘声音——列表还在继续，选项和可能的组合只受你的想象力、时间和资源的限制。</p>
<p>但是让我们说，你宁愿把所有的努力都花在真正让用户迷上你的游戏上——也就是游戏性。渲染引擎可以帮助您在很短的时间内创建令人惊叹的精致图形，让您专注于让您的游戏真正独一无二、引人注目的因素。</p>
<p>在本指南中，我们将重点介绍JavaScript社区提供的四个最好、最受欢迎的3D渲染引擎:</p>
<ol>
<li><a href="#overviewofcannonjs"> Cannon.js </a></li>
<li><a href="#overviewofphoriajs"> Phoria.js </a></li>
<li><a href="#overviewofd3"> D3 </a></li>
<li><a href="#overviewofxeogljs"> Xeogl.js </a></li>
</ol>
<p>我们将强调一些值得注意的特性，并探讨与每个引擎相关的优缺点。</p>
<h2 id="overviewofcannonjs">1.Cannon.js</h2>
<p>Cannon.js是JavaScript可用的最好的物理和渲染引擎之一。受Three.js和Ammo.js的启发，它以特别轻便而闻名。最棒的是，它是免费和开源的。</p>
<h3 id="pros">赞成的意见</h3>
<ul>
<li>轻型建筑尺寸</li>
<li>易于上手</li>
<li>开源，可以在任何地方免费使用</li>
<li>使用迭代高斯-塞德尔解算器解决约束问题</li>
<li>内置碰撞检测</li>
<li>开箱即用的刚体动力学</li>
</ul>
<h3 id="cons">骗局</h3>
<ul>
<li>难以掌握</li>
<li>单轴宽相位分离</li>
<li>以非性能的、面向对象的方式编写</li>
</ul>
<h3 id="gettingstartedwithcannonjs">Cannon.js正在运行</h3>
<p>要开始使用Cannon.js，创建一个简单的获取场景并将结果打印到控制台。</p>
<p>使用以下任一方法安装Cannon.js。</p>
<pre>&lt;script src="cannon.min.js"&gt;&lt;/script&gt;

// OR

npm install --save cannon 
</pre>
<p>现在让我们创造我们的世界。</p>
<pre>const world = new CANNON.World();
world.gravity.set(0, 0, -9.82); // m/s²
</pre>
<p>创建一个球体并将其添加到世界中。</p>
<pre>const radius = 1; // m
const sphereBody = new CANNON.Body({
   mass: 5, // kg
   position: new CANNON.Vec3(0, 0, 10), // m
   shape: new CANNON.Sphere(radius)
});
world.addBody(sphereBody);
</pre>
<p>接下来，创建地板或平面，并将其添加到世界中。</p>
<pre>// Create a plane
const groundBody = new CANNON.Body({
    mass: 0 // mass == 0 makes the body static
});
const groundShape = new CANNON.Plane();
groundBody.addShape(groundShape);
world.addBody(groundBody);

const fixedTimeStep = 1.0 / 60.0; // seconds
const maxSubSteps = 3;
</pre>
<p>创建一个初始化函数来设置一切，并将球体<code>Z</code>的位置打印到控制台。</p>
<pre>var lastTime;
(function simloop(time){
  requestAnimationFrame(simloop);
  if(lastTime !== undefined){
     const dt = (time - lastTime) / 1000;
     world.step(fixedTimeStep, dt, maxSubSteps);
  }
  console.log("Sphere z position: " + sphereBody.position.z);
  lastTime = time;
})();
</pre>
<p>这个函数创建动画本身。</p>
<pre>function animate() {
      init();
      requestAnimationFrame( animate );

      mesh.rotation.x += 0.01;
      mesh.rotation.y += 0.02;

      renderer.render( scene, camera );
}
</pre>
<p>您可以运行代码并打开控制台来查看<code>Z</code>位置的值。点击<a href="http://schteppe.github.io/cannon.js/" target="_blank" rel="noopener noreferrer">此处</a>查看更多示例，帮助您入门。</p>
<h2 id="overviewofphoriajs">2.Phoria.js</h2>
<p>Phoria是一个JavaScript库和渲染引擎，用于在画布上创建简单的3D 2D渲染器。由于Phoria不使用WebGL，所以它可以在任何可以渲染HTML Canvas的设备上工作。</p>
<h3 id="pros-1">赞成的意见</h3>
<ul>
<li>方便用户；易于上手并创建令人惊叹的图形</li>
<li>温和的学习曲线，因为Phoria不支持WebGL</li>
<li>优秀的向量和矩阵数学库</li>
</ul>
<h3 id="cons-1">骗局</h3>
<ul>
<li>缺少WebGL会使处理复杂的图形渲染变得困难</li>
<li>学习HTML画布需要稳定的练习</li>
<li>更适合小型动画和图形</li>
<li>没有文件。</li>
</ul>
<h3 id="gettingstartedwithphoriajs">Phoria.js在行动</h3>
<p>有很多例子和评论良好的示例代码可以帮助您开始使用Phoria.js。</p>
<p>首先，安装库。</p>
<pre>&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;script src="scripts/gl-matrix.js"&gt;&lt;/script&gt;
    &lt;script src="scripts/phoria-util.js"&gt;&lt;/script&gt;
    &lt;script src="scripts/phoria-entity.js"&gt;&lt;/script&gt;
    &lt;script src="scripts/phoria-scene.js"&gt;&lt;/script&gt;
    &lt;script src="scripts/phoria-renderer.js"&gt;&lt;/script&gt;
    &lt;script src="scripts/dat.gui.min.js"&gt;&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
  // Create a Canvas element
  &lt;canvas id="canvas" width="768" height="512" style="background-color: #eee"&gt;&lt;/canvas&gt;
  &lt;script&gt;
      // Render animation on page load
      window.addEventListener('load', loadAnimation, false);
  &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</pre>
<p>接下来，创建<code>loadAnimation</code>函数来加载动画和下面的代码。</p>
<pre>function loadAnimation(){
  const canvas = document.getElementById('canvas');

  // Add all script below here
  // ........
}
</pre>
<p>建立你的场景和摄像机，并设置好。</p>
<pre> const scene = new Phoria.Scene();
 scene.camera.position = {x:0.0, y:5.0, z:-15.0};
 scene.perspective.aspect = canvas.width / canvas.height;
 scene.viewport.width = canvas.width;
 scene.viewport.height = canvas.height;
</pre>
<p>创建一个渲染器，渲染上面创建的<code>canvas</code>。</p>
<pre>const renderer = new Phoria.CanvasRenderer(canvas);
</pre>
<p>接下来，构建一些工具和栅格，然后将它们添加到上面创建的场景中。</p>
<pre>  const plane = Phoria.Util.generateTesselatedPlane(8,8,0,20);
   scene.graph.push(Phoria.Entity.create({
      points: plane.points,
      edges: plane.edges,
      polygons: plane.polygons,
      style: {
         drawmode: "wireframe",
         shademode: "plain",
         linewidth: 0.5,
         objectsortmode: "back"
      }
   }));
   const c = Phoria.Util.generateUnitCube();
   const cube = Phoria.Entity.create({
      points: c.points,
      edges: c.edges,
      polygons: c.polygons
   });
   scene.graph.push(cube);
   scene.graph.push(new Phoria.DistantLight());
</pre>
<p>让我们结束动画，并开始它。</p>
<pre>   const pause = false;
   const fnAnimate = function() {
      if (!pause)
      {
         // rotate local matrix of the cube
         cube.rotateY(0.5*Phoria.RADIANS);

         // execute the model view 3D pipeline and render the scene
         scene.modelView();
         renderer.render(scene);
      }
      requestAnimFrame(fnAnimate);
   };

   // key binding
   document.addEventListener('keydown', function(e) {
      switch (e.keyCode)
      {
         case 27: // ESC
            pause = !pause;
            break;
      }
   }, false);

   // start animation
   requestAnimFrame(fnAnimate);
</pre>
<p id="preview-1">最终结果应该是这样的:</p>
<p><img data-attachment-id="26190" data-permalink="https://blog.logrocket.com/top-4-3d-rendering-engines-available-in-js/phoriajs-sample/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/09/phoriajs-sample.gif" data-orig-size="540,446" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Phoria.js animation example" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/09/phoriajs-sample-300x248.gif" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/09/phoriajs-sample.gif" decoding="async" class="aligncenter size-full wp-image-26190 jetpack-lazy-image" src="../Images/2c6a38fd24d74b487b0f71912f1d192f.png" alt="A Spinning Dark-Grey Cube on a Light-Grey, Gridded Plane" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2020/09/phoriajs-sample.gif?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/09/phoriajs-sample.gif"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="26190" data-permalink="https://blog.logrocket.com/top-4-3d-rendering-engines-available-in-js/phoriajs-sample/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/09/phoriajs-sample.gif" data-orig-size="540,446" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Phoria.js animation example" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/09/phoriajs-sample-300x248.gif" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/09/phoriajs-sample.gif" decoding="async" loading="lazy" class="aligncenter size-full wp-image-26190" src="../Images/2c6a38fd24d74b487b0f71912f1d192f.png" alt="A Spinning Dark-Grey Cube on a Light-Grey, Gridded Plane" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/09/phoriajs-sample.gif"/></noscript>
<h2 id="overviewofd3">3.D3</h2>
<p>D3是一个JavaScript库，用于操纵和呈现数据以及数据可视化。使用D3，您可以通过使用HTML添加令人惊叹的强大转换来赋予数据生命。</p>
<p>这个库非常容易上手，即使在处理更复杂的数据可视化增强时也是如此，这在很大程度上要归功于它蓬勃发展的社区。它也是高度可定制的，使您能够调整现有的可视化和扩展功能。</p>
<h3 id="pros-2">赞成的意见</h3>
<ul>
<li>大型社区和全面的文档</li>
<li>各种各样的可视化集合</li>
<li>可定制的动画、交互性和数据驱动的绘图</li>
<li>快速且对系统资源要求低；因为它是用JavaScript构建的，可视化可以很容易地跨浏览器托管在web上。</li>
</ul>
<h3 id="cons-2">骗局</h3>
<ul>
<li>几乎没有教育视频</li>
<li>可以使用更多创新的可视化图表</li>
<li>需要网络开发经验</li>
<li>处理大型数据集时可能会很慢</li>
<li>不太适合制作地图</li>
</ul>
<h3 id="gettingstartedwithd3">D3在起作用</h3>
<p>D3入门非常简单。只需将脚本标签添加到HTML文档中。</p>
<pre>&lt;script src="https://d3js.org/d3.v6.min.js"&gt;&lt;/script&gt;
</pre>
<p>例如，您可以像这样简单地在游戏中添加过渡:</p>
<pre>d3.selectAll("transPage").transition()
    .duration(750)
    .delay(function(d, i) { return i * 10; })
    .attr("r", function(d) { return Math.sqrt(d * scale); });
</pre>
<p>这里，我们简单地选择了所有带有<code>transPage</code>的标签，并为它们添加了过渡。</p>
<h2 id="overviewofxeogljs">4.Xeogl.js</h2>
<p>Xeogl.js是一个开源的JavaScript库，用于在WebGL上创建3D可视化。它的设计重点是创建交互式3D动画和图形。</p>
<h3 id="pros-3">赞成的意见</h3>
<ul>
<li>使用WebGL进行渲染</li>
<li>内置的、基于组件的场景图。</li>
<li>用ECMAScript 6编写</li>
<li>没有额外的依赖或库，使其规模更小</li>
<li>免费和开源</li>
<li>旨在快速渲染大量独立连接的对象</li>
</ul>
<h3 id="cons-3">骗局</h3>
<ul>
<li>不如其他渲染引擎灵活</li>
<li>在开发人员中不太受欢迎，所以有时很难找到资源来帮助解决常见问题</li>
<li>文档没有清楚地解释概念</li>
</ul>
<h3 id="gettingstartedwithxeogljs">Xeogl.js在行动</h3>
<p>要开始使用Xeogl.js，首先将CDN库添加到您的项目中。</p>
<pre>&lt;script src="https://github.com/xeolabs/xeogl/blob/master/build/xeogl.js"&gt;&lt;/script&gt;
</pre>
<p>接下来，创建您的3D对象。然后，用下面的代码创建一个<code>geometry</code>变量。</p>
<pre>const geometry = new xeogl.TorusGeometry({
    radius: 1.0,
    tube: 0.3
});
</pre>
<p>使用下面的代码创建一些<code>metallicMaterial</code>。</p>
<pre>const material = new xeogl.MetallicMaterial({
    baseColorMap: new xeogl.Texture({
        src: "textures/diffuse/uvGrid2.jpg"
    }),
    roughnessMap: new xeogl.Texture({
        src: "textures/roughness/goldRoughness.jpg"
    })
});
</pre>
<p>最后创建一些<code>Mesh</code>，添加上面的对象。</p>
<pre>const mesh = new xeogl.Mesh({
    geometry: geometry,
    material: material,
    position: [0, 0, 10]
});
</pre>
<p>如果一切按计划进行，您应该会看到如下内容:</p>
<p><img data-attachment-id="26191" data-permalink="https://blog.logrocket.com/top-4-3d-rendering-engines-available-in-js/xeogl-sample/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/09/xeogl-sample.png" data-orig-size="600,300" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Xeogl example graphic" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/09/xeogl-sample-300x150.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/09/xeogl-sample.png" decoding="async" class="aligncenter size-full wp-image-26191 jetpack-lazy-image" src="../Images/d2c81b6eba0acf3afba7a74d35448cc2.png" alt="Purple Gradient 3D Circle on a Black Background" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2020/09/xeogl-sample.png 600w, https://blog.logrocket.com/wp-content/uploads/2020/09/xeogl-sample-300x150.png 300w" data-lazy-sizes="(max-width: 600px) 100vw, 600px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2020/09/xeogl-sample.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/09/xeogl-sample.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="26191" data-permalink="https://blog.logrocket.com/top-4-3d-rendering-engines-available-in-js/xeogl-sample/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/09/xeogl-sample.png" data-orig-size="600,300" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Xeogl example graphic" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/09/xeogl-sample-300x150.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/09/xeogl-sample.png" decoding="async" loading="lazy" class="aligncenter size-full wp-image-26191" src="../Images/d2c81b6eba0acf3afba7a74d35448cc2.png" alt="Purple Gradient 3D Circle on a Black Background" srcset="https://blog.logrocket.com/wp-content/uploads/2020/09/xeogl-sample.png 600w, https://blog.logrocket.com/wp-content/uploads/2020/09/xeogl-sample-300x150.png 300w" sizes="(max-width: 600px) 100vw, 600px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/09/xeogl-sample.png"/></noscript>
<h2 id="finalthoughts">选择正确的渲染引擎</h2>
<p>与任何项目一样，最好的工具将取决于您独特的目标、需求和要求。希望这篇概述能帮助你做出正确的选择，让你的游戏变得生动。</p>
<p>在大多数情况下，在我看来，Cannon.js不会出错。如果你正在构建复杂的图形，它特别有用；由于内建了许多原本需要外部库的功能，Cannon的尺寸更小，如果优先考虑快速处理的话，它是一个很好的选择。</p>
<p>另一方面，如果你只想创建简单的图形，Phoria.js是一个很好的库。因为它不支持WebGL，所以很难用Phoria创建复杂的3D图形。</p>
<p>如果你幻想自己是一名web数据科学家，并且正在寻找创建惊人的数据可视化，D3是一个可靠的选择。</p>
<p>最后，如果您的目标是在web上创建类似CAD的图形或模型可视化，Xeogl.js是一个有趣的选择。</p>
<p>你最喜欢哪个渲染引擎？我们错过什么了吗？欢迎留言！</p><div class="code-block code-block-27">
<div class="blog-plug inline-plug vanilla-javascript-cta"><h2>通过理解上下文，更容易地调试JavaScript错误</h2>
<p>调试代码总是一项单调乏味的任务。但是你越了解自己的错误，就越容易改正。</p>
<p>LogRocket 让你以新的独特的方式理解这些错误。我们的前端监控解决方案跟踪用户与您的JavaScript前端的互动，让您能够准确找出导致错误的用户行为。</p>
<a href="https://lp.logrocket.com/blg/javascript-signup" class="signup" target="_blank" rel="noopener noreferrer"><img class="alignnone size-full wp-image-46 jetpack-lazy-image" src="../Images/cbfed9be3defcb505e662574769a7636.png" alt="LogRocket Dashboard Free Trial Banner" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2020/06/reproduce-javascript-errors.gif?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/06/reproduce-javascript-errors.gif"/><noscript><img data-lazy-fallback="1" class="alignnone size-full wp-image-46" src="../Images/cbfed9be3defcb505e662574769a7636.png" alt="LogRocket Dashboard Free Trial Banner" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/06/reproduce-javascript-errors.gif"/></noscript></a>
<p>LogRocket记录控制台日志、页面加载时间、堆栈跟踪、慢速网络请求/响应(带有标题+正文)、浏览器元数据和自定义日志。理解您的JavaScript代码的影响从来没有这么简单过！</p>
<a class="signup" href="https://lp.logrocket.com/blg/javascript-signup" target="_blank" rel="noopener noreferrer">Try it for free</a><p>.</p></div>


</div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
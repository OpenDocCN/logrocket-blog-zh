<html>
<head>
<title>Redux immutable update patterns - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>Redux不可变更新模式</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/redux-immutable-update-patterns/#0001-01-01">https://blog.logrocket.com/redux-immutable-update-patterns/#0001-01-01</a></blockquote><div><article class="article-post">
<p><em> <strong>编者按</strong>:这篇文章最后一次更新是在2021年12月30日，包含了关于Redux Toolkit的信息。</em></p>
<p>既然您正在阅读一篇关于Redux的文章，我假设您正在从事的项目正处于成长阶段，并且可能会变得日益复杂。您可能会有新的业务逻辑需求，这意味着您需要一种一致且可调试的方法来处理应用程序状态，以处理不同的域。</p>
<p>如果你是一个开发简单应用的开发人员，或者你刚刚开始学习一个新的前端框架，比如React，<a href="https://blog.logrocket.com/8-definitive-rules-building-apps-redux/">你可能不需要Redux </a>，除非你把它当成一个学习机会。</p>
<p>虽然Redux使您的应用程序更加复杂，但是这种复杂性为大规模状态管理带来了简单性。在本文中，我们将通过研究Redux的不可变更新模式来探索这个概念。我们开始吧！</p>
<h3>目录</h3>

<h2 id="reduxs-inner-workings">Redux的内部运作</h2>
<p>当您有几个不需要相互通信的独立组件，并且希望维护一个简单的UI或业务逻辑时，请使用本地状态。如果您有几个组件需要订阅以获得相同类型的数据，并且作为反应，调度通知、更改或事件，<a href="https://blog.logrocket.com/component-state-local-state-redux-store-and-loaders/"> loaders可能是您最好的朋友</a>。</p>
<p>但是，如果您有几个组件需要与其他组件共享某种状态，而没有直接的父子关系，如下图所示，那么Redux是一个完美的解决方案。</p>
<p>如果没有Redux，每个组件都需要以某种形式将状态传递给需要它的其他组件，并在反应中处理命令或事件调度。你可以看到这个系统是如何变得难以大规模维护、测试和调试的。</p>
<p>然而，在Redux的帮助下，任何组件都不需要持有任何管理状态的逻辑。相反，他们必须订阅Redux来获得他们需要的状态，并在需要时向它分派动作作为回报:</p>
<figure id="attachment_85044" aria-describedby="caption-attachment-85044" class="wp-caption aligncenter"><img data-attachment-id="85044" data-permalink="https://blog.logrocket.com/redux-immutable-update-patterns/redux-subscribe-comonents/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/04/redux-subscribe-comonents.png" data-orig-size="730,430" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="redux-subscribe-components" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/04/redux-subscribe-comonents-300x177.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/04/redux-subscribe-comonents.png" decoding="async" class="wp-image-85044 size-full jetpack-lazy-image" src="../Images/935355ef808c823740233f6ba58cc81e.png" alt="Redux Subscribe Components" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2020/04/redux-subscribe-comonents.png 730w, https://blog.logrocket.com/wp-content/uploads/2020/04/redux-subscribe-comonents-300x177.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2020/04/redux-subscribe-comonents.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/04/redux-subscribe-comonents.png"/><noscript><img data-lazy-fallback="1" data-attachment-id="85044" data-permalink="https://blog.logrocket.com/redux-immutable-update-patterns/redux-subscribe-comonents/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/04/redux-subscribe-comonents.png" data-orig-size="730,430" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="redux-subscribe-components" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/04/redux-subscribe-comonents-300x177.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/04/redux-subscribe-comonents.png" decoding="async" loading="lazy" class="wp-image-85044 size-full" src="../Images/935355ef808c823740233f6ba58cc81e.png" alt="Redux Subscribe Components" srcset="https://blog.logrocket.com/wp-content/uploads/2020/04/redux-subscribe-comonents.png 730w, https://blog.logrocket.com/wp-content/uploads/2020/04/redux-subscribe-comonents-300x177.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/04/redux-subscribe-comonents.png"/></noscript><figcaption id="caption-attachment-85044" class="wp-caption-text">Graph of components initiating change with and without Redux</figcaption></figure>
<p><a href="https://blog.codecentric.de/"><strong><em>https://blog . code centric . de</em></strong>T5】</a></p>
<p><a href="https://blog.logrocket.com/react-router-with-redux-navigation-state/">支持状态管理的Redux的核心部分是Redux store </a>，它将应用程序的逻辑保存为一个<code>state</code>对象。<code>state</code>对象公开了一些方法来获取、更新和监听状态及其变化。</p>
<p>在本文中，我们将只关注使用<code>dispatch(action)</code>方法更新状态。<code>dispatch(action)</code>方法是修改状态的唯一方法，以这种形式<a href="https://redux.js.org/api/store/#dispatchaction">出现。</a></p>
<p>存储的归约函数将与当前<code>getState()</code>结果和给定动作同步调用。它的返回值将被认为是下一个状态。从现在开始它将从<code>getState()</code>返回，改变监听器将立即被通知。要记住的主要事情是，对状态的任何更新都应该以不可变的方式发生。</p>

<p>注意:在更新这篇帖子的时候，大多数开发者使用<a href="https://blog.logrocket.com/using-redux-toolkits-createasyncthunk/"> Redux Toolkit来轻松地在他们的React应用程序中设置Redux </a>。</p>
<p>有了Redux Toolkit，我们就不用担心不变性了。虽然在使用Redux Toolkit时，状态似乎是可变的，但实际上<a href="https://blog.logrocket.com/immer-and-immutable-js-how-do-they-compare/">在幕后使用Immer】来确保状态是不可变的，这使得状态管理更加容易。</a></p>
<p>Redux Toolkit用切片来表示一段数据；让我们来看一个例子:</p>
<pre>const locationSlice = createSlice({
  name: 'location',
  initialState: {x: 0, y: 0},
  reducers: {
    setXCoord: (state, action) =&gt; {
      state.x = action.payload;
    },
    setYCoord: (state, action) =&gt; {
      state.y = action.payload;
    },
  },
})
</pre>
<p>上面的Redux工具包切片也包含了<code>reducer</code>函数。这里，我们有两个函数，<code>setXCoord</code>和<code>setYCoord</code>。两者看起来都是直接突变状态，但这并不是因为Immer，它正在Redux Toolkit中幕后使用。</p>
<p>让我们来看一个待办事项列表和一个更新数组的场景:</p>
<pre>const todoSlice = createSlice({
  name: 'todos',
  initialState: [],
  reducers: {
    addTodo: (state, action) =&gt; {
      state.push(action.payload)
    }
  },
})
</pre>
<p>我们试图使用<code>push()</code>，它改变了数组，我们将在本文后面讨论。这里，我们在状态的副本上使用<code>push()</code>，Redux Toolkit确保状态被正确更新。</p>
<p>如果您仍然想要手动设置Redux，您可能需要自己处理不变性。在本文的后面，我们将看到为什么不变性是必要的，以及如何处理它。</p>
<h2 id="why-use-immutable-update-pattern">为什么要使用不可变的更新模式？</h2>
<p>假设您正在开发一个电子商务应用程序，初始状态如下:</p>
<pre>const initialState = {
  isInitiallyLoaded: false,
  outfits: [],
  filters: {
    brand: [],
    colour: [],
  },
  error: '',
};
</pre>
<p>我们这里有各种各样的数据类型，包括<code>string</code>、<code>boolean</code>、<code>array</code>和<code>object</code>。为了响应应用程序事件，这些<code>state</code>对象参数需要以不可变的方式更新。换句话说，原始状态或其参数<a href="https://redux.js.org/usage/structuring-reducers/immutable-update-patterns/">不会改变或突变</a>。相反，我们将复制原始值，修改它们以返回新值。</p>
<h2 id="immutability-javascript">JavaScript中的不变性</h2>
<p>默认情况下，<code>strings</code>和<code>booleans</code>，以及其他像<code>number</code>或<code>symbol</code>这样的原语是不可变的。这里有一个<code>strings</code>不变性的例子:</p>
<pre>// strings are immutable by default

// for example when you define a variable like:
var myString = 'sun';

// and want to change one of its characters (string are handled like Array):
myString[0] = 'r';

// you see that this is not possible due to the immutability of strings
console.log(myString); // 'sun'

// also if you have two references to the same string, changing one does not affect the other
var firstString = secondString = "sun";

firstString = firstString + 'shine';
console.log(firstString); // 'sunshine'
console.log(secondString); // 'sun'
</pre>
<p><code>objects</code>是可变的，但可以<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/freeze">冻结</a>。在下面的例子中，我们看到了这一点。我们还看到，当我们通过将一个新对象指向一个现有对象来创建该对象，然后改变该新对象的一个属性时，会导致这两个对象的属性都发生变化:</p>
<pre>'use strict';

// setting myObject to a `const` will not prevent mutation.
const myObject = {};
myObject.mutated = true;
console.log(myObject.mutated); // true

// Object.freeze(obj) to prevent re-assigning properties, 
// but only at top level
Object.freeze(myObject);
myObject.mutated = true;
console.log(myObject.mutated); // undefined

// example of mutating an object properties
let outfit = {
    brand: "Zara",
    color: "White",
    dimensions: {
        height: 120,
        width: 40,
    }
}

// we want a mechanism to attach price to outfits
function outfitWithPricing(outfit) {
    outfit.price = 200;
    return outfit;
}

console.log(outfit); // has no price

let anotherOutfit = outfitWithPricing(outfit);

// there is another similar outfit that we want to have pricing.
// now outfitWithPricing has changed the properties of both objects.
console.log(outfit); // has price
console.log(anotherOutfit); // has price

// even though the internals of the object has changed, 
// they are both still pointing to the same reference
console.log(outfit === anotherOutfit); // true
</pre>
<p>如果我们想完成对对象的不可变更新，我们有几个选择，比如<code>Object.assign</code>或<code>spread operator</code>:</p>
<pre>// lets do this change in an immutable way
// we use spread oeprator and Object.assign for 
// this purpose. we need to refactor outfitWithPricing
// not to mutate the input object and instead return a new one
function outfitWithPricing(outfit) {
  let newOutfit = Object.assign({}, outfit, {
    price: 200
  })

  return newOutfit;
}

function outfitWithPricing(outfit) {
  return {
    ...outfit,
    price: 200,
  }
}

let anotherOutfit = outfitWithPricing(outfit);
console.log(outfit); // does not have price
console.log(anotherOutfit); // has price

// these two objects no longer point to the same reference
console.log(outfit === anotherOutfit); // false
</pre>
<p>拥有可变和不可变的方法。记住哪些数组方法是哪些是很重要的。这里有几个例子:</p>
<ul>
<li>不可变方法:<code>concat</code>、<code>filter</code>、<code>map</code>、<code>reduce</code>、<code>reduceRight</code></li>
<li>可变方法:<code>push</code>、<code>pop</code>、<code>shift</code>、<code>unshift</code>、<code>sort</code>、<code>reverse</code>、<code>splice</code>、<code>delete</code></li>
</ul>
<p>请记住，<code>spread operator</code>也适用于<code>array</code>,可以使不可变的更新更加容易。让我们看一些可变和不可变的更新作为例子:</p>
<pre>// The push() method adds one or more elements to the end of an array and returns
// the new length of the array.
const colors = ['red', 'blue', 'green'];

// setting a new varialbe to point to the original one
const newColors = colors;
colors.push('yellow'); // returns new length of array which is 4
console.log(colors); // Array ["red", "blue", "green", "yellow"]

// newColors has also been mutated
console.log(newColors); // Array ["red", "blue", "green", "yellow"]

// we can use one of the immutable methods to prevent this issue
let colors = ['red', 'blue', 'green'];
const newColors = colors;

// our immutable examples will be based on spread operator and concat method
colors = [...colors, 'yellow'];
colors = [].concat(colors, 'purple');

console.log(colors); // Array ["red", "blue", "green", "yellow", "purple"]
console.log(newColors); // Array ["red", "blue", "green"]
</pre>
<p>在一个真实的例子中，如果我们需要更新state上的<code>error</code>属性，我们需要对reducer执行<code>dispatch</code>操作。Redux reducers是纯函数，意思是:</p>
<ul>
<li>它们总是基于相同的输入返回相同的值，即<code>state</code>和<code>action</code></li>
<li>它们不会产生任何副作用，比如进行API调用</li>
</ul>
<p>这些属性要求我们以不可变的方式处理reducers中的状态更新，这带来了几个好处:</p>
<ul>
<li>更容易测试减速器，因为输入和输出总是可预测的</li>
<li>调试和时间旅行，所以你可以看到历史的变化，而不仅仅是结果</li>
</ul>
<p>最大的优势是保护我们的应用程序不会出现渲染问题。在React这样依赖状态来更新虚拟DOM的框架中，拥有正确的状态是必须的。</p>
<p>React可以通过比较引用来了解状态是否发生了变化，引用的<a href="https://yourbasic.org/algorithms/big-o-notation-explained/#constant-time">符号为<code>1</code> </a>，表示速度更快，而递归比较对象的速度较慢，表示为<code>n</code> 的<a href="https://yourbasic.org/algorithms/big-o-notation-explained/#linear-time">符号:</a></p>
<figure id="attachment_85046" aria-describedby="caption-attachment-85046" class="wp-caption aligncenter"><img data-attachment-id="85046" data-permalink="https://blog.logrocket.com/redux-immutable-update-patterns/big-o-complexity-chart/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/04/big-o-complexity-chart.jpeg" data-orig-size="730,508" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="big-o-complexity-chart" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/04/big-o-complexity-chart-300x209.jpeg" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/04/big-o-complexity-chart.jpeg" decoding="async" class="wp-image-85046 size-full jetpack-lazy-image" src="../Images/ec0749abb37e3573d138e9ece0a1ff17.png" alt="Big O Complexity Chart" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2020/04/big-o-complexity-chart.jpeg 730w, https://blog.logrocket.com/wp-content/uploads/2020/04/big-o-complexity-chart-300x209.jpeg 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2020/04/big-o-complexity-chart.jpeg?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/04/big-o-complexity-chart.jpeg"/><noscript><img data-lazy-fallback="1" data-attachment-id="85046" data-permalink="https://blog.logrocket.com/redux-immutable-update-patterns/big-o-complexity-chart/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/04/big-o-complexity-chart.jpeg" data-orig-size="730,508" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="big-o-complexity-chart" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/04/big-o-complexity-chart-300x209.jpeg" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/04/big-o-complexity-chart.jpeg" decoding="async" loading="lazy" class="wp-image-85046 size-full" src="../Images/ec0749abb37e3573d138e9ece0a1ff17.png" alt="Big O Complexity Chart" srcset="https://blog.logrocket.com/wp-content/uploads/2020/04/big-o-complexity-chart.jpeg 730w, https://blog.logrocket.com/wp-content/uploads/2020/04/big-o-complexity-chart-300x209.jpeg 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/04/big-o-complexity-chart.jpeg"/></noscript><figcaption id="caption-attachment-85046" class="wp-caption-text">Big-O complexity chart</figcaption></figure>
<p>在我们分派了<code>HANDLE_ERROR</code>动作，通知reducer我们需要更新状态之后，将会发生以下情况:</p>
<ul>
<li>首先，它使用<code>spread operator</code>来复制<code>stat</code>对象</li>
<li>接下来，它更新<code>error</code>属性并返回新的状态</li>
<li>订阅该存储的所有组件都会收到关于这个新状态的通知，如果需要的话会重新呈现</li>
</ul>
<pre>// initial state
    const initialState = {
      isInitiallyLoaded: false,
      outfits: [],
      filters: {
        brand: [],
        colour: [],
      },
      error: '',
    };
 a reducer takes a state (the current state) and an action object (a plain JavaScript object that was dispatched via dispatch(..) and potentially returns a new state. */ function handleError(state = initialState, action) { if (action.type === 'HANDLE_ERROR') { return { ...state, error: action.payload, } // note that a reducer MUST return a value } } // in one of your components ... store.dispatch({ type: 'HANDLE_ERROR', payload: error }) // dispatch an action that causes the reducer to execute and handle error</pre>
<p>我们已经以不变的方式介绍了Redux更新模式的基础知识。然而，有些类型的更新可能比其他类型的更新更棘手，比如删除或更新嵌套数据。</p>
<h2 id="adding-items-arrays">在数组中添加项目</h2>
<p>如前所述，像<code>unshift</code>、<code>push</code>和<code>splice</code>这样的数组方法是可变的。如果我们要就地更新阵列，我们希望远离这些。</p>
<p>无论我们是想将项目添加到数组的开头还是结尾，我们都可以简单地使用<code>spread operator</code>来返回一个包含所添加项目的新数组。如果我们打算在某个索引处添加项目，我们可以使用<code>splice</code>，只要我们首先制作一个状态的副本。然后，改变任何属性都是安全的:</p>
<pre>// ducks/outfits (Parent)

// types
export const NAME = `@outfitsData`;
export const PREPEND_OUTFIT = `${NAME}/PREPEND_OUTFIT`;
export const APPEND_OUTFIT = `${NAME}/APPEND_OUTFIT`;
export const INSERT_ITEM = `${NAME}/INSERT_ITEM`;

// initialization
const initialState = {
  isInitiallyLoaded: false,
  outfits: [],
  filters: {
    brand: [],
    colour: [],
  },
  error: '',
};

// action creators
export function prependOutfit(outfit) {
    return {
      type: PREPEND_OUTFIT,
      outfit
    };
}

export function appendOutfit(outfit) {
    return {
      type: APPEND_OUTFIT,
      outfit
    };
}

export function insertItem({ outfit, index }) {
    return {
      type: INSERT_ITEM,
      outfit,
      index,
    };
}

// immutability helpers
function insertItemImHelper(array, action) {
  let newArray = array.slice()
  newArray.splice(action.index, 0, action.item)
  return newArray
}


export default function reducer(state = initialState, action = {}) {
  switch (action.type) {  
  case PREPEND_OUTFIT:
    return {
      ...state,
      outfits: [
        action.payload,
        ...state.outfits,
      ]
    };
  case APPEND_OUTFIT:
    return {
      ...state,
      outfits: [
        ...state.outfits,
        action.payload,
      ]
    };
  case INSERT_ITEM:
    return {
      ...state,
      outfits: insertItemImHelper(state.outfits, action)
    };
  default:
     return state;
  }
}
</pre>
<h2 id="adding-items-arrays-nested-object">在嵌套对象的数组中添加项</h2>
<p>更新嵌套数据变得有点棘手。记住要正确地更新每一层数据，以便正确地执行更新。让我们看一个将项目添加到数组的示例，该数组位于嵌套对象中:</p>
<pre>// ducks/outfits (Parent)

// types
export const NAME = `@outfitsData`;
export const ADD_FILTER = `${NAME}/ADD_FILTER`;

// initialization
const initialState = {
  isInitiallyLoaded: false,
  outfits: [],
  filters: {
    brand: [],
    colour: [],
  },
  error: '',
};

// action creators
export function addFilter({ field, filter }) {
    return {
      type: ADD_FILTER,
      field,
      filter,
    };
}

export default function reducer(state = initialState, action = {}) {
  switch (action.type) {  
  case ADD_FILTER:
  return {
    ...state,
    filters: {
    ...state.filters,
       [action.field]: [
         ...state.filters[action.field],
         action.filter,
       ]
    },
  };
  default:
     return state;
  }
}
</pre>
<h2 id="removing-items-arrays">移除数组中的项目</h2>
<p>有几种方法可以以不可变的方式移除项目。首先，我们可以使用像<code>filter</code>这样的不可变方法，它返回一个新数组:</p>
<pre>function removeItemFiter(array, action) {
  return array.filter((item, index) =&gt; index !== action.index)
}
</pre>
<p>或者，我们可以先复制一个数组，然后使用<code>splice</code>删除数组中某个索引中的一项:</p>
<pre>function removeItemSplice(array, action) {
  let newArray = array.slice()
  newArray.splice(action.index, 1)
  return newArray
}
</pre>
<p>下面的例子展示了在reducer中使用这些不变性概念来返回正确的状态:</p>
<pre>// ducks/outfits (Parent)

// types
export const NAME = `@outfitsData`;
export const REMOVE_OUTFIT_SPLICE = `${NAME}/REMOVE_OUTFIT_SPLICE`;
export const REMOVE_OUTFIT_FILTER = `${NAME}/REMOVE_OUTFIT_FILTER`;

// initialization
const initialState = {
  isInitiallyLoaded: false,
  outfits: [],
  filters: {
    brand: [],
    colour: [],
  },
  error: '',
};

// action creators
export function removeOutfitSplice({ index }) {
    return {
      type: REMOVE_OUTFIT_SPLICE,
      index,
    };
}

export function removeOutfitFilter({ index }) {
    return {
      type: REMOVE_OUTFIT_FILTER,
      index,
    };
}

// immutability helpers
function removeItemSplice(array, action) {
  let newArray = array.slice()
  newArray.splice(action.index, 1)
  return newArray
}

function removeItemFiter(array, action) {
  return array.filter((item, index) =&gt; index !== action.index)
}

export default function reducer(state = initialState, action = {}) {
  switch (action.type) {  
  case REMOVE_OUTFIT_SPLICE:
    return {
      ...state,
      outfits: removeItemSplice(state.outfits, action)
    };
  case REMOVE_OUTFIT_FILTER:
    return {
      ...state,
      outfits: removeItemFiter(state.outfits, action)
    };
  default:
     return state;
  }
}
</pre>
<h2 id="removing-items-arrays-nested-object">移除嵌套对象内数组中的项目</h2>
<p>最后，我们将移除数组中的一个项，它位于一个嵌套对象中。这非常类似于添加一个项目，但是我们将在嵌套数据中过滤掉该项目:</p>
<pre>// ducks/outfits (Parent)

// types
export const NAME = `@outfitsData`;
export const REMOVE_FILTER = `${NAME}/REMOVE_FILTER`;

// initialization
const initialState = {
  isInitiallyLoaded: false,
  outfits: ['Outfit.1', 'Outfit.2'],
  filters: {
    brand: [],
    colour: [],
  },
  error: '',
};

// action creators
export function removeFilter({ field, index }) {
  return {
    type: REMOVE_FILTER,
    field,
    index,
  };
}

export default function reducer(state = initialState, action = {}) {
  sswitch (action.type) {  
  case REMOVE_FILTER:
  return {
    ...state,
    filters: {
    ...state.filters,
       [action.field]: [...state.filters[action.field]]
       .filter((x, index) =&gt; index !== action.index)
    },
  };
  default:
     return state;
  }
}
</pre>
<h2 id="conclusion">结论</h2>
<p>在本文中，我们介绍了以下内容:</p>
<ul>
<li>为什么以及何时我们需要像Redux这样的状态管理工具</li>
<li>Redux状态管理和更新如何工作</li>
<li>Redux工具包如何处理不变性</li>
<li>为什么不可变更新很重要</li>
<li>如何处理棘手的更新，比如在嵌套对象中添加或删除项目</li>
</ul>
<p>在本文中，我们打算学习Redux中手动不可变更新模式的基础，然而，有一组不可变库，如<a href="https://immutable-js.github.io/immutable-js/"> ImmutableJS </a>或<a href="https://github.com/immerjs/immer"> Immer </a>可以使您的状态更新不那么冗长，更可预测。</p><div class="code-block code-block-17">
<div class="blog-plug inline-plug react-plug" vwo-el-id="26283398190">
<h2 vwo-el-id="41600691720">使用LogRocket消除传统反应错误报告的噪音</h2>
<a href="https://lp.logrocket.com/blg/react-signup-issue-free" target="_blank" vwo-el-id="19356441070">LogRocket
</a><p>是一款React analytics解决方案，可保护您免受数百个误报错误警报的影响，只针对少数真正重要的项目。LogRocket告诉您React应用程序中实际影响用户的最具影响力的bug和UX问题。</p><a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="19356441380">
<img class="first-react-image alignnone size-full wp-image-46 jetpack-lazy-image jetpack-lazy-image--handled" src="../Images/f300c244a1a1cf916df8b4cb02bec6c6.png" vwo-el-id="18272717540" data-lazy-loaded="1" data-original-src="https://files.readme.io/27c94e7-Image_2017-06-05_at_9.46.04_PM.png"/>
</a>
<a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="19356441690">
<img class="second-react-image alignnone size-full wp-image-46 jetpack-lazy-image jetpack-lazy-image--handled" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" vwo-el-id="30720362350" data-lazy-loaded="1" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/>
</a>
<a href="https://lp.logrocket.com/blg/react-signup-issue-free" target="_blank" rel="noopener noreferrer" vwo-el-id="35866400580">LogRocket
</a><p>自动聚合客户端错误、反应错误边界、还原状态、缓慢的组件加载时间、JS异常、前端性能指标和用户交互。然后，LogRocket使用机器学习来通知您影响大多数用户的最具影响力的问题，并提供您修复它所需的上下文。</p><p vwo-el-id="28675661060">关注重要的React bug—<a class="signup" href="https://lp.logrocket.com/blg/react-signup-issue-free" target="_blank" rel="noopener noreferrer" vwo-el-id="40093418840">今天就试试LogRocket】。</a></p>
</div></div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
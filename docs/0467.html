<html>
<head>
<title>Comparing React form builders: Formik vs. Unform - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>比较React表单生成器:Formik与unim-log rocket博客</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/comparing-react-form-builders-formik-vs-unform/#0001-01-01">https://blog.logrocket.com/comparing-react-form-builders-formik-vs-unform/#0001-01-01</a></blockquote><div><article class="article-post">
<p><em> <strong>编者按</strong>:本帖更新于2021年11月1日。</em></p>
<p>应用程序越现代，开发人员就越有可能需要使用特殊的功能和有用的提示来确保要求苛刻的客户对他们的用户体验感到满意。</p>
<p>在React的世界里，表单给了我们输入组件的所有能力——但是这种能力还不够。</p>
<p>我们需要更好、更快的方法来创建定制的组件，包括输入、选择、按钮和潜在的新组件，这些组件不能被我们的浏览器隐式地识别(例如，根据组件创建新的UI体验)。</p>
<p>我们需要以多种不同的形式验证数据，有时通过复杂的正则表达式或JavaScript验证函数，有时通过外部资源。在某些情况下，可能需要在导航器中本地存储数据，并明智地恢复它。其他人可能需要以他们自己的方式与这些组件通信。</p>
<p>React没有给开发者提供处理自定义高亮的方法，所以社区想出了自己做的方法。</p>
<p>有许多不同的选项，比如用于基本表单操作的库、与Redux的集成等等。在这一点上，用户的最佳选择似乎是<a href="https://jaredpalmer.com/formik/" target="_blank" rel="noopener noreferrer">Formik</a>——至少数字是这么告诉我们的。</p>
<h2>什么是福米克？</h2>
<p>下图显示了在npmtrends.com的<a href="https://www.npmtrends.com/" target="_blank" rel="noopener noreferrer">下载最多的</a>著名React表单库的<a href="https://www.npmtrends.com/final-form-vs-formik-vs-react-form-vs-formsy" target="_blank" rel="noopener noreferrer">NPM包(根据本文的撰写):</a></p>
<p><img data-attachment-id="77783" data-permalink="https://blog.logrocket.com/comparing-react-form-builders-formik-vs-unform/image2-15/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2019/10/image2-1-e1637169404824.png" data-orig-size="730,343" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="compare-react-form-builders-formik-unform" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2019/10/image2-1-300x141.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2019/10/image2-1-1024x481.png" decoding="async" class="aligncenter size-full wp-image-77783 jetpack-lazy-image" src="../Images/054448afa1e2fcfd4c7ee4f9f824c073.png" alt="" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2019/10/image2-1-e1637169404824.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/10/image2-1-e1637169404824.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="77783" data-permalink="https://blog.logrocket.com/comparing-react-form-builders-formik-vs-unform/image2-15/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2019/10/image2-1-e1637169404824.png" data-orig-size="730,343" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="compare-react-form-builders-formik-unform" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2019/10/image2-1-300x141.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2019/10/image2-1-1024x481.png" decoding="async" loading="lazy" class="aligncenter size-full wp-image-77783" src="../Images/054448afa1e2fcfd4c7ee4f9f824c073.png" alt="" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/10/image2-1-e1637169404824.png"/></noscript>
<p>福米克是目前最受欢迎的。它不仅灵活，而且可以与React通信，还允许开发人员轻松地与<a href="https://github.com/jquense/yup" target="_blank" rel="noopener noreferrer"> Yup </a>(一种流行的JavaScript对象模式验证器和对象解析器)集成。</p>
<p>也许它最重要的特性是表单状态管理——我们不再需要在每次击键时都调用Redux store的状态(这确实是一种不好的做法),因为状态是由Formik在本地自动维护的。</p>
<h2>什么是制服？</h2>
<p>虽然Formik擅长处理受控组件，但它不擅长处理非受控组件。</p>
<p>另一方面，Unform 致力于为React表单和嵌套结构(尤其是深层结构)提供高性能。Unform还允许您在组件之间建立牢固的关系，甚至是不受控制的组件，而不会牺牲任何性能。这个巴西React库与React <a href="https://reactjs.org/docs/hooks-intro.html" target="_blank" rel="noopener noreferrer">钩子</a>配合得非常好。</p>
<p>在本文中，我们将通过几个例子来展示这个库的潜力。</p>
<h2>使用formik和uniform创建表单</h2>
<p>首先，让我们看看这两个库是如何处理表单创建的。下面，我们可以看到Formik表单的基本用法:</p>
<pre>import React from 'react';
import { Formik } from 'formik';

const SampleForm = () =&gt; (
  &lt;div&gt;
    &lt;Formik
      initialValues={{ email: '', password: '' }}
      validate={values =&gt; {
        const errors = {};
        
        // error validations here

        return errors;
      }}
      onSubmit={(values, { setSubmitting }) =&gt; {
        setTimeout(() =&gt; {
          console.log(values);

          // submit logic here
          
          setSubmitting(false);
        }, 400);
      }}
    &gt;
      {({
        values,
        errors,
        touched,
        handleChange,
        handleBlur,
        handleSubmit,
        isSubmitting,
      }) =&gt; (
        &lt;form onSubmit={handleSubmit}&gt;
          // fields
          {errors.email &amp;&amp; touched.email &amp;&amp; errors.email}
          
          &lt;button type="submit" disabled={isSubmitting}&gt;
            Submit
          &lt;/button&gt;
        &lt;/form&gt;
      )}
    &lt;/Formik&gt;
  &lt;/div&gt;
);

export default SampleForm;
</pre>
<p>有关React规格，请参考React官方文档。大多数库通常建议开发者从JavaScript提交函数开始。</p>
<p>在我们的例子中，这个函数有两个参数:<code>values</code>，它表示表单字段的值，第二个对象包含Formik的属性和函数，可以在submit body函数中免费使用。</p>
<p>例如，<code>setSubmitting</code>(布尔值)是分析请求当前是否正在发生的有用机制。</p>
<p>每种形式都由主要元素<code>&lt;Formik&gt;</code>和一些重要道具组成:</p>
<ul>
<li><code>initialValues</code>:每个后续受控组件的本地状态值</li>
<li><code>validate</code>:接收表单的所有值作为参数。您可以使用这个函数来执行您想要的任何验证。您还可以使用它来设置和返回正确的错误代码/消息</li>
<li><code>onSubmit</code>:决定哪个函数将处理提交事件</li>
<li><code>render</code>:隐式表单渲染函数本身。确定表单中哪些是受控制的Formik组件，哪些是不受控制的HTML组件</li>
</ul>
<p>很简单，不是吗？让我们看看下面等价的Unform形式。确保已经安装了<code>react</code>、<code>react-dom</code>和<code>yup</code>软件包。</p>
<pre>import React from 'react'
import { Form } from '@unform/web'
import { useField } from '@unform/core'
import * as Yup from 'yup';

function Input({ name, ...rest }) {
    const inputRef = React.useRef(null)
    const { fieldName, defaultValue, registerField, error } = useField(name)
  
    React.useEffect(() =&gt; {
      registerField({
        name: fieldName,
        ref: inputRef,
        getValue: ref =&gt; {
          return ref.current.value
        },
        setValue: (ref, value) =&gt; {
          ref.current.value = value
        },
        clearValue: ref =&gt; {
          ref.current.value = ''
        },
      })
    }, [fieldName, registerField])
  
    return &lt;input ref={inputRef} defaultValue={defaultValue} {...rest} /&gt;
  }
  
  function SampleForm() {
    const formRef = React.useRef(null);

    const initialValues = {
        email: '',
        document: ''
    };
    
    async function handleSubmit(data) {
        try {
            // Remove all previous errors
            formRef.current.setErrors({});
            const schema = Yup.object().shape({
              email: Yup.string()
                .email()
                .required(),
              password: Yup.string()
                .min(6)
                .required(),
            });
            await schema.validate(data, {
              abortEarly: false,
            });

            // Validation passed
            console.log(data);
        } catch (err) {
            const validationErrors = {};
            if (err instanceof Yup.ValidationError) {
              err.inner.forEach(error =&gt; {
                validationErrors[error.path] = error.message;
              });
              formRef.current.setErrors(validationErrors);
            }
        }
    }
  
    return (
      &lt;Form ref={formRef} initialData={initialValues} onSubmit={handleSubmit}&gt;
        &lt;Input name="email" type="email" /&gt;
        &lt;Input name="password" type="password" /&gt;
  
        &lt;button type="submit"&gt;Sign in&lt;/button&gt;
      &lt;/Form&gt;
    )
  }
  
  render(
    &lt;&gt;
      &lt;SampleForm /&gt;
    &lt;/&gt;
  )
</pre>
<p><span>首先，我们需要通过</span>安装Unform</p>
<pre>yarn add @unform/web @unform/core
# or
npm i @unform/web @unform/core
</pre>
<p>现在我们需要从Unform导入各自的<code>Form</code>和<code>Input</code>组件。您将看到的第二件事与一个Yup验证模式有关。</p>
<p>像Formik一样，通过提供一个<code>schema</code>属性，您可以稍后使用它来验证表单输入值，从而轻松地与Yup模式集成。因为到目前为止，Yup是最流行的输入值验证库，所以使用起来非常简单。</p>
<p>这段代码提供了一个例子来帮助您更好地理解带有验证的格式，比如电子邮件、必填字段和最小值长度。</p>
<p>当un format与钩子一起工作时，基于类的组件风格被抛弃，取而代之的是单功能组件。</p>
<p>Formik中的<code>initialValues</code>在这里转化为<code>initialData</code>——确保将每个对象属性与每个输入名称相匹配，以确保正确应用值。<code>handleSubmit</code>函数从Formik中丢失参数，只是接收值以便在提交事件中操作。</p>
<p>最后，没有内部的<code>render</code>函数，这意味着<code>&lt;Form&gt;</code>必须与其他组件混合。</p><div class="code-block code-block-54">
<hr/>
<h3>更多来自LogRocket的精彩文章:</h3>

<hr/></div>
<p>您还可以使用其他常见属性，如<code>placeholder</code>、<code>style</code>等。</p>
<h2>formik和uniform中的附加元素</h2>
<h3><strong>选择下拉菜单</strong></h3>
<p>让我们分析第二个组合框的例子，它是表单中非常常见的元素。</p>
<p>在Formik中，选择下拉菜单通常是这样的:</p>
<pre>&lt;Field as="select" name="color"&gt;
    &lt;option value="red"&gt;Red&lt;/option&gt;
    &lt;option value="green"&gt;Green&lt;/option&gt;
    &lt;option value="blue"&gt;Blue&lt;/option&gt;
&lt;/Field&gt;
</pre>
<p>不复杂。另一方面，un format与react-select合作来实现这一目标。下面是一个如何将外部dropdown组件与Unform结合的示例:</p>
<pre>import React, { useRef, useEffect } from 'react';
import ReactSelect, {
  OptionTypeBase,
  Props as SelectProps,
} from 'react-select';
import { useField } from '@unform/core';

interface Props extends SelectProps&lt;OptionTypeBase&gt; {
  name: string;
}

export default function Select({ name, ...rest }: Props) {
  const selectRef = useRef(null);
  const { fieldName, defaultValue, registerField, error } = useField(name);

  useEffect(() =&gt; {
    registerField({
      name: fieldName,
      ref: selectRef.current,
      getValue: (ref: any) =&gt; {
        if (rest.isMulti) {
          if (!ref.state.value) {
            return [];
          }
          return ref.state.value.map((option: OptionTypeBase) =&gt; option.value);
        }
        if (!ref.state.value) {
          return '';
        }
        return ref.state.value.value;
      },
    });
  }, [fieldName, registerField, rest.isMulti]);

  return (
    &lt;ReactSelect
      defaultValue={defaultValue}
      ref={selectRef}
      classNamePrefix="react-select"
      {...rest}
    /&gt;
  );
};</pre>
<p>特别注意连接字段与其对应字段<code>ReactSelect</code>的<code>useRef</code>函数。</p>
<h3><strong>嵌套元素</strong></h3>
<p>当涉及到多个嵌套元素时，没有一个库能够提供完全可适应的工作解决方案。</p>
<p>Formik有一个非常方便的对象叫做<code><a href="https://jaredpalmer.com/formik/docs/api/fieldarray" target="_blank" rel="noopener noreferrer">&lt;FieldArray&gt;</a></code>，它有助于常见的数组/列表操作:</p>
<pre>let countries = ['andorra', 'argentina', 'aruba'];

&lt;Form&gt;
   &lt;FieldArray
      name="countries"
      render={arrayHelpers =&gt; (
          // defining your form, loop through `countries`
     )}
    /&gt;
&lt;/Form&gt;</pre>
<p>它还有一堆熟悉的功能，比如<code>pop</code>、<code>replace</code>、<code>push</code>、<code>insert</code>，以及其他自动注入的<code>arrayHelpers</code>来帮助操作物品。</p>
<p>然而，每当您想要嵌套条目、应用验证或者以更接近实体模型的方式组织表单时，Formik就缺少选项。</p>
<p>un format有一个有趣的处理嵌套对象的机制。以下面的代码为例:</p>
<pre>import React from 'react';
import { Form, Input, Scope } from '@rocketseat/unform';

function App() {
  function handleSubmit(values) {
    console.log(values);
  }

  return (
    &lt;Form onSubmit={handleSubmit}&gt;
      &lt;Input name="name" /&gt;

      &lt;Scope path="address"&gt;
        &lt;Input name="country" /&gt;
        &lt;Input name="zipCode" /&gt;
      &lt;/Scope&gt;

      &lt;button type="submit"&gt;Submit&lt;/button&gt;
    &lt;/Form&gt;
  );
}</pre>
<p><code>Scope</code>是一个未格式化的组件，它标记了嵌套元素的根。这只是为了标记，不包含任何值。</p>
<p>当您提交表单时，您的<code>values</code>对象将如下所示:</p>
<pre>{
   name: '',
   address: { country: "", zipCode: "" }
}</pre>
<p>每当您更新状态的值时，它将反映在您的表单域中。</p>
<h3>结论</h3>
<p>在Formik和Unform之间进行选择时，最重要的是找到最适合您项目目的的产品。</p>
<p>Unform是一个很棒的库，特别是因为它是轻量级的、可执行的，并且足够灵活，允许与其他库集成。您可能希望在表单中使用第三方组件，比如<a href="https://github.com/JedWatson/react-select" target="_blank" rel="noopener noreferrer"> react-select </a>和<a href="https://github.com/Hacker0x01/react-datepicker/" target="_blank" rel="noopener noreferrer"> react-datepicker </a>。使用un format，这很容易做到。</p>
<p>去吧，你自己试试。迁移一些组件，或者从头开始创建组件。利用React钩子获得更简洁的代码，并测试嵌套元素的不同字段组织。</p>
<p>别忘了查看<a href="https://github.com/Rocketseat/unform" target="_blank" rel="noopener noreferrer">官方文档</a>了解更多关于其他元素的信息，以及每个元素的示例。</p><div class="code-block code-block-17">
<div class="blog-plug inline-plug react-plug" vwo-el-id="26283398190">
<h2 vwo-el-id="41600691720">使用LogRocket消除传统反应错误报告的噪音</h2>
<a href="https://lp.logrocket.com/blg/react-signup-issue-free" target="_blank" vwo-el-id="19356441070">LogRocket
</a><p>是一款React analytics解决方案，可保护您免受数百个误报错误警报的影响，只针对少数真正重要的项目。LogRocket告诉您React应用程序中实际影响用户的最具影响力的bug和UX问题。</p><a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="19356441380">
<img class="first-react-image alignnone size-full wp-image-46 jetpack-lazy-image jetpack-lazy-image--handled" src="../Images/f300c244a1a1cf916df8b4cb02bec6c6.png" vwo-el-id="18272717540" data-lazy-loaded="1" data-original-src="https://files.readme.io/27c94e7-Image_2017-06-05_at_9.46.04_PM.png"/>
</a>
<a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="19356441690">
<img class="second-react-image alignnone size-full wp-image-46 jetpack-lazy-image jetpack-lazy-image--handled" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" vwo-el-id="30720362350" data-lazy-loaded="1" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/>
</a>
<a href="https://lp.logrocket.com/blg/react-signup-issue-free" target="_blank" rel="noopener noreferrer" vwo-el-id="35866400580">LogRocket
</a><p>自动聚合客户端错误、反应错误边界、还原状态、缓慢的组件加载时间、JS异常、前端性能指标和用户交互。然后，LogRocket使用机器学习来通知您影响大多数用户的最具影响力的问题，并提供您修复它所需的上下文。</p><p vwo-el-id="28675661060">关注重要的React bug—<a class="signup" href="https://lp.logrocket.com/blg/react-signup-issue-free" target="_blank" rel="noopener noreferrer" vwo-el-id="40093418840">今天就试试LogRocket】。</a></p>
</div></div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
<html>
<head>
<title>Accessing previous props or state with React Hooks - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>用React钩子访问以前的道具或状态</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/accessing-previous-props-state-react-hooks/#0001-01-01">https://blog.logrocket.com/accessing-previous-props-state-react-hooks/#0001-01-01</a></blockquote><div><article class="article-post">
<p><strong> <em>编者按</em> </strong>:本帖最后更新于2022年1月28日，包含第三方库的状态管理。</p>
<p>在使用React钩子时，从功能组件中访问以前的属性或状态是您可能会遇到的看似简单的问题之一。虽然目前还没有现成的React钩子来做这件事，但是您可以通过利用React中的<code>useRef</code>、<code>useState</code>、<code>usePrevious</code>和<code>useEffect</code>钩子，从功能组件中手动检索以前的状态或道具。在这篇文章中，我们将学习如何。</p>
<p><img data-attachment-id="90017" data-permalink="https://blog.logrocket.com/accessing-previous-props-state-react-hooks/react-hook-previous-diagram/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/01/react-hook-previous-diagram.png" data-orig-size="730,410" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="react-hook-previous-diagram" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/01/react-hook-previous-diagram-300x168.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/01/react-hook-previous-diagram.png" decoding="async" class="aligncenter wp-image-90017 size-full jetpack-lazy-image" src="../Images/690dd12a44132a0a9e86f52a6bd60d97.png" alt="React Hook Previous Diagram" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2020/01/react-hook-previous-diagram.png 730w, https://blog.logrocket.com/wp-content/uploads/2020/01/react-hook-previous-diagram-300x168.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2020/01/react-hook-previous-diagram.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/01/react-hook-previous-diagram.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="90017" data-permalink="https://blog.logrocket.com/accessing-previous-props-state-react-hooks/react-hook-previous-diagram/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/01/react-hook-previous-diagram.png" data-orig-size="730,410" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="react-hook-previous-diagram" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/01/react-hook-previous-diagram-300x168.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/01/react-hook-previous-diagram.png" decoding="async" loading="lazy" class="aligncenter wp-image-90017 size-full" src="../Images/690dd12a44132a0a9e86f52a6bd60d97.png" alt="React Hook Previous Diagram" srcset="https://blog.logrocket.com/wp-content/uploads/2020/01/react-hook-previous-diagram.png 730w, https://blog.logrocket.com/wp-content/uploads/2020/01/react-hook-previous-diagram-300x168.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/01/react-hook-previous-diagram.png"/></noscript>
<h3>目录</h3>

<h2 id="example-getting-previous-props-state">示例:获取上一个道具或状态</h2>
<p>如果你查看React官方文档，<a href="https://reactjs.org/docs/hooks-faq.html#how-to-get-the-previous-props-or-state">你会看到下面的例子</a>，其中<code>Counter</code>代表一个简单的计数器组件:</p>
<pre>function Counter() {
  const [count, setCount] = useState(0);
//the useRef Hook allows you to persist data between renders
  const prevCountRef = useRef();
  useEffect(() =&gt; {
    //assign the ref's current value to the count Hook
    prevCountRef.current = count;
  }, [count]); //run this code when the value of count changes
  return (
    &lt;h1&gt;
      Now: {count}, before: {prevCountRef.current}
      {/*Increment  */}
      &lt;button onClick={() =&gt; setCount((count) =&gt; count + 1)}&gt;Increment&lt;/button&gt;
    &lt;/h1&gt;
  );
}
</pre>
<p>上面的代码生成以下输出:</p>
<p><img data-attachment-id="90019" data-permalink="https://blog.logrocket.com/accessing-previous-props-state-react-hooks/react-sample-get-previous-props/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/01/react-sample-get-previous-props.gif" data-orig-size="514,368" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="react-sample-get-previous-props" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/01/react-sample-get-previous-props-300x215.gif" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/01/react-sample-get-previous-props.gif" decoding="async" class="aligncenter wp-image-90019 size-full jetpack-lazy-image" src="../Images/849d4d24dcee988275f5ebdbc6d664ca.png" alt="React Sample Get Previous Props" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2020/01/react-sample-get-previous-props.gif?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/01/react-sample-get-previous-props.gif"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="90019" data-permalink="https://blog.logrocket.com/accessing-previous-props-state-react-hooks/react-sample-get-previous-props/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/01/react-sample-get-previous-props.gif" data-orig-size="514,368" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="react-sample-get-previous-props" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/01/react-sample-get-previous-props-300x215.gif" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/01/react-sample-get-previous-props.gif" decoding="async" loading="lazy" class="aligncenter wp-image-90019 size-full" src="../Images/849d4d24dcee988275f5ebdbc6d664ca.png" alt="React Sample Get Previous Props" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/01/react-sample-get-previous-props.gif"/></noscript>
<h2 id="custom-hook-useprevious-hook">用<code>usePrevious</code>钩子定制钩子</h2>
<p>但是，如果您正在寻找一个更快的解决方案，您可以构建以下自定义挂钩:</p>
<pre>function usePrevious(value) {
  const ref = useRef();
  useEffect(() =&gt; {
    ref.current = value; //assign the value of ref to the argument
  },[value]); //this code will run when the value of 'value' changes
  return ref.current; //in the end, return the current ref value.
}
export default usePrevious;
</pre>
<p>要在应用程序中使用自定义挂钩，请编写以下代码:</p>
<pre>function Counter() {
  const [count, setCount] = useState(0);
  // 👇 look here
  const prevCount = usePrevious(count)

  return &lt;h1&gt; Now: {count}, before: {prevCount} &lt;/h1&gt;;
}
</pre>
<p><img data-attachment-id="90050" data-permalink="https://blog.logrocket.com/accessing-previous-props-state-react-hooks/use-custom-react-hook-app/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/01/use-custom-react-hook-app.gif" data-orig-size="514,368" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="use-custom-react-hook-app" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/01/use-custom-react-hook-app-300x215.gif" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/01/use-custom-react-hook-app.gif" decoding="async" class="aligncenter wp-image-90050 size-full jetpack-lazy-image" src="../Images/b2b90660aaf34482c2fad6397372499e.png" alt="Use Custom React Hook App" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2020/01/use-custom-react-hook-app.gif?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/01/use-custom-react-hook-app.gif"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="90050" data-permalink="https://blog.logrocket.com/accessing-previous-props-state-react-hooks/use-custom-react-hook-app/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/01/use-custom-react-hook-app.gif" data-orig-size="514,368" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="use-custom-react-hook-app" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/01/use-custom-react-hook-app-300x215.gif" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/01/use-custom-react-hook-app.gif" decoding="async" loading="lazy" class="aligncenter wp-image-90050 size-full" src="../Images/b2b90660aaf34482c2fad6397372499e.png" alt="Use Custom React Hook App" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/01/use-custom-react-hook-app.gif"/></noscript>
<p>虽然这个例子看起来很简单，但是你真的能解释一下<code>usePrevious</code>钩子是如何工作的吗？让我们清楚地了解一下定制钩子中发生了什么，以及先前的值是如何保留的。</p>
<h2 id="useref-depth-overlooked-react-hook">深度:一个被忽视的反应钩</h2>
<p>我每天都用钩子工作，无论是个人项目还是专业的工作场所项目。根据我的经验，<a href="https://blog.logrocket.com/usestate-vs-useref/">我发现很少有人真正理解并利用<code>useRef</code>钩子</a>。</p>
<p>除了擅长处理DOM refs之外，<code>useRef</code> Hook还是在函数组件中实现类实例变量的完美替代品。此外，它会记住UI呈现之间的数据，允许开发人员访问以前被覆盖的值。</p>
<p>考虑下面的类组件示例:</p>
<pre>// class component 
class Count extends React.Component {

   constructor() {
     this.specialVariable = "SPECIAL_VARIABLE"
   }

  render() {
    return null
  }
}
</pre>
<p>每个实例化的<code>Count</code>类都有自己的<code>specialVariable</code>实例变量。<code>useRef</code>钩子可以用一个更有趣的特性来模拟这种行为:</p>
<pre>// functional component 

function Count() {
  const specialVariable = useRef("SPECIAL_VARAIBLE"); //store initial value into the specialVariable Hook. 
  return null
}
</pre>
<p><code>useRef</code>钩子取一个要存储的初始值，即<code>useRef("INITIAL_VALUE")</code>，返回一个当前属性为<code>{current: "INITIAL_VALUE"}</code>的对象。</p>
<p>最初传递给<code>useRef</code>钩子的任何值都被保存到<code>ref</code>对象的<code>current</code>属性中:</p>
<pre>function Count() {
  const specialVariable = useRef("SPECIAL_VARAIBLE");
  // specialVariable resolves to {current: "SPECIAL_VARIABLE"}
  console.log(specialVariable); //for debugging purposes, log out its value
  return null;
}
</pre>
<p><img data-attachment-id="90048" data-permalink="https://blog.logrocket.com/accessing-previous-props-state-react-hooks/value-passed-useref-hook-saved/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/01/value-passed-useref-hook-saved.png" data-orig-size="469,166" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="value-passed-useref-hook-saved" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/01/value-passed-useref-hook-saved-300x106.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/01/value-passed-useref-hook-saved.png" decoding="async" class="aligncenter wp-image-90048 size-full jetpack-lazy-image" src="../Images/99920a87d6f6c6d007d6e6c326950425.png" alt="Value Passed Useref Hook Saved" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2020/01/value-passed-useref-hook-saved.png 469w, https://blog.logrocket.com/wp-content/uploads/2020/01/value-passed-useref-hook-saved-300x106.png 300w" data-lazy-sizes="(max-width: 469px) 100vw, 469px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2020/01/value-passed-useref-hook-saved.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/01/value-passed-useref-hook-saved.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="90048" data-permalink="https://blog.logrocket.com/accessing-previous-props-state-react-hooks/value-passed-useref-hook-saved/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/01/value-passed-useref-hook-saved.png" data-orig-size="469,166" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="value-passed-useref-hook-saved" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/01/value-passed-useref-hook-saved-300x106.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/01/value-passed-useref-hook-saved.png" decoding="async" loading="lazy" class="aligncenter wp-image-90048 size-full" src="../Images/99920a87d6f6c6d007d6e6c326950425.png" alt="Value Passed Useref Hook Saved" srcset="https://blog.logrocket.com/wp-content/uploads/2020/01/value-passed-useref-hook-saved.png 469w, https://blog.logrocket.com/wp-content/uploads/2020/01/value-passed-useref-hook-saved-300x106.png 300w" sizes="(max-width: 469px) 100vw, 469px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/01/value-passed-useref-hook-saved.png"/></noscript>
<p>与普通变量不同，当重新呈现<code>Count</code>组件时，不会重新计算<code>specialVariable</code> ref对象。使用<code>useRef</code>钩子，保存在<code>ref</code>对象中的值在重新渲染时保持不变。该值既不会丢失，也不会重新计算；它保持不变。</p>
<h2 id="retrieving-previous-props-state-useref">用<code>useRef</code>检索以前的道具和状态</h2>
<p>值得一提的是，更新<code>ref</code>对象的唯一方法是直接设置当前属性的值，即<code>specialVariable.current = "NEW_SPECIAL_VARIABLE</code>。为什么这个解释很重要？</p>
<p>为了理解发生了什么，让我们一步一步地执行前面提到的检索以前的道具和状态的解决方案:</p>
<pre>// custom hook for getting previous value 
function usePrevious(value) {
  const ref = useRef();
  useEffect(() =&gt; {
    ref.current = value;
  },[value]);
  return ref.current;
}

// the App where the hook is used 
function Counter() {
  const [count, setCount] = useState(0);
  // 👇 look here
  const prevCount = usePrevious(count)

  return &lt;h1&gt;Now: {count}, before: {prevCount}&lt;/h1&gt;;
}

// How the App is rendered 
&lt;Counter /&gt;
</pre>
<p>当<code>Counter</code>应用程序的渲染过程开始时，首先调用<code>useState</code>钩子，并设置变量<code>count</code>和<code>setCount</code>。注意<code>count</code>现在是<code>0</code>:</p>
<p><img data-attachment-id="90040" data-permalink="https://blog.logrocket.com/accessing-previous-props-state-react-hooks/usestate-hook-invoked/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/01/useState-hook-invoked.png" data-orig-size="730,410" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="useState-hook-invoked" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/01/useState-hook-invoked-300x168.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/01/useState-hook-invoked.png" decoding="async" class="aligncenter wp-image-90040 size-full jetpack-lazy-image" src="../Images/3e4864e97c36d8d1fabf88332fcdc852.png" alt="useState Hook Invoked" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2020/01/useState-hook-invoked.png 730w, https://blog.logrocket.com/wp-content/uploads/2020/01/useState-hook-invoked-300x168.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2020/01/useState-hook-invoked.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/01/useState-hook-invoked.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="90040" data-permalink="https://blog.logrocket.com/accessing-previous-props-state-react-hooks/usestate-hook-invoked/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/01/useState-hook-invoked.png" data-orig-size="730,410" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="useState-hook-invoked" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/01/useState-hook-invoked-300x168.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/01/useState-hook-invoked.png" decoding="async" loading="lazy" class="aligncenter wp-image-90040 size-full" src="../Images/3e4864e97c36d8d1fabf88332fcdc852.png" alt="useState Hook Invoked" srcset="https://blog.logrocket.com/wp-content/uploads/2020/01/useState-hook-invoked.png 730w, https://blog.logrocket.com/wp-content/uploads/2020/01/useState-hook-invoked-300x168.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/01/useState-hook-invoked.png"/></noscript>
<p>之后，将执行下一行。用计数状态变量<code>0</code>的当前值调用<code>usePrevious</code>钩子:</p>
<p><img data-attachment-id="90038" data-permalink="https://blog.logrocket.com/accessing-previous-props-state-react-hooks/useprevious-hook-invoked/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/01/useprevious-hook-invoked.png" data-orig-size="730,410" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="useprevious-hook-invoked" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/01/useprevious-hook-invoked-300x168.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/01/useprevious-hook-invoked.png" decoding="async" class="aligncenter wp-image-90038 size-full jetpack-lazy-image" src="../Images/4904ee1ba1ec55c5d6d53c30ff0cd86a.png" alt="Useprevious Hook Invoked" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2020/01/useprevious-hook-invoked.png 730w, https://blog.logrocket.com/wp-content/uploads/2020/01/useprevious-hook-invoked-300x168.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2020/01/useprevious-hook-invoked.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/01/useprevious-hook-invoked.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="90038" data-permalink="https://blog.logrocket.com/accessing-previous-props-state-react-hooks/useprevious-hook-invoked/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/01/useprevious-hook-invoked.png" data-orig-size="730,410" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="useprevious-hook-invoked" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/01/useprevious-hook-invoked-300x168.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/01/useprevious-hook-invoked.png" decoding="async" loading="lazy" class="aligncenter wp-image-90038 size-full" src="../Images/4904ee1ba1ec55c5d6d53c30ff0cd86a.png" alt="Useprevious Hook Invoked" srcset="https://blog.logrocket.com/wp-content/uploads/2020/01/useprevious-hook-invoked.png 730w, https://blog.logrocket.com/wp-content/uploads/2020/01/useprevious-hook-invoked-300x168.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/01/useprevious-hook-invoked.png"/></noscript>
<p>在调用<code>usePrevious</code>钩子时，React创建一个新的<code>useRef</code>实例:</p>
<p><img data-attachment-id="90036" data-permalink="https://blog.logrocket.com/accessing-previous-props-state-react-hooks/react-new-useref-instance/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/01/react-new-useref-instance.png" data-orig-size="730,411" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="react-new-useref-instance" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/01/react-new-useref-instance-300x169.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/01/react-new-useref-instance.png" decoding="async" class="aligncenter wp-image-90036 size-full jetpack-lazy-image" src="../Images/4ffb33b85eea97381b9ded7f297d8910.png" alt="React New Useref Instance" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2020/01/react-new-useref-instance.png 730w, https://blog.logrocket.com/wp-content/uploads/2020/01/react-new-useref-instance-300x169.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2020/01/react-new-useref-instance.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/01/react-new-useref-instance.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="90036" data-permalink="https://blog.logrocket.com/accessing-previous-props-state-react-hooks/react-new-useref-instance/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/01/react-new-useref-instance.png" data-orig-size="730,411" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="react-new-useref-instance" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/01/react-new-useref-instance-300x169.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/01/react-new-useref-instance.png" decoding="async" loading="lazy" class="aligncenter wp-image-90036 size-full" src="../Images/4ffb33b85eea97381b9ded7f297d8910.png" alt="React New Useref Instance" srcset="https://blog.logrocket.com/wp-content/uploads/2020/01/react-new-useref-instance.png 730w, https://blog.logrocket.com/wp-content/uploads/2020/01/react-new-useref-instance-300x169.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/01/react-new-useref-instance.png"/></noscript>
<p>这个钩子的初始值是<code>undefined</code>。控制台返回<code>{current: undefined}</code>，因为当前数据不存在。</p>
<p>下一步是大多数人犯错的地方。React不执行<code>useEffect</code>调用，而是返回定制钩子的当前值:</p>
<p><img data-attachment-id="90033" data-permalink="https://blog.logrocket.com/accessing-previous-props-state-react-hooks/current-value-custom-hook-returned/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/01/current-value-custom-hook-returned.png" data-orig-size="730,411" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="current-value-custom-hook-returned" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/01/current-value-custom-hook-returned-300x169.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/01/current-value-custom-hook-returned.png" decoding="async" class="aligncenter wp-image-90033 size-full jetpack-lazy-image" src="../Images/a10c64bcb47737c755662a9dc46277d8.png" alt="Current Value Custom Hook Returned" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2020/01/current-value-custom-hook-returned.png 730w, https://blog.logrocket.com/wp-content/uploads/2020/01/current-value-custom-hook-returned-300x169.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2020/01/current-value-custom-hook-returned.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/01/current-value-custom-hook-returned.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="90033" data-permalink="https://blog.logrocket.com/accessing-previous-props-state-react-hooks/current-value-custom-hook-returned/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/01/current-value-custom-hook-returned.png" data-orig-size="730,411" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="current-value-custom-hook-returned" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/01/current-value-custom-hook-returned-300x169.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/01/current-value-custom-hook-returned.png" decoding="async" loading="lazy" class="aligncenter wp-image-90033 size-full" src="../Images/a10c64bcb47737c755662a9dc46277d8.png" alt="Current Value Custom Hook Returned" srcset="https://blog.logrocket.com/wp-content/uploads/2020/01/current-value-custom-hook-returned.png 730w, https://blog.logrocket.com/wp-content/uploads/2020/01/current-value-custom-hook-returned-300x169.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/01/current-value-custom-hook-returned.png"/></noscript>
<p>只有在调用钩子的组件被渲染后，钩子才会被调用。本质上，必须首先执行组件的返回值。</p>
<p>接下来，组件内的执行继续。这一次，<code>prevCount</code>变量保存值<code>undefined</code>:</p>
<p><img data-attachment-id="90030" data-permalink="https://blog.logrocket.com/accessing-previous-props-state-react-hooks/prevcount-variable-value-undefined/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/01/prevcount-variable-value-undefined.png" data-orig-size="730,410" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="prevcount-variable-value-undefined" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/01/prevcount-variable-value-undefined-300x168.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/01/prevcount-variable-value-undefined.png" decoding="async" class="aligncenter wp-image-90030 size-full jetpack-lazy-image" src="../Images/ef41b05d8f30e9ac9db7d6e4280a1afc.png" alt="Prevcount Variable Value Undefined" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2020/01/prevcount-variable-value-undefined.png 730w, https://blog.logrocket.com/wp-content/uploads/2020/01/prevcount-variable-value-undefined-300x168.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2020/01/prevcount-variable-value-undefined.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/01/prevcount-variable-value-undefined.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="90030" data-permalink="https://blog.logrocket.com/accessing-previous-props-state-react-hooks/prevcount-variable-value-undefined/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/01/prevcount-variable-value-undefined.png" data-orig-size="730,410" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="prevcount-variable-value-undefined" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/01/prevcount-variable-value-undefined-300x168.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/01/prevcount-variable-value-undefined.png" decoding="async" loading="lazy" class="aligncenter wp-image-90030 size-full" src="../Images/ef41b05d8f30e9ac9db7d6e4280a1afc.png" alt="Prevcount Variable Value Undefined" srcset="https://blog.logrocket.com/wp-content/uploads/2020/01/prevcount-variable-value-undefined.png 730w, https://blog.logrocket.com/wp-content/uploads/2020/01/prevcount-variable-value-undefined-300x168.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/01/prevcount-variable-value-undefined.png"/></noscript>
<p>组件的返回值被计算:</p>
<p><img data-attachment-id="90028" data-permalink="https://blog.logrocket.com/accessing-previous-props-state-react-hooks/component-return-value-evaluated/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/01/component-return-value-evaluated.png" data-orig-size="730,410" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="component-return-value-evaluated" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/01/component-return-value-evaluated-300x168.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/01/component-return-value-evaluated.png" decoding="async" class="aligncenter wp-image-90028 size-full jetpack-lazy-image" src="../Images/a32a31a170d10f310a73a3bad7fccc44.png" alt="Component Return Value Evaluated" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2020/01/component-return-value-evaluated.png 730w, https://blog.logrocket.com/wp-content/uploads/2020/01/component-return-value-evaluated-300x168.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2020/01/component-return-value-evaluated.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/01/component-return-value-evaluated.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="90028" data-permalink="https://blog.logrocket.com/accessing-previous-props-state-react-hooks/component-return-value-evaluated/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/01/component-return-value-evaluated.png" data-orig-size="730,410" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="component-return-value-evaluated" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/01/component-return-value-evaluated-300x168.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/01/component-return-value-evaluated.png" decoding="async" loading="lazy" class="aligncenter wp-image-90028 size-full" src="../Images/a32a31a170d10f310a73a3bad7fccc44.png" alt="Component Return Value Evaluated" srcset="https://blog.logrocket.com/wp-content/uploads/2020/01/component-return-value-evaluated.png 730w, https://blog.logrocket.com/wp-content/uploads/2020/01/component-return-value-evaluated-300x168.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/01/component-return-value-evaluated.png"/></noscript>
<p>该过程将<code>&lt;h1&gt;Now: {count}, before: {prevCount}&lt;/h1&gt;</code>返回到屏幕，其中<code>count</code>和<code>prevCount</code>分别是<code>0</code>和<code>undefined</code>。</p>
<p>为了避免阻止浏览器绘制DOM变化，现在异步调用<code>usePrevious</code>钩子中的<code>useEffect</code>调用。<code>useEffect</code>在功能组件渲染后被调用:</p>
<p><img data-attachment-id="90025" data-permalink="https://blog.logrocket.com/accessing-previous-props-state-react-hooks/useeffect-invoked-functional-component-render/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/01/useeffect-invoked-functional-component-render.png" data-orig-size="730,411" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="useeffect-invoked-functional-component-render" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/01/useeffect-invoked-functional-component-render-300x169.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/01/useeffect-invoked-functional-component-render.png" decoding="async" class="aligncenter wp-image-90025 size-full jetpack-lazy-image" src="../Images/7b6effb812494d14e4d3a7908447c805.png" alt="Useeffect Invoked Functional Component Render" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2020/01/useeffect-invoked-functional-component-render.png 730w, https://blog.logrocket.com/wp-content/uploads/2020/01/useeffect-invoked-functional-component-render-300x169.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2020/01/useeffect-invoked-functional-component-render.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/01/useeffect-invoked-functional-component-render.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="90025" data-permalink="https://blog.logrocket.com/accessing-previous-props-state-react-hooks/useeffect-invoked-functional-component-render/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/01/useeffect-invoked-functional-component-render.png" data-orig-size="730,411" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="useeffect-invoked-functional-component-render" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/01/useeffect-invoked-functional-component-render-300x169.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/01/useeffect-invoked-functional-component-render.png" decoding="async" loading="lazy" class="aligncenter wp-image-90025 size-full" src="../Images/7b6effb812494d14e4d3a7908447c805.png" alt="Useeffect Invoked Functional Component Render" srcset="https://blog.logrocket.com/wp-content/uploads/2020/01/useeffect-invoked-functional-component-render.png 730w, https://blog.logrocket.com/wp-content/uploads/2020/01/useeffect-invoked-functional-component-render-300x169.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/01/useeffect-invoked-functional-component-render.png"/></noscript>
<p>在效果函数中，我们有以下内容:</p>
<pre>useEffect(() =&gt; {
    ref.current = value;
},[value]);
</pre>
<p><code>useEffect</code>函数中的代码行将<code>ref</code>对象的当前属性更新为值。<code>value</code>现在表示自定义钩子最初被调用时的名称。</p>
<p>在这种情况下，值为<code>0</code>。在这个电流流中，记住<code>usePrevious</code>只被用<code>0</code>的初始值调用过一次。</p>
<p><img data-attachment-id="90023" data-permalink="https://blog.logrocket.com/accessing-previous-props-state-react-hooks/useprevious-called-once-value-0/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/01/useprevious-called-once-value-0.png" data-orig-size="730,411" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="useprevious-called-once-value-0" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/01/useprevious-called-once-value-0-300x169.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/01/useprevious-called-once-value-0.png" decoding="async" class="aligncenter wp-image-90023 size-full jetpack-lazy-image" src="../Images/c4289f19c90d8df417d0c3229a23a238.png" alt="Useprevious Called Once Value" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2020/01/useprevious-called-once-value-0.png 730w, https://blog.logrocket.com/wp-content/uploads/2020/01/useprevious-called-once-value-0-300x169.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2020/01/useprevious-called-once-value-0.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/01/useprevious-called-once-value-0.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="90023" data-permalink="https://blog.logrocket.com/accessing-previous-props-state-react-hooks/useprevious-called-once-value-0/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/01/useprevious-called-once-value-0.png" data-orig-size="730,411" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="useprevious-called-once-value-0" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/01/useprevious-called-once-value-0-300x169.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/01/useprevious-called-once-value-0.png" decoding="async" loading="lazy" class="aligncenter wp-image-90023 size-full" src="../Images/c4289f19c90d8df417d0c3229a23a238.png" alt="Useprevious Called Once Value" srcset="https://blog.logrocket.com/wp-content/uploads/2020/01/useprevious-called-once-value-0.png 730w, https://blog.logrocket.com/wp-content/uploads/2020/01/useprevious-called-once-value-0-300x169.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/01/useprevious-called-once-value-0.png"/></noscript>
<p>现在，ref保存值<code>0</code>。当应用程序中的<code>count state</code>变量从<code>0</code>更新为<code>1</code>，或者更新为新的计数时，应用程序将再次运行这段代码。</p>
<p>用新的状态值<code>1</code>调用<code>usePrevious</code>钩子。然后，计算return语句，返回<code>ref.current</code>，这将是<code>0</code>，而不是<code>1</code>，因为ref对象还没有更新。</p>
<p>这里，<code>ref.current</code>是在<code>useEffect</code>被触发之前存储的前一个值，或者是<code>0</code>。组件的<code>return</code>语句与先前成功返回的值相等。</p>
<p>只有在渲染之后，<code>usePrevious</code>钩子中的<code>useEffect</code>调用才会用新值<code>1</code>更新。这个循环继续下去，通过这种方式，您总是可以将之前的值传递给自定义钩子，<code>usePrevious</code>。</p>
<h3 id="why-works">为什么会这样</h3>
<p>要理解为什么我们可以以这种方式访问以前的属性或状态，您必须记住以下几点:</p>
<ol>
<li><code>ref</code>对象将总是返回保存在<code>ref.current</code>中的相同值，除非它被显式更新</li>
<li><code>useEffect</code>仅在组件使用之前的值呈现后调用。只有在渲染完成后，ref对象才会在<code>useEffect</code>内更新</li>
</ol>
<p>通过利用这两个事实，您可以轻松地自行复制这一功能。</p>
<h2 id="using-zustand">使用Zustand</h2>
<p>如果你想使用第三方库进行简单的状态管理，我推荐使用<a href="https://github.com/pmndrs/zustand"> Zustand API </a>。<a href="https://blog.logrocket.com/using-zustand-to-simplify-state-management/"> Zustand </a> <a href="https://blog.logrocket.com/using-zustand-to-simplify-state-management/">允许你创建订阅者</a>，这些函数让你获得你的状态变量的先前和当前值。</p>
<p>首先，创建一个商店及其订户，如下所示:</p>
<pre>import create from "zustand";
const useStore = create((set) =&gt; ({
  dollars: 0,
  increaseIncome: () =&gt; set((state) =&gt; ({ dollars: state.dollars + 1 }))
}));
//create a subscriber
const unsubscribe = useStore.subscribe((newValue, oldValue) =&gt; {
  console.log(
    "new Value " + newValue.dollars + ", old Value:" + oldValue.dollars
  );
});
</pre>
<p>首先，我们声明了一个名为<code>dollars</code>的全局变量。它的初始值将是<code>0</code>。然后，我们创建了一个名为<code>increaseIncome</code>的函数。如果用户执行该方法，程序将增加<code>dollars</code>状态。</p>
<p>然后我们编写了一个订户函数，它将记录变量<code>dollars</code>的当前值和旧值。要实际使用该存储，请编写以下代码:</p>
<pre>export default function App() {
  //extract our state and functions
  const dollars = useStore((state) =&gt; state.dollars);
  const increaseIncome = useStore((state) =&gt; state.increaseIncome);
  return (
    &lt;div&gt;
      &lt;h1&gt; Current: ${dollars} &lt;/h1&gt;
      {/*When clicked, execute the 'increaseIncome' function */}
      &lt;button onClick={() =&gt; increaseIncome()}&gt;Increment &lt;/button&gt;
    &lt;/div&gt;
  );
</pre>
<p>使用上面的代码，我们从我们的自定义存储中获得了<code>dollars</code>变量和<code>increaseIncome</code>函数:</p>
<p><img data-attachment-id="90021" data-permalink="https://blog.logrocket.com/accessing-previous-props-state-react-hooks/zustand-library-state-management/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/01/zustand-library-state-management.gif" data-orig-size="514,559" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="zustand-library-state-management" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/01/zustand-library-state-management-276x300.gif" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/01/zustand-library-state-management.gif" decoding="async" class="aligncenter wp-image-90021 size-full jetpack-lazy-image" src="../Images/bb315aadc1bbdaa4eb169be98de0a8fc.png" alt="Zustand Library State Management" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2020/01/zustand-library-state-management.gif?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/01/zustand-library-state-management.gif"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="90021" data-permalink="https://blog.logrocket.com/accessing-previous-props-state-react-hooks/zustand-library-state-management/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/01/zustand-library-state-management.gif" data-orig-size="514,559" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="zustand-library-state-management" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/01/zustand-library-state-management-276x300.gif" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/01/zustand-library-state-management.gif" decoding="async" loading="lazy" class="aligncenter wp-image-90021 size-full" src="../Images/bb315aadc1bbdaa4eb169be98de0a8fc.png" alt="Zustand Library State Management" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/01/zustand-library-state-management.gif"/></noscript>
<h2 id="conclusion">结论</h2>
<p>在本文中，我们学习了如何从React中的<code>useRef</code>、<code>useState</code>、<code>usePrevious</code>和<code>useEffect</code>钩子获取先前的值。</p>
<p>调用<code>useRef</code>返回的<code>ref</code>对象在功能组件的重新渲染中保持不变，这是一个非常强大的特性。它不需要你像在<code>useMemo</code>或<code>useCallback</code>中那样传递任何数组依赖就可以做到这一点。</p>
<p>当您将使用<code>useRef</code>作为实例变量的能力与<code>useEffect</code>钩子总是在父组件的return语句被求值之后被触发的事实结合起来时，您就有了一个无价的武器。</p><div class="code-block code-block-54">
<hr/>
<h3>更多来自LogRocket的精彩文章:</h3>

<hr/></div>
<p>感谢您的阅读，祝您编码愉快！</p>

<p class="clearfix"/>
 <p class="clearfix"/>
</article>

</div>    
</body>
</html>
<html>
<head>
<title>Understanding linear and binary search in JavaScript - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>在JavaScript - LogRocket博客中理解线性和二分搜索法</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/understanding-linear-and-binary-search-in-javascript/#0001-01-01">https://blog.logrocket.com/understanding-linear-and-binary-search-in-javascript/#0001-01-01</a></blockquote><div><article class="article-post">
<p>在本教程中，我将首先解释几个有助于我们理解这个概念的术语。</p>
<p>那么，首先:一个<strong>算法</strong>是给计算机执行特定任务的一组指令。</p>
<p>根据您需要执行的任务，算法会更快或更有效地执行它。工程师在为给定任务创建算法时会考虑这种权衡。</p>
<p>当我们讨论线性(简单)搜索和二分搜索法时，我们将会看到这是如何发生的。</p>
<h2>线性搜索</h2>
<p>有时称为简单搜索，线性搜索是一种在列表中查找元素的方法。</p>
<p>假设我们有一个数字列表——比方说，从1到1000——我们在寻找这些参数之间的一个数字。通过简单搜索，我们可以一个接一个地查找每个号码，直到找到匹配的号码。</p>
<p>这意味着——最坏的情况——我们必须查看整个列表，才能确定是否匹配。</p>
<p><img data-attachment-id="25632" data-permalink="https://blog.logrocket.com/understanding-linear-and-binary-search-in-javascript/linear-search/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/09/linear-search.gif" data-orig-size="730,300" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="linear-search" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/09/linear-search-300x123.gif" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/09/linear-search.gif" decoding="async" class="aligncenter wp-image-25632 size-full jetpack-lazy-image" src="../Images/7f13d6f08621c4ef4d3ddcb547c52012.png" alt="A gif displaying the process involved in linear searches." data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2020/09/linear-search.gif?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/09/linear-search.gif"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="25632" data-permalink="https://blog.logrocket.com/understanding-linear-and-binary-search-in-javascript/linear-search/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/09/linear-search.gif" data-orig-size="730,300" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="linear-search" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/09/linear-search-300x123.gif" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/09/linear-search.gif" decoding="async" loading="lazy" class="aligncenter wp-image-25632 size-full" src="../Images/7f13d6f08621c4ef4d3ddcb547c52012.png" alt="A gif displaying the process involved in linear searches." data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/09/linear-search.gif"/></noscript>
<p>下面是线性搜索的JavaScript实现:</p>
<pre>const linearSearch = (list, target) =&gt; {
  for (let i = 0; i &lt; list.length; i++){
    if( list[i] === target) return i
  }
  return null;
}

const list = [1,2,3,4,5,6,7,8,9,10]
let result = linearSearch(list, 8);
console.log(result); // 8
result = linearSearch(list, 19);
console.log(result); // null</pre>
<h2>二进位检索</h2>
<p>另一方面，二分搜索法是一个更好的搜索方式。</p>
<p>假设我们正在字典中寻找单词<code>Organic</code>的意思。</p>
<p>我们会从中间开始搜索，而不是从第一个以<code>A</code>开头的单词开始。我们可以这样做，因为我们知道字典中的单词是按字母顺序排列的<code>(sorted)</code>，当我们从中间开始时，我们就不需要搜索字典的特定一半。</p>
<p>这就是我们如何看待二分搜索法的同义词。</p>
<p>它接受一个排序列表并搜索一个目标。如果目标存在，就返回它。如果没有，则返回null。</p>
<p>因为它是一个排序列表，我们可以假设一些事情，并得出如下伪代码:</p>
<ul>
<li>从列表<code>middle</code>中的值开始，将其与目标值进行比较</li>
<li>如果目标值等于<code>middle</code>的值，则返回中间值</li>
<li>如果目标值小于<code>middle</code>的值，重新计算<code>middle</code>使其增加</li>
<li>如果目标值大于<code>middle</code>的值，重新计算<code>middle</code>使其减小</li>
<li>在仍有项目要搜索时继续此操作，或返回<code>null</code></li>
</ul>
<p>让我们用二分搜索法的JavaScript实现来看一下:</p>
<pre>const binarySearch = (list, target) =&gt; {
 let low = 0;
 let high = list.length - 1;
 let guess, mid;
 
 while (low &lt;= high) {
   mid = Math.floor((low + high) / 2);
   guess = list[mid];
   if (guess === target) return mid;
   if (guess &lt; target) low = mid + 1
   else high = mid - 1;
 }
 return null;
}</pre>
<p>本质上，当我们使用二分搜索法时，我们做的每一个猜测都排除了一半的列表。</p>
<p>假设我们有一个240，000个数字的列表，我们想要搜索一个特定的数字。最多，我们要经历18个步骤:</p>
<pre>240K  
→ 120k ------- 1
→ 60k -------- 2
→ 30 ---------- 3
→ 15k --------- 4
→ 7.5k -------- 5
→ 3.75k ------- 6
→ 1875 --------- 7
→ 938  --------- 8
→ 469 ---------- 9
→ 235 ---------- 10
→ 118 ---------- 11
→ 59 ----------- 12
→ 30 ----------- 13
→ 15 ----------- 14
→ 8 ------------ 15 
→ 4 ------------16
→ 2 ------------17
→ 1. ------- 18</pre>
<p>对于一个简单的搜索，我们将被要求通过名单上的每一个号码。</p>
<h2>大O符号</h2>
<p>大O符号是我们描述算法有多快或多复杂的一种方式。</p>
<p>当我们为一个特定的问题采用一种算法时，我们经常把它作为一种工具来理解可用的权衡。</p>
<p>它的名字来源于通常用对数表示的运算次数前的O。</p>
<p>对数可以被认为是指数——也就是说，一个数乘以多少才能得到另一个数，等等。</p>
<p><img data-attachment-id="25634" data-permalink="https://blog.logrocket.com/understanding-linear-and-binary-search-in-javascript/log/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/09/log.png" data-orig-size="284,174" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="log" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/09/log.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/09/log.png" decoding="async" class="aligncenter wp-image-25634 jetpack-lazy-image" src="../Images/47a49bd10ce53e5822d808a0d7134686.png" alt="An illustrated example of the exponents involved in calculating logs." data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2020/09/log.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/09/log.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="25634" data-permalink="https://blog.logrocket.com/understanding-linear-and-binary-search-in-javascript/log/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/09/log.png" data-orig-size="284,174" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="log" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/09/log.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/09/log.png" decoding="async" loading="lazy" class="aligncenter wp-image-25634" src="../Images/47a49bd10ce53e5822d808a0d7134686.png" alt="An illustrated example of the exponents involved in calculating logs." data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/09/log.png"/></noscript>
<h3>简单搜索</h3>
<p>让我们假设列表上有<code>n</code>个项目。简单的搜索需要遍历列表中的每一项，因此我们有<code>n</code>操作。结果大O记数法的运行时间是O(n)；</p>
<h3>二进位检索</h3>
<p>二分搜索法的大O符号是O(log n)。这是以2为基数的，这是因为对于每个操作，我们都将列表分成两部分。</p>
<h2>结论</h2>
<p>我们决定采用的算法可以提高或阻碍我们的应用程序的性能，因此在采用某个算法时，不时地适当考虑权衡是很重要的。</p>
<p>你可以在这里更深入地研究线性和二分搜索法<a href="https://www.amazon.com/Grokking-Algorithms-illustrated-programmers-curious/dp/1617292230" target="_blank" rel="noopener noreferrer">。</a></p><div class="code-block code-block-27">
<div class="blog-plug inline-plug vanilla-javascript-cta"><h2>通过理解上下文，更容易地调试JavaScript错误</h2>
<p>调试代码总是一项单调乏味的任务。但是你越了解自己的错误，就越容易改正。</p>
<p>LogRocket 让你以新的独特的方式理解这些错误。我们的前端监控解决方案跟踪用户与您的JavaScript前端的互动，让您能够准确找出导致错误的用户行为。</p>
<a href="https://lp.logrocket.com/blg/javascript-signup" class="signup" target="_blank" rel="noopener noreferrer"><img class="alignnone size-full wp-image-46 jetpack-lazy-image" src="../Images/cbfed9be3defcb505e662574769a7636.png" alt="LogRocket Dashboard Free Trial Banner" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2020/06/reproduce-javascript-errors.gif?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/06/reproduce-javascript-errors.gif"/><noscript><img data-lazy-fallback="1" class="alignnone size-full wp-image-46" src="../Images/cbfed9be3defcb505e662574769a7636.png" alt="LogRocket Dashboard Free Trial Banner" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/06/reproduce-javascript-errors.gif"/></noscript></a>
<p>LogRocket记录控制台日志、页面加载时间、堆栈跟踪、慢速网络请求/响应(带有标题+正文)、浏览器元数据和自定义日志。理解您的JavaScript代码的影响从来没有这么简单过！</p>
<a class="signup" href="https://lp.logrocket.com/blg/javascript-signup" target="_blank" rel="noopener noreferrer">Try it for free</a><p>.</p></div>


</div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
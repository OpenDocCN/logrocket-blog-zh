<html>
<head>
<title>How to keep your JavaScript libraries up to date - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>如何让你的JavaScript库保持最新</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/how-to-keep-javascript-libraries-up-to-date/#0001-01-01">https://blog.logrocket.com/how-to-keep-javascript-libraries-up-to-date/#0001-01-01</a></blockquote><div><article class="article-post">
<p>保持JavaScript库最新的工作可能比偶尔运行<code>npm update</code>或<code>yarn up</code>更微妙。新项目通常以最新版本的库开始，但它们很快就会过时。</p>
<p>对于JavaScript开发人员来说，这是一个特别重要的话题，因为与用其他语言编写的项目相比，用JS编写的项目往往具有相对较大的依赖树。</p>
<h2>为什么有这么多依赖？</h2>
<p>这种趋势有几个原因。首先，JS生态系统与Node.js和T2的npm注册中心紧密相连。这很重要，因为Node.js有一个<a href="https://medium.com/the-node-js-collection/keeping-the-node-js-core-small-137f83d18152">故意变小的</a>标准库。就<a href="https://nodejs.org/api/">把它</a>比作<a href="https://docs.python.org/3/library/"> Python的标准库</a>。</p>
<p>这种方法有利有弊，但实际结果是JS开发人员习惯于求助于第三方库来解决问题，即使是添加<code>mkdir -p</code>功能这样的任务。mkdirp 库每周被下载超过2000万次。</p>
<p>由于依赖项本身可以有依赖项，这种习惯会导致一个大的<code>node_modules</code>目录。它的大小已经成为了<a href="https://devrant.com/rants/760537/heaviest-objects-in-the-universe">模因</a>，npm的<code>package-lock.json</code>和<a href="https://yarnpkg.com/">纱’</a>s<code>yarn.lock</code>有几千行甚至上万行之长是很常见的。</p>
<p><img data-attachment-id="20977" data-permalink="https://blog.logrocket.com/how-to-keep-javascript-libraries-up-to-date/node-modules-meme/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/06/node-modules-meme.jpeg" data-orig-size="730,525" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;1&quot;}" data-image-title="node_modules meme" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/06/node-modules-meme-300x216.jpeg" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/06/node-modules-meme.jpeg" decoding="async" class="aligncenter size-full wp-image-20977 jetpack-lazy-image" src="../Images/e1d8e510590f1a15c3b91f6711de81ff.png" alt="A Meme Making Light Of The Weight Of Node Modules" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2020/06/node-modules-meme.jpeg 730w, https://blog.logrocket.com/wp-content/uploads/2020/06/node-modules-meme-300x216.jpeg 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2020/06/node-modules-meme.jpeg?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/06/node-modules-meme.jpeg"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="20977" data-permalink="https://blog.logrocket.com/how-to-keep-javascript-libraries-up-to-date/node-modules-meme/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/06/node-modules-meme.jpeg" data-orig-size="730,525" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;1&quot;}" data-image-title="node_modules meme" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/06/node-modules-meme-300x216.jpeg" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/06/node-modules-meme.jpeg" decoding="async" loading="lazy" class="aligncenter size-full wp-image-20977" src="../Images/e1d8e510590f1a15c3b91f6711de81ff.png" alt="A Meme Making Light Of The Weight Of Node Modules" srcset="https://blog.logrocket.com/wp-content/uploads/2020/06/node-modules-meme.jpeg 730w, https://blog.logrocket.com/wp-content/uploads/2020/06/node-modules-meme-300x216.jpeg 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/06/node-modules-meme.jpeg"/></noscript>
<p>与其他生态系统相比，JS开发人员在更大程度上也信奉创建和使用<a href="https://blog.sindresorhus.com/small-focused-modules-9238d977a92a">小而集中的依赖关系</a>的哲学。这有时是<a href="https://www.reddit.com/r/programming/comments/c0zwxb/one_liner_npm_package_iswindows_has_25_million/">批评的目标</a>，尤其是当包只包含一行代码的时候。</p>
<p>不考虑这种现实的权衡，开发人员将需要在某个时候考虑他们的依赖性更新策略。</p>
<h2>为什么要更新</h2>
<p>你可能会问为什么首先保持依赖关系的最新是值得的，特别是当一个项目运行良好的时候。</p>
<p>第一个原因是防止安全漏洞。即使您能够编写完美的代码，您使用的任何第三方代码，无论是直接的还是间接的，都可能存在安全问题。这可能导致灾难性的后果。2017年的Equifax数据泄露事件是由Equifax未能更新一个<a href="https://struts.apache.org/">框架</a>引起的，该框架用于其一个网站，此前该框架修补了一个安全漏洞。</p>
<p>同样的想法也适用于其他错误修复、功能改进和性能改进。通过更新您的依赖项，您可以轻松地将这些改进引入到您的项目中。</p>
<p>第二个原因是为了避免以后因为任何原因被迫升级时不得不做出巨大的改变。例如，您可能从1.0版本的库开始。你长时间不升级，然后你尝试直接升级到4.0版本。这可能涉及到重大的变化，如果您在此期间升级到2.0和3.0，这些变化可能不会那么痛苦。</p>
<p>这种情况并不少见。也许你想升级到Node的一个新的主版本，但是你的一个库的当前版本不支持它。</p>
<p>类似地，也许你的库在某种程度上相互依赖，使得更新一个库而不更新另一个库变得困难。例如，您可以使用一个React组件库，它对React具有对等依赖关系。您只想更新组件库，但随后您发现自己也被迫更新React。</p>
<p>这种级联效应会导致比您最初打算的更大的变化，尤其是当您必须更改一些自己的代码时。你越长时间不更新你的库，你就越有可能遇到这种情况。</p>
<p>一些库的作者试图通过深思熟虑的方式引入突破性的改变来简化迁移，比如在移除它们之前取消一些特性。如果你很少更新，你可能会被迫在一个不方便的时间做出大的改变，而不是有一个预警和制定计划的机会。</p>
<p>更新依赖关系也是保持消息灵通的一种方式。它给你一个图书馆发展的感觉。你可能会学到一个对你有帮助的新功能。或者你可能意识到一个库正在以这样一种方式改变，它不能满足你未来的需求，你应该开始研究替代方案。如果你安装了一个库，并且不再考虑它，就很容易错过这些事情。</p>
<p>最后，如果您自己就是一个库作者，那么代表您的最终用户更新您的依赖项是有意义的。他们不容易控制子依赖的版本，所以如果一个版本有问题，如果你不更新你的<code>package.json</code>来允许他们引入子依赖的新版本，他们可能会被这个问题所困扰。</p>
<h2>为什么不更新</h2>
<p>但是，也有不更新库的原因。最大的问题是，任何改变都有引发问题的风险。虽然您可能获得了一个您甚至没有意识到的bug的修复，但是更新的库也有可能引入一个新的bug或性能退化。</p>
<p>一个<a href="https://kevin.burke.dev/kevin/dont-update-dependencies/">学派</a>认为你应该只在有特定原因的时候更新依赖关系，而不是仅仅为了更新而更新。拥有一个好的测试套件有助于减轻风险，但它仍然是一个风险。</p>
<p>更新依赖关系还会占用构建新功能或修复已知问题的时间。当库发生重大变化时，这是一项耗时的工作。</p>
<p>不管您决定多久更新一次库，让我们考虑一下这样做的实际机制。</p>
<h2>更新相关性</h2>
<p>记住<a href="https://semver.org/">语义版本化(semver) </a>的思想。这是一个主要的版本化程序的实践。未成年人。补丁方式。新的主要版本表示重大变更，新的次要版本表示向后兼容的新功能，新的补丁版本表示向后兼容的错误修复。</p>
<p>JS库倾向于遵循语义版本化，但是版本号仅仅反映了作者的意图和理解。他们可能会发布一个新的次要版本，该版本实际上意外地发生了重大变化，或者您可能以一种意想不到的方式使用该库，从而导致更新版本出现问题。</p>
<p>默认情况下，npm和Yarn希望库遵循语义版本控制。当您使用任一选项添加库时，<code>package.json</code>中的条目将在版本前面有一个脱字符号(<code>^</code>):</p>
<pre>{
  "dependencies": {
    "lodash": "^3.1.0"
  }
}</pre>
<p>这意味着您将接受次要版本和补丁版本更新，但不接受主要版本更新。</p><div class="code-block code-block-54">
<hr/>
<h3>更多来自LogRocket的精彩文章:</h3>

<hr/></div>
<p>要检查您的依赖项是否过期，您可以运行<code><a href="https://docs.npmjs.com/cli-commands/outdated.html">npm outdated</a></code>:</p>
<pre>Package  Current  Wanted   Latest  Location
lodash     3.1.0  3.10.1  4.17.15  npm-test</pre>
<p>当你更新的时候，最重要的事情是读取库的<a href="https://keepachangelog.com/"> changelog </a>。这通常是弄清楚你带来了什么变化的最有效的方法，最关键的是突破性的变化。</p>
<p>如果您发现自己不幸地更新了一个没有changelog但却是开源的库，那么您可能需要查看提交历史来找出发生了什么变化。较大的项目也倾向于有博客，为新版本提供更多的细节。</p>
<p>更新包的标准方法是使用<code><a href="https://docs.npmjs.com/cli/update">npm update</a></code>，它将所有包更新到根据semver可以接受的最新版本。在这种情况下，您将把Lodash更新到版本3.10.1。</p>
<p>即使版本4.17.15可用，默认情况下您也不会更新到它，因为脱字符号限制您只能进行较小的更新和补丁更新。如果不想一次更新所有的包，也可以将特定的包传递给该命令。</p>
<p>在许多情况下，无论指定的版本如何，您都希望更新到最新的可用版本。不幸的是，<code>npm update</code>没有办法做到这一点，所以您需要使用<code>npm install <a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="620e0d0603110a220e0316071116">[email protected]</a></code>。</p>
<p>为了使这个过程更有效，特别是当你有很多依赖项时，考虑使用<code><a href="https://github.com/dylang/npm-check">npm-check</a></code>或<code><a href="https://github.com/raineorshine/npm-check-updates">npm-check-updates</a></code>。这些CLI工具允许您以交互方式进行更新，并提供有用的信息，如指向项目网站的链接，以便您可以轻松检查更改。</p>
<pre>$ npm-check

lodash   😎  MAJOR UP  Major update available. https://lodash.com/
                      npm install --save <a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="90fcfff4f1e3f8d0a4bea1a7bea1a5">[email protected]</a> to go from 3.1.0 to 4.17.15

Use npm-check -u for interactive update.

$ npm-check -u
? Choose which packages to update.

 Major Update Potentially breaking API changes. Use caution.
❯◯ lodash  3.1.0  ❯  4.17.15  https://lodash.com/</pre>
<p>Yarn甚至内置了这个特性。只需运行<code><a href="https://yarnpkg.com/cli/upgrade-interactive">yarn upgrade-interactive</a></code>。</p>
<pre>$ yarn upgrade-interactive
 Press &lt;up&gt;/&lt;down&gt; to select packages.         Press &lt;enter&gt; to install.
 Press &lt;left&gt;/&lt;right&gt; to select versions.      Press &lt;ctrl+c&gt; to abort.

? Pick the packages you want to upgrade.       Current      Range/Latest

 &gt; lodash                                      ◯  3.1.0    ◯  3.10.1   ◉  4.17.15</pre>
<p>Yarn没有一个<code>outdated</code>命令，所以<code>upgrade-interactive</code>基本上将npm的<code>outdated</code>和<code>update</code>合二为一，尽管你也可以使用<code><a href="https://yarnpkg.com/cli/up">yarn up</a></code>。</p>
<p>请注意，如果您仍然使用纱线v1，则会有一些差异。升级命令是<code><a href="https://classic.yarnpkg.com/en/docs/cli/upgrade/">yarn upgrade</a></code>而不是<code>yarn up</code>。Yarn v1也有一个<code><a href="https://classic.yarnpkg.com/en/docs/cli/outdated">outdated</a></code>命令。</p>
<h2>自动更新</h2>
<p>此外，还有一种利用外部服务简化更新流程的趋势。用于此目的的一些工具包括Gemnasium、<a href="https://github.com/greenkeeperio/greenkeeper"> Greenkeeper </a>和<a href="https://dependabot.com/">dependent bot</a>，尽管它们已经分别被<a href="https://about.gitlab.com/press/releases/2018-01-30-gemnasium-acquisition.html"> GitLab </a>、<a href="https://snyk.io/blog/snyk-partners-with-greenkeeper-to-help-developers-proactively-maintain-dependency-health/"> Snyk </a>和<a href="https://dependabot.com/blog/hello-github/"> GitHub </a>收购或归入。</p>
<p>总的想法是要有一个服务来监控项目的依赖项，甚至打开拉请求来更新它们。当在依赖关系树中发现安全漏洞时，它们还会提醒您。这里有一张由GitHub的<a href="https://help.github.com/en/github/managing-security-vulnerabilities/configuring-automated-security-updates">安全更新</a>生成的Dependabot PR的截图。</p>
<p><img data-attachment-id="20978" data-permalink="https://blog.logrocket.com/how-to-keep-javascript-libraries-up-to-date/dependabot-pull-request-example/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/06/dependabot-pull-request-example.png" data-orig-size="730,723" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Dependabot PR screenshot" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/06/dependabot-pull-request-example-300x297.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/06/dependabot-pull-request-example.png" decoding="async" class="aligncenter size-full wp-image-20978 jetpack-lazy-image" src="../Images/618afe18d16f19c2c8b5e26eda872682.png" alt="Screenshot Of A Dependabot Pull Request" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2020/06/dependabot-pull-request-example.png 730w, https://blog.logrocket.com/wp-content/uploads/2020/06/dependabot-pull-request-example-300x297.png 300w, https://blog.logrocket.com/wp-content/uploads/2020/06/dependabot-pull-request-example-150x150.png 150w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2020/06/dependabot-pull-request-example.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/06/dependabot-pull-request-example.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="20978" data-permalink="https://blog.logrocket.com/how-to-keep-javascript-libraries-up-to-date/dependabot-pull-request-example/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/06/dependabot-pull-request-example.png" data-orig-size="730,723" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Dependabot PR screenshot" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/06/dependabot-pull-request-example-300x297.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/06/dependabot-pull-request-example.png" decoding="async" loading="lazy" class="aligncenter size-full wp-image-20978" src="../Images/618afe18d16f19c2c8b5e26eda872682.png" alt="Screenshot Of A Dependabot Pull Request" srcset="https://blog.logrocket.com/wp-content/uploads/2020/06/dependabot-pull-request-example.png 730w, https://blog.logrocket.com/wp-content/uploads/2020/06/dependabot-pull-request-example-300x297.png 300w, https://blog.logrocket.com/wp-content/uploads/2020/06/dependabot-pull-request-example-150x150.png 150w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/06/dependabot-pull-request-example.png"/></noscript>
<p>像这样的服务可以使你的库保持最新变得相当容易，因为你不需要自己去记着这么做。</p>
<h2>结论</h2>
<p>使库保持最新表面上看起来似乎很简单，但是在每个项目的基础上对更新策略进行一些思考是很好的。一个项目可能永远不需要再次更新，而另一个项目可能需要使用Dependabot、Snyk或其他服务来积极地保持最新。或者，您可能对及时的方法很满意，在这种方法中，您在发现问题时更新依赖关系。无论如何，做出明确的决定。</p><div class="code-block code-block-27">
<div class="blog-plug inline-plug vanilla-javascript-cta"><h2>通过理解上下文，更容易地调试JavaScript错误</h2>
<p>调试代码总是一项单调乏味的任务。但是你越了解自己的错误，就越容易改正。</p>
<p>LogRocket 让你以新的独特的方式理解这些错误。我们的前端监控解决方案跟踪用户与您的JavaScript前端的互动，让您能够准确找出导致错误的用户行为。</p>
<a href="https://lp.logrocket.com/blg/javascript-signup" class="signup" target="_blank" rel="noopener noreferrer"><img class="alignnone size-full wp-image-46 jetpack-lazy-image" src="../Images/cbfed9be3defcb505e662574769a7636.png" alt="LogRocket Dashboard Free Trial Banner" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2020/06/reproduce-javascript-errors.gif?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/06/reproduce-javascript-errors.gif"/><noscript><img data-lazy-fallback="1" class="alignnone size-full wp-image-46" src="../Images/cbfed9be3defcb505e662574769a7636.png" alt="LogRocket Dashboard Free Trial Banner" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/06/reproduce-javascript-errors.gif"/></noscript></a>
<p>LogRocket记录控制台日志、页面加载时间、堆栈跟踪、慢速网络请求/响应(带有标题+正文)、浏览器元数据和自定义日志。理解您的JavaScript代码的影响从来没有这么简单过！</p>
<a class="signup" href="https://lp.logrocket.com/blg/javascript-signup" target="_blank" rel="noopener noreferrer">Try it for free</a><p>.</p></div>


</div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
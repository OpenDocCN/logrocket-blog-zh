<html>
<head>
<title>File upload and download in Rust - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>Rust - LogRocket博客中的文件上传和下载</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/file-upload-and-download-in-rust/#0001-01-01">https://blog.logrocket.com/file-upload-and-download-in-rust/#0001-01-01</a></blockquote><div><article class="article-post">
<p>许多web应用程序，尤其是面向用户的应用程序，都提供了上传文件的界面。这可以从简单的文件，如头像图片，到复杂的项目，如超安全，加密签署的合同。</p>
<p/>
<p>在任何情况下，对于许多web服务来说，这都是必须的——就像上传后能够再次下载或访问这些文件一样重要。</p>
<p>在本指南中，我们将演示如何在Rust web应用程序中实现文件上传和下载。我们将使用<a href="https://github.com/seanmonstar/warp" target="_blank" rel="noopener noreferrer"> warp </a> web框架，但是基础知识将主要适用于其他异步web框架。</p>
<p>有一个漂亮的板条箱用于处理异步多部分流，称为<a href="https://crates.io/crates/mpart-async" target="_blank" rel="noopener noreferrer"> mpart-async </a>，它流式传输传入的文件，而不是像warp此时所做的那样将它们完全加载到内存中(对此有一个<a href="https://github.com/seanmonstar/warp/issues/323" target="_blank" rel="noopener noreferrer">问题</a>)。</p>
<p>然而，出于本教程的目的，我们将使用warp的内置方法来处理多部分请求。如果您的用例涉及到处理需要在加载到内存之前流过或验证的大文件，那么前面提到的<code>mpart-async</code> crate是一个明智的方法。</p>
<p>我们将构建一个示例web应用程序，使用户能够上传高达5 MB的<code>.pdf</code>和<code>.png</code>文件。每个文件将以随机生成的名称放在本地的<code>./files</code>文件夹中，并可通过<code>GET /files/$filename</code>端点下载。</p>
<h2 id="setup">设置</h2>
<p>接下来，您只需要一个相当新的Rust安装(1.39+)和一个发送HTTP请求的工具，比如cURL。</p>
<p>首先，创建一个新的Rust项目。</p>
<pre>cargo new rust-upload-download-example
cd rust-upload-download-example
</pre>
<p>接下来，编辑<code>Cargo.toml</code>文件并添加您需要的依赖项。</p>
<pre>[dependencies]
tokio = { version = "0.2.21", features = ["macros", "rt-threaded", "fs"] }
warp = "0.2.3"
uuid = { version = "0.8", features = ["v4"] }
futures = { version = "=0.3.5", default-features = false }
bytes = "0.5.6"
</pre>
<p>我们使用warp来构建web服务，它在底层使用Tokio。其他依赖项用于处理warp的文件上传。使用<code>uuid</code>，我们将为上传的文件创建唯一的名称，期货和字节箱将帮助我们处理传入的文件流。</p>
<h2 id="webservice">网络服务</h2>
<p>让我们首先创建一个基本的Warp web应用程序，让用户从本地文件夹下载文件。</p>
<pre>#[tokio::main]
async fn main() {
    let download_route = warp::path("files").and(warp::fs::dir("./files/"));

    let router = download_route.recover(handle_rejection);
    println!("Server started at localhost:8080");
    warp::serve(router).run(([0, 0, 0, 0], 8080)).await;
}

async fn handle_rejection(err: Rejection) -&gt; std::result::Result&lt;impl Reply, Infallible&gt; {
    let (code, message) = if err.is_not_found() {
        (StatusCode::NOT_FOUND, "Not Found".to_string())
    } else if err.find::&lt;warp::reject::PayloadTooLarge&gt;().is_some() {
        (StatusCode::BAD_REQUEST, "Payload too large".to_string())
    } else {
        eprintln!("unhandled error: {:?}", err);
        (
            StatusCode::INTERNAL_SERVER_ERROR,
            "Internal Server Error".to_string(),
        )
    };

    Ok(warp::reply::with_status(message, code))
}
</pre>
<p>在这个代码片段中，我们在<code>GET /files</code>定义了一个<code>download_route</code>，它使用Warp的<code>fs::dir</code>过滤器，从给定的路径提供文件。这就是我们实现文件下载所要做的一切。</p>
<p>当然，根据您的具体使用情况和您正在处理的文件的大小，或者如果您有安全顾虑，下载文件的逻辑会比这更复杂。但是对于我们的例子来说已经足够了。</p>
<h2 id="uploadingfiles">上传文件</h2>
<p>接下来，我们来看看<code>upload</code>路线定义。</p>
<pre>// in main
let upload_route = warp::path("upload")
    .and(warp::post())
    .and(warp::multipart::form().max_length(5_000_000))
    .and_then(upload);

let router = upload_route.or(download_route).recover(handle_rejection);
</pre>
<p>上传路由是一个<code>POST</code>端点。我们使用Warp的<code>multipart::form()</code>过滤器来传递多部分请求。</p>
<p>我们也可以在这里定义一个最大长度。您可能已经注意到，在<code>handle_rejection</code>错误处理方法中，我们显式地处理了<code>PayloadTooLarge</code>错误。当有效负载超过此限制时，会触发此错误。</p>
<p>最后，让我们看看<code>upload</code>处理程序。这是这个小应用程序的核心部分，它有点复杂，所以我们将一步一步地介绍它。</p>
<pre>async fn upload(form: FormData) -&gt; Result&lt;impl Reply, Rejection&gt; {
    let parts: Vec&lt;Part&gt; = form.try_collect().await.map_err(|e| {
        eprintln!("form error: {}", e);
        warp::reject::reject()
    })?;
</pre>
<p>我们立即看到函数签名中的<code>FormData</code>。这实际上是一个<code>warp::multipart::FormData</code>，它是由多个<code>Part</code>元素组成的流。既然我们正在处理一个<code>futures::Stream</code>，我们可以使用<a href="https://docs.rs/futures/0.3.5/futures/stream/trait.TryStreamExt.html#method.try_collect" target="_blank" rel="noopener noreferrer"> <code>TryStreamExt</code> </a>特性来帮助一些助手。在这种情况下，我们使用<code>try_collect</code>函数将整个流异步收集到一个集合中，如果失败，记录错误。</p>
<p>为了理解下一部分，让我们看一个使用cURL发送到这个服务器的示例请求。</p>
<pre>curl --location --request POST 'http://localhost:8080/upload' \
--header 'Content-Type: multipart/form-data' \
--form '<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="d8beb1b4bde598">[email protected]</a>/home/somewhere/picture.png'
</pre>
<p>正如您在<code>--form</code>选项中看到的，我们用名称<code>file</code>定义我们的文件。我们还可以添加额外的参数，比如文件名或一些额外的元数据。</p>
<p>下一步是迭代上面收集的<code>Part</code>以查看是否有<code>file</code>字段。</p>
<pre>    for p in parts {
        if p.name() == "file" {
            let content_type = p.content_type();
...
</pre>
<p>我们迭代得到的部分，如果其中一个被称为<code>file</code>，我们将假设它是一个文件。现在我们需要确保它具有正确的内容类型——在本例中是PDF或PNG——并进一步处理它。</p><div class="code-block code-block-54">
<hr/>
<h3>更多来自LogRocket的精彩文章:</h3>

<hr/></div>
<pre>            let file_ending;
            match content_type {
                Some(file_type) =&gt; match file_type {
                    "application/pdf" =&gt; {
                        file_ending = "pdf";
                    }
                    "image/png" =&gt; {
                        file_ending = "png";
                    }
                    v =&gt; {
                        eprintln!("invalid file type found: {}", v);
                        return Err(warp::reject::reject());
                    }
                },
                None =&gt; {
                    eprintln!("file type could not be determined");
                    return Err(warp::reject::reject());
                }
            }
</pre>
<p>我们可以使用<code>Part</code>的<code>.content_type()</code>方法来检查实际的文件类型。<a href="https://github.com/flier/rust-mime-sniffer" target="_blank" rel="noopener noreferrer"> rust-mime-sniffer </a>是另一个可以用来检测文件类型的有用工具。</p>
<p>我们还根据文件类型设置了<code>file_ending</code>,因此我们可以将它附加到我们稍后想要创建的文件中。</p>
<p>如果文件是未知类型或者没有已知类型，我们记录错误并返回。</p>
<p>下一步是将<code>Part</code>转换成我们可以实际写入磁盘的字节向量。</p>
<pre>            let value = p
                .stream()
                .try_fold(Vec::new(), |mut vec, data| {
                    vec.put(data);
                    async move { Ok(vec) }
                })
                .await
                .map_err(|e| {
                    eprintln!("reading file error: {}", e);
                    warp::reject::reject()
                })?;
</pre>
<p>此时，我们可以使用<code>Part</code>的<code>.stream()</code>或<code>.data()</code>方法来获得包含数据的底层<code>bytes::Buf</code>。</p>
<p>在这个例子中，我们再次将整个部分转换成一个流，并使用来自<code>TryStreamExt</code>的另一个助手<code>.try_fold()</code>，将所有的缓冲区连接成一个包含所有数据的<code>Vec&lt;u8&gt;</code>。</p>
<p>这个<code>try_fold</code>本质上类似于任何其他的<code>.reduce()</code>或<code>.fold()</code>函数，除了它是异步的。我们定义一个初始值(一个空向量)，然后将每一段数据添加到其中。</p>
<p>如果这些失败了，我们再次记录错误并返回。</p>
<p>此时，我们解析并验证了传入的文件，并准备好将数据写入磁盘，这是最后一步。</p>
<pre>            let file_name = format!("./files/{}.{}", Uuid::new_v4().to_string(), file_ending);
            tokio::fs::write(&amp;file_name, value).await.map_err(|e| {
                eprint!("error writing file: {}", e);
                warp::reject::reject()
            })?;
            println!("created file: {}", file_name);
        }
    }
    Ok("success")
}
</pre>
<p>首先，我们使用<code>Uuid</code>箱创建一个随机生成的唯一文件名，并添加上面计算的<code>file_ending</code>。然后，使用Tokio的<code>fs::write</code>，它是<code>std::fs::write</code>的异步等价物，我们用生成的文件名将数据写到一个文件中。如果成功，我们记录文件名并向调用者返回成功消息。</p>
<p>让我们使用下面的命令来尝试一下。</p>
<pre># first, upload some png
curl --location --request POST 'http://localhost:8080/upload' \
--header 'Content-Type: multipart/form-data' \
--form '<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="7f1916131a423f">[email protected]</a>/home/somewhere/picture.png'

# check the logs for the file name, or go into the ./files folder
created file: ./files/7d678724-9480-489e-8a33-57e1ae5adb4d.png

# request the file and pipe it to a new png
curl http://localhost:8080/files/7d678724-9480-489e-8a33-57e1ae5adb4d.png &gt; new_picture.png
</pre>
<p>有用！太棒了。所有这一切都在不到一百行Rust代码中完成，只需使用几个箱子就可以进行一些非常基本的错误处理和输入验证。</p>
<p>你可以在<a href="https://github.com/zupzup/warp-upload-download-example" target="_blank" rel="noopener noreferrer"> GitHub </a>找到完整的示例代码。</p>
<h2 id="conclusion">结论</h2>
<p>在web服务中高效、可靠地处理文件上传并不是一件容易的事情，但是Rust生态系统提供了所有的工具来实现这一点，甚至提供了异步传输文件的选项来提高速度和灵活性。</p>
<p>上面的例子是现实世界实现的起点。当它用于生产系统时，还有更多的事情需要考虑。也就是说，Rust web生态系统已经具备了为您的用户创造出色的上传和下载体验的基础。</p><div class="code-block code-block-29">
<div class="blog-plug inline-plug rust-plug"><h2><a href="https://lp.logrocket.com/blg/rust-signup" target="_blank">log rocket</a>:Rust应用的web前端的全面可见性</h2><p>调试Rust应用程序可能很困难，尤其是当用户遇到难以重现的问题时。如果您对监控和跟踪Rust应用程序的性能、自动显示错误、跟踪缓慢的网络请求和加载时间感兴趣，</p><a href="https://lp.logrocket.com/blg/rust-signup" target="_blank">try LogRocket</a><p>. </p><a class="signup" href="https://lp.logrocket.com/blg/rust-signup" target="_blank" rel="noopener noreferrer"><img class="alignnone size-full wp-image-46 jetpack-lazy-image" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/><noscript><img data-lazy-fallback="1" class="alignnone size-full wp-image-46" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/></noscript></a><p>LogRocket 就像是网络和移动应用程序的DVR，记录你的Rust应用程序上发生的一切。您可以汇总并报告问题发生时应用程序的状态，而不是猜测问题发生的原因。LogRocket还可以监控应用的性能，报告客户端CPU负载、客户端内存使用等指标。</p><p>现代化调试Rust应用的方式— <a class="signup" href="https://lp.logrocket.com/blg/rust-signup" target="_blank" rel="noopener noreferrer">开始免费监控</a>。</p></div>


</div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
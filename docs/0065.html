<html>
<head>
<title>4 options to help you get started linting your JavaScript - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>帮助你入门的4个选项林挺你的JavaScript - LogRocket博客</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/four-options-to-help-you-get-started-linting-your-javascript-b4b829828648/#0001-01-01">https://blog.logrocket.com/four-options-to-help-you-get-started-linting-your-javascript-b4b829828648/#0001-01-01</a></blockquote><div><article class="article-post">
<p>你几乎总是可以打赌，一篇好文章是好编辑的恩人。在这方面，代码和散文没什么不同。作为开发人员和程序员，我们享受的一个好处是编辑器，或代码翻译器，它们可以内置到我们的工作流中。</p>
<p>林挺是检查您的代码是否有任何错误的行为或过程。关于如何优化给定代码的有效性，有许多想法。但是检查以确保它没有错误并且符合特定的风格指南是基线。有时这是一致性和可读性的问题，有时是让代码实际运行的问题。</p>
<p>谈到JavaScript林挺，有几个工具是与众不同的。让我们来看四个linters，它们可以帮助你开始或改进你的林挺过程:JSLint、standardJS、JSHint和ESLint。</p>
<figure><a href="https://logrocket.com/for/javascript-error-tracking/" target="_blank" rel="noopener noreferrer"><img decoding="async" class="alignnone jetpack-lazy-image" src="../Images/94b3e0f84b30cb0d321f60471481ab64.png" alt="" data-height="750" data-width="3212" data-lazy-src="https://storage.googleapis.com/blog-images-backup/1*GPjaPKNNUYHU8EsA3Z0JGA.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://storage.googleapis.com/blog-images-backup/1*GPjaPKNNUYHU8EsA3Z0JGA.png"/><noscript><img data-lazy-fallback="1" decoding="async" class="alignnone" src="../Images/94b3e0f84b30cb0d321f60471481ab64.png" alt="" data-height="750" data-width="3212" data-original-src="https://storage.googleapis.com/blog-images-backup/1*GPjaPKNNUYHU8EsA3Z0JGA.png"/></noscript></a></figure>
<h2>JSLint</h2>
<figure><img decoding="async" src="../Images/c272917ae200a7815f6cb7cfd3d16b36.png" data-height="200" data-width="463" data-lazy-src="https://storage.googleapis.com/blog-images-backup/1*TyN5Vstv9Vr_BIc_6deF3w@2x.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" class=" jetpack-lazy-image" data-original-src="https://storage.googleapis.com/blog-images-backup/1*TyN5Vstv9Vr_BIc_6deF3w@2x.png"/><noscript><img data-lazy-fallback="1" decoding="async" src="../Images/c272917ae200a7815f6cb7cfd3d16b36.png" data-height="200" data-width="463" data-original-src="https://storage.googleapis.com/blog-images-backup/1*TyN5Vstv9Vr_BIc_6deF3w@2x.png"/></noscript></figure>
<p>JSLint 由道格拉斯·克洛克福特于2002年创立，他也写了一本可以说是T2最好的关于JavaScript 的书。JSLint为表格带来了简单性和速度。但它也非常固执己见，这可能是一件好事，也可能是一件坏事。</p>
<p>JSLint由一个页面站点组成，该站点由一个文本字段控制，您可以在其中粘贴代码。单击“JSLint”按钮，任何错误、文体错误、语法错误或其他错误都会显示在文本字段下。文本字段下是一个小选项列表，可通过复选框进行配置。选项包括容忍额外的空白，使用“this”关键字(Crockford在他的演讲中不鼓励这样做)，以及包含Node.js。</p>
<p>如果您不依赖任何特定的风格指南，并且想要一个可靠的来源来检查您的代码，JSLint是一个很好的选择。对于测试代码片段，或者如果您正在寻找一种快速lint小项目的方法——可能是一个只包含一个JavaScript文件的单页静态站点，它特别有效。</p>
<h2>标准j</h2>
<figure><img decoding="async" src="../Images/b35d68a05d9b125d6c90254f507a32d0.png" data-height="288" data-width="250" data-lazy-src="https://storage.googleapis.com/blog-images-backup/1*8es60D8fS4-SeuPUWfLXOg.jpeg?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" class=" jetpack-lazy-image" data-original-src="https://storage.googleapis.com/blog-images-backup/1*8es60D8fS4-SeuPUWfLXOg.jpeg"/><noscript><img data-lazy-fallback="1" decoding="async" src="../Images/b35d68a05d9b125d6c90254f507a32d0.png" data-height="288" data-width="250" data-original-src="https://storage.googleapis.com/blog-images-backup/1*8es60D8fS4-SeuPUWfLXOg.jpeg"/></noscript></figure>
<p>仅基于GitHub的星星，<a href="https://standardjs.com/" target="_blank" rel="noopener noreferrer"> standardJS </a>是最受欢迎的选项，有近19，000颗星星。它是完全自以为是的，意味着它根本不可定制。但是，如果你不依赖任何特定的风格指南，这可能是一件好事。它以节点CLI的形式出现，可以使用您选择的终端或命令行进行全局安装或作为开发依赖项进行安装:</p>
<pre><code>$ npm install standard --global
</code><code>// or
</code><code>$ npm install standard --save-dev</code></pre>
<p>因为standardJS将Node和npm作为先决条件，并且因为它是从命令行或通过npm脚本运行的，所以标准比JSLint的标准稍微高了一些。但是因为它是不可配置的，所以你没有什么可担心的。你可以从命令行运行它，作为一个单词的命令，它会检查你当前工作目录中每个扩展名为<code>.js</code>的文件。</p>
<p>它发现的任何错误都将被打印到您的终端或命令行。您可以从standardJS <a href="https://standardjs.com/index.html#install" target="_blank" rel="noopener noreferrer">文档</a>中看到类似于这个例子的输出:</p>
<pre><code>$ standard
</code><code>Error: Use JavaScript Standard Style
</code><code>lib/torrent.js:950:11: Expected '===' and instead saw '=='.</code></pre>
<p>如果需要指定文件或目录，可以将路径作为参数，并使用通配符。它也接受通配符。在本例中，standardJS将在<code>src</code>目录及其子目录中查找并lint任何JavaScript文件:</p>
<p><code>$ standard "src/**/*.js" --fix</code></p>
<p>文件路径后面的<code>--fix</code>标志是在发现错误时自动修复错误的选项。这可以节省大量的时间，但也是一个很好的学习练习，让你自己去修正错误。</p>
<p>如果你想在决定是否使用它之前探索一下standardJS使用的惯例和规则，完整的列表可以在这里找到。对于那些寻找快速可靠的方法来开始使用JavaScript linter的人来说，StandardJS是一个很好的选择。</p>
<h2>JSHint</h2>
<figure><img decoding="async" src="../Images/668491266f64d21c5885a726001affd3.png" data-height="251" data-width="577" data-lazy-src="https://storage.googleapis.com/blog-images-backup/1*-SsoEZPBekzxvx4xg6Z0RA.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" class=" jetpack-lazy-image" data-original-src="https://storage.googleapis.com/blog-images-backup/1*-SsoEZPBekzxvx4xg6Z0RA.png"/><noscript><img data-lazy-fallback="1" decoding="async" src="../Images/668491266f64d21c5885a726001affd3.png" data-height="251" data-width="577" data-original-src="https://storage.googleapis.com/blog-images-backup/1*-SsoEZPBekzxvx4xg6Z0RA.png"/></noscript></figure>
<p>JSHint开始是JSLint的一个分支。目标是制造一个更加可配置的棉绒。如果你一直在使用standardJS，或者另一个固执己见的linter，并且你正在寻找一种方式开始定制你自己的林挺规则，JSHint可能适合你。它具有上述棉绒的大部分优点，还有其他一些优点。</p>
<p>像JSLint一样，<a href="http://jshint.com/" target="_blank" rel="noopener noreferrer"> JSHint主页</a>有一个文本字段，你可以在那里粘贴代码。文本字段右边的<code>Metrics</code>字段将在您输入时实时更新，记录您代码的运行统计列表，例如它包含多少个函数。当然，它还会显示找到的任何林挺错误。</p>
<p>如果您不喜欢复制/粘贴方法，并且希望将它应用到您的项目中，可以使用npm全局安装JSHint，或者将其作为项目依赖项安装:</p>
<pre><code>$ npm install jshint --global
</code><code>// or
</code><code>$ npm install jshint --save-dev</code></pre>
<p>安装后，您将使用CLI来lint您的代码。以下是分别检查单个文件和目录的两个命令示例:</p>
<pre><code>$ jshint index.js
</code><code>// or
</code><code>$ jshint src/</code></pre>
<p>在第一个例子中，JSHint将lint<code>index.js</code>文件，在第二个例子中，它将递归地搜索‘src/’目录并lint它找到的任何JavaScript文件。JSHint将打印它在终端中发现的任何错误。</p>
<p>如果您不关心定制，JSHint可以像上面的例子中描述的那样使用，它会工作得很好。但是，从这里开始，复杂性会显著增加，因为JSHint是完全可配置的，并且它还公开了一个API，这意味着它可以在您自己的JavaScript文件中用作JavaScript模块。</p>
<p>一个定制的配置应该存储在一个名为<code>.jshintrc</code>的文件中，文件可能是这样的:</p>
<pre><code>{
</code><code>"esversion": 5,
</code><code>"eqeqeq": true,
</code><code>"strict": true
</code><code>}</code></pre>
<p>此示例从上到下将ECMAScript版本设置为5，在比较值时需要使用三个等号(<code>===</code>或<code>!==</code>)而不是两个(<code>==</code>或<code>!=</code>)，并强制执行严格模式。您可以通过在命令行的一个<code>-- config</code>标志后面指定您的<code>.jshintrc</code>文件的路径，或者在您的项目<code>package.json</code>文件中将它们声明为‘jshintConfig’属性，来包含您的定制配置。JSHint将对您没有自定义的任何规则使用其默认选项。</p>
<p>命令行选项可能如下所示:</p>
<pre><code>// looks for '.jshintrc' in the current directory
</code><code>$ jshint --config './.jshintrc'</code></pre>
<p>虽然<code>package.json</code>选项可能看起来像这样:</p>
<pre id="d087" class="graf graf--pre graf-after--p"><code class="markup--code markup--pre-code">{
</code><code class="markup--code markup--pre-code">  "jshintConfig": {
</code><code class="markup--code markup--pre-code">    "esversion": 5,
</code><code class="markup--code markup--pre-code">    "eqeqeq": true,
</code><code class="markup--code markup--pre-code">    "strict": true
</code><code class="markup--code markup--pre-code">  }
</code><code>}</code></pre>
<p>您可以使用这些基础知识开始使用JSHint定制您自己的林挺规则。如果你想了解更多，官方文档包含了关于如何使用JSHint API的详尽描述，以及定制它来满足你的需求的所有方法。</p>
<h2>埃斯林特</h2>
<figure><img decoding="async" src="../Images/4e4471c1f1ef7350274dcd47fc330c8a.png" data-height="233" data-width="398" data-lazy-src="https://storage.googleapis.com/blog-images-backup/1*TPkhIqPgVzFSSpwdlVwhVw.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" class=" jetpack-lazy-image" data-original-src="https://storage.googleapis.com/blog-images-backup/1*TPkhIqPgVzFSSpwdlVwhVw.png"/><noscript><img data-lazy-fallback="1" decoding="async" src="../Images/4e4471c1f1ef7350274dcd47fc330c8a.png" data-height="233" data-width="398" data-original-src="https://storage.googleapis.com/blog-images-backup/1*TPkhIqPgVzFSSpwdlVwhVw.png"/></noscript></figure>
<p>抛开GitHub明星不谈，谈到JavaScript，林挺·埃斯林可能是最常见的，也将是很多人的首选。在它自己的<a href="https://eslint.org/docs/user-guide/getting-started" target="_blank" rel="noopener noreferrer">文档</a>中，它将自己与JSLint和JSHint进行比较，看它用于解析JavaScript的方法。而且，与JSHint类似，您可以使用缺省值，并随着您的偏好或需求的变化添加定制。</p>
<p>要开始使用ESLint，请全局安装或作为开发依赖项安装:</p>
<pre><code>$ npm install eslint --save-dev
</code><code>// or
</code><code>$ npm install eslint --global</code></pre>
<p>如果您全局安装ESLint，它的配置将应用于您运行它所针对的任何和所有项目文件。但是如果您希望不同的项目有不同的配置，您可以将它作为开发依赖项安装，并为每个项目创建不同的配置文件。请注意，如果ESLint是作为项目依赖项安装的，而不是全局安装的，那么您需要从您的<code>node_modules</code>文件夹中运行可执行文件，如下所示:</p>
<p><code>$ ./node_modules/.bin/eslint --init</code></p>
<p>当您运行上面的命令时，将通过一系列的问题引导您配置ESLint。(注意:无论您计划如何定制您的林挺规则，您都必须从这一步开始，因为ESLint需要这个过程生成的<code>.eslintrc</code>文件，然后它才能Lint您的代码。)</p>
<p>问你的第一个问题是如何配置ESLint。您有三种选择:使用流行的风格指南，回答关于您的风格的问题，或者让ESLint通过检查您的文件来决定如何设置规则，从而为您配置自身。如果马上自己配置它的前景看起来令人生畏，您可以依靠使用由少数几个已知组织之一开发的流行风格指南。</p>
<p>不管你走哪条路，ESLint都会用你的答案在当前工作目录下生成一个名为<code>.eslintrc</code>的文件。如果以后想修改林挺规则，就要修改这个文件。</p>
<p>这里有一个JSON格式的示例<code>.eslintrc</code>文件，它使用默认的<a href="https://github.com/airbnb/javascript" target="_blank" rel="noopener noreferrer"> Airbnb JavaScript样式指南</a>规则，并包括两个自定义规则来关闭严格模式并允许<code>console.log()</code>语句:</p>
<pre id="de34" class="graf graf--pre graf-after--p"><code class="markup--code markup--pre-code">{
</code><code class="markup--code markup--pre-code">  "extends": "airbnb-base",
</code><code class="markup--code markup--pre-code">  "rules": {
</code><code class="markup--code markup--pre-code">    "strict": "off",
</code><code class="markup--code markup--pre-code">    "no-console": "off"
</code><code class="markup--code markup--pre-code">  }
</code><code>}</code></pre>
<p>如果你选择回答关于你的风格的问题，它会问你使用哪个ECMAScript版本，你是否喜欢制表符或空格，分号或没有，你是否使用JSX和/或反应。ESLint对React和补充插件的现成支持可能会使它成为React开发者的最佳选择。至少对于那些刚刚开始接触林挺的人来说是这样。</p>
<p>安装ESLint并生成一个<code>.eslintrc</code>文件后，您可以使用CLI开始林挺您的代码。缺省情况下，ESLint会查找您的<code>.eslintrc</code>文件，因此您不需要在命令行中指定任何配置。但是您可以使用各种标志来改变ESLint的行为。在下面的例子中，<code> -- quiet</code>标志告诉ESLint只显示错误，而不是同时显示警告和错误。<code>--fix</code>标志告诉它尝试自动修复它发现的任何错误。</p>
<pre><code>// run eslint against file1.js
</code><code>$ ./node_modules/.bin/eslint file1.js
</code><code>// run eslint against file1.js and file2.js with flags to modify behavior
</code><code>$ ./node_modules/.bin/eslint file1.js file2.js --quiet --fix</code></pre>
<p>与我们讨论的其他CLI一样，如果需要，您可以使用通配符和文件路径来代替特定的文件名。虽然ESLint是高度可配置的，但它通过使用一个可接近的设置指南来简化默认配置方法的学习曲线。如果你真的想深入了解定制，<a href="https://eslint.org/docs/user-guide/getting-started" target="_blank" rel="noopener noreferrer">官方文档</a>包含了你可以用ESLint做的所有事情的详细解释。</p>
<section class="section section--body section--first">
<div class="section-content">
<div class="section-inner sectionLayout--insetColumn">
<h2 id="35d6" class="graf graf--h3 graf-after--p">后续步骤和结论</h2>
<p id="3200" class="graf graf--p graf-after--h3">总而言之:</p>
<ul class="postList">
<li id="92fa" class="graf graf--li graf-after--p">JSLint非常适合检查代码片段或单个文件。它的一个潜在缺点是不适合大型项目。</li>
<li id="8f0f" class="graf graf--li graf-after--li">StandardJS非常适合那些想要轻松入门和/或在工作流中构建linter和构建脚本的人。但是，它是不可配置的。因此，如果你需要制定自定义规则，你可能会想看看JSHint或ESLint。</li>
<li id="9934" class="graf graf--li graf-after--li">JSHint也可以通过npm安装，它的林挺规则是完全可配置的。这可能是好的也可能是坏的，取决于你的需求和技能水平。您可以从默认规则开始，并根据需要进行定制。它还提供了一个单页面站点，您可以使用它来lint片段或单个文件。</li>
<li id="e268" class="graf graf--li graf-after--li">ESLint可以通过npm安装，并像JSHint一样内置到工作流中。其CLI的问答格式可以帮助您入门。在其开箱即用的形式，它包括行业标准，开源风格指南和林挺规则，可适用于任何项目。</li>
</ul>
<p id="821d" class="graf graf--p graf-after--li">我们研究的所有四种linters都是可靠的、有信誉的，因为它们是由web开发社区中的知名人士和组织使用和开发的。他们中的任何一个都会给任何人带来好处。如果您已经掌握了本文中讨论的基础知识，下一步将是学习如何使用npm脚本或Webpack之类的捆绑器将它们进一步集成到您的工作流中。</p>
<p id="73a0" class="graf graf--p graf-after--p graf--trailing">任何工具的好坏取决于你如何使用它。这对linters和它们帮助你完善的代码来说都是正确的。即使您是单独开发，并且不需要担心整个开发团队的代码一致性，您仍然可以从内置编辑器中受益。这是学习正确编写JavaScript的非常有效的方法。不管你使用哪种棉绒，使用棉绒只能帮助你。你可以打赌你的代码质量会提高，你作为开发人员的技能也会提高。</p><div class="code-block code-block-27">
<div class="blog-plug inline-plug vanilla-javascript-cta"><h2>通过理解上下文，更容易地调试JavaScript错误</h2>
<p>调试代码总是一项单调乏味的任务。但是你越了解自己的错误，就越容易改正。</p>
<p>LogRocket 让你以新的独特的方式理解这些错误。我们的前端监控解决方案跟踪用户与您的JavaScript前端的互动，让您能够准确找出导致错误的用户行为。</p>
<a href="https://lp.logrocket.com/blg/javascript-signup" class="signup" target="_blank" rel="noopener noreferrer"><img class="alignnone size-full wp-image-46 jetpack-lazy-image" src="../Images/cbfed9be3defcb505e662574769a7636.png" alt="LogRocket Dashboard Free Trial Banner" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2020/06/reproduce-javascript-errors.gif?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/06/reproduce-javascript-errors.gif"/><noscript><img data-lazy-fallback="1" class="alignnone size-full wp-image-46" src="../Images/cbfed9be3defcb505e662574769a7636.png" alt="LogRocket Dashboard Free Trial Banner" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/06/reproduce-javascript-errors.gif"/></noscript></a>
<p>LogRocket记录控制台日志、页面加载时间、堆栈跟踪、慢速网络请求/响应(带有标题+正文)、浏览器元数据和自定义日志。理解您的JavaScript代码的影响从来没有这么简单过！</p>
<a class="signup" href="https://lp.logrocket.com/blg/javascript-signup" target="_blank" rel="noopener noreferrer">Try it for free</a><p>.</p></div>


</div>
</div>
</div>
</section>

 <p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
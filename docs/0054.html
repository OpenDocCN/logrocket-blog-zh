<html>
<head>
<title>How CSS works: Understanding the cascade - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>CSS如何工作:理解cascade - LogRocket博客</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/how-css-works-understanding-the-cascade-d181cd89a4d8/#0001-01-01">https://blog.logrocket.com/how-css-works-understanding-the-cascade-d181cd89a4d8/#0001-01-01</a></blockquote><div><article class="article-post">
<p>几周前，我开始了一个关于CSS基础的简短系列。如果你在前端web开发领域，CSS是需要知道的关键事情之一。无论你是喜欢CSS-in-JS还是喜欢普通的CSS，了解CSS如何工作对于编写高效、可伸缩的CSS是至关重要的。</p>
<p>本系列的第一篇文章深入探讨了浏览器如何将CSS渲染成像素。在这第二篇文章中，我们将深入探讨CSS语言的一个经常被误解的特性——层叠。</p>
<p>层叠是使用CSS所固有的——毕竟，它赋予了“层叠样式表”层叠的本质。cascade可能是一个强大的工具，但是错误地使用它会导致脆弱的样式表，这在前端开发人员必须做出更改的任何时候都会给他们带来噩梦。在我们深入研究级联时，我们还将研究一些防止级联失控的方法。</p>
<h3>定义级联</h3>
<p>因为我们将讨论CSS级联如何工作的细节，所以我们保持一致会很有帮助。</p>
<p>下面是来自<a href="https://www.w3.org/TR/css-cascade-4/#cascading" target="_blank" rel="noopener noreferrer"> CSS级联4级规范</a>的定义。</p>
<blockquote><p>cascade接受给定元素的给定属性的声明值的无序列表，按照声明的优先级对它们进行排序，并输出单个级联值。</p></blockquote>
<p>CSS Cascade是一种算法，浏览器通过它来决定将哪些CSS样式应用于某个元素——许多人喜欢将此视为“获胜”的样式。</p>
<p>为了更好地理解CSS级联，将CSS声明视为具有“属性”是有帮助的。这些属性可以是声明的不同部分，如选择器或CSS属性，也可以与CSS声明所在的<em>相关(如它的来源或在源代码中的位置)。</em></p>
<p>CSS级联获取这些属性中的一些，并给它们分配一个权重。如果一个CSS规则在更高的优先级胜出，那么这个规则将胜出。</p>
<p>但是，如果在给定的权重下有两个规则仍然冲突，算法将继续“向下级联”并检查较低优先级的属性，直到找到获胜的规则。</p>
<p>下面是CSS级联算法检查的属性，按照从<em>最高权重</em>到<em>最低权重</em>的顺序排列。</p>
<ol>
<li>起源和重要性</li>
<li>选择器特异性</li>
<li>出场顺序</li>
<li>初始和继承属性(默认值)</li>
</ol>
<p>不要担心，我们将深入研究每一个问题。</p>
<figure><a href="https://logrocket.com/signup/" target="_blank" rel="noopener noreferrer"><img decoding="async" src="../Images/576491a4328cdae7545b9efa365439da.png" data-height="750" data-width="3212" data-lazy-src="https://storage.googleapis.com/blog-images-backup/1*2H5cnv_UzdWhAwB6KOAOhg.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" class=" jetpack-lazy-image" data-original-src="https://storage.googleapis.com/blog-images-backup/1*2H5cnv_UzdWhAwB6KOAOhg.png"/><noscript><img data-lazy-fallback="1" decoding="async" src="../Images/576491a4328cdae7545b9efa365439da.png" data-height="750" data-width="3212" data-original-src="https://storage.googleapis.com/blog-images-backup/1*2H5cnv_UzdWhAwB6KOAOhg.png"/></noscript></a></figure>
<h4>起源和重要性</h4>
<p>级联检查的最高加权属性是给定规则的<em>重要性</em>和<em>来源</em>的组合。</p>
<p>就CSS规则的起源而言，规则可以来自三个地方。</p>
<ol>
<li><strong><em/></strong>:这些是浏览器为元素提供的默认样式。这就是为什么输入在不同的浏览器上看起来会略有不同，这也是人们喜欢使用CSS重置来确保用户代理样式被覆盖的原因之一。</li>
<li><strong> <em>用户</em> </strong>:这些由浏览器的用户定义和控制。不是每个人都会有一个，但是当人们添加一个时，通常是为了覆盖样式&amp;增加网站的可访问性。</li>
<li><strong> <em>作者</em> </strong>:这是HTML文档声明<em>的CSS。当我们作为前端开发人员写东西时，这是我们能控制的唯一来源。</em></li>
</ol>
<p>CSS声明的<em>重要性</em>由恰当命名的<code>!important</code>语法决定。将<code>!important</code>添加到CSS规则中会自动将它跳到级联算法的前面，这就是为什么它通常不被鼓励的原因。覆盖使用<code>!important</code>的样式只能通过使用<code>!important</code>的其他规则来完成，随着时间的推移，这会使你的CSS变得更加脆弱。许多人(包括我自己)建议你只使用<code>!important</code>作为所有其他方法失败时的逃生出口(比如使用第三方风格)。</p>
<p>级联算法在计算哪个声明胜出时，会考虑这两个属性的组合。每个组合都有一个权重(类似于CSS声明中各部分的权重)，权重最高的声明获胜。以下是浏览器考虑的原产地&amp;重要性的各种组合，按从<em>最高权重</em>到<em>最低权重</em>的顺序排列。</p>
<ol>
<li>用户代理&amp; <code>!important</code></li>
<li>用户&amp; <code>!important</code></li>
<li>作者&amp; <code>!important</code></li>
<li>CSS动画，<code>@keyframes</code>(这是唯一的例外，它仍然来自<em>作者，</em>，但由于动画是临时的/短暂的，浏览器对它们的权重比普通作者规则稍高)</li>
<li>作者，正常体重</li>
<li>用户，正常体重</li>
<li>用户代理，正常体重</li>
</ol>
<p>当浏览器遇到两个(或更多)冲突的CSS声明，并且其中一个在起源和重要性级别上胜出时，CSS级联会解决该规则。不问任何问题。游戏结束。</p>
<p>然而，如果冲突的声明具有相同的重要性/来源级别，级联将继续考虑<em>选择器的特异性。</em></p>
<h4>选择器特异性</h4>
<p>CSS级联中的第二个权重是<em>选择器特异性。</em>在这一层，浏览器查看CSS声明中使用的<em>选择器</em>。</p>
<p>作为一名前端开发人员，您只能控制网站上的“作者”来源样式表——您无法改变规则的<em>来源</em>。然而，如果你不在代码中使用<code>!important</code>,你会发现你在特殊性层对级联有很多控制。</p><div class="code-block code-block-54">
<hr/>
<h3>更多来自LogRocket的精彩文章:</h3>

<hr/></div>
<p>类似于origin和importance的组合都有自己的权重，不同类型的CSS选择器被分配优先级。在评估特异性时，需要考虑选择器的数量及其优先级。CSS选择器可以属于以下加权层之一。</p>
<ol>
<li>内嵌样式(任何在<code>style</code>标签内的东西)</li>
<li>ID选择器</li>
<li>类/伪选择器</li>
<li>类型选择器(例如，<code>h1</code> ) &amp;伪元素(<code>::before</code>)</li>
</ol>
<p>如果有两个CSS声明具有相同数量的高优先级选择器，解析算法将考虑下一个特定级别的选择器数量。例如，如果这两个CSS规则都针对同一个元素，则颜色将是红色。这是因为它们都有1个<code>id</code>选择器，但是第二个规则有2个<code>class</code>选择器。</p>
<pre>#first .blue h1 {
  color: blue;
}
#second .red.bold h1 {
  color: red;
}</pre>
<p>许多人喜欢通过简单地<em>不依赖它</em>来管理特殊性。保持选择器特异性较低可以确保CSS规则保持灵活性。</p>
<p>根据我的经验，如果你默认只使用<code>class</code>选择器来定制你的样式，使用<code>element</code>选择器来定制你的默认样式，当你真正需要的时候，<em>方式</em>更容易覆盖样式。如果你的CSS声明有非常高的选择器特异性，你会发现自己更多地求助于<code>!important</code>，这可能会很快变得很糟糕。</p>
<h4>来源订单</h4>
<p>CSS级联算法的最后一个主要层是通过<em>源顺序</em>进行解析。当两个选择器具有相同的特异性时，源代码中最后出现的声明获胜。</p>
<p>因为CSS考虑级联中的源代码顺序，所以加载样式表的顺序实际上很重要。如果在HTML文档的头部链接了两个样式表，第二个样式表将覆盖第一个样式表中的规则。这也是为什么如果你使用CSS重置或者CSS框架，你会想在你的自定义样式之前加载那个<em>。</em></p>
<h4>初始和继承的属性</h4>
<p>虽然初始值和继承值并不是CSS级联的真正组成部分，但它们确实决定了如果没有针对元素的CSS声明会发生什么。通过这种方式，它们决定了元素的默认值。</p>
<p>继承的属性将从父元素向下渗透到子元素。例如，<code>font-family</code> &amp; <code>color</code>属性被继承。这种行为是大多数人看到“层叠”这个词时想到的，因为风格会渗透到他们的孩子身上。</p>
<p>在下面的例子中，<code>&lt;p&gt;</code>标签将用等宽字体&amp;红色文本呈现，因为它的父节点包含这些样式。</p>
<pre><code>&lt;div style="font-family: monospace; color: red;"&gt;
  &lt;p&gt;inheritance can be super useful!&lt;/p&gt;
&lt;/div&gt;</code></pre>
<p>对于非继承属性，每个元素都有一组<em>初始值— </em>这些值是在CSS规范中为任何给定的规则定义的。例如，<code>background-color</code>属性的初始值是<code>transparent</code>。如果没有CSS声明为元素上的<code>background-color</code>设置值，它将默认为<code>transparent</code>。</p>
<p>此外，通过在CSS规则中使用<code>inherit</code>或<code>initial</code>关键字，您可以明确地选择在CSS声明中使用继承值或初始值。</p>
<pre>div {
  background-color: initial;
  color: inherit;
}</pre>
<h3>理解级联如何帮助我写出更好的CSS？</h3>
<p>由于CSS级联是CSS中最容易被误解的部分之一(通常是许多错误的来源)，了解它的工作原理将会给你保持样式表可维护性带来巨大的优势。</p>
<p>知道如何利用CSS选择器的特异性是一项巨大的技能——我已经看到太多的CSS直接进入了<code>!important</code> escape hatch，而一个更高特异性的选择器就可以做到这一点。如果你主要使用类选择器，当<em>需要</em>覆盖时，你可以通过嵌套选择器或添加另一个类来轻松实现。</p>
<p>然而，随着对CSS级联的了解越来越多，责任也越来越大。级联中更具体的部分(比如<code>!important</code>、内联样式、id选择器)往往会导致样式表在将来更难更新或覆盖。如果您使用的是使用内联样式的组件库或您无法控制的CSS库，那么它们确实很方便。</p><div class="code-block code-block-25">
<div class="blog-plug inline-plug css-plug"><h2>你的前端是否占用了用户的CPU？</h2><p>随着web前端变得越来越复杂，资源贪婪的特性对浏览器的要求越来越高。如果您对监控和跟踪生产环境中所有用户的客户端CPU使用、内存使用等感兴趣，</p><a target="_blank" href="https://lp.logrocket.com/blg/css-signup">try LogRocket</a><p>.</p><a class="signup" href="https://lp.logrocket.com/blg/css-signup" target="_blank" rel="noopener noreferrer"><img class="alignnone size-full wp-image-46 jetpack-lazy-image" src="../Images/dacb06c713aec161ffeaffae5bd048cd.png" alt="LogRocket Dashboard Free Trial Banner" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2019/12/cpu-memory-usage.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/12/cpu-memory-usage.png"/><noscript><img data-lazy-fallback="1" class="alignnone size-full wp-image-46" src="../Images/dacb06c713aec161ffeaffae5bd048cd.png" alt="LogRocket Dashboard Free Trial Banner" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/12/cpu-memory-usage.png"/></noscript></a><a href="https://lp.logrocket.com/blg/css-signup" target="_blank" rel="noopener noreferrer">https://logrocket.com/signup/</a><p>LogRocket 就像是网络和移动应用的DVR，记录你的网络应用或网站上发生的一切。您可以汇总和报告关键的前端性能指标，重放用户会话和应用程序状态，记录网络请求，并自动显示所有错误，而不是猜测问题发生的原因。</p><p>现代化您调试web和移动应用的方式— <a class="signup" href="https://lp.logrocket.com/blg/css-signup" target="_blank" rel="noopener noreferrer">开始免费监控</a>。</p></div>
</div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
<html>
<head>
<title>TypeScript enums vs. types for writing readable code - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>类型脚本枚举与用于编写可读代码的类型</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/writing-readable-code-with-typescript-enums-a84864f340e9/#0001-01-01">https://blog.logrocket.com/writing-readable-code-with-typescript-enums-a84864f340e9/#0001-01-01</a></blockquote><div><article class="article-post">
<p>TypeScript(您可能已经知道)是一种开源、强类型、面向对象的编译语言，由微软团队开发和维护。它是带有静态类型选项的JavaScript的超集。它是为开发编译成JavaScript的大型可伸缩应用程序而设计的。</p>
<h2>什么是枚举？</h2>
<p>在大多数面向对象的编程语言中，如C、C#和Java，有一种数据类型我们称之为枚举，简称enums。Java枚举是一种特殊的Java类，用于定义常量集合。然而，JavaScript没有enum数据类型，但是幸运的是，从版本2.4 开始，它们现在<a href="https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-4.html" target="_blank" rel="noopener noreferrer">在TypeScript中可用。</a></p>
<p>枚举允许我们定义或声明相关值的集合，这些值可以是数字或字符串，作为一组命名的常量。与TypeScript中的某些可用类型不同，枚举是经过预处理的，不会在编译时或运行时进行测试。</p>
<h2>为什么是enums？</h2>
<p>枚举只是在TypeScript中组织代码的一种有用方式。以下是枚举派上用场的一些原因:</p>
<ul>
<li>使用枚举，您可以创建易于关联的常数，使常数更易于阅读</li>
<li>开发人员可以自由地用JavaScript创建节省内存的自定义常量。众所周知，JavaScript不支持枚举，但是TypeScript可以帮助我们访问它们</li>
<li>如前所述，TypeScript枚举通过JavaScript中的内联代码节省了运行时和编译时间(我们将在本文后面看到)</li>
<li>类型脚本枚举还提供了一定的灵活性，这是我们以前只有在Java这样的语言中才有的。这种灵活性使得表达和记录我们的意图和用例变得容易</li>
</ul>
<h2>枚举语法</h2>
<p>枚举是用enum关键字定义的，如下所示:</p>
<pre>enum Continents {
    North_America,
    South_America,
    Africa,
    Asia,
    Europe,
    Antartica,
    Australia
}

// usage
var region = Continents.Africa;</pre>
<h2>类型脚本枚举的类型</h2>
<p>有三种类型的类型脚本枚举，即:</p>
<ol>
<li>数字枚举</li>
<li>字符串枚举</li>
<li>异质枚举</li>
</ol>
<h3>数字枚举</h3>
<p>默认情况下，TypeScript枚举是基于数字的。这意味着它们可以将字符串值存储为数字。可以将数字以及与其兼容的任何其他类型分配给枚举的实例。假设我们想存储周末的天数。TypeScript中表示枚举的形式如下:</p>
<pre>enum Weekend {
  Friday,
  Saturday,
  Sunday
}</pre>
<p>在上面的代码块中，我们有一个名为<code>Weekend</code>的枚举。枚举有三个值:<code>Friday</code>、<code>Saturday</code>和<code>Sunday</code>。在TypeScript中，就像在其他一些语言中一样，枚举值从零开始，每个成员增加1。它们将按如下方式存储:</p>
<pre>Friday = 0
Saturday = 1
Sunday = 2</pre>
<p>我们看到枚举总是被分配存储的数字；尽管我们可以用自己的逻辑定制存储值，但该值总是取数值零。</p>
<h4>自定义数字枚举</h4>
<p>在TypeScript中，允许我们指定枚举的第一个数值。使用上面的周末示例，我们可以像这样初始化第一个数值:</p>
<pre>enum Weekend {
  Friday = 1,
  Saturday,
  Sunday
}</pre>
<p>上面的代码块将把<code>Friday</code>存储为<code>1</code>、<code>Saturday</code>存储为<code>2</code>、<code>Sunday</code>存储为<code>3</code>。如果我们给第一个成员加一个数，我们仍然会给其余的成员加一。然而，我们有权力通过给它们任何数值来决定我们不需要一个连续的轨迹。下面的代码块是语义的，在TypeScript中工作:</p>
<pre>enum Weekend {
  Friday = 1,
  Saturday = 13,
  Sunday = 5
}</pre>
<p>就像TypeScript中的其他数据类型一样，我们可以使用枚举作为函数参数或返回类型，如下所示:</p>
<pre>enum Weekend {
  Friday = 1,
  Saturday,
  Sunday
}
function getDate(Day: string): Weekend {
    if ( Day === 'TGIF') {
        return Weekend.Friday;
    }
 }
let DayType: Weekend = getDate('TGIF');</pre>
<p>我们在上面声明了一个<code>Weekend</code>枚举。然后我们声明了一个接受输入<code>Day</code>的<code>getDate</code>函数，该函数返回一个<code>Weekend</code>枚举。在函数中，我们检查一些现在返回枚举成员的条件。</p>
<h4>计算枚举</h4>
<p>与TypeScript中的任何其他数字数据类型一样，数值枚举的值可以是常量，也可以是计算值。您可以使用计算值定义或初始化数值枚举:</p>
<pre>enum Weekend {
  Friday = 1,
  Saturday = getDate('TGIF'),
  Sunday = Saturday * 40
}

function getDate(day : string): number {
    if (day === 'TGIF') {
        return 3;
    }
}
Weekend.Saturday; // returns 3
Weekend.Sunday; // returns 120</pre>
<p>当枚举包含计算成员和常数成员时，未初始化的枚举成员要么在前面，要么必须跟在其他具有数字常数的已初始化成员后面。</p>
<p>忽略上述规则会导致初始化错误；如果看到这种情况，记得相应地重新排列枚举成员。</p>
<h4>常数枚举</h4>
<p>如果想提高数值枚举的性能，可以将它们声明为常量。让我们用周末的例子来说明:</p>
<pre>enum Weekend {
  Friday = 1,
  Saturday,
  Sunday
}
var day = Weekend.Saturday;</pre>
<p>编译成JavaScript时，运行时查找<code>Weekend</code>，执行时查找<code>Weekend.Saturday</code>。为了在运行时获得最佳性能，您可以将枚举改为常量，如下所示:</p>
<pre>const enum Weekend {
  Friday = 1,
  Saturday,
  Sunday
}
var day = Weekend.Saturday;</pre>
<p>编译时使用常数生成的JavaScript是:</p>
<pre>var day = 2;</pre>
<p>我们看到编译器只是内联enum用法，当它看到<code>const</code>时，甚至懒得为enum声明生成JavaScript。当您有需要数字到字符串或字符串到数字查找的用例时，了解这种选择以及可能导致的后果是很重要的。</p>
<p>也可以传递编译器标志<code>preserveConstEnums</code>，它仍然会生成<code>Weekend</code>定义。</p>
<h3>字符串枚举</h3>
<p>到目前为止，我们只看了数字枚举，其中的成员值是数字。在TypeScript中，枚举成员也可以是字符串值。<a href="https://blog.logrocket.com/typescript-string-enums-guide/" target="_blank" rel="noopener">字符串枚举</a>由于其有意义的字符串值，所以在错误记录和调试期间，出于可读性的目的，字符串枚举是至关重要且易于处理的。</p>
<pre>enum Weekend {
  Friday = 'FRIDAY',
  Saturday = 'SATURDAY',
  Sunday = 'SUNDAY'
}</pre>
<p>然后，它可以用于比较条件语句中的字符串，如下所示:</p>
<pre>enum Weekend {
  Friday = 'FRIDAY',
  Saturday = 'SATURDAY',
  Sunday ='SUNDAY'
}
const value = someString as Weekend;
if (value === Weekend.Friday || value === Weekend.Sunday){
    console.log('You choose a weekend');
    console.log(value); 
}</pre>
<p>在上面的例子中，我们定义了一个字符串枚举，<code>Weekend</code>，就像上面的数字枚举一样，但是这次枚举值是字符串。</p>
<p>数字枚举和字符串枚举的明显区别在于，数字枚举值大多是自动按顺序递增的，而字符串枚举值不会递增；相反，每个值都是独立初始化的。</p>
<h3>异质枚举</h3>
<p>TypeScript还允许混合使用字符串和数字，称为异类枚举值:</p>
<pre>enum Weekend {
  Friday = 'FRIDAY',
  Saturday = 1,
  Sunday = 2
}</pre>
<p>尽管这是可能的，但是可能需要这个用例的场景范围确实很小。因此，除非我们真的试图以一种巧妙的方式利用JavaScript的运行时行为，否则建议我们不要使用异构枚举。</p>
<h2>反向映射</h2>
<p>TypeScript枚举支持反向映射，这仅仅意味着正如我们可以访问枚举成员的值一样，我们也可以访问枚举名称本身。我们将使用第一次演示的样本来描述这一点:</p>
<pre>enum Weekend {
  Friday = 1,
  Saturday,
  Sunday
}
Weekend.Saturday     
Weekend["Saturday"];  
Weekend[2];</pre>
<p>在上面的代码块中，<code>Weekend.Saturday</code>将返回<code>2</code>，然后<code>Weekend["Saturday"]</code>也将返回<code>2</code>。然而有趣的是，由于反向映射，<code>Weekend[2]</code>将返回其成员名称<code>Saturday</code>。我们可以看到TypeScript用log命令解释反向映射的一种简单方式:</p>
<pre>enum Weekend {
  Friday = 1,
  Saturday,
  Sunday
}
console.log(Weekend);</pre>
<p>如果在控制台中运行，您将看到以下输出:</p>
<pre>{
  '1': 'Friday',
  '2': 'Saturday',
  '3': 'Sunday',
  Friday   : 1,
  Saturday : 2,
  Sunday  : 3
}</pre>
<p>对象包含既作为值又作为名称出现的枚举，正如类型脚本所预期的那样。这显示了TypeScript中反向映射的能力。</p>
<h2>TypeScript枚举最佳实践</h2>
<p>在某些用例中，使用枚举是最佳和有效的。也有这样的情况，你应该<a href="https://blog.logrocket.com/put-the-typescript-enums-and-booleans-away/">把枚举放在一边</a>。下面，我们将讨论TypeScript枚举的最佳实践以及何时使用替代方法。</p>
<h3>何时使用类型脚本枚举</h3>
<p>枚举应该理想地用在存在可以被视为常量的不同值的情况下，例如一周七天:</p>
<pre>enum Days {
  Sunday = 1,
  Monday,
  Tuesday,
  Wednesday,
  Thursday,
  Friday,
  Saturday
}</pre>
<p>枚举可以像其他TypeScript数据类型一样在数组初始化中使用。这里有一个简单的例子:</p>
<pre>enum NigerianLanguage {
  Igbo,
  Hause, 
  Yoruba
}

//can be used in array initialisation 
let citizen = {
  Name: 'Ugwunna',
  Age: 75,
  Language: NigerianLanguage.Igbo
}
</pre>
<p>枚举也可以用在需要在变量中表示字符串或常量的地方。</p>
<h3>类型脚本枚举与替代</h3>
<p>TypeScript枚举不适用于下列情况:</p>
<ul>
<li>当您计划重新分配或更改枚举成员值时，枚举是类型安全的，因此在重新分配时会返回编译错误</li>
<li>当您想要记录动态值时，枚举最适合有限的项，其背后的一般思想是帮助创建一个用户定义的常量系统</li>
<li>枚举不能用作变量；这样做会返回错误</li>
</ul>
<h2>结论</h2>
<p>我们已经能够很好地了解TypeScript中的枚举，包括它们的类型和属性。我们还看到了它们的语法和使用实例。我们看到了其他重要的枚举方面，如枚举中的常数、计算枚举，甚至反向映射。</p>
<p>值得注意的是，对于字符串枚举，不支持反向映射。此外，对于异类成员，它只支持数字类型成员，而不支持字符串类型成员。编码快乐！</p>
<h3>延伸阅读:</h3>

<p><a class="signup" href="https://lp.logrocket.com/blg/typescript-signup" target="_blank" rel="noopener noreferrer"> LogRocket </a>:全面了解您的网络和移动应用</p><div class="code-block code-block-21">
<div class="blog-plug inline-plug typescript-plug"><h2>LogRocket 是一个前端应用程序监控解决方案，可以让您回放问题，就像问题发生在您自己的浏览器中一样。LogRocket不需要猜测错误发生的原因，也不需要向用户询问截图和日志转储，而是让您重放会话以快速了解哪里出错了。它可以与任何应用程序完美配合，不管是什么框架，并且有插件可以记录来自Redux、Vuex和@ngrx/store的额外上下文。</h2>
<a href="https://lp.logrocket.com/blg/typescript-signup" class="signup" target="_blank" rel="noopener noreferrer"><img class="alignnone size-full wp-image-46 jetpack-lazy-image" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/><noscript><img data-lazy-fallback="1" class="alignnone size-full wp-image-46" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/></noscript></a>
<p>除了记录Redux操作和状态，LogRocket还记录控制台日志、JavaScript错误、堆栈跟踪、带有头+正文的网络请求/响应、浏览器元数据和自定义日志。它还使用DOM来记录页面上的HTML和CSS，甚至为最复杂的单页面和移动应用程序重新创建像素级完美视频。</p>
<p>.</p>
<a class="signup" href="https://lp.logrocket.com/blg/typescript-signup" target="_blank" rel="noopener noreferrer">Try it for free</a><p>.</p></div>
</div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
<html>
<head>
<title>5 things you didn't know you can do in CSS-in-JS - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>在CSS-in-JS - LogRocket博客中你不知道可以做的5件事</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/5-things-you-can-do-css-in-js/#0001-01-01">https://blog.logrocket.com/5-things-you-can-do-css-in-js/#0001-01-01</a></blockquote><div><article class="article-post">
<p><em> <strong>编者按:</strong>为了准确和清晰，这篇文章最后一次更新是在2021年7月29日。要了解更多关于CSS-in-JS的最新信息，您还可以<a href="https://blog.logrocket.com/comparing-the-top-zero-runtime-css-in-js-libraries/">查看这篇关于CSS-in-JS库</a>的文章。</em></p>
<h2>CSS-in-JS解决的是什么？</h2>
<p>除了传统的CSS，内联样式和CSS-in-JS也可以用来对React应用程序进行样式化。</p>
<p>尽管内联样式允许您将JavaScript对象传递给style属性(如下面的代码片段所示)，但它并不支持所有的CSS特性:</p>
<pre>import React from "react";

function App() {
  const myStyle = {
    fontSize: 24,
    lineHeight: "1.3em",
    fontWeight: "bold"
  };

  return (
    &lt;div&gt;
      &lt;p style={myStyle}&gt;Hello world&lt;/p&gt;
    &lt;/div&gt;
  );
}
export default App;
</pre>
<p>另一方面，CSS-in-JS库像<a href="https://github.com/Khan/aphrodite">阿芙罗狄蒂</a>、<a href="https://styled-components.com"> styled-components </a>、<a href="https://cssinjs.org/?v=v10.7.1"> JSS </a>、<a href="https://emotion.sh/docs/introduction">情感</a>、<a href="https://formidable.com/open-source/radium/">镭</a>等。让开发人员不仅能够用JavaScript设计组件的样式，还能够解决一些CSS限制，例如在使用它们时缺乏动态功能、作用域和可移植性:</p>
<pre>// Here's an implementation of the inline style code snippet above using Aphrodite

import React from "react";
import { StyleSheet, css } from "aphrodite";

function App() {
  const styles = StyleSheet.create({
    myStyle: {
      fontSize: 24,
      lineHeight: "1.3em",
      fontWeight: "bold"
    }
  });
  return (
    &lt;div&gt;
      &lt;span className={css(styles.myStyle)}&gt;Hello World!&lt;/span&gt;
    &lt;/div&gt;
  );
}
export default App;
</pre>
<p>在本文中，我将重点介绍使用上述CSS-in-JS库作为案例研究，在CSS-in-JS中可以做的五件事。👇</p>
<h2>1.CSS-in-JS允许您引用其他样式的组件</h2>
<p>像styled-components和Emotion这样的库允许您使用<a href="https://blog.logrocket.com/build-your-own-styled-components-library/#taggedtemplateliterals">标记的模板文字</a>从样式中创建React组件:</p>
<pre>// Create a component that renders a &lt;p&gt; element with blue text
import React from "react";
import styled from "styled-components";

function App() {
  const BlueText = styled.p`
    color: blue;
  `;

  return (
    &lt;div&gt;
      &lt;BlueText&gt;My blue text&lt;/BlueText&gt;
    &lt;/div&gt;
  );
}

export default App;
</pre>
<p>但是它们也允许你瞄准其他样式的组件(就像你使用CSS选择器一样):</p>
<pre>import React from "react";
import styled from "styled-components";

function App() {
  const ImportantText = styled.div`
    font-weight: bold;
  `;

  const Text = styled.div`
    color: gray;
    ${ImportantText} {
      font-style: italic;
    }
  `;

  return (
    &lt;div&gt;
      &lt;Text&gt;
        Text in gray
        &lt;ImportantText&gt;Important text in gray, bold and italic&lt;/ImportantText&gt;
      &lt;/Text&gt;
      &lt;ImportantText&gt;Important text bold&lt;/ImportantText&gt;
    &lt;/div&gt;
  );
}

export default App;
</pre>
<p>当它与伪类结合时，这是有用的；例如，要更改悬停时组件的颜色:</p>
<pre>import React from "react";
import styled from "styled-components";

function App() {
  const ImportantText = styled.div`
    font-weight: bold;
  `;

  const Text = styled.div`
    color: gray;
    &amp;:hover ${ImportantText} {
      color: red;
    }
  `;

  return (
    &lt;div&gt;
      &lt;Text&gt;
        Text in gray
        &lt;ImportantText&gt;Important text in gray, bold and italic&lt;/ImportantText&gt;
      &lt;/Text&gt;
      &lt;ImportantText&gt;Important text bold&lt;/ImportantText&gt;
    &lt;/div&gt;
  );
}

export default App;
</pre>
<h2>2.JSS(或其他库)可以扩展一些库的功能</h2>
<p>假设您已经使用Aphrodite来设计您的应用程序，现在您需要支持主题。</p>
<p>问题是阿芙罗狄蒂不容易支持主题化。至少，不像情感那么容易。</p>
<p>然而，有两个项目将JSS的核心与Aphrodite和styled-components联系起来:aphrodite-jss和styled-jss。</p>
<p>这样，你可以保留Aphrodite(或styled-components)的优秀部分，并使用JSS的所有特性和<a href="http://cssinjs.org/plugins" target="_blank" rel="noopener noreferrer">插件</a>，从规则缓存到规则隔离，对于主题，<a href="https://github.com/cssinjs/theming" target="_blank" rel="noopener noreferrer"> theming </a>包提供了以下高阶组件:</p>
<ul>
<li><code>ThemeProvider</code>，它通过上下文将主题对象沿React树向下传递</li>
<li><code>withTheme</code>，它允许你接收一个主题对象，它作为一个属性更新</li>
</ul>
<p>例如:</p>
<pre>import React from "react";
import { createUseStyles, ThemeProvider, useTheme } from "react-jss";

function App() {
  const useStyles = createUseStyles({
    wrapper: {
      padding: 40,
      background: ({ theme }) =&gt; theme.background,
      textAlign: "left"
    },
    title: {
      font: {
        size: 40,
        weight: 900
      },
      color: ({ theme }) =&gt; theme.color
    },
    link: {
      color: ({ theme }) =&gt; theme.color,
      "&amp;:hover": {
        opacity: 0.5
      }
    }
  });

  const Comp = () =&gt; {
    const theme = useTheme();
    const classes = useStyles({ theme });
    return (
      &lt;div className={classes.wrapper}&gt;
        &lt;h1 className={classes.title}&gt;Hello There!&lt;/h1&gt;
      &lt;/div&gt;
    );
  };

  const theme = {
    background: "blue",
    color: "white"
  };

  return (
    &lt;div&gt;
      &lt;ThemeProvider theme={theme}&gt;
        &lt;Comp /&gt;
      &lt;/ThemeProvider&gt;
    &lt;/div&gt;
  );
}

export default App;
</pre>
<p>在阿芙罗狄蒂和主题的特殊情况下，作为另一个例子，您还可以使用<a href="https://github.com/airbnb/react-with-styles" target="_blank" rel="noopener noreferrer"> react-with-styles </a>，它与阿芙罗狄蒂和JSS等接口，以在定义样式时访问主题信息。</p>
<h2>3.CSS-in-JS可以用关键帧链接多个动画</h2>
<p>与内联样式不同，CSS-in-JS允许您使用关键帧来定义动画。</p>
<p>例如，这是对样式化组件的处理方式:</p>
<pre>import React from "react";
import styled, { keyframes } from "styled-components";

function App() {
  const MoveAnimation = keyframes`
  0% {
    transform: translate(0, 0);
  }
  50% {
    transform: translate(50px, 0);
  }
`;

  const MyComponent = styled.div`
    display: inline-block;
    margin: 50px;
    width: 200;
    position: relative;
    animation: ${MoveAnimation} 1.5s ease infinite;
  `;

  return (
    &lt;div&gt;
      &lt;MyComponent&gt;Hello There!&lt;/MyComponent&gt;
    &lt;/div&gt;
  );
}

export default App;
</pre>
<p>但是没有多少人知道的是，可以通过在<code>animation</code>属性中使用多个关键帧对象来链接多个动画。</p>
<p>下面是上面的例子，修改后合并了两个动画:</p>
<pre>import React from "react";
import styled, { css, keyframes } from "styled-components";

function App() {
  const MoveAnimation = keyframes`
  0% {
    transform: translate(0, 0);
  }
  50% {
    transform: translate(50px, 0);
  }
`;

  const ColorAnimation = keyframes`
  from {color: red;}
  to {color: blue;}
`;

  const MyComponent = styled.div`
    display: inline-block;
    margin: 50px;
    width: 200;
    position: relative;
    animation: ${(props) =&gt; css`
      ${MoveAnimation} 1.5s ease infinite,
      ${ColorAnimation} 1.5s linear infinite
    `};
  `;

  return (
    &lt;div&gt;
      &lt;MyComponent&gt;Hello There!&lt;/MyComponent&gt;
    &lt;/div&gt;
  );
}

export default App;
</pre>
<h2>4.你可以用CSS-in-JS声明全局样式</h2>
<p>CSS中的一切都是全局的，使用CSS-in-JS的目的之一就是消除全局样式定义。</p>
<p>但是，可能存在全局样式的有效使用；例如，当您希望对页面中的每个元素应用相同的字体样式时。</p>
<p>当然，你可以一直使用传统的CSS，通过Webpack导入或者在<code>index.html</code>文件中声明。</p>
<p>但是如果你真的想把JavaScript用于你的所有风格，一些库实际上允许你通过帮助组件或扩展/插件来定义全局风格。</p>
<p>在Radium中，您可以使用<a href="https://github.com/FormidableLabs/radium/tree/master/docs/api#style-component" target="_blank" rel="noopener noreferrer"> Style </a>组件来呈现带有全局样式的样式元素。</p>
<p>例如:</p>
<pre>&lt;Style
  rules={{
    body: {
      fontFamily: 'Arial, Helvetica, sans-serif'
    }
  }}
/&gt;</pre>
<p>将返回:</p>
<pre>&lt;style&gt;
body {
  font-family: 'Arial, Helvetica, sans-serif';
}
&lt;/style&gt;</pre>
<p>JSS使用一个<a href="https://cssinjs.org/jss-plugin-global/?v=v10.7.1">插件</a>来编写全局样式:</p>
<pre>const styles = {
  '@global': {
    body: {
      fontFamily: 'Arial, Helvetica, sans-serif'
    }
  }
}</pre>
<p>它将返回:</p>
<pre>body {
  font-family: 'Arial, Helvetica, sans-serif';
}
</pre>
<p>在Aphrodite中，你可以使用第三方扩展来创建样式。例如:</p>
<pre>import {injectGlobalStyles} from "aphrodite-globals";

injectGlobalStyles({
    "body": {
          fontFamily: 'Arial, Helvetica, sans-serif',
    }
});</pre>
<p>这将返回:</p>
<pre>    body {
      font-family: 'Arial, Helvetica, sans-serif';
    }
</pre>
<h2>5.一些CSS-in-JS库可以在单元测试中用样式测试组件</h2>
<p>有些库包含用于测试带有样式的组件的实用程序。</p>
<p>Aphrodite提供了一个未记录的(至少在撰写本文时)对象，<a href="https://github.com/Khan/aphrodite/blob/62ee2f0a39f10be75322dc0f77d1346e9731ffbf/src/exports.js#L98" target="_blank" rel="noopener noreferrer">stylesheetestutils</a>，它只适用于非生产环境(<code>process.env.NODE_ENV !== 'production'</code>)，有三个方法:</p>
<ul>
<li><code>suppressStyleInjection</code>，它防止样式被注入到DOM中，当您想要在没有DOM的情况下测试Aphrodite组件的输出时，它非常有用</li>
<li><code>clearBufferAndResumeStyleInjection</code>，与<code>suppressStyleInjection</code>相反，应该与之配对</li>
<li><code>getBufferedStyles</code>，返回一串尚未刷新的缓冲样式</li>
</ul>
<p>这里有一个如何使用它们的例子:</p>
<pre>import { StyleSheetTestUtils, css } from 'aphrodite';
//...

beforeEach(() =&gt; {
  StyleSheetTestUtils.suppressStyleInjection();
});

afterEach(() =&gt; {
  StyleSheetTestUtils.clearBufferAndResumeStyleInjection();
});

test('my test', () =&gt; {
  const sheet = StyleSheet.create({
    background: {
      backgroundColor: 'blue'
    },
  });
  css(sheet.background);

 const buffer = StyleSheetTestUtils.getBufferedStyles();
});</pre>
<p>镭是另一个例子。它有一个<a href="https://github.com/FormidableLabs/radium/tree/master/docs/api#testmode" target="_blank" rel="noopener noreferrer"> TestMode </a>对象，用于在使用<code>clearState</code>、<code>enable</code>和<code>disable</code>方法进行测试时控制内部状态和行为。</p>
<p>在这里，你可以找到一个如何使用测试模式的例子。</p>
<h2>结论</h2>
<p>CSS-in-JS是一种用JavaScript设计应用程序的技术，您可以用实现它的库做一些有趣的事情。</p>
<p>在这篇文章中，我向你展示了你可能不知道可以用这些库做的五件事。当然，<a href="https://blog.logrocket.com/comparing-the-top-zero-runtime-css-in-js-libraries/">并不是所有的库都是生而平等的</a>，有些东西只适用于特定的库。</p>
<p>看看这个<a href="https://css-in-js-playground.com">游乐场，在这里你可以测试和比较许多CSS-in-JS库</a>。</p>
<p>另一方面，也有其他库将CSS、JavaScript和类型的概念发展得更进一步。</p>
<p>其中一个库是<a href="https://github.com/wix/stylable" target="_blank" rel="noopener noreferrer"> stylable </a>，这是一个基于组件的库，带有一个预处理器，可以将stylable的CSS转换成最小的跨浏览器的普通CSS。</p><div class="code-block code-block-17">
<div class="blog-plug inline-plug react-plug" vwo-el-id="26283398190">
<h2 vwo-el-id="41600691720">使用LogRocket消除传统反应错误报告的噪音</h2>
<a href="https://lp.logrocket.com/blg/react-signup-issue-free" target="_blank" vwo-el-id="19356441070">LogRocket
</a><p>是一款React analytics解决方案，可保护您免受数百个误报错误警报的影响，只针对少数真正重要的项目。LogRocket告诉您React应用程序中实际影响用户的最具影响力的bug和UX问题。</p><a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="19356441380">
<img class="first-react-image alignnone size-full wp-image-46 jetpack-lazy-image jetpack-lazy-image--handled" src="../Images/f300c244a1a1cf916df8b4cb02bec6c6.png" vwo-el-id="18272717540" data-lazy-loaded="1" data-original-src="https://files.readme.io/27c94e7-Image_2017-06-05_at_9.46.04_PM.png"/>
</a>
<a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="19356441690">
<img class="second-react-image alignnone size-full wp-image-46 jetpack-lazy-image jetpack-lazy-image--handled" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" vwo-el-id="30720362350" data-lazy-loaded="1" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/>
</a>
<a href="https://lp.logrocket.com/blg/react-signup-issue-free" target="_blank" rel="noopener noreferrer" vwo-el-id="35866400580">LogRocket
</a><p>自动聚合客户端错误、反应错误边界、还原状态、缓慢的组件加载时间、JS异常、前端性能指标和用户交互。然后，LogRocket使用机器学习来通知您影响大多数用户的最具影响力的问题，并提供您修复它所需的上下文。</p><p vwo-el-id="28675661060">关注重要的React bug—<a class="signup" href="https://lp.logrocket.com/blg/react-signup-issue-free" target="_blank" rel="noopener noreferrer" vwo-el-id="40093418840">今天就试试LogRocket】。</a></p>
</div></div>
<figure><a href="https://logrocket.com/signup/" target="_blank" rel="noopener noreferrer"><img decoding="async" src="../Images/94b3e0f84b30cb0d321f60471481ab64.png" data-height="750" data-width="3212" data-lazy-src="https://storage.googleapis.com/blog-images-backup/1*GPjaPKNNUYHU8EsA3Z0JGA.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" class=" jetpack-lazy-image" data-original-src="https://storage.googleapis.com/blog-images-backup/1*GPjaPKNNUYHU8EsA3Z0JGA.png"/><noscript><img data-lazy-fallback="1" decoding="async" src="../Images/94b3e0f84b30cb0d321f60471481ab64.png" data-height="750" data-width="3212" data-original-src="https://storage.googleapis.com/blog-images-backup/1*GPjaPKNNUYHU8EsA3Z0JGA.png"/></noscript></a></figure>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
<html>
<head>
<title>Real use cases for named tuples in TypeScript - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>TypeScript - LogRocket博客中命名元组的真实用例</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/use-cases-named-tuples-typescript/#0001-01-01">https://blog.logrocket.com/use-cases-named-tuples-typescript/#0001-01-01</a></blockquote><div><article class="article-post">
<h2>介绍</h2>
<p>元组扩展了数组数据类型的功能。使用元组，我们可以很容易地构造特殊类型的数组，其中元素相对于索引或位置是固定类型的。由于TypeScript的性质，这些元素类型在初始化时是已知的。本质上，使用元组，我们可以定义可以存储在数组中每个位置的数据类型。</p>
<p>元组更像是高级数组，具有确保类型安全的额外特性，特别是在我们需要考虑包含固定数量的多种已知类型元素的列表的情况下。</p>
<p>数组和元组之间的主要区别在于，当我们给元组赋值时，这些值必须以相同的顺序匹配元组声明中定义的类型。另一方面，数组可以使用<code>any</code>类型或按位OR ( <code>|</code>)运算符支持多种类型，但是元素的顺序或结构不起作用。</p>
<p>在本教程中，我们将介绍TypeScript中命名元组的真实用例及应用。我们将了解这种数据类型的重要性，以及为什么在某些情况下它是首选。</p>
<p>最终，我们将亲眼看到这种数据类型如何有助于改进TypeScript语言，根据改进的文档、可维护的代码和开发人员的生产力，允许更严格的规则。</p>
<h3>先决条件</h3>
<p>在我们开始之前，读者应该熟悉TypeScript和一般类型的基础知识。要了解关于这个主题的更多信息，请查看TypeScript文档的这一<a href="https://www.typescriptlang.org/docs/handbook/basic-types.html">部分</a>。现在让我们开始吧。</p>
<h2>数组和元组数据类型简介</h2>
<p>在我们开始探索TypeScript中元组的用例之前，让我们简单地探索一些可以使用数组的简单案例，以及元组如何能够很好地(甚至更好地)适应相同的场景。</p>
<p>在TS中，我们可以声明一个特定数据类型的数组。例如，我们可以通过指定元素的类型后跟方括号来声明一个数字数组:<code>[]</code>。让我们看看如何做到这一点:</p>
<pre>let arr: number[];

arr = [1, 2, 3];</pre>
<p>从上面的例子中我们可以看到，为了确保类型安全(这使得我们的代码更容易注释和文档化)，我们需要使用数组，这允许像这样的情况，我们有一个特定数据类型的列表。事实上，这是像TypeScript这样的类型化语言的本质。</p>
<p>对于具有多种数据类型的数组，我们可以利用<code>any</code>类型或<code>|</code>(按位or)运算符。但是，在这种情况下，数据的顺序并不是一成不变的。让我们看下面的例子:</p>
<pre>let arr: (string | number)[];
arr = ['Alex', 2020];
console.log(arr);</pre>
<p>从上面的例子中，我们可以决定在字符串之前传递数字，它仍然有效。在这种情况下，当数组被实例化时，我们传递数据的顺序并不重要，只要我们有指定类型的组合。这正是元组旨在解决的问题。</p>
<p>有了元组，我们可以有一个多种数据类型的列表，其中我们传递数据类型的顺序必须符合声明元组时的顺序。本质上，元组的结构需要保持不变。让我们看一个例子来更好地理解这个概念:</p>
<pre>let tup: [string, number];

tup = ['Alex', 19087]</pre>
<p>在上面的例子中，我们可以看到我们用两种基本数据类型声明了一个元组:字符串和数字。注意，当我们调用<code>tup</code>变量时，我们还必须按照元素类型声明的顺序传递它们。本质上，我们不能在<code>index 0</code>有一个数字，在<code>index 1</code>有一个字符串，就像这样:</p>
<pre>tup = [19087, 'Alex]</pre>
<p>如果我们这样做了，我们将得到如下所示的错误:</p>
<pre>TSError: ⨯ Unable to compile TypeScript:
index.ts:6:8 - error TS2322: Type 'number' is not assignable to type 'string'.

6 tup = [19087, 'Alex']
         ~~~~~
index.ts:6:15 - error TS2322: Type 'string' is not assignable to type 'number'.

6 tup = [19087, 'Alex']</pre>
<p>从前面的例子中我们可以看到，我们声明了一个数字数组并用值初始化它。只要我们只处理数字类型的元素，这种方法就有效。</p>
<p>为了考虑具有多种数据类型的数组，我们可以利用<code>any</code>类型或<code>|</code>操作符，尽管在这种情况下，数据的顺序或结构没有保证，这可能不是我们想要的。</p>
<p>然而，使用元组，我们可以确保数据类型的严格性以及我们想要传递的数据的顺序。元组允许在具有固定数量元素的元素类型周围指定已知的类型边界。</p>
<h2>类型脚本元组的用例</h2>
<p>因为元组允许我们在数组中定义固定类型和顺序，所以当处理以顺序方式彼此相关的数据时(顺序很重要)，元组是最好的。这样，我们可以很容易地以预定的方式访问元素，使我们期望的响应在行为上是可预测的。</p>
<p>下面，我们将基于<a href="https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-0.html#tuples-in-rest-parameters-and-spread-expressions"> 3.0版本</a>探索TS中元组类型的更多用例，这些用例通常围绕在函数签名中提取和传播参数列表。</p>
<h3>1.在rest参数中使用元组</h3>
<p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/rest_parameters"> rest参数</a>语法将参数收集到一个数组变量中，然后扩展它们。随着TypeScript 3.0的发布，我们现在可以将tuple类型的rest参数扩展为离散参数。这意味着当一个<code>tuple</code>类型被用作rest参数时，它会被展平到参数列表的其余部分中。</p>
<blockquote><p>简单来说，当rest参数是元组类型时，元组类型可以扩展为一系列参数列表。</p></blockquote>
<p>考虑下面的例子:</p>
<pre>declare function example(...args: [string, number]): void;</pre>
<p>rest参数将元组类型的元素扩展为离散参数。当调用该函数时，表示为rest参数的<code>args</code>被展开，看起来与下面的函数签名完全一样:</p>
<pre>declare function example(args0: string, args1: number): void;</pre>
<p>因此，rest参数语法将“参数溢出”收集到数组或元组中。总之，元组类型迫使我们将适当的类型传递给各自的函数签名。更多细节可以在TypeScript 3.0发布博客文章<a href="https://devblogs.microsoft.com/typescript/announcing-typescript-3-0/#tuples-and-parameters">这里</a>找到。</p>
<h3>2.用元组扩展表达式</h3>
<p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_syntax"> spread语法</a>将数组或对象的元素扩展到它的元素中。使用TypeScript 3.0，spread运算符还可以扩展元组的元素。当函数调用包括元组类型的扩展表达式作为自变量时，扩展表达式被扩展为对应于元组类型的元素的自变量序列。</p>
<p>让我们看下面的例子:</p>
<pre>type Value = [number, number];

const sample = (...value: Value) =&gt; {
  // do  something with value here
};

// create a type
let sampleTuple: Value;

sampleTuple = [20, 40];

// Passing the values as literals:
sample(20, 40);

// Passing indexes to the corresponding sampleTuple tuple
sample(sampleTuple[0], sampleTuple[1]);

// Using the spread operator to pass the full sampleTuple tuple
sample(...sampleTuple);</pre>
<blockquote><p><strong> N.B. </strong>从上面的例子可以看出，我们已经声明了一个tuple类型，并将其作为参数传递给了函数signature。</p></blockquote>
<p>当函数被调用时，我们可以直接传递参数或者通过它们各自的索引。但是，对于将元组作为参数传递给函数调用来说，使用spread操作符是一个快速而干净的选择。</p>
<p>由于扩展运算符的性质，参数被扩展为与元组类型的元素相对应的参数列表。</p>
<h3>3.破坏值</h3>
<p>因为元组是隐藏的数组，所以我们可以像析构数组一样析构它们。值得注意的是，析构变量获取相应元组元素的类型。让我们看一个例子:</p>
<pre>let tuple: [number, string, boolean];

tuple = [7, "hello", true];

let [a, b, c] = tuple; 

// a: number, b: string, c: boolean</pre>
<h3>类型脚本元组的其他用例</h3>
<ul>
<li>当我们打算从函数调用中同时返回响应和错误结果时，可以使用元组来加强类型安全</li>
<li>我们可以使用元组将相似的数据或有效载荷分组在一起，例如笛卡尔坐标，在自定义csv文件中强制元素类型</li>
<li>我们还可以使用元组来创建由多个其他类型组成的特定类型</li>
<li>元组通常可以用作函数签名或调用的参数列表</li>
</ul>
<blockquote><p><strong> N.B. </strong>，参数列表不仅仅是类型的有序列表。为了使元组作为参数列表工作，在TypeScript 3.0版本中做了一些改进。你可以在这里查看<a href="https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-0.html?o=60894&amp;t=1604332880&amp;z=222920&amp;sh=1#tuples-in-rest-parameters-and-spread-expressions">。</a></p></blockquote>
<h2>结论</h2>
<p>TypeScript元组类似于具有固定数量元素的数组。它们为我们提供了一个固定大小的容器，可以存储多种类型的值，其中顺序和结构非常重要。</p>
<p>当我们确切知道一个数组中允许多少种类型时，最好使用这种数据类型。正如我们所知，指定超出原始定义长度的索引将导致TypeScript编译器出错。</p>
<p>注意，虽然可以通过元组元素的索引来修改它们的值，但是我们必须确保在声明元组变量时匹配所提供的类型。这是因为一旦声明，我们就不能改变元组中元素的类型甚至大小。</p>
<p>有了本文中强调的特性，就有可能设计强类型的高阶函数，这些函数可以转换函数及其参数列表，并在本质上确保一个健壮的、文档完善的、可维护的代码库，这是我们使用TypeScript的核心原因。</p><div class="code-block code-block-21">
<div class="blog-plug inline-plug typescript-plug"><h2><a class="signup" href="https://lp.logrocket.com/blg/typescript-signup" target="_blank" rel="noopener noreferrer"> LogRocket </a>:全面了解您的网络和移动应用</h2>
<a href="https://lp.logrocket.com/blg/typescript-signup" class="signup" target="_blank" rel="noopener noreferrer"><img class="alignnone size-full wp-image-46 jetpack-lazy-image" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/><noscript><img data-lazy-fallback="1" class="alignnone size-full wp-image-46" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/></noscript></a>
<p>LogRocket 是一个前端应用程序监控解决方案，可以让您回放问题，就像问题发生在您自己的浏览器中一样。LogRocket不需要猜测错误发生的原因，也不需要向用户询问截图和日志转储，而是让您重放会话以快速了解哪里出错了。它可以与任何应用程序完美配合，不管是什么框架，并且有插件可以记录来自Redux、Vuex和@ngrx/store的额外上下文。</p>
<p>除了记录Redux操作和状态，LogRocket还记录控制台日志、JavaScript错误、堆栈跟踪、带有头+正文的网络请求/响应、浏览器元数据和自定义日志。它还使用DOM来记录页面上的HTML和CSS，甚至为最复杂的单页面和移动应用程序重新创建像素级完美视频。</p>
<a class="signup" href="https://lp.logrocket.com/blg/typescript-signup" target="_blank" rel="noopener noreferrer">Try it for free</a><p>.</p></div>
</div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
<html>
<head>
<title>React error handling with react-error-boundary - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>React错误处理与react-error-boundary - LogRocket博客</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/react-error-handling-react-error-boundary/#0001-01-01">https://blog.logrocket.com/react-error-handling-react-error-boundary/#0001-01-01</a></blockquote><div><article class="article-post">
<p><em> <strong>编者按:</strong>本文于2022年4月13日更新，以反映react-error-boundary的最新信息，包括使用<code>withErrorBoundary</code>函数作为高阶组件。</em></p>
<p>在我们的应用程序中，错误是必然会发生的，无论是与服务器相关的错误、边缘情况还是其他。因此，已经开发了许多方法来防止这些错误干扰用户和开发人员的体验。在React中，一种这样的方法是使用错误边界。</p>
<p>在本文中，我们将使用react-error-boundary检查React错误处理。我们将讨论以下内容:</p>

<h2 id="error-boundaries-in-react">React中的错误边界</h2>
<p>React 16中引入了错误边界，作为捕捉和处理组件UI部分中发生的JavaScript错误的一种方式。所以错误边界只捕捉发生在生命周期方法、渲染方法和类似于<code>useEffect</code>的钩子内部的错误。根据React文档，错误边界不处理以下错误:</p>
<ul>
<li>事件处理程序</li>
<li>异步代码(例如，<code>setTimeout</code>或<code>requestAnimationFrame</code>回调)</li>
<li>服务器端渲染</li>
<li>在错误边界本身(而不是其子系)中掷回的错误</li>
</ul>
<p>所以基本上，错误边界只处理代码中涉及React的部分的错误。</p>
<p>要创建错误边界，我们只需创建一个类组件，并定义一个状态变量来确定错误边界是否捕捉到了错误。我们的类组件也应该至少有三个方法:</p>
<ol>
<li>名为<code>getDerivedStateFromError</code>的静态方法，用于更新错误边界的状态</li>
<li>一种生命周期方法，用于在我们的错误边界捕捉到错误时执行操作，比如记录到错误记录服务</li>
<li>一个<code>render</code>方法，用于呈现我们的错误边界的子元素或出错时的回退UI</li>
</ol>
<p>这里有一个例子(摘自<a href="https://reactjs.org/docs/error-boundaries.html" target="_blank" rel="noopener"> React文档</a>)展示了我们简单的错误边界应该是什么样子:</p>
<pre class="language-javascript hljs">class ErrorBoundary extends React.Component {
  constructor(props) {
    super(props);
    this.state = { hasError: false };
  }

  static getDerivedStateFromError(error) {
    // Update state so the next render will show the fallback UI.
    return { hasError: true };
  }

  componentDidCatch(error, errorInfo) {
    // You can also log the error to an error reporting service
    logErrorToMyService(error, errorInfo);
  }

  render() {
    if (this.state.hasError) {
      // You can render any custom fallback UI
      return &lt;h1&gt;Something went wrong.&lt;/h1&gt;;
    }

    return this.props.children; 
  }
}
</pre>
<h2 id="react-error-boundary">反应误差边界</h2>
<p>react-error-boundary是react错误边界的包装器，允许开发人员在代码中实现错误边界，而无需从头开始构建。使用react-error-boundary，我们可以简单地用提供的<code>ErrorBoundary</code>组件包装我们预期会出错的组件，并传入一些额外的道具来定制我们的错误边界的行为。</p>
<p>在本文中，我将使用react-error-boundary来处理react应用程序中的错误。让我们来看看图书馆提供了什么。</p>
<h3 id="errorboundary-component"><code>ErrorBoundary</code>组件</h3>
<p><code>ErrorBoundary</code>组件是react-error-boundary中的主要组件。它允许我们用更少的代码实现典型的React错误边界。</p>
<p>这里有一个非常基本的<code>ErrorBoundary</code>用例:</p>
<pre class="language-javascript hljs">function App(){
  ...
  return (
    &lt;ErrorBoundary
          FallbackComponent={OurFallbackComponent}
        &gt;
          &lt;ComponentThatMightThrowAnError/&gt;
    &lt;/ErrorBoundary&gt;
  );
}

const OurFallbackComponent = ({ error, componentStack, resetErrorBoundary }) =&gt; {
  return (
    &lt;div&gt;
      &lt;h1&gt;An error occurred: {error.message}&lt;/h1&gt;
      &lt;button onClick={resetErrorBoundary}&gt;Try again&lt;/button&gt;
    &lt;/div&gt;
  );
};
</pre>
<p>在上面的组件中，我们简单地用<code>ErrorBoundary</code>组件包装我们的组件，并将我们的回退组件传递给<code>FallbackComponent</code> prop，这样如果有错误(可以由react-error-boundary捕获和处理)，我们的回退组件将被呈现；否则，我们的组件将被渲染。</p>
<p>我们还有<code>fallbackRender</code> prop，这是一个基于渲染prop的API，用于以内联方式指定我们的回退组件。下面是上面使用<code>fallbackRender</code>属性的代码块:</p>
<pre class="language-javascript hljs">function App(){
  ...
  return (
    &lt;ErrorBoundary
      fallbackRender =  {({error, resetErrorBoundary, componentStack}) =&gt; (
          &lt;div&gt;
          &lt;h1&gt;An error occurred: {error.message}&lt;/h1&gt;
          &lt;button onClick={resetErrorBoundary}&gt;Try again&lt;/button&gt;
        &lt;/div&gt;
      )}
    &gt;
      &lt;ComponentThatMightThrowAnError/&gt;
    &lt;/ErrorBoundary&gt;
  );
}
</pre>
<p><code>ErrorBoundary</code>还有一个<code>onError</code> prop，它充当一个监听器，当我们的错误边界捕获并处理其子组件中的错误时，就会触发这个监听器。正是从这个位置，我们可以选择将这样的错误记录到我们可能使用的任何错误记录服务中。</p>
<pre class="language-javascript hljs">function App(){
  ...

  return (
    &lt;ErrorBoundary
      onError = {(error, componentStack) =&gt; {
        logToErrorLoggingService(error, componentStack);
      }}
      ...
    &gt;
      &lt;ComponentThatMightThrowAnError/&gt;
    &lt;/ErrorBoundary&gt;
  );
}
</pre>
<h3 id="resetting-error-boundaries">重置误差边界</h3>
<p>react-error-boundary还为我们的代码提供了一种从错误边界捕获的错误中恢复的方法。这是通过使用复位键和传递给回退组件的<code>resetErrorBoundary</code>函数来完成的。</p>
<p>解释其工作原理的最佳方式是使用一个直接取自<a href="https://reactjs.org/docs/error-boundaries.html" target="_blank" rel="noopener"> React文档</a>的示例代码块:</p>
<pre class="language-javascript hljs">function ErrorFallback({error, componentStack, resetErrorBoundary}) {
  return (
    &lt;div role="alert"&gt;
      &lt;p&gt;Something went wrong:&lt;/p&gt;
      &lt;pre&gt;{error.message}&lt;/pre&gt;
      &lt;pre&gt;{componentStack}&lt;/pre&gt;
      &lt;button onClick={resetErrorBoundary}&gt;Try again&lt;/button&gt;
    &lt;/div&gt;
  )
}

function Bomb() {
  throw new Error('💥 KABOOM 💥')
}

function App() {
  const [explode, setExplode] = React.useState(false)
  return (
    &lt;div&gt;
      &lt;button onClick={() =&gt; setExplode(e =&gt; !e)}&gt;toggle explode&lt;/button&gt;
      &lt;ErrorBoundary
        FallbackComponent={ErrorFallback}
        onReset={() =&gt; setExplode(false)}
        resetKeys={[explode]}
      &gt;
        {explode ? &lt;Bomb /&gt; : null}
      &lt;/ErrorBoundary&gt;
    &lt;/div&gt;
  )
}
</pre>
<p>从上面的代码中我们可以看到，创建了一个状态钩子，用于确定<code>App</code>组件是呈现一个抛出错误的<code>Bomb</code>组件还是一个错误安全组件。重置键也被传递给错误边界组件。这些重置键确定是否将重置错误边界的内部状态。如果其中一个重置键在渲染过程中改变，错误边界的内部状态将被重置。</p>
<p>另一方面，调用<code>resetComponent</code>函数会触发我们的<code>ErrorBoundary</code>组件的<code>onReset</code>处理程序，在这里我们将<code>explode</code>状态值设置为<code>false</code>。这导致我们的<code>App</code>组件呈现一个错误安全的组件。</p>
<p>我们还有<code>onResetKeysChange</code>处理程序，当reset键的值改变时触发，导致错误边界内部状态的重置。</p>
<h3 id="useerrorhandler-hook"><code>useErrorHandler</code>挂钩</h3>
<p>react-error-boundary库的另一个重要特性是，它允许开发人员使用错误边界来捕获传统react错误边界无法捕获的错误。这意味着我们现在可以使用错误边界来捕捉API请求、事件处理程序和其他可能发生错误的代码部分中的错误。</p>
<p>有两种方法可以使用<code>useErrorHandler</code>挂钩:</p>
<ol>
<li><code>const handleError = useErrorHandler()</code>:然后我们可以调用<code>handleError(error)</code>并传入错误对象，就像下面的例子一样</li>
<li>当我们自己处理错误状态或者从另一个钩子得到错误状态时，这很有用</li>
</ol>
<p>这就是我们如何使用第一种方法捕获API请求中的错误:</p>
<pre class="language-javascript hljs"> const App = () =&gt; {
  return (
    &lt;ErrorBoundary
      FallbackComponent={CharacterFallback}
    &gt;
      &lt;ComponentWhereErrorMightOccur/&gt;
    &lt;/ErrorBoundary&gt;
  );
};


const ComponentWhereErrorMightOccur = () =&gt; {
  const handleError = useErrorHandler();
  const callAPI = () =&gt; {
    const result = fetch(apiURL)
    .then(
      (response) =&gt; response.json(),
      (error) =&gt; handleError(error))
    .then((data) =&gt; {
      return data["results"];
    });
    return result;
  };
  useEffect(() =&gt; {
    (async function () {
      await callAPI();
    })();
  }, []);
  return (
    ...
  );
};
</pre>
<p>如您所见，我们需要做的就是将从我们的API获取数据返回的错误对象传递给我们的<code>handleError</code>函数，该函数由<code>useErrorHandle</code>钩子返回。这样，我们的误差边界就更有用了。</p>
<h3 id="witherrorboundary-function-as-hoc"><code>withErrorBoundary</code>起特设的作用</h3>
<p>React-error-boundary允许我们利用<code>withErrorBoundary</code>函数作为<a href="https://reactjs.org/docs/higher-order-components.html" target="_blank" rel="noopener">高阶组件</a> (HOC)来管理组件内的问题。这样，我们可以专注于开发组件，而将错误处理留给函数。此外，该方法减少了实现组件及其测试所需的代码量。</p>
<p>这里有一个来自<a href="https://github.com/bvaughn/react-error-boundary" target="_blank" rel="noopener">反应-错误-边界文档</a>的例子，说明如何使用它:</p>
<pre class="language-javascript hljs">import {withErrorBoundary} from 'react-error-boundary'

const ComponentWithErrorBoundary = withErrorBoundary(ComponentThatMayError, {
  FallbackComponent: ErrorBoundaryFallbackComponent,
  onError(error, info) {
    // Do something with the error
    // E.g. log to an error logging client here
  },
})

const ui = &lt;ComponentWithErrorBoundary /&gt;
</pre>
<h2 id="conclusion">结论</h2>
<p>react-error-boundary使react开发人员能够减少必须编写的代码量，并扩展他们的错误边界功能，以捕捉常规错误边界无法识别的其他形式的错误。在GitHub 上了解更多关于react-error-boundary的信息。</p><div class="code-block code-block-17">
<div class="blog-plug inline-plug react-plug" vwo-el-id="26283398190">
<h2 vwo-el-id="41600691720">使用LogRocket消除传统反应错误报告的噪音</h2>
<a href="https://lp.logrocket.com/blg/react-signup-issue-free" target="_blank" vwo-el-id="19356441070">LogRocket
</a><p>是一款React analytics解决方案，可保护您免受数百个误报错误警报的影响，只针对少数真正重要的项目。LogRocket告诉您React应用程序中实际影响用户的最具影响力的bug和UX问题。</p><a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="19356441380">
<img class="first-react-image alignnone size-full wp-image-46 jetpack-lazy-image jetpack-lazy-image--handled" src="../Images/f300c244a1a1cf916df8b4cb02bec6c6.png" vwo-el-id="18272717540" data-lazy-loaded="1" data-original-src="https://files.readme.io/27c94e7-Image_2017-06-05_at_9.46.04_PM.png"/>
</a>
<a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="19356441690">
<img class="second-react-image alignnone size-full wp-image-46 jetpack-lazy-image jetpack-lazy-image--handled" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" vwo-el-id="30720362350" data-lazy-loaded="1" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/>
</a>
<a href="https://lp.logrocket.com/blg/react-signup-issue-free" target="_blank" rel="noopener noreferrer" vwo-el-id="35866400580">LogRocket
</a><p>自动聚合客户端错误、反应错误边界、还原状态、缓慢的组件加载时间、JS异常、前端性能指标和用户交互。然后，LogRocket使用机器学习来通知您影响大多数用户的最具影响力的问题，并提供您修复它所需的上下文。</p><p vwo-el-id="28675661060">关注重要的React bug—<a class="signup" href="https://lp.logrocket.com/blg/react-signup-issue-free" target="_blank" rel="noopener noreferrer" vwo-el-id="40093418840">今天就试试LogRocket】。</a></p>
</div></div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
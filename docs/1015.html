<html>
<head>
<title>How to set up TypeScript with Node.js and Express - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>如何用Node.js和Express - LogRocket Blog设置TypeScript</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/how-to-set-up-node-typescript-express/#0001-01-01">https://blog.logrocket.com/how-to-set-up-node-typescript-express/#0001-01-01</a></blockquote><div><article class="article-post">
<p><em> <strong>编者按</strong>:这篇文章最后一次更新是在2022年3月23日，以更新已经过时的代码。</em></p>
<p>当您构建用JavaScript编写的服务器并使用Node.js和Express时，开发的简易性是非常好的。但是，当您的应用服务器扩展时，或者您在世界各地的开发团队中工作时，会发生什么呢？在这些情况下，TypeScript会有所帮助。</p>
<p>在本文中，我们将介绍一种初学者友好的方法来在Express应用程序中设置TypeScript，理解随之而来的基本约束。</p>
<p>要充分利用本教程，请确保您具备以下条件:</p>
<ul>
<li>安装在本地开发环境中的Node.js版本≥ v12.x</li>
<li>访问像npm或Yarn这样的包管理器</li>
<li>Node.js和Express的基础知识</li>
</ul>
<h2>目录</h2>

<h2 id="package">创建一个<code>package.json</code>文件</h2>
<p>从在本地开发环境中保存辅助项目的地方创建一个新目录开始。在该目录中，使用npm的初始化器命令创建一个<code>package.json</code>文件:</p>
<pre class="&quot;language-shell">mkdir node-express-typescript
cd node-express-typescript/
npm init --yes</pre>
<p>当您初始化一个<code>package.json</code>文件时，<code>--yes</code>标志使用您在npm config中设置的默认设置。新创建的<code>package.json</code>文件可能类似于下面的代码:</p>
<pre class="&quot;language-json">{
  "name": "express-typescript",
  "version": "1.0.0",
  "description": "",
  "main": "index.js",
  "scripts": {
    "test": "echo \"Error: no test specified\" &amp;&amp; exit 1"
  },
  "type": "module",
  "keywords": [],
  "author": "",
  "license": "ISC"
}</pre>
<h2 id="create-minimal-server-express">使用Express创建最小服务器</h2>
<p>初始化完<code>package.json</code>文件，我们来添加一个快递包。在终端窗口中，运行以下命令:</p>
<pre class="&quot;language-shell">npm install express dotenv</pre>
<p>接下来，要触发一个最小服务器，在项目的根目录下用下面的代码创建一个名为<code>index.js</code>的新文件:</p>
<pre class="&quot;language-json">const express = require('express');
const dotenv = require('dotenv');

dotenv.config();

const app = express();
const port = process.env.PORT;

app.get('/', (req, res) =&gt; {
  res.send('Express + TypeScript Server');
});

app.listen(port, () =&gt; {
  console.log(`[server]: Server is running at http://localhost:${port}`);
});</pre>
<p><a href="https://blog.logrocket.com/customizing-node-js-env-files/"> <code>dotenv</code>包用于从<code>.env</code>文件中读取环境变量</a>。在Node.js应用程序的根目录下创建它，然后为<code>PORT=8000</code>创建环境变量。</p>
<p>要启动服务器，回到终端并触发命令<code>node index.js</code>:</p>
<p><img data-attachment-id="96885" data-permalink="https://blog.logrocket.com/start-server-node-index/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/03/start-server-node-index.png" data-orig-size="612,487" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="start-server-node-index" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/03/start-server-node-index-300x239.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/03/start-server-node-index.png" decoding="async" class="aligncenter wp-image-96885 size-full jetpack-lazy-image" src="../Images/e8d4a73e873a19466e71b3fc4a8bb6aa.png" alt="Start Server Node Index" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2022/03/start-server-node-index.png 612w, https://blog.logrocket.com/wp-content/uploads/2022/03/start-server-node-index-300x239.png 300w" data-lazy-sizes="(max-width: 612px) 100vw, 612px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2022/03/start-server-node-index.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/03/start-server-node-index.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="96885" data-permalink="https://blog.logrocket.com/start-server-node-index/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/03/start-server-node-index.png" data-orig-size="612,487" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="start-server-node-index" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/03/start-server-node-index-300x239.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/03/start-server-node-index.png" decoding="async" loading="lazy" class="aligncenter wp-image-96885 size-full" src="../Images/e8d4a73e873a19466e71b3fc4a8bb6aa.png" alt="Start Server Node Index" srcset="https://blog.logrocket.com/wp-content/uploads/2022/03/start-server-node-index.png 612w, https://blog.logrocket.com/wp-content/uploads/2022/03/start-server-node-index-300x239.png 300w" sizes="(max-width: 612px) 100vw, 612px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/03/start-server-node-index.png"/></noscript>
<p>Express服务器现在已经启动并运行了！</p>
<h2 id="installing-typescript">安装TypeScript</h2>
<p>我们将从安装TypeScript作为开发依赖项开始。与此同时，我们将为Express和Node.js安装<code>@types</code>声明包，它们以声明文件的形式提供类型定义。</p>
<p>声明文件是预定义的模块，为TypeScript编译器描述JavaScript值的形状或存在的类型。类型声明通常包含在扩展名为<code>.d.ts</code>的文件中。这些声明文件适用于所有最初用JavaScript而不是TypeScript编写的库。</p>
<p><a href="https://github.com/DefinitelyTyped/DefinitelyTyped">definitely typed GitHub repository</a>维护TypeScript类型定义，以便直接在Node.js和其他JavaScript项目中使用，因此您不必从头开始定义这些类型。要添加这些类型或与特定库或模块相关的声明文件，您必须寻找以<code>@types</code>名称空间开始的包。</p>
<p>打开终端窗口，使用以下命令安装上述软件包:</p>
<pre class="&quot;language-shell">npm i -D typescript @types/express @types/node</pre>
<p><code>-D</code>标志，也称为<code>--dev</code>标志，是包管理器将这些库安装为<code>devDependencies</code>的规范。</p>
<p>一旦安装了这些库，转到<code>package.json</code>文件，在那里您会看到一个新的<code>devDependencies</code>对象:</p>
<pre class="&quot;language-json">{
"devDependencies": {
"@types/express": "^4.17.13",
"@types/node": "^17.0.10",
"typescript": "^4.5.5"
}
}</pre>
<h2 id="generating-tsconfig-json">正在生成<code>tsconfig.json</code></h2>
<p>现在，我们有了一个使用一些默认配置选项编译的TypeScript项目。<code>tsconfig.json</code>文件提供了这些默认选项，也为我们提供了调整或定制编译器选项的能力。</p>
<p>通常，<code>tsconfig.json</code>文件位于项目的根目录下。为了生成它，我们将使用<code>tsc</code>命令:</p>
<pre class="&quot;language-shell">npx tsc --init
</pre>
<p>上面的命令将生成一个名为<code>tsconfig.json</code>的新文件，具有以下默认编译器选项:</p>
<pre class="&quot;language-shell">target: es2016
module: commonjs
strict: true
esModuleInterop: true
skipLibCheck: true
forceConsistentCasingInFileNames: true</pre>
<p>如果你打开<code>tsconfig.json</code>文件，你会看到很多其他的编译器选项被注释掉了。在<code>tsconfig.json</code>中，<code>compilerOptions</code>是必填字段，需要指定。上面配置中使用的选项有:</p>
<ul>
<li><code>target</code>:允许我们指定编译器将输出的目标JavaScript版本</li>
<li><code>module</code>:允许我们在编译的JavaScript代码中使用模块管理器。支持CommonJS，它是Node.js中的一个标准</li>
<li><code>strict</code>:启用严格类型检查选项的选项</li>
<li><code>esModuleInterop</code>:允许我们将ES6模块编译成CommonJS模块</li>
<li><code>skipLibCheck</code>:如果设置为<code>true</code>，跳过默认库声明文件的类型检查</li>
<li><code>forceConsistentCasingInFileNames</code>:设置为<code>true</code>时，启用区分大小写的文件命名</li>
</ul>
<p>您必须启用的一个选项叫做<code>outDir</code>，它指定了编译步骤之后输出将位于何处。您可以在<code>tsconfig.json</code>文件中搜索这个选项并取消注释。</p>
<p>默认情况下，该选项的值设置为根目录。改为<code>dist</code>:</p>
<pre class="&quot;language-json">{
  "compilerOptions": {
    "outDir": "./dist"

    // rest options remain same
  }
}</pre>
<p>虽然可能还有其他配置选项可以添加到TypeScript编译器中，但上面列出的选项是可以帮助您入门的基本规范。</p>
<h2 id="createanexpressserverwithtsextension">创建扩展名为<code>.ts</code>的Express服务器</h2>
<p>现在，您可以轻松地将<code>index.js</code>中的最小服务器代码转换成一个<code>index.ts</code>文件。</p>
<p>首先，将文件重命名为<code>index.ts</code>。<code>.ts</code>扩展名是一个文件扩展名，它决定了当我们构建服务器时，什么类型的脚本文件被编译成JavaScript文件。</p>
<p>打开<code>index.ts</code>文件，进行修改，如下图所示:</p>
<pre class="“language-typescript">import express, { Express, Request, Response } from 'express';
import dotenv from 'dotenv';

dotenv.config();

const app: Express = express();
const port = process.env.PORT;

app.get('/', (req: Request, res: Response) =&gt; {
  res.send('Express + TypeScript Server');
});

app.listen(port, () =&gt; {
  console.log(`⚡️[server]: Server is running at http://localhost:${port}`);
});</pre>
<h2 id="watchingfilechangesandbuilddirectory">监视文件更改并构建目录</h2>
<p>在处理Node.js项目时，我喜欢使用的另一个与开发相关的实用程序库是<a href="https://www.npmjs.com/package/nodemon"> nodemon </a>。nodemon是一个帮助开发基于Node.js的应用程序的工具，它在检测到目录中的文件更改时自动重新启动Node.js应用程序。</p>
<p>我们还将安装另一个名为<a href="https://www.npmjs.com/package/concurrently">并发</a>的开发依赖项，这将允许我们运行多个命令，如nodemon来查看文件更改，以及运行<code>tsc</code>命令来编译代码:</p>
<pre class="&quot;language-shell">npm install -D concurrently nodemon
</pre>
<p>安装这些开发依赖项后，更新<code>package.json</code>文件中的<code>scripts</code>:</p>
<pre class="&quot;language-json">{
  "scripts": {
    "build": "npx tsc",
    "start": "node dist/index.js",
    "dev": "concurrently \"npx tsc --watch\" \"nodemon -q dist/index.js\""
  }
}</pre>
<p><code>build</code>命令将在<code>dist</code>目录中编译JavaScript代码。<code>dev</code>命令用于在开发模式下运行Node.js服务器。</p>
<p>现在，回到终端窗口，运行<code>npm run dev</code>来触发开发服务器:</p>
<p><img data-attachment-id="99894" data-permalink="https://blog.logrocket.com/trigger-dev-server/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/03/trigger-dev-server.png" data-orig-size="730,516" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="trigger-dev-server" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/03/trigger-dev-server-300x212.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/03/trigger-dev-server.png" decoding="async" class="aligncenter wp-image-99894 size-full jetpack-lazy-image" src="../Images/3131a67537c2b5fe207e76149dc1118f.png" alt="Trigger Dev Server" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2022/03/trigger-dev-server.png 730w, https://blog.logrocket.com/wp-content/uploads/2022/03/trigger-dev-server-300x212.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2022/03/trigger-dev-server.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/03/trigger-dev-server.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="99894" data-permalink="https://blog.logrocket.com/trigger-dev-server/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/03/trigger-dev-server.png" data-orig-size="730,516" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="trigger-dev-server" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/03/trigger-dev-server-300x212.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/03/trigger-dev-server.png" decoding="async" loading="lazy" class="aligncenter wp-image-99894 size-full" src="../Images/3131a67537c2b5fe207e76149dc1118f.png" alt="Trigger Dev Server" srcset="https://blog.logrocket.com/wp-content/uploads/2022/03/trigger-dev-server.png 730w, https://blog.logrocket.com/wp-content/uploads/2022/03/trigger-dev-server-300x212.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/03/trigger-dev-server.png"/></noscript>
<p>没有错误，表明服务器正在成功运行。您可以进入浏览器窗口查看结果。</p>
<p>由于nodemon检测到更改，让我们尝试编辑从<code>res.send()</code>发送的消息，同时查看终端，看看nodemon是否检测到任何文件更改:</p>
<p><img data-attachment-id="99892" data-permalink="https://blog.logrocket.com/node-dev-server-ts/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/03/node-dev-server-ts.gif" data-orig-size="730,408" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="node-dev-server-ts" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/03/node-dev-server-ts-300x168.gif" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/03/node-dev-server-ts.gif" decoding="async" class="aligncenter wp-image-99892 size-full jetpack-lazy-image" src="../Images/606f171e4ae4ac7cdff7c38ec58df5e9.png" alt="Node Dev Server TS" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2022/03/node-dev-server-ts.gif?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/03/node-dev-server-ts.gif"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="99892" data-permalink="https://blog.logrocket.com/node-dev-server-ts/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/03/node-dev-server-ts.gif" data-orig-size="730,408" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="node-dev-server-ts" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/03/node-dev-server-ts-300x168.gif" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/03/node-dev-server-ts.gif" decoding="async" loading="lazy" class="aligncenter wp-image-99892 size-full" src="../Images/606f171e4ae4ac7cdff7c38ec58df5e9.png" alt="Node Dev Server TS" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/03/node-dev-server-ts.gif"/></noscript>
<p>要编译代码，您需要运行命令<code>npm run build</code>。该命令成功执行后，会创建一个新的<code>dist</code>目录。在这个目录中，TypeScript代码被编译成有效的JavaScript:</p>
<pre class="&quot;language-javascript">'use strict';
var __importDefault =
  (this &amp;&amp; this.__importDefault) ||
  function (mod) {
    return mod &amp;&amp; mod.__esModule ? mod : { default: mod };
  };
Object.defineProperty(exports, '__esModule', { value: true });
const express_1 = __importDefault(require('express'));
const dotenv_1 = __importDefault(require('dotenv'));
dotenv_1.default.config();
const app = (0, express_1.default)();
const port = process.env.PORT;
app.get('/', (req, res) =&gt; {
  res.send('Express + TypeScript Server is running.');
});
app.listen(port, () =&gt; {
  console.log(`⚡️[server]: Server is running at http://localhost:${port}`);
});
</pre>
<p>如果您指定任何其他目录作为<code>tsconfig.json</code>文件中属性<code>outDir</code>的值，该目录将在此处反映，而不是在<code>dist</code>处。</p>
<h2 id="conclusion">结论</h2>
<p>使用TypeScript有它的好处，但是它确实有一点学习曲线。你得仔细分析在你的Node.js和Express后端项目中使用TypeScript是否有利，这可能取决于你项目的需求。</p>
<p>确保检查不同的<a href="https://github.com/DefinitelyTyped/DefinitelyTyped/tree/master/types">类型定义</a>或者去官方的<a href="https://www.typescriptlang.org/docs/home.html">类型文档</a>探索更多。我希望你喜欢这个项目！如果你有任何问题，一定要留下评论。编码快乐！</p><div class="code-block code-block-21">
<div class="blog-plug inline-plug typescript-plug"><h2><a class="signup" href="https://lp.logrocket.com/blg/typescript-signup" target="_blank" rel="noopener noreferrer"> LogRocket </a>:全面了解您的网络和移动应用</h2>
<a href="https://lp.logrocket.com/blg/typescript-signup" class="signup" target="_blank" rel="noopener noreferrer"><img class="alignnone size-full wp-image-46 jetpack-lazy-image" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/><noscript><img data-lazy-fallback="1" class="alignnone size-full wp-image-46" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/></noscript></a>
<p>LogRocket 是一个前端应用程序监控解决方案，可以让您回放问题，就像问题发生在您自己的浏览器中一样。LogRocket不需要猜测错误发生的原因，也不需要向用户询问截图和日志转储，而是让您重放会话以快速了解哪里出错了。它可以与任何应用程序完美配合，不管是什么框架，并且有插件可以记录来自Redux、Vuex和@ngrx/store的额外上下文。</p>
<p>除了记录Redux操作和状态，LogRocket还记录控制台日志、JavaScript错误、堆栈跟踪、带有头+正文的网络请求/响应、浏览器元数据和自定义日志。它还使用DOM来记录页面上的HTML和CSS，甚至为最复杂的单页面和移动应用程序重新创建像素级完美视频。</p>
<a class="signup" href="https://lp.logrocket.com/blg/typescript-signup" target="_blank" rel="noopener noreferrer">Try it for free</a><p>.</p></div>
</div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
<html>
<head>
<title>Comparing JavaScript animation libraries - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>比较JavaScript动画库- LogRocket博客</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/comparing-javascript-animation-libraries/#0001-01-01">https://blog.logrocket.com/comparing-javascript-animation-libraries/#0001-01-01</a></blockquote><div><article class="article-post">
<p>如果你今天做任何类型的前端web开发，动画可能是你日常工作的一部分，或者至少是你正在做的项目的一部分。近年来，JavaScript中的动画已经有了很大的发展，从制作文本或图像动画到使用像<a href="https://get.webgl.org/"> WebGL </a>这样的工具制作成熟的3D动画。</p>
<p>有很多JavaScript框架提供动画功能。还有几个库与canvas和WebGL一起创建交互式体验。</p>
<p>在这篇文章中，我将对四个不同的JavaScript动画库进行比较。我在这里列出的库绝不是唯一的选择，但希望它们能向您展示在您的项目中添加任何动画时可以遵循的模式。</p>
<p>在这篇文章中，我们将关注以下内容:</p>

<p>我将用一个<a href="https://reactjs.org/"> React </a>项目来介绍实现，但是您应该能够遵循任何前端框架(或者普通JavaScript)的类似模式。你可以在这里查看我建的<a href="https://github.com/andrewevans0102/compare-javascript-animation-libraries">项目</a>。我还为每个库构建了示例组件，你可以在这里看到<a href="https://github.com/andrewevans0102/compare-javascript-animation-libraries/tree/master/src/components"/>。</p>
<p>在接下来的部分中，我将讨论如何使用上述每个库。我将在一个<a href="https://reactjs.org/"> React </a>项目中介绍基础知识及其实现。我还会提供一些我在与他们一起工作时发现的优点和缺点。</p>
<p>这篇文章假设读者对React和JavaScript项目有所了解。我讨论的所有库都可以应用于任何JavaScript框架，这只是正确导入库并调用所讨论的API的问题。</p>
<h2>Anime.js</h2>
<p>Anime.js 提供了一个基本的API，可以让你制作几乎任何你能想到的动画。使用Anime.js，您可以做基本的动画，来回移动对象，或者可以做更高级的动画，用动作重新设计组件的样式。</p>
<p>Anime.js还提供了对时间线之类的东西的支持，在那里你可以创建一个事件的动画序列。这在同时呈现几个事件时特别有用。</p>
<p>要使用Anime.js，你首先要通过npm安装或者直接从GitHub项目下载。</p>
<p>因为示例项目基于React，所以我使用npm:</p>
<pre>npm install animejs --save</pre>
<p>安装完成后，您可以使用标准JavaScript导入将它导入到您的组件中:</p>
<pre>import anime from "animejs";</pre>
<p>导入后，您可以用<code>anime</code>对象定义动画:</p>
<pre>    anime({
      targets: ".anime__label",
      translateX: "250px",
      rotate: "1turn",
      backgroundColor: "#FFC0CB",
      duration: 800,
      direction: "alternate"
    });</pre>
<p>正如你在这里看到的，Anime.js总是需要一个“目标”。目标可以包括用来标识DOM元素的任何东西。在本例中，我已经标识了包含<code>.container__label</code>类的元素。</p>
<p>除了定义目标之外，通常还要定义CSS属性——在本例中，我定义了一个<code>backgroundColor</code>。</p>
<p>您还需要定义“属性参数”和“动画参数”，就像我在本例中使用的一样:</p>
<ul>
<li><code>translateX</code></li>
<li><code>rotate</code></li>
<li><code>duration</code></li>
<li><code>direction</code></li>
<li>以及其他等等</li>
</ul>
<p>所以如果你像我上面那样定义动画，你就是在说:</p>
<ol>
<li>动画<code>.container__label</code>类元素向右移动250像素</li>
<li>旋转一次</li>
<li>应用<code>#FFC0CB</code>的背景色</li>
<li>播放动画，时长800毫秒</li>
<li>完成动画，然后重复(<code>direction:</code> <code>"``alternate``"</code>)</li>
</ol>
<p>综合起来，应该是这样的:</p>
<p><span class="embed-youtube"> <iframe loading="lazy" class="youtube-player" src="https://www.youtube.com/embed/hJ7SekzMvzg?version=3&amp;rel=1&amp;showsearch=0&amp;showinfo=1&amp;iv_load_policy=1&amp;fs=1&amp;hl=en-US&amp;autohide=2&amp;wmode=transparent" allowfullscreen="true" sandbox="allow-scripts allow-same-origin allow-popups allow-presentation">视频</iframe> </span></p>
<p>现在，如果您想要制作多个对象的动画，您可以使用时间轴将动画连接在一起。这个过程只是定义一个时间线，然后添加额外的动画，如下所示(这个例子是从Anime.js文档中复制的):</p>
<pre>    const tl = anime.timeline({
      easing: 'easeOutExpo',
      duration: 800,
      direction: "alternate"
    });
    tl
    .add({
      targets: '.anime__timeline--pink',
      translateX: 250,
    })
    .add({
      targets: '.anime__timeline--blue',
      translateX: 250,
    })
    .add({
      targets: '.anime__timeline--yellow',
      translateX: 250,
    });</pre>
<p>因此，这将定义一个初始动画事件，该事件使用持续800毫秒的缓动(移动行为)并像文本动画一样交替出现。</p>
<p>然后，使用<code>.add</code>方法，我们添加特定于具有<code>.anime__timeline--pink</code>、<code>.anime__timeline--blue</code>和<code>.anime__timeline--yellow</code>类的元素的附加动画。</p>
<p>产生的行为如下所示:</p>
<p><span class="embed-youtube"> <iframe loading="lazy" class="youtube-player" src="https://www.youtube.com/embed/LcXEL30r5Ks?version=3&amp;rel=1&amp;showsearch=0&amp;showinfo=1&amp;iv_load_policy=1&amp;fs=1&amp;hl=en-US&amp;autohide=2&amp;wmode=transparent" allowfullscreen="true" sandbox="allow-scripts allow-same-origin allow-popups allow-presentation">视频</iframe> </span></p>
<p>要获得这些元素代码的完整副本，请查看这里的<code>animejs</code>组件<a href="https://github.com/andrewevans0102/compare-javascript-animation-libraries/blob/master/src/components/Anime.js">。</a></p>
<p>这两个例子只是触及了Anime.js能为你的项目做些什么的表面。他们的文档里有多个例子<a href="https://animejs.com/documentation/">在这里</a>。此外，在<a href="https://codepen.io/collection/XLebem"> codepen上有很多很棒的例子。</a></p>
<p><strong>优点</strong>:</p>
<ul>
<li>超级容易设置</li>
<li>相当直观</li>
<li>很多好例子</li>
<li>与现代浏览器兼容</li>
</ul>
<p><strong>缺点</strong>:</p>
<ul>
<li>文档有时有点过于稀疏</li>
<li>关于CSS属性的信息不是很容易理解</li>
<li>放松很酷，但是定制的图案需要一秒钟来阅读</li>
<li>使用选择器是好的，但是需要在样式和动画定义之间进行协调</li>
</ul>
<p>最终，我真的很喜欢Anime.js，除了我肯定会建议添加更多的文档。此外，由于动画需要选择器，有时将元素样式转换成我想要的动画有点困难。</p>
<h2>p5.js</h2>
<p>这个<a href="https://p5js.org/"> p5.js </a>库是对麻省理工学院<a href="https://en.wikipedia.org/wiki/Casey_Reas">凯西·雷阿斯</a>和<a href="https://en.wikipedia.org/wiki/Ben_Fry">本·弗莱</a>开始的最初<a href="https://processing.org/">处理项目</a>的解释。处理包括编辑器和语言，试图使视觉设计对艺术家和创作者来说更容易。</p>
<p>最初的项目支持多种语言，这使得创建可视化元素比其他基础库(比如Java的Swing)更容易。p5.js将这些概念带到了JavaScript中，使您能够使用HTML画布快速构建动画。p5.js还允许您创建3D图像和音频。</p>
<p>要开始使用，您可以直接下载p5.js库或使用npm安装它:</p>
<pre>npm i p5</pre>
<p>只要您想使用p5.js，您就可以将动画创建为一个“草图”对象。</p>
<p><code>setup</code>方法使你能够启动你的画布对象并应用任何尺寸，等等。<code>draw</code>方法允许您在画布刷新时将任何循环行为应用到页面。</p>
<p>如果你查看p5.js的<a href="https://p5js.org/get-started/">入门</a>页面，他们定义了一个简单的例子(带动画)如下:</p>
<pre>function setup() {
  createCanvas(640, 480);
}

function draw() {
  if (mouseIsPressed) {
    fill("#000000");
  } else {
    fill("#FFFFFF");
  }
  ellipse(mouseX, mouseY, 80, 80);
}</pre>
<p>在上面的<code>setup</code>中，对<code>createCanvas</code>的调用创建了一个640x480px的画布。</p>
<p>然后，<code>draw</code>方法为<code>mouseIsPressed</code>事件添加一个事件监听器，根据鼠标是否被点击来应用一个<code>fill</code>属性。这个<code>fill</code>属性基本上是应用括号中指定的颜色(在我们的例子中，当按下时是黑色，当未按下时是白色)。</p>
<p>然后，调用<code>ellipse</code>方法在屏幕上画一个椭圆。因为每当画布翻页或刷新时都会调用该方法，所以它会在屏幕上创建一个画圆的动画效果。</p>
<p>因为在我们的示例应用程序中，我们使用React，所以这有一点不同。在React中，我们只需引用p5库，然后向返回的DOM添加一个草图，如下所示:</p>
<pre>import React, { Component } from "react";
import "./../styles/_title.scss";
import p5 from 'p5';
class P5WithSketch extends Component {
  constructor(props) {
    super(props)
    this.myRef = React.createRef()
  }

  Sketch = (p) =&gt; {
    let x = 100;
    let y = 100;
    p.setup = () =&gt; {
      p.createCanvas(640, 480);
    }
    p.draw = () =&gt; {
      if (p.mouseIsPressed) {
        p.fill("#000000");
      } else {
        p.fill("#FFFFFF");
      }
      p.ellipse(p.mouseX, p.mouseY, 80, 80);
    }
 }
  componentDidMount() {
    this.myP5 = new p5(this.Sketch, this.myRef.current);
  }
  render() {
    return (
      &lt;div&gt;
        &lt;section className="title"&gt;
          &lt;a
            className="title__heading"
            href="https://p5js.org/"
          &gt;
            P5.js
          &lt;/a&gt;
        &lt;/section&gt;
        &lt;section ref={this.myRef}&gt;
        &lt;/section&gt;
      &lt;/div&gt;
    );
  }
}
export default P5WithSketch;</pre>
<p>创建的最终动画如下所示:</p>
<p><span class="embed-youtube"> <iframe loading="lazy" class="youtube-player" src="https://www.youtube.com/embed/gTz_5GQJDBQ?version=3&amp;rel=1&amp;showsearch=0&amp;showinfo=1&amp;iv_load_policy=1&amp;fs=1&amp;hl=en-US&amp;autohide=2&amp;wmode=transparent" allowfullscreen="true" sandbox="allow-scripts allow-same-origin allow-popups allow-presentation">视频</iframe> </span></p>
<p>这只是你可以用p5.js做的事情的开始。你可以很容易地扩展这里的基本动画，以对用户输入做出反应，并呈现完整的3D元素。有很多p5.js草图的很好的例子展示了这种行为。点击这里查看他们的示例页面，了解更多信息。</p>
<p>我的示例项目中的完整工作组件可以在这里找到<a href="https://github.com/andrewevans0102/compare-javascript-animation-libraries/blob/master/src/components/p5WithSketch.js">。</a></p>
<p><strong>优点</strong>:</p>
<ul>
<li>能够将动画和行为扩展到画布元素的初始设置和刷新</li>
<li>有很多例子的好文档</li>
</ul>
<p><strong>缺点</strong>:</p>
<ul>
<li>难以创建“草图”对象来实际执行动画和行为</li>
<li>DOM元素和呈现的画布之间的连接需要自定义引用</li>
</ul>
<h2>绿袜子动画平台(GSAP)</h2>
<p>绿袜子动画平台(GSAP) 提供了一个相当强大的库，里面有你的项目可能需要的几乎任何类型效果的动画。此外，他们有非常强大的文档，包括如何与他们的API交互的例子。</p>
<p>要开始使用GSAP，您首先只需要将它作为项目的一个依赖项进行安装:</p>
<pre>npm i gsap</pre>
<p>一旦你把它加载到你的项目中，那么就只需要用<code>gsap</code>对象定义动画行为了，就像你在这里看到的:</p>
<pre>  animateText = () =&gt; {
    gsap.to(".gsap__label", { duration: 3, rotation: 360, scale: 0.5 });
  };
  animateSquare = () =&gt; {
    gsap.to(".gsap__square", { duration: 2, x: 200, ease: "bounce" });
  };</pre>
<p>当使用GSAP时，你会经常注意到文档将动画称为“补间动画”，这类似于我们看到p5.js将动画称为“草图”</p>
<p>使用GSAP时，使用<code>to</code>和<code>from</code>方法来表示开始和停止行为。在我放在这里的两个例子中，他们将动画应用于具有<code>.container__label</code>和<code>.container__square</code>风格的元素。</p><div class="code-block code-block-54">
<hr/>
<h3>更多来自LogRocket的精彩文章:</h3>

<hr/></div>
<p>类似于我们与Anime.js合作的方式，GSAP提供了像<code>duration</code>、<code>rotation</code>、<code>ease</code>和<code>scale</code>这样的属性。</p>
<p>当应用于模板时，上面的示例如下所示:</p>
<p><span class="embed-youtube"> <iframe loading="lazy" class="youtube-player" src="https://www.youtube.com/embed/xGgUDxj3FQo?version=3&amp;rel=1&amp;showsearch=0&amp;showinfo=1&amp;iv_load_policy=1&amp;fs=1&amp;hl=en-US&amp;autohide=2&amp;wmode=transparent" allowfullscreen="true" sandbox="allow-scripts allow-same-origin allow-popups allow-presentation">视频</iframe> </span></p>
<p>类似于Anime.js，你可以用GSAP做很多很酷的事情。你也可以做时间线和其他序列动画。要更深入地了解，请查看<a href="https://greensock.com/get-started/">GSAP入门页面</a>。完整的例子列表，你可以查看<a href="https://codepen.io/GreenSock"> GSAP密码页</a>。</p>
<p>我介绍的组件的完整工作副本在我的示例项目<a href="https://github.com/andrewevans0102/compare-javascript-animation-libraries/blob/master/src/components/GSAP.js">这里</a>中。</p>
<p><strong>优点</strong>:</p>
<ul>
<li>非常健壮的API，有很多可能的动画</li>
<li>非常好的带有示例的文档</li>
</ul>
<p><strong>缺点</strong>:</p>
<ul>
<li>特定的应用程序可能有特殊情况。我并没有真正涵盖这一点，但GSAP也包括周围的角度，反应等指示。</li>
<li>大量的API选项可能会让初学者望而生畏</li>
</ul>
<h2>三. js</h2>
<p>到目前为止，所有的动画要么直接与DOM元素交互，要么添加自定义元素。<a href="https://threejs.org/"> Three.js </a>库使用<a href="https://get.webgl.org/"> WebGL </a>渲染动画。</p>
<p>WebGL是什么？WebGL是一个DOM API，使您能够在浏览器中呈现图形。它确实使用了canvas元素，但与我们在p5.js中看到的生成画布并在其上书写不同，WebGL允许您调用API来为您进行渲染。</p>
<p>Three.js是一个协调WebGL调用的库，用于在浏览器中呈现图像和图形。如果您想创建与项目相关的动画或3D图形，这真的很棒。</p>
<p>Three.js有一个很棒的演练样本项目<a href="https://threejs.org/docs/index.html#manual/en/introduction/Creating-a-scene">，可以在这里</a>到达。正如我提到的，我的示例项目使用React，因此设置略有不同。核心概念和API调用都是一样的。</p>
<p>如果您对理解(或让示例工作)有任何问题，我建议在这里查看Three.js文档中的解释<a href="https://threejs.org/docs/#manual/en/introduction/Creating-a-scene">。</a></p>
<p>实现这一点是一个多步骤的过程。我们必须首先定义用于动画的渲染器:</p>
<pre>    const scene = new THREE.Scene();
    let camera = new THREE.PerspectiveCamera(75, 400 / 400, 0.1, 1000);
    const renderer = new THREE.WebGLRenderer();
    renderer.setSize(400, 400);
    this.mount.appendChild(renderer.domElement);</pre>
<p>Three.js称之为“创造场景”。它的长与短基本上是创造动画发生的区域。</p>
<p>接下来，我们定义想要制作动画的对象:</p>
<pre>    const geometry = new THREE.BoxGeometry(1, 1, 1);
    const material = new THREE.MeshNormalMaterial();
    const cube = new THREE.Mesh(geometry, material);
    scene.add(cube);</pre>
<p>这里，我们使用Three.js全局对象来定义立方体和与它相关联的动画材质。</p>
<p>接下来，我们定义动画方法:</p>
<pre>    camera.position.z = 5;
    const animate = function () {
      requestAnimationFrame(animate);
      cube.rotation.x += 0.01;
      cube.rotation.y += 0.01;
      renderer.render(scene, camera);
    };</pre>
<p>这就是将要调用的内容，以及Three.js如何调用WebGL API方法来显示动画。</p>
<p>最后，我们直接调用<code>animate</code>方法来渲染动画:</p>
<pre>    animate();</pre>
<p>为了让所有这些都与React一起工作，我们只需将它放在我们想要显示的组件的<code>componentDidMount</code>生命周期方法中:</p>
<pre>  componentDidMount() {
    // create the scene and renderer for the animation
    const scene = new THREE.Scene();
    let camera = new THREE.PerspectiveCamera(75, 400 / 400, 0.1, 1000);
    const renderer = new THREE.WebGLRenderer();
    renderer.setSize(400, 400);
    this.mount.appendChild(renderer.domElement);

    // create the elements that become a rotating cube and add them to the scene
    const geometry = new THREE.BoxGeometry(1, 1, 1);
    const material = new THREE.MeshNormalMaterial();
    const cube = new THREE.Mesh(geometry, material);
    scene.add(cube);
    // create the actual animation function that will draw the animation with WebGL
    camera.position.z = 5;
    const animate = function () {
      requestAnimationFrame(animate);
      cube.rotation.x += 0.01;
      cube.rotation.y += 0.01;
      renderer.render(scene, camera);
    };
    // call the animation function to show the rotating cube on the page
    animate();
  }</pre>
<p>生成的动画如下所示:</p>
<p><span class="embed-youtube"> <iframe loading="lazy" class="youtube-player" src="https://www.youtube.com/embed/SKvuFvrdYTc?version=3&amp;rel=1&amp;showsearch=0&amp;showinfo=1&amp;iv_load_policy=1&amp;fs=1&amp;hl=en-US&amp;autohide=2&amp;wmode=transparent" allowfullscreen="true" sandbox="allow-scripts allow-same-origin allow-popups allow-presentation">视频</iframe> </span></p>
<p>你可以用Three.js做很多很酷的事情。我推荐在这里查看他们的<a href="https://threejs.org/docs/index.html#manual/en/introduction/Creating-a-scene">文档</a>和在这里查看<a href="https://threejs.org/examples/#webgl_animation_cloth">示例</a>。</p>
<p>在我的示例项目<a href="https://github.com/andrewevans0102/compare-javascript-animation-libraries/blob/master/src/components/Three.js">这里</a>中可以找到我所涉及的组件的完整工作副本。</p>
<p><strong>优点</strong>:</p>
<ul>
<li>您可以利用API与WebGL进行交互，这使得使用API变得更加容易</li>
<li>您可以利用Three.js来创建图形</li>
</ul>
<p><strong>缺点</strong>:</p>
<ul>
<li>它需要手动向DOM添加一个元素</li>
<li>有一个与库和WebGL概念相关的学习曲线</li>
</ul>
<h2>结束语</h2>
<p>我希望这篇文章能让你对目前可用的一些不同的JavaScript动画库有一个基本的了解。</p>
<p>我想指出我介绍的四个库之间的一些共性。</p>
<p>对于Anime.js和GSAP，他们都是通过导入一个全局对象，识别要应用动画的元素，然后定义动画来完成动画的，就像这样:</p>
<pre>// anime.js
    anime({
      targets: ".anime__label",
      translateX: "250px",
      rotate: "1turn",
      backgroundColor: "#FFC0CB",
      duration: 800,
      direction: "alternate"
    });

// GSAP
gsap.to(".gsap__label", { duration: 3, rotation: 360, scale: 0.5 });</pre>
<p>使用p5.js和Three.js，可以创建定制元素并附加到DOM中。两者都利用HTML画布来生成相关联的动画，如下所示:</p>
<pre>// P5.js
Sketch = (p) =&gt; {
  let x = 100;
  let y = 100;
  p.setup = () =&gt; {
    p.createCanvas(640, 480);
  }
  p.draw = () =&gt; {
    if (p.mouseIsPressed) {
      p.fill("#000000");
    } else {
      p.fill("#FFFFFF");
    }
    p.ellipse(p.mouseX, p.mouseY, 80, 80);
  }
}

// Three.js
const scene = new THREE.Scene();
let camera = new THREE.PerspectiveCamera(75, 400 / 400, 0.1, 1000);
const renderer = new THREE.WebGLRenderer();
renderer.setSize(400, 400);
this.mount.appendChild(renderer.domElement);</pre>
<p>看到这些常见的行为会让您对任何JavaScript动画库有所了解。正如我在介绍中所说的，虽然这篇文章专门介绍了这四个库，但是今天仍然有许多其他的库可供您使用。</p>
<p>最好的部分是，随着web开发和浏览器技术的进步，JavaScript动画可以做比以前更多的事情。我鼓励您阅读与本文所涉及的库相关的文档，以获得更多信息。</p>
<p>感谢您阅读我的帖子！在Twitter上关注我，地址:<a href="https://twitter.com/AndrewEvans0102"> @AndrewEvans0102 </a>！</p><div class="code-block code-block-27">
<div class="blog-plug inline-plug vanilla-javascript-cta"><h2>通过理解上下文，更容易地调试JavaScript错误</h2>
<p>调试代码总是一项单调乏味的任务。但是你越了解自己的错误，就越容易改正。</p>
<p>LogRocket 让你以新的独特的方式理解这些错误。我们的前端监控解决方案跟踪用户与您的JavaScript前端的互动，让您能够准确找出导致错误的用户行为。</p>
<a href="https://lp.logrocket.com/blg/javascript-signup" class="signup" target="_blank" rel="noopener noreferrer"><img class="alignnone size-full wp-image-46 jetpack-lazy-image" src="../Images/cbfed9be3defcb505e662574769a7636.png" alt="LogRocket Dashboard Free Trial Banner" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2020/06/reproduce-javascript-errors.gif?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/06/reproduce-javascript-errors.gif"/><noscript><img data-lazy-fallback="1" class="alignnone size-full wp-image-46" src="../Images/cbfed9be3defcb505e662574769a7636.png" alt="LogRocket Dashboard Free Trial Banner" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/06/reproduce-javascript-errors.gif"/></noscript></a>
<p>LogRocket记录控制台日志、页面加载时间、堆栈跟踪、慢速网络请求/响应(带有标题+正文)、浏览器元数据和自定义日志。理解您的JavaScript代码的影响从来没有这么简单过！</p>
<a class="signup" href="https://lp.logrocket.com/blg/javascript-signup" target="_blank" rel="noopener noreferrer">Try it for free</a><p>.</p></div>


</div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>
 
</div>    
</body>
</html>
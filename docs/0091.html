<html>
<head>
<title>JavaScript Testing: Chai (Part 1) - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>JavaScript测试:Chai(第1部分)- LogRocket博客</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/javascript-testing-chai-part-1-c7d0496a17c1/#0001-01-01">https://blog.logrocket.com/javascript-testing-chai-part-1-c7d0496a17c1/#0001-01-01</a></blockquote><div><div class="mainheading">


<h1 class="posttitle">JavaScript测试:Chai(第1部分)</h1>
<h2 class="post-subtitle"/>
<p><span class="post-date"><time class="post-date">2017年3月10日</time> </span> <span class="dot"/> <span class="readingtime"> 2分钟阅读</span> <span class="wordcount"> 592 </span> <span class="logrocket_editor"/></p>
</div>
<article class="article-post">
<p>在LogRocket，几乎我们整个代码库都是JavaScript。多年来，我们已经了解了很多JavaScript测试库鲜为人知的特性。在本系列中，我将浏览LogRocket测试栈，并描述一些有助于使我们的测试更快、更健壮的技巧和诀窍。</p>
<ul>
<li>第1部分:测试期望—柴</li>
<li>第2部分:mocks测试-否则</li>
<li>第2部分:测试框架— Jest和Mocha</li>
<li>第3部分:集成测试— WebdriverIO和Selenium</li>
</ul>
<h3>柴</h3>
<figure><img decoding="async" src="../Images/b487eb11455801188213248fc15dc54a.png" data-height="217" data-width="193" data-lazy-src="https://storage.googleapis.com/blog-images-backup/1*OgPUvXK_nyEsUrgvsfT6Yg.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" class=" jetpack-lazy-image" data-original-src="https://storage.googleapis.com/blog-images-backup/1*OgPUvXK_nyEsUrgvsfT6Yg.png"/><noscript><img data-lazy-fallback="1" decoding="async" src="../Images/b487eb11455801188213248fc15dc54a.png" data-height="217" data-width="193" data-original-src="https://storage.googleapis.com/blog-images-backup/1*OgPUvXK_nyEsUrgvsfT6Yg.png"/></noscript></figure>
<p>Chai 是一个“测试期望”库:它帮助你做出关于代码行为的断言。Chai本身有多种语法风格，您可以从中选择一种来进行断言。</p>
<p>例如，如果您想要断言<code>foo</code>是一个<code>string</code>，有几个不同的选项:</p>
<pre>// should
chai.should();
foo.should.be.a(‘string’);

// expect
chai.expect(foo).to.be.a(‘string’);

// assert
chai.assert.typeOf(foo, ‘string’);</pre>
<h3>expect()to . throw()</h3>
<p>作为JavaScript工程师，我们非常擅长确保输入正确时代码正常工作。最大的挑战——也是编写测试的最好理由之一——是为失败或意外的输入做出断言。</p>
<p>Chai提供了一个方便的助手，让我们断言代码<em>应该抛出一个异常</em>。这对于在需要用户名的代码中抛出像<code>-1</code>、<code>★★François★★</code>和<code>function(){alert()}</code>这样的输入非常有用。</p>
<p>下面是一个用法示例:</p>
<pre>expect(() =&gt; {
  callSomeFunction();
}).to.throw(/an error/);</pre>
<h3>equal()与eql()</h3>
<p>Chai提供了许多用于确定等式的内置函数。断言两个参数在指称上相等(即。<code>a === b)</code>。<code>eql()</code>对两个参数进行深度相等检查。</p>
<p>示例:</p>
<pre>expect('rocket').to.equal('rocket') // true
expect('rocket').to.eql('rocket') // true
expect({ log: 'rocket' }).to.equal({ log: 'rocket' }) // false
expect({ log: 'rocket' }).to.eql({ log: 'rocket' }) // true</pre>
<p>为什么要用equal/eql而不是<code>expect(foo === 'rocket').to.be.true</code>？我们得到了漂亮的测试输出，如下所示:</p>
<figure><img decoding="async" src="../Images/f78cc42c306b0b157db6b7388c576f61.png" data-height="185" data-width="434" data-lazy-src="https://storage.googleapis.com/blog-images-backup/1*RtS3gwGegKPqZH_RF0mEAg.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" class=" jetpack-lazy-image" data-original-src="https://storage.googleapis.com/blog-images-backup/1*RtS3gwGegKPqZH_RF0mEAg.png"/><noscript><img data-lazy-fallback="1" decoding="async" src="../Images/f78cc42c306b0b157db6b7388c576f61.png" data-height="185" data-width="434" data-original-src="https://storage.googleapis.com/blog-images-backup/1*RtS3gwGegKPqZH_RF0mEAg.png"/></noscript></figure>
<p>而不是这个:</p>
<figure><img decoding="async" src="../Images/e806cc01b3ba6734fa4b879c69c78783.png" data-height="82" data-width="357" data-lazy-src="https://storage.googleapis.com/blog-images-backup/1*5kUc0khOs7BBfM65GWhY-Q.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" class=" jetpack-lazy-image" data-original-src="https://storage.googleapis.com/blog-images-backup/1*5kUc0khOs7BBfM65GWhY-Q.png"/><noscript><img data-lazy-fallback="1" decoding="async" src="../Images/e806cc01b3ba6734fa4b879c69c78783.png" data-height="82" data-width="357" data-original-src="https://storage.googleapis.com/blog-images-backup/1*5kUc0khOs7BBfM65GWhY-Q.png"/></noscript></figure>
<h3>脏柴</h3>
<p>Chai可以通过各种插件进行扩展，提供额外的功能，比如<code><a href="http://chaijs.com/plugins/chai-string/" target="_blank" rel="noopener noreferrer">chai-string</a></code>增加了方便的字符串测试功能、<code><a href="http://chaijs.com/plugins/chai-as-promised/" target="_blank" rel="noopener noreferrer">chai-as-promised</a></code>允许我们编写关于承诺的断言，以及<code><a href="http://chaijs.com/plugins/chai-datetime/" target="_blank" rel="noopener noreferrer">chai-datetime</a></code>提供日期断言。</p>
<p>一个方便但不太为人所知的插件是<code><a href="https://github.com/prodatakey/dirty-chai" target="_blank" rel="noopener noreferrer">dirty-chai</a></code>。通常情况下柴只能做出这样的断言:</p>
<pre>expect(foo).to.be.true</pre>
<p>这可能是易碎的。如果我不小心打错了，那么断言永远不会被检查:</p>
<pre>expect(foo).to.be.frue</pre>
<p>相反，我们使用<code>dirty-chai</code>，它用函数调用扩展了chai，如下所示:</p>
<pre>expect(foo).to.be.true()</pre>
<p>这样，如果我犯了语法错误，测试将抛出一个异常，而不是无声无息地通过。</p>
<h3>否则-柴</h3>
<p>Sinon是一个用JavaScript编写测试“间谍”和“存根”的神奇库。使用Sinon，我们可以模拟对测试断言没有贡献的功能。在测试中您可能想要使用stub或spy的原因有很多:</p>
<ul>
<li>伪造一个网络接口，查看组件如何响应特定的网络条件</li>
<li>依赖于与DOM接口的模拟代码</li>
<li>断言某个回调被测试调用。</li>
</ul>
<p><code>sinon-chai</code>允许我们用柴语法作出兴农断言:</p>
<pre>const stub = sinon.spy();
expect(stub).to.be.calledOnce();</pre>
<p>我将在本系列的另一篇博文中更全面地描述Sinon。</p>
<h3>eslint-plugin-chai-expect</h3>
<p>如果你使用<code>eslint</code>来lint你的代码，<a href="https://www.npmjs.com/package/eslint-plugin-chai-expect" target="_blank" rel="noopener noreferrer">eslint-plugin-chai-expect</a>可以防止一些最常见的语法错误:</p>
<pre>expect(foo === bar).to.be.true(); // no-inner-compare
expect(foo) // missing-assertion</pre>
<p>关于柴的断言，你还学到了什么？请在评论中告诉我！</p>
<figure><img decoding="async" src="../Images/d4100b8800a7db777f2c0b50e7240866.png" data-height="400" data-width="682" data-lazy-src="https://storage.googleapis.com/blog-images-backup/1*pnNR2ehJtOCDxx1cfBQdKQ.jpeg?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" class=" jetpack-lazy-image" data-original-src="https://storage.googleapis.com/blog-images-backup/1*pnNR2ehJtOCDxx1cfBQdKQ.jpeg"/><noscript><img data-lazy-fallback="1" decoding="async" src="../Images/d4100b8800a7db777f2c0b50e7240866.png" data-height="400" data-width="682" data-original-src="https://storage.googleapis.com/blog-images-backup/1*pnNR2ehJtOCDxx1cfBQdKQ.jpeg"/></noscript></figure>
<p> </p><div class="code-block code-block-27">
<div class="blog-plug inline-plug vanilla-javascript-cta"><h2>通过理解上下文，更容易地调试JavaScript错误</h2>
<p>调试代码总是一项单调乏味的任务。但是你越了解自己的错误，就越容易改正。</p>
<p>LogRocket 让你以新的独特的方式理解这些错误。我们的前端监控解决方案跟踪用户与您的JavaScript前端的互动，让您能够准确找出导致错误的用户行为。</p>
<a href="https://lp.logrocket.com/blg/javascript-signup" class="signup" target="_blank" rel="noopener noreferrer"><img class="alignnone size-full wp-image-46 jetpack-lazy-image" src="../Images/cbfed9be3defcb505e662574769a7636.png" alt="LogRocket Dashboard Free Trial Banner" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2020/06/reproduce-javascript-errors.gif?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/06/reproduce-javascript-errors.gif"/><noscript><img data-lazy-fallback="1" class="alignnone size-full wp-image-46" src="../Images/cbfed9be3defcb505e662574769a7636.png" alt="LogRocket Dashboard Free Trial Banner" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/06/reproduce-javascript-errors.gif"/></noscript></a>
<p>LogRocket记录控制台日志、页面加载时间、堆栈跟踪、慢速网络请求/响应(带有标题+正文)、浏览器元数据和自定义日志。理解您的JavaScript代码的影响从来没有这么简单过！</p>
<a class="signup" href="https://lp.logrocket.com/blg/javascript-signup" target="_blank" rel="noopener noreferrer">Try it for free</a><p>.</p></div>


</div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
<html>
<head>
<title>React Router v6: The future of Reach Router and React Router - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>React路由器V6:Reach路由器和React路由器的未来</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/react-router-v6-future-reach-router/#0001-01-01">https://blog.logrocket.com/react-router-v6-future-reach-router/#0001-01-01</a></blockquote><div><article class="article-post">
<p><em> <strong>编者按</strong>:这篇文章最后一次更新是在2021年12月30日，包含了关于React路由器v6的信息。</em></p>
<p>2019年5月，React路由器和Reach路由器的联合创始人Ryan Florence宣布<a href="https://reacttraining.com/blog/reach-react-router-future/">即将发布利用React的Hooks API的React路由器</a>新版本。他还表示，React Router将是幸存的项目，而Reach Router将继续以错误修复的形式获得支持。</p>
<p>快进到2019年9月，React路由器v5.1最终发布；这个版本是对新的基于钩子的API的介绍，并带有一些令人惊奇的特性。新的挂钩也使布线更加容易。</p>
<p>在本文中，我将讨论React Router中的最新特性，将Reach Router和React Router与新的基于Hooks的API进行比较，并简要讨论如何迁移到这个API。我们开始吧！</p>
<h3>目录</h3>

<h2 id="the-usehistory-hook"><code>useHistory</code>钩子</h2>
<p><a href="https://v5.reactrouter.com/web/api/Hooks/usehistory"> <code>useHistory</code>钩子</a>让您可以从历史包中访问<code>history</code>实例，这是React路由器的主要依赖项之一。<code>history</code>对象允许在React应用程序中的路线之间进行编程导航。</p>
<p>要访问React路由器v4中的<code>history</code>对象，您必须使用<code>history</code>属性。假设我们想使用一个按钮以编程方式导航到一条名为<code>home</code>的路线。使用React路由器v4，我们的代码将类似于以下内容:</p>
<pre>function HomeButton({history}) {
  function handleClick() {
    history.push("/home");
  }
  return (
    &lt;button type="button" onClick={handleClick}&gt;
      Go home
    &lt;/button&gt;
  );
}
</pre>
<p>然而，随着<code>useHistory</code>钩子的引入，我们可以很容易地访问<code>history</code>对象并如下使用它:</p>
<pre>import { useHistory } from "react-router-dom";

function HomeButton() {
  const history = useHistory();
  function handleClick() {
    history.push("/home");
  }
  return (
    &lt;button type="button" onClick={handleClick}&gt;
      Go home
    &lt;/button&gt;
  );
}</pre>
<p>如果用户点击按钮，<code>home</code>条目将被推送到<code>history</code>堆栈上，呈现主页。</p>
<h2 id="the-usenavigate-hook"><code>useNavigate</code>钩子</h2>
<p>或者，您可以使用<a href="https://reach.tech/router/api/useNavigate"> <code>useNavigate</code>钩</a>。像<code>useHistory</code>一样，<code>useNavigate</code>钩子允许开发者通过代码在应用中导航。看看下面这个简单的例子:</p>
<pre>import { useNavigate } from "react-router";

function About() {
  //create an instance of useNavigate
  //this allows us to access this hook's functions
  let navigate = useNavigate();
  function goToPhonePage() {
    //when executed, direct the user to the /phone page.
    navigate("/phone");
  }
  return (
    &lt;div&gt;
      &lt;p&gt; At about page&lt;/p&gt;
      {/*When clicked, run the goToPhonePage method */}
      &lt;button onClick={goToPhonePage}&gt; Check out our new phone&lt;/button&gt;
    &lt;/div&gt;
  );
} 
</pre>
<p>上面代码的输出如下所示:</p>
<p><img data-attachment-id="85004" data-permalink="https://blog.logrocket.com/react-router-v6-future-reach-router/react-router-usenavigate-hook/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/04/react-router-usenavigate-hook.gif" data-orig-size="654,405" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="react-router-usenavigate-hook" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/04/react-router-usenavigate-hook-300x186.gif" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/04/react-router-usenavigate-hook.gif" decoding="async" class="aligncenter wp-image-85004 size-full jetpack-lazy-image" src="../Images/37a23eed3f7f8b8344894a4e9b32e88d.png" alt="React Router useNavigate Hook" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2020/04/react-router-usenavigate-hook.gif?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/04/react-router-usenavigate-hook.gif"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="85004" data-permalink="https://blog.logrocket.com/react-router-v6-future-reach-router/react-router-usenavigate-hook/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/04/react-router-usenavigate-hook.gif" data-orig-size="654,405" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="react-router-usenavigate-hook" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/04/react-router-usenavigate-hook-300x186.gif" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/04/react-router-usenavigate-hook.gif" decoding="async" loading="lazy" class="aligncenter wp-image-85004 size-full" src="../Images/37a23eed3f7f8b8344894a4e9b32e88d.png" alt="React Router useNavigate Hook" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/04/react-router-usenavigate-hook.gif"/></noscript>
<h2 id="the-uselocation-hook"><code>useLocation</code>钩子</h2>
<p><a href="https://v5.reactrouter.com/web/api/Hooks/uselocation"> <code>useLocation</code>钩子</a>返回代表当前URL的<code>location</code>对象。使用<code>location</code>对象的state属性，<code>location</code>对象也可以用来访问从另一个路由发送的数据。</p>
<p>要在React Router v4和Reach Router中访问<code>location</code>对象，您必须分别使用props或<code>Location</code>组件。下面的代码片段演示了如何使用React Router v4访问<code>location</code>对象:</p>
<pre>function RandomRoute({ location }) {
  return &lt;h1&gt;Current pathname: {location.pathname}&lt;/h1&gt;;
}
</pre>
<p>下面的代码片段演示了如何在Reach Router中访问<code>location</code>对象:</p>
<pre>function RandomRoute() {
  return (
    &lt;Location&gt;
      {({ location }) =&gt; &lt;h1&gt;Current pathname: {location.pathname}&lt;/h1&gt;}
    &lt;/Location&gt;
  );
}
</pre>
<p>使用新的<code>useLocation</code>钩子，您可以更方便地访问<code>location</code>对象:</p>
<pre>function RandomRoute() {
  const location = useLocation();
  return &lt;h1&gt;Current pathname: {location.pathname}&lt;/h1&gt;;
}
</pre>
<p><code>useLocation</code>的一个关键用例是<a href="https://blog.logrocket.com/debugging-react-performance-issues-with-why-did-you-render/">在调试过程中帮助开发者</a>。下面的代码片段记录了用户每次点击链接时的当前页面:</p>
<pre>import { useLocation } from "react-router-dom";

export default function App() {
  const location = useLocation();
  useEffect(() =&gt; {
    console.log(location.pathname);
  }, []);
  //location is dependency, this means that this useEffect will run
  //everytime the value of 'location' changes
  return (
    &lt;Switch&gt;
      &lt;Route exact path="/"&gt;
        &lt;Home /&gt;
      &lt;/Route&gt;
      &lt;Route path="/about"&gt;
        &lt;About /&gt;
      &lt;/Route&gt;
      &lt;Route path="/phone"&gt;
        &lt;Phone /&gt;
      &lt;/Route&gt;
    &lt;/Switch&gt;
  );
}
</pre>
<p>在上面的代码中，我们首先创建了一个名为<code>location</code>的变量，它将是<code>useLocation</code>钩子的一个实例。这使我们可以访问包含用户当前位置的<code>pathname</code>对象。我们还使用了<code>useEffect</code>函数来注销用户的当前路径:</p>
<p><img data-attachment-id="85020" data-permalink="https://blog.logrocket.com/react-router-v6-future-reach-router/react-router-uselocation-hook/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/04/react-router-uselocation-hook.gif" data-orig-size="654,604" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="react-router-uselocation-hook" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/04/react-router-uselocation-hook-300x277.gif" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/04/react-router-uselocation-hook.gif" decoding="async" class="aligncenter wp-image-85020 size-full jetpack-lazy-image" src="../Images/0f49b5d3909dfe9b8ac9eb3540c0520d.png" alt="React Router useLocation Hook" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2020/04/react-router-uselocation-hook.gif?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/04/react-router-uselocation-hook.gif"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="85020" data-permalink="https://blog.logrocket.com/react-router-v6-future-reach-router/react-router-uselocation-hook/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/04/react-router-uselocation-hook.gif" data-orig-size="654,604" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="react-router-uselocation-hook" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/04/react-router-uselocation-hook-300x277.gif" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/04/react-router-uselocation-hook.gif" decoding="async" loading="lazy" class="aligncenter wp-image-85020 size-full" src="../Images/0f49b5d3909dfe9b8ac9eb3540c0520d.png" alt="React Router useLocation Hook" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/04/react-router-uselocation-hook.gif"/></noscript>
<h2 id="the-useparams-hook"><code>useParams</code>钩子</h2>
<p>React Router v5.1还为我们提供了新的<a href="https://v5.reactrouter.com/web/api/Hooks/useparams"> <code>useParams</code>钩子</a>，它返回URL参数的键值对对象。React Router和Reach Router用户通常使用的URL参数允许我们通过URL方便地传递关于点击事件的信息。</p>
<p>在Reach Router和React Router的早期版本中，访问URL参数的唯一方式是通过props，在Reach Router的情况下，是通过<code>Match</code>组件。使用React路由器v4，我们的代码将如下所示:</p>
<pre>import {
  BrowserRouter as Router,
  Switch,
  Route,
  Link
} from "react-router-dom";
function App() {
  return (
    &lt;Router&gt;
      &lt;header&gt;
        &lt;nav&gt;
          &lt;Link to="/"&gt;Home&lt;/Link&gt;
          &lt;Link to = "/page/2"&gt;Page 2&lt;/Link&gt;
        &lt;/nav&gt;
      &lt;/header&gt;
      &lt;Switch&gt;
        &lt;Route path = "/page/:pageNumber" component = {Page}&gt;
        &lt;Route path="/" render={() =&gt; &lt;h1&gt;Home&lt;/h1&gt;} /&gt;
      &lt;/Switch&gt;
    &lt;/Router&gt;
  );
}
function Page({match}) {
  const {pageNumber} = match.params;
  return &lt;h1&gt;Page Number:{pageNumber}&lt;/h1&gt;;
}
</pre>
<p>在到达路由器的情况下:</p>
<pre>import { Router, Link } from "@reach/router";
function App() {
  return (
    &lt;&gt;
      &lt;header&gt;
        &lt;nav&gt;
          &lt;Link to="/"&gt;Home&lt;/Link&gt;
          &lt;Link to="/page/2"&gt;Page 2&lt;/Link&gt;
        &lt;/nav&gt;
      &lt;/header&gt;
      &lt;Router&gt;
        &lt;Home path="/" /&gt;
        &lt;Page path="/page/:pageNumber" /&gt;
      &lt;/Router&gt;
    &lt;/&gt;
  );
}
const Home = () =&gt; &lt;h1&gt;Home&lt;/h1&gt;;
function Page(props) {
  return &lt;h1&gt;Page Number:{props.pageNumber}&lt;/h1&gt;;
}
</pre>
<p>尽管上面的方法对于大多数用例来说都很好，但是如果您试图将URL参数向下传递给子组件，您将不得不将它们作为道具来传递，从而使您的代码变得混乱。您可以使用<a href="https://blog.logrocket.com/react-context-api-deep-dive-examples/">上下文API来缓解这个问题</a>，但是，这样做可能会在您的代码中引入不必要的复杂性。</p>
<p>有了新的Hooks API，您可以轻松地在任何子组件中调用<code>useParams</code>钩子来获取URL参数。如果我们重写代码来使用钩子，它看起来会像这样:</p>
<pre>import { useParams } from "react-router-dom";

export default function App() {
  return (
    &lt;Router&gt;
      &lt;div&gt;
        &lt;Switch&gt;
          &lt;Route path="/page/:pageNumber" children={&lt;Page /&gt;} /&gt;
        &lt;/Switch&gt;
      &lt;/div&gt;
    &lt;/Router&gt;
  );
}

function Page() {
//extract the pageNumber parameter.
  const { pageNumber } = useParams();
  return (
    &lt;div&gt;
      &lt;p&gt; Current page: {pageNumber}&lt;/p&gt;
    &lt;/div&gt;
  );
}
</pre>
<p><img data-attachment-id="85022" data-permalink="https://blog.logrocket.com/react-router-v6-future-reach-router/useparams-hook-react-router/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/04/useparams-hook-react-router.gif" data-orig-size="403,324" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="useparams-hook-react-router" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/04/useparams-hook-react-router-300x241.gif" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/04/useparams-hook-react-router.gif" decoding="async" class="aligncenter wp-image-85022 size-full jetpack-lazy-image" src="../Images/4954a21debd5dd01fe2deb8e83891dfa.png" alt="useParams Hook React Router" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2020/04/useparams-hook-react-router.gif?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/04/useparams-hook-react-router.gif"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="85022" data-permalink="https://blog.logrocket.com/react-router-v6-future-reach-router/useparams-hook-react-router/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/04/useparams-hook-react-router.gif" data-orig-size="403,324" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="useparams-hook-react-router" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/04/useparams-hook-react-router-300x241.gif" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/04/useparams-hook-react-router.gif" decoding="async" loading="lazy" class="aligncenter wp-image-85022 size-full" src="../Images/4954a21debd5dd01fe2deb8e83891dfa.png" alt="useParams Hook React Router" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/04/useparams-hook-react-router.gif"/></noscript>
<h2 id="the-useroutematch-hook"><code>useRouteMatch</code>钩子</h2>
<p>最后，我们有<a href="https://v5.reactrouter.com/web/api/Hooks/useroutematch"> <code>useRouteMatch</code>挂钩</a>。在Reach Router中，要访问路由的<code>match</code>对象，您必须使用<code>Match</code>组件。如果您使用的是早期版本的React Router，则必须使用路线的道具或渲染道具。有了<code>useRouteMatch</code>钩子，访问<code>match</code>对象更加容易和方便。</p>
<p><code>useRouteMatch</code>钩子接受一个路径作为参数，并返回一个相应的<code>match</code>对象。当没有传递参数时，钩子根据树中最匹配的<code>&lt;Route&gt;</code>返回一个<code>match</code>对象。</p>
<p>React路由器中访问匹配对象的前一种方式如下:</p>
<pre>//option 1
function ARoute() {
  return (
    &lt;Route
      path="/randomroute/:randomrouteid"
      render={({ match }) =&gt; {
        return (
          ...
        );
      }}
    /&gt;
  );
}

//option 2
function ARoute(props){
  const match = props.match;
  return (
    ...
  );
}
</pre>
<p>要在到达路由器中获取<code>match</code>对象，我们必须使用提供的<code>Match</code>组件:</p>
<pre>function AnotherRandomRoute(){
    return(
        &lt;Match path = "/randomroute/:randomrouteid"&gt;
            {
                ({match}) =&gt; ...
            }
        &lt;/Match&gt;
    );
}
</pre>
<p>上面的代码块工作正常，但是我们可以用<code>useRouteMatch</code>钩子使我们的代码更短更简洁:</p>
<pre>function AnotherRandomRoute(){
    const match = useRouteMatch("/randomroute/:randomrouteid");
    return(
        ...
    );
}
</pre>
<p>使用<code>useRouteMatch</code>，您还可以使用<code>match</code>对象的<code>url</code>和<code>path</code>属性实现嵌套路由。下面是一个例子，说明如何在React Router中用<code>useRouteMatch</code>钩子处理嵌套路由:</p>
<pre>function Topics() {
  const { path, url } = useRouteMatch();
  return (
    &lt;div&gt;
      &lt;div&gt;
        &lt;Link to={`${url}/1`}&gt;Topic 1&lt;/Link&gt;
        &lt;Link to={`${url}/2`}&gt;Topic 2&lt;/Link&gt;
        &lt;Switch&gt;
          &lt;Route exact path={path} render={() =&gt; &lt;h1&gt;Select a topic&lt;/h1&gt;} /&gt;
          &lt;Route path={`${path}/:topic`}&gt;
            &lt;Topic /&gt;
          &lt;/Route&gt;
        &lt;/Switch&gt;
      &lt;/div&gt;
    &lt;/div&gt;
  );
}
function Topic() {
  const { topic } = useParams();
  return (
    &lt;div&gt;
      &lt;h1&gt;Topic: {topic}&lt;/h1&gt;
    &lt;/div&gt;
  );
}</pre>
<blockquote><p>在任何时候，如果您想在<code>Switch</code>组件之外使用Route组件，那么<code>useRouteMatch</code>也是很有帮助的。</p></blockquote>
<h2 id="link-navlink-components">对<code>Link</code>和<code>NavLink</code>组件的更新</h2>
<p>React Router v5.1还对<code>Link</code>和<code>NavLink</code>组件进行了一些更新，其中之一是能够将功能传递给这些组件的<code>to</code>道具。当前位置作为参数传递给函数，该函数必须以对象或字符串的形式返回位置表示。</p>
<h2 id="react-router-v6">React路由器v6</h2>
<p>在更新本文时，<a href="https://blog.logrocket.com/react-router-v6/"> React路由器团队已经发布了v6 </a>，它包括以下特性:</p>
<h3>较小的捆尺寸</h3>
<p>新包的当前大小大约是6kB。根据<a href="https://twitter.com/mjackson/status/1229156979714605056?s=20">React路由器的联合创始人Michael Jackson的一条推文</a>，他们可以通过放弃对IE11之前任何功能的支持来实现这一点。这包括放弃对React &lt; 16.8的支持，使用Google Closure编译器，以及使用更新的代码。由于捆绑包较小，您的应用程序占用的内存更少，速度也比以前更快。</p>
<h3>使用新的<code>&lt;Routes&gt;</code> API进行自动<code>&lt;Route&gt;</code>排序</h3>
<p><code>&lt;Routes&gt;</code>将取代<code>&lt;Switch&gt;</code>，这意味着开发者不再需要煞费苦心地为他们所有的路线分配<code>exact</code>道具。</p>
<h3>嵌套路线改进</h3>
<p>构建复杂的路由系统现在需要更少的样板代码来开始，从而允许更小的代码库，很像React Router v3和Reach Router。</p>
<h3>附加API和挂钩</h3>
<ul>
<li>全新的悬念就绪<code>navigate</code> API，带来更优化、响应更灵敏的网络应用</li>
<li><code>useRoutes</code>和<code>matchRoutes</code>用于使用基于对象的路由API</li>
<li>一个名为<code>useNavigate</code>的新钩子，它返回一个用于编程路由和导航的函数</li>
</ul>
<p>此外，随着更多新的钩子出现，React Router承诺易于使用和最小的膨胀。关于这个版本中新特性的更多信息，<a href="https://remix.run/blog/react-router-v6">查看文档</a>。</p>
<h2 id="migrating-reach-router-hooks-based-api">从Reach路由器迁移到新的基于Hooks的API</h2>
<p>如果您计划从Reach路由器迁移，<a href="https://blog.logrocket.com/migrating-react-router-v6-complete-guide/">迁移到React路由器v6 </a>会更容易，因为它们在表面上看起来很相似。您可以通过以下步骤轻松进行迁移:</p>
<p>安装React路由器v6:</p>
<pre>npm install <a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="582a3d393b2c752a372d2c3d2a753c3735186e">[email protected]</a>
</pre>
<p>将<code>&lt;Location&gt;</code>和<code>&lt;Match&gt;</code>更换为<code>useLocation</code>和<code>useMatch</code>挂钩；</p>
<pre>const {useMatch, location} from "react-router-dom";
const match = useMatch(); //identical to useRouteMatch
const location = useLocation(); //same as to that of version 5
</pre>
<p>使用<code>useParams</code>访问URL参数:</p>
<pre>import {useParams} from "react-router-dom";
//usage is similar to that of v5:
const {pageNumber}  = useParams();
console.log(pageNumber):
</pre>
<p>在顶部放置一个<code>&lt;BrowserRouter&gt;</code>:</p>
<pre>//file: index.js
import {BrowserRouter} from "react-router-dom";
ReactDOM.render(
  &lt;BrowserRouter&gt;
    &lt;App /&gt;
  &lt;/BrowserRouter&gt;,
  document.getElementById("root")
);
</pre>
<p>将<code>&lt;Router&gt;</code>替换为<code>&lt;Routes&gt;</code>，然后使用<code>&lt;Route&gt;</code>定义您的路线:</p>
<pre>import {Routes} from "react-router-dom";
&lt;Route path="/" element={&lt;Home /&gt;} /&gt;
&lt;Route path="about" element={&lt;About /&gt;} /&gt;
</pre>
<p>下面是一个使用React路由器v6的基本示例:</p>
<pre>import { Routes, Route } from "react-router-dom";

export default function App() {
  return (
    &lt;div className="App"&gt;
      &lt;Routes&gt;
        {/*when user goes to /, render Home */}
        &lt;Route path="/" element={&lt;Home /&gt;} /&gt;
        {/*when user goes to /about, render About */}
        &lt;Route path="about" element={&lt;About /&gt;} /&gt;
      &lt;/Routes&gt;
    &lt;/div&gt;
  );
}
function Home() {
  return (
    &lt;div&gt;
      &lt;p&gt;At home &lt;/p&gt;
    &lt;/div&gt;
  );
}
function About() {
  return &lt;div&gt; About&lt;/div&gt;;
}
</pre>
<p>正如您所看到的，样板文件的数量已经显著减少，允许更简单和更可读的代码。</p>
<h2 id="conclusion">结论</h2>
<p>到目前为止，React路由器v6还是很有前景的。新的特性和钩子肯定会鼓励更干净的代码，我认为React路由器团队转向构建基于钩子的API是一个伟大的决定。我希望你喜欢这篇文章！</p><div class="code-block code-block-17">
<div class="blog-plug inline-plug react-plug" vwo-el-id="26283398190">
<h2 vwo-el-id="41600691720"><a href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener"> LogRocket </a>:全面了解您的生产React应用</h2><p>调试React应用程序可能很困难，尤其是当用户遇到难以重现的问题时。如果您对监视和跟踪Redux状态、自动显示JavaScript错误以及跟踪缓慢的网络请求和组件加载时间感兴趣，</p><a href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" vwo-el-id="19356441070">try LogRocket</a><p>. </p><a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="19356441380">
<img class="first-react-image alignnone size-full wp-image-46 jetpack-lazy-image jetpack-lazy-image--handled" src="../Images/f300c244a1a1cf916df8b4cb02bec6c6.png" vwo-el-id="18272717540" data-lazy-loaded="1" data-original-src="https://files.readme.io/27c94e7-Image_2017-06-05_at_9.46.04_PM.png"/>
</a>
<a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="19356441690">
<img class="second-react-image alignnone size-full wp-image-46 jetpack-lazy-image jetpack-lazy-image--handled" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" vwo-el-id="30720362350" data-lazy-loaded="1" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/>
</a>
<p vwo-el-id="28675660440" class="">LogRocket 结合了会话回放、产品分析和错误跟踪，使软件团队能够创建理想的web和移动产品体验。这对你来说意味着什么？</p>
<p>LogRocket不是猜测错误发生的原因，也不是要求用户提供截图和日志转储，而是让您回放问题，就像它们发生在您自己的浏览器中一样，以快速了解哪里出错了。</p>
<p>不再有嘈杂的警报。智能错误跟踪允许您对问题进行分类，然后从中学习。获得有影响的用户问题的通知，而不是误报。警报越少，有用的信号越多。</p>
<p vwo-el-id="28675660750">LogRocket Redux中间件包为您的用户会话增加了一层额外的可见性。LogRocket记录Redux存储中的所有操作和状态。</p>
<p vwo-el-id="28675661060">现代化您调试React应用的方式— <a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="40093418840">开始免费监控</a>。</p>
</div></div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
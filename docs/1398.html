<html>
<head>
<title>Put the TypeScript enums and Booleans away - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>把类型脚本枚举和布尔值放在一边</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/put-the-typescript-enums-and-booleans-away/#0001-01-01">https://blog.logrocket.com/put-the-typescript-enums-and-booleans-away/#0001-01-01</a></blockquote><div><article class="article-post">
<p>我最喜欢TypeScript这个美丽新世界的一点是TypeScript枚举。我以前在C#中使用过它们，感觉很熟悉。</p>
<p>枚举是一组命名的常量，可以采用数字或字符串形式。我一直使用基于字符串的枚举，我将在本文的所有示例中使用它:</p>
<pre>enum State {
  on = 'ON',
  off = 'OFF,
};</pre>
<h2>不当使用</h2>
<p>我在各种不合适的地方使用了枚举，比如在Redux actions中的<code>string</code>类型在<a href="https://github.com/reduxjs/redux-toolkit" target="_blank" rel="noopener">之前，@reduxjs/toolkit </a>帮助减轻了臭名昭著的Redux样板文件:</p>
<pre>enum AuthActionTypes {
  SetForcePasswordChange = "SET_PASSWORD_CHANGE"
}

interface ForcePasswordChange {
type: AuthActionTypes.SetForcePasswordChange;
}

export const forcePasswordChange = (): ForcePasswordChange =&gt; ({
  type: AuthActionTypes.SetForcePasswordChange
});</pre>
<p>我的动机是避免令人讨厌的字符串输入错误，对于这个需求，这是可行的。</p>
<h2>用一把新锤子，所有东西看起来都像钉子</h2>
<p>随着我对这个在构建时和运行时都存在的新的诱人的弗兰肯斯坦构造的信心增加，我变得更加敢于冒险。</p>
<p>枚举似乎是在有限状态机中建模状态的绝佳选择。</p>
<p>我当时不知道的是，我错过了TypeScript最突出的特性之一，它不仅仅是确保我有一组互斥的常数:</p>
<pre>enum AuthenticationStates {
  unauthorised = "UNAUTHORISED",
  authenticating = "AUTHENTICATING",
  authenticated = "AUTHENTICATED",
  errored = "ERRORED",
  forcePasswordChange = "FORCE_PASSWORD_CHANGE"
}</pre>
<p>在上面的例子中，我有一个<code>AuthenticationStates</code>枚举来模拟认证工作流。</p>
<p>用户在转换到<code>AUTHENTICATING</code>之前从<code>UNAUTHENTICATED</code>状态开始，等等。我精心制作的enum确保用户在任何时候都不会处于一个以上的矛盾状态。例如，他们不能是<code>AUTHENTICATED</code>和<code>AUTHENTICATING</code>。</p>
<h2>我需要更多的果汁</h2>
<p>然后我意识到我需要额外的数据，例如，如果发生错误，我需要知道实际的<code>Error</code>对象是什么。</p>
<p>我最初对新需求建模如下:</p>
<pre>enum AuthenticationStates {
  unauthorised = "UNAUTHORISED",
  authenticating = "AUTHENTICATING",
  authenticated = "AUTHENTICATED",
  errored = "ERRORED",
}

type State = {
  current: AuthenticationStates;
  isLoading: boolean;
  authToken?: string;
  error?: Error;
};

const current: State = {
  kind: AuthenticationStates.authenticated,
  isLoading: false,
  authToken: 'token',
  error: undefined
};</pre>
<p>我努力确保每个身份验证状态可以有相同类型的字段。</p>
<p>这种方法的问题是，每个州都有相同的字段，这可能是一个很大的错误来源，因为我可能会变得懒惰，开始复制和粘贴。</p>
<p>然后我发现了有区别的联合，也称为代数数据类型。</p>
<h2>区别联合也称为代数数据类型</h2>
<p>如果您想在聚会上给人们留下深刻印象，那么告诉他们您每天都使用代数数据类型是一个保证的全垒打！</p>
<p>在TypeScript中，我们可以创建一个与我们的<code>Authentication</code>枚举非常相似的字符串联合:</p>
<pre>type AuthenticationStates =
  | "UNAUTHORISED"
  | "AUTHENTICATING"
  | "AUTHENTICATED"
  | "ERRORED";</pre>
<p>我可以用它作为一个更强大的字符串参数类型，更好地保证什么值是允许的。</p>
<p>TypeScript中的联合可以是许多事物的联合，而不仅仅是基本类型。我们可以通过创建一个只需要与联合中的每个元素具有相同的<code>kind</code>字段的联合来使世界变得更美好。<code>kind</code>字段将作为鉴别器:</p>
<pre>export type AuthenticationStates =
  | {
      kind: "UNAUTHORISED";
      context: {
        isLoading: false
      };
    }
  | {
      kind: "AUTHENTICATING";
      context: {
        isLoading: true;
      };
    }
  | {
      kind: "AUTHENTICATED";
      context: {
        isLoading: false;
        authToken: string;
      };
    }
  | {
      kind: "ERRORED";
      context: { isLoading: false; error: Error };
    };</pre>
<p>上面的类型既是漂亮的可执行文档，我们一眼就能看到工作流中所有可用的状态。</p>
<p>上例中的鉴别器是<code>kind</code>字段，编译器使用它来<code>type narrow</code>或应用更具体的规则，因为它确定变量可能是union的哪个确切元素。</p>
<p>这里关键的一点是，每种类型只有适当的数据可用。</p>
<p>如果我们当前不处于<code>AUTHENTICATED</code>状态，我们就没有尝试访问<code>authToken</code>的权利。</p>
<p>最令人兴奋的是，与在JVM上花了太多时间的程序员相比，编译器可以更好地执行这种正确性顺序。</p>
<h2>有区别的联合上的类型收缩</h2>
<p>下面是TypeScript如何在union的鉴别器上键入narrow的示例:</p>
<pre>const transition = (state: AuthenticationStates) =&gt; {
  switch (state.kind) {
    case "UNAUTHORISED": {
      console.log(state.context.userName); // only available in UNAUTHORISED

      // this is hot!! the compiler will not allow us to access the authToken in this state
      console.log(state.context.authToken); // Property 'authToken' does not exist on type '{ isLoading: false; userName: string; password: string; }'
      break;
    }
    case "AUTHENTICATING":
      console.log(state.context.userName); // Property 'userName' does not exist on type '{ isLoading: true; }'.
      // Type 'false' is not assignable to type 'true'
      state.context.isLoading = false;
      // The only assignable value is true in this state
      state.context.isLoading = true;
      break;
    case "AUTHENTICATED":
      // here and only here do we have an authToken
      console.log(state.context.authToken);
      break;
    case "ERRORED":
      console.log(state.context.error);
      break;
  }
};</pre>
<p>你也可以在这里查看code sandbox<a href="https://codesandbox.io/s/enums-54fsy?file=/src/index.tsx:480-1482" target="_blank" rel="noopener"/>。</p>
<p>当编译器通过使用<code>kind</code>鉴别器字段缩小类型时，我们只能访问特定的数据。</p>
<p>最好的例子是:</p>
<p><img data-attachment-id="30581" data-permalink="https://blog.logrocket.com/put-the-typescript-enums-and-booleans-away/unathorised2/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/12/unathorised2.png" data-orig-size="1273,237" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="unathorised2" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/12/unathorised2-300x56.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/12/unathorised2-1024x191.png" decoding="async" class="aligncenter size-full wp-image-30581 jetpack-lazy-image" src="../Images/c86946843bc7325d3a895c88f1cc136f.png" alt="unauthorised message " data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2020/12/unathorised2.png 1273w, https://blog.logrocket.com/wp-content/uploads/2020/12/unathorised2-300x56.png 300w, https://blog.logrocket.com/wp-content/uploads/2020/12/unathorised2-1024x191.png 1024w, https://blog.logrocket.com/wp-content/uploads/2020/12/unathorised2-768x143.png 768w" data-lazy-sizes="(max-width: 1273px) 100vw, 1273px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2020/12/unathorised2.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/12/unathorised2.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="30581" data-permalink="https://blog.logrocket.com/put-the-typescript-enums-and-booleans-away/unathorised2/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/12/unathorised2.png" data-orig-size="1273,237" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="unathorised2" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/12/unathorised2-300x56.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/12/unathorised2-1024x191.png" decoding="async" loading="lazy" class="aligncenter size-full wp-image-30581" src="../Images/c86946843bc7325d3a895c88f1cc136f.png" alt="unauthorised message " srcset="https://blog.logrocket.com/wp-content/uploads/2020/12/unathorised2.png 1273w, https://blog.logrocket.com/wp-content/uploads/2020/12/unathorised2-300x56.png 300w, https://blog.logrocket.com/wp-content/uploads/2020/12/unathorised2-1024x191.png 1024w, https://blog.logrocket.com/wp-content/uploads/2020/12/unathorised2-768x143.png 768w" sizes="(max-width: 1273px) 100vw, 1273px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/12/unathorised2.png"/></noscript>
<p>如果我们试图在错误的状态下使用<code>authToken</code>，编译器将会出错。</p>
<h2>布尔值不模拟状态</h2>
<p>任何用布尔来建模状态的尝试都会失败，导致矛盾变量的激增和紧张的开发人员。</p>
<p>例如，如果我们尝试这种方法:</p>
<pre>const isAuthenticated: boolean = false;
const isErrored: boolean = false;
const isLoading: boolean = false;</pre>
<p>用不了多久，我们就会开始把这些笨蛋组合成一堆不断旋转的混乱逻辑。</p>
<pre>if (isErrored &amp;&amp;. isAuthenticated === false) {
  // do this
} else if (isLoading &amp;&amp; is isErrored) {
  // do something else</pre>
<h2>代数在哪里？</h2>
<p>这些听起来很花哨的代数数据类型只不过是一种方式，说明一种类型是由其他类型组成的。就是这样。一点也不花哨。</p>
<h2>收场白</h2>
<p>联合作为漂亮的可执行文档，也让误入歧途的程序员走上正轨，这在过去JavaScript编程的西部荒原中尤为普遍。</p>
<p>代数数据类型在函数式语言(如Haskell)中已经存在了一段时间，令人兴奋的是，TypeScript将它们带给了非常无知的前端开发人员。</p><div class="code-block code-block-21">
<div class="blog-plug inline-plug typescript-plug"><h2><a class="signup" href="https://lp.logrocket.com/blg/typescript-signup" target="_blank" rel="noopener noreferrer"> LogRocket </a>:全面了解您的网络和移动应用</h2>
<a href="https://lp.logrocket.com/blg/typescript-signup" class="signup" target="_blank" rel="noopener noreferrer"><img class="alignnone size-full wp-image-46 jetpack-lazy-image" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/><noscript><img data-lazy-fallback="1" class="alignnone size-full wp-image-46" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/></noscript></a>
<p>LogRocket 是一个前端应用程序监控解决方案，可以让您回放问题，就像问题发生在您自己的浏览器中一样。LogRocket不需要猜测错误发生的原因，也不需要向用户询问截图和日志转储，而是让您重放会话以快速了解哪里出错了。它可以与任何应用程序完美配合，不管是什么框架，并且有插件可以记录来自Redux、Vuex和@ngrx/store的额外上下文。</p>
<p>除了记录Redux操作和状态，LogRocket还记录控制台日志、JavaScript错误、堆栈跟踪、带有头+正文的网络请求/响应、浏览器元数据和自定义日志。它还使用DOM来记录页面上的HTML和CSS，甚至为最复杂的单页面和移动应用程序重新创建像素级完美视频。</p>
<a class="signup" href="https://lp.logrocket.com/blg/typescript-signup" target="_blank" rel="noopener noreferrer">Try it for free</a><p>.</p></div>
</div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
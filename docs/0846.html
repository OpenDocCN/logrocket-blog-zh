<html>
<head>
<title>React-cool-portal: What it is and how to use it - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>React-cool-portal:它是什么以及如何使用它</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/react-cool-portal-what-it-is-and-how-to-use-it/#0001-01-01">https://blog.logrocket.com/react-cool-portal-what-it-is-and-how-to-use-it/#0001-01-01</a></blockquote><div><article class="article-post">
<p>如果您熟悉React，您很可能已经意识到React在单个<code>div</code>标签下呈现所有HTML元素，通常给出一个ID<code>root</code>。</p>
<pre>ReactDOM.render(
  &lt;React.StrictMode&gt;
    &lt;App /&gt;
  &lt;/React.StrictMode&gt;,
  document.getElementById('root')
);</pre>
<p>如果您试图在根元素之外呈现另一个元素，比如模态元素或工具提示元素，这将是一个恼人的限制。为了解决这个问题，引入了React门户。</p>
<h2>React门户简介</h2>
<p>在React 16.0版本中，引入了门户来解决无法呈现根节点之外的其他元素的问题。</p>
<p>以下是React文档中关于如何利用React门户的一个示例:</p>
<pre>const appRoot = document.getElementById('app-root');
const modalRoot = document.getElementById('modal-root');

class Modal extends React.Component {
  constructor(props) {
    super(props);
    this.el = document.createElement('div');
  }
  componentDidMount() {
    modalRoot.appendChild(this.el);
  }
  componentWillUnmount() {
    modalRoot.removeChild(this.el);
  }

  render() {
    return ReactDOM.createPortal(
      this.props.children,
      this.el
    );
  }
}

class Parent extends React.Component {
  constructor(props) {
    super(props);
    this.state = {clicks: 0};
    this.handleClick = this.handleClick.bind(this);
  }

  handleClick() {
    // This will fire when the button in Child is clicked,
    // updating Parent's state, even though button
    // is not direct descendant in the DOM.
    this.setState(state =&gt; ({
      clicks: state.clicks + 1
    }));
  }

  render() {
    return (
      &lt;div onClick={this.handleClick}&gt;
        &lt;p&gt;Number of clicks: {this.state.clicks}&lt;/p&gt;
        &lt;p&gt;
          Open up the browser DevTools
          to observe that the button
          is not a child of the div
          with the onClick handler.
        &lt;/p&gt;
        &lt;Modal&gt;
          &lt;Child /&gt;
        &lt;/Modal&gt;
      &lt;/div&gt;
    );
  }
}

function Child() {
  // The click event on this button will bubble up to parent,
  // because there is no 'onClick' attribute defined
  return (
    &lt;div className="modal"&gt;
      &lt;button&gt;Click&lt;/button&gt;
    &lt;/div&gt;
  );
}

ReactDOM.render(&lt;Parent /&gt;, appRoot);</pre>
<p>正如您所看到的，代码有点冗长，如果缩短它的长度，会更容易阅读和理解。快进到React版本16.8中钩子的引入。</p>
<p>钩子允许开发人员在不改变组件层次结构的情况下重用有状态逻辑。它们改变了React开发人员编写代码和编写状态的方式。事实上，许多React库，比如react-redux和react-router，正在或者已经转向一个更加基于钩子的API。</p>
<p>许多新的基于钩子的库也正在发布，为某些服务或代码提供一些抽象。一个这样的库是react-cool-portal。在本文中，我们将探索react-cool-portal，最后，我们将构建一个动画模型。我们开始吧！</p>
<h2>什么是react-cool-portal？</h2>
<p>正如我前面提到的，react-cool-portal是react门户上基于钩子的抽象。使用react-cool-portal，创建门户非常简单:</p>
<pre>const {Portal} = usePortal();</pre>
<p>钩子还带有各种方法和事件监听器，允许您执行更灵活的操作。以下是react-cool-portal的一些特性:</p>
<ul>
<li>您可以将元素/组件呈现给<code>&lt;body&gt;</code>中的默认元素或指定的DOM元素</li>
<li>react-cool-portal带有各种状态控制器和事件监听器，允许您更灵活地处理门户</li>
<li>它可以作为一个包装器来构建您的定制钩子</li>
<li>它会自动删除未使用的门户容器，从而防止DOM混乱</li>
<li>它支持TypeScript类型定义</li>
<li>它具有服务器端呈现兼容性</li>
<li>它的尺寸很小(<a href="https://bundlephobia.com/result?p=react-cool-portal"> ~ 1.4KB gzipped </a>)，除了<code>react</code>和<code>react-dom</code>之外，没有任何外部依赖</li>
</ul>
<p>在本文中，我们将探索react-cool-portal，最后，我们将构建一个动画模型。我们开始吧！</p>
<h3>探索反应-冷却-门户</h3>
<p>正如我前面提到的，您可以用<code>usePortal</code>钩子创建一个门户。<code>usePortal</code>返回一个包含<code>Portal</code>组件和一些函数的对象:</p>
<pre>const {Portal, show, hide, isShow, toggle} = usePortal();</pre>
<p><code>show</code>函数用于显示门户(挂载它),而<code>hide</code>用于隐藏门户(卸载它)。<code>isShow</code>是一个布尔值，当门户被安装时返回<code>true</code>，否则返回<code>false</code>。<code>toggle</code>是根据门户的当前状态显示或隐藏门户的功能。</p>
<p>我们可以向我们的<code>usePortal</code>钩子提供一个对象形式的参数，用于进一步的配置，如下所示:</p>
<pre>const {Portal} = usePortal({
  defaultShow: false,
  internalShowHide: true,
  onShow : e =&gt; {
  },
  onHide: e =&gt; {
  },
  containerId: "portal",
  clickOutsideToHide: true,
  escToHide: true
});</pre>
<p>使用<code>defaultShow</code>，我们可以选择默认显示或隐藏门户内容。<code>internalShowHide</code>启用/禁用我们门户的显示/隐藏功能，以便我们可以随心所欲地处理门户。</p>
<p><code>onShow</code>和<code>onHide</code>分别是当<code>isShow</code>设置为<code>true</code>或<code>isShow</code>设置为<code>false</code>时触发的事件处理程序。<code>containerId</code>，默认值为<code>react-cool-portal</code>，用于设置门户的ID。</p>
<p><code>clickOutsideToHide</code>定义我们是否想要通过点击门户外部来隐藏门户，而<code>escToHide</code>定义我们是否想要通过点击<code>esc</code>键来隐藏门户。</p>
<p>这基本上就是开始使用react-cool-portal所需要知道的全部内容！现在，我们将利用目前所学的知识建立一个动画模型。</p>
<h2>构建动画模型</h2>
<p>与任何React项目一样，您必须在开始工作之前创建一个新项目。为此，您可以轻松使用create-react-app:</p>
<pre>npx create-react-app animated-modal</pre>
<p>一旦你创建了一个新项目，你需要安装react-cool-portal，就像这样:</p>
<pre>npm install --save react-cool-portal</pre>
<p>由于这是一个非常小的项目，我将在一个文件<code>App.js</code>中编写我所有的JavaScript/JSX，在另一个文件<code>App.css</code>中编写我所有的CSS。</p>
<p>在我们继续之前，让我们想象一下我们想要创建什么。我们希望有一个按钮，当点击时，将显示一个动画模式。然后我们可以从模态本身退出模态。</p>
<p>也就是说，我们需要创建一个状态，根据按钮是否被点击来呈现<code>Portal</code>组件:</p>
<pre>const [showModal, setShowModal] = useState(false);</pre>
<p>我们还需要另一个状态来存储动画状态(将触发动画的不同CSS类):</p>
<pre>const [animationState, setAnimationState] = useState("");</pre>
<p>我们目前应该有这个:</p>
<pre>const { Portal, show, hide } = usePortal({
    defaultShow: false,
  });
  const [showModal, setShowModal] = useState(false);
  const [animationState, setAnimationState] = useState("");</pre>
<p>现在让我们创建一个简单的按钮元素，当它被点击时会将<code>showModal</code>设置为<code>true</code>，并调用<code>show</code>函数。</p>
<pre>return (
    &lt;div&gt;
      &lt;button
        onClick={() =&gt; {
          setShowModal(true);
          show();
        }}
      &gt;
        Open Modal
      &lt;/button&gt;    
    &lt;/div&gt;
  );</pre>
<p>现在让我们编写模态标记:</p>
<pre>return (
    &lt;div&gt;
      &lt;button
        onClick={() =&gt; {
          setShowModal(true);
          show();         
        }}
      &gt;
        Open Modal
      &lt;/button&gt;
      {showModal &amp;&amp; (
        &lt;Portal&gt;
          &lt;div className= "modal" tabIndex={-1}&gt;
            &lt;div
              className={`modal-dialog ${animationState}`}
              role="dialog"
              aria-labelledby="modal-label"
              aria-modal="true"
            &gt;
              &lt;div className="modal-header"&gt;
                &lt;h5 id="modal-label"&gt;Modal header&lt;/h5&gt;
                &lt;span
                  className="modal-exit"
                &gt;
                  close
                &lt;/span&gt;
              &lt;/div&gt;
              &lt;div className="modal-body"&gt;
                &lt;p&gt;Modal Body&lt;/p&gt;
              &lt;/div&gt;
            &lt;/div&gt;
          &lt;/div&gt;
        &lt;/Portal&gt;
      )}
    &lt;/div&gt;
  );</pre>
<p>在我们的CSS中，我们将有两个不同的动画:<code>slideIn</code>和<code>slideOut</code>。当点击按钮打开模态时，动画状态变为<code>slideIn</code>，并且<code>slideIn</code>类被附加到模态对话框<code>div</code>。</p>
<p>为此，我们将使用<code>onShow</code>事件处理程序将当前动画状态设置为<code>slideIn</code>。所以每当模态被显示时，<code>slideIn</code>类将被附加到它上面。</p>
<pre>const { Portal, show, hide } = usePortal({
    defaultShow: false,
    onShow: () =&gt; {
      setAnimationState("slideIn");
    },
  });</pre>
<p>我们的modal有一个<code>&lt;span&gt;</code>元素，它将用于在单击时关闭modal。当这个<code>&lt;span&gt;</code>元素被点击时，我们将动画状态设置为<code>slideOut</code>。</p><div class="code-block code-block-54">
<hr/>
<h3>更多来自LogRocket的精彩文章:</h3>

<hr/></div>
<pre>&lt;span
  className="modal-exit"
  onClick={() =&gt; {
    setAnimationState("slideOut");
  }}
&gt;
 close
&lt;/span&gt;</pre>
<p>我们现在将利用React提供的动画事件之一:<code>onAnimationEnd</code>。传递给它的事件处理程序将在动画结束后运行。</p>
<p>在我们的例子中，一旦模态对话框上的动画结束，我们将检查当前的动画状态。如果是<code>slideOut</code>，我们就隐藏模态。一旦完成，我们将设置动画状态为空字符串。</p>
<pre> &lt;div
  className={`modal-dialog ${animationState}`}
   role="dialog"
   aria-labelledby="modal-label"
   aria-modal="true"
    onAnimationEnd={() =&gt; {
       if(animationState == "slideOut"){
          hide();
        }
        setAnimationState("");
    }}
&gt;</pre>
<p>我们的<code>App</code>组件现在应该是这样的:</p>
<pre>import React, { useState } from "react";
import "./App.css";
import usePortal from "react-cool-portal";

function App() {
  const { Portal, show, hide } = usePortal({
    defaultShow: false,
    onShow: () =&gt; {
      setAnimationState("slideIn");
    },
  });
  const [showModal, setShowModal] = useState(false);
  const [animationState, setAnimationState] = useState("");
  return (
    &lt;div&gt;
      &lt;button
        onClick={() =&gt; {
          setShowModal(true);
          show(); 
        }}
      &gt;
        Open Modal
      &lt;/button&gt;
      {showModal &amp;&amp; (
        &lt;Portal&gt;
          &lt;div className= "modal" tabIndex={-1}&gt;
            &lt;div
              className={`modal-dialog ${animationState}`}
              role="dialog"
              aria-labelledby="modal-label"
              aria-modal="true"
              onAnimationEnd={() =&gt; {
                if(animationState == "slideOut"){
                  hide();
                }
                setAnimationState("");
              }}
            &gt;
              &lt;div className="modal-header"&gt;
                &lt;h5 id="modal-label"&gt;Modal header&lt;/h5&gt;
                &lt;span
                  className="modal-exit"
                  onClick={() =&gt; {
                    setAnimationState("slideOut");
                  }}
                &gt;
                  close
                &lt;/span&gt;
              &lt;/div&gt;
              &lt;div className="modal-body"&gt;
                &lt;p&gt;Modal Body&lt;/p&gt;
              &lt;/div&gt;
            &lt;/div&gt;
          &lt;/div&gt;
        &lt;/Portal&gt;
      )}
    &lt;/div&gt;
  );
}</pre>
<p>这就是JavaScript的全部内容——让我们继续讨论CSS。这是模态的CSS:</p>
<pre>body{
  --curve: cubic-bezier(0.22, 1, 0.36, 1);
}
#react-cool-portal{
  position: absolute;
  top:0;
  left: 0;
  min-width: 100vw;
  height: 100%;
}
.modal{
  height: 100%;
  width: 100%;
  display: flex;
  z-index: 20;
  justify-content: center;
  align-items: center;
  background-color: rgba(0,0,0,0.7);
}
.modal-dialog{
  background-color: white;
  border-radius: 10px;
  width: 80%;
  max-width: 400px;
  padding: 1rem;

}
.modal-header{
  font-weight: 400;
  font-size: 1.5rem;
  display: flex;
  justify-content: space-between;
}
.modal-header #modal-label{
  margin:0;
}
.modal-exit{
  font-size: 1rem;
  color: red;
  cursor: pointer;
}
.slideIn{
  animation: slideIn 0.5s var(--curve) 0s 1 normal none;
}
.slideOut{
  animation: slideOut 0.5s var(--curve) 0s 1 normal forwards;
}
@keyframes slideIn {
  0% {
    transform: translateY(-2rem);
    opacity: 0;
  }

  100% {
    transform: translateY(0);
    opacity: 1;
  }
}
@keyframes slideOut {
  100% {
    transform: translateY(-2rem);
    opacity: 0;
  }
  0% {
    transform: translateY(0);
    opacity: 1;
  }
}</pre>
<p>你现在应该有一个很好的动画模型了！</p>
<h2>结论</h2>
<p>就这样，我们结束了！您可以基于react-cool-portal创建一个名为<code>useModal</code>的定制钩子，以实现代码重用。</p>
<p>这个项目回购的链接可以在<a href="https://github.com/NodeJSs/react-cool-portal-article">这里</a>找到。你可以在这里找到现场演示<a href="https://react-cool-portal-article.netlify.app/"/>。最后，你可以在这里了解更多关于react-cool-portal <a href="https://github.com/wellyshen/react-cool-portal">的信息。</a></p><div class="code-block code-block-17">
<div class="blog-plug inline-plug react-plug" vwo-el-id="26283398190">
<h2 vwo-el-id="41600691720"><a href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener"> LogRocket </a>:全面了解您的生产React应用</h2><p>调试React应用程序可能很困难，尤其是当用户遇到难以重现的问题时。如果您对监视和跟踪Redux状态、自动显示JavaScript错误以及跟踪缓慢的网络请求和组件加载时间感兴趣，</p><a href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" vwo-el-id="19356441070">try LogRocket</a><p>. </p><a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="19356441380">
<img class="first-react-image alignnone size-full wp-image-46 jetpack-lazy-image jetpack-lazy-image--handled" src="../Images/f300c244a1a1cf916df8b4cb02bec6c6.png" vwo-el-id="18272717540" data-lazy-loaded="1" data-original-src="https://files.readme.io/27c94e7-Image_2017-06-05_at_9.46.04_PM.png"/>
</a>
<a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="19356441690">
<img class="second-react-image alignnone size-full wp-image-46 jetpack-lazy-image jetpack-lazy-image--handled" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" vwo-el-id="30720362350" data-lazy-loaded="1" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/>
</a>
<p vwo-el-id="28675660440" class="">LogRocket 结合了会话回放、产品分析和错误跟踪，使软件团队能够创建理想的web和移动产品体验。这对你来说意味着什么？</p>
<p>LogRocket不是猜测错误发生的原因，也不是要求用户提供截图和日志转储，而是让您回放问题，就像它们发生在您自己的浏览器中一样，以快速了解哪里出错了。</p>
<p>不再有嘈杂的警报。智能错误跟踪允许您对问题进行分类，然后从中学习。获得有影响的用户问题的通知，而不是误报。警报越少，有用的信号越多。</p>
<p vwo-el-id="28675660750">LogRocket Redux中间件包为您的用户会话增加了一层额外的可见性。LogRocket记录Redux存储中的所有操作和状态。</p>
<p vwo-el-id="28675661060">现代化您调试React应用的方式— <a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="40093418840">开始免费监控</a>。</p>
</div></div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
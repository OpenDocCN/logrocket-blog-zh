<html>
<head>
<title>Why you should use package-lock.json - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>为什么应该使用package-lock . JSON-log rocket Blog</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/why-you-should-use-package-lock-json/#0001-01-01">https://blog.logrocket.com/why-you-should-use-package-lock-json/#0001-01-01</a></blockquote><div><article class="article-post">
<p>在本文中，我们将了解<code>package-lock.json</code>，为什么它如此重要，以及如何在您的日常生活中最好地与NPM CLI配合使用。</p>
<h2>历史</h2>
<p>NPM版本5引入了<code>package-lock.json</code>作为一种机制来捕获在任何时间点安装的精确依赖树。</p>
<p>这有助于跨不同环境的协作，在这种环境中，您希望每个人为项目的特定版本获取依赖项，以获取相同的树。</p>
<p><code>package.json</code>使用<a href="https://semver.org/" target="_blank" rel="noopener noreferrer">语义版本化</a>定义所需的依赖关系及其各自的版本。然而，语义版本控制可能很棘手。</p>
<p>考虑一个被称为<code>"express": "^4.16.4"</code>的依赖关系。</p>
<p>这个模块的发行者(没有使用<code>package-lock.json</code>)会安装<code>express</code>版本4.16.4，因为他们安装了最新版本。</p>
<p>如果在我下载这个模块并试图在其上安装依赖项时，<code>express</code>已经发布了一个新版本，我可以下载最新版本。</p>
<p><code>caret</code>符号<a href="https://stackoverflow.com/a/22345808/1955940" target="_blank" rel="noopener noreferrer">确切地告诉我们</a>。</p>
<p>上面的问题是，如果版本4.17.x包含一个bug，我的本地安装将失败，但发行商的将继续在以前的版本上正常工作。</p>
<p>同样的事情可能发生在生产环境中，而您不知道它为什么会失败。</p>
<p>在NPM版本5之前，您将使用<code>shrinkwrap</code>。它与<code>package-lock.json</code>不同，因为它允许在NPM注册中心与你的模块一起发布，而<code>package-lock.json</code>则不允许。</p>
<p>如果所有成员都可以使用NPM+5，那么对于未发布的项目，最好使用<code>package-lock.json</code>。</p>
<p>但是，如果您正在开发一个模块并打算发布它，您可能需要考虑是否希望客户端安装您指定的确切的依赖树，或者是否希望在这方面更加灵活。这里有一个关于这个主题的更详细的版本。</p>
<p>因此，<code>package-lock.json</code>将描述当前安装的确切依赖树。格式在<a href="https://docs.npmjs.com/files/package-lock.json#dependencies-1" target="_blank" rel="noopener noreferrer"> NPM文档pag </a> e中描述</p>
<p>通过将它提交到您的VCS——这是您绝对应该做的——您可以回到历史中，从那时开始复制精确的依赖树。</p>
<p>确保总是将<code>package-lock.json</code>提交给你的VCS，以便在任何给定的时间跟踪精确的依赖树。</p>
<p>这将确保下载您的项目并尝试安装依赖项的所有客户端都将获得完全相同的依赖树。此外，它将确保您能够检查以前的提交并复制每个提交的依赖状态。</p>
<h2><code>package.json</code>对<code>package-lock.json</code></h2>
<p>确保不要直接改<code>package-lock.json</code>。这是由NPM自动处理的。它反映了对<code>package.json</code>到<code>package-lock.json</code>的更改，并使其保持最新。</p>
<p>但是，这只有在您使用NPMs的CLI进行更改时才会发生。如果手动更改<code>package.json</code>，就不要指望<code>package-lock.json</code>会更新。始终使用CLI命令，如<code>install</code>、<code>uninstall</code>等。</p>
<h2>如何使用NPM命令行界面</h2>
<p>当你第一次在一个新项目中使用它时，NPM会自动生成一个<code>package-lock.json</code>。</p>
<p>然后，你可以像平常一样使用NPM。</p>
<h3>npm安装(使用特定模块作为参数)</h3>
<p><code>install</code>可以与要安装的模块的名称一起用作参数，这将改变<code>package.json</code>和<code>package-lock.json</code>，因为依赖关系树将会改变。</p><div class="code-block code-block-54">
<hr/>
<h3>更多来自LogRocket的精彩文章:</h3>

<hr/></div>
<p>考虑下面的例子:</p>
<pre>npm install express body-parser cors</pre>
<h3>npm安装(无参数)</h3>
<p><code>install</code>将尝试安装与<code>package-lock.json</code>相关的所有依赖项。</p>
<p>这里的一个关键点是，<code>install</code>可以改变<code>package-lock.json</code>,如果它注册它是过时的。</p>
<p>例如，如果有人手动更改<code>package.json</code>——比方说，他们删除了一个包，因为这只是删除一行——下次有人运行<code>npm install</code>时，它将更改<code>package-lock.json</code>以反映前一个包的删除。</p>
<p>这可能很棘手。想象一下，提取项目的最新版本，运行<code>npm install</code>来更新，却发现你的树中立即有一堆毫无意义的变更。</p>
<p>也很有可能你的树中的变化对审查你的变化的人没有意义。</p>
<h3>npm卸载</h3>
<p>类似于<code>install</code>,但是要移除的模块名称作为参数。这将改变<code>package.json</code>和<code>package-lock.json</code>。</p>
<h3>npm更新</h3>
<p><code>update</code>将读取<code>package.json</code>以找到任何可以更新的依赖项。随后，它将构建一个新的依赖树并更新<code>package-lock.json</code>。</p>
<p>还记得语义版本吗？假设我们的<code>package.json</code>中有一个依赖项，表示为<code>^1.4.5</code>。</p>
<p><code>^</code>字符告诉NPM检查在<code>1.X.X</code>作用域下是否有更新的版本，如果有，就安装它。同样的，<code>~</code>角色只会升级到热补丁，或<code>1.4.X</code>。</p>
<p>您也可以省略特殊字符，保留一个固定的版本，这使得<code>package-lock.json</code>不那么有用(但不是没有用)。</p>
<h3>npm ci</h3>
<p><code>ci</code>将安装与<code>package-lock.json</code>相关的所有依赖项，类似于<code>install</code>。这里的关键区别在于，它在任何情况下都不会改变<code>package-lock.json</code>。</p>
<p>其目的是供环境使用，例如构建服务器，其中安装以自动方式进行。</p>
<h2>结论</h2>
<p>使用<code>package-lock.json</code>时，请记住以下要点:</p>
<p>不要使用不带参数的<code>npm install</code>来获取依赖关系——为此使用<code>npm ci</code>。您可以使用<code>npm install</code>来安装特定的依赖项。</p>
<p>当您只想使用本地依赖关系树时，可以在任何地方使用<code>npm ci</code>——甚至在您的本地开发环境中。</p>
<p>做一个重复的任务，比如一个月一次，来更新你的依赖。(或者，您可以使用类似于<a href="https://dependabot.com/" target="_blank" rel="noopener noreferrer">dependent bot</a>的服务，但要确保您有良好的测试覆盖率)。</p>
<p>这样，您可以确保您的依赖项是最新的，并避免产生技术债务。</p>
<h2>更多参考</h2>

<p>插头</p><div class="code-block code-block-2">
<div class="blog-plug base-cta"><h2>使用<a class="signup" href="https://lp.logrocket.com/blg/signup" target="_blank" rel="noopener noreferrer"> LogRocket </a>消除传统错误报告的干扰</h2>
<a href="https://lp.logrocket.com/blg/signup" class="signup" target="_blank" rel="noopener noreferrer"><img class="alignnone size-full wp-image-46 jetpack-lazy-image" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/><noscript><img data-lazy-fallback="1" class="alignnone size-full wp-image-46" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/></noscript></a>
<p><a href="https://lp.logrocket.com/blg/signup" target="_blank" rel="noopener noreferrer"> LogRocket </a>是一个数字体验分析解决方案，它可以保护您免受数百个假阳性错误警报的影响，只针对几个真正重要的项目。LogRocket会告诉您应用程序中实际影响用户的最具影响力的bug和UX问题。</p>
<p>然后，使用具有深层技术遥测的会话重放来确切地查看用户看到了什么以及是什么导致了问题，就像你在他们身后看一样。</p>
<p>LogRocket自动聚合客户端错误、JS异常、前端性能指标和用户交互。然后LogRocket使用机器学习来告诉你哪些问题正在影响大多数用户，并提供你需要修复它的上下文。</p>
<p>关注重要的bug—<a class="signup" href="https://lp.logrocket.com/blg/signup-issue-free" target="_blank" rel="noopener noreferrer">今天就试试LogRocket】。</a></p></div></div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
<html>
<head>
<title>JavaScript package managers compared: npm, Yarn, or pnpm? - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>JavaScript包管理器比较:npm，Yarn，还是pnpm？- LogRocket博客</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/javascript-package-managers-compared/#0001-01-01">https://blog.logrocket.com/javascript-package-managers-compared/#0001-01-01</a></blockquote><div><article class="article-post">
<p><strong> <em>编者按</em> </strong> <em>:这篇文章于2022年2月16日完全重写，以重新评估包管理器的前景，参考和比较新的工具和工作区，讨论Corepack的功能和性能影响，提供流行的开源项目中包管理器使用的鸟瞰图，并更彻底地解释包管理器自2010年以来的演变。</em></p>
<p>如今，包管理器领域有三个主要参与者:</p>
<ol>
<li><a href="https://docs.npmjs.com/" target="_blank" rel="noopener"> npm </a></li>
<li><a href="https://yarnpkg.com/" target="_blank" rel="noopener">纱</a>——我们很快就会看到，纱既可以指<a href="https://classic.yarnpkg.com/" target="_blank" rel="noopener">纱经典</a> ( &lt; v2)，也可以指它更现代的版本<a href="https://yarnpkg.com/" target="_blank" rel="noopener">纱莓</a> (≥ v2)</li>
<li><a href="https://pnpm.io/" target="_blank" rel="noopener">表演npm (pnpm) </a></li>
</ol>
<p>实际上，我们已经在所有的包管理器中实现了功能对等，所以您很可能会根据非功能性需求来决定使用哪个包管理器，比如安装速度、存储消耗，或者它如何与您现有的工作流相匹配。</p>
<p>当然，您选择使用每个包管理器的方式会有所不同，但是它们都有一组共同的主要概念。您可以使用这些软件包管理器执行以下操作:</p>
<ul>
<li>处理和写入元数据</li>
<li>批量安装或更新所有依赖项</li>
<li>添加、更新和删除相关性</li>
<li>运行脚本</li>
<li>发布包</li>
<li>执行安全审计</li>
</ul>
<p>尽管有这种平等，但是，包管理器在引擎盖下是不同的。传统上，npm和Yarn将依赖项安装在一个平面的<a href="https://docs.npmjs.com/cli/v8/configuring-npm/folders#node-modules" target="_blank" rel="noopener"> <code>node_modules</code>文件夹</a>中。但是这种依赖性解决策略并不是没有批评。</p>
<p>因此，pnpm引入了一些新概念，以便在嵌套的<code>node_modules</code>文件夹中更有效地存储依赖关系。Yarn Berry甚至更进一步，完全抛弃了<code>node_modules</code>的即插即用(PnP)模式。</p>
<p>在本文中，我们将讨论以下内容，并在适用的情况下比较实现选项:</p>

<p>随意跳过和阅读与你最相关的内容。</p>
<h3>如何使用配套项目</h3>
<p>我已经创建了一个<a href="https://github.com/doppelmutzi/companion-project-package-managers-2022" target="_blank" rel="noopener">配套的React应用程序</a>来演示一些不同的包管理器的独特概念。每个包管理器变体都有一个对应的Git分支。这是我也用来创建本帖下面部分的性能表的项目。</p>
<p>虽然应用程序的类型对于本文的主题并不重要，但我选择了一个中等规模且现实的项目来说明不同的方面；作为最近的一个例子，Yarn Berry的PnP机制引起了一些关于兼容性问题的热烈讨论，这个项目适合帮助检查。</p>
<h2 id="brief-history-javascript-package-managers">JavaScript包管理器简史</h2>
<p>第一个软件包管理器是在2010年1月发布的npm。它建立了当今包管理器工作的核心原则。</p>
<p>如果npm已经存在超过10年了，为什么还有其他选择呢？以下是出现这种情况的一些主要原因:</p>
<ul>
<li>具有不同<code>node_modules</code>文件夹结构的不同依赖关系解析算法(嵌套与平面、<code>node_modules</code>与PnP模式)</li>
<li><a href="https://yarnpkg.com/advanced/lexicon#hoisting" target="_blank" rel="noopener">吊装</a>的支撑不同，存在安全隐患</li>
<li>不同的锁文件格式，每种格式都有性能影响</li>
<li>在磁盘上存储包的不同方法，这对磁盘空间效率有影响</li>
<li>对多包项目(也称为工作区)的不同支持，这会影响大型monorepos的可维护性和速度</li>
<li>对新工具和命令的不同需求，每一个都有DX含义<ul>
<li>相关地，通过插件和社区工具对可扩展性的不同需求</li>
</ul>
</li>
<li>不同程度的可配置性和灵活性</li>
</ul>
<p>让我们深入了解一下npm崛起后这些需求是如何确定的，Yarn Classic是如何解决其中一些需求的，pnpm是如何扩展这些概念的，以及Yarn Berry作为Yarn Classic的继任者是如何试图打破这些传统概念和流程设定的模式的。</p>
<h3>npm，先锋</h3>
<p>npm是包管理器的前身。许多人错误地认为npm是“节点包管理器”的缩写，但是<a href="https://github.com/npm/cli#is-npm-an-acronym-for-node-package-manager" target="_blank" rel="noopener">事实并非如此</a>。然而，它是与Node.js运行时捆绑在一起的。</p>
<p>它的发布构成了一场革命，因为在那之前，项目依赖关系都是手工下载和管理的。npm引入了一些概念，如带有元数据字段(例如，<code>devDependencies</code>)的<code>package.json</code>文件、在<code>node_modules</code>中存储依赖关系、定制脚本、公共和私有包注册表等等。</p>
<p>2020年，<a href="https://github.blog/2020-03-16-npm-is-joining-github/" target="_blank" rel="noopener"> GitHub收购了npm </a>，所以原则上npm现在归微软管理。在撰写本文时，<a href="https://github.blog/changelog/2021-10-07-npm-cli-upgraded-to-version-8/" target="_blank" rel="noopener">的最新主要版本是v8 </a>，发布于2021年10月。</p>
<h3>Yarn (v1 / Classic ),引领了许多创新</h3>
<p>在2016年10月的一篇博客文章中，脸书宣布与谷歌和其他几家公司合作开发一种新的包管理器，可以解决npm当时存在的一致性、安全性和性能问题。他们将另一种选择命名为<a href="https://classic.yarnpkg.com/lang/en/" target="_blank" rel="noopener">纱</a>，代表另一种资源谈判者。</p>
<p>尽管Yarn的架构设计基于npm建立的许多概念和过程，但Yarn在其最初版本中对包管理器的前景产生了重大影响。与npm相反，Yarn并行化操作以加快安装过程，这是npm早期版本的一个主要难点。</p>
<p>Yarn为DX、安全性和性能设立了更高的标准，还发明了许多概念，包括:</p>
<ul>
<li>本机monorepo支持</li>
<li>缓存感知安装</li>
<li>离线缓存</li>
<li>锁定文件</li>
</ul>
<p>2020年纱线v1 <a href="https://classic.yarnpkg.com/en/docs/install#mac-stable" target="_blank" rel="noopener">进入维护模式</a> <a href="https://classic.yarnpkg.com/en/docs/install#mac-stable" target="_blank" rel="noopener">。从那以后，v1.x系列被认为是传统产品，并被更名为Yarn Classic。它的继任者，纱v2或贝里，现在是积极发展的分支。</a></p>
<h3>pnpm，速度快，磁盘效率高</h3>
<p>第一版<a href="https://pnpm.io/" target="_blank" rel="noopener"> pnpm </a>由Zoltan·科昌于2017年发布。它是npm的嵌入式替代品，所以如果您有一个npm项目，您可以马上使用pnpm！</p>
<p>pnpm的创建者对npm和Yarn有的主要问题是跨项目使用的依赖关系的冗余存储。尽管Yarn Classic比npm有速度优势，但它使用了相同的依赖关系解析方法，这对于pnpm的创建者来说是不可行的:npm和Yarn Classic使用提升来展平它们的<code>node_modules</code>。</p>
<p>pnpm没有提升，而是引入了另一种依赖性解决策略:<a href="https://pnpm.io/next/symlinked-node-modules-structure" target="_blank" rel="noopener">内容寻址存储</a>。这个方法产生一个嵌套的<code>node_modules</code>文件夹，它将包存储在您的主文件夹(<code>~/.pnpm-store/</code>)的全局存储中。一个依赖项的每个版本在那个文件夹中物理上只存储一次，构成了一个真实的单一来源，节省了相当多的磁盘空间。</p>
<p>这是通过一个<code>node_modules</code>布局实现的，使用符号链接创建一个依赖关系的嵌套结构，其中文件夹中每个包的每个文件都是一个到商店的<a href="https://pnpm.io/faq#why-does-my-node_modules-folder-use-disk-space-if-packages-are-stored-in-a-global-store" target="_blank" rel="noopener">硬链接</a>。官方文档中的下图阐明了这一点。</p>
<figure id="attachment_92984" aria-describedby="caption-attachment-92984" class="wp-caption aligncenter"><img data-attachment-id="92984" data-permalink="https://blog.logrocket.com/javascript-package-managers-compared/pnpm-node-modules-layout/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/11/pnpm-node-modules-layout.png" data-orig-size="730,348" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="pnpm-node-modules-layout" data-image-description="" data-image-caption="&lt;p&gt;Source: &lt;a href=&quot;https://pnpm.io/motivation#creating-a-non-flat-node_modules-directory&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;pnpm&lt;/a&gt;&lt;/p&gt;&#10;" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/11/pnpm-node-modules-layout-300x143.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/11/pnpm-node-modules-layout.png" decoding="async" class="size-full wp-image-92984 jetpack-lazy-image" src="../Images/5778c621fac759eb256962ae3f2502c3.png" alt="pnpm's node_modules layout" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2020/11/pnpm-node-modules-layout.png 730w, https://blog.logrocket.com/wp-content/uploads/2020/11/pnpm-node-modules-layout-300x143.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2020/11/pnpm-node-modules-layout.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/11/pnpm-node-modules-layout.png"/><noscript><img data-lazy-fallback="1" data-attachment-id="92984" data-permalink="https://blog.logrocket.com/javascript-package-managers-compared/pnpm-node-modules-layout/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/11/pnpm-node-modules-layout.png" data-orig-size="730,348" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="pnpm-node-modules-layout" data-image-description="" data-image-caption="&lt;p&gt;Source: &lt;a href=&quot;https://pnpm.io/motivation#creating-a-non-flat-node_modules-directory&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;pnpm&lt;/a&gt;&lt;/p&gt;&#10;" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/11/pnpm-node-modules-layout-300x143.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/11/pnpm-node-modules-layout.png" decoding="async" loading="lazy" class="size-full wp-image-92984" src="../Images/5778c621fac759eb256962ae3f2502c3.png" alt="pnpm's node_modules layout" srcset="https://blog.logrocket.com/wp-content/uploads/2020/11/pnpm-node-modules-layout.png 730w, https://blog.logrocket.com/wp-content/uploads/2020/11/pnpm-node-modules-layout-300x143.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/11/pnpm-node-modules-layout.png"/></noscript><figcaption id="caption-attachment-92984" class="wp-caption-text">Source: <a href="https://pnpm.io/motivation#creating-a-non-flat-node_modules-directory" target="_blank" rel="noopener">pnpm</a></figcaption></figure>
<p>pnpm的影响可以在他们的<a href="https://pnpm.io/blog/2021/12/29/yearly-update" target="_blank" rel="noopener"> 2021报告</a>中看到:竞争对手希望采用pnpm的安装概念，如<a href="https://pnpm.io/blog/2021/12/29/yearly-update#npm" target="_blank" rel="noopener">符号链接<code>node_modules</code>结构</a>和包的磁盘高效管理，因为他们在<a href="https://pnpm.io/blog/2021/12/29/yearly-update#yarn" target="_blank" rel="noopener">内容寻址存储</a>方面有所创新。</p>
<h3>Yarn (v2，Berry)，用即插即用重新发明轮子</h3>
<p>《Yarn 2》于2020年1月发布，被宣传为对原版《Yarn》的重大升级。Yarn团队开始称它为Yarn Berry，以便更清楚地表明它本质上是一个新的包管理器，具有新的代码库和新的原则。</p>
<p>Yarn Berry的主要创新是它的<a href="https://yarnpkg.com/features/pnp/" target="_blank" rel="noopener">即插即用(PnP) </a>方法，这是一种修复<code>node_modules</code> 的<a href="https://yarnpkg.com/features/pnp/#fixing-node_modules" target="_blank" rel="noopener">策略。不是生成<code>node_modules</code>，而是生成一个带有依赖关系查找表的<code>.pnp.cjs</code>文件，它可以被更有效地处理，因为它是一个单独的文件，而不是一个嵌套的文件夹结构。此外，每个包都作为一个</a><a href="https://yarnpkg.com/features/pnp/#packages-are-stored-inside-zip-archives-how-can-i-access-their-files" target="_blank" rel="noopener"> zip文件</a>存储在<code>.yarn/cache/</code>文件夹中，比<code>node_modules</code>文件夹占用更少的磁盘空间。</p>
<p>所有这些变化，而且如此之快，在发布后引发了大量争议。PnP的突破性变化<a href="https://blog.hao.dev/state-of-yarn-2-berry-in-2021" target="_blank" rel="noopener">要求维护者更新他们现有的包</a>以便与之兼容。默认情况下使用全新的PnP方法，恢复到<code>node_modules</code>最初并不简单，这导致许多著名的开发者<a href="https://www.youtube.com/watch?v=bPae4Z8BFt8" target="_blank" rel="noopener">公开批评Yarn 2 </a>没有选择加入。</p>
<p>自《T2》之后，Yarn Berry团队在随后的版本中解决了许多问题。为了解决PnP的不兼容性，该团队提供了一些方法来轻松地更改默认的操作模式。在一个<a href="https://github.com/yarnpkg/berry/tree/master/packages/plugin-nm" target="_blank" rel="noopener"> <code>node_modules</code>插件</a>的帮助下，使用传统的<code>node_modules</code>方法只需要一行配置。</p>
<p>此外，随着时间的推移，JavaScript生态系统已经为PnP提供了越来越多的支持，正如你在这个<a href="https://yarnpkg.com/features/pnp/#compatibility-table" target="_blank" rel="noopener">兼容性表</a>中看到的，一些<a href="https://github.com/babel/babel" target="_blank" rel="noopener">大</a> <a href="https://github.com/facebook/jest" target="_blank" rel="noopener">项目</a>已经开始采用Yarn Berry。在我的<a href="https://github.com/doppelmutzi/companion-project-package-managers-2022" target="_blank" rel="noopener">伙伴项目</a>中，我也能够用我的演示React项目正确地实现PnP。</p>
<p>虽然Yarn Berry还很年轻，但它也已经对包装经理的格局产生了影响——pnpm在2020年末采用了<a href="https://pnpm.io/blog/2020/10/17/node-modules-configuration-options-with-pnpm#plugnplay-the-strictest-configuration" target="_blank" rel="noopener"> PnP方法</a>。</p>
<h2 id="installation-workflows">安装工作流程</h2>
<p>必须首先在每个开发人员的本地和CI/CD系统上安装一个包管理器。</p>
<h3>npm</h3>
<p>npm是Node.js附带的，所以不需要额外的步骤。除了为您的操作系统下载<a href="https://nodejs.org/en/download/" target="_blank" rel="noopener"> Node.js安装程序</a>之外，使用CLI工具来管理软件版本已经成为一种常见的做法。在Node的上下文中，<a href="https://github.com/nvm-sh/nvm" target="_blank" rel="noopener">节点版本管理器(nvm) </a>或<a href="https://volta.sh/" target="_blank" rel="noopener"> Volta </a>已经成为非常方便的工具。</p>
<h3>纱线经典款和纱线浆果款</h3>
<p>您可以用不同的方式<a href="https://classic.yarnpkg.com/en/docs/install#mac-stable" target="_blank" rel="noopener">安装纱线1 </a>，例如，与<code>$ npm i -g yarn</code>一起作为npm包。</p>
<p>为了<a href="https://yarnpkg.com/getting-started/migration" target="_blank" rel="noopener">从Yarn Classic迁移到Yarn Berry </a>，推荐的方法是:</p>
<ul>
<li>将Yarn Classic安装或更新至最新的1.x版本</li>
<li>使用<code>yarn set version</code>命令升级到最新的现代版本:<code>$ yarn set version berry</code></li>
</ul>
<p>然而，<a href="https://yarnpkg.com/getting-started/install#install-corepack" target="_blank" rel="noopener">推荐的安装Yarn Berry </a>的方式是通过Corepack。</p>
<p>Corepack 是由Yarn Berry的人们创造的。该计划最初被命名为<a href="https://github.com/nodejs/TSC/issues/904" target="_blank" rel="noopener">包管理经理(pmm) </a>🤯并且<a href="https://github.com/nodejs/node/pull/35398" target="_blank" rel="noopener">与LTS v16中的节点</a>合并。</p>
<p>在Corepack的帮助下，您不必“单独”安装npm的替代包管理器，因为Node包括Yarn Classic、Yarn Berry和pnpm二进制文件作为垫片。这些垫片允许用户运行Yarn和pnpm命令，而不必先明确安装它们，也不会扰乱节点分布。</p>
<p>Corepack预装Node.js ≥ v16.9.0，不过对于较老的Node版本，可以使用<code>$ npm install -g corepack</code>安装。</p>
<p>使用Corepack之前，请先启用它。示例显示了如何在Yarn Berry v3.1.1中激活它。</p>
<pre class="language-bash hljs"># you need to opt-in first
$ corepack enable
# shim installed but concrete version needs to activated
$ corepack prepare <a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="e29b83908ca2d1ccd3ccd3">[email protected]</a> --activate
</pre>
<h3>pnpm</h3>
<p>可以用<code>$ npm i -g pnpm</code>将pnpm作为npm包安装。也可以<a href="https://pnpm.io/installation#using-corepack" target="_blank" rel="noopener">用Corepack </a> : <code>$ corepack prepare <a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="61110f110c21574f53554f53">[email protected]</a> --activate</code>安装pnpm。</p>
<h2 id="project-structures">项目结构</h2>
<p>在这一节中，您将一目了然地看到不同包管理器的主要特征。您可以很容易地发现哪些文件涉及到配置特定的包管理器，以及哪些文件是由安装步骤生成的。</p>
<p>所有的包管理器在项目清单文件<a href="https://docs.npmjs.com/cli/v8/configuring-npm/package-json" target="_blank" rel="noopener"> <code>package.json</code> </a>中存储所有重要的元信息。此外，根级别的配置文件可用于设置私有注册中心或依赖关系解析方法。</p>
<p>对于安装步骤，依赖性被存储在文件结构中(例如，在<code>node_modules</code>中)并且生成锁定文件。本节没有考虑到<a href="https://doppelmutzi.github.io/monorepo-lerna-yarn-workspaces/" target="_blank" rel="noopener">工作区设置</a>，所以所有的例子只显示了一个存储依赖关系的位置。</p>
<h3>npm</h3>
<p>用<code>$ npm install</code>，或者更短的<code>$ npm i</code>，生成一个<a href="https://docs.npmjs.com/cli/v7/configuring-npm/package-lock-json" target="_blank" rel="noopener"> <code>package-lock.json</code>文件</a>和一个<code>node_modules</code>文件夹。可选的<a href="https://docs.npmjs.com/cli/v8/configuring-npm/npmrc" target="_blank" rel="noopener"> <code>.npmrc</code>配置文件</a>可以放在根级别。有关锁文件的更多信息，请参见下一节。</p>
<pre class="language-plaintext hljs">.
├── node_modules/
├── .npmrc
├── package-lock.json
└── package.json
</pre>
<h3>经典纱线</h3>
<p>运行<code>$ yarn</code>会创建一个<code>yarn.lock</code>文件和一个<code>node_modules</code>文件夹。一个<a href="https://classic.yarnpkg.com/en/docs/yarnrc" target="_blank" rel="noopener"> <code>.yarnrc</code>文件</a>也可以是一个配置选项；纱经典还荣誉<code>.npmrc</code>档案。可选地，可以使用缓存文件夹(<code>.yarn/cache/</code>)和存储当前纱线经典版本的位置(<code>.yarn/releases/</code>)。在比较配置一节中可以看到不同的配置方法。</p>
<pre class="language-bash hljs">.
├── .yarn/
│   ├── cache/
│   └── releases/
│       └── yarn-1.22.17.cjs
├── node_modules/
├── .yarnrc
├── package.json
└── yarn.lock
</pre>
<h3>纱莓带<code>node_modules</code></h3>
<p>独立于安装模式，你将不得不在Yarn Berry项目中处理比使用其他包管理器的项目更多的文件和文件夹。有些是可选的，有些是强制的。</p>
<p>纱贝里不再荣誉<code>.npmrc</code>或<code>.yarnrc</code>文件；相反，需要一个<a href="https://yarnpkg.com/configuration/yarnrc/" target="_blank" rel="noopener"> <code>.yarnrc.yml</code>配置文件</a>。对于带有生成的<code>node_modules</code>文件夹的传统工作流，您必须提供一个<a href="https://yarnpkg.com/configuration/yarnrc/#nodeLinker" target="_blank" rel="noopener"> <code>nodeLinker</code>配置</a>，它使用<code>node_modules</code>或pnpm启发的安装变体。</p>
<pre class="language-bash hljs"># .yarnrc.yml
nodeLinker: node-modules # or pnpm
</pre>
<p>运行<code>$ yarn</code>会将所有依赖项安装到一个<code>node_modules</code>文件夹中。生成一个<code>yarn.lock</code>文件，该文件较新，但与Yarn Classic不兼容。此外，还会生成一个用于离线安装的<code>.yarn/cache/</code>文件夹。<code>releases</code>文件夹是可选的，存储项目使用的Yarn Berry版本，我们将在比较配置一节中看到。</p>
<pre class="language-plaintext hljs">.
├── .yarn/
│   ├── cache/
│   └── releases/
│       └── yarn-3.1.1.cjs
├── node_modules/
├── .yarnrc.yml
├── package.json
└── yarn.lock
</pre>
<h3>带有PnP的纱线浆果</h3>
<p>对于<a href="https://yarnpkg.com/features/pnp/" target="_blank" rel="noopener">严格</a>和<a href="https://yarnpkg.com/features/pnp/#pnp-loose-mode" target="_blank" rel="noopener">宽松</a> PnP模式，执行<code>$ yarn</code>会生成<code>.yarn/cache/</code>和<code>.yarn/unplugged/</code>，以及<code>.pnp.cjs</code>和<code>yarn.lock</code>文件。PnP strict是默认模式，但对于loose，需要进行配置。</p>
<pre class="language-bash hljs"># .yarnrc.yml
nodeLinker: pnp
pnpMode: loose
</pre>
<p>在PnP项目中，<code>.yarn/</code>文件夹很可能包含一个<code>sdk/</code>文件夹，以提供除了<code>releases/</code>文件夹之外的<a href="https://yarnpkg.com/getting-started/editor-sdks" target="_blank" rel="noopener"> IDE支持</a>。根据您的使用情况，有更多的文件夹可以成为<code>.yarn/</code>的一部分。</p>
<pre class="language-plaintext hljs">.
├── .yarn/
│   ├── cache/
│   ├── releases/
│   │   └── yarn-3.1.1.cjs
│   ├── sdk/
│   └── unplugged/
├── .pnp.cjs
├── .pnp.loader.mjs
├── .yarnrc.yml
├── package.json
└── yarn.lock
</pre>
<h3>pnpm</h3>
<p>pnpm项目的初始状态看起来就像npm或Yarn Classic项目——您需要一个<code>package.json</code>文件。在安装了与<code>$ pnpm i</code>的依赖关系后，会生成一个<code>node_modules</code>文件夹，但是它的结构完全不同，因为它采用了内容可寻址的存储方法。</p>
<p>pnpm还生成自己版本的锁文件<code>pnp-lock.yml</code>。您可以通过可选的<code>.npmrc</code>文件提供额外的配置。</p><div class="code-block code-block-54">
<hr/>
<h3>更多来自LogRocket的精彩文章:</h3>

<hr/></div>
<pre class="language-plaintext hljs">.
├── node_modules/
│   └── .pnpm/
├── .npmrc
├── package.json
└── pnpm-lock.yml
</pre>
<h2 id="lock-files-dependency-storage">锁定文件和依赖存储</h2>
<p>如前一节所述，每个包管理器都创建<a href="https://snyk.io/blog/what-is-package-lock-json/" target="_blank" rel="noopener">锁文件</a>。</p>
<p>锁定文件精确地存储为您的项目安装的每个依赖项的版本，使安装更加可预测和确定。这是必需的，因为依赖版本很可能是用<a href="https://docs.npmjs.com/about-semantic-versioning" target="_blank" rel="noopener">版本范围</a>(例如，v1.2.5)声明的，因此，如果您不“锁定”您的版本，实际安装的版本可能会有所不同。</p>
<p>锁文件有时也会存储校验和，我们将在安全性一节中更深入地讨论这一点。</p>
<p>锁文件从v5 ( <code><a href="https://docs.npmjs.com/cli/v8/configuring-npm/package-lock-json" target="_blank" rel="noopener">package-lock.json</a></code>)开始就是npm的一个特性，从第一天开始就是pnpm的一个特性(<code><a href="https://pnpm.io/git#lockfiles" target="_blank" rel="noopener">pnpm-lock.yaml</a></code>)，在Yarn Berry ( <code><a href="https://dev.to/arcanis/introducing-yarn-2-4eh1#new-lockfile-format" target="_blank" rel="noopener">yarn.lock</a></code>中是一个新的YAML格式。</p>
<p>在上一节中，我们看到了传统的方法，依赖项安装在一个<code>node_modules</code>文件夹结构中。这是npm、<a href="https://classic.yarnpkg.com/en/docs/yarn-lock/#toc-check-into-source-control" target="_blank" rel="noopener">纱经典</a>和<a href="https://pnpm.io/git#lockfiles" target="_blank" rel="noopener"> pnpm </a>都使用的方案，其中pnpm做的比其他的更有效率。</p>
<p>PnP模式下的Yarn Berry则不同。依赖项不是存储在<code>node_modules</code>文件夹中，而是存储在一个由<code>.yarn/cache/</code>和<code>.pnp.cjs</code>文件组合而成的zip文件中。</p>
<p>最好是<a href="https://yarnpkg.com/getting-started/qa/#which-files-should-be-gitignored" target="_blank" rel="noopener">将这些锁文件置于版本控制之下</a>,因为它解决了“在我的机器上工作”的问题——每个团队成员安装相同的版本。</p>
<h2 id="cli-commands">CLI命令</h2>
<p>下表比较了npm、Yarn Classic、Yarn Berry和pnpm中提供的一组不同的CLI命令。这绝不是一个完整的列表，而是一个备忘单。本节不包括与工作空间相关的命令。</p>
<p>npm和pnpm特别具有许多命令和选项别名，这意味着命令可以有不同的名称，例如，<code>$ npm install</code>与<code>$ npm add</code>相同。此外，许多命令选项都有简短的版本，例如，<code>-D</code>代替了<code>--save-dev</code>。</p>
<p>在表格中，我将所有的简称称为别名。对于所有的包管理器，您可以通过用空格(例如，<code>npm update react react-dom</code>)分隔来添加、更新或删除多个依赖项。为了清楚起见，示例只显示了单个依赖项的用法。</p>
<h3>依赖性管理</h3>
<p>该表涵盖了安装或更新<code>package.json</code>中指定的所有依赖关系的依赖关系管理命令，或通过在命令中指定多个依赖关系。</p>
<table class="center">
<thead>
<tr>
<th>行动</th>
<th><a href="https://docs.npmjs.com/cli/v8/commands" target="_blank" rel="noopener"> npm </a></th>
<th><a href="https://classic.yarnpkg.com/en/docs/cli/" target="_blank" rel="noopener">纱经典</a></th>
<th><a href="https://yarnpkg.com/cli/" target="_blank" rel="noopener">纱莓</a></th>
<th><a href="https://pnpm.io/cli/add" target="_blank" rel="noopener"> pnpm </a></th>
</tr>
</thead>
<tbody>
<tr>
<td>在<code>package.json</code>中安装deps</td>
<td><code>npm install</code> <br/>别名:<code>i</code>，<code>add</code></td>
<td><code>yarn install</code>或<code>yarn</code></td>
<td>喜欢经典</td>
<td><code>pnpm install</code> <br/>别名:<code>i</code></td>
</tr>
<tr>
<td>更新<code>package.json</code> acc中的deps。塞姆弗</td>
<td><code>npm update</code> <br/>别名:<code>up</code>，<code>upgrade</code></td>
<td><code>yarn upgrade</code></td>
<td><code>yarn semver up</code>(通过<a href="https://github.com/tophat/yarn-plugin-semver-up" target="_blank" rel="noopener">插件</a></td>
<td><code>pnpm update</code> <br/>别名:<code>up</code></td>
</tr>
<tr>
<td>将<code>package.json</code>中的deps更新为最新</td>
<td>不适用的</td>
<td><code>yarn upgrade --latest</code></td>
<td><code>yarn up</code></td>
<td><code>pnpm update --latest</code> <br/>别名:<code>-L</code></td>
</tr>
<tr>
<td>根据更新deps。塞姆弗</td>
<td><code>npm update react</code></td>
<td><code>yarn upgrade react</code></td>
<td><code>yarn semver up react</code></td>
<td><code>pnpm up react</code></td>
</tr>
<tr>
<td>将deps更新为最新版本</td>
<td><code>npm update <a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="c7b5a2a6a4b387aba6b3a2b4b3">[email protected]</a></code></td>
<td><code>yarn upgrade react --latest</code></td>
<td><code>yarn up react</code></td>
<td><code>pnpm up -L react</code></td>
</tr>
<tr>
<td>交互式更新deps</td>
<td>不适用的</td>
<td><code>yarn upgrade-interactive</code></td>
<td><code>yarn upgrade-interactive</code>(通过<a href="https://github.com/yarnpkg/berry/blob/HEAD/packages/plugin-interactive-tools/README.md" target="_blank" rel="noopener">插件</a></td>
<td><code>$ pnpm up --interactive</code> <br/>别名:<code>-i</code></td>
</tr>
<tr>
<td>添加运行时dep</td>
<td><code>npm i react</code></td>
<td><code>yarn add react</code></td>
<td>喜欢经典</td>
<td><code>pnpm add react</code></td>
</tr>
<tr>
<td>添加开发部门</td>
<td><code>npm i -D babel</code> <br/>别名:<code>--save-dev</code></td>
<td><code>yarn add -D babel</code> <br/>别名:<code>--dev</code></td>
<td>喜欢经典</td>
<td><code>pnpm add -D babel</code> <br/>别名:<code>--save-dev</code></td>
</tr>
<tr>
<td>将deps添加到<code>package.json</code>而不添加semver</td>
<td><code>npm i -E react</code> <br/>别名:<code>--save-exact</code></td>
<td><code>yarn add -E react</code> <br/>别名:<code>--exact</code></td>
<td>喜欢经典</td>
<td><code>pnpm add -E react</code> <br/>别名:<code>--save-exact</code></td>
</tr>
<tr>
<td>卸载deps并从<code>package.json</code>中移除</td>
<td><code>npm uninstall react</code> <br/>别名:<code>remove</code>、<code>rm</code>、<code>r</code>、<code>un</code>、<code>unlink</code></td>
<td><code>yarn remove react</code></td>
<td>喜欢经典</td>
<td><code>pnpm remove react</code> <br/>别名:<code>rm</code>、<code>un</code>、<code>uninstall</code></td>
</tr>
<tr>
<td>卸载deps，不更新<code>package.json</code></td>
<td><code>npm uninstall </code><br/>T1】</td>
<td>不适用的</td>
<td>不适用的</td>
<td>不适用的</td>
</tr>
</tbody>
</table>
<h3>包执行</h3>
<p>下面的例子展示了如何在开发期间管理构成实用工具的包——也就是二进制文件，比如<a href="https://github.com/ruyadorno/ntl" target="_blank" rel="noopener"> ntl </a>,从而交互地执行脚本。表中使用的术语:</p>
<ul>
<li>包:依赖或二进制</li>
<li>二进制:从<code>node_modules/.bin/</code>或<code>.yarn/cache/</code> (PnP)执行的可执行实用程序</li>
</ul>
<p>出于安全原因，Yarn Berry只允许我们执行我们在<code>package.json</code>中指定的或者在<code>bin</code>元字段中<a href="https://github.com/yarnpkg/berry/issues/2784#issuecomment-831825366" target="_blank" rel="noopener">公开的二进制文件，理解这一点很重要。pnpm的特点是</a><a href="https://github.com/pnpm/pnpm/issues/899#issuecomment-334548475" target="_blank" rel="noopener">同样的安全行为</a>。</p>
<table class="center">
<thead>
<tr>
<th>行动</th>
<th>npm</th>
<th>经典纱线</th>
<th>纱线浆果</th>
<th>pnpm</th>
</tr>
</thead>
<tbody>
<tr>
<td>全局安装软件包</td>
<td><code>npm i -g ntl</code> <br/>别名:<code>--global</code></td>
<td><code>yarn global add ntl</code></td>
<td>不适用(<a href="https://yarnpkg.com/getting-started/migration/#use-yarn-dlx-instead-of-yarn-global" target="_blank" rel="noopener">全局移除</a>)</td>
<td><code>pnpm add --global ntl</code></td>
</tr>
<tr>
<td>全局更新软件包</td>
<td><code>npm update -g ntl</code></td>
<td><code>yarn global upgrade ntl</code></td>
<td>不适用的</td>
<td><code>pnpm update --global ntl</code></td>
</tr>
<tr>
<td>全局删除包</td>
<td><code>npm uninstall -g ntl</code></td>
<td><code>yarn global remove ntl</code></td>
<td>不适用的</td>
<td><code>pnpm remove<br/> --global ntl</code></td>
</tr>
<tr>
<td>从终端运行二进制文件</td>
<td><code>npm exec ntl</code></td>
<td><code>yarn ntl</code></td>
<td><code>yarn ntl</code></td>
<td><code>pnpm ntl</code></td>
</tr>
<tr>
<td>从脚本运行二进制文件</td>
<td><code>ntl</code></td>
<td><code>ntl</code></td>
<td><code>ntl</code></td>
<td><code>ntl</code></td>
</tr>
<tr>
<td>动态包执行</td>
<td><code>npx ntl</code></td>
<td>不适用的</td>
<td><code>yarn dlx ntl</code></td>
<td><code>pnpm dlx ntl</code></td>
</tr>
<tr>
<td>添加运行时dep</td>
<td><code>npm i react</code></td>
<td><code>yarn add react</code></td>
<td>喜欢经典</td>
<td><code>pnpm add react</code></td>
</tr>
<tr>
<td>添加开发部门</td>
<td><code>npm i -D babel</code> <br/>别名:<code>--save-dev</code></td>
<td><code>yarn add -D babel</code> <br/>别名:<code>--dev</code></td>
<td>喜欢经典</td>
<td><code>pnpm add -D babel</code> <br/>别名:<code>--save-dev</code></td>
</tr>
<tr>
<td>将deps添加到<code>package.json</code>而不添加semver</td>
<td><code>npm i -E react</code> <br/>别名:<code>--save-exact</code></td>
<td><code>yarn add -E react</code> <br/>别名:<code>--exact</code></td>
<td>喜欢经典</td>
<td><code>pnpm add -E react</code> <br/>别名:<code>--save-exact</code></td>
</tr>
<tr>
<td>卸载deps并从<code>package.json</code>中移除</td>
<td><code>npm uninstall react</code> <br/>别名:<code>remove</code>、<code>rm</code>、<code>r</code>、<code>un</code>、<code>unlink</code></td>
<td><code>yarn remove react</code></td>
<td>喜欢经典</td>
<td><code>pnpm remove react</code> <br/>别名:<code>rm</code>、<code>un</code>、<code>uninstall</code></td>
</tr>
<tr>
<td>卸载deps，不更新<code>package.json</code></td>
<td><code>npm uninstall</code><br/>T1】</td>
<td>不适用的</td>
<td>不适用的</td>
<td>不适用的</td>
</tr>
</tbody>
</table>
<h3>常见命令</h3>
<p>此表涵盖了有用的内置命令。如果没有官方命令，通常可以通过npm包或Yarn Berry插件使用第三方命令。</p>
<table>
<thead>
<tr>
<th>行动</th>
<th>npm</th>
<th>经典纱线</th>
<th>纱线浆果</th>
<th>pnpm</th>
</tr>
</thead>
<tbody>
<tr>
<td>发布包</td>
<td><code>npm publish</code></td>
<td><code>yarn publish</code></td>
<td><code>yarn npm publish</code></td>
<td><code>pnpm publish</code></td>
</tr>
<tr>
<td>列出已安装的部门</td>
<td><code>npm ls</code> <br/>别名:<code>list</code>、<code>la</code>、<code>ll</code></td>
<td><code>yarn list</code></td>
<td><code>pnpm list</code> <br/>别名:<code>ls</code></td>
<td>列出过期的部门</td>
</tr>
<tr>
<td><code>npm outdated</code></td>
<td><code>yarn outdated</code></td>
<td><code>yarn upgrade-interactive</code></td>
<td><code>pnpm outdated</code></td>
<td>打印关于部门的信息</td>
</tr>
<tr>
<td><code>npm explain ntl</code> <br/>别名:<code>why</code></td>
<td><code>yarn why ntl</code></td>
<td>像经典一样</td>
<td><code>pnpm why ntl</code></td>
<td>初始化项目</td>
</tr>
<tr>
<td><code>npm init -y</code> <br/> <code>npm init</code>(互动)<br/>别名:<code>--yes</code></td>
<td><code>yarn init -y</code> <br/> <code>yarn init</code>(互动)<br/>别名:<code>--yes</code></td>
<td><code>yarn init</code></td>
<td><code>pnpm init -y</code> <br/> <code>pnpm init</code>(互动)<br/>别名:<code>--yes</code></td>
<td>打印许可证信息</td>
</tr>
<tr>
<td>不适用(通过第三方软件包)</td>
<td><code>yarn licenses list</code></td>
<td>不适用(或通过<a href="https://github.com/tophat/yarn-plugin-licenses" target="_blank" rel="noopener">插件</a>，其他<a href="https://github.com/mhassan1/yarn-plugin-licenses" target="_blank" rel="noopener">插件</a></td>
<td>不适用(通过第三方软件包)</td>
<td>更新包管理器版本</td>
</tr>
<tr>
<td>不适用(使用第三方工具，如nvm)</td>
<td>带npm: <code>yarn policies set-version 1.13.0</code></td>
<td>带Corepack: <code>yarn set version 3.1.1</code></td>
<td>不适用(带国家预防机制、核心包)</td>
<td>执行安全审计</td>
</tr>
<tr>
<td><code>npm audit</code></td>
<td><code>yarn audit</code></td>
<td><code>yarn npm audit</code></td>
<td><code>pnpm audit</code></td>
<td>将deps添加到<code>package.json</code>而不添加semver</td>
</tr>
<tr>
<td><code>npm i -E react</code> <br/>别名:<code>--save-exact</code></td>
<td><code>yarn add -E react</code> <br/>别名:<code>--exact</code></td>
<td>喜欢经典</td>
<td><code>pnpm add -E react</code> <br/>别名:<code>--save-exact</code></td>
<td>卸载deps并从<code>package.json</code>中移除</td>
</tr>
<tr>
<td><code>npm uninstall react</code> <br/>别名:<code>remove</code>、<code>rm</code>、<code>r</code>、<code>un</code>、<code>unlink</code></td>
<td><code>yarn remove react</code></td>
<td>喜欢经典</td>
<td><code>pnpm remove react</code> <br/>别名:<code>rm</code>、<code>un</code>、<code>uninstall</code></td>
<td>卸载deps，不更新<code>package.json</code></td>
</tr>
<tr>
<td><code>npm uninstall<br/> --no-save</code></td>
<td>不适用的</td>
<td>不适用的</td>
<td>不适用的</td>
<td>配置文件</td>
</tr>
</tbody>
</table>
<h2 id="configuration-files">配置包管理器发生在您的<code>package.json</code>和专用配置文件中。配置选项的示例包括:</h2>
<p>定义要使用的确切版本</p>
<ul>
<li>使用特定的依赖关系解析策略</li>
<li>配置对私有注册表的访问</li>
<li>告诉包管理器在monorepo中哪里可以找到工作区</li>
<li>npm</li>
</ul>
<h3>大多数配置发生在专用的配置文件(<code>.npmrc</code>)中。</h3>
<p>如果您想要使用npm的工作区特性，您必须通过使用<a href="https://docs.npmjs.com/cli/v8/using-npm/config#workspaces" target="_blank" rel="noopener">工作区元数据字段</a>向<code>package.json</code>添加一个配置，以告诉npm在哪里分别找到构成子项目或工作区的文件夹。</p>
<p>每个软件包管理器都使用公共的npm注册表。在有共享库的公司环境中，您很可能想要重用它们而不将它们发布到公共注册中心。要配置私有注册表，可以在一个<code>.npmrc</code>文件中完成。</p>
<pre class="language-bash hljs">{
  // ...
  "workspaces": [
    "hooks",
    "utils"
  ]
}
</pre>
<p>npm有许多配置选项,最好在文档中查看。</p>
<pre class="language-bash hljs"># .npmrc
@doppelmutzi:registry=https://gitlab.doppelmutzi.com/api/v4/projects/41/packages/npm/
</pre>
<p>经典纱线</p>
<h3>您可以在您的<code>package.json</code>中设置<a href="https://classic.yarnpkg.com/en/docs/workspaces" target="_blank" rel="noopener">纱线工作空间</a>。它类似于npm，但是工作空间必须是一个私有包。</h3>
<p>任何可选的配置都进入一个<a href="https://classic.yarnpkg.com/en/docs/yarnrc" target="_blank" rel="noopener"> <code>.yarnrc</code>文件</a>。一个常见的配置选项是设置一个<code><a href="https://classic.yarnpkg.com/en/docs/yarnrc#toc-yarn-path" target="_blank" rel="noopener">yarn-path</a></code>，它强制每个团队成员使用一个特定的二进制版本。<code>yarn-path</code>指向包含特定纱线版本的文件夹(如<code>.yarn/releases/</code>)。你可以用<a href="https://classic.yarnpkg.com/en/docs/cli/policies" target="_blank" rel="noopener"> <code>yarn policies</code>命令</a>安装一个Yarn Classic版本。</p>
<pre class="language-bash hljs">{
  // ...
  "private": true,
  "workspaces": ["workspace-a", "workspace-b"]
}
</pre>
<p>纱线浆果</p>
<h3><a href="https://yarnpkg.com/configuration/manifest#workspaces" target="_blank" rel="noopener">在Yarn Berry中配置工作区</a>也类似于在Yarn Classic中的操作，带有一个<code><a href="https://yarnpkg.com/configuration/manifest" target="_blank" rel="noopener">package.json</a></code>。大多数纱线浆果配置发生在<code><a href="https://yarnpkg.com/configuration/yarnrc" target="_blank" rel="noopener">.yarnrc.yml</a></code>，有许多配置选项可用。Yarn Classic示例也是可行的，但是元数据字段被重命名为<code><a href="https://yarnpkg.com/configuration/yarnrc#yarnPath" target="_blank" rel="noopener">yarnPath</a></code>。</h3>
<p>纱贝里可以通过使用<a href="https://yarnpkg.com/cli/plugin/import" target="_blank" rel="noopener"> <code>yarn plugin import</code> </a>来扩展插件。该命令更新<code>.yarnrc.yml</code>。</p>
<pre class="language-bash hljs"># .yarnrc.yml
yarnPath: .yarn/releases/yarn-3.1.1.cjs
</pre>
<p>如历史部分所述，由于不兼容，PnP严格模式下的依赖关系可能会出现问题。这种PnP问题有一个典型的解决方案:<a href="https://yarnpkg.com/configuration/yarnrc/#packageExtensions" target="_blank" rel="noopener"> <code>packageExtensions</code>配置属性</a>。你可以跟随下一个例子的<a href="https://github.com/doppelmutzi/companion-project-package-managers-2022/blob/yarn-berry-pnp-strict/.yarnrc.yml" target="_blank" rel="noopener">伙伴项目</a>。</p>
<pre class="language-bash hljs"># .yarnrc.yml
plugins:
  - path: .yarn/plugins/@yarnpkg/plugin-semver-up.cjs
    spec: "https://raw.githubusercontent.com/tophat/yarn-plugin-semver-up/master/bundles/%40yarnpkg/plugin-semver-up.js"
</pre>
<p>pnpm</p>
<pre class="language-bash hljs"># .yarnrc.yml
packageExtensions:
  "<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="ee9d9a97828b8ac38d81839e81808b809a9dae">[email protected]</a>*":
    dependencies:
      react-is: "*"
</pre>
<h3>pnpm使用与npm 相同的<a href="https://pnpm.io/configuring" target="_blank" rel="noopener">配置机制，所以您可以使用一个<code>.npmrc</code>文件。配置私有注册表的工作方式也与npm相同。</a></h3>
<p>通过pnpm的<a href="https://pnpm.io/workspaces" target="_blank" rel="noopener">工作空间特性</a>，可以支持多包项目。要初始化monorepo，您必须<a href="https://pnpm.io/pnpm-workspace_yaml" target="_blank" rel="noopener">在<code>pnpm-workspace.yaml</code>文件中指定包的位置</a>。</p>
<p>单一回购支持</p>
<pre class="language-bash hljs"># pnpm-workspace.yaml
packages:
  - 'packages/**'
</pre>
<h2 id="monorepo-support">什么是单向回购？</h2>
<h3>monorepo是存放多个项目的存储库，这些项目被称为工作区或包。这是一个项目组织策略，将所有东西保存在一个地方，而不是使用多个存储库。</h3>
<p>当然，这带来了额外的复杂性。Yarn Classic是第一个启用该功能的，但是现在每个主要的包管理器都提供了工作区功能。本节展示了如何使用每个不同的包管理器来配置工作区。</p>
<p>npm</p>
<h3>npm团队在v7中发布了期待已久的<a href="https://docs.npmjs.com/cli/v8/using-npm/workspaces" target="_blank" rel="noopener"> npm工作区</a>特性。它包含了许多CLI命令，这些命令有助于从一个根包中管理多包项目。大多数命令都可以与工作区相关的选项一起使用，以告诉npm应该针对特定、多个还是所有工作区运行。</h3>
<p>与其他包管理器不同，npm v8目前不支持高级过滤或并行执行多个与工作区相关的命令。</p>
<pre class="language-bash hljs"># Installing all dependencies for all workspaces
$ npm i --workspaces.
# run against one package
$ npm run test --workspace=hooks
# run against multiple packages
$ npm run test --workspace=hooks --workspace=utils
# run against all
$ npm run test --workspaces
# ignore all packages missing test
$ npm run test --workspaces --if-present
</pre>
<p>经典纱线</p>
<h3>2017年8月，Yarn团队<a href="https://classic.yarnpkg.com/blog/2017/08/02/introducing-workspaces/" target="_blank" rel="noopener">宣布在<a href="https://classic.yarnpkg.com/en/docs/workspaces" target="_blank" rel="noopener">工作区</a>功能方面提供</a>一级单一回购支持。在这一点之前，只能在带有第三方软件如<a href="https://lerna.js.org/" target="_blank" rel="noopener"> Lerna </a>的多包项目中使用包管理器。对Yarn的添加也为其他包管理器实现这样的特性铺平了道路。</h3>
<p>如果你感兴趣的话，我以前也写过关于<a href="https://doppelmutzi.github.io/monorepo-lerna-yarn-workspaces/" target="_blank" rel="noopener">如何使用Yarn Classic的工作空间特性</a>以及是否使用Lerna。但是这篇文章将只涉及一些必要的命令来帮助您管理Yarn Classic工作空间设置中的依赖关系。</p>
<p>纱线浆果</p>
<pre class="language-bash hljs"># Installing all dependencies for all workspaces
$ yarn
# display dependency tree
$ yarn workspaces info
# run start command only for one package
$ yarn workspace awesome-package start
# add Webpack to package
$ yarn workspace awesome-package add -D webpack
# add React to all packages
$ yarn add react -W
</pre>
<h3>Yarn Berry <a href="https://yarnpkg.com/features/workspaces/" target="_blank" rel="noopener">从一开始就以工作空间</a>为特色，因为它的实现是建立在Yarn Classic的概念之上的。在<a href="https://www.reddit.com/r/node/comments/omxnnq/workspaces_2021_yarn_v1_vs_yarn_v2_vs_npm/" target="_blank" rel="noopener"> Reddit的评论</a>中，Yarn Berry的一位主要开发者简要概述了面向工作空间的特性，包括:</h3>
<p>Yarn Berry大量使用了<a href="https://yarnpkg.com/features/protocols/" target="_blank rel=" rel="noopener">协议</a>，该协议可用于<code>package.json</code>文件的<code>dependencies</code>或<code>devDependencies</code>字段。其中之一就是<a href="https://yarnpkg.com/features/workspaces/#workspace-ranges-workspace" target="_blank rel=" rel="noopener"> <code>workspace:</code>协议</a>。</p>

<p>与Yarn Classic的工作区不同，Yarn Berry明确定义了依赖项必须是这个monorepo中的一个包。否则，如果版本不匹配，Yarn Berry可能会尝试从远程注册表获取版本。</p>
<p>pnpm</p>
<pre class="language-json hljs">{
  // ...
  "dependencies": {
    "@doppelmutzi/hooks": "workspace:*",
    "http-server": "14.0.0",
    // ...
  }  
}
</pre>
<h3>通过其<code>workspace:</code>协议，pnpm促进了类似于Yarn Berry的monorepo项目。许多pnpm命令接受像<code>--recursive</code> ( <code>-r</code>)或<a href="https://pnpm.io/filtering" target="_blank" rel="noopener"> <code>--filter</code> </a>这样的选项，这些选项在monorepo上下文中特别有用。它的<a href="https://medium.com/pnpm/pnpm-vs-lerna-filtering-in-a-multi-package-repository-1f68bc644d6a" target="_blank" rel="noopener">原生过滤命令</a>也是对Lerna很好的补充或替代。</h3>
<p>性能和磁盘空间效率</p>
<pre class="language-bash hljs"># prune all workspaces  
pnpm -r exec -- rm -rf node_modules &amp;&amp; rm pnpm-lock.yaml  
# run all tests for all workspaces with scope @doppelmutzi
pnpm recursive run test --filter @doppelmutzi/
</pre>
<h2 id="performance-disk-space-efficiency">绩效是决策的重要组成部分。这一部分展示了我基于一个小型和一个中型项目的基准测试。以下是关于示例项目的一些注释:</h2>
<p>两组基准都不使用工作区特性</p>
<ul>
<li>这个小项目指定了33个依赖项</li>
<li>中型项目指定了44个依赖项</li>
<li>我对三个用例(UC)进行了测量，对我们的每个包管理器变体进行一次测量。要了解详细的评估及说明，请查看<a href="https://github.com/doppelmutzi/companion-project-package-managers-2022/blob/yarn-berry-pnp-strict/benchmarks-project1.md" target="_blank" rel="noopener">项目1 (P1) </a>和<a href="https://github.com/doppelmutzi/companion-project-package-managers-2022/blob/yarn-berry-pnp-strict/benchmarks-project2.md" target="_blank" rel="noopener">项目2 (P2) </a>的结果。</li>
</ul>
<p>UC 1:没有缓存/存储，没有锁文件，没有<code>node_modules</code>或<code>.pnp.cjs</code></p>
<ul>
<li>UC 2:存在缓存/存储，没有锁文件，没有<code>node_modules</code>或<code>.pnp.cjs</code></li>
<li>UC 3:缓存/存储存在，锁文件存在，无<code>node_modules</code>或<code>.pnp.cjs</code></li>
<li>我使用工具<a href="https://github.com/paypal/gnomon" target="_blank" rel="noopener"> gnomon </a>来测量一次安装所消耗的时间(例如<code>$ yarn | gnomon</code>)。另外，我测量了生成文件的大小，例如<code>$ du -sh node_modules</code>。</li>
</ul>
<p>根据我的项目和测量，Yarn Berry PnP strict在所有用例以及两个项目的安装速度方面都是赢家。</p>
<p>项目1的绩效结果</p>
<table>
<thead>
<tr>
<th colspan="8">方法</th>
</tr>
</thead>
<tbody>
<tr>
<td>npm <br/> v8.1.2</td>
<td>纱线经典<br/> v1.23.0</td>
<td>pnpm <br/> v6.24.4</td>
<td>纱莓PnP松<br/> v3.1.1</td>
<td>纱贝里PnP严格<br/> v3.1.1</td>
<td>纱莓<code>node_modules</code> <br/> v3.1.1</td>
<td>纱线浆果<br/> pnpm <br/> v3.1.1</td>
<td>UC 1</td>
</tr>
<tr>
<td>86.63秒</td>
<td>108.89秒</td>
<td>43.58秒</td>
<td>31.77秒</td>
<td>30.13秒</td>
<td>56.64秒</td>
<td>60.91秒</td>
<td>UC 2</td>
</tr>
<tr>
<td>41.54秒</td>
<td>65.49秒</td>
<td>26.43秒</td>
<td>12.46秒</td>
<td>12.66秒</td>
<td>46.36秒</td>
<td>40.74秒</td>
<td>UC 3</td>
</tr>
<tr>
<td>23.59秒</td>
<td>40.35秒</td>
<td>20.32秒</td>
<td>1.61秒</td>
<td>1.36秒</td>
<td>28.72秒</td>
<td>31.89秒</td>
<td>文件和大小</td>
</tr>
<tr>
<td><code>package-lock.json</code>:1.3米<br/><code>node_modules</code>:467米</td>
<td><code>node_modules</code>:397米<br/><code>yarn.lock</code>:504千米</td>
<td><code>pnpm-lock.yaml</code>:412K<br/><code>node_modules</code>:319米</td>
<td><code>yarn.lock</code> : 540K <br/>缓存:68M <br/>不插电:29M <br/> <code>.pnp.cjs</code> : 1.6M</td>
<td><code>yarn.lock</code> : 540K <br/>缓存:68M <br/>不插电:29M <br/> <code>.pnp.cjs</code> : 1.5M</td>
<td><code>node_modules</code> : 395M <br/> <code>yarn.lock</code> : 540K <br/>缓存:68M</td>
<td><code>node_modules</code> : 374M <br/> <code>yarn.lock</code> : 540K <br/>缓存:68M</td>
<td> </td>
</tr>
</tbody>
</table>
<p>项目2的绩效结果</p>
<table class="center">
<thead>
<tr>
<th colspan="8">方法</th>
</tr>
</thead>
<tbody>
<tr>
<td>npm <br/> v8.1.2</td>
<td>纱线经典版v1.23.0</td>
<td>pnpm <br/> v6.24.4</td>
<td>纱莓PnP松<br/> v3.1.1</td>
<td>纱贝里PnP严格<br/> v3.1.1</td>
<td>纱莓<code>node_modules</code> <br/> v3.1.1</td>
<td>纱线浆果<br/> pnpm <br/> v3.1.1</td>
<td>UC 1</td>
</tr>
<tr>
<td>34.91秒</td>
<td>43.26秒</td>
<td>15.6秒</td>
<td>13.92秒</td>
<td>6.44英寸</td>
<td>23.62秒</td>
<td>20.09秒</td>
<td>UC 2</td>
</tr>
<tr>
<td>7.92秒</td>
<td>33.65秒</td>
<td>8.86秒</td>
<td>7.09秒</td>
<td>5.63秒</td>
<td>15.12秒</td>
<td>14.93秒</td>
<td>UC 3</td>
</tr>
<tr>
<td>5.09秒</td>
<td>15.64秒</td>
<td>4.73秒</td>
<td>0.93秒</td>
<td>0.79秒</td>
<td>8.18秒</td>
<td>6.02秒</td>
<td>文件和大小</td>
</tr>
<tr>
<td><code>package-lock.json</code> : 684K <br/> <code>node_modules</code> : 151M</td>
<td><code>yarn.lock</code>:268k<br/><code>node_modules</code>:159米</td>
<td><code>pnpm-lock.yaml</code> : 212K <br/> <code>node_modules</code> : 141M</td>
<td><code>.pnp.cjs</code>:1.1M<br/><code>.pnp.loader.mjs</code>:8.0K<br/><code>yarn.lock</code>:292k<br/><code>.yarn</code>:38M</td>
<td><code>.pnp.cjs</code>:1.0M<br/><code>.pnp.loader.mjs</code>:8.0K<br/><code>yarn.lock</code>:292k<br/><code>.yarn</code>:38M</td>
<td><code>yarn.lock</code> : 292K <br/> <code>node_modules</code> : 164M <br/>缓存:34M</td>
<td><code>yarn.lock</code> : 292K <br/> <code>node_modules</code> : 156M <br/>缓存:34M</td>
<td>以下是纱莓团队和<a href="https://pnpm.io/benchmarks" target="_blank" rel="noopener"> pnpm </a>的官方<a href="https://p.datadoghq.eu/sb/d2wdprp9uki7gfks-c562c42f4dfd0ade4885690fa719c818?tpl_var_npm=%2A&amp;tpl_var_pnpm=%2A&amp;tpl_var_yarn-classic=%2A&amp;tpl_var_yarn-modern=%2A&amp;tpl_var_yarn-nm=%2A&amp;tpl_var_yarn-pnpm=no&amp;from_ts=1641753387859&amp;to_ts=1642358187859&amp;live=true" target="_blank" rel="noopener">基准。</a></td>
</tr>
</tbody>
</table>
<p>安全功能</p>
<h2 id="security-features">npm</h2>
<h3>当涉及到处理坏的包时，npm有点太宽容了，并且经历了一些直接影响许多项目的安全漏洞。例如，在5.7.0版本中，当您在Linux操作系统上执行<code>sudo npm</code>命令时，有可能<a href="https://github.com/npm/npm/issues/19883" target="_blank" rel="noopener">改变系统文件的所有权</a>，导致操作系统不可用。</h3>
<p><a href="https://blog.npmjs.org/post/180565383195/details-about-the-event-stream-incident.html" target="_blank" rel="noopener">另一起事件</a>发生在2018年，涉及比特币被盗。基本上，流行的Node.js包<a href="https://www.npmjs.com/package/event-stream" target="_blank" rel="noopener"> EventStream </a>在其版本3.3.6中添加了一个恶意依赖。这个恶意包包含一个加密的有效载荷，试图从开发者的机器上窃取比特币。</p>
<p>为了帮助解决这些问题，最近的npm版本使用<code>package-lock.json</code>中的<a href="https://medium.com/@zaid960928/cryptography-explaining-sha-512-ad896365a0c1" target="_blank" rel="noopener"> <code>SHA-512</code>加密算法</a>来检查您安装的软件包的完整性。</p>
<p>总的来说，npm已经做了越来越多的工作来弥补他们的安全漏洞，尤其是那些与Yarn相比更加明显的漏洞。</p>
<p>故事</p>
<h3>Yarn Classic和Yarn Berry从一开始就用存储在<code>yarn.lock</code>中的<a href="https://yarnpkg.com/features/offline-cache/#cache-integrity" target="_blank" rel="noopener">校验和</a>来验证每个包的完整性。Yarn还试图防止您在安装过程中检索没有在您的<code>package.json</code>中声明的恶意包:如果发现不匹配，安装就会中止。</h3>
<p>PnP模式下的Yarn Berry不会遇到传统<code>node_modules</code>方法的安全问题。与Yarn Classic相比，Yarn Berry提高了命令执行的安全性。您只能执行依赖关系的二进制文件，这些依赖关系是您已经在您的<code>package.json</code>中<a href="https://github.com/yarnpkg/berry/issues/2784#issuecomment-831825366" target="_blank" rel="noopener">显式声明了</a>的。这个安全特性类似于pnpm，我将在下面描述。</p>
<p>pnpm</p>
<h3>pnpm还<a href="https://www.kochan.io/nodejs/why-should-we-use-pnpm.html" target="_blank" rel="noopener">使用校验和</a>在执行代码之前验证每个已安装软件包的完整性。</h3>
<p>正如我们上面提到的，npm和Yarn Classic由于提升都有<a href="https://www.mo4tech.com/deep-thoughts-on-modern-package-managers-why-do-i-now-recommend-pnpm-over-npm-yarn-2.html" target="_blank" rel="noopener">安全问题。pnpm避免了这一点，因为它的模型不使用提升；相反，它生成嵌套的<code>node_modules</code>文件夹，消除非法依赖访问的风险。这意味着依赖项只能访问其他依赖项，如果它们在<code>package.json</code>中被显式声明的话。</a></p>
<p>正如我们所讨论的，这在monorepo设置中尤其重要，因为提升算法有时会导致幻像依赖和复制品。</p>
<p>受欢迎的项目采用</p>
<h2 id="adoption-popular-projects">我分析了许多流行的开源项目，以了解哪些包管理器现在被“开发精英”所使用对我来说，这些项目被积极地维护并在最近更新是很重要的。这可能会让您在选择包管理器时有另一个视角。</h2>
<p>有趣的是，在撰写本文时，这些开源项目都没有使用PnP方法。</p>

<p>结论</p>
<h2>软件包管理器的当前状态非常好。我们实际上已经在所有主要的软件包管理器中实现了功能对等。但是，他们确实在引擎盖下有很大的不同。</h2>
<p>pnpm起初看起来像npm，因为它们的CLI用法相似，但管理依赖关系却大不相同；pnpm的方法带来了更好的性能和最佳的磁盘空间效率。Yarn Classic仍然非常受欢迎，但它被视为传统软件，在不久的将来可能会停止支持。纱浆果PnP是新的孩子，但还没有完全实现其潜力，再次彻底改变包装经理的景观。</p>
<p>这些年来，许多用户都在问<a href="https://www.reddit.com/r/javascript/comments/qfknkk/yarn_31_corepack_esm_pnpm_mode_optional_packages/hi0l1fv/" target="_blank" rel="noopener">谁使用哪个包管理器</a>，总的来说，人们似乎对Yarn Berry PnP的成熟和采用特别感兴趣。</p>
<p>这篇文章的目标是给你提供许多观点，让你自己决定使用哪个包管理器。我想指出的是，我并不推荐某个特定的包管理器。这取决于你如何权衡不同的需求——所以你仍然可以选择你喜欢的任何东西！</p>
<p>通过理解上下文，更容易地调试JavaScript错误</p><div class="code-block code-block-27">
<div class="blog-plug inline-plug vanilla-javascript-cta"><h2>调试代码总是一项单调乏味的任务。但是你越了解自己的错误，就越容易改正。</h2>
<p>LogRocket 让你以新的独特的方式理解这些错误。我们的前端监控解决方案跟踪用户与您的JavaScript前端的互动，让您能够准确找出导致错误的用户行为。</p>
<p>LogRocket记录控制台日志、页面加载时间、堆栈跟踪、慢速网络请求/响应(带有标题+正文)、浏览器元数据和自定义日志。理解您的JavaScript代码的影响从来没有这么简单过！</p>
<a href="https://lp.logrocket.com/blg/javascript-signup" class="signup" target="_blank" rel="noopener noreferrer"><img class="alignnone size-full wp-image-46 jetpack-lazy-image" src="../Images/cbfed9be3defcb505e662574769a7636.png" alt="LogRocket Dashboard Free Trial Banner" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2020/06/reproduce-javascript-errors.gif?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/06/reproduce-javascript-errors.gif"/><noscript><img data-lazy-fallback="1" class="alignnone size-full wp-image-46" src="../Images/cbfed9be3defcb505e662574769a7636.png" alt="LogRocket Dashboard Free Trial Banner" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/06/reproduce-javascript-errors.gif"/></noscript></a>
<p>.</p>
<a class="signup" href="https://lp.logrocket.com/blg/javascript-signup" target="_blank" rel="noopener noreferrer">Try it for free</a><p>.</p></div>


</div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
<html>
<head>
<title>Server-side rendering in Vue.js - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>Vue.js - LogRocket博客中的服务器端渲染</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/server-side-rendering-in-vue-js-cf9a9587b92b/#0001-01-01">https://blog.logrocket.com/server-side-rendering-in-vue-js-cf9a9587b92b/#0001-01-01</a></blockquote><div><article class="article-post">
<figure><img decoding="async" src="../Images/97ecae5141f8547562c38e0930a3bd17.png" data-height="720" data-width="1280" data-lazy-src="https://storage.googleapis.com/blog-images-backup/1*wFL3csJ96lQpY0IVT9SE3w.jpeg?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" class=" jetpack-lazy-image" data-original-src="https://storage.googleapis.com/blog-images-backup/1*wFL3csJ96lQpY0IVT9SE3w.jpeg"/><noscript><img data-lazy-fallback="1" decoding="async" src="../Images/97ecae5141f8547562c38e0930a3bd17.png" data-height="720" data-width="1280" data-original-src="https://storage.googleapis.com/blog-images-backup/1*wFL3csJ96lQpY0IVT9SE3w.jpeg"/></noscript></figure>
<h3>介绍</h3>
<p>Vue.js是使用起来最简单的JavaScript框架之一，事实上，我称之为轻量级冠军。一旦熟悉了JavaScript的基础知识，就很容易学会Vue.js并开始构建丰富的web应用程序。</p>
<p>但使用任何JavaScript框架的一个缺点是，在浏览器执行应用程序的JavaScript包之前，页面是不可见的。</p>
<p>例如，如果你看一下下面的代码，当你加载一个Vue.js应用程序时，你会发现你看到的只有<code/>元素。在Vue.js JavaScript代码运行之前，不会填充内容。</p>
<pre id="76f6" class="graf graf--pre graf-after--p">&lt;html&gt;
  &lt;head&gt; … &lt;/head&gt;
  &lt;body&gt;
    <strong class="markup--strong markup--pre-strong">&lt;div id=app&gt;&lt;/div&gt; </strong>
  &lt;/body&gt;
  &lt;script src=”dist/build.js”&gt;&lt;/script&gt;
&lt;/html&gt;</pre>
<p>这意味着用户必须等待更长时间才能看到任何东西。如果爬虫不能快速看到页面的内容，也会影响SEO。</p>
<p>为了解决这些问题，我们可以做<strong>服务器端渲染(SSR) </strong>，这是服务器在服务请求之前运行Vue.js代码<em>的地方，这样HTML一到达客户端就被填充到页面上。</em></p>
<p>在本教程中，我将向您展示如何在Vue.js应用程序中启动和运行SSR。</p>
<h3>服务器端渲染入门</h3>
<p>我们将从<a href="https://github.com/vuejs/vue-cli" target="_blank" rel="noopener noreferrer"> vue-cli的</a> <a href="https://github.com/vuejs-templates/webpack-simple" target="_blank" rel="noopener noreferrer"> webpack-simple </a>模板开始，为我们提供一个vue模板脚手架。</p>
<p>如果您没有安装<code>vue-cli</code>，您可以通过运行以下命令来安装:</p>
<pre>npm install -g vue-cli</pre>
<p>安装完<code>vue-cli</code>后，我们通过运行以下命令创建一个新项目:</p>
<pre>#Create the project 
vue init webpack-simple ssr-vue 
cd ssr-vue  
# Install dependencies
npm install</pre>
<p>我们还需要服务器端渲染所需的其他三个包，它们是:</p>
<ul>
<li><code>Express</code>:对于服务器</li>
<li><code>vue-server-renderer</code>:渲染捆绑包</li>
<li>我们将使用它来合并两个网络包包</li>
</ul>
<p>我们可以通过运行以下命令来安装它们:</p>
<pre>npm i express vue-server-renderer webpack-merge</pre>
<p>现在我们已经准备好为SSR配置我们的Vue应用程序</p>
<p>接下来，我们需要在<code>src</code>文件夹中创建一个名为<code>server.js</code>的文件，并将以下内容粘贴到其中:</p>
<blockquote class="embedly-card" data-card-controls="1" data-card-align="center" data-card-theme="light">

<p>使用JSFiddle代码编辑器在线测试您的JavaScript、CSS、HTML或CoffeeScript。</p>
</blockquote>
<p/>
<figure/>
<p>在上面的代码块中，我们注意到该代码与<code>src/main.js</code>中的代码非常相似。唯一不同的是，在这里，我们添加了上下文，然后返回一个承诺。</p>
<p>这是因为这是我们希望webpack为服务器运行和返回预渲染调用而准备的脚本。</p>
<h3>创建webpack服务器配置</h3>
<p>接下来，我们需要配置webpack来准备和编译我们的Vue应用程序，以便它可以被服务器执行。在最后一步中，我们已经创建了<code>server.js</code>文件。在这一步中，我们将配置webpack来编译文件及其依赖项，同时返回一个可执行包。</p>
<p>让我们在根文件夹中创建一个名为<code>webpack.server.config.js</code>的新文件，并添加:</p>
<blockquote class="embedly-card" data-card-controls="1" data-card-align="center" data-card-theme="light">

<p>使用JSFiddle代码编辑器在线测试您的JavaScript、CSS、HTML或CoffeeScript。</p>
</blockquote>
<p/>
<figure/>
<p>这里我们已经定义了代码的入口路径，也定义了文件的输出应该存储在哪里。</p>
<p>接下来，我们还要求webpack对结果包进行压缩和丑化。</p>
<h3>更新我们的npm脚本</h3>
<p>我们已经创建了用于创建可执行服务器包的webpack配置。但是，我们需要指定一个命令，使npm能够运行这个webpack配置。</p>
<p>为此，让我们将<code>package.json</code>的脚本部分替换为:</p>
<pre>"scripts": {
        "dev": "cross-env NODE_ENV=development webpack-dev-server --open --hot",
        "build": "cross-env NODE_ENV=production webpack --progress --hide-modules",
        "build-server": "cross-env NODE_ENV=production webpack --config webpack.server.config.js --progress --hide-modules"
    },</pre>
<p>在上面的代码中，我们会注意到添加了一个名为<code>build-server</code>的额外命令。这个命令将通过使用<code>webpack.server.config.js</code>文件调用webpack来构建我们的可执行服务器包。</p>
<p>现在，让我们通过运行以下命令来构建我们的普通包和服务器包:</p>
<pre>//build client/browser javascript bundle
npm run build
//build executable server bundle 
npm run build-server</pre>
<h3>创建服务器入口点</h3>
<p>对于服务器，我们将使用<code>Node js</code>。这解释了为什么我们之前安装了Express。</p><div class="code-block code-block-54">
<hr/>
<h3>更多来自LogRocket的精彩文章:</h3>

<hr/></div>
<p>让我们在根文件夹中创建一个名为<code>entry.js</code>的文件，并复制以下内容:</p>
<blockquote class="embedly-card" data-card-controls="1" data-card-align="center" data-card-theme="light">

<p>使用JSFiddle代码编辑器在线测试您的JavaScript、CSS、HTML或CoffeeScript。</p>
</blockquote>
<p>在上面的代码中，我们有:</p>
<figure/>
<p>需要将成为应用程序框架的<code>Express</code>库</p>
<ul>
<li>需要<code>fs</code>库，我们将使用它来同步读取文件</li>
<li>需要<code>path</code>库，这在处理文件路径时会很有帮助。</li>
<li>使用<code>fs</code>库将<code>bundle</code>变量设置为我们的<code>server.js</code>文件(可执行服务器包)的流内容</li>
<li>使用将<code>rendered</code>变量设置为我们的服务器包的解析和呈现值。</li>
<li>将我们的index.html文件的内容流式传输到一个名为<code>index</code>的变量中。</li>
<li>将<code>Express</code>实例实例化为一个名为<code>app</code>的变量。</li>
<li>使用<code>/dist</code>路径作为静态文件路径，并将其设置为从<code>dist</code>文件夹提供服务</li>
<li>在通配符路径中，我们调用了<code>renderer.renderToString</code>函数，该函数将javascript执行为字符串，并返回结果输出。</li>
<li>我们现在已经用结果输出替换了<code/>的出现。</li>
<li>现在，如果我们启动我们的应用程序，并访问相应的URL，看起来什么都没有改变。</li>
</ul>
<p>但是，如果我们看一下我们的页面源代码，我们会发现我们生成的HTML是:</p>
<p>使用JSFiddle代码编辑器在线测试您的JavaScript、CSS、HTML或CoffeeScript。</p>
<blockquote class="embedly-card" data-card-controls="1" data-card-align="center" data-card-theme="light">

<p>Test your JavaScript, CSS, HTML or CoffeeScript online with JSFiddle code editor.</p>
</blockquote>
<p>我们在这里注意到元素<code>&lt;div id=app&gt;</code>现在已经用它需要的全部元素填充了它的全部<code>innerHTML</code>。这是更好的搜索引擎优化和网络爬虫解析。此外，它还消除了页面加载后的等待时间。</p>
<figure/>
<p>结论</p>
<h3>在这篇文章中，我们看到了如何在Vue.js应用程序中设置服务器端渲染，以及它为什么有用。如果您想阅读上面显示的完整代码示例，您可以查看这个包含整个项目的GitHub资源库。</h3>
<p>此时您不能执行该操作。您已使用另一个标签页或窗口登录。您已在另一个标签页或窗口中注销。重新加载以刷新您的会话。重新加载以刷新您的会话。</p>
<blockquote class="embedly-card" data-card-controls="1" data-card-align="center" data-card-theme="light">

<p>You can’t perform that action at this time. You signed in with another tab or window. You signed out in another tab or window. Reload to refresh your session. Reload to refresh your session.</p>
</blockquote>
<p>像用户一样体验您的Vue应用</p><div class="code-block code-block-20">
<div class="blog-plug inline-plug vue-inline"><h2>调试Vue.js应用程序可能会很困难，尤其是当用户会话期间有几十个(如果不是几百个)突变时。如果您对监视和跟踪生产中所有用户的Vue突变感兴趣，</h2><p>. </p><a href="https://lp.logrocket.com/blg/vue-signup" target="_blank">try LogRocket</a><p>LogRocket 就像是网络和移动应用程序的DVR，记录你的Vue应用程序中发生的一切，包括网络请求、JavaScript错误、性能问题等等。您可以汇总并报告问题发生时应用程序的状态，而不是猜测问题发生的原因。</p><a class="signup" href="https://lp.logrocket.com/blg/vue-signup" target="_blank" rel="noopener noreferrer"><img class="alignnone size-full wp-image-46 jetpack-lazy-image" src="../Images/0d269845910c723dd7df26adab9289cb.png" alt="LogRocket Dashboard Free Trial Banner" data-lazy-src="https://files.readme.io/00591d0-687474703a2f2f692e696d6775722e636f6d2f6a3049327856572e706e67.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://files.readme.io/00591d0-687474703a2f2f692e696d6775722e636f6d2f6a3049327856572e706e67.png"/><noscript><img data-lazy-fallback="1" class="alignnone size-full wp-image-46" src="../Images/0d269845910c723dd7df26adab9289cb.png" alt="LogRocket Dashboard Free Trial Banner" data-original-src="https://files.readme.io/00591d0-687474703a2f2f692e696d6775722e636f6d2f6a3049327856572e706e67.png"/></noscript></a><a href="https://lp.logrocket.com/blg/vue-signup" target="_blank" rel="noopener noreferrer">https://logrocket.com/signup/</a><p>LogRocket Vuex插件将Vuex突变记录到LogRocket控制台，为您提供导致错误的环境，以及出现问题时应用程序的状态。</p><p>现代化您调试Vue应用的方式- <a class="signup" href="https://lp.logrocket.com/blg/vue-signup" target="_blank" rel="noopener noreferrer">开始免费监控</a>。</p><p>Modernize how you debug your Vue apps - <a class="signup" href="https://lp.logrocket.com/blg/vue-signup" target="_blank" rel="noopener noreferrer">Start monitoring for free</a>.</p></div>


</div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
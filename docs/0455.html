<html>
<head>
<title>How to implement drag and drop in React with React DnD - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>如何在React中实现拖放操作</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/drag-and-drop-react-dnd/#0001-01-01">https://blog.logrocket.com/drag-and-drop-react-dnd/#0001-01-01</a></blockquote><div><article class="article-post">
<div class="cro31">
<p>编者按:本教程最后一次更新是在2022年3月17日，以反映React DnD的更新。</p>
<p><a href="https://developer.mozilla.org/en-US/docs/Web/API/HTML_Drag_and_Drop_API">拖放API </a>为HTML带来了可拖动的元素，使开发人员能够构建包含丰富UI元素的应用程序，这些元素可以从一个地方拖动到另一个地方。拖放API是大多数现代应用程序不可或缺的一部分，它在不包含UX的情况下提供了丰富的UI。</p>
<p>React中最常见的拖放用例包括上传文件、在多个列表之间移动项目以及重新排列图像和资源。在本教程中，我们将重点介绍在React中实现拖放的几种不同的工具和用例。作为演示，我们将基于<a href="https://drag-drop-logrocket.netlify.app/">创建一个简单的应用程序。</a></p>
<p>你可以通过<a href="https://github.com/learnwithparam/logrocket-drag-and-drop">访问这个项目的完整代码库</a>和<a href="https://drag-drop-logrocket.netlify.com/">查看演示</a>来跟随这个教程。我们开始吧！</p>
<h3>目录</h3>

<h2>如何在React中实现拖放</h2>
<p>对于我们的示例，我们将构建一个简单的应用程序，使用户能够通过将图像文件放到浏览器中来上传图像文件，以网格的形式显示这些图像的预览，并对图像进行重新排序。</p>
<p>首先，我们将使用Create React App引导React应用程序:</p>
<pre class="“language-react">npx create-react-app logrocket-drag-and-drop
cd logrocket-drag-and-drop
yarn start
</pre>
<p>如果您使用的是npm，只需将<code>yarn start</code>替换为<code>npm start</code>。</p>
<p>如果你更喜欢视觉教程，看看下面的react-beautiful-dnd演练:</p>
<p><span class="embed-youtube"> <iframe loading="lazy" class="youtube-player" src="https://www.youtube.com/embed/Vqa9NMzF3wc?version=3&amp;rel=1&amp;showsearch=0&amp;showinfo=1&amp;iv_load_policy=1&amp;fs=1&amp;hl=en-US&amp;autohide=2&amp;wmode=transparent" allowfullscreen="true" sandbox="allow-scripts allow-same-origin allow-popups allow-presentation">视频</iframe> </span></p>
</div>
<h2 id="uploading-files-drag-and-drop-react">在React中使用拖放上传文件</h2>
<p>我们不会通过自己创建所有的逻辑和组件来重新发明轮子。相反，我们将使用一些最常用的React拖放库，从<a href="https://blog.logrocket.com/create-a-drag-and-drop-component-with-react-dropzone/#createthedropzonecomponent"> react-dropzone </a>开始。</p>
<p>在撰写本文时，GitHub 上有近<a href="https://github.com/react-dropzone/react-dropzone"> 8，000颗星星，react-dropzone是一个非常强大的库，可以帮助您在react中创建自定义组件，并通过</a><a href="https://blog.logrocket.com/frustrations-with-react-hooks/"> React Hooks </a>支持进行更新。要安装react-dropzone，请运行以下命令之一:</p>
<pre class="“language-bash">yarn add react-dropzone
#or
npm install react-dropzone
</pre>
<p>接下来，创建一个名为<code>Dropzone.js</code>的新文件，它负责将一个简单的内容区域变成一个dropzone区域，您可以在其中放置文件。</p>
<h3 id="react-dropzone">什么是<code>react-dropzone</code>？</h3>
<p><code>react-dropzone</code>隐藏文件输入，显示漂亮的自定义dropzone区域。当我们放下文件时，<code>react-dropzone</code>使用HTML <code>onDrag</code>事件，并根据文件是否被放入dropzone区域来从事件中捕获文件。</p>
<p>如果我们点击该区域，<code>react-dropzone</code>库使用React <code>ref</code>通过隐藏输入启动文件选择对话框，允许我们选择和上传文件。让我们创建我们的<code>Dropzone</code>组件:</p>
<pre class="“language-javascript">/* 
  filename: Dropzone.js 
*/

import React from "react";
// Import the useDropzone hooks from react-dropzone
import { useDropzone } from "react-dropzone";

const Dropzone = ({ onDrop, accept }) =&gt; {
  // Initializing useDropzone hooks with options
  const { getRootProps, getInputProps, isDragActive } = useDropzone({
    onDrop,
    accept
  });

  /* 
    useDropzone hooks exposes two functions called getRootProps and getInputProps
    and also exposes isDragActive boolean
  */

  return (
    &lt;div className="dropzone-div" {...getRootProps()}&gt;
      &lt;input className="dropzone-input" {...getInputProps()} /&gt;
      &lt;div className="text-center"&gt;
        {isDragActive ? (
          &lt;p className="dropzone-content"&gt;Release to drop the files here&lt;/p&gt;
        ) : (
          &lt;p className="dropzone-content"&gt;
            Drag 'n' drop some files here, or click to select files
          &lt;/p&gt;
        )}
      &lt;/div&gt;
    &lt;/div&gt;
  );
};

export default Dropzone;
</pre>
<p>组件很简单，但是让我们仔细看看代码。<code>useDropzone</code>为我们公开了几个方法和变量来创建自定义的dropzone区域。对于我们的项目，我们主要对三个属性感兴趣。</p>
<p>例如，<code>getRootProps</code>是基于dropzone区域的父元素设置的。这个元素决定了dropzone区域的宽度和高度。<code>getInputProps</code>是传递给输入元素的道具。它使我们能够支持点击事件和拖动事件来获取文件。</p>
<p>所有与我们传递给<code>useDropzone</code>的文件相关的选项都被设置到这个输入元素中。比如想只支持单个文件，可以通过<code>multiple: false</code>。它将自动要求<code>dropzone</code>只允许一个文件被接受。</p>
<p>如果文件被拖动到dropzone区域上方，则设置<code>isDragActive</code>,这对于基于该变量进行样式设置非常有用。</p>
<p>下面的例子演示了如何根据<code>isDragActive</code>值设置样式/类名:</p>
<pre class="“language-react">const getClassName = (className, isActive) =&gt; {
  if (!isActive) return className;
  return `${className} ${className}-active`;
};

...
&lt;div className={getClassName("dropzone", isDragActive)} {...getRootProps()}&gt;
...
</pre>
<p>在我们的拖放示例中，我们只使用了两个道具，但是，库支持很多道具来根据您的需要定制dropzone区域。</p>
<p>为了只接受图像文件，我们使用了<a href="https://github.com/react-dropzone/attr-accept"> <code>accept</code>道具</a>。现在，我们的<code>App.js</code>应该看起来像下面的代码:</p>
<pre class="“language-javascript">/*
filename: App.js 
*/

import React, { useCallback } from "react";
// Import the dropzone component
import Dropzone from "./Dropzone";

import "./App.css";

function App() {
  // onDrop function  
  const onDrop = useCallback(acceptedFiles =&gt; {
    // this callback will be called after files get dropped, we will get the acceptedFiles. If you want, you can even access the rejected files too
    console.log(acceptedFiles);
  }, []);

  // We pass onDrop function and accept prop to the component. It will be used as initial params for useDropzone hook
  return (
    &lt;main className="App"&gt;
      &lt;h1 className="text-center"&gt;Drag and Drop Example&lt;/h1&gt;
      &lt;Dropzone onDrop={onDrop} accept={"image/*"} /&gt;
    &lt;/main&gt;
  );
}

export default App;
</pre>
<p><img data-attachment-id="96545" data-permalink="https://blog.logrocket.com/appjs-file-accept-props/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/03/appjs-file-accept-props.png" data-orig-size="730,393" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="appjs-file-accept-props" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/03/appjs-file-accept-props-300x162.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/03/appjs-file-accept-props.png" decoding="async" class="aligncenter wp-image-96545 size-full jetpack-lazy-image" src="../Images/6092890a887130d9a4f5a9d0b22adfff.png" alt="Appjs File Accept Props" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2022/03/appjs-file-accept-props.png 730w, https://blog.logrocket.com/wp-content/uploads/2022/03/appjs-file-accept-props-300x162.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2022/03/appjs-file-accept-props.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/03/appjs-file-accept-props.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="96545" data-permalink="https://blog.logrocket.com/appjs-file-accept-props/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/03/appjs-file-accept-props.png" data-orig-size="730,393" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="appjs-file-accept-props" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/03/appjs-file-accept-props-300x162.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/03/appjs-file-accept-props.png" decoding="async" loading="lazy" class="aligncenter wp-image-96545 size-full" src="../Images/6092890a887130d9a4f5a9d0b22adfff.png" alt="Appjs File Accept Props" srcset="https://blog.logrocket.com/wp-content/uploads/2022/03/appjs-file-accept-props.png 730w, https://blog.logrocket.com/wp-content/uploads/2022/03/appjs-file-accept-props-300x162.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/03/appjs-file-accept-props.png"/></noscript>
<p>我们在主页面中添加了<code>dropzone</code>组件。现在，如果你放下文件，它会控制放下的图像文件。</p>
<p>请记住，上面的图像对dropzone div应用了一些样式，如填充和边框。你的可能会出现不同，直到你提供一些风格。在<code>index.css</code>中添加以下代码应该会给你一个类似的外观:</p>
<pre class="“language-css">body {
  text-align: center;
}
.dropzone-div {
  text-align: center;
  padding: 20px;
  border: 3px purple dashed;
  width: 60%;
  margin: auto;
}
</pre>
<p><code>acceptedFiles</code>是一个由<code>File</code>值组成的数组。您可以读取文件或将其发送到服务器并上传。无论你想做什么流程，都可以在那里完成。甚至当你点击区域并上传时，同样的<code>onDrop</code>回调被调用。</p>
<p>属性接受mime类型。它支持所有标准的mime类型和匹配模式。例如，如果你想只允许pdf，那么<code>accept={'application/pdf'}</code>。如果你既想要图片又想要pdf，它支持<code>accept={'application/pdf, image/*'}</code>。</p>
<p><code>onDrop</code>函数包含在<code>useCallback</code>中。截至目前，我们没有进行任何繁重的计算，也没有将文件发送到服务器。我们只是安慰一下<code>acceptedFiles</code>。稍后，我们将读取文件并设置在浏览器中显示图像的状态。建议对昂贵的函数使用<code>useCallback</code>以避免不必要的重新渲染，然而，在我们的例子中，它是完全可选的。</p>
<p>让我们读取图像文件并将它们添加到<code>App.js</code>中的一个状态。另外，一定要安装带有<code>yarn add cuid</code>或<code>npm install cuid</code>的<code>cuid</code>库:</p>
<pre class="“language-javascript">/*
filename: App.js
*/
import React, { useCallback, useState } from "react";
// cuid is a simple library to generate unique IDs
import cuid from "cuid";

function App() {
  // Create a state called images using useState hooks and pass the initial value as empty array
  const [images, setImages] = useState([]);

  const onDrop = useCallback(acceptedFiles =&gt; {
    // Loop through accepted files
    acceptedFiles.map(file =&gt; {
      // Initialize FileReader browser API
      const reader = new FileReader();
      // onload callback gets called after the reader reads the file data
      reader.onload = function(e) {
        // add the image into the state. Since FileReader reading process is asynchronous, its better to get the latest snapshot state (i.e., prevState) and update it. 
        setImages(prevState =&gt; [
          ...prevState,
          { id: cuid(), src: e.target.result }
        ]);
      };
      // Read the file as Data URL (since we accept only images)
      reader.readAsDataURL(file);
      return file;
    });
  }, []);

  ...
}
</pre>
<p>我们的<code>images</code>状态的数据结构如下:</p>
<pre class="“language-react">const images = [
  {
    id: 'abcd123',
    src: 'data:image/png;dkjds...',
  },
  {
    id: 'zxy123456',
    src: 'data:image/png;sldklskd...',
  }
]
</pre>
<h2 id="display-image-preview">显示图像预览</h2>
<p>为了在网格布局中显示图像预览，我们将创建另一个名为<code>ImageList</code>的组件:</p>
<pre class="“language-react">import React from "react";

// Rendering individual images
const Image = ({ image }) =&gt; {
  return (
    &lt;div className="file-item"&gt;
      &lt;img alt={`img - ${image.id}`} src={image.src} className="file-img" /&gt;
    &lt;/div&gt;
  );
};

// ImageList Component
const ImageList = ({ images }) =&gt; {

  // render each image by calling Image component
  const renderImage = (image, index) =&gt; {
    return (
      &lt;Image
        image={image}
        key={`${image.id}-image`}
      /&gt;
    );
  };

  // Return the list of files
  return &lt;section className="file-list"&gt;{images.map(renderImage)}&lt;/section&gt;;
};

export default ImageList;
</pre>
<p>现在，我们可以将这个<code>ImageList</code>组件添加到<code>App.js</code>来显示图像的预览:</p>
<pre class="“language-javascript">function App() {
  ...

  // Pass the images state to the ImageList component and the component will render the images
  return (
    &lt;main className="App"&gt;
      &lt;h1 className="text-center"&gt;Drag and Drop Example&lt;/h1&gt;
      &lt;Dropzone onDrop={onDrop} accept={"image/*"} /&gt;
      &lt;ImageList images={images} /&gt;
    &lt;/main&gt;
  );
}
</pre>
<p>至此，我们已经成功完成了应用程序的一半。我们现在可以拖放来查看图像的预览:</p>
<p><img data-attachment-id="96547" data-permalink="https://blog.logrocket.com/drag-drop-image-preview/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/03/drag-drop-image-preview.png" data-orig-size="730,550" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="drag-drop-image-preview" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/03/drag-drop-image-preview-300x226.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/03/drag-drop-image-preview.png" decoding="async" class="aligncenter wp-image-96547 size-full jetpack-lazy-image" src="../Images/0f2a4b3678371baec0612536ed311b30.png" alt="Drag Drop Image Preview" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2022/03/drag-drop-image-preview.png 730w, https://blog.logrocket.com/wp-content/uploads/2022/03/drag-drop-image-preview-300x226.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2022/03/drag-drop-image-preview.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/03/drag-drop-image-preview.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="96547" data-permalink="https://blog.logrocket.com/drag-drop-image-preview/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/03/drag-drop-image-preview.png" data-orig-size="730,550" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="drag-drop-image-preview" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/03/drag-drop-image-preview-300x226.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/03/drag-drop-image-preview.png" decoding="async" loading="lazy" class="aligncenter wp-image-96547 size-full" src="../Images/0f2a4b3678371baec0612536ed311b30.png" alt="Drag Drop Image Preview" srcset="https://blog.logrocket.com/wp-content/uploads/2022/03/drag-drop-image-preview.png 730w, https://blog.logrocket.com/wp-content/uploads/2022/03/drag-drop-image-preview-300x226.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/03/drag-drop-image-preview.png"/></noscript>
<h2 id="reorder-images-drag-drop">通过拖放重新排序图像</h2>
<p>接下来，我们将允许用户通过拖放来重新排序图像。但是首先，让我们快速回顾一下用于实现该功能的最流行的库，并根据您的项目需求引导您选择最好的库。</p>
<p>上面的图像已经应用了样式。使用将显示图像的容器上的flexbox来水平显示图像。在您的<code>index.css</code>中输入以下内容应该会给出大致相同的外观:</p>
<pre class="“language-css">.file-list {
  display: flex;
  flex-wrap: wrap;
  width: 65%;
  margin: 20px auto;
  padding: 10px;
  border: 3px dotted black;
}
.file-list img {
  height: 300px;
  width: 300px;
  object-fit: cover;
}
</pre>
<h2 id="react-drag-drop-libraries">React拖放库</h2>
<p>三个最流行的React拖放包是:</p>

<p>每个库在React开发人员中很受欢迎，并且有活跃的贡献者。让我们快速放大每个库，并分析其优缺点。</p>
<h2 id="react-beautiful-dnd">反应-美丽-dnd</h2>
<p><a href="https://blog.logrocket.com/adding-drag-and-drop-functionality-with-react-beautiful-dnd/"> react-beautiful-dnd是一个更高层次的抽象</a>,专门为列表而构建。它旨在提供一种自然、美观、易用的React拖放体验。</p>
<h3 id="react-beautiful-dnd-pros">反应-美丽-dnd优点</h3>
<p>react-beautiful-dnd非常适合一维布局和需要水平或垂直移动的拖放功能。例如，Trello布局可以使用react-beautiful-dnd开箱即用。</p>
<p>react-beautiful-dnd API轻而易举。该团队设法创建了一个真正令人愉快的开发人员体验，而没有增加代码库的复杂性</p>
<h3 id="react-beautiful-dnd-cons">反应-美丽-拒绝和反对</h3>
<p>react-beautiful-dnd对网格不起作用，因为你向各个方向移动元素。react-beautiful-dnd将无法同时计算x轴和y轴的位置。因此，当拖动网格上的元素时，你的内容会随机移动，直到你放下元素。</p><div class="code-block code-block-54">
<hr/>
<h3>更多来自LogRocket的精彩文章:</h3>

<hr/></div>
<h2 id="react-grid-layout">反应网格布局</h2>
<p><a href="https://github.com/react-grid-layout/react-grid-layout"> React-Grid-Layout </a>是专为React打造的网格布局系统。与Packery和Gridster等类似系统不同，React-Grid-Layout响应迅速，支持断点布局，断点布局可以由用户提供，也可以自动生成。它不需要jQuery。</p>
<h3 id="react-grid-layout-pros">反应网格布局优点</h3>
<p>React-Grid-Layout适用于需要拖放的复杂网格布局，如具有完全定制和调整大小的仪表板，即looker、数据可视化产品等。</p>
<p>对于大规模的应用需求来说，它的复杂性是值得的。</p>
<h3 id="react-grid-layout-cons">反应网格布局缺点</h3>
<p>在我看来，React-Grid-Layout提供了一个没有吸引力的API，还需要你自己进行大量的计算。布局结构必须通过React-Grid-Layout的组件API在UI中定义，这在您动态创建动态元素时引入了额外的复杂性。</p>
<h2 id="react-dnd">反应DnD</h2>
<p>React DnD是一套React工具，旨在帮助你构建高级拖放界面，同时保持组件的解耦。它实现了类似于Trello和Storify等应用程序的功能，在这些应用程序中，数据在应用程序的各个部分之间传输，组件会改变它们的外观和应用程序状态以响应拖放事件。</p>
<h3 id="react-dnd-pros">反应DnD专业人士</h3>
<p>React DnD适用于几乎所有的用例，比如网格、一维列表等。此外，React DnD有一个非常强大的API，可以在React中添加任何自定义拖放功能。</p>
<h3 id="react-dnd-cons">反应DnD的缺点</h3>
<p>对于小例子来说，API非常容易上手。然而，添加复杂的定制可能非常棘手。学习曲线比react-beautiful-dnd更高更复杂。此外，一些黑客需要支持网络和触摸设备</p>
<p>对于我们的用例，我选择使用React DnD。如果布局只包含一个项目列表，我会选择react-beautiful-dnd，但是在我们的例子中，我们有一个图像网格。因此，实现拖放的最简单的API是React DnD。</p>
<h2 id="exploring-react-dnd">探索反应DnD</h2>
<p>在我们深入研究拖放代码之前，我们需要首先了解React DnD是如何工作的。反应DnD可以使任何元素拖放。为了实现这一点，DnD有几个假设:</p>
<ul>
<li>反应DnD需要所有可丢弃物品的参考</li>
<li>React DnD需要所有可拖动项目的参考</li>
</ul>
<p>所有可拖放的元素都需要包含在React DnD的上下文提供程序中，该提供程序用于初始化和管理内部状态。</p>
<p>我们不需要太担心它如何管理状态；React DnD包含了漂亮而简单的API来公开这些状态，使我们能够计算和更新我们的本地状态。</p>
<p>要安装React DnD，请运行以下任一命令:</p>
<pre>yarn add react-dnd react-dnd-html5-backend immutability-helper
//or
npm install react-dnd react-dnd-html5-backend immutability-helper
</pre>
<p>请记住，在您完成所有步骤之前，这个示例不会起作用。查看最终产品<a href="https://github.com/learnwithparam/logrocket-drag-and-drop">预反应-dnd v14 </a>和<a href="https://github.com/AlexMercedCoder/logrocket-reactdnd-v14plus">后反应-dnd v14 </a>的报告，以供参考。</p>
<p>首先，我们将把我们的<code>ImageList</code>组件封装在DnD上下文提供者中:</p>
<pre>/* 
  filename: App.js 
*/

import { DndProvider } from "react-dnd";
import {HTML5Backend} from "react-dnd-html5-backend";

function App() {
  ...
  return (
    &lt;main className="App"&gt;
      ...
      &lt;DndProvider backend={HTML5Backend}&gt;
        &lt;ImageList images={images} moveImage={moveImage}/&gt;
      &amp;lt;/DndProvider&gt;
    &lt;/main&gt;
  );
}
</pre>
<p>只需导入<code>DNDProvider</code>并用<code>backend</code>道具初始化它。正如我前面提到的，这个变量帮助我们选择使用哪个API进行拖放。</p>
<ul>
<li><a href="https://blog.logrocket.com/html-5-drag-and-drop-api-a-tutorial/"> HTML5拖放API </a>仅在网络上受支持，在触摸设备上不受支持</li>
<li>触摸拖放API在触摸设备上受支持</li>
</ul>
<p>目前我们使用HTML5 API入门。功能完成后，我们将编写一个简单的实用程序来为触摸设备提供基本支持。</p>
<p>现在，我们需要添加可拖动和可放下的项目。在我们的应用程序中，可拖动和可放下的项目是相同的。我们将拖动<code>Image</code>组件，并将其放到另一个<code>Image</code>组件上，使我们的工作变得简单一些。要实现这一点，请使用下面的代码:</p>
<pre>import React, { useRef } from "react";
// import useDrag and useDrop hooks from react-dnd
import { useDrag, useDrop } from "react-dnd";

const type = "Image"; // Need to pass which type element can be draggable, its a simple string or Symbol. This is like an Unique ID so that the library know what type of element is dragged or dropped on.

const Image = ({ image, index }) =&gt; {
  const ref = useRef(null); // Initialize the reference

  // useDrop hook is responsible for handling whether any item gets hovered or dropped on the element
  const [, drop] = useDrop({
    // Accept will make sure only these element type can be droppable on this element
    accept: type,
    hover(item) {
      ...
    }
  });

  // useDrag will be responsible for making an element draggable. It also expose, isDragging method to add any styles while dragging
  const [{ isDragging }, drag] = useDrag(() =&gt; ({
    // what type of item this to determine if a drop target accepts it
    type: type,
    // data of the item to be available to the drop methods
    item: { id: image.id, index },
    // method to collect additional data for drop handling like whether is currently being dragged
    collect: (monitor) =&gt; {
      return {
        isDragging: monitor.isDragging(),
      };
    },
  }));

  /* 
    Initialize drag and drop into the element using its reference.
    Here we initialize both drag and drop on the same element (i.e., Image component)
  */
  drag(drop(ref));

  // Add the reference to the element
  return (
    &lt;div
      ref={ref}
      style={{ opacity: isDragging ? 0 : 1 }}
      className="file-item"
    &gt;
      &lt;img alt={`img - ${image.id}`} src={image.src} className="file-img" /&gt;
    &lt;/div&gt;
  );
};

const ImageList = ({ images, moveImage }) =&gt; {
  const renderImage = (image, index) =&gt; {
    return image ? (
      &lt;Image
        image={image}
        index={index}
        key={`${image.id}-image`}
        moveImage={moveImage}
      /&gt;
    ): null;
  };
  return &lt;section className="file-list"&gt;{images.map(renderImage)}&lt;/section&gt;;

export default ImageList;
</pre>
<p>现在，我们的图像已经可以拖动了。但是，如果我们放下它，图像会回到原来的位置，因为<code>useDrag</code>和<code>useDrop</code>会处理它，直到我们放下它。除非我们改变我们的局部状态，否则它会再次回到原来的位置。</p>
<p>要更新本地状态，我们需要知道被拖动的元素和被悬停的元素，即被拖动的元素悬停在哪个元素上。<code>useDrag</code>通过<code>hover</code>方法公开这些信息:</p>
<pre>const [, drop] = useDrop({
    // accept receives a definition of what must be the type of the dragged item to be droppable
    accept: type,
    // This method is called when we hover over an element while dragging
    hover(item) { // item is the dragged element
      if (!ref.current) {
        return;
      }
      const dragIndex = item.index;
      // current element where the dragged element is hovered on
      const hoverIndex = index;
      // If the dragged element is hovered in the same place, then do nothing
      if (dragIndex === hoverIndex) { 
        return;
      }
      // If it is dragged around other elements, then move the image and set the state with position changes
      moveImage(dragIndex, hoverIndex);
      /*
        Update the index for dragged item directly to avoid flickering
        when the image was half dragged into the next
      */
      item.index = hoverIndex;
    }
});
</pre>
<p>每当一个元素被拖动并停留在这个元素上时，就会触发<code>hover</code>方法。通过这种方式，当我们开始拖动一个元素时，我们得到了该元素的索引以及我们所悬停的元素。我们将通过这个<code>dragIndex</code>和<code>hoverIndex</code>来更新我们图像的状态。</p>
<p>此时，您可能想知道为什么我们需要在悬停时更新状态？为什么不一边滴一边更新呢？可以在删除时更新状态。<code>drag-and-drop</code>将工作并重新排列位置，但UX不会是好的。</p>
<p>例如，如果你拖动一个图像到另一个图像上，我们立即改变它的位置，那么这会给拖动它的用户很好的反馈。否则，他们可能不知道拖动功能是否有效，直到他们将图像放到某个位置。</p>
<p>因此，我们在每次悬停时更新状态。当悬停在另一个图像上时，我们设置状态并改变位置，用户将看到一个漂亮的动画。你可以在我们的演示页面查看。</p>
<p>到目前为止，我们只是将更新状态的代码显示为<code>moveImage</code>。让我们来看看实现:</p>
<pre>/*
  filename: App.js
*/

import update from "immutability-helper";

...

const moveImage = (dragIndex, hoverIndex) =&gt; {
    // Get the dragged element
    const draggedImage = images[dragIndex];
    /*
      - copy the dragged image before hovered element (i.e., [hoverIndex, 0, draggedImage])
      - remove the previous reference of dragged element (i.e., [dragIndex, 1])
      - here we are using this update helper method from immutability-helper package
    */
    setImages(
      update(images, {
        $splice: [[dragIndex, 1], [hoverIndex, 0, draggedImage]]
      })
    );
};

// We will pass this function to ImageList and then to Image -&gt; Quite a bit of props drilling, the code can be refactored and place all the state management in ImageList itself to avoid props drilling. It's an exercise for you :)
</pre>
<p>现在，我们的应用程序在支持HTML5 <code>onDrag</code>事件的设备上功能齐全。不幸的是，它在触摸设备上不起作用。</p>
<p>正如我之前说过的，我们可以使用实用函数来支持触摸设备。这不是最好的解决方案，但仍然有效。在触控设备上拖动的体验不会很棒；它只是简单地更新，但你不会觉得你在拖拉。你也可以把它弄干净:</p>
<pre>import HTML5Backend from "react-dnd-html5-backend";
import TouchBackend from "react-dnd-touch-backend";

// simple way to check whether the device support touch (it doesn't check all fallback, it supports only modern browsers)
const isTouchDevice = () =&gt; {
  if ("ontouchstart" in window) {
    return true;
  }
  return false;
};

// Assigning backend based on touch support on the device
const backendForDND = isTouchDevice() ? TouchBackend : HTML5Backend;

...
return (
  ...
  &lt;DndProvider backend={backendForDND}&gt;
    &lt;ImageList images={images} moveImage={moveImage} /&gt;
  &lt;/DndProvider&gt;
)
...
</pre>
<h2 id="drag-and-drop-react-native">对本机拖放做出反应</h2>
<p>有关如何在React Native中实现拖放的更多信息，请查看下面的视频教程:</p>
<p><iframe loading="lazy" src="https://www.youtube.com/embed/tsM3N_7bNcE" frameborder="0" allowfullscreen="allowfullscreen">视频</iframe></p>
<h2 id="conclusion">结论</h2>
<p>我们已经成功地构建了一个小而强大的演示程序，用于拖放文件、上传文件和重新排序这些文件。</p>
<p>我们只是触及了React在拖放功能方面的皮毛。我们可以使用拖放库来构建非常详尽的特性。我们讨论了撰写本文时可用的一些最好的库。</p>
<p>我希望它能帮助您更快、更自信地构建下一个拖放功能。请务必在评论中告诉我你用它做了什么。</p><div class="code-block code-block-17">
<div class="blog-plug inline-plug react-plug" vwo-el-id="26283398190">
<h2 vwo-el-id="41600691720">使用LogRocket消除传统反应错误报告的噪音</h2>
<a href="https://lp.logrocket.com/blg/react-signup-issue-free" target="_blank" vwo-el-id="19356441070">LogRocket
</a><p>是一款React analytics解决方案，可保护您免受数百个误报错误警报的影响，只针对少数真正重要的项目。LogRocket告诉您React应用程序中实际影响用户的最具影响力的bug和UX问题。</p><a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="19356441380">
<img class="first-react-image alignnone size-full wp-image-46 jetpack-lazy-image jetpack-lazy-image--handled" src="../Images/f300c244a1a1cf916df8b4cb02bec6c6.png" vwo-el-id="18272717540" data-lazy-loaded="1" data-original-src="https://files.readme.io/27c94e7-Image_2017-06-05_at_9.46.04_PM.png"/>
</a>
<a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="19356441690">
<img class="second-react-image alignnone size-full wp-image-46 jetpack-lazy-image jetpack-lazy-image--handled" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" vwo-el-id="30720362350" data-lazy-loaded="1" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/>
</a>
<a href="https://lp.logrocket.com/blg/react-signup-issue-free" target="_blank" rel="noopener noreferrer" vwo-el-id="35866400580">LogRocket
</a><p>自动聚合客户端错误、反应错误边界、还原状态、缓慢的组件加载时间、JS异常、前端性能指标和用户交互。然后，LogRocket使用机器学习来通知您影响大多数用户的最具影响力的问题，并提供您修复它所需的上下文。</p><p vwo-el-id="28675661060">关注重要的React bug—<a class="signup" href="https://lp.logrocket.com/blg/react-signup-issue-free" target="_blank" rel="noopener noreferrer" vwo-el-id="40093418840">今天就试试LogRocket】。</a></p>
</div></div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
<html>
<head>
<title>A comprehensive guide to data fetching in React - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>React - LogRocket博客中的数据获取综合指南</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/comprehensive-guide-data-fetching-react/#0001-01-01">https://blog.logrocket.com/comprehensive-guide-data-fetching-react/#0001-01-01</a></blockquote><div><article class="article-post">
<p><strong> <em>编者按:</em> </strong> <em>本React数据抓取教程于2022年8月9日更新，增加了关于什么是数据抓取、如何显示抓取的数据、如何通过缓存库抓取数据以及更新过时链接和代码演示的章节。</em></p>
<p>现代应用程序处理大量数据。React尤其擅长在分层组件视图中显示数据，但是组件如何获取数据呢？有许多方法去做这件事，每一种都有它自己的优点和缺点。</p>
<p>在本教程中，我们将关注React中的数据获取。我们将演示如何在React中获取数据，包括代码示例，并介绍一些方法来帮助您确定React项目的最佳数据获取方法。</p>
<p>我们将详细介绍以下内容:</p>

<h2 id="what-data-fetching-react">React中的数据获取是什么？</h2>
<p>现代的全栈应用包括两个主要模块:前端和后端。我们通常通过用React构建的应用前端来显示交互式UI元素。另一方面，后端保存并检索远程服务器计算机中的数据。</p>
<p>正因为如此，我们经常需要从后端获取数据并在前端显示。我们可以通过各种数据传输机制做到这一点，最流行的机制通常是RESTful接口、WebSockets、GraphQL接口、XML消息和gRPC实现。</p>
<p>如今，RESTful方法无疑是React应用程序最流行的数据传输机制之一。在本教程中，我们将主要关注基于RESTful的数据获取。</p>
<p>React RESTful数据获取流程很简单。在组件中，我们通常通过调用RESTful端点并让浏览器执行HTTP调用来请求网络客户端获取数据。一旦浏览器从RESTful服务器接收到特定端点的数据，我们就可以将这些数据转换成React组件或HTML元素，并将它们显示给用户。</p>
<p>让我们用一个实用的React app来理解数据抓取吧！</p>
<h2 id="setting-up-example-data-fetching-app">设置示例数据获取应用程序</h2>
<p>为了展示如何在React中获取数据，我们将使用从<a href="https://jsonplaceholder.typicode.com/users" target="_blank" rel="noopener"> JSONPlaceholder </a>获取用户的组件构建一个简单的React应用程序。所有组件呈现相同的数据，看起来也一样。我使用传统的<code>&lt;table&gt;</code> HTML元素来显示表格数据，以保持教程的简单性，并且只关注数据获取。您可以在React应用程序中使用任何首选的数据表组件。</p>
<p>下面是我们的示例应用程序的样子:</p>
<p><img data-attachment-id="129367" data-permalink="https://blog.logrocket.com/comprehensive-guide-data-fetching-react/attachment/example-app/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/12/example-app.png" data-orig-size="621,681" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="example-app" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/12/example-app-274x300.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/12/example-app.png" decoding="async" class="aligncenter size-full wp-image-129367 jetpack-lazy-image" src="../Images/667982bd99ba625f6f3bad7daac2e3c3.png" alt="Example App" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2020/12/example-app.png 621w, https://blog.logrocket.com/wp-content/uploads/2020/12/example-app-274x300.png 274w" data-lazy-sizes="(max-width: 621px) 100vw, 621px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2020/12/example-app.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/12/example-app.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="129367" data-permalink="https://blog.logrocket.com/comprehensive-guide-data-fetching-react/attachment/example-app/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/12/example-app.png" data-orig-size="621,681" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="example-app" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/12/example-app-274x300.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/12/example-app.png" decoding="async" loading="lazy" class="aligncenter size-full wp-image-129367" src="../Images/667982bd99ba625f6f3bad7daac2e3c3.png" alt="Example App" srcset="https://blog.logrocket.com/wp-content/uploads/2020/12/example-app.png 621w, https://blog.logrocket.com/wp-content/uploads/2020/12/example-app-274x300.png 274w" sizes="(max-width: 621px) 100vw, 621px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/12/example-app.png"/></noscript>
<p>首先，从<a href="https://github.com/codezri/react-data-patterns-demo" target="_blank" rel="noopener"> GitHub </a>下载或克隆预先开发好的样例app。使用以下命令安装依赖项:</p>
<pre class="language-bash hljs">npm install
# --- or ---
yarn install
</pre>
<p>我们不需要设置任何本地web API，因为我们使用远程<a href="https://jsonplaceholder.typicode.com/" target="_blank" rel="noopener"> JSONPlaceholder </a>服务作为数据源。照常运行React应用程序:</p>
<pre class="language-bash hljs">npm start
# --- or ---
yarn start
</pre>
<p>现在，您将看到预览截图中显示的数据表。</p>
<p>在深入研究数据获取实现的具体细节之前，让我们研究一下主要的<code>App</code>组件结构。主<code>App</code>组件只是一个功能组件。它呈现了各种数据模式组件，这些组件说明了每种数据获取方法:</p>
<pre class="language-javascript hljs">import React from 'react';
import UserTableAutonomous from './components/UserTableAutonomous';
import UserTableHOC from './components/UserTableHOC';
import UserTableReactHooks from './components/UserTableReactHooks';
import UserTableRenderProps from './components/UserTableRenderProps';
import SimpleUserTable from './components/SimpleUserTable';

import './App.css';

function App() {
    return (
        &lt;div className='App'&gt;
            &lt;h2&gt; User Table - Autonomous&lt;/h2&gt;
            &lt;UserTableAutonomous/&gt;
            &lt;h2&gt; User Table - Higher Order Component&lt;/h2&gt;
            &lt;UserTableHOC/&gt;
            &lt;h2&gt; User Table - Render Props&lt;/h2&gt;
            &lt;UserTableRenderProps children={SimpleUserTable}/&gt;
            &lt;h2&gt; User Table - React Hooks&lt;/h2&gt;
            &lt;UserTableReactHooks/&gt;
        &lt;/div&gt;
    );
}

export default App;
</pre>
<p>事不宜迟，让我们从React中的数据获取开始。</p>
<h2 id="overview-how-fetch-data-react">如何在React中提取数据概述</h2>
<p>如果您刚刚开始使用React，您可能只从事过简单的初级项目，不需要访问或处理数据。随着您开始React之旅并学习如何构建更复杂的项目，您的应用程序几乎肯定会需要这一功能。事实上，数据获取是几乎每个React应用程序的核心需求。</p>
<p>在React中获取数据有多种方式，包括使用内置的Fetch API、Axios等等。我们将详细讨论所有这些方法。您还可以从GraphQL后端获取高阶组件中的数据并呈现道具，等等。继续阅读，了解如何做到这一点。</p>
<h2 id="fetching-server-provided-data">获取服务器提供的数据</h2>
<p>这是为你的应用程序获取数据的传统方式。数据嵌入在从服务器发送的HTML中。如果需要新数据，需要手动刷新页面或定期刷新页面。还记得这个吗？</p>
<pre class="language-javascript hljs">&lt;meta http-equiv="refresh" content="30"&gt;
</pre>
<p>这与React应用程序并不特别相关，React应用程序有更动态、更细粒度的方式来更新自身，但这仍然是从服务器向浏览器获取数据的合法方式。许多遗留的web应用程序仍然在使用它，如果JavaScript被禁用或者您必须处理古老的浏览器，它甚至可能是最好的方法，因为非常简单明了。</p>
<h2 id="how-react-components-fetch-data">React组件如何获取数据</h2>
<p>React组件可以获取自己的数据。最大的问题是何时获取数据。有几个选项:</p>
<ul>
<li>从无数据开始，根据用户操作(如单击按钮)获取数据</li>
<li>加载一次数据</li>
<li>定期加载数据</li>
</ul>
<p>由于组件是完全自治的，没有其他组件可以告诉它是时候加载数据了。在这种情况下，我选择在<code>componentDidMount()</code>中第一次加载数据，并且还设置了一个计时器，该计时器将每五秒钟读取一次数据。</p>
<p>我们来看一下<code>UserTableAutonmous</code>组件，一片一片的解剖。这是一个标准的基于类的React组件。它的状态包括两个字段:一个初始化为<code>false</code>的布尔值<code>isFetching</code>，因为它还没有获取，以及一个空的用户列表(它想要获取的数据)。</p>
<pre class="language-javascript hljs">class UserTableAutonomous extends Component {
    constructor(props) {
        super(props);
        this.state = {
            isFetching: false,
            users: []
        };
    }
</pre>
<p>首先，<code>render()</code>方法呈现一个HTML <code>&lt;table&gt;</code>元素。然后，它通过使用<code>map</code>函数将<code>users</code>数组转换为<code>&lt;tr&gt;</code>元素来显示表中的数据记录。如果正在获取，也会显示“获取用户…”消息。</p>
<p>这是非常初级的进度报告，所以你可以考虑根据你的应用程序的UI/UX原则添加专业的CSS加载器/旋转器。HTML table元素将只显示每个用户的id、name和username字段，尽管还有其他几个字段。</p>
<pre class="language-javascript hljs">render() {
    return (
        &lt;div&gt;
            &lt;table&gt;
                &lt;tbody&gt;
                    {this.state.users.map((user, index) =&gt; (
                    &lt;tr key={index} className={rowClassNameFormat(index)}&gt;
                            &lt;td&gt;{user.id}&lt;/td&gt;
                            &lt;td&gt;{user.name}&lt;/td&gt;
                            &lt;td&gt;{user.username}&lt;/td&gt;
                    &lt;/tr&gt;
                    ))}
                &lt;/tbody&gt;
            &lt;/table&gt;
            &lt;p&gt;{this.state.isFetching ? 'Fetching users...' : ''}&lt;/p&gt;
        &lt;/div&gt;
    )
}
</pre>
<p>正如我之前所讨论的，实际的数据获取发生在<code>componentDidMount()</code>中，React生命周期方法在组件被挂载并准备就绪时被调用。有些人可能认为最好使用<code>componentWillMount()</code>,它在组件将要安装时被调用，并且更早地开始获取数据以节省时间。然而，有两个重要的理由反对它。</p>
<p>首先，<a href="https://reactjs.org/docs/react-component.html#unsafe_componentwillmount" target="_blank" rel="noopener">从React 17开始已经弃用</a>。第二，当你在<code>componentWillMount()</code>中使用Fetch API或Axios时，React会在没有等待它完成的情况下进行渲染，并且会导致第一次空渲染——所以你并没有真正节省任何时间。</p>
<p>注意<code>componentDidMount()</code>是在第一次渲染之后调用的，所以您仍然需要处理第一次空渲染。在我们的演示中，我使用了“获取用户…”消息。</p><div class="code-block code-block-54">
<hr/>
<h3>更多来自LogRocket的精彩文章:</h3>

<hr/></div>
<p>另一种选择是在构造函数中进行初始数据获取，但这会延迟组件的首次呈现。</p>
<p>好的，就这么定了——我们将在<code>componentDidMount()</code>获取我们的数据。这段代码简单地调用了<code>fetchUsers()</code>方法，并启动了一个每五秒钟调用一次<code>fetchUsers()</code>的计时器。</p>
<pre class="language-javascript hljs">componentDidMount() {
    this.fetchUsers();
    this.timer = setInterval(() =&gt; this.fetchUsers(), 5000);
}
</pre>
<p>当我们的组件离开时，调用<code>componentWillUnmount()</code>方法，这是通过调用<code>clearInterval()</code>并将其设置为null来停止计时器的好时机。</p>
<pre class="language-javascript hljs">componentWillUnmount() {
    clearInterval(this.timer);
    this.timer = null;
}
</pre>
<p><code>fetchUsers()</code>将<code>isFetching</code>状态变量设置为<code>true</code>，因此在获取新数据时，组件在数据表后的<code>&lt;p&gt;</code>标记中呈现“获取用户…”消息。然后它通过一些“魔法”得到用户，并将<code>isFetching</code>设置回<code>false</code>。</p>
<pre class="language-javascript hljs">async fetchUsers() {
    try {
        this.setState({...this.state, isFetching: true});
        // fetch data ....
        this.setState({users: response.data, isFetching: false});
    } catch (e) {
        // error handling
    }
}
</pre>
<p>我不太喜欢自主组件；他们太像一个黑箱了。它们混合了两种非常不同的数据获取和数据显示，并且更难测试。</p>
<p>有多种方法可以实现<code>fetchUsers()</code>功能。我在不同的组件中使用了三种不同的实现。所有三种实现都完成相同的任务:</p>
<ul>
<li>内置的获取API</li>
<li>Axios</li>
<li>Axios异步/等待</li>
</ul>
<p>我也可以在Fetch API中使用async/await。我在不同的组件中任意使用了不同的实现；它们都是可以互换的。利弊更多的是人体工程学而非功能性。</p>
<p>让我们仔细看看这些替代实现。</p>
<h2 id="example-using-fetch-api-react">在React中使用Fetch API的示例</h2>
<p>Fetch API是传统的<code>XMLHttpRequest</code> API的现代替代品。如今，所有现代浏览器通常都支持Fetch API，所以我们可以在React中使用它来获取数据，而无需向您的<code>package.json</code>添加另一个依赖项。</p>
<p>我已经在<code>UserTableHOC</code>组件中使用了Fetch。我实际上调用了函数<code>fetchUsersWithFetchAPI()</code>，但是将它赋给了一个名为<code>fetchUsers</code>的变量，所以组件只调用了<code>fetchUsers()</code>。</p>
<p>该函数首先将变量<code>isFetching</code>设置为<code>true</code>，然后调用fetch。Fetch返回一个承诺，该承诺解析为一个响应。响应的<code>json()</code>方法返回一个JavaScript对象。然后，它将用户设置为状态，并将<code>isFetching</code>重置为<code>false</code>。</p>
<p>如果出现问题，catch处理程序会将错误记录到控制台，并在获取完成后重置<code>isFetching</code>变量。</p>
<pre class="language-javascript hljs">fetchUsersWithFetchAPI = () =&gt; {
    this.setState({...this.state, isFetching: true});
    fetch(USER_SERVICE_URL)
        .then(response =&gt; response.json())
        .then(result =&gt; {
            this.setState({users: result, isFetching: false})
        })
        .catch(e =&gt; {
            console.log(e);
            this.setState({...this.state, isFetching: false});
        });
};

fetchUsers = this.fetchUsersWithFetchAPI;
</pre>
<h3 id="calling-api-fetch">使用Fetch调用API</h3>
<p>我们之前已经使用<code>fetch</code>函数调用了JSONPlaceholder用户API。<code>fetchUsersWithFetchAPI</code>触发了一个<code>GET</code> API请求，因为我们在没有特定HTTP方法的情况下调用了<code>fetch</code>(即<code>PATCH</code>、<code>POST</code>等)。).</p>
<p>调用web API是指进行<a href="https://en.wikipedia.org/wiki/Create,_read,_update_and_delete" target="_blank" rel="noopener"> CRUD </a>操作，而不仅仅是R(读)操作。例如，如果我们需要通过RESTful后端插入一个新用户，我们可能需要用一个<code>POST</code> HTTP请求和一个包含新用户数据的JSON有效负载来调用API。类似地，我们也经常需要用<code>PATCH</code>和<code>DELETE</code> HTTP方法调用API。</p>
<p>我们可以使用<code>fetch</code>函数的<code>method</code>选项来调用具有不同HTTP方法的API。以下代码片段插入一个新用户:</p>
<pre class="language-javascript hljs">const user = { username: 'John100' };

fetch(USER_SERVICE_URL, {
  method: 'POST',
  headers: {
    'Content-Type': 'application/json',
  },
  body: JSON.stringify(user),
})
  .then((response) =&gt; response.json())
  .then((user) =&gt; {
    console.log('New user:', user);
  })
  .catch((e) =&gt; {
    console.error(e);
  });
</pre>
<p>在这里，我们一直使用<code>USER_SERVICE_URL</code>，但是一个真实的API可能包含多个端点(即<code><a href="http://www.example.com/api/users" rel="nofollow">http://www.example.com/api/users</a></code>、<code><a href="http://www.example.com/api/orders" rel="nofollow">http://www.example.com/api/orders</a></code>等)。).然后，您可以使用多种策略，以可读性更好的方式调用Fetch API。</p>
<p>一种方法是对基本URL使用一个常量，并将其与<code>fetch</code>调用连接起来:</p>
<pre class="language-javascript hljs">const BASE_URL = 'https://www.example.com/api';

fetch(`${BASE_URL}/users`)
// ...

fetch(`${BASE_URL}/orders`)
// ...
</pre>
<p>通过<a href="https://blog.logrocket.com/intercepting-javascript-fetch-api-requests-responses/" target="_blank" rel="noopener">为<code>fetch</code>函数</a>创建一个拦截器，我们可以让上面的代码更加易读:</p>
<pre class="language-javascript hljs">function fetchWithBase(fetch, baseURL) {
    return (url, ...params) =&gt; {
      if(url.startsWith('/')) 
        return fetch(baseURL + url, ...params)
      else 
        return fetch(url, ...params);
    }
}
const fetch = fetchWithBase(window.fetch, BASE_URL);

fetch('/users')
// ...

fetch('/orders')
// ...
</pre>
<p>Fetch API相当冗长和麻烦，但是它是标准的，没有外部依赖性——这是Fetch API的卖点。话说回来，这是JavaScript许许多多的依赖是这片土地的法则。输入Axios。</p>
<h2 id="how-fetch-data-axios">如何用Axios获取数据</h2>
<p>我已经为<code>UserTableRenderProps</code>组件使用了Axios。Axios也有一个类似于Fetch的基于promise的API，但是Axios省去了JSON解析阶段，处理所有错误。例如，Fetch API返回404作为正常响应，因此您需要在代码中检查响应，并在需要时自己抛出一个错误。</p>
<pre class="language-javascript hljs">fetchUsersWithAxios = () =&gt; {
        this.setState({...this.state, isFetching: true});
        axios.get(USER_SERVICE_URL)
            .then(response =&gt; {
                this.setState({data: response.data, isFetching: false})
            })
            .catch(e =&gt; {
                console.log(e);
                this.setState({...this.state, isFetching: false});
            });
    };
fetchUsers = this.fetchUsersWithAxios
</pre>
<p>代码几乎与Fetch API版本相同，少了一个步骤，开发人员友好的代码和更健壮的错误处理。</p>
<h3 id="is-fetch-better-axios">Fetch比Axios好吗？</h3>
<p>您可以使用Fetch API或Axios 通过HTTP协议<a href="https://www.geeksforgeeks.org/difference-between-fetch-and-axios-js-for-making-http-requests/" target="_blank" rel="noopener">与服务器通信。有什么区别？</a></p>
<p>Fetch API提供了一个在window对象上定义的<code>fetch()</code>方法，以及一个用于访问和操作HTTP请求和响应的JavaScript接口。<code>fetch()</code>只有一个强制参数:要获取的资源的URL。它返回一个承诺，可用于检索请求的响应。</p>
<p>另一方面，Axios是一个JavaScript库，使您能够从浏览器和Node.js环境发出HTTP请求。它支持JavaScript ES6中的Promise API。Axios使您能够拦截HTTP请求和响应，保护客户端免受跨站点请求伪造(<a href="https://en.wikipedia.org/wiki/Cross-site_request_forgery" target="_blank" rel="noopener"> XSRF </a>)，并且能够取消请求。</p>
<p><a href="https://blog.logrocket.com/axios-or-fetch-api/" target="_blank" rel="noopener">那么React取数据方式哪个更好:<code>fetch</code>还是Axios </a>？这取决于您的项目的特定需求以及您在使用内置API时的舒适程度。</p>
<p>Axios在一个紧凑的包中提供了一个易于使用的API，可以满足您的大多数HTTP通信需求。但是，如果您更喜欢使用原生API，没有什么可以阻止您实现Axios特性。使用web浏览器提供的<code>fetch()</code>方法来重现Axios库的关键特性当然是可能的。</p>
<p>最终，是否值得加载客户端HTTP API取决于您是否习惯使用内置API。</p>
<h2 id="how-fetch-data-async-await-react">如何在React中用async/await获取数据</h2>
<p>我在<code>UserTableAutonomous</code>组件中使用了async/await语法。这些承诺链是对旧的回调地狱的巨大改进，但它可以变得更好。看看使用async/await时，相同的代码看起来是多么漂亮和自然:</p>
<pre class="language-javascript hljs">async fetchUsers() {
    try {
        this.setState({...this.state, isFetching: true});
        const response = await axios.get(USER_SERVICE_URL);
        this.setState({users: response.data, isFetching: false});
    } catch (e) {
        console.log(e);
        this.setState({...this.state, isFetching: false});
    }
}
</pre>
<p>毫无疑问，这是我最喜欢的变体。</p>
<h2 id="how-fetch-data-graphql-api-react">如何在React中从GraphQL API获取数据</h2>
<p>用户API是一个REST API。GraphQL后端怎么样？GraphQL服务器通常也通过HTTP返回JSON。</p>
<p>主要区别在于，只有一个查询端点来获取数据(忽略突变和订阅)，请求和返回的实际数据遵循GraphQL模式。数据获取策略和战术并不区分REST和GraphQL，它们在两者上都同样适用。</p>
<p>现在，WebSockets与gRPC是一个不同的故事——我们将把它留到另一天。</p>
<h2 id="how-fetch-data-higher-order-components">如何在高阶组件中获取数据</h2>
<p>高阶组件是复合组件，其中顶层组件负责获取数据并将其传播给子组件。高阶组件可以任意嵌套。</p>
<p>几个后代组件可能接收提取数据的不同部分，而层次结构中的其他组件可能根本不使用这些数据。这里有一个小图表来说明这一点:</p>
<p><img data-attachment-id="129369" data-permalink="https://blog.logrocket.com/comprehensive-guide-data-fetching-react/attachment/higher-order-components/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/12/higher-order-components.png" data-orig-size="516,480" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="higher-order-components" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/12/higher-order-components-300x279.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/12/higher-order-components.png" decoding="async" class="aligncenter size-full wp-image-129369 jetpack-lazy-image" src="../Images/92da49b0ad3b90acc5f0b75174c64f5c.png" alt="Higher Order Components" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2020/12/higher-order-components.png 516w, https://blog.logrocket.com/wp-content/uploads/2020/12/higher-order-components-300x279.png 300w" data-lazy-sizes="(max-width: 516px) 100vw, 516px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2020/12/higher-order-components.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/12/higher-order-components.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="129369" data-permalink="https://blog.logrocket.com/comprehensive-guide-data-fetching-react/attachment/higher-order-components/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/12/higher-order-components.png" data-orig-size="516,480" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="higher-order-components" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/12/higher-order-components-300x279.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/12/higher-order-components.png" decoding="async" loading="lazy" class="aligncenter size-full wp-image-129369" src="../Images/92da49b0ad3b90acc5f0b75174c64f5c.png" alt="Higher Order Components" srcset="https://blog.logrocket.com/wp-content/uploads/2020/12/higher-order-components.png 516w, https://blog.logrocket.com/wp-content/uploads/2020/12/higher-order-components-300x279.png 300w" sizes="(max-width: 516px) 100vw, 516px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/12/higher-order-components.png"/></noscript>
<p>基本思想是将获取和分发数据的考虑与实际处理数据的考虑分离开来。在多个组件需要不同方面的数据的情况下，这也更有效，因为您只需获取一次数据。让我们看看结果如何。</p>
<p>组件对服务器、生命周期方法、数据获取或错误处理一无所知；它所做的只是在props中接收用户列表，并使用HTML <code>&lt;table&gt;</code>元素呈现它们。它理解用户对象的属性，并期望一个id、名称和用户名。</p>
<pre class="language-javascript hljs">import React from 'react';
import '../css/Table.css';

function rowClassNameFormat(index) {
    return index % 2 === 0 ? 'Gold-Row' : 'Silver-Row';
}

const SimpleUserTable = (props) =&gt; {
    return (
        &lt;div&gt;
            &lt;table&gt;
                &lt;tbody&gt;
                {props.data.map((user, index) =&gt; (
                   &lt;tr key={index} className={rowClassNameFormat(index)}&gt;
                        &lt;td&gt;{user.id}&lt;/td&gt;
                        &lt;td&gt;{user.name}&lt;/td&gt;
                        &lt;td&gt;{user.username}&lt;/td&gt;
                   &lt;/tr&gt;
                ))}
                &lt;/tbody&gt;
            &lt;/table&gt;
            &lt;p&gt;{props.isFetching ? 'Fetching users...' : ''}&lt;/p&gt;
        &lt;/div&gt;
    )
};

export default SimpleUserTable;
</pre>
<p>有趣的是，关于用户对象的知识只是一个局部视图。从JSONPlaceholder返回的实际用户对象包含更多信息:</p>
<pre class="language-javascript hljs">{
    "id": 1,
    "name": "Leanne Graham",
    "username": "Bret",
    "email": "\[<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="f7a49e9994928592b79687859e9bd9959e8d">[email protected]</a>\](mailto:<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="580b31363b3d2a3d1839282a3134763a3122">[email protected]</a>)",
    "address": {
      "street": "Kulas Light",
      "suite": "Apt. 556",
      "city": "Gwenborough",
      "zipcode": "92998-3874",
      "geo": {
        "lat": "-37.3159",
        "lng": "81.1496"
      }
    },
    "phone": "1-770-736-8031 x56442",
    "website": "hildegard.org",
    "company": {
      "name": "Romaguera-Crona",
      "catchPhrase": "Multi-layered client-server neural-net",
      "bs": "harness real-time e-markets"
    }
  }
</pre>
<p><code>SimpleUserTable</code>只关心id、名称和用户名。如果后端服务器添加更多的信息或删除/重命名一些未使用的字段，这完全没问题。为了更加熟悉呈现数据，您可以尝试更新<code>SimpleUserTable</code>来呈现串联的地址字段和公司详细信息。我们将在下一节讨论如何完整地呈现获取的数据！</p>
<p>那么，什么获取实际数据呢？那就是<code>UserTableHOC</code>。它通过调用更新用户的<code>fetchUsers()</code>方法在它的<code>componentDidMount</code>中获取用户，<code>isFetching</code>是状态。<code>render()</code>方法只是将状态传递给子节点<code>SimpleUserTable</code>。</p>
<pre class="language-javascript hljs">import React, { Component } from 'react';
import SimpleUserTable from './SimpleUserTable';

const USER_SERVICE_URL = 'https://jsonplaceholder.typicode.com/users';

class UserTableHOC extends Component {
    constructor(props) {
        super(props);
        this.state = {
            isFetching: false,
            users: []
        };
    }

    render = () =&gt; &lt;SimpleUserTable data={this.state.users}
                                    isFetching={this.state.isFetching}
    /&gt;;


    componentDidMount() {
        this.fetchUsers();
    }

    fetchUsersWithFetchAPI = () =&gt; {
        this.setState({...this.state, isFetching: true});
        fetch(USER_SERVICE_URL)
            .then(response =&gt; response.json())
            .then(result =&gt; {
                this.setState({users: result, isFetching: false});
            })
            .catch(e =&gt; {
                console.log(e);
                this.setState({...this.state, isFetching: false});
            });
    };

    fetchUsers = this.fetchUsersWithFetchAPI;
}

export default UserTableHOC;
</pre>
<p>在实践中，我们将<code>UserTableAutonomous</code>分成两个嵌套的组件；代码基本相同，但是更简洁。我们已经做好了准备，以防我们需要多个组件以不同的方式显示用户数据。</p>
<p>例如，如果我们想启用用户选择，然后在另一个组件(如<code>FullUserInfo</code>)中显示所选用户的完整信息，那么<code>UserTableHOC</code>可以将相关的用户信息传递给<code>FullUserInfo</code>组件。</p>
<p>这听起来很棒，但是在这些情况下有很多工作要做，比如通知HOC关于子组件中的选择，以及通过深度嵌套的组件层次结构来传递提取的数据。</p>
<p>因此，HOC不仅负责获取数据，还负责呈现层次结构中直接位于它下面的组件，并可能响应来自这些子组件的事件。</p>
<p>我们的下一个数据模式解决了这些问题，但是它也有自己的权衡。</p>
<h2 id="how-fetch-data-render-props">如何在渲染道具中获取数据</h2>
<p>如果我们可以实现一个通用的数据提取器，它完全不知道应该如何处理数据，那会怎么样？事实证明这是一种常见的做法。诀窍是使用间接层。</p>
<p>俗话说，“你可以用一个<a href="https://en.wikipedia.org/wiki/Indirection" target="_blank" rel="noopener">附加的间接层</a>来解决计算机科学中的任何问题……除了太多间接层的问题。”</p>
<p>反应模式通常被称为渲染道具。其思想是将一个属性传递给一个组件，该组件是一个函数，而不是一个静态值或对象。接收对象将执行这个道具，它经常在<code>render()</code>方法中使用——因此命名为render prop。</p>
<p>这为您带来的是通过用您的函数替换部分逻辑来深度定制目标组件工作方式的能力。如果你熟悉面向对象的设计模式，它类似于策略模式或模板方法模式。</p>
<p><code>UserTableRenderProps</code>的代码和<code>UserTableHOC</code>很像。最大的区别在于调用其<code>props.children()</code>函数的<code>render()</code>方法。这增加了抽象层次，因为组件不需要知道任何关于其子组件的信息。</p>
<pre class="language-javascript hljs">import React, { Component } from 'react';
import axios from 'axios';

const USER_SERVICE_URL = 'https://jsonplaceholder.typicode.com/users';

class UserTableRenderProps extends Component {
    constructor(props) {
        super(props);
        this.state = {
            isFetching: false,
            data: []
        };
    }

    render = () =&gt; this.props.children(this.state);

    componentDidMount() {
        this.fetchUsers();
    }

    fetchUsersWithAxios = () =&gt; {
        this.setState({...this.state, isFetching: true});
        axios.get(USER_SERVICE_URL)
            .then(response =&gt; {
                this.setState({data: response.data, isFetching: false});
            })
            .catch(e =&gt; {
                console.log(e);
                this.setState({...this.state, isFetching: false});
            });
    };

    fetchUsers = this.fetchUsersWithAxios;
}
export default UserTableRenderProps;
</pre>
<p>这很酷，但这意味着无论传递什么，渲染支柱都需要知道内部结构。</p>
<p>什么时候使用渲染道具才有意义？一个很好的例子是在深层次结构中，数据获取组件可以共享一个缓存。在这种情况下，让多个数据提取器拥有不同的子对象是有意义的，这与HOC相反，HOC的子对象是固定的(在HOC组件的<code>render()</code>方法中硬编码)。</p>
<p>让我们再来看看App.js中的<code>App()</code>功能组件，它将<code>children</code>渲染道具传递给<code>UserTableRenderProps</code>。如您所见，它需要知道<code>SimpleUserTable</code>并传递它。</p>
<pre class="language-javascript hljs">function App() {
    return (
        &lt;div className='App'&gt;
            &lt;h2&gt; User Table - Autonomous&lt;/h2&gt;
            &lt;UserTableAutonomous/&gt;
            &lt;h2&gt; User Table - Higher Order Component&lt;/h2&gt;
            &lt;UserTableHOC/&gt;
            &lt;h2&gt; User Table - Render Props&lt;/h2&gt;
            &lt;UserTableRenderProps children={SimpleUserTable}/&gt;
            &lt;h2&gt; User Table - React Hooks&lt;/h2&gt;
            &lt;UserTableReactHooks/&gt;
        &lt;/div&gt;
    );
}
</pre>
<h2 id="fetching-data-react-hooks">用React钩子获取数据</h2>
<p>React中的数据获取过去需要一个具有状态和生命周期方法的基于类的组件。但是<a href="https://reactjs.org/docs/hooks-intro.html" target="_blank" rel="noopener"> React 16.8带给我们的是钩子</a>。</p>
<p>诸如高阶组件和渲染道具之类的模式要求您重新构建组件层次结构和/或通过层次结构传播大量状态(直接使用道具或者使用各种包装器、提供者和消费者)。此外，人们还纠结于类及其实现方式。</p>
<p>React Hooks的思想是将状态管理分解成独立的功能，不需要将状态的圆栓放入类生命周期方法的方孔中。</p>
<p>React的所有特性都可以在功能组件中使用，并且不需要类。特别是，我们可以使用React钩子来获取数据。</p>
<p>让我们检查一下<code>UserTableReactHooks</code>功能组件的代码。首先，用初始状态调用<code>useState()</code>状态钩子。这类似于构造函数。钩子返回两个值:当前状态和更新它的函数。请注意，您可以拥有多个状态挂钩，如果您需要独立更新状态的不同部分，这可能会很有用。</p>
<pre class="language-javascript hljs">import React, {useEffect, useState} from 'react';
import axios from 'axios';
import SimpleUserTable from './SimpleUserTable';

const USER_SERVICE_URL = 'https://jsonplaceholder.typicode.com/users';

function UserTableReactHooks() {
    const [data, setData] = useState({users: [], isFetching: false});
</pre>
<p>到目前为止，一切顺利。为了执行像数据获取这样的副作用，我们将使用一个效果钩子。默认情况下，效果挂钩接受一个函数并在每次渲染后运行它。</p>
<p>在本例中，我希望它只运行一次，所以我传递了一个函数和一个空数组。数组参数告诉钩子只在数组中列出的状态变量改变时才应用效果(即运行函数)。因为我传递了一个空数组，所以不需要观察状态变量，效果只运行一次。</p>
<pre class="language-javascript hljs">useEffect(() =&gt; {
    const fetchUsers = async () =&gt; {
        try {
            setData((data) =&gt; ({users: data.users, isFetching: true}));
            const response = await axios.get(USER_SERVICE_URL);
            setData({users: response.data, isFetching: false});
        } catch (e) {
            console.log(e);
            setData((data) =&gt; ({users: data.users, isFetching: false}));
        }
    };
    fetchUsers();
}, []);
</pre>
<p>你可以把效果想象成基于类的组件的<code>componentDidMount()</code>和<code>componentDidUpdate()</code>的组合。</p>
<p>最后，它只是返回带有本地状态的<code>SimpleUserTable</code>进行渲染。</p>
<pre class="language-javascript hljs">return &lt;SimpleUserTable data={data.users}
                            isFetching={data.isFetching}
    /&gt;;
}

export default UserTableReactHooks;
</pre>
<p>挂钩是一个很酷的和符合人体工程学的额外反应。我强烈建议你<a href="https://blog.logrocket.com/react-hooks-cheat-sheet-unlock-solutions-to-common-problems-af4caf699e70/" target="_blank" rel="noopener">熟悉他们</a>。</p>
<h2 id="fetching-data-caching-libraries">通过缓存库获取数据</h2>
<p>在前面的例子中，我们使用了一个简单的通用流程来显示来自web服务的数据。首先，我们用网络客户机调用RESTful API。接下来，我们将数据临时存储在一个状态变量中。最后，我们的React组件用花括号语法呈现获取的数据。这个流程简单且易于实现，但是它有几个缺点:</p>
<ul>
<li>如果我们多次使用数据获取组件，我们的React应用程序将多次发送相同的网络请求</li>
<li>我们必须自己定义状态变量来跟踪加载状态和错误</li>
<li>没有缓存层——组件最初会在呈现或重新呈现时显示加载指示器，直到数据获取请求完成。</li>
</ul>
<p>我们可以在数据呈现和获取之间实现一个缓存层来解决上述问题。缓存库帮助我们更有效地获取数据，并且以一种更加用户友好的方式。<a href="https://github.com/vercel/swr" target="_blank" rel="noopener"> React SWR </a>和<a href="https://github.com/TanStack/query" target="_blank" rel="noopener"> TanStack Query </a>是React生态系统中流行的缓存库。</p>
<p>你可以<a href="https://blog.logrocket.com/useswr-vs-react-query/" target="_blank" rel="noopener">在这里</a>了解更多关于缓存库、反应SWR和转移查询的信息。</p>
<h2 id="how-display-fetched-data">如何显示提取的数据</h2>
<p>前面，我们讨论了使用Fetch API和Axios获取数据。我们还将获取的数据传递给<code>SimpleUserTable</code>组件进行渲染。在本教程的示例应用程序中，我们必须显示一组用户。类似地，在React应用程序中，您可能需要显示一系列产品、一个销售订单信息、一个来自URL的图像以及其他类似的内容。</p>
<p>React让我们可以使用<a href="https://reactjs.org/docs/introducing-jsx.html#embedding-expressions-in-jsx" target="_blank" rel="noopener"> JSX表达式</a>语法(也称为花括号语法)动态呈现数据。</p>
<p>看<code>SimpleUserTable</code>。您可以看到我们是如何动态显示装载指示器文本的:</p>
<pre class="language-javascript hljs">&lt;p&gt;{props.isFetching ? 'Fetching users...' : ''}&lt;/p&gt;
</pre>
<p>那么我们如何在HTML <code>&lt;table&gt;</code>元素中呈现用户列表呢？元素让我们在一个<code>&lt;tbody&gt;</code>标签中添加带有<code>&lt;tr&gt;</code>标签的行数据。我们可以用花括号语法将<code>users</code> JavaScript数组转换成一组<code>&lt;tr&gt;</code>元素。我们都知道可以使用<code>map()</code>方法来转换数据，所以可以用<code>map()</code>来呈现获取的用户数组，如下所示:</p>
<pre class="language-javascript hljs">&lt;tbody&gt;
{props.data.map((user, index) =&gt; (
   &lt;tr key={user.id} className={rowClassNameFormat(index)}&gt;
        &lt;td&gt;{user.id}&lt;/td&gt;
        &lt;td&gt;{user.name}&lt;/td&gt;
        &lt;td&gt;{user.username}&lt;/td&gt;
   &lt;/tr&gt;
))}
&lt;/tbody&gt;
</pre>
<p>在React中，我们需要对组件列表的属性使用一个惟一的值，所以这里我们使用了惟一键<code>user.id</code>。在这个示例应用程序中，我们使用<code>rowClassNameFormat()</code>函数根据行索引对表格行进行了不同的样式化。</p>
<p>现代web应用程序通常为表格数据提供类似分页和排序的功能，因此如果我们使用<a href="https://github.com/tanstack/table" target="_blank" rel="noopener">t stack Table</a>(或类似的库)，我们可以用更少的代码呈现现代的全功能数据表。</p>
<h2 id="concurrent-mode-react-suspense">并发模式和反应暂停</h2>
<p>如果你是一名React开发人员，现在你很可能听说过<a href="https://reactjs.org/docs/concurrent-mode-intro.html" target="_blank" rel="noopener">并发模式</a>。暂停是并发模式中的一种机制，它使您的组件能够在等待一些长时间运行的操作完成时显示一些内容作为后备。显然，数据获取是一个长时间运行的操作，您可能希望在获取数据时显示类似消息、进度条或微调器的内容。</p>
<p>换句话说，<a href="https://reactjs.org/docs/concurrent-mode-suspense.html" target="_blank" rel="noopener">React suspension</a>是一套帮助React应用保持响应的功能，无论用户的设备能力或网络速度如何。它包装了您的定制组件，并使它们能够进行通信，以便在呈现组件之前做出反应，等待一些数据加载。</p>
<p>悬疑既不是<code><a href="https://github.com/async-library/react-async" target="_blank" rel="noopener">react-async</a></code>那样的数据取数库，也不是状态管理工具a-la <a href="https://blog.logrocket.com/why-use-redux-reasons-with-clear-examples-d21bffd5835/" target="_blank" rel="noopener"> Redux </a>。它只是防止组件呈现到DOM，直到某个异步操作(例如，网络请求)完成。</p>
<p>举以下例子:</p>
<pre class="language-javascript hljs">loading...
}&gt;  /&gt;
</pre>
<p><code>&lt;span class="typ"&gt;Todos&lt;/span&gt;</code>被一个带有<code>&lt;span class="pln"&gt;fallback&lt;/span&gt;</code>道具的<code>&lt;span class="typ"&gt;Suspense&lt;/span&gt;</code>组件包裹。</p>
<p>如果<code>Todos</code>正在等待一个异步操作，比如从API中检索待办事项列表，React会将<code>&lt;span class="tag"&gt;&lt;p&gt;&lt;/span&gt;&lt;span class="pln"&gt;loading…&lt;/span&gt;&lt;span class="tag"&gt;&lt;/p&gt;&lt;/span&gt;</code>呈现给DOM。</p>
<p>当操作结束时，<code>&lt;span class="typ"&gt;Todos&lt;/span&gt;</code>组件被呈现。您可能会尝试使用以下代码进行同样的操作:</p>
<pre class="language-javascript hljs">...
if (loading) {
  return &lt;p&gt;loading...p&gt;
}

return &lt;Todos /&gt;
...
</pre>
<p>这并不完全可行，因为它假设异步操作是由父组件触发的，并且在操作完成后,<code>&lt;span class="tag"&gt;&lt;Todos&lt;/span&gt;&lt;span class="pln"&gt; &lt;/span&gt;&lt;span class="tag"&gt;/&gt;&lt;/span&gt;</code>是由父组件呈现的。但是如果<code>Todos</code>触发了操作呢？</p>
<p>在这种情况下，您需要将加载检查从父组件移动到<code>Todos</code>组件。那么，假设有更多的组件，每个组件触发自己的异步请求。每个子组件都必须独立地管理自己的加载状态，这使得很难以一种干净的方式协调数据加载操作，而不会导致UX。</p>
<pre class="language-javascript hljs">loading...
}&gt;  /&gt;
   /&gt;
</pre>
<p>在上面的例子中，我们添加了另一个<code>Tasks</code>组件。让我们假设这个组件也触发它自己的异步操作。通过将两个组件包装在<code>Suspense</code>中，您实际上是在告诉React在两个操作都解决之前不要渲染任何一个组件。为了毫无悬念地完成同样的工作，您需要将异步调用移动到父组件，并在呈现组件之前添加对<code>loading</code>标志的<code>if</code>检查。</p>
<p>当然，您可以混合搭配各种方法，包括渲染时提取、提取后渲染和提取时渲染。你可以通过阅读我们全面的<a href="https://blog.logrocket.com/react-suspense-for-data-fetching/" target="_blank" rel="noopener">反应悬念教程</a>来了解更多关于这些方法的信息。</p>
<p>如果您已经有了一些以某种方式获取数据的组件，以及使用另一种方法的其他组件，它们都可以愉快地生活在同一个应用程序中。但是如果你是从零开始，使用React钩子和悬念可能是最好的方法。</p>
<p>需要注意的是，React悬念是一个实验性的功能，在稳定版本中尚不可用。</p>
<h2 id="conclusion">结论</h2>
<p>我们在这篇文章中涉及了很多内容。我们探讨了所有常见的React数据获取策略和战术。我们权衡了每种方法的利弊，并用代码演示了每种方法。</p>
<p>此时，我会使用async/await语法使用React钩子和Axios。在不久的将来，检验数据获取的悬念会很有趣。</p>
<p>感谢阅读！</p>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
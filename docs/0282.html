<html>
<head>
<title>WebSockets tutorial: How to go real-time with Node and React - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>WebSockets教程:如何实时使用Node和React - LogRocket博客</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/websocket-tutorial-real-time-node-react/#0001-01-01">https://blog.logrocket.com/websocket-tutorial-real-time-node-react/#0001-01-01</a></blockquote><div><article class="article-post">
<p><em> <strong>编者按</strong>:本WebSockets教程最后一次更新是在2022年12月23日，将示例应用升级到React v18，采用钩子和功能组件，并使用<code>react-use-websocket</code>库来处理WebSockets。</em></p>
<p>以前，大多数web应用程序都有一个紧密连接的后端和前端，因此应用程序将数据和视图内容一起提供给用户的浏览器。如今，我们通常开发松散耦合的、独立的后端和前端，通过面向网络的通信线路将两者连接起来。</p>
<p>例如，开发人员经常使用RESTful模式和HTTP协议来实现前端和后端之间的通信线路，以便进行数据传输。但是基于HTTP的RESTful概念使用的是单工通信(单向)，所以如果不实现轮询之类的变通方法，我们就不能直接从客户端(前端)向服务器(后端)发送数据。</p>
<p>WebSocket协议解决了传统HTTP模式的这一缺点，提供了全双工(或双向)通信机制，并帮助开发人员构建实时应用程序。</p>
<p>在本文中，我将解释WebSocket协议背后的理论概念，并演示如何使用WebSocket协议构建一个具有Node.js后端和React前端的实时协作文档编辑应用程序。</p>
<p>向前跳:</p>

<h2 id="websocket">什么是WebSocket协议？</h2>
<p>WebSocket协议通过单个TCP套接字连接在客户端和服务器之间提供持久、实时、全双工的通信。</p>
<p>WebSocket协议只有两个目的:开启握手和帮助数据传输。一旦服务器接受客户端发送的握手请求并发起WebSocket连接，它们就可以随意地以较少的开销互相发送数据。</p>
<p>WebSocket通信通过使用WS(端口80)或WSS(端口443)协议的单个TCP套接字进行。除了Opera Mini之外，几乎所有的浏览器在编写的时候都提供了令人钦佩的对WebSockets的支持，根据<a href="https://caniuse.com/#feat=websockets">我可以使用</a>。</p>
<p>下面的视频解释了与传统HTTP协议相比，WebSocket协议的工作原理及其对用户的益处:</p>
<p><span class="embed-youtube"> <iframe loading="lazy" class="youtube-player" src="https://www.youtube.com/embed/LenNpb5zqGE?version=3&amp;rel=1&amp;showsearch=0&amp;showinfo=1&amp;iv_load_policy=1&amp;fs=1&amp;hl=en-US&amp;autohide=2&amp;wmode=transparent" allowfullscreen="true" sandbox="allow-scripts allow-same-origin allow-popups allow-presentation">视频</iframe> </span></p>
<h2 id="websocket-different-from-http-polling-http-streaming-server-sent-events">WebSocket与HTTP轮询、HTTP流和服务器发送的事件有什么不同？</h2>
<p>历史上，创建需要实时数据的web应用程序(如游戏或聊天应用程序)需要滥用HTTP协议来建立双向数据传输。有多种方法用于实现实时功能，但没有一种方法像WebSocket那样高效。HTTP轮询、HTTP流、<a href="https://en.wikipedia.org/wiki/Comet_(programming)"> Comet </a>和SSE(服务器发送事件)都有它们的缺点。</p>
<h3 id="http-polling">HTTP轮询</h3>
<p>解决这个问题的第一个尝试是定期轮询服务器。正常的轮询方法根据客户端定义的时间间隔频繁地从服务器获取数据(通常使用<code>setInterval</code>或递归<code>setTimeout</code>)。另一方面，长轮询方法类似于普通轮询，但是服务器处理超时/等待时间。</p>
<p>HTTP长轮询生命周期如下:</p>
<ol>
<li>客户端发出请求并等待响应</li>
<li>服务器会推迟响应，直到发生更改、更新或超时。请求保持“挂起”状态，直到服务器有东西返回给客户机</li>
<li>当服务器端发生一些变化或更新时，它会向客户端发回一个响应</li>
<li>客户端发送一个新的长轮询请求来监听下一组更改</li>
</ol>
<p>长轮询有很多漏洞——报头开销、延迟、超时、缓存等等。</p>
<h3 id="http-streaming">HTTP流</h3>
<p>这种机制免除了网络延迟的痛苦，因为初始请求是无限期开放的。即使在服务器推送数据之后，请求也不会终止。HTTP流的前三种生命周期方法在HTTP长轮询中是相同的。</p>
<p>然而，当响应被发送回客户机时，请求永远不会终止；服务器保持连接打开，并在有变化时发送新的更新。</p>
<h3 id="server-sent-events">服务器发送的事件(SSE)</h3>
<p>使用SSE，服务器将数据推送到客户端，类似于HTTP流。SSE是HTTP流概念的标准化形式，带有一个内置的浏览器API。聊天或游戏应用程序不能完全依赖SSE。例如，SSE的完美用例是脸书新闻提要:每当有新的帖子进来，服务器就把它们推到时间线上。SSE通过传统的HTTP发送，并且对打开的连接数有限制。</p>
<p>从GitHub Gist文件中了解更多关于SSE架构的信息。与WebSockets相比，这些方法不仅效率低下。其中的代码似乎是一种变通方法，使请求-应答类型的协议类似于全双工。</p>
<h2 id="why-you-should-use-websockets">为什么应该使用WebSockets</h2>
<p>WebSockets旨在取代现有的双向通信方法。当涉及全双工实时通信时，上述现有方法既不可靠也不高效。</p>
<p>WebSockets类似于SSE，但同样成功地将消息从客户端传回服务器。连接限制不再是问题，因为数据是通过单个TCP套接字连接提供的。</p>
<h2 id="use-websockets-node-js-react">如何将WebSockets与Node.js和React一起使用</h2>
<p>正如介绍中提到的，WebSocket协议只有两个目的:1)建立握手，2)帮助数据传输。让我们看看WebSockets如何实现这些议程。为此，我将剥离Node.js服务器并<a href="https://blog.logrocket.com/beyond-rest-using-websockets-for-two-way-communication-in-your-react-app-884eff6655f5/">将其连接到用React.js </a>构建的客户端。</p>
<p>首先，下载或者克隆这个GitHub库到你的电脑上。这个存储库包含示例协作文档编辑应用程序的源代码。用你最喜欢的代码编辑器打开它。您将看到如下两个目录:</p>
<ul>
<li><code>server</code>:node . js web socket服务器，处理文档编辑器的后端逻辑</li>
<li><code>client</code>:React应用程序，连接到WebSocket服务器以获得实时特性</li>
</ul>
<p>您可以使用以下命令启动文档编辑器应用程序:</p>
<pre class="language-javascript hljs">#-- Setup and start the server
cd server
npm install # or yarn install
npm start # or yarn start

#-- Setup and start the client
cd client
npm install # or yarn install
npm start # or yarn start
</pre>
<p>使用上述命令运行应用程序，尝试用两个浏览器窗口打开它，然后从两个浏览器窗口编辑文档:</p>
<p><img data-attachment-id="154676" data-permalink="https://blog.logrocket.com/websocket-tutorial-real-time-node-react/attachment/testing-sample-app-two-browser-windows/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2021/01/testing-sample-app-two-browser-windows.gif" data-orig-size="730,468" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Testing the sample app with two browser windows" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2021/01/testing-sample-app-two-browser-windows-300x192.gif" data-large-file="https://blog.logrocket.com/wp-content/uploads/2021/01/testing-sample-app-two-browser-windows.gif" decoding="async" class="aligncenter size-full wp-image-154676 jetpack-lazy-image" src="../Images/4c0b7454c1647c2eaf5e7de43051e91d.png" alt="Testing The Sample App With Two Browser Windows" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2021/01/testing-sample-app-two-browser-windows.gif?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2021/01/testing-sample-app-two-browser-windows.gif"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="154676" data-permalink="https://blog.logrocket.com/websocket-tutorial-real-time-node-react/attachment/testing-sample-app-two-browser-windows/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2021/01/testing-sample-app-two-browser-windows.gif" data-orig-size="730,468" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Testing the sample app with two browser windows" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2021/01/testing-sample-app-two-browser-windows-300x192.gif" data-large-file="https://blog.logrocket.com/wp-content/uploads/2021/01/testing-sample-app-two-browser-windows.gif" decoding="async" loading="lazy" class="aligncenter size-full wp-image-154676" src="../Images/4c0b7454c1647c2eaf5e7de43051e91d.png" alt="Testing The Sample App With Two Browser Windows" data-original-src="https://blog.logrocket.com/wp-content/uploads/2021/01/testing-sample-app-two-browser-windows.gif"/></noscript>
<p>让我们研究一下源代码，了解一下它是如何使用WebSockets工作的！</p>
<h2 id="websocket-establishes-handshake-between-server-client">议程1: WebSocket在服务器和客户端之间建立握手</h2>
<h3 id="creating-handshake-server-level-node-js">使用Node.js在服务器级别创建握手</h3>
<p>我们可以利用单个端口来分离HTTP服务器并附加WebSocket服务器。下面的要点(摘自<code>server/index.js</code>)展示了一个简单HTTP服务器的创建。一旦它被创建，我们将WebSocket服务器绑定到HTTP端口:</p>
<pre class="language-javascript hljs">const { WebSocketServer } = require('ws');
const http = require('http');

// Spinning the http server and the WebSocket server.
const server = http.createServer();
const wsServer = new WebSocketServer({ server });
const port = 8000;
server.listen(port, () =&gt; {
  console.log(`WebSocket server is running on port ${port}`);
});
</pre>
<p>在示例项目中，我使用流行的<code><a href="https://github.com/websockets/ws">ws</a></code>库将WebSocket服务器实例附加到HTTP服务器实例。一旦WebSocket服务器连接到HTTP服务器实例，它将通过将协议从HTTP升级到WebSocket来接受传入的WebSocket连接请求。</p>
<p>在我的代码中，我将所有连接的客户端作为一个对象进行维护，在从浏览器接收到它们的请求时，通过<a href="https://github.com/uuidjs/uuid"> <code>uuid</code> </a>包生成一个唯一的键:</p>
<pre class="language-javascript hljs">// I'm maintaining all active connections in this object
const clients = {};

// A new client connection request received
wsServer.on('connection', function(connection) {
  // Generate a unique code for every user
  const userId = uuidv4();
  console.log(`Recieved a new connection.`);

  // Store the new connection and handle messages
  clients[userId] = connection;
  console.log(`${userId} connected.`);
});
</pre>
<h2 id="http-connection-accepted">当HTTP连接被接受时</h2>
<p>当发送常规HTTP请求以建立连接时，在请求头中，客户机发送<code>Sec-WebSocket-Key</code>。服务器对这个值进行编码和散列，并添加一个预定义的GUID。它回显服务器发送的握手中的<code>Sec-WebSocket-Accept</code>中生成的值。</p>
<p>一旦请求在服务器中被接受(在产品中进行必要的验证之后)，握手就用<a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/101">状态码</a> <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/101"> <code>101</code> </a>(交换协议)完成。如果您在浏览器中看到除了状态代码<code>101</code>之外的任何内容，WebSocket升级已经失败，将遵循正常的HTTP语义。</p>
<p><code>Sec-WebSocket-Accept</code>头字段指示服务器是否愿意接受连接。同样，如果响应缺少一个<code>Upgrade</code>头字段，或者<code>Upgrade</code>不等于<code>websocket</code>，这意味着WebSocket连接失败。</p>
<p>成功的WebSocket服务器握手如下所示:</p>
<pre class="language-javascript hljs">HTTP GET ws://127.0.0.1:8000/ 101 Switching Protocols
Connection: Upgrade
Sec-WebSocket-Accept: Nn/XHq0wK1oO5RTtriEWwR4F7Zw=
Upgrade: websocket
</pre>
<h2 id="creating-handshake-request-client-level">在客户端级别创建握手请求</h2>
<p>在客户端级别，我使用<code><a href="https://github.com/robtaussig/react-use-websocket">react-use-websocket</a></code>库来启动WebSocket连接。我们也可以使用内置的WebSocket浏览器API，不需要任何第三方包，但是在React功能组件中直接使用浏览器API通常会生成复杂的代码。</p>
<p>作为一个解决方案，我们可以为WebSocket连接创建一个定制的React钩子，但是之后我们将重新发明轮子并创建一个<code>react-use-websocket</code>克隆。<code>react-use-websocket</code>提供了<code>useWebSocket</code>钩子来管理React功能组件的WebSocket连接。查看<code>react-use-websocket</code>文档，更加熟悉特定React吊钩的设计。</p>
<p>一旦请求被服务器接受，我们将在浏览器控制台上看到<code>WebSocket connection established</code>。</p>
<p>下面是通过<code>App</code>组件(在<code>client/src/App.js</code>中)创建到服务器的连接的初始框架:</p>
<pre class="language-javascript hljs">import React from 'react';
import useWebSocket from 'react-use-websocket';

import './App.css';

const WS_URL = 'ws://127.0.0.1:8000';

function App() {
  useWebSocket(WS_URL, {
    onOpen: () =&gt; {
      console.log('WebSocket connection established.');
    }
  });

  return (
    &lt;div&gt;Hello WebSockets!&lt;/div&gt;
  );
}

export default App;
</pre>
<p>客户端发送以下头来建立握手:</p>
<pre class="language-javascript hljs">HTTP GET ws://127.0.0.1:8000/ 101 Switching Protocols
Upgrade: websocket
Connection: Upgrade
Sec-WebSocket-Key: vISxbQhM64Vzcr/CD7WHnw==
Origin: http://localhost:3000
Sec-WebSocket-Version: 13
</pre>
<p>现在客户机和服务器通过WebSocket握手事件连接起来了，WebSocket连接可以在接收消息的同时传输消息，从而实现了WebSocket协议的第二个议程。</p>
<h2 id="real-time-message-transmission">议程2:实时信息传输</h2>
<p><img data-attachment-id="154679" data-permalink="https://blog.logrocket.com/websocket-tutorial-real-time-node-react/attachment/real-time-message-transmission-websockets-tutorial/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2021/01/real-time-message-transmission-websockets-tutorial.gif" data-orig-size="730,468" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Real-time message transmission websockets tutorial" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2021/01/real-time-message-transmission-websockets-tutorial-300x192.gif" data-large-file="https://blog.logrocket.com/wp-content/uploads/2021/01/real-time-message-transmission-websockets-tutorial.gif" decoding="async" class="aligncenter size-full wp-image-154679 jetpack-lazy-image" src="../Images/c365e7f37fdaf491476c9beb5e8087ef.png" alt="Real-Time Message Transmission Websockets Tutorial" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2021/01/real-time-message-transmission-websockets-tutorial.gif?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2021/01/real-time-message-transmission-websockets-tutorial.gif"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="154679" data-permalink="https://blog.logrocket.com/websocket-tutorial-real-time-node-react/attachment/real-time-message-transmission-websockets-tutorial/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2021/01/real-time-message-transmission-websockets-tutorial.gif" data-orig-size="730,468" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Real-time message transmission websockets tutorial" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2021/01/real-time-message-transmission-websockets-tutorial-300x192.gif" data-large-file="https://blog.logrocket.com/wp-content/uploads/2021/01/real-time-message-transmission-websockets-tutorial.gif" decoding="async" loading="lazy" class="aligncenter size-full wp-image-154679" src="../Images/c365e7f37fdaf491476c9beb5e8087ef.png" alt="Real-Time Message Transmission Websockets Tutorial" data-original-src="https://blog.logrocket.com/wp-content/uploads/2021/01/real-time-message-transmission-websockets-tutorial.gif"/></noscript>
<p>用户可以在示例React应用程序中加入并编辑文档。该应用程序跟踪两个事件:</p>
<ol>
<li><strong>用户活动:</strong>每次用户加入或离开时，我都会将消息广播给所有其他连接的客户端</li>
<li><strong>内容更改:</strong>每次编辑器中的内容发生更改时，都会广播到所有其他连接的客户端</li>
</ol>
<p>该协议允许我们以二进制数据或UTF-8的形式发送和接收消息(注意，传输和转换UTF-8的开销较小)。</p>
<p>只要我们很好地理解了套接字事件:<code>onopen</code>、<code>onclose</code>和<code>onmessage</code>，理解和实现WebSockets是非常容易的。客户端和服务器端的术语是相同的。</p>
<h2 id="sending-listening-messages-clientside-using-react-use-websocket">使用<code>react-use-websocket</code>在客户端发送和收听消息</h2>
<p>在客户端，当新用户加入或内容发生变化时，我们使用<code>sendJsonMessage</code>向服务器发送一条消息，将新信息发送到服务器:</p>
<pre class="language-javascript hljs">/* When a user joins, I notify the
server that a new user has joined to edit the document. */
function LoginSection({ onLogin }) {
  const [username, setUsername] = useState('');
  useWebSocket(WS_URL, {
    share: true,
    filter: () =&gt; false
  });
  function logInUser() {
    if(!username.trim()) {
      return;
    }
    onLogin &amp;&amp; onLogin(username); // Triggers sendJsonMessage in App
  }
  // ----
  // ----

/* When content changes, we send the
current content of the editor to the server. */
function handleHtmlChange(e) {
  sendJsonMessage({
    type: 'contentchange',
    content: e.target.value
  });
}

return (
  &lt;DefaultEditor value={html} onChange={handleHtmlChange} /&gt;
);
</pre>
<p>监听来自服务器的消息非常简单。例如，看看<code>History</code>组件如何监听用户事件并呈现活动日志:</p>
<pre class="language-javascript hljs">function History() {
  const { lastJsonMessage } = useWebSocket(WS_URL, {
    share: true,
    filter: isUserEvent
  });
  const activities = lastJsonMessage?.data.userActivity || [];
  return (
    &lt;ul&gt;
      {activities.map((activity, index) =&gt; &lt;li key={`activity-${index}`}&gt;{activity}&lt;/li&gt;)}
    &lt;/ul&gt;
  );
}
</pre>
<p>这里我们使用了<code>share: true</code>设置来重用我们在<code>App</code>组件中启动的现有WebSocket连接。默认情况下，每当WebSocket连接收到来自服务器的新消息并且连接状态改变时，<code>useWebSocket</code>钩子会重新呈现组件。</p>
<p>因此，<code>History</code>组件将为用户和编辑者事件重新呈现。因此，作为性能增强，我们使用<code>filter: isUserEvent</code>设置只为用户事件重新呈现组件。</p>
<h2 id="sending-listening-messages-node-js-websocket-server">在Node.js WebSocket服务器上发送和侦听消息</h2>
<p>在服务器中，我们只需捕获传入的消息，并将其广播给连接到WebSocket的所有客户端。而这也是臭名昭著的<a href="https://blog.logrocket.com/building-real-time-location-app-node-js-socket-io/">插座的区别之一。IO </a>和WebSocket:我们在使用WebSocket时需要手动发送消息给所有客户端。插座。IO是一个成熟的库，所以它可以自己处理。</p>
<p>了解我们如何处理后端广播:</p>
<pre class="language-javascript hljs">function broadcastMessage(json) {
  // We are sending the current data to all connected active clients
  const data = JSON.stringify(json);
  for(let userId in clients) {
    let client = clients[userId];
    if(client.readyState === WebSocket.OPEN) {
      client.send(data);
    }
  };
}
</pre>
<p><img data-attachment-id="154682" data-permalink="https://blog.logrocket.com/websocket-tutorial-real-time-node-react/attachment/sending-listening-messages-server-side-using-websockets/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2021/01/sending-listening-messages-server-side-using-websockets.gif" data-orig-size="730,468" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Sending listening messages server side using WebSockets" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2021/01/sending-listening-messages-server-side-using-websockets-300x192.gif" data-large-file="https://blog.logrocket.com/wp-content/uploads/2021/01/sending-listening-messages-server-side-using-websockets.gif" decoding="async" class="aligncenter size-full wp-image-154682 jetpack-lazy-image" src="../Images/4b9a41dde3632d64239bb6ae3acfaeb7.png" alt="Sending Listening Messages Server Side Using WebSockets" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2021/01/sending-listening-messages-server-side-using-websockets.gif?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2021/01/sending-listening-messages-server-side-using-websockets.gif"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="154682" data-permalink="https://blog.logrocket.com/websocket-tutorial-real-time-node-react/attachment/sending-listening-messages-server-side-using-websockets/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2021/01/sending-listening-messages-server-side-using-websockets.gif" data-orig-size="730,468" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Sending listening messages server side using WebSockets" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2021/01/sending-listening-messages-server-side-using-websockets-300x192.gif" data-large-file="https://blog.logrocket.com/wp-content/uploads/2021/01/sending-listening-messages-server-side-using-websockets.gif" decoding="async" loading="lazy" class="aligncenter size-full wp-image-154682" src="../Images/4b9a41dde3632d64239bb6ae3acfaeb7.png" alt="Sending Listening Messages Server Side Using WebSockets" data-original-src="https://blog.logrocket.com/wp-content/uploads/2021/01/sending-listening-messages-server-side-using-websockets.gif"/></noscript>
<h2 id="when-browser-closed">浏览器关闭后会发生什么？</h2>
<p>当浏览器关闭时，WebSocket调用<code>close</code>事件，这允许我们编写逻辑来终止当前用户的连接。在我的代码中，当用户离开文档时，我向其余用户广播一条消息:</p>
<pre class="language-javascript hljs">function handleDisconnect(userId) {
    console.log(`${userId} disconnected.`);
    const json = { type: typesDef.USER_EVENT };
    const username = users[userId]?.username || userId;
    userActivity.push(`${username} left the document`);
    json.data = { users, userActivity };
    delete clients[userId];
    delete users[userId];
    broadcastMessage(json);
}

// User disconnected
connection.on('close', () =&gt; handleDisconnect(userId));
</pre>
<h2 id="conclusion">结论</h2>
<p>WebSockets是在应用程序中实现实时功能的最有趣和最方便的方式之一。它为我们利用全双工通信提供了很大的灵活性。我强烈建议在试用Socket之前先使用WebSocket。IO和其他可用的库。</p>
<p>编码快乐！🙂</p><div class="code-block code-block-17">
<div class="blog-plug inline-plug react-plug" vwo-el-id="26283398190">
<h2 vwo-el-id="41600691720">使用LogRocket消除传统反应错误报告的噪音</h2>
<a href="https://lp.logrocket.com/blg/react-signup-issue-free" target="_blank" vwo-el-id="19356441070">LogRocket
</a><p>是一款React analytics解决方案，可保护您免受数百个误报错误警报的影响，只针对少数真正重要的项目。LogRocket告诉您React应用程序中实际影响用户的最具影响力的bug和UX问题。</p><a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="19356441380">
<img class="first-react-image alignnone size-full wp-image-46 jetpack-lazy-image jetpack-lazy-image--handled" src="../Images/f300c244a1a1cf916df8b4cb02bec6c6.png" vwo-el-id="18272717540" data-lazy-loaded="1" data-original-src="https://files.readme.io/27c94e7-Image_2017-06-05_at_9.46.04_PM.png"/>
</a>
<a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="19356441690">
<img class="second-react-image alignnone size-full wp-image-46 jetpack-lazy-image jetpack-lazy-image--handled" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" vwo-el-id="30720362350" data-lazy-loaded="1" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/>
</a>
<a href="https://lp.logrocket.com/blg/react-signup-issue-free" target="_blank" rel="noopener noreferrer" vwo-el-id="35866400580">LogRocket
</a><p>自动聚合客户端错误、反应错误边界、还原状态、缓慢的组件加载时间、JS异常、前端性能指标和用户交互。然后，LogRocket使用机器学习来通知您影响大多数用户的最具影响力的问题，并提供您修复它所需的上下文。</p><p vwo-el-id="28675661060">关注重要的React bug—<a class="signup" href="https://lp.logrocket.com/blg/react-signup-issue-free" target="_blank" rel="noopener noreferrer" vwo-el-id="40093418840">今天就试试LogRocket】。</a></p>
</div></div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>
 
</div>    
</body>
</html>
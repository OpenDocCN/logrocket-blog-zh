<html>
<head>
<title>5 things not to do when building React applications - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>构建React应用时不要做的5件事</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/5-things-not-do-building-react-applications/#0001-01-01">https://blog.logrocket.com/5-things-not-do-building-react-applications/#0001-01-01</a></blockquote><div><article class="article-post">
<p><em> <strong>编者按</strong>:这篇文章最后一次更新是在2021年8月13日，以反映提到的任何技术变化或代码更新。但是，它可能仍然包含过时的信息。</em></p>
<p>在这一点上，React是地球上最受欢迎的图书馆之一。React引起了极大的兴趣，并且由于其UI优先的方法，新的开发人员被带到了该平台。</p>
<p>虽然这个库和整个React生态系统都已经成熟了很多年，但在某些情况下，我们会想，“这样做的正确方法到底是什么？”</p>
<p>这是一个合理的问题——并不总是有一种坚定的“正确”的做事方式。事实上，有时候最佳实践并不那么好。其中一些会损害性能和可读性，从长远来看，会使事情变得毫无成效。</p>
<p>在本文中，我们将回顾在使用React时实际上可以避免的五种普遍接受的开发实践，为什么它们是可以避免的，以及完成相同事情的替代方法。</p>
<h2>优化从一开始就做出反应</h2>
<p>React以其速度而闻名，每次新的更新都会添加新的优化。但是，在使用这些新的优化之前，最好先看看实际的性能。</p>
<p>因为与其他前端平台相比，React更容易扩展，所以开发人员不需要重写整个模块来加快速度。导致性能问题的罪魁祸首通常是React用来更新虚拟DOM的协调过程。</p>
<p>让我们看看React是如何处理这个问题的。在每个组件呈现上，React生成一个由UI元素组成的树，叶节点是DOM元素。</p>
<p>当更新状态或道具时，React必须以最小的变化生成新的树，并保持事情的可预测性。</p>
<p>例如，树可以是这样的:</p>
<p><img data-attachment-id="64794" data-permalink="https://blog.logrocket.com/5-things-not-do-building-react-applications/rendering-new-tree/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2018/06/Rendering-new-tree.jpeg" data-orig-size="730,570" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;1&quot;}" data-image-title="Rendering new tree" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2018/06/Rendering-new-tree-300x234.jpeg" data-large-file="https://blog.logrocket.com/wp-content/uploads/2018/06/Rendering-new-tree.jpeg" decoding="async" class="aligncenter size-full wp-image-64794 jetpack-lazy-image" src="../Images/f0939e4afc5e21f705969e6a19cae5b0.png" alt="Rendering new tree" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2018/06/Rendering-new-tree.jpeg 730w, https://blog.logrocket.com/wp-content/uploads/2018/06/Rendering-new-tree-300x234.jpeg 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2018/06/Rendering-new-tree.jpeg?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2018/06/Rendering-new-tree.jpeg"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="64794" data-permalink="https://blog.logrocket.com/5-things-not-do-building-react-applications/rendering-new-tree/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2018/06/Rendering-new-tree.jpeg" data-orig-size="730,570" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;1&quot;}" data-image-title="Rendering new tree" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2018/06/Rendering-new-tree-300x234.jpeg" data-large-file="https://blog.logrocket.com/wp-content/uploads/2018/06/Rendering-new-tree.jpeg" decoding="async" loading="lazy" class="aligncenter size-full wp-image-64794" src="../Images/f0939e4afc5e21f705969e6a19cae5b0.png" alt="Rendering new tree" srcset="https://blog.logrocket.com/wp-content/uploads/2018/06/Rendering-new-tree.jpeg 730w, https://blog.logrocket.com/wp-content/uploads/2018/06/Rendering-new-tree-300x234.jpeg 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2018/06/Rendering-new-tree.jpeg"/></noscript>
<p>假设应用程序接收到新数据，下列黄色节点需要更新:</p>
<p><img data-attachment-id="64796" data-permalink="https://blog.logrocket.com/5-things-not-do-building-react-applications/nodes-need-update-with-new-data/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2018/06/Nodes-need-update-with-new-data.jpeg" data-orig-size="730,570" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;1&quot;}" data-image-title="Nodes need update with new-data" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2018/06/Nodes-need-update-with-new-data-300x234.jpeg" data-large-file="https://blog.logrocket.com/wp-content/uploads/2018/06/Nodes-need-update-with-new-data.jpeg" decoding="async" class="aligncenter size-full wp-image-64796 jetpack-lazy-image" src="../Images/12d48b941c6d51e5aa86357baa81ad1c.png" alt="Nodes Need To Update With New Data, Nodes That Need Updating Are In Yellow" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2018/06/Nodes-need-update-with-new-data.jpeg 730w, https://blog.logrocket.com/wp-content/uploads/2018/06/Nodes-need-update-with-new-data-300x234.jpeg 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2018/06/Nodes-need-update-with-new-data.jpeg?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2018/06/Nodes-need-update-with-new-data.jpeg"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="64796" data-permalink="https://blog.logrocket.com/5-things-not-do-building-react-applications/nodes-need-update-with-new-data/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2018/06/Nodes-need-update-with-new-data.jpeg" data-orig-size="730,570" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;1&quot;}" data-image-title="Nodes need update with new-data" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2018/06/Nodes-need-update-with-new-data-300x234.jpeg" data-large-file="https://blog.logrocket.com/wp-content/uploads/2018/06/Nodes-need-update-with-new-data.jpeg" decoding="async" loading="lazy" class="aligncenter size-full wp-image-64796" src="../Images/12d48b941c6d51e5aa86357baa81ad1c.png" alt="Nodes Need To Update With New Data, Nodes That Need Updating Are In Yellow" srcset="https://blog.logrocket.com/wp-content/uploads/2018/06/Nodes-need-update-with-new-data.jpeg 730w, https://blog.logrocket.com/wp-content/uploads/2018/06/Nodes-need-update-with-new-data-300x234.jpeg 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2018/06/Nodes-need-update-with-new-data.jpeg"/></noscript>
<p>React通常会重新呈现整个子树，而不是只呈现相关节点:</p>
<p><img data-attachment-id="64799" data-permalink="https://blog.logrocket.com/5-things-not-do-building-react-applications/react-rerenders-entire-tree/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2018/06/React-rerenders-entire-tree.jpeg" data-orig-size="730,687" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;1&quot;}" data-image-title="React Rerenders Entire Tree" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2018/06/React-rerenders-entire-tree-300x282.jpeg" data-large-file="https://blog.logrocket.com/wp-content/uploads/2018/06/React-rerenders-entire-tree.jpeg" decoding="async" class="aligncenter size-full wp-image-64799 jetpack-lazy-image" src="../Images/e3227db135644d82259cc2bf5bb27c53.png" alt="React Rerenders Entire Tree, Seen In Yellow" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2018/06/React-rerenders-entire-tree.jpeg 730w, https://blog.logrocket.com/wp-content/uploads/2018/06/React-rerenders-entire-tree-300x282.jpeg 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2018/06/React-rerenders-entire-tree.jpeg?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2018/06/React-rerenders-entire-tree.jpeg"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="64799" data-permalink="https://blog.logrocket.com/5-things-not-do-building-react-applications/react-rerenders-entire-tree/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2018/06/React-rerenders-entire-tree.jpeg" data-orig-size="730,687" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;1&quot;}" data-image-title="React Rerenders Entire Tree" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2018/06/React-rerenders-entire-tree-300x282.jpeg" data-large-file="https://blog.logrocket.com/wp-content/uploads/2018/06/React-rerenders-entire-tree.jpeg" decoding="async" loading="lazy" class="aligncenter size-full wp-image-64799" src="../Images/e3227db135644d82259cc2bf5bb27c53.png" alt="React Rerenders Entire Tree, Seen In Yellow" srcset="https://blog.logrocket.com/wp-content/uploads/2018/06/React-rerenders-entire-tree.jpeg 730w, https://blog.logrocket.com/wp-content/uploads/2018/06/React-rerenders-entire-tree-300x282.jpeg 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2018/06/React-rerenders-entire-tree.jpeg"/></noscript>
<p>当顶层组件的状态发生变化时，它下面的所有组件都会重新呈现。这种默认行为对于小型应用程序来说是可以接受的。然而，随着应用程序的增长，使用React DevTools 中的<a href="https://blog.logrocket.com/react-devtools-5-things-you-didnt-know-you-could-do/"> Profiler工具来测量实际性能可能是有益的。</a></p>
<h3>如何在React中使用Profiler？</h3>
<p>Profiler工具给出了浪费在不需要的渲染上的时间的精确细节。如果数字很大，您可以通过防止重新呈现未受影响的纯功能组件来优化它们。在这种情况下，您可以使用<code>React.memo()</code>来记忆组件。</p>
<p><code>React.memo()</code>对接收到的属性做一个简单的比较，只有当属性不同时，而不仅仅是因为父状态改变时，才会重新呈现一个组件。</p>
<pre>const AChildComponent = React.memo(function AChildComponent(props) {
  // component will re-render if the prop changes
  return (
    &lt;div /&gt;
  );
});
</pre>
<p>对于基于类的组件，你可以通过<a href="https://blog.logrocket.com/react-pure-components-functional/">扩展一个<code>React.PureComponent</code> </a>或者<a href="https://blog.logrocket.com/react-reference-guide-react-component/#shouldcomponentupdate">使用<code>shouldComponentUpdate()</code> </a>定义一个定制的实现来执行一个简单的比较:</p>
<pre>shouldComponentUpdate(nextProps, nextState) {
    if (this.props.color !== nextProps.color) {
      return true;
    }
    if (this.state.count !== nextState.count) {
      return true;
    }
    return false;
  }
</pre>
<p>这样，如果除了<code>color</code>或<code>count</code>之外的任何其他道具或状态改变，组件将不会更新。</p>
<p>除此之外，还有一些开发人员通常会忽略的非React优化技巧，但它们会影响应用程序的性能。这可以通过考虑未优化的映像和未压缩的构建文件来避免。</p>
<h3>为什么图像优化很重要？</h3>
<p>如果您构建的是动态图像，那么文件巨大的图像会给用户一种应用程序运行缓慢的印象。要解决此问题，请在将图像推送到服务器之前对其进行压缩，或者使用动态图像处理解决方案。</p>
<p><a href="https://blog.logrocket.com/handling-images-with-cloudinary-in-react/"> Cloudinary是一个很棒的优化React图片的工具</a>，因为它有自己的React库；其他选项包括亚马逊S3或T2 Firebase T3。</p>
<h3>压缩构建文件的目的是什么？</h3>
<p>Gzipping构建文件(<code>bundle.js</code>)可以大幅减小文件大小。但是，您必须修改web服务器配置。</p>
<p>Webpack有一个名为compression-webpack-plugin 的gzip压缩插件。使用这种技术在构建期间生成<code>bundle.js.gz</code>。</p>
<h2>服务器端渲染对SEO有必要吗？</h2>
<p>尽管单页面应用程序(SPAs)很棒，但是它们引起了两个主要问题。</p>
<p>第一，当应用程序最初加载时，浏览器中没有JavaScript缓存。如果应用程序很大，那么最初加载应用程序所需的时间也会很长。</p>
<p>第二，由于应用程序在客户端呈现，搜索引擎使用的网络爬虫不能索引JavaScript生成的内容。搜索引擎会将一个应用程序视为空白，然后对其进行排名，赶走流量。</p>
<p>这就是<a href="https://blog.logrocket.com/why-you-should-render-react-on-the-server-side-a50507163b79/">服务器端渲染(SSR)技术</a>派上用场的地方。在SSR中，JavaScript内容最初是从服务器呈现的。在初始渲染之后，客户端脚本接管并像普通SPA一样工作。</p>
<p>设置传统SSR的复杂性和成本更高，因为您需要Node.js/Express.js服务器。然而，如果你是为了SEO的利益，这是一个好消息。Google毫无困难地索引和抓取JavaScript内容。</p>
<p>以下是2015年10月谷歌搜索中心博客的摘录:</p>
<blockquote><p>今天，只要你不阻止Googlebot抓取你的JavaScript或CSS文件，我们通常能够像现代浏览器一样呈现和理解你的网页。为了反映这一改进，我们最近更新了技术网站管理员指南，建议不要禁止Googlebot抓取您网站的CSS或JS文件。</p></blockquote>
<p>如果你只是因为担心你的谷歌页面排名而使用SSR，那么你不需要使用SSR。但是，如果您使用SSR来提高初始渲染速度，请尝试使用类似Next.js 的库来实现更简单的<a href="https://blog.logrocket.com/ssg-vs-ssr-in-next-js/"> SSR。</a></p>
<p>这为您节省了安装Node.js/Express.js服务器所需的时间。</p>
<h2>内嵌样式和CSS导入</h2>
<p>在React中引入样式的传统CSS-in-CSS方法已经存在了几十年，并与React组件一起工作。使用这种方法，所有的样式表都进入一个<code>stylesheets</code>目录，并将所需的CSS导入组件。</p>
<p>然而，当现在使用组件时，样式表不再有意义。React鼓励开发人员从组件的角度考虑应用程序，而样式表迫使您从文档的角度考虑应用程序。</p>
<p>各种其他方法将CSS和JavaScript代码合并到一个文件中。内嵌样式可能是其中最受欢迎的:</p>
<pre>import React from 'react';

const divStyle = {
  margin: '40px',
  border: '5px solid pink'
};
const pStyle = {
  fontSize: '15px',
  textAlign: 'center'
};

const TextBox = () =&gt; (
  &lt;div style={divStyle}&gt;
    &lt;p style={pStyle}&gt;Yeah!&lt;/p&gt;
  &lt;/div&gt;
);

export default TextBox;
</pre>
<p>您不必再导入CSS，但是您牺牲了可读性和可维护性。</p>
<p>除此之外，内联样式不支持媒体查询、伪类、伪元素和样式回退。当然，有一些方法可以让你做其中的一些，但是并不那么方便。</p>
<p>这就是JSS CSS派上用场的地方，内联样式并不完全是JSS CSS。下面的代码使用<code>styled-components</code>演示了这个概念:</p>
<pre>import styled from 'styled-components';

const Text = styled.div`
  color: white,
  background: black
`
&lt;Text&gt;This is CSS-in-JS&lt;/Text&gt;
</pre>
<p>浏览器看到的大概是这样的:</p>
<pre>&lt;style&gt;
.hash234dd2 {
  background-color: black;
  color: white;
}
&lt;/style&gt;

&lt;p class="hash234dd3"&gt;This is CSS-in-JS&lt;/p&gt;
</pre>
<p>一个新的<code>&lt;style&gt;</code>标签被添加到DOM的顶部，并且与内联样式不同，实际的CSS样式在这里生成。所以，任何在CSS中有效的东西在<code>styled-components</code>中也有效。</p>
<p>此外，这种技术增强了CSS，提高了可读性，并且适合组件架构。使用<code>styled-components</code>库，您还可以获得捆绑到库中的SASS支持。</p>
<h2>React中可以嵌套三元运算符吗？</h2>
<p>React中流行三元运算符；它是我创建条件语句的首选操作符，在<code>render()</code>方法中非常好用。</p>
<p>例如，它们帮助您以内联方式呈现元素。在下面的例子中，我用它来显示登录状态:</p>
<pre>render() {
  const isLoggedIn = this.state.isLoggedIn;
  return (

      The user is {isLoggedIn ? 'currently' : 'not'} logged in.

  );
}
</pre>
<p>但是，当您一次又一次地嵌套三元运算符时，它们可能会变得难看和难以阅读:</p>
<pre>int median(int a, int b, int c) {
    return (a&lt;b) ? (b&lt;c) ? b : (a&lt;c) ? c : a : (a&lt;c) ? a : (b&lt;c) ? c : b;
}
</pre>
<p>正如您所看到的，简写符号更紧凑，但是它们使代码看起来混乱。现在，想象一下如果你的结构中有十几个或者更多的嵌套ternaries(这比你想象的要经常发生)。</p>
<p>一旦开始使用条件操作符，就很容易继续嵌套它，直到您决定需要一种更好的技术来处理条件呈现。</p>
<p>但是，好的一面是你有很多选择。你可以使用一个像JSX控制语句这样的巴别塔插件来扩展JSX，以包含条件语句和循环的组件:</p>
<pre>// before transformation
&lt;If condition={ test }&gt;
  &lt;span&gt;Truth&lt;/span&gt;
&lt;/If&gt;

// after transformation
{ test ? &lt;span&gt;Truth&lt;/span&gt; : null }
</pre>
<p>还有一种流行的技术叫做即时调用函数表达式(IIFE)。这是一个匿名函数，在定义后立即调用:</p>
<pre>(function() {
 // Do something
 }
)()
</pre>
<p>我们将函数放在一对括号中，使匿名函数成为函数表达式。这种模式在JavaScript中很流行，但是在React中，您可以将所有if/else语句放在函数中，并返回您想要呈现的任何内容。</p>
<p>这里有一个例子演示了我们将如何在React中使用IFFE:</p>
<pre>{
   (() =&gt; {
      if (this.props.status === 'PENDING') {
         return (&lt;div className="loading" /&gt;);
      }
      else {
         return (&lt;div className="container" /&gt;);

   })()
} 
</pre>
<p>React中有更多的方法来运行条件语句，我们已经在React 中的<a href="https://blog.logrocket.com/conditional-rendering-in-react-c6b0e5af381e"> 8条件渲染方法中介绍过。</a></p>
<h2>闭包在React中有用吗？</h2>
<p>闭包是可以访问外部函数的变量和参数的内部函数。闭包在JavaScript中无处不在，无论您是否意识到，您可能都使用过它们:</p>
<pre>class SayHi extends Component {

render () {
 return () {
  &lt;Button onClick={(e) =&gt; console.log('Say Hi', e)}&gt;
    Click Me
  &lt;/Button&gt;
 }
}
}
</pre>
<p>但是当你在<code>render()</code>方法中使用闭包时，这实际上是不好的。每当<code>SayHi</code>组件呈现时，一个新的匿名函数被创建并传递给<code>Button</code>组件。</p>
<p>虽然道具没变，<code>&lt;Button /&gt;</code>还是会被强制重新渲染。如前所述，浪费的渲染会对性能产生直接影响。</p>
<p>相反，用一个类方法代替闭包，这样可读性更好，也更容易调试:</p>
<pre>class SayHi extends Component {

  showHiMessage = (e) =&gt; {
    console.log('Say Hi', e)
  };

  render () {
   return () {
      &lt;Button onClick={this.showHiMessage}&gt;
          Click Me
      &lt;/Button&gt;
   }
  }
}
</pre>
<p>对于函数组件，作为属性传递给子组件的函数也会导致重新呈现，不管子组件是否被记忆。在这种情况下，我们使用<code>useCallback</code>钩子来记忆渲染之间的函数:</p>
<pre>const showHiMessage = React.useCallback((e) =&gt; console.log('Say Hi', e), []);
</pre>
<h2>结论</h2>
<p>当一个平台成长时，每天都会出现新的模式。一些模式有助于您改进整个工作流程，而另一些则有明显的副作用。</p>
<p>当副作用影响应用程序的性能或损害可读性时，寻找替代方法可能是个更好的主意。在这篇文章中，我介绍了React中的一些实践，由于它们的缺点，你可以避免这些实践。</p>
<p>你对React有什么看法，React的最佳实践是什么？请在评论中分享它们。</p>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
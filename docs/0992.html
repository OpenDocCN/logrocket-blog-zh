<html>
<head>
<title>Roll your own dependency injection - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>滚动你自己的依赖注入-日志火箭博客</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/roll-your-own-dependency-injection/#0001-01-01">https://blog.logrocket.com/roll-your-own-dependency-injection/#0001-01-01</a></blockquote><div><article class="article-post">
<p>你有没有尝试过使用依赖注入(DI)框架，却被它们的复杂性和按照你的意愿改变它们的困难所击倒？使用一些流行的DI库，如果您认为这是火箭科学的一个分支，那也是情有可原的。</p>
<p>嗯，我想表明创建或使用阿迪图书馆并不像你想象的那样复杂或困难。在经历了几个流行的DI框架而没有得到我想要的东西之后，我决定自己写一个。</p>
<p>在这篇博文中，我将向您展示在阿迪图书馆中，用不到300行代码(其中许多是日志和注释)的TypeScript可以实现什么。</p>
<p>我为我在<a href="https://www.data-forge-notebook.com/"> Data-Forge Notebook </a>中使用的TypeScript创建了自己的DI库，它运行在Electron上，具有使用React构建的用户界面。我希望阿迪库能够很好地为React和泛型类型脚本代码工作，我希望它易于理解和使用，但仍然非常灵活。</p>
<p>我现在已经开源了我的DI库，它叫做Fusion。你可以在<a href="https://www.npmjs.com/package/@codecapers/fusion"> npm </a>和<a href="https://github.com/ashleydavis/fusion"> GitHub </a>上找到。请下载该代码的副本，这样您就可以阅读这篇博文了。</p>
<h2>什么是依赖注入？</h2>
<p>随着应用程序的增长和复杂性的增加，您是否曾经努力保持应用程序的正常运行？</p>
<p>所有软件都是由以特定方式连接在一起的交互组件组成的。随着交互组件数量的增长，组件之间的布线和连接数量呈指数增长(这种现象称为<a href="https://en.wikipedia.org/wiki/Metcalfe%27s_law">梅特卡夫定律</a>)。</p>
<p>你真的想自己处理那些复杂的线路吗？这就是自动化依赖注入将为您做的事情。</p>
<p>依赖注入是一种<a href="https://en.wikipedia.org/wiki/Software_design_pattern">设计模式</a>，用于自动连接复杂应用程序的组件。这在将依赖关系写入复杂的用户界面层次结构时特别有用，您可以在查看图1后想象这种情况。</p>
<figure id="attachment_21630" aria-describedby="caption-attachment-21630" class="wp-caption aligncenter"><img data-attachment-id="21630" data-permalink="https://blog.logrocket.com/roll-your-own-dependency-injection/di-and-ui-hierarchy/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/07/di-and-ui-hierarchy.png" data-orig-size="620,500" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Using DI to directly wire dependencies to the UI" data-image-description="" data-image-caption="&lt;p&gt;Figure 1: Using dependency injection to directly wire dependencies through to a deep and complex UI component hierarchy.&lt;/p&gt;&#10;" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/07/di-and-ui-hierarchy-300x242.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/07/di-and-ui-hierarchy.png" decoding="async" class="size-full wp-image-21630 jetpack-lazy-image" src="../Images/6fecff7e8cedef71e32915c9667f1ad6.png" alt="Using DI To Directly Wire Dependencies To The UI" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2020/07/di-and-ui-hierarchy.png 620w, https://blog.logrocket.com/wp-content/uploads/2020/07/di-and-ui-hierarchy-300x242.png 300w" data-lazy-sizes="(max-width: 620px) 100vw, 620px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2020/07/di-and-ui-hierarchy.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/07/di-and-ui-hierarchy.png"/><noscript><img data-lazy-fallback="1" data-attachment-id="21630" data-permalink="https://blog.logrocket.com/roll-your-own-dependency-injection/di-and-ui-hierarchy/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/07/di-and-ui-hierarchy.png" data-orig-size="620,500" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Using DI to directly wire dependencies to the UI" data-image-description="" data-image-caption="&lt;p&gt;Figure 1: Using dependency injection to directly wire dependencies through to a deep and complex UI component hierarchy.&lt;/p&gt;&#10;" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/07/di-and-ui-hierarchy-300x242.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/07/di-and-ui-hierarchy.png" decoding="async" loading="lazy" class="size-full wp-image-21630" src="../Images/6fecff7e8cedef71e32915c9667f1ad6.png" alt="Using DI To Directly Wire Dependencies To The UI" srcset="https://blog.logrocket.com/wp-content/uploads/2020/07/di-and-ui-hierarchy.png 620w, https://blog.logrocket.com/wp-content/uploads/2020/07/di-and-ui-hierarchy-300x242.png 300w" sizes="(max-width: 620px) 100vw, 620px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/07/di-and-ui-hierarchy.png"/></noscript><figcaption id="caption-attachment-21630" class="wp-caption-text">Figure 1: Using dependency injection to directly wire dependencies through to a deep and complex UI component hierarchy.</figcaption></figure>
<h2>为什么要使用依赖注入？</h2>
<p>依赖注入非常有用，原因有很多:</p>
<ul>
<li>依赖关系的使用和依赖关系的解决是分开的</li>
<li>它鼓励<a href="https://en.wikipedia.org/wiki/Separation_of_concerns">分离关注点</a>和<a href="https://en.wikipedia.org/wiki/Loose_coupling">组件之间的松散耦合</a></li>
<li>它自动化了应用程序中组件的连接，否则这项任务会非常复杂</li>
<li>单元测试更容易模仿依赖关系</li>
<li>它促进了组件的快速重组，这使得重构更快更安全</li>
<li>它允许抽象，这有助于跨多个平台、环境或流程类型重用相同的代码库</li>
<li>它可以用来集中或外部化您的应用程序的配置，尽管这不是Fusion在现阶段所支持的</li>
</ul>
<p>依赖注入也是一种简洁优雅的构建应用程序的方式。使用DI，您将花更少的时间关注系统布线，花更多的时间开发特性。</p>
<h2>有哪些替代方案？</h2>
<p>在开始编写自己的代码库之前，您应该首先考虑替代方案。我们还能如何连接依赖关系？</p>
<p>我们可以在代码中需要依赖的地方直接创建它们，而不是注入依赖。但是，我们不想这么做，因为这意味着我们不能共享依赖项，而且也不可能用模拟版本来替换单元测试的依赖项。</p>
<p>另一种选择是直接访问<a href="https://en.wikipedia.org/wiki/Singleton_pattern">单态</a>，但是这与添加硬链接全局变量具有完全相同的结果。</p>
<p>您可能喜欢的DI的一个更简单的替代方案叫做<a href="https://en.wikipedia.org/wiki/Service_locator_pattern">服务定位器模式</a>。它类似于DI，但自动化程度要低得多。如果您认为DI太复杂，它仍然是一个很好的开始模式。</p>
<p>当然，您可以使用大量现有的DI库。<a href="https://www.npmjs.com/search?q=dependency%20injection">刚刚搜了npm </a>发现了1778个包！这里肯定有我能用的东西吧？</p>
<p>嗯，就像我说的，我尝试了一些流行的图书馆，发现他们有所欠缺。它们通常非常复杂，很难满足您的需求。</p>
<p>我想要更简单的东西。我希望阿迪图书馆能让我按照自己的方式工作。这就是我创造核聚变的原因。现在我想展示一下，开发自己简单的DI库并不困难。</p>
<h2>使用类型脚本装饰器的依赖注入</h2>
<p>Fusion建立在<a href="https://www.typescriptlang.org/docs/handbook/decorators.html">TypeScript decorator</a>和<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy"> JavaScript <code>Proxy</code>类</a>之上。它为每个类创建一个代理来拦截对<a href="https://en.wikipedia.org/wiki/Constructor_(object-oriented_programming)">构造函数</a>的调用。就在构造对象之后，但就在对象被返回供调用者使用之前，代理自动注入依赖关系。</p>
<p>例如，我们将使用一个名为<code>SetupWindow</code>的React组件。图2显示了依赖注入系统如何为我们的类提供属性值。这是一个简单但真实的例子，取自数据伪造笔记本。请注意，Fusion可以与任何TypeScript类一起工作——我正在用React进行演示，以表明这是可以做到的。</p>
<figure id="attachment_21631" aria-describedby="caption-attachment-21631" class="wp-caption aligncenter"><img data-attachment-id="21631" data-permalink="https://blog.logrocket.com/roll-your-own-dependency-injection/dependency-injection/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/07/dependency-injection.png" data-orig-size="730,347" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="DI automatically provides values for certain properties" data-image-description="" data-image-caption="&lt;p&gt;Figure 2: Dependency injection automatically provides values for certain properties in our classes.&lt;/p&gt;&#10;" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/07/dependency-injection-300x143.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/07/dependency-injection.png" decoding="async" class="size-full wp-image-21631 jetpack-lazy-image" src="../Images/a0899a809fe38eba532b7e73e23b5d7d.png" alt="DI Automatically Provides Values For Certain Properties" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2020/07/dependency-injection.png 730w, https://blog.logrocket.com/wp-content/uploads/2020/07/dependency-injection-300x143.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2020/07/dependency-injection.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/07/dependency-injection.png"/><noscript><img data-lazy-fallback="1" data-attachment-id="21631" data-permalink="https://blog.logrocket.com/roll-your-own-dependency-injection/dependency-injection/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/07/dependency-injection.png" data-orig-size="730,347" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="DI automatically provides values for certain properties" data-image-description="" data-image-caption="&lt;p&gt;Figure 2: Dependency injection automatically provides values for certain properties in our classes.&lt;/p&gt;&#10;" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/07/dependency-injection-300x143.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/07/dependency-injection.png" decoding="async" loading="lazy" class="size-full wp-image-21631" src="../Images/a0899a809fe38eba532b7e73e23b5d7d.png" alt="DI Automatically Provides Values For Certain Properties" srcset="https://blog.logrocket.com/wp-content/uploads/2020/07/dependency-injection.png 730w, https://blog.logrocket.com/wp-content/uploads/2020/07/dependency-injection-300x143.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/07/dependency-injection.png"/></noscript><figcaption id="caption-attachment-21631" class="wp-caption-text">Figure 2: Dependency injection automatically provides values for certain properties in our classes.</figcaption></figure>
<h3>将类标记为可注入</h3>
<p>首先，我们必须能够标记一个用于注入的类。清单1显示了示例<code>SetupWindow</code>类。我们使用<code>InjectClass</code>装饰器将类标记为可注入的。这个装饰器创建了代理构造函数。</p>
<p>接下来在清单1中，我们使用<code>InjectProperty</code> decorator来标记要注入的类的属性。为了简单起见，<a href="https://softwareengineering.stackexchange.com/questions/365339/what-is-wrong-with-magic-strings">神奇字符串</a>用于标识要注入的依赖项。</p>
<p>如果你对魔法线的使用有异议，请不要担心；我只是想暂时保持事情简单，然后在这篇文章的最后，我会给你一个更好的解决方案。</p>
<p>在这个例子中，<code>log</code>和<code>toast</code>属性被注入了依赖关系，这些依赖关系是接口<code>ILog</code>和<code>IToast</code>的实现。然后，对于类的其余部分——至少在构造函数之后——我们可以利用这些属性，例如，在它们上面调用函数。</p>
<h5><em>清单1:将一个类标记为可注入的</em></h5>
<pre>import { InjectableClass, InjectProperty } from "@codecapers/fusion"

@InjectableClass()
export class SetupWindow extends React.Component&lt;{},{}&gt; {

    @InjectProperty("ILog")
    log!: ILog;

    @InjectProperty("IToast")
    toast!: IToast;

    constructor(props: any) {
        super(props); 

// ... dependencies can't be used in the constructor ...    
    }

    someFunction(): void {
        // Make use of dependencies.
        this.log.info("All went well.");

        this.toast.success("Operation was a success!");
    }

    // ... other code goes here ...
}</pre>
<p>有没有注意到每个楼盘名字后面的感叹号？这样TypeScript就不会给我们关于未初始化变量的警告。从编译器的角度来看，这些属性从来没有真正初始化过。它们当然会，但是TypeScript不知道这一点，所以我们使用感叹号来隐藏TypeScript的警告。</p>
<p>这就是要使一个类可注射所需要做的一切。现在，当您实例化这个类时(如清单2所示)，代理构造函数被调用，依赖关系被自动解析。</p>
<h5><em>清单2:在TSX文件中实例化一个React组件</em></h5>
<pre>&lt;SetupWindow /&gt;</pre>
<p>或者，如果您使用的是普通的TypeScript类而不是React组件，您可以用清单3所示的<code>new</code>关键字进行实例化。无论哪种方式，代理构造函数都会自动解析依赖关系。</p><div class="code-block code-block-54">
<hr/>
<h3>更多来自LogRocket的精彩文章:</h3>

<hr/></div>
<h5><em>清单3:用新关键字</em>实例化一个常规的类型脚本</h5>
<pre>const window = new SetupWindow();</pre>
<h3>记录可注射性</h3>
<p>装饰者将属性标记为可注入的。您可以在清单4中看到它的代码。</p>
<p><code>InjectProperty</code>是一个函数，它被传递了将要注入的依赖项的ID。这是一个创建装饰器的工厂函数。清单4中的内部函数实际上是装饰器，每个标记了它的属性都会调用它。</p>
<p>我们记录可注入的属性，以便以后构造类的实例时可以解析它们。<code>__injections__</code>数组附加到类的原型上，收集属性注入所需的细节(属性名和依赖ID)。</p>
<h5><em>清单4:记录可注入属性的TypeScript装饰器</em></h5>
<pre>export function InjectProperty(dependencyId: string): Function {
    // Returns a function that is invoked for the property that is to be injected.
    return (prototype: any, propertyName: string): void =&gt; {
        if (!prototype.__injections__) {
            // Record properties to be injected against the constructor prototype.
            prototype.__injections__ = [];
        }

        // Record injections to be resolved later when an instance is created.
        prototype.__injections__.push([ propertyName, dependencyId ]);
    };
}</pre>
<h3>使一个类可注入</h3>
<p>装饰者将一个类标记为可注入的。您可以在清单5中看到它的代码。同样，这是一个产生实际装饰器的工厂函数。它不需要任何参数，所以从技术上来说，我们并不真正需要工厂函数，但在Fusion中与其他装饰器保持一致是很好的。</p>
<p><code>InjectableClass</code>返回<code>makeConstructorInjectable</code>；这个函数是实际的装饰器。它不是一个匿名函数，就像我们在清单4中使用的那样。相反，这个函数有一个名字，因为我们希望在Fusion内部重用它。</p>
<h5><em>清单5:使类可注入的TypeScript装饰器</em></h5>
<pre>//
// TypeScript decorator: Marks a class as injectable.
//
export function InjectableClass(): Function {
    // Returns a factory function that creates a proxy constructor.
    return makeConstructorInjectable;
}</pre>
<h3>代理可注射对象</h3>
<p>为了让依赖注入自动发生，我们需要为原始构造函数创建一个代理。我们将其包装在一个JavaScript <code>Proxy</code>实例中，如图3所示。<code>proxyHandler</code>的<code>construct</code>函数拦截对原始构造函数的调用，这样我们就可以插入我们自己的定制逻辑。</p>
<figure id="attachment_21633" aria-describedby="caption-attachment-21633" class="wp-caption aligncenter"><img data-attachment-id="21633" data-permalink="https://blog.logrocket.com/roll-your-own-dependency-injection/proxy-function/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/07/proxy-function.png" data-orig-size="730,222" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Using a JS proxy instance" data-image-description="" data-image-caption="&lt;p&gt;Figure 3: Using a JavaScript Proxy instance to interface calls to the original constructor.&lt;/p&gt;&#10;" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/07/proxy-function-300x91.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/07/proxy-function.png" decoding="async" class="size-full wp-image-21633 jetpack-lazy-image" src="../Images/56b91bcf4d6a9278477c62e859f496b1.png" alt="Using A JS Proxy Instance" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2020/07/proxy-function.png 730w, https://blog.logrocket.com/wp-content/uploads/2020/07/proxy-function-300x91.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2020/07/proxy-function.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/07/proxy-function.png"/><noscript><img data-lazy-fallback="1" data-attachment-id="21633" data-permalink="https://blog.logrocket.com/roll-your-own-dependency-injection/proxy-function/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/07/proxy-function.png" data-orig-size="730,222" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Using a JS proxy instance" data-image-description="" data-image-caption="&lt;p&gt;Figure 3: Using a JavaScript Proxy instance to interface calls to the original constructor.&lt;/p&gt;&#10;" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/07/proxy-function-300x91.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/07/proxy-function.png" decoding="async" loading="lazy" class="size-full wp-image-21633" src="../Images/56b91bcf4d6a9278477c62e859f496b1.png" alt="Using A JS Proxy Instance" srcset="https://blog.logrocket.com/wp-content/uploads/2020/07/proxy-function.png 730w, https://blog.logrocket.com/wp-content/uploads/2020/07/proxy-function-300x91.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/07/proxy-function.png"/></noscript><figcaption id="caption-attachment-21633" class="wp-caption-text">Figure 3: Using a JavaScript Proxy instance to interface calls to the original constructor.</figcaption></figure>
<p>清单6展示了<code>makeConstructorInjectable</code>函数如何创建代理构造函数。它唯一的参数是<code>origConstructor</code>。顾名思义，这是我们需要代理的类的原始构造函数。</p>
<h5><em>清单6:创建代理构造函数来处理自动注入</em></h5>
<pre>//
// Takes a constructor and makes it 'injectable'.
// Wraps the constructor in a proxy that handles injecting dependencies.
//
function makeConstructorInjectable(origConstructor: Function): Function {

    if (!origConstructor.prototype.__injections__) {
        // Record properties to be injected against the constructor prototype.
        origConstructor.prototype.__injections__ = []; 
    }

    const proxyHandler = {  
        // Intercepts the call to the original class constructor.
        construct(target: any, args: any[], newTarget: any) {
        // ... body of this function shown in listing 7 ...
        }
    };

    // Wrap the original constructor in a proxy.
    // Use the proxy to inject dependencies.
    // Returns the proxy constructor to use in place of the original constructor.
    return new Proxy(origConstructor, proxyHandler);
}</pre>
<p>清单7显示了拦截对原始构造函数调用的<code>construct</code>函数。我们使用函数<code><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Reflect/construct">Reflect.construct</a></code>调用目标构造函数并实例化对象。这就像使用<code>new</code>关键字来创建一个对象，但它是专门为代理而设计的。</p>
<h5><em>清单7:拦截对原始类构造函数的调用以解决依赖关系</em></h5>
<pre>construct(target: any, args: any[], newTarget: any) {


    // Construct the object ...
    const obj = Reflect.construct(target, args, newTarget);

    try {
        // ... and then resolve property dependencies.
        const injections = origConstructor.prototype.__injections__ ;
        resolvePropertyDependencies(obj, injections);
    }
    catch (err) {
        // ... log the error ...
        throw err;
    }

    return obj;
}</pre>
<h3>解决依赖关系</h3>
<p>在构建目标对象之后，通过调用<code>resolvePropertyDependencies</code>注入依赖关系，如清单8所示。没什么大不了的——它只是在注入集合上循环，依次实例化和注入每一个。</p>
<h5><em>清单8:解析实例化对象的依赖关系</em></h5>
<pre>function resolvePropertyDependencies(obj: any, injections: any[]): void {

    if (injections) {
        for (const injection of injections) {
            const dependencyId = injection[1];

            // Creates a new dependency instance or reuses the existing one.
            const singleton = instantiateSingleton(dependencyId);
            if (!singleton) {
                throw new Error("Failed to instantiate singleton " + dependencyId);
            }

            const propertyName = injection[0];

            // Inject the dependency into the object.
            obj[propertyName] = singleton; 
        }
    }
}</pre>
<p>要注入的依赖项是通过调用<code>instantiateSingleton</code>创建的。顾名思义,“singleton”将只创建依赖关系的一个实例；它随后被缓存和重用。</p>
<p>如果您将清单8与Fusion中的实际代码进行比较，您会注意到一个差异。实际代码比清单8要复杂一些。有更多的代码，因为它检测依赖项之间的循环引用。如果不这样做，它可能会陷入循环。相反，它可以中断循环并报告错误。</p>
<h3>动态实例化单例</h3>
<p>您可以在清单9中看到<code>instantiateSingleton</code>函数。注意<code>singletonConstructors</code>和<code>instantiatedSingletons</code>。第一个是一个查找表，包含我们的依赖项的构造函数。第二个是已经创建并可以重用的依赖项的查找表。</p>
<p>在清单9中，我们重用了函数<code>makeConstructorInjectable</code>来使这些延迟实例化的单例元素本身是可注入的。所以我们的单例也可以包含注入依赖。</p>
<h5><em>清单9:实例化单例(或者重用先前创建的单例)</em></h5>
<pre>//
// Constructors that can be called to instantiate singletons.
//
const singletonConstructors = new Map&lt;string, Function&gt;();

//
// Collection of all singletons objects that can be injected.
//
const instantiatedSingletons = new Map&lt;string, any&gt;();

export function instantiateSingleton&lt;T = any&gt;(dependencyId: string): T {
    try {
        const existingSingleton = instantiatedSingletons.get(dependencyId);
        if (existingSingleton) {
            // The singleton has previously been instantiated.
            return existingSingleton;
        }


        const singletonConstructor = singletonConstructors.get(dependencyId);
        if (!singletonConstructor) {
            // The requested constructor was not found. 
            const msg = "No constructor found for singleton " + dependencyId;
            throw new Error(msg);
        }


        // Construct the singleton.
        const instantiatedSingleton = 
            Reflect.construct(makeConstructorInjectable(singletonConstructor), []);

        // Cache the instantiated singleton for later reuse.
        instantiatedSingletons.set(dependencyId, instantiatedSingleton);
        return instantiatedSingleton;
    }
    catch (err) {
        log.error("Failed to instantiate singleton " + dependencyId);
        log.error(err &amp;&amp; err.stack || err);
        throw err;
    }
}</pre>
<h3>手动注册单件</h3>
<p>剩下的问题是，我们如何指定实例化成单例的类？</p>
<p>有两种方法。第一种是通过调用<code>registerSingleton</code>手动注册。清单10中有一个这样的例子。</p>
<h5><em>清单10:手动注册单例</em></h5>
<pre>registerSingleton("IToast", new ToastService());</pre>
<p>手动注册适用于:</p>
<ol>
<li>对初始化顺序的明确控制</li>
<li>通过构造函数参数指定输入</li>
<li>根据情况提供不同的实现</li>
</ol>
<p>当您需要抽象出不同平台或流程之间的差异时，上面的第3点非常有用。例如，Data-Forge Notebook是一个电子应用程序，它的代码在不同类型的进程中运行，这些进程有很大的不同。有主进程和渲染器进程，此外，我还添加了一个单独的Node.js进程，用于在后台评估用户代码。</p>
<p>一些依赖项的实现必然是不同的，这取决于它们必须运行的流程。然而，大部分代码可以在任何进程上运行而无需修改。因此，在少数情况下，为每个流程手动注册不同的实现是有用的。这有助于抽象出进程之间的差异，并允许我在所有进程之间使用一组公共代码。</p>
<p>清单11展示了<code>registerSingleton</code>的实现。它只是记录单例实例，以便以后可以作为依赖项注入。</p>
<h5><em>清单11:记录先前实例化的单例</em></h5>
<pre>//
// Manually registers a singleton.
//
export function registerSingleton(dependencyId: string, singleton: any): void {
    instantiatedSingletons.set(dependencyId, singleton);
}</pre>
<h3>自动注册单件</h3>
<p>手动注册单例是有用的，有时也是必要的。然而，大多数时候，一个singleton只会有一个实现，我们并不关心初始化的顺序。</p>
<p>为应用程序中的组件获得正确的初始化顺序是一件棘手的事情，过去也是许多错误的来源。然而，通过自动化依赖注入，我们可以在需要注入的时候自动创建我们的单例。</p>
<p>这自动解决了应用程序中大多数组件的初始化顺序问题。这样，我们就摆脱了担心应用程序连线的束缚。相反，我们可以专注于向客户提供功能。</p>
<p>装饰器<code>InjectableSingleton</code>用于将待<a href="https://en.wikipedia.org/wiki/Lazy_initialization">惰性初始化的</a>类标记为单例。清单12展示了如何用它来注释我们将在应用程序中用来显示祝酒词的<code>Toast</code>类。</p>
<h5><em>清单12:为惰性初始化和自动注入注册单例</em></h5>
<pre>@InjectableSingleton("IToast")
export class Toast implements IToast {
    // ...
}</pre>
<p>清单13中的<code>InjectableSingleton</code>的实现类似于我们见过的其他装饰器。同样，这是一个返回实际装饰者的工厂函数。内部函数为每个单例类调用，并传递给单例类的构造函数。这里，我们简单地记录依赖ID的构造函数，以便在以后第一次需要它时可以实例化它。</p>
<h5><em>清单13:一个TypeScript decorator，它标记了一个类A，一个惰性初始化的singleton </em></h5>
<pre>//
// TypeScript decorator: Marks a class as an automatically 
// created singleton that's available for injection.
//
export function InjectableSingleton(dependencyId: string): Function {
    // Returns a factory function that records the constructor of the class so that
    // it can be lazily created later as a singleton when required as a dependency.
    return (target: Function): void =&gt; {
        // Adds the singleton constructor to the set of singletons.
        singletonConstructors.set(dependencyId, target);
    }
}</pre>
<h3>惰性初始化单例</h3>
<p>清单14中要看的最后一段代码是实例化singleton的代码。就在第一次需要单例之前，函数<code>instantiateSingleton</code>被延迟调用。创建完成后，单件将被缓存，以便将来可以重用。</p>
<h5><em>清单14:“及时”实例化单例的代码</em></h5>
<pre>//
// Constructors that can be called to instantiate singletons.
//
const singletonConstructors = new Map&lt;string, Function&gt;();

//
// Collection of all singletons objects that can be injected.
//
const instantiatedSingletons = new Map&lt;string, any&gt;();

//
// Instantiates a singleton.
// If it's already instantiated then the original is returned instead.
//
export function instantiateSingleton&lt;T = any&gt;(dependencyId: string): T {

    const existingSingleton = instantiatedSingletons.get(dependencyId);
    if (existingSingleton) {
        // The singleton has previously been instantiated.
        return existingSingleton;
    }

    const singletonConstructor = singletonConstructors.get(dependencyId);
    if (!singletonConstructor) {
        // The requested constructor was not found. 
        throw new Error(/* Error message omitted */);
    }

    // Construct the singleton.
    const instantiatedSingleton =
        Reflect.construct(makeConstructorInjectable(singletonConstructor), []);


    // Cache the instantiated singleton for later reuse.
    instantiatedSingletons.set(dependencyId, instantiatedSingleton);


    return instantiatedSingleton;
}</pre>
<h2>更进一步</h2>
<p>那么，我们该何去何从呢？在推进这项工作时，我们应该考虑一些事情。</p>
<h3>等等，单身族不好吗？</h3>
<p>通过这一切，你可能会想，“单身族不是最好避免的吗？”</p>
<p>一般来说，是的。与我们的代码硬链接的普通全局单例非常糟糕，因为它们鼓励组件之间的紧密耦合，它们降低了我们进行单元测试的能力，并且它们使得快速重新连接我们的应用程序变得困难。</p>
<p>然而，依赖注入解决了这些问题，并允许我们使用单例，消除了不好的部分:</p>
<ul>
<li>DI鼓励关注点的分离和松散耦合</li>
<li>DI增加了我们进行单元测试的能力</li>
<li>DI使得重写我们的应用程序来支持快速重构变得更加容易</li>
</ul>
<p>简而言之，DI使得单例变得可行。</p>
<h3>集装箱在哪里？</h3>
<p>依赖注入是一种设计模式，它是控制反转原则的实现。IoC库通常带有一个容器。所以你可能想知道容器在哪里。</p>
<p>Fusion中的“容器”是隐式的、全局的。这并不适合所有人，你可能会想讨论拥有一个显式容器的好处。</p>
<p>然而，一旦我决定放弃容器的明确概念，我发现它极大地简化了编写DI库的工作。DI库也更容易使用，因为不需要配置容器。</p>
<p>接下来我发现我根本不需要容器！我已经在Fusion上构建了几个大型应用程序(包括极其复杂的Data-Forge Notebook代码库)。我从来没有抱怨过缺少一个容器。</p>
<p>聚变是从实际考虑中诞生的。它随着我的需求而增长，我只添加必要的功能。将来我可能会添加更多的通用特性，但驱动目标永远是简单。我用一般换取了简单，我不后悔。</p>
<h3>消除魔法字符串</h3>
<p>如果您对用于标识依赖关系的神奇字符串有异议(谁不会呢？)，那么您可以通过在变量中存储和重用ID来轻松地消除它们。让我们考虑一个关于日志单例的例子。</p>
<p>假设我们如清单15所示定义了我们的<code>ILog</code>接口。然后我们可以用一个<code>id</code>变量来扩展<code>ILog </code>名称空间。然后，我们可以使用该变量代替魔术字符串，如清单16所示。这演示了一个简单的方法来删除魔术字符串，它完全在你的控制之下。</p>
<h5><em>清单15:用一个<code>id</code>变量</em>扩展<code>ILog</code>名称空间</h5>
<pre>interface ILog {
    info(msg: string): void;
}

//
// Extend the ILog namespace to with an id variable.
//
namespace ILog {
    export const id = "ILog";
}</pre>
<h5><em>清单16:使用<code>id</code>变量代替神奇的字符串</em></h5>
<pre>@InjectableClass()
export class MyClass {

    @InjectProperty(ILog.id)
    log!: ILog;

    // ... code omitted ...
}</pre>
<h3>确保类型安全</h3>
<p>对于那些想知道如何使依赖注入类型安全的人，请放心，您可以更进一步。</p>
<p>多亏了来自<a href="https://twitter.com/hediet_dev"> @hediet_dev </a>的有价值的输入(请阅读<a href="https://twitter.com/ashleydavis75/status/1272450417444585476">在Twitter上的对话</a>)，还可以使用tslint创建一个规则来加强类型安全。要深入研究这个问题，请参见<a href="https://github.com/ashleydavis/fusion/blob/master/README.md">GitHub上的Fusion自述文件</a>。</p>
<h2>未来的增强</h2>
<p>Fusion缺少的唯一一点我仍然想添加的是构造函数参数的自动注入。目前，注入只对类属性有效，但是如果能扩展到包括构造函数参数就更好了。所以请关注这个空间——构造函数参数的注入可能会在未来出现。</p>
<h2>结论</h2>
<p>在这篇博文中，我展示了构建自己的DI代码库并不困难。事实上，我已经展示了一个健壮、灵活且易于使用的系统可以用不到300行代码来交付。</p>
<p>构建自己的系统的好处是，你可以让它按照你想要的方式工作，这样它就可以完美地满足你的项目需求。</p>
<p>我鼓励任何人尝试建立他们自己的DI图书馆，这至少是一次很好的学习经历！否则，请随意派生Fusion代码，然后进行自己的改进，创建自己的定制，或者只是享受乐趣并尝试它！</p>
<h2>资源</h2>

<p><a href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener"> LogRocket </a>:全面了解您的生产React应用</p><div class="code-block code-block-17">
<div class="blog-plug inline-plug react-plug" vwo-el-id="26283398190">
<h2 vwo-el-id="41600691720">调试React应用程序可能很困难，尤其是当用户遇到难以重现的问题时。如果您对监视和跟踪Redux状态、自动显示JavaScript错误以及跟踪缓慢的网络请求和组件加载时间感兴趣，</h2><p>. </p><a href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" vwo-el-id="19356441070">try LogRocket</a><p>LogRocket 结合了会话回放、产品分析和错误跟踪，使软件团队能够创建理想的web和移动产品体验。这对你来说意味着什么？</p><a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="19356441380">
<img class="first-react-image alignnone size-full wp-image-46 jetpack-lazy-image jetpack-lazy-image--handled" src="../Images/f300c244a1a1cf916df8b4cb02bec6c6.png" vwo-el-id="18272717540" data-lazy-loaded="1" data-original-src="https://files.readme.io/27c94e7-Image_2017-06-05_at_9.46.04_PM.png"/>
</a>
<a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="19356441690">
<img class="second-react-image alignnone size-full wp-image-46 jetpack-lazy-image jetpack-lazy-image--handled" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" vwo-el-id="30720362350" data-lazy-loaded="1" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/>
</a>
<p vwo-el-id="28675660440" class="">LogRocket不是猜测错误发生的原因，也不是要求用户提供截图和日志转储，而是让您回放问题，就像它们发生在您自己的浏览器中一样，以快速了解哪里出错了。</p>
<p>不再有嘈杂的警报。智能错误跟踪允许您对问题进行分类，然后从中学习。获得有影响的用户问题的通知，而不是误报。警报越少，有用的信号越多。</p>
<p>LogRocket Redux中间件包为您的用户会话增加了一层额外的可见性。LogRocket记录Redux存储中的所有操作和状态。</p>
<p vwo-el-id="28675660750">现代化您调试React应用的方式— <a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="40093418840">开始免费监控</a>。</p>
<p vwo-el-id="28675661060"><a class="signup" href="https://lp.logrocket.com/blg/typescript-signup" target="_blank" rel="noopener noreferrer"> LogRocket </a>:全面了解您的网络和移动应用</p><div class="code-block code-block-21">
<div class="blog-plug inline-plug typescript-plug"><h2>LogRocket 是一个前端应用程序监控解决方案，可以让您回放问题，就像问题发生在您自己的浏览器中一样。LogRocket不需要猜测错误发生的原因，也不需要向用户询问截图和日志转储，而是让您重放会话以快速了解哪里出错了。它可以与任何应用程序完美配合，不管是什么框架，并且有插件可以记录来自Redux、Vuex和@ngrx/store的额外上下文。</h2>
<a href="https://lp.logrocket.com/blg/typescript-signup" class="signup" target="_blank" rel="noopener noreferrer"><img class="alignnone size-full wp-image-46 jetpack-lazy-image" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/><noscript><img data-lazy-fallback="1" class="alignnone size-full wp-image-46" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/></noscript></a>
<p>除了记录Redux操作和状态，LogRocket还记录控制台日志、JavaScript错误、堆栈跟踪、带有头+正文的网络请求/响应、浏览器元数据和自定义日志。它还使用DOM来记录页面上的HTML和CSS，甚至为最复杂的单页面和移动应用程序重新创建像素级完美视频。</p>
<p>.</p>
<a class="signup" href="https://lp.logrocket.com/blg/typescript-signup" target="_blank" rel="noopener noreferrer">Try it for free</a><p>.</p></div>
</div>
</div></div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
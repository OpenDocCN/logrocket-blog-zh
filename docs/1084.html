<html>
<head>
<title>How GraphQL Nexus can help you create better APIs - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>GraphQL Nexus如何帮助您创建更好的API</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/how-graphql-nexus-can-help-you-create-better-apis/#0001-01-01">https://blog.logrocket.com/how-graphql-nexus-can-help-you-create-better-apis/#0001-01-01</a></blockquote><div><article class="article-post">
<p>在处理API时，GraphQL真的正在成为一种标准。它帮助许多公司和开发人员发展壮大，并创建更好的API，从而为他们的客户创建更好的应用程序。很多公司，包括GitHub、Shopify、Airbnb、PayPal、<a href="https://graphql.org/users/" target="_blank" rel="noopener noreferrer">都采用了GraphQL </a>。</p>
<p>在开始创建一个新的API时，有许多要点和概念使GraphQL成为一个容易的选择。这个想法就是只要求你想要的，然后得到你想要的。REST API并不总是这样。基本上，在REST APIs中，当我们想要获取数据时，我们接收的是整个对象，而不是我们想要的数据的特定部分。假设我们只想获得一个特定用户的名字，为了做到这一点，我们通常会点击一个端点来获得用户的数据。问题是，如果我们不仅仅是为了检索用户名而创建一个特定的端点，我们将会收到整个用户对象，包含比我们想要的更多的数据。</p>
<p>构建一个可伸缩的GraphQL API并不容易，需要花费大量的时间、精力和研究。我们需要确切地知道将要使用哪种方法，哪种技术，以及如何正确地设计模式。</p>
<p>本质上，GraphQL有两种主要方法可以用来创建我们的API，即代码优先方法和SDL优先方法(也称为模式优先方法)。</p>
<p>在本文中，我们将了解如何使用GraphQL Nexus(一种代码优先和强类型的GraphQL模式构造)来创建更好的、类型安全的和声明性的GraphQL APIs。</p>
<p>为了更好地理解GraphQL Nexus，我们需要了解一下这两种方法是如何工作的。</p>
<h2>代码优先与SDL优先</h2>
<p>几年前GraphQL发布时，脸书发布了一个GraphQL APIs的参考实现，名为<a href="https://github.com/graphql/graphql-js" target="_blank" rel="noopener noreferrer"> graphql-js </a>。</p>
<p><a href="https://github.com/graphql/graphql-js" target="_blank" rel="noopener noreferrer"> graphql-js </a>参考实现使用代码优先的方法，graphql模式是通过使用普通的JavaScript对象创建的:</p>
<pre>import { GraphQLSchema, GraphQLObjectType, GraphQLString } from 'graphql';

const schema = new GraphQLSchema({
  query: new GraphQLObjectType({
    name: 'QueryType',
    fields: {
      helloWorld: {
        type: GraphQLString,
        resolve: () =&gt; 'Hello world!',
      },
    },
  }),
})</pre>
<p>使用代码优先的方法，我们在代码中定义模式。在大型代码库中，代码优先的方法对于组织和快速移动GraphQL模式非常有用。</p>
<p>虽然代码优先的方法是构建GraphQL API的一个很好的方法，但是许多开发人员认为代码优先的方法写起来很冗长。对于一些开发人员来说，在实现模式时，使用代码创建GraphQL模式的想法在视觉上并不容易理解。</p>
<p>SDL优先(也称为模式优先)方法非常适合这种情况。在SDL优先的方法中，我们使用<a href="https://www.prisma.io/blog/graphql-sdl-schema-definition-language-6755bcb9ce51" target="_blank" rel="noopener noreferrer"> SDL(模式定义语言)</a>定义GraphQL模式:</p>
<pre>type Query {
  helloWorld: String!
}</pre>
<p>SDL是一种定义良好的构建模式的方式，它是官方GraphQL规范的一部分。模式优先的方法使得我们的GraphQL模式更容易理解和可视化，使得创建模式的过程更加直观。</p>
<p>缺点之一是我们需要从GraphQL模式中单独实现解析器。SDL优先方法的另一个缺点是，有时在模式中使用指令毫无意义。</p>
<p>既然我们知道了代码优先和SDL优先之间的区别，我们可以了解更多关于GraphQL Nexus的信息。</p>
<h2>GraphQL关系</h2>
<p>由<a href="https://www.prisma.io/about" target="_blank" rel="noopener noreferrer"> Prisma </a>、<a href="https://github.com/graphql-nexus/schema" target="_blank" rel="noopener noreferrer">创建的GraphQL Nexus </a>是一个声明性的、代码优先的、强类型的GraphQL模式构造。</p>
<p><a href="https://github.com/graphql-nexus/schema" target="_blank" rel="noopener noreferrer"> GraphQL Nexus </a>是<a href="https://nexusjs.org/" target="_blank" rel="noopener noreferrer"> Nexus框架</a>的一部分，但是可以单独使用。要开始使用它，我们所要做的就是安装两个依赖项:</p>
<pre>yarn add @nexus/schema graphql</pre>
<p>这里我们需要<code>graphql</code>依赖，因为<a href="https://nexus.js.org/" target="_blank" rel="noopener noreferrer"> GraphQL Nexus </a>需要它作为对等依赖。</p>
<p>GraphQL Nexus 的设计结合了SDL优先方法的简单性和代码优先方法的长期性和组织性。它是建立在<code>graphql-js</code>之上的，所以如果你以前用过它，你可能会感觉有些熟悉。</p>
<p>正如<a href="https://nexus.js.org/docs/getting-started" target="_blank" rel="noopener noreferrer">文档</a>所说:</p>
<blockquote><p>GraphQL Nexus的设计考虑了TypeScript/JavaScript IntelliSense，并结合了type script泛型、条件类型和类型合并，以提供开箱即用的完整自动生成类型覆盖。</p></blockquote>
<h2>(计划或理论的)纲要</h2>
<p>安装完GraphQL Nexus后，要创建您的第一个模式，您需要做的就是从GraphQL Nexus导入<code>makeSchema</code>:</p>
<pre>import { makeSchema } from '@nexus/schema';</pre>
<p><code>makeSchema</code>函数用于定义GraphQL模式。您可以组合使用GraphQL Nexus定义的GraphQL类型，甚至可以传递您手动定义为类型的类型，如<code>Scalar</code>、<code>ObjectType</code>、<code>Enum</code>等。</p>
<p>使用<code>makeSchema</code>函数，非常类似于<a href="https://github.com/graphql/graphql-js" target="_blank" rel="noopener noreferrer"> graphql-js </a>的实现。为您的模式创建一个对象，在该对象中，您可以传递两个属性，<code>types</code>和<code>outputs</code>:</p>
<pre>const schema = makeSchema({
  types: [Query],
  outputs: {
    schema: __dirname + '/generated/schema.graphql',
    typegen: __dirname + '/generated/typings.ts',
  },
});</pre>
<p><code>types</code>属性是您可以传递GraphQL类型的地方。在<code>outputs</code>属性中，可以传递两个名为<code>schema</code>和<code>typegen</code>的属性。GraphQL Nexus将为您生成一个包含整个GraphQL模式的名为<code>schema.graphql</code>的文件，以及一个包含我们所有类型的名为<code>typing.ts</code>的文件。</p>
<p>当然，您可以在<code>makeSchema</code>函数中传递两个以上的属性。GraphQL Nexus有一个名为<code>plugins</code>的属性，其中可以有一组插件来扩展GraphQL的功能:</p>
<pre>const schema = makeSchema({
  types: [Query, Mutation],
  outputs: {
    schema: __dirname + '/generated/schema.graphql',
    typegen: __dirname + '/generated/typings.ts',
  },
  plugins: {
    fieldAuthorizePlugin({
      ...
    }),
    nullabilityGuard({
      ...
    })
  }
});</pre>
<h2>问题</h2>
<p>要使用GraphQL Nexus创建查询，首先需要导入<code>QueryType</code>:</p>
<pre>import { queryType, makeSchema } from '@nexus/schema';</pre>
<p>导入之后，您可以创建一个名为<code>Query</code>的对象，所有的查询都将存放在这个对象中。您需要使用一个名为<code>definition</code>的函数，在这个函数中，您可以使用<code>t</code>参数来定义查询的响应类型:</p>
<pre>const Query = queryType({
  definition(t) {
    ...
  },
});</pre>
<p>例如，假设我们想要创建一个名为<code>user</code>的查询。如果我们想返回一个<code>string</code>作为该查询的预期响应类型，我们可以这样做:</p>
<pre>const Query = queryType({
  definition(t) {
    t.string('user', {
      resolve: (root, args, context) =&gt; 'Hello!',
    });
  },
});</pre>
<p>注意，我们使用了<code>t.string</code>来指定查询响应的类型。您可以使用多种类型来指定响应类型，如<code>boolean</code>、<code>field</code>、<code>float</code>、<code>id</code>、<code>int</code>等。</p>
<h2>突变</h2>
<p>使用GraphQL Nexus创建变异与查询非常相似，首先，您需要导入<code>MutationType</code>:</p>
<pre>const Mutation = mutationType({
  definition(t) {
    t.string('createUser', {
      resolve: (root, args, context) =&gt; 'Hello!',
    });
  },
});</pre>
<p>GraphQL Nexus的一个优点是，您可以定义可用于任何对象或接口类型的参数:</p>
<pre>import { stringArg } from '@nexus/schema';
const userArgs = {
  name: stringArg({
    required: true,
    description: 'The name of the user to be created'
  })
};</pre>
<p>您可以使用许多不同的参数函数，如<code>arg</code>、<code>intArg</code>、<code>stringArg</code>、<code>floatArg</code>、<code>idArg</code>和<code>booleanArg</code>。</p>
<h2>类型</h2>
<p>GraphQL API最重要的部分是对象类型。要使用GraphQL Nexus创建一个，您需要做的就是导入<code>objectType</code>。</p>
<pre>import { objectType } from '@nexus/schema';</pre>
<p>创建对象类型与创建查询或变异非常相似。您可以传递一个名为<code>name</code>的属性来定义类型的名称，并在<code>definition</code>函数中定义类型的属性:</p>
<pre>import { objectType } from '@nexus/schema';
const User = objectType({
  name: 'User',
  definition(t) {
    t.int('id');
    t.string('title');
    t.int('age');
  }
});</pre>
<p>您可以非常容易地创建其他类型，如<code>Scalar</code>、<code>ObjectType</code>、<code>Enum</code>，GraphQL Nexus很好地支持这些类型:</p>
<pre>import { scalarType } from '@nexus/schema';
const DateScalar = scalarType({
  name: 'DateScalar',
  description: 'Date custom scalar',
  ...
});</pre>
<p>另一个有用的类型是<code>inputObjectType</code>。您可以创建一个可以定义并作为输入值传递的输入对象类型，当您有一个复杂的输入值时，这对于突变和查询非常有用:</p>
<pre>import { inputObjectType } from '@nexus/schema';
const UserInputType = inputObjectType({
  name: 'UserInputType',
  description: 'User input type',
  definition(t) {
    t.string('id', { required: true });     
    t.string('name');
    t.int('age');
  }
});
</pre>
<h2>插件</h2>
<p>GraphQL Nexus的另一个非常好的特性是插件。GraphQL Nexus有一个插件API，允许您在构建GraphQL模式时定义抽象。</p>
<p>GraphQL Nexus也有很多开箱即用的插件，比如:</p>
<ul>
<li><a href="https://nexus.js.org/docs/plugin-queryComplexity" target="_blank" rel="noopener noreferrer">查询复杂度插件</a> —测量GraphQL模式中的查询复杂度不是很多开发人员都会做的事情，但有时这是必要的。单个查询可能会为您的服务器产生巨大的工作负载。您可以使用这个插件来限制和跟踪您的GraphQL操作，并定义字段级复杂度值</li>
</ul>
<p>GraphQL Nexus还有一些非常有用的插件，例如:</p>

<p>在某些情况下，代码优先的方法比SDL优先的方法更好。有了GraphQL Nexus，我们可以从这种方法中获益，并创建一个更健壮、定义更好的GraphQL模式。GraphQL Nexus创建于<code>graphql-js</code>实现之上，是创建真正优秀、健壮、可维护和简洁的GraphQL API的最佳选择之一。</p>
<h2>结论</h2>
<p>在本文中，我们首先了解了GraphQL中的两种主要方法，代码优先和SDL优先。我们还看了GraphQL Nexus，如何创建您的第一个模式，以及定义您的查询和变化。GraphQL附带了很多特性，比如插件，我们可以用它们来定义自己的抽象，并帮助我们改进我们的GraphQL API。</p><div class="code-block code-block-24">
<div class="blog-plug inline-plug graphql-plug"><h2>监控生产中失败和缓慢的GraphQL请求</h2><p>虽然GraphQL有一些调试请求和响应的特性，但确保GraphQL可靠地为您的生产应用程序提供资源是一件比较困难的事情。如果您对确保对后端或第三方服务的网络请求成功感兴趣，</p><a href="https://lp.logrocket.com/blg/graphql-signup" target="_blank">try LogRocket</a><p>.</p><a class="signup" href="https://lp.logrocket.com/blg/graphql-signup" target="_blank" rel="noopener noreferrer"><img src="../Images/432a3823c85b3fb72a206e6236a29f48.png" data-lazy-src="https://files.readme.io/69aa835-Image_2019-11-09_at_1.28.05_PM.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" class=" jetpack-lazy-image" data-original-src="https://files.readme.io/69aa835-Image_2019-11-09_at_1.28.05_PM.png"/><noscript><img data-lazy-fallback="1" src="../Images/432a3823c85b3fb72a206e6236a29f48.png" data-original-src="https://files.readme.io/69aa835-Image_2019-11-09_at_1.28.05_PM.png"/></noscript><img class="alignnone size-full wp-image-46 jetpack-lazy-image" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/><noscript><img data-lazy-fallback="1" class="alignnone size-full wp-image-46" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/></noscript></a><a href="https://lp.logrocket.com/blg/graphql-signup" target="_blank" rel="noopener noreferrer">https://logrocket.com/signup/</a><p>LogRocket 就像是网络和移动应用的DVR，记录下你网站上发生的每一件事。您可以汇总并报告有问题的GraphQL请求，以快速了解根本原因，而不是猜测问题发生的原因。此外，您可以跟踪Apollo客户机状态并检查GraphQL查询的键值对。</p><p>LogRocket检测您的应用程序以记录基线性能计时，如页面加载时间、到达第一个字节的时间、慢速网络请求，还记录Redux、NgRx和Vuex操作/状态。</p><a class="signup" href="https://lp.logrocket.com/blg/graphql-signup" target="_blank" rel="noopener noreferrer">Start monitoring for free</a><p>.</p></div>


</div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
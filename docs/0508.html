<html>
<head>
<title>Take your Node backend to the next level with NestJS - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>使用NestJS - LogRocket博客将您的节点后端提升到一个新的水平</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/node-back-end-next-level-nestjs/#0001-01-01">https://blog.logrocket.com/node-back-end-next-level-nestjs/#0001-01-01</a></blockquote><div><article class="article-post">
<p>NestJS是用于创建可伸缩应用程序的后端框架。它是底层HTTP服务器库的抽象。目前，它支持两个库——Express和Fastify——同时仍然允许开发人员在需要时使用他们自己的API。</p>
<p>更重要的是，它通过引入类似Angular的模块、服务和控制器，迫使开发人员使用特定的架构，确保应用程序是可伸缩的、高度可测试的和松散耦合的。</p>
<p>Express、Koa和hapi不强制任何特定的架构。当然，它们提供了一套底层工具，但仍有许多工作留给了开发人员。项目早期关于架构的错误可能会花费大量时间来重构代码库。</p>
<p>相反，Nest对代码库——它的模块、服务和控制器——是严格的，你真的不能出错。</p>
<h2>体系结构</h2>
<p>作为一个团队在一个项目中工作意味着有很多关于应用程序应该如何构建的偏好。所有这些被强加到一个代码库中的偏好不会提供任何增强。反而会造成乱七八糟，整体代码质量差。</p>
<p>为了解决这个问题，Nest通过定义团队中每个开发人员都必须遵循的自以为是的架构，提供了一套标准化的指导方针。结果是一个易于维护的代码库。</p>
<p>Nest通过引入一些简单的构建模块，抽象出了与Express或Fastify等底层库的所有交易，其中最重要的是模块、服务和控制器。</p>
<p><img data-attachment-id="8809" data-permalink="https://blog.logrocket.com/node-back-end-next-level-nestjs/nestjs-application-module-structure/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2019/10/nestjs-application-module-structure.png" data-orig-size="730,526" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="NestJS module structure" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2019/10/nestjs-application-module-structure-300x216.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2019/10/nestjs-application-module-structure.png" decoding="async" class="aligncenter size-full wp-image-8809 jetpack-lazy-image" src="../Images/738a013117013ccd812bea851e4fd154.png" alt="NestJS Module Structure" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2019/10/nestjs-application-module-structure.png 730w, https://blog.logrocket.com/wp-content/uploads/2019/10/nestjs-application-module-structure-300x216.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2019/10/nestjs-application-module-structure.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/10/nestjs-application-module-structure.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="8809" data-permalink="https://blog.logrocket.com/node-back-end-next-level-nestjs/nestjs-application-module-structure/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2019/10/nestjs-application-module-structure.png" data-orig-size="730,526" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="NestJS module structure" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2019/10/nestjs-application-module-structure-300x216.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2019/10/nestjs-application-module-structure.png" decoding="async" loading="lazy" class="aligncenter size-full wp-image-8809" src="../Images/738a013117013ccd812bea851e4fd154.png" alt="NestJS Module Structure" srcset="https://blog.logrocket.com/wp-content/uploads/2019/10/nestjs-application-module-structure.png 730w, https://blog.logrocket.com/wp-content/uploads/2019/10/nestjs-application-module-structure-300x216.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/10/nestjs-application-module-structure.png"/></noscript>
<p>模块封装了与给定领域相关的所有逻辑。假设我们需要实现与用户相关的逻辑。我们可以创建一个包含<code>UserService</code>、<code>UserController</code>的<code>UserModule</code>。</p>
<p>模块本身只是一个用<code>@Module</code> decorator修饰的类，其中我们提供了所有必要的元数据。如果我们想从其他模块中访问模块的给定部分，我们可以在<code>exports</code>数组中导出该部分。</p>
<p>以下是来自官方文档的<code>CatModule</code>:</p>
<pre>import { Module } from '@nestjs/common';
import { CatsController } from './cats.controller';
import { CatsService } from './cats.service';

@Module({
  controllers: [CatsController],
  providers: [CatsService],
  exports: [CatsService]
})
export class CatsModule {}</pre>
<p>一个典型的应用程序将拥有诸如<code>ApplicationModule</code>(根模块)、<code>SharedModule</code>(它将进一步封装所有底层的可重用的、跨应用程序的模块)，以及，像上面提供的那样，将封装公共API的逻辑的模块。</p>
<p>点击阅读更多关于<a href="https://docs.nestjs.com/modules"> NestJS模块的信息。</a></p>
<h3>控制器</h3>
<p>控制器是一个用<code>@Controller</code>装饰器标注的类。控制器充当传入HTTP请求和处理它的相应逻辑之间的一层。我们可以把控制器看作一个中间人:它检查传入的请求并调用适当的服务方法。</p>
<p><img data-attachment-id="8811" data-permalink="https://blog.logrocket.com/node-back-end-next-level-nestjs/nestjs-controllers-illustration/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2019/10/nestjs-controllers-illustration.png" data-orig-size="730,420" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="NestJS controllers illustration" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2019/10/nestjs-controllers-illustration-300x173.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2019/10/nestjs-controllers-illustration.png" decoding="async" class="aligncenter size-full wp-image-8811 jetpack-lazy-image" src="../Images/6575ed52f09808bfb23f0d595cb209f8.png" alt="NestJS Controllers Illustration" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2019/10/nestjs-controllers-illustration.png 730w, https://blog.logrocket.com/wp-content/uploads/2019/10/nestjs-controllers-illustration-300x173.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2019/10/nestjs-controllers-illustration.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/10/nestjs-controllers-illustration.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="8811" data-permalink="https://blog.logrocket.com/node-back-end-next-level-nestjs/nestjs-controllers-illustration/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2019/10/nestjs-controllers-illustration.png" data-orig-size="730,420" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="NestJS controllers illustration" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2019/10/nestjs-controllers-illustration-300x173.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2019/10/nestjs-controllers-illustration.png" decoding="async" loading="lazy" class="aligncenter size-full wp-image-8811" src="../Images/6575ed52f09808bfb23f0d595cb209f8.png" alt="NestJS Controllers Illustration" srcset="https://blog.logrocket.com/wp-content/uploads/2019/10/nestjs-controllers-illustration.png 730w, https://blog.logrocket.com/wp-content/uploads/2019/10/nestjs-controllers-illustration-300x173.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/10/nestjs-controllers-illustration.png"/></noscript>
<p>控制器定义路由路径、参数、响应以及与HTTP请求相关的一切。他们不关心请求和响应之间发生了什么。</p>
<pre>@Controller('cats')
export class CatsController {
  @Post()
  create(@Body() createCatDto: CreateCatDto) {
    return 'This action adds a new cat';
  }

  @Get()
  findAll(@Query() query: ListAllEntities) {
    return `This action returns all cats (limit: ${query.limit} items)`;
  }

  @Get(':id')
  findOne(@Param('id') id: string) {
    return `This action returns a #${id} cat`;
  }

  @Put(':id')
  update(@Param('id') id: string, @Body() updateCatDto: UpdateCatDto) {
    return `This action updates a #${id} cat`;
  }

  @Delete(':id')
  remove(@Param('id') id: string) {
    return `This action removes a #${id} cat`;
  }
}</pre>
<p>在上面的例子中，有一个控制器在监听<code>application_url/cats</code>路径。每个方法都用<code>@Get</code>、<code>@Post</code>、<code>@Put</code>或<code>@Delete</code>来修饰，以表明他们对什么HTTP方法感兴趣。我们还可以在装饰器内部提供一个额外的路径。</p>
<p>与直接使用请求对象访问主体或查询(如我们在Express中所做的那样)不同，每个参数都可以用<code>@Param</code>、<code>@Query</code>或<code>@Body</code>来修饰，这样就可以抽象出底层的访问层。</p>
<p>尽管上例中的每个方法都是同步工作的，但是方法可能会返回带有承诺和可观察值的异步值。</p>
<p><a href="https://docs.nestjs.com/controllers">在此阅读更多关于控制器的信息</a>。</p>
<h3>服务</h3>
<p>服务是用<code>@Injectable</code>装饰器标注的类。它包含领域(业务)逻辑。通过分离访问层(控制器)和逻辑层(服务)，我们可以清楚地分离关注点。</p>
<pre>@Injectable()
export class CatsService {
  private readonly cats: Cat[] = [];

  create(cat: Cat) {
    this.cats.push(cat);
  }

  findAll(): Cat[] {
    return this.cats;
  }
}</pre>
<p>通过使用<code>@Injectable</code>装饰器，我们告诉Nest这个类可以被注入到应用程序的其他部分。</p>
<p>阅读更多关于<a href="https://docs.nestjs.com/providers">服务</a>的信息。</p>
<h3>依赖注入</h3>
<p>依赖注入是Nest最重要的方面之一。通过提供开箱即用的支持，Nest允许我们编写松散耦合的代码，这反过来也很容易测试。</p><div class="code-block code-block-54">
<hr/>
<h3>更多来自LogRocket的精彩文章:</h3>

<hr/></div>
<p>由于Nest是用TypeScript编写的，所以依赖关系只是通过类型来解析——不需要手工注入它们！</p>
<pre>@Controller('cats')
export class CatsController {
  constructor(private readonly catsService: CatsService) {}

  @Post()
  async create(@Body() createCatDto: CreateCatDto) {
    this.catsService.create(createCatDto);
  }

  @Get()
  async findAll(): Promise&lt;Cat[]&gt; {
    return this.catsService.findAll();
  }
}</pre>
<p>我们没有为依赖于<code>CatsService</code>的每个类提供<code>new CatsService(...deps)</code>，而是告诉Nest，“如果有人在其依赖关系中请求这个类的实例，就为他们创建它。”</p>
<p>默认情况下，提供的实例是单例的，在每个请求实体之间共享，但是可以通过指定<a href="https://docs.nestjs.com/fundamentals/injection-scopes">注入范围</a>来改变。我们的依赖关系通常通过使用<code>private readonly name: type</code>语法在构造函数中定义。</p>
<p>在<a href="https://angular.io/guide/dependency-injection"> Angular的依赖注入指南</a>中阅读更多关于依赖注入的内容。</p>
<h3>文件结构</h3>
<p>强烈建议在文件夹结构中反映代码库的结构。一个模块应该有它自己独立的文件夹，所有的内部构件都在这个文件夹中。</p>
<p><img data-attachment-id="8810" data-permalink="https://blog.logrocket.com/node-back-end-next-level-nestjs/nestjs-file-structure-example/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2019/10/nestjs-file-structure-example.png" data-orig-size="512,197" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="NestJS file structure example" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2019/10/nestjs-file-structure-example-300x115.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2019/10/nestjs-file-structure-example.png" decoding="async" class="aligncenter size-full wp-image-8810 jetpack-lazy-image" src="../Images/18afac61a345728e29db214434999189.png" alt="NestJS File Structure Example" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2019/10/nestjs-file-structure-example.png 512w, https://blog.logrocket.com/wp-content/uploads/2019/10/nestjs-file-structure-example-300x115.png 300w" data-lazy-sizes="(max-width: 512px) 100vw, 512px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2019/10/nestjs-file-structure-example.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/10/nestjs-file-structure-example.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="8810" data-permalink="https://blog.logrocket.com/node-back-end-next-level-nestjs/nestjs-file-structure-example/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2019/10/nestjs-file-structure-example.png" data-orig-size="512,197" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="NestJS file structure example" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2019/10/nestjs-file-structure-example-300x115.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2019/10/nestjs-file-structure-example.png" decoding="async" loading="lazy" class="aligncenter size-full wp-image-8810" src="../Images/18afac61a345728e29db214434999189.png" alt="NestJS File Structure Example" srcset="https://blog.logrocket.com/wp-content/uploads/2019/10/nestjs-file-structure-example.png 512w, https://blog.logrocket.com/wp-content/uploads/2019/10/nestjs-file-structure-example-300x115.png 300w" sizes="(max-width: 512px) 100vw, 512px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/10/nestjs-file-structure-example.png"/></noscript>
<p>按照Angular的步骤，Nest也有一个命名约定，包括适当的文件结尾，如<code>.controller</code>、<code>.service</code>和<code>.module</code>。这样，项目的文件夹结构易于阅读，并为开发人员提供了一个良好的代码库概览。</p>
<h3>硬币指示器 （coin-levelindicator的缩写）命令行界面（Command Line Interface for batch scripting）</h3>
<p>Nest自带CLI。</p>
<pre>npm i -g @nestjs/cli</pre>
<p>最重要的命令是<code>new</code>和<code>generate</code>。</p>
<p><code>new</code>命令让我们可以在几秒钟内用Nest创建一个完整的应用程序模板。</p>
<pre>nest new application-name</pre>
<p><code>generate</code>命令为请求的特征生成一组文件。如果有必要，它也可能修改现有的。</p>
<pre>nest generate service cat</pre>
<p>在上面的例子中，会生成两个文件:<code>cat.service.ts</code>和<code>cat.service.spec.ts</code>。此外，如果目录中指定了一个<code>cat</code>模块，该服务将被自动导入。</p>
<p>CLI通过减少需要为每个构建块编写的样板文件的数量，并通过生成一个包含一些非常基本的测试的<code>.spec</code>文件，真正提高了开发人员的生产力。</p>
<h2>测试</h2>
<p>测试对于确保应用程序在做出一些更改后仍能正常工作非常重要。Nest非常重视测试，并提供测试工具，以使测试过程尽可能顺利。通过使用依赖注入，由于Nest的<a href="https://docs.nestjs.com/fundamentals/custom-providers">定制提供者</a>特性，模拟出我们目前没有测试的模块是非常容易的。</p>
<p>这里有一个单元测试<code>CatsController</code>的例子:</p>
<pre>import { Test } from '@nestjs/testing';
import { CatsController } from './cats.controller';
import { CatsService } from './cats.service';

describe('CatsController', () =&gt; {
  let catsController: CatsController;
  let catsService: CatsService;

  beforeEach(async () =&gt; {
    const module = await Test.createTestingModule({
        controllers: [CatsController],
        providers: [CatsService],
      }).compile();

    catsService = module.get&lt;CatsService&gt;(CatsService);
    catsController = module.get&lt;CatsController&gt;(CatsController);
  });

  describe('findAll', () =&gt; {
    it('should return an array of cats', async () =&gt; {
      const result = ['test'];
      jest.spyOn(catsService, 'findAll').mockImplementation(() =&gt; result);

      expect(await catsController.findAll()).toBe(result);
    });
  });
});</pre>
<p>正如我们之前提到的，Nest的CLI为每个服务、控制器、过滤器等生成基本测试。通过这样做，Nest不仅给了我们必要的工具，还提醒我们应该测试应用程序的每个特性。</p>
<p>如果你想看一些更复杂的情况(例如，模拟数据库连接)，我已经创建了一个应用程序，你可以在这里看到<a href="https://github.com/maciejcieslar/zombie"/>。</p>
<h2>摘要</h2>
<p>Nest站在新趋势的顶端，使编写基于微服务架构的应用程序变得非常容易。</p>
<p>尽管默认情况下Nest用于构建REST APIs，但由于其平台无关的方法，该架构也可以用于创建GraphQL API。当谈到记录我们的REST API时，有一个与<em> Swagger </em>库的很好的集成，让我们可以毫不费力地生成文档。</p>
<p>Nest生态系统中也有很多将现有的包集成到Nest架构中的包。最受欢迎的套餐有<em>型的</em>、<em>护照</em>、<em>猫鼬</em>。如果一个给定的库不被支持，我们可以创建我们自己的服务/提供者，以一种嵌套可访问的方式封装这个库。</p>
<p>当然，Nest并不是万能的，在某些情况下确实有所欠缺，或者实现预期结果所需的步骤并不明确。但随着其不断增长的社区(GitHub上超过20，000颗星)，快速获得燃眉之急问题的回应变得越来越容易。</p><div class="code-block code-block-23">
<div class="blog-plug inline-plug node-plug"><h2>200只<img src="../Images/61167b9d027ca73ed5aaf59a9ec31267.png" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2019/10/green-check.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" class=" jetpack-lazy-image" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/10/green-check.png"/> <noscript> <img data-lazy-fallback="1" src="../Images/61167b9d027ca73ed5aaf59a9ec31267.png" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/10/green-check.png"/> </noscript>显示器出现故障，生产中网络请求缓慢</h2><p>部署基于节点的web应用程序或网站是容易的部分。确保您的节点实例继续为您的应用程序提供资源是事情变得更加困难的地方。如果您对确保对后端或第三方服务的请求成功感兴趣，</p><a href="https://lp.logrocket.com/blg/node-signup" target="_blank">try LogRocket</a><p>. </p><a class="signup" href="https://lp.logrocket.com/blg/node-signup" target="_blank" rel="noopener noreferrer"><img src="../Images/cae72fd2a54c5f02a6398c4867894844.png" alt="LogRocket Network Request Monitoring" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2019/12/network-request-filter-2-1.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" class=" jetpack-lazy-image" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/12/network-request-filter-2-1.png"/><noscript><img data-lazy-fallback="1" src="../Images/cae72fd2a54c5f02a6398c4867894844.png" alt="LogRocket Network Request Monitoring" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/12/network-request-filter-2-1.png"/></noscript></a><a href="https://lp.logrocket.com/blg/node-signup" target="_blank" rel="noopener noreferrer">https://logrocket.com/signup/</a><p>LogRocket 就像是网络和移动应用程序的DVR，记录下用户与你的应用程序交互时发生的一切。您可以汇总并报告有问题的网络请求，以快速了解根本原因，而不是猜测问题发生的原因。</p><p>LogRocket检测您的应用程序以记录基线性能计时，如页面加载时间、到达第一个字节的时间、慢速网络请求，还记录Redux、NgRx和Vuex操作/状态。</p><a class="signup" href="https://lp.logrocket.com/blg/node-signup" target="_blank" rel="noopener noreferrer">Start monitoring for free</a><p>. </p></div>
</div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
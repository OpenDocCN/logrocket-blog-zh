<html>
<head>
<title>Immutability in React with Immer - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>与Immer - LogRocket Blog反应的不变性</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/immutability-in-react-with-immer/#0001-01-01">https://blog.logrocket.com/immutability-in-react-with-immer/#0001-01-01</a></blockquote><div><article class="article-post">
<p>我们知道JavaScript是一种动态、多范式、弱类型的语言。这意味着我们可以在JavaScript代码中应用许多不同的范例，例如，面向对象的JavaScript、命令式JavaScript、函数式编程JavaScript等。许多JavaScript开发人员开始在他们的应用程序中采用函数式编程范式。</p>
<p>创建了一些库，现在React的采用正在开发人员中大规模扩展和增长，不变性概念也开始被更多地使用和讨论。让我们首先理解什么是不变性，然后我们将看看如何在React应用程序中使用函数式编程的概念。</p>
<h2>不变</h2>
<p>在函数式编程语言中，最有趣也是最重要的概念之一是不变性。不变性的全部含义是“无法改变”，如果我们有一个对象，并想创建一个新的对象，我们应该复制实际的对象，而不是变异它。</p>
<p>在创建应用程序时，我们需要考虑用户，更重要的是，用户数据。在您的应用程序中创建、修改、删除和替换的所有数据都很重要，应该得到正确的观察、存储和管理。这就是为什么我们应该创建更好的标准或概念来处理我们的数据。</p>
<p>但是为什么我们的应用程序中要有一个不可变的代码呢？嗯，我们可以利用不变性在某些方面获益，例如:</p>
<ul>
<li>可读性 —如果你有一个不可变的代码，你的应用程序对你和你的团队来说将变得更加可读，更容易理解到底发生了什么以及每段代码在执行什么</li>
<li>可维护性——有了不可变的代码，当错误发生时，你的应用程序将变得更容易调试和维护——这是我们不容易避免的，它们总是会发生——它将很容易找到错误发生的地方和出错的地方</li>
<li>更少的副作用 —这对于可维护性来说可能是更积极的一点，但是当你有一个不可变的代码时，在你的应用程序中产生负面副作用的机会就减少了。您将最终得到更易于管理的代码，并且您的应用程序中出现意外错误的机会也会减少</li>
</ul>
<h2>反应的不变性</h2>
<p>在React应用程序中，应用程序最重要的部分是状态数据。你应该适当地关心和管理它，否则，它会引起错误，你会非常容易地丢失数据，这可能是你最糟糕的噩梦。</p>
<p>React开发人员都知道我们不应该直接改变状态，而应该使用<code>setState</code>方法。但是为什么呢？</p>
<p>这是React背后的主要思想之一——跟踪变化，如果有什么变化，重新呈现组件。你不能简单地改变你的状态，因为它不会在你的组件中触发一个render。通过使用<code>setState</code>方法，您将以一种不可变的方式创建一个新的状态，React将知道某些事情发生了变化，并将重新呈现相应的组件。</p>
<p>我们在Redux中也有类似的行为，Redux是React应用程序最著名和最常用的状态管理库。Redux将状态表示为不可变的对象，为了改变你的状态，你应该使用纯函数传递你的新状态数据，这些纯函数被称为<code>reducers</code>。Reducers不应该改变状态，以避免应用程序中的副作用，并确保Redux跟踪当前的状态数据。</p>
<p>我们可以看到，在React社区中，不变性的概念越来越多地被使用，变得越来越普遍。但是为了确保我们做的方式正确，我们可以使用一个库来完成这项工作。</p>
<h2>总是（德语词）</h2>
<p>为了更好地处理状态数据，创建了一个名为Immer的库来帮助我们。创建Immer 是为了帮助我们拥有一个不可变的状态，它是一个基于<a href="https://www.computerhope.com/jargon/c/copy-on-write.htm" target="_blank" rel="noopener noreferrer">“写时复制”机制</a>创建的库，这是一种用于在可修改的资源上实现复制操作的技术。</p>
<p>Immer非常容易理解，这是Immer的工作方式:</p>
<ol>
<li>你有你的实际状态数据</li>
<li>Immer将复制您的实际状态数据，并创建一个新的临时“草稿”。这个草稿将是下一个状态数据的代理</li>
<li>创建草稿后，Immer将使用草稿更新您的状态数据，这是您下一个状态数据的代理</li>
<li>简而言之，Immer将这样处理您的状态:</li>
</ol>
<p><img data-attachment-id="15269" data-permalink="https://blog.logrocket.com/immutability-in-react-with-immer/statedraft/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/03/statedraft.png" data-orig-size="730,185" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="statedraft" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/03/statedraft-300x76.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/03/statedraft.png" decoding="async" class="aligncenter wp-image-15269 size-full jetpack-lazy-image" src="../Images/7bba116048ec8a749be2336ad7784a65.png" alt="how Immer deals with state" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2020/03/statedraft.png 730w, https://blog.logrocket.com/wp-content/uploads/2020/03/statedraft-300x76.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2020/03/statedraft.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/03/statedraft.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="15269" data-permalink="https://blog.logrocket.com/immutability-in-react-with-immer/statedraft/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/03/statedraft.png" data-orig-size="730,185" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="statedraft" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/03/statedraft-300x76.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/03/statedraft.png" decoding="async" loading="lazy" class="aligncenter wp-image-15269 size-full" src="../Images/7bba116048ec8a749be2336ad7784a65.png" alt="how Immer deals with state" srcset="https://blog.logrocket.com/wp-content/uploads/2020/03/statedraft.png 730w, https://blog.logrocket.com/wp-content/uploads/2020/03/statedraft-300x76.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/03/statedraft.png"/></noscript>
<h2>入门指南</h2>
<p>要开始使用Immer，您需要首先安装它:</p>
<pre>yarn add immer</pre>
<p>现在，我们将在组件中导入Immer。该库导出一个名为<code>produce</code>的默认函数:</p>
<pre>produce(currentState, producer: (draftState) =&gt; void): nextState</pre>
<p><code>produce</code>函数的第一个参数是我们当前的状态对象，第二个参数是一个函数，它将获取我们的<code>draft</code>状态，然后执行我们想要的更改。</p>
<p>让我们创建一个名为<code>Users</code>的简单组件，我们将创建一个用户列表。我们将创建一个名为<code>users</code>的简单状态，它将是一个用户数组，另一个名为<code>users</code>的状态将是一个对象。在那个对象里面，我们将有<code>user</code>的<code>name</code>:</p>
<pre>this.state = {
  user: {
    name: "",
  },
  users: []
}</pre>
<p>现在，让我们从Immer导入<code>produce</code>函数，并创建一个名为<code>onInputChange</code>的新函数。每次我们输入时，我们都会改变<code>user</code>的<code>name</code>的值。</p>
<pre>onInputChange = event =&gt; {
  this.setState(produce(this.state.user, draftState =&gt; {
    draftState.user = {
      name: event.target.value
    }
  }))
}</pre>
<p>React的<code>setState</code>方法接受一个函数，所以我们传递来自Immer的<code>produce</code>函数，在<code>produce</code>函数内部，我们传递我们的<code>user</code>状态作为第一个参数，作为第二个参数，我们使用一个函数。在这个函数中，我们改变了<code>user</code>的<code>draftState</code>，使其等于输入值。因此，我们跟踪输入的值，并将其保存在我们的<code>user</code>状态中。</p>
<p>现在我们已经正确保存了用户状态，让我们每次点击按钮时提交一个新用户。我们将创建一个名为<code>onSubmitUser</code>的新函数，我们的函数如下所示:</p>
<pre>onSubmitUser = () =&gt; {
  this.setState(produce(draftState =&gt; {
    draftState.users.push(this.state.user);
    draftState.user = {
      name: ""
    }
  }))
}</pre>
<p>你现在可以注意到我们再次使用了<code>setState</code>，传递了我们的<code>produce</code>函数，但是现在我们只使用了<code>draftState</code>作为参数，并且我们不再使用当前状态作为参数。但是为什么呢？</p>
<p>嗯，Immer有一个叫做<a href="https://immerjs.github.io/immer/docs/curried-produce" target="_blank" rel="noopener noreferrer"> curried producers </a>的东西，如果你把一个函数作为第一个参数传递给你的<code>produce</code>函数，它将被用于curry。我们现在有一个“curried”函数，这意味着这个函数将接受一个状态，并调用我们更新的draft函数。</p>
<p>因此，最终，我们的整个组件将看起来像这样:</p>
<pre>class Users extends Component {
  constructor(props) {
    super(props);
    this.state = {
      user: {
        name: ""
      },
      users: []
    };
  }

  onInputChange = event =&gt; {
    this.setState(
      produce(this.state.user, draftState =&gt; {
        draftState.user = {
          name: event.target.value
        };
      })
    );
  };

  onSubmitUser = () =&gt; {
    this.setState(
      produce(draftState =&gt; {
        draftState.users.push(this.state.user);
        draftState.user = {
          name: ""
        };
      })
    );
  };

  render() {
    const { users, user } = this.state;
    return (
      &lt;div&gt;
        &lt;h1&gt;Immer with React&lt;/h1&gt;
        {users.map(user =&gt; (
          &lt;h4&gt;{user.name}&lt;/h4&gt;
        ))}
        &lt;input type="text" value={user.name} onChange={this.onInputChange} /&gt;
        &lt;button onClick={this.onSubmitUser}&gt;Submit&lt;/button&gt;
      &lt;/div&gt;
    );
  }
}</pre>
<p>既然我们已经使用Immer和类组件创建了我们的例子，你可能会问，有可能使用Immer和React钩子吗？是的，它是！</p>
<h2>大部分是钩子</h2>
<p><code>useImmer</code>钩子与React中的<code>useState</code>钩子非常相似。首先，让我们安装它:</p>
<pre>yarn add use-immer</pre>
<p>让我们创建一个名为<code>UserImmer</code>的新组件，在该组件中，我们将从<code>use-immer</code>导入<code>useImmer</code>钩子:</p>
<pre>import React from 'react';
import { useImmer } from "use-immer";

const UserImmer = () =&gt; {
  ...
}
export default UserImmer;</pre>
<p>我们的组件中有两种状态。我们的用户列表中有<code>users</code>，还有<code>user</code>:</p>
<pre>const [user, setUser] = useImmer({
  name: ''
})
const [users, setUsers] = useImmer([])</pre>
<p>现在，让我们创建一个与上一个例子同名的函数，<code>onInputChange</code>，在这个函数中，我们将更新我们的<code>user</code>的值:</p>
<pre>const onInputChange = (user) =&gt; {
  setUser(draftState =&gt; {
    draftState.name = user
  })
}</pre>
<p>现在让我们创建我们的<code>onSubmitUser</code>函数，它将在我们每次点击按钮时添加一个新用户。与前面的例子非常相似:</p>
<pre>const onSubmitUser = () =&gt; {
  setUsers(draftState =&gt; {
    draftState.push(user)
  })

  setUser(draftState =&gt; {
    draftState.name = ""
  })
}</pre>
<p>你可以看到我们同时使用了<code>setUsers</code>和<code>setUser</code>函数。我们首先使用<code>setUsers</code>函数将<code>user</code>添加到我们的<code>users</code>数组中。之后，我们使用<code>setUser</code>函数将<code>user</code>的<code>name</code>值重置为空字符串。</p>
<p>我们的整个组件将如下所示:</p>
<pre>import React from 'react';
import { useImmer } from "use-immer";
const UserImmer = () =&gt; {
  const [user, setUser] = useImmer({
    name: ''
  })
  const [users, setUsers] = useImmer([])
  const onInputChange = (user: any) =&gt; {
    setUser(draftState =&gt; {
      draftState.name = user
    })
  }
  const onSubmitUser = () =&gt; {
    setUsers(draftState =&gt; {
      draftState.push(user)
    })
    setUser(draftState =&gt; {
      draftState.name = ""
    })
  }
  return (
    &lt;div&gt;
      &lt;h1&gt;Users&lt;/h1&gt;
      {users.map((user, index) =&gt; (
        &lt;h5 key={index}&gt;{user.name}&lt;/h5&gt;
      ))}
      &lt;input
        type="text"
        onChange={e =&gt; onInputChange(e.target.value)}
        value={user.name}
      /&gt;
      &lt;button onClick={onSubmitUser}&gt;Submit&lt;/button&gt;
    &lt;/div&gt;
  )
}
export default UserImmer;</pre>
<p>我们现在有一个使用Immer的组件，它有一个不可变的状态。这很容易开始，更容易维护，并且我们的代码可读性更好。如果您计划从React中的不可变性开始，并希望使您的状态不可变且更安全，Immer是您的最佳选择。</p>
<p>另一件对你来说很重要的事情是你不仅可以和React一起使用Immer，也可以和普通的JavaScript一起使用。所以，如果你打算用普通的JavaScript构建一个简单的应用程序，并且希望有一个不可变的状态，你可以很容易地使用Immer。从长远来看，拥有一个更自信、写得更好、更易维护的应用程序会对你有很大帮助。</p>
<h2>结论</h2>
<p>在本文中，我们学习了React中的不变性，以及如何使用Immer获得不可变的状态——使我们的应用程序更加安全、可读和可维护。要了解更多关于Immer的信息，你可以查看它的<a href="https://immerjs.github.io/immer/docs/introduction" target="_blank" rel="noopener noreferrer">文档</a>，如果你想了解这个神奇的库，你可以参加这个<a href="https://egghead.io/courses/immutable-javascript-data-structures-with-immer" target="_blank" rel="noopener noreferrer">课程</a>。</p>
<p> </p><div class="code-block code-block-17">
<div class="blog-plug inline-plug react-plug" vwo-el-id="26283398190">
<h2 vwo-el-id="41600691720"><a href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener"> LogRocket </a>:全面了解您的生产React应用</h2><p>调试React应用程序可能很困难，尤其是当用户遇到难以重现的问题时。如果您对监视和跟踪Redux状态、自动显示JavaScript错误以及跟踪缓慢的网络请求和组件加载时间感兴趣，</p><a href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" vwo-el-id="19356441070">try LogRocket</a><p>. </p><a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="19356441380">
<img class="first-react-image alignnone size-full wp-image-46 jetpack-lazy-image jetpack-lazy-image--handled" src="../Images/f300c244a1a1cf916df8b4cb02bec6c6.png" vwo-el-id="18272717540" data-lazy-loaded="1" data-original-src="https://files.readme.io/27c94e7-Image_2017-06-05_at_9.46.04_PM.png"/>
</a>
<a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="19356441690">
<img class="second-react-image alignnone size-full wp-image-46 jetpack-lazy-image jetpack-lazy-image--handled" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" vwo-el-id="30720362350" data-lazy-loaded="1" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/>
</a>
<p vwo-el-id="28675660440" class="">LogRocket 结合了会话回放、产品分析和错误跟踪，使软件团队能够创建理想的web和移动产品体验。这对你来说意味着什么？</p>
<p>代替猜测错误发生的原因，或者要求用户提供截图和日志转储，LogRocket允许您重放问题，就像它们发生在您自己的浏览器中一样，以快速了解出了什么问题。</p>
<p>不再有嘈杂的警报。智能错误跟踪允许您对问题进行分类，然后从中学习。获得有影响的用户问题的通知，而不是误报。警报越少，有用的信号越多。</p>
<p vwo-el-id="28675660750">LogRocket Redux中间件包为您的用户会话增加了一层额外的可见性。LogRocket记录Redux存储中的所有操作和状态。</p>
<p vwo-el-id="28675661060">现代化您调试React应用的方式— <a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="40093418840">开始免费监控</a>。</p>
</div></div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
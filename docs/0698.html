<html>
<head>
<title>Code-first vs. schema-first development in GraphQL - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>GraphQL - LogRocket博客中代码优先与模式优先的开发</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/code-first-vs-schema-first-development-graphql/#0001-01-01">https://blog.logrocket.com/code-first-vs-schema-first-development-graphql/#0001-01-01</a></blockquote><div><article class="article-post">
<blockquote><p>本文是正在进行的关于概念化、设计和实现GraphQL服务器的系列文章的一部分。该系列的前几篇文章是:</p>

</blockquote>
<hr/>
<p><a href="https://graphql.org"> GraphQL </a>模式通过导出可以针对服务执行的一组类型、字段和变异来定义GraphQL服务的契约。在创建GraphQL服务时，我们可以决定让模式成为事实的来源，并让我们所有的实现代码与其定义相匹配，或者让我们的代码成为事实的来源，让模式成为从代码生成的工件。</p>
<p>在这两种情况下，我们都将拥有一个全功能的GraphQL服务，但是根据我们使用的方法，我们可能能够实现更多或更少的功能，或多或少容易一些。这两种方法分别称为模式优先和代码优先。</p>
<p>在本文中，我们将探索这两种创建GraphQL服务的方法，回顾每种方法的优缺点，最后，表明立场并决定哪种方法可能是更好的选择。开始吧！</p>
<h2>什么是模式优先？</h2>
<p>Schema-first表示我们首先为GraphQL服务定义模式，然后通过匹配模式中的定义来实现代码。为了对模式进行编码，我们使用了<a href="https://www.howtographql.com/basics/2-core-concepts/">模式定义语言(SDL) </a>，这是一种为表示GraphQL数据模型而创建的语法。正因为如此，这种方法也可以称为SDL优先。</p>
<p>SDL为GraphQL的广泛流行做出了贡献。即使GraphQL的第一次实现和实用程序是在JavaScript中(2015年<a href="https://github.com/graphql/graphql-js"> graphql-js </a>，2016年<a href="https://github.com/apollographql/graphql-tools"> graphql-tools </a>)，SDL也被设计成语言无关的。不同语言的GraphQL服务器的实现——包括那些用于<a href="https://github.com/prisma/graphql-yoga"> Node.js </a>、<a href="http://graphql-ruby.org/"> Ruby </a>、<a href="http://graphene-python.org/"> Python </a>、<a href="https://sangria-graphql.org/"> Scala </a>、<a href="https://graphql-by-pop.com"> PHP </a>和其他语言的实现——可以读写SDL。</p>
<p>让我们看看SDL是什么样子的(我不会去详细介绍，因为有很多关于它的教程，像<a href="https://blog.logrocket.com/defining-types-for-your-graphql-api/">这个</a>)。在SDL定义一个具有属性<code>id</code>和<code>title</code>的类型<code>Film</code>，如下所示:</p>
<pre class="json">type Film {
  id: Int
  title: String!
}</pre>
<p>代码几乎是自描述的:title是string类型的属性(用title case: <code>String</code>编写)，它必须总是有一个值，通过字符<code>!</code>表示。</p>
<p>由于GraphQL完全是关于在图中查询关系的(这就是GraphQL这个名字的来源:图查询语言)，我们可以跨不同类型定义关系，就像这样:</p>
<pre class="json">type Film {
  id: Int
  title: String!
  director: Person!
  actors(limit: Int = 10): [Person]
}

type Person {
  id: Int
  name: String!
}</pre>
<p>由于一部电影可以有很多男演员和女演员，所以属性<code>actors</code>通过字符<code>[]</code>被定义为一个列表类型，我们可以通过自定义参数<code>limit</code>来限制在这个列表中返回多少个元素，默认值为10。</p>
<p>在这个简单的例子中，我们已经可以体会到SDL的最大优势:它非常简单明了，因此，对于技术人员和非技术人员来说都非常容易理解。因此，SDL可以作为一种交流工具，团队成员可以通过它协作创建组织的数据模型。</p>
<p>同样，我们已经可以注意到SDL带来的弊端。首先，SDL不包括解析器，即计算字段值的实际代码。因此，SDL不可能独自成为真理的唯一来源，因为它并不完整。最多，SDL只是在模式定义和解析之间带来了一个清晰的分离，如下面的代码(使用了<a href="https://github.com/apollographql/graphql-tools"> graphql-tools </a>):</p>
<pre class="javascript">const { makeExecutableSchema } = require('graphql-tools')

// Schema definition
const typeDefs = `
type Film {
  id: Int
  title: String!
  director: Person!
  actors(limit: Int = 10): [Person]
}

type Person {
  id: Int
  name: String!
}
`

// Schema resolution
const resolvers = {
  Film: {
    director: (film, args) =&gt; fetchUserById(film.directorID),
    actors: (film, args) =&gt; findUsers(film.actorIDs, {limit: args.limit}),
  }
}

const schema = makeExecutableSchema({
  typeDefs,
  resolvers,
})</pre>
<p>第二个缺点是解析器代码必须与SDL中的定义完全匹配(例如，类型为<code>String!</code>的属性必须是<code>String!</code>，而不是<code>String</code>或<code>Int!</code>)。因此，它不是干的(不要重复自己)；代码库中会有重复的信息，这些信息必须保持同步。</p>
<h2>什么是代码优先？</h2>
<p>在代码优先的方法中，我们首先对解析器进行编码，然后，从作为单一事实来源的代码开始，我们将模式作为工件生成。因此，我们仍然有一个模式，但是它不是手动创建的，而是通过运行脚本创建的。这种方法也可以称为解析器优先。</p>
<p>仅仅通过查看代码来理解模式不像查看SDL定义那样容易。因此，一些GraphQL服务器实现试图尽可能地镜像它们的代码，即SDL。</p>
<p>例如，在<a href="https://nexus.js.org/">Nexus</a>(JavaScript/TypeScript中代码优先的GraphQL服务器)中，定义字段的方法名已经表达了响应的类型(在下面的代码中:<code>t.int</code>、<code>t.string</code>、<code>t.field</code>表示与对象类型的关系，<code>t.list.field</code>表示与对象类型的关系列表)。实现与上面相同的模式如下所示:</p>
<pre class="javascript">const Film = objectType({
  name: "Film",
  definition(t) {
    t.int("id", { description: "Id of the film" });
    t.string("title", { description: "Title of the film" });
    t.field("director", {
      type: Person,
      resolve(root, args, ctx) {
        return ctx.getFilm(root.id).director();
      },
    });
    t.list.field("actors", {
      type: Person,
      nullable: true,
      args: {
        limit: intArg({
            required: false,
            default: 10,
            description: "Limit the number of actors/actresses"
        }),
      },
      resolve(root, args, ctx) {
        return ctx.getFilm(root.id).actors(args.limit);
      },
    });
  }
});

const Person = objectType({
  name: "Person",
  definition(t) {
    t.int("id");
    t.string("name");
  }
});</pre>
<p>要被解析为对象中同名属性的字段(例如来自类型<code>Film</code>的字段<code>id</code>和<code>title</code>，它们被解析为来自电影对象的属性<code>id</code>和<code>title</code>)可以省略它们的解析函数。如果数据模型主要由这样的简单属性组成，没有任何自定义逻辑需要解析，那么代码就很像SDL，就像上面代码中类型<code>Person</code>的情况一样。</p>
<p>Nexus强调声明性和可读性。因此，尽管不如阅读SDL那么容易理解，但它仍然足够好，可以用于交流模式的意图以及如何解决它。</p>
<p>其他GraphQL服务器也在它们的定义中模拟SDL，但是它们的结果可能不太理想。例如，<a href="https://webonyx.github.io/graphql-php/"> graphql-php </a>像这样实现上面的模式:</p>
<pre class="php">$film = new ObjectType([
    'name' =&gt; 'Film',
    'fields' =&gt; [
        'id' =&gt; Type::int(),
        'title' =&gt; [
            'type' =&gt; Type::string(),
            'description' =&gt; 'Film's title'
        ],
        'director' =&gt; [
            'type' =&gt; Type::nonNull($personType),
            'description' =&gt; 'Film director',
            'resolve' =&gt; function(Film $film) {
                return DataSource::findPerson($film-&gt;directorID);
            }
        ],
        'actors' =&gt; [
            'type' =&gt; Type::listOf($personType),
            'description' =&gt; 'List of actors/actresses in the film',
            'args' =&gt; [
                'limit' =&gt; [
                    'type' =&gt; Type::int(),
                    'description' =&gt; 'Limit the number of actors returned',
                    'defaultValue' =&gt; 10
                ]
            ],
            'resolve' =&gt; function(Film $film, $args) {
                return DataSource::findActors($film-&gt;id, $args['limit']);
            }
        ]
    ]
]);

$personType = new ObjectType([
    'name' =&gt; 'Person',
    'description' =&gt; 'A person',
    'fields' =&gt; [
        'id' =&gt; Type::int(),
        'name' =&gt; [
            'type' =&gt; Type::string(),
            'description' =&gt; 'Person's name'
        ],
    ]
]);
</pre>
<p>在这种情况下，定义更加不和谐，几个缩进切断了易读性，不同的语法颜色也碍事。因此，尽管该模式仍然是可理解的，但并不是对每个人都是如此，并且它作为跨团队交流工具的效用降低了。</p>
<p>从这些例子中，我们可以体会到代码优先模式的最大优点和缺点:它可以有效地成为数据模型的唯一来源，因为它包含了模式定义和解决它们的代码，但代价是更难理解。</p>
<p>请注意，我们仍然可以使用用SDL编写的模式来与我们的同事交流数据模型:通过运行一些脚本，模式可以作为工件从代码中生成。此外，生成的模式可以被一致地格式化以帮助其易读性，例如按字母顺序排序类型。</p>
<p>需要时，可以手动生成模式。它也可以作为我们持续集成过程的一部分来自动化——例如，每当我们的代码库被标记时触发它——并将新创建的文件提交到一个特殊的存储库中。这是GitHub为其<a href="https://github.com/octokit/graphql-schema">公共GraphQL模式</a>所采用的策略。</p>
<h2>选购模式优先或代码优先的GraphQL服务器</h2>
<p>我们可以选择这两种方法中的哪一种来创建我们的GraphQL服务。然而，可能必须在一开始就做出决定，因为它可能会影响我们使用哪个GraphQL服务器实现；大多数实现都会坚持使用其中一个，很少两个都用。</p>
<p>此外，这个决定也可能影响使用哪种语言。一些语言提供了这两种选择，比如JavaScript或TypeScript通过<a href="https://www.apollographql.com/docs/apollo-server/getting-started/#step-3-define-your-graphql-schema"> Apollo server </a>(模式优先)和<a href="https://nexus.js.org/"> Nexus </a>(代码优先)，Python通过<a href="https://ariadnegraphql.org/"> Ariadne </a>(模式优先)和<a href="https://graphene-python.org/"> Graphene </a>(代码优先)，以及。NET通过<a href="https://graphql-dotnet.github.io/docs/getting-started/introduction/"> GraphQL进行。NET </a>提供了两种选择。</p>
<p>然而，其他一些语言只有一种方法，比如Rust，它只有一个GraphQL服务器:<a href="https://github.com/graphql-rust/juniper"> Juniper </a>，它只支持代码优先的方法。</p>
<p>最后，它还可能影响我们可以使用某些语言的哪个框架。例如，对于PHP，<a href="https://laravel.com"> Laravel </a>可以通过<a href="https://lighthouse-php.com/"> Lighthouse </a>(模式优先)和<a href="https://github.com/rebing/graphql-laravel"> Laravel GraphQL </a>(代码优先)从两个选项中进行选择，但是<a href="https://wordpress.org"> WordPress </a>只有提供代码优先方法的解决方案，例如<a href="https://www.wpgraphql.com/"> WPGraphQL </a>和<a href="https://graphql-by-pop.com">PoP graph QL</a>。</p>
<p>所有语言的所有不同GraphQL服务器的链接可以在<a href="https://devhub.io/repos/chentsulin-awesome-graphql">这里</a>找到。</p>
<h2>不同实现者提倡的模式优先与代码优先</h2>
<p>到目前为止，我们已经回顾了这两种方法在易读性(模式优先更好)和成为没有重复代码的单一事实来源的能力(代码优先更好)方面的比较。然而，这些并不是唯一需要比较的特征。</p>
<p>接下来，让我们看看不同的实现者如何证明在他们自己的GraphQL服务器实现中使用这两种方法的合理性。</p>
<h3>为什么模式优先更好</h3>
<p>在“<a href="https://blog.mirumee.com/schema-first-graphql-the-road-less-travelled-cf0e50d5ccff">模式优先GraphQL:少走的路</a>”中，Mirumee的Jakub Draganek推广了GraphQL服务器<a href="https://ariadnegraphql.org/"> Ariadne </a>使用的模式优先方法。</p>
<p>Jakub提到让模式充当客户端和服务器端之间的公共契约的优点包括:</p>
<ul>
<li>这类似于进行测试驱动开发(TDD ),因为开发人员必须在开始编码解决方案之前考虑不同的用例以及用户的便利性，并且最终结果可能会带来更加模块化和可维护的设计。</li>
<li>它遵循依赖倒置原则(DIP ),这使得解决方案更加抽象，并且较少依赖于依赖。</li>
<li>它使客户端和服务器端开发人员能够同时工作，因为客户端开发人员不需要等待后端的工作先完成。该模式使得为API提供模拟数据成为可能，因此可以独立测试客户端，而无需准备好服务器端的GraphQL服务。</li>
</ul>
<h3>为什么代码优先更好</h3>
<p>在“<a href="https://www.prisma.io/blog/the-problems-of-schema-first-graphql-development-x1mn4cb0tyl3">‘模式优先’GraphQL服务器开发的问题</a>”(以及他在GraphQL Conf 2019 上的<a href="https://youtu.be/OloBAdNCnyQ">演讲)中，Prisma的Nikolas Burk提出了graph QL服务器</a><a href="https://nexus.js.org/"> Nexus </a>提供的代码优先方法。</p>
<p>按照Nikolas的说法，代码优先更好，因为模式优先不支持代码优先不支持的异常特性。与此同时，它使用起来更省力，因为与模式优先的方法相比，它不依赖于过多的工具。模式优先迫使开发人员使用大量的额外工具，这阻碍了他们的体验。</p>
<p>下面列出了一些挑战，模式优先需要一些工具来解决，而代码优先则不需要:</p>
<ul>
<li><strong>模式定义和解析器之间的不一致</strong>:确保模式定义始终与解析器同步。</li>
<li><strong>GraphQL模式的模块化</strong>:将graph QL类型定义组织成几个文件。</li>
<li>模式定义中的冗余(代码重用):重用SDL定义可能涉及大量样板文件和重复代码。</li>
<li><strong> IDE支持和开发人员体验</strong>:利用编辑器工作流中的GraphQL类型，从SDL代码的自动补全和构建时错误检查等功能中获益。</li>
<li><strong>组合GraphQL模式</strong>:将许多现有的(和分布式的)模式组合成一个模式。</li>
</ul>
<p>我想补充一点，模式优先中存在的问题在代码优先中不需要任何努力就可以解决，例如GraphQL规范中的这个问题，它涉及到在模式中本地化描述，以便让那些说不同语言的人可以使用它。</p>
<h2>根据我自己的经验，模式优先与代码优先</h2>
<p>毫无疑问，我完全支持代码优先的方法。让我解释一下我的立场。</p>
<p>我用PHP构建了一个GraphQL服务器，<a href="https://graphql-by-pop.com"> GraphQL by PoP </a>，它只支持代码优先的方法。缺少schema-first是因为PHP中没有合适的SDL解析器，而我自己实现一个解析器将花费大量的精力，我宁愿花在其他任务上。</p>
<p>然而，即使我可以，在我的GraphQL服务器中添加模式优先支持可能也没有多大意义，因为模式不是静态的，而是动态的:它可以根据需要变化，通过代码进行管理。动态模式提供了下面描述的所有好处，我非常怀疑通过模式优先的方法能否提供这些好处。</p>
<p>模式的<a href="https://newapi.getpop.org/api/graphql/?query=fullSchema">真值来源可以是GraphQL所需真值来源的超集(通过</a><a href="https://newapi.getpop.org/graphiql/">GraphQL</a>和<a href="https://newapi.getpop.org/graphql-interactive/"> Voyager </a>可以看到等价的graph QL模式)。额外的属性(比如全局字段、全局连接、全局指令和持久片段)已经可以在我们的API中使用，而不必等待它们被添加到GraphQL规范中(如果有的话)。</p>
<p>因为真理的来源与模式无关，所以我们也可以为任何其他系统生成任何模式；GraphQL只是目标之一。例如，它可以从相同的事实来源为REST服务生成一个JSON模式。</p>
<p>API可以同时是公共的/私有的，这取决于用户是否登录以及登录的用户角色，或者根据一些其他属性提供更多或更少的字段，例如用户是否为专业会员付费。</p>
<p>类型事先不知道它们将解析什么字段。相反，字段解析器使用<a href="https://en.wikipedia.org/wiki/Publish%E2%80%93subscribe_pattern">发布-订阅模式</a>将自己附加到类型解析器，并且字段解析器可以覆盖其他字段解析器。这个特性使得API具有很强的可扩展性，允许我们为自己的API编写一个通用代码，并在应用程序级别为特定的客户或项目定制它。</p>
<p>一个字段可以由不止一个字段解析器处理，而是由许多字段解析器处理:链中的每个字段解析器都可以在运行时决定是基于某个属性处理字段，还是沿着链传递字段。</p>
<p>例如，只有当字段参数<code>"source: testing"</code>被传递时，才可以使用一个特殊的字段解析器，使得它能够在正式发布之前在生产中的几个站点进行测试。同样的策略也使您能够为特定的客户端或环境提供快速的错误修复，而不会在其他地方冒意外副作用的风险。</p>
<p>上面描述的发布-订阅模式和字段解析器链接特性的组合也使得服务器的实现本身是分散的/联合的。事实上，不需要实现联合，因为联合或非联合API的编码方式是一样的，也不需要不同的团队为管理数据模型建立特殊的约定，就像<a href="https://www.apollographql.com/docs/apollo-server/federation/introduction/"> Apollo Federation </a>那样。</p>
<p>类型和接口可以<a href="https://leoloso.com/posts/added-namespaces-to-graphql-by-pop/">自动命名空间</a>以避免来自第三方的冲突。</p>
<p>我将在本系列的后续文章中描述这些策略及其实现。那么，我希望您会相信代码优先方法的优越性。</p>
<h2>结论</h2>
<p>在本文中，我们分析并比较了创建GraphQL服务的两种方法:模式优先和代码优先。尽管它们都有积极和消极的特点，基于我自己的经验，我可以说代码优先是更好的选择，因为它允许我们实现否则不可能实现的特性。</p>
<p>我不是一个人有这种感觉。在这条推文中，Prisma的Johannes Schickling预测，从2020年开始，代码优先的方法将会比模式优先更受欢迎。</p>
<p>Prisma有一些经验<a href="https://github.com/prisma-labs/">创建工具</a>来改善模式优先的固有限制，它创建了<a href="https://nexus.js.org/"> Nexus </a>以便通过代码优先的方法通过架构设计直接避免这些问题。因此，我相信约翰内斯肯定知道他在说什么，我会留意他的预测。</p>
<p>在任何情况下，使用模式优先还是代码优先仍然是一个必须基于每个项目具体情况的决定。如果您的团队已经知道如何处理它，或者您的模式永远不会从一个有限的大小开始增长，或者您只需要今天快速启动一些东西，而不需要担心未来，那么模式优先是理想的。</p><div class="code-block code-block-54">
<hr/>
<h3>更多来自LogRocket的精彩文章:</h3>

<hr/></div>
<p>然而，如果您需要扩展模式、联合模式、让自治团队处理模式，或者为特定的客户或项目定制模式，那么模式优先可能会产生一些棘手的问题。如果您认为您的模式最终会变得复杂或变大，那么代码优先是一条可行之路。</p><div class="code-block code-block-24">
<div class="blog-plug inline-plug graphql-plug"><h2>在生产环境中监控失败和缓慢的GraphQL请求</h2><p>虽然GraphQL有一些调试请求和响应的特性，但确保GraphQL可靠地为您的生产应用程序提供资源是一件比较困难的事情。如果您对确保对后端或第三方服务的网络请求成功感兴趣，</p><a href="https://lp.logrocket.com/blg/graphql-signup" target="_blank">try LogRocket</a><p>.</p><a class="signup" href="https://lp.logrocket.com/blg/graphql-signup" target="_blank" rel="noopener noreferrer"><img src="../Images/432a3823c85b3fb72a206e6236a29f48.png" data-lazy-src="https://files.readme.io/69aa835-Image_2019-11-09_at_1.28.05_PM.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" class=" jetpack-lazy-image" data-original-src="https://files.readme.io/69aa835-Image_2019-11-09_at_1.28.05_PM.png"/><noscript><img data-lazy-fallback="1" src="../Images/432a3823c85b3fb72a206e6236a29f48.png" data-original-src="https://files.readme.io/69aa835-Image_2019-11-09_at_1.28.05_PM.png"/></noscript><img class="alignnone size-full wp-image-46 jetpack-lazy-image" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/><noscript><img data-lazy-fallback="1" class="alignnone size-full wp-image-46" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/></noscript></a><a href="https://lp.logrocket.com/blg/graphql-signup" target="_blank" rel="noopener noreferrer">https://logrocket.com/signup/</a><p>LogRocket 就像是网络和移动应用的DVR，记录下你网站上发生的每一件事。您可以汇总并报告有问题的GraphQL请求，以快速了解根本原因，而不是猜测问题发生的原因。此外，您可以跟踪Apollo客户机状态并检查GraphQL查询的键值对。</p><p>LogRocket检测您的应用程序以记录基线性能计时，如页面加载时间、到达第一个字节的时间、慢速网络请求，还记录Redux、NgRx和Vuex操作/状态。</p><a class="signup" href="https://lp.logrocket.com/blg/graphql-signup" target="_blank" rel="noopener noreferrer">Start monitoring for free</a><p>.</p></div>


</div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
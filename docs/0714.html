<html>
<head>
<title>How to create randomly generated backgrounds with the CSS Paint API - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>如何使用CSS Paint API创建随机生成的背景</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/how-to-create-randomly-generated-backgrounds-with-the-css-paint-api/#0001-01-01">https://blog.logrocket.com/how-to-create-randomly-generated-backgrounds-with-the-css-paint-api/#0001-01-01</a></blockquote><div><article class="article-post">
<p>CSS Paint API(又名CSS Custom Paint)使开发人员能够编写JavaScript函数，将图像绘制到CSS属性中，如<code>background-image</code>、<code>border-image</code>等。在本文中，我们将讨论CSS Paint API的基础知识，特别是如何创建随机生成的背景。</p>
<h2 id="introductiontocsspaintapi">什么是CSS画图API</h2>
<p>CSS Paint API是CSS Houdini的一部分，CSS Houdini是一组低级API，允许开发人员直接访问CSS对象模型(CSSOM)。有了Houdini，开发人员可以创建他们自己的CSS功能，即使他们没有在浏览器中实现。</p>
<p>通常，我们会向元素添加背景图像，如下所示:</p>
<pre>body {
  background-image: url('path/to/image.jpg');
}
</pre>
<p>这个图像是静态的。如果从技术上考虑，当浏览器解析这段CSS代码时，它会向URL发送一个HTTP请求并获取图像。然后，它将图像显示为身体的背景图像。</p>
<p>与静态图像不同，您可以使用CSS Paint API来创建动态背景。请继续阅读，看看是如何做到的。</p>
<h2 id="gettingstartedwiththecsspaintapi">CSS画图API入门</h2>
<p>要开始使用CSS Paint API，请从以下步骤开始。</p>
<ol>
<li>添加CSS <code>paint()</code>函数</li>
<li>编写外部绘制小工具文件</li>
<li>在主线程中调用工作小程序</li>
</ol>
<p>在创建动态背景之前，我们先从一个简单的由气泡组成的静态背景开始。</p>
<p><img data-attachment-id="15000" data-permalink="https://blog.logrocket.com/how-to-create-randomly-generated-backgrounds-with-the-css-paint-api/bubble-background-css-paint-api/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/02/bubble-background-css-paint-api.png" data-orig-size="434,221" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Static background composed of bubbles" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/02/bubble-background-css-paint-api-300x153.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/02/bubble-background-css-paint-api.png" decoding="async" class="aligncenter size-full wp-image-15000 jetpack-lazy-image" src="../Images/00ff0953588993b932c1a5ffe9e81181.png" alt="Static Background Composed of Bubbles" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2020/02/bubble-background-css-paint-api.png 434w, https://blog.logrocket.com/wp-content/uploads/2020/02/bubble-background-css-paint-api-300x153.png 300w" data-lazy-sizes="(max-width: 434px) 100vw, 434px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2020/02/bubble-background-css-paint-api.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/02/bubble-background-css-paint-api.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="15000" data-permalink="https://blog.logrocket.com/how-to-create-randomly-generated-backgrounds-with-the-css-paint-api/bubble-background-css-paint-api/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/02/bubble-background-css-paint-api.png" data-orig-size="434,221" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Static background composed of bubbles" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/02/bubble-background-css-paint-api-300x153.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/02/bubble-background-css-paint-api.png" decoding="async" loading="lazy" class="aligncenter size-full wp-image-15000" src="../Images/00ff0953588993b932c1a5ffe9e81181.png" alt="Static Background Composed of Bubbles" srcset="https://blog.logrocket.com/wp-content/uploads/2020/02/bubble-background-css-paint-api.png 434w, https://blog.logrocket.com/wp-content/uploads/2020/02/bubble-background-css-paint-api-300x153.png 300w" sizes="(max-width: 434px) 100vw, 434px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/02/bubble-background-css-paint-api.png"/></noscript>
<p>首先，我们需要为风格建立一个元素。我们将使用一个简单的<code>&lt;div&gt;</code>元素。</p>
<pre>&lt;!-- index.html --&gt;
&lt;div id="bubble-background"&gt;&lt;/div&gt;
</pre>
<h3 id="step1addingthecsspaintfunction">步骤1:添加CSS <code>paint()</code>函数</h3>
<p>要将CSS Paint API用于背景，请将<code>paint()</code>函数添加到元素的<code>background-image</code>属性中。</p>
<pre>div#bubble-background {
  width:400px;
  height:200px;
  background-image: paint(bubblePaint);
}
</pre>
<p><code>bubblePaint</code>是我们将在接下来的步骤中创建的工作流。</p>
<h3 id="step2writinganexternalpaintworkletfile">步骤2:编写一个外部画图小工具文件</h3>
<p>我们需要将工作小程序保存在一个外部JavaScript文件中——我们称之为<code>bubble-paint.js</code>。</p>
<pre>// bubble-paint.js
registerPaint('bubblePaint', class {
  paint(ctx, geom) {
    const circleSize = 10; 
    const bodyWidth = geom.width;
    const bodyHeight = geom.height;

    const maxX = Math.floor(bodyWidth / circleSize);
    const maxY = Math.floor(bodyHeight / circleSize); 

    for (let y = 0; y &lt; maxY; y++) {
      for (let x = 0; x &lt; maxX; x++) {
        ctx.fillStyle = '#eee';
        ctx.beginPath();
        ctx.arc(x * circleSize * 2 + circleSize, y * circleSize * 2 + circleSize, circleSize, 0, 2 * Math.PI, true);
        ctx.closePath();
        ctx.fill();
      }
    }
  }
});
</pre>
<p>在这个文件中，<code>registerPaint()</code>函数注册了一个画图小工具。第一个参数是小工作程序的名称(与我们在<code>paint(bubblePaint)</code>中使用的相同)。下一个参数应该是一个带有<code>paint()</code>方法的类。</p>
<p><code>paint()</code>方法是我们编写JavaScript代码来呈现图像的地方。这里我们使用了两个论点:</p>
<ol>
<li><code>ctx</code>类似于<code>CanvasRenderingContext2D</code>(<code>canvas.getContext("2d")</code>的返回值)，虽然不完全相同。根据<a href="https://developers.google.com/web/updates/2018/01/paintapi" target="_blank" rel="noopener noreferrer">谷歌</a> : <br/> <blockquote> <p>的说法，一个画板的上下文与<code>&lt;canvas&gt;</code>的上下文并不是100%相同。到目前为止，文本渲染方法还没有出现，而且出于安全原因，您不能从画布上读回像素。</p> </blockquote></li>
<li><code>geom</code>包含两个元素:绘画元素的<code>width</code>和<code>height</code></li>
</ol>
<p>在函数内部，有一些创建模式的逻辑。<code>ctx.</code>函数是我们用来创建画布的。如果你不熟悉画布，我建议你浏览一下这个<a href="https://developer.mozilla.org/en-US/docs/Web/API/Canvas_API/Tutorial" target="_blank" rel="noopener noreferrer">画布API教程</a>。</p>
<h3 id="step3invokingtheworkletinthemainthread">步骤3:在主线程中调用工作小程序</h3>
<p>下一步是调用主JavaScript线程中的工作小程序(通常在HTML文件中)。</p>
<p class="codepen" data-height="265" data-theme-id="dark" data-default-tab="js,result" data-user="SupunKavinda" data-slug-hash="JjdbQZj" data-pen-title="JjdbQZj">参见<a href="https://codepen.io"> CodePen </a>上Supun Kavinda(<a href="https://codepen.io/SupunKavinda">@ SupunKavinda</a>)<br/>的笔<a href="https://codepen.io/SupunKavinda/pen/JjdbQZj"> <br/> JjdbQZj </a>。</p>
<p/>
<h2 id="dynamicbackgroundswiththecsspaintapi">CSS画图API的动态背景</h2>
<p>让我们把上面的泡泡的颜色和大小动态化。使用<a href="https://developer.mozilla.org/en-US/docs/Web/CSS/Using_CSS_custom_properties" target="_blank" rel="noopener noreferrer"> CSS变量</a>非常简单。</p>
<h3 id="step1addcssvariables">步骤1:添加CSS变量</h3>
<pre>div#bubble-background {
  --bubble-size: 40;
  --bubble-color: #eee;

  // other styles
}
</pre>
<h3 id="step2usecssvariables">步骤2:使用CSS变量</h3>
<p>为了在<code>paint()</code>方法中使用这些CSS变量，我们必须首先告诉浏览器我们将要使用它。这是通过向类添加静态属性<code>inputProperties()</code>来实现的。</p>
<pre>// bubble-paint.js
registerPaint('bubblePaint', class {
  static get inputProperties() { return ['--bubble-size', '--bubble-color']; }

  paint() { /* */ }
});
</pre>
<p>我们可以从<code>paint()</code>函数的第三个参数中访问这些属性。</p>
<pre>paint(ctx, geom, properties) {
    const circleSize = parseInt(properties.get('--bubble-size').toString());
    const circleColor = properties.get('--bubble-color').toString(); 

    const bodyWidth = geom.width;
    const bodyHeight = geom.height;

    const maxX = Math.floor(bodyWidth / circleSize);
    const maxY = Math.floor(bodyHeight / circleSize); 

    for (let y = 0; y &lt; maxY; y++) {
      for (let x = 0; x &lt; maxX; x++) {
        ctx.fillStyle = circleColor;
        ctx.beginPath();
        ctx.arc(x * circleSize * 2 + circleSize, y * circleSize * 2 + circleSize, circleSize, 0, 2 * Math.PI, true);
        ctx.closePath();
        ctx.fill();
      }
    }
}
</pre>
<p><img data-attachment-id="15069" data-permalink="https://blog.logrocket.com/how-to-create-randomly-generated-backgrounds-with-the-css-paint-api/dynamic-background-css-variables-3/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/03/dynamic-background-css-variables-3.gif" data-orig-size="700,392" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Dynamic background made with CSS variables" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/03/dynamic-background-css-variables-3-300x168.gif" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/03/dynamic-background-css-variables-3.gif" decoding="async" class="aligncenter size-full wp-image-15069 jetpack-lazy-image" src="../Images/475751c4ac4926cf2bbf975f32d248a6.png" alt="Dynamic Background Made With CSS Variables" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2020/03/dynamic-background-css-variables-3.gif?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/03/dynamic-background-css-variables-3.gif"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="15069" data-permalink="https://blog.logrocket.com/how-to-create-randomly-generated-backgrounds-with-the-css-paint-api/dynamic-background-css-variables-3/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/03/dynamic-background-css-variables-3.gif" data-orig-size="700,392" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Dynamic background made with CSS variables" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/03/dynamic-background-css-variables-3-300x168.gif" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/03/dynamic-background-css-variables-3.gif" decoding="async" loading="lazy" class="aligncenter size-full wp-image-15069" src="../Images/475751c4ac4926cf2bbf975f32d248a6.png" alt="Dynamic Background Made With CSS Variables" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/03/dynamic-background-css-variables-3.gif"/></noscript>
<p>这就是使用CSS Paint API创建动态背景是多么容易。</p>
<p>在<a href="https://codepen.io/SupunKavinda/full/abOBeVm" target="_blank" rel="noopener noreferrer"> CodePen </a>上的这个例子有两种不同的桌面和移动设备背景。</p>
<p>诀窍是改变<a href="https://developer.mozilla.org/en-US/docs/Web/CSS/Media_Queries/Using_media_queries" target="_blank" rel="noopener noreferrer">媒体查询</a>中的变量值。</p>
<pre>@media screen and (max-width:600px) {
  div#bubble-background {
    --bubble-size: 20;
    --bubble-color: green; 
  }
}
</pre>
<p>是不是很酷？想象一下静态图像——您需要在一个服务器上托管两个不同的图像来创建这些背景。有了CSS Paint API，我们可以创建无数漂亮的图形。</p>
<h2>创建随机生成的背景</h2>
<p>现在你已经熟悉了CSS Paint API，让我们来探索如何使用CSS Paint API创建随机生成的背景。</p>
<p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/random" target="_blank" rel="noopener noreferrer"> <code>Math.random()</code> </a>功能是制作随机生成背景的关键。</p>
<pre>Math.random()
// returns a float number inclusive of 0 and exclusive of 1
</pre>
<p>这里，我们正在执行与之前大致相同的过程；唯一的区别是我们在<code>paint()</code>方法中使用了<code>Math.random</code>函数。</p><div class="code-block code-block-54">
<hr/>
<h3>更多来自LogRocket的精彩文章:</h3>

<hr/></div>
<p>让我们创建一个随机渐变的背景。</p>
<pre>body {
  width:100%;
  height:100%;
  background-image: paint(randomBackground);
}


registerPaint('randomBackground', class {
  paint(ctx, geom) {
    const color1 = getRandomHexColor();
    const color2 = getRandomHexColor();

    const gradient = ctx.createLinearGradient(0, 0, geom.width, 0);
    gradient.addColorStop(0, color1);
    gradient.addColorStop(1, color2);

    ctx.fillStyle = gradient;
    ctx.fillRect(0, 0, geom.width, geom.height);
  }
})

function getRandomHexColor() {
  return '#'+ Math.floor(Math.random() * 16777215).toString(16)
}
</pre>
<p><code>getRandomHexColor</code>函数执行数学运算来创建一个随机的十六进制颜色。见这个<a href="https://dev.to/akhil_001/generating-random-color-with-single-line-of-js-code-fhj" target="_blank" rel="noopener noreferrer">有用的教程</a>了解更多关于如何工作的细节。</p>
<p>这是我们随机背景的最终结果。如果您重新载入页面，您将看到随机渐变，您可以使用它来制作独特而有趣的网页。</p>
<p class="codepen" data-height="265" data-theme-id="dark" data-default-tab="js,result" data-user="SupunKavinda" data-slug-hash="MWwEXaX" data-pen-title="MWwEXaX">参见<a href="https://codepen.io"> CodePen </a>上Supun Kavinda(<a href="https://codepen.io/SupunKavinda">@ SupunKavinda</a>)<br/>的笔<a href="https://codepen.io/SupunKavinda/pen/MWwEXaX"> <br/> MWwEXaX </a>。</p>
<p/>
<p>您还会注意到，当您调整浏览器窗口大小时，颜色会发生变化。这是因为浏览器通过在调整大小时用不同的<code>geom</code>值调用<code>paint()</code>方法来重新呈现背景。</p>
<p>虽然<code>Math.random</code>仅仅产生一个简单的随机数，但它是创建任何随机背景时最重要的函数。使用这种方法，你能做出的令人惊叹的东西的范围只受你想象力的限制。</p>
<h2 id="browsercompatibility">浏览器兼容性</h2>
<p>尽管CSS Paint API令人惊叹，但浏览器兼容性可能是一个问题。只有最新的浏览器版本支持它。这是来自<a href="https://ishoudinireadyyet.com/" target="_blank" rel="noopener noreferrer">的浏览器兼容性数据，胡迪尼准备好了吗？</a>撰写本文时。</p>
<p><img data-attachment-id="15002" data-permalink="https://blog.logrocket.com/how-to-create-randomly-generated-backgrounds-with-the-css-paint-api/browser-compatibility-houdini-2/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/02/browser-compatibility-houdini-1.png" data-orig-size="730,67" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Houdini’s browser compatibility" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/02/browser-compatibility-houdini-1-300x28.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/02/browser-compatibility-houdini-1.png" decoding="async" class="aligncenter size-full wp-image-15002 jetpack-lazy-image" src="../Images/8b33e82749d36663fb7e4ca04113a176.png" alt="Houdini's Browser Compatibility" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2020/02/browser-compatibility-houdini-1.png 730w, https://blog.logrocket.com/wp-content/uploads/2020/02/browser-compatibility-houdini-1-300x28.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2020/02/browser-compatibility-houdini-1.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/02/browser-compatibility-houdini-1.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="15002" data-permalink="https://blog.logrocket.com/how-to-create-randomly-generated-backgrounds-with-the-css-paint-api/browser-compatibility-houdini-2/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/02/browser-compatibility-houdini-1.png" data-orig-size="730,67" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Houdini’s browser compatibility" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/02/browser-compatibility-houdini-1-300x28.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/02/browser-compatibility-houdini-1.png" decoding="async" loading="lazy" class="aligncenter size-full wp-image-15002" src="../Images/8b33e82749d36663fb7e4ca04113a176.png" alt="Houdini's Browser Compatibility" srcset="https://blog.logrocket.com/wp-content/uploads/2020/02/browser-compatibility-houdini-1.png 730w, https://blog.logrocket.com/wp-content/uploads/2020/02/browser-compatibility-houdini-1-300x28.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/02/browser-compatibility-houdini-1.png"/></noscript>
<p>从这个数据来看，在制作中使用胡迪尼还不是一个好主意。然而，谷歌Chrome实验室团队创建了一个<a href="https://github.com/GoogleChromeLabs/css-paint-polyfill" target="_blank" rel="noopener noreferrer"> polyfill </a>，使得CSS Paint API可以在大多数浏览器中工作。然而，在生产中使用之前，一定要在所有主流浏览器上测试动态背景。</p>
<h3 id="detectingbrowsersupport">检测浏览器支持</h3>
<p>以下是如何在JavaScript中检测浏览器支持:</p>
<pre>if ('paintWorklet' in CSS) {
  CSS.paintWorklet.addModule('bubble-paint.js');
}
</pre>
<p>在CSS中:</p>
<pre>@supports (background: paint(id)) {
  div#bubble-background {
    width:400px;
    height:200px;
    background-image: paint(bubblePaint);
  }
}
&gt;</pre>
<h3 id="fallback">撤退</h3>
<p>CSS回退属性有助于改进浏览器支持。</p>
<pre>aside {
  background-image: url('/path/to/static/image');
  background-image: paint(bubblePaint);
}
</pre>
<p>不支持<code>paint()</code>功能的浏览器不会识别该语法。因此，它将忽略第二个并加载URL。支持它的浏览器将理解这两种语法，但是第二种语法将覆盖第一种语法。</p>
<h2 id="moreinterestingusecasesforcsspaintapi">CSS Paint API的其他有趣用例</h2>
<p>下面是使用CSS Paint API的一些其他有用和令人兴奋的方法。</p>
<h3 id="imageplaceholders">图像占位符</h3>
<p>使用CSS Paint API，我们可以在加载图像时绘制一个占位符来显示。这需要Houdini的新CSS属性和CSS Paint API。</p>
<p>请注意，只有少数浏览器支持CSS属性的<code>&lt;image&gt;</code>语法，因此它可能在您的浏览器中不起作用。</p>
<p class="codepen" data-height="265" data-theme-id="dark" data-default-tab="js,result" data-user="SupunKavinda" data-slug-hash="RwPKYBQ" data-pen-title="RwPKYBQ">参见<a href="https://codepen.io"> CodePen </a>上Supun Kavinda(<a href="https://codepen.io/SupunKavinda">@ SupunKavinda</a>)<br/>的笔<a href="https://codepen.io/SupunKavinda/pen/RwPKYBQ"> <br/> RwPKYBQ </a>。</p>
<p>画笔描边背景</p>
<h3 id="2brushstrokebackground">我见过无数的商业网站用笔触来强调他们的营销关键词。虽然可以使用canvas创建笔触，但使用CSS Paint API要容易得多。</h3>
<p>参见<a href="https://codepen.io"> CodePen </a>上Supun Kavinda(<a href="https://codepen.io/SupunKavinda">@ SupunKavinda</a>)<br/>的笔<a href="https://codepen.io/SupunKavinda/pen/VwLPEmd"> <br/> VwLPEmd </a>。</p>
<p class="codepen" data-height="265" data-theme-id="dark" data-default-tab="js,result" data-user="SupunKavinda" data-slug-hash="VwLPEmd" data-pen-title="VwLPEmd">由于它只是CSS，你可以根据需要改变变量并重用笔刷笔划。</p>
<p>结论</p>
<pre>.another-brushstroke {
  --brush-color: #fff;
  background-image: paint(brushstroke);
}
</pre>
<h2 id="conclusion">在本指南中，我们介绍了CSS Paint API的基础知识，并通过一些示例探讨了如何使用它。现在，您应该已经有了使用这个新的API创建更有创造性和动态图像所需的背景知识。虽然我们关注的是<code>background-image</code>，但是您也可以在其他属性中使用<code>paint()</code>函数(例如，<code>border-image</code>)。CSS画图API和其他CSS Houdini特性代表了CSS的未来，所以现在是时候开始了。</h2>
<p>一旦你掌握了基础知识，了解更多关于胡迪尼的知识，并查看这个可调整和可下载的<a href="https://paintlets.herokuapp.com/" target="_blank" rel="noopener noreferrer"> CSS画板库</a>。</p>
<p>你的前端是否占用了用户的CPU？</p><div class="code-block code-block-25">
<div class="blog-plug inline-plug css-plug"><h2>随着web前端变得越来越复杂，资源贪婪的特性对浏览器的要求越来越高。如果您对监控和跟踪生产环境中所有用户的客户端CPU使用情况、内存使用情况等感兴趣，</h2><p>.</p><a target="_blank" href="https://lp.logrocket.com/blg/css-signup">try LogRocket</a><p>LogRocket 就像是网络和移动应用的DVR，记录你的网络应用或网站上发生的一切。您可以汇总和报告关键的前端性能指标，重放用户会话和应用程序状态，记录网络请求，并自动显示所有错误，而不是猜测问题发生的原因。</p><a class="signup" href="https://lp.logrocket.com/blg/css-signup" target="_blank" rel="noopener noreferrer"><img class="alignnone size-full wp-image-46 jetpack-lazy-image" src="../Images/dacb06c713aec161ffeaffae5bd048cd.png" alt="LogRocket Dashboard Free Trial Banner" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2019/12/cpu-memory-usage.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/12/cpu-memory-usage.png"/><noscript><img data-lazy-fallback="1" class="alignnone size-full wp-image-46" src="../Images/dacb06c713aec161ffeaffae5bd048cd.png" alt="LogRocket Dashboard Free Trial Banner" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/12/cpu-memory-usage.png"/></noscript></a><a href="https://lp.logrocket.com/blg/css-signup" target="_blank" rel="noopener noreferrer">https://logrocket.com/signup/</a><p>现代化您调试web和移动应用的方式— <a class="signup" href="https://lp.logrocket.com/blg/css-signup" target="_blank" rel="noopener noreferrer">开始免费监控</a>。</p><p>Modernize how you debug web and mobile apps — <a class="signup" href="https://lp.logrocket.com/blg/css-signup" target="_blank" rel="noopener noreferrer">Start monitoring for free</a>.</p></div>
</div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
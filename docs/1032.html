<html>
<head>
<title>What's new in Immer 7.0 - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>Immer 7.0的新功能- LogRocket博客</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/whats-new-in-immer-7-0/#0001-01-01">https://blog.logrocket.com/whats-new-in-immer-7-0/#0001-01-01</a></blockquote><div><article class="article-post">
<p>6月10日发布的Immer 7.0包括许多新的创新、优化和突破性的变化。在本指南中，我们将了解Immer最新版本的新增功能。</p>
<p>我们将介绍一些最具影响力的变化，包括:</p>
<ul>
<li><code>current</code>的介绍</li>
<li><code>getters</code>和<code>setters</code>现在被一致地处理</li>
<li><code>produce</code>不再接受不可绘制的对象作为第一个参数</li>
<li>只能在汇票上调用</li>
<li>数组面片计算</li>
</ul>
<p>我们开始吧！</p>
<h2 id="introductionofimmer70">什么是Immer？</h2>
<p>您是否曾经想在JavaScript中使用不可变状态，但却以一种不方便的方式结束了工作，或者编写了许多行JavaScript代码？Immer是一个很小的包，它允许你以一种更方便的方式使用不可变状态。</p>
<p>基本思想很简单:Immer将您的所有更改应用到一个草稿状态，这是当前状态的代理。一旦你完成了草稿状态的改变，Immer就会产生下一个状态。这意味着您的当前状态对象是来自突变的状态，并且保留了不变性的所有好处。</p>
<h2 id="aworkingdemowithimmer">工作演示</h2>
<p>让我们来看一个简单的演示。</p>
<h3 id="installation">装置</h3>
<p>首先，升级到Immer的最新版本。在撰写本文时，<a href="https://github.com/immerjs/immer/releases/tag/v7.0.5" target="_blank" rel="noopener noreferrer">版本7.0.5 </a>是最新发布的版本。</p>
<pre>yarn add immer
// OR
npm install immer
</pre>
<p>打开一个JavaScript文件并粘贴以下内容。</p>
<pre>import produce from "immer"
const todos = [ //baseState
  {
    text: “learn Immer”
    done: false
  }
  {
    text: “learn cookimg
    done: true
  }
]
const nextState = produce (todos, draftState) = {
  draftState.push ({text: “writing”, done: false})
  draftState[0].done = true
});
// Comparisons
console.log(todos === nextState) //false
console.log (todos[0].done === nextState[0].done) //false
console.log(todos[1].done === nextState[0].done) // true
</pre>
<p><code>baseState</code>将保持不变，但是<code>nextState</code>将是一个新的、不可变的树，它反映了对<code>draftState</code>所做的所有更改(并且在结构上共享未更改的内容)。</p>
<p>上面的演示应该让你对Immer有一个很好的了解。欲了解更多信息，请查看<a href="https://immerjs.github.io/immer/docs/introduction">文档</a>。</p>
<p>现在让我们深入了解最新的更新。</p>
<h2 id="whatsnewinimmer70">Immer 7.0的5个主要变化</h2>
<p>现在让我们深入了解最新的更新。</p>
<h3 id="1theintroductionofcurrentmethod">1.<code>current</code>方法</h3>
<p>Immer公开了一个命名的export，<code>current</code>，它创建了草稿当前状态的副本。它会截取草稿的当前状态，并在不冻结对象的情况下完成它。这对于调试当前状态非常有用，因为这些对象不是代理对象。</p>
<p>这里有一个例子:</p>
<pre>const base = {
    x: 0
}

const next = produce(base, draft =&gt; {
    draft.x++
    const orig = original(draft)
    const copy = current(draft)
    console.log(orig.x)
    console.log(copy.x)

    setTimeout(() =&gt; {
        // this will execute after the produce has finised!
        console.log(orig.x)
        console.log(copy.x)
    }, 100)

    draft.x++
    console.log(draft.x)
})
console.log(next.x)

// This will print
// 0 (orig.x)
// 1 (copy.x)
// 2 (draft.x)
// 2 (next.x)
// 0 (after timeout, orig.x)
// 1 (after timeout, copy.x)
</pre>
<p>可以看到<a href="https://immerjs.github.io/immer/docs/current" target="_blank" rel="noopener noreferrer"> <code>current</code>方法</a>对<code>draft</code>的效果。</p>
<h3 id="2gettersandsettersarenowhandledconsistently">2.一致地处理Getters和setters</h3>
<p>如果你曾经将Immer与Vue或React一起使用，并试图与<a href="https://immerjs.github.io/immer/docs/complex-objects" target="_blank" rel="noopener noreferrer">类</a>一起工作，你会熟悉它总是产生的错误:</p>
<p><code>// Immer drafts cannot have computed properties.</code></p>
<p>在Immer 7.0中，这个错误正式绝迹。拥有的getters参与复制过程，就像<code>Object.assign</code>一样。</p>
<p>您可以在<a href="https://immerjs.github.io/immer/docs/complex-objects#semantics-in-detail" target="_blank" rel="noopener noreferrer">文档</a>中阅读更多关于getters和setters的内容。</p>
<h2 id="3nondraftableobjects">3.不可制图的物体</h2>
<p>不再接受不可绘制的对象作为第一个参数。不可起草对象是不可JSON序列化的对象，比如JavaScript中的<code>Date</code>对象(除非转换成字符串)。</p>
<p>Immer 7.0 <a href="https://github.com/immerjs/immer/blob/master/docs/complex-objects.md" target="_blank" rel="noopener noreferrer">不支持这种类型的对象</a>，遇到一个就会抛出异常。</p>
<h2 id="4originalcanonlybecalledondrafts">4.正本只能在汇票上兑付</h2>
<p>你有没有试过在不能被代理的对象上调用original，却被那个难看的<code>undefined</code>返回类型卡住了？对于版本7，Immer团队在原始API中添加了一个可捕捉的错误，所以它没有返回<code>undefined</code>，而是抛出了一个错误。</p>
<h2 id="5arraypatchescomputation">5.数组面片计算</h2>
<p>阵列的修补程序现在以不同的方式计算，以修复它们不正确的各种情况。在某些情况下，它们现在更理想；在<br/>其他人看来，就没那么回事了。例如，将项目拼接或取消移动到现有数组中可能会产生大量补丁。在Immer 7.0中，这不再是一个问题。</p>
<h2 id="conclusion">结论</h2>
<p>在本指南中，我们介绍了Immer 7.0中一些激动人心的新功能和四个突破性的变化。下面列出了超出本文范围的其他错误修复和重大更改。</p>
<h3 id="bugfixes">错误修复</h3>
<ol>
<li>生产状态<a href="https://github.com/immerjs/immer/issues/462" target="_blank" rel="noopener noreferrer">的所有分支都应被冻结</a></li>
<li>与<a href="https://github.com/immerjs/immer/issues/588" target="_blank" rel="noopener noreferrer">嵌套的<code>produce</code> </a>行为不一致</li>
<li>不适用于<a href="https://github.com/immerjs/immer/issues/577" target="_blank" rel="noopener noreferrer">多填充符号</a></li>
<li>显式调用<a href="https://github.com/immerjs/immer/pull/609" target="_blank" rel="noopener noreferrer"> <code>useProxies(false)</code> </a>不应该<a href="https://github.com/immerjs/immer/issues/514" target="_blank" rel="noopener noreferrer">检查代理</a>的存在</li>
<li><code>getownPropertyDescriptors</code>在<a href="https://github.com/immerjs/immer/commit/c7a47e251e9289561d7a7c539576c80e17dae2de" target="_blank" rel="noopener noreferrer">浏览器</a>或<a href="https://github.com/immerjs/immer/issues/626" target="_blank" rel="noopener noreferrer">爱马仕</a>中不可用</li>
</ol>
<p>前往<a href="https://github.com/immerjs/immer/releases/tag/v7.0.0" target="_blank" rel="noopener noreferrer"> GitHub </a>获取错误修复的完整列表。</p>
<h3 id="breakingchanges">重大变化</h3>
<ol>
<li>不可数和符号字段永远不会被冻结</li>
</ol>
<p>GitHub repo 有一个完整的重大变更列表。</p><div class="code-block code-block-28">
<div class="blog-plug inline-plug js-libraries-plug"><h2>您是否添加了新的JS库来提高性能或构建新特性？如果他们反其道而行之呢？</h2><p>毫无疑问，前端变得越来越复杂。当您向应用程序添加新的JavaScript库和其他依赖项时，您将需要更多的可见性，以确保您的用户不会遇到未知的问题。</p>
<p>LogRocket 是一个前端应用程序监控解决方案，可以让您回放JavaScript错误，就像它们发生在您自己的浏览器中一样，这样您就可以更有效地对错误做出反应。</p><a class="signup" href="https://lp.logrocket.com/blg/javascript-signup" target="_blank" rel="noopener noreferrer"><img class="alignnone size-full wp-image-46 jetpack-lazy-image" src="../Images/e8a0ab42befa3b3b1ae08c1439527dc6.png" alt="LogRocket Dashboard Free Trial Banner" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2019/10/errors-screenshot.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/10/errors-screenshot.png"/><noscript><img data-lazy-fallback="1" class="alignnone size-full wp-image-46" src="../Images/e8a0ab42befa3b3b1ae08c1439527dc6.png" alt="LogRocket Dashboard Free Trial Banner" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/10/errors-screenshot.png"/></noscript></a>
<a href="https://lp.logrocket.com/blg/javascript-signup" target="_blank" rel="noopener noreferrer">https://logrocket.com/signup/</a><p><a href="https://lp.logrocket.com/blg/javascript-signup" target="_blank" rel="noopener noreferrer"> LogRocket </a>可以与任何应用程序完美配合，不管是什么框架，并且有插件可以记录来自Redux、Vuex和@ngrx/store的额外上下文。您可以汇总并报告问题发生时应用程序的状态，而不是猜测问题发生的原因。LogRocket还可以监控应用的性能，报告客户端CPU负载、客户端内存使用等指标。</p><p>自信地构建— <a class="signup" href="https://lp.logrocket.com/blg/javascript-signup" target="_blank" rel="noopener noreferrer">开始免费监控</a>。</p></div>


</div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
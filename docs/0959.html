<html>
<head>
<title>Getting started with Neo4j - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>Neo4j入门- LogRocket博客</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/getting-started-with-neo4j/#0001-01-01">https://blog.logrocket.com/getting-started-with-neo4j/#0001-01-01</a></blockquote><div><article class="article-post">
<p>最简单的图是节点和关系的集合。图形数据库是一个数据库管理系统，它使用图形数据模型(节点和关系)来执行创建、读取、更新和删除(CRUD)操作。图形数据库被设计成将节点之间的关系视为一等公民。这意味着数据之间的连接不需要使用外键来推断。</p>
<p><img data-attachment-id="20886" data-permalink="https://blog.logrocket.com/getting-started-with-neo4j/sample-graph/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/06/sample-graph.jpeg" data-orig-size="722,402" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Sample graph" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/06/sample-graph-300x167.jpeg" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/06/sample-graph.jpeg" decoding="async" class="aligncenter size-full wp-image-20886 jetpack-lazy-image" src="../Images/8acc6dcc8cd180a235f6377c830e030c.png" alt="Sample Graph" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2020/06/sample-graph.jpeg 722w, https://blog.logrocket.com/wp-content/uploads/2020/06/sample-graph-300x167.jpeg 300w" data-lazy-sizes="(max-width: 722px) 100vw, 722px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2020/06/sample-graph.jpeg?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/06/sample-graph.jpeg"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="20886" data-permalink="https://blog.logrocket.com/getting-started-with-neo4j/sample-graph/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/06/sample-graph.jpeg" data-orig-size="722,402" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Sample graph" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/06/sample-graph-300x167.jpeg" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/06/sample-graph.jpeg" decoding="async" loading="lazy" class="aligncenter size-full wp-image-20886" src="../Images/8acc6dcc8cd180a235f6377c830e030c.png" alt="Sample Graph" srcset="https://blog.logrocket.com/wp-content/uploads/2020/06/sample-graph.jpeg 722w, https://blog.logrocket.com/wp-content/uploads/2020/06/sample-graph-300x167.jpeg 300w" sizes="(max-width: 722px) 100vw, 722px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/06/sample-graph.jpeg"/></noscript>
<h2 id="graphdatabaseconcepts">图形数据库概念</h2>
<h3>节点</h3>
<p>节点是图中的一个实体(如人、地点、对象或相关数据)。最简单的可能图形是单个节点。</p>
<p><img data-attachment-id="20887" data-permalink="https://blog.logrocket.com/getting-started-with-neo4j/graph-node/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/06/graph-node.jpeg" data-orig-size="192,101" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Graph node" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/06/graph-node.jpeg" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/06/graph-node.jpeg" decoding="async" class="aligncenter size-full wp-image-20887 jetpack-lazy-image" src="../Images/01b10b73ea44dfcdc13b0e328a4b306a.png" alt="Graph Node" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2020/06/graph-node.jpeg?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/06/graph-node.jpeg"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="20887" data-permalink="https://blog.logrocket.com/getting-started-with-neo4j/graph-node/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/06/graph-node.jpeg" data-orig-size="192,101" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Graph node" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/06/graph-node.jpeg" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/06/graph-node.jpeg" decoding="async" loading="lazy" class="aligncenter size-full wp-image-20887" src="../Images/01b10b73ea44dfcdc13b0e328a4b306a.png" alt="Graph Node" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/06/graph-node.jpeg"/></noscript>
<h3>标签</h3>
<p>标签用于将节点分组到集合中，使得标记有特定标签的所有节点属于同一集合。节点标签也可用于将元数据(如索引或约束)附加到某些节点。在上面的示例图中，所有代表人的节点都标有<code>:Person</code>。</p>
<h3>关系</h3>
<p>关系是两个节点之间的连接。关系总是有方向、类型、开始节点和结束节点。</p>
<p>我们的示例图将<code>ACTED_IN</code>、<code>HAS_CONTACT</code>和<code>DIRECTED</code>作为关系类型。克里斯·埃文斯节点具有传出关系，而“利刃出稍”节点具有传入关系。</p>
<h3>性能</h3>
<p>属性是用于向节点和关系添加属性的键值对。</p>
<p>在我们的示例图中，我们在<code>Person</code>节点上使用了属性<code>name</code>和<code>born</code>，在电影节点上使用了属性<code>title</code>和<code>released</code>，在<code>:ACTED_IN</code>关系上使用了属性<code>roles</code>。</p>
<p>属性值可以是以下任何数据类型:</p>
<ul>
<li><code>Integer</code></li>
<li><code>Float</code></li>
<li><code>String</code></li>
<li><code>Boolean</code></li>
<li><code>Point</code></li>
<li><code>Date</code></li>
<li><code>Time</code></li>
<li><code>LocalTime</code></li>
<li><code>DateTime</code></li>
<li><code>LocalDateTime</code>，以及</li>
<li><code>Duration</code></li>
</ul>
<h2 id="whyuseagraphdatabase">为什么要使用图形数据库？</h2>
<p>我们生活在一个高度关联的世界。如今，公司管理着大量互连的数据集。利用数据关系的最佳方式是使用一种非常重视关系的技术。这正是图形数据库所做的。图形数据库将关系信息存储为一级实体。</p>
<p>因为图形数据库不遵循严格的模式，所以它们最适合当今业务需求快速变化的敏捷团队。有了图形数据库，您可以灵活地扩展数据库，以适应不断变化的业务需求。</p>
<p>图形数据库旨在支持高效的数据检索，允许您实时遍历数百万个连接。</p>
<h2 id="graphdatabasessystems">图形数据库系统</h2>
<p>有如此多的图形数据库。下表显示了排名靠前的图形数据库(来源:<a href="https://db-engines.com/en/ranking/graph+dbms" target="_blank" rel="noopener noreferrer"> DB-Engines </a>)。</p>
<p><img data-attachment-id="20891" data-permalink="https://blog.logrocket.com/getting-started-with-neo4j/graph-databases-2/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/06/graph-databases-1.png" data-orig-size="730,846" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Graph databases" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/06/graph-databases-1-259x300.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/06/graph-databases-1.png" decoding="async" class="aligncenter size-full wp-image-20891 jetpack-lazy-image" src="../Images/18bb6c38528f9ee4ade4e54b418b284d.png" alt="Graph Databases" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2020/06/graph-databases-1.png 730w, https://blog.logrocket.com/wp-content/uploads/2020/06/graph-databases-1-259x300.png 259w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2020/06/graph-databases-1.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/06/graph-databases-1.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="20891" data-permalink="https://blog.logrocket.com/getting-started-with-neo4j/graph-databases-2/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/06/graph-databases-1.png" data-orig-size="730,846" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Graph databases" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/06/graph-databases-1-259x300.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/06/graph-databases-1.png" decoding="async" loading="lazy" class="aligncenter size-full wp-image-20891" src="../Images/18bb6c38528f9ee4ade4e54b418b284d.png" alt="Graph Databases" srcset="https://blog.logrocket.com/wp-content/uploads/2020/06/graph-databases-1.png 730w, https://blog.logrocket.com/wp-content/uploads/2020/06/graph-databases-1-259x300.png 259w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/06/graph-databases-1.png"/></noscript>
<p>如您所见，Neo4j是最流行的图形数据库系统。在本教程中，我们将带您了解如何使用Neo4j数据库。</p>
<h2 id="whatisneo4j">Neo4j是什么？</h2>
<p>Neo4j是一个开源的NoSQL本地图形数据库，为你的应用提供了一个ACID兼容的事务后端。</p>
<p>Neo4j被称为原生图数据库，因为它有效地实现了属性图模型，一直到存储级别。它还提供了完整的数据库特性，如ACID事务遵从性、集群支持和运行时故障转移。Neo4j支持自己的查询语言Cypher。</p>
<h2 id="installingneo4j">安装Neo4j</h2>
<p>在Neo4j中，有多种方式可以与图形数据交互并使用图形数据。出于本教程的目的，我们将使用Neo4j桌面。</p>
<p>Neo4j Desktop默认支持Cypher，不需要单独安装驱动程序。<a href="https://neo4j.com/download/" target="_blank" rel="noopener noreferrer">下载适用于您的操作系统的Neo4j Desktop </a>，然后按照安装说明进行操作。</p>
<h2 id="cypherquerylanguage">密码查询语言</h2>
<p><a href="https://neo4j.com/developer/cypher-query-language/" target="_blank" rel="noopener noreferrer"> Cypher </a>是Neo4j的图形查询语言。它允许用户从图形数据库中存储和检索数据。</p>
<p>Neo4j的Cypher查询语言易于任何人学习、理解和使用。Cypher结合了其他标准数据访问语言的能力和功能。</p>
<h2 id="queryingnodesandrelationshipswithcypher">用密码查询节点和关系</h2>
<p>在我们探索如何查询Neo4j图形数据库之前，让我们创建一个新的数据库并用数据填充它。</p>
<p>打开你安装的Neo4j桌面应用，创建一个名为<code>learn-neo4j</code>的新数据库。在Neo4j浏览器中打开新数据库，运行下面的查询，用初始数据填充数据库。</p>
<pre>// post data
CREATE (johnnyMnemonic:Movie {title:"Johnny Mnemonic",tagline:"The hottest data on earth. In the coolest head in town",released:1995} )
CREATE (sleepless:Movie {title:"Sleepless in Seattle",tagline:"What if someone you never met, someone you never saw, someone you never knew was the only someone for you?",released:1993})
CREATE (dreams:Movie {title:"What Dreams May Come", tagline:"After life there is more. The end is just the beginning.",released:1998}  )
CREATE (dina:Person {name:"Dina Meyer", born:1968} )
CREATE(ice:Person {name:"Ice-T", born:1958})
CREATE(keenu:Person {name:"Keanu Reeves", born:1964})
CREATE(takeshi:Person {name:"Takeshi Kitano", born:1947})
CREATE (robert:Person {name:"Robert Longo", born:1953})
CREATE (meg:Person {name:"Meg Ryan", born:1961} )
CREATE (cuba:Person {name:"Cuba Gooding Jr.", born:1968} )
CREATE (vin:Person {name: "Vincent Ward", born:1956})
CREATE (dina)-[:ACTED_IN { roles: ["Jane"]}]-&gt;(johnnyMnemonic)
CREATE (ice)-[:ACTED_IN { roles: ["J-Bone"]}]-&gt;(johnnyMnemonic)
CREATE (keenu)-[:ACTED_IN { roles: ["Johnny Mnemonic"]}]-&gt;(johnnyMnemonic)
CREATE (takeshi)-[:ACTED_IN { roles: ["Takahashi"]}]-&gt;(johnnyMnemonic)
CREATE (meg)-[:ACTED_IN {roles:["Annie Reed"]} ]-&gt;(sleepless)
CREATE (robert)-[:DIRECTED]-&gt;(johnnyMnemonic)
CREATE (cuba)-[:ACTED_IN]-&gt;(dreams)
CREATE (cuba)-[:HAS_CONTACT]-&gt;(vin)
CREATE (vin)-[:DIRECTED]-&gt;(dreams)
CREATE (cuba)-[:HAS_CONTACT]-&gt;(meg)
CREATE (meg)-[:HAS_CONTACT]-&gt;(dina)
CREATE (robert)-[:HAS_CONTACT]-&gt;(meg)
CREATE (robert)-[:HAS_CONTACT]-&gt;(vin)
CREATE (robert)-[:HAS_CONTACT]-&gt;(cuba)
</pre>
<h3>匹配节点</h3>
<p>要检索Neo4j图中的节点，我们使用<code>MATCH</code>语句。<code>MATCH</code>语句将搜索我们指定的模式，并为每个成功匹配的模式返回一行。</p>
<p>您可以找到图中存在的所有节点。</p>
<pre>MATCH (n)
RETURN n
</pre>
<p><code>n</code>是代表所有匹配节点的变量。在这种情况下，它是我们图中的所有节点。结果如下:</p>
<p><img decoding="async" src="../Images/8e978068f94fd3d05e95658dc0b91cf9.png" alt="All nodes in our graph" data-lazy-src="https://paper-attachments.dropbox.com/s_045E197C0E8CED79D79FD65884042E6EF831F3460A09EAA35196195FC8B4FD52_1589875184685_Screenshot+2020-05-19+at+08.59.19.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" class=" jetpack-lazy-image" data-original-src="https://paper-attachments.dropbox.com/s_045E197C0E8CED79D79FD65884042E6EF831F3460A09EAA35196195FC8B4FD52_1589875184685_Screenshot+2020-05-19+at+08.59.19.png"/></p><noscript><img data-lazy-fallback="1" decoding="async" src="../Images/8e978068f94fd3d05e95658dc0b91cf9.png" alt="All nodes in our graph" data-original-src="https://paper-attachments.dropbox.com/s_045E197C0E8CED79D79FD65884042E6EF831F3460A09EAA35196195FC8B4FD52_1589875184685_Screenshot+2020-05-19+at+08.59.19.png"/></noscript>
<p>通过添加节点的标签，我们可以将查询限制为搜索特定的节点。</p>
<pre>MATCH (n:Person)
RETURN n
╒═══════════════════════════════════════╕
│"n"                                    │
╞═══════════════════════════════════════╡
│{"name":"Dina Meyer","born":1968}      │
├───────────────────────────────────────┤
│{"name":"Robert Longo","born":1953}    │
├───────────────────────────────────────┤
│{"name":"Meg Ryan","born":1961}        │
├───────────────────────────────────────┤
│{"name":"Cuba Gooding Jr.","born":1968}│
├───────────────────────────────────────┤
│{"name":"Vincent Ward","born":1956}    │
└───────────────────────────────────────┘
</pre>
<p>该查询仅返回标记为<code>Person</code>的节点。</p>
<h3>匹配关系</h3>
<p>最简单的关系匹配是通过使用<code>--</code>将一个节点与另一个节点连接起来，而无需指定方向。</p>
<pre>MATCH(m)--(n)
RETURN m, n
</pre>
<p><img data-attachment-id="20890" data-permalink="https://blog.logrocket.com/getting-started-with-neo4j/all-nodes-relationships/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/06/all-nodes-relationships.png" data-orig-size="730,280" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="All node relationships" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/06/all-nodes-relationships-300x115.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/06/all-nodes-relationships.png" decoding="async" class="aligncenter size-full wp-image-20890 jetpack-lazy-image" src="../Images/b73ada80c2fa757ee147e70551a5c04f.png" alt="All Node Relationships" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2020/06/all-nodes-relationships.png 730w, https://blog.logrocket.com/wp-content/uploads/2020/06/all-nodes-relationships-300x115.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2020/06/all-nodes-relationships.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/06/all-nodes-relationships.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="20890" data-permalink="https://blog.logrocket.com/getting-started-with-neo4j/all-nodes-relationships/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/06/all-nodes-relationships.png" data-orig-size="730,280" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="All node relationships" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/06/all-nodes-relationships-300x115.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/06/all-nodes-relationships.png" decoding="async" loading="lazy" class="aligncenter size-full wp-image-20890" src="../Images/b73ada80c2fa757ee147e70551a5c04f.png" alt="All Node Relationships" srcset="https://blog.logrocket.com/wp-content/uploads/2020/06/all-nodes-relationships.png 730w, https://blog.logrocket.com/wp-content/uploads/2020/06/all-nodes-relationships-300x115.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/06/all-nodes-relationships.png"/></noscript>
<p><code>--</code>表示连接节点<code>m</code>和<code>n</code>的关系。</p>
<p>上面的Cypher查询没有返回任何关于关系的信息。为了获得关系信息，我们需要给关系分配一个变量。关系变量用方括号([])命名。</p>
<pre>MATCH(m)-[rel]-(n)
RETURN m, rel, n
</pre>
<p>您还可以通过在连接节点的任意一端使用<code>&lt;</code>或<code>&gt;</code>来指定关系的方向。</p>
<p>为了匹配与节点<code>n</code>有关系的节点<code>m</code>，查询应该是这样的:</p>
<pre>MATCH(m)-[rel]-&gt;(n)
RETURN m, rel, n
</pre>
<p>这里，我们匹配与另一个节点有任何关系的任何节点。为了匹配特定的关系，我们必须添加关系类型。</p>
<p>我们的图形数据库有一个叫做<code>:ACTED_IN</code>的关系类型。让我们匹配一个通过<code>:ACTED_IN</code>关系连接到另一个节点的节点。</p>
<pre>MATCH(m)-[rel:ACTED_IN]-(n)
RETURN m, rel, n
</pre>
<p>为了将我们的搜索限制到特定的节点，我们可以向节点添加标签。</p>
<pre>MATCH(someone:Person)-[rel:ACTED_IN | DIRECTED]-(movie:Movie)
RETURN someone, rel, movie

╒══════════════════╤════════════════════════╤══════════════════════╕
│"someone.name"    │"rel"                   │"movie.title"         │
╞══════════════════╪════════════════════════╪══════════════════════╡
│"Robert Longo"    │{}                      │"Johnny Mnemonic"     │
├──────────────────┼────────────────────────┼──────────────────────┤
│"Dina Meyer"      │{"roles":["Jane"]}      │"Johnny Mnemonic"     │
├──────────────────┼────────────────────────┼──────────────────────┤
│"Meg Ryan"        │{"roles":["Annie Reed"]}│"Sleepless in Seattle"│
├──────────────────┼────────────────────────┼──────────────────────┤
│"Vincent Ward"    │{}                      │"What Dreams May Come"│
├──────────────────┼────────────────────────┼──────────────────────┤
│"Cuba Gooding Jr."│{}                      │"What Dreams May Come"│
└──────────────────┴────────────────────────┴──────────────────────┘
</pre>
<p>管道字符(<code>|</code>)表示关系可以是<code>ACTED_IN</code>或<code>DIRECTED</code>类型。</p>
<h2 id="filteringresults">过滤结果</h2>
<p>到目前为止，我们已经匹配了图形数据库中的节点和关系，并返回了找到的所有结果。现在让我们来看看如何过滤结果并只返回特定的数据子集。</p>
<p>可以通过使用花括号(<code>{}</code>)在<code>MATCH</code>语句中指定感兴趣的属性，或者使用<code>WHERE</code>子句来完成密码过滤。</p>
<pre>MATCH(someone{ name: "Robert Longo" })
RETURN someone
╒═══════════════════════════════════╕
│"someone"                          │
╞═══════════════════════════════════╡
│{"name":"Robert Longo","born":1953}│
└───────────────────────────────────┘
</pre>
<p>Neo4j将搜索所有节点，寻找具有<code>name</code>属性和值<code>Robert Longo</code>的节点。</p>
<p>您可以通过添加标签将搜索限制在某些节点上。</p>
<pre>MATCH(someone:Person{ name: "Robert Longo" })
RETURN someone

╒═══════════════════════════════════╕
│"someone"                          │
╞═══════════════════════════════════╡
│{"name":"Robert Longo","born":1953}│
└───────────────────────────────────┘
</pre>
<p>搜索也可以针对多个逗号分隔的属性进行。</p>
<pre>MATCH(someone:Person{ name: "Robert Longo", born: 1953 })
RETURN someone

╒═══════════════════════════════════╕
│"someone"                          │
╞═══════════════════════════════════╡
│{"name":"Robert Longo","born":1953}│
└───────────────────────────────────┘
</pre>
<h3><code>WHERE</code>条款</h3>
<p>您还可以使用<code>WHERE</code>子句执行过滤。让我们使用<code>WHERE</code>子句重写上面的过滤。</p>
<pre>MATCH(robert: Person)
WHERE robert.name = "Robert Longo" AND hugo.born = 1953
RETURN robert;
</pre>
<p>这将返回与上面相同的结果。</p>
<h3>比较运算符</h3>
<p>有几个比较运算符可以和<code>WHERE</code>子句一起使用。在上面的<code>WHERE</code>子句示例中，我们使用了一个比较运算符(<code>=</code>)来比较节点的<code>name</code>属性和值<code>Hugo Weaving</code>。其他运算符有:<code>&lt;</code>、<code>&gt;</code>、<code>&lt;=</code>、<code>&gt;=</code>、<code>&lt;&gt;</code>(不等于)。</p>
<pre>MATCH(person: Person)
WHERE person.born &gt;= 1960
RETURN person;

╒═══════════════════════════════════════╕
│"person"                               │
╞═══════════════════════════════════════╡
│{"name":"Dina Meyer","born":1968}      │
├───────────────────────────────────────┤
│{"name":"Meg Ryan","born":1961}        │
├───────────────────────────────────────┤
│{"name":"Cuba Gooding Jr.","born":1968}│
└───────────────────────────────────────┘

MATCH(person: Person)
WHERE person.born &lt;&gt; 1968 AND person.born &lt;&gt; 1956
RETURN person;

╒═══════════════════════════════════╕
│"person"                           │
╞═══════════════════════════════════╡
│{"name":"Robert Longo","born":1953}│
├───────────────────────────────────┤
│{"name":"Meg Ryan","born":1961}    │
└───────────────────────────────────┘
</pre>
<h3>布尔运算符</h3>
<p>布尔运算符允许您执行高级过滤。使用布尔运算符，您可以将多个<code>WHERE</code>语句合并成一个。</p>
<p>在上面的<code>WHERE</code>子句示例中，我们还没有检查布尔运算符<code>AND</code>的示例。<code>OR</code>、<code>NOT</code>、<code>IN</code>和<code>XOR</code>是可以用来执行过滤的其他布尔运算符。</p>
<pre>MATCH(person: Person)
WHERE person.born = 1961 OR person.born = 1962 OR person.born = 1963
RETURN person;

╒═══════════════════════════════╕
│"person"                       │
╞═══════════════════════════════╡
│{"name":"Meg Ryan","born":1961}│
└───────────────────────────────┘
</pre>
<p>上述查询返回出生于1961年、1962年或1963年的人。如果您想要扩展查询并添加更多的年份，那么写出来会变得很长而且有点乏味。当要比较的值变大时，可以使用<code>IN</code>运算符代替<code>OR</code>。</p>
<pre>MATCH(person: Person)
WHERE person.born IN [1960, 1961, 1962, 1963, 1964, 1965]
RETURN person;

╒═══════════════════════════════╕
│"person"                       │
╞═══════════════════════════════╡
│{"name":"Meg Ryan","born":1961}│
└───────────────────────────────┘
</pre>
<p>为了匹配更大的范围，比如1960年到2000年之间的年份，可以组合使用布尔运算符<code>AND</code>和比较运算符<code>&lt;=</code>和<code>&gt;=</code>。</p>
<pre>MATCH(person: Person)
WHERE person.born &gt;= 1960 AND person.born &lt;= 2000
RETURN person;

╒═══════════════════════════════════════╕
│"person"                               │
╞═══════════════════════════════════════╡
│{"name":"Dina Meyer","born":1968}      │
├───────────────────────────────────────┤
│{"name":"Meg Ryan","born":1961}        │
├───────────────────────────────────────┤
│{"name":"Cuba Gooding Jr.","born":1968}│
└───────────────────────────────────────┘
</pre>
<h2 id="orderingandpagination">排序和分页</h2>
<p>使用<code>ORDER BY expression [ASC|DESC]</code>子句完成排序。<code>ORDER BY</code>使用节点或关系的属性对节点和关系进行排序。</p>
<p>分页是使用<code>SKIP {offset}</code>和<code>LIMIT {count}</code>子句完成的</p>
<h3><code>ORDER BY</code></h3>
<pre>MATCH(actor: Person)-[:ACTED_IN]-&gt;(movie:Movie)
WHERE movie.title = "Johnny Mnemonic"
RETURN actor
ORDER BY actor.born

╒═════════════════════════════════════╕
│"actor"                              │
╞═════════════════════════════════════╡
│{"name":"Takeshi Kitano","born":1947}│
├─────────────────────────────────────┤
│{"name":"Ice-T","born":1958}         │
├─────────────────────────────────────┤
│{"name":"Keanu Reeves","born":1964}  │
├─────────────────────────────────────┤
│{"name":"Dina Meyer","born":1968}    │
└─────────────────────────────────────┘
</pre>
<p>该查询按照出生年份的升序返回电影“Johnny Mnemonic”中的所有演员。要以出生年份的降序返回演员，请在用于执行排序的变量后添加关键字<code>DESC</code>。</p>
<pre>MATCH(actor: Person)-[:ACTED_IN]-&gt;(movie:Movie)
WHERE movie.title = "Johnny Mnemonic"
RETURN actor
ORDER BY actor.born DESC

╒═════════════════════════════════════╕
│"actor"                              │
╞═════════════════════════════════════╡
│{"name":"Dina Meyer","born":1968}    │
├─────────────────────────────────────┤
│{"name":"Keanu Reeves","born":1964}  │
├─────────────────────────────────────┤
│{"name":"Ice-T","born":1958}         │
├─────────────────────────────────────┤
│{"name":"Takeshi Kitano","born":1947}│
└─────────────────────────────────────┘
</pre>
<h3><code>SKIP</code>和<code>LIMIT</code></h3>
<p>如果你不想要顶部的<code>n</code>结果，你可以用<code>SKIP</code>修剪掉<code>if</code>。<code>SKIP</code>接受任何计算结果为正整数的表达式。</p>
<pre>MATCH(actor: Person)-[:ACTED_IN]-&gt;(movie:Movie)
WHERE movie.title = "Johnny Mnemonic"
RETURN actor
ORDER BY actor.born DESC
SKIP 2

╒═════════════════════════════════════╕
│"actor"                              │
╞═════════════════════════════════════╡
│{"name":"Ice-T","born":1958}         │
├─────────────────────────────────────┤
│{"name":"Takeshi Kitano","born":1947}│
└─────────────────────────────────────┘
</pre>
<p>“约翰尼助记符”这部电影有四位演员。前两个参与者被跳过，其他人返回。</p>
<p><code>LIMIT</code>将约束结果中的行数。就像<code>SKIP</code>，<code>LIMIT</code>接受任何计算结果为正整数的表达式。</p>
<pre>MATCH(actor: Person)-[:ACTED_IN]-&gt;(movie:Movie)
WHERE movie.title = "Johnny Mnemonic"
RETURN actor
ORDER BY actor.born DESC
SKIP 2
LIMIT 1

╒════════════════════════════╕
│"actor"                     │
╞════════════════════════════╡
│{"name":"Ice-T","born":1958}│
└────────────────────────────┘
</pre>
<p>查询结果被限制为单行。</p>
<h2 id="aggregationfunctions">聚合函数</h2>
<p>Cypher还支持聚合操作，例如计算平均值、总和、最小值/最大值和计数。</p>
<p>在Cypher中，在计算最终结果时，聚合发生在<code>RETURN</code>子句中。常见的聚合函数有:<code>count</code>、<code>sum</code>、<code>avg</code>、<code>min</code>、<code>max</code>等。</p>
<h3><code>count</code></h3>
<p><code>count()</code>返回与表达式匹配的值或行数。</p>
<p>有两种不同的方式执行<code>count()</code>操作。第一种是通过使用<code>count(n)</code>来计算<code>n</code>的出现次数(结果不包括<code>null</code>值)。</p>
<p>执行<code>count()</code>操作的另一种方法是使用<code>count(*)</code>，它计算返回的结果行数(包括那些带有<code>null</code>值的行)。</p>
<p>以下是你如何计算电影《强尼助记》中出现的演员人数:</p>
<pre>MATCH(actor: Person)-[:ACTED_IN]-&gt;(movie:Movie)
WHERE movie.title = "Johnny Mnemonic"
RETURN count(actor)

╒══════════════╕
│"count(actor)"│
╞══════════════╡
│4             │
└──────────────┘
</pre>
<p>要仅计算唯一值，请使用<code>DISTINCT</code>。比如:<code>count(DISTINCT actor)</code>。</p>
<h3><code>sum</code></h3>
<p><code>sum()</code>返回一组数值或持续时间的总和。假设我们图表中的<code>:ACTED_IN</code>关系有一个名为<code>earning</code>的数字属性，您可以计算某个演员在他们出演的电影中赚的钱。</p>
<pre>MATCH(actor:Person)-[role:ACTED_IN ]-(movie:Movie)
WHERE actor.name = "Dina Meyer"
RETURN sum(role.earning)
</pre>
<h3><code>avg</code></h3>
<p><code>avg()</code>返回一组数值或持续时间的平均值。要计算我们数据库中演员的平均出生年份:</p>
<pre>MATCH(actor:Person)-[role:ACTED_IN ]-(movie:Movie)
RETURN avg(actor.born)

╒═════════════════╕
│"avg(actor.born)"│
╞═════════════════╡
│1961.0           │
└─────────────────┘
</pre>
<h3><code>max</code>和<code>min</code></h3>
<p><code>max()</code>返回一组数值中的最大值，而<code>min()</code>返回最小值。</p>
<h2 id="stringfunctions">字符串函数</h2>
<p>在Cypher中，字符串函数用于将非字符串值转换为字符串，并以某种方式操作现有的字符串。常见的字符串函数有<code>toString</code>、<code>toUpper</code>、<code>toLower</code>、<code>trim</code>等。</p>
<h3><code>toString</code></h3>
<p><code>toString()</code>函数将一个整数、浮点数或布尔值转换成它的等效字符串。</p>
<pre>RETURN toString(true)

╒════════════════╕
│"toString(true)"│
╞════════════════╡
│"true"          │
└────────────────┘
</pre>
<h3><code>toUpper</code>和<code>toLower</code></h3>
<p><code>toUpper()</code>函数接受一个字符串值，并以大写形式返回原始字符串。<code>toLower()</code>返回小写的原始字符串。</p>
<pre>RETURN toLower("STRING")

╒═══════════════════╕
│"toLower("STRING")"│
╞═══════════════════╡
│"string"           │
└───────────────────┘
</pre>
<h3><code>trim</code></h3>
<p><code>trim()</code>接受一个字符串并返回一个去掉了前导和尾随空格的新字符串。</p>
<pre>RETURN trim("   I will be trimmed     ")

╒═══════════════════════════════════╕
│"trim("   I will be trimmed     ")"│
╞═══════════════════════════════════╡
│"I will be trimmed"                │
└───────────────────────────────────┘
</pre>
<h2 id="mathfunctions">数学函数</h2>
<p>数学函数只对数值进行运算。如果数学函数使用了非数值，数据库将抛出错误。</p>
<p>密码中的数学函数有<code>ceil</code>、<code>floor</code>、<code>rand</code>、<code>round</code>等。</p>
<h3><code>floor</code></h3>
<p><code>floor()</code>返回小于或等于表达式的最大浮点值。</p>
<pre>RETURN floor(0.9)

╒════════════╕
│"floor(0.9)"│
╞════════════╡
│0.0         │
└────────────┘
</pre>
<h3><code>ceil</code></h3>
<p><code>ceil()</code>返回大于或等于表达式的最大浮点值。</p>
<pre>RETURN ceil(0.9)

╒═══════════╕
│"ceil(0.9)"│
╞═══════════╡
│1.0        │
└───────────┘
</pre>
<h3><code>round</code></h3>
<p><code>round()</code>返回给定数字舍入到最接近整数的值。</p>
<pre>╒═════════════════╕
│"round(3.141592)"│
╞═════════════════╡
│3.0              │
└─────────────────┘
</pre>
<h3><code>rand</code></h3>
<p><code>rand()</code>返回在<code>0</code>(含)和<code>1</code>之间的随机浮点值。</p>
<pre>RETURN rand()

╒═════════════════╕
│"rand()"         │
╞═════════════════╡
│0.161308614578638│
└─────────────────┘
</pre>
<h2 id="creatingnodesandrelationshipswithcypher">使用Cypher创建节点和关系</h2>
<p>在Cypher中插入一个节点与匹配一个节点非常相似。我们将使用<code>CREATE</code>进行数据插入，而不是使用<code>MATCH</code>关键字进行匹配。<code>CREATE</code>可以用来插入节点和关系。</p>
<pre>CREATE()
</pre>
<p>上面的Cypher语句是向图中添加节点的最简单的方法。它创建一个没有标签和属性的匿名节点。</p>
<p>您可以创建一个带有标签的节点，使用<code>:</code>后跟标签的名称。</p>
<pre>CREATE(:Person)
</pre>
<p>您还可以为一个节点分配多个标签。</p>
<pre>CREATE(:Person :Actor)
</pre>
<p>如果我们执行上面的语句，Cypher返回变化的数量，在这个例子中增加了一个节点和两个标签。如果你也想返回创建的数据，你可以添加一个<code>RETURN</code>语句。</p>
<pre>CREATE(person:Person :Actor)
RETURN person
</pre>
<p>使用花括号({})将属性添加到节点中。</p>
<pre>CREATE(john:Person{name:"John Doe", born:1900} )
RETURN john

╒═══════════════════════════════╕
│"john"                         │
╞═══════════════════════════════╡
│{"name":"John Doe","born":1900}│
└───────────────────────────────┘
</pre>
<p>如果想要创建多个节点，可以用逗号分隔节点，或者使用多个<code>CREATE</code>语句。</p>
<pre>CREATE(john:Person{name:"John Doe", born:1900} )
CREATE(jane:Person{name:"Jane Doe", born:1800} )
RETURN jane, john

CREATE(john:Person{name:"John Doe", born:1900} ), (jane:Person{name:"Jane Doe", born:1800} )
RETURN jane, john

╒═══════════════════════════════╤═══════════════════════════════╕
│"jane"                         │"john"                         │
╞═══════════════════════════════╪═══════════════════════════════╡
│{"name":"Jane Doe","born":1800}│{"name":"John Doe","born":1900}│
└───────────────────────────────┴───────────────────────────────┘
</pre>
<p>您还可以创建关系，比如与演员信息的<code>ACTED_IN</code>关系，或者与导演的<code>DIRECTED</code>关系。</p>
<pre>CREATE (tom:Person { name:"Tom Hanks",   born:1956 })-[roles:ACTED_IN { roles: ["Forrest"]}]-&gt;(movie:Movie { title:"Forrest Gump",released:1994 }) 
CREATE (robert:Person { name:"Robert Zemeckis", born:1951 })-[:DIRECTED]-&gt;(movie) RETURN tom,roles,movie, robert
</pre>
<p>属性和关系也可以添加到现有节点中。要向节点添加新信息，首先匹配现有节点，然后通过关系将新创建的节点附加到它们。</p>
<p>要将《云图》添加为汤姆·汉克斯的新电影，请执行以下操作:</p>
<pre>MATCH (tom:Person { name:"Tom Hanks" })
CREATE (movie:Movie { title:"Cloud Atlas",released:2012 }) 
CREATE (tom)-[role:ACTED_IN { roles: ['Zachry']}]-&gt;(movie) 
RETURN tom,role,movie
</pre>
<p>上面的Cypher查询将为每个匹配的节点创建一个关系中的<code>:Movie</code>节点和<code>:ACTED_IN</code>。很多情况下，这就是你想要的。</p>
<p>如果这不是我们想要的，那么我们需要使用<code>MERGE</code>语句。<code>MERGE</code>的作用类似于<code>MATCH</code>或<code>CREATE</code>的组合，在创建数据之前首先检查数据是否存在。通过<code>MERGE</code>，你可以定义一个模式。</p>
<p>如果您不知道您的图形是否已经包含电影“云图”，但希望向其添加<code>:ACTED_IN</code>关系，您可以使用<code>MERGE</code>语句来确保如果“云图”已经存在，则不会重新创建它。</p>
<pre>MATCH (tom:Person { name:"Tom Hanks" })
MERGE (movie:Movie { title:"Cloud Atlas",released:2012 }) 
MERGE (tom)-[role:ACTED_IN { roles: ['Zachry']}]-&gt;(movie) 
RETURN tom,role,movie
</pre>
<h2 id="updatingdatawithcypher">用密码更新数据</h2>
<p>如果您在数据库中已经有了一个节点或关系，但是想要修改或更新属性，您可以首先匹配节点或关系，然后使用<code>SET</code>子句更新属性。</p>
<p>例如，我们可以更新Tom的节点来添加生日属性。</p>
<pre>MATCH (tom:Person { name:"Tom Hanks" })
SET tom.birthday = date("1956-07-01")
RETURN tom

╒════════════════════════════════════════════════════════╕
│"tom"                                                   │
╞════════════════════════════════════════════════════════╡
│{"birthday":"1956-07-01","name":"Tom Hanks","born":1956}│
└────────────────────────────────────────────────────────┘
</pre>
<h2 id="deletingdatawithcypher">用密码删除数据</h2>
<p>Cypher使用<code>DELETE</code>关键字删除节点和关系。因为Neo4j是ACID兼容的，所以如果节点仍然有关系，则不能删除附加了关系的节点。</p>
<h3><strong>删除关系</strong></h3>
<p>删除节点的第一步是删除它的关系。</p>
<p>首先，匹配开始和结束节点，然后使用<code>DELETE</code>关键字，如下面的语句所示。</p>
<p>继续删除汤姆·汉克斯和《云图》之间的<code>ACTED_IN</code>关系</p>
<pre>MATCH (tom:Person { name:"Tom Hanks" })-[role:ACTED_IN]-(:Movie{title: "Cloud Atlas"})
DELETE role
</pre>
<h3><strong>删除节点</strong></h3>
<p>删除一个节点就像匹配该节点然后使用<code>DELETE</code>关键字一样简单，就像我们对上面的关系所做的那样。</p>
<p>删除汤姆·汉克斯的节点:</p>
<pre>MATCH (tom:Person { name:"Tom Hanks" })
DELETE tom
</pre>
<h3><strong>删除节点和关系</strong></h3>
<p>您可以使用<code>DETACH DELETE</code>语法同时删除节点和关系。<code>DETACH DELETE</code>语法告诉Cypher删除节点拥有的任何关系，以及删除节点本身。</p>
<pre>MATCH (tom:Person { name:"Tom Hanks" })
DETACH DELETE tom
</pre>
<h2 id="conclusion">结论</h2>
<p>图形数据库——尤其是Neo4j——是一项了不起的技术，可以应用于许多场景。</p>
<p>最有价值的用例是那些具有高度关联的数据模型的用例，这使得您的查询变得冗长而复杂，难以阅读、编写和理解。示例包括欺诈检测、实时推荐引擎、网络和IT运营、身份和访问管理(IAM)等。</p><div class="code-block code-block-28">
<div class="blog-plug inline-plug js-libraries-plug"><h2>您是否添加了新的JS库来提高性能或构建新特性？如果他们反其道而行之呢？</h2><p>毫无疑问，前端变得越来越复杂。当您向应用程序添加新的JavaScript库和其他依赖项时，您将需要更多的可见性，以确保您的用户不会遇到未知的问题。</p>
<p>LogRocket 是一个前端应用程序监控解决方案，可以让您回放JavaScript错误，就像它们发生在您自己的浏览器中一样，这样您就可以更有效地对错误做出反应。</p><a class="signup" href="https://lp.logrocket.com/blg/javascript-signup" target="_blank" rel="noopener noreferrer"><img class="alignnone size-full wp-image-46 jetpack-lazy-image" src="../Images/e8a0ab42befa3b3b1ae08c1439527dc6.png" alt="LogRocket Dashboard Free Trial Banner" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2019/10/errors-screenshot.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/10/errors-screenshot.png"/><noscript><img data-lazy-fallback="1" class="alignnone size-full wp-image-46" src="../Images/e8a0ab42befa3b3b1ae08c1439527dc6.png" alt="LogRocket Dashboard Free Trial Banner" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/10/errors-screenshot.png"/></noscript></a>
<a href="https://lp.logrocket.com/blg/javascript-signup" target="_blank" rel="noopener noreferrer">https://logrocket.com/signup/</a><p><a href="https://lp.logrocket.com/blg/javascript-signup" target="_blank" rel="noopener noreferrer"> LogRocket </a>可以与任何应用程序完美配合，不管是什么框架，并且有插件可以记录来自Redux、Vuex和@ngrx/store的额外上下文。您可以汇总并报告问题发生时应用程序的状态，而不是猜测问题发生的原因。LogRocket还可以监控应用的性能，报告客户端CPU负载、客户端内存使用等指标。</p><p>自信地构建— <a class="signup" href="https://lp.logrocket.com/blg/javascript-signup" target="_blank" rel="noopener noreferrer">开始免费监控</a>。</p></div>


</div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
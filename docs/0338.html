<html>
<head>
<title>How to make HTTP requests with Axios - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>如何用Axios - LogRocket Blog发出HTTP请求</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/how-to-make-http-requests-like-a-pro-with-axios/#0001-01-01">https://blog.logrocket.com/how-to-make-http-requests-like-a-pro-with-axios/#0001-01-01</a></blockquote><div><article class="article-post">
<p><em> <strong>编者按</strong>:这篇Axios教程最后一次更新是在2021年1月26日。</em></p>
<p><a href="https://github.com/axios/axios"> Axios </a>是基于浏览器提供的<code>XMLHttpRequest</code>接口的客户端HTTP API。</p>
<p>在本教程中，我们将通过清晰的示例演示如何使用Axios发出HTTP请求，包括如何使用<code>axios.post()</code>发出Axios POST请求，如何使用<code>axios.all()</code>同时发送多个请求，等等。</p>
<p>我们将详细介绍以下内容:</p>

<p>如果你更喜欢视觉学习，看看下面的视频教程:</p>
<p><span class="embed-youtube"> <iframe loading="lazy" class="youtube-player" src="https://www.youtube.com/embed/rzGGK7BHCAA?version=3&amp;rel=1&amp;showsearch=0&amp;showinfo=1&amp;iv_load_policy=1&amp;fs=1&amp;hl=en-US&amp;autohide=2&amp;wmode=transparent" allowfullscreen="true" sandbox="allow-scripts allow-same-origin allow-popups allow-presentation">视频</iframe> </span></p>
<h2 id="why">为什么要用Axios？</h2>
<p>前端程序与服务器通信的最常见方式是通过HTTP协议。您可能熟悉<a href="https://blog.logrocket.com/axios-or-fetch-api/" target="_blank" rel="noopener noreferrer">获取API </a>和<code>XMLHttpRequest</code>接口，它允许您获取资源并发出HTTP请求。</p>
<p>如果您使用的是JavaScript库，那么它很可能附带了一个客户端HTTP API。例如，jQuery的<code>$.ajax()</code>函数特别受前端开发人员的欢迎。但是，随着开发人员放弃这种库，转而支持本地API，专用的HTTP客户机出现了，填补了这一空白。</p>
<p>和Fetch一样，Axios也是基于承诺的。但是，它提供了更强大、更灵活的特性集。</p>
<p>与原生获取API相比，使用Axios的优势包括:</p>
<ul>
<li>请求和响应拦截</li>
<li>简化的错误处理</li>
<li>XSRF防护</li>
<li>支持上传进度</li>
<li>响应超时</li>
<li>取消请求的能力</li>
<li>对旧浏览器的支持</li>
<li>自动JSON数据转换</li>
</ul>
<h2 id="installing">安装Axios</h2>
<p>您可以使用以下工具安装Axios:</p>

<h2 id="axiospost">如何提出Axios POST请求</h2>
<p>发出HTTP请求就像将config对象传递给Axios函数一样简单。您可以使用Axios发出POST请求，将数据“发布”到给定的端点并触发事件。</p>
<p>要在Axios中执行HTTP POST请求，调用<code>axios.post()</code>。</p>
<p>在Axios中发出POST请求需要两个参数:服务端点的URI和一个包含要发送给服务器的属性的对象。</p>
<p>对于一个简单的Axios POST请求，对象必须有一个<code>url</code>属性。如果没有提供方法，<code>GET</code>将被用作默认值。</p>
<p>让我们看一个简单的Axios POST示例:</p>
<pre>// send a POST request
axios({
  method: 'post',
  url: '/login',
  data: {
    firstName: 'Finn',
    lastName: 'Williams'
  }
});</pre>
<p>这对那些使用过<a href="https://blog.logrocket.com/the-history-and-legacy-of-jquery/" target="_blank" rel="noopener noreferrer"> jQuery的</a> <code>$.ajax</code>函数的人来说应该很熟悉。这段代码只是指示Axios向<code>/login</code>发送一个POST请求，将一个键/值对对象作为其数据。Axios会自动将数据转换成JSON，并作为请求体发送。</p>
<h2 id="shorthand">Axios HTTP请求的简化方法</h2>
<p>Axios还为执行不同类型的请求提供了一套简化方法。这些方法如下:</p>
<ul>
<li><code>axios.request(config)</code></li>
<li><code>axios.get(url[, config])</code></li>
<li><code>axios.delete(url[, config])</code></li>
<li><code>axios.head(url[, config])</code></li>
<li><code>axios.options(url[, config])</code></li>
<li><code>axios.post(url[, data[, config]])</code></li>
<li><code>axios.put(url[, data[, config]])</code></li>
<li><code>axios.patch(url[, data[, config]])</code></li>
</ul>
<p>例如，下面的代码显示了如何使用<code>axios.post()</code>方法编写前面的示例:</p>
<pre>axios.post('/login', {
  firstName: 'Finn',
  lastName: 'Williams'
});</pre>
<h2 id="axiospostreturn"><code>axios.post</code>回报什么？</h2>
<p>一旦发出HTTP POST请求，Axios将根据后端服务的响应返回一个完成或拒绝的承诺。</p>
<p>要处理结果，您可以使用<code>then()</code>方法，如下所示:</p>
<pre>axios.post('/login', {
  firstName: 'Finn',
  lastName: 'Williams'
})
.then((response) =&gt; {
  console.log(response);
}, (error) =&gt; {
  console.log(error);
});</pre>
<p>如果承诺兑现，会调用<code>then()</code>的第一个自变量；如果承诺被拒绝，将调用第二个参数。根据<a href="https://www.npmjs.com/package/axios#response-schema" target="_blank" rel="noopener noreferrer">文档</a>，履行值是包含以下信息的对象:</p>
<pre>{
  // `data` is the response that was provided by the server
  data: {},
 
  // `status` is the HTTP status code from the server response
  status: 200,
 
  // `statusText` is the HTTP status message from the server response
  statusText: 'OK',
 
  // `headers` the headers that the server responded with
  // All header names are lower cased
  headers: {},
 
  // `config` is the config that was provided to `axios` for the request
  config: {},
 
  // `request` is the request that generated this response
  // It is the last ClientRequest instance in node.js (in redirects)
  // and an XMLHttpRequest instance the browser
  request: {}
}</pre>
<p>例如，下面是从GitHub API请求数据时的响应:</p>
<pre>axios.get('https://api.github.com/users/mapbox')
  .then((response) =&gt; {
    console.log(response.data);
    console.log(response.status);
    console.log(response.statusText);
    console.log(response.headers);
    console.log(response.config);
  });

// logs:
// =&gt; {login: "mapbox", id: 600935, node_id: "MDEyOk9yZ2FuaXphdGlvbjYwMDkzNQ==", avatar_url: "https://avatars1.githubusercontent.com/u/600935?v=4", gravatar_id: "", …}
// =&gt; 200
// =&gt; OK
// =&gt; {x-ratelimit-limit: "60", x-github-media-type: "github.v3", x-ratelimit-remaining: "60", last-modified: "Wed, 01 Aug 2018 02:50:03 GMT", etag: "W/"3062389570cc468e0b474db27046e8c9"", …}
// =&gt; {adapter: ƒ, transformRequest: {…}, transformResponse: {…}, timeout: 0, xsrfCookieName: "XSRF-TOKEN", …}</pre>
<h2 id="axiosall">使用<code>axios.all</code>发送多个请求</h2>
<p>Axios更有趣的特性之一是它能够通过向<a href="https://blog.logrocket.com/using-axios-all-make-concurrent-requests/" target="_blank" rel="noopener"> <code>axios.all()</code>方法</a>传递一组参数来并行发出多个请求。此方法返回单个promise对象，该对象仅在作为数组传递的所有参数都已解析时解析。</p>
<p>下面是一个简单的例子，说明如何使用<code>axios.all</code>来发出同步HTTP请求:</p>
<pre>// execute simultaneous requests 
axios.all([
  axios.get('https://api.github.com/users/mapbox'),
  axios.get('https://api.github.com/users/phantomjs')
])
.then(responseArr =&gt; {
  //this will be executed only when all requests are complete
  console.log('Date created: ', responseArr[0].data.created_at);
  console.log('Date created: ', responseArr[1].data.created_at);
});

// logs:
// =&gt; Date created:  2011-02-04T19:02:13Z
// =&gt; Date created:  2017-04-03T17:25:46Z</pre>
<p>这段代码向GitHub API发出两个请求，然后记录对控制台的每个响应的<code>created_at</code>属性值。请记住，如果任何一个论点被拒绝，那么承诺将立即拒绝，原因是第一个承诺拒绝。</p>
<p>为了方便起见，Axios还提供了一个名为<code>axios.spread()</code>的方法，将响应数组的属性分配给单独的变量。你可以这样使用这个方法:</p>
<pre>axios.all([
  axios.get('https://api.github.com/users/mapbox'),
  axios.get('https://api.github.com/users/phantomjs')
])
.then(axios.spread((user1, user2) =&gt; {
  console.log('Date created: ', user1.data.created_at);
  console.log('Date created: ', user2.data.created_at);
}));

// logs:
// =&gt; Date created:  2011-02-04T19:02:13Z
// =&gt; Date created:  2017-04-03T17:25:46Z</pre>
<p>这段代码的输出与前面的示例相同。唯一的区别是<code>axios.spread()</code>方法用于从响应数组中解包值。</p>

<p>用Axios发送自定义头非常简单。只需传递一个包含头的对象作为最后一个参数。例如:</p>
<pre>const options = {
  headers: {'X-Custom-Header': 'value'}
};

axios.post('/save', { a: 10 }, options);</pre>
<h2 id="postjson">用Axios发布JSON</h2>
<p>当作为第二个参数传递给<code>axios.post</code>函数时，Axios自动将JavaScript对象序列化为JSON。这消除了将POST主体序列化到JSON的需要。</p>
<p>Axios还将<code>Content-Type</code>头设置为<code>application/json</code>。这使得web框架能够自动解析数据。</p>
<p>如果您想将一个预先序列化的JSON字符串作为JSON发送给<code>axios.post()</code>，您需要确保设置了<code>Content-Type</code>头。</p>
<h2 id="transforming">转换请求和响应</h2>
<p>尽管Axios默认情况下会自动将请求和响应转换为JSON，但它也允许您覆盖默认行为并定义不同的转换机制。这在处理只接受特定数据格式(如XML或CSV)的API时特别有用。</p>
<p>要在将请求数据发送到服务器之前对其进行更改，请在config对象中设置<code>transformRequest</code>属性。注意，这个方法只对<code>PUT</code>、<code>POST</code>和<code>PATCH</code>请求方法有效。</p>
<p>下面是一个如何在Axios中使用<code>transformRequest</code>的例子:</p>
<pre>const options = {
  method: 'post',
  url: '/login',
  data: {
    firstName: 'Finn',
    lastName: 'Williams'
  },
  transformRequest: [(data, headers) =&gt; {
    // transform the data

    return data;
  }]
};

// send the request
axios(options);</pre>
<p>要在将数据传递给<code>then()</code>或<code>catch()</code>之前修改数据，您可以设置<code>transformResponse</code>属性:</p>
<pre>const options = {
  method: 'post',
  url: '/login',
  data: {
    firstName: 'Finn',
    lastName: 'Williams'
  },
  transformResponse: [(data) =&gt; {
    // transform the response

    return data;
  }]
};

// send the request
axios(options);</pre>
<h2 id="intercepting">拦截请求和响应</h2>
<p>HTTP拦截是Axios的一个流行功能。有了这个特性，您可以检查和更改从您的程序到服务器的HTTP请求，反之亦然，这对于各种隐式任务非常有用，比如日志记录和身份验证。</p>
<p>乍一看，拦截器看起来非常像转换，但是它们在一个关键方面有所不同:与只接收数据和头作为参数的转换不同，拦截器接收整个响应对象或请求配置。</p>
<p>您可以像这样在Axios中声明一个请求拦截器:</p>
<pre>// declare a request interceptor
axios.interceptors.request.use(config =&gt; {
  // perform a task before the request is sent
  console.log('Request was sent');

  return config;
}, error =&gt; {
  // handle the error
  return Promise.reject(error);
});

// sent a GET request
axios.get('https://api.github.com/users/mapbox')
  .then(response =&gt; {
    console.log(response.data.created_at);
  });</pre>
<p>每当发送请求时，这段代码都会向控制台记录一条消息，然后一直等待，直到从服务器获得响应，此时它会将GitHub上的帐户创建时间打印到控制台。使用拦截器的一个优点是，您不必再为每个HTTP请求分别实现任务。</p>
<p>Axios还提供了一个响应拦截器，允许您将来自服务器的响应转换回应用程序:</p>
<pre>// declare a response interceptor
axios.interceptors.response.use((response) =&gt; {
  // do something with the response data
  console.log('Response was received');

  return response;
}, error =&gt; {
  // handle the response error
  return Promise.reject(error);
});

// sent a GET request
axios.get('https://api.github.com/users/mapbox')
  .then(response =&gt; {
    console.log(response.data.created_at);
  });</pre>
<h2 id="xsrf">针对XSRF保护的客户端支持</h2>
<p>跨站点请求伪造(或简称为XSRF)是一种攻击web托管应用程序的方法，攻击者将自己伪装成合法的可信用户，以影响应用程序与用户浏览器之间的交互。执行这样的攻击有很多种方式，包括<code>XMLHttpRequest</code>。</p>
<p>幸运的是，Axios通过允许您在发出请求时嵌入额外的身份验证数据来抵御XSRF。这使服务器能够发现来自未授权位置的请求。以下是使用Axios实现这一点的方法:</p>
<pre>const options = {
  method: 'post',
  url: '/login',
  xsrfCookieName: 'XSRF-TOKEN',
  xsrfHeaderName: 'X-XSRF-TOKEN',
};

// send the request
axios(options);</pre>
<div class="inline-plug cro18">
<h2>200只<img decoding="async" src="../Images/61167b9d027ca73ed5aaf59a9ec31267.png" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2019/10/green-check.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" class=" jetpack-lazy-image" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/10/green-check.png"/> <noscript> <img data-lazy-fallback="1" decoding="async" src="../Images/61167b9d027ca73ed5aaf59a9ec31267.png" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/10/green-check.png"/> </noscript>显示器出现故障，生产中的Axios请求变慢</h2>
<p>虽然Axios有一些调试请求和响应的功能，但确保Axios继续为生产中的应用程序提供资源是事情变得更加困难的地方。如果您对确保对后端或第三方服务的请求成功感兴趣，请尝试LogRocket 。<a class="signup" href="https://logrocket.com/signup/" target="_blank" rel="noopener noreferrer"><img data-attachment-id="46" data-permalink="https://blog.logrocket.com/vuex-showdown-mutations-vs-actions/1d0cd-1s_rmyo6nbrasp-xtvbaxfg/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg-e1565635879164.png" data-orig-size="730,412" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="LogRocket dashboard free trial banner" data-image-description="&lt;p&gt;LogRocket is working on the perfect frontend bug report. Try it free today.&lt;/p&gt;&#10;" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg-e1565635879164.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg-e1565635879164.png" decoding="async" class="alignnone wp-image-46 size-full jetpack-lazy-image" src="../Images/f192ef9cfab47722774e3bf35f48d117.png" alt="LogRocket Dashboard Free Trial Banner." data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg-e1565635879164.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg-e1565635879164.png"/><noscript><img data-lazy-fallback="1" data-attachment-id="46" data-permalink="https://blog.logrocket.com/vuex-showdown-mutations-vs-actions/1d0cd-1s_rmyo6nbrasp-xtvbaxfg/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg-e1565635879164.png" data-orig-size="730,412" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="LogRocket dashboard free trial banner" data-image-description="&lt;p&gt;LogRocket is working on the perfect frontend bug report. Try it free today.&lt;/p&gt;&#10;" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg-e1565635879164.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg-e1565635879164.png" decoding="async" loading="lazy" class="alignnone wp-image-46 size-full" src="../Images/f192ef9cfab47722774e3bf35f48d117.png" alt="LogRocket Dashboard Free Trial Banner." data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg-e1565635879164.png"/></noscript></a><a href="https://logrocket.com/signup/" target="_blank" rel="noopener noreferrer">https://logrocket.com/signup/</a></p>
<p>LogRocket 就像是网络应用的DVR，记录下你网站上发生的每一件事。您可以汇总并报告有问题的Axios请求，以快速了解根本原因，而不是猜测问题发生的原因。</p>
<p>LogRocket检测您的应用程序以记录基线性能计时，如页面加载时间、到达第一个字节的时间、慢速网络请求以及日志Redux、NgRx。和Vuex动作/状态。<a class="signup" href="https://logrocket.com/signup/" target="_blank" rel="noopener noreferrer">开始免费监控</a>。</p>
</div>
<h2 id="monitoring">监控发布请求进度</h2>
<p>Axios的另一个有趣特性是监控请求进度的能力。这在下载或上传大文件时特别有用。Axios文档中的<a href="https://github.com/axios/axios/blob/master/examples/upload/index.html" target="_blank" rel="noopener noreferrer">提供的示例</a>让您很好地了解了如何做到这一点。但是为了简单和风格，我们将在本教程中使用<a href="https://github.com/rikmms/progress-bar-4-axios/" target="_blank" rel="noopener noreferrer"> Axios进度条</a>模块。</p>
<p>要使用这个模块，我们需要做的第一件事是包含相关的样式和脚本:</p>
<pre>&lt;link rel="stylesheet" type="text/css" href="https://cdn.rawgit.com/rikmms/progress-bar-4-axios/0a3acf92/dist/nprogress.css" /&gt;

&lt;script src="https://cdn.rawgit.com/rikmms/progress-bar-4-axios/0a3acf92/dist/index.js"&gt;&lt;/script&gt;</pre>
<p>然后我们可以像这样实现进度条:</p>
<pre>loadProgressBar()

const url = 'https://media.giphy.com/media/C6JQPEUsZUyVq/giphy.gif';

function downloadFile(url) {
  axios.get(url)
  .then(response =&gt; {
    console.log(response)
  })
  .catch(error =&gt; {
    console.log(error)
  })
}

downloadFile(url);</pre>
<p>要更改进度条的默认样式，我们可以覆盖以下样式规则:</p>
<pre>#nprogress .bar {
    background: red !important;
}

#nprogress .peg {
    box-shadow: 0 0 10px red, 0 0 5px red !important;
}

#nprogress .spinner-icon {
    border-top-color: red !important;
    border-left-color: red !important;
}</pre>
<h2 id="canceling">取消请求</h2>
<p>在某些情况下，你可能不再关心结果，想取消已经发出的请求。这可以通过使用取消令牌来完成。Axios 1.5版本增加了取消请求的功能，该功能基于<a href="https://github.com/tc39/proposal-cancelable-promises" target="_blank" rel="noopener noreferrer">可取消承诺提议</a>。这里有一个简单的例子:</p>
<pre>const source = axios.CancelToken.source();

axios.get('https://media.giphy.com/media/C6JQPEUsZUyVq/giphy.gif', {
  cancelToken: source.token
}).catch(thrown =&gt; {
  if (axios.isCancel(thrown)) {
    console.log(thrown.message);
  } else {
    // handle error
  }
});

// cancel the request (the message parameter is optional)
source.cancel('Request canceled.');</pre>
<p>您还可以通过向<code>CancelToken</code>构造函数传递一个executor函数来创建一个取消令牌，如下所示:</p>
<pre>const CancelToken = axios.CancelToken;
let cancel;

axios.get('https://media.giphy.com/media/C6JQPEUsZUyVq/giphy.gif', {
  // specify a cancel token
  cancelToken: new CancelToken(c =&gt; {
    // this function will receive a cancel function as a parameter
    cancel = c;
  })
}).catch(thrown =&gt; {
  if (axios.isCancel(thrown)) {
    console.log(thrown.message);
  } else {
    // handle error
  }
});

// cancel the request
cancel('Request canceled.');</pre>
<h2 id="axioslibraries">流行的Axios库</h2>
<p>Axios在开发人员中越来越受欢迎，这导致了丰富的第三方库选择来扩展其功能。从测试人员到日志记录人员，在使用Axios时，您可能需要的几乎所有附加功能都有一个库。以下是目前可用的一些流行库:</p>

<h2 id="browsersupport">浏览器支持</h2>
<p>说到浏览器支持，Axios是非常可靠的。即使是IE 11等较老的浏览器也能很好地与Axios配合使用。</p>
<div>
<table data-ace-table-col-widths="192;192;192;192;192">
<tbody>
<tr>
<td>
<p class="ace-line gutter-author-d-1gg9uz65z1iz85zgdz68zmqkz84zo2qovum6z77zktz89zrd44z68z1oz80zbz68zmz82zjz66zi5z71zxqz122zz69zoq7 ace-ltr" dir="auto"><span class=" author-d-1gg9uz65z1iz85zgdz68zmqkz84zo2qovum6z77zktz89zrd44z68z1oz80zbz68zmz82zjz66zi5z71zxqz122zz69zoq7">铬合金</span></p>
</td>
<td>
<p class="ace-line gutter-author-d-1gg9uz65z1iz85zgdz68zmqkz84zo2qovum6z77zktz89zrd44z68z1oz80zbz68zmz82zjz66zi5z71zxqz122zz69zoq7 ace-ltr" dir="auto"><span class=" author-d-1gg9uz65z1iz85zgdz68zmqkz84zo2qovum6z77zktz89zrd44z68z1oz80zbz68zmz82zjz66zi5z71zxqz122zz69zoq7">火狐</span></p>
</td>
<td>
<p class="ace-line gutter-author-d-1gg9uz65z1iz85zgdz68zmqkz84zo2qovum6z77zktz89zrd44z68z1oz80zbz68zmz82zjz66zi5z71zxqz122zz69zoq7 ace-ltr" dir="auto"><span class=" author-d-1gg9uz65z1iz85zgdz68zmqkz84zo2qovum6z77zktz89zrd44z68z1oz80zbz68zmz82zjz66zi5z71zxqz122zz69zoq7">狩猎之旅</span></p>
</td>
<td>
<p class="ace-line gutter-author-d-1gg9uz65z1iz85zgdz68zmqkz84zo2qovum6z77zktz89zrd44z68z1oz80zbz68zmz82zjz66zi5z71zxqz122zz69zoq7 ace-ltr" dir="auto"><span class=" author-d-1gg9uz65z1iz85zgdz68zmqkz84zo2qovum6z77zktz89zrd44z68z1oz80zbz68zmz82zjz66zi5z71zxqz122zz69zoq7">边缘</span></p>
</td>
<td>
<p class="ace-line gutter-author-d-1gg9uz65z1iz85zgdz68zmqkz84zo2qovum6z77zktz89zrd44z68z1oz80zbz68zmz82zjz66zi5z71zxqz122zz69zoq7 ace-ltr" dir="auto"><span class=" author-d-1gg9uz65z1iz85zgdz68zmqkz84zo2qovum6z77zktz89zrd44z68z1oz80zbz68zmz82zjz66zi5z71zxqz122zz69zoq7"> IE </span></p>
</td>
</tr>
<tr>
<td>  </td>
<td>  </td>
<td>  </td>
<td>  </td>
<td>
<p class="ace-line gutter-author-d-1gg9uz65z1iz85zgdz68zmqkz84zo2qovum6z77zktz89zrd44z68z1oz80zbz68zmz82zjz66zi5z71zxqz122zz69zoq7 ace-ltr" dir="auto"><span class=" author-d-1gg9uz65z1iz85zgdz68zmqkz84zo2qovum6z77zktz89zrd44z68z1oz80zbz68zmz82zjz66zi5z71zxqz122zz69zoq7"> 11 </span></p>
</td>
</tr>
</tbody>
</table>
</div>
<h2>包扎</h2>
<p>Axios在开发者中如此受欢迎有一个很好的原因:它包含了许多有用的功能。在这篇文章中，我们仔细研究了Axios的几个关键特性，并学习了如何在实践中使用它们。但是Axios还有很多方面我们没有讨论。因此，请务必查看Axios GitHub页面以了解更多信息。</p>
<p>有没有一些使用Axios的小技巧？请在评论中告诉我们！</p>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
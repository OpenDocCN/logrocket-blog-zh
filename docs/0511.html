<html>
<head>
<title>Improve React Native performance with immutability - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>用不变性提高React本机性能</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/improve-react-native-performance-with-immutability/#0001-01-01">https://blog.logrocket.com/improve-react-native-performance-with-immutability/#0001-01-01</a></blockquote><div><article class="article-post">
<h3>如何在React Native中衡量性能</h3>
<p><a href="https://github.com/jondot/react-native-slowlog" target="_blank" rel="noopener noreferrer"> React Native SlowLog </a>是一款适用于React Native中较大性能问题的工具。</p>
<p>它应该优先于许多其他React本机性能工具，因为如果您的应用程序中的一些操作很慢，它可以通知您。</p>
<p>测量React本机应用程序性能的最常见方法是使用内置的性能监视器。</p>
<p>您可以通过单击性能监视器从模拟器的调试菜单中打开它。它将显示在您的应用程序中当前打开的屏幕上。<img data-attachment-id="8896" data-permalink="https://blog.logrocket.com/improve-react-native-performance-with-immutability/improve-react-native-performance-with-immutability/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2019/10/Improve-React-Native-performance-with-immutability.png" data-orig-size="450,108" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Improve-React-Native-performance-with-immutability" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2019/10/Improve-React-Native-performance-with-immutability-300x72.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2019/10/Improve-React-Native-performance-with-immutability.png" decoding="async" class="aligncenter wp-image-8896 jetpack-lazy-image" src="../Images/84638cc2ac905a1a7ebfeca8e819def2.png" alt="Improve React Native performance with immutability." data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2019/10/Improve-React-Native-performance-with-immutability.png 450w, https://blog.logrocket.com/wp-content/uploads/2019/10/Improve-React-Native-performance-with-immutability-300x72.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2019/10/Improve-React-Native-performance-with-immutability.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/10/Improve-React-Native-performance-with-immutability.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="8896" data-permalink="https://blog.logrocket.com/improve-react-native-performance-with-immutability/improve-react-native-performance-with-immutability/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2019/10/Improve-React-Native-performance-with-immutability.png" data-orig-size="450,108" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Improve-React-Native-performance-with-immutability" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2019/10/Improve-React-Native-performance-with-immutability-300x72.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2019/10/Improve-React-Native-performance-with-immutability.png" decoding="async" loading="lazy" class="aligncenter wp-image-8896" src="../Images/84638cc2ac905a1a7ebfeca8e819def2.png" alt="Improve React Native performance with immutability." srcset="https://blog.logrocket.com/wp-content/uploads/2019/10/Improve-React-Native-performance-with-immutability.png 450w, https://blog.logrocket.com/wp-content/uploads/2019/10/Improve-React-Native-performance-with-immutability-300x72.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/10/Improve-React-Native-performance-with-immutability.png"/></noscript><br/>
The RAM column shows memory usage for the current process, while the second column displays JavaScript thread memory usage.
<p>“视图”列有两个数字:第一个数字显示当前可见视图的数量，第二个数字显示创建并保存在内存中的视图数量。</p>
<p>最后两列的目的是显示用户界面的当前帧速率和JavaScript线程的每秒帧数。</p>
<p>在生产模式下检查您的性能很重要。确保检查应用程序日志中的以下内容:</p>
<pre>__DEV__ === false, development-level warning are OFF, performance optimizations are ON</pre>
<p>当谈到Android性能测量时，React原生文档建议使用<a href="https://facebook.github.io/react-native/docs/performance#profiling-android-ui-performance-with-systrace" target="_blank" rel="noopener noreferrer"> systrace </a>来代替。</p>
<p>另一个你可以使用的工具，也是React本地兼容的，是<a href="https://github.com/welldone-software/why-did-you-render" target="_blank" rel="noopener noreferrer">Why-do-you-render</a>。如果有可避免的重新渲染，它会通知您。它还能够跟踪React挂钩问题。</p>
<h3>避免突变并追踪它们</h3>
<p>我们应该避免改变不可变的数据，例如冗余状态。它允许我们避免不必要的重新渲染，并支持高级记忆。</p>
<p>你可以在这篇伟大的博客文章中找到不可变代码<a href="https://daveceddia.com/react-redux-immutability-guide/#how-to-update-state-in-redux" target="_blank" rel="noopener noreferrer">的伟大配方。</a></p>
<p>很容易犯一个简单的错误，尤其是因为JavaScript不是一种完全函数式的编程语言，它不支持<a href="https://en.wikipedia.org/wiki/Immutable_object#JavaScript" target="_blank" rel="noopener noreferrer">不变性</a>。</p>
<p>在瞄准不可变代码时，有许多JavaScript方法应该避免。查看这个<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array?source=post_page---------------------------#Mutator_methods" target="_blank" rel="noopener noreferrer">列表中的mutator方法。</a></p>
<p>在Mozilla文档中，您可以找到可以安全使用的JavaScript <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array?source=post_page---------------------------#Accessor_methods" target="_blank" rel="noopener noreferrer">方法。</a></p>
<p>但是如何检查代码中错误变异的Redux store呢？我们可以使用一个名为<a href="https://github.com/leoasis/redux-immutable-state-invariant" target="_blank" rel="noopener noreferrer">redux-immutable-state-invariant</a>的中间件，它是专门为此目的而设计的。</p>
<p>这个库不应该在生产中使用，因为它会降低应用程序的性能，但它是跟踪可能问题的一个很好的工具。</p>
<p>该库非常容易使用，因为设置是一个简单的步骤。</p>
<p>它是如何工作的？如果你在你的应用程序中，一些数据在调度或调度之间发生了变化，你会收到一条错误信息。</p>
<h3>使用纯组件</h3>
<p>如果您需要对不可变的结构(比如状态)进行小的更新，那么使用纯组件是一个不错的选择。</p>
<p>纯组件是在<a href="https://reactjs.org/docs/react-api.html#reactpurecomponent" target="_blank" rel="noopener noreferrer"> React 16.6 </a>中添加的，它们通过避免不必要的重新渲染来提高性能。</p>
<p>它开箱即用，与React组件没有区别。唯一的变化是它有一个肤浅的属性和状态比较。</p>
<p>请记住，如果您需要使用深度比较来更新结构，重新渲染整个组件可能会更快。重要的是不要过度使用纯组件。</p>
<p>请记住，pure component浅层相等检查并不便宜，我们应该始终测量性能差异，而不是将它们放在任何地方。</p>
<p>关于React中纯组件的更深入的解释，可以看看这篇博文:<a href="https://logrocket.com/blog/pure-functional-components/" target="_blank" rel="noopener noreferrer">纯功能组件</a>。</p>
<h3>使用备忘录</h3>
<pre>const memoizedValue = useMemo(() =&gt; computeExpensiveValue(a, b), [a, b]);</pre>
<p>另一种通过避免重新渲染来提高性能的方法是使用<a href="https://reactjs.org/docs/hooks-reference.html#usememo" target="_blank" rel="noopener noreferrer"> useMemo </a>钩子，它返回一个记忆值。</p>
<p>传递给<code>useMemo</code>的函数只有在数组改变时传递的参数才会运行。</p>
<p>在提高性能的同时，我们应该始终避免早期优化。</p>
<p>当使用<code>useMemo</code>时，我们很容易落入陷阱。对于不使用它的组件来说，这是一种提高性能的好方法，但是我们应该知道React可以决定在重新渲染时重新计算值——例如，在释放内存时。</p>
<h3>如何使用深度嵌套的结构</h3>
<p>当处理深层结构时，最好使用更强大的东西，如<a href="https://github.com/planttheidea/moize" target="_blank" rel="noopener noreferrer"> Moize </a>库。</p>
<p>为了使用法更加愉快和类似于<code>useMemo</code>，我们可以按照文档准备一个<code>useMoize</code>钩子，如下所示:【https://github.com/planttheidea/moize#usemoize-hook】T2</p>
<pre>const deepSum = useMoize(obj =&gt; obj.a + obj.b, [object], {
  isDeepEqual: true,
});</pre>
<p>我们应该避免深度比较，但是在某些情况下，我们可以使用选项<code>isDeepEqual</code>来记忆我们的结构。</p>
<p>为了提高性能，我们需要确保避免突变。</p>
<p>当改变深度嵌套的结构时尤其困难。在这种情况下，你最好的选择之一就是使用<a href="https://github.com/immerjs/immer" target="_blank" rel="noopener noreferrer"> Immer </a>库，它非常容易掌握:</p>
<pre>import produce from "immer"
 
const baseState = [
  {
    todo: "Measure performance",
    done: true
  },
  {
    todo: "Improve code",
    done: false
  }
]
 
const nextState = produce(baseState, draftState =&gt; {
  draftState.push({todo: "Use Immer"})
  draftState[1].done = true
})</pre>
<h3>结论</h3>
<p>以不可变的方式编写代码可以省去很多麻烦，因此有必要了解哪些JavaScript方法被认为是不安全的。</p>
<p>如果您发现您的应用程序运行不佳，您可以从各种工具中进行选择。不过，你应该先检查一下<a href="https://github.com/jondot/react-native-slowlog" target="_blank" rel="noopener noreferrer"> React Native SlowLog </a>。</p>
<p>像性能监视器这样的内置工具也非常有用。</p>
<p>慢速组件可以通过使用新的React特性(如纯组件)来改进，但正如本文所述，应该小心使用。</p>
<p>还记得软件开发人员中的一句名言吗:“过早优化是万恶之源”。</p>
<p>对于深度嵌套结构的性能问题，你应该致力于用外部库实现不变性，比如<a href="https://github.com/planttheidea/moize" target="_blank" rel="noopener noreferrer"> Moize </a>或<a href="https://github.com/immerjs/immer" target="_blank" rel="noopener noreferrer"> Immer </a>。</p><div class="code-block code-block-18">
<div class="blog-plug inline-plug react-native-plug"><h2><a href="https://lp.logrocket.com/blg/react-native-signup"> LogRocket </a>:即时重现React原生应用中的问题。</h2><a class="signup" href="https://lp.logrocket.com/blg/react-native-signup" target="_blank" rel="noopener noreferrer"><img class="alignnone size-full wp-image-46 jetpack-lazy-image" src="../Images/110055665562c1e02069b3698e6cc671.png" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2021/10/react-native-plug_v2-2.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2021/10/react-native-plug_v2-2.png"/><noscript><img data-lazy-fallback="1" class="alignnone size-full wp-image-46" src="../Images/110055665562c1e02069b3698e6cc671.png" data-original-src="https://blog.logrocket.com/wp-content/uploads/2021/10/react-native-plug_v2-2.png"/></noscript></a><p><a href="https://lp.logrocket.com/blg/react-native-signup" target="_blank" rel="noopener noreferrer"> LogRocket </a>是一款React原生监控解决方案，可帮助您即时重现问题、确定bug的优先级并了解React原生应用的性能。</p><p>LogRocket还可以向你展示用户是如何与你的应用程序互动的，从而帮助你提高转化率和产品使用率。LogRocket的产品分析功能揭示了用户不完成特定流程或不采用新功能的原因。</p><p>开始主动监控您的React原生应用— <a class="signup" href="https://lp.logrocket.com/blg/react-native-signup" target="_blank" rel="noopener noreferrer">免费试用LogRocket】。</a></p></div>
</div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
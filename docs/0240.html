<html>
<head>
<title>New in Firefox 66: Animating CSS Grid - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>Firefox 66的新特性:动画CSS网格- LogRocket博客</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/new-in-firefox-66-animating-css-grid-b4ed90ac32f5/#0001-01-01">https://blog.logrocket.com/new-in-firefox-66-animating-css-grid-b4ed90ac32f5/#0001-01-01</a></blockquote><div><article class="article-post">
 <p class="graf graf--p">Firefox在不断改进，Mozilla团队设法用每个新版本给我们带来惊喜。</p>
<p class="graf graf--p">我们已经看到<a class="markup--anchor markup--p-anchor" href="https://blog.logrocket.com/firefox-devtools-for-css-authors-1511f41d1e3" target="_blank" rel="noreferrer nofollow noopener" data-href="https://blog.logrocket.com/firefox-devtools-for-css-authors-1511f41d1e3">最近在他们的开发工具上的显著改进</a>推动许多开发人员在开发中使用Firefox，CSS模块和API的浏览器实现也在不断增长。</p>
<p class="graf graf--p">最近登陆的一个功能是CSS Grid的动画。根据<a class="markup--anchor markup--p-anchor" href="https://drafts.csswg.org/css-grid/#track-sizing" target="_blank" rel="noreferrer nofollow noopener" data-href="https://drafts.csswg.org/css-grid/#track-sizing"> CSS Grid level 1规范</a>，一些网格属性应该是可动画的，但是没有浏览器实现过这方面。所有的供应商都选择妥协，并在没有Grid的情况下发布了Grid，所以我认为这是一个很难(或者不可能)实现的特性，我也不期望它会出现。但幸运的是，我错了。</p>
<figure class="graf graf--figure graf--layoutOutsetCenter"><a class="graf-imageAnchor" href="https://logrocket.com/signup/" target="_blank" rel="noopener noreferrer" data-href="https://logrocket.com/signup/" data-action="image-link" data-action-observe-only="true"><img decoding="async" class="graf-image jetpack-lazy-image" src="../Images/94b3e0f84b30cb0d321f60471481ab64.png" data-image-id="1*GPjaPKNNUYHU8EsA3Z0JGA.png" data-width="3212" data-height="750" data-lazy-src="https://storage.googleapis.com/blog-images-backup/1*GPjaPKNNUYHU8EsA3Z0JGA.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://storage.googleapis.com/blog-images-backup/1*GPjaPKNNUYHU8EsA3Z0JGA.png"/><noscript><img data-lazy-fallback="1" decoding="async" class="graf-image" src="../Images/94b3e0f84b30cb0d321f60471481ab64.png" data-image-id="1*GPjaPKNNUYHU8EsA3Z0JGA.png" data-width="3212" data-height="750" data-original-src="https://storage.googleapis.com/blog-images-backup/1*GPjaPKNNUYHU8EsA3Z0JGA.png"/></noscript></a></figure>
<h3 class="graf graf--h3">动画网格行和列</h3>
<p class="graf graf--p">从Firefox 66开始，控制网格轨迹尺寸的属性现在是可动画化的。这意味着<code>grid-template-rows</code>和<code>grid-template-columns </code>可以通过适当的插值在动画中操作。</p>
<p class="graf graf--p">实现非常简单:与任何其他CSS动画一样，只需为元素定义<code>animation</code>，并设置一个控制它的<code>@keyframes</code>规则。例如:</p>
<pre class="graf graf--pre">.element{
   grid-template-columns: 1fr 1fr 1fr;
   animation: resize 2000ms ease infinite alternate;
 }
 
 <a class="markup--anchor markup--pre-anchor" title="Twitter profile for @keyframes" href="https://twitter.com/keyframes" target="_blank" rel="noopener noreferrer" data-href="http://twitter.com/keyframes">@keyframes</a> resize {
   to {
     grid-template-columns: 1fr 2fr 1fr;
   }
 }</pre>
<p class="graf graf--p">将提供一个具有三个等宽列的网格(除非任何网格项目具有更大的固有大小… <a class="markup--anchor markup--p-anchor" href="https://github.com/w3c/csswg-drafts/issues/1777" target="_blank" rel="noopener noreferrer" data-href="https://github.com/w3c/csswg-drafts/issues/1777"> FR单元不是那么简单</a>)来来回回地动画显示一个具有更宽中间列的网格。</p>
<p class="graf graf--p">尽管有一些限制。引用规范:</p>
<blockquote class="graf graf--blockquote"><p><em class="markup--em markup--blockquote-em">动画:作为长度、百分比或计算的简单列表，假设唯一的区别是列表中长度、百分比或计算组件的值</em></p></blockquote>
<p class="graf graf--p">这意味着动画只能影响不同轨迹的大小(而不是从模板中添加/移除轨迹),如果混合了单位类型，插值将不起作用。例如，一个轨道不能从40px到1fr制作动画。</p>
<p class="graf graf--p">米歇尔·巴克的这个例子展示了一个网格动画的基本作品(为了更好的测量，有一些颜色的变化):</p>
<blockquote class="embedly-card" data-card-controls="1" data-card-align="center" data-card-theme="light">

<p>没有描述</p>
</blockquote>
<p>要记住的一个好技巧是使用空轨道来推送实际内容。我们可以将元素放置在特定的轨迹(列/行)中，并设置空轨迹动画，以便“推动”该元素:</p>
<p class="graf graf--p">上面的代码将把元素放在第二行，从上到下再推回来(因为第一行将从零高度增长到占据所有的空白空间)。</p>
<pre class="graf graf--pre"><code class="markup--code markup--pre-code">&lt;div class="grid"&gt;
  &lt;div class="element"&gt;&lt;/div&gt;
&lt;/div&gt;</code></pre>
<pre class="graf graf--pre">.grid{ 
  display: grid;
  animation: push 2s linear infinite alternate;
}
 
.element{
  grid-row: 2;
}
    
<a class="markup--anchor markup--pre-anchor" title="Twitter profile for @keyframes" href="https://twitter.com/keyframes" target="_blank" rel="noopener noreferrer" data-href="http://twitter.com/keyframes">@keyframes</a> push{
  from{
    grid-template-rows: 0fr auto;
  }
  to{
    grid-template-rows: 1fr auto;
  }
}</pre>
<p class="graf graf--p">我最喜欢的这种技术的例子之一是安德鲁·哈佛的这支棒极了的笔，它重新创造了一个不错的老的有弹性的DVD标志:</p>
<p class="graf graf--p">一个CSS网格动画实验。最好在Firefox夜间观看。…</p>
<blockquote class="embedly-card" data-card-controls="1" data-card-align="center" data-card-theme="light">

<p>A CSS grid animation experiment. Best viewed in Firefox Nightly. …</p>
</blockquote>
<p>我使用相同的技术创建了一个纯CSS无限Pong演示:</p>
<p class="graf graf--p">网格{宽度:100%；身高:100%；显示:网格；网格-模板-列:20px 0fr 20px 1fr 20px动画:pong-h 2s线性无限交替，pong-v 1.4s线性无限交替；will-change:网格-模板-列，网格-模板-行；/*快速脏hack修复边界*/background-image:linear-gradient(透明40px，深灰色40px，深灰色calc(100%–90px)，透明0)；填充顶部:50px}</p>
<blockquote class="embedly-card" data-card-controls="1" data-card-align="center" data-card-theme="light">

<p>间隙也可以制作动画</p>
</blockquote>
<p>一个已经存在了相当长一段时间但仍不为大多数人所知的特性是网格间隙动画。还可以通过定义一个简单的<code>@keyframes</code>规则来激活<code>grid-gap</code>、<code>grid-column-gap</code>和<code>grid-row-gap</code>属性。这部分规范甚至拥有近乎完美的浏览器支持。</p>
<h3 class="graf graf--h3">这为其他酷的效果打开了可能性。例如，我们可以分离实际的元素，或者让它们开始时相距很远，然后在中心发生冲突。</h3>
<p class="graf graf--p">下面的代码将使两个网格项目完全脱离屏幕，并折叠到中间</p>
<p class="graf graf--p">Manuel Matuzovic 的这支笔展示了如何在“真实世界”中使用它(它在加载时是动画的，如果你错过了，请刷新):</p>
<p class="graf graf--p">没有描述</p>
<pre class="graf graf--pre">.grid{
  display: grid;
  grid-template-columns: 1fr 1fr;
  grid-template-rows: 300px;
  animation: gap 2s;
}
   
<a class="markup--anchor markup--pre-anchor" title="Twitter profile for @keyframes" href="https://twitter.com/keyframes" target="_blank" rel="noopener noreferrer" data-href="http://twitter.com/keyframes">@keyframes</a> gap{
  from{
    grid-gap: 100%;
  }
  to{
    grid-gap: 0%;
  }
}</pre>
<p class="graf graf--p">关于性能的说明</p>
<blockquote class="embedly-card" data-card-controls="1" data-card-align="center" data-card-theme="light">

<p>即使有这些限制，动画CSS网格属性也可以实现令人惊叹的效果。不过，有一个警告，与任何高度/宽度变化一样，动画网格列、行或间隙会触发布局的变化，这可能会影响性能。</p>
</blockquote>
<p>布局计算在<a class="markup--anchor markup--p-anchor" href="https://developers.google.com/web/fundamentals/performance/rendering/" target="_blank" rel="noreferrer nofollow noopener" data-href="https://developers.google.com/web/fundamentals/performance/rendering/">渲染管道</a>的中间，这意味着浏览器将不得不在动画期间不断地重复<em class="markup--em markup--p-em">布局</em> <strong class="markup--strong markup--p-strong">和</strong>以下步骤(<em class="markup--em markup--p-em">绘制</em>和<em class="markup--em markup--p-em">合成</em>)。</p>
<h3 class="graf graf--h3">通常认为只对改变合成步骤的属性进行动画制作是一种好的做法(这几乎意味着只进行不透明和变换)，所以如果你要在制作中使用CSS网格动画，请有目的地负责任地使用。为了最小化对性能的影响，仅动画化具有很少后代的元素，并使用简单的剪辑/堆叠上下文树。</h3>
<p class="graf graf--p">此外，考虑使用<a class="markup--anchor markup--p-anchor" href="https://developer.mozilla.org/en-US/docs/Web/CSS/will-change" target="_blank" rel="noreferrer nofollow noopener" data-href="https://developer.mozilla.org/en-US/docs/Web/CSS/will-change">的will-change属性</a>来通知浏览器哪些部分将被动画化，这样他们就可以进行优化。请记住，<code>will-change</code>上的多个属性应该以逗号分隔的值链接起来。所以，如果你想让列和行模板都有动画效果，使用<code>will-change: grid-template-columns, grid-template-rows;</code>。</p>
<p class="graf graf--p">其他浏览器呢？</p>
<figure class="graf graf--figure"><img decoding="async" class="graf-image jetpack-lazy-image" src="../Images/f6c8a1ceda2369b1bb1d5aa6fcca0768.png" data-image-id="0*T7jlcg_hq86XM5yc.jpg" data-width="1093" data-height="167" data-lazy-src="https://storage.googleapis.com/blog-images-backup/0*T7jlcg_hq86XM5yc.jpg?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://storage.googleapis.com/blog-images-backup/0*T7jlcg_hq86XM5yc.jpg"/><noscript><img data-lazy-fallback="1" decoding="async" class="graf-image" src="../Images/f6c8a1ceda2369b1bb1d5aa6fcca0768.png" data-image-id="0*T7jlcg_hq86XM5yc.jpg" data-width="1093" data-height="167" data-original-src="https://storage.googleapis.com/blog-images-backup/0*T7jlcg_hq86XM5yc.jpg"/></noscript><figcaption class="imageCaption">The full pixel pipeline</figcaption></figure>
<p class="graf graf--p">Chromium浏览器<em class="markup--em markup--p-em">类似于</em>动画CSS网格，但是没有插值。这意味着我们可以定义一个受尊重的<code>@keyframes</code>动画，但是它会在步骤之间跳跃，而不是平滑过渡。想想如何将一个元素的<code>visibility</code>从<code>hidden</code>到<code>visible</code>制作成跳动的外观，同时过渡<code>opacity</code>使其逐渐出现。</p>
<p class="graf graf--p">嗯，Chromium让网格状的可视性变得生动，而Firefox让它变得不透明。</p>
<h3 class="graf graf--h3">但是嘿！一如既往，有了CSS，<em class="markup--em markup--p-em">我们就能黑掉它</em>。我们可以将网格轨迹(行或列)定义为某种自动大小(<code>auto</code>、<code>min-content</code>、<code>max-content</code>)，然后制作网格元素的<code>width</code> / <code>height</code>动画。</h3>
<p class="graf graf--p">下面是基于上述代码的一个基本示例:</p>
<p class="graf graf--p">添加外部样式表/笔此处添加的任何URL都将按顺序添加，并放在编辑器中的CSS之前。通过使用其URL和适当的URL扩展名，您可以使用另一个笔中的CSS。JavaScript预处理器巴贝尔包括JSX处理。</p>
<p class="graf graf--p">But hey! As always, with CSS, <em class="markup--em markup--p-em">we can hack it</em>. We might define the grid track (row or column) as some automatic size (<code>auto</code>,<code>min-content</code>,<code>max-content</code>) then animate the <code>width</code>/ <code>height</code> of the grid-elements.</p>
<pre class="graf graf--pre">.container{
  display: grid;
  grid-template-columns: auto 1fr;
}
 
.element{
  width: 0;
  animation: grow 3s ease-in-out infinite alternate;
}
   
<a class="markup--anchor markup--pre-anchor" title="Twitter profile for @keyframes" href="https://twitter.com/keyframes" target="_blank" rel="noopener noreferrer" data-href="http://twitter.com/keyframes">@keyframes</a> grow{
  to{
    width: 200px;
  }
}</pre>
<p class="graf graf--p">更多来自LogRocket的精彩文章:</p>
<blockquote class="embedly-card" data-card-controls="1" data-card-align="center" data-card-theme="light">

<p>不是非常实用或高性能，但它为一些给定的用例提供了一种插值网格动画</p>
</blockquote>
<p>类似的方法可以用于基于过渡而不是关键帧的动画:</p><div class="code-block code-block-54">
<hr/>
<h3>CSS网格应该有动画属性…但是浏览器还没有实现它。这里有一个最典型的使用方法…</h3>

<hr/></div>
<p class="graf graf--p">结论</p>
<p class="graf graf--p">CSS网格动画的实现让我们可以在界面上添加惊人的效果。对性能的影响和缺乏其他更流行的浏览器的支持可能意味着我们不会经常看到这一点，但Firefox团队为开发人员和设计人员提供了一个很好的实验工具，为出色的CSS效果和工具铺平了道路。</p>
<blockquote class="embedly-card" data-card-controls="1" data-card-align="center" data-card-theme="light">

<p>你的前端是否占用了用户的CPU？</p>
</blockquote>
<p>随着web前端变得越来越复杂，资源贪婪的特性对浏览器的要求越来越高。如果您对监控和跟踪生产环境中所有用户的客户端CPU使用、内存使用等感兴趣，</p>
<h3 class="graf graf--h3">.</h3>
<p class="graf graf--p">LogRocket 就像是网络和移动应用的DVR，记录你的网络应用或网站上发生的一切。您可以汇总和报告关键的前端性能指标，重放用户会话和应用程序状态，记录网络请求，并自动显示所有错误，而不是猜测问题发生的原因。</p><div class="code-block code-block-25">
<div class="blog-plug inline-plug css-plug"><h2>现代化您调试web和移动应用的方式— <a class="signup" href="https://lp.logrocket.com/blg/css-signup" target="_blank" rel="noopener noreferrer">开始免费监控</a>。</h2><p>As web frontends get increasingly complex, resource-greedy features demand more and more from the browser. If you’re interested in monitoring and tracking client-side CPU usage, memory usage, and more for all of your users in production, </p><a target="_blank" href="https://lp.logrocket.com/blg/css-signup">try LogRocket</a><p>.</p><a class="signup" href="https://lp.logrocket.com/blg/css-signup" target="_blank" rel="noopener noreferrer"><img class="alignnone size-full wp-image-46 jetpack-lazy-image" src="../Images/dacb06c713aec161ffeaffae5bd048cd.png" alt="LogRocket Dashboard Free Trial Banner" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2019/12/cpu-memory-usage.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/12/cpu-memory-usage.png"/><noscript><img data-lazy-fallback="1" class="alignnone size-full wp-image-46" src="../Images/dacb06c713aec161ffeaffae5bd048cd.png" alt="LogRocket Dashboard Free Trial Banner" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/12/cpu-memory-usage.png"/></noscript></a><a href="https://lp.logrocket.com/blg/css-signup" target="_blank" rel="noopener noreferrer">https://logrocket.com/signup/</a><p><a href="https://lp.logrocket.com/blg/css-signup" target="_blank" rel="noopener noreferrer">LogRocket</a> is like a DVR for web and mobile apps, recording everything that happens in your web app or site. Instead of guessing why problems happen, you can aggregate and report on key frontend performance metrics, replay user sessions along with application state, log network requests, and automatically surface all errors.</p><p>Modernize how you debug web and mobile apps — <a class="signup" href="https://lp.logrocket.com/blg/css-signup" target="_blank" rel="noopener noreferrer">Start monitoring for free</a>.</p></div>
</div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
<html>
<head>
<title>HTML 5 drag and drop API: A tutorial - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>HTML 5拖放API:教程- LogRocket博客</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/html-5-drag-and-drop-api-a-tutorial/#0001-01-01">https://blog.logrocket.com/html-5-drag-and-drop-api-a-tutorial/#0001-01-01</a></blockquote><div><article class="article-post">
<p>在本教程中，我们将学习<a href="https://developer.mozilla.org/en-US/docs/Web/API/HTML_Drag_and_Drop_API" target="_blank" rel="noopener"> HTML 5拖放API </a>。拖放API为HTML带来了可拖动的元素，使开发人员能够构建包含丰富UI元素的应用程序，这些元素可以从一个地方拖动到另一个地方。</p>
<p>为了了解HTML 5的拖放功能，我们将使用<a href="https://vuejs.org/" target="_blank" rel="noopener"> Vue.js </a>构建一个简单的看板。</p>
<p>看板是一种项目管理工具，允许用户从开始到结束可视化地管理项目。像Trello、Pivotal Tracker和吉拉这样的工具就是看板。</p>
<h2>先决条件</h2>
<p>对于本教程，您需要以下内容:</p>
<ol>
<li>HTML和JavaScript的基础知识</li>
<li>Vue.js 2.x的基础知识</li>
<li>您机器上安装的Vue CLI  4(或更高版本)</li>
<li>您机器上安装的<a href="https://nodejs.org/en/" target="_blank" rel="noopener"> Node.js </a> 8.0.0和<a href="https://www.npmjs.com/" target="_blank" rel="noopener"> npm </a></li>
</ol>
<h2>设置看板板</h2>
<p>看板将是一个Vue CLI应用程序。要创建新的应用程序，请运行以下命令:</p>
<pre>vue create kanban-board
</pre>
<p>当提示选择预设时，选择仅包含<a href="https://babeljs.io/" target="_blank" rel="noopener">巴别</a>和<a href="https://eslint.org/" target="_blank" rel="noopener">埃斯林特</a>的默认预设。</p>
<p>安装完成后，删除默认组件<code>HelloWorld</code>，它是Vue在安装过程中创建的。另外，将<code>App</code>组件修改为空，只包含裸组件模板:</p>
<pre>&lt;template&gt; &lt;div&gt;&lt;/div&gt; &lt;/template&gt;
&lt;script&gt;
export default {
  name: 'App',
  components: {},
};
&lt;/script&gt;
&lt;style&gt;&lt;/style&gt;
</pre>
<p>我们将使用<a href="https://getbootstrap.com/" target="_blank" rel="noopener"> Bootstrap </a>进行造型，但是我们只需要<a href="https://getbootstrap.com/docs/4.3/getting-started/introduction/" target="_blank" rel="noopener"> Bootstrap CSS CDN </a>。添加到<strong> public/index.html </strong>的<code>head</code>部分。</p>
<pre>&lt;head&gt;
    &lt;meta charset="utf-8"&gt;
    &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt;
    &lt;meta name="viewport" content="width=device-width,initial-scale=1.0"&gt;
    &lt;link rel="icon" href="&lt;%= BASE_URL %&gt;favicon.ico"&gt;
    &lt;link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/css/bootstrap.min.css"
    integrity="sha384-JcKb8q3iqJ61gNV9KGb8thSsNjpSL0n8PARn9HuZOnIxN0hoP+VmmDGMN5t9UJ0Z" crossorigin="anonymous"&gt;
    &lt;title&gt;&lt;%= htmlWebpackPlugin.options.title %&gt;&lt;/title&gt;
  &lt;/head&gt;
</pre>
<h2>在看板中构建UI组件</h2>
<p>下面是看板板建成后的样子:</p>
<p><img data-attachment-id="31014" data-permalink="https://blog.logrocket.com/html-5-drag-and-drop-api-a-tutorial/built-kanban-board/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/12/built-kanban-board.png" data-orig-size="730,285" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Built Kanban board" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/12/built-kanban-board-300x117.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/12/built-kanban-board.png" decoding="async" class="aligncenter size-full wp-image-31014 jetpack-lazy-image" src="../Images/44435c2f1e39c6eb55d9448be156776d.png" alt="A Built Kanban Board" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2020/12/built-kanban-board.png 730w, https://blog.logrocket.com/wp-content/uploads/2020/12/built-kanban-board-300x117.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2020/12/built-kanban-board.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/12/built-kanban-board.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="31014" data-permalink="https://blog.logrocket.com/html-5-drag-and-drop-api-a-tutorial/built-kanban-board/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/12/built-kanban-board.png" data-orig-size="730,285" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Built Kanban board" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/12/built-kanban-board-300x117.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/12/built-kanban-board.png" decoding="async" loading="lazy" class="aligncenter size-full wp-image-31014" src="../Images/44435c2f1e39c6eb55d9448be156776d.png" alt="A Built Kanban Board" srcset="https://blog.logrocket.com/wp-content/uploads/2020/12/built-kanban-board.png 730w, https://blog.logrocket.com/wp-content/uploads/2020/12/built-kanban-board-300x117.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/12/built-kanban-board.png"/></noscript>
<p>通常，看板有列和卡片。卡片是要执行的单个项目或任务，列显示特定卡片的状态。</p>
<p>我们将创建三个Vue组件:一个用于列，一个用于卡片，另一个用于创建新卡片。</p>
<h3>创建卡组件</h3>
<p>我们将创建的第一个组件是卡组件。首先，在<code>/component</code>目录中创建一个新文件<code>Card.vue</code>。</p>
<p>将以下内容添加到新创建的组件中:</p>
<pre>&lt;template&gt;
  &lt;div class="card"&gt;
    &lt;div class="card-body"&gt;A Sample Card&lt;/div&gt;
  &lt;/div&gt;
&lt;/template&gt;
&lt;script&gt;
export default {};
&lt;/script&gt;
&lt;style scoped&gt;
div.card {
  margin-bottom: 15px;
  box-shadow: 0 0 5px #cccccc;
  transition: all ease 300ms;
  background: #fdfdfd;
}
div.card:hover {
  box-shadow: 0 0 10px #aaaaaa;
  background: #ffffff;
}
&lt;/style&gt;
</pre>
<p>这将创建并样式化卡组件。我们还没有给这个组件添加任何可拖动的功能，因为这只是组件的框架。</p>
<h3>添加卡组件</h3>
<p>顾名思义，这个组件将负责创建新的卡片并将它们添加到列中。</p>
<p>在<code>/components</code>目录中创建一个<code>AddCard.vue</code>文件，并将以下内容添加到其中:</p>
<pre>&lt;template&gt;
  &lt;div class=""&gt;
    &lt;button
      class="btn btn-sm btn-info w-100"
      v-if="!inAddMode"
      @click="inAddMode = true"
    &gt;
      Add Card
    &lt;/button&gt;
    &lt;form action="#" class="card p-3" ref="form" v-else&gt;
      &lt;div class="form-group"&gt;
        &lt;input
          type="text"
          name="title"
          id="title"
          class="form-control"
          placeholder="Something interesting..."
          v-model="cardData"
        /&gt;
      &lt;/div&gt;
      &lt;div class="d-flex justify-content-center"&gt;
        &lt;button type="submit" class="btn w-50 btn-primary mr-3"&gt;Save&lt;/button&gt;
        &lt;button type="reset" class="btn w-50 btn-danger"&gt;
          Cancel
        &lt;/button&gt;
      &lt;/div&gt;
    &lt;/form&gt;
  &lt;/div&gt;
&lt;/template&gt;
&lt;script&gt;
export default {
  data() {
    return {
      inAddMode: false,
      cardData: '',
    };
  },
  methods: {},
};
&lt;/script&gt;
&lt;style&gt;&lt;/style&gt;
</pre>
<p>这方面的功能将在下一节中构建。</p>
<h3>创建柱构件</h3>
<p>这是我们将创建的最后一个组件。该组件将显示一个卡片列表，还将包含“添加卡片组件”,以便可以直接在列中创建新的卡片。</p>
<p>在组件目录中创建一个<code>Column.vue</code>文件，并添加以下代码:</p>
<pre>&lt;template&gt;
  &lt;div class="col-md-3 card column" ref="column"&gt;
    &lt;header class="card-header"&gt;
      &lt;h3 class="col"&gt;Column Name&lt;/h3&gt;
    &lt;/header&gt;
    &lt;div class="card-list"&gt;&lt;/div&gt;
  &lt;/div&gt;
&lt;/template&gt;
&lt;script&gt;
export default {};
&lt;/script&gt;
&lt;style scoped&gt;
div.column {
  padding: 0;
  padding-bottom: 15px;
  margin: 0 15px;
  box-shadow: 0 0 10px #cccccc;
}
div.card-list {
  padding: 0 15px;
}
header {
  margin-bottom: 10px;
}
header h3 {
  text-align: center;
}
&lt;/style&gt;
</pre>
<p>在添加功能和组合组件工作之前，这里有一个关于拖放功能在浏览器中如何工作的概述。</p>
<h2>什么是HTML 5拖放API？</h2>
<p>当用户将鼠标移动到可拖动的元素上时，拖动操作开始，然后将该元素移动到可拖放的元素上。</p>
<p>默认情况下，可拖动的HTML元素只有图像和链接。要使其他元素可拖动，您需要显式地创建功能，或者通过向元素添加draggable属性，或者通过在JavaScript中选择元素并将draggable属性设置为<code>true</code>。</p>
<blockquote><p>在元素上将draggable设置为<code>true</code>之后，您会注意到draggable属性已经被添加到元素中。</p></blockquote>
<pre>&lt;!-- Making an element draggable in HTML --&gt;
&lt;div draggable="true"&gt;This is a draggable div in HTML&lt;/div&gt;

&lt;script&gt;
// Making an element draggable in javascript
const div = document.querySelector('div');
div.draggable = true;
&lt;/script&gt;
</pre>
<p>拖动元素的目的是将数据从页面的一部分转移到另一部分。</p>
<p>对于图像，传输的数据是图像URL或图像的base 64表示。对于链接，传输的数据是URL。可以将链接移动到浏览器的URL栏，以便浏览器导航到该URL。</p>
<p>同样，如果没有传输数据的能力，拖动元素将毫无用处。将通过拖动操作传输的数据存储在拖动数据存储中。可以通过<code><a href="https://developer.mozilla.org/en-US/docs/Web/API/DataTransfer" target="_blank" rel="noopener">DataTransfer</a></code> API访问它，它提供了一种在拖放操作中存储和访问数据的方法。</p>
<p><code><a href="https://developer.mozilla.org/en-US/docs/Web/API/DataTransfer" target="_blank" rel="noopener">DataTransfer</a></code>对象用于此目的，因为它提供了一个添加要通过拖放传输的项目的地方。</p>
<p>当拖动操作开始时(当调度<code>dragstart</code>事件时)，可以将数据添加到拖动数据存储中，并且只有在放下操作完成后(当调度<code>drop</code>事件时)，才可以接收数据。</p>
<p>从元素被拖动到被放下，在元素被放下后，被拖动的元素会触发两个事件:<code>dragstart</code>和<code>dragend</code>。</p>
<p>可拖动元素不能放在任何地方。正如我们需要显式地使一个元素可拖动一样，为了允许一个元素被删除，它需要支持删除。</p>
<p>要使一个元素支持下拉，我们需要监听<code>dragover</code>事件并阻止默认的浏览器动作。</p>
<pre>&lt;!-- Make a section drop-enabled --&gt;
&lt;section class="section"&gt;&lt;/section&gt;
&lt;script&gt;
const section = document.querySelector('.section');
section.addEventListener('dragover', (e) =&gt; {
  e.preventDefault();
});
&lt;/script&gt;
</pre>
<p>当元素被拖动到已启用拖放功能的元素上时，将在已启用拖放功能的元素上触发以下事件:</p>
<p><code>Dragenter</code>:当一个元素被拖动到允许拖放的元素<br/> <code>Dragover</code>上时触发一次:只要一个元素停留在允许拖放的元素<br/> <code>Drop</code>上，就会连续触发:当被拖动的元素被放到允许拖放的元素上时触发。</p>
<blockquote><p>重要的是要注意，存储在<code>DataTransfer</code>对象中的数据只能在drop事件被触发时访问，而不能在<code>dragenter</code>或<code>dragover</code>上访问。关于这方面的更多信息可以在找到<a href="https://html.spec.whatwg.org/multipage/dnd.html#the-drag-data-store" target="_blank" rel="noopener">。</a></p></blockquote>
<h2>组成组件</h2>
<p>在向组件添加拖放功能之前，让我们讨论一下<code>app state</code>。</p>
<p>这里的应用程序状态将存储在<code>App</code>组件中，然后可以作为props传递给<code>Column</code>组件。另一方面，<code>Column</code>组件在渲染时会将所需的道具传递给<code>Card</code>组件。</p><div class="code-block code-block-54">
<hr/>
<h3>更多来自LogRocket的精彩文章:</h3>

<hr/></div>
<p>修改<code>App.vue</code>以反映状态和组件组成:</p>
<pre>// App.vue
&lt;template&gt;
  &lt;div class="container-fluid"&gt;
    &lt;h2 class="m-5"&gt;
      Vue Kanban Board
    &lt;/h2&gt;
    &lt;div class="row justify-content-center"&gt;
      &lt;Column
        v-for="(column, index) in columns"
        :column="column"
        :key="index"
      /&gt;
    &lt;/div&gt;
  &lt;/div&gt;
&lt;/template&gt;
&lt;script&gt;
import Column from './components/Column';
export default {
  name: 'App',
  components: {
    Column,
  },
  data() {
    return {
      columns: [
        {
          name: 'TO-DO',
          cards: [
            {
              value: 'Prepare breakfast',
            },
            {
              value: 'Go to the market',
            },
            {
              value: 'Do the laundry',
            },
          ],
        },
        {
          name: 'In Progress',
          cards: [],
        },
        {
          name: 'Done',
          cards: [],
        },
      ],
    };
  },
};
&lt;/script&gt;
&lt;style&gt;
h2 {
  text-align: center;
}
&lt;/style&gt;
</pre>
<p>在这里，我们导入了<code>Column</code>组件，并且，当使用存储在state中的数据作为<code>columns</code>对其进行循环时，我们将每一列的数据传递给<code>column</code>组件。在这种情况下，只有三列:“待办事项”、“进行中”和“完成”，每一列都有一组卡片。</p>
<p>接下来，更新<code>Column</code>组件以接收道具并正确显示:</p>
<pre>// Column.vue
&lt;template&gt;
  &lt;div class="col-md-3 card column" ref="column"&gt;
    &lt;header class="card-header"&gt;
      &lt;h3 class="col"&gt;{{ column.name }}&lt;/h3&gt;
      &lt;AddCard /&gt;
    &lt;/header&gt;
    &lt;div class="card-list"&gt;
      &lt;Card v-for="(card, index) in column.cards" :key="index" :card="card" /&gt;
    &lt;/div&gt;
  &lt;/div&gt;
&lt;/template&gt;
&lt;script&gt;
import Card from './Card';
import AddCard from './AddCard';
export default {
  name: 'Column',
  components: {
    Card,
    AddCard,
  },
  props: {
    column: {
      type: Object,
      required: true,
    },
  },
};
&lt;/script&gt;

...
</pre>
<p><code>Column</code>组件从<code>App</code>组件接收道具，并用道具呈现一个<code>Card</code>组件的列表。我们在这里还使用了<code>AddCard</code>组件，因为新卡应该能够被直接添加到一个列中。</p>
<p>最后，我们更新<code>Card</code>组件来显示从<code>Column</code>接收的数据。</p>
<pre>// Card.vue
&lt;template&gt;
  &lt;div class="card" ref="card"&gt;
    &lt;div class="card-body"&gt;{{ card.value }}&lt;/div&gt;
  &lt;/div&gt;
&lt;/template&gt;
&lt;script&gt;
export default {
  name: 'Card',
  props: {
    card: {
      type: Object,
      required: true,
    },
  },
};
&lt;/script&gt;
</pre>
<p><code>Card</code>组件只是从<code>Column</code>接收所有需要的数据并显示出来。我们还在这里添加了对card元素的引用。这在通过JavaScript访问card元素时非常有用。</p>
<p>完成上述操作后，您的应用程序应该是这样的:</p>
<p><img data-attachment-id="31015" data-permalink="https://blog.logrocket.com/html-5-drag-and-drop-api-a-tutorial/in-progress-kanban-board/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/12/in-progress-kanban-board.png" data-orig-size="730,278" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="In-progress Kanban board" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/12/in-progress-kanban-board-300x114.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/12/in-progress-kanban-board.png" decoding="async" class="aligncenter size-full wp-image-31015 jetpack-lazy-image" src="../Images/ed8b7c39fbad5b438041c9e7f06949bd.png" alt="A Look at the In-Progress Kanban Board" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2020/12/in-progress-kanban-board.png 730w, https://blog.logrocket.com/wp-content/uploads/2020/12/in-progress-kanban-board-300x114.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2020/12/in-progress-kanban-board.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/12/in-progress-kanban-board.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="31015" data-permalink="https://blog.logrocket.com/html-5-drag-and-drop-api-a-tutorial/in-progress-kanban-board/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/12/in-progress-kanban-board.png" data-orig-size="730,278" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="In-progress Kanban board" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/12/in-progress-kanban-board-300x114.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/12/in-progress-kanban-board.png" decoding="async" loading="lazy" class="aligncenter size-full wp-image-31015" src="../Images/ed8b7c39fbad5b438041c9e7f06949bd.png" alt="A Look at the In-Progress Kanban Board" srcset="https://blog.logrocket.com/wp-content/uploads/2020/12/in-progress-kanban-board.png 730w, https://blog.logrocket.com/wp-content/uploads/2020/12/in-progress-kanban-board-300x114.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/12/in-progress-kanban-board.png"/></noscript>
<h2>添加拖放功能</h2>
<p>添加拖放功能的第一步是识别可拖动组件和拖放目标。</p>
<p>用户应该能够将卡片从一列拖动到另一列，跟踪卡片中活动的进度。因此，这里的可拖动组件应该是<code>Card</code>组件，而这里的放置目标是<code>Column</code>组件。</p>
<h3>使卡片可拖动</h3>
<p>要使卡组件可拖动，我们需要做以下工作:</p>
<ol>
<li>将<code>draggable</code>属性设置为<code>true</code></li>
<li>使用<code>DataTransfer</code>对象设置要传输的数据</li>
</ol>
<p>将<code>draggable</code>设置为<code>true</code>应该尽可能早，根据Vue lifecylce hook，一个安全的地方是在安装的钩子中。在<code>Card</code>组件的安装钩上增加以下内容:</p>
<pre>// Card.vue
&lt;script&gt;
export default {
  name: 'Card',
  props: {...},

  mounted() {
    this.setDraggable();
  },

  methods: {
    setDraggable() {
      // Get Card element.
      const card = this.$refs.card;
      card.draggable = true;
      // Setup event listeners.
      card.addEventListener('dragstart', this.handleDragStart);
      card.addEventListener('dragend', this.handleDragEnd);
    },
  },
&lt;/script&gt;
</pre>
<p>上面，我们创建了一个方法<code>setDraggable</code>来处理卡片组件的可拖动性。</p>
<p>在<code>setDraggable</code>中，我们从上一节添加的引用中获取卡片，并将draggable属性设置为<code>true</code>。</p>
<p>我们还设置了事件监听器，这对于使用<code>DataTransfer</code>对象向拖动数据存储添加数据非常有用。</p>
<p>让我们创建事件侦听器来完成这一任务。</p>
<pre>// Card.vue
&lt;script&gt;
export const CardDataType = 'text/x-kanban-card';

export default {
...
  methods: {
    setDraggable() {...},
    handleDragStart(event) {
      const dataTransfer = event.dataTransfer;
      // Set the data to the value of the card which is gotten from props.
      dataTransfer.setData(CardDataType, this.card.value);
      dataTransfer.effectAllowed = 'move';
      // Add visual cues to show that the card is no longer in it's position.
      event.target.style.opacity = 0.2;
    },
    handleDragEnd(event) {
      // Return the opacity to normal when the card is dropped.
      event.target.style.opacity = 1;
    }
  }
}
&lt;/script&gt;
</pre>
<p>回想一下拖放API概述部分，数据只能在调度<code>dragstart</code>事件时添加到拖动数据存储中。因此，我们需要在<code>handleDragStart</code>方法中添加数据。</p>
<p>从被调度的拖动事件中接收到了<code>dataTransfer</code>对象，并且使用<code>setData</code>，我们将在拖动操作期间要移动的数据设置为从props接收到的卡片的值。</p>
<p>设置数据时需要的一条重要信息是格式。这可以是任何字符串。在我们的例子中，它被设置为<code>text/x-kanban-card</code>。我们存储这种数据格式并将其导出，因为当我们在卡片掉落后获取数据时，在<code>Column</code>组件中需要它。</p>
<p>最后，将卡片的不透明度降低到<code>0.2</code>，以便给用户一些反馈，即卡片实际上正被拖出其原始位置。拖动完成后，我们将不透明度恢复为<code>1</code>。</p>
<p>卡片现在是可拖动的。但是，它们不能放在任何地方，因为我们没有添加放置目标。让我们这样做吧。</p>
<h3>使柱子落下来</h3>
<p>从拖放API的概述来看，我们需要监听<code>dragover</code>事件来使列被拖放。当一张卡片被拖过一列时，将触发<code>dragover</code>事件。</p>
<p>当卡片进入列组件时会立即触发<code>dragenter</code>事件，当卡片被放入列后会触发drop事件。</p>
<p>因此，要将卡片放入列中，我们需要监听这些事件。</p>
<p>首先，更新<code>Column</code>组件以启用drop。</p>
<pre>// Column.vue
&lt;template&gt;...&lt;/template&gt;
&lt;script&gt;
import Card { CardDataType } from './Card';
import AddCard from './AddCard';
export default {
  name: 'Column',
  components: {...},
  props: {...},
  mounted() {
    this.enableDrop();
  },
  methods: {
    enableDrop() {
      const column = this.$refs.column;
      column.addEventListener('dragenter', this.handleDragEnter);
      column.addEventListener('dragover', this.handleDragOver);
      column.addEventListener('drop', this.handleDrop);
    },
    /**
     * @param {DragEvent} event
     */
    handleDragEnter(event) {
      if (event.dataTransfer.types.includes[CardDataType]) {
        // Only handle cards.
        event.preventDefault();
      }
    },
    handleDragOver(event) {
      // Create a move effect.
      event.dataTransfer.dropEffect = 'move';
      event.preventDefault();
    },
    /**
     * @param {DragEvent} event
     */
    handleDrop(event) {
      const data = event.dataTransfer.getData(CardDataType);
      // Emit a card moved event.
      this.$emit('cardMoved', data);
    },
  },
};
&lt;/script&gt;
</pre>
<p>在这里，我们设置了在安装了<code>Column</code>组件后启用drop所需的所有事件监听器。</p>
<p>在这三个事件中，第一个被触发的是<code>dragenter</code> <em>，</em>，当任何可拖动的元素被拖动到列中时，该事件立即被触发。对于我们的应用程序，我们只希望卡片被放入一个列中，因此，在<code>dragenter</code>事件中，我们只防止数据类型的默认，这包括在卡片组件中定义的卡片数据类型。</p>
<p>在<code>dragover</code>事件中，我们将drop效果设置为<code>move</code>。</p>
<blockquote><p>Move表示一个项目(一张卡片)正在从一个地方移动到另一个地方(从一列移动到另一列)。其他效果包括复制、链接和无。关于这些的更多信息可以从<a href="https://developer.mozilla.org/en-US/docs/Web/API/DataTransfer/dropEffect" target="_blank" rel="noopener"> MDN </a>中找到。</p></blockquote>
<p>在drop事件中，我们获取从<code>dataTransfer</code>对象传输的数据。如果我们没有检查<code>dragenter</code>事件的数据类型，这里的数据可能是任意的，这取决于被拖动的是什么。</p>
<p>但是在这里，我们确定正在传输的数据是在<code>Card</code>组件的<code>dragstart</code>事件中指定的卡的内容。</p>
<p>接下来，我们需要更新状态并将卡片移动到当前列。因为我们的应用程序状态驻留在<code>App</code>组件中，所以我们在drop监听器中发出一个<code>cardMoved</code>事件，传递被传输的数据并监听<code>App</code>组件中的<code>cardMoved</code>事件。</p>
<p>要了解如何在Vue中调度自定义事件，请查看<a href="https://vuejs.org/v2/guide/components-custom-events.html" target="_blank" rel="noopener">Vue官方文档</a>。</p>
<p>现在，更新<code>App.vue</code>来监听<code>cardMoved</code>事件:</p>
<pre>// App.vue

&lt;template&gt;
  &lt;div class="container-fluid"&gt;
    ...
    &lt;div class="row justify-content-center"&gt;
      &lt;Column
        v-for="(column, index) in columns"
        :column="column"
        :key="index"
        @cardMoved="moveCardToColumn($event, column)"
      /&gt;
    &lt;/div&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
import Column from './components/Column';
export default {
  name: 'App',
  components: {...},
  data() {
    return {...}
  },
  methods: {
    moveCardToColumn(data, newColumn) {
      const formerColumn = this.columns.find(column =&gt; {
        // Get all the card values in a column.
        const cardValues = column.cards.map((card) =&gt; card.value);
        return cardValues.includes(data);
      })
      // Remove card from former column.
      formerColumn.cards = formerColumn.cards.filter(
        (card) =&gt; card.value !== data
      );
      // Add card to the new column.
      newColumn.cards.push({ value: data });
    },
  },
}
&lt;/script&gt;
</pre>
<p>这里，我们通过<code>@cardMoved</code>监听<code>cardMoved</code>事件，并调用<code>moveCardToColumn</code>方法。<code>cardMoved</code>事件发出一个值(卡片数据)，可以通过<code>$event</code>访问，我们还传递卡片被丢弃的当前列(这是事件被调度的地方)。</p>
<p><code>moveCardToColumn</code>函数做三件事:找到卡片之前所在的列，从该列中移除卡片，并将卡片添加到新列中。</p>
<h2>完成看板</h2>
<p>祝贺你在教程中走到这一步！现在已经添加了拖放功能，剩下的唯一任务是创建“添加卡片”功能。</p>
<p>更新<code>AddCard.vue</code>如下所示:</p>
<pre>&lt;template&gt;
  &lt;div class=""&gt;
    &lt;button
      class="btn btn-sm btn-info w-100"
      v-if="!inAddMode"
      @click="inAddMode = true"
    &gt;
      Add Card
    &lt;/button&gt;
    &lt;form
      action="#"
      class="card p-3"
      @submit.prevent="handleSubmit"
      @reset="handleReset"
      ref="form"
      v-else
    &gt;
      ...
    &lt;/form&gt;
  &lt;/div&gt;
&lt;/template&gt;
&lt;script&gt;
export default {
  data() {
    return {...};
  },
  methods: {
    handleSubmit() {
      if (this.cardData.trim()) {
        this.cardData = '';
        this.inAddMode = false;
        this.$emit('newcard', this.cardData.trim());
      }
    },
    handleReset() {
      this.cardData = '';
      this.inAddMode = false;
    },
  },
};
&lt;/script&gt;
</pre>
<p>我们创建了在“添加卡片”表单被提交或重置时运行的函数。</p>
<p>复位后，我们清除<code>cardData</code>(输入域中输入的当前数据)，并将<code>inAddMode</code>设置为<code>false</code>。</p>
<p>当提交表单时，我们还清除了<code>cardData</code>，这样当添加新的条目时，以前的数据就不存在了，我们还将<code>inAddMode</code>设置为<code>false</code>并发出一个<code>newcard</code>事件。</p>
<p>记住状态存储在<code>App</code>组件中，不知何故，我们需要通知<code>App</code>组件卡片的添加；因此，我们需要发出一个到达<code>App</code>组件的事件。</p>
<p>在<code>Column</code>组件中使用了<code>AddCard</code>组件，所以我们需要监听<code>Column</code>组件中的<code>newcard</code>事件。</p>
<p>更新<code>Column</code>组件来监听<code>newcard</code>事件。</p>
<pre>&lt;template&gt;
  &lt;div class="col-md-3 card column" ref="column"&gt;
    &lt;header class="card-header"&gt;
      &lt;h3 class="col"&gt;{{ column.name }}&lt;/h3&gt;
      &lt;AddCard @newcard="$emit('newcard', $event)"&gt;&lt;/AddCard&gt;
    &lt;/header&gt;
    ...
&lt;/template&gt;
...
</pre>
<p>这里，我们重新发出了<code>newcard</code>事件，这样它就可以到达<code>App</code>组件，在那里实际的动作将要发生。</p>
<blockquote><p>自定义Vue事件不会冒泡，因此<code>App</code>组件不能监听在<code>AddCard</code>组件中发出的<code>newcard</code>事件，因为它不是直接的子组件。</p></blockquote>
<p>现在，更新<code>App</code>组件来处理<code>newcard</code>事件:</p>
<pre>// App.vue

&lt;template&gt;
  &lt;div class="container-fluid"&gt;
    ...
    &lt;div class="row justify-content-center"&gt;
      &lt;Column
        v-for="(column, index) in columns"
        :column="column"
        :key="index"
        @cardMoved="moveCardToColumn($event, column)"
        @newcard="handleNewCard($event, column)"
      /&gt;
    &lt;/div&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
import Column from './components/Column';
export default {
  name: 'App',
  components: {...},
  data() {
    return {...}
  },
  methods: {
    moveCardToColumn(data, newColumn) {...},
    handleNewCard(data, column) {
      // Add new card to column.
      column.cards.unshift({ value: data });
    },
  },
};
&lt;/script&gt;
</pre>
<p>这里，我们监听从<code>Column</code>组件发送的<code>newcard</code>事件，并获取数据，我们创建一个新卡，并将其添加到创建它的列中。</p>
<h2>结论</h2>
<p>在本文中，我们介绍了什么是HTML 5拖放API，如何使用它，以及如何在Vue.js应用程序中实现它。</p>
<p>然而，拖放功能和本教程都可以在任何其他前端框架和普通JavaScript中使用。</p>
<p>你可以在这里找到这篇文章的代码。</p><div class="code-block code-block-20">
<div class="blog-plug inline-plug vue-inline"><h2>像用户一样体验您的Vue应用</h2><p>调试Vue.js应用程序可能会很困难，尤其是当用户会话期间有几十个(如果不是几百个)突变时。如果您对监视和跟踪生产中所有用户的Vue突变感兴趣，</p><a href="https://lp.logrocket.com/blg/vue-signup" target="_blank">try LogRocket</a><p>. </p><a class="signup" href="https://lp.logrocket.com/blg/vue-signup" target="_blank" rel="noopener noreferrer"><img class="alignnone size-full wp-image-46 jetpack-lazy-image" src="../Images/0d269845910c723dd7df26adab9289cb.png" alt="LogRocket Dashboard Free Trial Banner" data-lazy-src="https://files.readme.io/00591d0-687474703a2f2f692e696d6775722e636f6d2f6a3049327856572e706e67.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://files.readme.io/00591d0-687474703a2f2f692e696d6775722e636f6d2f6a3049327856572e706e67.png"/><noscript><img data-lazy-fallback="1" class="alignnone size-full wp-image-46" src="../Images/0d269845910c723dd7df26adab9289cb.png" alt="LogRocket Dashboard Free Trial Banner" data-original-src="https://files.readme.io/00591d0-687474703a2f2f692e696d6775722e636f6d2f6a3049327856572e706e67.png"/></noscript></a><a href="https://lp.logrocket.com/blg/vue-signup" target="_blank" rel="noopener noreferrer">https://logrocket.com/signup/</a><p>LogRocket 就像是网络和移动应用程序的DVR，记录你的Vue应用程序中发生的一切，包括网络请求、JavaScript错误、性能问题等等。您可以汇总并报告问题发生时应用程序的状态，而不是猜测问题发生的原因。</p><p>LogRocket Vuex插件将Vuex突变记录到LogRocket控制台，为您提供导致错误的环境，以及出现问题时应用程序的状态。</p><p>现代化您调试Vue应用的方式- <a class="signup" href="https://lp.logrocket.com/blg/vue-signup" target="_blank" rel="noopener noreferrer">开始免费监控</a>。</p></div>


</div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
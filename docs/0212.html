<html>
<head>
<title>Rethinking frontend error reporting - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>反思前端错误报告</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/rethinking-front-end-error-reporting/#0001-01-01">https://blog.logrocket.com/rethinking-front-end-error-reporting/#0001-01-01</a></blockquote><div><article class="article-post">
 <p>理解网络应用中的问题很难。在神秘的JavaScript错误、用户报告的bug和QA中发现的问题之间，有一个持续的斗争来超越影响用户的问题。这些只是显而易见的问题——大多数bug实际上从未被报告过，因为有糟糕体验的用户只是离开或默默忍受。</p>
<p>传统的错误报告工具(如BugSnag、Sentry和Rollbar)只能解决部分问题。最初是为记录服务器端错误而设计的，后来随着前端应用程序变得越来越复杂，他们增加了浏览器SDK。虽然这些工具捕获了一些有用的信息，如堆栈跟踪和元数据，但许多团队发现它们的警报噪音太大(误报太多而无用)，并且它们没有捕获足够的上下文来阐明复杂的问题。</p>
<h2>前端是不同的</h2>
<p>调查前端和后端错误是非常不同的过程。服务器端代码运行在单一平台上。通常，系统中可能导致难以重现的错误的唯一状态来自于容易记录的事件，如数据库或缓存查询。当服务器代码中发生未处理的异常时，通常意味着有一个明显的问题需要解决。</p>
<p>在前端，事情没有这么简单。一般的web应用程序运行在超过15种不同的浏览器上，跨越数百种设备类型。状态可能非常复杂，来自内存、本地存储、本地数据库、服务人员和API。一个web应用程序必须对连接问题和跨浏览器差异具有鲁棒性，并且不像后端，异常通常是明确的，它可能很难衡量对前端的影响。</p>
<figure><img decoding="async" src="../Images/d681c386e1314673c3cea67a33ef1f4f.png" data-height="186" data-width="1260" data-lazy-src="https://storage.googleapis.com/blog-images-backup/1*iM58m5_7buKXkbThpykXKw.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" class=" jetpack-lazy-image" data-original-src="https://storage.googleapis.com/blog-images-backup/1*iM58m5_7buKXkbThpykXKw.png"/><noscript><img data-lazy-fallback="1" decoding="async" src="../Images/d681c386e1314673c3cea67a33ef1f4f.png" data-height="186" data-width="1260" data-original-src="https://storage.googleapis.com/blog-images-backup/1*iM58m5_7buKXkbThpykXKw.png"/></noscript></figure>
<p>考虑到前端开发人员看到的错误的频率和多样性，最重要的问题变成了，<em>这影响到用户了吗？</em>不幸的是，只看堆栈跟踪和异常消息，很难知道。这是一个导致瘫痪的bug吗？或者只是一个麻烦。</p>
<h2>回答正确的问题</h2>
<figure class="wp-caption aligncenter"><a href="https://www.xkcd.com/1700/" target="_blank" rel="noopener noreferrer"><img decoding="async" src="../Images/e76f9ecbe49a1d021b425b43ec6ad9a8.png" data-height="536" data-width="1315" data-lazy-src="https://storage.googleapis.com/blog-images-backup/1*x-zMtnqUPMHnH1_451tCtA.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" class=" jetpack-lazy-image" data-original-src="https://storage.googleapis.com/blog-images-backup/1*x-zMtnqUPMHnH1_451tCtA.png"/><noscript><img data-lazy-fallback="1" decoding="async" src="../Images/e76f9ecbe49a1d021b425b43ec6ad9a8.png" data-height="536" data-width="1315" data-original-src="https://storage.googleapis.com/blog-images-backup/1*x-zMtnqUPMHnH1_451tCtA.png"/></noscript></a><figcaption class="wp-caption-text">You never quite know how things will break. (credit: xkcd.com)</figcaption></figure>
<p>两年前，我们开始思考完美的前端bug报告应该是什么样的。显然，它将收集基本信息，如堆栈跟踪、元数据和频率直方图。但是要真正衡量对用户的影响，特别是对于难以重现的错误，它必须让你实际上<em>看到</em>发生了什么。</p>
<p>LogRocket是我们在这方面的大胆尝试——重现一个问题，就像它发生在你自己的浏览器中一样。</p>
<figure><img decoding="async" src="../Images/031cd9e1b60e5a549112b5abf09fec32.png" data-height="2874" data-width="4000" data-lazy-src="https://storage.googleapis.com/blog-images-backup/1*7jjY7mzUUvKKVoumPnNEdA.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" class=" jetpack-lazy-image" data-original-src="https://storage.googleapis.com/blog-images-backup/1*7jjY7mzUUvKKVoumPnNEdA.png"/><noscript><img data-lazy-fallback="1" decoding="async" src="../Images/031cd9e1b60e5a549112b5abf09fec32.png" data-height="2874" data-width="4000" data-original-src="https://storage.googleapis.com/blog-images-backup/1*7jjY7mzUUvKKVoumPnNEdA.png"/></noscript></figure>
<h2>都在视频里了</h2>
<p>LogRocket错误报告的中心是一个像素完美的视频，它准确地捕捉了用户在屏幕上看到的内容。为了在不影响性能的情况下做到这一点，LogRocket对DOM进行了检测，以记录问题发生时页面上的HTML和CSS。</p>
<p>此外，LogRocket记录控制台日志、JavaScript错误、堆栈跟踪、带有头+体的网络请求/响应、浏览器元数据和自定义日志。它还与React、Redux和Angular等库进行了深度集成，以记录操作和应用程序状态。</p>
<figure><img decoding="async" src="../Images/ae948ffd848a9dbab3cc1857d427a6ba.png" data-height="963" data-width="1704" data-lazy-src="https://storage.googleapis.com/blog-images-backup/1*SEE7Ol9Wlnx6NIuhU7CBlQ.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" class=" jetpack-lazy-image" data-original-src="https://storage.googleapis.com/blog-images-backup/1*SEE7Ol9Wlnx6NIuhU7CBlQ.png"/><noscript><img data-lazy-fallback="1" decoding="async" src="../Images/ae948ffd848a9dbab3cc1857d427a6ba.png" data-height="963" data-width="1704" data-original-src="https://storage.googleapis.com/blog-images-backup/1*SEE7Ol9Wlnx6NIuhU7CBlQ.png"/></noscript></figure>
<p>观看视频是快速了解某个异常是否真正影响了用户的最快方法。如果发生了，您可以通过检查网络请求、日志和应用程序状态，轻松地找出发生了什么。</p>
<h2>用户报告的错误</h2>

<p>当用户寻求帮助时——无论是通过帮助台、电子邮件，还是最糟糕的是在Twitter上——支持人员和开发人员能够迅速了解问题所在是至关重要的。不幸的是，这通常意味着要求用户提供截图、日志和重现步骤。</p>
<p>使用LogRocket，您只需搜索用户并重放他们遇到问题或请求支持的会话。我们已经与大多数帮助台建立了集成，如Intercom，让您可以直接从聊天中查看用户的历史记录。</p>
<p>有时候，不清楚用户是感到困惑还是真的遇到了错误。通过查看视频回放以及他们会话中的控制台和网络日志，您可以很容易地做出这种区分。</p>
<figure><img decoding="async" src="../Images/35b0a8e38c5f8b379aa7cd9d55f426fe.png" data-height="338" data-width="1600" data-lazy-src="https://storage.googleapis.com/blog-images-backup/1*dYWBFW6Bb1R__isM04y87Q.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" class=" jetpack-lazy-image" data-original-src="https://storage.googleapis.com/blog-images-backup/1*dYWBFW6Bb1R__isM04y87Q.png"/><noscript><img data-lazy-fallback="1" decoding="async" src="../Images/35b0a8e38c5f8b379aa7cd9d55f426fe.png" data-height="338" data-width="1600" data-original-src="https://storage.googleapis.com/blog-images-backup/1*dYWBFW6Bb1R__isM04y87Q.png"/></noscript></figure>
<p>大多数bug都不是显式的异常</p>
<h2>虽然监控和修复JavaScript异常对于应用程序的健康至关重要，但现实是用户遇到的大多数问题都不是显式的代码错误，也从未被报告过。UI故障，缓慢的性能，破碎的界面，甚至混乱的UX都会对用户的快乐和你的底线产生负面影响。</h2>
<p>如果前端团队希望能够快速发布新特性，他们必须确信这些问题正在被主动检测到并浮出水面。</p>
<p>此外，任何类型的问题都必须是可信的——如果有太多的误报，警报就会被忽略。</p>
<p>我们的使命:揭露所有负面影响用户的前端问题</p>
<h2>JavaScript异常只是我们在LogRocket中开始出现的第一类“问题”。我们在前端收集的遥测数据让我们可以检测性能问题、接口故障、混乱的UX等等。我们已经开始与Reddit、Twitch和AOL等精选客户合作，以解决这些问题，并将在未来几个月内向更多客户推出。</h2>
<figure><img decoding="async" src="../Images/3e9354e138f2b6b94dc78a41a38f9052.png" data-height="1452" data-width="2654" data-lazy-src="https://storage.googleapis.com/blog-images-backup/1*4XJU0jQ1Q-EyuQ5nvkKXCQ.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" class=" jetpack-lazy-image" data-original-src="https://storage.googleapis.com/blog-images-backup/1*4XJU0jQ1Q-EyuQ5nvkKXCQ.png"/><noscript><img data-lazy-fallback="1" decoding="async" src="../Images/3e9354e138f2b6b94dc78a41a38f9052.png" data-height="1452" data-width="2654" data-original-src="https://storage.googleapis.com/blog-images-backup/1*4XJU0jQ1Q-EyuQ5nvkKXCQ.png"/></noscript></figure>
<p>如果你是LogRocket的现有客户，或者想开始与我们合作，<a href="/cdn-cgi/l/email-protection#55262025253a272115393a32273a363e30217b363a38" target="_blank" rel="noopener noreferrer">联系</a>，你就可以加入测试版。</p>
<p>前端是未来</p>
<h2>向丰富的单页应用的转变无疑提高了用户体验质量和开发人员的工作效率。但是随着复杂性的增加，需要更多的可观察性。现有的工具还不足以让团队对他们发布的前端代码有信心。</h2>
<p>在LogRocket，我们已经朝着我们认为的解决方案迈出了一大步，但还有很多工作要做。如果你想帮助前端开发人员定义下一代工具，我们很乐意见到你。我们正在<a href="https://logrocket.com/company" target="_blank" rel="noopener noreferrer">招聘</a>🙂</p>
<p>At LogRocket, we’ve taken what we believe is a big step toward a solution — but there’s lots more work to do. If you want to help define the next generation of tooling for frontend developers, we’d love to meet you. We’re <a href="https://logrocket.com/company" target="_blank" rel="noopener noreferrer">hiring</a> 🙂</p>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
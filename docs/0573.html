<html>
<head>
<title>What’s new in Preact X? - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>Preact X有什么新功能？- LogRocket博客</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/whats-new-in-preact-x/#0001-01-01">https://blog.logrocket.com/whats-new-in-preact-x/#0001-01-01</a></blockquote><div><article class="article-post">
<p>Preact是一个JavaScript库，它将自己描述为一个<a href="https://blog.logrocket.com/introduction-to-preact-a-smaller-faster-react-alternative-ad5532eb6d79/" target="_blank" rel="noopener noreferrer">快速3kB的替代方案，以使用相同的现代API来反应</a>。与类似的框架相比，它拥有最快的虚拟DOM库之一。您可以开始在React/ReactDOM代码中编写Preact，而无需对工作流或代码库进行任何更改。</p>
<p>GitHub 上有超过24，000个️stars，并且有许多专门的社区成员不断提供支持，在JS中构建高效、小型、高性能、超快的前端应用程序从未如此简单。</p>
<p>自最初发布以来，Preact的维护人员已经发布了几个版本来解决问题和增加功能。10月，Preact X推出了几个旨在解决常见问题和改进现有功能的更新。</p>
<p>让我们回顾一下最近的一些变化，并讨论它们如何帮助我们使用PreactJS开发更好的应用程序。</p>
<p>注意，本教程假设您对PreactJS或reactJS有基本的了解。要了解更多关于Preact的信息，请阅读图书馆的官方指南。</p>
<h2 id="improvementsandnewcapabilitiesinpreactx">Preact X中的新功能和改进</h2>
<p>Preact的维护人员已经添加了重大改进，以支持许多最新的react特性。让我们回顾一些最有趣的新功能。</p>
<h3>碎片</h3>
<p>片段允许您分组子列表，而无需向DOM添加额外的节点，因为它们不会呈现在DOM中。您可以在通常使用包装器<code>div</code>的地方使用这个特性。它在处理列表、表格或CSS flexbox时最有用。</p>
<p>考虑以下标记:</p>
<pre>class Table extends Component {
  render() {
    return (
      &lt;table&gt;
        &lt;tr&gt;
          &lt;Columns /&gt;
        &lt;/tr&gt;
      &lt;/table&gt;
    );
  }
}
class Columns extends Component {
  render() {
    return (
      &lt;div&gt;
        &lt;td&gt;One&lt;/td&gt;
        &lt;td&gt;Two&lt;/td&gt;
      &lt;/div&gt;
    );
  }
} 
</pre>
<p>呈现的结果将是无效的HTML，因为来自<code>Columns</code>组件的包装器<code>div</code>被呈现在<code>Table</code>组件的<code>&lt;tr&gt;</code>内。</p>
<p>使用片段，您可以在DOM上呈现输出，而无需添加任何额外的元素。</p>
<pre>class Columns extends Component {
  render() {
    return (
      &lt;&gt;
        &lt;td&gt;One&lt;/td&gt;
        &lt;td&gt;Two&lt;/td&gt;
      &lt;/&gt;
    );
  }
} 
</pre>
<p>现在，输出将是有效的HTML，因为没有额外的<code>div</code>被添加到DOM中。片段可以用两种方式编写:</p>
<pre>BY :
import { Fragment, render } from 'preact';

function TodoItems() {
  return (
    &lt;Fragment&gt;
        &lt;li&gt;A&lt;/li&gt;
        &lt;li&gt;B&lt;/li&gt;
        &lt;li&gt;C&lt;/li&gt;
    &lt;/Fragment&gt;
  )
}

or 

function TodoItems() {
  return (
    &lt;&gt;
        &lt;li&gt;A&lt;/li&gt;
        &lt;li&gt;B&lt;/li&gt;
        &lt;li&gt;C&lt;/li&gt;
    &lt;/&gt;
  )
}
</pre>
<p>要了解更多信息，请阅读Preact X官方指南中的<a href="https://preactjs.com/guide/v10/components/#fragments" target="_blank" rel="noopener noreferrer">组件</a>文章。</p>
<h3>钩住</h3>
<p>钩子是基于类的组件API的替代物。钩子允许您组合状态和有状态逻辑，并在组件之间轻松地重用它们。Preact X提供了许多现成的钩子以及创建定制钩子的能力。您可以从<code>preact/hooks</code>或<code>preact/compat</code>导入挂钩。</p>
<pre>import {useState, useCallback} from 'preact/hooks';
or
import {useState, useCallback} from 'preact/compat';

function Counter() {
  const [value, setValue] = useState(0);
  const increment = useCallback(() =&gt; setValue(value + 1), [value]);

  return (
    &lt;div&gt;
      Counter: {value}
      &lt;button onClick={increment}&gt;Increment&lt;/button&gt;
    &lt;/div&gt;
  );
}
</pre>
<p>上面的代码是一个计数器组件，当单击它时，值会递增。它利用了Preact X API中提供的<code>useState</code>和<code>useCallback</code>钩子。如图所示，代码也与您在React中编写的代码相同。</p>
<p>注意，<a href="https://preactjs.com/guide/v10/hooks/" target="_blank" rel="noopener noreferrer">钩子</a>是可选的，可以和类组件一起使用。</p>
<h3>componentDidCatch</h3>
<p>Preact X包含对<code>componentDidCatch</code>生命周期方法的更新，该方法在组件呈现后调用。这允许您处理在呈现期间发生的任何错误，包括在生命周期钩子中发生的错误，但不包括任何异步抛出的错误，比如在一个<code>fetch()</code>调用之后。当捕获到错误时，您可以使用这个生命周期来对任何错误做出反应，并显示一条漂亮的错误消息或任何其他后备内容。</p>
<pre>class Catcher extends Component {
  state = { errored: false }

  componentDidCatch(error) {
    this.setState({ errored: true });
  }

  render(props, state) {
    if (state.errored) {
      return &lt;p&gt;Something went badly wrong&lt;/p&gt;;
    }
    return props.children;
  }
}
</pre>
<p>在上面的代码中，我们调用了<code>componentDidCatch()</code>，一旦组件被渲染，它就会被调用。如果捕获到错误，您可以更新组件，让用户知道发生了错误，并将条目记录到日志服务中。</p>
<p>这确保了更干净的代码库和更容易的错误跟踪。<a href="https://preactjs.com/guide/v10/components/#componentdidcatch" target="_blank" rel="noopener noreferrer">官方指南</a>有更多关于<code>componentDidCatch()</code>的信息。</p>
<h3>ccreatecontext</h3>
<p>上下文提供了一种通过组件树传递数据的方式，而不必在每一层手动向下传递属性。尽管上下文对于Preact来说并不陌生，但是已知遗留API <code>getChildContext()</code>在向虚拟DOM树的更深处交付更新时会出现问题。</p>
<p>通过<code>createContext(initialValue)</code>函数创建一个上下文对象。它返回一个用于设置上下文值的<code>Provider</code>组件和一个从上下文中检索值的<code>Consumer</code>组件。</p>
<pre>import {useContext} from 'preact/compat';

const Theme = createContext('light');

function DisplayTheme() {
  const theme = useContext(Theme);
  return &lt;p&gt;Active theme: {theme}&lt;/p&gt;;
}

// ...later
function App() {
  return (
    &lt;Theme.Provider value="light"&gt;
      &lt;OtherComponent&gt;
        &lt;DisplayTheme /&gt;
      &lt;/OtherComponent&gt;
    &lt;/Theme.Provider&gt;
  )
}
</pre>
<h2 id="changestopreactcore">对Preact核心的更改</h2>
<p>以前，<code>preact-compat</code>是作为一个单独的包包含在内的。现在它和Preact本身包含在同一个包中；使用React生态系统中的库不需要额外安装。</p>
<pre>// Preact 8.x
import React from "preact-compat";

// Preact X
import React from "preact/compat";
</pre>
<p>Preact X现在还直接支持<a href="https://developer.mozilla.org/en-US/docs/Web/CSS/--*" target="_blank" rel="noopener noreferrer"> CSS定制属性</a>来设计Preact组件的样式。Preact团队特别确保在测试过程中包含几个流行的包，以保证对它们的完全支持。</p>
<h2 id="conclusion">结论</h2>
<p>在本教程中，我们探索了Preact X中引入的一些功能。要查看所有更改的具体列表并了解新版本的更多信息，请务必查看GitHub 上的<a href="https://github.com/preactjs/preact/releases" target="_blank" rel="noopener noreferrer"> Preact发布页面。</a></p>
<p>你最喜欢的新特性或API是什么？欢迎在评论中分享你的想法。</p><div class="code-block code-block-17">
<div class="blog-plug inline-plug react-plug" vwo-el-id="26283398190">
<h2 vwo-el-id="41600691720">使用LogRocket消除传统反应错误报告的噪音</h2>
<a href="https://lp.logrocket.com/blg/react-signup-issue-free" target="_blank" vwo-el-id="19356441070">LogRocket
</a><p>是一款React analytics解决方案，可保护您免受数百个误报错误警报的影响，只针对少数真正重要的项目。LogRocket告诉您React应用程序中实际影响用户的最具影响力的bug和UX问题。</p><a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="19356441380">
<img class="first-react-image alignnone size-full wp-image-46 jetpack-lazy-image jetpack-lazy-image--handled" src="../Images/f300c244a1a1cf916df8b4cb02bec6c6.png" vwo-el-id="18272717540" data-lazy-loaded="1" data-original-src="https://files.readme.io/27c94e7-Image_2017-06-05_at_9.46.04_PM.png"/>
</a>
<a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="19356441690">
<img class="second-react-image alignnone size-full wp-image-46 jetpack-lazy-image jetpack-lazy-image--handled" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" vwo-el-id="30720362350" data-lazy-loaded="1" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/>
</a>
<a href="https://lp.logrocket.com/blg/react-signup-issue-free" target="_blank" rel="noopener noreferrer" vwo-el-id="35866400580">LogRocket
</a><p>自动聚合客户端错误、反应错误边界、还原状态、缓慢的组件加载时间、JS异常、前端性能指标和用户交互。然后，LogRocket使用机器学习来通知您影响大多数用户的最具影响力的问题，并提供您修复它所需的上下文。</p><p vwo-el-id="28675661060">关注重要的React bug—<a class="signup" href="https://lp.logrocket.com/blg/react-signup-issue-free" target="_blank" rel="noopener noreferrer" vwo-el-id="40093418840">今天就试试LogRocket】。</a></p>
</div></div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
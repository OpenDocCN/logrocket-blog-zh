<html>
<head>
<title>Interesting use cases for JavaScript bitwise operators - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>JavaScript位操作符的有趣用例</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/interesting-use-cases-for-javascript-bitwise-operators/#0001-01-01">https://blog.logrocket.com/interesting-use-cases-for-javascript-bitwise-operators/#0001-01-01</a></blockquote><div><article class="article-post">
<p><a href="https://blog.logrocket.com/javascript-date-libraries/" target="_blank" rel="noopener noreferrer"> JavaScript </a>提供了几种运算符，使得对简单值进行算术运算、赋值运算、逻辑运算、位运算等基本运算成为可能。</p>
<p>我们经常看到JavaScript代码混合了赋值操作符、算术操作符和逻辑操作符。然而，我们很少看到按位运算符被大量使用。</p>
<h2>JavaScript按位运算符</h2>
<ol>
<li><strong><code>~</code></strong>——<strong>按位非</strong></li>
<li><strong><code>&amp;</code></strong>——<strong>按位与</strong></li>
<li><strong><code>|</code></strong>——<strong>按位或</strong></li>
<li><strong><code>^</code></strong>——<strong>按位异或</strong></li>
<li><strong><code>&lt;&lt;</code></strong>——<strong>左移</strong></li>
<li><strong><code>&gt;&gt;</code></strong>——<strong>传号右移</strong></li>
<li><strong><code>&gt;&gt;&gt;</code></strong>——<strong>补零右移</strong></li>
</ol>
<p>在本教程中，我们将看看所有的JavaScript位操作符，并试图理解它们是如何计算的。我们还将看看在编写简单的JavaScript程序时，位运算符的一些有趣的应用。这需要我们稍微了解一下JavaScript位操作符是如何将它们的操作数表示为<em>有符号的32位整数</em>的。来吧，让我们开始吧！</p>
<h2>按位非(<code>~</code>)</h2>
<p><code>~</code>运算符是一个<em>一元运算符</em>；因此，它只需要一个操作数。<code>~</code>运算符对其操作数的每一位执行NOT运算。非运算的结果称为<em>补码</em>。整数的补码是通过反转整数的每一位形成的。</p>
<p>对于给定的整数，比如说<code>170</code>，可以使用<code>~</code>运算符计算补码，如下所示:</p>
<pre>// 170 =&gt; 00000000000000000000000010101010
// --------------------------------------
//  ~ 00000000000000000000000010101010
// --------------------------------------
//  = 11111111111111111111111101010101
// --------------------------------------
//  = -171 (decimal)

console.log(~170); // -171</pre>
<p>JavaScript位操作符将它们的操作数转换成32位有符号整数，格式为<em>二进制补码</em>。因此，当对整数使用<code>~</code>运算符时，结果值是整数的二进制补码。整数<code>A</code>的二进制补码由<code>-(A + 1)</code>给出。</p>
<pre>~170 =&gt; -(170 + 1) =&gt; -171</pre>
<p>关于JavaScript按位运算符使用的32位有符号整数，有几点需要注意:</p>
<ul>
<li>最高有效(最左边)位被称为<em>符号位</em>。正整数的符号位始终为<code>0</code>，负整数的符号位始终为<code>1</code>。</li>
<li>除了符号位之外，其余31位用于表示整数。所以能表示的最大32位整数是<code>(2^31 - 1)</code>，也就是<code>2147483647</code>，最小整数是<code>-(2^31)</code>，也就是<code>-2147483648</code>。</li>
<li>对于超出32位有符号整数范围的整数，最高有效位将被丢弃，直到该整数落入范围内。</li>
</ul>
<p>以下是一些重要数字的32位序列表示:</p>
<pre>           0 =&gt; 00000000000000000000000000000000
          -1 =&gt; 11111111111111111111111111111111
  2147483647 =&gt; 01111111111111111111111111111111
 -2147483648 =&gt; 10000000000000000000000000000000</pre>
<p>从上面的表述可以明显看出:</p>
<pre>          ~0 =&gt; -1
         ~-1 =&gt; 0
 ~2147483647 =&gt; -2147483648
~-2147483648 =&gt; 2147483647</pre>
<h3>找到索引</h3>
<p>JavaScript中的大多数内置对象，比如数组和字符串，都有一些有用的方法，可以用来检查数组中的某个项或字符串中的某个子串是否存在。以下是其中的一些方法:</p>
<ul>
<li><code>Array.indexOf()</code></li>
<li><code>Array.lastIndexOf()</code></li>
<li><code>Array.findIndex()</code></li>
<li><code>String.indexOf()</code></li>
<li><code>String.lastIndexOf()</code></li>
<li><code>String.search()</code></li>
</ul>
<p>这些方法都返回该项或子串的从零开始的<em>索引</em>，如果找到的话；否则，它们返回<code>-1</code>。例如:</p>
<pre>const numbers = [1, 3, 5, 7, 9];

console.log(numbers.indexOf(5)); // 2
console.log(numbers.indexOf(8)); // -1</pre>
<p>如果我们对找到的条目或子串的索引不感兴趣，我们可以选择使用布尔值来代替，这样对于没有找到的条目或子串，<code>-1</code>就变成了<code>false</code>，而其他所有的值都变成了<code>true</code>。这就是它的样子:</p>
<pre>function foundIndex (index) {
  return Boolean(~index);
}
</pre>
<p>在上面的代码片段中，<code>~</code>操作符在用于<code>-1</code>时，计算结果为<code>0</code>，这是一个falsy值。因此，使用<code>Boolean()</code>将一个假值转换为布尔值将返回<code>false</code>。对于每隔一个索引值，返回<code>true</code>。因此，前面的代码片段可以修改如下:</p>
<pre>const numbers = [1, 3, 5, 7, 9];

console.log(foundIndex(numbers.indexOf(5))); // true
console.log(foundIndex(numbers.indexOf(8))); // false</pre>
<h2>按位与(<code>&amp;</code>)</h2>
<p><code>&amp;</code>运算符对其操作数的每一对对应位执行AND运算。只有两位都为1时，<code>&amp;</code>运算符才返回<code>1</code>；否则返回<code>0</code>。因此，AND运算的结果相当于将每对对应的位相乘。</p>
<p>对于一对位，以下是AND运算的可能值。</p>
<pre>(0 &amp; 0) === 0     // 0 x 0 = 0
(0 &amp; 1) === 0     // 0 x 1 = 0
(1 &amp; 0) === 0     // 1 x 0 = 0
(1 &amp; 1) === 1     // 1 x 1 = 1</pre>
<h3>关闭bits</h3>
<p><code>&amp;</code>运算符通常用于位屏蔽应用，以确保对于给定的位序列，某些位被关闭。这是基于以下事实:对于任何位<code>A</code>:</p>
<ul>
<li><strong><code>(A &amp; 0 = 0)</code></strong>–该位总是被相应的<code>0</code>位关闭</li>
<li><strong><code>(A &amp; 1 = A)</code></strong>–该位与相应的<code>1</code>位配对时保持不变</li>
</ul>
<p>例如，假设我们有一个8位整数，我们希望确保前4位关闭(设置为<code>0</code>)。<code>&amp;</code>操作符可用于实现这一点，如下所示:</p>

<h3>检查设置位</h3>
<p><code>&amp;</code>操作符还有一些其他有用的位屏蔽应用。一个这样的应用是确定是否为给定的比特序列设置了一个或多个比特。例如，假设我们想检查第五位是否是为给定的十进制数设置的。下面是我们如何使用<code>&amp;</code>操作符来实现这一点:</p>

<h3>偶数还是奇数</h3>
<p>在检查十进制数的设置位时使用的<code>&amp;</code>操作符可以扩展到检查给定的十进制数是偶数还是奇数。为此，<code>1</code>被用作位屏蔽(以确定是第一位还是最右边的位被置位)。</p>
<p>对于整数，最低有效位(第一位或最右位)可用于确定数字是偶数还是奇数。如果最低有效位开启(设置为<code>1</code>)，则数字为奇数；否则，数字是偶数。</p>
<pre>function isOdd (int) {
  return (int &amp; 1) === 1;
}

function isEven (int) {
  return (int &amp; 1) === 0;
}

console.log(isOdd(34)); // false
console.log(isOdd(-63)); // true
console.log(isEven(-12)); // true
console.log(isEven(199)); // false</pre>
<h3>有用的身份</h3>
<p>在进入下一个操作符之前，这里有一些对<code>&amp;</code>操作有用的恒等式(对于任何有符号的32位整数<code>A</code>):</p>
<pre>(A &amp; 0) === 0
(A &amp; ~A) === 0
(A &amp; A) === A
(A &amp; -1) === A</pre>
<h2>按位或(<code>|</code>)</h2>
<p><code>|</code>运算符对其操作数的每一对对应位执行or运算。只有两位都为0时，<code>|</code>运算符才返回<code>0</code>；否则返回<code>1</code>。</p>
<p>对于一对位，以下是or运算的可能值:</p>
<pre>(0 | 0) === 0
(0 | 1) === 1
(1 | 0) === 1
(1 | 1) === 1</pre>
<h3>打开bits</h3>
<p>在位屏蔽应用中，<code>|</code>操作符可用于确保位序列中的某些位开启(设为<code>1</code>)。这是基于以下事实:对于任何给定的位<code>A</code>:</p>
<ul>
<li><strong> <code>(A | 0 = A)</code> </strong> —该位与相应的<code>0</code>位配对时保持不变。</li>
<li><strong> <code>(A | 1 = 1)</code> </strong> —该位总是由相应的<code>1</code>位开启。</li>
</ul>
<p>例如，假设我们有一个8位整数，我们希望确保所有偶数位(第二、第四、第六、第八)都打开(设置为<code>1</code>)。<code>|</code>操作符可用于实现这一点，如下所示:</p>
<ul>
<li>首先，创建一个位掩码，它的作用是打开一个8位整数的每个偶数位。该位掩码将为<code>0b10101010</code>。注意，位屏蔽的偶数位被设置为<code>1</code>，而每隔一位被设置为<code>0</code>。</li>
<li>接下来，使用8位整数和创建的位掩码执行<code>|</code>操作:</li>
</ul>
<pre>const mask = 0b10101010;

// 208 =&gt; 11010000

// (208 | mask)
// ------------
// 11010000
// | 10101010
// ------------
// = 11111010
// ------------
// = 250 (decimal)

console.log(208 | mask); // 250</pre>
<h3>有用的身份</h3>
<p>在进入下一个操作符之前，这里有一些对<code>|</code>操作有用的恒等式(对于任何有符号的32位整数<code>A</code>):</p>
<pre>(A | 0) === A
(A | ~A) === -1
(A | A) === A
(A | -1) === -1</pre>
<h2>按位异或(<code>^</code>)</h2>
<p><code>^</code>运算符对其操作数的每对对应位执行XOR ( <em>异或</em>)运算。如果两位相同(0或1)，则<code>^</code>运算符返回<code>0</code>；否则返回<code>1</code>。</p>
<p>对于一对比特，下面是XOR运算的可能值。</p>
<pre>(0 ^ 0) === 0
(0 ^ 1) === 1
(1 ^ 0) === 1
(1 ^ 1) === 0</pre>
<h3>切换位</h3>
<p>在位屏蔽应用中，<code>^</code>运算符通常用于切换或翻转位序列中的某些位。这是基于以下事实:对于任何给定的位<code>A</code>:</p>
<ul>
<li>当与相应的<code>0</code>位配对时，该位保持不变。<br/>T3<code>(A ^ 0 = A)</code>T4】</li>
<li>当与相应的<code>1</code>位配对时，该位总是被切换。<br/> <strong> <code>(A ^ 1 = 1)</code> </strong> —如果<code>A</code>是<code>0</code> <br/> <strong> <code>(A ^ 1 = 0)</code> </strong> —如果<code>A</code>是<code>1</code></li>
</ul>
<p>例如，假设我们有一个8位整数，我们希望确保除了最低有效位(第一位)和最高有效位(第八位)之外的每一位都被切换。<code>^</code>操作符可用于实现这一点，如下所示:</p>
<ul>
<li>首先，创建一个位掩码，其作用是切换8位整数中除最低有效位和最高有效位之外的每一位。该位掩码将为<code>0b01111110</code>。注意，要切换的位被设置为<code>1</code>，而每隔一位被设置为<code>0</code>。</li>
<li>接下来，使用8位整数和创建的位掩码执行<code>^</code>操作:</li>
</ul>
<pre>const mask = 0b01111110;

// 208 =&gt; 11010000

// (208 ^ mask)
// ------------
// 11010000
// ^ 01111110
// ------------
// = 10101110
// ------------
// = 174 (decimal)

console.log(208 ^ mask); // 174</pre>
<h3>有用的身份</h3>
<p>在进入下一个操作符之前，这里有一些对<code>^</code>操作有用的恒等式(对于任何有符号的32位整数<code>A</code>):</p>
<pre>(A ^ 0) === A
(A ^ ~A) === -1
(A ^ A) === 0
(A ^ -1) === ~A</pre>
<p>从上面列出的恒等式可以明显看出，对<code>A</code>和<code>-1</code>的异或运算等同于对<code>A</code>的非运算。因此，以前的<code>foundIndex()</code>函数也可以写成这样:</p>
<pre>function foundIndex (index) {
  return Boolean(index ^ -1);
}</pre>
<h2>左移(<code>&lt;&lt;</code>)</h2>
<p>左移(<code>&lt;&lt;</code>)运算符接受两个操作数。第一个操作数是一个整数，而第二个操作数是第一个操作数要左移的位数。零(<code>0</code>)位从右侧移入，而移至左侧的多余位被丢弃。</p>
<p>例如，考虑整数<code>170</code>。假设我们想向左移动三位。我们可以如下使用<code>&lt;&lt;</code>运算符:</p>
<pre>// 170 =&gt; 00000000000000000000000010101010

// 170 &lt;&lt; 3
// --------------------------------------------
//    (000)00000000000000000000010101010(***)
// --------------------------------------------
//  = (***)00000000000000000000010101010(000)
// --------------------------------------------
//  = 00000000000000000000010101010000
// --------------------------------------------
//  = 1360 (decimal)

console.log(170 &lt;&lt; 3); // 1360</pre>
<p>可以使用以下JavaScript表达式定义左移位运算符(<code>&lt;&lt;</code>):</p>
<pre>(A &lt;&lt; B) =&gt; A * (2 ** B) =&gt; A * Math.pow(2, B)</pre>
<p>因此，回头看前面的例子:</p>
<pre>(170 &lt;&lt; 3) =&gt; 170 * (2 ** 3) =&gt; 170 * 8 =&gt; 1360</pre>
<h3>颜色转换:RGB到十六进制</h3>
<p>左移(<code>&lt;&lt;</code>)运算符的一个非常有用的应用是将颜色从RGB表示转换成十六进制表示。</p>
<p>RGB颜色的每个分量的颜色值在<code>0 - 255</code>之间。简单来说，每个颜色值都可以用8位完美表示。</p>
<pre>  0 =&gt; 0b00000000 (binary) =&gt; 0x00 (hexadecimal)
255 =&gt; 0b11111111 (binary) =&gt; 0xff (hexadecimal)</pre>
<p>因此，颜色本身可以由24位(红、绿和蓝分量各8位)完美地表示。从右边开始的前8位代表蓝色成分，接下来的8位代表绿色成分，之后的8位代表红色成分。</p>
<pre>(binary) =&gt; 11111111 00100011 00010100

   (red) =&gt; 11111111 =&gt; ff =&gt; 255
 (green) =&gt; 00100011 =&gt; 23 =&gt; 35
  (blue) =&gt; 00010100 =&gt; 14 =&gt; 20

   (hex) =&gt; ff2314</pre>
<p>既然我们已经了解了如何将颜色表示为24位序列，那么让我们看看如何从颜色的各个分量的值中合成24位颜色。假设我们有一个用<code>rgb(255, 35, 20)</code>表示的颜色。下面是我们如何组合这些位:</p>
<pre>  (red) =&gt; 255 =&gt; 00000000 00000000 00000000 11111111
(green) =&gt;  35 =&gt; 00000000 00000000 00000000 00100011
 (blue) =&gt;  20 =&gt; 00000000 00000000 00000000 00010100

// Rearrange the component bits and pad with zeroes as necessary
// Use the left shift operator

  (red &lt;&lt; 16) =&gt; 00000000 11111111 00000000 00000000
 (green &lt;&lt; 8) =&gt; 00000000 00000000 00100011 00000000
       (blue) =&gt; 00000000 00000000 00000000 00010100

// Combine the component bits together using the OR (|) operator
// ( red &lt;&lt; 16 | green &lt;&lt; 8 | blue )

      00000000 11111111 00000000 00000000
    | 00000000 00000000 00100011 00000000
    | 00000000 00000000 00000000 00010100
// -----------------------------------------
      00000000 11111111 00100011 00010100
// -----------------------------------------</pre>
<p>现在过程已经很清楚了，下面是一个简单的函数，它将颜色的RGB值作为输入数组，并根据上面的过程返回颜色的相应十六进制表示:</p>
<pre>function rgbToHex ([red = 0, green = 0, blue = 0] = []) {
  return `#${(red &lt;&lt; 16 | green &lt;&lt; 8 | blue).toString(16)}`;
}</pre>
<h2>符号传播右移(<code>&gt;&gt;</code>)</h2>
<p>符号传播右移(<code>&gt;&gt;</code>)运算符有两个操作数。第一个操作数是一个整数，而第二个操作数是第一个操作数要右移的位数。</p>
<p>已经移至右侧的多余位被丢弃，而符号位(最左侧位)的副本从左侧移入。结果，整数的符号总是被保留，因此得名<em>符号传播右移</em>。</p><div class="code-block code-block-54">
<hr/>
<h3>更多来自LogRocket的精彩文章:</h3>

<hr/></div>
<p>例如，考虑整数<code>170</code>和<code>-170</code>。假设我们想向右移动三位。我们可以如下使用<code>&gt;&gt;</code>操作符:</p>
<pre>//  170 =&gt; 00000000000000000000000010101010
// -170 =&gt; 11111111111111111111111101010110

// 170 &gt;&gt; 3
// --------------------------------------------
//    (***)00000000000000000000000010101(010)
// --------------------------------------------
//  = (000)00000000000000000000000010101(***)
// --------------------------------------------
//  = 00000000000000000000000000010101
// --------------------------------------------
//  = 21 (decimal)

// -170 &gt;&gt; 3
// --------------------------------------------
//    (***)11111111111111111111111101010(110)
// --------------------------------------------
//  = (111)11111111111111111111111101010(***)
// --------------------------------------------
//  = 11111111111111111111111111101010
// --------------------------------------------
//  = -22 (decimal)

console.log(170 &gt;&gt; 3); // 21
console.log(-170 &gt;&gt; 3); // -22</pre>
<p>符号传播右移位按位运算符(<code>&gt;&gt;</code>)可由以下JavaScript表达式描述:</p>
<pre>(A &gt;&gt; B) =&gt; <strong>Math.floor(A / (2 ** B)) =&gt; Math.floor(A / Math.pow(2, B))</strong></pre>
<p>因此，回头看前面的例子:</p>
<pre>(170 &gt;&gt; 3) =&gt; Math.floor(170 / (2 ** 3)) =&gt; Math.floor(170 / 8) =&gt; 21
(-170 &gt;&gt; 3) =&gt; Math.floor(-170 / (2 ** 3)) =&gt; Math.floor(-170 / 8) =&gt; -22</pre>
<h3>颜色提取</h3>
<p>右移(<code>&gt;&gt;</code>)运算符的一个非常好的应用是从颜色中提取RGB颜色值。当用RGB表示颜色时，很容易区分红色、绿色和蓝色分量值。然而，对于用十六进制表示的颜色来说，需要花费更多的努力。</p>
<p>在上一节中，我们看到了从单个颜色成分(红色、绿色和蓝色)合成颜色成分的过程。如果我们把这个过程向后推，我们就能提取出颜色各个成分的值。让我们试一试。</p>
<p>假设我们有一种由十六进制符号<code>#ff2314</code>表示的颜色。以下是颜色的有符号32位表示:</p>
<pre>(color) =&gt; ff2314 (hexadecimal) =&gt; 11111111 00100011 00010100 (binary)

// 32-bit representation of color
00000000 11111111 00100011 00010100</pre>
<p>为了获得单独的分量，我们将根据需要将颜色比特右移8的倍数，直到我们获得目标分量比特，作为从右边开始的前8比特。由于颜色的32位中最高有效位是<code>0</code>，我们可以安全地使用符号传播右移(<code>&gt;&gt;</code>)操作符。</p>
<pre>color =&gt; 00000000 11111111 00100011 00010100

// Right shift the color bits by multiples of 8
// Until the target component bits are the first 8 bits from the right

  red =&gt; color &gt;&gt; 16
      =&gt; 00000000 11111111 00100011 00010100 &gt;&gt; 16
      =&gt; 00000000 00000000 00000000 11111111

green =&gt; color &gt;&gt; 8
      =&gt; 00000000 11111111 00100011 00010100 &gt;&gt; 8
      =&gt; 00000000 00000000 11111111 00100011

 blue =&gt; color &gt;&gt; 0 =&gt; color
      =&gt; 00000000 11111111 00100011 00010100</pre>
<p>既然我们已经将目标组件位作为从右开始的前8位，我们需要一种方法来屏蔽掉除前8位之外的所有其他位。这让我们回到AND ( <code>&amp;</code>)操作符。记住<code>&amp;</code>操作符可以用来确保某些位被关闭。</p>
<p>让我们从创建所需的位掩码开始。看起来会像这样:</p>
<pre>mask =&gt; 00000000 00000000 00000000 11111111
     =&gt; 0b11111111 (binary)
     =&gt; 0xff (hexadecimal)</pre>
<p>准备好位掩码后，我们可以使用位掩码对之前右移操作的每个结果执行AND ( <code>&amp;</code>)操作，以提取目标组成位。</p>
<pre>  red =&gt; color &gt;&gt; 16 &amp; 0xff
      =&gt;   00000000 00000000 00000000 11111111
      =&gt; &amp; 00000000 00000000 00000000 11111111
      =&gt; = 00000000 00000000 00000000 11111111
      =&gt;   255 (decimal)

green =&gt; color &gt;&gt; 8 &amp; 0xff
      =&gt;   00000000 00000000 11111111 00100011
      =&gt; &amp; 00000000 00000000 00000000 11111111
      =&gt; = 00000000 00000000 00000000 00100011
      =&gt;   35 (decimal)

 blue =&gt; color &amp; 0xff
      =&gt;   00000000 11111111 00100011 00010100
      =&gt; &amp; 00000000 00000000 00000000 11111111
      =&gt; = 00000000 00000000 00000000 00010100
      =&gt;   20 (decimal)</pre>
<p>基于上面的过程，下面是一个简单的函数，它接受一个十六进制颜色字符串(有六个十六进制数字)作为输入，并返回相应的RGB颜色分量值数组。</p>
<pre>function hexToRgb (hex) {
  hex = hex.replace(/^#?([0-9a-f]{6})$/i, '$1');
  hex = Number(`0x${hex}`);

  return [
    hex &gt;&gt; 16 &amp; 0xff, // red
    hex &gt;&gt; 8 &amp; 0xff,  // green
    hex &amp; 0xff        // blue
  ];
}</pre>
<h2>补零右移(<code>&gt;&gt;&gt;</code>)</h2>
<p>零填充右移位(<code>&gt;&gt;&gt;</code>)运算符的行为非常类似于符号传播右移位(<code>&gt;&gt;</code>)运算符。然而，关键的区别在于从左边移入的位。</p>
<p>顾名思义，<code>0</code>位总是从左边移入。结果，<code>&gt;&gt;&gt;</code>操作符总是返回一个无符号的32位整数，因为得到的整数的符号位总是<code>0</code>。对于正整数，<code>&gt;&gt;</code>和<code>&gt;&gt;&gt;</code>将总是返回相同的结果。</p>
<p>例如，考虑整数<code>170</code>和<code>-170</code>。假设我们想右移3位，我们可以如下使用<code>&gt;&gt;&gt;</code>运算符:</p>
<pre>//  170 =&gt; 00000000000000000000000010101010
// -170 =&gt; 11111111111111111111111101010110

// 170 &gt;&gt;&gt; 3
// --------------------------------------------
//    (***)00000000000000000000000010101(010)
// --------------------------------------------
//  = (000)00000000000000000000000010101(***)
// --------------------------------------------
//  = 00000000000000000000000000010101
// --------------------------------------------
//  = 21 (decimal)

// -170 &gt;&gt;&gt; 3
// --------------------------------------------
//    (***)11111111111111111111111101010(110)
// --------------------------------------------
//  = (000)11111111111111111111111101010(***)
// --------------------------------------------
//  = 00011111111111111111111111101010
// --------------------------------------------
//  = 536870890 (decimal)

console.log(170 &gt;&gt;&gt; 3); // 21
console.log(-170 &gt;&gt;&gt; 3); // 536870890</pre>
<h2>配置标志</h2>
<p>在我们结束本教程之前，让我们考虑一下位操作符和位屏蔽的另一个非常常见的应用:配置标志。</p>
<p>假设我们有一个函数，它接受几个布尔选项，这些选项可以用来控制函数的运行方式或返回值的类型。创建该函数的一种可能方式是将所有选项作为参数传递给该函数，可能带有一些默认值，如下所示:</p>
<pre>function doSomething (optA = true, optB = true, optC = false, optD = true, ...) {
  // something happens here...
}</pre>
<p>当然，这不太方便。这种方法在两种情况下开始出现问题:</p>
<ul>
<li>假设我们有10个以上的布尔选项。我们不能用那么多参数来定义函数。</li>
<li>假设我们只想为第五个和第九个选项指定不同的值，而让其他选项保留默认值。我们将需要调用函数，将默认值作为参数传递给所有其他选项，同时传递第五个和第九个选项的期望值。</li>
</ul>
<p>解决上述问题的一种方法是为配置选项使用一个对象，如下所示:</p>
<pre>const defaultOptions = {
  optA: true,
  optB: true,
  optC: false,
  optD: true,
  ...
};

function doSomething (options = defaultOptions) {
  // something happens here...
}</pre>
<p>这种方法非常优雅，您很可能见过它被使用，甚至在某个时候自己也使用过。然而，使用这种方法，<code>options</code>参数将始终是一个对象，对于配置选项来说，这被认为是多余的。</p>
<p>如果所有选项都采用布尔值，我们可以用一个整数代替一个对象来表示选项。在这种情况下，整数的某些位将被映射到指定的选项。如果某一位开启(设置为<code>1</code>)，指定选项的值为<code>true</code>；否则，就是<code>false</code>。</p>
<p>我们可以用一个简单的例子来演示这种方法。假设我们有一个函数，它对包含数字的数组列表的项进行规范化，并返回规范化的数组。返回的数组可以由三个选项控制，即:</p>
<ul>
<li><strong> Fraction: </strong>将数组中的每一项除以数组中的最大项</li>
<li><strong> Unique: </strong>从数组中删除重复项</li>
<li><strong>排序:</strong>将数组中的项目从最低到最高排序</li>
</ul>
<p>我们可以使用3位整数来表示这些选项，每一位映射到一个选项。以下代码片段显示了选项标志:</p>
<pre>const LIST_FRACTION = 0x1; // (001)
const LIST_UNIQUE = 0x2;   // (010)
const LIST_SORTED = 0x4;   // (100)</pre>
<p>要激活一个或多个选项，必要时可使用<code>|</code>操作符组合相应的标志。例如，我们可以创建一个激活所有选项的标志，如下所示:</p>
<pre>const LIST_ALL = LIST_FRACTION | LIST_UNIQUE | LIST_SORTED; // (111)</pre>
<p>同样，假设我们只希望默认激活<strong>分数</strong>和<strong>排序</strong>选项。我们可以再次使用<code>|</code>操作符，如下所示:</p>
<pre>const LIST_DEFAULT = LIST_FRACTION | LIST_SORTED; // (101)</pre>
<p>虽然只有三个选项看起来还不错，但当有这么多选项时，它往往会变得非常混乱，并且默认情况下需要激活其中的许多选项。在这种情况下，更好的方法是使用<code>^</code>操作符取消不需要的选项:</p>
<pre>const LIST_DEFAULT = LIST_ALL ^ LIST_UNIQUE; // (101)</pre>
<p>这里，我们有激活所有选项的<code>LIST_ALL</code>标志。然后，我们使用<code>^</code>操作符去激活唯一选项，根据需要激活其他选项。</p>
<p>现在我们已经准备好了选项标志，我们可以继续定义<code>normalizeList()</code>函数:</p>
<pre>function normalizeList (list, flag = LIST_DEFAULT) {
  if (flag &amp; LIST_FRACTION) {
    const max = Math.max(...list);
    list = list.map(value =&gt; Number((value / max).toFixed(2)));
  }
  if (flag &amp; LIST_UNIQUE) {
    list = [...new Set(list)];
  }
  if (flag &amp; LIST_SORTED) {
    list = list.sort((a, b) =&gt; a - b);
  }
  return list;
}</pre>
<p>为了检查一个选项是否被激活，我们使用<code>&amp;</code>操作符来检查该选项的相应位是否被打开(设置为<code>1</code>)。<code>&amp;</code>操作是通过传递给函数的<code>flag</code>参数和选项的相应标志来执行的，如下面的代码片段所示:</p>
<pre>// Checking if the unique option is activated
// (flag &amp; LIST_UNIQUE) === LIST_UNIQUE (activated)
// (flag &amp; LIST_UNIQUE) === 0 (deactivated)

flag &amp; LIST_UNIQUE</pre>
<div class="inline-plug cro19">
<h2>实现新的JS特性？了解JavaScript错误如何影响用户</h2>
<p>追踪生产JavaScript异常或错误的原因是耗时且令人沮丧的。如果您对监控JavaScript错误感兴趣，并想看看它们是如何影响用户的，<a href="https://logrocket.com/signup/">试试LogRocket </a>。<a class="signup" href="https://logrocket.com/signup/" target="_blank" rel="noopener noreferrer"><img data-attachment-id="46" data-permalink="https://blog.logrocket.com/vuex-showdown-mutations-vs-actions/1d0cd-1s_rmyo6nbrasp-xtvbaxfg/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg-e1565635879164.png" data-orig-size="730,412" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="LogRocket dashboard free trial banner" data-image-description="&lt;p&gt;LogRocket is working on the perfect frontend bug report. Try it free today.&lt;/p&gt;&#10;" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg-e1565635879164.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg-e1565635879164.png" decoding="async" class="alignnone size-full wp-image-46 jetpack-lazy-image" src="../Images/e8a0ab42befa3b3b1ae08c1439527dc6.png" alt="LogRocket Dashboard Free Trial Banner" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2019/10/errors-screenshot.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/10/errors-screenshot.png"/><noscript><img data-lazy-fallback="1" data-attachment-id="46" data-permalink="https://blog.logrocket.com/vuex-showdown-mutations-vs-actions/1d0cd-1s_rmyo6nbrasp-xtvbaxfg/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg-e1565635879164.png" data-orig-size="730,412" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="LogRocket dashboard free trial banner" data-image-description="&lt;p&gt;LogRocket is working on the perfect frontend bug report. Try it free today.&lt;/p&gt;&#10;" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg-e1565635879164.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg-e1565635879164.png" decoding="async" class="alignnone size-full wp-image-46" src="../Images/e8a0ab42befa3b3b1ae08c1439527dc6.png" alt="LogRocket Dashboard Free Trial Banner" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/10/errors-screenshot.png"/></noscript></a><a href="https://logrocket.com/signup/" target="_blank" rel="noopener noreferrer">https://logrocket.com/signup/</a></p>
<p>LogRocket 就像是网络应用的DVR，记录下你网站上发生的每一件事。LogRocket使您能够聚合和报告错误，以查看它们发生的频率以及它们影响了多少用户群。您可以轻松地重放发生错误的特定用户会话，以查看导致错误的用户操作。</p>
<p>log火箭工具您的应用程序记录带有标题+正文以及用户上下文信息的请求/响应，以获得问题的全貌。它还会在页面上记录HTML和CSS，即使是最复杂的单页应用程序也能重现像素级的完美视频。</p>
<p>增强您的JavaScript错误监控能力— <a class="signup" href="https://logrocket.com/signup/" target="_blank" rel="noopener noreferrer">开始免费监控</a>。</p>
</div>
<h2>结论</h2>
<p>嘿，我真的很高兴尽管读了很长时间，你还是读完了这篇文章，我强烈希望你在阅读的时候学到了一两件事。谢谢你的时间。</p>
<p>正如我们在本文中看到的，JavaScript按位运算符虽然很少使用，但有一些非常有趣的用例。我强烈希望从现在开始，您在阅读本文的过程中获得的见解能够在您的日常编码中得到体现。</p>
<p>快乐编码…</p><div class="code-block code-block-27">
<div class="blog-plug inline-plug vanilla-javascript-cta"><h2>通过理解上下文，更容易地调试JavaScript错误</h2>
<p>调试代码总是一项单调乏味的任务。但是你越了解自己的错误，就越容易改正。</p>
<p>LogRocket 让你以新的独特的方式理解这些错误。我们的前端监控解决方案跟踪用户与您的JavaScript前端的互动，让您能够准确找出导致错误的用户行为。</p>
<a href="https://lp.logrocket.com/blg/javascript-signup" class="signup" target="_blank" rel="noopener noreferrer"><img class="alignnone size-full wp-image-46 jetpack-lazy-image" src="../Images/cbfed9be3defcb505e662574769a7636.png" alt="LogRocket Dashboard Free Trial Banner" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2020/06/reproduce-javascript-errors.gif?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/06/reproduce-javascript-errors.gif"/><noscript><img data-lazy-fallback="1" class="alignnone size-full wp-image-46" src="../Images/cbfed9be3defcb505e662574769a7636.png" alt="LogRocket Dashboard Free Trial Banner" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/06/reproduce-javascript-errors.gif"/></noscript></a>
<p>LogRocket记录控制台日志、页面加载时间、堆栈跟踪、慢速网络请求/响应(带有标题+正文)、浏览器元数据和自定义日志。理解您的JavaScript代码的影响从来没有这么简单过！</p>
<a class="signup" href="https://lp.logrocket.com/blg/javascript-signup" target="_blank" rel="noopener noreferrer">Try it for free</a><p>.</p></div>


</div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>
 
</div>    
</body>
</html>
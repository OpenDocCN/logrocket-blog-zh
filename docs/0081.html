<html>
<head>
<title>Immutability in React: Should you mutate objects? - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>React中的不变性:应该改变对象吗？- LogRocket博客</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/immutability-react-should-you-mutate-objects/#0001-01-01">https://blog.logrocket.com/immutability-react-should-you-mutate-objects/#0001-01-01</a></blockquote><div><article class="article-post">
<p><em> <strong>编者按</strong>:这篇文章最后一次更新是在2022年10月14日，包括了关于React钩子的附加信息。</em></p>
<p>当您开始使用React时，您学到的第一件事就是不应该改变或修改列表:</p>
<pre>// This is bad, push modifies the original array
items.push(newItem);
// This is good, concat doesn’t modify the original array
const newItems = items.concat([newItem]);
</pre>
<p>尽管普遍认为，变异的对象实际上没有任何问题。在某些情况下，比如并发，这可能会成为一个问题，但是，改变对象是最简单的开发方法。就像编程中的大多数事情一样，这是一种权衡。</p>
<p>函数式编程和不变性等概念是热门话题。但是对于React来说，不变性不仅仅是时髦，它还有一些真正的好处。在本文中，我们将探索React中的不变性，包括它是什么以及如何工作。我们开始吧！</p>
<h2 id="tableofcontents">目录</h2>

<h2 id="what-immutability">什么是不变性？</h2>
<p>如果某样东西是不可变的，我们就不能改变它的价值或状态。虽然这看起来是一个简单的概念，但通常情况下，细节决定成败。</p>
<p>你可以在JavaScript本身找到不可变的类型；<code>String</code>值类型就是一个很好的例子。如果按如下方式定义字符串，则不能直接更改字符串中的某个字符:</p>
<pre>var str = 'abc';
</pre>
<p>在JavaScript中，字符串不是数组，因此可以如下定义一个数组:</p>
<pre>str[2] = 'd';
</pre>
<p>使用下面的方法定义一个字符串，给<code>str</code>分配一个不同的字符串:</p>
<pre>str = 'abd';
</pre>
<p>您甚至可以将<code>str</code>引用定义为一个常量:</p>
<pre>const str = 'abc'
</pre>
<p>因此，分配新字符串会产生错误。然而，这与不变性无关。如果你想修改字符串值，你必须使用像<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/replace"> replace() </a>、<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/toUpperCase"> <code>toUpperCase()</code> </a>或<code><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/trim">trim()</a></code>这样的操作方法。所有这些方法都返回新的字符串；他们不会修改原始版本。</p>
<h2 id="value-type">值类型</h2>
<p>注意值类型很重要。字符串值是不可变的，但字符串对象不是。</p>
<p>如果一个对象是不可变的，你不能改变它的状态或属性值。但是，这也意味着您不能向对象添加新属性。</p>
<p>例如，试试下面的小提琴:</p>
<p/>
<p>如果您运行它，您将看到一个带有消息<code>undefined</code>的警告窗口。新属性未添加。现在，试试这个:</p>
<p><br/>字符串是不可变的。最后一个例子用封装了不可变字符串值的<code>String()</code>构造函数创建了一个对象。您可以向这个包装器添加新的属性，因为它是一个对象，并且不是<a href="https://stackoverflow.com/questions/33124058/object-freeze-vs-const">冻结的</a>。这个例子引导我们理解一个重要的概念；引用和值相等的区别。</p>
<h2 id="reference-equality-vs-value-equality">引用相等与值相等</h2>
<p>使用引用相等，您可以用<code>===</code>和<code>!==</code>操作符或者<code>==</code>和<code>!=</code>操作符来比较对象引用。如果引用指向同一个对象，则认为它们是相等的:</p>
<pre>var str1 = ‘abc’;
var str2 = str1;
str1 === str2 // true
</pre>
<p>在上面的例子中，<code>str1</code>和<code>str2</code>引用是相等的，因为它们指向同一个对象，<code>'abc'</code>:</p>
<p><img data-attachment-id="139154" data-permalink="https://blog.logrocket.com/reference-equality-example-point-object/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/10/reference-equality-example-point-object.png" data-orig-size="377,179" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="reference-equality-example-point-object" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/10/reference-equality-example-point-object-300x142.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/10/reference-equality-example-point-object.png" decoding="async" class="aligncenter wp-image-139154 size-full jetpack-lazy-image" src="../Images/0a750acb16747095f895f7a57ed1a707.png" alt="Reference Equality Example Point Object" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2022/10/reference-equality-example-point-object.png 377w, https://blog.logrocket.com/wp-content/uploads/2022/10/reference-equality-example-point-object-300x142.png 300w" data-lazy-sizes="(max-width: 377px) 100vw, 377px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2022/10/reference-equality-example-point-object.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/10/reference-equality-example-point-object.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="139154" data-permalink="https://blog.logrocket.com/reference-equality-example-point-object/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/10/reference-equality-example-point-object.png" data-orig-size="377,179" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="reference-equality-example-point-object" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/10/reference-equality-example-point-object-300x142.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/10/reference-equality-example-point-object.png" decoding="async" loading="lazy" class="aligncenter wp-image-139154 size-full" src="../Images/0a750acb16747095f895f7a57ed1a707.png" alt="Reference Equality Example Point Object" srcset="https://blog.logrocket.com/wp-content/uploads/2022/10/reference-equality-example-point-object.png 377w, https://blog.logrocket.com/wp-content/uploads/2022/10/reference-equality-example-point-object-300x142.png 300w" sizes="(max-width: 377px) 100vw, 377px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/10/reference-equality-example-point-object.png"/></noscript>
<p>如果该值是不可变的，当两个引用引用相同的值时，它们也是相等的:</p>
<pre>var str1 = ‘abc’;
var str2 = ‘abc’;
str1 === str2 // true
var n1 = 1;
var n2 = 1;
n1 === n2 // also true
</pre>
<p><img data-attachment-id="139156" data-permalink="https://blog.logrocket.com/reference-equality-immutabiilty/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/10/reference-equality-immutabiilty.png" data-orig-size="419,412" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="reference-equality-immutabiilty" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/10/reference-equality-immutabiilty-300x295.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/10/reference-equality-immutabiilty.png" decoding="async" class="aligncenter wp-image-139156 size-full jetpack-lazy-image" src="../Images/3fbb42377640c93e28c14953cc721e73.png" alt="Reference Equality Immutabiilty" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2022/10/reference-equality-immutabiilty.png 419w, https://blog.logrocket.com/wp-content/uploads/2022/10/reference-equality-immutabiilty-300x295.png 300w" data-lazy-sizes="(max-width: 419px) 100vw, 419px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2022/10/reference-equality-immutabiilty.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/10/reference-equality-immutabiilty.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="139156" data-permalink="https://blog.logrocket.com/reference-equality-immutabiilty/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/10/reference-equality-immutabiilty.png" data-orig-size="419,412" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="reference-equality-immutabiilty" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/10/reference-equality-immutabiilty-300x295.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/10/reference-equality-immutabiilty.png" decoding="async" loading="lazy" class="aligncenter wp-image-139156 size-full" src="../Images/3fbb42377640c93e28c14953cc721e73.png" alt="Reference Equality Immutabiilty" srcset="https://blog.logrocket.com/wp-content/uploads/2022/10/reference-equality-immutabiilty.png 419w, https://blog.logrocket.com/wp-content/uploads/2022/10/reference-equality-immutabiilty-300x295.png 300w" sizes="(max-width: 419px) 100vw, 419px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/10/reference-equality-immutabiilty.png"/></noscript>
<p>但是，当谈到对象时，这不再适用:</p>
<pre>var str1 =  new String(‘abc’);
var str2 = new String(‘abc’);
str1 === str2 // false
var arr1 = [];
var arr2 = [];
arr1 === arr2 // false
</pre>
<p>在每种情况下，都会创建两个不同的对象，因此它们的引用不相等:</p>
<p><img data-attachment-id="139158" data-permalink="https://blog.logrocket.com/two-objects-created-unequal-references/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/10/two-objects-created-unequal-references.png" data-orig-size="387,453" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="two-objects-created-unequal-references" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/10/two-objects-created-unequal-references-256x300.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/10/two-objects-created-unequal-references.png" decoding="async" class="aligncenter wp-image-139158 size-full jetpack-lazy-image" src="../Images/8e600be0a4901f9f7a421020dfd69e78.png" alt="Two Objects Created Unequal References" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2022/10/two-objects-created-unequal-references.png 387w, https://blog.logrocket.com/wp-content/uploads/2022/10/two-objects-created-unequal-references-256x300.png 256w" data-lazy-sizes="(max-width: 387px) 100vw, 387px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2022/10/two-objects-created-unequal-references.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/10/two-objects-created-unequal-references.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="139158" data-permalink="https://blog.logrocket.com/two-objects-created-unequal-references/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/10/two-objects-created-unequal-references.png" data-orig-size="387,453" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="two-objects-created-unequal-references" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/10/two-objects-created-unequal-references-256x300.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/10/two-objects-created-unequal-references.png" decoding="async" loading="lazy" class="aligncenter wp-image-139158 size-full" src="../Images/8e600be0a4901f9f7a421020dfd69e78.png" alt="Two Objects Created Unequal References" srcset="https://blog.logrocket.com/wp-content/uploads/2022/10/two-objects-created-unequal-references.png 387w, https://blog.logrocket.com/wp-content/uploads/2022/10/two-objects-created-unequal-references-256x300.png 256w" sizes="(max-width: 387px) 100vw, 387px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/10/two-objects-created-unequal-references.png"/></noscript>
<p>如果要检查两个对象是否包含相同的值，必须使用值相等，比较对象的属性值。</p>
<p>在JavaScript中，没有直接的方法对对象和数组执行值相等。如果您正在处理字符串对象，您可以使用<code>valueOf</code>或<code>trim</code>方法，它们返回一个字符串值:</p>
<pre>var str1 =  new String(‘abc’);
var str2 = new String(‘abc’);
str1.valueOf() === str2.valueOf() // true
str1.trim() === str2.trim() // true
</pre>
<p>对于任何其他类型的对象，要么实现自己的equals方法，要么使用第三方库。如果两个对象是不可变的，那么测试它们是否相等就更容易了。React利用这个概念进行了一些性能优化；让我们详细探讨这些。</p>
<h2 id="performance-optimizations-react">React中的不变性性能优化</h2>
<p>React维护UI的内部表示，称为虚拟DOM。当组件的属性或状态发生变化时，虚拟DOM会更新以反映这些变化。操纵虚拟DOM更加容易和快速，因为UI中没有任何改变。然后，React将虚拟DOM与更新前的版本进行比较，以了解发生了什么变化，这就是所谓的<a href="https://reactjs.org/docs/reconciliation.html">协调</a>过程。</p>
<p>因此，在真正的DOM中，只有发生变化的元素才会被更新。然而，有时，DOM的某些部分会被重新渲染，即使它们没有改变。在这种情况下，它们是其他部分发生变化的副作用。您可以实现<code><a href="https://reactjs.org/docs/react-component.html#shouldcomponentupdate">shouldComponentUpdate()</a></code>函数来检查属性或状态是否真的改变了，然后返回<code>true</code>让React执行更新:</p>
<pre>class MyComponent extends Component {
// ...
shouldComponentUpdate(nextProps, nextState) {
    if (this.props.myProp !== nextProps.color) {
      return true;
    }
    return false;
  }
// ...
}
</pre>
<p>如果组件的属性和状态是不可变的对象或值，您可以用一个简单的等式操作符检查它们是否改变了。</p>
<p>从这个角度来看，不变性消除了复杂性，因为有时很难确切知道什么发生了变化。例如，考虑深层领域:</p>
<pre>myPackage.sender.address.country.id = 1;
</pre>
<p>如何有效地跟踪哪个嵌套对象发生了变化？想想数组。对于两个大小相同的数组，知道它们是否相等的唯一方法是比较每个元素，对于大型数组来说，这是一个开销很大的操作。</p>
<p>最简单的解决方案是使用不可变对象。如果对象需要更新，您必须用新值创建一个新对象，因为原始值是不可变的，不能更改。您可以使用引用相等来知道它发生了变化。</p>
<p>React文档还建议将状态视为不可变的。直接操纵状态会使React的状态管理失效，从而导致性能问题。React <code>useState</code>钩子在性能优化中起着至关重要的作用，它允许您避免直接操纵功能组件中的状态。</p>
<p>对于一些人来说，这个概念可能看起来有点不一致，或者与性能和简单性的想法相反。因此，让我们回顾一下创建新对象和实现不变性的选项。</p>
<h2 id="implementing-immutability">在React中实现不变性</h2>
<p>在大多数真实世界的应用程序中，您的状态和属性将是对象和数组。JavaScript提供了一些方法来创建它们的新版本。</p>
<h3 id="object-assign"><code>Object.assign</code></h3>
<p>您可以使用<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign"> <code>Object.assign</code> </a>来避免定义未修改的属性，而不是手动创建具有新属性的对象:</p>
<pre>const modifyShirt = (shirt, newColor, newSize) =&gt; {
  return {
    id: shirt.id,
    desc: shirt.desc,
    color: newColor,
    size: newSize
  };
}


const modifyShirt = (shirt, newColor, newSize) =&gt; {
  return Object.assign( {}, shirt, {
    color: newColor,
    size: newSize
  });
}
</pre>
<p><code>Object.assign</code>将复制作为参数传递的对象的所有属性，从第二个参数开始到第一个参数中指定的对象。</p>
<h3 id="spread-operator">传播算子</h3>
<p>您可以使用<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_syntax">扩展运算符</a>，效果相同；不同之处在于<code>Object.assign()</code>使用setter方法来分配新值，而spread运算符不这样做:</p>
<pre>const modifyShirt = (shirt, newColor, newSize) =&gt; {
  return {
    ...shirt,
    color: newColor,
    size: newSize
  };
}
</pre>
<p>您还可以使用spread运算符创建具有新值的数组:</p>
<pre>const addValue = (arr) =&gt; {
  return [...arr, 1];
};
</pre>
<h3 id="concat-slice-methods"><code>concat</code>和<code>slice</code>方法</h3>
<p>或者，您可以使用类似于<code>concat</code>或<code>slice</code>的方法，它们返回一个新数组，而不修改原来的数组:</p>
<pre>const addValue = (arr) =&gt; {
  return arr.concat([1]);
};
const removeValue = (arr, index) =&gt; {
  return arr.slice(0, index)
    .concat(
        arr.slice(index+1)
    );
};
</pre>
<p>在这个<a href="https://gist.github.com/JoeNoPhoto/329f002ef4f92f1fcc21280dc2f4aa71">要点</a>中，您将看到如何将spread操作符与这些方法结合起来，以避免在执行常见操作时改变数组。</p>
<p>然而，使用这些本地方法有两个主要缺点。首先，它们将属性或元素从一个对象或数组复制到另一个对象或数组，对于较大的对象和数组来说，这可能是一个缓慢的操作。此外，默认情况下，对象和数组是可变的。没有任何东西强制不变性。你必须记住使用这些方法中的一种。</p>
<p>由于这些原因，最好使用处理不变性的外部库。</p><div class="code-block code-block-54">
<hr/>
<h3>更多来自LogRocket的精彩文章:</h3>

<hr/></div>
<h2 id="immutability-libraries">不变性库</h2>
<p>React团队推荐<a href="https://immutable-js.com/"> Immutable.js </a>和<a href="https://github.com/kolodny/immutability-helper">immutanbility-helper</a>，但是<a href="https://github.com/markerikson/redux-ecosystem-links/blob/master/immutable-data.md">可以找到许多具有类似功能的库</a>。有三种主要类型:</p>
<ul>
<li>使用专用数据结构的库</li>
<li>通过冻结对象来工作的库</li>
<li>具有执行不可变操作的助手函数的库</li>
</ul>
<p>这些库中的大多数都使用持久数据结构。</p>
<h2 id="persistent-data-structures">持久数据结构</h2>
<p>无论什么时候修改，持久数据结构都会创建一个新版本，使得数据不可变，同时提供对所有版本的访问。</p>
<p>如果数据结构是部分持久的，您可以访问所有版本，但是，您只能修改最新的版本。如果数据结构是完全持久的，您可以访问和修改每个版本。</p>
<p>持久数据结构基于两个概念，树和共享，以有效的方式实现新版本。</p>
<p>数据结构充当列表或映射，但在幕后，它是作为一种树来实现的，称为<a href="https://en.wikipedia.org/wiki/Trie"> trie </a>，具体来说是<a href="https://stackoverflow.com/a/29121204/3593852">位图向量trie </a>。只有叶子保存值，键的二进制表示是树的内部节点。</p>
<p>例如，假设我们有下面的数组:</p>
<pre>[1, 2, 3, 4, 5]
</pre>
<p>我们可以将索引转换为4位二进制数:</p>
<pre>0: 0000
1: 0001
2: 0010
3: 0011
4: 0100
</pre>
<p>我们可以将数组表示为一棵树，如下所示:</p>
<p><img data-attachment-id="139161" data-permalink="https://blog.logrocket.com/bitmapped-vector-trie/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/10/bitmapped-vector-trie.png" data-orig-size="502,480" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="bitmapped-vector-trie" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/10/bitmapped-vector-trie-300x287.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/10/bitmapped-vector-trie.png" decoding="async" class="aligncenter wp-image-139161 size-full jetpack-lazy-image" src="../Images/38b763b17462687d891d9176a8cc3a7d.png" alt="Bitmapped Vector Trie" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2022/10/bitmapped-vector-trie.png 502w, https://blog.logrocket.com/wp-content/uploads/2022/10/bitmapped-vector-trie-300x287.png 300w" data-lazy-sizes="(max-width: 502px) 100vw, 502px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2022/10/bitmapped-vector-trie.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/10/bitmapped-vector-trie.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="139161" data-permalink="https://blog.logrocket.com/bitmapped-vector-trie/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/10/bitmapped-vector-trie.png" data-orig-size="502,480" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="bitmapped-vector-trie" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/10/bitmapped-vector-trie-300x287.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/10/bitmapped-vector-trie.png" decoding="async" loading="lazy" class="aligncenter wp-image-139161 size-full" src="../Images/38b763b17462687d891d9176a8cc3a7d.png" alt="Bitmapped Vector Trie" srcset="https://blog.logrocket.com/wp-content/uploads/2022/10/bitmapped-vector-trie.png 502w, https://blog.logrocket.com/wp-content/uploads/2022/10/bitmapped-vector-trie-300x287.png 300w" sizes="(max-width: 502px) 100vw, 502px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/10/bitmapped-vector-trie.png"/></noscript>
<p>每个级别都有两个字节，它们构成了到达某个值的路径。现在，假设您想要将值<code>1</code>更新为<code>6</code>:</p>
<p><img data-attachment-id="139163" data-permalink="https://blog.logrocket.com/update-value-bitmap-vector-tree/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/10/update-value-bitmap-vector-tree.png" data-orig-size="501,480" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="update-value-bitmap-vector-tree" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/10/update-value-bitmap-vector-tree-300x287.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/10/update-value-bitmap-vector-tree.png" decoding="async" class="aligncenter wp-image-139163 size-full jetpack-lazy-image" src="../Images/cfb53b9029e52e8c0308acb3cefa14b0.png" alt="Update Value Bitmap Vector Tree" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2022/10/update-value-bitmap-vector-tree.png 501w, https://blog.logrocket.com/wp-content/uploads/2022/10/update-value-bitmap-vector-tree-300x287.png 300w" data-lazy-sizes="(max-width: 501px) 100vw, 501px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2022/10/update-value-bitmap-vector-tree.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/10/update-value-bitmap-vector-tree.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="139163" data-permalink="https://blog.logrocket.com/update-value-bitmap-vector-tree/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/10/update-value-bitmap-vector-tree.png" data-orig-size="501,480" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="update-value-bitmap-vector-tree" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/10/update-value-bitmap-vector-tree-300x287.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/10/update-value-bitmap-vector-tree.png" decoding="async" loading="lazy" class="aligncenter wp-image-139163 size-full" src="../Images/cfb53b9029e52e8c0308acb3cefa14b0.png" alt="Update Value Bitmap Vector Tree" srcset="https://blog.logrocket.com/wp-content/uploads/2022/10/update-value-bitmap-vector-tree.png 501w, https://blog.logrocket.com/wp-content/uploads/2022/10/update-value-bitmap-vector-tree-300x287.png 300w" sizes="(max-width: 501px) 100vw, 501px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/10/update-value-bitmap-vector-tree.png"/></noscript>
<p>不是直接更新树中的值，而是复制从根到您正在更改的值的路径上的节点:</p>
<p><img data-attachment-id="139166" data-permalink="https://blog.logrocket.com/path-nodes-update-copy/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/10/path-nodes-update-copy.png" data-orig-size="740,481" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="path-nodes-update-copy" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/10/path-nodes-update-copy-300x195.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/10/path-nodes-update-copy.png" decoding="async" class="aligncenter wp-image-139166 size-full jetpack-lazy-image" src="../Images/6f8af9e2dba9b752dcc5a53ff06e9ff4.png" alt="Path Nodes Update Copy" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2022/10/path-nodes-update-copy.png 740w, https://blog.logrocket.com/wp-content/uploads/2022/10/path-nodes-update-copy-300x195.png 300w" data-lazy-sizes="(max-width: 740px) 100vw, 740px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2022/10/path-nodes-update-copy.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/10/path-nodes-update-copy.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="139166" data-permalink="https://blog.logrocket.com/path-nodes-update-copy/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/10/path-nodes-update-copy.png" data-orig-size="740,481" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="path-nodes-update-copy" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/10/path-nodes-update-copy-300x195.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/10/path-nodes-update-copy.png" decoding="async" loading="lazy" class="aligncenter wp-image-139166 size-full" src="../Images/6f8af9e2dba9b752dcc5a53ff06e9ff4.png" alt="Path Nodes Update Copy" srcset="https://blog.logrocket.com/wp-content/uploads/2022/10/path-nodes-update-copy.png 740w, https://blog.logrocket.com/wp-content/uploads/2022/10/path-nodes-update-copy-300x195.png 300w" sizes="(max-width: 740px) 100vw, 740px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/10/path-nodes-update-copy.png"/></noscript>
<p>该值在新节点上更新:</p>
<p><img data-attachment-id="139168" data-permalink="https://blog.logrocket.com/value-updated-new-node/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/10/value-updated-new-node.png" data-orig-size="740,481" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="value-updated-new-node" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/10/value-updated-new-node-300x195.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/10/value-updated-new-node.png" decoding="async" class="aligncenter wp-image-139168 size-full jetpack-lazy-image" src="../Images/67a4a8e5a597131acae06cdbcb3c2f53.png" alt="Value Updated New Node" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2022/10/value-updated-new-node.png 740w, https://blog.logrocket.com/wp-content/uploads/2022/10/value-updated-new-node-300x195.png 300w" data-lazy-sizes="(max-width: 740px) 100vw, 740px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2022/10/value-updated-new-node.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/10/value-updated-new-node.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="139168" data-permalink="https://blog.logrocket.com/value-updated-new-node/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/10/value-updated-new-node.png" data-orig-size="740,481" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="value-updated-new-node" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/10/value-updated-new-node-300x195.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/10/value-updated-new-node.png" decoding="async" loading="lazy" class="aligncenter wp-image-139168 size-full" src="../Images/67a4a8e5a597131acae06cdbcb3c2f53.png" alt="Value Updated New Node" srcset="https://blog.logrocket.com/wp-content/uploads/2022/10/value-updated-new-node.png 740w, https://blog.logrocket.com/wp-content/uploads/2022/10/value-updated-new-node-300x195.png 300w" sizes="(max-width: 740px) 100vw, 740px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/10/value-updated-new-node.png"/></noscript>
<p>剩余的节点被重用:</p>
<p><img data-attachment-id="139170" data-permalink="https://blog.logrocket.com/remainder-nodes-reused/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/10/remainder-nodes-reused.png" data-orig-size="741,480" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="remainder-nodes-reused" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/10/remainder-nodes-reused-300x194.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/10/remainder-nodes-reused.png" decoding="async" class="aligncenter wp-image-139170 size-full jetpack-lazy-image" src="../Images/3be9ff709ae8c5fbdd3a463a801b4fc0.png" alt="Remainder Nodes Reused" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2022/10/remainder-nodes-reused.png 741w, https://blog.logrocket.com/wp-content/uploads/2022/10/remainder-nodes-reused-300x194.png 300w" data-lazy-sizes="(max-width: 741px) 100vw, 741px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2022/10/remainder-nodes-reused.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/10/remainder-nodes-reused.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="139170" data-permalink="https://blog.logrocket.com/remainder-nodes-reused/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/10/remainder-nodes-reused.png" data-orig-size="741,480" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="remainder-nodes-reused" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/10/remainder-nodes-reused-300x194.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/10/remainder-nodes-reused.png" decoding="async" loading="lazy" class="aligncenter wp-image-139170 size-full" src="../Images/3be9ff709ae8c5fbdd3a463a801b4fc0.png" alt="Remainder Nodes Reused" srcset="https://blog.logrocket.com/wp-content/uploads/2022/10/remainder-nodes-reused.png 741w, https://blog.logrocket.com/wp-content/uploads/2022/10/remainder-nodes-reused-300x194.png 300w" sizes="(max-width: 741px) 100vw, 741px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/10/remainder-nodes-reused.png"/></noscript>
<p>换句话说，未修改的节点由两个版本共享。当然，这种4位分支通常不用于这些数据结构，但是，这是结构共享的基本概念。</p>
<p>我就不赘述了，但是如果你想了解更多关于持久数据结构和结构共享的知识，我推荐<a href="https://medium.com/@dtinth/immutable-js-persistent-data-structures-and-structural-sharing-6d163fbd73d2">阅读这篇文章</a>或者<a href="https://www.youtube.com/watch?v=Wo0qiGPSV-s">观看这篇演讲</a>。</p>
<h2 id="benefits-immutability">不变性的好处</h2>
<p>总的来说，不变性提高了应用程序的性能，并促进了简单的调试。它允许简单而廉价地实现检测变化的复杂技术，并确保仅在绝对必要时才执行更新DOM的计算开销很大的过程。</p>
<h2 id="disadvantages-immutability">不变性的缺点</h2>
<p>然而，不变性并不是没有自身的问题。正如我前面提到的，当处理对象和数组时，您要么必须记住使用方法而不是强制不变性，要么使用第三方库。</p>
<p>许多这些库使用它们自己的数据类型。尽管它们提供了兼容的API和将这些类型转换为原生JavaScript类型的方法，但在设计应用程序时，您必须小心避免高度耦合或使用类似<code><a href="https://twitter.com/leeb/status/746733697093668864">toJs()</a></code>的方法损害性能。</p>
<p>如果库不实现新的数据结构，例如，通过冻结对象工作的库，就不会有任何结构共享的好处。最有可能的是，对象在更新时会被复制，在某些情况下性能会受到影响。</p>
<p>此外，在较大的团队中实现不变性概念可能会很耗时，因为个体开发人员必须遵守纪律，尤其是在使用具有陡峭学习曲线的第三方库时。您还必须考虑与这些库相关的学习曲线。</p>
<p>Redux 中可以看到不可变性的另一个<a href="https://blog.logrocket.com/redux-immutable-update-patterns/">缺点，这使得组件在Redux的<code>combineReducers</code>功能旁边的reducers中使用时会出现不必要的渲染。要深入了解Redux的不变性，请查看Redux </a>中的<a href="https://redux.js.org/faq/immutable-data">不可变数据。</a></p>
<p>由于这些原因，在决定使用哪种方法来增强不变性时，您必须小心。</p>
<h2 id="conclusion">结论</h2>
<p>理解不变性对于React开发人员来说至关重要。不可变的值或对象不能被改变，所以每次更新都会创建新的值，旧的值保持不变。例如，如果您的应用程序状态是不可变的，您可以将所有状态对象保存在一个存储中，以便轻松实现撤消和重做功能。</p>
<p>像Git这样的版本控制系统以类似的方式工作。Redux也是基于那个<a href="https://redux.js.org/introduction/three-principles">原理</a>。然而，对Redux的关注更多的是在纯函数和应用程序状态的快照方面。这个<a href="https://stackoverflow.com/a/34962065/3593852"> StackOverflow答案</a>很好的解释了Redux和不变性的关系。</p>
<p>不变性还有其他优点，比如避免意外的副作用或者减少耦合，但是它也有缺点。请记住，与编程中的许多事情一样，这是一种权衡。</p><div class="code-block code-block-17">
<div class="blog-plug inline-plug react-plug" vwo-el-id="26283398190">
<h2 vwo-el-id="41600691720"><a href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener"> LogRocket </a>:全面了解您的生产React应用</h2><p>调试React应用程序可能很困难，尤其是当用户遇到难以重现的问题时。如果您对监视和跟踪Redux状态、自动显示JavaScript错误以及跟踪缓慢的网络请求和组件加载时间感兴趣，</p><a href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" vwo-el-id="19356441070">try LogRocket</a><p>. </p><a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="19356441380">
<img class="first-react-image alignnone size-full wp-image-46 jetpack-lazy-image jetpack-lazy-image--handled" src="../Images/f300c244a1a1cf916df8b4cb02bec6c6.png" vwo-el-id="18272717540" data-lazy-loaded="1" data-original-src="https://files.readme.io/27c94e7-Image_2017-06-05_at_9.46.04_PM.png"/>
</a>
<a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="19356441690">
<img class="second-react-image alignnone size-full wp-image-46 jetpack-lazy-image jetpack-lazy-image--handled" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" vwo-el-id="30720362350" data-lazy-loaded="1" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/>
</a>
<p vwo-el-id="28675660440" class="">LogRocket 结合了会话回放、产品分析和错误跟踪，使软件团队能够创建理想的web和移动产品体验。这对你来说意味着什么？</p>
<p>LogRocket不是猜测错误发生的原因，也不是要求用户提供截图和日志转储，而是让您回放问题，就像它们发生在您自己的浏览器中一样，以快速了解哪里出错了。</p>
<p>不再有嘈杂的警报。智能错误跟踪允许您对问题进行分类，然后从中学习。获得有影响的用户问题的通知，而不是误报。警报越少，有用的信号越多。</p>
<p vwo-el-id="28675660750">LogRocket Redux中间件包为您的用户会话增加了一层额外的可见性。LogRocket记录Redux存储中的所有操作和状态。</p>
<p vwo-el-id="28675661060">现代化您调试React应用的方式— <a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="40093418840">开始免费监控</a>。</p>
</div></div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
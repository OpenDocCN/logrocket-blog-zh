<html>
<head>
<title>Code splitting React components with TypeScript and NO Babel - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>代码分割用类型脚本和没有巴别塔-日志火箭博客来反应组件</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/code-splitting-react-components-with-typescript-and-no-babel/#0001-01-01">https://blog.logrocket.com/code-splitting-react-components-with-typescript-and-no-babel/#0001-01-01</a></blockquote><div><article class="article-post">
<h2>web性能的秘密在于代码更少</h2>
<p>随着现在臭名昭著的单页面应用程序的出现，大量的JavaScript开始被推到浏览器上。JavaScript的重量是一个问题，但是浏览器也必须解析下载的JavaScript。浏览器的UI线程可能会在这种压力下挂起，因为它超出了预期目的。显而易见的答案是发布更少的代码。代码分割允许我们在不减少功能的情况下做到这一点。</p>
<p>代码分割是一件复杂的事情，一束代码被分割成可以按需加载的小块。值得庆幸的是，像webpack这样的工具将这种复杂性抽象在一个不太复杂的API后面。不幸的是，这个不太复杂的API仍然非常复杂。在React生态系统中，像<a href="https://github.com/gregberge/loadable-components" target="_blank" rel="noopener noreferrer">loadable-components</a>这样的工具为<a href="https://javascript.info/modules-dynamic-imports" target="_blank" rel="noopener noreferrer">动态导入</a>添加了一层更简单的外表。</p>
<h2>按路由进行代码拆分</h2>
<p>我希望看到更多的渲染控制返回到服务器。浏览器不是用来呈现HTML的，有很多很好的理由说明为什么在服务器端呈现React更好。我预测我们将会看到更多的服务器端HTML渲染的回归。</p>
<p>下面是来自我的公司网站的一些代码，该网站使用动态导入来创建更小的代码文件，这些文件可以按需加载。</p>
<pre>import React from 'react';
import loadable from '@loadable/component';
import * as Urls from '../urls';
import { RouteProps, Route, Switch } from 'react-router';

export type Page&lt;P = unknown&gt; = RouteProps &amp; {
  heading: string;
  path: string;
  footerPage?: boolean;
} &amp; P;

const fallback = &lt;div&gt;loading....&lt;/div&gt;;

const Home = loadable(() =&gt; import('src/components/Home'), {
  fallback,
});
const OSS = loadable(() =&gt; import('src/components/OSS'), {
  fallback: &lt;div&gt;Loading...&lt;/div&gt;,
});
const Blog = loadable(() =&gt; import('src/components/Blog'), {
  fallback: &lt;div&gt;Loading...&lt;/div&gt;,
});

export const routable: Page[] = [
  {
    heading: 'Home',
    path: Urls.Home,
    component: Home,
    exact: true,
  },
  {
    heading: 'OSS',
    path: Urls.OSS,
    component: OSS,
    exact: true,
  },
// etc.</pre>
<p><code>loadable</code>函数将动态导入作为一个参数，它将为我们完成这项艰巨的工作。运行webpack构建会创建几个可以延迟加载的较小文件:</p>
<p><img data-attachment-id="15557" data-permalink="https://blog.logrocket.com/code-splitting-react-components-with-typescript-and-no-babel/code-split/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/03/code-split.png" data-orig-size="828,439" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="code-split" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/03/code-split-300x159.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/03/code-split.png" decoding="async" class="aligncenter wp-image-15557 size-full jetpack-lazy-image" src="../Images/96532dd3bc260274b4df5f3f0d5a70c2.png" alt="list of files that have been code splitted" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2020/03/code-split.png 828w, https://blog.logrocket.com/wp-content/uploads/2020/03/code-split-300x159.png 300w, https://blog.logrocket.com/wp-content/uploads/2020/03/code-split-768x407.png 768w" data-lazy-sizes="(max-width: 828px) 100vw, 828px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2020/03/code-split.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/03/code-split.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="15557" data-permalink="https://blog.logrocket.com/code-splitting-react-components-with-typescript-and-no-babel/code-split/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/03/code-split.png" data-orig-size="828,439" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="code-split" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/03/code-split-300x159.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/03/code-split.png" decoding="async" loading="lazy" class="aligncenter wp-image-15557 size-full" src="../Images/96532dd3bc260274b4df5f3f0d5a70c2.png" alt="list of files that have been code splitted" srcset="https://blog.logrocket.com/wp-content/uploads/2020/03/code-split.png 828w, https://blog.logrocket.com/wp-content/uploads/2020/03/code-split-300x159.png 300w, https://blog.logrocket.com/wp-content/uploads/2020/03/code-split-768x407.png 768w" sizes="(max-width: 828px) 100vw, 828px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/03/code-split.png"/></noscript>
<h2>@可加载/巴别塔插件</h2>
<p>我是一个超级打字迷，我总是远离任何需要Babel的东西，因为不得不维护两种不同的transpiler配置不是我愿意走的路。</p>
<p><code>@loadable/babel-plugin</code>像这样转换代码:</p>
<pre>import loadable from '@loadable/component';

export const LazyFoo = loadable(() =&gt; import('./input/AsyncDefaultComponent'));</pre>
<p>变成这样的代码:</p>
<pre>import loadable from 'loadable-components';

export const LazyFoo = loadable({
  chunkName() {
    return 'input-AsyncDefaultComponent';
  },
  isReady(props) {
    return (
      typeof __webpack_modules__ !== 'undefined' &amp;&amp;
      Boolean(__webpack_modules__[this.resolve(props)])
    );
  },
  requireAsync: () =&gt;
    import(
      /* "webpackChunkName":"input-AsyncDefaultComponent" */ './input/AsyncDefaultComponent'
    ),
  requireSync(props) {
    return typeof '__webpack_require__' !== 'undefined'
      ? __webpack_require__(this.resolve(props))
      : eval('module.require')(this.resolve(props));
  },
  resolve() {
    if (require.resolveWeak)
      return require.resolveWeak(
        /* "webpackChunkName":"input-AsyncDefaultComponent" */ './input/AsyncDefaultComponent',
      );
    else
      return eval('require.resolve')(
        /* "webpackChunkName":"input-AsyncDefaultComponent" */ './input/AsyncDefaultComponent',
      );
  },
});</pre>
<h2>可装载变压器</h2>
<p>现在该片的主角登场了，即<a href="https://github.com/Quramy/loadable-ts-transformer" target="_blank" rel="noopener noreferrer"> loadable-ts-transformer </a>，它与它的Babel对应物做着同样的工作，只是它通过创建一个<a href="https://blog.logrocket.com/using-typescript-transforms-to-enrich-runtime-code-3fd2863221ed/" target="_blank" rel="noopener noreferrer">类型脚本转换器</a>来完成这项工作。TypeScript transformer允许我们挂接编译管道并转换代码，就像上面列出的Babel插件一样。一个完整的AST由开发人员按照他们的意愿处理。</p>
<h2>将loadable-ts-transformer连接到webpack构建</h2>
<p>第一步是用<a href="https://loadable-components.com/docs/api-loadable-component/#loadable" target="_blank" rel="noopener noreferrer">可加载组件的可加载函数</a>定义我们想要分割成更小块的组件:</p>
<pre>const Home = loadable(() =&gt; import('src/components/Home'), {
  fallback,
});</pre>
<p>接下来，需要配置webpack。通常，在webpack ssr(服务器端呈现)构建中，您有一个服务器webpack配置文件和一个客户端webpack配置文件。</p>
<p>webpack服务器配置负责捆绑呈现react组件服务器端的节点<a href="https://expressjs.com/" target="_blank" rel="noopener noreferrer"> express代码</a>。</p>
<p>为了减少两个配置文件之间的重复，我使用<a href="https://www.npmjs.com/package/webpack-merge" target="_blank" rel="noopener noreferrer"> webpack-merge </a>来创建一个<code>common.config.js</code>文件，该文件被合并到<code>client.config.js</code>和<code>server.config.js</code>文件中。</p>
<p>下面是一个<code>common.config.js</code>文件的例子，它包含webpack客户端和服务器配置文件的通用组件:</p>
<pre>const path = require("path");
const { loadableTransformer } = require('loadable-ts-transformer');

module.exports = {
  resolve: {
    extensions: ['.ts', '.tsx', '.js'],
  },
  module: {
    rules: [
      {
        test: /\.tsx?$/,
        exclude: /node_modules/,
        loader: 'ts-loader',
        options: {
          transpileOnly: true,
          getCustomTransformers: () =&gt; ({ before: [loadableTransformer] }),
        },
      }
    ],
  },
};</pre>
<p>我使用<a href="https://github.com/TypeStrong/ts-loader" target="_blank" rel="noopener noreferrer"> ts-loader </a>将类型脚本转换成JavaScript，<code>ts-loader</code>有一个<a href="https://github.com/TypeStrong/ts-loader#getcustomtransformers" target="_blank" rel="noopener noreferrer"> getCustomTransformers </a>选项，我们可以用它来添加<code>loadable-ts-transformer</code>。</p>
<p><code>client.config.js</code>文件如下所示:</p>
<pre>const path = require("path");
const merge = require('webpack-merge');
const LoadablePlugin = require('@loadable/webpack-plugin');
const commonConfig = require('./webpack.config');
const webpack = require('webpack');

module.exports = () =&gt; {
  return merge(commonConfig, {
    output: {
      path: path.resolve(__dirname, 'public'),
      publicPath: '/assets/',
      filename: '[name].[chunkhash].js',
    },
    entry: {
      main: path.resolve(__dirname, 'src/client.tsx'),
    },
    optimization: {
      splitChunks: {
        name: 'vendor',
        chunks: 'initial',
      },
    },
    plugins: [
      new LoadablePlugin(),
      new webpack.DefinePlugin({ __isBrowser__: "true" })
    ],
  });
};</pre>
<p>注意<a href="https://webpack.js.org/plugins/define-plugin/" target="_blank" rel="noopener noreferrer">网络包的使用。定义插件</a>将<code>__isBrowser__</code>属性添加到捆绑代码中。这不再需要使用无休止的<code>typeof window === 'undefined'</code>检查来确定代码是否在服务器或浏览器上执行。</p>
<p><code>client.config.js</code>文件还将<a href="https://loadable-components.com/docs/api-loadable-webpack-plugin/#loadablewebpack-plugin" target="_blank" rel="noopener noreferrer"> @loadable/webpack-plugin </a>添加到插件数组中。不要将其添加到<code>server.config.js</code>中。</p>
<p><code>server.config.js</code>文件如下所示:</p>
<pre>const path = require("path");
const merge = require('webpack-merge');
const commonConfig = require('./webpack.config');
const webpack = require('webpack');
const nodeExternals = require('webpack-node-externals');

module.exports = () =&gt; {
  return merge(commonConfig, {
    target: 'node',
    externals:  nodeExternals({
      whitelist: [
          /^@loadable\/component$/,
          /^react$/,
          /^react-dom$/,
          /^loadable-ts-transformer$/,
        ]
      }),
    ],
    output: {
      path: path.resolve(__dirname, 'dist-server'),
      filename: '[name].js',
    },
    entry: {
      server: path.resolve(__dirname, 'src/server.tsx'),
    },
   plugins: [
     new webpack.DefinePlugin({ __isBrowser__: "false" })
   ]
  });
};</pre>
<p><a href="https://webpack.js.org/configuration/externals/" target="_blank" rel="noopener noreferrer"> webpack externals </a>部分曾多次绊倒我。externals属性允许您将webpack服务器构建中捆绑的内容列入白名单。您不希望捆绑整个<code>node_modules</code>文件夹。我发现<a href="https://www.npmjs.com/package/webpack-node-externals" target="_blank" rel="noopener noreferrer"> webpack-node-externals包</a>非常有用，它有一个白名单选项。</p>
<h2>可加载组件服务器端</h2>
<p><code>server.config.js</code>文件定义了<code>src/server/index.ts</code>的<a href="https://webpack.js.org/concepts/#entry" target="_blank" rel="noopener noreferrer">入口点</a>，如下所示:</p>
<pre>export const app = express();
const rootDir = process.cwd();

const publicDir = path.join(rootDir, isProduction ? 'dist/public' : 'public');
app.use(express.static(publicDir));

app.use(bodyParser.urlencoded({ extended: false }));
app.use(bodyParser.json());

app.get('/*', async (req, res) =&gt; {
  await render({
    req,
    res,
  });
});</pre>
<p>上述代码的要点是:</p>
<ul>
<li><code>app.use(express.static(publicDir));</code>代码点表示webpack使用<a href="https://expressjs.com/en/starter/static-files.html" target="_blank" rel="noopener noreferrer"> express静态函数</a>输出的静态文件</li>
<li>一个包罗万象的<code>app.get('/*. async (req. res) =&gt; {</code>路径指向一个可重用的<code>render</code>函数，我将在下面解释这个函数</li>
</ul>
<p><code>render</code>功能如下:</p>
<pre>const statsFile = path.resolve(process.cwd(), 'dist/loadable-stats.json');

export async function render({ req, res }: RendererOptions): Promise&lt;void&gt; {
  const extractor = new ChunkExtractor({
    entrypoints: ['client'],
    statsFile,
  });

  const context: StaticRouterContext = {};

  const html = renderToString(
    extractor.collectChunks(
      &lt;StaticRouter location={req.url} context={context}&gt;
        &lt;Routes /&gt;
      &lt;/StaticRouter&gt;,
    ),
  );

  res.status(HttpStatusCode.Ok).send(`
    &lt;!doctype html&gt;
    &lt;html lang="en"&gt;
      &lt;head&gt;
        &lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8"&gt;
        &lt;meta httpEquiv="X-UA-Compatible" content="IE=edge" /&gt;
        &lt;meta charSet="utf-8" /&gt;
        &lt;meta name="viewport" content="width=device-width, initial-scale=1" /&gt;
        ${extractor.getStyleTags()}   
      &lt;/head&gt;
      &lt;body&gt;
        &lt;div id="root"&gt;${html}&lt;/div&gt;
        ${extractor.getScriptTags()}
      &lt;/body&gt;
    &lt;/html&gt;
`);
}</pre>
<p>上面的代码利用了<a href="https://loadable-components.com/docs/api-loadable-server/#chunkextractor" target="_blank" rel="noopener noreferrer"> ChunkExtractor组件</a>，它收集服务器端的块，然后创建可以在输出的HTML中使用的脚本标签或脚本元素。</p>
<p><code>${extractor.getStyleTags()}</code>将输出CSS链接标签，而<code>${extractor.getScriptTags()}</code>将输出JavaScript脚本标签。</p>
<p>当运行您的构建时，@loadable/webpack-plugin生成一个名为<code>loadable-stats.json</code>的文件，它包含来自webpack的所有条目和块的信息。</p>
<p>一旦就位，<code>ChunkExtractor</code>负责从该文件中找到您的条目。</p>
<p><code>ChunkExtractor</code>组件的<a href="https://loadable-components.com/docs/server-side-rendering/#chunkextractor-entrypoints" target="_blank" rel="noopener noreferrer">入口点数组</a>被设置为<code>['client']</code>，映射到webpack <code>client.config.js</code>文件的<code>client</code>属性；</p>
<pre>entry: {
  client: path.join(process.cwd(), 'src/client.tsx'),
 },</pre>
<h2>客户补液</h2>
<p>客户端配置文件的<a href="https://webpack.js.org/concepts/#entry" target="_blank" rel="noopener noreferrer">入口点</a>现在是一个具有客户端属性的对象。</p>
<p>下面列出了<code>client.tsx</code>文件:</p>
<pre>import React from 'react';
import { hydrate } from 'react-dom';
import { loadableReady } from '@loadable/component';

import { App } from '../containers/App';

const bootstrap = (): void =&gt; {
  const root = document.getElementById('root');

  if (!root) {
    return;
  }

  hydrate(&lt;App /&gt;, root);
};

loadableReady(() =&gt; bootstrap());</pre>
<p>通常，当重新水合React服务器端呈现的代码时，您会使用<a href="https://reactjs.org/docs/react-dom.html#hydrate" target="_blank" rel="noopener noreferrer"> ReactDom的水合物函数</a>，但是在上面的<code>loadable-component's</code>世界中，可加载组件的<a href="https://loadable-components.com/docs/api-loadable-component/#loadableready" target="_blank" rel="noopener noreferrer"> loadableReady函数</a>用于等待所有脚本异步加载，以确保最佳性能。所有脚本都是并行加载的，所以您必须使用<code>loadableReady</code>等待它们准备好。</p>
<h2>收场白</h2>
<p>由于对Babel的需求，我已经避免使用许多代码分割包。<a href="https://github.com/Quramy/loadable-ts-transformer" target="_blank" rel="noopener noreferrer"> loadable-ts-transformer </a>已经解决了这个问题。</p>
<p>如果你想看到这个被添加到<a href="https://github.com/gregberge/loadable-components" target="_blank" rel="noopener noreferrer">可加载组件的源</a>中，那么请在<a href="https://github.com/gregberge/loadable-components/issues/458" target="_blank" rel="noopener noreferrer">这个问题</a>上插话，我在那里发现了它的存在。</p><div class="code-block code-block-17">
<div class="blog-plug inline-plug react-plug" vwo-el-id="26283398190">
<h2 vwo-el-id="41600691720"><a href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener"> LogRocket </a>:全面了解您的生产React应用</h2><p>调试React应用程序可能很困难，尤其是当用户遇到难以重现的问题时。如果您对监视和跟踪Redux状态、自动显示JavaScript错误以及跟踪缓慢的网络请求和组件加载时间感兴趣，</p><a href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" vwo-el-id="19356441070">try LogRocket</a><p>. </p><a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="19356441380">
<img class="first-react-image alignnone size-full wp-image-46 jetpack-lazy-image jetpack-lazy-image--handled" src="../Images/f300c244a1a1cf916df8b4cb02bec6c6.png" vwo-el-id="18272717540" data-lazy-loaded="1" data-original-src="https://files.readme.io/27c94e7-Image_2017-06-05_at_9.46.04_PM.png"/>
</a>
<a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="19356441690">
<img class="second-react-image alignnone size-full wp-image-46 jetpack-lazy-image jetpack-lazy-image--handled" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" vwo-el-id="30720362350" data-lazy-loaded="1" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/>
</a>
<p vwo-el-id="28675660440" class="">LogRocket 结合了会话回放、产品分析和错误跟踪，使软件团队能够创建理想的web和移动产品体验。这对你来说意味着什么？</p>
<p>LogRocket不是猜测错误发生的原因，也不是要求用户提供截图和日志转储，而是让您回放问题，就像它们发生在您自己的浏览器中一样，以快速了解哪里出错了。</p>
<p>不再有嘈杂的警报。智能错误跟踪允许您对问题进行分类，然后从中学习。获得有影响的用户问题的通知，而不是误报。警报越少，有用的信号越多。</p>
<p vwo-el-id="28675660750">LogRocket Redux中间件包为您的用户会话增加了一层额外的可见性。LogRocket记录Redux存储中的所有操作和状态。</p>
<p vwo-el-id="28675661060">现代化您调试React应用的方式— <a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="40093418840">开始免费监控</a>。</p><div class="code-block code-block-21">
<div class="blog-plug inline-plug typescript-plug"><h2><a class="signup" href="https://lp.logrocket.com/blg/typescript-signup" target="_blank" rel="noopener noreferrer"> LogRocket </a>:全面了解您的网络和移动应用</h2>
<a href="https://lp.logrocket.com/blg/typescript-signup" class="signup" target="_blank" rel="noopener noreferrer"><img class="alignnone size-full wp-image-46 jetpack-lazy-image" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/><noscript><img data-lazy-fallback="1" class="alignnone size-full wp-image-46" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/></noscript></a>
<p>LogRocket 是一个前端应用程序监控解决方案，可以让您回放问题，就像问题发生在您自己的浏览器中一样。LogRocket不需要猜测错误发生的原因，也不需要向用户询问截图和日志转储，而是让您重放会话以快速了解哪里出错了。它可以与任何应用程序完美配合，不管是什么框架，并且有插件可以记录来自Redux、Vuex和@ngrx/store的额外上下文。</p>
<p>除了记录Redux操作和状态，LogRocket还记录控制台日志、JavaScript错误、堆栈跟踪、带有头+正文的网络请求/响应、浏览器元数据和自定义日志。它还使用DOM来记录页面上的HTML和CSS，甚至为最复杂的单页面和移动应用程序重新创建像素级完美视频。</p>
<a class="signup" href="https://lp.logrocket.com/blg/typescript-signup" target="_blank" rel="noopener noreferrer">Try it for free</a><p>.</p></div>
</div>
</div></div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
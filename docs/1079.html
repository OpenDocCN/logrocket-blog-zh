<html>
<head>
<title>Understanding the ViewChild and ViewChildren decorators in Angular 10 - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>了解Angular 10 - LogRocket博客中的ViewChild和ViewChildren装饰器</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/understanding-the-viewchild-and-viewchildren-decorators-in-angular-10/#0001-01-01">https://blog.logrocket.com/understanding-the-viewchild-and-viewchildren-decorators-in-angular-10/#0001-01-01</a></blockquote><div><article class="article-post">
<p>Angular中的<code>@ViewChild</code>和<code>@ViewChildren</code>装饰器通过设置视图查询来提供对视图DOM中子元素的访问。视图查询是对包含元素元数据的<a href="https://angular.io/guide/glossary#view" target="_blank" rel="noopener noreferrer">组件视图</a>内的子元素的请求引用。这些装饰器的范围仅限于组件视图及其嵌入的子视图。在无法以传统方式访问和修改视图中的元素的情况下，这些装饰器尤其有用。</p>
<p>例如，如果一个库附带了一个组件或指令，并且带有您想要更改的公共非输入或非输出属性，那么这些decorators将允许您访问和修改它们。这些装饰器还有助于暴露在子组件中配置的提供者，以注入依赖关系(如服务、配置值等。)主组件可能无法访问。</p>
<p>在本文中，我们将介绍如何使用<code>@ViewChild</code>和<code>@ViewChildren</code>装饰器，它们的属性做什么，以及如何指定它们的属性。</p>
<h2>视图查询和AfterViewInit生命周期挂钩</h2>
<p>当组件视图及其子视图完全初始化时，调用<code>AfterViewInit</code>生命周期钩子。因此，对于即时修改或赋值，访问视图查询的最佳位置是在<code>ngAfterViewInit</code>回调中，因为视图查询已经被解析和设置。试图在<code>ngAfterViewInit</code>响应之前访问它们可能会产生未定义的值。然而，<code>@ViewChild</code>装饰器提供了一个<code>static</code>属性，可以在变更检测运行之前设置该属性来解析视图查询。我们将在下面介绍如何使用这个属性。</p>
<h2>ViewChild装饰器</h2>
<p>这个装饰器接受三个属性，一个<code>selector</code>、一个<code>read</code>和一个<code>static</code>属性。<code>read</code>和<code>static</code>属性是可选的。这些属性是这样指定的:</p>
<pre>@ViewChild(selector {read: readValue, static: staticValue}) property;</pre>
<h2>支持的视图子选择器</h2>
<p><code>selector</code>属性指定要查询组件视图中的哪个子元素。根据<code><a href="https://angular.io/api/core/ViewChild" target="_blank" rel="noopener noreferrer">@ViewChild</a></code>文档，支持五种选择器。这些是:</p>
<p>1)具有<code>@Component</code>或<code>@Directive</code>装饰器的类</p>
<p>在第一个例子中，<code>MenuItemComponent</code>是从<code>MenuComponent</code>视图中查询的:</p>
<pre>@Component({
  selector: 'menu-item',
  template: `&lt;p&gt;{{menuText}}&lt;/p&gt;`
})

export class MenuItemComponent {
  @Input() menuText: string;
}

@Component({
  selector: 'menu',
  template: `&lt;menu-item [menuText]="'Contact Us'"&gt;&lt;/menu-item&gt;`
})

export class MenuComponent{
  @ViewChild(MenuItemComponent) menu: MenuItem;
}</pre>
<p>下面是一个带有指令的示例:</p>
<pre>@Directive({
  selector: '[textHighlight]'
})

export class TextHighlightDirective{}

@Component({
  selector: 'profile',
  template: '&lt;p textHighlight&gt;Some text to highlight&lt;/p&gt;'
})

export class ProfileComponent{
  @ViewChild(TextHighlightDirective) highlightedText: TextHighlightDirective;
}</pre>
<p>2)字符串形式的模板引用变量。模板引用变量通常在模板中使用，但在本例中，它用于配置视图查询:</p>
<pre>@Component({
  selector: 'menu-item',
  template: `&lt;p&gt;{{menuText}}&lt;/p&gt;`
})

export class MenuItemComponent {
  @Input() menuText: string;
}

@Component({
  selector: 'menu',
  template: `
    &lt;menu-item #aboutUs [menuText]="'About Us'"&gt;&lt;/menu-item&gt;
    &lt;menu-item  #contactUs [menuText]="'Contact Us'"&gt;&lt;/menu-item&gt;
  `
})

export class MenuComponent{
  @ViewChild('aboutUs') aboutItem: MenuItem;
  @ViewChild('contactUs') contactItem: MenuItem;
}</pre>
<p>3)在当前组件的子组件树中定义的提供者。在这个例子中，<code>SampleService</code>被指定为<code>FirstChildComponentClass</code>的提供者令牌。由于<code>&lt;first-child&gt;</code>是<code>ParentComponent</code>中的一个元素，我们可以使用<code>SampleService</code>类作为令牌从它那里访问<code>SampleService</code>:</p>
<pre>export class SampleService {}

@Component({
  selector: 'first-child',
  providers: [SampleService]
})

export class FirstChildComponent{}

@Component({
  selector: 'parent',
  template: '&lt;first-child&gt;&lt;/first-child&gt;'
})

export class ParentComponent{
  @ViewChild(SampleService) sampleService: SampleService;
}</pre>
<p>4)通过字符串令牌定义的提供者。虽然<a href="https://angular.io/api/core/ViewChild#description" target="_blank" rel="noopener noreferrer">在文档</a>中有说明，但是通过这个方法获取提供者会返回未定义的值。这是在<a href="https://angular.io/guide/ivy" target="_blank" rel="noopener noreferrer"> Ivy </a>中的一个回归，在Angular 9中默认启用。针对此的<a href="https://github.com/angular/angular/pull/38321" target="_blank" rel="noopener noreferrer">修复已经完成，但是在本文发布时，它还没有包含在任何版本中。为了让它工作，您需要在<code>tsconfig.json</code>文件中禁用Ivy，而使用<code>ViewEngine</code>:</a></p>
<pre>{
  "angularCompilerOptions": {
    "enableIvy": false,
  }
}</pre>
<p>下面是如何使用通过字符串标记定义的提供者作为选择器:</p>
<pre>@Component({
  selector: 'first-child',
  providers: [{ provide: 'TokenA', useValue: 'ValueA' }]
})

export class FirstChildComponent{}

@Component({
  selector: 'parent',
  template: '&lt;first-child&gt;&lt;/first-child&gt;'
})

export class ParentComponent{
  @ViewChild('TokenA') providerA: string;
}</pre>
<p>但是，如果您想在Ivy中使用这种类型的选择器，您可以使用<code>read</code>属性来获取一个视图查询:</p>
<pre>export class ParentComponent{
  @ViewChild(FirstChildComponent, { read: 'TokenA' }) providerA: string;
}</pre>
<p>5)一个<code>TemplateRef</code>。可以使用<code>@ViewChild</code>装饰器访问嵌入式模板，然后使用<code>ViewContainerRef</code>实例化嵌入式视图:</p>
<pre>@Component({
  selector: `container`,
  template: `&lt;ng-template&gt;&lt;h1&gt;This container is empty&lt;/h1&gt;&lt;/ng-template&gt;`
})

export class ContainerComponent{
  @ViewChild(TemplateRef) contTemplate: TemplateRef;
}</pre>
<p>为了更好地理解如何使用这些配置好的视图查询，请查看每种选择器的这些<a href="https://stackblitz.com/edit/view-child-examples" target="_blank" rel="noopener noreferrer">实例</a>。它们说明了如何使用视图查询来访问和修改嵌入视图。</p>
<h2>使用读取属性</h2>
<p><code>read</code>属性允许您从查询的元素中选择各种标记。这些标记可以是用于依赖注入的提供者标记，或者在某些情况下，可以是视图查询的类型。这是一个可选属性。</p>
<p>在下面的例子中，<code>FirstChildComponent</code>有一个提供者配置，其中有各种依赖标记，比如类、字符串标记和注入标记。这些令牌与<code>read</code>属性一起可以向嵌入了<code>FirstChildComponent</code>的父组件公开这些依赖关系。使用<code>ViewChild</code>装饰器和指定每个对应令牌的<code>read</code>属性在<code>ParentComponent</code>中访问了所有这些依赖关系。</p>
<p>还可以使用<code>read</code>属性指定视图查询的类型。在同一个例子中，<code>fcElementRef</code>和<code>fcComponent</code>属性都是<code>FirstChildComponent</code>的查询，但是基于<code>read</code>属性被指定为什么，它们具有不同的类型:</p>
<pre>export class SampleService {}

export const ExampleServiceToken = new InjectionToken&lt;string&gt;('ExampleService');

@Component({
  selector: 'first-child',
  providers: [
    SampleService,
    { provide: 'TokenA', useValue: 'valueA' },
    { provide: 'TokenB', useValue: 123 },
    { provide: ExampleServiceToken, useExisting: SampleService },
    { provide: 'TokenC', useValue: true }
  ]
})

export class FirstChildComponent{}

@Component({
  selector: 'parent',
  template: `&lt;first-child&gt;&lt;/first-child&gt;`
})

export class ParentComponent{
  @ViewChild(FirstChildComponent, { read: 'TokenA' }) dependencyA: string;
  @ViewChild(FirstChildComponent, { read: 'TokenB' }) dependencyB: number;
  @ViewChild(FirstChildComponent, { read: 'TokenC' }) dependencyC: boolean;
  @ViewChild(FirstChildComponent, { read: SampleService }) sampleService: SampleService;
  @ViewChild(FirstChildComponent, { read: ElementRef }) fcElementRef: ElementRef;
  @ViewChild(FirstChildComponent, { read: FirstChildComponent }) fcComponent: FirstChildComponent;
  @ViewChild(FirstChildComponent, { read: ExampleServiceToken }) exampleService: SampleService;
}</pre>
<h2>使用静态属性</h2>
<p><code>static</code>属性接受一个布尔值，并且是可选的。默认情况下，它是假的。如果为真，则在完全初始化完整的主管视图和数据绑定属性之前，视图查询被解析。如果设置为false，则在组件视图和数据绑定属性完全初始化后解析视图查询。</p>
<p>在这个例子中，使用<code>true</code>和<code>false static</code>属性以及在<code>ngOnInit</code>和<code>ngAfterViewInit</code>回调中为每个属性记录的值来查询段落元素:</p>
<pre>@Component({
  selector: 'display-name',
  template: '&lt;p #displayName&gt;{{name}}&lt;/p&gt;'
})

export class DisplayNameComponent implements OnInit, AfterViewInit{
  @ViewChild('displayName', {static: true}) staticName: ElementRef;
  @ViewChild('displayName', {static: false}) nonStaticName: ElementRef;

  name: string = "Jane";

  ngOnInit(){
   logValues('OnInit');
  }

  ngAfterViewInit(){
   logValues('AfterViewInit');
  }

  logValues(eventType: string){
    console.log(`[${eventType}]\n staticName: ${this.staticName}, name value: "${this.staticName.nativeElement.innerHTML}"\n nonStaticName: ${this.nonStaticName}, name value: "${this.nonStaticName.nativeElement.innerHTML}"\n`);
  }
}</pre>
<p>以下是将被记录的内容:</p>
<pre>[OnInit]
staticName: [object Object], name value: "" // static: true
nonStaticName: undefined, name value: "" // static: false

[AfterViewInit]
staticName: [object Object], name value: "Jane" // static: true
nonStaticName: [object Object], name value: "Jane"  // static: false</pre>
<p>在<code>ngOnInit</code>回调中，没有内插值被初始化，但是通过<code>{ static: true}</code>,<code>staticName</code>视图查询已经被解析，但是<code>nonStaticName</code>未被定义。然而，在<code>AfterViewInit</code>事件之后，所有的视图查询都被解决了。</p>
<p>您可以查看这些<a href="https://stackblitz.com/edit/view-child-examples" target="_blank" rel="noopener noreferrer">活生生的例子</a>，它们更好地说明了如何通过<code>@ViewChild</code>装饰器使用<code>read</code>和<code>static</code>属性。</p>
<h2>视图儿童</h2>
<p><code>@ViewChildren</code>装饰器的工作方式类似于<code>@ViewChild</code>装饰器，但是它不是配置单个视图查询，而是获取一个查询列表。从组件视图DOM中，它检索子元素的<code><a href="https://angular.io/api/core/QueryList" target="_blank" rel="noopener noreferrer">QueryList</a></code>。当对子元素进行任何更改时，该列表会更新。<code>@ViewChildren</code>装饰器获取两个属性，一个<code>selector</code>和一个<code>read</code>属性。这些属性的工作方式与<code>@ViewChild</code>装饰器相同。任何匹配的子元素都将成为列表的一部分。这里有一个例子:</p>
<pre>@Component({
  selector: 'item-label',
  template: `&lt;h6&gt;{{labelText}}&lt;/h6&gt;`
})

export class ItemLabelComponent{
  @Input() labelText: string;
}

@Component({
  selector: 'item',
  template: `&lt;item-label *ngFor="let label of labels" [labelText]="label"&gt;&lt;/item-label&gt;`
})

export class ItemComponent{
  @ViewChildren(ItemLabelComponent) allLabels: ItemLabelComponent;

  labels = ['recent', 'popular', 'new'];
}</pre>
<p>由于所有的<code>&lt;item-label&gt;</code>都将被选择，因此<code>allLabels</code>的长度将为三。<code>QueryList</code>有许多<a href="https://angular.io/api/core/QueryList" target="_blank" rel="noopener noreferrer">方法</a>，您可以使用它们来操作视图查询。</p>
<p>对于如何使用<code>@ViewChildren</code>装饰器和指定<code>read</code>属性的更广泛的说明，请查看<a href="https://stackblitz.com/edit/view-child-examples" target="_blank" rel="noopener noreferrer">这个例子</a>。</p>
<h2>结论</h2>
<p><code>@ViewChild</code>和<code>@ViewChildren</code>装饰器是查询视图中子元素的优秀工具。了解如何使用它们可以为您提供更多自定义组件视图的选项。如果你想了解更多关于如何使用它们，请查看<a href="https://stackblitz.com/edit/view-child-examples?file=src/app/app.component.ts" target="_blank" rel="noopener noreferrer">这些例子</a>。</p><div class="code-block code-block-19">
<div class="blog-plug inline-plug angular-plug"><h2>像用户一样体验Angular应用程序</h2><p>调试Angular应用程序可能很困难，尤其是当用户遇到难以重现的问题时。如果您对监控和跟踪生产中所有用户的角度状态和动作感兴趣，</p><a href="https://lp.logrocket.com/blg/angular-signup">try LogRocket</a><p>. </p><a class="signup" href="https://lp.logrocket.com/blg/angular-signup" target="_blank" rel="noopener noreferrer"><img class="alignnone size-full wp-image-46 jetpack-lazy-image" src="../Images/2794ac39244976f37c4941d9a910be23.png" alt="LogRocket Dashboard Free Trial Banner" data-lazy-src="https://files.readme.io/610d6a7-687474703a2f2f692e696d6775722e636f6d2f696147547837412e706e67.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://files.readme.io/610d6a7-687474703a2f2f692e696d6775722e636f6d2f696147547837412e706e67.png"/><noscript><img data-lazy-fallback="1" class="alignnone size-full wp-image-46" src="../Images/2794ac39244976f37c4941d9a910be23.png" alt="LogRocket Dashboard Free Trial Banner" data-original-src="https://files.readme.io/610d6a7-687474703a2f2f692e696d6775722e636f6d2f696147547837412e706e67.png"/></noscript></a><a href="https://lp.logrocket.com/blg/angular-signup" target="_blank" rel="noopener noreferrer">https://logrocket.com/signup/</a><p>LogRocket 就像是网络和移动应用程序的DVR，记录你网站上发生的一切，包括网络请求、JavaScript错误等等。您可以汇总并报告问题发生时应用程序的状态，而不是猜测问题发生的原因。</p><p>LogRocket NgRx插件将角度状态和动作记录到LogRocket控制台，为您提供导致错误的环境，以及出现问题时应用程序的状态。</p><p>现代化调试Angular应用的方式- <a class="signup" href="https://lp.logrocket.com/blg/angular-signup" target="_blank" rel="noopener noreferrer">开始免费监控</a>。</p></div>
</div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
<html>
<head>
<title>const assertions are the killer new TypeScript feature - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>const断言是杀手级的新类型脚本特性</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/const-assertions-are-the-killer-new-typescript-feature-b73451f35802/#0001-01-01">https://blog.logrocket.com/const-assertions-are-the-killer-new-typescript-feature-b73451f35802/#0001-01-01</a></blockquote><div><article class="article-post">
<p>Typescript 3.4已经发布，虽然我发现官方的Typescript文档信息量很大，但它们总感觉有点太学术性，有点枯燥。当我发现新功能时，我想知道该功能将治愈的确切疾病。</p>
<p>在我看来，<code>const assertions</code>是TypeScript 3.4的杀手级新特性，正如我将在后面解释的那样，使用这个新特性，我可以省略许多繁琐的类型声明。</p>
<h3>常量断言</h3>
<pre><code>const x = { text: "hello" } as const;</code></pre>
<p><a class="markup--anchor markup--p-anchor" href="https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-4.html" target="_blank" rel="noopener noreferrer" data-href="https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-4.html">官方文件</a>给出这样的解释:</p>
<blockquote><p>TypeScript 3.4为文字值引入了一个新的构造，称为const断言。它的语法是用const代替类型名的类型断言(例如123作为const)。当我们用常量断言构造新的文字表达式时，我们可以向语言发出信号</p></blockquote>
<ul>
<li><blockquote> <p>该表达式中的文字类型不应被加宽(例如，不能从“hello”到字符串)</p> </blockquote></li>
<li><blockquote> <p>对象文字量获取<code>readonly</code>属性</p> </blockquote></li>
<li><blockquote> <p>数组文字量变成<code>readonly</code>元组</p> </blockquote></li>
</ul>
<p>这感觉有点干涩，有点混乱。让我们一次分解一个要点。</p>
<p><a href="https://logrocket.com/signup/"> <img decoding="async" class="progressiveMedia-image js-progressiveMedia-image jetpack-lazy-image" src="../Images/37fb366b01f8ba4b23129468d1953129.png" data-src="https://cdn-images-1.medium.com/max/2400/1*GPjaPKNNUYHU8EsA3Z0JGA.png" data-lazy-src="https://cdn-images-1.medium.com/max/2400/1*GPjaPKNNUYHU8EsA3Z0JGA.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://cdn-images-1.medium.com/max/2400/1*GPjaPKNNUYHU8EsA3Z0JGA.png"/> <noscript> <img data-lazy-fallback="1" decoding="async" class="progressiveMedia-image js-progressiveMedia-image" src="../Images/37fb366b01f8ba4b23129468d1953129.png" data-src="https://cdn-images-1.medium.com/max/2400/1*GPjaPKNNUYHU8EsA3Z0JGA.png" data-original-src="https://cdn-images-1.medium.com/max/2400/1*GPjaPKNNUYHU8EsA3Z0JGA.png"/> </noscript></a></p>
<h3>文字类型没有类型扩展</h3>
<p>并不是每个人都知道什么是类型加宽，由于一些意想不到的行为，当它第一次被发现时，人们感到非常惊讶。</p>
<p>当我们使用关键字<code>const</code>声明一个文字变量时，类型就是等号右边的文字，例如:</p>
<p><code>const x = 'x'; // x has the type 'x'</code></p>
<p>关键字<code>const</code>确保不会发生对变量的重新赋值，并且只保证该文字的严格类型。</p>
<p>但是如果我们使用<code>let</code>而不是<code>const</code>,那么我们就让这个变量可以重新赋值，并且类型被扩展为字面量的类型，如下所示:</p>
<pre>let x = 'x'; // x has the type string;</pre>
<p>以下是两种不同的声明:</p>
<pre>const x = 'x'; // has the type 'x' 
let y = 'x';   // has the type string</pre>
<p><code>y</code>被扩展为更通用的类型，这将允许它被重新分配给该类型的其他值，并且<code>x</code>只能有<code>'x'</code>的值。</p>
<p>有了新的<code>const</code>功能，我可以这样做:</p>
<pre>let y = 'x' as const; // y has type 'x'</pre>
<p>如果我这样做，而不是简单地将<code>y</code>声明为一个<code>const</code>变量，我可能会在任何好的代码评审中被扫地出门，但是让我们快速地转到文档中的第二点:</p>
<h3>对象文字获取只读属性</h3>
<p>在Typescript 3.4之前，对象文本的类型扩展是全面的:</p>
<pre>const action = { type: 'INCREMENT', } // has type { type: string }</pre>
<p>尽管我们已经将<code>action</code>声明为<code>const</code>，但是<code>type</code>属性仍然可以被重新分配，因此，该属性被扩展为字符串类型。</p>
<p>这仍然不觉得有用，所以让我们用一个更好的例子。</p>
<p>如果你熟悉<a class="markup--anchor markup--p-anchor" href="https://redux.js.org/" target="_blank" rel="noopener noreferrer" data-href="https://redux.js.org/"> Redux </a>，那么你可能会意识到上面的<code>action</code>变量可以用作Redux动作。对于那些不知道的人来说，Redux是一个全局不可变的状态存储。通过向所谓的<code>reducers</code>发送动作来修改状态。Reducers是纯粹的函数，它在每个动作被调度后返回全局状态的新的更新版本，反映了动作中指定的修改。</p>
<p>在Redux中，标准做法是从名为<a class="markup--anchor markup--p-anchor" href="https://read.reduxbook.com/markdown/part1/04-action-creators.html" target="_blank" rel="noopener noreferrer" data-href="https://read.reduxbook.com/markdown/part1/04-action-creators.html"> action creators </a>的函数中创建您的动作。动作创建器是简单的纯函数，它返回Redux动作对象文字以及提供给函数的任何参数。</p>
<p>这可以用一个例子来更好地说明。一个应用程序可能需要一个全局<code>count</code>属性，为了更新这个<code>count</code>属性，我们可以调度<code>SET_COUNT</code>类型的动作，简单地将全局<code>count</code>属性设置为一个新值，这个新值是一个文字对象属性。该动作的动作创建者将是一个函数，该函数将一个数字作为参数，并返回一个具有<code>SET_COUNT</code>的<code>type</code>属性和<code>number</code>类型的有效负载属性的对象，该属性将指定<code>count</code>的新值是什么:</p>
<pre>const setCount = (n: number) =&gt; {
  return {
    type: 'SET_COUNT',
    payload: n,
  }
}

const action = setCount(3)
// action has type
// { type: string, payload: number }</pre>
<p>从上面显示的代码中可以看出，<code>type</code>属性被扩展为<code>string</code>而不是<code>SET_COUNT</code>。这不是非常安全的类型，我们所能保证的是<code>type</code>属性是一个字符串。redux中的每个动作都有一个<code>type</code>属性，是一个字符串。</p>
<p>这不是很好，如果我们想要利用在类型属性上变窄的<a class="markup--anchor markup--p-anchor" href="https://basarat.gitbooks.io/typescript/docs/types/discriminated-unions.html" target="_blank" rel="noopener noreferrer" data-href="https://basarat.gitbooks.io/typescript/docs/types/discriminated-unions.html">区别联合</a>，那么在TypeScript 3.4之前，我们需要为每个动作声明一个接口或类型:</p>
<pre>interface SetCount {
  type: 'SET_COUNT';
  payload: number;
}

const setCount = (n: number): SetCount =&gt; {
  return {
    type: 'SET_COUNT',
    payload: n,
  }
}

const action = setCount(3)
// action has type SetCount</pre>
<p>这确实增加了编写Redux动作和reducers的负担，但是我们可以通过添加一个<code>const assertion</code>来解决这个问题:</p>
<pre>const setCount = (n: number) =&gt; {
  return &lt;const&gt;{
    type: 'SET_COUNT',
    payload: n
  }
}

const action = setCount(3);
// action has type
//  { readonly type: "SET_COUNT"; readonly payload: number };</pre>
<p>观察力敏锐的您会注意到，从<code>setCount</code>推断出的类型已经将<code>readonly</code>修饰符附加到每个属性上，正如文档中的要点所述。</p>
<p>这正是所发生的情况:</p>
<pre>{
  readonly type: "SET_COUNT";
  readonly payload: number
};</pre>
<p>动作中的每个文字都添加了<code>readonly</code>修饰符。</p>
<p>在redux中，我们建立了一个允许动作的联合，reducer函数可以采取该联合来获得良好的类型安全，我们将围绕该联合调度动作。在TypeScript 3.4之前，我们会这样做:</p>
<pre>interface SetCount {
  type: 'SET_COUNT';
  payload: number;
}

interface ResetCount {
  type: 'RESET_COUNT';
}

const setCount = (n: number): SetCount =&gt; {
  return {
    type: 'SET_COUNT',
    payload: n,
  }
}

const resetCount = (): ResetCount =&gt; {
  return {
    type: 'RESET_COUNT',
  }
}

type CountActions = SetCount | ResetCount</pre>
<p>我们创建了两个接口<code>RESET_COUNT</code>和<code>SET_COUNT</code>来键入两个动作创建者<code>resetCount</code>和<code>setCount</code>的返回类型。</p>
<p><code>CountActions</code>是这两个接口的联合。</p>
<p>有了<code>const assertions</code>，我们可以通过使用<code>const</code>、<a class="markup--anchor markup--p-anchor" href="https://dev.to/busypeoples/notes-on-typescript-returntype-3m5a" target="_blank" rel="noopener noreferrer" data-href="https://dev.to/busypeoples/notes-on-typescript-returntype-3m5a">、ReturnType </a>和<code>typeof</code>的组合来消除声明所有这些接口的需要:</p>
<pre>const setCount = (n: number) =&gt; {
  return &lt;const&gt;{
    type: 'SET_COUNT',
    payload: n
  }
}

const resetCount = () =&gt; {
  return &lt;const&gt;{
    type: 'RESET_COUNT'
  }
}

type CountActions = ReturnType&lt;typeof setCount&gt; | ReturnType&lt;typeof resetCount&gt;;</pre>
<p>我们有一个从动作创建函数<code>setCount</code>和<code>resetCount</code>的返回类型推断出的动作的很好的联合。</p>
<h3>数组文字变成了<code>readonly</code>元组</h3>
<p>在TypeScript 3.4之前，声明文字数组将被加宽，并对修改开放。</p>
<p>使用<code>const</code>，我们可以将文字锁定为它们的显式值，也不允许修改。</p>
<p>如果我们有一个redux操作类型来设置一个小时数组，它可能看起来像这样:</p>
<pre>const action = {
  type: 'SET_HOURS',
  payload: [8, 12, 5, 8],
}
//  { type: string; payload: number[]; }

action.payload.push(12) // no error</pre>
<p>在TypeScript 3.4之前，加宽使上述操作的文字属性更加通用，因为它们可以修改。</p>
<p>如果我们将<code>const</code>应用于对象文字，那么我们就很好地收紧了一切:</p>
<pre>&gt;const action = &lt;const&gt;{
  type: 'SET_HOURS',
  payload: [8, 12, 5, 8]
}

// {
//  readonly type: "SET_HOURS";
//  readonly payload: readonly [8, 12, 5, 8];
// }

action.payload.push(12);  // error - Property 'push' does not exist on type 'readonly [8, 12, 5, 8]'.</pre>
<p>这里所发生的正是文档中的要点所陈述的:有效载荷数字数组确实是一个[8，12，5，8]的<code>readonly</code>元组(但是我肯定不是从阅读文档中得到这个的)。</p>
<h3>结论</h3>
<p>我可以用这个代码示例总结以上所有内容:</p>
<pre>let obj = {
  x: 10,
  y: [20, 30],
  z: {
    a:
      {  b: 42 }
  } 
} as const;</pre>
<p>对应于:</p>
<pre>let obj: {
  readonly x: 10;
  readonly y: readonly [20, 30];
  readonly z: {
    readonly a: {
      readonly b: 42;
    };
  };
};</pre>
<p>在这里，我可以推断类型，而不是编写多余的样板类型。这对于redux特别有用，在redux中，有区别的联合用于缩小对象文字表达式的类型。</p><div class="code-block code-block-21">
<div class="blog-plug inline-plug typescript-plug"><h2><a class="signup" href="https://lp.logrocket.com/blg/typescript-signup" target="_blank" rel="noopener noreferrer"> LogRocket </a>:全面了解您的网络和移动应用</h2>
<a href="https://lp.logrocket.com/blg/typescript-signup" class="signup" target="_blank" rel="noopener noreferrer"><img class="alignnone size-full wp-image-46 jetpack-lazy-image" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/><noscript><img data-lazy-fallback="1" class="alignnone size-full wp-image-46" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/></noscript></a>
<p>LogRocket 是一个前端应用程序监控解决方案，可以让您回放问题，就像问题发生在您自己的浏览器中一样。LogRocket不需要猜测错误发生的原因，也不需要向用户询问截图和日志转储，而是让您重放会话以快速了解哪里出错了。它可以与任何应用程序完美配合，不管是什么框架，并且有插件可以记录来自Redux、Vuex和@ngrx/store的额外上下文。</p>
<p>除了记录Redux操作和状态，LogRocket还记录控制台日志、JavaScript错误、堆栈跟踪、带有头+正文的网络请求/响应、浏览器元数据和自定义日志。它还使用DOM来记录页面上的HTML和CSS，甚至为最复杂的单页面和移动应用程序重新创建像素级完美视频。</p>
<a class="signup" href="https://lp.logrocket.com/blg/typescript-signup" target="_blank" rel="noopener noreferrer">Try it for free</a><p>.</p></div>
</div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
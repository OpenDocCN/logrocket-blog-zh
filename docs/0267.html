<html>
<head>
<title>Tools and modern workflow for front-end developers - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>面向前端开发人员的工具和现代工作流- LogRocket博客</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/tools-and-modern-workflow-for-front-end-developers-505c7227e917/#0001-01-01">https://blog.logrocket.com/tools-and-modern-workflow-for-front-end-developers-505c7227e917/#0001-01-01</a></blockquote><div><article class="article-post">
<figure class="graf graf--figure"><img decoding="async" class="graf-image jetpack-lazy-image" src="../Images/a9ef45674371172ca4292367279858c0.png" data-image-id="1*46ZYJlxQyLlBcvOHJyhD8w.png" data-width="1240" data-height="700" data-is-featured="true" data-lazy-src="https://cdn-images-1.medium.com/max/1600/1*46ZYJlxQyLlBcvOHJyhD8w.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://cdn-images-1.medium.com/max/1600/1*46ZYJlxQyLlBcvOHJyhD8w.png"/><noscript><img data-lazy-fallback="1" decoding="async" class="graf-image" src="../Images/a9ef45674371172ca4292367279858c0.png" data-image-id="1*46ZYJlxQyLlBcvOHJyhD8w.png" data-width="1240" data-height="700" data-is-featured="true" data-original-src="https://cdn-images-1.medium.com/max/1600/1*46ZYJlxQyLlBcvOHJyhD8w.png"/></noscript></figure>
<p class="graf graf--p">最近出现了不同的工具和工作流，以使前端开发过程更容易——其中一种工具被称为<code>build tool</code>。在本教程中，我们将探索什么是构建工具以及如何使用它们。我们会看看NPM脚本，咕噜，吞咽和网络包。我们还将讨论如何根据您的项目需求选择要使用的构建工具。</p>
<figure class="graf graf--figure graf--layoutOutsetCenter"><a class="graf-imageAnchor" href="https://logrocket.com/signup/" target="_blank" rel="noopener noreferrer" data-href="https://logrocket.com/signup/" data-action="image-link" data-action-observe-only="true"><img decoding="async" class="graf-image jetpack-lazy-image" src="../Images/37fb366b01f8ba4b23129468d1953129.png" data-image-id="1*GPjaPKNNUYHU8EsA3Z0JGA.png" data-width="3212" data-height="750" data-lazy-src="https://cdn-images-1.medium.com/max/2400/1*GPjaPKNNUYHU8EsA3Z0JGA.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://cdn-images-1.medium.com/max/2400/1*GPjaPKNNUYHU8EsA3Z0JGA.png"/><noscript><img data-lazy-fallback="1" decoding="async" class="graf-image" src="../Images/37fb366b01f8ba4b23129468d1953129.png" data-image-id="1*GPjaPKNNUYHU8EsA3Z0JGA.png" data-width="3212" data-height="750" data-original-src="https://cdn-images-1.medium.com/max/2400/1*GPjaPKNNUYHU8EsA3Z0JGA.png"/></noscript></a></figure>
<h3 class="graf graf--h3">先决条件</h3>
<p class="graf graf--p">大多数构建工具都构建在<code>NODE and NPM</code>之上。在本教程中，NPM T2的基本知识是假定的，但不是必需的，因为我们也将介绍NPM。本教程确实需要关于<strong class="markup--strong markup--p-strong"> HTML </strong>、<strong class="markup--strong markup--p-strong"> CSS </strong>和<strong class="markup--strong markup--p-strong"> JavaScript </strong>的基础知识。</p>
<h3 class="graf graf--h3">NPM</h3>
<p class="graf graf--p"><strong class="markup--strong markup--p-strong"> NPM </strong>(节点包管理器)是一个预装Node.js的JavaScript包管理器，即使使用它不需要Node.js技能。NPM的主要功能是运行一个简单的任务，比如浏览器同步，从你的<code>package.json</code>文件中动态加载库和样式表。NPM安装了一个<code>node_modules</code>文件夹，这样你就可以从不同的安装包中运行更多的命令。任何本机CLI任务都可以使用正确的对象在脚本中完成。让我们看一些例子。</p>
<h3 class="graf graf--h3">使用</h3>
<p class="graf graf--p">默认情况下，<code>NPM</code>预装了<code>NODE</code>。所以不需要安装不同的。要使用<code>npm scripts</code>，你所要做的就是初始化它。创建一个名为<code>npm_test</code>的新文件夹，然后初始化NPM来创建一个<code>package.json</code>文件。在您的终端中键入<code>npm init</code>，然后按照提示进行操作。完成后，您应该会在项目文件夹中看到一个<code>package.json</code>文件。该文件应该如下所示:</p>
<pre>{
      "name": "npm_tests",
      "version": "1.0.0",
      "description": "",
      "main": "index.js",
      "scripts": {
        "test": "echo \"Error: no test specified\" &amp;&amp; exit 1"
      },
      "author": "",
      "license": "ISC"
    }</pre>
<p class="graf graf--p">如您所见，<code>index.js</code>被定义为主脚本，也就是我们应用程序的入口点。我们需要创建该文件，并告诉NPM如何启动我们的应用程序。首先，创建一个名为<code>index.js</code>的空白文件，然后更新<code>package.json</code>文件中的<code>scripts</code>对象，如下所示:</p>
<pre>"scripts": {
        "start": "node index.js"
     },</pre>
<p class="graf graf--p">这告诉node，每当我们在终端中键入命令<code>npm start</code>时，它应该启动<code>index.js</code>文件。在您的<code>index.js</code>文件中，让我们放一个简单的日志消息。添加以下代码:</p>
<pre>console.log('This is index.js')</pre>
<p class="graf graf--p">现在，在您的终端中键入<code>npm start</code>，您应该会看到以下输出:</p>
<pre>$ npm start
    &gt; <a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="4a243a27153e2f393e390a7b647a647a">[email protected]</a> start /home/user/frontend/npm_tests
    &gt; This is index.js</pre>
<p class="graf graf--p">虽然这个例子不太可靠。稍后，当我们讨论其他构建工具时，我们将看到如何使用<code>npm scripts</code>来执行其他有用的命令，如安装依赖项、测试等。</p>
<h3 class="graf graf--h3">故事</h3>
<p class="graf graf--p">Yarn (Yarn Package Manager)是脸书创建的另一个JavaScript包管理器。随着时间的推移，它被认为是一个更快和更可靠的替代NPM，因为他们有类似的语法和功能。Yarn也安装来自<code>NPM Registry</code>的包，所以任何<code>NPM Package</code>也可以安装Yarn。Yarn对管理包有不同的理念。让我们来看看其中的一些。</p>
<h3 class="graf graf--h3">使用</h3>
<p class="graf graf--p">纱线和NPM的功能基本相同。虽然它们的功能相似，但它们的语法不同。要了解如何安装和使用纱线，请遵循第<a class="markup--anchor markup--p-anchor" href="https://yarnpkg.com/lang/en/docs/install/#debian-stable" target="_blank" rel="noopener noreferrer" data-href="https://yarnpkg.com/lang/en/docs/install/#debian-stable">页</a>的说明。</p>
<p class="graf graf--p"><strong class="markup--strong markup--p-strong"> NPM还是纱？</strong>许多人认为(并且测试已经证明)<code>Yarn</code>比<code>npm</code>更快，然而，大多数人仍然使用<code>npm</code>,我们将讨论的大多数构建工具默认支持<code>npm</code>。然而，选择要使用的工具主要是开发人员和项目需求的功能。请务必选择最适合您项目需求的工具。</p>
<h3 class="graf graf--h3">咕哝</h3>
<p class="graf graf--p">Grunt是一个构建在<strong class="markup--strong markup--p-strong">节点之上的JavaScript任务运行器。Js和NPM </strong>。它的主要功能是优化并帮助您减少项目中的所有重复性任务，如加载JavaScript资源、样式表、林挺和调试。因为<code>GRUNT</code>是建立在<code>NPM</code>之上的，所以它是用一个<code>package.json</code>文件初始化的，但是任务是在一个<code>Grunt.js</code>文件中定义的。</p>
<p class="graf graf--p"><strong class="markup--strong markup--p-strong">N/B:</strong><code>**'G'**</code><strong class="markup--strong markup--p-strong"/><code>**Grunt.js**</code><strong class="markup--strong markup--p-strong">中必须大写。</strong>让我们看看如何利用它来促进我们的发展:</p>
<h3 class="graf graf--h3">使用</h3>
<p class="graf graf--p">要使用grunt，我们首先需要安装它。在你的终端输入<code>npm install -g grunt</code>。这将在你的机器上全局安装<strong class="markup--strong markup--p-strong"> grunt </strong>。接下来，创建一个名为<code>grunt_test</code>的文件夹，并初始化一个<code>package.json</code>文件。在您的终端中键入<code>npm init</code>并按照提示创建文件。现在你的<code>package.json</code>文件应该是这样的:</p>
<pre>{
      "name": "grunt_test",
      "version": "1.0.0",
      "description": "",
      "main": "app.js",
      "scripts": {
        "test": "echo \"Error: no test specified\" &amp;&amp; exit 1"
      },
      "author": "",
      "license": "ISC"
    }</pre>
<p class="graf graf--p">接下来，我们需要安装Grunt作为一个依赖项。在你的终端输入<code>npm install --save grunt</code>。该命令会将grunt安装为一个依赖项，您的<code>package.json</code>文件现在将如下所示:</p>
<pre>{
      "name": "grunt_test",
      "version": "1.0.0",
      "description": "",
      "main": "index.js",
      "scripts": {
        "test": "echo \"Error: no test specified\" &amp;&amp; exit 1"
      },
      "author": "",
      "license": "ISC",
      "dependencies": {
        "grunt": "^1.0.3"
      }
    }</pre>
<p class="graf graf--p">既然<code>grunt</code>安装好了，那就用吧。创建一个空的<code>gruntfile.js</code>文件。为了使用这个文件，我们需要设定一个目标，假设我们有几个包含代码的文件，我们想把它们编译成一个。为此，我们需要使用插件(插件是为工具增加额外功能的代码片段)。为了实现我们的目标，我们将使用一个名为<code>grunt-contrib-concat</code>的插件。要安装插件，请在您的终端中键入以下内容:</p>
<pre>npm install grunt-contrib-concat --save-dev</pre>
<p class="graf graf--p">现在让我们付诸行动。创建一个名为<code>js</code>的文件夹，然后创建两个文件<code>main1.js</code>和<code>main2.js</code>，并添加以下代码:</p>
<pre>/** this is main1.js **/</pre>
<p class="graf graf--p">对<code>main2.js</code>做同样的操作。现在，在您的<code>gruntfile.js</code>文件中添加以下代码行:</p>
<pre>module.exports = function(grunt){
    
      grunt.initConfig({
       concat: {
        dist: {
          src: ['js/main1.js', 'js/main2.js'],
          dest: 'dist/js/built.js',
         },
        },
      });
    
      grunt.loadNpmTasks('grunt-contrib-concat');
    };</pre>
<p class="graf graf--p">该任务指示grunt将文件从<code>main1.js</code>和<code>main2.js</code>复制到名为<code>dist/built.js</code>的文件夹/文件中。虽然这个文件还没有创建，但是<code>grunt</code>会自动为我们创建它。在你的终端键入<code>grunt concat</code>:</p>
<pre>$ grunt concat
    Running "concat:dist" (concat) task
    Done</pre>
<p class="graf graf--p">现在，您将看到一个新文件夹已经创建完毕<code>dist/built.js</code>:</p>
<pre>/** this is main one */
    /** this is main two */</pre>
<p class="graf graf--p">这表明它将两个文件的内容加在了一起。当你有很多JavaScript风格时，这是非常强大的，它将通过把所有代码编译成一个文件来帮助优化你的网站。grunt还有很多其他的功能和用途，你可以在这里找到它们<a class="markup--anchor markup--p-anchor" href="https://gruntjs.com/plugins" target="_blank" rel="noopener noreferrer" data-href="https://gruntjs.com/plugins">。</a></p>
<h3 class="graf graf--h3">吞咽</h3>
<p class="graf graf--p">Gulp.js是构建在Node.js和NPM之上的另一个JavaScript任务运行器。它的主要功能是帮助您减少项目中所有重复的任务。Gulp是一个前端构建系统，所以不管使用什么前端技术(Vue、React或Angular ),它仍然可以以最佳方式工作和执行。它也由一个<code>package.json</code>文件管理，并内置了对各种插件的支持，这些插件有助于执行各种任务。</p>
<h3 class="graf graf--h3">使用</h3>
<p class="graf graf--p">Gulp构建在<code>node strings</code>之上，以<code>pipelines</code>的形式处理数据。创建一个名为<code>gulp_test</code>的文件夹，初始化一个<strong class="markup--strong markup--p-strong"> package.json </strong>文件。在您的终端中键入<code>npm init</code>并按照提示初始化文件。您的<strong class="markup--strong markup--p-strong"> package.json </strong>现在看起来像这样:</p>
<pre>{
      "name": "gulp_test",
      "version": "1.0.0",
      "description": "",
      "main": "index.js",
      "scripts": {
        "test": "echo \"Error: no test specified\" &amp;&amp; exit 1"
      },
      "author": "",
      "license": "ISC"
    }</pre>
<p class="graf graf--p">要使用<code>gulp</code>，我们必须将其作为项目依赖项安装。在你的终端输入<code>npm install --save-dev gulp</code>。这将把它保存为一个项目依赖，你的<code>package.json</code>文件将会是这样的:</p>
<pre>{
      "name": "gulp_test",
      "version": "1.0.0",
      "description": "",
      "main": "index.js",
      "scripts": {
        "test": "echo \"Error: no test specified\" &amp;&amp; exit 1"
      },
      "author": "",
      "license": "ISC",
      "devDependencies": {
        "gulp": "^4.0.0"
      }
    }</pre>
<p class="graf graf--p">为了创建任务，我们必须创建一个名为<code>gulpfile.js</code>的文件，并向其中添加代码。<strong class="markup--strong markup--p-strong">大口</strong>有四个顶级功能:</p>
<ul class="postList">
<li class="graf graf--li"><strong class="markup--strong markup--li-strong"> gulp.task </strong> —设置运行gulp的任务</li>
<li class="graf graf--li"><strong class="markup--strong markup--li-strong"> gulp.src </strong> —告诉gulp要使用的文件</li>
<li class="graf graf--li"><strong class="markup--strong markup--li-strong"> gulp.dest </strong> —告诉gulp输出文件的位置</li>
<li class="graf graf--li"><strong class="markup--strong markup--li-strong"> gulp.watch </strong> —告诉gulp注意更新</li>
</ul>
<p class="graf graf--p">让我们创建虚拟HTML。首先，创建一个<code>src</code>文件夹，并将这两个文件添加到其中。<code>index.html</code>和<code>test.html</code>然后向其中添加以下代码:</p>
<pre>&lt;html&gt;
        &lt;head&gt;
            &lt;title&gt;Gulp Test&lt;/title&gt;
        &lt;/head&gt;
        &lt;body&gt;
            &lt;h2&gt;This is for a test&lt;/h2&gt;
        &lt;/body&gt;
    &lt;/html&gt;</pre>
<p class="graf graf--p">我们来设定一些任务。在您的<strong class="markup--strong markup--p-strong"> gulp.js </strong>文件中添加以下代码行:</p>
<pre>const gulp = require('gulp');
    
    gulp.task('compileHtml', function(done){
      gulp.src('src/*.html')
      .pipe(gulp.dest('build'));
      done();
    });</pre>
<p class="graf graf--p">这个命令告诉gulp将所有文件从<code>src</code>目录复制到一个构建目录。我们创建了一个函数<code>compileHtml</code>，当我们想要运行我们的任务时，我们将参考这个函数。在你的终端键入<code>gulp compileHTml</code>。现在可以看到已经创建了一个<code>build</code>文件夹，其中包含文件。接下来，让我们使用一个<code>gulp</code>插件来缩小我们的Javascript。首先，我们需要安装插件。要查看<code>gulp</code>插件列表，请点击查看<a class="markup--anchor markup--p-anchor" href="https://gulpjs.com/plugins/" target="_blank" rel="noopener noreferrer" data-href="https://gulpjs.com/plugins/">。</a></p>
<p class="graf graf--p">首先，让我们创建一个名为<code>js</code>的文件夹，并在其中创建一个测试文件<code>test.js</code>。接下来，我们需要安装一个名为<code>uglify</code>的插件来帮助我们缩小文件。在终端键入<code>npm install --save-dev gulp-uglify</code>。这将把它作为一个依赖项安装在我们的项目中。现在在你的<code>gulpfile.js</code>中更新代码为:</p>
<pre>const gulp = require('gulp');
    const uglify = require('gulp-uglify');
    
    
    gulp.task('compileHtml', function(done){
      gulp.src('src/*.html')
      .pipe(gulp.dest('build'));
      done();
    });
    
    gulp.task('minify', function(done){
      gulp.src('src/js/*.html')
      .pipe(uglify())
      .pipe(gulp.dest('build/js'));
      done();
    });</pre>
<h3 class="graf graf--h3">网络包</h3>
<p class="graf graf--p">Webpack是一个前端构建工具。更准确地说，它被定义为一个<code>Module Bundler</code>。Webpack的功能不仅仅是将不同的模块转换成静态资产。Webpack使捆绑代码、将所有旧的<strong class="markup--strong markup--p-strong"> JS </strong>代码转换成<strong class="markup--strong markup--p-strong"> ES6 </strong>、加载开发依赖、运行自动化任务和管理项目变得容易。使用Webpack，您可以加载自定义文件或由<code>NPM</code>安装的文件。Webpack的基本功能可以通过使用<code>plugins and loaders</code> <code>css</code> <code>sass</code> <code>jsx</code> <code>CoffeeScript</code>扩展为更复杂的功能，这些都是常见的Webpack加载器的例子。</p>
<h3 class="graf graf--h3">使用</h3>
<p class="graf graf--p">要使用Webpack，我们必须先安装它。我们可以通过终端输入<code>npm install -g Webpack</code>来安装。此命令将在您的计算机上全局安装Webpack。接下来，让我们创建一个文件夹来使用。创建一个文件夹<code>webpacktest</code>并初始化一个<code>package.json</code>文件。在您的终端中键入<code>npm init</code>并按照提示创建文件。现在<strong class="markup--strong markup--p-strong"> package.json </strong>文件应该是这样的:</p>
<pre>{
      "name": "webpacktest",
      "version": "1.0.0",
      "description": "",
      "main": "app.js",
      "scripts": {
        "test": "echo \"Error: no test specified\" &amp;&amp; exit 1"
      },
      "author": "",
      "license": "ISC"
    }</pre>
<p class="graf graf--p">现在我们有了它的设置，让我们做一些事情。假设我们想在我们的新项目中使用<code>JQuery</code>库，我们可以这样做。首先，我们需要安装<code>JQuery</code>。在你的终端键入<code>npm install --save jquery</code>。如果这是成功的，您的<code>package.json</code>文件将看起来像这样:</p>
<pre>{
      "name": "webpacktest",
      "version": "1.0.0",
      "description": "",
      "main": "app.js",
      "scripts": {
        "test": "echo \"Error: no test specified\" &amp;&amp; exit 1"
      },
      "author": "",
      "license": "ISC",
      "dependencies": {
        "jquery": "^3.3.1"
      }
    }</pre>
<p class="graf graf--p">您可以看到<code>JQuery</code>已经作为一个依赖项被安装。现在，为了使用它，我们需要创建文件。首先，让我们创建一个将加载到浏览器中的HTML文件。创建一个<code>index.html</code>文件，并向其中添加以下代码行:</p>
<pre>&lt;html&gt;
        &lt;head&gt;
            &lt;title&gt;WebPack Test&lt;/title&gt;
        &lt;/head&gt;
        &lt;body&gt;
    
            &lt;script src="bundle.js"&gt;&lt;/script&gt;
        &lt;/body&gt;
    &lt;/html&gt;</pre>
<p class="graf graf--p">你可以看到我们调用了一个名为<code>bundle.js</code>的文件，尽管它还没有被创建。当我们运行我们的<code>Webpack</code>命令时，<strong class="markup--strong markup--p-strong"> Webpack </strong>会自动将我们告诉它的所有代码编译到那个文件中。现在创建一个<code>app.js</code>文件，并添加以下代码行:</p>
<pre>let $ = require('jquery');
    
     $('body').append("&lt;h1&gt;Hey there! This is JQUERY&lt;/h1&gt;");</pre>
<p class="graf graf--p">这里我们在项目中需要<code>JQuery</code>，然后我们使用<code>append</code> JQuery函数将数据添加到页面中。要查看这个，输入<code>webpack --mode=development app.js -o bundle.js</code>。完成后，在浏览器中打开您的<strong class="markup--strong markup--p-strong">index.html</strong>文件，您将看到以下内容:</p>
<figure class="graf graf--figure"><img decoding="async" class="graf-image jetpack-lazy-image" src="../Images/24be8f187a0f7483f04188837d6c09d2.png" data-image-id="0*XNC3cTL8qCaGnFBa.png" data-width="688" data-height="79" data-lazy-src="https://cdn-images-1.medium.com/max/1600/0*XNC3cTL8qCaGnFBa.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://cdn-images-1.medium.com/max/1600/0*XNC3cTL8qCaGnFBa.png"/><noscript><img data-lazy-fallback="1" decoding="async" class="graf-image" src="../Images/24be8f187a0f7483f04188837d6c09d2.png" data-image-id="0*XNC3cTL8qCaGnFBa.png" data-width="688" data-height="79" data-original-src="https://cdn-images-1.medium.com/max/1600/0*XNC3cTL8qCaGnFBa.png"/></noscript></figure>
<p class="graf graf--p">这意味着Webpack成功捆绑了代码，导入了<code>JQuery</code>库供我们使用。你已经可以看到这是多么的有益，就好像我们必须导入十个依赖关系一样<strong class="markup--strong markup--p-strong"> Webpack </strong>让我们可以将所有的依赖关系添加到一个文件中，而不是单个文件。让我们使用有用的数据。创建一个<code>books.js</code>文件，并向其中添加以下代码行:</p>
<pre>let books = [
     { name: "Hey there my name is awesome"},
     { name: "The mythical man month"},
     { name: "Please don't make me think"}
    ]
    
    module.exports = books;</pre>
<p class="graf graf--p">接下来，更新您的<code>app.js</code>,如下所示:</p>
<pre>let $ = require('jquery');
    let books = require('./books.js');
    
    $.each(books, function(key, value){
      $('body').append("&lt;h1&gt;"+ books[key].name +"&lt;/h1&gt;");
    })</pre>
<p class="graf graf--p">在这里，我们从<code>books.js</code>文件导入书籍，并使用特殊的<strong class="markup--strong markup--p-strong"> JQuery </strong>函数将它动态添加到我们的HTML页面。现在，如果您运行命令<code>webpack --mode=development app.js -o bundle.js</code>，您将在页面上看到:</p>
<figure class="graf graf--figure"><img decoding="async" class="graf-image jetpack-lazy-image" src="../Images/981f4eff2a1d9cee1d52c49a7bd1aafd.png" data-image-id="0*qFU_cPMZQsHsSAvX.png" data-width="786" data-height="228" data-lazy-src="https://cdn-images-1.medium.com/max/1600/0*qFU_cPMZQsHsSAvX.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://cdn-images-1.medium.com/max/1600/0*qFU_cPMZQsHsSAvX.png"/><noscript><img data-lazy-fallback="1" decoding="async" class="graf-image" src="../Images/981f4eff2a1d9cee1d52c49a7bd1aafd.png" data-image-id="0*qFU_cPMZQsHsSAvX.png" data-width="786" data-height="228" data-original-src="https://cdn-images-1.medium.com/max/1600/0*qFU_cPMZQsHsSAvX.png"/></noscript></figure>
<p class="graf graf--p">在你的终端输入<code>webpack --mode=development app.js -o bundle.js --watch</code>。现在你所做的任何改变<strong class="markup--strong markup--p-strong"> Webpack </strong>都会自动监视并更新<strong class="markup--strong markup--p-strong"> bundle.js </strong>文件。最后，让我们看看如何向页面添加样式。为了在Webpack中使用<strong class="markup--strong markup--p-strong"> CSS或SASS </strong>，我们必须使用<strong class="markup--strong markup--p-strong">加载器</strong>。让我们安装它。在你的终端输入<code>npm install --save-dev css-loader style-loader</code>。您的<strong class="markup--strong markup--p-strong"> package.json </strong>文件现在将如下所示:</p>
<pre>{
      "name": "webpacktest",
      "version": "1.0.0",
      "description": "",
      "main": "app.js",
      "scripts": {
        "test": "echo \"Error: no test specified\" &amp;&amp; exit 1"
      },
      "author": "",
      "license": "ISC",
      "dependencies": {
        "jquery": "^3.3.1"
      },
      "devDependencies": {
        "css-loader": "^2.0.1",
        "style-loader": "^0.23.1"
      }
    }</pre>
<p class="graf graf--p">你可以看到两个加载器都被安装为<strong class="markup--strong markup--p-strong">开发依赖</strong>供我们使用。让我们创建一个样式表，并向其中添加基本样式。创建一个<code>styles.css</code>文件，并向其中添加以下代码行:</p>
<pre>body {
      background: yellow;
    }</pre>
<p class="graf graf--p">现在更新您的<code>app.js</code>文件，如下所示:</p>
<pre>require('!style-loader!css-loader!./styles.css');
    let $ = require('jquery');
    let books = require('./books.js');
    
    $.each(books, function(key, value){
      $('body').append("&lt;h1&gt;"+ books[key].name +"&lt;/h1&gt;");
    })</pre>
<p class="graf graf--p">现在，由于<strong class="markup--strong markup--p-strong"> Webpack </strong>处于观察模式，刷新您的浏览器，您会看到:</p>
<figure class="graf graf--figure"><img decoding="async" class="graf-image jetpack-lazy-image" src="../Images/4de3a4527877079fb10865914f3bd30a.png" data-image-id="0*20lnPXGI0Qq0DZ1I.png" data-width="943" data-height="278" data-lazy-src="https://cdn-images-1.medium.com/max/1600/0*20lnPXGI0Qq0DZ1I.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://cdn-images-1.medium.com/max/1600/0*20lnPXGI0Qq0DZ1I.png"/><noscript><img data-lazy-fallback="1" decoding="async" class="graf-image" src="../Images/4de3a4527877079fb10865914f3bd30a.png" data-image-id="0*20lnPXGI0Qq0DZ1I.png" data-width="943" data-height="278" data-original-src="https://cdn-images-1.medium.com/max/1600/0*20lnPXGI0Qq0DZ1I.png"/></noscript></figure>
<p class="graf graf--p">现在我们已经看到了如何使用Webpack以及它如何帮助开发。还有很多Webpack命令、技术和插件需要探索，你可以在这里找到它们<a class="markup--anchor markup--p-anchor" href="https://webpack.js.org/concepts/" target="_blank" rel="noopener noreferrer" data-href="https://webpack.js.org/concepts/">。</a></p>
<h3 class="graf graf--h3">结论</h3>
<p class="graf graf--p">在本教程中，我们讨论了不同的构建工具以及它们如何帮助改进我们的开发。所有这些工具都很棒，适合某些用例。但是，尽量不要花太多时间考虑使用哪种工具。只需定义您的项目需求，然后尝试使用最适合该需求且不太难设置和上手的工具。谢了。编码快乐！</p>
<div class="code-block code-block-23">
<div class="blog-plug inline-plug node-plug"><h2>200只<img src="../Images/61167b9d027ca73ed5aaf59a9ec31267.png" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2019/10/green-check.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" class=" jetpack-lazy-image" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/10/green-check.png"/> <noscript> <img data-lazy-fallback="1" src="../Images/61167b9d027ca73ed5aaf59a9ec31267.png" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/10/green-check.png"/> </noscript>显示器出现故障，生产中网络请求缓慢</h2><p>部署基于节点的web应用程序或网站是容易的部分。确保您的节点实例继续为您的应用程序提供资源是事情变得更加困难的地方。如果您对确保对后端或第三方服务的请求成功感兴趣，</p><a href="https://lp.logrocket.com/blg/node-signup" target="_blank">try LogRocket</a><p>. </p><a class="signup" href="https://lp.logrocket.com/blg/node-signup" target="_blank" rel="noopener noreferrer"><img src="../Images/cae72fd2a54c5f02a6398c4867894844.png" alt="LogRocket Network Request Monitoring" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2019/12/network-request-filter-2-1.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" class=" jetpack-lazy-image" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/12/network-request-filter-2-1.png"/><noscript><img data-lazy-fallback="1" src="../Images/cae72fd2a54c5f02a6398c4867894844.png" alt="LogRocket Network Request Monitoring" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/12/network-request-filter-2-1.png"/></noscript></a><a href="https://lp.logrocket.com/blg/node-signup" target="_blank" rel="noopener noreferrer">https://logrocket.com/signup/</a><p>LogRocket 就像是网络和移动应用程序的DVR，记录下用户与你的应用程序交互时发生的一切。您可以汇总并报告有问题的网络请求，以快速了解根本原因，而不是猜测问题发生的原因。</p><p>LogRocket检测您的应用程序以记录基线性能计时，如页面加载时间、到达第一个字节的时间、慢速网络请求，还记录Redux、NgRx和Vuex操作/状态。</p><a class="signup" href="https://lp.logrocket.com/blg/node-signup" target="_blank" rel="noopener noreferrer">Start monitoring for free</a><p>. </p></div>
</div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
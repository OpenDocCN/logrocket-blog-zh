<html>
<head>
<title>GraphQL vs. REST APIs: Why you shouldn’t use GraphQL - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>GraphQL与REST APIs:为什么你不应该使用GraphQL - LogRocket博客</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/graphql-vs-rest-api-why-you-shouldnt-use-graphql/#0001-01-01">https://blog.logrocket.com/graphql-vs-rest-api-why-you-shouldnt-use-graphql/#0001-01-01</a></blockquote><div><article class="article-post">
<p><em> <strong>编者按</strong>:这篇文章最后一次更新于2022年8月24日，以验证代码的准确性。</em></p>
<p>如果您想以声明的方式工作，GraphQL是很棒的，它允许您只选择您需要的信息或操作。然而，根据您的用例、性能需求和对不必要复杂性的容忍度，GraphQL可能不适合您的项目。</p>
<p>在本文中，我们将回顾为什么您应该考虑使用REST架构而不是GraphQL的一些原因。我们将讨论使用GraphQL的缺点，包括性能问题、GraphQL模式问题和复杂查询。我们还将概述GraphQL的一些常见用例，并提供一些提示来帮助您<a href="https://blog.logrocket.com/graphql-vs-grpc-vs-rest-choosing-right-api/">决定何时使用GraphQL与REST </a>。我们开始吧！</p>

<h2 id="graphql-vs-rest-differences">GraphQL与REST:差异</h2>
<p>GraphQL和REST最大的区别是数据发送到客户端的方式。在REST架构中，客户端发出HTTP请求，数据作为HTTP响应发送，而在GraphQL中，客户端通过查询请求数据。</p>
<p>同样值得注意的是，在REST中，请求对象的结构是在服务器上定义的。在<a href="https://blog.logrocket.com/5-graphql-clients-for-javascript-and-node-js/"> GraphL中，您在客户端</a>上定义对象。</p>
<h2 id="when-use-graphql">什么时候应该使用GraphQL？</h2>
<p>GraphQL是构建和使用API的独特问题的优秀解决方案。当按设计使用时，它可以成为下述用例的理想工具。</p>
<h3 id="data-fetching-control">数据提取控制</h3>
<p>GraphQL被设计成允许客户机只请求它需要的数据。虽然服务器可能能够为单个请求向客户机传送更多的数据，但它只会发送客户机请求的数据。如果您希望客户机控制它需要的数据类型和数量，GraphQL将是您的项目的理想选择。</p>
<h3 id="using-multiple-sources">使用多个数据源</h3>
<p>GraphQL简化了从多个来源或API聚集数据，然后在一个API调用中将数据解析到客户端的任务。另一方面，像REST这样的API技术需要多个HTTP调用来访问来自多个数据源的数据。</p>
<h3 id="alleviating-bandwidth-concerns">缓解带宽问题</h3>
<p>对于手机、智能手表和物联网设备等无法处理大量数据的小型设备来说，带宽是一个问题。使用GraphQL有助于最小化这个问题。因为GraphQL允许客户端指定它需要什么数据，所以服务器不会发送多余的数据，这可能会在带宽有限的情况下降低应用程序的性能。</p>
<h3 id="rapid-prototyping">快速原型</h3>
<p>GraphQL公开了允许您访问多个资源的单个端点。此外，资源不会根据您在应用程序中拥有的视图而公开。因此，如果您的UI发生变化，例如，需要更多或更少的数据，它不会对服务器产生影响，也不需要对服务器进行更改。</p>
<h2 id="when-use-rest-api">什么时候应该使用REST API？</h2>
<p>既然我们已经概述了一些需要使用GraphQL的用例，那么让我们来讨论一些为什么您可能想要考虑使用REST的原因，回顾一些提示来帮助您确定何时使用每一个。</p>
<h3 id="graphql-performance-issues">GraphQL性能问题</h3>
<p>作为API的一种查询语言，GraphQL赋予了客户执行查询的能力，以获得他们所需要的信息。但是，如果客户端发送一个查询，要求提供许多字段和资源，例如，某个作者对所有书籍发表评论的用户的信息，该怎么办呢:</p>
<pre>author(id: '1234') {
  id
  name
  books {
    id
    title
    reviews {
      text
      date
      user {
        id
        name
      }
    }
  }
}
</pre>
<p>使用GraphQL，用户不能简单地运行他们想要的任何查询。必须仔细设计GraphQL API这不仅仅是将它放在REST API或数据库之上。</p>
<p>对于复杂的查询，REST API可能更容易设计，因为您可以为特定的需求建立多个端点，并且可以对特定的查询进行微调，以高效的方式检索数据。</p>
<p>这可能有点争议，因为多个网络调用仍然会花费很多时间。但是，如果不小心的话，一些大的查询可能会让您的服务器严重停机。从这个意义上说，GraphQL最大的优势也可能是它最大的弱点。</p>
<p>在GraphQL API中，像<a href="https://github.com/facebook/dataloader"> Dataloader </a>这样的工具允许你批处理和缓存数据库调用。但是，在某些情况下，即使这样也不够，唯一的解决方案是通过计算最大执行成本或查询深度来阻塞查询。这些解决方案都取决于您使用的库。</p>
<h3 id="rest-graphql-tasks">REST可以做GraphQL做的很多事情</h3>
<p>重要的是要记住，GraphQL是REST开发API的替代品，而不是替代品。</p>
<p>使用GraphQL的主要好处是能够发送只指定您需要的信息的查询，并准确地接收这些信息。然而，您可以使用REST达到同样的效果，方法是在URL中传递您想要使用的字段的名称，然后自己实现解析并返回逻辑:</p>
<pre>GET /books/1492030716?fields=title,pageCount
</pre>
<p>幸运的是，这很容易实现，这要归功于许多语言中可用的JSON API库。如果您希望在REST中使用模式和强类型，您可以使用<a href="https://json-schema.org/"> JSON模式</a>；有许多<a href="https://json-schema.org/implementations.html">库实现并支持JSON模式</a>。</p>
<p>如果您想在REST APIs中使用查询语言，像<a href="https://www.odata.org/"> OData </a>这样的解决方案是一个很好的选择。OData是开放数据协议的缩写，最初由微软于2007年开发。OData是一个开放的协议，使您能够以简单、标准的方式创建和使用可查询和可互操作的RESTful APIs。OData为您提供了一组丰富的查询功能，并因其开源方法和卓越的可伸缩性而迅速赢得市场。</p>
<p>有许多有效的替代方法，特别是对于使用GraphQL可能有些过头的小型应用程序和项目。出于同样的原因，您会遇到实现这些库很复杂而使用GraphQL更容易的情况，graph QL本身支持所有这些特性。然而，GraphQL也可以以自己的方式使事情变得更复杂，这一点我们将在接下来讨论。</p>
<h3 id="graphql-tasks-complex">GraphQL使一些任务变得更加复杂</h3>
<p>不建议在简单的应用程序中使用GraphQL。例如，在一个每次都以相同的方式使用一些字段的应用程序中，使用GraphQL会增加更多的复杂性，因为像类型、查询、赋值函数、解析器和更高阶的组件，</p>
<p>从维护的角度来看，这尤其有害。但是，即使使用GraphQL是合理的，也可能存在一些复杂性。两个例子包括错误处理和文件上传。</p>
<p>在REST中，检查响应状态是了解请求是否成功执行、是否存在服务器错误或者是否没有找到资源的唯一方法。但是，当GraphQL中出现错误时，您会得到类似如下的结果:</p>
<pre>{
  "data": null,
  "errors": [
    {
      "message": "Validation error...",
      "locations": [
        {
          "line": 5,
          "column": 6
        }
      ]
    }
  ]
}
</pre>
<p>您必须解析这条消息才能知道是否有错误，不同的错误可能会有稍微不同的格式或一些自定义字段。</p>
<p>一些库，比如<a href="https://blog.logrocket.com/graphql-local-state-management-apollo/"> Apollo client，帮助处理错误</a>，但是这不像在REST API中那么容易。</p>
<p>文件上传不是GraphQL规范的一部分，所以实现工作留给了您。一些选项包括使用:</p>

<p>第三种选择可能是最好的。然而，这意味着添加另一个依赖项来管理您的项目，并且它可能不适用于所有编程语言。</p>
<h3 id="web-cache">GraphQL与。REST: Web cache</h3>
<p>我想强调web部分，即网络级别的缓存，因为您肯定可以使用Apollo客户端的<a href="https://www.apollographql.com/docs/react/advanced/caching.html">内存缓存实现</a>在数据库级别或客户端级别实现缓存。</p>
<p>例如，假设您有一个在HTTP级别实现的缓存，它带有一个存储请求内容的反向代理。这可以减少服务器的流量，或者将频繁访问的信息保存在靠近客户端的位置，如内容交付网络。</p>
<p>由于REST API提供了许多端点，您可以轻松地配置web缓存来匹配某些URL模式、HTTP方法或特定资源。</p>
<p>在GraphQL中，只有一个端点，通常是HTTP POST端点，所有的查询都发送到这个端点。因为每个查询都可能不同，所以使用这种类型的缓存比较困难。为了减少web服务器的流量，您可以使用带有<a href="https://www.npmjs.com/package/persistgraphql"> PersistGraphQL </a>的<a href="https://blog.apollographql.com/persisted-graphql-queries-with-apollo-client-119fd7e6bba5">持久化查询</a>。请记住，在撰写本文时，这个工具不再被维护，但是，它仍然被广泛使用，并将为本教程的目的而工作。</p>
<p>PersistGraphQL为GraphQL查询分配标识符，生成一个映射查询和标识符的JSON文件。有了这个映射，客户机只需将标识符和查询的参数发送给服务器，这样它就可以查找了。然而，这增加了另一层复杂性，并且它只是部分地解决了问题。</p>
<h3 id="graphql-schemas">GraphQL架构</h3>
<p>通过允许定义模式，GraphQL给了你很多好处，比如自动验证和T2自省。根据您选择的编写或生成模式的方式，当您有一个不断变化的数据模型时，静态模式可能会成为一个问题，因为客户端得到的响应取决于模式定义和它们进行的查询。</p>
<p>例如，您不能拥有比模式或查询中指定的深度更深的深度，您可以在运行时修改的模式，或<a href="https://github.com/absinthe-graphql/absinthe/issues/439">动态类型定义</a>。在GraphQL中，您可以通过使用代码优先的方法以编程方式构建模式来解决这个问题。设计过程从编写解析器开始，GraphQL模式的SDL版本是以编程方式生成的。</p>

<p>与GraphQL相比，REST中的错误处理更容易。RESTful APIs在资源方面遵循HTTP规范，并为各种API请求状态返回各种HTTP状态。另一方面，GraphQL为每个API请求返回<code>200 Ok</code>状态，包括错误。这使得管理错误变得困难，并且难以与监控工具集成。</p>
<h2 id="conclusion">结论</h2>
<p>GraphQL是一个强大的工具，有很多理由让你选择GraphQL而不是REST。但是，如果您对缓慢的性能和复杂性的容忍度较低，那么您可能希望避开它，考虑使用REST架构。</p>
<p>在本指南中，我们讨论了一些使用GraphQL可能导致性能问题以及与模式和复杂查询相关的问题的场景。我们还提供了一些技巧来帮助您确定什么时候使用GraphQL，什么时候使用REST架构。</p>
<p>我在这里提出的观点可能并不总是适用，但值得考虑一下，看看是否可以解决。</p><div class="code-block code-block-24">
<div class="blog-plug inline-plug graphql-plug"><h2>监控生产中失败和缓慢的GraphQL请求</h2><p>虽然GraphQL有一些调试请求和响应的特性，但确保GraphQL可靠地为您的生产应用程序提供资源是一件比较困难的事情。如果您对确保对后端或第三方服务的网络请求成功感兴趣，</p><a href="https://lp.logrocket.com/blg/graphql-signup" target="_blank">try LogRocket</a><p>.</p><a class="signup" href="https://lp.logrocket.com/blg/graphql-signup" target="_blank" rel="noopener noreferrer"><img src="../Images/432a3823c85b3fb72a206e6236a29f48.png" data-lazy-src="https://files.readme.io/69aa835-Image_2019-11-09_at_1.28.05_PM.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" class=" jetpack-lazy-image" data-original-src="https://files.readme.io/69aa835-Image_2019-11-09_at_1.28.05_PM.png"/><noscript><img data-lazy-fallback="1" src="../Images/432a3823c85b3fb72a206e6236a29f48.png" data-original-src="https://files.readme.io/69aa835-Image_2019-11-09_at_1.28.05_PM.png"/></noscript><img class="alignnone size-full wp-image-46 jetpack-lazy-image" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/><noscript><img data-lazy-fallback="1" class="alignnone size-full wp-image-46" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/></noscript></a><a href="https://lp.logrocket.com/blg/graphql-signup" target="_blank" rel="noopener noreferrer">https://logrocket.com/signup/</a><p>LogRocket 就像是网络和移动应用的DVR，记录下你网站上发生的每一件事。您可以汇总并报告有问题的GraphQL请求，以快速了解根本原因，而不是猜测问题发生的原因。此外，您可以跟踪Apollo客户机状态并检查GraphQL查询的键值对。</p><p>LogRocket检测您的应用程序以记录基线性能计时，如页面加载时间、到达第一个字节的时间、慢速网络请求，还记录Redux、NgRx和Vuex操作/状态。</p><a class="signup" href="https://lp.logrocket.com/blg/graphql-signup" target="_blank" rel="noopener noreferrer">Start monitoring for free</a><p>.</p></div>


</div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
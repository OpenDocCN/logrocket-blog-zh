<html>
<head>
<title>React dynamic imports and route-centric code splitting - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>React动态导入和以路由为中心的代码分割</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/react-dynamic-imports-route-centric-code-splitting-guide/#0001-01-01">https://blog.logrocket.com/react-dynamic-imports-route-centric-code-splitting-guide/#0001-01-01</a></blockquote><div><article class="article-post">
<p><em> <strong>编者按:</strong>这篇文章于2022年3月21日更新，包含了关于可加载组件和React路由器最新版本的信息。</em></p>
<p>性能优化对于每个开发人员来说都是一个重要的软件开发里程碑。在投入大量时间编写优秀的代码、添加功能、忍受冗长的调试部分，以及最终完成我们的杰作之后，我们接下来选择我们最喜欢的托管服务，并将应用程序部署到云中。</p>
<p>但是，一旦我们尝试托管和导航应用程序，我们会立即注意到加载时间很长，这意味着应用程序慢得令人难以置信。此时，我们已经到达了性能优化的里程碑。</p>
<p>作为开发人员，我们可以在人类已知的最胖的服务器上开发我们的应用程序:localhost。在localhost上开发时，我们很容易遇到任何性能问题，但这是因为生产和开发之间存在差异。</p>
<p>在本地服务器上开发时，我们所有的文件都托管在我们计算机的端口上。在React中，端口默认设置为<code>3000</code>。因为当我们使用本地服务器时，互联网连接并不重要，所以我们可以非常快地下载我们所有的文件和JavaScript包。</p>
<p>然而，一旦我们上线，下载大文件和JavaScript包可能会成为一个大问题，尤其是在可能没有高速互联网的地方。React使用了几种性能优化技术和技巧。在本文中，我们将看看如何使用以路由为中心的<a href="https://reactjs.org/docs/code-splitting.html" target="_blank" rel="noopener">代码分割</a>来提高性能。</p>
<h2 id="benefits-of-code-splitting"><strong>代码拆分的好处</strong></h2>
<p>使用create-react-app的一个很大的好处是，它给了我们现成的代码拆分和分块。组块允许我们将代码分成包，包是打包成单个文件的一组相关的组块。<a href="https://github.com/facebook/create-react-app" target="_blank" rel="noopener"> Create React App </a>、<a href="https://www.gatsbyjs.com/" target="_blank" rel="noopener"> Gatsby </a>、<a href="https://nextjs.org/" target="_blank" rel="noopener"> Next.js </a>等工具使用<a href="https://webpack.js.org/" target="_blank" rel="noopener"> webpack </a>捆绑应用。像webpack这样的捆绑器导入所有的应用程序文件，并将它们合并成一个包。</p>
<p>这样做的一些优点是:</p>
<ul>
<li>允许用户的浏览器下载整个应用程序一次，这样他们就可以无缝导航，而不需要另一个HTTP请求</li>
<li>浏览器不需要要求或导入任何其他文件，因为它们都在包中。虽然捆绑通常很有帮助，但随着应用程序的增长，应用程序捆绑包可能会变得非常大，这意味着它会影响应用程序的加载时间</li>
</ul>
<p>对于最佳实践，web开发人员将大的包代码分割成较小的包，因为这使他们能够按需延迟加载文件，并提高React应用程序的性能。</p>
<p>以下是React应用程序的生产版本片段:</p>
<p><img decoding="async" src="../Images/c5e6def74f5dd2214ad35479c5df659d.png" alt="Code splitting production build chunks." data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2020/10/yBSPW03w.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" class=" jetpack-lazy-image" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/10/yBSPW03w.png"/></p><noscript><img data-lazy-fallback="1" decoding="async" src="../Images/c5e6def74f5dd2214ad35479c5df659d.png" alt="Code splitting production build chunks." data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/10/yBSPW03w.png"/></noscript>
<p>我们可以通过运行构建脚本<code>npm run build</code>或<code>yarn build</code>来创建一个生产构建——分别是<code>build/static/js</code>和<code>build/static/css</code>目录中的<code>.js</code>和<code>.css</code>文件。</p>
<p>从图像中，我们可以看到文件被分成不同的块。<a href="https://create-react-app.dev" target="_blank" rel="noopener">创建React应用</a>通过<code>[SplitChunksPlugin](<a href="https://webpack.js.org/plugins/split-chunks-plugin/" rel="nofollow">https://webpack.js.org/plugins/split-chunks-plugin/</a>)</code> webpack插件实现了这一点。让我们分解上面显示的代码:</p>
<ol>
<li>代表我们的应用程序需要的所有CSS代码。注意，即使你使用类似于<a href="https://styled-components.com/" target="_blank" rel="noopener">样式组件</a>的东西用JavaScript编写CSS，它仍然会编译成CSS</li>
<li>代表我们的应用程序中使用的所有库。它实际上是从<code>node_modules</code>文件夹中导入的所有供应商代码</li>
<li><code>Main.[hash].chunk.js</code>是我们所有的申请文件(Contact.js，About.js等。).它代表了我们为React应用程序编写的所有代码</li>
<li>代表一个小的webpack运行时逻辑，用于加载和运行我们的应用程序。默认情况下，其内容位于build/index.html文件中</li>
</ol>
<p>然而，即使我们的生产结构得到优化，仍有改进的空间。<br/>考虑以下图像:</p>
<figure class="wp-caption aligncenter"><img decoding="async" src="../Images/58e73a9aa0279bdf84e9a31a4648a95f.png" alt="Code Spitting Optimized Production Build" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2020/10/u7TMq3gZ-e1603726308465.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" class=" jetpack-lazy-image" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/10/u7TMq3gZ-e1603726308465.png"/><noscript><img data-lazy-fallback="1" decoding="async" loading="lazy" src="../Images/58e73a9aa0279bdf84e9a31a4648a95f.png" alt="Code Spitting Optimized Production Build" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/10/u7TMq3gZ-e1603726308465.png"/></noscript><figcaption class="wp-caption-text">Code spitting optimized production build.</figcaption></figure>
<p>虽然我们可以创建一个生产版本，并按原样部署应用程序，但上面的图片显示它可以进一步优化。</p>
<p>从图像中，我们看到<code>main.[hash].chunk.js</code>包含了我们所有的应用程序文件，大小为1000kB。我们还可以看到，当用户访问登录页面时，浏览器会下载整个1000kB的数据块。这个块包含用户可能永远不需要的代码。因此，如果登录页面为2kB，用户必须加载1000kB的数据块才能查看2kB的页面。</p>
<p>因为<code>main.[hash].chunk.js</code>的大小随着我们的应用程序的增长而增加，更大的应用程序的大小可能会超过1000kB，这意味着我们的应用程序加载时间可能会大幅增加——如果用户的互联网速度很差，它的执行速度甚至会更慢。这就是我们需要进一步优化的原因。</p>
<p>对此的解决方案是将<code>main.[hash].chunk.js</code>分割成更小的块，这确保当用户访问我们的页面时，他们只下载他们需要的代码块。在这个例子中，用户的浏览器应该只加载登录块。</p>
<p>通过这样做，我们将显著减少用户在应用程序初始加载期间下载的代码数量，并提升应用程序的性能。让我们在下一节看看如何实现代码分割。</p>
<h2 id="implementing-route-centric-codes-plitting"><strong>实现以路由为中心的代码拆分</strong></h2>
<p>为了实现代码分割，我们将结合JavaScript和React的特性。让我们来看看下面的技巧:</p>

<h3 id="dynamic-imports">动态导入</h3>
<p>这是一个现代的JavaScript特性，它像承诺一样导入我们的文件。</p>
<p>之前:</p>
<pre class="language-javascript hljs">import Login from "Pages/Login.js";
import Home from "Pages/Home.js";
import About from "Pages/About.js";
import Contact from "Pages/Contact.js";
import Blog from "Pages/Blog.js";
import Shop from "Pages/Shop.js";
</pre>
<p>上面的代码片段使用静态导入来导入我们的文件。当webpack遇到这种语法时，它会将所有文件捆绑在一起。这是因为我们想静态地将它们包含在一起。</p>
<p>之后:</p>
<pre class="language-javascript hljs">const module = await import('/modules/myCustomModule.js');
</pre>
<p>与同步的静态导入不同，动态导入是异步的。这使我们能够按需导入我们的模块和文件。一旦webpack遇到这种语法，它会立即开始对我们的应用程序进行代码拆分。</p>
<h3 id="react-lazy"><code>React.lazy()</code></h3>
<p>这个React组件是一个将另一个函数作为参数的函数。该参数调用动态导入并返回一个承诺。<code>React.lazy()</code>处理这个承诺，并期望它返回一个包含<code>defaultexport</code> React组件的模块。</p>
<p>之前:</p>
<pre class="language-javascript hljs">import Login from "Pages/Login.js";
/pre&gt;</pre>
<p>之后:</p>
<p>登录页面现在是延迟加载的，确保了<code>Login.js</code>块仅在呈现时才被加载。</p>
<pre class="language-react hljs">import React, {lazy} from "react";
const Login = lazy(()=&gt; import("Pages/Login"));
</pre>
<p><code>React.Suspense()</code></p>
<h3 id="react-suspense">允许我们有条件地暂停一个组件的渲染，直到它被加载。它有一个接受React元素的后备属性。React元素可以是JSX代码片段，也可以是完整的组件。</h3>
<p>更多来自LogRocket的精彩文章:</p><div class="code-block code-block-54">
<hr/>
<h3>当用户访问使用动态导入的页面时，他们可能会在应用程序加载模块时看到一个空白屏幕。由于动态导入是异步的，有时用户甚至会得到一个错误。如果用户的互联网连接速度较慢，这种可能性就会增加。</h3>

<hr/></div>
<p><code>React.lazy()</code>和<code>React.suspense()</code>一起使用来解决这个问题。</p>
<p>虽然<code>React.Suspense</code>会暂停组件的呈现，直到它的所有依赖项都被延迟加载，但它也会显示传递给<code>fallback props</code>的React元素作为后备UI。</p>
<p>考虑下面的代码:</p>
<p>这里，我们延迟加载<code>hero</code>和<code>service</code>组件。这些都是<code>home component</code>的属地。它需要他们展示一个完整的主页。</p>
<pre class="language-react hljs">import React, { lazy, Suspense } from 'react';

const Hero = lazy(() =&gt; import('./Components/Hero'));
const Service = lazy(() =&gt; import('./Component/Service'));

const Home = () =&gt; {
  return (
    &lt;div&gt;
      &lt;Suspense fallback={&lt;div&gt;Page is Loading...&lt;/div&gt;}&gt;
        &lt;section&gt;
          &lt;Hero /&gt; 
          &lt;Service /&gt;
        &lt;/section&gt;
      &lt;/Suspense&gt;
    &lt;/div&gt;
  );
}
</pre>
<p>我们使用<code>suspense component</code>来暂停<code>home component</code>的渲染，直到依赖项被延迟加载，这样当用户导航到主页时就不会出现错误或空白页面。</p>
<p>现在，当组件被延迟加载时，用户使用下面的回退UI:</p>
<p>反应路由器</p>
<pre class="language-react hljs">&lt;div&gt;Page is Loading...&lt;/div&gt;
</pre>
<h3 id="react-router">选择在应用程序中何处实现代码拆分可能会有问题。在不影响用户体验的情况下，选择能够均匀分割包的位置非常重要。</h3>
<p>路线是一个很好的起点。</p>
<p><code>react-router-dom</code>库支持内置的路由级代码分割。它允许我们在路由级别下载块。使用这个特性，我们将在路由级别进行代码拆分，这非常有帮助。</p>
<p>考虑下面的代码:</p>
<p>从这个代码示例中，我们使用<code>react-router-router</code>库设置了我们的路线，并且<code>Dashboard</code>和<code>Notifications</code>组件是延迟加载的。</p>
<pre class="language-react hljs">import { lazy, Suspense } from "react";
import { Routes, Route, Outlet, Link } from "react-router-dom";

import HomePage from "./pages/Home";

const Dashboard = lazy(() =&gt; import("./pages/Dashboard"));
const Notifications = lazy(() =&gt; import("./pages/Notifications"));

export default function App() {
  return (
    &lt;div className="App"&gt;
      &lt;h1&gt;React Router Code Splitting Demo&lt;/h1&gt;
      &lt;Routes&gt;
        &lt;Route path="/" element={&lt;AppLayout /&gt;}&gt;
          &lt;Route index element={&lt;HomePage /&gt;} /&gt;
          &lt;Route path="dashboard" element={&lt;DashboardPage /&gt;} /&gt;
          &lt;Route path="notifications" element={&lt;NotificationsPage /&gt;} /&gt;
        &lt;/Route&gt;
      &lt;/Routes&gt;
    &lt;/div&gt;
  );
}

const DashboardPage = () =&gt; (
  &lt;Suspense fallback={&lt;div&gt;Page is Loading...&lt;/div&gt;}&gt;
    &lt;Dashboard /&gt;
  &lt;/Suspense&gt;
);

const NotificationsPage = () =&gt; (
  &lt;Suspense fallback={&lt;div&gt;Page is Loading...&lt;/div&gt;}&gt;
    &lt;Notifications /&gt;
  &lt;/Suspense&gt;
);

const AppLayout = () =&gt; {
  return (
    &lt;div&gt;
      &lt;nav&gt;
        &lt;ul&gt;
          &lt;li&gt;
            &lt;Link to="/"&gt;Home&lt;/Link&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;Link to="/dashboard"&gt;Dashboard&lt;/Link&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;Link to="/notifications"&gt;Notifications&lt;/Link&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/nav&gt;
      &lt;hr /&gt;
      &lt;Outlet /&gt;
    &lt;/div&gt;
  );
};
</pre>
<p>注意<code>Dashboard</code>和<code>Notifications</code>组件是如何与<code>Suspense</code>组件封装在一起的。这确保了在延迟加载所请求的页面组件时，向用户呈现回退UI。</p>
<p>由于我们的设置，webpack提前将我们的代码分块。因此，用户只接收按需呈现页面所需的块。例如，当用户访问通知页面时，用户会收到<code>Notifications``.js</code>块，当用户访问仪表板页面时，他们会看到<code>Dashboard``.js</code>块。</p>
<p>演示的完整代码和工作示例都可以在<a href="https://codesandbox.io/s/blazing-morning-3m7tst" target="_blank" rel="noopener">这个代码沙箱</a>中找到。</p>
<p>您可以看到，我们已经显著减少了应用程序的初始加载时间，甚至没有减少应用程序中的代码量。</p>
<p>此外，如果您有兴趣了解React Router v6的更多信息，您可以查看本指南。</p>
<p>可加载组件</p>
<h3 id="loadable-components">您还可以使用<a href="https://loadable-components.com/" target="_blank" rel="noopener">可加载组件</a>库来动态加载页面组件。</h3>
<p><code>loadable()</code>函数用于创建一个可以动态导入的异步组件。它与<code>React.lazy()</code>相似，但另外它可以接受<code>fallback</code>,而不需要<code>Suspense</code>组件。<code>loadable()</code>功能还可以从组件中注入道具，支持完全动态导入。</p>
<p>你可以在这个<a href="https://codesandbox.io/s/react-router-code-splitting-with-loadable-components-5mqf4n" target="_blank" rel="noopener">代码沙箱链接</a>中找到<code>loadable``()</code>组件的演示。</p>
<pre class="language-react hljs">import { Routes, Route, Outlet, Link } from "react-router-dom";
import loadable from "@loadable/component";

import HomePage from "./pages/Home";

const LoadablePage = loadable((props) =&gt; import(`./pages/${props.page}`), {
  fallback: &lt;div&gt;Page is Loading...&lt;/div&gt;,
  cacheKey: (props) =&gt; props.page
});

export default function App() {
  return (
    &lt;div className="App"&gt;
      &lt;h1&gt;React Router Code Splitting Demo&lt;/h1&gt;
      &lt;Routes&gt;
        &lt;Route path="/" element={&lt;AppLayout /&gt;}&gt;
          &lt;Route index element={&lt;HomePage /&gt;} /&gt;
          &lt;Route path="dashboard" element={&lt;LoadablePage page="Dashboard" /&gt;} /&gt;
          &lt;Route
            path="notifications"
            element={&lt;LoadablePage page="Notifications" /&gt;}
          /&gt;
        &lt;/Route&gt;
      &lt;/Routes&gt;
    &lt;/div&gt;
  );
}
</pre>
<p>请注意，<code>loadable``()</code>组件库不是<code>React.lazy()</code>和<code>React.Suspense</code>的替代品，应该只在你觉得受限或者需要服务器端渲染支持的情况下使用。你可以查看这本<a href="https://loadable-components.com/docs/loadable-vs-react-lazy/" target="_blank" rel="noopener">比较指南</a>了解详细信息。</p>
<p><strong>结论</strong></p>
<h2 id="conclusion">在本文中，我们解释了什么是以路由为中心的代码分割，以及为什么使用它会有帮助。我们还讨论了利用动态导入、<code>React.lazy()</code>、<code>React.Suspense</code>、React路由器和可加载组件来创建性能更好的React应用程序。</h2>
<p>使用LogRocket消除传统反应错误报告的噪音</p><div class="code-block code-block-17">
<div class="blog-plug inline-plug react-plug" vwo-el-id="26283398190">
<h2 vwo-el-id="41600691720">是一款React analytics解决方案，可保护您免受数百个误报错误警报的影响，只针对少数真正重要的项目。LogRocket告诉您React应用程序中实际影响用户的最具影响力的bug和UX问题。</h2>
<a href="https://lp.logrocket.com/blg/react-signup-issue-free" target="_blank" vwo-el-id="19356441070">LogRocket
</a><p>自动聚合客户端错误、反应错误边界、还原状态、缓慢的组件加载时间、JS异常、前端性能指标和用户交互。然后，LogRocket使用机器学习来通知您影响大多数用户的最具影响力的问题，并提供您修复它所需的上下文。</p><a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="19356441380">
<img class="first-react-image alignnone size-full wp-image-46 jetpack-lazy-image jetpack-lazy-image--handled" src="../Images/f300c244a1a1cf916df8b4cb02bec6c6.png" vwo-el-id="18272717540" data-lazy-loaded="1" data-original-src="https://files.readme.io/27c94e7-Image_2017-06-05_at_9.46.04_PM.png"/>
</a>
<a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="19356441690">
<img class="second-react-image alignnone size-full wp-image-46 jetpack-lazy-image jetpack-lazy-image--handled" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" vwo-el-id="30720362350" data-lazy-loaded="1" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/>
</a>
<a href="https://lp.logrocket.com/blg/react-signup-issue-free" target="_blank" rel="noopener noreferrer" vwo-el-id="35866400580">LogRocket
</a><p>关注重要的React bug—<a class="signup" href="https://lp.logrocket.com/blg/react-signup-issue-free" target="_blank" rel="noopener noreferrer" vwo-el-id="40093418840">今天就试试LogRocket】。</a></p><p vwo-el-id="28675661060">Focus on the React bugs that matter —
<a class="signup" href="https://lp.logrocket.com/blg/react-signup-issue-free" target="_blank" rel="noopener noreferrer" vwo-el-id="40093418840">try LogRocket today</a>.
</p>
</div></div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
<html>
<head>
<title>The visual learner's guide to async JS - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>异步JS - LogRocket博客的可视化学习指南</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/the-visual-learners-guide-to-async-js-62a0a03d1d57/#0001-01-01">https://blog.logrocket.com/the-visual-learners-guide-to-async-js-62a0a03d1d57/#0001-01-01</a></blockquote><div><article class="article-post">
<p>你是否曾经观看或阅读了几个小时的教程，但仍然感到困惑？这就是我第一次学习异步JavaScript时的感受。我很难清楚地看出promises和async/await之间的区别，特别是因为在引擎盖下，它们是相同的。</p>
<p>多年来，Async JS已经发展了很多。教程是很棒的，但是它们经常给你一个快照，告诉你在那个特定的时间点什么是“正确的”做事方法。没有意识到我应该注意内容的日期(😅)，我发现自己把不同的语法混在了一起。甚至当我试图只消费最近的内容时，仍然缺少一些东西。</p>
<p>我意识到外面的很多材料都不符合我的学习风格。我是一个视觉学习者，所以为了理解所有不同的异步方法，我需要以一种符合我视觉风格的方式来组织它们。在这里，我将通过例子和类比向您介绍我提出的关于异步的问题，以及我如何区分承诺和异步/等待。</p>
<h3>为什么我们需要异步？</h3>
<p>从本质上讲，JavaScript是一种同步、阻塞、单线程的语言。如果这些话对你来说没什么意义，这个视觉帮助我更好地理解异步JS如何更省时:</p>
<figure id="4b5c" class="graf graf--figure graf-after--p">
<figcaption class="imageCaption"><a class="markup--anchor markup--figure-anchor" href="https://eloquentjavascript.net/11_async.html" target="_blank" rel="noopener noreferrer" data-href="https://eloquentjavascript.net/11_async.html">Thick lines = time the program spends running normally. Thin lines = time spent waiting for the network</a>.</figcaption></figure>
<p>我们希望对可以在后台发生的事情使用异步方法。当您从数据库中查询一些东西或发出API请求时，您不希望整个应用程序等待。在现实生活中，这相当于在洗衣机修好之前，你什么都不能做——不能打电话，不能吃饭，不能上厕所。这不太理想。</p>
<p>开箱即用，JS是同步的，但是我们有办法让它的行为<em>异步。</em></p>
<h3>异步的发展</h3>
<p>在网上搜索“async JS”时，我遇到了许多不同的实现:回调、承诺和async/await。对我来说，清楚每种方法及其独特的价值主张很重要，这样我就可以始终使用一致的语法进行编码。以下是每一项的细目分类:</p>
<h4>回收</h4>
<p>在ES6之前，我们使用回调来实现这种异步行为。在这里我不会深入探讨，但简而言之，回调是一个函数，你把它作为一个参数发送给另一个函数，一旦当前函数执行完毕，这个函数就会被执行。这么说吧，人们称之为“回调地狱”是有原因的。</p>
<p>为了控制事件的顺序，使用回调，您必须将函数嵌套在其他函数的回调中，以确保它们按照您期望的顺序发生。</p>
<p><img decoding="async" class="progressiveMedia-image js-progressiveMedia-image jetpack-lazy-image" src="../Images/40a65ab26d25f8317f92650c758a38d1.png" data-src="https://cdn-images-1.medium.com/max/1600/1*dQgkS279Z-xzfK0rkBBP2A.png" data-lazy-src="https://cdn-images-1.medium.com/max/1600/1*dQgkS279Z-xzfK0rkBBP2A.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://cdn-images-1.medium.com/max/1600/1*dQgkS279Z-xzfK0rkBBP2A.png"/></p><noscript><img data-lazy-fallback="1" decoding="async" class="progressiveMedia-image js-progressiveMedia-image" src="../Images/40a65ab26d25f8317f92650c758a38d1.png" data-src="https://cdn-images-1.medium.com/max/1600/1*dQgkS279Z-xzfK0rkBBP2A.png" data-original-src="https://cdn-images-1.medium.com/max/1600/1*dQgkS279Z-xzfK0rkBBP2A.png"/></noscript>
<figure id="6253" class="graf graf--figure graf--startsWithDoubleQuote graf-after--p"><figcaption class="imageCaption">“Callback hell.”</figcaption></figure>
<p>由于实现这个让我们都很头疼，JS社区提出了promise对象。</p>
<h4>承诺</h4>
<p>作为人类，我们更容易理解和阅读同步代码，所以承诺被创造出来，让<em class="markup--em markup--p-em">看起来</em>更同步，但<em class="markup--em markup--p-em">的行为</em>不同步。理想情况下，它应该是这样的:</p>
<figure id="3ab7" class="graf graf--figure graf-after--p">

</figure>
<p>这可能看起来不错，但它缺少一些关键元素，其中之一是错误处理。您曾经收到过<code>unhandledPromiseRejection</code>错误或警告吗？这是因为发生了一些错误，导致承诺被拒绝而不是被解决。</p>
<p>在上面的代码片段中，我们只处理“成功”的情况，这意味着一个未处理的承诺永远不会被解决，它占用的内存永远不会被释放。如果你不小心，一个承诺会无声无息地失败，除非用<code>catch</code>手动处理:</p>
<p><img decoding="async" class="progressiveMedia-image js-progressiveMedia-image jetpack-lazy-image" src="../Images/fd51f891089132ac5d541d5f4b5ab59a.png" data-src="https://cdn-images-1.medium.com/max/1600/1*uvHdR3kMsJtdfPamlgkS7Q.png" data-lazy-src="https://cdn-images-1.medium.com/max/1600/1*uvHdR3kMsJtdfPamlgkS7Q.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://cdn-images-1.medium.com/max/1600/1*uvHdR3kMsJtdfPamlgkS7Q.png"/></p><noscript><img data-lazy-fallback="1" decoding="async" class="progressiveMedia-image js-progressiveMedia-image" src="../Images/fd51f891089132ac5d541d5f4b5ab59a.png" data-src="https://cdn-images-1.medium.com/max/1600/1*uvHdR3kMsJtdfPamlgkS7Q.png" data-original-src="https://cdn-images-1.medium.com/max/1600/1*uvHdR3kMsJtdfPamlgkS7Q.png"/></noscript>
<h4>异步/等待</h4>
<p>这是承诺之上的语法糖，有助于代码看起来更具可读性。当我们在函数前面添加<code>async</code>关键字时，它改变了它的性质。</p>
<p>异步函数将返回承诺中的值。为了访问这个值，我们需要或者<code>.then()</code>这个方法或者<code>await</code>它。</p>
<p>抛开风格和约定不谈，在代码中一起使用不同的异步方法在技术上是可行的，因为它们都实现异步行为。但是一旦你完全理解了它们之间的区别，你就能毫不犹豫地用一致的语法来写了。</p>
<p>由于async/await利用了承诺，我最初很难从语法和约定的角度来区分这两种方法。为了弄清楚它们之间的区别，我为每个用例绘制了每个方法及其语法。</p>
<h3>比较承诺和异步/等待</h3>
<p>这些比较是我最初为自己设计的视觉升级版。<strong>承诺在左边，异步/等待在右边</strong>。</p>
<h4>强烈的</h4>
<p><img decoding="async" class="progressiveMedia-image js-progressiveMedia-image jetpack-lazy-image" src="../Images/cd515efa5d868d39f0e66975d377e0a4.png" data-src="https://cdn-images-1.medium.com/max/1600/1*C6B05ty6ltEtKgS_FEp0Aw.png" data-lazy-src="https://cdn-images-1.medium.com/max/1600/1*C6B05ty6ltEtKgS_FEp0Aw.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://cdn-images-1.medium.com/max/1600/1*C6B05ty6ltEtKgS_FEp0Aw.png"/></p><noscript><img data-lazy-fallback="1" decoding="async" class="progressiveMedia-image js-progressiveMedia-image" src="../Images/cd515efa5d868d39f0e66975d377e0a4.png" data-src="https://cdn-images-1.medium.com/max/1600/1*C6B05ty6ltEtKgS_FEp0Aw.png" data-original-src="https://cdn-images-1.medium.com/max/1600/1*C6B05ty6ltEtKgS_FEp0Aw.png"/></noscript>
<p><code>getJSON()</code>是一个返回承诺的函数。对于承诺，为了解决承诺，我们需要<code>.then()</code>或<code>.catch()</code>它。另一种解决承诺的方法是<code>await</code>兑现它。</p>
<p>注意，<code>await</code>只能在异步函数内部调用。这里省略了async函数，以便更直接地比较这两种方法。</p>
<h4>创造</h4>
<p><img decoding="async" class="progressiveMedia-image js-progressiveMedia-image jetpack-lazy-image" src="../Images/7781019434e1108352f978cf5f41e834.png" data-src="https://cdn-images-1.medium.com/max/1600/1*PbuSmkWo3D5jSr39bbiBgQ.png" data-lazy-src="https://cdn-images-1.medium.com/max/1600/1*PbuSmkWo3D5jSr39bbiBgQ.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://cdn-images-1.medium.com/max/1600/1*PbuSmkWo3D5jSr39bbiBgQ.png"/></p><noscript><img data-lazy-fallback="1" decoding="async" class="progressiveMedia-image js-progressiveMedia-image" src="../Images/7781019434e1108352f978cf5f41e834.png" data-src="https://cdn-images-1.medium.com/max/1600/1*PbuSmkWo3D5jSr39bbiBgQ.png" data-original-src="https://cdn-images-1.medium.com/max/1600/1*PbuSmkWo3D5jSr39bbiBgQ.png"/></noscript>
<p>这两个都会返回<code>Promise {&lt;resolved&gt;: "hi"}</code>。有了<code>async</code>，即使你没有显式地返回一个承诺，它也会确保你的代码通过一个承诺传递。</p>
<p><code>resolve()</code>是遗嘱执行人对于承诺的职能之一。调用时，它返回用值解析的promise对象。为了直接比较这种行为，<code>async</code>方法被包装在一个立即调用的函数中。</p><div class="code-block code-block-54">
<hr/>
<h3>更多来自LogRocket的精彩文章:</h3>

<hr/></div>
<h4>错误处理</h4>
<p><img decoding="async" class="progressiveMedia-image js-progressiveMedia-image jetpack-lazy-image" src="../Images/0d83938d4ddde7cac5346ebe7132d271.png" data-src="https://cdn-images-1.medium.com/max/1600/1*i1yzaTVK1YO99kzvUn4vjQ.png" data-lazy-src="https://cdn-images-1.medium.com/max/1600/1*i1yzaTVK1YO99kzvUn4vjQ.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://cdn-images-1.medium.com/max/1600/1*i1yzaTVK1YO99kzvUn4vjQ.png"/></p><noscript><img data-lazy-fallback="1" decoding="async" class="progressiveMedia-image js-progressiveMedia-image" src="../Images/0d83938d4ddde7cac5346ebe7132d271.png" data-src="https://cdn-images-1.medium.com/max/1600/1*i1yzaTVK1YO99kzvUn4vjQ.png" data-original-src="https://cdn-images-1.medium.com/max/1600/1*i1yzaTVK1YO99kzvUn4vjQ.png"/></noscript>
<p>有几种方法可以捕捉错误。一种是通过使用<code>then/catch</code>，另一种是通过使用<code>try/catch</code>。这两种方式都可以与promises和async/await互换使用，但这两种方式似乎分别是最常用的约定。</p>
<p>使用<code>async/await</code>的主要优势在于错误堆栈跟踪。有了承诺，一旦<code>B</code>解决了，我们在堆栈跟踪中不再有<code>A</code>的上下文。因此，如果<code>B</code>或<code>C</code>抛出异常，我们就不再知道<code>A</code>的上下文。</p>
<p>然而，对于<code>async/await</code>，<code>A</code>被暂停，同时等待<code>B</code>解决。因此，如果<code>B</code>或<code>C</code>抛出异常，我们在堆栈跟踪中知道错误来自<code>A</code>。</p>
<h4>重复</h4>
<p><img decoding="async" class="progressiveMedia-image js-progressiveMedia-image jetpack-lazy-image" src="../Images/57b428b1d77e80db4dd875878c5d5c51.png" data-src="https://cdn-images-1.medium.com/max/1600/1*R5Im4AOl01u-0UY78ieSXw.png" data-lazy-src="https://cdn-images-1.medium.com/max/1600/1*R5Im4AOl01u-0UY78ieSXw.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://cdn-images-1.medium.com/max/1600/1*R5Im4AOl01u-0UY78ieSXw.png"/></p><noscript><img data-lazy-fallback="1" decoding="async" class="progressiveMedia-image js-progressiveMedia-image" src="../Images/57b428b1d77e80db4dd875878c5d5c51.png" data-src="https://cdn-images-1.medium.com/max/1600/1*R5Im4AOl01u-0UY78ieSXw.png" data-original-src="https://cdn-images-1.medium.com/max/1600/1*R5Im4AOl01u-0UY78ieSXw.png"/></noscript>
<p>我在这里使用单个字母作为名称，以帮助您更清楚地看到语法之间的差异。以前，我会通读代码样本，在那里我觉得我必须剔除函数名中的杂草才能理解发生了什么。这让我很分心，尤其是作为一个视觉学习者。</p>
<p>注意，即使每个任务都是异步的，它们也不会同时运行。我将在下面的<strong>并行执行</strong>中谈到这一点。</p>
<h4>测试</h4>
<p><img decoding="async" class="progressiveMedia-image js-progressiveMedia-image jetpack-lazy-image" src="../Images/9980f5bc44286448ea42c7c53a34408d.png" data-src="https://cdn-images-1.medium.com/max/1600/1*5KunRgOF8I6aWf9hpjWGcQ.png" data-lazy-src="https://cdn-images-1.medium.com/max/1600/1*5KunRgOF8I6aWf9hpjWGcQ.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://cdn-images-1.medium.com/max/1600/1*5KunRgOF8I6aWf9hpjWGcQ.png"/></p><noscript><img data-lazy-fallback="1" decoding="async" class="progressiveMedia-image js-progressiveMedia-image" src="../Images/9980f5bc44286448ea42c7c53a34408d.png" data-src="https://cdn-images-1.medium.com/max/1600/1*5KunRgOF8I6aWf9hpjWGcQ.png" data-original-src="https://cdn-images-1.medium.com/max/1600/1*5KunRgOF8I6aWf9hpjWGcQ.png"/></noscript>
<p>这里有微妙但重要的区别。记住异步函数返回承诺，同样，如果你使用常规承诺，你必须返回它们。</p>
<p>其他需要注意的事项:</p>
<ul>
<li>不把<code>await</code>放在async前面会导致一个未解决的承诺，这会使你的测试结果返回一个假阳性</li>
<li>如果您想要存根一个返回承诺的异步方法，您可以这样做:</li>
</ul>
<p><img decoding="async" class="progressiveMedia-image js-progressiveMedia-image jetpack-lazy-image" src="../Images/dbd703bbad8e50148f09d508445ea701.png" data-src="https://cdn-images-1.medium.com/max/1600/1*z0GJsfL3ltDmiQXakiT1OA.png" data-lazy-src="https://cdn-images-1.medium.com/max/1600/1*z0GJsfL3ltDmiQXakiT1OA.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://cdn-images-1.medium.com/max/1600/1*z0GJsfL3ltDmiQXakiT1OA.png"/></p><noscript><img data-lazy-fallback="1" decoding="async" class="progressiveMedia-image js-progressiveMedia-image" src="../Images/dbd703bbad8e50148f09d508445ea701.png" data-src="https://cdn-images-1.medium.com/max/1600/1*z0GJsfL3ltDmiQXakiT1OA.png" data-original-src="https://cdn-images-1.medium.com/max/1600/1*z0GJsfL3ltDmiQXakiT1OA.png"/></noscript>
<p>既然我们已经讨论了大部分基本场景，那么让我们接触一些关于异步的更高级的主题。</p>
<h3>并行与顺序异步</h3>
<p>由于async/await使得语法可读性很强，所以区分并行执行和顺序执行可能会令人困惑。以下是不同之处:</p>
<h4>并行执行</h4>
<p>假设你有一个很长的待办事项清单:取邮件、洗衣服、回复邮件。因为这些事情都不相互依赖，所以您可以使用<code>Promise.all()</code>来运行这些任务。<code>Promise.all()</code>接受一个承诺数组(对于任何iterable ),并在所有异步方法解析后解析，或者在其中一个方法拒绝时拒绝。</p>
<p><img decoding="async" class="progressiveMedia-image js-progressiveMedia-image jetpack-lazy-image" src="../Images/b0f27dabb3b9194025649667098ca5a6.png" data-src="https://cdn-images-1.medium.com/max/1600/1*aAAOgSzoSOWqlMAp8GaeoA.png" data-lazy-src="https://cdn-images-1.medium.com/max/1600/1*aAAOgSzoSOWqlMAp8GaeoA.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://cdn-images-1.medium.com/max/1600/1*aAAOgSzoSOWqlMAp8GaeoA.png"/></p><noscript><img data-lazy-fallback="1" decoding="async" class="progressiveMedia-image js-progressiveMedia-image" src="../Images/b0f27dabb3b9194025649667098ca5a6.png" data-src="https://cdn-images-1.medium.com/max/1600/1*aAAOgSzoSOWqlMAp8GaeoA.png" data-original-src="https://cdn-images-1.medium.com/max/1600/1*aAAOgSzoSOWqlMAp8GaeoA.png"/></noscript>
<h4>顺序执行</h4>
<p>或者，如果您有相互依赖的任务，您可以按顺序执行它们。例如，假设你在洗衣服。你必须按顺序做事:清洗、晾干、折叠。你不能同时做这三件事。因为它是有顺序的，你应该这样做:</p>
<p><img decoding="async" class="progressiveMedia-image js-progressiveMedia-image jetpack-lazy-image" src="../Images/8df535edc0f522352cd4ab90913ff6fd.png" data-src="https://cdn-images-1.medium.com/max/1600/1*zX1r9QoYPQ-zdz9Idqro5A.png" data-lazy-src="https://cdn-images-1.medium.com/max/1600/1*zX1r9QoYPQ-zdz9Idqro5A.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://cdn-images-1.medium.com/max/1600/1*zX1r9QoYPQ-zdz9Idqro5A.png"/></p><noscript><img data-lazy-fallback="1" decoding="async" class="progressiveMedia-image js-progressiveMedia-image" src="../Images/8df535edc0f522352cd4ab90913ff6fd.png" data-src="https://cdn-images-1.medium.com/max/1600/1*zX1r9QoYPQ-zdz9Idqro5A.png" data-original-src="https://cdn-images-1.medium.com/max/1600/1*zX1r9QoYPQ-zdz9Idqro5A.png"/></noscript>
<p>这些函数按顺序执行，因为这里的返回值被用作下一个函数的输入。因此，该函数必须等到返回值后才能继续执行。</p>
<h3>成功秘诀</h3>
<p>每个人都有不同的学习风格。无论我看了多少教程或读了多少博客，我的异步知识仍然存在漏洞。只有当我坐下来，把所有的事情都计划好了，我才最终把所有的事情拼凑起来。</p>
<p>当你遇到一个让你纠结的概念时，不要沮丧或气馁。这只是因为信息没有以符合你学习风格的方式呈现给你。如果没有适合你的材料，那就自己创造并分享吧！你可能会惊讶有多少人和你有同样的感受。</p>
<p>感谢阅读🙌！很想听听你的想法，欢迎发表评论。</p>
<p>在<a class="markup--anchor markup--p-anchor" href="https://www.instagram.com/edenadler" target="_blank" rel="noopener noreferrer" data-href="https://www.instagram.com/edenadler"> Instagram </a>上与我联系，并查看我的<a class="markup--anchor markup--p-anchor" href="https://edenadler.com/" target="_blank" rel="noopener noreferrer" data-href="https://edenadler.com">网站</a>👈。</p><div class="code-block code-block-27">
<div class="blog-plug inline-plug vanilla-javascript-cta"><h2>通过理解上下文，更容易地调试JavaScript错误</h2>
<p>调试代码总是一项单调乏味的任务。但是你越了解自己的错误，就越容易改正。</p>
<p>LogRocket 让你以新的独特的方式理解这些错误。我们的前端监控解决方案跟踪用户与您的JavaScript前端的互动，让您能够准确找出导致错误的用户行为。</p>
<a href="https://lp.logrocket.com/blg/javascript-signup" class="signup" target="_blank" rel="noopener noreferrer"><img class="alignnone size-full wp-image-46 jetpack-lazy-image" src="../Images/cbfed9be3defcb505e662574769a7636.png" alt="LogRocket Dashboard Free Trial Banner" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2020/06/reproduce-javascript-errors.gif?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/06/reproduce-javascript-errors.gif"/><noscript><img data-lazy-fallback="1" class="alignnone size-full wp-image-46" src="../Images/cbfed9be3defcb505e662574769a7636.png" alt="LogRocket Dashboard Free Trial Banner" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/06/reproduce-javascript-errors.gif"/></noscript></a>
<p>LogRocket记录控制台日志、页面加载时间、堆栈跟踪、慢速网络请求/响应(带有标题+正文)、浏览器元数据和自定义日志。理解您的JavaScript代码的影响从来没有这么简单过！</p>
<a class="signup" href="https://lp.logrocket.com/blg/javascript-signup" target="_blank" rel="noopener noreferrer">Try it for free</a><p>.</p></div>


</div>
<hr/>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
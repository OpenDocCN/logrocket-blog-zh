<html>
<head>
<title>Simplifying state management in React apps with batched updates - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>通过批量更新简化React应用的状态管理</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/simplifying-state-management-in-react-apps-with-batched-updates/#0001-01-01">https://blog.logrocket.com/simplifying-state-management-in-react-apps-with-batched-updates/#0001-01-01</a></blockquote><div><article class="article-post">
<p>使用<code>useState</code>或<code>this.setState</code>更新组件状态后，组件的某些部分会根据更新重新渲染。更重要的是，如果您有各种调用来更新像<code>onClick</code>这样的React事件处理程序中的状态，React会批量更新，而不是一次更新一个，从而减少组件渲染的次数。</p>
<p>但是，您可能并不总是调用事件处理程序来更新状态，在这些情况下(例如在Promise或SetTimeout中)，React会同步更新，而不是成批更新。这意味着您将获得多次重新渲染。考虑下面的例子(或者查看CodeSandbox 上的<a href="https://codesandbox.io/s/batched-update-snippet1-4wuk8" target="_blank" rel="noopener noreferrer">演示):</a></p>
<pre>import React, { Fragment, useState } from "react";
import ReactDOM from "react-dom";
function Component() {
  const [item1, setItem1] = useState("Initial Item 1");
  const [item2, setItem2] = useState("Initial Item 2");
  console.log("render: ", item1, item2);
  function handleClickWithPromise() {
    Promise.resolve().then(() =&gt; {
      setItem1("Updated Item 1");
      setItem2("Updated Item 2");
    });
  }
  function handleClickWithoutPromise() {
    setItem1("Updated Item 1");
    setItem2("Updated Item 2");
  }
  return (
    &lt;Fragment&gt;
      &lt;button onClick={handleClickWithPromise}&gt;
        {item1} - {item2} (with promise)
      &lt;/button&gt;
      &lt;button onClick={handleClickWithoutPromise}&gt;
        {item1} - {item2} (without promise)
      &lt;/button&gt;
    &lt;/Fragment&gt;
  );
}
function App() {
  return &lt;Component /&gt;;
}
const rootElement = document.getElementById("root");
ReactDOM.render(&lt;App /&gt;, rootElement);</pre>
<p>在这个例子中，我们有两个状态值<code>item1</code>和<code>item2</code>，当两个按钮中的任何一个被点击时，我们更新它们的值。但是，在第一个按钮中，我们在承诺范围内进行更新。</p>
<p>默认情况下，React批处理在已知方法(如生命周期方法或事件处理程序)中进行的更新，但是当更新在回调中(如在<code>SetTimeout</code>或Promises中)时，React不会这样做。这意味着，如果有多次调用来更新状态，React会在每次调用时重新呈现组件。</p>
<p>当<code>Component</code>第一次渲染时，控制台输出<code>item1</code>和<code>item2</code>的初始值。</p>
<p><img data-attachment-id="5879" data-permalink="https://blog.logrocket.com/simplifying-state-management-in-react-apps-with-batched-updates/componentrender/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2019/09/componentrender.png" data-orig-size="1432,488" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="componentrender" data-image-description="&lt;p&gt;Initial render&lt;/p&gt;&#10;" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2019/09/componentrender-300x102.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2019/09/componentrender-1024x349.png" decoding="async" class="aligncenter wp-image-5879 size-large jetpack-lazy-image" src="../Images/ff628d1db70581adee070208c200668e.png" alt="Initial render" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2019/09/componentrender-1024x349.png 1024w, https://blog.logrocket.com/wp-content/uploads/2019/09/componentrender-300x102.png 300w, https://blog.logrocket.com/wp-content/uploads/2019/09/componentrender-768x262.png 768w, https://blog.logrocket.com/wp-content/uploads/2019/09/componentrender.png 1432w" data-lazy-sizes="(max-width: 1024px) 100vw, 1024px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2019/09/componentrender-1024x349.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/09/componentrender-1024x349.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="5879" data-permalink="https://blog.logrocket.com/simplifying-state-management-in-react-apps-with-batched-updates/componentrender/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2019/09/componentrender.png" data-orig-size="1432,488" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="componentrender" data-image-description="&lt;p&gt;Initial render&lt;/p&gt;&#10;" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2019/09/componentrender-300x102.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2019/09/componentrender-1024x349.png" decoding="async" loading="lazy" class="aligncenter wp-image-5879 size-large" src="../Images/ff628d1db70581adee070208c200668e.png" alt="Initial render" srcset="https://blog.logrocket.com/wp-content/uploads/2019/09/componentrender-1024x349.png 1024w, https://blog.logrocket.com/wp-content/uploads/2019/09/componentrender-300x102.png 300w, https://blog.logrocket.com/wp-content/uploads/2019/09/componentrender-768x262.png 768w, https://blog.logrocket.com/wp-content/uploads/2019/09/componentrender.png 1432w" sizes="(max-width: 1024px) 100vw, 1024px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/09/componentrender-1024x349.png"/></noscript>
<p>然后，如果您单击第一个按钮，组件会重新渲染两次，您会看到最初的渲染和随后的两次重新渲染:</p>
<p><img data-attachment-id="5880" data-permalink="https://blog.logrocket.com/simplifying-state-management-in-react-apps-with-batched-updates/tworenders/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2019/09/tworenders.png" data-orig-size="1416,658" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="tworenders" data-image-description="&lt;p&gt;Initial render and additional two re-renders&lt;/p&gt;&#10;" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2019/09/tworenders-300x139.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2019/09/tworenders-1024x476.png" decoding="async" class="aligncenter wp-image-5880 size-full jetpack-lazy-image" src="../Images/f8b44788548576863be029a7e0718f9e.png" alt="Initial render and additional two re-renders" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2019/09/tworenders.png 1416w, https://blog.logrocket.com/wp-content/uploads/2019/09/tworenders-300x139.png 300w, https://blog.logrocket.com/wp-content/uploads/2019/09/tworenders-768x357.png 768w, https://blog.logrocket.com/wp-content/uploads/2019/09/tworenders-1024x476.png 1024w" data-lazy-sizes="(max-width: 1416px) 100vw, 1416px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2019/09/tworenders.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/09/tworenders.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="5880" data-permalink="https://blog.logrocket.com/simplifying-state-management-in-react-apps-with-batched-updates/tworenders/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2019/09/tworenders.png" data-orig-size="1416,658" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="tworenders" data-image-description="&lt;p&gt;Initial render and additional two re-renders&lt;/p&gt;&#10;" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2019/09/tworenders-300x139.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2019/09/tworenders-1024x476.png" decoding="async" loading="lazy" class="aligncenter wp-image-5880 size-full" src="../Images/f8b44788548576863be029a7e0718f9e.png" alt="Initial render and additional two re-renders" srcset="https://blog.logrocket.com/wp-content/uploads/2019/09/tworenders.png 1416w, https://blog.logrocket.com/wp-content/uploads/2019/09/tworenders-300x139.png 300w, https://blog.logrocket.com/wp-content/uploads/2019/09/tworenders-768x357.png 768w, https://blog.logrocket.com/wp-content/uploads/2019/09/tworenders-1024x476.png 1024w" sizes="(max-width: 1416px) 100vw, 1416px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/09/tworenders.png"/></noscript>
<p>但是，如果您刷新页面并单击第二个按钮，您会看到初始呈现和仅一次重新呈现，尽管仍然有两次对状态的更新:</p>
<p><img data-attachment-id="5881" data-permalink="https://blog.logrocket.com/simplifying-state-management-in-react-apps-with-batched-updates/initialrenderandonererender/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2019/09/Initialrenderandonererender.png" data-orig-size="1380,556" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Initialrenderandonererender" data-image-description="&lt;p&gt;Initial render and only one re-render&lt;/p&gt;&#10;" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2019/09/Initialrenderandonererender-300x121.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2019/09/Initialrenderandonererender-1024x413.png" decoding="async" class="aligncenter wp-image-5881 size-full jetpack-lazy-image" src="../Images/df22b1cfe2b2569490faf7435cf62ce5.png" alt="Initial render and only one re-render" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2019/09/Initialrenderandonererender.png 1380w, https://blog.logrocket.com/wp-content/uploads/2019/09/Initialrenderandonererender-300x121.png 300w, https://blog.logrocket.com/wp-content/uploads/2019/09/Initialrenderandonererender-768x309.png 768w, https://blog.logrocket.com/wp-content/uploads/2019/09/Initialrenderandonererender-1024x413.png 1024w" data-lazy-sizes="(max-width: 1380px) 100vw, 1380px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2019/09/Initialrenderandonererender.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/09/Initialrenderandonererender.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="5881" data-permalink="https://blog.logrocket.com/simplifying-state-management-in-react-apps-with-batched-updates/initialrenderandonererender/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2019/09/Initialrenderandonererender.png" data-orig-size="1380,556" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Initialrenderandonererender" data-image-description="&lt;p&gt;Initial render and only one re-render&lt;/p&gt;&#10;" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2019/09/Initialrenderandonererender-300x121.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2019/09/Initialrenderandonererender-1024x413.png" decoding="async" loading="lazy" class="aligncenter wp-image-5881 size-full" src="../Images/df22b1cfe2b2569490faf7435cf62ce5.png" alt="Initial render and only one re-render" srcset="https://blog.logrocket.com/wp-content/uploads/2019/09/Initialrenderandonererender.png 1380w, https://blog.logrocket.com/wp-content/uploads/2019/09/Initialrenderandonererender-300x121.png 300w, https://blog.logrocket.com/wp-content/uploads/2019/09/Initialrenderandonererender-768x309.png 768w, https://blog.logrocket.com/wp-content/uploads/2019/09/Initialrenderandonererender-1024x413.png 1024w" sizes="(max-width: 1380px) 100vw, 1380px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/09/Initialrenderandonererender.png"/></noscript>
<p>为什么可能呢？因为React在已知的方法中自动批量更新，在本例中是一个<a href="https://blog.logrocket.com/a-guide-to-react-onclick-event-handlers-d411943b14dd/" target="_blank" rel="noopener noreferrer">事件处理程序</a>。请随意使用<a href="https://codesandbox.io/s/batched-update-snippet1-4wuk8" target="_blank" rel="noopener noreferrer">演示</a>亲自测试功能:</p>
<p/>
<p>当您在一个承诺中包含多个状态调用时，就像上面的例子一样，您可以强制React进行批量更新，因此只会导致一次重新呈现。这可以通过包装调用以更新<code>*ReactDOM.unstable_batchedUpdates()*</code>中的状态来实现，如下所示:</p>
<pre>function handleClickWithPromise() {
    Promise.resolve().then(() =&gt; {
      ReactDOM.unstable_batchedUpdates(() =&gt; {
        setItem1("Updated Item 1");
        setItem2("Updated Item 2");
      });
    });
  }</pre>
<p>接下来，用上面的片段更新<a href="https://codesandbox.io/s/batched-update-snippet1-4wuk8" target="_blank" rel="noopener noreferrer">之前的演示</a>上的<code>handleClickWithPromise()</code>函数，就像我们目前在这个<a href="https://codesandbox.io/s/objective-surf-bs3ky" target="_blank" rel="noopener noreferrer">沙箱</a>上的一样。现在，如果你点击第一个按钮，更新将被批量处理，导致只有一个渲染。如果您查看您的控制台，您应该会在单击第一个按钮后看到以下内容:</p>
<p><img data-attachment-id="5884" data-permalink="https://blog.logrocket.com/simplifying-state-management-in-react-apps-with-batched-updates/renderconsole/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2019/09/renderconsole.png" data-orig-size="1378,576" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="renderconsole" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2019/09/renderconsole-300x125.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2019/09/renderconsole-1024x428.png" decoding="async" class="aligncenter wp-image-5884 size-full jetpack-lazy-image" src="../Images/453d530c8892df7e7f320e36f2bc6be7.png" alt="" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2019/09/renderconsole.png 1378w, https://blog.logrocket.com/wp-content/uploads/2019/09/renderconsole-300x125.png 300w, https://blog.logrocket.com/wp-content/uploads/2019/09/renderconsole-768x321.png 768w, https://blog.logrocket.com/wp-content/uploads/2019/09/renderconsole-1024x428.png 1024w" data-lazy-sizes="(max-width: 1378px) 100vw, 1378px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2019/09/renderconsole.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/09/renderconsole.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="5884" data-permalink="https://blog.logrocket.com/simplifying-state-management-in-react-apps-with-batched-updates/renderconsole/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2019/09/renderconsole.png" data-orig-size="1378,576" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="renderconsole" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2019/09/renderconsole-300x125.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2019/09/renderconsole-1024x428.png" decoding="async" loading="lazy" class="aligncenter wp-image-5884 size-full" src="../Images/453d530c8892df7e7f320e36f2bc6be7.png" alt="" srcset="https://blog.logrocket.com/wp-content/uploads/2019/09/renderconsole.png 1378w, https://blog.logrocket.com/wp-content/uploads/2019/09/renderconsole-300x125.png 300w, https://blog.logrocket.com/wp-content/uploads/2019/09/renderconsole-768x321.png 768w, https://blog.logrocket.com/wp-content/uploads/2019/09/renderconsole-1024x428.png 1024w" sizes="(max-width: 1378px) 100vw, 1378px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/09/renderconsole.png"/></noscript>
<p>这不像上次我们点击第一个按钮时有两次重新渲染(有承诺)。作为在<code>*ReactDOM.unstable_batchedUpdates()*</code>中包装更新状态调用的结果，我们获得了与第二个按钮完全相同的功能(没有承诺)。</p>
<p>正如我前面提到的，如果你使用<code>*unstable_batchedUpdates()*</code>，请记住这是一个实现细节。React的未来版本可能会将此作为默认行为，您不必使用不稳定的API。</p>
<h2>该不该用？</h2>
<p>这个方法的名字确实让人有点担心在生产中使用是否安全。然而，React团队已经<a href="https://github.com/facebook/react/issues/16377" target="_blank" rel="noopener noreferrer">鼓励过</a>(在撰写本文时，仍然如此)在适当的时候使用这个API。因此，可以肯定地说，虽然“不稳定”，但它足够稳定，可以用于今天的生产。</p>
<h2>何时使用它</h2>
<p>如果您需要多次调用来更新状态，就像上面的例子一样，您可能会发现有一种更好的方法。根据我的经验，在大多数情况下，我看到开发人员进行多次调用来更新状态，这些调用可以很容易地被一次调用所取代。让我们来看一些实例，在这些实例中，您可能会多次调用来更新状态。</p>
<pre>this.setState({ ...this.state, foo: 42 });
if (condition) {
    this.setState({ ...this.state, isBar: true });
}</pre>
<p>可以重构上面的代码，用一个调用来更新状态，如下所示:</p>
<pre>let newState = { this.state, foo: 42 };
if (condition) {
    newState = { ...this.state, isBar: true };
}
this.setState(newState);</pre>
<p>当然，你正在创建一个全新的变量，这没关系。通常，正如我们前面看到的，React会自动批量更新某些函数，而不是其他函数。因此，当您试图将调用次数减少到<code>setState</code>时，您应该慎重考虑。</p>
<p>另一种需要多次调用来更新状态的情况是:</p>
<pre>// Increment foo
this.setState({ ...this.state, foo: this.state.foo + 1 });
this.setState({ ...this.state, foo: this.state.foo + 1 });</pre>
<p>在这种情况下，随后的调用会利用先前调用所产生的更新值。同样，上面的代码可以这样重构:</p>
<pre>function incrementFooBy(delta) {
    return (previousState, currentProps) =&gt; {
        return { ...previousState, foo: previousState.foo + delta };
    };
}
this.setState(incrementFooBy(2));</pre>
<p>这里，我们使用currying来根据先前的状态和预期的更改“编写”更新内容，然后将值传递给<code>this.setState</code>。</p>
<h2>它适用于钩子吗？</h2>
<p>这可能是你想问的一个问题，所以让我就此打住，说是的。随着<a href="https://blog.logrocket.com/frustrations-with-react-hooks/" target="_blank" rel="noopener noreferrer">钩子</a>的引入，我看到了很多这样的案例。考虑下面这个例子:</p>
<pre>const [value, updateValue] = useState({});
const [anotherValue, updateAnotherValue] = useState({});

updateValue({ content: "Hello" });
updateAnotherValue({ content: "World" });</pre>
<p>有时当你使用钩子时，你会发现自己在一个单一的功能组件中创建了多个状态对象。如果你这样做，这可能是一个信号，表明你的功能组件违反了单一责任原则，做了不止一件事。如果多个状态对象放在一起有意义，那么您应该将这些值组合成一个状态对象，如下所示:</p>
<pre>const [allValues, updateAllValues] = useState({});

updateAllValues({firstContent: "Hello", secondContent: "World" });</pre>
<p>或者将两个状态对象分离成它们自己独立的功能组件，如果它们在一起没有意义的话。如果你不属于上面提到的任何一种情况，那么我认为你应该使用<code>*unstable_batchedUpdates*</code>。</p>
<p>我觉得有必要提一下，进行多次调用来更新状态并没有那么糟糕，特别是因为React在某些情况下会自动批量更新，而在其他情况下，它并不会真正产生任何性能问题。因此，如果你发现自己需要使用<code>*unstable_batchedUpdates*</code>，那么你一定处于非常罕见的情况。</p>
<h2>会被弃用吗？</h2>
<p>根据Dan Abramov对Stackoverflow问题的回复:</p>
<p>“但是，我们不会在次要版本中删除[<code>unstable_batchedUpdates</code>]，因此在React 17之前，如果您需要在React事件处理程序之外的某些情况下强制批处理，您可以放心地依赖它。”</p>
<p>他对Github问题的另一个评论是:</p>
<p>“这是预期的行为，因为我们目前只在已知的反应范围内批量更新(例如，在同步生命周期方法期间，或在事件处理程序期间)。如上所述，您可以使用<code>unstable_batchedUpdates</code>来解决这个问题。未来，批处理将在任何地方默认开启。”</p>
<p>截至撰写本文时，官方路线图博客帖子中没有提到任何React版本中的<code>unstable_batchedUpdates</code>将被弃用，除了Dan的评论之外，也没有太多信息更准确地说明API何时将被弃用。</p>
<h2>最后的想法</h2>
<p>在这篇文章中，我们仔细研究了批量更新特性，并展示了它如何简化React应用程序中的语句管理和呈现过程。提到了这个featured目前还不稳定，值得注意的是目前可以使用。首先，只需将状态调用放入传递给<code>*ReactDOM.unstable_batchedUpdates*</code>的回调函数中。</p><div class="code-block code-block-17">
<div class="blog-plug inline-plug react-plug" vwo-el-id="26283398190">
<h2 vwo-el-id="41600691720">使用LogRocket消除传统反应错误报告的噪音</h2>
<a href="https://lp.logrocket.com/blg/react-signup-issue-free" target="_blank" vwo-el-id="19356441070">LogRocket
</a><p>是一款React analytics解决方案，可保护您免受数百个误报错误警报的影响，只针对少数真正重要的项目。LogRocket告诉您React应用程序中实际影响用户的最具影响力的bug和UX问题。</p><a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="19356441380">
<img class="first-react-image alignnone size-full wp-image-46 jetpack-lazy-image jetpack-lazy-image--handled" src="../Images/f300c244a1a1cf916df8b4cb02bec6c6.png" vwo-el-id="18272717540" data-lazy-loaded="1" data-original-src="https://files.readme.io/27c94e7-Image_2017-06-05_at_9.46.04_PM.png"/>
</a>
<a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="19356441690">
<img class="second-react-image alignnone size-full wp-image-46 jetpack-lazy-image jetpack-lazy-image--handled" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" vwo-el-id="30720362350" data-lazy-loaded="1" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/>
</a>
<a href="https://lp.logrocket.com/blg/react-signup-issue-free" target="_blank" rel="noopener noreferrer" vwo-el-id="35866400580">LogRocket
</a><p>自动聚合客户端错误、反应错误边界、还原状态、缓慢的组件加载时间、JS异常、前端性能指标和用户交互。然后，LogRocket使用机器学习来通知您影响大多数用户的最具影响力的问题，并提供您修复它所需的上下文。</p><p vwo-el-id="28675661060">关注重要的React bug—<a class="signup" href="https://lp.logrocket.com/blg/react-signup-issue-free" target="_blank" rel="noopener noreferrer" vwo-el-id="40093418840">今天就试试LogRocket】。</a></p>
</div></div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
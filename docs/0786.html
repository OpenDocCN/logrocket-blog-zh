<html>
<head>
<title>How to build an SVG circular progress component using React and React Hooks - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>如何使用React和React Hooks构建SVG循环进度组件</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/build-svg-circular-progress-component-react-hooks/#0001-01-01">https://blog.logrocket.com/build-svg-circular-progress-component-react-hooks/#0001-01-01</a></blockquote><div><article class="article-post">
<p><em> <strong>编者按:</strong>本文最后一次更新是在2022年7月22日，通过React的最新版本来更新代码和示例。</em></p>
<p>进度条指示web和移动应用程序上的活动，如文件上传、下载、数据加载等。这种视觉表现对增强应用程序的UX大有帮助。</p>
<p>在本教程中，我们将演示使用SVG为React创建一个简单的、可定制的、易于使用的循环进度指示器。我们将在不依赖外部的情况下这样做。</p>
<p>下面是我们将构建的循环进度组件的可视化表示:</p>
<p><img data-attachment-id="125550" data-permalink="https://blog.logrocket.com/build-svg-circular-progress-component-react-hooks/attachment/visual-representation-of-circular-progress-indicator-created-with-svg-and-react/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/04/Visual-representation-of-Circular-Progress-Indicator-created-with-SVG-and-React.png" data-orig-size="800,450" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Visual representation of Circular Progress Indicator created with SVG and React" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/04/Visual-representation-of-Circular-Progress-Indicator-created-with-SVG-and-React-300x169.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/04/Visual-representation-of-Circular-Progress-Indicator-created-with-SVG-and-React.png" decoding="async" class="size-full wp-image-125550 aligncenter jetpack-lazy-image" src="../Images/5944fcbb7a30dbd24ecd7b68441aa3dc.png" alt="Visual representation of Circular Progress Indicator created with SVG and React" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2020/04/Visual-representation-of-Circular-Progress-Indicator-created-with-SVG-and-React.png 800w, https://blog.logrocket.com/wp-content/uploads/2020/04/Visual-representation-of-Circular-Progress-Indicator-created-with-SVG-and-React-300x169.png 300w, https://blog.logrocket.com/wp-content/uploads/2020/04/Visual-representation-of-Circular-Progress-Indicator-created-with-SVG-and-React-768x432.png 768w" data-lazy-sizes="(max-width: 800px) 100vw, 800px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2020/04/Visual-representation-of-Circular-Progress-Indicator-created-with-SVG-and-React.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/04/Visual-representation-of-Circular-Progress-Indicator-created-with-SVG-and-React.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="125550" data-permalink="https://blog.logrocket.com/build-svg-circular-progress-component-react-hooks/attachment/visual-representation-of-circular-progress-indicator-created-with-svg-and-react/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/04/Visual-representation-of-Circular-Progress-Indicator-created-with-SVG-and-React.png" data-orig-size="800,450" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Visual representation of Circular Progress Indicator created with SVG and React" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/04/Visual-representation-of-Circular-Progress-Indicator-created-with-SVG-and-React-300x169.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/04/Visual-representation-of-Circular-Progress-Indicator-created-with-SVG-and-React.png" decoding="async" loading="lazy" class="size-full wp-image-125550 aligncenter" src="../Images/5944fcbb7a30dbd24ecd7b68441aa3dc.png" alt="Visual representation of Circular Progress Indicator created with SVG and React" srcset="https://blog.logrocket.com/wp-content/uploads/2020/04/Visual-representation-of-Circular-Progress-Indicator-created-with-SVG-and-React.png 800w, https://blog.logrocket.com/wp-content/uploads/2020/04/Visual-representation-of-Circular-Progress-Indicator-created-with-SVG-and-React-300x169.png 300w, https://blog.logrocket.com/wp-content/uploads/2020/04/Visual-representation-of-Circular-Progress-Indicator-created-with-SVG-and-React-768x432.png 768w" sizes="(max-width: 800px) 100vw, 800px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/04/Visual-representation-of-Circular-Progress-Indicator-created-with-SVG-and-React.png"/></noscript>
<p>由于这个项目与圆有很大关系，所以我将其命名为SVG Pi。你可以在<a href="https://github.com/c99rahul/SVG-Pi" target="_blank" rel="noopener"> this GitHub repo </a>中参考本教程的完整源代码。</p>
<p>让我们开始吧！</p>
<h3>内容</h3>

<h2 id="why-use-svg">嘿，美国SVG？</h2>
<p>缩写“SVG”的阐述揭示了这个问题的正确答案。SVG代表可缩放矢量图形，无论屏幕分辨率如何，它都能提供完美的像素渲染。</p>
<p>在现代前端开发中，png和gif被认为不适合图标和加载器等应用资产。SVGs可以完美地完成这项工作；这里有一些支持这一观点的要点。</p>
<h3>可量测性</h3>
<p>矢量图形与分辨率无关，并提供完美的像素体验。</p>
<h3>交互性</h3>
<p>使用CSS和JavaScript向SVG添加无限的交互效果和动画是可能的。</p>
<h3>展开性</h3>
<p>因为SVG是基于XML的，所以我们可以在任何需要的时候向SVG添加不同的外来元素，包括HTML。</p>
<h3>可嵌入</h3>
<p>SVG很容易嵌入到HTML文档中。甚至CSS也支持各种几何和表示属性作为属性。</p>
<h3>轻量级选手</h3>
<p>尽管SVG具有可伸缩性和交互性，但文件大小通常很小。</p>
<h3>搜索引擎优化友好</h3>
<p>因为SVG是基于XML的，所以它们支持在任何合适的地方添加关键字和描述，这比HTML图像通常的alt标记好得多。</p>
<h3>易于编辑</h3>
<p>一旦理解了SVG的基础，就可以像编辑XML文件一样编辑它们了。</p>
<h3>受到广泛支持</h3>
<p>几乎所有现代网络和移动浏览器都支持SVG。点击了解更多关于支持和兼容性的信息<a href="https://caniuse.com/svg" target="_blank" rel="noopener">。</a></p>
<p>从图像到交互性，现代前端开发广泛使用了SVG。考虑到它们的灵活性和广泛的应用领域，为您的项目学习和采用SVG也是一个不错的主意。</p>
<h2 id="building-circular-progress-bar-indicator-svg">用SVG构建圆形进度条指示器</h2>
<p>在我们深入JavaScript部分之前，让我们先来看看SVG解决循环进度指示器问题的技术细节。</p>
<p>我们可以用两个重叠的圆环状形状来制作这样的指示器，其中一个作为轨道，另一个作为进度指示器。</p>
<p>请看下图，它展示了这两个圆圈的作用。</p>
<p><img data-attachment-id="125553" data-permalink="https://blog.logrocket.com/build-svg-circular-progress-component-react-hooks/attachment/circle-progress-loader-with-two-rings/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/04/circle-progress-loader-with-two-rings.png" data-orig-size="800,450" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="circle progress loader with two rings" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/04/circle-progress-loader-with-two-rings-300x169.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/04/circle-progress-loader-with-two-rings.png" decoding="async" class="size-full wp-image-125553 aligncenter jetpack-lazy-image" src="../Images/18eb40db4ae91f128ffe79d87b3410cb.png" alt="circle progress loader with two rings" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2020/04/circle-progress-loader-with-two-rings.png 800w, https://blog.logrocket.com/wp-content/uploads/2020/04/circle-progress-loader-with-two-rings-300x169.png 300w, https://blog.logrocket.com/wp-content/uploads/2020/04/circle-progress-loader-with-two-rings-768x432.png 768w" data-lazy-sizes="(max-width: 800px) 100vw, 800px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2020/04/circle-progress-loader-with-two-rings.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/04/circle-progress-loader-with-two-rings.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="125553" data-permalink="https://blog.logrocket.com/build-svg-circular-progress-component-react-hooks/attachment/circle-progress-loader-with-two-rings/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/04/circle-progress-loader-with-two-rings.png" data-orig-size="800,450" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="circle progress loader with two rings" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/04/circle-progress-loader-with-two-rings-300x169.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/04/circle-progress-loader-with-two-rings.png" decoding="async" loading="lazy" class="size-full wp-image-125553 aligncenter" src="../Images/18eb40db4ae91f128ffe79d87b3410cb.png" alt="circle progress loader with two rings" srcset="https://blog.logrocket.com/wp-content/uploads/2020/04/circle-progress-loader-with-two-rings.png 800w, https://blog.logrocket.com/wp-content/uploads/2020/04/circle-progress-loader-with-two-rings-300x169.png 300w, https://blog.logrocket.com/wp-content/uploads/2020/04/circle-progress-loader-with-two-rings-768x432.png 768w" sizes="(max-width: 800px) 100vw, 800px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/04/circle-progress-loader-with-two-rings.png"/></noscript>
<p>让我们尝试用一些简单的SVG元素和它们不同的属性创建类似的东西。从标记开始，添加两个圆形元素，如下所示:</p>
<pre class="language-css hljs">&lt;svg class="svg-indicator"&gt;
  &lt;circle class="svg-indicator-track" /&gt;
  &lt;circle class="svg-indicator-indication" /&gt;
&lt;/svg&gt;
</pre>
<p/>
<p>我在这两个圆圈中添加了一些CSS类，因为它们的大多数表示属性在CSS中作为属性可用。我们现在只打算用CSS来操作这两个元素。</p>
<p>我们需要确保以下几点，使这些圈像进度指示器一样协同工作:</p>
<ol>
<li>两个看起来都像戒指</li>
<li>两者共享同一个中心</li>
<li>两者半径相同</li>
<li>第一个环充当轨道</li>
<li>第二个表现为进度指示，看起来更像一个环的一部分</li>
</ol>
<p>透明填充加上一些笔画颜色和宽度会让圆圈看起来像圆环。</p>
<p>注意，<code>cx</code>和<code>cy</code>属性共同定义了SVG圆的中心，而<code>r</code>属性定义了它的半径。这两个circle元素应该以完全相同的方式应用这三个值。</p>
<p>一旦我们定义了圆的大小和笔画宽度，我们就可以很容易地确定它们的中心和半径。以下是基于这一理论的一些计算:</p>
<pre class="language-css hljs">size = 100
strokeWidth = 10
center = size / 2
       = 100 / 2 = 50
radius = center - strokeWidth 
       = 50 - 10 = 40
</pre>
<p>简单的<a href="https://en.wikipedia.org/wiki/Circle" target="_blank" rel="noopener">圆数学</a>。让我们根据前面的计算为我们的指示器环编写一些CSS样式:</p>
<pre class="language-css hljs">/* Define the size */
.svg-indicator {
  width: 100px;
  height: 100px;
}

/* 
 * Add the center and the radius using the size 
 * and `stroke-width` values.
 */
.svg-indicator-track,
.svg-indicator-indication {
  cx: 50px;
  cy: 50px;
  r: 40px;
  fill: transparent;
  stroke-width: 10px;
}

/* Some color to highlight the rings */
.svg-indicator-track {
  stroke: #ddd;
}

.svg-indicator-indication {
  stroke: #07c;
}</pre>
<blockquote class="embedly-card" data-card-controls="1" data-card-align="center" data-card-theme="light">

<p>添加外部样式表/笔此处添加的任何URL都将按顺序添加，并放在编辑器中的CSS之前。通过使用其URL和适当的URL扩展名，您可以使用另一个笔中的CSS。JavaScript预处理器巴贝尔包括JSX处理。</p>
</blockquote>
<p/>
<p>正如你在上面看到的，我们的指示器只显示指示器环，而轨迹环隐藏在它的后面。只有当进度达到100%时，它才会看起来像这样。</p>
<p>为了准备好任何给定的进度值，让我们利用<code>stroke-dasharray</code>和<code>stroke-dashoffset</code>属性。</p>
<h3><code>stroke-dasharray</code></h3>
<p>属性允许我们给SVG笔画一个类似破折号的外观。更高的<code>dasharray</code>值表示笔画中虚线之间的空间更大，直到它达到等于相关形状周长的值。</p>
<blockquote class="embedly-card" data-card-controls="1" data-card-align="center" data-card-theme="light">

<p>添加外部样式表/笔此处添加的任何URL都将按顺序添加，并放在编辑器中的CSS之前。通过使用其URL和适当的URL扩展名，您可以使用另一个笔中的CSS。JavaScript预处理器巴贝尔包括JSX处理。</p>
</blockquote>
<p/>
<p>如上所示，笔画中的破折号根据提供给<code>stroke-dasharray</code>属性的值而变化。</p>
<h3><code>stroke-dashoffset</code></h3>
<p><code>stroke-dashoffset</code>属性与<code>stroke-dasharray</code>一起指定破折号在SVG路径上的开始位置。随着这个数字的增加，破折号将出现在路径的更远处。</p>
<blockquote class="embedly-card" data-card-controls="1" data-card-align="center" data-card-theme="light">

<p>添加外部样式表/笔此处添加的任何URL都将按顺序添加，并放在编辑器中的CSS之前。通过使用其URL和适当的URL扩展名，您可以使用另一个笔中的CSS。JavaScript预处理器巴贝尔包括JSX处理。</p>
</blockquote>
<p/>
<p>上面的演示显示虚线笔画的起点与<code>stroke-dashoffset</code>属性的值成比例移动。</p>
<h3>带有<code>dasharray</code>和<code>dashoffset</code>的指示逻辑</h3>
<p>基本的圆几何学认为一个环的弧的长度等于它的周长。在将周长作为值提供给<code>stroke-dasharray</code>属性后，您将观察到<a href="https://codepen.io/_rahul/pen/xxWwBLL" target="_blank" rel="noopener">没有变化</a>。</p>
<p>但是你会注意到，如果你给属性<code>stroke-dashoffset</code>相同的值，虚线笔画会从视图中消失。这就是我们希望进度指示器显示零进度的方式。</p>
<p>让我们重新审视我们的圆形计算，并添加一些数据，以便我们可以评估任何给定进度值所需的移动:</p>
<pre class="language-css hljs">size = 100
strokeWidth = 10
center = size / 2
       = 100 / 2 = 50
radius = center - strokeWidth 
       = 50 - 10 = 40
progress = 0
arcLength = 2 * π * radius 
          = 2 * 3.14 * 40 = 251.2
arcOffset = arcLength * ((100 - progress)/100) 
          = 251.2 * ((100 - 0)/100) = 251.2
</pre>
<p>假设我们的进度指示器显示25%的进度。以下是如何计算该数字的适当指示值:</p>
<pre class="language-css hljs">progress = 25
arcOffset = arcLength * ((100 - progress)/100) 
          = 251.2 * ((100 - 25)/100) = 188.4
</pre>
<p>将如此获得的移位值添加到指示环的<code>stroke-dashoffset</code>属性，我们得到以下输出。</p>
<blockquote class="embedly-card" data-card-controls="1" data-card-align="center" data-card-theme="light">

<p>添加外部样式表/笔此处添加的任何URL都将按顺序添加，并放在编辑器中的CSS之前。通过使用其URL和适当的URL扩展名，您可以使用另一个笔中的CSS。JavaScript预处理器巴贝尔包括JSX处理。</p>
</blockquote>
<p/>
<p>这看起来就像我们戒指的四分之一，或者25 %!让我们也逆时针旋转它，像时钟一样将指示原点移动到顶部。</p>
<blockquote class="embedly-card" data-card-controls="1" data-card-align="center" data-card-theme="light">

<p>没有描述</p>
</blockquote>
<p>以上是我们通过不同进度值的战略转移得到的SVG进度指标。我使用了<code>stroke-linecap</code>属性使进度环看起来是圆形的。</p>
<p>添加我们的进度组件进行反应</p>
<h2 id="adding-progress-component-react">第一步是创建一个以节点为主要需求的React app。</h2>
<p>打开一个终端，cd进入您想要添加项目的目录。现在，键入以下命令:</p>
<p>如果<code>npx</code>命令花费太多时间，你也可以考虑使用yarn。安装完成后，使用您选择的任何IDE打开项目。</p>
<pre class="language-shell hljs">npx create-react-app react-progress-bar
</pre>
<p>我们的React项目有一个包含所有组件的<code>src</code>目录。目前，我们只有内部的<code>App</code>组件。</p>
<p>使用<code>npm start</code>命令运行应用程序时，您会在浏览器窗口中看到虚拟应用程序，这是我们不想要的。</p>
<p>下一部分包括清除所有虚拟数据和添加我们的默认设置。</p>
<p>清除默认值</p>
<h3><code>index.css</code>文件携带了全局应用的样式。清除其内容并添加新内容，以便更好地重新启动到默认样式:</h3>
<p>与<code>App.css</code>文件相同，用这些新的CSS样式替换所有内容，使应用程序与屏幕中间对齐:</p>
<pre class="language-css hljs">:root {
  box-sizing: border-box;
}

*,
*:after,
*:before {
  box-sizing: inherit;
}

body {
  margin: 0;
  font: 1em/1.618 sans-serif;
  background-color: #fff;
}

svg {
  max-width: 100%;
  vertical-align: middle;
}
</pre>
<p>我不是在这里硬衬东西；如果您对CSS布局和对齐属性感到满意，可以随意自定义CSS文件。</p>
<pre class="language-css hljs">.App {
  max-width: 800px;
  margin: 0 auto;
}

.App-content {
  padding: 3em;
}

.App-loading,
.App-content-loading {
  min-height: 100vh;
  display: flex;
  align-items: center;
  justify-content: center;
}
</pre>
<p>从<code>App.js</code>开始清除所有看起来不必要的东西。这里的要点是在我们开始描绘我们的React应用程序之前有一个清晰的画布:</p>
<p>如上面的代码所示，我们使用了功能组件，当与不同的React挂钩配对时，这些功能组件使事情变得容易得多。</p>
<pre class="language-js hljs">import "./App.css"

const App = () =&gt; {
  return (
    &lt;div class="App"&gt;
      ...
    &lt;/div&gt;
  )
}

export default App
</pre>
<p>随着开发的深入，我们将会在这些文件中添加更多的内容。</p>
<p>进度组件设置</p>
<h3>是时候在React中实现我们用SVG做的任何事情了。让我们在src目录中创建一个名为<code>components</code>的子目录，以保持井然有序。</h3>
<p>同样，在我们的组件目录中创建另一个名为<code>ProgressBar</code>的文件，包含两个名为<code>ProgressBar.js</code>和<code>ProgressBar.css</code>的文件。</p>
<p>让我们开始制作<code>ProgressBar</code>组件，添加常规的React和样式表导入、组件定义，然后是导出语句:</p>
<p>从形状和大小到标签和动画，我们的<code>ProgressBar</code>组件中会有很多道具。以下是所有这些属性的列表:</p>
<pre class="language-js hljs">import "./ProgressBar.css"

const ProgressBar = () =&gt; {
  ...
}

export default ProgressBar
</pre>
<p><code>label</code>定义指标组件中除数字进度数据以外的文本信息</p>
<ul>
<li><code>labelColor</code>控制由标签定义的信息的颜色</li>
<li><code>spinnerMode</code>是一个布尔值，通过将CSS关键帧动画类切换到ProgressBar组件来控制不确定行为；它默认为假</li>
<li><code>spinnerSpeed</code>管理循环动画的速度</li>
<li><code>progress</code>采用数字数据以百分比方式显示进度信息</li>
<li><code>indicatorColor</code>是进度指示的颜色</li>
<li><code>indicatorCap</code>控制进度指示的圆形和平滑形状；它接受对<code>stroke-linecap</code> SVG属性有效的所有三个值</li>
<li><code>size</code>向组件添加尺寸</li>
<li><code>trackColor</code>负责轨道环的着色</li>
<li><code>indicatorWidth</code>管理指示环的厚度</li>
<li><code>trackWidth</code>负责轨道环的厚度</li>
<li>与其将它们逐个定义为参数，不如使用JavaScript的对象析构，如下所示。如果你愿意，你也可以根据需要用React <code>propTypes</code>对它们进行类型检查和标记:</li>
</ul>
<p>是时候对我们的组件应用圆计算了。稍后返回SVG指示器元素时，将进一步使用这些计算:</p>
<pre class="language-js hljs">...

const ProgressBar = (props) =&gt; {
  let {
    size = 150,
    progress = 0,
    trackWidth = 10,
    trackColor = `#ddd`,
    indicatorWidth = 10,
    indicatorColor = `#07c`,
    indicatorCap = `round`,
    label = `Loading...`,
    labelColor = `#333`,
    spinnerMode = false,
    spinnerSpeed = 1
  } = props

...
</pre>
<p>我们的指示器组件的结构类似于我们前面的例子。将它包装在division中是一个好主意，这样可以防止我们应用于SVG元素的转换与标签信息的对齐发生冲突。</p>
<pre class="language-css hljs">...

const ProgressBar = props =&gt; {
  ...

  const center = size / 2,
        radius = center - (trackWidth &gt; indicatorWidth ? trackWidth : indicatorWidth),
        dashArray = 2 * Math.PI * radius,
        dashOffset = dashArray * ((100 - progress) / 100)}

...
</pre>
<p>为了更好的控制和实用，现在最好使用SVG属性而不是CSS属性。注意，JSX支持用camelCase而不是kebab-case编写的HTML和SVG属性。</p>
<p>除了包装器大小调整和SVG属性处理，我还为不确定进度指示器变化的指示环添加了一些旋转动画逻辑:</p>
<p>条件标签信息将是一个不错的小补充。我们还要注意当指示器尺寸太小或旋转动画被钩住时没有意义的百分比加载:</p>
<pre class="language-css hljs">...

const ProgressBar = props =&gt; {
  ...

  return (
    &lt;&gt;
      &lt;div
        className="svg-pi-wrapper"
        style={{ width: size, height: size }}
      &gt;
        &lt;svg
          className="svg-pi" 
          style={{ width: size, height: size }}
        &gt;
          &lt;circle
            className="svg-pi-track"
            cx={center}
            cy={center}
            fill="transparent"
            r={radius}
            stroke={trackColor}
            strokeWidth={trackWidth}
          /&gt;
          &lt;circle
            className={`svg-pi-indicator ${
              spinnerMode ? "svg-pi-indicator--spinner" : ""
            }`}
            style={{ animationDuration: spinnerSpeed * 1000 }}
            cx={center}
            cy={center}
            fill="transparent"
            r={radius}
            stroke={indicatorColor}
            strokeWidth={indicatorWidth}
            strokeDasharray={dashArray}
            strokeDashoffset={dashOffset}
            strokeLinecap={indicatorCap}
          /&gt;
        &lt;/svg&gt;
      &lt;/div&gt;
    &lt;/&gt;
  )
}
</pre>
<p>最后，让我们给<code>ProgressBar.css</code>添加一些CSS，其中大部分取自我们之前的例子。这段CSS的关键作用是正确对齐事物，固定指示器的方向，并添加旋转动画支持，为此我们在上面的代码中制作了一个可切换的控件:</p>
<pre class="language-css hljs">...

const ProgressBar = props =&gt; {
  ...

  let hideLabel = (size &lt; 100 || !label.length || spinnerMode) ? true : false

  return (
    &lt;&gt;
      &lt;div
        className="svg-indicator-wrapper"
        ...
      &gt;
        &lt;svg
          ...
        &gt;
          ...
        &lt;/svg&gt;

        {!hideLabel &amp;&amp; (
          &lt;div 
            className="svg-pi-label" 
            style={{ color: labelColor }}
          &gt;
            &lt;span className="svg-pi-label__loading"&gt;
              {label}
            &lt;/span&gt;

            {!spinnerMode &amp;&amp; (
              &lt;span className="svg-pi-label__progress"&gt;
                {`${
                  progress &gt; 100 ? 100 : progress
                }%`}
              &lt;/span&gt;
            )}
          &lt;/div&gt;
        )}
      &lt;/div&gt;
    &lt;/&gt;
  )
}

export default ProgressBar
</pre>
<p>使用React挂钩的<code>ProgressBar</code>组件</p>
<pre class="language-css hljs">.svg-pi-wrapper {
  position: relative;
}

.svg-pi {
  transform: rotate(-90deg); /* Fix the orientation */
}

/* Animated spinner version */
.svg-pi-indicator--spinner {
  animation: spinner .75s linear infinite;
  transform-origin: center;
}

.svg-pi-label {
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  text-align: center;
}

.svg-pi-label__loading {
  opacity: .5;
  font-size: 0.75em;
}

.svg-pi-label__progress {
  font-size: 1.5em;
  font-weight: bold;
}

.svg-pi-label__loading,
.svg-pi-label__progress {
  display: block;
}

/* Spinner animation */
@keyframes spinner {
  0% {
    transform: rotate(0)
  }
  100% {
    transform: rotate(360deg)
  }
}
</pre>
<h2 id="progressbar-component-action-react-hooks">是时候将新鲜出炉的<code>ProgressBar</code>组件导入到我们的空白<code>App.js</code>中，并为其设置动作了。</h2>
<p>让我们在所需组件完成加载之前，在应用程序开始时显示进度指示器。这里最好使用两个广泛使用的React钩子来控制加载显示以及进度指示器的数字数据。</p>
<p>您可能已经知道，<code>useEffect</code>钩子负责在React中执行不同的副作用，而不会影响组件渲染。</p>
<p>在这种情况下，<code>useState</code>钩子保持加载和进度状态，我们在<code>useEffect</code>的帮助下根据计时功能和最大进度值来操作这些状态。</p>
<p>因此，进度和加载状态自动成为<code>useEffect</code>钩子的两个依赖项。</p>
<p>将<code>loadingDuration</code>除以100可确保进度指示器正确显示，并以受控的方式显示确定的指示器:</p>
<p>最后，让我们根据当前的加载状态返回适当的组件。当<code>loading</code>设置为真时，我们返回<code>ProgressBar</code>组件。当它改变时，我们返回一个不同的组件给DOM:</p>
<pre class="language-js hljs">import {useState, useEffect} from 'react'
import ProgressBar from "./components/ProgressBar/ProgressBar"
import "./App.css"

const App = () =&gt; {
  const [loading, setLoading] = useState(true)
  const [progress, setProgress] = useState(0)
  const loadingDuration = 3000 // 3 seconds

  useEffect(() =&gt; {
    let loadingTimeout = setTimeout(() =&gt; {
      if (loading &gt;= 100) return
      setProgress(progress + 1)
    }, loadingDuration/100)
    if (progress === 100) {
      setLoading(false)
    }
    return () =&gt; {
      clearTimeout(loadingTimeout)
    }
  }, [progress, loading])

  return (
    ...
  )
}

export default App
</pre>
<p>没有描述</p>
<pre class="language-css hljs">...

const App = () =&gt; {
  ...

  return (
    &lt;div className="App"&gt;
      {loading ? (
        &lt;ProgressBar progress={progress} trackWidth={5} indicatorWidth={10} /&gt;
      ) : (
        &lt;div
          className="App-content"
        &gt;
          &lt;p&gt;...&lt;/p&gt;
        &lt;/div&gt;
      )}
    &lt;/div&gt;
  )
}

...</pre>
<blockquote class="embedly-card" data-card-controls="1" data-card-align="center" data-card-theme="light">

<p>注意，如果你从上面的代码中删除了<code>loadingDuration</code>逻辑，进度指示器仍然会显示出来，但是<a href="https://codepen.io/_rahul/pen/GRxpadM" target="_blank" rel="noopener">会有点难以注意到</a>。</p>
</blockquote>
<p>获取数据时显示<code>ProgressBar</code>组件</p>
<p>让我们在网络呼叫期间使用ProgressBar组件。大部分实现保持不变，但是我们将在前面的例子中添加数据获取逻辑。</p>
<h2 id="showing-progressbar-component-fetching-data">我正在使用<a href="https://jsonplaceholder.typicode.com/" target="_blank" rel="noopener">假的JSON占位符API </a>来获取一些数据到我们的应用程序中。同样，我们将使用<code>useEffect</code>钩子访问API，并在我们的应用程序中显示获取的数据。目标是同时显示一个进度指示器:</h2>
<p>让我们也加入从API获取的数据。我们将在这里使用<code>postData</code>的当前状态，如果那里有任何数据，我们将列出它，否则将显示一个<code>ProgressBar</code>。</p>
<p>这是最终结构的样子:</p>
<pre class="language-js hljs">...

// The fake JSON Placeholder API url
const postUrl = `https://jsonplaceholder.typicode.com/posts`

const App = () =&gt; {
  const [postData, setPostData] = React.useState(true)
  const postUrl = `https://jsonplaceholder.typicode.com/posts`

  // Network call
  useEffect(() =&gt; {
    const getUsers = async () =&gt; {
      try {
        await fetch(postUrl)
          .then((res) =&gt; res.json())
          .then((data) =&gt; {
            setPostData(data)
          })
      } catch (e) {
        console.log(e)
      }
    }
    getUsers()
  }, [])

  return (
    ...  
  )
}

...
</pre>
<p>没有描述</p>
<p>要更清楚地注意旋转进度指示器，请在浏览器的开发工具中进入<strong>网络</strong>标签，选择一个较慢的连接。</p>
<pre class="language-js hljs">...

const App = () =&gt; {
  ...

  return (
    &lt;div className="App"&gt;
      {postData.length ? (
        &lt;div className="App-content"&gt;
          &lt;h2&gt;Dummy posts&lt;/h2&gt;
          &lt;ul className="App-post-list"&gt;
            {postData.map(({ id, title, body }) =&gt; (
              &lt;li key={id} className={id}&gt;
                &lt;h3&gt;{title}&lt;/h3&gt;
                &lt;p&gt;{body}&lt;/p&gt;
              &lt;/li&gt;
            ))}
          &lt;/ul&gt;
        &lt;/div&gt;
      ) : (
        &lt;ProgressBar
          trackColor="#333"
          indicatorColor="#f7c"
          size={50}
          progress={25}
          trackWidth={5}
          indicatorWidth={5}
          spinnerMode={true}
        /&gt;
      )}
    &lt;/div&gt;
  )
}

export default App
</pre>
<blockquote class="embedly-card" data-card-controls="1" data-card-align="center" data-card-theme="light">

<p><img data-attachment-id="125555" data-permalink="https://blog.logrocket.com/build-svg-circular-progress-component-react-hooks/attachment/observing-the-progress-indicator-on-a-slower-connection/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/04/Observing-the-progress-indicator-on-a-slower-connection.png" data-orig-size="800,450" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Observing the progress indicator on a slower connection" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/04/Observing-the-progress-indicator-on-a-slower-connection-300x169.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/04/Observing-the-progress-indicator-on-a-slower-connection.png" decoding="async" class="size-full wp-image-125555 aligncenter jetpack-lazy-image" src="../Images/a00b8a528179f7668c961650c712e9d9.png" alt="Observing the progress indicator on a slower connection" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2020/04/Observing-the-progress-indicator-on-a-slower-connection.png 800w, https://blog.logrocket.com/wp-content/uploads/2020/04/Observing-the-progress-indicator-on-a-slower-connection-300x169.png 300w, https://blog.logrocket.com/wp-content/uploads/2020/04/Observing-the-progress-indicator-on-a-slower-connection-768x432.png 768w" data-lazy-sizes="(max-width: 800px) 100vw, 800px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2020/04/Observing-the-progress-indicator-on-a-slower-connection.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/04/Observing-the-progress-indicator-on-a-slower-connection.png"/></p>
</blockquote>
<p>结论</p>
<p>现在，您应该很好地理解了如何使用SVG创建一个定制的循环进度指示器，然后使用<code>useState</code>和<code>useEffect</code>钩子在React应用程序中实现它。</p>
<p>这些指示器在React页面转换时看起来很棒，但是我们将在另一篇文章中讨论。或者随意尝试一下。我建议您将CSS转换添加到指示器中，然后尝试在React实现中修复它所添加的延迟。</p><noscript><img data-lazy-fallback="1" data-attachment-id="125555" data-permalink="https://blog.logrocket.com/build-svg-circular-progress-component-react-hooks/attachment/observing-the-progress-indicator-on-a-slower-connection/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/04/Observing-the-progress-indicator-on-a-slower-connection.png" data-orig-size="800,450" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Observing the progress indicator on a slower connection" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/04/Observing-the-progress-indicator-on-a-slower-connection-300x169.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/04/Observing-the-progress-indicator-on-a-slower-connection.png" decoding="async" loading="lazy" class="size-full wp-image-125555 aligncenter" src="../Images/a00b8a528179f7668c961650c712e9d9.png" alt="Observing the progress indicator on a slower connection" srcset="https://blog.logrocket.com/wp-content/uploads/2020/04/Observing-the-progress-indicator-on-a-slower-connection.png 800w, https://blog.logrocket.com/wp-content/uploads/2020/04/Observing-the-progress-indicator-on-a-slower-connection-300x169.png 300w, https://blog.logrocket.com/wp-content/uploads/2020/04/Observing-the-progress-indicator-on-a-slower-connection-768x432.png 768w" sizes="(max-width: 800px) 100vw, 800px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/04/Observing-the-progress-indicator-on-a-slower-connection.png"/></noscript>
<h2>在这个<a href="https://github.com/c99rahul/SVG-Pi" target="_blank" rel="noopener"> GitHub repo </a>中，您可以随意使用本教程中示例的完整源代码。感谢你从头到尾的阅读！</h2>
<p><a href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener"> LogRocket </a>:全面了解您的生产React应用</p>
<p>调试React应用程序可能很困难，尤其是当用户遇到难以重现的问题时。如果您对监视和跟踪Redux状态、自动显示JavaScript错误以及跟踪缓慢的网络请求和组件加载时间感兴趣，</p>
<p>. </p><div class="code-block code-block-17">
<div class="blog-plug inline-plug react-plug" vwo-el-id="26283398190">
<h2 vwo-el-id="41600691720">LogRocket 结合了会话回放、产品分析和错误跟踪，使软件团队能够创建理想的web和移动产品体验。这对你来说意味着什么？</h2><p>LogRocket不是猜测错误发生的原因，也不是要求用户提供截图和日志转储，而是让您回放问题，就像它们发生在您自己的浏览器中一样，以快速了解哪里出错了。</p><a href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" vwo-el-id="19356441070">try LogRocket</a><p>不再有嘈杂的警报。智能错误跟踪允许您对问题进行分类，然后从中学习。获得有影响的用户问题的通知，而不是误报。警报越少，有用的信号越多。</p><a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="19356441380">
<img class="first-react-image alignnone size-full wp-image-46 jetpack-lazy-image jetpack-lazy-image--handled" src="../Images/f300c244a1a1cf916df8b4cb02bec6c6.png" vwo-el-id="18272717540" data-lazy-loaded="1" data-original-src="https://files.readme.io/27c94e7-Image_2017-06-05_at_9.46.04_PM.png"/>
</a>
<a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="19356441690">
<img class="second-react-image alignnone size-full wp-image-46 jetpack-lazy-image jetpack-lazy-image--handled" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" vwo-el-id="30720362350" data-lazy-loaded="1" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/>
</a>
<p vwo-el-id="28675660440" class="">LogRocket Redux中间件包为您的用户会话增加了一层额外的可见性。LogRocket记录Redux存储中的所有操作和状态。</p>
<p>现代化您调试React应用的方式— <a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="40093418840">开始免费监控</a>。</p>
<p> No more noisy alerting. Smart error tracking lets you triage and categorize issues, then learns from this. Get notified of impactful user issues, not false positives. Less alerts, way more useful signal.
</p>
<p vwo-el-id="28675660750">The LogRocket Redux middleware package adds an extra layer of visibility into your user sessions. LogRocket logs all actions and state from your Redux stores.
</p>
<p vwo-el-id="28675661060">Modernize how you debug your React apps —
<a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="40093418840">start monitoring for free</a>.
</p>
</div></div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
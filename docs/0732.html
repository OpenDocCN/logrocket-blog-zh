<html>
<head>
<title>Simplify React state management with Kea - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>使用Kea - LogRocket博客简化React状态管理</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/simplify-react-state-management-with-kea/#0001-01-01">https://blog.logrocket.com/simplify-react-state-management-with-kea/#0001-01-01</a></blockquote><div><article class="article-post">
<p>有几种方法可以在React组件之间共享数据。首先，我们可以通过props将数据从父母传递给孩子。React还具有上下文API，可以在具有任何关系的组件之间传递数据，只要我们将上下文提供者组件包装在React组件内，我们就可以在这些组件之间共享数据。</p>
<p>我们还有全球状态管理解决方案，如<a href="https://redux.js.org/" target="_blank" rel="noopener noreferrer"> Redux </a>和<a href="https://mobx.js.org/README.html" target="_blank" rel="noopener noreferrer"> MobX </a>，让我们可以在整个应用程序中轻松共享数据。</p>
<p>任何想要获得状态的最新值的组件都可以订阅带有全局状态管理解决方案的数据存储。</p>
<p>另一个状态管理解决方案是<a href="https://kea.js.org/" target="_blank" rel="noopener noreferrer"> Kea </a>，它的工作方式类似于Redux。我们可以订阅用Kea创建的存储来获取数据并设置最新状态。Kea是由Redux驱动的，所以很多概念，比如reducers和stores也将与Kea一起使用。</p>
<p>在本文中，我们将了解如何在React应用程序中使用Kea作为全局状态管理解决方案。</p>
<h2>基本状态管理</h2>
<p>我们可以通过运行以下命令，使用create -react-app创建一个应用程序:</p>
<pre>npx create-react-app kea-app</pre>
<p>然后我们就可以安装Kea需要的库了，就是Kea本身，Redux，React-Redux。为了安装它们，我们运行以下代码:</p>
<pre>npm i kea redux react-redux reselect</pre>
<p>然后，我们可以通过编写以下代码，使用Kea编写一个简单的应用程序，作为我们应用程序范围的全局状态管理解决方案:</p>
<pre>//index.js
import React from "react";
import ReactDOM from "react-dom";
import { resetContext, getContext } from "kea";
import { Provider } from "react-redux";
resetContext({
  createStore: {},
  plugins: []
});

import App from "./App";

const rootElement = document.getElementById("root");
ReactDOM.render(
  &lt;Provider store={getContext().store}&gt;
    &lt;App /&gt;
  &lt;/Provider&gt;,
  rootElement
);
</pre>
<pre>//App.js
import React from "react";
import { kea, useActions, useValues } from "kea";

const logic = kea({
  actions: () =&gt; ({
    setName: name =&gt; ({ name })
  }),

  reducers: ({ actions }) =&gt; ({
    name: [
      "",
      {
        [actions.setName]: (_, payload) =&gt; payload.name
      }
    ]
  })
});

const Name = () =&gt; {
  const { name } = useValues(logic);
  return &lt;p&gt;{name}&lt;/p&gt;;
};

export default function App() {
  const { setName } = useActions(logic);
  return (
    &lt;div className="App"&gt;
      &lt;input onChange={e =&gt; setName(e.target.value)} /&gt;
      &lt;Name /&gt;
    &lt;/div&gt;
  );
}
</pre>
<p>在上面的代码中，我们导入了React Redux的<code>Provider</code>组件，然后将其包装在整个应用程序中，让Kea作为应用程序范围的状态管理库。</p>
<p>然而，我们将<code>getContext().store</code>作为商店的值传入，而不是像我们通常做的那样作为Redux商店。我们将<code>createStore</code>和<code>plugins</code>属性保留为一个空对象，并在传递给<code>resetContext</code>的对象中包含一个数组，因为我们没有使用任何插件，并且在创建商店时没有更改任何选项。</p>
<p>然后在<code>App.js</code>中，我们用<code>kea</code>函数创建一个对象，它具有我们将在商店中使用的逻辑。它包括为我们的存储检索和设置值的逻辑。</p>
<p>我们在<code>App.js</code>中有以下内容来创建<code>logic</code>对象，我们将使用它从存储中读取和写入值:</p>
<pre>const logic = kea({
  actions: () =&gt; ({
    setName: name =&gt; ({ name })
  }),

  reducers: ({ actions }) =&gt; ({
    name: [
      "",
      {
        [actions.setName]: (_, payload) =&gt; payload.name
      }
    ]
  })
});</pre>
<p>我们有带有方法的<code>actions</code>属性，我们将使用这些方法来设置存储中的<code>name</code>状态的值。<code>reducers</code>属性将动作名作为对象的键。</p>
<p>reducer数组的第一个条目是它的默认值。</p>
<p>它使用函数名作为reducer函数的标识符，我们在reducer数组的第二个条目的对象中有这个函数。像Redux reducer一样，我们用reducer函数返回我们想要在存储中设置的值。</p>
<p>然后我们通过调用Kea的<code>useActions</code>函数和传入的<code>logic</code>对象来设置存储中的<code>name</code>值。它有<code>setName</code>方法，我们可以用它返回的对象调用它。</p>
<p>在<code>App</code>的输入元素中，我们调用<code>setName</code>将<code>name</code>的值设置为输入的值。</p>
<p>然后在<code>Name</code>组件中，我们调用Kea的<code>useValues</code>方法，使用我们之前创建的<code>logic</code>对象作为参数，然后从存储中获取<code>name</code>值并呈现它。</p>
<p>因此，输入到输入中的文本将显示在其下方的<code>Name</code>组件中。</p>
<h2>听众</h2>
<p>侦听器是在调度操作后运行的函数。如果我们希望能够取消侦听器中的这些操作，它们会很有用。</p>
<p>要使用它，我们可以通过运行以下命令来添加<code>kea-listeners</code>包:</p>
<pre>npm i kea-listeners</pre>
<p>我们可以用它来监听Kea正在执行的操作，然后用它来触发另一个操作，如下所示:</p>
<pre>//index.js
import React from "react";
import ReactDOM from "react-dom";
import { resetContext, getContext } from "kea";
import { Provider } from "react-redux";
import listeners from "kea-listeners";
import App from "./App";

resetContext({
  createStore: {},
  plugins: [listeners]
});

const rootElement = document.getElementById("root");
ReactDOM.render(
  &lt;Provider store={getContext().store}&gt;
    &lt;App /&gt;
  &lt;/Provider&gt;,
  rootElement
);
</pre>
<pre>//App.js
import React from "react";
import { kea, useActions, useValues } from "kea";

const logic = kea({
  actions: () =&gt; ({
    setCount: count =&gt; ({ count }),
    setDoubleCount: doubleCount =&gt; ({ doubleCount })
  }),

  listeners: ({ actions, values, store, sharedListeners }) =&gt; ({
    [actions.setCount]: ({ count }) =&gt; {
      actions.setDoubleCount(count * 2);
    }
  }),

  reducers: ({ actions }) =&gt; ({
    count: [
      0,
      {
        [actions.setCount]: (_, payload) =&gt; payload.count
      }
    ],
    doubleCount: [
      0,
      {
        [actions.setDoubleCount]: (_, payload) =&gt; payload.doubleCount
      }
    ]
  })
});

const Count = () =&gt; {
  const { count, doubleCount } = useValues(logic);
  return (
    &lt;p&gt;
      {count} {doubleCount}
    &lt;/p&gt;
  );
};

export default function App() {
  const { count } = useValues(logic);
  const { setCount } = useActions(logic);
  return (
    &lt;div className="App"&gt;
      &lt;button onClick={() =&gt; setCount(count + 1)}&gt;Increment&lt;/button&gt;
      &lt;Count /&gt;
    &lt;/div&gt;
  );
</pre>
<p>在上面的代码中，我们通过将<code>listeners</code>插件添加到数组中来添加<code>listeners</code>插件，我们将该数组设置为<code>index.js</code>中<code>plugins</code>属性的值。</p>
<p>然后我们可以监听正在<code>listeners</code>属性中运行的<code>actions.setCount</code>动作。将<code>listeners</code>属性设置为一个对象，该对象接受具有<code>actions</code>、<code>values</code>、<code>store</code>和<code>sharedListeners</code>属性的对象。</p>
<p>在上面的例子中，我们通过使用<code>actions</code>属性访问action方法来调用<code>setDoubleCount</code>动作。</p><div class="code-block code-block-54">
<hr/>
<h3>更多来自LogRocket的精彩文章:</h3>

<hr/></div>
<p>我们还定义了<code>doubleCount</code>缩减器，这样我们就可以像上面一样调用<code>setDoubleCount</code>动作来更新<code>doubleCount</code>状态的值。然后在<code>Count</code>组件中，我们用<code>logic</code>调用<code>useValues</code>来获取<code>count</code>和<code>doubleCount</code>并显示值。</p>
<p>因此，当我们单击Increment按钮时，我们得到一个递增1的计数，即<code>count</code>，另一个递增2的计数，即<code>doubleCount</code>。</p>
<h2>取消操作</h2>
<p>我们可以添加一个<code>breakpoint</code>方法调用，它返回一个等待指定毫秒数的承诺，如果再次调用相同的操作，我们可以取消该操作。</p>
<p>例如，我们可以编写以下代码来创建一个可取消的操作:</p>
<pre>//App.js
import React from "react";
import { kea, useActions, useValues } from "kea";

const logic = kea({
  actions: () =&gt; ({
    setName: name =&gt; ({ name }),
    setResult: result =&gt; ({ result })
  }),
  listeners: ({ actions, values, store, sharedListeners }) =&gt; ({
    [actions.setName]: async ({ name }, breakpoint) =&gt; {
      await breakpoint(3000);
      const res = await fetch(`https://api.agify.io?name=${name}
      `);
      breakpoint();
      actions.setResult(await res.json());
    }
  }),

  reducers: ({ actions }) =&gt; ({
    name: [
      "",
      {
        [actions.setName]: (_, payload) =&gt; payload.name
      }
    ],
    result: [
      "",
      {
        [actions.setResult]: (_, payload) =&gt; payload.result
      }
    ]
  })
});

export default function App() {
  const { result } = useValues(logic);
  const { setName } = useActions(logic);
  return (
    &lt;div className="App"&gt;
      &lt;input onChange={e =&gt; setName(e.target.value)} /&gt;
      &lt;button onClick={() =&gt; setName("")}&gt;Cancel&lt;/button&gt;
      &lt;p&gt;{result.name}&lt;/p&gt;
    &lt;/div&gt;
  );
}
</pre>
<p>在上面的代码中，我们有一个带<code>actions.setName</code>键的方法，它被设置为一个<code>async</code>函数，并接受一个<code>breakpoint</code>函数。我们调用<code>breakpoint</code>函数，等待3000毫秒，让我们取消请求。</p>
<p>我们还有一个取消按钮，它也调用<code>setName</code>动作，让我们取消动作。当第二次调用<code>setName</code>动作时，第二个断点调用中断取消动作。</p>
<h2>萨迦</h2>
<p>要将sagas合并到Kea中，我们必须通过运行以下命令来安装Redux-Saga和Kea Saga包:</p>
<pre>npm install --save kea-saga redux-saga</pre>
<p>然后，我们可以添加传奇，并使用它们与Kea如下:</p>
<pre>//index.js
import React from "react";
import ReactDOM from "react-dom";
import { resetContext, getContext } from "kea";
import { Provider } from "react-redux";
import sagaPlugin from "kea-saga";
import App from "./App";
resetContext({
  createStore: true,
  plugins: [sagaPlugin({ useLegacyUnboundActions: false })]
});

const rootElement = document.getElementById("root");
ReactDOM.render(
  &lt;Provider store={getContext().store}&gt;
    &lt;App /&gt;
  &lt;/Provider&gt;,
  rootElement
);</pre>
<p>在上面的代码中，我们添加了来自<code>kea-saga</code>的<code>sagaPlugin</code>作为我们的Kea插件。我们还必须将<code>createStore</code>设置为<code>true</code>,以便在我们的商店中使用传奇故事:</p>
<pre>//App.js
import React from "react";
import { kea, useActions, useValues } from "kea";
import { put } from "redux-saga/effects";

const logic = kea({
  actions: () =&gt; ({
    setCount: count =&gt; ({ count }),
    setDoubleCount: doubleCount =&gt; ({ doubleCount })
  }),
  start: function*() {
    console.log(this);
  },

  stop: function*() {},

  takeEvery: ({ actions }) =&gt; ({
    [actions.setCount]: function*({ payload: { count } }) {
      yield put(this.actions.setDoubleCount(count * 2));
    }
  }),

  reducers: ({ actions }) =&gt; ({
    count: [
      0,
      {
        [actions.setCount]: (_, payload) =&gt; payload.count
      }
    ],
    doubleCount: [
      0,
      {
        [actions.setDoubleCount]: (_, payload) =&gt; payload.doubleCount
      }
    ]
  })
});

const Count = () =&gt; {
  const { count, doubleCount } = useValues(logic);
  return (
    &lt;p&gt;
      {count} {doubleCount}
    &lt;/p&gt;
  );
};

export default function App() {
  const { setCount } = useActions(logic);
  const { count } = useValues(logic);
  return (
    &lt;div className="App"&gt;
      &lt;button onClick={() =&gt; setCount(count + 1)}&gt;Increment&lt;/button&gt;
      &lt;Count /&gt;
    &lt;/div&gt;
  );
}
</pre>
<p>在上面的代码中，我们在传递给<code>kea</code>函数的对象中有我们的saga方法。每次发出新值时都会调用<code>takeEvery</code>,所以我们可以用它来运行代码，就像我们上面做的另一个动作一样。</p>
<p>我们使用<code>yield</code>关键字来返回用于设置动作的值。<code>put</code>用于安排商场的行动调度。</p>
<p><code>this.actions.setDoubleCount(count * 2)</code>返回我们想要为<code>setDoubleCount</code>发出的值，因此<code>yield</code>和<code>put</code>一起将动作发送给<code>setDoubleCount</code>，并通过<code>useValue</code>钩子将值发送给我们的组件。</p>
<p><code>start</code>方法是一个生成器函数，当我们的存储初始化时会调用它，所以我们可以将任何存储初始化代码放入其中。</p>
<p>因此，当我们点击increment按钮时，<code>setCount</code>函数被调用，它更新存储中的<code>count</code>状态。然后调用<code>takeEvery</code>方法，该方法调度<code>setDoubleCount</code>动作。然后，该值被发出，并在<code>Count</code>组件中结束。</p>
<p>所以左边的数字会增加1，右边的数字会增加2。</p>
<h2>谢谢</h2>
<p>Thunks是Redux产生副作用的另一种方式。它让我们一次调度多个动作，也让我们用Redux运行异步代码。它在Kea做同样的事情。</p>
<p>要在Kea中使用Thunk，我们需要安装Kea Thunk和Redux Thunk软件包，如下所示:</p>
<pre>//index.js
import React from "react";
import ReactDOM from "react-dom";
import { resetContext, getContext } from "kea";
import { Provider } from "react-redux";
import thunkPlugin from "kea-thunk";
import App from "./App";
resetContext({
  createStore: true,
  plugins: [thunkPlugin]
});

const rootElement = document.getElementById("root");
ReactDOM.render(
  &lt;Provider store={getContext().store}&gt;
    &lt;App /&gt;
  &lt;/Provider&gt;,
  rootElement
);</pre>
<p> </p>
<pre>//App.js
import React from "react";
import { kea, useActions, useValues } from "kea";
const delay = ms =&gt; new Promise(resolve =&gt; window.setTimeout(resolve, ms));

const logic = kea({
  actions: () =&gt; ({
    setCount: count =&gt; ({ count }),
    setDoubleCount: doubleCount =&gt; ({ doubleCount })
  }),

  thunks: ({ actions, dispatch, getState }) =&gt; ({
    setCountAsync: async count =&gt; {
      await delay(1000);
      actions.setCount(count);
      await delay(1000);
      actions.setDoubleCount(count * 2);
    }
  }),

  reducers: ({ actions }) =&gt; ({
    count: [
      0,
      {
        [actions.setCount]: (state, payload) =&gt; payload.count
      }
    ],
    doubleCount: [
      0,
      {
        [actions.setDoubleCount]: (state, payload) =&gt; payload.doubleCount
      }
    ]
  })
});
const Count = () =&gt; {
  const { count, doubleCount } = useValues(logic);
  return (
    &lt;p&gt;
      {count} {doubleCount}
    &lt;/p&gt;
  );
};

export default function App() {
  const { setCountAsync } = useActions(logic);
  const { count } = useValues(logic);
  return (
    &lt;div className="App"&gt;
      &lt;button onClick={() =&gt; setCountAsync(count + 1)}&gt;Increment&lt;/button&gt;
      &lt;Count /&gt;
    &lt;/div&gt;
  );
}
</pre>
<p>在上面的代码中，我们用以下代码添加了<code>kea-thunk</code>插件:</p>
<pre>plugins: [thunkPlugin]</pre>
<p>然后在我们传递给<code>kea</code>函数的对象的<code>thunks</code>属性中，我们定义了thunk，它有一个异步<code>delay</code>函数来暂停thunk 1秒钟。然后我们调度<code>setCount</code>动作，并在调用<code>delay</code>后调度<code>setDoubleAction</code>再等待一秒钟。</p>
<p>我们不能用actions函数运行异步代码，因为它们应该是纯同步函数。</p>
<p>在分派动作时，使用thunks是运行异步代码的好方法。</p>
<p>最后，我们应该得到一个增量按钮，我们可以点击这个按钮，在按钮被点击后一秒钟增加<code>count</code>，两秒钟后增加<code>doubleCount</code>。</p>
<h2>结论</h2>
<p>对于状态管理，Kea是Redux的替代方案。它有各种插件来进行状态管理，比如sagas和thunks。</p>
<p>它的工作方式类似于Redux，并使用Redux作为其状态管理解决方案的基础。</p>
<p>它的工作原理是创建一个带有动作和减少器的存储。它们和Redux中的一样。此外，我们可以添加侦听器来侦听动作分派事件。我们也可以通过Kea的插件添加传奇和thunks。</p><div class="code-block code-block-17">
<div class="blog-plug inline-plug react-plug" vwo-el-id="26283398190">
<h2 vwo-el-id="41600691720"><a href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener"> LogRocket </a>:全面了解您的生产React应用</h2><p>调试React应用程序可能很困难，尤其是当用户遇到难以重现的问题时。如果您对监视和跟踪Redux状态、自动显示JavaScript错误以及跟踪缓慢的网络请求和组件加载时间感兴趣，</p><a href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" vwo-el-id="19356441070">try LogRocket</a><p>. </p><a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="19356441380">
<img class="first-react-image alignnone size-full wp-image-46 jetpack-lazy-image jetpack-lazy-image--handled" src="../Images/f300c244a1a1cf916df8b4cb02bec6c6.png" vwo-el-id="18272717540" data-lazy-loaded="1" data-original-src="https://files.readme.io/27c94e7-Image_2017-06-05_at_9.46.04_PM.png"/>
</a>
<a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="19356441690">
<img class="second-react-image alignnone size-full wp-image-46 jetpack-lazy-image jetpack-lazy-image--handled" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" vwo-el-id="30720362350" data-lazy-loaded="1" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/>
</a>
<p vwo-el-id="28675660440" class="">LogRocket 结合了会话回放、产品分析和错误跟踪，使软件团队能够创建理想的web和移动产品体验。这对你来说意味着什么？</p>
<p>LogRocket不是猜测错误发生的原因，也不是要求用户提供截图和日志转储，而是让您回放问题，就像它们发生在您自己的浏览器中一样，以快速了解哪里出错了。</p>
<p>不再有嘈杂的警报。智能错误跟踪允许您对问题进行分类，然后从中学习。获得有影响的用户问题的通知，而不是误报。警报越少，有用的信号越多。</p>
<p vwo-el-id="28675660750">LogRocket Redux中间件包为您的用户会话增加了一层额外的可见性。LogRocket记录Redux存储中的所有操作和状态。</p>
<p vwo-el-id="28675661060">现代化您调试React应用的方式— <a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="40093418840">开始免费监控</a>。</p>
</div></div>

<p class="clearfix"/>
<p class="clearfix"/>
 </article>

</div>    
</body>
</html>
<html>
<head>
<title>How to limit frontend bugs - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>如何限制前端程序错误</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/how-to-limit-front-end-bugs-27d5648dd3ee/#0001-01-01">https://blog.logrocket.com/how-to-limit-front-end-bugs-27d5648dd3ee/#0001-01-01</a></blockquote><div><article class="article-post">
<figure><img decoding="async" src="../Images/38b748eb95c609578171a5281a904011.png" data-height="576" data-width="1404" data-lazy-src="https://storage.googleapis.com/blog-images-backup/1*vsxmr94zqk6HnKXXsP9Z5A.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" class=" jetpack-lazy-image" data-original-src="https://storage.googleapis.com/blog-images-backup/1*vsxmr94zqk6HnKXXsP9Z5A.png"/><noscript><img data-lazy-fallback="1" decoding="async" src="../Images/38b748eb95c609578171a5281a904011.png" data-height="576" data-width="1404" data-original-src="https://storage.googleapis.com/blog-images-backup/1*vsxmr94zqk6HnKXXsP9Z5A.png"/></noscript></figure>
<p>bug让我们的用户不高兴，并减缓了我们产品的开发速度。我们产品的前端可以说比后端更不稳定，所以可能更容易出问题。那么，如何才能限制我们引入产品的前端bug呢？</p>
<figure/>
<h3>林挺</h3>
<p>林挺是发现有问题的模式或代码的过程，这些模式或代码不符合特定的风格指南。林挺规则可以在编写代码时由我们的代码编辑器自动运行，也是我们CI流程的一部分。因此，它有助于在生产高质量可读代码时强制执行这些代码。</p>
<p>林挺工具存在于许多编程语言中，包括JavaScript。事实上，在JavaScript世界中有一些linters，但是目前最流行的是<a href="https://eslint.org/" target="_blank" rel="noopener noreferrer"> ESLint </a>。</p>
<p>ESLint附带了许多适用于现代JavaScript代码的<a href="https://eslint.org/docs/rules/" target="_blank" rel="noopener noreferrer">规则</a>。我们可以在一个<code>.eslintrc</code> JSON文件中配置打开和关闭哪些规则，或者只是给我们一个警告，而不是让构建失败。我们也可以选择采用社区推荐的一套规则，而不是找出我们自己的一套规则来使用。</p>
<p>你能发现下面代码中的错误吗？</p>
<figure class="wp-caption"><img decoding="async" src="../Images/991edbe5a2f3d5cd4e97a47ce30c56dd.png" data-height="809" data-width="1400" data-lazy-src="https://storage.googleapis.com/blog-images-backup/0*mRL8Pd3s3aMoMAmu?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" class=" jetpack-lazy-image" data-original-src="https://storage.googleapis.com/blog-images-backup/0*mRL8Pd3s3aMoMAmu"/><noscript><img data-lazy-fallback="1" decoding="async" src="../Images/991edbe5a2f3d5cd4e97a47ce30c56dd.png" data-height="809" data-width="1400" data-original-src="https://storage.googleapis.com/blog-images-backup/0*mRL8Pd3s3aMoMAmu"/></noscript><figcaption class="wp-caption-text">Buggy JavaScript code</figcaption></figure>
<p>ESLint非常容易通过npm安装，并且有很多编辑器的插件，这些插件清楚地突出了linter已经发现的问题。看看下面的<a href="https://marketplace.visualstudio.com/items?itemName=dbaeumer.vscode-eslint" target="_blank" rel="noopener noreferrer"> ESLint扩展</a>中的<a href="https://code.visualstudio.com/" target="_blank" rel="noopener noreferrer">与</a>中的问题代码中的问题有多清晰:</p>
<figure class="wp-caption"><img decoding="async" src="../Images/90f96c04743e8e9c2701ac4d28dfacb9.png" data-height="318" data-width="480" data-lazy-src="https://storage.googleapis.com/blog-images-backup/0*6Z5cs_sQkxrMPATp?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" class=" jetpack-lazy-image" data-original-src="https://storage.googleapis.com/blog-images-backup/0*6Z5cs_sQkxrMPATp"/><noscript><img data-lazy-fallback="1" decoding="async" src="../Images/90f96c04743e8e9c2701ac4d28dfacb9.png" data-height="318" data-width="480" data-original-src="https://storage.googleapis.com/blog-images-backup/0*6Z5cs_sQkxrMPATp"/></noscript><figcaption class="wp-caption-text">ESLint helping us quickly resolve the bugs</figcaption></figure>
<p>没错，不止一个问题！</p>
<p>如果我们用TypeScript编写前端代码，那么<a href="https://palantir.github.io/tslint/" target="_blank" rel="noopener noreferrer"> TSLint </a>是一个很好的linter，我们可以用它来加强我们的风格指南。它的功能与ESLint非常相似——规则配置、预构建的规则集和强大的VS代码扩展。</p>
<p>林挺在任何前端项目中实现起来都相当简单，并且会带来显著的收益。所以，值得一试。</p>
<h3>自动代码格式化</h3>
<p>难道linter发现的一些样式问题不能被自动纠正吗？例如，工具可以自动添加丢失的分号吗？是啊！这就是代码格式化的用武之地。看看下面的代码:</p>
<figure class="wp-caption"><img decoding="async" src="../Images/e5c28223b26120f469ecd204a3af02d0.png" data-height="529" data-width="1400" data-lazy-src="https://storage.googleapis.com/blog-images-backup/0*9Q-7TVv0uV5vnFLS?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" class=" jetpack-lazy-image" data-original-src="https://storage.googleapis.com/blog-images-backup/0*9Q-7TVv0uV5vnFLS"/><noscript><img data-lazy-fallback="1" decoding="async" src="../Images/e5c28223b26120f469ecd204a3af02d0.png" data-height="529" data-width="1400" data-original-src="https://storage.googleapis.com/blog-images-backup/0*9Q-7TVv0uV5vnFLS"/></noscript><figcaption class="wp-caption-text">Unformatted code</figcaption></figure>
<p>这不是代码审查中最容易阅读的代码。代码是否包含bug？</p>
<p>是一个代码格式化工具，当我们签入源代码时，我们可以用它来自动格式化我们的代码。编辑器扩展，比如VS代码中的<a href="https://marketplace.visualstudio.com/items?itemName=esbenp.prettier-vscode" target="_blank" rel="noopener noreferrer">漂亮扩展</a>，也允许我们保存代码时自动格式化。</p>
<p>因此，只要将代码文件保存在VS代码中，我们就可以将代码转换成可读性更好的东西:</p>
<figure class="wp-caption"><img decoding="async" src="../Images/7037b0903a6333b141cef30b1cefd345.png" data-height="578" data-width="1400" data-lazy-src="https://storage.googleapis.com/blog-images-backup/0*4FzmZlu0vN0-RiiG?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" class=" jetpack-lazy-image" data-original-src="https://storage.googleapis.com/blog-images-backup/0*4FzmZlu0vN0-RiiG"/><noscript><img data-lazy-fallback="1" decoding="async" src="../Images/7037b0903a6333b141cef30b1cefd345.png" data-height="578" data-width="1400" data-original-src="https://storage.googleapis.com/blog-images-backup/0*4FzmZlu0vN0-RiiG"/></noscript><figcaption class="wp-caption-text">Code automatically formatted with prettier</figcaption></figure>
<p>代码格式化非常容易实现，与linter配合得很好，让我们更容易发现代码中的错误。</p>
<h3>静态类型检查</h3>
<p>静态类型还允许我们在编写代码时尽早发现问题。你能发现下面Javascript函数中的错误吗？</p>
<figure class="wp-caption"><img decoding="async" src="../Images/d9687d930d3dfe95f23c80d94a190d06.png" data-height="578" data-width="1400" data-lazy-src="https://storage.googleapis.com/blog-images-backup/0*W9exkdq6v_wZp_yQ?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" class=" jetpack-lazy-image" data-original-src="https://storage.googleapis.com/blog-images-backup/0*W9exkdq6v_wZp_yQ"/><noscript><img data-lazy-fallback="1" decoding="async" src="../Images/d9687d930d3dfe95f23c80d94a190d06.png" data-height="578" data-width="1400" data-original-src="https://storage.googleapis.com/blog-images-backup/0*W9exkdq6v_wZp_yQ"/></noscript><figcaption class="wp-caption-text">Buggy JavaScript code</figcaption></figure>
<p>有一个bug，我们引用了一个linter无法捕捉的响应对象，除非我们非常熟悉被调用的特定web API，否则我们很难发现这个bug。如果我们能够定义响应对象类型会怎么样？然后编译器可以检查我们是否正确引用了响应对象。嗯，这就是<a href="https://www.typescriptlang.org/" target="_blank" rel="noopener noreferrer"> TypeScript </a>允许我们做的事情！</p>
<p>现在，如果我们为响应对象添加一个类型，您能发现问题吗？</p>
<figure class="wp-caption"><img decoding="async" src="../Images/a58a416f04ac9939a9cd2734181dc4f0.png" data-height="260" data-width="480" data-lazy-src="https://storage.googleapis.com/blog-images-backup/0*WB4x_k1D4wIb2Z4E?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" class=" jetpack-lazy-image" data-original-src="https://storage.googleapis.com/blog-images-backup/0*WB4x_k1D4wIb2Z4E"/><noscript><img data-lazy-fallback="1" decoding="async" src="../Images/a58a416f04ac9939a9cd2734181dc4f0.png" data-height="260" data-width="480" data-original-src="https://storage.googleapis.com/blog-images-backup/0*WB4x_k1D4wIb2Z4E"/></noscript><figcaption class="wp-caption-text">TypeScript catching bugs</figcaption></figure>
<p>上面截图中的编辑器是VS Code，它有很好的TypeScript支持，用一个非常有用的错误消息尽可能快地突出了这个bug。</p>
<p>TypeScript在JavaScript之上构建了一个静态类型系统，目前非常流行。实际上，<a href="https://medium.com/the-vue-point/plans-for-the-next-iteration-of-vue-js-777ffea6fabf" target="_blank" rel="noopener noreferrer"> vue 3.x是用typescript </a>写的。</p>
<p>TypeScript编译器是高度可配置的，因此，无论我们是在一个全新的还是全新的项目中工作，我们都可以将TypeScript添加到组合中，并尽早开始捕捉错误。</p>
<h3>自动化测试</h3>
<p>林挺、代码格式化和静态类型检查并不需要在我们的项目中投入太多精力。另一方面，自动化测试确实需要相当大的努力，但是它们可以捕捉更复杂的错误，所以这种努力是值得的。</p>
<p>Jest是一个很棒的单元测试工具，我们可以用它来测试JavaScript函数和我们的前端组件。它在测试React应用程序时非常受欢迎。它具有有用的模拟功能，并在测试失败时给我们提供有用的错误消息:</p>
<figure class="wp-caption"><img decoding="async" src="../Images/738d03d5ee8dee5324efaee4ba658bed.png" data-height="428" data-width="606" data-lazy-src="https://storage.googleapis.com/blog-images-backup/0*Seaq84Cv9FeBRCkb?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" class=" jetpack-lazy-image" data-original-src="https://storage.googleapis.com/blog-images-backup/0*Seaq84Cv9FeBRCkb"/><noscript><img data-lazy-fallback="1" decoding="async" src="../Images/738d03d5ee8dee5324efaee4ba658bed.png" data-height="428" data-width="606" data-original-src="https://storage.googleapis.com/blog-images-backup/0*Seaq84Cv9FeBRCkb"/></noscript><figcaption class="wp-caption-text">Jest error information in the Terminal</figcaption></figure>
<p>当编写单元测试时，知道哪些代码区域没有被代码覆盖是很有用的。有了Jest，您只需添加<code>--coverage</code>选项就可以获得一份出色的代码覆盖率报告:</p>
<figure class="wp-caption"><img decoding="async" src="../Images/2c69f26f49dafdf09f43cf628996d5aa.png" data-height="333" data-width="695" data-lazy-src="https://storage.googleapis.com/blog-images-backup/0*tooPZ8VBTH9WHWwy?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" class=" jetpack-lazy-image" data-original-src="https://storage.googleapis.com/blog-images-backup/0*tooPZ8VBTH9WHWwy"/><noscript><img data-lazy-fallback="1" decoding="async" src="../Images/2c69f26f49dafdf09f43cf628996d5aa.png" data-height="333" data-width="695" data-original-src="https://storage.googleapis.com/blog-images-backup/0*tooPZ8VBTH9WHWwy"/></noscript><figcaption class="wp-caption-text">Code coverage report</figcaption></figure>
<p>然后，我们可以使用这些知识来帮助计划我们需要编写的未来单元测试。</p>
<p>单元测试给了我们信心，让我们相信应用程序中孤立的部分正在工作，并且随着应用程序的开发而继续工作。然而，他们并没有给我们很大的信心，让我们相信随着应用程序的发展，应用程序中的关键故事情节将继续正确运行。这就是端到端测试(ETE)的用武之地。Cypress是一个伟大的ETE测试工具，它允许我们用JavaScript构建测试。当调试一个失败的测试时，Cypress确实很出色，因为测试在浏览器内部运行，这意味着我们拥有Chrome DevTools的所有功能。</p>
<p>除了让我们相信我们的应用程序中的关键故事情节会继续工作，ETE测试通常更容易添加到现有的代码库中，因为它们与代码是分离的。ETE测试还可以快速覆盖我们应用程序的各个领域。ETE测试更脆弱，因为它们依赖于应用程序的所有层——应用程序所基于的数据的一点点变化都可能导致失败测试的雪崩，而没有捕捉到真正的错误。</p>
<p>因此，成本更高，但是健壮的单元测试和ETE测试的良好结合可以帮助林挺和类型检查没有捕捉到的回归。</p>
<h3>通过利用框架和库减少代码</h3>
<p>另一种减少代码中bug的方法是减少我们代码库的大小，并利用其他人久经沙场的代码。利用像React、Vue或Angular这样的框架将节省大量代码，更重要的是节省大量bug。这三个框架都有蓬勃发展的生态系统和强大的库来支持状态管理和漂亮的UI组件。</p>
<p>但是我们必须小心，引入大量的依赖项会膨胀我们的代码库，并留给我们一个真正具有挑战性的bug需要修复——性能！这让我们很好地预防了性能问题…</p><div class="code-block code-block-54">
<hr/>
<h3>更多来自LogRocket的精彩文章:</h3>

<hr/></div>
<h3>关注性能</h3>
<p>在开发我们的应用程序时，我们可以使用Chrome中强大的DevTools来帮助密切关注性能。</p>
<p>首先，我们可以使用网络面板来查看HTTP请求。有效载荷大吗？某个特定的资源是否被过于频繁地调用？大量的web请求或喋喋不休的web APIs会影响我们应用程序的性能。DevTools甚至让我们模拟我们的应用程序在慢速网络上运行，这可以真正突出这些类型的性能问题。</p>
<p>DevTools中实际上有一个特定的面板，用于在性能面板中分析性能。我们可以记录一段时间的应用使用情况，以获得性能相关信息的时间表，帮助我们发现并确定性能瓶颈所在。很有必要对您正在使用的应用程序进行分析，以检查性能是否有所下降。</p>
<p>解决性能问题的成本可能很高，因为这通常涉及到重构代码。因此，定期使用上述工具来及早发现这些问题是非常值得的。</p>
<h3>尽可能使用纯函数</h3>
<p>看看下面的代码:</p>
<figure class="wp-caption"><img decoding="async" src="../Images/00a62094cd9d65d74e0ea41803aa79d3.png" data-height="630" data-width="1110" data-lazy-src="https://storage.googleapis.com/blog-images-backup/0*lw5OHhVzlz0NhlQb?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" class=" jetpack-lazy-image" data-original-src="https://storage.googleapis.com/blog-images-backup/0*lw5OHhVzlz0NhlQb"/><noscript><img data-lazy-fallback="1" decoding="async" src="../Images/00a62094cd9d65d74e0ea41803aa79d3.png" data-height="630" data-width="1110" data-original-src="https://storage.googleapis.com/blog-images-backup/0*lw5OHhVzlz0NhlQb"/></noscript><figcaption class="wp-caption-text">Impure function</figcaption></figure>
<p>该函数接受一个对象，并返回相同的对象，字符串属性值转换为小写。你能发现代码的潜在问题吗？</p>
<p>嗯，根本问题是函数改变了传递给它的参数。代码的另一部分可能依赖于以原始状态传递的对象。这些都是微妙的错误，需要花费很高的成本来确定和修复。</p>
<p>这里显示了一个纯函数版本:</p>
<figure class="wp-caption"><img decoding="async" src="../Images/1928ab53a8fe380b63bdfd9d0a475ae2.png" data-height="666" data-width="1092" data-lazy-src="https://storage.googleapis.com/blog-images-backup/0*HFyMOnVyraWWqPNq?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" class=" jetpack-lazy-image" data-original-src="https://storage.googleapis.com/blog-images-backup/0*HFyMOnVyraWWqPNq"/><noscript><img data-lazy-fallback="1" decoding="async" src="../Images/1928ab53a8fe380b63bdfd9d0a475ae2.png" data-height="666" data-width="1092" data-original-src="https://storage.googleapis.com/blog-images-backup/0*HFyMOnVyraWWqPNq"/></noscript><figcaption class="wp-caption-text">Pure function</figcaption></figure>
<p>这个函数是纯粹的，因为它总是为给定的参数返回相同的值，并且不会产生任何副作用，比如改变参数。不改变参数意味着函数不会在我们代码的其他区域引起错误。</p>
<p>我们函数的第二个版本使用array <code>reduce</code>函数创建一个新对象，而不改变原始对象。其他有用的非变异数组函数有:</p>
<ul>
<li><code>concat</code> —用于添加数组项</li>
<li><code>filter</code> —用于移除数组项目</li>
<li><code>map</code> —用于改变数组项目</li>
</ul>
<h3>不同浏览器中的常规检查</h3>
<p>一个常见的需求是支持所有主流浏览器。如果我们在这个阵营中，并且正在使用一个我们以前没有用过的功能，我们可以在<a href="https://caniuse.com/" target="_blank" rel="noopener noreferrer">caniuse.com</a>查看它的浏览器支持。没有什么比写了一小段很酷的代码，然后发现IE不支持它更糟糕的了！</p>
<p>除了确保我们使用的功能与我们需要支持的浏览器兼容，我们还可以在开发应用程序时在不同的浏览器中进行抽查。像<a href="https://www.browserstack.com/" target="_blank" rel="noopener noreferrer"> BrowserStack </a>这样的工具使得在不同的浏览器中检查我们的应用程序变得超级简单。</p>
<h3>主动捕捉生产中的错误</h3>
<p>我们可以在开发我们的应用程序的同时做所有这些伟大的事情，但错误仍然可能进入生产。如果我们能够在用户报告之前发现生产中发生的错误并解决它们，这不是很好吗？这就是错误报告工具发挥作用的地方。有很多很棒的工具可供选择(包括<a href="https://logrocket.com/" target="_blank" rel="noopener noreferrer"> LogRocket </a>)。</p>
<h3>包裹</h3>
<p>所以，我们有很多方法可以减少前端代码中的错误。有些是速赢的，如代码格式化和林挺，有些是更重要的投资，如自动化测试。</p>
<p>限制bug并尽早捕获bug意味着用户更快乐，有更多的时间来创建酷功能！</p><div class="code-block code-block-21">
<div class="blog-plug inline-plug typescript-plug"><h2><a class="signup" href="https://lp.logrocket.com/blg/typescript-signup" target="_blank" rel="noopener noreferrer"> LogRocket </a>:全面了解您的网络和移动应用</h2>
<a href="https://lp.logrocket.com/blg/typescript-signup" class="signup" target="_blank" rel="noopener noreferrer"><img class="alignnone size-full wp-image-46 jetpack-lazy-image" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/><noscript><img data-lazy-fallback="1" class="alignnone size-full wp-image-46" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/></noscript></a>
<p>LogRocket 是一个前端应用程序监控解决方案，可以让您回放问题，就像问题发生在您自己的浏览器中一样。LogRocket不需要猜测错误发生的原因，也不需要向用户询问截图和日志转储，而是让您重放会话以快速了解哪里出错了。它可以与任何应用程序完美配合，不管是什么框架，并且有插件可以记录来自Redux、Vuex和@ngrx/store的额外上下文。</p>
<p>除了记录Redux操作和状态，LogRocket还记录控制台日志、JavaScript错误、堆栈跟踪、带有头+正文的网络请求/响应、浏览器元数据和自定义日志。它还使用DOM来记录页面上的HTML和CSS，甚至为最复杂的单页面和移动应用程序重新创建像素级完美视频。</p>
<a class="signup" href="https://lp.logrocket.com/blg/typescript-signup" target="_blank" rel="noopener noreferrer">Try it for free</a><p>.</p></div>
</div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
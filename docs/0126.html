<html>
<head>
<title>Writing robust Vue.js unit tests using Avoriaz - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>使用Avoriaz - LogRocket博客编写健壮的Vue.js单元测试</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/writing-unit-tests-in-vue-js-using-avoriaz-d449e3decdb6/#0001-01-01">https://blog.logrocket.com/writing-unit-tests-in-vue-js-using-avoriaz-d449e3decdb6/#0001-01-01</a></blockquote><div><div class="section-inner sectionLayout--insetColumn">
<h3 id="ef20" class="graf graf--h3 graf-after--figure">设置我们的环境</h3>
<p id="43a5" class="graf graf--p graf-after--h3">为了开始我们的项目，我们将使用<code>Vue-cli</code>。这将帮助我们跳过配置webpack的过程和所有其他复杂的过程。</p>
<p id="2dab" class="graf graf--p graf-after--p">如果没有安装<code>Vue-cli</code>，我们可以通过运行以下命令来安装:</p>
<pre id="ce27" class="graf graf--pre graf-after--p">npm install -g vue-cli</pre>
<p id="7de2" class="graf graf--p graf-after--pre">一旦我们安装了<code>vie-cli</code>，让我们继续创建应用程序。为此，我们运行:</p>
<pre id="30f2" class="graf graf--pre graf-after--p">vue init webpack unittest</pre>
<p id="08b4" class="graf graf--p graf-after--pre">在这个阶段，会提示您几个问题。您可以接受大多数的默认选项，唯一的要求是您回答“是”来包含vue-router，并回答“是”来设置Karma和Mocha的单元测试。</p>
<h3 id="13d9" class="graf graf--h3 graf-after--p">了解默认测试</h3>
<p id="8656" class="graf graf--p graf-after--h3">接下来，让我们来看看我们的<code>test\unit\specs\Hello.spec.js</code>。我们会注意到这段代码:</p>
<figure id="8efa" class="graf graf--figure graf--iframe graf-after--p"/>
<p id="782b" class="graf graf--p graf-after--figure">在上面的代码块中，我们会注意到:</p>
<ul class="postList">
<li id="33bc" class="graf graf--li graf-after--p">Vue库的导入</li>
<li id="65fa" class="graf graf--li graf-after--li">Hello组件的导入</li>
<li id="d563" class="graf graf--li graf-after--li">名为Hello.vue的测试描述</li>
<li id="2b6e" class="graf graf--li graf-after--li">一个单元测试说“应该呈现正确的内容”。在这个测试中，我们安装我们的组件，然后声明我们的<code>expect</code>函数，它检查输出是否等于我们所期望的。</li>
</ul>
<p id="4cf4" class="graf graf--p graf-after--li">注意，在上面的测试中，我们期望<code>hello</code>类下的<code>h1</code>标签的文本内容等于<code>welcome to Your Vue.js App</code></p>
<p id="1973" class="graf graf--p graf-after--p">这解释了编写Vue测试是多么简单。虽然这个方法很简单，但是有一个更简单的方法可以在Vue中编写测试。</p>
<h3 id="b1aa" class="graf graf--h3 graf-after--p">使用Avorias编写Vue测试</h3>
<p id="31a2" class="graf graf--p graf-after--h3">记得我提到过在Vue中编写单元测试有一个更简单的方法。我们到了。这个简单的方法是使用一个名为<code>avorias</code>的包。</p>
<p id="aaa5" class="graf graf--p graf-after--p">首先，我们需要安装软件包。为此，让我们运行以下命令。</p>
<pre id="6ef5" class="graf graf--pre graf-after--p"><code>// change directory to our folder
cd unittest
// install the avorias package
npm install avoriaz</code></pre>
<p id="9b38" class="graf graf--p graf-after--pre">现在让我们使用<code>avoriaz</code>重写默认的<code>hello</code>测试。为此，让我们删除<code>test\unit\specs\Hello.spec.js</code>文件，然后创建一个名为<code>test\unit\specs\Hello-avorias.spec.js</code>的新文件。</p>
<p id="0a09" class="graf graf--p graf-after--p">创建该文件后，让我们将它的内容替换为:</p>
<figure id="d0be" class="graf graf--figure graf--iframe graf-after--p"/>
<p id="b4ae" class="graf graf--p graf-after--figure">查看上面的代码块，我们注意到了与默认测试规范的以下不同之处</p>
<ul class="postList">
<li id="25d3" class="graf graf--li graf-after--p">我们在默认测试中导入mount，而不是Vue。这是因为avorias附带了一个mount helper函数，而不是扩展Vue，然后挂载它。</li>
<li id="7c05" class="graf graf--li graf-after--li">我们使用了<code>text()</code>函数，而不是使用<code>textContent </code>属性。这是因为avorias给了我们一个叫做<code>text()</code>的帮助函数</li>
</ul>
<h3 id="e878" class="graf graf--h3 graf-after--li">创建我们的可测试组件</h3>
<p id="a96e" class="graf graf--p graf-after--h3">让我们在<code>src\components</code>文件夹中创建一个名为<code>Happy.vue</code>的新文件，并粘贴以下内容:</p>
<figure id="d2bf" class="graf graf--figure graf--iframe graf-after--p"/>
<p id="c67d" class="graf graf--p graf-after--figure">让我们快速解释一下上面代码块中的内容。</p>
<ul class="postList">
<li id="1897" class="graf graf--li graf-after--p">我们的模板部分包含一个div(根元素),它包含一个循环的<code>h1</code>标签。</li>
<li id="91b8" class="graf graf--li graf-after--li">我们声明我们的数据只包含一个名为<code>them </code>的变量，它在模板部分循环。</li>
<li id="8015" class="graf graf--li graf-after--li">在我们的挂载调用中，我们调用了名为<code>get_them</code>的函数</li>
<li id="5e7e" class="graf graf--li graf-after--li"><code>get_them</code>函数使用axios向<a class="markup--anchor markup--li-anchor" href="https://restcountries.eu/rest/v2/all%27%29.then%28%28response%29" target="_blank" rel="nofollow noopener noreferrer" data-href="https://restcountries.eu/rest/v2/all').then((response)">https://restcountries.eu/rest/v2/all</a>发送一个GET请求。但是，我们不使用响应。我们只使用它来触发和异步事件。</li>
<li id="14ed" class="graf graf--li graf-after--li">最后，我们有两个计算属性。将一个新项目添加到<code>them</code>数组并返回它。第二个计算属性返回一个字符串<code>happy</code></li>
</ul>
<p id="8a39" class="graf graf--p graf-after--li">接下来，我们将看看如何测试我们的新组件。这意味着我们将测试我们的<code>get_them</code>函数，以及我们计算的属性。</p>
<h3 id="884e" class="graf graf--h3 graf-after--p">更新我们的路线</h3>
<p id="27f1" class="graf graf--p graf-after--h3">接下来，我们需要更新我们的路线，这样我们就可以查看到目前为止我们已经构建的组件。为此，让我们打开我们的<code>src\router\index.js</code>,并将其替换为:</p>
<figure id="832d" class="graf graf--figure graf--iframe graf-after--p"/>
<p id="f27b" class="graf graf--p graf-after--figure">在上面的代码块中，我们已经导入了我们的happy组件，并将其添加到我们的routes中。</p>
<p id="0018" class="graf graf--p graf-after--p">如果我们在终端中运行<code>npm run dev</code>并浏览到<code><a href="http://localhost:8080/#/happy" rel="nofollow">http://localhost:8080/#/happy</a></code>，我们应该会看到下图:</p>
<figure id="bea7" class="graf graf--figure graf-after--p">

</figure>
<h3 id="e16c" class="graf graf--h3 graf-after--figure">测试我们的组件方法</h3>
<p id="72c7" class="graf graf--p graf-after--h3">现在，让我们测试一下。如果我们检查我们名为<code>get_them</code>的方法，我们注意到我们有一个使用<code>axios</code>的异步调用。因此，如果我们试图为我们的组件编写测试，我们会遇到各种各样的问题，例如:</p>
<ul class="postList">
<li id="fef2" class="graf graf--li graf-after--p">承诺没有定义</li>
<li id="e74b" class="graf graf--li graf-after--li">超过2000毫秒的超时。</li>
</ul>
<p id="3900" class="graf graf--p graf-after--li">为了在测试过程中解决这些问题，我们将安装两个库，它们是:</p>
<ul class="postList">
<li id="2ed7" class="graf graf--li graf-after--p">承诺:解决“找不到可变承诺/承诺未定义”</li>
<li id="5bb8" class="graf graf--li graf-after--li">Moxios:这个库将存根请求并返回假数据到其中。以便伪造异步调用的提前完成。</li>
</ul>
<p id="bef0" class="graf graf--p graf-after--li">为了安装这些库，我们运行:</p>
<pre id="0b0f" class="graf graf--pre graf-after--p">npm install promise moxios</pre>
<p id="5485" class="graf graf--p graf-after--pre">现在我们已经安装了这些库，让我们在<code>test\unit\specs\</code>文件夹中创建一个名为<code>Happy-avorias.spec.js</code>的新文件。让我们将以下代码添加到文件中:</p>
<figure id="e090" class="graf graf--figure graf--iframe graf-after--p"/>
<p id="b855" class="graf graf--p graf-after--figure">让我们了解一下我们在上面的代码块中做了什么:</p>
<ul class="postList">
<li id="ed0c" class="graf graf--li graf-after--p">正如我们之前解释的那样，我们导入了挂载函数</li>
<li id="b3ef" class="graf graf--li graf-after--li">接下来，我们为存根请求导入了<code>Moxios</code>。</li>
<li id="5afe" class="graf graf--li graf-after--li">然后，我们将名为Promise的全局变量设置为Promise库的实例。这是为了让我们不会面临诸如承诺没有在Axios中定义的问题。</li>
<li id="42df" class="graf graf--li graf-after--li">然后我们描述了我们的测试</li>
<li id="37e2" class="graf graf--li graf-after--li">我们调用了两个钩子<code>beforeEach</code>和<code>afterEach</code>来处理<code>Moxios</code>的安装和卸载。这意味着<code>Moxios</code>将在该文件中定义的所有测试之前安装，并将在每次测试之后卸载。</li>
<li id="ecd2" class="graf graf--li graf-after--li">我们定义了两个测试标准</li>
<li id="d6fc" class="graf graf--li graf-after--li">在第一个测试标准中，我们使用Moxios来捕捉发往<a class="markup--anchor markup--li-anchor" href="https://restcountries.eu/rest/v2/all%27" target="_blank" rel="nofollow noopener noreferrer" data-href="https://restcountries.eu/rest/v2/all'">https://restcountries.eu/rest/v2/all</a>的请求，然后返回一个测试数据。</li>
<li id="93dc" class="graf graf--li graf-after--li">我们使用<code>moxios.wait</code>来确保在声明expect关键字之前承诺被解析</li>
<li id="600b" class="graf graf--li graf-after--li">注意，我们使用<code>vm.data()</code>来访问组件的数据属性。这是<code>avorias</code>提供的一个帮助函数</li>
<li id="a3c5" class="graf graf--li graf-after--li">我们检查我们的数据是否将<code>happy one</code>作为其数组内容的一部分，该数组是在请求后分配给它的。</li>
<li id="2757" class="graf graf--li graf-after--li">在第二个测试标准中，我们还使用Moxios来存根请求。然而，这里我们发现数组的长度等于4。这是我们期望的数组长度。</li>
</ul>
<h3 id="02b2" class="graf graf--h3 graf-after--li">测试我们的计算数据</h3>
<p id="eda2" class="graf graf--p graf-after--h3">就在上面，我们已经看到了如何测试数据和方法。这里我们进入测试计算属性。用<code>avorias</code>测试计算属性可能有点棘手，因为<code>this</code>没有绑定到计算属性。请参考下面关于该问题的链接。</p>

<p id="fcb8" class="graf graf--p graf-after--mixtapeEmbed">然而，不要害怕。我们将讨论如何在对计算属性运行我们自己的测试时解决这个问题。</p>
<p id="4361" class="graf graf--p graf-after--p">让我们回到我们的<code>Happy-avorias.spec.js</code>，用以下内容替换它:</p>
<figure id="899f" class="graf graf--figure graf--iframe graf-after--p"/>
<p id="5bf0" class="graf graf--p graf-after--figure">在上面的代码块中，我们会注意到添加了两个新的测试标准。</p><div class="code-block code-block-54">
<hr/>
<h3>更多来自LogRocket的精彩文章:</h3>

<hr/></div>
<ul class="postList">
<li id="f80d" class="graf graf--li graf-after--p">第一个标准是它必须返回计算的数据。它检查我们的<code>computed_first()</code>属性的响应，该属性对<code>this</code>关键字没有任何作用。</li>
<li id="3c78" class="graf graf--li graf-after--li">请注意avorias的帮助函数<code>computed()</code>用于检查计算的属性</li>
<li id="f0fe" class="graf graf--li graf-after--li">第二个标准说它的长度应该是5。然而，这里引用的计算属性<code>all_of_them</code>使用了<code>this</code>关键字，avorias并没有绑定到计算属性</li>
<li id="025c" class="graf graf--li graf-after--li">注意，我们期望<code>app.vm.all_of_them</code>包含<code>computed_one</code>，而不是期望<code>app.computed().all_of_them()</code></li>
</ul>
<p id="f4d3" class="graf graf--p graf-after--li">上面解释的是我们在运行计算数据时需要考虑的唯一差异。另外，请注意，同样的问题也适用于道具数据。</p>
<p id="5a8d" class="graf graf--p graf-after--p">我们可以通过运行以下命令来运行所有的测试:</p>
<pre id="2be0" class="graf graf--pre graf-after--p">npm run unit</pre>
<p id="8e1a" class="graf graf--p graf-after--pre">我们应该得到以下结果:</p>
</div>
</div>    
</body>
</html>
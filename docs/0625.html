<html>
<head>
<title>Building GraphQL APIs with TypeGraphQL and TypeORM - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>用TypeGraphQL和TypeORM - LogRocket博客构建GraphQL APIs</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/build-graphql-typegraphql-typeorm/#0001-01-01">https://blog.logrocket.com/build-graphql-typegraphql-typeorm/#0001-01-01</a></blockquote><div><article class="article-post">
<p><em> <strong>编者按:</strong> </em> <em>本帖于2021年12月15日修订，包含更新的代码块和信息。</em></p>
<p>GraphQL的受欢迎程度在不断增长，原因并不神秘:它是一个很好的工具，解决了开发人员在使用RESTful APIs时遇到的许多常见问题。GraphQL允许我们轻松地获取数据关系，但也防止我们过度获取数据。简而言之，GraphQL改善了开发体验，使前端应用程序更快。</p>
<p>如果您以前曾经使用Node.js创建过GraphQL服务器，那么您很有可能使用GraphQL模式语言为您的对象类型、变异和查询定义了模式，并使用JavaScript/TypeScript定义了解析器，它们与您定义的模式相匹配。</p>
<p>这种方法可能很难维护，尤其是在处理大型模式时，因为模式和解析器位于不同的位置。</p>
<p>如果我们想要更改数据中的一个字段，我们需要更改数据库模型类和GraphQL模式，并调整类型接口(如果使用TypeScript)。但在本教程中，我将向您展示一种用TypeGraphQL和TypeORM构建GraphQL API的愉快方式。</p>
<p><a href="https://typegraphql.com/" target="_blank" rel="noopener"> TypeGraphQL </a>是一个用Node.js和TypeScript构建GraphQL APIs的框架。这个工具的主要目的是让我们直接从我们的TypeScript代码中定义我们的模式。<a href="https://typeorm.io/#/">另一方面，TypeORM </a>是一个允许我们与SQL数据库交互的类型脚本库。结合这些工具，我们可以构建一个类型安全的GraphQL API，而不会遇到这类项目通常会遇到的挫折。</p>
<p>事不宜迟，让我们来看看如何用TypeGraphQL和TypeORM构建一个GraphQL API，它可以用<a href="https://blog.logrocket.com/crud-with-node-graphql-react/" target="_blank" rel="noopener noreferrer"> CRUD功能</a>管理图书数据。</p>
<h2 id="prerequisites">先决条件</h2>
<p>开始之前，请确保您:</p>
<ol>
<li>理解JavaScript</li>
<li>对Node.js和npm有一个大致的了解</li>
<li>具备打字稿的基本知识</li>
</ol>
<h2 id="gettingstarted">GraphQL入门</h2>
<p>我们将从初始化一个新的Node.js项目开始。</p>
<pre>mkdir learn-typegraphql
npm init -y
</pre>
<p>接下来，我们将安装一些依赖项。</p>
<pre class="language-bash hljs">npm install apollo-server type-graphql typeorm reflect-metadata
</pre>
<p>在这里，我们正在安装:</p>
<ul>
<li>Apollo服务器来构建和运行我们的GraphQL服务器</li>
<li>从TypeScript类生成我们的模式</li>
<li>键入与我们的SQL数据库交互的表单</li>
<li>与打字稿装饰者一起工作</li>
</ul>
<p>此外，我们需要安装一些开发依赖项。</p>
<pre>npm install -D typescript ts-node nodemon
</pre>
<p>该脚本将安装:</p>
<ol>
<li>将我们的代码编译成普通的JavaScript</li>
<li>在开发环境中运行我们的服务器</li>
<li>当我们修改代码时，自动重启服务器</li>
</ol>
<p>现在，为了让我们的工作简单一点，让我们在<code>package.json</code>中定义npm启动脚本。</p>
<pre class="language-typescript hljs">{
  // ...
  "scripts": {
    "start": "nodemon -w src --ext ts --exec ts-node src/index.ts"
  }
}
</pre>
<p>接下来，创建一个<code>tsconfig.json</code>文件。该文件包含我们的TypeScript配置，因为我们将使用一些目前仍处于试验阶段的TypeScript特性，但对于我们的目的来说已经足够稳定了。</p>
<pre class="language-typescript hljs">{
  "compilerOptions": {
    "target": "es5",
    "module": "commonjs",
    "strict": true,
    "esModuleInterop": true,
    "experimentalDecorators": true,
    "emitDecoratorMetadata": true,
    "strictPropertyInitialization": false
  }
}
</pre>
<p>确保<code>experimentalDecorators</code>和<code>emitDecoratorMetadata</code>设置为真。</p>
<p>作为参考，我把这个项目的全部源代码发布到我的<a href="https://github.com/rahmanfadhil/learn-typegraphql" target="_blank" rel="noopener noreferrer"> GitHub </a>上。你可以随意摆弄或者克隆到你的电脑上。</p>
<pre>git clone https://github.com/rahmanfadhil/learn-typegraphql.git
</pre>
<h2 id="settingupagraphqlserver">设置GraphQL服务器</h2>
<p>是时候开始开发我们的服务器API了。让我们在<code>src</code>文件夹中创建一个名为<code>index.ts</code>的新文件。</p>
<pre class="language-typescript hljs">// src/index.ts

import "reflect-metadata";
import { createConnection } from "typeorm";
import { ApolloServer } from "apollo-server";
import { buildSchema } from "type-graphql";

async function main() {
  const connection = await createConnection()
  const schema = await buildSchema()
  const server = new ApolloServer({ schema })
  await server.listen(4000)
  console.log("Server has started!")
}
main()</pre>
<p>在这个文件中，我们可以编写一个名为<code>main</code>的函数。这个函数使得初始化我们在这个项目中使用的每一个库变得更加容易。在这个函数中，我们将首先使用TypeORM提供的<code>createConnection</code>函数创建一个到数据库的新连接。</p>
<p>接下来，我们将使用TypeGraphQL的<code>buildSchema</code>方法生成我们的GraphQL模式。这将使用我们所有的解析器，并生成一个可执行的GraphQL模式，我们可以在我们的Apollo服务器中使用。这些解析器略有不同，我们将在本教程的后面讨论。</p>
<p>我们在顶部导入的<a href="https://www.npmjs.com/package/reflect-metadata"> reflect-metadata </a>包是一个助手库，它扩展了TypeScript decorators的功能。这个包是使用TypeORM和TypeGraphQL所必需的。</p>
<p>最后，我们将初始化我们的Apollo服务器，传递我们的模式，并在端口<code>4000</code>(或者您想要的任何其他端口)启动它。</p>
<h2 id="databaseconfiguration">GraphQL中的数据库配置</h2>
<p>在上一节中，我们从TypeORM调用了<code>createConnection</code>函数来建立数据库连接。现在，我们需要定义一个数据库配置来告诉TypeORM我们计划使用哪种数据库以及如何访问它。有几种方法可以做到这一点；就个人而言，我喜欢在<code>ormconfig.json</code>文件中创建配置。</p>
<p>目前，TypeORM支持九种类型的SQL数据库，包括MySQL和PostgreSQL等流行的数据库。您可以使用任何想要的数据库，但是为了简单起见，我将使用SQLite——SQL数据库引擎的最小实现，非常容易上手。要使用这个数据库，我们必须首先安装Node.js的驱动程序。</p>
<pre>npm install sqlite3
</pre>
<p>现在，我们可以将<code>ormconfig.json</code>文件添加到我们的项目中。</p>
<pre class="language-typescript hljs">{
  "type": "sqlite",
  "database": "./db.sqlite3",
  "entities": ["./src/models/*.ts"],
  "synchronize": true
}
</pre>
<h2 id="resolvers">下决心者</h2>
<p>假设您创建了一个只有Apollo库的GraphQL服务器。在这种情况下，您用GraphQL模式语言为对象类型、变异和查询定义模式，并用JavaScript/TypeScript定义与您定义的模式相匹配的解析器。这种方法可能很难维护，尤其是当您有很多变化和查询时，因为您的模式和解析器位于不同的位置。</p><div class="code-block code-block-54">
<hr/>
<h3>更多来自LogRocket的精彩文章:</h3>

<hr/></div>
<p>然而，使用TypeGraphQL，我们不需要显式地编写模式。相反，我们用TypeScript类和decorators定义解析器，TypeGraphQL将为我们生成模式。</p>
<p>要了解这一点，让我们看看下面的代码。</p>
<pre class="language-typescript hljs">// src/resolvers/BookResolver.ts

import { Resolver, Query } from "type-graphql";

@Resolver()
export class BookResolver {
  @Query(() =&gt; String)
  hello() {
    return "world";
  }
}
</pre>
<p>在这里，我们创建了一个名为<code>BookResolver</code>的类，并用TypeGraphQL的<code>Resolver</code>装饰器来装饰它。这使我们能够将所有的解析器作为一个方法放在这个类中。我们还想确保用<code>Query</code>或<code>Mutation</code>来修饰方法，并在第一个参数上传递返回类型。</p>
<p>到目前为止，我们只有一个返回字符串的<code>hello</code>查询。稍后，我们将使用TypeORM对我们的数据库实现完整的CRUD。</p>
<p>现在我们需要在<code>src/index.ts</code>中注册我们的解析器。</p>
<pre class="language-typescript hljs">import "reflect-metadata";
import { createConnection } from "typeorm";
import { ApolloServer } from "apollo-server";
import { BookResolver } from "./resolvers/BookResolver.ts"; // add this
import { buildSchema } from "type-graphql";

async function main() {
  const connection = await createConnection()
  const schema = await buildSchema({
    resolvers: [BookResolver] // add this
  })
  const server = new ApolloServer({ schema })
  await server.listen(4000)
  console.log("Server has started!")
}
main()</pre>
<p>就是这样！为了确保一切设置正确，让我们通过在终端上运行<code>npm start</code>并在浏览器中打开<code>localhost:4000</code>来运行我们的服务器。</p>
<p><img data-attachment-id="12675" data-permalink="https://blog.logrocket.com/build-graphql-typegraphql-typeorm/graphql-api-resolver/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/01/graphql-api-resolver.png" data-orig-size="730,556" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Building a resolver in GraphQL" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/01/graphql-api-resolver-300x228.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/01/graphql-api-resolver.png" decoding="async" class="aligncenter size-full wp-image-12675 jetpack-lazy-image" src="../Images/148a00044e98d5984208a9b3966d28ce.png" alt="Building a Resolver in GraphQL" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2020/01/graphql-api-resolver.png 730w, https://blog.logrocket.com/wp-content/uploads/2020/01/graphql-api-resolver-300x228.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2020/01/graphql-api-resolver.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/01/graphql-api-resolver.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="12675" data-permalink="https://blog.logrocket.com/build-graphql-typegraphql-typeorm/graphql-api-resolver/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/01/graphql-api-resolver.png" data-orig-size="730,556" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Building a resolver in GraphQL" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/01/graphql-api-resolver-300x228.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/01/graphql-api-resolver.png" decoding="async" loading="lazy" class="aligncenter size-full wp-image-12675" src="../Images/148a00044e98d5984208a9b3966d28ce.png" alt="Building a Resolver in GraphQL" srcset="https://blog.logrocket.com/wp-content/uploads/2020/01/graphql-api-resolver.png 730w, https://blog.logrocket.com/wp-content/uploads/2020/01/graphql-api-resolver-300x228.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/01/graphql-api-resolver.png"/></noscript>
<h2 id="models">用TypeORM定义模型</h2>
<p>现在我们的服务器已经启动并运行了，下一步是定义我们的模型。</p>
<p>模型本质上是一个类，它允许我们与数据库中的特定表进行交互。使用TypeORM，我们可以用类和装饰器定义我们的数据库模型，就像我们的解析器一样。因为我们试图构建一个书店API，所以让我们创建一个代表我们的书籍的模型。</p>
<pre class="language-typescript hljs">// src/models/Book.ts

import { Entity, BaseEntity, PrimaryGeneratedColumn, Column } from "typeorm";

@Entity()
export class Book extends BaseEntity {
  @PrimaryGeneratedColumn()
  id: string;

  @Column()
  title: string;

  @Column()
  author: string;

  @Column({ default: false })
  isPublished: boolean;
}
</pre>
<p>TypeORM模型本质上是一个用<code>Entity</code>修饰的普通TypeScript类。该类包含表示数据库中表的字段的属性。你可以在<a href="https://typeorm.io/#/entities" target="_blank" rel="noopener noreferrer"> TypeORM官方文档</a>中了解更多。</p>
<p>这个类扩展了<code>BaseEntity</code>类，它包含了访问books表的有用方法。</p>
<h2 id="objecttypes">对象类型</h2>
<p>因为我们正在构建一个GraphQL API，所以我们还需要定义我们的对象类型。在GraphQL中，每一个查询和变异都会返回一个对象，无论是布尔值、字符串还是我们自己定义的自定义对象。就像我们的模型一样，我们可以通过使用类和装饰器来简单地定义我们的对象类型。</p>
<p>这就是奇迹发生的地方。我们可以将TypeGraphQL和TypeORM装饰器组合在一个TypeScript类中。这样，我们可以有一个表示GraphQL对象类型以及数据库模型的类。代码应该如下所示:</p>
<pre class="language-typescript hljs">// src/models/Book.ts

import { Entity, BaseEntity, PrimaryGeneratedColumn, Column } from "typeorm";
import { ObjectType, Field, ID } from "type-graphql";

@Entity()
@ObjectType()
export class Book extends BaseEntity {
  @Field(() =&gt; ID)
  @PrimaryGeneratedColumn()
  id: string;

  @Field(() =&gt; String)
  @Column()
  title: string;

  @Field(() =&gt; String)
  @Column()
  author: string;

  @Field(() =&gt; Boolean)
  @Column({ default: false })
  isPublished: boolean;
}
</pre>
<p>这使得我们的代码更加高效，因为我们在一个地方定义了单一的数据类型，这应该有助于减少由属性不一致导致的错误。</p>
<p>假设我们想将<code>isPublished</code>属性更新为<code>published</code>。传统上，当使用默认的GraphQL模式语言时，我们需要在数据库模型和GraphQL模式中定义我们的数据类型。然而，通过使用这些装饰器，我们可以简单地更新类中的属性来更新模式和模型。</p>
<p>您甚至可以为数据库表列和GraphQL模式使用不同的名称。假设您想要将数据库中的<code>isPublished</code>字段命名为<code>is_published</code>,并在GraphQL模式中发布，您可以通过向属性装饰器添加name选项来实现:</p>
<pre class="language-typescript hljs">@Field(() =&gt; Boolean, { name: "published" })
@Column({ default: false, name: 'is_published' })
isPublished: boolean;
</pre>
<h2 id="databasecrud">数据库积垢</h2>
<p>创建数据库模型后，让我们回到解析器，实现一个返回所有书籍的查询。</p>
<pre class="language-typescript hljs">import { Resolver, Query } from "type-graphql";
import { Book } from "../models/Book";

@Resolver()
class BookResolver {
  @Query(() =&gt; [Book])
  books() {
    return Book.find()
  }
}
</pre>
<p>我们将在resolver类中创建<code>books</code>方法，并用<code>Query</code>修饰它。为了指定查询的返回类型，我们需要在<code>Query</code>装饰参数中传递它，在本例中，它是一个书籍数组。在这个方法中，我们用<code>find</code>方法从我们的模型中获取我们的书。</p>
<p>现在让我们回到我们的操场，测试这个查询。</p>
<p><img data-attachment-id="12671" data-permalink="https://blog.logrocket.com/build-graphql-typegraphql-typeorm/graphql-api-database-crud/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/01/graphql-api-database-crud.png" data-orig-size="730,556" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Database CRUD query in GraphQL" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/01/graphql-api-database-crud-300x228.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/01/graphql-api-database-crud.png" decoding="async" class="aligncenter size-full wp-image-12671 jetpack-lazy-image" src="../Images/0c4d18aa03d095e192721fda97151166.png" alt="Database CRUD Query in GraphQL" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2020/01/graphql-api-database-crud.png 730w, https://blog.logrocket.com/wp-content/uploads/2020/01/graphql-api-database-crud-300x228.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2020/01/graphql-api-database-crud.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/01/graphql-api-database-crud.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="12671" data-permalink="https://blog.logrocket.com/build-graphql-typegraphql-typeorm/graphql-api-database-crud/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/01/graphql-api-database-crud.png" data-orig-size="730,556" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Database CRUD query in GraphQL" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/01/graphql-api-database-crud-300x228.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/01/graphql-api-database-crud.png" decoding="async" loading="lazy" class="aligncenter size-full wp-image-12671" src="../Images/0c4d18aa03d095e192721fda97151166.png" alt="Database CRUD Query in GraphQL" srcset="https://blog.logrocket.com/wp-content/uploads/2020/01/graphql-api-database-crud.png 730w, https://blog.logrocket.com/wp-content/uploads/2020/01/graphql-api-database-crud-300x228.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/01/graphql-api-database-crud.png"/></noscript>
<p>它返回一个空数组，这意味着我们还没有创建任何书籍。让我们通过创造一个突变来做到这一点。</p>
<pre class="language-typescript hljs">@Mutation(() =&gt; Book)
async createBook(@Arg("data") data: CreateBookInput) {
  const book = Book.create(data);
  await book.save();
  return book;
}
</pre>
<p>这里，我们创建了一个返回图书类型的<code>createBook</code>方法。在这个方法中，我们初始化一个新的<code>Book</code>实例，用<code>save</code>方法将它保存到数据库中，并返回它。此方法需要数据作为参数。为了从用户那里获得数据，我们可以构建一个输入类型来指定哪些字段对于这种变异是必需的。</p>
<p>让我们创建一个输入来创建一本新书。</p>
<pre class="language-typescript hljs">// src/inputs/CreateBookInput.ts

import { InputType, Field } from "type-graphql";

@InputType()
export class CreateBookInput {
  @Field()
  title: string;

  @Field()
  author: string;
  @Field({ nullable: true })
  isPublished?: boolean;
}
</pre>
<p>输入类型类类似于我们的对象类型。唯一不同的是我们用<code>InputType</code>修饰了这个类。这里，我们指定除了<code>id</code>列之外的所有列，因为它是在我们每次插入新行时由数据库自动生成的。我们还为<code>isPublished</code>列设置了<code>nullable: true</code>，因为它有一个默认值。</p>
<p>让我们来测试一下！</p>
<p><img data-attachment-id="12673" data-permalink="https://blog.logrocket.com/build-graphql-typegraphql-typeorm/graphql-api-new-book/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/01/graphql-api-new-book.png" data-orig-size="730,500" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Creating a new book in GraphQL" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/01/graphql-api-new-book-300x205.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/01/graphql-api-new-book.png" decoding="async" class="aligncenter size-full wp-image-12673 jetpack-lazy-image" src="../Images/92bc090df4d52951f6364ee2f1cd2a0f.png" alt="Creating a New Book in GraphQL" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2020/01/graphql-api-new-book.png 730w, https://blog.logrocket.com/wp-content/uploads/2020/01/graphql-api-new-book-300x205.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2020/01/graphql-api-new-book.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/01/graphql-api-new-book.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="12673" data-permalink="https://blog.logrocket.com/build-graphql-typegraphql-typeorm/graphql-api-new-book/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/01/graphql-api-new-book.png" data-orig-size="730,500" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Creating a new book in GraphQL" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/01/graphql-api-new-book-300x205.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/01/graphql-api-new-book.png" decoding="async" loading="lazy" class="aligncenter size-full wp-image-12673" src="../Images/92bc090df4d52951f6364ee2f1cd2a0f.png" alt="Creating a New Book in GraphQL" srcset="https://blog.logrocket.com/wp-content/uploads/2020/01/graphql-api-new-book.png 730w, https://blog.logrocket.com/wp-content/uploads/2020/01/graphql-api-new-book-300x205.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/01/graphql-api-new-book.png"/></noscript>
<p>接下来，我们将创建一个新的查询来获取一本书。</p>
<pre class="language-typescript hljs">@Query(() =&gt; Book)
book(@Arg("id") id: string) {
  return Book.findOne({ where: { id } });
}
</pre>
<p>让我们试试这个查询:</p>
<p><img data-attachment-id="12674" data-permalink="https://blog.logrocket.com/build-graphql-typegraphql-typeorm/graphql-api-new-query/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/01/graphql-api-new-query.png" data-orig-size="730,500" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Creating a new query to fetch a book in GraphQL" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/01/graphql-api-new-query-300x205.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/01/graphql-api-new-query.png" decoding="async" class="aligncenter size-full wp-image-12674 jetpack-lazy-image" src="../Images/bd319ea7054144161903f07ee132f7c5.png" alt="Creating a New Query to Fetch a Book in GraphQL" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2020/01/graphql-api-new-query.png 730w, https://blog.logrocket.com/wp-content/uploads/2020/01/graphql-api-new-query-300x205.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2020/01/graphql-api-new-query.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/01/graphql-api-new-query.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="12674" data-permalink="https://blog.logrocket.com/build-graphql-typegraphql-typeorm/graphql-api-new-query/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/01/graphql-api-new-query.png" data-orig-size="730,500" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Creating a new query to fetch a book in GraphQL" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/01/graphql-api-new-query-300x205.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/01/graphql-api-new-query.png" decoding="async" loading="lazy" class="aligncenter size-full wp-image-12674" src="../Images/bd319ea7054144161903f07ee132f7c5.png" alt="Creating a New Query to Fetch a Book in GraphQL" srcset="https://blog.logrocket.com/wp-content/uploads/2020/01/graphql-api-new-query.png 730w, https://blog.logrocket.com/wp-content/uploads/2020/01/graphql-api-new-query-300x205.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/01/graphql-api-new-query.png"/></noscript>
<p>到目前为止，一切顺利！</p>
<p>现在是添加更新操作的时候了。</p>
<pre class="language-typescript hljs">@Mutation(() =&gt; Book)
async updateBook(@Arg("id") id: string, @Arg("data") data: UpdateBookInput) {
  const book = await Book.findOne({ where: { id } });
  if (!book) throw new Error("Book not found!");
  Object.assign(book, data);
  await book.save();
  return book;
}
</pre>
<p>在<code>updateBook</code>方法中，我们需要我们想要更新的<code>book</code>的<code>id</code>以及用户输入，我们将在后面创建。首先，我们会找到这本书，如果它存在的话。然后，我们将更新在<code>data</code>参数中定义的属性。最后，我们将保存对数据库的所有更改，并将更新后的图书数据返回给用户。</p>
<p>下面我们定义更新一本书的输入。</p>
<pre class="language-typescript hljs">import { InputType, Field } from "type-graphql";

@InputType()
export class UpdateBookInput {
  @Field({ nullable: true })
  title?: string;

  @Field({ nullable: true })
  author?: string;

  @Field({ nullable: true })
  isPublished?: boolean;
}
</pre>
<p>输入与我们的<code>CreateBookInput</code>类非常相似。然而，所有这些属性都是可选的，这意味着用户不必填写书的所有属性。</p>
<p><img data-attachment-id="12676" data-permalink="https://blog.logrocket.com/build-graphql-typegraphql-typeorm/graphql-api-update-book/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/01/graphql-api-update-book.png" data-orig-size="730,500" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Updating a book in GraphQL" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/01/graphql-api-update-book-300x205.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/01/graphql-api-update-book.png" decoding="async" class="aligncenter size-full wp-image-12676 jetpack-lazy-image" src="../Images/bb3f7b3e616e7bab92cb600fd665ac20.png" alt="Updating a Book in GraphQL" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2020/01/graphql-api-update-book.png 730w, https://blog.logrocket.com/wp-content/uploads/2020/01/graphql-api-update-book-300x205.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2020/01/graphql-api-update-book.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/01/graphql-api-update-book.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="12676" data-permalink="https://blog.logrocket.com/build-graphql-typegraphql-typeorm/graphql-api-update-book/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/01/graphql-api-update-book.png" data-orig-size="730,500" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Updating a book in GraphQL" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/01/graphql-api-update-book-300x205.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/01/graphql-api-update-book.png" decoding="async" loading="lazy" class="aligncenter size-full wp-image-12676" src="../Images/bb3f7b3e616e7bab92cb600fd665ac20.png" alt="Updating a Book in GraphQL" srcset="https://blog.logrocket.com/wp-content/uploads/2020/01/graphql-api-update-book.png 730w, https://blog.logrocket.com/wp-content/uploads/2020/01/graphql-api-update-book-300x205.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/01/graphql-api-update-book.png"/></noscript>
<p>最后一步是实现删除图书特性。</p>
<pre class="language-typescript hljs">@Mutation(() =&gt; Boolean)
async deleteBook(@Arg("id") id: string) {
  const book = await Book.findOne({ where: { id } });
  if (!book) throw new Error("Book not found!");
  await book.remove();
  return true;
}
</pre>
<p>这个方法非常简单。我们从给定的<code>id</code>中找到那本书，用<code>remove</code>函数将它从数据库中删除，并返回<code>true</code>作为结果。</p>
<p><img data-attachment-id="12672" data-permalink="https://blog.logrocket.com/build-graphql-typegraphql-typeorm/graphql-api-delete-book/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/01/graphql-api-delete-book.png" data-orig-size="730,500" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Removing a book in GraphQL" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/01/graphql-api-delete-book-300x205.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/01/graphql-api-delete-book.png" decoding="async" class="aligncenter size-full wp-image-12672 jetpack-lazy-image" src="../Images/08671f32d6723472b8ea4b88ab3a4e81.png" alt="Removing a Book in GraphQL" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2020/01/graphql-api-delete-book.png 730w, https://blog.logrocket.com/wp-content/uploads/2020/01/graphql-api-delete-book-300x205.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2020/01/graphql-api-delete-book.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/01/graphql-api-delete-book.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="12672" data-permalink="https://blog.logrocket.com/build-graphql-typegraphql-typeorm/graphql-api-delete-book/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/01/graphql-api-delete-book.png" data-orig-size="730,500" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Removing a book in GraphQL" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/01/graphql-api-delete-book-300x205.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/01/graphql-api-delete-book.png" decoding="async" loading="lazy" class="aligncenter size-full wp-image-12672" src="../Images/08671f32d6723472b8ea4b88ab3a4e81.png" alt="Removing a Book in GraphQL" srcset="https://blog.logrocket.com/wp-content/uploads/2020/01/graphql-api-delete-book.png 730w, https://blog.logrocket.com/wp-content/uploads/2020/01/graphql-api-delete-book-300x205.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/01/graphql-api-delete-book.png"/></noscript>
<div>
<h2>结论</h2>
<p>TypeGraphQL可以帮助解决开发人员在构建GraphQL APIs时遇到的许多问题，尤其是使用TypeScript时。它不仅提供了一种更干净、更安全的方式来构建GraphQL APIs，还避免了我们一遍又一遍地重复相同的任务。</p>
<p>如果使用TypeORM，它甚至会更有用，因为它采用相同的方法来定义数据库模型。这些工具被证明可以完成工作，应该是你下一个大项目的首要考虑因素。</p><div class="code-block code-block-21">
<div class="blog-plug inline-plug typescript-plug"><h2><a class="signup" href="https://lp.logrocket.com/blg/typescript-signup" target="_blank" rel="noopener noreferrer"> LogRocket </a>:全面了解您的网络和移动应用</h2>
<a href="https://lp.logrocket.com/blg/typescript-signup" class="signup" target="_blank" rel="noopener noreferrer"><img class="alignnone size-full wp-image-46 jetpack-lazy-image" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/><noscript><img data-lazy-fallback="1" class="alignnone size-full wp-image-46" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/></noscript></a>
<p>LogRocket 是一个前端应用程序监控解决方案，可以让您回放问题，就像问题发生在您自己的浏览器中一样。LogRocket不需要猜测错误发生的原因，也不需要向用户询问截图和日志转储，而是让您重放会话以快速了解哪里出错了。它可以与任何应用程序完美配合，不管是什么框架，并且有插件可以记录来自Redux、Vuex和@ngrx/store的额外上下文。</p>
<p>除了记录Redux操作和状态，LogRocket还记录控制台日志、JavaScript错误、堆栈跟踪、带有头+正文的网络请求/响应、浏览器元数据和自定义日志。它还使用DOM来记录页面上的HTML和CSS，甚至为最复杂的单页面和移动应用程序重新创建像素级完美视频。</p><div class="code-block code-block-24">
<div class="blog-plug inline-plug graphql-plug"><h2>监控生产中失败和缓慢的GraphQL请求</h2><p>虽然GraphQL有一些调试请求和响应的特性，但确保GraphQL可靠地为您的生产应用程序提供资源是一件比较困难的事情。如果您对确保对后端或第三方服务的网络请求成功感兴趣，</p><a href="https://lp.logrocket.com/blg/graphql-signup" target="_blank">try LogRocket</a><p>.</p><a class="signup" href="https://lp.logrocket.com/blg/graphql-signup" target="_blank" rel="noopener noreferrer"><img src="../Images/432a3823c85b3fb72a206e6236a29f48.png" data-lazy-src="https://files.readme.io/69aa835-Image_2019-11-09_at_1.28.05_PM.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" class=" jetpack-lazy-image" data-original-src="https://files.readme.io/69aa835-Image_2019-11-09_at_1.28.05_PM.png"/><noscript><img data-lazy-fallback="1" src="../Images/432a3823c85b3fb72a206e6236a29f48.png" data-original-src="https://files.readme.io/69aa835-Image_2019-11-09_at_1.28.05_PM.png"/></noscript><img class="alignnone size-full wp-image-46 jetpack-lazy-image" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/><noscript><img data-lazy-fallback="1" class="alignnone size-full wp-image-46" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/></noscript></a><a href="https://lp.logrocket.com/blg/graphql-signup" target="_blank" rel="noopener noreferrer">https://logrocket.com/signup/</a><p>LogRocket 就像是网络和移动应用的DVR，记录下你网站上发生的每一件事。您可以汇总并报告有问题的GraphQL请求，以快速了解根本原因，而不是猜测问题发生的原因。此外，您可以跟踪Apollo客户机状态并检查GraphQL查询的键值对。</p><p>LogRocket检测您的应用程序以记录基线性能计时，如页面加载时间、到达第一个字节的时间、慢速网络请求，还记录Redux、NgRx和Vuex操作/状态。</p><a class="signup" href="https://lp.logrocket.com/blg/graphql-signup" target="_blank" rel="noopener noreferrer">Start monitoring for free</a><p>.</p></div>


</div>
<a class="signup" href="https://lp.logrocket.com/blg/typescript-signup" target="_blank" rel="noopener noreferrer">Try it for free</a><p>.</p></div>
</div>
</div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
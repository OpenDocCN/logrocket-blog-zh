<html>
<head>
<title>Creating visuals of your webpage with Puppeteer - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>使用木偶师博客创建网页的视觉效果</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/creating-visuals-of-your-webpage-with-puppeteer/#0001-01-01">https://blog.logrocket.com/creating-visuals-of-your-webpage-with-puppeteer/#0001-01-01</a></blockquote><div><article class="article-post">
<p>Puppeteer是由Google构建的Node.js模块，用于在节点环境中模拟Chrome浏览器或Chrome。</p>
<blockquote><p>来自Puppeteer API文档:Puppeteer是一个节点库，它提供了一个高级API来控制Chrome或DevTools协议上的Chrome。</p></blockquote>
<p>因此，基本上，Puppeteer是一个在Node.js上运行的浏览器。它包含模拟浏览器的API。这些API使您能够执行不同的操作，例如:</p>
<ul>
<li>从网页生成PDF</li>
<li>从网页生成屏幕截图</li>
<li>测试Chrome扩展</li>
<li><a href="https://github.com/puppeteer/puppeteer" target="_blank" rel="noopener noreferrer">这么多更</a></li>
</ul>
<p>在这篇文章中，我们将学习如何使用木偶师从一个网站的网址生成截图。</p>
<h2>创建视觉</h2>
<p>使用木偶节点模块创建网页的视觉效果非常容易。</p>
<p>首先，我们安装木偶节点模块:</p>
<pre>npm i puppeteer</pre>
<p>然后，我们将创建我们的。js文件并需要“木偶师”库。</p>
<pre>const puppeteer = require("puppeteer")</pre>
<p>现在，创建一个浏览器上下文和一个新页面:</p>
<pre>const puppeteer = require("puppeteer")
const browser = await puppeteer.launch({ headless: true })
const page = await browser.newPage()</pre>
<p>注意:木偶库是基于承诺的。这意味着它的API主要返回promise对象。</p>
<p>通过<code>_const browser = await puppeteer.launch({ headless: true })_</code>，我们在木偶师类实例Puppeteer中使用<code>launch</code> API创建了一个新的浏览器实例。这实际上启动了一个Chromium实例。浏览器是浏览器类的一个实例。</p>
<p>设置<code>{ headless: true }</code>意味着浏览器将是Chromium的一个无头实例。</p>
<p>注意，启动返回一个承诺，它解析为一个浏览器实例。在这里，那将是<code>browser</code>。</p>
<pre>_const page = await browser.newPage()_</pre>
<p>浏览器可以容纳如此多的页面。因此，<code>Browser</code>中的这个<code>newPage()</code>方法在默认浏览器上下文中创建了一个新页面。页面是页面类的对象。</p>
<p>现在，使用<code>page</code>对象，我们将加载或导航到我们想要截屏的网页:</p>
<pre>await page.goto('https://medium.com')&gt;/pre&gt;</pre>
<p>在这里，我们正在加载中型主页。当浏览器触发<code>load</code>事件时，方法<code>goto</code>将解析，表示页面已经成功加载。现在，随着页面<code>medium.com</code>的加载，我们可以截图了。</p>
<pre>const screenShot = await page.screenshot({
    path: "./",
    type: "png",
    fullPage: true
})</pre>
<p>page对象的截图方法完成了所有的工作。它获取当前页面的截图。</p>
<p>截图方法采用了一些配置:</p>
<p><code>_path_</code>:表示我们想要保存图像的文件路径。在这里，我们将保存在当前的工作目录。如果没有路径，图像将不会保存到磁盘。</p>
<p><code>_type_</code>:表示使用png或jpeg的图像编码类型。</p>
<p><code>_fullPage_</code>:这将使屏幕截图完全滚动到页面大小。</p>
<p>还有其他设置，包括:</p>
<p><code>_quality_</code>:图像的质量，在0-100之间。不适用于png图像。</p>
<p><code>_omitBackground_</code>:隐藏默认白色背景，允许捕捉透明截图。</p>
<p><code>_encoding_</code>:图像的编码可以是base64，也可以是二进制。默认为二进制。</p>
<p>截图方法返回一个承诺，它将根据设置中的<code>encoding</code>属性值解析为buffer或base64。因此，在我们自己的例子中，屏幕截图方法将返回一个承诺，该承诺将解析为二进制。截图变量将保存介质frontpage的二进制图像。</p>
<p>至此，我们的代码完成了:</p>
<pre>// screenshot.js
const puppeteer = require("puppeteer")

( async function() {

    const browser = await puppeteer.launch({ headless: true })

    const page = await browser.newPage()

    await page.goto('https://medium.com')

    const screenShot = await page.screenshot({
        path: "./",
        type: "png",
        fullPage: true
    })
}()
)</pre>
<p>我们可以在Node.js环境中运行该文件:</p>
<pre>node screenshot.js</pre>
<p>这将生成一个媒体截图，并保存在我们当前的目录。</p>
<p>您可以将<code><a href="https://medium.com" rel="nofollow">https://medium.com</a></code>替换为您想要捕捉其屏幕截图的网页。</p>
<h2>设置视口大小</h2>
<p>如果在使用puppeter截图时没有指定<code>fullPage</code>选项，puppeter将模拟一个默认大小设置为800×600的浏览器窗口。</p>
<p>我们可以使用page类中的<code>setViewport</code> API来改变屏幕截图的大小。</p>
<pre>await page.setViewport({
    width: 1200,
    height: 1500
})</pre>
<p>这将生成一个宽度为1200px，高度为1500px的网页截图。</p>
<h2>设置屏幕截图的特定区域</h2>
<p>我们可以剪切页面的一个区域，并对其进行截图。也就是说，我们可以对网页上的特定区域进行截图。</p>
<p>这是通过将一个<code>clip</code>对象传递给<code>page.screenshot(...)</code>方法来实现的。</p>
<pre>const screenShot = await page.screenshot({
        path: "./",
        type: "png",
        clip: {
            ...            
        }
    })</pre>
<p><code>clip</code>对象有以下字段:</p>
<ul>
<li><code>_x_</code>:剪辑区网页x轴的左上方</li>
<li><code>_y_</code>:剪辑区网页y轴的左上方</li>
<li><code>_width_</code>:剪裁区域的宽度</li>
<li><code>_height_</code>:裁剪区域的高度</li>
</ul>
<pre>const screenShot = await page.screenshot({
        path: "./",
        type: "png",
        clip: {
            x: 0,
            y: 0,
            width: 360,
            height: 400
        }
    })</pre>
<p>上面的代码将从0，0 =&gt; x，y轴开始，向右移动300像素，向下移动400像素，截取网页的截图。</p>
<pre>const screenShot = await page.screenshot({
        path: "./",
        type: "png",
        clip: {
            x: 50,
            y: 60,
            width: 360,
            height: 400
        }
    })</pre>
<p>这将对页面上的50，60 =&gt; x，y轴进行三角剖分，并向右移动360px，向下移动400px，然后对裁剪区域进行截图。</p><div class="code-block code-block-54">
<hr/>
<h3>更多来自LogRocket的精彩文章:</h3>

<hr/></div>
<h2>背景</h2>
<p>我们可以通过传递<code>omitBackground</code>布尔选项来省略截图中木偶师给我们的默认白色背景。</p>
<pre>const screenShot = await page.screenshot({
        ...,
        omitBackground: true
    })</pre>
<p>这将采取透明背景的网页截图。</p>
<h2>等待页面加载</h2>
<p>对于我们当前的加载，当加载事件被触发时，页面被认为是完全加载的。当页面成功加载时，将触发load事件。</p>
<p>除了load事件之外，Puppeteer还为我们提供了更多选项来指示导航何时完成。</p>
<ul>
<li><code>_domcontentloaded_</code>:这将告诉木偶师在<code>DOMContentLoaded</code>事件被触发时触发页面加载完成。</li>
<li>
<p>这将确保当至少500毫秒内没有超过0个网络连接时，木偶师告诉我们页面加载完成。</p>
</li>
<li>
<p>这将确保当至少500毫秒内没有超过2个网络连接时，Puppeteer告诉我们页面加载完成。</p>
</li>
</ul>
<p>默认的页面加载事件是加载。我们可以在<code>page.goto(...)</code>调用中设置以上选项。</p>
<p>为了设置<code>domcontentload</code>页面加载事件，我们这样做:</p>
<pre>await .goto( "https://medium.com",{
    waitUntil: 'domcontentloaded'
});</pre>
<p>页面加载事件在传递给<code>page.goto(...)</code>的选项的<code>waitUntil</code>字段中设置。这里，当<code>DOMContentLoaded</code>事件被触发时，页面加载将被视为完成。</p>
<pre>await .goto( "https://medium.com",{
    waitUnitl: 'networkidle0'
});</pre>
<p>这里，当至少500毫秒没有网络连接时，页面加载将被视为完成。</p>
<pre>await .goto( "https://medium.com",{
    waitUnitl: 'networkidle2'
});</pre>
<p>这里，当至少500毫秒内没有超过2个网络连接时，页面加载将被视为完成。</p>
<h2>横向模式</h2>
<p>为了在横向模式下截取网页的截图，我们将把<code>isLandscape</code>选项传递给<code>page.setViewport(...)</code>调用。</p>
<pre>page.setViewport({
    ...,
    isLandscape: true
})</pre>
<p>这将采取横向模式的网页截图。</p>
<h2>让它成为一种服务</h2>
<p>我们可以扩展这个实现，把它变成一个服务，就像在线网页变成图像服务一样。</p>
<p>这项服务将让用户对他们的网页或任何选定的网页进行截图。</p>
<p>我们将在Node.js中实现这个服务。</p>
<p>以下是后端代码:</p>
<pre>/** require dependencies */
const express = require("express")
const cors = require('cors')
const bodyParser = require('body-parser')
const helmet = require('helmet')
const path = require('path')
const puppeteer = require("puppeteer")

const app = express()

let port = process.env.PORT || 5000

/** set up middlewares */
app.use(cors())
app.use(bodyParser.json({limit: '50mb'}))
app.use(helmet())

app.get("/", (request, response) =&gt; {
    response.sendFile(path.join(__dirname, 'index.html'));
});

app.get("/style.css", (request, response) =&gt; {
    response.sendFile(path.join(__dirname, 'style.css'));
});

app.get('*', function(req, res) {
  res.sendFile(path.resolve(__dirname, 'index.html'));
});

app.use('/static',express.static(path.join(__dirname,'static')))
app.use('/assets',express.static(path.join(__dirname,'assets')))

app.post('/api/screenshot', (req, res, next) =&gt; {
    const { url } = req.body

    var screenshot = takeScreenshot(url)
    res.send({result: screenshot })
    next()    
})

async function takeScreenshot(url) {
    const browser = await puppeteer.launch({ 
       headless: true,
       args: ['--no-sandbox'] 
     });
    const page = await browser.newPage();
    await page.goto(url, { waitUntil: 'networkidle0' });
    const screenShot = await page.screenshot({
        path: "./",
        type: "png",
        fullPage: true
    })

    await browser.close();
    return screenshot;
}

/** start server */
app.listen(port, () =&gt; {
    console.log(`Server started at port: ${port}`);
});</pre>
<p><code>takeScreenshot</code>函数是主代码。我们将从请求体中获取想要截图的网页的URL，并将其传递给<code>takeScreenshot</code>函数。创建了一个木偶浏览器实例，我们将导航到URL。然后对页面进行截屏，并将截屏返回给用户。</p>
<p>让我们看看前端代码:</p>
<pre>&lt;title&gt;Webpage to Image&lt;/title&gt;

&lt;style&gt;
&lt;/style&gt;

&lt;body&gt;
    &lt;header&gt;
        &lt;div class="title-bar"&gt;&lt;h2&gt;Webpage to Image&lt;/h2&gt;&lt;/div&gt;
    &lt;/header&gt;
    &lt;div class="container"&gt;
        &lt;div class="info close" id="info"&gt;
            &lt;h3&gt;Info&lt;/h3&gt;
        &lt;/div&gt;
        &lt;div class="wrapper"&gt;
            &lt;div class="div-input" style=""&gt;
                &lt;input id="webpageUrl" type="text" placeholder="Type your webpage URL" /&gt;
            &lt;/div&gt;
            &lt;div class="div-button"&gt;
                &lt;button id="webpageButton" onclick="return generateImage(event)"&gt;
                    Generate Image
                &lt;/button&gt;
            &lt;/div&gt;                
        &lt;/div&gt;
    &lt;/div&gt;
&lt;/body&gt;
&lt;script src="./axios/axios.min.js"&gt;&lt;/script&gt;
&lt;script&gt;

    webpageUrl.addEventListener("keydown", (evt) =&gt; {
        if(evt.key == "Enter")
            generateImage(evt)
    })

    function generateImage(evt) {
        evt.preventDefault()

        showLoading(true)
        disableButton(true)

        if(webpageUrl.value.length === 0) {
            showLoading(false)
            info.innerHTML = `
                &lt;h3&gt;Error&lt;/h3&gt;
                Please, Type in the webpage URL.
            `
            info.classList.add("info-danger")
            info.classList.remove("close")

            setTimeout(() =&gt; {
                info.classList.add("close")
                info.classList.remove("info-danger")
            }, 3000)
        } else
            axios.post("api/screenshot", { url: webpageUrl.value } ).then( res =&gt; {
                showLoading(false)
                const { result } = res.data
                const blob = new Blob([result], {type: 'image/png'})
                const link = document.createElement('a')
                link.href = window.URL.createObjectURL(blob)
                link.download = `your-file-name.png`
                link.click()
            }).catch(err =&gt; {
                showLoading(false)

                // err

                info.innerHTML = `
                    &lt;h3&gt;Error&lt;/h3&gt;
                    ${err}
                `
                info.classList.add("info-danger")
                info.classList.remove("close")
                setTimeout(() =&gt; {
                    info.classList.add("close")
                    info.classList.remove("info-danger")
                }, 3000)
            })

        disableButton(false)
    }

    function showLoading(show) {
        if(show == true) {
            webpageButton.innerHTML = "wait..."
        } else {
            webpageButton.innerHTML = "Generate Image"
        }
    }

    function disableButton(disable) {
        if(disable == true) {
            webpageButton.setAttribute("disable", true)
        } else {
            webpageButton.removeAttribute("disable")
        }
    }
&lt;/script&gt;
...</pre>
<p>我们有输入和按钮。我们在输入中输入想要截图的网页。点击后，按钮将调用“API/截图”处的后端API，并随其一起发送输入框中的网页URL。“API/截图”处的后端代码将生成截图并将其发送回用户。Axios get调用中的解析函数将运行，我们将以编程方式将生成的图像下载到我们的存储中。</p>
<p>很简单。</p>
<p>除此之外，您还可以添加更多功能:</p>
<ul>
<li>要生成的图像类型</li>
<li>批量图像处理(在这里，用户可以添加一组网页，服务将在批量处理中生成它们的图像)</li>
<li>屏幕截图大小</li>
<li>要截图的网页区域</li>
<li>背景透明度</li>
<li>等等</li>
</ul>
<p>您可以根据Puppeteer APIs中的不同选项来设置选项。</p>
<p>天空是极限。</p>
<h2>结论</h2>
<p>毫无疑问，木偶师非常棒。</p>
<p>它有如此多的API，你可以利用它来制作一些很酷的东西。在此找到它们:</p>
<blockquote class="embedly-card" data-card-controls="1" data-card-align="center" data-card-theme="light">

<p>无头Chrome Node.js API。在GitHub上创建一个帐户，为木偶师/木偶师的发展做出贡献。</p>
</blockquote>
<p/>
<p>如果你对此有任何问题，请随时评论，发电子邮件或给我发短信。</p><div class="code-block code-block-23">
<div class="blog-plug inline-plug node-plug"><h2>200只<img src="../Images/61167b9d027ca73ed5aaf59a9ec31267.png" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2019/10/green-check.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" class=" jetpack-lazy-image" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/10/green-check.png"/> <noscript> <img data-lazy-fallback="1" src="../Images/61167b9d027ca73ed5aaf59a9ec31267.png" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/10/green-check.png"/> </noscript>显示器出现故障，生产中网络请求缓慢</h2><p>部署基于节点的web应用程序或网站是容易的部分。确保您的节点实例继续为您的应用程序提供资源是事情变得更加困难的地方。如果您对确保对后端或第三方服务的请求成功感兴趣，</p><a href="https://lp.logrocket.com/blg/node-signup" target="_blank">try LogRocket</a><p>. </p><a class="signup" href="https://lp.logrocket.com/blg/node-signup" target="_blank" rel="noopener noreferrer"><img src="../Images/cae72fd2a54c5f02a6398c4867894844.png" alt="LogRocket Network Request Monitoring" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2019/12/network-request-filter-2-1.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" class=" jetpack-lazy-image" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/12/network-request-filter-2-1.png"/><noscript><img data-lazy-fallback="1" src="../Images/cae72fd2a54c5f02a6398c4867894844.png" alt="LogRocket Network Request Monitoring" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/12/network-request-filter-2-1.png"/></noscript></a><a href="https://lp.logrocket.com/blg/node-signup" target="_blank" rel="noopener noreferrer">https://logrocket.com/signup/</a><p>LogRocket 就像是网络和移动应用程序的DVR，记录下用户与你的应用程序交互时发生的一切。您可以汇总并报告有问题的网络请求，以快速了解根本原因，而不是猜测问题发生的原因。</p><p>LogRocket检测您的应用程序以记录基线性能计时，如页面加载时间、到达第一个字节的时间、慢速网络请求，还记录Redux、NgRx和Vuex操作/状态。</p><a class="signup" href="https://lp.logrocket.com/blg/node-signup" target="_blank" rel="noopener noreferrer">Start monitoring for free</a><p>. </p></div>
</div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
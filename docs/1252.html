<html>
<head>
<title>Why you should switch from Ruby to Crystal - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>为什么你应该从Ruby转到Crystal - LogRocket博客</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/why-you-should-switch-from-ruby-to-crystal/#0001-01-01">https://blog.logrocket.com/why-you-should-switch-from-ruby-to-crystal/#0001-01-01</a></blockquote><div><article class="article-post">
<h2>爱Ruby？试试水晶</h2>
<p>你爱露比吗？你希望有一个更好的Ruby版本，像C一样有超快的性能吗？你的祈祷得到了回应。让我把你介绍给克里斯托。互联网称之为“像红宝石一样光滑，像C语言一样快”。</p>
<p>从一开始，开发人员就因为Ruby编程语言的简单性、对开发人员满意度和生产力的关注而爱上了它。</p>
<p>Ruby(和Rails框架)在过去十年中催生了一些传奇的初创公司，包括Twitter、Github、AirBnB、Shopify、Soundcloud等等。</p>
<p>然而，Ruby的主要缺点是性能和可伸缩性。作为一种解释型语言，Ruby的性能不如C/C++、Rust和Go。</p>
<p>尽管并非不可能，但是很难扩展Ruby on Rails应用程序。此外，Ruby中缺少静态类型，这使得随着开发团队的成长，重构代码变得很困难。另一方面，Crystal拥有Ruby的所有优点，却没有它的缺点。</p>
<p>✔️ Crystal拥有Ruby一样漂亮的语法<br/> ✔️ Crystal的性能堪比C <br/> ✔️ Crystal支持原生c绑定<br/> ✔️静态类型和强大的宏用于元编程<br/> ✔️ Crystal拥有Rails和Sinatra一样的web框架</p>
<p>Crystal的语法和Ruby的几乎一样。</p>
<p>你将能够在Crystal shell中直接编写Ruby代码，反之亦然。像Ruby一样，Crystal专注于让开发人员开心和高效。Ruby开发人员对Crystal语法如鱼得水。以这个例子为例(斐波那契数列函数🌀):</p>
<pre>def fib(n)
  if (n&lt;=2)
    return 1
  else
    return (fib(n-1) + fib(n-2))
  end
end</pre>
<p>这个代码片段对于Ruby和Crystal是相同的。由于语法相似，从一个迁移到另一个绝对轻而易举。</p>
<p>安装Crystal并设置您的开发环境也非常简单。你可以在任何Linux发行版或Mac上用几个简单的命令安装Crystal。在这里看一下官方<a href="https://crystal-lang.org/install/" target="_blank" rel="noopener noreferrer">指南。但是，您需要安装一个Linux子系统来在windows上运行Crystal。建议Ubuntu 18.04或更高版本。</a></p>
<h3>惊人的表现</h3>
<p>在大多数基准测试中，Crystal的性能优于Go、Python和Node.js。下面是几个链接，比较了Crystal与其他编程语言的性能:</p>
<p>🚆 👉<a href="https://github.com/the-benchmarker/web-frameworks" target="_blank" rel="noopener noreferrer">性能基准</a> <br/>🚆 👉<a href="https://github.com/drujensen/fib?ref=hackernoon.com" target="_blank" rel="noopener noreferrer">性能对比</a></p>
<p>Crystal构建在LLVM框架之上。这就是Crystal炽热表现背后的秘密。LLVM是将C/C++代码编译成字节码的同一个框架。</p>
<h3>晶体中易结合碳</h3>
<p>使用Crystal，您可以毫不费力地绑定到现有的C库和代码。这允许开发人员使用原生C库处理应用程序中的低级任务，进一步提高性能。</p>
<p>这里有一个用Crystal做C绑定的例子。</p>
<p>假设我们有以下用C编写的简单函数:</p>
<pre>#include &lt;stdio.h&gt;
void hello(const char * name){
  printf("Say Hello %s!\n", name);
}</pre>
<p>首先，我们可以用<code>gcc -c hello.c -o hello.o</code>编译它，然后在Crystal脚本中调用它，如下所示:</p>
<pre>#hello.cr
@[Link(ldflags: "#{__DIR__}/hello.o")]
lib Say 
  fun hello(name : LibC::Char*) : Void
end
Say.hello("to 🔮")</pre>
<h3>静态打字</h3>
<p>Crystal最棒的特性之一是它的静态类型系统。它帮助开发人员在编译时捕捉错误。Ruby和Python等动态类型语言允许开发人员轻松编写代码并快速交付特性。然而，随着时间的推移，随着我们的代码库和团队的成长，重构和维护这些代码变得越来越困难。</p>
<p>嗯，Crystal对这个问题有一个独特的解决方案。</p>
<p>你可以像任何动态类型语言一样用Crystal编写代码。编译器只会抱怨，并要求您在不明确的情况下显式指定类型。</p>
<h3>Web框架</h3>
<p>让我们来看看适用于Crystal的web框架。如果你喜欢Rails或者Phoenix，那么你会喜欢Crystal的Amber框架。</p>
<p><a href="https://amberframework.org/" target="_blank" rel="noopener noreferrer"> Amber </a>围绕Rails的相同理念构建(约定胜于配置)。另一个有前途的框架是<a href="https://www.luckyframework.org/" target="_blank" rel="noopener noreferrer"> Lucky </a>，也是受Rails启发。这两个框架都有令人惊叹的文档和一个热情的开发人员社区，他们积极地为代码库做出贡献。</p>
<p>另一方面，如果你是Flask、Express.js (Node.js)和Sinatra等轻量级web框架的粉丝，那么就来看看<a href="https://kemalcr.com/" target="_blank" rel="noopener noreferrer"> Kemal </a>。还不服气？</p>
<p>好吧，看看这些web框架的<a href="http://techempower.com/benchmarks" target="_blank" rel="noopener noreferrer">性能基准</a>。与其他web框架相比，Crystal框架表现非常好，Crystal框架的响应时间在亚毫秒级。</p>
<h3>元编程怎么样？</h3>
<p>Crystal有一个强大的宏系统用于元编程。它可以用于一系列事情，比如基本的模板、AST检查、类型检查和运行任意的外部程序。【来源:<a href="https://crystal-lang.org" target="_blank" rel="noopener noreferrer">https://crystal-lang.org</a></p>
<p>以这段代码片段为例。我们可以用这个简单的函数生成模块、类和结构:</p>
<pre>macro define_class(module_name, class_name, method, content)
  module {{module_name}}
    class {{class_name}}
      def initialize(@name : String)
      end
      def {{method}}
        {{content}} + @name
      end
    end
  end
end
# This generates:
#     module Foo
#       class Bar
#         def initialize(@name : String)
#         end
#
#         def say
#           "hi " + @name
#         end
#       end
#     end
define_class Foo, Bar, say, "hi "
p Foo::Bar.new("John").say # =&gt; "hi John"</pre>
<p>你可以点击<a href="https://crystal-lang.org/reference/syntax_and_semantics/macros.html" target="_blank" rel="noopener noreferrer">链接</a>了解更多关于Crystal macros的信息。</p>
<h2>让我们谈谈并发性</h2>
<p>Crystal使用一种叫做纤程的东西来实现并发。纤程类似于操作系统线程，但是轻量级的。执行由流程内部管理。一个程序可以产生多个纤程，Crystal将高效地执行它们以优化性能。</p>
<p>纤程和围棋套路很像。下面是一个产生纤维的例子:</p>
<pre>spawn do
  # ...
  socket.gets
  # ...
end
spawn do
  # ...
  sleep 5.seconds
  #  ...
end</pre>
<p>【来源:<a href="https://crystal-lang.org/reference/guides/concurrency.html" target="_blank" rel="noopener noreferrer">https://crystal-lang.org/reference/guides/concurrency.html</a></p>
<p>Crystal允许不同光纤之间的数据通信，而不必共享内存或担心锁。Crystal通过渠道实现这一点，渠道的灵感来自于<a href="https://en.wikipedia.org/wiki/Communicating_sequential_processes" target="_blank" rel="noopener noreferrer"> CSP </a>(通信顺序流程)</p>
<p>排比怎么样？</p><div class="code-block code-block-54">
<hr/>
<h3>更多来自LogRocket的精彩文章:</h3>

<hr/></div>
<p>目前Crystal不支持并行。然而，该团队正在努力将这一功能纳入稳定版本。</p>
<p>如果你很好奇，想研究一下，请随意阅读关于并发模型的crystal <a href="https://crystal-lang.org/reference/guides/concurrency.html" target="_blank" rel="noopener noreferrer">文档。</a></p>
<h2>那么，有什么条件呢？</h2>
<p>如果你开发软件已经有一段时间了，你应该已经知道每项技术都有其局限性。Crystal的主要缺点是它是一个新手。许多人认为Crystal及其生态系统还不成熟，没有做好生产准备。</p>
<p>虽然在某种程度上这是真的，但这也为你提前适应这个闪亮的新工具提供了可能性。电动汽车初创公司Nikola Motors正在生产中使用Crystal来驱动他们的软件。你可以在这里阅读他们的故事<a href="https://manas.tech/blog/2020/02/11/nikola-motor-company" target="_blank" rel="noopener noreferrer">。</a></p>
<p>可用于Crystal的库也有些有限。与Ruby的Gems或Node的npm包相比，Crystal的可用库没有那么多样化。</p>
<p>最后，如果你试图建立一个利基产品，并解决一个非常具体的问题，你可能无法找到文档。例如，我试图用Crystal剥离GraphQL服务器。虽然Github中有一些很好的例子，但我找不到任何关于这个主题的合适的文档或教程。</p>
<h2>结论</h2>
<p>Crystal带来了Ruby的所有优点，没有它的任何限制。从Ruby移植到Crystal很容易，反之亦然。Crystal很快，有漂亮的类似Ruby的语法、静态类型和强大的功能，比如元编程的宏。然而，像每种技术一样，Crystal也有自己的局限性。</p>
<p>Crystal的主要限制是它不像Ruby、Node或Python那样成熟。随着越来越多热情的开发人员支持Crystal，它可能很快就会成为web开发领域的下一个大玩家。作为一个Rubyist本人，我知道我正在密切关注Crystal的发展。</p>
<h2>额外资源</h2>

<p>使用<a class="signup" href="https://lp.logrocket.com/blg/signup" target="_blank" rel="noopener noreferrer"> LogRocket </a>消除传统错误报告的干扰</p><div class="code-block code-block-2">
<div class="blog-plug base-cta"><h2><a href="https://lp.logrocket.com/blg/signup" target="_blank" rel="noopener noreferrer"> LogRocket </a>是一个数字体验分析解决方案，它可以保护您免受数百个假阳性错误警报的影响，只针对几个真正重要的项目。LogRocket会告诉您应用程序中实际影响用户的最具影响力的bug和UX问题。</h2>
<a href="https://lp.logrocket.com/blg/signup" class="signup" target="_blank" rel="noopener noreferrer"><img class="alignnone size-full wp-image-46 jetpack-lazy-image" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/><noscript><img data-lazy-fallback="1" class="alignnone size-full wp-image-46" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/></noscript></a>
<p>然后，使用具有深层技术遥测的会话重放来确切地查看用户看到了什么以及是什么导致了问题，就像你在他们身后看一样。</p>
<p>LogRocket自动聚合客户端错误、JS异常、前端性能指标和用户交互。然后LogRocket使用机器学习来告诉你哪些问题正在影响大多数用户，并提供你需要修复它的上下文。</p>
<p>关注重要的bug—<a class="signup" href="https://lp.logrocket.com/blg/signup-issue-free" target="_blank" rel="noopener noreferrer">今天就试试LogRocket】。</a></p>
<p>Focus on the bugs that matter — <a class="signup" href="https://lp.logrocket.com/blg/signup-issue-free" target="_blank" rel="noopener noreferrer">try LogRocket today</a>.</p></div></div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
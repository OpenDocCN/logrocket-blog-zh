<html>
<head>
<title>Types vs. interfaces in TypeScript - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>TypeScript - LogRocket博客中的类型与接口</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/types-vs-interfaces-in-typescript/#0001-01-01">https://blog.logrocket.com/types-vs-interfaces-in-typescript/#0001-01-01</a></blockquote><div><article class="article-post">
<p>在JavaScript中进行静态类型检查的想法非常棒，TypeScript的采用每天都在增加。</p>
<p>你开始在你的项目中使用TypeScript，你创建了你的第一个类型，然后你跳转到你的第一个接口，你让它工作。您的结论是，TypeScript实际上有助于您的开发并节省了您的宝贵时间，但是当您开始使用TypeScript中的类型和接口时，您可能犯了一些错误并且没有遵循最佳实践。</p>
<p>这是许多开发人员的情况，他们并不真正知道类型别名和TypeScript中的接口之间的真正区别。</p>
<p>开始使用TypeScript非常简单，但有时我们需要更多地考虑对我们来说最好的用例。在这种情况下，是类型还是接口？</p>
<h2>类型和类型别名</h2>
<p>在我们开始讨论TypeScript中类型和接口的区别之前，我们需要了解一些事情。</p>
<p>在TypeScript中，我们有很多基本类型，比如string、boolean和number。这些是类型脚本的基本类型。你可以在这里查看所有基本类型<a href="https://www.typescriptlang.org/docs/handbook/basic-types.html#table-of-contents" target="_blank" rel="noopener noreferrer">的列表。同样，在TypeScript中，我们有高级类型，在这些</a><a href="https://www.typescriptlang.org/docs/handbook/advanced-types.html" target="_blank" rel="noopener noreferrer">高级类型</a>中，我们有被称为<a href="https://www.typescriptlang.org/docs/handbook/advanced-types.html#type-aliases" target="_blank" rel="noopener noreferrer">类型别名</a>的东西。使用类型别名，我们可以为类型创建一个新的名称，但是我们不能定义一个新的类型。</p>
<p>我们使用<code>type</code>关键字来创建一个新的类型别名，这就是为什么有些人可能会感到困惑，认为这是在创建一个新的类型，而他们只是在为一个类型创建一个新的名称。所以，当你听到有人谈论类型和接口之间的区别时，就像在这篇文章中，你可以假设这个人谈论的是类型别名和接口。</p>
<p>我们将使用<a href="https://www.typescriptlang.org/play/index.html#" target="_blank" rel="noopener noreferrer"> TypeScript Playground </a>作为代码示例。<a href="https://www.typescriptlang.org/play/index.html#" target="_blank" rel="noopener noreferrer"> TypeScript Playground </a>允许我们工作和测试最新版本的TypeScript(或者我们想要的任何其他版本)，通过使用这个Playground，我们将节省时间，而不是仅仅为了示例而创建一个新的TypeScript项目。</p>
<h2>类型与接口</h2>
<p>在TypeScript中，类型和接口之间的区别曾经更加明显，但是随着TypeScript的最新版本，它们变得更加相似。</p>
<p>接口基本上是描述数据形状的一种方式，例如，一个对象。</p>
<p>类型是数据类型的定义，例如，联合、基元、交集、元组或任何其他类型。</p>
<h3>声明合并</h3>
<p>有一件事可以用接口来做，但不能用类型来做，那就是声明合并。当TypeScript编译器将两个或更多共享相同名称的接口合并到一个声明中时，就会发生声明合并。</p>
<p>假设我们有两个名为<code>Song</code>的接口，具有不同的属性:</p>
<pre>interface Song {
  artistName: string;
};

interface Song {
  songName: string;
};

const song: Song = {
  artistName: "Freddie",
  songName: "The Chain"
};</pre>
<p>TypeScript会自动将两个接口声明合并成一个，所以当我们使用这个<code>Song</code>接口时，我们将拥有两个属性。</p>
<p>声明合并不适用于类型。如果我们试图创建两个名称相同但属性不同的类型，TypeScript仍然会抛出一个错误。</p>
<pre>Duplicate identifier Song.</pre>
<h2>扩展和实现</h2>
<p>在TypeScript中，我们可以轻松地扩展和实现接口。但是这对于类型是不可能的。</p>
<p>TypeScript中的接口可以扩展类，这是一个非常棒的概念，在更面向对象的编程方式中有很大帮助。我们也可以创建实现接口的类。</p>
<p>例如，假设我们有一个名为<code>Car</code>的类和一个名为<code>NewCar</code>的接口，我们可以使用一个接口轻松扩展这个类:</p>
<pre>class Car {
  printCar = () =&gt; {
    console.log("this is my car")
  }
};

interface NewCar extends Car {
  name: string;
};

class NewestCar implements NewCar {
  name: "Car";
  constructor(engine:string) {
    this.name = name
  }
  printCar = () =&gt; {
    console.log("this is my car")
  }
};</pre>
<h2>交集</h2>
<p>交集允许我们将多种类型组合成一种类型。要创建交集类型，我们必须使用<code>&amp;</code>关键字:</p>
<pre>type Name = {
  name: “string”
};

type Age = {
  age: number
};

type Person = Name &amp; Age;</pre>
<p>这里好的一点是，我们可以创建一个新的交集类型，例如，合并两个接口，但不能反过来。我们不能创建一个结合两种类型的接口，因为它不起作用:</p>
<pre>interface Name {
  name: “string”
};

interface Age {
  age: number
};

type Person = Name &amp; Age;</pre>
<h3>联盟</h3>
<p>联合类型允许我们创建一个新类型，它可以有一个或几个类型的值。要创建一个联合类型，我们必须使用<code>|</code>关键字。</p>
<pre>type Man = {
  name: “string”
};

type Woman = {
  name: “string”
};

type Person = Man | Woman;</pre>
<p>例如，与交集类似，我们可以创建一个新的联合类型来组合两个接口，但不能反过来:</p>
<pre>interface Man {
  name: "string"
};

interface Woman {
  name: "string"
};

type Person = Man | Woman;</pre>
<h3>元组</h3>
<p><a href="https://www.typescriptlang.org/docs/handbook/basic-types.html#tuple" target="_blank" rel="noopener noreferrer">元组</a>是TypeScript中一个非常有用的概念，它给我们带来了这种新的数据类型，它包括两组不同数据类型的值。</p>
<pre>type Reponse = [string, number]</pre>
<p>但是，在TypeScript中，我们只能使用类型而不是接口来声明元组。我们无法使用接口在TypeScript中声明元组，但是您仍然可以在接口中使用元组，如下所示:</p>
<pre>interface Response {
  value: [string, number]
}</pre>
<p>我们可以看到，使用带有接口的类型可以获得相同的结果。因此，很多开发人员可能会有一个问题——我应该使用类型而不是接口吗？如果是，什么时候应该使用类型？</p>
<p>让我们来了解两者的最佳用例，这样你就不需要为了一个而抛弃另一个。</p><div class="code-block code-block-54">
<hr/>
<h3>更多来自LogRocket的精彩文章:</h3>

<hr/></div>
<h2>我应该用什么？</h2>
<p>这个问题非常棘手，你可能会猜测，它的答案取决于你正在构建什么和你正在做什么。</p>
<p>当你需要定义一个新的对象或对象的方法时，接口会更好。例如，在React应用程序中，当您需要定义特定组件将要接收的属性时，最好使用接口而不是类型:</p>
<pre>interface TodoProps {
  name: string;
  isCompleted: boolean
};

const Todo: React.FC&lt;TodoProps&gt; = ({ name, isCompleted }) =&gt; {
  ...
};</pre>
<p>例如，当您需要创建函数时，类型更好。假设我们有一个函数将返回一个名为的对象，这种方法更推荐使用类型别名:</p>
<pre>type Person = {
  name: string,
  age: number
};

type ReturnPerson = (
  person: Person
) =&gt; Person;

const returnPerson: ReturnPerson = (person) =&gt; {
  return person;
};</pre>
<p>在一天结束时，要决定是否应该使用类型别名或接口，您应该仔细考虑和分析情况——您正在做什么，具体的代码，等等。</p>
<p>接口更适合处理对象和方法对象，类型更适合处理函数和复杂类型等。</p>
<p>你不应该开始使用一个而删除另一个。与其这样做，不如开始慢慢重构，考虑什么对特定情况更有意义。</p>
<p>请记住，您可以一起使用两者，它们会工作得很好。这里的想法只是阐明类型和接口之间的区别，以及两者的最佳用例。</p>
<h2>结论</h2>
<p>在本文中，我们了解了更多关于TypeScript中类型和接口之间的区别。我们了解了类型别名是TypeScript中的高级类型，我们了解了TypeScript中类型和接口的最佳用例，以及我们如何在实际项目中应用它们。</p><div class="code-block code-block-21">
<div class="blog-plug inline-plug typescript-plug"><h2><a class="signup" href="https://lp.logrocket.com/blg/typescript-signup" target="_blank" rel="noopener noreferrer"> LogRocket </a>:全面了解您的网络和移动应用</h2>
<a href="https://lp.logrocket.com/blg/typescript-signup" class="signup" target="_blank" rel="noopener noreferrer"><img class="alignnone size-full wp-image-46 jetpack-lazy-image" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/><noscript><img data-lazy-fallback="1" class="alignnone size-full wp-image-46" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/></noscript></a>
<p>LogRocket 是一个前端应用程序监控解决方案，可以让您回放问题，就像问题发生在您自己的浏览器中一样。LogRocket不需要猜测错误发生的原因，也不需要向用户询问截图和日志转储，而是让您重放会话以快速了解哪里出错了。它可以与任何应用程序完美配合，不管是什么框架，并且有插件可以记录来自Redux、Vuex和@ngrx/store的额外上下文。</p>
<p>除了记录Redux操作和状态，LogRocket还记录控制台日志、JavaScript错误、堆栈跟踪、带有头+正文的网络请求/响应、浏览器元数据和自定义日志。它还使用DOM来记录页面上的HTML和CSS，甚至为最复杂的单页面和移动应用程序重新创建像素级完美视频。</p>
<a class="signup" href="https://lp.logrocket.com/blg/typescript-signup" target="_blank" rel="noopener noreferrer">Try it for free</a><p>.</p></div>
</div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
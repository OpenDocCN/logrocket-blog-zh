<html>
<head>
<title>Making HTTP requests in Go - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>在Go - LogRocket博客中发出HTTP请求</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/making-http-requests-in-go/#0001-01-01">https://blog.logrocket.com/making-http-requests-in-go/#0001-01-01</a></blockquote><div><article class="article-post">
<p>HTTP请求是整个web的一个非常基础的部分。它们用于访问服务器(可能是远程的)上托管的资源。</p>
<p>HTTP是超文本传输协议的缩写，超文本传输协议是一种确保客户端和服务器之间数据传输的通信协议。HTTP客户端-服务器交互的一个完美实例是当您打开浏览器并键入URL时。您的浏览器充当客户端，从服务器获取资源，然后显示出来。</p>
<p>在web开发中，我们需要获取资源的情况非常普遍。您可能正在开发一个天气应用程序，需要从一个API获取天气数据。在这种情况下，在应用程序中使用浏览器作为客户端将不再可能。因此，您必须在应用程序中设置一个HTTP客户端来处理这些请求。</p>
<p>大多数编程语言都有各种各样的结构来设置HTTP客户端以发出请求。在接下来的几节中，我们将采取实践的方法来探索如何用Golang或Go进行HTTP请求，因为在本文的其余部分我将参考这种语言。</p>
<h2>先决条件</h2>
<p>要阅读本文，您需要:</p>

<h2>在Go中发出HTTP请求</h2>
<h3>获取请求</h3>
<p>我们将发出的第一个请求是GET请求。HTTP GET方法用于从指定的源或服务器请求数据。GET方法主要在需要获取数据时使用。</p>
<p>为了清楚起见，需要注意的是，本文中的HTTP方法总是大写的。</p>
<p>对于我们的例子，我们将使用GET方法从<a href="https://jsonplaceholder.typicode.com/posts" target="_blank" rel="noopener noreferrer">https://jsonplaceholder.typicode.com/posts</a>获取一些示例JSON数据。</p>
<p>用Go发出HTTP请求的第一步是从标准库中导入<code>net/http</code>包。这个包为我们提供了轻松进行HTTP请求所需的所有工具。我们可以通过将下面几行代码添加到我们创建的<code>main.go</code>文件中来导入<code>net/http</code>包和我们需要的其他包:</p>
<pre>import (
   "io/ioutil"
   "log"
   "net/http"
)</pre>
<p>我们导入的<code>net/http</code>包有一个GET函数，用于发出Get请求。Get函数接收一个URL，并返回一个指向结构的指针类型的响应和一个错误。当错误为<code>nil</code>时，返回的响应将包含响应体，反之亦然:</p>
<pre>resp, err := http.Get("https://jsonplaceholder.typicode.com/posts/1")
if err != nil {
   log.Fatalln(err)
}</pre>
<p>为了发出请求，我们调用Get函数，传入一个URL字符串(【https://jsonplaceholder.typicode.com/posts】)如上所示。调用该函数返回的值存储在两个变量中，通常称为resp和err。尽管变量resp包含了我们的响应，但是如果我们把它打印出来，我们会得到一堆不一致的数据，包括请求的头和属性。为了获得我们感兴趣的响应，我们必须访问response结构上的<code>Body</code>属性，并在最终将它输出到终端之前读取它。我们可以使用<code>ioutil.ReadMe</code>函数读取响应体。</p>
<p>类似于<code>Get</code>函数，<code>ioutil.ReadMe</code>函数返回一个主体和一个错误。需要注意的是，响应<code>Body</code>应该在我们读完之后关闭，以防止内存泄漏。</p>
<p>在函数末尾执行<code>resp.Body.Close()</code>的defer关键字用于关闭响应体。然后，我们可以打印出终端响应的值。作为优秀的程序员，处理可能的错误是很重要的，因此我们使用if语句来检查任何错误，如果存在错误，则记录错误:</p>
<pre>package main

import (
   "io/ioutil"
   "log"
   "net/http"
)

func main() {
   resp, err := http.Get("https://jsonplaceholder.typicode.com/posts")
   if err != nil {
      log.Fatalln(err)
   }
//We Read the response body on the line below.
   body, err := ioutil.ReadAll(resp.Body)
   if err != nil {
      log.Fatalln(err)
   }
//Convert the body to type string
   sb := string(body)
   log.Printf(sb)
}</pre>
<p>此时，我们已经设置好了，可以执行包含我们代码的文件了。如果一切顺利，您会注意到一些类似下图的JSON数据被打印到终端上:</p>
<p><img data-attachment-id="25064" data-permalink="https://blog.logrocket.com/making-http-requests-in-go/jsondatainterminal/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/09/jsondatainterminal.png" data-orig-size="680,233" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="jsondatainterminal" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/09/jsondatainterminal-300x103.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/09/jsondatainterminal.png" decoding="async" class="aligncenter size-full wp-image-25064 jetpack-lazy-image" src="../Images/d3e249abd3798abe53893bc0c1a05590.png" alt="JSON data printed in terminal including user ID, id, title, and body" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2020/09/jsondatainterminal.png 680w, https://blog.logrocket.com/wp-content/uploads/2020/09/jsondatainterminal-300x103.png 300w" data-lazy-sizes="(max-width: 680px) 100vw, 680px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2020/09/jsondatainterminal.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/09/jsondatainterminal.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="25064" data-permalink="https://blog.logrocket.com/making-http-requests-in-go/jsondatainterminal/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/09/jsondatainterminal.png" data-orig-size="680,233" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="jsondatainterminal" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/09/jsondatainterminal-300x103.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/09/jsondatainterminal.png" decoding="async" loading="lazy" class="aligncenter size-full wp-image-25064" src="../Images/d3e249abd3798abe53893bc0c1a05590.png" alt="JSON data printed in terminal including user ID, id, title, and body" srcset="https://blog.logrocket.com/wp-content/uploads/2020/09/jsondatainterminal.png 680w, https://blog.logrocket.com/wp-content/uploads/2020/09/jsondatainterminal-300x103.png 300w" sizes="(max-width: 680px) 100vw, 680px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/09/jsondatainterminal.png"/></noscript>
<p>恭喜你，你已经用Go发出了你的第一个HTTP请求。现在我们已经看到了如何使用HTTP GET方法从服务器获取资源，接下来我们将看看如何向服务器发送资源。</p>
<h3>发布请求</h3>
<p>HTTP POST方法用于发出通常包含主体的请求。它用于向服务器发送数据，发送的数据通常用于创建或更新资源。</p>
<p>使用POST请求的一个明显例子是，当用户试图创建一个社交媒体帐户时，用户需要提供他们的数据(姓名、电子邮件和密码)。然后解析这些数据，并作为POST请求发送到服务器，服务器随后创建并保存用户。就像上面看到的GET方法一样，Go的<code>net/http</code>包也提供了通过Post函数发出POST请求的功能。Post函数有三个参数。</p>
<ol>
<li>服务器的URL地址</li>
<li>字符串形式的正文的内容类型</li>
<li>使用类型<code>io.Reader</code>的POST方法发送的请求正文</li>
</ol>
<p>Post函数返回一个响应和一个错误。为了调用Post函数，我们必须将请求体转换为可接受的类型。对于这个例子，我们将向<a href="https://postman-echo.com/post" target="_blank" rel="noopener noreferrer">https://postman-echo.com/post</a>发出一个post请求，并传入包含姓名和电子邮件的JSON数据。首先，我们将JSON数据转换为实现Io的类型。Post函数期望的读者接口，这是一个双向步骤:</p>
<ul>
<li>第一步是对我们的Json数据进行编码，以便它能够以字节格式返回数据，为此我们使用了Go的JSON包提供的<a href="https://golang.org/pkg/encoding/json/#Marshal" target="_blank" rel="noopener noreferrer"> Marshall函数</a></li>
<li>接下来，我们将编码的JSON数据转换成由<code>io.Reader</code>接口实现的类型，我们简单地使用<code>NewBuffer</code>函数，将编码的JSON数据作为参数传入。<code>NewBuffer</code>函数返回一个buffer类型的值，然后我们可以将它传递给Post函数</li>
</ul>
<pre>postBody, _ := json.Marshal(map[string]string{
   "name":  "Toby",
   "email": "<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="9ecaf1fce7defbe6fff3eef2fbb0fdf1f3">[email protected]</a>",
})
responseBody := bytes.NewBuffer(postBody)</pre>
<p>现在我们已经有了Post函数需要的所有参数，我们可以继续调用它，传入https://postman-echo.com/post的<a href="https://postman-echo.com/post" target="_blank" rel="noopener noreferrer">作为URL字符串，传入application/JSON作为内容类型，传入由<code>NewBuffer</code>函数返回的请求体作为请求体。由<code>Post</code>函数返回的值被分配给resp和err，分别代表响应和错误。处理完错误后，我们读取并打印响应体，就像我们在上一节中对Get函数所做的那样。此时，您的文件应该如下所示:</a></p>
<pre>import (
   "bytes"
   "encoding/json"
   "io/ioutil"
   "log"
   "net/http"
)

func main() {
//Encode the data
   postBody, _ := json.Marshal(map[string]string{
      "name":  "Toby",
      "email": "<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="abffc4c9d2ebced3cac6dbc7ce85c8c4c6">[email protected]</a>",
   })
   responseBody := bytes.NewBuffer(postBody)
//Leverage Go's HTTP Post function to make request
   resp, err := http.Post("https://postman-echo.com/post", "application/json", responseBody)
//Handle Error
   if err != nil {
      log.Fatalf("An Error Occured %v", err)
   }
   defer resp.Body.Close()
//Read the response body
   body, err := ioutil.ReadAll(resp.Body)
   if err != nil {
      log.Fatalln(err)
   }
   sb := string(body)
   log.Printf(sb)
}
</pre>
<p>当文件被执行时，如果一切正常，我们应该将响应打印出来。很神奇，对吧？我们刚刚用Go使用<code>net/http</code>包发出了一个post请求，该包提供了使HTTP请求更容易的功能。在下一节中，我们将进行一个项目，帮助我们了解HTTP请求在现实生活中的应用。</p>
<h2>HTTP请求在起作用</h2>
<p>在本节中，我们将构建一个加密货币价格检查器CLI工具！本练习旨在让您看到HTTP请求的真实用例。我们正在构建的工具将检查用户在指定法定货币中指定的任何加密货币的价格。我们将使用Nomics提供的加密市值和定价数据来实时获取加密货币的价格！首先，创建所需的文件和文件夹以匹配下面的树结构:</p>
<pre>├── model/
│   ├── crypto-model.go
├── client/
│   ├── crypto-client.go
└── main.go</pre>
<ul>
<li>加密客户端文件将存放从API获取加密货币数据的代码</li>
<li>加密模型文件包含了我们的应用程序所必需的几个实用函数</li>
<li>主文件是应用程序的中心引擎，它将合并应用程序的所有部分，使其发挥作用</li>
</ul>
<p>在加密模型文件中，我们创建一个对从API接收的数据进行建模的结构，该结构仅包括我们需要/打算使用的特定数据。接下来，我们创建一个名为<code>TextOutput</code>的函数，它是一个属于我们上面创建的<code>Cryptoresponse</code>结构的接收器。<code>TextOutput</code>函数的目的是将从API获得的数据格式化为比JSON(我们从服务器接收的)更容易阅读的纯文本。我们使用<code>fmt.Sprintf</code>函数来格式化数据:</p>
<pre>package model

import (
   "fmt"
)

// Cryptoresponse is exported, it models the data we receive.
type Cryptoresponse []struct {
   Name              string    `json:"name"`
   Price             string    `json:"price"`
   Rank              string    `json:"rank"`
   High              string    `json:"high"`
   CirculatingSupply string    `json:"circulating_supply"`
}

//TextOutput is exported,it formats the data to plain text.
func (c Cryptoresponse) TextOutput() string {
p := fmt.Sprintf(
  "Name: %s\nPrice : %s\nRank: %s\nHigh: %s\nCirculatingSupply: %s\n",
  c[0].Name, c[0].Price, c[0].Rank, c[0].High, c[0].CirculatingSupply)
   return p
}</pre>
<p>既然<code>crypto-model</code>文件已经准备好了，我们可以继续看与我们最相关的<code>crypto-client</code>文件。在<code>crypto-client</code>文件中，我们创建了一个<code>FetchCrypto</code>函数，它接受加密货币和法定货币的名称作为参数。</p>
<blockquote><p>注意，我们将函数名的第一个字母大写，这是为了确保它被导出。</p></blockquote>
<p>在<code>FetchCrypto</code>函数中，我们创建了一个名为URL的变量，该变量是由<a href="https://api.nomics.com/v1/" target="_blank" rel="noopener noreferrer"> Nomics API </a>提供的URL字符串和将被传递到我们的应用程序中的各种变量的串联。还记得我们的应用程序接受所需加密货币和首选法定货币的名称吗？这些是用于构建URL字符串的变量。我们的URL字符串应该是这样的。</p>
<pre>URL := "...currencies/ticker?key=3990ec554a414b59dd85d29b2286dd85&amp;interval=1d&amp;ids="+crypto+"&amp;convert="+fiat
</pre>
<p>设置好URL后，我们可以继续使用上面提到的Get函数来发出请求。Get函数返回响应，我们优雅地处理错误。为了得到我们想要的数据，以我们想要的格式，我们必须解码它！为此，我们使用接收响应体的<code>Json.NewDecoder</code>函数和接收我们在<code>crypto-model</code>文件中创建的cryptoresponse类型变量的decode函数。最后，我们对解码后的数据调用<code>TextOutput</code>函数，使我们能够以纯文本的形式获得结果:</p>
<pre>package client

import (
   "encoding/json"
   "fmt"
   "log"
   "net/http"

   "github.com/Path/to/model"
)

//Fetch is exported ...
func FetchCrypto(fiat string , crypto string) (string, error) {
//Build The URL string
   URL := "https://api.nomics.com/v1/currencies/ticker?key=3990ec554a414b59dd85d29b2286dd85&amp;interval=1d&amp;ids="+crypto+"&amp;convert="+fiat
//We make HTTP request using the Get function
   resp, err := http.Get(URL)
   if err != nil {
      log.Fatal("ooopsss an error occurred, please try again")
   }
   defer resp.Body.Close()
//Create a variable of the same type as our model
   var cResp model.Cryptoresponse
//Decode the data
   if err := json.NewDecoder(resp.Body).Decode(&amp;cResp); err != nil {
      log.Fatal("ooopsss! an error occurred, please try again")
   }
//Invoke the text output function &amp; return it with nil as the error value
   return cResp.TextOutput(), nil
}
</pre>
<p>从上面的内容来看，这个应用程序正在很好地组合在一起。然而，如果您尝试运行上面的文件，您将会遇到一些错误，这是因为我们没有调用<code>FetchCrypto</code>函数，所以没有提供fiat和crypto参数的值。我们将把应用程序的各个部分放在我们创建的<code>main.go</code>文件中。由于我们的应用程序是一个命令行工具，用户必须通过终端传递数据，我们将使用Go的标志包来处理这个问题。</p>
<p>在主函数中，我们创建了两个变量<code>fiatcurrency</code>和<code>nameofcrypto</code>。这两个变量都调用<code>flag.string</code>函数，传入:</p>
<ul>
<li>作为第一个参数的命令名称</li>
<li>作为第二个的回退值</li>
<li>关于如何使用命令作为第三个参数的信息</li>
</ul>
<p>接下来，我们调用在<code>crypto-client</code>文件中定义的<code>FetchCrypto</code>函数，并传入<code>fiatcurrency</code>和<code>nameofcrypto</code>变量。然后我们可以打印对<code>FetchCrypto</code>的调用结果:</p>
<pre>package main

import (
    "flag"
    "fmt"
    "log"

    "github.com/path/to/client"
)

func main() {
    fiatCurrency := flag.String(
      "fiat", "USD", "The name of the fiat currency you would like to know the price of your crypto in",
    )

    nameOfCrypto := flag.String(
      "crypto", "BTC", "Input the name of the CryptoCurrency you would like to know the price of",
    )
    flag.Parse()

    crypto, err := client.FetchCrypto(*fiatCurrency, *nameOfCrypto)
    if err != nil {
        log.Println(err)
      }

  fmt.Println(crypto)
}</pre>
<p>此时，我们可以开始了，如果我们运行命令<code>go run main.go -fiat=EUR -crypto=ETH</code>，我们将得到类似下图的输出:</p>
<p><img data-attachment-id="25077" data-permalink="https://blog.logrocket.com/making-http-requests-in-go/output1/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/09/output1.png" data-orig-size="680,170" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="output1" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/09/output1-300x75.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/09/output1.png" decoding="async" class="aligncenter size-full wp-image-25077 jetpack-lazy-image" src="../Images/6fec23b30b5f7ae14e41010e3064b58b.png" alt="Name: Ethereum, Price: 362.34252819, Rank: 2, High: 1146.26224974, CirculatingSupply: 112196536" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2020/09/output1.png 680w, https://blog.logrocket.com/wp-content/uploads/2020/09/output1-300x75.png 300w" data-lazy-sizes="(max-width: 680px) 100vw, 680px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2020/09/output1.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/09/output1.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="25077" data-permalink="https://blog.logrocket.com/making-http-requests-in-go/output1/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/09/output1.png" data-orig-size="680,170" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="output1" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/09/output1-300x75.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/09/output1.png" decoding="async" loading="lazy" class="aligncenter size-full wp-image-25077" src="../Images/6fec23b30b5f7ae14e41010e3064b58b.png" alt="Name: Ethereum, Price: 362.34252819, Rank: 2, High: 1146.26224974, CirculatingSupply: 112196536" srcset="https://blog.logrocket.com/wp-content/uploads/2020/09/output1.png 680w, https://blog.logrocket.com/wp-content/uploads/2020/09/output1-300x75.png 300w" sizes="(max-width: 680px) 100vw, 680px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/09/output1.png"/></noscript>
<p>这表明我们的应用程序运行良好，非常棒。我们有一个使用HTTP协议从远程服务器获取数据的应用程序。</p>
<h2>结论</h2>
<p>在本文中，我们讨论了如何在Go中发出HTTP请求，并构建了一个CLI工具来检查加密货币的价格。我强烈推荐查看<code>net/http</code>包的<a href="https://golang.org/src/net/http/client.go?s=16191:16251#L460" target="_blank" rel="noopener noreferrer">源代码</a>和<a href="https://golang.org/pkg/net/http/" target="_blank" rel="noopener noreferrer">文档</a>，探索它提供的其他惊人功能。</p><div class="code-block code-block-2">
<div class="blog-plug base-cta"><h2>使用<a class="signup" href="https://lp.logrocket.com/blg/signup" target="_blank" rel="noopener noreferrer"> LogRocket </a>消除传统错误报告的干扰</h2>
<a href="https://lp.logrocket.com/blg/signup" class="signup" target="_blank" rel="noopener noreferrer"><img class="alignnone size-full wp-image-46 jetpack-lazy-image" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/><noscript><img data-lazy-fallback="1" class="alignnone size-full wp-image-46" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/></noscript></a>
<p><a href="https://lp.logrocket.com/blg/signup" target="_blank" rel="noopener noreferrer"> LogRocket </a>是一个数字体验分析解决方案，它可以保护您免受数百个假阳性错误警报的影响，只针对几个真正重要的项目。LogRocket会告诉您应用程序中实际影响用户的最具影响力的bug和UX问题。</p>
<p>然后，使用具有深层技术遥测的会话重放来确切地查看用户看到了什么以及是什么导致了问题，就像你在他们身后看一样。</p>
<p>LogRocket自动聚合客户端错误、JS异常、前端性能指标和用户交互。然后LogRocket使用机器学习来告诉你哪些问题正在影响大多数用户，并提供你需要修复它的上下文。</p>
<p>关注重要的bug—<a class="signup" href="https://lp.logrocket.com/blg/signup-issue-free" target="_blank" rel="noopener noreferrer">今天就试试LogRocket】。</a></p></div></div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
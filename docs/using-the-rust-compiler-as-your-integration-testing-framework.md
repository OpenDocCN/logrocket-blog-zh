# 如何使用 Rust 编译器作为你的集成测试框架

> 原文：<https://blog.logrocket.com/using-the-rust-compiler-as-your-integration-testing-framework/>

当我在 2.5 年前开始在 Rust 中开发时，我对我的程序一旦编译就能正常工作的频率非常着迷。众所周知，Rust 编译器有点迂腐，这在开始时可能会非常令人沮丧。然而，随着时间的推移，我实际上学会了热爱这一方面。这些天来，我经常发现自己故意思考如何以巧妙的方式使用 Rust 的类型系统，让我能够在开发周期的早期捕捉或防止错误。

在本指南中，我将分享我在这个主题上积累的一些知识，并介绍一些使集成测试变得几乎多余的技术。最终，问题是:“它能编译，让我们来发布它！”对铁锈来说是真的吗？

## 回顾 Rust 的一些特性

首先，让我们谈谈 Rust 及其编译器的一些精选特性。

### 强类型

Rust 是强类型的。强类型意味着函数清楚地表达了允许传递给它们的类型。如果你试图传递一个不兼容的类型，程序将无法编译。

强类型是我将在本指南中概述的思想的基础构件。它允许编译器指出我们在表达中自相矛盾的情况。只有代码的所有部分都协调一致，程序才能编译。

### 单子

Rust 的标准库包含几个单子实例类型，比如`Result`、`Future`和`Option`。然而，与 Haskell 不同的是，Rust 无法抽象所有的单子实例。然而，这些类型仍然是单子，这意味着我们可以单独抽象它们。

例如，设计选择在标准库中包含`Option`单子来建模空状态，这通常允许程序抽象出空状态的概念。换句话说，您可以编写在`Option<T>`上运行的代码，而不必具体说明`T`是什么。对于错误处理上下文中的`Result`和异步计算上下文中的`Future`也是如此。

对这些问题使用单子消除了对空指针和异常等语言特性的需要。正如我们将在后面看到的，没有这两个特性极大地提高了 Rust 程序的健壮性。

### 标记的联合

Rust 的枚举被实现为标记的联合。抛开官方名称不谈，除了类 C 枚举，Rust 的枚举可以存储每个变体的额外数据。

以标准库中的`Result`类型为例:

```
pub enum Result<T, E> {
    Ok(T),
    Err(E),
}

```

信不信由你，这只是一个枚举。没有任何花哨的语言功能。

定义枚举时，可以在元组变量和结构变量之间进行选择。换句话说，您可以选择通过索引(`.0`、`.1`)或名称(`.foo`、`.bar`)来访问变量中的字段。

标记联合非常强大，因为它们允许您轻松地对域的正交方面以及相关数据进行建模。

坚持以`Result`为例，假设一个函数返回`Result::Err(error)`。我们不仅告诉调用者函数失败了，还通过在`Err`变量中返回错误来告诉他们失败的原因。同时，`Ok`和`Err`是正交的。在`Ok`的情况下，错误的变量/槽根本不存在。

### 彻底性检查

标记联合的一个很好的特性是穷举检查。要处理生锈的`enum`,你必须对它进行`match`。每次你匹配一个`enum`，编译器会确保你处理了所有的变量。不处理变量是一个编译时错误，除非您使用`_ => ...`明确选择这种行为。

### `#[must_use]`

类型和函数可以在 Rust 中用`#[must_use]`标注。对于函数，如果调用方没有将返回值赋给变量，编译器会发出警告。对于类型，每次从函数返回类型并且调用方没有使用它时，都会发出警告。

与未使用变量的默认警告一起，这是另一种穷举检查。编译器确保你不会忘记变量和重要的返回值。

例如，`Result`用`#[must_use]`标注。不对类型为`Result`的返回值赋值或匹配将发出警告。这可以防止您忘记潜在的错误情况。

## 走向零集成测试

我们已经讨论了 Rust 的一些语言特性如何帮助我们避免忘记错误并正确处理它们。但是遇到逻辑 bug 怎么办？例如，假设您不小心用了`<`而不是`>`进行比较。

像这样的决策逻辑代码通常只能在运行时检查，因为它通常依赖于用户输入。为了确保这些事情都做对了，编写测试是个好主意。

* * *

### 更多来自 LogRocket 的精彩文章:

* * *

但是我们到底应该如何测试它，Rust 和它的编译器在这里能帮到我们什么呢？

### 集成测试与单元测试

根据我的经验，对于单元测试到底是什么，还没有一个普遍的共识。我个人推荐伊恩·库珀关于 TDD 的演讲。

出于本教程的考虑，我将采用以下定义:

*   集成测试确保多个模块能够正确地协同工作
*   单元测试确保单个模块在隔离状态下正确工作

### 新类型，新类型，新类型

在 Rust 中声明类型很便宜。它们在运行时被有效地删除，因此拥有更多它们不会带来运行时性能开销。

通过新类型来利用这一点是个好主意。按照惯例，newtype 是恰好包装了一个其他类型的类型定义。例如，如果您的系统中有语义不同的 id，将它们建模为不同的类型就像对编译器说，“如果我混淆了其中的任何一个，请警告我！”

```
struct UserId(Uuid);

struct OrderId(Uuid);

```

由于 Rust 具有强类型，在需要一个`OrderId`的地方传递一个`UserId`将会产生一个编译错误。当然，只有当 ID 进入系统时，即从数据库或 HTTP 请求中读取时，正确地解析和验证了 ID，这才是正确的。

### 尽早解析和验证

在这种情况下，早期指的是程序数据流层次结构的早期。你想要避免的是携带允许比你的软件的业务规则实际允许的更多的值的数据类型——例如，一个代表“MasterCard”或“VISA”的`String`,如果这两个是用户可以在你的系统中用于支付的唯一可能的信用卡品牌。

相反，您应该创建一个表示有效范围的枚举，并在早期将字符串解析到该枚举中。

对于其他不变量也是如此，例如数字范围。假设一个给定的数字必须在 1 到 100 之间。我们可以用来嵌入不变量“必须在 1 到 100 之间”的最接近的原始数据类型是`u8`。但是一个`u8`允许值`0`和`101 - 127`。

我们可以创建自己的类型来实现这些不变量。

```
struct Percent(u8);

impl Percent {
    fn new(value: u8) -> anyhow::Result<Self> {
        if value > 100 {
            anyhow::bail!("number is too big!")
        }

        if value == 0 {
            anyhow::bail!("number is zero!")
        }

        Self(value)
    }
}

```

因为`Percent`中的字段是私有的，所以构造`Percent`的唯一方法是通过`new`函数。

因此，在程序内的任何类型签名中使用`Percent`保证了如果我们到达这个阶段，已经根据那些不变量检查了`Percent`内的值。使用数据隐私和封装允许我们在类型系统中嵌入不变量。

### 将决策和执行分开

为了实现我们不写集成测试的目标，我们不得不接受另一个关于我们如何设计软件的约束:一个功能应该或者做决定或者执行决定，但是不能两者都做。

原因是执行决策可能涉及其他模块，而做出决策可能只涉及数据。

例如，一个决定可能是，“这张信用卡应该收取 110 美元。”做出这个决定的模块可以而且应该与执行这个决定的模块完全不同。执行可能会涉及相当枯燥的代码，比如与支付处理器的 API 对话。另一方面，做出那个决定是通常被称为系统的“业务逻辑”，或者“核心逻辑”。

如何才能实现这种拆分？引用大卫·惠勒的话，“计算机科学中的所有问题都可以通过另一种间接方式来解决。”

我们可以通过增加一个间接层来分离决策和执行决策的行为。更具体地说，我们可以简单地对已经发生或应该发生的事情建模，而不是直接对决策采取行动。

还记得 Rust 的枚举，也就是标记的联合吗？它们非常适合对决策结果进行建模。这里的通用术语还包括“事件”或“动作”

```
enum Action {
      ChargeCreditCard {
              credit_card: CardDetails,
              amount: Amount
      },
      ...
}

```

有了这种间接性，我们可以创建一个模块来封装应用程序的决策逻辑。这个模块也非常适合进行单元测试。没有什么比向一个函数抛出一些数据并断言它返回正确的枚举变量更容易的了！假设我们的调用者对收到这样的动作做出适当的反应，系统应该可以正常工作。

### 集成模块

让我们设身处地为正在被返回的调用者着想，就像上面那个一样。我们该拿它怎么办？为了处理 Rust 中的枚举，我们必须对它们进行`match`。

```
match action {
      Action::ChargeCreditCard { credit_card, amount } => {
            payment_processor_client.charge_credit_card(credit_card, amount);
      }
}

```

有趣的是枚举变量和我们调用的函数之间的映射。它们使用相同的术语，数据只是简单地传递。但就“整合”工作而言，也就这样了。

## 把所有的放在一起

如果您一直密切关注，您可能已经看到了这一趋势:

*   将我们的代码分为决策和执行允许您对您的决策代码进行单元测试——在这种情况下，我们发出正确的`Action`变体
*   Rust 的详尽匹配确保您可以处理`Action`的每个变体
*   针对未使用变量的 lint 确保您不会忘记我们正在传递的某些数据
*   Rust 的强类型确保传递给`charge_credit_card`函数的内容是兼容的
*   `#[must_use]`属性确保您不会简单地完全删除`Action`
*   尽早解析和验证数据可以确保您不会处理无效数据。因此，决策模块可以假设数据的某些不变量是真实的
*   使用像`Result`这样的一元类型可以确保您处理过程中的每一个错误。如果异常是主要的错误处理机制，那么您的程序很容易因为没有捕捉到异常而意外中止

单独来看，这几点并不令人兴奋，但当它们组合在一起时，就会产生强大的冲击力。总的来说，在这里编写有问题的集成代码的风险相当低。我甚至可以说风险是如此之低，以至于编写和维护集成测试的努力是不值得的。根据我的经验，对于集成测试来说尤其如此，因为它们往往很长，有大量的设置代码、古怪的模仿，以及经常有问题的断言。

相反，我建议在不会很快改变的抽象层次上进行更多的端到端测试，比如服务的 HTTP API。这种端到端的测试，加上模块级的单元测试，以及对集成类型系统的良好使用，可以形成一个非常容易维护的代码库。

## 结论

在本指南中，我们探索了 Rust 今天的一些特定特性——即它的枚举和强制的穷举匹配。再加上新类型的良好使用和一些零星的间接性，将应用程序的大部分关键逻辑捆绑到一个模块中是相对容易的，这个模块可以独立整齐地进行测试，同时在与其他模块的集成代码中风险很小。

“它编译好了，我们出货吧！”不适用于铁锈。更好的说法是:“它编译时没有警告，我的单元测试也通过了，所以我们来发布它吧！”

## [log rocket](https://lp.logrocket.com/blg/rust-signup):Rust 应用的 web 前端的全面可见性

调试 Rust 应用程序可能很困难，尤其是当用户遇到难以重现的问题时。如果您对监控和跟踪 Rust 应用程序的性能、自动显示错误、跟踪缓慢的网络请求和加载时间感兴趣，

[try LogRocket](https://lp.logrocket.com/blg/rust-signup)

.

[![LogRocket Dashboard Free Trial Banner](img/d6f5a5dd739296c1dd7aab3d5e77eeb9.png)](https://lp.logrocket.com/blg/rust-signup)

LogRocket 就像是网络和移动应用程序的 DVR，记录你的 Rust 应用程序上发生的一切。您可以汇总并报告问题发生时应用程序的状态，而不是猜测问题发生的原因。LogRocket 还可以监控应用的性能，报告客户端 CPU 负载、客户端内存使用等指标。

现代化调试 Rust 应用的方式— [开始免费监控](https://lp.logrocket.com/blg/rust-signup)。
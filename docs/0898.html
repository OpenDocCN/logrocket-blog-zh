<html>
<head>
<title>A guide to the GraphQL Mesh library - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>GraphQL网格库指南- LogRocket博客</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/a-guide-to-the-graphql-mesh-library/#0001-01-01">https://blog.logrocket.com/a-guide-to-the-graphql-mesh-library/#0001-01-01</a></blockquote><div><article class="article-post">
<p>GraphQL是前端开发者和客户的梦想。毕竟，客户不关心数据来自哪里，也不关心您使用的数据库格式。他们关心的是快速、干净、轻松地获得他们需要的数据。如果它不会给服务器带来太重的负载，还会加分。</p>
<p>对于已经习惯了GraphQL的简单易用性的开发人员来说，以graph QL格式使用所有的API是一个目标。多亏了一个新的库GraphQL Mesh，这个梦想现在变成了现实。GraphQL Mesh是一块罗塞塔石碑，允许您的所有API和本地数据库一起很好地运行。</p>
<h2>GraphQL是什么？</h2>
<p>GraphQL Mesh是由 <a href="https://medium.com/the-guild"> <span>行会</span> </a> <span>创建的一个新库，该行会是一个开源团体，致力于授权开发人员利用GraphQL的许多好处。</span></p>
<p>公会还负责流行的GraphQL资源，如GraphQL代码编辑器、GraphQL Inspector和GraphQL-CLI。他们清楚地知道如何让不同的开发人员使用GraphQL，不管他们之前是否熟悉脸书创建的规范。</p>
<p>对于那些一直想尝试GraphQL，但由于缺乏经验或拥有REST等旧格式的遗留产品而犹豫不决的开发人员来说，GraphQL Mesh实现了他们的梦想。GraphQL Mesh旨在充当中间层，从几乎任何地方接收数据，并将其转换为GraphQL格式。</p>
<p>GraphQL Mesh的目标是从大量不同格式的数据中提取数据，并将它们与GraphQL集成，以便可以用GraphQL查询和变化来修改它们。</p>
<p><span>到目前为止，GraphQL Mesh已经本机支持:</span></p>
<ul>
<li><span>图表QL </span></li>
<li><span> gRPC </span></li>
<li><span> JSON </span></li>
<li><span> MongoDB </span></li>
<li><span> OpenAPI/Swagger </span></li>
<li><span> PostgreSQL </span></li>
<li><span>肥皂/WSDL </span></li>
<li><span>阿帕奇节俭</span></li>
</ul>
<p>这使得修改输出模式、跨模式链接类型和合并模式类型变得容易。它还让您能够精确控制如何检索数据，克服后端限制，以及由于模式规范和非类型化API导致的复杂性。</p>
<p>GraphQL Mesh还充当本地数据的代理，并允许您与其他API一起使用公共库。您可以在本地使用这个代理，也可以在其他应用程序中使用execute函数调用服务。</p>
<p>请记住，GraphQL Mesh主要用作您企业的背景层。如果您想向公众提供数据，您很可能需要添加一个额外的抽象层。</p>
<p>GraphQL从收集与之通信的服务的API模式开始。然后，它为这些服务创建一个全类型SDK的运行时环境。然后它将各种API规范翻译成 <a href="https://blog.logrocket.com/speeding-up-changes-to-the-graphql-schema/"> <span> GraphQL模式</span> </a> <span>，在这里可以执行定制的模式转换和扩展。最后，所有这些都被打包成一个SDK，用于从您试图与之通信的服务获取数据。</span></p>
<p>这是通过使用本地模式实现的，本地模式是在安装GraphQL Mesh时从自动生成的目录中创建的。</p>
<p>这个模式允许您使用GraphQL的execute函数在您的应用程序中本地运行查询和变异函数。这使得GraphQL能够充当你的应用程序和你用来驱动它的任何东西之间的中枢神经系统。</p>
<h2>GraphQL网格的优势</h2>
<p>GraphQL允许客户端和最终用户集成各种不同格式的数据。</p>
<p>用户不需要对复杂的API架构有透彻的理解就可以检索到他们需要的数据。这也使得快速原型更快更有效，因为你不必每次想做一个无关紧要的改变时都去API的引擎盖下。</p>
<p><span> GraphQL也比</span> <a href="https://blog.logrocket.com/graphql-vs-rest-what-you-didnt-know/"> <span>其他规范如REST </span> </a> <span>要高效得多。REST在被查询时返回存储在数据库中的所有数据，这可能导致过度提取和不足提取。</span></p>
<p>GraphQL只返回用户查询的确切数据。这不仅节省了资源，还使API更容易使用，因为您花在寻找所需数据上的时间更少了。</p>
<h2>GraphQL网格如何工作</h2>
<p>所有的数据都返回到一个地方。虽然REST对端点的大量使用肯定有它的用处，但也有它的缺点。能够将所有数据路由到一个 <i> <span> </span> </i> <span>端点是GraphQL Mesh的一大优势和理由，足以让graph QL Mesh一试身手。</span></p>
<p>GraphQL Mesh将几乎任何给定格式的API转换成GraphQL格式。它是一个抽象层，几乎可以覆盖任何源，包括本地文件和数据库。</p>
<h2>安装GraphQL网格</h2>
<p>GraphQL Mesh有几个软件包可供选择，您可以根据自己的特定需求进行安装。我们将向您展示如何设置GraphQL Mesh的一个基本实例，这样您就可以开始使用该库并亲自试用。</p>
<p><span>首先，你需要安装<code>Yarn</code>包处理程序，它可以让包在全球范围内可用。为了便于管理，在开发文件夹中为这个项目创建一个新目录。我们称我们的为<code>GraphQL_mesh</code>。</span></p>
<p><span>在项目文件夹的根目录下，使用您选择的文本编辑器创建一个名为<code>.meshrc.yaml</code>的文件。</span></p>
<p>我们使用的是 <a href="https://notepad-plus-plus.org/downloads/"> <span>记事本++ </span> </a> <span>，这是一个开源文本编辑器，可以让你以任何你想要的文件格式保存文件。将以下内容粘贴到文件中，然后保存:</span></p>
<pre>sources:
  - name: Wiki
    handler:
      openapi:
        source: https://api.apis.guru/v2/specs/wikimedia.org/1.0.0/swagger.yaml</pre>
<p>使用终端导航到该目录，并输入以下内容:</p>
<pre>$ npm install yarn --global</pre>
<p><span>要安装基本的GraphQL网格包，请键入以下内容:</span></p>
<pre>$ yarn add graphql @graphql-mesh/runtime @graphql-mesh/cli</pre>
<p>现在你需要安装一个网格处理器，这取决于你将要使用的特定API的需求。为了这个例子，我们将为OpenAPI规范安装网格处理程序:</p>
<pre>$ yarn add graphql @graphql-mesh/openapi</pre>
<p><span>要查看支持的API规范的完整列表，请查阅</span> <a href="https://graphql-mesh.com/docs/handlers/available-handlers"> <span> GraphQL-mesh文档</span> </a> <span>。</span></p>
<p>现在你可以运行GraphQL了。键入以下命令:</p>
<pre>$ yarn graphql-mesh serve</pre>
<p><span>这是GraphQL的一个实例，遵循您提供给</span><a href="http://localhost:4000/"><span>http://localhost:4000/</span></a><span>的模式，因此您可以测试您的代码并确保一切正常运行。</span></p>
<h2>如何使用GraphQL网格</h2>
<p>现在让我们来看一个GraphQL Mesh的例子，让您了解如何将它集成到您的开发工作流程中。它还将帮助您直观地了解GraphQL Mesh如何比其他语言更容易、更直观地整合来自多个API源的数据。</p>
<p>为了说明其中的一些概念，我们将构建一个简单的应用程序，整合来自两个不同API的数据，并将它们合并在一起。我们正在从天气API和地理数据API收集数据。</p>
<p><span>为了便于管理，让我们为我们的项目创建一个新目录。我们把我们的命名为<code>locationweather</code>。使用终端导航到此文件夹。</span></p>
<p>现在我们将开始重新安装我们的库并收集我们需要的权限。一旦你进入你的编程指导，输入:</p>
<pre>npm install yarn --global
yarn add graphql @graphql-mesh/runtime @graphql-mesh/cli
yarn add apollo-server
yarn add @graphql-mesh/openapi</pre>
<p>这将安装将在我们的GraphQL函数内部调用的库，并使它们全局可用。</p>
<p>现在打开一个你喜欢的文本编辑器的实例进行编程。</p>
<p>我们使用的是 <a href="https://notepad-plus-plus.org/downloads/"> <span>记事本++ </span> </a> <span>，因为它可以让你以你喜欢的任何文件格式保存文件。</span></p>
<p><span>让我们从制作GraphQL模式开始，它构成了GraphQL函数的大部分功能。在项目文件夹的根目录下，使用文本编辑器创建一个名为<code>.meshrc.yaml</code>的文件并保存它。然后输入如下:</span></p>
<pre>sources:
  - name: Cities
    handler:
      openapi:
        source: https://api.apis.guru/v2/specs/mashape.com/geodb/1.0.0/swagger.json
        operationHeaders:
          'X-RapidAPI-Key': f93d3b393dmsh13fea7cb6981b2ep1dba0ajsn654ffeb48c26
  - name: Weather
    context:
      apiKey: 971a693de7ff47a89127664547988be5
    handler:
      openapi:
        source: https://api.apis.guru/v2/specs/weatherbit.io/2.0.0/swagger.json
transforms:
  - extend: |
      extend type PopulatedPlaceSummary {
        dailyForecast: [Forecast]
        todayForecast: Forecast
      }
  - cache:
      # Geo data doesn't change frequntly, so we can cache it forever
      - field: Query.*
      # Forecast data might change, so we can cache it for 1 hour only
      - field: PopulatedPlaceSummary.dailyForecast
        invalidate:
          ttl: 3600
      - field: PopulatedPlaceSummary.todayForecast
        invalidate:
          ttl: 3600
require:
  - ts-node/register/transpile-only
additionalResolvers:
  - ./src/mesh/additional-resolvers.ts</pre>
<p>你可以看到这个函数正在调用我们在这个项目中使用的API。它应该让您了解如何将这些原则应用于您可能想要使用的几乎任何API或数据源。</p>
<p><span>接下来，您将创建<code>package.json</code>，它构成了这个简单应用程序的其余部分。创建一个空白文件，并将下面的代码放入主体:</span></p>
<pre>{
  "name": "typescript-location-weather-example",
  "version": "0.0.20",
  "license": "MIT",
  "private": true,
  "scripts": {
    "predev": "yarn mesh:ts",
    "dev": "ts-node-dev src/index.ts",
    "prestart": "yarn mesh:ts",
    "start": "ts-node src/index.ts",
    "premesh:serve": "yarn mesh:ts",
    "mesh:serve": "graphql-mesh serve",
    "mesh:ts": "graphql-mesh typescript --output ./src/mesh/__generated__/types.ts"
  },
  "devDependencies": {
    "@types/node": "13.9.0",
    "ts-node": "8.8.2",
    "ts-node-dev": "1.0.0-pre.44",
    "typescript": "3.8.3"
  },
  "dependencies": {
    "@graphql-mesh/cli": "0.0.20",
    "@graphql-mesh/openapi": "0.0.20",
    "@graphql-mesh/runtime": "0.0.20",
    "@graphql-mesh/transform-cache": "0.0.20",
    "@graphql-mesh/transform-extend": "0.0.20",
    "apollo-server": "2.11.0",
    "graphql": "15.0.0"
  }
}</pre>
<p><span>你可以看到我们将使用的大多数变量都在<code>package.json</code>中定义。这是GraphQL的另一个最大优势——它的硬输入能力。使用GraphQL的JSON字符串，事情更加稳定和固定，因此不太可能出错。</span></p>
<p>我们根目录下最后一个实体文件是<code>tsconfig.ts</code>。创建文件并插入以下几行:</p>
<pre>{
  "compilerOptions": {
    "target": "es2015",
    "module": "commonjs",    
    "moduleResolution": "node", /* Specify module resolution strategy: 'node' (Node.js) or 'classic' (TypeScript pre-1.6). */
    "lib": [
      "esnext"
    ],
    "sourceMap": true /* Generates corresponding '.map' file. */,
  },
  "include": ["src"],
  "exclude": ["node_modules"]
}</pre>
<p>现在，如果有人在你之后使用这个应用程序，只需要多做一点家务就可以了。我们将制作一个自述文件，<code>README.md</code>:</p>
<pre>## Location-Weather Example</pre>
<p>这个例子采用了基于Openapi 3和Swagger的两个API源，以及它们之间的链接。</p>
<p>它允许您查询城市和位置，并包括找到的地方的天气字段。</p>
<p>最后，我们将创建一个负责一些附加路由的文件，名为<code>.gitingore</code>，没有文件扩展名。</p>
<pre>__generated__
src/__generated__</pre>
<p>我们快完成了！我们只想加入一点点额外的格式。为此，首先创建一个名为<code>SRC</code>的子文件夹。然后做一个名为<code>index.ts</code>的文件。</p>
<p>插入以下代码:</p>
<pre>import { ApolloServer } from 'apollo-server';
import { getMesh, findAndParseConfig } from '@graphql-mesh/runtime';
async function main() {
  const meshConfig = await findAndParseConfig();
  const { schema, contextBuilder } = await getMesh(meshConfig);
  const server = new ApolloServer({
    schema,
    context: contextBuilder,
  });
  server.listen().then(({ url }) =&gt; {
    console.log(`🚀 Server ready at ${url}`);
  });
}
main().catch(err =&gt; console.error(err));</pre>
<p><span>你可以看到<code>index.ts</code> </span> <span>导入了我们之前安装的函数，像apollo-server，当然还有GraphQL Mesh，并让其余的函数都可以使用。</span></p>
<p><span>在<code>src</code>目录下再创建一个子文件夹，命名为<code>mesh</code>。在这个文件夹中，你将创建最后一个文件，名为<code>additional-resolvers.ts</code> : </span></p>
<pre>import { Resolvers } from './__generated__/types';
export const resolvers: Resolvers = {
  PopulatedPlaceSummary: {
    dailyForecast: async (placeSummary, _, { Weather }) =&gt; {
      const forecast = await Weather.api.getForecastDailyLatLatLonLon({
        lat: placeSummary.latitude!,
        lon: placeSummary.longitude!,
        key: Weather.config.apiKey,
      });
      return forecast.data!;
    },
    todayForecast: async (placeSummary, _, { Weather }) =&gt; {
      const forecast = await Weather.api.getForecastDailyLatLatLonLon({
        lat: placeSummary.latitude!,
        lon: placeSummary.longitude!,
        key: Weather.config.apiKey,
      });
      return forecast.data![0]!;
    },
  },
};</pre>
<p>这是最后一段代码！现在您可以进入命令行并运行:</p>
<pre>yarn graphql-mesh serve</pre>
<p><span>这将把你的应用程序服务到</span><a href="http://localhost:4000"><span>http://localhost:4000</span></a><span>，运行在GraphQL的一个实例上，在这里你可以执行你的查询和突变。</span></p>
<p><span>如果你想在不弄乱任何代码的情况下试用GraphQL Mesh，整个项目</span> <a href="https://codesandbox.io/s/github/Urigo/graphql-mesh/tree/master/examples/location-weather"> <span>都可以在codesandbox </span> </a> <span>上获得，包括代码，所以你可以亲自看到GraphQL Mesh的运行，并了解如何将这个聪明的翻译器集成到你现有的工作流中。</span></p>
<h2>结论</h2>
<p>GraphQL Mesh是前端开发人员和最终用户的梦想成真。</p>
<p>从客户的角度来看，他们不需要了解太多的API结构来做他们想做的事情。相反，他们只需要知道他们在查询什么，而GraphQL Mesh提供了这些。</p>
<p>从程序员的角度来看，GraphQL Mesh使得代码更加健壮和灵活。您不必担心每次更改数据时都要重新配置API。不再需要路由无止境的端点或不断编码复杂的数据库。</p><div class="code-block code-block-24">
<div class="blog-plug inline-plug graphql-plug"><h2>监控生产中失败和缓慢的GraphQL请求</h2><p>虽然GraphQL有一些调试请求和响应的特性，但确保GraphQL可靠地为您的生产应用程序提供资源是一件比较困难的事情。如果您对确保对后端或第三方服务的网络请求成功感兴趣，</p><a href="https://lp.logrocket.com/blg/graphql-signup" target="_blank">try LogRocket</a><p>.</p><a class="signup" href="https://lp.logrocket.com/blg/graphql-signup" target="_blank" rel="noopener noreferrer"><img src="../Images/432a3823c85b3fb72a206e6236a29f48.png" data-lazy-src="https://files.readme.io/69aa835-Image_2019-11-09_at_1.28.05_PM.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" class=" jetpack-lazy-image" data-original-src="https://files.readme.io/69aa835-Image_2019-11-09_at_1.28.05_PM.png"/><noscript><img data-lazy-fallback="1" src="../Images/432a3823c85b3fb72a206e6236a29f48.png" data-original-src="https://files.readme.io/69aa835-Image_2019-11-09_at_1.28.05_PM.png"/></noscript><img class="alignnone size-full wp-image-46 jetpack-lazy-image" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/><noscript><img data-lazy-fallback="1" class="alignnone size-full wp-image-46" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/></noscript></a><a href="https://lp.logrocket.com/blg/graphql-signup" target="_blank" rel="noopener noreferrer">https://logrocket.com/signup/</a><p>LogRocket 就像是网络和移动应用的DVR，记录下你网站上发生的每一件事。您可以汇总并报告有问题的GraphQL请求，以快速了解根本原因，而不是猜测问题发生的原因。此外，您可以跟踪Apollo客户机状态并检查GraphQL查询的键值对。</p><p>LogRocket检测您的应用程序以记录基线性能计时，如页面加载时间、到达第一个字节的时间、慢速网络请求，还记录Redux、NgRx和Vuex操作/状态。</p><a class="signup" href="https://lp.logrocket.com/blg/graphql-signup" target="_blank" rel="noopener noreferrer">Start monitoring for free</a><p>.</p></div>


</div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
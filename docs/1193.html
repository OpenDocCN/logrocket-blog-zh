<html>
<head>
<title>Does my bundle look big in this? - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>我的包裹穿这个看起来大吗？- LogRocket博客</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/does-my-bundle-look-big-in-this/#0001-01-01">https://blog.logrocket.com/does-my-bundle-look-big-in-this/#0001-01-01</a></blockquote><div><article class="article-post">
<h2>我们想去哪里？</h2>
<p>以下代码与Rollup捆绑在一起。Rollup已经确定了代码需要执行的最少导入，这个过程称为树摇动。</p>
<pre>import React from 'react';
import { useFormikContext, useField } from 'formik';
import isEmpty from 'lodash/isEmpty';
import { DatePicker, Checkbox, CheckboxGroup, Radio, RadioGroup, TransitionComponent, TransitionType } from '@my/component-library';</pre>
<p>树抖动是一种用于消除死代码的技术。Rollup已经确定我只需要来自<a href="https://github.com/formium/formik" target="_blank" rel="noopener noreferrer"> formik </a>的两个组件。</p>
<h2>我的包裹穿这个看起来大吗？</h2>
<p>众所周知，大多数现代的大量使用JavaScript的应用程序向浏览器发送了过多的代码。</p>
<p><img data-attachment-id="26094" data-permalink="https://blog.logrocket.com/does-my-bundle-look-big-in-this/bundle/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/09/bundle.png" data-orig-size="934,730" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="bundle" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/09/bundle-300x234.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/09/bundle.png" decoding="async" class="aligncenter size-full wp-image-26094 jetpack-lazy-image" src="../Images/d833395371c33a503787fd64e95f4de5.png" alt="bundle visualization" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2020/09/bundle.png 934w, https://blog.logrocket.com/wp-content/uploads/2020/09/bundle-300x234.png 300w, https://blog.logrocket.com/wp-content/uploads/2020/09/bundle-768x600.png 768w" data-lazy-sizes="(max-width: 934px) 100vw, 934px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2020/09/bundle.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/09/bundle.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="26094" data-permalink="https://blog.logrocket.com/does-my-bundle-look-big-in-this/bundle/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/09/bundle.png" data-orig-size="934,730" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="bundle" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/09/bundle-300x234.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/09/bundle.png" decoding="async" loading="lazy" class="aligncenter size-full wp-image-26094" src="../Images/d833395371c33a503787fd64e95f4de5.png" alt="bundle visualization" srcset="https://blog.logrocket.com/wp-content/uploads/2020/09/bundle.png 934w, https://blog.logrocket.com/wp-content/uploads/2020/09/bundle-300x234.png 300w, https://blog.logrocket.com/wp-content/uploads/2020/09/bundle-768x600.png 768w" sizes="(max-width: 934px) 100vw, 934px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/09/bundle.png"/></noscript>
<p>在上图中，所有人都能看到<code>react-dom.production.min.js</code>的巨大尺寸。</p>
<p>福米克已经毫无必要地将它的规模扩大了一倍，几乎囊括了所有的<a href="https://lodash.com/" target="_blank" rel="noopener noreferrer">洛达什</a>。对于如此多的JavaScript包来说，Lodash是一个巨大的问题。</p>
<h2>怎么会？</h2>
<p>似乎不太可能的是，<a href="https://github.com/formium/formik" target="_blank" rel="noopener noreferrer"> formik </a>正在使用所有的进口模块，这些模块增加了包的大小。所需要的是一种消除死代码或者只导入被导入者使用的模块的方法。</p>
<p>为了让捆绑器识别死代码，它需要对代码库执行静态分析。</p>
<h2>CommonJS增加了包的大小</h2>
<p>这些天来，我尽可能地使用TypeScript，直到最近，我还将<code>tsconfig.json</code>的<code>module</code>设置为<code>commonjs</code>。</p>
<p>CommonJS模块更难优化，因为它支持动态导入和导出:</p>
<pre>const a = require(localStorage.getItem('somekey'));

const b = 'exportThis';

module.exports[b] = (a) =&gt; a;</pre>
<p>因为<code>require</code>实际上是一个函数调用，我们可以使用一个动态计算的字符串在运行时确定要加载的模块。</p>
<p>静态分析器甚至不会试图解密动态导入和导出，而是获取所有内容。</p>
<h2>ESM (Ecmascript)模块语法</h2>
<p><code>import</code>和<code>export</code>语句都是ESM模块语言的一部分。没有歧义，缺乏动态性便于静态分析。</p>
<p><a href="https://javascript.info/modules-dynamic-imports" target="_blank" rel="noopener noreferrer">动态导入</a>仍然可以在ESM模块中进行代码拆分。</p>
<h2>Rollup是消除死代码的市场领导者</h2>
<p>我使用Webpack已经很长时间了，Webpack的工作原理是将每个模块封装在一个函数中，这个函数实现了一个加载器和一个模块缓存。在运行时，依次对这些模块中的每一个进行评估，以填充模块缓存。Webpack方法使得像热模块替换(HMR)这样的事情成为可能，但是这种方法带来了开销。</p>
<p>Rollup 采用了一种不同的方法——它将所有代码放在同一个级别，这就是所谓的范围提升。最终的包更小，开销也更少，因为没有对每个模块进行评估。</p>
<p>代价是rollup依赖于ESM模块语义。缩小包大小的第一步是将任何CommonJS包变成100%的ESM包。</p>
<h2>Package.json模块解析</h2>
<p>像rollup或Webpack这样的捆绑器通常有一种机制来指定<code>package.json</code>文件中的哪个字段是入口点。</p>
<p>如果消费包有一个导入，如:</p>
<pre>import * as D3 from 'd3';</pre>
<p><code>package.json</code>的以下字段将决定模块的入口点:</p>
<ul>
<li><strong>类型</strong>–文件结尾为。当最近的父package.json文件包含值为<code>module</code>的顶级字段<code>type</code>时，js将作为ES模块加载</li>
<li><strong>模块</strong>–如果该字段表明导入的文件将是一个ESM模块</li>
<li><strong>main</strong>–该字段通常用于解析CommonJS模块</li>
<li><strong>浏览器</strong>–从未被节点使用。通过使用该字段，我们可以为web和Node生成不同的包</li>
</ul>
<p><img data-attachment-id="26103" data-permalink="https://blog.logrocket.com/does-my-bundle-look-big-in-this/version/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/09/version.png" data-orig-size="293,190" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="version" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/09/version.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/09/version.png" decoding="async" class="aligncenter size-full wp-image-26103 jetpack-lazy-image" src="../Images/0f3e3cd8cc74ba5e3e2e14d334f1a397.png" alt="version, module, browser, main fields in packagejson" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2020/09/version.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/09/version.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="26103" data-permalink="https://blog.logrocket.com/does-my-bundle-look-big-in-this/version/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/09/version.png" data-orig-size="293,190" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="version" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/09/version.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/09/version.png" decoding="async" loading="lazy" class="aligncenter size-full wp-image-26103" src="../Images/0f3e3cd8cc74ba5e3e2e14d334f1a397.png" alt="version, module, browser, main fields in packagejson" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/09/version.png"/></noscript>
<p>使用Webpack，可以使用<code>mainFields</code>选项设置优先搜索哪些字段:</p>
<pre>resolve: {
  mainFields: ['module', 'browser', 'main'],</pre>
<p>使用Rollup，您可以使用<a href="https://github.com/rollup/plugins/tree/master/packages/node-resolve" target="_blank" rel="noopener noreferrer">@ roll up/plugin-node-resolve roll up</a>插件:</p>
<pre>resolve({
  mainFields: ['module', 'browser', 'main'],</pre>
<p>我们旅程的第一步应该是将<code>type</code>设置为<code>module</code>,并提供一个<code>module</code>字段:</p>
<pre>{
  "name": "@ds/util",
  "version": "6.3.0",
  "type": "module",
  "module": "dist/index",
  "browser": "dist/index",
  "main": "dist/index",
}</pre>
<p>如果有一个文件扩展名是<code>module</code>、<code>main</code>或<code>browser</code>，并且Webpack在定位<code>web</code>构建时依赖于浏览器字段的存在，那么我在使用Webpack时就会遇到问题。</p>
<h2>用<code>mjs</code>文件抓住你</h2>
<p>ES模块是扩展名为<code>.mjs</code>的文件的目标。Node的更高版本假设一个<code>mjs</code>文件的导入将符合ESM。</p>
<p>在浏览器世界，或者更准确地说，在bundler世界，这更像是一种约定，但是Webpack和Rollup会以不同的方式处理这个文件，并编译到不同的目标。</p>
<p>我遇到了像React和react-router这样的依赖问题，它们是常见的依赖。解决方案是输出一个文件扩展名为<code>.esm.js</code>的文件。</p>
<h2>开机<code>require</code>接触</h2>
<p>我遇到的主要重构是删除导入<code>scss</code>文件的<code>require</code>语句:</p>
<pre>const styles = require('./Start.module.scss');</pre>
<p>变成了:</p>
<pre>import styles from './Start.module.scss';</pre>
<h2>以打字打的文件</h2>
<p>使用TypeScript，我必须指示编译器将文件转换到<code>ESNext</code>。</p>
<p>在<code>tsconfig.json</code>中，<code>module</code>字段从:</p>
<pre>"module": "CommonJS",</pre>
<p>到</p>
<pre>"module": "ESNext",</pre>
<h2>卷曲</h2>
<p>这是我选定的汇总配置:</p>
<pre>const bundle = await rollup({
    input: inputFile,
    external: (id: string) =&gt; {
      return !id.startsWith('.') &amp;&amp; !path.isAbsolute(id);
    },
    treeshake: {
      moduleSideEffects: false,
    },
    plugins: [
      resolve({
        mainFields: ['module', 'browser', 'main'],
        extensions: ['.mjs', '.esm.js', 'cjs', '.js', '.ts', '.tsx', '.json', '.jsx'],
      }),
      json(),
      postcss({
        extract: false,
        modules: true,
        use: ['sass'],
      }),
      typescript({
        clean: true,
        typescript: require('typescript'),
        tsconfig: paths.tsConfig,
        abortOnError: true,
        tsconfigDefaults: {
          compilerOptions: {
            sourceMap: true,
            declaration: true,
            target: 'esnext',
            jsx: 'react',
          },
          useTsconfigDeclarationDir: true,
        },
        tsconfigOverride: {
          compilerOptions: {
            sourceMap: true,
            target: 'esnext',
          },
        },
      }),
      babel({
        exclude: /\/node_modules\/core-js\//,
        babelHelpers: 'runtime',
        ...babelConfig,
      } as RollupBabelInputPluginOptions),
      injectProcessEnv({
        NODE_ENV: 'production',
      }),
      sourceMaps(),
      minify === true &amp;&amp;
        terser({
          compress: {
            keep_infinity: true,
            pure_getters: true,
            passes: 10,
          },
          ecma: 2016,
          toplevel: false,
          format: {
            comments: 'all',
          },
        }),
    ],
  });
}</pre>
<p>使用了以下插件:</p>

<p>使用上述配置调用rollup的<a href="http://rollupjs.org/guide/en/" target="_blank" rel="noopener noreferrer"> rollup函数</a>会返回一个bundle对象，该对象可以使用以下代码将bundle写入磁盘:</p>
<pre>await bundle.write({
  file: path.join(paths.appBuild, 'index.js'),
  format: 'esm',
  name: packageName,
  exports: 'auto',
  sourcemap: true,
  esModule: true,
  interop: 'esModule',
});</pre>
<p>该软件包现在符合ESM标准。</p><div class="code-block code-block-54">
<hr/>
<h3>更多来自LogRocket的精彩文章:</h3>

<hr/></div>
<h2>包扎</h2>
<p>世界正缓慢但坚定地转向ESM模块。有一个更小的包大小的承诺，引诱你到应许之地。</p>
<p>我使用Rollup来捆绑我的包，但在开发中仍然使用Webpack进行热模块替换。</p>
<p>无论捆绑者是谁，远离大众越来越有意义。</p><div class="code-block code-block-28">
<div class="blog-plug inline-plug js-libraries-plug"><h2>您是否添加了新的JS库来提高性能或构建新特性？如果他们反其道而行之呢？</h2><p>毫无疑问，前端变得越来越复杂。当您向应用程序添加新的JavaScript库和其他依赖项时，您将需要更多的可见性，以确保您的用户不会遇到未知的问题。</p>
<p>LogRocket 是一个前端应用程序监控解决方案，可以让您回放JavaScript错误，就像它们发生在您自己的浏览器中一样，这样您就可以更有效地对错误做出反应。</p><a class="signup" href="https://lp.logrocket.com/blg/javascript-signup" target="_blank" rel="noopener noreferrer"><img class="alignnone size-full wp-image-46 jetpack-lazy-image" src="../Images/e8a0ab42befa3b3b1ae08c1439527dc6.png" alt="LogRocket Dashboard Free Trial Banner" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2019/10/errors-screenshot.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/10/errors-screenshot.png"/><noscript><img data-lazy-fallback="1" class="alignnone size-full wp-image-46" src="../Images/e8a0ab42befa3b3b1ae08c1439527dc6.png" alt="LogRocket Dashboard Free Trial Banner" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/10/errors-screenshot.png"/></noscript></a>
<a href="https://lp.logrocket.com/blg/javascript-signup" target="_blank" rel="noopener noreferrer">https://logrocket.com/signup/</a><p><a href="https://lp.logrocket.com/blg/javascript-signup" target="_blank" rel="noopener noreferrer"> LogRocket </a>可以与任何应用程序完美配合，不管是什么框架，并且有插件可以记录来自Redux、Vuex和@ngrx/store的额外上下文。您可以汇总并报告问题发生时应用程序的状态，而不是猜测问题发生的原因。LogRocket还可以监控应用的性能，报告客户端CPU负载、客户端内存使用等指标。</p><p>自信地构建— <a class="signup" href="https://lp.logrocket.com/blg/javascript-signup" target="_blank" rel="noopener noreferrer">开始免费监控</a>。</p></div>


</div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
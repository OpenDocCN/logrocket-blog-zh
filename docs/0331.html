<html>
<head>
<title>Building forms with Formik in React - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>在React - LogRocket博客中用Formik构建表单</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/building-forms-formik-react/#0001-01-01">https://blog.logrocket.com/building-forms-formik-react/#0001-01-01</a></blockquote><div><article class="article-post">
<p><em> <strong>编者按:</strong>本文更新于2022年1月28日，更新了任何过时的信息，并添加了使用Formik的 <code><a href="https://blog.logrocket.com/building-better-react-forms-with-formik/#using-formiks-handlechange">handleChange</a></code>部分的<a href="https://blog.logrocket.com/building-better-react-forms-with-formik/#using-formiks-handlechange">、使用Formik的</a> <code><a href="https://blog.logrocket.com/building-better-react-forms-with-formik/#using-formiks-onsubmit">onSubmit</a></code>部分的<a href="https://blog.logrocket.com/building-better-react-forms-with-formik/#using-formiks-onsubmit">和使用Formik的</a> <code><a href="https://blog.logrocket.com/building-better-react-forms-with-formik/#using-formiks-setsubmitting">setSubmitting</a></code>部分的<a href="https://blog.logrocket.com/building-better-react-forms-with-formik/#using-formiks-setsubmitting">。</a></em></p>
<p>使用React构建表单包括将状态设置为用户数据的容器，将props设置为控制状态如何使用用户输入更新的手段。可以在用户输入之间进行验证，并在表单提交时执行任意提交功能。</p>
<p>在本文中，我们将回顾如何在React中使用Formik来构建表单，包括:</p>

<h2 id="why-should-use-formik-react">React中为什么要用Formik？</h2>
<p>在我们学习如何使用Formik之前，让我们了解一下如何在没有库的情况下用最少的引导样式在React中编写表单。</p>
<p>在下面的例子中，我们首先在<code>constructor</code>方法中初始化所需的状态值。因为我们有两个必需的输入— <code>email</code>和<code>password</code> —我们为输入值、输入有效性和输入错误初始化状态:</p>
<pre class="language-javascript hljs">constructor(props) {
  super(props);
  this.state = {
    formValues: {
      email: "",
      password: ""
    },
    formErrors: {
      email: "",
      password: ""
    },
    formValidity: {
      email: false,
      password: false
    },
    isSubmitting: false
  };
}
</pre>
<p>接下来，我们使用从state派生的输入值创建呈现表单的方法:</p>
<pre class="language-javascript hljs">render() {
  const { formValues, formErrors, isSubmitting } = this.state;
  return (
    &lt;div className="container"&gt;
      &lt;div className="row mb-5"&gt;
        &lt;div className="col-lg-12 text-center"&gt;
          &lt;h1 className="mt-5"&gt;Login Form&lt;/h1&gt;
        &lt;/div&gt;
      &lt;/div&gt;
      &lt;div className="row"&gt;
        &lt;div className="col-lg-12"&gt;
          &lt;form onSubmit={this.handleSubmit}&gt;
            &lt;div className="form-group"&gt;
              &lt;label&gt;Email address&lt;/label&gt;
              &lt;input
                type="email"
                name="email"
                className={`form-control ${
                  formErrors.email ? "is-invalid" : ""
                }`}
                placeholder="Enter email"
                onChange={this.handleChange}
                value={formValues.email}
              /&gt;
              &lt;div className="invalid-feedback"&gt;{formErrors.email}&lt;/div&gt;
            &lt;/div&gt;
            &lt;div className="form-group"&gt;
              &lt;label&gt;Password&lt;/label&gt;
              &lt;input
                type="password"
                name="password"
                className={`form-control ${
                  formErrors.password ? "is-invalid" : ""
                }`}
                placeholder="Password"
                onChange={this.handleChange}
                value={formValues.password}
              /&gt;
              &lt;div className="invalid-feedback"&gt;{formErrors.password}&lt;/div&gt;
            &lt;/div&gt;
            &lt;button
              type="submit"
              className="btn btn-primary btn-block"
              disabled={isSubmitting}
            &gt;
              {isSubmitting ? "Please wait..." : "Submit"}
            &lt;/button&gt;
          &lt;/form&gt;
        &lt;/div&gt;
      &lt;/div&gt;
    &lt;/div&gt;
  );
}
</pre>
<p>现在我们必须编写<code>handleChange</code>方法来更新用户输入的状态:</p>
<pre class="language-javascript hljs">handleChange = ({ target }) =&gt; {
  const { formValues } = this.state;
  formValues[target.name] = target.value;
  this.setState({ formValues });
  this.handleValidation(target);
};
</pre>
<p>每当状态值被更新时，我们将针对用户输入运行一个验证方法。这是我们的<code>handleValidation</code>方法:</p>
<pre class="language-javascript hljs">handleValidation = target =&gt; {
  const { name, value } = target;
  const fieldValidationErrors = this.state.formErrors;
  const validity = this.state.formValidity;
  const isEmail = name === "email";
  const isPassword = name === "password";
  const emailTest = /^[^\<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="4e3d0e">[email protected]</a>]<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="507b10">[email protected]</a>[^\<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="5e2d1e">[email protected]</a>]+\.[^\<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="0a794a">[email protected]</a>]{2,}$/i;
  validity[name] = value.length &gt; 0;
  fieldValidationErrors[name] = validity[name]
    ? ""
    : `${name} is required and cannot be empty`;
  if (validity[name]) {
    if (isEmail) {
      validity[name] = emailTest.test(value);
      fieldValidationErrors[name] = validity[name]
        ? ""
        : `${name} should be a valid email address`;
    }
    if (isPassword) {
      validity[name] = value.length &gt;= 3;
      fieldValidationErrors[name] = validity[name]
        ? ""
        : `${name} should be 3 characters minimum`;
    }
  }
  this.setState({
    formErrors: fieldValidationErrors,
    formValidity: validity
  });
};
</pre>
<p>这个基本表单的最后一部分是提交过程的<code>handleSubmit</code>方法。我们需要检查<code>formValidity</code>值，并且，如果有任何<code>false</code>值，再次运行验证方法而不提交表单:</p>
<pre class="language-javascript hljs">handleSubmit = event =&gt; {
  event.preventDefault();
  this.setState({ isSubmitting: true });
  const { formValues, formValidity } = this.state;
  if (Object.values(formValidity).every(Boolean)) {
    alert("Form is validated! Submitting the form...");
    this.setState({ isSubmitting: false });
  } else {
    for (let key in formValues) {
      let target = {
        name: key,
        value: formValues[key]
      };
      this.handleValidation(target);
    }
    this.setState({ isSubmitting: false });
  }
};
</pre>
<p>现在表单已经可以使用了。React只为您的应用程序提供“视图”层，这意味着它只提供制作表单组件的基本必需品。<code>component</code>、<code>state</code>和<code>props</code>就像拼图块，你必须把它们拼在一起才能构建一个工作表单。</p>
<p>正如您所看到的，对于只有两个文本框的表单来说，这是相当多的代码。想象一下，在一个有10个或更多输入的表单中，您需要记录多少状态值。呀！</p>
<p>是的，用React创建表单一点也不好玩；很啰嗦，很死板。构建表单和创建验证方法是很无聊的任务。在每个表单中，您至少需要执行以下操作:</p>
<ol>
<li>设置表单值、表单错误和表单有效性的状态</li>
<li>处理用户输入和更新状态</li>
<li>创建验证函数</li>
<li>处理提交</li>
</ol>
<p>以自然反应的方式构建表单要求您编写从设置状态到表单提交过程的每个部分。我做了无数的React表单，我总是发现构建表单的这一部分非常无聊和耗时。幸运的是，我不是唯一有这种感觉的人。</p>
<h2 id="what-is-formik">什么是福米克？</h2>
<p>输入<a href="https://formik.org/"> Formik </a>。贾里德·帕尔默出于在构建React表单时的挫败感，编写了Formik库。他需要一种方法来标准化输入组件和表单提交流程。Formik帮助您编写构建表单的三个最烦人的部分:</p>
<ol>
<li>获取表单状态内外的值</li>
<li>验证和错误消息</li>
<li>处理表单提交</li>
</ol>
<p>这又是一个相同的表单，但是这次使用的是Formik。这个新表单只使用了Formik库中的四个额外组件:<code>&lt;Formik /&gt;</code>、<code>&lt;Form /&gt;</code>、<code>&lt;Field /&gt;</code>和<code>&lt;ErrorMessage /&gt;</code>。</p>
<p>要释放Formik的能力，您可以将表单包装在<code>&lt;Formik /&gt;</code>组件中:</p>
<pre class="language-javascript hljs">&lt;Formik&gt;
  &lt;Form&gt;
    {/* the rest of the code here */}
  &lt;/Form&gt;
&lt;/Formik&gt;
</pre>
<p>让我们看看与React的自然方式相比，Formik如何使构建表单更容易。</p>
<h3 id="getting-values-in-out-form-state-formik">在Formik中获取表单状态内外的值</h3>
<p>Formik将通过它的<code>initialValues</code> prop在内部设置状态来存储用户输入，因此您不再需要从构造函数初始化状态。</p>
<p>要获取Formik内部状态的值，可以使用<code>&lt;Field /&gt;</code>组件替换常规的HTML <code>&lt;input /&gt;</code>组件。该组件将保持Formik状态和输入值同步，因此您不需要将<code>value</code>和<code>onChange</code>道具传递到<code>&lt;Field /&gt;</code>组件中:</p>
<pre class="language-javascript hljs">&lt;Formik
  initialValues={{ email: "", password: "" }}
  onSubmit={({ setSubmitting }) =&gt; {
    alert("Form is validated! Submitting the form...");
    setSubmitting(false);
  }}
&gt;
  {() =&gt; (
    &lt;Form&gt;
      &lt;div className="form-group"&gt;
        &lt;label htmlFor="email"&gt;Email&lt;/label&gt;
        &lt;Field
          type="email"
          name="email"
          className="form-control"
        /&gt;
      &lt;/div&gt;
      &lt;div className="form-group"&gt;
        &lt;label htmlFor="password"&gt;Password&lt;/label&gt;
        &lt;Field
          type="password"
          name="password"
          className="form-control"
        /&gt;
      &lt;/div&gt;
    &lt;/Form&gt;
  )}
&lt;/Formik&gt;
</pre>
<h4 id="using-formiks-handlechange">使用Formik的<code>handleChange</code></h4>
<p>有了Formik，就不再需要在<code>constructor</code>中初始化状态并创建自己的<code>handleChange</code>方法了。一切都搞定了。</p>
<p>Formik有自己的<code>handleChange</code>方法，可以用它来更新用户输入的状态，不需要实现自己的<code>handleChange</code>方法。</p>
<p><code>handleChange</code>方法根据输入的<code>name</code>属性更新表单值。</p>
<p><code>handleChange</code>方法与<code>input</code>元素一起使用。<code>Field</code>组件在内部更新值，而不需要实现<code>handleChange</code>方法。</p>
<p>让我们用一个例子来说明:</p>
<pre class="language-javascript hljs">const SignupForm = () =&gt; {
  const formik = useFormik({
    initialValues: {
      email: "",
    },
    onSubmit: (values) =&gt; {
      alert(JSON.stringify(values, null, 2));
    },
  });
  return (
    &lt;form onSubmit={formik.handleSubmit}&gt;
      &lt;label htmlFor="email"&gt;Email Address&lt;/label&gt;
      &lt;input
        id="email"
        name="email"
        type="email"
        onChange={formik.handleChange}
        value={formik.values.email}
      /&gt;

      &lt;button type="submit"&gt;Submit&lt;/button&gt;
    &lt;/form&gt;
  );
};
</pre>
<p>这里，我们有一个<code>input</code>，其中<code>name</code>被设置为<code>email</code>。请注意，我们为它设置了一个<code>onChange</code>事件处理程序。<code>onChange</code>事件处理程序调用<code>formik</code>对象的<code>handleChange</code>方法。</p>
<p>这将用新值更新<code>formik</code>对象的<code>values</code>对象，以便我们可以从<code>onSubmit</code>道具中的<code>values</code>对象中检索它。</p>
<h3 id="validation-error-messages-formik">Formik中的验证和错误消息</h3>
<p>在构建表单时，验证是非常重要的。如果表单处理不当，会导致很多错误。</p>
<p>表单必须告诉用户哪些字段是必填的，某些字段中允许的值类型。这也有助于让用户清楚地知道他们的输入有什么问题。</p>
<p>Formik提供了一种处理验证和显示错误消息的方法。在下面的章节中，我们将学习如何在Formik中显示验证信息，以及如何在Formik中显示错误信息。</p>
<h4 id="How-show-validation-messages-formik">如何在Formik中显示验证消息？</h4>
<p>Formik中的验证会在特定事件期间自动执行。所有常见的事件，比如用户输入之后、焦点改变时和提交时，都包括在内，您不需要担心它们。你所需要做的就是将一个函数传递给Formik的<code>validate</code> prop。</p><div class="code-block code-block-54">
<hr/>
<h3>更多来自LogRocket的精彩文章:</h3>

<hr/></div>
<p>比较Formik验证和vanilla React验证之间的代码:</p>
<pre class="language-javascript hljs">// Formik validation code. Take values from Formik
validate={values =&gt; {
  let errors = {};
  if (values.email === "") {
    errors.email = "Email is required";
  } else if (!emailTest.test(values.email)) {
    errors.email = "Invalid email address format";
  }
  if (values.password === "") {
    errors.password = "Password is required";
  } else if (values.password.length &lt; 3) {
    errors.password = "Password must be 3 characters at minimum";
  }
  return errors;
}}

// Vanilla React validation code. Take values given by handleChange
handleValidation = target =&gt; {
  const { name, value } = target;
  const fieldValidationErrors = this.state.formErrors;
  const validity = this.state.formValidity;
  const isEmail = name === "email";
  const isPassword = name === "password";
  const emailTest = /^[^\<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="4c3f0c">[email protected]</a>]<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="89a2c9">[email protected]</a>[^\<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="82f1c2">[email protected]</a>]+\.[^\<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="700330">[email protected]</a>]{2,}$/i;
  validity[name] = value.length &gt; 0;
  fieldValidationErrors[name] = validity[name]
    ? ""
    : `${name} is required and cannot be empty`;
  if (validity[name]) {
    if (isEmail) {
      validity[name] = emailTest.test(value);
      fieldValidationErrors[name] = validity[name]
        ? ""
        : `${name} should be a valid email address`;
    }
    if (isPassword) {
      validity[name] = value.length &gt;= 3;
      fieldValidationErrors[name] = validity[name]
        ? ""
        : `${name} should be 3 characters minimum`;
    }
  }
  this.setState({
    formErrors: fieldValidationErrors,
    formValidity: validity
  });
};
</pre>
<h4 id="how-show-error-messages-formik">如何在Formik中显示错误信息？</h4>
<p>验证就绪后，现在需要输出错误消息。Formik的<code>&lt;ErrorMessage /&gt;</code>组件将自动显示给定名称的<code>&lt;Field /&gt;</code>组件的错误消息。</p>
<p>你可以通过<code>component</code>道具调整显示什么HTML标签。因为这个示例表单使用Bootstrap的样式，所以您还必须添加一个<code>className</code>道具:</p>
<pre class="language-javascript hljs">// Formik error message output
&lt;Field
  type="email"
  name="email"
  className={`form-control ${
    touched.email &amp;&amp; errors.email ? "is-invalid" : ""
  }`}
/&gt;
&lt;ErrorMessage
  component="div"
  name="email"
  className="invalid-feedback"
/&gt;

// Vanilla React error message output
&lt;input
  type="email"
  name="email"
  className={`form-control ${
    formErrors.email ? "is-invalid" : ""
  }`}
  placeholder="Enter email"
  onChange={this.handleChange}
  value={formValues.email}
/&gt;
&lt;div className="invalid-feedback"&gt;{formErrors.email}&lt;/div&gt;
</pre>
<p>错误消息的代码实际上是一样的，但是Formik验证中的代码比vanilla React中的少得多。好样的，福米克！</p>
<h4 id="how-validate-using-yup">我如何使用Yup进行验证？</h4>
<p>虽然您已经感受到了在验证过程中使用Formik的好处，但是您可以通过使用对象模式验证器使它变得更加简单。</p>
<p>对象模式验证器是一个简单的库，它允许您定义JavaScript对象的蓝图，并通过验证过程确保对象值与蓝图相匹配。</p>
<p>这在验证表单数据时特别有用，因为它实际上是保存在Formik的<code>values</code> prop中的一个对象。</p>
<p>现在有一个这样的库是Yup，Formik的作者非常喜欢Yup，以至于他包括了一个特殊的道具来连接Yup和Formik，名为<code><a href="https://jaredpalmer.com/formik/docs/api/formik#validationschema-schema-schema">validationSchema</a></code>。</p>
<p>这个道具自动将Yup的验证错误转换成一个漂亮的对象，它的键匹配<code><a href="https://jaredpalmer.com/formik/docs/api/formik#values-field-string-any">values</a></code>和<code><a href="https://jaredpalmer.com/formik/docs/api/formik#values-field-string-any">touched</a></code>。</p>
<p>这里是一个Formik使用Yup 作为验证模式的例子。注意validate prop是如何从<code>&lt;Formik /&gt;</code>组件中移除的。</p>
<p>有了Yup的对象模式验证器，您不必再手动编写<code>if</code>条件。你可以通过<a href="https://github.com/jquense/yup">访问它的GitHub repo </a>来了解更多关于Yup和它能做什么样的验证。</p>
<h3 id="form-submission-process-formik">Formik中的表单提交流程</h3>
<p>Formik的<code>&lt;Form /&gt;</code>组件将自动运行您的验证方法，如果有任何错误，将取消提交过程。</p>
<p>虽然您必须将<code>onSubmit</code>属性包含到常规的<code>&lt;form /&gt;</code>元素中，但是Formik的<code>&lt;Form /&gt;</code>包装器将运行您传递到<code>&lt;Formik /&gt;</code>组件中的<code>onSubmit</code>属性函数:</p>
<pre class="language-javascript hljs">// Formik's submit code. Won't be executed if there are any errors.
onSubmit={({ setSubmitting }) =&gt; {
  alert("Form is validated!");
  setSubmitting(false);
}}

// Vanilla React submit code. Check on validity state then run validation manually.
handleSubmit = event =&gt; {
  event.preventDefault();
  this.setState({ isSubmitting: true });
  const { formValues, formValidity } = this.state;
  if (Object.values(formValidity).every(Boolean)) {
    alert("Form is validated!");
    this.setState({ isSubmitting: false });
  } else {
    for (let key in formValues) {
      let target = {
        name: key,
        value: formValues[key]
      };
      this.handleValidation(target);
    }
    this.setState({ isSubmitting: false });
  }
};
</pre>
<p>Formik至少只需要提交四行代码，并且不需要跟踪表单输入的有效性。这真是太棒了！</p>
<h4 id="using-formiks-onsubmit">使用Formik的<code>onSubmit</code></h4>
<p>Formik的<code>onSubmit</code>道具是一个接受<code>values</code>道具并返回承诺的函数。在提交之前，你可以用这个对<code>values</code>道具做些什么:</p>
<pre class="language-javascript hljs">    // Formik's submit code.
    onSubmit={(values, { setSubmitting }) =&gt; {
      alert("Form is validated!");
      setSubmitting(false);
    }}
</pre>
<p>这个函数属性与普通JavaScript中的<code>onsubmit</code>非常相似。<code>onSubmit</code>函数作为第一个参数和一个对象传递给表单的值，第二个参数是<code>FormikBag</code>的实例:</p>
<pre class="language-javascript hljs">onSubmit: (values: Values, formikBag: FormikBag) =&gt; void | Promise&lt;any&gt;
</pre>
<p><code>values</code>包含表格中所有输入的值。<code>formikBag</code>包含名称以<code>set</code>和<code>reset</code>开头的功能，例如<code>setSubmitting</code>和<code>resetForm</code>。</p>
<p>属性很有用，因为我们可以很容易地从传递给它的参数中操纵表单及其值。因此，它为我们使用HTML和表单JavaScript APIs提供了巨大的优势，因为它使表单操作变得简单。</p>
<p>让我们看看如何将<code>onSubmit</code>函数与<code>Formik</code>组件一起使用:</p>
<pre class="language-javascript hljs">// js
&lt;Formik
  initialValues={{ name: "jared" }}
  onSubmit={(values, actions) =&gt; {
    setTimeout(() =&gt; {
      alert(JSON.stringify(values, null, 2));
      actions.setSubmitting(false);
    }, 1000);
  }}
&gt;
  {(props) =&gt; (
    &lt;form onSubmit={props.handleSubmit}&gt;
      &lt;input
        type="text"
        onChange={props.handleChange}
        onBlur={props.handleBlur}
        value={props.values.name}
        name="name"
      /&gt;
      {props.errors.name &amp;&amp; &lt;div id="feedback"&gt;{props.errors.name}&lt;/div&gt;}
      &lt;button type="submit"&gt;Submit&lt;/button&gt;
    &lt;/form&gt;
  )}
&lt;/Formik&gt;
</pre>
<p>这里，我们使用<code>initialValues</code>属性设置初始值。然后，在提交过程之前，我们使用<code>onSubmit</code>函数对<code>values</code>道具做一些事情。</p>
<p>我们有一个<code>form</code>元素，它在提交时调用<code>handleSubmit</code>函数。当点击<code>button type="submit"</code>时，这个提交事件被触发。然后，调用<code>Formik</code>组件中的<code>onSubmit</code>函数。</p>
<p>需要注意的一点是，提交表单时不会调用<code>onSubmit</code>函数。这是因为Formik的<code>&lt;Form /&gt;</code>包装器会自动运行您的验证方法，如果有任何错误，就会取消提交过程。</p>
<h4 id="using-formiks-issubmitting">使用Formik的<code>isSubmitting</code></h4>
<p>这个<code>isSubmitting</code>是Formik在表单提交过程中设置的布尔属性。您可以使用它来显示加载微调器或禁用“提交”按钮:</p>
<pre class="language-javascript hljs">isSubmitting: boolean;
</pre>
<p>我们可以使用这个属性来检测表单提交的状态或进度。让我们看一个如何使用这个<code>isSubmitting</code>属性的例子:</p>
<pre class="language-javascript hljs">const Example = () =&gt; (
  &lt;div&gt;
    &lt;h1&gt;Sign Up&lt;/h1&gt;
    &lt;Formik
      initialValues={{
        email: "",
      }}
      onSubmit={async (values) =&gt; {
        await sleep(500);
      }}
    &gt;
      {({ isSubmitting }) =&gt; (
        &lt;Form&gt;
          {isSubmitting &amp;&amp; &lt;div&gt;Loading...&lt;/div&gt;}

          &lt;label htmlFor="email"&gt;Email&lt;/label&gt;
          &lt;Field name="email" placeholder="<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="096368676c49686a646c276a6664">[email protected]</a>" type="email" /&gt;

          &lt;button type="submit" disabled={isSubmitting}&gt;
            Submit
          &lt;/button&gt;
        &lt;/Form&gt;
      )}
    &lt;/Formik&gt;
  &lt;/div&gt;
);
</pre>
<p>我们看到我们从<code>Formik</code>组件的渲染道具中析构了<code>isSubmitting</code>属性。我们使用<code>isSubmitting</code>属性禁用提交按钮，并向用户显示一个<code>Loading…</code>指示器。</p>
<p>利用这个<code>isSubmitting</code>属性很棒，因为它允许我们为用户开发一个漂亮的UI/UX，并告诉他们后台进程何时在后台运行。</p>
<h4 id="using-formiks-setsubmitting">使用Formik的<code>setSubmitting</code></h4>
<p><code>setSubmitting</code>函数设置Formik渲染道具的<code>isSubmitting</code>属性:</p>
<pre class="language-javascript hljs">setSubmitting: (isSubmitting: boolean) =&gt;
  void;

&lt;Formik
  initialValues={{
    email: "",
  }}
  onSubmit={async (values, { setSubmitting }) =&gt; {
    // ...
  }}
&gt;&lt;/Formik&gt;
</pre>
<p>当这个<code>setSubmitting</code>函数被布尔函数<code>true</code>调用时，那么<code>isSubmitting</code>被设置为<code>true</code>。如果用布尔函数<code>false</code>调用<code>setSubmitting</code>函数，那么<code>isSubmitting</code>被设置为<code>false</code>。</p>
<p>所以，我们可以看到<code>setSubmitting</code>函数设置了Formik的渲染道具的<code>isSubmitting</code>属性。</p>
<p>让我们看一个例子:</p>
<pre class="language-javascript hljs">const Example = () =&gt; {
  return (
    &lt;div&gt;
      &lt;h1&gt;Sign Up&lt;/h1&gt;
      &lt;Formik
        initialValues={{
          email: "",
        }}
        onSubmit={async (values, { setSubmitting }) =&gt; {
          setSubmitting(true);
          await sleep(500);
          setSubmitting(false);
        }}
      &gt;
        {({ isSubmitting }) =&gt; (
          &lt;Form&gt;
            {isSubmitting &amp;&amp; &lt;div&gt;Loading...&lt;/div&gt;}

            &lt;label htmlFor="email"&gt;Email&lt;/label&gt;
            &lt;Field name="email" placeholder="<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="244e454a4164454749410a474b49">[email protected]</a>" type="email" /&gt;

            &lt;button type="submit" disabled={isSubmitting}&gt;
              Submit
            &lt;/button&gt;
          &lt;/Form&gt;
        )}
      &lt;/Formik&gt;
    &lt;/div&gt;
  );
};
</pre>
<p>这里，当提交表单时，我们用布尔函数<code>true</code>调用<code>setSubmitting</code>函数。这将<code>isSubmitting</code>设置为<code>true</code>，而<code>button</code>将为<code>disabled</code>，我们会看到一个<code>Loading...</code>指示器。</p>
<p>然后，线程休眠5秒，用布尔值<code>false</code>调用<code>setSubmitting</code>，将<code>isSubmitting</code>设置为<code>false</code>，按钮被禁用。<code>Loading...</code>指标终于消失了。</p>
<h2 id="problem-with-redux">还原形式的问题</h2>
<p>当然，<a href="https://github.com/erikras/redux-form"> redux-form </a>很好用，但是你首先需要使用redux。如果你用的是<a href="https://www.google.com/url?q=https://mobx.js.org/README.html&amp;sa=D&amp;source=editors&amp;ust=1618946177801000&amp;usg=AOvVaw0LeSOQvnr91y2z7ZXWSY8v"> MobX </a>呢？如果将来出现一个新的、更好的库，而您想用它取代Redux，该怎么办？</p>
<p>除此之外，您的React表单实际上以某种方式影响了整个应用程序的流程吗？</p>
<p>考虑一下:用户名文本框的值对您的应用程序全局有影响吗？如果不是，那么真的没有必要使用Redux来跟踪它的值。甚至先知丹·阿布拉莫夫也说了同样的话。</p>
<p>redux-form的另一个问题是将表单输入值存储到Redux store中。这意味着您的应用程序将在每次击键时调用Redux的reducer来更新一个文本框的值。这不是个好主意。</p>
<p>我喜欢用Formik的方式编写表单，但是如果你喜欢redux-form，那也可以。</p>
<h2 id="conclusion">结论</h2>
<p>构建表单是React不擅长的事情之一。幸运的是，React有一个开发人员社区，他们互相帮助，使编写代码的过程更加容易。</p>
<p>如果您要在React应用程序中编写许多表单，Formik无疑是必不可少的开源库之一。</p>
<p>它通过像<code>&lt;Field /&gt;</code>和<code>&lt;Form /&gt;</code>这样的组件抽象出表单的一部分，从而真正加速了您的开发过程并减少了样板代码。</p>
<p>虽然普通的React表单要求您指定自己的状态值和方法，但是您可以简单地将props传递给<code>&lt;Formik /&gt;</code>组件来做同样的事情:处理用户输入、验证输入和表单提交。</p>
<p>如果您想了解更多关于Formik的信息，请前往文档或观看其创建者的演示。感谢阅读！</p><div class="code-block code-block-17">
<div class="blog-plug inline-plug react-plug" vwo-el-id="26283398190">
<h2 vwo-el-id="41600691720">使用LogRocket消除传统反应错误报告的噪音</h2>
<a href="https://lp.logrocket.com/blg/react-signup-issue-free" target="_blank" vwo-el-id="19356441070">LogRocket
</a><p>是一款React analytics解决方案，可保护您免受数百个误报错误警报的影响，只针对少数真正重要的项目。LogRocket告诉您React应用程序中实际影响用户的最具影响力的bug和UX问题。</p><a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="19356441380">
<img class="first-react-image alignnone size-full wp-image-46 jetpack-lazy-image jetpack-lazy-image--handled" src="../Images/f300c244a1a1cf916df8b4cb02bec6c6.png" vwo-el-id="18272717540" data-lazy-loaded="1" data-original-src="https://files.readme.io/27c94e7-Image_2017-06-05_at_9.46.04_PM.png"/>
</a>
<a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="19356441690">
<img class="second-react-image alignnone size-full wp-image-46 jetpack-lazy-image jetpack-lazy-image--handled" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" vwo-el-id="30720362350" data-lazy-loaded="1" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/>
</a>
<a href="https://lp.logrocket.com/blg/react-signup-issue-free" target="_blank" rel="noopener noreferrer" vwo-el-id="35866400580">LogRocket
</a><p>自动聚合客户端错误、反应错误边界、还原状态、缓慢的组件加载时间、JS异常、前端性能指标和用户交互。然后，LogRocket使用机器学习来通知您影响大多数用户的最具影响力的问题，并提供您修复它所需的上下文。</p><p vwo-el-id="28675661060">关注重要的React bug—<a class="signup" href="https://lp.logrocket.com/blg/react-signup-issue-free" target="_blank" rel="noopener noreferrer" vwo-el-id="40093418840">今天就试试LogRocket】。</a></p>
</div></div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
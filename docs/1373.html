<html>
<head>
<title>A guide to classic static blocks in JavaScript - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>JavaScript - LogRocket博客中的经典静态块指南</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/a-guide-to-classic-static-blocks-in-javascript/#0001-01-01">https://blog.logrocket.com/a-guide-to-classic-static-blocks-in-javascript/#0001-01-01</a></blockquote><div><article class="article-post">
<h2>介绍</h2>
<p>JavaScript中的<code>Class static blocks</code>允许您在评估类定义的过程中执行额外的静态初始化。然而，类静态块目前仍然包含在<a href="https://tc39.es/process-document/" target="_blank" rel="noopener noreferrer">第二阶段提案</a>中，这并不是为了替代<code><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes/Public_class_fields" target="_blank" rel="noopener noreferrer">static fields</a></code>，而是为了提供使用<code>static fields</code>无法完成的新用例。因此，<code>class static blocks</code>让面向对象编程(OOP) JavaScript变得有趣和强大得多。</p>
<p>Java和C#等使用<code>classical inheritance</code>的编程语言已经有了这样的实现。在Java中，它们是<code><a href="https://docs.oracle.com/javase/specs/jls/se10/html/jls-8.html#jls-8.7" target="_blank" rel="noopener noreferrer">static initializers</a></code>，而在C#中，它们是<code><a href="https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/static-constructors" target="_blank" rel="noopener noreferrer">static constructors</a></code>。</p>
<p>与这些语言不同，JavaScript中的OOP使用<code>prototypal inheritance</code>。通常，这样的特征不应该出现。然而，随着<a href="http://es6-features.org/#Constants" target="_blank" rel="noopener noreferrer">Ecmascript 2015</a><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes" target="_blank" rel="noopener noreferrer">【es6】</a>中<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes" target="_blank" rel="noopener noreferrer">类</a>的出现，已经出现了类似于<code>classical inheritance</code>中所见的特性的实现。有些，如<code><a href="https://developer.mozilla.org/en-US/docs/Glossary/Static_method" target="_blank" rel="noopener noreferrer">static methods</a></code>、<code><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes/extends" target="_blank" rel="noopener noreferrer">extends</a></code>，已经实施。而现在，甚至有更多的实验特性，如<code><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes/Public_class_fields#:~:text=The%20static%20keyword%20defines%20a,to%20create%20or%20clone%20objects." target="_blank" rel="noopener noreferrer">static fields</a></code>、<code><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes/Private_class_fields" target="_blank" rel="noopener noreferrer">private fields</a></code>和<code>class static blocks</code>。</p>
<p>尽管OOP JavaScript有了这些巨大的进步，但重要的是要注意，在幕后，JavaScript仍然使用原型继承。因此，许多这些仅仅是<code><a href="https://en.wikipedia.org/wiki/Syntactic_sugar#:~:text=In%20computer%20science%2C%20syntactic%20sugar,style%20that%20some%20may%20prefer." target="_blank" rel="noopener noreferrer">syntatic sugar</a></code>。</p>
<blockquote><p>语法糖指的是一种新的、视觉上吸引人的语法(通常是一种快捷方式)来执行旧的操作。–<a href="https://en.wikipedia.org/wiki/Syntactic_sugar#:~:text=In%20computer%20science%2C%20syntactic%20sugar,style%20that%20some%20may%20prefer." target="_blank" rel="noopener noreferrer">维基百科</a></p></blockquote>
<p>让我们在下一节考虑JavaScript中<code>class static blocks</code>的语法和语义。</p>
<h2><code>class static blocks</code>的语法和语义</h2>
<h4>句法</h4>
<p>下面是建议的语法:</p>
<pre>class NewClass {
  static {
     // do something 
  }
}
</pre>
<h4>语义学</h4>
<p>无退货声明:</p>
<pre>class NewClass {
  static {
    return // syntax error
  }
}</pre>
<p>一个类定义应该只有一个<code>static block {}</code>。</p>
<pre>class NewClass {
  static {}
  static {} // throws and error.
}</pre>
<p>一个<code>static block {}</code>创建一个新的<a href="https://tc39.es/proposal-class-static-block/" target="_blank" rel="noopener noreferrer">变量环境</a>嵌套在类的范围内。</p>
<pre>var age = 23
class NewClass {
  static {
      var age; // can still use age inside the static block 
              //because it creates as new lexical scope
      var name = "Lawrence Eagles"
  }
}

console.log(name) // reference error. 
                  // cannot access name inside the static block's lexical scope.</pre>
<p>从上面的代码中，我们可以看到，尽管<code>var age</code>是在与类相同的作用域中声明的，我们仍然在<code>class static block</code>中创建了一个新的<code>age</code>变量。这是因为<code>class static block {}</code>有自己的可变环境。</p>
<p>然而，我们无法访问在局部范围之外的<code>class static block {}</code>中初始化的<code>var name</code>变量。</p>
<p>A <code>static block {}</code>不应该有装修工。你要装饰类本身，如下所示:</p>
<pre>@decorator // ok
class NewClass {
  @decorator // error. not allowed
  static {
  }
}</pre>
<p>求值时，<code>static block {}</code>的<code>this</code>变量指向类的<code>constructor function</code>。</p>
<p>你可以在这里获得更多关于它的语义<a href="https://github.com/tc39/proposal-class-static-block#semantics" target="_blank" rel="noopener noreferrer">。</a></p>
<h2>静态块的用例</h2>
<p>如前所述，<code>static blocks</code>不是<code>static fields</code>或<code>static private fields</code>的替代品。</p>
<p>然而，它们意味着支持更多的用例，如下所示:</p>
<p>在<code>class initialization</code>期间评估a <code>statement</code>:</p>
<pre>class NewClass {
  static square = {L: 8, B: 6};
  static y;
  static z;
  // wrong code would throw an error
  try {
      // do something here
    }catch (error) {
      // handle error here
  }
}</pre>
<p>上面的代码会抛出一个错误。我们不能在类初始化期间评估那个<code>try…catch</code>语句。必须将<code>try…catch</code> <code>statement</code>移到类声明之外。</p>
<p>然而，如果我们需要评估一个类初始化中的语句(例如，<code>try..catch</code>)，我们可以使用如下所示的<code>static block</code>:</p>
<pre>class NewClass {
  static square = {L: 8, B: 6};
  static y;
  static z;
  static {
    try {
      // do something here
    }catch (error) {
      // handle error here
    }
  }
}
</pre>
<p>当我们需要从一个值设置两个字段时，如下所示:</p>
<pre>class NewClass {
  static square = {L: 8, B: 6};
  static y;
  static z;
  NewClass.y = square.L // throws an error
  NewClass.z = square.B // throws an error
}</pre>
<p>然而，我们可以使用如下所示的<code>static blocks</code>设置这些值:</p>
<pre>class NewClass {
  static square = {L: 8, B: 6};
  static y;
  static z;
  static {
    NewClass.y = square.L // correct
    NewClass.z = square.B // correct
  }
}
</pre>
<p>当一个带有<code>instance private field</code>的类和另一个在相同作用域中声明的类或函数之间需要共享信息时，如下所示:</p>
<pre>let getName;
export class NewClass {
  #name
  constructor(devName) {
    this.#name = { data: devName };
  }
  static {
    // getName has privileged access to the private state (#name)
    getName = (obj) =&gt; obj.#name;
  }
}

export function getNameData(obj) {
  return getName(obj).data;
}</pre>
<p>从上面我们可以看到，<code>static blocks</code>允许你在当前类声明的上下文中使用特权访问(<code>instance</code>或<code>static</code> ) <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes/Private_class_fields" target="_blank" rel="noopener noreferrer">私有状态</a>来评估语句。</p>
<p>尽管在<code>class static block {}</code>中对<code>getName</code>函数求值，但它仍然可以优先访问该类的名称<code>private state</code>。</p>
<p>你可以在这里了解更多关于<code>class static block {}</code> <a href="https://github.com/tc39/proposal-class-static-block#motivations" target="_blank" rel="noopener noreferrer">的可能用法。</a></p>
<h2>结论</h2>
<p>JavaScript的开发一直在不断发展，尤其是在OOP JavaScript中。虽然JavaScript保持了它的<code>prototypal inheritance</code>实现，但是许多新的和提议的特性与那些在<code>classical inheritance</code>中看到的类似。</p>
<p><code>Class static block {}</code>没什么不同。这种发展对语言是有益的，因为它现在吸引了更多的开发者，他们发现<code>prototypal inheritance</code>是采用JavaScript的一个障碍。</p>
<p>最后，<code>class static block {}</code>是对OOP JavaScript的一个强大补充，但它仍然是第二阶段提案的特性。</p><div class="code-block code-block-27">
<div class="blog-plug inline-plug vanilla-javascript-cta"><h2>通过理解上下文，更容易地调试JavaScript错误</h2>
<p>调试代码总是一项单调乏味的任务。但是你越了解自己的错误，就越容易改正。</p>
<p>LogRocket 让你以新的独特的方式理解这些错误。我们的前端监控解决方案跟踪用户与您的JavaScript前端的互动，让您能够准确找出导致错误的用户行为。</p>
<a href="https://lp.logrocket.com/blg/javascript-signup" class="signup" target="_blank" rel="noopener noreferrer"><img class="alignnone size-full wp-image-46 jetpack-lazy-image" src="../Images/cbfed9be3defcb505e662574769a7636.png" alt="LogRocket Dashboard Free Trial Banner" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2020/06/reproduce-javascript-errors.gif?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/06/reproduce-javascript-errors.gif"/><noscript><img data-lazy-fallback="1" class="alignnone size-full wp-image-46" src="../Images/cbfed9be3defcb505e662574769a7636.png" alt="LogRocket Dashboard Free Trial Banner" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/06/reproduce-javascript-errors.gif"/></noscript></a>
<p>LogRocket记录控制台日志、页面加载时间、堆栈跟踪、慢速网络请求/响应(带有标题+正文)、浏览器元数据和自定义日志。理解您的JavaScript代码的影响从来没有这么简单过！</p>
<a class="signup" href="https://lp.logrocket.com/blg/javascript-signup" target="_blank" rel="noopener noreferrer">Try it for free</a><p>.</p></div>


</div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
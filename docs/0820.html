<html>
<head>
<title>Building a REST API in Rust with warp - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>用warp - LogRocket博客在Rust中构建REST API</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/building-rest-api-rust-warp/#0001-01-01">https://blog.logrocket.com/building-rest-api-rust-warp/#0001-01-01</a></blockquote><div><article class="article-post">
<p><em> <strong>编者按:</strong>这个用warp在Rust中构建REST API的指南最后一次更新是在2023年2月8日，以反映Rust框架的最新变化。这次更新还包括了关于锈中翘曲的好处的新章节。</em></p>
<p>Rust是很多人最喜欢的编程语言，但是仍然很难找到一个关于它的项目，甚至很难掌握它。开始学习任何语言的一个好方法是构建一些你每天都会用到的东西。如果你的公司运营微服务，那就更容易了。Rust非常适合取代这样的服务，你可以在几天内重写它。</p>
<p/>
<p>从Rust开始，你需要<a href="https://blog.logrocket.com/getting-up-to-speed-with-rust/">学习基础知识</a>。一旦熟悉了语法和基本概念，就可以开始考虑<a href="https://blog.logrocket.com/a-practical-guide-to-async-in-rust/">异步Rust </a>了。大多数现代语言都有一个内置的运行时来处理异步任务，比如发送请求或在后台等待应答。</p>
<p>在Rust中，你必须选择一个适合你的异步运行时。库通常有自己的运行时。如果您从事一个较大的项目，您可能希望避免添加多个运行时，因为通过选择一个单一的、一致的运行时，您可以简化您的应用程序架构，并降低应用程序的复杂性和兼容性问题的风险。</p>
<p>Tokio是生产中使用最多的、经过验证的可以处理异步任务的运行时，所以你未来的雇主很可能已经在使用它了。因此，您的选择有些有限，因为您可能需要选择一个已经内置了Tokio的库来创建您的API。对于本教程，我们将使用<a href="https://github.com/seanmonstar/warp">扭曲</a>。根据您以前的编程经验，可能需要几天时间才能理解。但是一旦你理解了warp，它可以成为构建API的一个非常好的工具。</p>
<p><em>让我们开始吧:</em></p>

<h2 id="what-warp">什么是翘曲？</h2>
<p>Warp是一个最小且高效的web框架，用于在Rust中构建基于HTTP的web服务。它为构建HTTP服务器提供了一个高级API，关注安全性、性能和稳定性。Warp还包括一些内置特性，比如支持HTTP/1和HTTP/2、TLS加密、异步编程以及用于日志记录、速率限制和路由任务的通用中间件。它的许多功能都是从<a href="https://hyper.rs/"> Hyper </a>借来的，因为warp更像是Hyper的超集。</p>
<h2 id="setting-up-project">设置您的项目</h2>
<p>您需要安装以下库来跟随本教程。</p>
<ul>
<li>创建API的warp</li>
<li>Tokio运行异步服务器</li>
<li>Serde帮助序列化传入的JSON</li>
<li>为您的本地存储创建一个<code>ReadWriteLock</code></li>
</ul>
<p>首先，用cargo创建一个新项目:</p>
<pre class="language-rust hljs">cargo new neat-api --bin
</pre>
<p>我们已经在<code>Cargo.toml</code>中包含了warp，所以我们可以在我们的代码库中使用它:</p>
<pre class="language-rust hljs"><code>
[dependencies]
warp = "0.2"
parking_lot = "0.10.0"
serde = { version = "1.0", features = ["derive"] }
tokio = { version = "0.2", features = ["macros"] }
</code></pre>
<p>对于第一个测试，创建一个简单的“Hello，World！”进入<code>main.rs</code>，如下图:<br/> &lt;</p>
<pre class="language-rust hljs">use warp::Filter;

#[tokio::main]
async fn main() {
    // GET /hello/warp =&gt; 200 OK with body "Hello, warp!"
    let hello = warp::path!("hello" / String)
        .map(|name| format!("Hello, {}!", name));

    warp::serve(hello)
        .run(([127, 0, 0, 1], 3030))
        .await;
}
</pre>
<p>是一种解析请求并根据我们创建的路由进行匹配的方法。因此，当你通过<code>cargo run</code>启动服务器并将浏览器指向<code>localhost:3030/hello/WHATEVER</code>时，warp通过其过滤器发送这个请求，并执行第一个被触发的请求。</p>
<p>在<code>let hello = …</code>中，我们创建了一个新的路径，本质上就是说每个带有路径<code>/hello</code>和一个字符串的请求都由这个方法处理。所以，我们返回<code>Hello, WHATEVER</code>。<br/>如果我们将浏览器指向<code>localhost:3030/hello/new/WHATEVER</code>，我们将得到404，因为我们没有针对<code>/hello/new + String</code>的过滤器。</p>
<h2 id="building-rest-api">构建REST API</h2>
<p>让我们构建一个真实的API来演示这些概念。一个好的模型是用于购物清单的API。我们希望能够向列表中添加项目，更新数量，删除项目，并查看整个列表。因此，我们需要四个不同的路由，分别使用<a href="https://blog.logrocket.com/making-http-requests-rust-reqwest/"> HTTP方法</a> <code>GET</code>、<code>DELETE</code>、<code>PUT</code>和<code>POST</code>。有这么多不同的路径，为每一个创建方法而不是在<code>main.rs</code>中处理它们是明智的吗？</p>
<h3 id="creating-local-storage">创建本地存储</h3>
<p>除了路由，我们还需要在文件或局部变量中存储一个状态。在<a href="https://blog.logrocket.com/pinning-rust-async-data-types-memory-safety/">异步环境</a>中，我们必须确保一次只有一个方法可以访问存储，这样线程之间就不会有不一致。</p>
<p>在Rust中，我们有<code>Arc</code>，所以编译器知道何时丢弃一个值和一个读写锁(<code>RwLock</code>)。这样，不同线程上的两个方法就不会写入同一个内存。<br/>您的商店实现应该是这样的:<br/>T4</p>
<pre class="language-rust hljs">use parking_lot::RwLock;
use std::collections::HashMap;
use std::sync::Arc;

type Items = HashMap&lt;String, i32&gt;;

#[derive(Debug, Deserialize, Serialize, Clone)]
struct Item {
    name: String,
    quantity: i32,
}

#[derive(Clone)]
struct Store {
  grocery_list: Arc&lt;RwLock&lt;Items&gt;&gt;
}

impl Store {
    fn new() -&gt; Self {
        Store {
            grocery_list: Arc::new(RwLock::new(HashMap::new())),
        }
    }
}
</pre>
<h3 id="posting-item">将一个项目添加到列表中</h3>
<p>现在，我们可以添加我们的第一条路线。要向列表中添加项目，需要向路径发出HTTP <code>POST</code>请求。我们的方法必须返回一个正确的HTTP代码，以便调用者知道他们的调用是否成功。Warp通过自己的<code>http</code>库提供基本类型，我们也需要包含这些类型。像这样添加:<br/>T3】</p>
<pre class="language-rust hljs">use warp::{http, Filter};
</pre>
<p>用于<code>POST</code>请求的方法如下:<br/> &lt;</p>
<pre class="language-rust hljs">async fn add_grocery_list_item(
    item: Item,
    store: Store
    ) -&gt; Result&lt;impl warp::Reply, warp::Rejection&gt; {
        let r = store.grocery_list.read();
        Ok(warp::reply::json(&amp;*r))
}
</pre>
<p>warp框架提供了选择<code>reply with status</code>的选项，所以我们可以添加文本和一个通用的HTTP状态，这样调用者就知道请求是否成功，或者他们是否必须再试一次。现在，添加一个新的路由，并调用刚刚为它创建的方法。因为您可以期待一个JSON，所以您应该创建一个小的<code>json_body</code>助手函数来从HTTP请求的<code>body</code>中提取出<code>Item</code>。</p>
<p>此外，我们需要通过克隆它并创建一个<code>warp filter</code>来将存储传递给每个方法，在<code>warp path</code>创建期间，我们在<code>.and()</code>中调用这个方法:<br/> &lt;</p>
<pre class="language-rust hljs">fn json_body() -&gt; impl Filter&lt;Extract = (Item,), Error = warp::Rejection&gt; + Clone {
    // When accepting a body, we want a JSON body
    // (and to reject huge payloads)...
    warp::body::content_length_limit(1024 * 16).and(warp::body::json())
}

#[tokio::main]
async fn main() {
    let store = Store::new();
    let store_filter = warp::any().map(move || store.clone());

    let add_items = warp::post()
        .and(warp::path("v1"))
        .and(warp::path("groceries"))
        .and(warp::path::end())
        .and(json_body())
        .and(store_filter.clone())
        .and_then(add_grocery_list_item);

    warp::serve(add_items)
        .run(([127, 0, 0, 1], 3030))
        .await;
}
</pre>
<p>你可以通过<code>curl</code>或者像<a href="https://blog.logrocket.com/how-automate-api-tests-postman/">邮差</a>这样的应用程序来测试<code>POST</code>调用，它现在是一个独立的HTTP请求应用程序。通过<code>cargo run</code>启动服务器，打开另一个终端窗口或标签，执行下面的<code>curl</code> : <br/> &lt;</p>
<pre class="language-shell hljs">curl --location --request POST 'localhost:3030/v1/groceries' \
--header 'Content-Type: application/json' \
--header 'Content-Type: text/plain' \
--data-raw '{
        "name": "apple",
        "quantity": 3
}'
</pre>
<p>您应该得到方法中定义的文本响应和HTTP代码。</p>
<h3 id="getting-grocery-list">购物清单</h3>
<p>现在，我们可以将商品列表发布到我们的杂货列表中，但是我们仍然无法检索它们。我们需要为<code>GET</code>请求创建另一个路由。我们的主要功能是添加这条新路线。对于这条新路线，我们不需要解析任何JSON。代码如下:</p>
<pre class="language-rust hljs">#[tokio::main]
async fn main() {
    let store = Store::new();
    let store_filter = warp::any().map(move || store.clone());

    let add_items = warp::post()
        .and(warp::path("v1"))
        .and(warp::path("groceries"))
        .and(warp::path::end())
        .and(json_body())
        .and(store_filter.clone())
        .and_then(add_grocery_list_item);

    let get_items = warp::get()
        .and(warp::path("v1"))
        .and(warp::path("groceries"))
        .and(warp::path::end())
        .and(store_filter.clone())
        .and_then(get_grocery_list);


    let routes = add_items.or(get_items);

    warp::serve(routes)
        .run(([127, 0, 0, 1], 3030))
        .await;
}
</pre>
<p>当您检查您的<code>Arc</code>背后的数据结构时，您将体验到异步Rust的味道。您需要使用<code>.read()</code>方法来访问和取消引用数据。该函数如下所示:</p>
<pre class="language-rust hljs">async fn get_grocery_list(
    store: Store
    ) -&gt; Result&lt;impl warp::Reply, warp::Rejection&gt; {
         let result = store.grocery_list.read();
        Ok(warp::reply::json(&amp;*result))
}
</pre>
<p>然后，为<code>store.grocery_list.read()</code>创建一个变量，我们称之为<code>result</code>。注意我们正在返回<code>&amp;*result;</code>这是新的，对吗？是的，<code>&amp;*result</code>将<code><a href="https://doc.rust-lang.org/std/sync/struct.RwLockReadGuard.html">RwLockReadGuard</a></code>对象<code>result</code>解引用到一个<code>&amp;HashMap</code>，然后作为对已经返回的<code>warp::reply::json</code>函数的引用传递。</p>
<h3 id="update-delete"><code>UPDATE</code>和<code>DELETE</code></h3>
<p>最后两个缺失的方法是<code>UPDATE</code>和<code>DELETE</code>。对于<code>DELETE</code>，你几乎可以复制你的<code>add_grocery_list_item</code>，而不是<code>.insert()</code>，<code><a href="https://doc.rust-lang.org/std/collections/struct.HashMap.html#method.remove">.remove()</a></code>一个词条。</p>
<p>一个特例是<code>UPDATE</code>。这里Rust <code>HashMap</code>实现也使用了<code>.insert()</code>，但是如果键不存在，它会更新值而不是创建一个新条目。因此，只需重命名该方法，并为<code>POST</code>和<code>PUT</code>调用它。</p>
<p>对于<code>DELETE</code>方法，您只需要传递项目的名称，因此创建一个新的struct并为新类型添加另一个<code>parse_json()</code>方法。重命名第一个解析方法，并添加另一个方法。</p>
<p>您可以简单地将您的<code>add_grocery_list_item</code>方法重命名为<code>update_grocery_list</code>，并为一个<code>warp::post()</code>和<code>warp::put()</code>调用它。您的完整代码应该如下所示:</p>
<pre class="language-rust hljs">use warp::{http, Filter};
use parking_lot::RwLock;
use std::collections::HashMap;
use std::sync::Arc;
use serde::{Serialize, Deserialize};

type Items = HashMap&lt;String, i32&gt;;

#[derive(Debug, Deserialize, Serialize, Clone)]
struct Id {
    name: String,
}

#[derive(Debug, Deserialize, Serialize, Clone)]
struct Item {
    name: String,
    quantity: i32,
}

#[derive(Clone)]
struct Store {
  grocery_list: Arc&lt;RwLock&lt;Items&gt;&gt;
}

impl Store {
    fn new() -&gt; Self {
        Store {
            grocery_list: Arc::new(RwLock::new(HashMap::new())),
        }
    }
}

async fn update_grocery_list(
    item: Item,
    store: Store
    ) -&gt; Result&lt;impl warp::Reply, warp::Rejection&gt; {
        store.grocery_list.write().insert(item.name, item.quantity);


        Ok(warp::reply::with_status(
            "Added items to the grocery list",
            http::StatusCode::CREATED,
        ))
}

async fn delete_grocery_list_item(
    id: Id,
    store: Store
    ) -&gt; Result&lt;impl warp::Reply, warp::Rejection&gt; {
        store.grocery_list.write().remove(&amp;id.name);


        Ok(warp::reply::with_status(
            "Removed item from grocery list",
            http::StatusCode::OK,
        ))
}

async fn get_grocery_list(
    store: Store
    ) -&gt; Result&lt;impl warp::Reply, warp::Rejection&gt; {
        let r = store.grocery_list.read();
        Ok(warp::reply::json(&amp;*r))
}

fn delete_json() -&gt; impl Filter&lt;Extract = (Id,), Error = warp::Rejection&gt; + Clone {
    // When accepting a body, we want a JSON body
    // (and to reject huge payloads)...
    warp::body::content_length_limit(1024 * 16).and(warp::body::json())
}

fn post_json() -&gt; impl Filter&lt;Extract = (Item,), Error = warp::Rejection&gt; + Clone {
    // When accepting a body, we want a JSON body
    // (and to reject huge payloads)...
    warp::body::content_length_limit(1024 * 16).and(warp::body::json())
}

#[tokio::main]
async fn main() {
    let store = Store::new();
    let store_filter = warp::any().map(move || store.clone());

    let add_items = warp::post()
        .and(warp::path("v1"))
        .and(warp::path("groceries"))
        .and(warp::path::end())
        .and(post_json())
        .and(store_filter.clone())
        .and_then(update_grocery_list);

    let get_items = warp::get()
        .and(warp::path("v1"))
        .and(warp::path("groceries"))
        .and(warp::path::end())
        .and(store_filter.clone())
        .and_then(get_grocery_list);

    let delete_item = warp::delete()
        .and(warp::path("v1"))
        .and(warp::path("groceries"))
        .and(warp::path::end())
        .and(delete_json())
        .and(store_filter.clone())
        .and_then(delete_grocery_list_item);


    let update_item = warp::put()
        .and(warp::path("v1"))
        .and(warp::path("groceries"))
        .and(warp::path::end())
        .and(post_json())
        .and(store_filter.clone())
        .and_then(update_grocery_list);



    let routes = add_items.or(get_items).or(delete_item).or(update_item);

    warp::serve(routes)
        .run(([127, 0, 0, 1], 3030))
        .await;
}
</pre>
<h2 id="testing-curls">了解测试卷曲</h2>
<p>更新代码后，通过<code>cargo run</code>重启服务器，并使用这些curls来发布、更新、获取和删除项目。</p>
<h3><code>POST</code></h3>
<pre class="language-shell hljs">curl --location --request POST 'localhost:3030/v1/groceries' \
--header 'Content-Type: application/json' \
--header 'Content-Type: text/plain' \
--data-raw '{
        "name": "apple",
        "quantity": 3
}'
</pre>
<h3><code>UPDATE</code></h3>
<pre class="language-shell hljs">curl --location --request PUT 'localhost:3030/v1/groceries' \
--header 'Content-Type: application/json' \
--header 'Content-Type: text/plain' \
--data-raw '{
        "name": "apple",
        "quantity": 5
}'
</pre>
<h3><code>GET</code></h3>
<pre class="language-shell hljs">curl --location --request GET 'localhost:3030/v1/groceries' \
--header 'Content-Type: application/json' \
--header 'Content-Type: text/plain'
</pre>
<h3><code>DELETE</code></h3>
<pre class="language-shell hljs">curl --location --request DELETE 'localhost:3030/v1/groceries' \
--header 'Content-Type: application/json' \
--header 'Content-Type: text/plain' \
--data-raw '{
        "name": "apple"
}'
</pre>
<p>总结一下我们刚刚讲述的步骤:</p>
<ul>
<li>为每个项目创建一个ID，以便您可以通过<code>/v1/groceries/{id}</code>进行更新和删除</li>
<li>添加404路线</li>
<li>为格式错误的JSON添加错误处理</li>
<li>调整每条路线的返回消息</li>
<li>为每条有弯曲的路线添加测试</li>
</ul>
<h2 id="why-use-warp-rust">为什么在Rust中使用warp</h2>
<p>在Rust中构建API时，您有几个库选项。但是，项目的具体要求将有助于指导您的选择。如果你决定使用warp，这里有一些在Rust项目中使用它的好处。</p>
<ol>
<li>性能:warp被设计为快速高效，侧重于异步处理和性能优化特性，比如自动HTTP保持活动和连接池</li>
<li>安全性:warp非常重视安全性，内置TLS加密支持等功能可确保您的数据在网络上安全传输</li>
<li>简单性:warp提供了一个易于使用的高级API，但仍然是强大的和可定制的。这使得开始构建HTTP服务器变得简单，并且可以根据需要用额外的功能轻松地扩展您的应用程序</li>
<li>健壮性:warp被设计得稳定可靠，重点是错误处理和报告</li>
<li>可伸缩性:warp被设计成可伸缩的，支持HTTP/1和HTTP/2以及高效的资源利用，这使得它成为构建高性能和可伸缩的web应用程序的绝佳选择</li>
</ol>
<h2>最后的想法</h2>
<p>Warp是一个用Rust构建web APIs的有趣工具。尽管代码远非完美，样本代码还是给了我们warp的冰山一角。我们可以延长它，我希望你这样做。我很乐意看到你基于你已经建立的反馈。</p>
<p>您可以添加一些内容:</p>
<ul>
<li>错误处理</li>
<li>单元测试</li>
<li>统一的JSON响应</li>
</ul>
<p>您可以看到用Rust和warp创建您的第一个REST API是多么简单，Rust type系统是如何明确您正在处理什么数据以及您可以使用什么方法的。现在就看你自己磨练技巧，优化代码了。你可以在<a href="https://github.com/gruberb/warp-examaple-api"> GitHub </a>找到完整的源代码。请随意克隆、试验和改进它。</p><div class="code-block code-block-29">
<div class="blog-plug inline-plug rust-plug"><h2><a href="https://lp.logrocket.com/blg/rust-signup" target="_blank">log rocket</a>:Rust应用的web前端的全面可见性</h2><p>调试Rust应用程序可能很困难，尤其是当用户遇到难以重现的问题时。如果您对监控和跟踪Rust应用程序的性能、自动显示错误、跟踪缓慢的网络请求和加载时间感兴趣，</p><a href="https://lp.logrocket.com/blg/rust-signup" target="_blank">try LogRocket</a><p>. </p><a class="signup" href="https://lp.logrocket.com/blg/rust-signup" target="_blank" rel="noopener noreferrer"><img class="alignnone size-full wp-image-46 jetpack-lazy-image" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/><noscript><img data-lazy-fallback="1" class="alignnone size-full wp-image-46" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/></noscript></a><p>LogRocket 就像是网络和移动应用程序的DVR，记录你的Rust应用程序上发生的一切。您可以汇总并报告问题发生时应用程序的状态，而不是猜测问题发生的原因。LogRocket还可以监控应用的性能，报告客户端CPU负载、客户端内存使用等指标。</p><p>现代化调试Rust应用的方式— <a class="signup" href="https://lp.logrocket.com/blg/rust-signup" target="_blank" rel="noopener noreferrer">开始免费监控</a>。</p></div>


</div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
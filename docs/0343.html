<html>
<head>
<title>Using ECMAScript modules (ESM) with Node.js - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>将ECMAScript模块(ESM)用于Node.js - LogRocket博客</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/how-to-use-ecmascript-modules-with-node-js/#0001-01-01">https://blog.logrocket.com/how-to-use-ecmascript-modules-with-node-js/#0001-01-01</a></blockquote><div><article class="article-post">
<p><strong> <em>编者按:</em> </strong> <em>本帖于2021年4月更新，包含ES模块的更新及相关信息。</em></p>
<p>自2009年以来，就在Kevin Dangoor启动了CommonJS项目之后，一场新的讨论开始了，关于JavaScript如何更好地适应构建应用程序的过程，不仅要在web浏览器中运行，还要将其能力扩大到越来越广泛的可能性。当然，这些必须包括后端世界。</p>
<p>它成功的关键实际上是由于它的API，它带来了一个丰富的标准库，类似于我们为其他语言如<a href="https://blog.logrocket.com/how-python-can-help-you-learn-es6/" target="_blank" rel="noopener noreferrer"> Python </a>、Java等所拥有的标准库。今天，多亏了CommonJS，我们在服务器端应用程序、命令行工具、基于GUI的桌面和混合应用程序(Titanium、Adobe AIR等)中有了JavaScript。)，还有更多。</p>
<p>无论如何，每次你使用一个<code>require()</code>，你实际上是在使用CommonJS模块的实现，默认情况下它在Node.js中。</p>
<h2>什么是ECMAScript模块(ESM)？</h2>
<p>CommonJS模块虽然由于Node.js而无处不在，但并不是JavaScript语言规范的正式组成部分。另一方面，ECMAScript模块(简称es模块或ESM)是JavaScript语言规范的一个相对较新的补充，正在寻求统一和标准化模块在JavaScript应用程序中的加载方式。</p>
<p>这是将ES模块与<a href="https://blog.logrocket.com/how-to-use-event-driven-programming-in-node-js/" target="_blank" rel="noopener noreferrer">节点</a>一起使用的第一个问题:CommonJS已经是一个模块系统，ESM必须找到与其共存的最佳方式。这应该不是问题，除了一个重要的事实:ESM是异步加载的，而CommonJS是同步加载的。</p>
<p>当谈到像<a href="https://babeljs.io/"> Babel </a>和<a href="https://webpack.js.org/"> webpack </a>这样的工具时，负载也由同步进程承担，因此考虑到它们允许浏览器和服务器端的应用程序在没有本机支持的情况下运行的同构特性，我们会有一些问题。</p>
<p>在本文中，我们将探索在Node.js宇宙中支持这两个世界的旅程已经走了多远。我们将创建几个示例，让您更深入地了解如何迁移您的代码库，以利用ESM的强大功能。</p>
<h2>ES模块使用简介</h2>
<p>如果您是ES模块的初学者，让我们仔细看看如何使用它们。如果你曾经使用过React或Vue.js，你可能会看到这样的东西:</p>
<pre>import React, {Fragment} from 'react';
// or
import Vue from './vue.mjs';
</pre>
<p>特别是第一个例子，它是一个很好的例子，因为它展示了默认导出和命名导出之间的区别。考虑下面的代码片段:</p>
<pre>export default React;
</pre>
<p>我们只能为每个文件导出一个默认模块。这就是为什么<code>Fragment</code>必须导入到<code>{ }</code> s中的原因，因为它不是默认包含的。它的输出看起来像:</p>
<pre>export const Fragment = … ;
</pre>
<p>很明显，你可以创造你自己的，就像这样:</p>
<pre>export const itsMine = 'It is my module';
</pre>
<p>将这段代码保存到一个<code>mjs</code>扩展文件中，正如我们在React示例中看到的，您可以将它导入到另一个文件中:</p>
<pre>import { itsMine } from './myESTest.mjs'

alert(itsMine); // it'll alert 'It is my module' text
</pre>
<p>当我们将扩展名<code>mjs</code>与<code>js</code>文件进行比较时，它可能会导致一些混淆。对于JavaScript规范来说，两者是有区别的。例如，按照定义，模块是严格的(就像在<code>'use strict'</code>中一样)，所以这意味着在实现你的JavaScript模块时，要进行大量的检查，并且禁止“不安全”的动作。</p>
<p>对于JavaScript引擎来说,<code>js</code>和<code>mjs</code>的区别是必要的，这样才能知道它处理的是模块还是脚本。例如，如果您得到一个CommonJS脚本，您不允许在其中使用<code>'import from'</code>(只有<code>require</code>)，所以他们可以强制每个扩展导入适当的、各自的模块脚本:</p>
<ul>
<li><code>mjs import from mjs</code></li>
<li><code>js require js</code></li>
</ul>
<p>但是互操作性很重要；那么在下面的场景中会发生什么呢？</p>
<ul>
<li><code>mjs import from js</code></li>
<li><code>js require mjs</code></li>
</ul>
<p>说到es模块，众所周知它们是静态的——也就是说，你只能在编译时“访问”它们，而不能在运行时访问。这就是为什么我们必须把它们放在文件的开头。</p>
<h3>从js导入mjs</h3>
<p>这里要注意的第一件事是你不能在一个<code>mjs</code>文件中使用<code>require</code>。(如果您尝试这样做，您将会看到一个错误，指出“require is not defined。”)相反，我们必须使用我们以前见过的导入语法:</p>
<pre>import itsMine from './myESTest.js'
</pre>
<p>但前提是默认导入(<code>module.exports</code>)已经导出到CommonJS文件(<code>myESTest.js</code>)。很简单，不是吗？</p>
<h3>js需要mjs</h3>
<p>然而，当相反的情况发生时，我们不能简单地使用:</p>
<pre>const itsMine require('./myESTest.mjs')
</pre>
<p>记住，ESM不能通过<code>require</code>功能导入。另一方面，如果您尝试使用<code>import from</code>语法，我们会得到一个错误，因为CommonJS文件不允许使用它:</p>
<pre>import { itsMine } from './myESTest.mjs' // will err
</pre>
<p>多米尼奇·德尼科拉提出了一个通过<code>import()</code>函数以多种方式动态导入ES模块的过程。请参考链接，了解更多信息。有了它，我们的代码将如下所示:</p>
<pre>async function myFunc() {
const { itsMine } = await import('./myESTest.mjs')
}
myFunc()
</pre>
<p>但是，请注意，这种方法将引导我们使用异步函数。您也可以通过回调、承诺和其他技术来实现这一点，在这里会有更详细的描述<a href="http://2ality.com/2017/01/import-operator.html">。</a></p>
<p><em>注意:这种类型的导入只能从节点10+开始使用。</em></p>
<h2>使用ES模块运行Node.js</h2>
<p>在Node.js中运行ES模块有两种主要方式:</p>
<ol>
<li>通过使用高于12.0.0的Node.js版本。</li>
<li>通过一个将ES模块支持添加到Node旧版本的库，在本例中是<a href="https://www.npmjs.com/package/esm" target="_blank" rel="noopener"> ESM </a>，它将实现的所有主要部分捆绑在一个地方</li>
</ol>
<p>在Node GitHub repo中，您可以找到一个名为“<a href="https://github.com/nodejs/modules/blob/main/doc/archive/plan-for-new-modules-implementation.md">Plan for New Modules Implementation</a>”的归档页面，在这里您可以遵循Node.js团队为支持Node.js中的ECMAScript模块而遵循的官方计划。</p>
<h3>使用官方的ES模块支持</h3>
<p>让我们从Node.js提供的第一种(也是官方的)方式开始，在您的节点环境中使用ES模块。</p>
<p>首先，如前所述，确保您的机器上的Node版本高于12。您可以使用<a href="https://github.com/nvm-sh/nvm"> NVM </a>的能力来管理和升级您当前的版本。</p>
<p>然后，我们将创建一个单独的例子，只是为了让您体验一下模块是如何工作的。创建以下结构:</p>
<figure class="wp-block-image"><img data-attachment-id="3565" data-permalink="https://blog.logrocket.com/how-to-use-ecmascript-modules-with-node-js/project-structure/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2019/07/project-structure.png" data-orig-size="956,234" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Example project structure" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2019/07/project-structure-300x73.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2019/07/project-structure.png" decoding="async" class="aligncenter wp-image-3565 jetpack-lazy-image" src="../Images/ab09ac0cbc3f522bd2f074e41be740e5.png" alt="ESM ES modules node project example" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2019/07/project-structure.png 956w, https://blog.logrocket.com/wp-content/uploads/2019/07/project-structure-300x73.png 300w, https://blog.logrocket.com/wp-content/uploads/2019/07/project-structure-768x188.png 768w" data-lazy-sizes="(max-width: 500px) 100vw, 500px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2019/07/project-structure.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/07/project-structure.png"/><noscript><img data-lazy-fallback="1" data-attachment-id="3565" data-permalink="https://blog.logrocket.com/how-to-use-ecmascript-modules-with-node-js/project-structure/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2019/07/project-structure.png" data-orig-size="956,234" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Example project structure" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2019/07/project-structure-300x73.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2019/07/project-structure.png" decoding="async" loading="lazy" class="aligncenter wp-image-3565" src="../Images/ab09ac0cbc3f522bd2f074e41be740e5.png" alt="ESM ES modules node project example" srcset="https://blog.logrocket.com/wp-content/uploads/2019/07/project-structure.png 956w, https://blog.logrocket.com/wp-content/uploads/2019/07/project-structure-300x73.png 300w, https://blog.logrocket.com/wp-content/uploads/2019/07/project-structure-768x188.png 768w" sizes="(max-width: 500px) 100vw, 500px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/07/project-structure.png"/></noscript><figcaption>Our project structure.</figcaption></figure>
<p>第一个文件<code>hi.mjs</code>将存放一个函数的代码，该函数将连接一个字符串参数并返回一条hello消息:</p>
<pre>// Code of hi.mjs
export function sayHi(name) {
    return "Hi, " + name + "!"
}
</pre>
<p>注意，我们正在利用<code>export</code>特性。第二个文件<code>runner.mjs</code>将负责导入我们的函数并将消息打印到控制台:</p>
<pre>// Code of runner.mjs
import { sayHi } from './hi.mjs'

console.log(sayHi('LogRocket'))
</pre>
<p>要运行我们的代码，只需发出以下命令:</p>
<pre>node runner.mjs
</pre>
<p>这将是输出:</p>
<figure class="wp-block-image"><figcaption><img data-attachment-id="43518" data-permalink="https://blog.logrocket.com/how-to-use-ecmascript-modules-with-node-js/image1-11/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2019/07/image1.png" data-orig-size="584,146" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="ES-modules-node-runner" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2019/07/image1-300x75.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2019/07/image1.png" decoding="async" class="aligncenter size-full wp-image-43518 jetpack-lazy-image" src="../Images/3d2673cafd42db8d76a5c178a86ac890.png" alt="ESM ES modules node runner output" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2019/07/image1.png 584w, https://blog.logrocket.com/wp-content/uploads/2019/07/image1-300x75.png 300w" data-lazy-sizes="(max-width: 584px) 100vw, 584px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2019/07/image1.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/07/image1.png"/><noscript><img data-lazy-fallback="1" data-attachment-id="43518" data-permalink="https://blog.logrocket.com/how-to-use-ecmascript-modules-with-node-js/image1-11/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2019/07/image1.png" data-orig-size="584,146" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="ES-modules-node-runner" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2019/07/image1-300x75.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2019/07/image1.png" decoding="async" loading="lazy" class="aligncenter size-full wp-image-43518" src="../Images/3d2673cafd42db8d76a5c178a86ac890.png" alt="ESM ES modules node runner output" srcset="https://blog.logrocket.com/wp-content/uploads/2019/07/image1.png 584w, https://blog.logrocket.com/wp-content/uploads/2019/07/image1-300x75.png 300w" sizes="(max-width: 584px) 100vw, 584px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/07/image1.png"/></noscript></figcaption></figure>
<h2>使用ESM库</h2>
<p>虽然在前端，我们可以利用Babel、webpack或类似的工具来帮助我们在本地支持尚不可用的情况下使用ES模块，但我们有另一个针对Node.js的解决方案，在类似的情况下更简洁:它是ESM包。</p>
<blockquote><p>注意:只有旧版本的Node才需要这种方法。node的最新版本支持开箱即用的ES模块。</p></blockquote>
<p>它基本上由一个模块加载器组成，该加载器在CommonJS模块系统之上添加了对ES模块的支持。不需要依赖关系；它允许您超级快速地使用Node.js v6+中的ES模块。当然，它完全符合Node ES模块规范。</p>
<p>现在让我们考虑一个不同的<code>hello world</code>，这次是在网络上，用<a href="https://expressjs.com/"> Express.js </a>。我们将创建一个CJS文件来与ESM文件对话。</p>
<p>但是首先，在我们项目的根文件夹中，运行以下命令来设置您的<code>package.json</code>文件:</p>
<pre>npm init -y
npm install --save esm
npm install --save express
</pre>
<p>完成后，创建两个新文件:</p>
<ul>
<li><code>runner.js</code>将是执行的起点，但是现在作为一个单独的JavaScript文件</li>
<li><code>hi-web.mjs</code>将存储快速访问hello功能的代码</li>
</ul>
<p>让我们从<code>hi-web.mjs</code>源代码开始:</p>
<pre>import express from "express";
import { sayHi } from "./hi.mjs";

const app = express();

app.get("/", (req, res) =&gt; res.json({ "message": sayHi("LogRocket") }));

app.listen(8080, () =&gt; console.log("Hello ESM with esm !!"));
</pre>
<p>注意，在这里，我们使用的是托管<code>sayHi()</code>函数的前一个<code>mjs</code>文件。一旦我们看到我们可以完美地从另一个文件导入<code>mjs</code>文件，这就不是什么大新闻了。看看我们如何将这个文件导入到我们的启动脚本中:</p>
<pre>// runner.js code
require = require("esm")(module);
module.exports = require("./hi-web.mjs").default;
</pre>
<p>一旦我们不使用动态导入，就必须使用<code>default</code>。ESM包重写了<code>require</code>，还向正在使用的节点版本模块添加了功能。它进行一些内联和按需转换，实时处理和缓存执行。</p>
<p>在运行这个例子之前，请确保修改您的<code>package.json</code>,以理解哪个文件将是起点:</p>
<pre>...

"scripts": {
    "start": "node runner.js"
},
</pre>
<p>在运行npm start命令之后，当我们的服务器启动时，我们应该在控制台中看到一条消息，并且请求localhost:8080将在浏览器中显示以下输出:</p>
<figure class="wp-block-image">
<p><figure id="attachment_3567" aria-describedby="caption-attachment-3567" class="wp-caption aligncenter"> <img data-attachment-id="3567" data-permalink="https://blog.logrocket.com/how-to-use-ecmascript-modules-with-node-js/browser-output-example/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2019/07/browser-output-example.png" data-orig-size="1068,348" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Browser output example" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2019/07/browser-output-example-300x98.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2019/07/browser-output-example-1024x334.png" decoding="async" class="wp-image-3567 jetpack-lazy-image" src="../Images/0e34562bf70d9ee487f7d080ea523b21.png" alt="ESM ES modules node browser output" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2019/07/browser-output-example.png 1068w, https://blog.logrocket.com/wp-content/uploads/2019/07/browser-output-example-300x98.png 300w, https://blog.logrocket.com/wp-content/uploads/2019/07/browser-output-example-768x250.png 768w, https://blog.logrocket.com/wp-content/uploads/2019/07/browser-output-example-1024x334.png 1024w" data-lazy-sizes="(max-width: 500px) 100vw, 500px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2019/07/browser-output-example.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/07/browser-output-example.png"/> <noscript> <img data-lazy-fallback="1" data-attachment-id="3567" data-permalink="https://blog.logrocket.com/how-to-use-ecmascript-modules-with-node-js/browser-output-example/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2019/07/browser-output-example.png" data-orig-size="1068,348" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Browser output example" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2019/07/browser-output-example-300x98.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2019/07/browser-output-example-1024x334.png" decoding="async" loading="lazy" class="wp-image-3567" src="../Images/0e34562bf70d9ee487f7d080ea523b21.png" alt="ESM ES modules node browser output" srcset="https://blog.logrocket.com/wp-content/uploads/2019/07/browser-output-example.png 1068w, https://blog.logrocket.com/wp-content/uploads/2019/07/browser-output-example-300x98.png 300w, https://blog.logrocket.com/wp-content/uploads/2019/07/browser-output-example-768x250.png 768w, https://blog.logrocket.com/wp-content/uploads/2019/07/browser-output-example-1024x334.png 1024w" sizes="(max-width: 500px) 100vw, 500px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/07/browser-output-example.png"/> </noscript> <figcaption id="caption-attachment-3567" class="wp-caption-text">浏览器输出。</figcaption> </figure> <figcaption/></p></figure>
<h2>结论</h2>
<p>有关ES模块如何与Node一起工作的更多详细信息，请访问他们的<a href="https://nodejs.org/api/esm.html">官方文档</a>。</p>
<p>在处理基本代码转换时，请记住以下要点:</p>
<ul>
<li>将您的<code>js</code>文件迁移到<code>mjs</code>时，将基本导出(<code>module.exports</code>)更改为新的ESM <code>export</code>语句</li>
<li>所有的<code>require</code>必须更改为各自的导入语句</li>
<li>如果你正在动态地使用<code>require</code>，记住也要通过<code>await import</code>(或者我们已经看到的动态<code>import()</code>函数)进行导入</li>
<li>还要更改其他文件中引用您要迁移的内容的其他<code>require</code></li>
<li><code>mjs</code>文件在浏览器中使用时，必须使用正确的媒体类型，即<code>text/javascript</code>或<code>application/javascript</code>。由于浏览器不关心扩展，Node.js是唯一需要扩展存在的东西。这是检测文件是CJS模块还是ES模块的方法</li>
</ul>
<p>好好学习！</p><div class="code-block code-block-23">
<div class="blog-plug inline-plug node-plug"><h2>200只<img src="../Images/61167b9d027ca73ed5aaf59a9ec31267.png" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2019/10/green-check.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" class=" jetpack-lazy-image" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/10/green-check.png"/> <noscript> <img data-lazy-fallback="1" src="../Images/61167b9d027ca73ed5aaf59a9ec31267.png" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/10/green-check.png"/> </noscript>显示器出现故障，生产中网络请求缓慢</h2><p>部署基于节点的web应用程序或网站是容易的部分。确保您的节点实例继续为您的应用程序提供资源是事情变得更加困难的地方。如果您对确保对后端或第三方服务的请求成功感兴趣，</p><a href="https://lp.logrocket.com/blg/node-signup" target="_blank">try LogRocket</a><p>. </p><a class="signup" href="https://lp.logrocket.com/blg/node-signup" target="_blank" rel="noopener noreferrer"><img src="../Images/cae72fd2a54c5f02a6398c4867894844.png" alt="LogRocket Network Request Monitoring" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2019/12/network-request-filter-2-1.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" class=" jetpack-lazy-image" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/12/network-request-filter-2-1.png"/><noscript><img data-lazy-fallback="1" src="../Images/cae72fd2a54c5f02a6398c4867894844.png" alt="LogRocket Network Request Monitoring" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/12/network-request-filter-2-1.png"/></noscript></a><a href="https://lp.logrocket.com/blg/node-signup" target="_blank" rel="noopener noreferrer">https://logrocket.com/signup/</a><p>LogRocket 就像是网络和移动应用程序的DVR，记录下用户与你的应用程序交互时发生的一切。您可以汇总并报告有问题的网络请求，以快速了解根本原因，而不是猜测问题发生的原因。</p><p>LogRocket检测您的应用程序以记录基线性能计时，如页面加载时间、到达第一个字节的时间、慢速网络请求，还记录Redux、NgRx和Vuex操作/状态。</p><a class="signup" href="https://lp.logrocket.com/blg/node-signup" target="_blank" rel="noopener noreferrer">Start monitoring for free</a><p>. </p></div>
</div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
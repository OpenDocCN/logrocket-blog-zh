<html>
<head>
<title>Livewire vs. Inertia.js: Comparing Laravel frontends - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>Livewire vs. Inertia.js:比较Laravel前端- LogRocket博客</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/livewire-vs-inertia-js/#0001-01-01">https://blog.logrocket.com/livewire-vs-inertia-js/#0001-01-01</a></blockquote><div><article class="article-post">
<p>编者按:这篇文章在2021年9月进行了编辑和更新，以包括Livewire与Inertia.js的比较，这是利用Vue.js前端和Laravel后端的新方法。</p>
<p>Blade是一种非常棒的模板语言，它允许我们制作全面的、动态的Laravel应用程序视图。然而，许多现代应用程序要求页面组件更新而无需页面重新加载，而传统的Laravel应用程序使用Blade和jQuery之类的JavaScript库来实现这一点很麻烦。</p>
<p>另一方面，使用React、Svelte和Vue等JavaScript框架构建的单页面应用程序(SPAs)可以毫不费力地做到这一点。</p>
<p>感谢Laravel社区的贡献者，现在我们有几种方法可以构建这种类型的应用程序。在本文中，我们将讨论两种最流行的前端技术，它们被用来构建Laravel的现代web应用程序:Livewire和Vue。</p>
<h2>先决条件</h2>
<p>要跟随本教程，您需要:</p>
<ul>
<li>对Vue 3 ( <a href="https://blog.logrocket.com/refactoring-vue-2-apps-vue-3/" target="_blank" rel="noopener">或至少Vue 2 </a>)有所了解</li>
<li>拉勒维尔的知识</li>
<li>使用Blade制作模板的经验</li>
</ul>
<h2>背景</h2>
<p>从Laravel 8开始，Laravel应用中的认证和前端现在有两种主要的搭建方式:<a href="https://laravel.com/docs/8.x/starter-kits#laravel-jetstream" target="_blank" rel="noopener"> Laravel Jetstream </a>和<a href="https://laravel.com/docs/8.x/starter-kits#laravel-breeze" target="_blank" rel="noopener"> Laravel Breeze </a>。</p>
<p>通过Jetstream，我们可以为Laravel应用提供认证、电子邮件验证、密码重置系统、会话管理、使用Tailwind CSS的前端等。我们还可以选择两种前端技术来构建这些应用程序:Inertia.js和Livewire。</p>
<p>Laravel Breeze有些类似，但它是一种更简单的方法，可以通过身份验证和前端搭建来设置应用程序。另一个区别是，Breeze只附带了Inertia.js。</p>
<p><a href="https://inertiajs.com/" target="_blank" rel="noopener"> Inertia.js是一个JavaScript库</a>，它将一个JavaScript前端连接到一个不同的后端，而不需要API。除了Vue，Inertia.js还允许我们连接React和Svelte前端。</p>
<p>因此，我们可以在后端使用Laravel的<a href="https://blog.logrocket.com/laravel-breeze-inertia-react-stack-vs-next-js-gatsby/" target="_blank" rel="noopener">魔法，而不是使用非常复杂的React框架——比如Gatsby和Next.js，以及像Nuxt.js这样的Vue框架——来处理服务器上的数据获取、数据处理和路由。</a></p>
<p>Laravel Livewire承诺提供React和Vue的水疗体验，但没有它们的复杂性。<a href="https://laravel-livewire.com/" target="_blank" rel="noopener"> Livewire组件向服务器发出AJAX调用</a>,虽然响应是HTML，但Livewire并没有用新的HTML重新加载整个页面，而是根据变化改变了DOM。</p>
<h2>设置</h2>
<p>在本文中，我们将讨论使用Jetstream和Breeze的背景。但是，您应该知道，为了使用Livewire或Vue，您不需要使用Jetstream或Breeze。</p>
<p>Vue已经预装在Laravel中，您需要做的就是使用Laravel Mix将Vue组件编译成一个浏览器可用的JavaScript文件。</p>
<p>对于Livewire，我们需要做的就是运行<code>composer require livewire/livewire</code>和<a href="https://laravel-livewire.com/docs/2.x/quickstart" target="_blank" rel="noopener">包括刀片</a>中的指令。然而，在这种情况下，我们将使用Laravel Breeze和Jetstream等初学者工具包提供的脚手架。</p>
<h3>Laravel Livewire</h3>
<p>要使用Jetstream安装Livewire，必须首先通过运行以下命令将Jetstream安装到全新的Laravel安装中:</p>
<pre class="language-php hljs">composer require laravel/jetstream
</pre>
<p>然后，运行<code> php artisan jetstream:install livewire</code>安装与Livewire相关的各种组件。然后，运行<code>php artisan vendor:publish --tag=jetstream-views</code>来发布和使用Livewire的刀片组件，比如输入、模态和按钮。</p>
<p>前端资产仍然需要通过运行<code>npm install &amp;&amp; npm run dev</code>来安装。数据库也需要通过运行<code>php artisan migrate</code>来迁移。</p>
<h3>惯性. js</h3>
<p>要使用Jetstream安装惯性，必须通过运行以下命令将Jetstream安装到新的Laravel安装中:</p>
<p><code>composer require laravel/jetstream</code></p>
<p>惯性可以通过运行<code>php artisan jetstream:install inertia</code>来安装。通过运行<code>npm install &amp;&amp; npm run dev</code>合并前端资产，通过运行<code>php artisan migrate</code>迁移数据库。</p>
<p>要在Jetstream上安装惯性，我们必须先运行<code>composer require laravel/breeze --dev</code>来安装Laravel Breeze。</p>
<p>然后，通过运行以下命令安装Breeze的组件:</p>
<p><code>php artisan breeze:install vue</code></p>
<p>Breeze也为我们提供了使用React的选项，但我们今天不会讨论这个问题。</p>
<p>通过运行<code>npm install &amp;&amp; npm run dev</code>安装并合并前端资产。数据库也需要迁移:<code>php artisan migrate</code>。<code> </code></p>
<h2>创建组件和模板</h2>
<p>惯性处理组件和模板与Livewire非常不同，因为惯性负责帮助PHP后端与JavaScript前端“对话”,而Livewire扩展了Laravel中已经可用的功能。</p>
<p>例如，让我们考虑一个简单的计数器特性，每次单击一个按钮，我们都需要增加1。</p>
<p>在Livewire中，我们创建了一个<code>Counter </code>组件，在那里我们初始化了我们的<code>$count </code>属性，并有一个加载视图的<code>render() </code>方法。</p>
<pre class="language-php hljs">&lt;?php

use Livewire\Component;

class Counter extends Component
{
    public $count = 0;

    public function render()
    {
        return view('livewire.counter');
    }


    public function increment()
    {
        $this-&gt;count++;
    }
}
</pre>
<p>然后，我们将Livewire嵌入到我们的视图中，在我们的刀片文件中包含这一行:<code>@livewire('counter')</code>。有了<code>wire:click </code>指令，我们就可以绑定<code>click </code>事件，这样每当前端触发事件时，我们就可以在后端运行该方法。</p>
<pre class="language-php hljs">&lt;div&gt;
    &lt;button wire:click="increment"&gt;Count&lt;/button&gt;
    &lt;span&gt;{{ $count }}&lt;/span&gt;
&lt;/div&gt;
</pre>
<p>我们不必编写一行JavaScript就能获得交互式组件，这一事实对许多不喜欢编写前端代码的PHP开发人员来说非常有吸引力。Livewire开发人员还可以继续使用Blade，并访问它的所有指令和功能。</p>
<p>对于不介意钻研JavaScript领域的Laravel开发人员来说，惯性使得创建JavaScript SPAs变得非常简单。在后端，我们可以通过控制器/路由以及方法和助手函数的使用将数据发送到前端。在下面的例子中，我们有我们的<code>CounterController</code>，它有一个保存我们的增量值和我们的<code>increment() </code>方法的<code>$counter </code>属性。</p>
<pre class="language-php hljs">&lt;?php

namespace app\Http\Controllers;

use Illuminate\Http\Request;
use Inertia\Inertia;

class CounterController extends Controller
{
    public $counter = 1;

    public function index(){
        return Inertia::render('Home/Index', [
            'counter' =&gt; $this-&gt;counter,
        ]);
    }

    public function increment(Request $request){
        $count = $this-&gt;counter + $request-&gt;count;
      return Redirect::route('home', ['counter' =&gt; $count]);
    }
}
</pre>
<p>在我们前进之前，让我们把它放在那里，有一个与后端对话的计数器应用程序将是多余的。Vue已经有了自己完成这项工作的工具。但是出于演示的目的，你会在下面看到两个按钮:一个通过Vue单独递增，另一个在惯性和我们后端的帮助下递增。</p>
<pre class="language-javascript hljs">&lt;template&gt;
    &lt;button @click="count++"&gt;Via Vue: {{count}}&lt;/button&gt;&lt;br&gt;
    &lt;button @click="countup"&gt;Via Inertia: {{total}}&lt;/button&gt;
&lt;/template&gt;
&lt;script&gt;
export default {
    data(){
        return {
            count: 0,
            vuecount: 0, 
            total: this.total
        }
    },
    computed: {
        total() {
            this.vuecount = this.vuecount + this.$page.props.counter
            return this.vuecount
        }
    },
    methods: {
        countup() {
            this.$inertia.post('/counter', {count: this.vuecount})
        }
    }
}
&lt;/script&gt;
</pre>
<h2>访问数据</h2>
<p>在Inertia出现之前，与Vue前端共享数据的唯一方式是通过REST API。现在，当在Inertia和Livewire之间进行选择时，如何在前端共享和访问数据不必成为主要考虑因素。唯一的问题是需要在前端编写更多的代码。</p>
<p>Livewire和Inertia渲染数据的方式有很大的区别。对Livewire的所有请求都呈现在服务器端，而对Inertia的所有请求都呈现在客户端。两者各有利弊。</p>
<p>对于客户端呈现的应用程序，请求被重定向到一个空的HTML文件，JavaScript编译所有内容。这些应用程序通常非常快，但缺点是SEO有时会受到影响(像Google这样的搜索引擎仍然能够抓取JavaScript文件)。</p><div class="code-block code-block-54">
<hr/>
<h3>更多来自LogRocket的精彩文章:</h3>

<hr/></div>
<p>对于服务器端呈现的应用程序，标记和数据在提供给客户端之前在服务器上编译。这是web从一开始就有的工作方式，但问题是这种方式比较慢。</p>
<p>尽管Livewire和Inertia都有它们的弱点，但它们都有解决方案。在Livewire的例子中，组件可以在第一次渲染后被缓存。对于Inertia.js，目前正在构建一个SSR解决方案<a href="https://inertiajs.com/server-side-rendering" target="_blank" rel="noopener"/>，其中页面将在第一次加载时在服务器端呈现，但后续请求在客户端完成。</p>
<h2>反应性处理</h2>
<p>反应性描述了现代应用程序基于用户交互动态变化的方式。Livewire和Vue处理反应非常不同。</p>
<p>Vue通过跟踪特定变量的变化并重新呈现DOM受影响的部分来处理反应。创建Vue组件时，您定义了Vue要跟踪的变量(反应数据)。这里有一个只有一个反应变量的例子，<code>message.</code></p>
<pre class="language-javascript hljs">&lt;template&gt;
    &lt;h2&gt;{{message}}&lt;/h2&gt;
&lt;/template&gt;
&lt;script&gt;
export default {
    data() {
        return {
            message: "Hello World!"
        }
    }
}
&lt;/script&gt;
</pre>
<p>在上面的例子中，Vue跟踪对我们的示例消息所做的每一个更改，并将适当地更新<code>h2</code>。这些更新发生在客户端——它不需要与后端交互，因为该组件的状态存在于浏览器中。</p>
<p>然而，有时浏览器中的状态需要与数据库中的数据同步，在这种情况下，AJAX将更新前端和后端，使它们彼此同步。问题是，如果发生了一些事情，更新失败，导致前端和后端不同步，问题可能会出现。</p>
<p>相比之下，Livewire组件的状态驻留在服务器上。同样，这也有利有弊。</p>
<pre class="language-php hljs">&lt;?php
namespace App\Http\Livewire;

use Livewire\Component;

class HelloWorld extends Component
{
    public $message = "Hello World";


    public function render() {
        return &lt;&lt;&lt;'blade'
            &lt;div&gt;
                {{message}}


            &lt;/div&gt;
        blade;
    }
}
?&gt;
</pre>
<p>对于上面这样的简单组件，状态存储在服务器上没有任何影响。然而，对于基于用户交互频繁更新的动态组件，必须发出几个AJAX请求来更新服务器中的状态。</p>
<p>这可能会导致一些性能问题。Livewire的开发者提出，为了解决这个问题，开发者可以<a href="https://laravel-livewire.com/docs/2.x/dirty-states" target="_blank" rel="noopener">使用“脏状态”</a>。</p>
<h2>结论</h2>
<p>在本指南中，我们探讨了Livewire和Vue之间的差异，并强调了它们的亮点和不足。</p>
<p>公平地说，目前，您对框架的选择主要取决于您是否喜欢使用JavaScript。在大多数用例中，Livewire提供了与JavaScript应用相同的能力和活力。</p>
<p>Vue已经为反应性而建立，但Livewire生活在浏览器上，所以如果你想在不如Google先进的搜索引擎上，SEO不会是问题。Laravel的开发者被选择宠坏了。</p><div class="code-block code-block-20">
<div class="blog-plug inline-plug vue-inline"><h2>像用户一样体验您的Vue应用</h2><p>调试Vue.js应用程序可能会很困难，尤其是当用户会话期间有几十个(如果不是几百个)突变时。如果您对监视和跟踪生产中所有用户的Vue突变感兴趣，</p><a href="https://lp.logrocket.com/blg/vue-signup" target="_blank">try LogRocket</a><p>. </p><a class="signup" href="https://lp.logrocket.com/blg/vue-signup" target="_blank" rel="noopener noreferrer"><img class="alignnone size-full wp-image-46 jetpack-lazy-image" src="../Images/0d269845910c723dd7df26adab9289cb.png" alt="LogRocket Dashboard Free Trial Banner" data-lazy-src="https://files.readme.io/00591d0-687474703a2f2f692e696d6775722e636f6d2f6a3049327856572e706e67.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://files.readme.io/00591d0-687474703a2f2f692e696d6775722e636f6d2f6a3049327856572e706e67.png"/><noscript><img data-lazy-fallback="1" class="alignnone size-full wp-image-46" src="../Images/0d269845910c723dd7df26adab9289cb.png" alt="LogRocket Dashboard Free Trial Banner" data-original-src="https://files.readme.io/00591d0-687474703a2f2f692e696d6775722e636f6d2f6a3049327856572e706e67.png"/></noscript></a><a href="https://lp.logrocket.com/blg/vue-signup" target="_blank" rel="noopener noreferrer">https://logrocket.com/signup/</a><p>LogRocket 就像是网络和移动应用程序的DVR，记录你的Vue应用程序中发生的一切，包括网络请求、JavaScript错误、性能问题等等。您可以汇总并报告问题发生时应用程序的状态，而不是猜测问题发生的原因。</p><p>LogRocket Vuex插件将Vuex突变记录到LogRocket控制台，为您提供导致错误的环境，以及出现问题时应用程序的状态。</p><p>现代化您调试Vue应用的方式- <a class="signup" href="https://lp.logrocket.com/blg/vue-signup" target="_blank" rel="noopener noreferrer">开始免费监控</a>。</p></div>


</div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
# Go generics:过去的设计和现在的发布特性

> 原文：<https://blog.logrocket.com/go-generics-past-designs-present-release-features/>

***编者按:**本帖于 2022 年 6 月 10 日更新，包含了 Go v1.18 版本中关于仿制药的信息。*

泛型编程在其他编程语言中也被称为参数多态性。这是通过编写支持多种类型参数的“公共函数”来减少函数重复的一种方式。

在这种情况下，类型参数可以被去掉，或者更好的是被隔离，函数仍然可以运行，不管我们传递的类型参数是什么。

作为 Go 编程语言的一个特性，泛型并没有包含在最初的发布版本(Go1.x)中，也没有包含在语言的设计中。

然而，在 Go 社区中通过提案草案和设计文档进行了大量的辩论之后——以及核心团队和贡献者的辛勤工作——对泛型的支持现在已经在今年早些时候的 [Go v1.18 版本](https://tip.golang.org/doc/go1.18)中被添加到语言核心中。

记住这一点，在这篇文章中，我们将讨论:

在我们开始之前，读者必须了解 Go 编程语言的基础。具体来说，读者要了解 Go 类型系统，包括类型断言和类型推断，以及[接口及其在 Go 程序](https://blog.logrocket.com/exploring-structs-and-interfaces-in-go/)中的用法。

## 什么是 Go 泛型？

每一种静态类型语言都有某种形式的泛型。泛型为我们提供了一种在 Go 代码中表达类型约束的新方法。Go 中泛型的总体目的是避免样板代码或逻辑重复。

Go 的作者不得不在像 Go 这样为网络系统软件设计的编程语言中权衡泛型的利弊。结果，他们最初选择了退出[特性，比如并发](https://blog.logrocket.com/concurrency-patterns-golang-waitgroups-goroutines/)，可伸缩构建，等等。

向 Go 中添加泛型的目的是为了能够编写能够在任意类型或值上工作或操作的库或函数。因此，该语言应该能够显式地记录类型参数的约束。

Go 中对泛型的另一个常见要求是编写编译时类型安全容器的能力。

总之，我们的目标是支持编写 Go 库，通过允许类型参数的参数多态来抽象掉不必要的类型细节。

### 问题案例:在 Go 中的泛型之前

Go 的一个显著特点是它的接口方法，这也是针对代码重用的。具体来说，接口使得编写算法的抽象实现成为可能。

通过使用空的接口类型，Go 已经支持了一种形式的泛型编程。例如，我们可以通过使用带有类型断言和类型开关的空接口类型来编写一个适用于不同片类型的函数。

空接口类型让我们通过类型开关和类型断言来捕获不同的类型。我们可以编写使用这些接口类型的函数，这些函数将适用于我们作为参数传递的任何类型。

但是这种方法不支持代码重用。对于接口，我们必须为我们想要支持的每种类型编写开关用例。然后，我们必须利用类型断言和 case 语句，根据我们想要支持的类型进行检查。

例如，要反转任何元素类型的切片，我们可以传递一个空接口作为参数，并利用类型断言，我们可以在调用函数时获得作为参数传递的类型。

让我们看看下面一个非泛型函数的快速示例:

```
func Sum(args …int) int {
  var sum int
  for i := 0; i < len(args); i++ {
    sum += args[i]
  }
  return sum
}

```

如果我们打算为一个 **int32** 或一个 **int64** 数据类型实现同样的特性，会发生什么呢？见下文:

```
func SumInt64(args ...int64) int64 {
        var sum int64
        for i := 0; i < len(args); i++ {
                sum += args[i]
        }
        return sum
}

```

我们需要实现单独的函数来处理每种数据类型。随着泛型的发布，这已经不再需要了。

### Go 泛型简史:从提案草案到设计

根据 2019 年的一篇官方 Go 博客文章[，泛型支持一直是该语言中需要解决的首要问题之一。](https://blog.golang.org/why-generics)

Go generics 的[初始设计草案，在过去的几年中经过了几次改进和更新，引入了`contracts`。`contracts`的目的是验证一个函数的一组类型参数，以及在这些类型上可以调用什么方法。](https://go.googlesource.com/proposal/+/master/design/go2draft-generics-overview.md#draft-design)

设计草案引入了命名契约的概念，契约就像一个函数体，说明了类型必须支持的操作。

总之，目标是实现能够约束可能使用的类型。草稿中的一个示例显示了如何声明类型`T`的值必须是可比较的:

```
contract Equal(t T) {
        t == t
}

```

然后，为了要求一个契约，我们在类型参数列表后给出它的名称:

```
type Set(type T Equal) []T

```

最后，在函数签名中使用已定义的`contract`:

```
// Find returns the index of x in the set s,
// or -1 if x is not contained in s.
func (s Set(T)) Find(x T) int {
        for i, v := range s {
                if v == x {
                        return i
                }
        }
        return -1
}

```

在上面的函数定义中，我们可以看到我们正在使用已定义的契约，它指定了类型必须是可比较的。

合同设计草案概述如下:

*   函数和类型可以有类型参数，这些参数是使用可选契约定义的
*   契约描述类型参数所需的方法和允许的内置类型
*   协定描述了类型参数允许的方法和操作
*   当调用带有类型参数的函数时，类型推断通常允许省略类型参数

你可以在 Russ Cox 的一篇文章中读到更多关于早期设计草案的内容，在这篇文章中，他广泛地讨论和实验了契约的概念。

### 为什么 Go 泛型的设计草案改变了

契约的问题在于它的设计似乎给语言带来了更多的复杂性。

根据 2019 年的一份[设计草案，由于类型列表只出现在契约中，而不是接口类型上，许多人很难理解这种差异。因此，Go 团队完全放弃了契约的想法。](https://github.com/golang/proposal/blob/master/design/go2draft-contracts.md)

相反，该团队简化了他们的方法，只使用接口类型，因为它也证明了契约可以表示为一组接口。

### 今天去泛型:有界类型参数

添加泛型编程到 Go 的[类型参数建议强调可选的类型参数或参数化类型。以下是这个被提议和接受的设计的概要:](https://go.googlesource.com/proposal/+/refs/heads/master/design/43651-type-parameters.md)

*   类型参数是使用约束定义的
*   接口类型充当类型参数的约束
*   使用接口类型，我们可以添加额外的类型来帮助限制满足给定约束的类型集。
*   函数和类型参数可以使用运算符，但是，满足参数约束的所有类型都必须允许这样做。
*   通过类型推断，可以在函数调用中省略类型参数。
*   泛型实现尊重 Go 1.x 向后兼容的承诺

在 Go 中增加泛型的语法之前，我们在 Go 中编写的每个函数都只能应用于特定的类型。

例如，不可能编写一个简单的`copy`函数来操作任何容器类型，例如`map`。我们必须为不同的目标类型编写不同的函数，除了类型之外，它们的签名几乎相同。

随着 Go 中泛型编程的发布，我们现在可以编写一个适用于整数和浮点类型的`min()`函数，而不必基于类型显式地编写它们。

Go 泛型设计基本上允许类型和函数声明具有可选的类型参数。类型参数由显式定义的结构约束来限定。

## Go 中的一般语法

让我们探索一下 Go 1.18 中泛型的一些[特性。](https://blog.logrocket.com/understanding-generics-go-1-18/)

### 函数可以有可选的类型参数

先说关键词`type`——也就是`func Add\[T any\](a, b T) T`。下面的示例显示了泛型编程中允许的函数类型:

```
func Sum[T int](args ...T) T {
        var sum T
        for i := 0; i < len(args); i++ {
                sum += args[i]
        }
        return sum
}

```

从上面的泛型函数可以看出，`[T int]`代表了在 Go 中编写泛型代码的基本语法。`T`是泛型类型，`int`是对该类型的约束。约束通过指定允许的类型参数来确保类型安全。

这里的挑战在于应该如何声明类型参数，因为每个标识符都必须以某种方式声明。解决方法是类型参数类似于普通的非类型函数参数，因此应该与其他参数一起列出。

这些类型参数(区别于非类型参数)可以由常规参数使用，也可以在函数体中使用。

### 类型可以有一个类型参数列表

在函数`Print`中，标识符`T`是一个类型参数:一个当前未知的类型，但是当函数被调用时就会知道。此参数列表出现在常规参数之前。

```
func Print(T int | int64)(args ...T) T{
        // same as above
}

```

由于`Print`有一个类型参数，任何对`Print`的调用都必须提供一个类型参数。

```
func main() {
        fmt.Println(Sum([]int{1, 2, 3}...))
        fmt.Println(Sum([]int64{1, 2, 3}...))
}

```

类型参数作为单独的参数列表传递。

### 每个类型参数都可以有一个可选的类型约束

如果一个泛型函数没有为类型参数指定约束，就像上面的`Print`方法一样，那么任何类型参数都是允许的。

泛型函数可以对该类型参数的值使用的唯一操作是那些允许对任何类型的值使用的操作。任何类型允许的操作有:

*   声明这些类型的变量
*   将相同类型的其他值赋给这些变量
*   将这些变量传递给函数或者从函数中返回它们
*   获取这些变量的地址
*   将这些类型的值转换或赋给类型`interface{}`，等等

在定义约束时，Go 已经有了一个非常接近约束所需的结构:接口类型。在这个新的设计中，约束相当于接口类型。

约束是函数参数必须满足的接口类型。在我们有太多约束的情况下，我们可以使用`any`关键字或将我们的类型约束抽象为接口类型。

此外，编写泛型函数就像使用接口类型的值:泛型代码只能使用约束允许的操作(或任何类型都允许的操作)。

下面是另一个约束示例:

```
type Sumable interface {
        int | int64 | uint32
}

```

虽然泛型函数不需要使用约束，但它们可以作为元类型列在类型参数列表中。

```
func Sum\[T Sumable\](args ...T) T {
        var sum T
        for i := 0; i < len(args); i++ {
                sum += args[i]
        }
         return sum
}

```

## `any`约束

`any`约束相当于一个空接口类型**接口** {}。这样做的问题是，一个空的**接口** {}没有告诉我们任何关于数据的信息，它不太安全，并且需要太多的错误处理。请参见下面没有类型断言的示例:

```
func Sum\[T any\](args ...T) T {
        var sum T
        for i := 0; i < len(args); i++ {
                sum += args[i]
        }
        return sum
 }

```

注意:上面的程序编译时会出错，因为编译器不知道任何关于`T`的事情，也不知道它是否支持加法运算符。

## Go 泛型中的自定义类型

Go generics 包括对自定义类型参数的支持:

```
type CustomIntType int
func main() {
        fmt.Println(Sum([]CustomIntType{1, 2, 3}...))
}

```

请注意，每个类型参数可能有自己的约束。没有约束的类型参数必须具有空`interface{}`类型的约束。

此外，单个约束可用于多个类型参数。但是，该约束分别应用于每个类型参数。

## 使用 Go 泛型的函数示例

今天让我们回顾一些例子，看看如何在 Go 中编写一个泛型函数。

### 对任何类型的切片进行排序

```
// import the constraint package
func sortSlice\[T constraints.Ordered\](s []T) {
    sort.Slice(s, func(i, j int) bool {
        return s[i] < s[j]
    })
 }

 stringSlice := []string{"o", "a", "b"}
 sortSlice(stringSlice)

 fmt.Println(stringSlice) //[a b o]

intSlice := []int{0, 3, 2, 1, 6}
sortSlice(intSlice)
fmt.Println(intSlice) // [0 1 2 3 6]

```

`Ordered`约束允许任何有序类型；即支持小于`<`、小于等于`<=`、大于等于`>=`或大于`>`的运算符的任何类型。

### 检查切片是否包含值

正如我们在下面的例子中看到的，调用一个泛型函数看起来就像调用任何其他函数一样:

```
func contains\[T comparable\](elems []T, v T) bool {
    for _, s := range elems {
        if v == s {
            return true
        }
    }
    return false
}
func main() {
    fmt.Println(contains([]string{“e”,”f”, “g”}, “f”)) // true
    fmt.Println(contains([]int{5, 6, 7}, 8)) // false 
}  

```

在像 Python 或 JavaScript 这样的动态类型语言中，我们可以简单地编写函数，而不必费心指定元素类型。这在 Go 中不起作用，因为它是静态类型的，需要我们写下切片和切片元素的确切类型。

最后，泛型使得只需编写一次函数就可以随处使用变得更加容易。处理特定数据类型的函数，如`copy`或`string`数据类型，可以通用化，也可以用于`map`类型。它们甚至可以扩展到用户定义的数据类型。

## 为什么我们需要 Go 泛型

泛型编程支持以泛型形式表示算法和数据结构，并分解出代码的具体元素(如类型)。

Go 中的泛型包含了上面的定义，也包含了一种从函数定义和数据结构中抽象出类型的编程风格。你可能知道我们也可以用 Go 中的`interfaces`和`type assertions`来做这件事，但是我们必须为所有类型编写相同的方法。

这里的想法是能够分解出元素类型。这将允许我们编写一次函数，编写一次测试，然后将它们打包成一个包。然后，我们可以重用一个高效的、完全调试好的实现，它可以在任何时候为任何值类型工作。

## 什么时候在 Go 中使用泛型

如果您正在努力实现一个需要不同数据类型的单一行为的解决方案，那么您应该使用 Go 泛型。这意味着您希望为所有不同的数据类型定义一组行为或方法，以便以多态的方式存储或传递。

如果您在不打算进行一些数据验证或使用任何封送或反封送操作的情况下使用空接口类型，Go 泛型也很有用。

最后，在编写操作容器类型(如地图、切片、通道或任何其他通用数据结构)的函数时，使用 Go 泛型。

## Go 中何时不使用泛型

在对类型参数调用方法时，不应使用 Go 泛型。相反，使用接口类型；例如，替换`io.Reader`和`io.Writer`接口类型

此外，Go 中的方法集有不同的实现，这意味着在这种情况下泛型将是错误的选择。

最后，当对每种类型执行不同的操作时，不要使用 Go 泛型，即使是在方法集中。在这种情况下，[使用 Go 的反射 API 代替](https://blog.logrocket.com/reflection-go-use-cases-tutorial/)，在 JSON 编解码包(`decode.go`)文件中可以找到。

## 结论

通用数据结构和算法提供了许多优势，包括灵活性和代码可重用性，通过实用函数或编写算法，然后可以应用于不同类型的参数。

泛型使 Go 更安全、使用更高效、功能更强大。这将允许我们将许多问题实现为适用于不同类型的函数，并使用之前调试、优化和高效的包或库，从而允许更大的可伸缩性和更容易地处理不断增长的代码库。

感谢阅读。如果您有任何问题、意见或贡献，请不要犹豫，在下面的评论区联系我们，或者，您可以在 [Twitter](https://www.twitter.com/alex_nnakwue) 上给我发消息。
<html>
<head>
<title>How to reduce Docker Image sizes using multi-stage builds - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>如何使用多阶段构建减少Docker图像大小</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/reduce-docker-image-sizes-using-multi-stage-builds/#0001-01-01">https://blog.logrocket.com/reduce-docker-image-sizes-using-multi-stage-builds/#0001-01-01</a></blockquote><div><article class="article-post">
<h2>介绍</h2>
<p>Docker 是当今企业最重要的技术之一。大多数科技公司都在使用Docker来改善其产品和服务的部署策略，使其变得强大和可扩展。在本文中，我们将探讨高效编写Dockerfiles以减小最终图像大小的最有前途的特性之一。但是首先，让我们了解一下Docker。</p>
<h2>Docker是什么？</h2>
<p>Docker 是应用程序的容器化，类似于虚拟机，但非常轻量级(阅读关于<a href="https://nickjanetakis.com/blog/comparing-virtual-machines-vs-docker-containers" target="_blank" rel="noopener noreferrer"> Docker vs虚拟机</a>的完整文章)。Docker是一个通过使用独立于操作系统的容器来轻松创建、部署和运行应用程序的工具。</p>
<p>一个<strong>容器</strong>将应用服务或功能与所有的库、配置文件、依赖项和其他必要的操作部分打包在一起。每个容器共享一个底层操作系统的服务。</p>
<h2 id="what-are-docker-images">这些Docker图像是什么？</h2>
<p>Docker映像是一组写在名为<code>Dockerfile</code>的文件中的指令。这些指令充当Docker中的多层文件系统。当Docker用户运行图像时，它会生成一个或多个容器。</p>
<p>我们也可以说Docker映像是不可变的文件，基本上是容器的快照。我们可以从单个Docker映像中创建<em> n </em>个容器，类似于从单个类中创建<em> n </em>个对象实例(共享共同的特征和行为)的概念。</p>
<p>就像我前面说过的，Dockerfile包含一组指令，充当多层文件系统。docker文件中的指令越多(例如<code>RUN</code>、<code>COPY</code>、<code>ADD</code>)，图像的最终大小就越大。还有许多其他因素会增加映像的大小，如上下文、基本映像、不必要的依赖项、包和一些指令。</p>
<h2>为什么要缩小Docker图片的尺寸？</h2>
<p>在这个内存和存储相对便宜的现代技术时代，我们为什么需要减小Docker图像的大小呢？</p>
<p>通过减小Docker图像的大小，我们只保留最终图像中所需的伪影，并删除所有不必要的数据。这也是必要的，因为:</p>
<ul>
<li>首先也是最重要的是<a href="https://docs.docker.com/develop/develop-images/dockerfile_best-practices/" target="_blank" rel="noopener noreferrer">最佳实践</a></li>
<li>在映像中安装和保留不必要的依赖项会增加应用程序的复杂性和易受攻击性</li>
<li>下载和生成容器将花费大量时间</li>
<li>创建映像并将其推送到注册表也将花费大量时间，最终会阻塞我们的CI/CD管道</li>
<li>有时，由于构建上下文，我们最终会将密钥和秘密留在docker文件中</li>
<li>为了使容器不可变(是的，你没看错)，我们甚至不能在最终容器中编辑文件。这就是我们使用CoreOS实例的原因</li>
</ul>
<h2>如何缩小Docker图像的大小</h2>
<p>减少Docker图像是我们应该知道如何做的事情，以保持我们的应用程序安全，并坚持正确的行业标准和准则。</p>
<p>有很多方法可以做到这一点，包括:</p>
<ul>
<li>使用. dockerignore文件从生成上下文中移除不必要的内容</li>
<li>尽量避免安装不必要的包和依赖项</li>
<li>保持图像中的图层最少</li>
<li>尽可能使用阿尔卑斯山的图片</li>
<li>使用多阶段构建，这是我将在本文中讨论的。</li>
</ul>
<p>让我们转到<strong>多阶段构建</strong>🤘</p>
<h2>Docker中的多阶段构建</h2>
<p>Docker中的多阶段构建是在<a href="https://docs.docker.com/develop/develop-images/multistage-build/" target="_blank" rel="noopener noreferrer"> Docker 17.05 </a>中引入的新功能。这是一种减小图像大小、更好地组织Docker命令、提高性能同时保持Docker文件易于阅读和理解的方法。</p>
<p>多阶段构建是将Dockerfile划分为多个阶段，以将所需的工件从一个阶段传递到另一个阶段，并最终在最后一个阶段交付最终的工件。这样，我们的最终图像将不会有任何不必要的内容，除了我们需要的工件。</p>
<p>以前，当我们没有多阶段构建功能时，很难最小化图像大小。我们过去常常在进入下一个指令之前清理每个工件(这不是必需的),因为Dockerfile中的每个指令都会将层添加到图像中。我们还曾经编写bash/shell脚本并应用hacks来删除不必要的工件。</p>
<p>让我们看一个例子:</p>
<p><a href="https://carbon.now.sh/?bg=rgba%28171%2C%20184%2C%20195%2C%201%29&amp;t=dracula&amp;wt=none&amp;l=dockerfile&amp;ds=true&amp;dsyoff=20px&amp;dsblur=68px&amp;wc=true&amp;wa=true&amp;pv=56px&amp;ph=56px&amp;ln=false&amp;fm=Hack&amp;fs=14px&amp;lh=133%25&amp;si=false&amp;es=2x&amp;wm=false&amp;code=RUN%2520wget%2520http%253A%252F%252Fxyz.com%252Fabc.tar.gz%2520%2526%2526%2520%255C%250A%2520%2520%2520%2520tar%2520zxf%2520abc.tar.gz%2520%2526%2526%2520%255C%250A%2520%2520%2520%2520cd%2520abc%2520%2526%2526%2520%255C%250A%2520%2520%2520%2520make%2520DESTDIR%253D%252Ftmp%2520install%2520%2526%2526%2520%255C%250A%2520%2520%2520%2520cd%2520..%252F%2520%2526%2526%2520%255C%250A%2520%2520%2520%2520rm%2520-rf%2520abc*" target="_blank" rel="noopener noreferrer"> <img data-attachment-id="4394" data-permalink="https://blog.logrocket.com/reduce-docker-image-sizes-using-multi-stage-builds/runimagedocker/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2019/08/runimagedocker.png" data-orig-size="958,590" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="runimagedocker" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2019/08/runimagedocker-300x185.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2019/08/runimagedocker.png" decoding="async" class="aligncenter wp-image-4394 size-full jetpack-lazy-image" src="../Images/264152ccd3fc33b0b0449d0b6841f780.png" alt="" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2019/08/runimagedocker.png 958w, https://blog.logrocket.com/wp-content/uploads/2019/08/runimagedocker-300x185.png 300w, https://blog.logrocket.com/wp-content/uploads/2019/08/runimagedocker-768x473.png 768w" data-lazy-sizes="(max-width: 958px) 100vw, 958px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2019/08/runimagedocker.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/08/runimagedocker.png"/> <noscript> <img data-lazy-fallback="1" data-attachment-id="4394" data-permalink="https://blog.logrocket.com/reduce-docker-image-sizes-using-multi-stage-builds/runimagedocker/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2019/08/runimagedocker.png" data-orig-size="958,590" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="runimagedocker" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2019/08/runimagedocker-300x185.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2019/08/runimagedocker.png" decoding="async" loading="lazy" class="aligncenter wp-image-4394 size-full" src="../Images/264152ccd3fc33b0b0449d0b6841f780.png" alt="" srcset="https://blog.logrocket.com/wp-content/uploads/2019/08/runimagedocker.png 958w, https://blog.logrocket.com/wp-content/uploads/2019/08/runimagedocker-300x185.png 300w, https://blog.logrocket.com/wp-content/uploads/2019/08/runimagedocker-768x473.png 768w" sizes="(max-width: 958px) 100vw, 958px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/08/runimagedocker.png"/> </noscript></a></p>
<p>这只是Dockerfile中的一条指令，我们需要从某个<a href="https://gen.xyz/" target="_blank" rel="noopener noreferrer"> <code>http://xyz.com</code> </a>网站下载<code>abc.tar.gz</code>文件，提取内容并运行<code>make install</code>。</p>
<p>在同一条指令中，我们将<code>make install</code>命令的内容存储到<code>/tmp</code>目录中，并删除剩余的数据，如下载的<code>tar</code>文件和提取的<code>tar</code>内容，这样我们就可以只拥有<code>make install</code>命令的内容，这是我们进一步处理所需要的。</p>
<p>这就是我们在一条指令中要做的所有事情，以减小最终图像的尺寸。现在我们可以想象一下Dockerfile对于<em> n </em>条指令的复杂性。</p>
<p>哦，等等..等待..等待..！！！现在我们有了多阶段构建的能力，可以在不影响power文件可读性的情况下减小图像的大小。</p>
<p>让我们看看使用多阶段构建的同一个示例:</p>
<p><a href="https://carbon.now.sh/?bg=rgba%28171%2C%20184%2C%20195%2C%201%29&amp;t=dracula&amp;wt=none&amp;l=dockerfile&amp;ds=true&amp;dsyoff=20px&amp;dsblur=68px&amp;wc=true&amp;wa=true&amp;pv=56px&amp;ph=56px&amp;ln=false&amp;fm=Hack&amp;fs=14px&amp;lh=133%25&amp;si=false&amp;es=2x&amp;wm=false&amp;code=%2523%2520Base%2520image%2520Stage%25201%250AFROM%2520ubuntu%253A16.04%2520as%2520stage1%250A%250ARUN%2520apt-get%2520update%250ARUN%2520apt-get%2520-y%2520install%2520make%2520curl%250ARUN%2520curl%2520http%253A%252F%252Fxyz.com%252Fabc.tar.gz%2520-O%250ARUN%2520tar%2520zxf%2520abc.tar.gz%2520%2526%2526%2520cd%2520abc%250ARUN%2520make%2520DESTDIR%253D%252Ftmp%2520install%250A%250A%2523%2520Stage%25202%250AFROM%2520alpine%253A3.10%250A%250ACOPY%2520--from%253Dstage1%2520%252Ftmp%2520%252Fabc%250A%250AENTRYPOINT%2520%255B%2522%252Fabc%252Fapp%2522%255D" target="_blank" rel="noopener noreferrer"> <img data-attachment-id="4398" data-permalink="https://blog.logrocket.com/reduce-docker-image-sizes-using-multi-stage-builds/multistagedockerinstructions/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2019/08/multistagedockerinstructions.png" data-orig-size="512,506" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="multistagedockerinstructions" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2019/08/multistagedockerinstructions-300x296.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2019/08/multistagedockerinstructions.png" decoding="async" class="aligncenter wp-image-4398 size-full jetpack-lazy-image" src="../Images/0d1a5d6f6fc140e3317f78d9b4d9a818.png" alt="" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2019/08/multistagedockerinstructions.png 512w, https://blog.logrocket.com/wp-content/uploads/2019/08/multistagedockerinstructions-300x296.png 300w" data-lazy-sizes="(max-width: 512px) 100vw, 512px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2019/08/multistagedockerinstructions.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/08/multistagedockerinstructions.png"/> <noscript> <img data-lazy-fallback="1" data-attachment-id="4398" data-permalink="https://blog.logrocket.com/reduce-docker-image-sizes-using-multi-stage-builds/multistagedockerinstructions/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2019/08/multistagedockerinstructions.png" data-orig-size="512,506" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="multistagedockerinstructions" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2019/08/multistagedockerinstructions-300x296.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2019/08/multistagedockerinstructions.png" decoding="async" loading="lazy" class="aligncenter wp-image-4398 size-full" src="../Images/0d1a5d6f6fc140e3317f78d9b4d9a818.png" alt="" srcset="https://blog.logrocket.com/wp-content/uploads/2019/08/multistagedockerinstructions.png 512w, https://blog.logrocket.com/wp-content/uploads/2019/08/multistagedockerinstructions-300x296.png 300w" sizes="(max-width: 512px) 100vw, 512px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/08/multistagedockerinstructions.png"/> </noscript></a></p>
<p>在这个docker文件中，我们使用<code>ubuntu:16.04</code>作为基础映像，将这个阶段称为<code>stage1</code>，并执行如下指令:</p>
<ol>
<li>运行<code>apt-get update</code>来更新包</li>
<li>运行<code>apt-get -y install make curl</code>安装make和curl包</li>
<li>我们使用curl从<code><a href="http://xyz.com" rel="nofollow">http://xyz.com</a></code>下载了<code>abc.tar.gz</code>文件</li>
<li>解压缩<code>abc.tar.gz</code>文件，并将目录更改为<code>abc</code></li>
<li>运行<code>make DESTDIR=/tmp install</code>命令，将输出保存到<code>tmp</code>目录</li>
<li>我们没有移除不必要的人工物品，而是创建了另一个阶段，即阶段2，用<code>alpine:3.10</code>作为基础图像，因为它更亮</li>
<li>我们通过简单地运行<code>COPY --from=stage1 /tmp /abc</code>命令，将<code>/tmp</code>目录中的内容从<code>stage1</code>复制到<code>stage2</code>中的<code>/abc</code>目录</li>
<li>最后，我们在<code>Entrypoint</code>中添加了二进制文件的路径来运行它</li>
</ol>
<p>通过这种方式，我们将所需的工件从阶段1复制到阶段2，而没有损害docker文件，并成功地创建了最优化和简化的映像。类似地，我们可以使用多阶段构建来为前端文件创建静态构建，并将静态文件传递到阶段2，在那里我们可以使用nginx基本映像来托管它们，而无需在我们的应用程序中保留大而笨重的<code>node_modules</code>,静态构建后这些文件就没有用了。</p>
<h2>结论</h2>
<p>我们还可以使用外部Docker映像作为一个阶段，也可以在特定的构建阶段停止。它并不总是有用的，因为我们失去了前一阶段的中间容器，所以我们将无法利用Docker中的构建缓存。从<a href="https://docs.docker.com/develop/develop-images/multistage-build/" target="_blank" rel="noopener noreferrer"> Docker官方文档</a>中阅读更多关于多阶段构建的信息。</p>
<p>在本文中，我们研究了Docker是什么，为什么我们需要减少图像的大小，以及我们如何有效地使用多阶段构建来做到这一点。我希望这篇文章能帮助你理解Docker和它的多阶段构建特性。</p>
<p>随便评论，问我什么都行。你可以在<a href="https://twitter.com/ankitjain28may" target="_blank" rel="noopener noreferrer">推特</a>和<a href="https://medium.com/@ankitjain28may" target="_blank" rel="noopener noreferrer">媒体</a>上关注我。感谢阅读！👍</p>
<p> </p>
<p> </p><div class="code-block code-block-2">
<div class="blog-plug base-cta"><h2>使用<a class="signup" href="https://lp.logrocket.com/blg/signup" target="_blank" rel="noopener noreferrer"> LogRocket </a>消除传统错误报告的干扰</h2>
<a href="https://lp.logrocket.com/blg/signup" class="signup" target="_blank" rel="noopener noreferrer"><img class="alignnone size-full wp-image-46 jetpack-lazy-image" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/><noscript><img data-lazy-fallback="1" class="alignnone size-full wp-image-46" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/></noscript></a>
<p><a href="https://lp.logrocket.com/blg/signup" target="_blank" rel="noopener noreferrer"> LogRocket </a>是一个数字体验分析解决方案，它可以保护您免受数百个假阳性错误警报的影响，只针对几个真正重要的项目。LogRocket会告诉您应用程序中实际影响用户的最具影响力的bug和UX问题。</p>
<p>然后，使用具有深层技术遥测的会话重放来确切地查看用户看到了什么以及是什么导致了问题，就像你在他们身后看一样。</p>
<p>LogRocket自动聚合客户端错误、JS异常、前端性能指标和用户交互。然后LogRocket使用机器学习来告诉你哪些问题正在影响大多数用户，并提供你需要修复它的上下文。</p>
<p>关注重要的bug—<a class="signup" href="https://lp.logrocket.com/blg/signup-issue-free" target="_blank" rel="noopener noreferrer">今天就试试LogRocket】。</a></p></div></div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
# 使用 Jest - LogRocket 博客测试 Next.js 应用程序

> 原文：<https://blog.logrocket.com/testing-next-js-apps-jest/>

作为一名开发人员，您知道测试对于任何生产级别的项目有多重要。编写测试需要一些时间，但是从长远来看，它们会帮助你解决代码库中的问题。您还可以将这些测试集成到 GitHub 操作中，这样无论何时您部署到生产环境中或者有人发出 pull 请求，测试都会自动运行，并且您会收到任何失败测试的通知。

Jest 是一款令人惊叹的内置工具，用于测试 React 应用。由于 [Next.js 发布了 v12](https://blog.logrocket.com/whats-new-next-js-12/) ，它也内置了 Jest 配置，由 Rust 编译器提供支持(这是下一个 v12 更新的一个亮点)。

在本教程中，我们将学习如何通过编写一个计算器应用程序的简单测试来设置 Jest 与 Next。我们还将看到当我们模拟测试失败时会发生什么，因此您可以决定 Jest 对于您自己的项目是否足够有效。

### 内容

### 先决条件

*   React 和 Next.js 的工作知识
*   如何测试应用程序的工作知识
*   代码编辑器——我更喜欢 Visual Studio 代码
*   安装在计算机上的 Node.js

如果你在教程的某个地方卡住了，请随意参考 [GitHub 库](https://github.com/atharvadeosthale/jest-tutorial-article)。

## 创建新的 Next.js 应用程序

导航到一个安全的目录，并在终端中输入以下命令来设置新的[下一个应用程序](https://blog.logrocket.com/testing-error-handling-patterns-next-js/):

```
npx create-next-app jest-tutorial

```

您可以用应用程序的任何其他名称替换`jest-tutorial`。安装完成后，在代码编辑器中打开项目，并在终端中运行以下命令来启动开发服务器:

```
npm run dev

```

## 创建计算器

因为我们在这里特别关注测试，所以我们不会讨论计算器是如何工作的。然而，为了让我们测试，这里是计算器的代码。

`pages`目录下`index.js`的内容如下:

```
import Head from "next/head";
import Image from "next/image";
import { useState } from "react";
import styles from "../styles/Home.module.css";
export default function Home() {
  const [num1, setNum1] = useState(0);
  const [num2, setNum2] = useState(0);
  const [result, setResult] = useState(0);
  const add = () => {
    setResult(parseInt(num1) + parseInt(num2));
  };
  const subtract = () => {
    setResult(parseInt(num1) - parseInt(num2));
  };
  const multiply = () => {
    setResult(parseInt(num1) * parseInt(num2));
  };
  const divide = () => {
    setResult(parseInt(num1) / parseInt(num2));
  };
  return (
    <div className={styles.container}>
      <Head>
        <title>Create Next App</title>
        <meta name="description" content="Generated by create next app" />
        <link rel="icon" href="/favicon.ico" />
      </Head>
      <div className={styles.result} data-testid="result">
        {result}
      </div>
      <input
        type="number"
        className={styles.input}
        data-testid="num1"
        value={num1}
        onChange={(e) => setNum1(e.target.value)}
      />
      <input
        type="number"
        className={styles.input}
        data-testid="num2"
        value={num2}
        onChange={(e) => setNum2(e.target.value)}
      />
      <button onClick={add} className={styles.button} data-testid="add">
        Add
      </button>
      <button
        onClick={subtract}
        className={styles.button}
        data-testid="subtract"
      >
        Subtract
      </button>
      <button
        onClick={multiply}
        className={styles.button}
        data-testid="multiply"
      >
        Multiply
      </button>
      <button onClick={divide} className={styles.button} data-testid="divide">
        Divide
      </button>
    </div>
  );
}

```

上面代码中需要注意的一点是添加到元素中的`data-testid`属性，比如结果区域、输入字段和按钮。这个 ID 帮助我们识别测试文件中的特定字段，并在测试时对它们执行操作。这些 id 在生产中不会有任何影响。

以下是`styles`目录下`Home.module.css`的内容:

```
.container {
  padding: 0 2rem;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  height: 100vh;
  background-color: #121212;
  color: white;
}
.result {
  font-size: 4rem;
  font-weight: bold;
  margin-bottom: 1rem;
}
.input {
  margin: 0.5rem 0;
  padding: 0.5rem;
  font-size: large;
  width: 13rem;
  background-color: #121212;
  border: 1px solid #525252;
  color: white;
  border-radius: 10px;
}
.button {
  font-size: large;
  padding: 0.5rem;
  width: 13rem;
  margin: 0.5rem 0;
  border: 1px solid black;
  background-color: black;
  border-radius: 10px;
  color: white;
}

```

现在，当您访问`[http://localhost:3000](http://localhost:3000)`时，您应该会看到我们的计算器启动并运行:

![calculator app](img/5c5203686dfa6ed14a30320ff2a60529.png)

现在，让我们继续使用 Jest 测试这个计算器！

## 设置笑话

要设置 Jest，我们需要安装一些必需的包。在终端中运行以下命令来安装它们:

```
npm install --save-dev jest @testing-library/react @testing-library/jest-dom

```

记住，我们在这里使用`--save-dev`，这意味着这些包包含在我们的`devDependencies`中，不会在生产中使用。

现在，让我们创建一个新文件来存储 Jest 配置。在项目根文件夹中，用以下配置创建一个名为`jest.config.js`的新文件(这些配置来自官方的下一个[文档](https://nextjs.org/docs/testing)):

```
const nextJest = require("next/jest");
const createJestConfig = nextJest({
  dir: "./",
});
const customJestConfig = {
  moduleDirectories: ["node_modules", "<rootDir>/"],
  testEnvironment: "jest-environment-jsdom",
};
module.exports = createJestConfig(customJestConfig);

```

现在，转到`package.json`并添加一个名为`test`的脚本，它运行命令`jest` `--watch`。

您的脚本应该如下所示:

```
"scripts": {
  "dev": "next dev",
  "build": "next build",
  "start": "next start",
  "lint": "next lint",
  "test": "jest --watch"
},

```

现在我们的配置已经准备好了，我们可以继续编写测试了。

## 用 Jest 测试 Next.js 计算器应用程序

在项目根目录中，创建一个名为`tests`的新文件夹，Jest 将使用它来查找测试。然后，创建一个名为`index.test.js`的新文件。

首先，让我们导入一些依赖项:

```
import Home from "../pages/index";
import "@testing-library/jest-dom";
import { fireEvent, render, screen } from "@testing-library/react";

```

我们将从下一个应用程序中直接导入`Home`组件，因为我们将在测试期间渲染它。

现在，让我们编写一个测试，看看是否所有元素都正确呈现:

```
describe("Calculator", () => {
  it("renders a calculator", () => {
    render(<Home />);
    // check if all components are rendered
    expect(screen.getByTestId("result")).toBeInTheDocument();
    expect(screen.getByTestId("num1")).toBeInTheDocument();
    expect(screen.getByTestId("num2")).toBeInTheDocument();
    expect(screen.getByTestId("add")).toBeInTheDocument();
    expect(screen.getByTestId("subtract")).toBeInTheDocument();
    expect(screen.getByTestId("multiply")).toBeInTheDocument();
    expect(screen.getByTestId("divide")).toBeInTheDocument();
  });
});

```

这些测试通常是人类可读的。让我们看看上面的代码发生了什么:

首先，`describe`函数描述了模块是什么。你可以给它取任何你想要的名字；运行测试时，该名称将显示在控制台中。

接下来，`it`函数指定了一个单独的测试。在`describe`中可以有多个`it`。

然后我们呈现出从`pages`目录下的`index.js`导入的`<Home/>`组件。这将模拟一个 DOM 并在其上呈现组件。

下面的`expect`函数检查条件是`true`还是`false`。它的结果告诉你测试的结果。如果这些`expect`语句中的任何一个是`false`，测试将失败，您将在控制台中看到一条错误消息。

最后，我们使用`toBeInTheDocument()`来检查元素是否确实存在于 Jest 创建的 DOM 中。我们在页面中提供了测试 id，所以 Jest 更容易识别这些元素。

现在，您可以运行测试了。在您的终端中使用以下命令:

```
npm run test

```

您应该会看到这样的测试结果:

```
 PASS  __tests__/index.test.js
  Calculator
    ✓ renders a calculator (15 ms)

Test Suites: 1 passed, 1 total
Tests:       1 passed, 1 total
Snapshots:   0 total
Time:        0.554 s, estimated 1 s
Ran all test suites.

Watch Usage: Press w to show more.

```

一旦您运行 test 命令，一旦项目中的任何文件被保存，它就会自动重新运行测试，因此我们不需要终止并重启测试终端。

## 测试计算器操作并模拟错误

现在，让我们创建一个测试来检查数字相加是否正确:

```
it("adds numbers", () => {
  render(<Home />);
  // check if adds properly
  const num1input = screen.getByTestId("num1");
  const num2input = screen.getByTestId("num2");
  const addButton = screen.getByTestId("add");
  const resultArea = screen.getByTestId("result");
  fireEvent.change(num1input, { target: { value: 5 } });
  fireEvent.change(num2input, { target: { value: 8 } });
  addButton.click();
  expect(resultArea).toHaveTextContent("13");
});

```

在上面的代码中，我们模拟了在计算器中打字和按键。我们还提供两个数字相加，并检查计算器提供的结果是否相同。

保存文件后，检查终端，您的测试应该会自动重新运行并提供以下输出:

```
 PASS  __tests__/index.test.js
  Calculator
    ✓ renders a calculator (18 ms)
    ✓ adds numbers (9 ms)

Test Suites: 1 passed, 1 total
Tests:       2 passed, 2 total
Snapshots:   0 total
Time:        0.526 s, estimated 1 s
Ran all test suites.

Watch Usage: Press w to show more.

```

完美！现在，让我们尝试在应用程序中模拟一个错误。首先，我们将对实际的计算器应用程序进行修改，使它不像预期的那样工作。为此，将`index.js`中的`add`功能更改如下:

```
const add = () => {
  setResult(parseInt(num1) - parseInt(num2));
};

```

这里我们改变了函数，使它减去而不是增加。保存文件时，您应该会立即看到一个错误:

```
 FAIL  __tests__/index.test.js
  Calculator
    ✓ renders a calculator (14 ms)
    ✕ adds numbers (13 ms)

  ● Calculator › adds numbers

    expect(element).toHaveTextContent()

    Expected element to have text content:
      13
    Received:
      -3

      28 |     addButton.click();
      29 |
    > 30 |     expect(resultArea).toHaveTextContent("13");
         |                        ^
      31 |   });
      32 | });
      33 |

      at Object.<anonymous> (__tests__/index.test.js:30:24)

Test Suites: 1 failed, 1 total
Tests:       1 failed, 1 passed, 2 total
Snapshots:   0 total
Time:        0.667 s, estimated 1 s
Ran all test suites.

Watch Usage: Press w to show more.

```

Jest 试图添加数字，并没有看到我们预期的数字，这意味着`add`函数存在一些问题。这就是当测试失败时，如何检查代码中的问题。恢复您在`index.js`文件中所做的更改，使内容恢复到原始工作顺序。

现在，让我们再添加几个测试来检查是否所有的操作都运行良好。以下是`index.test.js`的完整代码:

```
import Home from "../pages/index";
import "@testing-library/jest-dom";
import { fireEvent, render, screen } from "@testing-library/react";
describe("Calculator", () => {
  it("renders a calculator", () => {
    render(<Home />);
    // check if all components are rendered
    expect(screen.getByTestId("result")).toBeInTheDocument();
    expect(screen.getByTestId("num1")).toBeInTheDocument();
    expect(screen.getByTestId("num2")).toBeInTheDocument();
    expect(screen.getByTestId("add")).toBeInTheDocument();
    expect(screen.getByTestId("subtract")).toBeInTheDocument();
    expect(screen.getByTestId("multiply")).toBeInTheDocument();
    expect(screen.getByTestId("divide")).toBeInTheDocument();
  });
  it("adds numbers", () => {
    render(<Home />);
    // check if adds properly
    const num1input = screen.getByTestId("num1");
    const num2input = screen.getByTestId("num2");
    const addButton = screen.getByTestId("add");
    const resultArea = screen.getByTestId("result");
    fireEvent.change(num1input, { target: { value: 5 } });
    fireEvent.change(num2input, { target: { value: 8 } });
    addButton.click();
    expect(resultArea).toHaveTextContent("13");
  });
  it("subtracts numbers", () => {
    render(<Home />);
    // check if adds properly
    const num1input = screen.getByTestId("num1");
    const num2input = screen.getByTestId("num2");
    const subtractButton = screen.getByTestId("subtract");
    const resultArea = screen.getByTestId("result");
    fireEvent.change(num1input, { target: { value: 8 } });
    fireEvent.change(num2input, { target: { value: 5 } });
    subtractButton.click();
    expect(resultArea).toHaveTextContent("3");
  });
  it("multiplies numbers", () => {
    render(<Home />);
    // check if adds properly
    const num1input = screen.getByTestId("num1");
    const num2input = screen.getByTestId("num2");
    const multiplyButton = screen.getByTestId("multiply");
    const resultArea = screen.getByTestId("result");
    fireEvent.change(num1input, { target: { value: 5 } });
    fireEvent.change(num2input, { target: { value: 8 } });
    multiplyButton.click();
    expect(resultArea).toHaveTextContent("40");
  });
  it("divides numbers", () => {
    render(<Home />);
    // check if adds properly
    const num1input = screen.getByTestId("num1");
    const num2input = screen.getByTestId("num2");
    const divideButton = screen.getByTestId("divide");
    const resultArea = screen.getByTestId("result");
    fireEvent.change(num1input, { target: { value: 20 } });
    fireEvent.change(num2input, { target: { value: 2 } });
    divideButton.click();
    expect(resultArea).toHaveTextContent("10");
  });
});

```

保存文件后，您应该会看到所有测试都通过了，如下所示:

```
 PASS  __tests__/index.test.js
  Calculator
    ✓ renders a calculator (14 ms)
    ✓ adds numbers (6 ms)
    ✓ subtracts numbers (4 ms)
    ✓ multiplies numbers (4 ms)
    ✓ divides numbers (4 ms)

Test Suites: 1 passed, 1 total
Tests:       5 passed, 5 total
Snapshots:   0 total
Time:        0.674 s, estimated 1 s
Ran all test suites.

Watch Usage: Press w to show more.

```

## 结论

读完这篇文章后，我希望您了解了测试在生产级项目中的重要性。特别是对于大型项目，手动测试会花费很多时间。因此，用 Jest 编写自动化测试是一个很好的解决方案。每次你发布一个特性，当某个测试失败时，你会收到通知，这样你就可以立即进行修复。

## [LogRocket](https://lp.logrocket.com/blg/nextjs-signup) :全面了解生产 Next.js 应用

调试下一个应用程序可能会很困难，尤其是当用户遇到难以重现的问题时。如果您对监视和跟踪状态、自动显示 JavaScript 错误、跟踪缓慢的网络请求和组件加载时间感兴趣，

[try LogRocket](https://lp.logrocket.com/blg/nextjs-signup)

.

[![](img/f300c244a1a1cf916df8b4cb02bec6c6.png)](https://lp.logrocket.com/blg/nextjs-signup)[![LogRocket Dashboard Free Trial Banner](img/d6f5a5dd739296c1dd7aab3d5e77eeb9.png)](https://lp.logrocket.com/blg/nextjs-signup)

LogRocket 就像是网络和移动应用的 DVR，记录下你的 Next.js 应用上发生的一切。您可以汇总并报告问题发生时应用程序的状态，而不是猜测问题发生的原因。LogRocket 还可以监控应用程序的性能，报告客户端 CPU 负载、客户端内存使用等指标。

LogRocket Redux 中间件包为您的用户会话增加了一层额外的可见性。LogRocket 记录 Redux 存储中的所有操作和状态。

让您调试 Next.js 应用的方式现代化— [开始免费监控](https://lp.logrocket.com/blg/nextjs-signup)。
<html>
<head>
<title>Lazy loading components and code splitting in Vue.js - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>Vue.js - LogRocket博客中的延迟加载组件和代码拆分</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/vue-lazy-loading-components-code-splitting/#0001-01-01">https://blog.logrocket.com/vue-lazy-loading-components-code-splitting/#0001-01-01</a></blockquote><div><article class="article-post">
<p><em> <strong>编者按</strong>:这个Vue懒加载教程最后一次更新是在2021年4月29日。</em></p>
<p>在这个Vue延迟加载教程中，我们将演示如何延迟加载Vue.js应用程序中的组件。本演示的目的是帮助您理解Vue.js如何借助webpack代码分割在抽象的路由级别处理延迟加载。</p>
<p>以下是我们将要介绍的内容:</p>

<h2 id="whatisvuejs">Vue.js是什么？</h2>
<p>Vue.js 是一个非常进步的JavaScript框架，由<a href="https://twitter.com/youyuxi?lang=en" target="_blank" rel="noopener noreferrer">尤雨溪</a>和Vue核心团队创建，来自超过<a href="https://github.com/vuejs/vue" target="_blank" rel="noopener noreferrer"> 230个开源社区成员</a>的贡献。在撰写本文时，Vue.js在GitHub 上拥有超过<a href="https://github.com/vuejs/vue" target="_blank" rel="noopener">18.3万颗星。它由一个只关注视图层的可接近的核心库和一个支持库的生态系统组成，旨在帮助您处理大型单页面应用程序中的复杂性。</a></p>
<h2 id="whatislazyloading">Vue.js中的懒加载是什么？</h2>
<p><a href="https://blog.logrocket.com/understanding-lazy-loading-in-javascript/" target="_blank" rel="noopener">惰性加载</a>是一种模式，旨在延迟元素和对象的初始化，直到需要它们的时候。惰性加载意味着相对于父DOM元素的目标DOM元素被加载，并且只有当用户在网页上滚动它们时才变得可见(当两个元素之间有交集时，基于设置的阈值)。</p>
<p>要理解延迟加载，首先必须理解急切加载。急切加载是将JavaScript代码加载到<a href="https://blog.logrocket.com/8-dom-features-you-didnt-know-existed-ec2a0a28fd89/" target="_blank" rel="noopener noreferrer"> DOM </a>的默认方式。对于Vue.js，这意味着使用import语句将一个组件引入到<code>app.vue</code>文件中。延迟加载是指在应用程序启动时，所有的脚本都不会加载到DOM上。相反，它们只在被请求时才被加载，这使得JavaScript包在初始加载时非常小。</p>
<p>Vue.js用routes处理组件的延迟加载，所以在DOM上，只有在需要时才可以通过routes加载组件。这是通过将每个路由的组件分割成独立于初始化时加载的主块的块来实现的。这可以防止发送到DOM的包变得太大。Vue.js结合了<a href="https://vuejs.org/guide/components.html#Async-Components" target="_blank" rel="noopener noreferrer">异步组件特性</a>和<a href="https://webpack.js.org/guides/code-splitting-async/" target="_blank" rel="noopener noreferrer"> webpack的代码分割特性</a>来延迟加载路由组件。</p>
<h2 id="important">为什么说懒加载很重要？</h2>
<p>随着Vue.js项目的规模和复杂性的增长，急切加载的方法使得js包变得非常麻烦。对于可能在移动设备上或没有高速互联网连接的情况下访问您的应用程序的最终用户来说，这可能会成为一个问题。</p>
<p>惰性加载保证您的JavaScript包按照从最需要的组件到最不需要的组件的重要性顺序被提供给DOM。这种方法确保您可以控制用户的整个体验，包括资源加载到DOM时的最初等待时间。</p>
<h2 id="example">Vue.js延迟加载示例</h2>
<p>为了演示Vue.js中的延迟加载，我们将使用<a href="https://cli.vuejs.org/" target="_blank" rel="noopener"> Vue CLI </a>构建一个示例Vue.js应用程序，并在配置阶段添加路由。</p>
<p>我们还将手动添加第三条路线，向不熟悉Vue CLI的开发人员展示该过程。也就是说，使用Vue CLI总是可取的，因为默认情况下，次要路由已经配置为延迟加载。</p>
<h3>启动Vue.js项目</h3>
<p>在您选择的目录中打开一个终端，并使用以下命令创建一个新项目:</p>
<pre>vue create test_project</pre>
<p>你会看到这样一份后续调查问卷:</p>
<pre>? Please pick a preset: Manually select features
? Check the features needed for your project: 
 ◉ Babel
 ◯ TypeScript
 ◯ Progressive Web App (PWA) Support
❯◉ Router
 ◯ Vuex
 ◯ CSS Pre-processors
 ◉ Linter / Formatter
 ◯ Unit Testing
 ◯ E2E Testing</pre>
<p>确保使用空格键选择路由器选项，就像上面选择的一样。然后，为了节省空间，您可以选择将所有配置存储在<code>package.json</code>文件中。项目创建完成后，您会看到一条成功消息。此时，将目录更改为新的项目文件夹，并在开发环境中运行应用程序:</p>
<pre>cd test_project
npm run serve</pre>
<p><img data-attachment-id="46643" data-permalink="https://blog.logrocket.com/vue-lazy-loading-components-code-splitting/vue-js-lazy-loading-example-app/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2019/07/vue-js-lazy-loading-example-app.png" data-orig-size="657,426" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Vue.js lazy loading example app" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2019/07/vue-js-lazy-loading-example-app-300x195.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2019/07/vue-js-lazy-loading-example-app.png" decoding="async" class="aligncenter size-full wp-image-46643 jetpack-lazy-image" src="../Images/06a86361e10620d44f5123ddc4e5360a.png" alt="Vue.js Lazy Loading Example App" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2019/07/vue-js-lazy-loading-example-app.png 657w, https://blog.logrocket.com/wp-content/uploads/2019/07/vue-js-lazy-loading-example-app-300x195.png 300w" data-lazy-sizes="(max-width: 657px) 100vw, 657px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2019/07/vue-js-lazy-loading-example-app.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/07/vue-js-lazy-loading-example-app.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="46643" data-permalink="https://blog.logrocket.com/vue-lazy-loading-components-code-splitting/vue-js-lazy-loading-example-app/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2019/07/vue-js-lazy-loading-example-app.png" data-orig-size="657,426" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Vue.js lazy loading example app" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2019/07/vue-js-lazy-loading-example-app-300x195.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2019/07/vue-js-lazy-loading-example-app.png" decoding="async" loading="lazy" class="aligncenter size-full wp-image-46643" src="../Images/06a86361e10620d44f5123ddc4e5360a.png" alt="Vue.js Lazy Loading Example App" srcset="https://blog.logrocket.com/wp-content/uploads/2019/07/vue-js-lazy-loading-example-app.png 657w, https://blog.logrocket.com/wp-content/uploads/2019/07/vue-js-lazy-loading-example-app-300x195.png 300w" sizes="(max-width: 657px) 100vw, 657px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/07/vue-js-lazy-loading-example-app.png"/></noscript>
<p>它有一个<code>about</code>组件，可以在视图中进行路线导航。应用程序一初始化，两个组件<code>Home.vue</code>和<code>About.vue</code>就被加载到DOM中。这是标准过程，对于资产最少的小型项目非常好，但是在有很多组件的大型应用程序中，加载速度可能非常慢。这就是代码拆分的作用。</p>
<p>打开<code>router.js</code>文件。它看起来应该是这样的:</p>
<pre>import Vue from 'vue'
import Router from 'vue-router'
import Home from './views/Home.vue'
import About from './views/About.vue'
Vue.use(Router)
export default new Router({
  routes: [
    {
      path: '/',
      name: 'home',
      component: Home
    },
    {
      path: '/about',
      name: 'about',
      component: About
    }
  ]
})</pre>
<p>对于<code>about</code>组件部分，这可能看起来有所不同，因为Vue CLI包括了次要路由的延迟加载，例如我们示例中的<code>about</code>组件。</p>
<h2 id="manually">手动添加新路线</h2>
<p>您现在有两条路线:一条是指向主视图的<code>home</code>路线，另一条是指向关于视图的<code>about</code>路线。让我们添加第三个视图，然后为它注册一条路线。</p>
<p>在您的<code>views</code>文件夹中，创建一个新文件，并将其命名为<code>extra.vue</code>。然后，将<code>about.vue</code>文件的内容复制到<code>extra.vue</code>文件中。它应该是这样的:</p>
<pre>&lt;template&gt;
&lt;div class=”about”&gt;
&lt;h1&gt;This is an extra page&lt;/h1&gt;
&lt;/div&gt;
&lt;/template&gt;</pre>
<p>要注册该路线，打开您的<code>router.js</code>文件并在routes数组下添加额外的代码块:</p>
<pre>export default new Router({
  routes: [
    {
      path: '/',
      name: 'home',
      component: Home
    },
    {
      path: '/about',
      name: 'about',
      component: About
    },
   {
      path: '/extra',
      name: 'extra',
      component: Extra
    }
  ]
})</pre>
<p>让它显示在DOM中的最后一步是用一个<code>router-link</code>将它添加到主<code>App.vue</code>文件中。</p>
<p>打开您的<code>app.vue</code>文件，将模板部分更改为下面的代码块:</p>
<pre>&lt;template&gt;
&lt;div id=”app”&gt;
&lt;div id=”nav”&gt;
&lt;router-link to=”/”&gt;Home&lt;/router-link&gt; |
&lt;router-link to=”/about”&gt;About&lt;/router-link&gt; |
&lt;router-link to=”/extra”&gt;Extra&lt;/router-link&gt;
&lt;/div&gt;
&lt;router-view/&gt;
&lt;/div&gt;
&lt;/template&gt;</pre>
<h2 id="how">如何延迟加载Vue.js组件</h2>
<p>既然在我们的示例Vue.js应用程序中已经设置了所有的路由，那么是时候将所有的路由配置为按需延迟加载了。</p>
<p>打开您的<code>router.js</code>文件，将下面的代码块复制/粘贴到其中:</p>
<pre>import Vue from 'vue'
import Router from 'vue-router'
Vue.use(Router)
function lazyLoad(view){
  return() =&gt; import(`@/views/${view}.vue`)
}
export default new Router({
  mode: 'history',
  base: process.env.BASE_URL,
  routes: [
    {
      path: '/',
      name: 'home',
      component: lazyLoad('Home')
    },
    {
      path: '/about',
      name: 'about',
      component: lazyLoad('About')
    },
    {
      path: '/extra',
      name: 'extra',
      component: lazyLoad('extra')
    }
  ]
})
</pre>
<p>下面是为使这些视图延迟加载所做的工作:</p>
<h3>删除导入语句</h3>
<p>最初，您可能已经注意到了Vue.js、Router、Home、About和extra的import语句。这些语句是驱动组件急切加载的主要因素，所以当您更改为延迟加载方法时，您必须删除那些导入语句。</p>
<h3><code>lazyLoad</code>功能</h3>
<p>创建Vue <code>lazyLoad</code>函数是为了使导入语句变得清晰。如果没有这个函数，每个组件都会有一个很长的import语句。有了它，您可以简单地调用该函数，并将路由作为参数传入。</p>
<h3>webpack导入语句</h3>
<p>告诉webpack延迟加载组件的import语句必须嵌入到routes部分，而不是脚本开头的import部分。</p>
<p>要测试加载策略，请在开发中再次运行应用程序:</p>
<pre>npm run serve</pre>
<p>在浏览器中的<a href="http://localhost:8080/" target="_blank" rel="noopener noreferrer"> http://localhost:8080/ </a>打开它，并打开开发者工具。单击网络部分，然后选择JS选项卡。</p>
<p><img data-attachment-id="3680" data-permalink="https://blog.logrocket.com/vue-lazy-loading-components-code-splitting/aboutpage/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2019/07/aboutpage.gif" data-orig-size="730,243" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="aboutpage" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2019/07/aboutpage-300x100.gif" data-large-file="https://blog.logrocket.com/wp-content/uploads/2019/07/aboutpage.gif" decoding="async" class="aligncenter wp-image-3680 size-full jetpack-lazy-image" src="../Images/aac35601531a58048317972a875a765f.png" alt="" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2019/07/aboutpage.gif?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/07/aboutpage.gif"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="3680" data-permalink="https://blog.logrocket.com/vue-lazy-loading-components-code-splitting/aboutpage/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2019/07/aboutpage.gif" data-orig-size="730,243" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="aboutpage" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2019/07/aboutpage-300x100.gif" data-large-file="https://blog.logrocket.com/wp-content/uploads/2019/07/aboutpage.gif" decoding="async" loading="lazy" class="aligncenter wp-image-3680 size-full" src="../Images/aac35601531a58048317972a875a765f.png" alt="" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/07/aboutpage.gif"/></noscript>
<p>正如您所看到的，加载到DOM上的JavaScript块按时间顺序分成若干个数字，其中第一个(<code>0.js</code>)是主视图，第二个(<code>1.js</code>)是关于视图，只在点击时才添加到DOM中，第三个(<code>2.js</code>)是额外视图，也可以根据请求添加到DOM中。</p>
<p>在这个阶段，您还可以通过使用以下命令构建生产应用程序来验证延迟加载是否有效:</p>
<pre>npm run build</pre>
<p>这三个块将由webpack适时地表示为单独的、独立的、延迟加载的块。</p>
<h2>结论</h2>
<p>本入门教程旨在向您展示Vue.js如何借助webpack代码分割在抽象的路由级别处理延迟加载。在小型Vue.js项目中，延迟加载组件的重要性可能并不明显，但是随着您的项目变得越来越复杂，在您的工作流中实现延迟加载对于提高效率和优化资源使用来说是明智的。</p><div class="code-block code-block-20">
<div class="blog-plug inline-plug vue-inline"><h2>像用户一样体验您的Vue应用</h2><p>调试Vue.js应用程序可能会很困难，尤其是当用户会话期间有几十个(如果不是几百个)突变时。如果您对监视和跟踪生产中所有用户的Vue突变感兴趣，</p><a href="https://lp.logrocket.com/blg/vue-signup" target="_blank">try LogRocket</a><p>. </p><a class="signup" href="https://lp.logrocket.com/blg/vue-signup" target="_blank" rel="noopener noreferrer"><img class="alignnone size-full wp-image-46 jetpack-lazy-image" src="../Images/0d269845910c723dd7df26adab9289cb.png" alt="LogRocket Dashboard Free Trial Banner" data-lazy-src="https://files.readme.io/00591d0-687474703a2f2f692e696d6775722e636f6d2f6a3049327856572e706e67.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://files.readme.io/00591d0-687474703a2f2f692e696d6775722e636f6d2f6a3049327856572e706e67.png"/><noscript><img data-lazy-fallback="1" class="alignnone size-full wp-image-46" src="../Images/0d269845910c723dd7df26adab9289cb.png" alt="LogRocket Dashboard Free Trial Banner" data-original-src="https://files.readme.io/00591d0-687474703a2f2f692e696d6775722e636f6d2f6a3049327856572e706e67.png"/></noscript></a><a href="https://lp.logrocket.com/blg/vue-signup" target="_blank" rel="noopener noreferrer">https://logrocket.com/signup/</a><p>LogRocket 就像是网络和移动应用程序的DVR，记录你的Vue应用程序中发生的一切，包括网络请求、JavaScript错误、性能问题等等。您可以汇总并报告问题发生时应用程序的状态，而不是猜测问题发生的原因。</p><p>LogRocket Vuex插件将Vuex突变记录到LogRocket控制台，为您提供导致错误的环境，以及出现问题时应用程序的状态。</p><p>现代化您调试Vue应用的方式- <a class="signup" href="https://lp.logrocket.com/blg/vue-signup" target="_blank" rel="noopener noreferrer">开始免费监控</a>。</p></div>


</div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
<html>
<head>
<title>Pitfalls of overusing React Context - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>过度使用React上下文日志的陷阱</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/pitfalls-of-overusing-react-context/#0001-01-01">https://blog.logrocket.com/pitfalls-of-overusing-react-context/#0001-01-01</a></blockquote><div><article class="article-post">
<p>在很大程度上，反应和状态是齐头并进的。随着React应用的增长，管理状态变得越来越重要。</p>
<p>随着<a href="https://blog.logrocket.com/introducing-react-16-8-featuring-official-support-for-hooks/" target="_blank" rel="noopener noreferrer"> React 16.8和钩子</a>的引入，React上下文API有了显著的改进。现在我们可以把它和钩子结合起来模仿<code>react-redux</code>；有些人甚至用它来管理他们的整个应用程序状态。然而，React上下文有一些缺陷，过度使用它会导致性能问题。</p>
<p>在本教程中，我们将回顾过度使用React上下文的潜在后果，并讨论如何在下一个React项目中有效地使用它。</p>
<h3 id="whatisreactcontext">什么是反应上下文？</h3>
<p>React Context提供了一种在应用程序中共享数据(状态)的方式，而无需传递每个组件的属性。它使您能够通过提供者和消费者使用上下文中保存的数据，而无需进行适当的演练。</p>
<pre>const CounterContext = React.createContext();

const CounterProvider = ({ children }) =&gt; {
  const [count, setCount] = React.useState(0);

  const increment = () =&gt; setCount(counter =&gt; counter + 1);
  const decrement = () =&gt; setCount(counter =&gt; counter - 1);
  return (
    &lt;CounterContext.Provider value={{ count, increment, decrement }}&gt;
      {children}
    &lt;/CounterContext.Provider&gt;
  );
};

const IncrementCounter = () =&gt; {
  const { increment } = React.useContext(CounterContext);
  return &lt;button onClick={increment}&gt; Increment&lt;/button&gt;;
};

const DecrementCounter = () =&gt; {
  const { decrement } = React.useContext(CounterContext);
  return &lt;button onClick={decrement}&gt; Decrement&lt;/button&gt;;
};

const ShowResult = () =&gt; {
  const { count } = React.useContext(CounterContext);
  return &lt;h1&gt;{count}&lt;/h1&gt;;
};

const App = () =&gt; (
  &lt;CounterProvider&gt;
    &lt;ShowResult /&gt;
    &lt;IncrementCounter /&gt;
    &lt;DecrementCounter /&gt;
  &lt;/CounterProvider&gt;
);
</pre>
<p>注意，我有意将<code>IncrementCounter</code>和<code>DecrementCounter</code>分成两个部分。这将帮助我更清楚地演示与React上下文相关的问题。</p>
<p>如你所见，我们有一个非常简单的上下文。它包含两个函数，<code>increment</code>和<code>decrement</code>，处理计数器的计算和结果。然后，我们从每个组件中提取数据，并显示在<code>App</code>组件上。没什么特别的，只是你典型的React应用。</p>
<p><img data-attachment-id="13525" data-permalink="https://blog.logrocket.com/pitfalls-of-overusing-react-context/gordon-ramsay-what-is-the-problem/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/02/gordon-ramsay-what-is-the-problem.gif" data-orig-size="500,338" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Gordon Ramsay asking, “What is the problem?”" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/02/gordon-ramsay-what-is-the-problem-300x203.gif" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/02/gordon-ramsay-what-is-the-problem.gif" decoding="async" class="aligncenter size-full wp-image-13525 jetpack-lazy-image" src="../Images/59d818204f42ec790cc79c1aa82bfd85.png" alt="Gordon Ramsay Asking, &quot;What Is the Problem?&quot;" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2020/02/gordon-ramsay-what-is-the-problem.gif?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/02/gordon-ramsay-what-is-the-problem.gif"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="13525" data-permalink="https://blog.logrocket.com/pitfalls-of-overusing-react-context/gordon-ramsay-what-is-the-problem/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/02/gordon-ramsay-what-is-the-problem.gif" data-orig-size="500,338" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Gordon Ramsay asking, “What is the problem?”" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/02/gordon-ramsay-what-is-the-problem-300x203.gif" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/02/gordon-ramsay-what-is-the-problem.gif" decoding="async" loading="lazy" class="aligncenter size-full wp-image-13525" src="../Images/59d818204f42ec790cc79c1aa82bfd85.png" alt="Gordon Ramsay Asking, &quot;What Is the Problem?&quot;" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/02/gordon-ramsay-what-is-the-problem.gif"/></noscript>
<p>从这个角度来看，您可能想知道使用React上下文有什么问题？对于这样一个简单的应用程序，管理状态很容易。然而，随着您的应用程序变得越来越复杂，React Context可能很快成为开发人员的噩梦。</p>
<h3 id="pitfallsofreactcontext">使用React上下文的利与弊</h3>
<p>尽管React Context实现起来很简单，对于某些类型的应用程序来说也很棒，但它是以这样一种方式构建的，即每次上下文的值发生变化时，组件使用者都会重新呈现。</p>
<p>到目前为止，对于我们的应用程序来说，这还不是一个问题，因为如果组件在上下文的值改变时不重新呈现，它将永远不会获得更新的值。然而，重新呈现将不限于组件消费者；将重新呈现与上下文相关的所有组件。</p>
<p>要查看它的运行情况，让我们更新我们的示例。</p>
<pre>const CounterContext = React.createContext();

const CounterProvider = ({ children }) =&gt; {
  const [count, setCount] = React.useState(0);
  const [hello, setHello] = React.useState("Hello world");

  const increment = () =&gt; setCount(counter =&gt; counter + 1);
  const decrement = () =&gt; setCount(counter =&gt; counter - 1);

  const value = {
    count,
    increment,
    decrement,
    hello
  };

  return (
    &lt;CounterContext.Provider value={value}&gt;{children}&lt;/CounterContext.Provider&gt;
  );
};

const SayHello = () =&gt; {
  const { hello } = React.useContext(CounterContext);
  console.log("[SayHello] is running");
  return &lt;h1&gt;{hello}&lt;/h1&gt;;
};

const IncrementCounter = () =&gt; {
  const { increment } = React.useContext(CounterContext);
  console.log("[IncrementCounter] is running");
  return &lt;button onClick={increment}&gt; Increment&lt;/button&gt;;
};

const DecrementCounter = () =&gt; {
  console.log("[DecrementCounter] is running");
  const { decrement } = React.useContext(CounterContext);
  return &lt;button onClick={decrement}&gt; Decrement&lt;/button&gt;;
};

const ShowResult = () =&gt; {
  console.log("[ShowResult] is running");
  const { count } = React.useContext(CounterContext);
  return &lt;h1&gt;{count}&lt;/h1&gt;;
};

const App = () =&gt; (
  &lt;CounterProvider&gt;
    &lt;SayHello /&gt;
    &lt;ShowResult /&gt;
    &lt;IncrementCounter /&gt;
    &lt;DecrementCounter /&gt;
  &lt;/CounterProvider&gt;
);
</pre>
<p>我添加了一个新组件<code>SayHello</code>，它显示来自上下文的消息。每当这些组件渲染或重新渲染时，我们还会记录一条消息。这样，我们可以看到变更是否影响了所有组件。</p>
<pre>// Result of the console
 [SayHello] is running
 [ShowResult] is running
 [IncrementCounter] is running
 [DecrementCounter] is running
</pre>
<p>当页面完成加载时，所有消息都将出现在控制台上。目前还没什么可担心的。</p>
<p>让我们点击<code>increment</code>按钮，看看会发生什么。</p>
<pre>// Result of the console
 [SayHello] is running
 [ShowResult] is running
 [IncrementCounter] is running
 [DecrementCounter] is running
</pre>
<p>如您所见，所有组件都重新呈现。点击<code>decrement</code>按钮具有相同的效果。每当上下文的值改变时，所有组件的消费者都将重新呈现。</p>
<p>你可能还在想，谁在乎呢？React上下文不就是这样工作的吗？</p>
<p><img data-attachment-id="13524" data-permalink="https://blog.logrocket.com/pitfalls-of-overusing-react-context/friends-who-cares/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/02/friends-who-cares.gif" data-orig-size="192,231" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Joey from “Friends” shrugging" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/02/friends-who-cares.gif" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/02/friends-who-cares.gif" decoding="async" class="aligncenter size-full wp-image-13524 jetpack-lazy-image" src="../Images/abed578413ebd0c69b2d7dcb48c32feb.png" alt="Joey From &quot;Friends&quot; Shrugging" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2020/02/friends-who-cares.gif?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/02/friends-who-cares.gif"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="13524" data-permalink="https://blog.logrocket.com/pitfalls-of-overusing-react-context/friends-who-cares/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/02/friends-who-cares.gif" data-orig-size="192,231" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Joey from “Friends” shrugging" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/02/friends-who-cares.gif" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/02/friends-who-cares.gif" decoding="async" loading="lazy" class="aligncenter size-full wp-image-13524" src="../Images/abed578413ebd0c69b2d7dcb48c32feb.png" alt="Joey From &quot;Friends&quot; Shrugging" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/02/friends-who-cares.gif"/></noscript>
<p>对于这么微小的app，我们完全不用担心使用React Context带来的负面影响。但是在一个状态频繁变化的大型项目中，这个工具产生的问题比它帮助解决的问题还要多。一个简单的更改会导致无数次重新渲染，最终会导致严重的性能问题。</p>
<p>那么我们如何避免这种降低性能的重新渲染呢？</p>
<h3 id="usememototherescue">用<code>useMemo()</code>防止重新渲染</h3>
<p>也许记忆是解决我们问题的方法。让我们用<code>useMemo</code>更新我们的代码，看看记忆我们的值是否能帮助我们避免重新呈现。</p>
<pre>const CounterContext = React.createContext();

const CounterProvider = ({ children }) =&gt; {
  const [count, setCount] = React.useState(0);
  const [hello, sayHello] = React.useState("Hello world");

  const increment = () =&gt; setCount(counter =&gt; counter + 1);
  const decrement = () =&gt; setCount(counter =&gt; counter - 1);

  const value = React.useMemo(
    () =&gt; ({
      count,
      increment,
      decrement,
      hello
    }),
    [count, hello]
  );

  return (
    &lt;CounterContext.Provider value={value}&gt;{children}&lt;/CounterContext.Provider&gt;
  );
};

const SayHello = () =&gt; {
  const { hello } = React.useContext(CounterContext);
  console.log("[SayHello] is running");
  return &lt;h1&gt;{hello}&lt;/h1&gt;;
};

const IncrementCounter = () =&gt; {
  const { increment } = React.useContext(CounterContext);
  console.log("[IncrementCounter] is running");
  return &lt;button onClick={increment}&gt; Increment&lt;/button&gt;;
};

const DecrementCounter = () =&gt; {
  console.log("[DecrementCounter] is running");
  const { decrement } = React.useContext(CounterContext);
  return &lt;button onClick={decrement}&gt; Decrement&lt;/button&gt;;
};

const ShowResult = () =&gt; {
  console.log("[ShowResult] is running");
  const { count } = React.useContext(CounterContext);
  return &lt;h1&gt;{count}&lt;/h1&gt;;
};

const App = () =&gt; (
  &lt;CounterProvider&gt;
    &lt;SayHello /&gt;
    &lt;ShowResult /&gt;
    &lt;IncrementCounter /&gt;
    &lt;DecrementCounter /&gt;
  &lt;/CounterProvider&gt;
);
</pre>
<p>现在让我们再次点击<code>increment</code>按钮，看看它是否工作。</p>
<pre>&lt;// Result of the console
 [SayHello] is running
 [ShowResult] is running
 [IncrementCounter] is running
 [DecrementCounter] is running
</pre>
<p>不幸的是，我们仍然遇到同样的问题。每当我们的上下文的值改变时，所有组件的消费者都被重新呈现。</p>
<p><img data-attachment-id="13526" data-permalink="https://blog.logrocket.com/pitfalls-of-overusing-react-context/michael-scott-sad/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/02/michael-scott-sad.gif" data-orig-size="220,220" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Michael Scott from “The Office” with a sad expression" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/02/michael-scott-sad.gif" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/02/michael-scott-sad.gif" decoding="async" class="aligncenter size-full wp-image-13526 jetpack-lazy-image" src="../Images/e79cb09ea2a906ae81082e66e72383c8.png" alt="Michael Scott Making a Sad Face" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2020/02/michael-scott-sad.gif?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/02/michael-scott-sad.gif"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="13526" data-permalink="https://blog.logrocket.com/pitfalls-of-overusing-react-context/michael-scott-sad/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/02/michael-scott-sad.gif" data-orig-size="220,220" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Michael Scott from “The Office” with a sad expression" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/02/michael-scott-sad.gif" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/02/michael-scott-sad.gif" decoding="async" loading="lazy" class="aligncenter size-full wp-image-13526" src="../Images/e79cb09ea2a906ae81082e66e72383c8.png" alt="Michael Scott Making a Sad Face" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/02/michael-scott-sad.gif"/></noscript>
<p>如果记忆不能解决问题，我们是否应该停止用反应上下文来管理我们的状态？</p>
<h3 id="shouldweavoidreactcontext">应该使用React上下文吗？</h3>
<p>在开始项目之前，您应该确定如何管理您的状态。有无数可用的解决方案，其中只有一个是React Context。要确定哪种工具最适合您的应用，问自己两个问题:</p>
<ol>
<li>你应该什么时候使用它？</li>
<li>你打算如何使用它？</li>
</ol>
<p>如果您的状态频繁更新，React Context可能不如像<a href="https://blog.logrocket.com/when-and-when-not-to-use-redux-41807f29a7fb/" target="_blank" rel="noopener noreferrer"> React Redux </a>这样的工具有效或高效。但是，如果您的静态数据更新频率较低，比如首选语言、时间更改、位置更改和用户身份验证，那么使用React上下文传递props可能是最好的选择。</p>
<p>如果您确实选择使用React上下文，请尽可能地将您的大上下文拆分成多个上下文，并使您的状态靠近其组件消费者。这将帮助您最大化React Context的特性和功能，对于简单的应用程序来说，React Context在某些情况下可能非常强大。</p>
<p>那么，<a href="https://blog.logrocket.com/use-hooks-and-context-not-react-and-redux/" target="_blank" rel="noopener noreferrer">应该使用React上下文</a>吗？答案取决于何时和如何。</p>
<h3 id="finalthoughts">最后的想法</h3>
<p>React Context对于状态变化不频繁的简单应用程序来说是一个优秀的API，但是如果您在更复杂的项目中过度使用它，它会很快变成开发人员的噩梦。了解该工具在构建高性能应用程序时是如何工作的，可以帮助您确定它对于管理项目中的状态是否有用。尽管React Context在处理高频率的状态变化时有其局限性，但如果使用得当，它是一个非常强大的状态管理解决方案。</p><div class="code-block code-block-17">
<div class="blog-plug inline-plug react-plug" vwo-el-id="26283398190">
<h2 vwo-el-id="41600691720"><a href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener"> LogRocket </a>:全面了解您的生产React应用</h2><p>调试React应用程序可能很困难，尤其是当用户遇到难以重现的问题时。如果您对监视和跟踪Redux状态、自动显示JavaScript错误以及跟踪缓慢的网络请求和组件加载时间感兴趣，</p><a href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" vwo-el-id="19356441070">try LogRocket</a><p>. </p><a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="19356441380">
<img class="first-react-image alignnone size-full wp-image-46 jetpack-lazy-image jetpack-lazy-image--handled" src="../Images/f300c244a1a1cf916df8b4cb02bec6c6.png" vwo-el-id="18272717540" data-lazy-loaded="1" data-original-src="https://files.readme.io/27c94e7-Image_2017-06-05_at_9.46.04_PM.png"/>
</a>
<a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="19356441690">
<img class="second-react-image alignnone size-full wp-image-46 jetpack-lazy-image jetpack-lazy-image--handled" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" vwo-el-id="30720362350" data-lazy-loaded="1" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/>
</a>
<p vwo-el-id="28675660440" class="">LogRocket 结合了会话回放、产品分析和错误跟踪，使软件团队能够创建理想的web和移动产品体验。这对你来说意味着什么？</p>
<p>LogRocket不是猜测错误发生的原因，也不是要求用户提供截图和日志转储，而是让您回放问题，就像它们发生在您自己的浏览器中一样，以快速了解哪里出错了。</p>
<p>不再有嘈杂的警报。智能错误跟踪允许您对问题进行分类，然后从中学习。获得有影响的用户问题的通知，而不是误报。警报越少，有用的信号越多。</p>
<p vwo-el-id="28675660750">LogRocket Redux中间件包为您的用户会话增加了一层额外的可见性。LogRocket记录Redux存储中的所有操作和状态。</p>
<p vwo-el-id="28675661060">现代化您调试React应用的方式— <a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="40093418840">开始免费监控</a>。</p>
</div></div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
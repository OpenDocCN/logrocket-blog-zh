<html>
<head>
<title>How to build React components for codebases that use JavaScript and TypeScript - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>如何为使用JavaScript和TypeScript的代码库构建React组件</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/how-to-build-react-components-for-codebases-that-use-javascript-and-typescript/#0001-01-01">https://blog.logrocket.com/how-to-build-react-components-for-codebases-that-use-javascript-and-typescript/#0001-01-01</a></blockquote><div><article class="article-post">
<p>TypeScript 最近越来越受欢迎，因为它通过在运行代码之前捕捉错误并提出修复建议来帮助改善开发体验。出于这个原因，TypeScript在防止任何运行时错误和减少bug方面大有作为。</p>
<p>TypeScript通过扩展JavaScript来添加类型并在开发期间执行类型检查，因此，所有类型错误都必须在运行代码之前修复，类似于Elm等语言。</p>
<p>TypeScript相当不错，在某些情况下，您可能希望将它插入到已经利用JavaScript的代码库中，这可以与您的JavaScript代码一起使用，或者逐渐将您的代码库迁移到JavaScript。在本文中，我们将了解如何将TypeScript与React和built组件结合使用，这些组件在TypeScript和JavaScript文件中都可用。为此，我们将构建一个简单的显示组件，它接收一些数据并显示给用户。</p>
<h2>创建应用程序</h2>
<p>为了节省我们开发人员环境的配置时间，我们将使用<a href="https://create-react-app.dev/docs/getting-started/" target="_blank" rel="noopener noreferrer"> create-react-app </a>来引导我们的应用程序，幸运的是，它还有一个<a href="https://create-react-app.dev/docs/adding-typescript/" target="_blank" rel="noopener noreferrer">类型脚本模板</a>，我们可以使用它来快速启动并运行。</p>
<p>如果您没有安装create-react-app，请运行以下命令进行安装:</p>
<pre>npm install -g create-react-app</pre>
<p>安装create-react-app后，通过运行以下命令创建您的应用程序:</p>
<pre>yarn create react-app my-app --template typescript</pre>
<p>进入应用程序的目录，在终端中使用<code>yarn start</code>命令运行。</p>
<p>我们将在应用程序中使用<a href="https://reacttraining.com/react-router/web/guides/quick-start" target="_blank" rel="noopener noreferrer"> react-router </a>进行一些最少的路由，因此我们需要安装一些依赖项:</p>
<pre>yarn add react-router-dom @types/react-router-dom</pre>
<p>这将安装两个包，<code>react-router-dom</code>为react-router提供DOM绑定，而<code>@types/react-router-dom</code>包含了<code>react-router-dom</code>的类型定义。</p>
<p>现在我们有了应用程序设置的样板文件，在您的<code>src</code>文件夹中创建两个新目录，<code>pages</code>将保存我们将在应用程序中拥有的两个简单页面，<code>DisplayData</code>将存放我们的组件。</p>
<h2>路由和页面</h2>
<p>每个页面都将使用我们将要创建的相同显示组件，其中一个页面用JavaScript实现，另一个用TypeScript实现。</p>
<p>在<code>pages</code>文件夹中，创建两个文件,<code>WithTS.tsx</code>和<code>WithoutTS.jsx</code>,这两个文件都将包含一些功能组件，它们只是将一些数据传递到我们的可重用显示组件中。我们的JavaScript页面将包含一个名为<code>DisplayWithoutTS</code>的组件，我们将把它放在<code>WithoutTS.jsx</code>中，它看起来像这样:</p>
<pre>import React from 'react'
import { DisplayData } from '../DisplayData'
const DisplayWithoutTS = () =&gt; {
    const info = {
        name: 'Anakin Skywalker',
        alias: [ 'Darth Vader', 'The Chosen One'],
        powers: ['Force Push', 'Force Pull', 'Force Vision'],
        rating: 10
      }
    return &lt;DisplayData data={info}/&gt;
}
export { DisplayWithoutTS }</pre>
<p>我们的TypeScript实现是一个<code>DisplayWithTS</code>组件，它将位于<code>WithTs.tsx</code>文件中，并包含以下代码:</p>
<pre>import React from 'react'
import { DisplayData } from '../DisplayData'
const DisplayWithTS = () =&gt; {
    const info = {
        name: 'Sheev Palpatine',
        alias: [ 'Chancellor Palpatine', 'Emperor Palpatine', 'Darth Sidious'],
        powers: ['Force Push', 'Force Pull', 'Force Vision', 'Force Lightning', 'Sith Storm', 'Essense Transfer'],
        rating: 10
      }
    return &lt;DisplayData data={info}/&gt;
}
export { DisplayWithTS }</pre>
<p>现在我们已经建立了基础页面，下一步是建立路由。由于我们只有两条路线，我们将保持简单并编辑我们的<code>App.tsx</code>文件:</p>
<pre>import React from 'react';
import './App.css';
import { BrowserRouter, Route, Switch } from 'react-router-dom'
import  { DisplayWithoutTS } from './pages/WithoutTS'
import { DisplayWithTS } from './pages/WithTS'

function App() {
  return (
    &lt;div className="App"&gt;
      &lt;div&gt;
        &lt;a href="/"&gt;With JS&lt;/a&gt;
        &lt;br/&gt;
        &lt;a href="/withts"&gt;With TS&lt;/a&gt;
      &lt;/div&gt;
      &lt;br/&gt;&lt;br/&gt;
      &lt;BrowserRouter&gt;
        &lt;Switch&gt;
          &lt;Route exact path='/' component={DisplayWithoutTS}/&gt;
          &lt;Route exact path='/withts' component={DisplayWithTS}/&gt;
          &lt;Route exact path='*' &gt;
            &lt;div&gt;
              404 Page Not Found
            &lt;/div&gt;
          &lt;/Route&gt;
        &lt;/Switch&gt;
      &lt;/BrowserRouter&gt;
    &lt;/div&gt;
  );
}
export default App;</pre>
<p>在<code>BrowserRouter</code>组件之前我们有两个链接，这将让我们在应用程序的两个页面之间切换。我们使用<code>Switch</code>来处理路由，并通过将<code>404</code>错误与<code>*</code>路径匹配来显示所有未考虑路径的错误消息。</p>
<h2>构建我们的可重用组件</h2>
<p>在设置我们的TypeScript兼容性之前，我们需要首先构建我们的组件。在<code>DisplayData</code>目录下，创建两个文件，<code>DisplayData.jsx</code>和<code>index.ts</code>。</p>
<p>让我们在<code>DisplayData.jsx</code>中创建我们的显示组件:</p>
<pre>import React from 'react'
import {shape, string, number, arrayOf} from 'prop-types'

const DisplayData = ({data}) =&gt; {
    return (
        &lt;div&gt;
            &lt;div&gt;Name: {data.name}&lt;/div&gt;
            &lt;div&gt;Alias: {data.alias.join(', ')}&lt;/div&gt;
            &lt;div&gt;Powers: {data.powers.join(', ')}&lt;/div&gt;
            &lt;div&gt;Rating: {data.rating}&lt;/div&gt;
        &lt;/div&gt;
    )
}
DisplayData.propTypes = {
    data: shape({
        name: string,
        alias: arrayOf(string),
        powers: arrayOf(string),
        rating: number,
    })
}

DisplayData.defaultProps = {
    data: {
        name: '',
        alias: [],
        powers: [],
        rating: null,
    }
}
export { DisplayData }</pre>
<p>我们的组件接受一个数据属性，用它来填充一个虚构角色的信息并显示给用户。我们用prop-types执行prop验证，在这种情况下，我们的组件接收一个单独的prop，它是一个对象。我们使用<code>shape</code>来描述正确验证中对象类型。然后，我们继续填充对象内容的类型，例如分别用于文本字符串和数值的<code>string</code>和<code>number</code>。对于以数组形式出现的数据，我们使用<code>arrayOf</code>来定义数组的内容，这很好，因为它比简单地使用<code>array</code>类型声明数据提供了更多的特异性。</p>
<p>然后我们将这个组件导出到<code>index.ts</code>中，使它可以在其他文件中使用。</p>
<h2>添加TypeScript兼容性</h2>
<p>既然我们已经设置了组件并使其工作，我们需要添加一些TypeScript配置，以确保当在TypeScript文件(扩展名为<code>.ts</code>或<code>.tsx</code>的文件)中使用类型检查时，类型检查由TypeScript处理。为了利用TypeScript的类型检查功能，我们需要熟悉<a href="https://www.typescriptlang.org/docs/handbook/basic-types.html" target="_blank" rel="noopener noreferrer">类型</a>和<a href="https://www.typescriptlang.org/docs/handbook/interfaces.html" target="_blank" rel="noopener noreferrer">接口</a>的概念，您可以查看<a href="https://blog.logrocket.com/types-vs-interfaces-in-typescript/" target="_blank" rel="noopener noreferrer">这篇涵盖这两者的伟大文章</a>来帮助您快速上手。类型基本上指定了我们传入的各种数据的格式。接口允许我们塑造这些值，并充当命名这些类型的角色，并且是在您的代码中定义契约以及与项目外部的代码定义契约的强大方法。我们还需要熟悉<a href="https://www.typescriptlang.org/docs/handbook/modules.html" target="_blank" rel="noopener noreferrer">模块</a>，这些模块允许我们将添加的TypeScript封装到现有的React组件中，并允许它在TypeScript文件中使用时执行类型检查。</p>
<p>将TypeScript合并到组件中就像将下面的代码添加到组件文件夹中的<code>index.ts</code>文件中一样简单:</p>
<pre>interface DisplayDataProps {
    data : {
        name: String,
        alias: String[],
        powers: String[],
        rating: Number,
    }
}
declare module '.'{
    export const DisplayData: React.FC&lt;DisplayDataProps&gt;
}</pre>
<p>我们将接口声明为<code>DisplayDataProps</code>，接口中的类型定义与组件中的属性类型验证非常相似，但是更加简洁。对于对象类型，我们简单地按照对象的结构来映射它。其他基本类型的定义与<code>prop-types</code>相同，唯一的区别是类型名是大写的，即<code>string</code>将是<code>String</code>而<code>number</code>将是<code>Number</code>等等。</p>
<p>你可能还会注意到我们对<code>alias</code>和<code>powers</code>的类型定义，它们都是字符串数组，与我们用<code>prop-types</code>验证的略有不同，而不是<code>arrayOf(string)</code>，我们用<code>String[]</code>来声明字符串数组。这不仅比<code>prop-types</code>实现更简洁，而且当值未定义时，它还会自动返回一个空列表，这很方便，因为它为组件提供了自动默认属性。</p>
<p>一旦定义了我们的接口，我们需要将组件声明为TypeScript模块，以便在组件被导入到<code>.ts</code>或<code>.tsx</code>文件时通知TypeScript使用定义的接口。我们使用<code>React.FC</code> ( <code>React.FunctionalComponent</code>全称)在声明的模块中定义了我们的<code>DisplayData</code>组件，以使其返回类型更加明确，并为静态属性(如<code>displayName</code>、<code>propTypes</code>和<code>defaultProps</code>)提供类型检查和自动完成功能。你可以在<a href="https://github.com/typescript-cheatsheets/react-typescript-cheatsheet" target="_blank" rel="noopener noreferrer">React TypeScript cheat sheet</a>上找到关于这个的更多信息。</p>
<p>就这样，我们准备好了！由于我们已经做了所有的前期设置，我们所要做的就是重新运行我们的应用程序。在路由之间切换应该显示由两个页面提供给应用程序的数据，如下面的演示所示。</p>
<p/>
<p>您可以进行类型验证，以确保一切都按照预期进行，更改其中任何一项都会破坏应用程序。</p>
<h2>结论</h2>
<p>现在，您已经具备了在包含JavaScript或TypeScript文件的代码库中使用组件所需的条件。这在很多情况下都会派上用场，无论是迁移代码库还是构建兼容的组件库。TypeScript的类型检查在开发中非常方便，这无疑是TypeScript值得学习的地方。如果你想看看这个应用程序的代码，你可以看看这个<a href="https://github.com/austinroy/react-ts-component-demo/blob/master/README.md" target="_blank" rel="noopener noreferrer"> GitHub repo </a>。</p><div class="code-block code-block-17">
<div class="blog-plug inline-plug react-plug" vwo-el-id="26283398190">
<h2 vwo-el-id="41600691720"><a href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener"> LogRocket </a>:全面了解您的生产React应用</h2><p>调试React应用程序可能很困难，尤其是当用户遇到难以重现的问题时。如果您对监视和跟踪Redux状态、自动显示JavaScript错误以及跟踪缓慢的网络请求和组件加载时间感兴趣，</p><a href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" vwo-el-id="19356441070">try LogRocket</a><p>. </p><a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="19356441380">
<img class="first-react-image alignnone size-full wp-image-46 jetpack-lazy-image jetpack-lazy-image--handled" src="../Images/f300c244a1a1cf916df8b4cb02bec6c6.png" vwo-el-id="18272717540" data-lazy-loaded="1" data-original-src="https://files.readme.io/27c94e7-Image_2017-06-05_at_9.46.04_PM.png"/>
</a>
<a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="19356441690">
<img class="second-react-image alignnone size-full wp-image-46 jetpack-lazy-image jetpack-lazy-image--handled" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" vwo-el-id="30720362350" data-lazy-loaded="1" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/>
</a>
<p vwo-el-id="28675660440" class="">LogRocket 结合了会话回放、产品分析和错误跟踪，使软件团队能够创建理想的web和移动产品体验。这对你来说意味着什么？</p>
<p>LogRocket不是猜测错误发生的原因，也不是要求用户提供截图和日志转储，而是让您回放问题，就像它们发生在您自己的浏览器中一样，以快速了解哪里出错了。</p>
<p>不再有嘈杂的警报。智能错误跟踪允许您对问题进行分类，然后从中学习。获得有影响的用户问题的通知，而不是误报。警报越少，有用的信号越多。</p>
<p vwo-el-id="28675660750">LogRocket Redux中间件包为您的用户会话增加了一层额外的可见性。LogRocket记录Redux存储中的所有操作和状态。</p>
<p vwo-el-id="28675661060">现代化您调试React应用的方式— <a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="40093418840">开始免费监控</a>。</p><div class="code-block code-block-21">
<div class="blog-plug inline-plug typescript-plug"><h2><a class="signup" href="https://lp.logrocket.com/blg/typescript-signup" target="_blank" rel="noopener noreferrer"> LogRocket </a>:全面了解您的网络和移动应用</h2>
<a href="https://lp.logrocket.com/blg/typescript-signup" class="signup" target="_blank" rel="noopener noreferrer"><img class="alignnone size-full wp-image-46 jetpack-lazy-image" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/><noscript><img data-lazy-fallback="1" class="alignnone size-full wp-image-46" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/></noscript></a>
<p>LogRocket 是一个前端应用程序监控解决方案，可以让您回放问题，就像问题发生在您自己的浏览器中一样。LogRocket不需要猜测错误发生的原因，也不需要向用户询问截图和日志转储，而是让您重放会话以快速了解哪里出错了。它可以与任何应用程序完美配合，不管是什么框架，并且有插件可以记录来自Redux、Vuex和@ngrx/store的额外上下文。</p>
<p>除了记录Redux操作和状态，LogRocket还记录控制台日志、JavaScript错误、堆栈跟踪、带有头+正文的网络请求/响应、浏览器元数据和自定义日志。它还使用DOM来记录页面上的HTML和CSS，甚至为最复杂的单页面和移动应用程序重新创建像素级完美视频。</p>
<a class="signup" href="https://lp.logrocket.com/blg/typescript-signup" target="_blank" rel="noopener noreferrer">Try it for free</a><p>.</p></div>
</div>
</div></div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
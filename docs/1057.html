<html>
<head>
<title>Gatsby APIs you need to know - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>你需要知道的盖茨比API</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/gatsby-apis-you-need-to-know/#0001-01-01">https://blog.logrocket.com/gatsby-apis-you-need-to-know/#0001-01-01</a></blockquote><div><article class="article-post">
<p>盖茨比生态系统有很多合作在进行。这可以归因于它的开源性质，<a href="https://github.com/gatsbyjs/gatsby/pulls?q=is%3Apr+is%3Aopen+sort%3Aupdated-desc" target="_blank" rel="noopener noreferrer">许多人向Gatsby存储库发送pull请求</a>来贡献文档、框架本身，或者创建starters/showcases——这是用Gatsby构建的网站，显示在<a href="https://www.gatsbyjs.org/showcase/" target="_blank" rel="noopener noreferrer">官方网站</a>上。</p>
<p>生态系统的大部分利用Gatsby构建，这很棒，尽管Gatsby为想要真正扩展框架功能的人提供了一些API。在这篇博文中，我们将会看到这些API中的一些，以及它们派上用场的一些用例。</p>
<h2>盖茨比是怎么工作的？</h2>
<p>Gatsby为web提供了最好的构建方式，同时可以针对任何目的进行无限的定制和扩展。认为Gatsby只适用于特定用例(博客、附带项目)的想法是不准确的，因为Gatsby提供了一个允许它扩展其功能的层，这意味着随着应用程序的增长，Gatsby的功能也会随之增长，同时考虑到性能。</p>
<p>例如，如果您的应用程序需要更加自定义的模式定制，这就是Gatsby的模式定制API所提供的。另外，如果你想为你的平台扩展<a href="https://webpack.js.org/" target="_blank" rel="noopener noreferrer"> Webpack </a>配置，或者你还没有使用插件来处理这个问题，那么<code>onCreateWebpackConfig</code>可以在<code>gatsby-node.js</code>文件中导出。</p>
<p>让我们从查看处理Gatsby应用程序中插件功能的<code>gatsby-confi</code>文件开始。在这个文件中，我们可以定义站点的元数据和其他常规配置。这个文件应该在你的Gatsby站点的根目录下。</p>
<p>如果您用<code>gatsby new</code>命令创建了一个Gatsby站点，那么在您站点的目录中应该已经有一个示例配置文件了。配置文件应该导出一个JavaScript对象。在这个对象中，您可以定义几个不同的配置选项。例如:</p>
<pre>module.exports = {
  siteMetadata: {
    title: `Name of your application`,
  },
  plugins: [
    `Name-of-plugin`,
    {
      resolve: `Name-of-plugin`,
      options: {
        optionA: true,
        optionB: `Another option`,
      },
    },
  ],
}</pre>
<blockquote><p>插件作者注意:如果你的插件执行异步操作(磁盘I/O，数据库访问，调用远程API，等等。)必须返回一个承诺(显式地使用<code>Promise</code> API或者隐式地使用<code>async</code> / <code>await</code>语法)或者使用传递给第三个参数的回调。Gatsby需要知道插件何时完成，因为为了正确工作，一些API需要先完成以前的API。–<a href="https://www.gatsbyjs.org/docs/" target="_blank" rel="noopener noreferrer">盖茨比文件</a></p></blockquote>
<h2>盖茨比·阿皮斯</h2>
<h3>扩展模式功能</h3>
<p>在本文的前面，我提到了一个API来帮助扩展您的数据的GraphQL模式，这些特性通常是插件作者、试图修复由自动类型推断创建的GraphQL模式的用户、为更大的站点优化构建的开发人员以及任何对定制Gatsby的模式生成感兴趣的人所需要的。</p>
<p>这个例子中的API是<code>a href="https://www.gatsbyjs.org/docs/node-apis/#createSchemaCustomization" target="_blank" rel="noopener"&gt;createSchemaCustomization</code>(在Gatsby v2.12和更高版本中可用)和<code><a href="https://www.gatsbyjs.org/docs/node-apis/#sourceNodes" target="_blank" rel="noopener noreferrer">sourceNodes</a></code>API。</p>
<p>一个直接的用例是当自动生成的方案中的一个特定字段有一个没有明确定义的类型时。例如，下面的代码块是一个作者的Gatsby的GraphQL层中自动生成的节点表示:</p>
<pre>type AuthorJson implements Node {
  id: ID!
  parent: Node!
  children: [Node!]!
  internal: Internal!
  name: String
  firstName: String
  email: String
  joinedAt: Date
}
// Below is the query that results to the Scheme above.
[
  {
    "name": "Doe",
    "firstName": "Jane",
    "email": "<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="6f050e010a2f0a170e021f030a410c0002">[email protected]</a>",
    "joinedAt": "2018-01-01"
  }
]</pre>
<blockquote><p>值得注意的是，<code>author.json</code>中的数据本身并不提供关于作者字段的类型信息。</p>
<p>为了将数据形状转换成GraphQL类型定义，Gatsby必须检查每个字段的内容并检查其类型。这种方法的问题在于它非常耗时，并且还会导致可伸缩性问题。此外，如果一个字段中的值属于不同的类型，Gatsby无法确定哪一个是正确的。这样做的后果是，如果数据源发生变化，类型推断可能会突然失败。</p></blockquote>
<p>在添加新作者的情况下，我们可以从下面的代码块中看到,<code>joinedAt</code>的类型是<code>Date</code>和<code>String</code>值:</p>
<pre>{
  "name": "Doe",
  "firstName": "John",
   "email": "<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="ef85808781af8a978e829f838ac18c8082">[email protected]</a>",
   "joinedAt": "201-04-02"
 }
]</pre>
<p>通过使用<a href="https://www.gatsbyjs.org/docs/actions/#createTypes" target="_blank" rel="noopener noreferrer"> <code>createTypes</code> </a>动作向Gatsby提供显式类型定义，我们可以确保模式将只显示一个<code>Date</code>类型。它接受GraphQL模式定义语言中的类型定义:</p>
<pre>exports.createSchemaCustomization = ({ actions }) =&gt; {
  const { createTypes } = actions
  const typeDefs = `
    type AuthorJson implements Node {
      joinedAt: Date
    }
  `
  createTypes(typeDefs)
}</pre>
<blockquote><p>注意:其余的字段不必提供，它们仍将由Gatsby的类型推断来处理。</p></blockquote>
<p>你也可以完全控制这个方案，看看官方文档了解更多信息。</p>
<h3>添加第三方架构</h3>
<p>除了能够定制现有模式之外，Gatsby还提供了在构建前端时从其他应用程序导入现有模式的能力，而无需修改。使用<code><a href="https://www.gatsbyjs.org/docs/actions/#addThirdPartySchema" target="_blank" rel="noopener noreferrer">addThirdPartySchema</a></code> API可以做到这一点，模式必须是graphql-js GraphQLSchema对象。</p>
<p>值得注意的是，该模式很容易破坏主Gatsby模式，因此建议确保这种情况不会发生(例如，通过给模式命名空间):</p>
<pre>addThirdPartySchema: (
  {schema }: { schema: GraphQLSchema },
  plugin: IGatsbyPlugin,
  traceId?: string):
 IAddThirdPartySchema =&gt; {
  return {
  type: `ADD_THIRD_PARTY_SCHEMA`,
    traceId,
  payload: schema,
  }
},</pre>
<h3>从其他节点扩展/转换节点</h3>
<blockquote><p>“节点”是盖茨比数据系统的中心。添加到Gatsby的所有数据都是使用节点建模的。</p></blockquote>
<p>当创建一个插件来作用于Gatsby代码库时，它被称为<a href="https://www.gatsbyjs.org/docs/node-interface/" target="_blank" rel="noopener noreferrer">节点创建</a>。</p>
<p>有不同类型的<a href="https://www.gatsbyjs.org/docs/plugins/" target="_blank" rel="noopener noreferrer"> Gatsby插件</a>，随着用例的出现，可以创建插件来作用于其他插件，以将数据从一种格式(例如CSV、YAML)转换为JavaScript对象。他们通常遵循命名惯例<code>gatsby-transformer-*</code>。这些插件被称为transformer插件，例如<code><a href="https://github.com/gatsbyjs/gatsby/tree/master/packages/gatsby-transformer-yaml" target="_blank" rel="noopener noreferrer">gatsby-transformer-yaml</a></code>。</p>
<p>上面使用了<code>onCreateNode</code> API来扩展或转换其他插件创建的节点。大多数API代码都在<code>gatsby-node.js</code>文件中实现。下面是Yaml如何转换成JavaScript对象的代码示例:</p>
<pre>const jsYaml = require(`js-yaml`)
const _ = require(`lodash`)

async function onCreateNode({
  node,
  actions,
  loadNodeContent,
  createNodeId,
  createContentDigest,
}) {
  function transformObject(obj, id, type) {
    const yamlNode = {
      ...obj,
      id,
      children: [],
      parent: node.id,
      internal: {
        contentDigest: createContentDigest(obj),
        type,
      },
    }
    createNode(yamlNode)
    createParentChildLink({ parent: node, child: yamlNode })
  }

  const { createNode, createParentChildLink } = actions

  if (node.internal.mediaType !== `text/yaml`) {
    return
  }

  const content = await loadNodeContent(node)
  const parsedContent = jsYaml.load(content)

  parsedContent.forEach((obj, i) =&gt; {
    transformObject(
      obj,
      obj.id ? obj.id : createNodeId(`${node.id} [${i}] &gt;&gt;&gt; YAML`),
      _.upperFirst(_.camelCase(`${node.name} Yaml`))
    )
  })
}

exports.onCreateNode = onCreateNode</pre>
<p>要获得更多关于这个API如何工作的信息，你可以查看官方的Gatsby文档。</p>
<h3>自定义Webpack配置</h3>
<p>您的定制Webpack配置可以作为插件来支持您的特定用例，也可以贡献给社区。如果您想处理您的捆绑逻辑，可以在<code>gatsby-node.js</code>中使用<code>onCreateWebpackConfig</code>来完成。</p>
<p>默认情况下，Gatsby处理配置略有不同的多个Webpack构建。当Gatsby创建它的Webpack配置时，这个函数将被调用，允许您使用<a href="https://github.com/survivejs/webpack-merge" target="_blank" rel="noopener noreferrer"> webpack-merge </a>修改默认的Webpack配置。</p>
<h3>replaceWebpackConfig</h3>
<p>您可以使用<code>replaceWebpackConfig</code>来完全控制配置合并逻辑:</p>
<pre>actions.replaceWebpackConfig = () =&gt; {
  return {
    type: `REPLACE_WEBPACK_CONFIG`,
    plugin,
    payload:config,
  }
}</pre>
<p>如果插件选项被改变或者与<code>gatsby-config.js</code>中的原始插件配置有冲突，这可能是危险的并且会破坏Gatsby。一般来说，这仅在您需要自己处理配置合并逻辑的情况下有用，在这种情况下可以考虑使用<code>webpack-merge</code>。</p>
<h2>结论</h2>
<p>在本文中，我们研究了一些API，它们可以帮助创建插件，并以更容易理解的方式扩展Gatsby的功能。我们还看了展示实现的代码示例。我希望看到更多使用这些API的实现。快乐编码。😄</p><div class="code-block code-block-2">
<div class="blog-plug base-cta"><h2>使用<a class="signup" href="https://lp.logrocket.com/blg/signup" target="_blank" rel="noopener noreferrer"> LogRocket </a>消除传统错误报告的干扰</h2>
<a href="https://lp.logrocket.com/blg/signup" class="signup" target="_blank" rel="noopener noreferrer"><img class="alignnone size-full wp-image-46 jetpack-lazy-image" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/><noscript><img data-lazy-fallback="1" class="alignnone size-full wp-image-46" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/></noscript></a>
<p><a href="https://lp.logrocket.com/blg/signup" target="_blank" rel="noopener noreferrer"> LogRocket </a>是一个数字体验分析解决方案，它可以保护您免受数百个假阳性错误警报的影响，只针对几个真正重要的项目。LogRocket会告诉您应用程序中实际影响用户的最具影响力的bug和UX问题。</p>
<p>然后，使用具有深层技术遥测的会话重放来确切地查看用户看到了什么以及是什么导致了问题，就像你在他们身后看一样。</p>
<p>LogRocket自动聚合客户端错误、JS异常、前端性能指标和用户交互。然后LogRocket使用机器学习来告诉你哪些问题正在影响大多数用户，并提供你需要修复它的上下文。</p>
<p>关注重要的bug—<a class="signup" href="https://lp.logrocket.com/blg/signup-issue-free" target="_blank" rel="noopener noreferrer">今天就试试LogRocket】。</a></p></div></div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
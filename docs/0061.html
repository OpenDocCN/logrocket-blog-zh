<html>
<head>
<title>React Suspense: Async rendering in React - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>React悬念:React - LogRocket博客中的异步渲染</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/async-rendering-react-suspense/#0001-01-01">https://blog.logrocket.com/async-rendering-react-suspense/#0001-01-01</a></blockquote><div><article class="article-post">
<p><em> <strong>编者按</strong>:这篇博文更新于2021年8月30日，包含了关于React悬念的最新信息。</em></p>
<p>悬念是React 16.6中引入的React新特性。它旨在帮助处理异步操作，让您等待一些代码加载，并在等待时声明性地指定加载状态(像一个微调器)。</p>
<p>它允许您推迟呈现应用程序树的一部分，直到满足某些条件(例如，加载了来自端点或资源的数据)。虽然本文将重点关注悬念的数据获取应用程序，但悬念也可以用于获取其他资源，如图像、脚本或其他异步工作。</p>
<p>在本文中，我们将探索悬念，看看这个特性将对React应用程序的构建方式产生什么样的潜在影响。</p>
<p>在我们继续这篇文章之前，请注意React悬念是一个实验性的功能，仍然在经历变化，特别是随着React 18的即将发布。</p>
<h2>为什么反应悬疑？</h2>
<p>您很有可能遇到过利用加载图标作为正在获取数据的指示器的spa。这是一种常用方法，用于确保从外部来源获取数据的应用程序具有良好的UX。您所要做的就是检查数据是否已经成功获取，如果没有，就显示一个微调器。</p>
<p>但是，当数据获取过程变得复杂时，这可能无法扩展:</p>
<ul>
<li>当父组件和子组件都有加载状态时</li>
<li>当您需要一个组件在其他(子)组件加载后才加载时</li>
</ul>
<p>要看到悬疑在行动，让我们来对比一下经典的条件渲染方法对悬疑的实现。</p>
<p>我已经在这个<a href="https://github.com/yomete/react-suspense" target="_blank" rel="noopener"> GitHub库</a>中构建了经典的条件渲染方法，您可以查看一下。代码库是一个从<a href="https://www.tvmaze.com/api" target="_blank" rel="noopener"> TVMaze </a>获取数据的React应用程序，这是一个免费的公共API，可以让你搜索关于电视节目的信息。</p>
<p>这里感兴趣的主要文件是<code>Shows/index.js</code>文件，它负责获取所需的数据并呈现出来:</p>
<pre>import axios from "axios";
import { useEffect, useState } from "react";
import * as Styles from "./styles";
const formatScore = (number) =&gt; {
 return Math.round(number * 100);
};
const Shows = () =&gt; {
 const [isLoaded, setIsLoaded] = useState(false);
 const [shows, setShows] = useState([]);

 useEffect(() =&gt; {
   axios(`https://api.tvmaze.com/search/shows?q=heist`)
     .then((r) =&gt; {
       console.log(r);
       setShows(r.data);
       setIsLoaded(true);
     })
     .catch((e) =&gt; {
       setIsLoaded(false);
       console.log(e);
     });
 }, []);

 return (
   &lt;Styles.Root&gt;
     {!isLoaded &amp;&amp; &lt;p&gt;loading...&lt;/p&gt;}
     {isLoaded &amp;&amp; (
       &lt;Styles.Container&gt;
         {shows.map((show, index) =&gt; (
           &lt;Styles.ShowWrapper key={index}&gt;
             &lt;Styles.ImageWrapper&gt;
               &lt;img
                 src={show.show.image ? show.show.image.original : ""}
                 alt="Show Poster"
               /&gt;
             &lt;/Styles.ImageWrapper&gt;

             &lt;Styles.TextWrapper&gt;
               &lt;Styles.Title&gt;{show.show.name}&lt;/Styles.Title&gt;
               &lt;Styles.Subtitle&gt;
                 Score: {formatScore(show.score)}
               &lt;/Styles.Subtitle&gt;
               &lt;Styles.Subtitle&gt;Status: {show.show.status}&lt;/Styles.Subtitle&gt;
               &lt;Styles.Subtitle&gt;
                 Network: {show.show.network ? show.show.network.name : "N/A"}
               &lt;/Styles.Subtitle&gt;
             &lt;/Styles.TextWrapper&gt;
           &lt;/Styles.ShowWrapper&gt;
         ))}
       &lt;/Styles.Container&gt;
     )}
   &lt;/Styles.Root&gt;
 );
};

export default Shows;
</pre>
<p>如上面的代码块所示，该组件有一个<code>useEffect</code>函数，用于从TVMaze的API获取数据，并将其存储在本地状态中。因为我们希望保持应用程序的交互性，不让用户看到一个空屏幕，所以有一个<code>isLoaded</code>状态，它的值是一个布尔值。<code>isLoaded</code>用于根据数据是否已成功提取，在屏幕上显示加载指示器。</p>
<p>这种方法通常被称为“渲染时提取”，因为提取直到组件被渲染后才开始。</p>
<p>现在让我们看看如何使用React悬念重写这个例子。您可以从这里开始<a href="https://github.com/yomete/react-suspense">克隆现有的回购。</a></p>
<p>首先，让我们确保安装了React (alpha)的实验版本，因为悬念仍然是一个实验功能。您可以通过运行以下命令来实现这一点:</p>
<pre class="language-bash hljs">npm install <a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="7f0d1a1e1c0b3f1e130f171e">[email protected]</a> <a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="beccdbdfddca93dad1d3fedfd2ced6df">[email protected]</a></pre>
<p>让我们从向React应用程序添加悬念组件开始。我们需要将所需的组件放在<code>&lt;Suspense /&gt;</code>组件中，以便在所需的数据可用之前，悬念知道哪些组件需要成为<code>blocked</code>。</p>
<p>我们可以通过用下面的代码块编辑<code>components</code>目录中的<code>App.js</code>文件来做到这一点:</p>
<pre>import React, { Suspense } from "react";
import "./App.css";

const Shows = React.lazy(() =&gt; import("./components/Shows"));

function App() {
 return (
   &lt;div className="App"&gt;
     &lt;header className="App-header"&gt;
       &lt;h1 className="App-title"&gt;React Suspense Demo&lt;/h1&gt;
     &lt;/header&gt;
     &lt;Suspense fallback={&lt;p&gt;loading...&lt;/p&gt;}&gt;
       &lt;Shows /&gt;
     &lt;/Suspense&gt;
   &lt;/div&gt;
 );
}

export default App;
</pre>
<p>在上面的代码块中，<code>Shows</code>组件被一个<code>Suspense</code>组件包装，后者有一个<code>fallback</code>道具。这意味着当组件<code>Shows</code>等待一些异步操作时，比如从TVMaze的API中获取节目，React将把<code>&lt;p&gt;loading...&lt;/p&gt;</code>呈现给DOM。然后，只有在承诺和API被解析之后，才会呈现<code>Shows</code>组件。</p>
<p>悬念本身不是一个数据获取库。相反，它是一种机制，让数据读取库进行通信，以对组件正在读取的数据尚未准备好做出反应。</p>
<p>目前，将悬念与数据获取库结合使用的方法是利用一种称为资源的机制。</p>
<p>资源是暂记异步数据的来源。资源只是一个返回<code>read</code>方法的对象。<code>read</code>方法要么返回异步数据的结果，要么返回一个错误。React Suspense将根据内部工作需要调用该方法。</p>
<p>接下来，让我们为这个例子创建存放资源的文件。在<code>components</code>目录下创建一个新文件<code>fetchShows.js</code>。用下面的代码块编辑它:</p>
<pre>import axios from "axios";

export const fetchShows = () =&gt; {
 let status = "pending";
 let result;
 let suspender = axios(`https://api.tvmaze.com/search/shows?q=heist`).then(
   (r) =&gt; {
     status = "success";
     result = r.data;
   },
   (e) =&gt; {
     status = "error";
     result = e;
   }
 );
 return {
   read() {
     if (status === "pending") {
       throw suspender;
     } else if (status === "error") {
       throw result;
     } else if (status === "success") {
       return result;
     }
   },
 };
};
</pre>
<p>上面的代码块中，<code>fetchShows</code>函数返回的是<code>read</code>对象，这是悬疑需要的资源。在函数的顶端有一些变量；<code>result</code>变量将保存来自API请求和<code>status</code>的响应，其中包含API请求的当前状态，可以是<code>pending</code>、<code>success</code>或<code>error</code>。</p>
<p>还有一个<code>suspender</code>变量存储API请求本身。在服务器响应之后，<code>status</code>和<code>result</code>变量被更新。下面是<code>read</code>对象的工作方式:</p>
<p>在API的<code>.then()</code>函数中将变量<code>status</code>和<code>result</code>设置为合适的值后，如果<code>status</code>为<code>pending</code>，则<code>read</code>对象自身抛出<code>suspender</code>承诺，该悬念将捕捉并显示<code>fallback</code>组件。</p>
<p>如果状态为完成，<code>read</code>对象返回结果，如果状态为<code>error</code>，<code>read</code>对象抛出<code>result</code>，在这种情况下，这是一个错误实例。</p>
<p>接下来，让我们看看如何在<code>Shows</code>组件中使用资源。用下面的代码块编辑<code>Shows/index.js</code>文件:</p>
<pre>import { fetchShows } from "../fetchShows";
import * as Styles from "./styles";

const resource = fetchShows();

const formatScore = (number) =&gt; {
 return Math.round(number * 100);
};

const Shows = () =&gt; {
 const shows = resource.read();

 return (
   &lt;Styles.Root&gt;
     &lt;Styles.Container&gt;
       {shows.map((show, index) =&gt; (
         &lt;Styles.ShowWrapper key={index}&gt;
           &lt;Styles.ImageWrapper&gt;
             &lt;img
               src={show.show.image ? show.show.image.original : ""}
               alt="Show Poster"
             /&gt;
           &lt;/Styles.ImageWrapper&gt;

           &lt;Styles.TextWrapper&gt;
             &lt;Styles.Title&gt;{show.show.name}&lt;/Styles.Title&gt;
             &lt;Styles.Subtitle&gt;
               Score: {formatScore(show.score)}
             &lt;/Styles.Subtitle&gt;
             &lt;Styles.Subtitle&gt;Status: {show.show.status}&lt;/Styles.Subtitle&gt;
             &lt;Styles.Subtitle&gt;
               Network: {show.show.network ? show.show.network.name : "N/A"}
             &lt;/Styles.Subtitle&gt;
           &lt;/Styles.TextWrapper&gt;
         &lt;/Styles.ShowWrapper&gt;
       ))}
     &lt;/Styles.Container&gt;
   &lt;/Styles.Root&gt;
 );
};

export default Shows;
</pre>
<p>在上面的代码块中，资源从<code>fetchShows</code>导入并初始化为<code>resource</code>变量。</p><div class="code-block code-block-54">
<hr/>
<h3>更多来自LogRocket的精彩文章:</h3>

<hr/></div>
<p>我们不需要检查是否为空，也不需要显示一个加载指示器，而是只调用<code>resource.read()</code>而不进行任何安全检查。尽管从TVMaze的API获取节目是一个异步过程，但资源是同步使用的，因为悬念负责获取和检查数据。</p>
<p>这种方法通过消除对安全检查、条件呈现、防止竞争条件的需要，使我们的应用程序更干净、更健壮。</p>
<h2>反应悬念<code>ErrorBoundary</code></h2>
<p>悬疑要考虑的另一件事是它如何处理错误。我们在资源文件<code>fetchShows.js</code>中抛出一个错误，但是我们没有做任何事情来通知用户发生了一些错误。</p>
<p>React提供了错误边界来帮助解决这个问题。<a href="https://blog.logrocket.com/handling-javascript-errors-react-error-boundaries/" target="_blank" rel="noopener">错误边界</a>是React组件，它捕捉子组件树中任何地方的JavaScript错误，记录这些错误，并显示一个回退UI，而不是崩溃的组件树。因为如果资源文件中有错误，我们会抛出一个错误，这意味着我们可以创建一个<code>ErrorBoundary</code>组件，并将其嵌入到我们的组件树中。</p>
<p>因此，让我们创建错误边界组件，以便在我们的项目中使用。在<code>src/components</code>目录下创建一个文件<code>ErrorBoundary.js</code>:</p>
<pre>import React from "react";

// Error boundaries currently have to be classes.
class ErrorBoundary extends React.Component {
 state = { hasError: false, error: null };
 static getDerivedStateFromError(error) {
   return {
     hasError: true,
     error,
   };
 }
 render() {
   if (this.state.hasError) {
     return this.props.fallback;
   }
   return this.props.children;
 }
}

export default ErrorBoundary;
</pre>
<p>然后可以在<code>App.js</code>文件中使用<code>ErrorBoundary</code>组件，如下所示:</p>
<pre>import React, { Suspense } from "react";

import ErrorBoundary from "./components/ErrorBoundary";
import "./App.css";

const Shows = React.lazy(() =&gt; import("./components/Shows"));

function App() {
 return (
   &lt;div className="App"&gt;
     &lt;header className="App-header"&gt;
       &lt;h1 className="App-title"&gt;React Suspense Demo&lt;/h1&gt;
     &lt;/header&gt;
     &lt;ErrorBoundary fallback={&lt;p&gt;Could not fetch TV shows.&lt;/p&gt;}&gt;
       &lt;Suspense fallback={&lt;p&gt;loading...&lt;/p&gt;}&gt;
         &lt;Shows /&gt;
       &lt;/Suspense&gt;
     &lt;/ErrorBoundary&gt;
   &lt;/div&gt;
 );
}

export default App;
</pre>
<p>您可以通过将<code>fetchShows</code>文件中的API URL编辑为无效并显示<code>ErrorBoundary</code>组件来测试这一点。</p>
<h2><strong>结论</strong></h2>
<p>通过暂停，您可以在加载异步数据时暂停组件渲染。您可以暂停任何状态更新，直到数据准备就绪，并且您可以向树深处的任何组件添加异步加载，而无需通过您的应用程序检查所有属性和状态并提升逻辑。</p>
<p>这为快速网络带来了即时和流畅的用户界面，并为慢速网络带来了有意设计的加载状态，而不是一般的加载状态。</p>
<p>值得注意的是，这些API仍处于实验模式，不适合生产。最好始终与React团队保持一致，了解任何API变化和悬念功能的更新。</p>
<p>上述悬念演示的代码库可以在<a href="https://github.com/yomete/react-suspense/tree/suspense" target="_blank" rel="noopener"> GitHub </a>上访问，现场演示可以在<a href="https://codesandbox.io/s/fragrant-architecture-9rp4c?file=/src/components/fetchShows.js" target="_blank" rel="noopener"> CodeSandbox </a>上看到。</p><div class="code-block code-block-17">
<div class="blog-plug inline-plug react-plug" vwo-el-id="26283398190">
<h2 vwo-el-id="41600691720">使用LogRocket消除传统反应错误报告的噪音</h2>
<a href="https://lp.logrocket.com/blg/react-signup-issue-free" target="_blank" vwo-el-id="19356441070">LogRocket
</a><p>是一款React analytics解决方案，可保护您免受数百个误报错误警报的影响，只针对少数真正重要的项目。LogRocket告诉您React应用程序中实际影响用户的最具影响力的bug和UX问题。</p><a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="19356441380">
<img class="first-react-image alignnone size-full wp-image-46 jetpack-lazy-image jetpack-lazy-image--handled" src="../Images/f300c244a1a1cf916df8b4cb02bec6c6.png" vwo-el-id="18272717540" data-lazy-loaded="1" data-original-src="https://files.readme.io/27c94e7-Image_2017-06-05_at_9.46.04_PM.png"/>
</a>
<a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="19356441690">
<img class="second-react-image alignnone size-full wp-image-46 jetpack-lazy-image jetpack-lazy-image--handled" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" vwo-el-id="30720362350" data-lazy-loaded="1" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/>
</a>
<a href="https://lp.logrocket.com/blg/react-signup-issue-free" target="_blank" rel="noopener noreferrer" vwo-el-id="35866400580">LogRocket
</a><p>自动聚合客户端错误、反应错误边界、还原状态、缓慢的组件加载时间、JS异常、前端性能指标和用户交互。然后，LogRocket使用机器学习来通知您影响大多数用户的最具影响力的问题，并提供您修复它所需的上下文。</p><p vwo-el-id="28675661060">关注重要的React bug—<a class="signup" href="https://lp.logrocket.com/blg/react-signup-issue-free" target="_blank" rel="noopener noreferrer" vwo-el-id="40093418840">今天就试试LogRocket】。</a></p>
</div></div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
<html>
<head>
<title>How to build a blazingly fast API with Fastify - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>如何用Fastify - LogRocket博客构建一个速度惊人的API</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/how-to-build-a-blazingly-fast-api-with-fastify/#0001-01-01">https://blog.logrocket.com/how-to-build-a-blazingly-fast-api-with-fastify/#0001-01-01</a></blockquote><div><article class="article-post">
<p>Fastify是一个后端web开发框架，具有强大的插件架构和最小的开销。它主要受<a href="https://hapi.dev/" target="_blank" rel="noopener noreferrer">哈比神</a>和<a href="https://expressjs.com/" target="_blank" rel="noopener noreferrer"> Express </a>的启发，是运行在Node.js上最快的web框架之一</p>
<p>Fastify v3.0是最新版本，已于2020年7月初上市。版本3具有一些特殊的新功能，例如:</p>
<ul>
<li>在伪造中运行快速应用程序</li>
<li>日志序列化的变化</li>
<li>模式替换的变化</li>
<li>更好的类型脚本支持</li>
</ul>
<h2 id="anoverviewoffastifysfeatures">Fastify功能概述</h2>
<p>现在，我们已经介绍了Fastify的最新版本更新功能，让我们回顾一下Fastify最重要的功能列表:</p>
<h5>高性能</h5>
<p>根据代码的复杂程度，对于不太复杂的业务逻辑，它每秒可以处理大约30，000个请求</p>
<h5>可扩展性</h5>
<p>钩子、插件和装饰器使它完全可扩展</p>
<h5>基于方案</h5>
<p>在内部，Fastify将一个JSON模式编译成一个高性能函数，可用于路由验证和输出序列化</p>
<h5>记录</h5>
<p>Pino 是一款高性价比的测井仪，用于加快测井速度</p>
<h5>开发人员友好的环境</h5>
<p>这个框架很有表现力，也很容易上手。此外，它允许开发人员在不牺牲性能或安全性的情况下，快速将小项目扩展到更大的高性能应用程序</p>
<h5>打字稿就绪</h5>
<p>TypeScript类型声明文件维护对TypeScript社区的支持</p>
<h2 id="5importantfastifypluginsyoushouldknow">你应该知道的5个重要的Fastify插件</h2>
<p>除了Fastify提供的大量功能，它还有一个强大的插件架构。任何开发人员都可以构建与Fastify协同工作的插件，以创建用于引导API项目的快速构建块。</p>
<p>由外部开发人员开发的插件属于“社区插件”的范畴，而Fastify团队也维护着一些他们自己的插件，他们称之为“核心插件”。然而，重要的是要知道任何社区插件都必须遵循Fastify的最佳实践。</p>
<p>使用核心插件的好处是Fastify团队会主动维护那些插件，但要记住社区插件可能不会维护。</p>
<p>以下是一些需要注意的重要Fastify插件:</p>
<ul>
<li>fastify-auth :由fastify团队开发的一个认证插件，允许你快速地将认证逻辑注入到你的API路径中</li>
<li>fastify-cors :跨源请求对任何应用程序都很重要，fastify-cors可以帮助你管理这一点，而不需要单独安装一个<a href="https://www.npmjs.com/package/cors" target="_blank" rel="noopener noreferrer"> CORS包</a></li>
<li>fastify-jwt :这个插件会用标准的JSON web令牌来装饰你的应用程序。Fastify-jwt在内部使用jsonwebtoken包</li>
<li><a href="https://github.com/fastify/fastify-nextjs" target="_blank" rel="noopener noreferrer">fastify-nextjs</a>:<a href="https://github.com/vercel/next.js" target="_blank" rel="noopener noreferrer">Next</a>是一个在服务器端构建预渲染网站的React框架。这个插件帮助你用Fastify做同样的事情</li>
<li><a href="https://github.com/fastify/fastify-redis" target="_blank" rel="noopener noreferrer"> fastify-redis </a>:这使您的fastify应用程序能够在整个服务器上共享同一个<a href="https://redis.io/" target="_blank" rel="noopener noreferrer"> Redis </a>连接</li>
</ul>
<p>这还不是一个完整的列表。Fastify有<a href="https://www.fastify.io/ecosystem/" target="_blank" rel="noopener noreferrer">多种插件</a>可供选择。</p>
<h2 id="fastifyvskoavsexpress">Fastify vs Koa vs Express</h2>
<p>当然，每个框架都有其优点和缺点——但是每个框架也有其应用。比较多样的框架并不容易。然而，当你选择一个框架时，我试图选择相关的评估标准。</p>
<h3 id="speedcomparison">速度比较</h3>
<p><a href="https://www.fastify.io/benchmarks/" target="_blank" rel="noopener noreferrer">下面是</a>stack share . io的速度对比概述。</p>
<p><a href="https://expressjs.com/" target="_blank" rel="noopener noreferrer"> Express </a> : Express每秒处理的请求量最少。基准测试证明，Express每秒可以处理15978个请求<br/> <a href="https://koajs.com/" target="_blank" rel="noopener noreferrer"> Koa </a> : Koa是比Express更好的选择。它还是一个轻量级框架，每秒处理54，848个请求<br/> <a href="https://www.fastify.io/" target="_blank" rel="noopener noreferrer"> Fastify </a> : Fastify以每秒78，956个请求获得了最好的基准测试结果</p>
<h3 id="pluginsecosystem">插件生态系统</h3>
<p>正如上一节所讨论的，Fastify是这三个框架中唯一一个有大量插件的web框架，它有很大的不同。这对开发人员来说是一大优势，因为他们不必依赖多个框架或包来构建他们的应用程序。Fastify成为一站式解决方案。</p>
<h3 id="typescriptsupport">类型脚本支持</h3>
<p>同样，Fastify是唯一一个开箱即用的支持TypeScript的框架。根据您的Node.js版本，您可能需要安装<code>@types/node</code>。</p>
<h2 id="creatingyourfirstserverwithfastify30">使用Fastify 3.0创建您的第一台服务器</h2>
<p>现在，激动人心的部分来了！本教程将指导您使用Fastify构建第一台服务器，包括以下几个方面:</p>
<ol>
<li>装置</li>
<li>运行您的第一台服务器</li>
<li>向您的API添加路线</li>
<li>使用Fastify插件</li>
<li>添加数据验证功能</li>
</ol>
<p>准备好了吗？我们开始吧。</p>
<h2 id="1installationandrequirements">1.安装和要求</h2>
<p>首先，启动一个新的npm项目，使用:</p>
<pre>npm init -y</pre>
<p>接下来，让我们将Fastify依赖项添加到项目中。</p>
<p>使用npm:</p>
<pre>npm i fastify --save</pre>
<p>使用纱线:</p>
<pre>yarn add fastify</pre>
<p>确保您的系统上安装了最新版本的Node.js。可以使用<a href="https://github.com/nvm-sh/nvm#installing-and-updating" target="_blank" rel="noopener noreferrer"> nvm </a>(节点版本管理器)在不同Node.js版本之间快速切换。你还需要一个工具来发送请求，比如<a href="https://curl.haxx.se/" target="_blank" rel="noopener noreferrer">卷毛</a>或者<a href="https://www.postman.com/" target="_blank" rel="noopener noreferrer">邮递员</a>。</p>
<h2 id="2createserverjs">2.创建server.js</h2>
<p>接下来，让我们在项目的根目录下创建一个名为<code>server.js</code>的新文件。将以下代码添加到您的<code>server.js</code>文件中:</p>
<pre>const fastify = require('fastify')({ logger: true })

//Add routes here, discussed in further steps

//@Server
fastify.listen(5000, (err) =&gt; {
  if (err) {
    console.log(err)
    process.exit(1)
  } else {
    console.log(`Server running, navigate to  https://localhost:5000`)
  }
})</pre>
<p>如您所见，listen函数在端口<code>5000</code>上启动服务器。它还接受一个接受一个参数的回调，该参数可以包含一个错误对象。这是运行Fastify API的最基本的服务器设置。</p>
<p>如果您想尝试这个基本设置，您可以使用<code>node</code>命令来运行<code>server.js</code>文件，如下所示:</p>
<pre><code class="bash language-bash">node server.js
</code></pre>
<p>这将在地址<a href="http://localhost:5000" rel="nofollow"> http://localhost:5000 </a>上启动您的服务器。如果您尝试导航到该地址，您会看到一条错误消息，指出该路由不存在，因为我们尚未定义任何路由。现在我们需要添加一些简单的<a href="https://blog.logrocket.com/crud-with-node-graphql-react/" target="_blank" rel="noopener noreferrer"> CRUD路线</a>。</p>
<h2 id="3addingcrudroutes">3.添加CRUD路线</h2>
<p>让我们在应用程序中添加一些基本的CRUD路径。首先，让我们添加一个GET路线。</p>
<h3 id="31getroute">3.1获取路线</h3>
<p>假设我们有一个类型为数组的堆栈对象。首先，我们想添加一个GET route来检索这个数组的内容。为此，我们可以使用Fastify对象来定义一条<code>get</code>路线。第一个参数接受我们希望将路由附加到的路径，第二个参数接受一个回调，该回调向您的客户端发回一个回复。</p>
<pre>const stack = []

//@Routes
fastify.get('/getStack', (request, reply) =&gt; {
  reply.send(stack)
})</pre>
<h3 id="32postroute">3.2邮寄路线</h3>
<p>接下来，让我们尝试使用POST route向堆栈数组添加项。这样，我们就可以根据我们的请求发送数据。这里我们期望用户发送一个JSON对象，带有一个名为<code>item</code>的参数。我们将这个<code>item</code>压入堆栈数组。现在我们可以使用回调函数<code>request</code>的第一个参数，它包含与POST请求一起发送的数据。</p>
<pre>fastify.post('/addItem', (request, reply) =&gt; {
    const item = request.body.item
    stack.push(item)
    reply.send(stack)
})</pre>
<p>同样的原则也适用于其他路由方法，如PUT、DELETE、HEAD、PATCH和OPTIONS。关于<a href="https://www.fastify.io/docs/latest/Routes/#routes-option" target="_blank" rel="noopener noreferrer">路线选项</a>的更多信息可以在Fastify文档中找到。</p>
<h3 id="33finalroutingcode">3.3最终路由代码</h3>
<p>您的最终路由代码应该如下所示:</p>
<pre>const fastify = require('fastify')({ logger: true })

const stack = []

//@Routes
fastify.get('/getStack', (request, reply) =&gt; {
  reply.send(stack)
})

fastify.post('/addItem', (request, reply) =&gt; {
    const item = request.body.item
    stack.push(item)
    reply.send(stack)
})

//@Server
fastify.listen(5000, (err) =&gt; {
  if (err) {
    console.log(err)
    process.exit(1)
  } else {
    console.log(`Server running, navigate to  https://localhost:5000`)
  }
})</pre>
<p>现在让我们试试我们创建的代码。首先用<code>node server.js</code>启动服务器。接下来，访问下面的路由<a href="http://localhost:5000/getStack" rel="nofollow">http://localhost:5000/get stack</a>，它应该会返回一个空的数组对象。</p>
<p>让我们使用cURL向堆栈中添加一个条目。我想在堆栈中添加一个苹果。因此，我发送一个带有键<code>item</code>和值<code>apple</code>的JSON对象。</p><div class="code-block code-block-54">
<hr/>
<h3>更多来自LogRocket的精彩文章:</h3>

<hr/></div>
<pre><code class="bash language-bash">curl --header "Content-Type: application/json" --request POST --data '{"item": "apple"}' http://localhost:5000/addItem
</code></pre>
<p>如果您再次访问<a href="http://localhost:5000/getStack" rel="nofollow">http://localhost:5000/get stack</a>，您会注意到堆栈数组中填充了<code>apple</code>项。</p>
<p>一切都好吗？让我们添加一个插件！</p>
<h2 id="4addaplugintoyourfastifyapi">4.向您的Fastify API添加插件</h2>
<p>为了演示添加和使用fastify插件是多么容易，让我们安装<a href="https://github.com/fastify/fastify-routes" target="_blank" rel="noopener noreferrer"> fastify-routes </a>，这使我们能够使用Fastify实例检索所有注册路线的地图。</p>
<p>首先，从CLI安装Fastify-routes依赖项:</p>
<pre><code class="bash language-bash">npm i fastify-routes
</code></pre>
<p>安装插件后，在注册任何路由之前，通过包含插件来注册插件。</p>
<p>下面是包含<code>fastify-routes</code>插件的<code>server.js</code>文件的一个片段。我还添加了一个<code>console.log</code>语句，展示了如何使用插件返回所有注册的路线。</p>
<pre>const fastify = require('fastify')({ logger: true })
fastify.register(require('fastify-routes')) // Add and register plugin

const stack = []

//@Routes
fastify.get('/getStack', (request, reply) =&gt; {
    reply.send(stack)
})

fastify.post('/addItem', (request, reply) =&gt; {
    const item = request.body.item
    stack.push(item)
    reply.send(stack)
})

//@Server
fastify.listen(5000, (err) =&gt; {
    console.log(fastify.routes) // Log all registered routes
    if (err) {
        console.log(err)
        process.exit(1)
    } else {
        console.log(`Server running, navigate to  https://localhost:5000`)
    }
})</pre>
<p>现在，当您使用<code>node server.js</code>启动服务器时，您的CLI将打印所有注册的路由。</p>
<p>这个插件演示了在你的服务器上添加插件是多么容易。你不需要初始化它们。构成您的服务器的<code>fastify</code>对象也作为所有注册插件的父对象，您可以从这个<code>fastify</code>对象直接调用它们。</p>
<p>最后，让我们为我们的服务器添加一些基本的数据验证。</p>
<h2 id="5adddatavalidation">5.添加数据验证</h2>
<p>作为本教程的最后一部分，让我们为您的路径添加数据验证。具体来说，我们希望为之前创建的POST路由添加验证。让我们验证一下body对象是否包含了<code>item</code>属性，数据类型是否应该与<code>string</code>类型相匹配。</p>
<p>幸运的是，Fastify允许我们为路由定义验证模式。下面是一个验证<code>item</code>属性是否存在并包含一个<code>string</code>的例子。此外，我们告诉Fastify服务器，我们不允许使用<code>additionalProperties: false</code>设置在body对象上添加任何附加属性。</p>
<p>您还可以定义一个响应属性来描述请求成功时的响应。</p>
<p>下面是添加数据验证选项后的完整代码。不要忘记添加<code>itemValidation</code>作为POST路线的第二个参数。</p>
<pre>const fastify = require('fastify')({ logger: true })
fastify.register(require('fastify-routes'))

const itemValidation = { // Define validation
    schema: {
        body: {
            type: 'object',
            additionalProperties: false,
            required: [
                'item'
            ],
            properties: {
                item: { type: 'string' }
            }
        },
        response: {
            201: {
                type: 'object',
                properties: {
                    item: { type: 'string' }
                }
            }
        }
    }
}

const stack = []

//@Routes
fastify.get('/getStack', (request, reply) =&gt; {
    reply.send(stack)
})

fastify.post('/addItem', itemValidation, (request, reply) =&gt; { // Add validation options to POST route
    const item = request.body.item
    stack.push(item)
    reply.send(stack)
})

//@Server
fastify.listen(5000, (err) =&gt; {
    console.log(fastify.routes)
    if (err) {
        console.log(err)
        process.exit(1)
    } else {
        console.log(`Server running, navigate to  https://localhost:5000`)
    }
})</pre>
<p>让我们通过向我们的服务器发送相同的请求，添加<code>apple</code>项，再次尝试代码。这个请求应该被成功执行。</p>
<pre><code class="bash language-bash">curl --header "Content-Type: application/json" --request POST --data '{"item": "apple"}' http://localhost:5000/addItem
</code></pre>
<p>接下来，让我们尝试发送一个包含空对象的项目，这样我们就可以测试服务器是否拒绝请求。将以下请求发送到您的服务器，以验证数据验证实施。</p>
<pre><code class="bash language-bash">curl --header "Content-Type: application/json" --request POST --data '{"item": {}}' http://localhost:5000/addItem
</code></pre>
<p>服务器应该向您发送以下错误消息:</p>
<pre><code class="json language-json">{"statusCode":400,"error":"Bad Request","message":"body.item should be string"}
</code></pre>
<p>一切都好吗？恭喜你！您已经成功完成了您的第一个Fastify API服务器。</p>
<h2 id="conclusion">结论</h2>
<p>我希望您喜欢使用Fastify构建一个简单的CRUD API，同时实现数据验证和添加插件。</p>
<p>还有更多的插件，所以一定要看看Fastify插件生态系统看看有什么可用的。插件有助于快速引导你的API，消除从头构建API的需要。</p>
<p>请随意查看Fastify提供的以下概念:</p>

<p>就这样，伙计们！完整的代码可以在我的GitHub库上找到。</p><div class="code-block code-block-1">
<div class="blog-plug base-cta"><h2>使用<a class="signup" href="https://lp.logrocket.com/blg/signup" target="_blank" rel="noopener noreferrer"> LogRocket </a>消除传统错误报告的干扰</h2>
<a href="https://lp.logrocket.com/blg/signup" class="signup" target="_blank" rel="noopener noreferrer"><img class="alignnone size-full wp-image-46 jetpack-lazy-image" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/><noscript><img data-lazy-fallback="1" class="alignnone size-full wp-image-46" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/></noscript></a>
<p><a href="https://lp.logrocket.com/blg/signup" target="_blank" rel="noopener noreferrer"> LogRocket </a>是一个数字体验分析解决方案，它可以保护您免受数百个假阳性错误警报的影响，只针对几个真正重要的项目。LogRocket会告诉您应用程序中实际影响用户的最具影响力的bug和UX问题。</p>
<p>然后，使用具有深层技术遥测的会话重放来确切地查看用户看到了什么以及是什么导致了问题，就像你在他们身后看一样。</p>
<p>LogRocket自动聚合客户端错误、JS异常、前端性能指标和用户交互。然后LogRocket使用机器学习来告诉你哪些问题正在影响大多数用户，并提供你需要修复它的上下文。</p>
<p>关注重要的bug—<a class="signup" href="https://lp.logrocket.com/blg/signup-issue-free" target="_blank" rel="noopener noreferrer">今天就试试LogRocket】。</a></p></div></div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
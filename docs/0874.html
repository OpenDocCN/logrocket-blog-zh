<html>
<head>
<title>Web storage made simple with use-local-storage-state - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>使用本地存储状态日志博客使网络存储变得简单</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/web-storage-made-simple-use-local-storage-state/#0001-01-01">https://blog.logrocket.com/web-storage-made-simple-use-local-storage-state/#0001-01-01</a></blockquote><div><article class="article-post">
<p>use-local-storage-state包通过将<code>localStorage</code>的使用抽象到一个React钩子中，使得在浏览器中持久化数据变得更加容易。它可以保存数据并自动解析它们，我们可以在应用程序的多个地方使用它。</p>
<p>在这篇文章中，我们将看看如何使用钩子来帮助我们更简单地在React应用中使用<code>localStorage</code>。</p>
<h2>入门指南</h2>
<p>首先，我们通过编写以下内容来安装该软件包:</p>
<pre>npm install use-local-storage-state</pre>
<p>那么我们可以如下使用它:</p>
<pre>import React, { useEffect } from "react";
import useLocalStorageState from "use-local-storage-state";

export default function App() {
  const [todos, setTodos] = useLocalStorageState("todos", []);

  useEffect(() =&gt; {
    setTodos(["eat", "drink"]);
  }, []);

  return (
    &lt;div className="App"&gt;
      {todos.map((t, i) =&gt; (
        &lt;p key={i}&gt;{t}&lt;/p&gt;
      ))}
    &lt;/div&gt;
  );
}</pre>
<p>我们从use-local-storage-state导入了<code>useLocalStorageState</code>钩子，然后将钩子放在我们的<code>App</code>组件中。为了在组件加载时设置组件的值，我们在第二个参数中使用带有空数组的<code>useEffect</code>钩子，这样它只在<code>App</code>第一次渲染时加载。一旦我们这样做了，<code>todos</code>从钩子中得到值，我们可以在返回的<code>div</code>中呈现它们。</p>
<p>如果我们查看浏览器控制台的<code>localStorage</code>部分，它位于Chrome控制台的<strong>应用</strong>选项卡下，我们可以看到键是<code>todos</code>，我们将其设置为<code>useLocalStorageState</code>的第一个参数。它的值<code>["eat", "drink"]</code>，就是我们用<code>setTodo</code>调用的数组。钩子为我们传递了值，而不需要我们使用<code>JSON.stringify</code>，这很方便。</p>
<h2>更新<code>localStorage</code></h2>
<p>为了更新<code>localStorage</code>值，我们可以编写以下代码:</p>
<pre>import React, { useEffect, useState } from "react";
import useLocalStorageState from "use-local-storage-state";

export default function App() {
  const [todos, setTodos] = useLocalStorageState("todos", []);
  const [todo, setTodo] = useState("");

  const onClick = () =&gt; {
    setTodos([...todos, todo]);
    setTodo("");
  };

  useEffect(() =&gt; {
    setTodos(["eat", "drink"]);
  }, []);

  return (
    &lt;div className="App"&gt;
      &lt;input value={todo} onChange={e =&gt; setTodo(e.target.value)} /&gt;
      &lt;button onClick={onClick}&gt;Create&lt;/button&gt;
      {todos.map((t, i) =&gt; (
        &lt;p key={i}&gt;{t}&lt;/p&gt;
      ))}
    &lt;/div&gt;
  );
}</pre>
<p>我们添加了一个输入元素和一个<code>onClick</code>处理程序来将条目添加到<code>todos</code>数组中。这将自动保存在<code>localStorage</code>中，因为我们调用了<code>useLocalStorageState</code>返回的<code>setTodos</code>函数。</p>
<h2>删除项目</h2>
<p>要删除一个待办事项，我们可以写:</p>
<pre>import React, { useEffect, useState } from "react";
import useLocalStorageState from "use-local-storage-state";

export default function App() {
  const [todos, setTodos] = useLocalStorageState("todos", []);
  const [todo, setTodo] = useState("");

  const onClick = () =&gt; {
    setTodos([...todos, todo]);
    setTodo("");
  };

  const onDelete = index =&gt; {
    const newTodos = todos.filter((_, i) =&gt; i !== index);
    setTodos(newTodos);
  };

  useEffect(() =&gt; {
    setTodos(["eat", "drink"]);
  }, []);

  return (
    &lt;div className="App"&gt;
      &lt;input value={todo} onChange={e =&gt; setTodo(e.target.value)} /&gt;
      &lt;button onClick={onClick}&gt;Create&lt;/button&gt;
      {todos.map((t, i) =&gt; (
        &lt;p key={i}&gt;
          {t} &lt;button onClick={onDelete.bind(undefined, i)}&gt;Delete&lt;/button&gt;
        &lt;/p&gt;
      ))}
    &lt;/div&gt;
  );
}</pre>
<p>我们添加了一个<code>onDelete</code>函数，它调用<code>todo</code>数组上的<code>filter</code>来返回一个没有指定索引的新数组。然后我们传递返回给<code>setTodos</code>的<code>newTodos</code>数组。</p>
<p>为了让<code>index</code>进入函数，我们在<code>Delete</code>按钮的<code>onClick</code>中加入了<code>onDelete.bind(undefined, i)</code>。<code>bind</code>返回一个新函数，它有我们想要传入的参数，在本例中，这些参数是我们想要删除的条目的索引。</p>
<h2>编辑一个项目并在多个地方使用同一个钩子</h2>
<p>为了添加编辑功能，我们希望创建一个组件来显示值并允许我们执行编辑。为此，我们写道:</p>
<pre>import React, { useEffect, useState } from "react";
import { createLocalStorageStateHook } from "use-local-storage-state";

const useTodos = createLocalStorageStateHook("todos");

const Todo = ({ name, index, onDelete }) =&gt; {
  const [todos, setTodos] = useTodos();
  const [todo, setTodo] = useState("");
  const [editing, setEditing] = useState(false);

  const save = () =&gt; {
    const newTodos = [...todos];
    newTodos[index] = todo;
    setTodos(newTodos);
    setEditing(false);
  };

  useEffect(() =&gt; {
    setTodo(name);
  }, []);

  return (
    &lt;div&gt;
      {(() =&gt; {
        if (editing) {
          return (
            &lt;p&gt;
              &lt;input value={todo} onChange={e =&gt; setTodo(e.target.value)} /&gt;
              &lt;button onClick={save}&gt;Save&lt;/button&gt;
            &lt;/p&gt;
          );
        } else {
          return &lt;p&gt;{name}&lt;/p&gt;;
        }
      })()}
      &lt;button onClick={() =&gt; setEditing(editing =&gt; !editing)}&gt;Edit&lt;/button&gt;
      &lt;button onClick={onDelete}&gt;Delete&lt;/button&gt;
    &lt;/div&gt;
  );
};

export default function App() {
  const [todos, setTodos] = useTodos();
  const [todo, setTodo] = useState("");

  const onClick = () =&gt; {
    setTodos([...todos, todo]);
    setTodo("");
  };

  const onDelete = index =&gt; {
    const newTodos = todos.filter((_, i) =&gt; i !== index);
    setTodos(newTodos);
  };

  return (
    &lt;div className="App"&gt;
      &lt;input value={todo} onChange={e =&gt; setTodo(e.target.value)} /&gt;
      &lt;button onClick={onClick}&gt;Create&lt;/button&gt;
      {todos.map((t, i) =&gt; (
        &lt;Todo key={i} index={i} name={t} onDelete={onDelete.bind(this, i)} /&gt;
      ))}
    &lt;/div&gt;
  );
}</pre>
<p>在上面的代码中，我们创建了一个<code>Todo</code>组件来保存待办事项，输入允许我们编辑待办事项。我们还调用了<code>createLocalStorageStateHook</code>函数，这样我们就可以在<code>Todo</code>和<code>App</code>中共享<code>localStorage</code>的内容。在<code>Todo</code>和<code>App</code>中，我们使用由<code>createLocalStorageStateHook</code>返回的<code>useTodo</code>钩子。</p>
<p>在<code>Todo</code>的<code>save</code>中，我们复制了一个<code>todos</code>数组，并根据<code>index</code>值设置<code>todo</code>的当前值。然后我们调用由<code>useTodos</code>返回的<code>setTodo</code>来保存新的todo项。用<code>false</code>调用<code>setEditing</code>禁用输入。</p>
<p><code>Todo</code>中的<code>onDelete</code>函数来自<code>App</code>。我们在<code>onDelete</code>上调用<code>bind</code>，然后将它作为<code>onDelete</code>的值传入，以便用正确的索引调用它。我们现在可以点击<strong>编辑</strong>，输入新的待办事项值，并将新值保存到<code>localStorage</code>。</p>
<p>另外，请注意，我们移除了<code>App</code>中的<code>useEffect</code>钩子，这样它就可以从<code>localStorage</code>中检索项目，而不是用钩子中的值重置它们。现在我们有了一个完整的待办事项应用程序，我们可以用它来添加、编辑和删除项目。</p>
<h2>结论</h2>
<p>use-local-storage-state包为我们提供了一种在React应用中使用<code>localStorage</code>的简单方法。有了它，我们可以轻松地创建、更新和删除数据。</p>
<p>有了这个，我们就不再需要用<code>JSON.parse</code>或者<code>JSON.stringify</code>来处理<code>localStorage</code>值了。我们要做的就是调用内置钩子返回的函数，这些函数为我们保存值。</p><div class="code-block code-block-17">
<div class="blog-plug inline-plug react-plug" vwo-el-id="26283398190">
<h2 vwo-el-id="41600691720">使用LogRocket消除传统反应错误报告的噪音</h2>
<a href="https://lp.logrocket.com/blg/react-signup-issue-free" target="_blank" vwo-el-id="19356441070">LogRocket
</a><p>是一款React analytics解决方案，可保护您免受数百个误报错误警报的影响，只针对少数真正重要的项目。LogRocket告诉您React应用程序中实际影响用户的最具影响力的bug和UX问题。</p><a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="19356441380">
<img class="first-react-image alignnone size-full wp-image-46 jetpack-lazy-image jetpack-lazy-image--handled" src="../Images/f300c244a1a1cf916df8b4cb02bec6c6.png" vwo-el-id="18272717540" data-lazy-loaded="1" data-original-src="https://files.readme.io/27c94e7-Image_2017-06-05_at_9.46.04_PM.png"/>
</a>
<a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="19356441690">
<img class="second-react-image alignnone size-full wp-image-46 jetpack-lazy-image jetpack-lazy-image--handled" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" vwo-el-id="30720362350" data-lazy-loaded="1" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/>
</a>
<a href="https://lp.logrocket.com/blg/react-signup-issue-free" target="_blank" rel="noopener noreferrer" vwo-el-id="35866400580">LogRocket
</a><p>自动聚合客户端错误、反应错误边界、还原状态、缓慢的组件加载时间、JS异常、前端性能指标和用户交互。然后，LogRocket使用机器学习来通知您影响大多数用户的最具影响力的问题，并提供您修复它所需的上下文。</p><p vwo-el-id="28675661060">关注重要的React bug—<a class="signup" href="https://lp.logrocket.com/blg/react-signup-issue-free" target="_blank" rel="noopener noreferrer" vwo-el-id="40093418840">今天就试试LogRocket】。</a></p>
</div></div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
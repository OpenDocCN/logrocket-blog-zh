<html>
<head>
<title>Smarter Redux with Redux Toolkit - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>使用Redux Toolkit的智能Redux-log rocket博客</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/smarter-redux-redux-toolkit/#0001-01-01">https://blog.logrocket.com/smarter-redux-redux-toolkit/#0001-01-01</a></blockquote><div><article class="article-post">
<p><strong> <em>编者按:</em> </strong> <em>本文于2022年4月22日更新，包含关于Redux-Saga和Redux Toolkit的最新信息。</em></p>
<p>当Redux第一次出现在前台时，许多人认为它是我们所有状态管理问题的解决方案。它与React的联系如此之深，以至于人们开始相信没有Redux的React在某种程度上是不完整的，尽管这个想法被Redux的创造者Dan Abramov断然拒绝。</p>
<p>渐渐地，开发人员开始意识到Redux的局限性，这导致了一系列关于是否有更好的方法来管理全局状态的辩论——事实上，Redux是否是一个可行的解决方案。</p>
<h3>内容</h3>


<p>许多反对Redux的论点都源于许多观点和“最佳实践”,这些观点和“最佳实践”后来被视为需求。(实际上，裸形式的Redux<a href="https://blog.isquaredsoftware.com/2017/05/idiomatic-redux-tao-of-redux-part-1/#the-core-of-redux-createstore">非常简单</a>并且容易理解。)但最受欢迎和持久的批评之一是Redux添加到应用程序中的代码量，许多人认为这是不必要的。</p>
<p>这些争论导致了<a href="https://redux-toolkit.js.org/" target="_blank" rel="noopener"> Redux Toolkit (RTK) </a>的开发，“用于高效Redux开发的官方的、固执己见的、包含电池的工具集。”Redux团队为此付出了巨大的努力，毫无疑问，已经取得了显著的成果。</p>
<p>RTK解决了许多与样板文件和不必要的代码相关的争论。正如其官方文件中提到的，它有助于解决人们对Redux的三个主要问题:</p>
<ol>
<li>“配置Redux存储太复杂”</li>
<li>“我必须添加许多包才能让Redux做任何有用的事情”</li>
<li>“Redux需要太多样板代码”</li>
</ol>
<p>在这里，我们将看到如何利用RTK的API来使我们的Redux应用程序更小但仍然强大。我们将使用React和RTK模板来引导我们的应用程序。</p>
<p>我们的应用程序将具有以下容器架构:</p>
<ul>
<li>Redux，用于状态管理</li>
<li><a href="https://react-redux.js.org/"> R </a> <a href="https://react-redux.js.org/" target="_blank" rel="noopener"> eact-Redux </a>，用于从全局存储和调度动作中选择状态</li>
<li><a href="https://github.com/immerjs/immer" target="_blank" rel="noopener"> Immer </a>，用于处理店内不变性</li>
</ul>
<p>稍后，我们将安装Redux-Saga，看看它如何用于异步任务。</p>
<blockquote><p>一个重要的注意事项:Redux Thunk可以作为异步任务的默认选项与RTK一起使用，强烈推荐用于简单的数据获取任务。你可以在这里找到它的指南<a href="https://redux-toolkit.js.org/tutorials/advanced-tutorial#thinking-in-thunks" target="_blank" rel="noopener">。然而，在本文中，我们将使用Redux-Saga来更好地理解中间件与RTK的集成。如果你不熟悉传奇，那么这篇文章</a><a href="https://blog.logrocket.com/understanding-redux-saga-action-creators-sagas/" target="_blank" rel="noopener">非常值得一读。</a></p></blockquote>
<p>你可以在这里找到应用程序<a href="https://github.com/Chinwike1/rtk-w-redux-saga" target="_blank" rel="noopener">的源代码。</a></p>

<p>Redux最常被讨论的缺陷之一是将其集成到现有应用程序中所需要的努力。Redux Toolkit提供了用Redux Toolkit引导React应用程序的选项。</p>
<p>为此，请在终端中运行以下命令:</p>
<pre class="language-shell hljs">npx create-react-app my-redux-app --template redux
</pre>
<p>下载完成后，在文本编辑器中打开应用程序，我们将检查使Redux <code>store</code>起作用的关键文件:</p>
<pre class="language-javascript hljs">// store.js
import { configureStore } from '@reduxjs/toolkit'
import counterReducer from '../features/counter/counterSlice'

export const store = configureStore({
  reducer: {
    counter: counterReducer,
  },
  // other options e.g middleware, go here
})
</pre>
<p>位于<code>app/store.js</code>的Redux store是我们的Redux工具包应用程序的中心站。这个文件利用了RTK的<code>configureStore</code> API，根据RTK文档，它是标准Redux <code>createStore</code>函数的友好抽象。它为商店设置添加了良好的默认值，以获得更好的开发体验。</p>
<p><code>configureStore</code>接受带有多个参数的单个配置对象，最重要的是<code>reducer</code>。</p>
<p><code>reducer</code>是一个对象，它在我们的应用程序中存储不同的<code>slices</code>，并在Redux store中反映它，正如通过<a href="https://www.google.com/url?sa=t&amp;rct=j&amp;q=&amp;esrc=s&amp;source=web&amp;cd=&amp;cad=rja&amp;uact=8&amp;ved=2ahUKEwjX9Za5ovr2AhXNgf0HHWiFBecQFnoECAYQAQ&amp;url=https%3A%2F%2Fchrome.google.com%2Fwebstore%2Fdetail%2Fredux-devtools%2Flmhkpmbekcpmknklioeibfkpmmfibljd%3Fhl%3Den&amp;usg=AOvVaw0nx2UHMZL6wwwf2BNRTg5T" target="_blank" rel="noopener"> Redux DevTools扩展</a>所看到的。</p>
<p><img data-attachment-id="105228" data-permalink="https://blog.logrocket.com/smarter-redux-redux-toolkit/redux-devtools-extension/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/05/Redux-devtools-extension.jpeg" data-orig-size="325,187" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Redux-devtools-extension" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/05/Redux-devtools-extension-300x173.jpeg" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/05/Redux-devtools-extension.jpeg" decoding="async" class="size-full wp-image-105228 aligncenter jetpack-lazy-image" src="../Images/b613afba0538ff7f1c12cb4834097070.png" alt="Redux-devtools-extension" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2020/05/Redux-devtools-extension.jpeg 325w, https://blog.logrocket.com/wp-content/uploads/2020/05/Redux-devtools-extension-300x173.jpeg 300w" data-lazy-sizes="(max-width: 325px) 100vw, 325px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2020/05/Redux-devtools-extension.jpeg?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/05/Redux-devtools-extension.jpeg"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="105228" data-permalink="https://blog.logrocket.com/smarter-redux-redux-toolkit/redux-devtools-extension/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/05/Redux-devtools-extension.jpeg" data-orig-size="325,187" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Redux-devtools-extension" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/05/Redux-devtools-extension-300x173.jpeg" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/05/Redux-devtools-extension.jpeg" decoding="async" loading="lazy" class="size-full wp-image-105228 aligncenter" src="../Images/b613afba0538ff7f1c12cb4834097070.png" alt="Redux-devtools-extension" srcset="https://blog.logrocket.com/wp-content/uploads/2020/05/Redux-devtools-extension.jpeg 325w, https://blog.logrocket.com/wp-content/uploads/2020/05/Redux-devtools-extension-300x173.jpeg 300w" sizes="(max-width: 325px) 100vw, 325px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/05/Redux-devtools-extension.jpeg"/></noscript>
<p>在我们的模板中,<code>counterSlice</code>被添加到<code>reducer</code>对象中——关于什么是切片的更多解释很快就会出现。</p>
<p>为了使我们应用程序中的所有组件都可以访问我们存储中的数据，来自<code>react-redux</code>的<code>Provider</code>组件用于包装整个应用程序，将Redux存储作为<code>store</code>属性的值:</p>
<pre class="language-javascript hljs">// index.js
import React from 'react';
import ReactDOM from 'react-dom';
import './index.css';
import App from './App';
import { store } from './app/store';
import { Provider } from 'react-redux';

ReactDOM.render(
  &lt;React.StrictMode&gt;
    &lt;Provider store={store}&gt;
      &lt;App /&gt;
    &lt;/Provider&gt;
  &lt;/React.StrictMode&gt;,
  document.getElementById('root')
);
</pre>

<p>尽管Redux不依赖于文件的结构，但它在大型应用程序的维护中起着重要的作用。最好根据功能而不是文件类型对文件进行分组。</p>
<p>广泛采用的ducks模式建议将所有Redux功能保存在一个文件中。如果需要，这个文件将默认导出一个reducer函数以及所有的动作、创建者和常量。它还建议了动作类型的模式。</p>
<p>这个名字来自Redux的最后一部分——dux——并且已经成为Redux应用程序强烈推荐的模式。</p>
<p>RTK遵循ducks模式，在一个名为slice的文件中组合了reducers、actions和constants。每个切片将为存储中的对象提供初始状态和缩减器功能:</p>
<pre class="language-javascript hljs">// counterSlice.js
import { createAsyncThunk, createSlice } from '@reduxjs/toolkit';
import { fetchCount } from './counterAPI';
const initialState = {
  value: 0,
  status: 'idle',
};

// asynchronous function with createAsyncThunk
export const incrementAsync = createAsyncThunk(
  'counter/fetchCount',
  async (amount) =&gt; {
    const response = await fetchCount(amount);
    return response.data;
  }
);

// Redux Toolkit slice
export const counterSlice = createSlice({
  name: 'counter',
  initialState,
  // The `reducers` field lets us define reducers and generate associated actions
  reducers: {
    increment: (state) =&gt; {
      // Redux Toolkit allows us to write "mutating" logic in reducers. It
      // doesn't actually mutate the state because it uses the Immer library,
      // which detects changes to a "draft state" and produces a brand new
      // immutable state based off those changes
      state.value += 1;
    },
    decrement: (state) =&gt; {
      state.value -= 1;
    },
    incrementByAmount: (state, action) =&gt; {
      state.value += action.payload;
    },
  },
  // The `extraReducers` field lets the slice handle actions defined elsewhere,
  // including actions generated by createAsyncThunk or in other slices.
  extraReducers: (builder) =&gt; {
    builder
      .addCase(incrementAsync.pending, (state) =&gt; {
        state.status = 'loading';
      })
      .addCase(incrementAsync.fulfilled, (state, action) =&gt; {
        state.status = 'idle';
        state.value += action.payload;
      });
  },
});
export const { increment, decrement, incrementByAmount } = counterSlice.actions;
// more code...
export default counterSlice.reducer;
</pre>
<p><code>counterSlice</code>文件使用RTK的<code>createSlice</code>方法。这个方法返回一个带有reducers和动作的对象，这些动作可以用于其他中间件的注入。</p>
<h2 id="createslice"><code>createSlice</code></h2>
<p>Redux Toolkit可以使用它的<code>createSlice</code> API替换一系列动作/reducer/常量。它是生成存储片的辅助方法。它采用切片的名称、初始状态和一个reducer函数来返回一个reducer、动作类型和动作创建者。</p>
<p>作为回报，它为我们提供了切片、动作创建者和reducer函数的名称。所有这些都可以用于切片的注入、调度动作和其他情况，这取决于实现。</p>
<p>查看<code>counterSlice.js</code>，我们可以看到<code>createSlice</code>返回一个带有名称和reducers的对象，该对象可以从我们应用程序中的任何地方发送，如下所示:</p>
<pre class="language-javascript hljs">// Counter.js
import React, { useState } from 'react';
import { useDispatch } from 'react-redux';
import {
  increment,
} from './counterSlice';
import styles from './Counter.module.css';
export function Counter() {
  const dispatch = useDispatch();

  return (
    &lt;div&gt;
      &lt;div className={styles.row}&gt;
        &lt;button
          className={styles.button}
          aria-label="Increment value"
          onClick={() =&gt; dispatch(increment())}
        &gt;
          +
        &lt;/button&gt;
      &lt;/div&gt;
    &lt;/div&gt;
  );
}
</pre>
<p>以下是关于<code>createSlice</code>方法参数的一些细节:</p>
<h3><code>name: string</code></h3>
<p>一个名称，用作存储中切片的ID，也用作此缩减器的操作类型的前缀。这唯一标识存储中的切片。</p>
<h3><code>initialState: any</code></h3>
<p>减速器的初始状态。</p>
<h3><code>reducers: Object&lt;string, ReducerFunction | ReducerAndPrepareObject&gt;</code></h3>
<p>RTK中的归约器是对象，其中键用作动作类型，函数是与这些类型相关联的归约器。该键还用作动作类型的后缀，因此最终的动作类型变成了<code>${name}/${actionKey}</code>。</p>
<p>在底层，这个对象被传递给<code>[createReducer](<a href="https://redux-toolkit.js.org/api/createReducer" rel="nofollow">https://redux-toolkit.js.org/api/createReducer</a>)</code>，这是一个RTK实用程序，用于简化reducers的定义。它允许我们将reducers定义为一个函数查找表来处理每种动作类型。这有助于避免动作创建者函数的样板代码。</p>
<p>推荐在reducers中使用不可变的状态管理，Immer是最流行这样做的库之一。RTK允许你使用点符号改变状态，并在引擎盖下使用Immer。更准确地说，<code>createSlice</code>和<code>createReducer</code>用来自Immer的<code>produce</code>包装你的减速器功能。</p><div class="code-block code-block-54">
<hr/>
<h3>更多来自LogRocket的精彩文章:</h3>

<hr/></div>
<h3><code>extraReducers</code></h3>
<p>这也是一个case reducer函数，但是用于除此切片之外的操作。每个切片缩减器在全局存储中拥有自己的切片，但它可以响应任何动作类型，包括由另一个切片生成的动作。</p>
<p>这个API将允许我们在调度另一个片生成的动作时改变当前片的状态。减速器会通过同一个<code>createReducer</code> API，允许安全变异。</p>
<h2 id="accessing-data-store-react-redux">使用React-Redux从存储中访问数据</h2>
<p>使用React-Redux(已经包含在模板中)，我们可以访问两个重要的钩子:<code>useSelector</code>和<code>useDispatch</code>。这些钩子允许我们从Redux存储中读取数据，并将任何片上的动作分派到我们的组件中:</p>
<pre class="language-javascript hljs">// Counter.js
import React, { useState } from 'react';
import { useSelector, useDispatch } from 'react-redux';
import {
  decrement,
  increment,
  incrementByAmount,
  incrementAsync,
  incrementIfOdd,
  selectCount,
} from './counterSlice';
import styles from './Counter.module.css';
export function Counter() {
  const count = useSelector(selectCount);
  const dispatch = useDispatch();
  const [incrementAmount, setIncrementAmount] = useState('2');
  const incrementValue = Number(incrementAmount) || 0;
  return (
    &lt;div&gt;
      &lt;div className={styles.row}&gt;
        &lt;button
          className={styles.button}
          aria-label="Decrement value"
          onClick={() =&gt; dispatch(decrement())}
        &gt;
          -
        &lt;/button&gt;
        &lt;span className={styles.value}&gt;{count}&lt;/span&gt;
        &lt;button
          className={styles.button}
          aria-label="Increment value"
          onClick={() =&gt; dispatch(increment())}
        &gt;
          +
        &lt;/button&gt;
      &lt;/div&gt;
      &lt;div className={styles.row}&gt;
        &lt;input
          className={styles.textbox}
          aria-label="Set increment amount"
          value={incrementAmount}
          onChange={(e) =&gt; setIncrementAmount(e.target.value)}
        /&gt;
        &lt;button
          className={styles.button}
          onClick={() =&gt; dispatch(incrementByAmount(incrementValue))}
        &gt;
          Add Amount
        &lt;/button&gt;
        &lt;button
          className={styles.asyncButton}
          onClick={() =&gt; dispatch(incrementAsync(incrementValue))}
        &gt;
          Add Async
        &lt;/button&gt;
        &lt;button
          className={styles.button}
          onClick={() =&gt; dispatch(incrementIfOdd(incrementValue))}
        &gt;
          Add If Odd
        &lt;/button&gt;
      &lt;/div&gt;
    &lt;/div&gt;
  );
}
</pre>

<p>我们已经讨论了RTK中的两个主要API，它们对大多数情况都很有用。在幕后，这些API利用了其他实用程序，这些实用程序也可以单独使用:</p>
<h3><code>createAction</code></h3>
<p>使用Redux，我们需要定义一个表示动作类型的常量，然后定义一个函数来创建该类型的动作。尽管Redux并不要求这样做，但这有助于我们保持不同存储文件之间的同步。</p>
<p>有了这个API，多重声明的麻烦就没有了。它接受动作类型并返回该类型的动作创建者。返回的动作创建者是用一个参数调用的，这个参数将作为一个有效负载。</p>
<p>这里有一个简单的例子:</p>
<pre class="language-javascript hljs">const increment = createAction('counter/INCREMENT');
// increment() -&gt; { type: 'counter/INCREMENT' }
// increment(5) -&gt; { type: 'counter/increment', payload: 3 }
// increment.toString() -&gt; 'counter/INCREMENT'
// console.log(increment) -&gt; counter/INCREMENT
</pre>
<p>对于更复杂的情况，它还接受另一个参数，一个用于自定义操作创建逻辑的函数。这个例子很容易理解:</p>
<pre class="language-javascript hljs">const addTodo = createAction('todos/ADD, function prepare(text) {
  return {
    payload: {
      text,
      createdAt: new Date().toISOString()
    }
  }
})

console.log(addTodo('Some text'))
/**
 * {
 *   type: 'todos/ADD',
 *   payload: {
 *     text: 'Some text',
 *     createdAt: '2019-10-03T07:53:36.581Z'
 *   }
 * }
 **/
</pre>
<h3><code>createReducer</code></h3>
<p>如上所述，这是<code>createSlice</code>法中的特色酱料之一。它帮助我们编写一个更简单的reducer。这移除了与case reducers相关联的样板代码，并允许我们将reducer编写为函数查找表来处理每种动作类型。利用Immer的力量，使变异状态更加直观。</p>
<p>它有两个参数:第一个是初始状态，另一个是从动作类型到reducers的对象映射。</p>
<p>一个简单的计数器缩减器，以前可能是这样的:</p>
<pre class="language-javascript hljs">function counterReducer(state = 0, { type, payload }) {
  switch (type) {
    case 'increment':
      return state + payload
    case 'decrement':
      return state - payload
    default:
      return state
  }
}
</pre>
<p>现在看起来像这样:</p>
<pre class="language-javascript hljs">const counterReducer = createReducer(0, {
  increment: (state, { payload }) =&gt; state + payload,
  decrement: (state, { payload }) =&gt; state - payload
})
</pre>
<p>使用<code>createAction</code> API创建的动作可以用作键。</p>
<h3>用Redux工具包使用Redux-Saga</h3>
<p>Redux Saga是一个中间件库，用于允许Redux存储与外部资源异步交互。这包括向外部服务发出HTTP请求、访问浏览器存储和执行I/O操作。这些操作也被称为副作用。</p>
<p>尽管RTK的<code>createAsyncThunk</code>可以创建异步函数，sagas更强大，也更容易测试，但是它们引入了许多新概念，如果你还在学习其他技术，这些新概念可能会有点让人不知所措。这篇StackOverflow帖子简洁地解释了Redux Thunk和Redux-Saga 之间的<a href="https://stackoverflow.com/questions/50285972/what-is-the-difference-between-redux-thunk-and-redux-saga" target="_blank" rel="noopener">差异。</a></p>
<p>在您的终端中运行以下命令来安装Redux-Saga和Axios，它们将用于数据获取:</p>
<pre class="language-shell hljs">npm install Redux-Saga axios
</pre>
<p>现在你可以像这样在你的Redux商店里使用Redux-Saga:</p>
<pre class="language-javascript hljs">// store.js
import { configureStore } from '@reduxjs/toolkit'
import createSagaMiddleware from 'Redux-Saga'
import counterReducer from '../features/counter/counterSlice'
import saga from '../sagas/saga'

let sagaMiddleware = createSagaMiddleware()
const middleware = [sagaMiddleware]

export const store = configureStore({
  reducer: {
    counter: counterReducer,
  },
  middleware: (getDefaultMiddleware) =&gt;
    getDefaultMiddleware().concat(middleware),
})

sagaMiddleware.run(saga)
</pre>
<p>Redux-Saga提供了一个用于实例化<code>sagaMiddleware</code>的<code>createSagaMiddle</code>函数。因为<code>configureStore</code> API中的<code>middleware</code>参数是现有中间件的数组，所以我们可以通过<code>getDefaultMiddleware</code>回调来获取当前中间件，并将我们的新Saga中间件连接到该数组。</p>
<p>最后，我们在我们的传奇故事的<code>sagaMiddleware</code>上使用<code>run</code>函数，我在下面的路径中创建了这个传奇故事:<code>sagas/saga.js</code>。</p>
<h3>还原传奇效应</h3>
<p><code>Redux-Saga</code>提供了许多效果，这些效果是给中间件执行某些操作的指令。其中包括:</p>
<ul>
<li><code>takeEvery (actionType, saga)</code>在发送到商店的每个动作上产生一个与<code>actionType</code>匹配的<code>saga</code>，例如<code>FETCH_USER_DETAILS</code></li>
<li><code>call (fn, …args)</code>创建一个效果描述，指示中间件调用带有<code>args</code>参数的函数<code>fn</code>,如果有的话</li>
<li><code>put: (action)</code>创建一个效果描述，指示中间件调度一个动作到商店</li>
</ul>
<p>将此应用于我们的应用程序，我们可以创建一个saga，它从一个API异步获取一个随机数，然后使用来自<code>counterSlice</code>的<code>incrementByAmount</code>缩减器将计数器值增加来自外部API的值:</p>
<pre class="language-javascript hljs">// saga.js
import { call, takeEvery, put } from 'Redux-Saga/effects'
import Axios from 'axios'
import { incrementByAmount } from '../features/counter/counterSlice'
import { sagaActions } from './sagaActions'

// function uses axios to fetch data from our api
let callAPI = async ({ url, method, data }) =&gt; {
  return await Axios({
    url,
    method,
    data,
  })
}

export function* fetchNumberSaga() {
  try {
    let result = yield call(() =&gt;
      callAPI({
        url: 'http://www.randomnumberapi.com/api/v1.0/random?min=100&amp;max=1000&amp;count=1',
      })
    )
    yield put(incrementByAmount(result.data[0]))
  } catch (e) {
    yield put({ type: 'NUMBER_SAGA_FAILED' })
  }
}
export default function* rootSaga() {
  yield takeEvery(sagaActions.FETCH_NUMBER_SAGA, fetchNumberSaga)
}
</pre>
<p>这里，<code>call</code>效果用于向外部API发出请求，<code>put</code>用于用reducer函数更新存储。</p>
<p>在前面的异步请求发出后，<code>takeEvery</code>创建一个saga，监视任何类型为<code>FETCH_NUMBER_SAGA</code>的动作，引用为来自<code>sagaActions.js</code>的<code>sagaActions.FETCH_NUMBER_SAGA</code>:</p>
<pre class="language-javascript hljs">// sagas/sagaActions.js
export const sagaActions = {
  FETCH_NUMBER_SAGA: 'FETCH_NUMBER_SAGA',
}
</pre>
<p>有了我们的第一个saga now设置，我们可以从<code>Counter</code>组件调度它，如下所示:</p>
<pre class="language-javascript hljs">// Counter.js
import React, { useState } from 'react'
import { useSelector, useDispatch } from 'react-redux'
import {
  decrement,
  increment,
  incrementByAmount,
  incrementAsync,
  incrementIfOdd,
  selectCount,
} from './counterSlice'
import styles from './Counter.module.css'
import { sagaActions } from '../../sagas/sagaActions'
export function Counter() {
  const count = useSelector(selectCount)
  const dispatch = useDispatch()
  const [incrementAmount, setIncrementAmount] = useState('2')
  const incrementValue = Number(incrementAmount) || 0

  return (
    &lt;div&gt;
      &lt;div className={styles.row}&gt;
        &lt;button
          className={styles.button}
          aria-label='Decrement value'
          onClick={() =&gt; dispatch(decrement())}
        &gt;
          -
        &lt;/button&gt;
        &lt;span className={styles.value}&gt;{count}&lt;/span&gt;
        &lt;button
          className={styles.button}
          aria-label='Increment value'
          onClick={() =&gt; dispatch(increment())}
        &gt;
          +
        &lt;/button&gt;
      &lt;/div&gt;
      &lt;div className={styles.row}&gt;
        &lt;input
          className={styles.textbox}
          aria-label='Set increment amount'
          value={incrementAmount}
          onChange={(e) =&gt; setIncrementAmount(e.target.value)}
        /&gt;
        {/* buttons */}
        {/* add random number asynchronously with redux saga */}
        &lt;button
          className={styles.button}
          onClick={() =&gt; dispatch({ type: sagaActions.FETCH_NUMBER_SAGA })}
        &gt;
          Add Random number with Saga
        &lt;/button&gt;
      &lt;/div&gt;
    &lt;/div&gt;
  )
}
</pre>
<p><img data-attachment-id="105230" data-permalink="https://blog.logrocket.com/smarter-redux-redux-toolkit/example-redux-toolkit-app/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/05/example-Redux-Toolkit-app.gif" data-orig-size="494,466" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="example Redux Toolkit app" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/05/example-Redux-Toolkit-app-300x283.gif" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/05/example-Redux-Toolkit-app.gif" decoding="async" class="size-full wp-image-105230 aligncenter jetpack-lazy-image" src="../Images/3911193b3bd2a3f351b8d63d6ceafbdd.png" alt="example Redux Toolkit app" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2020/05/example-Redux-Toolkit-app.gif?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/05/example-Redux-Toolkit-app.gif"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="105230" data-permalink="https://blog.logrocket.com/smarter-redux-redux-toolkit/example-redux-toolkit-app/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/05/example-Redux-Toolkit-app.gif" data-orig-size="494,466" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="example Redux Toolkit app" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/05/example-Redux-Toolkit-app-300x283.gif" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/05/example-Redux-Toolkit-app.gif" decoding="async" loading="lazy" class="size-full wp-image-105230 aligncenter" src="../Images/3911193b3bd2a3f351b8d63d6ceafbdd.png" alt="example Redux Toolkit app" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/05/example-Redux-Toolkit-app.gif"/></noscript>
<h2>结论</h2>
<p>正如我们所看到的，Redux Toolkit消除了许多反对Redux的论点。它还有助于弥合围绕良好实践和模式的知识差距。它对大规模应用程序非常有帮助，尤其是因为它也可以在现有的Redux应用程序中使用。</p>
<p>RTK是否能够解决围绕Redux及其用法的所有争论仍是一个问题，但毫无疑问，它看起来像是朝着正确方向迈出的一大步。请在评论区告诉我们你的想法。</p><div class="code-block code-block-17">
<div class="blog-plug inline-plug react-plug" vwo-el-id="26283398190">
<h2 vwo-el-id="41600691720">使用LogRocket消除传统反应错误报告的噪音</h2>
<a href="https://lp.logrocket.com/blg/react-signup-issue-free" target="_blank" vwo-el-id="19356441070">LogRocket
</a><p>是一款React analytics解决方案，可保护您免受数百个误报错误警报的影响，只针对少数真正重要的项目。LogRocket告诉您React应用程序中实际影响用户的最具影响力的bug和UX问题。</p><a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="19356441380">
<img class="first-react-image alignnone size-full wp-image-46 jetpack-lazy-image jetpack-lazy-image--handled" src="../Images/f300c244a1a1cf916df8b4cb02bec6c6.png" vwo-el-id="18272717540" data-lazy-loaded="1" data-original-src="https://files.readme.io/27c94e7-Image_2017-06-05_at_9.46.04_PM.png"/>
</a>
<a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="19356441690">
<img class="second-react-image alignnone size-full wp-image-46 jetpack-lazy-image jetpack-lazy-image--handled" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" vwo-el-id="30720362350" data-lazy-loaded="1" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/>
</a>
<a href="https://lp.logrocket.com/blg/react-signup-issue-free" target="_blank" rel="noopener noreferrer" vwo-el-id="35866400580">LogRocket
</a><p>自动聚合客户端错误、反应错误边界、还原状态、缓慢的组件加载时间、JS异常、前端性能指标和用户交互。然后，LogRocket使用机器学习来通知您影响大多数用户的最具影响力的问题，并提供您修复它所需的上下文。</p><p vwo-el-id="28675661060">关注重要的React bug—<a class="signup" href="https://lp.logrocket.com/blg/react-signup-issue-free" target="_blank" rel="noopener noreferrer" vwo-el-id="40093418840">今天就试试LogRocket】。</a></p>
</div></div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
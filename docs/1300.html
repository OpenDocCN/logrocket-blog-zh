<html>
<head>
<title>Coding in PHP 7.4 and deploying to 7.1 via Rector and GitHub Actions - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>在PHP 7.4中编码并通过Rector和GitHub Actions部署到7.1</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/coding-in-php-7-4-and-deploying-to-7-1-via-rector-and-github-actions/#0001-01-01">https://blog.logrocket.com/coding-in-php-7-4-and-deploying-to-7-1-via-rector-and-github-actions/#0001-01-01</a></blockquote><div><article class="article-post">

<p>PHP开发人员希望获得该语言的最新特性，但是由于各种原因，他们可能无法获得。这可能是因为客户端的服务器运行在旧版本上，无法升级，或者CMS必须支持遗留代码，或者用户群会显著缩小，或者其他原因。</p>
<p>但是有一个解决方案:我们可以使用transpiler将使用新语法的代码转换为遗留语法。Transpilers提供了两个世界的精华；开发人员可以使用最新的特性进行编码，并生成一个可与该语言以前版本一起工作的生产资产。</p>
<p>在我的<a href="https://blog.logrocket.com/transpiling-php-code-from-8-0-to-7-x-via-rector/">上一篇文章</a>中，我介绍了<a href="https://github.com/rectorphp/rector/"> Rector </a>，一个PHP的重构工具。现在让我们把它付诸实践。在本文中，我们将探索如何使用PHP 7.4代码开发一个WordPress插件，并通过Rector和<a href="https://github.com/features/actions"> GitHub Actions </a>发布包含PHP 7.1及更低版本代码的插件。</p>
<h2>为什么选择PHP 7.1</h2>
<p>由于WordPress决定将<a href="https://make.wordpress.org/core/2020/08/24/proposal-dropping-support-for-old-php-versions-via-a-fixed-schedule/">而非</a> <a href="https://make.wordpress.org/core/2020/08/24/proposal-dropping-support-for-old-php-versions-via-a-fixed-schedule/">升级为</a> <a href="https://make.wordpress.org/core/2020/08/24/proposal-dropping-support-for-old-php-versions-via-a-fixed-schedule/">，我开始移植我的WordPress插件，目前是5.6。你可能会想，为什么我要转换到PHP 7.1，而不是PHP 5.6？</a></p>
<p>这有两个原因。首先，Rector基于<a href="https://github.com/rectorphp/rector/blob/master/docs/rector_rules_overview.md">规则</a>进行转换，比如<a href="https://github.com/rectorphp/rector/blob/master/docs/rector_rules_overview.md#arrowfunctiontoanonymousfunctionrector">arrow functiontoanonymousfuncorctor</a>，将代码从PHP 7.4的箭头函数降级为PHP 7.3及以下的匿名函数:</p>
<pre class="diff hljs">class SomeClass
 {
     public function run()
     {
         $delimiter = ",";
<span class="hljs-deletion">-        $callable = fn($matches) =&gt; $delimiter . strtolower($matches[1]);</span>
<span class="hljs-addition">+        $callable = function ($matches) use ($delimiter) {
+            return $delimiter . strtolower($matches[1]);
+        };</span>
     }
 }</pre>
<p>从迄今实施的大约<a href="https://github.com/rectorphp/rector/blob/master/docs/rector_rules_overview.md#downgradephp71"> 20个降级规则</a>来看，只有少数是从PHP 7.1到7.0，没有一个是从7.0到5.6。所以对达到7.0的支持是有限的，对目标5.6还没有支持。</p>
<p>这并不意味着Rector不能支持PHP 5.6，但这项工作必须完成。如果这些规则最终得以实现(在WordPress将其最低版本提升到7.1之前，否则就不再需要它们了)，那么我可以瞄准一个更低的PHP版本。</p>
<p>第二个原因与第三方PHP依赖有关。这些也必须与我们的应用程序代码一起传输，这样做可能需要大量的工作。</p>
<p>例如，如果一个依赖项需要PHP 7.1，而我的应用程序的目标是PHP 7.1，那么这个依赖项就被直接支持，我不需要转换它的代码。但是如果我的目标是PHP 7.0或5.6，那么我需要转换它。</p>
<p>传输第三方依赖项会变得很有挑战性，因为它们不在我的控制之下。仅仅浏览它的代码是不够的；我需要做彻底的研究，以确保依赖关系中的所有PHP 7.1代码都可以被编译。我没有注意到的一个特性很可能会使应用程序在运行时失败。</p>
<p>在我的例子中，我的应用程序有一个依赖项需要PHP 7.2，几十个依赖项需要PHP 7.1(稍后会详细介绍)。因为我没有无限的资源，所以我选择了PHP 7.1和transpile一个依赖项，而不是7.0和transpile几十个。</p>
<p>因此，运行WordPress 5.6和7.0的用户将无法使用我的WordPress插件，但这是一个我很满意的权衡。</p>
<h2>支持的PHP特性</h2>
<p>当声明一个应用程序现在可以使用PHP 7.4代码时，这并不一定意味着它可以使用PHP 7.4 中引入的每一个特性。相反，它只能使用那些有Rector规则来降级的功能。</p>
<p>而且，<a href="https://blog.logrocket.com/transpiling-php-code-from-8-0-to-7-x-via-rector/#avoiding-features-needed-on-runtime">不是所有的特性都可以被传输</a>，有些特性因为这样那样的原因不会被传输。</p>
<p>例如，在PHP 7.4引入的<a href="https://www.php.net/manual/en/migration74.constants.php">新常量</a>中，常量<code>SO_LABEL</code>、<code>SO_PEERLABEL</code>和其他常量是FreeBSD特定的套接字选项。这似乎太具体了，所以我不希望有人为他们实现一个Rector规则。</p>
<p>这样一来，应用程序将不会完全支持PHP 7.4(如果有人确实需要constant <code>SO_LABEL</code>，那也不会有)；相反，它可以完全支持PHP 7.1，并通过PHP 7.2、7.3和7.4中的一组特性得到增强。</p>
<p>下面的列表列出了当前支持的PHP 7.1版本的特性。该列表(随着社区实施<a href="https://github.com/rectorphp/rector/projects/3">剩余降级规则</a>而必定会扩大)还包括由<a href="https://blog.logrocket.com/transpiling-php-code-from-8-0-to-7-x-via-rector/#backporting-functionalities"> Symfony polyfill软件包</a>支持的功能:</p>

<p>你有没有注意到一些PHP 8.0的特性已经被支持了？一旦PHP 8.0在今年年底发布，您就可以立即开始在您的应用程序代码中使用<a href="https://github.com/rectorphp/rector/blob/master/docs/rector_rules_overview.md#downgradenullcoalescingoperatorrector">联合类型</a>，而不会放弃对PHP 7.1的支持……这多酷啊？</p>
<h2>蒸腾输入和输出</h2>
<p>我将使用我自己的插件<a href="https://github.com/GraphQLAPI/graphql-api-for-wp"> GraphQL API for WordPress </a>和它的包来演示如何通过Rector传输一个WordPress插件。</p>
<p>插件中的代码使用了PHP 7.4、7.3和7.2的特性，即:</p>
<ul>
<li>PHP 7.4中的类型化属性、箭头函数、零合并赋值操作符、数组内部的解包和数字文字分隔符</li>
<li>PHP 7.3中数组析构和灵活的Heredoc语法中的引用赋值</li>
<li>PHP 7.2中的<code>object</code>返回和参数类型</li>
</ul>
<p>当transpiling时，这些特性被转换成PHP 7.1中的等价代码。</p>
<p>此表显示了来自源代码的示例，以及当<a href="https://github.com/GraphQLAPI/graphql-api-for-wp/releases/tag/0.6.3">为生产</a>生成资产时，Rector将它们转换成什么:</p>
<table>
<tbody>
<tr>
<td><strong> PHP特性</strong></td>
<td><strong>源代码</strong></td>
<td><strong>传输码</strong></td>
</tr>
<tr>
<td><a href="https://github.com/GraphQLAPI/graphql-api-for-wp/blob/1b08b9ad1654edf8488c7ca40127fc25d56d883a/src/Registries/ModuleTypeRegistry.php#L15">类型化属性</a></td>
<td><pre class="diff hljs">class ModuleTypeRegistry { <span class="hljs-deletion”">-  protected array $moduleTypeResolvers = [];</span> }</pre></td>
<td><pre class="diff hljs">class ModuleTypeRegistry { <span class="hljs-addition">+  /** +   * @var array +   */ +  protected $moduleTypeResolvers = [];</span> }</pre></td>
</tr>
<tr>
<td><a href="https://github.com/GraphQLAPI/graphql-api-for-wp/blob/ca7094317080ab2bab374e3f0926c361db77b733/src/Registries/ModuleRegistry.php#L36">箭头功能</a></td>
<td><pre class="diff hljs">$modules = array_filter(   $modules, <span class="&quot;hljs-deletion”">-  fn ($module) =&gt; !$this-&gt;getModuleResolver($module)-&gt;isHidden($module)</span> );</pre></td>
<td><pre class="diff hljs">$modules = array_filter(   $modules, <span class="hljs-addition">+  function ($module) { +    return !$this-&gt;getModuleResolver($module)-&gt;isHidden($module); +  }</span> );</pre></td>
</tr>
<tr>
<td><a href="https://github.com/getpop/api/blob/0bade110afe33506902fff4a58cee6d89940b2b6/src/Schema/FieldQueryConvertor.php#L57">零合并赋值运算符</a></td>
<td><pre class="diff hljs"><span class="hljs-deletion">-$fragments ??= $this-&gt;getFragments();</span></pre></td>
<td><pre class="diff hljs"><span class="hljs-addition">+$fragments = $fragments ?? $this-&gt;getFragments();</span></pre></td>
</tr>
<tr>
<td><a href="https://github.com/GraphQLAPI/graphql-api-for-wp/blob/a92efc2e1e7d03d551196a17d2c717e5f1a74962/src/BlockCategories/AbstractBlockCategory.php#L59">打开数组内部的包装</a></td>
<td><pre class="diff hljs"><span class="&quot;hljs-deletion”">-return [ -  ...$categories, -  [ -    'slug' =&gt; $this-&gt;getBlockCategorySlug(), -    'title' =&gt; $this-&gt;getBlockCategoryTitle(),</span> -  ], -];</pre></td>
<td><pre class="diff hljs"><span class="hljs-addition">+return array_merge( +  $categories, [[ +    'slug' =&gt; $this-&gt;getBlockCategorySlug(), +    'title' =&gt; $this-&gt;getBlockCategoryTitle(), +  ]] +);</span></pre></td>
</tr>
<tr>
<td><a href="https://github.com/getpop/trace-tools/blob/ebbd132cd28f9a520442d1c15639c99b1207149b/src/DirectiveResolvers/EndTraceExecutionTimeDirectiveResolver.php#L135">数字文字分隔符</a></td>
<td><pre class="diff hljs"><span class="hljs-deletion">-$executionTime / 1_000_000</span></pre></td>
<td><pre class="diff hljs"><span class="hljs-addition">+$executionTime / 1000000</span></pre></td>
</tr>
<tr>
<td><a href="https://github.com/GraphQLAPI/graphql-api-for-wp/blob/fef87e1500e999de6821c6f63325eb902659e851/src/EndpointResolvers/EndpointResolverTrait.php#L94">在<code>list()</code>中引用赋值/数组析构</a></td>
<td><pre class="diff hljs"><span class="hljs-deletion">-[&amp;$vars] = $vars_in_array;</span></pre></td>
<td><pre class="diff hljs"><span class="hljs-addition">+$vars =&amp; $vars_in_array[0];</span></pre></td>
</tr>
<tr>
<td><a href="https://github.com/GraphQLAPI/graphql-api-for-wp/blob/61f58a0093147ad17503fd267a46b556e8224bb0/src/Admin/MenuPages/GraphiQLMenuPage.php#L210">灵活的Heredoc语法</a></td>
<td><pre class="diff hljs"><span class="hljs-addition">-return &lt;&lt;&lt;EOT -  # Welcome to GraphiQL -  # -  # GraphiQL is an in-browser tool for writing, validating, and -  # testing GraphQL queries. -  EOT;</span></pre></td>
<td><pre class="diff hljs"><span class="hljs-addition">+return &lt;&lt;&lt;EOT +# Welcome to GraphiQL +# +# GraphiQL is an in-browser tool for writing, validating, and +# testing GraphQL queries. +EOT;</span></pre></td>
</tr>
<tr>
<td><a href="https://github.com/getpop/component-model/blob/2d93d20cabe71b8c20b598927cbc9a4f9db94ae3/src/Instances/InstanceManagerInterface.php#L9"> <code>object</code>键入回车键</a></td>
<td><pre class="diff hljs"><span class="hljs-deletion">-public function getInstance(string $class): object;</span></pre></td>
<td><pre class="diff hljs"><span class="hljs-addition">+/** + @return object + */ +public function getInstance(string $class);</span></pre></td>
</tr>
<tr>
<td><a href="https://github.com/GraphQLByPoP/graphql-server/blob/33acfc909a34eea21c8ad800e1356e942533a2a2/src/TypeResolvers/DirectiveTypeResolver.php#L26"> <code>object</code>输入参数</a></td>
<td><pre class="diff hljs"><span class="hljs-deletion">-public function getID(object $resultItem)</span> {   $directive = $resultItem;   return $directive-&gt;getID(); }</pre></td>
<td><pre class="diff hljs"><span class="hljs-addition">+/** + * @param object $resultItem + */ +public function getID($resultItem)</span> {   $directive = $resultItem;   return $directive-&gt;getID(); }</pre></td>
</tr>
</tbody>
</table>
<p>这些文件来自两个来源:<code>src/</code>文件夹和<code>vendor/</code>文件夹。</p>
<p>是存储应用程序代码的地方，所以它完全在我的控制之下。因此，我可以保证这段代码只包含前面描述的受支持的PHP特性。</p>
<p><code>vendor/</code>包含我和第三方拥有的所有依赖项(通过Composer管理)。对于我的插件，所有对transpile的依赖(来自所有者<code>getpop</code>、<code>pop-schema</code>和<code>graphql-by-pop</code>)也是我的，所以我可以再次保证这段代码只包含受支持的特性。</p>
<p>排除的路径对应于包含的依赖项，我已经知道这些依赖项只包含PHP 7.1和更低版本的代码。因此，没有什么要为它们传输的，因此，我直接跳过对它们运行Rector。</p>
<p>第三方依赖怎么办？为什么我一个都没发？</p>
<p>幸运的是，我不需要。原因如下。</p>
<h3>传输第三方依赖关系</h3>
<p>我们需要弄清楚第三方依赖是否必须移植到PHP 7.1。</p>
<p>第一步是找出哪些依赖项需要PHP 7.2或以上。为此，我们为生产安装了Composer依赖项，因为我们将在那里运行transpiled代码:</p>
<pre><code>composer install --no-dev
</code></pre>
<p>现在，我们可以通过运行以下命令获得不支持PHP 7.1的依赖项列表:</p>
<pre><code>composer why-not php 7.1.33
</code></pre>
<p>请注意，约束是在版本<code>7.1.33</code>(PHP 7.1的最新版本)上，而不是直接在<code>7.1</code>上。这是因为<code>7.1</code>被解释为<code>7.1.0</code>，所以需要版本<code>7.1.3</code>的包也会失败。</p>
<p>对于我的插件，运行上面的命令会产生这些依赖关系:</p>
<pre>symfony/cache                                 v5.1.6         requires  php (&gt;=7.2.5)
symfony/cache-contracts                       v2.2.0         requires  php (&gt;=7.2.5)
symfony/expression-language                   v5.1.6         requires  php (&gt;=7.2.5)
symfony/filesystem                            v5.1.6         requires  php (&gt;=7.2.5)
symfony/inflector                             v5.1.6         requires  php (&gt;=7.2.5)
symfony/service-contracts                     v2.2.0         requires  php (&gt;=7.2.5)
symfony/string                                v5.1.6         requires  php (&gt;=7.2.5)
symfony/var-exporter                          v5.1.6         requires  php (&gt;=7.2.5)</pre>
<p>所以我不得不检查这八个包的源代码，以检查为什么它们至少需要PHP 7.2.5，并找出这些代码是否可以被编译。</p><div class="code-block code-block-54">
<hr/>
<h3>更多来自LogRocket的精彩文章:</h3>

<hr/></div>
<p>六个包(<code>cache-contracts</code>、<code>expression-language</code>、<code>filesystem</code>、<code>inflector</code>、<code>service-contracts</code>、<code>string</code>)只用PHP 7.1及以下代码。他们对PHP 7.2.5有需求只是因为他们的一个依赖项有这个需求。</p>
<p>我不知道(也不关心)包<code>symfony/var-exporter</code>(它是对<code>symfony/cache</code>的依赖)是否包含PHP 7.2代码:它是从我的插件不使用的类中引用的(<code>PhpArrayAdapter</code>和<code>PhpFilesAdapter</code>)，并且由于<code><a href="https://www.php-fig.org/psr/psr-4/">PSR-4</a></code>和自动加载，运行时不会加载包中的任何类。</p>
<p>最后，包<code>symfony/cache</code>确实包含PHP 7.2代码，在<a href="https://github.com/symfony/cache/blob/292cd57b7c2e3c37aa2f0a2fa42dacae567dd5cd/Adapter/PdoAdapter.php#L433">类<code>PdoAdapter</code> </a>中。我可以转换这段代码(有<a href="https://github.com/rectorphp/rector/blob/master/docs/rector_rules_overview.md#downgradereturnobjecttypedeclarationrector">对应的降级规则</a>，但是没有必要:我的应用程序不访问类<code>PdoAdapter</code>，因为<code>PSR-4</code>，它永远不会被加载。</p>
<p>这八个包相当小，PHP 7.2只引入了一小部分新特性，所以在其中搜索PHP 7.2代码并不困难。但是拥有更大的包，或者针对具有更多特性的PHP版本，会使任务更加困难。</p>
<h3>降级集合</h3>
<p>接下来，我们定义对代码应用什么集合或规则:</p>
<pre>  // here we can define what sets of rules will be applied
  $parameters-&gt;set(Option::SETS, [
    // @todo Uncomment when PHP 8.0 released
    // SetList::DOWNGRADE_PHP80,
    SetList::DOWNGRADE_PHP74,
    SetList::DOWNGRADE_PHP73,
    SetList::DOWNGRADE_PHP72,
  ]);</pre>
<p>看到评论的<code>SetList::DOWNGRADE_PHP80</code>行了吗？在PHP 8.0发布的同一天，只需取消注释该行，我的插件就可以开始使用联合类型😎。</p>
<p>关于集合的执行顺序，代码必须从较高版本降级到较低版本:</p>
<ul>
<li>从PHP 7.4到7.3</li>
<li>从PHP 7.3到7.2</li>
<li>从PHP 7.2到7.1</li>
</ul>
<p>对于当前的规则，这没有什么不同，但是如果降级的代码被一个较低的PHP版本中的另一个规则修改，就会有所不同。</p>
<p>例如，PHP 7.4中引入的零合并赋值操作符<code>??=</code>被降级为这样的<a href="https://github.com/rectorphp/rector/blob/master/docs/rector_rules_overview.md#downgradenullcoalescingoperatorrector"/>:</p>
<pre class="diff hljs"> $array = [];
<span class="hljs-deletion">-$array['user_id'] ??= 'value';</span>
<span class="hljs-addition">+$array['user_id'] = $array['user_id'] ?? 'value';</span></pre>
<p>然后，如果一直降级到PHP 5.6，带有空合并操作符<code>??</code>的编译代码也必须降级，如下所示:</p>
<pre class="hljs diff"> $array = [];
<span class="hljs-deletion">-$array['user_id'] = $array['user_id'] ?? 'value';</span>
<span class="hljs-addition">+$array['user_id'] = isset($array['user_id']) ? $array['user_id'] : 'value'; </span>
</pre>
<h3>正在加载WordPress</h3>
<p>因为WordPress不使用Composer自动加载，所以我们必须提供其源文件的路径，否则每当遇到WordPress代码(比如执行一个WordPress函数，从WordPress的一个类扩展，或者其他)时，Rector都会抛出一个错误:</p>
<pre>  // Rector relies on autoload setup of your project; Composer autoload is included by default; to add more:
  $parameters-&gt;set(Option::AUTOLOAD_PATHS, [
    // full directory
    __DIR__ . '/vendor/wordpress/wordpress',
  ]);</pre>
<p>为了下载WordPress源文件，我们将WordPress添加为一个Composer依赖项(但仅用于开发)，并将它的位置定制为<code>vendor/wordpress/wordpress</code>。我们的<code>composer.json</code>会这样看<a href="https://github.com/GraphQLAPI/graphql-api-for-wp/blob/3f9fd52ddf318b9fbb33653de8acfec8dc4b4665/composer.json"/>:</p>
<pre>{
  "require-dev": {
    "johnpbloch/wordpress": "&gt;=5.5"
  },
  "extra": {
    "wordpress-install-dir": "vendor/wordpress/wordpress"
  }
}</pre>
<h3>处理WordPress</h3>
<p>仅仅包含WordPress的自动加载路径可能还不够。例如，当运行Rector时，我会得到这个错误(追溯到我的代码引用类<code>WP_Upgrader</code>):</p>
<pre>PHP Warning:  Use of undefined constant ABSPATH - assumed 'ABSPATH' (this will throw an Error in a future version of PHP) in .../graphql-api-for-wp/vendor/wordpress/wordpress/wp-admin/includes/class-wp-upgrader.php on line 13</pre>
<p>我没有深究为什么会出现这种情况，但似乎WordPress代码定义常数<code>ABSPATH</code>(在<code>wp-load.php</code>中)不知何故没有被执行。所以我只是在我的目录配置中复制了这个逻辑，指向WordPress源文件的位置:</p>
<pre>  /** Define ABSPATH as this file's directory */
  if (!defined('ABSPATH')) {
    define('ABSPATH', __DIR__ . '/vendor/wordpress/wordpress/');
  }</pre>
<h2>运行控制器</h2>
<p>Rector配置已经设置好了，所以让我们开始传输一些代码吧！</p>
<p>要运行Rector，我们在插件的根文件夹中运行:</p>
<pre>vendor/bin/rector process --dry-run</pre>
<p>我们必须使用<code>--dry-run</code>,因为我们正在降级代码，并且我们不想覆盖源文件。当生产用于生产的资产时，没有<code>--dry-run</code>的流程将在我们的持续集成流程中执行(稍后将详细介绍)。</p>
<p>对于我的插件，Rector需要大约1分钟来处理指定路径中包含的4，188个文件的16个降级规则，之后它会显示173个文件中的代码将如何转换:</p>
<figure id="attachment_28508" aria-describedby="caption-attachment-28508" class="wp-caption aligncenter"><img data-attachment-id="28508" data-permalink="https://blog.logrocket.com/coding-in-php-7-4-and-deploying-to-7-1-via-rector-and-github-actions/running-rector-plugin/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/11/running-rector-plugin.gif" data-orig-size="730,417" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Running Rector on the plugin" data-image-description="" data-image-caption="&lt;p&gt;Running Rector on the plugin.&lt;/p&gt;&#10;" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/11/running-rector-plugin-300x171.gif" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/11/running-rector-plugin.gif" decoding="async" class="size-full wp-image-28508 jetpack-lazy-image" src="../Images/e4855c8dbb37496f0792607a4c59b9a7.png" alt="Running Rector on the Plugin" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2020/11/running-rector-plugin.gif?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/11/running-rector-plugin.gif"/><noscript><img data-lazy-fallback="1" data-attachment-id="28508" data-permalink="https://blog.logrocket.com/coding-in-php-7-4-and-deploying-to-7-1-via-rector-and-github-actions/running-rector-plugin/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/11/running-rector-plugin.gif" data-orig-size="730,417" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Running Rector on the plugin" data-image-description="" data-image-caption="&lt;p&gt;Running Rector on the plugin.&lt;/p&gt;&#10;" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/11/running-rector-plugin-300x171.gif" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/11/running-rector-plugin.gif" decoding="async" loading="lazy" class="size-full wp-image-28508" src="../Images/e4855c8dbb37496f0792607a4c59b9a7.png" alt="Running Rector on the Plugin" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/11/running-rector-plugin.gif"/></noscript><figcaption id="caption-attachment-28508" class="wp-caption-text">Running Rector on the plugin.</figcaption></figure>
<h2>测试编译的代码</h2>
<p>一旦我们产生了编译过的代码，我们如何知道它工作得很好？也就是说，如果我们的目标是PHP 7.1，那么如何才能确保PHP 7.2及以上版本的所有代码都被降级了呢？</p>
<p>我找到的办法是用PHP 7.1运行降级后的代码。如果任何PHP 7.2或更高版本的代码仍然存在，并且被引用，PHP引擎将不会识别它并抛出错误。</p>
<p>作为持续集成过程的一部分，我已经与<a href="https://travis-ci.com/"> Travis </a>一起实施了这个解决方案。每当新代码被推送到repo时，它就验证它可以被适当地降级。为了证明这一点，我只需在传输的代码上运行<a href="https://phpstan.org/">PHP stan</a>；如果PHPStan进程没有错误地退出，这意味着所有transpiled代码都与PHP 7.1兼容。</p>
<p>产生<a href="https://travis-ci.com/github/GraphQLAPI/graphql-api-for-wp/jobs/398847741">这些结果</a>的解决方案(注意红色的transpiled代码删除，绿色的添加)，在这里实现<a href="https://github.com/GraphQLAPI/graphql-api-for-wp/blob/6c9452191e692afb516b8d812139befb9e7724ea/.travis.yml">:</a></p>
<pre>language: php
os:
  - linux
dist: bionic

php:
  - 7.4

jobs:
  include:
    - name: "Test downgrading"
      script:
        - vendor/bin/rector process
        - composer config platform-check false
        - composer dumpautoload
        - phpenv local 7.1
        - vendor/bin/phpstan analyse -c phpstan.neon.dist src/
      after_script: skip

script:
  - vendor/bin/phpunit --coverage-text --coverage-clover=coverage.clover</pre>
<p>让我们看看这个解决方案是如何工作的。</p>
<p>我们首先通过运行<code>vendor/bin/rector process</code>经由Rector降级代码。因为源文件包含PHP 7.4代码，所以必须在PHP 7.4上执行Rector，否则PHP引擎在解析文件时会抛出错误。</p>
<p>Composer v2(几天前刚刚发布)引入了<a href="https://php.watch/articles/composer-platform-check">平台检查</a>。因为<code>composer.json</code>需要PHP 7.4，但是我们将运行PHP 7.1，我们必须禁用它们，否则执行<code>phpstan</code>将触发错误。为此，我们首先执行<code>composer config platform-check false</code>，然后<code>composer dumpautoload</code>删除文件<code>vendor/composer/platform_check.php</code>，这就是验证发生的地方。</p>
<p>降级代码后，我们将环境的PHP版本从7.4切换到7.1。出于这个原因，我们使用<a href="https://docs.travis-ci.com/user/reference/bionic/"> Ubuntu 18.04 LTS，仿生</a>作为构建环境，因为它预装了<a href="https://docs.travis-ci.com/user/reference/bionic/#php-support">PHP 7.1</a>，我们可以通过运行<code>phpenv local 7.1</code>切换到PHP 7.1。</p>
<p>然后，命令<code>vendor/bin/phpstan analyse -c phpstan.neon.dist src/</code>对降级的代码运行PHPStan。这个过程以<code>0</code>退出意味着降级成功，否则将显示一条错误消息指向失败的代码。</p>
<p>我的插件用的是最新版本的PHPUnit(9.4版)，需要PHP 7.3以上。因此，这个进程不能运行PHPUnit，否则会失败，这就是它被跳过的原因。然后，Travis必须使用一个矩阵来执行不同的测试，PHPUnit在单独的运行中执行。</p>
<h2>处理奇怪的事情</h2>
<p>我们可能偶尔会遇到一些我们需要解决的奇怪问题。</p>
<p>例如，我在源代码上运行PHPStan以避免类型不匹配的潜在错误(使用<a href="https://phpstan.org/user-guide/rule-levels">最严格模式</a>，级别<code>8</code>)。PHPStan目前<a href="https://github.com/phpstan/phpstan/issues/3132">有一个bug </a>，向<code>array_filter</code>传递一个匿名函数<a href="https://phpstan.org/r/70f7e6ab-e67c-4ab3-96ee-fcdeb532df52">可能会抛出一个不存在的错误</a>，但是传递一个箭头函数代替<a href="https://phpstan.org/r/5ceed909-77dc-4076-9613-48bbe954b38b">效果很好</a>。</p>
<p>因此，PHPStan在包含arrow函数的源代码和包含匿名函数的transpiled版本上的行为可能会有所不同。对于我的插件，PHPStan不会显示这个箭头函数的任何错误:</p>
<pre>$skipSchemaModuleComponentClasses = array_filter(
  $maybeSkipSchemaModuleComponentClasses,
  fn ($module) =&gt; !$moduleRegistry-&gt;isModuleEnabled($module),
  ARRAY_FILTER_USE_KEY
);</pre>
<p>但是它会为其传输的代码抛出一个错误:</p>
<pre>$skipSchemaModuleComponentClasses = array_filter(
  $maybeSkipSchemaModuleComponentClasses,
  function ($module) use ($moduleRegistry) {
      return !$moduleRegistry-&gt;isModuleEnabled($module);
  },
  ARRAY_FILTER_USE_KEY
);</pre>
<p>为了解决这个问题，我<a href="https://github.com/GraphQLAPI/graphql-api-for-wp/blob/3f9fd52ddf318b9fbb33653de8acfec8dc4b4665/phpstan.neon.dist#L3">将PHPStan </a>配置为忽略错误(对于降级的代码)并在错误不匹配的情况下禁用失败(对于源代码):</p>
<pre>parameters:
  reportUnmatchedIgnoredErrors: false
  ignoreErrors:
    -
      message: '#^Parameter \#1 \$module of method GraphQLAPI\\GraphQLAPI\\Registries\\ModuleRegistryInterface::isModuleEnabled\(\) expects string, array\&lt;int, class-string\&gt; given\.$#'
      path: src/PluginConfiguration.php</pre>
<p>作为一个收获，我们必须总是仔细检查源代码和它的transpiled版本在其上运行进程时产生相同的行为，以避免不愉快的意外。</p>
<h2>通过GitHub动作为生产生成资产</h2>
<p>我们快完成了。到目前为止，我们已经配置了transpiling并测试了它。剩下要做的就是在为生产生成资产时转换代码。这个资产将成为实际的WordPress插件，被分发用于安装。</p>
<p>由于我的插件代码托管在GitHub上，我创建了一个GitHub动作，在标记代码后，将生成transpiled资产。这个动作有<a href="https://github.com/GraphQLAPI/graphql-api-for-wp/blob/3f9fd52ddf318b9fbb33653de8acfec8dc4b4665/.github/workflows/main.yml">这个内容</a>:</p>
<pre>name: Generate Installable Plugin and Upload as Release Asset
on:
  release:
    types: [published]
jobs:
  build:
    name: Build, Downgrade and Upload Release
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="0b68636e6860647e7f4b7d39">[email protected]</a>
      - name: Downgrade code for production (to PHP 7.1)
        run: |
          composer install
          vendor/bin/rector process
          sed -i 's/Requires PHP: 7.4/Requires PHP: 7.1/' graphql-api.php
      - name: Build project for production
        run: |
          composer install --no-dev --optimize-autoloader
          mkdir build
      - name: Create artifact
        uses: montudor/<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="026361766b6d6c2f786b724274322c332c32">[email protected]</a>
        with:
          args: zip -X -r build/graphql-api.zip . -x *.git* node_modules/\* .* "*/\.*" CODE_OF_CONDUCT.md CONTRIBUTING.md ISSUE_TEMPLATE.md PULL_REQUEST_TEMPLATE.md rector.php *.dist composer.* dev-helpers** build**
      - name: Upload artifact
        uses: actions/<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="bbcecbd7d4dadf96dac9cfd2dddad8cffbcd89">[email protected]</a>
        with:
            name: graphql-api
            path: build/graphql-api.zip
      - name: Upload to release
        uses: JasonEtco/<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="6114110d0e00054c150e4c13040d04001204210c0012150413">[email protected]</a>
        with:
          args: build/graphql-api.zip application/zip
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}</pre>
<p>我已经在我的博客上记录了这个动作的大部分步骤:它是如何被触发的，它如何创建一个包含所有Composer依赖项的新的<code>.zip</code>文件，以及它如何作为发布资产被上传到GitHub repo。</p>
<p>唯一新增的是降级代码的步骤，它发生在这里:</p>
<pre>      - name: Downgrade code for production (to PHP 7.1)
        run: |
          composer install
          vendor/bin/rector process
          sed -i 's/Requires PHP: 7.4/Requires PHP: 7.1/' graphql-api.php</pre>
<p>请注意<code>composer install</code>是如何在动作中执行两次的:第一次没有<code>--no-dev</code>,因为<a href="https://github.com/GraphQLAPI/graphql-api-for-wp/blob/3f9fd52ddf318b9fbb33653de8acfec8dc4b4665/composer.json#L52">目录是作为开发依赖项</a>安装的，然后再次使用<code>--no-dev</code>在为生产生成资产之前删除<code>vendor/</code>下的所有开发依赖项。</p>
<p>安装完依赖项后，我们运行<code>vendor/bin/rector process</code>来传输代码。这里没有<code>--dry-run</code>，所以Rector不仅会显示转换，还会将它们应用到输入文件中。</p>
<p>然后，我们必须将<a href="https://github.com/GraphQLAPI/graphql-api-for-wp/blob/3f9fd52ddf318b9fbb33653de8acfec8dc4b4665/graphql-api.php#L8">插件主文件【WordPress依靠它来验证插件是否可以安装)中的<code>Requires PHP</code>头从<code>7.4</code>修改为<code>7.1</code>。我们通过执行<code>sed -i 's/Requires PHP: 7.4/Requires PHP: 7.1/' graphql-api.php</code>来做到这一点。</a></p>
<p>这最后一步可能看起来是一个细节。毕竟，我可以在源代码中定义header <code>Requires PHP: 7.1</code>。然而，我们也可以直接从repo安装插件(事实上，开发就是这样)。因此，为了一致性，源代码和生成的<code>.zip</code>文件插件都必须指明它们各自的PHP版本。</p>
<p>最后，在创建<code>.zip</code>文件时，我们应该排除文件<code>rector.php</code>(以及所有其他要排除的文件):</p>
<pre>      - name: Create artifact
        uses: montudor/<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="b3d2d0c7dadcdd9ec9dac3f3c5839d829d83">[email protected]</a>
        with:
          args: zip -X -r build/graphql-api.zip . -x rector.php ...</pre>
<p>当这个GitHub动作被触发时，它将生成插件资产<code>graphql-api.zip</code>并上传到<a href="https://github.com/GraphQLAPI/graphql-api-for-wp/releases">发布页面</a>:</p>
<figure id="attachment_28509" aria-describedby="caption-attachment-28509" class="wp-caption aligncenter"><img data-attachment-id="28509" data-permalink="https://blog.logrocket.com/coding-in-php-7-4-and-deploying-to-7-1-via-rector-and-github-actions/generated-plugin-asset/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/11/generated-plugin-asset.png" data-orig-size="1160,472" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Generated plugin asset" data-image-description="" data-image-caption="&lt;p&gt;Generated plugin asset.&lt;/p&gt;&#10;" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/11/generated-plugin-asset-300x122.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/11/generated-plugin-asset-1024x417.png" decoding="async" class="size-full wp-image-28509 jetpack-lazy-image" src="../Images/a771bbc21033d4ab4e5830da5a17b252.png" alt="The Generated Plugin Asset" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2020/11/generated-plugin-asset.png 1160w, https://blog.logrocket.com/wp-content/uploads/2020/11/generated-plugin-asset-300x122.png 300w, https://blog.logrocket.com/wp-content/uploads/2020/11/generated-plugin-asset-1024x417.png 1024w, https://blog.logrocket.com/wp-content/uploads/2020/11/generated-plugin-asset-768x312.png 768w" data-lazy-sizes="(max-width: 1160px) 100vw, 1160px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2020/11/generated-plugin-asset.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/11/generated-plugin-asset.png"/><noscript><img data-lazy-fallback="1" data-attachment-id="28509" data-permalink="https://blog.logrocket.com/coding-in-php-7-4-and-deploying-to-7-1-via-rector-and-github-actions/generated-plugin-asset/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/11/generated-plugin-asset.png" data-orig-size="1160,472" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Generated plugin asset" data-image-description="" data-image-caption="&lt;p&gt;Generated plugin asset.&lt;/p&gt;&#10;" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/11/generated-plugin-asset-300x122.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/11/generated-plugin-asset-1024x417.png" decoding="async" loading="lazy" class="size-full wp-image-28509" src="../Images/a771bbc21033d4ab4e5830da5a17b252.png" alt="The Generated Plugin Asset" srcset="https://blog.logrocket.com/wp-content/uploads/2020/11/generated-plugin-asset.png 1160w, https://blog.logrocket.com/wp-content/uploads/2020/11/generated-plugin-asset-300x122.png 300w, https://blog.logrocket.com/wp-content/uploads/2020/11/generated-plugin-asset-1024x417.png 1024w, https://blog.logrocket.com/wp-content/uploads/2020/11/generated-plugin-asset-768x312.png 768w" sizes="(max-width: 1160px) 100vw, 1160px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/11/generated-plugin-asset.png"/></noscript><figcaption id="caption-attachment-28509" class="wp-caption-text">Generated plugin asset.</figcaption></figure>
<p>让我们检查资产生成是否成功。为此，我<a href="https://github.com/GraphQLAPI/graphql-api-for-wp/releases/latest/download/graphql-api.zip">下载transpiled插件<code>graphql-api.zip</code> </a>，将它安装在运行PHP 7.1的WordPress站点上，然后调用它的功能(在本例中，是执行一个GraphQL查询):</p>
<figure id="attachment_28512" aria-describedby="caption-attachment-28512" class="wp-caption aligncenter"><img data-attachment-id="28512" data-permalink="https://blog.logrocket.com/coding-in-php-7-4-and-deploying-to-7-1-via-rector-and-github-actions/wp-php-7-1-running-transpiled-plugin/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/11/wp-php-7-1-running-transpiled-plugin.gif" data-orig-size="730,420" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="WP on PHP 7.1 running transpiled plugin" data-image-description="" data-image-caption="&lt;p&gt;WordPress on PHP 7.1 running transpiled plugin.&lt;/p&gt;&#10;" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/11/wp-php-7-1-running-transpiled-plugin-300x173.gif" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/11/wp-php-7-1-running-transpiled-plugin.gif" decoding="async" class="size-full wp-image-28512 jetpack-lazy-image" src="../Images/a7ca071d4105fd478116b25c6f2c692f.png" alt="WordPress Running Our Transpiled Plugin" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2020/11/wp-php-7-1-running-transpiled-plugin.gif?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/11/wp-php-7-1-running-transpiled-plugin.gif"/><noscript><img data-lazy-fallback="1" data-attachment-id="28512" data-permalink="https://blog.logrocket.com/coding-in-php-7-4-and-deploying-to-7-1-via-rector-and-github-actions/wp-php-7-1-running-transpiled-plugin/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/11/wp-php-7-1-running-transpiled-plugin.gif" data-orig-size="730,420" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="WP on PHP 7.1 running transpiled plugin" data-image-description="" data-image-caption="&lt;p&gt;WordPress on PHP 7.1 running transpiled plugin.&lt;/p&gt;&#10;" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/11/wp-php-7-1-running-transpiled-plugin-300x173.gif" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/11/wp-php-7-1-running-transpiled-plugin.gif" decoding="async" loading="lazy" class="size-full wp-image-28512" src="../Images/a7ca071d4105fd478116b25c6f2c692f.png" alt="WordPress Running Our Transpiled Plugin" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/11/wp-php-7-1-running-transpiled-plugin.gif"/></noscript><figcaption id="caption-attachment-28512" class="wp-caption-text">WordPress on PHP 7.1 running transpiled plugin.</figcaption></figure>
<p>有用！</p>
<h2>结论</h2>
<p>这个插件是用PHP 7.4的特性编写的，它可以安装在运行PHP 7.1的WordPress上。目标实现🙏。</p>
<p>传输我们的PHP代码让我们有机会将应用程序的开发从应用程序本身中分离出来，这样我们就可以使用最新的PHP特性，即使我们的客户端或CMS不支持它们。PHP 8.0指日可待。想要使用联合类型吗？现在你可以做了！</p><div class="code-block code-block-1">
<div class="blog-plug base-cta"><h2>使用<a class="signup" href="https://lp.logrocket.com/blg/signup" target="_blank" rel="noopener noreferrer"> LogRocket </a>消除传统错误报告的干扰</h2>
<a href="https://lp.logrocket.com/blg/signup" class="signup" target="_blank" rel="noopener noreferrer"><img class="alignnone size-full wp-image-46 jetpack-lazy-image" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/><noscript><img data-lazy-fallback="1" class="alignnone size-full wp-image-46" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/></noscript></a>
<p><a href="https://lp.logrocket.com/blg/signup" target="_blank" rel="noopener noreferrer"> LogRocket </a>是一个数字体验分析解决方案，它可以保护您免受数百个假阳性错误警报的影响，只针对几个真正重要的项目。LogRocket会告诉您应用程序中实际影响用户的最具影响力的bug和UX问题。</p>
<p>然后，使用具有深层技术遥测的会话重放来确切地查看用户看到了什么以及是什么导致了问题，就像你在他们身后看一样。</p>
<p>LogRocket自动聚合客户端错误、JS异常、前端性能指标和用户交互。然后LogRocket使用机器学习来告诉你哪些问题正在影响大多数用户，并提供你需要修复它的上下文。</p>
<p>关注重要的bug—<a class="signup" href="https://lp.logrocket.com/blg/signup-issue-free" target="_blank" rel="noopener noreferrer">今天就试试LogRocket】。</a></p></div></div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
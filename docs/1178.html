<html>
<head>
<title>Supercharge your Electron apps with Rust - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>使用Rust - LogRocket博客增强您的电子应用程序</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/supercharge-your-electron-apps-with-rust/#0001-01-01">https://blog.logrocket.com/supercharge-your-electron-apps-with-rust/#0001-01-01</a></blockquote><div><article class="article-post">
<p>电子已经成为创建跨平台桌面应用程序的首要技术。它被用于Atom、VS Code、Spotify、Slack、Discord等许多知名和受欢迎的平台。</p>
<p/>
<p>JavaScript是一种缓慢的语言，但在本教程中，我们将演示如何使用Rust来加速电子应用程序，以获得更好的用户体验。Rust是一种低级语言，具有高级人机工程学。它运行速度极快，内存占用非常少。</p>
<h2 id="settingelectronproject">建立一个电子项目</h2>
<p>我们将使用<code><a href="https://github.com/electron-react-boilerplate/electron-react-boilerplate" target="_blank" rel="noopener noreferrer">electron-react-boilerplate</a></code>为我们的演示应用程序创建一个样板文件。从克隆GitHub repo开始。</p>
<pre>git clone --depth 1 --single-branch https://github.com/electron-react-boilerplate/electron-react-boilerplate.git md_notes
</pre>
<p>使用npm或Yarn安装所有依赖项。</p>
<pre>npm run dev
</pre>
<p>我们将创建一个支持减价的笔记应用程序。markdown解析器将用Rust编写。我们将使用各种方法来连接电子和铁锈。</p>
<h2 id="adduitoelectronproject">将UI添加到您的电子项目中</h2>
<p>我们将使用<a href="https://blog.logrocket.com/the-material-ui-grid-system/" target="_blank" rel="noopener noreferrer"> Material-UI </a>为我们的应用程序获取现成的组件。</p>
<pre>import React, { useState, useEffect } from 'react';
import { makeStyles, createStyles, Theme } from '@material-ui/core/styles';
import Grid from '@material-ui/core/Grid';
import Paper from '@material-ui/core/Paper';
import { TextField, Typography, ListItemText, Button } from '@material-ui/core';
import List from '@material-ui/core/List';
import ListItem from '@material-ui/core/ListItem';
import { remote } from 'electron';
// import fs and path nodejs core module for wrting and reading files
const fs = remote.require('fs');
const path = remote.require('path');
const useStyles = makeStyles((theme: Theme) =&gt;
  createStyles({
    root: {
      flexGrow: 1,
      width: '100vw',
    },
    paper: {
      width: '100%',
      minHeight: '100vh',
      padding: '5px',
    },
    control: {
      padding: theme.spacing(2),
    },
    textArea: {
      width: '100%',
      height: '100%',
    },
    heading: {
      textAlign: 'center',
    },
  })
);
const NOTES_FOLDER = 'notes';
const save = (name: string, data: any) =&gt; {
  fs.writeFileSync(
    path.join('.', NOTES_FOLDER, `${name}${Date.now()}.json`).toString(),
    JSON.stringify(data)
  );
};
export default function SpacingGrid() {
  const [editorState, setEditorState] = useState('');
  const [previewState, setPreview] = useState('');
  const [notes, setNotes] = useState([]);
  useEffect(() =&gt; {
    // we need to add code to parse md and set it to preview
  }, [setPreview, editorState]);
  useEffect(() =&gt; {
    const note = fs
      .readdirSync(path.join('.', NOTES_FOLDER))
      .map((file: string) =&gt; {
        return JSON.parse(
          String(fs.readFileSync(path.join('.', NOTES_FOLDER, file)))
        );
      });
    setNotes(note);
  }, []);
  const [title, setTitle] = useState('');
  const classes = useStyles();
  return (
    &lt;Grid container className={classes.root} spacing={2}&gt;
      &lt;Grid item xs={12}&gt;
        &lt;Grid container justify="center" spacing={2}&gt;
          &lt;Grid item xs={9}&gt;
            &lt;Paper className={classes.paper}&gt;
              &lt;Grid container justify="space-between"&gt;
                &lt;Grid item&gt;
                  &lt;Typography variant="h3" align="center"&gt;
                    Add Notes
                  &lt;/Typography&gt;
                &lt;/Grid&gt;
                &lt;Grid item&gt;
                  &lt;Button
                    variant="outlined"
                    onClick={() =&gt; {
                      save(title, {
                        title,
                        createdAt: Date.now(),
                        body: editorState,
                      });
                    }}
                  &gt;
                    Save
                  &lt;/Button&gt;
                &lt;/Grid&gt;
              &lt;/Grid&gt;
              &lt;Grid
                container
                direction="column"
                justify="space-between"
                spacing={2}
              &gt;
                &lt;Grid item&gt;
                  &lt;TextField
                    label="Title"
                    value={title}
                    onChange={(e) =&gt; setTitle(e.target.value)}
                    variant="outlined"
                    className={classes.textArea}
                  /&gt;
                &lt;/Grid&gt;
                &lt;Grid item&gt;
                  &lt;TextField
                    multiline
                    label="Content"
                    value={editorState}
                    onChange={(e) =&gt; setEditorState(e.target.value)}
                    variant="outlined"
                    className={classes.textArea}
                    rows={20}
                  /&gt;
                &lt;/Grid&gt;
                &lt;Grid item&gt;
                  &lt;div dangerouslySetInnerHTML={{ __html: previewState }} /&gt;
                &lt;/Grid&gt;
              &lt;/Grid&gt;
            &lt;/Paper&gt;
          &lt;/Grid&gt;
          &lt;Grid item xs={3}&gt;
            &lt;Paper className={classes.paper}&gt;
              &lt;List&gt;
                {notes.map((note, i) =&gt; (
                  &lt;ListItem
                    key={`key-${i}`}
                    onClick={() =&gt; {
                      setEditorState(note.body);
                      setTitle(note.title);
                    }}
                  &gt;
                    &lt;ListItemText
                      primary={note.title}
                      secondary={new Date(note.createdAt).toLocaleString('in')}
                    /&gt;
                  &lt;/ListItem&gt;
                ))}
              &lt;/List&gt;
            &lt;/Paper&gt;
          &lt;/Grid&gt;
        &lt;/Grid&gt;
      &lt;/Grid&gt;
    &lt;/Grid&gt;
  );
}
</pre>
<p>这是电子应用的样板代码。现在我们将实现一个解析函数来将markdown转换成HTML。</p>
<p>我们将探索使用Rust解析markdown的各种方法，权衡每种方法的利弊。我们还将研究每种方法的用例。</p>
<p><img data-attachment-id="26076" data-permalink="https://blog.logrocket.com/supercharge-your-electron-apps-with-rust/electron-notes-app/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/09/electron-notes-app.png" data-orig-size="720,391" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Electron notes app" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/09/electron-notes-app-300x163.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/09/electron-notes-app.png" decoding="async" class="aligncenter size-full wp-image-26076 jetpack-lazy-image" src="../Images/007e6ff365a86385c8c82abae58bc74d.png" alt="Electron Notes App" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2020/09/electron-notes-app.png 720w, https://blog.logrocket.com/wp-content/uploads/2020/09/electron-notes-app-300x163.png 300w" data-lazy-sizes="(max-width: 720px) 100vw, 720px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2020/09/electron-notes-app.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/09/electron-notes-app.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="26076" data-permalink="https://blog.logrocket.com/supercharge-your-electron-apps-with-rust/electron-notes-app/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/09/electron-notes-app.png" data-orig-size="720,391" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Electron notes app" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/09/electron-notes-app-300x163.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/09/electron-notes-app.png" decoding="async" loading="lazy" class="aligncenter size-full wp-image-26076" src="../Images/007e6ff365a86385c8c82abae58bc74d.png" alt="Electron Notes App" srcset="https://blog.logrocket.com/wp-content/uploads/2020/09/electron-notes-app.png 720w, https://blog.logrocket.com/wp-content/uploads/2020/09/electron-notes-app-300x163.png 300w" sizes="(max-width: 720px) 100vw, 720px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/09/electron-notes-app.png"/></noscript>
<h2 id="usingwebassemblyinelectron">在电子中使用WebAssembly</h2>
<p>电子应用的核心就是Chrome浏览器和Node.js。我们可以在Chrome和Node中利用WebAssembly支持。</p>
<p>WebAssembly是一种二进制指令格式，在浏览器或基于堆栈的虚拟机中运行。我们将在WebAssembly中编译用Rust编写的markdown解析器。</p>
<h3 id="creatingrustmarkdownparserinwebassembly">在WebAssembly中创建Rust markdown分析器</h3>
<p>Rust对WebAssembly有一流的支持。它使用LLVM编译WebAssembly作为目标。<a href="https://rustwasm.github.io/docs/wasm-pack/" target="_blank" rel="noopener noreferrer"> <code>\wasm-pack\</code> </a>是Rust社区创建的一个工具，帮助开发者使用WebAssembly在Rust中编写节点模块。</p>
<h3 id="usingwasmpack">使用wasm包</h3>
<p><code>wasm-pack</code>是一个创建、构建、发布用WebAssembly编写的节点模块的工具。</p>
<pre>curl https://rustwasm.github.io/wasm-pack/installer/init.sh -sSf | sh
</pre>
<p><code>wasm-pack</code>为Linux和macOS提供安装程序脚本。一旦在您的系统上安装了<code>wasm-pack</code>，您就可以使用<code>wasm-pack new</code>为WebAssembly模块创建一个样板文件。</p>
<p>这将用样板文件创建一个名为<code>md-parser</code>的新目录。</p>
<pre>wasm-pack new md_webassembly


├── Cargo.toml
├── LICENSE_APACHE
├── LICENSE_MIT
├── README.md
├── src
│   ├── lib.rs
│   └── utils.rs
└── tests
    └── web.rs
</pre>
<p><code>lib.rs</code>是Wasm库的主文件。仔细观察<code>lib.rs</code>,会发现它导出了JavaScript调用的<code>greet</code>函数。</p>
<pre>// utils set a panic hook so it is console in js
mod utils;
use wasm_bindgen::prelude::*;
// When the `wee_alloc` feature is enabled, use `wee_alloc` as the global
// allocator.
#[cfg(feature = "wee_alloc")]
#[global_allocator]
static ALLOC: wee_alloc::WeeAlloc = wee_alloc::WeeAlloc::INIT;

// function defination for alert. It is dom api for generating a dialog
#[wasm_bindgen]
extern {
    fn alert(s: &amp;str);
}

// wasm_bingen is a pro macro which transfor return type and arguments to the function
#[wasm_bindgen]
pub fn greet() {
// calling alert
    alert("Hello, md-webassembly!");
}
</pre>
<p>是Rust社区开发的一个板条箱，它使得创建Wasm模块变得更加容易。Wasm不支持字符串或数组数据类型；它只支持整数和浮点数。所以它需要JavaScript堆上字符串的地址来使用access string。将所有样板代码添加到我们的函数中。</p>
<p>对于降价解析，我们将使用<code>comrak</code> crate，它支持GitHub风格的降价。</p>
<pre>[package]
name = "md-webassembly"
version = "0.1.0"
authors = ["anshul &lt;<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="3c5d524f5449505b5359500d090d0505057c5b515d5550125f5351">[email protected]</a>&gt;"]
edition = "2018"

# libtype must be cdylib so it can be dynamically linked by electron
[lib]
crate-type = ["cdylib", "rlib"]

[features]
default = ["console_error_panic_hook"]

[dependencies]
wasm-bindgen = "0.2.63"
comrak = "0.8.2"
console_error_panic_hook = { version = "0.1.6", optional = true }
wee_alloc = { version = "0.4.5", optional = true }

[dev-dependencies]
wasm-bindgen-test = "0.3.13"

[profile.release]
# Tell `rustc` to optimize for small code size.
opt-level = "s"

# avoid wasm-opt error while build
[package.metadata.wasm-pack.profile.release]
wasm-opt = false
</pre>
<h3 id="usingcomrakcrate">使用<code>comrak</code>箱</h3>
<p><code>comark</code>提供了<code>markdown_to_html</code>功能，将markdown解析为HTML。我们将创建一个解析函数，它将markdown字符串作为参数，然后返回HTML字符串。</p>
<pre>mod utils;
use comrak::{markdown_to_html, ComrakOptions};
use wasm_bindgen::prelude::*;
#[cfg(feature = "wee_alloc")]
#[global_allocator]
static ALLOC: wee_alloc::WeeAlloc = wee_alloc::WeeAlloc::INIT;

// take md string return html string
#[wasm_bindgen]
pub fn parse(md: String) -&gt; String {
    markdown_to_html(md.as_str(), &amp;ComrakOptions::default())
}
</pre>
<p>我们已经准备好使用rust markdown解析器了。用于编译使用<code>wasm-pack build</code>。<code>build</code>命令将用typescript类型创建wasm模块。</p>
<h3 id="usingwebassemblyinelectron-1">在电子中使用WebAssembly</h3>
<p>我们可以在电子版的浏览器端和Node.js APIs中使用Rust markdown解析器。</p><div class="code-block code-block-54">
<hr/>
<h3>更多来自LogRocket的精彩文章:</h3>

<hr/></div>
<p>Node和Chromium都支持现成的WebAssembly。而且，用来引导Electron的样板文件也默认支持导入<code>wasm</code>模块。我们可以直接导入Wasm代码，无需添加任何样板文件。</p>
<pre>  useEffect(() =&gt; {
    import('../../md-webassembly/pkg/md_webassembly').then((module) =&gt;
      setPreview(module.parse(editorState))
    );
  }, [setPreview, editorState]);
</pre>
<p>您应该使用动态导入，以便在Wasm模块被实例化时不会阻塞UI呈现。webpack将负责休息。如果您想支持web应用程序，这种方法也很有用。</p>
<h2 id="usingnapiinelectron">NAPI在电子学中的应用</h2>
<p>皮娜是一个与Node.js通信的C头文件，这个方法实现起来有点困难。</p>
<p>我们将使用<code><a href="https://github.com/infinyon/node-bindgen" target="_blank" rel="noopener noreferrer">node-bindgen</a></code>创建一个可以直接在Node.js中使用的Rust库。</p>
<p>用货物安装<code>nj-cli</code>。</p>
<pre>cargo install nj-cli
</pre>
<p>我们现在可以为节点模块创建一个样板文件，然后将其导入到一个电子应用程序中。</p>
<p>让我们从创建一个简单的Rust项目开始。</p>
<pre>cargo new md_napi --lib
</pre>
<p>现在我们需要配置<code>cargo</code>以在Node.js可以使用的动态库中编译它，当应用程序需要线程、SIMD或特定于处理器的代码时，应该使用这个方法。</p>
<pre>[package]
name = "md_napi"
version = "0.1.0"
authors = ["anshul &lt;<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="64050a170c1108030b01085551555d5d5d240309050d084a070b09">[email protected]</a>&gt;"]
edition = "2018"

[lib]
# compile to .so or .dl file based on OS
crate-type = ["cdylib"]

[dependencies]
# Node.js NAPI helper library
node-bindgen = { version = "2.1.1" }
# Parse MarkDown
comrak = "0.8.2"

[build-dependencies]
node-bindgen = { version = "2.1.1", features = ["build"] }
</pre>
<p>我们可以在<code>lib.rs</code>文件中导出一个函数。</p>
<pre>use node_bindgen::derive::node_bindgen;
use comrak::{markdown_to_html, ComrakOptions};

#[node_bindgen]
fn parse(md: String) -&gt; String {
  markdown_to_html(md.as_str(), &amp;ComrakOptions::default())
}
</pre>
<p>现在我们可以使用<code>nj-cli build</code>命令构建这个库。它将用<code>index.node</code>创建一个<code>dist</code>目录。这个文件是直接需要电子版的。</p>
<pre>import { remote } from 'electron';
const mdModule = remote.require('../md_napi/dist/index.node');

console.log((mdModule.parse('# Heading'))
</pre>
<p>在电子应用程序中，我们将简单地替换WebAssembly模块导入。</p>
<pre> useEffect(() =&gt; {
    setPreview(mdModule.parse(editorState));
  }, [setPreview, editorState]);
</pre>
<h3 id="otherlibraries">其他图书馆</h3>
<p>还有一些额外的库可以用来创建附加组件。下面列出的库使用V8 APIs或NAPIs。</p>

<h2 id="comparision">比较</h2>
<p>上述两种方法各有利弊。特定项目的正确选择取决于用例及需求。使用下表作为快速参考指南，帮助您选择最合适的方法。</p>
<table>
<tbody>
<tr>
<td><strong>功能</strong></td>
<td><strong>日/增</strong></td>
<td><strong>web assembly</strong></td>
</tr>
<tr>
<td>线</td>
<td>Libuv线程</td>
<td>网络工作者</td>
</tr>
<tr>
<td>SIMD</td>
<td>全力支持</td>
<td>部分支持</td>
</tr>
<tr>
<td>网页浏览器</td>
<td>无支持的</td>
<td>支持</td>
</tr>
<tr>
<td>CFI</td>
<td>支持</td>
<td>无支持的</td>
</tr>
<tr>
<td>外部板条箱</td>
<td>全力支持</td>
<td>可能支持也可能不支持</td>
</tr>
</tbody>
</table>
<h2 id="conclusion">结论</h2>
<p>JavaScript是一种缓慢的语言。所以电子app往往比较慢。诀窍是将CPU密集型任务转移给其他更快的语言。JavaScript非常适合UI控制，而Rust更适合处理这些复杂的计算。如果你已经完成了本教程，现在你已经有了两个可靠的方法来使用Rust加速你的电子应用程序。</p><div class="code-block code-block-29">
<div class="blog-plug inline-plug rust-plug"><h2><a href="https://lp.logrocket.com/blg/rust-signup" target="_blank">log rocket</a>:Rust应用的web前端的全面可见性</h2><p>调试Rust应用程序可能很困难，尤其是当用户遇到难以重现的问题时。如果您对监控和跟踪Rust应用程序的性能、自动显示错误、跟踪缓慢的网络请求和加载时间感兴趣，</p><a href="https://lp.logrocket.com/blg/rust-signup" target="_blank">try LogRocket</a><p>. </p><a class="signup" href="https://lp.logrocket.com/blg/rust-signup" target="_blank" rel="noopener noreferrer"><img class="alignnone size-full wp-image-46 jetpack-lazy-image" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/><noscript><img data-lazy-fallback="1" class="alignnone size-full wp-image-46" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/></noscript></a><p>LogRocket 就像是网络和移动应用程序的DVR，记录你的Rust应用程序上发生的一切。您可以汇总并报告问题发生时应用程序的状态，而不是猜测问题发生的原因。LogRocket还可以监控应用的性能，报告客户端CPU负载、客户端内存使用等指标。</p><p>现代化调试Rust应用的方式— <a class="signup" href="https://lp.logrocket.com/blg/rust-signup" target="_blank" rel="noopener noreferrer">开始免费监控</a>。</p></div>


</div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
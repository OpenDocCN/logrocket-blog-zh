<html>
<head>
<title>Understanding RxJS Observables and why you need them - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>了解RxJS可观测量以及为什么需要它们</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/understanding-rxjs-observables/#0001-01-01">https://blog.logrocket.com/understanding-rxjs-observables/#0001-01-01</a></blockquote><div><article class="article-post">
<h2>RxJS是什么？</h2>
<p>RxJS 是一个反应式编程的框架，它利用了<a href="https://rxjs-dev.firebaseapp.com/guide/observable" target="_blank" rel="noopener noreferrer">可观察对象</a>，使得编写异步代码变得非常容易。根据官方<a href="https://rxjs-dev.firebaseapp.com/" target="_blank" rel="noopener noreferrer">文档</a>，这个项目是对JavaScript的一种反应式扩展，具有更好的性能、更好的模块化、更好的可调试调用堆栈，同时保持大部分向后兼容，并有一些减少API面的突破性变化。Angular 使用这个官方库来处理反应，将回调的拉操作转换成可观察的。</p>
<p>先决条件</p>
<h2>为了能够完成本文的演示，您应该具备:</h2>
<p>确认你使用的是版本7，如果不是的话<a href="https://angular.io/cli/update" target="_blank" rel="noopener noreferrer">更新到7 </a>。</p>

<pre>// run the command in a terminal
ng version</pre>
<p>点击这里下载本教程的起始项目<a href="https://github.com/viclotana/ng_canvas" target="_blank" rel="noopener noreferrer">来完成演示</a></p>
<ul>
<li>解压缩项目，并使用以下命令初始化终端中的节点模块</li>
<li>其他值得拥有的东西有:</li>
</ul>
<pre>npm install</pre>
<p>初级水平的<a href="https://blog.logrocket.com/how-to-make-your-angular-8-forms-reactive/" target="_blank" rel="noopener noreferrer">角度</a>框架的工作知识</p>
<ul>
<li>理解可观测量:拉与推</li>
</ul>
<h2>为了理解可观测量，你必须首先理解拉和推的背景。在JavaScript中，有两种通信系统，称为推和拉。</h2>
<p>一个<strong>拉系统</strong>基本上就是一个函数。通常首先定义一个函数(一个称为<em>生产</em>的过程)，然后调用(这个过程称为<em>消费</em>)返回函数中的数据或值。对于函数，生产者(这是定义)不知道数据何时被消费，所以函数调用从生产者那里获取返回值或数据。</p>
<p>另一方面，推送系统控制在生产者手中，消费者不知道数据何时会被传递给它。一个常见的例子是JavaScript中的承诺，承诺(生产者)将已经解析的值推给回调(消费者)。另一个例子是RxJS Observables，Observables产生多个称为流的值(不同于返回一个值的承诺),并将它们推送给作为消费者的观察者。</p>
<p>什么是溪流？</p>
<h2><a href="https://angular.io/guide/observables" target="_blank" rel="noopener noreferrer">流</a>基本上是一段时间内的数据值序列，其范围可以是6秒内打印的简单数字增量(0，1，2，3，4，5)或一段时间内打印的坐标，甚至是通过web套接字或API响应传递的表单或聊天文本中输入的数据值。这些都表示将随时间收集的数据值，因此称为stream。</h2>
<p>什么是可观测量？</p>
<h2>理解流是很重要的，因为RxJS可观察性有助于理解流。一个可观察对象基本上是一个函数，它可以随着时间的推移向观察者返回一系列的值，这可以是同步的，也可以是异步的。返回的数据值可以从零到无限范围的值。</h2>
<p>观察者和订阅</p>
<h2>要让Observables工作，需要有观察者和订阅。观察器是数据源包装器，当有新值或数据值发生变化时，观察器会执行一些指令。可观察对象通过订阅连接到执行的观察者，通过订阅方法，观察者连接到可观察对象以执行代码块。</h2>
<p>可观察的生命周期</p>
<h2>在观察者和订阅的帮助下，可观察实例在其整个生命周期中会经历以下四个阶段:</h2>
<p>创造</p>
<ul>
<li>签署</li>
<li>执行</li>
<li>破坏</li>
<li>创造可观的</li>
</ul>
<h2>如果您从一开始就关注这篇文章，那么您一定已经用VS代码打开了Angular starter项目。要创建一个Observable，你必须首先从RxJS导入Observable到你想要创建它的组件的<code>.ts</code>文件中。创建语法如下所示:</h2>
<p>打开您的<code>app.component.ts</code>文件，并将下面的代码块复制到其中:</p>
<pre>import { Observable } from "rxjs";

var observable = Observable.create((observer:any) =&gt; {
    observer.next('Hello World!')
})</pre>
<p>订阅Observables</p>
<pre>import { Component, OnInit } from '@angular/core';
import { Observable } from "rxjs/";
@Component({
  selector: 'app-root',
  templateUrl: './app.component.html',
  styleUrls: ['./app.component.css']
})
export class AppComponent implements OnInit{
  title = 'ngcanvas';
  ngOnInit(): void {
    var observable = Observable.create()
  }
  
}</pre>
<h2>要告诉RxJS在可观察对象上执行代码块，或者用更简单的术语来说，调用可观察对象开始执行，您必须使用subscribe方法，如下所示:</h2>
<p>这个subscribe方法将导致在控制台中记录“hello world”。</p>
<pre>export class AppComponent implements OnInit{
  title = 'ngcanvas';
  ngOnInit(): void {
    var observable = Observable.create((observer:any) =&gt; {
      observer.next('Hello World!')
  })
  observable.subscribe(function logMessage(message:any) {
    console.log(message);
  })
}</pre>
<p>执行观察值</p>
<h2>观察者负责执行可观察对象中的指令，因此每个订阅的观察者可以向可观察对象传递三个值:</h2>
<p><strong>下一个值:</strong>对于下一个值，observer发送一个值，可以是数字、字符串或者对象。特定可观察对象上可以设置多个后续通知</p>
<ol>
<li><strong>错误值:</strong>利用错误值，观察者发送一个JavaScript异常。如果在可观察对象中发现一个错误，其他任何东西都不能交付给可观察对象</li>
<li><strong>完整值:</strong>有了完整值，观察者不发送任何值。这通常表示特定可观察对象的订阅已完成。如果发送了完整的值，就不能向可观察对象发送其他任何东西。</li>
<li>这可以用下面的代码块来说明:</li>
</ol>
<p>如果您此时在dev服务器中用</p>
<pre>export class AppComponent implements OnInit{
  title = 'ngcanvas';
  ngOnInit(): void {
    var observable = Observable.create((observer:any) =&gt; {
      observer.next('I am number 1')
      observer.next('I am number 2')
      observer.error('I am number 3')
      observer.complete('I am number 4')
      observer.next('I am number 5')
  })
  observable.subscribe(function logMessage(message:any) {
    console.log(message);
  })
}
}</pre>
<p>当您在开发人员工具中打开控制台时，您的日志将如下所示:</p>
<pre>ng serve</pre>
<p><img data-attachment-id="3991" data-permalink="https://blog.logrocket.com/understanding-rxjs-observables/angularerrorconsole/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2019/07/angularerrorconsole.png" data-orig-size="1362,422" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="angularerrorconsole" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2019/07/angularerrorconsole-300x93.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2019/07/angularerrorconsole-1024x317.png" decoding="async" class="aligncenter wp-image-3991 size-full jetpack-lazy-image" src="../Images/a368c385ca147b9b980f042b410c25f0.png" alt="error in console" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2019/07/angularerrorconsole.png 1362w, https://blog.logrocket.com/wp-content/uploads/2019/07/angularerrorconsole-300x93.png 300w, https://blog.logrocket.com/wp-content/uploads/2019/07/angularerrorconsole-768x238.png 768w, https://blog.logrocket.com/wp-content/uploads/2019/07/angularerrorconsole-1024x317.png 1024w" data-lazy-sizes="(max-width: 1362px) 100vw, 1362px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2019/07/angularerrorconsole.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/07/angularerrorconsole.png"/></p>
<p>您会注意到，错误值或完整值会自动停止执行，因此数字5不会出现在控制台中。这是一个简单的同步练习。为了使它异步，让我们在一些值周围包装计时器。</p><noscript><img data-lazy-fallback="1" data-attachment-id="3991" data-permalink="https://blog.logrocket.com/understanding-rxjs-observables/angularerrorconsole/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2019/07/angularerrorconsole.png" data-orig-size="1362,422" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="angularerrorconsole" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2019/07/angularerrorconsole-300x93.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2019/07/angularerrorconsole-1024x317.png" decoding="async" loading="lazy" class="aligncenter wp-image-3991 size-full" src="../Images/a368c385ca147b9b980f042b410c25f0.png" alt="error in console" srcset="https://blog.logrocket.com/wp-content/uploads/2019/07/angularerrorconsole.png 1362w, https://blog.logrocket.com/wp-content/uploads/2019/07/angularerrorconsole-300x93.png 300w, https://blog.logrocket.com/wp-content/uploads/2019/07/angularerrorconsole-768x238.png 768w, https://blog.logrocket.com/wp-content/uploads/2019/07/angularerrorconsole-1024x317.png 1024w" sizes="(max-width: 1362px) 100vw, 1362px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/07/angularerrorconsole.png"/></noscript>
<p>这将在您的浏览器控制台中显示如下:</p>
<pre>export class AppComponent implements OnInit{
  title = 'ngcanvas';
  ngOnInit(): void {
    var observable = Observable.create((observer:any) =&gt; {
      observer.next('I am number 1')
      observer.next('I am number 2')
      setInterval(() =&gt; {
        observer.next('Random Async log message')
    }, 2000)
    observer.next('I am number 3')
    observer.next('I am number 4')
      setInterval(() =&gt; {
        observer.error('This is the end')
    }, 6001)
    observer.next('I am number 5')
  })
  observable.subscribe(function logMessage(message:any) {
    console.log(message);
  })
}
}</pre>
<p><img data-attachment-id="3992" data-permalink="https://blog.logrocket.com/understanding-rxjs-observables/consoleerrors/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2019/07/consoleerrors.gif" data-orig-size="566,270" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="consoleerrors" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2019/07/consoleerrors-300x143.gif" data-large-file="https://blog.logrocket.com/wp-content/uploads/2019/07/consoleerrors.gif" decoding="async" class="aligncenter wp-image-3992 size-full jetpack-lazy-image" src="../Images/21ae9b5009bf0f8620a864c323d49a30.png" alt="console errors " data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2019/07/consoleerrors.gif?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/07/consoleerrors.gif"/></p>
<p>请注意，在setInterval模块的帮助下，这里的值显示是异步完成的。</p><noscript><img data-lazy-fallback="1" data-attachment-id="3992" data-permalink="https://blog.logrocket.com/understanding-rxjs-observables/consoleerrors/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2019/07/consoleerrors.gif" data-orig-size="566,270" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="consoleerrors" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2019/07/consoleerrors-300x143.gif" data-large-file="https://blog.logrocket.com/wp-content/uploads/2019/07/consoleerrors.gif" decoding="async" loading="lazy" class="aligncenter wp-image-3992 size-full" src="../Images/21ae9b5009bf0f8620a864c323d49a30.png" alt="console errors " data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/07/consoleerrors.gif"/></noscript>
<p>摧毁一个可见的</p>
<h2>摧毁一个可观察对象实质上就是通过取消订阅将它从<a href="https://blog.logrocket.com/8-dom-features-you-didnt-know-existed-ec2a0a28fd89/" target="_blank" rel="noopener noreferrer"> DOM </a>中移除。通常对于异步逻辑，RxJS负责退订，在错误或完整通知之后，您的可观察对象立即退订。对于知识，您可以像这样手动触发取消订阅:</h2>
<p>为什么可观察性如此重要</p>
<pre>return function unsubscribe() {
    clearInterval(observable);
  };</pre>
<h2>用Observables异步发出多个值非常容易处理</h2>
<ul>
<li>错误处理程序也可以很容易地在Observables内部完成，而不是像promises这样的构造</li>
<li>可观测量被认为是惰性的，因此在没有订阅的情况下，不会发出数据值</li>
<li>与功能甚至承诺相反，可观察到的问题可以解决多次</li>
<li>结论</li>
</ul>
<h2>我们已经对RxJS中的可观察对象、观察者和订阅进行了全面的介绍。我们还通过实际例子了解了可观测量的生命周期过程。更多RxJS的帖子可以在博客上找到，黑客快乐！</h2>
<p> </p>
<p>使用<a class="signup" href="https://lp.logrocket.com/blg/signup" target="_blank" rel="noopener noreferrer"> LogRocket </a>消除传统错误报告的干扰</p><div class="code-block code-block-2">
<div class="blog-plug base-cta"><h2><a href="https://lp.logrocket.com/blg/signup" target="_blank" rel="noopener noreferrer"> LogRocket </a>是一个数字体验分析解决方案，它可以保护您免受数百个假阳性错误警报的影响，只针对几个真正重要的项目。LogRocket会告诉您应用程序中实际影响用户的最具影响力的bug和UX问题。</h2>
<a href="https://lp.logrocket.com/blg/signup" class="signup" target="_blank" rel="noopener noreferrer"><img class="alignnone size-full wp-image-46 jetpack-lazy-image" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/><noscript><img data-lazy-fallback="1" class="alignnone size-full wp-image-46" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/></noscript></a>
<p>然后，使用具有深层技术遥测的会话重放来确切地查看用户看到了什么以及是什么导致了问题，就像你在他们身后看一样。</p>
<p>LogRocket自动聚合客户端错误、JS异常、前端性能指标和用户交互。然后LogRocket使用机器学习来告诉你哪些问题正在影响大多数用户，并提供你需要修复它的上下文。</p>
<p>关注重要的bug—<a class="signup" href="https://lp.logrocket.com/blg/signup-issue-free" target="_blank" rel="noopener noreferrer">今天就试试LogRocket】。</a></p>
<p>Focus on the bugs that matter — <a class="signup" href="https://lp.logrocket.com/blg/signup-issue-free" target="_blank" rel="noopener noreferrer">try LogRocket today</a>.</p></div></div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>
 
</div>    
</body>
</html>
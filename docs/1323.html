<html>
<head>
<title>An introduction to ent - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>耳鼻喉科博客简介</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/an-introduction-to-ent/#0001-01-01">https://blog.logrocket.com/an-introduction-to-ent/#0001-01-01</a></blockquote><div><article class="article-post">
<p>数据库系统是软件开发不可或缺的一部分。无论选择哪种编程语言，软件开发人员都需要熟练使用数据库。大多数编程语言都有各种工具/包，使得开发人员使用数据库管理系统变得容易。这些工具中的一些是编程语言所固有的，另一些是由围绕该语言的开发人员社区构建/维护的，并且可以免费使用。</p>
<p>由于Go编程语言缺乏基于图形的ORM(对象关系映射),脸书的一个开发团队创建了ent。Ent是一个实体框架，通常用于在基于图形的结构中建模数据。ent框架以其将数据建模为Go代码的能力而自豪，不像许多其他ORM将数据建模为<a href="https://golang.org/ref/spec#Tag" target="_blank" rel="noopener noreferrer"> struct标签</a>。由于ent框架的基于图的结构，查询存储在数据库中的数据可以很容易地完成，并采用图遍历的形式。ent附带了一个命令行工具，我们可以使用它来自动生成代码模式并获得模式的可视化表示。</p>
<p>在这篇文章中，我们将探索ent框架的所有很酷的特性，并构建一个简单的CRUD API来利用ent的各种功能。</p>
<h2>先决条件</h2>
<p>要阅读这篇文章，您需要:</p>

<h2>耳鼻喉科入门</h2>
<p>使用ent框架的第一步是将它安装到我们的项目中。要安装ent，运行下面的命令<code>go get github.com/facebook/ent/cmd/entc</code>。该命令将为ent包安装命令行工具<a href="https://github.com/facebook/ent/tree/master/entc" target="_blank" rel="noopener noreferrer"> entc </a>。</p>
<p>在本文中，我们将构建一个简单的利用ent的CRUD(创建、读取、更新和删除)API。该API将包含五个端点，构建该API的目的是展示如何使用ent在数据库上执行常见的创建、读取、更新和删除操作。</p>
<p>首先，创建所需的文件和文件夹以匹配下面的树结构:</p>
<pre>├── handlers/
│ ├── handler.go
├── database/
│ ├── db.go
└── main.go</pre>
<ul>
<li><code>main.go</code>文件将包含与为API创建服务器相关的所有逻辑。我们将使用<a href="https://github.com/gofiber/fiber" target="_blank" rel="noopener noreferrer">纤程</a>，Go的快速风格框架来快速连接我们的API端点。<a href="https://blog.logrocket.com/express-style-api-go-fiber/" target="_blank" rel="noopener noreferrer">这篇文章</a>是纤维的一个伟大开端</li>
<li>数据库目录中的<code>db.go</code>文件将包含与创建数据库连接和客户机相关的代码</li>
<li><code>handler.go</code>文件将存放API处理程序</li>
</ul>
<p>在下一节中，我们将开始构建API并探索ent。</p>
<h2>对耳鼻喉科的深入研究</h2>
<p>要开始这个项目，运行项目根目录中的<code>go mod init</code>。这将初始化一个带有Go模块的新项目。接下来，我们必须通过在项目<code>github.com/gofiber/fiber/v2</code>的根目录下运行以下命令来安装fiber，这是我们将在构建API时使用的框架。</p>
<p>在为一个假想的笔记应用程序构建API时，我们需要以下端点:</p>
<ul>
<li>/API/v1/create notes</li>
<li>API 1/readnote؛</li>
<li>/api/v1/searchnote/:标题</li>
<li>/api/v1/updatenote/:id</li>
<li>/api/v1/deletenote/:id</li>
</ul>
<p>在<code>main.go</code>文件中，添加以下代码行:</p>
<pre>package main

import (
   "fmt"

   "github.com/gofiber/fiber/v2"
)

func Routes(app *fiber.App){
   api := app.Group("/api/v1")

   api.Get("/", func(c *fiber.Ctx) error {
      return c.SendString("Hello, World!")
   })
}

func main() {
   app := fiber.New()

   Routes(app)

   err := app.Listen(":3000")
   if err != nil {
      fmt.Println("Unable to start server")
   }
}</pre>
<p>上面的代码创建了一个简单的web服务器。目前只有一个端点被连接，在接下来的部分中，我们将在<code>handler.go</code>文件中工作，以确保所有的API端点都正常工作。现在，您可以运行上面的文件并在浏览器上访问<code>localhost:3000/api/v1/</code>。如果一切顺利，您应该会看到“hello world”被打印出来。</p>
<h2>创建模式</h2>
<p>使用ent创建模式很容易，这要感谢我们在上面安装的命令行工具entc。对于我们的API，我们将创建一个名为notes的模式，在项目目录的根目录下创建模式run <code>entc init Notes</code>。这个命令将自动生成我们的Notes模式。与模式相关的代码可以在<code>ent/schema/notes.go</code>中找到。此时，模式为空，不包含任何字段。对于我们的API，我们的模式将有四个字段:</p>
<ul>
<li>标题</li>
<li>内容</li>
<li>私人的</li>
<li>创建于</li>
</ul>
<p>为了在我们的模式中定义字段，我们在<code>Field</code>函数中使用了ent提供的fields子包。我们调用字段的类型，像这样传入所需模式字段的名称:</p>
<pre>field.String("Title")</pre>
<p>对于我们的API，我们将指定标题、内容和私有字段作为模式的属性。ent目前支持所有Go数值类型、string、bool和<code>time.Time</code>！将字段添加到模式后，我们的<code>notes.go</code>文件应该如下所示:</p>
<pre>package schema

import (
   "time"

   "github.com/facebook/ent"
   "github.com/facebook/ent/schema/field"
)

// Notes holds the schema definition for the Notes entity.
type Notes struct {
   ent.Schema
}

// Fields of the Notes.
func (Notes) Fields() []ent.Field {
   return []ent.Field{
      field.String("Title").
         Unique(),
      field.String("Content"),
      field.Bool("Private").
         Default(false),
      field.Time("created_at").
         Default(time.Now),
   }
}

// Edges of the Notes.
func (Notes) Edges() []ent.Edge {
   return nil
}</pre>
<p>field子包还提供了helper函数来验证字段输入，如上面的代码片段所示。所有内置验证器的完整列表可以在<a href="https://entgo.io/docs/schema-fields/#validators" target="_blank" rel="noopener noreferrer">这里</a>找到。现在我们已经添加了必要的字段，我们可以继续生成一些资产来使用数据库。</p>
<p>ent自动生成资产，包括CRUD构建器和一个实体对象。要生成资产，在项目目录<code>go generate./ent</code>的根目录下运行下面的命令，您会注意到一堆文件将被添加到我们项目的<code>/ent</code>目录中。添加的文件包含与生成的资产相关的代码。在接下来的小节中，我们将学习如何使用这些生成的资产来执行CRUD操作，并继续构建notes API。</p>
<h2>可视化模式</h2>
<p>entc是ent框架的命令行工具，它使我们能够在终端中获得模式的可视化表示。要可视化模式，只需在项目目录的根目录下运行下面的命令<code>entc describe./ent/schema</code>，您应该会看到类似下图的notes模式的可视化表示。</p>
<p><img data-attachment-id="29056" data-permalink="https://blog.logrocket.com/an-introduction-to-ent/schemadescribe/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/11/SchemaDescribe.png" data-orig-size="926,276" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="SchemaDescribe" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/11/SchemaDescribe-300x89.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/11/SchemaDescribe.png" decoding="async" class="aligncenter size-full wp-image-29056 jetpack-lazy-image" src="../Images/6846dd645842ddb9109ce61e27ca48a5.png" alt="schema " data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2020/11/SchemaDescribe.png 926w, https://blog.logrocket.com/wp-content/uploads/2020/11/SchemaDescribe-300x89.png 300w, https://blog.logrocket.com/wp-content/uploads/2020/11/SchemaDescribe-768x229.png 768w" data-lazy-sizes="(max-width: 926px) 100vw, 926px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2020/11/SchemaDescribe.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/11/SchemaDescribe.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="29056" data-permalink="https://blog.logrocket.com/an-introduction-to-ent/schemadescribe/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/11/SchemaDescribe.png" data-orig-size="926,276" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="SchemaDescribe" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/11/SchemaDescribe-300x89.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/11/SchemaDescribe.png" decoding="async" loading="lazy" class="aligncenter size-full wp-image-29056" src="../Images/6846dd645842ddb9109ce61e27ca48a5.png" alt="schema " srcset="https://blog.logrocket.com/wp-content/uploads/2020/11/SchemaDescribe.png 926w, https://blog.logrocket.com/wp-content/uploads/2020/11/SchemaDescribe-300x89.png 300w, https://blog.logrocket.com/wp-content/uploads/2020/11/SchemaDescribe-768x229.png 768w" sizes="(max-width: 926px) 100vw, 926px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/11/SchemaDescribe.png"/></noscript>
<h2>连接到数据库</h2>
<p>ent为我们提供了连接到包括PostgreSQL在内的几个数据库的功能。在<code>database.go</code>文件中，我们创建了一个<a href="https://www.digitalocean.com/community/tutorials/understanding-init-in-go" target="_blank" rel="noopener noreferrer"> init </a>函数，它使用<code>ent.Open</code>函数连接到一个数据库，并返回一个类型为<code>ent.Client</code>的客户端。<code>Open</code>函数接受数据库的名称及其连接字符串。</p>
<p>对于我们正在构建的API，我们将使用PostgreSQL数据库。首先，我们将启动Postgres的docker实例，并通过三个简单的步骤从本地机器连接到它。</p>
<p>要跟进，您必须在本地机器上安装<a href="https://docs.docker.com/engine/install/ubuntu/" target="_blank" rel="noopener noreferrer">docker</a>。</p>

<p>现在我们已经连接好了数据库容器，接下来需要做的是导入PostgreSQL的驱动程序，作为我们项目的一个副作用。要安装驱动程序，请在项目目录的根目录下运行<code>go get github.com/lib/pq</code>。设置好一切后，将下面几行代码添加到<code>database.go</code>文件中:</p>
<pre>var EntClient *ent.Client
func init() {
//Open a connection to the database
   Client, err := ent.Open("postgres","host=localhost port=5432 user=postgres dbname=notesdb password=mysecretpassword sslmode=disable")
   if err != nil {
      log.Fatal(err)
   }

   fmt.Println("Connected to database successfully")
   defer Client.Close()
// AutoMigration with ENT
   if err := Client.Schema.Create(context.Background()); err != nil {
      log.Fatalf("failed creating schema resources: %v", err)
   }
   EntClient = Client
}</pre>
<h2>保存到数据库</h2>
<p>使用ent框架，执行创建操作/保存到数据库变得很容易。在本节中，我们将添加create note端点，它将负责将新的注释保存到数据库中。</p>
<p>首先，在<code>handler.go</code>文件中，我们创建了一个名为<code>createNotes</code>的函数，它实现了<code>fibers</code>处理程序接口。在<code>createNotes</code>函数内部，我们使用fiber提供的主体解析器函数解析请求主体。</p>
<p>ent拥有由它的命令行工具<code>entc</code>自动生成的助手方法。我们调用<code>setTitle</code>和<code>setContent</code>方法，将它们各自的值作为类型字符串传入。最后，为了确保数据被保存，我们调用了传入上下文值的<code>save</code>方法:</p>
<pre>func CreateNote(c *fiber.Ctx) error{
//Parse the request body
   note := new(struct{
      Title string
      Content string
      Private bool
   })

   if err := c.BodyParser(&amp;note); err != nil {
      c.Status(400).JSON("Error  Parsing Input")
      return err
   }
//Save to the database
   createdNote, err := database.EntClient.Notes.
      Create().                      
      SetTitle(note.Title).
      SetContent(note.Content).
      SetPrivate(note.Private).
      Save(context.Background())  

   if err != nil {
      c.Status(500).JSON("Unable to save note")
      return err
   }
//Send the created note back with the appropriate code.
   c.Status(200).JSON(createdNote)

   return nil
}</pre>
<p>至此，我们已经做好了准备，并添加了创建新实体的逻辑。要注册上述处理程序，只需将下面一行代码添加到我们在上面的<code>main.go</code>文件中创建的routes函数中:</p>
<pre>api.Post("/createnote", handlers.CreateNote)</pre>
<p>如果我们启动应用程序并向<code>localhost:3000/api/v1/createnote</code>发出post请求，传入一个注释的标题和内容，您应该会看到类似下图的输出，表明注释已经成功创建。</p>
<p><img data-attachment-id="29067" data-permalink="https://blog.logrocket.com/an-introduction-to-ent/createnote/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/11/CreateNote.png" data-orig-size="974,518" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="CreateNote" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/11/CreateNote-300x160.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/11/CreateNote.png" decoding="async" class="aligncenter size-full wp-image-29067 jetpack-lazy-image" src="../Images/e86a1d8e424443d1af083a42a1d83e94.png" alt="note created successfully " data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2020/11/CreateNote.png 974w, https://blog.logrocket.com/wp-content/uploads/2020/11/CreateNote-300x160.png 300w, https://blog.logrocket.com/wp-content/uploads/2020/11/CreateNote-768x408.png 768w" data-lazy-sizes="(max-width: 974px) 100vw, 974px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2020/11/CreateNote.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/11/CreateNote.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="29067" data-permalink="https://blog.logrocket.com/an-introduction-to-ent/createnote/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/11/CreateNote.png" data-orig-size="974,518" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="CreateNote" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/11/CreateNote-300x160.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/11/CreateNote.png" decoding="async" loading="lazy" class="aligncenter size-full wp-image-29067" src="../Images/e86a1d8e424443d1af083a42a1d83e94.png" alt="note created successfully " srcset="https://blog.logrocket.com/wp-content/uploads/2020/11/CreateNote.png 974w, https://blog.logrocket.com/wp-content/uploads/2020/11/CreateNote-300x160.png 300w, https://blog.logrocket.com/wp-content/uploads/2020/11/CreateNote-768x408.png 768w" sizes="(max-width: 974px) 100vw, 974px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/11/CreateNote.png"/></noscript>
<h2>从数据库中读取</h2>
<p>有了ent，查询数据库变得很容易。<code>entc</code>为每个模式生成一个包，其中包含用于搜索数据库的有用资产。在客户端，为了与自动生成的构建器进行交互，我们调用了<code>Query</code>函数。该函数为模式返回一个查询生成器，生成器的一部分包括<code>Where</code>和<code>Select</code>。</p>
<p>在本节中，我们将编写两个端点的逻辑代码:</p>
<ol>
<li><code>/api/v1/readnotes/</code>–该端点将使我们能够读取数据库中的所有笔记</li>
<li><code>/searchnotes/:title</code>–这个端点使我们能够通过标题在数据库中搜索特定的笔记</li>
</ol>
<p>我们将从构建<code>/api/v1/readnotes/</code>端点开始。在<code>handlers.go</code>文件中，我们创建了一个名为<code>ReadNotes</code>的处理函数，类似于上面的<code>createnote</code>函数，它实现了纤程处理程序接口。在<code>ReadNotes</code>函数中，我们对<code>EntClient</code>变量调用<code>Query</code>。为了指定我们想要匹配查询的所有记录，我们在查询构建器上调用<code>All</code>。在这一点上，完整的<code>ReadNotes</code>函数应该看起来像这样:</p>
<pre>func ReadNote(c *fiber.Ctx) error{
   readNotes, err := database.EntClient.Notes.
      Query().
      All(context.Background())
   if err != nil {
      c.Status(500).JSON("No Notes Found")
      log.Fatal(err)
   }
   c.Status(200).JSON(readNotes)
   return nil
}</pre>
<p><code>ReadNotes</code>处理函数已经准备好了，我们现在可以通过在<code>main.go</code>中的<code>Routes</code>函数中添加下面一行来在服务器上注册它:</p>
<pre>api.Get("/readnotes", handlers.ReadNote)</pre>
<p>我们现在可以启动我们的应用程序并访问路线<code>/api/v1/readnotes/</code>来测试它。如果一切顺利，您应该会看到一个包含数据库中所有笔记的数组，如下图所示:</p>
<p><img data-attachment-id="29072" data-permalink="https://blog.logrocket.com/an-introduction-to-ent/readnote/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/11/ReadNote.png" data-orig-size="963,517" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="ReadNote" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/11/ReadNote-300x161.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/11/ReadNote.png" decoding="async" class="aligncenter size-full wp-image-29072 jetpack-lazy-image" src="../Images/387d6f69d1239905326982da0d131741.png" alt="Read note " data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2020/11/ReadNote.png 963w, https://blog.logrocket.com/wp-content/uploads/2020/11/ReadNote-300x161.png 300w, https://blog.logrocket.com/wp-content/uploads/2020/11/ReadNote-768x412.png 768w" data-lazy-sizes="(max-width: 963px) 100vw, 963px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2020/11/ReadNote.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/11/ReadNote.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="29072" data-permalink="https://blog.logrocket.com/an-introduction-to-ent/readnote/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/11/ReadNote.png" data-orig-size="963,517" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="ReadNote" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/11/ReadNote-300x161.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/11/ReadNote.png" decoding="async" loading="lazy" class="aligncenter size-full wp-image-29072" src="../Images/387d6f69d1239905326982da0d131741.png" alt="Read note " srcset="https://blog.logrocket.com/wp-content/uploads/2020/11/ReadNote.png 963w, https://blog.logrocket.com/wp-content/uploads/2020/11/ReadNote-300x161.png 300w, https://blog.logrocket.com/wp-content/uploads/2020/11/ReadNote-768x412.png 768w" sizes="(max-width: 963px) 100vw, 963px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/11/ReadNote.png"/></noscript>
<p>用于读取数据库中存储的所有笔记的<code>readnotes</code>端点已经连接好，接下来我们将连接<code>searchnotes</code>端点，它将在数据库中搜索任何标题与搜索查询匹配的笔记。就像我们到目前为止对每个处理程序所做的一样，我们创建了一个名为<code>SearchNotes</code>的函数。</p>
<p>在这个函数中，我们使用fibers内置的<code>params</code>方法检索作为请求参数传递的搜索查询。接下来，我们在客户端调用<code>Query</code>构建器方法，就像我们调用<code>ReadNotes</code>函数一样。为了指定搜索查询，我们调用另一个名为<code>where</code>的方法，<code>where</code>方法向查询构建器添加了一个新的谓词。作为<code>where</code>方法的参数，我们可以传入由<code>entc</code>自动生成的标题谓词:</p>
<pre>func SearchNotes(c *fiber.Ctx) error{
//extract search query
   query := c.Params("title")
   if query == "" {
      c.Status(400).JSON("No Search Query")
   }
 //Search the database
   createdNotes, err := database.EntClient.Notes.
      Query().
      Where(notes.Title(query)).
      All(context.Background())

   if err != nil {
      c.Status(500).JSON("No Notes Found")
      log.Fatal(err)
   }

   c.Status(200).JSON(createdNotes)
   return nil
}</pre>
<p>最后，我们可以通过将下面一行代码添加到<code>main.go</code>文件来注册<code>SearchNotes</code>函数:</p>
<pre>api.Get("/searchnotes/:title", handlers.SearchNotes)</pre>
<p>我们已经完成了对<code>searchnotes</code>端点的测试，可以通过启动应用程序并访问<code>localhost:3000/api/v1/searchnotes/Lorem</code>来测试它。如果一切顺利，您应该会看到一个标题为Lorem的注释，如果它存在于数据库中的话。</p>
<h2>更新记录</h2>
<p>构建API时，提供更新数据库中记录的功能非常重要，因为它符合您的业务逻辑。由于所有生成的资产都包含构建函数，ent使得更新记录变得容易。在本节中，我们将构建notes API的更新路径，并学习如何使用ent更新记录。</p>
<p>首先，我们转到<code>handlers.go</code>文件并创建一个名为<code>UpdateNotes</code>的函数。这个函数和<code>handler.go</code>文件中的其他函数一样，实现了纤程的处理程序接口。在<code>UpdateNotes</code>函数中，我们解析请求体以确保只有内容字段可以被更新。接下来，我们通过使用键调用<code>params</code>函数，从查询参数中检索要更新的记录的ID。因为我们使用纤程作为类型字符串来检索查询参数，所以我们必须使用<code>strconv</code>包中可用的<code>Atoi</code>函数将检索到的参数转换为Int，该Int对应于数据库中存储的类型。</p>
<p>为了更新记录，我们调用函数<code>UpdateOneId</code>并传递从上面的用户那里获取的ID。调用<code>UpdateOneId</code>函数返回给定ID的更新构建器。接下来，我们调用<code>setContent</code>函数。<code>setContent</code>是根据我们上面声明的模式和字段自动生成的。<code>setContent</code>函数接受对我们模式的内容字段的指定更新。最后，我们可以通过使用上下文调用<code>Save</code>函数来保存更新的记录:</p>
<pre>func UpdateNote(c *fiber.Ctx) error{
//Parse the request Body
   note := new(struct{
      Content string
   })

   if err := c.BodyParser(&amp;note); err != nil {
      c.Status(400).JSON("Error  Parsing Input")
      return err
   }
//Extract &amp; Convert the request parameter
   idParam := c.Params("id")
   if idParam == "" {
      c.Status(400).JSON("No Search Query")
   }
   id, _ := strconv.Atoi(idParam)
//Update the note in the database
   UpdatedNotes, err := database.EntClient.Notes.
      UpdateOneID(id).
      SetContent(note.Content).
      Save(context.Background())

   if err != nil {
      c.Status(500).JSON("No Notes Found")
      log.Fatal(err)
   }

   c.Status(200).JSON(UpdatedNotes)
   return nil
}</pre>
<p>有了这样的<code>UpdateNote</code>函数，我们就可以通过向<code>Routes</code>函数添加下面一行代码来注册处理程序了:</p>
<pre>api.Put("/updatenote/:id", handlers.UpdateNote)</pre>
<p>向上述路由发出put请求并提供有效的记录id，更新相应的记录。</p>
<h2>删除记录</h2>
<p>删除记录类似于更新操作，但是，当使用ent删除记录时，会使用不同的函数。要删除一条记录，使用接收ID并返回给定用户的删除生成器的函数<code>DeleteOneId</code>。我们还调用了<code>Exec</code>函数。<code>Exec</code>接收一个上下文并在数据库上执行删除操作:</p>
<pre>func DeleteNotes(c *fiber.Ctx) error{
   idParam := c.Params("id")
   if idParam == "" {
      c.Status(400).JSON("No Search Query")
   }

   id, _ := strconv.Atoi(idParam)
//Delete the Record frm the databse
   err := database.EntClient.Notes.
      DeleteOneID(id).
      Exec(context.Background())

   if err != nil {
      c.Status(500).JSON("Unable to Perform Operation")
   }

   c.Status(200).JSON("Success")

   return nil
}</pre>
<p>我们可以通过将下面一行代码添加到<code>handler.go</code>文件中的<code>route</code>函数来注册上面的处理函数:</p>
<pre>api.Delete("/deletenote/:id", handlers.DeleteNotes)</pre>
<p><code>deletenote</code>路线都定好了！现在，您可以通过指定ID来删除数据库中的任何注释。</p>
<h2>结论</h2>
<p>到目前为止，我们已经使用ent框架为笔记应用程序构建了一个API来与PostgreSQL数据库进行交互。由于ent和entc生成的资产，我们不必编写任何SQL查询，也不必太担心执行CRUD操作的逻辑。本文旨在帮助您开始使用耳鼻喉科。我强烈建议您查看官方的<a href="https://entgo.io/" target="_blank" rel="noopener noreferrer">文档</a>作为参考指南。这个项目的完整源代码可以在<a href="https://github.com/Ghvstcode/Facebook-Ent-Framework-API" target="_blank" rel="noopener noreferrer">这里</a>找到。</p><div class="code-block code-block-1">
<div class="blog-plug base-cta"><h2>使用<a class="signup" href="https://lp.logrocket.com/blg/signup" target="_blank" rel="noopener noreferrer"> LogRocket </a>消除传统错误报告的干扰</h2>
<a href="https://lp.logrocket.com/blg/signup" class="signup" target="_blank" rel="noopener noreferrer"><img class="alignnone size-full wp-image-46 jetpack-lazy-image" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/><noscript><img data-lazy-fallback="1" class="alignnone size-full wp-image-46" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/></noscript></a>
<p><a href="https://lp.logrocket.com/blg/signup" target="_blank" rel="noopener noreferrer"> LogRocket </a>是一个数字体验分析解决方案，它可以保护您免受数百个假阳性错误警报的影响，只针对几个真正重要的项目。LogRocket会告诉您应用程序中实际影响用户的最具影响力的bug和UX问题。</p>
<p>然后，使用具有深层技术遥测的会话重放来确切地查看用户看到了什么以及是什么导致了问题，就像你在他们身后看一样。</p>
<p>LogRocket自动聚合客户端错误、JS异常、前端性能指标和用户交互。然后LogRocket使用机器学习来告诉你哪些问题正在影响大多数用户，并提供你需要修复它的上下文。</p>
<p>关注重要的bug—<a class="signup" href="https://lp.logrocket.com/blg/signup-issue-free" target="_blank" rel="noopener noreferrer">今天就试试LogRocket】。</a></p></div></div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
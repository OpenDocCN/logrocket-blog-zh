<html>
<head>
<title>Defining types for your GraphQL API - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>为您的GraphQL API - LogRocket博客定义类型</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/defining-types-for-your-graphql-api/#0001-01-01">https://blog.logrocket.com/defining-types-for-your-graphql-api/#0001-01-01</a></blockquote><div><article class="article-post">
<p>GraphQL是一种用于API的查询语言。它是脸书在2015年开源的<a href="https://github.com/graphql" target="_blank" rel="noopener noreferrer">T3，从那以后作为REST的替代品获得了巨大的人气。像</a><a href="https://medium.com/paypal-engineering/graphql-a-success-story-for-paypal-checkout-3482f724fb53" target="_blank" rel="noopener noreferrer"> PayPal </a>、<a href="https://help.shopify.com/en/api/graphql-admin-api" target="_blank" rel="noopener noreferrer"> Shopify </a>、<a href="https://developer.github.com/v4/" target="_blank" rel="noopener noreferrer"> GitHub </a>这样的公司，以及许多其他领先的科技公司如今都在使用GraphQL。创建GraphQL是为了在客户机和服务器之间有更好的通信。在这篇博文中，我们将了解GraphQL类型以及如何使用它们来构建GraphQL模式。</p>
<h2>强类型架构</h2>
<p>GraphQL有一个<a href="https://en.wikipedia.org/wiki/Strong_and_weak_typing" target="_blank" rel="noopener noreferrer">强类型</a>模式。这意味着模式充当客户机和服务器之间的契约。这是使用GraphQL的最大好处之一。</p>
<h3>强类型架构的好处</h3>
<ul>
<li><strong>模式充当契约</strong> —对于强类型模式，模式充当客户端和服务器之间的契约。有了这个明确定义的模式，客户机和服务器之间的交互变得更加容易。它减少了使用API时客户机/服务器交互中可能出现的任何错误通信和潜在延迟</li>
<li><strong>错误的早期检测</strong> —在GraphQL中，您可以在开发阶段在GraphQL编辑器中发现大量错误。这是因为，由于模式的强类型特性，传递给API的任何不正确的数据都将被标记为错误。这在开发周期中节省了大量的时间和精力</li>
<li><strong>团队独立工作</strong>——因为一切都在模式中明确定义，强类型模式也可以生成客户可以使用的文档，前端和后端团队可以独立工作</li>
</ul>
<h2>GraphQL标量类型</h2>
<p><a href="https://graphql.github.io/graphql-spec/June2018/#sec-Scalars" target="_blank" rel="noopener noreferrer">标量类型</a>是GraphQL中的原始数据类型。以下是GraphQL支持的原始数据类型:</p>
<ul>
<li><a href="https://graphql.github.io/graphql-spec/June2018/#sec-Int">Int</a>–一个有符号的32位整数</li>
<li><a href="https://graphql.github.io/graphql-spec/June2018/#sec-Float">Float</a>–有符号双精度浮点值</li>
<li><a href="https://graphql.github.io/graphql-spec/June2018/#sec-String">字符串</a>–UTF 8字符序列</li>
<li><a href="https://graphql.github.io/graphql-spec/June2018/#sec-Boolean">布尔型</a>–代表真/假</li>
<li><a href="https://graphql.github.io/graphql-spec/June2018/#sec-ID">ID</a>–唯一标识符</li>
</ul>
<p>让我们编写一个GraphQL对象，它有自己的特征，由项组成，每项都有自己的类型:</p>
<pre>type BlogPost {
      id: ID
      title: String
      author: String
      numberOfLikes: Int
    }</pre>
<p>在上面的例子中，我们创建了一个类型为<em> BlogPost </em>的复杂对象。<em> BlogPost </em>对象包含id、文章标题、文章作者和收到的赞数。当您编写GraphQL模式时，您要做的第一件事就是定义类型。</p>
<p>由于GraphQL是强类型的，并且严重依赖于类型，所以在创建模式之前，就在一开始定义了这些类型。</p>
<p>让我们看看GraphQL中更多的类型来进一步理解这一点。</p>
<h2>Enum类型(在GraphQL中)</h2>
<p>GraphQL支持<em>枚举</em>类型，它们的工作方式就像在任何其他编程语言中一样。枚举允许您验证任何参数都可以有一个定义的值。枚举也是GraphQL中的标量类型。</p>
<p>下面是GraphQL中枚举类型的一个示例:</p>
<pre>enum BlogTopics {
  WEB,
  MOBILE,
  FRONTEND,
  BACKEND, 
  GENERAL
}</pre>
<p>在这个例子中，我们定义了一个类型为<em> BlogTopics </em>的枚举。这个枚举可以有五个值。主题可以是web、移动、前端、后端或常规。<em> BlogTopics </em>类型允许具有这五个值中的任何一个。</p>
<h2>GraphQL中的列表类型</h2>
<p>GraphQL模式支持标量类型的扩展，以监听条目。这很简单，只需在类型周围添加方括号，使其成为该类型的列表。例如，如果您想要一个整数列表，您可以将其声明为<strong> int </strong>，这表明它是一个列表类型。</p>
<p>让我们给我们最初的<em> BlogPost </em>类型添加一个列表类型:</p>
<pre>type BlogPost {
  id: ID
  title: String
  author: String
  numberOfLikes: Int
  comments: [String]
}</pre>
<p>我们为博客文章评论添加了一个条目，它是一个字符串列表。这意味着它可以将多个评论保存为一个列表。GraphQL模式中经常使用列表。</p>
<h2>查询和变异类型</h2>
<p>GraphQL模式可以不仅仅包含标量类型。最常用的两种类型是<a href="https://graphql.org/learn/schema/#the-query-and-mutation-types" target="_blank" rel="noopener noreferrer">查询和变异类型</a>。</p>
<p>每个GraphQL服务都有一个查询类型。这是GraphQL模式的入口点。GraphQL中的查询表示客户端对GraphQL API的要求。</p>
<p>要了解更多关于GraphQL查询的信息，你可以阅读我写的博客文章,它详细描述了GraphQL中查询是如何构造的。</p>
<p>尽管每个GraphQL服务都有一个查询类型，但它可能包含也可能不包含变异类型。GraphQL突变用于添加/更新/删除数据。客户端可以使用可用的突变来更新数据。你可以把它想象成REST世界中的POST请求。</p>
<p>下面是如何在GraphQL模式中定义查询和变异类型:</p>
<pre>schema {
      query: Query
      mutation: Mutation
    }</pre>
<p>在GraphQL中，查询和变异类型都像任何其他数据类型一样被处理。</p>
<p>让我们看一些例子来更好地理解这些。我将扩展我们之前的类型为<em> BlogPost </em>的例子，以包括一个查询和变异类型:</p>
<pre>type Query {
  blog_info: [BlogPost]
}</pre>
<p>在上面的例子中，我们定义了一个名为<em> blog-info </em>的查询。查询类型的定义就像GraphQL中的任何其他类型一样。至此，我们已经定义了一个新的查询<em> blog-info </em>，客户端可以用它来检索数据。它将返回一个类型为<em> BlogPost </em>的数据数组。</p>
<p>类似地，我们也可以定义突变类型:</p>
<pre>type Mutation {
  add_blog_post: (title: String, author: String, numberOfLikes: int) : BlogPost
}</pre>
<p>这里的<em> add_blog_post </em>变异可以用来向<em> BlogPost </em>添加新条目。它接受<em>标题、作者、</em>和<em> numberOfLikes </em>作为参数。</p>
<p>类似地，您可以为GraphQL API定义几个查询和变化。</p>
<h2>不可为空的字段</h2>
<p>GraphQL类型的酷之处在于，您可以定义类型并决定它们是否可以为空。我调整了我们最初的<em> BlogPost </em>类型，加入了一个不可空的字段。注意下面有一个感叹号(！)旁边的<em> ID </em>。这表明ID不能为空。</p>
<pre>type BlogPost {
  id: ID!
  title: String
  author: String
  numberOfLikes: Int
}</pre>
<p>默认情况下，每个标量类型都可以设置为null。通过添加感叹号，我们设置了一个规则，即字段不能为空。我喜欢这个特性，因为它在客户机和服务器之间定义了一个清晰的契约，消除了使用API时的任何混淆。</p>
<h2>组合列表和非空</h2>
<p>对于更复杂的模式定义，我们可以用多种方式组合列表和非空值。假设您有一个名为<code>[myList]</code>的列表类型。以下是将非空值与列表结合的方法。</p>
<ul>
<li>如果您想要一个不能包含任何空项的列表，那么您可以将您的列表声明为<code>[myList!]</code>。这意味着列表中的项目不能为空</li>
<li>或者，如果您将列表声明为<code>[myList!]</code>，并在方括号外加上非空的感叹号，则意味着其他内容。这表示不接受null，但允许列表为空</li>
<li>你也可以将你的列表声明为<code>[mylist!]!</code>。这是非null的一种更严格的形式。这意味着列表不能包含任何非空项，列表也不能为空</li>
</ul>
<p>在下面的例子中，注释列表中不能有任何空项:</p>
<pre>type BlogPost {
  id: ID
  title: String
  author: String
  numberOfLikes: Int
  comments: [String!]
}</pre>
<h2>结论</h2>
<p>我希望您喜欢学习GraphQL类型。如果你有兴趣进一步了解GraphQL，并对GraphQL有一个全面的了解，你可以在GraphQL上查看我的课程<a href="https://app.pluralsight.com/library/courses/graphql-big-picture/table-of-contents" target="_blank" rel="noopener noreferrer"> Pluralsight </a>。</p>
<p>其他资源:</p>

<p>如果您有任何意见，请在下面发表您的意见，并与您的团队和朋友分享这篇文章。</p><div class="code-block code-block-54">
<hr/>
<h3>更多来自LogRocket的精彩文章:</h3>

<hr/></div>
<p> </p><div class="code-block code-block-24">
<div class="blog-plug inline-plug graphql-plug"><h2>监控生产中失败和缓慢的GraphQL请求</h2><p>虽然GraphQL有一些调试请求和响应的特性，但确保GraphQL可靠地为您的生产应用程序提供资源是一件比较困难的事情。如果您对确保对后端或第三方服务的网络请求成功感兴趣，</p><a href="https://lp.logrocket.com/blg/graphql-signup" target="_blank">try LogRocket</a><p>.</p><a class="signup" href="https://lp.logrocket.com/blg/graphql-signup" target="_blank" rel="noopener noreferrer"><img src="../Images/432a3823c85b3fb72a206e6236a29f48.png" data-lazy-src="https://files.readme.io/69aa835-Image_2019-11-09_at_1.28.05_PM.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" class=" jetpack-lazy-image" data-original-src="https://files.readme.io/69aa835-Image_2019-11-09_at_1.28.05_PM.png"/><noscript><img data-lazy-fallback="1" src="../Images/432a3823c85b3fb72a206e6236a29f48.png" data-original-src="https://files.readme.io/69aa835-Image_2019-11-09_at_1.28.05_PM.png"/></noscript><img class="alignnone size-full wp-image-46 jetpack-lazy-image" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/><noscript><img data-lazy-fallback="1" class="alignnone size-full wp-image-46" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/></noscript></a><a href="https://lp.logrocket.com/blg/graphql-signup" target="_blank" rel="noopener noreferrer">https://logrocket.com/signup/</a><p>LogRocket 就像是网络和移动应用的DVR，记录下你网站上发生的每一件事。您可以汇总并报告有问题的GraphQL请求，以快速了解根本原因，而不是猜测问题发生的原因。此外，您可以跟踪Apollo客户机状态并检查GraphQL查询的键值对。</p><p>LogRocket检测您的应用程序以记录基线性能计时，如页面加载时间、到达第一个字节的时间、慢速网络请求，还记录Redux、NgRx和Vuex操作/状态。</p><a class="signup" href="https://lp.logrocket.com/blg/graphql-signup" target="_blank" rel="noopener noreferrer">Start monitoring for free</a><p>.</p></div>


</div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
<html>
<head>
<title>Node.js task runners vs. module bundlers - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>Node.js任务运行程序与模块打包程序- LogRocket博客</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/node-js-task-runners-vs-module-bundlers/#0001-01-01">https://blog.logrocket.com/node-js-task-runners-vs-module-bundlers/#0001-01-01</a></blockquote><div><article class="article-post">
<p><em>编者按:本帖于2021年12月2日更新，以包括对任务运行器和模块捆绑器的更强大的比较，因为后者自本帖于2019年首次发布以来，在使用和受欢迎程度上都有了显著提高。我们还更新了几个部分，以包括关于本帖中讨论的库和工具的最新版本的新信息。</em></p>
<p>这篇文章将涵盖以下主题:</p>

<h2 id="brief-history-node-js">Node.js简史</h2>
<p>JavaScript的工具生态系统令人难以置信。你很难找到任何其他语言有如此多的工具或如此多的不同用户参与这个工具。从它作为一门语言的卑微开始<a href="https://www.computer.org/csdl/mags/co/2012/02/mco2012020007.html" target="_blank" rel="noopener">最初在10天内设计</a>到它的<a href="http://blog.caustik.com/2012/08/19/node-js-w1m-concurrent-connections/" target="_blank" rel="noopener">C10K-在服务器领域实现立足点</a>，你不会找到另一种语言像这种语言一样具有可塑性。</p>
<p>流行的JavaScript服务器端实现Node.js于2009年首次推出。这个平台让前端开发人员几乎在一夜之间成为可行的后端开发人员，解除了前端团队的所有障碍。它的成功保证了一个可以轻松分发源代码的工具，在2010年，这个需求被npm满足了。</p>
<p>Node.js被誉为快速、易接近，并且最吸引人的是简单。它很快开始从PHP 等其他<a href="https://blog.logrocket.com/why-dont-people-like-php/" target="_blank" rel="noopener">平台吸引用户，PHP</a>是一种用来生成动态网站的语言。PHP可能随时都有成千上万的全局函数可用，并且需要一堆配置文件。</p>
<p>Node.js允许开发人员迁移到该平台，重新开始。由于太新，它还没有开发出其他语言的“包含电池”框架。Node.js的指导原则之一是保持核心简单。你找不到连接MySQL、生成UUID或计算Levenshtein距离的内置工具。</p>
<p>与此同时，JavaScript语言也在发生变化。由于用户的“多填充”,一些特性是向后兼容的，但是为了语言的进步，它必须偶尔添加新的语法。开发人员渴望新的语法，但旧的浏览器是现实，这导致了transpilers的发展。</p>
<p>由于代码是用web的通用语言JavaScript编写的，Node.js的简单性最终变得不那么重要了。Node.js作为将前端资产从一种表示(如ES7或SASS)转换为另一种表示(如ES5或CSS)的工具，获得了越来越多的关注。</p>
<p>不过，只有一个问题:JavaScript工程师通常希望继续编写JavaScript。这导致了任务运行器的开发，这是专门为运行其他工具而设计的Node.js工具。</p>
<h3>任务跑者的崛起</h3>
<p>众所周知，构建一个网站基本上需要三种技术，每种技术都由浏览器直接使用:</p>
<ul>
<li>HTML，它控制网页的结构</li>
<li>CSS，控制网页外观</li>
<li>JavaScript，用于网站交互性编程</li>
</ul>
<p>对于简单的网站或小团队来说，直接使用这些语言通常是一个不错的方法。然而，对于由工程师团队(每个人都有自己的专长)构建的复杂网站或在浏览器上运行的应用程序，直接使用这些基本语言可能会开始出现问题。</p>
<h2 id="what-are-benefits-using-task-runner">使用任务运行器有什么好处？</h2>
<p>例如，考虑当公司网站的品牌改变时。几个不同样式文件中使用的十六进制颜色代码可能需要更改。对于原始的CSS，这个操作需要跨几个团队的协调变化。使用SASS，这样的更改可以在一行代码中完成。</p>
<p>类似的概念也适用于HTML，我们使用模板工具如Mustache或虚拟DOM如React生成标记。它们也适用于JavaScript，工程师可以使用async/await ES2017语法编写代码，然后通过回调转换成复杂的ES5 switch语句。</p>
<p>此时，我们可能有一个网站需要将SASS编译成CSS，ES2015代码需要转换成ES5，React/JSX模板需要转换成原始JavaScript。其他操作也是有益的，例如缩小编译的代码和将PNG图像压缩成它们的最小表示。</p>
<p>在构建网站时，这些任务中的每一项都需要按照特定的顺序运行。根据特定网站构建的环境——例如它是为开发/调试目的或生产而构建的——一些任务必须被改变或完全跳过。这种复杂性激发了任务运行工具的产生。</p>
<p>两个受欢迎的Node.js任务运行者前来救援。第一个是<a href="https://www.npmjs.com/package/grunt" target="_blank" rel="noopener"> Grunt </a>，第一次提交是在2011年9月。这个工具采用一种强制性的方法来配置不同的任务，构建深度嵌套的对象并调用一些方法。</p>
<p>第二个是<a href="https://www.npmjs.com/package/gulp" target="_blank" rel="noopener"> Gulp </a>，在2013年7月有一个初始提交。这个工具采用了一种不同的方法，本质上更具功能性，将一个函数的输出通过管道传输到另一个函数的输入中，将结果流式传输。</p>
<h2 id="grunt-vs-gulp-task-runner-comparison">咕噜咕噜与狼吞虎咽:任务跑步者的比较</h2>
<p>让我们考虑一个简单的web应用程序，我们希望使用这些技术的子集来模拟它。这个应用程序依赖于多个SASS和JS文件。我们希望将SASS文件转换成CSS，并连接结果。</p>
<p>为了简洁起见，我们也将简单地将JS文件连接在一起，并假设<a href="http://www.adequatelygood.com/JavaScript-Module-Pattern-In-Depth.html" target="_blank" rel="noopener">模块模式</a>，而不是使用CommonJS <code>require</code>语句。让我们看看使用这些不同的任务运行器，这样的配置会是什么样子。</p>
<h3>Grunt配置文件</h3>
<p>这种方法要求安装以下模块:</p>
<ul>
<li><code>grunt</code></li>
<li><code>grunt-contrib-sass</code></li>
<li><code>grunt-contrib-concat</code></li>
<li><code>grunt-contrib-clean</code></li>
</ul>
<p>使用这种方法，我们可以运行<code>grunt style</code>、<code>grunt script</code>或<code>grunt build</code>来完成这两项工作。</p>
<pre class="language-javascript hljs">const grunt = require('grunt');

grunt.initConfig({
  sass: {
    dist: {
      files: [{
          expand: true,
          cwd: './src/styles',
          src: ['*.scss'],
          dest: './temp',
          ext: '.css'
      }]
    }
  },
  concat: {
    styles: {
      src: ['./temp/*.css'],
      dest: 'public/dist.css',
    },
    scripts: {
      src: ['./src/scripts/*.js'],
      dest: 'public/dist.js',
    }
  },
  clean: {
    temp: ['./temp/*.css']
  }
});

grunt.loadNpmTasks('grunt-contrib-sass');
grunt.loadNpmTasks('grunt-contrib-concat');
grunt.loadNpmTasks('grunt-contrib-clean');

grunt.registerTask('style', ['sass', 'concat:styles', 'clean:temp']);
grunt.registerTask('script', ['concat:scripts']);

grunt.registerTask('build', ['style', 'script']);
</pre>
<h3>Gulp配置文件</h3>
<p>前一示例的等效吞咽版本如下。这要求我们安装了<code>gulp</code>、<code>gulp-sass</code>、<code>gulp-concat</code>和<code>node-sass</code>。使用这种方法，我们可以运行<code>gulp style</code>、<code>gulp script</code>或<code>gulp build</code>来完成这两项工作。</p>
<pre class="language-javascript hljs">const gulp = require('gulp');
const sass = require('gulp-sass');
const concat = require('gulp-concat');
sass.compiler = require('node-sass');

gulp.task('style', function () {
  return gulp.src('./src/styles/*.scss')
    .pipe(sass().on('error', sass.logError))
    .pipe(concat('dist.css'))
    .pipe(gulp.dest('./public/'));
});

gulp.task('script', function () {
  return gulp.src('./src/scripts/*.js')
    .pipe(concat('dist.js'))
    .pipe(gulp.dest('./public/'));
});

gulp.task('build', gulp.series('style', 'script'));
</pre>
<p>正如您所看到的，Gulp示例比Grunt示例更简洁，因为配置Gulp文件比配置Grunt文件花费的时间相对更少。但是，Grunt文件可读性更好。所以，这取决于你想采取哪种方法。</p>
<p>从哲学上讲，这两个工具采用不同的方法来实现可运行的任务，但最终它们允许您做类似的事情。再说一次，Grunt是在Gulp之前引入的。他们在一生中都有着不相上下的受欢迎程度:</p>
<figure id="attachment_83416" aria-describedby="caption-attachment-83416" class="wp-caption aligncenter"><img data-attachment-id="83416" data-permalink="https://blog.logrocket.com/node-js-task-runners-vs-module-bundlers/google-trends-grunt-vs-gulp-2021/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2019/02/google-trends-grunt-vs-gulp-2021.png" data-orig-size="730,252" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="google-trends-grunt-vs-gulp-2021" data-image-description="" data-image-caption="&lt;p&gt;Google Trends graph showing Grunt vs. Gulp in 2021&lt;/p&gt;&#10;" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2019/02/google-trends-grunt-vs-gulp-2021-300x104.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2019/02/google-trends-grunt-vs-gulp-2021.png" decoding="async" class="size-full wp-image-83416 jetpack-lazy-image" src="../Images/58112319d8c3b808f412280348c824b3.png" alt="Google Trends graph showing Grunt vs. Gulp in 2021" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2019/02/google-trends-grunt-vs-gulp-2021.png 730w, https://blog.logrocket.com/wp-content/uploads/2019/02/google-trends-grunt-vs-gulp-2021-300x104.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2019/02/google-trends-grunt-vs-gulp-2021.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/02/google-trends-grunt-vs-gulp-2021.png"/><noscript><img data-lazy-fallback="1" data-attachment-id="83416" data-permalink="https://blog.logrocket.com/node-js-task-runners-vs-module-bundlers/google-trends-grunt-vs-gulp-2021/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2019/02/google-trends-grunt-vs-gulp-2021.png" data-orig-size="730,252" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="google-trends-grunt-vs-gulp-2021" data-image-description="" data-image-caption="&lt;p&gt;Google Trends graph showing Grunt vs. Gulp in 2021&lt;/p&gt;&#10;" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2019/02/google-trends-grunt-vs-gulp-2021-300x104.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2019/02/google-trends-grunt-vs-gulp-2021.png" decoding="async" loading="lazy" class="size-full wp-image-83416" src="../Images/58112319d8c3b808f412280348c824b3.png" alt="Google Trends graph showing Grunt vs. Gulp in 2021" srcset="https://blog.logrocket.com/wp-content/uploads/2019/02/google-trends-grunt-vs-gulp-2021.png 730w, https://blog.logrocket.com/wp-content/uploads/2019/02/google-trends-grunt-vs-gulp-2021-300x104.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/02/google-trends-grunt-vs-gulp-2021.png"/></noscript><figcaption id="caption-attachment-83416" class="wp-caption-text">Google Trends graph showing Grunt vs. Gulp in 2021</figcaption></figure>
<p>这两个项目都是高度模块化的，允许开发人员创建专门的插件。这些插件允许外部工具，如<code>eslint</code>、<code>sass</code>或<code>browserify</code>轻松集成到任务运行器中。<br/>在我们之前看过的代码中，我们实际上有一个这样的例子:流行的SASS工具既有一个<code>grunt-contrib-sass</code>模块，又有一个<code>gulp-sass</code>模块。</p>
<p>这两个工具可能基本上已经“完成”了。在撰写本文时，Grunt的最后一次发布是在2021年5月，Gulp的最后一次发布是在2019年。</p>
<p>“done”是什么意思，这个词在JavaScript社区中从字面上和比喻上都是四个字母的单词？那么，在这种情况下，这可能意味着核心任务运行模块做他们需要做的一切，任何额外的功能都可以通过插件添加。</p>
<h2>任务执行者与捆绑者</h2>
<p>在2021年的前端开发生态系统中，任务运行器越来越不受欢迎，而<a href="https://blog.logrocket.com/benchmarking-bundlers-2020-rollup-parcel-webpack/" target="_blank" rel="noopener">模块捆绑器正在取代它们的位置</a>。</p>
<p>模块捆绑器是前端开发人员将所有JavaScript模块捆绑到一个可以在浏览器中执行的JavaScript文件中的工具。模块捆扎机中最大的名称是网络包、汇总和包裹。我们将在下面逐一讨论。</p>
<p>web.dev博客已经创建了一个名为<a href="https://bundlers.tooling.report/" target="_blank" rel="noopener">工具的网站。报告</a>，其中他们比较了现有的最佳捆扎机，目前他们只比较了四个模块捆扎机:webpack、Browserify、Parcel和Rollup。根据他们的结果，在2021年11月，Parcel通过了最多的测试(93%)。Webpack以90分的及格分数位居第二。</p>
<h3>网络包</h3>
<p>Webpack 是一个较新的工具，也可以用来获取源文件，以各种方式组合它们，并将它们输出到单个文件中。Webpack可以使用一个名为<code>webpack.config.js</code>的文件以类似于Grunt和Gulp的方式进行配置。</p>
<p>它也是高度模块化的，我们可以使用像<code>sass-loader</code>这样的插件来实现类似的结果。它与Grunt和Gulp有自己的哲学差异，但是，在基于节点的流程最终转换资产并通过JavaScript文件进行配置的意义上，它仍然是相似的。</p>
<p>然而，它与Grunt和Gulp有很大的不同，直接将它与Grunt和Gulp进行比较是不公平的。它主要是一个转换JavaScript的工具，基于<code>require</code>语句和依赖关系的层次结构——它本质上不是一个任务运行器。这是一个模块捆扎机。</p>
<p>webpack的第一次提交发生在2012年3月，在Grunt和Gulp的第一次提交之间，它仍在积极开发中，因为它在世界各地被大量使用。它是最受欢迎的模块捆绑软件，每周下载量超过1500万次。</p>
<p>Grunt和Gulp帮助执行许多类型的通用任务，而webpack对构建前端资产更感兴趣。但是，它不仅仅限于此，webpack在Node.js开发中也很有用。</p>
<h3>到达</h3>
<p>Rollup是另一个JavaScript模块捆绑器，它将小段代码编译成更广泛、更复杂的代码。Rollup的配置和webpack差不多，熟悉webpack的人会发现Rollup的配置也差不多，设置起来也很方便。</p>
<p>开发人员通常喜欢Rollup，因为它们的API和设计更简单，使得编写插件更容易。汇总文档也很出色。</p>
<h3>包裹</h3>
<p>Parcel 因其零配置方法而广受欢迎。它也是非常轻量级的，向项目添加Parcel非常简单。</p>
<p>包不使用任何配置文件；通过CLI传递入口文件就足以开始使用它了。它自己完成剩下的工作。虽然现在，webpack 4也有一个零配置方法，但与package提供的功能相比，它仅限于这些功能。</p>
<p>当构建一个小型到中型的应用程序时，包是一个很好的选择。</p>
<h3>浏览</h3>
<p><a href="https://browserify.org/" target="_blank" rel="noopener"> Browserify </a>一直是webpack势均力敌的竞争对手，但近年来，webpack的增长速度比Browserify快了很多。</p>
<p>Browserify不是模块捆绑器。相反，它为浏览器带来了Node.js的强大功能。这个包允许你在浏览器中为你的前端包使用许多Node.js包。</p>
<h2 id="task-runner-alternatives">任务运行程序备选方案</h2>
<p>对于最复杂的构建系统，使用Node.js任务运行器是完全有意义的。有一个临界点，用编写应用程序之外的语言来维护构建过程是没有意义的，因为它变得如此复杂。</p>
<p>然而，对于许多项目来说，这些任务运行者最终是多余的。它们是一个<em>附加的</em>工具，我们需要将其添加到项目中并保持更新。当任务运行者很容易通过<code>npm install</code>获得时，他们的复杂性很容易被忽略。</p>
<p>在前面的例子中，我们需要32MB的磁盘空间来使用Grunt，需要40MB的空间来使用Gulp。这些简单的构建命令——连接两个JavaScript文件并编译/连接两个SASS文件——使用Grunt需要250毫秒，使用Gulp需要370毫秒。</p>
<h3>使用Bash脚本作为任务运行器的替代方案</h3>
<p>Gulp的方法是从一个操作中获取输出，然后通过管道将它们传送到另一个操作中，这听起来应该很熟悉。同样的管道系统也可以通过命令行使用，我们可以通过使用Bash脚本来实现自动化。macOS和Linux电脑的用户已经可以使用这样的脚本特性了(<a href="https://docs.microsoft.com/en-us/windows/wsl/install-win10" target="_blank" rel="noopener"> WSL </a>可以帮助Windows)。</p>
<p>我们可以使用以下三个Bash脚本来实现Grunt和Gulp示例所做的事情:</p>
<pre class="language-bash hljs">### style.sh
#!/usr/bin/env bash
cat ./src/styles/*.scss | sass &gt; ./public/dist.css

### script.sh
#!/usr/bin/env bash
cat ./src/scripts/*.js &gt; ./public/dist.js

### build.sh
#!/usr/bin/env bash
./style.sh
./script.sh
</pre>
<p>当我们使用这种方法时，我们只需要一个2.5MB的二进制文件(可执行文件)。执行整个构建操作所需的时间也减少了:在我的机器上，这个操作只需要25毫秒。这意味着我们使用了大约1/12的磁盘空间，运行速度提高了10倍。对于更复杂的构建步骤，差异可能会更大。</p>
<p>这种方法甚至可以内联到您的<code>package.json</code>文件中。然后，可以通过<code>npm run style</code>、<code>npm run script</code>和<code>npm run build</code>执行命令。</p>
<pre class="language-css hljs">{
  "scripts": {
    "style": "cat ./src/styles/*.scss | sass &gt; ./public/dist.css",
    "script": "cat ./src/scripts/*.js &gt; ./public/dist.js",
    "build": "npm run style &amp;&amp; npm run script"
  }
}
</pre>
<p>当然，这是一种权衡。最大的区别是<a href="https://blog.logrocket.com/writing-js-based-bash-scripts-zx/" target="_blank" rel="noopener"> Bash是一种shell脚本语言，语法完全不同于JavaScript </a>。对于一些从事JavaScript项目的工程师来说，编写构建复杂应用程序所需的适当脚本可能很困难。</p>
<p>另一个缺点是，Bash脚本要求我们想要合并的每个操作都有某种可执行文件。幸运的是，他们通常都是。</p>
<p>Browserify 和<a href="https://github.com/babel/babel" target="_blank" rel="noopener"> Babel </a>，这两个软件都提供了一个可执行文件。萨斯、莱斯、Coffeescript和JSX也都有可执行文件。如果没有，我们可以自己写；然而，一旦我们达到这一点，我们可能会考虑只使用任务运行器。</p>
<h2>结论</h2>
<p>我们机器的命令行脚本功能非常强大。人们很容易忽略它们，尤其是当我们在JavaScript这样的高级语言上花了这么多时间的时候。</p>
<p>正如我们所看到的，它们通常足够强大，可以完成我们的许多前端资产构建任务，并且通常可以更快地完成。当您开始下一个项目时，考虑使用这些工具，并且只有当您达到Bash脚本的限制时，才切换到像task runner这样的更重的解决方案。</p><div class="code-block code-block-23">
<div class="blog-plug inline-plug node-plug"><h2>200只<img src="../Images/61167b9d027ca73ed5aaf59a9ec31267.png" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2019/10/green-check.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" class=" jetpack-lazy-image" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/10/green-check.png"/> <noscript> <img data-lazy-fallback="1" src="../Images/61167b9d027ca73ed5aaf59a9ec31267.png" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/10/green-check.png"/> </noscript>显示器出现故障，生产中网络请求缓慢</h2><p>部署基于节点的web应用程序或网站是容易的部分。确保您的节点实例继续为您的应用程序提供资源是事情变得更加困难的地方。如果您对确保对后端或第三方服务的请求成功感兴趣，</p><a href="https://lp.logrocket.com/blg/node-signup" target="_blank">try LogRocket</a><p>. </p><a class="signup" href="https://lp.logrocket.com/blg/node-signup" target="_blank" rel="noopener noreferrer"><img src="../Images/cae72fd2a54c5f02a6398c4867894844.png" alt="LogRocket Network Request Monitoring" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2019/12/network-request-filter-2-1.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" class=" jetpack-lazy-image" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/12/network-request-filter-2-1.png"/><noscript><img data-lazy-fallback="1" src="../Images/cae72fd2a54c5f02a6398c4867894844.png" alt="LogRocket Network Request Monitoring" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/12/network-request-filter-2-1.png"/></noscript></a><a href="https://lp.logrocket.com/blg/node-signup" target="_blank" rel="noopener noreferrer">https://logrocket.com/signup/</a><p>LogRocket 就像是网络和移动应用程序的DVR，记录下用户与你的应用程序交互时发生的一切。您可以汇总并报告有问题的网络请求，以快速了解根本原因，而不是猜测问题发生的原因。</p><p>LogRocket检测您的应用程序以记录基线性能计时，如页面加载时间、到达第一个字节的时间、慢速网络请求，还记录Redux、NgRx和Vuex操作/状态。</p><a class="signup" href="https://lp.logrocket.com/blg/node-signup" target="_blank" rel="noopener noreferrer">Start monitoring for free</a><p>. </p></div>
</div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
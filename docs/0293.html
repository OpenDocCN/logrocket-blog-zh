<html>
<head>
<title>Getting started with Enzyme for React - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>React - LogRocket博客的酶入门</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/getting-started-with-enzyme-for-react-a106b58fc53b/#0001-01-01">https://blog.logrocket.com/getting-started-with-enzyme-for-react-a106b58fc53b/#0001-01-01</a></blockquote><div><article class="article-post">
<p>测试是web应用程序开发中的一个重要步骤，尤其是对于基于React这样的组件库开发的应用程序。在众多不同的测试工具和库当中，<a class="markup--anchor markup--p-anchor" href="http://airbnb.io/enzyme/" target="_blank" rel="noopener noreferrer" data-href="http://airbnb.io/enzyme/"> Enzyme </a>因其灵活性和易于为React代码开发测试而脱颖而出。</p>
<p>实际上，Enzyme更像是一个JavaScript测试工具，可以更容易地断言、操作和遍历React组件的输出。它由Airbnb创建，添加了许多实用功能，以方便组件渲染，以类似于jQuery的方式查找元素并与之交互。</p>
<p>在本教程中，我们将探索该工具提供的不同渲染选项，以及一些实际的例子。</p>
<p><a href="https://logrocket.com/signup/"> <img decoding="async" class="progressiveMedia-image js-progressiveMedia-image jetpack-lazy-image" src="../Images/386849f1f7f5e9c679ded10375d9134d.png" data-src="https://cdn-images-1.medium.com/max/2160/1*wV7zU6J05BL3bphzMlB2rA.png" data-lazy-src="https://cdn-images-1.medium.com/max/2160/1*wV7zU6J05BL3bphzMlB2rA.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://cdn-images-1.medium.com/max/2160/1*wV7zU6J05BL3bphzMlB2rA.png"/> <noscript> <img data-lazy-fallback="1" decoding="async" class="progressiveMedia-image js-progressiveMedia-image" src="../Images/386849f1f7f5e9c679ded10375d9134d.png" data-src="https://cdn-images-1.medium.com/max/2160/1*wV7zU6J05BL3bphzMlB2rA.png" data-original-src="https://cdn-images-1.medium.com/max/2160/1*wV7zU6J05BL3bphzMlB2rA.png"/> </noscript></a></p>
<h3>设置和安装</h3>
<p>首先确保你的本地开发机器上有<a class="markup--anchor markup--p-anchor" href="https://nodejs.org/en/" target="_blank" rel="noopener noreferrer" data-href="https://nodejs.org/en/">节点</a> ≥ v8.10.0。如果你不确定你是否在使用最新版本，参考<a class="markup--anchor markup--p-anchor" href="https://github.com/nvm-sh/nvm#installation" target="_blank" rel="noopener noreferrer" data-href="https://github.com/nvm-sh/nvm#installation"> nvm文档</a>来确认。</p>
<p>对于这个项目，我们将使用<a class="markup--anchor markup--p-anchor" href="https://facebook.github.io/create-react-app/" target="_blank" rel="noopener noreferrer" data-href="https://facebook.github.io/create-react-app/"> create-react-app </a>来设置一个react应用程序，并让它立即运行。有了它，我们不需要安装或配置Webpack或Babel之类的工具；它们是预先配置和隐藏的，因此我们可以专注于代码。</p>
<p>它使用了<a class="markup--anchor markup--p-anchor" href="https://www.npmjs.com/package/npx" target="_blank" rel="noopener noreferrer" data-href="https://www.npmjs.com/package/npx"> npx </a>，这是一个npm包运行程序，附带了NPM v 5.2，所以整个事情非常简单。你可以在这里阅读npx上的<a class="markup--anchor markup--p-anchor" href="https://medium.com/@maybekatz/introducing-npx-an-npm-package-runner-55f7d4bd282b" target="_blank" rel="noopener noreferrer" data-href="https://medium.com/@maybekatz/introducing-npx-an-npm-package-runner-55f7d4bd282b"/>。🙂</p>
<p>因此，为了创建我们的应用程序，在提示符下运行以下命令:</p>
<pre>cd your-project-directory
npx create-react-app logrocket-react-enzyme-app</pre>
<p>这将创建并初始化带有一系列预置节点模块的项目，这些模块对于React开发非常重要:</p>
<p><img decoding="async" class="progressiveMedia-image js-progressiveMedia-image jetpack-lazy-image" src="../Images/4b65192025a098a28bed325c8ef87964.png" data-src="https://cdn-images-1.medium.com/max/1440/0*vl5wrB5vcEagPWo9" data-lazy-src="https://cdn-images-1.medium.com/max/1440/0*vl5wrB5vcEagPWo9?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://cdn-images-1.medium.com/max/1440/0*vl5wrB5vcEagPWo9"/></p><noscript><img data-lazy-fallback="1" decoding="async" class="progressiveMedia-image js-progressiveMedia-image" src="../Images/4b65192025a098a28bed325c8ef87964.png" data-src="https://cdn-images-1.medium.com/max/1440/0*vl5wrB5vcEagPWo9" data-original-src="https://cdn-images-1.medium.com/max/1440/0*vl5wrB5vcEagPWo9"/></noscript>
<figure id="8b91" class="graf graf--figure graf-after--p"><figcaption class="imageCaption"><em class="markup--em markup--figure-em">Facebook create-react-app output.</em></figcaption></figure>
<p id="eebf" class="graf graf--p graf-after--figure">这是生成的文件和目录结构:</p>
<pre>logrocket-react-enzyme-app
├── README.md
├── node_modules
├── package.json
├── .gitignore
├── public
│   ├── favicon.ico
│   ├── index.html
│   └── manifest.json
└── src
    ├── App.css
    ├── App.js
    ├── App.test.js
    ├── index.css
    ├── index.js 
    ├── logo.svg
    └── serviceWorker.js</pre>
<p>花点时间打开<code>package.json</code>文件，分析预装的节点依赖，包括React、React DOM、脚本；预设的启动脚本；建筑测试；以此类推:</p>
<pre>{
  "name": "logrocket-react-enzyme-app",
  "version": "0.1.0",
  "private": true,
  "dependencies": {
    "react": "^16.8.6",
    "react-dom": "^16.8.6",
    "react-scripts": "3.0.0"
  },
  "scripts": {
    "start": "react-scripts start",
    "build": "react-scripts build",
    "test": "react-scripts test",
    "eject": "react-scripts eject"
  },
  "eslintConfig": {
    "extends": "react-app"
  },
  "browserslist": {
    "production": [
      "&gt;0.2%",
      "not dead",
      "not op_mini all"
    ],
    "development": [
      "last 1 chrome version",
      "last 1 firefox version",
      "last 1 safari version"
    ]
  }
}
</pre>
<p>要检查正在运行的应用程序，只需在应用程序根文件夹中键入<code>npm start</code>命令，索引页面将在<code><a href="http://localhost:3000/" rel="nofollow">http://localhost:3000/</a></code>时在浏览器中打开，就像这样:</p>
<p><img decoding="async" class="progressiveMedia-image js-progressiveMedia-image jetpack-lazy-image" src="../Images/ddca43615e3852b2b3f4ba19854bcaeb.png" data-src="https://cdn-images-1.medium.com/max/1440/0*5ApTvEuA8_9UELJF" data-lazy-src="https://cdn-images-1.medium.com/max/1440/0*5ApTvEuA8_9UELJF?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://cdn-images-1.medium.com/max/1440/0*5ApTvEuA8_9UELJF"/></p><noscript><img data-lazy-fallback="1" decoding="async" class="progressiveMedia-image js-progressiveMedia-image" src="../Images/ddca43615e3852b2b3f4ba19854bcaeb.png" data-src="https://cdn-images-1.medium.com/max/1440/0*5ApTvEuA8_9UELJF" data-original-src="https://cdn-images-1.medium.com/max/1440/0*5ApTvEuA8_9UELJF"/></noscript>
<figure id="4d34" class="graf graf--figure graf-after--p"><figcaption class="imageCaption"><em class="markup--em markup--figure-em">Index React App page</em></figcaption></figure>
<p>现在，让我们继续酶的设置。一旦我们使用React 16(撰写本文时的最新版本)进行项目开发，可以发出以下命令来正确安装Enzyme:</p>
<pre>npm i — save-dev enzyme enzyme-adapter-react-16</pre>
<p>之后，您会注意到我们的<code>package.json</code>文件被更新了:</p>
<pre>"devDependencies": {
   "enzyme": "^3.9.0",
   "enzyme-adapter-react-16": "^1.12.1"
}</pre>
<p>如果你使用的是React的不同版本，不用担心——你可以按照<a class="markup--anchor markup--p-anchor" href="https://airbnb.io/enzyme/docs/installation/" target="_blank" rel="noopener noreferrer" data-href="https://airbnb.io/enzyme/docs/installation/">官方酶安装文档</a>来指导如何为你的项目安装正确的版本。</p>
<p>注意:如果您使用的是Linux，并且您得到了错误<code>Error: ENOSPC: System limit for number of file watchers reached</code>，这意味着您的系统达到了文件观察者的限制。要修复它，只需运行以下命令:</p>
<pre>echo fs.inotify.max_user_watches=524288 | sudo tee -a /etc/sysctl.conf &amp;&amp; sudo sysctl -p</pre>
<h3>创建我们的第一个测试</h3>
<p>为了使用Enzyme的功能，我们需要告诉我们的React应用程序它已经安装并且可用。但是，请记住，我们需要参考我们之前安装的适配器包，并正确设置适配器以供Enzyme使用。因此，转到<code>src</code>文件夹，创建一个名为<code>enzyme.js</code>的新文件:</p>
<pre>import Enzyme, { configure, shallow, mount, render } from 'enzyme';
import Adapter from 'enzyme-adapter-react-16';

configure({ adapter: new Adapter() });
export { shallow, mount, render };
export default Enzyme;
</pre>
<p>这将足以导出所有不同的酶渲染类型。然后，在<code>src/components</code>目录中创建另一个文件夹<code>tests</code>来保存我们的测试文件。</p>
<p>让我们考虑一个简单的例子:一个HTML有序列表。它将由两部分组成:</p>
<ul>
<li><code>OrderedList</code>:这将存储构建一个<code>OrderedListOption</code>元素的<code>&lt;ol&gt;</code>的函数，为不同的显示配置检查列表是否为空</li>
<li><code>OrderedListOption</code>:它独立地处理每个<code>&lt;li&gt;</code>项、CSS类及其值</li>
</ul>
<p>例如，考虑到它的列表性质，这个组件可以很容易地适应于一个<code>&lt;select&gt;</code>。让我们来看看源代码:</p>
<pre>import React from 'react';
import PropTypes from 'prop-types';

import OrderedListOption from './OrderedListOption';

function OrderedList(props) {
  const { options } = props;
  if (!options.length) {
    return &lt;span className="empty"&gt;No options added.&lt;/span&gt;;
  }

  return (
    &lt;ol className="options"&gt;
      {options.map(option =&gt; &lt;OrderedListOption key={option} value={option} /&gt;)}
    &lt;/ol&gt;
  );
}

OrderedList.propTypes = {
  options: PropTypes.array,
};

OrderedList.defaultProps = {
  options: [],
};

export default OrderedList;
</pre>
<p>代码非常简单:我们在文件顶部导入<code>React</code>和<code>OrderedListOption</code>组件，同时检查条目的数组是否为空，以显示正确的HTML内容。如果数组不为空，我们将遍历它来组成列表选项。</p>
<p>看一看<code>OrderedListOption</code>代码:</p>
<pre>import React from 'react';
import PropTypes from 'prop-types';

function OrderedListOption(props) {
  const { value } = props;
  return &lt;li className="value"&gt;{value}&lt;/li&gt;;
}

OrderedListOption.propTypes = {
  value: PropTypes.string,
};

export default OrderedListOption;
</pre>
<p>它只是接收元素的值，并将其放入<code>&lt;li&gt;</code>元素中。很简单，不是吗？</p>
<p>在我们创建测试之前，声明酶支持的三种不同渲染类型是很重要的。</p>
<h4><code>shallow</code></h4>
<p>这基本上每次呈现一个组件。换句话说，Enzyme不会考虑测试的子元素。考虑这样的情况，您希望将组件本身与其周围或内部的其他组件隔离开来进行测试。当您喜欢单元测试而不是完全集成的测试时，这种呈现类型很有用。</p>
<h4><code>mount</code></h4>
<p>这与<code>shallow</code>相反，使用完整的DOM渲染，包括所有的子元素。它非常适合每个组件与其他组件(DOM API)紧密交互的情况。</p>
<h4><code>render</code></h4>
<p>它呈现为静态HTML。这包括所有的子元素。同时，它阻止了对React生命周期方法的访问，这反过来为测试提供了更少的灵活性和功能性——此外，它的速度要快得多。它构建在<a class="markup--anchor markup--p-anchor" href="https://github.com/cheeriojs/cheerio" target="_blank" rel="noopener noreferrer" data-href="https://github.com/cheeriojs/cheerio"> Cheerio </a>之上，后者是一个基于服务器jQuery核心的DOM操作和遍历API。因此，您将拥有jQuery的所有功能。</p>
<p>现在让我们做一些测试。在我们的<code>/tests</code>文件夹中创建一个名为<code>OrderedList.test.js</code>的新文件，并添加以下代码:</p>
<pre>import React from 'react';
import { shallow, mount, render } from '../../enzyme';

import OrderedList from '../OrderedList';

describe('Our test suite', () =&gt; {

    it('renders all the mocked animal options', () =&gt; {
        const animals = ['duck', 'bear', 'whale'];

        const wrapper = render(&lt;OrderedList options={animals} /&gt;);

        expect(wrapper.find('.options')).toBeDefined();
        expect(wrapper.find('.value')).toHaveLength(animals.length);
    });

    it('renders no animal options', () =&gt; {
        const animals = [];
        const wrapper = shallow(&lt;OrderedList options={animals} /&gt;);

        expect(wrapper.find('.empty').exists()).toBe(true);
    });

    it('renders a single animal option', () =&gt; {
        const animals = ['duck'];
        const wrapper = mount(&lt;OrderedList options={animals} /&gt;);

        expect(wrapper.contains(&lt;li key='duck' className="value"&gt;duck&lt;/li &gt;)).toBeTruthy();
    });

    it('renders correct text in animal option', () =&gt; {
        const animals = ['duck', 'bear', 'whale'];
        const wrapper = mount(&lt;OrderedList options={animals} /&gt;);

        expect(wrapper.find('.value').get(0).props.children).toEqual('duck');
    });
});
</pre>
<p>首先，我们从之前创建的<code>enzyme.js</code>文件开始导入三种渲染类型。这里，我们为每种类型的渲染设想了四个测试场景。</p>
<p>第一种为<code>render</code>型；我们基本上是要求Enzyme用给定的动物参数数组渲染一个<code>OrderedList</code>，并通过<code>expect()</code>函数断言测试条件。</p>
<p><code>wrapper</code>对象代表<code>render()</code>结果，在其中，我们可以调用<code>find</code>CSS类<code>options</code>(我们的项目的孩子)和<code>value</code>，关于每个内部列表元素的类。我们还测试了子元素的数量。</p>
<p>第二个测试集中在一个不接收任何元素的列表上。这里，我们使用的是<code>shallow</code>渲染类型，这使得像<code>exists()</code>这样的方法对我们可用。</p>
<p>最后两个测试利用了<code>mount()</code>函数，该函数将完整的DOM返回给<code>wrapper</code>对象。方法<code>contains()</code>是React生命周期方法的另一个例子。</p>
<h3>测试表单组件</h3>
<p>您甚至可以进一步测试表单、表单元素、事件等等。让我们来看第二个例子，一个登录表单组件(<code>Login.js</code>):</p>
<pre>import React from 'react';

class Login extends React.Component {
    constructor() {
        super()
        this.state = {
            username: '',
            password: ''
        }
    }

    handleInputChange = (event) =&gt; {
        this.setState({
            [event.target.name]: event.target.value
        })
    }
    
    render() {
        return (
            &lt;form className='login'&gt;
                &lt;label&gt;Username&lt;/label&gt;
                &lt;input id='email' onBlur={this.handleInputChange} name='email' type='text' /&gt;
                &lt;label&gt;Password&lt;/label&gt;
                &lt;input id='password' onBlur={this.handleInputChange} name='password' type='password' /&gt;
                &lt;button&gt;Submit&lt;/button&gt;
            &lt;/form&gt;
        )
    }
}
export default Login
</pre>
<p>这是一个常见的表单结构组件，只是我们在这里保存的状态必须在每次输入中发生模糊事件时更新。</p>
<p>我们来看看<code>Login.test.js</code>文件:</p>
<pre>import React from 'react';
import { shallow, mount, render } from '../../enzyme';
import Login from '../Login'

describe('Login Test Suite', () =&gt; {

    it('should render the form', () =&gt; {
        const wrapper = shallow(&lt;Login /&gt;);

        expect(wrapper.find('form.login').exists()).toBe(true);
        expect(wrapper.find('#email').length).toEqual(1);
        expect(wrapper.find('#password').length).toEqual(1);
    })
})

describe('Email Test Suite', () =&gt; {

    it('should change the state of the Login component', () =&gt; {

        const wrapper = shallow(&lt;Login /&gt;);
        wrapper.find('#email').simulate('blur',
            {
                target: { name: 'email', value: '<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="86eae9e1f4e9e5ede3f2c6ebe7efeaa8e5e9eb">[email protected]</a>' }
            });

        expect(wrapper.state('email')).toEqual('<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="c9a5a6aebba6aaa2acbd89a4a8a0a5e7aaa6a4">[email protected]</a>');
    })
})

describe('Password Test Suite', () =&gt; {

    it('should change the state of the Login component', () =&gt; {

        const wrapper = mount(&lt;Login /&gt;);
        wrapper.find('#password').simulate('blur',
            {
                target: { name: 'password', value: 'my log is rocket' }
            });

        expect(wrapper.state('password')).toEqual('my log is rocket');
    })
})
</pre>
<p>第一个测试套件并不新鲜；我们只是检查表单元素是否存在。第二个和第三个测试利用了<code>simulate()</code>函数，顾名思义，模拟现场的事件——在本例中是<code>onBlur</code>。</p>
<p>一旦我们设置了<code>onBlur</code>将触发每个输入字段的状态更新，我们就可以检查是否存储了相同的状态。这是一个很好的行为测试的例子，其中我们测试在酶强制模拟组件中的事件后会发生什么。</p>
<p>这将是您的IDE中的最终输出(这里是Visual Studio代码):</p>
<figure id="7de6" class="graf graf--figure graf-after--p">
<figcaption class="imageCaption"><em class="markup--em markup--figure-em">Test results in the terminal</em></figcaption></figure>
<h3>结论</h3>
<p>你可以从我的<a class="markup--anchor markup--p-anchor" href="https://github.com/diogosouza/react-enzyme-app" target="_blank" rel="noopener noreferrer" data-href="https://github.com/diogosouza/react-enzyme-app"> GitHub repo </a>获得完整的源代码。如果你喜欢它，请留下一个星级。</p>
<p>在酶提供的许多方法和例子中，我们在这里只介绍了几个。这是一个动态和丰富的环境，您可以创建您的测试套件并探索许多不同的测试场景，例如集成、单一、行为、语义等。</p>
<p>参考<a class="markup--anchor markup--p-anchor" href="https://airbnb.io/enzyme/docs/api/" target="_blank" rel="noopener noreferrer" data-href="https://airbnb.io/enzyme/docs/api/">官方文档页面</a>了解更多关于酶及其功能、附加配置等的信息。以一个经过良好测试的应用程序为目标，让它更值得信赖。</p>
<p>你用酶反应过吗？请告诉我们一点您的体验…</p><div class="code-block code-block-17">
<div class="blog-plug inline-plug react-plug" vwo-el-id="26283398190">
<h2 vwo-el-id="41600691720"><a href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener"> LogRocket </a>:全面了解您的生产React应用</h2><p>调试React应用程序可能很困难，尤其是当用户遇到难以重现的问题时。如果您对监视和跟踪Redux状态、自动显示JavaScript错误以及跟踪缓慢的网络请求和组件加载时间感兴趣，</p><a href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" vwo-el-id="19356441070">try LogRocket</a><p>. </p><a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="19356441380">
<img class="first-react-image alignnone size-full wp-image-46 jetpack-lazy-image jetpack-lazy-image--handled" src="../Images/f300c244a1a1cf916df8b4cb02bec6c6.png" vwo-el-id="18272717540" data-lazy-loaded="1" data-original-src="https://files.readme.io/27c94e7-Image_2017-06-05_at_9.46.04_PM.png"/>
</a>
<a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="19356441690">
<img class="second-react-image alignnone size-full wp-image-46 jetpack-lazy-image jetpack-lazy-image--handled" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" vwo-el-id="30720362350" data-lazy-loaded="1" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/>
</a>
<p vwo-el-id="28675660440" class="">LogRocket 结合了会话回放、产品分析和错误跟踪，使软件团队能够创建理想的web和移动产品体验。这对你来说意味着什么？</p>
<p>LogRocket不是猜测错误发生的原因，也不是要求用户提供截图和日志转储，而是让您回放问题，就像它们发生在您自己的浏览器中一样，以快速了解哪里出错了。</p>
<p>不再有嘈杂的警报。智能错误跟踪允许您对问题进行分类和归类，然后从中学习。获得有影响的用户问题的通知，而不是误报。警报越少，信号就越有用。</p>
<p vwo-el-id="28675660750">LogRocket Redux中间件包为您的用户会话增加了一层额外的可见性。LogRocket记录Redux存储中的所有操作和状态。</p>
<p vwo-el-id="28675661060">现代化您调试React应用的方式— <a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="40093418840">开始免费监控</a>。</p>
</div></div>
<hr/>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
<html>
<head>
<title>Laravel 5.8 release: 10 new features to try - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>Laravel 5.8发布:10个新功能尝试</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/laravel-5-8-release-10-new-features-to-try-c06b1bc89eca/#0001-01-01">https://blog.logrocket.com/laravel-5-8-release-10-new-features-to-try-c06b1bc89eca/#0001-01-01</a></blockquote><div><article class="article-post">
<figure><img decoding="async" src="../Images/9be5e91077e6372ad7f4e838500206a6.png" data-height="401" data-width="1201" data-lazy-src="https://storage.googleapis.com/blog-images-backup/1*2gKr79YTmj2MkP8zLOn-bg.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" class=" jetpack-lazy-image" data-original-src="https://storage.googleapis.com/blog-images-backup/1*2gKr79YTmj2MkP8zLOn-bg.png"/><noscript><img data-lazy-fallback="1" decoding="async" src="../Images/9be5e91077e6372ad7f4e838500206a6.png" data-height="401" data-width="1201" data-original-src="https://storage.googleapis.com/blog-images-backup/1*2gKr79YTmj2MkP8zLOn-bg.png"/></noscript></figure>
<p>Laravel的最新版本<a href="https://laravel.com/docs/5.8" target="_blank" rel="noopener noreferrer">5.8版</a>，最近已经发布。这个版本有许多令人兴奋的新功能，它是Laravel以前版本的持续改进。这些功能包括:</p>
<ul>
<li>自动策略解析</li>
<li>碳2.0支持</li>
<li>通过雄辩的关系</li>
<li>令牌保护令牌散列</li>
<li>缓存TTL</li>
<li>调度程序时区配置</li>
<li><code>Artisan::call</code>改进</li>
<li>工匠服务改进</li>
<li>模拟测试助手方法</li>
<li>高阶<code>orWhere</code>雄辩法</li>
</ul>
<p>还有很多。在本文中，我将更深入地讨论这些新特性。</p>
<figure/>
<h3>1.自动策略解析</h3>
<p><a href="https://laravel.com/docs/5.8/authorization#creating-policies" target="_blank" rel="noopener noreferrer">策略</a>是Laravel处理用户授权的两种主要方式之一。它们是围绕特定模型或资源组织授权逻辑的类。在Laravel的早期版本中，策略需要在<code>AuthServiceProvider </code>中注册，如下所示:</p>
<figure>
<pre><code>
&lt;?php

namespace AppProviders;

use AppPost;
use AppPoliciesTransactionPolicy;
use IlluminateSupportFacadesGate;
use IlluminateFoundationSupportProvidersAuthServiceProvider as ServiceProvider;

class AuthServiceProvider extends ServiceProvider
{
    /**
     * The policy mappings for the application.
     *
     * @var array
     */
    protected $policies = [
        Transaction::class =&gt; TransactionPolicy::class,
    ];

    /**
     * Register any application authentication / authorization services.
     *
     * @return void
     */
    public function boot()
    {
        $this-&gt;registerPolicies();

        //
    }
}</code></pre>
</figure>
<p>在本例中，我们注册的策略是一个名为<code>TransactionPolicy</code>的策略，我们将它输入到<code>$policies</code>数组中。</p>
<p>然而，从Laravel 5.8开始，您不需要手动注册模型的授权策略。只要模型和策略遵循标准的Laravel命名约定，并且策略目录位于其默认位置，Laravel就可以自动发现策略。</p>
<p>如果您在不同于默认Laravel结构的位置拥有模型或策略，您可以使用<code>Gate::guessPolicyNamesUsing </code>方法注册一个定制回调。通常，应该从应用程序的<code>AuthServiceProvider </code>的引导方法中调用该方法，如下所示:</p>
<figure>
<pre><code>use IlluminateSupportFacadesGate;

Gate::guessPolicyNamesUsing(function ($modelClass) {
    // return policy class name...
});</code></pre>
</figure>
<h3>2.碳2.0支持</h3>
<p><a href="https://carbon.nesbot.com/" target="_blank" rel="noopener noreferrer"> Carbon </a>是一个包，它扩展了PHP自己的<a href="http://www.php.net/manual/en/class.datetime.php" target="_blank" rel="noopener noreferrer"> DateTime </a>类，使得处理日期和时间变得非常容易。Laravel 5.8为碳的<code>2.0 </code>释放提供了支持。碳纤维<code>2.0</code>的新特性之一是<code>CarbonImmutable </code>级和一个新的<code>Date</code>外观。让我们看看这是如何工作的。</p>
<p>在Laravel 5.8安装的<code>routesweb.php </code>文件中输入以下内容:</p>
<figure>
<pre><code>use CarbonCarbon;

Route::get('carbon', function () {
    $date = Carbon::now();
    dump($date);
    $date-&gt;addDays(3);
    dump($date);
});</code></pre>
</figure>
<p>这里我们创建一条路线<code>carbon </code>，它将当前日期保存在一个<code>$date</code>变量中，然后显示它。然后，它将当前日期加上三(3)天，并显示出来。如果您访问我们刚刚创建的<code>/carbon</code>路线，您会看到如下内容:</p>
<figure><img decoding="async" src="../Images/724d7295fc6a1c7b88bca1910285bac1.png" data-height="716" data-width="1908" data-lazy-src="https://storage.googleapis.com/blog-images-backup/1*ccaU-iu7JP7Bi4Rg4OzERA.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" class=" jetpack-lazy-image" data-original-src="https://storage.googleapis.com/blog-images-backup/1*ccaU-iu7JP7Bi4Rg4OzERA.png"/><noscript><img data-lazy-fallback="1" decoding="async" src="../Images/724d7295fc6a1c7b88bca1910285bac1.png" data-height="716" data-width="1908" data-original-src="https://storage.googleapis.com/blog-images-backup/1*ccaU-iu7JP7Bi4Rg4OzERA.png"/></noscript></figure>
<p>这里发生的是我们正在改变我们的对象。这可能是您想要的，但是在很多情况下，这不是我们想要的，因为日期通常是<code>protected</code>属性。我们实际上应该能够创建一个新的日期，而不修改现有的日期。例如，假设我们将出生日期存储在数据库的某一列中，这是不会改变的信息，但是，我们可以为它创建一个副本，并对该副本进行一些修改。这就是<code>CarbonImmutable</code>类的用武之地。要使用此功能，请转到您的<code>AppServiceProvider</code>并输入以下内容:</p>
<figure>
<pre><code>// ...other includes
use IlluminateSupportDateFactory;
use CarbonCarbonImmutable;

class AppServiceProvider extends ServiceProvider
{
  public function register()
    {
        DateFactory::use(CarbonImmutable::class);
    }
}</code></pre>
</figure>
<p>然后更新<code>routesweb.php</code>文件以使用新的<code>Date</code>外观，并创建一个我们可以更改的日期副本:</p>
<figure>
<pre><code>use IlluminateSupportFacadesDate;

Route::get('carbon', function () {
    $date = Date::now();
    dump($date);
    $newDate = $date-&gt;copy()-&gt;addDays(7);
    dump($newDate);
});</code></pre>
</figure>
<p>刷新您的浏览器，您应该会看到:</p>
<figure><img decoding="async" src="../Images/92fbc9458579e9a790c7ced97a520416.png" data-height="827" data-width="1911" data-lazy-src="https://storage.googleapis.com/blog-images-backup/1*lefUyoI2Q0vm_XTXX6MV9g.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" class=" jetpack-lazy-image" data-original-src="https://storage.googleapis.com/blog-images-backup/1*lefUyoI2Q0vm_XTXX6MV9g.png"/><noscript><img data-lazy-fallback="1" decoding="async" src="../Images/92fbc9458579e9a790c7ced97a520416.png" data-height="827" data-width="1911" data-original-src="https://storage.googleapis.com/blog-images-backup/1*lefUyoI2Q0vm_XTXX6MV9g.png"/></noscript></figure>
<h3>3.有一段雄辩的关系</h3>
<p>Laravel 5.8引入了一个新的雄辩关系:<code>HasOneThrough</code>。尽管这在Laravel中是新的，但它也存在于其他框架中，如Rails。假设我们有三个型号:一个<code>Supplier </code>型号一个<code>Account</code>型号和一个<code>AccountHistory</code>型号。一个供应商有一个帐户，一个帐户有一个帐户历史。</p>
<p>以前，要获得供应商的帐户历史，您必须找到供应商，然后编写类似于:<code>$supplier-&gt;account-&gt;accountHistory</code>的内容。现在，您可以使用<code>hasOneThrough</code>关系跳过这一步，直接访问供应商的账户历史，如下所示:<code>$history = $supplier-&gt;accountHistory </code>通过账户模型:</p>
<figure>
<pre><code>public function accountHistory()
{
    return $this-&gt;hasOneThrough(AccountHistory::class, Account::class);
}</code></pre>
</figure>
<h3>4.令牌保护令牌散列</h3>
<p>关于Laravel API认证的一个鲜为人知的事实是，您并不总是必须使用Laravel Passport。有一个更简单的令牌保护，它提供基本的API认证，在Laravel 5.8中，它现在支持将令牌存储为SHA-256哈希。这比存储纯文本令牌更安全。</p>
<h3>5.缓存TTL</h3>
<p>在Laravel以前的版本中，缓存是以分钟为单位设置的。在5.8版中，这一点已更改为秒，以便在存储项目时更精确、更精细地设置到期时间，并符合PSR-16缓存库标准。因此，在应用程序中引用缓存时，请记住更新为秒:</p>
<figure>
<pre><code>// Laravel 5.7 - Store item for 5 minutes...
Cache::put('foo', 'bar', 10);

// Laravel 5.8 - Store item for 5 seconds...
Cache::put('foo', 'bar', 10);</code></pre>
</figure>
<h3>6.调度程序时区配置</h3>
<p>在Laravel中，您可以使用如下的<code>timezone </code>方法为计划任务定义您的时区:</p>
<figure>
<pre><code>$schedule-&gt;command('run')
         -&gt;daily()
         -&gt;at('15:00')
         -&gt;timezone('America/Chicago');</code></pre>
</figure>
<p>在以前的版本中，您必须为每个计划的任务重复这一过程，如果您有很多这样的任务，这很快就会变得很麻烦。在Laravel 5.8中，你可以在你的<code>app/Console/kernel.php</code>文件中定义一个名为<code>scheduledTimezone </code>的方法，并返回你的默认时区。这将附加到您拥有的每个计划程序:</p>
<figure>
<pre><code> /**
 * Get the timezone that should be used by default for scheduled events.
 *
 * @return DateTimeZone|string|null
 */
protected function scheduleTimezone()
{
    return 'America/Chicago';
}</code></pre>
</figure>
<h3>7.工匠呼吁改进</h3>
<p>Laravel允许您使用<code>Artisan::call </code>方法从代码中生成Artisan命令。在Laravel的早期版本中，如果您需要向命令传递一些选项，通常会这样做:</p>
<figure>
<pre><code>use IlluminateSupportFacadesArtisan;

Artisan::call('migrate:install', ['database' =&gt; 'foo']);</code></pre>
</figure>
<p>现在，在5.8中，您可以像这样在一个字符串中传递选项，而不是将选项作为数组传递:</p>
<figure>
<pre><code>Artisan::call('migrate:install --database=foo');</code></pre>
</figure>
<h3>8.工匠服务改进</h3>
<p>快速为Laravel应用程序提供服务的一种方法是运行命令<code>php artisan serve</code>。在Laravel以前的版本中，这个命令将在默认端口<code>8000</code>中运行您的应用程序，如果您试图用相同的命令服务另一个应用程序，这将会失败。现在在5.8版本中，<code>serve</code>命令将扫描到端口<code>8009</code>的可用端口，这样你就可以同时服务多个应用程序。</p>
<h3>9.模拟测试助手方法</h3>
<p>这是使您的测试代码更干净和可读的另一个改进。假设我们想要模拟一个事务服务，并让它返回一些虚拟的事务数据。在Laravel以前的版本中，我们会这样写:</p>
<figure>
<pre><code>public function testBasicTest()
{       
  $service = Mockery::mock(TransactionService::class, function ($mock) {
        $mock-&gt;shouldReceive('find')-&gt;once()-&gt;with()-&gt;andReturn(['id' =&gt; 1, 'name' =&gt; 'foo']);
  });

  $this-&gt;instance(TransactionService::class, $service)
}</code></pre>
</figure>
<p>在Laravel 5.8中，这可以简化为:</p>
<figure>
<pre><code>public function testBasicTest()
{
  $this-&gt;mock(TransactionService::class, function($mock){
    $mock-&gt;shouldReceive('find')-&gt;once()-&gt;with(1)-&gt;andReturn(['id' =&gt; 1, 'name' =&gt; 'foo'])
  });
}</code></pre>
</figure>
<p>这负责调用<code>Mockery</code>并将其绑定到容器中。注意我们不需要调用<code>$this-&gt;instance</code></p>
<h3>10.高阶或有说服力的方法</h3>
<p>以前，如果我们想将限定范围的查询与<code>or</code>结合起来，我们通常会像这样定义一个闭包:</p>
<figure>
<pre><code>// scopeActive and scopeEmailVerified methods defined on the User model...
$users = AppUser::emailVerified()-&gt;orWhere(function (Builder $query) {
  $query-&gt;active();
})-&gt;get();</code></pre>
</figure>
<p>Laravel 5.8引入了一个“高阶”<code>orWhere</code>方法，所以你再也不需要写上面的闭包了。相反，您可以这样写:</p>
<figure>
<pre><code>$users = AppUser::emailVerified()-&gt;orWhere-&gt;active()-&gt;get();</code></pre>
</figure>
<h3>结论</h3>
<p>这个新版本的Laravel加载了许多令人兴奋的特性，我们已经完成了框架中一些最显著的改进。有关如何将您现有的Laravel应用程序升级到版本5.8的详细信息，请参见<a href="https://laravel.com/docs/5.8/upgrade#upgrade-5.8.0" target="_blank" rel="noopener noreferrer">升级指南</a>。你对Laravel 5.8有什么看法？请在评论区告诉我！</p>
<h3>更多资源</h3>
<p>如果您想了解更多关于Laravel的新特性，请查看以下资源:</p><div class="code-block code-block-2">
<div class="blog-plug base-cta"><h2>使用<a class="signup" href="https://lp.logrocket.com/blg/signup" target="_blank" rel="noopener noreferrer"> LogRocket </a>消除传统错误报告的干扰</h2>
<a href="https://lp.logrocket.com/blg/signup" class="signup" target="_blank" rel="noopener noreferrer"><img class="alignnone size-full wp-image-46 jetpack-lazy-image" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/><noscript><img data-lazy-fallback="1" class="alignnone size-full wp-image-46" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/></noscript></a>
<p><a href="https://lp.logrocket.com/blg/signup" target="_blank" rel="noopener noreferrer"> LogRocket </a>是一个数字体验分析解决方案，它可以保护您免受数百个假阳性错误警报的影响，只针对几个真正重要的项目。LogRocket会告诉您应用程序中实际影响用户的最具影响力的bug和UX问题。</p>
<p>然后，使用具有深层技术遥测的会话重放来确切地查看用户看到了什么以及是什么导致了问题，就像你在他们身后看一样。</p>
<p>LogRocket自动聚合客户端错误、JS异常、前端性能指标和用户交互。然后LogRocket使用机器学习来告诉你哪些问题正在影响大多数用户，并提供你需要修复它的上下文。</p>
<p>关注重要的bug—<a class="signup" href="https://lp.logrocket.com/blg/signup-issue-free" target="_blank" rel="noopener noreferrer">今天就试试LogRocket】。</a></p></div></div>


<p class="clearfix"/>
<p class="clearfix"/>
 </article>

</div>    
</body>
</html>
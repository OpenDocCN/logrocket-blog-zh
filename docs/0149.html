<html>
<head>
<title>7 bad excuses for not using TypeScript - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>不使用TypeScript - LogRocket博客的7个糟糕借口</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/7-bad-excuses-for-not-using-typescript-dbf5e603a9a8/#0001-01-01">https://blog.logrocket.com/7-bad-excuses-for-not-using-typescript-dbf5e603a9a8/#0001-01-01</a></blockquote><div><article class="article-post">
<figure><img decoding="async" src="../Images/9885e7e26a8b840745fe30dda983ed3f.png" data-height="1105" data-width="2000" data-lazy-src="https://storage.googleapis.com/blog-images-backup/1*D8Wwwce8wS3auLAiM3BQKA.jpeg?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" class=" jetpack-lazy-image" data-original-src="https://storage.googleapis.com/blog-images-backup/1*D8Wwwce8wS3auLAiM3BQKA.jpeg"/><noscript><img data-lazy-fallback="1" decoding="async" src="../Images/9885e7e26a8b840745fe30dda983ed3f.png" data-height="1105" data-width="2000" data-original-src="https://storage.googleapis.com/blog-images-backup/1*D8Wwwce8wS3auLAiM3BQKA.jpeg"/></noscript></figure>
<p>Typescript自六年前<a href="https://en.wikipedia.org/wiki/TypeScript" target="_blank" rel="noopener noreferrer">问世以来已经走过了漫长的道路，并被领先的网络公司所采用。虽然<em>可能</em>是避免使用它的好理由，但你不使用TypeScript的借口很可能是糟糕的。</a></p>
<p>在本文中，我将讨论一些常见的问题，如学习曲线、工具、开发速度、可持续性和标准遵从性。</p>
<figure/>
<h3>1.学习曲线太陡了</h3>
<p>需要注意的是，TypeScript并不是一种全新的语言。像CoffeeScript和Reason这样的语言将JavaScript打扮成其他编程语言的语法和语义——相应地还有Ruby和OCaml。TypeScript追求更保守的目标。</p>
<p>相反，它采用普通的JavaScript，只是在其上添加了一个类型系统(TypeScript是JavaScript的超集)。这使得学习曲线非常倾斜。从JavaScript切换到TypeScript和在不同语言之间切换是不一样的。</p>
<p>下面是TypeScript中的一段代码:</p>
<figure>
<pre><code>class Greeter {
    greeting: string;

    constructor(message: string) {
        this.greeting = message;
    }

    greet() {
        return "Hello, " + this.greeting;
    }
}</code></pre>
</figure>
<p>以下是现代(ES6) JavaScript中的相同代码:</p>
<figure>
<pre><code>class Greeter {
    constructor(message) {
        this.greeting = message;
    }

    greet() {
        return "Hello, " + this.greeting;
    }
}</code></pre>
</figure>
<p>正如该语言的共同创造者安德斯·海尔斯伯格所言，<a href="https://www.hanselminutes.com/340/what-is-typescript-and-why-with-anders-hejlsberg" target="_blank" rel="noopener noreferrer"><strong>如果你懂JavaScript，你就已经懂了TypeScript</strong></a>。在本文的后面，我将更多地讨论将现有项目转换为TypeScript的途径。</p>
<h3>2.但是JavaScript是标准的，TypeScript不是</h3>
<p>当TypeScript在2012年问世时，它带来了像类和模块这样的功能，直到2015年ECMAScript第6版(ES6，或ES2015)最终确定时，这些功能才成为“标准JavaScript”。TypeScript中模块的最初实现偏离了ES6，但是在标准最终确定的同一年，它被更新(保持向后兼容性)以匹配ES6规范。</p>
<p>今天，TypeScript语言严格遵循ECMAScript规范，实现了大多数达到阶段<a href="#38bf"> </a>的提议。这意味着<strong>当你写TypeScript时，你写的是现代的、符合标准的JavaScript </strong>。由于内置的ES3/ES5 transpiler，输出的<code>.js</code>文件在旧浏览器中运行时不会出现问题。</p>
<h3>3.它扼杀了JavaScript的动态本质</h3>
<p>如果您使用脚本语言已经有一段时间了，那么您会逐渐体会到它们所带来的开发速度。您可以自由地动态讨论数据结构，而不必预先声明它们。然而，这种自由是有代价的。动态类型的程序比静态类型的程序更难推理，因为流经程序的数据没有编译时验证。</p>
<p>考虑这个简单的普通JavaScript示例:</p>
<figure>
<pre><code>function greeter(person) {
    return "Hello, " + person.firstName + " " + person.lastName;
}</code></pre>
</figure>
<p>通过查看代码，我们可以<em>推断</em>参数<code>person</code>应该是一个具有属性<code>firstName</code>和<code>lastName</code>的<code>Object</code>。但是不能保证在运行时总是如此。</p>
<p>您的项目越大，出现与类型相关的错误的可能性就越大。</p>
<p>防止代码出现这种错误的一种方法是通过运行时类型检查和附加的单元测试，如下所示:</p>
<figure>
<pre><code>function greeter(person) {
    if (!person || !person.firstName || !person.lastName) {
        throw new Error('invalid arguments');
    }

    return "Hello, " + person.firstName + " " + person.lastName;
}

// Jasmine spec:
describe("greeter", function() {
    it("returns greeting on valid input", function() {
        expect(
            greeter({firstName: 'James', lastName: 'Hetfield'})
        ).toEqual('Hello, James Hetfield');
    });

    it("throws on invalid input", function() {
        expect(() =&gt; greeter()).toThrowError('invalid arguments');
        expect(() =&gt; greeter(5)).toThrowError('invalid arguments');
        expect(() =&gt; greeter({firstName: 'Jason'})).toThrowError('invalid arguments');
    });
});</code></pre>
</figure>
<p>但是这种解决方案非常冗长，将验证数据的责任留给了开发人员。相反，如果我们可以简单地在函数中添加一个类型注释呢？</p>
<figure>
<pre><code>interface Person {
    firstName: string;
    lastName: string;
}

function greeter(person: Person): string {
    return "Hello, " + person.firstName + " " + person.lastName;
}

// Jasmine spec:
describe("greeter", function() {
    it("returns greeting", function() {
        expect(
            greeter({firstName: 'James', lastName: 'Hetfield'})
        ).toEqual('Hello, James Hetfield');
    });
});</code></pre>
</figure>
<p>上面的例子更符合习惯，让我们只关注在测试中验证业务逻辑。</p>
<p>TypeScript通过采用一个<strong>结构化类型系统</strong>和惊人地擅长<strong>类型推断</strong>来拥抱JavaScript的动态本质，这意味着您不必像在C#或Java中那样显式地使用类型。下面是一个使用我们上面在TypeScript中编写的函数的示例:</p>
<figure>
<pre><code>let user = { firstName: "James", lastName: "Hetfield" };
console.log(greeter(user));</code></pre>
</figure>
<p>此代码成功编译。请注意，我们不必显式地说<code>user</code>变量实现了<code>Person</code>接口，也不必定义一个扩展它的类。该语言的<a href="https://github.com/Microsoft/TypeScript/wiki/TypeScript-Design-Goals" target="_blank" rel="noopener noreferrer">设计目标之一</a>不是创建一个“声音或<em>可证明正确的</em>类型系统”，而是“在正确性和生产力之间取得平衡”。</p>
<p>同样重要的是，TypeScript编译器并不强迫你在任何地方声明类型，你可以选择你想在类型安全方面有多积极。您甚至可以决定在项目的不同区域应用不同级别的类型严格性。这种灵活性不是传统静态类型语言所能提供的。</p>
<h3>4.五年后它将不复存在</h3>
<p>我有消息告诉你。没有人知道5年后会出现什么语言、工具或框架，尤其是在网络领域。下面是StackOverflow博客作者写的关于JavaScript框架生命周期的文章:</p>
<blockquote><p>JavaScript框架的使用似乎有两个主要阶段。随着框架越来越受欢迎，似乎会有一个快速的上升，然后随着开发人员采用更新的技术，会有一个稍慢但稳定的下降。这些生命周期只持续几年。</p></blockquote>
<p>你在一个快速发展的行业工作，如果你和你的项目能从今天的某些技术中真正受益，考虑采用它。即使你在1-2年内把它换成其他东西，你在这段时间内获得的收益也会加速你的项目，让它物有所值。</p>
<h3>5.这不是社区驱动的</h3>
<p>Typescript于2012年由专有软件巨头微软发布。考虑到公司及其开发平台的声誉，很容易理解TypeScript是“一种JavaScript风格”。NET开发者”。也许这种看法被这样一个事实进一步强化了，即Visual Studio是当时唯一一个对该语言有丰富支持的IDE。或者这个项目的源代码最初是在微软的GitHub替代软件<a href="https://archive.codeplex.com/?p=typescript" target="_blank" rel="noopener noreferrer"> CodePlex </a>上发布的。</p>
<p>从那以后，很多事情都变了。TypeScript背后的团队意识到，如果他们希望看到该语言得到更广泛的采用，他们需要通过提供高质量的工具和听取反馈来更好地融入web开发社区。他们不仅仅是把源代码放在那里，同时在真空中继续开发，而是完全接受了开放开发的概念。</p>
<p>2014年，TypeScript的代码被<a href="https://blogs.msdn.microsoft.com/typescript/2014/07/21/new-compiler-and-moving-to-github/" target="_blank" rel="noopener noreferrer">转移到GitHub </a>，开发实际上是在那里进行的(而不是在其他地方开发，只是将新版本的代码导出到GitHub，就像在一些项目中看到的那样)。项目<a href="https://github.com/Microsoft/TypeScript/wiki/Contributing-to-TypeScript" target="_blank" rel="noopener noreferrer">以记录错误、记录提议和提交请求的形式邀请投稿</a>。“问题跟踪者”会定期查看，每份提交的材料通常会在几天内进行筛选。核心团队已经发布了我之前提到的语言的<a href="https://github.com/Microsoft/TypeScript/wiki/TypeScript-Design-Goals" target="_blank" rel="noopener noreferrer">设计目标</a>，这有助于该项目忠实于它的使命，同时仍然接受来自社区的输入。他们保持一个最新的路线图(大约每两个月发布一个新版本)，同时记录任何突破性的变化。</p>
<figure class="wp-caption"><img decoding="async" src="../Images/c6f86b80fcfdc1629dab455490d9823f.png" data-height="553" data-width="1006" data-lazy-src="https://storage.googleapis.com/blog-images-backup/0*gxKfxr1C8_pB60Gt?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" class=" jetpack-lazy-image" data-original-src="https://storage.googleapis.com/blog-images-backup/0*gxKfxr1C8_pB60Gt"/><noscript><img data-lazy-fallback="1" decoding="async" src="../Images/c6f86b80fcfdc1629dab455490d9823f.png" data-height="553" data-width="1006" data-original-src="https://storage.googleapis.com/blog-images-backup/0*gxKfxr1C8_pB60Gt"/></noscript><figcaption class="wp-caption-text">An overview of the activity on the <a href="https://github.com/Microsoft/TypeScript" target="_blank" rel="noopener noreferrer">TypeScript</a> project on Github</figcaption></figure>
<p>在撰写本文时，所有主要的跨平台ide和文本编辑器，如Eclipse、Webstorm、Emacs、Vim、Sublime、Atom、VS Code，都已经或通过插件对TypeScript提供了成熟的支持。核心团队还投入了大量精力来创建类型定义文件，以实现与用普通JavaScript编写的现有库和框架的互操作性(稍后将详细介绍)。另一件值得注意的事情是一个文档完善的TypeScript编译器API，它支持创建许多有价值的第三方语言工具。鼓励使用Typescript的开发人员在<a href="https://stackoverflow.com/questions/tagged/typescript" target="_blank" rel="noopener noreferrer"> StackOverflow </a>上提出技术问题。</p>
<p>考虑到所有这些，并重申TypeScript严重依赖ECMAScript的事实，我认为公平地说项目<em>是</em> <em>社区驱动的</em>，并且在过去几年中一直如此。以下是EmberJS，<a href="https://tomdale.net/2017/04/whats-the-deal-with-typescript/" target="_blank" rel="noopener noreferrer">的联合创始人汤姆·戴尔在2017年对TypeScript </a>的评论:</p>
<blockquote><p>最重要的是，我仍然对TypeScript团队的专业精神印象深刻。在一个可以感觉建立在无人维护的卡片房子上的生态系统中，TypeScript不断迭代改进的鼓点令人耳目一新。</p></blockquote>
<h3>6.转换现有项目的工作量太大</h3>
<p>好吧，为了在你的项目中充分利用TypeScript，你<em>将</em>不得不花时间声明类型和修复编译器错误，并且<em>将</em>有些乏味。然而，作者在构建它时考虑到了JavaScript生态系统，并为在现有项目中采用TypeScript提供了一个平稳的入口。</p>
<p>根据<a href="https://www.typescriptlang.org/docs/handbook/migrating-from-javascript.html" target="_blank" rel="noopener noreferrer">官方迁移指南</a>，你可以通过TypeScript编译器简单地运行你的<em>现有JavaScript </em> <em>代码</em>来获得一些早期的好处。此时，编译器会捕捉一些低级错误，比如在函数或不可达代码块的末尾缺少<code>return</code>语句。然后，您可以开始将<code>.js</code>文件逐个重命名为<code>.ts</code>，并处理新的编译器反馈。默认的编译器选项相当宽松，但是您可以打开更严格的检查。您甚至可以在项目的不同部分使用一组不同的编译器选项，让您的团队按照他们自己的速度采用TypeScript，根据他们的需要使用或多或少。底线是<strong>有一个平稳的过渡路径，不会停止整个公司的发展，</strong>这不是一个全有或全无的承诺。</p>
<p>您可以选择逐渐将现有项目转换为TypeScript，或者<a href="https://www.lucidchart.com/techblog/2017/11/16/converting-600k-lines-to-typescript-in-72-hours/" target="_blank" rel="noopener noreferrer">执行“大爆炸”转换</a>，或者简单地将其用于新项目。还有像<a href="https://medium.com/@urish/manual-typing-is-no-fun-introducing-typewiz-58e3e8813f4c" target="_blank" rel="noopener noreferrer"> TypeWiz </a>这样的社区项目，可以自动将缺失的类型信息添加到代码中。</p>
<h3>7.但是我使用的所有库都是JavaScript的</h3>
<p>为了实现与现有JavaScript代码的互操作性，该语言支持TypeScript声明文件。例如，如果您使用的JavaScript库导出了一个名为<code>camelize</code>的全局函数，那么它的TypeScript声明将如下所示:</p>
<figure>
<pre><code>declare function camelize(s: string): string;</code></pre>
</figure>
<p>将这样的声明导入到项目中后，TypeScript将知道该函数的类型。</p>
<p>同年，TypeScript发布，<a href="https://github.com/DefinitelyTyped/DefinitelyTyped" target="_blank" rel="noopener noreferrer"> DefinitelyTyped </a>，一个流行库的声明文件的社区存储库被创建。在撰写本文时，它包含了5，000多个JavaScript包的声明。使用这些声明非常容易。例如，如果您在项目中使用Jasmine测试框架，只需运行:</p>
<figure>
<pre><code>npm install --save-dev @types/jasmine</code></pre>
</figure>
<p>编译器会自动包含这些类型，您可以在代码编辑器中进行动态类型检查和自动完成。您使用的所有或大部分包都应该已经为它们创建了高质量的类型声明，或者捆绑在一起，或者通过DefinitelyTyped repo提供。Slack的工程团队分享了他们的经验:</p>
<blockquote><p>展望未来并思考代码维护，我们欣赏围绕TypeScript的生态系统。作为React和Node/npm生态系统的大量用户，第三方库的类型定义的可用性是一个巨大的优势。我们导入的许多库已经与TypeScript兼容。如果模块本身没有提供定义，那么它们可能会出现在奇妙的<a href="https://github.com/DefinitelyTyped/DefinitelyTyped" target="_blank" rel="noopener noreferrer">明确类型化的</a>项目中。例如，React没有附带类型定义，但是一个简单的<code><em>npm install @types/react</em></code>就可以安装它们，不需要进一步的配置。</p></blockquote>
<h3>结论</h3>
<p>使用静态类型检查有助于消除一整类错误，TypeScript是Node/JavaScript项目中最流行的静态类型解决方案。对于一个相对较小或实验性的项目来说，这可能不值得，但其好处远远超过大规模项目的额外开销，正如谷歌、Slack、Asana、Ember等公司所证明的那样。希望这篇文章为您提供了关于TypeScript的新观点，并解决了一些不再相关的反对它的具体论点。也许你该再给它一次机会了。</p>
<p>您目前正在使用TypeScript还是计划使用它？如果不是，是什么阻碍了你？</p>
<p>P.S .值得注意的是，还有另一个项目在保留语言语法和语义的同时向JavaScript添加静态类型，它被称为<a href="https://flow.org/" target="_blank" rel="noopener noreferrer"> Flow </a>。如果你正在寻找TypeScript的替代品，一定要去看看。</p>
<p>[ <a href="#bb31"> ^ </a> ]根据ECMAScript的<a href="https://tc39.github.io/process-document/" target="_blank" rel="noopener noreferrer">标准化流程</a>，阶段3(“候选”)是标准提案五个“成熟”步骤中的第四个。这意味着提案规范已经可以在现实世界中实现了。</p><div class="code-block code-block-21">
<div class="blog-plug inline-plug typescript-plug"><h2><a class="signup" href="https://lp.logrocket.com/blg/typescript-signup" target="_blank" rel="noopener noreferrer"> LogRocket </a>:全面了解您的网络和移动应用</h2>
<a href="https://lp.logrocket.com/blg/typescript-signup" class="signup" target="_blank" rel="noopener noreferrer"><img class="alignnone size-full wp-image-46 jetpack-lazy-image" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/><noscript><img data-lazy-fallback="1" class="alignnone size-full wp-image-46" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/></noscript></a>
<p>LogRocket 是一个前端应用程序监控解决方案，可以让您回放问题，就像问题发生在您自己的浏览器中一样。LogRocket不需要猜测错误发生的原因，也不需要向用户询问截图和日志转储，而是让您重放会话以快速了解哪里出错了。它可以与任何应用程序完美配合，不管是什么框架，并且有插件可以记录来自Redux、Vuex和@ngrx/store的额外上下文。</p>
<p>除了记录Redux操作和状态，LogRocket还记录控制台日志、JavaScript错误、堆栈跟踪、带有头+正文的网络请求/响应、浏览器元数据和自定义日志。它还使用DOM来记录页面上的HTML和CSS，甚至为最复杂的单页面和移动应用程序重新创建像素级完美视频。</p>
<a class="signup" href="https://lp.logrocket.com/blg/typescript-signup" target="_blank" rel="noopener noreferrer">Try it for free</a><p>.</p></div>
</div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
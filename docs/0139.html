<html>
<head>
<title>Understanding Redux: A tutorial with examples - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>理解Redux:带示例的教程</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/understanding-redux-tutorial-examples/#0001-01-01">https://blog.logrocket.com/understanding-redux-tutorial-examples/#0001-01-01</a></blockquote><div><article class="article-post">
<p><em> <strong>编者按</strong>:这个React Redux教程最后一次更新是在2022年10月3日，内容包括Redux有什么用途，为什么Redux对React很好，以及更新过时的信息。</em></p>
<p>随着web开发工具和库的出现(JavaScript库可能在您读完本文之前就已经发布了)，在没有真正理解它的好处或为什么应该使用它的情况下就使用每一个新的工具和库可能不是最明智的做法。</p>
<p>Redux并不新鲜，但它仍然很受欢迎。在本教程中，我们将向您展示Redux是什么，为什么您应该使用它，以及它是如何工作的。</p>
<p>首先，我们将回顾Redux 的<a href="https://egghead.io/courses/getting-started-with-redux" target="_blank" rel="noopener">基础以及它是如何工作的。然后我们将通过使用一个简单但实用的组件来看看使用Redux如何在您的应用程序中帮助您。</a></p>
<p>我们将详细介绍以下内容:</p>

<h2 id="what-redux">Redux是什么？</h2>
<p>Redux是一个可预测的状态容器，旨在帮助您编写跨客户端、服务器和本机环境表现一致的JavaScript应用程序，并且易于测试。</p>
<p>虽然它主要用作React的状态管理工具，但是您可以将它用于任何其他JavaScript框架或库。它是轻量级的，只有2KB(包括依赖项)，所以您不必担心它会使您的应用程序的资产变大。</p>
<p>使用Redux，应用程序的状态保存在一个存储中，每个组件都可以从这个存储中访问它需要的任何状态。</p>
<p>如果你刚刚开始使用Redux，下面的视频对初学者来说是一个很好的资源。</p>
<p><span class="embed-youtube"> <iframe loading="lazy" class="youtube-player" src="https://www.youtube.com/embed/CVpUuw9XSjY?version=3&amp;rel=1&amp;showsearch=0&amp;showinfo=1&amp;iv_load_policy=1&amp;fs=1&amp;hl=en-US&amp;autohide=2&amp;wmode=transparent" allowfullscreen="true" sandbox="allow-scripts allow-same-origin allow-popups allow-presentation">视频</iframe> </span></p>
<h2 id="when-use-redux">何时使用Redux</h2>
<p>最近前端世界最大的争论之一是关于Redux。发布后不久，Redux就成为最热门的讨论话题之一。许多人赞成它，而其他人指出了问题。</p>
<p>Redux允许您在一个地方管理应用程序的状态，并使应用程序中的更改更加可预测和可跟踪。这使得推断应用程序中发生的变化变得更加容易。但是所有这些好处都伴随着权衡和限制。有人可能会觉得它增加了样板代码，使简单的事情变得有点令人不知所措；但这取决于架构决策。</p>
<p>这个问题的一个简单答案是，当你需要Redux时，你会自己意识到。如果你仍然不知道是否需要它，你不需要。当你的应用程序增长到管理应用程序状态变得很麻烦的规模时，通常会发生这种情况；你开始寻找使它变得简单易行的方法。</p>
<h3 id="what-redux-used-for">那么，Redux是用来做什么的呢？</h3>
<p>简而言之，Redux用于跨应用程序维护和更新数据，供多个组件共享，同时保持独立于组件。</p>
<p>如果没有Redux，您将不得不使数据依赖于组件，并通过不同的组件将其传递到需要它的地方。</p>
<p><img data-attachment-id="137624" data-permalink="https://blog.logrocket.com/understanding-redux-tutorial-examples/attachment/passing-data-components-2/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/10/passing-data-components-1.png" data-orig-size="730,469" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Passing data components" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/10/passing-data-components-1-300x193.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/10/passing-data-components-1.png" decoding="async" class="aligncenter wp-image-137624 size-full jetpack-lazy-image" src="../Images/4dc48ec0b567c61efda6fd4703dffbf3.png" alt="Passing Data Through Components Diagram" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2020/10/passing-data-components-1.png 730w, https://blog.logrocket.com/wp-content/uploads/2020/10/passing-data-components-1-300x193.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2020/10/passing-data-components-1.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/10/passing-data-components-1.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="137624" data-permalink="https://blog.logrocket.com/understanding-redux-tutorial-examples/attachment/passing-data-components-2/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/10/passing-data-components-1.png" data-orig-size="730,469" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Passing data components" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/10/passing-data-components-1-300x193.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/10/passing-data-components-1.png" decoding="async" loading="lazy" class="aligncenter wp-image-137624 size-full" src="../Images/4dc48ec0b567c61efda6fd4703dffbf3.png" alt="Passing Data Through Components Diagram" srcset="https://blog.logrocket.com/wp-content/uploads/2020/10/passing-data-components-1.png 730w, https://blog.logrocket.com/wp-content/uploads/2020/10/passing-data-components-1-300x193.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/10/passing-data-components-1.png"/></noscript>
<p>在上面的例子中，我们只需要父组件和内部子组件中的一些数据，但是我们被迫将它传递给所有组件(包括不需要它的子组件),以便将它传递到需要它的地方。</p>
<p>使用Redux，我们可以使状态数据独立于组件，并且在需要时，组件可以通过Redux存储进行访问或更新。</p>
<p><img data-attachment-id="137622" data-permalink="https://blog.logrocket.com/understanding-redux-tutorial-examples/attachment/passing-updating-independently-redux-store/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/10/passing-updating-independently-Redux-store.png" data-orig-size="730,268" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Passing updating independently Redux store" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/10/passing-updating-independently-Redux-store-300x110.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/10/passing-updating-independently-Redux-store.png" decoding="async" class="aligncenter size-full wp-image-137622 jetpack-lazy-image" src="../Images/bcbdea0ce12d8bc307ef47c64c30625f.png" alt="Passing And Updating Independently With Redux Store Diagram" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2020/10/passing-updating-independently-Redux-store.png 730w, https://blog.logrocket.com/wp-content/uploads/2020/10/passing-updating-independently-Redux-store-300x110.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2020/10/passing-updating-independently-Redux-store.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/10/passing-updating-independently-Redux-store.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="137622" data-permalink="https://blog.logrocket.com/understanding-redux-tutorial-examples/attachment/passing-updating-independently-redux-store/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/10/passing-updating-independently-Redux-store.png" data-orig-size="730,268" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Passing updating independently Redux store" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/10/passing-updating-independently-Redux-store-300x110.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/10/passing-updating-independently-Redux-store.png" decoding="async" loading="lazy" class="aligncenter size-full wp-image-137622" src="../Images/bcbdea0ce12d8bc307ef47c64c30625f.png" alt="Passing And Updating Independently With Redux Store Diagram" srcset="https://blog.logrocket.com/wp-content/uploads/2020/10/passing-updating-independently-Redux-store.png 730w, https://blog.logrocket.com/wp-content/uploads/2020/10/passing-updating-independently-Redux-store-300x110.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/10/passing-updating-independently-Redux-store.png"/></noscript>
<h2 id="why-redux-good-react">为什么Redux和React好？</h2>
<p>正如我们前面提到的，Redux是一个独立的库，可以用于不同的JavaScript框架，如Angular、Inferno、Vue、Preact、react等</p>
<p>但是，Redux最常与React一起使用。</p>
<p>这是因为React是根据状态和生命周期的概念设计的。而在React中，状态也不能直接修改，只能通过函数<code>setState</code>来完成。这使得Redux概念更容易应用，因为它们共享对状态对象的相同理解和行为。</p>
<blockquote><p>💡React组件被定义为具有应用程序状态访问的类或函数，即类扩展了<code>React.Component</code>，函数使用<code>useState</code>助手来访问状态值/对象。</p></blockquote>
<h2 id="what-state-management-redux">Redux中的状态管理是什么？</h2>
<p>状态管理本质上是一种促进组件间通信和数据共享的方法。它创建了一个有形的数据结构来表示您的应用程序的状态，您可以从中读取和写入。这样，在使用它们时，您可以看到原本看不见的状态。</p><div class="code-block code-block-54">
<hr/>
<h3>更多来自LogRocket的精彩文章:</h3>

<hr/></div>
<p>大部分库，比如React，Angular等。为组件提供了一种在内部管理其状态的方式，而不需要任何外部库或工具。它适用于组件很少的应用程序，但是随着应用程序越来越大，管理跨组件共享的状态就变得很麻烦。</p>
<p>在组件间共享数据的应用程序中，实际知道一个州应该在哪里可能会令人困惑。理想情况下，组件中的数据应该只存在于一个组件中，因此在兄弟组件之间共享数据变得很困难。</p>
<p>例如，在React中，为了在兄弟组件之间共享数据，状态必须存在于父组件中。更新该状态的方法由父组件提供，并作为道具传递给这些兄弟组件。</p>
<p>下面是React中登录组件的一个简单示例。登录组件的输入会影响其同级组件(状态组件)显示的内容:</p>
<pre class="language-javascript hljs">class App extends React.Component {
  constructor(props) {
    super(props);
    // First the Parent creates a state for what will be passed
    this.state = { userStatus: "NOT LOGGED IN"}
    this.setStatus = this.setStatus.bind(this);
  }
  // A method is provided for the child component to update the state of the
  // userStatus
  setStatus(username, password) {
    const newUsers = users;
    newUsers.map(user =&gt; {
      if (user.username == username &amp;&amp; user.password === password) {
        this.setState({
          userStatus: "LOGGED IN"
        })
      }
    });
  }

  render() {
    return (
      &lt;div&gt;
        // the state is passed to the sibling as a props as is updated whenever
        // the child component changes the input
        &lt;Status status={this.state.userStatus} /&gt;
        // this method is passed to the child component as a props which it
        // uses to change the state of the userStatus
        &lt;Login handleSubmit={this.setStatus} /&gt;
      &lt;/div&gt;
    );
  }
});
</pre>
<blockquote><p>请记住，父组件不需要这些数据，但是因为其子组件需要共享数据，所以它必须提供一个状态。</p></blockquote>
<p>现在想象一下，当一个状态必须在组件树中相距很远的组件之间共享时会发生什么。状态必须从一个组件传递到另一个组件，直到它到达需要它的地方。</p>
<p>基本上，状态必须提升到最近的父组件，然后提升到下一个组件，直到到达需要该状态的两个组件共有的祖先，然后传递下去。这使得状态难以维持，并且更不可预测。这也意味着将数据传递给不需要它的组件。</p>
<p>很明显，随着应用程序变得越来越复杂，状态管理也变得越来越混乱。这就是为什么你需要一个像Redux这样的状态管理工具，让维护这些状态变得更容易。在考虑Redux的好处之前，让我们先了解一下Redux的概念。</p>
<h2 id="how-redux-works">Redux如何工作</h2>
<p>Redux的工作方式很简单。有一个保存应用程序整个状态的中央存储。每个组件都可以访问存储的状态，而不必将道具从一个组件发送到另一个组件。</p>
<p>Redux中有三个核心组件——动作、存储和reducers。下面简单讨论一下他们各自是做什么的。这很重要，因为它们可以帮助您了解Redux的优势以及如何使用它。我们将实现一个类似于上面登录组件的例子，但是这次是在Redux中。</p>
<blockquote><p>💡<code>state</code>表示保存组件间共享的应用程序数据的对象。</p></blockquote>
<h3 id="what-redux-actions">什么是Redux动作？</h3>
<p>简单来说，Redux动作就是事件。</p>
<p>它们是将数据从应用程序发送到Redux存储的唯一方式。数据可以来自用户交互、API调用，甚至表单提交。</p>
<p>动作是普通的JavaScript对象，必须具有</p>
<ul>
<li>用于指示要执行的动作类型的<code>type</code>属性，以及</li>
<li>一个包含用于改变状态的信息的<code>payload</code>对象。</li>
</ul>
<p>动作是通过动作创建器创建的，简单来说就是一个返回动作的函数。并且使用将动作发送到存储的<code>store.dispatch()</code>方法来执行动作。</p>
<p>下面是一个操作示例:</p>
<pre class="language-javascript hljs">{ 
  type: "LOGIN",
  payload: {
    username: "foo",
    password: "bar"
  }
}
</pre>
<p>下面是一个动作创建者的示例:</p>
<pre class="language-javascript hljs">const setLoginStatus = (username, password) =&gt; {
  return {
    type: "LOGIN",
    payload: {
      username, // "foo"
      password // "bar" 
    }
  }
}
</pre>
<h2 id="what-redux-reducers">什么是Redux reducers？</h2>
<p>Reducers是纯粹的函数，它接受应用程序的当前状态，执行一个动作，然后返回一个新状态。reducer处理状态(应用程序数据)如何响应动作而改变。</p>
<blockquote><p>💡纯函数是指如果给定相同的参数，将总是返回相同的值的函数。即该函数仅依赖于参数而不依赖于外部数据。</p></blockquote>
<p>它基于JavaScript中的<code>reduce</code>函数，在执行回调函数后，从多个值中计算出一个值。</p>
<p>下面是Redux中reducers如何工作的一个例子:</p>
<pre class="language-javascript hljs">const LoginComponent = (state = initialState, action) =&gt; {
    switch (action.type) {

      // This reducer handles any action with type "LOGIN"
      case "LOGIN":
          return state.map(user =&gt; {
              if (user.username !== action.username) {
                  return user;
              }

              if (user.password == action.password) {
                  return {
                      ...user,
                      login_status: "LOGGED IN"
                  }
              }
          });
       default:
          return state;
      } 
};
</pre>
<blockquote><p>💡Reducers获取应用程序以前的状态，并根据传递给它的动作返回一个新状态。作为纯函数，它们不会改变传递给它们的对象中的数据，也不会对应用程序产生任何副作用。给定相同的对象，它们应该总是产生相同的结果。</p></blockquote>
<h3 id="what-redux-store">Redux Store是什么？</h3>
<p>商店是保存应用程序状态的“容器”(实际上是一个JavaScript对象)，改变状态的唯一方式是通过发送到商店的动作。Redux允许单个组件将<em> <em/> </em>连接到商店，并通过调度动作对其应用更改。</p>
<p>强烈建议在任何Redux应用程序中只保留一个存储。您可以通过helper方法访问存储的状态、更新状态以及注册或取消注册侦听器。</p>
<p>让我们为我们的登录应用程序创建一个商店:</p>
<pre class="language-javascript hljs">const store = createStore(LoginComponent);
</pre>
<p>对状态执行的操作总是返回新的状态。因此，这种状态非常容易预测。</p>
<p>现在我们对Redux有了更多的了解，让我们回到之前实现的登录组件示例，看看Redux如何改进组件:</p>
<pre class="language-javascript hljs">class App extends React.Component {
    render() {
        return (
            &lt;div&gt;
                &lt;Status user={this.props.user.name}/&gt;
                &lt;Login login={this.props.setLoginStatus}/&gt;
            &lt;/div&gt;
        )
    }
}
</pre>
<p>使用Redux，存储中有一个通用状态，每个组件都可以访问该状态。</p>
<p>这消除了将状态从一个组件持续传递到另一个组件的需要。您还可以从商店中为特定组件选择切片；这使得你的应用程序更加优化。</p>
<h2 id="redux-middleware">Redux中间件</h2>
<p>Redux允许开发人员在组件的所有动作被传递给<code>reducer</code>函数之前拦截它们。这种拦截是通过中间件完成的。</p>
<p>基于上一节讨论的示例登录组件，我们可能希望在用户的输入到达我们的存储进行进一步处理之前对其进行净化。这可以通过<a href="https://redux.js.org/understanding/history-and-design/middleware" target="_blank" rel="noopener"> Redux中间件</a>来实现。</p>
<p>从技术上讲，中间件是在处理完当前动作后调用参数中接收的下一个方法的函数。每次调度后都会调用这些函数。</p>
<p>下面是一个简单的中间件的样子:</p>
<pre class="language-javascript hljs">function simpleMiddleware({ getState, dispatch }) {
  return function(next){
    return function(action){
      // processing
      const nextAction = next(action);
      // read the next state
      const state = getState();
      // return the next action or you can dispatch any other action
      return nextAction;  
    }
  }
}
</pre>
<p>这可能看起来有点令人不知所措，但是在大多数情况下，您可能不需要创建自己的中间件，因为巨大的Redux社区已经提供了许多这样的中间件。如果你觉得中间件是必需的，你会喜欢它，因为它给你很大的力量用最好的抽象做大量的工作。</p>
<h2 id="why-use-redux">为什么要用Redux？</h2>
<p>当Redux与React一起使用时，状态将不再需要提升。这使您更容易跟踪哪个操作导致了任何变化。</p>
<p>正如您在上面的例子中看到的，组件不需要为其子组件提供任何状态或方法来在它们之间共享数据。一切都由Redux处理。这大大简化了应用程序，使其更容易维护。</p>
<p>这是您应该使用Redux的主要原因，但不是唯一的好处。请看下面的列表，它总结了使用Redux进行状态管理可以获得的好处。</p>
<h3 id="redux-makes-state-predictable">Redux使状态可预测</h3>
<p>在Redux中，状态总是可预测的。如果将相同的状态和动作传递给一个reducer，总是会产生相同的结果，因为reducer是纯函数。状态也是不可变的，永远不会改变。这使得实现像无限撤销和重做这样的艰巨任务成为可能。还可以实现时间旅行，即在以前的状态之间来回移动并实时查看结果的能力。</p>
<h3 id="redux-maintainable">Redux是可维护的</h3>
<p>Redux对如何组织代码有严格的要求，这使得了解Redux的人更容易理解任何Redux应用程序的结构。这通常会使维护变得更容易。这也有助于将业务逻辑从组件树中分离出来。对于大规模的应用程序，保持你的应用程序更具可预测性和可维护性是至关重要的。</p>
<h3 id="debugging-easy-redux">在Redux中调试很容易</h3>
<p>Redux使调试应用程序变得容易。通过记录操作和状态，很容易理解编码错误、网络错误和生产过程中可能出现的其他形式的错误。</p>
<p>除了日志之外，它还有<a href="https://blog.logrocket.com/redux-devtools-tips-tricks-for-faster-debugging/" target="_blank" rel="noopener">强大的开发工具，允许你进行时间旅行动作</a>，在页面刷新时保持动作，等等。</p>
<p>对于中型和大型应用程序，调试比实际开发功能花费更多的时间。Redux DevTools使得利用Redux提供的所有功能变得很容易。</p>
<h3 id="performance-benefits">性能优势</h3>
<p>您可能会认为保持应用程序的全局状态会导致性能下降。很大程度上，事实并非如此。</p>
<p>React Redux在内部实现了许多性能优化，以便您自己的连接组件只在实际需要时才重新呈现。</p>
<h3 id="ease-testing">易于测试</h3>
<p>测试Redux应用程序很容易，因为函数用来改变纯函数的状态。</p>
<h3 id="h3statepersistence">状态持久性</h3>
<p>您可以将应用程序的一些状态保存到本地存储，并在刷新后恢复。这真的很棒。</p>
<h3 id="server-side-rendering">服务器端渲染</h3>
<p>Redux也可以用于服务器端渲染。使用它，您可以通过将应用程序的状态及其对服务器请求的响应发送到服务器来处理应用程序的初始呈现。然后，所需的组件以HTML格式呈现并发送给客户端。</p>
<h2 id="conclusion">结论</h2>
<p>我们已经讨论了Redux的主要特性，以及为什么Redux对你的应用有益。虽然Redux有它的好处，但这并不意味着你应该在你所有的应用中加入Redux。没有Redux ，你的应用程序<a href="https://blog.logrocket.com/when-and-when-not-to-use-redux-41807f29a7fb/" target="_blank" rel="noopener">可能仍然工作得很好。</a></p>
<p>Redux的一个主要好处是增加了将“发生了什么”与“事情如何变化”分离的方向。然而，如果您确定您的项目需要状态管理工具，那么您应该只实现Redux。</p>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
<html>
<head>
<title>How to protect your Node.js applications from malicious dependencies - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>如何保护Node.js应用程序免受恶意依赖</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/how-to-protect-your-node-js-applications-from-malicious-dependencies-5f2e60ea08f9/#0001-01-01">https://blog.logrocket.com/how-to-protect-your-node-js-applications-from-malicious-dependencies-5f2e60ea08f9/#0001-01-01</a></blockquote><div><div class="mainheading">

<div class="row post-top-meta hidden-md-down">

<div class="col-md-10 col-xs-12">
<a class="text-capitalize link-dark" href="https://blog.logrocket.com/author/albertogimeno/">
Alberto Gimeno <span class="btn follow">Follow</span></a>
<span class="author-description d-block">Ecosystem Engineer at GitHub. Sometimes I write about JavaScript, Node.js, and frontend development.</span>
</div>
</div>
<h1 class="posttitle">如何保护Node.js应用程序免受恶意依赖</h1>
<h2 class="post-subtitle"/>
<p><span class="post-date"><time class="post-date">2018年12月7日</time> </span> <span class="dot"/> <span class="readingtime"> 3分钟读完</span> <span class="wordcount"> 1008 </span> <span class="logrocket_editor"/></p>
</div>
<article class="article-post">
<figure>
<img decoding="async" data-height="700" data-width="1240" src="../Images/25acdbab710491c6cf0ca6c4a0bcf2e6.png" data-lazy-src="https://storage.googleapis.com/blog-images-backup/1*GG67wdykOg7Zk4h8cjqJIQ.jpeg?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" class=" jetpack-lazy-image" data-original-src="https://storage.googleapis.com/blog-images-backup/1*GG67wdykOg7Zk4h8cjqJIQ.jpeg"/><noscript><img data-lazy-fallback="1" decoding="async" data-height="700" data-width="1240" src="../Images/25acdbab710491c6cf0ca6c4a0bcf2e6.png" data-original-src="https://storage.googleapis.com/blog-images-backup/1*GG67wdykOg7Zk4h8cjqJIQ.jpeg"/></noscript><br/>
</figure>
<p>你可能听说过<a href="https://blog.npmjs.org/post/180565383195/details-about-the-event-stream-incident" target="_blank" rel="noopener noreferrer">最近的一个事件</a>，一个流行的npm包<a href="https://github.com/dominictarr/event-stream/issues/116#issue-382854428" target="_blank" rel="noopener noreferrer"> <em>事件流</em> </a>，包含了可能影响数千个应用程序(甚至更多)的恶意代码。).希望这次攻击是有针对性的，只影响一个特定的项目。</p>
<p>该库的原始作者是社会工程攻击的受害者，一个恶意黑客获得了发布权限。许多人认为原作者应该更加谨慎。</p>
<p>但这不是真正的问题。</p>
<p>为什么？</p>
<p>因为库的原始作者可能故意发布了恶意代码，所以任何拥有库的人都可以随时发布恶意代码。我们很多人都依赖于荣誉系统，希望没有人会发布恶意代码。</p>
<p>我们如何防止这种情况发生？</p>
<p>嗯，总是会有多种方式侵入系统，并向我们的应用程序中注入恶意代码。不仅通过依赖性，还通过无意的漏洞。</p>
<p>然而，我们仍然可以考虑如何防止这些事情发生，但更重要的是，我们需要考虑减轻其影响的方法。</p>
<p/>
<figure>
<p><a href="https://logrocket.com/signup/" target="_blank" rel="noopener noreferrer"><img decoding="async" data-height="750" data-width="3212" src="../Images/94b3e0f84b30cb0d321f60471481ab64.png" data-lazy-src="https://storage.googleapis.com/blog-images-backup/1*GPjaPKNNUYHU8EsA3Z0JGA.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" class=" jetpack-lazy-image" data-original-src="https://storage.googleapis.com/blog-images-backup/1*GPjaPKNNUYHU8EsA3Z0JGA.png"/><noscript><img data-lazy-fallback="1" decoding="async" data-height="750" data-width="3212" src="../Images/94b3e0f84b30cb0d321f60471481ab64.png" data-original-src="https://storage.googleapis.com/blog-images-backup/1*GPjaPKNNUYHU8EsA3Z0JGA.png"/></noscript></a>T6】</p></figure>
<h3>预防</h3>
<p>你现在可以采取一些预防措施:</p>
<ul>
<li><strong>锁定你的依赖</strong>。使用<code>package-lock.json</code>或<code>yarn.lock</code>来防止在部署时获得自动更新(在您的服务器中执行<code>npm/yarn install</code>时)。至少这样你会有更少的机会得到npm团队还没有清理的恶意更新。然而，这并不能阻止事件流对您的影响，因为恶意代码已经在npm注册表中存在数周了。但这可能会阻止你在7月份发生另一起事件。</li>
<li><strong>使用</strong> <a href="https://docs.npmjs.com/cli/audit" target="_blank" rel="noopener noreferrer"> <strong> npm审计</strong> </a> <strong>、</strong> <a href="https://snyk.io/" target="_blank" rel="noopener noreferrer"> <strong> Snyk </strong> </a> <strong>和/或</strong> <a href="https://help.github.com/articles/about-security-alerts-for-vulnerable-dependencies/" target="_blank" rel="noopener noreferrer"> <strong> GitHub安全警报</strong> </a>在您的任何依赖项可能包含安全漏洞时得到通知。</li>
</ul>
<h3>减轻</h3>
<p>现在，一旦攻击被触发，我们如何减轻它的影响？</p>
<p>大多数攻击包括窃取数据、挖掘并将结果发送回服务器等。因此，您可以使用权限非常有限的用户来执行Node.js:限制文件系统访问，配置iptables以限制应用程序只能连接到某些域，等等。问题是，在云服务时代，你可能无法在你的云提供商那里做到这一点。</p>
<p>在Node.js内部我们能做些什么吗？</p>
<p>Node.js的贡献者已经开始考虑一个<a href="https://docs.google.com/document/d/1h__FmXsEWRuNrzAV_l3Iw9i_z8fCXSokGfBiW8-nDNg/view#heading=h.v9j0bjkph3tv" target="_blank" rel="noopener noreferrer"> Node.js安全模型</a>。因此，我们可以期待将来在Node.js中实现不同级别的安全性。</p>
<p>我个人喜欢一个权限系统，在这里你可以定义你需要在你的<code>package.json</code>中访问什么东西。例如:</p>
<figure>
<pre><code>{
  "permissions": {
    "fs": {
      "directories": {
        "$TEMP": "rw",
        "$SRC_ROOT": "r"
      }
    },
    "network": {
      "tcp": {
        "v4:*:$PORT": "LISTEN"
      }
    }
  }
}</code></pre>
</figure>
<p>这类似于现代浏览器中的内容安全策略。</p>
<p>当然，这只是我的建议，Node.js安全模型的想法才刚刚开始评估。不要指望在不久的将来会实现。</p>
<p>那么，我们现在能做点什么吗？更具体地说，在不改变Node.js内部结构的情况下，我们能在Userland中做些什么呢？</p>
<p>答案是肯定的！</p>
<h3>沙盒化你的应用——硬核方式</h3>
<p>由于Node.js也遵循JavaScript的动态特性，我们能够<em>侵入</em>运行时。我们可以:</p>
<ul>
<li><strong>劫持</strong><code>require()</code>电话并操纵里面的代码。这就是<code>ts-node/register</code>和<code>@babel/register</code>的工作方式。</li>
<li><strong>用<a href="https://nodejs.org/api/vm.html" target="_blank" rel="noopener noreferrer"> vm模块</a>在沙盒环境中运行</strong>代码，通过自定义<code>require</code>函数阻止访问某些模块，或者包装核心模块阻止访问某些东西。</li>
</ul>
<p><strong>或</strong></p>
<ul>
<li>直接<strong>覆盖</strong>核心模块。让我们看看如何做到这一点:</li>
</ul>
<p>我将展示一个覆盖<code>readFileSync</code>以防止访问特定目录中的文件的概念证明。在实践中，我们应该覆盖一些其他功能，我们也可以选择白名单，而不是黑名单某些目录。</p>
<p>但是作为一个例子，我只想防止恶意代码:</p>
<figure>
<pre><code>// malicious.js
const fs = require('fs')
const secrets = fs.readFileSync('/system/secrets.txt', 'utf8')
console.log(secrets);</code></pre>
</figure>
<p>我将实现一个覆盖<code>fs</code>核心模块的<code>cage.js</code>文件，我将拦截该函数并阻止访问<code>/system/</code>内部的文件:</p>
<figure>
<pre><code>// cage.js
const fs = require('fs')
const path = require('path')
const wrap = (module, name, wrapper) =&gt; {
  const original = module[name]
  module[name] = wrapper(original)
}
wrap(fs, 'readFileSync', (readFileSync) =&gt; (...args) =&gt; {
  const [filepath] = args
  const fullpath = path.resolve(filepath)
  if (fullpath.startsWith('/system/')) {
    throw new Error('You do not have permissions to access this file')
  }
  return readFileSync(...args)
})
// Prevent further changes
Object.freeze(fs)</code></pre>
</figure>
<p>瞧啊。就在那里。现在，如果我们直接运行恶意代码:</p>
<p><code>node malicious.js</code></p>
<p>我们将看到该文件的内容被打印到标准输出中。但是如果我们告诉Node.js首先像这样运行<code>cage.js</code>:</p>
<p><code>node -r cage.js malicious.js</code></p>
<p>我们将看到恶意代码无法访问文件的内容，并抛出了一个错误。</p>
<p>显然，这只是一个概念证明。下一步将是覆盖更多的函数，使其可配置，而不是硬编码文件路径，理想情况下，对其他核心模块也是如此。例如覆盖<a href="https://nodejs.org/api/http.html#http_http_request_options_callback" target="_blank" rel="noopener noreferrer"> http(s)。请求</a>。</p>
<h3>结论</h3>
<ul>
<li>我们的应用中的恶意代码(或只是易受攻击的代码)是一个日益严重的问题，因为我们的应用变得越来越复杂，依赖于更多的依赖项，使得攻击面越来越大</li>
<li>诸如<a href="https://docs.npmjs.com/cli/audit" target="_blank" rel="noopener noreferrer"> npm审计</a>、<a href="https://snyk.io/" target="_blank" rel="noopener noreferrer"> Snyk </a>和/或<a href="https://help.github.com/articles/about-security-alerts-for-vulnerable-dependencies/" target="_blank" rel="noopener noreferrer"> GitHub安全警报</a>之类的服务和工具非常有用，你现在就可以开始使用它们</li>
<li>我们需要减轻攻击的影响，Node.js需要在这方面做些什么。然而，解决方案不是在不久的将来</li>
<li>如果你想走“硬核之路”，你可以！Node.js足够灵活，允许你做一些疯狂的事情来保护自己。我们刚刚演示过了🙂</li>
</ul>
<p> </p><div class="code-block code-block-23">
<div class="blog-plug inline-plug node-plug"><h2>200只<img src="../Images/61167b9d027ca73ed5aaf59a9ec31267.png" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2019/10/green-check.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" class=" jetpack-lazy-image" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/10/green-check.png"/> <noscript> <img data-lazy-fallback="1" src="../Images/61167b9d027ca73ed5aaf59a9ec31267.png" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/10/green-check.png"/> </noscript>显示器出现故障，生产中网络请求缓慢</h2><p>部署基于节点的web应用程序或网站是容易的部分。确保您的节点实例继续为您的应用程序提供资源是事情变得更加困难的地方。如果您对确保对后端或第三方服务的请求成功感兴趣，</p><a href="https://lp.logrocket.com/blg/node-signup" target="_blank">try LogRocket</a><p>. </p><a class="signup" href="https://lp.logrocket.com/blg/node-signup" target="_blank" rel="noopener noreferrer"><img src="../Images/cae72fd2a54c5f02a6398c4867894844.png" alt="LogRocket Network Request Monitoring" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2019/12/network-request-filter-2-1.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" class=" jetpack-lazy-image" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/12/network-request-filter-2-1.png"/><noscript><img data-lazy-fallback="1" src="../Images/cae72fd2a54c5f02a6398c4867894844.png" alt="LogRocket Network Request Monitoring" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/12/network-request-filter-2-1.png"/></noscript></a><a href="https://lp.logrocket.com/blg/node-signup" target="_blank" rel="noopener noreferrer">https://logrocket.com/signup/</a><p>LogRocket 就像是网络和移动应用程序的DVR，记录下用户与你的应用程序交互时发生的一切。您可以汇总并报告有问题的网络请求，以快速了解根本原因，而不是猜测问题发生的原因。</p><p>LogRocket检测您的应用程序以记录基线性能计时，如页面加载时间、到达第一个字节的时间、慢速网络请求，还记录Redux、NgRx和Vuex操作/状态。</p><a class="signup" href="https://lp.logrocket.com/blg/node-signup" target="_blank" rel="noopener noreferrer">Start monitoring for free</a><p>. </p></div>
</div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
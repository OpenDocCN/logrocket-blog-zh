<html>
<head>
<title>The upsides of prop drilling in React - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>React - LogRocket博客中的支柱钻井的优点</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/the-upsides-of-prop-drilling-in-react/#0001-01-01">https://blog.logrocket.com/the-upsides-of-prop-drilling-in-react/#0001-01-01</a></blockquote><div><article class="article-post">
<h2>支柱钻孔介绍</h2>
<p>在使用React时，总是需要与不同的组件共享数据。这可以通过最基本的方式实现，即使用支柱钻孔。正确钻孔允许组件之间的单向数据共享。以道具形式传递或共享的数据。</p>
<p>让我们考虑下图:</p>
<p><img data-attachment-id="30651" data-permalink="https://blog.logrocket.com/the-upsides-of-prop-drilling-in-react/props-drilling/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/12/props-drilling.png" data-orig-size="638,359" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="props-drilling" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/12/props-drilling-300x169.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/12/props-drilling.png" decoding="async" class="aligncenter wp-image-30651 jetpack-lazy-image" src="../Images/566a8e9098ece17f9d0eb2f0dcdcd547.png" alt="A diagram explaining how props drilling works." data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2020/12/props-drilling.png 638w, https://blog.logrocket.com/wp-content/uploads/2020/12/props-drilling-300x169.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2020/12/props-drilling.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/12/props-drilling.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="30651" data-permalink="https://blog.logrocket.com/the-upsides-of-prop-drilling-in-react/props-drilling/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/12/props-drilling.png" data-orig-size="638,359" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="props-drilling" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/12/props-drilling-300x169.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/12/props-drilling.png" decoding="async" loading="lazy" class="aligncenter wp-image-30651" src="../Images/566a8e9098ece17f9d0eb2f0dcdcd547.png" alt="A diagram explaining how props drilling works." srcset="https://blog.logrocket.com/wp-content/uploads/2020/12/props-drilling.png 638w, https://blog.logrocket.com/wp-content/uploads/2020/12/props-drilling-300x169.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/12/props-drilling.png"/></noscript>
<p> </p>
<p>对于要在C组件中访问的A组件中的数据，它必须作为prop传递给B组件，最后传递给C组件。这就是所谓的线程化。</p>
<p>从上面的解释中，你可以了解什么是支柱钻探的基本知识，以及我们为什么需要它。</p>
<p>现在让我们继续使用我们在上面学到的知识创建一个简单的应用程序。本教程的所有代码都可以在这里找到。</p>
<p>首先，让我们在React应用程序的src文件夹中创建两个文件，分别命名为app.js和name.js。</p>
<p>接下来，我们将下面的代码复制到name.js文件中:</p>
<pre>import React from 'react';
const Name = () =&gt;{
  return(
  &lt;div&gt;
     {/* names should be here*/}
  &lt;/div&gt;
  )
}
export default Name;</pre>
<p>现在，让我们将以下代码添加到app.js文件中:</p>
<pre>import React,{useState} from 'react';
import Name from './Names'
const App = () =&gt;{
  const [data , setData] = useState([
    {
     name:'Ijeoma Belinda',
     age: 13,
    },
    {
     name:'Ozioko Chioma',
     age: 17,
    }
  ])
  return(
    &lt;Name data = {data} /&gt;
  )
}
export default App;</pre>
<p>注意，我们需要在<code>name.js</code>中显示的数据作为一种状态存储在<code>app.js</code>文件中。为了将它作为道具传递下去，我们需要将第16行中的代码替换为:</p>
<pre>&lt;Name data = {data} /&gt;</pre>
<p>现在，我们可以在name.js文件中使用它，如下所示:</p>
<pre>import React from 'react';
const Name = (props) =&gt;{
  return(
  &lt;div&gt;
      {props.data.map( unitData =&gt; &lt;h1&gt;{unitData.name}&lt;/h1&gt;)}
  &lt;/div&gt;
  )
}
export default Name;</pre>
<p>app.js和name.js的最终代码应该如下所示:</p>
<pre>import React,{useState} from 'react';
import Name from './Names'
const App = () =&amp;gt;{
  const [data , setData] = useState([
    {
     name:'Ijeoma Belinda',
     age: 13,
    },
    {
     name:'Ozioko Chioma',
     age: 17,
    }
  ])
  return(
    &amp;lt;Name data = {data} /&amp;gt;
  )
}
export default App;</pre>
<p>下面的name.js文件:</p>
<pre>import React from 'react';
const Name = (props) =&gt;{
  return(
  &lt;div&gt;
      {props.data.map( unitData =&gt; &lt;h1&gt;{unitData.name}&lt;/h1&gt;)}
  &lt;/div&gt;
  )
}
export default Name;</pre>
<p>注意<code>props</code>是作为参数添加到功能组件中的。</p>
<p>如果一切都做得正确，存储在状态中的数据现在应该显示在浏览器中。</p>
<h3>支柱钻井的好处</h3>
<p>在处理小型应用程序时，prop drilling可以作为一种快速简便的组件间数据传输方法。与其他常见的数据传输方法不同，prop drilling相对容易学习和实施。</p>
<p>除此之外，作为道具传递的数据可以很容易地在状态改变时更新，以反映新的变化。</p>
<p>为了更好地理解这一点，让我们回到app.js文件，用新用户的数据更新状态，如下所示:</p>
<pre>import React,{useState , useEffect} from 'react';
import Name from './Names'
const App = () =&gt;{
  const [data , setData] = useState([
    {
     name:'Ijeoma Belinda',
     age: 13 },
      {
     name:'Ozioko Chioma',
     age: 17
    }
  ])
  useEffect(() =&gt; {
   setData([
   ...data,
    {
      name:'Eze ifechi',
      age: 17,
     }
  ])
  },[])
  return(
    &lt;Name data = {data} /&gt;
  )
}
export default App;</pre>
<p>您会注意到，浏览器中呈现的页面会立即更新以反映新的更改，而无需添加任何额外的代码或逻辑。</p>
<h3>支柱钻井的缺点</h3>
<p>道具钻井确实有其缺点，在某些情况下，它不值得。随着您的代码库的增加，适当的调整会使您的代码变得过于复杂，而且随着代码的增加，情况只会变得更糟。</p>
<p>除此之外，props可以被传递给不一定需要它的组件，只是为了让数据到达子组件，导致代码库不必要的增加。</p>
<p>为了演示这一点，让我们通过添加一个名为singleName.js的新文件来调整我们的代码，然后在我们的Name.js文件中呈现它，如下所示:</p>
<pre>import React from 'react';
import SingleName from './singleName'
const Name = (props) =&gt;{
  return(
  &lt;div&gt;
      {props.data.map( unitData =&gt; &lt;SingleName unitData = {unitData} /&gt;)}
  &lt;/div&gt;
  )
}
export default Name;</pre>
<p>接下来，让我们将以下代码添加到我们的新文件(<code>singleName.js</code>)中:</p>
<pre>import React from 'react';
const SingleName = (props) =&gt;{
  return(
  &lt;div&gt;
      &lt;h1&gt;{props.data.name}&lt;/h1&gt;
  &lt;/div&gt;
  )
}
export default SingleName;</pre>
<p>请注意，数据被传递到name.js文件，即使它并不需要，以便它到达子组件，在本例中是singleName.js。</p>
<p>随着代码库的增加，跟踪道具名称可能会变得很困难，尤其是在线程中途道具被重命名的情况下。</p>
<p>如果你遇到这种情况，可能很难解决。</p>
<h2><strong>如何解决这些问题</strong></h2>
<p>首先要做的就是少用元件。避免添加不必要的组件，这些组件需要适当的训练来防止代码库变得太大。</p>
<p>现在，重要的是要注意，这并不意味着你应该把你的代码浓缩到只有一个组件。但是，可能有一种情况，你真的不需要增加一个额外的组件。在这种情况下，请记住，您不希望代码过于复杂。</p><div class="code-block code-block-54">
<hr/>
<h3>更多来自LogRocket的精彩文章:</h3>

<hr/></div>
<p>你可以做的另一件事是总是使用一个默认的道具名，这样就很容易跟踪它。</p>
<p>在您的应用中，除了适当的钻孔，您还可以使用其他替代方法。在应用程序的几乎所有部分都需要您的数据的情况下，您可以使用上下文API。Context API可以为您的应用程序的不同部分提供您需要的所有数据，而没有prop drilling带来的所有复杂性。</p>
<h2>结论</h2>
<p>正确钻孔，即使有其缺点，仍然是组件之间数据传输的可行方法，应该用于相对较小的应用。但是，在处理较大的应用程序时，不建议将它作为主要的数据传输方法。</p><div class="code-block code-block-17">
<div class="blog-plug inline-plug react-plug" vwo-el-id="26283398190">
<h2 vwo-el-id="41600691720">使用LogRocket消除传统反应错误报告的噪音</h2>
<a href="https://lp.logrocket.com/blg/react-signup-issue-free" target="_blank" vwo-el-id="19356441070">LogRocket
</a><p>是一款React analytics解决方案，可保护您免受数百个误报错误警报的影响，只针对少数真正重要的项目。LogRocket告诉您React应用程序中实际影响用户的最具影响力的bug和UX问题。</p><a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="19356441380">
<img class="first-react-image alignnone size-full wp-image-46 jetpack-lazy-image jetpack-lazy-image--handled" src="../Images/f300c244a1a1cf916df8b4cb02bec6c6.png" vwo-el-id="18272717540" data-lazy-loaded="1" data-original-src="https://files.readme.io/27c94e7-Image_2017-06-05_at_9.46.04_PM.png"/>
</a>
<a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="19356441690">
<img class="second-react-image alignnone size-full wp-image-46 jetpack-lazy-image jetpack-lazy-image--handled" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" vwo-el-id="30720362350" data-lazy-loaded="1" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/>
</a>
<a href="https://lp.logrocket.com/blg/react-signup-issue-free" target="_blank" rel="noopener noreferrer" vwo-el-id="35866400580">LogRocket
</a><p>自动聚合客户端错误、反应错误边界、还原状态、缓慢的组件加载时间、JS异常、前端性能指标和用户交互。然后，LogRocket使用机器学习来通知您影响大多数用户的最具影响力的问题，并提供您修复它所需的上下文。</p><p vwo-el-id="28675661060">关注重要的React bug—<a class="signup" href="https://lp.logrocket.com/blg/react-signup-issue-free" target="_blank" rel="noopener noreferrer" vwo-el-id="40093418840">今天就试试LogRocket】。</a></p>
</div></div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
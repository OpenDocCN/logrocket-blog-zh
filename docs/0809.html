<html>
<head>
<title>Implementing built-in JavaScript methods from scratch - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>从头开始实现内置的JavaScript方法</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/implementing-built-in-javascript-methods-from-scratch/#0001-01-01">https://blog.logrocket.com/implementing-built-in-javascript-methods-from-scratch/#0001-01-01</a></blockquote><div><article class="article-post">
<p>JavaScript充满了许多内置方法，这些方法有助于在一行代码中完成大量任务。</p>
<p>您可能在项目中使用过它们，但不知道它们是如何工作的。这篇文章是关于研究这些函数的。</p>
<p>我在采访中看到很多公司都要求从头实现这些功能，所以这就是我们要做的！我们将采用一组您几乎每天都会用到的内置JavaScript函数，并从头开始实现它们。</p>
<p>我相信这样做也会让你更有信心像专业人士一样使用这些功能。</p>
<h2>地图</h2>
<p>好老图是高阶函数。它遍历给定数组的元素，对每个元素应用转换函数，将元素添加到新数组中，并返回新数组。</p>
<p>这是函数式编程工具箱中最有用的函数之一。</p>
<p>关于map需要注意的重要一点是，它允许您在不修改原始列表的情况下转换整个值列表。</p>
<p>这就是所有神奇的事情发生的过程:</p>
<pre>const Map = (array, fn) =&gt; {
 const answer = [];
 for (let i = 0; i &lt; array.length; i++) {
   answer.push(fn(array[i]));
 }
 return answer;
};</pre>
<h2>减少</h2>
<p>当您有一个值列表，并希望以一种有意义的方式组合成一个值时，Reduce是一个非常有用的函数。</p>
<p>reduce函数迭代给定数组的所有值，并返回单个值。</p>
<p>它不像map那样返回新的数组。Reduce输出单个值，可以是数字、字符串或对象。</p>
<p>让我们看看reduce是如何工作的:</p>
<pre>const Reduce = (list, fn, seed) =&gt; {
 let result = seed;
 for (let i = 0; i &lt; list.length; i++) {
   result = fn(answer, list[i]);
 }
 return result;
};</pre>
<p>因此，reduce包含一个调用它的列表、一个reducing函数、一个累加器和一个种子值。</p>
<p>累加器是一个临时/中间结果，保存reducer函数返回的值。返回值再次传递给下一个reducer函数，该函数对数组中的下一个值运行。</p>
<p>种子值是累加器的第一个值。</p>
<p>如果没有传递种子值，列表中的第一个元素将作为种子。</p>
<pre>const list = [1,2,3];
list.reduce(function(accumulator, number) {
   return accumulator + number;
});
// returns 6 since 1 becomes the seed</pre>
<h2>过滤器</h2>
<p>Filter就像它的名字一样。它返回从原始数组中筛选出的新元素数组。</p>
<p>我们只需要写一个函数，如果我们想在列表中保留当前项，返回true，否则返回false。</p>
<pre>const Filter = (list, fn) =&gt; {
 const result = [];
 for (let i = 0; i &lt; list.length; i++) {
   if (fn(list[i])) {
     result.push(list[i]);
   }
 }
 return result;
};</pre>
<p>下面是我们如何使用它来过滤掉给定数组中的所有奇数:</p>
<pre>const filterOddOnesOut = nums =&gt; nums.filter( num =&gt; num % 2 ===</pre>
<h2>去抖</h2>
<p>如果您曾经考虑过实现自动完成或键入，您可能已经使用过去抖。这是一种在用户打字时限制网络调用数量的方法。</p><div class="code-block code-block-54">
<hr/>
<h3>更多来自LogRocket的精彩文章:</h3>

<hr/></div>
<p>让我们从头开始实现它:</p>
<pre>const debounce = (fn, time) =&gt; {
 let setTimeoutId;

 return function() {
     if(setTimeoutId) {
       clearTimeout(setTimeoutId);
     }

     setTimeoutId = setTimeout(() =&gt; {
       fn.apply(this, arguments);
       setTimeoutId = null;
     }, time);
 }
}</pre>
<p>现在，当用户输入时，假设我们连续调用去抖函数:</p>
<pre>debounce(someFunction, 500);
debounce(someFunction, 500);
debounce(someFunction, 500);</pre>
<p>只有最后一个会被执行，因为如果在超时前调用了新的，那么<code>clearTimeout</code>会取消前面的。</p>
<h2>约束</h2>
<p>对于JavaScript，我们经常需要与作用域进行交互，尤其是当我们使用React时。</p>
<p>范围本质上是我们操作的环境和所有对我们可用的东西。一般来说，像<code>call</code>和<code>apply</code>这样的函数是用来改变JavaScript中当前的执行范围的。</p>
<p>这两种方法不仅改变范围，而且立即执行给定的函数。使用bind，我们仍然改变了作用域，但是返回了一个以后可以调用的函数。</p>
<p>让我们看看如何从头开始编写bind。</p>
<p>我们将使用call方法来实现这一点:</p>
<pre>const bind = (fn, context) =&gt; {
    return function () {
       fn.call(context);
    }
}</pre>
<h2>分类</h2>
<p>sort函数从给定的数组中返回一个排序后的数组。让我们看看排序是如何工作的。</p>
<p>为此，我们将使用合并排序算法。当我们调用<code>Array.prototype.sort</code>时，它经常在后台使用归并排序。</p>
<p>合并排序是一种分治算法。在这个算法中，我们基本上接受一个列表，把它分成两半，然后递归地调用合并排序，这反过来也做同样的事情。</p>
<p>基本情况是我们只有一个元素的列表。在这种情况下，我们只需返回列表。</p>
<p>当您逐步完成递归调用时，我们将两个排序列表合并在一起:</p>
<pre>const mergeSort = list =&gt; {
// base case
 if (list.length &lt; 2) {
   return list;
 }
 const length = list.length;
 const middle = Math.floor(length / 2);
 const left = list.slice(0, middle);
 const right = list.slice(middle);

 return merge(mergeSort(left), mergeSort(right));
};
const merge = (left, right) =&gt; {

 const results = [];

 while (left.length &amp;&amp; right.length) {
  
   if (left[0] &lt;= right[0]) {
     results.push(left.shift());
   }
   else {
     results.push(right.shift());
   }
 }

 return results.concat(left, right);
};</pre>
<p>如您所见，我们有一个合并函数，它遍历左侧和右侧的列表，首先插入较小的值，从而得到一个较大的排序列表。</p>
<h2>结论</h2>
<p>所有这些内置的JavaScript方法都非常强大。通过从头开始重新实现它们，我们可以更好地有效使用它们。</p><div class="code-block code-block-27">
<div class="blog-plug inline-plug vanilla-javascript-cta"><h2>通过理解上下文，更容易地调试JavaScript错误</h2>
<p>调试代码总是一项单调乏味的任务。但是你越了解自己的错误，就越容易改正。</p>
<p>LogRocket 让你以新的独特的方式理解这些错误。我们的前端监控解决方案跟踪用户与您的JavaScript前端的互动，让您能够准确找出导致错误的用户行为。</p>
<a href="https://lp.logrocket.com/blg/javascript-signup" class="signup" target="_blank" rel="noopener noreferrer"><img class="alignnone size-full wp-image-46 jetpack-lazy-image" src="../Images/cbfed9be3defcb505e662574769a7636.png" alt="LogRocket Dashboard Free Trial Banner" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2020/06/reproduce-javascript-errors.gif?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/06/reproduce-javascript-errors.gif"/><noscript><img data-lazy-fallback="1" class="alignnone size-full wp-image-46" src="../Images/cbfed9be3defcb505e662574769a7636.png" alt="LogRocket Dashboard Free Trial Banner" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/06/reproduce-javascript-errors.gif"/></noscript></a>
<p>LogRocket记录控制台日志、页面加载时间、堆栈跟踪、慢速网络请求/响应(带有标题+正文)、浏览器元数据和自定义日志。理解您的JavaScript代码的影响从来没有这么简单过！</p>
<a class="signup" href="https://lp.logrocket.com/blg/javascript-signup" target="_blank" rel="noopener noreferrer">Try it for free</a><p>.</p></div>


</div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
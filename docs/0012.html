<html>
<head>
<title>Building an offline-first app with React and RxDB - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>用React和RxDB - LogRocket博客构建离线优先应用</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/building-an-offline-first-app-with-react-and-rxdb-e97a1fa64356/#0001-01-01">https://blog.logrocket.com/building-an-offline-first-app-with-react-and-rxdb-e97a1fa64356/#0001-01-01</a></blockquote><div><article class="article-post">
<figure><img decoding="async" src="../Images/10c65bf3600005a1704c39768bdbb319.png" data-height="1328" data-width="3840" data-lazy-src="https://storage.googleapis.com/blog-images-backup/1*PqUmB3Ei8URSOiAKaO8heA.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" class=" jetpack-lazy-image" data-original-src="https://storage.googleapis.com/blog-images-backup/1*PqUmB3Ei8URSOiAKaO8heA.png"/><noscript><img data-lazy-fallback="1" decoding="async" src="../Images/10c65bf3600005a1704c39768bdbb319.png" data-height="1328" data-width="3840" data-original-src="https://storage.googleapis.com/blog-images-backup/1*PqUmB3Ei8URSOiAKaO8heA.png"/></noscript></figure>
<p>离线功能正成为应用程序用户体验中越来越重要的一部分。这不仅对于离线运行的应用程序很重要，对于在间歇性互联网连接下运行的web或移动JavaScript应用程序也很重要。</p>
<p>让一个应用程序在没有互联网连接的情况下工作包括两件事。首先，应用程序文件需要存储在本地。这可以通过<a href="https://developers.google.com/web/progressive-web-apps/" target="_blank" rel="noopener noreferrer">渐进式网络应用</a>和<a href="https://developers.google.com/web/fundamentals/getting-started/primers/service-workers" target="_blank" rel="noopener noreferrer">服务人员</a>来完成。</p>
<p>其次，必须使用某种形式的本地存储作为应用程序的主要数据源。此存储必须与远程数据源持续同步。幸运的是，有像<a href="http://pouchdb.com/" target="_blank" rel="noopener noreferrer"> PouchDB </a>这样的数据库，它们在本地存储数据，并且可以自动与服务器中的<a href="http://couchdb.apache.org/" target="_blank" rel="noopener noreferrer"> CouchDB </a>数据库同步。</p>
<p>在本教程中，我们将构建一个具有离线功能的匿名聊天应用程序。它看起来会像这样:</p>
<figure><img decoding="async" src="../Images/d1602eaa3d522e436135024c2602038e.png" data-height="500" data-width="800" data-lazy-src="https://storage.googleapis.com/blog-images-backup/1*_j6ng7S-s5e5ffdBVeUPEQ.gif?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" class=" jetpack-lazy-image" data-original-src="https://storage.googleapis.com/blog-images-backup/1*_j6ng7S-s5e5ffdBVeUPEQ.gif"/><noscript><img data-lazy-fallback="1" decoding="async" src="../Images/d1602eaa3d522e436135024c2602038e.png" data-height="500" data-width="800" data-original-src="https://storage.googleapis.com/blog-images-backup/1*_j6ng7S-s5e5ffdBVeUPEQ.gif"/></noscript></figure>
<p>我们将使用<a href="https://github.com/facebookincubator/create-react-app" target="_blank" rel="noopener noreferrer"> Create React App </a>自动生成一个带有React和<a href="https://github.com/pubkey/rxdb" target="_blank" rel="noopener noreferrer"> RxDB </a>的<a href="https://github.com/facebookincubator/create-react-app/blob/master/packages/react-scripts/template/README.md#making-a-progressive-web-app" target="_blank" rel="noopener noreferrer">渐进式web应用</a>，这是一个反应式、客户端和离线优先的数据库，将与服务器端CouchDB数据库同步。</p>
<p>您将需要:</p>
<ul>
<li>节点版本6或更高版本。可以使用<a href="https://github.com/creationix/nvm#installation" target="_blank" rel="noopener noreferrer"> nvm </a>在节点版本之间切换。</li>
<li>支持<a href="http://caniuse.com/#feat=indexeddb" target="_blank" rel="noopener noreferrer"> IndexedDB </a>的现代浏览器。</li>
</ul>
<p>作为参考，您可以在以下GitHub资源库中找到的完整源代码:</p>
<blockquote class="embedly-card" data-card-controls="1" data-card-align="center" data-card-theme="light">

<p>一个简单的匿名聊天应用程序，展示了如何使用React和RxDB创建离线应用程序，使用本地IndexedDB数据库。这个项目是用Create React App引导的。节点版本6或更高版本。您可以使用nvm在节点版本之间切换。支持IndexedDB的现代浏览器。</p>
</blockquote>
<p>设置React应用程序</p>
<figure><a href="https://logrocket.com/signup/" target="_blank" rel="noopener noreferrer"><img decoding="async" src="../Images/94b3e0f84b30cb0d321f60471481ab64.png" data-height="750" data-width="3212" data-lazy-src="https://storage.googleapis.com/blog-images-backup/1*GPjaPKNNUYHU8EsA3Z0JGA.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" class=" jetpack-lazy-image" data-original-src="https://storage.googleapis.com/blog-images-backup/1*GPjaPKNNUYHU8EsA3Z0JGA.png"/><noscript><img data-lazy-fallback="1" decoding="async" src="../Images/94b3e0f84b30cb0d321f60471481ab64.png" data-height="750" data-width="3212" data-original-src="https://storage.googleapis.com/blog-images-backup/1*GPjaPKNNUYHU8EsA3Z0JGA.png"/></noscript></a></figure>
<h3>安装(或升级至最新版本)<code>create-react-app</code>:</h3>
<p>然后，创建一个新的应用程序并<code>cd</code>进入其中:</p>
<pre>npm install -g create-react-app</pre>
<p>现在，让我们通过执行以下命令来安装项目的所有依赖项:</p>
<pre>create-react-app offline-anonymous-chat
cd offline-anonymous-chat</pre>
<p>下面是对每个依赖项的描述:</p>
<pre>npm install --save concurrently moment pouchdb-adapter-http pouchdb-adapter-idb pouchdb-server react-toastify rxdb rxjs serve</pre>
<p><a href="https://www.npmjs.com/package/concurrently" target="_blank" rel="noopener noreferrer">兼</a>。我们将需要它同时运行两个npm脚本。</p>
<ul>
<li><a href="https://www.npmjs.com/package/moment" target="_blank" rel="noopener noreferrer">时刻</a>。我们将需要它来格式化消息的创建日期。</li>
<li><a href="https://www.npmjs.com/package/pouchdb-adapter-http" target="_blank" rel="noopener noreferrer"> pouchdb-adapter-http </a>。PouchDB适配器，用于与外部CouchDB(或类似CouchDB的)数据库通信。</li>
<li><a href="https://www.npmjs.com/package/pouchdb-adapter-idb" target="_blank" rel="noopener noreferrer"> pouchdb-adapter-idb </a>。PouchDB适配器在浏览器中使用IndexedDB。只需切换适配器，就可以在不同的环境中使用PouchDB(和RxDB)。</li>
<li><a href="https://github.com/pouchdb/pouchdb-server" target="_blank" rel="noopener noreferrer"> pouchdb-server </a>。这将作为我们的服务器端数据库。</li>
<li><a href="https://www.npmjs.com/package/react-toastify" target="_blank" rel="noopener noreferrer">反应-适应</a>。我们需要它在应用程序中显示数据库事件的通知。</li>
<li><a href="https://github.com/pubkey/rxdb" target="_blank" rel="noopener noreferrer"> rxdb </a>。这将作为我们的客户端数据库。</li>
<li><a href="https://github.com/ReactiveX/rxjs" target="_blank" rel="noopener noreferrer"> rxjs </a>。RxDB以被动的方式处理数据，因此它依赖于rxjs。</li>
<li><a href="https://www.npmjs.com/package/serve" target="_blank" rel="noopener noreferrer">发球</a>。当测试离线功能时，我们需要一个HTTP服务器来为我们的应用程序提供服务(稍后将详细介绍)。</li>
<li>接下来，编辑<code>package.json</code>文件中的<code>start</code>脚本。而不是:</li>
</ul>
<p>应该是:</p>
<pre>"start": "react-scripts start",</pre>
<p>此外，我们应该添加<code>server</code>脚本:</p>
<pre>"start": "concurrently "npm run server" "react-scripts start"",</pre>
<p>这将在应用程序运行的同时执行PouchDB服务器。数据库文件将存储在<code>db</code>目录中。你可以在这里找到数据库服务器<a href="https://github.com/pouchdb/pouchdb-server#full-options" target="_blank" rel="noopener noreferrer">的所有配置选项。</a></p>
<pre>"server": "pouchdb-server -d ./db",</pre>
<p>执行<code>npm start</code>时，可以去<a href="http://localhost:3000/" target="_blank" rel="noopener noreferrer"> http://localhost:3000 </a>(如果不是自动打开的话)查看<code>create-react-app</code>生成的app:</p>
<p>对于数据库，可以打开<a href="http://localhost:5984/_utils" target="_blank" rel="noopener noreferrer">http://localhost:5984/_ utils</a>查看其web界面(<a href="https://github.com/apache/couchdb-fauxton" target="_blank" rel="noopener noreferrer"> Fauxton </a>):</p>
<figure><img decoding="async" src="../Images/a3c3c47fd1029194157ca3cba41699b5.png" data-height="800" data-width="1280" data-lazy-src="https://storage.googleapis.com/blog-images-backup/1*Z8H9D3IV7CJJGxxCbR3hEg.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" class=" jetpack-lazy-image" data-original-src="https://storage.googleapis.com/blog-images-backup/1*Z8H9D3IV7CJJGxxCbR3hEg.png"/><noscript><img data-lazy-fallback="1" decoding="async" src="../Images/a3c3c47fd1029194157ca3cba41699b5.png" data-height="800" data-width="1280" data-original-src="https://storage.googleapis.com/blog-images-backup/1*Z8H9D3IV7CJJGxxCbR3hEg.png"/></noscript></figure>
<p>如您所见，只创建了两个供PouchDB内部使用的数据库。</p>
<figure><img decoding="async" src="../Images/496111a9eb6a24d827cffeac161b0889.png" data-height="800" data-width="1280" data-lazy-src="https://storage.googleapis.com/blog-images-backup/1*Nv-JKFQs1sBurlxBkGXebQ.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" class=" jetpack-lazy-image" data-original-src="https://storage.googleapis.com/blog-images-backup/1*Nv-JKFQs1sBurlxBkGXebQ.png"/><noscript><img data-lazy-fallback="1" decoding="async" src="../Images/496111a9eb6a24d827cffeac161b0889.png" data-height="800" data-width="1280" data-original-src="https://storage.googleapis.com/blog-images-backup/1*Nv-JKFQs1sBurlxBkGXebQ.png"/></noscript></figure>
<p>在下一节中，我们将为应用程序数据库创建模式。</p>
<p>创建数据库模式</p>
<h3>RxDB依赖于PouchDB(反过来，受CouchDB的启发)，这使它成为一个<a href="https://en.wikipedia.org/wiki/NoSQL" target="_blank" rel="noopener noreferrer"> NoSQL </a>文档数据库，类似于<a href="https://www.mongodb.com" target="_blank" rel="noopener noreferrer"> MongoDB </a>。</h3>
<p>我们可以使用模式来定义数据的外观，并验证每个插入的文档。数据被组织成集合，每个集合都有自己的模式。</p>
<p>对于我们的应用程序，我们将使用一个名为<code>messages</code>的集合来存储消息的创建日期和消息本身。</p>
<p>模式是使用<a href="http://json-schema.org/" target="_blank" rel="noopener noreferrer"> JSON模式</a>标准定义的。出于我们的目的，用下面的<a href="https://jsfiddle.net/eh3rrera/Lj35tx2y/" target="_blank" rel="noopener noreferrer">内容</a>创建文件<code>src/Schema.js</code>:</p>
<p>在上面的模式中:</p>
<figure/>
<p>版本号为零。如果版本大于零，您必须提供一个<a href="https://pubkey.github.io/rxdb/data-migration.html" target="_blank" rel="noopener noreferrer">数据迁移策略</a>。</p>
<ul>
<li>它有两个类型为<code>string</code>、<code>id</code>和<code>message</code>的属性。第一个是主键，它表示消息插入的日期，即从<a href="https://en.wikipedia.org/wiki/Unix_time" target="_blank" rel="noopener noreferrer"> Unix纪元</a>以来的毫秒数。</li>
<li>属性<code>message</code>是必需的。</li>
<li>你可以在这里了解更多关于模式的信息。</li>
</ul>
<p>现在让我们配置本地数据库。</p>
<p>配置本地数据库</p>
<h3>将进口后的<a href="https://jsfiddle.net/eh3rrera/xLfxad7c/" target="_blank" rel="noopener noreferrer">添加到<code>App.js</code>:</a></h3>
<p>除了导入主RxDB模块和上一节中创建的模式之外，我们还要导入模块<code>QueryChangeDetector</code>。</p>
<figure/>
<p>由于RxDB是一个反应式数据库，您可以订阅查询以实时接收新结果，但每次执行查询都会影响性能，因此选项<code>QueryChangeDetector</code>通过从数据库事件中获取新结果来优化观察到的查询。</p>
<p>该选项目前处于测试阶段，默认情况下是禁用的，但是我们可以使用下面的<a href="https://jsfiddle.net/eh3rrera/74mjvqbc/" target="_blank" rel="noopener noreferrer">代码</a>来启用它:</p>
<p>使用JSFiddle代码编辑器在线测试您的JavaScript、CSS、HTML或CoffeeScript。</p>
<blockquote class="embedly-card" data-card-controls="1" data-card-align="center" data-card-theme="light">

<p>Test your JavaScript, CSS, HTML or CoffeeScript online with JSFiddle code editor.</p>
</blockquote>
<p> </p>
<p>我们还可以启用调试，这样每次进行优化时，都会在控制台中显示一条消息。</p>
<figure/>
<p>接下来，将适配器配置为使用IndexDB作为存储引擎，并支持通过<a href="https://jsfiddle.net/eh3rrera/em9bxtdv/" target="_blank" rel="noopener noreferrer"> HTTP </a>同步到远程数据库:</p>
<p>并将远程数据库的URL和本地数据库的名称声明为常量:</p>
<figure/>
<p>使用JSFiddle代码编辑器在线测试您的JavaScript、CSS、HTML或CoffeeScript。</p>
<blockquote class="embedly-card" data-card-controls="1" data-card-align="center" data-card-theme="light">

<p>Test your JavaScript, CSS, HTML or CoffeeScript online with JSFiddle code editor.</p>
</blockquote>
<p>在类内部，让我们声明一个方法来创建<a href="https://jsfiddle.net/eh3rrera/3nah0syf/" target="_blank" rel="noopener noreferrer">数据库</a>:</p>
<figure/>
<p>使用JSFiddle代码编辑器在线测试您的JavaScript、CSS、HTML或CoffeeScript。</p>
<blockquote class="embedly-card" data-card-controls="1" data-card-align="center" data-card-theme="light">

<p>Test your JavaScript, CSS, HTML or CoffeeScript online with JSFiddle code editor.</p>
</blockquote>
<p>数据库是以异步方式创建的，但是我们将使用<a href="https://hackernoon.com/6-reasons-why-javascripts-async-await-blows-promises-away-tutorial-c7ec10518dd9" target="_blank" rel="noopener noreferrer"> async/await </a>来获得更简洁的代码，而不是使用回调或承诺。这里有一篇很好的<a href="https://ponyfoo.com/articles/understanding-javascript-async-await" target="_blank" rel="noopener noreferrer">文章</a>，比较了编写异步代码的三种方法。</p>
<figure/>
<p>这样，我们创建数据库，传递一个名称、适配器和一个<a href="https://jsfiddle.net/eh3rrera/ev02qzup/" target="_blank" rel="noopener noreferrer">密码</a>(必须至少有8个字符):</p>
<p>使用JSFiddle代码编辑器在线测试您的JavaScript、CSS、HTML或CoffeeScript。</p>
<blockquote class="embedly-card" data-card-controls="1" data-card-align="center" data-card-theme="light">

<p>Test your JavaScript, CSS, HTML or CoffeeScript online with JSFiddle code editor.</p>
</blockquote>
<p>接下来，我们启用<a href="https://pubkey.github.io/rxdb/LeaderElection.html" target="_blank" rel="noopener noreferrer"> leader-election </a>算法，该算法确保始终只有一个选项卡管理远程数据访问(以防应用程序同时有多个选项卡)。当选领导人后，页面标题旁边的<a href="https://jsfiddle.net/eh3rrera/pmrwr1xs/" target="_blank" rel="noopener noreferrer">将显示</a>一个皇冠:</p>
<figure/>
<p>使用JSFiddle代码编辑器在线测试您的JavaScript、CSS、HTML或CoffeeScript。</p>
<blockquote class="embedly-card" data-card-controls="1" data-card-align="center" data-card-theme="light">

<p>Test your JavaScript, CSS, HTML or CoffeeScript online with JSFiddle code editor.</p>
</blockquote>
<p>然后，我们通过<a href="https://jsfiddle.net/eh3rrera/0szL2atb/" target="_blank" rel="noopener noreferrer">模式</a>创建<code>messages</code>集合:</p>
<figure/>
<p>使用JSFiddle代码编辑器在线测试您的JavaScript、CSS、HTML或CoffeeScript。</p>
<blockquote class="embedly-card" data-card-controls="1" data-card-align="center" data-card-theme="light">

<p>Test your JavaScript, CSS, HTML or CoffeeScript online with JSFiddle code editor.</p>
</blockquote>
<p>更多来自LogRocket的精彩文章:</p><div class="code-block code-block-54">
<hr/>
<h3>最后，让我们设置复制特性并返回数据库<a href="https://jsfiddle.net/eh3rrera/y1s8okju/" target="_blank" rel="noopener noreferrer">对象</a>:</h3>

<hr/></div>
<figure/>
<p>使用JSFiddle代码编辑器在线测试您的JavaScript、CSS、HTML或CoffeeScript。</p>
<blockquote class="embedly-card" data-card-controls="1" data-card-align="center" data-card-theme="light">

<p>Test your JavaScript, CSS, HTML or CoffeeScript online with JSFiddle code editor.</p>
</blockquote>
<p>现在让我们将这个方法集成到我们的React应用程序中。</p>
<figure/>
<p>构建应用程序</p>
<h3>让我们从添加组件的导入开始，以显示通知和处理<a href="https://jsfiddle.net/eh3rrera/1n7wwhp3/" target="_blank" rel="noopener noreferrer">日期</a>的时刻库:</h3>
<p>使用JSFiddle代码编辑器在线测试您的JavaScript、CSS、HTML或CoffeeScript。</p>
<blockquote class="embedly-card" data-card-controls="1" data-card-align="center" data-card-theme="light">

<p>Test your JavaScript, CSS, HTML or CoffeeScript online with JSFiddle code editor.</p>
</blockquote>
<p>接下来，将下面的<a href="https://jsfiddle.net/eh3rrera/syeetpyf/" target="_blank" rel="noopener noreferrer">构造函数</a>添加到该类中:</p>
<figure/>
<p>使用JSFiddle代码编辑器在线测试您的JavaScript、CSS、HTML或CoffeeScript。</p>
<blockquote class="embedly-card" data-card-controls="1" data-card-align="center" data-card-theme="light">

<p>Test your JavaScript, CSS, HTML or CoffeeScript online with JSFiddle code editor.</p>
</blockquote>
<p>我们有两个属性作为组件的状态，一个用于新消息，一个数组用于存储所有消息。</p>
<figure/>
<p>我们还定义了一个数组来存储我们将要使用的订阅的处理程序，以便我们可以在必要时取消订阅，以及绑定函数来添加新消息和处理新消息的文本框更改。</p>
<p>在<code>componentDidMount</code>中，让我们调用方法<code>createDatabase</code>，然后订阅一个查询，返回按照<code>id</code>排序的所有消息:</p>
<p>使用JSFiddle代码编辑器在线测试您的JavaScript、CSS、HTML或CoffeeScript。</p>
<blockquote class="embedly-card" data-card-controls="1" data-card-align="center" data-card-theme="light">

<p>Test your JavaScript, CSS, HTML or CoffeeScript online with JSFiddle code editor.</p>
</blockquote>
<p>方法<code>$()</code>将返回一个<a href="http://reactivex.io/rxjs/manual/overview.html#observable" target="_blank" rel="noopener noreferrer"> RxJS可观察值</a>，它将查询返回的数据的每一个变化进行流式处理。如果返回任何消息，将显示一个通知，并且状态会发生变化。</p>
<figure/>
<p>注意，我们还添加了对<code>subs</code>数组订阅的引用。这样，当组件将要被卸载时，我们将使用这些引用来取消订阅<a href="https://jsfiddle.net/eh3rrera/17Lnr51e/" target="_blank" rel="noopener noreferrer">观察对象</a>:</p>
<p>使用JSFiddle代码编辑器在线测试您的JavaScript、CSS、HTML或CoffeeScript。</p>
<blockquote class="embedly-card" data-card-controls="1" data-card-align="center" data-card-theme="light">

<p>Test your JavaScript, CSS, HTML or CoffeeScript online with JSFiddle code editor.</p>
</blockquote>
<p>接下来，修改<code>render</code>方法，使其看起来像<a href="https://jsfiddle.net/eh3rrera/qka8apjs/" target="_blank" rel="noopener noreferrer">这个</a>:</p>
<figure/>
<p>使用JSFiddle代码编辑器在线测试您的JavaScript、CSS、HTML或CoffeeScript。</p>
<blockquote class="embedly-card" data-card-controls="1" data-card-align="center" data-card-theme="light">

<p>Test your JavaScript, CSS, HTML or CoffeeScript online with JSFiddle code editor.</p>
</blockquote>
<p>如您所见，渲染逻辑很简单。</p>
<figure/>
<p>方法<code>renderMessages</code>将每个消息对象转换成一个<code>div</code>元素，在<code>moment</code>库(记住<code>id</code>代表以毫秒为单位的日期)和<a href="https://jsfiddle.net/eh3rrera/tsh9yvxu/" target="_blank" rel="noopener noreferrer">消息</a>的帮助下显示消息的相对插入日期:</p>
<p>使用JSFiddle代码编辑器在线测试您的JavaScript、CSS、HTML或CoffeeScript。</p>
<blockquote class="embedly-card" data-card-controls="1" data-card-align="center" data-card-theme="light">

<p>Test your JavaScript, CSS, HTML or CoffeeScript online with JSFiddle code editor.</p>
</blockquote>
<p>这是方法<code>handleMessageChange</code>的<a href="https://jsfiddle.net/eh3rrera/qc2x3360/" target="_blank" rel="noopener noreferrer">定义</a>:</p>
<figure/>
<p>使用JSFiddle代码编辑器在线测试您的JavaScript、CSS、HTML或CoffeeScript。</p>
<blockquote class="embedly-card" data-card-controls="1" data-card-align="center" data-card-theme="light">

<p>Test your JavaScript, CSS, HTML or CoffeeScript online with JSFiddle code editor.</p>
</blockquote>
<p>为了添加消息，我们创建一个对象，并以如下方式将其插入数据库，为下一个<a href="https://jsfiddle.net/eh3rrera/desLds3f/" target="_blank" rel="noopener noreferrer">消息</a>设置状态为空字符串:</p>
<figure/>
<p>使用JSFiddle代码编辑器在线测试您的JavaScript、CSS、HTML或CoffeeScript。</p>
<blockquote class="embedly-card" data-card-controls="1" data-card-align="center" data-card-theme="light">

<p>Test your JavaScript, CSS, HTML or CoffeeScript online with JSFiddle code editor.</p>
</blockquote>
<p>最后，显示复制事件以了解正在发生的事情可能是一个好主意。方法<code>RxCollection.sync()</code>返回一个<a href="https://pubkey.github.io/rxdb/replication.html" target="_blank" rel="noopener noreferrer"> RxReplicationState </a>对象，该对象可用于观察事件和取消复制。</p>
<figure/>
<p>修改方法<code>createDatabase</code>的最后一部分，使其看起来像<a href="https://jsfiddle.net/eh3rrera/ca7559u3/" target="_blank" rel="noopener noreferrer">这个</a>:</p>
<p>使用JSFiddle代码编辑器在线测试您的JavaScript、CSS、HTML或CoffeeScript。</p>
<blockquote class="embedly-card" data-card-controls="1" data-card-align="center" data-card-theme="light">

<p>Test your JavaScript, CSS, HTML or CoffeeScript online with JSFiddle code editor.</p>
</blockquote>
<p>这些事件中的一些会发出一个对象，这就是为什么在某些情况下它们会被打印在控制台中，而不是显示为通知。以下是对每个事件的描述:</p>
<figure/>
<p><code>change$</code>。每次复制文档时触发。它可以发出一个描述变化的布尔值或对象。</p>
<ul>
<li><code>docs$</code>。发出每个复制的文档。</li>
<li><code>active$</code>。根据复制是否正在运行，发出<code>true</code>或<code>false</code>。</li>
<li><code>complete$</code>。根据复制是否完成发出<code>true</code>或<code>false</code>(实际上，只有一次复制会完成)。</li>
<li><code>error$</code>。当复制过程中出现错误时触发。</li>
<li>此外，我们将这些订阅添加到了<code>subs</code>数组中，以便在必要时可以取消订阅。</li>
</ul>
<p>仅此而已。让我们测试一下这个应用程序。</p>
<p>测试应用程序</p>
<h3>执行<code>npm start</code>并转到<code><a href="http://localhost:3000" rel="nofollow">http://localhost:3000</a></code>。您应该会看到类似这样的内容:</h3>
<p>开始添加一些消息。请注意标题中的皇冠，它表示该选项卡是前导选项卡。如果您打开另一个选项卡，并关闭第一个，现在另一个应该有冠:</p>
<figure><img decoding="async" src="../Images/e1ddf3f9578e60c50e79ca9ae68720b1.png" data-height="800" data-width="1280" data-lazy-src="https://storage.googleapis.com/blog-images-backup/1*sdkc_G5mvs4jDqgWRrbYbQ.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" class=" jetpack-lazy-image" data-original-src="https://storage.googleapis.com/blog-images-backup/1*sdkc_G5mvs4jDqgWRrbYbQ.png"/><noscript><img data-lazy-fallback="1" decoding="async" src="../Images/e1ddf3f9578e60c50e79ca9ae68720b1.png" data-height="800" data-width="1280" data-original-src="https://storage.googleapis.com/blog-images-backup/1*sdkc_G5mvs4jDqgWRrbYbQ.png"/></noscript></figure>
<p>由于RxDB的反应性质(以及浏览器中的所有选项卡共享同一本地存储的事实)，数据库状态是实时广播的，这意味着一个选项卡中的更改将自动反映在另一个选项卡中:</p>
<figure><img decoding="async" src="../Images/ccf8b8b7f8244320b21d27beb53afd6f.png" data-height="46" data-width="386" data-lazy-src="https://storage.googleapis.com/blog-images-backup/1*xj2LYZ_liteeRCNakP4Sow.gif?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" class=" jetpack-lazy-image" data-original-src="https://storage.googleapis.com/blog-images-backup/1*xj2LYZ_liteeRCNakP4Sow.gif"/><noscript><img data-lazy-fallback="1" decoding="async" src="../Images/ccf8b8b7f8244320b21d27beb53afd6f.png" data-height="46" data-width="386" data-original-src="https://storage.googleapis.com/blog-images-backup/1*xj2LYZ_liteeRCNakP4Sow.gif"/></noscript></figure>
<p>转到<a href="http://localhost:5984/_utils" target="_blank" rel="noopener noreferrer">http://localhost:5984/_ utils</a>，现在您应该会看到应用程序的数据库:</p>
<figure><img decoding="async" src="../Images/2df2958027ddd8c206f5d634b9e86c33.png" data-height="500" data-width="800" data-lazy-src="https://storage.googleapis.com/blog-images-backup/1*iD-pD3zG3oczgfmI1jvGxg.gif?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" class=" jetpack-lazy-image" data-original-src="https://storage.googleapis.com/blog-images-backup/1*iD-pD3zG3oczgfmI1jvGxg.gif"/><noscript><img data-lazy-fallback="1" decoding="async" src="../Images/2df2958027ddd8c206f5d634b9e86c33.png" data-height="500" data-width="800" data-original-src="https://storage.googleapis.com/blog-images-backup/1*iD-pD3zG3oczgfmI1jvGxg.gif"/></noscript></figure>
<p>单击数据库名称，然后单击其中一个文档的铅笔图标进行编辑:</p>
<figure><img decoding="async" src="../Images/6979b080cc3d3f4460440e7e149cc1ba.png" data-height="800" data-width="1280" data-lazy-src="https://storage.googleapis.com/blog-images-backup/1*Hnfr7k7sghSvfQ6AXDlETw.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" class=" jetpack-lazy-image" data-original-src="https://storage.googleapis.com/blog-images-backup/1*Hnfr7k7sghSvfQ6AXDlETw.png"/><noscript><img data-lazy-fallback="1" decoding="async" src="../Images/6979b080cc3d3f4460440e7e149cc1ba.png" data-height="800" data-width="1280" data-original-src="https://storage.googleapis.com/blog-images-backup/1*Hnfr7k7sghSvfQ6AXDlETw.png"/></noscript></figure>
<p>在数据库web界面上所做的更改应该会立即应用到应用程序中:</p>
<figure><img decoding="async" src="../Images/05a36c893c1ef63b3c10da98759f02d5.png" data-height="800" data-width="1280" data-lazy-src="https://storage.googleapis.com/blog-images-backup/1*kLC431vzt9X4bGWEqT2DJg.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" class=" jetpack-lazy-image" data-original-src="https://storage.googleapis.com/blog-images-backup/1*kLC431vzt9X4bGWEqT2DJg.png"/><noscript><img data-lazy-fallback="1" decoding="async" src="../Images/05a36c893c1ef63b3c10da98759f02d5.png" data-height="800" data-width="1280" data-original-src="https://storage.googleapis.com/blog-images-backup/1*kLC431vzt9X4bGWEqT2DJg.png"/></noscript></figure>
<p>所以它看起来工作正常，但在离线模式下工作吗？</p>
<figure><img decoding="async" src="../Images/de1617a32fbcbc5aff6c51ce718da0e4.png" data-height="500" data-width="800" data-lazy-src="https://storage.googleapis.com/blog-images-backup/1*oZkFMudIeVmwBjkGutaFrg.gif?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" class=" jetpack-lazy-image" data-original-src="https://storage.googleapis.com/blog-images-backup/1*oZkFMudIeVmwBjkGutaFrg.gif"/><noscript><img data-lazy-fallback="1" decoding="async" src="../Images/de1617a32fbcbc5aff6c51ce718da0e4.png" data-height="500" data-width="800" data-original-src="https://storage.googleapis.com/blog-images-backup/1*oZkFMudIeVmwBjkGutaFrg.gif"/></noscript></figure>
<p>离线</p>
<h3>由<code>create-react-app</code>生成的应用程序的生产版本是一个全功能、离线优先的渐进式web应用程序。</h3>
<p>我们必须考虑一些因素，但基本上，我们只需要构建应用程序并为其提供服务。执行:</p>
<p>该命令创建一个包含应用程序生产版本的<code>build</code>目录。</p>
<pre>npm run build</pre>
<p>现在将以下脚本添加到<code>package.json</code>文件中:</p>
<p>并执行:</p>
<pre>"http": "serve -p 3000 -s build",
"offline": "concurrently "npm run server" "npm run http""</pre>
<p>由于该应用程序现在将安装一个服务人员和一个清单，如果你想稍后回到开发版本，你可能需要使用浏览器的匿名模式来测试它，以避免冲突。</p>
<pre>npm run offline</pre>
<p>再次转到<code><a href="http://localhost:3000" rel="nofollow">http://localhost:3000</a></code>，应用程序将安装服务人员，浏览器将缓存文件。如果你使用的是Chrome，你可以进入开发者工具-应用程序，选择清单和/或服务人员部分:</p>
<p>现在，通过从服务人员面板中选择<em>离线</em>选项，从<em>开发者工具</em> ' <em>网络</em>选项卡中选择离线选项，或者直接断开网络连接，即可离线。</p>
<figure><img decoding="async" src="../Images/e5e3782e90b6d6591fc0526f1eb5e681.png" data-height="800" data-width="1280" data-lazy-src="https://storage.googleapis.com/blog-images-backup/1*ZNYbeVeaXra-KOB-a8g7GQ.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" class=" jetpack-lazy-image" data-original-src="https://storage.googleapis.com/blog-images-backup/1*ZNYbeVeaXra-KOB-a8g7GQ.png"/><noscript><img data-lazy-fallback="1" decoding="async" src="../Images/e5e3782e90b6d6591fc0526f1eb5e681.png" data-height="800" data-width="1280" data-original-src="https://storage.googleapis.com/blog-images-backup/1*ZNYbeVeaXra-KOB-a8g7GQ.png"/></noscript></figure>
<p>当您重新加载应用程序时，您仍然可以插入信息:</p>
<p>插入一些消息后，重新联机。过一会儿，您应该会看到一些关于复制的通知:</p>
<figure><img decoding="async" src="../Images/d1602eaa3d522e436135024c2602038e.png" data-height="500" data-width="800" data-lazy-src="https://storage.googleapis.com/blog-images-backup/1*_j6ng7S-s5e5ffdBVeUPEQ.gif?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" class=" jetpack-lazy-image" data-original-src="https://storage.googleapis.com/blog-images-backup/1*_j6ng7S-s5e5ffdBVeUPEQ.gif"/><noscript><img data-lazy-fallback="1" decoding="async" src="../Images/d1602eaa3d522e436135024c2602038e.png" data-height="500" data-width="800" data-original-src="https://storage.googleapis.com/blog-images-backup/1*_j6ng7S-s5e5ffdBVeUPEQ.gif"/></noscript></figure>
<p>如果转到数据库web界面，数据库应该包含新文档:</p>
<figure><img decoding="async" src="../Images/628a63acb0724f7eb96e658cbce28e32.png" data-height="500" data-width="800" data-lazy-src="https://storage.googleapis.com/blog-images-backup/1*Oitdgkr_INW8G7S0UOBC8Q.gif?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" class=" jetpack-lazy-image" data-original-src="https://storage.googleapis.com/blog-images-backup/1*Oitdgkr_INW8G7S0UOBC8Q.gif"/><noscript><img data-lazy-fallback="1" decoding="async" src="../Images/628a63acb0724f7eb96e658cbce28e32.png" data-height="500" data-width="800" data-original-src="https://storage.googleapis.com/blog-images-backup/1*Oitdgkr_INW8G7S0UOBC8Q.gif"/></noscript></figure>
<p>结论</p>
<figure><img decoding="async" src="../Images/d3309a1c712825308e298505174af06e.png" data-height="800" data-width="1280" data-lazy-src="https://storage.googleapis.com/blog-images-backup/1*0xm7iUtw01P-2VRczMuv_g.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" class=" jetpack-lazy-image" data-original-src="https://storage.googleapis.com/blog-images-backup/1*0xm7iUtw01P-2VRczMuv_g.png"/><noscript><img data-lazy-fallback="1" decoding="async" src="../Images/d3309a1c712825308e298505174af06e.png" data-height="800" data-width="1280" data-original-src="https://storage.googleapis.com/blog-images-backup/1*0xm7iUtw01P-2VRczMuv_g.png"/></noscript></figure>
<h3>RxDB有很多这里没有提到的特性，比如<a href="https://pubkey.github.io/rxdb/rx-schema.html" target="_blank" rel="noopener noreferrer">加密</a>、<a href="https://pubkey.github.io/rxdb/middleware.html" target="_blank" rel="noopener noreferrer">中间件钩子</a>，或者<a href="https://pubkey.github.io/rxdb/rx-document.html#atomicupdate" target="_blank" rel="noopener noreferrer">原子更新操作</a>。</h3>
<p>您可以通过实现编辑和删除操作，或者通过将数据同步到一个<a href="http://couchdb.apache.org/" target="_blank" rel="noopener noreferrer"> CouchDB </a>服务器或者一个<a href="https://www.ibm.com/analytics/us/en/technology/cloud-data-services/cloudant/" target="_blank" rel="noopener noreferrer"> IBM Cloudant </a>数据库来扩展这个应用程序。</p>
<p>使用LogRocket消除传统反应错误报告的噪音</p><div class="code-block code-block-17">
<div class="blog-plug inline-plug react-plug" vwo-el-id="26283398190">
<h2 vwo-el-id="41600691720">是一款React analytics解决方案，可保护您免受数百个误报错误警报的影响，只针对少数真正重要的项目。LogRocket告诉您React应用程序中实际影响用户的最具影响力的bug和UX问题。</h2>
<a href="https://lp.logrocket.com/blg/react-signup-issue-free" target="_blank" vwo-el-id="19356441070">LogRocket
</a><p>自动聚合客户端错误、反应错误边界、还原状态、缓慢的组件加载时间、JS异常、前端性能指标和用户交互。然后，LogRocket使用机器学习来通知您影响大多数用户的最具影响力的问题，并提供您修复它所需的上下文。</p><a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="19356441380">
<img class="first-react-image alignnone size-full wp-image-46 jetpack-lazy-image jetpack-lazy-image--handled" src="../Images/f300c244a1a1cf916df8b4cb02bec6c6.png" vwo-el-id="18272717540" data-lazy-loaded="1" data-original-src="https://files.readme.io/27c94e7-Image_2017-06-05_at_9.46.04_PM.png"/>
</a>
<a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="19356441690">
<img class="second-react-image alignnone size-full wp-image-46 jetpack-lazy-image jetpack-lazy-image--handled" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" vwo-el-id="30720362350" data-lazy-loaded="1" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/>
</a>
<a href="https://lp.logrocket.com/blg/react-signup-issue-free" target="_blank" rel="noopener noreferrer" vwo-el-id="35866400580">LogRocket
</a><p>关注重要的React bug—<a class="signup" href="https://lp.logrocket.com/blg/react-signup-issue-free" target="_blank" rel="noopener noreferrer" vwo-el-id="40093418840">今天就试试LogRocket】。</a></p><p vwo-el-id="28675661060">Focus on the React bugs that matter —
<a class="signup" href="https://lp.logrocket.com/blg/react-signup-issue-free" target="_blank" rel="noopener noreferrer" vwo-el-id="40093418840">try LogRocket today</a>.
</p>
</div></div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
<html>
<head>
<title>React Context API: A deep dive with examples - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>React Context API:示例深度剖析</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/react-context-api-deep-dive-examples/#0001-01-01">https://blog.logrocket.com/react-context-api-deep-dive-examples/#0001-01-01</a></blockquote><div><article class="article-post">
<blockquote><p><strong>编者按</strong>:这篇文章最后一次更新是在2021年10月，以反映关于React上下文API的最新信息。</p></blockquote>
<p>尽管React很受欢迎，但开发人员在使用该库时面临的最大障碍之一是组件过度重复渲染，这会降低性能并损害可读性。当开发人员需要组件在称为prop drilling的过程中相互通信时，组件重新呈现尤其有害。</p>
<p>React v.16.3引入的<a href="https://reactjs.org/docs/context.html">新React上下文API </a>允许我们通过组件树传递数据，使我们的组件能够在不同级别上通信和共享数据。在本教程中，我们将探索如何使用React上下文来避免适当的钻取。首先，我们将涵盖什么是道具演练，以及为什么我们应该避免它。</p>
<p>目录:</p>

<h2 id="componetsandpropsinreact">React中的组件和道具</h2>
<p>虽然您的应用程序开始时可能只有一个组件，但是随着它变得越来越复杂，您必须不断地将它分解成更小的组件。有了组件，我们可以隔离更大的应用程序的各个部分，提供关注点的分离。如果您的应用程序中出现任何问题，您可以使用故障隔离轻松地确定问题出在哪里。</p>
<p>然而，组件也意味着可重用。您希望避免重复的逻辑并防止过度抽象。重用组件带来了干代码的好处；组件通常具有另一个组件需要的一些数据或功能，例如，保持组件同步。在React中，我们可以使用道具来使我们的组件进行通信。</p>
<p>组件就像JavaScript函数，可以接受任意数量的参数。理想情况下，函数的参数用于其操作。我喜欢把函数想象成一个代码块，它执行一个函数，传递给它的参数可以是零，也可以是任意数量。例如，下面的函数<code>sum</code>将两个数字<code>a</code>和<code>b</code>相加:</p>
<pre>function sum(a, b) {
  return a + b;
}
</pre>
<p>执行该函数相当简单:</p>
<pre>console.log(sum(1, 2)); // 3
</pre>
<p>在React组件中，这些参数被称为props，是properties的缩写。一个<code>ErrorMessage</code>可能看起来像这样:</p>
<pre>function ErrorMessage(props) {
  return (
    &lt;div className="error-message"&gt;
      &lt;h1&gt; Something went wrong &lt;/h1&gt;  
      &lt;p&gt; {props.message} &lt;/p&gt;
    &lt;/div&gt;
  )
}
</pre>
<p>因为<code>ErrorMessage</code>将在整个应用中被多次重用，所以它将在其props中传递一个不同的<code>message</code>。然而，这只是一个组成部分，这个例子并没有阐明<code>message</code>道具从何而来，这对我们了解很重要。</p>
<h2 id="reactpropdrilling">反作用支柱钻井</h2>
<p>React将UI更改保存在虚拟DOM中，然后通过一个称为协调的过程来更新浏览器DOM。让我们以一个简单的仪表板应用程序为例:</p>
<pre>function App() {
  const [title, setTitle] = React.useState("Home");
  const [username, setUsername] = React.useState("John Doe");
  const [activeProfileId, setActiveProfileId] = React.useState("A1B2C3");

  return (
    &lt;div className="app"&gt;
      &lt;h1&gt;Welcome, {username}&lt;/h1&gt;
      &lt;Dashboard {...{ activeProfileId, title, username}}/&gt;
    &lt;/div&gt;
  )
}
</pre>
<p><code>App</code>组件有三个<code>states</code>、<code>activeProfileId</code>、<code>title</code>和<code>username</code>。<code>states</code>有默认值，它们被传递给<code>Dashboard</code>组件:</p>
<pre>function Dashboard({activeProfileId, title, username}) {
  return (
    &lt;div className="dashboard"&gt;
      &lt;SideNav {...{activeProfileId}}/&gt;
      &lt;Main {...{title, username}}/&gt;
    &lt;/div&gt;
  )
}
</pre>
<p><code>Dashboard</code>组件接收<code>props</code>并立即将它们分派给树中更下面的后续组件<code>SideNav</code>和<code>Main</code>:</p>
<pre>function SideNav({activeProfileId}) {
  return (
    &lt;nav className="side-nav"&gt;
      &lt;h1&gt;ID: {activeProfileId}&lt;/h1&gt;
    &lt;/nav&gt;
  )
}

function Main({title, username}) {
  return (
    &lt;div className="main-content"&gt;
      &lt;TopNav {...{title}}/&gt;
      &lt;Page {...{username}}/&gt;
    &lt;/div&gt;
  )
}
SideNav immediately consumes the activeProfileId prop, and Main continues to relay the title and username props further down the tree.
function TopNav({title}) {
  return (
    &lt;nav className="top-nav"&gt;
      &lt;h1&gt; {title} &lt;/h1&gt;
    &lt;/nav&gt;
  )
}

function Page({username}) {
  return &lt;Profile {...{username}}/&gt;
}
TopNav uses the title props, and Page sends username down, again, to Profile:
function Profile({username}) {
  return &lt;h1&gt;{username}&lt;/h1&gt;
}
</pre>
<p>最后，<code>Profile</code>使用<code>username</code>道具。以这种方式传递道具下来，<a href="https://blog.logrocket.com/the-upsides-of-prop-drilling-in-react/">称为道具钻</a>，是默认的方法。为了更好地说明组件层次结构，请查看下图:</p>
<p><img data-attachment-id="74807" data-permalink="https://blog.logrocket.com/react-context-api-deep-dive-examples/react-prop-drilling-dashboard-example/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/06/react-prop-drilling-dashboard-example.png" data-orig-size="730,715" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="react-prop-drilling-dashboard-example" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/06/react-prop-drilling-dashboard-example-300x294.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/06/react-prop-drilling-dashboard-example.png" decoding="async" class="aligncenter wp-image-74807 size-full jetpack-lazy-image" src="../Images/5d2f5d691e1d368a8931b42b6bab0257.png" alt="React Prop Drilling Dashboard Example" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2020/06/react-prop-drilling-dashboard-example.png 730w, https://blog.logrocket.com/wp-content/uploads/2020/06/react-prop-drilling-dashboard-example-300x294.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2020/06/react-prop-drilling-dashboard-example.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/06/react-prop-drilling-dashboard-example.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="74807" data-permalink="https://blog.logrocket.com/react-context-api-deep-dive-examples/react-prop-drilling-dashboard-example/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/06/react-prop-drilling-dashboard-example.png" data-orig-size="730,715" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="react-prop-drilling-dashboard-example" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/06/react-prop-drilling-dashboard-example-300x294.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/06/react-prop-drilling-dashboard-example.png" decoding="async" loading="lazy" class="aligncenter wp-image-74807 size-full" src="../Images/5d2f5d691e1d368a8931b42b6bab0257.png" alt="React Prop Drilling Dashboard Example" srcset="https://blog.logrocket.com/wp-content/uploads/2020/06/react-prop-drilling-dashboard-example.png 730w, https://blog.logrocket.com/wp-content/uploads/2020/06/react-prop-drilling-dashboard-example-300x294.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/06/react-prop-drilling-dashboard-example.png"/></noscript>
<p><code>App</code>是启动道具传递组件。当<code>App</code>的状态<code>title</code>、<code>username</code>、<code>activeProfileId</code>被传为<code>props</code>时，需要这些<code>props</code>的组件是<code>SideNav</code>、<code>TopNav</code>和<code>Profile</code>。然而，我们必须通过中介组件<code>Dashboard</code>、<code>Main</code>和<code>Page</code>，它们仅仅是传递道具。</p>
<p>与从<code>App</code>、<code>Dashboard</code>、<code>Main</code>、<code>Page</code>并最终到达<code>Profile</code>的导航相比，从<code>App</code>到<code>Dashboard</code>再到<code>SideNav</code>的遍历相对容易。</p>
<p>沿着链条，任何事情都可能出错。例如，可能会有打字错误，中间组件可能会发生重构，或者我们的<code>props</code>可能会经历突变。此外，如果我们去掉一个中间组件，整个过程就会崩溃。</p>
<p>还有重新渲染的问题。由于React渲染的工作方式，中间组件也将被迫重新渲染，从而降低应用程序的整体性能。让我们看看如何使用React上下文API解决这些问题。</p>
<h2 id="gettingstartedwithreactcontext">React上下文入门</h2>
<p>根据React文档，上下文提供了一种通过组件树将数据从父组件传递到子组件的方法，而不必在每一层手动传递属性。</p>
<p>上下文中的每个组件都是上下文感知的。本质上，需要道具的组件可以简单地请求它，而不需要仅帮助传递道具的中间助手组件，而不是通过树上的每个组件向下传递道具。</p>
<p>我们将使用<a href="https://blog.logrocket.com/how-and-when-to-use-reacts-new-context-api-b584e41b2704/"> <code>useContext</code>钩子来创建和使用一个新的上下文</a>，如下所示:</p>
<pre>// import UserContext — you'd learn how to implement this below

function UserProfile() {
  const userDetails = useContext(UserContext);
  // rest of the component
}
</pre>
<h2 id="reactcontextapiexamples">React上下文API示例</h2>
<h3>存储和访问用户配置文件</h3>
<p>我最喜欢的一个上下文用例是存储用户配置文件，并在我需要的任何地方访问它。我还可以保持共享状态同步。让我们再次构建我们的仪表板应用程序:</p>
<p><img data-attachment-id="74809" data-permalink="https://blog.logrocket.com/react-context-api-deep-dive-examples/react-context-api-dashboard-example/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/06/react-context-api-dashboard-example.png" data-orig-size="730,672" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="react-context-api-dashboard-example" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/06/react-context-api-dashboard-example-300x276.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/06/react-context-api-dashboard-example.png" decoding="async" class="aligncenter wp-image-74809 size-full jetpack-lazy-image" src="../Images/0dff3163f89db633f572375e3244a160.png" alt="React Context API Dashboard Example" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2020/06/react-context-api-dashboard-example.png 730w, https://blog.logrocket.com/wp-content/uploads/2020/06/react-context-api-dashboard-example-300x276.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2020/06/react-context-api-dashboard-example.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/06/react-context-api-dashboard-example.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="74809" data-permalink="https://blog.logrocket.com/react-context-api-deep-dive-examples/react-context-api-dashboard-example/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/06/react-context-api-dashboard-example.png" data-orig-size="730,672" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="react-context-api-dashboard-example" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/06/react-context-api-dashboard-example-300x276.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/06/react-context-api-dashboard-example.png" decoding="async" loading="lazy" class="aligncenter wp-image-74809 size-full" src="../Images/0dff3163f89db633f572375e3244a160.png" alt="React Context API Dashboard Example" srcset="https://blog.logrocket.com/wp-content/uploads/2020/06/react-context-api-dashboard-example.png 730w, https://blog.logrocket.com/wp-content/uploads/2020/06/react-context-api-dashboard-example-300x276.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/06/react-context-api-dashboard-example.png"/></noscript>
<p>组件树看起来会像这样:</p>
<p><img data-attachment-id="74811" data-permalink="https://blog.logrocket.com/react-context-api-deep-dive-examples/react-context-api-dashboard-component-tree/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/06/react-context-api-dashboard-component-tree.png" data-orig-size="730,784" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="react-context-api-dashboard-component-tree" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/06/react-context-api-dashboard-component-tree-279x300.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/06/react-context-api-dashboard-component-tree.png" decoding="async" class="aligncenter wp-image-74811 size-full jetpack-lazy-image" src="../Images/826d4e1c16e74d62379a5ed932510f55.png" alt="React Context API Dashboard Component Tree" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2020/06/react-context-api-dashboard-component-tree.png 730w, https://blog.logrocket.com/wp-content/uploads/2020/06/react-context-api-dashboard-component-tree-279x300.png 279w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2020/06/react-context-api-dashboard-component-tree.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/06/react-context-api-dashboard-component-tree.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="74811" data-permalink="https://blog.logrocket.com/react-context-api-deep-dive-examples/react-context-api-dashboard-component-tree/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/06/react-context-api-dashboard-component-tree.png" data-orig-size="730,784" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="react-context-api-dashboard-component-tree" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/06/react-context-api-dashboard-component-tree-279x300.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/06/react-context-api-dashboard-component-tree.png" decoding="async" loading="lazy" class="aligncenter wp-image-74811 size-full" src="../Images/826d4e1c16e74d62379a5ed932510f55.png" alt="React Context API Dashboard Component Tree" srcset="https://blog.logrocket.com/wp-content/uploads/2020/06/react-context-api-dashboard-component-tree.png 730w, https://blog.logrocket.com/wp-content/uploads/2020/06/react-context-api-dashboard-component-tree-279x300.png 279w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/06/react-context-api-dashboard-component-tree.png"/></noscript>
<p>请注意，该图看起来类似于上面的支柱钻孔组件树，除了<code>username</code>是唯一的考虑因素。您可能还会注意到以下内容:</p>
<ul>
<li>接收组件是<code>TopNav</code>和<code>Profile</code></li>
<li>接收部件需要的状态是在<code>UserProvider</code></li>
<li><code>UserProvider</code>的所有子组件都可以直接访问<code>username</code>状态，包括<code>TopNav</code>、<code>Page</code>和<code>Profile</code></li>
</ul>
<p>直接访问意味着即使<code>Page</code>是<code>Profile</code>的父组件，它也不必再是中间组件:</p>
<pre>import React, { createContext, useState } from "react";

// Create two context:
// UserContext: to query the context state
// UserDispatchContext: to mutate the context state
const UserContext = createContext(undefined);
const UserDispatchContext = createContext(undefined);

// A "provider" is used to encapsulate only the
// components that needs the state in this context
function UserProvider({ children }) {
  const [userDetails, setUserDetails] = useState({
    username: "John Doe"
  });

  return (
    &lt;UserContext.Provider value={userDetails}&gt;
      &lt;UserDispatchContext.Provider value={setUserDetails}&gt;
        {children}
      &lt;/UserDispatchContext.Provider&gt;
    &lt;/UserContext.Provider&gt;
  );
}

export { UserProvider, UserContext, UserDispatchContext };
</pre>
<p>状态变量<code>userDetails</code>和<code>setUserDetails</code>通过带有<code>value</code>属性的<code>UserContext</code>和<code>UserDispatchContext</code>提供者公开。</p>
<p>包装<code>UserProvider</code>，如下图<code>Main</code>所示，将<code>UserContext</code>和<code>UserDispatchContext</code>的<code>value</code>道具暴露给树中的<code>TopNav</code>和<code>Page</code>组件:</p>
<pre>function Main() {
  return (
    &lt;div className="dashboardContent"&gt;
      &lt;UserProvider&gt;
        &lt;TopNav /&gt;
        &lt;Page /&gt;
      &lt;/UserProvider&gt;
    &lt;/div&gt;
  );
}
</pre>
<p>在<code>Profile</code>中，我们可以如下使用<code>username</code>:</p>
<pre>function Profile() {
  const userDetails = React.useContext(UserContext);
  const setUserDetails = useContext(UserDispatchContext);

  return &lt;h1&gt; {userDetails.username} &lt;/h1&gt;;
}

// setUserDetails is a function as de-structured. When using it to update userDetail// s it expects an object with a username:
const [userDetails, setUserDetails] = useState({
    username: "John Doe"
});
</pre>
<h3>具有反应上下文的全局共享状态</h3>
<p>React上下文的另一个用例是将其用作全局状态机制，就像我们在<code>TopNav</code>和<code>Profile</code>之间使用的一样。更新<code>Profile</code>中的<code>username</code>会立即更新<code>UserProvider</code>中的共享状态，为全局状态管理提供一种机制。</p>
<p>与适当钻取一样，在使用上下文时会有一些性能消耗。每当它呈现时，其子组件也会呈现。最小化渲染的一个方法是让上下文尽可能靠近它被使用的地方，就像我们对<code>UserProvider</code>所做的那样。尽管我们可以将它放在组件树中更高的位置，但它的效率会更低。</p>
<h2 id="whatthereactcontextapiisusedfor">React上下文API的用途</h2>
<p>有了React Context，我们可以深入传递数据。虽然一些开发人员可能希望使用上下文作为全局状态管理解决方案，但这样做是很棘手的。尽管React Context是原生且简单的，但它不像Redux那样是一个专用的状态管理工具，也没有合理的默认设置。</p>
<p>如果您决定使用React上下文，您应该意识到其潜在的性能消耗。你很容易忘乎所以，在不需要的地方添加了太多的组件。为了防止重新呈现，请确保仅在需要上下文的组件中正确放置上下文。</p>
<h2 id="reduxvsthereactcontextapi">Redux与React上下文API</h2>
<p>React上下文是否替代Redux？简而言之，答案是否定的。正如我们已经看到的，Context和Redux是两种不同的工具，而比较通常来自于对每种工具的设计目的的误解。</p>
<p>尽管可以编排上下文来充当状态管理工具，但它不是为此目的而设计的，所以您必须付出额外的努力才能使它工作。已经有很多状态管理工具运行良好，会减轻你的烦恼。</p><div class="code-block code-block-54">
<hr/>
<h3>更多来自LogRocket的精彩文章:</h3>

<hr/></div>
<p>以我使用Redux的经验来看，要实现一些现在用上下文更容易解决的事情可能会相对复杂。请记住，适当的钻取和全局状态管理是Redux和Context的交叉点。Redux在这方面有更多的功能。</p>
<p>最终，Redux和Context应该被认为是互补的工具，它们一起工作，而不是替代物。我的建议是使用Redux进行复杂的全局状态管理，使用Context进行适当的处理。</p>
<h2>结论</h2>
<p>这篇文章的主要内容包括:</p>
<ul>
<li>React上下文API是为正确钻探而设计的</li>
<li>如果您使用上下文进行全局状态管理，请谨慎使用</li>
<li>如果你不能谨慎对待上下文，尝试Redux</li>
<li>Redux可以独立于React使用</li>
<li>Redux不是唯一可用的状态管理工具</li>
</ul>
<p>在本文中，我们回顾了什么是React Context API，何时应该使用它来避免钻取，以及如何最有效地使用上下文。我们还澄清了围绕React上下文API和Redux的一些误解。我希望你喜欢这个教程！</p><div class="code-block code-block-17">
<div class="blog-plug inline-plug react-plug" vwo-el-id="26283398190">
<h2 vwo-el-id="41600691720">使用LogRocket消除传统反应错误报告的噪音</h2>
<a href="https://lp.logrocket.com/blg/react-signup-issue-free" target="_blank" vwo-el-id="19356441070">LogRocket
</a><p>是一款React analytics解决方案，可保护您免受数百个误报错误警报的影响，只针对少数真正重要的项目。LogRocket告诉您React应用程序中实际影响用户的最具影响力的bug和UX问题。</p><a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="19356441380">
<img class="first-react-image alignnone size-full wp-image-46 jetpack-lazy-image jetpack-lazy-image--handled" src="../Images/f300c244a1a1cf916df8b4cb02bec6c6.png" vwo-el-id="18272717540" data-lazy-loaded="1" data-original-src="https://files.readme.io/27c94e7-Image_2017-06-05_at_9.46.04_PM.png"/>
</a>
<a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="19356441690">
<img class="second-react-image alignnone size-full wp-image-46 jetpack-lazy-image jetpack-lazy-image--handled" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" vwo-el-id="30720362350" data-lazy-loaded="1" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/>
</a>
<a href="https://lp.logrocket.com/blg/react-signup-issue-free" target="_blank" rel="noopener noreferrer" vwo-el-id="35866400580">LogRocket
</a><p>自动聚合客户端错误、反应错误边界、还原状态、缓慢的组件加载时间、JS异常、前端性能指标和用户交互。然后，LogRocket使用机器学习来通知您影响大多数用户的最具影响力的问题，并提供您修复它所需的上下文。</p><p vwo-el-id="28675661060">关注重要的React bug—<a class="signup" href="https://lp.logrocket.com/blg/react-signup-issue-free" target="_blank" rel="noopener noreferrer" vwo-el-id="40093418840">今天就试试LogRocket】。</a></p>
</div></div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
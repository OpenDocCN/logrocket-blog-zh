<html>
<head>
<title>Working with the Blazor JavaScript Interop - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>使用Blazor JavaScript Interop-log rocket博客</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/working-with-the-blazor-javascript-interop-3c2a8d0eb56c/#0001-01-01">https://blog.logrocket.com/working-with-the-blazor-javascript-interop-3c2a8d0eb56c/#0001-01-01</a></blockquote><div><article class="article-post">
<figure><img decoding="async" src="../Images/29d580f04469b962618419bb41214011.png" data-height="700" data-width="1240" data-lazy-src="https://storage.googleapis.com/blog-images-backup/1*9VnQHM6JhrXhm6otyaMVmQ.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" class=" jetpack-lazy-image" data-original-src="https://storage.googleapis.com/blog-images-backup/1*9VnQHM6JhrXhm6otyaMVmQ.png"/><noscript><img data-lazy-fallback="1" decoding="async" src="../Images/29d580f04469b962618419bb41214011.png" data-height="700" data-width="1240" data-original-src="https://storage.googleapis.com/blog-images-backup/1*9VnQHM6JhrXhm6otyaMVmQ.png"/></noscript></figure>
<p>在本文中，我们将研究Blazor，一个基于。使用WebAssembly在浏览器中运行的. NET。我们将了解Blazor如何处理JavaScript调用，为什么它是必要的，以及如何使用它。</p>
<p>随着WebAssembly(缩写为Wasm)的发展势头越来越猛，了解当前的功能非常重要。WebAssembly无法直接访问浏览器的DOM API，但是它可以调用JavaScript。由于这个缺点，JavaScript仍然是web开发的一部分。</p>
<figure><a href="https://logrocket.com/signup/" target="_blank" rel="noopener noreferrer"><img decoding="async" src="../Images/94b3e0f84b30cb0d321f60471481ab64.png" data-height="750" data-width="3212" data-lazy-src="https://storage.googleapis.com/blog-images-backup/1*GPjaPKNNUYHU8EsA3Z0JGA.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" class=" jetpack-lazy-image" data-original-src="https://storage.googleapis.com/blog-images-backup/1*GPjaPKNNUYHU8EsA3Z0JGA.png"/><noscript><img data-lazy-fallback="1" decoding="async" src="../Images/94b3e0f84b30cb0d321f60471481ab64.png" data-height="750" data-width="3212" data-original-src="https://storage.googleapis.com/blog-images-backup/1*GPjaPKNNUYHU8EsA3Z0JGA.png"/></noscript></a></figure>
<h3>Blazor、Mono和WebAssembly</h3>
<p>WebAssembly (Wasm)是一种二进制指令格式，旨在为C#等高级语言提供编译目标。最近，微软开始试验WebAssembly来实现。NET到使用Mono运行时的浏览器。Mono提供了基本的管道。NET库(.dll)在WebAssembly上运行。</p>
<figure class="wp-caption"><img decoding="async" src="../Images/202d7ff854e6283d16f953e1055faf79.png" data-height="1245" data-width="2872" data-lazy-src="https://storage.googleapis.com/blog-images-backup/1*VdBE4STMMqP_9g7EKZsEJw.jpeg?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" class=" jetpack-lazy-image" data-original-src="https://storage.googleapis.com/blog-images-backup/1*VdBE4STMMqP_9g7EKZsEJw.jpeg"/><noscript><img data-lazy-fallback="1" decoding="async" src="../Images/202d7ff854e6283d16f953e1055faf79.png" data-height="1245" data-width="2872" data-original-src="https://storage.googleapis.com/blog-images-backup/1*VdBE4STMMqP_9g7EKZsEJw.jpeg"/></noscript><figcaption class="wp-caption-text">A block diagram of the Blazor &amp; Browser relationship</figcaption></figure>
<p>Blazor具有组件架构、路由、虚拟DOM和JavaScript互操作性(interop) API。通过JavaScript interop，Blazor应用程序可以从。来自JavaScript代码的. NET和C#方法。</p>
<p>从调用JavaScript。NET使用了<em> IJSRuntime </em>抽象。通过调用<em> JSRuntime来解析IJSRuntime的当前实例。电流</em>。从这个实例中，我们可以调用<em> InvokeAsync &lt; T &gt; </em>方法，将第一个参数作为标识符传递给我们想要调用的相应JavaScript函数，这个函数必须在<em>窗口</em>的全局范围内可用。额外的参数可以传递给JavaScript函数，只要它们是JSON可序列化的，以及返回类型<em>Task&lt;T&gt;T9】。</em></p>
<figure>
<pre><code>using Microsoft.JSInterop;
public class ExampleJsInterop
{
  public static Task&lt;T&gt; MethodName(TArgs args)
  {
    // Implemented in exampleJsInterop.js
    return JSRuntime.Current.InvokeAsync&lt;T&gt;("scope.jsMethod", args);
  }
}</code></pre>
</figure>
<h3>JavaScript互操作</h3>
<p>由于Blazor是基于Mono和WebAssembly构建的，因此不能直接访问浏览器的DOM API，所以当它需要DOM访问时，必须通过JavaScript进行调用。在堆栈中包含JavaScript不仅在必要性方面是有益的，而且在灵活性方面也是有益的。</p>
<p><strong>向后兼容性</strong></p>
<p>在堆栈中包含JavaScript使得Blazor应用程序能够利用现有的JavaScript库。这包括UI库，如用于简单图表组件的<a href="https://github.com/chanan/BlazorStrap" target="_blank" rel="noopener noreferrer"> Bootstrap </a>、<a href="https://github.com/sotsera/sotsera.blazor.toaster" target="_blank" rel="noopener noreferrer"> Toastr.js </a>、toast通知库和<a href="http://www.chartjs.org/" target="_blank" rel="noopener noreferrer"> Chart.js </a>。</p>
<p>此外，全功能的商业UI库，如<a href="https://www.telerik.com/kendo-ui" target="_blank" rel="noopener noreferrer">剑道UI </a>有可能被移植到Blazor。这些“端口”本质上提供了一个C# API表面，用于与底层JavaScript进行交互，同时为用户提供了一个迁移路径。</p>
<p><strong>介意差距</strong></p>
<p>因为Blazor是新的和实验性的，所以当WebAssembly本身有缺点时，或者因为Blazor框架还不成熟时，interop允许开发人员依靠JavaScript。</p>
<p>例如，如果我们想使用一个标准的window <em> prompt() </em>方法，Blazor中没有本地支持来做这件事。但是，可以使用JavaScript interop创建一个简单的API来添加对该功能的支持。</p>
<p>我们首先用我们希望从应用程序中调用的方法创建一个JavaScript文件。</p>
<p>对于Blazor可见的函数，我们需要将其添加到<em>窗口</em>的范围内。作为最佳实践，可以使用模块模式添加额外的名称空间，这可以保护我们的方法不与<em>窗口</em>范围内的其他代码冲突。在我们的名称空间中，我们定义了一个函数来调用本机窗口<em> prompt() </em>方法。</p>
<figure>
<pre><code>window.myNamespace = {
    showPrompt: function (message) {
    return prompt(message, 'Type anything here');
  },
    anotherFunction: function(args) { 
    // do stuff 
  }
};</code></pre>
</figure>
<p>接下来，我们需要使用<em> JSRuntime从C#内部调用JavaScript <em> showPrompt </em>函数。Current.InvokeAsync </em>方法。一个C#函数<em> PromptAsync </em>提供了一个很好的抽象，可以在Blazor应用程序中使用。使用抽象的开发人员不需要理解底层的JavaScript实现。</p>
<figure>
<pre><code>using Microsoft.JSInterop;

public class PromptInterop
{
    /// &lt;summary&gt;
    /// Invokes a browser prompt and returns the user's input.
    /// &lt;/summary&gt;
    public static Task&lt;string&gt; PromptAsync(string message) {
        return JSRuntime.Current.InvokeAsync&lt;string&gt;("myNamespace.showPrompt",message);
    }
}</code></pre>
</figure>
<p>因为Blazor的UI进程能够在独立于应用程序的线程上运行，所以默认情况下应该使用InvokeAsync。</p>
<p>然而，如果需要同步调用JavaScript方法，我们可以通过将<em> JSRuntime </em>向下转换为<em> IJSInProcessRuntime </em>来提供该功能。除了<em> PromptAsync </em>之外，添加<em>提示</em>方法可以在异步行为不可用时提供一个替代的API。</p>
<figure>
<pre><code>using Microsoft.JSInterop;

public class PromptInterop
{
    /// &lt;summary&gt;
    /// Invokes a browser prompt and returns the user's input.
    /// &lt;/summary&gt;
    public static Task&lt;string&gt; PromptAsync(string message) {
        return JSRuntime.Current.InvokeAsync&lt;string&gt;("myNamespace.showPrompt",message);
    }

    /// &lt;summary&gt;
    /// Syncronously invokes a browser prompt and returns the user's input. Use for in-process-senarios only.
    /// &lt;/summary&gt;
    public static string Prompt(string message) {
        return ((IJSInProcessRuntime)JSRuntime.Current).Invoke&lt;string&gt;("myNamespace.showPrompt",message);
    }
}</code></pre>
</figure>
<p><em> ShowPrompt </em>方法现在可以在应用程序中使用了。通过调用方法并等待结果，我们可以从Blazor组件中调用<em> PromptAsync </em>。</p>
<p>在下面的例子中，我们将在用户点击组件时触发浏览器提示。当提示关闭时，结果返回到组件的<em>消息</em>字段，该字段被数据绑定并呈现给组件。为了确保数据绑定发生时新值得到更新，我们将调用<em> StateHasChanged </em>来指示Blazor重新呈现组件。</p>
<figure>
<pre><code>&lt;div onclick="@HandleClick" class="my-component"&gt;
    @Message
&lt;/div&gt;

@functions {
    string Message = "Click to change";
    async void HandleClick()
    {
        Message = await PromptInterop.PromptAsync("Type a message");
        StateHasChanged();
    }
}</code></pre>
</figure>
<figure class="wp-caption"><img decoding="async" src="../Images/1833ab34f51013e54d6f7f6dceeee87b.png" data-height="170" data-width="400" data-lazy-src="https://storage.googleapis.com/blog-images-backup/1*aVDRr5sTO7oOnrX1YmnRVg.gif?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" class=" jetpack-lazy-image" data-original-src="https://storage.googleapis.com/blog-images-backup/1*aVDRr5sTO7oOnrX1YmnRVg.gif"/><noscript><img data-lazy-fallback="1" decoding="async" src="../Images/1833ab34f51013e54d6f7f6dceeee87b.png" data-height="170" data-width="400" data-original-src="https://storage.googleapis.com/blog-images-backup/1*aVDRr5sTO7oOnrX1YmnRVg.gif"/></noscript><figcaption class="wp-caption-text">Blazor JavaScript interop providing a browser prompt</figcaption></figure>
<h3>结论</h3>
<p>虽然Blazor和WebAssembly缺乏直接访问浏览器的DOM API的能力，但JavaScript interop提供了一种填补这一空白的方法。互操作使得将现有的JavaScript库迁移到Blazor成为可能。通过interop，开发人员可以围绕浏览器特性创建抽象，提供C#方法来在应用程序级别添加功能。</p><div class="code-block code-block-54">
<hr/>
<h3>更多来自LogRocket的精彩文章:</h3>

<hr/></div>
<p>随着Blazor越来越受欢迎，有理由认为一个互操作库的生态系统将会出现。随着更多互操作库的出现，Blazor开发人员可能会花更少的时间编写JavaScript，而花更多的时间编写C#。</p><div class="code-block code-block-28">
<div class="blog-plug inline-plug js-libraries-plug"><h2>您是否添加了新的JS库来提高性能或构建新特性？如果他们反其道而行之呢？</h2><p>毫无疑问，前端变得越来越复杂。当您向应用程序添加新的JavaScript库和其他依赖项时，您将需要更多的可见性，以确保您的用户不会遇到未知的问题。</p>
<p>LogRocket 是一个前端应用程序监控解决方案，可以让您回放JavaScript错误，就像它们发生在您自己的浏览器中一样，这样您就可以更有效地对错误做出反应。</p><a class="signup" href="https://lp.logrocket.com/blg/javascript-signup" target="_blank" rel="noopener noreferrer"><img class="alignnone size-full wp-image-46 jetpack-lazy-image" src="../Images/e8a0ab42befa3b3b1ae08c1439527dc6.png" alt="LogRocket Dashboard Free Trial Banner" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2019/10/errors-screenshot.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/10/errors-screenshot.png"/><noscript><img data-lazy-fallback="1" class="alignnone size-full wp-image-46" src="../Images/e8a0ab42befa3b3b1ae08c1439527dc6.png" alt="LogRocket Dashboard Free Trial Banner" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/10/errors-screenshot.png"/></noscript></a>
<a href="https://lp.logrocket.com/blg/javascript-signup" target="_blank" rel="noopener noreferrer">https://logrocket.com/signup/</a><p><a href="https://lp.logrocket.com/blg/javascript-signup" target="_blank" rel="noopener noreferrer"> LogRocket </a>可以与任何应用程序完美配合，不管是什么框架，并且有插件可以记录来自Redux、Vuex和@ngrx/store的额外上下文。您可以汇总并报告问题发生时应用程序的状态，而不是猜测问题发生的原因。LogRocket还可以监控应用的性能，报告客户端CPU负载、客户端内存使用等指标。</p><p>自信地构建— <a class="signup" href="https://lp.logrocket.com/blg/javascript-signup" target="_blank" rel="noopener noreferrer">开始免费监控</a>。</p></div>


</div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
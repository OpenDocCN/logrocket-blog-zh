<html>
<head>
<title>Creating an @export GraphQL directive - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>创建@export GraphQL指令- LogRocket博客</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/creating-an-export-graphql-directive/#0001-01-01">https://blog.logrocket.com/creating-an-export-graphql-directive/#0001-01-01</a></blockquote><div><article class="article-post">
<p>GraphQL中的<code>@export</code>指令的目标是将一个字段(或一组字段)的值导出到一个变量中，我们可以在查询中的其他地方使用这个变量。</p>
<p>它最明显的用例是将两个查询合并成一个，这样就不需要第二个查询等待第一个查询执行，从而提高了性能。有人提议通过发布<a href="https://github.com/graphql/graphql-spec/issues/583">【RFC】动态变量声明</a>将其添加到GraphQL规范中。</p>
<p>如何运用这一指令？假设我们想要搜索所有提到登录用户名字的帖子。通常，我们需要两个查询来完成这个任务。</p>
<p>我们首先检索用户的<code>name</code>:</p>
<pre class="json">query GetLoggedInUserName {
  me {
    name
  }
}</pre>
<p>然后，在执行了第一个查询之后，我们可以将检索到的用户的<code>name</code>作为变量<code>$search</code>进行传递，以在第二个查询中执行搜索:</p>
<pre class="json">query GetPostsContainingString($search: String = "") {
  posts(search: $search) {
    id
    title
  }
}</pre>
<p><code>@export</code>指令将允许我们从一个字段中导出值，并通过一个动态变量将该值注入第二个字段，该变量的名称在参数<code>as</code>下定义，从而将两个查询合并为一个:</p>
<pre class="json">query GetPostsContainingLoggedInUserName($search: String = "") {
  me {
    name @export(as: "search")
  }
  posts(search: $search) {
    id
    title
  }
}</pre>
<p>自从创建以来，这个问题没有从<a href="https://github.com/graphql/graphql-spec/blob/master/CONTRIBUTING.md#stage-0-strawman">稻草人阶段</a>升级，因为它不容易实现。特别是<code><a href="https://github.com/graphql/graphql-js">graphql-js</a></code>(JavaScript中GraphQL的引用实现)通过承诺并行解析字段，所以它事先并不知道哪个字段会在哪个字段之前被解析。</p>
<p>这对<code>@export</code>来说是一个阻塞问题，因为导出值的字段必须在读取值的字段之前执行。因此，这个指令只能在GraphQL服务器中实现，这些服务器允许我们控制字段被解析的流程，或者哪些<a href="https://github.com/graphql/graphql-spec/issues/583#issuecomment-491807207">支持查询批处理</a>。</p>
<p><a href="https://graphql-by-pop.com">PoP的GraphQL</a>是PHP中的一个graph QL服务器，幸运的是，它没有使用承诺或并行解析字段；它使用开发人员可以在查询本身中操纵的确定性顺序，按顺序解析它们。因此，它可以支持<code>@export</code>指令的执行。</p>
<p>因为这个指令最终可能成为规范的一部分，所以这个特定的解决方案必须尽可能地通用，只使用GraphQL规范中已经存在的特性，以便为其他GraphQL服务器提供一个遵循的模型，并且不要与最终的官方解决方案偏离太多，这样它就可以通过最少的重写进行调整。</p>
<p>在本文中，我将解释这个针对<code>@export</code>的特殊解决方案是如何工作的，以及它是如何设计的。</p>
<h2>研究如何使用该指令</h2>
<p>正如我们在上面的查询中看到的，<code>@export</code>必须处理从单个字段导出单个值:用户的<code>name</code>。</p>
<p>返回列表的字段也应该是可导出的。例如，在下面的查询中，导出的值是登录用户的朋友的名字列表(因此，<code>$search</code>变量的类型从<code>String</code>变成了<code>[String]</code>):</p>
<pre class="json">query GetPostsContainingLoggedInUserName($search: [String] = []) {
  me {
    friends {
      name @export(as: "search")
    }
  }
  posts(searchAny: $search) {
    id
    title
  }
}</pre>
<p>请注意，参数<code>"as"</code>也用于定义导出列表的动态变量的名称，尽管<a href="https://github.com/graphql/graphql-spec/issues/583#issue-442887842">最初的提议</a>建议了两个不同的参数:<code>"as"</code>用于单个值，而<code>"into"</code>用于列表。然而，我相信<code>"as"</code>适合这两种情况，并且使事情变得简单，所以我坚持使用它。</p>
<p>尽管在最初的提议中没有要求，但在某些情况下，我们可能还需要从同一个对象中导出几个属性。然后，<code>@export</code>应该允许我们将这些属性导出到同一个变量，作为值的字典。</p>
<p>例如，查询可以从用户导出<code>name</code>和<code>surname</code>字段，并有一个接收字典的<code>searchByAnyProperty</code>输入(输入类型改为<code>Map</code>):</p>
<pre class="json">query GetPostsContainingLoggedInUserName($search: Map = {}) {
  me {
    name @export(as: "search")
    surname @export(as: "search")
  }
  posts(searchByAnyProperty: $search) {
    id
    title
  }
}</pre>
<p>然后，类似于从单个值升级到值列表，我们可以从单个字典升级到字典列表。</p>
<p>例如，我们可以从登录用户的朋友列表中导出字段<code>name</code>和<code>surname</code>(输入类型变为<code>[Map]</code>):</p>
<pre class="json">query GetPostsContainingLoggedInUserName($search: [Map] = []) {
  me {
    friends {
      name @export(as: "search")
      surname @export(as: "search")
    }
  }
  posts(searchAnyByAnyProperty: $search) {
    id
    title
  }
}</pre>
<p>总之，<code>@export</code>必须能够处理这四种情况:</p>
<ol>
<li>从单个字段导出单个值</li>
<li>从单个字段导出值列表</li>
<li>导出值的字典，包含来自同一对象的多个字段</li>
<li>导出值字典的列表，每个字典包含来自同一对象的多个字段</li>
</ol>
<h2>履行</h2>
<p>下面的查询用<code>user(id: 1)</code>替换了字段<code>me</code>,否则非登录用户无法运行它。稍后，我们将回顾为什么变量名以<code>_</code>开头，为什么查询使用一个名为<code>self</code>的字段，以及为什么输入有一个默认值，尽管它从未被使用过。</p>
<p>处理上述所有四种情况的<code>@export</code>的实现是<a href="https://github.com/getpop/graphql/blob/109d194c11dd2510d0ea5ce42b88fb556397400c/src/DirectiveResolvers/ExportDirectiveResolver.php">这个</a>。让我们看看它是如何表现的。</p>
<h3>执行第一个案例</h3>
<p>下面的查询将用户的<code>name</code>提取到变量<code>$_authorName</code>中，然后搜索包含该字符串的所有帖子:</p>
<pre class="json">query GetPostsAuthorNames($_authorName: String = "") {
  user(id: 1) {
    name @export(as: "_authorName")
  }
  self {
    posts(searchfor: $_authorName) {
      id
      title
    }
  }
}</pre>
<p>当<a href="https://newapi.getpop.org/graphiql/?query=query%20GetPostsAuthorNames(%24_authorName%3A%20String%20%3D%20%22%22)%20%7B%0A%20%20user(id%3A%201)%20%7B%0A%20%20%20%20name%20%40export(as%3A%20%22_authorName%22)%0A%20%20%7D%0A%20%20self%20%7B%0A%20%20%20%20posts(searchfor%3A%20%24_authorName)%20%7B%0A%20%20%20%20%20%20id%0A%20%20%20%20%20%20title%0A%20%20%20%20%7D%0A%20%20%7D%0A%7D&amp;operationName=GetPostsAuthorNames">运行查询</a>时，它产生以下响应:</p>
<figure id="attachment_21219" aria-describedby="caption-attachment-21219" class="wp-caption aligncenter"><img data-attachment-id="21219" data-permalink="https://blog.logrocket.com/creating-an-export-graphql-directive/first-query/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/07/first-query.png" data-orig-size="927,437" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="First query" data-image-description="" data-image-caption="&lt;p&gt;Running the first query.&lt;/p&gt;&#10;" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/07/first-query-300x141.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/07/first-query.png" decoding="async" class="size-full wp-image-21219 jetpack-lazy-image" src="../Images/be766c9c272da2494c0c29270c7a8127.png" alt="Running the first query" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2020/07/first-query.png 927w, https://blog.logrocket.com/wp-content/uploads/2020/07/first-query-300x141.png 300w, https://blog.logrocket.com/wp-content/uploads/2020/07/first-query-768x362.png 768w" data-lazy-sizes="(max-width: 927px) 100vw, 927px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2020/07/first-query.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/07/first-query.png"/><noscript><img data-lazy-fallback="1" data-attachment-id="21219" data-permalink="https://blog.logrocket.com/creating-an-export-graphql-directive/first-query/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/07/first-query.png" data-orig-size="927,437" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="First query" data-image-description="" data-image-caption="&lt;p&gt;Running the first query.&lt;/p&gt;&#10;" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/07/first-query-300x141.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/07/first-query.png" decoding="async" loading="lazy" class="size-full wp-image-21219" src="../Images/be766c9c272da2494c0c29270c7a8127.png" alt="Running the first query" srcset="https://blog.logrocket.com/wp-content/uploads/2020/07/first-query.png 927w, https://blog.logrocket.com/wp-content/uploads/2020/07/first-query-300x141.png 300w, https://blog.logrocket.com/wp-content/uploads/2020/07/first-query-768x362.png 768w" sizes="(max-width: 927px) 100vw, 927px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/07/first-query.png"/></noscript><figcaption id="caption-attachment-21219" class="wp-caption-text">Running the first query.</figcaption></figure>
<p>它的工作原理是:在同一个查询中获取用户名<code>"leo"</code>，并搜索包含关键字<code>"leo"</code>的所有帖子。</p>
<h3>执行所有四个案件</h3>
<p>该查询包括<code>@export</code>必须处理的四种情况:</p>
<pre class="json">query GetSomeData(
  $_firstPostTitle: String = "",
  $_postTitles: [String] = [],
  $_firstPostData: Mixed = {},
  $_postData: [Mixed] = []
) {
  post(id: 1) {
    title @export(as:"_firstPostTitle")
    title @export(as:"_firstPostData")
    date @export(as:"_firstPostData")
  }
  posts(limit: 2) {
    title @export(as:"_postTitles")
    title @export(as:"_postData")
    date @export(as:"_postData")
  }
  self {
    _firstPostTitle: echoVar(variable: $_firstPostTitle)
    _postTitles: echoVar(variable: $_postTitles)
    _firstPostData: echoVar(variable: $_firstPostData)
    _postData: echoVar(variable: $_postData)
  }
}</pre>
<p>它是这样工作的:</p>
<p><strong>情况1</strong>–<code>@export</code>单值:</p>
<pre class="json">post(id: 1) {
  title @export(as: "_firstPostTitle")
}</pre>
<p><strong>案例二</strong>–<code>@export</code>一个价值列表:</p>
<pre class="json">posts(limit: 2) {
  title @export(as: "_postTitles")
}</pre>
<p><strong>案例3</strong>–<code>@export</code>字段/值的字典，包含来自同一个对象的两个属性(<code>title</code>和<code>date</code>):</p>
<pre class="json">post(id: 1) {
  title @export(as: "_firstPostData")
  date @export(as: "_firstPostData")
}</pre>
<p><strong>案例4</strong>–<code>@export</code>字段/值字典列表:</p>
<pre class="json">posts(limit: 2) {
  title @export(as: "_postData")
  date @export(as: "_postData")
}</pre>
<p>该查询使用字段<code><a href="https://github.com/GraphQLByPoP/graphql/blob/9d2f983b8374222cda6e4eb87de0e268ccf6f7b0/src/FieldResolvers/ConditionalOnEnvironment/VariablesAsExpressions/VariablesAsExpressionsRootFieldResolver.php">echoVar</a></code>来可视化动态变量的内容。当<a href="">运行查询</a>时，它产生以下响应:</p>
<figure id="attachment_21220" aria-describedby="caption-attachment-21220" class="wp-caption aligncenter"><img data-attachment-id="21220" data-permalink="https://blog.logrocket.com/creating-an-export-graphql-directive/second-query/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/07/second-query.png" data-orig-size="1099,755" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Second query" data-image-description="" data-image-caption="&lt;p&gt;Running the second query.&lt;/p&gt;&#10;" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/07/second-query-300x206.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/07/second-query-1024x703.png" decoding="async" class="size-full wp-image-21220 jetpack-lazy-image" src="../Images/e3e4be6356792b38beaa14428e72fc6c.png" alt="Running the second query" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2020/07/second-query.png 1099w, https://blog.logrocket.com/wp-content/uploads/2020/07/second-query-300x206.png 300w, https://blog.logrocket.com/wp-content/uploads/2020/07/second-query-1024x703.png 1024w, https://blog.logrocket.com/wp-content/uploads/2020/07/second-query-768x528.png 768w" data-lazy-sizes="(max-width: 1099px) 100vw, 1099px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2020/07/second-query.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/07/second-query.png"/><noscript><img data-lazy-fallback="1" data-attachment-id="21220" data-permalink="https://blog.logrocket.com/creating-an-export-graphql-directive/second-query/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/07/second-query.png" data-orig-size="1099,755" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Second query" data-image-description="" data-image-caption="&lt;p&gt;Running the second query.&lt;/p&gt;&#10;" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/07/second-query-300x206.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/07/second-query-1024x703.png" decoding="async" loading="lazy" class="size-full wp-image-21220" src="../Images/e3e4be6356792b38beaa14428e72fc6c.png" alt="Running the second query" srcset="https://blog.logrocket.com/wp-content/uploads/2020/07/second-query.png 1099w, https://blog.logrocket.com/wp-content/uploads/2020/07/second-query-300x206.png 300w, https://blog.logrocket.com/wp-content/uploads/2020/07/second-query-1024x703.png 1024w, https://blog.logrocket.com/wp-content/uploads/2020/07/second-query-768x528.png 768w" sizes="(max-width: 1099px) 100vw, 1099px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/07/second-query.png"/></noscript><figcaption id="caption-attachment-21220" class="wp-caption-text">Running the second query.</figcaption></figure>
<p>同样，它是有效的，因为响应包含处理所有四种情况的结果:</p>
<p><strong>情况1</strong>–<code>@export</code>单值:</p>
<pre class="json">{
  "data": {
    "self": {
      "_firstPostTitle": "Hello world!"
    }
  }
}</pre>
<p><strong>案例二</strong>–<code>@export</code>一个价值列表:</p>
<pre class="json">{
  "data": {
    "self": {
      "_postTitles": [
        "Scheduled by Leo",
        "COPE with WordPress: Post demo containing plenty of blocks"
      ]
    }
  }
}</pre>
<p><strong>案例3</strong>–<code>@export</code>字段/值的字典，包含来自同一个对象的两个属性(<code>title</code>和<code>date</code>):</p>
<pre class="json">{
  "data": {
    "self": {
      "_firstPostData": {
        "title": "Hello world!",
        "date": "August 2, 2019"
      }
    }
  }
}</pre>
<p><strong>案例4</strong>–<code>@export</code>字段/值字典列表:</p>
<pre class="json">{
  "data": {
    "self": {
      "_postData": [
        {
          "title": "Scheduled by Leo",
          "date": "January 1, 2020"
        },
        {
          "title": "COPE with WordPress: Post demo containing plenty of blocks",
          "date": "August 8, 2019"
        }
      ]
    }
  }
}</pre>
<h2>该解决方案的缺陷</h2>
<p>没有什么是完美的。为了让<code>@export</code>工作，查询必须编码成具有以下三个特性:</p>
<ol>
<li>动态变量的名称必须以<code>"_"</code>开头</li>
<li>可能需要字段<code>self</code>来控制解析字段的顺序</li>
<li>动态变量必须在操作名中声明为静态(即“普通”)变量，并且总是接收默认值</li>
</ol>
<p>我将逐一解释为什么这些是强制性的，以及它们是如何工作的。</p>
<h3>1.动态变量的名称必须以<code>"_"</code>开头</h3>
<p>正如我们前面提到的,<code>@export</code>指令不是GraphQL规范的一部分，所以对于它的实现，不需要考虑语言本身。因此，GraphQL服务器实现者必须找到自己的方法来满足他们的需求，而不要过多地偏离GraphQL语法，并期望有一天它能成为官方解决方案的一部分。</p>
<p>对于这个解决方案，我决定<code>@export</code>将这个值导出到一个普通变量中，作为<code>$variable</code>访问。请注意，这是一个可能因实现者而异的设计决策——例如，<a href="https://www.apollographql.com/docs/link/links/rest/#export-directive"> Apollo的<code>@export</code>指令</a>是在条目<code>exportVariables</code>下访问的(就像<code>{exportVariables.id}</code>一样)，而不是在条目<code>args</code>下作为其输入。</p>
<p>因此，Apollo的解决方案不需要我们在操作名中声明导出的变量，但是我的实现需要。</p>
<p>这个设计决策很难实现，因为静态变量和动态变量的行为不同:静态变量的值可以在解析查询时确定，而动态变量的值必须在运行时确定，也就是在读取变量的值时确定。然后，GraphQL引擎必须能够判断用哪种方式处理变量，是静态方式还是动态方式。</p>
<p>给定约束，并且为了避免在查询中引入新的、不受支持的语法(比如有<code>$staticVariables</code>和<code>%dynamicVariables%</code>)，我发现的解决方案是让动态变量名以<code>"_"</code>开头，比如<code>$_dynamicVariable</code>。然后，如果变量名以<code>"_"</code>开头，GraphQL引擎会将其视为动态的，在解析查询时不会解析它；否则，它被视为静态变量。</p>
<p>这个解决方案无疑是一个黑客，但它工作得很好。如果最终有一个针对<code>@export</code>指令的官方解决方案，并且它提供了关于如何区分动态和静态变量的指南，那么我的解决方案必须被修改。</p>
<h3>2.可能需要字段<code>self</code>来控制解析字段的顺序</h3>
<p>如果在将值导出到变量之前读取变量，那么<code>@export</code>指令将不起作用。因此，引擎需要提供一种方法来控制字段执行顺序。这是一个<code>graphql-js</code>无法轻易解决的问题，其结果是<code>@export</code>无法得到GraphQL规范的官方支持。</p>
<p>如前所述，GraphQL by PoP确实提供了一种通过查询本身操纵字段执行顺序的方法。让我们看看它是如何工作的。</p>
<blockquote><p><strong> N.B. </strong>:我已经在文章“<a href="https://blog.logrocket.com/designing-graphql-server-optimal-performance/">设计GraphQL服务器以获得最佳性能</a>”和“<a href="https://blog.logrocket.com/simplifying-the-graphql-data-model/">简化GraphQL数据模型</a>”中详细描述了GraphQL引擎如何解析字段并加载它们的数据。</p></blockquote>
<p>引擎以迭代方式加载每种类型的数据，先解析查询中遇到的第一种类型的所有字段，然后解析查询中遇到的第二种类型的所有字段，依此类推，直到没有其他类型需要处理。</p>
<p>例如，以下查询涉及类型为<code>Director</code>、<code>Film</code>和<code>Actor</code>的对象:</p>
<pre class="json">{
  directors {
    name
    films {
      title
      actors {
        name
      }
    }
  }
}</pre>
<p>由GraphQL引擎按以下顺序解析:</p>
<figure id="attachment_21233" aria-describedby="caption-attachment-21233" class="wp-caption aligncenter"><img data-attachment-id="21233" data-permalink="https://blog.logrocket.com/creating-an-export-graphql-directive/dataloading-engine-type-iterations/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/07/dataloading-engine-type-iterations.png" data-orig-size="1780,294" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Data-loading engine type iterations" data-image-description="" data-image-caption="&lt;p&gt;Dealing with types in iterations.&lt;/p&gt;&#10;" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/07/dataloading-engine-type-iterations-300x50.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/07/dataloading-engine-type-iterations-1024x169.png" decoding="async" class="size-full wp-image-21233 jetpack-lazy-image" src="../Images/8d013ee3b3bbe788f44a92553708004c.png" alt="Dealing with types in iterations" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2020/07/dataloading-engine-type-iterations.png 1780w, https://blog.logrocket.com/wp-content/uploads/2020/07/dataloading-engine-type-iterations-300x50.png 300w, https://blog.logrocket.com/wp-content/uploads/2020/07/dataloading-engine-type-iterations-1024x169.png 1024w, https://blog.logrocket.com/wp-content/uploads/2020/07/dataloading-engine-type-iterations-768x127.png 768w, https://blog.logrocket.com/wp-content/uploads/2020/07/dataloading-engine-type-iterations-1536x254.png 1536w" data-lazy-sizes="(max-width: 1780px) 100vw, 1780px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2020/07/dataloading-engine-type-iterations.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/07/dataloading-engine-type-iterations.png"/><noscript><img data-lazy-fallback="1" data-attachment-id="21233" data-permalink="https://blog.logrocket.com/creating-an-export-graphql-directive/dataloading-engine-type-iterations/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/07/dataloading-engine-type-iterations.png" data-orig-size="1780,294" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Data-loading engine type iterations" data-image-description="" data-image-caption="&lt;p&gt;Dealing with types in iterations.&lt;/p&gt;&#10;" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/07/dataloading-engine-type-iterations-300x50.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/07/dataloading-engine-type-iterations-1024x169.png" decoding="async" loading="lazy" class="size-full wp-image-21233" src="../Images/8d013ee3b3bbe788f44a92553708004c.png" alt="Dealing with types in iterations" srcset="https://blog.logrocket.com/wp-content/uploads/2020/07/dataloading-engine-type-iterations.png 1780w, https://blog.logrocket.com/wp-content/uploads/2020/07/dataloading-engine-type-iterations-300x50.png 300w, https://blog.logrocket.com/wp-content/uploads/2020/07/dataloading-engine-type-iterations-1024x169.png 1024w, https://blog.logrocket.com/wp-content/uploads/2020/07/dataloading-engine-type-iterations-768x127.png 768w, https://blog.logrocket.com/wp-content/uploads/2020/07/dataloading-engine-type-iterations-1536x254.png 1536w" sizes="(max-width: 1780px) 100vw, 1780px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/07/dataloading-engine-type-iterations.png"/></noscript><figcaption id="caption-attachment-21233" class="wp-caption-text">Dealing with types in iterations.</figcaption></figure>
<p>如果在处理之后，在查询中再次引用类型以检索未加载的数据(例如，从额外的对象或来自先前加载的对象的额外的字段)，则该类型被再次添加到迭代列表的末尾。</p>
<p>例如，假设我们还查询了<code>Actor</code>的<code>preferredDirector</code>字段(返回一个类型为<code>Director</code>的对象)，如下所示:</p>
<pre class="json">{
  directors {
    name
    films {
      title
      actors {
        name
        preferredDirector {
          name
        }
      }
    }
  }
}</pre>
<p>然后，GraphQL引擎将按以下顺序处理查询:</p>
<figure id="attachment_21234" aria-describedby="caption-attachment-21234" class="wp-caption aligncenter"><img data-attachment-id="21234" data-permalink="https://blog.logrocket.com/creating-an-export-graphql-directive/dataloading-engine-repeated-type-iterations/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/07/dataloading-engine-repeated-type-iterations.png" data-orig-size="1780,294" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Repeated types in iterations" data-image-description="" data-image-caption="&lt;p&gt;Repeated types in iterations.&lt;/p&gt;&#10;" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/07/dataloading-engine-repeated-type-iterations-300x50.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/07/dataloading-engine-repeated-type-iterations-1024x169.png" decoding="async" class="size-full wp-image-21234 jetpack-lazy-image" src="../Images/7891be64f5bae59634ab62c220153856.png" alt="Repeated types in iterations" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2020/07/dataloading-engine-repeated-type-iterations.png 1780w, https://blog.logrocket.com/wp-content/uploads/2020/07/dataloading-engine-repeated-type-iterations-300x50.png 300w, https://blog.logrocket.com/wp-content/uploads/2020/07/dataloading-engine-repeated-type-iterations-1024x169.png 1024w, https://blog.logrocket.com/wp-content/uploads/2020/07/dataloading-engine-repeated-type-iterations-768x127.png 768w, https://blog.logrocket.com/wp-content/uploads/2020/07/dataloading-engine-repeated-type-iterations-1536x254.png 1536w" data-lazy-sizes="(max-width: 1780px) 100vw, 1780px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2020/07/dataloading-engine-repeated-type-iterations.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/07/dataloading-engine-repeated-type-iterations.png"/><noscript><img data-lazy-fallback="1" data-attachment-id="21234" data-permalink="https://blog.logrocket.com/creating-an-export-graphql-directive/dataloading-engine-repeated-type-iterations/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/07/dataloading-engine-repeated-type-iterations.png" data-orig-size="1780,294" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Repeated types in iterations" data-image-description="" data-image-caption="&lt;p&gt;Repeated types in iterations.&lt;/p&gt;&#10;" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/07/dataloading-engine-repeated-type-iterations-300x50.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/07/dataloading-engine-repeated-type-iterations-1024x169.png" decoding="async" loading="lazy" class="size-full wp-image-21234" src="../Images/7891be64f5bae59634ab62c220153856.png" alt="Repeated types in iterations" srcset="https://blog.logrocket.com/wp-content/uploads/2020/07/dataloading-engine-repeated-type-iterations.png 1780w, https://blog.logrocket.com/wp-content/uploads/2020/07/dataloading-engine-repeated-type-iterations-300x50.png 300w, https://blog.logrocket.com/wp-content/uploads/2020/07/dataloading-engine-repeated-type-iterations-1024x169.png 1024w, https://blog.logrocket.com/wp-content/uploads/2020/07/dataloading-engine-repeated-type-iterations-768x127.png 768w, https://blog.logrocket.com/wp-content/uploads/2020/07/dataloading-engine-repeated-type-iterations-1536x254.png 1536w" sizes="(max-width: 1780px) 100vw, 1780px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/07/dataloading-engine-repeated-type-iterations.png"/></noscript><figcaption id="caption-attachment-21234" class="wp-caption-text">Repeated types in iterations.</figcaption></figure>
<p>让我们看看如何执行<code>@export</code>。对于我们的第一次尝试，我们像平常一样创建查询，不考虑字段的执行顺序:</p>
<pre class="json">query GetPostsAuthorNames($_authorName: String = "") {
  user(id: 1) {
    name @export(as: "_authorName")
  }
  posts(searchfor: $_authorName) {
    id
    title
  }
}</pre>
<p>当<a href="https://newapi.getpop.org/graphiql/?query=query%20GetPostsAuthorNames(%24_authorName%3A%20String%20%3D%20%22%22)%20%7B%0A%20%20user(id%3A%201)%20%7B%0A%20%20%20%20name%20%40export(as%3A%20%22_authorName%22)%0A%20%20%7D%0A%20%20posts(searchfor%3A%20%24_authorName)%20%7B%0A%20%20%20%20id%0A%20%20%20%20title%0A%20%20%7D%0A%7D&amp;operationName=GetPostsAuthorNames">运行查询</a>时，它产生以下响应:</p>
<figure id="attachment_21236" aria-describedby="caption-attachment-21236" class="wp-caption aligncenter"><img data-attachment-id="21236" data-permalink="https://blog.logrocket.com/creating-an-export-graphql-directive/third-query/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/07/third-query.png" data-orig-size="981,341" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Third query" data-image-description="" data-image-caption="&lt;p&gt;Executing a query using a variable.&lt;/p&gt;&#10;" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/07/third-query-300x104.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/07/third-query.png" decoding="async" class="size-full wp-image-21236 jetpack-lazy-image" src="../Images/2322a8e9723572a9df65fed756088387.png" alt="Executing a query using a variable" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2020/07/third-query.png 981w, https://blog.logrocket.com/wp-content/uploads/2020/07/third-query-300x104.png 300w, https://blog.logrocket.com/wp-content/uploads/2020/07/third-query-768x267.png 768w" data-lazy-sizes="(max-width: 981px) 100vw, 981px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2020/07/third-query.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/07/third-query.png"/><noscript><img data-lazy-fallback="1" data-attachment-id="21236" data-permalink="https://blog.logrocket.com/creating-an-export-graphql-directive/third-query/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/07/third-query.png" data-orig-size="981,341" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Third query" data-image-description="" data-image-caption="&lt;p&gt;Executing a query using a variable.&lt;/p&gt;&#10;" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/07/third-query-300x104.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/07/third-query.png" decoding="async" loading="lazy" class="size-full wp-image-21236" src="../Images/2322a8e9723572a9df65fed756088387.png" alt="Executing a query using a variable" srcset="https://blog.logrocket.com/wp-content/uploads/2020/07/third-query.png 981w, https://blog.logrocket.com/wp-content/uploads/2020/07/third-query-300x104.png 300w, https://blog.logrocket.com/wp-content/uploads/2020/07/third-query-768x267.png 768w" sizes="(max-width: 981px) 100vw, 981px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/07/third-query.png"/></noscript><figcaption id="caption-attachment-21236" class="wp-caption-text">Executing a query using a variable.</figcaption></figure>
<p>其中包含以下错误:</p>
<pre class="json">{
  "errors": [
    {
      "message": "Expression '_authorName' is undefined",
    }
  ]
}</pre>
<p>这个错误意味着当变量<code>$_authorName</code>被读取时，它还没有被设置——它是<code>undefined</code>。</p>
<p>让我们看看为什么会这样。首先，我们分析哪些类型出现在查询中，作为注释添加如下(type <code>ID</code>是一个自定义标量):</p>
<pre class="json"># Type: Root
query GetPostsAuthorNames($_authorName: String = "") {
  # Type: User
  user(id: 1) {
    # Type: String
    name @export(as: "_authorName")
  }
  # Type: Post
  posts(searchfor: $_authorName) {
    # Type: ID
    id
    # Type: String
    title
  }
}</pre>
<p>为了处理类型并加载它们的数据，数据加载引擎将查询类型<code>Root</code>添加到FIFO(先进先出)列表中，从而使<code>[Root]</code>成为传递给算法的初始列表。然后，它按顺序遍历这些类型，就像这样:</p>
<table>
<colgroup>
<col/>
<col/>
<col/></colgroup>
<tbody>
<tr>
<td class="">
<p><strong> # </strong></p>
</td>
<td class="">
<p><strong>操作</strong></p>
</td>
<td class="">
<p><strong>列表</strong></p>
</td>
</tr>
<tr>
<td class="">
<p>0</p>
</td>
<td class="">
<p>准备FIFO列表</p>
</td>
<td class="">
<p><code>[Root]</code></p>
</td>
</tr>
<tr>
<td class="">
<p>1a</p>
</td>
<td class="">
<p>弹出列表的第一种类型(<code>Root</code>)</p>
</td>
<td class="">
<p><code>[]</code></p>
</td>
</tr>
<tr>
<td class="">
<p>1b</p>
</td>
<td class="">
<p>处理从根类型查询的所有字段:</p>
<p>→ <code>user(id: 1)</code></p>
<p>→ <code>posts(searchfor: $_authorName)</code></p>
<p>将它们的类型(<code>User</code>和<code>Post</code>)添加到列表中</p>
</td>
<td class="">
<p><code>[User, Post]</code></p>
</td>
</tr>
<tr>
<td class="">
<p>2a</p>
</td>
<td class="">
<p>弹出列表的第一种类型(<code>User</code>)</p>
</td>
<td class="">
<p><code>[Post]</code></p>
</td>
</tr>
<tr>
<td class="">
<p>2b</p>
</td>
<td class="">
<p>处理从<code>User</code>类型查询的字段:</p>
<p>→ <code>name @export(as: "_authorName")</code></p>
<p>因为它是标量类型(<code>String</code>)，所以不需要将其添加到列表中</p>
</td>
<td class="">
<p><code>[Post]</code></p>
</td>
</tr>
<tr>
<td class="">
<p>3a</p>
</td>
<td class="">
<p>弹出列表的第一种类型(<code>Post</code>)</p>
</td>
<td class="">
<p><code>[]</code></p>
</td>
</tr>
<tr>
<td class="">
<p>3b</p>
</td>
<td class="">
<p>处理从<code>Post</code>类型查询的所有字段:</p>
<p>→ <code>id</code></p>
<p>→ <code>title</code></p>
<p>因为这些是标量类型(ID和字符串)，所以不需要将它们添加到列表中</p>
</td>
<td class="">
<p><code>[]</code></p>
</td>
</tr>
<tr>
<td class="">
<p>四</p>
</td>
<td class="">
<p>列表为空，迭代结束</p>
</td>
<td class="">
<p>这里可以看出问题:<code>@export</code>是在步骤<strong> 2b </strong>执行的，但是在步骤<strong> 1b </strong>读取的。</p>
</td>
</tr>
</tbody>
</table>
<p>正是在这里，我们需要控制现场执行流程。我实现的解决方案是延迟读取导出变量的时间，通过人工查询类型<code>Root</code>中的字段<code><a href="https://github.com/getpop/component-model/blob/57a27af3841da284ea59c6f7ff3a9b4c0befa472/src/FieldResolvers/CoreFieldResolver.php">self</a></code>来实现。</p>
<p><code>self</code>字段，顾名思义，返回相同的对象；应用于<code>Root</code>对象，它返回相同的<code>Root</code>对象。您可能会想:“如果我已经有了根对象，那么我为什么还需要再次检索它呢？”</p>
<p>因为随后GraphQL引擎的算法将需要在FIFO列表的末尾添加这个对<code>Root</code>的新引用，并且我们可以在每次迭代之前或之后故意分布查询的字段。</p>
<p>这是一种黑客行为，但它允许我们有效地控制字段被解析的顺序。</p>
<p>这就是为什么在上面的查询中字段<code>posts(searchfor: $_authorName)</code>被放在字段<code>self</code>中，并且<a href="https://newapi.getpop.org/graphiql/?query=query%20GetPostsAuthorNames(%24_authorName%3A%20String%20%3D%20%22%22)%20%7B%0A%20%20user(id%3A%201)%20%7B%0A%20%20%20%20name%20%40export(as%3A%20%22_authorName%22)%0A%20%20%7D%0A%20%20self%20%7B%0A%20%20%20%20posts(searchfor%3A%20%24_authorName)%20%7B%0A%20%20%20%20%20%20id%0A%20%20%20%20%20%20title%0A%20%20%20%20%7D%0A%20%20%7D%0A%7D&amp;operationName=GetPostsAuthorNames">运行查询</a>产生预期的响应:</p>
<p>让我们探索一下这个查询处理类型的顺序，以理解为什么它工作得很好:</p>
<pre class="json">query GetPostsAuthorNames($_authorName: String = "") {
  user(id: 1) {
    name @export(as: "_authorName")
  }
  self {
    posts(searchfor: $_authorName) {
      id
      title
    }
  }
}</pre>
<figure id="attachment_21219" aria-describedby="caption-attachment-21219" class="wp-caption aligncenter"><img data-attachment-id="21219" data-permalink="https://blog.logrocket.com/creating-an-export-graphql-directive/first-query/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/07/first-query.png" data-orig-size="927,437" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="First query" data-image-description="" data-image-caption="&lt;p&gt;Running the first query.&lt;/p&gt;&#10;" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/07/first-query-300x141.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/07/first-query.png" decoding="async" class="size-full wp-image-21219 jetpack-lazy-image" src="../Images/be766c9c272da2494c0c29270c7a8127.png" alt="Running the first query" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2020/07/first-query.png 927w, https://blog.logrocket.com/wp-content/uploads/2020/07/first-query-300x141.png 300w, https://blog.logrocket.com/wp-content/uploads/2020/07/first-query-768x362.png 768w" data-lazy-sizes="(max-width: 927px) 100vw, 927px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2020/07/first-query.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/07/first-query.png"/><noscript><img data-lazy-fallback="1" data-attachment-id="21219" data-permalink="https://blog.logrocket.com/creating-an-export-graphql-directive/first-query/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/07/first-query.png" data-orig-size="927,437" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="First query" data-image-description="" data-image-caption="&lt;p&gt;Running the first query.&lt;/p&gt;&#10;" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/07/first-query-300x141.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/07/first-query.png" decoding="async" loading="lazy" class="size-full wp-image-21219" src="../Images/be766c9c272da2494c0c29270c7a8127.png" alt="Running the first query" srcset="https://blog.logrocket.com/wp-content/uploads/2020/07/first-query.png 927w, https://blog.logrocket.com/wp-content/uploads/2020/07/first-query-300x141.png 300w, https://blog.logrocket.com/wp-content/uploads/2020/07/first-query-768x362.png 768w" sizes="(max-width: 927px) 100vw, 927px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/07/first-query.png"/></noscript><figcaption id="caption-attachment-21219" class="wp-caption-text">Running the first query.</figcaption></figure>
<p><strong> # </strong></p>
<table>
<colgroup>
<col/>
<col/>
<col/></colgroup>
<tbody>
<tr>
<td class="">
<p><strong>操作</strong></p>
</td>
<td class="">
<p><strong>列表</strong></p>
</td>
<td class="">
<p>0</p>
</td>
</tr>
<tr>
<td class="">
<p>准备FIFO列表</p>
</td>
<td class="">
<p><code>[Root]</code></p>
</td>
<td class="">
<p>1a</p>
</td>
</tr>
<tr>
<td class="">
<p>弹出列表的第一种类型(<code>Root</code>)</p>
</td>
<td class="">
<p><code>[]</code></p>
</td>
<td class="">
<p>1b</p>
</td>
</tr>
<tr>
<td class="">
<p>处理从根类型查询的所有字段:</p>
</td>
<td class="">
<p>→ <code>user(id: 1)</code></p>
<p>→ <code>self</code></p>
<p>将它们的类型(<code>User</code>和<code>Root</code>)添加到列表中</p>
<p><code>[User, Root]</code></p>
</td>
<td class="">
<p>2a</p>
</td>
</tr>
<tr>
<td class="">
<p>弹出列表的第一种类型(<code>User</code>)</p>
</td>
<td class="">
<p><code>[Root]</code></p>
</td>
<td class="">
<p>2b</p>
</td>
</tr>
<tr>
<td class="">
<p>处理从用户类型查询的字段:</p>
</td>
<td class="">
<p>→ <code>name @export(as: "_authorName")</code></p>
<p>因为它是标量类型(<code>String</code>)，所以不需要将其添加到列表中</p>
<p><code>[Root]</code></p>
</td>
<td class="">
<p>3a</p>
</td>
</tr>
<tr>
<td class="">
<p>弹出列表的第一种类型(根)</p>
</td>
<td class="">
<p><code>[]</code></p>
</td>
<td class="">
<p>3b</p>
</td>
</tr>
<tr>
<td class="">
<p>处理从根类型查询的字段:</p>
</td>
<td class="">
<p>→ <code>posts(searchfor: $_authorName)</code></p>
<p>将其类型(<code>Post</code>)添加到列表中</p>
<p><code>[Post]</code></p>
</td>
<td class="">
<p>4a</p>
</td>
</tr>
<tr>
<td class="">
<p>弹出列表的第一种类型(<code>Post</code>)</p>
</td>
<td class="">
<p><code>[]</code></p>
</td>
<td class="">
<p>4b</p>
</td>
</tr>
<tr>
<td class="">
<p>处理从帖子类型查询的所有字段:</p>
</td>
<td class="">
<p>→ <code>id</code></p>
<p>→ <code>title</code></p>
<p>因为这些是标量类型(<code>ID</code>和<code>String</code>)，所以没有必要将它们添加到列表中</p>
<p><code>[]</code></p>
</td>
<td class="">
<p>5</p>
</td>
</tr>
<tr>
<td class="">
<p>列表为空，迭代结束</p>
</td>
<td class="">
<p>现在可以看到问题已经解决:<code>@export</code>在步骤<strong> 2b </strong>执行，在步骤<strong> 3b </strong>读取。</p>
</td>
<td class="">
<p>3.动态变量必须在操作名中声明为静态变量，并且总是接收默认值</p>
</td>
</tr>
</tbody>
</table>
<p>GraphQL解析器仍然将动态变量视为变量，因此它验证它已经被定义，并且它在解析时间上有一个值，否则它抛出一个错误<code>"The variable has not been set"</code>。</p>
<h3>为了避免这种错误(它会中止查询的执行)，我们必须始终在操作名称中定义变量，并为该参数提供一个默认值，即使这个值不会被使用。</h3>
<p>奖励:使<code>@skip</code>和<code>@include</code>动态化</p>
<p>我相信，在某些领域，GraphQL目前还没有发挥出它的真正潜力。这就是关于<code>@skip</code>和<code>@include</code>指令的情况，如下查询所示:</p>
<h2>这些指令通过参数<code>"if"</code>接收要评估的条件，该参数只能是实际的布尔值(<code>true</code>或<code>false</code>)或带有布尔值的变量(<code>$showExcerpt</code>)。就行为而言，这是相当静态的。</h2>
<p>基于对象本身的一些属性执行<code>"if"</code>条件怎么样？例如，我们可能希望根据<code>Post</code>对象是否有注释来显示<code>excerpt</code>字段。</p>
<pre class="json">query GetPostTitleAndMaybeExcerpt(
  $showExcerpt: Bool!
) {
  post(id: 1) {
    id
    title
    excerpt @include(if: $showExcerpt)
  }
}</pre>
<p>嗯，<code>@export</code>指令使这成为可能。对于此查询:</p>
<p>响应可能包含也可能不包含字段<code>excerpt</code>，这取决于所查询的帖子是否有评论。</p>
<p>我们去看看。<a href="https://newapi.getpop.org/graphiql/?query=query%20ShowExcerptIfPostHasComments(%0A%20%20%24id%3A%20ID!%2C%0A%20%20%24_hasComments%3A%20Boolean%20%3D%20false%0A)%20%7B%0A%20%20post(id%3A%20%24id)%20%7B%0A%20%20%20%20hasComments%20%40export(as%3A%20%22_hasComments%22)%0A%20%20%7D%0A%20%20self%20%7B%0A%20%20%20%20post(id%3A%20%24id)%20%7B%0A%20%20%20%20%20%20title%0A%20%20%20%20%20%20excerpt%20%40include(if%3A%20%24_hasComments)%0A%20%20%20%20%7D%0A%20%20%7D%0A%7D&amp;operationName=ShowExcerptIfPostHasComments&amp;variables=%7B%0A%20%20%22id%22%3A%201%0A%7D">运行ID为<code>1</code> </a>的帖子的查询会产生以下响应:</p>
<pre class="json">query ShowExcerptIfPostHasComments(
  $id: ID!,
  $_hasComments: Boolean = false
) {
  post(id: $id) {
    hasComments @export(as: "_hasComments")
  }
  self {
    post(id: $id) {
      title
      excerpt @include(if: $_hasComments)
    }
  }
}</pre>
<p><a href="https://newapi.getpop.org/graphiql/?query=query%20ShowExcerptIfPostHasComments(%0A%20%20%24id%3A%20ID!%2C%0A%20%20%24_hasComments%3A%20Boolean%20%3D%20false%0A)%20%7B%0A%20%20post(id%3A%20%24id)%20%7B%0A%20%20%20%20hasComments%20%40export(as%3A%20%22_hasComments%22)%0A%20%20%7D%0A%20%20self%20%7B%0A%20%20%20%20post(id%3A%20%24id)%20%7B%0A%20%20%20%20%20%20title%0A%20%20%20%20%20%20excerpt%20%40include(if%3A%20%24_hasComments)%0A%20%20%20%20%7D%0A%20%20%7D%0A%7D&amp;operationName=ShowExcerptIfPostHasComments&amp;variables=%7B%0A%20%20%22id%22%3A%201499%0A%7D">运行ID为<code>1499</code> </a>的帖子的查询会产生以下响应:</p>
<p>正如我们所看到的，<code>@include</code>变成了动态的:同一个查询基于被查询对象本身的某些属性产生不同的结果，而不是基于外部变量。</p>
<figure id="attachment_21239" aria-describedby="caption-attachment-21239" class="wp-caption aligncenter"><img data-attachment-id="21239" data-permalink="https://blog.logrocket.com/creating-an-export-graphql-directive/dynamic-include-first-query/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/07/dynamic-include-first-query.png" data-orig-size="901,477" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Response includes the excerpt field" data-image-description="" data-image-caption="&lt;p&gt;The response includes the excerpt field.&lt;/p&gt;&#10;" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/07/dynamic-include-first-query-300x159.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/07/dynamic-include-first-query.png" decoding="async" class="size-full wp-image-21239 jetpack-lazy-image" src="../Images/8d9cb48a691c8e3429d8067bbfc2b9ef.png" alt="Query response, which includes the excerpt field" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2020/07/dynamic-include-first-query.png 901w, https://blog.logrocket.com/wp-content/uploads/2020/07/dynamic-include-first-query-300x159.png 300w, https://blog.logrocket.com/wp-content/uploads/2020/07/dynamic-include-first-query-768x407.png 768w" data-lazy-sizes="(max-width: 901px) 100vw, 901px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2020/07/dynamic-include-first-query.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/07/dynamic-include-first-query.png"/><noscript><img data-lazy-fallback="1" data-attachment-id="21239" data-permalink="https://blog.logrocket.com/creating-an-export-graphql-directive/dynamic-include-first-query/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/07/dynamic-include-first-query.png" data-orig-size="901,477" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Response includes the excerpt field" data-image-description="" data-image-caption="&lt;p&gt;The response includes the excerpt field.&lt;/p&gt;&#10;" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/07/dynamic-include-first-query-300x159.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/07/dynamic-include-first-query.png" decoding="async" loading="lazy" class="size-full wp-image-21239" src="../Images/8d9cb48a691c8e3429d8067bbfc2b9ef.png" alt="Query response, which includes the excerpt field" srcset="https://blog.logrocket.com/wp-content/uploads/2020/07/dynamic-include-first-query.png 901w, https://blog.logrocket.com/wp-content/uploads/2020/07/dynamic-include-first-query-300x159.png 300w, https://blog.logrocket.com/wp-content/uploads/2020/07/dynamic-include-first-query-768x407.png 768w" sizes="(max-width: 901px) 100vw, 901px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/07/dynamic-include-first-query.png"/></noscript><figcaption id="caption-attachment-21239" class="wp-caption-text">The response includes the excerpt field.</figcaption></figure>
<p>只有当导出的变量——在本例中是<code>$_hasComments</code>——涉及单个值时，这个特性才起作用，但对于列表来说，这个特性不起作用。这是因为算法在同一次迭代中为列表中的所有对象评估了<code>if</code>条件，相互覆盖；然后，当检查该结果以在算法的某个后续迭代中执行<code>@skip</code> / <code>@include</code>验证时，只有列表中最后一个对象的值可用。</p>
<figure id="attachment_21241" aria-describedby="caption-attachment-21241" class="wp-caption aligncenter"><img data-attachment-id="21241" data-permalink="https://blog.logrocket.com/creating-an-export-graphql-directive/dynamic-include-second-query/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/07/dynamic-include-second-query.png" data-orig-size="901,477" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="No excerpt field" data-image-description="" data-image-caption="&lt;p&gt;The response does not include the excerpt field.&lt;/p&gt;&#10;" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/07/dynamic-include-second-query-300x159.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/07/dynamic-include-second-query.png" decoding="async" class="size-full wp-image-21241 jetpack-lazy-image" src="../Images/96acfd19f8a704a59ae270ad4a29e4b5.png" alt="The response does not include the excerpt field" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2020/07/dynamic-include-second-query.png 901w, https://blog.logrocket.com/wp-content/uploads/2020/07/dynamic-include-second-query-300x159.png 300w, https://blog.logrocket.com/wp-content/uploads/2020/07/dynamic-include-second-query-768x407.png 768w" data-lazy-sizes="(max-width: 901px) 100vw, 901px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2020/07/dynamic-include-second-query.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/07/dynamic-include-second-query.png"/><noscript><img data-lazy-fallback="1" data-attachment-id="21241" data-permalink="https://blog.logrocket.com/creating-an-export-graphql-directive/dynamic-include-second-query/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/07/dynamic-include-second-query.png" data-orig-size="901,477" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="No excerpt field" data-image-description="" data-image-caption="&lt;p&gt;The response does not include the excerpt field.&lt;/p&gt;&#10;" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/07/dynamic-include-second-query-300x159.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/07/dynamic-include-second-query.png" decoding="async" loading="lazy" class="size-full wp-image-21241" src="../Images/96acfd19f8a704a59ae270ad4a29e4b5.png" alt="The response does not include the excerpt field" srcset="https://blog.logrocket.com/wp-content/uploads/2020/07/dynamic-include-second-query.png 901w, https://blog.logrocket.com/wp-content/uploads/2020/07/dynamic-include-second-query-300x159.png 300w, https://blog.logrocket.com/wp-content/uploads/2020/07/dynamic-include-second-query-768x407.png 768w" sizes="(max-width: 901px) 100vw, 901px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/07/dynamic-include-second-query.png"/></noscript><figcaption id="caption-attachment-21241" class="wp-caption-text">The response does not include the excerpt field.</figcaption></figure>
<p>结论</p>
<p>在我的文章<a href="https://blog.logrocket.com/graphql-directives-are-underrated/"> <em> GraphQL指令被低估</em> </a>中，我表达了为定制指令提供良好的支持可能是GraphQL服务器中需要注意的最重要的特性。</p>
<h2><code>@export</code>指令提供了一个恰当的例子。因为这个指令可以提高我们的API的性能，所以社区要求将它添加到GraphQL规范中，但是由于技术上的困难，对它的支持被搁置了。然而，在找到正式的解决方案之前，我们可以尝试通过定制的指令来编码这种功能——只要GraphQL服务器允许我们这样做。</h2>
<p>在本文中，我们探讨了PoP为GraphQL完成的<code>@export</code>的实现，包括为使解决方案尽可能通用而采取的设计决策，在此过程中发现了哪些问题，以及解决这些问题需要哪些妥协(或攻击)。</p>
<p>继续多看</p>
<p>本文是正在进行的关于概念化、设计和实现GraphQL服务器的系列文章的一部分。该系列的前几篇文章是:</p>
<h2><em> <a href="https://blog.logrocket.com/designing-graphql-server-optimal-performance/" target="_blank" rel="nofollow noopener noreferrer">设计GraphQL服务器以获得最佳性能</a> </em></h2>
<p><em> <a href="https://blog.logrocket.com/simplifying-the-graphql-data-model/" target="_blank" rel="nofollow noopener noreferrer">简化GraphQL数据模型</a> </em></p>
<ol>
<li><em><a href="https://blog.logrocket.com/code-first-vs-schema-first-development-graphql/" target="_blank" rel="nofollow noopener noreferrer">graph QL中模式优先与代码优先的开发</a> </em></li>
<li><em> <a href="https://blog.logrocket.com/speeding-up-changes-to-the-graphql-schema/" target="_blank" rel="nofollow noopener noreferrer">加速对GraphQL模式的修改</a> </em></li>
<li><em><a href="https://blog.logrocket.com/versioning-fields-graphql/">graph QL中的版本控制字段</a> </em></li>
<li><em> <a href="https://blog.logrocket.com/graphql-directives-are-underrated/"> GraphQL指令被低估</a> </em></li>
<li><a href="https://blog.logrocket.com/treating-graphql-directives-as-middleware/"> <em>将GraphQL指令视为中间件</em> </a></li>
<li> </li>
<li>监控生产中失败和缓慢的GraphQL请求</li>
</ol>
<p>虽然GraphQL有一些调试请求和响应的特性，但确保GraphQL可靠地为您的生产应用程序提供资源是一件比较困难的事情。如果您对确保对后端或第三方服务的网络请求成功感兴趣，</p><div class="code-block code-block-24">
<div class="blog-plug inline-plug graphql-plug"><h2>.</h2><p>LogRocket 就像是网络和移动应用的DVR，记录下你网站上发生的每一件事。您可以汇总并报告有问题的GraphQL请求，以快速了解根本原因，而不是猜测问题发生的原因。此外，您可以跟踪Apollo客户机状态并检查GraphQL查询的键值对。</p><a href="https://lp.logrocket.com/blg/graphql-signup" target="_blank">try LogRocket</a><p>LogRocket检测您的应用程序以记录基线性能计时，如页面加载时间、到达第一个字节的时间、慢速网络请求，还记录Redux、NgRx和Vuex操作/状态。</p><a class="signup" href="https://lp.logrocket.com/blg/graphql-signup" target="_blank" rel="noopener noreferrer"><img src="../Images/432a3823c85b3fb72a206e6236a29f48.png" data-lazy-src="https://files.readme.io/69aa835-Image_2019-11-09_at_1.28.05_PM.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" class=" jetpack-lazy-image" data-original-src="https://files.readme.io/69aa835-Image_2019-11-09_at_1.28.05_PM.png"/><noscript><img data-lazy-fallback="1" src="../Images/432a3823c85b3fb72a206e6236a29f48.png" data-original-src="https://files.readme.io/69aa835-Image_2019-11-09_at_1.28.05_PM.png"/></noscript><img class="alignnone size-full wp-image-46 jetpack-lazy-image" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/><noscript><img data-lazy-fallback="1" class="alignnone size-full wp-image-46" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/></noscript></a><a href="https://lp.logrocket.com/blg/graphql-signup" target="_blank" rel="noopener noreferrer">https://logrocket.com/signup/</a><p>.</p><p>LogRocket instruments your app to record baseline performance timings such as page load time, time to first byte, slow network requests, and also logs Redux, NgRx, and Vuex actions/state. </p><a class="signup" href="https://lp.logrocket.com/blg/graphql-signup" target="_blank" rel="noopener noreferrer">Start monitoring for free</a><p>.</p></div>


</div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
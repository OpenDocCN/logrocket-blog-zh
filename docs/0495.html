<html>
<head>
<title>Creating a "Lists" PWA with React and Firebase - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>用React和Firebase - LogRocket博客创建一个“列表”PWA</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/creating-a-lists-pwa-with-react-and-firebase/#0001-01-01">https://blog.logrocket.com/creating-a-lists-pwa-with-react-and-firebase/#0001-01-01</a></blockquote><div><article class="article-post">
<p>渐进式网络应用程序(PWAs)基本上是外观和行为都像本地应用程序的网络应用程序。虽然性能不如原生应用或使用React Native、NW.js等设备特定框架构建的应用。，当您想要从现有的web代码库快速创建跨平台应用程序时，它们通常是解决方案。</p>
<p>在本教程中，我们将创建一个基于React和<a href="https://firebase.google.com"> Firebase </a>的简单PWA。该应用程序将显示一个想法列表。我们将能够在列表中添加和删除想法，它也可以离线工作。我们将选择无服务器架构，让Firebase为我们处理繁重的工作，而不是为它构建服务器。</p>
<h2>设定期望</h2>
<p>在我们继续之前，我觉得概述一下这个教程是什么和不是什么是个好主意，这样我们就都在同一个(网页)页面上了🤭。</p>
<p>本教程假设了几件事:</p>
<ul>
<li>你知道反应钩吗</li>
<li>您有一个Firebase帐户</li>
<li>你有NoSQL数据库的基本经验</li>
<li>你有时间完成这个教程(很长)</li>
</ul>
<p>您将从本教程中学到什么:</p>
<ul>
<li>如何使用Firebase Firestore实现CRD(创建、读取、删除)功能</li>
<li>如何利用Firebase的实时功能</li>
<li>如何将您的应用程序部署到Firebase</li>
<li>如何创建脱机工作的PWA</li>
</ul>
<p>从本教程中学不到的内容:</p>
<ul>
<li>React钩子如何工作</li>
<li>如何使用Firebase实现认证</li>
<li>生命和宇宙的意义</li>
</ul>
<p>我们将首先构建应用程序，当所有功能完成后，我们将把它转换成PWA。这只是为了以一种易于理解的方式组织教程。既然已经设定了预期，就该开始构建了！</p>
<p>你可以在我的GitHub上找到完成版本<a href="https://github.com/ovieokeh/lists-pwa">的源代码。</a></p>
<p>你可以在这里找到<a href="https://lists-pwa.web.app">托管版。</a></p>
<figure id="attachment_8493" aria-describedby="caption-attachment-8493" class="wp-caption aligncenter"><img data-attachment-id="8493" data-permalink="https://blog.logrocket.com/creating-a-lists-pwa-with-react-and-firebase/lists_pwa/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2019/10/lists_pwa.gif" data-orig-size="358,652" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Our finished Lists PWA" data-image-description="" data-image-caption="&lt;p&gt;Our finished app.&lt;/p&gt;&#10;" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2019/10/lists_pwa-165x300.gif" data-large-file="https://blog.logrocket.com/wp-content/uploads/2019/10/lists_pwa.gif" decoding="async" class="size-full wp-image-8493 jetpack-lazy-image" src="../Images/05f7a90e910a9e96d9fbc91f6ae2fbf8.png" alt="Our Finished Lists PWA" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2019/10/lists_pwa.gif?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/10/lists_pwa.gif"/><noscript><img data-lazy-fallback="1" data-attachment-id="8493" data-permalink="https://blog.logrocket.com/creating-a-lists-pwa-with-react-and-firebase/lists_pwa/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2019/10/lists_pwa.gif" data-orig-size="358,652" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Our finished Lists PWA" data-image-description="" data-image-caption="&lt;p&gt;Our finished app.&lt;/p&gt;&#10;" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2019/10/lists_pwa-165x300.gif" data-large-file="https://blog.logrocket.com/wp-content/uploads/2019/10/lists_pwa.gif" decoding="async" loading="lazy" class="size-full wp-image-8493" src="../Images/05f7a90e910a9e96d9fbc91f6ae2fbf8.png" alt="Our Finished Lists PWA" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/10/lists_pwa.gif"/></noscript><figcaption id="caption-attachment-8493" class="wp-caption-text">Our finished app.</figcaption></figure>
<h2>构建应用程序</h2>
<p>让我们谈一谈该应用程序的功能和组件，这样我们就知道我们正在进入什么。这个应用程序就像一个轻量级的笔记应用程序，你可以记录你一天中可能有的简短想法。你也有能力删除所说的想法。但是你不能编辑它们。</p>
<p>这款应用的另一个特点是它是实时的。如果我们都打开应用程序，我在我这边添加或删除了一个想法，你会同时获得更新，所以我们在任何给定的时间都有相同的想法列表。</p>
<p>现在，因为我们没有实现身份验证，并且因为我们共享一个数据库，所以您的想法将不是您的应用程序实例所独有的。如果您添加或删除了一个建议，连接到该应用程序的每个人都会看到您的更改。</p>
<p>我们也不会像在传统的web应用程序中那样创建自己的服务器来处理请求。相反，该应用程序将直接连接到一个数据库。如果你不知道Firestore是什么，只知道它是一个NoSQL数据库，提供即时同步。</p>
<p>欢迎使用无服务器😊。</p>
<p>所以，概括一下:</p>
<ul>
<li>没有认证(尽量简单)</li>
<li>每个人都能看到每个人的变化</li>
<li>想法在应用程序的每个实例之间实时同步</li>
<li>没有服务器</li>
</ul>
<h2>设置Firebase + React</h2>
<p>首先，我们需要在Firebase上建立一个新项目，获取我们的凭证，并为它提供一个Firestore数据库。谢天谢地，这是一个非常简单的过程，不应该超过五分钟。</p>
<p>如果您有使用Firebase的经验，请继续创建一个新项目，创建一个web应用程序，并为其提供一个Firestore数据库。否则，<a href="https://console.firebase.google.com/">创建一个Firebase帐户</a>，登录到您的控制台，并按照下面视频中的步骤进行设置。</p>
<p><span class="embed-youtube"> <iframe loading="lazy" class="youtube-player" src="https://www.youtube.com/embed/z4ag_b9tP8k?version=3&amp;rel=1&amp;showsearch=0&amp;showinfo=1&amp;iv_load_policy=1&amp;fs=1&amp;hl=en-US&amp;autohide=2&amp;wmode=transparent" allowfullscreen="true" sandbox="allow-scripts allow-same-origin allow-popups allow-presentation">视频</iframe> </span></p>
<p>请记住在过程结束时复制您的配置详细信息，并将其保存在某处以便于访问。我们以后会需要它。</p>
<p>现在我们已经完成了Firebase项目的创建，让我们在本地设置我们的项目。我将使用<a href="https://parceljs.org">包</a>来捆绑应用程序，因为它不需要任何设置，我们也不需要高级功能。</p>
<p>打开您的终端(或Windows的命令提示符)并运行以下命令:</p>
<pre>$ mkdir lists-pwa &amp;&amp; cd lists-pwa
$ npm init -y
$ npm i -S firebase react react-dom
$ npm i -D parcel parcel-bundler
$ npm install -g firebase-tools
$ mkdir src
</pre>
<p>现在，仍然在同一个目录中，运行<code>firebase login</code>并登录到您的Firebase帐户。现在完成以下步骤:</p>
<ol>
<li>运行<code>firebase init</code></li>
<li>使用空格键，选择<strong> Firestore </strong>和<strong>主持</strong>并点击回车</li>
<li>选择<strong>使用现有项目</strong>并点击回车</li>
<li>从列表中选择新创建的项目，并按enter键</li>
<li>一直按回车键，直到得到问题<code>Configure as a single-page app (rewrite all urls to /index.html)?</code>。键入<code>y</code>并按回车键</li>
</ol>
<p>有些文件会自动为您生成。打开<code>firebase.json</code>并用以下内容替换内容:</p>
<pre>{
  "firestore": {
    "rules": "firestore.rules",
    "indexes": "firestore.indexes.json"
  },
  "hosting": {
    "headers": [
      {
        "source": "/serviceWorker.js",
        "headers": [
          {
            "key": "Cache-Control",
            "value": "no-cache"
          }
        ]
      }
    ],
    "public": "build",
    "ignore": ["firebase.json", "**/.*", "**/node_modules/**"],
    "rewrites": [
      {
        "source": "**",
        "destination": "/index.html"
      }
    ]
  }
}</pre>
<p>这将为您以后在尝试将应用程序部署到Firebase时省去很多麻烦。打开生成的<code>package.json</code>，用以下内容替换脚本部分:</p>
<pre>"scripts": {
    "start": "parcel public/index.html",
    "build": "parcel build public/index.html --out-dir build --no-source-maps",
    "deploy": "npm run build &amp;&amp; firebase deploy"
  },</pre>
<h2>设置Firebase上下文</h2>
<p>如果你没有React Context API的经验，这里有一个很棒的教程<a href="https://www.toptal.com/react/react-context-api">详细解释了它</a>。它只是允许我们将数据从父组件传递到子组件，而不需要使用<code>props</code>。这在处理嵌套在多个层中的子元素时非常有用。</p>
<p>在<code>src</code>文件夹中，创建另一个名为<code>firebase</code>的文件夹，并创建以下文件:</p>
<ol>
<li><code>config.js</code></li>
<li><code>index.js</code></li>
<li><code>withFirebase.jsx</code></li>
</ol>
<p>打开<code>config.js</code>并粘贴到您之前在设置Firebase项目时复制的Firebase配置文件中，但是在它之前添加一个<code>export</code>关键字:</p>
<pre>export const firebaseConfig = {
  apiKey: REPLACE_WITH_YOURS,
  authDomain: REPLACE_WITH_YOURS,
  databaseURL: REPLACE_WITH_YOURS,
  projectId: REPLACE_WITH_YOURS,
  storageBucket: REPLACE_WITH_YOURS,
  messagingSenderId: REPLACE_WITH_YOURS,
  appId: REPLACE_WITH_YOURS
}</pre>
<p>初始化Firebase时需要此配置文件。</p>
<p><strong>注意</strong>:我们没有为我们的Firestore数据库创建<a href="https://firebase.google.com/docs/firestore/security/get-started">安全规则</a>，这意味着任何使用该应用程序的人都将对您的项目拥有读/写权限。你肯定不希望这样，所以请研究安全规则，并相应地保护你的应用程序。</p>
<p>打开<code>index.js</code>并粘贴以下内容:</p>
<pre>import { createContext } from 'react'
import FirebaseApp from 'firebase/app'
import 'firebase/firestore'

import { firebaseConfig } from './config'

class Firebase {
  constructor() {
    if (!FirebaseApp.apps.length) {
      FirebaseApp.initializeApp(firebaseConfig)
      FirebaseApp.firestore()
        .enablePersistence({ synchronizeTabs: true })
        .catch(err =&gt; console.log(err))
    }

    // instance variables
    this.db = FirebaseApp.firestore()
    this.ideasCollection = this.db.collection('ideas')
  }
}

const FirebaseContext = createContext(null)

export { Firebase, FirebaseContext, FirebaseApp }</pre>
<p>这是一个非常简单的文件。我们正在创建一个类<code>Firebase</code>，它将保存我们的Firebase实例。</p>
<p>在构造函数内部，我们首先检查当前是否有任何Firebase实例正在运行。如果没有，我们使用刚刚创建的配置初始化Firebase，然后在Firestore实例上启用持久性。这使得我们的数据库即使在离线时也可用，并且当你的应用上线时，数据与实时数据库同步。</p>
<p>然后我们创建两个实例变量:<code>db</code>和<code>ideasCollection</code>。这将允许我们从React组件中与数据库进行交互。</p>
<p>然后，我们创建一个初始值为null的新上下文，并将其赋给一个名为<code>FirebaseContext</code>的变量。然后，在文件的结尾，我们导出<code>{ Firebase, FirebaseContext, FirebaseApp }</code>。</p>
<p>打开<code>withFirebase.jsx</code>并粘贴以下内容:</p>
<pre>import React from 'react'
import { FirebaseContext } from '.'

export const withFirebase = Component =&gt; props =&gt; (
  &lt;FirebaseContext.Consumer&gt;
    {firebase =&gt; &lt;Component {...props} firebase={firebase} /&gt;}
  &lt;/FirebaseContext.Consumer&gt;
)</pre>
<p>这是一个<a href="https://reactjs.org/docs/higher-order-components.html">高阶组件</a>，它将向作为参数传递给它的任何组件提供我们在上面创建的Firebase实例。这只是为了方便起见，所以你不需要<em>来使用它，但是我建议你这样做以使你的代码更容易推理。</em></p>
<h2>编写我们的组件</h2>
<p>好了，我们现在完成了与Firebase相关的所有工作。让我们编写组件代码，并在屏幕上显示一些东西！</p>
<p><strong>注意</strong>:为了让本教程集中在主要主题上(React、Firebase、PWA)，我不打算包括样式的CSS。你可以从<a href="https://github.com/ovieokeh/lists-pwa">回购这里</a>。</p>
<p>在<code>src</code>中创建一个名为<code>components</code>的新文件夹。在这个文件夹中，我们只有两个组件:<code>App.jsx</code>和<code>Idea.jsx</code>。</p>
<p>在这里，<code>App</code>组件将完成繁重的工作，因为它将负责与数据库进行实际交互，以获取想法列表、添加新想法和删除现有想法。</p>
<p><code>Idea</code>组件是一个简单的组件，只显示一个想法。但是，在我们开始为这些组件编写代码之前，我们必须先做一些事情。</p>
<p>打开<code>public/index.html</code>并用以下内容替换内容:</p>
<pre>&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
  &lt;head&gt;
    &lt;meta charset="utf-8" /&gt;
    &lt;meta name="viewport" content="width=device-width, initial-scale=1" /&gt;
    &lt;title&gt;Lists PWA&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;noscript&gt;You need to enable JavaScript to run this app.&lt;/noscript&gt;
    &lt;div id="root"&gt;&lt;/div&gt;
    &lt;script src="../src/index.js"&gt;&lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;</pre>
<p>在<code>src</code>文件夹下，创建一个新文件<code>index.js</code>，打开它，粘贴如下内容:</p>
<pre>import React from 'react'
import ReactDOM from 'react-dom'
import App from './components/App'
import { FirebaseContext, Firebase } from './firebase'

const rootNode = document.querySelector('#root')

ReactDOM.render(
  &lt;FirebaseContext.Provider value={new Firebase()}&gt;
    &lt;App /&gt;
  &lt;/FirebaseContext.Provider&gt;,
  rootNode
)</pre>
<p>我们只是用我们之前创建的Firebase上下文包装我们的<code>App</code>组件，给出我们定义的Firebase类的一个实例的值，并呈现给DOM。这将使我们的应用程序中的所有组件都可以访问Firebase实例，这样它们就可以通过我们的HOC直接与数据库交互，我们很快就会看到这一点。</p>
<p>现在让我们编写组件代码。我们将从<code>Idea.jsx</code>开始，因为它更简单，移动部件更少。</p><div class="code-block code-block-54">
<hr/>
<h3>更多来自LogRocket的精彩文章:</h3>

<hr/></div>
<h2><code>Idea.jsx</code></h2>
<pre>import React from 'react'
import './Idea.less'
const Idea = ({ idea, onDelete }) =&gt; (
  &lt;div className="app__content__idea"&gt;
    &lt;p className="app__content__idea__text"&gt;{idea.content}&lt;/p&gt;
    &lt;button
      type="button"
      className="app__btn app__content__idea__btn"
      id={idea.id}
      onClick={onDelete}
    &gt;
      –
    &lt;/button&gt;
  &lt;/div&gt;
)

export default Idea</pre>
<p>这是一个非常简单的组件。它所做的只是返回一个<code>div</code>,其中包含一些从其props接收的内容——这里没有什么可看的。从这里可以得到<code>Idea.less</code>T2的代码。</p>
<p><strong>注意</strong>:如果你用的是我的Less风格，在<code>src</code>下新建一个名为<code>variables.less</code>的文件，从这里获取内容<a href="https://github.com/ovieokeh/lists-pwa/blob/master/src/variables.less">。否则，事情可能看起来不对。</a></p>
<p>让我们继续一些更令人兴奋的事情。</p>
<h2><code>App.jsx</code></h2>
<p>这是一个大得多的组件，所以我们将一点一点地分解它。</p>
<p>PS，你可以从这里得到<code>App.less</code> <a href="https://github.com/ovieokeh/lists-pwa/blob/master/src/components/App.less">的代码。</a></p>
<pre>import React, { useState, useEffect, useRef } from 'react'
import Idea from './Idea'
import { withFirebase } from '../firebase/withFirebase'
import './App.less'

const App = props =&gt; {
  const { ideasCollection } = props.firebase
  const ideasContainer = useRef(null)
  const [idea, setIdeaInput] = useState('')
  const [ideas, setIdeas] = useState([])

  useEffect(() =&gt; {
    const unsubscribe = ideasCollection
      .orderBy('timestamp', 'desc')
      .onSnapshot(({ docs }) =&gt; {
        const ideasFromDB = []

        docs.forEach(doc =&gt; {
          const details = {
            id: doc.id,
            content: doc.data().idea,
            timestamp: doc.data().timestamp
          }

          ideasFromDB.push(details)
        })

        setIdeas(ideasFromDB)
      })

    return () =&gt; unsubscribe()
  }, [])

...to be continued below...</pre>
<h3>设置</h3>
<p>好吧，让我们过一遍。马上，我们从从<code>withFirebase</code> HOC获取的Firebase实例中检索<code>ideasCollection</code>实例变量(我们将组件包装在文件的末尾)。</p>
<p>然后我们创建一个新的对<code>section</code> HTML元素的引用，它将保存来自数据库的想法列表(我们为什么这样做一会儿就清楚了)。我们还创建了两个状态变量，<code>idea</code>用于保存受控HTML输入元素的值，<code>ideas</code>用于保存数据库中的想法列表。</p>
<h3>效果</h3>
<p>然后我们创建一个<code>useEffect</code>钩子，大部分魔法都在这里发生。在这个钩子中，我们引用了<code>ideasCollection</code>中的文档集合，按照时间戳降序排列其中的文档，并为其附加了一个<code>onSnapShot</code>事件监听器。</p>
<p>这个<a href="https://firebase.google.com/docs/firestore/query-data/listen">监听器监听集合上的变化</a>(创建、更新、删除)，并在每次检测到变化时调用更新的数据。</p>
<p>我们初始化一个新的空数组<code>ideasFromDB</code>，对于来自数据库的每个文档(例如，idea)，我们创建一个<code>details</code>对象来保存它的信息，并将该对象推送到<code>ideasFromDB</code>。</p>
<p>当我们完成所有想法的迭代后，我们用<code>ideasFromDB</code>更新<code>ideas</code>状态变量。然后，在<code>useEffect</code>调用结束时，我们通过调用函数<code>unsubscribe</code>取消对数据库监听的订阅，以避免内存泄漏。</p>
<pre>...continuation...

const onIdeaDelete = event =&gt; {
  const { id } = event.target
  ideasCollection.doc(id).delete()
}

const onIdeaAdd = event =&gt; {
  event.preventDefault()

  if (!idea.trim().length) return

  setIdeaInput('')
  ideasContainer.current.scrollTop = 0 // scroll to top of container

  ideasCollection.add({
    idea,
    timestamp: new Date()
  })
}

const renderIdeas = () =&gt; {
  if (!ideas.length)
    return &lt;h2 className="app__content__no-idea"&gt;Add a new Idea...&lt;/h2&gt;

  return ideas.map(idea =&gt; (
    &lt;Idea key={idea.id} idea={idea} onDelete={onIdeaDelete} /&gt;
  ))
}

...to be continued below...</pre>
<p>接下来的代码要简单一些。让我们一个功能一个功能地过一遍。</p>
<h3><code>onIdeaDelete</code></h3>
<p>这个函数处理删除一个想法。它是一个回调函数，传递给附加到删除按钮上的<code>onClick</code>处理程序，每一个想法都被呈现到DOM中。这也很简单。</p>
<p>每个创意上的所有删除按钮都有一个唯一的ID，这也是Firestore数据库中创意的唯一ID。因此，当按钮被单击时，我们从<code>event.target</code>对象中获得这个ID，在<code>ideasCollection</code>集合中定位具有该ID的文档，并在其上调用一个delete方法。</p>
<p>这将从数据库中的想法集合中删除该想法，由于我们在<code>useEffect</code>调用中监听该集合的变化，这将导致<code>onSnapShot</code>监听器被触发。这反过来用新的想法列表减去我们刚刚删除的想法列表来更新我们的状态🤯。</p>
<p>Firebase不就是牛逼吗？</p>
<h3><code>onIdeaAdd</code></h3>
<p>该功能与<code>onIdeaDelete</code>功能正好相反。这是一个传递给附加在表单上的<code>onSubmit</code>处理程序的回调函数，该表单包含您添加新想法的输入。</p>
<p>首先，我们防止表单提交的默认行为，并检查输入是否为空。如果是，则在那里结束执行；否则，继续。然后，我们清除输入值，以允许添加新的想法。</p>
<p>还记得我们在设置中初始化的HTML section元素的引用吗？这就是我们需要它的原因。如果有太多的想法不能一次显示在屏幕上，我们可以向下滚动来查看旧的。</p>
<p>当在这个滚动位置时，如果我们添加一个新的想法，我们希望滚动到容器的顶部来查看最新的想法，因此我们将保存想法的section元素的<code>scrollTop</code>设置为<code>0</code>。这具有滚动到HTML section元素顶部的效果。</p>
<p>最后，我们引用数据库中的想法集合，<code>ideasCollection</code>，并在其上调用<code>add</code>方法。我们传递给它一个对象，该对象包含来自输入元素的值和当前日期的时间戳。</p>
<p>这将再次触发我们的<code>onSnapShot</code>监听器更新我们的想法列表，以便ideas状态变量得到更新以包含我们刚刚添加的最新想法。</p>
<h3><code>renderIdeas</code></h3>
<p>这个函数完全按照它在tin上显示的那样工作。它负责将所有想法呈现给DOM。</p>
<p>我们检查是否有任何想法可以呈现。如果没有，我们返回一个带有文本的<code>h2</code>元素:“添加一个新想法……”否则，我们映射想法的数组，对于每个想法，返回我们之前创建的哑<code>Idea</code>组件，并向其传递所需的道具。</p>
<p>这里没什么可看的。</p>
<pre>...continuation...

  return (
    &lt;div className="app"&gt;
      &lt;header className="app__header"&gt;
        &lt;h1 className="app__header__h1"&gt;Idea Box&lt;/h1&gt;
      &lt;/header&gt;

      &lt;section ref={ideasContainer} className="app__content"&gt;
        {renderIdeas()}
      &lt;/section&gt;

      &lt;form className="app__footer" onSubmit={onIdeaAdd}&gt;
        &lt;input
          type="text"
          className="app__footer__input"
          placeholder="Add a new idea"
          value={idea}
          onChange={e =&gt; setIdeaInput(e.target.value)}
        /&gt;
        &lt;button type="submit" className="app__btn app__footer__submit-btn"&gt;
          +
        &lt;/button&gt;
      &lt;/form&gt;
    &lt;/div&gt;
  )
}

export default withFirebase(App)</pre>
<p>这里的最后一段代码是返回JSX的返回语句。</p>
<p>在文件的最后，我们有一个默认的导出，导出用<code>withFirebase</code> HOC包装的<code>App</code>组件。这就是将<code>firebase</code>作为道具注入组件的原因。</p>
<p>假设您从我的GitHub repo中为这两个组件复制了相应的<code>.less</code>文件，那么现在您就有了一个功能完整的应用程序。在你的终端中，运行<code>npm start</code>并从浏览器中打开<code><a href="http://localhost:1234" rel="nofollow">http://localhost:1234</a></code>。</p>
<p>您应该看到您的应用程序正在运行。补充一个想法。删除它。打开另一个浏览器窗口，从那里添加一个想法。注意这两个窗口是如何自动同步的？这是Firebase完美完成的工作🔥。</p>
<p>我继续前进，并添加了一个主题切换器，因为为什么不呢？如果你想做同样的事情，从这里克隆<a href="https://github.com/ovieokeh/lists-pwa"> repo。</a></p>
<p>您可以通过运行<code>npm run deploy</code>将您的应用程序部署到Firebase。</p>
<h2>将应用程序转换为渐进式网络应用程序</h2>
<p>如果你一直遵循这个教程，你就是一个摇滚明星⭐，你应该得到一枚金牌。我们已经完成了创建实际应用程序的大部分艰苦工作，现在剩下的就是将其转换为PWA并使其离线工作。</p>
<p>但要做到这一点，我们需要了解PWAs的两个关键组成部分:</p>
<ol>
<li>Web应用程序清单</li>
<li>服务人员</li>
</ol>
<h3>web应用程序清单</h3>
<p>不要被“web app manifest”这个听起来令人印象深刻的名字所迷惑。这是一个相当简单的概念，我将让谷歌为您解释它:</p>
<blockquote><p>“<a href="https://developer.mozilla.org/en-US/docs/Web/Manifest"> web应用程序清单</a>是一个简单的JSON文件，它告诉浏览器关于您的web应用程序，以及当它‘安装’在用户的移动设备或桌面上时应该如何运行。Chrome需要一个清单来显示<a href="https://developers.google.com/web/fundamentals/app-install-banners/">添加到主屏幕提示</a>。</p>
<p>一个典型的清单文件包括关于它应该使用的应用程序<code>name</code>、<code>icons</code>、启动时应该启动的<code>start_url</code>等信息。"</p></blockquote>
<p>当我们创建一个manifest文件时，我们从我们的<code>index.html</code>文件的头部链接到它，以便浏览器可以拾取它并使用它。以下是您可以使用清单文件配置的应用程序的一些最重要的属性:</p>
<ul>
<li><code>name</code>:这是应用程序安装提示上使用的名称</li>
<li>这是在你的用户的主屏幕、启动器和空间有限的地方使用的名称。它是可选的</li>
<li>这是一个image对象的数组，表示在主屏幕、闪屏等地方使用的图标。对于不同的屏幕分辨率，每个对象通常是对同一图标的不同大小的引用</li>
<li>这告诉你的浏览器你的应用程序在安装时应该默认使用哪个URL</li>
<li>这告诉你的浏览器你的应用应该看起来像本地应用、浏览器应用还是全屏应用</li>
</ul>
<p>您可以在这里找到<a href="https://developers.google.com/web/fundamentals/web-app-manifest#key_manifest_properties">可配置属性的完整列表。</a></p>
<h2 id="serviceworkers">服务人员</h2>
<p>服务人员更复杂，但非常强大。除了推送通知、后台同步等其他功能之外，它们使得离线网络体验成为可能。但是它们到底是什么呢？</p>
<p>简单地说，服务工作者是一个JavaScript脚本(我们需要为JS取一个新名字🤦)在后台运行，与网页分开。服务人员有点复杂，所以我们不会在这里一一介绍。相反，你可以在<a href="https://developers.google.com/web/fundamentals/primers/service-workers">谷歌开发者网站</a>上阅读更多关于它们的内容，当你完成后，你可以回到这里获得它们的实际体验。</p>
<p>我假设你确实访问了上面的Google开发者链接，因为我们将使用一些你可能不熟悉的概念。如果这是你第一次与服务人员一起工作，请，如果你没有阅读它，现在是时候这样做了。</p>
<p>准备好了吗？我们能继续了吗？太好了。</p>
<h2>使用Lighthouse审核应用程序</h2>
<p>为了使开发PWA的过程尽可能简单和无缝，我们将使用一个名为Lighthouse的工具来审计我们的应用程序，以便我们确切地知道我们需要做什么来创建一个功能齐全的PWA。</p>
<p>如果你已经使用Chrome浏览器，那么你的浏览器中已经安装了Lighthouse。否则，你可能需要安装Chrome来跟进。</p>
<ol>
<li>通过运行<code>npm start</code>启动您的应用程序</li>
<li>在你的Chrome浏览器中打开应用程序</li>
<li>在Mac上点击<code>COMMAND + OPTION + J</code>，在Windows上点击<code>CTRL + SHIFT + J</code>，打开开发者工具</li>
<li>打开<strong>审计</strong>标签，勾选<strong>渐进式网络应用</strong>复选框，然后点击<strong>运行审计</strong>如下:<br/> <img data-attachment-id="8497" data-permalink="https://blog.logrocket.com/creating-a-lists-pwa-with-react-and-firebase/lighthouse-audit/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2019/10/lighthouse-audit-e1571404711618.png" data-orig-size="730,890" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Lighthouse audit page" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2019/10/lighthouse-audit-246x300.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2019/10/lighthouse-audit-840x1024.png" decoding="async" class="aligncenter size-full wp-image-8497 jetpack-lazy-image" src="../Images/27232b9c7ad8f26351626e0580808b7a.png" alt="Lighthouse Audit Page" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2019/10/lighthouse-audit-e1571404711618.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/10/lighthouse-audit-e1571404711618.png"/> <noscript> <img data-lazy-fallback="1" data-attachment-id="8497" data-permalink="https://blog.logrocket.com/creating-a-lists-pwa-with-react-and-firebase/lighthouse-audit/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2019/10/lighthouse-audit-e1571404711618.png" data-orig-size="730,890" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Lighthouse audit page" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2019/10/lighthouse-audit-246x300.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2019/10/lighthouse-audit-840x1024.png" decoding="async" loading="lazy" class="aligncenter size-full wp-image-8497" src="../Images/27232b9c7ad8f26351626e0580808b7a.png" alt="Lighthouse Audit Page" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/10/lighthouse-audit-e1571404711618.png"/> </noscript></li>
</ol>
<p>你应该会得到一个可怕的结果，但这是意料之中的，因为我们没有做任何事情来使这个应用程序成为PWA。请注意<strong> PWA优化的</strong>部分，因为这是我们首先要解决的问题。</p>
<figure id="attachment_8520" aria-describedby="caption-attachment-8520" class="wp-caption aligncenter"><img data-attachment-id="8520" data-permalink="https://blog.logrocket.com/creating-a-lists-pwa-with-react-and-firebase/lighthouse-pwa-optimize-fail/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2019/10/lighthouse-pwa-optimize-fail.png" data-orig-size="689,336" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Lighthouse PWA Optimized score" data-image-description="" data-image-caption="&lt;p&gt;What a horrible score 🤮&lt;/p&gt;&#10;" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2019/10/lighthouse-pwa-optimize-fail-300x146.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2019/10/lighthouse-pwa-optimize-fail.png" decoding="async" class="size-full wp-image-8520 jetpack-lazy-image" src="../Images/ed9f0f8290670637b6f20e468a9ab8d6.png" alt="Lighthouse PWA Optimized Score" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2019/10/lighthouse-pwa-optimize-fail.png 689w, https://blog.logrocket.com/wp-content/uploads/2019/10/lighthouse-pwa-optimize-fail-300x146.png 300w" data-lazy-sizes="(max-width: 689px) 100vw, 689px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2019/10/lighthouse-pwa-optimize-fail.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/10/lighthouse-pwa-optimize-fail.png"/><noscript><img data-lazy-fallback="1" data-attachment-id="8520" data-permalink="https://blog.logrocket.com/creating-a-lists-pwa-with-react-and-firebase/lighthouse-pwa-optimize-fail/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2019/10/lighthouse-pwa-optimize-fail.png" data-orig-size="689,336" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Lighthouse PWA Optimized score" data-image-description="" data-image-caption="&lt;p&gt;What a horrible score 🤮&lt;/p&gt;&#10;" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2019/10/lighthouse-pwa-optimize-fail-300x146.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2019/10/lighthouse-pwa-optimize-fail.png" decoding="async" loading="lazy" class="size-full wp-image-8520" src="../Images/ed9f0f8290670637b6f20e468a9ab8d6.png" alt="Lighthouse PWA Optimized Score" srcset="https://blog.logrocket.com/wp-content/uploads/2019/10/lighthouse-pwa-optimize-fail.png 689w, https://blog.logrocket.com/wp-content/uploads/2019/10/lighthouse-pwa-optimize-fail-300x146.png 300w" sizes="(max-width: 689px) 100vw, 689px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/10/lighthouse-pwa-optimize-fail.png"/></noscript><figcaption id="caption-attachment-8520" class="wp-caption-text">What a horrible score 🤮</figcaption></figure>
<p>我们开始吧，好吗？</p>
<h2>设置清单文件</h2>
<p>让我们从web应用程序清单文件开始。这通常是一个链接到<code>index.html</code>文件的<code>manifest.json</code>文件，但是由于<a href="https://github.com/parcel-bundler/parcel/issues/235">包的工作方式</a>，我们将不使用<code>.json</code>扩展名。相反，我们将使用一个<code>.webmanifest</code>扩展，但是内容将保持不变。</p>
<p>在<code>public</code>文件夹中，创建一个名为<code>manifest.webmanifest</code>的新文件，并将以下内容粘贴到其中:</p>
<pre>{
  "name": "Lists PWA",
  "short_name": "Idea!",
  "icons": [
    {
      "src": "./icons/icon-128x128.png",
      "type": "image/png",
      "sizes": "128x128"
    },
    {
      "src": "./icons/icon-256x256.png",
      "type": "image/png",
      "sizes": "256x256"
    },
    {
      "src": "./icons/icon-512x512.png",
      "type": "image/png",
      "sizes": "512x512"
    }
  ],
  "start_url": ".",
  "display": "standalone",
  "background_color": "#333",
  "theme_color": "#39c16c",
  "orientation": "portrait"
}</pre>
<p>注意，在<code>"icons"</code>部分，我们链接到了<code>/icons</code>文件夹下的<code>.png</code>文件。你可以从<a href="https://github.com/ovieokeh/lists-pwa/tree/master/public/icons"> GitHub repo这里</a>获得这些图片，或者你可以选择使用自定义图片。其他的事情应该是不言自明的。</p>
<p>现在让我们对<code>index.html</code>文件做一些修改。打开文件，将以下内容添加到<code>&lt;head&gt;</code>部分:</p>
<pre>&lt;link rel="shortcut icon" href="icons/icon-128x128.png" /&gt;
&lt;link rel="manifest" href="manifest.webmanifest" /&gt;
&lt;link rel="apple-touch-icon" href="icons/icon-512x512.png" /&gt;
&lt;meta name="apple-mobile-web-app-capable" content="yes" /&gt;
&lt;meta name="apple-mobile-web-app-status-bar-style" content="black" /&gt;
&lt;meta name="apple-mobile-web-app-title" content="Lists PWA" /&gt;
&lt;meta name="theme-color" content="#39c16c" /&gt;
&lt;meta name="description" content="Lists PWA with React" /&gt;</pre>
<p>事情是这样的:</p>
<ol>
<li>我们添加了一个快捷方式图标，显示在浏览器选项卡标题中</li>
<li>我们链接到刚刚创建的清单文件</li>
<li>因为iOS上的Safari还不支持web应用清单，所以我们添加了一些传统的meta标签来弥补(任何以<code>apple</code>为前缀的标签)</li>
<li>我们给浏览器的地址栏添加了一个主题颜色，以匹配我们偏好的品牌颜色</li>
<li>最后，我们添加了对我们的应用程序的简短描述</li>
</ol>
<p>好了，现在把你的跑步app杀掉，重新启动，我们再来运行一次灯塔审计，看看现在得到了什么。</p>
<figure id="attachment_8522" aria-describedby="caption-attachment-8522" class="wp-caption aligncenter"><img data-attachment-id="8522" data-permalink="https://blog.logrocket.com/creating-a-lists-pwa-with-react-and-firebase/pwa-optimized-updates/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2019/10/pwa-optimized-updates.png" data-orig-size="688,314" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Updated PWA Optimized score" data-image-description="" data-image-caption="&lt;p&gt;Much better!&lt;/p&gt;&#10;" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2019/10/pwa-optimized-updates-300x137.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2019/10/pwa-optimized-updates.png" decoding="async" class="size-full wp-image-8522 jetpack-lazy-image" src="../Images/84e32d8af114152d8cc39299b72c4247.png" alt="Updated PWA Optimized Score" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2019/10/pwa-optimized-updates.png 688w, https://blog.logrocket.com/wp-content/uploads/2019/10/pwa-optimized-updates-300x137.png 300w" data-lazy-sizes="(max-width: 688px) 100vw, 688px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2019/10/pwa-optimized-updates.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/10/pwa-optimized-updates.png"/><noscript><img data-lazy-fallback="1" data-attachment-id="8522" data-permalink="https://blog.logrocket.com/creating-a-lists-pwa-with-react-and-firebase/pwa-optimized-updates/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2019/10/pwa-optimized-updates.png" data-orig-size="688,314" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Updated PWA Optimized score" data-image-description="" data-image-caption="&lt;p&gt;Much better!&lt;/p&gt;&#10;" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2019/10/pwa-optimized-updates-300x137.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2019/10/pwa-optimized-updates.png" decoding="async" loading="lazy" class="size-full wp-image-8522" src="../Images/84e32d8af114152d8cc39299b72c4247.png" alt="Updated PWA Optimized Score" srcset="https://blog.logrocket.com/wp-content/uploads/2019/10/pwa-optimized-updates.png 688w, https://blog.logrocket.com/wp-content/uploads/2019/10/pwa-optimized-updates-300x137.png 300w" sizes="(max-width: 688px) 100vw, 688px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/10/pwa-optimized-updates.png"/></noscript><figcaption id="caption-attachment-8522" class="wp-caption-text">Much better!</figcaption></figure>
<p>请注意，我们现在在<strong> PWA优化</strong>部分获得了几乎完美的分数。<strong>不会将HTTP流量重定向到HTTPS </strong>无法在本地主机模式下修复。如果你在Firebase上运行测试，这应该也能通过。</p>
<p>仍然在浏览器控制台中，切换到<strong>应用程序</strong>选项卡，点击<strong>应用程序</strong>部分下的<strong>清单</strong>。您应该在这里看到来自<code>manifest.webmanifest</code>文件的详细信息，如下所示:</p>
<p><img data-attachment-id="8524" data-permalink="https://blog.logrocket.com/creating-a-lists-pwa-with-react-and-firebase/app-manifest-chrome-devtools/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2019/10/app-manifest-chrome-devtools.png" data-orig-size="730,481" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="App manifest page in Chrome DevTools" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2019/10/app-manifest-chrome-devtools-300x198.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2019/10/app-manifest-chrome-devtools.png" decoding="async" class="aligncenter size-full wp-image-8524 jetpack-lazy-image" src="../Images/722576d990198dd5c265d962846f906e.png" alt="App Manifest Page In Chrome DevTools" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2019/10/app-manifest-chrome-devtools.png 730w, https://blog.logrocket.com/wp-content/uploads/2019/10/app-manifest-chrome-devtools-300x198.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2019/10/app-manifest-chrome-devtools.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/10/app-manifest-chrome-devtools.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="8524" data-permalink="https://blog.logrocket.com/creating-a-lists-pwa-with-react-and-firebase/app-manifest-chrome-devtools/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2019/10/app-manifest-chrome-devtools.png" data-orig-size="730,481" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="App manifest page in Chrome DevTools" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2019/10/app-manifest-chrome-devtools-300x198.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2019/10/app-manifest-chrome-devtools.png" decoding="async" loading="lazy" class="aligncenter size-full wp-image-8524" src="../Images/722576d990198dd5c265d962846f906e.png" alt="App Manifest Page In Chrome DevTools" srcset="https://blog.logrocket.com/wp-content/uploads/2019/10/app-manifest-chrome-devtools.png 730w, https://blog.logrocket.com/wp-content/uploads/2019/10/app-manifest-chrome-devtools-300x198.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/10/app-manifest-chrome-devtools.png"/></noscript>
<p>我们已经确认我们的清单文件工作正常，所以让我们修复Lighthouse PWA审计中的其他问题:</p>
<p><img data-attachment-id="8525" data-permalink="https://blog.logrocket.com/creating-a-lists-pwa-with-react-and-firebase/lighthouse-pwa-audit-issues/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2019/10/lighthouse-pwa-audit-issues.png" data-orig-size="688,384" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Remaining Lighthouse PWA audit issues" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2019/10/lighthouse-pwa-audit-issues-300x167.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2019/10/lighthouse-pwa-audit-issues.png" decoding="async" class="aligncenter size-full wp-image-8525 jetpack-lazy-image" src="../Images/6961a5b1468cf735466728b1979aa24c.png" alt="Remaining Lighthouse PWA Audit Issues" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2019/10/lighthouse-pwa-audit-issues.png 688w, https://blog.logrocket.com/wp-content/uploads/2019/10/lighthouse-pwa-audit-issues-300x167.png 300w" data-lazy-sizes="(max-width: 688px) 100vw, 688px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2019/10/lighthouse-pwa-audit-issues.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/10/lighthouse-pwa-audit-issues.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="8525" data-permalink="https://blog.logrocket.com/creating-a-lists-pwa-with-react-and-firebase/lighthouse-pwa-audit-issues/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2019/10/lighthouse-pwa-audit-issues.png" data-orig-size="688,384" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Remaining Lighthouse PWA audit issues" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2019/10/lighthouse-pwa-audit-issues-300x167.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2019/10/lighthouse-pwa-audit-issues.png" decoding="async" loading="lazy" class="aligncenter size-full wp-image-8525" src="../Images/6961a5b1468cf735466728b1979aa24c.png" alt="Remaining Lighthouse PWA Audit Issues" srcset="https://blog.logrocket.com/wp-content/uploads/2019/10/lighthouse-pwa-audit-issues.png 688w, https://blog.logrocket.com/wp-content/uploads/2019/10/lighthouse-pwa-audit-issues-300x167.png 300w" sizes="(max-width: 688px) 100vw, 688px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/10/lighthouse-pwa-audit-issues.png"/></noscript>
<ul>
<li><strong>快速可靠</strong>:在移动网络上，页面加载速度不够快</li>
<li><strong>快速可靠</strong>:当前页面离线时没有200响应</li>
<li><strong>快速可靠</strong> : <code>start_url</code>离线时无200响应</li>
<li><strong> Installable </strong>:不注册控制页面和start_url的服务人员</li>
</ul>
<h2>设置服务人员</h2>
<p>为了修复上面列出的问题，我们需要向应用程序添加一个服务工作者(为了保持头脑清醒，从现在开始我将简称为SW)。注册软件后，我们将缓存所有需要的文件，以便能够离线提供服务。</p>
<p><strong>注意</strong>:为了让事情变得更简单，我建议在本教程的剩余部分用匿名标签打开你的应用程序。这是由<a href="https://developers.google.com/web/fundamentals/primers/service-workers/lifecycle">软件生命周期</a>的性质决定的。(你有没有像我问的那样访问过<a href="https://developers.google.com/web/fundamentals/primers/service-workers">那个链接？</a>)</p>
<h3>注册服务人员</h3>
<p>在<code>public</code>文件夹下，创建一个名为<code>serviceWorker.js</code>的新文件，并暂时粘贴以下内容:<code>console.log('service worker registered')</code>。</p>
<p>现在打开<code>index.html</code>文件并添加一个新脚本:</p>
<pre>&lt;script&gt;
  if ('serviceWorker' in navigator) {
    window.addEventListener('load', () =&gt; {
      navigator.serviceWorker.register('serviceWorker.js');
    });
  }
&lt;/script&gt;</pre>
<p>我们来剖析一下这个脚本。我们正在检查当前的浏览器是否支持SWs ( <a href="https://jakearchibald.github.io/isserviceworkerready/"> SW支持</a>)，如果支持，我们向窗口对象添加一个<code>'load'</code>事件监听器。</p>
<p>一旦窗口被加载，我们告诉浏览器在位置<code>serviceWorker.js</code>注册SW文件。你可以把你的软件文件放在任何地方，但是我喜欢把它放在<code>public</code>文件夹里。</p>
<p>保存您的更改，在匿名模式下重新启动您的应用程序，然后打开控制台。您应该会看到记录的消息<code>service worker registered</code>。太好了。现在打开DevTools中的<strong>应用程序</strong>选项卡，点击<strong>服务人员</strong>。你应该看到我们的新软件运行。</p>
<p><img data-attachment-id="8526" data-permalink="https://blog.logrocket.com/creating-a-lists-pwa-with-react-and-firebase/service-worker-running-chrome-devtools/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2019/10/service-worker-running-chrome-devtools.png" data-orig-size="730,397" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Service worker running" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2019/10/service-worker-running-chrome-devtools-300x163.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2019/10/service-worker-running-chrome-devtools.png" decoding="async" class="aligncenter size-full wp-image-8526 jetpack-lazy-image" src="../Images/ed9d748de659d18e40da9a8686eb65d5.png" alt="Service Worker Running" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2019/10/service-worker-running-chrome-devtools.png 730w, https://blog.logrocket.com/wp-content/uploads/2019/10/service-worker-running-chrome-devtools-300x163.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2019/10/service-worker-running-chrome-devtools.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/10/service-worker-running-chrome-devtools.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="8526" data-permalink="https://blog.logrocket.com/creating-a-lists-pwa-with-react-and-firebase/service-worker-running-chrome-devtools/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2019/10/service-worker-running-chrome-devtools.png" data-orig-size="730,397" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Service worker running" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2019/10/service-worker-running-chrome-devtools-300x163.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2019/10/service-worker-running-chrome-devtools.png" decoding="async" loading="lazy" class="aligncenter size-full wp-image-8526" src="../Images/ed9d748de659d18e40da9a8686eb65d5.png" alt="Service Worker Running" srcset="https://blog.logrocket.com/wp-content/uploads/2019/10/service-worker-running-chrome-devtools.png 730w, https://blog.logrocket.com/wp-content/uploads/2019/10/service-worker-running-chrome-devtools-300x163.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/10/service-worker-running-chrome-devtools.png"/></noscript>
<p>现在，我们的软件正在运行，但是有点没用。让我们给它增加一些功能。</p>
<p>所以这是我们需要做的:</p>
<ol>
<li>安装软件后，缓存应用程序离线工作所需的所有文件</li>
<li>当我们收到任何GET network请求时，我们将尝试使用实时数据进行响应，如果失败(由于缺少网络连接)，我们将使用缓存的数据进行响应</li>
</ol>
<h3>缓存所需的文件</h3>
<p>打开<code>serviceWorker.js</code>文件，将内容替换为以下内容:</p>
<pre>const version = 'v1/';
const assetsToCache = [
  '/',
  '/src.7ed060e2.js',
  '/src.7ed060e2.css',
  '/manifest.webmanifest',
  '/icon-128x128.3915c9ec.png',
  '/icon-256x256.3b420b72.png',
  '/icon-512x512.fd0e04dd.png',
];

self.addEventListener('install', (event) =&gt; {
  self.skipWaiting();

  event.waitUntil(
    caches
      .open(version + 'assetsToCache')
      .then((cache) =&gt; cache.addAll(assetsToCache))
      .then(() =&gt; console.log('assets cached')),
  );
});</pre>
<p>这是怎么回事？首先，我们定义了两个变量:</p>
<ol>
<li>用于跟踪你的软件版本</li>
<li><code>assetsToCache</code>:我们要缓存的文件列表。这些文件是我们的应用程序正常工作所必需的</li>
</ol>
<p><strong>注意</strong>:以下部分仅适用于使用包裹捆绑应用程序的情况。</p>
<hr/>
<p>现在，请注意,<code>assetsToCache</code>数组中的文件名在文件扩展名前添加了一个随机的八个字母的字符串？</p>
<p>当package捆绑我们的应用程序时，它会将从文件内容生成的唯一哈希添加到文件名中，这意味着每次我们对文件内容进行更改时，哈希很可能是唯一的。这意味着每当我们对这些文件中的任何一个进行更改时，我们都必须更新这个数组。</p>
<p>幸运的是，我们可以很容易地解决这个问题，告诉Parcel基于文件的<em>位置</em>而不是内容生成散列。这样，只要我们不改变任何文件的位置，我们就可以保证散列是恒定的。</p>
<p>虽然每当我们改变数组的位置时，我们仍然需要更新数组，但是如果我们坚持使用默认的散列方案，这种情况不会那么频繁。</p>
<p>那么，我们如何告诉包裹使用位置？只需打开您的<code>package.json</code>并将<code>--no-content-hash</code>添加到构建脚本的<em>末端</em>即可。<em>这很重要。</em></p>
<hr/>
<p>在初始化这些变量之后，我们向一个<code>self</code>对象添加一个事件监听器，这个对象指的是SW本身。</p>
<p>我们希望在SW开始运行时执行某些操作，所以我们指定我们正在监听哪个事件，在我们的例子中，就是<code>install</code>事件。然后我们提供一个回调函数，它接受一个<code>event</code>对象作为参数。</p>
<p>在这个回调中，我们调用SW上的<code>skipWaiting()</code>,这基本上是强制激活当前的SW。请阅读关于<a href="https://developers.google.com/web/fundamentals/primers/service-workers/lifecycle"/><a href="https://developers.google.com/web/fundamentals/primers/service-workers/lifecycle">s</a><a href="https://developers.google.com/web/fundamentals/primers/service-workers/lifecycle">service</a><a href="https://developers.google.com/web/fundamentals/primers/service-workers/lifecycle">w</a><a href="https://developers.google.com/web/fundamentals/primers/service-workers/lifecycle">workers</a>的生命周期，了解为什么会出现这一步。我不确定我能比谷歌开发者网站解释得更好。</p>
<p>然后，我们在传递给回调的<code>event</code>对象上调用一个<code>waitUntil()</code>方法，这有效地阻止了SW进入其生命周期的下一个阶段，直到我们传递给它的任何参数都被解决。让我们更详细地看看这个论点。</p>
<p>我们正在使用<a href="https://developer.mozilla.org/en-US/docs/Web/API/Cache">缓存API </a>，所以我建议你在继续之前复习一下。我们打开一个名为<code>v1/assetsToCache</code>的缓存存储(如果它以前不存在，它将被创建)，它返回一个承诺。</p>
<p>然后，我们在结果上链接一个<code>.then</code>方法，并传入一个回调，该回调接受一个名为<code>cache</code>的参数，这是我们刚刚打开的缓存存储的一个实例。然后，我们在这个实例上调用<code>addAll()</code>方法，传入我们希望缓存的文件列表。完成后，我们将<code>assets cached</code>登录到控制台。</p>
<p>让我们回顾一下到目前为止我们所做的工作:</p>
<ol>
<li>创建一个新变量来保存我们的软件版本</li>
<li>创建一个新数组来保存要缓存的文件列表</li>
<li>在软件上添加一个“安装”事件监听器</li>
<li>强制软件在其生命周期的“安装”阶段自行激活</li>
<li>阻止软件进入下一阶段，直到所有文件都被缓存</li>
</ol>
<h3>在网络故障时提供缓存文件</h3>
<p>将以下代码粘贴到前面的代码之后:</p>
<pre>self.addEventListener('fetch', (event) =&gt; {
  if (event.request.method === 'GET') {
    event.respondWith(
      fetch(event.request).catch(() =&gt; {
        return caches.match(event.request);
      }),
    );
  }
});</pre>
<p>我们想在用户网络瘫痪时提供缓存文件，这样他们就不会得到臭名昭著的Chrome T-Rex。</p>
<p>因此，我们将为所有网络获取请求添加另一个事件侦听器，并检查它是否是一个GET请求(即，浏览器是否在请求资源？).如果是，我们将尝试从服务器获取资源，如果失败，则提供缓存的资源。我们如何做到这一点？</p>
<p>在传递给事件监听器的回调中，我们检查<code>event.request.method</code>是否等于GET。如果不是(例如，用户添加了一个新的想法)，那么我们不会处理这个请求。请记住，我们在设置期间在Firestore实例中启用了持久性，因此Firestore将为我们处理这种情况。我们感兴趣的是处理GET请求。</p>
<p>因此，如果这是一个GET请求，我们将尝试使用<a href="https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API"> Fetch API </a>向服务器查询所请求的数据。如果用户离线，这将会失败，所以我们在请求的结果上附加了一个<code>catch</code>方法。</p>
<p>在这个<code>catch</code>块中，我们从缓存存储中返回与请求的资源相匹配的缓存文件。这确保了应用程序永远不会知道网络关闭，因为它正在接收对请求的响应。</p>
<h2>测试一切</h2>
<p>我们已经做了我们需要的一切，使应用程序成为一个具有离线连接功能的全功能PWA，所以让我们来测试它。</p>
<p>关闭你的应用程序(如果它正在运行),然后重新启动。打开Chrome DevTools，切换到<strong>应用</strong>标签，点击<strong>服务人员</strong>，你应该会看到我们的软件被激活，运行起来就像高速公路上的1968克尔维特。太好了。</p>
<p>现在选中<strong>离线</strong>复选框，重新加载页面，如下所示:</p>
<p><img data-attachment-id="8527" data-permalink="https://blog.logrocket.com/creating-a-lists-pwa-with-react-and-firebase/service-workers-offline-devtools/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2019/10/service-workers-offline-devtools.png" data-orig-size="730,386" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Offline option checked" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2019/10/service-workers-offline-devtools-300x159.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2019/10/service-workers-offline-devtools.png" decoding="async" class="aligncenter size-full wp-image-8527 jetpack-lazy-image" src="../Images/ffc0dfd99519b9e3f0997b70ae2d5a57.png" alt="Offline Option Checked On Service Workers Page" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2019/10/service-workers-offline-devtools.png 730w, https://blog.logrocket.com/wp-content/uploads/2019/10/service-workers-offline-devtools-300x159.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2019/10/service-workers-offline-devtools.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/10/service-workers-offline-devtools.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="8527" data-permalink="https://blog.logrocket.com/creating-a-lists-pwa-with-react-and-firebase/service-workers-offline-devtools/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2019/10/service-workers-offline-devtools.png" data-orig-size="730,386" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Offline option checked" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2019/10/service-workers-offline-devtools-300x159.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2019/10/service-workers-offline-devtools.png" decoding="async" loading="lazy" class="aligncenter size-full wp-image-8527" src="../Images/ffc0dfd99519b9e3f0997b70ae2d5a57.png" alt="Offline Option Checked On Service Workers Page" srcset="https://blog.logrocket.com/wp-content/uploads/2019/10/service-workers-offline-devtools.png 730w, https://blog.logrocket.com/wp-content/uploads/2019/10/service-workers-offline-devtools-300x159.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/10/service-workers-offline-devtools.png"/></noscript>
<p>请注意，您的应用程序甚至没有退缩。它一直在运转，好像世界一切都好。你可以关闭你的无线网络，尝试重新加载页面。请注意，它仍然显示良好。</p>
<p>现在让我们将应用程序部署到Firebase，将其作为PWA安装在实际的移动设备上，并确认一切正常。</p>
<p>在移动设备上运行<code>npm run deploy</code>并访问Firebase为您提供的托管URL。您应该会看到安装应用程序的提示。安装它，访问你的应用程序启动菜单，你应该看到“想法！”(或者你决定的任何名字)在本地应用列表中。</p>
<p>启动它，应用程序应该像一个本地应用程序一样加载，并带有一个闪屏。如果有人现在走进你正在使用的应用程序，他们将无法辨别这不是一个原生的移动应用程序。</p>
<h2>结论</h2>
<p>本教程很长，但是我们仅仅触及了React + Firebase + PWAs的皮毛。请将本教程看作是对构建渐进式web应用程序的奇妙世界的一个温和介绍。</p>
<p>虽然你当然可以直接使用服务工作者API，但是有很多事情可能会出错，所以使用谷歌的工具箱更明智。它处理了大量繁重的工作，让您可以专注于真正重要的功能。例如，如果你检查回购上的版本，你会发现这正是我正在使用的。</p>
<p>我希望你喜欢这个教程，并快乐编码❤️！</p><div class="code-block code-block-17">
<div class="blog-plug inline-plug react-plug" vwo-el-id="26283398190">
<h2 vwo-el-id="41600691720">使用LogRocket消除传统反应错误报告的噪音</h2>
<a href="https://lp.logrocket.com/blg/react-signup-issue-free" target="_blank" vwo-el-id="19356441070">LogRocket
</a><p>是一款React analytics解决方案，可保护您免受数百个误报错误警报的影响，只针对少数真正重要的项目。LogRocket告诉您React应用程序中实际影响用户的最具影响力的bug和UX问题。</p><a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="19356441380">
<img class="first-react-image alignnone size-full wp-image-46 jetpack-lazy-image jetpack-lazy-image--handled" src="../Images/f300c244a1a1cf916df8b4cb02bec6c6.png" vwo-el-id="18272717540" data-lazy-loaded="1" data-original-src="https://files.readme.io/27c94e7-Image_2017-06-05_at_9.46.04_PM.png"/>
</a>
<a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="19356441690">
<img class="second-react-image alignnone size-full wp-image-46 jetpack-lazy-image jetpack-lazy-image--handled" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" vwo-el-id="30720362350" data-lazy-loaded="1" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/>
</a>
<a href="https://lp.logrocket.com/blg/react-signup-issue-free" target="_blank" rel="noopener noreferrer" vwo-el-id="35866400580">LogRocket
</a><p>自动聚合客户端错误、反应错误边界、还原状态、缓慢的组件加载时间、JS异常、前端性能指标和用户交互。然后，LogRocket使用机器学习来通知您影响大多数用户的最具影响力的问题，并提供您修复它所需的上下文。</p><p vwo-el-id="28675661060">关注重要的React bug—<a class="signup" href="https://lp.logrocket.com/blg/react-signup-issue-free" target="_blank" rel="noopener noreferrer" vwo-el-id="40093418840">今天就试试LogRocket】。</a></p>
</div></div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
<html>
<head>
<title>How to best use Sinon with Chai - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>如何在Chai - LogRocket博客上最好地使用Sinon</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/sinon-with-chai/#0001-01-01">https://blog.logrocket.com/sinon-with-chai/#0001-01-01</a></blockquote><div><article class="article-post">
<p>如果您正在用JavaScript构建出于任何原因发出<code>http</code>请求的软件，您将拥有依赖于这些请求的响应的代码。发出这些请求的代码具有外部依赖性，这使得单元测试更难编写。</p>
<p>如果您使用<code>mocha</code>作为测试运行器，这就是<code>sinon</code>的用武之地。这是一个全功能的存根库，用于JavaScript中的单元测试。它通过允许你改变被测函数的行为来帮助你用外部依赖来单元测试代码。</p>
<p>如果你用的是<code>jest</code>，它自带存根功能。这里的最佳实践将有sinon的具体例子，但原则适用于任何存根引擎。</p>
<p>本指南假设您已经了解了<code>chai</code>和<code>sinon</code>的基础知识。这将提供如何一起使用这两个模块的战术建议，同时避免一些<strong>常见的陷阱。</strong></p>
<h2 id="an-api-client">api客户端</h2>
<p>Sinon对于避免在单元测试中依赖外部依赖是非常有用的。因此，假设我们想要测试这个简单的api客户端的<code>get</code>方法。对于我们想要测试的已知响应状态，它有一些特殊的错误处理:</p>
<pre><code class="javascript hljs"><span class="hljs-built_in">module</span>.exports = <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ApiClient</span> </span>{  
  <span class="hljs-keyword">constructor</span>(httpClient, apiKey) { 
    <span class="hljs-keyword">this</span>.httpClient = httpClient; 
    <span class="hljs-keyword">this</span>.apiKey = apiKey;
    <span class="hljs-keyword">this</span>.isApiKeyValid = <span class="hljs-literal">true</span>;
  }
  
  get(endpoint, callback) {
    
    
    
    <span class="hljs-keyword">this</span>.httpClient.get(endpoint, {<span class="hljs-attr">apiKey</span>: <span class="hljs-keyword">this</span>.apiKey}, (err, response) =&gt; {
      <span class="hljs-keyword">if</span> (err) { <span class="hljs-keyword">return</span> callback(err); }
      <span class="hljs-keyword">if</span> (response.status &gt;= <span class="hljs-number">500</span>) {
        <span class="hljs-keyword">return</span> callback(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'INTERNAL_SERVER_ERROR'</span>))
      }
      <span class="hljs-keyword">if</span> (response.status == <span class="hljs-number">403</span>) {
        <span class="hljs-keyword">this</span>.isApiKeyValid = <span class="hljs-literal">false</span>;
        <span class="hljs-keyword">return</span> callback(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'AUTH_ERROR'</span>))
      }
      <span class="hljs-keyword">return</span> callback(<span class="hljs-literal">null</span>, response);
    })
  }
}</code></pre>
<h2 id="stub-the-real-thing">把真的东西切掉</h2>
<p>如果您尝试存根的方法不存在，Sinon将抛出一个非常有用的错误。最佳实践是将您希望在代码中使用的同一类型的对象上使用的方法存根化。如果代码使用不存在的方法，这将避免编写通过的单元测试:</p>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> request = <span class="hljs-built_in">require</span>(<span class="hljs-string">'request'</span>);
<span class="hljs-keyword">const</span> sinon = <span class="hljs-built_in">require</span>(<span class="hljs-string">"sinon"</span>);

it(<span class="hljs-string">'issues the request'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>() </span>{
  
  sinon.stub(request, <span class="hljs-string">'gettt'</span>)
  
  sinon.stub(request, <span class="hljs-string">'get'</span>)
  ...
})</code></pre>
<p><strong>常见的陷阱:</strong>使用不带参数的<code>sinon.stub()</code>创建完全虚构的对象的测试会让测试传递带有难以捕捉的错别字的代码，从而导致错误。</p>
<h2 id="sinon-expectations">兴农期望</h2>
<p>将<code>sinon-chai</code>模块添加到mix中，以便使用带有<code>sinon</code>存根的期望语法。没有了<code>sinon-chai</code>,这种期望可以被笨拙地断言，如下所示:</p>
<pre><code class="javascript hljs">it(<span class="hljs-string">'issues the request'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">done</span>) </span>{
  sinon.stub(request, <span class="hljs-string">'get'</span>).yields(<span class="hljs-literal">null</span>, {});
  apiClient = <span class="hljs-keyword">new</span> ApiClient(request, <span class="hljs-string">'api-key'</span>);
  apiClient.get(<span class="hljs-string">'/endpoint'</span>, (err, response) =&gt; {
    expect(request.get.calledOnce).to.be.true
    done(err);
  })
})</code></pre>
<p>在失败时，<code>chai</code>会告诉我们它“期望假为真”，这并没有提供太多的上下文。</p>
<p>常见陷阱:对于没有编写原始代码或测试的人来说，这使得测试更难维护。</p>
<p>有了<code>sinon-chai</code>，人们可以使用相同的期望链接，这使得期望语法易于阅读，并且是更好的失败报告:</p>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> request = <span class="hljs-built_in">require</span>(<span class="hljs-string">'request'</span>);
<span class="hljs-keyword">const</span> sinon = <span class="hljs-built_in">require</span>(<span class="hljs-string">"sinon"</span>);
<span class="hljs-keyword">const</span> chai = <span class="hljs-built_in">require</span>(<span class="hljs-string">"chai"</span>);
<span class="hljs-keyword">const</span> sinon = <span class="hljs-built_in">require</span>(<span class="hljs-string">"sinon"</span>);
<span class="hljs-keyword">const</span> sinonChai = <span class="hljs-built_in">require</span>(<span class="hljs-string">"sinon-chai"</span>);
chai.use(sinonChai);
<span class="hljs-keyword">const</span> expect = chai.expect;

it(<span class="hljs-string">'issues the request'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">done</span>) </span>{
  sinon.stub(request, <span class="hljs-string">'get'</span>).yields(<span class="hljs-literal">null</span>, {});
  apiClient = <span class="hljs-keyword">new</span> ApiClient(request, <span class="hljs-string">'api-key'</span>);
  apiClient.get(<span class="hljs-string">'/endpoint'</span>, (err, response) =&gt; {
    expect(request.get).to.have.been.calledOnce
    done(err);
  })
})</code></pre>
<p>如果失败，<code>sinon-chai</code>将告诉我们它“期望request.get被调用一次”，这是对测试失败原因的更准确的解释。</p>
<h2 id="always-play-in-the-sandbox">总是在沙盒里玩</h2>
<p>始终使用沙箱来存储您的存根和间谍，以便于清理。不必记住恢复每个单独的存根，整个沙箱可以一次恢复。这将确保一个测试中的更改不会影响到下游的单元测试:</p>
<pre><code class="javascript hljs">describe(<span class="hljs-string">'TestModule'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>() </span>{
  beforeEach(<span class="hljs-string">'setup sandbox'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>() </span>{
    <span class="hljs-keyword">this</span>.sandbox = sinon.sandbox.create();
    <span class="hljs-keyword">this</span>.sandbox.stub(request, <span class="hljs-string">'get'</span>);
  });
  ...
  afterEach(<span class="hljs-string">'restore sandbox'</span> <span class="hljs-function"><span class="hljs-keyword">function</span>() </span>{
    <span class="hljs-keyword">this</span>.sandbox.restore();
  });
})</code></pre>
<p>这种策略将避免<strong>常见的陷阱</strong>，存根和间谍仍然有效，并改变不相关测试的行为。</p>
<p>如果你有任何全局测试设置助手/基础设施，如果<code>this.sandbox</code>被设置为避免难以调试的测试失败，考虑将沙箱恢复添加到全局<code>afterEach</code>中。如果测试后没有清理存根，就会发生这种情况:</p>
<pre><code class="javascript hljs">
afterEach(<span class="hljs-string">'restore sandbox'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>() </span>{
  <span class="hljs-keyword">if</span>(<span class="hljs-keyword">this</span>.sandbox) { <span class="hljs-keyword">this</span>.sandbox.restore(); }
}</code></pre>
<h2 id="use-yields-for-asynchronous-interfaces">将<code>yields</code>用于异步接口</h2>
<p>在许多情况下，外部依赖将使用异步接口。为了测试许多不同的结果，在<code>beforeEach</code>中创建一次存根，并在您的特定测试中使用<code>yields</code>方法，以将它限定在特定的情况下:</p>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> ApiClient = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./ApiClient'</span>);
<span class="hljs-keyword">const</span> request = <span class="hljs-built_in">require</span>(<span class="hljs-string">'request'</span>);
<span class="hljs-keyword">const</span> sinon = <span class="hljs-built_in">require</span>(<span class="hljs-string">'sinon'</span>);
<span class="hljs-keyword">const</span> chai = <span class="hljs-built_in">require</span>(<span class="hljs-string">'chai'</span>);
<span class="hljs-keyword">const</span> sinonChai = <span class="hljs-built_in">require</span>(<span class="hljs-string">'sinon-chai'</span>);

chai.use(sinonChai);
<span class="hljs-keyword">const</span> expect = chai.expect;

describe(<span class="hljs-string">'ApiClient#get'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>() </span>{
  beforeEach(<span class="hljs-string">'create ApiClient instance'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>() </span>{
    <span class="hljs-keyword">this</span>.sandbox = sinon.sandbox.create();
    <span class="hljs-keyword">this</span>.sandbox.stub(request, <span class="hljs-string">'get'</span>)
    <span class="hljs-keyword">this</span>.apiClient = <span class="hljs-keyword">new</span> ApiClient(request, <span class="hljs-string">'api-key'</span>);
  });
  afterEach(<span class="hljs-string">'restore stub'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>() </span>{
    <span class="hljs-keyword">this</span>.sandbox.restore();
  }
  it(<span class="hljs-string">'yields the request error if the request fails'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">done</span>) </span>{     
    <span class="hljs-keyword">let</span> requestError = {<span class="hljs-attr">some</span>: <span class="hljs-string">'error'</span>}
    
    request.get.yields(requestError); 

    <span class="hljs-keyword">this</span>.apiClient.get(<span class="hljs-string">'/posts'</span>, (err, response) =&gt; {
      
      expect(request.get).to.have.been.calledWith(<span class="hljs-string">'/posts'</span>, {<span class="hljs-attr">apiKey</span>: <span class="hljs-string">'api-key'</span>});
      
      expect(err).to.equal(requestError);
      <span class="hljs-keyword">return</span> done();
  });
  it(<span class="hljs-string">'yields INTERNAL_SERVER_ERROR when the response status is 500'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">done</span>) </span>{ 
    
    request.get.yields(<span class="hljs-literal">null</span>, {<span class="hljs-attr">status</span>: <span class="hljs-number">500</span>}); 
    
    <span class="hljs-keyword">this</span>.apiClient.get(<span class="hljs-string">'/posts'</span>, (err, response) =&gt; {
      
      expect(request.get).to.have.been.calledWith(<span class="hljs-string">'/posts'</span>, {<span class="hljs-attr">apiKey</span>: <span class="hljs-string">'api-key'</span>});
      
      expect(err).to.equal(<span class="hljs-string">'INTERNAL_SERVER_ERROR'</span>);
      <span class="hljs-keyword">return</span> done();
  });
  it(<span class="hljs-string">'yields an AUTH_ERROR when the response status is 403'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">done</span>) </span>{     
    request.get.yields(<span class="hljs-literal">null</span>, {<span class="hljs-attr">status</span>: <span class="hljs-number">403</span>}); 
    
    <span class="hljs-keyword">this</span>.apiClient.get(<span class="hljs-string">'/posts'</span>, (err, response) =&gt; {
      
      expect(request.get).to.have.been.calledWith(<span class="hljs-string">'/posts'</span>, {<span class="hljs-attr">apiKey</span>: <span class="hljs-string">'api-key'</span>});
      
      expect(err).to.have.property(<span class="hljs-string">'message'</span>, <span class="hljs-string">'AUTH_ERROR'</span>)
      
      expect(<span class="hljs-keyword">this</span>.apiClient.isApiKeyValid).to.equal(<span class="hljs-literal">false</span>);
      <span class="hljs-keyword">return</span> done();
  });
});</code></pre>
<p>使用<code>yields</code>避免了<strong>中常见的陷阱</strong>，即创建额外的存根来充当已经被存根化的方法的回调。</p>
<h2 id="conclusion">结论</h2>
<p>有了上面的提示，你和你的团队可以更好地利用<code>sinon</code>为具有外部依赖的代码编写单元测试，同时避免上面列出的<strong>常见陷阱</strong>！</p><div class="code-block code-block-2">
<div class="blog-plug base-cta"><h2>使用<a class="signup" href="https://lp.logrocket.com/blg/signup" target="_blank" rel="noopener noreferrer"> LogRocket </a>消除传统错误报告的干扰</h2>
<a href="https://lp.logrocket.com/blg/signup" class="signup" target="_blank" rel="noopener noreferrer"><img class="alignnone size-full wp-image-46 jetpack-lazy-image" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/><noscript><img data-lazy-fallback="1" class="alignnone size-full wp-image-46" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/></noscript></a>
<p><a href="https://lp.logrocket.com/blg/signup" target="_blank" rel="noopener noreferrer"> LogRocket </a>是一个数字体验分析解决方案，它可以保护您免受数百个假阳性错误警报的影响，只针对几个真正重要的项目。LogRocket会告诉您应用程序中实际影响用户的最具影响力的bug和UX问题。</p>
<p>然后，使用具有深层技术遥测的会话重放来确切地查看用户看到了什么以及是什么导致了问题，就像你在他们身后看一样。</p>
<p>LogRocket自动聚合客户端错误、JS异常、前端性能指标和用户交互。然后LogRocket使用机器学习来告诉你哪些问题正在影响大多数用户，并提供你需要修复它的上下文。</p>
<p>关注重要的bug—<a class="signup" href="https://lp.logrocket.com/blg/signup-issue-free" target="_blank" rel="noopener noreferrer">今天就试试LogRocket】。</a></p></div></div>
<hr/>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
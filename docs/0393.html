<html>
<head>
<title>Cypress vs. Selenium: Why Cypress is the better option - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>柏树与硒:为什么柏树是更好的选择</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/cypress-io-the-selenium-killer/#0001-01-01">https://blog.logrocket.com/cypress-io-the-selenium-killer/#0001-01-01</a></blockquote><div><article class="article-post">
<h2>硒的问题是</h2>
<p>编者按:这篇文章于2021年1月19日更新，以反映Cypress 6.1.0引入的变化和改进。</p>
<p>在我开始之前，我想强调的是，这篇文章不是关于一个特定的项目或者我曾经工作过的任何自动化测试人员。我在最近的三个项目中看到了这种行为，几乎每个和我一起工作过的自动化测试人员都竭尽全力让这台有故障的机器工作。</p>
<p>我相当肯定的是，我最近参与的每个合同都有一份备忘录，规定需要<a href="https://blog.logrocket.com/automated-testing-is-not-working/">一百万次自动化测试</a>来保证成功。我们不能停下来质疑这些测试的价值。我们必须像保护我们的孩子一样保护他们。</p>
<p>这些测试必须用<a href="https://www.seleniumhq.org/" target="_blank" rel="noopener noreferrer"> Selenium </a>编写，尽管几乎每个人都有过相当糟糕的经历，原因是我将在后面陈述的固有的已知问题。根据他们的文档，Selenium提供了一系列工具和库来支持web浏览器的自动化，并提供了模拟用户与浏览器交互的扩展，以及用于扩展浏览器分配的分发服务器。它还拥有实现<a class="highlight" href="https://www.w3.org/TR/webdriver/"> W3C WebDriver规范</a>的基础设施，可以让你为所有主流web浏览器编写可互换的代码。</p>
<p>编写Selenium测试具有极大的挑战性，但是我们不会因此而退缩。取而代之的是，我们的测试人员可能很晚才开始编程，或者是开发新手。我们将让这些经验不足的开发人员编写这些困难的测试。</p>
<p>Selenium测试可能很难编写，但是它们很容易复制和粘贴。这当然会导致各种各样的问题。</p>
<p>我们经常听到“如果它动了，就给它写个硒测试”。自动化测试必须针对<a href="https://blog.logrocket.com/common-api-mistakes-and-how-to-avoid-them-804fbcb9cc4b/" target="_blank" rel="noopener noreferrer"> API </a>，前端、后端、中端、快乐路径、悲伤路径、颠倒路径等进行编写。</p>
<p>我们没有时间进行手动测试，我们怎么可能呢？我们要编写和维护所有这些古怪的硒测试。这个冲刺我们已经迟到了，每个故事都要有自动化测试。</p>
<p>经过一年左右的时间和一个疯狂漫长的建设，我们将决定这是有点傻，并删除它们。或者更糟——重新开始。</p>
<h3>为什么大家还在用硒？</h3>
<p>我想如果我能回答上面的问题，我会更接近理解我们存在的真正本质。玩笑归玩笑，为什么硒的使用如此广泛？这确实让我感到震惊，但这里有一些建议:</p>

<p>公平地说，编写一百万个验收测试的突然激增并不是Selenium的错。在我看来，自动化测试的正确数量是<em>一个</em> <span>快乐路径测试，没有悲伤路径或颠倒路径。这个测试是一个冒烟测试，以确保我们的系统对业务开放。</span></p>
<p>单元测试和集成测试运行、实现和维护起来更便宜，应该成为我们测试的主体。大家都忘了<a href="https://martinfowler.com/bliki/TestPyramid.html" target="_blank" rel="noopener noreferrer">测试金字塔</a>了吗？</p>
<h2>为什么硒对你不起作用的原因</h2>
<p>硒的问题可以用一个词来表达:<em>时机</em>。</p>
<p>在我们开始编写代码来断言我们的测试是正确的之前，我们需要确保我们需要与之交互的任何元素都是可见的，并且处于接受模拟输入的状态。远程API调用需要解决，动画和微调需要结束。现在构成我们应用程序大部分的动态内容需要从API调用的当前检索数据中完成渲染。</p>
<p>那么，当这种可怕的异步哑剧发生时，我们该做些什么呢？我们如何阻止我们的测试刚刚完成或触底，因为一个特定的文本输入被禁用，直到一个API调用已经完成或一个美丽的SVG旋转覆盖已经把我们的虚拟世界的黑暗面纱？</p>
<p>通俗地说，我们等待HTML元素处于就绪状态。在Selenium speak中，我们编写了许多定制的<code>waitForXXXXX</code>代码助手，例如</p>
<p>或者更现实地说…</p>
<pre>wait.until(ExpectedConditions.visibilityOfElementLocated(By.xpath("//input[@id='text3']")));
</pre>
<p>最糟糕的罪行之一就是使用<code>Thread.sleep</code>。这是一个令人发指的罪行，从空气中随机抽取一个数字，作为我们认为UI处于就绪状态时的胡乱猜测。请不要这样做。</p>
<p>以下是我一直以来最喜欢的Selenium异常，是我在艰难地阅读CI构建报告时发现的:</p>
<ul>
<li>继续前进，你不会在这里找到你的输入</li>
<li>这种厚颜无耻的行为意味着你已经非常接近了，但是还不够接近，它就在大教堂里，但是你却什么也做不了</li>
<li><code>StaleElementReferenceException</code>–元素结束了一天的工作，去了酒吧。请明天再试一次</li>
<li>你可以等到时间的尽头，无论你想做什么都不会发生。你刚刚掷出了一个7</li>
</ul>
<h2>看:鳞片</h2>
<p>我经历过的最令人心碎的时刻之一是，由于自动化测试失败而导致构建失败，只是通过再次运行构建而神奇地通过。这种现象或僵尸自动化测试通常被称为<em>一个薄片</em>。</p>
<p>薄片的主要问题在于它是<a href="https://martinfowler.com/articles/nonDeterminism.html" target="_blank" rel="noopener noreferrer">非确定性的</a>，这意味着当在不同的时间使用相同的输入执行时，测试会表现出不同的行为。随着非确定性测试数量的增加，您可以看到对您的回归测试套件的信心化为乌有。</p>
<p>一个古怪的测试很可能是由于计时、延迟和可怕的异步操作，我们正试图用我们的<code>Thread.sleep</code>和<code>waitForAHero</code>助手来驯服它们，我们需要继续写以保持理智。</p>
<p>试想一下，如果我们能够以某种方式让所有这些异步编程消失，如果我们的世界开始以线性或同步方式运行，这将会变得多么容易。我们将有一个多么自然的世界来测试。</p>
<p>Cypress.io 正着手这么做。</p>
<h2>Cypress.io:硒的替代品</h2>
<h3 id="what-is-cypress">柏树是什么？</h3>
<p>Cypress是一个基于JavaScript的端到端测试框架。它构建在Mocha之上，运行在浏览器中，支持异步测试。根据<a href="https://docs.cypress.io/guides/overview/why-cypress.html#In-a-nutshell" target="_blank" rel="noopener"> Cypress文档</a>，除了端到端测试，Cypress还能帮你编写集成测试和单元测试。</p>
<p>Cypress包括以下功能:</p>
<ul>
<li><strong>时间旅行:</strong> Cypress在测试运行时拍摄快照</li>
<li><strong>调试:</strong>可读的错误和堆栈跟踪使调试更容易</li>
<li><strong>自动等待:</strong>自动等待命令和断言，然后继续</li>
<li><strong>间谍、存根和时钟:</strong>验证和控制函数、服务器响应或定时器的行为</li>
<li><strong>网络流量控制:</strong>不涉及服务器的控制、存根和测试边缘案例</li>
<li><strong>截图和视频:</strong>查看失败时自动拍摄的截图，或者从CLI运行时查看整个测试套件的视频</li>
<li><strong>跨浏览器测试:</strong>在本地运行Firefox和Chrome系列浏览器(包括Edge和electronic)中的测试</li>
</ul>
<h3>柏树和硒的区别</h3>
<p><a href="https://www.cypress.io/" target="_blank" rel="noopener noreferrer"> Cypress.io </a>和<a href="https://www.seleniumhq.org/" target="_blank" rel="noopener noreferrer"> Selenium </a>的主要区别之一是Selenium在我们测试的浏览器或设备之外的进程中执行。Cypress在浏览器中执行，并在与被测设备相同的运行循环中执行。</p>
<p>Cypress在浏览器内部执行绝大多数命令，因此没有网络延迟。命令以应用程序能够呈现的速度运行并驱动应用程序。为了处理具有复杂UI的现代JavaScript框架，您使用断言来告诉Cypress您的应用程序的期望状态是什么。</p>
<p>Cypress会自动等待您的应用程序达到这个状态，然后再继续。您完全不必担心手动等待或重试。Cypress会自动等待元素的存在，并且永远不会产生已经从<a href="https://blog.logrocket.com/8-dom-features-you-didnt-know-existed-ec2a0a28fd89/" target="_blank" rel="noopener noreferrer"> DOM </a>中分离出来的陈旧元素。</p>
<p>这是主要的收获。Cypress通过在与设备相同的运行循环中执行，消除了Selenium的主要问题。Cypress负责等待DOM元素出现。</p>
<p>我再说一遍:赛普拉斯会处理好所有等待的事情。没有<code>Thread.sleep</code>，没有<code>waitForTheMoon</code>帮手。你不明白这意味着什么吗？</p>
<p>要真正理解这有多好，你必须经历痛苦。</p>
<p>下面是一些柏树测试的例子。</p>
<p>他们缺席的一个同义词是任何时机或淫秽的<code>waitFor</code>帮手:</p>
<pre>context("Login", () =&gt; {
  beforeEach(() =&gt; {
    cy.visit("localhost:8080/login");
  });

  it("can find and type in email", () =&gt; {
    cy.get("#email")
      .type("<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="6402050f01240109050d084a070b09">[email protected]</a>")
      .should("have.value", "<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="c3a5a2a8a683a6aea2aaafeda0acae">[email protected]</a>");
  });

  it("can find and type in password", () =&gt; {
    cy.get("#password")
      .type("fakepassword")
      .should("have.value", "fakepassword");
  });

  it("will fail when type invalid user credentials", () =&gt; {
    cy.get("#email").type("<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="bcdaddd7d9fcd9d1ddd5d092dfd3d1">[email protected]</a>");

    cy.get("#password").type("fakepassword");

    cy.get("input[type=submit]").click();

    cy.get("#login-message").should("have.text", "Login failed");
  });
});
</pre>
<p>我喜欢这些测试。它们清楚地陈述了自己的目的，并且不会被弥补平台局限性的代码混淆。</p>
<p>下面是我写的通过Cypress运行<a href="https://www.deque.com/axe/" target="_blank" rel="noopener noreferrer"> axe辅助工具</a>的一些测试:</p>
<pre>import { AxeConfig } from "../support/axeConfig";

describe("Axe violations", () =&gt; {
  beforeEach(() =&gt; {
    cy.visit("/");
    cy.injectAxe();
  });

  it("home page should have no axe violations", () =&gt; {
    cy.configureAxe(AxeConfig);
    cy.checkA11yAndReportViolations();
  });
});
</pre>
<p>这里有一个使用<code>webdriver</code>的类似测试:</p>
<pre>// in e2e/home.test.js
import assert from 'assert';
import { By, until } from 'selenium-webdriver';
import {
    getDriver,
    analyzeAccessibility,
} from './helpers';

describe('Home page', () =&gt; {
    let driver;

    before(() =&gt; {
        driver = getDriver();
    });

    it('has no accessibility issues', async () =&gt; {
        await driver.get(`http://localhost:3000`);

        // The dreaded wait until.  Abandon hope
        await driver.wait(until.elementLocated(By.css('h1')));

        const results = await analyzeAccessibility();
        assert.equal(results.violations.length, 0);
    });
});

</pre>
<p>主要的显著区别和令我担忧的是延迟。有两个<code>await</code>电话和可怕的<code>wait(until.elementLocated)</code>。这是一个简单的测试，但是你的互动越多，你就需要越多的<code>waitFor</code>助手，并且这种剥落开始蔓延。</p>
<p>如果你有兴趣了解更多，这里有一个用Cypress编写端到端测试的教程。</p>
<h3>JavaScript一路向下</h3>
<p>Cypress显然是针对前端开发者的。安装Cypress是一件轻而易举的事情，通过您最喜欢的包管理器选择来执行:npm或yarn。</p>
<pre>npm install cypress --save-dev</pre>
<p>这真的再简单不过了。与下载Chrome WebDriver和Selenium世界中的朋友相比。</p>
<p>没有Selenium这样的多语言支持。你可以有任何你喜欢的编程语言，只要是JavaScript或者TypeScript。</p>
<h3>赛普拉斯监狱</h3>
<p>当然，也有缺点，其中一些是显而易见的，所以我不能不列举这些。</p>
<ul>
<li>柏树是相对较新的物种，它没有硒那样庞大的群落</li>
<li>如前所述，要么是JavaScript，要么是bust。你不会用C#和java这些陈旧的静态语言来编写Cypress测试</li>
<li>因为它在浏览器中运行，所以你不能支持多个标签</li>
</ul>
<p>同样需要注意的是，Cypress <a href="https://docs.cypress.io/faq/questions/general-questions-faq.html#Do-you-support-native-mobile-apps">不支持本地移动应用</a>。但是，您可以使用Cypress来测试移动web浏览器的某些功能，并测试在使用Ionic等框架的浏览器中开发的移动应用程序。</p>
<h2>柏树会取代硒吗？</h2>
<p>虽然我很想说是，但我有疑虑。有一大批自动化测试人员，除了selenium之外，他们还不知道任何其他世界，可能很难很快离开。</p>
<div class="inline-plug cro19">
<h2>测试只是开始——确保通过测试意味着用户满意</h2>
<p>虽然Cypress引入了一个引人注目的新测试框架，但是让测试更进一步是很重要的。LogRocket监控应用程序的整个客户端体验，并自动发现任何问题(尤其是那些测试可能遗漏的问题)。要通过前端监控获得对生产环境的宝贵见解，<a href="https://logrocket.com/signup/">请尝试LogRocket </a>。<a class="signup" href="https://logrocket.com/signup/" target="_blank" rel="noopener noreferrer">T3<noscript>T5</noscript>T7】</a></p>
<p><a href="https://logrocket.com/signup/" target="_blank" rel="noopener noreferrer">https://logrocket.com/signup/</a></p>
<p>LogRocket 就像是网络应用的DVR，记录下你网站上发生的每一件事。您可以汇总并报告性能问题以快速了解根本原因，而不是猜测问题发生的原因。</p>
<p>LogRocket让你的应用程序记录带有标题+正文的请求/响应，以及关于用户的上下文信息，以全面了解问题。它还记录页面上的HTML和CSS，甚至可以重建最复杂的单页面应用程序的像素级完美视频。</p>
<p>优先考虑性能–<a class="signup" href="https://logrocket.com/signup/" target="_blank" rel="noopener noreferrer">开始免费监控</a>。</p>
</div>
<h2>结论</h2>
<p>正如我在本文开始时所说的，我对自动化测试的体验并不好。大量的金钱、时间和痛苦花费在维持数以千计难以维持的测试上，却得不到令人满意的回报。根据我的经验，自动化测试只能保证长时间的CI构建。</p>
<p>作为开发人员，我们需要更好地进行自动化测试。我们需要编写更少的测试来做更多有用的事情。我们把一些最难写的代码留给了一些经验最少的开发人员。我们已经让手工测试看起来过时了，在我看来，这仍然是发现真正错误的地方。</p>
<p>我们需要对自动化测试能够达到的目标有一个清醒的认识。</p>
<p>Cypress很棒，因为它使事情同步。这消除了整个世界的痛苦，为此，我坚决支持。然而这并不是开绿灯写千柏考。我们的大部分测试是单元测试，在我们进行一些愉快的自动化测试之前有一层集成测试。</p>
<p>当然，这是一个永远不会发生的非常明智的策略。</p><div class="code-block code-block-27">
<div class="blog-plug inline-plug vanilla-javascript-cta"><h2>通过理解上下文，更容易地调试JavaScript错误</h2>
<p>调试代码总是一项单调乏味的任务。但是你越了解自己的错误，就越容易改正。</p>
<p>LogRocket 让你以新的独特的方式理解这些错误。我们的前端监控解决方案跟踪用户与您的JavaScript前端的互动，让您能够准确找出导致错误的用户行为。</p>
<a href="https://lp.logrocket.com/blg/javascript-signup" class="signup" target="_blank" rel="noopener noreferrer"><img class="alignnone size-full wp-image-46 jetpack-lazy-image" src="../Images/cbfed9be3defcb505e662574769a7636.png" alt="LogRocket Dashboard Free Trial Banner" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2020/06/reproduce-javascript-errors.gif?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/06/reproduce-javascript-errors.gif"/><noscript><img data-lazy-fallback="1" class="alignnone size-full wp-image-46" src="../Images/cbfed9be3defcb505e662574769a7636.png" alt="LogRocket Dashboard Free Trial Banner" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/06/reproduce-javascript-errors.gif"/></noscript></a>
<p>LogRocket记录控制台日志、页面加载时间、堆栈跟踪、慢速网络请求/响应(带有标题+正文)、浏览器元数据和自定义日志。理解您的JavaScript代码的影响从来没有这么简单过！</p>
<a class="signup" href="https://lp.logrocket.com/blg/javascript-signup" target="_blank" rel="noopener noreferrer">Try it for free</a><p>.</p></div>


</div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
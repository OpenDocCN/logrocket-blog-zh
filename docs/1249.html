<html>
<head>
<title>A simple guide for migrating from JavaScript to TypeScript - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>从JavaScript迁移到TypeScript的简单指南</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/a-simple-guide-for-migrating-from-javascript-to-typescript/#0001-01-01">https://blog.logrocket.com/a-simple-guide-for-migrating-from-javascript-to-typescript/#0001-01-01</a></blockquote><div><article class="article-post">
<p>您可能已经知道，TypeScript是一种流行的静态类型检查器，是作为JavaScript的超集构建的。TypeScript对于在执行之前发现类型错误非常方便——这是普通Javascript所没有的规则。然而，Typescript运行起来和Javascript一样流畅。</p>
<p>我们将假设你用JavaScript开始了一个项目，现在重新开始已经太晚了。因此，您遇到了一个问题:您想在TypeScript中工作，但是已经进行了很长时间，无法重新开始。</p>
<p>你是做什么的？</p>
<p>在本文中，我们将介绍一种平稳高效地迁移到Typescript的方法。</p>
<p>当迁移到TypeScript时，要记住的一个基本事情是TypeScript文件有一个<code>.ts</code>扩展名，而不是<code>.js</code>。这很简单。要记住的另一件事是，要使迁移变得轻而易举，您可以配置您的TypeScript编译器来允许JavaScript文件。</p>
<p>正如我们前面所说的，TypeScript只是Javascript之上的一个超集——因此，您可以一次迁移一个文件，而不必担心为迁移创建一个完全独立的分支。</p>
<p>说到编译器，最好不要去管当前捆绑或编译你的JavaScript的东西。TypeScript有一种简单的方法，可以简单地将自己添加到编译器上，而不会把事情弄糟。如果你正在使用<code>npm</code>，你可以简单地运行<code>npm i -g typescript</code>。</p>
<p>在进一步了解TypeScript设置之前，需要考虑的一件事是您的IDE是否配置为使用TypeScript。预编译自动更正TypeScript提供的功能，以及在这个阶段检测错误的能力，是您不想错过的功能。如果您使用的是VS代码，则内置了对TypeScript的支持。否则，您可能需要找到一个包来获得IDE对TypeScript的支持。</p>
<h2>类型脚本编译器</h2>
<p>现在您需要添加TypeScript编译器。</p>
<p>在项目的根目录下创建一个名为<code>tsconfig.json</code>的文件。有数百种方法来配置这个文件，但是让我们只看一些基本的。</p>
<p>在我们深入研究之前，您可以在项目的根目录下运行以下命令，而不是自己创建文件:</p>
<pre>npx tsc --init</pre>
<p>这将为您创建一个<code>tsconfig.json</code>文件，打开几个默认选项，并注释掉一些可能的选项供您查看。</p>
<p>如您所见，这将是一个JSON文件。因此，这里要配置的两个常见属性是<code>compileOptions</code>和<code>include</code>。</p>
<p><code>CompileOptions</code>是一个对象，其中的选项可以设置为true，以更改将TypeScript transpiles文件转换为JavaScript的方式。</p>
<p>例如，在<code>compileOptions</code>中，我们可以打开<code>noImplicitAny: true</code>(如果为false，Typescript将推断没有定义类型的“any”的类型)和<code>strictNullChecks: true</code>(如果为false，TypeScript将忽略“null”和“undefined”)。</p>
<p>打开这两个选项后，我们可以确定我们的<code>.ts</code>文件将实际检查类型。如果没有，您可以在<code>.ts</code>文件中运行普通的JavaScript。</p>
<p><code>include</code>选项是指定文件名或glob模式来匹配类型脚本文件的一种方式。它是一个数组，可以包含特定的文件名或所有TypeScript文件遵循的模式。一个简单的设置是简单地将这个选项定义为<code>include: ["src/**/*"]</code> ( <code>*_</code>匹配任何目录，而<code>_</code>匹配任何文件)。</p>
<p>默认情况下，选择<code>src</code>目录下扩展名为<code>.ts</code>、<code>.tsx</code>或<code>.d.ts</code>的任何文件。</p>
<p>如果您将<code>allowJs: true</code>添加到<code>compileOptions</code>中，那么上面定义的<code>include</code>也将包括我们的<code>src</code>目录中的<code>.js</code>和<code>.jsx</code>文件。</p>
<p>短边注释:<code>.d.ts</code>扩展和普通<code>.ts</code>的区别在于，<code>.d.ts</code>用于声明要打印的内容，而<code>.ts</code>用于打印编译成JavaScript。<code>.d.ts</code>最常用于在<code>npm</code>模块中声明类型，让TypeScript知道，而<code>.ts</code>用于所有的JavaScript文件。<code>.ts</code>和<code>.tsx</code>的区别在于<code>.tsx</code>用于JSX文件，就像React组件一样。</p>
<p>另一个需要理解的基本选项是<code>exclude</code>。如果您的<code>exclude</code>范围很广，那么您可能不希望编译器匹配某些文件。例如，包含所有内容是一种选择，但是您可能希望将<code>node_modules</code>放在exclude数组下。</p>
<p>关于配置你的TypeScript编译器的更多信息，请参见官方文档。</p>
<p>一旦完成了对<code>tsconfig.json</code>文件的配置，就可以在<code>package.json</code>中添加一个脚本来运行编译器。在脚本下，添加类似于<code>"tsc:w": "tsc -w"</code>的内容。然后你可以运行脚本，它将指向你的<code>tsconfig.json</code>文件并编译！</p>
<h3><code>@types</code></h3>
<p>如果你使用像React这样的前端框架，你还需要安装<code>@types</code>包。因为TypeScript中的所有东西都需要类型定义，所以像<code>@types/react</code>这样的包会让TypeScript知道所有基本的React类、函数、组件等的类型。</p>
<p>这是满足TypeScript所必需的，也是理所当然的。你还需要记住将类型添加到添加到你的项目中的任何其他库中(例如<code>@types/react-router-dom</code>、<code>@types/react-bootstrap</code>或<code>@types/react-redux</code>)。</p><div class="code-block code-block-54">
<hr/>
<h3>更多来自LogRocket的精彩文章:</h3>

<hr/></div>
<p><code>@types</code>包的另一个例子是<code>@types/node</code>。如果没有这个包，我们习惯的关键字在Typescript文件(<code>.ts</code>文件)中将无法被识别。</p>
<p>例如，使用<code>require</code>来导入一个包，将会返回如下错误:<code>Error:(3, 12) TS2304:Cannot find name 'require'</code>。包<code>@types/node</code>为TypeScript定义了这一点，所以我们现在可以使用<code>require</code>而不会出错。</p>
<p>一些JavaScript包中已经编写了类型。这些不需要安装类型包。但是，如果包中没有编写类型，也没有要安装的类型包，该怎么办呢？</p>
<p>首先，这很难找到，因为TypeScript有很多支持。但是，如果你广泛使用TypeScript，你将不可避免地发现一个没有TypeScript支持的JavaScript包。</p>
<p>这里最简单的解决方案是简单地让TypeScript编译器知道你的模块存在。这不会将TypeScript添加到包中，但会绕过TypeScript检查器并允许您使用它。有很多方法可以解决这个问题，比如自己将TypeScript完全添加到包中(大多数情况下需要做很多工作)，但这只是一个简单的解决方法。</p>
<p>创建一个文件，命名如下:<code>MyModuleDesc.d.ts</code>(T1是重要的部分)。</p>
<p>在该文件中，只需编写<code>declare module "my-module"</code>(其中“my-module”是没有Typescript的包)。然后，在您的<code>tsconfig.json</code>文件中，在<code>include</code>数组下，添加<code>MyModuleDesc.d.ts</code>文件(假设这个文件在您的项目的根目录下)。</p>
<h3>反应示例</h3>
<p>好了，基本的操作方法已经讲得够多了，让我们实际看看这种迁移是如何进行的。我为从Swapi.dev接收的数据创建了一个简单的表:</p>
<pre>export default function TableComponent(props) {

  const { result } = props;
  return (
    &lt;Table&gt;
      &lt;Row&gt;&lt;Cell&gt;{result.name}&lt;/Cell&gt;&lt;/Row&gt;
      &lt;Row&gt;&lt;Cell&gt;Hair Color&lt;/Cell&gt;&lt;Cell&gt;{result.hairColor}&lt;/Cell&gt;&lt;/Row&gt;
      &lt;Row&gt;&lt;Cell&gt;Height&lt;/Cell&gt;&lt;Cell&gt;{result.height}&lt;/Cell&gt;&lt;/Row&gt;
      &lt;Row&gt;&lt;Cell&gt;Weight&lt;/Cell&gt;&lt;Cell&gt;{result.weight}&lt;/Cell&gt;&lt;/Row&gt;
      &lt;Row&gt;&lt;Cell&gt;Date of Birth&lt;/Cell&gt;&lt;Cell&gt;{result.dateOfBirth}&lt;/Cell&gt;&lt;/Row&gt;
      &lt;Row&gt;
        &lt;Cell&gt;{result.filmNames.length &lt;= 1 ? "Film" : "Films"}&lt;/Cell&gt;
        &lt;Cell&gt;{result.filmNames.length === 0 ?
          "None" :
          result.filmNames.map((film, idx) =&gt; (
            &lt;LineItem key={'film' + idx}&gt;{film}&lt;/LineItem&gt;))}
        &lt;/Cell&gt;
      &lt;/Row&gt;
    &lt;/Table&gt;
  )
}</pre>
<p>这将成为一个好榜样。我们在这里看到的每个元素都是我在别处定义的一个<code>styled-component</code>；它们是这样定义的<code>const Table = styled.div;</code>(在引号之间定义了一堆CSS)。</p>
<p>首先，在我的项目中完全没有使用任何类型脚本。文件名是<code>TableComponent.js</code>，为了简单起见，它是App.js的子文件。我最初是用<code>create-react-app</code>初始化这个项目的——你也可以很容易地这样做。你唯一需要跟随的包裹是<code>styled-components</code>。</p>
<p>接下来要添加TypeScript，可以通过<code>npm</code>安装几样东西:</p>
<pre>npm i --save typescript @types/react @types/react-dom @types/styled-components</pre>
<p>在这一级别，让我们在终端中运行命令:</p>
<pre>npx tsc --init</pre>
<p>这将创建我们的<code>tsconfig.json</code>文件。</p>
<p>现在，您可能会注意到您的<code>tsconfig.json</code>文件中有一个错误。如果您将鼠标悬停在该文件中最上面的第一个花括号上，您将会看到以下错误:</p>
<p>"错误TS18003:在配置文件<code>tsconfig.json</code>中找不到输入。指定的<code>include</code>路径为<code>["**/*"]</code>，<code>exclude</code>路径为<code>[]</code></p>
<p>我注意到这个错误时不时地出现，如果你关闭你的编辑器然后再打开，但是如果你试着运行你的应用程序，你会看到这个错误。</p>
<p>这里的基本思想是，我们至少需要一个TypeScript文件，编译器才能工作。让我们把<code>TableComponent.js</code>的文件名改成<code>TableComponent.tsx</code>。您可能需要重新启动IDE，就像我在使用Visual Studio代码时所做的那样，但是您应该会在道具下和其他一些地方看到红线，这表示有错误。</p>
<p>我们将到达那里，但是首先让我们试着用这个命令运行它:</p>
<pre>npm run start</pre>
<p>它会变得很远，你甚至可以看到应用程序组件完成了，但是我们的<code>TableComponent</code>会显示一个错误。</p>
<p>更具体地说，您将看到一个Typescript错误:“参数<code>props</code>隐式地具有一个<code>any</code>类型。TS7006”。</p>
<p>这正是红线所指示的。这是因为<code>noImplicitAny</code>被默认为true，而这正是我们想要的。我们可以转到我们的<code>tsconfig.json</code>文件，并将其更改为false。然后，我们将没有错误，但基本上有普通的JavaScript。</p>
<p><img data-attachment-id="27374" data-permalink="https://blog.logrocket.com/a-simple-guide-for-migrating-from-javascript-to-typescript/typescript/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/10/typescript.png" data-orig-size="890,194" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="typescript" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/10/typescript-300x65.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/10/typescript.png" decoding="async" class="aligncenter wp-image-27374 jetpack-lazy-image" src="../Images/3bf9329b32a2e497524277c4745498ea.png" alt="A screenshot of a codeblock in TypeScript." data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2020/10/typescript.png 890w, https://blog.logrocket.com/wp-content/uploads/2020/10/typescript-300x65.png 300w, https://blog.logrocket.com/wp-content/uploads/2020/10/typescript-768x167.png 768w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2020/10/typescript.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/10/typescript.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="27374" data-permalink="https://blog.logrocket.com/a-simple-guide-for-migrating-from-javascript-to-typescript/typescript/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/10/typescript.png" data-orig-size="890,194" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="typescript" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/10/typescript-300x65.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/10/typescript.png" decoding="async" loading="lazy" class="aligncenter wp-image-27374" src="../Images/3bf9329b32a2e497524277c4745498ea.png" alt="A screenshot of a codeblock in TypeScript." srcset="https://blog.logrocket.com/wp-content/uploads/2020/10/typescript.png 890w, https://blog.logrocket.com/wp-content/uploads/2020/10/typescript-300x65.png 300w, https://blog.logrocket.com/wp-content/uploads/2020/10/typescript-768x167.png 768w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/10/typescript.png"/></noscript>
<p>值得注意的一点是，TypeScript运行在我们当前的bundler之上，而没有干扰它。</p>
<p>我们做了一个<code>npm run start</code>,尽管我们似乎没有调用任何类型脚本。从技术上讲，当<code>noEmit</code>选项设置为true时，TypeScript只是在我们的JSX中检查类型，但是我们的bundler发出/输出它。另一件事是查看<code>tsconfig.json</code>文件——它读取了我们的应用程序，并为我们填写了一些默认选项。</p>
<p>让我们也注意一下TypeScript在我们的项目中做了什么:它在我们的<code>src</code>文件夹中自动创建了一个名为<code>react-app-env.d.ts</code>的文件。这个文件并不太重要，但是您会注意到，即使您删除了它，它也会在每次启动/构建时自动生成。让TypeScript了解<code>react-scripts</code>类型是一件奇怪的事情。</p>
<p>事不宜迟，让我们把这个文件改成TypeScript。</p>
<h3>JSX到TSX</h3>
<p>我们可以通过在变量末尾添加<code>: any</code>来轻松消除红线错误，但这基本上没用。</p>
<p>一个更好的方法是做TypeScript应该做的事情:检查类型以避免错误。让我们从解决映射函数中的变量开始:“电影”。</p>
<p>你会看到它们下面有红线，坦白地说，它们是最容易理解它们所需要的类型:它们都是字符串，所以我们可以很容易地浏览并在最后加上注释:<code>: string</code>。</p>
<p>然后，我们可以用<code>: number</code>注释<code>idx</code>，它会满足TypeScript编译器。所有这些都没问题，但是props变量仍然存在问题，它仍然没有注释。老实说，在JSX仔细检查道具并做注解并不是最好的方式。</p>
<p>更好的方法是为传入的道具创建我们自己的TypeScript接口或类型。现在，当我们从一个API(或者更好，如果我们已经创建了它，也在API中)获取结果时，我们可能已经在父<code>App.js</code>组件中正常地完成了这一点，但是因此你可以看到TypeScript的灵活性，你甚至不需要这样做。</p>
<p>让我们为我们的道具创建一个类型:</p>
<pre>type Props = {
  result: Result,
};</pre>
<p>然后输入结果:</p>
<pre>type Result = {
  name: string,
  hairColor: string,
  height: string,
  weight: string,
  dateOfBirth: string,
  filmNames: string[],
};</pre>
<p>然后，简单注释一下道具:<code>props: Props</code>。现在，你应该看到电影不再是红色下划线。</p>
<p>我们可以把这些接口中的每一个都做成一个新的类型，但是作为一个通用的经验法则，尽量把更多受控的东西(比如道具)做成一个类型。关于在类型和接口之间选择的更多信息，请参见这篇文章。</p>
<h2>样式组件</h2>
<p>这绝不是完整的TypeScript指南。然而，为了看更多的基础知识，让我们看看<code>styled-components</code>。</p>
<p>现在我们没有错误，但是关于样式化组件的一个很棒的事情是能够传入一个道具，所以你可以重用相同的定义，并根据道具做一点改变。</p>
<p>例如，在我们的JSX中，我们希望第一个单元格(一个样式化的组件)占据整个表格的宽度，但是其他单元格应该只有一半的宽度。所以让我们在这里放一个“头”道具:</p>
<pre>&lt;Cell header&gt; {result.name} &lt;/Cell&gt;.</pre>
<p>TypeScript不喜欢这个，也不知道怎么处理。以下是我目前对细胞的定义:</p>
<pre>const Cell = styled.div`
  padding: 5px 20px;
  display: flex;
  border: 1px solid black;
  flex-direction: column;
  justify-content: center;
  align-items: center;
  width: 50%;
`;</pre>
<p>通常，我们可以将我们的道具添加到我们创建的样式中，如下所示:</p>
<pre>width: ${props =&gt; props.header ? '100%' : '50%}</pre>
<p>但是我们会看到，根据TypeScript，header在这里也是一个错误，因为我们还没有定义它。</p>
<p>我们需要为细胞道具创造一种新的类型，就像这样:</p>
<pre>type cellProp = {
  header: boolean,
};</pre>
<p>现在将它添加到我们创建的单元组件中:</p>
<pre>const Cell =
  styled.div &lt;
  cellProp &gt;
  `
        ...
        width: ${(props) =&gt; (props.header ? "100%" : "50%")};
    `;</pre>
<p>这将清除错误。然后我们得到了其他东西:Cell的每个其他实例都得到一个错误，因为它没有header属性。</p>
<p>这可能看起来很奇怪，但这是预期的行为——我们告诉TypeScript Cell的每个实例都需要这个头布尔值。</p>
<p>我们可以遍历并使每个实例都有一个prop <code>header={false}</code>，但这在我们的JSX中是额外的混乱。</p>
<p>一个更好的解决方案是让header prop可选。我们可以通过在类型定义中添加一个问号来轻松做到这一点:</p>
<pre>type cellProps = {
  header?: boolean,
};</pre>
<p>维奥拉。不再有错误。</p>
<h2>结论</h2>
<p>这有点将React组件迁移到TypeScript的味道。如您所见，迁移到TypeScript一点也不麻烦。它很灵活，所以您可以在需要它的文件上使用它，同时等待优先级较低的文件。在您知道之前，您可以让TypeScript在您的项目中工作！</p>
<p>更多信息，请参见<a href="https://www.typescriptlang.org/" target="_blank" rel="noopener noreferrer">正式文档</a>。</p><div class="code-block code-block-21">
<div class="blog-plug inline-plug typescript-plug"><h2><a class="signup" href="https://lp.logrocket.com/blg/typescript-signup" target="_blank" rel="noopener noreferrer"> LogRocket </a>:全面了解您的网络和移动应用</h2>
<a href="https://lp.logrocket.com/blg/typescript-signup" class="signup" target="_blank" rel="noopener noreferrer"><img class="alignnone size-full wp-image-46 jetpack-lazy-image" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/><noscript><img data-lazy-fallback="1" class="alignnone size-full wp-image-46" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/></noscript></a>
<p>LogRocket 是一个前端应用程序监控解决方案，可以让您回放问题，就像问题发生在您自己的浏览器中一样。LogRocket不需要猜测错误发生的原因，也不需要向用户询问截图和日志转储，而是让您重放会话以快速了解哪里出错了。它可以与任何应用程序完美配合，不管是什么框架，并且有插件可以记录来自Redux、Vuex和@ngrx/store的额外上下文。</p>
<p>除了记录Redux操作和状态，LogRocket还记录控制台日志、JavaScript错误、堆栈跟踪、带有头+正文的网络请求/响应、浏览器元数据和自定义日志。它还使用DOM来记录页面上的HTML和CSS，甚至为最复杂的单页面和移动应用程序重新创建像素级完美视频。</p>
<a class="signup" href="https://lp.logrocket.com/blg/typescript-signup" target="_blank" rel="noopener noreferrer">Try it for free</a><p>.</p></div>
</div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
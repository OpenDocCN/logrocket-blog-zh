<html>
<head>
<title>Offline storage for PWAs - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>PWAs - LogRocket博客的离线存储</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/offline-storage-for-pwas/#0001-01-01">https://blog.logrocket.com/offline-storage-for-pwas/#0001-01-01</a></blockquote><div><article class="article-post">
<p>无论您正在构建什么类型的应用程序，您都可能希望存储在单个用户会话之后仍然存在的信息。有时(但不总是)，您希望这些信息存储在某种集中式数据库中。如果用户离线，您可能还希望这些数据可用，这样即使他们无法连接到网络，他们仍然可以使用应用程序来执行有意义的任务。</p>
<p>为了实现这一功能，该应用程序可能需要大量的数据。我们如何在一个<a href="https://blog.logrocket.com/from-create-react-app-to-pwa/" target="_blank" rel="noopener noreferrer">渐进式网络应用(PWA) </a>的环境中实现这一点？</p>
<h2 id="theproblemwithlocalstorage"><code>localStorage</code>的问题</h2>
<p>如果您正在构建一个经典的web应用程序，您可能会在此时使用<a href="https://developer.mozilla.org/en-US/docs/Web/API/Window/localStorage" target="_blank" rel="noopener noreferrer"> <code>Window.localStorage</code> </a>。<code>Window.localStorage</code>是一个长期存在的API，它存储单个会话之外的数据。它有一个简单的API，非常容易使用。然而，它提出了几个关键问题:</p>
<ul>
<li><code>Window.localStorage</code>是同步的，这对于每个应用程序来说都不是一个大问题，但是如果你正在构建的东西有很高的性能需求，这可能会导致问题</li>
<li><code>Window.localStorage</code>不能在<code>Worker</code>或<code>ServiceWorker</code>的上下文中使用，因为API在那里不可用。</li>
<li><code>Window.localStorage</code>只存储<code>string</code>s；鉴于<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify" target="_blank" rel="noopener noreferrer"> <code>JSON.stringify</code> </a>和<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/parse" target="_blank" rel="noopener noreferrer"> <code>JSON.parse</code> </a>，这并不是什么大问题，但肯定会带来不便</li>
</ul>
<p>这里的第二点很重要。如果您需要在<code>ServiceWorker</code>环境中访问离线数据，您会怎么做——如果您正在离线工作，您几乎肯定会这样做。</p>
<h2 id="indexeddbtotherescue">IndexedDB不足之处</h2>
<p>幸运的是，<code>localStorage</code>不是镇上唯一的游戏。浏览器中有一种替代的离线存储机制，它有一个奇怪的名字叫做<a href="https://developer.mozilla.org/en-US/docs/Web/API/IndexedDB_API" target="_blank" rel="noopener noreferrer"> IndexedDB </a>。引用文档:</p>
<blockquote><p>IndexedDB是一个事务数据库系统，类似于基于SQL的RDBMS。然而，与使用固定列表的基于SQL的RDBMSes不同，IndexedDB是基于JavaScript的面向对象数据库。IndexedDB允许您存储和检索用键索引的对象；可以存储结构化克隆算法支持的任何对象。您需要指定数据库模式，打开到数据库的连接，然后在一系列事务中检索和更新数据。</p></blockquote>
<p>很明显，IndexedDB非常强大，但听起来肯定不简单。进一步看看如何与IndexedDB交互的<a href="https://github.com/mdn/to-do-notifications/blob/8b3e1708598e42062b0136608b1c5fbb66520f0a/scripts/todo.js#L48" target="_blank" rel="noopener noreferrer"> MDN示例</a>,不会与这种想法相矛盾。</p>
<p>我们希望能够离线访问数据，但是以一种简单的方式——就像我们用<code>localStorage</code>一样，它有一个非常简单的API。要是有人能在IndexedDB上构建一个抽象来让我们的生活变得更简单就好了…</p>
<p>幸运的是，有人做到了。</p>
<h2 id="idbkeyvaltotherescue">IDB-Keyval来救援了！</h2>
<p>谷歌的杰克·阿奇博尔德创建了<a href="https://github.com/jakearchibald/idb-keyval" target="_blank" rel="noopener noreferrer"> IDB-Keyval </a>，它宣称自己是一个“基于承诺的超级简单的Keyval商店，使用IndexedDB实现”</p>
<p>这个API本质上相当于<code>localStorage</code>,只是有一些可爱的区别:</p>
<ul>
<li>API是基于承诺的；所有函数都返回一个<code>Promise</code>，这使得它成为一个非阻塞API</li>
<li>与<code>localStorage</code>不同，API不局限于<code>string</code> s。根据文档，它是IDB支持的，这意味着你可以存储任何结构化的可克隆的东西，比如数字、数组、对象、日期、blobs等等</li>
<li>因为这是建立在IndexedDB之上的抽象，所以它既可以用在典型的web应用程序的上下文中，也可以用在<code>Worker</code>或<code>ServiceWorker</code>中(如果需要的话)</li>
</ul>
<h2 id="simpleusage">基本用途</h2>
<p>为了展示如何使用IDB-Keyval，我们需要一个示例应用程序。我们将演示它的基本功能以及如何在应用程序中使用它。</p>
<p>让我们用<a href="https://create-react-app.dev/" target="_blank" rel="noopener noreferrer"> Create React App </a>创建一个TypeScript React app:</p>
<pre>npx create-react-app offline-storage-in-a-pwa --template typescript
</pre>
<p>接下来，将IDB-Keyval添加到其中。</p>
<pre>yarn add idb-keyval
</pre>
<p>更新<code>index.tsx</code>文件，添加一个使用IDB-Keyval进行测试的函数。</p>
<pre>import React from 'react';
import ReactDOM from 'react-dom';
import { set, get } from 'idb-keyval';
import './index.css';
import App from './App';
import * as serviceWorker from './serviceWorker';

ReactDOM.render(&lt;App /&gt;, document.getElementById('root'));

serviceWorker.register();

async function testIDBKeyval() {
    await set('hello', 'world');
    const whatDoWeHave = await get('hello');
    console.log(`When we queried idb-keyval for 'hello', we found: ${whatDoWeHave}`);
}

testIDBKeyval();
</pre>
<p><code>testIDBKeyval</code>功能执行以下操作:</p>
<ul>
<li>使用IDB-Keyval为<code>'hello'</code>的键添加值<code>'world'</code>到IndexedDB</li>
<li>使用IDB-Keyval查询IndexedDB的关键字<code>'hello'</code>，并将其存储在变量<code>whatDoWeHave</code>中</li>
<li>记录我们发现的东西</li>
</ul>
<p>你还会注意到<code>testIDBKeyval</code>是一个<code>async</code>函数。这是为了让我们在与IDB-Keyval交互时可以使用<code>await</code>。鉴于它的API是基于<code>Promise</code>的，它是<code>await-</code>友好的。当您一次执行多个异步操作时，使用<a href="https://blog.logrocket.com/async-await-in-typescript/" target="_blank" rel="noopener noreferrer"> async/await </a>来增加代码库的可读性通常是有价值的。</p>
<p>当我们用<code>yarn start</code>运行我们的应用程序时会发生什么？让我们这样做，并看看开发工具。</p>
<p><img data-attachment-id="15149" data-permalink="https://blog.logrocket.com/offline-storage-for-pwas/hello_world_idb_keyval-2/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/03/hello_world_idb_keyval-1.png" data-orig-size="725,548" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Hello World app using IDB-Keyval" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/03/hello_world_idb_keyval-1-300x227.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/03/hello_world_idb_keyval-1.png" decoding="async" class="aligncenter size-full wp-image-15149 jetpack-lazy-image" src="../Images/f4c753e4a1fdf8e06673482cea8e6109.png" alt="Hello World App Using IDB-Keyval" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2020/03/hello_world_idb_keyval-1.png 725w, https://blog.logrocket.com/wp-content/uploads/2020/03/hello_world_idb_keyval-1-300x227.png 300w" data-lazy-sizes="(max-width: 725px) 100vw, 725px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2020/03/hello_world_idb_keyval-1.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/03/hello_world_idb_keyval-1.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="15149" data-permalink="https://blog.logrocket.com/offline-storage-for-pwas/hello_world_idb_keyval-2/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/03/hello_world_idb_keyval-1.png" data-orig-size="725,548" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Hello World app using IDB-Keyval" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/03/hello_world_idb_keyval-1-300x227.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/03/hello_world_idb_keyval-1.png" decoding="async" loading="lazy" class="aligncenter size-full wp-image-15149" src="../Images/f4c753e4a1fdf8e06673482cea8e6109.png" alt="Hello World App Using IDB-Keyval" srcset="https://blog.logrocket.com/wp-content/uploads/2020/03/hello_world_idb_keyval-1.png 725w, https://blog.logrocket.com/wp-content/uploads/2020/03/hello_world_idb_keyval-1-300x227.png 300w" sizes="(max-width: 725px) 100vw, 725px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/03/hello_world_idb_keyval-1.png"/></noscript>
<p>我们成功地将一些内容写入IndexedDB，读回它，并将该值打印到控制台。</p>
<h2 id="usageinreact">在React中使用IDB-Keyval</h2>
<p>到目前为止，我们所做的有点抽象。为了实现一个真实的用例，让我们创建一个应用程序，使用户能够在黑暗模式和常规显示之间进行选择。</p>
<p>首先，我们将把我们的<code>App.tsx</code>替换为:</p>
<pre>import React, { useState } from "react";
import "./App.css";

const sharedStyles = {
  height: "30rem",
  fontSize: "5rem",
  textAlign: "center"
} as const;

function App() {
  const [darkModeOn, setDarkModeOn] = useState(true)
  const handleOnChange = ({ target }: React.ChangeEvent&lt;HTMLInputElement&gt;) =&gt; setDarkModeOn(target.checked);

  const styles = {
    ...sharedStyles,
    ...(darkModeOn
      ? {
          backgroundColor: "black",
          color: "white"
        }
      : {
          backgroundColor: "white",
          color: "black"
        })
  };

  return (
    &lt;div style={styles}&gt;
      &lt;input
        type="checkbox"
        value="darkMode"
        checked={darkModeOn}
        id="darkModeOn"
        name="darkModeOn"
        style={{ width: "3rem", height: "3rem" }}
        onChange={handleOnChange}
      /&gt;
      &lt;label htmlFor="darkModeOn"&gt;Use dark mode?&lt;/label&gt;
    &lt;/div&gt;
  );
}

export default App;
</pre>
<p>当你运行这个应用程序时，你可以看到它是如何工作的。</p>
<p><img data-attachment-id="15151" data-permalink="https://blog.logrocket.com/offline-storage-for-pwas/use-dark-mode-2/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/03/use-dark-mode-1.gif" data-orig-size="725,144" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Dark mode option" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/03/use-dark-mode-1-300x60.gif" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/03/use-dark-mode-1.gif" decoding="async" class="aligncenter size-full wp-image-15151 jetpack-lazy-image" src="../Images/68ccdb3bf20db1692b3e22232cb8f277.png" alt="Dark Mode Option" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2020/03/use-dark-mode-1.gif?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/03/use-dark-mode-1.gif"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="15151" data-permalink="https://blog.logrocket.com/offline-storage-for-pwas/use-dark-mode-2/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/03/use-dark-mode-1.gif" data-orig-size="725,144" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Dark mode option" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/03/use-dark-mode-1-300x60.gif" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/03/use-dark-mode-1.gif" decoding="async" loading="lazy" class="aligncenter size-full wp-image-15151" src="../Images/68ccdb3bf20db1692b3e22232cb8f277.png" alt="Dark Mode Option" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/03/use-dark-mode-1.gif"/></noscript>
<p>如你所见，这是使用React的<code>useState</code>钩子实现的。页面刷新时，任何选定的用户首选项都将丢失。让我们看看是否可以使用<code>IDB-Keyval</code>将这个状态转移到IndexedDB中。</p>
<p>我们将这样修改代码:</p>
<pre>import React, { useState, useEffect } from "react";
import { set, get } from "idb-keyval";
import "./App.css";

const sharedStyles = {
  height: "30rem",
  fontSize: "5rem",
  textAlign: "center"
} as const;

function App() {
  const [darkModeOn, setDarkModeOn] = useState&lt;boolean | undefined&gt;(undefined);

  useEffect(() =&gt; {
    get&lt;boolean&gt;("darkModeOn").then(value =&gt;
      // If a value is retrieved then use it; otherwise default to true
      setDarkModeOn(value ?? true)
    );
  }, [setDarkModeOn]);

  const handleOnChange = ({ target }: React.ChangeEvent&lt;HTMLInputElement&gt;) =&gt; {
    setDarkModeOn(target.checked);

    set("darkModeOn", target.checked);
  };

  const styles = {
    ...sharedStyles,
    ...(darkModeOn
      ? {
          backgroundColor: "black",
          color: "white"
        }
      : {
          backgroundColor: "white",
          color: "black"
        })
  };

  return (
    &lt;div style={styles}&gt;
      {darkModeOn === undefined ? (
        &lt;&gt;Loading preferences...&lt;/&gt;
      ) : (
        &lt;&gt;
          &lt;input
            type="checkbox"
            value="darkMode"
            checked={darkModeOn}
            id="darkModeOn"
            name="darkModeOn"
            style={{ width: "3rem", height: "3rem" }}
            onChange={handleOnChange}
          /&gt;
          &lt;label htmlFor="darkModeOn"&gt;Use dark mode?&lt;/label&gt;
        &lt;/&gt;
      )}
    &lt;/div&gt;
  );
}

export default App;
</pre>
<p>让我们概述一下变化。</p>
<ul>
<li><code>darkModeOn</code>现在被初始化为<code>undefined</code>，应用程序显示加载信息，直到<code>darkModeOn</code>有一个值</li>
<li>该应用程序尝试使用键<code>'darkModeOn'</code>从IDB-Keyval加载一个值，并使用检索到的值设置<code>darkModeOn</code>。如果没有检索到值，它将<code>darkModeOn</code>设置为<code>true</code></li>
<li>当复选框改变时，相应的值应用于<code>darkModeOn</code>并保存到IDB-Keyval和密钥<code>'darkModeOn'</code></li>
</ul>
<p>这意味着除了页面刷新之外，我们还在以一种在线和离线都可以工作的方式保持首选项。</p>
<p><img data-attachment-id="15150" data-permalink="https://blog.logrocket.com/offline-storage-for-pwas/use-dark-mode-with-idb-keyval-2/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/03/use-dark-mode-with-idb-keyval-1.gif" data-orig-size="725,357" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Use dark mode with IDB-Keyval" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/03/use-dark-mode-with-idb-keyval-1-300x148.gif" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/03/use-dark-mode-with-idb-keyval-1.gif" decoding="async" class="aligncenter size-full wp-image-15150 jetpack-lazy-image" src="../Images/6be4c2cbb02c16403ca9596278446f3f.png" alt="Use Dark Mode With IDB-Keyval" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2020/03/use-dark-mode-with-idb-keyval-1.gif?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/03/use-dark-mode-with-idb-keyval-1.gif"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="15150" data-permalink="https://blog.logrocket.com/offline-storage-for-pwas/use-dark-mode-with-idb-keyval-2/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/03/use-dark-mode-with-idb-keyval-1.gif" data-orig-size="725,357" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Use dark mode with IDB-Keyval" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/03/use-dark-mode-with-idb-keyval-1-300x148.gif" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/03/use-dark-mode-with-idb-keyval-1.gif" decoding="async" loading="lazy" class="aligncenter size-full wp-image-15150" src="../Images/6be4c2cbb02c16403ca9596278446f3f.png" alt="Use Dark Mode With IDB-Keyval" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/03/use-dark-mode-with-idb-keyval-1.gif"/></noscript>
<h2 id="usageasareacthook">使用IDB-Keyval作为React挂钩</h2>
<p>为了加分，让我们把这个功能移到一个可重用的React钩子中。</p>
<p>创建一个新的<code>usePersistedState.ts</code>文件。</p>
<pre>import { useState, useEffect, useCallback } from "react";
import { set, get } from "idb-keyval";

export function usePersistedState&lt;TState&gt;(keyToPersistWith: string, defaultState: TState) {
    const [state, setState] = useState&lt;TState | undefined&gt;(undefined);

    useEffect(() =&gt; {
        get&lt;TState&gt;(keyToPersistWith).then(retrievedState =&gt;
            // If a value is retrieved then use it; otherwise default to defaultValue
            setState(retrievedState ?? defaultState));
    }, [keyToPersistWith, setState, defaultState]);

    const setPersistedValue = useCallback((newValue: TState) =&gt; {
        setState(newValue);
        set(keyToPersistWith, newValue);
    }, [keyToPersistWith, setState]);

    return [state, setPersistedValue] as const;
}
</pre>
<p>这个新的钩子是仿照<a href="https://reactjs.org/docs/hooks-reference.html#usestate" target="_blank" rel="noopener noreferrer"> <code>useState</code> </a>的API，命名为<code>usePersistentState</code>。它需要一个密钥，这个密钥将用于保存数据。它还需要一个缺省值，以防在查找过程中一无所获。</p>
<p>就像<code>useState</code>一样，它返回一个有状态的值和一个更新它的函数。</p><div class="code-block code-block-54">
<hr/>
<h3>更多来自LogRocket的精彩文章:</h3>

<hr/></div>
<p>最后，让我们切换我们的<code>App.tsx</code>来使用我们闪亮的新钩子。</p>
<pre>import React from "react";
import "./App.css";
import { usePersistedState } from "./usePersistedState";

const sharedStyles = {
  height: "30rem",
  fontSize: "5rem",
  textAlign: "center"
} as const;

function App() {
  const [darkModeOn, setDarkModeOn] = usePersistedState&lt;boolean&gt;("darkModeOn", true);

  const handleOnChange = ({ target }: React.ChangeEvent&lt;HTMLInputElement&gt;) =&gt;
    setDarkModeOn(target.checked);

  const styles = {
    ...sharedStyles,
    ...(darkModeOn
      ? {
        backgroundColor: "black",
        color: "white"
      }
      : {
        backgroundColor: "white",
        color: "black"
      })
  };

  return (
    &lt;div style={styles}&gt;
      {darkModeOn === undefined ? (
        &lt;&gt;Loading preferences...&lt;/&gt;
      ) : (
          &lt;&gt;
            &lt;input
              type="checkbox"
              value="darkMode"
              checked={darkModeOn}
              id="darkModeOn"
              name="darkModeOn"
              style={{ width: "3rem", height: "3rem" }}
              onChange={handleOnChange}
            /&gt;
            &lt;label htmlFor="darkModeOn"&gt;Use dark mode?&lt;/label&gt;
          &lt;/&gt;
        )}
    &lt;/div&gt;
  );
}

export default App;</pre>
<h2>结论</h2>
<p>现在，您应该对web应用程序或PWA如何使用本机浏览器功能安全轻松地存储会话间持久化的数据有了深入的了解。</p>
<p>IndexedDB支持我们在本教程中构建的解决方案。我们使用IDB-Keyval而不是IndexedDB，因为它提供了令人愉快和熟悉的抽象。这允许我们用一个类似的可爱的API来构建一个解决方案。</p>
<p>值得注意的是，IDB-Keyval还有其他选择，比如<a href="https://github.com/localForage/localForage" target="_blank" rel="noopener noreferrer">local feed</a>，如果您正在为可能缺乏良好IndexedDB支持的旧浏览器构建，这将是一个特别好的选择。但是请注意，随着向后兼容性的提高，下载量也会增加。做出对你有意义的权衡是很重要的。</p>
<p>最后，我们展示了如何在React上下文中使用IDB-Keyval。请注意，我们的离线存储机制没有任何React特定的内容。所以，如果你正在使用Vue，Angular，或者其他什么东西，这个教程也可以帮助你。</p>
<p>简而言之，离线存储可以带来更好的用户体验。您应该考虑在您的应用程序中使用它。</p><div class="code-block code-block-17">
<div class="blog-plug inline-plug react-plug" vwo-el-id="26283398190">
<h2 vwo-el-id="41600691720"><a href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener"> LogRocket </a>:全面了解您的生产React应用</h2><p>调试React应用程序可能很困难，尤其是当用户遇到难以重现的问题时。如果您对监视和跟踪Redux状态、自动显示JavaScript错误以及跟踪缓慢的网络请求和组件加载时间感兴趣，</p><a href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" vwo-el-id="19356441070">try LogRocket</a><p>. </p><a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="19356441380">
<img class="first-react-image alignnone size-full wp-image-46 jetpack-lazy-image jetpack-lazy-image--handled" src="../Images/f300c244a1a1cf916df8b4cb02bec6c6.png" vwo-el-id="18272717540" data-lazy-loaded="1" data-original-src="https://files.readme.io/27c94e7-Image_2017-06-05_at_9.46.04_PM.png"/>
</a>
<a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="19356441690">
<img class="second-react-image alignnone size-full wp-image-46 jetpack-lazy-image jetpack-lazy-image--handled" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" vwo-el-id="30720362350" data-lazy-loaded="1" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/>
</a>
<p vwo-el-id="28675660440" class="">LogRocket 结合了会话回放、产品分析和错误跟踪，使软件团队能够创建理想的web和移动产品体验。这对你来说意味着什么？</p>
<p>LogRocket不是猜测错误发生的原因，也不是要求用户提供截图和日志转储，而是让您回放问题，就像它们发生在您自己的浏览器中一样，以快速了解哪里出错了。</p>
<p>不再有嘈杂的警报。智能错误跟踪允许您对问题进行分类，然后从中学习。获得有影响的用户问题的通知，而不是误报。警报越少，有用的信号越多。</p>
<p vwo-el-id="28675660750">LogRocket Redux中间件包为您的用户会话增加了一层额外的可见性。LogRocket记录Redux存储中的所有操作和状态。</p>
<p vwo-el-id="28675661060">现代化您调试React应用的方式— <a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="40093418840">开始免费监控</a>。</p>
</div></div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
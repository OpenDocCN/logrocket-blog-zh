# 是 Go 超车 Node.js？

> 原文：<https://blog.logrocket.com/go-overtaking-node-js/>

***编者按:**本帖更新于 2022 年 3 月 16 日，删除并更正了过时的信息。*

Go 和 Node.js 都是在 2009 年首次发布，用于开发服务器端和网络应用程序。

Go 可以解决很多问题，包括系统、大数据、机器学习、视频编辑和音频等等。它还具有与 C 相同的性能，因为它编译成机器代码，不需要虚拟机或解释器。

在你认为这篇文章是另一场“科技战争”之前，我建议你放慢脚步，继续读下去。这只是 Go 和 Node.js 的对比，我会在这里分享两者的优劣。

因此，虽然 Go 是一个强大的工具，但我并不是在这里拒绝 Node.js。此外，它本质上取决于您想要用哪一个来构建。

Node.js 和 Go 非常快，非常适合多线程程序(Node 是单线程的，但它可以很好地完成工作，这使得多线程变得没有必要)。

好吧，我们别闹了。在本文中，我们将看看这两个强大工具的优缺点，看看它们如何处理不同的情况，了解它们的可伸缩性，并回答这个问题，“是 Go 超越 Node.js 吗？”

## Go vs. Node.js

Node.js 是用 JavaScript 构建跨平台应用程序的最流行的环境。它有助于构建快速和可伸缩的服务器端应用程序，其强大的特性包括事件驱动和非阻塞 I/O 模型。

另一方面，Go 是一种开源的、静态类型的、编译的、跨平台的、快速的和多用途的语言，它提供了最大的并发性、自动内存管理和用于结构类型检查的动态接口。

Go 在语法和速度上和 C 类似。它也类似于 C++，因为它是编译的，是一种通用语言。

不要用这些介绍性的或基础的东西来烦你，它们都是流行的和不断发展的，并且基于不同的项目工作得最好，但是我们将深入研究利弊以确定哪个适合你的项目。

### 并发

#### Go 擅长并发吗？

[Go 使用协程](https://blog.logrocket.com/concurrency-patterns-golang-waitgroups-goroutines/)处理并发，这被称为 Goroutines。这些函数或方法与其他函数或方法同时运行。通道使通信能够在处理共享内存时避免竞争情况。

Goroutines 是围棋的强势方面；如果一个大型项目需要同时处理几个请求，Go 将会执行。然而，Node.js 的情况并非如此。

#### Node 对并发性好吗？

Node.js 是一个使用事件回调机制的单线程工具。这意味着每个函数或方法都以线性顺序执行。

回调是一个在函数完成执行后执行的函数，这意味着我们只能决定等待函数的结果稍后完成。所以，Node.js 缺乏并发性。

说到并发性，Go 是必然的赢家。

### 错误处理

#### Go 的错误处理好吗？

与使用异常方法处理错误的 Node.js 不同，Go 使用显式样式。没有意外的未捕获的异常。例如，对于每个 Go 项目，您经常会看到以下代码:

```
if err != nil {
    return err
}

```

对于一个围棋门外汉来说，这听起来可能是多余的，但围棋的主要目标之一是作为每项功能的一等公民接受错误，这是一种“计划失败，而不是成功”的心态。

使用 if `err != nil`返回值或错误，这有助于您注意到必须首先处理失败。没有必要围绕`try catch`，它处理每一个可能的异常。

linters 的另一个优点是，当你忽略一个错误时，它们会抓住你。

#### Node.js 中的错误处理是什么？

关于 Node.js，[错误处理不清楚，不明确](https://blog.logrocket.com/error-handling-node-js/)。下面的代码正确地处理了错误，但是没有明确或正确地处理出错的地方。错误只会传到控制台，不允许负全部责任。

```
try {
    operation1();
    operation2();
    operation3();
} catch (e) {
    console.error(e);
}

```

Go 在处理错误时使用了一种训练有素、有条不紊的编码方式，是这里的赢家。

### 可量测性

#### Go 可扩展吗？

一开始，Go 就在可伸缩性方面胜过 Node.js，因为它支持并发性，这有助于处理并行任务。Go 每秒可以管理 1000 个并发请求，让 Go 更胜一筹。

#### Node.js 扩展性强吗？

Node.js 的弱点是它在单线程机制上工作，这意味着任务是一个接一个地执行的，这使得它的可伸缩性较差。但是，它确实允许事件回调的并发性，但是这些并不有效，与并行性 ***相去甚远。***

这并不意味着 Node.js 也不可伸缩，但是 Go 在并发性方面做得更好，内存效率也更高。因此，如果您有一个 CPU 密集型应用程序，Go 就是您应该去的地方。

### 开发人员工资

根据 Stackoverflow 2021 年开发者调查，Go 以 76800 美元的年薪轻松超过 Node.js，而 Node.js 开发者的年薪为 56860 美元。

![Stack Overflow High Pay Go Node.js Scatter Plot](img/d1c9f46a3a2403a7ab9745ad23cd8d02.png)

在这一点上，这甚至不是一场战斗。

### 表演

#### Golang 是表演型的吗？

对于原始性能， [Go 开发者已经表示，它在速度和性能方面表现出了与 C 和 C++相同的特性](https://blog.logrocket.com/benchmarking-golang-improve-function-performance/)，这真的很好。

通过其内存管理(垃圾收集器)，它可以清除未使用的内存，从而降低因内存泄漏而带来的安全风险。

[Go 甚至适合构建微服务](https://blog.logrocket.com/building-microservices-go-gin/),因为它具有处理重负载、高速度和支持并发的能力。事实上，它编译成一个相对较小的、静态链接的本地二进制文件，具有相对较小的、固定的运行时开销，这使得它适合安装在 Docker 容器中。

#### Node.js 性能高吗？

就原始性能而言，Node.js 与 Go 相比并不出色，但在现场性能中，一切都与 Go 一样。

在库和包方面，Go 的开发工具比 Node.js 少。仅仅这一点就意味着开发人员仍然需要为 Go 应用程序进行大量的手动设置，包括彻底的研究。

Node.js 有一个很大的社区，为开发者提供了很多库和包。这个大型社区还在 Stackoverflow 这样的平台上提供了更多的支持，有助于在构建产品时提高生产率。

在比较开发工具和社区时，Node.js 轻松胜出。

## 结论

比较了这两种工具后，Go 和 Node.js 都有各自的优缺点，但是，尽管 Go 的性能很好，但 Go 似乎比它的对手更可靠。

在全球范围内，Go 开发人员的工资往往比 Node.js 高，错误处理似乎也处理得很好，这并不是说`try catch`不好，但是对错误负全责对程序员来说应该很重要。

我们不应该忘记 Go 的竞争条件检测，这在创建多线程应用程序时是一件好事，因为一些进程可能会以意想不到的顺序完成。

此外，Go 是一种编译语言，可以提高应用程序的速度。

正如你所看到的，围棋赢得了一些战斗，但仍然很难给它颁奖，因为很难说哪个更好。这取决于您想要构建的应用程序。

必须处理一千个请求的应用程序将同时使用 Go to scale。

此外，虽然 Go 对于必须处理高负载的微服务和企业项目来说也是非常棒和完美的，但 Node.js 仍然有许多针对每个挑战的开发工具，从而减少了开发时间。

但是，您可能需要考虑项目的类型(我一直在重复这一点)、规模和结构，以实现您的最终目标。

## 200 只![](img/61167b9d027ca73ed5aaf59a9ec31267.png)显示器出现故障，生产中网络请求缓慢

部署基于节点的 web 应用程序或网站是容易的部分。确保您的节点实例继续为您的应用程序提供资源是事情变得更加困难的地方。如果您对确保对后端或第三方服务的请求成功感兴趣，

[try LogRocket](https://lp.logrocket.com/blg/node-signup)

.

[![LogRocket Network Request Monitoring](img/cae72fd2a54c5f02a6398c4867894844.png)](https://lp.logrocket.com/blg/node-signup)[https://logrocket.com/signup/](https://lp.logrocket.com/blg/node-signup)

LogRocket 就像是网络和移动应用程序的 DVR，记录下用户与你的应用程序交互时发生的一切。您可以汇总并报告有问题的网络请求，以快速了解根本原因，而不是猜测问题发生的原因。

LogRocket 检测您的应用程序以记录基线性能计时，如页面加载时间、到达第一个字节的时间、慢速网络请求，还记录 Redux、NgRx 和 Vuex 操作/状态。

[Start monitoring for free](https://lp.logrocket.com/blg/node-signup)

.
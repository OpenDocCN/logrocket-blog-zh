<html>
<head>
<title>An overview of technical differences between loops in JavaScript - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>JavaScript - LogRocket博客中循环之间的技术差异概述</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/technical-differences-between-loops-javascript/#0001-01-01">https://blog.logrocket.com/technical-differences-between-loops-javascript/#0001-01-01</a></blockquote><div><article class="article-post">
<p>在JavaScript中使用循环时，需要正确定义两个关键点:<code>enumerable properties</code>和<code>iterable objects</code>。</p>
<h2>可枚举属性</h2>
<p>可枚举对象的一个定义特征是，当我们通过赋值操作符将属性赋给对象时，我们将内部可枚举标志设置为true。这是默认值。</p>
<p>但是，我们可以通过将它设置为false来改变这种行为。</p>
<p>一个经验法则是一个可枚举的属性总是出现在一个<code>for … in</code>循环中。</p>
<p>让我们来看看实际情况:</p>
<pre>// shows up in a for .... in loop
const gbols = {};
gbols.platform = "LogRocket";

Object.getOwnPropertyDescriptor(gbols, "platform")
{value: "LogRocket", writable: true, enumerable: true, configurable: true}

// doesn't show up in a for .... in loop 
//to have more control of this properties  we use
Object.defineProperty(gbols, 'role', {value: 'Admin', writable: true, enumerable: false})

// Testing this out yeilds
for (const item in gbols) {
console.log(item)
}
 // logs platform</pre>
<h2>可迭代对象</h2>
<p>如果一个对象定义了它的迭代行为，那么它就是可迭代的。在这种情况下，将在<code>for …of</code>构造中循环的值将定义它的迭代行为。可迭代的内置类型包括<code>Arrays</code>、<code>Strings</code>、<code>Sets</code>和<code>Maps</code>，而<code>object</code>是不可迭代的，因为它没有指定<code>@iterator method</code>。</p>
<p>基本上，在Javascript中，所有的可迭代对象都是可枚举对象，但并不是所有的可枚举对象都是可迭代对象。</p>
<p>这里有一个概念化的方法:<code>for …in</code>在数据中寻找对象，而<code>for ..of</code>寻找重复的序列。</p>
<p>让我们看看当使用<code>Array</code>数据类型时是什么样子:</p>
<pre> const authors = ['Jade', 'Dafe', 'Gbols', 'Daniel'];
// using with a for in loop
for (const author in authors) {
console.log(author)
}
// logs 0,1,2,3

for (const author of authors) {
console.log(author)
}
// logs Jade, Dafe, Gbols, Daniel</pre>
<p>当使用这个结构时，你需要记住的是，如果调用了<code>typeof</code>并且答案产生了<code>object</code>，那么你可以使用一个<code>for …in</code>循环。</p>
<p>让我们来看看对作者的变量的操作:</p>
<pre>typeof authors
// logs "object" hence we can use a for ..in</pre>
<p>乍一看，这似乎令人惊讶，但是需要注意的是，数组是一种特殊的对象，索引是它的键。知道<code>for ...in</code>将在一个构造中寻找一个对象可以极大地帮助我们。当一个<code>for ...in</code>循环找到一个对象时，它将遍历每个键。</p>
<p>我们可以将<code>for ..in</code>在作者数组上循环的方式形象化如下:</p>
<pre> const authors = {
0: 'Jade',
1: 'Dafe',
2: 'Gbols',
3: 'Daniel'
}</pre>
<p>一个重要的注意事项:如果它可以被追踪到一个对象(或者从对象原型链中继承)，那么<code>for …in</code>将以不特定的顺序迭代这个键。</p>
<p>同时，如果它实现了一个迭代器<code>for.. of</code>结构，它将在每次迭代中遍历值。</p>
<h2><code>ForEach</code>和<code>map</code>方法</h2>
<p>虽然<code>forEach</code>和<code>map</code>方法可以用来实现相同的事情，但是它们的行为和性能有所不同。</p>
<p>在基本级别，当调用函数时，它们都接收回调作为参数。</p>
<p>考虑下面的片段:</p>
<pre>const scoresEach = [2,4 ,8, 16, 32];
const scoresMap = [2,4 ,8, 16, 32];
const square = (num) =&gt; num * num;</pre>
<p>让我们列举一下它们在操作上的一些不同之处。</p>
<p><code>forEach</code>返回<code>undefined</code>，而<code>map</code>返回一个新的<code>array</code>:</p>
<pre>let newScores = []
const resultWithEach = scoresEach.forEach((score) =&gt; {
const newScore = square(score);
newScores.push(newScore);
});
const resultWithMap = scoresMap.map(square);

console.log(resultWithEach) // logs undefined
console.log(resultWithMap) // logs [4, 16, 64, 256, 1024]</pre>
<p><code>Map</code>是一个纯函数，而<code>forEach</code>执行一些变异:</p>
<pre>console.log(newScores) // logs [4, 16, 64, 256, 1024]</pre>
<p>在我看来，<code>map</code>更倾向于函数式编程范式。我们不需要总是执行一个突变来得到想要的结果，不像<code>forEach</code>，我们必须突变<code>newScores</code>变量。每次运行时，当提供相同的输入时，<code>map</code>功能将产生相同的结果。与此同时，<code>forEach</code>副本将从上一次突变的先前值中提取。</p>
<h3>链接</h3>
<p>用<code>map</code>链接是可能的，因为返回的结果是一个<code>array</code>。因此，可以立即对结果调用任何其他数组方法。换句话说，我们可以称之为<code>filter</code>、<code>reduce</code>、<code>some</code>等。这在<code>forEach</code>中是不可能的，因为返回值是未定义的。</p>
<h3>表演</h3>
<p><code>map</code>方法往往比<code>forEach</code>方法表现更好。可以用<a href="https://jsperf.com/" target="_blank" rel="noopener noreferrer"> JsPerf </a></p>
<p>检查用<code>map</code>和<code>forEach</code>实现的等效代码块的性能。平均来说，你会发现<code>map</code>函数的执行速度至少快了50%。</p>
<p>注意:这个基准依赖于你使用的机器，以及你的浏览器实现。</p>
<h2>结论</h2>
<p>在上面讨论的所有循环结构中，给我们最多控制权的是<code>for..of</code>循环。我们可以用关键字<code>return</code>、<code>continue</code>和<code>break</code>来使用它。这意味着我们可以指定我们希望在<code>array</code>中的每个元素上发生什么，以及我们是否希望提前离开或跳过。</p>
<p>记住这些信息，确保根据您希望在代码中实现的目标使用适当的工具。</p><div class="code-block code-block-27">
<div class="blog-plug inline-plug vanilla-javascript-cta"><h2>通过理解上下文，更容易地调试JavaScript错误</h2>
<p>调试代码总是一项单调乏味的任务。但是你越了解自己的错误，就越容易改正。</p>
<p>LogRocket 让你以新的独特的方式理解这些错误。我们的前端监控解决方案跟踪用户与您的JavaScript前端的互动，让您能够准确找出导致错误的用户行为。</p>
<a href="https://lp.logrocket.com/blg/javascript-signup" class="signup" target="_blank" rel="noopener noreferrer"><img class="alignnone size-full wp-image-46 jetpack-lazy-image" src="../Images/cbfed9be3defcb505e662574769a7636.png" alt="LogRocket Dashboard Free Trial Banner" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2020/06/reproduce-javascript-errors.gif?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/06/reproduce-javascript-errors.gif"/><noscript><img data-lazy-fallback="1" class="alignnone size-full wp-image-46" src="../Images/cbfed9be3defcb505e662574769a7636.png" alt="LogRocket Dashboard Free Trial Banner" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/06/reproduce-javascript-errors.gif"/></noscript></a>
<p>LogRocket记录控制台日志、页面加载时间、堆栈跟踪、慢速网络请求/响应(带有标题+正文)、浏览器元数据和自定义日志。理解您的JavaScript代码的影响从来没有这么简单过！</p>
<a class="signup" href="https://lp.logrocket.com/blg/javascript-signup" target="_blank" rel="noopener noreferrer">Try it for free</a><p>.</p></div>


</div>

<p class="clearfix"/>
 <p class="clearfix"/>
</article>

</div>    
</body>
</html>
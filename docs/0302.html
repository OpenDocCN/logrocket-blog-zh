<html>
<head>
<title>What to expect in React v17 - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>React v17 - LogRocket博客有什么值得期待的</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/what-to-expect-in-react-v17/#0001-01-01">https://blog.logrocket.com/what-to-expect-in-react-v17/#0001-01-01</a></blockquote><div><article class="article-post">
<p>React Fiber (React v16)非常棒，已经采取了一些重要的措施来改善开发人员的体验以及用React构建的应用程序的质量。在本帖中，我们将看看React 17是如何基于React v16构建的。</p>
<h3>为什么要异步渲染？</h3>
<p>React 17专注于异步渲染，旨在通过最大限度地降低计算和网络速度对用户体验的影响，为开发人员创建一个轻松构建高效应用的环境。</p>
<p>为了实现这一点，React应用程序的编写方式将不可避免地发生一些变化，引入一些新功能，摒弃一些以前的功能。</p>
<p>以下是我们可以期待的变化:</p>
<ul>
<li>引入新的生命周期方法</li>
<li>时间分片</li>
<li>焦虑</li>
</ul>
<p>我们一个一个来看。</p>
<h3>新的生命周期方法</h3>
<p class="graf graf--p">取代不推荐的生命周期方法的是两种新的生命周期方法，<code>getDerivedStateFromProps</code>和<code>getSnapShotBeforeUpdate</code>。</p>
<p class="graf graf--p">如果您准备将您的应用程序迁移到React 17，请记住这些要点。一个很好的起点是用这些新的生命周期方法替换不安全的方法。例如，<code>componentWillUpdate</code>可以通过结合使用<code>getDerivedStateFromProps</code>和<code>shouldComponentUpdate</code>来替换，<code>componentWillMount</code>应该被一起移除以进行异步渲染。</p>
<p class="graf graf--p">下面是React v16.4去掉不安全方法后组件生命周期的示意图。</p>
<p><img data-attachment-id="3476" data-permalink="https://blog.logrocket.com/what-to-expect-in-react-v17/reactv17-3/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2019/06/reactv17-2.png" data-orig-size="1284,770" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="reactv17" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2019/06/reactv17-2-300x180.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2019/06/reactv17-2-1024x614.png" decoding="async" class="alignnone wp-image-3476 size-full jetpack-lazy-image" src="../Images/e29449e922b31e39d7deef8b5337c4d4.png" alt="" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2019/06/reactv17-2.png 1284w, https://blog.logrocket.com/wp-content/uploads/2019/06/reactv17-2-300x180.png 300w, https://blog.logrocket.com/wp-content/uploads/2019/06/reactv17-2-768x461.png 768w, https://blog.logrocket.com/wp-content/uploads/2019/06/reactv17-2-1024x614.png 1024w" data-lazy-sizes="(max-width: 1284px) 100vw, 1284px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2019/06/reactv17-2.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/06/reactv17-2.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="3476" data-permalink="https://blog.logrocket.com/what-to-expect-in-react-v17/reactv17-3/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2019/06/reactv17-2.png" data-orig-size="1284,770" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="reactv17" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2019/06/reactv17-2-300x180.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2019/06/reactv17-2-1024x614.png" decoding="async" loading="lazy" class="alignnone wp-image-3476 size-full" src="../Images/e29449e922b31e39d7deef8b5337c4d4.png" alt="" srcset="https://blog.logrocket.com/wp-content/uploads/2019/06/reactv17-2.png 1284w, https://blog.logrocket.com/wp-content/uploads/2019/06/reactv17-2-300x180.png 300w, https://blog.logrocket.com/wp-content/uploads/2019/06/reactv17-2-768x461.png 768w, https://blog.logrocket.com/wp-content/uploads/2019/06/reactv17-2-1024x614.png 1024w" sizes="(max-width: 1284px) 100vw, 1284px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/06/reactv17-2.png"/></noscript>
<h3 class="graf graf--p"><strong class="markup--strong markup--p-strong"> getDerivedStateFromProps </strong></h3>
<p class="graf graf--p">这个生命周期方法取代了<code>componentWillReceiveProps</code>和<code>componentWillUpdate</code>，并且将在组件被创建之后以及当它接收到新的props时被调用。当道具改变时，它返回一个对象来更新状态；当状态没有改变时，返回<code>null</code>。</p>
<pre>state = { cachedSomeProp: null };

static getDerivedStateFromProps(nextProps, prevState) {
  // do things with nextProps.someProp and prevState.cachedSomeProp
  return {
    cachedSomeProp: nextProps.someProp,
    ..
  };
}</pre>
<p>但是，请记住，这种生命周期方法只适用于在props发生变化后组件需要更新其本地状态的情况。不必要的使用这个方法可能<a href="https://reactjs.org/blog/2018/06/07/you-probably-dont-need-derived-state.html" target="_blank" rel="noopener noreferrer">引入一些bug</a>，比如无条件复制道具到状态，当道具改变时擦除状态<code>componentWillReceiveProps</code>就是这种情况。</p>
<h3 id="3fd3" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">更新前获取快照</strong></h3>
<p id="3390" class="graf graf--p graf-after--p">这将处理组件更新，并将有效地取代<code>componentWillUpdate</code>并与<code>componentDidUpdate</code>一起工作。它在任何DOM更新之前被调用，并返回一个传递给<code>componentDidUpdate</code>的值，后者随后处理更改:</p>
<pre>class ScrollingList extends React.Component {
  listRef = null;

  getSnapshotBeforeUpdate(prevProps, prevState) {
    // Are we adding new items to the list?
    // Capture the scroll position so we can adjust scroll later.
    if (prevProps.list.length &lt; this.props.list.length) {
      return (
        this.listRef.scrollHeight - this.listRef.scrollTop
      );
    }
    return null;
  }

  componentDidUpdate(prevProps, prevState, snapshot) {
    // If we have a snapshot value, we've just added new items.
    // Adjust scroll so these new items don't push the old ones out of view.
    // (snapshot here is the value returned from getSnapshotBeforeUpdate)
    if (snapshot !== null) {
      this.listRef.scrollTop =
        this.listRef.scrollHeight - snapshot;
    }
  }

  render() {
    return (
      &lt;div ref={this.setListRef}&gt;
        {/* ...contents... */}
      &lt;/div&gt;
    );
  }

  setListRef = ref =&gt; {
    this.listRef = ref;
  };
}</pre>
<h3 id="0e42" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">时间分片</strong></h3>
<p id="906f" class="graf graf--p graf-after--p">时间切片是React的最大更新，旨在改善用户体验。它的目标是通过允许元素的优先渲染来使网站更加友好。所以高优先级更新不会因为呈现低优先级更新而被阻止。</p>
<p id="b737" class="graf graf--p graf-after--p">丹·阿布拉莫夫将此比作2018年冰岛JSConf的版本控制。其中工作被分成分支，并且每个分支的工作一旦完成就被合并到主服务器。类似地，使用时间片，元素可以单独呈现，允许应用程序呈现就绪的元素和尚未呈现的元素的占位符。</p>
<p id="10ad" class="graf graf--p graf-after--p">一个很好的例子是我们获取用户的详细信息。用户头像和名字将会显示，他们的简历稍后会出现。时间片将允许我们显示准备好的细节(姓名和头像)，并有一个占位符，而生物被提取。一旦bio准备好了，它就会呈现出来，最终状态和预期的一样。这增强了应用程序在较慢的设备和网络上的响应能力，也意味着当某个元素仍在渲染时，应用程序的其余部分仍可使用。</p>
<p id="96a1" class="graf graf--p graf-after--p">这是如何实现的？通过React 16.6中引入的名为<a href="https://reactjs.org/docs/code-splitting.html#suspense" target="_blank" rel="noopener noreferrer">悬念</a>的新API。</p>
<h3 id="b68f" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">悬念</strong></h3>
<p id="8bcd" class="graf graf--p graf-after--p">悬念负责在准备状态更新时呈现回退UI(占位符)。在这些更新准备好之前，它会保留最终UI的呈现，同时呈现您选择的占位符。如果您打算用它来指示装载状态，这就是您应该放置微调器的位置。</p>
<p id="177c" class="graf graf--p graf-after--p">这为处理数据加载提供了一个很好的替代条件呈现的方法。您还可以设置时间限制，如果数据在此时间内加载，回退UI将不会以并发模式呈现。太棒了，对吧？更好的是，悬念是在React 16.6中引入的，所以悬念现在就可以使用。</p>
<p id="ea7c" class="graf graf--p graf-after--p">这里有一个使用悬念的简单例子:</p>
<pre>const DataComponent = React.lazy(() =&gt; import('./DataComponent'));

function MySuspenseComponent(){
  return (
    &lt;Suspense fallback={&lt;Spinner /&gt;}&gt;
      &lt;DataComponnent/&gt;
    &lt;Suspense&gt;
    )
}</pre>
<p id="0ea7" class="graf graf--p graf-after--p">在上面的例子中，悬念与<a href="https://reactjs.org/blog/2018/10/23/react-v-16-6.html" target="_blank" rel="noopener noreferrer"> lazy() </a>一起使用，lazy加载DataComponent，当组件正在加载时，将显示一个微调器，我们的组件仅在加载完成后显示。我们还可以使用其他异步操作(如API调用)来实现这一点。</p>
<p id="96cb" class="graf graf--p graf-after--p">React 17还有望推出稳定版的<a href="https://github.com/facebook/react/tree/master/packages/react-cache" target="_blank" rel="noopener noreferrer"> react-cache </a>库，这将有助于扩展悬念的功能，并允许在同步操作中使用异步操作。react-cache可能是这样的:</p>
<pre>const getInfo = () =&gt; fetch("https://myApi.apiexample").then(res =&gt; res.json())

const ApiResource = createResource(getInfo)

const SayHello = () =&gt; {
  const data = ApiResource.read()

  return &lt;div&gt;Hi {data.name}&lt;/div&gt;
}

const App = () =&gt; (
  &lt;Suspense fallback={&lt;Spinner /&gt;}&gt;
    &lt;SayHello /&gt;
  &lt;/Suspense&gt;
)</pre>
<p id="a74f" class="graf graf--p graf-after--figure">react-cache也可以与时间片一起使用，以低优先级更新的方式在后台加载数据，一个很好的例子是当数据显示为选项卡时，这使得数据在选项卡之间切换时立即可用。Andrew Clark在React Conf 2018上做了一个很棒的演示，例如一个使用案例，请查看以下内容:</p>
<p><iframe loading="lazy" src="https://www.youtube.com/embed/ByBPyMBTzM0" frameborder="0" allowfullscreen="allowfullscreen">视频</iframe></p>
<figure id="6a46" class="graf graf--figure graf--iframe graf-after--p"><figcaption class="imageCaption">Concurrent Rendering in React </figcaption></figure>
<h3 id="01f2" class="graf graf--p graf-after--figure"><strong class="markup--strong markup--p-strong">结论</strong></h3>
<p id="9938" class="graf graf--p graf-after--p">React 17是一个主要版本，React开发人员有几个理由感到兴奋。它不仅提供了一些令人惊叹的新功能，这些功能将重新定义React应用程序的构建方式，而且它还扩展了最近引入的功能，如钩子，并进行增量更改，使开发人员可以更好地利用它们。这将带来更好的应用程序和更好的构建体验。看到React的未来还会发生什么令人兴奋。</p>
<p id="1041" class="graf graf--p graf-after--p">你可能还想看看Dan Abramov在JS Conf 2018上的演讲，我在编写这篇文章时提到过。</p>
<p><iframe loading="lazy" src="https://www.youtube.com/embed/nLF0n9SACd4" frameborder="0" allowfullscreen="allowfullscreen">视频</iframe></p>
<p> </p><div class="code-block code-block-17">
<div class="blog-plug inline-plug react-plug" vwo-el-id="26283398190">
<h2 vwo-el-id="41600691720"><a href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener"> LogRocket </a>:全面了解您的生产React应用</h2><p>调试React应用程序可能很困难，尤其是当用户遇到难以重现的问题时。如果您对监视和跟踪Redux状态、自动显示JavaScript错误以及跟踪缓慢的网络请求和组件加载时间感兴趣，</p><a href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" vwo-el-id="19356441070">try LogRocket</a><p>. </p><a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="19356441380">
<img class="first-react-image alignnone size-full wp-image-46 jetpack-lazy-image jetpack-lazy-image--handled" src="../Images/f300c244a1a1cf916df8b4cb02bec6c6.png" vwo-el-id="18272717540" data-lazy-loaded="1" data-original-src="https://files.readme.io/27c94e7-Image_2017-06-05_at_9.46.04_PM.png"/>
</a>
<a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="19356441690">
<img class="second-react-image alignnone size-full wp-image-46 jetpack-lazy-image jetpack-lazy-image--handled" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" vwo-el-id="30720362350" data-lazy-loaded="1" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/>
</a>
<p vwo-el-id="28675660440" class="">LogRocket 结合了会话回放、产品分析和错误跟踪，使软件团队能够创建理想的web和移动产品体验。这对你来说意味着什么？</p>
<p>LogRocket不是猜测错误发生的原因，也不是要求用户提供截图和日志转储，而是让您回放问题，就像它们发生在您自己的浏览器中一样，以快速了解哪里出错了。</p>
<p>不再有嘈杂的警报。智能错误跟踪允许您对问题进行分类，然后从中学习。获得有影响的用户问题的通知，而不是误报。警报越少，有用的信号越多。</p>
<p vwo-el-id="28675660750">LogRocket Redux中间件包为您的用户会话增加了一层额外的可见性。LogRocket记录Redux存储中的所有操作和状态。</p>
<p vwo-el-id="28675661060">现代化您调试React应用的方式— <a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="40093418840">开始免费监控</a>。</p>
</div></div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
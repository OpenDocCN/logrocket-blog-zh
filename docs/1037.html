<html>
<head>
<title>9 Rust authentication libraries that are ready for production - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>9个Rust认证库已经准备好投入生产</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/9-rust-authentication-libraries-that-are-ready-for-production/#0001-01-01">https://blog.logrocket.com/9-rust-authentication-libraries-that-are-ready-for-production/#0001-01-01</a></blockquote><div><article class="article-post">
<p>Rust是一种低级语言，具有高级人机工程学。它快速可靠，支持异步I/O到达稳定的Rust。因此，Rust正迅速成为注重性能的网络和web应用的首选。</p>
<p/>
<p>几乎所有的网络应用都需要某种形式的认证，尤其是在一个数据隐私意识日益增强的时代。Rust拥有越来越多的高质量、可生产的板条箱，可用于认证和授权。</p>
<p>在本指南中，我们将根据以下标准评估九个稳定的生产就绪型身份认证库:</p>
<ul>
<li>流行</li>
<li>完全</li>
<li>维护</li>
<li>支持稳定生锈</li>
</ul>
<p>我们还将预览一些尚未生产就绪但应该在您的雷达上的板条箱。</p>
<p>让我们开始吧！</p>
<h2 id="cookie">1.<code>cookie</code></h2>
<ul>
<li>生产就绪:是</li>
<li>异步支持:否</li>
</ul>
<p><a href="https://docs.rs/cookie/0.14.1/cookie/" target="_blank" rel="noopener noreferrer"> <code>cookie</code> </a>是一个用于创建和解析HTTP cookies的机箱。它用于管理会话、加密和签署cookies。</p>
<p><code>cookie</code>是一款生产就绪的板条箱，可下载数千次。它是构建基于会话的身份验证策略的基础。板条箱支持在cookies中保存和记录更改。它与web框架无关，支持actix、rocket和所有其他框架。</p>
<h2 id="jsonwebtoken">2.<code>jsonwebtoken</code></h2>
<ul>
<li>生产就绪:是</li>
<li>异步支持:否</li>
</ul>
<p>JSON Web令牌在授权方面非常流行；许多OAuth提供商发行JWT。<a href="https://docs.rs/jsonwebtoken/7.2.0/jsonwebtoken/" target="_blank" rel="noopener noreferrer"> <code>jsonwebtoken</code> </a>提供验证和创建JWT令牌的支持。</p>
<p>板条箱支持所有标准签名算法以及对称和非对称加密算法。它带有标准声明的内置验证，以及强类型和高度可配置的API。它还完全实现了RFC 7519 。</p>
<p>jsonwebtoken是一个高度稳定且被广泛使用的库，有数千次下载。最重要的是，它有一个活跃的维护团队，有巨大的社区支持。</p>
<h2 id="oauth2">3.<code>oauth2</code></h2>
<ul>
<li>生产就绪:是</li>
<li>异步支持:是</li>
</ul>
<p><a href="https://docs.rs/oauth2/4.0.0-alpha.1/oauth2/index.html" target="_blank" rel="noopener noreferrer"> <code>oauth2</code> </a>提供了OAuth 2协议的完整实现。它支持异步和同步I/O、获取访问令牌、验证状态以及获取刷新令牌。</p>
<p>特性包括完全实现RFC 6749 和强类型。机箱支持状态和<code>crf_state</code>验证以及PKCE挑战。此外，一个默认支持<code>reqwest</code>和<code>curl</code>的定制HTTP客户端被嵌入到机箱中。</p>
<p>最后，<code>oauth2</code>是框架无关的，支持直接使用密码和用户名。</p>
<p>其他oAuth提供者的例子包括:</p>

<p><code>oauth2</code>易于使用，提供完整的OAuth 2客户端解决方案，包括更新令牌、管理声明、范围和授权。</p>
<h2 id="otpauth">4.<code>otpauth</code></h2>
<ul>
<li>生产就绪:是</li>
<li>异步支持:否</li>
</ul>
<p><a href="https://messense.github.io/otpauth-rs/otpauth/index.html" target="_blank" rel="noopener noreferrer"> <code>otpauth</code> </a>同时支持<a href="https://tools.ietf.org/html/rfc4226" target="_blank" rel="noopener noreferrer"> HOTP </a>和<a href="https://tools.ietf.org/html/rfc6238.html" target="_blank" rel="noopener noreferrer"> TOTP </a>算法。它用于生成一次性密码(OTP)。它可以生成基于时间的OTP，并支持更改验证时间。</p>
<p>的API易于使用且直观，并且具有HOTP和TOTP的完整实现。</p>
<h2 id="yupoauth2">5.<code>yup-oauth2</code></h2>
<ul>
<li>生产就绪:是</li>
<li>异步支持:是</li>
</ul>
<p><code>yup-oauth2</code>提供了服务器到服务器的OAuth 2.0的实现。它用于实现不同服务的客户端库，比如<code>google-api-rs</code>。</p>
<p>板条箱支持服务帐户和已安装的应用程序，并与任何实现OAuth 2.0的服务一起工作，以进行服务器到服务器的身份验证。<code>yup-ouath</code>通常用于使用<a href="https://tools.ietf.org/html/rfc8628" target="_blank" rel="noopener noreferrer">设备流</a>在输入能力有限的设备上进行验证。它被用于谷歌云平台、Firebase等服务，以及其他使用<a href="https://developers.google.com/identity/protocols/oauth2/service-account" target="_blank" rel="noopener noreferrer">服务流</a>的谷歌服务。它还支持无法使用<a href="https://developers.google.com/youtube/v3/live/guides/auth/installed-apps" target="_blank" rel="noopener noreferrer">安装的应用流程</a>安全保存认证令牌的应用。</p>
<h2 id="asap">6.尽快</h2>
<ul>
<li>生产就绪:是</li>
<li>异步支持:否</li>
</ul>
<p><a href="https://crates.io/crates/asap" target="_blank" rel="noopener noreferrer"> ASAP </a>是由Atlassian创建并维护的认证机制。它支持非标准声明，并以闪电般的速度执行验证和令牌生成。</p>
<p>ASAP基于<code>jsonwebtoken</code>板条箱。它完全支持ASAP规范。</p>
<h2 id="jwksclient">7.JWKS-客户端</h2>
<ul>
<li>生产就绪:是</li>
<li>异步支持:是</li>
</ul>
<p>JWKS-Client 支持使用JWKS (JSON web keyset)验证JSON web令牌。crate的主要功能是使用JWKS对JWT令牌进行对称签名验证。</p>
<p>crate主要用于Google和Firebase OAuth，但也可以很容易地用于任何其他提供商。它获取密钥参数的URL并验证令牌。它还支持密钥缓存。</p>
<h2 id="openssl">8.<code>openssl</code></h2>
<ul>
<li>生产就绪:是</li>
<li>异步支持:否</li>
</ul>
<p>这个<a href="https://docs.rs/openssl/0.10.30/openssl/" target="_blank" rel="noopener noreferrer"> <code>openssl</code> </a>箱子是为OpenSSL库进行Rust绑定的。它提供了对签名令牌、哈希密码、生成随机身份验证令牌和加密数据的全面支持。</p>
<p>许多身份验证库使用OpenSSL对数据进行签名和哈希处理。<code>jsonwebtoken</code>使用OpenSSL对令牌进行签名。</p>
<p>板条箱支持静态和动态链接。它还支持OpenSSL的可用版本或下载所需的版本。</p>
<h2 id="pgen">9.<code>pgen</code></h2>
<ul>
<li>生产就绪:是</li>
<li>异步支持:否</li>
</ul>
<p><a href="https://github.com/ctsrc/Pgen" target="_blank" rel="noopener noreferrer"> <code>pgen</code> </a>使用EFF的<a href="https://www.eff.org/deeplinks/2016/07/new-wordlists-random-passphrases" target="_blank" rel="noopener noreferrer">单词表为随机密码</a>生成密码。</p>
<h2 id="upcominglibraries">3个信任认证库，让您时刻保持警惕</h2>
<p>下面的库还不稳定，但是有很好的特性，应该引起你的注意。随着Rust的成长，它将支持越来越多的标准。</p>
<h3 id="boringauth">1.<code>boringauth</code></h3>
<ul>
<li>生产就绪:否</li>
<li>异步支持:否</li>
</ul>
<p><a href="https://docs.rs/boringauth/0.9.0/boringauth/" target="_blank" rel="noopener noreferrer"> <code>boringauth</code> </a>是任何app认证相关需求的一站式解决方案。它支持密码身份验证以及基于HTOP和TOP的身份验证。它还具有可定制的周期、哈希算法、输出长度和初始时间戳。</p>
<p><code>boringauth</code>可用于CLI和桌面应用。它还不完全支持HTOP和TOPT。对通用双因素认证的支持也即将推出。</p>
<h3 id="oxideauth">2.<code>oxide-auth</code></h3>
<ul>
<li>生产就绪:否</li>
<li>异步支持:否</li>
</ul>
<p><a href="https://docs.rs/oxide-auth/0.4.5/oxide_auth/" target="_blank" rel="noopener noreferrer"> <code>oxide-auth</code> </a>机箱为服务器提供OAuth的实现。它支持许多web框架，包括Actix、Iron、Rocket和Rouille。</p>
<p>简单地说，<code>oxide-auth</code>使得在服务器上管理OAuth令牌变得容易。它还支持处理自定义服务器的令牌。</p><div class="code-block code-block-54">
<hr/>
<h3>更多来自LogRocket的精彩文章:</h3>

<hr/></div>
<p>虽然它的API还不稳定，但<code>oxide-auth</code>是一个可靠的库。web框架的支持框架仍在开发中。</p>
<h3 id="frankjwt">3.弗兰克·JWT</h3>
<ul>
<li>生产就绪:否</li>
<li>异步支持:否</li>
</ul>
<p>弗兰克JWT用于验证和产生JWT。它可以从path中自动读取密钥。</p>
<p>这个板条箱还不能用于生产，因为它不支持对<code>iss</code>、<code>sub</code>和许多其他声明的验证。</p>
<h2>摘要</h2>
<p>总之，下面是一个综合表格，可以帮助您比较本指南中讨论的Rust身份验证库的特性、功能和优缺点。</p>
<table>
<tbody>
<tr>
<td>名字</td>
<td>生产就绪？</td>
<td>类型</td>
<td>异步支持？</td>
<td>主要用途</td>
<td>缺点</td>
<td>利益</td>
<td>维护？</td>
</tr>
<tr>
<td><code>cookie</code></td>
<td>是</td>
<td>助手</td>
<td>不</td>
<td>   <ul>
<li>创建基于自定义会话和cookies的身份验证</li>
<li>将JWT保存在加密的cookies中</li>
<li>跟踪用户</li>
</ul>
</td>
<td>广泛的用户基础</td>
<td>支持解析器和创建cookies<ul>
<li>是</li>
<li><code>oauth2</code></li>
</ul>
</td>
<td>
<p>是</p>
</td>
</tr>
<tr>
<td>OAuth支持</td>
<td>是</td>
<td>获取OAuth令牌</td>
<td>支持多个HTTPS请求客户端(请求、curl、自定义)</td>
<td>支持任何支持OAuth 2的OAuth提供程序<ul>
<li>   </li>
<li>不支持验证获得的令牌</li>
<li>   </li>
</ul>
</td>
<td>全面实施OAuth 2<ul>
<li>是</li>
</ul>
</td>
<td><code>oauth-client</code><ul>
<li>不</li>
</ul>
</td>
<td>
<p>OAuth支持</p>
</td>
</tr>
<tr>
<td>不</td>
<td>不支持验证获得的令牌</td>
<td>未积极维护</td>
<td>No</td>
<td>不</td>
<td><code>oauth-client-async</code><ul>
<li>不</li>
<li>OAuth支持</li>
</ul>
</td>
<td>是</td>
<td>
<p><code>oauth-client</code>的异步版本</p>
</td>
</tr>
<tr>
<td>未积极维护</td>
<td>相对较少的用户</td>
<td>不支持验证获得的令牌</td>
<td>不</td>
<td><code>oxide-auth</code><ul>
<li>不</li>
</ul>
</td>
<td>OAuth服务器<ul>
<li>是</li>
<li>基于OAuth构建服务器</li>
<li>支持各种框架(<code>oxide-auth-actix</code>、<code>oxide-auth-iron</code>、<code>oxide-auth-rocket</code>、<code>oxide-auth-rouille</code>)</li>
</ul>
</td>
<td>是</td>
<td>
<p><code>inth-oauth2</code></p>
</td>
</tr>
<tr>
<td>不</td>
<td>OAuth服务器</td>
<td>是</td>
<td>OAuth客户端服务器</td>
<td>支持Google、GitHub和Imgur开箱即用<ul>
<li>对Slack和其他提供商提供社区支持的可插拔接口</li>
<li>不</li>
</ul>
</td>
<td><code>yup-oauth2</code></td>
<td>是</td>
<td>
<p>OAuth服务器</p>
</td>
</tr>
<tr>
<td>是</td>
<td>Google服务的OAuth</td>
<td>令牌缓存</td>
<td>没有现成的身份验证提供程序支持</td>
<td>   <ul>
<li>对已安装应用程序的支持</li>
<li>服务账户<be/></li>
<li>由<code>google-api-rs</code>使用</li>
</ul>
</td>
<td>是</td>
<td>弗兰克·JWT</td>
<td>
<p>不</p>
</td>
</tr>
<tr>
<td>JWT助手</td>
<td>不</td>
<td>JWT创建和验证</td>
<td>对称和非对称模拟</td>
<td>   <ul>
<li>不支持从JWKS获取密钥</li>
<li>   </li>
</ul>
</td>
<td>支持多种算法<ul>
<li>是</li>
</ul>
</td>
<td><code>jsonwebtoken</code><ul>
<li>是</li>
<li>JWT帮手</li>
<li>不</li>
</ul>
</td>
<td>
<p>JWT创建和验证</p>
</td>
</tr>
<tr>
<td>对称和非对称模拟</td>
<td>   </td>
<td>不支持从JWKS获取密钥</td>
<td>巨大的社区支持</td>
<td>广泛使用<ul>
<li>是</li>
<li><code>otpauth</code></li>
</ul>
</td>
<td>是<ul>
<li>OTP授权</li>
</ul>
</td>
<td>不<ul>
<li>OTP创建和验证</li>
</ul>
</td>
<td>
<p>不支持秘密生成</p>
</td>
</tr>
<tr>
<td>支持TOPT和HTOP</td>
<td>是</td>
<td><code>boringauth</code></td>
<td>不</td>
<td>OTP授权<ul>
<li>不</li>
<li>OTP创建和验证</li>
</ul>
</td>
<td>高度可配置<ul>
<li>支持密码</li>
</ul>
</td>
<td>支持TOPT和HTOP<ul>
<li>是</li>
<li>尽快(As Soon As Possible)</li>
</ul>
</td>
<td>
<p>是</p>
</td>
</tr>
<tr>
<td>尽快授权</td>
<td>是</td>
<td>ASAP代币(JWT，带自定义申领)</td>
<td>超快的</td>
<td>由Atlassian支持<ul>
<li>是</li>
</ul>
</td>
<td>JWKS-客户端<ul>
<li>是</li>
</ul>
</td>
<td>JWT认证中间件<ul>
<li>是</li>
</ul>
</td>
<td>
<p>使用JWKS的JWT验证</p>
</td>
</tr>
<tr>
<td>是</td>
<td><code>openssl</code></td>
<td>是</td>
<td>密码系统</td>
<td>不<ul>
<li>哈希密码</li>
</ul>
</td>
<td>生成盐<ul>
<li>OpenSSL库的绑定</li>
<li>是</li>
</ul>
</td>
<td><code>pgen</code><ul>
<li>是</li>
</ul>
</td>
<td>
<p>释义生成器</p>
</td>
</tr>
<tr>
<td>不</td>
<td>Yes</td>
<td>ASAP auth</td>
<td>Yes</td>
<td>是<ul>
<li> </li>
</ul>
</td>
<td><a href="https://lp.logrocket.com/blg/rust-signup" target="_blank">log rocket</a>:Rust应用的web前端的全面可见性</td>
<td>调试Rust应用程序可能很困难，尤其是当用户遇到难以重现的问题时。如果您对监控和跟踪Rust应用程序的性能、自动显示错误、跟踪缓慢的网络请求和加载时间感兴趣，<ul>
<li>. </li>
<li>LogRocket 就像是网络和移动应用程序的DVR，记录你的Rust应用程序上发生的一切。您可以汇总并报告问题发生时应用程序的状态，而不是猜测问题发生的原因。LogRocket还可以监控应用的性能，报告客户端CPU负载、客户端内存使用等指标。</li>
</ul>
</td>
<td>
<p>现代化调试Rust应用的方式— <a class="signup" href="https://lp.logrocket.com/blg/rust-signup" target="_blank" rel="noopener noreferrer">开始免费监控</a>。</p>
</td>
</tr>
<tr>
<td>JWKS-Client</td>
<td>Yes</td>
<td>JWT auth middleware</td>
<td>Yes</td>
<td>
 
</td>
<td>

</td>
<td>

</td>
<td>
<p>Yes</p>
</td>
</tr>
<tr>
<td><code>openssl</code></td>
<td>Yes</td>
<td>Cryptography</td>
<td>No</td>
<td>
 
</td>
<td/>
<td>
 
</td>
<td>Yes</td>
</tr>
<tr>
<td><code>pgen</code></td>
<td>Yes</td>
<td>Paraphrases generator</td>
<td>No</td>
<td>

</td>
<td>

</td>
<td/>
<td>
<p>Yes</p>
</td>
</tr>
</tbody>
</table>
<p> </p><div class="code-block code-block-29">
<div class="blog-plug inline-plug rust-plug"><h2><a href="https://lp.logrocket.com/blg/rust-signup" target="_blank">LogRocket</a>: Full visibility into web frontends for Rust apps</h2><p> Debugging Rust applications can be difficult, especially when users experience issues that are difficult to reproduce. If you’re interested in monitoring and tracking performance of your Rust apps, automatically surfacing errors, and tracking slow network requests and load time, </p><a href="https://lp.logrocket.com/blg/rust-signup" target="_blank">try LogRocket</a><p>. </p><a class="signup" href="https://lp.logrocket.com/blg/rust-signup" target="_blank" rel="noopener noreferrer"><img class="alignnone size-full wp-image-46 jetpack-lazy-image" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/><noscript><img data-lazy-fallback="1" class="alignnone size-full wp-image-46" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/></noscript></a><p><a href="https://lp.logrocket.com/blg/rust-signup" target="_blank" rel="noopener noreferrer">LogRocket</a> is like a DVR for web and mobile apps, recording literally everything that happens on your Rust app. Instead of guessing why problems happen, you can aggregate and report on what state your application was in when an issue occurred. LogRocket also monitors your app’s performance, reporting metrics like client CPU load, client memory usage, and more.</p><p>Modernize how you debug your Rust apps — <a class="signup" href="https://lp.logrocket.com/blg/rust-signup" target="_blank" rel="noopener noreferrer">start monitoring for free</a>.</p></div>


</div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
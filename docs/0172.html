<html>
<head>
<title>How CSS works: Parsing &amp; painting CSS in the critical rendering path - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>CSS如何工作:在关键渲染路径中解析和绘制CSS</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/how-css-works-parsing-painting-css-in-the-critical-rendering-path-b3ee290762d3/#0001-01-01">https://blog.logrocket.com/how-css-works-parsing-painting-css-in-the-critical-rendering-path-b3ee290762d3/#0001-01-01</a></blockquote><div><article class="article-post">
<p><a href="https://platform.twitter.com/widgets.js">https://platform.twitter.com/widgets.js</a></p>
<p>CSS经常让人感觉像是一种神秘的、异想天开的力量，控制着我们在网络上看到的一切。有时它本身可能很简单，但是编写可伸缩的、高性能的CSS似乎是例外而不是标准。</p>
<p>无论你认为CSS是“不可避免的邪恶”,还是认为它有能力但被误解，CSS对于任何从事web应用的人来说都是必备的。对CSS的深入了解可能是一个漂亮、精致的web应用程序和一个感觉有点“嗯”的应用程序之间的差别。</p>
<p>这篇文章将是我们深入研究CSS及其附属生态系统的系列文章的第一篇。我们的愿景是，通过打开CSS的盖子，我们可以更深入地理解和欣赏事实上的web样式语言，使我们能够编写更快、更干净、更漂亮的CSS，随着应用程序的规模和复杂性的增长而扩展。</p>
<hr/>
<p>在本系列的第一篇文章中，我们将讨论CSS如何在初始页面加载时呈现在屏幕上。</p>
<p>我们关心CSS变成漂亮像素的途径的原因可以归结为两个词。</p>
<p><strong> <em>加载时间。</em>T3】</strong></p>
<p>如果你的网站加载时间很长，那么你的用户可能不会等着它结束，即使那里有有价值的内容。一些研究表明，多达50%的移动用户在等待3秒钟后离开页面。</p>
<p>随着用户对这些类型的加载时间的期待，我们作为web开发人员有责任不增加我们发送给用户的内容数量。可悲的是，CSS经常是增加加载时间的罪魁祸首，所以对你发送的CSS如何转换成漂亮的像素有一个细致入微的理解将帮助你优化用户最有可能反弹的关键时刻。</p>
<figure><a href="https://logrocket.com/signup/" target="_blank" rel="noopener noreferrer"><img decoding="async" src="../Images/94b3e0f84b30cb0d321f60471481ab64.png" data-height="750" data-width="3212" data-lazy-src="https://storage.googleapis.com/blog-images-backup/1*GPjaPKNNUYHU8EsA3Z0JGA.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" class=" jetpack-lazy-image" data-original-src="https://storage.googleapis.com/blog-images-backup/1*GPjaPKNNUYHU8EsA3Z0JGA.png"/><noscript><img data-lazy-fallback="1" decoding="async" src="../Images/94b3e0f84b30cb0d321f60471481ab64.png" data-height="750" data-width="3212" data-original-src="https://storage.googleapis.com/blog-images-backup/1*GPjaPKNNUYHU8EsA3Z0JGA.png"/></noscript></a></figure>
<h3>不管怎样，关键的渲染路径是什么？</h3>
<p>当我们说用户想要更快的加载时间时，我们必须区分<em>关键</em>和<em>非关键</em>资源。也许你在偷懒加载你的一些图片，或者你设置了一点奇特的路径分割(谢谢你，webpack！)不要一次发送所有的JavaScript。这些在初始页面呈现之后加载的资源被认为是<em>非关键的</em>——也就是说，它们不会延迟页面的初始呈现。延迟页面第一次呈现的资源被认为是<em>关键</em>。</p>
<p>关键呈现路径是浏览器从接收到HTML的第一个字节到第一次在屏幕上呈现像素必须采取的最少步骤。本质上，它是浏览器必须做的事情，将我们的关键资源处理成我们的用户可以享受的东西。它看起来像这样。</p>
<ol>
<li>从接收到的HTML构建DOM(文档对象模型)</li>
<li>如果我们遇到一个CSS样式表(嵌入的或链接的)，开始构建CSSOM (CSS对象模型——我们一会儿会谈到这是什么)。</li>
<li>如果我们在构建DOM的时候遇到了JS块(没有指定为<code>async</code>)，等待CSSOM构建，停止DOM构建，解析/执行代码。这样做的原因是因为JS执行可以修改DOM并访问/修改CSSOM。</li>
</ol>
<p>出于本文的目的，我们将深入第二步CSS如何影响关键的渲染路径。我们很容易极其小心地对JavaScript进行树抖动、路径分割和延迟加载，但有时CSS可能会被遗忘。然而，一个未优化的CSS包很容易严重影响你的加载时间。</p>
<h3>HTML和关键呈现路径</h3>
<p>由于这主要是一篇关于CSS的文章，我们不会在DOM构造上花太多时间。然而，CSS基本上是一种用于样式标记的语言，所以我们需要知道它是如何与DOM交互的。</p>
<p>DOM是一个树状数据结构，包含页面上的所有HTML节点。每个节点都包含关于HTML元素的数据(例如属性、id和类)。如果节点有任何HTML元素作为子节点，它也会指向这些子节点。例如，给定下面的HTML，我们将构造下面的DOM。注意HTML的缩进和DOM的结构非常相似。</p>
<p><img data-attachment-id="2563" data-permalink="https://blog.logrocket.com/how-css-works-parsing-painting-css-in-the-critical-rendering-path-b3ee290762d3/0_4j8hsezvi4dqb-wp/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2018/04/0_4J8HSEzvi4DQb-WP.png" data-orig-size="1600,746" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="0_4J8HSEzvi4DQb-WP" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2018/04/0_4J8HSEzvi4DQb-WP-300x140.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2018/04/0_4J8HSEzvi4DQb-WP-1024x477.png" decoding="async" class="alignnone size-full wp-image-2563 jetpack-lazy-image" src="../Images/1060e90bdabb3ec9b9a62c6b5f0ae4d4.png" alt="" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2018/04/0_4J8HSEzvi4DQb-WP.png 1600w, https://blog.logrocket.com/wp-content/uploads/2018/04/0_4J8HSEzvi4DQb-WP-300x140.png 300w, https://blog.logrocket.com/wp-content/uploads/2018/04/0_4J8HSEzvi4DQb-WP-768x358.png 768w, https://blog.logrocket.com/wp-content/uploads/2018/04/0_4J8HSEzvi4DQb-WP-1024x477.png 1024w" data-lazy-sizes="(max-width: 1600px) 100vw, 1600px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2018/04/0_4J8HSEzvi4DQb-WP.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2018/04/0_4J8HSEzvi4DQb-WP.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="2563" data-permalink="https://blog.logrocket.com/how-css-works-parsing-painting-css-in-the-critical-rendering-path-b3ee290762d3/0_4j8hsezvi4dqb-wp/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2018/04/0_4J8HSEzvi4DQb-WP.png" data-orig-size="1600,746" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="0_4J8HSEzvi4DQb-WP" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2018/04/0_4J8HSEzvi4DQb-WP-300x140.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2018/04/0_4J8HSEzvi4DQb-WP-1024x477.png" decoding="async" loading="lazy" class="alignnone size-full wp-image-2563" src="../Images/1060e90bdabb3ec9b9a62c6b5f0ae4d4.png" alt="" srcset="https://blog.logrocket.com/wp-content/uploads/2018/04/0_4J8HSEzvi4DQb-WP.png 1600w, https://blog.logrocket.com/wp-content/uploads/2018/04/0_4J8HSEzvi4DQb-WP-300x140.png 300w, https://blog.logrocket.com/wp-content/uploads/2018/04/0_4J8HSEzvi4DQb-WP-768x358.png 768w, https://blog.logrocket.com/wp-content/uploads/2018/04/0_4J8HSEzvi4DQb-WP-1024x477.png 1024w" sizes="(max-width: 1600px) 100vw, 1600px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2018/04/0_4J8HSEzvi4DQb-WP.png"/></noscript>
<p>至于关键的呈现路径，我们认为HTML是我们的呈现阻塞的关键资源之一——如果我们还没有解析它，我们就不能呈现任何内容！</p>
<h3>构建CSS对象模型</h3>
<p>当浏览器遇到CSS样式表(嵌入式或外部)时，它需要将文本解析成可用于样式布局和绘制的内容。浏览器将CSS转换成的数据结构被创造性地命名为CSSOM，即CSS对象模型。</p>
<p>CSSOM看起来像什么？给定下面的CSS，浏览器将构建一个如下所示的CSSOM。</p>
<p><img data-attachment-id="2565" data-permalink="https://blog.logrocket.com/how-css-works-parsing-painting-css-in-the-critical-rendering-path-b3ee290762d3/0_6t8_7kprbpssxlct/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2018/04/0_6T8_7kprBpSSXlct.png" data-orig-size="1600,877" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="0_6T8_7kprBpSSXlct" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2018/04/0_6T8_7kprBpSSXlct-300x164.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2018/04/0_6T8_7kprBpSSXlct-1024x561.png" decoding="async" class="alignnone size-full wp-image-2565 jetpack-lazy-image" src="../Images/05f553a4c516737a018a129ddb177745.png" alt="" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2018/04/0_6T8_7kprBpSSXlct.png 1600w, https://blog.logrocket.com/wp-content/uploads/2018/04/0_6T8_7kprBpSSXlct-300x164.png 300w, https://blog.logrocket.com/wp-content/uploads/2018/04/0_6T8_7kprBpSSXlct-768x421.png 768w, https://blog.logrocket.com/wp-content/uploads/2018/04/0_6T8_7kprBpSSXlct-1024x561.png 1024w" data-lazy-sizes="(max-width: 1600px) 100vw, 1600px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2018/04/0_6T8_7kprBpSSXlct.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2018/04/0_6T8_7kprBpSSXlct.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="2565" data-permalink="https://blog.logrocket.com/how-css-works-parsing-painting-css-in-the-critical-rendering-path-b3ee290762d3/0_6t8_7kprbpssxlct/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2018/04/0_6T8_7kprBpSSXlct.png" data-orig-size="1600,877" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="0_6T8_7kprBpSSXlct" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2018/04/0_6T8_7kprBpSSXlct-300x164.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2018/04/0_6T8_7kprBpSSXlct-1024x561.png" decoding="async" loading="lazy" class="alignnone size-full wp-image-2565" src="../Images/05f553a4c516737a018a129ddb177745.png" alt="" srcset="https://blog.logrocket.com/wp-content/uploads/2018/04/0_6T8_7kprBpSSXlct.png 1600w, https://blog.logrocket.com/wp-content/uploads/2018/04/0_6T8_7kprBpSSXlct-300x164.png 300w, https://blog.logrocket.com/wp-content/uploads/2018/04/0_6T8_7kprBpSSXlct-768x421.png 768w, https://blog.logrocket.com/wp-content/uploads/2018/04/0_6T8_7kprBpSSXlct-1024x561.png 1024w" sizes="(max-width: 1600px) 100vw, 1600px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2018/04/0_6T8_7kprBpSSXlct.png"/></noscript>
<p>本质上，我们解析所有的CSS选择器，并给它们分配在树中的位置。如果只有一个选择器，它将被附加到树的根节点上。嵌套的选择器将被附加到它们所嵌套的节点上。CSS解析器必须从右到左读取嵌套的选择器，以保证它们最终位于正确的节点之下。</p>
<p>将CSS转换成CSSOM被认为是一个“渲染阻塞”阶段，就像从HTML中构建DOM一样。如果它不等待CSSOM就直接渲染成像素，我们会看到一闪而过的无样式内容(难看！)在CSSOM解析的时候。之后，当最终应用CSS时，一切都会改变。远远算不上伟大的UX。</p>
<h3>朗读者</h3>
<p>浏览器使用构造的CSSOM和DOM创建“渲染树”。简而言之，渲染树包含浏览器在页面上创建像素所需的所有信息。浏览器基本上把DOM和CSSOM放在一起，去掉任何对渲染输出没有影响的东西。</p>
<p>首先，浏览器删除所有不可见的元素。这包括像<code>&lt;head&gt;</code>、<code>&lt;script&gt;</code>和<code>&lt;meta&gt;</code>这样的元素，以及具有<code>hidden</code>属性的HTML元素。这些元素虽然被应用程序的其他部分使用，但不会呈现到页面上，因此浏览器可以安全地继续呈现，因为它知道呈现树中的所有元素实际上都是可见的HTML元素。</p>
<p>接下来，我们遍历CSSOM，找出当前渲染树中的哪些元素与CSS选择器匹配。任何匹配的选择器的CSS规则将被应用到渲染树的那个节点。</p>
<p>不过，有一个CSS规则是个例外。在CSS规则中应用<code>display: none;</code>将<em>从渲染树中完全移除一个元素</em>。这又回到了在渲染树中只包含可见元素。<em>其他隐藏元素的方法，如</em> <code><em>opacity: 0;</em></code> <em>不会从渲染树中移除元素，而是渲染它而不显示它</em>。</p>
<p><img data-attachment-id="2566" data-permalink="https://blog.logrocket.com/how-css-works-parsing-painting-css-in-the-critical-rendering-path-b3ee290762d3/0_bxfdb1usqaonjgya/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2018/04/0_bXFDb1USqAonjGYa.png" data-orig-size="2400,859" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="0_bXFDb1USqAonjGYa" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2018/04/0_bXFDb1USqAonjGYa-300x107.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2018/04/0_bXFDb1USqAonjGYa-1024x367.png" decoding="async" class="alignnone size-full wp-image-2566 jetpack-lazy-image" src="../Images/9369ca413b30831d2ed47c22b1e25824.png" alt="" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2018/04/0_bXFDb1USqAonjGYa.png 2400w, https://blog.logrocket.com/wp-content/uploads/2018/04/0_bXFDb1USqAonjGYa-300x107.png 300w, https://blog.logrocket.com/wp-content/uploads/2018/04/0_bXFDb1USqAonjGYa-768x275.png 768w, https://blog.logrocket.com/wp-content/uploads/2018/04/0_bXFDb1USqAonjGYa-1024x367.png 1024w" data-lazy-sizes="(max-width: 2400px) 100vw, 2400px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2018/04/0_bXFDb1USqAonjGYa.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2018/04/0_bXFDb1USqAonjGYa.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="2566" data-permalink="https://blog.logrocket.com/how-css-works-parsing-painting-css-in-the-critical-rendering-path-b3ee290762d3/0_bxfdb1usqaonjgya/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2018/04/0_bXFDb1USqAonjGYa.png" data-orig-size="2400,859" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="0_bXFDb1USqAonjGYa" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2018/04/0_bXFDb1USqAonjGYa-300x107.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2018/04/0_bXFDb1USqAonjGYa-1024x367.png" decoding="async" loading="lazy" class="alignnone size-full wp-image-2566" src="../Images/9369ca413b30831d2ed47c22b1e25824.png" alt="" srcset="https://blog.logrocket.com/wp-content/uploads/2018/04/0_bXFDb1USqAonjGYa.png 2400w, https://blog.logrocket.com/wp-content/uploads/2018/04/0_bXFDb1USqAonjGYa-300x107.png 300w, https://blog.logrocket.com/wp-content/uploads/2018/04/0_bXFDb1USqAonjGYa-768x275.png 768w, https://blog.logrocket.com/wp-content/uploads/2018/04/0_bXFDb1USqAonjGYa-1024x367.png 1024w" sizes="(max-width: 2400px) 100vw, 2400px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2018/04/0_bXFDb1USqAonjGYa.png"/></noscript>
<p>这样我们就有了一个渲染树，一切准备就绪！在我们将CSSOM和DOM组合成一个渲染树之后，浏览器可以使用它并安全地假设渲染树包含了绘制第一批像素所需的信息——不多也不少。</p>
<h3>冲刺阶段:布局和绘画</h3>
<p>有了完整的渲染树，浏览器就可以开始在页面上放置实际的像素了。关键渲染管道的最后阶段包含两个主要步骤:布局和绘制。</p>
<p>布局是浏览器计算出<em>元素去哪里</em>和<em>它们占据了多少空间</em>的地方。浏览器在这里考虑影响边距、填充、宽度和位置的规则。计算布局时，浏览器必须从渲染树的顶部开始向下移动，因为每个元素的位置、宽度和高度都是根据其父节点的位置计算的。</p>
<p>如果你熟悉CSS盒子模型，浏览器实际上是在页面上绘制一堆CSS盒子(如果你想了解更多关于盒子模型的信息，这里有一些很好的读物<a href="https://developer.mozilla.org/en-US/docs/Learn/CSS/Introduction_to_CSS/Box_model" target="_blank" rel="noopener noreferrer"/>)。</p>
<p>然而，重要的是要记住，此时<em>页面</em>上没有显示任何内容。可以把它想象成在视窗中绘制模板线，准备填充它们。</p>
<p>绘制直接发生在布局阶段之后，我们终于可以看到一些渲染到页面上的东西了！如果你用到达第一个像素的时间来衡量比赛的终点，这就是终点线。浏览器遍历所有其他CSS框，并用非布局规则填充它们。如果你正在使用多个合成器层，浏览器将确保东西进入它们的专用层。</p>
<p>重要的是要记住，有些CSS属性对页面权重的影响比其他属性更大(例如，绘制径向渐变比绘制简单的颜色要复杂得多)。如果你在绘制过程中遇到一些“问题”,减少“昂贵的”CSS规则可以极大地提高应用程序的感知性能。</p>
<hr/>
<h3>我为什么要关心关键渲染路径中的CSS？</h3>
<p>你可以花尽可能多的时间来优化你的应用程序的每秒帧数性能，让它看起来很漂亮，或者A-B测试更高的转化率，但如果你的用户在页面加载前反弹也没关系。</p>
<p>知道浏览器采取哪一步来到达非常重要的第一个像素是至关重要的(没有双关语😂)如果你想提高你的加载时间。由于浏览器在解析完所有CSS之前会阻止渲染，所以通过从初始HTML文档中删除任何不适用于第一次绘制的CSS，可以大大缩短加载时间。这样做可以大大减少浏览器构建CSSOM和渲染树所需的时间。</p>
<p>任何第一次加载不需要的CSS都可以被认为是“非关键的”,可以在用户获得第一次绘制后延迟加载(如果你有一个单页面应用程序，这一点尤其重要，为甚至还不可见的页面发送CSS会严重影响性能！)</p>
<p>了解CSSOM是如何构造的另一个好处是对选择器性能有更深入的了解。因为嵌套选择器必须检查CSSOM的父节点，所以它们的性能往往比避免嵌套选择器的平面CSSOM稍差。然而，我敢说，在大多数应用程序中，这并不是你的性能瓶颈，在你需要重写CSS选择器之前，可能还有其他事情可以优化。</p>
<p>与任何与web性能相关的事情一样，在开始对CSS进行全面检查之前，您可能最好先分析一下您的加载时间。如果你用的是Chrome，打开DevTools，进入<code>Performance</code>标签。通过查找<code>Recalculate Styles</code>、<code>Layout</code>和<code>Paint</code>事件，您可以快速查看您在CSSOM构建、布局和绘制上花费了多少时间。然后你可以开始琢磨你的瓶颈，并开始相应地优化。</p><div class="code-block code-block-23">
<div class="blog-plug inline-plug node-plug"><h2>200只<img src="../Images/61167b9d027ca73ed5aaf59a9ec31267.png" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2019/10/green-check.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" class=" jetpack-lazy-image" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/10/green-check.png"/> <noscript> <img data-lazy-fallback="1" src="../Images/61167b9d027ca73ed5aaf59a9ec31267.png" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/10/green-check.png"/> </noscript>显示器出现故障，生产中网络请求缓慢</h2><p>部署基于Node的web应用程序或网站是最简单的部分。确保你的Node实例继续为你的应用程序提供资源是事情变得更难的地方。如果您有兴趣确保对后端或第三方服务的请求成功，</p><a href="https://lp.logrocket.com/blg/node-signup" target="_blank">try LogRocket</a><p>. </p><a class="signup" href="https://lp.logrocket.com/blg/node-signup" target="_blank" rel="noopener noreferrer"><img src="../Images/cae72fd2a54c5f02a6398c4867894844.png" alt="LogRocket Network Request Monitoring" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2019/12/network-request-filter-2-1.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" class=" jetpack-lazy-image" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/12/network-request-filter-2-1.png"/><noscript><img data-lazy-fallback="1" src="../Images/cae72fd2a54c5f02a6398c4867894844.png" alt="LogRocket Network Request Monitoring" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/12/network-request-filter-2-1.png"/></noscript></a><a href="https://lp.logrocket.com/blg/node-signup" target="_blank" rel="noopener noreferrer">https://logrocket.com/signup/</a><p>LogRocket 就像是网络和移动应用程序的DVR，记录下用户与你的应用程序交互时发生的一切。您可以汇总并报告有问题的网络请求，以快速了解根本原因，而不是猜测问题发生的原因。</p><p>LogRocket检测您的应用程序以记录基线性能计时，如页面加载时间、到达第一个字节的时间、慢速网络请求，还记录Redux、NgRx和Vuex操作/状态。</p><a class="signup" href="https://lp.logrocket.com/blg/node-signup" target="_blank" rel="noopener noreferrer">Start monitoring for free</a><p>. </p></div>
</div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
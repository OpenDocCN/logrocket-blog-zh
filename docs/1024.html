<html>
<head>
<title>8 definitive rules for building apps with Redux - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>使用Redux - LogRocket博客构建应用程序的8条明确规则</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/8-definitive-rules-building-apps-redux/#0001-01-01">https://blog.logrocket.com/8-definitive-rules-building-apps-redux/#0001-01-01</a></blockquote><div><article class="article-post">
<p>状态管理是复杂的现代ui的关键，目前有许多解决方案可以解决这个问题。毫无疑问，Redux是其中最著名的——你要么喜欢它，要么讨厌它，但你不能忽视它。</p>
<p>Redux多年来获得了令人印象深刻的吸引力，这主要是因为它解决了问题，而且做得非常好。Redux的应用如此广泛，有人称赞，也有人批评。很多赞扬来自于开发大规模应用程序的开发人员，Redux有助于保持可伸缩性、可预测性和高性能。</p>
<p>另一方面，许多批评是基于广泛持有的观点和所谓的最佳实践，这给开发人员带来了麻烦。在我看来，Redux——如果实施得当——可以为任何大规模应用程序提供真正坚实的基础。</p>
<p>在这里，我们为Redux编制了一个必须做的实践列表，以避免任何大规模应用程序中的任何主要陷阱。</p>

<div class="podcast-container">
<div class="podcast-embed">
<h2>我们不只是写Redux，我们也谈论它。现在听着:</h2>
<p>或者以后订阅</p>
<h3>需要的时候就用！</h3>

</div>
</div>
<h2>web开发人员今天面临的主要挑战之一是评估哪些新工具值得学习和使用。随着一些很酷的新库登场，JavaScript社区每隔几周就会热闹起来；有些人喜欢他们，把他们当作救命恩人，有些人拒绝他们，质疑他们的需要。</h2>
<p>Redux最初也是如此。当它出现时，许多人认为没有更好的方法来处理国家管理，许多人仍然持有这种观点。其他人指出了Redux的几个问题，现在仍然如此。</p>
<p>那么谁是对的呢？在我看来，这个问题没有简单的答案。这完全取决于你的应用程序的规模，以及其他因素，比如你的功能需求和你的团队的能力。然而，Redux的好处是:</p>
<p><em> 1。需要Redux的时候你自己会体会到。如果你仍然不知道是否需要它，你不需要。</em></p>
<h4>Redux允许您在一个地方管理应用程序的状态，并使应用程序中的更改更加可预测和可跟踪。这使得推断应用程序中发生的变化变得更加容易。但是所有这些好处都伴随着权衡和限制。我认为从长远来看，这些约束有助于你很好地维护应用程序。</h4>
<p>每个应用程序一个商店</p>
<h2>Redux的指导原则是集中你的应用程序的状态。这为时间旅行、状态持久化等强大功能奠定了基础。借助这种集中式状态概念，Redux允许通过拆分和组合reducers在数据域之间进行隔离。因此，在大多数情况下，单个应用程序中不需要多个商店。</h2>
<p><em> 2。标准应用程序将有一个应用程序的单一商店。</em></p>
<h4>虽然在一个应用程序中可以有多个商店，但这使得订阅、持久性和再水合变得非常困难。这也使得Redux DevTools的集成变得不可能。话虽如此，有些人可能会发现这是他们在非常大的应用程序中实现性能或可伸缩性目的的最后手段。</h4>
<p>不可变存储</p>
<h2>在我们今天看到的复杂的web应用程序背后，不变性是一个真正的助推器。它使复杂的变化检测技术变得简单，导致计算量大的操作只在需要时才发生。</h2>
<p>Redux应用程序(或者说，一般的JS应用程序)中最常见的错误原因之一是直接改变对象。在我们的例子中，这可能会阻止组件的重新渲染，中断时间旅行，并妨碍Redux DevTools。不变性也会给你的程序代码带来更好的性能和推理。</p>
<p><em> 3。避免在减速器中直接改变状态(最好使用Immer)。</em></p>
<h4>编写不变性逻辑可能会很麻烦。Immer是一个3KB的gzipped库，<a href="https://blog.logrocket.com/immutability-in-react-with-immer/">通过允许您对中间草稿状态进行所有更改，使它变得非常简单。然后它根据这些突变产生下一个状态。</a></h4>
<p>可管理和可序列化的存储片</p>
<h2>Redux建议将一个集中的应用商店分成更小的、更容易管理的块，称为切片。</h2>
<p>每个切片都有一个单独的reducer函数来处理其状态中发生的所有突变。因此，每个片将拥有其状态部分，并管理与该状态部分相关的所有更改。所有这些片都通过<code>combineReducers</code> API连接在一起，该API接受一个键-值对:片的名称作为键，它的reducer作为值。</p>
<p><em> 4。每个片拥有它的状态部分:一个可序列化的对象，在基于数据域的app reducer中命名。</em></p>
<h4>人们可以将store视为一个数据库，其中保存着驱动应用程序状态的数据，每个片都被视为一个包含一个数据域的表。</h4>
<p>话虽如此，每个切片的名称应该代表它所包含的数据域—例如，“位置”、“交易”、“银行”等。基于同样的概念，存储不能包含任何不可序列化的值，因为这将破坏持久性、再水合和DevTools。</p>
<p>使用鸭子模式</p>
<h2>围绕大规模反应式应用程序的主要架构争论之一涉及文件结构。尽管Redux不依赖于文件的结构，但它在大型应用程序的维护中起着重要的作用。因此，社区中出现了许多模式。</h2>
<p>有些人建议将reducers、actions、constants和sagas放在各自的目录中，类似于Rails中使用的模式。这可能适用于功能有限的小型应用程序，但随着功能集的增长，这种模式可能会变得难以维护，因为可能一起更改的特定相关文件通常会彼此分开存储。</p>
<p>另一种(强烈推荐)方法是根据功能对文件进行分组。您的存储将被划分为多个片，每个片的常量、操作、减少器和副作用都存储在一个目录中。这使得一次开发和调试一个功能变得更加容易。</p>
<p><em> 5。最好是根据特性而不是文件类型对文件进行分组——也就是Ducks模式。</em></p>
<h4>这是一个久经考验的模式，适用于大多数复杂的React应用程序。名字来源于Redux的后半部分:“dux。”它使应用程序更具可扩展性，更易于调试，允许开发人员独立地更改和测试每个功能。</h4>
<p>使用Redux工具包</p>
<h2>最受欢迎和持久的批评之一是Redux添加到应用程序中的代码量，许多人认为这是不必要的。一些人还认为Redux需要太多额外的包才能运行。这种批评通常是基于自以为是的最佳实践，这些实践被认为是Redux应用的关键。</h2>
<p>所有这些批评和争论最终导致了Redux ToolKit (RTK)的诞生，所以:</p>
<p><em> 6。使用官方的、固执己见的、包含电池的高效Redux开发工具集:Redux Toolkit。</em></p>
<h4>RTK可以真正地<a href="https://blog.logrocket.com/smarter-redux-with-redux-toolkit/">加速开发过程</a>，同时保持高质量的代码和完整的应用性能。它带有实用功能，通过避免大量样板代码来帮助您更快地编写切片，并且它可以集成到现有的Redux应用程序中，无需任何重大更改。Redux Toolkit有效地消除了许多反对Redux的论点。</h4>
<p>使用Redux DevTools智能调试</p>
<h2>Redux优于许多其他状态管理解决方案的最大优势是围绕它开发的生态系统，令人惊叹的DevTools是其中必不可少的一部分。</h2>
<p>对于由多个动作和减少器组成的大规模应用程序，监控应用程序范围内发生的变化可能是一个巨大的挑战。Redux使应用程序具有撤销/重做动作和时间旅行的能力，Redux DevTools利用这些来使开发人员的体验愉快。</p>
<p><em> 7。Redux DevTools提供了使用Redux优于其他状态管理解决方案的最佳理由之一。</em></p>
<h4><a href="https://blog.logrocket.com/redux-devtools-tips-tricks-for-faster-debugging/">如果得到最大程度的利用</a>，Redux DevTools可以证明是开发工具集最重要的部分。这可以使Redux应用程序的开发和调试更快，是的，甚至更有趣。</h4>
<p>明智地设计商店</p>
<h2>一些Redux用户混淆了全局状态管理的原则，将每个值都保存在Redux store中，完全忽略了组件的本地状态管理。</h2>
<p>虽然没有一个正确的方法来决定什么应该保存在商店里，什么应该保存在当地，但有一些参数可以帮助您做出决定。为了保持应用程序的性能和可伸缩性，明智地设计Redux存储是必要的。</p>
<p><em> 8。利用本地状态，避免存储中不必要的值。只有应用程序范围内使用的值才会放在商店中。</em></p>
<h4>每个开发人员都必须决定什么值构成应用程序的状态，什么值可以放在附近的本地状态中。然而，可以设置一些规则来使这些决定变得更容易:如果数据被用于派生其他数据，如果它被用于应用程序的任何其他部分，或者如果该数据被缓存或水合，它应该被放在商店中。</h4>
<p>包装它</p>
<h2>React太好了，完全可以用bare React写一个完整的app。然而，当你的应用开始变成一头野兽时，Redux可以成为救世主。它可以让应用程序更具可预测性、可测试性和可扩展性。</h2>
<p>但是和其他技术一样，使用Redux进行状态管理也有一些权衡。即使有这些权衡，在我看来，Redux是当今前端世界状态管理的最佳解决方案之一。</p>
<p>使用<a class="signup" href="https://lp.logrocket.com/blg/signup" target="_blank" rel="noopener noreferrer"> LogRocket </a>消除传统错误报告的干扰</p><div class="code-block code-block-2">
<div class="blog-plug base-cta"><h2><a href="https://lp.logrocket.com/blg/signup" target="_blank" rel="noopener noreferrer"> LogRocket </a>是一个数字体验分析解决方案，它可以保护您免受数百个假阳性错误警报的影响，只针对几个真正重要的项目。LogRocket会告诉您应用程序中实际影响用户的最具影响力的bug和UX问题。</h2>
<a href="https://lp.logrocket.com/blg/signup" class="signup" target="_blank" rel="noopener noreferrer"><img class="alignnone size-full wp-image-46 jetpack-lazy-image" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/><noscript><img data-lazy-fallback="1" class="alignnone size-full wp-image-46" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/></noscript></a>
<p>然后，使用具有深层技术遥测的会话重放来确切地查看用户看到了什么以及是什么导致了问题，就像你在他们身后看一样。</p>
<p>LogRocket自动聚合客户端错误、JS异常、前端性能指标和用户交互。然后LogRocket使用机器学习来告诉你哪些问题正在影响大多数用户，并提供你需要修复它的上下文。</p>
<p>关注重要的bug—<a class="signup" href="https://lp.logrocket.com/blg/signup-issue-free" target="_blank" rel="noopener noreferrer">今天就试试LogRocket】。</a></p>
<p>Focus on the bugs that matter — <a class="signup" href="https://lp.logrocket.com/blg/signup-issue-free" target="_blank" rel="noopener noreferrer">try LogRocket today</a>.</p></div></div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
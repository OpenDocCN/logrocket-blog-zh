<html>
<head>
<title>5 ES2019 features you can use today - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>今天您可以使用的5个ES2019功能- LogRocket博客</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/5-es2019-features-you-can-use-today/#0001-01-01">https://blog.logrocket.com/5-es2019-features-you-can-use-today/#0001-01-01</a></blockquote><div><article class="article-post">
<p>ECMAScript 2015，也称为ES6，是一个花了六年时间才完成的主要版本。从那以后，负责开发ECMAScript标准的技术委员会39 (TC39)每年都会发布新的标准版本。这一年度发布周期简化了流程，并使新特性快速可用，这受到了JavaScript社区的欢迎。</p>
<p>今年将发布ECMAScript 2019(简称ES2019)。新特性包括<code>Object.fromEntries()</code>、<code>trimStart()</code>、<code>trimEnd()</code>、<code>flat()</code>、<code>flatMap()</code>，符号对象的描述属性，可选的捕捉绑定等等。</p>
<p>好消息是，这些功能已经在最新版本的Firefox和Chrome中实现了，它们也可以被传输，以便旧版本的浏览器能够处理它们。在这篇文章中，我们将好好看看这些特性，看看它们是如何升级语言的。</p>
<h2>1.Object.fromEntries()</h2>
<p>在JavaScript中，将数据从一种格式转换成另一种格式是很常见的。为了便于将对象转换成数组，ES2017引入了<code>Object.entries()</code>方法。该方法将一个对象作为参数，并以<code>[key, value]</code>的形式返回该对象自己的可枚举字符串键属性对的数组。例如:</p>
<pre>const obj = {one: 1, two: 2, three: 3};

console.log(Object.entries(obj));    
// =&gt; [["one", 1], ["two", 2], ["three", 3]]</pre>
<p>但是，如果我们想做相反的事情，将一个键值对列表转换成一个对象呢？一些编程语言，比如Python，为此提供了<code>dict()</code>函数。下划线. js和Lodash中还有<code>_.fromPairs</code>函数。</p>
<p>ES2019旨在通过引入<code>Object.fromEntries() method</code>为JavaScript带来类似的功能。这个静态方法允许您轻松地将一组键值对转换成一个对象:</p>
<pre>const myArray = [['one', 1], ['two', 2], ['three', 3]];
const obj = Object.fromEntries(myArray);

console.log(obj);    // =&gt; {one: 1, two: 2, three: 3}</pre>
<p>如你所见，<code>Object.fromEntries()</code>只是<code>Object.entries()</code>的反义词。虽然以前有可能达到同样的结果，但这并不简单:</p>
<pre>const myArray = [['one', 1], ['two', 2], ['three', 3]];
const obj = Array.from(myArray).reduce((acc, [key, val]) =&gt; Object.assign(acc, {[key]: val}), {});

console.log(obj);    // =&gt; {one: 1, two: 2, three: 3}</pre>
<p>请记住，传递给<code>Object.fromEntries()</code>的参数可以是实现iterable协议的任何对象，只要它返回一个两元素、类似数组的对象。</p>
<p>例如，在下面的代码中，<code>Object.fromEntries()</code>将一个Map对象作为参数，并创建一个新对象，其键和相应的值由Map中的对给出:</p>
<pre>const map = new Map();
map.set('one', 1);
map.set('two', 2);

const obj = Object.fromEntries(map);

console.log(obj);    // =&gt; {one: 1, two: 2}</pre>
<p><code>Object.fromEntries()</code>方法对于变换对象也非常有用。考虑以下代码:</p>
<pre>const obj = {a: 4, b: 9, c: 16};

// convert the object into an array
const arr = Object.entries(obj);

// get the square root of the numbers
const map = arr.map(([key, val]) =&gt; [key, Math.sqrt(val)]);

// convert the array back to an object
const obj2 = Object.fromEntries(map);

console.log(obj2);  // =&gt; {a: 2, b: 3, c: 4}</pre>
<p>这段代码将对象中的值转换成它们的平方根。为此，它首先将对象转换成一个数组，然后使用<code>map()</code>方法获得数组中值的平方根。结果是可以转换回对象的数组的数组。</p>
<p><code>Object.fromEntries()</code>派上用场的另一种情况是处理URL的查询字符串，如下例所示:</p>
<pre>const paramsString = 'param1=foo&amp;param2=baz';
const searchParams = new URLSearchParams(paramsString);

Object.fromEntries(searchParams);    // =&gt; {param1: "foo", param2: "baz"}</pre>
<p>在这段代码中，一个查询字符串被传递给<code>URLSearchParams()</code>构造函数。然后返回值，也就是一个<code>URLSearchParams</code>对象实例，被传递给<code>Object.fromEntries()</code>方法。结果是一个包含每个参数作为属性的对象。</p>
<p><code>Object.fromEntries()</code>方法目前是第4阶段提案，这意味着它已经准备好纳入ES2019标准。</p>
<h2>2.trimStart()和trimEnd()</h2>
<p><code>trimStart()</code>和<code>trimEnd()</code>方法在技术上与<code>trimLeft()</code>和<code>trimRight()</code>相同。这些方法目前是第4阶段的建议，为了与<code>padStart()</code>和<code>padEnd()</code>保持一致，将被添加到规范中。让我们看一些例子:</p>
<pre>const str = "   string   ";

// es2019
console.log(str.trimStart());    // =&gt; "string   "
console.log(str.trimEnd());      // =&gt; "   string"

// the same as
console.log(str.trimLeft());     // =&gt; "string   "
console.log(str.trimRight());    // =&gt; "   string"</pre>
<p>为了网页兼容性，<code>trimLeft()</code>和<code>trimRight()</code>将保留为<code>trimStart()</code>和<code>trimEnd()</code>的别名。</p>
<h2>3.flat()和flatMap()</h2>
<p><code>flat()</code>方法使您能够轻松地连接一个数组的所有子数组元素。考虑下面的例子:</p>
<pre>const arr = ['a', 'b', ['c', 'd']];
const flattened = arr.flat();

console.log(flattened);    // =&gt; ["a", "b", "c", "d"]</pre>
<p>以前，您必须使用<code>reduce()</code>或<code>concat()</code>来获得平面数组:</p>
<pre>const arr = ['a', 'b', ['c', 'd']];
const flattened = [].concat.apply([], arr);

// or
// const flattened =  [].concat(...arr);

console.log(flattened);    // =&gt; ["a", "b", "c", "d"]</pre>
<p>请注意，如果所提供的数组中有任何空插槽，它们将被丢弃:</p>
<pre>const arr = ['a', , , 'b', ['c', 'd']];
const flattened = arr.flat();

console.log(flattened);    // =&gt; ["a", "b", "c", "d"]</pre>
<p><code>flat()</code>还接受一个可选参数，该参数指定嵌套数组应展平的级数。如果没有提供参数，将使用默认值1:</p>
<pre>const arr = [10, [20, [30]]];

console.log(arr.flat());     // =&gt; [10, 20, [30]]
console.log(arr.flat(1));    // =&gt; [10, 20, [30]]
console.log(arr.flat(2));    // =&gt; [10, 20, 30]</pre>
<p><code>flatMap()</code>方法将<code>map()</code>和<code>flat()</code>组合成一个方法。它首先用提供的函数的返回值创建一个新数组，然后连接该数组的所有子数组元素。一个例子应该能使这一点更清楚:</p>
<pre>const arr = [4.25, 19.99, 25.5];

console.log(arr.map(value =&gt; [Math.round(value)]));    
// =&gt; [[4], [20], [26]]

console.log(arr.flatMap(value =&gt; [Math.round(value)]));    
// =&gt; [4, 20, 26]</pre>
<p>数组将被展平的深度级别是1。如果您想从结果中删除一项，只需返回一个空数组:</p>
<pre>const arr = [[7.1], [8.1], [9.1], [10.1], [11.1]];

// do not include items bigger than 9
arr.flatMap(value =&gt; {
  if (value &gt;= 10) {
    return [];
  } else {
    return Math.round(value);
  }
});  

// returns:
// =&gt; [7, 8, 9]</pre>
<p>除了正在处理的当前元素之外，回调函数还将接收元素的索引和对数组本身的引用。<code>flat()</code>和<code>flatMap()</code>方法目前是第4阶段提案。</p>
<h2>4.符号对象的描述属性</h2>
<p>创建符号时，可以出于调试目的向其添加说明。有时候，能够直接访问代码中的描述是很有用的。</p>
<p>该ES2019提案向符号对象添加了一个只读描述属性，该属性返回一个包含符号描述的字符串。以下是一些例子:</p>
<pre>let sym = Symbol('foo');
console.log(sym.description);    // =&gt; foo

sym = Symbol();
console.log(sym.description);    // =&gt; undefined

// create a global symbol
sym = Symbol.for('bar');
console.log(sym.description);    // =&gt; bar</pre>
<h2>5.可选catch绑定</h2>
<p><code>try … catch</code>语句中的catch绑定并不总是被使用。考虑以下代码:</p>
<pre>try {
  // use a feature that the browser might not have implemented
} catch (unused) {
  // fall back to an already implemented feature 
}</pre>
<p>在这段代码中没有使用catch绑定。然而，它仍然应该用来避免一个<code>SyntaxError</code>。这个提议对ECMAScript规范做了一个小小的修改，允许您省略catch绑定及其括号:</p>
<pre>try {
  // use a feature that the browser might not have implemented
} catch {
  // do something that doesn’t care about the value thrown
}</pre>
<h2>奖励:es 2020 string . prototype . match all</h2>
<p><code>matchAll()</code>方法是第4阶段ES2020提案，针对正则表达式返回所有匹配的迭代器对象——包括捕获组。</p>
<p>为了与<code>match()</code>方法保持一致，TC39选择了“matchAll”而不是其他建议的名称，比如“matches”或Ruby的“scan”。让我们看一个简单的例子:</p>
<pre>const re = /(Dr\. )\w+/g;
const str = 'Dr. Smith and Dr. Anderson';
const matches = str.matchAll(re);

for (const match of matches) {
  console.log(match);
}

// logs:
// =&gt; ["Dr. Smith", "Dr. ", index: 0, input: "Dr. Smith and Dr. Anderson", groups: undefined]
// =&gt; ["Dr. Anderson", "Dr. ", index: 14, input: "Dr. Smith and Dr. Anderson", groups: undefined]</pre>
<p>这个正则表达式中的捕获组匹配字符“Dr ”,后跟一个点和一个空格。<code>\w+</code>匹配任意单词字符一次或多次。并且<code>g</code>标志指示引擎在整个字符串中搜索模式。</p>
<p>以前，您必须在一个循环中使用<code>exec()</code>方法来获得相同的结果，这不是很有效:</p>
<pre>const re = /(Dr\.) \w+/g;
const str = 'Dr. Smith and Dr. Anderson';
let matches;

while ((matches = re.exec(str)) !== null) {
  console.log(matches);
}

// logs:
// =&gt; ["Dr. Smith", "Dr.", index: 0, input: "Dr. Smith and Dr. Anderson", groups: undefined]
// =&gt; ["Dr. Anderson", "Dr.", index: 14, input: "Dr. Smith and Dr. Anderson", groups: undefined]</pre>
<p>值得注意的是，尽管可以使用全局标志<code>g</code>来使用<code>match()</code>方法来访问所有匹配，但它不提供匹配的捕获组或索引位置。比较:</p>
<pre>const re = /page (\d+)/g;
const str = 'page 2 and page 10';

console.log(str.match(re));    
// =&gt; ["page 2", "page 10"]

console.log(...str.matchAll(re)); 
// =&gt; ["page 2", "2", index: 0, input: "page 2 and page 10", groups: undefined] 
// =&gt; ["page 10", "10", index: 11, input: "page 2 and page 10", groups: undefined]</pre>
<h2>包扎</h2>
<p>在这篇文章中，我们仔细研究了ES2019中引入的几个关键功能，包括<code>Object.fromEntries()</code>、<code>trimStart()</code>、<code>trimEnd()</code>、<code>flat()</code>、<code>flatMap()</code>、符号对象的描述属性以及可选的catch绑定。</p>
<p>尽管一些浏览器供应商还没有完全实现这些特性，但是由于Babel和其他JavaScript transpilers，您仍然可以在您的项目中使用它们。</p>
<p>ECMAScript的开发速度在最近几年加快了，新的特性不时地被引入和实现，所以一定要查看一下<a href="https://github.com/tc39/proposals/blob/master/finished-proposals.md" target="_blank" rel="noopener noreferrer">完成提案的列表</a>以了解最新的新特性。你有什么建议吗？在评论中分享吧！</p><div class="code-block code-block-2">
<div class="blog-plug base-cta"><h2>使用<a class="signup" href="https://lp.logrocket.com/blg/signup" target="_blank" rel="noopener noreferrer"> LogRocket </a>消除传统错误报告的干扰</h2>
<a href="https://lp.logrocket.com/blg/signup" class="signup" target="_blank" rel="noopener noreferrer"><img class="alignnone size-full wp-image-46 jetpack-lazy-image" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/><noscript><img data-lazy-fallback="1" class="alignnone size-full wp-image-46" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/></noscript></a>
<p><a href="https://lp.logrocket.com/blg/signup" target="_blank" rel="noopener noreferrer"> LogRocket </a>是一个数字体验分析解决方案，它可以保护您免受数百个假阳性错误警报的影响，只针对几个真正重要的项目。LogRocket会告诉您应用程序中实际影响用户的最具影响力的bug和UX问题。</p>
<p>然后，使用具有深层技术遥测的会话重放来确切地查看用户看到了什么以及是什么导致了问题，就像你在他们身后看一样。</p>
<p>LogRocket自动聚合客户端错误、JS异常、前端性能指标和用户交互。然后LogRocket使用机器学习来告诉你哪些问题正在影响大多数用户，并提供你需要修复它的上下文。</p>
<p>关注重要的bug—<a class="signup" href="https://lp.logrocket.com/blg/signup-issue-free" target="_blank" rel="noopener noreferrer">今天就试试LogRocket】。</a></p></div></div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
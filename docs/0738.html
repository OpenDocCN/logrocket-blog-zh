<html>
<head>
<title>Querying databases with Knex.js - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>使用Knex.js - LogRocket博客查询数据库</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/querying-databases-with-knex-js/#0001-01-01">https://blog.logrocket.com/querying-databases-with-knex-js/#0001-01-01</a></blockquote><div><article class="article-post">
<h2>Knex简介</h2>
<p>Knex.js是一个“包含电池”的查询构建器，用于PostgreSQL、MySQL、SQLite3、Oracle、Amazon Redshift和许多其他数据库驱动程序。我们只需安装Knex库和适当的驱动程序来查询数据库。Knex主要是为Node.js设计的，支持节点风格的回调和承诺。在本文中，我们将研究用Knex查询Postgres数据库。</p>
<h2>连接Knex和Postgres</h2>
<p>要使用Knex和Postgres，我们必须首先在应用程序中安装Knex和pg驱动程序。</p>
<pre>npm install pg knex --save</pre>
<p>安装完依赖项后，下一步是建立到pg的连接。这与我们传统上在节点应用程序中建立pg连接的方式大致相同。我们为Postgres和point Knex指定连接参数，以连接到pg客户机。</p>
<pre>const db = require("knex")({
  client: "pg",
  connection: {
    host: "localhost",
    user: "postgres",
    password: "",
    database: "knex-test"
  }
});

app.set("db", db);
</pre>
<p>一旦建立了连接，我们将播种数据，而不用用Knex和<a href="https://github.com/marak/Faker.js/"> faker.js </a>编写任何查询。我使用Postman和pgAdmin来测试我们正在构建的API。</p>
<h2>播种转储数据</h2>
<p>Knex提供了许多<a href="http://knexjs.org/#Schema-Building">内置助手</a>来构建我们的表模式。我已经使用内置的<code>createTable</code>函数创建了一个名为<code>users</code>的表，如果这个表不存在的话。Faker.js正在帮助我们将虚拟数据植入表中。我使用内置的<code>.insert</code>方法将数据插入到我们刚刚创建的用户表中。这一切都发生在我们到达路线<code>http:localhost:3000/seed</code>的时候。</p>
<pre>router.get("/seed", function(req, res, next) {
  const db = req.app.get('db');
  db.schema.hasTable("users").then(function(exists) {
    if (!exists) {
      db.schema
        .createTable("users", function(table) {
          table.increments("id").primary();
          table.string("name");
          table.string("email");
        })
        .then(function() {
          const recordsLength = Array.from(Array(100).keys());
          const records = recordsLength.map(rec =&gt; ({
            name: faker.name.findName(),
            email: faker.internet.email()
          }));
          db("users")
            .insert(records)
            .then(() =&gt; {
              res.send("Seeded data");
            });
        });
    } else {
      res.send("Table exists - Seeded data");
    }
  });
});</pre>
<p>如果您安装了pgAdmin，您可以快速查看种子数据。当一切正常时，您将在浏览器或邮递员界面上看到响应“种子数据”。当您尝试重新访问该路由时，它会返回“表存在-植入数据”</p>
<p><img data-attachment-id="15621" data-permalink="https://blog.logrocket.com/querying-databases-with-knex-js/seeded-data/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/03/seeded-data.png" data-orig-size="730,313" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Seeded data in a table" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/03/seeded-data-300x129.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/03/seeded-data.png" decoding="async" class="aligncenter size-full wp-image-15621 jetpack-lazy-image" src="../Images/79b5a898d0798f5bacc3f40232725419.png" alt="Screenshot Of Our Seeded Data In A Table" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2020/03/seeded-data.png 730w, https://blog.logrocket.com/wp-content/uploads/2020/03/seeded-data-300x129.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2020/03/seeded-data.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/03/seeded-data.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="15621" data-permalink="https://blog.logrocket.com/querying-databases-with-knex-js/seeded-data/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/03/seeded-data.png" data-orig-size="730,313" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Seeded data in a table" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/03/seeded-data-300x129.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/03/seeded-data.png" decoding="async" loading="lazy" class="aligncenter size-full wp-image-15621" src="../Images/79b5a898d0798f5bacc3f40232725419.png" alt="Screenshot Of Our Seeded Data In A Table" srcset="https://blog.logrocket.com/wp-content/uploads/2020/03/seeded-data.png 730w, https://blog.logrocket.com/wp-content/uploads/2020/03/seeded-data-300x129.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/03/seeded-data.png"/></noscript>
<h2>查询、插入和删除数据</h2>
<h3>获取所有数据</h3>
<p>Knex让查询变得非常简单。我将编写一个可以获取、更新、删除和创建用户的服务。使用Knex，从Postgres数据库中查询数据非常简单:</p>
<pre>getAllUsers(db) {
    return db
      .select("*")
      .from("users")
      .then(rows =&gt; rows);
 }</pre>
<p>我将创建一个<code>get</code>路由来从数据库中获取所有用户。当从Postman ping这个端点时，Knex为我们请求的数据构建查询并返回数据。</p>
<pre>router
  .route("/")
  .get(function(req, res) {
    const db = req.app.get("db");
    UsersService.getAllUsers(db).then(data =&gt; {
      res.send(data);
    });
  })</pre>
<h3>插入数据</h3>
<p>向数据库中插入新用户也很简单。我将为我们已经创建的路线创建一个<code>.post</code>方法，并用一个查询更新<code>usersService.js</code>以将数据插入pg数据库。</p>
<pre>const UsersService = {
  insertUser(db, newUser) {
    return db
      .insert(newUser)
      .into("users")
      .returning("*")
      .then(rows =&gt; {
        return rows[0];
      });
  }
};

module.exports = UsersService;</pre>
<p>更新后的路线如下所示:</p>
<pre>router.route('/')
  .get(function(req, res, next) {
    const db = req.app.get("db");
    UsersService.getAllUsers(db).then(data =&gt; {
      res.send(data);
    });
  })
  .post(function(req, res) {
    const db = req.app.get("db");
    UsersService.insertUser(db, req.body).then(data =&gt; {
      res.send(data);
    });
  });</pre>
<h3>更新、删除和获取特定数据</h3>
<p>我将根据用户ID对更新、删除和获取的路由进行分组。</p>
<pre>router
  .route("/:id")
  .get(function(req, res) {
    const db = req.app.get("db");
    UsersService.getById(db, req.params.id).then(data =&gt; {
      res.send(data);
    });
  })
  .patch(function(req, res) {
    const db = req.app.get("db");
    UsersService.updateUser(db, req.params.id, req.body).then(() =&gt; {
      res.status(204).end();
    });
  })
  .delete(function(req, res) {
    const db = req.app.get("db");
    UsersService.deleteUser(db, req.params.id).then(data =&gt; {
      res.status(204).end();
    });
  });</pre>
<p>从Knex查询特定信息非常简单。在这个例子中，我们使用了带有一个<code>where </code>子句的<code>select</code>、<code>update</code>和<code>delete</code>的组合，通过ID选择用户并修改他们的信息。<code>usersService.js</code>看起来像:</p>
<pre>const UsersService = {
  getById(db, id) {
    return db
      .from("users")
      .select("*")
      .where("id", id)
      .first();
  },
  deleteUser(db, id) {
    return db("users")
      .where({ id })
      .delete();
  },
  updateUser(db, id, userFields) {
    return db("users")
      .where({ id })
      .update(userFields);
  }
};

module.exports = UsersService;</pre>
<p>使用适当的用户ID点击GET、PATCH或DELETE路径，我们将能够从数据库中查看、修改或删除用户信息。</p>
<p>完整版本的<code><a href="https://github.com/AvanthikaMeenakshi/knex-tutorial/blob/master/module/usersService.js">usersService.js</a></code>和<a href="https://github.com/AvanthikaMeenakshi/knex-tutorial/blob/master/routes/index.js">路线</a>被推送到GitHub上的<a href="https://github.com/AvanthikaMeenakshi/knex-tutorial">这个库</a>。</p>
<h2>Knex.js的利与弊</h2>
<h5>优点:</h5>
<ol>
<li>帮助我们编写更少的SQL查询:Knex知道您正在连接到哪个数据库系统，并将改变它编写的SQL以匹配</li>
<li>感觉更像是用JavaScript编程</li>
<li>迁移和播种要简单得多</li>
</ol>
<h5>缺点:</h5>
<ol>
<li>您仍然应该花时间在更深的层次上学习数据库操作</li>
<li>Knex需要一个学习曲线。它本身就是一个库，开发人员应该非常了解使用Knex的方法</li>
<li>如果你是一个尝试构建API的初学者，选择艰难的道路比快乐的道路更好。与使用Knex之类的查询构建器相比，自己编写查询将使您更加精通和熟悉数据库</li>
</ol>
<p> </p><div class="code-block code-block-28">
<div class="blog-plug inline-plug js-libraries-plug"><h2>您是否添加了新的JS库来提高性能或构建新特性？如果他们反其道而行之呢？</h2><p>毫无疑问，前端变得越来越复杂。当您向应用程序添加新的JavaScript库和其他依赖项时，您将需要更多的可见性，以确保您的用户不会遇到未知的问题。</p>
<p>LogRocket 是一个前端应用程序监控解决方案，可以让您回放JavaScript错误，就像它们发生在您自己的浏览器中一样，这样您就可以更有效地对错误做出反应。</p><a class="signup" href="https://lp.logrocket.com/blg/javascript-signup" target="_blank" rel="noopener noreferrer"><img class="alignnone size-full wp-image-46 jetpack-lazy-image" src="../Images/e8a0ab42befa3b3b1ae08c1439527dc6.png" alt="LogRocket Dashboard Free Trial Banner" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2019/10/errors-screenshot.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/10/errors-screenshot.png"/><noscript><img data-lazy-fallback="1" class="alignnone size-full wp-image-46" src="../Images/e8a0ab42befa3b3b1ae08c1439527dc6.png" alt="LogRocket Dashboard Free Trial Banner" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/10/errors-screenshot.png"/></noscript></a>
<a href="https://lp.logrocket.com/blg/javascript-signup" target="_blank" rel="noopener noreferrer">https://logrocket.com/signup/</a><p><a href="https://lp.logrocket.com/blg/javascript-signup" target="_blank" rel="noopener noreferrer"> LogRocket </a>可以与任何应用程序完美配合，不管是什么框架，并且有插件可以记录来自Redux、Vuex和@ngrx/store的额外上下文。您可以汇总并报告问题发生时应用程序的状态，而不是猜测问题发生的原因。LogRocket还可以监控应用的性能，报告客户端CPU负载、客户端内存使用等指标。</p><p>自信地构建— <a class="signup" href="https://lp.logrocket.com/blg/javascript-signup" target="_blank" rel="noopener noreferrer">开始免费监控</a>。</p></div>


</div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>


</div>    
</body>
</html>
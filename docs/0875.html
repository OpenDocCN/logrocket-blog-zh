<html>
<head>
<title>A comprehensive guide to video playback in React - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>React - LogRocket博客视频播放综合指南</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/a-comprehensive-guide-to-video-playback-in-react/#0001-01-01">https://blog.logrocket.com/a-comprehensive-guide-to-video-playback-in-react/#0001-01-01</a></blockquote><div><article class="article-post">
<p>在思科最近的一项研究中，预计到2022年，82%的消费者互联网流量将采用视频内容的形式，比2017年高出15倍。了解支撑视频播放的技术以及如何最好地利用它来提供最佳体验，从来没有像现在这样重要。</p>
<p>在这篇文章中，我们将在重点介绍一些最流行的JavaScript视频播放器框架、它们的特性以及如何在React中实现它们之前，先浏览一下视频播放的基础知识。</p>
<h3>视频播放基础</h3>
<p>为了理解视频回放，首先理解用户点击播放按钮和正在播放的视频的第一帧之间涉及的过程是很重要的。在这两点之间有相当多的步骤可能出错，最终会影响您的视频性能，或者在更糟糕的情况下，意味着您的视频根本无法播放。</p>
<p>除非您的视频文件非常小，否则您的视频播放器不太可能在播放前一次性下载整个文件。</p>
<p>这将最终导致消费者在看到任何内容之前等待相当长的时间，这可能导致他们变得不耐烦并离开视频。</p>
<p>一次性下载整个视频的过程通常被称为单源播放，大多数情况下不建议这样做。</p>
<p>相反，视频内容通常被分成称为“块”的片段，视频播放器连续下载这些片段，以确保设备在任何给定时间只下载小块数据。</p>
<p>除了被分割成小块的数据之外，通常还有多个级别的视频质量可供播放器使用，以便客户能够选择更适合其网络条件的比特率。</p>
<p>如果你曾经见过可怕的缓冲符号，那是因为视频播放器未能及时降低比特率，播放器试图下载每个块。</p>
<p>客户端在不同质量级别的视频之间切换并尝试下载块的过程称为自适应比特率流(ABS ),在讨论视频回放时理解这一点非常重要。</p>
<p>MSS、HLS和DASH是三种不同的技术，用于实现有效的ABS。</p>
<h2>手写本</h2>
<p>MSS (Microsoft Smooth Streaming)由微软标准化，并随着Silverlight播放器的引入而首次出现。</p>
<p>MSS以一系列小块的形式下载视频，这些小块缓存在网络边缘，这意味着客户端请求和接收这些小块的事务可以更快地发生。</p>
<p>为了开始播放，视频播放器从服务器请求一个清单文件，该文件展示了关于所请求的视频的细节，例如视频的持续时间、每个块的位置以及播放器可用的比特率。</p>
<p>以下是MSS清单示例，其中一些关键信息标有:</p>
<pre>&lt;SmoothStreamingMedia
  MajorVersion="2"
  MinorVersion="1"
  Duration="1209510000"&gt; // Total video duration
  
  &lt;!-- Video information --&gt;
  &lt;StreamIndex
    Type="video"
    Name="video"
    Chunks="4" // Number of chunks
    QualityLevels="4" // Number of bitrates available
    MaxWidth="1280"
    MaxHeight="720"
    DisplayWidth="1280"
    DisplayHeight="720"
    Url="QualityLevels({bitrate})/Fragments(video={start time})"&gt; // URL template to request chunks
    
    &lt;!-- Quality levels --&gt;
    &lt;QualityLevel
      Index="0"
      Bitrate="2962000"
      MaxWidth="1280"
      MaxHeight="720" /&gt;
    &lt;QualityLevel
      Index="1"
      Bitrate="2056000"
      MaxWidth="992"
      MaxHeight="560" /&gt;
    &lt;QualityLevel
      Index="2"
      Bitrate="1427000"
      MaxWidth="768"
      MaxHeight="432" /&gt;
    &lt;QualityLevel
      Index="3"
      Bitrate="991000"
      MaxWidth="592"
      MaxHeight="332" /&gt;
    &lt;QualityLevel
      Index="4"
      Bitrate="688000"
      MaxWidth="448"
      MaxHeight="252" /&gt;
    
    &lt;!-- Chunks --&gt;
    &lt;c d="20020000" /&gt; // Chunk duration
    &lt;c d="20020000" /&gt;
    &lt;c d="20020000" /&gt;
    &lt;c d="20020000" /&gt;
  &lt;/StreamIndex&gt;
&lt;/SmoothStreamingMedia&gt;</pre>
<p>MSS是微软平台上最常用的ABS技术之一，旨在提供最小的缓冲和快速的启动时间。</p>
<h3>HLS</h3>
<p>HLS代表HTTP Live Streaming，由苹果公司在2009年随着iPhone 3的发布而开发，作为流行的Adobe flash格式的替代方案。</p>
<p>HLS将视频分成10秒钟的小段，索引在一个单独的播放列表文件中，是苹果iOS和OSX设备上唯一支持的标准。</p><div class="code-block code-block-54">
<hr/>
<h3>更多来自LogRocket的精彩文章:</h3>

<hr/></div>
<p>HLS播放列表示例如下:</p>
<pre>#EXTM3U
#EXT-X-PLAYLIST-TYPE:VOD
&lt;!-- Video duration --&gt;
#EXT-X-TARGETDURATION:10
#EXT-X-VERSION:4
#EXT-X-MEDIA-SEQUENCE:0
&lt;!-- Chunk duration (10 seconds) --&gt;
#EXTINF:10.0,
&lt;!-- URL to request chunk --&gt;
http://example.com/movie1/fileSequenceA.ts
#EXTINF:10.0,
http://example.com/movie1/fileSequenceB.ts
#EXTINF:10.0,
http://example.com/movie1/fileSequenceC.ts
#EXTINF:9.0,
http://example.com/movie1/fileSequenceD.ts
#EXT-X-ENDLIST</pre>
<p>HLS的主要好处是它是苹果设备唯一的原生ABS格式。如果你想在iOS设备上实现视频播放，HLS是你唯一的选择。</p>
<h3>破折号</h3>
<p>HTTP上的动态自适应流(DASH)是一项相当新的技术，旨在为所有设备提供支持，避免为同一视频源实施MSS和HLS等多种技术带来的不必要的复杂性。</p>
<p>在2009年MPEG征集提案后，包括谷歌和微软在内的50多家大公司合作制定了MPEG-DASH标准，并最终于2012年发布。</p>
<p>本质上，DASH的目标是将当前所有的技术结合成一个，提供每个标准的优点并减少技术上的麻烦。通常，DASH视频被分割成2-4秒的视频块，从而允许更快的视频下载并最终获得更好的性能。</p>
<p>仪表板清单样本:</p>
<pre>&lt;MPD  profiles="urn:mpeg:dash:profile:full:2011"&gt;
    &lt;Period duration="PT10M"&gt; // Period Duration
        &lt;BaseURL&gt;main/&lt;/BaseURL&gt;
        &lt;AdaptationSet mimeType="video/mp2t"&gt;
            &lt;BaseURL&gt;video/&lt;/BaseURL&gt;
            &lt;!-- 1st Bitrate --&gt;
            &lt;Representation id="720p" bandwidth="3200000" width="1280" height="720"&gt;
                &lt;BaseURL&gt;720p/&lt;/BaseURL&gt;
                &lt;!-- Chunk List --&gt;
                &lt;SegmentList timescale="90000" duration="5400000"&gt;
                    &lt;RepresentationIndex sourceURL="representation-index.sidx"/&gt;
                    &lt;SegmentURL media="segment-1.ts"/&gt;
                    &lt;SegmentURL media="segment-2.ts"/&gt;
                    &lt;SegmentURL media="segment-3.ts"/&gt;
                    &lt;SegmentURL media="segment-4.ts"/&gt;
                    &lt;SegmentURL media="segment-5.ts"/&gt;
                    &lt;SegmentURL media="segment-6.ts"/&gt;
                    &lt;SegmentURL media="segment-7.ts"/&gt;
                    &lt;SegmentURL media="segment-8.ts"/&gt;
                    &lt;SegmentURL media="segment-9.ts"/&gt;
                    &lt;SegmentURL media="segment-10.ts"/&gt;
                &lt;/SegmentList&gt;
            &lt;/Representation&gt;
            &lt;!-- 2nd Bitrate --&gt;
            &lt;Representation id="1080p" bandwidth="6800000" width="1920" height="1080"&gt;
                &lt;BaseURL&gt;1080/&lt;/BaseURL&gt;
                &lt;!-- Chunk List --&gt;
                &lt;SegmentList timescale="90000" duration="5400000"&gt; // Segment duration
                    &lt;RepresentationIndex sourceURL="representation-index.sidx"/&gt;
                    &lt;SegmentURL media="segmentl-1.ts"/&gt;
                    &lt;SegmentURL media="segmentl-2.ts"/&gt;
                    &lt;SegmentURL media="segmentl-3.ts"/&gt;
                    &lt;SegmentURL media="segmentl-4.ts"/&gt;
                    &lt;SegmentURL media="segmentl-5.ts"/&gt;
                    &lt;SegmentURL media="segmentl-6.ts"/&gt;
                    &lt;SegmentURL media="segmentl-7.ts"/&gt;
                    &lt;SegmentURL media="segmentl-8.ts"/&gt;
                    &lt;SegmentURL media="segmentl-9.ts"/&gt;
                    &lt;SegmentURL media="segmentl-10.ts"/&gt;
                &lt;/SegmentList&gt;
            &lt;/Representation&gt;
        &lt;/AdaptationSet&gt;
    &lt;/Period&gt;
&lt;/MPD&gt;</pre>
<h2>视频播放器框架</h2>
<p>现在，您已经了解了不同的ABS技术，我们可以看看可用于适应它们的各种JavaScript播放器框架。</p>
<p>虽然行业似乎正在向DASH发展，但它仍然是一项相对较新的技术，运行MSS和/或HLS的系统仍然存在于我们的视频基础设施中，特别是在HLS是唯一选项的苹果设备上。</p>
<p>让我们看看一些最流行的JavaScript视频播放器框架，它们支持的ABS技术，以及如何在React中实现它们。</p>
<h3>视频. js</h3>
<p>我们要研究的第一项技术可以说是当今最流行的开源视频播放器框架之一。Video.js是在2010年从零开始构建的，并考虑到了Javascript世界，全球约有500，000个网站使用它。</p>
<p>其主要卖点在于，旨在支持所有类型的视频格式，包括自适应视频格式，如HLS和DASH。</p>
<p>Video.js被Tumblr和LinkedIn等公司使用，它易于设计风格，跨功能，易于实现。但是它在React世界中是怎样的呢？</p>
<p>幸运的是，在React中实现Video.js并不太困难，几分钟内就可以启动并运行。首先，你需要点击<a href="https://videojs.com/getting-started/" target="_blank" rel="noopener noreferrer">这里的</a>来下载Video.js或者使用npm和<code>npm i video.js</code>来导入它。</p>
<p>在这里，Video.js播放器需要在<code>componentDidMount</code>上进行实例化，然后才能使用:</p>
<pre>import React from 'react';
import videojs from 'video.js'
export default class VideoPlayer extends React.Component {
  componentDidMount() {
    this.player = videojs(this.videoNode, this.props, function onPlayerReady() {
      console.log('Video.js Ready', this)
    });
  }
  componentWillUnmount() {
    if (this.player) {
      this.player.dispose()
    }
  }
  render() {
    return (
      &lt;div&gt; 
        &lt;div data-vjs-player&gt;
          &lt;video ref={ node =&gt; this.videoNode = node } className="video-js"&gt;&lt;/video&gt;
        &lt;/div&gt;
      &lt;/div&gt;
    )
  }
}</pre>
<p>您可能会注意到播放器被包装在一个<code>data-vjs-player</code> div中。这是一个额外的步骤，确保不会在DOM中创建额外的包装器。一旦创建了组件，就可以用各种选项来触发它以开始播放。</p>
<p>Video.js可用选项的完整列表可以在<a href="https://docs.videojs.com/tutorial-options.html" target="_blank" rel="noopener noreferrer">这里</a>找到。</p>
<pre>const videoJsOptions = {
  autoplay: true,
  controls: true,
  sources: [{
    src: '/path/to/video.mp4',
    type: 'video/mp4'
  }]
}
return &lt;VideoPlayer { ...videoJsOptions } /&gt;</pre>
<h3>HLS.js</h3>
<p>Video.js为播放HLS内容提供了一个解决方案，但是作为处理Apple格式的更好的选择之一，一个正在获得关注的播放器框架是HLS.js。</p>
<p>这项技术于2015年发布，现已在包括Twitter和纽约时报在内的数千家知名网站上投入使用。</p>
<p>HLS.js的吸引力在于其实现的简单性和微小的占用空间(它只有本文提到的其他播放器的一半大小，只有71.1KB)。</p>
<p>依靠HTML5视频和媒体源扩展来实现回放，您可以在浏览器中快速高效地提供可靠的HLS回放。</p>
<p>在React中实现HLS.js的第一步是下载<a href="https://github.com/video-dev/hls.js" target="_blank" rel="noopener noreferrer">最新的库</a>，并将其包含在React项目中，或者使用<code>npm i hls.js</code>从npm安装。</p>
<p>从那里，我们在渲染函数中创建一个标准的<code>&lt;video&gt;</code>标签。</p>
<p>我们还将为播放器提供一个引用<code>this.player</code>,以便我们稍后可以使用它来实例化我们的播放器框架:</p>
<pre>import React from "react";
import Hls from "hls.js";
export default class VideoPlayer extends React.Component {
  state = {};
  render() {
    return (
          &lt;video
            className="videoCanvas"
            ref={player =&gt; (this.player = player)}
            autoPlay={true}
          /&gt;
    );
  }
}</pre>
<p>一旦视频标签就位，在HLS.js中呈现视频就像更新我们的<code>componentDidUpdate</code>来附加媒体一样简单:</p>
<pre>import React from "react";
import Hls from "hls.js";
export default class VideoPlayer extends React.Component {
  state = {};
  componentDidUpdate() {
      const video = this.player;
      const hls = new Hls();
      const url = "https://bitdash-a.akamaihd.net/content/sintel/hls/playlist.m3u8";
 
      hls.loadSource(url);
      hls.attachMedia(video);
      hls.on(Hls.Events.MANIFEST_PARSED, function() { video.play(); });
  }
  render() {
    return (
          &lt;video
            className="videoCanvas"
            ref={player =&gt; (this.player = player)}
            autoPlay={true}
          /&gt;
    );
  }
}</pre>
<p>这里你可以看到我们的<code>componentDidUpdate</code>正在加载源码流，将它附加到视频播放器，并附加一个监听器来显示事件，以便知道何时播放视频。</p>
<p>HLS.js的完整文档，以及回放期间可以触发的许多事件，可以在<a href="https://github.com/video-dev/hls.js/blob/master/docs/API.md" target="_blank" rel="noopener noreferrer">这里</a>找到。</p>
<h3>DASH.js</h3>
<p>DASH.js由DASH行业论坛创建，旨在设计一个视频播放器框架，允许开发人员使用日益流行的MPEG-DASH格式构建视频播放器，这种格式与浏览器无关，并且在生产环境中非常健壮。</p>
<p>实现DASH.js视频播放器框架的第一步是将该库导入到您的项目中，最新的库可以在<a href="https://cdn.dashjs.org/latest/dash.all.min.js" target="_blank" rel="noopener noreferrer">这里</a>找到。</p>
<p>和我们的其他玩家一样，你需要创建你的<code>&lt;video&gt;</code>标签并把它放在你的渲染函数中。这就是DASH.js渲染视频的目标。</p>
<p>我们将再次给video标签一个引用<code>this.player</code>,这样我们稍后可以用它来初始化DASH.js:</p>
<pre>import React from "react";
import * as dashjs from "dash.js";
export default class VideoPlayer extends React.Component {
  state = {};
  render() {
    return (
          &lt;video
            ref={player =&gt; (this.player = player)}
            autoPlay={true} 
          /&gt;
    );
  }
}</pre>
<p>实现播放的最后一步是在<code>componentDidUpdate</code>上实例化您的播放器，并提供您的目标URL:</p>
<pre>import React from "react";
import * as dashjs from "dash.js";
export default class VideoPlayer extends React.Component {
  state = {};
  componentDidUpdate() {
      const url = "https://dash.akamaized.net/envivio/EnvivioDash3/manifest.mpd";
      const video = this.player;
      const dashjs = dashjs.MediaPlayer().create();
      dashjs.initialize(video, url, true);
  }
  render() {
    return (
          &lt;video 
            ref={player =&gt; (this.player = player)}
            autoPlay={true} 
          /&gt;
    );
  }
}</pre>
<p>此时，您应该会看到一些视频回放！DASH.js有许多可用的设置、事件和定制选项，可以在它们的文档中找到<a href="http://cdn.dashjs.org/latest/jsdoc/index.html" target="_blank" rel="noopener noreferrer">。</a></p>
<h2>结论</h2>
<p>在这篇文章中，我们已经了解了视频播放的基本知识，以及一旦用户点击播放按钮，在幕后会发生什么。我们已经讨论了三种最流行的ABS格式以及每种格式的应用。</p>
<p>最后，在介绍React中的各种实现之前，我们回顾了一些流行的Javascript视频播放器框架。</p>
<p>随着视频成为绝大多数互联网用户的头号信息消费方式，现在是开始探索视频播放精彩世界的最佳时机。</p>
<p>我希望这篇文章能让你下次在你最喜欢的流媒体服务上看到那个缓冲图标时有所思考，并激发你开始使用React中的一个视频播放器框架创建自己的视频播放器。</p>
<p>对于进一步的阅读，我推荐<a href="https://bitmovin.com/adaptive-streaming/" target="_blank" rel="noopener noreferrer"> Bitmovins关于自适应比特率流的文章</a>，该文章深入探讨了ABS如何适应客户端的网络条件。</p><div class="code-block code-block-17">
<div class="blog-plug inline-plug react-plug" vwo-el-id="26283398190">
<h2 vwo-el-id="41600691720"><a href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener"> LogRocket </a>:全面了解您的生产React应用</h2><p>调试React应用程序可能很困难，尤其是当用户遇到难以重现的问题时。如果您对监视和跟踪Redux状态、自动显示JavaScript错误以及跟踪缓慢的网络请求和组件加载时间感兴趣，</p><a href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" vwo-el-id="19356441070">try LogRocket</a><p>. </p><a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="19356441380">
<img class="first-react-image alignnone size-full wp-image-46 jetpack-lazy-image jetpack-lazy-image--handled" src="../Images/f300c244a1a1cf916df8b4cb02bec6c6.png" vwo-el-id="18272717540" data-lazy-loaded="1" data-original-src="https://files.readme.io/27c94e7-Image_2017-06-05_at_9.46.04_PM.png"/>
</a>
<a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="19356441690">
<img class="second-react-image alignnone size-full wp-image-46 jetpack-lazy-image jetpack-lazy-image--handled" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" vwo-el-id="30720362350" data-lazy-loaded="1" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/>
</a>
<p vwo-el-id="28675660440" class="">LogRocket 结合了会话回放、产品分析和错误跟踪，使软件团队能够创建理想的web和移动产品体验。这对你来说意味着什么？</p>
<p>LogRocket不是猜测错误发生的原因，也不是要求用户提供截图和日志转储，而是让您回放问题，就像它们发生在您自己的浏览器中一样，以快速了解哪里出错了。</p>
<p>不再有嘈杂的警报。智能错误跟踪允许您对问题进行分类，然后从中学习。获得有影响的用户问题的通知，而不是误报。警报越少，有用的信号越多。</p>
<p vwo-el-id="28675660750">LogRocket Redux中间件包为您的用户会话增加了一层额外的可见性。LogRocket记录Redux存储中的所有操作和状态。</p>
<p vwo-el-id="28675661060">现代化您调试React应用的方式— <a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="40093418840">开始免费监控</a>。</p>
</div></div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
<html>
<head>
<title>What’s new in Vuex 4 - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>Vuex 4 - LogRocket博客中的新内容</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/whats-new-in-vuex-4/#0001-01-01">https://blog.logrocket.com/whats-new-in-vuex-4/#0001-01-01</a></blockquote><div><article class="article-post">
<h2>介绍</h2>
<p>多年来，前端应用程序变得越来越复杂和分层。随着越来越多的数据在前端处理，最大的挑战可能是管理客户端应用程序可能处于的各种复杂状态。这就是为什么状态管理可能是构建健壮的前端应用程序中最关键的挑战。</p>
<p>在过去几年中，Redux、MobX和Vuex已经成为JavaScript生态系统中最流行的状态管理库。尽管Redux可能是其中最受欢迎的，但Vuex已经巩固了其作为基于Vue.js构建的web应用程序的事实上的状态管理库的地位，这主要是因为它相对简单并且与Vue集成。</p>
<h2>为什么是Vuex？</h2>
<p>Redux和Vuex的灵感都来自于<a href="https://facebook.github.io/flux/"> Flux </a>架构。然而，主要的区别在于它们如何处理状态。在更受React开发者欢迎的Redux中，状态是绝对不可变的；有了Vuex，您就有了更容易理解、更简洁、更直观的特定变异规则。</p>
<p>Vue组件从Vuex存储中获取它们的状态，它本质上是一个对象，但是具有与普通JavaScript对象不同的特征:它们是反应性的，您不能直接改变存储的状态。改变存储状态的唯一方法是显式提交<a href="https://vuex.vuejs.org/guide/mutations.html">突变</a>。</p>
<h2>有什么新鲜事吗？</h2>
<p>Vuex经历了相当多的迭代才达到目前的状态。在本文中，我们将关注VueX最新版本<code>v4.0.0-beta</code>中的新特性。</p>
<p>版本4的主要目标是支持Vue 3中引入的新的<a href="https://composition-api.vuejs.org/">组合API </a>和<a href="https://github.com/vuejs/roadmap#vuex-4x">简化Vuex </a>的整体使用。它还旨在为TypeScript支持更健壮的推理。我们将通过几个例子详细探讨每一个问题。</p>
<h3>重大变化</h3>
<p>截至发稿时，<code><a href="https://github.com/vuejs/vuex/releases/tag/v4.0.0-beta.1"><span class="__cf_email__" data-cfemail="dc8aa9b9849caae8f2ecf2ecbeb9a8bd">[email protected]</span></a></code>刚刚发布。主要的突破性变化之一是在Vue组件中删除了<code>this.$store</code>的全局类型。该功能的目的是使typescript用户能够在组件中编写完整的类型层。因此，开发人员可以进行手动声明，实现完全类型化的结构，这在Vuex 3中几乎是不可能的。</p>
<p>综上所述，根据<a href="https://github.com/vuejs/vuex/releases/tag/v4.0.0-beta.1">发布说明</a>:</p>
<blockquote><p>使用TypeScript时，必须提供自己的增强声明。</p></blockquote>
<p>以下是上述发行说明中提供的示例:</p>
<pre>// vuex-shim.d.ts
declare module "@vue/runtime-core" {
  // Declare your own store states.
  interface State {
    count: number
  }
  interface ComponentCustomProperties {
    $store: Store&lt;State&gt;;
  }
}</pre>
<p>接下来，我们将对此进行更深入的探讨。</p>
<h3>状态</h3>
<p>商店的定义通常从定义<code>state</code>开始:</p>
<pre>interface Actor {
  name: string
  age: number
  }
interface State {
  loading: boolean
  data: Array&lt;Actor&gt;
}
export const state:State = {
  loading: false,
  data: [{name: 'John',age: 25}]</pre>
<p>导出状态的类型是很重要的，因为它将被用于getters、突变和动作的定义中。这里有一个附带的GitHub repo示例。</p>
<h3>突变</h3>
<p>就像在Redux和其他Flux实现中一样，将突变存储为常量是很常见的。这里的方法是将我们所有的潜在突变存储为一个<code>MutationTypes</code>枚举。</p>
<pre>// mutation-types.ts:
export enum MutationTypes {
  SET_LOADING = 'SET_LOADING',
  FETCH_ACTORS = 'FETCH_ACTORS',
  ADD_ACTOR = 'ADD_ACTOR',
  REMOVE_ACTORS = 'REMOVE_ACTOR'
}</pre>
<p>我们现在可以为我们的每个突变声明一个“契约”。这是Redux中常见的模式，类似于<code>reducers</code>。变异只是一个函数，它接受状态和一个可选的有效载荷，对状态进行变异，然后返回最新更新的状态。</p>
<p>根据我们新发现的知识，让我们为我们的突变声明一个类型。为此，我们有几个选择:更健壮的方法是使用TypeScript的<code>generic</code>对我们的突变进行分类:</p>
<pre>// mutuations.ts
import { MutationTypes } from './mutation-types'
import { State } from './state'
export type Mutations&lt;S = State&gt; = {
  \[MutationTypes.SET_LOADING\](state: S, payload: boolean): void
}</pre>
<p>目前看起来不错吧？现在让我们编写一个实现:</p>
<pre>import { MutationTree } from 'vuex'
import { MutationTypes } from './mutation-types'
import { State,Actor } from './state'
export type Mutations&lt;S = State&gt; = {
  \[MutationTypes.SET_LOADING\](state: S, payload: boolean): void,
  \[MutationTypes.REMOVE_ACTORS\](state: S, payload: Actor): Array&lt;Actor&gt;,
  \[MutationTypes.ADD_ACTOR\](state: S, payload: Actor): Array&lt;Actor&gt;,
}
export const mutations: MutationTree&lt;State&gt; &amp; Mutations = {
    \[MutationTypes.SET_LOADING\](state, payload: boolean) {
      state.loading = payload
      return state
    },
  \[MutationTypes.REMOVE_ACTORS\](state, payload: Actor) {
    state.data = [payload]
    return state.data
  },
  \[MutationTypes.ADD_ACTOR\](state, payload: Actor) {
    state.data = [payload]
    return state.data
  }
}</pre>
<p><code>mutations</code>存储所有可能实现的突变。这将最终用于建造商店。</p>
<h3>行动</h3>
<p>让我们为我们的应用程序编写一个简单的<code>action</code>。首先，让我们用一个枚举键入<code>action</code>类型:</p>
<pre>// action-types.ts
export enum ActionTypes {
  GET_ACTOR = 'GET_ACTORS',
}
```
`actions.ts`
```
import { ActionTypes } from './action-types'
export const actions: ActionTree&lt;State, State&gt; &amp; Actions = {
  async \[ActionTypes.GET_ACTORS\]({ commit }) {
   const allActors = await fetch('actorsAPI').then((actors)=&gt; commit(MutationTypes.ADD_ACTOR,actors))
   return allActors
  },
}</pre>
<h3>吸气剂</h3>
<p>Getters也可以是静态类型的。getter与mutation没有太大区别，因为它本质上是一个接收状态并对其执行计算的函数。</p>
<p>下面展示了一个例子，它将<code>state</code>作为第一个参数，并以大写形式返回<code>actor</code>名称。这可能会变得非常复杂，但它遵循相同的基本原则:</p>
<pre>// getters.ts
import { GetterTree } from 'vuex'
import { State } from './state'
export type Getters = {
  capitalizeName(state: State): string[]
}
export const getters: GetterTree&lt;State, State&gt; &amp; Getters = {
  capitalizeName: (state) =&gt; {
    return state.data.map(actor =&gt; actor.name.toUpperCase())
  },
}</pre>
<h3>全局<code>$store</code>类型</h3>
<p>如前所述，您现在必须显式地键入您的存储，以便在您的组件中访问它们。所以所有默认的Vuex类型——getter、commit和dispatch——都将被我们的自定义类型所取代。</p>
<p>为了使我们定义的类型可以全局访问并正确工作，我们需要将它们传递给Vue，就像这样:</p>
<pre>// vuex-shim.d.ts
import {State} from '../state'
declare module "@vue/runtime-core" {
    // Declare your own store states.
    interface State {
      count: number
    }

    interface ComponentCustomProperties {
      $store: Store&lt;State&gt;;
    }
  }</pre>
<h2>组件中的用法</h2>
<p>现在我们有了一个类型化的存储，让我们在一个组件中利用它来巩固概念。我们将会看到在组件中使用组合API语法，因为这是Vue的主要变化，也是Vuex 4的核心目的之一。</p>
<h3>组合API</h3>
<p>我们必须用组合API通过<code>useStore</code>钩子访问商店。<code>useStore</code>钩子实质上返回了我们的<code>store</code>:</p>
<pre>export function useStore() {
  return store as Store
}


&lt;script lang="ts"&gt;
import { defineComponent, computed, h } from 'vue'
import { useStore } from '../store'
import { MutationTypes } from '../store/mutation-types'
import { ActionTypes } from '../store/action-types'
export default defineComponent({
  name: 'CompositionAPIComponent',
  setup(props, context) {
    const store = useStore()
    const actors = computed(() =&gt; store.state.data)
    const capitalizeActors = computed(() =&gt; store.getters.capitalizeName)
    async  function removeActor() {
      store.commit(MutationTypes.REMOVE_ACTORS,  {name: 'John',age: 67})
    }

    async function addActor() {
      const result = await store.dispatch(ActionTypes.GET_ACTORS, {name: 'John',age: 67})
      return result
    }
    return () =&gt;
      h('section', undefined, [
        h('h2', undefined, 'Composition API Component'),
        h('p', undefined, actors.value.toString()),
        h('button', { type: 'button', onClick: addActor }, 'Add Actor'),
             h('button', { type: 'button', onClick: removeActor}, 'Remove Actor'),
      ])
  },
})
&lt;/script&gt;</pre>
<p>我们得到的是一个完全静态类型的存储。我们只能用适当的有效载荷提交/分派声明的突变/动作；否则，我们会得到一个错误。</p>
<p>这对于静态分析来说非常棒，对于自文档化代码来说非常好。如果您试图发送一个格式错误的有效负载或一个未启动的操作，那么TypeScript编译器会对您大喊大叫，并引导您纠正错误。太棒了，不是吗？</p>
<h2>结论</h2>
<p>我们已经了解了Vuex 4的新增功能和即将推出的功能。在撰写本文时，<code><a href="https://github.com/vuejs/vuex/releases/tag/v4.0.0-beta.1">v4.0.0-beta.1</a></code>是Vuex 4的唯一一个版本，它的主要特性发布具有突破性的变化，也就是说，为商店提供了健壮的类型，并与Vue 3中的复合API进行了出色的集成。</p>
<p><code>v4.0.0-beta.3</code>还附带了一个主要特性:<code>createLogger</code>函数是从<code>Vuex/dist/logger</code>中导出的，但是它现在包含在核心包中。您应该直接从Vuex包中导入函数。这是一个需要注意的小而重要的特征。</p>
<p>必须记住，Vuex 4仍处于测试阶段，因此被标记为预发布，这意味着我们可以期待更多尚未完全实现或发布的令人兴奋的变化。这些包括去掉<code>mapXXX</code>和消除分离动作和突变的需要。</p>
<p>作为Vue和Vuex的粉丝和用户，这是一个激动人心的时刻。请关注Vuex 4的正式发布，它包含了所有令人惊叹的新特性——我特别喜欢增强的静态类型。再一次<a href="https://github.com/olajohn-ajiboye/vuex4">这里是附带的GitHub repo </a>的代码示例。</p><div class="code-block code-block-20">
<div class="blog-plug inline-plug vue-inline"><h2>像用户一样体验您的Vue应用</h2><p>调试Vue.js应用程序可能会很困难，尤其是当用户会话期间有几十个(如果不是几百个)突变时。如果您对监视和跟踪生产中所有用户的Vue突变感兴趣，</p><a href="https://lp.logrocket.com/blg/vue-signup" target="_blank">try LogRocket</a><p>. </p><a class="signup" href="https://lp.logrocket.com/blg/vue-signup" target="_blank" rel="noopener noreferrer"><img class="alignnone size-full wp-image-46 jetpack-lazy-image" src="../Images/0d269845910c723dd7df26adab9289cb.png" alt="LogRocket Dashboard Free Trial Banner" data-lazy-src="https://files.readme.io/00591d0-687474703a2f2f692e696d6775722e636f6d2f6a3049327856572e706e67.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://files.readme.io/00591d0-687474703a2f2f692e696d6775722e636f6d2f6a3049327856572e706e67.png"/><noscript><img data-lazy-fallback="1" class="alignnone size-full wp-image-46" src="../Images/0d269845910c723dd7df26adab9289cb.png" alt="LogRocket Dashboard Free Trial Banner" data-original-src="https://files.readme.io/00591d0-687474703a2f2f692e696d6775722e636f6d2f6a3049327856572e706e67.png"/></noscript></a><a href="https://lp.logrocket.com/blg/vue-signup" target="_blank" rel="noopener noreferrer">https://logrocket.com/signup/</a><p>LogRocket 就像是网络和移动应用程序的DVR，记录你的Vue应用程序中发生的一切，包括网络请求、JavaScript错误、性能问题等等。您可以汇总并报告问题发生时应用程序的状态，而不是猜测问题发生的原因。</p><p>LogRocket Vuex插件将Vuex突变记录到LogRocket控制台，为您提供导致错误的环境，以及出现问题时应用程序的状态。</p><p>现代化您调试Vue应用的方式- <a class="signup" href="https://lp.logrocket.com/blg/vue-signup" target="_blank" rel="noopener noreferrer">开始免费监控</a>。</p></div>


</div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
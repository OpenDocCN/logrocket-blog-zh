<html>
<head>
<title>Introduction to nanoSQL - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>nanoSQL - LogRocket博客简介</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/introduction-to-nanosql/#0001-01-01">https://blog.logrocket.com/introduction-to-nanosql/#0001-01-01</a></blockquote><div><article class="article-post">
<p>nanoSQL是一个通用的JavaScript客户端库，用于连接几个不同的数据库，包括内存数据库和永久数据库。</p>
<p>随着web应用程序变得越来越复杂，您可能会发现自己不仅仅使用一个数据库来保存和检索数据。例如，您可能在一个应用程序中同时使用MySQL和Redis。</p>
<p>当后端数据库保存和更新永久数据时，您可以使用Redis作为前端层的数据库来存储会话令牌和缓存，或者为管理仪表板或竞技游戏创建实时统计数据。MySQL等传统数据库的读/写速度太慢，无法创造现代用户期望的“即时”体验。</p>
<p>要连接到您的数据库，您需要一个数据库客户端库。如果你使用Node.js，你可以使用<a href="https://github.com/mysqljs/mysql" target="_blank" rel="noopener noreferrer"> mysqljs </a>连接到MySQL，使用<a href="https://www.npmjs.com/package/redis" target="_blank" rel="noopener noreferrer"> Redis </a>连接到Redis数据库。这意味着您需要学习两套不同的数据库客户端库，并知道如何编写正确的查询来实现您想要做的事情。</p>
<p>nanoSQL解决了这个问题。它使您能够连接和使用不同的数据库系统，而无需为您要使用的每个数据库安装专用的客户端库。它通过创建一种可以在所有类型的受支持数据库中使用的标准化查询语言来做到这一点。</p>
<p>通过使用nanoSQL，您可以并行运行几个数据库，每个数据库使用自己的适配器。您可以创建一个连接到MySQL的nanoSQL实例和另一个连接到Redis的实例。</p>
<p>另一个好处是，只要使用JavaScript，就可以在客户机、服务器或移动设备中使用nanoSQL。</p>
<h2 id="nanosqlinaction">行动中的nanoSQL</h2>
<p>让我们看看nanoSQL如何帮助我们使用相同的查询语言和API来操作本地存储和MySQL数据库。</p>
<p>我们将使用React创建一个小型表单组件，将临时用户输入保存在本地存储中。这样，当重新加载应用程序时，我们可以获取之前输入的数据。当用户点击提交时，应用程序将通过用Express构建的REST API将数据保存在MySQL的一个表中。</p>
<p>在我们开始之前，确保您的机器上安装了MySQL。最简单的方法之一是安装<a href="https://www.apachefriends.org/index.html" target="_blank" rel="noopener noreferrer"> XAMPP </a>，其中包括用于MySQL管理的phpMyAdmin。</p>
<p>一旦MySQL开始运行，就要使用Express编写REST API。这款应用的代码可以在<a href="https://github.com/nsebhastian/intro-nanosql-react" target="_blank" rel="noopener noreferrer"> GitHub </a>上找到。</p>
<h2 id="nanosqlinthebackend">后端的nanoSQL</h2>
<p>首先，使用<code>npm init</code>为您的应用程序创建一个npm包目录。您可以用自己的信息填写包裹详情。</p>
<p>接下来，在目录中安装必要的软件包。</p>
<pre>npm install express @nano-sql/core @nano-sql/adapter-mysql
</pre>
<p><code>express</code>包用于创建REST API，而<code>@nano-sql/core</code>和<code>@nano-sql/adapter-mysql</code>用于连接和操作MySQL数据库。</p>
<p>安装完成后，创建一个名为<code>server.js</code>的新文件，并开始导入所需的模块。</p>
<pre>const express = require('express');
const bodyParser = require("body-parser");
const { nSQL } = require("@nano-sql/core");
const { MySQL } = require("@nano-sql/adapter-mysql");
</pre>
<p>创建要在您的应用程序中使用的Express server实例。我们将使用<code>express.json()</code>函数，以便Express可以从传入的POST请求中识别JSON对象。</p>
<p>接下来，创建一个中间件来允许来自<code>localhost:3000</code>的CORS请求，稍后我们将把它用于React应用程序。我们还将设置Express监听本地主机端口5000上的请求。</p>
<pre>const app = express();
app.use(express.json());
app.use(function (req, res, next) {
  res.setHeader('Access-Control-Allow-Origin', 'http://localhost:3000');
  res.setHeader('Access-Control-Allow-Methods', 'GET,POST,PUT,DELETE,OPTIONS');
  res.setHeader('Access-Control-Allow-Headers', 'Content-Type, Access-Control-Allow-Headers');
  next();
});
const PORT = process.env.PORT || 5000;
app.listen(PORT, () =&gt; {
  console.log(`Listening on port ${PORT}`);
});
</pre>
<p>是时候使用nanoSQL的createDatabase函数将Express与MySQL连接起来了，该函数有三个参数:</p>
<ol>
<li><code>id</code>参数是数据库的唯一标识符</li>
<li><code>mode</code>参数用于定义数据库；您可以指定内置模式或任何一种受支持的适配器</li>
<li><code>tables</code>参数接受定义数据库的对象数组。您可以通过使用一个<code>model</code>对象来定义表格及其列的<code>name</code>，如下所示</li>
</ol>
<p>因为我们使用的是MySQL，所以我们将使用之前从适配器导入的MySQL函数。我们需要在该函数中指定我们的MySQL配置。</p>
<pre>nSQL().createDatabase({
  id: "mysql-db",
  mode: new MySQL({ 
    // specify your MySQL credentials here
    host: "localhost",
    database: "test",
    user: "root",
    password: ""
  }),
  tables: [
    {
      name: "tb_users",
      model: {
        "id:uuid": {pk: true},
        "name:string": {},
        "age:int": {},
        "role:string": {}
      }
    }
  ],
})
</pre>
<p>虽然在生产环境中不建议使用用户、主机、数据库、密码和端口等凭证，但为了简化教程，我们将把它们写在这个文件中。您可能需要在生产中使用环境变量，但这超出了本指南的范围。</p>
<p>现在，nanoSQL已经连接到我们的MySQL，我们可以创建快速路由来对数据库进行特定的操作。我们将创建三个操作数据库的简单路径:</p>
<ol>
<li><code>/get</code>用于从表中检索所有数据</li>
<li><code>/save</code>用于将新条目保存到表格中</li>
<li><code>/delete/:id</code>用于删除具有指定ID的条目</li>
</ol>
<p>首先，创建<code>/get</code>路由，从<code>tb_users</code>表中选择所有行。nanoSQL中的查询语法如下所示:</p>
<pre>nSQL("table name")
.query("query type", ...query args)
...optional filtering, etc..
.exec()
</pre>
<p>您不用在字符串中编写整个查询，而是使用函数并将它们链接在一起。这看起来非常类似于查询构建器，比如Rails的活动记录。</p>
<p>首先创建<code>/get</code>路线并查询表中的所有行。</p>
<pre>app.get('/get', (req, res) =&gt; {
  nSQL("tb_users").query("select").exec()
  .then( rows =&gt; {
    res.json(rows)
  })
});
</pre>
<p>这里是<code>/save</code>和<code>/delete/:id</code>路线的路线。我们不像在大多数SQL查询中那样使用<code>insert</code>，而是使用<code><a href="https://nanosql.io/query/upsert.html#upsert">upsert</a></code>，它可以执行插入或更新，这取决于我们在调用中定义的查询参数的数量。</p>
<pre>app.post('/save', (req, res) =&gt; {
  const { name, age, role } = req.body
  nSQL("tb_users").query("upsert", {name, age, role}).exec()
  .then(
    res.json({message: 'Data is saved!'})
  )
});

app.delete('/delete/:id', (req, res) =&gt; {
  const { id } = req.params
  nSQL("tb_users").query("delete").where(['id', '=', id]).exec()
  .then(
    res.json({message: 'User is deleted!'})
  )
});
</pre>
<p>最后，删除路径将接受一个<code>id</code>参数，并在找到具有匹配ID的行时执行删除操作。</p>
<p>将你写的代码与GitHub上的源代码进行比较。</p>
<h2 id="creatingreactforminthefrontend">在前端创建一个反应表单</h2>
<p>REST API完成后，我们可以开始编写一个使用这个API的React应用程序。</p><div class="code-block code-block-54">
<hr/>
<h3>更多来自LogRocket的精彩文章:</h3>

<hr/></div>
<p>打开项目目录中的终端，使用<code>create-react-app</code>引导React应用程序。我们将把这个应用程序命名为“客户端”</p>
<pre>npx create-react-app client
</pre>
<p>安装React应用程序后，进入目录并安装<code>axios</code>和<code>@nano-sql/core</code>。</p>
<pre>npm install axios @nano-sql/core
</pre>
<p>是时候写我们应用程序的前端了。让我们从编写新的<code>index.js</code>组件开始。</p>
<p>在该文件中呈现您的<code>App</code>组件:</p>
<pre>import React from 'react';
import ReactDOM from 'react-dom';
import App from './App';
ReactDOM.render(&lt;App /&gt;, document.getElementById('root'));
</pre>
<p>接下来，创建一个名为<code>App.js</code>的文件，导入所需的模块，并写入您的状态。</p>
<p>我们将创建一个具有四个状态属性的简单组件:</p>
<pre>import React from 'react';
import Axios from 'axios';
import {nSQL} from '@nano-sql/core';

const API_URL = 'http://localhost:5000/' // for connecting to API later

class App extends React.Component {
  state = {
    name: '',
    age: '',
    role: '',
    users: []
  }
</pre>
<p><code>name</code>、<code>age</code>和<code>role</code>属性将用于存储表单输入值，而<code>users</code>将存储稍后从Express检索的数据。</p>
<p>就在状态下面，写一个函数来检索用户数据，消费我们之前创建的<code>/get</code>路由。</p>
<pre>getMerchant = () =&gt; {
  Axios.get(`${API_URL}get`)
  .then(res =&gt; {
    this.setState({users: res.data});
  });
}
</pre>
<p>从<code>componentDidMount</code>方法调用该函数，以便组件一呈现，用户数据就被填充。</p>
<pre>componentDidMount() {
  this.getMerchant();
}
</pre>
<p>接下来，记下<code>render</code>方法。简单地使用状态属性来存储输入值(除了<code>users</code>)。我们只需要使用<code>map</code>函数来呈现<code>users</code>值。</p>
<p>就在表单下方，添加一个从MySQL数据库中删除数据的按钮。</p>
<pre>render() {
  const {name, age, role, users} = this.state
  return(
    &lt;div className='app'&gt;
      &lt;h1&gt;Auto-save form with NanoSQL for local storage and MySQL&lt;/h1&gt;
      &lt;h2&gt;Current data: &lt;/h2&gt;
      &lt;ul&gt;
      {
        users.map( user =&gt; {
          return (
           &lt;li key={user.id}&gt; {user.id} / {user.name} / {user.age} / {user.role} &lt;/li&gt;
          )
        })
      }
      &lt;/ul&gt;
      &lt;form onSubmit={this.handleSubmit}&gt;
      &lt;div&gt;
        &lt;label&gt;Name: &lt;/label&gt;
        &lt;input
          name="name"
          type="text"
          placeholder="Enter name"
          value={name}
          onChange={event =&gt; this.setState({name: event.target.value})}
          /&gt;
      &lt;/div&gt;
      &lt;div&gt;
        &lt;label&gt;Age: &lt;/label&gt;
        &lt;input
          name="age"
          type="number"
          placeholder="Enter age"
          value={age}
          onChange={event =&gt; this.setState({age: event.target.value})}
          /&gt;
      &lt;/div&gt;
      &lt;div&gt;
        &lt;label&gt;Role: &lt;/label&gt;
        &lt;input
          name="age"
          type="text"
          placeholder="Enter role"
          value={role}
          onChange={event =&gt; this.setState({role: event.target.value})}
          /&gt;
      &lt;/div&gt;
      &lt;button type='submit'&gt;Submit&lt;/button&gt;
      &lt;/form&gt;
      &lt;button onClick={this.handleDelete}&gt;Delete&lt;/button&gt;
    &lt;/div&gt;
  )
}
</pre>
<p>最后要处理的是表单提交和用户删除。</p>
<pre>handleSubmit = (e) =&gt; {
  e.preventDefault()
  const {name, age, role} = this.state
  Axios.post(`${API_URL}/save`, {
    name,
    age,
    role
  })
  .then(response =&gt; {
    alert(response.data.message)
    this.setState({
      name: '',
      age: '',
      role: ''
    })
    this.getMerchant()
  })
}

handleDelete = () =&gt; {
  let id = prompt('Enter user id');
  if (id){
    Axios.delete(`${API_URL}delete/${id}`)
    .then(response =&gt; {
      alert(response.data.message)
      this.getMerchant()
    })
  }
}
</pre>
<p>现在你的申请完成了。运行<code>npm start</code>并填写表格，尝试一下。您应该能够毫无问题地添加和删除用户数据。</p>
<h2 id="savingtemporaryuserinputintolocalstorage">将临时用户输入保存在本地存储中</h2>
<p>由于我们使用的是nanoSQL，所以让我们试着在前端使用它。我们将在浏览器的本地存储数据库中保存表单的状态属性— <code>name</code>、<code>age</code>和<code>role</code>。当我们关闭应用程序并再次打开它时，我们的应用程序将从本地存储中检索状态值。</p>
<p>回到我们之前写的<code>componentDidMount</code>方法，添加下面的代码。</p>
<pre>componentDidMount() {
  this.getMerchant()

  nSQL().createDatabase({
    id: "ls-db",
    mode: "LS",
    tables: [
      {
        name: "tb_temp",
        model: {
            "id:uuid": {pk: true},
            "data:string": {},
            "form:string": {}
        }
      }
    ]
  }).then(() =&gt; {
    nSQL("tb_temp").query("select").where(['form', '=', 'user']).exec().then((row) =&gt; {
      console.log(row)
      if(row.length){
        console.log('update state')
        const data = JSON.parse(row[0].data)
        this.setState({
          name: data.name,
          age: data.age,
          role: data.role
        })
      } else {
        const {name, age, role} = this.state
        nSQL("tb_temp")
        .query("upsert",{data: JSON.stringify({name, age, role}), form: 'user'})
        .exec()      
      }
    })
  })
}
</pre>
<p>如果上面的代码看起来很熟悉，那是因为你以前写过它。我们正在执行与MySQL相同的<code>createDatabase</code>功能。该表有三列:</p>
<ol>
<li><code>id</code>作为表的主键</li>
<li><code>data</code>存储格式为JSON字符串的表单值</li>
<li><code>form</code>作为数据的唯一标识符，这在应用程序中有多个表单时非常有用</li>
</ol>
<p>连接到数据库后，查询表中具有指定的<code>form</code>值的任何行。当找到一行时，将它放入状态。如果没有数据，只需插入一个带有<code>user</code> <code>form</code>的新行，但是带有<code>data</code>列的初始状态值。您需要此行，以便以后用户在表单中键入内容时可以更新它。</p>
<p>最后一步是在状态改变时更新本地存储行。您可以使用<code>componentDidUpdate</code>方法来实现。</p>
<pre>componentDidUpdate() {
  const {name, age, role} = this.state
  nSQL("tb_temp")
  .query("upsert",{data: JSON.stringify({name, age, role})})
  .where(['form', '=', 'user'])
  .exec().then(
    console.log('Data updated')
  )
}
</pre>
<p>当组件由于状态改变而更新时，我们将检索状态属性并用它更新<code>data</code>列。这就是我们需要做的！</p>
<p>现在打开React应用程序，在表单中输入一些内容。关闭应用程序，然后再次打开。您将看到您在表单中输入的值仍然存在，等待您提交。</p>
<h2 id="conclusion">结论</h2>
<p>随着您的web应用程序变得越来越复杂，总有一天您需要利用不止一个数据库系统。为了给用户创造无缝体验，您可能需要同时使用前端和后端存储系统，这意味着您需要学习如何高效地操作它们。</p>
<p>nanoSQL通过启用标准化的查询语言来帮助您减少开发时间，以便您可以在不同的数据库系统上使用相同的API。</p>
<p>即使它的名字中有“SQL ”, nanoSQL也支持noSQL数据库，如MongoDB和ScyllaDB。这意味着当您将这些数据库添加到您的架构中时，您不需要学习新的查询语言。在不同的数据库之间跳转是一件小事。</p>
<p>您甚至可以将自己的查询功能添加到nanoSQL中。如果你正在用多数据库架构开发软件，一定要查看一下<a href="https://nanosql.io/setup.html" target="_blank" rel="noopener noreferrer"> nanoSQL文档</a>，看看它是否适合你。</p><div class="code-block code-block-17">
<div class="blog-plug inline-plug react-plug" vwo-el-id="26283398190">
<h2 vwo-el-id="41600691720">使用LogRocket消除传统反应错误报告的噪音</h2>
<a href="https://lp.logrocket.com/blg/react-signup-issue-free" target="_blank" vwo-el-id="19356441070">LogRocket
</a><p>是一款React analytics解决方案，可保护您免受数百个误报错误警报的影响，只针对少数真正重要的项目。LogRocket告诉您React应用程序中实际影响用户的最具影响力的bug和UX问题。</p><a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="19356441380">
<img class="first-react-image alignnone size-full wp-image-46 jetpack-lazy-image jetpack-lazy-image--handled" src="../Images/f300c244a1a1cf916df8b4cb02bec6c6.png" vwo-el-id="18272717540" data-lazy-loaded="1" data-original-src="https://files.readme.io/27c94e7-Image_2017-06-05_at_9.46.04_PM.png"/>
</a>
<a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="19356441690">
<img class="second-react-image alignnone size-full wp-image-46 jetpack-lazy-image jetpack-lazy-image--handled" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" vwo-el-id="30720362350" data-lazy-loaded="1" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/>
</a>
<a href="https://lp.logrocket.com/blg/react-signup-issue-free" target="_blank" rel="noopener noreferrer" vwo-el-id="35866400580">LogRocket
</a><p>自动聚合客户端错误、反应错误边界、还原状态、缓慢的组件加载时间、JS异常、前端性能指标和用户交互。然后，LogRocket使用机器学习来通知您影响大多数用户的最具影响力的问题，并提供您修复它所需的上下文。</p><p vwo-el-id="28675661060">关注重要的React bug—<a class="signup" href="https://lp.logrocket.com/blg/react-signup-issue-free" target="_blank" rel="noopener noreferrer" vwo-el-id="40093418840">今天就试试LogRocket】。</a></p><div class="code-block code-block-27">
<div class="blog-plug inline-plug vanilla-javascript-cta"><h2>通过理解上下文，更容易地调试JavaScript错误</h2>
<p>调试代码总是一项单调乏味的任务。但是你越了解自己的错误，就越容易改正。</p>
<p>LogRocket 让你以新的独特的方式理解这些错误。我们的前端监控解决方案跟踪用户与您的JavaScript前端的互动，让您能够准确找出导致错误的用户行为。</p>
<a href="https://lp.logrocket.com/blg/javascript-signup" class="signup" target="_blank" rel="noopener noreferrer"><img class="alignnone size-full wp-image-46 jetpack-lazy-image" src="../Images/cbfed9be3defcb505e662574769a7636.png" alt="LogRocket Dashboard Free Trial Banner" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2020/06/reproduce-javascript-errors.gif?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/06/reproduce-javascript-errors.gif"/><noscript><img data-lazy-fallback="1" class="alignnone size-full wp-image-46" src="../Images/cbfed9be3defcb505e662574769a7636.png" alt="LogRocket Dashboard Free Trial Banner" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/06/reproduce-javascript-errors.gif"/></noscript></a>
<p>LogRocket记录控制台日志、页面加载时间、堆栈跟踪、慢速网络请求/响应(带有标题+正文)、浏览器元数据和自定义日志。理解您的JavaScript代码的影响从来没有这么简单过！</p>
<a class="signup" href="https://lp.logrocket.com/blg/javascript-signup" target="_blank" rel="noopener noreferrer">Try it for free</a><p>.</p></div>


</div>
</div></div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
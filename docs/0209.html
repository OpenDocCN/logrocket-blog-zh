<html>
<head>
<title>Animating Route Transitions with React Router - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>用React Router - LogRocket博客制作路由转换动画</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/routes-animation-transitions-in-react-router-v4-9f4788deb964/#0001-01-01">https://blog.logrocket.com/routes-animation-transitions-in-react-router-v4-9f4788deb964/#0001-01-01</a></blockquote><div><article class="article-post">
<figure><img decoding="async" src="../Images/03c7e1744aab90117de4bbc3c7578845.png" data-height="957" data-width="4854" data-lazy-src="https://storage.googleapis.com/blog-images-backup/1*ljaxlLQFJ60zohYGCj9cCA.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" class=" jetpack-lazy-image" data-original-src="https://storage.googleapis.com/blog-images-backup/1*ljaxlLQFJ60zohYGCj9cCA.png"/><noscript><img data-lazy-fallback="1" decoding="async" src="../Images/03c7e1744aab90117de4bbc3c7578845.png" data-height="957" data-width="4854" data-original-src="https://storage.googleapis.com/blog-images-backup/1*ljaxlLQFJ60zohYGCj9cCA.png"/></noscript></figure>
<p>React Router v4为构建支持导航的React应用程序提供了直观的声明式API。然而，在构建需要运动的ui时，文档、堆栈溢出或博客中并没有多少解释如何在路线之间设置动画。</p>
<p>在本文中，我们将使用新的React路由器(v4)创建一个React应用程序，并在视图之间导航时添加一些动画。在本教程的最后，你将看到如何使用高阶组件(HOC)来用React的<code>CSSTransitionGroup</code>插件组成你的组件。</p>
<p>这是我们将构建的应用程序的预览:</p>
<figure><img decoding="async" src="../Images/e54f48dd999a1cc31ea73a091e859922.png" data-height="620" data-width="1084" data-lazy-src="https://storage.googleapis.com/blog-images-backup/1*5jLshPl8aw3-TNF1yzPaMQ.gif?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" class=" jetpack-lazy-image" data-original-src="https://storage.googleapis.com/blog-images-backup/1*5jLshPl8aw3-TNF1yzPaMQ.gif"/><noscript><img data-lazy-fallback="1" decoding="async" src="../Images/e54f48dd999a1cc31ea73a091e859922.png" data-height="620" data-width="1084" data-original-src="https://storage.googleapis.com/blog-images-backup/1*5jLshPl8aw3-TNF1yzPaMQ.gif"/></noscript></figure>
<figure><a href="https://logrocket.com/signup/" target="_blank" rel="noopener noreferrer"><img decoding="async" src="../Images/94b3e0f84b30cb0d321f60471481ab64.png" data-height="750" data-width="3212" data-lazy-src="https://storage.googleapis.com/blog-images-backup/1*GPjaPKNNUYHU8EsA3Z0JGA.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" class=" jetpack-lazy-image" data-original-src="https://storage.googleapis.com/blog-images-backup/1*GPjaPKNNUYHU8EsA3Z0JGA.png"/><noscript><img data-lazy-fallback="1" decoding="async" src="../Images/94b3e0f84b30cb0d321f60471481ab64.png" data-height="750" data-width="3212" data-original-src="https://storage.googleapis.com/blog-images-backup/1*GPjaPKNNUYHU8EsA3Z0JGA.png"/></noscript></a></figure>
<h3>创建新的React项目</h3>
<p>本文的所有例子都可以在Codesandbox.io中找到，但是在一个真实的项目中，你至少需要用<code>create-react-app</code>来设置一个项目。让我们安装这个工具并设置一个新项目:</p>
<pre># Install globally
npm install -g create-react-app

#Create a new project
create-react-app router-animations</pre>
<p>您需要再安装两个依赖项；react路由器和CSS过渡插件:</p>
<pre>yarn add react-router-dom react-addons-css-transition-group</pre>
<p>注意，与之前版本的React路由器不同，我们安装的是<code>react-router-dom</code>而不是<code>react-router</code>。React路由器的v4是独立于平台的，这就是为什么我们要安装依赖于<code>react-router</code>包本身的<code>react-router-dom</code>，并在安装过程中拉动它。</p>
<p>只是为了有一个不那么无聊的用户界面，复制替换的内容<code>index.css</code>和<code>logo.svg</code>分别找到<a href="https://github.com/christiannwamba/react-router-transition/blob/master/src/index.css" target="_blank" rel="noopener noreferrer">这里</a>和<a href="https://github.com/christiannwamba/react-router-transition/blob/master/src/logo.svg" target="_blank" rel="noopener noreferrer">这里</a>。</p>
<h3>创建寻呼路由</h3>
<p>我们都准备好开始添加路线了。在src目录中创建一个pages文件夹。这是将添加解析为路由页面的组件的地方。</p>
<p>只有两页:</p>
<ol>
<li><strong>订阅页面</strong>:假想邮件订阅页面</li>
<li><strong>感谢页面</strong>:邮件订阅后显示的感谢页面</li>
</ol>
<p>让我们从订阅页面开始:</p>
<p/>
<p>接下来，还要添加感谢页面:</p>
<p/>
<p>除了组件中明显的文本，它们还有一个共同点——<code>SubscribeForm</code>。这是一个UI组件，只显示订阅表单。</p>
<p>让我们也创建它:</p>
<p>如果没有定义<code>thanks</code>属性，组件将呈现一个文本输入和一个订阅按钮。该属性仅在<code>ThankYou</code>页面的<code>SubscribeForm</code>组件上定义。如果它被定义了，组件只呈现一个按钮，上面写着“再试一次”。</p>
<p>根据查看的页面，按钮应该在被点击时使用<code>history.push()</code>方法将我们带到另一个页面。</p>
<p>配置路由和浏览器路由器</p>
<h3>设置好要呈现的页面后，让我们定义它们的路径以及它们应该呈现到的路径。用以下内容更新您的<code>App</code>组件:</h3>
<p>With the pages set to be rendered, let’s define their routes and what paths they should be rendered to. Update your <code>App</code> component with the following:</p>
<p>上面的组件是这样的:</p>
<p>使用我们导入的<code>react-router-dom</code>库中的<code>Route</code>配置路由。</p>
<ul>
<li><code>Route</code>只是一个组件，它接收像<code>path</code>这样的属性来指定组件将被安装在什么位置。它还接收<code>component</code>，这是当指定路径匹配时应该安装的组件</li>
<li>现在，为了让路由器实际上与React一起工作，我们需要用<code>BrowserRouter</code>组件包装<code>App</code>组件:</li>
</ul>
<p>我们在这里所做的唯一改变是我们导入了<code>BrowserRouter</code>并将其别名为<code>Router</code>(只是为了简洁)，然后我们用<code>Router</code>包装了<code>App</code>组件:</p>
<pre>// ./src/index.js

import React from 'react';
import ReactDOM from 'react-dom';
import { BrowserRouter as Router } from 'react-router-dom';
import './index.css';
import App from './App';
import registerServiceWorker from './registerServiceWorker';

ReactDOM.render(
  &lt;Router&gt;
    &lt;App /&gt;
  &lt;/Router&gt;, 
  document.getElementById('root')
);
registerServiceWorker();</pre>
<p>打开应用程序时，屏幕上应该会有一些导航:</p>
<pre>&lt;Router&gt;
  &lt;App /&gt;
&lt;/Router&gt;</pre>
<p>为web应用程序定制的在线代码编辑器</p>
<blockquote class="embedly-card" data-card-controls="1" data-card-align="center" data-card-theme="light">

<p>高阶组件</p>
</blockquote>
<p>高阶组件(HOC)允许您扩展React组件。它们基本上是接受一个组件并返回一个组件的函数。就这么简单。</p>
<figure/>
<h3>当两个组件共享相同的特性导致逻辑重复时，它们就变得很方便。例如，作为组件订阅页面可能有一个徽标和一个白色背景。与感谢页面相同。为了给两个组件都添加一个徽标和一个白色背景，我们需要在两个组件类中都编写这个特性。相反，我们可以做的是使用一个实现共享特性的特设，并使用Subscribe或Thank You调用特设。</h3>
<p>举个例子会更有意义。在组件目录中创建一个名为<code>PageShell</code>的组件:</p>
<p>组件是一个函数，它被设计成接收一个组件(页面)作为参数。</p>
<p>它用一些花哨的DOM内容[1]包装接收到的组件并返回，传入它的props[2]并将组件作为函数返回。</p>
<pre>// ./src/components/PageShell.js

import React from 'react';
import logo from '../logo.svg';

const PageShell = Page =&gt; { 
  return props =&gt; {/* [1]*/}
    &lt;div className="page"&gt;
        &lt;img src={logo} alt="" /&gt;
        &lt;Page {...props} /&gt; {/* [2]*/}
    &lt;/div&gt;;
};

export default PageShell;</pre>
<ul>
<li>期望是<code>PageShell</code>会这样用:<code>PageShell(PageComponent)</code></li>
<li>现在让我们用<code>PageShell</code>包装<code>App</code>中的页面组件:</li>
<li>The expectation is that <code>PageShell</code> will be used like this: <code>PageShell(PageComponent)</code></li>
</ul>
<p>唯一的区别是，在将<code>Subscribe</code>和<code>ThankYou</code>传递给<code>component</code>属性之前，我们首先将其包装在<code>PageShell</code>中，从而得到这个新的外观:</p>
<p>为web应用程序定制的在线代码编辑器</p>
<p>临时转换</p>
<blockquote class="embedly-card" data-card-controls="1" data-card-align="center" data-card-theme="light">

<p>为了实现转换，每个组件都需要用<code>ReactCSSTransitionGroup</code>包装。</p>
</blockquote>
<p>更多来自LogRocket的精彩文章:</p>
<figure/>
<h3><code>transitionName</code>映射到一个CSS类，它定义了动画的每个阶段发生的事情。下面是来自<code>index.css</code>的一小段删节片段:</h3>
<p><code>ReactCSSTransitionGroup</code>映射到每个阶段(出现、进入和离开),并应用CSS类定义上可用的任何过渡效果。你可以在动画附加软件的<a href="https://facebook.github.io/react/docs/animation.html" target="_blank" rel="noopener noreferrer"> React文档中了解更多信息。</a></p><div class="code-block code-block-54">
<hr/>
<h3>如果我们正在构建一个大型的应用程序，当你试图用<code>ReactCSSTransitionGroup</code>包装这些组件时，你将会被重复的代码弄得一团糟。有了HOC，你可以在页面外壳中使用一次<code>ReactCSSTransitionGroup</code>，用页面外壳包装每个需要<code>ReactCSSTransitionGroup</code>的组件:</h3>

<hr/></div>
<pre>&lt;ReactCSSTransitionGroup
        transitionAppear={true}
        transitionAppearTimeout={600}
        transitionEnterTimeout={600}
        transitionLeaveTimeout={200}
        transitionName="SlideIn"
      &gt; 
        &lt;Page /&gt;
&lt;/ReactCSSTransitionGroup&gt;</pre>
<p>The <code>transitionName</code> maps to a CSS class that defines what happens at every phase of the animation. Here is a small and truncated snippet from <code>index.css</code>:</p>
<pre>.SlideIn-appear {
  transform: translateX(30px);
  opacity: 0;
}
.SlideIn-appear.SlideIn-appear-active {
  opacity: 1;
  transform: translateX(0);;
  transition: all 0.6s linear;
}
.SlideIn-enter {
    opacity: 0;
    transform: translateX(30px);
}
.SlideIn-enter.SlideIn-enter-active {
    opacity: 1;
    transform: translateX(0);
    transition: all 0.2s linear 0.4s;
}
.SlideIn-leave {
    opacity: 1.0;
    transform: translateX(0);
}
.SlideIn-leave.SlideIn-leave-active {
    opacity: 0;
    position: absolute;
    width: 100%;
    transform: translateX(-30px);
    transition: all 0.2s linear;
}</pre>
<p>这就是在您的路线上开始转场所需要的一切:</p>
<p>为web应用程序定制的在线代码编辑器</p>
<p>资源</p>
<p><a href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener"> LogRocket </a>:全面了解您的生产React应用</p>
<blockquote class="embedly-card" data-card-controls="1" data-card-align="center" data-card-theme="light">

<p>调试React应用程序可能很困难，尤其是当用户遇到难以重现的问题时。如果您对监视和跟踪Redux状态、自动显示JavaScript错误以及跟踪缓慢的网络请求和组件加载时间感兴趣，</p>
</blockquote>
<p>. </p>
<figure/>
<h4>LogRocket 结合了会话回放、产品分析和错误跟踪，使软件团队能够创建理想的web和移动产品体验。这对你来说意味着什么？</h4>

<p>LogRocket不是猜测错误发生的原因，也不是要求用户提供截图和日志转储，而是让您回放问题，就像它们发生在您自己的浏览器中一样，以快速了解哪里出错了。</p><div class="code-block code-block-17">
<div class="blog-plug inline-plug react-plug" vwo-el-id="26283398190">
<h2 vwo-el-id="41600691720">不再有嘈杂的警报。智能错误跟踪允许您对问题进行分类，然后从中学习。获得有影响的用户问题的通知，而不是误报。警报越少，有用的信号越多。</h2><p>LogRocket Redux中间件包为您的用户会话增加了一层额外的可见性。LogRocket记录Redux存储中的所有操作和状态。</p><a href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" vwo-el-id="19356441070">try LogRocket</a><p>现代化您调试React应用的方式— <a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="40093418840">开始免费监控</a>。</p><a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="19356441380">
<img class="first-react-image alignnone size-full wp-image-46 jetpack-lazy-image jetpack-lazy-image--handled" src="../Images/f300c244a1a1cf916df8b4cb02bec6c6.png" vwo-el-id="18272717540" data-lazy-loaded="1" data-original-src="https://files.readme.io/27c94e7-Image_2017-06-05_at_9.46.04_PM.png"/>
</a>
<a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="19356441690">
<img class="second-react-image alignnone size-full wp-image-46 jetpack-lazy-image jetpack-lazy-image--handled" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" vwo-el-id="30720362350" data-lazy-loaded="1" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/>
</a>
<p vwo-el-id="28675660440" class="">
<a href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="35866400580">LogRocket
</a> combines session replay, product analytics, and error tracking – empowering software teams to create the ideal web and mobile product experience. What does that mean for you?
</p>
<p> Instead of guessing why errors happen, or asking users for screenshots and log dumps, LogRocket lets you replay problems as if they happened in your own browser to quickly understand what went wrong.
</p>
<p> No more noisy alerting. Smart error tracking lets you triage and categorize issues, then learns from this. Get notified of impactful user issues, not false positives. Less alerts, way more useful signal.
</p>
<p vwo-el-id="28675660750">The LogRocket Redux middleware package adds an extra layer of visibility into your user sessions. LogRocket logs all actions and state from your Redux stores.
</p>
<p vwo-el-id="28675661060">Modernize how you debug your React apps —
<a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="40093418840">start monitoring for free</a>.
</p>
</div></div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
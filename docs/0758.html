<html>
<head>
<title>Comparing hooks libraries for GraphQL - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>比较GraphQL - LogRocket博客的钩子库</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/comparing-hooks-libraries-for-graphql/#0001-01-01">https://blog.logrocket.com/comparing-hooks-libraries-for-graphql/#0001-01-01</a></blockquote><div><article class="article-post">
<p>React挂钩是有状态函数，用于维护功能组件中的状态。基本上，它们通过将复杂的React组件分解成更小的功能块来实现。</p>
<p>React类组件的主要问题是需要维护大量的抽象，比如高阶组件(hoc)和渲染道具。React钩子将逻辑作为一个函数来维护，不需要封装它。</p>
<p>看看下面的例子。</p>
<blockquote class="embedly-card" data-card-controls="1" data-card-align="center" data-card-theme="light">

<p>LucaColonnello使用react、react-dom、react-scripts编写的类与React挂钩</p>
</blockquote>
<p/>
<p>GraphQL是一种数据查询语言，它只获取自己需要的数据，而不是从API获取所有数据。它有两个操作:<a href="https://blog.logrocket.com/graphql-queries-in-simple-terms/" target="_blank" rel="noopener noreferrer">查询</a>和<a href="https://blog.logrocket.com/robust-graphql-mutations-the-relay-way/">突变</a>。对于实时数据，GraphQL使用了一个叫做<a href="https://blog.logrocket.com/graphql-subscriptions-with-node-js/" target="_blank" rel="noopener noreferrer">订阅</a>的概念。</p>
<p>有两大React钩子库:<code><a href="https://github.com/nearform/graphql-hooks" target="_blank" rel="noopener noreferrer">graphql-hooks</a></code>和<code><a href="https://www.apollographql.com/docs/react/api/react-hooks/" target="_blank" rel="noopener noreferrer">apollo/react-hooks</a></code>。为了帮助您确定哪个库最适合您的下一个GraphQL项目，让我们比较它们，检查它们的特性，并权衡利弊。</p>
<h2 id="projectscenario">项目场景</h2>
<p>我们将快速启动一个项目，以方便我们进行比较。让我们实现一个聊天应用程序，使用户能够登录并发送群发消息。</p>
<p><img data-attachment-id="15985" data-permalink="https://blog.logrocket.com/comparing-hooks-libraries-for-graphql/attachment/chat-app-built-with-graphql-hooks-2/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/03/chat-app-built-with-graphql-hooks-1.gif" data-orig-size="720,450" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Chat app built with GraphQL Hooks" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/03/chat-app-built-with-graphql-hooks-1-300x188.gif" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/03/chat-app-built-with-graphql-hooks-1.gif" decoding="async" class="aligncenter size-full wp-image-15985 jetpack-lazy-image" src="../Images/b541c69532dc43814432399722d623f7.png" alt="Chat App Built With GraphQL Hooks" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2020/03/chat-app-built-with-graphql-hooks-1.gif?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/03/chat-app-built-with-graphql-hooks-1.gif"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="15985" data-permalink="https://blog.logrocket.com/comparing-hooks-libraries-for-graphql/attachment/chat-app-built-with-graphql-hooks-2/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/03/chat-app-built-with-graphql-hooks-1.gif" data-orig-size="720,450" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Chat app built with GraphQL Hooks" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/03/chat-app-built-with-graphql-hooks-1-300x188.gif" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/03/chat-app-built-with-graphql-hooks-1.gif" decoding="async" loading="lazy" class="aligncenter size-full wp-image-15985" src="../Images/b541c69532dc43814432399722d623f7.png" alt="Chat App Built With GraphQL Hooks" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/03/chat-app-built-with-graphql-hooks-1.gif"/></noscript>
<h3><strong>后端设置</strong></h3>
<p>我不会在后端上花太多时间，但这里可以快速浏览一下我是如何为这个应用程序设置它的:</p>
<p><img data-attachment-id="15980" data-permalink="https://blog.logrocket.com/comparing-hooks-libraries-for-graphql/attachment/backend-of-chat-app/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/03/backend-of-chat-app.png" data-orig-size="451,136" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Backend of chat app" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/03/backend-of-chat-app-300x90.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/03/backend-of-chat-app.png" decoding="async" class="aligncenter size-full wp-image-15980 jetpack-lazy-image" src="../Images/380a5570b1f37ba230a61c7c866c055c.png" alt="Backend of Chat App" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2020/03/backend-of-chat-app.png 451w, https://blog.logrocket.com/wp-content/uploads/2020/03/backend-of-chat-app-300x90.png 300w" data-lazy-sizes="(max-width: 451px) 100vw, 451px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2020/03/backend-of-chat-app.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/03/backend-of-chat-app.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="15980" data-permalink="https://blog.logrocket.com/comparing-hooks-libraries-for-graphql/attachment/backend-of-chat-app/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/03/backend-of-chat-app.png" data-orig-size="451,136" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Backend of chat app" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/03/backend-of-chat-app-300x90.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/03/backend-of-chat-app.png" decoding="async" loading="lazy" class="aligncenter size-full wp-image-15980" src="../Images/380a5570b1f37ba230a61c7c866c055c.png" alt="Backend of Chat App" srcset="https://blog.logrocket.com/wp-content/uploads/2020/03/backend-of-chat-app.png 451w, https://blog.logrocket.com/wp-content/uploads/2020/03/backend-of-chat-app-300x90.png 300w" sizes="(max-width: 451px) 100vw, 451px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/03/backend-of-chat-app.png"/></noscript>
<p>基本上，我使用<a href="https://blog.logrocket.com/building-a-product-hunt-clone-app-using-hasura-and-next-js/"> Hasura </a>来建立GraphQL和一个<a href="https://blog.logrocket.com/getting-started-with-postgres-in-your-react-app/"> Postgres数据库</a>。这个易于使用的工具使您能够在几分钟内创建一个后端。</p>
<p>我们的后端包含两个表:</p>
<ul>
<li>用户，包括关于用户的信息</li>
<li>消息，存储所有用户的消息</li>
</ul>
<p>后端网址为<a href="https://hasura-infiite-loader.herokuapp.com/v1alpha1/graphql" rel="nofollow">https://hasura-infite-loader . heroku app . com/v1 alpha 1/graph QL</a>；WebSocket的URL是ws://hasura-infite-loader . heroku app . com/v1 alpha 1/graph QL。</p>
<h2 id="apolloandreacthooks">阿波罗和反应钩</h2>
<p>要使用Apollo、React Hooks和React实现我们的应用程序，我们必须首先使用下面的命令建立一个React项目。</p>
<pre>npx create-react-app apollo-react-hook-example
</pre>
<p>之后，安装<code>@apollo/react-hooks</code>包的所有依赖项。</p>
<pre>npm install @apollo/react-hooks apollo-client apollo-link-http apollo-link-ws apollo-link apollo-utilities apollo-cache-inmemory subscriptions-transport-ws
</pre>
<p>那可是好多包啊！让我们一个一个地分解它们。</p>
<ul>
<li><code><a href="https://www.apollographql.com/docs/react/api/react-hooks/" target="_blank" rel="noopener noreferrer">@apollo/react-hooks</a></code>提供了使用GraphQL和<code>apollo-client</code>所需的所有React钩子。它包含执行所有GraphQL操作的<code>useQuery</code>、<code>useMutation</code>和<code>useSubscription</code></li>
<li><code><a href="https://github.com/apollographql/apollo-client" target="_blank" rel="noopener noreferrer">apollo-client</a></code>提供了在客户端运行缓存操作所需的所有包。常与<code><a href="https://www.apollographql.com/docs/link/links/http/" target="_blank" rel="noopener noreferrer">apollo-link-http</a></code>和<code><a href="https://www.apollographql.com/docs/react/caching/cache-configuration/" target="_blank" rel="noopener noreferrer">apollo-cache-memory</a></code>连用</li>
<li><code><a href="https://www.apollographql.com/docs/link/links/http/" target="_blank" rel="noopener noreferrer">apollo-link-http</a></code>是一个可链接的操作单元，您可以将其应用于您的GraphQL请求。它一个接一个地执行单元。这里我们使用一个HTTP链接来执行GraphQL HTTP请求</li>
<li><code><a href="https://www.apollographql.com/docs/link/links/ws/" target="_blank" rel="noopener noreferrer">apollo-link-ws</a></code>为GraphQL客户端创建一个WebSocket链接</li>
<li><code><a href="https://www.apollographql.com/docs/link/#usage" target="_blank" rel="noopener noreferrer">apollo-link</a></code>上述两种功能属于<code><a href="https://www.apollographql.com/docs/link/#usage" target="_blank" rel="noopener noreferrer">apollo-link</a></code></li>
<li><code><a href="https://www.npmjs.com/package/apollo-utilities" target="_blank" rel="noopener noreferrer">apollo-utilities</a></code>为<code>apollo-client</code>提供实用功能</li>
<li><code><a href="https://www.npmjs.com/package/apollo-cache-inmemory" target="_blank" rel="noopener noreferrer">apollo-cache-inmemory</a></code>为GraphQL请求提供缓存功能</li>
<li><code><a href="https://github.com/apollographql/subscriptions-transport-ws" target="_blank" rel="noopener noreferrer">subscription-transport-ws</a></code>与<code>apollo-link-ws</code>一起使用，以方便GraphQL订阅</li>
</ul>
<p>现在是时候用我们的应用程序设置<code>@apollo/react-hooks</code>了。将所有包导入<code>App.js</code>。</p>
<pre>import ApolloClient from "apollo-client";
import { ApolloProvider } from "@apollo/react-hooks";
import { WebSocketLink } from "apollo-link-ws";
import { HttpLink } from "apollo-link-http";
import { split } from "apollo-link";
import { getMainDefinition } from "apollo-utilities";
import { InMemoryCache } from "apollo-cache-inmemory";
</pre>
<p>建立与服务器的HTTP和WebSocket链接。</p>
<pre>const httpLink = new HttpLink({
  uri: "https://hasura-infiite-loader.herokuapp.com/v1alpha1/graphql" // use https for secure endpoint
});
// Create a WebSocket link:
const wsLink = new WebSocketLink({
  uri: "ws://hasura-infiite-loader.herokuapp.com/v1alpha1/graphql", // use wss for a secure endpoint
  options: {
    reconnect: true
  }
});
</pre>
<p>一旦我们有了<code>httpLink</code>和<code>wsLink</code>，我们需要分割请求链接，这样我们就可以向每个链接发送不同的数据。</p>
<pre>// using the ability to split links, you can send data to each link
// depending on what kind of operation is being sent
const link = split(
  // split based on operation type
  ({ query }) =&gt; {
    const { kind, operation } = getMainDefinition(query);
    return kind === "OperationDefinition" &amp;&amp; operation === "subscription";
  },
  wsLink,
  httpLink
);
</pre>
<p>让我们创建Apollo客户机，并将其配置为Apollo提供者</p>
<pre>// Instantiate client
const client = new ApolloClient({
  link,
  cache: new InMemoryCache()
});

function App() {
  return (
    &lt;ApolloProvider client={client}&gt;
      &lt;ThemeProvider theme={customTheme}&gt;
        &lt;div className="App"&gt;
          &lt;Routes /&gt;
        &lt;/div&gt;
      &lt;/ThemeProvider&gt;
    &lt;/ApolloProvider&gt;
  );
}
</pre>
<p>完成<code>App.js</code>的源代码。</p>
<pre>import React from "react";
import logo from "./logo.svg";
import "./App.css";
import customTheme from "./theme";
import { ThemeProvider } from "@chakra-ui/core";
import Routes from "./routes";
import ApolloClient from "apollo-client";
import { ApolloProvider } from "@apollo/react-hooks";
import { WebSocketLink } from "apollo-link-ws";
import { HttpLink } from "apollo-link-http";
import { split } from "apollo-link";
import { getMainDefinition } from "apollo-utilities";
import { InMemoryCache } from "apollo-cache-inmemory";
const httpLink = new HttpLink({
  uri: "https://hasura-infiite-loader.herokuapp.com/v1alpha1/graphql" // use https for secure endpoint
});
// Create a WebSocket link:
const wsLink = new WebSocketLink({
  uri: "ws://hasura-infiite-loader.herokuapp.com/v1alpha1/graphql", // use wss for a secure endpoint
  options: {
    reconnect: true
  }
});
// using the ability to split links, you can send data to each link
// depending on what kind of operation is being sent
const link = split(
  // split based on operation type
  ({ query }) =&gt; {
    const { kind, operation } = getMainDefinition(query);
    return kind === "OperationDefinition" &amp;&amp; operation === "subscription";
  },
  wsLink,
  httpLink
);
// Instantiate client
const client = new ApolloClient({
  link,
  cache: new InMemoryCache()
});
function App() {
  return (
    &lt;ApolloProvider client={client}&gt;
      &lt;ThemeProvider theme={customTheme}&gt;
        &lt;div className="App"&gt;
          &lt;Routes /&gt;
        &lt;/div&gt;
      &lt;/ThemeProvider&gt;
    &lt;/ApolloProvider&gt;
  );
}
export default App;
</pre>
<p>现在我们将为我们的应用程序创建<code>Routes.js</code>。</p>
<pre>import React from "react";
import { BrowserRouter as Router, Route, Switch } from "react-router-dom";
import LoginComponent from "./components/login";
import Chat from "./components/Chat";
const Routes = () =&gt; (
  &lt;Router&gt;
    &lt;Route exact path="/" component={LoginComponent} /&gt;
    &lt;Route path="/chat" component={Chat} /&gt;
  &lt;/Router&gt;
);
export default Routes;
</pre>
<p>我们有三个主要组件:</p>
<ol>
<li>注册</li>
<li>闲谈</li>
<li>聊天项目</li>
</ol>
<p><img data-attachment-id="15982" data-permalink="https://blog.logrocket.com/comparing-hooks-libraries-for-graphql/attachment/chat-app-components-apollo/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/03/chat-app-components-apollo.png" data-orig-size="330,390" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Chat app components — Apollo" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/03/chat-app-components-apollo-254x300.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/03/chat-app-components-apollo.png" decoding="async" class="aligncenter size-full wp-image-15982 jetpack-lazy-image" src="../Images/0ca475603da0903ae45079ad08d7a860.png" alt="Chat App Components — Apollo" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2020/03/chat-app-components-apollo.png 330w, https://blog.logrocket.com/wp-content/uploads/2020/03/chat-app-components-apollo-254x300.png 254w" data-lazy-sizes="(max-width: 330px) 100vw, 330px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2020/03/chat-app-components-apollo.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/03/chat-app-components-apollo.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="15982" data-permalink="https://blog.logrocket.com/comparing-hooks-libraries-for-graphql/attachment/chat-app-components-apollo/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/03/chat-app-components-apollo.png" data-orig-size="330,390" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Chat app components — Apollo" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/03/chat-app-components-apollo-254x300.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/03/chat-app-components-apollo.png" decoding="async" loading="lazy" class="aligncenter size-full wp-image-15982" src="../Images/0ca475603da0903ae45079ad08d7a860.png" alt="Chat App Components — Apollo" srcset="https://blog.logrocket.com/wp-content/uploads/2020/03/chat-app-components-apollo.png 330w, https://blog.logrocket.com/wp-content/uploads/2020/03/chat-app-components-apollo-254x300.png 254w" sizes="(max-width: 330px) 100vw, 330px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/03/chat-app-components-apollo.png"/></noscript>
<p>让我们更详细地检查这些。</p>
<h3>登录组件</h3>
<p>登录组件的功能非常简单。我们的应用程序将有一个用户输入名称和密码的形式。</p>
<p>这里我们需要的GraphQL操作是突变。我们将使用一个名为<code>useMutation</code>的React钩子。我们还将使用<code><a href="https://github.com/react-hook-form/react-hook-form" target="_blank" rel="noopener noreferrer">react-hook-form</a></code>进行表单验证，使用<code><a href="https://chakra-ui.com/" target="_blank" rel="noopener noreferrer">chakraUI</a></code>进行UI验证。</p>
<pre>import { useMutation } from "@apollo/react-hooks";

import gql from "graphql-tag";
const LOGIN_USER = gql`
  mutation InsertUsers($name: String!, $password: String!) {
    insert_users(objects: { name: $name, password: $password }) {
      returning {
        id
        name
      }
    }
  }
`;
</pre>
<p>我们有一个突变GraphQL操作，它将<code>name</code>和<code>password</code>作为参数，并执行<code>insert_users</code>突变。</p><div class="code-block code-block-54">
<hr/>
<h3>更多来自LogRocket的精彩文章:</h3>

<hr/></div>
<p>接下来，用变异GraphQL定义登录组件内部的<code>useMutation</code>钩子。</p>
<pre>  const [insert_users, { data }] = useMutation(LOGIN_USER);
</pre>
<p>以下是<code>Login</code> / <code>index.js</code>的完整源代码:</p>
<pre>import React, { useState, useEffect } from "react";
import { useForm } from "react-hook-form";
import {
  FormErrorMessage,
  FormLabel,
  FormControl,
  Input,
  Button,
  Box
} from "@chakra-ui/core";
import { useMutation } from "@apollo/react-hooks";
import gql from "graphql-tag";
const LOGIN_USER = gql`
  mutation InsertUsers($name: String!, $password: String!) {
    insert_users(objects: { name: $name, password: $password }) {
      returning {
        id
        name
      }
    }
  }
`;
const Login = ({ history }) =&gt; {
  const [state, setState] = useState({
    name: "",
    password: ""
  });
  const [insert_users, { data }] = useMutation(LOGIN_USER);
  useEffect(() =&gt; {
    const user = data &amp;&amp; data.insert_users.returning[0];
    if (user) {
      localStorage.setItem("user", JSON.stringify(user));
      history.push("/chat");
    }
  }, [data]);
  const { handleSubmit, errors, register, formState } = useForm();
  function validateName(value) {
    let error;
    if (!value) {
      error = "Name is required";
    }
    return error || true;
  }
  function validatePassword(value) {
    let error;
    if (value.length &lt;= 4) {
      error = "Password should be 6 digit long";
    }
    return error || true;
  }
  const onInputChange = e =&gt; {
    setState({ ...state, [e.target.name]: e.target.value });
  };
  const onSubmit = () =&gt; {
    insert_users({ variables: { name: state.name, password: state.password } });
    setState({ name: "", password: "" });
  };
  return (
    &lt;Box&gt;
      &lt;form onSubmit={handleSubmit(onSubmit)}&gt;
        &lt;FormControl isInvalid={errors.name}&gt;
          &lt;FormLabel htmlFor="name"&gt;Name&lt;/FormLabel&gt;
          &lt;Input
            name="name"
            placeholder="name"
            onChange={onInputChange}
            ref={register({ validate: validateName })}
          /&gt;
          &lt;FormErrorMessage&gt;
            {errors.name &amp;&amp; errors.name.message}
          &lt;/FormErrorMessage&gt;
        &lt;/FormControl&gt;
        &lt;FormControl isInvalid={errors.password}&gt;
          &lt;FormLabel htmlFor="name"&gt;Password&lt;/FormLabel&gt;
          &lt;Input
            name="password"
            type="password"
            placeholder="password"
            onChange={onInputChange}
            ref={register({ validate: validatePassword })}
          /&gt;
          &lt;FormErrorMessage&gt;
            {errors.password &amp;&amp; errors.password.message}
          &lt;/FormErrorMessage&gt;
        &lt;/FormControl&gt;
        &lt;Button
          mt={4}
          variantColor="teal"
          isLoading={formState.isSubmitting}
          type="submit"
        &gt;
          Submit
        &lt;/Button&gt;
      &lt;/form&gt;
    &lt;/Box&gt;
  );
};
export default Login;
</pre>
<h3>聊天组件</h3>
<p>聊天组件将主要使用两个GraphQL操作:变异和订阅。由于我们的聊天应用程序是一个实时应用程序，我们需要订阅以获取更新的数据。</p>
<p>为此，我们需要用<code>useSubscription</code> React钩子来订阅，用<code>useMutation</code>钩子在GraphQL上发出HTTP POST请求。</p>
<pre>import { useMutation, useSubscription } from "@apollo/react-hooks";
import gql from "graphql-tag";
const MESSAGES_SUBSCRIPTION = gql`
  subscription {
    messages {
      id
      text
      users {
        id
        name
      }
    }
  }
`;
const SUBMIT_MESSAGES = gql`
  mutation InsertMessages($text: String!, $userid: Int!) {
    insert_messages(objects: { text: $text, created_user: $userid }) {
      returning {
        text
        created_user
        users {
          name
          id
        }
        id
      }
    }
  }
`;
</pre>
<p><code>MESSAGES_SUBSCRIPTION</code>是一个订阅GraphQL模式定义。<code>SUBMIT_MESSAGES</code>是一个突变GraphQL模式定义。</p>
<p>我们将在我们的聊天组件中使用这两者。</p>
<pre>const [insert_messages, { returnData }] = useMutation(SUBMIT_MESSAGES);


const { loading, error, data: { messages } = [] } = useSubscription(
    MESSAGES_SUBSCRIPTION
  );
</pre>
<p>每当来自GraphQL的消息发生变化时，来自<code>useSubscription</code>的消息将返回更新的数据。</p>
<p>以下是<code>Chat</code> / <code>index.js</code>的完整源代码:</p>
<pre>import React, { useState, useEffect } from "react";
import { Box, Flex, Input } from "@chakra-ui/core";
import ChatItem from "../ChatItem";
import { useMutation, useSubscription } from "@apollo/react-hooks";
import gql from "graphql-tag";
const MESSAGES_SUBSCRIPTION = gql`
  subscription {
    messages {
      id
      text
      users {
        id
        name
      }
    }
  }
`;
const SUBMIT_MESSAGES = gql`
  mutation InsertMessages($text: String!, $userid: Int!) {
    insert_messages(objects: { text: $text, created_user: $userid }) {
      returning {
        text
        created_user
        users {
          name
          id
        }
        id
      }
    }
  }
`;
const Chat = () =&gt; {
  const [state, setState] = useState({
    text: ""
  });
  const [insert_messages, { returnData }] = useMutation(SUBMIT_MESSAGES);
  const { loading, error, data: { messages } = [] } = useSubscription(
    MESSAGES_SUBSCRIPTION
  );
  const onInputChage = e =&gt; {
    setState({ [e.target.name]: e.target.value });
  };
  const onEnter = e =&gt; {
    if (e.key === "Enter") {
      let user = localStorage.getItem("user");
      user = JSON.parse(user);
      insert_messages({ variables: { text: state.text, userid: user.id } });
      setState({ text: "" });
    }
  };
  return (
    &lt;Box h="100vh" w="40%" margin="auto"&gt;
      &lt;Flex direction="column" h="100%"&gt;
        &lt;Box bg="blue" h="90%" w="100%" border="solid 1px" overflowY="scroll"&gt;
          {messages &amp;&amp;
            messages.map(message =&gt; {
              return &lt;ChatItem item={message} /&gt;;
            })}
        &lt;/Box&gt;
        &lt;Box bg="green" h="10%" w="100%"&gt;
          &lt;Input
            placeholder="Enter a message"
            name="text"
            value={state.text}
            onChange={onInputChage}
            onKeyDown={onEnter}
            size="md"
          /&gt;
        &lt;/Box&gt;
      &lt;/Flex&gt;
    &lt;/Box&gt;
  );
};
export default Chat;
</pre>
<p><code>ChatItem</code> / <code>index.js</code>:</p>
<pre>import React from "react";
import { Box, Flex, Avatar, Heading, Text } from "@chakra-ui/core";
const ChatItem = ({ item }) =&gt; {
  return (
    &lt;Box h="60px"&gt;
      &lt;Flex direction="row" alignItems="center" height="100%"&gt;
        &lt;Avatar size="sm" padding="4px" marginLeft="10px" /&gt;
        &lt;Flex direction="column" margin="5px"&gt;
          &lt;Text fontSize="xl" margin="0"&gt;
            {item.users.name}
          &lt;/Text&gt;
          &lt;Text margin="0"&gt;{item.text}&lt;/Text&gt;
        &lt;/Flex&gt;
      &lt;/Flex&gt;
    &lt;/Box&gt;
  );
};
export default ChatItem;
</pre>
<h2 id="graphqlhooksandreact">GraphQL挂钩并做出反应</h2>
<p>到目前为止，我们已经展示了如何将<code><a href="https://www.apollographql.com/docs/react/api/react-hooks/" target="_blank" rel="noopener noreferrer">@apollo/react-hooks</a></code>与React一起使用。现在让我们看看如何在React应用程序中设置和使用<code><a href="https://github.com/nearform/graphql-hooks" target="_blank" rel="noopener noreferrer">graphql-hooks</a></code>。</p>
<pre>npm install graphql-hooks subscriptions-transport-ws
</pre>
<ul>
<li><code><a href="https://github.com/nearform/graphql-hooks" target="_blank" rel="noopener noreferrer">graphql-hooks</a></code>提供GraphQL操作的钩子，如<code>useQuery</code>、<code>useMutation</code>和<code>useSubscriptions</code></li>
<li><code><a href="https://github.com/apollographql/subscriptions-transport-ws" target="_blank" rel="noopener noreferrer">subscriptions-transport-ws</a></code>-为WebSocket提供<code>SubscriptionClient</code>以在GraphQL订阅中使用</li>
</ul>
<p><code>App.js</code>:</p>
<pre>import React from "react";
import customTheme from "./theme";
import { ThemeProvider } from "@chakra-ui/core";
import { GraphQLClient, ClientContext } from "graphql-hooks";
import { SubscriptionClient } from "subscriptions-transport-ws";
import Routes from "./routes";
import "./App.css";
const client = new GraphQLClient({
  url: "https://hasura-infiite-loader.herokuapp.com/v1alpha1/graphql",
  subscriptionClient: new SubscriptionClient(
    "ws://hasura-infiite-loader.herokuapp.com/v1alpha1/graphql"
  )
});
function App() {
  return (
    &lt;ClientContext.Provider value={client}&gt;
      &lt;ThemeProvider theme={customTheme}&gt;
        &lt;div className="App"&gt;
          &lt;Routes /&gt;
        &lt;/div&gt;
      &lt;/ThemeProvider&gt;
    &lt;/ClientContext.Provider&gt;
  );
}
export default App;
</pre>
<p>我们创建了一个带有HTTP和WebSocket链接的GraphQL客户端，并将其用于上下文提供者。</p>
<p>既然我们已经设置了GraphQL钩子，我们可以在我们的组件中使用它。我们将创建与在<code>@apollo/react-hooks</code>设置中创建的组件相同的组件。</p>
<p>剧透:组件没有太大变化。</p>
<p><img data-attachment-id="15983" data-permalink="https://blog.logrocket.com/comparing-hooks-libraries-for-graphql/attachment/chat-app-components-graphql/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/03/chat-app-components-graphql.png" data-orig-size="330,390" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Chat app components — GraphQL" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/03/chat-app-components-graphql-254x300.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/03/chat-app-components-graphql.png" decoding="async" class="aligncenter size-full wp-image-15983 jetpack-lazy-image" src="../Images/ef5d1f6f0da416d425ef350d693c0b2b.png" alt="Chat App Components — GraphQL" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2020/03/chat-app-components-graphql.png 330w, https://blog.logrocket.com/wp-content/uploads/2020/03/chat-app-components-graphql-254x300.png 254w" data-lazy-sizes="(max-width: 330px) 100vw, 330px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2020/03/chat-app-components-graphql.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/03/chat-app-components-graphql.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="15983" data-permalink="https://blog.logrocket.com/comparing-hooks-libraries-for-graphql/attachment/chat-app-components-graphql/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/03/chat-app-components-graphql.png" data-orig-size="330,390" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Chat app components — GraphQL" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/03/chat-app-components-graphql-254x300.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/03/chat-app-components-graphql.png" decoding="async" loading="lazy" class="aligncenter size-full wp-image-15983" src="../Images/ef5d1f6f0da416d425ef350d693c0b2b.png" alt="Chat App Components — GraphQL" srcset="https://blog.logrocket.com/wp-content/uploads/2020/03/chat-app-components-graphql.png 330w, https://blog.logrocket.com/wp-content/uploads/2020/03/chat-app-components-graphql-254x300.png 254w" sizes="(max-width: 330px) 100vw, 330px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/03/chat-app-components-graphql.png"/></noscript>
<h3>登录组件</h3>
<p>这将类似于Apollo设置，除了两件事:我们将导入<code>graphql-hooks</code>，并且我们不需要<code>graphql-tags</code>来定义模式。</p>
<p>否则，步骤相同。</p>
<pre>import React, { useState, useEffect } from "react";
import { useForm } from "react-hook-form";
import {
  FormErrorMessage,
  FormLabel,
  FormControl,
  Input,
  Button,
  Box
} from "@chakra-ui/core";
import { useMutation } from "graphql-hooks";
const LOGIN_USER = `
  mutation InsertUsers($name: String!, $password: String!) {
    insert_users(objects: { name: $name, password: $password }) {
      returning {
        id
        name
      }
    }
  }
`;
const Login = ({ history }) =&gt; {
  const [state, setState] = useState({
    name: "",
    password: ""
  });
  const [insert_users, { data }] = useMutation(LOGIN_USER);
  useEffect(() =&gt; {
    const user = data &amp;&amp; data.insert_users.returning[0];
    if (user) {
      localStorage.setItem("user", JSON.stringify(user));
      history.push("/chat");
    }
  }, [data]);
  const { handleSubmit, errors, register, formState } = useForm();
  function validateName(value) {
    let error;
    if (!value) {
      error = "Name is required";
    }
    return error || true;
  }
  function validatePassword(value) {
    let error;
    if (value.length &lt;= 4) {
      error = "Password should be 6 digit long";
    }
    return error || true;
  }
  const onInputChange = e =&gt; {
    setState({ ...state, [e.target.name]: e.target.value });
  };
  const onSubmit = () =&gt; {
    insert_users({ variables: { name: state.name, password: state.password } });
    setState({ name: "", password: "" });
  };
  return (
    &lt;Box w="50%" margin="auto"&gt;
      &lt;form onSubmit={handleSubmit(onSubmit)}&gt;
        &lt;FormControl isInvalid={errors.name}&gt;
          &lt;FormLabel htmlFor="name"&gt;Name&lt;/FormLabel&gt;
          &lt;Input
            name="name"
            placeholder="name"
            onChange={onInputChange}
            ref={register({ validate: validateName })}
          /&gt;
          &lt;FormErrorMessage&gt;
            {errors.name &amp;&amp; errors.name.message}
          &lt;/FormErrorMessage&gt;
        &lt;/FormControl&gt;
        &lt;FormControl isInvalid={errors.password}&gt;
          &lt;FormLabel htmlFor="name"&gt;Password&lt;/FormLabel&gt;
          &lt;Input
            name="password"
            type="password"
            placeholder="password"
            onChange={onInputChange}
            ref={register({ validate: validatePassword })}
          /&gt;
          &lt;FormErrorMessage&gt;
            {errors.password &amp;&amp; errors.password.message}
          &lt;/FormErrorMessage&gt;
        &lt;/FormControl&gt;
        &lt;Button
          mt={4}
          variantColor="teal"
          isLoading={formState.isSubmitting}
          type="submit"
        &gt;
          Submit
        &lt;/Button&gt;
      &lt;/form&gt;
    &lt;/Box&gt;
  );
};
export default Login;
</pre>
<h3>聊天组件</h3>
<p><code>Chat</code> / <code>index.js</code></p>
<pre>import React, { useState, useEffect } from "react";
import { Box, Flex, Input } from "@chakra-ui/core";
import ChatItem from "../ChatItem";
import { useMutation, useSubscription } from "graphql-hooks";
const MESSAGES_SUBSCRIPTION = `
  subscription {
    messages {
      id
      text
      users {
        id
        name
      }
    }
  }
`;
const SUBMIT_MESSAGES = `
  mutation InsertMessages($text: String!, $userid: Int!) {
    insert_messages(objects: { text: $text, created_user: $userid }) {
      returning {
        text
        created_user
        users {
          name
          id
        }
        id
      }
    }
  }
`;
const Chat = () =&gt; {
  const [state, setState] = useState({
    text: "",
    data: []
  });
  const [errors, setErrors] = useState(null);
  const [insert_messages, { returnData }] = useMutation(SUBMIT_MESSAGES);
  //   const { loading, error, data: { messages } = [] } = useSubscription(
  //     MESSAGES_SUBSCRIPTION
  //   );
  useSubscription({ query: MESSAGES_SUBSCRIPTION }, ({ data, error }) =&gt; {
    if (errors &amp;&amp; errors.length &gt; 0) {
      setErrors(errors[0]);
      return;
    }
    setState({ ...state, data: data.messages });
  });
  const onInputChage = e =&gt; {
    setState({ ...state, [e.target.name]: e.target.value });
  };
  const onEnter = e =&gt; {
    if (e.key === "Enter") {
      let user = localStorage.getItem("user");
      user = JSON.parse(user);
      insert_messages({ variables: { text: state.text, userid: user.id } });
      setState({ ...state, text: "" });
    }
  };
  return (
    &lt;Box h="100vh" w="40%" margin="auto"&gt;
      &lt;Flex direction="column" h="100%"&gt;
        &lt;Box bg="blue" h="90%" w="100%" border="solid 1px" overflowY="scroll"&gt;
          {state.data.map(message =&gt; {
            return &lt;ChatItem item={message} /&gt;;
          })}
        &lt;/Box&gt;
        &lt;Box bg="green" h="10%" w="100%"&gt;
          &lt;Input
            placeholder="Enter a message"
            name="text"
            value={state.text}
            onChange={onInputChage}
            onKeyDown={onEnter}
            size="md"
          /&gt;
        &lt;/Box&gt;
      &lt;/Flex&gt;
    &lt;/Box&gt;
  );
};
export default Chat;
</pre>
<p><code>ChatItem</code> / <code>index.js</code></p>
<pre>import React from "react";
import { Box, Flex, Avatar, Heading, Text } from "@chakra-ui/core";
const ChatItem = ({ item }) =&gt; {
  return (
    &lt;Box h="60px"&gt;
      &lt;Flex direction="row" alignItems="center" height="100%"&gt;
        &lt;Avatar
          size="sm"
          name={item.users.name}
          padding="4px"
          marginLeft="10px"
        /&gt;
        &lt;Flex direction="column" margin="5px"&gt;
          &lt;Text fontSize="xl" margin="0"&gt;
            {item.users.name}
          &lt;/Text&gt;
          &lt;Text margin="0"&gt;{item.text}&lt;/Text&gt;
        &lt;/Flex&gt;
      &lt;/Flex&gt;
    &lt;/Box&gt;
  );
};
export default ChatItem;
</pre>
<h2 id="keytakeaways">关键要点</h2>
<p>下面我们通过分析一些主要概念来总结一下<code>graphql-hooks</code>和<code>apollo-react-hooks</code>的区别。</p>
<h3>GraphQL操作</h3>
<p>就查询、变异和订阅等GraphQL操作而言，这两个库是相似的。它们都有相同的钩子集，可用于GraphQL操作。</p>
<h3>贮藏</h3>
<p>Apollo钩子和GraphQL钩子都有缓存选项。</p>
<p>GraphQL钩子包括<code><a href="https://github.com/nearform/graphql-hooks/tree/master/packages/graphql-hooks-memcache" target="_blank" rel="noopener noreferrer">graphql-hooks-memcache</a></code>。</p>
<pre>import { GraphQLClient } from 'graphql-hooks'
import memCache from 'graphql-hooks-memcache'

const client = new GraphQLClient({
  url: '/graphql',
  cache: memCache()
})
</pre>
<p>同时，阿波罗·胡克斯提供了<code><a href="https://www.apollographql.com/docs/react/caching/cache-configuration/" target="_blank" rel="noopener noreferrer">apollo-cache-inmemory</a></code>。</p>
<pre>import { InMemoryCache } from 'apollo-cache-inmemory';
import { HttpLink } from 'apollo-link-http';
import { ApolloClient } from 'apollo-client';

const client = new ApolloClient({
  link: new HttpLink(),
  cache: new InMemoryCache()
});
</pre>
<p><a href="https://www.apollographql.com/docs/react/caching/cache-configuration/#configuring-the-cache" target="_blank" rel="noopener noreferrer"> Apollo缓存</a>的另一个优点是有额外的选项来配置缓存，比如从对象获取数据ID和缓存重定向。Apollo还提供了<a href="https://www.apollographql.com/docs/react/caching/cache-interaction/" target="_blank" rel="noopener noreferrer">缓存交互</a>的选项。</p>
<h2 id="middleware">中间件</h2>
<p>由于Apollo提供了一个<a href="https://blog.apollographql.com/apollo-link-the-modular-graphql-network-stack-3b6d5fcf9244" target="_blank" rel="noopener noreferrer"> Apollo链接</a>，我们可以通过提供链接来控制GraphQL操作的执行。常见的Apollo link功能包括重试、实时查询、备用缓存层和离线支持。</p>
<h3>服务器端渲染</h3>
<p>GraphQL钩子和T2阿波罗都为服务器端渲染提供了包。根据我的经验，两者都很好。</p>
<h2 id="conclusion">结论</h2>
<p>现在，您应该对用于实现GraphQL的React挂钩的包有了基本的了解。那么哪个最适合你的GraphQL项目呢？没有正确或错误的答案，这完全取决于你的应用程序的独特需求和你的个人偏好。我倾向于<code>graphql-hooks</code>因为它简单易用，易于实现，但是我鼓励你两者都尝试一下，看看你最喜欢哪一个。</p><div class="code-block code-block-24">
<div class="blog-plug inline-plug graphql-plug"><h2>监控生产中失败和缓慢的GraphQL请求</h2><p>虽然GraphQL有一些调试请求和响应的特性，但确保GraphQL可靠地为您的生产应用程序提供资源是一件比较困难的事情。如果您对确保对后端或第三方服务的网络请求成功感兴趣，</p><a href="https://lp.logrocket.com/blg/graphql-signup" target="_blank">try LogRocket</a><p>.</p><a class="signup" href="https://lp.logrocket.com/blg/graphql-signup" target="_blank" rel="noopener noreferrer"><img src="../Images/432a3823c85b3fb72a206e6236a29f48.png" data-lazy-src="https://files.readme.io/69aa835-Image_2019-11-09_at_1.28.05_PM.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" class=" jetpack-lazy-image" data-original-src="https://files.readme.io/69aa835-Image_2019-11-09_at_1.28.05_PM.png"/><noscript><img data-lazy-fallback="1" src="../Images/432a3823c85b3fb72a206e6236a29f48.png" data-original-src="https://files.readme.io/69aa835-Image_2019-11-09_at_1.28.05_PM.png"/></noscript><img class="alignnone size-full wp-image-46 jetpack-lazy-image" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/><noscript><img data-lazy-fallback="1" class="alignnone size-full wp-image-46" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/></noscript></a><a href="https://lp.logrocket.com/blg/graphql-signup" target="_blank" rel="noopener noreferrer">https://logrocket.com/signup/</a><p>LogRocket 就像是网络和移动应用的DVR，记录下你网站上发生的每一件事。您可以汇总并报告有问题的GraphQL请求，以快速了解根本原因，而不是猜测问题发生的原因。此外，您可以跟踪Apollo客户机状态并检查GraphQL查询的键值对。</p><p>LogRocket检测您的应用程序以记录基线性能计时，如页面加载时间、到达第一个字节的时间、慢速网络请求，还记录Redux、NgRx和Vuex操作/状态。</p><a class="signup" href="https://lp.logrocket.com/blg/graphql-signup" target="_blank" rel="noopener noreferrer">Start monitoring for free</a><p>.</p></div>


</div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
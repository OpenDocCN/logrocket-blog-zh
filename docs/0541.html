<html>
<head>
<title>Writing end-to-end tests for GraphQL servers using Jest - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>使用Jest - LogRocket博客为GraphQL服务器编写端到端测试</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/writing-end-to-end-tests-for-graphql-servers-using-jest/#0001-01-01">https://blog.logrocket.com/writing-end-to-end-tests-for-graphql-servers-using-jest/#0001-01-01</a></blockquote><div><article class="article-post">
<p>为应用程序编写端到端测试有助于确保应用程序按预期运行。当我们向现有应用程序添加新功能时，它也很方便，因为它确保新引入的功能与我们现有的功能很好地集成。</p>
<p>如果不是这样，我们的测试套件将会失败，这将促使我们对应用程序进行适当的修改，以确保测试成功。</p>
<p>为了让这篇文章易于理解，我创建了这个<a href="https://github.com/gbols/End-to-End-Test-With-Jest" target="_blank" rel="noopener noreferrer">样板项目</a>，它公开了几个解析器，本质上是对<code>User</code>和<code>Todo</code>类型的CRUD操作。</p>
<p>设置项目后，我们可以执行一些查询和变化。</p>
<p>这些查询和变化会给我们一个项目如何工作的概述。</p>
<p>重要的是，我们要熟悉我们的GraphQL服务器所公开的解析器的期望——这是有效和正确测试的基础。</p>
<p>样板项目包括帮助我们理解项目基础的文档。</p>
<p>为了开始测试，我们需要一个单独的数据库。这有助于我们保持原始数据库的完整性。</p>
<p>我们将有一组不同的环境变量来运行测试，如<br/> <code>~/config/test.env</code>所示</p>
<p>这些变量是在我们运行测试套件时从脚本标签中的<code>package.json</code>载入的:</p>
<pre>"scripts": {
    "test": "env-cmd -f ./config/test.env",
     .....
  },</pre>
<p>要开始编写测试，我们需要安装Jest，这是一个帮助编写测试的库:</p>
<pre>npm install --save-dev jest

// ~/Documents/ultimate-todo
mkdir tests
cd tests</pre>
<p>我们将更新我们的<code>package.json</code>来运行我们的测试:</p>
<pre>"scripts": {
    "test": "env-cmd -f ./config/test.env jest --runInBand",
     .....
  },</pre>
<p>到目前为止，我们一直从默认情况下位于<a href="http://localhost:4000/" rel="nofollow"> http://localhost:4000/ </a>的GraphQL客户端平台向我们的GraphQL服务器发出请求。然而，我们需要从代码中向服务器发出请求。</p>
<p>为此，我们需要安装<code>apollo-boost</code>。</p>
<p>我们还将安装Babel register，因为Jest需要能够使用我们的服务器，它的代码是用es6编写的。巴别塔注册帮助Jest理解我们的代码。</p>
<pre>npm install apollo-boost graphql cross-fetch @babel/register -D</pre>
<p>我也更喜欢设置Jest config来启动，然后在运行所有测试套件后拆除服务器。</p>
<pre>// ~/Documents/ultimate-todo/tests
mkdir config
cd config

//create both files 
touch globalSetup.js globalTeardown.js

//globalSetup.js
require('@babel/register');

const server = require('../../src/app').default;

module.exports = async () =&gt; {
  global.httpServer = server;
  await global.httpServer.listen();
};

//globalTeardown.js
module.exports = async () =&gt; {
  await global.httpServer.stop();
};</pre>
<p>Jest将在测试开始时使用文件<code>gbolbalSetup.js</code>，在测试结束时使用文件<code>gbolbalTeardown.js</code>。</p>
<p>我们现在要做的就是在我们的<code>package.json</code>中设置它，以便Jest可以在运行我们的测试套件时选择它们。</p>
<pre>.....
 "jest": {
    "globalSetup": "./tests/config/globalSetup.js",
    "globalTeardown": "./tests/config/globalTeardown.js"
  },
....</pre>
<p>现在我们已经完成了所有的设置，让我们编写一些测试。</p>
<pre>// ~/Documents/ultimate-todo/tests
touch user.tests.js // file to contain tests for the user type.</pre>
<p>我们将从编写<code>creatUser</code>突变的测试开始。</p>
<p>如果我们探索我们的突变的实现，我们可以清楚地看到有3种可能性。</p>
<ol>
<li>提供的密码少于8个字符。</li>
<li>用户已成功创建。</li>
<li>提供的电子邮件已被占用</li>
</ol>
<p>我们将编写测试来解释所有这些结果。</p>
<pre>// ~/Documents/ultimate-todo/tests/utils
import ApolloClient from 'apollo-boost';

export const client = new ApolloClient({
  uri: 'http://localhost:4000/',
  onError: (e) =&gt; { console.log(e) },
});

//~/Documents/ultimate-todo/tests/user.test/js
import 'cross-fetch/polyfill';
import ApolloClient, { gql } from 'apollo-boost';
import { prisma } from '../src/generated/prisma-client';
import { client } from './utils/getClient';

beforeAll(async () =&gt; {
  await prisma.deleteManyUsers()
})
describe('Tests the createUser Mutation', () =&gt; {
    it('should not signup a user with a password less than 8 characters', async () =&gt; {
          const createUser = gql`
            mutation {
              createUser(data: {
                name: "Gbolahan Olagunju",
                email: "<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="ff989d90938cbf9a879e928f939ad19c9092">[email protected]</a>",
                password: "dafe",
              }){
                token
                user {
                  name
                  password
                  email
                  id
                }
              }
            }
            `;
      
    await expect(client.mutate({
      mutation: createUser
    })).rejects.toThrowError("password must be more than 8 characters");
  })
  it('should successfully create a user with valid credentials', async () =&gt; {
    const createUser = gql`
            mutation {
              createUser(data: {
                name: "Gbolahan Olagunju",
                email: "<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="f295909d9e81b2978a939f829e97dc919d9f">[email protected]</a>",
                password: "dafeMania"
              }){
                token
                user {
                  id
                }
              }
            }
            `;
            
     const res = await client.mutate({
      mutation: createUser
    })
    const exists = await prisma.$exists.user({id : res.data.createUser.id});
    expect(exists).toBe(true);
  });
  
  it('should not create two users with the same crededntials', async () =&gt; {
    const createUser = gql`
            mutation {
              createUser(data: {
                name: "Gbolahan Olagunju",
                email: "<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="0562676a697645607d64687569602b666a68">[email protected]</a>",
                password: "dafeMania"
              }){
                token
                user {
                  name
                  password
                  email
                  id
                }
              }
            }
            `;
    await expect(client.mutate({
      mutation: createUser
    })).rejects.toThrowError("A unique constraint would be violated on User. Details: Field name = email");
  });
});</pre>
<p>上面的代码如预期的那样工作。</p>
<p><img data-attachment-id="10279" data-permalink="https://blog.logrocket.com/writing-end-to-end-tests-for-graphql-servers-using-jest/end-to-end-test-nocdn/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2019/11/end-to-end-test-nocdn.png" data-orig-size="848,362" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="end-to-end-test-nocdn" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2019/11/end-to-end-test-nocdn-300x128.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2019/11/end-to-end-test-nocdn.png" decoding="async" class="aligncenter wp-image-10279 jetpack-lazy-image" src="../Images/fc168ad12491e50b3b78fbbd2855870f.png" alt="output from our test" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2019/11/end-to-end-test-nocdn.png 848w, https://blog.logrocket.com/wp-content/uploads/2019/11/end-to-end-test-nocdn-300x128.png 300w, https://blog.logrocket.com/wp-content/uploads/2019/11/end-to-end-test-nocdn-768x328.png 768w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2019/11/end-to-end-test-nocdn.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/11/end-to-end-test-nocdn.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="10279" data-permalink="https://blog.logrocket.com/writing-end-to-end-tests-for-graphql-servers-using-jest/end-to-end-test-nocdn/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2019/11/end-to-end-test-nocdn.png" data-orig-size="848,362" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="end-to-end-test-nocdn" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2019/11/end-to-end-test-nocdn-300x128.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2019/11/end-to-end-test-nocdn.png" decoding="async" loading="lazy" class="aligncenter wp-image-10279" src="../Images/fc168ad12491e50b3b78fbbd2855870f.png" alt="output from our test" srcset="https://blog.logrocket.com/wp-content/uploads/2019/11/end-to-end-test-nocdn.png 848w, https://blog.logrocket.com/wp-content/uploads/2019/11/end-to-end-test-nocdn-300x128.png 300w, https://blog.logrocket.com/wp-content/uploads/2019/11/end-to-end-test-nocdn-768x328.png 768w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/11/end-to-end-test-nocdn.png"/></noscript>
<p>[运行npm测试获得的输出]</p>
<p>我们需要我们的测试行为一致，所以我们必须在所有测试运行之前清空我们的数据库。为此，我们将在测试开始时添加一个beforeAll块。</p>
<pre>...
  onError: (e) =&gt; { console.log(e) },
});
beforeAll(async () =&gt; {
  await prisma.deleteManyUsers()
})
...</pre>
<p>让我们继续为我们的<code>createTodo</code>、<code>updateTodo</code>和<code>deleteTodo</code>突变编写测试。</p>
<p>已经在localhost上与playground进行了交互，我们知道我们需要一个用户进行身份验证来执行这个操作。</p>
<p>因此，我们需要更新创建客户端的方式，以迎合经过身份验证的用户。当前代码创建了一个未经验证的用户。</p>
<p>让我们修改这个<code>Apolloclient</code>的实例来反映这个变化。</p>
<pre>// ~/Documents/ultimate-todo/tests/utils
import ApolloClient from 'apollo-boost';

export const getClient = (token) =&gt; {
   return new ApolloClient({
    uri: 'http://localhost:4000/',
    request: (operation) =&gt; {
      if(token) {
        operation.setContext({
          headers: {
            "Authorization": `Bearer ${token}`
          }
        })
      }
    },
    onError: (e) =&gt; { console.log(e) },
  });
}</pre>
<p>接下来，我们将编写测试来覆盖所有TODO类型的测试用例。</p>
<pre>//~/Documents/ultimate-todo/tests/todo.test/js

import 'cross-fetch/polyfill';
import { gql } from 'apollo-boost';
import { prisma } from '../src/generated/prisma-client';
import { getClient } from './utils/getClient';
const client = getClient();
let  authenticatedClient;
let todoId;
beforeAll(async () =&gt; {
  await prisma.deleteManyUsers()
  await prisma.deleteManyTodoes();
  const createUser = gql`
            mutation {
              createUser(data: {
                name: "Gbolahan Olagunju",
                email: "<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="761114191a0536130e171b061a135815191b">[email protected]</a>",
                password: "dafeMania"
              }){
                token
                user {
                  id
                }
              }
            }
            `;
            
     const authenticatedUser = await client.mutate({
      mutation: createUser
    });
    authenticatedClient = getClient(authenticatedUser.data.createUser.token);
});
describe('Tests that can be performed on the Todo Mutation', () =&gt; {
  it('should not allow an authenticated user create a TODO ', async () =&gt; {
      const createTodo = gql`
      mutation {
        createTodo(data: {
          title: "Buy Potatoes",
          body: "Buy yam from the supermarket for everyone to eat at 10pm"
        }){
          title
          body
          id
        }
      }
      `;
      await expect(client.mutate({
        mutation: createTodo
      })).rejects.toThrowError("Authentication required");
  });
  it('should create a todo for a authenticated user', async () =&gt; {
    const createTodo = gql`
    mutation {
      createTodo(data: {
        title: "Buy Potatoes",
        body: "Buy yam from the supermarket for everyone to eat at 10pm"
      }){
        title
        body
        id
      }
    }
    `;
    const todo = await authenticatedClient.mutate({
      mutation: createTodo
    });
    todoId = todo.data.createTodo.id
    const exists = await prisma.$exists.todo({id: todoId});
    expect(exists).toBe(true);
  });
  it('should update a TODO', async () =&gt; {
    const variables = {
      id: todoId
    }
    const updateTodo = gql`
    mutation($id: ID!){
      updateTodo(id: $id , data: {
        title: "Buy Ice Cream",
        body: "Buy Ice Cream from the store"
      }){
        title
        body
      }
    }
    `;
    const updatedTodo = await authenticatedClient.mutate({
      mutation: updateTodo, variables
    });
    expect(updatedTodo.data.updateTodo.title).toBe('Buy Ice Cream');
    expect(updatedTodo.data.updateTodo.body).toBe('Buy Ice Cream from the store');
  });
  it('should delete a TODO', async () =&gt; {
    const variables = {
      id: todoId
    }
    const deleteTodo = gql`
    mutation($id: ID!){
      deleteTodo(id: $id){
        title
        body
      }
    }
    `;
    const deletedTodo = await authenticatedClient.mutate({
      mutation: deleteTodo, variables
    });
    const exists = await prisma.$exists.todo({id : todoId});
    expect(exists).toBe(false);
  });
});</pre>
<p>最后，我们将编写测试来覆盖我们对<code>TODO</code>类型和<code>USER</code>类型的查询。</p>
<p>为了实现这一点，我们将在数据库中植入我们可以断言的虚拟数据。</p>
<pre>touch queries.test.js


    ////~/Documents/ultimate-todo/tests/queries.test/js
    
    import 'cross-fetch/polyfill';
    import { gql } from 'apollo-boost';
    import { prisma } from '../src/generated/prisma-client';
    import { getClient } from './utils/getClient';
    
    const client = getClient();
    beforeAll( async () =&gt; {
      await prisma.deleteManyUsers()
      const createUser = gql`
      mutation {
        createUser(data: {
          name: "Gbolahan Olagunju",
          email: "<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="83e4e1eceff0c3e6fbe2eef3efe6ade0ecee">[email protected]</a>",
          password: "dafeMania"
        }){
          token
          user {
            id
          }
        }
      }
      `;
      
      await client.mutate({
      mutation: createUser
      });
    });
    describe('the Queries that can be performed on TODO and USER type', () =&gt; {
      it('should be able to see author\'s profile without sensitive info being displayed', async () =&gt; {
        const userQuery = gql`
        query {
          users {
            id 
            name
          }
        }
        `;
        const { data } = await client.query({
          query: userQuery
        });
        expect(data.users.length).toBe(1);
        expect(data.users[0].name).toBe('Gbolahan Olagunju');
      });
    });</pre>
<p><img data-attachment-id="10289" data-permalink="https://blog.logrocket.com/writing-end-to-end-tests-for-graphql-servers-using-jest/three-passed-tests-nocdn/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2019/11/three-passed-tests-nocdn.png" data-orig-size="694,210" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="three-passed-tests-nocdn" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2019/11/three-passed-tests-nocdn-300x91.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2019/11/three-passed-tests-nocdn.png" decoding="async" class="aligncenter wp-image-10289 size-full jetpack-lazy-image" src="../Images/a16c29ef61c04af70ff5432b55820d72.png" alt="Passed tests" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2019/11/three-passed-tests-nocdn.png 694w, https://blog.logrocket.com/wp-content/uploads/2019/11/three-passed-tests-nocdn-300x91.png 300w" data-lazy-sizes="(max-width: 694px) 100vw, 694px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2019/11/three-passed-tests-nocdn.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/11/three-passed-tests-nocdn.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="10289" data-permalink="https://blog.logrocket.com/writing-end-to-end-tests-for-graphql-servers-using-jest/three-passed-tests-nocdn/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2019/11/three-passed-tests-nocdn.png" data-orig-size="694,210" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="three-passed-tests-nocdn" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2019/11/three-passed-tests-nocdn-300x91.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2019/11/three-passed-tests-nocdn.png" decoding="async" loading="lazy" class="aligncenter wp-image-10289 size-full" src="../Images/a16c29ef61c04af70ff5432b55820d72.png" alt="Passed tests" srcset="https://blog.logrocket.com/wp-content/uploads/2019/11/three-passed-tests-nocdn.png 694w, https://blog.logrocket.com/wp-content/uploads/2019/11/three-passed-tests-nocdn-300x91.png 300w" sizes="(max-width: 694px) 100vw, 694px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/11/three-passed-tests-nocdn.png"/></noscript>
<h3>结论</h3>
<p>这里，我们展示了如何使用Apollo server在GraphQL服务器上用Jest编写端到端测试的细节。</p><div class="code-block code-block-24">
<div class="blog-plug inline-plug graphql-plug"><h2>监控生产中失败和缓慢的GraphQL请求</h2><p>虽然GraphQL有一些调试请求和响应的特性，但确保GraphQL可靠地为您的生产应用程序提供资源是一件比较困难的事情。如果您对确保对后端或第三方服务的网络请求成功感兴趣，</p><a href="https://lp.logrocket.com/blg/graphql-signup" target="_blank">try LogRocket</a><p>.</p><a class="signup" href="https://lp.logrocket.com/blg/graphql-signup" target="_blank" rel="noopener noreferrer"><img src="../Images/432a3823c85b3fb72a206e6236a29f48.png" data-lazy-src="https://files.readme.io/69aa835-Image_2019-11-09_at_1.28.05_PM.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" class=" jetpack-lazy-image" data-original-src="https://files.readme.io/69aa835-Image_2019-11-09_at_1.28.05_PM.png"/><noscript><img data-lazy-fallback="1" src="../Images/432a3823c85b3fb72a206e6236a29f48.png" data-original-src="https://files.readme.io/69aa835-Image_2019-11-09_at_1.28.05_PM.png"/></noscript><img class="alignnone size-full wp-image-46 jetpack-lazy-image" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/><noscript><img data-lazy-fallback="1" class="alignnone size-full wp-image-46" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/></noscript></a><a href="https://lp.logrocket.com/blg/graphql-signup" target="_blank" rel="noopener noreferrer">https://logrocket.com/signup/</a><p>LogRocket 就像是网络和移动应用的DVR，记录下你网站上发生的每一件事。您可以汇总并报告有问题的GraphQL请求，以快速了解根本原因，而不是猜测问题发生的原因。此外，您可以跟踪Apollo客户机状态并检查GraphQL查询的键值对。</p><p>LogRocket检测您的应用程序以记录基线性能计时，如页面加载时间、到达第一个字节的时间、慢速网络请求，还记录Redux、NgRx和Vuex操作/状态。</p><a class="signup" href="https://lp.logrocket.com/blg/graphql-signup" target="_blank" rel="noopener noreferrer">Start monitoring for free</a><p>.</p></div>


</div>
<ul>
<li>没有涵盖所有的测试案例，但是应该与已经存在的内容相似。</li>
<li>本文中的例子没有测试订阅。</li>
<li>写作时使用了大量的重复，以使文章易于理解。然而，在生产代码中，它很容易变得难以管理。</li>
</ul>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
<html>
<head>
<title>How to create a React Native app with PostgreSQL and GraphQL: Part 1 - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>如何用PostgreSQL和GraphQL创建React本地应用程序:第1部分- LogRocket博客</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/create-a-react-native-app-with-postgresql-and-graphql-part-1/#0001-01-01">https://blog.logrocket.com/create-a-react-native-app-with-postgresql-and-graphql-part-1/#0001-01-01</a></blockquote><div><article class="article-post">
<p>在为iOS和Android智能手机开发移动应用程序时，React Native 是一个很好的选择。使用React Native，您可以编写一个在两个平台上都可以工作的应用程序，唯一的区别是视图级别，iOS和Android呈现不同。在这个由两部分组成的系列中，我们将了解如何使用React Native和GraphQL开发应用程序。为此，我们将构建一个简单的笔记应用程序，允许我们的用户添加笔记，查看，编辑和删除它们。</p>
<p>对于第一部分，我们将使用PostgreSQL数据库构建一个GraphQL服务器，作为应用程序的后端。<a href="https://blog.logrocket.com/how-to-create-a-react-native-app-with-postgresql-and-graphql-part-2/">在第二部分</a>中，我们将使用React Native构建一个应用程序，该应用程序将使用我们服务器中的数据。</p>
<p>让我们开始设置服务器。我们项目的文件夹结构将如<a href="https://github.com/jimmykimani/GraphQL-Server-Tutorial-with-Apollo-Server-and-Express/tree/notes/starter-files" target="_blank" rel="noopener noreferrer">本报告</a>所示。</p>
<p>为了构建我们的应用程序，您需要熟悉:</p>
<ul>
<li>NodeJS</li>
<li>表达</li>
<li>数据库</li>
<li>移动开发</li>
</ul>
<h2>如何使用Express设置Apollo服务器</h2>
<p>我们的后端服务器将运行在<a href="https://nodejs.org/en" target="_blank" rel="noopener noreferrer">节点JS </a>和<a href="https://expressjs.com/" target="_blank" rel="noopener noreferrer"> Express </a>上。我们需要安装一些初始依赖项，但首先，我们需要启动我们的应用程序，运行:</p>
<pre>npm init</pre>
<p>现在让我们安装第一组依赖项:</p>
<pre>npm install apollo-server apollo-server-express express graphql cors --save</pre>
<p>我们已经安装的依赖项之一是<code>apollo-server</code>，Apollo Server是使用任何来源的数据为GraphQL客户端快速构建生产就绪、自文档化API的最佳方式。当我们在Express中使用它时，它可能会在几个流行的图书馆中使用，如<a href="https://github.com/hapijs/hapi" target="_blank" rel="noopener noreferrer">哈比神</a>和<a href="https://koajs.com/" target="_blank" rel="noopener noreferrer"> Koa </a>。</p>
<p>现在我们已经准备好开始创建我们的服务器了。将以下代码添加到<code>src/index.js</code>。</p>
<pre>import cors from 'cors';
import express from 'express';
import {
    ApolloServer
} from 'apollo-server-express';

const app = express();

app.use(cors());

const server = new ApolloServer({});

server.applyMiddleware({
    app,
    path: '/graphql'
});

app.listen({
    port: 8000
}, () =&gt; {
    console.log('Apollo Server on http://localhost:8000/graphql');
});</pre>
<p>让我们回顾一下到目前为止我们所拥有的，在上面的代码中，我们已经初始化了一个Express应用程序和一个Apollo服务器实例。使用Apollo Server的<code>applyMiddleware()</code>方法，您可以选择加入任何中间件，在我们的例子中是Express应用程序。此外，您可以指定GraphQL API端点的路径。</p>
<p>你可能还注意到我们将<code>cors</code>应用到了我们的<a href="https://blog.logrocket.com/forget-express-js-opt-for-these-alternatives-instead/" target="_blank" rel="noopener noreferrer"> Express应用</a>，这是为了允许外部域访问我们的应用。</p>
<p>下一步是为Apollo服务器实例定义模式和解析器。但是首先，让我们了解一下模式和解析器。</p>
<h2>(计划或理论的)纲要</h2>
<p>提供给Apollo服务器的<a href="https://graphql.org/learn/schema/" target="_blank" rel="noopener noreferrer"> GraphQL模式</a>是通过GraphQL读写数据的所有可用数据。该模式包含来自强制顶级<code>Query</code>类型的类型定义，该类型允许读取后跟字段和嵌套字段的数据。这些是使用GraphQL模式语言定义的，并允许我们以一种语言不可知的方式谈论GraphQL模式。</p>
<p>以下是我们的<code>schema/notes.js</code>中的内容:</p>
<pre>import {
  gql
} from 'apollo-server-express';

export default gql `
  extend type Query {
    notes: [Note!]
    note(id: ID!): Note!
  }

  type Note {
    id: ID!
    text: String!
  }
`;</pre>
<p>让我们来看看我们的模式定义中需要注意的一些术语。我们已经介绍了<code>Query</code>类型，但是让我们看看其余的:</p>
<ul>
<li><code>notes</code>被定义为<code>[Note!]</code>，它代表一个<code>Note</code>对象的数组。感叹号意味着<strong>不可为空，</strong>这意味着当您查询<code>notes</code>字段时，您总是可以期待一个数组(包含零个或多个项)</li>
<li>每个<code>Note</code>对象包含一个定义为<code>ID</code>的<code>id</code>字段。<code>ID</code>标量类型代表一个惟一的标识符，通常用于重新获取一个对象或作为缓存的键。它的序列化方式与字符串的序列化方式相同。然而，将它定义为<code>ID</code>意味着它不适合人类阅读</li>
<li><code>Note</code>对象还有一个被定义为<code>String</code>的<code>text</code>字段，它是内置的<strong>标量</strong>类型之一，是一个UTF 8字符序列</li>
<li>您还会注意到<code>note</code>字段以<code>(id: ID!)</code>的形式提供了<code>id</code>选项。这允许使用<a href="https://graphql.org/learn/queries/#arguments" target="_blank" rel="noopener noreferrer"> GraphQL参数</a>来细化查询。这允许我们通过在查询中提供它的<code>ID</code>来获取单个音符。参数<em>也是不可空的</em>，因为它必须在获取单个便笺时提供。</li>
</ul>
<p>上述模式应放在<code>src/schema/notes.js</code>中。然后，我们可以在<code>src/schema</code>目录中使用以下代码创建一个<code>index.js</code>文件:</p>
<pre>import { gql } from "apollo-server-express";
    
    import noteSchema from "./notes";
    
    const linkSchema = gql`
      type Query {
        _: Boolean
      }
    
      type Mutation {
        _: Boolean
      }
    
      type Subscription {
        _: Boolean
      }
    `;
    
    export default [linkSchema, noteSchema];</pre>
<h2>下决心者</h2>
<p>解析器负责操作和返回数据，可以把它们看作查询处理程序。<code>Query</code>类型中的每个顶级查询都有一个解析器，但是我们将为每个字段创建自己的解析器。解析器被分组在一个JavaScript对象中，通常称为<strong>解析器映射</strong>。</p>
<p>让我们在<code>src/resolvers</code>中创建一个<code>notes.js</code>文件，并向其中添加以下代码:</p>
<pre>export default {
    Query: {
        notes: (parent, args, {
            models
        }) =&gt; {
            return Object.values(models.notes)
        },
        note: (parent, {
            id
        }, {
            models
        }) =&gt; {
            return models.notes[id]
        }
    }
}</pre>
<p>上述解析器允许我们使用<code>note</code>字段查询单个音符，并使用<code>notes</code>字段提供一个<code>id</code>参数或一组音符。一旦我们使用<a href="https://sequelize.org" target="_blank" rel="noopener noreferrer">序列</a>将我们的应用程序链接到数据库，我们将清理我们的解析器，并添加突变，这将允许我们执行除读取数据之外的操作。目前，这些解决了我们将在<code>src/models/index.js</code>中拥有的伪数据，它包含以下代码:</p>
<pre>let notes = {
    1: {
        id: '1',
        text: 'Hello World',
    },
    2: {
        id: '2',
        text: 'By World',
    },
};

export default {
    notes
};</pre>
<p>现在，我们已经为如何存储数据建立了框架，让我们看看如何使用<a href="https://graphql.org/learn/queries/" target="_blank" rel="noopener noreferrer">查询和变异</a>进行数据操作。</p>
<h2>查询和突变</h2>
<p>GraphQL中的查询和变异允许我们访问和操作GraphQL服务器上的数据。查询负责读取操作，而变异负责创建、更新和删除操作。</p>
<p>为了创建我们的查询和变异，我们必须首先在我们的模式中定义它们。让我们编辑<code>src/schema/notes.js</code>如下:</p>
<pre>import {
  gql
} from 'apollo-server-express';

export default gql `
  extend type Query {
    notes: [Note!]
    note(id: ID!): Note!
  }

  extend type Mutation {
    createNewNote(text: String!): Note!
    deleteNote(id: ID!): Boolean!
    updateNote(id: ID!, text: String!): Note!
  }

  type Note {
    id: ID!
    text: String!
  }
`;</pre>
<p>前面已经定义了查询，所以我们新添加的是<code>Mutation</code>类型。从定义的类型中，您可以了解返回的数据是什么样子的。例如，<code>createNewNote</code>接受一个字符串形式的<code>text</code>参数，并生成和返回一个<code>Note</code>对象，<code>updateNote</code>与此类似，但它也接受<code>id</code>参数，以便找到要更新的注释。同时，<code>deleteNote</code>获取一个用于标识目标笔记的<code>id</code>布尔值，并返回一个指示该笔记是否已被成功删除的布尔值。</p>
<p>这是测试查询的方法。在您的<a href="https://github.com/prisma/graphql-playground" target="_blank" rel="noopener noreferrer"> graphql playground中键入以下代码:</a></p>
<h3>获取所有笔记</h3>
<p>获取并返回所有保存的便笺。</p>
<pre>query {
  notes {
    id
    text
  }
}</pre>
<p>接下来点击<em>执行查询</em>按钮，您应该能够看到以下结果:</p>
<h3>结果</h3>
<pre>{
  "data": {
    "notes": [
      {
        "id": "1",
        "text": "Hello World"
      },
      {
        "id": "3",
        "text": "By World"
      }
    ]
  }
}</pre>
<h3>按id获取便笺</h3>
<p>这将返回一段与给定参数<code>id</code>匹配的数据</p>
<pre>query{
  note(id: "1") {
    id
   text
  }
}</pre>
<h3>结果</h3>
<pre>{
  "data": {
    "note": {
      "id": "1",
      "text": "Hello World"
    }
  }</pre>
<p>接下来，我们需要编写一个突变解析器。让我们这样编辑<code>src/resolvers/notes.js</code> <br/>:</p>
<pre>import uuidv4 from 'uuid/v4';

export default {
    Query: {
        notes: (parent, args, {
            models
        }) =&gt; {
            return Object.values(models.notes)
        },
        note: (parent, {
            id
        }, {
            models
        }) =&gt; {
            return models.notes[id]
        }
    },
    Mutation: {
        createNewNote: (parent, {
            text
        }, {
            models
        }) =&gt; {
            const id = uuidv4();
            const newNote = {
                id,
                text
            }
            models.notes[id] = newNote;
            return newNote;
        },

        deleteNote: (parent, {
            id
        }, {
            models
        }) =&gt; {
            const {
                [id]: note, ...otherNotes
            } = models.notes
            if (!note) {
                return false
            }
            models.notes = otherNotes
            return true
        },
}</pre>
<p>对于<code>createNewNote</code>突变，我们正在使用<code>uuid/v4</code>库生成唯一的<code>id</code>，因此我们需要通过运行以下命令来安装它:</p>
<p><code>npm install uuid/v4 --save</code></p>
<p>解析器接受一个文本参数，生成一个惟一的<code>id</code>并使用它们创建一个<code>Note</code>对象，然后将该对象追加到注释列表中。然后，它返回已经创建的新便笺。</p>
<p><code>deleteNote</code>变异采用一个<code>id</code>参数，找到一个注释并创建一个新的<code>notes</code>对象，没有要删除的注释，并用新的对象替换旧的<code>notes</code>对象。如果没有找到笔记，它返回<code>false</code>，如果找到并删除了笔记，则返回<code>true</code>。</p>
<p><code>updateNote</code>变异将<code>id</code>和<code>text</code>作为参数，并相应地更新<code>notes</code>对象中的<code>Note</code>，最后返回更新后的注释。</p>
<p>当我们在浏览器上运行<code>npm start</code>并转到<code><a href="3000/graphql" target="_blank" rel="noopener noreferrer">localhost:3000/graphql</a></code>来运行我们的应用程序时，我们现在可以通过GraphQL playground访问这些端点。然后，您可以尝试以下操作:</p>
<h3>创建新便笺</h3>
<p>接受文本参数，创建并返回注释。</p>
<pre>mutation {
  createNewNote( text: "Hello GraphQl") {
    id
    text
  }
}</pre>
<h3>结果</h3>
<pre>{
  "data": {
    "createNewNote": {
      "id": "3",
      "text": "Hello GraphQl"
    }
  }
}</pre>
<h3>更新注释</h3>
<p>接受文本和id参数，更新并返回注释。</p>
<pre>mutation {
  updateNote(id:3, text:"Graphql is awesome") {
    id
    text
  }
}</pre>
<h3>结果</h3>
<pre>{
  "data": {
    "updateNote": {
      "id": "4",
      "text": "Graphql is awesome"
    }
  }
}</pre>
<h3>删除注释</h3>
<p>接受id参数并删除匹配的注释。</p>
<pre>mutation {
  deleteNote(id:5)
}</pre>
<h2>添加带序列的PostgreSQL</h2>
<p>我们已经准备好了大部分应用程序，所以接下来我们需要考虑的是如何将数据保存到数据库中。我们的数据库将<a href="https://www.postgresql.org/" target="_blank" rel="noopener noreferrer"> PostgreSQ </a> L，所以继续从他们的网站安装它，然后启动它。</p>
<p>之后，创建一个名为<code>mynotes</code>的数据库。为此，您可以在终端中运行命令<code>psql</code>来打开PosgreSQL CLI。一次开放运行:</p>
<pre>CREATE DATABASE mynotes;
CREATE USER postgres;
GRANT ALL PRIVILEGES ON DATABASE members TO postgres;</pre>
<p>接下来，您需要将Node.js的<a href="https://github.com/brianc/node-postgres" target="_blank" rel="noopener noreferrer">PostgreSQL</a>和<a href="https://github.com/sequelize/sequelize" target="_blank" rel="noopener noreferrer"> Sequelize (ORM) </a>添加到您的项目中。运行:</p>
<pre>npm install pg sequelize --save</pre>
<p>下一步是更新我们的模型，准备链接到数据库，如下所示。该模型定义了存储在数据库中的每条数据的形状:</p>
<pre>const note = (sequelize, DataTypes) =&gt; {
  const Note = sequelize.define("note", {
    text: DataTypes.STRING
  });
  return Note;
};

export default note;</pre>
<p>接下来，从应用程序的<code>src/models/index.js</code>文件中连接到数据库:</p>
<pre>import Sequelize from "sequelize";

const sequelize = new Sequelize(
  process.env.DATABASE,
  process.env.DATABASE_USER,
  process.env.DATABASE_PASSWORD,
  {
    dialect: "postgres"
  }
);

const models = {
  Note: sequelize.import("./notes")
};

Object.keys(models).forEach((key) =&gt; {
  if ("associate" in models[key]) {
    models[key].associate(models);
  }
});

export { sequelize };
export default models;</pre>
<p>您需要定义数据库名称、数据库超级用户和用户密码。您可能还想定义一种数据库方言，因为Sequelize也支持其他数据库。</p>
<p>在同一个文件中，如果您有多个模型(因此有上面的<code>foreEach</code>循环),您可以将所有的模型物理地相互关联，以将它们作为数据库的数据访问层(模型)公开给应用程序。在我们的例子中，我们只有一个模型，但这仍然是很好的了解。</p><div class="code-block code-block-54">
<hr/>
<h3>更多来自LogRocket的精彩文章:</h3>

<hr/></div>
<p>现在让我们在项目的根目录下创建一个<code>.env</code>文件来保存一些关键数据作为环境变量。数据库凭证(数据库名称、数据库超级用户名称、数据库超级用户密码)可以作为环境变量与我们希望运行服务器的端口一起存储。</p>
<p>在<code>.env</code>文件中添加以下变量或根据您的喜好进行更改:</p>
<pre>PORT=3000
DATABASE=mynotes
DATABASE_USER=postgres
DATABASE_PASSWORD=postgres</pre>
<p>接下来，让我们更新<code>src/index.js</code>以在应用程序启动时同步我们的数据库。进行以下更改:</p>
<pre>...
import 'dotenv/config';
import models, {
    sequelize
} from './models';
...

sequelize.sync().then(async () =&gt; {
    app.listen({
        port: 8000 // you could change this to process.env.PORT if you wish
    }, () =&gt; {
        console.log('Apollo Server on http://localhost:8000/graphql');
    });
});</pre>
<p>我们现在已经将应用程序链接到了数据库，所以接下来我们需要做的是替换解析器中的逻辑。</p>
<h2>如何将解析器连接到数据库</h2>
<p>我们以前有虚拟数据，但有了Sequelize，我们现在可以将数据与数据库同步，从而实现数据持久性。为了实现这一点，我们需要更新我们在<code>src/resolvers/notes.js</code>中的解析器来集成Sequelize API。</p>
<pre>export default {
  Query: {
    notes: async (parent, args, { models }) =&gt; {
      return await models.Note.findAll();
    },

    note: async (parent, { id }, { models }) =&gt; {
      return await models.Note.findByPk(id);
    }
  },
  Mutation: {
    createNewNote: async (parent, { text }, { models }) =&gt; {
      return await models.Note.create({
        text
      });
    },

    deleteNote: async (parent, { id }, { models }) =&gt; {
      return await models.Note.destroy({
        where: {
          id
        }
      });
    },
    updateNote: async (parent, { id, text }, { models }) =&gt; {
      await models.Note.update(
        {
          text
        },
        {
          where: {
            id: id
          }
        }
      );
      const updatedNote = await models.Note.findByPk(id, {
        include
      });
      return updatedNote;
    }
  }
};</pre>
<p>你会注意到我们不再需要<code>uuid/v4</code>,因为Sequelize自动处理我们数据库中的id分配。<code>findAll()</code>和<code>findByPk()</code>是数据库操作常用的顺序化方法，<code>findAll()</code>返回某个表中的所有条目，而<code>findPk()</code>识别并返回符合某个标准的条目，比如我们示例中的匹配<code>id</code>。</p>
<p>我们使用的其他顺序化方法包括<code>update()</code>和<code>destroy()</code>来分别更新和删除记录。</p>
<p>除此之外，我们使用<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function" target="_blank" rel="noopener noreferrer"> async/await </a>来实现对数据库的基于承诺的异步Javascript请求。</p>
<h2>结论</h2>
<p>太好了！我们都准备好了，下一步是将我们的GraphQL后端与我们的前端应用程序集成，这将在本教程的第二部分中为移动设备<a href="https://blog.logrocket.com/how-to-create-a-react-native-app-with-postgresql-and-graphql-part-2/">构建。我们将与阿波罗和React Native合作，这应该是令人兴奋的。敬请期待！</a></p><div class="code-block code-block-18">
<div class="blog-plug inline-plug react-native-plug"><h2><a href="https://lp.logrocket.com/blg/react-native-signup"> LogRocket </a>:即时重现React原生应用中的问题。</h2><a class="signup" href="https://lp.logrocket.com/blg/react-native-signup" target="_blank" rel="noopener noreferrer"><img class="alignnone size-full wp-image-46 jetpack-lazy-image" src="../Images/110055665562c1e02069b3698e6cc671.png" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2021/10/react-native-plug_v2-2.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2021/10/react-native-plug_v2-2.png"/><noscript><img data-lazy-fallback="1" class="alignnone size-full wp-image-46" src="../Images/110055665562c1e02069b3698e6cc671.png" data-original-src="https://blog.logrocket.com/wp-content/uploads/2021/10/react-native-plug_v2-2.png"/></noscript></a><p><a href="https://lp.logrocket.com/blg/react-native-signup" target="_blank" rel="noopener noreferrer"> LogRocket </a>是一款React原生监控解决方案，可帮助您即时重现问题、确定bug的优先级并了解React原生应用的性能。</p><p>LogRocket还可以向你展示用户是如何与你的应用程序互动的，从而帮助你提高转化率和产品使用率。LogRocket的产品分析功能揭示了用户不完成特定流程或不采用新功能的原因。</p><p>开始主动监控您的React原生应用— <a class="signup" href="https://lp.logrocket.com/blg/react-native-signup" target="_blank" rel="noopener noreferrer">免费试用LogRocket】。</a></p></div>
</div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

 
</div>    
</body>
</html>
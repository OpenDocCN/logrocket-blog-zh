<html>
<head>
<title>Robust GraphQL mutations the Relay way - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>健壮的GraphQL改变了中继方式</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/robust-graphql-mutations-the-relay-way/#0001-01-01">https://blog.logrocket.com/robust-graphql-mutations-the-relay-way/#0001-01-01</a></blockquote><div><article class="article-post">
<p>当您第一次学习GraphQL时，您可能会陷入一些与API突变设计相关的基本陷阱，这些陷阱可能会在以后反噬您。</p>
<p>幸运的是，如果您在设计GraphQL变体时遵循一些简单的原则，您将会处于良好的状态。</p>
<p>在本文中，我们将浏览脸书的<a href="https://relay.dev/docs/en/graphql-server-specification#mutations" target="_blank" rel="noopener noreferrer"> Relay API spec for mutations </a>,并浏览针对您的突变需要遵循的最佳实践(无论您是否在前端使用Relay)。</p>
<h3>为每个突变使用唯一的输出类型</h3>
<p>起初，在GraphQL中对资源进行突变直接返回该资源似乎很直观。</p>
<p>然而，这导致了脆弱的突变，当您的需求改变时，它不能扩展以将元数据添加到响应或其他资源中。</p>
<p>相反，Relay建议每个变异都有自己独特的输出类型，并带有后缀<code>Payload</code>。</p>
<p>例如，如果您有一个名为<code>CreateUser</code>的突变，它的输出类型将被称为<code>CreateUserPayload</code>。</p>
<p>让我们通过一个例子来更清楚地理解这一点。</p>
<p>假设我们正在构建一个简单的博客API。</p>
<p>首先，您可能会尝试进行如下所示的<code>CreatePost</code>突变:</p>
<pre>mutation CreatePost(title: String!, body: String!): Post</pre>
<p>这看起来很简单:我们的变异只需要一个标题和主体，并直接返回一个<code>Post</code>对象。</p>
<p>当我们意识到我们还想添加当前的查看器对象来刷新查看器主屏幕上的文章列表时，问题就来了。</p>
<p>目前，没有办法向这个输出添加更多的字段，因为输出类型是<code>Post</code>，这可能在许多其他地方使用。</p>
<p>通过不为这个变异使用唯一的输出类型，变异的输出被锁定到<code>Post</code>中的任何字段。</p>
<p>让我们用一个继电器风格的输出类型来看看这个相同的变化。</p>
<p>现在，我们的突变看起来像这样:</p>
<pre>mutation CreatePost(title: String!, body: String!): CreatePostPayload!

type CreatePostPayload {
  post: Post
}</pre>
<p>使用中继样式的输出类型可以很容易地向输出中添加更多的字段。</p>
<p>如果我们想添加当前的查看器，我们可以这样添加:</p>
<pre>mutation CreatePost(title: String!, body: String!): CreatePostPayload!

type CreatePostPayload {
  post: Post
  viewer: Viewer!
}</pre>
<p>这将允许我们发出这样的突变:</p>
<pre>mutation {
  createPost(title: "My New Post", body: "New Post Body") {
    post {
      id
      name
      body
    }
    viewer {
       dashboardPosts {
         id
         name
       }
    }
  }
}</pre>
<p>同样，如果我们想在突变响应中添加更多字段，也没有问题——这种突变是经得起未来考验的！</p>
<h3>对每个突变使用单一的、唯一的输入类型</h3>
<p>虽然对于每个变异来说，拥有一个唯一的输出类型并不重要，但是对于每个变异来说，拥有一个名为<code>input</code>的输入参数也是一个最佳实践。</p>
<p>对于继电器，该参数用突变名称和后缀<code>Input</code>表示。</p>
<p>随着您的变化越来越大，并接受越来越多的参数，在开发过程中保持客户端GraphQL同步会很快变得困难。</p><div class="code-block code-block-54">
<hr/>
<h3>更多来自LogRocket的精彩文章:</h3>

<hr/></div>
<p>像这样将一个大的参数列表移动到一个输入对象中被称为<a href="http://wiki.c2.com/?ParameterObject" target="_blank" rel="noopener noreferrer">参数对象模式</a>，可以帮助简化您的代码。</p>
<p>例如，对于上面的<code>CreatePost</code>变异，我们可以使用一个<code>CreatePostInput</code>类型重写输入，如下所示:</p>
<pre>mutation CreatePost(input: CreatePostInput!): CreatePostPayload!

type CreatePostInput {
  title: String!
  body: String!
}</pre>
<p>这让我们像这样使用我们的突变:</p>
<pre>mutation createPost($input: CreatePostInput!) {
  createPost(input: $input) {
    post { ... }
  }
}</pre>
<p>现在，无论我们在<code>createPost</code>突变中增加多少字段，上面的GraphQL仍然是正确的。</p>
<h3>具有clientMutationId的幂等突变</h3>
<p>中继变异规范中比较奇怪的部分之一是参数<code>clientMutationId</code>，它在变异的输入和输出类型中都出现了。</p>
<p>这个参数非常强大，因为它允许您的突变成为幂等的。</p>
<p>例如，想象一下在我们上面的例子中，一个客户端发送了一个<code>createPost</code>请求，但是在请求期间他们失去了一会儿互联网。客户端如何判断请求是否通过？</p>
<p>当它再次获得网络访问时，它应该重试吗？如果我们发送另一个请求，但是服务器确实收到了前一个请求，我们将会得到一个重复的post。</p>
<p>幸运的是，我们可以用<code>clientMutationId</code>参数解决这个问题。</p>
<p>这要求客户端和服务器都知道这个参数。例如，它允许我们的服务器根据客户端发送的<code>clientMutationId</code>缓存每个客户端的响应。</p>
<p>因此，如果服务器看到两个具有相同<code>clientMutationId</code>的请求，它将意识到第二个请求是重复的，并再次返回缓存的响应，而不重新应用变异的内容。</p>
<p>这允许客户端获得它需要的响应内容，而不会意外地导致变异在服务器上运行多次。</p>
<p>通过使用这个参数，我们基本上使所有的突变都是幂等的。</p>
<p>中继规范还要求在变异的输出中将相同的<code>clientMutationId</code>发送回客户机。</p>
<p>这是为了帮助客户确保他们得到的响应是针对他们请求的突变，以防可能有多个类似的突变快速连续发送。</p>
<h3>使用动词作为突变名称</h3>
<p>虽然Relay没有严格执行，但规范建议使用动词来命名您的变体。</p>
<p>突变在您的API中执行一项操作，因此使用一个主动词来表示通过调用突变将会发生一些变化是有意义的。</p>
<p>例如，你应该用像<code>createPost</code>这样的动词而不是像<code>postCreation</code>这样的名词来命名一个突变。</p>
<h3>标准化实施</h3>
<p>坚持使用Relay规范的另一个好处是，作为GraphQL的通用规范，它很容易实现。</p>
<p>大多数常见的GraphQL库都支持Relay，比如Python的Graphene或者Node/JavaScript的graphql-js。</p>
<p>这些库使得实现上面描述的模式变得容易，所以您不需要担心记住为每个变异创建单独的命名输入和输出类型，或者添加可选的<code>clientMutationId</code>参数。</p>
<p>尽管如此，如果你想使用它，你仍然可以让你的代码知道<code>clientMutationId</code>。</p>
<h3>结论</h3>
<p>即使您在前端使用Apollo或其他GraphQL客户端，Relay也是设计GraphQL API的一个很好的规范。</p>
<p>它得到了GraphQL和Relay的创造者脸书的官方支持。</p>
<p>它们是行业标准，Relay强加于突变的设计意见将有助于确保您的突变是健壮的，并且随着API的增长是经得起未来考验的。</p>
<p>变异快乐！</p><div class="code-block code-block-24">
<div class="blog-plug inline-plug graphql-plug"><h2>监控生产中失败和缓慢的GraphQL请求</h2><p>虽然GraphQL有一些调试请求和响应的特性，但确保GraphQL可靠地为您的生产应用程序提供资源是一件比较困难的事情。如果您对确保对后端或第三方服务的网络请求成功感兴趣，</p><a href="https://lp.logrocket.com/blg/graphql-signup" target="_blank">try LogRocket</a><p>.</p><a class="signup" href="https://lp.logrocket.com/blg/graphql-signup" target="_blank" rel="noopener noreferrer"><img src="../Images/432a3823c85b3fb72a206e6236a29f48.png" data-lazy-src="https://files.readme.io/69aa835-Image_2019-11-09_at_1.28.05_PM.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" class=" jetpack-lazy-image" data-original-src="https://files.readme.io/69aa835-Image_2019-11-09_at_1.28.05_PM.png"/><noscript><img data-lazy-fallback="1" src="../Images/432a3823c85b3fb72a206e6236a29f48.png" data-original-src="https://files.readme.io/69aa835-Image_2019-11-09_at_1.28.05_PM.png"/></noscript><img class="alignnone size-full wp-image-46 jetpack-lazy-image" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/><noscript><img data-lazy-fallback="1" class="alignnone size-full wp-image-46" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/></noscript></a><a href="https://lp.logrocket.com/blg/graphql-signup" target="_blank" rel="noopener noreferrer">https://logrocket.com/signup/</a><p>LogRocket 就像是网络和移动应用的DVR，记录下你网站上发生的每一件事。您可以汇总并报告有问题的GraphQL请求，以快速了解根本原因，而不是猜测问题发生的原因。此外，您可以跟踪Apollo客户机状态并检查GraphQL查询的键值对。</p><p>LogRocket检测您的应用程序以记录基线性能计时，如页面加载时间、到达第一个字节的时间、慢速网络请求，还记录Redux、NgRx和Vuex操作/状态。</p><a class="signup" href="https://lp.logrocket.com/blg/graphql-signup" target="_blank" rel="noopener noreferrer">Start monitoring for free</a><p>.</p></div>


</div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
<html>
<head>
<title>How to use the FlatList component in React - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>如何在React - LogRocket博客中使用FlatList组件</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/how-to-use-flatlist-component-in-react/#0001-01-01">https://blog.logrocket.com/how-to-use-flatlist-component-in-react/#0001-01-01</a></blockquote><div><article class="article-post">
<p><code>FlatList</code>组件是最简单和最常用的React本地组件之一。如果您刚刚开始使用React Native，您必须了解<code>FlatList</code>组件的要点并理解其用途。</p>
<p>在构建app的时候，你会碰到一些列表；这些可以是联系人、用户、活动等的列表。它们看起来很容易实现。但是，显示大型数据集或长列表的性能不是很好。这就是React Native的<code>FlatList</code>组件发挥作用的地方。</p>
<h2><code>flatList</code>组件介绍</h2>
<p><code>FlatList</code>组件用于显示大量的可滚动列表项。在引擎盖下，<code>FlatList</code>组件利用了<code>ScrollView</code>组件。</p>
<p>尽管如此，它还是增加了一个性能因素，比如只呈现屏幕上可见的项目，只更新已经更改的项目。<code>FlatList</code>组件非常适合可能会随时间变化的大型数据项。</p>
<p>使用<code>FlatList</code>组件需要知道两个主要的和必需的道具——<code>data</code>和<code>renderItem</code>。</p>
<p>属性是一个数据数组，用作创建列表的源。<code>renderItem</code>是一个回调函数，它将接受来自<code>data</code>道具的单个项目，并为其呈现一个组件。您不再需要格式化数据—相反，您可以传递一个数组并立即开始呈现。</p>
<h2>基本用法</h2>
<p>假设您有一个包含国家列表的数据数组:</p>
<pre>js
const data = ["Germany", "Australia", "Sri Lanka", "Japan"];</pre>
<p>现在，为了呈现国家，创建一个名为<code>Country</code>的组件:</p>
<pre>jsx
import { Text, View } from "react-native";

const Country = ({ name }) =&gt; (
  &lt;View&gt;
    &lt;Text&gt;{name}&lt;/Text&gt;
  &lt;/View&gt;
);</pre>
<p>在<code>App</code>组件中，让数据进入状态:</p>
<pre>jsx
const data = ["Germany", "Australia", "Sri Lanka", "Japan"];

const App = () =&gt; {
    constructor(props) {
        super(props);

        this.state = {
            countries: data
        }
    }

    render() {
        // ...
    }
}</pre>
<p>接下来，从<code>react-native</code>导入<code>FlatList</code>组件，并使用它来显示国家:</p>
<pre>jsx
import { FlatList, Text, View } from "react-native";

// ...

const App = () =&gt; {
    constructor(props) {
        super(props);

        this.state = {
            countries: data
        }
    }

    render() {
        return (
            &lt;View style={{ flex: 1 }}&gt;
                &lt;FlatList
                    data={this.state.data}
                    renderItem={({item}) =&gt; &lt;Country name={item} /&gt;}
                /&gt;
            &lt;/View&gt;
        );
    }
}</pre>
<p><code>renderItem</code>函数作为单个参数传递，它是一个对象。</p>
<p>您需要的数据在<code>item</code>属性中，因此您可以使用析构来访问数据。在这种情况下，您需要将<code>item</code>传递给<code>Country</code>组件的<code>name</code>支柱。</p>
<p>请注意，根据组件可能采用的道具和道具类型，这在不同的情况下可能会有所不同。</p>
<p>下面，您可以找到这一部分的完整代码:</p>
<pre>jsx
import React from "react";
import { FlatList, Text, View } from "react-native";

const data = ["Germany", "Australia", "Sri Lanka", "Japan"];

const Country = ({ name }) =&gt; (
  &lt;View&gt;
    &lt;Text&gt;{name}&lt;/Text&gt;
  &lt;/View&gt;
);

const App = () =&gt; {
    constructor(props) {
        super(props);

        this.state = {
            countries: data
        }
    }

    render() {
        return (
            &lt;View style={{ flex: 1 }}&gt;
                &lt;FlatList
                    data={this.state.data}
                    renderItem={({item}) =&gt; &lt;Country name={item} /&gt;}
                /&gt;
            &lt;/View&gt;
        );
    }
}
export default App;</pre>
<h2>从API获取数据</h2>
<p>在一个更实际的场景中，您可能希望显示从后端服务获取的数据。在本节中，您将看到一些使用<code>FlatList</code>组件的真实例子。</p>
<p>因此，首先创建一个新项目:</p>
<pre>sh
npx react-native init FlatListDemo</pre>
<p>为了设计组件的样式，使用<code>react-native-elements</code>库:</p>
<pre>sh
yarn add react-native-elements react-native-vector-icons</pre>
<p>首先在屏幕上添加header组件:</p>
<pre>jsx
import { Header } from "react-native-elements";

const AppHeader = () =&gt; (
  &lt;Header
    centerComponent={{ text: "USERS", style: { color: "#fff" } }}
    containerStyle={{ paddingTop: 0, height: 60 }}
  /&gt;
);

const App = () =&gt; {
  return (
    &lt;View&gt;
      &lt;AppHeader /&gt;
    &lt;/View&gt;
  );
};</pre>
<p>接下来，使用JSON占位符API获取用户信息:</p>
<pre>jsx
class App extends Component {
  constructor(props) {
    super(props);

    this.state = {
      users: [],
      isLoading: false,
    };
  }

  fetchUsers = async () =&gt; {
    this.setState({ isLoading: true });
    try {
      const res = await fetch(JSON_API_URL);
      const users = await res.json();
      this.setState({ users });
    } catch (err) {
      console.log(err);
    }
    this.setState({ isLoading: false });
  };

  componentDidMount() {
    this.fetchUsers();
  }

  render() {
    return (
      
        
         (
            
          )}
          keyExtractor={(user) =&gt; user.id}
          ItemSeparatorComponent={() =&gt; }
        /&gt;
      
    );
  }
}</pre>
<p><code>keyExtractor</code> prop检索列表项的键。这些唯一的键通知FlatList组件跟踪项目，这对效率和性能非常重要。</p>
<p>您必须为密钥选择一个唯一的值。在这种情况下，它就是<code>id</code>。默认情况下，<code>keyExtractor</code>会退回到该项的索引，但是您仍然会看到警告。</p>
<p><code>ItemSeperatorComponent</code> prop允许您在列表项之间添加分隔符组件。在本例中，您添加了<code>Divider</code>组件。</p>
<h2>拉至刷新</h2>
<p>拉至刷新是一项基本功能，当用户将屏幕拉至底部并加载新数据时，该功能允许用户刷新屏幕上的数据。</p>
<p>在任何有活动或数据馈送的应用程序中，拉至刷新都是至关重要的，需要刷新才能查看新内容。</p>
<p>当用户在你的应用上花费大量时间浏览提要，并且新数据在某个时间点变得可用时，就会发生这种情况。</p>
<p>在一个<code>FlatList</code>组件中实现拉取刷新功能需要两个道具，即<code>refreshing</code>和<code>onRefresh</code>。</p><div class="code-block code-block-54">
<hr/>
<h3>更多来自LogRocket的精彩文章:</h3>

<hr/></div>
<p>当加载新数据时，<code>refreshing</code>属性告诉<code>FlatList</code>组件显示一个<code>RefreshControl</code>组件。</p>
<p>它接受一个<code>Boolean</code>值。<code>onRefresh</code>是一个回调属性，当<code>refreshing</code>属性设置为<code>true</code>时，它调用函数。该函数必须负责加载新数据和更新<code>FlatList</code>组件中的列表项。</p>
<pre>jsx
class App extends Component {
  constructor(props) {
    super(props);

    this.state = {
      users: [],
      isLoading: false,
    };
  }

  fetchUsers = async () =&gt; {
    this.setState({ isLoading: true });
    try {
      const res = await fetch(JSON_API_URL);
      const users = await res.json();
      this.setState({ users });
    } catch (err) {
      console.log(err);
    }
    this.setState({ isLoading: false });
  };

  componentDidMount() {
    this.fetchUsers();
  }

  render() {
    return (
      
        
         (
            
          )}
          keyExtractor={(user) =&gt; user.id}
          refreshing={this.state.isLoading}
          onRefresh={this.fetchUsers}
          ItemSeparatorComponent={() =&gt; }
        /&gt;
      
    );
  }
}</pre>
<h2>页码</h2>
<p>当有大量数据需要加载时，分页是应用程序中的另一个重要功能。</p>
<p>实际上，你不能一次加载所有的数据——这会让你的应用程序非常慢，效率很低，导致性能差，用户体验差。</p>
<p>对于这个例子，使用伪用户生成器API，因为它有一个分页选项，并且还包含用户头像。</p>
<p>基本思想是在组件中有一个状态变量，它跟踪当前页面，并在用户到达列表末尾时递增。</p>
<p>当用户到达末尾时，用当前页面值获取新的列表数据。这可以使用<code>onEndReached</code>属性在<code>FlatList</code>组件中实现。<code>onEndReached</code>道具接受一个当用户到达列表末尾时触发的功能。</p>
<pre>jsx
const Loader = () =&gt; (
  &lt;View style={{ minHeight: 230, padding: 20 }}&gt;
    &lt;ActivityIndicator
      color="#000"
      size="large"
      style={{ alignSelf: "center" }}
    /&gt;
  &lt;/View&gt;
);

class App extends Component {
  constructor(props) {
    super(props);

    this.state = {
      users: [],
      isLoading: false,
      isLoadingMore: false,
      page: 1,
    };
  }

  fetchUsers = async () =&gt; {
    this.setState({ isLoading: true });
    try {
      const res = await fetch(`${JSON_API_URL}&amp;page=${this.state.page}`);
      const { results: users } = await res.json();
      if (this.state.page === 1) this.setState({ users });
      else this.setState({ users: [...this.state.users, ...users] });
    } catch (err) {
      console.log(err);
    }
    this.setState({ isLoading: false });
  };

  refreshUsers = () =&gt; {
    this.setState({ page: 1 }, () =&gt; {
      this.fetchUsers();
    });
  };

  loadMoreUsers = () =&gt; {
    this.setState({ page: this.state.page + 1, isLoadingMore: true }, () =&gt; {
      this.fetchUsers();
      this.setState({ isLoadingMore: false });
    });
  };

  componentDidMount() {
    this.fetchUsers();
  }

  render() {
    return (
      &lt;View&gt;
        &lt;AppHeader /&gt;
        &lt;FlatList
          data={this.state.users}
          renderItem={({ item }) =&gt; (
            &lt;ListItem
              title={`${item.name.first} ${item.name.last}`}
              subtitle={item.login.username}
              leftAvatar={{ source: { uri: item.picture.thumbnail } }}
            /&gt;
          )}
          keyExtractor={(user) =&gt; user.login.uuid}
          refreshing={this.state.isLoading}
          onRefresh={this.refreshUsers}
          ItemSeparatorComponent={() =&gt; &lt;Divider /&gt;}
          ListFooterComponent={this.state.isLoadingMore &amp;&amp; &lt;Loader /&gt;}
          onEndReachedThreshold={0.1}
          onEndReached={this.loadMoreUsers}
        /&gt;
      &lt;/View&gt;
    );
  }
}</pre>
<h2>结论</h2>
<p>这就是React Native中的<code>FlatList</code>组件。</p>
<p>现在您已经了解了<code>FlatList</code>组件，您可以从任何API获取数据并在您的应用程序中显示列表项。</p>
<p>确保在应用中实现拉刷新和无限滚动，因为这可以改善整体用户体验，并使应用更专业。</p><div class="code-block code-block-17">
<div class="blog-plug inline-plug react-plug" vwo-el-id="26283398190">
<h2 vwo-el-id="41600691720">使用LogRocket消除传统反应错误报告的噪音</h2>
<a href="https://lp.logrocket.com/blg/react-signup-issue-free" target="_blank" vwo-el-id="19356441070">LogRocket
</a><p>是一款React analytics解决方案，可保护您免受数百个误报错误警报的影响，只针对少数真正重要的项目。LogRocket告诉您React应用程序中实际影响用户的最具影响力的bug和UX问题。</p><a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="19356441380">
<img class="first-react-image alignnone size-full wp-image-46 jetpack-lazy-image jetpack-lazy-image--handled" src="../Images/f300c244a1a1cf916df8b4cb02bec6c6.png" vwo-el-id="18272717540" data-lazy-loaded="1" data-original-src="https://files.readme.io/27c94e7-Image_2017-06-05_at_9.46.04_PM.png"/>
</a>
<a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="19356441690">
<img class="second-react-image alignnone size-full wp-image-46 jetpack-lazy-image jetpack-lazy-image--handled" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" vwo-el-id="30720362350" data-lazy-loaded="1" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/>
</a>
<a href="https://lp.logrocket.com/blg/react-signup-issue-free" target="_blank" rel="noopener noreferrer" vwo-el-id="35866400580">LogRocket
</a><p>自动聚合客户端错误、反应错误边界、还原状态、缓慢的组件加载时间、JS异常、前端性能指标和用户交互。然后，LogRocket使用机器学习来通知您影响大多数用户的最具影响力的问题，并提供您修复它所需的上下文。</p><p vwo-el-id="28675661060">关注重要的React bug—<a class="signup" href="https://lp.logrocket.com/blg/react-signup-issue-free" target="_blank" rel="noopener noreferrer" vwo-el-id="40093418840">今天就试试LogRocket】。</a></p>
</div></div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
<html>
<head>
<title>How to extract text from an image using JavaScript - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>如何使用JavaScript - LogRocket Blog从图像中提取文本</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/how-to-extract-text-from-an-image-using-javascript-8fe282fb0e71/#0001-01-01">https://blog.logrocket.com/how-to-extract-text-from-an-image-using-javascript-8fe282fb0e71/#0001-01-01</a></blockquote><div><article class="article-post">
<figure id="6aaf" class="graf graf--figure graf-after--h3">
<p><img decoding="async" class="graf-image jetpack-lazy-image" src="../Images/cf87b5fef25a58d2d13abda5c5a6d06e.png" data-image-id="0*2EQJS-0l2V33aUDr.jpg" data-width="800" data-height="513" data-lazy-src="https://storage.googleapis.com/blog-images-backup/0*2EQJS-0l2V33aUDr.jpg?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://storage.googleapis.com/blog-images-backup/0*2EQJS-0l2V33aUDr.jpg"/></p><noscript><img data-lazy-fallback="1" decoding="async" class="graf-image" src="../Images/cf87b5fef25a58d2d13abda5c5a6d06e.png" data-image-id="0*2EQJS-0l2V33aUDr.jpg" data-width="800" data-height="513" data-original-src="https://storage.googleapis.com/blog-images-backup/0*2EQJS-0l2V33aUDr.jpg"/></noscript><figcaption class="imageCaption">Tesseract.js</figcaption></figure>
<p id="4b0b" class="graf graf--p graf-after--figure">现在许多笔记应用程序都提供给文档拍照并将其转换成文本的功能。我很好奇，决定再深入一点，看看到底发生了什么。</p>
<p id="2d04" class="graf graf--p graf-after--p">做了一点研究后，我遇到了<em class="markup--em markup--p-em">光学字符识别</em>——模式识别和人工智能的一个研究领域，围绕着我们感兴趣的东西，从图像中读取文本。有一个非常有前途的实现<em class="markup--em markup--p-em"> OCR </em>的JavaScript库叫做<em class="markup--em markup--p-em"> tesseract.js </em>，它不仅可以在<em class="markup--em markup--p-em">节点</em>中工作，也可以在浏览器中工作——不需要服务器！</p>
<p id="4293" class="graf graf--p graf-after--p">我想重点研究如何将<em class="markup--em markup--p-em"> tesseract.js </em>添加到应用程序中，然后通过创建一个标记图像中所有匹配单词的函数来检查它的工作表现如何。</p>
<p id="817a" class="graf graf--p graf-after--p">这里有一个<a class="markup--anchor markup--p-anchor" href="https://github.com/maciejcieslar/OCR" target="_blank" rel="noopener noreferrer" data-href="https://github.com/maciejcieslar/OCR">链接</a>到存储库。</p>
<figure id="1eee" class="graf graf--figure graf--layoutOutsetCenter graf-after--p">
<a class="graf-imageAnchor" href="https://logrocket.com/signup/" target="_blank" rel="noopener noreferrer" data-href="https://logrocket.com/signup/" data-action="image-link" data-action-observe-only="true"><img decoding="async" class="graf-image jetpack-lazy-image" src="../Images/94b3e0f84b30cb0d321f60471481ab64.png" data-image-id="1*GPjaPKNNUYHU8EsA3Z0JGA.png" data-width="3212" data-height="750" data-lazy-src="https://storage.googleapis.com/blog-images-backup/1*GPjaPKNNUYHU8EsA3Z0JGA.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://storage.googleapis.com/blog-images-backup/1*GPjaPKNNUYHU8EsA3Z0JGA.png"/><noscript><img data-lazy-fallback="1" decoding="async" class="graf-image" src="../Images/94b3e0f84b30cb0d321f60471481ab64.png" data-image-id="1*GPjaPKNNUYHU8EsA3Z0JGA.png" data-width="3212" data-height="750" data-original-src="https://storage.googleapis.com/blog-images-backup/1*GPjaPKNNUYHU8EsA3Z0JGA.png"/></noscript></a><br/>
</figure>
<h3 id="c72f" class="graf graf--h3 graf-after--figure">Tesseract.js</h3>
<p id="100b" class="graf graf--p graf-after--h3">要将tesseract添加到项目中，我们只需在终端中键入以下内容:</p>
<pre id="6d2f" class="graf graf--pre graf-after--p">npm install tesseract.js</pre>
<p id="1062" class="graf graf--p graf-after--pre">将它导入我们的代码库后，一切都应该像预期的那样工作。至少根据包装上的文件是这样的。但实际上，我一直收到一个关于丢失worker.js文件的错误，由于文档和非常彻底的谷歌搜索没有多大帮助，我使用了一个变通方法。我从<em class="markup--em markup--p-em">node _ modules/tessera CT . js</em>中复制了一个名为<em class="markup--em markup--p-em"> worker.min.js </em>的文件，并将其粘贴到我的<em class="markup--em markup--p-em"> public </em>文件夹中，我从该文件夹中提供我的静态文件。之后，我将<em class="markup--em markup--p-em">宇宙魔方</em>内部的工作者路径改为如下所示:</p>
<pre id="2a9c" class="graf graf--pre graf-after--p">tesseract.workerOptions.workerPath = ‘http://localhost:8080/worker.min.js';</pre>
<p id="74d6" class="graf graf--p graf-after--pre">一切正常。</p>
<h3 id="52c3" class="graf graf--h3 graf-after--p">应用</h3>
<p id="ae16" class="graf graf--p graf-after--h3">让我们创建一个简单的应用程序来识别图像中的文本。我们希望它渲染图像两次。一次向用户显示他们选择的原始图像，一次突出显示匹配的单词。最后，我们还希望我们的应用程序为用户显示迄今为止取得的进展(一直)。</p>
<h3 id="69a6" class="graf graf--h3 graf-after--p">HTML markup</h3>
<pre id="8477" class="graf graf--pre graf-after--h3">&lt;label for="recognition-image-input"&gt;Choose image&lt;/label&gt;
&lt;input type="file" accept="image/jpeg, image/png" id="recognition-image-input" /&gt;&lt;br /&gt;
&lt;label for="recognition-confidence-input"&gt;Confidence&lt;/label&gt;
&lt;input type="number" max="100" min="0" id="recognition-confidence-input" value="70" /&gt;&lt;br /&gt;
&lt;label for="recognition-progress"&gt;File recognition progress:&lt;/label&gt;
&lt;progress id="recognition-progress" max="100" value="0"&gt;0%&lt;/progress&gt;
&lt;div id="recognition-text"&gt;&lt;/div&gt;
&lt;div id="recognition-images"&gt;
  &lt;div id="original-image"&gt;&lt;/div&gt;
  &lt;div id="labeled-image"&gt;&lt;/div&gt;
&lt;/div&gt;</pre>
<p id="6041" class="graf graf--p graf-after--pre"><code>&lt;input type=”file”&gt;</code>让用户选择一张图片和<code>&lt;input type=”number”&gt;</code>——期望的可信度，这表明用户希望应用程序对结果有多确定。不符合置信度要求的匹配不会出现在结果中。<code>&lt;progress&gt;</code>告知用户识别进行到什么程度，<code>&lt;div id=”recognition-text”&gt;</code>显示已识别的文本，<code>&lt;div id=”recognition-images”&gt;</code>充当图像的占位符。</p>
<p id="5bce" class="graf graf--p graf-after--p">通过监听<code>&lt;input type=”file” /&gt;</code>的<code>change</code>事件，我们可以获得用户选择的图像并呈现结果。</p>
<p id="5dae" class="graf graf--p graf-after--p">但是，在此之前，让我们将对HTML元素的引用保存在变量中，以便将来的代码片段更具可读性:</p>
<pre id="51f0" class="graf graf--pre graf-after--p">const recognitionImageInputElement = document.querySelector(
 '#recognition-image-input',
);
const recognitionConfidenceInputElement = document.querySelector(
 '#recognition-confidence-input',
);
const recognitionProgressElement = document.querySelector('#recognition-progress');
const recognitionTextElement = document.querySelector('#recognition-text');
const originalImageElement = document.querySelector('#original-image');
const labeledImageElement = document.querySelector('#labeled-image');</pre>
<h3 id="ccfc" class="graf graf--h3 graf-after--pre">监听更改事件</h3>
<p id="4e3d" class="graf graf--p graf-after--h3">当用户在他们的计算机上选择一个图像时，触发<code>change</code>事件。</p>
<p id="c9d3" class="graf graf--p graf-after--p"><code>&lt;input type=”file”&gt;</code>元素有一个名为files的属性，它保存用户选择的所有文件。然而，我们不接受多个文件，所以在第0个索引处总是只有一个文件。</p>
<pre id="9a87" class="graf graf--pre graf-after--p">recognitionImageElement.addEventListener('change', () =&gt; {
 if (!recognitionImageElement.files) {
   return null;
 }
const file = recognitionImageElement.files[0];
})</pre>
<h3 id="b294" class="graf graf--h3 graf-after--pre">如何识别图像</h3>
<p id="2a01" class="graf graf--p graf-after--h3"><em class="markup--em markup--p-em"> Tesseract </em>有一个名为recognize的方法，它接受两个参数——an<code>imageLike</code>和<code>options</code>。一个<code><a class="markup--anchor markup--p-anchor" href="https://github.com/naptha/tesseract.js#imagelike" target="_blank" rel="noopener noreferrer" data-href="https://github.com/naptha/tesseract.js#imagelike">imageLike</a></code>可以是很多东西。在我们的例子中，我们将使用一个<code>File</code>对象，一旦用户选择了一个图像，这个对象就可用了。<code>options</code>仅用于设置图像的语言或者(在一些高级情况下)改变<em class="markup--em markup--p-em">镶嵌的默认值</em>。然而，我们对此不感兴趣。</p>
<p id="6915" class="graf graf--p graf-after--p">由<em class="markup--em markup--p-em">宇宙魔方</em>识别的每个文本都有一个置信度值(从0到100 ),它告诉我们<em class="markup--em markup--p-em">宇宙魔方</em>对结果有多确定。</p>
<h3 id="0e34" class="graf graf--h3 graf-after--p">关于信心的一个注记</h3>
<p id="ae67" class="graf graf--p graf-after--h3">自信可能会因为两件事而变得棘手。</p>
<p id="a0c2" class="graf graf--p graf-after--p">第一，段落有自己的自信，文字和符号也一样。一行的置信度等于其组成词的置信度中最低的。根据同样的原理，一个单词的置信度等于宇宙魔方最不信任的符号<em class="markup--em markup--p-em">的置信度。</em></p>
<p id="bc11" class="graf graf--p graf-after--p">这意味着，仅仅因为一行的可信度低，并不一定意味着整行都被错误识别——可能只是一个单词引起了麻烦。</p>
<p id="7ccc" class="graf graf--p graf-after--p">其次，置信度表示一个对象与某个角色的相似程度。</p>
<p id="55d3" class="graf graf--p graf-after--p">例如，如果图像是一个人的脸，那么他眼睛的虹膜很有可能被误认为是字母“O”。这通常意味着过滤掉低于给定置信水平的所有内容，只会给我们留下好的匹配。</p>
<h3 id="40e3" class="graf graf--h3 graf-after--p">识别图像</h3>
<p id="e506" class="graf graf--p graf-after--h3">现在我们有了一个文件，让我们通过调用<code>.recognize()</code>方法从中提取文本。此外，通过向<code>.progress()</code>方法添加一个处理程序，我们可以更新<code>&lt;progress&gt;</code>元素。</p>
<pre id="94aa" class="graf graf--pre graf-after--p">return tesseract
  .recognize(file, {
    lang: 'eng',
  })
  .progress(({ progress, status }) =&gt; {
    if (!progress || !status || status !== 'recognizing text') {
      return null;
    }
  const p = (progress * 100).toFixed(2);
  recognitionProgressElement.textContent = `${status}: ${p}%`;
  recognitionProgressElement.value = p;
})</pre>
<p id="8487" class="graf graf--p graf-after--pre">在<code>.progress()</code>处理程序中，我们得到以下信息，<code>progress</code>(一个从0到1的数字)告诉我们处理进行到什么程度，<code>status</code>只是一条消息，告诉我们正在发生什么。</p>
<p id="bd0c" class="graf graf--p graf-after--p">我们将<code>progress</code>乘以100，因此在<code>status</code>中我们看到的是50而不是0.50。</p>
<h3 id="3e43" class="graf graf--h3 graf-after--p">处理结果</h3>
<p id="38bd" class="graf graf--p graf-after--h3">至少可以说，<code>.recognition()</code>方法的结果是令人困惑的。它没有被很好地记录，所以我们必须自己推断一些事情:</p>
<pre id="c087" class="graf graf--pre graf-after--p">{
    blocks: Array[1]
    confidence: 87
    html: "&lt;div class='ocr_page' id='page_1' ..."
    lines: Array[3]
    oem: "DEFAULT"
    paragraphs: Array[1]
    psm: "SINGLE_BLOCK"
    symbols: Array[33]
    text: "Hello World↵from beyond↵the Cosmic Void↵↵"
    version: "3.04.00"
    words: Array[7]
}</pre>
<p id="6829" class="graf graf--p graf-after--pre"><code>html</code>是将提取的文本嵌入HTML标签中。<code>text</code>是提取的文本，<code>paragraphs</code>、<code>words</code>、<code>symbols</code>(分别是文本中的段落、单词和字符)是如下所示的对象数组:</p>
<figure id="0267" class="graf graf--figure graf-after--p">
<p><img decoding="async" class="graf-image jetpack-lazy-image" src="../Images/665f5c979b8a5645e8e9807f9b46a838.png" data-image-id="0*voPrQS3H01X9Qv6k" data-width="796" data-height="1058" data-lazy-src="https://storage.googleapis.com/blog-images-backup/0*voPrQS3H01X9Qv6k?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://storage.googleapis.com/blog-images-backup/0*voPrQS3H01X9Qv6k"/></p><noscript><img data-lazy-fallback="1" decoding="async" class="graf-image" src="../Images/665f5c979b8a5645e8e9807f9b46a838.png" data-image-id="0*voPrQS3H01X9Qv6k" data-width="796" data-height="1058" data-original-src="https://storage.googleapis.com/blog-images-backup/0*voPrQS3H01X9Qv6k"/></noscript><br/>
</figure>
<p id="b289" class="graf graf--p graf-after--figure">我们将使用<code>paragraphs</code>属性在<code>&lt;p&gt;</code>元素中向用户显示提取的文本，并使用<code>words</code>属性创建黑边框，并将它们放在第二张图片上，向用户显示匹配单词的确切位置。</p>
<h3 id="b367" class="graf graf--h3 graf-after--p">向用户显示提取的文本</h3>
<p id="4eea" class="graf graf--p graf-after--h3">我们希望将段落呈现给用户，最好的方法是为每个段落创建一个<code>&lt;p&gt;</code>元素。一个段落有一个<code>text</code>属性，可以设置为<code>&lt;p&gt;</code>元素的<code>textContent</code>。</p>
<p id="0e78" class="graf graf--p graf-after--p">在之前创建的<code>&lt;div id=”#recognition-text”&gt;</code>元素中，我们可以使用<code>.append()</code>方法来呈现段落:</p>
<pre id="bbd6" class="graf graf--pre graf-after--p">const paragraphsElements = res.paragraphs.map(({ text }) =&gt; {
  const p = document.createElement('p');
  p.textContent = text;
  return p;
});
recognitionTextElement.append(...paragraphsElements);</pre>
<h3 id="8857" class="graf graf--h3 graf-after--pre">渲染图像</h3>
<p id="795f" class="graf graf--p graf-after--h3">为了渲染图像，我们必须首先创建它们，因为到目前为止我们只有作为容器的<code>&lt;div&gt;</code>元素:</p>
<pre id="c24d" class="graf graf--pre graf-after--p">const originalImage = document.createElement('img');

const labeledImage = originalImage.cloneNode(true);</pre>
<p id="c359" class="graf graf--p graf-after--pre">然而，设置它们的<code>src</code>属性有一个小问题，因为我们没有指向图像的URL相反，我们有一个<code>File</code>对象。</p>
<p id="5a5a" class="graf graf--p graf-after--p">要在<code>&lt;img&gt;</code>标签中呈现一个<code>File</code>对象，我们必须像这样使用<code>FileReader</code>构造函数:</p>
<pre id="bfb8" class="graf graf--pre graf-after--p">const setImageSrc = (image: HTMLImageElement, imageFile: File) =&gt; {
 return new Promise((resolve, reject) =&gt; {
   const fr = new FileReader();
   fr.onload = function() {
     if (typeof fr.result !== 'string') {
       return reject(null);
     }
     image.src = fr.result;
     return resolve();
   };
   fr.onerror = reject;
   fr.readAsDataURL(imageFile);
 });
};</pre>
<p id="3e78" class="graf graf--p graf-after--pre">我们将<code>File</code>对象传递给<code>.readAsDataURL()</code>方法，然后等待传递给<code>.onload()</code>方法的处理程序触发结果。现在可以将结果设置为图像的<code>src</code>。</p>
<p id="e762" class="graf graf--p graf-after--p">代码将如下所示:</p>
<pre id="ffa1" class="graf graf--pre graf-after--p">const originalImage = document.createElement('img');
await setImageSrc(originalImage, file);
const labeledImage = originalImage.cloneNode(true);</pre>
<h3 id="3d16" class="graf graf--h3 graf-after--pre">标记匹配的单词</h3>
<p id="df8f" class="graf graf--p graf-after--h3">为了显示每个匹配单词的方框，我们必须首先过滤掉每个<code>confidence</code>低于先前设置值的单词(在<code>&lt;input id=”recognition-confidence-input”&gt;</code>元素内):</p>
<pre id="b120" class="graf graf--pre graf-after--p">const wordsElements = res.words
  .filter(({ confidence }) =&gt; {
    return confidence &gt; parseInt(recognitionConfidenceInputElement.value, 10);
})</pre>
<p id="02b5" class="graf graf--p graf-after--pre">然后，由于每个word对象都有一个<code>bbox</code>属性，我们知道每个匹配单词的坐标。坐标为<code>x0</code>、<code>x1</code>、<code>y0</code>、<code>y1</code>，其中:</p>
<p id="a960" class="graf graf--p graf-after--p"><code>x0</code> —水平轴上单词的开始，它成为<code>left</code> CSS属性</p><div class="code-block code-block-54">
<hr/>
<h3>更多来自LogRocket的精彩文章:</h3>

<hr/></div>
<p id="30c2" class="graf graf--p graf-after--p"><code>y0</code> —纵轴上单词的开始，它成为<code>top</code> CSS属性</p>
<p id="3237" class="graf graf--p graf-after--p"><code>x1</code> —横轴上单词的结尾(减去<code>x1</code> — <code>x0</code>得到<code>width</code>属性)</p>
<p id="fc4b" class="graf graf--p graf-after--p"><code>y1</code> —纵轴上单词的结尾(减去<code>y1</code> — <code>y0</code>得到<code>height</code>属性)</p>
<pre id="e047" class="graf graf--pre graf-after--p">const wordsElements = res.words
  .filter(({ confidence }) =&gt; {
    return confidence &gt; parseInt(recognitionConfidenceInputElement.value, 10);
  })
  .map((word) =&gt; {
    const div = document.createElement('div');
    const { x0, x1, y0, y1 } = word.bbox;
    div.classList.add('word-element');
    Object.assign(div.style, {
      top: `${y0}px`,
      left: `${x0}px`,
      width: `${x1 - x0}px`,
      height: `${y1 - y0}px`,
      border: '1px solid black',
      position: 'absolute',
    });
    return div;
});</pre>
<p id="13ea" class="graf graf--p graf-after--pre">最后要做的事情是将图像和单词附加到它们各自的父代，对于原始图像是<code>&lt;div class=”original-image”&gt;</code>，对于带有标记匹配的图像是<code>&lt;div class=”labeled-image”&gt;</code>。</p>
<pre id="37ed" class="graf graf--pre graf-after--p">originalImageElement.appendChild(originalImage);
labeledImageElement.appendChild(labeledImage);
labeledImageElement.append(...wordsElements);</pre>
<p id="43c2" class="graf graf--p graf-after--pre">为了让带有<code>position: absolute;</code>的框显示在图像上，让我们添加所需的CSS:</p>
<pre id="effa" class="graf graf--pre graf-after--p"><strong class="markup--strong markup--pre-strong">#labeled-image</strong> {
position: relative;
}</pre>
<p id="7476" class="graf graf--p graf-after--pre">解决了这个问题，让我们来看看应用程序的运行吧！</p>
<h3 id="13aa" class="graf graf--h3 graf-after--p">测试它</h3>
<p id="7b8f" class="graf graf--p graf-after--h3">我对我最近的<a class="markup--anchor markup--p-anchor" href="https://hackernoon.com/how-i-used-my-programming-skills-to-save-over-8-hours-of-writing-work-7aba154d4232" target="_blank" rel="noopener noreferrer" data-href="https://hackernoon.com/how-i-used-my-programming-skills-to-save-over-8-hours-of-writing-work-7aba154d4232">帖子</a>进行了截图，看看它在单色背景上处理格式良好的文本有多好。</p>
<p id="04cb" class="graf graf--p graf-after--p">原始图像:</p>
<figure id="6dcf" class="graf graf--figure graf-after--p">
<img decoding="async" class="graf-image jetpack-lazy-image" src="../Images/9a16efd99f08a0f6fe588f87104fad66.png" data-image-id="0*jSuCqn4seg1AJJGG" data-width="1412" data-height="422" data-lazy-src="https://storage.googleapis.com/blog-images-backup/0*jSuCqn4seg1AJJGG?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://storage.googleapis.com/blog-images-backup/0*jSuCqn4seg1AJJGG"/><noscript><img data-lazy-fallback="1" decoding="async" class="graf-image" src="../Images/9a16efd99f08a0f6fe588f87104fad66.png" data-image-id="0*jSuCqn4seg1AJJGG" data-width="1412" data-height="422" data-original-src="https://storage.googleapis.com/blog-images-backup/0*jSuCqn4seg1AJJGG"/></noscript><br/>
</figure>
<p id="1915" class="graf graf--p graf-after--figure">标签图像:</p>
<figure id="508a" class="graf graf--figure graf-after--p">
<img decoding="async" class="graf-image jetpack-lazy-image" src="../Images/416b06880b449b245dba8d58b039283c.png" data-image-id="0*WbGdw_a6rStPILOK" data-width="1600" data-height="476" data-lazy-src="https://storage.googleapis.com/blog-images-backup/0*WbGdw_a6rStPILOK?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://storage.googleapis.com/blog-images-backup/0*WbGdw_a6rStPILOK"/><noscript><img data-lazy-fallback="1" decoding="async" class="graf-image" src="../Images/416b06880b449b245dba8d58b039283c.png" data-image-id="0*WbGdw_a6rStPILOK" data-width="1600" data-height="476" data-original-src="https://storage.googleapis.com/blog-images-backup/0*WbGdw_a6rStPILOK"/></noscript><br/>
</figure>
<p id="0bad" class="graf graf--p graf-after--figure">以下是摘录的文本:</p>
<p id="85c9" class="graf graf--p graf-after--p">最近，在脸书上，大卫·斯穆克(Hackernoon的首席执行官)发布了一篇文章，他在文章中列举了2018年的顶级科技故事。他还提到，如果有人想列出一个类似的清单，比如说JavaScript，他很乐意在Hackernoon的首页上展示。</p>
<p id="b53f" class="graf graf--p graf-after--p">为了让更多的人阅读我的作品，我一直在努力。我不能错过这个机会，索尔立即开始计划如何列出这样一个清单。</p>
<p id="ffb1" class="graf graf--p graf-after--p">现在你知道了！</p>
<h3 id="aadf" class="graf graf--h3 graf-after--p">结论</h3>
<p id="9b2e" class="graf graf--p graf-after--h3"><em class="markup--em markup--p-em"> tesseract.js </em>库为我们提供了一个现成的OCR实现，它是高效的，并且在很大程度上是准确的。该库的额外优势是其巨大的灵活性，因为它与<em class="markup--em markup--p-em"> Node.js </em>和浏览器兼容。甚至有一个选项，包括定制的培训数据，可以使它更好地为您的特定应用。</p><div class="code-block code-block-23">
<div class="blog-plug inline-plug node-plug"><h2>200只<img src="../Images/61167b9d027ca73ed5aaf59a9ec31267.png" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2019/10/green-check.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" class=" jetpack-lazy-image" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/10/green-check.png"/> <noscript> <img data-lazy-fallback="1" src="../Images/61167b9d027ca73ed5aaf59a9ec31267.png" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/10/green-check.png"/> </noscript>显示器出现故障，生产中网络请求缓慢</h2><p>部署基于节点的web应用程序或网站是容易的部分。确保您的节点实例继续为您的应用程序提供资源是事情变得更加困难的地方。如果您对确保对后端或第三方服务的请求成功感兴趣，</p><a href="https://lp.logrocket.com/blg/node-signup" target="_blank">try LogRocket</a><p>. </p><a class="signup" href="https://lp.logrocket.com/blg/node-signup" target="_blank" rel="noopener noreferrer"><img src="../Images/cae72fd2a54c5f02a6398c4867894844.png" alt="LogRocket Network Request Monitoring" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2019/12/network-request-filter-2-1.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" class=" jetpack-lazy-image" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/12/network-request-filter-2-1.png"/><noscript><img data-lazy-fallback="1" src="../Images/cae72fd2a54c5f02a6398c4867894844.png" alt="LogRocket Network Request Monitoring" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/12/network-request-filter-2-1.png"/></noscript></a><a href="https://lp.logrocket.com/blg/node-signup" target="_blank" rel="noopener noreferrer">https://logrocket.com/signup/</a><p>LogRocket 就像是网络和移动应用程序的DVR，记录下用户与你的应用程序交互时发生的一切。您可以汇总并报告有问题的网络请求，以快速了解根本原因，而不是猜测问题发生的原因。</p><p>LogRocket检测您的应用程序以记录基线性能计时，如页面加载时间、到达第一个字节的时间、慢速网络请求，还记录Redux、NgRx和Vuex操作/状态。</p><a class="signup" href="https://lp.logrocket.com/blg/node-signup" target="_blank" rel="noopener noreferrer">Start monitoring for free</a><p>. </p></div>
</div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
<html>
<head>
<title>What you need to know about GraphQL enums - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>关于GraphQL enums - LogRocket博客你需要知道什么</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/what-you-need-to-know-about-graphql-enums/#0001-01-01">https://blog.logrocket.com/what-you-need-to-know-about-graphql-enums/#0001-01-01</a></blockquote><div><article class="article-post">
<p>GraphQL是一种语言和一组技术，使现代前端应用程序更容易查询数据。在“<a href="https://2019.stateofjs.com/awards/">2019 JavaScript状态</a>”报告中，GraphQL被命名为开发人员最有兴趣学习的技术，被认为是一种可扩展的生产就绪工具，被许多行业巨头使用，如Github、网飞和Shopify等。</p>
<p>虽然GraphQL的大部分特性都很好理解(例如，指令、输入类型、解析器)，但枚举类型经常被低估，它们的有用性很大程度上是未知的。在本教程中，我们将阐明枚举的重要性，并探索这种简单类型在构建健壮的GraphQL APIs中的重要作用。</p>
<h2 id="our-schema">GraphQL架构</h2>
<p>GraphQL APIs依赖GraphQL模式来公开数据。GraphQL提供了自己的标量类型(<code>Int</code>、<code>Float</code>、<code>String</code>、<code>Boolean</code>和<code>ID</code>，并允许您使用以下关键字创建自己的数据类型。</p>
<ul>
<li><code>type</code>定义查询使用的复杂对象类型(读取数据)</li>
<li><code>input</code>定义被突变用作自变量的输入类型(创建、更新、删除数据)</li>
</ul>
<p>我们所有的例子都基于下面描述用户管理API的模式。</p>
<pre># A User (profile) is linked to some Accounts that carries all authentication information
type Account {
  id: ID! # "!" indicate a non-null (mandatory) field
  authType: String! # "google-auth", "github-auth", "outlook-auth"
  email: String!
  token: String
  archived: Boolean!
  disabled: Boolean!
  verified: Boolean!
}

type User {
  id: ID!
  accounts: [Account!]! # (a non-null array of non-null Account values)
  givenName: String!
}

# a single query is exposed to list all users and filter by status and authType
type Query {
  users(first: Int!, from: ID, status: String, authType: String): [User!]!
}

# we define an "input" type for our updateAccount mutation
input UpdateAccountInput {
  id: ID!
  state: String! # "verified", "disabled", "archived"
}

type Mutation {
  updateAccount(input: UpdateAccountInput!): Account!
}
</pre>
<p>我们的GraphQL API允许我们使用一些可选的过滤器列出所有用户。</p>
<ul>
<li><code>String</code>类型的<code>status</code>，允许我们使用一个简单的<code>String</code>值:<code>“verified”, “disabled”, “archived”</code>来过滤<code>User</code>的多个布尔字段</li>
<li><code>authType</code>基于<code>Account.authType</code></li>
</ul>
<p>API在内部使用<code>Account.authType</code>值(<code>“google-auth”, “github-auth”, “outlook-auth”</code>)来利用适当的提供者进行身份验证，并获取用户配置文件信息。<code>“google-auth”</code>导致了<code>GoogleProfileProvide</code>名称空间下的适当逻辑。</p>
<p>我们可以通过以下方式让前10个活跃用户使用Google。</p>
<pre>   user(first: 10, authType: "google-auth", status: "verified") {
      id
      # ...
   }
</pre>
<p>我们的API还公开了一个<code>updateAccount</code>突变，它允许我们在帐户的生命周期中更新帐户状态。</p>
<p><img data-attachment-id="20065" data-permalink="https://blog.logrocket.com/what-you-need-to-know-about-graphql-enums/graphql-enums-account-authtype-values/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/06/GraphQL-enums-Account-authType-values.png" data-orig-size="631,256" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="GraphQL enums account authType values" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/06/GraphQL-enums-Account-authType-values-300x122.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/06/GraphQL-enums-Account-authType-values.png" decoding="async" class="aligncenter size-full wp-image-20065 jetpack-lazy-image" src="../Images/f8cb4bff7fe2313cfb6d63b41ad38409.png" alt="GraphQL enums Account authType Values" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2020/06/GraphQL-enums-Account-authType-values.png 631w, https://blog.logrocket.com/wp-content/uploads/2020/06/GraphQL-enums-Account-authType-values-300x122.png 300w" data-lazy-sizes="(max-width: 631px) 100vw, 631px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2020/06/GraphQL-enums-Account-authType-values.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/06/GraphQL-enums-Account-authType-values.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="20065" data-permalink="https://blog.logrocket.com/what-you-need-to-know-about-graphql-enums/graphql-enums-account-authtype-values/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/06/GraphQL-enums-Account-authType-values.png" data-orig-size="631,256" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="GraphQL enums account authType values" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/06/GraphQL-enums-Account-authType-values-300x122.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/06/GraphQL-enums-Account-authType-values.png" decoding="async" loading="lazy" class="aligncenter size-full wp-image-20065" src="../Images/f8cb4bff7fe2313cfb6d63b41ad38409.png" alt="GraphQL enums Account authType Values" srcset="https://blog.logrocket.com/wp-content/uploads/2020/06/GraphQL-enums-Account-authType-values.png 631w, https://blog.logrocket.com/wp-content/uploads/2020/06/GraphQL-enums-Account-authType-values-300x122.png 300w" sizes="(max-width: 631px) 100vw, 631px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/06/GraphQL-enums-Account-authType-values.png"/></noscript>
<p>该模式按原样运行。然而，我们可以通过利用GraphQL枚举使它更加健壮。</p>
<h2 id="why-using-enums">为什么使用枚举？</h2>
<p>虽然当使用<code>String</code>、<code>Account.authType</code>和<code>UpdateAccountInput.state</code>时，我们可以期望得到特定的值，但这会在多个层面上引入问题。</p>
<h3>字符串区分大小写，会破坏GraphQL验证</h3>
<p>下面是一个如何使用<code>users</code>查询的例子。</p>
<pre>query {
  users(first: 10, status: "Verified") {
   id
  }
}
</pre>
<p>在客户端(例如，Apollo)，这个查询是完全有效的。然而，你能发现这个错别字吗？</p>
<p><code>status</code>值<code>“Verified”</code>，应该写成<code>“verified”</code>。</p>
<p>在这里使用自由格式的<code>String</code>类型可能会触发意外的500、静默错误，或者更糟的是，安全漏洞。</p>
<p>为了防止这种情况，我们必须向我们的<code>users</code>查询解析器添加一些验证逻辑。</p>
<pre>interface UsersArgs {
  first: number,
  from?: string,
  status?: String,
  authType?: string,
}

const STATUSES = ['', '', ]

export const resolvers = {
  Query: {
    users: (_record: never, args: UsersArgs, _context: never) {
      if (args?.status &amp;&amp;  !STATUSES.includes(args.status)) {
        // throw error
      }
      // ...
    }
  }
}
</pre>
<p>这是适得其反的，因为基于GraphQL类型的模式的主要价值是提供开箱即用的操作和数据验证。使用枚举将状态值限制在一组给定的已定义值内，并避免重复的验证逻辑。</p>
<h3 id="exposing-internal-values">公开内部值</h3>
<p>我们看到<code>Account.authType</code>依赖于<code>String</code>类型，这导致了下面的<code>users</code>查询。</p>
<pre>query {
  users(first: 10, authType: "google-auth") {
   id
  }
}
</pre>
<p>这种模式不是最佳的，因为公开内部值违背了API应该公开一个简单的、解耦的数据接口的原则。</p><div class="code-block code-block-54">
<hr/>
<h3>更多来自LogRocket的精彩文章:</h3>

<hr/></div>
<p>同样，我们可以改进我们的<code>users</code>查询解析器，以允许过滤公共友好的值。</p>
<pre>interface UsersArgs {
  first: number,
  from?: string,
  status?: String,
  authType?: string,
}

const AUTH_TYPES_FILTER_MAP = {
   'GOOGLE': 'google-auth',
   'GITHUB': 'github-auth,
   'OUTLOOK': 'outlook-auth',
}

export const resolvers = {
  Query: {
    users: (_record: never, args: UsersArgs, _context: never) {
      // does both mapping and validation (invalid value will be ignored)
      const authType = AUTH_TYPES_FILTER_MAP[args.authType]
      // ...
    }
  }
}
</pre>
<p>这将允许以下查询。</p>
<pre>query {
  users(first: 10, authType: "GOOGLE") {
   id
  }
}
</pre>
<p>然而，在这里，我们必须再次构建一个已经由GraphQL通过enums提供的特性。</p>
<p>在下一节中，我们将通过将我们的模式迁移到枚举来演示如何将枚举映射到内部值。</p>
<h3 id="discoverability-issue-typescript-graphiql-explorer">可发现性问题(类型脚本、图形/资源管理器)</h3>
<p>依赖<code>String</code>类型获得基于过滤器或选择的值的最后一个缺点是可发现性。</p>
<p>如果您有一个依赖于<code>String</code>类型的<code>UpdateAccountInput.status</code>，GraphQL将无法在自省查询期间检查<code>UpdateAccountInput.status</code>的可能值，因为只有解析器知道它们。</p>
<p><a href="https://graphql.org/learn/introspection/" target="_blank" rel="noopener noreferrer"> GraphQL自省</a>是GraphQL的核心特性之一，它允许客户端通过执行GraphQL查询(inception)来动态检查模式定义。</p>
<p>下面是一个例子，列出了我们的模式中定义的所有查询:</p>
<pre>query {
  __schema {
    queryType {
      fields {
        name
        args {
          name
          type {
            name
            description
          }
        }
        description
        deprecationReason
      }
    }
  }
}

{
  "data": {
    "__schema": {
      "queryType": {
        "fields": [
          {
            "args": [
              {
                "name": "authType",
                "type": {
                  "name": "String",
                  "description": null
                }
              },
              {
                "name": "first",
                "type": {
                  "name": null,
                  "description": null
                }
              },
              {
                "name": "from",
                "type": {
                  "name": "ID",
                  "description": null
                }
              },
              {
                "name": "status",
                "type": {
                  "name": "String",
                  "description": null
                }
              }
            ],
            "deprecationReason": null,
            "name": "users",
            "description": "perform the action: \"users\""
          }
        ]
      }
    }
  }
}
</pre>
<p>像GraphiQL这样的工具使用自省来提供自动完成功能。<a href="https://graphql-code-generator.com/" target="_blank" rel="noopener noreferrer"> GraphQL代码生成器</a>也用它来生成TypeScript类型。</p>
<p>类型不允许我们检查可能的值。</p>
<p><img data-attachment-id="20067" data-permalink="https://blog.logrocket.com/what-you-need-to-know-about-graphql-enums/string-types-discoverability-issue/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/06/string-types-discoverability-issue.png" data-orig-size="730,204" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="String types discoverability issue" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/06/string-types-discoverability-issue-300x84.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/06/string-types-discoverability-issue.png" decoding="async" class="aligncenter size-full wp-image-20067 jetpack-lazy-image" src="../Images/4ae6a2796931afedf63c81e9dbf65b1a.png" alt="String Types Discoverability Issue" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2020/06/string-types-discoverability-issue.png 730w, https://blog.logrocket.com/wp-content/uploads/2020/06/string-types-discoverability-issue-300x84.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2020/06/string-types-discoverability-issue.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/06/string-types-discoverability-issue.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="20067" data-permalink="https://blog.logrocket.com/what-you-need-to-know-about-graphql-enums/string-types-discoverability-issue/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/06/string-types-discoverability-issue.png" data-orig-size="730,204" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="String types discoverability issue" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/06/string-types-discoverability-issue-300x84.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/06/string-types-discoverability-issue.png" decoding="async" loading="lazy" class="aligncenter size-full wp-image-20067" src="../Images/4ae6a2796931afedf63c81e9dbf65b1a.png" alt="String Types Discoverability Issue" srcset="https://blog.logrocket.com/wp-content/uploads/2020/06/string-types-discoverability-issue.png 730w, https://blog.logrocket.com/wp-content/uploads/2020/06/string-types-discoverability-issue-300x84.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/06/string-types-discoverability-issue.png"/></noscript>
<p>GraphQL枚举是自省的，允许应用程序自动完成可能的值并生成相应的TypeScript类型。</p>
<h2 id="let’s-migrate-to-enums">迁移到枚举</h2>
<p>依赖于<code>String</code>可能会导致安全问题、解析器端不必要的验证逻辑以及糟糕的开发人员体验。</p>
<p>让我们通过迁移到枚举来使我们的GraphQL模式更加健壮。</p>
<h3 id="how-to-use-enums">如何使用枚举</h3>
<p>GraphQL枚举可以使用<code>enum</code>关键字来定义。</p>
<pre>enum AuthType {
   GOOGLE
   GITHUB
   OUTLOOK
}
</pre>
<p>根据<a href="http://spec.graphql.org/June2018/#EnumValue" target="_blank" rel="noopener noreferrer">官方规范</a>，您应该使用全大写约定来命名枚举值。枚举值不需要任何公共前缀，因为它们是由枚举的名称命名的。</p>
<h3 id="update-our-schema">更新模式</h3>
<p>让我们来看看新的基于枚举的模式:</p>
<pre>enum AuthType {
   GOOGLE
   GITHUB
   OUTLOOK
}

# A User (profile) is linked to some Accounts that carries all authentication information
type Account {
  id: ID! # "!" indicate a non-null (mandatory) field
  authType: AuthType!
  email: String!
  token: String
  archived: Boolean!
  disabled: Boolean!
  verified: Boolean!
}

type User {
  id: ID!
  accounts: [Account!]! # (a non-null array of non-null Account values)
  givenName: String!
}

# a single query is exposed to list all users and filter by status and authType
type Query {
  users(first: Int!, from: ID, status: String, authType: String): [User!]!
}

enum AccountState {
   VERIFIED,
   DISABLED,
   ARCHIVED
}

# we define an "input" type for our updateAccount mutation
input UpdateAccountInput {
  id: ID!
  state: AccountState!
}

type Mutation {
  updateAccount(input: UpdateAccountInput!): Account!
}
</pre>
<p><strong>枚举内部值</strong></p>
<p>枚举值解析(在解析器和客户端)是一个实现细节，这意味着每个库选择如何将给定的枚举值解析为特定于语言的值。</p>
<p>使用Apollo Server，每个枚举值都将被解析为它的等效字符串。</p>
<ul>
<li><code>AuthType.GOOGLE</code>解析为<code>“GOOGLE”</code></li>
<li><code>AuthType.GITHUB</code>解析为<code>“GITHUB”</code></li>
<li><code>AuthType.OUTLOOK</code>解析为<code>“OUTLOOK”</code></li>
</ul>
<p>然而，我们的API期望被操纵的内部值(<code>“google-auth”, “github-auth”, “outlook-auth”</code>)适当地运行。</p>
<p>根据<a href="https://www.apollographql.com/docs/graphql-tools/scalars/#internal-values" target="_blank" rel="noopener noreferrer">官方文档</a>，Apollo Server使您能够提供enum解析器，如下图所示，我们更新了<code>users</code>查询解析器。</p>
<p>JavaScript版本:</p>
<pre>export const resolvers = {
  AuthType: {
   GOOGLE: 'google-auth',
   GITHUB: 'github-auth',
   OUTLOOK: 'outlook-auth',
  },
  Query: {
    users: (_record, args, _context) {
      // args.authType will always be 'google-auth' or  'github-auth' or 'outlook-auth'
      // ...
    }
  }
}
</pre>
<p>TypeScript版本:</p>
<pre>enum AuthType {
 GOOGLE =  'google-auth',
 GITHUB =  'github-auth',
 OUTLOOK = 'outlook-auth',
}

interface UsersArgs {
  first: number,
  from?: string,
  status?: String,
  authType?: AuthType,
}

export const resolvers = {
  AuthType,
  Query: {
    users: (_record: never, args: UsersArgs, _context: never) {
      // args.authType will always be 'google-auth' or  'github-auth' or 'outlook-auth'
      // ...
    }
  }
}
</pre>
<p>请注意，使用TypeScript，枚举类型可以作为解析器直接传递。</p>
<p>对于输入和输出数据(<code>Mutation</code>参数和<code>Query</code>返回的数据)，Apollo服务器会将枚举值解析为其正确的内部值(<code>resolvers.AuthType</code>)。</p>
<p>现在我们的模式依赖于枚举，让我们看看它是如何改进我们的查询和突变用法的。</p>
<h2 id="let’s-query-with-enums">使用枚举查询</h2>
<p>我们现在可以查询我们的用户，并使用我们的<code>AuthType</code> enum进行过滤。</p>
<pre>query {
  users (first: 10, authType: GOOGLE) {
    id
  }
}
</pre>
<p>我们的查询现在是安全的、无类型的、完全可发现的。</p>
<p id="gdcalert4"><img data-attachment-id="20069" data-permalink="https://blog.logrocket.com/what-you-need-to-know-about-graphql-enums/graphql-enums-typescript-types-generation-2/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/06/graphql-enums-typescript-types-generation-1.png" data-orig-size="730,245" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Typoless enums query" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/06/graphql-enums-typescript-types-generation-1-300x101.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/06/graphql-enums-typescript-types-generation-1.png" decoding="async" class="aligncenter size-full wp-image-20069 jetpack-lazy-image" src="../Images/f2d6e180e798063235935466beb199b3.png" alt="GraphQL Enums TypeScript Types Generation" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2020/06/graphql-enums-typescript-types-generation-1.png 730w, https://blog.logrocket.com/wp-content/uploads/2020/06/graphql-enums-typescript-types-generation-1-300x101.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2020/06/graphql-enums-typescript-types-generation-1.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/06/graphql-enums-typescript-types-generation-1.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="20069" data-permalink="https://blog.logrocket.com/what-you-need-to-know-about-graphql-enums/graphql-enums-typescript-types-generation-2/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/06/graphql-enums-typescript-types-generation-1.png" data-orig-size="730,245" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Typoless enums query" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/06/graphql-enums-typescript-types-generation-1-300x101.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/06/graphql-enums-typescript-types-generation-1.png" decoding="async" loading="lazy" class="aligncenter size-full wp-image-20069" src="../Images/f2d6e180e798063235935466beb199b3.png" alt="GraphQL Enums TypeScript Types Generation" srcset="https://blog.logrocket.com/wp-content/uploads/2020/06/graphql-enums-typescript-types-generation-1.png 730w, https://blog.logrocket.com/wp-content/uploads/2020/06/graphql-enums-typescript-types-generation-1-300x101.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/06/graphql-enums-typescript-types-generation-1.png"/></noscript>
<p>但是枚举值<code>String</code>无效。使用枚举类型的字段需要枚举引用，因此传递枚举值被认为是无效的。</p>
<p><img data-attachment-id="20067" data-permalink="https://blog.logrocket.com/what-you-need-to-know-about-graphql-enums/string-types-discoverability-issue/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/06/string-types-discoverability-issue.png" data-orig-size="730,204" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="String types discoverability issue" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/06/string-types-discoverability-issue-300x84.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/06/string-types-discoverability-issue.png" decoding="async" class="aligncenter size-full wp-image-20067 jetpack-lazy-image" src="../Images/4ae6a2796931afedf63c81e9dbf65b1a.png" alt="String Types Discoverability Issue" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2020/06/string-types-discoverability-issue.png 730w, https://blog.logrocket.com/wp-content/uploads/2020/06/string-types-discoverability-issue-300x84.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2020/06/string-types-discoverability-issue.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/06/string-types-discoverability-issue.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="20067" data-permalink="https://blog.logrocket.com/what-you-need-to-know-about-graphql-enums/string-types-discoverability-issue/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/06/string-types-discoverability-issue.png" data-orig-size="730,204" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="String types discoverability issue" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/06/string-types-discoverability-issue-300x84.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/06/string-types-discoverability-issue.png" decoding="async" loading="lazy" class="aligncenter size-full wp-image-20067" src="../Images/4ae6a2796931afedf63c81e9dbf65b1a.png" alt="String Types Discoverability Issue" srcset="https://blog.logrocket.com/wp-content/uploads/2020/06/string-types-discoverability-issue.png 730w, https://blog.logrocket.com/wp-content/uploads/2020/06/string-types-discoverability-issue-300x84.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/06/string-types-discoverability-issue.png"/></noscript> <img data-attachment-id="20072" data-permalink="https://blog.logrocket.com/what-you-need-to-know-about-graphql-enums/enum-error-prompt/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/06/enum-error-prompt.png" data-orig-size="730,170" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Enum error prompt" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/06/enum-error-prompt-300x70.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/06/enum-error-prompt.png" decoding="async" class="aligncenter size-full wp-image-20072 jetpack-lazy-image" src="../Images/4101983fb2703168343a39652812359a.png" alt="Enum Error Prompt" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2020/06/enum-error-prompt.png 730w, https://blog.logrocket.com/wp-content/uploads/2020/06/enum-error-prompt-300x70.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2020/06/enum-error-prompt.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/06/enum-error-prompt.png"/><noscript><img data-lazy-fallback="1" data-attachment-id="20072" data-permalink="https://blog.logrocket.com/what-you-need-to-know-about-graphql-enums/enum-error-prompt/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/06/enum-error-prompt.png" data-orig-size="730,170" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Enum error prompt" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/06/enum-error-prompt-300x70.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/06/enum-error-prompt.png" decoding="async" loading="lazy" class="aligncenter size-full wp-image-20072" src="../Images/4101983fb2703168343a39652812359a.png" alt="Enum Error Prompt" srcset="https://blog.logrocket.com/wp-content/uploads/2020/06/enum-error-prompt.png 730w, https://blog.logrocket.com/wp-content/uploads/2020/06/enum-error-prompt-300x70.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/06/enum-error-prompt.png"/></noscript>
<h2 id="bonus-typescript-generations">额外收获:打字稿生成</h2>
<p>GraphQL枚举是可内省的，如下所示。</p>
<p id="gdcalert6"><img data-attachment-id="20075" data-permalink="https://blog.logrocket.com/what-you-need-to-know-about-graphql-enums/introspectable-graphql-enums/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/06/introspectable-graphql-enums.png" data-orig-size="730,253" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Introspectable GraphQL enums" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/06/introspectable-graphql-enums-300x104.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/06/introspectable-graphql-enums.png" decoding="async" class="aligncenter size-full wp-image-20075 jetpack-lazy-image" src="../Images/e71e599575c6c22f0299f776643b0452.png" alt="Introspectable GraphQL enums" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2020/06/introspectable-graphql-enums.png 730w, https://blog.logrocket.com/wp-content/uploads/2020/06/introspectable-graphql-enums-300x104.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2020/06/introspectable-graphql-enums.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/06/introspectable-graphql-enums.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="20075" data-permalink="https://blog.logrocket.com/what-you-need-to-know-about-graphql-enums/introspectable-graphql-enums/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/06/introspectable-graphql-enums.png" data-orig-size="730,253" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Introspectable GraphQL enums" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/06/introspectable-graphql-enums-300x104.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/06/introspectable-graphql-enums.png" decoding="async" loading="lazy" class="aligncenter size-full wp-image-20075" src="../Images/e71e599575c6c22f0299f776643b0452.png" alt="Introspectable GraphQL enums" srcset="https://blog.logrocket.com/wp-content/uploads/2020/06/introspectable-graphql-enums.png 730w, https://blog.logrocket.com/wp-content/uploads/2020/06/introspectable-graphql-enums-300x104.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/06/introspectable-graphql-enums.png"/></noscript>
<p>自省枚举意味着像<a href="https://graphql-code-generator.com/" target="_blank" rel="noopener noreferrer"> GraphQL代码生成器</a>这样的工具会为你的前端应用程序生成相应的TypeScript枚举类型。</p>
<p>使用我们的模式，GraphQL代码生成器将能够创建相应的TypeScript枚举:</p>
<pre>export enum AuthType {
 GOOGLE =  'google-auth',
 GITHUB =  'github-auth',
 OUTLOOK = 'outlook-auth',
}
</pre>
<p>这对于以后的使用会很方便(<code>useQuery()</code>，<code>useMutation()</code>):</p>
<pre>const ActiveUsersList = () =&gt; {
  const { loading, data } = useQuery(
    usersQueryDocument,
    {
      variables: {
        first: 10,
        authType: AuthType.GOOGLE,
      }
    })

  // ...
}
</pre>
<p>同时依赖GraphQL枚举和TypeScript生成的枚举有助于增强开发人员的体验。</p>
<h2 id="conclusion">摘要</h2>
<p>即使在小的GraphQL APIs上，比如用户管理API，枚举也带来了很多一致性，并使您的模式更加健壮。</p>
<p>在本教程中，我们探索了GraphQL枚举如何帮助:</p>
<ul>
<li><strong>提供更健壮、更易发现的API </strong> —模式中每个基于列表或过滤的字段都应该利用枚举来避免安全性、与输入错误相关的问题和可发现性问题。使用枚举是充分利用GraphQL强大功能的一个很好的例子:语义操作和动态数据验证</li>
<li><strong>公开一个简单的接口</strong>—API的主要目标是为数据或复杂系统提供一个简化的接口。GraphQL更是如此，它为前端世界带来了自然的、类似JSON的API。当涉及到过滤时，GraphQL枚举是将内部值抽象为简单选择的极好方法</li>
<li><strong>维护精简解析器</strong> —在构建GraphQL API时，重要的是不要重新实现GraphQL提供的特性。如果GraphQL的主要特性是操作验证(例如，操作询问、参数的结构)和数据验证(对于输入和输出)，那么解析器应该精简，只关注业务逻辑(例如，数据操作、额外复杂的验证)</li>
</ul>
<p> </p><div class="code-block code-block-24">
<div class="blog-plug inline-plug graphql-plug"><h2>监控生产中失败和缓慢的GraphQL请求</h2><p>虽然GraphQL有一些调试请求和响应的特性，但确保GraphQL可靠地为您的生产应用程序提供资源是一件比较困难的事情。如果您对确保对后端或第三方服务的网络请求成功感兴趣，</p><a href="https://lp.logrocket.com/blg/graphql-signup" target="_blank">try LogRocket</a><p>.</p><a class="signup" href="https://lp.logrocket.com/blg/graphql-signup" target="_blank" rel="noopener noreferrer"><img src="../Images/432a3823c85b3fb72a206e6236a29f48.png" data-lazy-src="https://files.readme.io/69aa835-Image_2019-11-09_at_1.28.05_PM.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" class=" jetpack-lazy-image" data-original-src="https://files.readme.io/69aa835-Image_2019-11-09_at_1.28.05_PM.png"/><noscript><img data-lazy-fallback="1" src="../Images/432a3823c85b3fb72a206e6236a29f48.png" data-original-src="https://files.readme.io/69aa835-Image_2019-11-09_at_1.28.05_PM.png"/></noscript><img class="alignnone size-full wp-image-46 jetpack-lazy-image" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/><noscript><img data-lazy-fallback="1" class="alignnone size-full wp-image-46" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/></noscript></a><a href="https://lp.logrocket.com/blg/graphql-signup" target="_blank" rel="noopener noreferrer">https://logrocket.com/signup/</a><p>LogRocket 就像是网络和移动应用的DVR，记录下你网站上发生的每一件事。您可以汇总并报告有问题的GraphQL请求，以快速了解根本原因，而不是猜测问题发生的原因。此外，您可以跟踪Apollo客户机状态并检查GraphQL查询的键值对。</p><p>LogRocket检测您的应用程序以记录基线性能计时，如页面加载时间、到达第一个字节的时间、慢速网络请求，还记录Redux、NgRx和Vuex操作/状态。</p><a class="signup" href="https://lp.logrocket.com/blg/graphql-signup" target="_blank" rel="noopener noreferrer">Start monitoring for free</a><p>.</p></div>


</div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
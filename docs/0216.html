<html>
<head>
<title>Robust, scalable tests for React applications - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>React应用程序的健壮、可扩展测试</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/robust-scalable-tests-react-applications/#0001-01-01">https://blog.logrocket.com/robust-scalable-tests-react-applications/#0001-01-01</a></blockquote><div><div class="section-content">
<div class="section-inner sectionLayout--insetColumn">
<p>有了React和围绕它出现的测试工具生态系统，最终有可能构建健壮的、可伸缩的测试，为代码正确性提供强有力的保证。</p>
<figure class="graf graf--figure"><img decoding="async" class="graf-image jetpack-lazy-image" src="../Images/4bb60b7cf651150c21c129683ea130d1.png" data-image-id="1*y_7bdnRYNi_ZDXPLClI2uQ.png" data-width="704" data-height="541" data-is-featured="true" data-lazy-src="https://storage.googleapis.com/blog-images-backup/1*y_7bdnRYNi_ZDXPLClI2uQ.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://storage.googleapis.com/blog-images-backup/1*y_7bdnRYNi_ZDXPLClI2uQ.png"/><noscript><img data-lazy-fallback="1" decoding="async" class="graf-image" src="../Images/4bb60b7cf651150c21c129683ea130d1.png" data-image-id="1*y_7bdnRYNi_ZDXPLClI2uQ.png" data-width="704" data-height="541" data-is-featured="true" data-original-src="https://storage.googleapis.com/blog-images-backup/1*y_7bdnRYNi_ZDXPLClI2uQ.png"/></noscript><figcaption class="imageCaption">The number of possibilities to test on the front end grows exponentially. User input, network, and race conditions can all introduce bugs.</figcaption></figure>
<p class="graf graf--p">当我们决定开始为我们的应用程序编写UI测试时，我们发现没有任何很好的资源来解释React测试的各种技术。本系列的目标是讨论这些技术，并概述如何开始。</p>
<p>在现代JavaScript前端中，我们可能想要编写3种类型的测试:</p>
<ul class="postList">
<li class="graf graf--li">单元测试:这些测试验证单个组件或模块的行为。有许多工具和库使得编写这些测试变得更加容易。</li>
<li class="graf graf--li">应用程序测试:应用程序和业务逻辑很难用单元测试来全面测试。应用程序测试(通常称为“集成测试”)测试您的整个应用程序代码，通常使用模拟的API。</li>
<li class="graf graf--li">端到端测试:如果您想要测试您的整个应用程序(前端和后端)，端到端测试允许您断言您的整个系统按预期工作。</li>
</ul>
<p class="graf graf--p">在这篇文章中，我将讨论单元测试以及何时/如何编写单元测试。</p>
<h3 class="graf graf--h3">单元测试</h3>
<p class="graf graf--p">在React中，单元测试分为几个不同的类别:</p>
<ul class="postList">
<li class="graf graf--li">逻辑测试</li>
<li class="graf graf--li">组件测试</li>
<li class="graf graf--li">故事书测试</li>
</ul>
<p class="graf graf--p">想象我们正在构建一个“计算器”应用程序。这些测试中的每一个都有稍微不同的目的:</p>
<ul class="postList">
<li class="graf graf--li">逻辑测试:计算器能正确地计算一个等式并返回正确的结果吗？</li>
<li class="graf graf--li">组件测试:当我点击一个按钮时，一个数字会出现在计算器中吗？</li>
<li class="graf graf--li">故事书测试:当用户将两个数字相加时，计算器看起来正确吗？</li>
</ul>
</div>
<p class="section-inner sectionLayout--outsetColumn">逻辑测试</p>
<div class="section-inner sectionLayout--insetColumn">
<h3 class="graf graf--h3">逻辑测试是最直接的单元测试。最简单的情况可能是这样的:</h3>
<p class="graf graf--p">这些代码通常写起来很快，在处理有很多边缘情况的复杂代码时非常有用。重要的是不要过度进行这些测试——您应该只为具有稳定API的代码编写测试。如果函数的目的或输入不断变化，测试的保证将变得毫无意义。</p>
<pre class="graf graf--pre"><code>import { expect } from 'chai';
function addTwoNumbers(a, b) {
   return a + b;
}
describe('addTwoNumbers', () =&gt; {
  it('should add two numbers', () =&gt; {
     expect(addTwoNumber(2, 3)).to.equal(5);
  });
});</code></pre>
<p class="graf graf--p">要在前端设置逻辑测试，我建议使用Jest或Mocha，以及Chai来进行测试断言:</p>
<p>组件测试</p>

<h3 class="graf graf--h3">React的组件模型对于编写测试来说相当方便。组件测试允许我们单独测试单个组件，而不是用集成测试来测试整个应用。此外，React的虚拟事件模型允许我们在没有浏览器环境的情况下对组件执行“操作”!这里有一个使用AirBnB的<a class="markup--anchor markup--p-anchor" href="https://github.com/airbnb/enzyme" target="_blank" rel="noopener noreferrer" data-href="https://github.com/airbnb/enzyme">酶</a>库的集成测试示例:</h3>
<p class="graf graf--p">你可以在这个run kit:<a class="markup--anchor markup--p-anchor" href="https://runkit.com/arbesfeld/enzyme-example" target="_blank" rel="noopener noreferrer" data-href="https://runkit.com/arbesfeld/enzyme-example">https://runkit.com/arbesfeld/enzyme-example</a>玩玩酶和成分测试</p>
<pre class="graf graf--pre"><code>class MyComponent extends Component {
  state = {
    counter: 0,
  };
  
  render() {
     return ( 
       &lt;div&gt;
         {this.state.counter}
         &lt;button onClick={() =&gt; this.setState({ counter: this.state.counter + 1 })} /&gt;
       &lt;/div&gt;
     );
  }
}
describe('MyComponent', () =&gt; {
  it('should increment the counter when the button is pressed', () =&gt; {
    const wrapper = shallow(&lt;MyComponent /&gt;);
    
    expect(wrapper.text()).to.contain(0);
    wrapper.find('button').simulate('click');
    expect(wrapper.text()).to.contain(1);
  });
});</code></pre>
<p class="graf graf--p">像逻辑测试一样，找到正确的API边界来测试是很重要的。不值得为不断变化的组件编写测试。此外，简单的纯功能组件对于测试来说并不那么有用:它们很少会有bug或问题。我建议在构建复杂组件的UI库时编写组件测试，比如多选、预输入搜索框等。</p>
<p>故事书测试</p>
<h3 class="graf graf--h3"><a class="markup--anchor markup--p-anchor" href="https://github.com/storybooks/react-storybook" target="_blank" rel="noopener noreferrer" data-href="https://github.com/storybooks/react-storybook"> react-storybook </a>和其他“UI开发环境”允许你在一个自包含的开发环境中构建组件，然后保存你的组件的“故事”,这使得其他开发人员很容易迭代组件。</h3>
<p class="graf graf--p"><img decoding="async" src="../Images/33886f2bc19469c531383b2fc2c428d1.png" data-lazy-src="https://cdn-images-1.medium.com/max/1600/1*TxuoKupMwNqsEKyrCdB9cQ.gif?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" class=" jetpack-lazy-image" data-original-src="https://cdn-images-1.medium.com/max/1600/1*TxuoKupMwNqsEKyrCdB9cQ.gif"/></p>
<p>一些开发人员会争辩说这些不是真正的测试，但是我觉得它们和测试的目的是一样的。通过编写组件的所有可能状态，其他开发人员可以更容易地改进组件，并在应用程序的其他部分使用组件。</p><noscript><img data-lazy-fallback="1" decoding="async" src="../Images/33886f2bc19469c531383b2fc2c428d1.png" data-original-src="https://cdn-images-1.medium.com/max/1600/1*TxuoKupMwNqsEKyrCdB9cQ.gif"/></noscript>
<figure class="graf graf--figure"><img decoding="async" class="graf-image jetpack-lazy-image" src="../Images/4fa43b600916b14c08b096c2bdb77c65.png" data-image-id="1*TxuoKupMwNqsEKyrCdB9cQ.gif" data-width="2156" data-height="1396" data-lazy-src="https://storage.googleapis.com/blog-images-backup/1*TxuoKupMwNqsEKyrCdB9cQ.gif?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://storage.googleapis.com/blog-images-backup/1*TxuoKupMwNqsEKyrCdB9cQ.gif"/><noscript><img data-lazy-fallback="1" decoding="async" class="graf-image" src="../Images/4fa43b600916b14c08b096c2bdb77c65.png" data-image-id="1*TxuoKupMwNqsEKyrCdB9cQ.gif" data-width="2156" data-height="1396" data-original-src="https://storage.googleapis.com/blog-images-backup/1*TxuoKupMwNqsEKyrCdB9cQ.gif"/></noscript></figure>
<p class="graf graf--p">如果你对react-storybooks感兴趣，这里有一些其他的好资源供你深入研究:</p>
<p>UI组件行动手册提供了一个关于如何用组件设计前端的很好的概述。</p>
<ul class="postList">
<li class="graf graf--li">阿鲁诺达简介react-stor books:<a class="markup--anchor markup--li-anchor" href="https://voice.kadira.io/introducing-react-storybook-ec27f28de1e2" target="_blank" rel="noopener noreferrer" data-href="https://voice.kadira.io/introducing-react-storybook-ec27f28de1e2">https://voice . kadira . io/introducing-react-story book-EC 27 f 28 de 1 e 2</a></li>
<li class="graf graf--li">对于高级用户，story shots(<a class="markup--anchor markup--li-anchor" href="https://github.com/storybooks/storyshots" target="_blank" rel="noopener noreferrer" data-href="https://github.com/storybooks/storyshots">https://github.com/storybooks/storyshots</a>)可以让你从你的故事书故事中编写实际的测试。</li>
<li class="graf graf--li">我应该写前端单元测试吗？</li>
</ul>
<h3 class="graf graf--h3">这是我在讨论React engineering时经常听到的问题。做出这个决定通常有几个因素在起作用:</h3>
<p class="graf graf--p"><strong class="markup--strong markup--li-strong">组件逻辑有多复杂？</strong>如果测试和组件代码一样长，很可能不值得测试。</p>
<ul class="postList">
<li class="graf graf--li"><strong class="markup--strong markup--li-strong">成分变化的可能性有多大？</strong>该功能/组件是否会随着时间的推移而演变？如果是这样，最好考虑集成测试。</li>
<li class="graf graf--li">测试能帮助我编写组件吗？有时在编写组件代码之前编写测试实际上对加速开发非常有帮助。</li>
<li class="graf graf--li">产品必须有多坚固？根据您产品所处的阶段，您可能拥有非常高的可靠性保证。随着时间的推移，单元测试几乎肯定会减少错误的可能性，这可能会对业务产生影响。</li>
<li class="graf graf--li">谢谢你的倾听，祝单元测试愉快！</li>
</ul>
<p class="graf graf--p"><a href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener"> LogRocket </a>:全面了解您的生产React应用</p><div class="code-block code-block-17">
<div class="blog-plug inline-plug react-plug" vwo-el-id="26283398190">
<h2 vwo-el-id="41600691720">调试React应用程序可能很困难，尤其是当用户遇到难以重现的问题时。如果您对监视和跟踪Redux状态、自动显示JavaScript错误以及跟踪缓慢的网络请求和组件加载时间感兴趣，</h2><p>. </p><a href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" vwo-el-id="19356441070">try LogRocket</a><p>LogRocket 结合了会话回放、产品分析和错误跟踪，使软件团队能够创建理想的web和移动产品体验。这对你来说意味着什么？</p><a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="19356441380">
<img class="first-react-image alignnone size-full wp-image-46 jetpack-lazy-image jetpack-lazy-image--handled" src="../Images/f300c244a1a1cf916df8b4cb02bec6c6.png" vwo-el-id="18272717540" data-lazy-loaded="1" data-original-src="https://files.readme.io/27c94e7-Image_2017-06-05_at_9.46.04_PM.png"/>
</a>
<a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="19356441690">
<img class="second-react-image alignnone size-full wp-image-46 jetpack-lazy-image jetpack-lazy-image--handled" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" vwo-el-id="30720362350" data-lazy-loaded="1" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/>
</a>
<p vwo-el-id="28675660440" class="">LogRocket不是猜测错误发生的原因，也不是要求用户提供截图和日志转储，而是让您回放问题，就像它们发生在您自己的浏览器中一样，以快速了解哪里出错了。</p>
<p>不再有嘈杂的警报。智能错误跟踪允许您对问题进行分类，然后从中学习。获得有影响的用户问题的通知，而不是误报。警报越少，有用的信号越多。</p>
<p>LogRocket Redux中间件包为您的用户会话增加了一层额外的可见性。LogRocket记录Redux存储中的所有操作和状态。</p>
<p vwo-el-id="28675660750">现代化您调试React应用的方式— <a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="40093418840">开始免费监控</a>。</p>
<p vwo-el-id="28675661060">Modernize how you debug your React apps —
<a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="40093418840">start monitoring for free</a>.
</p>
</div></div>
</div>
</div>
</div>    
</body>
</html>
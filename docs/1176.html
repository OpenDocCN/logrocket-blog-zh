<html>
<head>
<title>CSS Reference Guide: overflow - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>CSS参考指南:溢出-日志火箭博客</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/css-reference-guide-overflow/#0001-01-01">https://blog.logrocket.com/css-reference-guide-overflow/#0001-01-01</a></blockquote><div><article class="article-post">
<p>CSS <code>overflow</code>属性指定元素的内容溢出或超出其父容器的方式。当元素的宽度或高度大于其封闭父元素时，元素的x和y方向都可能发生溢出。</p>
<h4><em>向前跳转:</em></h4>

<hr/>
<p>假设我们有一个宽度为300px、高度为700px的父元素<code>div</code>，以及一个宽度为500px、高度为900px的子元素。我们将看到子元素<code>div</code>在x和y方向上溢出了它的父元素。</p>
<pre class="language-css">.parentEl {
    width: 300px;
    height: 700px;
    border: 1px solid orangered;
}

.childEl {
    width: 500px;
    height: 900px;
    border: 1px solid black;
}</pre>
<p>查看下面的一个实例:</p>
<p class="codepen" data-height="500" data-theme-id="dark" data-default-tab="html,result" data-user="philipsz-davido" data-slug-hash="XWdYvBr" data-pen-title="css overflow">参见<a href="https://codepen.io"> CodePen </a>上Chidume David(<a href="https://codepen.io/philipsz-davido">@ philipsz-davido</a>)<br/>的笔<a href="https://codepen.io/philipsz-davido/pen/XWdYvBr">CSS溢出</a>。</p>
<p/>
<p><code>.childEl</code>将溢出x轴和y轴200像素。</p>
<hr/>
<h2 id="values">价值观念</h2>
<p><code>overflow</code>属性具有可以用来处理上述情况的值:<code>visible</code>、<code>hidden</code>、<code>auto</code>、<code>scroll</code>和<code>clip</code>。</p>
<h3><code>visible</code></h3>
<p><code>overflow</code>的默认值。该值使溢出可见。它不会剪裁任何溢出。</p>
<pre class="language-css">.parentEl {
    width: 300px;
    height: 700px;
    border: 1px solid orangered;
}

.childEl {
    width: 500px;
    height: 900px;
    border: 1px solid black;

    overflow: visible;
}</pre>
<p><code>.childEl</code>溢出的内容不会被裁剪。</p>
<hr/>
<h3 id="hidden"><code>hidden</code></h3>
<p>该值剪切或隐藏子元素的溢出区域/内容。</p>
<pre class="language-css">.parentEl {
    width: 300px;
    height: 700px;
    border: 1px solid orangered;
}

.childEl {
    width: 500px;
    height: 900px;
    border: 1px solid black;

    overflow: hidden;
}</pre>
<p>上面<code>.childEl</code>溢出的内容会被隐藏。</p>
<hr/>
<h3 id="auto"><code>auto</code></h3>
<p>这隐藏并提供滚动条以溢出元素中的内容。一旦内容溢出，滚动条就会出现。</p>
<pre class="language-css">.parentEl {
    width: 300px;
    height: 700px;
    border: 1px solid orangered;
}

.childEl {
    width: 500px;
    height: 900px;
    border: 1px solid black;

    overflow: auto;
}</pre>
<p>滚动条将出现在. childEl上。</p>
<p>如果我们设置宽度不溢出它的父级:</p>
<pre class="language-css">...
.childEl {
    width: 200px;
    ...

    overflow: auto;
}</pre>
<p>然后，滚动条将不会出现在底部，因为那里没有溢出。滚动条仅在右侧可见。</p>
<hr/>

<p>这将隐藏或剪辑溢出的内容，但提供滚动条，以便可以滚动溢出的内容，使其可见或看到其余的内容。即使内容没有溢出，滚动条也会自动出现在元素中。</p>
<pre class="language-css">.parentEl {
    width: 300px;
    height: 700px;
    border: 1px solid orangered;
}

.childEl {
    width: 500px;
    height: 900px;
    border: 1px solid black;

    overflow: scroll;
}</pre>
<p><code>.childEl</code>溢出的内容将被隐藏，滚动条将出现在其右侧和底部。使用鼠标或按键，我们可以滚动显示溢出的内容。</p>
<hr/>
<h3 id="clip"><code>clip</code></h3>
<p>与<code>hidden</code>类似，只是带有<code>hidden</code>的溢出内容可以编程滚动。而<code>clip</code>则不然，它禁止所有的滚动。</p>
<pre class="language-css">.parentEl {
    width: 300px;
    height: 700px;
    border: 1px solid orangered;
}

.childEl {
    width: 500px;
    height: 900px;
    border: 1px solid black;

    overflow: clip;
}</pre>
<p><code>.childEl</code>溢出的内容将被隐藏，无法使用JS滚动到。</p>
<blockquote><p><strong>注意:</strong>，<code>overflow: clip;</code>在撰写本文时仍处于试验阶段，仍不受大多数主流浏览器的支持。</p></blockquote>
<hr/>
<h2 id="properties"><code>overflow</code>属性</h2>
<p><code>overflow</code>是<code>overflow-x</code>和<code>overflow-y</code>的简写，这意味着当我们使用<code>overflow</code>时，我们同时设置了<code>overflow-x</code>和<code>overflow-y</code>属性。</p>
<p><code>overflow</code>可以有一个或两个值。如果它只有一个值，那么<code>overflow-x</code>和<code>overflow-y</code>都取这个值。</p>
<p>如果我们有<code>overflow: auto;</code>，它将等于:</p>
<pre class="language-css">overflow-x: auto;
overflow-y: auto;</pre>
<p>如果有两个值，第一个值变成<code>overflow-x</code>，第二个值变成<code>overflow-y</code>。</p><div class="code-block code-block-54">
<hr/>
<h3>更多来自LogRocket的精彩文章:</h3>

<hr/></div>
<p>如果我们有<code>overflow: auto hidden;</code>，它将等于:</p>
<pre class="language-css">overflow-x: auto;
overflow-y: hidden;</pre>
<hr/>
<h3 id="overflowx"><code>overflow-x</code></h3>
<p>这针对元素的左侧和右侧，并控制如何处理溢出的内容。</p>
<pre class="language-css">.parentEl {
    width: 300px;
    height: 700px;
    border: 1px solid orangered;
}

.childEl {
    width: 500px;
    height: 900px;
    border: 1px solid black;

    overflow-x: hidden;
}</pre>
<p>上面的例子会隐藏右侧<code>.childEl</code>溢出的内容。其底部的溢出内容不受该规则的影响。</p>
<pre class="language-css">.parentEl {
    width: 300px;
    height: 700px;
    border: 1px solid orangered;
}

.childEl {
    width: 500px;
    height: 900px;
    border: 1px solid black;

    overflow-x: scroll;
}</pre>
<p>上面的例子将只在<code>.childEl</code>的右侧添加一个滚动条</p>
<hr/>
<h3 id="overflowy"><code>overflow-y</code></h3>
<p>这针对元素的顶部和底部，并控制如何处理溢出的内容。</p>
<pre class="language-css">.parentEl {
    width: 300px;
    height: 700px;
    border: 1px solid orangered;
}

.childEl {
    width: 500px;
    height: 900px;
    border: 1px solid black;

    overflow-y: hidden;
}</pre>
<p>这只会隐藏<code>.childEl</code>溢出的底部</p>
<hr/>
<h2 id="both">使用<code>overflow-x</code>和<code>overflow-y</code></h2>
<p>这两个属性可以一起使用来影响内容的顶部和底部。</p>
<pre class="language-css">.parentEl {
    width: 300px;
    height: 700px;
    border: 1px solid orangered;
}

.childEl {
    width: 500px;
    height: 900px;
    border: 1px solid black;

    overflow-x: hidden;
    overflow-y: scroll;
}</pre>
<p>这将隐藏溢出的右侧，并在<code>.childEl</code>的底部添加一个滚动条。</p><div class="code-block code-block-25">
<div class="blog-plug inline-plug css-plug"><h2>你的前端是否占用了用户的CPU？</h2><p>随着web前端变得越来越复杂，资源贪婪的特性对浏览器的要求越来越高。如果您对监控和跟踪生产环境中所有用户的客户端CPU使用、内存使用等感兴趣，</p><a target="_blank" href="https://lp.logrocket.com/blg/css-signup">try LogRocket</a><p>.</p><a class="signup" href="https://lp.logrocket.com/blg/css-signup" target="_blank" rel="noopener noreferrer"><img class="alignnone size-full wp-image-46 jetpack-lazy-image" src="../Images/dacb06c713aec161ffeaffae5bd048cd.png" alt="LogRocket Dashboard Free Trial Banner" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2019/12/cpu-memory-usage.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/12/cpu-memory-usage.png"/><noscript><img data-lazy-fallback="1" class="alignnone size-full wp-image-46" src="../Images/dacb06c713aec161ffeaffae5bd048cd.png" alt="LogRocket Dashboard Free Trial Banner" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/12/cpu-memory-usage.png"/></noscript></a><a href="https://lp.logrocket.com/blg/css-signup" target="_blank" rel="noopener noreferrer">https://logrocket.com/signup/</a><p>LogRocket 就像是网络和移动应用的DVR，记录你的网络应用或网站上发生的一切。您可以汇总和报告关键的前端性能指标，重放用户会话和应用程序状态，记录网络请求，并自动显示所有错误，而不是猜测问题发生的原因。</p><p>现代化您调试web和移动应用的方式— <a class="signup" href="https://lp.logrocket.com/blg/css-signup" target="_blank" rel="noopener noreferrer">开始免费监控</a>。</p></div>
</div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
<html>
<head>
<title>Using React with Django to create an app: Tutorial - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>使用React和Django创建一个应用程序:教程-日志火箭博客</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/using-react-django-create-app-tutorial/#0001-01-01">https://blog.logrocket.com/using-react-django-create-app-tutorial/#0001-01-01</a></blockquote><div><article class="article-post">
<p><em> <strong>编者按:</strong>本帖于2022年7月15日更新，以反映React和Django的最新版本，以及添加关于如何在React和Django之间发送数据的信息。</em></p>
<p>Django是目前最完整的web开发框架之一。它快速、安全且可扩展。借助Python的强大功能，我们几乎可以立即启动并运行应用程序。它管理一切，从数据库到最终发送到客户端的HTML。</p>
<p>然而，随着单页面应用程序(SPAs)的出现，越来越常见的是创建这样的应用程序，它们使用Django只是为了提供一个API来响应在各种JavaScript框架中开发的应用程序所使用的JSON数据。</p>
<p>这种架构将前端和后端分开，允许两个接口更好地解耦，这样团队可以在各自的领域中完全独立地开发。</p>
<p>它还支持多个客户端应用程序与同一个API进行交互，同时确保数据完整性和业务规则，以及各种用户界面。</p>
<p>另一方面，两个不同的项目会产生更多的工作:两个独立的部署，两个要配置的环境，等等。简化的一个方法是使用Django自己的能力来服务静态文件。毕竟前端无非就是这种类型的一组文件。</p>
<p>在本文中，我们将概述如何使用Django及其著名的Django REST框架创建一个简单的CRUD API，避免常见的跨源资源共享(CORS)问题。我们还将学习如何将Django与React应用程序集成。</p>
<p>我们将涵盖一切，从设置和配置到定制我们的前端组件和后端API:</p>

<h2 id="how-send-data-django-react">我们如何从Django发送数据以作出反应？</h2>
<p>使用Django，您可以用不同的方式公开您的API。你可以使用REST API、<a href="https://docs.graphene-python.org/projects/django/en/latest/" target="_blank" rel="noreferrer noopener"> GraphQL API </a>，或者<a href="https://djangogrpcframework.readthedocs.io/en/latest/" target="_blank" rel="noreferrer noopener"> RPC API </a>，每一个都有<a href="https://main.grokoverflow.com/posts/2022/02-understanding-rpc-node-walkthrough" target="_blank" rel="noreferrer noopener">自己的优缺点</a>。虽然GraphQL 是一个安全的赌注，但我们将使用传统的REST端点。</p>
<p>在本教程结束时，这将是我们的最终输出:</p>
<p><img data-attachment-id="124543" data-permalink="https://blog.logrocket.com/using-react-django-create-app-tutorial/attachment/img1-final-visualization-react-app-using-react-django/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/07/img1-Final-visualization-React-app-using-React-Django.png" data-orig-size="730,327" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Final-visualization-React-app-using-React-Django" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/07/img1-Final-visualization-React-app-using-React-Django-300x134.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/07/img1-Final-visualization-React-app-using-React-Django.png" decoding="async" src="../Images/aad1a72317b0dcbdfd0a529478cd6946.png" alt="Final Visualization Of Our React App Using React With Django" class="aligncenter size-full wp-image-124543 jetpack-lazy-image" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2022/07/img1-Final-visualization-React-app-using-React-Django.png 730w, https://blog.logrocket.com/wp-content/uploads/2022/07/img1-Final-visualization-React-app-using-React-Django-300x134.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2022/07/img1-Final-visualization-React-app-using-React-Django.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/07/img1-Final-visualization-React-app-using-React-Django.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="124543" data-permalink="https://blog.logrocket.com/using-react-django-create-app-tutorial/attachment/img1-final-visualization-react-app-using-react-django/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/07/img1-Final-visualization-React-app-using-React-Django.png" data-orig-size="730,327" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Final-visualization-React-app-using-React-Django" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/07/img1-Final-visualization-React-app-using-React-Django-300x134.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/07/img1-Final-visualization-React-app-using-React-Django.png" decoding="async" loading="lazy" src="../Images/aad1a72317b0dcbdfd0a529478cd6946.png" alt="Final Visualization Of Our React App Using React With Django" class="aligncenter size-full wp-image-124543" srcset="https://blog.logrocket.com/wp-content/uploads/2022/07/img1-Final-visualization-React-app-using-React-Django.png 730w, https://blog.logrocket.com/wp-content/uploads/2022/07/img1-Final-visualization-React-app-using-React-Django-300x134.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/07/img1-Final-visualization-React-app-using-React-Django.png"/></noscript>
<h2 id="setting-up-python-django">设置Python和Django</h2>
<p>对于本文，我们不打算介绍如何安装基本工具，所以在阅读本文之前，请务必查看一下您需要在计算机中设置的内容列表:</p>

<p>如果您使用的是Linux，那么Python可能已经安装了。运行<code>python3 -V</code>命令进行检查。</p>
<p>在某些环境中，您可能已经安装了Python 2和Python 3。在这种情况下，运行命令时应该使用<code>python3</code>而不是<code>python</code>。你可以通过安装PyEnv 来切换<code>python</code>命令使用的Python版本，从而避免这种情况。</p>
<p>在本文中，我们还将利用一个名为 <code><a href="https://docs.python.org/3/tutorial/venv.html" target="_blank" rel="noreferrer noopener">venv</a></code>的<a href="https://docs.python.org/3/tutorial/venv.html" target="_blank" rel="noreferrer noopener">便捷Python特性，也称为Python虚拟环境。这个特性基本上允许开发人员创建一个文件夹，其行为完全类似于特定的Python环境。</a></p>
<h3 id="setting-up-python">设置Python</h3>
<p>打开您首选的IDE到一个空目录，并按照我们开始的步骤进行操作。记住总是<a href="https://stackoverflow.com/questions/52827722/folder-naming-convention-for-python-projects" target="_blank" rel="noreferrer noopener">给你的目录起一个好名字</a>。</p>
<p>让我们运行这个文件夹中的命令来创建我们的<code>venv</code>:</p>
<pre class="language-bash hljs">python -m venv logrocket_env
</pre>
<p>进入创建的文件夹后，你会看到其他一些文件，如<code>bin</code>、<code>lib</code>、<code>share</code>。这些文件保证您处于Python配置的独立环境中。要使用<code>bin</code>文件，您必须确保它已被激活:</p>
<pre class="language-bash hljs">source ./logrocket_env/bin/activate
</pre>
<p>然后您的命令行将看起来像下面的例子，括号中的名称确认您在<code>venv</code>中:</p>
<pre class="language-bash hljs">(logrocket_env) <a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="25505640574b44484065494a4644494d4a5651">[email protected]</a>: _
</pre>
<p>注意，一旦你进入<code>venv</code>，你可以正常使用命令<code>pip</code>或<code>python</code>。如果你在<code>venv</code>之外，你必须使用<code>pip3</code>和<code>python3</code>。</p>
<p>就是这样。你很适合和你的venv一起去。</p>
<h3 id="setting-up-django">建立姜戈</h3>
<p>接下来，让我们通过在<code>venv</code>中运行以下命令来开始安装Django :</p>
<pre class="language-bash hljs">pip install django djangorestframework django-cors-headers
</pre>
<p>请注意，我们正在为我们的API安装另外两个依赖项:</p>

<p>当我们试图从一个不同的应用程序访问API时，这些依赖关系非常有用。在这种情况下，它们帮助连接Django并做出反应。</p>
<p>我们还将利用Django的另外两个特性来帮助我们进行样板配置:<code><a href="https://docs.djangoproject.com/en/4.0/ref/django-admin/" target="_blank" rel="noreferrer noopener">django-admin</a></code> <a href="https://docs.djangoproject.com/en/4.0/ref/django-admin/" target="_blank" rel="noreferrer noopener">和</a> <code><a href="https://docs.djangoproject.com/en/4.0/ref/django-admin/" target="_blank" rel="noreferrer noopener">manage.py</a></code>。</p>
<p>是Django的自动管理界面。它基本上是一个命令行实用程序，可以用Django执行方便的操作。</p>
<p>是一个脚本，它将帮助我们管理我们的数据库，从我们的模型中创建表格，处理迁移和版本控制，以及正确地创建我们的项目。</p>
<p>现在，我们将运行以下命令来创建我们的API项目——记住，您必须在<code>venv</code>中:</p>
<pre class="language-bash hljs">django-admin startproject django_react_proj
</pre>
<p>创建项目后，检查我们前面提到的<code>manage.py</code>文件的根文件夹。我们将进一步研究其余的文件。</p>
<p>让我们使用<code>django_react_proj/</code>文件夹中的<code>settings.py</code>文件开始我们的Django配置。当您打开这个文件时，您会看到许多配置。<code>INSTALLED_APPS</code>对我们来说很重要。</p>
<p>将以下三行添加到数组中:</p>
<pre class="language-python hljs">INSTALLED_APPS = [
   ...
    'rest_framework',
    'corsheaders',
    'students'
]
</pre>
<p>这三行是我们之前安装的依赖项，以及将要创建的API文件夹的名称。</p>
<p>现在，将以下内容添加到<code>MIDDLEWARE</code>数组中:</p>
<pre class="language-python hljs">MIDDLEWARE = [
    ....
    'corsheaders.middleware.CorsMiddleware',
    'django.middleware.common.CommonMiddleware',
]
</pre>
<p>这些对应于一个过滤器，它将拦截我们应用程序的所有请求，并对它们应用CORS逻辑。</p>
<p>然而，由于我们正在全力工作<code>localhost</code>，我们将通过向同一个文件添加以下内容来禁用CORS特性:</p>
<pre class="language-python hljs">CORS_ORIGIN_ALLOW_ALL = True
</pre>
<p>太好了！现在，让我们继续讨论应用程序的模型和视图。</p>
<h2 id="adding-models-views-django">向Django添加模型和视图</h2>
<p>为了创建一些预置文件，我们将再次使用<code>manage.py</code>脚本。这一次，运行以下命令:</p>
<pre class="language-bash hljs">django-admin startapp students
</pre>
<p>之后，将会创建一个<code>students/</code>文件夹，以及<code>models.py</code>和<code>views.py</code>。最初，这些文件中几乎没有内容。</p>
<p>让我们先删除当前在<code>models.py</code>文件中的所有内容，然后添加我们的模型:</p>
<pre class="language-python hljs">from django.db import models

class Student(models.Model):
    name = models.CharField("Name", max_length=240)
    email = models.EmailField()
    document = models.CharField("Document", max_length=20)
    phone = models.CharField(max_length=20)
    registrationDate = models.DateField("Registration Date", auto_now_add=True)

    def __str__(self):
        return self.name
</pre>
<p>注意，我们的<code>Student</code>类是从<a href="https://docs.djangoproject.com/en/3.0/ref/models/instances/#django.db.models.Model" target="_blank" rel="noreferrer noopener"> Django的</a> <code><a href="https://docs.djangoproject.com/en/3.0/ref/models/instances/#django.db.models.Model" target="_blank" rel="noreferrer noopener">Model</a></code> <a href="https://docs.djangoproject.com/en/3.0/ref/models/instances/#django.db.models.Model" target="_blank" rel="noreferrer noopener">类</a>扩展而来的。一旦它直接连接到Django模型框架，我们将使用它来创建数据库表，这将使我们的生活更加轻松。</p>
<p>用正确的类型和配置来设置所有字段也很重要，包括<code>max length</code>(如果需要的话)、<code>description</code>、<code>autocreation</code>等。</p>
<h2 id="migrating-django-models-database">将我们的Django模型迁移到数据库</h2>
<p>现在，让我们通过<a href="https://blog.logrocket.com/making-django-migrations-python/" target="_blank" rel="noreferrer noopener"> Django的迁移特性</a>将模型导出到数据库中。</p>
<p>迁移是Django将您对模型所做的更改——比如添加一个字段或删除一个模型——传播到数据库模式中的一种方式。</p>
<p>它们被设计成大部分是自动的，但是您需要知道何时进行迁移，何时运行迁移，以及您可能会遇到哪些常见问题。</p>
<p>转到应用程序的根目录，运行以下命令:</p>
<pre class="language-bash hljs">python manage.py makemigrations
</pre>
<p>您将看到为对这些更改进行版本控制而创建的文件的名称和位置。然后，我们需要将更改应用到数据库本身:</p>
<pre class="language-bash hljs">python manage.py migrate
</pre>
<p>下一步是创建我们称之为数据迁移文件的东西。它代表了对数据库中数据的直接操作。要创建此文件，请运行以下命令:</p>
<pre class="language-bash hljs">python manage.py makemigrations --empty --name students students
</pre>
<p>请注意，版本控制是根据文件末尾的数字进行的，以保持顺序。</p>
<p>之后，转到<code>django_react_proj/students/migrations/</code>文件夹，将内容更改为:</p>
<pre class="language-python hljs">from django.db import migrations

def create_data(apps, schema_editor):
    Student = apps.get_model('students', 'Student')
    Student(name="Joe Silver", email="<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="8fe5e0eacfeae2eee6e3a1ece0e2">[email protected]</a>", document="22342342", phone="00000000").save()

class Migration(migrations.Migration):

    dependencies = [
        ('students', '0001_initial'),
    ]

    operations = [
        migrations.RunPython(create_data),
    ]
</pre>
<p>简而言之，<code>create_data</code>方法恢复<code>Student</code>模型对象并创建初始数据，这样当API启动时我们的数据库就不会为空。</p>
<p><code>dependencies</code>属性将迁移过程中要考虑的其他文件联系起来。</p>
<p><code>operations</code>基本上是一旦迁移被触发，Django必须执行的动作。</p>
<p>现在，我们准备再次运行migrate命令。在<code>django_react_proj/</code>文件夹中，运行:</p>
<pre class="language-bash hljs">python manage.py migrate
</pre>
<h2 id="diving-into-django-rest-api">深入我们的Django REST API</h2>
<p>现在是时候深入研究REST API了，我们将<a href="https://blog.logrocket.com/django-rest-framework-create-api/" target="_blank" rel="noreferrer noopener">在Django REST框架</a>之上构建这个API。在这里，您将接触到两个主要的世界:视图和URL。视图是由URL提供服务的特定端点上的请求的初始入口点。</p>
<p>一旦我们将函数本身连接到端点，所有这些都由Django REST框架进行映射。我们还将<a href="http://www.django-rest-framework.org/api-guide/serializers/" target="_blank" rel="noreferrer noopener">利用序列化器</a>。</p>
<p>它们允许将复杂的数据(如查询集和模型实例)转换成本地Python数据类型，然后可以很容易地呈现到JSON中。让我们从那里开始。</p>
<p>在<code>students/</code>文件夹中新建一个文件<code>serializers.py</code>，并添加以下内容:</p>
<pre class="language-python hljs">from rest_framework import serializers
from .models import Student

class StudentSerializer(serializers.ModelSerializer):

    class Meta:
        model = Student 
        fields = ('pk', 'name', 'email', 'document', 'phone', 'registrationDate')
</pre>
<p><code>Meta</code>类在这里很重要，因为它定义了我们的模型拥有的元数据信息(数据库),这些信息必须转换成<code>Student</code>类。</p>
<p>接下来，让我们打开位于<code>django_react_proj/</code>文件夹中的<code>urls.py</code>文件，并将其内容更改为以下内容:</p>
<pre class="language-python hljs">from django.contrib import admin
from django.urls import path, re_path
from students import views

urlpatterns = [
    path('admin/', admin.site.urls),
    re_path(r'^api/students/$', views.students_list),
    re_path(r'^api/students/([0-9])$', views.students_detail),
]
</pre>
<p>路径已经存在。我们唯一添加的是<code>students</code>端点。注意，它们中的每一个都连接到一个将要创建的视图函数，所以这是我们路由请求的地方。</p>
<p>第一个端点将处理创建(<code>POST</code>)和列表(<code>GET</code>)。第二个将删除(<code>DELETE</code>)或更新(<code>PUT</code>)单个学生的数据。简单吧？</p>
<p>现在，让我们去看风景。打开<code>students/views.py</code>文件，复制以下代码:</p>
<pre class="language-python hljs">from rest_framework.response import Response
from rest_framework.decorators import api_view
from rest_framework import status

from .models import Student
from .serializers import *

@api_view(['GET', 'POST'])
def students_list(request):
    if request.method == 'GET':
        data = Student.objects.all()

        serializer = StudentSerializer(data, context={'request': request}, many=True)

        return Response(serializer.data)

    elif request.method == 'POST':
        serializer = StudentSerializer(data=request.data)
        if serializer.is_valid():
            serializer.save()
            return Response(status=status.HTTP_201_CREATED)

        return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)

@api_view(['PUT', 'DELETE'])
def students_detail(request, pk):
    try:
        student = Student.objects.get(pk=pk)
    except Student.DoesNotExist:
        return Response(status=status.HTTP_404_NOT_FOUND)

    if request.method == 'PUT':
        serializer = StudentSerializer(student, data=request.data,context={'request': request})
        if serializer.is_valid():
            serializer.save()
            return Response(status=status.HTTP_204_NO_CONTENT)
        return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)

    elif request.method == 'DELETE':
        student.delete()
        return Response(status=status.HTTP_204_NO_CONTENT)
</pre>
<p>第一种方法是<code>students_list</code>，在我们的API的根端点上处理<code>GET</code>和<code>POST</code>操作。</p>
<p>这意味着每次我们通过带有<code>GET</code>和<code>POST</code> HTTP动词的<a href="http://localhost:8000/api/students" target="_blank" rel="noreferrer noopener">HTTP://localhost:8000/API/students</a>发出请求时，我们都会执行这个方法。</p>
<p>第一件事是通过<code>Student</code>对象获取我们模型中的所有学生。它为一个名为<code>object</code>的隐式对象提供了访问整个数据库的方法:<code>all()</code>。</p>
<p>然后，我们将结果传递给序列化程序，在我们将结果作为响应返回之前，序列化程序会负责转换过程。</p>
<p>对于<code>POST</code>方法，注意我们首先在序列化器上调用<code>is_valid()</code>方法，以确保接收的数据符合我们的模型。否则，序列化程序将在这里引发异常。如果一切正常，我们将其保存到数据存储区。</p>
<p>接下来的<code>PUT</code>和<code>DELETE</code>操作非常相似，只是改变了HTTP动词和响应。</p>
<p>就是这样！</p>
<h2 id="testing-endpoints-django">测试我们在Django的端点</h2>
<p>现在，让我们运行Django应用程序来测试这些端点。在根文件夹中运行以下命令:</p>
<pre class="language-bash hljs">python manage.py runserver
</pre>
<p>在您看到显示我们的服务器已经启动并运行的日志之后，进入浏览器并访问<a href="http://localhost:8000/api/students/" target="_blank" rel="noreferrer noopener">http://localhost:8000/API/students/</a>。您会看到类似这样的内容:</p>
<p><img data-attachment-id="124546" data-permalink="https://blog.logrocket.com/using-react-django-create-app-tutorial/attachment/img2-testing-endpoints-django-student-list/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/07/img2-Testing-endpoints-Django-student-list.png" data-orig-size="730,389" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Testing-endpoints-Django-student-list" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/07/img2-Testing-endpoints-Django-student-list-300x160.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/07/img2-Testing-endpoints-Django-student-list.png" decoding="async" src="../Images/8e789aaefa7c3ac33fee9a769f76fc94.png" alt="Student List Shown At Localhost 8000 While Testing Django Endpoints" class="aligncenter size-full wp-image-124546 jetpack-lazy-image" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2022/07/img2-Testing-endpoints-Django-student-list.png 730w, https://blog.logrocket.com/wp-content/uploads/2022/07/img2-Testing-endpoints-Django-student-list-300x160.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2022/07/img2-Testing-endpoints-Django-student-list.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/07/img2-Testing-endpoints-Django-student-list.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="124546" data-permalink="https://blog.logrocket.com/using-react-django-create-app-tutorial/attachment/img2-testing-endpoints-django-student-list/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/07/img2-Testing-endpoints-Django-student-list.png" data-orig-size="730,389" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Testing-endpoints-Django-student-list" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/07/img2-Testing-endpoints-Django-student-list-300x160.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/07/img2-Testing-endpoints-Django-student-list.png" decoding="async" loading="lazy" src="../Images/8e789aaefa7c3ac33fee9a769f76fc94.png" alt="Student List Shown At Localhost 8000 While Testing Django Endpoints" class="aligncenter size-full wp-image-124546" srcset="https://blog.logrocket.com/wp-content/uploads/2022/07/img2-Testing-endpoints-Django-student-list.png 730w, https://blog.logrocket.com/wp-content/uploads/2022/07/img2-Testing-endpoints-Django-student-list-300x160.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/07/img2-Testing-endpoints-Django-student-list.png"/></noscript>
<p>你在这里看到的是<a href="https://www.django-rest-framework.org/topics/browsable-api/" target="_blank" rel="noreferrer noopener"> Django的可浏览API </a>，一个人性化的HTML输出，允许轻松浏览资源，以及向资源提交数据的表单。不需要使用<code>cURL</code>或其他UI工具，就可以很方便地测试你的端点。</p>
<p>您还可以通过图像底部的表单使用其他HTTP方法。继续玩吧。</p>
<h2 id="building-react-app">构建React应用程序</h2>
<p>现在是前端时间。</p>
<p>需要注意的是，我们不会在这里深入讨论React的细节，所以如果你是初学者，请花一些时间阅读React 。本教程的重点是向您展示如何从React应用程序中快速使用Django API。</p>
<p>在本文中，我们将使用React的最新版本。但是，请随意使用您喜欢的版本。我们也不会讨论React钩子的使用或React的其他特性，因为目的是the API消费本身。</p>
<p>一旦安装了Node和npm，让我们在Django项目的根文件夹中运行以下命令来创建React应用程序:</p>
<pre class="language-bash hljs">npx create-react-app students-fe
</pre>
<p>如果你不知道<code>create-react-app</code>，<a href="https://blog.logrocket.com/create-react-app-a-quick-setup-guide-b812f0aad03c/" target="_blank" rel="noreferrer noopener">通读快速设置指南</a>以获得一些帮助。</p>
<h3 id="crud-react-components">CRUD反应组件</h3>
<p>我们将前端分成一些更小的组件，如下图所示:</p>
<p><img data-attachment-id="124548" data-permalink="https://blog.logrocket.com/using-react-django-create-app-tutorial/attachment/img3-frontend-components-header-home/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/07/img3-Frontend-components-header-home.png" data-orig-size="730,297" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Frontend-components-header-home" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/07/img3-Frontend-components-header-home-300x122.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/07/img3-Frontend-components-header-home.png" decoding="async" src="../Images/fc7eef2145b4580602e05d8ff2cfe8f8.png" alt="Frontend With Labeled Red Boxes Showing Different Components, Including Header At Top And Home Below" class="aligncenter size-full wp-image-124548 jetpack-lazy-image" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2022/07/img3-Frontend-components-header-home.png 730w, https://blog.logrocket.com/wp-content/uploads/2022/07/img3-Frontend-components-header-home-300x122.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2022/07/img3-Frontend-components-header-home.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/07/img3-Frontend-components-header-home.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="124548" data-permalink="https://blog.logrocket.com/using-react-django-create-app-tutorial/attachment/img3-frontend-components-header-home/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/07/img3-Frontend-components-header-home.png" data-orig-size="730,297" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Frontend-components-header-home" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/07/img3-Frontend-components-header-home-300x122.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/07/img3-Frontend-components-header-home.png" decoding="async" loading="lazy" src="../Images/fc7eef2145b4580602e05d8ff2cfe8f8.png" alt="Frontend With Labeled Red Boxes Showing Different Components, Including Header At Top And Home Below" class="aligncenter size-full wp-image-124548" srcset="https://blog.logrocket.com/wp-content/uploads/2022/07/img3-Frontend-components-header-home.png 730w, https://blog.logrocket.com/wp-content/uploads/2022/07/img3-Frontend-components-header-home-300x122.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/07/img3-Frontend-components-header-home.png"/></noscript>
<p>标题组件将存储标题信息、徽标等。</p>
<p>home组件将是我们的主容器，存储其他组件的剩余部分，比如表中的学生列表。</p>
<p>我们还将为表单添加两个组件。“更新”和“添加”表单将有几乎相同的组件，并将被放置在模态中。拥有这两个功能取决于现在哪个模态是活动的。</p>
<p><img data-attachment-id="124553" data-permalink="https://blog.logrocket.com/using-react-django-create-app-tutorial/attachment/4-creating-new-student-modal/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/07/4-Creating-new-student-modal.png" data-orig-size="730,711" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Creating-new-student-modal" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/07/4-Creating-new-student-modal-300x292.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/07/4-Creating-new-student-modal.png" decoding="async" src="../Images/d414225895cc4ef82cb234461c204c54.png" alt="Popup Modal Titled Creating New Student With Blank Fields For Name, Email, Document, And Phone, And Send Button" class="aligncenter size-full wp-image-124553 jetpack-lazy-image" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2022/07/4-Creating-new-student-modal.png 730w, https://blog.logrocket.com/wp-content/uploads/2022/07/4-Creating-new-student-modal-300x292.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2022/07/4-Creating-new-student-modal.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/07/4-Creating-new-student-modal.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="124553" data-permalink="https://blog.logrocket.com/using-react-django-create-app-tutorial/attachment/4-creating-new-student-modal/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/07/4-Creating-new-student-modal.png" data-orig-size="730,711" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Creating-new-student-modal" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/07/4-Creating-new-student-modal-300x292.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/07/4-Creating-new-student-modal.png" decoding="async" loading="lazy" src="../Images/d414225895cc4ef82cb234461c204c54.png" alt="Popup Modal Titled Creating New Student With Blank Fields For Name, Email, Document, And Phone, And Send Button" class="aligncenter size-full wp-image-124553" srcset="https://blog.logrocket.com/wp-content/uploads/2022/07/4-Creating-new-student-modal.png 730w, https://blog.logrocket.com/wp-content/uploads/2022/07/4-Creating-new-student-modal-300x292.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/07/4-Creating-new-student-modal.png"/></noscript>
<h3 id="setting-up-react-app-integrate-django">设置React应用程序以与Django集成</h3>
<p>让我们直奔主题吧。我们将<a href="https://blog.logrocket.com/using-bootstrap-with-react-tutorial-with-examples/" target="_blank" rel="noreferrer noopener">使用Bootstrap和React为</a>设计强大的<code>reactstrap</code>包。我们还将使用基于promise的HTTP客户端<a href="https://blog.logrocket.com/how-to-make-http-requests-like-a-pro-with-axios/" target="_blank" rel="noreferrer noopener"> Axios对我们的Django API进行HTTP请求调用</a>。</p>
<p>首先，我们将向我们的<code>students-fe</code>项目添加一些重要的依赖项，因此<code>cd</code>进入项目并运行以下命令:</p>
<pre class="language-bash hljs">npm install bootstrap reactstrap axios --save
</pre>
<p>接下来，转到<code>src/index.js</code>文件并添加以下导入语句:</p>
<pre class="language-javascript hljs">import "bootstrap/dist/css/bootstrap.min.css";
</pre>
<p>在你的<code>src/</code>文件夹中，创建另一个名为<code>constants</code>的文件夹，然后是一个文件<code>index.js</code>。这个文件将存储React项目的实用程序常量。添加一个常量来保存我们的API的URL:</p>
<pre class="language-javascript hljs">export const API_URL = "http://localhost:8000/api/students/";
</pre>
<p>然后，让我们开始创建组件，从头部开始。</p>

<p>创建另一个名为<code>components</code>的文件夹，并在其中创建一个名为<code>Header.js</code>的JavaScript文件。增加以下内容:</p>
<pre class="language-javascript hljs">import React, { Component } from "react";

class Header extends Component {
  render() {
    return (
      &lt;div className="text-center"&gt;
        &lt;img
          src="https://logrocket-assets.io/img/logo.png"
          width="300"
          className="img-thumbnail"
          style={{ marginTop: "20px" }}
        /&gt;
        &lt;hr /&gt;
        &lt;h5&gt;
          &lt;i&gt;presents&lt;/i&gt;
        &lt;/h5&gt;
        &lt;h1&gt;App with React + Django&lt;/h1&gt;
      &lt;/div&gt;
    );
  }
}

export default Header;
</pre>
<p>这是在JSX下表现的非常静态的HTML。这里没什么值得注意的。</p>
<h3 id="working-creating-new-student-form">正在创建新的学生表单</h3>
<p>现在，让我们改变策略，从最里面到最外面构建下一个组件。在同一个<code>components</code>文件夹中，创建一个名为<code>NewStudentForm.js</code>的新文件，并添加以下内容:</p>
<pre class="language-javascript hljs">import React from "react";
import { Button, Form, FormGroup, Input, Label } from "reactstrap";

import axios from "axios";

import { API_URL } from "../constants";

class NewStudentForm extends React.Component {
  state = {
    pk: 0,
    name: "",
    email: "",
    document: "",
    phone: ""
  };

  componentDidMount() {
    if (this.props.student) {
      const { pk, name, document, email, phone } = this.props.student;
      this.setState({ pk, name, document, email, phone });
    }
  }

  onChange = e =&gt; {
    this.setState({ [e.target.name]: e.target.value });
  };

  createStudent = e =&gt; {
    e.preventDefault();
    axios.post(API_URL, this.state).then(() =&gt; {
      this.props.resetState();
      this.props.toggle();
    });
  };

  editStudent = e =&gt; {
    e.preventDefault();
    axios.put(API_URL + this.state.pk, this.state).then(() =&gt; {
      this.props.resetState();
      this.props.toggle();
    });
  };

  defaultIfEmpty = value =&gt; {
    return value === "" ? "" : value;
  };

  render() {
    return (
      &lt;Form onSubmit={this.props.student ? this.editStudent : this.createStudent}&gt;
        &lt;FormGroup&gt;
          &lt;Label for="name"&gt;Name:&lt;/Label&gt;
          &lt;Input
            type="text"
            name="name"
            onChange={this.onChange}
            value={this.defaultIfEmpty(this.state.name)}
          /&gt;
        &lt;/FormGroup&gt;
        &lt;FormGroup&gt;
          &lt;Label for="email"&gt;Email:&lt;/Label&gt;
          &lt;Input
            type="email"
            name="email"
            onChange={this.onChange}
            value={this.defaultIfEmpty(this.state.email)}
          /&gt;
        &lt;/FormGroup&gt;
        &lt;FormGroup&gt;
          &lt;Label for="document"&gt;Document:&lt;/Label&gt;
          &lt;Input
            type="text"
            name="document"
            onChange={this.onChange}
            value={this.defaultIfEmpty(this.state.document)}
          /&gt;
        &lt;/FormGroup&gt;
        &lt;FormGroup&gt;
          &lt;Label for="phone"&gt;Phone:&lt;/Label&gt;
          &lt;Input
            type="text"
            name="phone"
            onChange={this.onChange}
            value={this.defaultIfEmpty(this.state.phone)}
          /&gt;
        &lt;/FormGroup&gt;
        &lt;Button&gt;Send&lt;/Button&gt;
      &lt;/Form&gt;
    );
  }
}

export default NewStudentForm;
</pre>
<p>在这里，我们有一些重要的事情正在进行。</p>
<p>在第一行中，我们第一次导入了一些<code>reactstrap</code>组件，包括<code>Form</code>、<code>Button</code>，以及其他将组成我们表单的组件。</p>
<p>然后，我们用我们的<code>NewStudentForm</code>模型的相应属性创建了我们的<code>state</code>对象。这将有助于单独操纵每个道具。</p>
<p><code>componentDidMount</code>函数将在组件完成启动后运行，因此我们可以在这里从父组件(<code>this.props</code>)中恢复学生的<code>props</code>，并用它们设置<code>state</code>(如果它们存在，用于编辑场景。)</p>
<p><code>onChange</code>函数将用每个字段中输入的当前值来处理每个<code>state</code>道具的更新。</p>
<p><code>createStudent</code>函数将处理表单的HTTP <code>POST</code>请求。每次我们按下“提交”按钮，这个函数就会被调用，触发Axios的<code>post()</code>函数并传递请求的<code>body.</code>中的当前<code>state</code></p>
<p>一旦完成，我们将调用两个<code>props</code>函数:<code>resetState</code>刷新表格，和<code>toggle</code>关闭模态。我们稍后将讨论如何创建这些。</p>
<h3 id="working-modal-edit-student-information">处理编辑学生信息的模式</h3>
<p><code>editStudent</code>函数的工作方式几乎与前一个一样，但是调用了我们的<code>PUT</code>操作。</p>
<p><code>defaultIfEmpty</code>函数是作为一个辅助函数创建的，它将检查每个字段的当前值，以便在创建新学生时确定是否要用<code>state</code>的值填充它们(如果存在的话，用于编辑)。</p>
<p><code>render</code>函数将在<code>reactstrap</code>组件的帮助下合成我们的表单。注意<code>onSubmit</code>属性，它检查名为<code>student</code>的<code>props</code>属性。如果属性存在，提交函数将用于编辑(值由父组件传递)；否则就是为了创作。</p>
<p>接下来，我们将注意力转向包含我们刚刚创建的表单的模态组件。为此，创建一个名为<code>NewStudentModal.js</code>的新组件文件，并添加以下代码:</p>
<pre class="language-javascript hljs">import React, { Component, Fragment } from "react";
import { Button, Modal, ModalHeader, ModalBody } from "reactstrap";
import NewStudentForm from "./NewStudentForm";

class NewStudentModal extends Component {
  state = {
    modal: false
  };

  toggle = () =&gt; {
    this.setState(previous =&gt; ({
      modal: !previous.modal
    }));
  };

  render() {
    const create = this.props.create;

    var title = "Editing Student";
    var button = &lt;Button onClick={this.toggle}&gt;Edit&lt;/Button&gt;;
    if (create) {
      title = "Creating New Student";

      button = (
        &lt;Button
          color="primary"
          className="float-right"
          onClick={this.toggle}
          style={{ minWidth: "200px" }}
        &gt;
          Create New
        &lt;/Button&gt;
      );
    }

    return (
      &lt;Fragment&gt;
        {button}
        &lt;Modal isOpen={this.state.modal} toggle={this.toggle}&gt;
          &lt;ModalHeader toggle={this.toggle}&gt;{title}&lt;/ModalHeader&gt;

          &lt;ModalBody&gt;
            &lt;NewStudentForm
              resetState={this.props.resetState}
              toggle={this.toggle}
              student={this.props.student}
            /&gt;
          &lt;/ModalBody&gt;
        &lt;/Modal&gt;
      &lt;/Fragment&gt;
    );
  }
}

export default NewStudentModal;
</pre>
<p>这一次，我们创建的唯一的<code>state</code>道具是模态的<code>state</code>,以便检查它是必须打开还是关闭。</p>
<p><code>toggle</code>函数(我们的表单作为参数接收的函数)会在每次调用时将当前模态的值切换到相反的值。</p>
<p>在<code>render</code>函数中，我们首先检查一个<code>create</code>布尔值是否作为一个参数从父调用者传递来，以决定按钮是用于编辑还是创建。这些按钮是根据家长对我们说的话动态创建的。</p>
<p>然后，<code>Modal</code>组件可以在这些条件下进一步安装。注意我们将刚刚创建的<code>&lt;NewStudentForm /&gt;</code>组件放在哪里。</p>
<h3 id="creating-students-listing">创建学生列表</h3>
<p><code>NewStudentModal</code>组件将被放入我们现在要创建的<code>StudentList.js</code>中:</p>
<pre class="language-javascript hljs">import React, { Component } from "react";
import { Table } from "reactstrap";
import NewStudentModal from "./NewStudentModal";

import ConfirmRemovalModal from "./ConfirmRemovalModal";

class StudentList extends Component {
  render() {
    const students = this.props.students;
    return (
      &lt;Table dark&gt;
        &lt;thead&gt;
          &lt;tr&gt;
            &lt;th&gt;Name&lt;/th&gt;
            &lt;th&gt;Email&lt;/th&gt;
            &lt;th&gt;Document&lt;/th&gt;
            &lt;th&gt;Phone&lt;/th&gt;
            &lt;th&gt;Registration&lt;/th&gt;
            &lt;th&gt;&lt;/th&gt;
          &lt;/tr&gt;
        &lt;/thead&gt;
        &lt;tbody&gt;
          {!students || students.length &lt;= 0 ? (
            &lt;tr&gt;
              &lt;td colSpan="6" align="center"&gt;
                &lt;b&gt;Ops, no one here yet&lt;/b&gt;
              &lt;/td&gt;
            &lt;/tr&gt;
          ) : (
            students.map(student =&gt; (
              &lt;tr key={student.pk}&gt;
                &lt;td&gt;{student.name}&lt;/td&gt;
                &lt;td&gt;{student.email}&lt;/td&gt;
                &lt;td&gt;{student.document}&lt;/td&gt;
                &lt;td&gt;{student.phone}&lt;/td&gt;
                &lt;td&gt;{student.registrationDate}&lt;/td&gt;
                &lt;td align="center"&gt;
                  &lt;NewStudentModal
                    create={false}
                    student={student}
                    resetState={this.props.resetState}
                  /&gt;
                  &amp;nbsp;&amp;nbsp;
                  &lt;ConfirmRemovalModal
                    pk={student.pk}
                    resetState={this.props.resetState}
                  /&gt;
                &lt;/td&gt;
              &lt;/tr&gt;
            ))
          )}
        &lt;/tbody&gt;
      &lt;/Table&gt;
    );
  }
}

export default StudentList;
</pre>
<p>在这里，焦点是明确的<code>students</code>列表，而不是别的。注意不要混淆不属于这里的不同逻辑和规则。</p>
<p>这个组件的核心是对我们将从父组件(<code>Home</code>)接收的<code>students</code>属性的迭代。<code>map</code>函数将通过提供一个变量(<code>student</code>)让我们访问每个值来处理迭代。</p>
<p>再来看一下<code>NewStudentModal</code>和<code>ConfirmRemovalModal</code>组件，它们就放在最后一个<code>&lt;td&gt;</code>的下面。</p>
<p>以下是<code>ConfirmRemovalModal</code>组件的内容:</p>
<pre class="language-javascript hljs">import React, { Component, Fragment } from "react";
import { Modal, ModalHeader, Button, ModalFooter } from "reactstrap";

import axios from "axios";

import { API_URL } from "../constants";

class ConfirmRemovalModal extends Component {
  state = {
    modal: false
  };

  toggle = () =&gt; {
    this.setState(previous =&gt; ({
      modal: !previous.modal
    }));
  };

  deleteStudent = pk =&gt; {
    axios.delete(API_URL + pk).then(() =&gt; {
      this.props.resetState();
      this.toggle();
    });
  };

  render() {
    return (
      &lt;Fragment&gt;
        &lt;Button color="danger" onClick={() =&gt; this.toggle()}&gt;
          Remove
        &lt;/Button&gt;
        &lt;Modal isOpen={this.state.modal} toggle={this.toggle}&gt;
          &lt;ModalHeader toggle={this.toggle}&gt;
            Do you really wanna delete the student?
          &lt;/ModalHeader&gt;

          &lt;ModalFooter&gt;
            &lt;Button type="button" onClick={() =&gt; this.toggle()}&gt;
              Cancel
            &lt;/Button&gt;
            &lt;Button
              type="button"
              color="primary"
              onClick={() =&gt; this.deleteStudent(this.props.pk)}
            &gt;
              Yes
            &lt;/Button&gt;
          &lt;/ModalFooter&gt;
        &lt;/Modal&gt;
      &lt;/Fragment&gt;
    );
  }
}

export default ConfirmRemovalModal;
</pre>
<p>这个组件也很简单；它托管删除操作。我们称这个为我们的<code>DELETE</code>端点。</p>
<p>因为它也是模态的，所以我们也必须有状态的<code>modal</code>属性，以及<code>toggle</code>函数。<br/><code>deleteStudent</code>函数将处理HTTP调用来删除给定的学生。</p>
<p>代码的其余部分与我们已经看到的非常相似。</p>
<h3 id="working-home-component">处理家庭组件</h3>
<p>现在让我们构建我们的<code>Home.js</code>组件。创建文件，并向其中添加以下内容:</p>
<pre class="language-javascript hljs">import React, { Component } from "react";
import { Col, Container, Row } from "reactstrap";
import StudentList from "./StudentList";
import NewStudentModal from "./NewStudentModal";

import axios from "axios";

import { API_URL } from "../constants";

class Home extends Component {
  state = {
    students: []
  };

  componentDidMount() {
    this.resetState();
  }

  getStudents = () =&gt; {
    axios.get(API_URL).then(res =&gt; this.setState({ students: res.data }));
  };

  resetState = () =&gt; {
    this.getStudents();
  };

  render() {
    return (
      &lt;Container style={{ marginTop: "20px" }}&gt;
        &lt;Row&gt;
          &lt;Col&gt;
            &lt;StudentList
              students={this.state.students}
              resetState={this.resetState}
            /&gt;
          &lt;/Col&gt;
        &lt;/Row&gt;
        &lt;Row&gt;
          &lt;Col&gt;
            &lt;NewStudentModal create={true} resetState={this.resetState} /&gt;
          &lt;/Col&gt;
        &lt;/Row&gt;
      &lt;/Container&gt;
    );
  }
}

export default Home;
</pre>
<p>在这里，我们的<code>state</code>将托管我们将从服务器恢复的<code>students</code>的数组。</p>
<p><code>resetState</code>函数(我们在前面调用过)将只调用<code>getStudents</code>，T1又调用我们的API中的<code>GET</code>端点和完整的学生列表。</p>
<p>清单的其余部分指的是使用<code>StudentList</code>和<code>NewStudentModal</code>组件。请自行组织您的组件展览。</p>
<p>接下来是测试我们的应用程序之前的最后一步。将<code>Header</code>和<code>Home</code>组件导入到我们的<code>App.js</code>文件中:</p>
<pre class="language-javascript hljs">import React, { Component, Fragment } from "react";
import Header from "./components/Header";
import Home from "./components/Home";

class App extends Component {
  render() {
    return (
      &lt;Fragment&gt;
        &lt;Header /&gt;
        &lt;Home /&gt;
      &lt;/Fragment&gt;
    );
  }
}

export default App;
</pre>
<p>现在，运行命令<code>npm start</code>，您的React应用程序将打开浏览器到<a href="http://localhost:3000/" https:="" blog.logrocket.com="" tag="" react=""/> http://localhost:3000/ URL。确保您的Django API已经启动并运行。</p>
<h2 id="conclusion">结论</h2>
<p>你可以<a href="https://github.com/diogosouza/django-react-logrocket" target="_blank" rel="noreferrer noopener">在这里</a>访问这个项目的完整源代码。</p>
<p>当然，这只是一种方法。使用React的好处是，您可以用多种不同的方式组织组件(或者甚至在现有组件的基础上创建更多组件)来实现相同的目标。</p>
<p>在SPAs的世界中，您的后端API实际上完全独立于前端客户端。这给了你改变整个API架构的灵活性(比如从Django切换到<a href="https://github.com/pallets/flask" target="_blank" rel="noreferrer noopener"> Flask </a>，而不会对你的React应用产生任何副作用。</p>
<p>作为一个挑战，尝试给你的API/React应用添加一个<a href="https://blog.logrocket.com/4-ways-to-render-large-lists-in-react/" target="_blank" rel="noreferrer noopener">分页系统</a>。Django REST框架提供了对<a href="https://www.django-rest-framework.org/api-guide/pagination/" target="_blank" rel="noreferrer noopener">可定制分页样式</a>的支持。</p><div class="code-block code-block-17">
<div class="blog-plug inline-plug react-plug" vwo-el-id="26283398190">
<h2 vwo-el-id="41600691720">使用LogRocket消除传统反应错误报告的噪音</h2>
<a href="https://lp.logrocket.com/blg/react-signup-issue-free" target="_blank" vwo-el-id="19356441070">LogRocket
</a><p>是一款React analytics解决方案，可保护您免受数百个误报错误警报的影响，只针对少数真正重要的项目。LogRocket告诉您React应用程序中实际影响用户的最具影响力的bug和UX问题。</p><a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="19356441380">
<img class="first-react-image alignnone size-full wp-image-46 jetpack-lazy-image jetpack-lazy-image--handled" src="../Images/f300c244a1a1cf916df8b4cb02bec6c6.png" vwo-el-id="18272717540" data-lazy-loaded="1" data-original-src="https://files.readme.io/27c94e7-Image_2017-06-05_at_9.46.04_PM.png"/>
</a>
<a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="19356441690">
<img class="second-react-image alignnone size-full wp-image-46 jetpack-lazy-image jetpack-lazy-image--handled" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" vwo-el-id="30720362350" data-lazy-loaded="1" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/>
</a>
<a href="https://lp.logrocket.com/blg/react-signup-issue-free" target="_blank" rel="noopener noreferrer" vwo-el-id="35866400580">LogRocket
</a><p>自动聚合客户端错误、反应错误边界、还原状态、缓慢的组件加载时间、JS异常、前端性能指标和用户交互。然后，LogRocket使用机器学习来通知您影响大多数用户的最具影响力的问题，并提供您修复它所需的上下文。</p><p vwo-el-id="28675661060">关注重要的React bug—<a class="signup" href="https://lp.logrocket.com/blg/react-signup-issue-free" target="_blank" rel="noopener noreferrer" vwo-el-id="40093418840">今天就试试LogRocket】。</a></p>
</div></div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
<html>
<head>
<title>JSONP demystified: What it is and why it exists - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>JSONP揭秘:它是什么，为什么存在</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/jsonp-demystified-what-it-is-and-why-it-exists/#0001-01-01">https://blog.logrocket.com/jsonp-demystified-what-it-is-and-why-it-exists/#0001-01-01</a></blockquote><div><article class="article-post">
<p>JSONP一直是所有web开发中最难解释的概念之一。这可能是由于它令人困惑的名字和粗略的背景。在采用<a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS" target="_blank" rel="noopener noreferrer">跨来源资源共享(CORS)标准</a>之前，JSONP是从不同来源的服务器获得JSON响应的唯一选择。</p>
<p>向不支持CORS的不同来源的服务器发送请求后，将会引发以下错误:</p>
<p><img data-attachment-id="10089" data-permalink="https://blog.logrocket.com/jsonp-demystified-what-it-is-and-why-it-exists/cors-support-error/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2019/11/cors-support-error.png" data-orig-size="730,64" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="CORS support error" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2019/11/cors-support-error-300x26.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2019/11/cors-support-error.png" decoding="async" class="aligncenter size-full wp-image-10089 jetpack-lazy-image" src="../Images/09ce004e594bf133de0071f51b3ab2cc.png" alt="CORS Support Error" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2019/11/cors-support-error.png 730w, https://blog.logrocket.com/wp-content/uploads/2019/11/cors-support-error-300x26.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2019/11/cors-support-error.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/11/cors-support-error.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="10089" data-permalink="https://blog.logrocket.com/jsonp-demystified-what-it-is-and-why-it-exists/cors-support-error/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2019/11/cors-support-error.png" data-orig-size="730,64" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="CORS support error" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2019/11/cors-support-error-300x26.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2019/11/cors-support-error.png" decoding="async" loading="lazy" class="aligncenter size-full wp-image-10089" src="../Images/09ce004e594bf133de0071f51b3ab2cc.png" alt="CORS Support Error" srcset="https://blog.logrocket.com/wp-content/uploads/2019/11/cors-support-error.png 730w, https://blog.logrocket.com/wp-content/uploads/2019/11/cors-support-error-300x26.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/11/cors-support-error.png"/></noscript>
<p>看到这种情况，许多人会在Google上搜索，结果发现需要JSONP来绕过同源策略。然后，以前无处不在的jQuery将带着其方便的JSONP实现加入到核心库中，这样我们只需切换一个参数就可以让它工作。许多人从来不明白，完全改变的是发送请求的底层机制。</p>
<pre>$.ajax({
 url: 'http://twitter.com/status/user_timeline/padraicb.json?count=10',
 dataType: 'jsonp',
 success: function onSuccess() { }
});</pre>
<p>为了理解幕后发生了什么，让我们看看JSONP到底是什么。</p>
<h2>JSONP是什么？</h2>
<p>JSON with Padding(简称JSONP)是一种允许开发人员通过使用<code>&lt;script&gt;</code>元素的性质来绕过浏览器强制执行的同源策略的技术。该政策不允许阅读来自不同于当前使用的网站的任何回复。顺便提一下，该策略允许发送请求，但不允许读取请求。</p>
<p>一个网站的起源由三部分组成。首先是URI方案(即<code>https://</code>)，然后是主机名(即<code>logrocket.com</code>)，最后是端口(即<code>443</code>)。像<code><a href="http://logrocket.com" rel="nofollow">http://logrocket.com</a></code>和<code><a href="https://logrocket.com" rel="nofollow">https://logrocket.com</a></code>这样的网站，由于URI方案的不同，有两种不同的起源。</p>
<p>如果您希望了解更多有关此政策的信息，<a href="https://developer.mozilla.org/en-US/docs/Web/Security/Same-origin_policy" target="_blank" rel="noopener noreferrer">请不要再看了</a>。</p>
<h2>它是如何工作的？</h2>
<p>让我们假设我们在<code>localhost:8000</code>上，我们向提供JSON API的服务器发送一个请求。</p>
<pre>https://www.server.com/api/person/1</pre>
<p>响应可能如下所示:</p>
<pre>{
  "firstName": "Maciej",
  "lastName": "Cieslar"
}</pre>
<p>但是由于上述政策，请求将被阻止，因为网站和服务器的来源不同。</p>
<p>不需要我们自己发送请求，可以使用<code>&lt;script&gt;</code>元素，策略并不适用于它——它可以从外部来源加载并执行JavaScript。这样，位于<code><a href="https://logrocket.com" rel="nofollow">https://logrocket.com</a></code>的网站可以从位于不同来源(即CDN)的提供商处加载谷歌地图库。</p>
<p>通过向<code>&lt;script&gt;</code>的<code>src</code>属性提供API的端点URL，<code>&lt;script&gt;</code>将获取响应并在浏览器上下文中执行它。</p>
<pre>&lt;script src="https://www.server.com/api/person/1" async="true"&gt;&lt;/script&gt;</pre>
<p>然而，问题是<code>&lt;script&gt;</code>元素会自动解析并执行返回的代码。在这种情况下，返回的代码将是上面显示的JSON片段。JSON将被解析为JavaScript代码，因此会抛出一个错误，因为它不是有效的JavaScript。</p>
<p><img data-attachment-id="10091" data-permalink="https://blog.logrocket.com/jsonp-demystified-what-it-is-and-why-it-exists/invalid-syntax-error/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2019/11/invalid-syntax-error.png" data-orig-size="730,362" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Invalid syntax error" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2019/11/invalid-syntax-error-300x149.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2019/11/invalid-syntax-error.png" decoding="async" class="aligncenter size-full wp-image-10091 jetpack-lazy-image" src="../Images/06d2b40a7ef1d29ac8dfe6d3dda1d6d0.png" alt="Invalid Syntax Error" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2019/11/invalid-syntax-error.png 730w, https://blog.logrocket.com/wp-content/uploads/2019/11/invalid-syntax-error-300x149.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2019/11/invalid-syntax-error.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/11/invalid-syntax-error.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="10091" data-permalink="https://blog.logrocket.com/jsonp-demystified-what-it-is-and-why-it-exists/invalid-syntax-error/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2019/11/invalid-syntax-error.png" data-orig-size="730,362" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Invalid syntax error" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2019/11/invalid-syntax-error-300x149.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2019/11/invalid-syntax-error.png" decoding="async" loading="lazy" class="aligncenter size-full wp-image-10091" src="../Images/06d2b40a7ef1d29ac8dfe6d3dda1d6d0.png" alt="Invalid Syntax Error" srcset="https://blog.logrocket.com/wp-content/uploads/2019/11/invalid-syntax-error.png 730w, https://blog.logrocket.com/wp-content/uploads/2019/11/invalid-syntax-error-300x149.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/11/invalid-syntax-error.png"/></noscript>
<p>必须返回一个完全正常工作的JavaScript代码，以便由<code>&lt;script&gt;</code>正确解析和执行。如果我们将JSON代码赋给一个变量或者作为一个函数的参数传递给它，它会工作得很好——毕竟，JSON格式只是一个JavaScript对象。</p>
<p>因此，服务器可以返回一段JavaScript代码，而不是返回一个纯JSON响应。在返回的代码中，函数包装在JSON对象周围。函数名必须由客户端传递，因为代码将在浏览器中执行。在名为<code>callback</code>的查询参数中提供了函数名。</p>
<p>在查询中提供回调的名称后，我们在全局(<code>window</code>)上下文中创建一个函数，一旦解析并执行了响应，就会调用这个函数。</p>
<pre>https://www.server.com/api/person/1?callback=callbackName</pre>
<pre>callbackName({
  "firstName": "Maciej",
  "lastName": "Cieslar"
})</pre>
<p>这与以下内容相同:</p>
<pre>window.callbackName({
  "firstName": "Maciej",
  "lastName": "Cieslar"
})</pre>
<p>代码在浏览器的上下文中执行。该函数将从全局范围内的<code>&lt;script&gt;</code>中下载的代码内部执行。</p>
<p>为了让JSONP工作，客户机和服务器都必须支持它。虽然定义函数名称的参数没有标准名称，但是客户端通常会在名为<code>callback</code>的查询参数中发送它。</p>
<h2>履行</h2>
<p>让我们创建一个名为<code>jsonp</code>的函数，它将以JSONP的方式发送请求。</p>
<pre>let jsonpID = 0;

function jsonp(url, timeout = 7500) {
  const head = document.querySelector('head');
  jsonpID += 1;

  return new Promise((resolve, reject) =&gt; {
    let script = document.createElement('script');
    const callbackName = `jsonpCallback${jsonpID}`;

    script.src = encodeURI(`${url}?callback=${callbackName}`);
    script.async = true;

    const timeoutId = window.setTimeout(() =&gt; {
      cleanUp();

      return reject(new Error('Timeout'));
    }, timeout);

    window[callbackName] = data =&gt; {
      cleanUp();

      return resolve(data);
    };

    script.addEventListener('error', error =&gt; {
      cleanUp();

      return reject(error);
    });

    function cleanUp() {
      window[callbackName] = undefined;
      head.removeChild(script);
      window.clearTimeout(timeoutId);
      script = null;
    }


    head.appendChild(script);
  });
}</pre>
<p>如您所见，有一个名为<code>jsonpID</code>的共享变量——它将用于确保每个请求都有自己唯一的函数名。</p>
<p>首先，我们将对<code>&lt;head&gt;</code>对象的引用保存在一个名为<code>head</code>的变量中。然后我们增加<code>jsonpID</code>来确保函数名是唯一的。在提供给返回的承诺的回调中，我们创建了一个<code>&lt;script&gt;</code>元素和由字符串<code>jsonpCallback</code>和唯一ID连接组成的<code>callbackName</code>。</p>
<p>然后，我们将<code>&lt;script&gt;</code>元素的<code>src</code>属性设置为所提供的URL。在查询中，我们将回调参数设置为等于<code>callbackName</code>。请注意，这个简化的实现不支持具有预定义查询参数的URL，所以它不适用于像<code><a href="https://logrocket.com/?param=true" rel="nofollow">https://logrocket.com/?param=true</a></code>这样的东西，因为我们将再次在末尾添加<code>?</code>。</p>
<p>我们还将<code>async</code>属性设置为<code>true</code>,以便脚本不阻塞。</p>
<p>该请求有三种可能的结果:</p>
<ol>
<li>请求成功，并执行<code>window[callbackName]</code>，它用结果(JSON)解析承诺</li>
<li>元素抛出一个错误，我们拒绝了这个承诺</li>
<li>请求花费的时间比预期的长，超时回调开始，抛出超时错误</li>
</ol>
<pre>const timeoutId = window.setTimeout(() =&gt; {
  cleanUp();

  return reject(new Error('Timeout'));
}, timeout);

window[callbackName] = data =&gt; {
  cleanUp();

  return resolve(data);
};

script.addEventListener('error', error =&gt; {
  cleanUp();

  return reject(error);
});</pre>
<p>回调必须在<code>window</code>对象上注册，以便在创建的<code>&lt;script&gt;</code>上下文中可用。在全局范围内执行一个名为<code>callback()</code>的函数相当于调用<code>window.callback()</code>。</p>
<p>通过在<code>cleanUp</code>函数中抽象清理过程，三个回调——超时、成功和错误监听器——看起来完全一样。唯一的区别是他们是决定还是拒绝这个承诺。</p><div class="code-block code-block-54">
<hr/>
<h3>更多来自LogRocket的精彩文章:</h3>

<hr/></div>
<pre>function cleanUp() {
  window[callbackName] = undefined;
  head.removeChild(script);
  window.clearTimeout(timeoutId);
  script = null;
}</pre>
<p><code>cleanUp</code>函数是为了在请求之后进行清理而需要做的事情的抽象。该函数首先移除在窗口上注册的回调，该回调在成功响应时被调用。然后它从<code>&lt;head&gt;</code>中移除<code>&lt;script&gt;</code>元素并清除超时。此外，为了确保万无一失，它将<code>script</code>引用设置为<code>null</code>，这样它就被垃圾收集了。</p>
<p>最后，我们将<code>&lt;script&gt;</code>元素添加到<code>&lt;head&gt;</code>中，以便触发请求。<code>&lt;script&gt;</code>将在附加请求后自动发送请求。</p>
<p>下面是用法的例子:</p>
<pre>jsonp('https://gist.github.com/maciejcieslar/1c1f79d5778af4c2ee17927de769cea3.json')
 .then(console.log)
 .catch(console.error);</pre>
<p>这里有一个<a href="https://codesandbox.io/embed/festive-mendel-zt0ih?fontsize=14&amp;hidenavigation=1&amp;theme=dark">活生生的例子</a>。</p>
<h2>摘要</h2>
<p>通过理解JSONP的底层机制，您可能不会在直接适用的web技能方面有太多收获，但看到人们的独创性如何绕过最严格的策略总是很有趣的。</p>
<p>JSONP是过去的遗物，由于许多限制(例如，只能发送GET请求)和许多安全问题(例如，服务器可以用它想要的任何JavaScript代码来响应——不一定是我们期望的那个——这样就可以访问窗口上下文中的所有内容，包括<code>localStorage</code>和<code>cookies</code>)。<a href="https://stackoverflow.com/questions/613962/is-jsonp-safe-to-use" target="_blank" rel="noopener noreferrer">点击此处阅读更多</a>。</p>
<p>相反，我们应该依靠CORS机制来提供安全的跨来源请求。</p><div class="code-block code-block-2">
<div class="blog-plug base-cta"><h2>使用<a class="signup" href="https://lp.logrocket.com/blg/signup" target="_blank" rel="noopener noreferrer"> LogRocket </a>消除传统错误报告的干扰</h2>
<a href="https://lp.logrocket.com/blg/signup" class="signup" target="_blank" rel="noopener noreferrer"><img class="alignnone size-full wp-image-46 jetpack-lazy-image" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/><noscript><img data-lazy-fallback="1" class="alignnone size-full wp-image-46" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/></noscript></a>
<p><a href="https://lp.logrocket.com/blg/signup" target="_blank" rel="noopener noreferrer"> LogRocket </a>是一个数字体验分析解决方案，它可以保护您免受数百个假阳性错误警报的影响，只针对几个真正重要的项目。LogRocket会告诉您应用程序中实际影响用户的最具影响力的bug和UX问题。</p>
<p>然后，使用具有深层技术遥测的会话重放来确切地查看用户看到了什么以及是什么导致了问题，就像你在他们身后看一样。</p>
<p>LogRocket自动聚合客户端错误、JS异常、前端性能指标和用户交互。然后LogRocket使用机器学习来告诉你哪些问题正在影响大多数用户，并提供你需要修复它的上下文。</p>
<p>关注重要的bug—<a class="signup" href="https://lp.logrocket.com/blg/signup-issue-free" target="_blank" rel="noopener noreferrer">今天就试试LogRocket】。</a></p></div></div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
<html>
<head>
<title>Vuex showdown: Mutations vs. actions - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>Vuex摊牌:突变与行动</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/vuex-showdown-mutations-vs-actions/#0001-01-01">https://blog.logrocket.com/vuex-showdown-mutations-vs-actions/#0001-01-01</a></blockquote><div><article class="article-post">
<p><em> <strong>编者按</strong>:这篇文章在2021年9月被审查和更新，以提供关于Vuex中突变和动作的使用的更新信息和更大的清晰度。</em></p>
<p>突变和动作是Vuex的核心。它们不仅允许你改变你的状态，而且在整个Vuex中起到组织和结构的作用。</p>
<p>Vuex突变和动作的唯一问题是，在确定何时以及如何使用它们时会很混乱。这可能导致不必要的样板文件，使用反模式，以及其他不良后果。</p>
<p>因此，让我们深入研究一下突变和动作，看看您应该在什么时候使用它们！</p>
<h2>Vuex中的突变和作用</h2>
<p>在Vuex中，突变是改变存储状态的唯一方法。它们相对简单，为所有Vuex用户所熟知。</p>
<p>当你把行动混在一起时，混乱就开始了。学习Vuex时，可能需要一段时间才能清楚动作和突变之间的区别。通常，开发人员可能会看到这样的代码:</p>
<pre class="language-javascript hljs">mutations: {
  setName(state, name) {
    state.name = name;
  },
},
actions: {
  setName({ commit }, name) {
    commit('setName', name);
  },
},
</pre>
<p>想想:为什么有这么多样板文件？</p>
<p>Vuex医生说:</p>
<blockquote><p>动作类似于突变，不同之处在于:</p>
<ul>
<li>动作提交突变，而不是改变状态</li>
<li>动作可以包含任意的异步操作</li>
</ul>
</blockquote>
<p>所以在很多例子中，我们看到一个API调用在一个动作中，这导致了一个变异的提交:</p>
<pre class="language-javascript hljs">actions: {
  loadBooks({ commit }) {
    commit('startLoading');
    get('/api/books').then((response) =&gt; {
      commit('setBooks', response.data.books);
      commit('stopLoading');
    });
  },
},
</pre>
<p>不看任何突变，仍然应该相当清楚发生了什么:</p>
<ol>
<li>在API调用开始之前，设置加载标志</li>
<li>然后，调用使用承诺异步返回</li>
<li>然后，调用将提交响应数据，随后是<code>stopLoading</code>，这很可能会取消加载标志</li>
</ol>
<p>上面的代码中有一个值得注意的设计选择:它使用了两个突变，其中一个就足够了。<code>startLoading</code> / <code>stopLoading</code>突变可以用一个具有布尔有效载荷的单个突变(<code>setLoading</code>)代替，然后<code>stopLoading</code>可以改为<code>commit(‘setLoading’, false)</code>。</p>
<p>上面的例子需要两个突变，这意味着需要维护更多的代码。这个推理与建议相同，即<a href="https://blog.logrocket.com/5-things-to-consider-when-creating-your-css-style-guide-7b85fa70039d/" target="_blank" rel="noopener"> CSS类不要根据它们应用的样式命名为</a>，而要根据样式的含义命名——也就是说，不要称之为<code>redAndBold</code>，而要称之为<code>activeMenuItem</code>。</p>
<p>通过调用变异<code>set&lt;Property&gt;</code>，意味着接口什么都不抽象；对实现的任何更改都可能意味着对接口的更改。我们将很快看到一个例子，在这个例子中，突变抽象得到了回报。</p>
<p>保持突变只关注特定的任务是一个好的实践。由于历史跟踪和<a href="https://blog.logrocket.com/5-vue-devtools-hacks/" target="_blank" rel="noopener"> Vue DevTools </a>，在调试全局状态以查找bug时，这成为一个很大的优势。</p>
<h2>Vuex历史跟踪和时间旅行调试</h2>
<p>现代状态管理工具的驱动需求之一是可追溯性。在前几代状态管理中，当系统进入不一致的状态时，很难弄清楚它是如何进入这种状态的。</p>
<p>使用<a href="https://blog.logrocket.com/5-useful-development-tools-for-vue-js/" target="_blank" rel="noopener">Vue dev tools</a>，可以看到应用于单个全局状态的突变的清晰历史。</p>
<p>就拿上面的<code>loadBooks</code>例子来说吧。一个周五的晚上，一个叫Alex的开发人员开始开发在书籍旁边加载和显示作者的功能。作为起点，他们复制并粘贴已有的动作，只做了微小的修改。</p>
<pre class="language-javascript hljs">actions: {
  loadBooks({ commit }) {
    commit('startLoading');
    get('/api/books').then((response) =&gt; {
      commit('setBooks', response.data.books);
      commit('stopLoading');
    });
  },
  loadAuthors({ commit }) {
    commit('startLoading');
    get('/api/authors').then((response) =&gt; {
      commit('setAuthors', response.data.authors);
      commit('stopLoading');
    });
  },
},
</pre>
<p>经过一些快速的开发人员测试后，它工作了，Alex高兴地部署到staging。第二天，出现了一个错误报告，指出在使用该数据的页面上，首先会看到一个微调器，但随后它会消失，显示一个未对齐的空白屏幕。然后，几秒钟后，内容出现，一切正常。</p>
<p>亚历克斯试图重现这个问题，不幸的是，这是零星的。几次尝试后，问题再次出现，Vue DevTools显示如下:</p>
<p><img decoding="async" src="../Images/18736eeb34782e507125afcfe40d996a.png" alt="Vuex tab in Vue DevTools" data-lazy-src="https://storage.googleapis.com/blog-images-backup/1*POCf8tMGwspoeKA5RNsX4g.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" class=" jetpack-lazy-image" data-original-src="https://storage.googleapis.com/blog-images-backup/1*POCf8tMGwspoeKA5RNsX4g.png"/></p><noscript><img data-lazy-fallback="1" decoding="async" src="../Images/18736eeb34782e507125afcfe40d996a.png" alt="Vuex tab in Vue DevTools" data-original-src="https://storage.googleapis.com/blog-images-backup/1*POCf8tMGwspoeKA5RNsX4g.png"/></noscript>
<p>Alex使用时间旅行调试来循环过去的突变，并返回到导致视觉故障的状态。他们意识到简单的布尔加载标志对多个异步请求不起作用；历史清楚地表明，这两个行动有交错的突变。</p>
<p>不管你是否认为这是你在代码中发现的错误，Vuex提供的时间旅行调试肯定是一个非常强大的跟踪工具。由于它的突变概念，它可以提供一个有意义的状态修改事件序列。</p>
<h3>为什么突变不能访问getters？</h3>
<p>突变的另一个有助于其事务性质的方面是，它们旨在成为纯函数。突变旨在仅通过其有效载荷接收输入，而不会在其他地方产生副作用。虽然动作有一个完整的上下文来处理，但是变异只有<code>state</code>和<code>payload</code>。</p>
<p>在Vue DevTools中调试时，如果突变列表没有给出问题来源的线索，也会显示突变的有效负载。这是可能的，因为它们是纯函数。</p>
<h3>抽象的修正</h3>
<p>让我们回到亚历克斯的问题上来。我们必须对代码进行一些修改，以支持多个并发API请求。下面是相关的突变现在的样子:</p>
<pre class="language-javascript hljs">state: { loading: false },
mutations: {
  startLoading(state) {
    state.loading = true;
  },
  stopLoading(state) {
    state.loading = false;
  },
},
</pre>
<p>以下是一个不需要对操作进行任何更改的解决方案:</p>
<pre class="language-javascript hljs">state: { loading: 0 },
mutations: {
  startLoading(state) {
    state.loading += 1;
  },
  stopLoading(state) {
    state.loading -= 1;
  },
},
</pre>
<p>如果这个变异的接口是<code>setLoading</code>，如前所述，这可能意味着修复必须改变动作中的提交代码，或者忍受一个混淆底层功能的接口。</p>
<p>这可能不是一个严重的反模式，但值得指出的是，如果一个开发人员将突变视为一个没有抽象的层，它会降低该层的责任，并且更有可能代表纯粹的样板文件，而不是任何有价值的东西。如果每个变异都是带有<code>set&lt;Property&gt;</code>名称的单个赋值，那么本文顶部的<code>setName</code>示例将是许多商店代码的样子，开发人员将会感到沮丧。</p>
<p>为了确保这种情况不会发生，请始终记住，行动也应该服务于功能角色。如果你的行为可以通过一个简单的突变来完成，就保持这样。仅当您的状态更改代码:</p>
<ul>
<li>超越了突变</li>
<li>需要按照一定的顺序进行一些突变</li>
<li>处理异步代码</li>
</ul>
<h2>找到合适数量的突变抽象</h2>
<p>考虑这篇文章开头的<code>setName</code>例子:</p>
<pre class="language-javascript hljs">mutations: {
  setName(state, name) {
    state.name = name;
  },
},
actions: {
  setName({ commit }, name) {
    commit('setName', name);
  },
},
</pre>
<p>从Vuex开始时出现的一个问题是，“突变应该被包装在动作中吗？”有什么好处？首先，store提供了一个外部的<code>commit</code> API，使用它并不会否定DevTools中突变的好处。那为什么要包起来呢？</p>
<p>如前所述，突变是纯函数和同步的。仅仅因为现在需要的任务可以通过突变来处理，并不意味着下个月的特性不需要比一个突变所能提供的更多。将突变包装在动作中是一种实践，它为未来的开发留出了空间，而不需要更改所有的调用代码——这与Alex的修复中的突变抽象概念非常相似。</p>
<p>当然，知道它为什么在那里并不能消除样板代码给开发者带来的挫败感。</p><div class="code-block code-block-54">
<hr/>
<h3>更多来自LogRocket的精彩文章:</h3>

<hr/></div>
<h3>减少样板文件</h3>
<p>针对这个样板文件的一个非常简洁的解决方案是<a href="https://davestewart.github.io/vuex-pathify/#/" target="_blank" rel="noopener"> Vuex Pathify </a>提供的:它试图使用尽可能少的代码创建一个商店，这是一个简洁的API，采用了许多开发人员所推崇的约定胜于配置的方法。简介中最引人注目的陈述之一是:</p>
<pre class="language-javascript hljs">make.mutations(state)
</pre>
<p>这直接从状态中自动生成了<code>set&lt;Property&gt;</code>样式的突变，这当然去除了样板文件，但是也去除了突变层可能具有的任何值。</p>
<h2>Vuex行动的好处</h2>
<p>动作是一个非常开放的逻辑层；没有什么事情是在商店之外做不到的，简单地说，行动都集中在商店里。</p>
<p>动作和您可能在商店外声明的任何类型的函数之间的一些差异:</p>
<ol>
<li>无论是在调度动作时，还是在动作可用的上下文中，动作的范围都可以是模块</li>
<li>可以通过<code>subscribeAction</code>商店API拦截动作</li>
<li>默认情况下，动作是承诺的，就像异步函数一样</li>
</ol>
<p>这种功能的大部分属于方便和约定的范畴。</p>
<h3>async/await在这里适合做什么？</h3>
<p>Async/await可以很好地处理动作。下面是前面用async/await实现的<code>loadBooks</code>示例的样子:</p>
<pre class="language-javascript hljs">actions: {
  async loadBooks({ commit }) {
    commit('startLoading');
    const response = await get('/api/books');
    commit('setBooks', response.data.books);
    commit('stopLoading');
  },
},
</pre>
<p>然而这在功能上是不等价的；有一个微妙的区别。相反，上述内容在功能上等同于以下内容:</p>
<pre class="language-javascript hljs">actions: {
  loadBooks({ commit }) {
    commit('startLoading');
    return get('/api/books').then((response) =&gt; {
      commit('setBooks', response.data.books);
      commit('stopLoading');
    });
  },
}
</pre>
<p>需要注意的关键是<code>return</code>语句。这意味着动作返回的承诺正在等待内心的承诺完成。接下来，它还检测返回的承诺何时实现，并在<code>dispatch</code>调用中使用它。</p>
<pre class="language-javascript hljs">store.dispatch('loadBooks').then(() =&gt; {
  // ...
})
</pre>
<h2>变异粒度</h2>
<p>如果大多数(但不是全部)变异都是单行函数，那么原子的、事务性的变异可能只是一个单一的变异语句(例如赋值)。DevTools中的变化轨迹可能如下所示:</p>
<pre class="language-javascript hljs">state.loading = true;
state.loading = true;
state.books = […];
state.loading = false;
state.authors = […];
state.loading = false;
</pre>
<p>然而，由于大量的操作并行运行，这可能会令人困惑，而且没有突变目前提供的有意义的名称，可能很难调试。</p>
<p>最近Vue DevTools增加了在DevTools时间线中查看动作的功能，就在突变旁边，在这种情况下肯定会有帮助。</p>
<h2>融合这些概念:一个实验</h2>
<p>作为一个发人深省的实验，让我们尝试将突变和动作合二为一。这可以让我们更好地理解为什么这两个概念应该(或者不应该)分开。</p>
<p>这是我们的新创造，或“变异”，可能看起来像:</p>
<pre class="language-javascript hljs">mutactions: {
  async loadBooks({ state }) {
    state.loading += 1;
    const response = await get('/api/books');
    state.books = response.data.books;
    state.loading -= 1;
  },
}
</pre>
<p>如果没有单独的动作，单个突变(也称为“变动作”)负责管理状态和异步请求。虽然这在表面上可能工作得很好，但我们需要一些额外的修补来使这个概念适应Vue DevTools。</p>
<h3>利用反应魔法</h3>
<p>利用反应做一些聪明的事情总是好的——在这里能做吗？动作通常不是反应性的。在Vue生态系统中，只有以下功能是反应式功能:</p>
<ul>
<li>组件的渲染</li>
<li>一个观察者</li>
<li>计算出来的财产</li>
<li>商店吸货员</li>
</ul>
<p>它们将在每次运行时被“记录”,如果它们的依赖项触发，它们将被“回放”。反应性就像一个捕鼠器，一放就弹起。</p>
<p>反应性的记录阶段可能是我们可以效仿的模式。但这里有一个可能不会立即显现的巨大挑战:反应性记录是同步的。</p>
<p>那是什么意思？好吧，这里有一个测试代码笔:</p>
<p class="codepen" data-height="300" data-theme-id="dark" data-default-tab="css,result" data-slug-hash="WWEmEj" data-user="mikeapr4">参见<a href="https://codepen.io"> CodePen </a>上迈克尔加拉格尔(<a href="https://codepen.io/mikeapr4"> @mikeapr4 </a> ) <br/>的Pen <a href="https://codepen.io/mikeapr4/pen/WWEmEj"> <br/>异步守望者</a>。</p>
<p/>
<p>以上是对一些反应数据的两位观察者。两个观察器是相同的，除了一个有异步的获取器。正如您所观察到的，这个观察器没有触发，而同一个同步观察器触发了。为什么？</p>
<p>反应性目前基于依赖函数的全局堆栈工作。好奇的话可以翻看<code><a href="https://github.com/vuejs/vue/blob/dev/src/core/observer/dep.js" target="_blank" rel="noopener">/observer/dep.js</a></code>看看。要做到这一点，反应必须是同步的。</p>
<h3>一些代理魔术？</h3>
<p>Vue 3使用<code>Proxy</code>类来获得更透明的反应。这个功能是否给了我们任何可以用来完成异步记录的东西？</p>
<p>首先，让我们暂时把性能问题放在一边，因为我们认为运行DevTools的是一个<em>开发者</em>，而不是一个用户。如果手头有更多的调试选项，资源的增加和性能的下降是允许的。</p>
<p>这里有一个模拟Vuex商店的例子。它包括亚历克斯的<code>loadBooks</code>和<code>lookAuthor</code>动作与突变合并在一起成为一个单一的“变异动作”。</p>
<p class="codepen" data-height="300" data-theme-id="dark" data-default-tab="css,result" data-slug-hash="NWvGYYN" data-user="areknawo">参见<a href="https://codepen.io"> CodePen </a>上阿雷克·纳沃(<a href="https://codepen.io/areknawo">@阿雷克那沃</a> ) <br/>的笔<a href="https://codepen.io/areknawo/pen/NWvGYYN"> <br/>变招</a>。</p>
<p>控制台日志是低粒度突变可追溯性的基本起点，由调用它们的动作分组。此外，操作的开始和结束也按时间顺序记录。</p>
<p>那么代码中发生了什么呢？</p>
<p>如前所述，我们不可能全局跟踪一个异步堆栈，并且在发生突变时访问调用堆栈的选项也不多——您可以抛出并捕获一个错误，或者使用不推荐的/禁止的<code>arguments.caller</code>。</p>
<p>然而，当我们将<code>state</code>对象传递给动作时，我们知道“突变动作”，并且我们知道所有的突变都将通过该对象。因此，我们将<code>state</code>(一个全局单实例)包装在一个特殊的自定义<code>Proxy</code>中，并引用了“mutaction”</p>
<p>如果子属性被读取，代理会自我传播，并最终为任何写入触发一个日志。这个示例代码显然是为简单、愉快的路径功能编写的，但它证明了这个概念。这里有一个内存开销，但是这些自定义代理将和“mutaction”执行一样长。</p>
<p>“mutactions”使用async/await，并且必须等待所有异步功能，确保返回的承诺只有在动作真正完成时才会解析/拒绝。这里可能有一个拒绝的警告，拒绝不会等待所有潜在的承诺完成。</p>
<h2>时间旅行</h2>
<p>这种粒度突变的缺点是，如果对每个突变都继续执行时间旅行调试步骤，那么每次保存整个状态的开销将会非常大。</p>
<p>然而，反应性可以在这里提供一个范例，因为默认情况下，它在触发观察者之前等待<code>nextTick</code>。如果DevTools在存储状态快照之前做了同样的事情，这意味着这些步骤可能会围绕今天的突变概念。</p>
<p>该显示每个节拍只会重新渲染一次，因此提供更低粒度的时间旅行步骤没有多大意义。</p>
<h2>结论</h2>
<p>突变提供了简单性和可追溯性、更少的样板文件、灵活性和组合性。它们可以添加到Vuex中，同时仍然保持向后兼容性，以便逐渐采用。</p><div class="code-block code-block-20">
<div class="blog-plug inline-plug vue-inline"><h2>像用户一样体验您的Vue应用</h2><p>调试Vue.js应用程序可能会很困难，尤其是当用户会话期间有几十个(如果不是几百个)突变时。如果您对监视和跟踪生产中所有用户的Vue突变感兴趣，</p><a href="https://lp.logrocket.com/blg/vue-signup" target="_blank">try LogRocket</a><p>. </p><a class="signup" href="https://lp.logrocket.com/blg/vue-signup" target="_blank" rel="noopener noreferrer"><img class="alignnone size-full wp-image-46 jetpack-lazy-image" src="../Images/0d269845910c723dd7df26adab9289cb.png" alt="LogRocket Dashboard Free Trial Banner" data-lazy-src="https://files.readme.io/00591d0-687474703a2f2f692e696d6775722e636f6d2f6a3049327856572e706e67.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://files.readme.io/00591d0-687474703a2f2f692e696d6775722e636f6d2f6a3049327856572e706e67.png"/><noscript><img data-lazy-fallback="1" class="alignnone size-full wp-image-46" src="../Images/0d269845910c723dd7df26adab9289cb.png" alt="LogRocket Dashboard Free Trial Banner" data-original-src="https://files.readme.io/00591d0-687474703a2f2f692e696d6775722e636f6d2f6a3049327856572e706e67.png"/></noscript></a><a href="https://lp.logrocket.com/blg/vue-signup" target="_blank" rel="noopener noreferrer">https://logrocket.com/signup/</a><p>LogRocket 就像是网络和移动应用程序的DVR，记录你的Vue应用程序中发生的一切，包括网络请求、JavaScript错误、性能问题等等。您可以汇总并报告问题发生时应用程序的状态，而不是猜测问题发生的原因。</p><p>LogRocket Vuex插件将Vuex突变记录到LogRocket控制台，为您提供导致错误的环境，以及出现问题时应用程序的状态。</p><p>现代化您调试Vue应用的方式- <a class="signup" href="https://lp.logrocket.com/blg/vue-signup" target="_blank" rel="noopener noreferrer">开始免费监控</a>。</p></div>


</div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
<html>
<head>
<title>Caching headers: A practical guide for frontend developers - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>缓存头:前端开发人员实用指南</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/caching-headers-a-practical-guide-for-frontend-developers/#0001-01-01">https://blog.logrocket.com/caching-headers-a-practical-guide-for-frontend-developers/#0001-01-01</a></blockquote><div><article class="article-post">
<p>开发人员和运营人员可以使用多个头文件来操作缓存行为。</p>
<p>旧规范和新规范混杂在一起:有许多设置需要配置，并且您会发现多个用户报告了不一致的行为。</p>
<p>在这篇文章中，我将重点解释不同的头如何影响浏览器缓存，以及它们如何与代理服务器相关联。</p>
<p>您将看到一个Nginx配置示例和运行Express的Node.js代码。最后，我们将研究在React中创建的流行服务如何服务于它们的web应用程序。</p>
<p>对于单页面应用程序，我感兴趣的是无限缓存JavaScript、CSS、字体和图像文件，并防止缓存HTML文件和服务人员(如果有)。</p>
<p>这个策略是可行的，因为我的资产文件在文件名中有唯一的标识符。</p>
<p>您可以在WebPack中实现相同的配置，在资产的文件名中包含一个<code>[hash]</code>，或者更好的是一个<code>[chunkhash]</code>。这种技术被称为<a href="https://developers.google.com/web/fundamentals/performance/webpack/use-long-term-caching" target="_blank" rel="noopener noreferrer">长期缓存</a>。</p>
<p>但是当你阻止重新下载时，你如何更新你的网站呢？保持更新网站的能力是永远不缓存HTML文件如此重要的原因。</p>
<p>每次你访问我的网站时，浏览器都会从服务器获取一份新的HTML文件，只有当有新的脚本src或链接hrefs时，浏览器才会从服务器下载新的资源。</p>
<h3>缓存控制</h3>
<pre>Cache-Control: no-store</pre>
<p>当浏览器被告知<code>no-store</code>时，它不应该存储任何关于请求的信息。您可以将它用于HTML和服务工作者脚本。</p>
<pre>Cache-Control: public, no-cache

or

Cache-Control: public, max-age=0, must-revalidate</pre>
<p>这两者是等效的，尽管有无缓存的名称，但允许提供缓存的响应，只是浏览器必须验证缓存是否是新的。</p>
<p>如果您正确地设置了ETag或Last-Modified头，以便浏览器可以验证它已经缓存了最新的版本，那么您和您的用户将会节省带宽。您可以将它用于HTML和服务工作者脚本。</p>
<pre>Cache-Control: private, no-cache

or

Cache-Control: private, max-age=0, must-revalidate</pre>
<p>以此类推，这两者也是等价的。公共和私有的区别在于共享缓存(例如CDN)可以缓存公共响应，但不能缓存私有响应。</p>
<p>本地缓存(例如浏览器)仍然可以缓存私有响应。在服务器上呈现HTML时使用private，呈现的HTML包含特定于用户的信息或敏感信息。</p>
<p>就框架而言，对于典型的Gatsby博客，您不需要设置private，但是对于需要授权访问的页面，您应该考虑使用Next.js。</p>
<pre>Cache-Control: public, max-age=31536000, immutable</pre>
<p>在本例中，浏览器将根据max-age指令(60 <em> 60 </em> 24*365)缓存一年的响应。</p>
<p>不可变指令告诉浏览器这个响应(文件)的内容不会改变，并且浏览器不应该通过发送If-None-Match (ETag验证)或If-Modified-Since(Last-Modified验证)来验证其缓存。</p>
<p>使用静态资产来支持长期缓存策略。</p>
<h3>杂注和过期</h3>
<pre>Pragma: no-cache
Expires: &lt;http-date&gt;</pre>
<p>Pragma是在<a href="https://www.w3.org/Protocols/HTTP/1.0/spec.html#Pragma" target="_blank" rel="noopener noreferrer"> HTTP/1.0规范</a>中定义为请求头的旧头。</p>
<p>后来，<a href="https://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.32" target="_blank" rel="noopener noreferrer"> HTTP/1.1规范</a>规定<code>Pragma: no-cache</code>响应应该作为<code>Cache-Control: no-cache</code>来处理，但是这并不是一个可靠的替代，因为它仍然是一个请求头。</p>
<p>我也一直使用<code>Pragma: no-cache</code>作为OWASP <a href="https://www.owasp.org/index.php/OWASP_Application_Security_FAQ#How_do_I_ensure_that_sensitive_pages_are_not_cached_on_the_user.27s_browser.3F" target="_blank" rel="noopener noreferrer">安全建议。</a></p>
<p>包含<code>Pragma: no-cache</code>头是一种预防措施，可以保护不支持较新的缓存控制机制的遗留服务器，这些服务器可能会缓存您不打算缓存的内容。</p>
<p>有些人会说，除非你必须支持Internet Explorer 5或Netscape，否则你不需要Prama或Expires。归结起来就是支持遗留软件。</p>
<p>代理普遍理解Expires头，这给了它一点优势。</p><div class="code-block code-block-54">
<hr/>
<h3>更多来自LogRocket的精彩文章:</h3>

<hr/></div>
<p>对于HTML文件，我禁用Expires头，或者将其设置为过去的日期。对于静态资产，我通过Nginx expires指令将它与Cache-Control的max-age一起管理。</p>
<h3>ETags</h3>
<pre>ETag: W/"5e15153d-120f"

or

ETag: "5e15153d-120f"</pre>
<p>ETags是缓存验证的几种方法之一。ETag必须唯一地标识资源，通常情况下，web服务器会从资源内容中生成一个指纹。</p>
<p>当资源改变时，它会有不同的ETag值。</p>
<p>有两种类型的电子标签。弱ETags等式表示资源在语义上是等价的。强ETags验证表明资源是完全相同的。</p>
<p>您可以通过为弱ETags设置的“W/”前缀来区分这两者。</p>
<p>弱ETags不适合字节范围的请求，但是它们很容易动态生成。</p>
<p>实际上，您不打算自己设置ETags并让您的web服务器处理它们。</p>
<pre>curl -I &lt;http-address&gt;
curl -I -H "Accept-Encoding: gzip" &lt;http-address&gt;</pre>
<p>您可能会看到，当您从Nginx请求一个静态文件时，它会设置一个强ETag。当启用了gzip压缩，但您没有上传压缩文件时，动态压缩会导致弱ETags。</p>
<p>通过发送带有缓存资源的ETag的“If-None-Match”请求头，浏览器期望带有新资源的200 OK响应，或者空的304 Not Modified响应，这指示您应该使用缓存资源而不是下载新资源。</p>
<p>同样的优化也适用于API GET响应，并且不限于静态文件。</p>
<p>如果您的应用程序接收到大量的JSON有效负载，您可以配置您的后端，根据有效负载的内容来计算和设置ETag(例如，使用md5)。</p>
<p>在将其发送到客户端之前，将其与“如果不匹配”请求报头进行比较。</p>
<p>如果有匹配，而不是发送有效负载，发送304未修改，以节省带宽和提高web应用程序的性能。</p>
<h3>最后修改的</h3>
<pre>Last-Modified: Tue, 07 Jan 2020 23:33:17 GMT</pre>
<p>最后修改响应报头是另一种高速缓存控制机制，并且使用最后修改日期。Last-Modified标头是更准确的ETags的后备机制。</p>
<p>通过发送具有缓存资源的最后修改日期的“If-Modified-Since”请求报头，浏览器期望具有较新资源的200 OK响应或者空的304 Not Modified响应，这指示应该使用缓存的资源而不是下载新的资源。</p>
<h3>排除故障</h3>
<p>当您设置标头然后测试配置时，请确保您在网络方面靠近服务器。我的意思是，如果您的服务器已经Dockerized，那么运行容器并在本地测试它。</p>
<p>如果您配置了一个虚拟机，那么ssh到该虚拟机并在那里测试头。如果您有一个Kubernetes集群，请启动一个pod并从集群中调用您的服务。</p>
<p>在生产设置中，您将使用负载平衡器、代理和cdn。在这些步骤中的每一步，您的头都可能被修改，所以知道您的服务器首先发送了正确的头，调试会容易得多。</p>
<p>如果您启用了电子邮件地址混淆或自动HTTPS重写，意外行为的一个示例可能是Cloudflare删除ETag标头。</p>
<p>祝你通过改变你的服务器配置来调试它好运！在Cloudflare看来，这种行为<a href="https://support.cloudflare.com/hc/en-us/articles/218505467-Using-ETag-Headers-with-Cloudflare" target="_blank" rel="noopener noreferrer">被很好地记录了下来</a>并且非常有意义，因此了解您的工具是您的责任。</p>
<pre>Cache-Control: max-age=31536000
Cache-Control: public, immutable</pre>
<p>在这篇文章的前面，我在代码片段的标题之间加了“or”来表示这是两个不同的例子。有时，您可能会注意到HTTP响应中有多个相同的头。</p>
<p>这意味着两个标题都适用。一些代理服务器可以一路合并报头。上面的例子相当于:</p>
<pre>Cache-Control: max-age=31536000, public, immutable</pre>
<p>使用<code>curl</code>将会给你最一致的结果和在多种环境中运行的便利性。</p>
<p>如果您决定使用web浏览器，请确保在调试缓存问题时查看服务人员。服务工人调试是另一篇文章的复杂主题。</p>
<p>要解决缓存问题，请确保在DevTools应用程序选项卡中启用了绕过服务工作器。</p>
<h3>Nginx配置</h3>
<p>既然您已经了解了不同类型的缓存头的作用，那么是时候将您的知识付诸实践了。</p>
<p>下面的Nginx配置将服务于一个支持长期缓存的单页面应用程序。</p>
<pre>gzip on;
gzip_disable "msie6";
gzip_vary on;
gzip_proxied any;
gzip_comp_level 6;
gzip_buffers 16 8k;
gzip_http_version 1.1;
gzip_types text/plain text/css application/json application/javascript application/x-javascript text/xml application/xml application/xml+rss text/javascript;</pre>
<p>首先，我为最有利于单个页面应用程序的内容类型启用了gzip压缩。有关每个可用gzip设置的更多细节，请参阅<a href="http://nginx.org/en/docs/http/ngx_http_gzip_module.html" target="_blank" rel="noopener noreferrer"> nginx gzip模块</a>文档。</p>
<pre>location ~* (\.html|\/sw\.js)$ {
  expires -1y;
  add_header Pragma "no-cache";
  add_header Cache-Control "public";
}</pre>
<p>我想用<code>/sw.js</code>将所有HTML文件匹配在一起，这是一个服务工作者脚本。</p>
<p>都不应该被缓存。Nginx <code>expires</code>指令设置为负值，设置超过<code>Expires</code>头，并添加一个额外的<code>Cache-Control: no-cache</code>头。</p>
<pre>location ~* \.(js|css|png|jpg|jpeg|gif|ico|json)$ {
  expires 1y;
  add_header Cache-Control "public, immutable";
}</pre>
<p>我想最大限度地缓存我所有的静态资产，包括JavaScript文件、CSS文件、图像和静态JSON文件。如果您托管您的字体文件，您也可以添加它们。</p>
<pre>location / {
  try_files $uri $uri/ =404;
}


if ($host ~* ^www\.(.*)) {
  set $host_without_www $1;
  rewrite ^(.*) https://$host_without_www$1 permanent;
}</pre>
<p>这两项与缓存无关，但它们是Nginx配置的重要组成部分。</p>
<p>因为现代的单页面应用程序支持漂亮URL的路由，而我的静态服务器不知道它们。我需要为每个不匹配静态文件的路由提供一个默认的<code>index.html</code>。</p>
<p>我还对从带<code>www.</code>的URL到不带<code>www</code>的URL的重定向感兴趣。您可能不需要最后一个，因为您的应用程序已经由您的服务提供商为您托管了。</p>
<h3>快速配置</h3>
<p>有时我们无法使用Nginx这样的反向代理服务器来提供静态文件。</p>
<p>可能是因为您的无服务器设置/服务提供商限制您使用一种流行的编程语言，并且性能不是您主要关心的问题。</p>
<p>在这种情况下，您可能希望使用像Express这样的服务器来提供静态文件。</p>
<pre>import express, { Response } from "express";
import compression from "compression";
import path from "path";

const PORT = process.env.PORT || 3000;
const BUILD_PATH = "public";

const app = express();

function setNoCache(res: Response) {
  const date = new Date();
  date.setFullYear(date.getFullYear() - 1);
  res.setHeader("Expires", date.toUTCString());
  res.setHeader("Pragma", "no-cache");
  res.setHeader("Cache-Control", "public, no-cache");
}

function setLongTermCache(res: Response) {
  const date = new Date();
  date.setFullYear(date.getFullYear() + 1);
  res.setHeader("Expires", date.toUTCString());
  res.setHeader("Cache-Control", "public, max-age=31536000, immutable");
}

app.use(compression());
app.use(
  express.static(BUILD_PATH, {
    extensions: ["html"],
    setHeaders(res, path) {
      if (path.match(/(\.html|\/sw\.js)$/)) {
        setNoCache(res);
        return;
      }

      if (path.match(/\.(js|css|png|jpg|jpeg|gif|ico|json)$/)) {
        setLongTermCache(res);
      }
    },
  }),
);

app.get("*", (req, res) =&gt; {
  setNoCache(res);
  res.sendFile(path.resolve(BUILD_PATH, "index.html"));
});

app.listen(PORT, () =&gt; {
  console.log(`Server is running http://localhost:${PORT}`);
});</pre>
<p>这个脚本模仿了我们的Nginx配置正在做的事情。使用压缩中间件启用gzip。</p>
<p>Express静态中间件为你设置<code>ETag</code>和<code>Last-Modified</code>头。我们必须自己处理发送<code>index.html</code>的问题，以防请求不匹配任何已知的静态文件。</p>
<h3>例子</h3>
<p>最后，我想探索流行的服务是如何利用缓存头的。</p>
<p>我分别检查了HTML和CSS或JavaScript文件的头。我还查看了服务器头(如果有的话),因为它可能会让我们对底层基础设施有一个令人兴奋的了解。</p>
<h3>推特</h3>
<p>Twitter非常努力地不让他们的HTML文件出现在你的浏览器缓存中。看起来Twitter正在使用Express为我们提供React应用程序的一个<code>&lt;div id="react-root"&gt;</code>入口。</p>
<p>不管什么原因，Twitter使用了<code>Expiry</code>头，而<code>Expires</code>头不见了。</p>
<p>我已经查过了，但是我没有发现任何有趣的东西。</p>
<p>可能是打印错误吗？如果知道，请留言评论。</p>
<pre>cache-control: no-cache, no-store, must-revalidate, pre-check=0, post-check=0
expiry: Tue, 31 Mar 1981 05:00:00 GMT
last-modified: Wed, 08 Jan 2020 22:16:19 GMT (current date)
pragma: no-cache
server: tsa_o
x-powered-by: Express</pre>
<p>Twitter没有CSS文件，可能正在使用一些CSS-in-JS解决方案。看起来像是运行在Amazon ECS上的容器化应用程序在服务静态文件。</p>
<pre>etag: "fXSAIt9bnXh6KGXnV0ABwQ=="
expires: Thu, 07 Jan 2021 22:19:54 GMT
last-modified: Sat, 07 Dec 2019 22:27:21 GMT
server: ECS (via/F339)</pre>
<h3>照片墙</h3>
<p>Instagram也不希望你的浏览器缓存HTML，使用设置为2000年初的有效Expires头；任何早于当前日期的日期都是有效的。</p>
<pre>last-modified: Wed, 08 Jan 2020 21:45:45 GMT
cache-control: private, no-cache, no-store, must-revalidate
pragma: no-cache
expires: Sat, 01 Jan 2000 00:00:00 GMT</pre>
<p>Instagram提供的CSS和JavaScript文件都支持长期缓存，并且有一个ETag。</p>
<pre>etag: "3d0c27ff077a"
cache-control: public,max-age=31536000,immutable</pre>
<h3>纽约时报</h3>
<p>《纽约时报》也在使用React，并以服务器端渲染页面的形式提供文章。最后修改日期似乎是一个真实的日期，不会随着每个请求而改变。</p>
<pre>cache-control: no-cache
last-modified: Wed, 08 Jan 2020 21:54:09 GMT
server: nginx</pre>
<p>纽约时报的资产也会被缓存很长时间，同时提供Etag和Last-Modified date。</p>
<pre>cache-control: public,max-age=31536000
etag: "42db6c8821fec0e2b3837b2ea2ece8fe"
expires: Wed, 24 Jun 2020 23:27:22 GMT
last-modified: Tue, 25 Jun 2019 22:51:52 GMT
server: UploadServer</pre>
<h3>结论</h3>
<p>我创建这个部分是为了组织我的知识，但我也打算用它作为配置当前和未来项目的备忘单。我希望你喜欢阅读，也发现它很有用！</p>
<p>如果你有任何问题或想提出改进建议，请在下面留下评论，我很乐意回答！</p><div class="code-block code-block-2">
<div class="blog-plug base-cta"><h2>使用<a class="signup" href="https://lp.logrocket.com/blg/signup" target="_blank" rel="noopener noreferrer"> LogRocket </a>消除传统错误报告的干扰</h2>
<a href="https://lp.logrocket.com/blg/signup" class="signup" target="_blank" rel="noopener noreferrer"><img class="alignnone size-full wp-image-46 jetpack-lazy-image" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/><noscript><img data-lazy-fallback="1" class="alignnone size-full wp-image-46" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/></noscript></a>
<p><a href="https://lp.logrocket.com/blg/signup" target="_blank" rel="noopener noreferrer"> LogRocket </a>是一个数字体验分析解决方案，它可以保护您免受数百个假阳性错误警报的影响，只针对几个真正重要的项目。LogRocket会告诉您应用程序中实际影响用户的最具影响力的bug和UX问题。</p>
<p>然后，使用具有深层技术遥测的会话重放来确切地查看用户看到了什么以及是什么导致了问题，就像你在他们身后看一样。</p>
<p>LogRocket自动聚合客户端错误、JS异常、前端性能指标和用户交互。然后LogRocket使用机器学习来告诉你哪些问题正在影响大多数用户，并提供你需要修复它的上下文。</p>
<p>关注重要的bug—<a class="signup" href="https://lp.logrocket.com/blg/signup-issue-free" target="_blank" rel="noopener noreferrer">今天就试试LogRocket】。</a></p></div></div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
<html>
<head>
<title>What is Deno, and how is it different from Node.js? - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>Deno是什么，和Node.js有什么不同？- LogRocket博客</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/what-is-deno/#0001-01-01">https://blog.logrocket.com/what-is-deno/#0001-01-01</a></blockquote><div><article class="article-post">
<p><em> <strong>编者按</strong>:本指南最后一次更新是在2021年3月，以反映最新Deno版本<a href="https://deno.land/posts/v1.7" target="_blank" rel="noopener"> Deno v1.7.0 </a>中引入的变化，并包括更新的Deno与Node.js性能比较。</em></p>
<p>Ryan Dahl，<a href="https://blog.logrocket.com/use-cases-for-node-workers/" target="_blank" rel="noopener noreferrer"> Node.js </a>的创作者，于2018年5月正式发布了<a href="https://deno.land/" target="_blank" rel="noopener"> Deno </a>。这个新的JavaScript运行时旨在修复Node.js中的一长串固有问题。</p>
<p>不要误解我的意思:Node本身就是一个很棒的服务器端JavaScript运行时，这主要归功于它庞大的生态系统和JavaScript的使用。然而，Dahl在2018 JSConf EU 上承认，有几件事他应该考虑得更多——安全性、模块和依赖性，等等。</p>
<p><iframe loading="lazy" src="https://www.youtube.com/embed/M3BM9TB-8yA" frameborder="0" allowfullscreen="allowfullscreen">视频</iframe></p>
<p>在他的辩护中，他无法想象这个平台会在如此短的时间内增长多少。此外，早在2009年，JavaScript还是这种人人取笑的奇怪的小语言，它的许多功能还没有出现。</p>
<h2>什么是德诺？</h2>
<p><a href="https://github.com/denoland/deno" target="_blank" rel="noopener"> Deno </a>是一个安全的<a href="https://blog.logrocket.com/writing-idiomatic-typescript/" target="_blank" rel="noopener noreferrer"> TypeScript </a>运行时，构建于V8之上，V8是用于JavaScript的Google运行时引擎。</p>
<p>Deno由以下材料制成:</p>
<ul>
<li>Rust (Deno的内核用Rust编写，Node的用C++)</li>
<li>Tokio(用Rust编写的事件循环)</li>
<li>TypeScript (Deno支持JavaScript和现成的TypeScript)</li>
<li>V8(谷歌在Chrome和Node等平台上使用的JavaScript运行时)</li>
</ul>
<p><span class="embed-youtube"> <iframe loading="lazy" class="youtube-player" src="https://www.youtube.com/embed/AoAXcW2-LNA?version=3&amp;rel=1&amp;showsearch=0&amp;showinfo=1&amp;iv_load_policy=1&amp;fs=1&amp;hl=en-US&amp;autohide=2&amp;wmode=transparent" allowfullscreen="true" sandbox="allow-scripts allow-same-origin allow-popups allow-presentation">视频</iframe> </span></p>
<h2>为什么用Deno？</h2>
<p>Deno的特性旨在改进Node.js的功能。让我们仔细看看使Deno成为Node的一个有吸引力的替代方案的一些主要特性。</p>
<h3>Deno中的安全性(权限)</h3>
<p>Deno最重要的特性之一是它对安全性的关注。</p>
<p>与Node.js相反，Deno默认情况下在沙箱中执行代码，这意味着运行时无权访问:</p>
<ul>
<li>文件系统</li>
<li>网络</li>
<li>其他脚本的执行</li>
<li>环境变量</li>
</ul>
<p>让我们来看看许可系统是如何工作的。</p>
<pre>(async () =&gt; {
 const encoder = new TextEncoder();
 const data = encoder.encode('Hello world\n');

 await Deno.writeFile('hello.txt', data);
 await Deno.writeFile('hello2.txt', data);
})();</pre>
<p>该脚本创建了两个名为<code>hello.txt</code>和<code>hello2.txt</code>的文本文件，其中包含一条<code>Hello world</code>消息。代码是在沙箱中执行的，所以它不能访问文件系统。</p>
<p>还要注意，我们使用的是Deno名称空间，而不是fs模块，就像在Node.js中一样。通过使用名称空间，我们失去了浏览器兼容性，这将在后面讨论。</p>
<p>当我们通过执行以下命令来运行它时:</p>
<pre>deno run write-hello.ts</pre>
<p>系统会提示我们以下信息:</p>
<pre>⚠️Deno requests write access to "/Users/user/folder/hello.txt". Grant? [a/y/n/d (a = allow always, y = allow once, n = deny once, d = deny always)]</pre>
<p>我们实际上被提示了两次，因为来自沙箱的每个调用都必须请求许可。当然，如果我们选择了<code>allow always</code>选项，我们只会被询问一次。</p>
<p>如果我们选择<code>deny</code>选项，将会抛出<code>PermissionDenied</code>错误，并且由于我们没有任何错误处理逻辑，流程将会终止。</p>
<p>如果我们使用以下命令执行脚本:</p>
<pre>deno run --allow-write write-hello.ts</pre>
<p>没有提示，两个文件都被创建。</p>
<p>除了文件系统的<code>--allow-write</code>标志之外，还有<code>--allow-net</code>、<code>--allow-env</code>和<code>--allow-run</code>标志，分别用于启用网络请求、访问环境和运行子进程。</p>
<h3>Deno模块</h3>
<p>Deno就像浏览器一样，通过URL加载模块。当许多人在服务器端看到带有URL的import语句时，他们一开始会感到困惑，但是它实际上是有意义的——请耐心听我说:</p>
<pre>import { assertEquals } from "https://deno.land/std/testing/asserts.ts";</pre>
<p>你可能会问，通过URL导入包有什么大不了的？答案很简单:通过使用URL，Deno包可以在没有像<code>npm</code>这样的集中注册中心的情况下分发，最近这个注册中心出现了很多问题，所有问题都在这里<a href="https://www.youtube.com/watch?v=MO8hZlgK5zc">解释</a>。</p>
<p>通过URL导入代码，我们使得包创建者可以在他们认为合适的地方托管他们的代码——这是去中心化的最好体现。不再有<code>package.json</code>和<code>node_modules</code>。</p>
<p>当我们启动应用程序时，Deno下载所有导入的模块并缓存它们。一旦它们被缓存，Deno将不会再次下载它们，直到我们用<code>--reload</code>标志明确要求它。</p>
<p>这里有几个重要的问题要问:</p>
<h4>如果一个网站瘫痪了怎么办？</h4>
<p>由于它不是一个集中的注册中心，托管该模块的网站可能会因为许多原因而关闭。依赖于它在开发期间——或者更糟，在生产期间——是有风险的。</p>
<p>正如我们之前提到的，Deno缓存下载的模块。由于缓存存储在我们的本地磁盘上，Deno的创建者建议在我们的版本控制系统(即g it)中检查它，并将其保存在存储库中。这样，即使当网站关闭时，所有的开发者仍然可以访问下载的版本。</p>
<p>Deno将缓存存储在环境变量<code>$DENO_DIR</code>下指定的目录中。如果我们不自己设置变量，它将被设置为系统默认的缓存目录。我们可以在本地存储库中的某个地方设置<code>$DENO_DIR</code>,并将其签入版本控制系统。</p>
<h4>我必须一直通过网址导入吗？</h4>
<p>不断地输入URL会非常乏味。谢天谢地，Deno为我们提供了两个选择来避免这样做。</p>
<p>第一个选项是从本地文件重新导出导入的模块，如下所示:</p>
<pre>export { test, assertEquals } from "https://deno.land/std/testing/mod.ts";</pre>
<p>假设上面的文件叫做<code>local-test-utils.ts</code>。现在，如果我们想再次使用<code>test</code>或<code>assertEquals</code>函数，我们可以像这样引用它:</p>
<pre>import { test, assertEquals } from './local-test-utils.ts';</pre>
<p>所以它是否从URL加载并不重要。</p>
<p>第二个选项是创建一个导入映射，我们在一个JSON文件中指定它:</p>
<pre>{
   "imports": {
      "http/": "https://deno.land/std/http/"
   }
}</pre>
<p>然后像这样导入它:</p>
<pre>import { serve } from "http/server.ts";</pre>
<p>为了让它工作，我们必须通过包含<code>--importmap</code>标志来告诉Deno关于导入映射的信息:</p>
<pre>deno run --importmap=import_map.json hello_server.ts</pre>
<h4>Deno中的包版本控制</h4>
<p>版本控制必须得到包提供者的支持，但是从客户端来看，它只是在URL中设置版本号，如下所示:</p>
<pre>https://unpkg.com/<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="e38f8a8f97869097a3d3cdd3cdd6">[email protected]</a>/dist/liltest.js</pre>
<h3>Deno浏览器兼容性</h3>
<p>Deno的目标是兼容浏览器。从技术上讲，当使用ES模块时，我们不必使用任何像webpack这样的构建工具来使我们的应用程序准备好在浏览器中使用。</p><div class="code-block code-block-54">
<hr/>
<h3>更多来自LogRocket的精彩文章:</h3>

<hr/></div>
<p>然而，像Babel这样的工具会将代码转换到JavaScript的ES5版本，因此，代码甚至可以在不支持该语言所有最新特性的旧浏览器中运行。但这也是以在最终文件中包含大量不必要的代码和输出文件膨胀为代价的。</p>
<p>由我们来决定我们的主要目标是什么，并做出相应的选择。</p>
<h3>Deno支持现成的类型脚本</h3>
<p>Deno使得使用TypeScript变得容易，不需要任何配置文件。尽管如此，用普通的JavaScript编写程序并毫无困难地用Deno执行它们是可能的。</p>
<h2>Deno生产就绪了吗？</h2>
<p>一段时间以来，Deno一直在稳步增长。Deno v1.0 于5月13日大张旗鼓地正式发布，此后一直稳步增长。</p>
<p>撰写本文时最新的稳定版本是2021年1月19日发布的<a href="https://github.com/denoland/deno/releases" target="_blank" rel="noopener"> Deno v1.7.0 </a>。Deno的最新版本具有改进的编译和数据URL功能。新版本的亮点包括使用<code>deno compile</code>从稳定的、受支持的架构(包括Windows x64、MacOS x64和Linux x64)中交叉编译的能力。此外，<code>deno compile</code>现在生成的二进制文件比Deno v. 1.6生成的要小40–60%，并且二进制文件具有内置的CA证书、自定义V8标志、锁定权限等等。</p>
<p>Deno v.1.7中其他值得注意的特性包括支持数据URL，支持用<code>deno fmt</code>格式化Markdown文件，以及用<code>--location</code>标志为脚本设置文档位置。了解更多关于<a href="https://www.infoworld.com/article/3604740/deno-17-brings-compilation-improvements.html" target="_blank" rel="noopener">Deno</a>的最新更新。</p>
<p>通过这种去中心化的方法，Deno采取了必要的步骤，将JavaScript生态系统从集中的包注册中心(npm)中解放出来。</p>
<h2 id="performance">Deno与Node.js:性能</h2>
<p>由于Deno相对年轻，因此很难比较Node.js和Deno的性能。大多数可用的基准测试都非常简单，比如将消息记录到控制台，因此我们不能仅仅假设性能会随着应用程序的增长而保持不变。</p>
<p>我们可以肯定的一点是，Node.js和Deno都使用相同的JavaScript引擎，谷歌的V8，所以在运行JavaScript本身时，性能不会有任何差异。</p>
<p>唯一可能影响性能的区别是Deno是基于Rust构建的，而Node.js是基于C++构建的。Deno的团队为每个版本发布了一组基准测试,展示Deno的性能，在许多情况下与Node进行比较。截至2021年3月，似乎Node.js在HTTP吞吐量方面表现更好，而Deno在更低的延迟方面表现更好。总的来说，表现很像。</p>
<p>关于Deno的一级类型脚本支持的一个常见误解是，由于类型检查，它会以某种方式影响运行时性能。我找不到这种误解的来源，但是，任何了解TypeScript如何工作的人都会告诉你，TypeScript只在翻译过程中检查类型。因此，它不可能对任何类型的运行时性能产生负面影响。一旦我们使用了<a href="https://deno.land/manual/tools/bundler" target="_blank" rel="noopener"> bundle命令</a>，输出就是一个JavaScript文件。</p>
<p>总而言之，这两个运行时都非常快，并利用大量优化来提供最佳性能。我不认为Deno或Node.js能够明显胜过对方。</p>
<h2 id="shouldyouuse">应该用Deno而不是Node.js吗？</h2>
<p>Deno的目标不是做节点替代者，而是替代者。我要说的是，大多数开发人员对Node.js的发展方式感到满意，并没有真的想改变现状。</p>
<p>Deno对安全性的关注以及将整个代码库捆绑到单个文件中的可能性为Deno提供了一个很好的机会，使其成为JavaScript开发人员在创建实用程序脚本时的首选工具，否则这些脚本可能是用Bash或Python等语言编写的。</p>
<p>如果你想决定选择哪一个，我会选择Node。它是成熟和稳定的，因此不会有任何可能对应用程序的开发产生负面影响的意外行为。</p><div class="code-block code-block-23">
<div class="blog-plug inline-plug node-plug"><h2>200只<img src="../Images/61167b9d027ca73ed5aaf59a9ec31267.png" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2019/10/green-check.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" class=" jetpack-lazy-image" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/10/green-check.png"/> <noscript> <img data-lazy-fallback="1" src="../Images/61167b9d027ca73ed5aaf59a9ec31267.png" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/10/green-check.png"/> </noscript>显示器出现故障，生产中网络请求缓慢</h2><p>部署基于节点的web应用程序或网站是容易的部分。确保您的节点实例继续为您的应用程序提供资源是事情变得更加困难的地方。如果您对确保对后端或第三方服务的请求成功感兴趣，</p><a href="https://lp.logrocket.com/blg/node-signup" target="_blank">try LogRocket</a><p>. </p><a class="signup" href="https://lp.logrocket.com/blg/node-signup" target="_blank" rel="noopener noreferrer"><img src="../Images/cae72fd2a54c5f02a6398c4867894844.png" alt="LogRocket Network Request Monitoring" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2019/12/network-request-filter-2-1.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" class=" jetpack-lazy-image" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/12/network-request-filter-2-1.png"/><noscript><img data-lazy-fallback="1" src="../Images/cae72fd2a54c5f02a6398c4867894844.png" alt="LogRocket Network Request Monitoring" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/12/network-request-filter-2-1.png"/></noscript></a><a href="https://lp.logrocket.com/blg/node-signup" target="_blank" rel="noopener noreferrer">https://logrocket.com/signup/</a><p>LogRocket 就像是网络和移动应用程序的DVR，记录下用户与你的应用程序交互时发生的一切。您可以汇总并报告有问题的网络请求，以快速了解根本原因，而不是猜测问题发生的原因。</p><p>LogRocket检测您的应用程序以记录基线性能计时，如页面加载时间、到达第一个字节的时间、慢速网络请求，还记录Redux、NgRx和Vuex操作/状态。</p><a class="signup" href="https://lp.logrocket.com/blg/node-signup" target="_blank" rel="noopener noreferrer">Start monitoring for free</a><p>. </p></div>
</div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
<html>
<head>
<title>Build a server-rendered React app with Next.js and Express - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>用Next.js和Express - LogRocket Blog构建一个服务器渲染的React应用程序</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/build-server-rendered-react-app-next-express/#0001-01-01">https://blog.logrocket.com/build-server-rendered-react-app-next-express/#0001-01-01</a></blockquote><div><article class="article-post">
<p><em> <strong>编者按:</strong>这篇文章于2022年10月4日更新，其中包括为什么要使用Express with Next、Express是否优于Next.js的自定义服务器、使用Express和Next的优势、服务器端渲染的示例以及文本的其他一般更新。</em></p>
<p>不言而喻，React是构建高质量web应用程序的绝佳选择。然而，随着项目变得越来越复杂，您需要了解客户端路由、页面布局等等，以扩展您的应用程序。例如，在某些时候，您会希望页面加载得更快。通常，这是事情变得困难的地方。</p>
<p><a href="https://learnnextjs.com/" target="_blank" rel="noopener"> Next.js </a>是一个通用的JavaScript框架，可以在浏览器和服务器上运行。它为开发人员提供了一种简单的入门方式，并且，因为它使用React作为模板，所以对于拥有React经验的开发人员来说，这也是一种快速高效的<a href="https://blog.logrocket.com/creating-website-next-js-react/" target="_blank" rel="noopener">方式。</a></p>
<p>它的一个优点是很好地处理了服务器端渲染，并且很好地集成了<a href="https://expressjs.com/" target="_blank" rel="noopener"> Express </a>。哦，我多么喜欢快递。</p>
<p>但是我们太超前了。先说说为什么需要服务器端渲染吧。然后我们开始建造东西。</p>

<h2 id="what-next-js">Next.js是什么？</h2>
<p>Next.js是构建在Node.js之上的开源开发框架，支持基于React的web应用功能，如服务器端渲染，并允许生成静态网站。它最初于2016年10月25日发布，但很快成为开发人员寻求构建高质量web应用程序时的首选JavaScript框架之一。</p>
<p>Next.js为您提供了最佳的开发人员体验，包括生产所需的所有功能，如混合静态和服务器渲染、类型脚本支持、智能绑定、路由预取、快速刷新和内置CSS支持，完全不需要特殊配置。</p>
<p>它的一个优点是可以很好地处理服务器端渲染，并且可以很好地与Express集成。为了充分利用Next，我们需要了解什么是服务器端呈现，它是如何工作的，然后开始构建我们的示例服务器端呈现React和Express web应用程序。</p>
<h2 id="what-server-side-rendering-exactly">确切地说，什么是服务器端渲染？</h2>
<p>服务器端呈现是将HTML显示在屏幕上的传统方法。这指的是使用服务器环境让你的HTML到达浏览器。如果这是一种由来已久的传统方法，又何必大惊小怪呢？</p>
<p>还记得引起一些关注的<a href="https://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93controller" target="_blank" rel="noopener"> MVC </a>(模型、视图、控制器)概念的引入吗？基本上，有些分歧最终导致了用于呈现视图的JavaScript框架的兴起。</p>
<p>那么这有什么关系呢？很快，一个问题出现了:现代JavaScript框架只在浏览器中显示一堆div，使用DOM操纵在浏览器中完成工作。这意味着用户必须等待更长时间才能看到任何东西。如果爬虫不能快速看到页面的内容，也会影响SEO。</p>
<p>一种解决方案是在将输出返回给服务器之前，从服务器呈现JavaScript文件。</p>
<h3 id="example-server-side-rendering">服务器端渲染示例</h3>
<p>当使用服务器端呈现时，页面的HTML直接从服务器呈现。在客户端，HTML用于显示快速的非交互式页面，而JavaScript用于使页面具有交互性。为了利用服务器端渲染，我们将使用<code>getServerSideProps</code>。</p>
<p><code>getServerSideProps</code>只在服务器端运行，不会在浏览器中运行。如果您需要呈现页面，并且还需要在请求时获取数据，那么应该使用它。</p>
<pre class="language-javascript hljs">export async function getServerSideProps(context) {
  return {
    props: {}, // will be passed to the page component as props
  }
}
</pre>
<p>当您从一个页面中导出一个名为<code>getServerSideProps</code>的函数时，Next.js将在每次请求时使用由<code>getServerSideProps</code>返回的数据预呈现这个页面。</p>
<h2 id="getting-started-next-js">Next.js入门</h2>
<p>开始使用Next很简单。因为它构建在Node之上，所以继续安装Node v10.13或更高版本。在本教程中，您还将使用文本编辑器和终端应用程序。</p>
<p>有两种方法可以创建我们的应用程序。</p>
<h3 id="option-1">选项1:</h3>
<p>第一种方法是我在本教程中推荐的，因为它是现成的。</p>
<pre class="language-bash hljs">npx create-next-app logrocket-nextjs --use-npm --example
# https://github.com/vercel/next-learn/tree/master/basics/learn-starter
</pre>
<p>上面的命令使用了名为<code>create-next-app</code>的工具，它会为您启动一个Next.js应用程序。它使用通过<code>--example</code>标志指定的默认学习模板。完成后，运行开发服务器:</p>
<pre class="language-bash hljs"># change to the project directory
cd logrocket-nextjs
# start the development server
npm run dev
</pre>
<p>完成后，导航到<a href="http://localhost:3000" rel="nofollow"> http://localhost:3000 </a>，在这里您应该会看到示例web应用程序正在运行:</p>
<p><img data-attachment-id="137926" data-permalink="https://blog.logrocket.com/build-server-rendered-react-app-next-express/attachment/welcome-next/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2018/04/welcome-next.png" data-orig-size="730,411" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Welcome next" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2018/04/welcome-next-300x169.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2018/04/welcome-next.png" decoding="async" class="aligncenter size-full wp-image-137926 jetpack-lazy-image" src="../Images/94835ae1e02fe17838df3bf28b364237.png" alt="Welcome To Next.js Screen" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2018/04/welcome-next.png 730w, https://blog.logrocket.com/wp-content/uploads/2018/04/welcome-next-300x169.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2018/04/welcome-next.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2018/04/welcome-next.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="137926" data-permalink="https://blog.logrocket.com/build-server-rendered-react-app-next-express/attachment/welcome-next/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2018/04/welcome-next.png" data-orig-size="730,411" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Welcome next" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2018/04/welcome-next-300x169.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2018/04/welcome-next.png" decoding="async" loading="lazy" class="aligncenter size-full wp-image-137926" src="../Images/94835ae1e02fe17838df3bf28b364237.png" alt="Welcome To Next.js Screen" srcset="https://blog.logrocket.com/wp-content/uploads/2018/04/welcome-next.png 730w, https://blog.logrocket.com/wp-content/uploads/2018/04/welcome-next-300x169.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2018/04/welcome-next.png"/></noscript>
<h3 id="option-2">选项2:</h3>
<p>首先，使用下面的代码开始:</p>
<pre class="language-bash hljs"># make a directory
mkdir logrocket-nextjs
# change to the new directory
cd logrocket-nextjs
# init a new node project
npm init -y 
# install react, react-dom and next
npm install --save react react-dom next
</pre>
<p>接下来，打开您的<code>package.json</code>,将您的脚本部分替换为:</p>
<pre class="language-json hljs">"scripts": {
        "dev": "next",
        "build": "next build",
        "start": "next start"
    }
</pre>
<p>运行<code>npm run dev</code>命令，您应该会得到如下错误:</p>
<pre class="language-bash hljs">next &gt; Couldn't find a `pages` directory. Please create one under the project root
</pre>
<p>这是因为<code>Next</code>使用<code>pages</code>目录和其中的文件来映射它的路径。这意味着如果我们的pages文件夹中有一个名为<code>index.js</code>的文件，Next将尝试使用其中的组件作为我们的入口点。让我们创建pages文件夹和<code>index.js</code>文件:</p>
<pre class="language-bash hljs">#create pages directory
mkdir pages
#create file for base route
touch pages/index.js
</pre>
<p>接下来，让我们向<code>pages/index.js</code>文件添加一些代码:</p>
<pre class="language-javascript hljs">const Index = () =&gt; (



Hello Next.js, this is your friend Brian from logrocket



)
export default Index
</pre>
<p>保存上面的文件，并在您的终端中运行命令<code>npm run dev</code>。如果你打开你的浏览器，你会看到“Hello Next.js，这是你在LogRocket的朋友Samuel”的文本打印出来。</p>
<p><img data-attachment-id="137928" data-permalink="https://blog.logrocket.com/build-server-rendered-react-app-next-express/attachment/friend-logrocket/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2018/04/friend-logrocket.png" data-orig-size="730,126" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Friend logrocket" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2018/04/friend-logrocket-300x52.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2018/04/friend-logrocket.png" decoding="async" class="aligncenter size-full wp-image-137928 jetpack-lazy-image" src="../Images/413dee9ac6a09322c40fce2dcead8593.png" alt="Your Friend From LogRocket Screen" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2018/04/friend-logrocket.png 730w, https://blog.logrocket.com/wp-content/uploads/2018/04/friend-logrocket-300x52.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2018/04/friend-logrocket.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2018/04/friend-logrocket.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="137928" data-permalink="https://blog.logrocket.com/build-server-rendered-react-app-next-express/attachment/friend-logrocket/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2018/04/friend-logrocket.png" data-orig-size="730,126" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Friend logrocket" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2018/04/friend-logrocket-300x52.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2018/04/friend-logrocket.png" decoding="async" loading="lazy" class="aligncenter size-full wp-image-137928" src="../Images/413dee9ac6a09322c40fce2dcead8593.png" alt="Your Friend From LogRocket Screen" srcset="https://blog.logrocket.com/wp-content/uploads/2018/04/friend-logrocket.png 730w, https://blog.logrocket.com/wp-content/uploads/2018/04/friend-logrocket-300x52.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2018/04/friend-logrocket.png"/></noscript>
<p>注意到这有多简单了吗？不需要挂载React到一个<code>div</code>，不需要导入React，不需要设置路由。在我们通常的React应用程序中，我们需要进行其他配置，以允许代码分割和服务器端呈现。但是，嘿，看看你的页面来源。你会惊讶的。都是开箱即用的。</p>
<h2 id="why-express-next-js">为什么要在Next.js中使用Express？</h2>
<p>Next.js本身就是一个强大的工具。当与Express结合时，它构成了一个神圣的组合。使用Express和Next.js，您可以:</p>
<ul>
<li>在您的应用程序中轻松构建web套接字功能</li>
<li>为您的Next.js路线开发自定义或额外的逻辑</li>
<li>构建Express中间件，并在呈现Next.js页面之前获取数据</li>
<li>轻松构建后端功能，如文件上传、媒体文件压缩等</li>
</ul>
<h2 id="express-better-custom-server-next-js">Express比Next.js的自定义服务器好吗？</h2>
<p>根据Next.js的官方文档，定制的Next.js服务器允许您完全以编程方式启动服务器，以便使用定制的服务器模式。</p>
<p>使用定制服务器将会失去某些特性，例如性能优化、自动静态优化、无服务器功能等，但是如果您有定制需求和定制基础设施，那么为Next.js拥有自己的定制服务器将是一个很好的选择。</p><div class="code-block code-block-54">
<hr/>
<h3>更多来自LogRocket的精彩文章:</h3>

<hr/></div>
<p>使用Express作为您的服务器只允许您做更多的后端任务。</p>
<h2 id="advantages-using-express-next-js">在Next.js中使用Express的优势</h2>
<p>Next.js的伟大之处在于它有很多优势，不仅对开发人员，而且对在技术栈中使用Next.js的用户和企业所有者都是如此。</p>
<p>对于开发者来说，Next.js有:</p>
<ul>
<li>一个由经验丰富的开发人员和贡献者组成的不断增长的社区，因此很容易被其他开发人员采用，并且很容易找到您在学习和使用Next.js时可能遇到的任何问题的解决方案</li>
<li>一种自动功能，可帮助您优化图像，并具有自动延迟加载、预加载关键图像、跨设备正确调整大小以及支持现代格式的功能。</li>
<li>开发过程中更快的浏览器刷新速度</li>
<li>对TypeScript的现成支持</li>
<li>自动编译和捆绑，这样您就不会浪费时间进行大量配置来运行您的应用程序</li>
<li>在应用程序开发过程中轻松创建API路由或端点</li>
<li>以多种方式呈现内容。您可以使用服务器端呈现或静态站点生成进行预呈现，也可以使用增量静态重新生成在运行时更新或创建您的应用程序内容</li>
</ul>
<p>在Next.js中使用Express的其他一些优点还包括:</p>
<ul>
<li>数据安全性:使用Next.js创建的网站是静态的，与您的应用程序数据库、用户信息、第三方集成密钥和任何其他敏感信息没有直接联系</li>
<li>搜索引擎友好性:因为Next.js网站加载速度快，容易被搜索引擎机器人扫描，这提高了网站的有机流量，可以转化为网站所有者的转化和销售</li>
<li>交叉部署:您可以使用Next.js跨多个平台进行构建。您可以使用Next.js构建静态web应用程序、渐进式Web应用程序(PWA ),甚至移动应用程序</li>
</ul>
<h2 id="using-next-express">使用Next和Express</h2>
<p>我打赌你认为这就是Next.js的全部魅力。但是Next更进了一步，允许在更困难的情况下使用Express进行更好的服务器端渲染。</p>
<p>首先，将Express添加到您的应用程序中:</p>
<pre class="language-bash hljs">npm install --save express
</pre>
<p>然后在你的app里创建一个名为<code>ssr-server.js</code>的文件，添加以下内容:</p>
<pre class="language-javascript hljs">const express = require('express')
const next = require('next')

const dev = process.env.NODE_ENV !== 'production'
const app = next({ dev })
const handle = app.getRequestHandler()

app.prepare()
.then(() =&gt; {
  const server = express()

  server.get('*', (req, res) =&gt; {
    return handle(req, res)
  })

  server.listen(3000, (err) =&gt; {
    if (err) throw err
    console.log('&gt; Ready on http://localhost:3000')
  })
})
.catch((ex) =&gt; {
  console.error(ex.stack)
  process.exit(1)
})
</pre>
<p>在上面的代码块中，我们导入了Express和Next库，并创建了一个实例，根据环境传入一个布尔值来检测是在开发模式还是生产模式下启动Next.js。</p>
<p><code>app.getRequestHandler</code>返回一个请求处理程序，我们可以用它来解析所有的HTTP请求。prepare函数返回一个承诺，因此我们可以向它添加一个<code>.then</code>管道。在<code>.then</code>调用中，我们启动Express，并使用通配符路由来捕获所有路由，并将它们返回给处理函数。</p>
<p>现在更新您的npm开发脚本以运行服务器端呈现应用程序入口点:</p>
<pre class="language-json hljs">{ "scripts": { "dev": "node ssr-server.js" } }
</pre>
<p>如果你运行<code>npm run dev</code>，你的页面会旋转起来，看起来和原来一样，但是我们现在可以很容易地实现干净的应用程序路由，如下所示:</p>
<pre class="language-javascript hljs">server.get('/p/:id', (req, res) =&gt; {
    const actualPage = '/post'
    const queryParams = { id: req.params.id } 
    app.render(req, res, actualPage, queryParams)
})
</pre>
<p>在上面的代码中，我们使用流行的express routing来定义这样的路线，然后我们将应该加载的页面和<code>id</code>作为查询参数传递给主Next应用程序。在这里，调用<code>/p?id=2</code>发生在引擎盖下，没有人能看到发生了什么。</p>
<p>普通用户看到的URL是<code>/p/2/</code>。</p>
<h2 id="serving-exporting-app">服务和导出应用程序</h2>
<p>现在我们已经开发了我们的应用程序，我们需要将它部署到生产环境中。首先，我们必须构建应用程序。然后，我们可以使用下面的命令提供服务:</p>
<pre class="language-bash hljs">#build the app
npm run build
#serve the application in a production environment
npm run serve
</pre>
<p>哇，太酷了。如果要将应用程序导出为静态HTML文件，该怎么办？问得好。</p>
<p>首先，在您的应用程序的根目录中创建一个名为<code>next.config.js</code>的文件，并添加以下内容:</p>
<pre class="language-javascript hljs">module.exports = {
  exportPathMap: function () {
    return {
      '/': { page: '/' }
    }
  }
}
</pre>
<blockquote><p><strong>注意:</strong>在上面的设置中，只有索引页面会被导出，因为这是我们在<code>PathMap</code>中指定的唯一路径。</p></blockquote>
<p>如果需要，添加更多页面也很容易。你可以像<code>'/about': { page: '/about' }</code>一样在<code>PathMap</code>的返回对象中添加一个新的键和值。</p>
<p>接下来，将以下内容添加到您的<code>package.json</code>的脚本部分:</p>
<pre class="language-json hljs">"export": "next export"
</pre>
<p>最后，构建并导出您的应用程序。</p>
<pre class="language-javascript hljs">#build app
npm run build
#export app
npm run export
</pre>
<h2 id="conclusion">结论</h2>
<p>Next.js为我们提供了大量易于使用和配置的特性，比如干净的路由、更快的加载时间、改进的SEO等等。可以从官方文档中了解更多关于<a href="https://nextjs.org/" target="_blank" rel="noopener"> Next.js的内容。</a></p>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
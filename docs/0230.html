<html>
<head>
<title>Demonstration on how to use GraphQL with Node and Vue in bits - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>在bits - LogRocket博客中演示如何将GraphQL与Node和Vue结合使用</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/demonstration-on-how-to-use-graphql-with-node-and-vue-in-bits-8981f0d65f94/#0001-01-01">https://blog.logrocket.com/demonstration-on-how-to-use-graphql-with-node-and-vue-in-bits-8981f0d65f94/#0001-01-01</a></blockquote><div><article class="article-post">
<figure class="graf graf--figure"><img decoding="async" class="graf-image jetpack-lazy-image" src="../Images/52fde5ec2b39ee9081fe507956bf239f.png" data-image-id="1*uUXiDk5CNIwCgql8dh3pqQ.jpeg" data-width="1600" data-height="983" data-is-featured="true" data-lazy-src="https://storage.googleapis.com/blog-images-backup/1*uUXiDk5CNIwCgql8dh3pqQ.jpeg?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://storage.googleapis.com/blog-images-backup/1*uUXiDk5CNIwCgql8dh3pqQ.jpeg"/><noscript><img data-lazy-fallback="1" decoding="async" class="graf-image" src="../Images/52fde5ec2b39ee9081fe507956bf239f.png" data-image-id="1*uUXiDk5CNIwCgql8dh3pqQ.jpeg" data-width="1600" data-height="983" data-is-featured="true" data-original-src="https://storage.googleapis.com/blog-images-backup/1*uUXiDk5CNIwCgql8dh3pqQ.jpeg"/></noscript></figure>
<p class="graf graf--p">当我在网上冲浪时，我看到了这条微博。前端开发人员似乎厌倦了时不时地请求API。😄</p>

<p/>
<p class="graf graf--p">第一次和GraphQL互动，就爱上了它。为什么？GraphQL为您提供了轻松构建API的空间，让您不必重复做同样的事情。怎么会？让我们找出答案。</p>
<p class="graf graf--p">我假设您对以下内容有基本的了解:</p>
<ul class="postList">
<li class="graf graf--li">JavaScript(JavaScript)</li>
<li class="graf graf--li">Node.js(节点. js)</li>
<li class="graf graf--li">view . js-检视. js</li>
</ul>
<p class="graf graf--p">我们来看看<code>GraphQL</code>和<code>REST</code>的对比。</p>
<p class="graf graf--p">为了全面了解本文，我希望你克隆这个项目的<a class="markup--anchor markup--p-anchor" href="https://github.com/meshboy/recipe" target="_blank" rel="noopener noreferrer" data-href="https://github.com/meshboy/recipe">库</a>，它包含了<code>server</code>端和<code>client</code>端。</p>
<p class="graf graf--p">在本文中，我们将关注以下几点</p>
<ul class="postList">
<li class="graf graf--li">为什么是GraphQL</li>
<li class="graf graf--li">GraphQL的关键组件</li>
<li class="graf graf--li">证明</li>
<li class="graf graf--li">文件上传</li>
<li class="graf graf--li">带Vue的GraphQL</li>
</ul>
<figure class="graf graf--figure graf--layoutOutsetCenter"><a class="graf-imageAnchor" href="https://logrocket.com/signup/" target="_blank" rel="noopener noreferrer" data-href="https://logrocket.com/signup/" data-action="image-link" data-action-observe-only="true"><img decoding="async" class="graf-image jetpack-lazy-image" src="../Images/94b3e0f84b30cb0d321f60471481ab64.png" data-image-id="1*GPjaPKNNUYHU8EsA3Z0JGA.png" data-width="3212" data-height="750" data-lazy-src="https://storage.googleapis.com/blog-images-backup/1*GPjaPKNNUYHU8EsA3Z0JGA.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://storage.googleapis.com/blog-images-backup/1*GPjaPKNNUYHU8EsA3Z0JGA.png"/><noscript><img data-lazy-fallback="1" decoding="async" class="graf-image" src="../Images/94b3e0f84b30cb0d321f60471481ab64.png" data-image-id="1*GPjaPKNNUYHU8EsA3Z0JGA.png" data-width="3212" data-height="750" data-original-src="https://storage.googleapis.com/blog-images-backup/1*GPjaPKNNUYHU8EsA3Z0JGA.png"/></noscript></a></figure>
<h4 class="graf graf--h4">GraphQL是什么？</h4>
<p class="graf graf--p">GraphQL是一种查询语言，它有助于将API的<code>door</code>的密钥交给访问者(<code>client</code>)，当然是在你允许的情况下。嗯，如果管理不当，你的访客可能会把事情搞砸。</p>
<p class="graf graf--p">无论如何，您的应用程序都必须与其他应用程序进行交互。这只能通过公开部分或全部API来实现。实现这一点的方法之一是使用REST构建您的应用程序。到本文结束时，我们都会明白为什么应该在下一个应用程序中使用GraphQL。</p>
<blockquote class="graf graf--blockquote"><p>GraphQL是一种API查询语言，也是一种用现有数据完成这些查询的运行时语言。GraphQL为API中的数据提供了完整且易于理解的描述，使客户能够准确地要求他们需要的东西，使API更容易随时间发展，并支持强大的开发工具。</p></blockquote>
<p class="graf graf--p"><em class="markup--em markup--p-em"> REST Vs GraphQL </em></p>
<ul class="postList">
<li class="graf graf--li">GraphQL只有一个<code>route</code>而REST有多个路由。随着客户端需求的增加，REST端点也在不断增加。</li>
<li class="graf graf--li">除了REST有多个端点之外，它还附带了<code>HTTP</code>动词(POST、PUT、GET等),但是GraphQL也涵盖了我们，因为它不需要这些东西。</li>
<li class="graf graf--li">每个API都应该有文档，但是GraphQL给了我们一个现成的API文档。</li>
<li class="graf graf--li">你可以在GraphQL中轻松地<code>resolve</code>尽可能远的数据，但在REST的情况下就不行了。它肯定会有一个新的终点。</li>
<li class="graf graf--li">GraphQL不会让你担心如何<code>version</code>你的API，因为单个路由不会改变，但是你需要关心的是当更新不断到来时，你应该如何在使用REST的同时版本化你的API。</li>
</ul>
<p class="graf graf--p">说教到此为止！</p>
<p class="graf graf--p">让我们来看一个典型的GraphQL文档。随意复制并粘贴<a class="markup--anchor markup--p-anchor" href="https://www.apollographql.com/docs/apollo-server/getting-started.html" target="_blank" rel="noopener noreferrer" data-href="https://www.apollographql.com/docs/apollo-server/getting-started.html">片段</a>，在您的机器上感受一下。</p>
<p><img decoding="async" class="graf-image jetpack-lazy-image" src="../Images/fb7c26108f2dbd3539658bd94aed78da.png" data-image-id="1*BsR8Q4yrpkPK6fR1IkyQ6Q.gif" data-lazy-src="https://storage.googleapis.com/blog-images-backup/1*BsR8Q4yrpkPK6fR1IkyQ6Q.gif?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://storage.googleapis.com/blog-images-backup/1*BsR8Q4yrpkPK6fR1IkyQ6Q.gif"/></p><noscript><img data-lazy-fallback="1" decoding="async" class="graf-image" src="../Images/fb7c26108f2dbd3539658bd94aed78da.png" data-image-id="1*BsR8Q4yrpkPK6fR1IkyQ6Q.gif" data-original-src="https://storage.googleapis.com/blog-images-backup/1*BsR8Q4yrpkPK6fR1IkyQ6Q.gif"/></noscript>
<p class="graf graf--p">在这个项目的过程中，我们将使用<code>Apollo</code>来探索GraphQL。Apollo同时支持NodeJs和VueJs。😃</p>
<p class="graf graf--p">让我们来看看我们项目的演示是什么样子的，这应该会给你一个未来的想法。也可以设置一下。</p>
<p><img decoding="async" class="graf-image jetpack-lazy-image" src="../Images/45e0561db1a9ea1d322533c0e6472b1a.png" data-image-id="1*iC228AF0k17NXArEiFsLAQ.gif" data-lazy-src="https://storage.googleapis.com/blog-images-backup/1*iC228AF0k17NXArEiFsLAQ.gif?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://storage.googleapis.com/blog-images-backup/1*iC228AF0k17NXArEiFsLAQ.gif"/></p><noscript><img data-lazy-fallback="1" decoding="async" class="graf-image" src="../Images/45e0561db1a9ea1d322533c0e6472b1a.png" data-image-id="1*iC228AF0k17NXArEiFsLAQ.gif" data-original-src="https://storage.googleapis.com/blog-images-backup/1*iC228AF0k17NXArEiFsLAQ.gif"/></noscript><br/>
Recipe demo
<h4>GraphQL的关键组件</h4>
<h4 class="graf graf--h4">我们将重点关注四个主要部分:</h4>
<p class="graf graf--p">类型</p>
<ul class="postList">
<li class="graf graf--li">问题</li>
<li class="graf graf--li">变化</li>
<li class="graf graf--li">下决心者</li>
<li class="graf graf--li"><strong class="markup--strong markup--li-strong">类型:</strong>在数据库层面上，我们为每个模型都准备了一个<code>schema</code>。在这个项目中，我们只有两个模型(配方和用户)。</li>
</ul>
<ol class="postList">
<li class="graf graf--li"><em>数据库级模式</em></li>
</ol>
<pre><code>const recipeSchema = new mongoose.Schema({
    name: {
        type: String,
    },
    description: {
        type: String,
    },
    difficultyLevel: {
        type: Number,
    },
    fileUrl: {
        type: String
    },
    steps: [{
        type: String
    }],
    averageTimeForCompletion: {
        type: Number,
    },
userId: {
        type: mongoose.Schema.Types.ObjectId,
        ref: 'User'
    }
}, { timestamps: true });
export const Recipe = mongoose.model('Recipe', recipeSchema);</code></pre>
<p>我们还有一个API级别的模式，它将符合上面的数据库模式。这个模式也像数据库模式上的验证器一样。具有GraphQL无法识别的类型的查询将被退回。</p>
<p class="graf graf--p"><em>API级模式</em></p>
<pre><code>type Recipe {
  id: ID!
  name: String!
  description: String!
  difficultyLevel: Int!
  image: String!
  steps: [String]!
  averageTimeForCompletion: Int!
  user: User!
}</code></pre>
<p>在编写模式时，GraphQL支持不同的对象<code>Types</code>:<code>Int</code>，<code>Float</code>，<code>String</code>，<code>Boolean</code>，<code>ID</code>，就像MongoDB中的_id一样。它还支持List，以防你的数据库模式有一个对象列表和更多的列表。</p>
<p class="graf graf--p">符号确保对象不返回空值。当你再次确定时，总是使用它，一个值将被返回。如果它似乎被使用，并且值为null，那么将抛出一个<code>error</code>。在上面的代码片段中，我们不希望类型为<code>ID</code>的<code>id</code>为空。</p>
<p class="graf graf--p">我们也可以拥有自己的<code>custom</code>类型，就像我们拥有<code>File</code>类型一样。</p>
<p class="graf graf--p"><strong class="markup--strong markup--p-strong"> 2。查询:</strong>在REST中，获取数据的标准方式是使用<code>GET.</code>同样的概念也适用于GraphQL查询。我们在需要获取数据的地方使用查询。查询在GraphQL中只能定义一次。</p>
<pre><code>type File {
    id: ID!
    url: String!
}</code></pre>
<p class="graf graf--p">为了更好地理解，每个GraphQL组件在项目中都有自己的文件。在recipe项目中，关键字<code>Query</code>被多次使用。</p>
<p class="graf graf--p">让我们看看如何编写一个<code>query</code>来获取会话中用户的属性。</p>
<p class="graf graf--p">更多来自LogRocket的精彩文章:</p><div class="code-block code-block-54">
<hr/>
<h3><em>查询用户</em></h3>

<hr/></div>
<pre><code>type User {
    id: ID!
    email: String!
    name: String!
    token: String
    createdAt: String!
    updatedAt: String!
}
type Query {
    getMe: User!
}</code></pre>
<p>既然我们已经在用户资源中声明了<code>query</code>，我们还必须在配方资源中声明查询。你应该知道它会抛出一个错误。好吧，我们都准备好了。对于多次使用的关键字查询，需要使用关键字<code>extend</code>进行扩展。</p>
<p class="graf graf--p">为了获取用户食谱，我们需要一个与该食谱相关联的用户ID。GraphQL查询也可以接受参数。</p>
<p class="graf graf--p"><em>配方</em></p>
<pre><code>extend type Query {
    Recipe(id: ID!): Recipe!
    Recipes: [Recipe]!
}</code></pre>
<p>上面有两个不同的查询。第一个函数使用类型为<code>ID</code>的参数<code>id</code>获得一个食谱，该参数不能为空，而后者返回系统中的所有食谱。</p>
<p class="graf graf--p"><strong class="markup--strong markup--p-strong"> 3。突变:</strong>一个API不仅仅是获取，在某些时候，数据必须被存储、更新或删除以保持我们平台的活力。要执行此操作(<code>POST</code>、<code>PUT</code>、<code>DELETE</code>等)，最好在<code>mutation</code>下声明。</p>
<p class="graf graf--p"><em>创建一个用户(突变)</em></p>
<pre><code>type Mutation {
    createUser(email: String!, name: String!, password: String)
}</code></pre>
<p>变异本可以写得更好，但我更喜欢使用变量声明风格。是的，你也可以为你的突变声明一个变量。</p>
<p class="graf graf--p">如果您需要客户机在发送响应之前提供输入，变量将会派上用场。</p>
<p class="graf graf--p"><em>用户登录和注册</em></p>
<pre><code>type Mutation {
  createUser(input: NewUser!): User!
  loginUser(input: LoginUser!): User!
}</code></pre>
<p>变量可以有任何形式。只要通过创建或声明您的变量类型来通知GraphQL，就不会有警报。😉</p>
<p class="graf graf--p">在上面的变异中，我们有接受类型为<code>NewUser</code>的<code>input</code>的<code>loginUser</code>和<code>createUser</code>，后者必须返回类型<code>User</code>和类型<code>LoginUser</code>，后者也返回类型<code>User</code>。我们已经在上面看到了用户的样子。</p>
<p class="graf graf--p"><code>input</code>是变量的一种形式，为声明类型的参数提供服务。</p>
<blockquote class="graf graf--blockquote"><p>登录和注册类型</p></blockquote>
<pre><code>input LoginUser {
  email: String!
  password: String!
}
input NewUser {
  email: String!
  name: String!
  password: String!
}</code></pre>
<p><em>配方模式</em></p>
<pre><code>type Recipe {
  id: ID!
  name: String!
  description: String!
  difficultyLevel: Int!
  image: String
  steps: [String]!
  averageTimeForCompletion: Int!
  user: User!
}
input NewRecipe {
  name: String!
  description: String!
  difficultyLevel: Int!
  image: Upload
  steps: [String]! 
  averageTimeForCompletion: Int!
}
input UpdateRecipe {
  id: ID!
  name: String
  description: String
  difficultyLevel: Int!
  image: String
  steps: [String]
  averageTimeForCompletion: Int!
}
input DeleteRecipe {
    id: ID!
}
# query is use when you want to get anything from 
#the server just like (GET) using REST
extend type Query {
    Recipe(id: ID!): Recipe!
    Recipes: [Recipe]!
}
# performing actions (that requires DELETE, PUT, POST) 
#just as in REST requires a mutation 
extend type Mutation {
    deleteRecipe(input: DeleteRecipe!): Recipe!
    updateRecipe(input: UpdateRecipe!): Recipe!
    newRecipe(input: NewRecipe!): Recipe!
}</code></pre>
<p>在上面的代码片段中，用户可以根据我们在<code>Mutation</code>中的声明决定删除配方、更新配方和创建新配方。</p>
<p class="graf graf--p">有没有注意到一个没有声明但是使用了<code>Upload</code>的类型？但是GraphQL似乎对此并不介意。我们将在文件部分讨论这个问题。</p>
<p class="graf graf--p"><strong class="markup--strong markup--p-strong"> 4。</strong> <strong class="markup--strong markup--p-strong">解析器:</strong>既然我们已经声明了类型、突变和查询。这与客户对我们数据库的要求有什么联系？</p>
<p class="graf graf--p">让我们来看看这个流程…</p>
<p class="graf graf--p">所以在GraphQL中，我们有标量类型(<code>Strings</code>、<code>Integers</code>、<code>Booleans</code>、<code>Float</code>、<code>Enums</code>)。如果我们足够幸运地将我们的数据库对象与我们拥有的类型相匹配，GraphQL将为我们解决这个问题。</p>
<figure class="graf graf--figure"><img decoding="async" class="graf-image jetpack-lazy-image" src="../Images/340491add529eefce26ec24de0b6dc46.png" data-image-id="1*a6F8kPNU5PT6NPH8zEyq3g.png" data-width="741" data-height="771" data-lazy-src="https://storage.googleapis.com/blog-images-backup/1*a6F8kPNU5PT6NPH8zEyq3g.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://storage.googleapis.com/blog-images-backup/1*a6F8kPNU5PT6NPH8zEyq3g.png"/><noscript><img data-lazy-fallback="1" decoding="async" class="graf-image" src="../Images/340491add529eefce26ec24de0b6dc46.png" data-image-id="1*a6F8kPNU5PT6NPH8zEyq3g.png" data-width="741" data-height="771" data-original-src="https://storage.googleapis.com/blog-images-backup/1*a6F8kPNU5PT6NPH8zEyq3g.png"/></noscript><figcaption class="imageCaption">An overview of how GraphQL handles data</figcaption></figure>
<p class="graf graf--p">让我们来处理我们在突变中声明的动作。记住我们在突变中声明的论点是<code>input</code>。无论我们期望从客户端得到什么，都可以在变量<code>input</code>中找到。</p>
<p class="graf graf--p"><em>登录用户</em></p>
<pre><code>import { User } from './user.model'; 
import { Recipe } from '../recipe/recipe.model'; 
import { signIn, verify } from '../../modules/auth';''
const loginUser = async(root, { input }) =&gt; {
    const { email, password } = input;
    const user = await User.findOne({ email }).exec();
    const errorMsg = 'Wrong credentials. Please try again';
    if(!user) {
        throw new Error (errorMsg);
    }
    if(user.comparePassword(password)) {
        user.token = signIn({ id: user._id, email: user.email });
        return user;
    }
    else{
        throw new Error (errorMsg);
    }
};</code></pre>
<p>让我们花点时间来看看<code>Queries</code>和<code>Mutations</code>的论点。以<code>loginUser</code>为例。</p>
<p class="graf graf--p">每个解析器中都有四个主要的自变量(<code>rootValue</code>、<code>arguments</code>、<code>context </code>和<code>info</code>)。</p>
<p class="graf graf--p"><code>rootValue</code>:主要用于处理嵌套解析器(主分支的子分支)。</p>
<ul class="postList">
<li class="graf graf--li"><em>用户类型</em></li>
</ul>
<pre><code>type User {
    id: ID!
    email: String!
    name: String!
    token: String
    recipes: [Recipe]!
    createdAt: String!
    updatedAt: String!
}</code></pre>
<p>看上面的类型，在我们的数据库模型中有一个我们没有声明的对象。这意味着GraphQL期望我们解决(处理它并赋值)。</p>
<p class="graf graf--p"><code>recipes</code>将被视为嵌套解析器。树枝上方的<code>rootValue</code>是<code>User</code>。这样做的好处是<code>fetching recipes</code>由用户创建。</p>
<p class="graf graf--p"><em>嵌套解析器</em></p>
<pre><code>
    User: {
        recipes(user) {
           return Recipe.find({ userId: user.id }).exec()
        }
    }</code></pre>
<p><code>arguments</code>:保存从客户端传来的参数。在我们定义的突变中，我们期望客户端传入一个<code>input</code></p>
<ul class="postList">
<li class="graf graf--li"><code>context</code>:它保存了所有需要在解析器之间共享的数据。在这个项目中，我们将经过验证的用户传递给上下文</li>
<li class="graf graf--li">这是我们可能永远不会使用的唯一论据。这是原始的GraphQL查询</li>
<li class="graf graf--li">对于<code>loginUser</code>，用户传递从参数对象中析构的电子邮件和密码，然后返回一个用户，就像我们在变异中声明的那样(user！)如果凭证是正确的，否则我们抛出一个错误。</li>
</ul>
<p class="graf graf--p">我们在突变类型(<code>server/api/resources/user/<em class="markup--em markup--p-em">user.graphql file</em></code>)中的声明也必须与传递给解析器的声明相同。</p>
<p class="graf graf--p"><em>用户解析器</em></p>
<pre><code>export const userResolvers = {
    Query: {
        getMe
    },
    Mutation: {
        createUser, //createUser: createUser
        loginUser //loginUser: loginUser
    },
    User: {
        recipes(user) {
           return Recipe.find({ userId: user.id }).exec()
        }
    }
}</code></pre>
<p>证明</p>
<h4 class="graf graf--h4">有几种方法可以验证我们的GraphQL应用程序，特别是当我们想要公开查询或变异操作时(<code>loginUser</code>和<code>createUser</code>)。</h4>
<p class="graf graf--p">我们可以通过对公共路由使用REST和单独保护单一GraphQL路由来保护它。就个人而言，我总是选择这个选项，因为它为您的应用程序提供了灵活性。</p>
<p class="graf graf--p">在这个项目中，我们在一个<code>resolver level</code>上认证了GraphQL。当用户成功登录时，使用<code>jwebtokens</code>生成的令牌被返回给客户端，并被传递给头部。</p>
<p class="graf graf--p">中间件</p>
<pre><code>import { verify } from './api/modules/auth';
const setMiddleware = (app) =&gt; {
    app.use(async (req, res, next) =&gt; {
        try{
            const token = req.headers.authorization || '';
            const user = await verify(token);
            req.user = user;
        }
        catch(e) {
            console.log(e)
            req.user = null;
        }
        next();
    });
};
export default setMiddleware;</code></pre>
<h4>中间件交叉检查每个请求中的报头，获取令牌，验证并在成功的情况下给出适当的有效载荷(用户)。中间件然后被传递到Apollo服务器。</h4>
<p class="graf graf--p">既然我们使用express，<code>apollo-server-express</code>是我们最好的工具。</p>
<p class="graf graf--p"><em>认证</em></p>
<pre><code>setMiddleware(app);
const path = '/recipe'
graphQLRouter.applyMiddleware({ app, path});
</code><code>const secret = process.env.TOKEN_SECRET;
const expiresIn = process.env.EXPIRES_IN || '1 day';
export const signIn = payload =&gt; jsonwebtoken.sign(payload, secret, { expiresIn });
export const verify = token =&gt; {
    return new Promise((resolve, reject) =&gt; {
        jsonwebtoken.verify(token, secret, {}, (err, payload) =&gt; {
            if(err){
                return reject(err);
            }
            return resolve(payload);
        })
    })
}
export const throwErrorIfUserNotAuthenticated = user =&gt; 
        {if(!user) throw new Error('hey!. You are not authenticated')}</code></pre>
<p>这是关键，每个球员都走到了一起。GraphQL标签(<code>gql</code>)使得编写和组合模式更加容易。</p>
<p class="graf graf--p">对于每个解析器，我们检查用户是否为空，一旦为空，客户端就被退回。系统告诉客户端对请求进行身份验证。</p>
<pre><code>import { ApolloServer, gql } from 'apollo-server-express';
import merge from 'lodash.merge'
import { userType, userResolvers } from './resources/user';
import { recipeType, recipeResolvers } from './resources/recipe';
import { fileType } from './resources/file';
const typeDefs = gql`${userType}${recipeType}${fileType}`;
export const graphQLRouter = new ApolloServer(
    {
        typeDefs,
        resolvers: merge({}, userResolvers, recipeResolvers),
        context: ({req, res})=&gt; ({ user: req.user })
    }
);</code></pre>
<p class="graf graf--p">检查用户是否有权访问此解析程序</p>
<pre><code>const getRecipe = (root, { id }, { user }) =&gt; {
    throwErrorIfUserNotAuthenticated(user); 
    return Recipe.findById(id).exec();
}; </code></pre>
<p>文件上传</p>
<h4 class="graf graf--h4">除了发送简单的数据，我们还会以某种方式上传文件。Apollo server 2.0 ~通过开箱即用处理文件，让生活变得更加轻松。<code>Upload</code>graph QL识别标量。它帮助处理一个可变文件对象。它被添加到<code>NewRecipe</code>输入中，以处理请求附带的文件。</h4>
<p class="graf graf--p">创建新配方</p>
<pre><code>
const createRecipe = async (root, { input }, { user }) =&gt; {
  throwErrorIfUserNotAuthenticated(user);
  //    bring out the image from input for file processing
  const { image, ...recipeObject } = await input;
  let url = "";
  if (image) {
    const result = await uploadFile(image);
    url = result.url;
  }
  const recipe = await Recipe.findOne({ name: input.name.toLowerCase() });
  if (recipe) {
    throw new Error("Recipe already exists!");
  }
  Object.assign(recipeObject, { image: url, userId: user.id });
  return Recipe.create(recipeObject);
};</code></pre>
<p>文件流正在被处理，完成后，URL将与rest输入对象一起保存。</p>
<p class="graf graf--p">让我们看看医生。如果您的端口号是3000并且您的MongoDB在本地运行，那么可以在<a class="markup--anchor markup--p-anchor" href="http://localhost:3000/recipe" target="_blank" rel="nofollow noopener noreferrer" data-href="http://localhost:3000/recipe">http://localhost:3000/recipe</a>上访问它。一旦你能与文档很好地互动，客户端就变得非常容易。</p>
<pre><code>import cloudinary from "cloudinary";
import streamToBuffer from "stream-to-buffer";
cloudinary.config({
  cloud_name: process.env.CLOUDINARY_CLOUD_NAME,
  api_key: process.env.CLOUDINARY_API_KEY,
  api_secret: process.env.CLOUDINARY_API_SECRET
});
export const uploadFile = async file =&gt; {
  const { mimetype, stream } = await file;
  // process image
  return new Promise((resolve, reject) =&gt; {
    if (!Object.is(mimetype, "image/jpeg")) {
      throw new Error("File type not supported");
    }
    streamToBuffer(stream, (err, buffer) =&gt; {
      cloudinary.v2.uploader
        .upload_stream({ resource_type: "raw" }, (err, result) =&gt; {
          if (err) {
            throw new Error("File not uploaded!");
          }
          return resolve({ url: result.url });
        })
        .end(buffer);
    });
  });
};</code></pre>
<p class="graf graf--p">交给客户</p>
<h4 class="graf graf--h4">如果你熟悉从Vue向服务器发送数据，使用<code>vue-apollo</code>没有太大区别。你所需要做的就是写出你的问题。Vue-apollo为您处理其余的事情。</h4>
<p class="graf graf--p">那么，让我们设置我们的Vue-apollo:</p>
<p class="graf graf--p"><code>setContext</code> from <code>apollo-link-context</code>让我们能够在请求传递到服务器之前拦截它。记住，我们需要将一个令牌传递给头部，以便访问经过身份验证的资源。</p>
<pre><code>import Vue from 'vue';
import VueApollo from "vue-apollo";
import apolloUploadClient from "apollo-upload-client"
import { InMemoryCache } from "apollo-cache-inmemory";
import { ApolloClient } from "apollo-client";
import { setContext } from "apollo-link-context";
Vue.use(VueApollo);
const baseUrl = "http://localhost:3000/recipe";
const uploadClientLink = apolloUploadClient.createUploadLink({
  uri: baseUrl
});
const interceptor = setContext((request, previousContext) =&gt; {
  const token = localStorage.getItem("token");
  if(token) {
    return {
        headers: {
          authorization: token
        }
      };
  }
});
const apolloClient = new ApolloClient({
  link: interceptor.concat(uploadClientLink),
  cache: new InMemoryCache(),
  connectToDevTools: true
});
const instance = new VueApollo({
  defaultClient: apolloClient
});
export default instance;
view raw</code></pre>
<p class="graf graf--p">每个响应都被缓存。<code>cache: new InMemoryCache()</code>，从上面显示的演示中，当一个新的食谱被创建时，我们期望它和其他食谱一起反映在<code>All recipes </code>页面中。但是响应已经被缓存了。它返回从内存中获取的响应。这有利有弊。</p>
<p class="graf graf--p"><code>this.$apollo</code>允许我们访问Vue apollo，只要它已经添加(<code>Vue.use(VueApollo)</code>)到Vue。</p>
<p class="graf graf--p">让我们创建查询:</p>
<p class="graf graf--p">这里的查询结构是我们在服务器端所期望的，查询的响应是基于选择的。</p>
<pre><code>import gql from "graphql-tag";
// user object pointing to loginUser to make the return response pretty
export const LOGIN_QUERY = gql`
  mutation LoginUser($input: LoginUser!) {
    user: loginUser(input: $input) {
      token
    }
  }
`;
export const REGISTERATION_QUERY = gql`
  mutation RegisterUser($input: NewUser!) {
    user: createUser(input: $input) {
      token
    }
  }
`;
export const ALL_RECIPES_QUERY = gql`
  query {
    recipeList: Recipes {
      id
      name
      image
    }
  }
`;
export const GET_USER_QUERY = gql`
  query {
    user: getMe {
      name
      email
      recipes {
        id
        name
        image
      }
    }
  }
`;
export const CREATE_RECIPE_QUERY = gql`
  mutation createRecipe($input: NewRecipe!) {
    newRecipe(input: $input) {
      id
    }
  }
`;</code></pre>
<p class="graf graf--p"><code>GET_USER_QUERY</code>获取会话中用户的姓名、电子邮件、食谱(id、姓名和图像)。</p>
<p class="graf graf--p">将<code>apollo</code>添加到组件中，以获取与对象相关的特定查询。<code>getMe</code>查询被绑定到用户对象。</p>
<pre><code>apollo: {
    user: query.GET_USER_QUERY
  }</code></pre>
<p class="graf graf--p">在my-recipe页面上，我们不希望响应来自缓存内存。</p>
<p class="graf graf--p"><code>refetch</code>使用相应的(用户)查询从服务器获取最新数据。这应该谨慎使用。</p>
<pre class="graf graf--pre">this.$apollo.queries.user.refetch();</pre>
<p class="graf graf--p">从<code>apollo</code>可以访问一些有趣的选项，比如加载状态、错误、暂停查询流等等。</p>
<p class="graf graf--p">我们如何处理突变？</p>
<p class="graf graf--p">让我们看看如何创建食谱:</p>
<p class="graf graf--p">因为我们对单个文件感兴趣，所以file对象被绑定到image ( <code>part of the object going to the server</code>)。</p>
<p class="graf graf--p"><code>$this.apollo.mutate</code>接受突变及其变量。因为服务器正在请求输入。一个<code>input</code>对象被传递给变量。</p>
<pre><code>onFileChange(e) {
      const files = e.target.files || e.dataTransfer.files;
      this.image = files[0];
    }</code></pre>
<p class="graf graf--p"><em>创建配方</em></p>
<pre><code>   async createRecipe() {
      const recipeObject = {
        name: this.recipeName,
        description: this.description,
        difficultyLevel: this.difficultyLevel
          ? parseInt(this.difficultyLevel)
          : 0,
        image: this.image,
        steps: this.stepsList,
        averageTimeForCompletion: this.averageTime
          ? parseInt(this.averageTime)
          : 0
      };
      await this.$apollo
        .mutate({
          mutation: query.CREATE_RECIPE_QUERY,
          variables: { input: recipeObject }
        })
        .then(({ data }) =&gt; {
            this.$router.push({ name: "my-recipes" });
        })
        .catch(err =&gt; {
          console.log(err);
          this.error =
            parseGraphqlError(err) || "Something went wrong. Try again...";
        });
    }</code></pre>
<p>结论</p>
<h4 class="graf graf--h4">就像我前面说的，相比我们习惯的(REST)，GraphQL更容易设置、更新和重构。</h4>
<p class="graf graf--p">如果您的模式设计得不好，您的客户端可以对您的模式进行递归调用。避免会给出相同结果的查询。关于GraphQL with Apollo的更多信息，请点击<a class="markup--anchor markup--p-anchor" href="https://www.apollographql.com/docs/" target="_blank" rel="noopener noreferrer" data-href="https://www.apollographql.com/docs/">这里</a>。如果你想了解更多关于Vue Apollo的信息，请点击这里的<a class="markup--anchor markup--p-anchor" href="https://akryum.github.io/vue-apollo/guide/" target="_blank" rel="noopener noreferrer" data-href="https://akryum.github.io/vue-apollo/guide/"/>。</p>
<p class="graf graf--p">像用户一样体验您的Vue应用</p><div class="code-block code-block-20">
<div class="blog-plug inline-plug vue-inline"><h2>调试Vue.js应用程序可能会很困难，尤其是当用户会话期间有几十个(如果不是几百个)突变时。如果您对监视和跟踪生产中所有用户的Vue突变感兴趣，</h2><p>. </p><a href="https://lp.logrocket.com/blg/vue-signup" target="_blank">try LogRocket</a><p>LogRocket 就像是网络和移动应用程序的DVR，记录你的Vue应用程序中发生的一切，包括网络请求、JavaScript错误、性能问题等等。您可以汇总并报告问题发生时应用程序的状态，而不是猜测问题发生的原因。</p><a class="signup" href="https://lp.logrocket.com/blg/vue-signup" target="_blank" rel="noopener noreferrer"><img class="alignnone size-full wp-image-46 jetpack-lazy-image" src="../Images/0d269845910c723dd7df26adab9289cb.png" alt="LogRocket Dashboard Free Trial Banner" data-lazy-src="https://files.readme.io/00591d0-687474703a2f2f692e696d6775722e636f6d2f6a3049327856572e706e67.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://files.readme.io/00591d0-687474703a2f2f692e696d6775722e636f6d2f6a3049327856572e706e67.png"/><noscript><img data-lazy-fallback="1" class="alignnone size-full wp-image-46" src="../Images/0d269845910c723dd7df26adab9289cb.png" alt="LogRocket Dashboard Free Trial Banner" data-original-src="https://files.readme.io/00591d0-687474703a2f2f692e696d6775722e636f6d2f6a3049327856572e706e67.png"/></noscript></a><a href="https://lp.logrocket.com/blg/vue-signup" target="_blank" rel="noopener noreferrer">https://logrocket.com/signup/</a><p>LogRocket Vuex插件将Vuex突变记录到LogRocket控制台，为您提供导致错误的环境，以及出现问题时应用程序的状态。</p><p>现代化您调试Vue应用的方式- <a class="signup" href="https://lp.logrocket.com/blg/vue-signup" target="_blank" rel="noopener noreferrer">开始免费监控</a>。</p><p>Modernize how you debug your Vue apps - <a class="signup" href="https://lp.logrocket.com/blg/vue-signup" target="_blank" rel="noopener noreferrer">Start monitoring for free</a>.</p></div>


</div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
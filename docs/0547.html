<html>
<head>
<title>Django and GraphQL: Demo project with Graphene - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>Django和graph QL:Graphene-log rocket博客演示项目</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/django-graphql-project-graphene/#0001-01-01">https://blog.logrocket.com/django-graphql-project-graphene/#0001-01-01</a></blockquote><div><article class="article-post">
<p><em> <strong>编者按:</strong>本文于2022年5月3日更新，以反映GraphQL和Django的最新版本，并更好地详细说明GraphQL和Django演示项目，包括使用石墨烯进行集成。</em></p>
<p>在过去八年左右的时间里，Django一直是制作快速web应用程序、API端点或其他应用程序的管理面板的最有效框架。</p>
<p>Django的最大优势之一是它能够让用户编写更少的代码，更快地开始工作，特别是如果您包括一个管理面板和一个完全可管理的数据库迁移过程作为基本功能的话。</p>
<p>Django REST Framework是一个外部工具包，它使得构建API端点变得很容易。它基本上只用几行代码就将完整的CRUD API包装在Django模型周围。</p>
<p>这意味着用Django构建任何基本的CRUD API都有助于将开发重点更多地放在UI部件上，UI部件是所有软件产品的关键元素。</p>
<p>类似地，GraphQL旨在通过提供严格类型查询语言和单个API端点来自动化后端API，在该端点上，您可以从UI查询所有需要的信息，并触发动作(突变)以将数据发送到后端。</p>
<p>我的GraphQL之旅是从脸书的API开始的，GraphQL就是从那里来的。</p>
<p>自然，GraphQL被认为非常接近JavaScript世界，主要是因为基于浏览器的应用程序是该技术的第一批采用者。</p>
<p>这就是为什么我的第一个GraphQL server+client是在Node.js和React.js中完成的，在GraphQL API的基础上构建了第一个应用程序后，我开始专门将其用于我的基于Web的项目。</p>
<p>在本文中，我将回顾GraphQL和GraphQL订阅的优点。我还将使用GraphQL和Django构建一个示例项目，展示这种组合对于web开发的强大功能。我会用石墨烯来整合。</p>
<h3><em>向前跳转:</em></h3>

<h2 id="advantages-of-graphql">GraphQL的优势</h2>
<p>你可能已经猜到了，Django有一个支持GraphQL的库叫做<a href="https://docs.graphene-python.org/projects/django/en/latest/" target="_blank" rel="noopener"> Graphene-Django </a>，和Django REST框架非常相似。但是，Django REST和Django with GraphQL之间存在显著的差异。</p>
<p>关键的区别在于UI的可用性:使用REST API，您会得到无数带有特定参数名的URL，您必须在这些URL中检查类型和特定值。</p>
<p>同时，使用GraphQL，您可以定义类似于下面代码的变化，并获得严格定义的变量名和类型，这成为自动GraphQL类型验证的一部分。</p>
<pre class="language-python hljs">type Mutation {
  userLogin(email: String!, password: String!): UserLoginResponse
}

type UserLoginResponse {
  token: String
  error: Boolean
  message: String
}
</pre>
<p>GraphQL还附带了封装在其类型系统中的另一个好处:它自动生成文档，您可以在其中获得可用的查询和变异及其参数/返回类型。</p>
<p>Django REST也生成某种形式的文档，但是它不如GraphQL Playground 有用。</p>
<p>如果你认为这种类型的接口适用于所有类型的GraphQL端点，那你就错了——这只适用于开发模式服务器。不过，您可以下载GraphQL Playground standalone之类的软件，并为任何公共GraphQL端点手动配置它。</p>
<p>就安全性而言，拥有一个API端点自然比拥有数百个端点更容易管理——尤其是当您考虑到GraphQL会自动保持特定的类型规则，并且不允许参数名或参数值不正确的请求时。</p>
<h2 id="django-graphql">姜戈·❤️·格拉夫QL</h2>
<p>让我们用Django和GraphQL构建一个基本项目来演示这个设置有多强大。一方面，您可以通过数据库获得简单的CRUD管理。另一方面，您将获得一种非常强大的具有单一端点的API查询语言。</p>
<h3 id="project-setup">项目设置</h3>
<ul>
<li>在IDE终端或独立终端模拟器中打开一个空目录</li>
<li>创建虚拟环境:<code>python -m venv venv</code></li>
<li>激活虚拟环境:<code>source ./venv/bin/activate</code></li>
<li>安装Django和石墨烯:<code>pip install django graphene_django</code></li>
<li>创建新的Django项目:<code>django-admin startproject graphqlpractice</code></li>
<li>光盘放入上层<code>graphqlpractice</code>目录</li>
</ul>
<h3 id="creating-the-models">创建模型</h3>
<p>现在，让我们创建并定义我们的模型。创建一个新的Django应用程序<code>django-admin startapp postusers</code>，并在<code>settings.py</code>中注册应用程序，如下所示:</p>
<pre class="language-python hljs">INSTALLED_APPS = [
...
"postusers.apps.PostusersConfig"
]</pre>
<p>接下来，像这样定义<code>postusers/models.py</code>中的模型:</p>
<pre class="language-python hljs">from django.db import models
class Author(models.Model):
    name = models.CharField(max_length=100)


    def __str__(self):
        return self.name

class Post(models.Model):
    title = models.CharField(maxlength=100)
    body = models.TextField()
    author = models.ForeignKey(
        Author, relatedname="posts", on_delete=models.CASCADE
    )
    def str(self):
        return self.title</pre>
<p>现在，让我们通过向<code>postusers/admin.py</code>添加以下代码来向管理面板注册模型:</p>
<pre class="language-python hljs">from django.contrib import admin
from .models import Author, Post
admin.site.register(Author)
admin.site.register(Post)</pre>
<p>接下来，进行迁移:<code>python manage.py makemigrations</code>。</p>
<blockquote><p><strong>注意，</strong>如果你得到一个关于<code>force_text</code>的错误，这与Django 4中的突破性变化有关；要么降级到Django 3，要么按照指示<a href="https://exerror.com/importerror-cannot-import-name-force_text-from-django-utils-encoding/" target="_blank" rel="noopener">这里</a></p></blockquote>
<p>现在，运行迁移:<code>python manage.py migrate</code></p>
<p>创建一个超级用户— <code>python manage.py createsuperuser</code> —并使用<code>python manage.py runserver</code>运行您的服务器。然后前往<code>localhost:8000/admin</code>，添加一些作者和帖子。</p>
<h3 id="setting-up-graphene">设置石墨烯</h3>
<p>现在，让我们建立石墨烯，一个与Django集成的强大库。首先，将石墨烯添加到<code>/graphqlpractices/settings.py</code>中已安装的应用程序中，如下所示:</p>
<pre class="language-python hljs">INSTALLEDAPPS = [
    ...
    'django.contrib.staticfiles',
    "graphenedjango"
    ...
]</pre>
<p>然后，将GraphQL端点添加到<code>/graphqlpractice/urls.py</code>:</p>
<pre class="language-python hljs">from django.contrib import admin
from django.urls import path
from graphenedjango.views import GraphQLView
urlpatterns = [
    path('admin/', admin.site.urls),
    path("graphql", GraphQLView.asview(graphiql=True)),
]</pre>
<p>接下来，添加下面的<code>settings.py</code>来标识您的GraphQL模式所在的位置，<code>postusers/schma/schema.py</code>；您需要创建模式目录和文件。</p>
<pre class="language-python hljs">GRAPHENE = {
    "SCHEMA": "postusers.schema.schema"
}</pre>
<p>这个项目最有趣的部分是用Python定义GraphQL类型和查询。它实际上基于您的数据库模型，但是您也可以在不使用Django模型的情况下定义定制查询。</p>
<p>将以下内容添加到<code>postusers/schema/schema.py</code>:</p>
<pre class="language-python hljs">from graphene_django import DjangoObjectType
import graphene
from postusers.models import Post as PostModel
from postusers.models import Author as AuthorModel
class Post(DjangoObjectType):
    class Meta:
        model = PostModel
        fields = ['id', 'title', 'body', 'author']

class Author(DjangoObjectType):
    class Meta:
        model = AuthorModel
        fields = ['id', 'name', 'posts']
    def resolve_posts(self, info):
                return PostModel.objects.filter(author=self)
    @classmethod
    def get_node(cls, info, id):
        return Author.objects.get(id=id)
class Query(graphene.ObjectType):
    authors = graphene.List(Author)
    posts = graphene.List(Post)
    def resolve_authors(self, info):
        return AuthorModel.objects.all()

    def resolve_posts(self, info):
        return PostModel.objects.all()
schema = graphene.Schema(query=Query)
</pre>
<p>现在您可以运行服务器并转到<code>localhost:8000/graphql</code>来测试一些GraphQL查询，如下所示:</p>
<pre class="language-python hljs">query {
  authors {
    name
      posts {
        title
      }
  }
}
</pre>
<p>最需要记住的是，你可以查询任何你想要的字段，这将影响UI端的整体加载时间和流量使用。</p>
<p>对于较大的用户群，保持低流量并只查询您需要的字段是很重要的。在REST API的情况下，您无论如何都会获得所有字段。</p><div class="code-block code-block-54">
<hr/>
<h3>更多来自LogRocket的精彩文章:</h3>

<hr/></div>
<pre class="language-python hljs">query {
  posts {
    title
    author {
      name
    }
  }
}
</pre>
<p>这是Python定义的基本查询结果。它非常简单，并且与REST APIs相比，比您想象的更具表现力。你可以在这里找到这个练习<a href="https://github.com/AlexMercedCoder/graphql-with-django-graphene-example" target="_blank" rel="noopener">的最终代码供参考</a>。</p>
<h2 id="what-about-graphql-subscriptions">GraphQL订阅呢？</h2>
<p>GraphQL订阅的功能是告诉服务器在数据可用时基于特定的查询检索数据。</p>
<p>它几乎实时地与WebSockets一起工作，这意味着我们必须以某种方式包含Django Websockets，并配置我们的后端服务器来接受Websockets。</p>
<p>基本上，GraphQL只是一个API查询语言解释，当处理客户端和服务器端GraphQL语言解释时，它可以与任何类型的网络传输一起工作。</p>
<p>乍一看似乎很难，但是在Django WebSockets模块上有一个开源库和Django GraphQL订阅。</p>
<pre class="language-python hljs"># settings.py

GRAPHENE = {
    'SCHEMA_INDENT': 4,
    'MIDDLEWARE': [
        # Other middlewares

        'graphenedjangosubscriptions.depromise_subscription',
    ]
}</pre>
<p>这将足以在以后作为订阅查询来处理订阅模式。</p>
<p>顺便提一句，Pinterest实际上完全基于GraphQL订阅，而graph QL订阅是建立在Django后端之上的(但可能做了一些修改)。</p>
<h2 id="conclusion">结论</h2>
<p>在我看来，使用GraphQL的Django比使用REST API的Django功能更强大，可扩展性更强。</p>
<p>然而，它还没有经过实战检验，大公司仍在采用这种组合。尽管如此，基于您从这个简单的配置中所能得到的，想象一下当您将Django与现代技术的GraphQL结合使用时，web开发会变得多么舒适。</p><div class="code-block code-block-24">
<div class="blog-plug inline-plug graphql-plug"><h2>监控生产中失败和缓慢的GraphQL请求</h2><p>虽然GraphQL有一些调试请求和响应的特性，但确保GraphQL可靠地为您的生产应用程序提供资源是一件比较困难的事情。如果您对确保对后端或第三方服务的网络请求成功感兴趣，</p><a href="https://lp.logrocket.com/blg/graphql-signup" target="_blank">try LogRocket</a><p>.</p><a class="signup" href="https://lp.logrocket.com/blg/graphql-signup" target="_blank" rel="noopener noreferrer"><img src="../Images/432a3823c85b3fb72a206e6236a29f48.png" data-lazy-src="https://files.readme.io/69aa835-Image_2019-11-09_at_1.28.05_PM.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" class=" jetpack-lazy-image" data-original-src="https://files.readme.io/69aa835-Image_2019-11-09_at_1.28.05_PM.png"/><noscript><img data-lazy-fallback="1" src="../Images/432a3823c85b3fb72a206e6236a29f48.png" data-original-src="https://files.readme.io/69aa835-Image_2019-11-09_at_1.28.05_PM.png"/></noscript><img class="alignnone size-full wp-image-46 jetpack-lazy-image" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/><noscript><img data-lazy-fallback="1" class="alignnone size-full wp-image-46" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/></noscript></a><a href="https://lp.logrocket.com/blg/graphql-signup" target="_blank" rel="noopener noreferrer">https://logrocket.com/signup/</a><p>LogRocket 就像是网络和移动应用的DVR，记录下你网站上发生的每一件事。您可以汇总并报告有问题的GraphQL请求，以快速了解根本原因，而不是猜测问题发生的原因。此外，您可以跟踪Apollo客户机状态并检查GraphQL查询的键值对。</p><p>LogRocket检测您的应用程序以记录基线性能计时，如页面加载时间、到达第一个字节的时间、慢速网络请求，还记录Redux、NgRx和Vuex操作/状态。</p><a class="signup" href="https://lp.logrocket.com/blg/graphql-signup" target="_blank" rel="noopener noreferrer">Start monitoring for free</a><p>.</p></div>


</div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
<html>
<head>
<title>Dynamic type validation in TypeScript - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>TypeScript - LogRocket博客中的动态类型验证</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/dynamic-type-validation-in-typescript/#0001-01-01">https://blog.logrocket.com/dynamic-type-validation-in-typescript/#0001-01-01</a></blockquote><div><article class="article-post">
<p>毫无疑问，TypeScript已经在JavaScript社区中被广泛采用，它提供的一个巨大好处是对我们代码中的所有变量进行类型检查。它将检查在给定变量类型的情况下，是否可以对变量执行任何操作。</p>
<p>大多数人认为，通过使用TypeScript作为他们的应用程序语言，他们可以“避免”任何空性错误，就像经典的“undefined不是函数”或我最喜欢的“无法读取undefined的属性X”这个假设是错误的，最好的证明方法是用代码！</p>
<p>我在柏林会议的打字稿上做了一个关于这个话题的演讲。这篇文章和<a href="https://youtu.be/cn6i5Av-B8Q?t=1884"> the talk </a>涵盖了相同的内容，所以你可以使用其中任何一个来了解这个话题！</p>
<h2>为什么打字稿不会总是覆盖你🕵</h2>
<p>下面的示例不会出现任何TypeScript错误。</p>
<pre>// Typescript definition
type ExampleType = {
  name: string,
  age?: number,
  pets: {
    name: string,
    legs: number,
  }[],
};

// communicates with external API
const fetchData = (): Promise&lt;ExampleType&gt; =&gt; {};

const getBiped = async () =&gt; {
  const data = await fetchData();
  console.log(data);
  // { name: 'John' }
  return data.pets.find(pet =&gt; pet.legs === 2); // Boom!
};
</pre>
<p>该代码片段包含:</p>
<ul>
<li><code>ExampleType</code>–具有两个必需属性<code>name</code>和<code>pets</code>以及一个可选属性<code>age</code>的类型定义。属性<code>pets</code>是一个带有<code>name</code>和<code>legs</code>的对象数组，两者都是必需的</li>
<li><code>fetchData</code>–从外部端点检索数据的功能</li>
<li><code>getBiped</code>–另一个函数将调用<code>fetchData</code>，迭代<code>pets</code>，并且只返回带有两个<code>legs</code>的<code>pets</code></li>
</ul>
<p>那么，为什么我的脚本在执行时会失败呢？原因是因为外部API正在返回一个内部不包含<code>pets</code>的对象，然后当你试图执行<code>data.pets.find()</code>时，就会收到错误<code>Uncaught ReferenceError: Cannot read property 'find' of undefined</code>。</p>
<p>在<a href="https://reactjs.org/docs/static-type-checking.html">官方React文档</a>中，你可以找到一个关于TypeScript的非常好的定义:</p>
<blockquote><p>TypeScript是微软开发的一种编程语言。它是JavaScript的类型化超集，包括它的编译器。作为一种类型化语言，TypeScript可以在构建时捕捉错误和bug，远在你的应用程序上线之前。</p></blockquote>
<p>有了这个定义，就有可能提出一个新的假设:</p>
<p>TypeScript执行静态类型验证。开发人员应该利用动态验证。</p>
<h2>你需要验证一切吗？🤔</h2>
<p>简单来说，不是！🎉</p>
<p>从开发和性能的角度来看，检查应用程序中的所有变量都非常耗时。一个很好的经验法则是:</p>
<blockquote><p>验证应用程序的所有外部来源。</p></blockquote>
<p>外部来源是外部的或无法访问您的应用程序的任何东西。一些例子:</p>
<ul>
<li>API响应</li>
<li>文件内的内容</li>
<li>来自用户的输入</li>
<li>无类型库</li>
</ul>
<p>一个应用程序将总是呈现至少一个外部源，否则，它很可能是无用的。因此，让我们看看如何在TypeScript中为对象编写验证。</p>
<p>为了简单起见，最初的代码片段将被认为是<em>的基础</em>，在上面，我将展示如何实现每个验证方法。</p>
<h2>手动验证</h2>
<p>最基本的验证是一组检查结构是否是预期结构的条件。</p>
<pre>const validate = (data: ExampleType) =&gt; {
  if (!data.pets) return false;
  // perform more checks

  return true;
};

const getBiped = async () =&gt; {
  const data = await fetchData();
  console.log(data);
  // { name: 'John' }

  if (!validate(data))
    throw Error('Validation error: data is not complete ...');

  return data.pets.find(pet =&gt; pet.legs === 2);
};
</pre>
<p>如您所见，已经定义了一个新函数，名为<code>validate</code>，它接收一个<code>ExampleType</code>对象作为参数，用它来检查属性<code>pets</code>是否已定义。如果不是，它将返回<code>false</code>，这将最终抛出一个带有描述消息的错误。否则，它将继续执行，现在，当评估<code>data.pets.find</code>时，它不会抛出一个错误。</p>
<p>请注意，<code>validate</code>函数的实现非常简单，并且还有进行更多检查的空间，例如:</p>
<ul>
<li><code>name</code>应该存在</li>
<li><code>name</code>应该是一个<code>string</code></li>
<li>如果<code>age</code>存在，应该是一个<code>number</code></li>
<li><code>pets</code>应该是<code>objects</code>的一个<code>array</code></li>
<li>每个<code>pet</code>物体都应该有道具<code>name</code>和<code>legs</code></li>
</ul>
<p>您添加的检查越多，您的应用程序就越健壮——但是您也需要投入更多的时间。</p>
<p>这种方法的优点是:</p>
<ul>
<li><strong>不需要外部库</strong>:只需要纯打字稿</li>
<li><strong>以业务为中心的</strong>:您可以在这些验证器中添加任何业务逻辑。例如，如果<code>propertyB</code>存在，您可以检查<code>propertyA</code>不应该存在</li>
</ul>
<p>它也存在一些缺点:</p>
<ul>
<li><strong>手工工作</strong>:每个验证都必须手工编码，这可能非常耗时</li>
<li><strong>代码重复</strong>:在本例中，<code>ExampleType</code>已经定义了有一个<code>pets</code>属性，并且是必需的。但是同样，在验证代码中，您仍然应该检查它是否为真</li>
<li><strong>漏洞空间</strong>:在之前的代码中，有很多“漏洞”或需要改进的地方</li>
</ul>
<h2>使用验证库</h2>
<p>为什么要重新发明轮子，对吗？这种方法包括使用任何验证库来断言对象的结构。列举一些最常用的库:</p>

<p>本文使用的验证库是<code>ajv</code>；然而，所有的结论也适用于其他图书馆。</p>
<pre>const Ajv = require('ajv');
const ajv = new Ajv();

const validate = ajv.compile({
  properties: {
    name: {
      type: 'string',
      minLength: 3,
    },
    age: { type: 'number' },
    pets: {
      type: 'array',
      items: {
        name: {
          type: 'string',
          minLength: 3,
        },
        legs: { type: 'number' },
      },
    },
  },
  required: ['name', 'pets'],
  type: 'object',
});

const getBiped = async () =&gt; {
  const data = await fetchData();
  console.log(data);
  // { name: 'John' }
  if (!validate(data)) {
    throw Error('Validation failed: ' + ajv.errorsText(validate.errors));
    // Error: Validation failed: data should have required property 'pets'
  }

  return data.pets.find(pet =&gt; pet.legs === 2);
};
</pre>
<p>许多验证库强迫您定义一个<code>schema</code>，您可以在其中描述要评估的结构。给定该模式，您可以创建将在您的代码中使用的验证函数。</p>
<p>您的架构声明将始终取决于您正在使用的库；因此，我总是建议查看官方文件。在<code>ajv</code>的情况下，它强迫你在一个对象样式中声明，其中每个属性必须提供它的<code>type</code>。也可以为这些值设置自定义检查器，比如为任何<code>array</code>或<code>string</code>设置<code>minLength</code>。</p>
<p>该方法提供:</p>
<ul>
<li><strong>创建验证器和检查</strong>的标准化方法:<code>schema</code>背后的想法是只有一种方法来检查应用程序内部的特定条件——特别是在JavaScript中，有许多方法可以完成相同的任务，例如检查数组的<code>length</code>。这种品质对于改善团队内部的沟通和协作非常重要</li>
<li><strong>错误报告的改进</strong>:如果某个属性不匹配，库会以一种人性化的方式通知你是哪一个，而不仅仅是打印堆栈跟踪</li>
</ul>
<p>这种创建验证的新方法存在以下缺点:</p>
<ul>
<li><strong>引入新语法</strong>:当一个团队决定添加一个新的库时，理解整个代码库变得更加困难。每个贡献者都必须了解验证器模式，才能理解如何对它进行修改</li>
<li><strong>验证器和类型不同步</strong>:对<code>schema</code>和<code>ExampleType</code>的定义是断开的，这意味着每次你在<code>ExampleType</code>内部做了更改，你都要手动地在<code>schema</code>内部反映出来。根据您拥有的验证器的数量，这个任务可能会非常乏味</li>
</ul>
<p>关于保持验证器和类型同步的一个小评论:一些开源项目解决了这个问题，例如<a href="https://www.npmjs.com/package/json-schema-to-typescript">JSON-schema-to-typescript</a>，它可以从现有的模式生成类型定义。那这个就不算问题了。</p>
<h2>动态类型验证器</h2>
<p>这就是我想谈论的方法，它代表了关于如何创建验证器和保持类型同步的范式的变化。</p>
<p>在另外两个方法中，验证器和类型可以被视为不同的实体:验证器将接受传入的对象并检查其属性，而类型静态地属于该对象。结合这两个实体，结果是一个经过验证的类型对象。</p>
<p>动态类型验证允许类型从其定义中生成验证器。现在它们是相关的——验证器完全依赖于类型，防止了结构之间的任何不匹配。</p>
<h3>验证器的生成</h3>
<p>为了生成这些验证器，我找到了一个叫做<code><a href="https://github.com/ForbesLindesay/typescript-json-validator">typescript-json-validator</a></code>的惊人的开源项目，由<a href="https://twitter.com/ForbesLindesay"> @ForbesLindesay </a>制作。repo描述声明其目标是“使用JSON模式和AJV为任何TypeScript类型自动生成验证器”</p>
<p>对于测试，让我们重用<code>ExampleType</code>定义，它现在已经被移动到<code>types</code>文件夹中的一个单独的文件中。</p>
<pre>// src/types/ExampleType.ts

type ExampleType = {
  name: string;
  age?: number;
  pets: {
    name: string;
    legs: number;
  }[];
};
</pre>
<p>这个库公开了一个方便的CLI，可以从任何地方调用，给定一个文件路径和类型名称，它将在与文件相同的位置生成一个带有验证器代码的新文件。</p><div class="code-block code-block-54">
<hr/>
<h3>更多来自LogRocket的精彩文章:</h3>

<hr/></div>
<pre>&gt; npx typescript-json-validator src/types/ExampleType.ts ExampleType
# ExampleType.validator.ts created!
</pre>
<p>得到的验证器可能是一个很长的文件，所以让我们一点一点地看一下。</p>
<h3>1.创建<code>ajv</code>实例</h3>
<p>它还为<code>ajv</code>设置了一些默认配置。</p>
<pre>/* tslint:disable */
// generated by typescript-json-validator
import { inspect } from 'util';
import Ajv = require('ajv');
import ExampleType from './ExampleType';

export const ajv = new Ajv({
  allErrors: true,
  coerceTypes: false,
  format: 'fast',
  nullable: true,
  unicode: true,
  uniqueItems: true,
  useDefaults: true,
});

ajv.addMetaSchema(require('ajv/lib/refs/json-schema-draft-06.json'));

export { ExampleType };
</pre>
<h3>2.<code>schema</code>由下式定义</h3>
<p>这是这种方法的关键。</p>
<pre>// Definition of Schema
export const ExampleTypeSchema = {
  $schema: 'http://json-schema.org/draft-07/schema#',
  defaultProperties: [],
  properties: {
    age: {
      type: 'number',
    },
    name: {
      type: 'string',
    },
    pets: {
      items: {
        defaultProperties: [],
        properties: {
          legs: {
            type: 'number',
          },
          name: {
            type: 'string',
          },
        },
        required: ['legs', 'name'],
        type: 'object',
      },
      type: 'array',
    },
  },
  required: ['name', 'pets'],
  type: 'object',
};
</pre>
<h3>3.使用生成的<code>schema</code>导出验证函数</h3>
<p>它还负责在出现错误时抛出异常。</p>
<pre>export type ValidateFunction&lt;T&gt; = ((data: unknown) =&gt; data is T) &amp;
  Pick&lt;Ajv.ValidateFunction, 'errors'&gt;;
export const isExampleType = ajv.compile(ExampleTypeSchema) as ValidateFunction&lt;
  ExampleType
&gt;;

export default function validate(value: unknown): ExampleType {
  if (isExampleType(value)) {
    return value;
  } else {
    throw new Error(
      ajv.errorsText(
        isExampleType.errors!.filter((e: any) =&gt; e.keyword !== 'if'),
        { dataVar: 'ExampleType' },
      ) +
        '\n\n' +
        inspect(value),
    );
  }
}
</pre>
<p>要使用验证器，您只需要从各自的路径导入并调用它。请注意，该函数已经在检查对象内部是否有任何错误；因此，没有必要在这里添加一个<code>if</code>语句，使代码更加简洁。</p>
<pre>import validate from 'src/types/ExampleType.validator';

const getBiped = async () =&gt; {
  const data = validate(await fetchData());

  return data.pets.find(pet =&gt; pet.legs === 2);
};
</pre>
<h3>打字稿❤️ <code>ajv</code></h3>
<p>这个库使用<code>ajv</code>来创建验证器函数，这意味着您可以利用它提供的所有优秀特性，比如类型的自定义验证。</p>
<p>让我们为<code>ExampleType</code>创建一个新的定义类型。</p>
<pre>interface ExampleType {
  /**
   * @format email
   */
  email?: string;
  /**
   * @minimum 0
   * @maximum 100
   */
  answer: number;
}
</pre>
<p>在每个属性的上方，你会发现一些注释在注释括号内。当库生成最终模式时，这些将被翻译成<code>ajv</code>规则。这是结果:</p>
<pre>export const ExampleTypeSchema = {
  $schema: 'http://json-schema.org/draft-07/schema#',
  defaultProperties: [],
  properties: {
    answer: {
      maximum: 100,
      minimum: 0,
      type: 'number',
    },
    email: {
      format: 'email',
      type: 'string',
    },
  },
  required: ['answer'],
  type: 'object',
};
</pre>
<p>属性<code>answer</code>现在提供了另外两个属性来检查<code>number</code>是否在0和100之间。在<code>email</code>的情况下，它将检查<code>string</code>值是否属于有效的电子邮件地址。</p>
<p>因为这些注释被包装在注释中，所以它们不会与TypeScript编译器发生任何冲突。</p>
<h2>让它成为你工作流程的一部分</h2>
<p>这种方法基于这样的想法，即开发人员将运行CLI命令并生成验证器；否则，有可能该模式是用该类型的旧版本生成的，这可能会导致不匹配。</p>
<p>修复这个问题非常简单:您只需添加一个脚本，该脚本将在您的代码运行之前执行。你可以称它为<code>prebuild</code>或<code>prestart</code>，这就是你的<code>package.json</code>可能的样子:</p>
<pre>{
  "scripts": {
    "prebuild": "typescript-json-validator src/types/ExampleType.ts ExampleType",
    "start": "yarn prebuild &amp;&amp; ts-node start.ts",
    "build": "yarn prebuild &amp;&amp; tsc"
  }
}
</pre>
<p>最后一个建议:忽略项目中的任何<code>validator.ts</code>文件。将这些文件提交到您的存储库中是没有意义的，因为它们将在您每次启动项目时生成。</p>
<h2>我使用这种方法的经验🙋‍♂️</h2>
<p>大约两个月前，我开源了我的一个副业项目<code><a href="https://github.com/EmaSuriano/gatsby-starter-linkedin-resume">gatsby-starter-linkedin-resume</a></code>。</p>
<p>总之，这是一个<a href="https://www.gatsbyjs.org/docs/starters/"> Gatsby starter </a>，它可以使用<a href="https://github.com/linkedtales/scrapedin"> LinkedIn爬虫</a>从LinkedIn检索你的信息，并使用<a href="https://jsonresume.org/"> JSON Resume </a>从中生成HTML和PDF简历。</p>
<p>该项目呈现两个主要流程:</p>
<ol>
<li>创建简历信息:您将被要求输入您的链接凭据，然后一个爬虫将打开一个新的浏览器，读取您的配置文件值，最后将所有这些信息保存在您目录下的一个JSON文件中。之后，项目将把从爬虫中提取的数据转换成Json Resume的结构。</li>
<li>构建项目:一旦简历信息得到处理，Gatsby就可以用它生成HTML和PDF。</li>
</ol>
<p>在本文的开始，我提到验证您的外部资源是明智的。对于这个项目，它们是:</p>
<ol>
<li>来自LinkedIn爬虫的数据:当与爬虫打交道时，你应该总是非常小心他们的结果，因为它与他们获取数据的网站高度相关。在网站发生变化的情况下，来自爬虫的输出可以被改变。</li>
<li><strong>包含简历信息的本地文件</strong>:该项目允许您手动更改简历内容，以防您想跳过简历信息的创建而自己创建。如果简历数据的结构错误，JSON Resume将无法正确生成简历。</li>
</ol>
<p>以下是每种情况的类型定义:</p>
<pre>interface LinkedInSchema {
  contact: ContactItem[];
  profile: ProfileData;
  positions: LinkedInPosition[];
  educations: LinkedInEducation[];
  skills: Skill[];
  courses: Course[];
  languages: LinkedInLanguage[];
  projects: LinkedInProject[];
}

interface JsonResumeSchema {
  basics: JsonResumeBasics;
  work: JsonResumeWork[];
  volunteer?: JsonResumeVolunteer[];
  education: JsonResumeEducation[];
  awards?: JsonResumeAward[];
  publications?: JsonResumePublication[];
  skills?: JsonResumeSkill[];
  languages?: JsonResumeLanguage[];
  interests?: JsonResumeInterest[];
  references?: JsonResumeReference[];
  projects?: JsonResumeProject[];
}
</pre>
<p>这两种类型在变量名方面有相似之处，但它们的内部结构不同。这就是为什么有必要在第一个流中从一个结构转换到另一个结构。</p>
<p>在我设置我的项目从这些类型生成验证器之后，检查传入对象的结构是一件非常容易的任务。</p>
<h3>爬虫结果的验证</h3>
<pre>// src/index.ts
import { RESUME_PATH, LINKED_IN_PATH } from './utils/path';
import validateLinkedInSchema from './types/LinkedInSchema.validator';
import { saveJson, readJson } from './utils/file';
import { inquireLoginData, getLinkedInData } from './utils/linkedin';

// ❗️❗️ IMPORT OF THE VALIDATOR  ❗️❗️
import mapLinkedInToJSONResume from './utils/mapLinkedInToJSONResume';

export const main = async ({ renew }) =&gt; {
  if (renew || !readJson(LINKED_IN_PATH)) {
    const credentials = await inquireLoginData();
    const linkedInData = await getLinkedInData(credentials);

    saveJson(LINKED_IN_PATH, linkedInData);
  }

  // ❗️❗️ VALIDATION IN ACTION ❗️❗️
  const linkedInParsed = validateLinkedInSchema(readJson(LINKED_IN_PATH));

  const jsonResumeData = mapLinkedInToJSONResume(linkedInParsed);
  saveJson(RESUME_PATH, jsonResumeData);
};
</pre>
<h3>简历信息的验证</h3>
<pre>// gatsby-config.js
const { existsSync } = require('fs');

// ❗️❗️ IMPORT OF THE VALIDATOR  ❗️❗️
const {
  default: validateJsonResume,
} = require('./lib/types/JsonResumeSchema.validator');

if (!existsSync('./resume.json')) {
  throw new Error(
    'Please run "yarn generate-resume" to generate your resume information.',
  );
}

// ❗️❗️ VALIDATION IN ACTION ❗️❗️
const resumeJson = validateJsonResume(require('./resume.json'));

module.exports = {
  plugins: [
    {
      resolve: 'gatsby-theme-jsonresume',
      options: {
        resumeJson,
      },
    },
    'gatsby-plugin-meta-redirect',
  ],
};
</pre>
<h2>结束语🗣</h2>
<p>总而言之，我创建了这个表来比较这三种方法。动态类型方法吸取了其他方法的优点，是验证对象的推荐方法。</p>
<table>
<tbody>
<tr>
<td><strong>接近</strong></td>
<td><strong>没有附加语法</strong></td>
<td><strong>验证器和类型同步</strong></td>
<td><strong>标准化</strong></td>
</tr>
<tr>
<td>指南</td>
<td>✅</td>
<td>❌</td>
<td>❌</td>
</tr>
<tr>
<td>图书馆</td>
<td>❌</td>
<td>❓</td>
<td>✅</td>
</tr>
<tr>
<td>Dynamic types</td>
<td>✅</td>
<td>✅</td>
<td>✅</td>
</tr>
</tbody>
</table>
<p>如果您正在使用TypeScript代码库，我建议您尝试一下这种验证对象的新方法。它很容易设置，如果你发现它没有用，从代码库中删除它就像从你的文件中删除一个<code>import</code>一样简单。</p><div class="code-block code-block-21">
<div class="blog-plug inline-plug typescript-plug"><h2><a class="signup" href="https://lp.logrocket.com/blg/typescript-signup" target="_blank" rel="noopener noreferrer"> LogRocket </a>:全面了解您的网络和移动应用</h2>
<a href="https://lp.logrocket.com/blg/typescript-signup" class="signup" target="_blank" rel="noopener noreferrer"><img class="alignnone size-full wp-image-46 jetpack-lazy-image" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/><noscript><img data-lazy-fallback="1" class="alignnone size-full wp-image-46" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/></noscript></a>
<p>LogRocket 是一个前端应用程序监控解决方案，可以让您回放问题，就像问题发生在您自己的浏览器中一样。LogRocket不需要猜测错误发生的原因，也不需要向用户询问截图和日志转储，而是让您重放会话以快速了解哪里出错了。它可以与任何应用程序完美配合，不管是什么框架，并且有插件可以记录来自Redux、Vuex和@ngrx/store的额外上下文。</p>
<p>除了记录Redux操作和状态，LogRocket还记录控制台日志、JavaScript错误、堆栈跟踪、带有头+正文的网络请求/响应、浏览器元数据和自定义日志。它还使用DOM来记录页面上的HTML和CSS，甚至为最复杂的单页面和移动应用程序重新创建像素级完美视频。</p>
<a class="signup" href="https://lp.logrocket.com/blg/typescript-signup" target="_blank" rel="noopener noreferrer">Try it for free</a><p>.</p></div>
</div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
<html>
<head>
<title>How to use React Context with TypeScript - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>如何在TypeScript - LogRocket博客中使用React上下文</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/how-to-use-react-context-typescript/#0001-01-01">https://blog.logrocket.com/how-to-use-react-context-typescript/#0001-01-01</a></blockquote><div><article class="article-post">
<p><strong> <em>编者按</em> </strong> <em>:本帖于2022年2月15日更新，增加了一个主题化示例，改进并更新了对React上下文API的引用，并删除了过时的信息。</em></p>
<p>在对代码进行了大量改进和添加之后，如健壮的静态类型检查、可理解性和类型推断，TypeScript变得越来越受欢迎。当TypeScript与React一起使用时，它提供了改进的开发人员体验和项目的更多可预测性。</p>
<p>在本指南中，我们将通过从头构建一个待办事项应用程序来学习如何在React上下文中使用TypeScript。为了充分利用本教程，您需要<a href="https://blog.logrocket.com/using-typescript-with-react-tutorial-examples/" target="_blank" rel="noopener">对React和TypeScript </a>有一个基本的了解。</p>
<p>在本帖中，我们将讨论:</p>

<p>让我们开始吧。</p>
<h2 id="what-is-react-context-api">什么是React上下文API？</h2>
<p>React Context API是在React v16中引入的，作为一种在组件树中<a href="https://blog.logrocket.com/solving-prop-drilling-react-apps/" target="_blank" rel="noopener">共享数据的方式，而不需要在每一层向下传递属性。</a></p>
<p>对于被认为是“全局的”但对于Redux或MobX这样的专用状态管理器来说不够大或不够复杂的数据，如用户的当前语言、当前主题，甚至是发送到API之前来自多步表单的数据，上下文API是理想的选择。</p>
<h2 id="setting-up-app">设置应用程序</h2>
<p>为了演示React Context，我们将构建一个待办事项应用程序，它使用Context API来管理列表上的任务以及主题化。</p>
<p>我们将使用<a href="https://create-react-app.dev/" target="_blank" rel="noopener">创建React应用</a>以便拥有一个没有麻烦的现代配置，但是欢迎您使用<a href="https://webpack.js.org/" target="_blank" rel="noopener"> Webpack </a>从头开始设置一个新的应用。</p>
<p>首先打开您的终端并运行以下命令:</p>
<pre class="language-bash hljs">npx create-react-app react-context-todo --template typescript
</pre>
<p>要使用CRA轻松创建TypeScript项目，需要添加标志<code>--template typescript</code>，否则应用程序将只支持JavaScript。</p>
<p>接下来，让我们按如下方式构建项目:</p>
<pre class="language-plaintext hljs">src
├── @types
│   └── todo.d.ts
├── App.tsx
├── components
│   ├── AddTodo.tsx
│   └── Todo.tsx
├── containers
│   └── Todos.tsx
├── context
│   └── todoContext.tsx
├── index.tsx
├── react-app-env.d.ts
└── styles.css
</pre>
<p>这里，有两个文件需要加下划线:</p>
<ul>
<li><code>context/todoContext.tsx</code>文件，导出为待办功能创建的上下文，以及它的提供者</li>
<li>文件<code>@types</code>中的<code>todo.d.ts</code>包含应用程序中与待办事项列表实现相关的部分的类型定义</li>
</ul>
<p>拥有专用的类型定义文件是最佳实践，因为它改进了项目的结构。声明的类型既可以通过引用使用而不导入，也可以通过将它们显式导入到另一个文件中来使用(尽管它们必须先被导出)。理想情况下，我们希望导入类型，这样就不会污染全局名称空间。</p>
<p>有了这些，我们现在可以动手做一些有意义的事情了。</p>
<h2 id="create-to-do-type">创建待办事项类型</h2>
<p>TypeScript类型允许您定义变量或函数应该期望的值，以便帮助编译器在运行时之前捕捉错误。</p>
<pre class="language-typescript hljs">// @types.todo.ts
export interface ITodo {
  id: number;
  title: string;
  description: string;
  status: boolean;
}
export type TodoContextType = {
  todos: ITodo[];
  saveTodo: (todo: ITodo) =&gt; void;
  updateTodo: (id: number) =&gt; void;
};
</pre>
<p>正如你所看到的，接口<code>ITodo</code>定义了待办事项的形状。接下来，我们有类型<code>TodoContextType</code>,它需要一组待办事项和添加或更新待办事项的方法。</p>
<h2 id="create-context">创建上下文</h2>
<p>React Context允许您跨组件共享和管理状态，而无需传递属性。上下文将只向需要使用数据的组件提供数据。</p>
<pre class="language-typescript hljs">// context/todoContext.tsx
import * as React from 'react';
import { TodoContextType, ITodo } from '../@types/todo';

export const TodoContext = React.createContext&lt;TodoContextType | null&gt;(null);

const TodoProvider: React.FC&lt;React.ReactNode&gt; = ({ children }) =&gt; {
  const [todos, setTodos] = React.useState&lt;ITodo[]&gt;([
    {
      id: 1,
      title: 'post 1',
      description: 'this is a description',
      status: false,
    },
    {
      id: 2,
      title: 'post 2',
      description: 'this is a description',
      status: true,
    },
  ]);
</pre>
<p>这里，我们首先创建一个新的上下文，并将其类型设置为匹配<code>TodoContextType</code>或<code>null</code>。在创建上下文时，我们暂时将默认值设为<code>null</code>；预期值将在提供程序上分配。接下来，我们创建向组件消费者提供上下文的组件<code>TodoProvider</code>。在这里，我用一些数据初始化状态，让<code>todos</code>工作。</p>
<pre class="language-typescript hljs">// context/todoContext.tsx
const saveTodo = (todo: ITodo) =&gt; {
  const newTodo: ITodo = {
    id: Math.random(), // not really unique - but fine for this example
    title: todo.title,
    description: todo.description,
    status: false,
  }
  setTodos([...todos, newTodo])
}

const updateTodo = (id: number) =&gt; {
  todos.filter((todo: ITodo) =&gt; {
    if (todo.id === id) {
      todo.status = true
      setTodos([...todos])
    }
  })
}
</pre>
<p>函数<code>saveTodo</code>将基于接口<code>ITodo</code>创建一个新的待办事项，然后将该对象添加到待办事项数组中。下一个函数<code>updateTodo</code>将在待办事项数组中查找作为参数传递的待办事项id，然后更新它。</p>
<pre class="language-typescript hljs">// context/todoContext.tsx
 return (
    &lt;TodoContext.Provider value={{ todos, saveTodo, updateTodo }}&gt;
      {children}
    &lt;/TodoContext.Provider&gt;
  );
};

export default TodoProvider;
</pre>
<p>接下来，我们将这些值传递给上下文，使它们可供组件使用。</p>
<pre class="language-typescript hljs">// context/todoContext.tsx
import * as React from 'react';
import { TodoContextType, ITodo } from '../@types/todo';

export const TodoContext = React.createContext&lt;TodoContextType | null&gt;(null);

const TodoProvider: React.FC&lt;React.ReactNode&gt; = ({ children }) =&gt; {
  const [todos, setTodos] = React.useState&lt;ITodo[]&gt;([
    {
      id: 1,
      title: 'post 1',
      description: 'this is a description',
      status: false,
    },
    {
      id: 2,
      title: 'post 2',
      description: 'this is a description',
      status: true,
    },
  ]);
  const saveTodo = (todo: ITodo) =&gt; {
    const newTodo: ITodo = {
      id: Math.random(), // not really unique - but fine for this example
      title: todo.title,
      description: todo.description,
      status: false,
    };
    setTodos([...todos, newTodo]);
  };
  const updateTodo = (id: number) =&gt; {
    todos.filter((todo: ITodo) =&gt; {
      if (todo.id === id) {
        todo.status = true;
        setTodos([...todos]);
      }
    });
  };
  return &lt;TodoContext.Provider value={{ todos, saveTodo, updateTodo }}&gt;{children}&lt;/TodoContext.Provider&gt;;
};

export default TodoProvider;
</pre>
<p>有了这个，我们现在能够使用上下文了。因此，让我们在下一节中创建组件。</p>
<h2 id="create-components-consume-context">创建组件并使用上下文</h2>
<p>下面，我们有一个表单组件，它允许我们处理用户使用<code>useState</code>钩子输入的数据。一旦我们获得了表单数据，我们就使用从上下文对象中提取的函数<code>saveTodo</code>来添加一个新的待办事项。</p>
<pre class="language-typescript hljs">// components/AddTodo.tsx
import * as React from 'react';
import { TodoContext } from '../context/todoContext';
import { TodoContextType, ITodo } from '../@types/todo';

const AddTodo: React.FC = () =&gt; {
  const { saveTodo } = React.useContext(TodoContext) as TodoContextType;
  const [formData, setFormData] = React.useState&lt;ITodo | {}&gt;();
  const handleForm = (e: React.FormEvent&lt;HTMLInputElement&gt;): void =&gt; {
    setFormData({
      ...formData,
      [e.currentTarget.id]: e.currentTarget.value,
    });
  };
  const handleSaveTodo = (e: React.FormEvent, formData: ITodo | any) =&gt; {
    e.preventDefault();
    saveTodo(formData);
  };
  return (
    &lt;form className="Form" onSubmit={(e) =&gt; handleSaveTodo(e, formData)}&gt;
      &lt;div&gt;
        &lt;div&gt;
          &lt;label htmlFor="name"&gt;Title&lt;/label&gt;
          &lt;input onChange={handleForm} type="text" id="title" /&gt;
        &lt;/div&gt;
        &lt;div&gt;
          &lt;label htmlFor="description"&gt;Description&lt;/label&gt;
          &lt;input onChange={handleForm} type="text" id="description" /&gt;
        &lt;/div&gt;
      &lt;/div&gt;
      &lt;button disabled={formData === undefined ? true : false}&gt;Add Todo&lt;/button&gt;
    &lt;/form&gt;
  );
};
export default AddTodo;
</pre>
<p>注意，我在<code>useContext</code>钩子上使用类型转换来防止TypeScript抛出错误，因为上下文在开始时将是<code>null</code>。</p>
<pre class="language-typescript hljs">// components/Todo.tsx
import * as React from 'react';
import { ITodo } from '../@types/todo';

type Props = {
  todo: ITodo;
  updateTodo: (id: number) =&gt; void;
};

const Todo: React.FC&lt;Props&gt; = ({ todo, updateTodo }) =&gt; {
  const checkTodo: string = todo.status ? `line-through` : '';
  return (
    &lt;div className="Card"&gt;
      &lt;div className="Card--text"&gt;
        &lt;h1 className={checkTodo}&gt;{todo.title}&lt;/h1&gt;
        &lt;span className={checkTodo}&gt;{todo.description}&lt;/span&gt;
      &lt;/div&gt;
      &lt;button onClick={() =&gt; updateTodo(todo.id)} className={todo.status ? `hide-button` : 'Card--button'}&gt;
        Complete
      &lt;/button&gt;
    &lt;/div&gt;
  );
};
export default Todo;
</pre>
<p>正如您在这里看到的，我们有一个显示单个待办事项的表示组件。它接收<code>todo</code>对象和更新它的函数，作为需要匹配上面定义的<code>Props</code>类型的参数。</p><div class="code-block code-block-54">
<hr/>
<h3>更多来自LogRocket的精彩文章:</h3>

<hr/></div>
<pre class="language-typescript hljs">// containers/Todos.tsx
import * as React from 'react';
import { TodoContextType, ITodo } from '../@types/todo';
import { TodoContext } from '../context/todoContext';
import Todo from '../components/Todo';

const Todos = () =&gt; {
  const { todos, updateTodo } = React.useContext(TodoContext) as TodoContextType;
  return (
    &lt;&gt;
      {todos.map((todo: ITodo) =&gt; (
        &lt;Todo key={todo.id} updateTodo={updateTodo} todo={todo} /&gt;
      ))}
    &lt;/&gt;
  );
};

export default Todos;
</pre>
<p>该组件在页面加载时显示待办事项列表。它从待办事项上下文中提取<code>todos</code>和函数<code>updateTodo</code>。接下来，我们遍历数组，将想要显示的对象传递给<code>Todo</code>组件。</p>
<p>随着这一步的推进，我们现在能够在<code>App.tsx</code>文件中提供待办事项上下文来完成应用程序的构建。因此，让我们在下一部分使用上下文提供者。</p>
<h2 id="provide-context">提供背景</h2>
<pre class="language-typescript hljs">// App.tsx
import * as React from 'react'
import TodoProvider from './context/todoContext'
import Todos from './containers/Todos'
import AddTodo from './components/AddTodo'
import './styles.css'

export default function App() {
  return (
    &lt;TodoProvider&gt;
      &lt;main className='App'&gt;
        &lt;h1&gt;My Todos&lt;/h1&gt;
        &lt;AddTodo /&gt;
        &lt;Todos /&gt;
      &lt;/main&gt;
    &lt;/TodoProvider&gt;
  )
}
</pre>
<p>在这里，我们导入了包装待办事项上下文消费者的<code>TodoProvider</code>组件。也就是说，我们现在可以使用其他组件中的<code>useContext</code>钩子访问<code>todos</code>数组和函数来添加或更新待办事项。</p>
<p>这样，我们现在可以在终端上打开项目并运行以下命令:</p>
<pre class="language-bash hljs">  yarn start
</pre>
<p>或者</p>
<pre class="language-bash hljs">  npm start
</pre>
<p>如果一切正常，您将能够在浏览器中看到以下内容:</p>
<pre class="language-plaintext hljs">http://localhost:3000
</pre>
<p><img data-attachment-id="94708" data-permalink="https://blog.logrocket.com/how-to-use-react-context-typescript/to-do-provider-react-context/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/11/to-do-provider-react-context.png" data-orig-size="730,407" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="to-do-provider-react-context" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/11/to-do-provider-react-context-300x167.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/11/to-do-provider-react-context.png" decoding="async" class="aligncenter size-full wp-image-94708 jetpack-lazy-image" src="../Images/cd0b3eed37669567103be158ab255f9c.png" alt="The to-do provider we built" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2020/11/to-do-provider-react-context.png 730w, https://blog.logrocket.com/wp-content/uploads/2020/11/to-do-provider-react-context-300x167.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2020/11/to-do-provider-react-context.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/11/to-do-provider-react-context.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="94708" data-permalink="https://blog.logrocket.com/how-to-use-react-context-typescript/to-do-provider-react-context/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/11/to-do-provider-react-context.png" data-orig-size="730,407" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="to-do-provider-react-context" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/11/to-do-provider-react-context-300x167.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/11/to-do-provider-react-context.png" decoding="async" loading="lazy" class="aligncenter size-full wp-image-94708" src="../Images/cd0b3eed37669567103be158ab255f9c.png" alt="The to-do provider we built" srcset="https://blog.logrocket.com/wp-content/uploads/2020/11/to-do-provider-react-context.png 730w, https://blog.logrocket.com/wp-content/uploads/2020/11/to-do-provider-react-context-300x167.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/11/to-do-provider-react-context.png"/></noscript>
<h2 id="theming-with-context-api">使用上下文API进行主题化</h2>
<p>在这一节中，我们将再看一下上下文API的另一个应用:主题化。</p>
<pre class="language-typescript hljs">// @types/theme.d.ts
export type Theme = 'light' | 'dark';
export type ThemeContextType = {
  theme: Theme;
  changeTheme: (theme: Theme) =&gt; void;
};
};
</pre>
<p>我们创建了实现主题化所必需的类型:<code>Theme</code>指定了可能的主题模式，<code>ThemeContextType</code>指定了当我们使用主题时在主题上下文中可用的属性。</p>
<p>接下来，我们创建一个<code>themeContext.tsx</code>文件，导出原始主题上下文及其提供者。</p>
<pre class="language-typescript hljs">// context/themeContext.tsx
import * as React from 'react';
import { Theme, ThemeContextType } from '../@types/theme';

export const ThemeContext = React.createContext&lt;ThemeContextType | null&gt;(null);

const ThemeProvider: React.FC&lt;React.ReactNode&gt; = ({ children }) =&gt; {
  const [themeMode, setThemeMode] = React.useState&lt;Theme&gt;('light');
  return (
    &lt;ThemeContext.Provider value={{ theme: themeMode, changeTheme: setThemeMode }}&gt;
      {children}
    &lt;/ThemeContext.Provider&gt;
  );
};

export default ThemeProvider;
</pre>
<p>创建上下文后，我们创建一个<code>ThemeWrapper</code>组件，它既可以使用上下文，也可以在应用程序上切换主题。</p>
<pre class="language-typescript hljs">// components/ThemeWrapper.tsx
import React from 'react';
import { ThemeContextType, Theme } from '../@types/theme';
import { ThemeContext } from '../context/themeContext';

const ThemeWrapper: React.FC = ({ children }) =&gt; {
  const { theme, changeTheme } = React.useContext(ThemeContext) as ThemeContextType;
  const handleThemeChange = (event: React.ChangeEvent&lt;HTMLSelectElement&gt;) =&gt; {
    changeTheme(event.target.value as Theme);
  };

  return (
    &lt;div data-theme={theme}&gt;
      &lt;select name="toggleTheme" onChange={handleThemeChange}&gt;
        &lt;option value="light"&gt;Light&lt;/option&gt;
        &lt;option value="dark"&gt;Dark&lt;/option&gt;
      &lt;/select&gt;
      {children}
    &lt;/div&gt;
  );
};
export default ThemeWrapper;
</pre>
<p>准备好<code>ThemeWrapper</code>后，我们现在可以将其导入<code>App.tsx</code>并进行测试。</p>
<pre class="language-typescript hljs">// App.tsx
import * as React from 'react';
import TodoProvider from './context/todoContext';
import ThemeProvider from './context/themeContext';
import Todos from './containers/Todos';
import AddTodo from './components/AddTodo';
import ThemeWrapper from './components/ThemeWrapper';
import './styles.css';

export default function App() {
  return (
    &lt;ThemeProvider&gt;
      &lt;TodoProvider&gt;
        &lt;ThemeWrapper&gt;
          &lt;main className="App"&gt;
            &lt;h1&gt;My Todos&lt;/h1&gt;
            &lt;AddTodo /&gt;
            &lt;Todos /&gt;
          &lt;/main&gt;
        &lt;/ThemeWrapper&gt;
      &lt;/TodoProvider&gt;
    &lt;/ThemeProvider&gt;
  );
}
</pre>
<p><img data-attachment-id="94710" data-permalink="https://blog.logrocket.com/how-to-use-react-context-typescript/theming-react-context-example/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/11/theming-react-context-example.png" data-orig-size="730,400" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="theming-react-context-example" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/11/theming-react-context-example-300x164.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/11/theming-react-context-example.png" decoding="async" class="aligncenter size-full wp-image-94710 jetpack-lazy-image" src="../Images/4cd2176f0ce62398ea1624f759d115a8.png" alt="Example of theming with React Context" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2020/11/theming-react-context-example.png 730w, https://blog.logrocket.com/wp-content/uploads/2020/11/theming-react-context-example-300x164.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2020/11/theming-react-context-example.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/11/theming-react-context-example.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="94710" data-permalink="https://blog.logrocket.com/how-to-use-react-context-typescript/theming-react-context-example/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/11/theming-react-context-example.png" data-orig-size="730,400" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="theming-react-context-example" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/11/theming-react-context-example-300x164.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/11/theming-react-context-example.png" decoding="async" loading="lazy" class="aligncenter size-full wp-image-94710" src="../Images/4cd2176f0ce62398ea1624f759d115a8.png" alt="Example of theming with React Context" srcset="https://blog.logrocket.com/wp-content/uploads/2020/11/theming-react-context-example.png 730w, https://blog.logrocket.com/wp-content/uploads/2020/11/theming-react-context-example-300x164.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/11/theming-react-context-example.png"/></noscript>
<p>一旦select元素的change处理程序修改了<code>data-theme</code>属性，预先编写的CSS文件就会处理剩下的部分。</p>
<p>你可以在这里找到源代码<a href="https://codesandbox.io/s/react-context-typescript-vk41i7" target="_blank" rel="noopener">。</a></p>
<h2>结论</h2>
<p>TypeScript是一种很棒的语言，它使我们的代码变得更好。在本教程中，我们已经学习了如何在React上下文中使用TypeScript。希望这对你的下一个项目有所帮助。感谢阅读。</p><div class="code-block code-block-17">
<div class="blog-plug inline-plug react-plug" vwo-el-id="26283398190">
<h2 vwo-el-id="41600691720">使用LogRocket消除传统反应错误报告的噪音</h2>
<a href="https://lp.logrocket.com/blg/react-signup-issue-free" target="_blank" vwo-el-id="19356441070">LogRocket
</a><p>是一款React analytics解决方案，可保护您免受数百个误报错误警报的影响，只针对少数真正重要的项目。LogRocket告诉您React应用程序中实际影响用户的最具影响力的bug和UX问题。</p><a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="19356441380">
<img class="first-react-image alignnone size-full wp-image-46 jetpack-lazy-image jetpack-lazy-image--handled" src="../Images/f300c244a1a1cf916df8b4cb02bec6c6.png" vwo-el-id="18272717540" data-lazy-loaded="1" data-original-src="https://files.readme.io/27c94e7-Image_2017-06-05_at_9.46.04_PM.png"/>
</a>
<a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="19356441690">
<img class="second-react-image alignnone size-full wp-image-46 jetpack-lazy-image jetpack-lazy-image--handled" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" vwo-el-id="30720362350" data-lazy-loaded="1" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/>
</a>
<a href="https://lp.logrocket.com/blg/react-signup-issue-free" target="_blank" rel="noopener noreferrer" vwo-el-id="35866400580">LogRocket
</a><p>自动聚合客户端错误、反应错误边界、还原状态、缓慢的组件加载时间、JS异常、前端性能指标和用户交互。然后，LogRocket使用机器学习来通知您影响大多数用户的最具影响力的问题，并提供您修复它所需的上下文。</p><p vwo-el-id="28675661060">关注重要的React bug—<a class="signup" href="https://lp.logrocket.com/blg/react-signup-issue-free" target="_blank" rel="noopener noreferrer" vwo-el-id="40093418840">今天就试试LogRocket】。</a></p><div class="code-block code-block-21">
<div class="blog-plug inline-plug typescript-plug"><h2><a class="signup" href="https://lp.logrocket.com/blg/typescript-signup" target="_blank" rel="noopener noreferrer"> LogRocket </a>:全面了解您的网络和移动应用</h2>
<a href="https://lp.logrocket.com/blg/typescript-signup" class="signup" target="_blank" rel="noopener noreferrer"><img class="alignnone size-full wp-image-46 jetpack-lazy-image" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/><noscript><img data-lazy-fallback="1" class="alignnone size-full wp-image-46" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/></noscript></a>
<p>LogRocket 是一个前端应用程序监控解决方案，可以让您回放问题，就像问题发生在您自己的浏览器中一样。LogRocket不需要猜测错误发生的原因，也不需要向用户询问截图和日志转储，而是让您重放会话以快速了解哪里出错了。它可以与任何应用程序完美配合，不管是什么框架，并且有插件可以记录来自Redux、Vuex和@ngrx/store的额外上下文。</p>
<p>除了记录Redux操作和状态，LogRocket还记录控制台日志、JavaScript错误、堆栈跟踪、带有头+正文的网络请求/响应、浏览器元数据和自定义日志。它还使用DOM来记录页面上的HTML和CSS，甚至为最复杂的单页面和移动应用程序重新创建像素级完美视频。</p>
<a class="signup" href="https://lp.logrocket.com/blg/typescript-signup" target="_blank" rel="noopener noreferrer">Try it for free</a><p>.</p></div>
</div>
</div></div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
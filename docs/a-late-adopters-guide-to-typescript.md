# TypeScript 的后期采用者指南

> 原文：<https://blog.logrocket.com/a-late-adopters-guide-to-typescript/>

我职业生涯的大部分时间都在倡导 JavaScript。其动态特性所提供的灵活性使其成为快速原型开发和高质量产品软件的完美之选。我一直用它来制作简单的交互、单页应用程序、超快的 API 和易于理解的 shell 脚本——我从来没有认真考虑过它缺少类型。至少到目前为止。

老实说，我越来越失望于在我充满活力的小语言中不断出现的新类型拥护者——狂热的[Flow](https://flow.org/)爱好者和 TypeScript bros 每个人都在他们自己的夸夸其谈的争论中磕磕绊绊，这些争论涉及类型是如何成为未来，以及编写无类型 JavaScript 是如何不负责任和——嗯——愚蠢的。

这些花哨的类型系统倾向于为我们修复的所有错误都是任何人都能发现的错误。类型系统设置的保护措施是有限制的，是一种额外的痛苦，并且是对时间的全面浪费。对吗？

与此同时，支持 JavaScript 类型(尤其是 TypeScript)的人激增，这有点令人不快。他们中的许多人是我同意和尊重的人——我很少看到有人在一夜打字后回到普通的 JavaScript。这就像……一旦你打字了，你就会永远兴奋？

出于对科学的兴趣，我在我们正在构建的绿地设计系统中引入了 TypeScript。这看起来是一个很好的匹配——没有遗留下来的奇怪的东西要强制转换成类型系统，并且有大量很棒的 API 要创建。

今天，我非常喜欢打字稿。我是你所说的那些奇怪的，但是很棒的类型定义的后期采用者，人们一直在和我争论这些定义。如果你仍然不确定这些类型是否适合你，让我告诉你一些让我坠入爱河的原因。

## 基于 API 的开发

我总是着迷于我创建的代码的 API。这是我的代码向世界其他地方的展示。其他人会与我创建的接口进行交互，在实现它们之前，对我来说仔细考虑它们是很重要的。我的函数应该接受多少个参数？它们应该是什么样的？它应该返回什么？

以前，真的没有什么“强迫”我去考虑如何建模我的 API。它们通常是一路形成的。这种技术既有好的一面，也有不好的一面。

积极的一面是，我觉得在编码和重构 API 的过程中非常有效率。我写了很多代码，因为从开始到结束，我几次改变了我的想法和实现。在我改变方向之前，我通过写下它们并触及它们的局限性来测试不同的可能性。我想我绝对讨厌不能用 TypeScript 来做这件事。

事实证明，在开始实施工作之前仔细考虑事情是一项不可思议的练习，可以极大地提高工作质量。您的设计变得更加清晰，理解使用模式现在是一个先决条件，最终您会编写更少的代码。

因此，在开始实现之前，开始写出你的接口或类型——它提供的价值是惊人的。

## 图书馆的支持是惊人的

当转向 TypeScript 时，我最大的担心之一是 JavaScript 生态系统中缺少类型。事实证明，这在 2019 年根本不是问题。少数没有与类型定义捆绑在一起的包，通过社区管理的[definitely typed](http://definitelytyped.org/)type repository 可以很容易地获得它们。写的时候 6400 多！我甚至自己给[提供了一个 pull 请求](https://github.com/DefinitelyTyped/DefinitelyTyped/pull/40362)来修复我在那里发现的唯一一个 bug。

如果您正在使用某处没有提供其类型的东西，您可以编写自己的类型定义，或者干脆选择完全退出类型覆盖。这可能是你反过来做的事情——首先选择退出，然后编写你自己的本地类型，最后创建一个明确类型化的 pull 请求来帮助社区。

## TypeScript + modern React =😍

当我们谈到库支持时，我想强调一下 React。这是我每天写的东西，它与类型的互操作性绝对是我向类型过渡的成功因素。

以前，我在为所谓的高阶组件创建类型时遇到了一些麻烦。这些函数接受一个组件，并返回该组件的新版本，只是具有更多的功能。想到它们，我仍然不寒而栗。

幸运的是，hoc 在现代反应中是多余的。在引入钩子之后，像这样共享逻辑和行为已经变成了一个几乎微不足道的任务——甚至更容易为其编写好的类型定义。记住——定制钩子只是带有参数和返回值的函数——这些都很好并且是可键入的。

另一件事是类——由于继承和其他面向对象的特性，它们倾向于引入许多泛型和其他高级类型模式。老实说，我已经有一年没有编写新的类组件了——编写函数组件的类型和编写常规函数一样简单。

再加上 React 库中的这种优秀的类型定义和文档，您就有一个快乐的营员了。

## 更少的测试带来更多的价值

我一生中已经编写了大量的单元测试。在编写 React 时，我经常编写测试来确保我的组件在得到空值或未定义的值时不会崩溃和烧毁。有了 TypeScript，所有这些测试都将不复存在。

* * *

### 更多来自 LogRocket 的精彩文章:

* * *

由于所有这些测试现在都是可以在编译时检查的语言特性，您的反馈循环从几秒钟变成了一瞬间——这一改进对您的生产率产生了奇迹。

举个例子，用一套单元测试来检查你的函数是否能处理所有类型的输入。在 JavaScript 中，我们需要验证传递所有 falsy 类型(null、undefined、0，“”、NaN 和 false)以及所有真实但无效的类型的行为。我们需要以编程方式确保我们的代码处理各种奇怪的参数类型。但是，在 TypeScript 中，类型系统为我们提供了保证，即传递给我们函数的任何参数都是预先确定的类型。如果我们试图传递其他东西——甚至是几个文件——我们的代码将无法编译，我们也无法将代码发送给我们的用户。

此外，您最终编写的测试倾向于关注使用模式，而不是只有 QA 工程师才会考虑的繁琐的边缘情况。不是测试不可能的场景，而是为用户最终能做的事情编写测试用例。

## 保持简单

类型可能听起来令人生畏，对我来说也是如此。如果您深入到由 TypeScript“专家”创建的代码库，您通常会看到许多您从未听说过的高级泛型类型或特性。我在这里告诉你，你不必使用那些功能。

在我编写的大部分代码中，我只使用了常规类型别名，并指定了内置值或字符串等特定值。它像一个魔咒一样工作，对于任何类型的新手来说都是很好的可读性。当然，类型保护、继承和有区别的联合是你工具箱中很有效的东西——但是你不必使用任何你不熟悉的东西。坚持基础，应该没问题。

我想提到的另一件事是，你也不必用你的类型覆盖率从零到英雄。TypeScript 为您提供了类似 any 类型的输出，这使您可以在涉猎较浅的领域时保持代码中某些“复杂”的部分不被类型化。

## 安全重构和内联文档

我知道我会喜欢的开箱即用的特性是在编写代码时对安全重构和自动完成的改进支持。有了像 Visual Studio Code 或 IntelliJ IDEA 这样的现代编辑器，您可以获得大量优秀的工具来帮助您比以前更快地编写和重写代码——同时也更有信心。

另一个很酷的特性是，您可以轻松地添加代码注释，在您选择的编辑器中显示为内联文档。这肯定会帮助你未来的自己理解“normalizeInput”函数实际上是做什么的，而不必深入源代码。

## 增值，没有麻烦

在试用了大约六个月之后，我深深地爱上了将 TypeScript 添加到我的技术堆栈中所获得的附加值。我对自己的代码充满了信心，这让我能够在相同的时间内用更少的测试写出更好的代码。同时，它没有带来任何我认为会遇到的问题。

我希望这篇文章能让你尝试一下 TypeScript——如果你几年前尝试过的话——再试一次。这是对 JavaScript 的一个非常强大的补充，我再也不想离开它了——我打赌你也不会。

## [LogRocket](https://lp.logrocket.com/blg/typescript-signup) :全面了解您的网络和移动应用

[![LogRocket Dashboard Free Trial Banner](img/d6f5a5dd739296c1dd7aab3d5e77eeb9.png)](https://lp.logrocket.com/blg/typescript-signup)

LogRocket 是一个前端应用程序监控解决方案，可以让您回放问题，就像问题发生在您自己的浏览器中一样。LogRocket 不需要猜测错误发生的原因，也不需要向用户询问截图和日志转储，而是让您重放会话以快速了解哪里出错了。它可以与任何应用程序完美配合，不管是什么框架，并且有插件可以记录来自 Redux、Vuex 和@ngrx/store 的额外上下文。

除了记录 Redux 操作和状态，LogRocket 还记录控制台日志、JavaScript 错误、堆栈跟踪、带有头+正文的网络请求/响应、浏览器元数据和自定义日志。它还使用 DOM 来记录页面上的 HTML 和 CSS，甚至为最复杂的单页面和移动应用程序重新创建像素级完美视频。

[Try it for free](https://lp.logrocket.com/blg/typescript-signup)

.
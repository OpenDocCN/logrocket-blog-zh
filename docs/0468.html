<html>
<head>
<title>Use cases for Node workers - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>节点工作者的用例——log rocket博客</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/use-cases-for-node-workers/#0001-01-01">https://blog.logrocket.com/use-cases-for-node-workers/#0001-01-01</a></blockquote><div><article class="article-post">
<p>在过去，当构建需要<a href="https://en.wikipedia.org/wiki/Central_processing_unit" target="_blank" rel="noopener noreferrer"> CPU </a>密集计算的应用程序时，Node.js通常不是一个选项。这是由于它的非阻塞、事件驱动的I/O架构。随着Node.js中线程工作器的出现，有可能将其用于CPU密集型应用程序。在本文中，我们将研究Node.js应用程序中工作线程的某些用例。</p>
<p>在继续讨论Node.js中线程工作器的用例之前，让我们快速比较一下Node中I/O受限和CPU受限的情况。</p>
<h2>Node.js中的I/O限制与CPU限制</h2>
<h3>输入输出绑定</h3>
<p>如果资源的增加导致程序性能的提高，则称程序受资源约束。提高I/O子系统的速度(如内存、硬盘速度或网络连接)可以提高I/O绑定程序的性能。这是Node.js应用程序的典型情况，因为在继续执行代码或返回响应之前，事件循环通常会花费时间等待网络、文件系统甚至数据库I/O完成它们的操作。提高硬盘速度和/或网络连接通常会提高应用程序或程序的整体性能。</p>
<h3>CPU限制</h3>
<p>如果一个程序的处理时间因CPU的增加而减少，那么它就是CPU受限的。例如，计算文件哈希的程序在2.2GHz处理器上处理速度较快，在1.2GHz处理器上处理速度较慢</p>
<p>对于CPU受限的应用程序，大部分时间都花在使用CPU进行计算上。在Node.js中，受CPU限制的应用程序会阻塞事件，并导致其他请求被阻塞。</p>
<h4>Node.js黄金法则</h4>
<blockquote><p>不要阻塞事件循环，保持它运行，并避免任何可能阻塞类似线程的同步网络调用或无限循环的事情。</p></blockquote>
<p>Node在单线程事件循环中运行，使用非阻塞I/O调用，允许它同时支持同时运行的数万个计算，例如为多个传入的HTTP请求提供服务。只要在任何给定时间与每个客户机相关联的工作量很小，这种方法就很有效并且很快。但是如果您执行CPU密集型计算，您的并发Node.js服务器将嘎然而止。其他传入的请求将等待，因为一次只有一个请求得到服务。</p>
<p>Node.js中使用了某些策略来处理CPU密集型任务。多个进程(如<a href="https://nodejs.org/docs/latest-v10.x/api/cluster.html" target="_blank" rel="noopener noreferrer"> cluster API </a>)确保CPU得到最佳利用，子进程产生新的进程来处理阻塞任务。</p>
<p>这些策略是有利的，因为事件循环没有被阻塞，它还允许分离进程，所以如果一个进程出错，它不会影响其他进程。然而，由于子进程是独立运行的，它们不能相互共享内存，数据通信必须通过JSON，这就需要对数据进行序列化和反序列化。</p>
<p>Node.js中CPU密集型计算的最佳解决方案是在同一个进程中运行多个Node.js实例，这样可以共享内存，并且不需要通过JSON传递数据。这正是工作线程在Node.js中所做的。</p>
<p><img data-attachment-id="7124" data-permalink="https://blog.logrocket.com/use-cases-for-node-workers/singlethreadcode/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2019/09/singlethreadcode.jpg" data-orig-size="730,516" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="singlethreadcode" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2019/09/singlethreadcode-300x212.jpg" data-large-file="https://blog.logrocket.com/wp-content/uploads/2019/09/singlethreadcode.jpg" decoding="async" class="aligncenter wp-image-7124 size-full jetpack-lazy-image" src="../Images/d3cb75c305d361217186ecaf05cbb7a3.png" alt="worker threads display " data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2019/09/singlethreadcode.jpg 730w, https://blog.logrocket.com/wp-content/uploads/2019/09/singlethreadcode-300x212.jpg 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2019/09/singlethreadcode.jpg?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/09/singlethreadcode.jpg"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="7124" data-permalink="https://blog.logrocket.com/use-cases-for-node-workers/singlethreadcode/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2019/09/singlethreadcode.jpg" data-orig-size="730,516" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="singlethreadcode" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2019/09/singlethreadcode-300x212.jpg" data-large-file="https://blog.logrocket.com/wp-content/uploads/2019/09/singlethreadcode.jpg" decoding="async" loading="lazy" class="aligncenter wp-image-7124 size-full" src="../Images/d3cb75c305d361217186ecaf05cbb7a3.png" alt="worker threads display " srcset="https://blog.logrocket.com/wp-content/uploads/2019/09/singlethreadcode.jpg 730w, https://blog.logrocket.com/wp-content/uploads/2019/09/singlethreadcode-300x212.jpg 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/09/singlethreadcode.jpg"/></noscript>
<h2>可由线程工作器完成的真实世界的CPU密集型任务</h2>
<p>我们将查看Node.js应用程序中线程工作器的几个用例。我们不会查看线程工作器API，因为我们将只查看节点应用程序中线程工作器的用例。如果你不熟悉线程工作器，你可以访问这个<a href="https://blog.logrocket.com/a-complete-guide-to-threads-in-node-js-4fa3898fe74f/" target="_blank" rel="noopener noreferrer">帖子</a>开始学习如何使用线程工作器API。</p>
<h3>图像大小调整</h3>
<p>假设您正在构建一个允许用户上传个人资料图像的应用程序，然后您为应用程序中的各种用例生成多种大小(例如:100 x 100和64 x 64)的图像。调整图像大小的过程是CPU密集型的，并且必须调整成两种不同的大小也会增加CPU调整图像大小所花费的时间。调整图像大小的任务可以外包给一个单独的线程，而主线程处理其他轻量级任务。</p>
<pre>// worker.js
const { parentPort, workerData } =  require("worker_threads");
const  sharp  =  require("sharp");

async  function  resize() {

    const  outputPath  =  "public/images/" + Date.now() +  ".png";
    const { image, size } =  workerData;

    await  sharp(image)
    .resize(size, size, { fit:  "cover" })
    .toFile(outputPath);
 parentPort.postMessage(outputPath);
}
resize()</pre>
<pre>// mainThread.js
const { Worker } =  require("worker_threads");

module.exports  =  function  imageResizer(image, size) {

    return  new  Promise((resolve, reject) =&gt; {
    const  worker  =  new  Worker(__dirname  +    "/worker.js", {
workerData: { image, size }
});
    worker.on("message", resolve);
    worker.on("error", reject);
    worker.on("exit", code  =&gt; {
        if (code  !==  0)
            reject(new  Error(`Worker stopped with exit code ${code}`));
        });
    });
};</pre>
<p>主线程有一个方法，该方法创建一个调整每个图像大小的线程。它使用<code>workerData</code>属性将大小和图像传递给线程工作器。工人用<a href="https://www.npmjs.com/package/sharp" target="_blank" rel="noopener noreferrer"> sharp </a>调整图像大小，并将其发送回主线程。</p>
<h3>视频压缩</h3>
<p>视频压缩是另一项CPU密集型任务，可以外包给线程工作器。大多数视频流应用程序通常具有单个视频的多个变体，根据用户的网络连接显示给用户。线程工作者可以将视频压缩到各种大小。</p>
<p><a href="https://www.npmjs.com/package/fluent-ffmpeg" target="_blank" rel="noopener noreferrer"> <code>ffmpeg-fluet</code> </a>是Node.js应用中视频处理的常用模块。它依赖于<a href="https://ffmpeg.org/" target="_blank" rel="noopener noreferrer"> <code>ffmpeg</code> </a>这是一个完整的，跨平台的解决方案，以记录，转换和流媒体音频和视频。</p>
<p>由于每次需要使用新线程时都要创建工作线程，因此建议您创建一个工作线程池，以便在需要时使用，而不是匆忙创建工作线程。为了创建一个工作线程池，我们使用一个NPM模块<code><a href="https://www.npmjs.com/package/node-worker-threads-pool" target="_blank" rel="noopener noreferrer">node-worker-threads-pool</a></code>，它使用节点的worker_threads模块创建工作线程池。</p>
<pre>// worker.js
const { parentPort, workerData } =  require("worker_threads");
const  ffmpeg  =  require("fluent-ffmpeg");

function  resizeVideo({ inputPath, size, parentPort }) {
    const  outputPath  =  "public/videos/"  +  Date.now() +  size  +  ".mp4";
    ffmpeg(inputPath)
    .audioCodec("libmp3lame")
    .videoCodec("libx264")
    .size(size)
    .on("error", function(err) {
    console.log("An error occurred: "  +  err.message);
    })
    .on("end", function() {
    parentPort.postMessage(outputPath);
    })
    .save(outputPath);
}

parentPort.on("message", param  =&gt; {
    resizeVideo({ ...param, parentPort });
});
</pre>
<pre>// mainThread.js
const { StaticPool } =  require("node-worker-threads-pool");

  const  filePath  =  __dirname  +  "/worker.js";
  const  pool  =  new  StaticPool({
        size:  4,
        task:  filePath,
        workerData:  "workerData!"
    });

  const  videoSizes  = ["1920x1080", "1280x720",   "854x480", "640x360"];

module.exports  =  async  function compressVideo(inputPath) {
    const  compressedVideos  = [];
    videoSizes.forEach(async  size  =&gt; {
        const  video  =  await  pool.exec({ inputPath, size });
        compressedVideos.push(video);
    });
};</pre>
<h3>文件完整性</h3>
<p>假设你必须将你的文件存储在云存储中。您希望确保您存储的文件不会被任何第三方篡改。你可以通过使用一个<a href="https://www.lifewire.com/cryptographic-hash-function-2625832" target="_blank" rel="noopener noreferrer">加密散列算法</a>来计算该文件的散列值。您将这些散列及其存储位置保存在数据库中。当您下载文件时，您需要再次计算散列值，看看它们是否匹配。计算散列的过程是CPU密集型的，并且可以在线程工作器中完成:</p>
<pre>// hashing.js
const {
  Worker, isMainThread, parentPort, workerData
} = require('worker_threads');
const  crypto  =  require("crypto");
const  fs  =  require("fs");


if (isMainThread) {
  module.exports = async function hashFile(filePath) {
    return new Promise((resolve, reject) =&gt; {
      const worker = new Worker(__filename);
      worker.on('message', resolve);
      worker.on('error', reject);
      worker.on('exit', (code) =&gt; {
        if (code !== 0)
          reject(new Error(`Worker stopped with exit code ${code}`));
      });
      worker.postMessage(filePath)
    });
  };
} else {
    const  algorithm  =  "sha1";
    const  shasum  =  crypto.createHash(algorithm);
    const  stream  =  fs.ReadStream(filePath);
    stream.on("data", function(data) {
        shasum.update(data);
    });
    stream.on("end", function() {
        const  hash  =  shasum.digest("hex");
        parentPort.postMessage(hash);
    });
}</pre>
<p>注意，我们在同一个文件中既有工作线程代码又有主线程代码。线程工作器的<code>isMainThread</code>属性帮助我们确定当前线程并运行适合每个线程的代码。主线程创建一个新的工作线程，并侦听来自该工作线程的事件。工作线程使用名为<code>createHash</code>的Node.js <a href="https://nodejs.org/api/crypto.html" target="_blank" rel="noopener noreferrer"> crypto </a>方法计算数据流的哈希。</p>
<h2>结论</h2>
<p>当我们希望通过释放事件循环来提高性能时，Node.js线程工作器是一个很好的选择。需要注意的一点是，workers对于执行CPU密集型JavaScript操作非常有用。不要将它们用于I/O，因为Node.js用于异步执行操作的内置机制已经比工作线程更有效地处理了它。</p><div class="code-block code-block-23">
<div class="blog-plug inline-plug node-plug"><h2>200只<img src="../Images/61167b9d027ca73ed5aaf59a9ec31267.png" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2019/10/green-check.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" class=" jetpack-lazy-image" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/10/green-check.png"/> <noscript> <img data-lazy-fallback="1" src="../Images/61167b9d027ca73ed5aaf59a9ec31267.png" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/10/green-check.png"/> </noscript>显示器出现故障，生产中网络请求缓慢</h2><p>部署基于节点的web应用程序或网站是容易的部分。确保您的节点实例继续为您的应用程序提供资源是事情变得更加困难的地方。如果您对确保对后端或第三方服务的请求成功感兴趣，</p><a href="https://lp.logrocket.com/blg/node-signup" target="_blank">try LogRocket</a><p>. </p><a class="signup" href="https://lp.logrocket.com/blg/node-signup" target="_blank" rel="noopener noreferrer"><img src="../Images/cae72fd2a54c5f02a6398c4867894844.png" alt="LogRocket Network Request Monitoring" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2019/12/network-request-filter-2-1.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" class=" jetpack-lazy-image" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/12/network-request-filter-2-1.png"/><noscript><img data-lazy-fallback="1" src="../Images/cae72fd2a54c5f02a6398c4867894844.png" alt="LogRocket Network Request Monitoring" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/12/network-request-filter-2-1.png"/></noscript></a><a href="https://lp.logrocket.com/blg/node-signup" target="_blank" rel="noopener noreferrer">https://logrocket.com/signup/</a><p>LogRocket 就像是网络和移动应用程序的DVR，记录下用户与你的应用程序交互时发生的一切。您可以汇总并报告有问题的网络请求，以快速了解根本原因，而不是猜测问题发生的原因。</p><p>LogRocket检测您的应用程序以记录基线性能计时，如页面加载时间、到达第一个字节的时间、慢速网络请求，还记录Redux、NgRx和Vuex操作/状态。</p><a class="signup" href="https://lp.logrocket.com/blg/node-signup" target="_blank" rel="noopener noreferrer">Start monitoring for free</a><p>. </p></div>
</div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
<html>
<head>
<title>Comparing state machines: XState vs. Robot - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>比较状态机:XState与Robot - LogRocket博客</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/comparing-state-machines-xstate-vs-robot/#0001-01-01">https://blog.logrocket.com/comparing-state-machines-xstate-vs-robot/#0001-01-01</a></blockquote><div><article class="article-post">
<p>随着应用程序逻辑变得越来越复杂，在React中管理状态会变得很麻烦。Redux、Flux和MobX等第三方库有所帮助，但即使是这些工具也有自己的开销。</p>
<p><a href="https://en.wikipedia.org/wiki/Finite-state_machine" target="_blank" rel="noopener noreferrer">状态机</a>，也称为有限状态机或有限状态自动机，是计算的数学模型。它是一个抽象的机器，在任何给定的时间都有有限数量的<a href="https://en.wikipedia.org/wiki/State_(computer_science)" target="_blank" rel="noopener noreferrer">状态</a>。</p>
<p>在本指南中，我们将回顾两种状态机——x state和Robot——的相似性、差异、优缺点，并介绍如何使用它们来简化React应用程序中的状态管理。</p>
<h2 id="whystatemachines">为什么要使用状态机？</h2>
<p>状态是大多数前端应用程序的重要组成部分，尤其是在React中。可以把状态看作是应用程序中发生变化的部分的表示。</p>
<p>考虑一个从API获取数据的组件。</p>
<pre>const Todo = () =&gt; {
  const [data, setData] = useState([]);

  const handleClick = () =&gt; {
    fetch('https://jsonplaceholder.typicode.com/todos/1')
    .then(response =&gt; response.json())
    .then(todo =&gt; setData(data.push(todo))
    .catch(error =&gt; console.error(error) )
  }
  return(
    &lt;div&gt;
      &lt;button onClick={handleClick}&gt; Fetch Data &lt;/button&gt;
      {data &amp;&amp; data.map(todo =&gt; (&lt;p key={todo.id}&gt; {todo.title} &lt;span&gt; {todo.completed} &lt;/span&gt;&lt;/p&gt;) )}
    &lt;/div&gt;
  ); 
}
</pre>
<p>在这个例子中，数据是我们的状态，因为它是应用程序的一部分，在事件发生时会发生变化——在这个例子中，是单击按钮。这种设置的问题是它会变得复杂。</p>
<p>当用户等待获取记录时，或者在获取过程中发生错误时，会发生什么情况？我们需要增加更多的州来处理这些问题。</p>
<pre>const Todo = () =&gt; {
  const [isLoading, setIsLoading] = useState(false);
  const [data, setData] = useState([]);
  const [isError, setIsError] = useState(false);

  const handleClick = () =&gt; {
    setLoading(true);
    fetch('https://jsonplaceholder.typicode.com/todos/1')
      .then(response =&gt; response.json())
      .then(todo =&gt; {
        setLoading(false);
        setData(data.push(todo));
      })
      .catch(error =&gt; {
        setLoading(false);
        setIsError(true);
      })
  }
  return(
    &lt;div&gt;
      {loading &amp;&amp; &lt;p&gt; Loading Data... &lt;/p&gt;}
      &lt;button onClick={handleClick}&gt; Fetch Data &lt;/button&gt;
      {data &amp;&amp; data.map(todo =&gt; (&lt;p key={todo.id}&gt; {todo.title} &lt;span&gt; {todo.completed} &lt;/span&gt;&lt;/p&gt;) )}
      {error &amp;&amp; &lt;p&gt; An error occured. Try again.&lt;/p&gt;}
    &lt;/div&gt;
  ); 
} 
</pre>
<p>如果您的应用程序很复杂，随着新功能的增加，事情会很快失控，使您的代码难以理解、测试和增强。</p>
<p>状态机以不同的方式处理这个独特的问题。使用状态机，您可以定义我们的应用程序可能处于的所有状态、状态之间的转换以及可能出现的副作用。这有助于避免应用程序处于不可能的状态。</p>
<p><img data-attachment-id="21587" data-permalink="https://blog.logrocket.com/comparing-state-machines-xstate-vs-robot/state-diagram/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/07/state-diagram.png" data-orig-size="558,395" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="State diagram" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/07/state-diagram-300x212.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/07/state-diagram.png" decoding="async" class="aligncenter size-full wp-image-21587 jetpack-lazy-image" src="../Images/6fcacafa7caed2bf8037021465e4d7d8.png" alt="State Diagram" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2020/07/state-diagram.png 558w, https://blog.logrocket.com/wp-content/uploads/2020/07/state-diagram-300x212.png 300w" data-lazy-sizes="(max-width: 558px) 100vw, 558px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2020/07/state-diagram.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/07/state-diagram.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="21587" data-permalink="https://blog.logrocket.com/comparing-state-machines-xstate-vs-robot/state-diagram/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/07/state-diagram.png" data-orig-size="558,395" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="State diagram" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/07/state-diagram-300x212.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/07/state-diagram.png" decoding="async" loading="lazy" class="aligncenter size-full wp-image-21587" src="../Images/6fcacafa7caed2bf8037021465e4d7d8.png" alt="State Diagram" srcset="https://blog.logrocket.com/wp-content/uploads/2020/07/state-diagram.png 558w, https://blog.logrocket.com/wp-content/uploads/2020/07/state-diagram-300x212.png 300w" sizes="(max-width: 558px) 100vw, 558px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/07/state-diagram.png"/></noscript>
<p>我们的应用程序可以处于以下状态:</p>
<ol>
<li><code>ready</code> —应用程序启动时的初始状态</li>
<li><code>loading</code> —当事件发生时，即点击按钮时</li>
<li><code>success</code> —当负载解决时</li>
<li><code>error</code> —加载被拒绝时</li>
</ol>
<p>当一个动作被触发时，即当用户点击一个按钮时，应用程序从一种状态转换到另一种状态。当您可以预测应用程序可能处于的所有状态时，您就可以更好地控制应用程序。</p>
<h2 id="whatisxstate">XState和Robot是做什么的？</h2>
<p>根据其官方文档，XState是一个库，用于创建、解释和执行有限状态机和状态图，以及作为参与者管理这些机器的调用。它是由<a href="https://twitter.com/davidkpiano" target="_blank" rel="noopener noreferrer"> David Khourshid </a>创建的，用来解决用户界面中的状态问题。</p>
<p>Robot是一个轻量级的、功能性的、不可变的库，由Mathew Philips为构建有限状态机而创建。它的灵感来自于XState、Statecharts和P编程语言。</p>
<h2 id="prerequisites">先决条件</h2>
<p>要跟随本教程，您需要:</p>
<ul>
<li>JavaScript知识</li>
<li>反应的知识</li>
<li>yarn或npm v5.2或更高版本</li>
<li>节点版本10或更高版本</li>
</ul>
<h2 id="gettingstarted">入门指南</h2>
<p>为了演示XState和Robot之间的相似之处和不同之处，我们将创建一个从API获取数据的应用程序。</p>
<p>打开终端并初始化React应用程序。</p>
<pre>npx create-react-app state-machine
</pre>
<p>这将创建一个名为状态机的React应用程序。</p>
<p>接下来，创建一个从API获取数据的服务。</p>
<pre>cd src &amp;&amp; touch fetchTodo.js
</pre>
<p>上面的命令在<code>src</code>目录中创建了一个名为<code>fetchTodo.js</code>的文件。</p>
<p>打开文件并输入以下内容。</p>
<pre>export const fetchTodo = () =&gt; {
  return fetch('https://jsonplaceholder.typicode.com/todos/1')
    .then((response) =&gt; response.json())
    .then((todo) =&gt; todo);
};
</pre>
<p>基本上，无论何时调用<code>fetchTodo</code>函数，它都会返回从API中检索到的数据。</p>
<h2 id="installation">装置</h2>
<p>可以通过使用npm或yarn或者通过CDN嵌入脚本来安装XState。</p><div class="code-block code-block-54">
<hr/>
<h3>更多来自LogRocket的精彩文章:</h3>

<hr/></div>
<p>要使用npm安装库，请打开终端并运行:</p>
<pre>npm install xstate @xstate/react
</pre>
<p>这将安装<code>xstate</code>核心库和一个名为<code>@xstate/react</code>的React包，它允许您在React应用程序中使用定制的XState钩子。</p>
<p>您可以使用npm或yarn安装机器人，但不能使用CDN。</p>
<p>要安装Robot，请启动终端并运行以下命令。</p>
<pre>npm install robot3 react-robot
</pre>
<p>Robot还提供了一个在React中使用定制钩子的包，名为<code>react-robot</code></p>
<h2 id="creatingamachine">创建一台机器</h2>
<p>在使用状态机之前，您必须首先定义它。</p>
<p>在<code>src</code>目录中，创建一个名为<code>xstateMachine.js</code>的文件。将下面的代码复制到创建的文件中。</p>
<pre>import { Machine, assign } from 'xstate';
import { fetchTodo } from '../fetchTodo';
export const xstateMachine = Machine({
  id: 'clickButton',
  initial: 'ready',
  context: {
    todo: null,
  },
  states: {
    ready: {
      on: {
        CLICK: 'loading',
      },
    },
    loading: {
      invoke: {
        id: 'fetch-todo',
        src: fetchTodo,
        onDone: {
          target: 'success',
          actions: assign({
            todo: (context, event) =&gt; event.data,
          }),
        },
        onError: 'error',
      },
    },
    success: {
      on: {
        CLICK: 'loading',
      },
    },
    error: {
      on: {
        CLICK: 'loading',
      },
    },
  },
});
</pre>
<p>使用<code>Machine()</code>工厂功能定义机器。我们在上面的代码中定义的机器由id、状态、上下文、动作和转换组成。id用于标识状态节点。</p>
<p>机器中的状态有:</p>
<ul>
<li><code>ready</code></li>
<li><code>loading</code></li>
<li><code>success</code></li>
<li><code>error</code></li>
</ul>
<p>上下文是一种扩展状态，用于表示定量数据，如数字、任意字符串、对象等。应用程序的初始状态定义为<code>ready</code>。当点击一个按钮时，会发生一个转换，将状态从<code>ready</code>转移到<code>loading</code>。</p>
<p>在<code>loading</code>状态中，有一个<code>invoke</code>属性负责解析或拒绝承诺。每当<code>fetchTodo</code>承诺被解决时，<code>loading</code>状态转换到<code>success</code>状态，并且<code>assign</code>动作用从承诺获得的结果更新上下文。如果它被拒绝，它移动到<code>error</code>状态。</p>
<p>用机器人创造一台机器是相似的，尽管有一些关键的不同。一个主要的区别是，由于Robot是一个函数库，所以大多数操作都是使用函数来执行的，这与使用选项对象的XState不同。</p>
<p>在您的<code>src</code>目录中创建一个名为<code>robotMachine.js</code>的文件，并粘贴以下内容。</p>
<pre> import { createMachine, invoke, reduce, state, transition } from 'robot3';
import { fetchTodo } from '../fetchTodo';
const context = () =&gt; ({
  todo: {},
});
export const robotMachine = createMachine(
  {
    ready: state(transition('CLICK', 'loading')),
    loading: invoke(
      fetchTodo,
      transition(
        'done',
        'success',
        reduce((ctx, evt) =&gt; ({ ...ctx, todo: evt.data }))
      ),
      transition(
        'error',
        'error', 
        reduce((ctx, ev) =&gt; ({ ...ctx, error: ev.error }))
      )
    ),
    success: state(transition('CLICK', 'loading')),
    error: state(transition('CLICK', 'loading')),
  },
  context
);
</pre>
<p>在Robot中，使用接受一个对象的<code>createMachine</code>函数来创建机器。使用<code>state</code>函数定义一个状态，并且可以接受一个<code>transition</code>作为参数。</p>
<p>从一个状态转移到另一个状态是通过<code>transition</code>函数完成的，它接受事件和下一个状态作为参数。可选地，<code>reduce</code>函数可以作为第三个参数添加到<code>transition</code>中。Reduce函数将reducer函数作为参数，用于更新上下文。</p>
<p>Robot也有一个<code>invoke</code>函数，类似于XState中的<code>invoke</code>属性。当应用程序处于<code>loading</code>状态时，调用<code>invoke</code>函数。<code>invoke</code>函数是一种调用承诺并返回函数或另一台机器的状态。如果<code>invoke</code>函数解析了承诺，它将发送一个<code>done</code>事件。如果被拒绝，它会发送一个<code>error</code>事件。</p>
<h2 id="buildingourcomponent">构建组件</h2>
<p>现在我们的机器已经准备好了，下一步是构建一个将利用该机器的组件。</p>
<p>在您的<code>src</code>目录中为组件创建一个文件，并粘贴以下内容。</p>
<pre>import React from 'react';
import { useMachine } from '@xstate/react';
import { xstateMachine } from './stateMachine';

function Todo() {
  const [current, send] = useMachine(xstateMachine);
  const { todo } = current.context;
  return (
    &lt;div&gt;
      &lt;button onClick={() =&gt; send('CLICK')}&gt;Fetch Todo XState&lt;/button&gt;
      {current.matches('loading') &amp;&amp; &lt;p&gt;loading...&lt;/p&gt;}
      {current.matches('success') &amp;&amp; (
        &lt;p key={todo.id}&gt;
          {todo.title} &lt;span&gt; {todo.completed} &lt;/span&gt;
        &lt;/p&gt;
      )}
      {current.matches('error') &amp;&amp; &lt;p&gt;An error occured&lt;/p&gt;}
    &lt;/div&gt;
  );
}
export default Todo;
</pre>
<p>要使用机器，我们必须从<code>@xstate/react library</code>导入<code>useMachine</code>钩子，以及我们之前创建的机器。</p>
<p><code>useMachine</code>钩子是一个解释机器的React钩子。它负责在组件的整个生命周期中启动服务。</p>
<p><code>useMachine</code>钩子接受一个机器作为参数并返回一个数组。该数组包含<code>current</code>状态和<code>send</code>，后者是一个向由<code>useMachine</code>钩子创建的服务发送事件的函数。</p>
<p><code>current</code>状态是一个包含状态、上下文和一些实用函数的对象。要检查当前状态，使用<code>matches</code>属性，该属性返回一个布尔值。当用户单击按钮时，它会向服务发送一个事件。然后，它检查机器的当前状态，并根据状态呈现适当的UI。</p>
<p>机器人建造组件的方法也是类似的。用Robot构建的组件如下所示:</p>
<pre>import React from 'react';
import { useMachine } from 'react-robot';
import { robotMachine } from './robotMachine';

function Todo() {
  const [current, send] = useMachine(robotMachine);
  const { todo } = current.context;
  return (
    &lt;div&gt;
      &lt;button onClick={() =&gt; send('CLICK')}&gt;Fetch Todo Robot&lt;/button&gt;
      {current.name === 'loading' &amp;&amp; &lt;p&gt;loading...&lt;/p&gt;}
      {current.name === 'success' &amp;&amp; (
        &lt;p key={todo.id}&gt;
          {todo.title} &lt;span&gt; {todo.completed} &lt;/span&gt;
        &lt;/p&gt;
      )}
      {current.name === 'error' &amp;&amp; &lt;p&gt;An error occured&lt;/p&gt;}
    &lt;/div&gt;
  );
}
export default RobotTodo;
</pre>
<p>机器人还有一个<code>useMachine</code>钩子，可以通过导入<code>react-robot library</code>来访问。实现的不同之处在于比较状态的方式。XState使用<code>matches</code>属性，这是一个接受我们试图比较的字符串的函数，而Robot使用<code>name</code>属性在比较之前检查当前状态。</p>
<h2 id="conclusion">结论</h2>
<p>状态机为管理React应用程序中的状态提供了一种组织得更好的方式，并且与其他替代方案相比，它们易于扩展。XState和Robot是两个非常流行的库，虽然非常相似，但从非常不同的角度来处理机器。</p>
<p>本教程的资源库可以在<a href="https://github.com/sa-ma/xstate-robot-example/" target="_blank" rel="noopener noreferrer"> GitHub </a>上找到。</p>
<p>要了解更多信息，请查阅以下资源。</p>

<p> </p><div class="code-block code-block-17">
<div class="blog-plug inline-plug react-plug" vwo-el-id="26283398190">
<h2 vwo-el-id="41600691720">使用LogRocket消除传统反应错误报告的噪音</h2>
<a href="https://lp.logrocket.com/blg/react-signup-issue-free" target="_blank" vwo-el-id="19356441070">LogRocket
</a><p>是一款React analytics解决方案，可保护您免受数百个误报错误警报的影响，只针对少数真正重要的项目。LogRocket告诉您React应用程序中实际影响用户的最具影响力的bug和UX问题。</p><a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="19356441380">
<img class="first-react-image alignnone size-full wp-image-46 jetpack-lazy-image jetpack-lazy-image--handled" src="../Images/f300c244a1a1cf916df8b4cb02bec6c6.png" vwo-el-id="18272717540" data-lazy-loaded="1" data-original-src="https://files.readme.io/27c94e7-Image_2017-06-05_at_9.46.04_PM.png"/>
</a>
<a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="19356441690">
<img class="second-react-image alignnone size-full wp-image-46 jetpack-lazy-image jetpack-lazy-image--handled" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" vwo-el-id="30720362350" data-lazy-loaded="1" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/>
</a>
<a href="https://lp.logrocket.com/blg/react-signup-issue-free" target="_blank" rel="noopener noreferrer" vwo-el-id="35866400580">LogRocket
</a><p>自动聚合客户端错误、反应错误边界、还原状态、缓慢的组件加载时间、JS异常、前端性能指标和用户交互。然后，LogRocket使用机器学习来通知您影响大多数用户的最具影响力的问题，并提供您修复它所需的上下文。</p><p vwo-el-id="28675661060">关注重要的React bug—<a class="signup" href="https://lp.logrocket.com/blg/react-signup-issue-free" target="_blank" rel="noopener noreferrer" vwo-el-id="40093418840">今天就试试LogRocket】。</a></p>
</div></div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
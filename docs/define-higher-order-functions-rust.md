# Rust 中如何定义高阶函数

> 原文：<https://blog.logrocket.com/define-higher-order-functions-rust/>

高阶函数是其参数和/或返回值本身就是函数的函数。换句话说，如果一种语言支持高阶函数，那么我们说这些函数是一等公民，也就是说它们是值。

在本文中，我们将研究 Rust 如何支持高阶函数，以及我们如何定义它们。

*向前跳转:*

## Rust 中的函数

我们可以通过关键字`fn`在 Rust 中定义函数。通常，要定义一个函数，我们必须指定它的名称、参数和返回值的类型:

```
fn plus_one(n: i32) -> i32 {
    n + 1
}
```

`return`关键字是可选的。如果我们不指定它，函数的最后一条语句被认为是返回语句。

我们前面说过，Rust 中的函数是一等公民。因此，我们可以将它们存储在一个变量中。一旦它存储在变量中，我们就可以像往常一样调用它:

```
fn main() {
    let add_one = plus_one;

    println!("{}", add_one(1));
}
```

## 作为参数的功能

在上一节中，我们演示了如何定义一个函数并将其存储在一个变量中。现在，让我们看看如何将一个函数作为参数传递给另一个函数。

首先，我们必须创建高阶函数定义:

```
fn binary_operator<F>(n: i32, m: i32, op: F) -> i32 
                     where F: Fn(i32, i32) -> i32 {
    op(n, m)
}
```

`binary_operator`输入两个数字`n`和`m`，以及一个函数`op`。它将`op`应用于`n`和`m`，返回结果。

注意`op`参数的类型。它是一个通用类型`F`，在`binary_operator`的`where`子句中进行了细化。特别是，我们将它定义为一个带有两个数字参数(`(i32, i32)`)的函数(`Fn`，返回一个参数(`i32)`)。`Fn`这里代表一个函数指针，也就是存储函数的内存地址。

### 命名函数

将函数作为参数传递的最简单方法是使用它的`name (named function)`:

```
 add(n: i32, m: i32) -> i32 {
    n + m
}

fn binary_operator<F>(n: i32, m: i32, op: F) -> i32 
                     where F: Fn(i32, i32) -> i32 {
    op(n, m)
}

fn main() {
    println!("{}", binary_operator(5, 6, add));
}
```

在上面的例子中，我们首先定义了一个函数(`add`)来将两个数字相加，并将其用作`binary_operator`的参数。`main`印出`11`，不出所料。

### 匿名函数

有时没有必要命名函数。例如，我们可能想要动态定义一个函数，只在一个地方使用。这就是匿名函数发挥作用的地方:

```
fn main() {
    println!("{}", binary_operator(5, 6, |a: i32, b: i32| a - b));
}
```

在上面的例子中，我们在对`binary_operator`的调用中直接定义了一个匿名函数。我们定义管道之间的参数列表(`||`)，后面是函数本身的主体。

匿名函数是一个非常强大的工具，因为在 Rust 中，它们可以“捕获”周围的环境。在这种情况下，函数也称为闭包。

上面的代码片段按照预期编译并打印了`-1`。

## 作为返回值运行

正如我们前面提到的，在 Rust 中一个函数也可以返回另一个函数。由于 Rust 中内存管理的后果，这有点复杂，我们很快就会看到。

在下面的例子中，我们将修改上面定义的`binary_operator`，不应用操作符，而是返回一个代表未应用操作符的函数:

```
fn unapplied_binary_operator<'a, F>(n:& 'a i32, m:& 'a i32, op:& 'a F) 
                                   -> Box<dyn Fn() -> i32 + 'a>
                                   where F: Fn(i32, i32) -> i32 {
    Box::new(move || op(*n, *m))
}
```

`unapplied_binary_operator`的定义现在看起来复杂多了。

返回函数的主要问题是定义该函数的生命周期。Rust 中的生存期是借用检查器用来确保所有借用都有效的构造。

借用检查器，更一般地说，借用在 Rust 中是如何工作的，超出了本文的范围。如果你对 Rust 借检查器不熟悉，或者想知道更多，请查看这篇文章。

在上面的例子中，我们定义了一个生存期(`'a`)和通常的`F`类型(代表二元运算符)。然后，我们将`'a`与三个参数以及函数的返回值相关联。

基本上，我们告诉借用检查器，只要三个参数(`n`、`m`和`op`)存在，就要考虑由`unapplied_binary_operator`返回的函数的生命周期。

此外，锈蚀寿命可能只存在于参考文献中。因此，我们必须将我们的参数和返回值分别转换成带有`&`和`Box`的引用。

一般来说，`Box<dyn Fn()>`表示实现`Fn`特征的装箱值。

* * *

### 更多来自 LogRocket 的精彩文章:

* * *

引用使得函数体比以前更加复杂，因为我们现在必须取消对`n`和`m`的引用，并使用`Box::new()`显式地创建结果函数。

上述实现中另一个有趣的事情是`move`的使用。该关键字表示所有捕获(即所有对封闭环境的引用)都是通过值发生的。否则，一旦返回的匿名函数存在，任何引用捕获都将被丢弃，从而使闭包带有无效的引用。换句话说，使用`move`，闭包获得了它所使用的变量的所有权。

`unapplied_binary_operator`返回一个函数，不带参数，返回`op`对`n`和`m`的应用结果。假设我们现在使用引用，我们必须使用借用来调用它:

```
fn main() {
    let n = 5;
    let m = 6;
    println!("{}", unapplied_binary_operator(&n, &m, &add)());
}
```

注意我们如何使用`&`借用`n`、`m`和`add`(如上定义)。最后，由于`unapplied_binary_operator`返回一个不带参数的函数，我们可以使用空括号来调用它。上面的代码片段会打印出`11`，和预期的一样。

## 结论

在本文中，我们快速浏览了 Rust 中的高阶函数。我们演示了如何定义一个简单的函数。然后，我们探索了将函数作为参数传递的方法。最后，我们研究了返回一个函数有多复杂，简单提到了 Rust 的一些关键特性，比如借用和生存期。

高阶函数是 Rust 和许多其他编程语言的一个关键特性；Hof 是函数式编程的一个基本概念。我们可以使用高阶函数来编写更简洁、更易于长期维护的代码。

## [log rocket](https://lp.logrocket.com/blg/rust-signup):Rust 应用的 web 前端的全面可见性

调试 Rust 应用程序可能很困难，尤其是当用户遇到难以重现的问题时。如果您对监控和跟踪 Rust 应用程序的性能、自动显示错误、跟踪缓慢的网络请求和加载时间感兴趣，

[try LogRocket](https://lp.logrocket.com/blg/rust-signup)

.

[![LogRocket Dashboard Free Trial Banner](img/d6f5a5dd739296c1dd7aab3d5e77eeb9.png)](https://lp.logrocket.com/blg/rust-signup)

LogRocket 就像是网络和移动应用程序的 DVR，记录你的 Rust 应用程序上发生的一切。您可以汇总并报告问题发生时应用程序的状态，而不是猜测问题发生的原因。LogRocket 还可以监控应用的性能，报告客户端 CPU 负载、客户端内存使用等指标。

现代化调试 Rust 应用的方式— [开始免费监控](https://lp.logrocket.com/blg/rust-signup)。
<html>
<head>
<title>Cleaner components with React Router Hooks - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>带有React路由器挂钩的清洁组件</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/react-router-hooks-cleaner-components/#0001-01-01">https://blog.logrocket.com/react-router-hooks-cleaner-components/#0001-01-01</a></blockquote><div><article class="article-post">
<p><strong> <em>编者按</em> </strong> <em>:本帖最后更新于2022年3月7日，以反映已经过时的路线渲染方法的信息。</em></p>
<p>React Router是一个轻量级的库，允许您管理和处理React应用程序的路由。当使用React和React Native构建单页面应用程序时，React Router就派上了用场。</p>
<p>自从引入功能组件以来，React已经进步了很多，比如通过钩子的引入。与普通的基于类的方法不同，钩子使得包能够很好地与功能组件一起工作，许多包正在朝这个方向迁移。</p>
<p>结果，我们看到React路由器挂钩。在本文中，我们将回顾三个<a href="https://blog.logrocket.com/using-hooks-with-react-router/"> React挂钩，它们将使React路由器</a>的工作更加容易。我们开始吧！</p>
<h3>目录</h3>

<h2 id="the-useparams-hook"><code>useParams</code>钩子</h2>
<p><code>useParams</code>钩子将从应用程序URL返回一个设置为动态的键/值对对象。在复杂的应用程序中，有许多动态导航链接是很常见的。例如，您可能有一个<code>/post/:id</code> URL，它也启动一个到应用程序后端的获取过程。在这种情况下，最常见的React路由器模式是使用组件属性:</p>
<pre class="“language-react">export default function App() {
  return (
    &lt;Router&gt;
      &lt;div&gt;
        &lt;nav&gt;
          &lt;ul&gt;
            &lt;li&gt;
              &lt;Link to="/"&gt;Home&lt;/Link&gt;
            &lt;/li&gt;
            &lt;li&gt;
              &lt;Link to="/post/hello-world"&gt;First Post&lt;/Link&gt;
            &lt;/li&gt;
          &lt;/ul&gt;
        &lt;/nav&gt;
        &lt;Routes&gt;
          &lt;Route path="/post/:slug" element={&lt;Post /&gt;} /&gt;
          &lt;Route path="/"&gt;
            &lt;Home /&gt;
          &lt;/Route&gt;
        &lt;/Routes&gt;
      &lt;/div&gt;
    &lt;/Router&gt;
  );
}
</pre>
<p>通过将<code>Post</code>组件传递给<code>/post/:numberRoute</code>组件，您可以从React Router传递给<code>Post</code>组件的<code>match</code>属性中提取<code>params</code>对象:</p>
<pre class="“language-react">// Old way to fetch parameters
function Post({ match }) {
  let params = match.params;
  return (
    &lt;div&gt;
      In React Router v4, you get parameters from the props. Current parameter
      is &lt;strong&gt;{params.slug}&lt;/strong&gt;
    &lt;/div&gt;
  );
}
</pre>
<p>虽然上面的方法是可行的，但是如果你有一个包含许多动态路由的大型应用程序，这就相当麻烦了。你必须跟踪哪些<code>Route</code>组件需要组件道具，哪些不需要。此外，因为<code>match</code>对象是从<code>Route</code>传递到渲染组件的，所以您需要将动态路径传递给DOM树中更下面的组件。</p>
<p>在这种情况下，<code>useParams</code>钩子确实会发光。这是一个简洁的助手函数，它为您提供了当前路线的参数，因此您不必使用component props模式:</p>
<pre class="“language-react">&lt;Switch&gt;
  &lt;Route path="/post/:slug" element={&lt;Post /&gt;} /&gt;
  &lt;Route path="/users/:id/:hash" element={&lt;Users /&gt;} /&gt;
  &lt;Route path="/" element={&lt;Home /&gt;} /&gt;
&lt;/Switch&gt;

function Users() {
  let params = useParams();
  return (
    &lt;div&gt;
      In React Router v5, You can use hooks to get parameters.
      &lt;br /&gt;
      Current id parameter is &lt;strong&gt;{params.id}&lt;/strong&gt;
      &lt;br /&gt;
      Current hash parameter is &lt;strong&gt;{params.hash}&lt;/strong&gt;
    &lt;/div&gt;
  );
}
</pre>
<p>如果<code>Users</code>的子组件需要访问参数，您也可以简单地在那里调用<code>useParams()</code>。</p>
<h2 id="the-uselocation-hook"><code>useLocation</code>钩子</h2>
<p>在React Router v4.x中，就像获取参数一样，您必须使用component props模式来访问一个<code>location</code>对象:</p>
<pre class="“language-react">&lt;Route path="/post/:number" component={Post} /&gt;

function Post(props) {
  return (
    &lt;div&gt;
      In React Router v4, you get the location object from props. &lt;br /&gt;
      Current pathname: &lt;strong&gt;{props.location.pathname}&lt;/strong&gt;
    &lt;/div&gt;
  );
}
</pre>
<p>但是，<a href="https://blog.logrocket.com/react-router-v6-future-reach-router/">用React路由器v6.x，可以调用<code>useLocation</code>钩子</a>从React路由器获取<code>location</code>对象:</p>
<pre>&lt;Route path="/users/:id/:password" element={&lt;Users /&gt;} /&gt;

// new way to fetch location with hooks
function Users() {
  let location = useLocation();
  return (
    &lt;div&gt;
      In React Router v5, You can use hooks to get location object.
      &lt;br /&gt;
      Current pathname: &lt;strong&gt;{location.pathname}&lt;/strong&gt;
    &lt;/div&gt;
  );
}
</pre>
<h2 id="the-usenavigate-hook"><code>useNavigate</code>钩子</h2>
<p>从上一节我们又少了一个使用组件道具的理由。但是你不是还需要使用组件或者渲染模式来获取<code>history</code>对象吗？</p>
<p><code>history</code>对象是你需要使用组件或渲染道具模式的最后一个原因:</p>
<pre class="“language-react">&lt;Route path="/post/:slug" component={Post} /&gt;

// Old way to fetch history
function Post(props) {
  return (
    &lt;div&gt;
      In React Router v4, you get the history object from props. &lt;br /&gt;
      &lt;button type="button" onClick={() =&gt; props.history.goBack()}&gt;
        Go back
      &lt;/button&gt;
    &lt;/div&gt;
  );
}
</pre>
<p>使用<code>useNavigate</code>钩子，您可以获得相同的历史对象，而不需要<code>Route</code>组件来传递它:</p>
<pre class="“language-react">&lt;Route path="/users/:id/:hash" element={&lt;Users /&gt;}&gt;

// new way to fetch history with hooks
function Users() {
  let navigate = useNavigate();
  return (
    &lt;div&gt;
      In React Router v5, You can use hooks to get navigate function to move around in the app.
      &lt;br /&gt;
      &lt;button type="button" onClick={() =&gt; navigate(-1)}&gt;
        Go back
      &lt;/button&gt;
    &lt;/div&gt;
  );
}
</pre>
<p>React路由器v6不提供<code>useHistory</code>钩子。相反，我们用<code>useNavigate</code>钩子导航。在上面的例子中，我们使用<code>navigate(-1)</code>返回到上一页。<code>-1</code>确定您想要返回的页数。例如，<code>-2</code>会倒退两页，等等。</p>
<h2 id="conclusion">用React路由器钩子重构你的组件</h2>
<p><a href="https://blog.logrocket.com/migrating-react-router-v6-complete-guide/"> React路由器团队利用了钩子</a>的力量，实现了跨组件共享逻辑，而不需要从树的顶端向下传递。如果你想用这些新钩子重构你的组件，你可以从更新使用<code>match</code>、<code>location</code>或<code>history</code>对象的组件开始:</p>
<pre class="“language-react">// before
function userComponent({ match, location, history }) {
  let { slug } = match.params
  // ...
}

// after
function userComponent() {
  let { slug } = useParams()
  let location = useLocation()
  // ...
}
</pre>
<p>之后，您可以更新您的<code>navigation</code>组件中可能有的奇怪的<code>&lt;Route&gt;</code>组件:</p>
<pre class="“language-react">// before
&lt;Switch&gt;
  &lt;Route path="/user/:id" component={userComponent} /&gt;
&lt;/Switch&gt;

// after
&lt;Switch&gt;
  &lt;Route path="/user/:id" element={&lt;userComponent /&gt;}&gt;
&lt;/Switch&gt;
</pre>
<p>如何看待React路由器挂钩？如果你有任何问题，请在下面留下评论。编码快乐！</p><div class="code-block code-block-17">
<div class="blog-plug inline-plug react-plug" vwo-el-id="26283398190">
<h2 vwo-el-id="41600691720"><a href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener"> LogRocket </a>:全面了解您的生产React应用</h2><p>调试React应用程序可能很困难，尤其是当用户遇到难以重现的问题时。如果您对监视和跟踪Redux状态、自动显示JavaScript错误以及跟踪缓慢的网络请求和组件加载时间感兴趣，</p><a href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" vwo-el-id="19356441070">try LogRocket</a><p>. </p><a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="19356441380">
<img class="first-react-image alignnone size-full wp-image-46 jetpack-lazy-image jetpack-lazy-image--handled" src="../Images/f300c244a1a1cf916df8b4cb02bec6c6.png" vwo-el-id="18272717540" data-lazy-loaded="1" data-original-src="https://files.readme.io/27c94e7-Image_2017-06-05_at_9.46.04_PM.png"/>
</a>
<a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="19356441690">
<img class="second-react-image alignnone size-full wp-image-46 jetpack-lazy-image jetpack-lazy-image--handled" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" vwo-el-id="30720362350" data-lazy-loaded="1" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/>
</a>
<p vwo-el-id="28675660440" class="">LogRocket 结合了会话回放、产品分析和错误跟踪，使软件团队能够创建理想的web和移动产品体验。这对你来说意味着什么？</p>
<p>LogRocket不是猜测错误发生的原因，也不是要求用户提供截图和日志转储，而是让您回放问题，就像它们发生在您自己的浏览器中一样，以快速了解哪里出错了。</p>
<p>不再有嘈杂的警报。智能错误跟踪允许您对问题进行分类，然后从中学习。获得有影响的用户问题的通知，而不是误报。警报越少，有用的信号越多。</p>
<p vwo-el-id="28675660750">LogRocket Redux中间件包为您的用户会话增加了一层额外的可见性。LogRocket记录Redux存储中的所有操作和状态。</p>
<p vwo-el-id="28675661060">现代化您调试React应用的方式— <a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="40093418840">开始免费监控</a>。</p>
</div></div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
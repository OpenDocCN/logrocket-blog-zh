<html>
<head>
<title>Understanding Elasticsearch query body builder in Node.js - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>在Node.js - LogRocket博客中了解Elasticsearch查询body builder</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/elasticsearch-query-body-builder-node-js/#0001-01-01">https://blog.logrocket.com/elasticsearch-query-body-builder-node-js/#0001-01-01</a></blockquote><div><article class="article-post">
<h2>介绍</h2>
<p>Elasticsearch查询主体构建器是一个查询DSL(特定领域语言)或客户端，它在原始Elasticsearch查询上提供了一个API层。它使全文搜索数据查询和复杂的数据聚合在语法上更容易、更方便、更清晰。</p>
<p>在本教程中，我们将了解如何使用构建器语法编写查询比原始的Elasticsearch查询更具优势。这是因为原始查询可能很快变得繁琐、无结构、不太习惯，甚至容易出错。</p>
<p>我们将通过利用查询构建器库<a href="https://elastic-builder.js.org/"> elastic-builder </a>来实现这一点。根据<a href="https://elastic-builder.js.org/docs/"> its文档</a>，它是一个为复杂的搜索查询和聚合快速构建请求体的工具。此外，它符合本地Elasticsearch查询的API规范标准，没有任何性能瓶颈。</p>
<p>本质上，这意味着我们可以使用构建器语法编写查询，匹配本地Elasticsearch提供的等价查询。不要担心，随着本教程的深入，我们将学习并理解构建器语法。</p>
<p>首先，让我们检查一个普通汽车查询的简单示例，以了解为什么使用ES query builder会使查询Elasticsearch数据更容易，以及它如何有助于更快的开发生命周期。</p>
<pre>{
  "query": {
    "bool": {
      "must": {
        "match": {
          "Origin": "USA"
        }
      },
      "filter": {
        "range": {
          "Cylinders": {
            "gte": 4,
            "lte": 6
          }
        }
      },
      "must_not": {
        "range": {
          "Horsepower": {
            "gte": 75
          }
        }
      },
      "should": {
        "term": {
          "Name": "ford"
        }
      }
    }
  }
}</pre>
<p>看着上面的内容，我们正在运行一个对原产地为美国的汽车的查询，同时执行一个过滤器，其中引擎的汽缸可以大于或等于4或小于或等于6。此外，我们正在运行一个范围查询，其中汽车的马力不得大于或等于75。最后，车的名字应该是福特。</p>
<p>现在，编写这类查询的问题是:</p>
<ul>
<li>它们过于冗长</li>
<li>它们很容易出现语法错误，这可能是糟糕的字段嵌套的结果</li>
<li>随着时间的推移，它们可能很难维护，甚至很少增加变化。例如，知道在哪里添加另一个筛选器或查询字段可能会变得令人困惑</li>
<li>开发团队的新成员可能很难发现它们</li>
<li>为更复杂的查询编写它们并不有趣</li>
</ul>
<p>现在考虑使用构建器语法的上述查询的等效查询，如下所示:</p>
<pre>esb.requestBodySearch()
     .query(
        esb.boolQuery()
            .must(esb.matchQuery('Origin', 'USA'))
            .filter(esb.rangeQuery('Cylinders').gte(4).lte(6))
            .should(esb.termQuery('Name', 'ford'))
            .mustNot(esb.rangeQuery('Horsepower').gte(75))
    )</pre>
<p>上面的查询与我们之前查看的原始es查询做了完全相同的事情，正如我们所看到的，这更加直观和有目的。</p>
<p>这里，我们使用了来自elastic-builder的<code>requestBodySearch</code> API。这个API帮助我们构建和形成查询，以一种平稳、流畅、习惯的方式口头表达和解释我们的意图。它们的可读性也很强，我们可以根据具体情况决定添加更多的字段，以获得完全不同的查询结果。</p>
<h2>先决条件</h2>
<p>为了更容易地跟随本教程，我建议浏览一下关于开始使用Elasticsearch和Node.js的本<a href="https://blog.logrocket.com/write-your-own-search-engine-using-node-js-and-elastic/">介绍性教程</a>。请注意，只有在您之前缺乏使用Elasticsearch的经验或者想要复习一下的情况下，才需要这样做。否则，你应该能够轻松地跟随这个教程。</p>
<p>首先，确保您的机器上安装了Node.js和npm。另外，我建议你<a href="https://www.elastic.co/downloads/elasticsearch">下载Elasticsearch二进制文件</a>并安装它们，以防万一你打算在本地运行它。然而，出于本教程的目的，我们将使用弹性云设置弹性搜索，你可以使用<a href="https://www.elastic.co/cloud/"> 14天免费试用</a>。</p>
<p>在你完成整个设置后(比如选择一个云提供商和你选择的地区，因为它是一个托管服务)，你应该得到一个用户名(很可能是<code>elastic</code>)、<code>password</code>、<code>host</code>和<code>port</code>。请注意，稍后我们将需要这些凭证或密码来连接到我们的ES集群。</p>
<p>虽然用户界面非常直观，但是为了直观地了解这些参数的位置，这里有一些截图指出了应该在哪里查看。</p>
<figure id="attachment_10798" aria-describedby="caption-attachment-10798" class="wp-caption aligncenter"><img data-attachment-id="10798" data-permalink="https://blog.logrocket.com/elasticsearch-query-body-builder-node-js/user-and-password-fields/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2019/12/user-and-password-fields.png" data-orig-size="730,410" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Elastic user and password fields" data-image-description="" data-image-caption="&lt;p&gt;Elastic user and password fields.&lt;/p&gt;&#10;" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2019/12/user-and-password-fields-300x168.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2019/12/user-and-password-fields.png" decoding="async" class="size-full wp-image-10798 jetpack-lazy-image" src="../Images/19b80907f8112b050fe4bb4e605a4050.png" alt="Elastic User And Password Fields" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2019/12/user-and-password-fields.png 730w, https://blog.logrocket.com/wp-content/uploads/2019/12/user-and-password-fields-300x168.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2019/12/user-and-password-fields.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/12/user-and-password-fields.png"/><noscript><img data-lazy-fallback="1" data-attachment-id="10798" data-permalink="https://blog.logrocket.com/elasticsearch-query-body-builder-node-js/user-and-password-fields/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2019/12/user-and-password-fields.png" data-orig-size="730,410" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Elastic user and password fields" data-image-description="" data-image-caption="&lt;p&gt;Elastic user and password fields.&lt;/p&gt;&#10;" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2019/12/user-and-password-fields-300x168.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2019/12/user-and-password-fields.png" decoding="async" loading="lazy" class="size-full wp-image-10798" src="../Images/19b80907f8112b050fe4bb4e605a4050.png" alt="Elastic User And Password Fields" srcset="https://blog.logrocket.com/wp-content/uploads/2019/12/user-and-password-fields.png 730w, https://blog.logrocket.com/wp-content/uploads/2019/12/user-and-password-fields-300x168.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/12/user-and-password-fields.png"/></noscript><figcaption id="caption-attachment-10798" class="wp-caption-text">Elastic user and password fields.</figcaption></figure>
<figure id="attachment_10799" aria-describedby="caption-attachment-10799" class="wp-caption aligncenter"><img data-attachment-id="10799" data-permalink="https://blog.logrocket.com/elasticsearch-query-body-builder-node-js/elasticsearch-url-endpoint/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2019/12/elasticsearch-url-endpoint.png" data-orig-size="730,480" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Elasticsearch URL endpoint" data-image-description="" data-image-caption="&lt;p&gt;Elasticsearch URL endpoint.&lt;/p&gt;&#10;" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2019/12/elasticsearch-url-endpoint-300x197.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2019/12/elasticsearch-url-endpoint.png" decoding="async" class="size-full wp-image-10799 jetpack-lazy-image" src="../Images/76a9c9f39db4c7060aa2544ec6d79a45.png" alt="Elasticsearch URL Endpoint" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2019/12/elasticsearch-url-endpoint.png 730w, https://blog.logrocket.com/wp-content/uploads/2019/12/elasticsearch-url-endpoint-300x197.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2019/12/elasticsearch-url-endpoint.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/12/elasticsearch-url-endpoint.png"/><noscript><img data-lazy-fallback="1" data-attachment-id="10799" data-permalink="https://blog.logrocket.com/elasticsearch-query-body-builder-node-js/elasticsearch-url-endpoint/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2019/12/elasticsearch-url-endpoint.png" data-orig-size="730,480" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Elasticsearch URL endpoint" data-image-description="" data-image-caption="&lt;p&gt;Elasticsearch URL endpoint.&lt;/p&gt;&#10;" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2019/12/elasticsearch-url-endpoint-300x197.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2019/12/elasticsearch-url-endpoint.png" decoding="async" loading="lazy" class="size-full wp-image-10799" src="../Images/76a9c9f39db4c7060aa2544ec6d79a45.png" alt="Elasticsearch URL Endpoint" srcset="https://blog.logrocket.com/wp-content/uploads/2019/12/elasticsearch-url-endpoint.png 730w, https://blog.logrocket.com/wp-content/uploads/2019/12/elasticsearch-url-endpoint-300x197.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/12/elasticsearch-url-endpoint.png"/></noscript><figcaption id="caption-attachment-10799" class="wp-caption-text">Elasticsearch URL endpoint.</figcaption></figure>
<p>第一张截图显示了Elasticsearch <code>user</code>以及我们可以在哪里找到我们的<code>password</code>或生成新密码。第二个截图显示了一个链接，在这里我们可以很容易地复制<code>elasticsearch endpoint url</code>。完成这个设置后，我们应该可以开始工作了，除了我们打算探索栈中的其他Elasticsearch服务，如Kibana。</p>
<figure id="attachment_10800" aria-describedby="caption-attachment-10800" class="wp-caption aligncenter"><img data-attachment-id="10800" data-permalink="https://blog.logrocket.com/elasticsearch-query-body-builder-node-js/kibana-ui/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2019/12/kibana-ui.png" data-orig-size="730,413" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Kibana UI" data-image-description="" data-image-caption="&lt;p&gt;The Kibana UI.&lt;/p&gt;&#10;" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2019/12/kibana-ui-300x170.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2019/12/kibana-ui.png" decoding="async" class="wp-image-10800 size-full jetpack-lazy-image" src="../Images/80e03ed1f260894105788e5e48fbd467.png" alt="Kibana UI Screenshot" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2019/12/kibana-ui.png 730w, https://blog.logrocket.com/wp-content/uploads/2019/12/kibana-ui-300x170.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2019/12/kibana-ui.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/12/kibana-ui.png"/><noscript><img data-lazy-fallback="1" data-attachment-id="10800" data-permalink="https://blog.logrocket.com/elasticsearch-query-body-builder-node-js/kibana-ui/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2019/12/kibana-ui.png" data-orig-size="730,413" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Kibana UI" data-image-description="" data-image-caption="&lt;p&gt;The Kibana UI.&lt;/p&gt;&#10;" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2019/12/kibana-ui-300x170.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2019/12/kibana-ui.png" decoding="async" loading="lazy" class="wp-image-10800 size-full" src="../Images/80e03ed1f260894105788e5e48fbd467.png" alt="Kibana UI Screenshot" srcset="https://blog.logrocket.com/wp-content/uploads/2019/12/kibana-ui.png 730w, https://blog.logrocket.com/wp-content/uploads/2019/12/kibana-ui-300x170.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/12/kibana-ui.png"/></noscript><figcaption id="caption-attachment-10800" class="wp-caption-text">The Kibana UI, which provides a sort of dashboard visualization and allows monitoring and viewing metrics on your data and the entire Elastic stack.</figcaption></figure>
<p>你可以查看关于Kibana 和整个Elastic stack的更多信息。接下来，让我们对将要构建的内容有一个清晰的背景。</p>
<h2>引导我们的应用程序</h2>
<p>在本教程中，我们将构建几个API端点来演示如何对存储在Elasticsearch集群中的数据执行全文搜索查询。当然，我们将使用构建器语法来构建我们的查询，并将它们与原始的es查询进行比较。</p>
<p>我们可以继续为我们的项目创建一个新文件夹，并随意命名。像往常一样，在我们开始一个新的Node.js项目之前，我们在项目目录中运行<code>npm init</code>。这将为我们创建一个新的<code>package.json</code>文件。</p>
<p>然后，我们可以继续安装我们的应用程序依赖项。这个项目需要的依赖项是节点的官方Elasticsearch客户端、elastic-builder库、Express、body-parser和dotenv包。</p>
<p>要安装它们，我们可以在终端/命令提示符下运行以下命令:</p>
<p>NPM install @ elastic/elastic search body-parser dotenv elastic-builder express–保存</p>
<p>安装完成后，我们的<code>package.json</code>文件应该是这样的:</p>
<pre>{
  "name": "logrocket_elasticsearch_tutorial",
  "version": "1.0.0",
  "description": "LogRocket ElasticSearch Tutorial with ES Builder",
  "main": "index.js",
  "scripts": {
    "start": "node ./app/server.js"
  },
  "author": "Alexander Nnakwue",
  "license": "ISC",
  "dependencies": {
    "@elastic/elasticsearch": "^7.4.0",
    "body-parser": "^1.19.0",
    "dotenv": "^8.2.0",
    "elastic-builder": "^2.4.0",
    "express": "^4.17.1"
  }
}</pre>
<p>现在我们将继续创建我们需要的所有必要的文件和文件夹。注意，<code>start</code>脚本基于我们的<code>server.js</code>文件的相对路径。首先，确保您在项目目录中，然后运行<code>mkdir app</code>创建一个名为<code>app</code>的新文件夹。</p>
<p>创建完<code>app</code>文件夹后，我们可以导航到其中并创建所有必要的文件，如下面的截图所示。此外，我们可以继续在项目的根目录中创建所有其他文件，如图所示。</p>
<p><img data-attachment-id="10840" data-permalink="https://blog.logrocket.com/elasticsearch-query-body-builder-node-js/project-files/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2019/12/project-files.png" data-orig-size="310,752" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Project’s root directory" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2019/12/project-files-124x300.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2019/12/project-files.png" decoding="async" class="aligncenter size-full wp-image-10840 jetpack-lazy-image" src="../Images/cc1d86b218db0dd83477654f11b2ceb1.png" alt="Project's Root Directory" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2019/12/project-files.png 310w, https://blog.logrocket.com/wp-content/uploads/2019/12/project-files-124x300.png 124w" data-lazy-sizes="(max-width: 310px) 100vw, 310px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2019/12/project-files.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/12/project-files.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="10840" data-permalink="https://blog.logrocket.com/elasticsearch-query-body-builder-node-js/project-files/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2019/12/project-files.png" data-orig-size="310,752" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Project’s root directory" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2019/12/project-files-124x300.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2019/12/project-files.png" decoding="async" loading="lazy" class="aligncenter size-full wp-image-10840" src="../Images/cc1d86b218db0dd83477654f11b2ceb1.png" alt="Project's Root Directory" srcset="https://blog.logrocket.com/wp-content/uploads/2019/12/project-files.png 310w, https://blog.logrocket.com/wp-content/uploads/2019/12/project-files-124x300.png 124w" sizes="(max-width: 310px) 100vw, 310px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/12/project-files.png"/></noscript>
<p>下一步是我们创建一个到Elasticsearch集群的连接。为此，我们需要创建一个<code>.env</code>文件来存储我们所有的环境变量或秘密。<code>sample.env</code>文件完全反映了我们的<code>.env</code>中应该包含的内容。该文件的内容如下:</p>
<pre>ELASTICSEARCH_USERNAME=username
ELASTICSEARCH_PASSWORD=password
ELASTICSEARCH_HOST=host
ELASTICSEARCH_PORT=port
APP_PORT= 3004
ELASTICSEARCH_INDEX=index
ELASTICSEARCH_TYPE=type</pre>
<p>我们可以继续复制这些参数，在我们项目的根目录下创建一个<code>.env</code>文件，并填写真正的凭证。之后，我们应该可以创建我们的<code>config.js</code>文件，它应该提供对我们新创建的<code>.env</code>文件中定义或添加的变量的访问。</p>
<p><code>config.js</code>文件应该包含以下JSON:</p>
<pre>const result = require('dotenv').config();
module.exports= {
es_host: process.env.ELASTICSEARCH_HOST,
es_pass: process.env.ELASTICSEARCH_PASSWORD,
es_port: process.env.ELASTICSEARCH_PORT,
es_user:process.env.ELASTICSEARCH_USERNAME,
es_index:process.env.ELASTICSEARCH_INDEX,
es_type:process.env.ELASTICSEARCH_TYPE,
app_port: process.env.APP_PORT
};

if (result.error) {
  console.log(result.error, "[Error Parsing env variables!]");
  throw result.error;
};
// console.log(result.parsed, '[Parsed env variables!]');</pre>
<p>正如我们所见，我们正在访问包含在<code>.env</code>文件中的变量，并用不同的变量名存储它们。还要注意的是，我们已经添加了<code>app_port</code>、<code>es_index</code>、<code>es_type</code>以及我们的Elasticsearch连接所需的其他变量。</p>
<p>现在，让我们用这些参数连接到我们的Elasticsearch集群。为此，我们可以将以下内容复制到<code>esConfig.js</code>文件中:</p>
<pre>'use strict'

const { Client } = require('@elastic/elasticsearch');
const config = require('./config');
const client = new Client({ node: `https://${config.es_user}:${config.es_pass}@${config.es_host}:${config.es_port}`});

module.exports.esClient= client;</pre>
<p>这里我们添加了一个对官方Elasticsearch Node.js客户端库的引用，然后我们使用之前创建的<code>config.js</code>文件中包含的内容来实例化一个到我们集群的新ES客户端连接。</p><div class="code-block code-block-54">
<hr/>
<h3>更多来自LogRocket的精彩文章:</h3>

<hr/></div>
<h2>将数据写入我们的ES集群</h2>
<p>既然我们的集群已经设置好了，我们可以继续创建一个新文件，其中包含我们打算写入Elasticsearch索引的JSON数据。我们可以继续创建新文件<code>dataToEs.json</code>，如果我们之前没有这样做的话。文件的内容可以归功于GitHub 上的<a href="https://vega.github.io/vega-datasets/data/cars.json">这个来源。它基本上包含了基于JSON的数据集，我们将根据连接到集群所需的给定参数将其写入ES索引。</a></p>
<p>完成以上工作后，我们可以创建一个<code>utility.js</code>文件，其中包含创建ES索引所需的函数；根据可用字段及其各自的数据类型为数据集创建新的映射；最后，将JSON数据写入我们在集群上创建的索引。</p>
<p>注意，Elasticsearch在默认情况下是无模式的，但是我们可以预先定义自己的模式来帮助定义数据的标准结构和格式。这当然有其自身的优势，比如数据一致性等等。现在让我们了解一下<code>utility.js</code>文件中发生了什么:</p>
<pre>const fs = require('fs');
const esconfig = require('./esConfig');
const client = esconfig.esClient;
const data = JSON.parse(fs.readFileSync(__dirname + '/dataToEs.json'));
const config = require('./config');

const index= config.es_index;
const type = config.es_type;

  async function writeCarDataToEs(index, data){
    for (let i = 0; i &lt; data.length; i++ ) {
      await client.create({
        refresh: true,
        index: index,
        id: i,
        body: data[i]
      }, function(error, response) {
        if (error) {
          console.error("Failed to import data", error);
          return;
        }
        else {
          console.log("Successfully imported data", data[i]);
        }
      });
    }
};
async function createCarMapping (index, type) {
  const carSchema = {
      "Acceleration": {
        "type": "long"
      },
      "Cylinders": {
        "type": "long"
      },
      "Displacement": {
        "type": "long"
      },
      "Horsepower": {
        "type": "long"
      },
      "Miles_per_Gallon": {
        "type": "long"
      },
      "Name": {
        "type": "text",
        "fields": {
          "keyword": {
            "type": "keyword",
            "ignore_above": 256
          }
        }
      },
      "Origin": {
        "type": "text",
        "fields": {
          "keyword": {
            "type": "keyword",
            "ignore_above": 256
          }
        }
      },
      "Weight_in_lbs": {
        "type": "long"
      },
      "Year": {
        "type": "date"
    }
  }
  return client.indices.putMapping({index, type, body:{properties:carSchema}});
}
module.exports = {
async resetIndex(){
 if (client.indices.exists({ index })) {
      client.indices.delete({ index });
   }
 client.indices.create({ index });
 createCarMapping(client, index, type);
 writeCarDataToEs(index, data);
}
};</pre>
<p>在上面的文件中，我们首先动态读取包含在我们之前谈到的<code>dataToEs.json</code>文件中的JSON数据。如图所示，我们使用了Node.js的本地文件系统包。</p>
<p>我们还利用<code>__dirname</code>来访问当前模块的目录名，并将数据集的相对文件路径附加到它上面。此外，我们正在导入对我们的ES客户端连接的引用。第一个函数<code>writeCarDataToEs</code>遍历整个JSON数据集，并将其写入我们的Elasticsearch索引。</p>
<p>注意这里有一个警告，对于非常大的数据集，我们应该用ES <code>bulk</code> API代替<code>create</code> API。然而，对于我们当前的用例，这应该很好。要了解如何使用ES <code>bulk</code> API，可以查看<a href="https://github.com/elastic/elasticsearch-js/blob/master/docs/examples/bulk.asciidoc"> this GitHub repo </a>中提供的官方示例。</p>
<p>之后，我们现在可以为我们的数据创建映射，它代表了预期的数据类型和格式。我们通过在传递索引、类型和JSON主体的同时调用<code>putMapping</code> API来实现。</p>
<p>最后，我们创建函数<code>resetIndex</code>，它检查我们试图创建的索引是否已经存在，如果存在，就为我们删除它。否则，我们使用从env变量传递的名称创建一个新的索引，为JSON数据集创建映射，并调用<code>writeDataToEs()</code>函数，然后该函数根据已经指定的映射将数据写入索引。</p>
<p>现在我们可以继续创建我们的<code>server.js</code>文件，它基本上是一个简单的Express服务器。</p>
<pre>const express = require('express');
const bodyParser = require('body-parser')
require("dotenv").config();
require("./utility").resetIndex();
const app = express();
const esconfig = require('./esConfig');
const client = esconfig.esClient;
const router  = require("./router");

app.use(bodyParser.urlencoded({ extended: false }));
app.use(bodyParser.json());
app.use("/",router);

app.set('port', process.env.APP_PORT || 3000);

client.ping({}, function(error) {
  if (error) {
      console.log('ES Cluster is down', error);
  } else {
      console.log('ES Cluster is up!');
  }
});


app.listen(app.get('port'), ()=&gt;{
  console.log(`Express server listening on port, ${app.get('port')}`);
} );</pre>
<p>这里，我们从<code>utility.js</code>文件导入<code>resetIndex()</code>函数，这将使它在我们启动应用程序时自动运行。我们可以决定将该导入注释掉，因为后续的应用程序重启不需要它，因为我们应该已经在ES集群中创建和设置了索引、映射和数据。</p>
<h2>编写弹性生成器查询</h2>
<p>现在我们可以开始为我们的数据编写查询了。让我们首先编写一个多匹配查询，它匹配汽车的名称和来源，同时它的重量大于或等于一个特定的数字(<code>rangeQuery</code>)。我们可以查看<a href="https://github.com/firebase007/Elastic_search_query_builder_tutorial/blob/master/app/services.js"> <code>service.js</code>文件</a>来理解这个查询是如何工作的:</p>
<pre>async fetchMatchMultipleQuery(origin, name,weight){
  const requestBody = esb.requestBodySearch()
      .query(
        esb.boolQuery()
          .must([
            esb.matchQuery(
              'Origin', origin,
            ),
            (
              esb.matchQuery(
                'Name', name,
              )
            ),
          ])
        .filter(esb.rangeQuery('Weight_in_lbs').gte(weight))
      )
      return client.search({index: index, body: requestBody.toJSON()});
}</pre>
<p>看看上面的函数，我们想要达到的目的就很清楚了。这个查询是一个布尔值，它必须匹配来自特定来源和特定名称的汽车。此外，我们使用范围查询过滤汽车，其中重量必须大于或等于我们指定的特定重量。</p>
<p>作为题外话，让我们看看上面的等价原始查询:</p>
<pre>{
  "bool": {
    "must": [
      {
        "match": {
          "Origin": "https://elastic-builder.js.org"
        }
      },
      {
        "match": {
          "Name": "name"
        }
      }
    ],
    "filter": {
      "range": {
        "Weight_in_lbs": {
          "gte": "weight"
        }
      }
    }
  }
}</pre>
<p>正如我们所见，由于查询的深层嵌套性质，这很容易出错，这一点我们在前面已经指出。现在我们有了一个可视化的提示，让我们来理解实际调用这个API的流程。</p>
<p>首先，检查一下<a href="https://github.com/firebase007/Elastic_search_query_builder_tutorial/blob/master/app/services.js"> <code>services.js</code>文件</a>。这个文件处理与使用构建器语法构建查询相关的所有事情，然后调用我们的es客户端来实际执行这些调用。同样，在文件内部，我们填充了与上面相同的函数。</p>
<p><a href="https://github.com/firebase007/Elastic_search_query_builder_tutorial/blob/master/app/controller.js"> <code>controller.js</code>文件</a>负责根据<a href="https://github.com/firebase007/Elastic_search_query_builder_tutorial/blob/master/app/router.js"> <code>routes.js</code>文件</a>中指定的应用程序路由来路由我们的请求。当请求被路由时，<code>controller.js</code>文件中的函数调用<code>services.js</code>文件中的函数。</p>
<p>让我们用一个简单的例子来说明这个问题。对于上面定义的前一个查询，<code>controller</code>文件中相应的调用如下所示:</p>
<pre>async fetchMatchMultipleQuery(req,res) {
    const origin = req.query.Origin;
    const name = req.query.Name;
    const weight = req.query.Weight_in_lbs;
    try {
      const result = await Services.fetchMatchMultipleQuery(origin, name, weight);
      const data = result.body.hits.hits.map((car)=&gt;{
        return {
          id: car._id,
          data: car._source
        }
      })
      res.json({status_code: 200, success: true, data: data, messsage: "fetch match query for multiple requests successful!" });
    } catch (err) {
      res.json({status_code: 500, success: false, data: [], message: err});
    }
  }</pre>
<p>随后，该呼叫的路由包含在<code>routes.js</code>文件中:</p>
<pre>routes.route("/search-by-multiple").get(controller.fetchMatchMultipleQuery);</pre>
<h2>测试我们的实现</h2>
<p>我们现在可以继续测试我们的实现了。首先，让我们通过运行<code>npm start</code>来启动我们的服务器。然后我们可以访问这个URL，用提供的过滤器运行我们的查询:<code>name</code>、<code>origin</code>和<code>weight_in_lbs</code>。</p>
<p><code><a href="http://localhost:3000/search-by-multiple?Name=ford&amp;Origin=USA&amp;Weight_in_lbs=3000" rel="nofollow">http://localhost:3000/search-by-multiple?Name=ford&amp;Origin=USA&amp;Weight_in_lbs=3000</a></code></p>
<p>注意，上面的请求是一个<code>GET</code>请求，URL后面的参数是为我们提供所需的过滤结果所需的查询参数。API调用的结果如下所示:</p>
<pre>{
  "status_code": 200,
  "success": true,
  "data": [
    {
      "id": "221",
      "data": {
        "Name": "ford f108",
        "Miles_per_Gallon": 13,
        "Cylinders": 8,
        "Displacement": 302,
        "Horsepower": 130,
        "Weight_in_lbs": 3870,
        "Acceleration": 15,
        "Year": "1976-01-01",
        "Origin": "USA"
      }
    },
    {
      "id": "99",
      "data": {
        "Name": "ford ltd",
        "Miles_per_Gallon": 13,
        "Cylinders": 8,
        "Displacement": 351,
        "Horsepower": 158,
        "Weight_in_lbs": 4363,
        "Acceleration": 13,
        "Year": "1973-01-01",
        "Origin": "USA"
      }
    },
{
      "id": "235",
      "data": {
        "Name": "ford granada",
        "Miles_per_Gallon": 18.5,
        "Cylinders": 6,
        "Displacement": 250,
        "Horsepower": 98,
        "Weight_in_lbs": 3525,
        "Acceleration": 19,
        "Year": "1977-01-01",
        "Origin": "USA"
      }
    },
    {
      "id": "31",
      "data": {
        "Name": "ford f250",
        "Miles_per_Gallon": 10,
        "Cylinders": 8,
        "Displacement": 360,
        "Horsepower": 215,
        "Weight_in_lbs": 4615,
        "Acceleration": 14,
        "Year": "1970-01-01",
        "Origin": "USA"
      }
    },
    "messsage": "fetch match query for multiple requests successful!"
}</pre>
<p>注意，为了简洁起见，上面的查询结果被截断了。当我们在本地运行这个查询时，您应该会得到完整的结果。别担心，POSTMAN <a href="https://www.getpostman.com/collections/3bd8ddb0131882594446">上收藏的链接在这里</a>。您可以复制它，导入到您的邮递员，并进行测试。</p>
<p>下面显示了<code>services.js</code>文件的完整代码，它包含了对集群中数据的所有查询:</p>
<pre>const esconfig = require('./esConfig');
const client = esconfig.esClient;
const config = require('./config');
const index = config.es_index;
const esb = require('elastic-builder'); //the builder

module.exports = {
  async search(){
    const requestBody = esb.requestBodySearch()
    .query(esb.matchAllQuery())
    .size(10)
    .from(1);
    return client.search({index: index, body: requestBody.toJSON()});
  },


  async filterCarsByYearMade(param) {
    const requestBody = esb.requestBodySearch()
                            .query(
                              esb.boolQuery()
                              .must(esb.matchAllQuery())
                              .filter(esb.rangeQuery('Year').gte(param).lte(param))
                            )
                            .from(1)
                            .size(5);
    return client.search({index: index, body: requestBody.toJSON()});
  },

async filterCarsByName(param) {
  const requestBody = esb.requestBodySearch()
  .query(
      esb.termQuery('Name', param))
      .sort(esb.sort('Year', 'asc')
  )
  .from(1)
  .size(10);
  return client.search({index: index, body: requestBody.toJSON()});
},
async fetchCarByName(param) {
  const requestBody = esb.requestBodySearch()
    .query(
      esb.boolQuery()
        .must(esb.matchPhraseQuery('Name', param))
    );
  return client.search({index: index, body: requestBody.toJSON()});
},
async fetchMatchMultipleQuery(origin, name,weight){
  const requestBody = esb.requestBodySearch()
      .query(
        esb.boolQuery()
          .must([
            esb.matchQuery(
              'Origin', origin,
            ),
            (
              esb.matchQuery(
                'Name', name,
              )
            ),
          ])
        .filter(esb.rangeQuery('Weight_in_lbs').gte(weight))
      )
      return client.search({index: index, body: requestBody.toJSON()});
},
async aggregateQuery(origin,cylinder,name,horsePower) {
const requestBody = esb.requestBodySearch()
.query(
    esb.boolQuery()
        .must(esb.matchQuery('Origin', origin))
        .filter(esb.rangeQuery('Cylinders').gte(cylinder))
        .should(esb.termQuery('Name', name))
        .mustNot(esb.rangeQuery('Horsepower').gte(horsePower))
        // .agg(esb.avgAggregation('avg_miles', 'Miles_per_Gallon'))
)
return client.search({index: index, body: requestBody.toJSON()});
},
};</pre>
<p>正如我们在上面的文件中看到的，这些查询可读性很强，很容易理解。我们使用了构建器库提供的<code>matchQuery</code>、<code>rangeQuery</code>、<code>termQuery</code>、<code>matchPhraseQuery</code>、<code>boolQuery</code>和<code>matchAllQuery</code>查询。对于其他可用的查询以及如何使用它们，我们可以查看elastic-builder文档的查询部分。</p>
<p><code>sort</code>命令，顾名思义，按照升序或降序对查询进行排序。<code>from</code>和<code>size</code>参数通过对返回的结果进行分页来帮助控制数据的输出。</p>
<p>另外，<code>controller.js</code>文件的代码如下所示:</p>
<pre>const Services = require('./services');

module.exports = {
  async search(req, res) {
    try {
      const result = await Services.search();
      const data = result.body.hits.hits.map((car)=&gt;{
        return {
          id: car._id,
          data: car._source
        }
      })
      res.json({ status_code: 200, success: true, data: data, message: "Cars data successfully fetched!" });
    } catch (err) {
      res.json({ status_code: 500, success: false, data: [], message: err});
    }
  },

  async  filterCarsByYearMade(req, res) {
    let {year} = req.query;
    try {
      const result = await Services.filterCarsByYearMade(year);
      const data = result.body.hits.hits.map((car)=&gt;{
        return {
          id: car._id,
          data: car._source
        }
      })
      res.json({ status_code: 200, success: true, data: data, message: "Filter Cars by year made data fetched successfully" });
    } catch (err) {
      res.json({ status_code: 500, success: false, data: [],  message: err});
    }
  },

  async filterCarsByName(req,res) {
    let param = req.query.Name;
    try {
      const result = await Services.filterCarsByName(param);
      const data = result.body.hits.hits.map((car)=&gt;{
        return {
          id: car._id,
          data: car._source
        }
      })
      res.json({status_code: 200, success: true, data:data , message: "Filter cars by name data fetched successfully!" });
    } catch (err) {
      res.json({ status_code: 500, success: false, data: [], message: err});
    }
  },


  async filterCarByName(req,res) {
    const param = req.query.Name;
    try {
      const result = await Services.fetchCarByName(param);
      const data = result.body.hits.hits.map((car)=&gt;{
        return {
          id: car._id,
          data: car._source
        }
      })
      res.json({ status_code: 200, success: true, data: data , message: "Filter a car by name query data fetched successfully!"});
    } catch (err) {
      res.json({ status_code: 500, success: false, data: [], message: err});
    }
  },

  async fetchMatchMultipleQuery(req,res) {
    const origin = req.query.Origin;
    const name = req.query.Name;
    const weight = req.query.Weight_in_lbs;
    try {
      const result = await Services.fetchMatchMultipleQuery(origin, name, weight);
      const data = result.body.hits.hits.map((car)=&gt;{
        return {
          id: car._id,
          data: car._source
        }
      })
      res.json({status_code: 200, success: true, data: data, messsage: "fetch match query for multiple requests successful!" });
    } catch (err) {
      res.json({status_code: 500, success: false, data: [], message: err});
    }
  },

  async aggregateQuery(req,res) {
    const origin = req.query.Origin;
    const cylinder = req.query.Cylinder;
    const name = req.query.Name;
    const horsePower = req.query.Horsepower;
    try {
    const result = await Services.aggregateQuery(origin, cylinder, name, horsePower);
      const data = result.body.hits.hits.map((car)=&gt;{
        return {
          id: car._id,
          data: car._source
        }
      })
      res.json({ status_code: 200, success: true, data: data, message: "Data successfully fetched!" });
    } catch (err) {
      res.json({ status_code: 500, success: false, data: [], message: err});
    }
  },

}</pre>
<p>上面的文件包含了调用我们的<code>services.js</code>文件并帮助路由请求的代码。正如我们所看到的，对于上面的每个查询，我们对返回的数据进行映射，并单独输出<code>id</code>和<code>_source</code>字段。</p>
<p>包含在<code>routes.js</code>文件中的所有查询的路径如下所示:</p>
<pre>const express    = require("express");
const controller = require("./controller");
const routes     = express.Router();

routes.route("/search-all").get(controller.search);
routes.route("/search-by-year").get(controller.filterCarsByYearMade);
routes.route("/search-by-name").get(controller.filterCarsByName);
routes.route("/search-by-name-single").get(controller.filterCarByName);
routes.route("/search-by-multiple").get(controller.fetchMatchMultipleQuery);
routes.route("/seach-avg-query").get(controller.aggregateQuery);

module.exports = routes;</pre>
<p>该文件有助于调用和路由<code>controller.js</code>文件中提供的所有函数。注意，这个项目的全部代码可以在GitHub 上找到。</p>
<h2>结论</h2>
<p>如果我们打算为高度搜索密集型应用程序执行数据聚合、度量、复杂过滤器和全文搜索功能，那么Elasticsearch是必要的。这里的好处是，我们已经能够更进一步，在使用Node.js和Elasticsearch 编写自己的搜索引擎的基础上，通过使用构建器语法扩展我们的查询，为我们的数据集编写更高级的查询和过滤器。</p>
<p>尽管有其他构建器库，但elastic-builder非常可靠、稳定，并且具有清晰、易读、易懂的语法。</p>
<p>如果您对这篇文章有任何问题、反馈或评论，请不要犹豫，在下面的评论区回复，或者通过<a href="https://twitter.com/alex_nnakwue"> Twitter </a>联系我。感谢您抽出时间阅读！</p><div class="code-block code-block-23">
<div class="blog-plug inline-plug node-plug"><h2>200只<img src="../Images/61167b9d027ca73ed5aaf59a9ec31267.png" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2019/10/green-check.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" class=" jetpack-lazy-image" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/10/green-check.png"/> <noscript> <img data-lazy-fallback="1" src="../Images/61167b9d027ca73ed5aaf59a9ec31267.png" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/10/green-check.png"/> </noscript>显示器出现故障，生产中网络请求缓慢</h2><p>部署基于节点的web应用程序或网站是容易的部分。确保您的节点实例继续为您的应用程序提供资源是事情变得更加困难的地方。如果您对确保对后端或第三方服务的请求成功感兴趣，</p><a href="https://lp.logrocket.com/blg/node-signup" target="_blank">try LogRocket</a><p>. </p><a class="signup" href="https://lp.logrocket.com/blg/node-signup" target="_blank" rel="noopener noreferrer"><img src="../Images/cae72fd2a54c5f02a6398c4867894844.png" alt="LogRocket Network Request Monitoring" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2019/12/network-request-filter-2-1.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" class=" jetpack-lazy-image" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/12/network-request-filter-2-1.png"/><noscript><img data-lazy-fallback="1" src="../Images/cae72fd2a54c5f02a6398c4867894844.png" alt="LogRocket Network Request Monitoring" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/12/network-request-filter-2-1.png"/></noscript></a><a href="https://lp.logrocket.com/blg/node-signup" target="_blank" rel="noopener noreferrer">https://logrocket.com/signup/</a><p>LogRocket 就像是网络和移动应用程序的DVR，记录下用户与你的应用程序交互时发生的一切。您可以汇总并报告有问题的网络请求，以快速了解根本原因，而不是猜测问题发生的原因。</p><p>LogRocket检测您的应用程序以记录基线性能计时，如页面加载时间、到达第一个字节的时间、慢速网络请求，还记录Redux、NgRx和Vuex操作/状态。</p><a class="signup" href="https://lp.logrocket.com/blg/node-signup" target="_blank" rel="noopener noreferrer">Start monitoring for free</a><p>. </p></div>
</div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
<html>
<head>
<title>How to write reusable CSS with SASS - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>如何用SASS - LogRocket Blog编写可重用的CSS</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/how-to-write-reusable-css-with-sass/#0001-01-01">https://blog.logrocket.com/how-to-write-reusable-css-with-sass/#0001-01-01</a></blockquote><div><article class="article-post">
<p>Sass是一个CSS预处理器，在前端工程师的工具箱中变得至关重要。Sass之所以流行，是因为它修复了一些CSS缺陷。</p>
<p>这也是<a href="https://getbootstrap.com" target="_blank" rel="noopener noreferrer"> Bootstrap 4 </a>运行的基础。这意味着学习Sass将非常有助于理解如何操作引导代码，而不是重写代码(这是大多数开发人员的定制方法)。理解Sass有助于更好地理解源代码级别的工具。</p>
<p>当使用CSS时，我们经常在一个全局的世界中工作，可能会错误地设计元素的样式。</p>
<p>自定义CSS(即使有CSS变量)还是很多余的。CSS不是为我们今天拥有的那种复杂架构而设计的，我们会遇到在另一个样式表中导入一个样式表的问题，这可能会导致一个非常大的样式库，如果没有适当的文档，可能无法理解。</p>
<h2>TL；速度三角形定位法(dead reckoning)</h2>
<p>在本文中，我们将关注预处理器为什么重要，特别强调SASS及其组合规则的能力。使用Sass为设计现代web组件提供了一种更符合逻辑的方法。</p>
<p>我们还将看看为什么我们使用这些预处理程序，并通过演示例子展示我们如何将样式分解成更小的特定组件，而不会强迫用户下载大量不需要的CSS文件。</p>
<h2>先决条件</h2>
<p>在我们进一步讨论之前，本文假设:</p>
<ul>
<li><a href="https://nodejs.org/" target="_blank" rel="noopener noreferrer"> Node.js ≥v6 </a>安装在您的机器上</li>
<li>您的机器上安装了npm </li>
<li>您的机器上安装了Sass </li>
<li><a href="https://www.npmjs.com/package/create-react-app" target="_blank" rel="noopener noreferrer"> Create-react-app </a>已安装在您的机器上</li>
<li>你对CSS有一个基本的了解</li>
</ul>
<h2>入门指南</h2>
<p>Sass可以以多种方式添加到你的项目中，你可以在这里找到所有的分期付款选项。出于本文的考虑，我们将通过运行以下命令来使用<a href="https://www.npmjs.com/" target="_blank" rel="noopener noreferrer"> npm </a>:</p>
<pre>npm install -g sass</pre>
<h2>CSS有什么问题？</h2>
<p>在学习web开发的基础知识时，我们会接触到传统的CSS，它涉及到使用类或id等标识符来处理和操作HTML。</p>
<p>在使用CSS的时候，我们经常不得不改变样式，让它看起来像我们想要的样子。组织大型样式表真的很有压力。保持类的范围以避免以非预期的方式设计东西几乎是很累的。</p>
<p>即使引入了CSS变量来减少声明的重复，这个概念还是有一些问题可以通过使用预处理器来解决。例如使用长变量名。</p>
<p>即使有了CSS3，我们仍然需要依靠技术(基本上是黑客)来设计用户界面。我们还可以注意到，在编写HTML时，有一个清晰的嵌套和可视化的层次结构，这是常规CSS所不允许的。</p>
<p>让我们看看CSS中缺少的特性的“解决方案”。</p>
<h2>什么是CSS预处理程序？</h2>
<p>这些基本上可以被认为是一个程序，让您从预处理程序自己独特的语法生成CSS。CSS预处理器一般会增加一些纯CSS中没有的特性，比如<a href="https://sass-lang.com/documentation/at-rules/mixin" target="_blank" rel="noopener noreferrer"> mixin </a>、<a href="http://thesassway.com/beginner/the-inception-rule" target="_blank" rel="noopener noreferrer">嵌套选择器</a>、<a href="https://github.com/webplatform/webplatform.github.io/blob/master/docs/tutorials/inheritance_and_cascade/index.html" target="_blank" rel="noopener noreferrer">继承选择器</a>。同时也为我们提供了一种非常结构化的编写样式表的方法。CSS预处理器的例子包括<a href="http://lesscss.org" target="_blank" rel="noopener noreferrer"> LESS </a>、<a href="http://stylus-lang.com" target="_blank" rel="noopener noreferrer"> stylus </a>、<a href="https://sass-lang.com" target="_blank" rel="noopener noreferrer"> Sass </a>、<a href="https://postcss.org" target="_blank" rel="noopener noreferrer">postscs</a>。如前所述，本文主要关注作为预处理器的Sass。</p>
<p><img data-attachment-id="6663" data-permalink="https://blog.logrocket.com/how-to-write-reusable-css-with-sass/csspreprocessor-nocdn/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2019/09/csspreprocessor-nocdn.jpeg" data-orig-size="451,285" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;PRATHAP KUDUPU&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="csspreprocessor-nocdn" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2019/09/csspreprocessor-nocdn-300x190.jpeg" data-large-file="https://blog.logrocket.com/wp-content/uploads/2019/09/csspreprocessor-nocdn.jpeg" decoding="async" class="aligncenter wp-image-6663 size-full jetpack-lazy-image" src="../Images/ddc02ba55734a753ebd7d8cc5f26d652.png" alt="csspreprocessors" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2019/09/csspreprocessor-nocdn.jpeg 451w, https://blog.logrocket.com/wp-content/uploads/2019/09/csspreprocessor-nocdn-300x190.jpeg 300w" data-lazy-sizes="(max-width: 451px) 100vw, 451px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2019/09/csspreprocessor-nocdn.jpeg?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/09/csspreprocessor-nocdn.jpeg"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="6663" data-permalink="https://blog.logrocket.com/how-to-write-reusable-css-with-sass/csspreprocessor-nocdn/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2019/09/csspreprocessor-nocdn.jpeg" data-orig-size="451,285" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;PRATHAP KUDUPU&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="csspreprocessor-nocdn" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2019/09/csspreprocessor-nocdn-300x190.jpeg" data-large-file="https://blog.logrocket.com/wp-content/uploads/2019/09/csspreprocessor-nocdn.jpeg" decoding="async" loading="lazy" class="aligncenter wp-image-6663 size-full" src="../Images/ddc02ba55734a753ebd7d8cc5f26d652.png" alt="csspreprocessors" srcset="https://blog.logrocket.com/wp-content/uploads/2019/09/csspreprocessor-nocdn.jpeg 451w, https://blog.logrocket.com/wp-content/uploads/2019/09/csspreprocessor-nocdn-300x190.jpeg 300w" sizes="(max-width: 451px) 100vw, 451px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/09/csspreprocessor-nocdn.jpeg"/></noscript>
<h2>萨斯还是SCSS？</h2>
<p>现在，如果你不熟悉Sass这个概念，你可能会想，“如果Sass是预处理器，那么SCSS是什么？”因为缺少分号<code>;</code>和花括号<code>{}</code>，使用Sass会有点混乱，所以用制表符和空格来代替。</p>
<p>在Sass的版本3中，SCSS语法作为Sass的主要语法被引入，它包含了CSS的所有特性，但是允许使用Sass的特性。在我看来，这两种语法在样式化时都有效，没有一种比另一种更好。对SCSS的需求是使Sass的学习曲线和实现更快并且没有错误。</p>
<p>萨斯:萨斯:</p>
<pre>$font-stack:    Helvetica, sans-serif
$primary-color: #333

body
  font: 100% $font-stack
  color: $primary-color</pre>
<p>在上面的代码示例中，我们注意到了萨斯和SCSS写作风格的不同。注意，它们都使用<code>$</code>来声明一个变量。</p>
<pre>$font-stack:    Helvetica, sans-serif;
$primary-color: #333;

body {
  font: 100% $font-stack;
  color: $primary-color;
}</pre>
<p>SCSS的概念</p>
<h2>嵌套和范围</h2>
<h3>当设计HTML文件的样式时，SCSS可以让你在样式表中拥有和HTML相同的视觉层次，这样你就可以用一种更容易理解的方式来设计你的样式。例如，对这个<code>index.html</code>进行造型:</h3>
<p>CSS:</p>
<pre>&lt;nav class = 'sidebar'&gt;
  &lt;ul&gt;
    &lt;li&gt; &lt;a&gt; &lt;/a&gt;&lt;/li&gt;
  &lt;/ul&gt;
&lt;/nav&gt;</pre>
<p>SCSS:</p>
<pre>nav ul {
  margin: 0;
  padding: 0;
  list-style: none;
}
nav li {
  display: inline-block;
}
nav a {
  display: block;
  padding: 6px 12px;
  text-decoration: none;
}</pre>
<p>从上面的CSS代码示例中我们可以看到，我们能够推导出HTML文件的结构，同时保持实现简短。这样做的另一个好处是，它有助于避免拼写错误，另外，您可以看到，我们已经确定了一些规则的范围，因此它们只适用于<code>nav</code>。</p>
<pre>nav {
  ul {
    margin: 0;
    padding: 0;
    list-style: none;
  }

  li { display: inline-block; }

  a {
    display: block;
    padding: 6px 12px;
    text-decoration: none;
  }
}</pre>
<p>后代风格规则适用于SCSS，例如:</p>
<p>这意味着拥有<code>class = "left-area"</code>的容器类的所有后代都将受到规则的影响。基本的CSS选择器仍然适用于SCSS，例如:</p>
<pre>.container{
.left-area{
  ...
}
}</pre>
<p>直系后代(&gt;)</p>
<h2>现在，只有容器div的直接子类才会获得样式。</h2>
<pre>.container{
  &gt; .left-area{
   ...
 }
}</pre>
<p>父选择器(&amp;)</p>
<h2>如果我们想通过添加一个类来修改一个类，我们可以使用父选择器，它主要用于添加辅助样式改变元素样式的情况。这也将起到改性剂的作用。</h2>
<p>我们还可以使用父选择器将角色范围扩大到另一个类，如下所示:</p>
<pre>.container{
  &amp; .right-area{
   background-color : #0000
 }
}</pre>
<p>在代码示例中，由于父选择器的原因，颜色<code>#fff</code>仅适用于<code>.theme-dark</code>类。</p>
<pre>button{
  color:#349;
  .theme-dark &amp;{
    color: #fff
}
}</pre>
<p>变量</p>
<h2>通常，在CSS中，我们通过使用<code>@import</code>将另一个样式表引入主CSS来链接各种样式表。这对用户意味着什么？这意味着必须下载额外的CSS文件。</h2>
<p>如果有一种方法可以使用SCSS将所有这些输入解析到一个CSS文件中会怎么样呢？CSS中变量的概念来自JavaScript方法。</p>
<p>更多来自LogRocket的精彩文章:</p><div class="code-block code-block-54">
<hr/>
<h3>请注意，SCSS的<code>@import</code>用于将部分内容放入其他SCSS文件，但它们不会变成CSS文件。它们通过在名称前加上<code>_</code>来表示。</h3>

<hr/></div>
<p>使用SCSS变量</p>
<h2><strong>全局变量:</strong>顾名思义，这些是可以在一个CSS块中访问的变量。如果你熟悉JavaScript中的作用域，你就会理解<a href="https://funprogramming.org/50-What-are-global-and-local-variables.html" target="_blank" rel="noopener noreferrer">全局变量</a>。</h2>
<p>SCSS的变量总是以美元符号<code>$</code>开头。</p>
<p>从上面的代码中，我们注意到<code>$text_color</code>只能在代码块中被访问。</p>
<pre>$color: #f002
.color{
  $text_color: #ddd;
  background-color: $color;
  color: $text_color;
  text-shadow:0 0 2px darken($text_color, 40%);
}</pre>
<p>混合蛋白</p>
<h2>SCSS的另一个令人敬畏的特性是它能够将可重用的样式打包在一起，并允许按需导入到另一个样式块中，以减少代码中的冗余。</h2>
<p>申报</p>
<h2>创建mixin很简单，只需在样式块前添加一个<code>@mixin</code>后跟mixin名称，如下所示:</h2>
<p>使用</p>
<pre>@mixin {insert name} {
     //write CSS code here
}</pre>
<h2>要在代码块中使用mixin，我们必须使用<code>@include</code>，后跟mixin的名称，然后是分号。这有助于在代码块中使用预定义的mixin:</h2>
<p>使用mixin的另一种方式是使用参数，就像JavaScript中的函数一样，我们可以声明一个全局变量，并将其设置为mixin的参数:</p>
<pre>.nav {
   @include {mixin name}
}</pre>
<p>现在想象一下，如果我们想要一个mixin的默认值，并在不同的代码块中改变或重新分配这个值，我们将使用一些参数。为了说明这一点，我将重构前面的代码示例:</p>
<pre>@mixin text-color($color){
  background-color: $color;
  color: white;
}

//import 
.name{
  @include text-color(orange);
}
.background{
  @include text-color(white)
}</pre>
<p>这样做的是，它为mixin设置一个默认的颜色作为基础，但是它可以通过重新分配来修改。我们还可以将值设置为<code>null</code>,以便在mixin中只使用我们需要的参数:</p>
<pre>@mixin text-color($color : #fff){
  background-color: $color;
  color: white;
}

//import 
.name{
  @include text-color(orange);
}
.background{
  @include text-color($color: white)
}</pre>
<p>这样做的目的是使显示为null的值在<code>@include</code>导入中没有值，但默认显示其他值。</p>
<pre>@mixin text-color($color : null){
  background-color: $color;
  color: #038;
}

//import 
.name{
  @include text-color();
}
.background{
  @include text-color(#fff)
}</pre>
<p>通过减速块:</p>
<p>代码块基本上允许我们通过样式化父类和定义内部类来保持样式化的简单。</p>
<pre>@mixin text-color($color){
  color: $color;
  .extra{
  @content
  }
}

//import 
.name{
  @include text-color(#fff){
    color: blue;
  }
}</pre>
<p>值得注意的信息</p>
<h2>Mixins并不评估为CSS文件，它们是被设计用来消费的，所以在SCSS你通常会把它们看作是<a href="https://dev.to/sarah_chima/using-sass-partials-7mh" target="_blank" rel="noopener noreferrer">部分</a></h2>
<ul>
<li>Mixins前面不需要带点(。)</li>
<li>功能</li>
</ul>
<h2>SCSS中的函数是SASS特性的一个重要部分，它们允许你定义复杂的操作，这些操作在你的样式表中是可重用的。有许多内置的Sass函数可以提供帮助。查看<a href="https://sass-lang.com/documentation/at-rules/function" target="_blank" rel="noopener noreferrer">文档</a>了解更多信息。</h2>
<p>这里列出了一些您应该熟悉的功能</p>
<p>我们也可以编写自己的Sass函数:</p>

<p>当使用正常宽度作为参数调用函数时，上面的函数只是将值加倍。</p>
<pre>$width: 4px;
@function double($x){
  @return 2 * $x;
}
.thin-border{
  border-width: $width
}
.thick-border{
  broder-width:double($width)
}</pre>
<p>使用控制流的条件样式</p>
<h2>这个特性很棒，因为它允许我们使用<code>@if</code>和<code>@else</code>声明，基于另一个样式的值来替换一个特定的样式。例如，为不同的字体大小值动态增加行高。</h2>
<p>其他一些需要注意的特性</p>
<pre>@mixin modify($size){
 font-size: $size;
 @if $size &gt; 18{
 line-height: $size;
 }
}

//import 
.name{
 @include modify(24px)
 }</pre>
<h2>注释–SCSS中的多行注释在CSS中以同样的方式显示，但是行内注释被移除。它们可以用于字符串插值(知道CSS中实际显示的是什么值)</h2>
<ul>
<li>Sass还附带了用于迭代的<code>@for</code>和用于混合和函数的<a href="https://sass-lang.com/documentation/at-rules/control" target="_blank" rel="noopener noreferrer">控制流</a></li>
<li>结论</li>
</ul>
<h2>在这篇文章中，我们试图理解用SCSS编写函数式CSS的基础知识，同时也大致了解了一些萨斯/SCSS原则。我希望我们将这些实践用于为我们的应用程序编写更轻松、更优化的样式。编码快乐！😄</h2>
<p>你的前端是否占用了用户的CPU？</p><div class="code-block code-block-25">
<div class="blog-plug inline-plug css-plug"><h2>随着web前端变得越来越复杂，资源贪婪的特性对浏览器的要求越来越高。如果您对监控和跟踪生产环境中所有用户的客户端CPU使用情况、内存使用情况等感兴趣，</h2><p>.</p><a target="_blank" href="https://lp.logrocket.com/blg/css-signup">try LogRocket</a><p>LogRocket 就像是网络和移动应用的DVR，记录你的网络应用或网站上发生的一切。您可以汇总和报告关键的前端性能指标，重放用户会话和应用程序状态，记录网络请求，并自动显示所有错误，而不是猜测问题发生的原因。</p><a class="signup" href="https://lp.logrocket.com/blg/css-signup" target="_blank" rel="noopener noreferrer"><img class="alignnone size-full wp-image-46 jetpack-lazy-image" src="../Images/dacb06c713aec161ffeaffae5bd048cd.png" alt="LogRocket Dashboard Free Trial Banner" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2019/12/cpu-memory-usage.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/12/cpu-memory-usage.png"/><noscript><img data-lazy-fallback="1" class="alignnone size-full wp-image-46" src="../Images/dacb06c713aec161ffeaffae5bd048cd.png" alt="LogRocket Dashboard Free Trial Banner" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/12/cpu-memory-usage.png"/></noscript></a><a href="https://lp.logrocket.com/blg/css-signup" target="_blank" rel="noopener noreferrer">https://logrocket.com/signup/</a><p>现代化您调试web和移动应用的方式— <a class="signup" href="https://lp.logrocket.com/blg/css-signup" target="_blank" rel="noopener noreferrer">开始免费监控</a>。</p><p>Modernize how you debug web and mobile apps — <a class="signup" href="https://lp.logrocket.com/blg/css-signup" target="_blank" rel="noopener noreferrer">Start monitoring for free</a>.</p></div>
</div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
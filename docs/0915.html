<html>
<head>
<title>How to build a GraphQL API with NestJS - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>如何用NestJS - LogRocket博客构建一个GraphQL API</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/how-to-build-a-graphql-api-with-nestjs/#0001-01-01">https://blog.logrocket.com/how-to-build-a-graphql-api-with-nestjs/#0001-01-01</a></blockquote><div><article class="article-post">
<p><a href="https://nestjs.com/" target="_blank" rel="noopener noreferrer"> NestJS </a>是一个TypeScript Node.js框架，帮助你构建企业级的、高效的、可伸缩的Node.js应用。它支持RESTful和GraphQL API设计方法。</p>
<p>在之前的一篇文章中，我们介绍了如何使用NestJS 构建RESTful APIs。在本教程中，我们将演示如何使用NestJS来利用GraphQL APIs的强大功能。</p>
<p>GraphQL是一种用于API的查询语言，也是一个用现有数据完成这些查询的运行时。它为API中的数据提供了一个完整的、可理解的描述，使客户能够准确地要求他们需要的东西，使API更容易随时间发展，并有助于使用强大的开发工具。</p>
<p>Nest提供了两种构建GraphQL APIs的方法:<a href="https://blog.logrocket.com/code-first-vs-schema-first-development-graphql/" target="_blank" rel="noopener noreferrer">代码优先和模式优先</a>。代码优先的方法包括使用TypeScript类和decorators来生成GraphQL模式。使用这种方法，您可以将数据模型类作为模式重用，并用<code>@ObjectType()</code> decorator修饰它，Nest将从您的模型自动生成模式。模式优先的方法包括使用GraphQL的<a href="https://graphql.org/learn/schema/">模式定义语言(SDL) </a>定义模式，然后通过匹配模式中的定义来实现服务。</p>
<h2 id="setup">设置</h2>
<h3>安装NestJS</h3>
<p>开始一个Nest项目很简单。Nest提供了一个CLI，您可以使用它来生成一个新项目。如果您已经安装了<a href="https://www.npmjs.com/get-npm" target="_blank" rel="noopener noreferrer"> npm </a>，那么您可以使用下面的命令创建一个新的嵌套项目。</p>
<pre> npm i -g @nestjs/cli
nest new project-name
</pre>
<p>Nest将使用<code>project-name</code>创建一个项目目录，并添加一些样板文件。</p>
<p><img data-attachment-id="19851" data-permalink="https://blog.logrocket.com/how-to-build-a-graphql-api-with-nestjs/nestjs-boilerplate-files/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/06/nestjs-boilerplate-files.png" data-orig-size="720,116" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="NestJS boilerplate files" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/06/nestjs-boilerplate-files-300x48.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/06/nestjs-boilerplate-files.png" decoding="async" class="aligncenter size-full wp-image-19851 jetpack-lazy-image" src="../Images/77e49d5a6e2911f263b14f3ed5f97434.png" alt="NestJS Boilerplate Files" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2020/06/nestjs-boilerplate-files.png 720w, https://blog.logrocket.com/wp-content/uploads/2020/06/nestjs-boilerplate-files-300x48.png 300w" data-lazy-sizes="(max-width: 720px) 100vw, 720px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2020/06/nestjs-boilerplate-files.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/06/nestjs-boilerplate-files.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="19851" data-permalink="https://blog.logrocket.com/how-to-build-a-graphql-api-with-nestjs/nestjs-boilerplate-files/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/06/nestjs-boilerplate-files.png" data-orig-size="720,116" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="NestJS boilerplate files" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/06/nestjs-boilerplate-files-300x48.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/06/nestjs-boilerplate-files.png" decoding="async" loading="lazy" class="aligncenter size-full wp-image-19851" src="../Images/77e49d5a6e2911f263b14f3ed5f97434.png" alt="NestJS Boilerplate Files" srcset="https://blog.logrocket.com/wp-content/uploads/2020/06/nestjs-boilerplate-files.png 720w, https://blog.logrocket.com/wp-content/uploads/2020/06/nestjs-boilerplate-files-300x48.png 300w" sizes="(max-width: 720px) 100vw, 720px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/06/nestjs-boilerplate-files.png"/></noscript>
<h3>添加GraphQL</h3>
<p>在幕后，Nest使用<a href="https://www.apollographql.com/" target="_blank" rel="noopener noreferrer"> Apollo </a> GraphQL服务器实现将GraphQL用于Nest应用程序。为了向我们的Nest项目添加API，我们需要安装Apollo Server和其他GraphQL依赖项。</p>
<pre>$ npm i --save @nestjs/graphql graphql-tools graphql apollo-server-express
</pre>
<p>安装完依赖项后，您现在可以将<code>GraphQLModule</code>导入到<code>AppModule</code>中。</p>
<pre>//src/app.module.ts

import { Module } from '@nestjs/common';
import { GraphQLModule } from '@nestjs/graphql';

@Module({
  imports: [
    GraphQLModule.forRoot({}),
  ],
})
export class AppModule {}
</pre>
<p>是Apollo服务器的包装器。它提供了一个静态方法<code>forRoot()</code>，用于配置底层的Apollo实例。<code>forRoot()</code>方法接受传递给Apollo服务器构造函数的<a href="https://www.apollographql.com/docs/apollo-server/api/apollo-server/#constructor-options-lt-ApolloServer-gt" target="_blank" rel="noopener noreferrer">选项</a>列表。</p>
<h3>添加数据库</h3>
<p>嵌套是数据库不可知的；它允许与任何数据库、<a href="https://www.tutorialspoint.com/phalcon/phalcon_object_document_mapper.htm" target="_blank" rel="noopener noreferrer">对象文档映射器(ODM) </a>或对象关系映射器(ORM)集成。出于本指南的目的，我们将使用PostgreSQL和<a href="https://blog.logrocket.com/how-build-graphql-api-typegraphql-typeorm/" target="_blank" rel="noopener noreferrer"> TypeORM </a>。Nest团队建议将TypeORM与Nest一起使用，因为它是TypeScript可用的最成熟的ORM。因为它是用TypeScript编写的，所以它与Nest框架集成得很好。Nest提供了用于处理TypeORM的<code>@nestjs/typeorm</code>包。</p>
<p>让我们安装这些依赖项</p>
<pre>$ npm install --save @nestjs/typeorm typeorm pg
</pre>
<p>一旦安装过程完成，我们就可以使用<code>TypeOrmModule</code>连接到数据库。</p>
<pre>// src/app.module.ts

import { Module } from '@nestjs/common';
import { AppController } from './app.controller';
import { AppService } from './app.service';
import { GraphQLModule } from '@nestjs/graphql';
import { TypeOrmModule } from '@nestjs/typeorm'
@Module({
  imports: [
    GraphQLModule.forRoot({
      autoSchemaFile: 'schema.gql'
    }),
    TypeOrmModule.forRoot({
      type: 'postgres',
      host: 'localhost',
      port: 5432,
      username: 'godwinekuma',
      password: '',
      database: 'invoiceapp',
      entities: ['dist/**/*.model.js'],
      synchronize: false,
    }),
  ],
  controllers: [AppController],
  providers: [AppService],
})
export class AppModule { }
</pre>
<h2 id="resolvers">下决心者</h2>
<p><a href="https://www.apollographql.com/docs/tutorial/resolvers/" target="_blank" rel="noopener noreferrer">解析器</a>提供将GraphQL操作(查询、变异或订阅)转换成数据的指令。它们要么返回我们在模式中指定的数据类型，要么返回对该数据的承诺。<code>@nestjs/graphql</code>包使用用于注释类的decorators提供的元数据自动生成一个解析器映射。为了演示如何使用包特性来创建GraphQL API，我们将创建一个简单的invoice API。</p>
<p>为了构建我们的API，我们将使用代码优先的方法。</p>
<h3>对象类型</h3>
<p>对象类型是GraphQL模式最基本的组成部分。它是可以从服务中获取的字段集合，每个字段声明一种类型。定义的每个对象类型代表API中的一个域对象。例如，我们的示例发票API需要能够获取客户及其发票的列表，因此我们应该定义<code>Customer</code>和<code>Invoice</code>对象类型来支持该功能。</p>
<p>由于我们使用代码优先的方法，我们将使用TypeScript类定义模式，然后使用<a href="https://blog.logrocket.com/a-practical-guide-to-typescript-decorators/" target="_blank" rel="noopener noreferrer"> TypeScript装饰器</a>来注释这些类的字段。</p>
<pre>// src/invoice/customer.model.ts

import { Entity, Column, PrimaryGeneratedColumn, CreateDateColumn, UpdateDateColumn, OneToMany } from 'typeorm';
import { ObjectType, Field } from '@nestjs/graphql';
import { InvoiceModel } from '../invoice/invoice.model';
@ObjectType()
@Entity()
export class CustomerModel {
  @Field()
  @PrimaryGeneratedColumn('uuid')
  id: string;
  @Field()
  @Column({ length: 500, nullable: false })
  name: string;
  @Field()
  @Column('text', { nullable: false })
  email: string;
  @Field()
  @Column('varchar', { length: 15 })
  phone: string;
  @Field()
  @Column('text')
  address: string;
  @Field(type =&gt; [InvoiceModel], { nullable: true })
  @OneToMany(type =&gt; InvoiceModel, invoice =&gt; invoice.customer)
  invoices: InvoiceModel[]
  @Field()
  @Column()
  @CreateDateColumn()
  created_at: Date;
  @Field()
  @Column()
  @UpdateDateColumn()
  updated_at: Date;
}
</pre>
<p>注意，我们用来自<code>@nestjs/graphql</code>的<code>@ObjectTpye()</code>修饰了这个类。装饰器告诉Nest这个类是一个对象类。</p>
<h3>田</h3>
<p>我们上面的<code>CustomerModel</code>类中的每个属性都用<code>@Field()</code>装饰器来装饰。Nest要求我们在模式定义类中显式使用<code>@Field()</code>装饰器来提供关于每个字段的GraphQL类型和可选性的元数据。</p>
<p>字段的GraphQL类型可以是标量类型，也可以是其他对象类型。GraphQL自带了一组默认的<a href="https://graphql.org/learn/schema/#scalar-types" target="_blank" rel="noopener noreferrer">标量类型</a>:<code>Int</code>、<code>String</code>、<code>ID</code>、<code>Float</code>和<code>Boolean</code>。<code>@Field()</code>装饰器接受可选的类型函数(例如，type = &gt; Int)和可选的选项对象。</p>
<p>当字段是数组时，我们必须在<code>@Field()</code> decorator的type函数中手动指明数组类型，如下所示。</p>
<pre> @Field(type =&gt; [InvoiceModel])
  invoices: InvoiceModel[]
</pre>
<p>现在我们已经创建了<code>CustomerModel</code>对象类型，让我们定义<code>InvoiceModel</code>对象类型。</p>
<pre>// src/invoice/invoice.model.ts

import { CustomerModel } from './../customer/customer.model';
import { Entity, Column, PrimaryGeneratedColumn, CreateDateColumn, UpdateDateColumn, JoinColumn, ManyToOne, ChildEntity } from 'typeorm';
import { ObjectType, Field } from '@nestjs/graphql';
export enum Currency {
  NGN = "NGN",
  USD = "USD",
  GBP = "GBP",
  EUR = " EUR"
}
export enum PaymentStatus {
  PAID = "PAID",
  NOT_PAID = "NOT_PAID",
}
@ObjectType()
export class Item{
  @Field()
  description: string;
  @Field()
  rate: number;
  @Field()
  quantity: number 
}
@ObjectType()
@Entity()
export class InvoiceModel {
  @Field()
  @PrimaryGeneratedColumn('uuid')
  id: string;
  @Field()
  @Column({ length: 500, nullable: false })
  invoiceNo: string;
  @Field()
  @Column('text')
  description: string;
  @Field(type =&gt; CustomerModel)
  @ManyToOne(type =&gt; CustomerModel, customer =&gt; customer.invoices)
  customer: CustomerModel;
  @Field()
  @Column({
    type: "enum",
    enum: PaymentStatus,
    default: PaymentStatus.NOT_PAID
  })
  paymentStatus: PaymentStatus;
  @Field()
  @Column({
    type: "enum",
    enum: Currency,
    default: Currency.USD
  })
  currency: Currency;
  @Field()
  @Column()
  taxRate: number;
  @Field()
  @Column()
  issueDate: string;
  @Field()
  @Column()
  dueDate: string;
  @Field()
  @Column('text')
  note: string;
  @Field( type =&gt; [Item])
  @Column({
    type: 'jsonb',
    array: false,
    default: [],
    nullable: false,
  })
  items: Item[];
  @Column()
  @Field()
  taxAmount: number;
  @Column()
  @Field()
  subTotal: number;
  @Column()
  @Field()
  total: string;
  @Column({
    default: 0
  })
  @Field()
  amountPaid: number;
  @Column()
  @Field()
  outstandingBalance: number;
  @Field()
  @Column()
  @CreateDateColumn()
  createdAt: Date;
  @Field()
  @Column()
  @UpdateDateColumn()
  updatedAt: Date;
}
</pre>
<h3>GraphQL特殊对象类型</h3>
<p>我们已经看到了如何用Nest定义对象类型。但是GraphQL中有两种特殊类型:<code>Query</code>和<code>Mutation</code>。这些对象充当其他对象类型的父对象，并且很特殊，因为它们定义了其他对象的入口点。每个GraphQL API都有一个<code>Query</code>类型，可能有也可能没有<code>Mutation</code>类型。</p>
<p>我们的发票API应该有一个类似下面的查询。</p>
<pre>type Query {
  customer: CustomerModel
  invoice: InvoiceModel
}
</pre>
<p>创建了应该存在于我们的图中的对象之后，我们现在可以定义我们的resolver类来为我们的客户端提供一种与我们的API进行交互的方式。在代码优先方法中，解析器类既定义解析器函数，又生成<code>Query</code>类型。为了创建一个解析器，我们将创建一个使用解析器函数作为方法的类，并用<code>@Resolver()</code>装饰器来装饰这个类。</p>
<pre>//src/customer/customer.resolver.ts

import { InvoiceModel } from './../invoice/invoice.model';
import { InvoiceService } from './../invoice/invoice.service';
import { CustomerService } from './customer.service';
import { CustomerModel } from './customer.model';
import { Resolver, Mutation, Args, Query, ResolveField, Parent } from '@nestjs/graphql';
import { Inject } from '@nestjs/common';
@Resolver(of =&gt; CustomerModel)
export class CustomerResolver {
  constructor(
    @Inject(CustomerService) private customerService: CustomerService,
    @Inject(InvoiceService) private invoiceService: InvoiceService
  ) { }
  @Query(returns =&gt; CustomerModel)
  async customer(@Args('id') id: string): Promise&lt;CustomerModel&gt; {
    return await this.customerService.findOne(id);
  }
  @ResolveField(returns =&gt; [InvoiceModel])
  async invoices(@Parent() customer) {
    const { id } = customer;
    console.log(customer);
    return this.invoiceService.findByCustomer(id);
  }
  @Query(returns =&gt; [CustomerModel])
  async customers(): Promise&lt;CustomerModel[]&gt; {
    return await this.customerService.findAll();
  }
}
</pre>
<p><code>@Resolver()</code> decorator接受一个可选参数，用于指定字段解析器函数的父函数。在上面的例子中，我们创建了<code>CustomerResolver</code>，它定义了一个查询解析器函数和一个字段解析器函数。为了指定该方法是一个查询处理程序，我们用<code>@Query()</code>装饰器对该方法进行了注释。我们使用<code>@ResolveField()</code>来注释解析<code>CustomerModel</code>的<code>invoices</code>字段的方法。<code>@Args()</code>装饰器用于从请求中提取参数，以便在查询处理程序中使用。</p>
<h3>图QL操场</h3>
<p>既然我们已经创建了graph服务的入口点，我们可以通过playground查看我们的GraphQL API。playground是一个图形化的、交互式的、浏览器内置的GraphQL IDE，默认情况下，它与GraphQL服务器位于同一个URL上。要访问操场，我们需要运行我们的GraphQL服务器。</p>
<p>运行以下命令启动服务器。</p>
<pre>npm start
</pre>
<p>在服务器运行的情况下，打开您的网络浏览器并导航至<code><a href="http://localhost:3000/graphql" rel="nofollow">http://localhost:3000/graphql</a></code>查看操场。</p>
<p><img data-attachment-id="19850" data-permalink="https://blog.logrocket.com/how-to-build-a-graphql-api-with-nestjs/graphql-playground/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/06/graphql-playground.png" data-orig-size="720,391" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="GraphQL playground" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/06/graphql-playground-300x163.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/06/graphql-playground.png" decoding="async" class="aligncenter size-full wp-image-19850 jetpack-lazy-image" src="../Images/92d491045889efeb824b657bebbffbfc.png" alt="GraphQL Playground" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2020/06/graphql-playground.png 720w, https://blog.logrocket.com/wp-content/uploads/2020/06/graphql-playground-300x163.png 300w" data-lazy-sizes="(max-width: 720px) 100vw, 720px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2020/06/graphql-playground.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/06/graphql-playground.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="19850" data-permalink="https://blog.logrocket.com/how-to-build-a-graphql-api-with-nestjs/graphql-playground/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/06/graphql-playground.png" data-orig-size="720,391" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="GraphQL playground" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/06/graphql-playground-300x163.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/06/graphql-playground.png" decoding="async" loading="lazy" class="aligncenter size-full wp-image-19850" src="../Images/92d491045889efeb824b657bebbffbfc.png" alt="GraphQL Playground" srcset="https://blog.logrocket.com/wp-content/uploads/2020/06/graphql-playground.png 720w, https://blog.logrocket.com/wp-content/uploads/2020/06/graphql-playground-300x163.png 300w" sizes="(max-width: 720px) 100vw, 720px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/06/graphql-playground.png"/></noscript>
<h2 id="mutations">突变</h2>
<p>我们已经介绍了如何从GraphQL服务器检索数据，但是修改服务器端数据又如何呢？变异方法用于修改GraphQL中的服务器端数据。</p>
<p>从技术上讲，可以实现一个<code>Query</code>来添加服务器端数据。但是通常的惯例是用<code>@Mutations()</code>装饰器注释任何导致数据写入的方法。装饰者告诉Nest，这样的方法是用于数据修改的。</p>
<p>让我们将新的<code>createCustomer()</code>添加到解析器中。</p>
<pre>  @Mutation(returns =&gt; CustomerModel)
  async createCustomer(
    @Args('name') name: string,
    @Args('email') email: string,
    @Args('phone', { nullable: true }) phone: string,
    @Args('address', { nullable: true }) address: string,
  ): Promise&lt;CustomerModel&gt; {
    return await this.customerService.create({ name, email, phone, address })
  }
</pre>
<p><code>createCustomer()</code>已经用<code>@Mutations()</code>修饰，表示它修改或添加了新数据。</p>
<p>如果一个突变需要将一个对象作为参数，我们将需要创建一个特殊的名为<code>InputType</code>的对象，然后作为参数传递给方法。要声明一个输入类型，使用<code>@InputType()</code>装饰器。</p>
<pre>import { PaymentStatus, Currency, Item } from "./invoice.model";
import { InputType, Field } from "@nestjs/graphql";
@InputType()
class ItemDTO{
    @Field()
    description: string;
    @Field()
    rate: number;
    @Field()
    quantity: number
}
@InputType()
export class CreateInvoiceDTO{
@Field()
customer: string;
@Field()    
invoiceNo: string;
@Field()
paymentStatus: PaymentStatus;
@Field()
description: string;
@Field()
currency: Currency;
@Field()
taxRate: number;
@Field()
issueDate: Date;
@Field()
dueDate: Date;
@Field()
note: string;
@Field(type =&gt; [ItemDTO])
items: Array&lt;{ description: string; rate: number; quantity: number }&gt;;
}



 @Mutation(returns =&gt; InvoiceModel)
  async createInvoice(
    @Args('invoice') invoice: CreateInvoiceDTO,
  ): Promise&lt;InvoiceModel&gt; {
    return await this.invoiceService.create(invoice)
  }
</pre>
<h2 id="conclusion">结论</h2>
<p>我们演示了如何使用代码优先的方法通过Nest构建GraphQL API。你可以在<a href="https://github.com/GodwinEkuma/invoice-app"> GitHub </a>上找到这里分享的完整版示例代码。</p>
<p>要了解关于模式优先方法和其他最佳实践的更多信息，请查看<a href="https://docs.nestjs.com/graphql/quick-start" target="_blank" rel="noopener noreferrer"> Nest文档</a>。</p><div class="code-block code-block-21">
<div class="blog-plug inline-plug typescript-plug"><h2><a class="signup" href="https://lp.logrocket.com/blg/typescript-signup" target="_blank" rel="noopener noreferrer"> LogRocket </a>:全面了解您的网络和移动应用</h2>
<a href="https://lp.logrocket.com/blg/typescript-signup" class="signup" target="_blank" rel="noopener noreferrer"><img class="alignnone size-full wp-image-46 jetpack-lazy-image" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/><noscript><img data-lazy-fallback="1" class="alignnone size-full wp-image-46" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/></noscript></a>
<p>LogRocket 是一个前端应用程序监控解决方案，可以让您回放问题，就像问题发生在您自己的浏览器中一样。LogRocket不需要猜测错误发生的原因，也不需要向用户询问截图和日志转储，而是让您重放会话以快速了解哪里出错了。它可以与任何应用程序完美配合，不管是什么框架，并且有插件可以记录来自Redux、Vuex和@ngrx/store的额外上下文。</p>
<p>除了记录Redux操作和状态，LogRocket还记录控制台日志、JavaScript错误、堆栈跟踪、带有头+正文的网络请求/响应、浏览器元数据和自定义日志。它还使用DOM来记录页面上的HTML和CSS，甚至为最复杂的单页面和移动应用程序重新创建像素级完美视频。</p><div class="code-block code-block-24">
<div class="blog-plug inline-plug graphql-plug"><h2>监控生产中失败和缓慢的GraphQL请求</h2><p>虽然GraphQL有一些调试请求和响应的特性，但确保GraphQL可靠地为您的生产应用程序提供资源是一件比较困难的事情。如果您对确保对后端或第三方服务的网络请求成功感兴趣，</p><a href="https://lp.logrocket.com/blg/graphql-signup" target="_blank">try LogRocket</a><p>.</p><a class="signup" href="https://lp.logrocket.com/blg/graphql-signup" target="_blank" rel="noopener noreferrer"><img src="../Images/432a3823c85b3fb72a206e6236a29f48.png" data-lazy-src="https://files.readme.io/69aa835-Image_2019-11-09_at_1.28.05_PM.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" class=" jetpack-lazy-image" data-original-src="https://files.readme.io/69aa835-Image_2019-11-09_at_1.28.05_PM.png"/><noscript><img data-lazy-fallback="1" src="../Images/432a3823c85b3fb72a206e6236a29f48.png" data-original-src="https://files.readme.io/69aa835-Image_2019-11-09_at_1.28.05_PM.png"/></noscript><img class="alignnone size-full wp-image-46 jetpack-lazy-image" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/><noscript><img data-lazy-fallback="1" class="alignnone size-full wp-image-46" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/></noscript></a><a href="https://lp.logrocket.com/blg/graphql-signup" target="_blank" rel="noopener noreferrer">https://logrocket.com/signup/</a><p>LogRocket 就像是网络和移动应用的DVR，记录下你网站上发生的每一件事。您可以汇总并报告有问题的GraphQL请求，以快速了解根本原因，而不是猜测问题发生的原因。此外，您可以跟踪Apollo客户机状态并检查GraphQL查询的键值对。</p><p>LogRocket检测您的应用程序以记录基线性能计时，如页面加载时间、到达第一个字节的时间、慢速网络请求，还记录Redux、NgRx和Vuex操作/状态。</p><a class="signup" href="https://lp.logrocket.com/blg/graphql-signup" target="_blank" rel="noopener noreferrer">Start monitoring for free</a><p>.</p></div>


</div>
<a class="signup" href="https://lp.logrocket.com/blg/typescript-signup" target="_blank" rel="noopener noreferrer">Try it for free</a><p>.</p></div>
</div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
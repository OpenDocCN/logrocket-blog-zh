<html>
<head>
<title>React Hooks — let’s not get too attached - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>react Hooks——让我们不要太执着——log rocket博客</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/react-hooks-lets-not-get-too-attached-11b0ac09b4b5/#0001-01-01">https://blog.logrocket.com/react-hooks-lets-not-get-too-attached-11b0ac09b4b5/#0001-01-01</a></blockquote><div><article class="article-post">
<figure>
<p><img decoding="async" data-height="504" data-width="950" src="../Images/8bde93612e63365d1f7d3949ae168bdb.png" data-lazy-src="https://storage.googleapis.com/blog-images-backup/1*3BUc4O4T2cyE11h_HRxcXA.jpeg?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" class=" jetpack-lazy-image" data-original-src="https://storage.googleapis.com/blog-images-backup/1*3BUc4O4T2cyE11h_HRxcXA.jpeg"/></p><noscript><img data-lazy-fallback="1" decoding="async" data-height="504" data-width="950" src="../Images/8bde93612e63365d1f7d3949ae168bdb.png" data-original-src="https://storage.googleapis.com/blog-images-backup/1*3BUc4O4T2cyE11h_HRxcXA.jpeg"/></noscript><br/>
</figure>
<p>React团队在React Conf 18上宣布了一个名为Hooks的新功能的提议后，React社区出现了奇怪的反应:一系列描述如何使用它的教程，好像它已经在React核心中了。</p>
<p>被明确描述为<a href="https://reactjs.org/docs/hooks-intro.html" target="_blank" rel="noopener noreferrer">“新功能提案”</a>的东西被一些人视为功能<em>公告</em>。显然，有太多的宣传和“让我们现在就重写一切”的态度，正如React团队的Dan Abramov所说:</p>
<figure>
<blockquote><p><a href="https://twitter.com/dan_abramov/status/1057027428827193344"/></p></blockquote>
</figure>
<p>因此，让我们冷静一下，甚至不要为提议的API费心，并思考React是如何走到这一步的。</p>
<p>如果你现在更想看到代码并重构你的应用程序来使用钩子，那么<a href="https://reactjs.org/docs/hooks-intro.html" target="_blank" rel="noopener noreferrer">官方文档</a>是一个很好的起点。</p>
<p>在<a href="https://www.youtube.com/watch?v=x7cQ3mrcKaY" target="_blank" rel="noopener noreferrer">关于React的第一次会议演讲</a>中，Pete Hunt使用单词<em> hooks </em>来指代<code>React.Component</code>的方法，该方法允许用户提供自定义更新逻辑，以<em>挂钩到</em> React的内部并调整它们的行为。新的特性提案以类似的方式引入了<em>钩子</em>——通过将你的代码挂接到React的引擎中，作为一种与React交互的方式。</p>
<p>这种使用函数而不是从类继承的想法与React的功能和声明精神非常契合。因为基于类的组件遭受了古老的香蕉-大猩猩-丛林问题的困扰，正如乔·阿姆斯特朗所描述的:</p>
<blockquote><p>面向对象语言的问题是，它们拥有所有这些隐含的环境。你想要一个香蕉，但你得到的是一只大猩猩拿着香蕉和整个丛林。</p></blockquote>
<p>使用<code>React.Component</code>，通常您需要的只是状态或引用，但是您得到的是一组您永远不会使用的方法，以及编写可怕的<code>this</code>关键字的必要性(这是一个变位词)。基本上，Hooks是一个放弃类的提议，代替<em>从</em>继承React，<em> hook变成</em> React。</p>
<figure>
<p><a href="https://logrocket.com/signup/" target="_blank" rel="noopener noreferrer"><img decoding="async" data-height="750" data-width="3212" src="../Images/94b3e0f84b30cb0d321f60471481ab64.png" data-lazy-src="https://storage.googleapis.com/blog-images-backup/1*GPjaPKNNUYHU8EsA3Z0JGA.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" class=" jetpack-lazy-image" data-original-src="https://storage.googleapis.com/blog-images-backup/1*GPjaPKNNUYHU8EsA3Z0JGA.png"/><noscript><img data-lazy-fallback="1" decoding="async" data-height="750" data-width="3212" src="../Images/94b3e0f84b30cb0d321f60471481ab64.png" data-original-src="https://storage.googleapis.com/blog-images-backup/1*GPjaPKNNUYHU8EsA3Z0JGA.png"/></noscript></a>T6】</p></figure>
<h3>在没有<code>class</code> es的情况下如何反应</h3>
<p>React基于类的API出现问题已经有一段时间了。ES6类本身并不是真正的类(只是语法糖掩盖了原型继承)，它们不能很好地组合，并且使用<code>this</code>关键字会产生绑定问题，尤其是在执行异步操作时。</p>
<p>因此，对无类React开发的研究开始了。也许最值得注意的项目是<code><a href="https://github.com/acdlite/recompose" target="_blank" rel="noopener noreferrer">recompose</a></code>(文档中的第一个例子是<a href="https://github.com/acdlite/recompose#lift-state-into-functional-wrappers" target="_blank" rel="noopener noreferrer">向功能组件</a>提供状态)，该项目现在因为钩子的引入而停止。然而，<code>recompose</code>大量使用了高阶组件模式，不幸的是，这在渲染树中创造了一个难以阅读和虚假的层次。</p>
<p>另一个例子是<a href="https://github.com/reactions/component" target="_blank" rel="noopener noreferrer"> Reactions </a> <code><a href="https://github.com/reactions/component" target="_blank" rel="noopener noreferrer">Component</a></code>，它使用了另一个非常流行的模式来使类组件更加可组合——Render Prop。这里的问题是，用户首先必须非常熟悉基于类的React API，才能对如何使用Reactions <code>Component</code>有所了解。</p>
<p>还有一些很酷的项目使用新的<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy" target="_blank" rel="noopener noreferrer"> ES6代理</a>来管理状态，比如<code><a href="https://github.com/solkimicreb/react-easy-state" target="_blank" rel="noopener noreferrer">react-easy-state</a></code>或者——以一种更轻量级和实验性的方式——<code><a href="https://github.com/davidgilbertson/react-recollect" target="_blank" rel="noopener noreferrer">react-recollect</a></code>。我推荐关于后一个的<a href="https://hackernoon.com/a-different-way-to-manage-state-in-react-2d21dfb94482" target="_blank" rel="noopener noreferrer">文章，它很好地探究了如何实现超级可读和自我解释的状态管理。可悲的是，对ES6代理的支持</a><a href="https://caniuse.com/#feat=proxy" target="_blank" rel="noopener noreferrer">与理想的</a>相差甚远。</p>
<p>目前，钩子实现允许替换<em>几乎</em>所有基于类的组件的功能(很快将添加<code>componentDidCatch</code>和<code>getDerivedStateFromError</code>的钩子等价体)，所以在添加它们以作出反应之后，搜索可以被取消。React中的类不会很快消失，但是很明显React团队为图书馆设想了一个无类的未来。</p>
<h3>请只给我一种成分</h3>
<p>类和函数组件之间的二分法对用户来说是不必要的负担。我倾向于将函数组件视为成熟的类组件的一种轻量级的小兄弟——而且，这种区别与<a href="https://medium.com/@dan_abramov/smart-and-dumb-components-7ca2f9a7c7d0" target="_blank" rel="noopener noreferrer">表示和容器组件</a>模式非常吻合。但是当我想象现在学习React时，我认为在开始编写组件之前就必须决定是否使用状态(React最基本的特性)是一件令人失望的事情。</p>
<p>这有点像<a href="http://journal.stuffwithstuff.com/2015/02/01/what-color-is-your-function/" target="_blank" rel="noopener noreferrer">同步与异步函数</a> : <code>async</code> / <code>await</code>和<code>Promise</code>帮助我们逃离回调地狱，但是为什么程序员首先要关心一个操作是否是异步的呢？至少对我来说，钩子是一个比<code>class Something extends React.Component</code>更容易理解的抽象概念——我怎么知道在丛林中潜伏着什么，我必须带着<code>setState</code>功能？</p>
<h3>更具声明性和功能性的未来</h3>
<p>React以其声明性而自豪，但是使用生命周期方法是非常必要的——一个经典的例子是在<code>componentDidMount</code>和<code>componentDidUpdate</code>方法中的重复代码。使用钩子，这可以通过<code>useEffect</code>函数来实现(在官方文档中有一个关于钩子的声明式API如何击败生命周期方法的必要性<a href="https://reactjs.org/docs/hooks-effect.html#explanation-why-effects-run-on-each-update" target="_blank" rel="noopener noreferrer">的很好的例子)。</a></p>
<figure class="wp-caption"><figcaption class="wp-caption-text">Drop the “Stateless”, just “Functional Components“.</figcaption></figure>
<p>有了无状态的功能组件，React更多地朝着函数式编程的方向发展。钩子在这一领域更进一步，因为它们可以不用类而只用函数来构建全功能的React应用程序。</p>
<p>当该提案最终确定时，这将是自该库推出以来React应用程序开发方式的最大变化。今天的漂亮模式，如高阶组件或Render Prop，将会显得古怪，甚至粗糙(因为它们引入了一个错误的层次)。熟悉的<code>class App extends React.Component</code>及其生命周期方法列表将成为过去，如果没有JSX语法，一段代码甚至可能乍一看都不像React组件。</p>
<p>但在此之前，我们不要太依赖于提议的API，而要专注于使用酷的、稳定的特性编写代码。</p>
<h4>进一步阅读</h4>

<p><a href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener"> LogRocket </a>:全面了解您的生产React应用</p><div class="code-block code-block-17">
<div class="blog-plug inline-plug react-plug" vwo-el-id="26283398190">
<h2 vwo-el-id="41600691720">调试React应用程序可能很困难，尤其是当用户遇到难以重现的问题时。如果您对监视和跟踪Redux状态、自动显示JavaScript错误以及跟踪缓慢的网络请求和组件加载时间感兴趣，</h2><p>. </p><a href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" vwo-el-id="19356441070">try LogRocket</a><p>LogRocket 结合了会话回放、产品分析和错误跟踪，使软件团队能够创建理想的web和移动产品体验。这对你来说意味着什么？</p><a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="19356441380">
<img class="first-react-image alignnone size-full wp-image-46 jetpack-lazy-image jetpack-lazy-image--handled" src="../Images/f300c244a1a1cf916df8b4cb02bec6c6.png" vwo-el-id="18272717540" data-lazy-loaded="1" data-original-src="https://files.readme.io/27c94e7-Image_2017-06-05_at_9.46.04_PM.png"/>
</a>
<a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="19356441690">
<img class="second-react-image alignnone size-full wp-image-46 jetpack-lazy-image jetpack-lazy-image--handled" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" vwo-el-id="30720362350" data-lazy-loaded="1" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/>
</a>
<p vwo-el-id="28675660440" class="">LogRocket不是猜测错误发生的原因，也不是要求用户提供截图和日志转储，而是让您回放问题，就像它们发生在您自己的浏览器中一样，以快速了解哪里出错了。</p>
<p>不再有嘈杂的警报。智能错误跟踪允许您对问题进行分类，然后从中学习。获得有影响的用户问题的通知，而不是误报。警报越少，有用的信号越多。</p>
<p>LogRocket Redux中间件包为您的用户会话增加了一层额外的可见性。LogRocket记录Redux存储中的所有操作和状态。</p>
<p vwo-el-id="28675660750">现代化您调试React应用的方式— <a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="40093418840">开始免费监控</a>。</p>
<p vwo-el-id="28675661060">Modernize how you debug your React apps —
<a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="40093418840">start monitoring for free</a>.
</p>
</div></div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
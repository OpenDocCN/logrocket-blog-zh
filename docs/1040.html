<html>
<head>
<title>The best of both worlds: SSR with isomorphic JavaScript - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>两全其美:具有同构JavaScript的SSR-log rocket博客</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/ssr-with-isomorphic-javascript/#0001-01-01">https://blog.logrocket.com/ssr-with-isomorphic-javascript/#0001-01-01</a></blockquote><div><article class="article-post">
<p>服务器端渲染，或SSR，是您在前端开发社区中经常听到的一个短语。</p>
<p>在最基本的层面上，服务器端呈现正是它所描述的:在服务器上呈现应用程序。您导航到一个网站，它向服务器发出请求，呈现一些HTML，然后您在浏览器中获得完整的呈现结果。相当简单。你可能会问自己，为什么这个社区对此有一个专门的术语。</p>
<p>在大量依赖JavaScript和jQuery的丰富的动态web应用程序出现之前，基本上所有的web应用程序都是服务器呈现的。PHP，WordPress，甚至只是基本的HTML站点都是这样的例子。</p>
<p>当你访问这些网站上的一个页面时，你会得到所有的HTML数据和所有的东西。如果您单击一个链接，浏览器将向服务器发出另一个请求。根据响应，浏览器将从头开始刷新并呈现下一个页面。这种方法效果很好，而且多年来一直如此；浏览器呈现静态HTML的速度惊人地快。有什么变化？</p>
<p>自从世纪之交以来，JavaScript的使用已经从网页交互性的零星应用发展成为web上无可争议的首选语言。我们不断地向浏览器提供更多的逻辑和JavaScript。</p>
<p>像React和Vue这样的单页面框架已经开创了这个动态、复杂、数据驱动的客户端呈现的web应用的新时代。这些spa与服务器呈现的应用程序不同，因为它们在屏幕上呈现之前，不会从服务器获取完整的呈现内容和数据。</p>
<p>客户端呈现的应用程序使用JavaScript在浏览器中呈现其内容。他们不是从服务器获取所有内容，而是简单地获取一个没有正文内容的准系统HTML页面，并使用JavaScript呈现页面中的所有内容。</p>
<p>这样做的好处是，您可以避免完全由服务器呈现的应用程序所发生的页面刷新，这对于用户来说可能有点不舒服。单页面客户端呈现的应用程序将更新屏幕上的内容，从API获取数据，并在您面前更新，而无需任何页面刷新。这一特性使得现代web应用程序在您与它们交互时感觉更快更“自然”。</p>
<h2>客户端渲染权衡</h2>
<p>在客户端渲染的SPA世界里，不全是阳光和彩虹。在客户端呈现您的应用程序需要一些权衡。两个主要的例子是SEO和初始负载性能。</p>
<h3>搜索引擎优化</h3>
<p>由于客户端呈现的应用程序返回一个基本的HTML页面，在JavaScript开始运行并呈现其余内容之前，内容非常少，搜索引擎爬虫很难理解您页面的HTML结构，这对您网站的搜索排名是有害的。谷歌已经围绕这一点做了很多工作，但是如果搜索引擎优化特别重要的话，还是建议避免客户端渲染。</p>
<h3>初始负载性能</h3>
<p>对于客户端呈现的应用程序，当您第一次打开页面时，通常会看到以下情况:</p>
<ul>
<li>该应用程序加载一些基本的HTML，如应用程序外壳或静态导航栏</li>
<li>你会看到某种装载指示器</li>
<li>然后，您的内容被呈现</li>
</ul>
<p>这样做的问题是，在JavaScript从网络上完全加载并完成在屏幕上呈现元素之前，您的应用程序不会显示任何内容。</p>
<p>简而言之，客户端性能的问题通常在于，您无法控制用户在什么客户端设备上使用您的应用程序——无论是他们最先进的智能手机、功能强大的高端台式机，还是100美元的低端智能手机。</p>
<p>然而，我们确实控制着服务器。我们几乎总是可以给我们的服务器更多的CPU和内存，并对其进行调整，使其为我们的用户提供更好的性能。</p>
<h2>两全其美</h2>
<p>当使用现代前端技术的服务器端渲染时，我们可以两全其美。这通常的工作方式是，服务器在第一次加载时呈现并发送回完全呈现的应用程序。下一步称为水合，是下载和执行JavaScript包的地方。这将附加事件处理程序，并像客户端路由器一样进行连接。</p>
<p>使用这种方法，您可以在初始加载时获得SSR的所有好处，然后从那时起的每个交互都将由客户端JavaScript处理。这提供了一个快速的、SEO友好的初始加载，然后是我们熟悉和喜爱的动态单页web应用程序体验。</p>
<p>像这样的应用程序被称为通用应用程序，因为相同的JavaScript运行在客户端和服务器端。你可能还会听到更有趣的术语“同构”，意思完全一样。</p>
<h2>教程:实现SSR</h2>
<p>SSR也不是没有利弊。它引入了更复杂的配置，并且必须托管和管理自己的服务器，从而增加了开发的开销。这些问题就是像Next.js和Razzle这样不可思议的框架非常受欢迎的原因:它们抽象掉了SSR配置部分，让你专注于编写UI代码。</p>
<p>在本教程中，我们不打算使用任何SSR框架。了解事物工作原理的最佳方式是实际构建它，因此我们将学习如何创建尽可能简单的SSR设置，它将提供:</p>
<ul>
<li>全球CDN</li>
<li>全功能后端API</li>
<li>无需管理服务器或基础架构</li>
<li>单一命令部署</li>
</ul>
<p>我们将在Amazon Web Services (AWS)上部署一个使用create-react-app创建的通用服务器渲染的React应用程序。你不需要有AWS的经验。</p>
<h3>我们的工具</h3>
<p>为了构建我们的应用程序，我们将利用一些不同的AWS服务。</p>
<ul>
<li>AWS Amplify:管理AWS服务的高级框架，主要用于移动和web开发</li>
<li><strong> AWS Lambda </strong>:在云中运行代码，无需管理服务器</li>
<li><strong> AWS Cloudfront (CDN) </strong>:一个内容交付网络，负责在全球范围内交付和缓存内容</li>
<li>AWS简单存储服务(S3) :我们将在这里存储静态资产(JS、CSS等)。)</li>
</ul>
<h4>架构图</h4>
<p>我们的Lambda函数负责React应用程序的服务器呈现。我们将使用S3来存储我们的静态内容，使用Cloudfront CDN来提供服务。您不需要事先了解这些服务，因为AWS Amplify将使我们创建它们变得非常简单。</p>
<p><img data-attachment-id="22752" data-permalink="https://blog.logrocket.com/ssr-with-isomorphic-javascript/architecture-diagram/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/08/architecture-diagram.png" data-orig-size="730,403" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Diagram of our architecture" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/08/architecture-diagram-300x166.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/08/architecture-diagram.png" decoding="async" class="aligncenter size-full wp-image-22752 jetpack-lazy-image" src="../Images/d2ac77bea8652f2693895afbb2ae883c.png" alt="Our Architecture Diagram" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2020/08/architecture-diagram.png 730w, https://blog.logrocket.com/wp-content/uploads/2020/08/architecture-diagram-300x166.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2020/08/architecture-diagram.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/08/architecture-diagram.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="22752" data-permalink="https://blog.logrocket.com/ssr-with-isomorphic-javascript/architecture-diagram/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/08/architecture-diagram.png" data-orig-size="730,403" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Diagram of our architecture" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/08/architecture-diagram-300x166.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/08/architecture-diagram.png" decoding="async" loading="lazy" class="aligncenter size-full wp-image-22752" src="../Images/d2ac77bea8652f2693895afbb2ae883c.png" alt="Our Architecture Diagram" srcset="https://blog.logrocket.com/wp-content/uploads/2020/08/architecture-diagram.png 730w, https://blog.logrocket.com/wp-content/uploads/2020/08/architecture-diagram-300x166.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/08/architecture-diagram.png"/></noscript>
<h3>构建我们的应用程序</h3>
<p>首先，您需要安装AWS Amplify CLI并创建一个AWS帐户(如果您还没有的话)。你可以按照这个<a href="https://docs.amplify.aws/start">简短指南</a>来做。</p>
<h4>项目设置</h4>
<p>现在放大器已经配置好了，我们可以开始设置React项目了。我们将使用神奇的<a href="https://github.com/facebook/create-react-app"> create-react-app </a>来帮助我们。假设您已经安装了Node.js和npm，我们可以运行:</p>
<pre>npx create-react-app amplify-ssr
cd amplify-ssr 
yarn add aws-amplify 
amplify init
</pre>
<p>在AWS Amplify向导中选择默认选项。</p>
<p>我们的React项目现在用Amplify引导，并准备好为SSR添加我们的“服务器”。我们通过运行<code>amplify add api</code>并回答一些问题来做到这一点:</p>
<pre>$ amplify add api

? Please select from one of the below mentioned services: REST
? Provide a friendly name for your resource to be used as a label for this category in the project: amplifyssr
? Provide a path (e.g., /items): /ssr
? Choose a Lambda source: Create a new Lambda function
? Provide a friendly name for your resource to be used as a label for this category in the project: amplifyssr
? Provide the AWS Lambda function name: ssr
? Choose the function runtime that you want to use: NodeJS
? Choose the function template that you want to use: Serverless expressJS function
? Do you want to access other resources created in this project from your Lambda function? N
? Do you want to edit the local lambda function now? N
? Restrict API access: N
? Do you want to add another path? N
</pre>
<p>这将创建我们的AWS基础设施和后端所需的相关模板、目录和代码:一个AWS Lambda函数，它将运行一个小型Express服务器，负责呈现我们的React应用程序。</p>
<p>在部署基础设施之前，我们需要在React应用程序内部进行一些更改，以便为服务器端呈现做准备。打开【React应用程序的主要应用程序组件)并粘贴以下内容:</p>
<pre>import React from 'react';

function App() {
  return (
    &lt;div className="App"&gt;
      &lt;header className="App-header"&gt;
        Server Rendered React App
      &lt;/header&gt;
    &lt;/div&gt;
  );
}

export default App;
</pre>
<p>接下来，我们需要创建一个脚本来在服务器端呈现我们的React应用程序。这是通过<code>react-dom/server</code>包中的<code>renderToString</code>函数完成的。这个函数负责获取我们的<code>&lt;App /&gt;</code>组件，并在服务器端将其呈现为一个字符串，准备好作为完全呈现的HTML返回给客户端。</p>
<p>使用以下代码在<code>src/render.js</code>处创建一个文件:</p>
<pre>import React from "react";
import { renderToString } from "react-dom/server";
import App from "./App";

export default () =&gt; renderToString(&lt;App /&gt;);
</pre>
<p>太好了——我们的客户端React应用程序拥有所有需要在服务器端呈现的代码。这意味着我们现在必须编写将呈现React应用程序的服务器端端点。</p>
<p>但是，我们有一个问题——我们需要在服务器端运行<code>src/render</code>函数和<code>&lt;App /&gt;</code>组件代码。默认情况下，服务器对React甚至es模块一无所知。出于这个原因，我们将使用<a href="https://babeljs.io">巴别塔</a>从React应用程序中传输代码到服务器端。</p>
<p>为此，让我们在项目中安装一些Babel依赖项。</p>
<pre>yarn add --dev @babel/core @babel/cli @babel/preset-react @babel/preset-env
</pre>
<p>接下来，在项目的根目录下创建一个<code>.babelrc</code>。这个文件用于配置Babel，并告诉它使用哪些插件/预置。</p>
<pre>{
    "presets":[
        "@babel/preset-react",
        "@babel/preset-env"
    ]
}
</pre>
<p>最后，作为构建步骤的一部分，让我们更新我们的<code>package.json</code>来传输我们的代码。这将把文件传输到<code>amplify/backend/function/amplifyssr/src/client</code>目录中，在那里我们将存储所有需要在客户端和服务器上运行的通用JavaScript。</p>
<pre>  "scripts": {
    "start": "react-scripts start",
    "transpile": "babel src --out-dir amplify/backend/function/amplifyssr/src/client --copy-files",
    "build": "npm run transpile &amp;&amp; react-scripts build &amp;&amp; npm run copy",
    "copy": "cp build/index.html amplify/backend/function/amplifyssr/src/client",
    "test": "react-scripts test",
    "eject": "react-scripts eject"
  },
</pre>
<h4>用Lambda渲染应用程序</h4>
<p>构建配置完成了！让我们跳到<code>amplify/backend/function/amplifyssr/src</code>并安装<code>react</code>和<code>react-dom</code>，因为Lambda执行SSR都需要它们。</p>
<pre>yarn add react react-dom
</pre>
<p>现在来配置我们的Express服务器，它将在Lambda上运行。当我们完成前面的<code>amplify add api</code>步骤并选择了<code>REST</code>和<code>ExpressJS</code> API时，Lambda函数是自动生成的。</p>
<p>Amplify已经为我们配置了在Lambda上运行的Express服务器，所以我们现在需要做的就是添加一个端点，以便当有人点击浏览器中的API URL时，服务器呈现我们的React应用程序。更新您的<code>amplify/backend/function/amplifyssr/src/app.js</code>文件以包含以下代码:</p>
<pre>/* Amplify Params - DO NOT EDIT
    ENV
    REGION
Amplify Params - DO NOT EDIT */

const express = require('express')
const bodyParser = require('body-parser')
const awsServerlessExpressMiddleware = require('aws-serverless-express/middleware')
const fs = require('fs');
const render = require('./client/render').default;

// declare a new express app
const app = express()
app.use(bodyParser.json())
app.use(awsServerlessExpressMiddleware.eventContext())

// Enable CORS for all methods
app.use(function(req, res, next) {
  res.header("Access-Control-Allow-Origin", "*")
  res.header("Access-Control-Allow-Headers", "Origin, X-Requested-With, Content-Type, Accept")
  next()
});

app.get('*', function(req, res) {
  // Read the index.html file from the create-react-app build
  const html = fs.readFileSync("./client/index.html", "utf-8");
  // Server side render the react application
  const markup = render();

  // Replace the empty body of index.html with the fully server rendered react application and send it back to the client
  res.send(html.replace(`&lt;div id="root"&gt;&lt;/div&gt;`, `&lt;div id="root"&gt;${markup}&lt;/div&gt;`))
});

module.exports = app
</pre>
<p>我们的Express服务器现在已经为SSR做好了准备，我们可以部署React应用程序了。</p>
<h3>主持和最后润色</h3>
<p>一旦我们从应用程序的初始渲染接收到服务器渲染的HTML，我们将从那里获取客户端JavaScript包来接管，并给我们一个完全交互式的SPA。</p>
<p>我们需要一个地方来存放我们的客户端JavaScript和静态文件。在AWS中，通常用于此的服务是S3(简单存储服务)，这是一个大规模可扩展的云对象存储。</p>
<p>我们还将在它前面放置一个CDN，以实现全局缓存和性能。使用Amplify，我们可以通过从项目根目录运行几个命令来为项目创建这两个资源:</p>
<pre>$ amplify add hosting

Select the plugin module to execute Amazon CloudFront and S3
? Select the environment setup: PROD (S3 with CloudFront using HTTPS)
? hosting bucket name (name your bucket or use the default)
</pre>
<p>您现在可以通过运行<code>amplify publish</code>命令来部署您的整个基础设施，包括您的Express server Lambda功能、S3桶和CDN。</p>
<p>您的控制台输出将显示Amplify为您创建的模板中的所有相关资源。请注意，创建一个Cloudfront CDN需要一段时间，请耐心等待。一旦创建了您的资源，您的Cloudfront CDN URL将显示在终端中。</p>
<pre>Publish started for S3AndCloudFront
✔ Uploaded files successfully.
Your app is published successfully.
https://d3gdcgc9a6lz30.cloudfront.net
</pre>
<p>我们需要做的最后一件事是告诉React在服务器呈现应用程序后从哪里获取我们的客户端包。这是在create-react-app中使用<code>PUBLIC_URL</code>环境变量完成的。让我们再次更新React应用程序<code>package.json</code>脚本，如下所示:</p>
<pre>  "scripts": {
    "start": "react-scripts start",
    "transpile": "babel src --out-dir amplify/backend/function/amplifyssr/src/client --copy-files",
    "build": "npm run transpile &amp;&amp; PUBLIC_URL=&lt;your-cloudfront-url&gt; react-scripts build &amp;&amp; npm run copy",
    "copy": "cp build/index.html amplify/backend/function/amplifyssr/src/client",
    "test": "react-scripts test",
    "eject": "react-scripts eject"
  },
</pre>
<p>使用更新后的配置重新构建应用程序并将其部署到AWS。</p>
<pre>amplify publish
</pre>
<p>我们现在应该有一个完全服务器端渲染的React应用程序在AWS上运行了！</p>
<h4>运行我们的应用</h4>
<p>您的SSR API URL可以在<code>amplify/backend/amplify-meta.json</code>找到。在JSON文件中查找<code>RootUrl</code>,您应该看到可以访问新的服务器呈现应用程序的URL。它应该如下所示:</p>
<pre>"output": {
    "ApiName": "amplifyssr",
    "RootUrl": "https://g6nfj3bvsg.execute-api.eu-west-1.amazonaws.com/dev",
    "ApiId": "g6nfj3bvsg"
}, 
</pre>
<p>在<code>&lt;your-api-url&gt;/ssr</code>访问浏览器中的API网关URL，您应该会看到全新的服务器渲染React应用程序！如果您在您选择的浏览器中进入<strong>网络</strong>标签并查看请求，您会注意到对<code>/ssr</code>的请求有一个完全呈现的HTML响应，我们的React应用程序呈现在文档的<code>&lt;body&gt;</code>中。</p>
<pre>&lt;div id="root"&gt;
  &lt;div class="App" data-reactroot=""&gt;
      &lt;header class="App-header"&gt;Server Rendered React App&lt;/header&gt;
  &lt;/div&gt;
&lt;/div&gt;
</pre>
<p>您还会注意到从浏览器向Cloudfront URL发出的请求，这些请求用于加载客户端JavaScript，该JavaScript将从这里接管渲染，为我们提供了客户端和服务器端的最佳渲染环境。</p>
<h2>从这里去哪里</h2>
<p>本教程旨在让您尽快开始使用服务器端渲染，而不必担心管理基础设施、cdn等。使用无服务器方法后，我们可以对我们的设置做一些很好的改进。</p>
<h3>供应的并发</h3>
<p>AWS Lambda能够保持极低成本的一个方法是，一段时间没有使用的Lambda函数将会“闲置”。这实质上意味着当我们再次执行它们时，将会有所谓的“冷启动”——在Lambda响应之前必须发生的初始化延迟。</p>
<p>此后，lambda将再次“预热”一段时间，并快速响应后续请求，直到下一个长空闲期。这可能会导致稍微不可靠的响应时间。</p>
<p>尽管是“无服务器的”，Lambda使用轻量级容器来处理任何请求。每个容器在任何给定时间只能处理一个请求。除了空闲期后的冷启动问题，当许多并发请求命中同一个Lambda函数，导致更多并发容器或工作者在响应前被冷启动时，情况也是如此。</p>
<p>过去，许多工程师通过编写脚本来周期性地ping Lambda以保持其热度，从而解决了这个问题。现在有一个更好的AWS原生方法来解决这个问题，它被称为<a href="https://aws.amazon.com/about-aws/whats-new/2019/12/aws-lambda-announces-provisioned-concurrency/">供应并发</a>。</p>
<p>通过提供并发性，您可以非常容易地请求给定数量的专用容器为特定的Lambda函数保温。这将使您在高负载和零星负载时获得更加一致的SSR响应时间。</p>
<h3>Lambda版本</h3>
<p>您可以为您的函数创建几个<a href="https://docs.aws.amazon.com/lambda/latest/dg/configuration-versions.html"> Lambda版本</a>，并在它们之间划分流量。这在我们的SSR应用程序中是非常强大的，因为它允许我们在Lambda端进行更新，并使用一小部分用户对它们进行A/B测试。</p>
<p>您可以发布Lambda的多个版本，并在它们之间按您指定的权重分配流量。例如，您可能希望在服务器上呈现一个CTA横幅以供某些用户测量参与度，但不要呈现给其他用户。你可以用Lambda版本做到这一点。</p>
<h3>全栈web应用</h3>
<p>如前所述，AWS Amplify已经为我们创建了一个REST API和一个Express服务器，我们在其中创建了一个端点来服务器呈现我们的React应用程序。我们总是可以在<code>amplify/backend/function/amplifyssr/src/app.js</code>向这个Express服务器添加更多代码和端点，使我们能够将我们的应用程序变成一个全栈web应用程序，包括数据库、身份验证等等。</p>
<p>您可以利用AWS Amplify工具的奇妙套件来创建这些资源或插入到您自己的基础架构中——即使它不是托管在AWS上。您可以将AWS Lambda后端视为任何其他Express服务器，并在其上构建。</p>
<p>您已经通过运行<code>amplify publish</code>设置好了整个部署管道，因此您可以专注于编写代码。本教程的起点为您提供了完全的灵活性，让您可以从这里开始做自己想做的事情。</p>
<h2>结论</h2>
<p>服务器端渲染不一定很难。我们可以使用完全托管的工具，如Next或Razzle，它们本身就很棒，但对于许多团队来说，考虑到他们现有的代码或需求，这可能是一个太大的范式转变。使用简单、低维护、定制的方法可以让生活更轻松，尤其是如果您已经在项目中使用AWS或Amplify。</p>
<p>SSR可以为您的web应用程序增加大量价值，并提供急需的性能或SEO提升。在web开发社区中，我们很幸运拥有一些工具，只需几个命令或点击，就可以创建cdn、无服务器后端和完全托管的web应用程序。</p>
<p>即使您认为不需要SSR，这也是JavaScript生态系统中非常普遍和常见的话题。了解它的好处和缺点对几乎所有参与web开发领域的人来说都会很方便。</p>
<p>我希望你今天学到了一些东西——感谢阅读！欢迎联系我或在Twitter上关注我，我会在Twitter上发布关于JavaScript、Python、AWS、自动化和无代码开发的消息和博客。</p><div class="code-block code-block-17">
<div class="blog-plug inline-plug react-plug" vwo-el-id="26283398190">
<h2 vwo-el-id="41600691720"><a href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener"> LogRocket </a>:全面了解您的生产React应用</h2><p>调试React应用程序可能很困难，尤其是当用户遇到难以重现的问题时。如果您对监视和跟踪Redux状态、自动显示JavaScript错误以及跟踪缓慢的网络请求和组件加载时间感兴趣，</p><a href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" vwo-el-id="19356441070">try LogRocket</a><p>. </p><a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="19356441380">
<img class="first-react-image alignnone size-full wp-image-46 jetpack-lazy-image jetpack-lazy-image--handled" src="../Images/f300c244a1a1cf916df8b4cb02bec6c6.png" vwo-el-id="18272717540" data-lazy-loaded="1" data-original-src="https://files.readme.io/27c94e7-Image_2017-06-05_at_9.46.04_PM.png"/>
</a>
<a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="19356441690">
<img class="second-react-image alignnone size-full wp-image-46 jetpack-lazy-image jetpack-lazy-image--handled" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" vwo-el-id="30720362350" data-lazy-loaded="1" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/>
</a>
<p vwo-el-id="28675660440" class="">LogRocket 结合了会话回放、产品分析和错误跟踪，使软件团队能够创建理想的web和移动产品体验。这对你来说意味着什么？</p>
<p>LogRocket不是猜测错误发生的原因，也不是要求用户提供截图和日志转储，而是让您回放问题，就像它们发生在您自己的浏览器中一样，以快速了解哪里出错了。</p>
<p>不再有嘈杂的警报。智能错误跟踪允许您对问题进行分类，然后从中学习。获得有影响的用户问题的通知，而不是误报。警报越少，有用的信号越多。</p>
<p vwo-el-id="28675660750">LogRocket Redux中间件包为您的用户会话增加了一层额外的可见性。LogRocket记录Redux存储中的所有操作和状态。</p>
<p vwo-el-id="28675661060">现代化您调试React应用的方式— <a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="40093418840">开始免费监控</a>。</p>
</div></div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
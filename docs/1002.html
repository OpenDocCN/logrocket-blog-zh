<html>
<head>
<title>Node operators: Kubernetes node management made simple - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>节点操作者:Kubernetes节点管理变得简单</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/kubernetes-node-operators/#0001-01-01">https://blog.logrocket.com/kubernetes-node-operators/#0001-01-01</a></blockquote><div><article class="article-post">
<h2>介绍</h2>
<p>Kubernetes是为自动化而设计的。它带有许多内置功能，有助于部署和运行工作负载，可以在控制器的帮助下进行定制。节点操作符是Kubernetes API的客户机，充当定制资源的控制器。</p>
<p>本教程分解了Kubernetes节点操作符的概念。它回顾了它们是什么，为什么和什么时候需要它们，以及使用它们的优点。它还涵盖了构建操作符的最佳实践，更重要的是，它提供了创建节点操作符的分步指南。</p>
<p>但是，在我们继续之前，让我们快速探索一下在阅读本文时可能会遇到的一些重要的Kubernetes组件。我的希望是，最终，这将成为构建Kubernetes节点操作符的一站式指南。</p>
<h3>Kubernetes核心组件说明</h3>
<ul>
<li><a href="https://kubernetes.io/docs/concepts/architecture/controller/#:~:text=In%20Kubernetes%2C%20controllers%20are%20control,closer%20to%20the%20desired%20state.">控制器</a>是来自Kubernetes核心的循环，它通过API服务器不断监视集群的状态。这就允许集群拥有扩展的行为，而无需对Kubernetes代码本身进行修改</li>
<li><a href="https://kubernetes.io/docs/concepts/extend-kubernetes/api-extension/custom-resources/">定制资源</a>是为个别用例构建的Kubernetes API的扩展</li>
<li>Kubernetes API公开了HTTP API，允许终端用户和Kubernetes集群的其他组件相互通信</li>
<li><a href="https://kubernetes.io/docs/concepts/workloads/pods/pod/"> Pods </a>是由kubernetes创建和管理的最小可部署计算单元。它是Kubernetes中一个应用程序的单个实例，可能由一个或多个容器组成。</li>
<li>Kubernetes中的节点是包含运行pod所需服务的机器(物理或虚拟)</li>
<li>部署是描述应用程序状态的声明性配置文件</li>
<li><a href="https://kubernetes.io/docs/concepts/workloads/">工作负载</a>是为pod设置部署规则的Kubernetes对象</li>
<li><a href="https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/">名称空间</a>是Kubernetes集群的逻辑隔离</li>
</ul>
<h3>先决条件</h3>
<p>因为本教程不是为Kubernetes初学者设计的，所以我们至少应该有以下基本知识:</p>
<ul>
<li>Go编程语言</li>
<li>运行码头集装箱</li>
<li>运行库组件</li>
<li>通过kube CTL(Kubernetes命令行工具)与Kubernetes交互</li>
</ul>
<p>出于测试的目的，我们可以使用Minikube，这是一个使本地运行Kubernetes变得容易的工具。运行和安装Minikube的步骤见<a href="https://kubernetes.io/docs/setup/learning-environment/minikube/">此处</a>，安装kubectl见<a href="https://kubernetes.io/docs/tasks/tools/install-kubectl/">此处</a>。也可以在这里看到下载围棋<a href="https://golang.org/doc/install#install">的说明。最后，按照这些</a><a href="https://docs.docker.com/get-started/">步骤</a>来学习Docker及其安装。</p>
<h2>透视Kubernetes节点运算符</h2>
<p>节点操作员是利用Kubernetes的能力来提供云服务的自动化优势的应用程序。他们可以自始至终打包、部署和管理应用程序。这些应用程序不仅可以部署在平台上，还可以在Kubernetes可以运行的其他云服务器上运行，例如EKS、GKE等。</p>
<p>本质上，节点操作者通过Kubernetes提供了特定于应用程序的自动化。最简单的形式是，操作员向Kubernetes API服务器添加一个端点，称为定制资源(CR)。</p>
<p>这附带了一个控制平面组件，用于在创建自定义资源时对其进行监控和维护。然后，这些操作员可以根据资源的状态采取行动。</p>
<h3>运营商是为了谁？</h3>
<ul>
<li>基础设施工程师和开发人员，他们经常希望扩展Kubernetes，以提供特定于他们的应用程序的特性</li>
<li>集群管理员，因为操作员可以用更少的管理开销更容易地管理软件，如数据库</li>
<li>应用程序开发人员，他们可能希望使用运营商来管理他们交付的应用程序，从而简化Kubernetes集群上的部署管道和管理体验</li>
</ul>
<h2>Kubernetes节点运算符模式</h2>
<p>这些是Kubernetes的原则，每个运营商都是建立在这些原则之上的。它们包括:</p>
<h3>自定义资源</h3>
<p>CRs是为个人使用而构建的Kubernetes API的扩展。与其他内置资源不同，它们在默认的Kubernetes安装中并不总是可用的。<a href="https://kubernetes.io/docs/concepts/extend-kubernetes/api-extension/custom-resources/">根据文件</a>:</p>
<blockquote><p>“它们代表了特定Kubernetes安装的定制…使Kubernetes更加模块化。”</p></blockquote>
<p>CRs是动态的，可以独立于集群本身进行更新。一旦安装了CR，用户就可以使用kubectl创建和访问它的对象，就像我们对内置资源(如pods、部署等)所做的一样。</p>
<blockquote><p><strong>注意</strong> : CRs是使用<code>CustomResourceDefinition</code> API定义的。</p></blockquote>
<h3>定制控制器</h3>
<p>当我们将自定义资源与自定义控制器相结合时，它提供了一个真正的声明式API。这允许我们声明或指定资源的期望状态，并使Kubernetes对象的当前状态与期望状态保持同步。</p>
<h2>Kubernetes节点运算符的优势</h2>
<ul>
<li>它是一个声明性系统，因为它管理从期望状态到最终状态的资源</li>
<li>它是基于Kubernetes API构建的</li>
<li>敏捷、灵活、操作方便，因为它们使得在Kubernetes应用程序上安装和构建变得容易</li>
<li>他们打包内部应用程序，并使它们易于访问</li>
<li>当我们想要构建更好的自动化体验，而不是手工做重复性的任务或操作时，节点操作符就派上了用场</li>
</ul>
<h2>何时使用Kubernetes节点操作符</h2>
<p>操作员可以代表基础设施工程师/开发人员执行自动化任务。因此，有许多可以使用节点操作符的场景。</p>
<p>例如，在定义Spark、Cassandra、Airflow、Zookeeper等定制应用程序时，节点操作符就派上了用场。这些应用可能需要大量的微服务来管理它们的生命周期，而我们可以使用运营商来部署这些应用的实例，使它们更易于管理</p>
<p>它们对于数据库之类的有状态应用程序也很有用。其中一些有状态的应用程序具有预配置和后配置步骤，这些步骤很容易导致错误，可以通过操作员的自动化来减少错误。</p>
<p>其他使用案例可能包括:</p>
<ul>
<li>实施安全策略—例如，在创建pod之前扫描图像中的漏洞可以使用操作员轻松实现。</li>
<li>创建可用于自动化目的的模板</li>
<li>管理复杂的管理任务，如授予访问权限。您可以创建操作符来实施Kubernetes级别的集群策略，例如，<code>do not allow</code>一些pod</li>
</ul>
<h2>构建节点操作符</h2>
<p>如果生态系统中没有实现应用程序所需行为的操作者，我们可以通过各种方法编写自己的代码。然而，本节将详细讨论<a href="https://github.com/operator-framework/operator-sdk">操作符SDK </a>。</p>
<p>运营商SDK最初是CoreOS写的，现在由红帽维护。这是构建一个操作符最简单、最直接的方法之一，不需要非常了解Kubernetes API的复杂性。</p>
<p>其他方法包括ClientGo，这是一个与Kubernetes API连接的Go客户端。然而，使用这个客户机构建一个操作符需要Go编程语言的工作知识。</p>
<p>Kube Builder是另一个选择。这是Kubernetes特别兴趣小组(SIGs)的一部分，负责构建在Kubernetes内运行的应用程序。它也是用Go编写的，并使用控制器运行时——因此，它允许与Kubernetes API通信。</p>
<h2>使用Operator SDK构建节点运算符</h2>
<h3>1.安装Operator SDK</h3>
<p>安装Operator SDK有多种方式，这里我们将重点介绍其中的两种。首先是通过操作符二进制直接安装。我们可以通过运行以下命令从Operator框架中获取最新版本的Operator SDK来实现这一点:</p>
<pre>$ wget https://github.com/operator-framework/operator-sdk/releases/download/v0.15.2/operator-sdk-v0.15.2-x86_64-linux-gnu</pre>
<p>下一步是通过运行以下命令将下载的操作符移动到可执行路径:</p>
<pre>$ sudo mv operator-sdk-v0.15.2-x86_64-linux-gnu /usr/local/bin/operator-sdk</pre>
<p>然后，我们可以通过运行以下命令使其可执行:</p>
<pre>$ sudo chmod +x /usr/local/bin/operator-sdk</pre>
<p>另一种方法是从托管SDK的GitHub存储库中克隆SDK，并从那里进行安装。为此，我们可以在Go路径(Go的安装路径)上为操作符框架创建一个目录:</p>
<pre>$ mkdir -p $GOPATH/src/github.com/operator-framework</pre>
<p>然后，我们通过运行以下命令导航到该路径:</p>
<pre>$ cd $GOPATH/src/github.com/operator-framework</pre>
<p>现在，我们可以通过运行以下命令集，将Operator framework存储库克隆到我们刚刚创建的目录中:</p>
<pre>$ git clone https://github.com/operator-framework/operator-sdk
$ cd operator-sdk
$ git checkout v0.4.0
$ make dep
$ make install</pre>
<p><code>operator-sdk</code>命令引导操作员。下面显示了一个示例:</p>
<pre>$ operator-sdk new sample-operator
$ cd sample-operator</pre>
<p>运行上述命令生成的项目结构如下所示:</p>
<pre>├── Gopkg.lock
├── Gopkg.toml
├── build
│   └── Dockerfile
├── cmd
│   └── manager
│       └── main.go
├── deploy
│   ├── operator.yaml
│   ├── role.yaml
│   ├── role_binding.yaml
│   └── service_account.yaml
├── pkg
│   ├── apis
│   │   └── apis.go
│   └── controller
│       └── controller.go
└── version
    └── version.go</pre>
<h3>2.自定义资源定义</h3>
<p>接下来是生成一些代表项目CR定义的代码，即自定义资源(API)和自定义控制器。为此，我们可以运行以下命令:</p>
<pre>$ operator-sdk add api --api-version=sample-operator.example.com/v1alpha1 --kind=App
$ operator-sdk add controller --api-version=sample-operator.example.com/v1alpha1 --kind=App</pre>
<p>该命令指定CRD将被调用<code>App</code>。这为我们创建了<code>pkg/apis/app/v1alpha1/app_types.go</code>文件。可以修改该文件以添加额外的参数。</p>
<blockquote><p><strong>注意</strong>:我们也可以运行以下命令来生成CRD:</p>
<pre>      $ operator-sdk generate crds
      $ operator-sdk generate k8s
</pre>
</blockquote>
<p>这将生成一组新的YAML文件和Go代码，附加到上面的树中。</p>
<p>注意，<code>deploy/crds/sample-operator_v1alpha1_app_crd.yaml</code>文件包含定制资源定义，而<code>deploy/crds/sample-operator_v1alpha1_app_cr.yaml</code>文件包含定制资源。</p><div class="code-block code-block-54">
<hr/>
<h3>更多来自LogRocket的精彩文章:</h3>

<hr/></div>
<blockquote><p><strong>注意</strong>:我们可以通过运行以下命令在Kubernetes集群上安装CRD:</p>
<pre>kubectl apply -f deploy/crds/sample-operator_v1alpha1_app_crd.yaml</pre>
</blockquote>
<h3>3.控制器</h3>
<p>此时，操作员运行所谓的“协调循环”这只是调用一个协调函数，确保每次从我们上面定义的CR定义中创建CR时都触发一段代码。</p>
<p><code>pkg/controller/app/app_controller.go</code>控制器文件包含控制器逻辑和协调功能。它还包含创建pod的示例代码，我们可以根据需要进行调整。</p>
<p>在协调过程中，控制器获取当前名称空间中的应用资源，并将它的副本字段的值(即，要运行的pod的期望数量)与运行的pod的实际数量进行比较。</p>
<p>这将比较并确保所需的单元数量与活动单元的可用数量相匹配。修改控制器逻辑的一个例子是通过添加存储副本数量的字段，即在<code>pkg/apis/sample-operator/v1alpha1/app_types.go</code>文件中，来改变<code>appSpec</code> Go结构。</p>
<pre>Type appSpec struct {
  Replicas int32  `json:"replicas"`
}</pre>
<blockquote><p><strong>注意</strong>:对该文件的修改次数没有限制，因为它是高度可定制的。</p></blockquote>
<p>记住，在对控制器结构进行更改后，总是要运行一个<code>operator-sdk generate k8s</code>命令，因为这将更新API包文件，即<code>pkg/apis/app/v1alpha1/zz_generated.deepcopy.go</code>。</p>
<h2>测试操作员</h2>
<p>在部署操作符之前，我们可以在集群之外的本地机器上测试它。为此，首先，我们通过运行以下命令来启动集群:</p>
<pre>$ operator-sdk run local</pre>
<p>接下来，我们可以通过运行以下命令来测试我们的示例应用程序:</p>
<pre>$ kubectl apply -f &lt;(echo "
apiVersion: sample-operator.example.com/v1alpha1
kind: app
metadata:
         name: test-app
spec:
         replicas: 3
")</pre>
<blockquote><p><strong>注意</strong>:这将旋转三个吊舱，如控制器逻辑中所定义的。</p>
<pre> 
      $ kubectl get pods -l app=test-app
      NAME                                       READY            STATUS             RESTARTS           AGE
      test-app-podc2ckn                   1/1                     Running                   0          103s
      test-app-podhg56f                   1/1                     Running                   0          103s
      test-app-pod12efd                   1/1                     Running                   0          103s
</pre>
</blockquote>
<p>一旦我们确信操作员按预期工作，并且其他kubectl命令(<code>create</code>、<code>describe</code>、<code>edit</code>)可以针对我们的CR成功运行，我们的下一步就是部署集群。</p>
<h2>部署操作员</h2>
<p>为了发布操作符，我们需要一个Docker容器映像，Kubernetes集群可以轻松地访问它。我们将图像推送到任何容器注册表。请注意，在本教程中，我们将使用<a href="https://quay.io/"> Quay.io </a>。</p>
<p>下一步是通过运行以下命令构建并发布到注册表:</p>
<pre>$ operator-sdk build quay.io/&lt;username&gt;/sample-operator
$ docker push quay.io/&lt;username&gt;/sample-operator</pre>
<p>现在更新<code>deploy/operator.yml</code>文件，指向注册表中新的Docker映像。我们通过运行以下命令来实现这一点:</p>
<pre>$ sed -i 's|REPLACE_IMAGE|quay.io/&lt;username&gt;/sample-operator|g' deploy/operator.yaml</pre>
<h3>运营商最佳实践</h3>
<ul>
<li>针对控制器代码运行足够的测试。这确保了如果操作符突然停止，您的应用程序仍将按预期运行</li>
<li>运营商应利用内置资源，如pod、部署等。这使得运营商可以建立在先前测试和验证的Kubernetes资源上</li>
<li>为每个应用开发一个操作员。与让一个运营商部署多个应用程序相比，这种方式更容易维护。例如，一个数据库运营商部署MySQL和Redis并不理想</li>
<li>持续监控构建的操作程序</li>
<li>使用声明式API，因为Kubernetes本身支持声明式配置。这使得用户更容易表达他们想要的集群状态</li>
<li>始终使用SDK。这使得构建操作符变得更容易和更好，而不用担心Kubernetes库是如何实现的底层细节</li>
<li>确保控制器尽可能精简，不依赖于外部资源，这样仅<code>kubectl install</code>就足以部署操作员</li>
</ul>
<h2>结论</h2>
<p>节点操作符旨在简化扩展Kubernetes的过程，正如我们所见，它们很容易集成和构建。</p>
<p>在众多好处中，它们简化了自动化，使我们可以在任何地方轻松部署云原生应用程序(小型、独立、松散耦合的服务的集合),并完全按照我们的意愿管理它们。</p>
<p>同样，希望这有助于快速开始构建自己的Kubernetes操作器。想找或者分享运营商？查看<a href="https://operatorhub.io/"> OperatorHub.io </a>了解更多详细信息。</p><div class="code-block code-block-2">
<div class="blog-plug base-cta"><h2>使用<a class="signup" href="https://lp.logrocket.com/blg/signup" target="_blank" rel="noopener noreferrer"> LogRocket </a>消除传统错误报告的干扰</h2>
<a href="https://lp.logrocket.com/blg/signup" class="signup" target="_blank" rel="noopener noreferrer"><img class="alignnone size-full wp-image-46 jetpack-lazy-image" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/><noscript><img data-lazy-fallback="1" class="alignnone size-full wp-image-46" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/></noscript></a>
<p><a href="https://lp.logrocket.com/blg/signup" target="_blank" rel="noopener noreferrer"> LogRocket </a>是一个数字体验分析解决方案，它可以保护您免受数百个假阳性错误警报的影响，只针对几个真正重要的项目。LogRocket会告诉您应用程序中实际影响用户的最具影响力的bug和UX问题。</p>
<p>然后，使用具有深层技术遥测的会话重放来确切地查看用户看到了什么以及是什么导致了问题，就像你在他们身后看一样。</p>
<p>LogRocket自动聚合客户端错误、JS异常、前端性能指标和用户交互。然后LogRocket使用机器学习来告诉你哪些问题正在影响大多数用户，并提供你需要修复它的上下文。</p>
<p>关注重要的bug—<a class="signup" href="https://lp.logrocket.com/blg/signup-issue-free" target="_blank" rel="noopener noreferrer">今天就试试LogRocket】。</a></p></div></div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
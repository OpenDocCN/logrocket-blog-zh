<html>
<head>
<title>Jest and Enzyme: Unit testing in React in 2021 - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>Jest和Enzyme:2021年React中的单元测试</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/jest-and-enzyme-unit-testing-in-react-in-2021/#0001-01-01">https://blog.logrocket.com/jest-and-enzyme-unit-testing-in-react-in-2021/#0001-01-01</a></blockquote><div><article class="article-post">
<p>自框架早期以来，React 2021中的单元测试已经走过了漫长的道路。诸如<a href="https://jestjs.io/" target="_blank" rel="noopener noreferrer"> Jest </a>和<a href="https://enzymejs.github.io/enzyme/" target="_blank" rel="noopener noreferrer"> Enzyme </a>这样的工具将进入生产<a href="https://www.researchgate.net/publication/3249271_Guest_Editors'_Introduction_TDD--The_Art_of_Fearless_Programming" target="_blank" rel="noopener noreferrer">的编码错误减少了40%到80%之多</a>。在部署这些广泛的框架时，不再需要推出自己的解决方案。</p>
<p>在本文中，我们将看看如何使用Jest和Enzyme为React构建单元测试，并学习如何可靠地测试组件树和函数。</p>
<h2>先决条件</h2>
<p>本教程要求具备<a href="https://reactjs.org/" target="_blank" rel="noopener noreferrer">反应</a>的基础知识。我们依靠<a href="https://nodejs.org/en/" target="_blank" rel="noopener noreferrer"> Node.js </a>来提供内容。</p>
<p>你需要安装几个库来使用Jest和Enzyme。在Node.js <code>package.json</code>文件中包含以下部分，或者使用<code>npm</code>安装包:</p>
<pre>"devDependencies": {

"@babel/preset-env": "7.12.7",

"@babel/preset-react": "^7.12.7",

"babel-jest": "^26.6.3",

"jest": "^26.6.3",

"react-test-renderer": "^17.0.1"

}</pre>
<p>虽然React是一个前端框架，但我们将重点关注使用Node.js运行测试。</p>
<h2>一个简单的反应程序</h2>
<p>在开始单元测试之前，我们需要创建一个简单的程序。我们创建了一个返回简单计算结果的函数和一个呈现内容的函数。</p>
<p>将以下内容添加到您的<code>index.js</code>或自定义JavaScript文件中:</p>
<pre>function getComputation(a, b){
return a + b;

}
function sayHello(){
return &lt;div&gt;&lt;p&gt;Hello World!&lt;/p&gt;&lt;/div&gt;;

}
</pre>
<p>启动web服务器，打开应用程序的索引页。确保页面显示“Hello World！”文字。</p>
<h2>React中的单元测试是什么？</h2>
<p>假设<code>sayHello</code>函数停止返回正确的内容或者完全失败。您可能想知道该方法在进入生产之前是否停止了工作。</p>
<p>单元测试确保您的代码在生产的早期就像预期的那样工作。开发人员在编写函数时将它们结合在一起，以确保每个函数都能正常工作。测试在与强大的日志记录相结合时非常有效。</p>
<h2>编写好的单元测试</h2>
<p>测试需要彻底，这需要时间和精力。尽管如此，编写可扩展的套件可以让您安心，同时确保您的应用程序不会意外失败并在此过程中赶走用户。</p>
<p>良好的单元测试:</p>
<ul>
<li>测试单个功能</li>
<li>为预期的行为和功能编写测试</li>
<li>不同的资产和行为依赖于一种共同的语言</li>
<li>通过日志和其他信息深入了解问题</li>
</ul>
<p>随着时间的推移，编写大量的测试变得越来越容易，正如测试随着时间的推移成为第二天性一样。</p>
<h2>编码最佳实践对测试的影响</h2>
<p>有一些最佳实践可以遵循，以提高测试能力和代码质量。<a href="https://www.aversan.com/coding-standards-and-best-practices-2/" target="_blank" rel="noopener noreferrer">编码标准和最佳实践</a>与保持您的应用程序平稳运行密切相关。</p>
<p>要使运行测试和使用应用程序更容易:</p>
<ul>
<li>将重复的代码分割成独立的和可测试的功能</li>
<li>避免组合功能</li>
<li>不要隐藏关键代码</li>
</ul>
<p>难以通读的混乱代码，将许多功能包装在一个函数中，使得测试更加困难。不好的做法也让以后的发展更加困难。</p>
<h2>笑话和酶的单元测试</h2>
<p>Jest和Enzyme允许您编写强大的单元测试，而无需从头构建框架。这些工具以一种比编写单个函数更自然的方式包装测试，并且还允许您访问报告和断言。</p>
<p>在你的<code>src</code>文件夹下创建<code>index.test.js</code>。在这个文件中为<code>getComputation</code>函数编写一个测试:</p>
<pre>const idx = require('./index.js')
describe("testComputation", () =&gt;{
it('adds 1 + 5', () =&gt;{


    expect(idx.getComputation(1, 5)).toBe(6);


});

});</pre>
<p>我们确保程序返回正确的结果。你仍然需要告诉测试者你的测试。</p>
<p>在名为<code>testconfig.json</code>的新文件中写入以下配置:</p>
<pre>{

"verbose": true,

"testURL": "http://localhost/",

"testMatch": ["**index.test.js?(x)"]

}</pre>
<p>更改<code>testMatch</code>数组以匹配到<code>test.index.js</code>的路径。您可以告诉Jest使用正则表达式从任何文件中读取测试。</p>
<p>最后，将以下内容添加到<code>package.json</code>中，告诉Node如何运行您的单元测试:</p>
<pre>"scripts": {

"test": "jest",

}</pre>
<p>从命令行运行测试:</p>
<pre>jest testComputation –config=./testconfig.json</pre>
<p>Jest将运行<code>test.index.js</code>文件中的<code>testComputation</code>测试。每个测试的详细信息都会出现在您的控制台中。</p>
<h2>DOM测试</h2>
<p>React提供了一个DOM渲染器。Enzyme以此为基础，让您测试单个组件。您可以验证单个组件。</p>
<p><code>sayHello</code>函数返回一个div。您可以创建以下测试来确保页面正确呈现:</p>
<pre>import {shallow} from 'enzyme';
describe("testRender", () =&gt;{
it("should render hello world", () =&gt; {


    const html = idx.sayHello();


    const wrapper = shallow(html).toJSON();


    expect(wrapper.text()).toContain("Hello World!");


});

});</pre>
<p>除非你改变树，否则划分看起来是一样的。这确保了结果内容保持一致。检测不需要的更改有助于改善用户体验。</p>
<h2>酶是做什么的？</h2>
<p>在上面的测试用例中，Enzyme提供了挂载和遍历React.js组件树的机制。该框架让您可以轻松地断言、操作和遍历组件。</p>
<p>与过去你可能无法访问渲染器不同，Jest可以渲染内容，而Enzyme允许你测试关于内容的假设。这可以使您避免编写可能有问题的用例，在这些用例中，您需要像上面所示的那样匹配字符串。</p><div class="code-block code-block-54">
<hr/>
<h3>更多来自LogRocket的精彩文章:</h3>

<hr/></div>
<h2>用酶记录</h2>
<p>酶也可以作为进入单元测试的窗口。没有什么比测试无缘无故失败更令人沮丧的了，尤其是如果您使用的依赖项没有提供像样的日志。</p>
<p>您可以包装对象并将其打印到控制台:</p>
<pre>const html = idx.sayHello();

const wrapper = shallow(html).toJSON();

console.log(wrapper.debug());</pre>
<p>如果您在持续集成框架中运行您的测试，将这些信息记录到一个中心位置。您选择的工具可能已经从控制台聚集了信息，但是您可以使用<a href="https://www.npmjs.com/package/logstash-client" target="_blank" rel="noopener noreferrer"> Logstash </a>或另一个可搜索的日志存储平台将这些日志存储在<a href="https://www.elastic.co/" target="_blank" rel="noopener noreferrer"> Elasticsearch </a>中。</p>
<h2>持续集成中的单元测试</h2>
<p>单元测试是确保应用程序健康的更广泛策略的一部分。它们是减少系统中错误数量的第一步。</p>
<p>在持续集成工具中使用它们可以防止应用程序在更新后崩溃。持续集成使构建自动化，如果意外中断，这可能是个问题。</p>
<p>像<a href="https://circleci.com/blog/continuously-testing-react-applications-with-jest-and-enzyme/" target="_blank" rel="noopener noreferrer"> Circle CI和Gitlab CI </a>这样的工具可以让你在<a href="https://www.docker.com/" target="_blank" rel="noopener noreferrer"> Docker </a>容器中运行测试，作为构建过程的一部分。如果您的测试失败了，整个构建就会失败。请确保登录到应用程序性能管理或其他日志工具，以跟踪您的构建中的问题。</p>
<h2 id="code-coverage">代码覆盖率</h2>
<p>随着应用程序的增长，确保彻底测试变得更加困难。代码覆盖率，即测试中运行的源代码的数量，是一个有用的跟踪统计数据。使用代码覆盖工具来查找项目中未测试的部分。</p>
<p>Jest允许您在运行测试时跟踪这个统计数据。只需在控制台上使用<code>–coverage</code>选项，准备好100%完成你的<a href="https://github.com/pamepeixinho/jest-coverage-badges" target="_blank" rel="noopener noreferrer"> Jest GitHub代码覆盖率</a>徽章。生成的报告显示语句、分支、函数和到达的行。</p>
<h2>2021年React中的单元测试</h2>
<p>单元测试是开发的重要部分。它减少了错误，提高了生产率，并消除了调试代码所花费的时间。</p>
<p>Jest是一个强大的平台，让你能够在2021年的React中执行彻底的单元测试。将您的测试部署到您选择的持续集成工具，并使日志可访问，以保持您的应用程序健康。</p><div class="code-block code-block-17">
<div class="blog-plug inline-plug react-plug" vwo-el-id="26283398190">
<h2 vwo-el-id="41600691720">使用LogRocket消除传统反应错误报告的噪音</h2>
<a href="https://lp.logrocket.com/blg/react-signup-issue-free" target="_blank" vwo-el-id="19356441070">LogRocket
</a><p>是一款React analytics解决方案，可保护您免受数百个误报错误警报的影响，只针对少数真正重要的项目。LogRocket告诉您React应用程序中实际影响用户的最具影响力的bug和UX问题。</p><a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="19356441380">
<img class="first-react-image alignnone size-full wp-image-46 jetpack-lazy-image jetpack-lazy-image--handled" src="../Images/f300c244a1a1cf916df8b4cb02bec6c6.png" vwo-el-id="18272717540" data-lazy-loaded="1" data-original-src="https://files.readme.io/27c94e7-Image_2017-06-05_at_9.46.04_PM.png"/>
</a>
<a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="19356441690">
<img class="second-react-image alignnone size-full wp-image-46 jetpack-lazy-image jetpack-lazy-image--handled" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" vwo-el-id="30720362350" data-lazy-loaded="1" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/>
</a>
<a href="https://lp.logrocket.com/blg/react-signup-issue-free" target="_blank" rel="noopener noreferrer" vwo-el-id="35866400580">LogRocket
</a><p>自动聚合客户端错误、反应错误边界、还原状态、缓慢的组件加载时间、JS异常、前端性能指标和用户交互。然后，LogRocket使用机器学习来通知您影响大多数用户的最具影响力的问题，并提供您修复它所需的上下文。</p><p vwo-el-id="28675661060">关注重要的React bug—<a class="signup" href="https://lp.logrocket.com/blg/react-signup-issue-free" target="_blank" rel="noopener noreferrer" vwo-el-id="40093418840">今天就试试LogRocket】。</a></p>
</div></div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
<html>
<head>
<title>Building the simplest CRUD out there with entity management - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>用实体管理构建最简单的CRUD</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/building-the-simplest-crud-out-there-with-entity-management/#0001-01-01">https://blog.logrocket.com/building-the-simplest-crud-out-there-with-entity-management/#0001-01-01</a></blockquote><div><article class="article-post">
<p>在某种程度上，所有的应用程序都只是数据库的漂亮接口。试想一下——一条推文、一条facebook帖子、一条instagram评论——每一条都只是某处数据库中的一行。</p>
<h2>一开始就有实体</h2>
<p>对于作为前端开发人员的我来说，学习一点SQL(用于数据库管理的语言)带来了一个小小的启示:所以这就是它的终点。每个用户的旅程从登录屏幕，通过搜索栏，流畅的动画，消除讨厌的弹出窗口，看广告，直到最终到达他们需要的信息。</p>
<p>最后就像这样一句台词:</p>
<p><code>sql SELECT * FROM movies WHERE id='42';</code> <br/>它说:“从名为<code>movies</code>的表中选择所有字段，其中名为<code>id</code>的字段的值为<code>42</code>”。</p>
<p>那么这整个努力的结果是什么呢？一部电影，一个用户，一本书，我们简单地称之为…一个实体。挺有哲理的吧？</p>
<p>根据字典的解释，实体是“一个具有独特和独立存在的事物”。而实体的管理，一般来说，叫做CRUD。</p>
<h2>那么，实际上什么是污垢呢？</h2>
<p>CRUD代表创建、读取、更新和删除。这是管理任何数据集合所需的一组基本操作。</p>
<p>让我们看看一组简单的CRUD函数是如何实现的。</p>
<p>数据将是一个数组，数组中的每一项都必须满足一个要求——一个惟一的id。该数组可能如下所示:</p>
<pre>const data = [
  {id: 1, name: 'Foo'},
  {id: 2, name: 'Bar'},
]</pre>
<p>让我们先解决<strong>创造</strong>的问题。这很简单——它只是向数组(一个“表”)添加一个实体(在数据库语言中是一个“行”):</p>
<pre>const createEntity = (entity, data) =&gt; [entity, ...data]</pre>
<p>很好。接下来— <strong>读取</strong>给定id的单个实体:</p>
<pre>const getEntity = (idToFind, data) =&gt; data.find(
  ({ id }) =&gt; id === idToFind
)</pre>
<p><strong>更新</strong>一件物品是所有物品中最复杂的:</p>
<pre>const updateEntity = ({ id, changes }, data) =&gt; {
 const entity = getEntity(id, data)
 if (entity) {
   const dataCopy = data.slice() // in order to keep the original array intact
   const itemIndex = dataCopy.findIndex(({ id: _id }) =&gt; _id === id)
    dataCopy[itemIndex] = { ...dataCopy, ...changes }
   return dataCopy
  }
 return data
}</pre>
<p>最后，<strong>删除</strong>:</p>
<pre>const deleteEntity = (id, data) =&gt; data.filter(
  ({ id: _id }) =&gt; _id !== id
)</pre>
<p>上面的函数可能看起来不自然——为什么移除动作是通过过滤完成的？这些例子遵循编程中的函数式风格——它们不改变原始数据数组，而是返回它的副本。这种方法不容易出错，而且更加模块化——每个功能都是独立的操作，不依赖于任何外部状态。</p>
<p>这组函数还可以，但是对于真实世界的使用来说还不完整。没有在一次操作中处理多个项目的功能。另外，一个类似于<code>updateEntity</code>的函数怎么样，如果没有找到实体，它会创建一个实体。</p>
<p>最后，在较大规模下，将数据存储为数组在性能上是次优的。这就好像你把所有的东西都放在没有标签的盒子里，在寻找东西的时候不得不(最多)打开所有的盒子。更简单的方法是标记盒子——这意味着使用一个关联数组，也就是一个对象。</p>
<p>当然，某处肯定有人已经编写了一个优化的函数式CRUD工具集？</p>
<h2>见面<code>createEntityAdapter</code></h2>
<p>碰巧的是，在令人惊叹的<a href="https://redux-starter-kit.js.org/" target="_blank" rel="noopener noreferrer"> redux-toolkit </a>的最近<a href="https://github.com/reduxjs/redux-toolkit/releases/tag/v1.3.0" target="_blank" rel="noopener noreferrer">版本</a>中，添加了一个新的API，叫做<code>createEntityAdapter</code>。</p>
<p>这很好，因为在前端开发中，实体管理是一个需要重新发明轮子的领域。redux-toolkit通过这个新API带来的简化就像一股新鲜空气。</p>
<p>如果重复编写CRUD代码的经历与你无关，那么一个没有它的未来值得从NPM安装。</p>
<h3>项目概述</h3>
<p>每个开发人员都知道，学习的最好方法是构建一些东西。</p>
<p>这里的项目将非常简单，但它将代表大多数web应用程序的核心。</p>
<p>结果将看起来像一个漂亮而相当复杂的web应用程序，它在上班的路上遇到了一个喷砂工，但掉进了一个淡水池，所以看起来不太可怕(你会明白我的意思)。</p>
<p>最基本的，纯粹的商业逻辑，野兽派的学习材料。或者在某些情况下我们称之为公司内部工具。</p>
<p>它看起来是这样的:</p>
<p><img data-attachment-id="21442" data-permalink="https://blog.logrocket.com/building-the-simplest-crud-out-there-with-entity-management/users/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/07/users.png" data-orig-size="730,533" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="users" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/07/users-300x219.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/07/users.png" decoding="async" class="aligncenter wp-image-21442 size-full jetpack-lazy-image" src="../Images/4a0376cc20ae989426761f5828731888.png" alt="A list of users built with a CRUD operation." data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2020/07/users.png 730w, https://blog.logrocket.com/wp-content/uploads/2020/07/users-300x219.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2020/07/users.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/07/users.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="21442" data-permalink="https://blog.logrocket.com/building-the-simplest-crud-out-there-with-entity-management/users/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/07/users.png" data-orig-size="730,533" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="users" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/07/users-300x219.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/07/users.png" decoding="async" loading="lazy" class="aligncenter wp-image-21442 size-full" src="../Images/4a0376cc20ae989426761f5828731888.png" alt="A list of users built with a CRUD operation." srcset="https://blog.logrocket.com/wp-content/uploads/2020/07/users.png 730w, https://blog.logrocket.com/wp-content/uploads/2020/07/users-300x219.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/07/users.png"/></noscript>
<p>它显示用户列表(读取)，允许创建新用户，以及删除和更新样本。</p>
<h3>让我们开始吧</h3>
<p>下面假设对Redux和React有基本的熟悉。如果前者对你来说是全新的，也许值得阅读官方文件的这一部分。我将链接到Github上的具体提交，但如果你不喜欢克隆git库，最相关的部分将在本帖中转载。</p>
<p>这里是储存库。要快速开始，只需克隆它，安装我们在这个短暂的旅程中需要的所有东西，并启动服务器:</p>
<pre>$ git clone <a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="9cfbf5e8dcfbf5e8f4e9feb2fff3f1">[email protected]</a>:adekbadek/crude.git
$ cd crude
$ npm install
$ npm start</pre>
<p>这组法术完成后，你应该可以在<a href="http://localhost:1234" rel="nofollow"> http://localhost:1234 </a>惊叹这个站点了。</p>
<p>我们将在这里逐个提交，所以这个列表就像一个目录表。</p>
<h3>关于设置的说明</h3>
<p>除了我们显而易见的朋友Redux &amp; React，<a href="https://parceljs.org/" target="_blank" rel="noopener noreferrer"> parcel </a>用于捆绑代码，而<a href="https://watercss.kognise.dev/" target="_blank" rel="noopener noreferrer"> water </a>则是为了让我们在看一个没有风格的网站时不会掉出眼睛。</p>
<p>所有这些boiler-platey代码都添加到<a href="https://github.com/adekbadek/crude/commit/f176ba64dcceddf4a41b31b1244a5c6959f5b06a" target="_blank" rel="noopener noreferrer">这个commit </a>中。</p>
<h3>创造</h3>
<p>现在到了重要的部分，这是在<a href="https://github.com/adekbadek/crude/commit/7d9d46c94c26169d30ed06671f4ae3fdc4aeeba1" target="_blank" rel="noopener noreferrer">这里</a>。<a href="https://github.com/adekbadek/crude/commit/7d9d46c94c26169d30ed06671f4ae3fdc4aeeba1#diff-3bf35cd41da51153dcca3003656f7c67" target="_blank" rel="noopener noreferrer"> store.js文件</a>超级小，因为所有繁重的工作都外包给了<code>@reduxjs/toolkit</code>——开发人员需要做的就是理解和复制粘贴技能:</p>
<pre>const usersAdapter = createEntityAdapter()</pre>
<p>注意<code>createEntityAdapter</code>不需要任何参数。</p>
<p>它甚至不关心实体是如何命名的。</p><div class="code-block code-block-54">
<hr/>
<h3>更多来自LogRocket的精彩文章:</h3>

<hr/></div>
<p>调用这个函数的结果是<a href="https://redux-starter-kit.js.org/api/createEntityAdapter#crud-functions" target="_blank" rel="noopener noreferrer">一个CRUD函数</a>的工具带，其中有超过四个——尽管在这个应用程序中只使用最基本的。</p>
<pre>const usersSlice = createSlice({
  name: 'users',
  initialState: usersAdapter.getInitialState(),
  reducers: {
    usersAddOne: usersAdapter.addOne,
    usersAddMany: usersAdapter.addMany,
    userUpdate: usersAdapter.updateOne,
    userRemove: usersAdapter.removeOne,
  },
})</pre>
<p>对<code>createSlice</code>的调用增加了一点复杂性，与实体没有直接关系。这是因为<code>createEntityAdapter</code>返回多个“case reducers”，它们是单动作处理的reducer。</p>
<p>在redux的经典形式中，通常只有一个缩减器，一个switch语句处理多种情况。redux基于切片的风格可以说比传统风格简单一点，更类似于编程中的函数式范式。</p>
<p>为了创建一个用户，必须分派<code>usersAddOne</code>动作:</p>
<pre>dispatch(
  actions.usersAddOne({
    id: String(Math.random()),
    name: newUserName,
  })
)</pre>
<p>如您所见，分配了一个随机id。</p>
<p>只要数据存储在本地(而不是发送到服务器)，这是可以的。本文的最后一节描述了拥有服务器的意义，以及为现实世界的应用程序编写CRUD的意义。</p>
<h3>阅读</h3>
<p>读取数据通常被称为选择数据—还记得本文开头的SQL片段吗？</p>
<p>实体适配器有一个名为<code>getSelectors</code>的方法，它有一个可选的参数——一个将它指向状态的特定部分的函数。在我们的例子中，状态看起来像这样:</p>
<pre>{
  users: {ids: [], entities: {}}
}</pre>
<p>在用户切片的位置提示选择器获取逻辑非常简单。然后:</p>
<pre>const selectors = usersAdapter.getSelectors(state =&gt; state.users)</pre>
<p><code>getSelectors</code>方法返回<a href="https://redux-starter-kit.js.org/api/createEntityAdapter#selector-functions" target="_blank" rel="noopener noreferrer">五个选择符</a>，其中最重要的是<code>selectAll</code>和<code>selectById</code>，这一点不言自明。</p>
<p>我们的应用程序只会利用前者。剩下的三个是<code>selectEntities</code>、<code>selectTotal</code>、<code>selectIds</code>，都是蛮不言自明的。</p>
<h3>更新</h3>
<p>更新实体与创建实体非常相似。事实上如此相似，以至于有一个词代表“如果不存在就更新或插入”——up sert。理论上，你可以在一生中不创建实体，而只是增加它们。但这是一个少一点简洁就多一点清晰的例子。当您阅读创建实体的代码时，您知道该实体被认为是新的，这可能意味着很多。如果到处都有向上插入，就很难在代码中分辨出实体的旅程，好的代码是可读的代码。</p>
<p>在我们的应用中，我们将只通过<code>updateOne</code>函数处理单个用户(<a href="https://github.com/adekbadek/crude/commit/1b50561257feff73ae96483a634b244d52d5a2a1" target="_blank" rel="noopener noreferrer">在这里看一下</a>)上的单个字段的<strong>更新</strong>，该函数已经映射到<code>userUpdate</code> case reducer:</p>
<pre>dispatch(
  actions.userUpdate({
    id: user.id,
    changes: { name: newName },
  }),
)
</pre>
<p>注意动作负载的特殊形状:<code>{id, changes}</code>。</p>
<p>嘿，但是如果实体A的id是实体B变化的一部分呢？在这种奇怪的情况下，仍然会有两个实体，但是A的属性将被B的替换。请记住，<code>updateOne</code>执行浅层更新，这意味着实体的任何嵌套属性都必须完整传递。这可以在创建特殊的case reducers时解决——记住，您不必使用1:1的CRUD函数。</p>
<p>还有空间用于一些额外的逻辑，例如在某些情况下阻止更新:</p>
<pre>reducers: {
  updateUser(state, action) {
    if (!state.isDisabled) {
      usersAdapter.updateOne(state, action.payload)
    }
  }
}</pre>
<h2>删除</h2>
<p>其中最简单的操作。只有一句台词:</p>
<pre>dispatch(actions.userRemove(user.id))</pre>
<p>在这个简单的应用程序中，我们不关心删除用户可能带来的任何事情——但是在实体之间存在关系的大型应用程序中，事情就更复杂了。例如，在博客应用程序中删除用户时，他们的帖子会发生什么变化？和其他用户共同创建的帖子呢？</p>
<h3>少了什么？</h3>
<p>显然，这篇文章的主题是从与数据库的通信开始的！到目前为止，所有显示的代码都处理只存储在浏览器内存中的数据更新。请注意，这完全没问题——无论是出于隐私还是简单的原因。</p>
<h2>乐观的更新</h2>
<p>然而，大多数web应用程序遵循客户机-服务器模型，其中客户机(在本例中是浏览器)将数据与存储在服务器上的数据库同步。当用户更新数据时，应用程序向服务器发送一个更新数据的请求。</p>
<p>这种流程的一个含义是，在更新操作(例如单击按钮)和在屏幕上呈现更新的数据之间通常有一个滞后。一种流行的方法是在这个延迟期间禁用UI，但是在这个时代，互联网用户期望即时反馈。</p>
<p>由于这个原因，许多应用程序实现了乐观更新策略，这正是我们在这个示例应用程序中所做的——假设我们知道数据在更新后的样子。</p>
<p>让我们立即呈现更新的数据。然后，在服务器的响应返回后，我们处理任何错误和差异。</p>
<h2>结论</h2>
<p>我希望这篇文章解释了实体的概念和它们在web开发中的管理，并且CRUD的缩写现在已经很清楚了。</p>
<p>谢谢！</p><div class="code-block code-block-17">
<div class="blog-plug inline-plug react-plug" vwo-el-id="26283398190">
<h2 vwo-el-id="41600691720"><a href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener"> LogRocket </a>:全面了解您的生产React应用</h2><p>调试React应用程序可能很困难，尤其是当用户遇到难以重现的问题时。如果您对监视和跟踪Redux状态、自动显示JavaScript错误以及跟踪缓慢的网络请求和组件加载时间感兴趣，</p><a href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" vwo-el-id="19356441070">try LogRocket</a><p>. </p><a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="19356441380">
<img class="first-react-image alignnone size-full wp-image-46 jetpack-lazy-image jetpack-lazy-image--handled" src="../Images/f300c244a1a1cf916df8b4cb02bec6c6.png" vwo-el-id="18272717540" data-lazy-loaded="1" data-original-src="https://files.readme.io/27c94e7-Image_2017-06-05_at_9.46.04_PM.png"/>
</a>
<a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="19356441690">
<img class="second-react-image alignnone size-full wp-image-46 jetpack-lazy-image jetpack-lazy-image--handled" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" vwo-el-id="30720362350" data-lazy-loaded="1" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/>
</a>
<p vwo-el-id="28675660440" class="">LogRocket 结合了会话回放、产品分析和错误跟踪，使软件团队能够创建理想的web和移动产品体验。这对你来说意味着什么？</p>
<p>LogRocket不是猜测错误发生的原因，也不是要求用户提供截图和日志转储，而是让您回放问题，就像它们发生在您自己的浏览器中一样，以快速了解哪里出错了。</p>
<p>不再有嘈杂的警报。智能错误跟踪允许您对问题进行分类，然后从中学习。获得有影响的用户问题的通知，而不是误报。警报越少，有用的信号越多。</p>
<p vwo-el-id="28675660750">LogRocket Redux中间件包为您的用户会话增加了一层额外的可见性。LogRocket记录Redux存储中的所有操作和状态。</p>
<p vwo-el-id="28675661060">现代化您调试React应用的方式— <a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="40093418840">开始免费监控</a>。</p>
</div></div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
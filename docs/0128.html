<html>
<head>
<title>A comprehensive look back at front end in 2018 - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>2018年前端全面回眸——log rocket博客</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/a-comprehensive-look-back-at-frontend-in-2018-8122e724a802/#0001-01-01">https://blog.logrocket.com/a-comprehensive-look-back-at-frontend-in-2018-8122e724a802/#0001-01-01</a></blockquote><div><article class="article-post">
<p>Web开发一直是一个快速发展的领域——很难跟上所有浏览器的变化、库的发布和新的编程趋势，它们会在一年中淹没你的大脑。</p>
<p>这个行业每年都在变大，这使得一般的开发者很难跟上。所以让我们退一步，回顾一下2018年web开发社区发生了什么变化。</p>
<p>在过去的几年里，我们见证了JavaScript的爆炸性发展。随着互联网对全球经济变得更加重要，像谷歌和微软这样强大的商业利益相关者意识到他们需要更好的工具来创建下一代网络应用程序。</p>
<p>这导致了JavaScript自诞生以来最大的一波变化，从ECMAScript 2015(又名ES6)开始。现在每年发布的版本都给我们带来了令人兴奋的新特性，比如类、生成器、迭代器、承诺、全新的模块系统等等。</p>
<p>这开启了网络发展的黄金时代。许多当今最流行的工具、库和框架都是在ES2015发布后开始流行的。甚至在主流浏览器供应商支持新标准的一半之前，<a href="https://babeljs.io/" target="_blank" rel="noopener noreferrer"> Babel </a>编译器项目就已经允许数千名开发者抢先一步，亲自体验新特性。</p>
<p>前端开发者第一次不再受制于他们公司支持的最老的浏览器，而是可以按照自己的节奏自由创新。三年过去了，ECMAScript已经有了三个版本，这个web开发的新时代丝毫没有放缓的迹象。</p>
<h2>新的JS语言特性</h2>
<p>与之前的版本相比，ECMAScript 2018在功能方面相当轻便，仅添加了<a href="https://github.com/tc39/proposal-object-rest-spread" target="_blank" rel="noopener noreferrer">对象休息/传播属性</a>、<a href="https://github.com/tc39/proposal-async-iteration" target="_blank" rel="noopener noreferrer">异步迭代</a>和<a href="https://github.com/tc39/proposal-promise-finally" target="_blank" rel="noopener noreferrer"> Promise.finally </a>，这些都已经被Babel和<a href="https://github.com/zloirock/core-js#stage-3-proposals" target="_blank" rel="noopener noreferrer"> core-js </a>支持了一段时间。<a href="http://kangax.github.io/compat-table/es2016plus/#test-Asynchronous_Iterators" target="_blank" rel="noopener noreferrer">大多数浏览器</a>和<a href="https://node.green/" target="_blank" rel="noopener noreferrer"> Node.js </a>支持除Edge之外的所有ES2018，Edge只支持Promise.finally .对于许多开发者来说，这意味着他们需要的所有语言功能都在他们支持的所有浏览器中得到支持——有些人想知道Babel是否真的有必要了。</p>
<h3>新的正则表达式功能</h3>
<p>JavaScript一直缺少一些更高级的正则表达式特性，而Python等其他语言却有——直到现在。ES2018增加了四项新功能:</p>
<ul>
<li><a href="https://github.com/tc39/proposal-regexp-lookbehind" target="_blank" rel="noopener noreferrer">后视断言</a>，为早在1999年就出现在语言中的前视断言提供了缺失的补充。</li>
<li><a href="https://github.com/tc39/proposal-regexp-dotall-flag" target="_blank" rel="noopener noreferrer"> s (dotAll)标志</a>，匹配除行结束符以外的任何单个字符。</li>
<li><a href="https://github.com/tc39/proposal-regexp-named-groups" target="_blank" rel="noopener noreferrer">命名的捕获组</a>，通过允许基于属性的捕获组查找，使得使用正则表达式更加容易。</li>
<li><a href="https://github.com/tc39/proposal-regexp-unicode-property-escapes" target="_blank" rel="noopener noreferrer"> Unicode属性转义</a>，这使得编写能够识别Unicode的正则表达式成为可能。</li>
</ul>
<p>尽管这些特性中的许多已经有了解决方法和替代库，但没有一个能比得上本机实现提供的速度。</p>
<h2>新的浏览器功能</h2>
<p>今年发布了数量惊人的新JavaScript浏览器API。几乎所有方面都有所改善，比如网络安全、高性能计算和动画。让我们按领域对它们进行分解，以便更好地了解它们的影响。</p>
<h3>web程序集</h3>
<p>尽管WebAssembly v1支持在去年被添加到了主流浏览器中，但它尚未被开发人员社区广泛采用。WebAssembly组有一个<a href="https://webassembly.org/docs/future-features/" target="_blank" rel="noopener noreferrer">雄心勃勃的特性路线图</a>，包括<a href="https://github.com/WebAssembly/gc" target="_blank" rel="noopener noreferrer">垃圾收集</a>，ECMAScript模块集成，以及<a href="https://developers.google.com/web/updates/2018/10/wasm-threads" target="_blank" rel="noopener noreferrer">线程</a>等特性。也许有了这些特性，我们将开始看到web应用程序的广泛采用。</p>
<p>部分问题是WebAssembly需要大量的设置才能开始，并且许多习惯于JavaScript的开发人员不熟悉使用传统的编译语言。Firefox推出了一个名为<a href="https://hacks.mozilla.org/2018/04/sneak-peek-at-webassembly-studio/" target="_blank" rel="noopener noreferrer"> WebAssembly Studio </a>的在线IDE，让WebAssembly的入门变得尽可能简单。如果你想把它集成到现有的应用程序中，现在有很多工具可供选择。Webpack v4增加了实验性的<a href="https://github.com/webpack/webpack/releases/tag/v4.0.0" target="_blank" rel="noopener noreferrer">内置支持</a>，用于紧密集成到构建和模块系统中的WebAssembly模块，并具有源代码映射支持。</p>
<p>Rust已经成为编译成WebAssembly的最受欢迎的语言。它提供了一个健壮的包生态系统，有<a href="https://github.com/rust-lang/cargo" target="_blank" rel="noopener noreferrer"> cargo </a>，可靠的性能，和一个<a href="https://doc.rust-lang.org/book/" target="_blank" rel="noopener noreferrer">易学的</a>语法。已经有一个新兴的工具生态系统将Rust与JavaScript集成在一起。你可以使用<a href="https://github.com/rustwasm/wasm-pack" target="_blank" rel="noopener noreferrer"> wasm-pack </a>发布Rust WebAssembly包到NPM。如果你使用webpack，你现在可以使用<a href="https://github.com/dflemstr/rust-native-wasm-loader" target="_blank" rel="noopener noreferrer"> rust-native-wasm-loader </a>将Rust代码无缝集成到你的应用中。</p>
<p>如果您不想放弃JavaScript而使用WebAssembly，那么您很幸运——现在有几个选项可供选择。如果你熟悉TypeScript，有一个<a href="https://github.com/AssemblyScript/assemblyscript" target="_blank" rel="noopener noreferrer"> AssemblyScript </a>项目，它使用了官方的<a href="https://github.com/WebAssembly/binaryen" target="_blank" rel="noopener noreferrer"> Binaryen </a>编译器和TypeScript。</p>
<p>因此，它可以很好地与现有的TypeScript和WebAssembly工具配合使用。<a href="https://github.com/ballercat/walt" target="_blank" rel="noopener noreferrer"> Walt </a>是另一个编译器，它坚持JavaScript语法(带有类似TypeScript的类型提示),并直接编译成WebAssembly文本格式。它没有依赖性，编译速度非常快，并且与webpack集成。这两个项目都在积极开发中，根据您的标准，它们可能不被认为是“生产就绪的”无论如何，它们都值得一试。</p>
<h3>共用存储器</h3>
<p>现代JavaScript应用程序经常在<a href="https://developer.mozilla.org/en-US/docs/Web/API/Worker" target="_blank" rel="noopener noreferrer"> Web Workers </a>中进行繁重的计算，以避免阻塞主线程和中断浏览体验。虽然这些工人已经存在好几年了，但是他们的局限性阻止了他们被更广泛的采用。工作人员可以使用<a href="https://developer.mozilla.org/en-US/docs/Web/API/Worker/postMessage" target="_blank" rel="noopener noreferrer"> postMessage </a>方法在其他线程之间传输数据，该方法要么克隆正在发送的数据(较慢)，要么使用<a href="https://developer.mozilla.org/en-US/docs/Web/API/Transferable" target="_blank" rel="noopener noreferrer">可传输对象</a>(较快)。因此，线程之间的通信要么很慢，要么是单向的。对于简单的应用程序来说，这很好，但是它阻止了使用工人来构建更复杂的架构。</p>
<p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/SharedArrayBuffer" target="_blank" rel="noopener noreferrer"> SharedArrayBuffer </a>和<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Atomics" target="_blank" rel="noopener noreferrer"> Atomics </a>是新特性，允许JavaScript应用程序在上下文之间共享固定的内存缓冲区，并对其执行原子操作。然而，在发现共享内存使浏览器容易受到之前未知的被称为<a href="https://meltdownattack.com/" target="_blank" rel="noopener noreferrer">幽灵</a>的定时攻击后，浏览器支持被暂时移除。Chrome在7月份重新启用了SharedArrayBuffers，当时他们发布了一个缓解该漏洞的新安全功能。在Firefox中，它默认是禁用的，但可以被重新启用。Edge已经<a href="https://blogs.windows.com/msedgedev/2018/01/03/speculative-execution-mitigations-microsoft-edge-internet-explorer/#Yr2pGlOHTmaRJrLl.97" target="_blank" rel="noopener noreferrer">完全移除了支持</a>，微软也没有表示何时会重新启用。希望明年所有的浏览器都有缓解策略，这样这个关键的缺失功能就可以使用了。</p>
<h3>帆布</h3>
<p>Canvas和WebGL等图形API到现在已经支持好几年了，但是一直局限于只在主线程中渲染。因此，渲染可能会阻塞。这导致了糟糕的用户体验。<a href="https://developer.mozilla.org/en-US/docs/Web/API/OffscreenCanvas#Asynchronous_display_of_frames_produced_by_an_OffscreenCanvas" target="_blank" rel="noopener noreferrer"> OffscreenCanvas </a> API通过允许您将画布上下文(2D或WebGL)的控制权转移给web worker来解决这个问题。然后，工作人员可以像平常一样使用Canvas APIs，同时在主线程中无缝呈现，不会出现阻塞。</p>
<p>考虑到显著的性能节省，您可以期待图表和绘图库很快考虑支持它。浏览器支持目前仅限于Chrome，Firefox在幕后支持它，Edge团队尚未公开表示支持。你可以期待它与SharedArrayBuffers和WebAssembly很好地配对，允许工作人员基于任何线程中存在的数据，从任何语言编写的代码进行渲染，所有这些都没有janky用户体验。这可能会让网络高端游戏的梦想成为现实，并允许在网络应用程序中使用更复杂的图形。</p>
<p>为CSS带来新的绘图和布局API的努力正在进行中。目标是向web开发人员公开CSS引擎的一部分，以揭开CSS 的一些<a href="https://blog.logrocket.com/new-horizons-in-css-houdini-and-the-paint-api-8b307cf387bb" target="_blank" rel="noopener noreferrer">“魔法”。W3C的</a><a href="https://github.com/w3c/css-houdini-drafts/wiki" target="_blank" rel="noopener noreferrer"> CSS Houdini任务组</a>由来自主要浏览器厂商的工程师组成，在过去的两年里一直在努力工作，发布了<a href="https://drafts.css-houdini.org/" target="_blank" rel="noopener noreferrer">几个草案规范</a>，它们现在处于设计的最后阶段。</p>
<p>CSS Paint API 是第一批登陆浏览器的，早在一月份就登陆了Chrome 65。它允许开发人员使用类似上下文的API来绘制图像，这种API可以在CSS中需要图像的任何地方使用。它使用新的<a href="https://drafts.css-houdini.org/worklets" target="_blank" rel="noopener noreferrer"> Worklet </a>接口，这些接口基本上是轻量级的、高性能的<a href="https://developer.mozilla.org/en-US/docs/Web/API/Worker" target="_blank" rel="noopener noreferrer"> Worker </a>式的构造，用于专门的任务。像worker一样，它们在自己的执行上下文中运行，但与worker不同，它们是线程不可知的(浏览器选择它们在什么线程上运行)，并且它们可以访问渲染引擎。</p>
<p>使用Paint Worklet，您可以创建一个背景图像，当包含它的元素发生变化时，它会自动重绘。使用CSS属性，您可以添加在更改时触发重新绘制的参数，并且可以通过JavaScript进行控制。除了Edge之外，所有的浏览器都承诺支持，但是现在，有一个<a href="https://github.com/GoogleChromeLabs/css-paint-polyfill" target="_blank" rel="noopener noreferrer">聚合填充</a>。有了这个API，我们将开始看到组件化的图像以类似于我们现在看到组件的方式被使用。</p>
<h3>动画片</h3>
<p>大多数现代web应用程序使用动画作为用户体验的重要部分。像谷歌的Material Design这样的框架已经使它们成为他们的设计语言的重要组成部分，认为它们对于创造富有表现力和易于理解的用户体验是必不可少的。考虑到其重要性的提升，最近有一股推动力量将一个更强大的动画API引入JavaScript，这导致了Web动画API (WAAPI)的出现。</p>
<p>正如CSS-Tricks指出的那样，WAAPI提供了比CSS动画更好的开发体验，你可以轻松地记录和操作JS或CSS中定义的动画的状态。<a href="https://caniuse.com/#feat=web-animation" target="_blank" rel="noopener noreferrer">浏览器支持</a>目前主要限于Chrome和Firefox，但有一个<a href="https://github.com/web-animations/web-animations-js/tree/master" target="_blank" rel="noopener noreferrer">官方polyfill </a>可以满足你的一切需求。</p>
<p>性能一直是网页动画的一个问题，这个问题已经通过引入<a href="https://wicg.github.io/animation-worklet/" target="_blank" rel="noopener noreferrer">动画小工具</a>得到了解决。这种新的API允许复杂的动画并行运行，这意味着更高的帧速率动画不会受到主线程jank的影响。<a href="https://blog.logrocket.com/using-animation-worklet-4a3914c19112" target="_blank" rel="noopener noreferrer">动画工作小程序</a>遵循与网络动画API相同的接口，但是在工作小程序执行上下文中。</p>
<p>它预计将在Chrome 71(撰写本文时的下一个版本)和其他浏览器中发布。如果你今天想尝试一下，GitHub上有官方的<a href="https://github.com/GoogleChromeLabs/houdini-samples/tree/master/animation-worklet" target="_blank" rel="noopener noreferrer"> polyfill和示例回购</a>。</p>
<h3>安全性</h3>
<p>Spectre定时攻击并不是今年唯一的网络安全恐慌。NPM固有的脆弱性在过去已经被写了很多，上个月我们得到了一个来自T2的警告。这并不是NPM本身的安全漏洞，而是一个被称为<a href="https://www.npmjs.com/package/event-stream" target="_blank" rel="noopener noreferrer">事件流</a>的包，它被许多流行的包所使用。NPM允许软件包作者将所有权转让给任何其他成员，黑客说服所有者将其转让给他们。黑客随后发布了一个新版本，该版本对他们创建的名为<a href="https://www.npmjs.com/package/flatmap-stream" target="_blank" rel="noopener noreferrer"> flatmap-stream </a>的包有新的依赖性，如果恶意包与<a href="https://www.npmjs.com/package/copay-dash" target="_blank" rel="noopener noreferrer"> copay-dash </a>包一起安装，该包的代码旨在窃取<a href="https://copay.io/" target="_blank" rel="noopener noreferrer">比特币钱包</a>。</p>
<p>鉴于NPM的工作方式和社区随意安装看似有用的NPM软件包的倾向，这种攻击只会变得更加普遍。社区对软件包所有者寄予了很大的信任，这种信任受到了极大的质疑。NPM用户应该知道他们正在安装的每个包(包括依赖项的依赖项)，使用一个锁文件来锁定版本，并注册类似Github 提供的那些<a href="https://blog.github.com/2017-11-16-introducing-security-alerts-on-github/" target="_blank" rel="noopener noreferrer">安全警报。</a></p>
<p>NPM意识到了社区的安全问题，他们在过去的一年里已经采取措施来改善这种状况。你现在可以用<a href="https://blog.npmjs.org/post/166039777883/protect-your-npm-account-with-two-factor" target="_blank" rel="noopener noreferrer">双因素认证</a>来保护你的NPM账户，NPM v6现在包括了一个<a href="https://docs.npmjs.com/auditing-package-dependencies-for-security-vulnerabilities" target="_blank" rel="noopener noreferrer">安全审计</a>命令。</p>
<h3>监视</h3>
<p><a href="https://developers.google.com/web/updates/2018/09/reportingapi" target="_blank" rel="noopener noreferrer"> Reporting API </a>是一种新标准，旨在通过在出现问题时发出警报，让开发人员更容易发现他们应用程序的问题。如果您在过去几年中使用过Chrome DevTools控制台，您可能会看到<em>【干预】</em>警告消息，指出使用了过时的API或做了可能不安全的事情。这些信息仅限于客户端，但是现在您可以使用新的<a href="https://developers.google.com/web/updates/2018/07/reportingobserver" target="_blank" rel="noopener noreferrer">reporting bserver</a>将它们报告给分析工具。</p>
<p>有两种报告:</p>
<ul>
<li><a href="https://developers.google.com/web/updates/tags/deprecations" target="_blank" rel="noopener noreferrer">弃用</a>，当你使用一个过时的API时，它会警告你，并告诉你它什么时候会被删除。它还会告诉你文件名和它被使用的行号。</li>
<li><a href="https://www.chromestatus.com/features#intervention" target="_blank" rel="noopener noreferrer">干预</a>，当你以非预期的、危险的或不安全的方式使用API时，它会警告你。</li>
</ul>
<p>而像LogRocket这样的工具可以让开发者洞察他们应用程序中的错误。到目前为止，第三方工具还没有任何可靠的方法来记录这些警告。这意味着问题要么被忽视，要么表现为难以调试的错误消息。Chrome目前支持ReportingObserver API，其他浏览器也将很快支持。</p>
<h3>半铸钢ˌ钢性铸铁(Cast Semi-Steel)</h3>
<p>尽管JavaScript吸引了所有的注意力，但今年浏览器中还是出现了几个有趣的CSS新特性。</p>
<p>对于那些不知道的人，没有类似于ECMAScript的统一的CSS3规范。最后一个官方统一标准是CSS2.1，CSS3是指在此之后发布的任何标准。相反，每个部分都被单独标准化为一个“CSS模块”。MDN对每个模块标准及其状态有一个极好的概述。</p>
<p>截至2018年，一些较新的功能现已在所有主流浏览器中得到全面支持(这是2018年，IE不是主流浏览器)。这包括<a href="https://blog.logrocket.com/flexing-with-css-flexbox-b7940b329a8a" target="_blank" rel="noopener noreferrer"> flexbox </a>，<a href="https://caniuse.com/#feat=css-variables" target="_blank" rel="noopener noreferrer">自定义属性</a>(变量)，以及<a href="https://blog.logrocket.com/the-simpletons-guide-to-css-grid-1767565b3cf7" target="_blank" rel="noopener noreferrer">网格布局</a>。</p>
<p>虽然在过去曾有过<a href="https://tabatkins.github.io/specs/css-nesting/" target="_blank" rel="noopener noreferrer">关于在CSS中加入对嵌套规则的支持(比如LESS和SASS)的讨论，但是那些提议没有任何进展。7月份，W3C </a><a href="https://github.com/w3c/csswg-drafts/issues/2701#issuecomment-402392212" target="_blank" rel="noopener noreferrer">的CSS工作组决定对该提案再做一次研究，但还不清楚这是否是优先考虑的事情。</a></p>
<h3>节点. js</h3>
<p>Node在遵循ECMAScript标准方面继续取得出色进展，截至12月，他们<a href="https://node.green/" target="_blank" rel="noopener noreferrer">支持所有ES2018 </a>。另一方面，他们在采用ECMAScript模块系统方面进展缓慢，因此缺少了一个关键的功能，这个功能阻止了浏览器的功能对等，而浏览器已经支持ES模块一年多了。Node实际上在v11.4.0中增加了<a href="https://nodejs.org/api/esm.html" target="_blank" rel="noopener noreferrer">实验支持</a>的一个标志后面，但这要求文件使用新的。mjs扩展，导致<a href="https://github.com/nodejs/modules/issues/57" target="_blank" rel="noopener noreferrer">担心</a>采用缓慢以及这会对Node的丰富包生态系统产生什么影响。</p>
<p>如果您希望快速起步，并且不希望使用实验性的内置支持，Lodash的创建者有一个有趣的项目，名为<a href="https://medium.com/web-on-the-edge/tomorrows-es-modules-today-c53d29ac448c" target="_blank" rel="noopener noreferrer"> esm </a>，它为节点es模块提供了比官方解决方案更好的互操作性和性能支持。</p>
<h2>工具和框架</h2>
<h3>反应</h3>
<p>React 今年有两个值得注意的版本。React 16.3支持一套新的<a href="https://reactjs.org/blog/2018/03/29/react-v-16-3.html#component-lifecycle-changes" target="_blank" rel="noopener noreferrer">生命周期方法</a>和一个新的官方<a href="https://reactjs.org/blog/2018/03/29/react-v-16-3.html#official-context-api" target="_blank" rel="noopener noreferrer">上下文API </a>。React 16.6增加了一个名为“悬念”的新功能，让React能够在组件等待数据获取或<a href="https://reactjs.org/docs/code-splitting.html#reactlazy" target="_blank" rel="noopener noreferrer">代码分割</a>等任务完成时暂停渲染。</p>
<p>今年谈论最多的React话题是<a href="https://reactjs.org/docs/hooks-intro.html" target="_blank" rel="noopener noreferrer"> React Hooks </a>的推出。该提议旨在使编写更小的组件变得更容易，而不牺牲有用的功能，这些功能目前仅限于类组件。React将提供两个内置钩子，一个是状态钩子，它让功能组件使用状态，另一个是<a href="https://reactjs.org/docs/hooks-effect.html#tip-use-multiple-effects-to-separate-concerns" target="_blank" rel="noopener noreferrer">效果钩子</a>，它让你在功能组件中执行副作用。虽然没有从React中移除类的计划，但React团队显然希望钩子成为React未来的核心。在他们被宣布后，社区中有一个积极的反应(<a href="https://twitter.com/dan_abramov/status/1057027428827193344" target="_blank" rel="noopener noreferrer">有些人可能会说被夸大了</a>)。如果你有兴趣了解更多，请查看<a href="https://medium.com/@dan_abramov/making-sense-of-react-hooks-fdbde8803889" target="_blank" rel="noopener noreferrer">丹·阿布拉莫夫的博客文章</a>综合概述。</p>
<p>明年，React计划发布一个名为<a href="https://reactjs.org/blog/2018/11/27/react-16-roadmap.html#react-16x-q2-2019-the-one-with-concurrent-mode" target="_blank" rel="noopener noreferrer">并发模式</a>的新特性(以前称为“异步模式”或“异步渲染”)。这将允许React在不阻塞主线程的情况下呈现大型组件树。对于具有深度组件树的大型应用程序，性能节省可能非常显著。目前还不清楚API到底是什么样子，但React团队的目标是尽快完成它，并在明年的某个时候发布。如果您对采用这一特性感兴趣，请通过采用React 16.3中发布的新生命周期方法来确保您的代码库是兼容的。</p>
<p>React越来越受欢迎，根据JavaScript 2018年调查的状况，64%的受访者使用它并将再次使用它(自去年以来增加了7.1%)，相比之下，<a href="https://2018.stateofjs.com/front-end-frameworks/vuejs/" target="_blank" rel="noopener noreferrer">的Vue </a>为28%(+9.2%)，而<a href="https://2018.stateofjs.com/front-end-frameworks/angular/" target="_blank" rel="noopener noreferrer">的Angular </a>为23%(+5.1%)。</p>
<h3>网络包</h3>
<p><a href="https://webpack.js.org" target="_blank" rel="noopener noreferrer"> Webpack </a> 4于<a href="https://github.com/webpack/webpack/releases/tag/v4.0.0-beta.0" target="_blank" rel="noopener noreferrer">二月</a>发布，带来了巨大的性能改进，内置的生产和开发模式，易于使用的优化，如代码分割和缩小，实验性WebAssembly支持，以及ECMAScript模块支持。Webpack现在比以前的版本更容易使用，以前复杂的功能，如代码分割和优化，现在设置起来非常简单。与TypeScript或Babel相结合，webpack仍然是web开发人员的基础工具，在不久的将来，竞争对手似乎不太可能出现并取代它。</p>
<h3>巴比伦式的城市</h3>
<p>《通天塔》7于今年八月在<a href="https://babeljs.io/blog/2018/08/27/7.0.0" target="_blank" rel="noopener noreferrer">发布，这是近三年来的第一次重大发布。主要变化包括</a><a href="https://twitter.com/left_pad/status/927554660508028929" target="_blank" rel="noopener noreferrer">更快的构建时间</a>，一个新的包命名空间，以及支持<a href="https://babeljs.io/docs/en/next/babel-preset-env.html" target="_blank" rel="noopener noreferrer"> preset-env </a>的各种“stage”和年度ECMASCript预设包的弃用，这通过自动包含您支持的浏览器所需的插件极大地简化了Babel的配置。此版本还增加了<a href="https://babeljs.io/blog/2018/08/27/7.0.0#automatic-polyfilling-experimental" target="_blank" rel="noopener noreferrer">自动多孔填充</a>，无需导入整个Babel多孔填充(这相当大)，也无需显式导入您需要的多孔填充(这既耗时又容易出错)。</p>
<p>Babel现在<a href="https://blogs.msdn.microsoft.com/typescript/2018/08/27/typescript-and-babel-7/" target="_blank" rel="noopener noreferrer">也支持TypeScript语法</a>，这使得开发者更容易将Babel和TypeScript结合使用。Babel 7.1还增加了对新的<a href="https://babeljs.io/blog/2018/09/17/decorators" target="_blank" rel="noopener noreferrer">装饰者提案</a>的支持，该提案与社区广泛采用的过时提案不兼容，但与浏览器将支持的内容相匹配。谢天谢地，巴别塔团队已经发布了一个<a href="https://babeljs.io/blog/2018/09/17/decorators#upgrading" target="_blank" rel="noopener noreferrer">兼容性包</a>，这将使升级变得更加容易。</p>
<h3>电子</h3>
<p>电子仍然是为桌面打包JavaScript应用程序最流行的方式，尽管这是否是一件好事还有些争议。一些最流行的桌面应用程序现在使用Electron来降低开发成本，使开发跨平台应用程序变得容易。</p>
<p>一个常见的抱怨是使用电子的应用程序倾向于使用太多的内存，因为每个应用程序都打包了一个完整的Chrome实例(这是非常占用内存的)。<a href="https://github.com/GoogleChromeLabs/carlo" target="_blank" rel="noopener noreferrer"> Carlo </a>是谷歌的一个电子版，使用本地安装的Chrome版本(这是谷歌需要的)，导致应用程序对内存的需求减少。电子本身在提高性能方面没有太大进展，<a href="https://electronjs.org/blog/electron-3-0" target="_blank" rel="noopener noreferrer">最近的更新</a>集中在更新Chrome依赖和小的API变化上。</p>
<h3>以打字打的文件</h3>
<p>TypeScript 在过去的一年里越来越受欢迎，成为ES6作为JavaScript主流风格的真正挑战者。自从微软每月发布新版本以来，开发在过去的一年中进展相当迅速。TypeScript团队非常关注开发人员的体验，包括语言本身和围绕它的编辑器工具。</p>
<p>最近的版本增加了对开发者更友好的<a href="https://blogs.msdn.microsoft.com/typescript/2018/07/30/announcing-typescript-3-0/#improved-errors-and-ux" target="_blank" rel="noopener noreferrer">错误格式化</a>和强大的重构特性，比如<a href="https://blogs.msdn.microsoft.com/typescript/2018/05/31/announcing-typescript-2-9/#rename-move-file" target="_blank" rel="noopener noreferrer">自动导入更新</a>和<a href="https://blogs.msdn.microsoft.com/typescript/2018/03/27/announcing-typescript-2-8/#organize-imports" target="_blank" rel="noopener noreferrer">导入组织</a>等等。与此同时，改进类型系统的工作还在继续，增加了一些新的特性，比如条件类型和未知类型。</p>
<p>2018年JavaScript状况调查指出，<a href="https://2018.stateofjs.com/javascript-flavors/typescript/" target="_blank" rel="noopener noreferrer">近一半的受访者</a>使用TypeScript，在过去两年中呈强劲上升趋势。相比之下，它的主要竞争对手Flow在受欢迎程度上停滞不前，大多数开发者说他们不喜欢它缺乏工具和受欢迎的势头。TypeScript令人钦佩，因为它使开发人员能够轻松地编写由强大的编辑器支持的健壮而优雅的代码。它的赞助商微软似乎比脸书更愿意支持它，开发者们显然也注意到了这一点。</p>
<p> </p><div class="code-block code-block-17">
<div class="blog-plug inline-plug react-plug" vwo-el-id="26283398190">
<h2 vwo-el-id="41600691720">使用LogRocket消除传统反应错误报告的噪音</h2>
<a href="https://lp.logrocket.com/blg/react-signup-issue-free" target="_blank" vwo-el-id="19356441070">LogRocket
</a><p>是一款React analytics解决方案，可保护您免受数百个误报错误警报的影响，只针对少数真正重要的项目。LogRocket告诉您React应用程序中实际影响用户的最具影响力的bug和UX问题。</p><a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="19356441380">
<img class="first-react-image alignnone size-full wp-image-46 jetpack-lazy-image jetpack-lazy-image--handled" src="../Images/f300c244a1a1cf916df8b4cb02bec6c6.png" vwo-el-id="18272717540" data-lazy-loaded="1" data-original-src="https://files.readme.io/27c94e7-Image_2017-06-05_at_9.46.04_PM.png"/>
</a>
<a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="19356441690">
<img class="second-react-image alignnone size-full wp-image-46 jetpack-lazy-image jetpack-lazy-image--handled" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" vwo-el-id="30720362350" data-lazy-loaded="1" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/>
</a>
<a href="https://lp.logrocket.com/blg/react-signup-issue-free" target="_blank" rel="noopener noreferrer" vwo-el-id="35866400580">LogRocket
</a><p>自动聚合客户端错误、反应错误边界、还原状态、缓慢的组件加载时间、JS异常、前端性能指标和用户交互。然后，LogRocket使用机器学习来通知您影响大多数用户的最具影响力的问题，并提供您修复它所需的上下文。</p><p vwo-el-id="28675661060">关注重要的React bug—<a class="signup" href="https://lp.logrocket.com/blg/react-signup-issue-free" target="_blank" rel="noopener noreferrer" vwo-el-id="40093418840">今天就试试LogRocket】。</a></p><div class="code-block code-block-21">
<div class="blog-plug inline-plug typescript-plug"><h2><a class="signup" href="https://lp.logrocket.com/blg/typescript-signup" target="_blank" rel="noopener noreferrer"> LogRocket </a>:全面了解您的网络和移动应用</h2>
<a href="https://lp.logrocket.com/blg/typescript-signup" class="signup" target="_blank" rel="noopener noreferrer"><img class="alignnone size-full wp-image-46 jetpack-lazy-image" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/><noscript><img data-lazy-fallback="1" class="alignnone size-full wp-image-46" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/></noscript></a>
<p>LogRocket 是一个前端应用程序监控解决方案，可以让您回放问题，就像问题发生在您自己的浏览器中一样。LogRocket不需要猜测错误发生的原因，也不需要向用户询问截图和日志转储，而是让您重放会话以快速了解哪里出错了。它可以与任何应用程序完美配合，不管是什么框架，并且有插件可以记录来自Redux、Vuex和@ngrx/store的额外上下文。</p>
<p>除了记录Redux操作和状态，LogRocket还记录控制台日志、JavaScript错误、堆栈跟踪、带有头+正文的网络请求/响应、浏览器元数据和自定义日志。它还使用DOM来记录页面上的HTML和CSS，甚至为最复杂的单页面和移动应用程序重新创建像素级完美视频。</p>
<a class="signup" href="https://lp.logrocket.com/blg/typescript-signup" target="_blank" rel="noopener noreferrer">Try it for free</a><p>.</p></div>
</div>
</div></div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
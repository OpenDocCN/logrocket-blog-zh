<html>
<head>
<title>Getting started with Bree.js - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>Bree.js - LogRocket博客入门</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/getting-started-with-bree-js/#0001-01-01">https://blog.logrocket.com/getting-started-with-bree-js/#0001-01-01</a></blockquote><div><article class="article-post">
<p>本文涵盖了Bree.js是什么以及如何开始构建一个实际的应用程序。</p>
<h3>Bree.js是什么？</h3>
<p>Bree.js是Node.js应用程序的作业调度程序。<a href="https://en.wikipedia.org/wiki/Job_scheduler" target="_blank" rel="noopener noreferrer">作业调度</a>是以预定的、重复的方式执行一段代码的过程。</p>
<p>Node.js社区中还有其他可用的作业调度程序。然而，有一些很好的理由说明为什么我们应该选择Bree.js而不是其他。</p>
<h2>为什么是BreeJS？</h2>
<h4>工作线程</h4>
<p>Bree.js在幕后使用工作线程。由于工作线程在Node.js LTS版本中可用，所以最好使用线程来完成后台作业，而不是使用主线程。</p>
<h4>并发、节流和重试</h4>
<p>Bree.js帮助您同时运行作业，并提供重试选项。有时，您需要重试作业中的特定操作。你可以使用像<a href="https://github.com/sindresorhus/p-all" target="_blank" rel="noopener noreferrer"> this </a>这样的库来实现。</p>
<h2>安装和设置</h2>
<p>让我们安装Bree.js，看看如何在Node.js中开始一个简单的计划作业:</p>
<pre>npm install bree</pre>
<p>之后，让我们在根目录下创建一个名为<code>jobs</code>的文件夹，其中包含所有后台作业:</p>
<p><img data-attachment-id="23857" data-permalink="https://blog.logrocket.com/getting-started-with-bree-js/bree-js-jobs/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/08/bree-js-jobs.png" data-orig-size="869,435" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="bree-js-jobs" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/08/bree-js-jobs-300x150.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/08/bree-js-jobs.png" decoding="async" class="aligncenter wp-image-23857 jetpack-lazy-image" src="../Images/708b995d5d7cea22513d1e732893e666.png" alt="The file for Bree.js jobs." data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2020/08/bree-js-jobs.png 869w, https://blog.logrocket.com/wp-content/uploads/2020/08/bree-js-jobs-300x150.png 300w, https://blog.logrocket.com/wp-content/uploads/2020/08/bree-js-jobs-768x384.png 768w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2020/08/bree-js-jobs.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/08/bree-js-jobs.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="23857" data-permalink="https://blog.logrocket.com/getting-started-with-bree-js/bree-js-jobs/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/08/bree-js-jobs.png" data-orig-size="869,435" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="bree-js-jobs" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/08/bree-js-jobs-300x150.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/08/bree-js-jobs.png" decoding="async" loading="lazy" class="aligncenter wp-image-23857" src="../Images/708b995d5d7cea22513d1e732893e666.png" alt="The file for Bree.js jobs." srcset="https://blog.logrocket.com/wp-content/uploads/2020/08/bree-js-jobs.png 869w, https://blog.logrocket.com/wp-content/uploads/2020/08/bree-js-jobs-300x150.png 300w, https://blog.logrocket.com/wp-content/uploads/2020/08/bree-js-jobs-768x384.png 768w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/08/bree-js-jobs.png"/></noscript>
<blockquote class="embedly-card" data-card-controls="1" data-card-align="center" data-card-theme="light">

<p>跳转到内容这个有趣的，经典的模拟把一个绘图变成一个轨道链！如果你感到困惑，试着减少循环次数🙂欢迎加入我的编码服务器:<a href="https://discord.gg/9PSpWyTNkB" rel="nofollow">https://discord.gg/9PSpWyTNkB</a>一个简单的命令行翻译器，使用由Brave托管的Lingvanex翻译API。</p>
</blockquote>
<p/>
<p><code>bree.start()</code>将启动调度程序并运行所有已配置的作业。这里，我们有一个作业数组，它包含所有后台作业。该名称应该与作业目录中声明的文件名相匹配。</p>
<p>例如，这里我们有一个作业<code>test</code>。因此，jobs目录应该包含一个名为<code>test.js</code>的文件来运行这个作业。我们可以在<code>test.js</code>中编写我们的逻辑，它与后台作业一起运行。</p>
<p>一旦我们运行了脚本，我们就可以运行作业并执行作业脚本文件中的逻辑。</p>
<p><img data-attachment-id="23858" data-permalink="https://blog.logrocket.com/getting-started-with-bree-js/worker-job-test/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/08/worker-job-test.png" data-orig-size="780,218" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="worker-job-test" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/08/worker-job-test-300x84.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/08/worker-job-test.png" decoding="async" class="aligncenter wp-image-23858 jetpack-lazy-image" src="../Images/0ed45f2d50ecce59ab63e512346ff36f.png" alt="Worker job test." data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2020/08/worker-job-test.png 780w, https://blog.logrocket.com/wp-content/uploads/2020/08/worker-job-test-300x84.png 300w, https://blog.logrocket.com/wp-content/uploads/2020/08/worker-job-test-768x215.png 768w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2020/08/worker-job-test.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/08/worker-job-test.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="23858" data-permalink="https://blog.logrocket.com/getting-started-with-bree-js/worker-job-test/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/08/worker-job-test.png" data-orig-size="780,218" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="worker-job-test" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/08/worker-job-test-300x84.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/08/worker-job-test.png" decoding="async" loading="lazy" class="aligncenter wp-image-23858" src="../Images/0ed45f2d50ecce59ab63e512346ff36f.png" alt="Worker job test." srcset="https://blog.logrocket.com/wp-content/uploads/2020/08/worker-job-test.png 780w, https://blog.logrocket.com/wp-content/uploads/2020/08/worker-job-test-300x84.png 300w, https://blog.logrocket.com/wp-content/uploads/2020/08/worker-job-test-768x215.png 768w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/08/worker-job-test.png"/></noscript>
<h2>安排工作</h2>
<p>到目前为止，我们已经了解了如何在脚本启动时运行作业。现在，让我们看看如何使用Bree.js安排作业。安排作业很简单。您只需要向jobs数组元素传递一个附加参数:</p>
<p><img data-attachment-id="23859" data-permalink="https://blog.logrocket.com/getting-started-with-bree-js/index-js-bree/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/08/index-js-bree.png" data-orig-size="902,463" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="index-js-bree" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/08/index-js-bree-300x154.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/08/index-js-bree.png" decoding="async" class="aligncenter wp-image-23859 jetpack-lazy-image" src="../Images/9cb0e8ec004eaa47b6d980cfe7fea432.png" alt="The index section of Bree.js." data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2020/08/index-js-bree.png 902w, https://blog.logrocket.com/wp-content/uploads/2020/08/index-js-bree-300x154.png 300w, https://blog.logrocket.com/wp-content/uploads/2020/08/index-js-bree-768x394.png 768w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2020/08/index-js-bree.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/08/index-js-bree.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="23859" data-permalink="https://blog.logrocket.com/getting-started-with-bree-js/index-js-bree/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/08/index-js-bree.png" data-orig-size="902,463" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="index-js-bree" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/08/index-js-bree-300x154.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/08/index-js-bree.png" decoding="async" loading="lazy" class="aligncenter wp-image-23859" src="../Images/9cb0e8ec004eaa47b6d980cfe7fea432.png" alt="The index section of Bree.js." srcset="https://blog.logrocket.com/wp-content/uploads/2020/08/index-js-bree.png 902w, https://blog.logrocket.com/wp-content/uploads/2020/08/index-js-bree-300x154.png 300w, https://blog.logrocket.com/wp-content/uploads/2020/08/index-js-bree-768x394.png 768w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/08/index-js-bree.png"/></noscript>
<p>这里，我们有一个参数<code>interval</code>，它每5秒运行一次脚本。</p>
<pre>const Bree = require('bree')
const bree = new Bree({
  jobs : [
    // runs the job on Start
    'test',
    {
      name : 'sample',
      interval : '5s'
    }
  ]
})
bree.start()</pre>
<p>我们的输出将如下所示:</p>
<p><img data-attachment-id="23860" data-permalink="https://blog.logrocket.com/getting-started-with-bree-js/worker-for-job-test/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/08/worker-for-job-test.png" data-orig-size="684,494" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="worker-for-job-test" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/08/worker-for-job-test-300x217.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/08/worker-for-job-test.png" decoding="async" class="aligncenter wp-image-23860 jetpack-lazy-image" src="../Images/1ba81bdc567ed445c3cf84656c1ee816.png" alt="The worker for our test." data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2020/08/worker-for-job-test.png 684w, https://blog.logrocket.com/wp-content/uploads/2020/08/worker-for-job-test-300x217.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2020/08/worker-for-job-test.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/08/worker-for-job-test.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="23860" data-permalink="https://blog.logrocket.com/getting-started-with-bree-js/worker-for-job-test/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/08/worker-for-job-test.png" data-orig-size="684,494" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="worker-for-job-test" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/08/worker-for-job-test-300x217.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/08/worker-for-job-test.png" decoding="async" loading="lazy" class="aligncenter wp-image-23860" src="../Images/1ba81bdc567ed445c3cf84656c1ee816.png" alt="The worker for our test." srcset="https://blog.logrocket.com/wp-content/uploads/2020/08/worker-for-job-test.png 684w, https://blog.logrocket.com/wp-content/uploads/2020/08/worker-for-job-test-300x217.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/08/worker-for-job-test.png"/></noscript>
<p>您还可以使用其他选项来计划作业，包括以下选项:</p>
<h4>超时</h4>
<p>超时在作业配置中的指定时间后运行脚本。您可以用它来替代JavaScript中的<code>setTimeout</code>。</p>
<pre>const Bree = require('bree')
const bree = new Bree({
  jobs : [
    // runs the job on Start
    'test',
    {
      name : 'sample',
      timeout : '30s' //run the script after 30 seconds from the start
    }
  ]
})
bree.start()</pre>
<h4>时间单位</h4>
<p>Cron只是用于在Node.js中运行cron作业。cron作业的用例包括根据指定的小时、天、月或年备份数据库和运行脚本。</p>
<pre>const Bree = require('bree')
const bree = new Bree({
  jobs : [
    // runs the job on Start
    'test',
    {
      name : 'sample',
      cron : '* * * * *'
      // timeout : '30s' //run the script after 30 seconds from the start
    }
  ]
})
bree.start()</pre>
<p>到目前为止，我们已经了解了如何安排作业。现在，我们将看到如何从主文件向我们的作业传递一个值。</p>
<h2>传递数据</h2>
<p>因为Bree.js使用一个工作线程，所以您可以使用相同的概念将数据传递给一个工作线程。您只需传递<code>workerData</code>中的数据，该数据将出现在相应的作业文件中:</p>
<pre>const Bree = require('bree')
const bree = new Bree({
  jobs : [
    // runs the job on Start
    // 'test',
    {
      name : 'sample',
      worker: {
        workerData: {
          foo: 'bar',
          beep: 'boop'
        }
      }
      // cron : '* * * * *'
      // timeout : '30s' //run the script after 30 seconds from the start
    }
  ]
})
bree.start()</pre>
<pre>const { Worker, isMainThread, workerData } = require('worker_threads');
console.log("worker data",workerData.foo)</pre>
<p>我们现在已经开始触及Bree.js的皮毛。</p>
<p>以上细节已在<a href="https://jobscheduler.net" target="_blank" rel="noopener noreferrer"> Breejs </a>的文档中提供。我不想在本文中再次浏览文档，因为它已经被很好地记录了。</p>
<p>相反，我们将构建一个使用Bree.js的小应用程序。这样，我们将学习如何在实际应用中使用Bree.js。</p>
<p>这里，我们将构建一个Twitter调度程序应用程序。它允许用户在指定的时间安排一个Tweet。让我们看看如何使用Bree.js构建这个应用程序:</p>
<p><span class="embed-youtube"> <iframe loading="lazy" class="youtube-player" src="https://www.youtube.com/embed/pas2zS2zmmc?version=3&amp;rel=1&amp;showsearch=0&amp;showinfo=1&amp;iv_load_policy=1&amp;fs=1&amp;hl=en-US&amp;autohide=2&amp;wmode=transparent" allowfullscreen="true" sandbox="allow-scripts allow-same-origin allow-popups allow-presentation">视频</iframe> </span></p>
<h2>安装和设置</h2>
<p>让我们安装该应用程序所需的依赖项:</p>
<pre>npm install express bree body-parser cabin ejs twit passport passport-twitter</pre>
<ul>
<li><a href="https://expressjs.com/" target="_blank" rel="noopener noreferrer">express</a>–web服务器处理服务器端的请求</li>
<li><a href="https://jobscheduler.net/" target="_blank" rel="noopener noreferrer">Bree</a>–任务调度器，用于调度推文</li>
<li><a href="https://www.npmjs.com/package/body-parser" target="_blank" rel="noopener noreferrer">body-parser</a>–lib解析POST请求体</li>
<li><a href="https://github.com/cabinjs/cabin" target="_blank" rel="noopener noreferrer">小屋</a>–测井库(Bree.js推荐用于测井)</li>
<li>ejs–呈现网页的模板引擎</li>
<li><a href="https://www.npmjs.com/package/twit" target="_blank" rel="noopener noreferrer">twit</a>–Twitter客户端库将数据发布到Twitter</li>
<li><a href="https://www.npmjs.com/package/passport" target="_blank" rel="noopener noreferrer">passport</a>–用于处理Twitter认证</li>
</ul>
<p>接下来，在根目录中创建<code>app.js</code>,并添加以下代码:</p>
<pre>const express = require("express");
const bodyParser = require("body-parser");
const expressLayouts = require("express-ejs-layouts");
const passport = require("passport");
const session = require("express-session");
const mongoose = require("mongoose");
const app = express();
const routes = require("./routes");
const dotenv = require("dotenv");
const Bree = require("bree");
const Cabin = require("cabin");
dotenv.config({});

const MONGO_USER = process.env.MONGODB_USER;
const MONGO_PASSWORD = process.env.MONGODB_PASSWORD;

// MONGODB Connection
mongoose
  .connect(
    &lt;url&gt;,
    { useNewUrlParser: true, useCreateIndex: true, useUnifiedTopology: true }
  )
  .then((res) =&gt; {
    console.log("mongodb connected successfully");
    app.use(bodyParser.json());
    app.use(bodyParser.urlencoded({ extended: false }));

    // Template Engine
    app.use(expressLayouts);
    app.set("view engine", "ejs");

    //Passport Configuration
    require("./config/passport")(passport);

    // Express Session for the application
    app.use(
      session({
        secret: "abcdefg",
        resave: true,
        saveUninitialized: false,
      })
    );

    // passport initialization
    app.use(passport.initialize());
    app.use(passport.session());

    // breejs configuration.
    const bree = new Bree({
      //   logger: new Cabin(),
      jobs: [{ name: "tweet-schedule", interval: "1m" }],
    });
    bree.start();

    //routes
    app.use("/", routes);

    //PORT for our application.
    const PORT = process.env.PORT || 4500;
    app.listen(PORT, () =&gt; {
      console.log(`Server is running on PORT ${PORT}`);
    });
  })
  .catch((err) =&gt; {
    console.log("Error in mongodb connection", err);
  });</pre>
<p>我们有一个MongoDB连接功能，它通过MongoDB URI进行连接:</p>
<pre>mongoose
  .connect(
    &lt;url&gt;,
    { useNewUrlParser: true, useCreateIndex: true, useUnifiedTopology: true }
  ){
     //logic comes here
   }</pre>
<p>之后，我们必须实现POST请求的主体解析器和模板引擎的设置，这是<code>ejs</code>:</p>
<pre>app.use(bodyParser.json());
app.use(bodyParser.urlencoded({ extended: false }));
app.use(expressLayouts);
app.set("view engine", "ejs");</pre>
<p>之后，我们可以设置快速会话和passport初始化:</p>
<pre>app.use(
      session({
        secret: "abcdefg",
        resave: true,
        saveUninitialized: false,
      })
);
app.use(passport.initialize());
app.use(passport.session());</pre>
<p>最后，我们将使用jobs配置来设置Bree.js，以实现Tweet调度功能。</p>
<pre>const bree = new Bree({
      //   logger: new Cabin(),
      jobs: [{ name: "tweet-schedule", interval: "1m" }],
    });
    bree.start();</pre>
<h2>调度程序逻辑</h2>
<p>让我们编写调度程序作业功能的逻辑。</p>
<p>在<code>jobs</code>目录中创建一个文件<code>tweet-scheduler.js</code>。现在，添加以下代码:</p>
<pre>const { parentPort } = require("worker_threads");
const Cabin = require("cabin");
const { Signale } = require("signale");
const Jobs = require("../models/Jobs");
const User = require("../models/User");
const mongoose = require("mongoose");
const moment = require("moment-timezone");
const tweetUtils = require("../lib/tweetUtils");
const cabin = new Cabin({
  axe: {
    logger: new Signale(),
  },
});
let isCancelled = false;
if (parentPort) {
  parentPort.once("message", (message) =&gt; {
    if (message === "cancel") isCancelled = true;
  });
}
(async () =&gt; {
  await mongoose.connect(
    &lt;URL&gt;,
    { useNewUrlParser: true, useCreateIndex: true, useUnifiedTopology: true }
  );
  const tweetJobs = await Jobs.find({ isActive: true }).exec();
  await Promise.all(
    tweetJobs.map(async (tweet) =&gt; {
      return new Promise(async (resolve, reject) =&gt; {
        try {
          if (isCancelled) return;
          const user = await User.findById({ _id: tweet.userId }).exec();
          if (
            moment().tz(tweet.timezone).format("YYYY-MM-DD HH:mm") &lt;
            moment(tweet.scheduledTime, "YYYY-MM-DD HH:mm").format(
              "YYYY-MM-DD HH:mm"
            )
          ) {
            console.log("It it not time yet to post tweet");
            // return;
            resolve();
          } else {
            console.log("==================");
            try {
              await tweetUtils({
                accessToken: user.twitter.accessToken,
                accessSecret: user.twitter.refreshToken,
                tweet: tweet.body,
              });
              await Jobs.findOneAndUpdate(
                { _id: tweet._id },
                { isActive: false }
              );
            } catch (e) {
              cabin.error(e);
            }
            resolve();
          }
        } catch (e) {
          reject(e);
        }
      });
    })
  );
  if (parentPort) parentPort.postMessage("done");
  else process.exit(0);
})();
// cabin.info("tweet schedule jobb");
// console.log("==============================================");</pre>
<p>我知道乍一看可能会让人不知所措。让我们一步一步地分解它，以便更好地理解正在发生的事情。</p>
<p>首先，我们设置了Cabin.js记录器。然后，我们检查工作线程的父端口是否发送了任何消息。如果工作线程的parentPort发送类型为<code>cancel</code>的消息，那么我们将<code>isCancelled</code>设置为true。</p>
<pre>const cabin = new Cabin({
  axe: {
    logger: new Signale(),
  },
});
let isCancelled = false;
if (parentPort) {
  parentPort.once("message", (message) =&gt; {
    if (message === "cancel") isCancelled = true;
  });
}</pre>
<p>下面是我们应用程序的逻辑:</p>
<p><img data-attachment-id="23862" data-permalink="https://blog.logrocket.com/getting-started-with-bree-js/connect-to-mongo-db/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/08/connect-to-mongo-db.png" data-orig-size="730,982" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="connect-to-mongo-db" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/08/connect-to-mongo-db-223x300.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/08/connect-to-mongo-db.png" decoding="async" class="aligncenter size-full wp-image-23862 jetpack-lazy-image" src="../Images/1c168355c128b49bff618a1ffcbfc44a.png" alt="A flowchart showing how to connect to MongoDB." data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2020/08/connect-to-mongo-db.png 730w, https://blog.logrocket.com/wp-content/uploads/2020/08/connect-to-mongo-db-223x300.png 223w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2020/08/connect-to-mongo-db.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/08/connect-to-mongo-db.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="23862" data-permalink="https://blog.logrocket.com/getting-started-with-bree-js/connect-to-mongo-db/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/08/connect-to-mongo-db.png" data-orig-size="730,982" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="connect-to-mongo-db" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/08/connect-to-mongo-db-223x300.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/08/connect-to-mongo-db.png" decoding="async" loading="lazy" class="aligncenter size-full wp-image-23862" src="../Images/1c168355c128b49bff618a1ffcbfc44a.png" alt="A flowchart showing how to connect to MongoDB." srcset="https://blog.logrocket.com/wp-content/uploads/2020/08/connect-to-mongo-db.png 730w, https://blog.logrocket.com/wp-content/uploads/2020/08/connect-to-mongo-db-223x300.png 223w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/08/connect-to-mongo-db.png"/></noscript>
<p>我们需要检查我们是否可以在后台工作中做一些事情。它们包括:</p>
<ul>
<li>从数据库中获取数据，这样我们就可以从数据库中安排推文</li>
<li>在Bree.js作业文件中使用异步/等待</li>
<li>工作完成后更新</li>
</ul>
<p>为了从数据库中访问数据，我们需要在后台作业中单独连接数据库，即使我们在<code>app.js</code>中有连接逻辑:</p>
<pre>mongoose.connect(
   &lt;URL&gt;,
    { useNewUrlParser: true, useCreateIndex: true, useUnifiedTopology: true }
  );</pre>
<p>之后，我们需要在我们的作业中立即调用具有异步功能的函数执行(IIFE)来使用Async/Await。</p>
<pre>(async () =&gt; {
  await mongoose.connect(
    &lt;URL&gt;,
    { useNewUrlParser: true, useCreateIndex: true, useUnifiedTopology: true }
  );
  // Logic comes Here
})();</pre>
<p>然后，我们需要使用这个查询从数据库中找到所有活跃的推文:</p>
<pre>const tweetJobs = await Jobs.find({ isActive: true }).exec();</pre>
<p>一旦我们得到了所有活跃的tweet，我们就遍历它并发送tweet。通过我们的调度程序，我们希望在小于或等于我们当前时间的时间发送这些推文:</p>
<pre>await Promise.all(
    tweetJobs.map(async (tweet) =&gt; {
      return new Promise(async (resolve, reject) =&gt; {
        try {
          if (isCancelled) return;
          const user = await User.findById({ _id: tweet.userId }).exec();
          if (
            moment().tz(tweet.timezone).format("YYYY-MM-DD HH:mm") &lt;
            moment(tweet.scheduledTime, "YYYY-MM-DD HH:mm").format(
              "YYYY-MM-DD HH:mm"
            )
          ) {
            console.log("It it not time yet to post tweet");
            // return;
            resolve();
          } else {
            console.log("==================");
            try {
              await tweetUtils({
                accessToken: user.twitter.accessToken,
                accessSecret: user.twitter.refreshToken,
                tweet: tweet.body,
              });
              await Jobs.findOneAndUpdate(
                { _id: tweet._id },
                { isActive: false }
              );
            } catch (e) {
              cabin.error(e);
            }
            resolve();
          }
        } catch (e) {
          reject(e);
        }
      });
    })
  );</pre>
<p>最后，当我们完成任务时，我们可以向父线程发送一条消息，告诉它任务已经完成。</p>
<pre>if (parentPort) parentPort.postMessage("done");
  else process.exit(0);</pre>
<h2>结论</h2>
<p>最后，您应该使用您认为最容易实现的框架或库，这样您就可以自信地说这个库做得很好。根据这个简单的标准，我觉得Bree.js是最适合使用的库。您可以使用Bree.js实现任意复杂的逻辑。</p>
<p>要深入了解Bree.js，请查看文档<a href="https://jobscheduler.net/#/?id=writing-jobs-with-promises-and-async-await" target="_blank" rel="noopener noreferrer">这里</a>和<a href="https://jobscheduler.net/#/?id=cancellation-retries-stalled-jobs-and-graceful-reloading" target="_blank" rel="noopener noreferrer">这里</a>。</p><div class="code-block code-block-27">
<div class="blog-plug inline-plug vanilla-javascript-cta"><h2>通过理解上下文，更容易地调试JavaScript错误</h2>
<p>调试代码总是一项单调乏味的任务。但是你越了解自己的错误，就越容易改正。</p>
<p>LogRocket 让你以新的独特的方式理解这些错误。我们的前端监控解决方案跟踪用户与您的JavaScript前端的互动，让您能够准确找出导致错误的用户行为。</p>
<a href="https://lp.logrocket.com/blg/javascript-signup" class="signup" target="_blank" rel="noopener noreferrer"><img class="alignnone size-full wp-image-46 jetpack-lazy-image" src="../Images/cbfed9be3defcb505e662574769a7636.png" alt="LogRocket Dashboard Free Trial Banner" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2020/06/reproduce-javascript-errors.gif?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/06/reproduce-javascript-errors.gif"/><noscript><img data-lazy-fallback="1" class="alignnone size-full wp-image-46" src="../Images/cbfed9be3defcb505e662574769a7636.png" alt="LogRocket Dashboard Free Trial Banner" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/06/reproduce-javascript-errors.gif"/></noscript></a>
<p>LogRocket记录控制台日志、页面加载时间、堆栈跟踪、慢速网络请求/响应(带有标题+正文)、浏览器元数据和自定义日志。理解您的JavaScript代码的影响从来没有这么简单过！</p>
<a class="signup" href="https://lp.logrocket.com/blg/javascript-signup" target="_blank" rel="noopener noreferrer">Try it for free</a><p>.</p></div>


</div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
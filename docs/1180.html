<html>
<head>
<title>Diving into the new JSX transform - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>潜入新JSX的转变-日志火箭博客</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/diving-into-the-new-jsx-transform/#0001-01-01">https://blog.logrocket.com/diving-into-the-new-jsx-transform/#0001-01-01</a></blockquote><div><article class="article-post">
<p>有了React 17，您不再需要在文件中导入React来使用React。迷茫？本文将告诉您为了将您的代码和知识迁移到这种新的做事方式，您需要知道什么。</p>
<h2>什么是JSX变换？</h2>
<p><span>如果你曾经写过《反应》，你可能已经注意到了普通JavaScript文件中怪异的HTML语法。这种语法被称为JSX，并且是<em>而不是</em>有效的JavaScript。看样子:</span></p>
<pre>const Welcome = () =&gt; {
  return &lt;h1 className="hero"&gt;Welcome!&lt;/h1&gt;;
};</pre>
<p>为了在浏览器中运行，您需要通过编译器运行您的代码，通常是Babel或TypeScript，它会将您的代码更改为有效的JavaScript。因为，事实证明，JSX只是另一种写法:</p>
<pre>const Welcome = () =&gt; {
  return React.createElement("h1", { className: "hero", children: "Welcome" });
};</pre>
<p>因此，Babel或TypeScript(或任何你选择的工具)将你的代码转换成对函数<code>React.createElement</code>的调用——这就是挑战所在。因为，突然间，你的代码中有了一个“React”的引用！如果没有在文件顶部导入React，JavaScript也不知道如何处理这些编译后的代码。这就是为什么你需要将<code>import React from 'react'</code>添加到所有JSX文件的顶部。</p>
<p>将此添加到所有文件的顶部对于初学者来说是一个巨大的绊脚石，对于专家来说是一个痛苦的负担。有了React 17，您不再需要指定它！</p>
<p>React团队已经与社区合作创建了一个新的转换，它从一个新的定制入口点自动导入一个新的<code>jsx</code>-函数。编译后的代码将如下所示:</p>
<pre>import { jsx as _jsx } from "react/jsx-runtime";

const Welcome = () =&gt; {
  return _jsx("h1", { className: "hero", children: "Welcome" });
};
</pre>
<p>这也有一个潜在的更小的包大小的可爱的副作用！</p>
<h2>我要做什么呢？</h2>
<p>首先，我想重申，这个功能目前只在React 17的发布候选中可用。它也将被移植到旧版本，但如果你想今天就试用，你需要坚持使用版本17。</p>
<p>你需要做什么取决于你用什么来编写你的React应用。</p>
<ul>
<li>如果你正在使用create-react-app，你需要更新到4.0.0版本(目前处于测试阶段)</li>
<li>如果您使用的是Next JS，您需要更新到9.5.3或更高版本</li>
<li>如果你用的是Gatsby JS，需要更新到2.24.5版或以上</li>
</ul>
<p>如果你有自己的Babel配置，你需要多做一些手工步骤。如果您使用的是<code>@babel/preset-react</code>，请将其更新到最新版本。如果你使用的是<code>@babel/plugin-transform-react-jsx</code>，请更新那个。顺便更新一下<code>@babel/core</code>的信息。</p>
<pre>npm update @babel/core @babel/preset-react

# or

npm update @babel/core @babel/plugin-transform-react-jsx
</pre>
<p>接下来，用以下代码片段更新您的Babel配置:</p>
<pre>{
  "presets": [
    [
      "@babel/preset-react",
      {
        "runtime": "automatic"
      }
    ]
  ]
}
</pre>
<p>或者</p>
<pre>{
  "plugins": [
    [
      "@babel/plugin-transform-react-jsx",
      {
        "runtime": "automatic"
      }
    ]
  ]
}
</pre>
<p>你完了！</p>
<h2>删除现有导入</h2>
<p>好了，快好了。因为现在你有大量不再需要的进口商品！我们不能让他们到处游荡，对吧？</p>
<p>实际上，你可以。在可预见的未来，一切都将照常运行。但是让死代码到处游荡只是一件麻烦的事情，如果您有资源删除它们，为什么不呢？</p>
<p>React团队的优秀人员编写了一个自动脚本(所谓的codemod ),为我们完成了这一切，而不是检查您的数百个组件并手动删除它们。🙌你只需要做以下事情:</p>
<pre>npx react-codemod update-react-imports</pre>
<p>这将删除默认React导出(<code>import React from 'react'</code>)的所有导入，并将任何对钩子和其他函数的引用重写为命名导入。这意味着<code>React.useEffect</code>将改为<code>useEffect</code>，并且一个<code>import { useEffect } from 'react'</code>语句将被添加到文件的顶部。</p>
<p>后一部分让我大吃一惊(我总是用前缀来写它们，因为我发现读和写都更容易)，但它为将来创建React的ES模块版本扫清了道路。过一段时间我肯定会习惯的😅</p>
<h2>回报</h2>
<p>有了这个烦人的React导入，React将变得更加容易学习。少了一个需要记住的概念，开箱即用会更好。每当你引导一个新的JSX文件时，少写一行。</p><div class="code-block code-block-17">
<div class="blog-plug inline-plug react-plug" vwo-el-id="26283398190">
<h2 vwo-el-id="41600691720">使用LogRocket消除传统反应错误报告的噪音</h2>
<a href="https://lp.logrocket.com/blg/react-signup-issue-free" target="_blank" vwo-el-id="19356441070">LogRocket
</a><p>是一款React analytics解决方案，可保护您免受数百个误报错误警报的影响，只针对少数真正重要的项目。LogRocket告诉您React应用程序中实际影响用户的最具影响力的bug和UX问题。</p><a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="19356441380">
<img class="first-react-image alignnone size-full wp-image-46 jetpack-lazy-image jetpack-lazy-image--handled" src="../Images/f300c244a1a1cf916df8b4cb02bec6c6.png" vwo-el-id="18272717540" data-lazy-loaded="1" data-original-src="https://files.readme.io/27c94e7-Image_2017-06-05_at_9.46.04_PM.png"/>
</a>
<a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="19356441690">
<img class="second-react-image alignnone size-full wp-image-46 jetpack-lazy-image jetpack-lazy-image--handled" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" vwo-el-id="30720362350" data-lazy-loaded="1" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/>
</a>
<a href="https://lp.logrocket.com/blg/react-signup-issue-free" target="_blank" rel="noopener noreferrer" vwo-el-id="35866400580">LogRocket
</a><p>自动聚合客户端错误、反应错误边界、还原状态、缓慢的组件加载时间、JS异常、前端性能指标和用户交互。然后，LogRocket使用机器学习来通知您影响大多数用户的最具影响力的问题，并提供您修复它所需的上下文。</p><p vwo-el-id="28675661060">关注重要的React bug—<a class="signup" href="https://lp.logrocket.com/blg/react-signup-issue-free" target="_blank" rel="noopener noreferrer" vwo-el-id="40093418840">今天就试试LogRocket】。</a></p>
</div></div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
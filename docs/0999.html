<html>
<head>
<title>Compiled: A CSS-in-JS library without the runtime cost - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>编译:一个CSS-in-JS库，没有运行时成本日志博客</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/compiled-a-css-in-js-library-without-the-runtime-cost/#0001-01-01">https://blog.logrocket.com/compiled-a-css-in-js-library-without-the-runtime-cost/#0001-01-01</a></blockquote><div><article class="article-post">
<p>CSS-in-JS是一个模式和思想的集合，旨在解决开发人员在为他们的应用程序编写CSS时面临的一些最令人烦恼的挑战。它解决了与缩放CSS相关的一些困难，例如使用JavaScript模块系统将CSS代码分成较小的文件，以及通过生成唯一的本地名称来确定CSS样式的范围。</p>
<p>但是CSS-in-JS不是没有代价的。当您使用React等现代UI库时，浏览器会在屏幕上呈现任何内容之前等待JavaScript包文件下载，这会增加加载时间。</p>
<h2 id="theproblemwithcssinjs">CSS-in-JS的问题是</h2>
<p>谷歌创造了<a href="https://web.dev/first-meaningful-paint/" target="_blank" rel="noopener noreferrer">第一个有意义的绘画(FMP) </a>的概念来衡量一个页面的主要内容何时对用户可见。随着React在构建复杂项目的公司和开发人员中获得采用，React应用程序的包大小可以从2MB增长到20MB以上。</p>
<p>为了解决包大小的问题，开发人员已经创建了几种解决方案。例如，你可以把这个包分成几个部分，或者延迟加载应用程序(例如，首先加载最重要的部分)。</p>
<p>CSS-in-JS 模式在现代UI库中也有类似的问题。CSS过去是静态编写的，所以浏览器只需要读取代码。使用CSS-in-JS，浏览器需要动态生成和更新<code>&lt;style&gt;</code>标签来响应状态和属性的变化。</p>
<p>开发人员在JavaScipt文件中编写CSS的美妙体验是以运行时生成CSS为代价的。</p>
<h2 id="compiledsolvethisproblem">编译到救援</h2>
<p><a href="https://compiledcssinjs.com/" target="_blank" rel="noopener noreferrer"> Compiled </a>是一个CSS-in-JS库，由Atlassian Labs创建，旨在提供无运行时成本的优秀开发人员体验。它的工作方式是在构建时静态分析您的代码，将其转换为编译后的组件，然后在运行时将样式代码移动到文档的头部。</p>
<p>Compiled反映了在<a href="https://blog.logrocket.com/8-reasons-to-use-styled-components-cf3788f0bb4d/" target="_blank" rel="noopener noreferrer"> styled-components </a>和Emotion中发现的样式模式，所以如果您使用过其中的任何一个，您都会感觉很舒服。</p>
<p>下面是一个简单的例子。</p>
<pre>import { styled } from '@compiled/css-in-js';

export const ColoredText = styled.span`
  color: #ff5630;
`;
</pre>
<p>上面的内容将被转换成下面的编译组件。</p>
<pre>import React from 'react';
import { CC, CS } from '@compiled/css-in-js';
export const ColoredText = /*#__PURE__*/ React.forwardRef(
  ({ as: C = 'span', ...props }, ref) =&gt; (
    &lt;CC&gt;
      &lt;CS hash="zd46j1"&gt;{['.cc-zd46j1{color:#ff5630}']}&lt;/CS&gt;
      &lt;C
        {...props}
        ref={ref}
        className={'cc-zd46j1' + (props.className ? ' ' + props.className : '')}
      /&gt;
    &lt;/CC&gt;
  )
);
if (process.env.NODE_ENV === 'development') {
  ColoredText.displayName = 'ColoredText';
}
</pre>
<p>就像普通的CSS-in-JS一样，组件将拥有一个惟一的hash作为类，支持本地作用域。</p>
<p>这种转换使您能够在没有任何配置、设置或工具的情况下使用组件。只需导入组件并使用它。</p>
<pre>const EmphasisText = (props) =&gt; {
  const color = props.massive ? '#00B8D9' : '#36B37E';
  return (
    &lt;span
      css={{
        color,
        textTransform: 'uppercase',
        fontWeight: 600,
      }}&gt;
      {props.children}
    &lt;/span&gt;
  );
};
export default EmphasisText

//... import from other component

import EmphasisText from './EmphasisText';
const WelcomeComponent = () =&gt; {
    return (
        &lt;EmphasisText massive&gt;
            Welcome to Jumanji!
        &lt;/EmphasisText&gt;
    );
}
</pre>
<p>这是完全相同的CSS-in-JS模式，但是没有在运行时生成CSS。这个约束解决了由动态CSS生成引起的性能问题。</p>
<h2 id="gettingstartedwithcompiled">使用带React的编译</h2>
<p>要使用React编译，您需要安装软件包和编译器。</p>
<p>要安装软件包，请执行以下操作:</p>
<pre>npm i @compiled/css-in-js
</pre>
<p>接下来，安装编译器。您可以将Babel或TypeScript编译器与Compiled一起使用。如果您使用Create React App，您需要从包中弹出(您需要编辑配置文件来设置两个编译器)。</p>
<p>要安装Babel插件:</p>
<pre>npm install @compiled/babel-plugin-css-in-js
</pre>
<p>确保插件是数组中的第一个条目。</p>
<pre>{
  "plugins": ["@compiled/babel-plugin-css-in-js"]
}
</pre>
<p>对于TypeScript:</p>
<pre>npm install @compiled/ts-transform-css-in-js ttypescript
</pre>
<p>将插件放在您的<code>tsconfig.json</code>文件中。</p>
<pre>{
  "compilerOptions": {
    "plugins": [{ "transform": "@compiled/ts-transform-css-in-js" }]
  }
}
</pre>
<p>接下来，让编译器使用<code><a href="https://github.com/cevek/ttypescript">ttypescript</a></code>库从您的配置中选择插件。</p>
<pre>npm i ttypescript -D
</pre>
<p>要编译文件，请使用<code>ttsc</code>命令，而不是<code>tsc</code>。</p>
<p>或者，在webpack内部使用它。</p>
<pre>{
  loader: require.resolve('ts-loader'),
  options: {
    compiler: 'ttypescript',
  },
},
</pre>
<p>你也可以用包裹。</p>
<pre>npm i parcel-plugin-ttypescript
</pre>
<p>只需通过从Compiled的主库导入来编写CSS-in-JS文件。</p><div class="code-block code-block-54">
<hr/>
<h3>更多来自LogRocket的精彩文章:</h3>

<hr/></div>
<pre>import React from 'react';
import '@compiled/css-in-js';

const EmphasisText = (props) =&gt; {
  const color = props.massive ? '#00B8D9' : '#36B37E';
  return (
    &lt;span
      css={{
        color,
        textTransform: 'uppercase',
        fontWeight: 600,
      }}&gt;
      {props.children}
    &lt;/span&gt;
  );
};

export default EmphasisText
</pre>
<p>接下来，导入组件。</p>
<pre>import React from "react";
import ReactDOM from "react-dom";
import EmphasisText from './EmphasisText';

const WelcomeComponent = () =&gt; {
    return (
        &lt;EmphasisText massive&gt;
            Welcome to Jumanji!
        &lt;/EmphasisText&gt;
    );
}

ReactDOM.render(&lt;WelcomeComponent /&gt;, document.getElementById("root"));
</pre>
<h2 id="conclusion">结论</h2>
<p>CSS-in-JS模式解决了与缩放CSS相关的最大问题之一。通过使用带有局部作用域的模块化方法，CSS现在更易于维护，更不可预测。然而，它也带来了一些折衷，导致了与其动态渲染相关的性能问题。</p>
<p>Compiled是一个CSS-in-JS库，它在构建时分析您的代码，并将其转换为已编译的组件，以确保在运行时不会生成CSS代码。这样，您可以享受编写CSS-in-JS的出色开发体验，而不会牺牲性能。</p>
<p><a href="https://compiledcssinjs.com/docs/" target="_blank" rel="noopener noreferrer">编译文档</a>有额外的指南，用于从样式化组件或情感和<a href="https://compiledcssinjs.com/docs/testing" target="_blank" rel="noopener noreferrer">测试编译组件</a>的<a href="https://compiledcssinjs.com/docs/migrating">迁移。你甚至可以用编译过的</a>做<a href="https://compiledcssinjs.com/docs/server-side-rendering" target="_blank" rel="noopener noreferrer">服务器端渲染。</a></p>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
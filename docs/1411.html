<html>
<head>
<title>Using Next.js with TypeScript - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>将Next.js与TypeScript - LogRocket Blog一起使用</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/using-next-js-with-typescript/#0001-01-01">https://blog.logrocket.com/using-next-js-with-typescript/#0001-01-01</a></blockquote><div><article class="article-post">
<p>编者按:这篇文章于2021年11月15日更新，以更新过时的信息，并提供关于打字稿类型的更多澄清。</p>
<p>Next.js允许您使用React构建静态和动态(服务器端)应用程序。它附带了方便的功能，例如:</p>
<ul>
<li>API路线</li>
<li>文件系统路由</li>
<li>图像优化</li>
<li>中间件</li>
<li>ES模块支持和URL导入</li>
<li>服务器组件</li>
<li>HTTP流</li>
<li>Next.js Live</li>
</ul>
<p><a href="https://nextjs.org/"> Next.js </a>是用<a href="https://www.typescriptlang.org/">类型脚本</a>构建的，所以默认情况下，只需JavaScript就能在编辑器中获得更好的智能感知和类型定义。但是当您将它与TypeScript结合使用时，您可以获得更好的开发人员体验——包括当您的组件需要道具，但是您没有通过任何道具时的即时反馈。</p>
<p>您还可以使用Next的导出类型进行构建，并定义您自己的类型来构建您的应用程序。这些<a href="https://blog.logrocket.com/type-flowing-rethinking-typescript-typing-system/">类型通过指定你的对象、数组等等，帮助你的代码有更好的结构</a>。，看起来像是提前了。这样，您、您的代码编辑器以及您之后的任何开发人员都知道如何引用您的代码。</p>
<p>Next的功能使构建全栈React应用比以往任何时候都更容易，从<a href="https://nextjs.org/docs/basic-features/pages">简化路由</a>到性能增强功能，如<a href="https://nextjs.org/docs/basic-features/image-optimization">图像优化</a>。</p>
<p>在本教程中，我们将演示如何使用Next.js和TypeScript，并向您介绍一个令人兴奋的现代堆栈，用于构建高质量、搜索优化和可预测的应用程序。我们将详细介绍以下内容:</p>

<p>为了展示Next.js和TypeScript的实际应用，我们将介绍如何构建一个简单的文章管理器应用程序。我们的示例应用程序将从<a href="https://jsonplaceholder.typicode.com/"> JSON占位符</a>中检索数据。</p>
<h2 id="whatisnextjs">Next.js是什么？</h2>
<p>Next.js是一个构建在React和Node.js之上的生产就绪框架。它提供了上面列出的所有功能以及更多的功能。</p>
<p>您可以使用Next.js构建静态和动态应用程序，因为它支持客户端和服务器端呈现。Next.js 9引入了<a href="https://nextjs.org/docs/api-routes/introduction"> API routes </a>，允许你用Node.js、Express.js、GraphQL等构建的真正的后端(无服务器)来扩展你的下一个应用。在撰写本文时，最新的版本是<a href="https://blog.logrocket.com/whats-new-next-js-12/"> Next.js 12 </a>，它有一个新的、更快的Rust编译器。</p>
<p>Next.js使用<a href="https://blog.logrocket.com/understanding-lazy-loading-in-javascript/">自动代码分割(延迟加载)</a>来只呈现你的应用程序需要的JavaScript。Next.js还可以在构建时预渲染页面以按需提供服务，这可以让你的应用程序感觉很快，因为浏览器不必花时间执行JavaScript捆绑包来为你的应用程序生成HTML，这使得更多的搜索引擎爬虫可以索引你的应用程序，这反过来对SEO很好。</p>
<h2 id="whatistypescript">什么是TypeScript？</h2>
<p>TypeScript是一种由微软创建和维护的流行语言。它是JavaScript的超集，这意味着所有有效的JavaScript都是有效的Typescript。</p>
<p>你可以<a href="https://blog.logrocket.com/a-simple-guide-for-migrating-from-javascript-to-typescript/">将你现有的JavaScript应用程序转换成TypeScript </a>，只要你的代码是有效的JavaScript，它就会像预期的那样工作。TypeScript允许您在变量和函数上设置类型，这样您就可以静态地对代码进行类型检查，并在编译时捕捉错误。</p>
<p>您还可以使用JavaScript尚不支持的现代特性。不要担心浏览器支持——TypeScript编译成普通JavaScript，这意味着您的TypeScript代码永远不会出现在浏览器中。</p>
<h2 id="usingtypescriptinanextjsapp">在Next.js应用程序中使用TypeScript</h2>
<p>要创建新的Next.js应用程序，可以使用创建下一个应用程序。</p>
<p>首先，打开命令行界面(CLI)并运行以下命令:</p>
<pre><code>npx create-next-app next-typescript-example
</code></pre>
<p>该命令将生成一个全新的Next.js应用程序。现在，让我们按如下方式构建项目:</p>
<pre><code>src
├── components
|  ├── AddPost.tsx
|  └── Post.tsx
├── pages
|  ├── index.tsx
|  └── _app.tsx
├── styles
|  └── index.css
├── tsconfig.json
├── types
|  └── index.ts
├── next-env.d.ts
└── package.json
</code></pre>
<p>要在Next.js应用程序中启用TypeScript，请在项目的根目录中添加一个<code>tsconfig.json</code>文件。Next.js将识别该文件并为项目使用TypeScript。</p>
<p>有了这些，我们现在可以创建扩展名为<code>.ts</code>或<code>.tsx</code>的文件。Next.js处理将TypeScript代码编译成JavaScript，然后像往常一样在浏览器中为我们的应用程序提供服务。</p>
<h2 id="creating-typescript-types-next-js">在Next.js中创建TypeScript类型</h2>
<p>您可以为应用程序中的任何内容创建类型，包括属性类型、API响应、实用函数的参数，甚至全局状态的属性！</p>
<p>我们首先为我们的帖子创建一个类型。下面的界面反映了一个<code>Post</code>物体的形状。它需要<code>id</code>、<code>title</code>和<code>body</code>属性。</p>
<pre class="language-typescript hljs">// types/index.ts

export interface IPost {
  id: number
  title: string
  body: string
}
</pre>
<h2 id="creating-components-next-js">在Next.js中创建组件</h2>
<p>既然post类型(<code>IPost</code>)已经可以使用了，让我们创建React组件并设置类型。</p>
<pre class="language-typescript hljs">// components/AddPost.tsx

import * as React from 'react'
import { IPost } from '../types'

type Props = {
  savePost: (e: React.FormEvent, formData: IPost) =&gt; void
}

const AddPost: React.FC&lt;Props&gt; = ({ savePost }) =&gt; {
  const [formData, setFormData] = React.useState&lt;IPost&gt;()

  const handleForm = (e: React.FormEvent&lt;HTMLInputElement&gt;): void =&gt; {
    setFormData({
      ...formData,
      [e.currentTarget.id]: e.currentTarget.value,
    })
  }

  return (
    &lt;form className='Form' onSubmit={(e) =&gt; savePost(e, formData)}&gt;
      &lt;div&gt;
        &lt;div className='Form--field'&gt;
          &lt;label htmlFor='name'&gt;Title&lt;/label&gt;
          &lt;input onChange={handleForm} type='text' id='title' /&gt;
        &lt;/div&gt;
        &lt;div className='Form--field'&gt;
          &lt;label htmlFor='body'&gt;Description&lt;/label&gt;
          &lt;input onChange={handleForm} type='text' id='body' /&gt;
        &lt;/div&gt;
      &lt;/div&gt;
      &lt;button
        className='Form__button'
        disabled={formData === undefined ? true : false}
      &gt;
        Add Post
      &lt;/button&gt;
    &lt;/form&gt;
  )
}

export default AddPost
</pre>
<p>如您所见，我们从导入<code>IPost</code>类型开始。之后，我们创建另一个名为<code>Props</code>的类型，它镜像组件作为参数接收的属性。</p>
<p>接下来，我们在<a href="https://blog.logrocket.com/a-guide-to-usestate-in-react-ecb9952e406c/" target="_blank" rel="noopener">钩子</a>上设置类型<code>IPost</code>。然后，我们用它来处理表单数据。一旦表单被提交，我们就依靠函数<code>savePost</code>将数据保存在数组<code>posts</code>中。<br/>现在，我们可以创建并保存一个新帖子。</p>
<p>让我们继续关注负责显示<code>Post</code>对象的组件。</p>
<pre class="language-typescript hljs">// components/Post.tsx

import * as React from 'react'
import { IPost } from '../types'

type Props = {
  post: IPost
  deletePost: (id: number) =&gt; void
}

const Post: React.FC&lt;Props&gt; = ({ post, deletePost }) =&gt; {
  return (
    &lt;div className='Card'&gt;
      &lt;div className='Card--body'&gt;
        &lt;h1 className='Card--body-title'&gt;{post.title}&lt;/h1&gt;
        &lt;p className='Card--body-text'&gt;{post.body}&lt;/p&gt;
      &lt;/div&gt;
      &lt;button className='Card__button' onClick={() =&gt; deletePost(post.id)}&gt;
        Delete
      &lt;/button&gt;
    &lt;/div&gt;
  )
}

export default Post
</pre>
<p>这个<code>Post</code>组件接收要显示的<code>post</code>对象和作为道具的<code>deletePost</code>函数。参数必须匹配<code>Props</code>才能让TypeScript满意。</p>
<p>我们现在能够添加、显示和删除帖子。让我们将组件导入到<code>App.tsx</code>文件中，并创建处理帖子的逻辑。</p>
<pre class="language-typescript hljs">import * as React from 'react'
import { InferGetStaticPropsType } from 'next'
import AddPost from '../components/AddPost'
import Post from '../components/Post'
import { IPost } from '../types'

const API_URL: string = 'https://jsonplaceholder.typicode.com/posts'

export default function IndexPage({
  posts,
}: InferGetStaticPropsType&lt;typeof getStaticProps&gt;) {
  const [postList, setPostList] = React.useState(posts)

  const addPost = async (e: React.FormEvent, formData: IPost) =&gt; {
    e.preventDefault()
    const post: IPost = {
      id: Math.random(),
      title: formData.title,
      body: formData.body,
    }
    setPostList([post, ...postList])
  }

  const deletePost = async (id: number) =&gt; {
    const posts: IPost[] = postList.filter((post: IPost) =&gt; post.id !== id)
    console.log(posts)
    setPostList(posts)
  }

  if (!postList) return &lt;h1&gt;Loading...&lt;/h1&gt;

  return (
    &lt;main className='container'&gt;
      &lt;h1&gt;My posts&lt;/h1&gt;
      &lt;AddPost savePost={addPost} /&gt;
      {postList.map((post: IPost) =&gt; (
        &lt;Post key={post.id} deletePost={deletePost} post={post} /&gt;
      ))}
    &lt;/main&gt;
  )
}

export async function getStaticProps() {
  const res = await fetch(API_URL)
  const posts: IPost[] = await res.json()

  return {
    props: {
      posts,
    },
  }
}
</pre>
<p>在这个组件中，我们首先导入前面创建的类型和组件。Next.js提供的类型<code>InferGetStaticPropsType</code>允许我们在方法<code>getStaticProps</code>上设置类型。它会推断出<code>getStaticProps</code>返回的道具上定义的类型。</p>
<p>之后，我们使用<code>useState</code>钩子用<code>posts</code>数组初始化状态。接下来，我们声明函数<code>addPost</code>来保存posts数组中的数据。<code>deletePost</code>方法接收帖子的<code>id</code>作为参数，这允许我们过滤数组并删除帖子。</p>
<p>最后，我们将预期的道具传递给组件。然后，我们遍历响应数据，并使用<code>Todo</code>组件显示它。借助Next.js提供的<code>getStaticProps</code>方法，从JSON占位符API中检索数据。</p>
<p>将<code>posts</code>的类型设置为具有由<code>IPost</code>定义的结构的对象数组，有助于我们和我们的编辑器确切地知道从API的响应中哪些字段对我们可用。</p>
<p>您也可以使用<a href="https://nextjs.org/docs/basic-features/data-fetching#getserversideprops-server-side-rendering" target="_blank" rel="noopener"> <code>getServerSideProps</code>方法</a>、Fetch或者一个库来获取数据。只是你想怎么渲染你的Next.js应用的问题。</p>
<p>在这个演示中，我们通过<a href="https://nextjs.org/docs/basic-features/pages#static-generation-recommended" target="_blank" rel="noopener">静态生成</a>页面来呈现我们的应用程序，这意味着Next.js在构建时使用少量JavaScript生成HTML文件，并且相同的HTML文件服务于每个请求。静态生成页面是推荐的应用程序服务方式，因为提供预先生成的HTML文件可以提高性能。</p>
<p><a href="https://nextjs.org/docs/basic-features/pages#server-side-rendering" target="_blank" rel="noopener">服务器端渲染</a>也是一个选项，这个方法在每次向服务器发出请求时生成一个新的HTML文件。这是您将使用<code>getServerSideProps</code>的模式。</p>
<h2 id="testing-your-next-js-app">测试Next.js应用程序</h2>
<p>完成最后一步后，应用程序就可以在浏览器上进行测试了。首先找到项目的根目录并运行以下命令:</p>
<pre class="language-bash hljs">yarn dev
</pre>
<p>或者，如果使用<code>npm</code>:</p>
<pre class="language-bash hljs">npm run dev
</pre>
<p>如果一切正常，您应该会在<code><a href="http://localhost:3000/" rel="nofollow">http://localhost:3000/</a></code>看到下一个应用程序:</p>
<p><img data-attachment-id="80682" data-permalink="https://blog.logrocket.com/using-next-js-with-typescript/next-js-app-preview/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/12/next-js-app-preview.png" data-orig-size="730,497" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="next-js-app-preview" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/12/next-js-app-preview-300x204.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/12/next-js-app-preview.png" decoding="async" class="aligncenter size-full wp-image-80682 jetpack-lazy-image" src="../Images/33a9c220f2afce6f01d5ef90d24c3fe1.png" alt="A preview of our Next.js app" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2020/12/next-js-app-preview.png 730w, https://blog.logrocket.com/wp-content/uploads/2020/12/next-js-app-preview-300x204.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2020/12/next-js-app-preview.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/12/next-js-app-preview.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="80682" data-permalink="https://blog.logrocket.com/using-next-js-with-typescript/next-js-app-preview/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/12/next-js-app-preview.png" data-orig-size="730,497" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="next-js-app-preview" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/12/next-js-app-preview-300x204.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/12/next-js-app-preview.png" decoding="async" loading="lazy" class="aligncenter size-full wp-image-80682" src="../Images/33a9c220f2afce6f01d5ef90d24c3fe1.png" alt="A preview of our Next.js app" srcset="https://blog.logrocket.com/wp-content/uploads/2020/12/next-js-app-preview.png 730w, https://blog.logrocket.com/wp-content/uploads/2020/12/next-js-app-preview-300x204.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/12/next-js-app-preview.png"/></noscript><br/>
And that’s it!
<h2>结论</h2>
<p>在本教程中，我们介绍了如何通过构建一个文章管理器应用程序来使用TypeScript和Next.js。你可以<a href="https://github.com/ibrahima92/next-typescript-example" target="_blank" rel="noopener">在GitHub上查看完成的项目</a>。</p>
<p>Next.js对TypeScript有很好的支持，并且很容易设置。这使得使用Next.js和TypeScript构建强类型React应用程序变得简单，这些应用程序可以在客户端或服务器上运行。坦率地说，Next.js和TypeScript是一个非常令人兴奋的堆栈，可以在您的下一个React项目中尝试。</p><div class="code-block code-block-21">
<div class="blog-plug inline-plug typescript-plug"><h2><a class="signup" href="https://lp.logrocket.com/blg/typescript-signup" target="_blank" rel="noopener noreferrer"> LogRocket </a>:全面了解您的网络和移动应用</h2>
<a href="https://lp.logrocket.com/blg/typescript-signup" class="signup" target="_blank" rel="noopener noreferrer"><img class="alignnone size-full wp-image-46 jetpack-lazy-image" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/><noscript><img data-lazy-fallback="1" class="alignnone size-full wp-image-46" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/></noscript></a>
<p>LogRocket 是一个前端应用程序监控解决方案，可以让您回放问题，就像问题发生在您自己的浏览器中一样。LogRocket不需要猜测错误发生的原因，也不需要向用户询问截图和日志转储，而是让您重放会话以快速了解哪里出错了。它可以与任何应用程序完美配合，不管是什么框架，并且有插件可以记录来自Redux、Vuex和@ngrx/store的额外上下文。</p>
<p>除了记录Redux操作和状态，LogRocket还记录控制台日志、JavaScript错误、堆栈跟踪、带有头+正文的网络请求/响应、浏览器元数据和自定义日志。它还使用DOM来记录页面上的HTML和CSS，甚至为最复杂的单页面和移动应用程序重新创建像素级完美视频。</p><div class="code-block code-block-30">
<div class="blog-plug inline-plug next-plug"><h2><a href="https://lp.logrocket.com/blg/nextjs-signup" target="_blank"> LogRocket </a>:全面了解生产Next.js应用</h2><p>调试下一个应用程序可能会很困难，尤其是当用户遇到难以重现的问题时。如果您对监视和跟踪状态、自动显示JavaScript错误、跟踪缓慢的网络请求和组件加载时间感兴趣，</p><a href="https://lp.logrocket.com/blg/nextjs-signup" target="_blank">try LogRocket</a><p>. </p><a class="signup" href="https://lp.logrocket.com/blg/nextjs-signup" target="_blank" rel="noopener noreferrer"><img class="alignnone size-full wp-image-46 jetpack-lazy-image" src="../Images/f300c244a1a1cf916df8b4cb02bec6c6.png" data-lazy-src="https://files.readme.io/27c94e7-Image_2017-06-05_at_9.46.04_PM.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://files.readme.io/27c94e7-Image_2017-06-05_at_9.46.04_PM.png"/><noscript><img data-lazy-fallback="1" class="alignnone size-full wp-image-46" src="../Images/f300c244a1a1cf916df8b4cb02bec6c6.png" data-original-src="https://files.readme.io/27c94e7-Image_2017-06-05_at_9.46.04_PM.png"/></noscript></a><a class="signup" href="https://lp.logrocket.com/blg/nextjs-signup" target="_blank" rel="noopener noreferrer"><img class="alignnone size-full wp-image-46 jetpack-lazy-image" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/><noscript><img data-lazy-fallback="1" class="alignnone size-full wp-image-46" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/></noscript></a><p>LogRocket 就像是网络和移动应用的DVR，记录下你的Next.js应用上发生的一切。您可以汇总并报告问题发生时应用程序的状态，而不是猜测问题发生的原因。LogRocket还可以监控应用程序的性能，报告客户端CPU负载、客户端内存使用等指标。</p><p>LogRocket Redux中间件包为您的用户会话增加了一层额外的可见性。LogRocket记录Redux存储中的所有操作和状态。</p><p>让您调试Next.js应用的方式现代化— <a class="signup" href="https://lp.logrocket.com/blg/nextjs-signup" target="_blank" rel="noopener noreferrer">开始免费监控</a>。</p></div></div>
<a class="signup" href="https://lp.logrocket.com/blg/typescript-signup" target="_blank" rel="noopener noreferrer">Try it for free</a><p>.</p></div>
</div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
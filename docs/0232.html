<html>
<head>
<title>Using Google Closure Compiler to deliver better JavaScript - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>使用Google Closure编译器交付更好的JavaScript - LogRocket博客</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/using-google-closure-compiler-to-deliver-better-javascript-3059a8343445/#0001-01-01">https://blog.logrocket.com/using-google-closure-compiler-to-deliver-better-javascript-3059a8343445/#0001-01-01</a></blockquote><div><article class="article-post">
<p class="graf graf--p">代码审查是通过(理论上)严格的阅读和严格的同行审查其内容的过程来分析代码的过程。在提交代码供评审之前，程序员通常会根据他们使用的语言和环境，使用一些自动化工具中的一种来清理代码。</p>
<p class="graf graf--p">在JavaScript世界中，仅仅因为语言的本质，许多开发人员，尤其是初学者，看不到他们在编程时犯的错误。这些可能是任何事情，从使用未声明的变量，到由于不一致的空检查导致的空指针异常，到误用(或者根本没有使用)函数返回的内容。这就是为什么在提交代码供审查之前，自动化的其他东西可以帮助我们。</p>
<p class="graf graf--p">Google Closure Compiler 正是这么做的:它通过分析、解析、缩小和重写JavaScript，从JavaScript编译成更好的JavaScript。当然，它也警告我们上面提到的同样的陷阱。它删除不必要的内容，检查语法——简而言之，它做了很多。</p>
<p class="graf graf--p">在本文中，我们将展示前端开发人员面临的一些常见问题，并更好地理解Closure Compiler如何帮助我们快速地复查我们正在编写的内容，以确保我们交付尽可能最好的代码。</p>
<h3 class="graf graf--h3">简单的快速入门</h3>
<p class="graf graf--p">您可以从命令行执行Closure Compiler到您的应用程序中(例如Node.js)或者通过<a class="markup--anchor markup--p-anchor" href="https://closure-compiler.appspot.com/home" target="_blank" rel="noopener noreferrer" data-href="https://closure-compiler.appspot.com/home">免费提供的web服务</a>。</p>
<figure class="graf graf--figure"><img data-attachment-id="1792" data-permalink="https://blog.logrocket.com/using-google-closure-compiler-to-deliver-better-javascript-3059a8343445/attachment/1_yp6mybfegyjhr5wfbxd8gw/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2019/03/1_Yp6MYbFEGYjhR5WFBXd8Gw.gif" data-orig-size="1232,472" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="1_Yp6MYbFEGYjhR5WFBXd8Gw" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2019/03/1_Yp6MYbFEGYjhR5WFBXd8Gw-300x115.gif" data-large-file="https://blog.logrocket.com/wp-content/uploads/2019/03/1_Yp6MYbFEGYjhR5WFBXd8Gw-1024x392.gif" decoding="async" class="alignnone size-full wp-image-1792 jetpack-lazy-image" src="../Images/8df142a73bf0e20640ff426bb91dfe25.png" alt="" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2019/03/1_Yp6MYbFEGYjhR5WFBXd8Gw.gif?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/03/1_Yp6MYbFEGYjhR5WFBXd8Gw.gif"/><noscript><img data-lazy-fallback="1" data-attachment-id="1792" data-permalink="https://blog.logrocket.com/using-google-closure-compiler-to-deliver-better-javascript-3059a8343445/attachment/1_yp6mybfegyjhr5wfbxd8gw/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2019/03/1_Yp6MYbFEGYjhR5WFBXd8Gw.gif" data-orig-size="1232,472" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="1_Yp6MYbFEGYjhR5WFBXd8Gw" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2019/03/1_Yp6MYbFEGYjhR5WFBXd8Gw-300x115.gif" data-large-file="https://blog.logrocket.com/wp-content/uploads/2019/03/1_Yp6MYbFEGYjhR5WFBXd8Gw-1024x392.gif" decoding="async" loading="lazy" class="alignnone size-full wp-image-1792" src="../Images/8df142a73bf0e20640ff426bb91dfe25.png" alt="" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/03/1_Yp6MYbFEGYjhR5WFBXd8Gw.gif"/></noscript></figure>
<p class="graf graf--p">它基本上公开了一个网页，您可以通过链接的JavaScript文件或内联代码粘贴来编译您的代码。然后，该工具会在屏幕右侧显示结果。</p>
<p class="graf graf--p">这些结果依次显示了原始源代码和编译版本(gzipped和uncompressed)之间的大小差异，以及一个自动生成的链接，供您下载JavaScript文件。</p>
<p class="graf graf--p">最重要的是，您将看到一个包含四个选项卡的表格，显示:</p>
<ul class="postList">
<li class="graf graf--li">最终编译的代码</li>
<li class="graf graf--li">警告和错误的列表，说明它们发生的时间、行、错误/警告类型以及对错误的描述</li>
<li class="graf graf--li">用于向闭包编译器web服务发出REST请求的POST数据</li>
</ul>
<p class="graf graf--p">关于优化，你可以从<em class="markup--em markup--p-em">简单</em>和<em class="markup--em markup--p-em">高级</em>选项中选择(我们不会只考虑<em class="markup--em markup--p-em">空白</em>，因为它做不了多少)。</p>
<p class="graf graf--p">简单的T1将转换并缩小你的JS代码，同时警告语法和我们经常犯的最危险的错误。<em class="markup--em markup--p-em">简单</em>模式，顾名思义，简单——而且，大多数时候，安全。</p>
<p class="graf graf--p">另一方面，Advanced 在删除代码、重组原始实现的整个结构方面要积极得多。</p>
<p class="graf graf--p">以Closure web服务页面上默认的“hello，world”示例的前一幅图像为例:它缩减了代码并使其更简单，但是它失去了<code>hello()</code>函数，这意味着对它的外部引用会中断。但是不用担心；我们将探讨如何解决这个问题。</p>
<p class="graf graf--p">让我们举另一个稍微复杂一点的例子，这个例子摘自<a class="markup--anchor markup--p-anchor" href="https://developers.google.com/closure/compiler/samples/tutorial2.js" target="_blank" rel="noopener noreferrer" data-href="https://developers.google.com/closure/compiler/samples/tutorial2.js">官方谷歌教程</a>:</p>
<pre><code>// Copyright 2009 Google Inc. All Rights Reserved.

/**
 * Creates the DOM structure for the note and adds it to the document.
 */
function makeNoteDom(noteTitle, noteContent, noteContainer) {
  // Create DOM structure to represent the note.
  var headerElement = document.createElement('div');
  var headerText = document.createTextNode(noteTitle);
  headerElement.appendChild(headerText);
  
  var contentElement = document.createElement('div');
  var contentText = document.createTextNode(noteContent);
  contentElement.appendChild(contentText);

  var newNote = document.createElement('div');
  newNote.appendChild(headerElement);
  newNote.appendChild(contentElement);

  // Add the note's DOM structure to the document.
  noteContainer.appendChild(newNote);
}

/**
 * Iterates over a list of note data objects and creates a DOM
 */
function makeNotes(data, noteContainer) {
  for (var i = 0; i &lt; data.length; i++) {
    makeNoteDom(data[i].title, data[i].content, noteContainer);
  }
}

function main() {
  var noteData = [
      {title: 'Note 1', content: 'Content of Note 1'},
      {title: 'Note 2', content: 'Content of Note 2'}];
  var noteListElement = document.getElementById('notes');
  makeNotes(noteData, noteListElement);
}

main();</code></pre>
<p class="graf graf--p">这里，我们基本上创建了一个notes的数据结构，每个notes都有一个标题和内容的字符串属性。其余的由实用函数组成，用于迭代注释列表，并通过各自的<code>create</code>函数将它们全部放入文档。相同的代码在被Closure编译器编译后会是这样的:</p>
<pre class="graf graf--pre">for (var a = [{title:"Note 1", content:"Content of Note 1"}, {title:"Note 2", content:"Content of Note 2"}], b = document.getElementById("notes"), c = 0; c &lt; a.length; c++) { var d = a[c].content, e = b, f = document.createElement("div"); f.appendChild(document.createTextNode(a[c].title)); var g = document.createElement("div"); g.appendChild(document.createTextNode(d)); var h = document.createElement("div"); h.appendChild(f); h.appendChild(g); e.appendChild(h); } ;</pre>
<p class="graf graf--p">注意，整个<code>noteData</code>变量列表被改变为一个内联对象声明，它出现在循环内部。这些变量从它们原来的名字重新命名为字母字符。而且不能在其他地方重用之前的函数；如果从其他地方调用这个列表，闭包编译器可能会粘贴它两次。</p>
<p class="graf graf--p">然而代码的可读性和可理解性并不好——这当然不能用于开发环境。</p>
<figure class="graf graf--figure graf--layoutOutsetCenter"><a class="graf-imageAnchor" href="https://logrocket.com/signup/" target="_blank" rel="noopener noreferrer" data-href="https://logrocket.com/signup/" data-action="image-link" data-action-observe-only="true"><img decoding="async" class="graf-image jetpack-lazy-image" src="../Images/acc3369b8434437774121b537bc47a70.png" data-image-id="1*wV7zU6J05BL3bphzMlB2rA.png" data-width="2400" data-height="560" data-lazy-src="https://storage.googleapis.com/blog-images-backup/1*wV7zU6J05BL3bphzMlB2rA.png?zoom=2&amp;resize=730%2C170&amp;ssl=1&amp;is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://storage.googleapis.com/blog-images-backup/1*wV7zU6J05BL3bphzMlB2rA.png?zoom=2&amp;resize=730%2C170&amp;ssl=1"/><noscript><img data-lazy-fallback="1" decoding="async" class="graf-image" src="../Images/acc3369b8434437774121b537bc47a70.png" data-image-id="1*wV7zU6J05BL3bphzMlB2rA.png" data-width="2400" data-height="560" data-original-src="https://storage.googleapis.com/blog-images-backup/1*wV7zU6J05BL3bphzMlB2rA.png?zoom=2&amp;resize=730%2C170&amp;ssl=1"/></noscript></a></figure>
<h3 class="graf graf--h3">未使用的变量</h3>
<p class="graf graf--p">Closure Compiler可以驱动很多场景——也就是我们作为JavaScript开发人员日常生活中常见的问题。让我们举一个JavaScript代码的例子:</p>
<pre class="graf graf--pre"><code>'use strict';
const helperModule = require('./helper.js');
var notUsed;</code></pre>
<p class="graf graf--p">当我们使用<code>'use strict'</code>模式时，生成的输出代码会怎样？或者是一个未使用的变量，即使您后来为它设置了一个值？</p>
<p class="graf graf--p">创建许多结构(不仅是变量，还有常量、函数、类等等)是很常见的。)被删除，这很容易被遗忘——如果您处理大量的源代码文件，就更是如此。根据模型的复杂程度，或者将对象暴露给外部世界的方式，这可能会导致不必要的情况。</p>
<p class="graf graf--p">嗯，结果就是这样:</p>
<pre class="graf graf--pre">var a = require(“./helper.js”);</pre>
<p class="graf graf--p">闭包编译器会自动识别并移除那些未使用的结构。另外，局部变量(<code>let</code>)和常量(<code>const</code>)被替换为<code>var</code>声明。</p>
<h3 class="graf graf--h3">条件流</h3>
<p class="graf graf--p">如果一个流依赖于另一个有条件的流呢？假设您有一个函数<code>check()</code>，它依赖于另一个函数<code>getRandomInt()</code>，生成一个介于0和1之间的随机数，如果该随机数为1，则返回<code>true</code>。</p>
<p class="graf graf--p">基于这个流程，我们不知道会发生什么，因为函数是随机的——也就是说，只有在运行时我们才能看到代码是否进入了<code>if</code>:</p>
<pre class="graf graf--pre"><code>let abc = 1;
if (check()) {
   abc = "abc";
}
console.info(`abc length: ` + abc.length);

</code>function check() { return getRandomInt(2) == 1; } <code>function getRandomInt(max) {
   return Math.floor(Math.random() * Math.floor(max));
}</code></pre>
<p class="graf graf--p">下面是编译后的代码:</p>
<pre class="graf graf--pre"><code>var b = 1;
1 == Math.floor(2 * Math.random()) &amp;&amp; (b = "abc");
console.info("abc length: " + b.length);</code></pre>
<p class="graf graf--p">条件流被分析并重新编程为一条单线。注意闭包编译器是如何检查前面有一个<code>&amp;&amp;</code>操作符的第一个条件的。该操作符表示，只有当第一个条件为真时，才会执行第二个条件。否则，如果我们的随机数不等于1，那么<code>b</code>将永远不会收到<code>"abc"</code>作为值。</p>
<p class="graf graf--p">多条件的<code>if</code>怎么样？</p>
<pre class="graf graf--pre"><code>if(document == null || document == undefined || document == ‘’)
   console.info(`Is not valid`);</code></pre>
<p class="graf graf--p">看一看结果:</p>
<pre class="graf graf--pre"><code>null != document &amp;&amp; void 0 != document &amp;&amp; “” != document || console.info(“Is not valid”);</code></pre>
<p class="graf graf--p">条件<code>if</code>被嵌套。这是Closure编译器的默认行为:它总是试图尽可能地缩小，保持代码小而可执行。</p>
<h3 class="graf graf--h3">外部参考和注释</h3>
<p class="graf graf--p">总是审查已编译的代码可能是危险的和无益的。另外，如果您想让其他JavaScript文件全局使用<code>check()</code>函数，会发生什么情况呢？这里有一些技巧，比如Google建议将函数附加到全局窗口对象:</p>
<pre class="graf graf--pre"><code>window.check = c;</code></pre>
<p class="graf graf--p">在这里，我们将收到以下输出:</p>
<pre class="graf graf--pre"><code>var a = require("./helper.js"), b = 1;
c() &amp;&amp; (b = "abc");
console.info("abc length: " + b.length);
null != document &amp;&amp; void 0 != document &amp;&amp; "" != document || console.info("Is not valid");
function c() {
return 1 == Math.floor(2 * Math.random());
}
window.check = c;</code></pre>
<p class="graf graf--p">闭包编译器检查的类型系统是整个事情的核心。您可以对代码进行更多类型的注释，这意味着编译器将根据您的注释检查错误的用法。</p><div class="code-block code-block-54">
<hr/>
<h3>更多来自LogRocket的精彩文章:</h3>

<hr/></div>
<p class="graf graf--p">让我们以<code>getRandomInt()</code>函数为例。您需要您的参数在所有情况下都是一个数字，因此您可以让Closure编译器检查调用者是否传递了与此不同的内容:</p>
<pre class="graf graf--pre"><code>function getRandomInt(/** number */ max) {
return Math.floor(Math.random() * Math.floor(max));
}
window['getRandomInt'] = getRandomInt;
getRandomInt('a');</code></pre>
<p class="graf graf--p">这将返回以下内容:</p>
<figure class="graf graf--figure"><img decoding="async" class="graf-image jetpack-lazy-image" src="../Images/e4ecb0061d0adeb62480c2dab80a147f.png" data-image-id="0*-Vw2dsCYYPw9robF" data-width="692" data-height="279" data-lazy-src="/wp-content/uploads/2019/03/0_-Vw2dsCYYPw9robF.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/03/0_-Vw2dsCYYPw9robF.png"/><noscript><img data-lazy-fallback="1" decoding="async" class="graf-image" src="../Images/e4ecb0061d0adeb62480c2dab80a147f.png" data-image-id="0*-Vw2dsCYYPw9robF" data-width="692" data-height="279" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/03/0_-Vw2dsCYYPw9robF.png"/></noscript></figure>
<p class="graf graf--p">尽管该文件总是针对警告进行编译，但是您可以对您的代码有所了解，主要是那些被许多人更新的代码。</p>
<p class="graf graf--p">另一个有趣的特性是导出定义。如果您决定不希望通过<em class="markup--em markup--p-em">高级</em>选项对某些内容进行重命名，您也可以使用以下内容对代码进行注释:</p>
<pre class="graf graf--pre"><code>/** @export */</code></pre>
<p class="graf graf--p">这样，输出代码就不会被重命名。</p>
<h3 class="graf graf--h3">结论</h3>
<p class="graf graf--p">有许多不同的场景可以用来测试这个工具的能力。继续，使用您自己的JavaScript代码片段，用Closure Compiler来尝试它们。记下它生成的内容以及每个优化选项之间的差异。您还可以获取任何外部JavaScript插件/文件，并将其导入web服务进行测试。</p>
<p class="graf graf--p">请记住，您也可以从命令行运行它，甚至可以从您的构建系统(如Gulp、Webpack和其他可用的插件)运行它。谷歌还在其官方GitHub库提供了一个<a class="markup--anchor markup--p-anchor" href="https://github.com/google/closure-compiler-js/tree/master/samples" target="_blank" rel="noopener noreferrer" data-href="https://github.com/google/closure-compiler-js/tree/master/samples"> <em class="markup--em markup--p-em">样本</em>文件夹</a>，在那里你可以测试它的更多特性。伟大的研究！</p><div class="code-block code-block-27">
<div class="blog-plug inline-plug vanilla-javascript-cta"><h2>通过理解上下文，更容易地调试JavaScript错误</h2>
<p>调试代码总是一项单调乏味的任务。但是你越了解自己的错误，就越容易改正。</p>
<p>LogRocket 让你以新的独特的方式理解这些错误。我们的前端监控解决方案跟踪用户与您的JavaScript前端的互动，让您能够准确找出导致错误的用户行为。</p>
<a href="https://lp.logrocket.com/blg/javascript-signup" class="signup" target="_blank" rel="noopener noreferrer"><img class="alignnone size-full wp-image-46 jetpack-lazy-image" src="../Images/cbfed9be3defcb505e662574769a7636.png" alt="LogRocket Dashboard Free Trial Banner" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2020/06/reproduce-javascript-errors.gif?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/06/reproduce-javascript-errors.gif"/><noscript><img data-lazy-fallback="1" class="alignnone size-full wp-image-46" src="../Images/cbfed9be3defcb505e662574769a7636.png" alt="LogRocket Dashboard Free Trial Banner" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/06/reproduce-javascript-errors.gif"/></noscript></a>
<p>LogRocket记录控制台日志、页面加载时间、堆栈跟踪、慢速网络请求/响应(带有标题+正文)、浏览器元数据和自定义日志。理解您的JavaScript代码的影响从来没有这么简单过！</p>
<a class="signup" href="https://lp.logrocket.com/blg/javascript-signup" target="_blank" rel="noopener noreferrer">Try it for free</a><p>.</p></div>


</div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
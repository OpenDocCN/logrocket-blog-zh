<html>
<head>
<title>How to use type guards in TypeScript - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>如何在 TypeScript - LogRocket 博客中使用类型保护</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/how-to-use-type-guards-typescript/#0001-01-01">https://blog.logrocket.com/how-to-use-type-guards-typescript/#0001-01-01</a></blockquote><div><article class="article-post">
<p>类型保护是一种类型脚本技术，用于获取有关变量类型的信息，通常在条件块中。类型保护是返回布尔值的常规函数，它接受一个类型，并告诉 TypeScript 是否可以缩小到更具体的范围。类型保护具有独特的属性，可以根据返回的布尔值确保测试的值是固定类型的。</p>
<p>TypeScript 使用一些内置的 JavaScript 操作符，如<code>typeof</code>、<code>instanceof</code>和<code>in</code>操作符，用于确定对象是否包含属性。类型保护使您能够指示 TypeScript 编译器在特定上下文中推断变量的特定类型，从而确保参数的类型是您所说的类型。</p>
<p>类型保护通常用于缩小类型，与功能检测非常相似，允许您检测值的正确方法、原型和属性。因此，您可以很容易地找出如何处理该值。</p>
<p>使用类型保护有五种主要方式:</p>

<p>在本文中，我们将探索上面列出的四种方法。我们开始吧！</p>
<h2 id="the-instanceof-typeguard"><code>instanceof</code>型防护罩</h2>
<p><a href="https://www.typescriptlang.org/docs/handbook/2/narrowing.html#instanceof-narrowing"> <code>instanceof</code>是一个内置的类型保护</a>，可以用来检查一个值是否是一个给定的构造函数或类的实例。使用这种类型保护，我们可以测试一个对象或值是否是从一个类中派生出来的，这对于确定一个实例类型的类型是很有用的。</p>
<p><code>instanceof</code>型保护的基本语法如下:</p>
<pre class="“language-typescript">objectVariable instanceof ClassName;
</pre>
<p>在下面的例子中，我们看到了一个<code>instanceof</code>型防护装置的例子:</p>
<pre class="“language-typescript">interface Accessory {
    brand: string;
  }
  class Necklace implements Accessory{
    kind: string;
    brand: string;
    constructor(brand: string, kind: string) {    
      this.brand = brand;
      this.kind = kind;
    }
  }
  class bracelet implements Accessory{
    brand: string;
    year: number;
    constructor(brand: string, year: number) {    
      this.brand = brand;
      this.year = year;
    }
  }
  const getRandomAccessory = () =&gt;{
    return Math.random() &lt; 0.5 ?
      new bracelet('cartier', 2021) :
      new Necklace('choker', 'TASAKI');
  }
  let Accessory = getRandomAccessory();
  if (Accessory instanceof bracelet) {
    console.log(Accessory.year);
  }
  if (Accessory instanceof Necklace) {
    console.log(Accessory.brand);    
  }
</pre>
<p>上面的<code>getRandomAccessory</code>函数返回一个<code>Necklace</code>或<code>bracelet</code>对象，因为它们都实现了<code>Accessory</code>接口。<code>Necklace</code>和<code>bracelet</code>的构造函数签名是不同的，并且<code>instanceof</code>类型守卫比较这两个构造函数签名来有效地确定类型。</p>
<h2 id="the-typeof-typeguard"><code>typeof</code>型防护罩</h2>
<p><a href="https://www.typescriptlang.org/docs/handbook/2/typeof-types.html"> <code>typeof</code>类型保护</a>用于确定变量的类型。<code>typeof</code>型护板据说非常有限而且很浅。它只能确定 JavaScript 识别的以下类型:</p>
<ul>
<li><code>boolean</code></li>
<li><code>string</code></li>
<li><code>bigint</code></li>
<li><code>symbol</code></li>
<li><code>undefined</code></li>
<li><code>function</code></li>
<li><code>number</code></li>
</ul>
<p>对于这个列表之外的任何东西，<code>typeof</code>类型的守卫简单地返回<code>object</code>。</p>
<p><code>typeof</code>型保护可以用以下两种方式编写:</p>
<pre class="“language-typescript">typeof v !== "typename"
#or 
typeof v === "typename"
</pre>
<p><code>typename</code>可以是<code>string</code>、<code>number</code>、<code>symbol</code>或<code>boolean</code>。</p>
<p>在下面的例子中，<code>StudentId</code>有一个<code>string | number</code>类型的联合参数条目。我们看到，如果变量是一个<code>string</code>，就会打印出<code>Student</code>，如果是一个<code>number</code>，就会打印出<code>Id</code>。<code>typeof</code>类型保护帮助我们从<code>x</code>中提取类型:</p>
<pre class="“language-typescript">function StudentId(x: string | number) {
    if (typeof x == 'string') {
        console.log('Student');
    }
    if (typeof x === 'number') {
        console.log('Id');
    }
}
StudentId(`446`); //prints Student
StudentId(446); //prints Id
</pre>
<h2 id="the-in-typeguard"><code>in</code>型防护罩</h2>
<p><a href="https://www.typescriptlang.org/docs/handbook/2/narrowing.html#the-in-operator-narrowing"> <code>in</code>类型守卫</a>检查一个对象是否有特定的属性，以此来区分不同的类型。它通常返回一个布尔值，表明该属性是否存在于该对象中。它用于其缩小功能，以及检查浏览器支持。</p>
<p><code>in</code>型保护的基本语法如下:</p>
<pre class="“language-typescript">propertyName in objectName
</pre>
<p>在下面的例子中，<code>in</code>类型的守卫检查属性<code>house</code>是否存在。如果存在，返回布尔值<code>true</code>，如果不存在，返回<code>false</code>。</p>
<pre class="“language-typescript">"house" in { name: "test", house: { parts: "door" } }; // =&gt; true
"house" in { name: "test", house: { parts: "windows" } }; // =&gt; true
"house" in { name: "test", house: { parts: "roof" } }; // =&gt; true
"house" in { name: "test" }; // =&gt; false
"house" in { name: "test", house: undefined }; // =&gt; true
</pre>
<p>另一个类似的<code>in</code>型防护装置工作原理的例子如下所示:</p>
<pre class="“language-typescript">interface Pupil {
    ID: string;
  }
  interface Adult {
    SSN: number;
  }
  interface Person {
    name: string;
    age: number;
  }
  let person: Pupil | Adult | Person = {
    name: 'Britney',
    age: 6
  };
  const getIdentifier = (person: Pupil | Adult | Person) =&gt; {
    if ('name' in person) {
      return person.name;
    }
    else if ('ID' in person) {
      return person.ID
    }
    return person.SSN;
  }
</pre>
<h2 id="equality-narrowing-typeguard">相等缩小型防护</h2>
<p>相等缩小检查表达式的值。要使两个变量相等，这两个变量必须属于同一类型。如果变量的类型未知，但它等于另一个具有精确类型的变量，则 Typescript 将使用已知变量提供的信息缩小第一个变量的类型:</p>
<pre class="“language-typescript">function getValues(a: number | string, b: string) {
    if(a === b) {
        // this is where the narrowing takes place. narrowed to string
        console.log(typeof a) // string
    } else {
        // if there is no narrowing, type remains unknown
        console.log(typeof a) // number or string
    }
}
</pre>
<p>如果变量<code>a</code>等于变量<code>b</code>，那么两者必须具有相同的类型。在这种情况下，Typescript 将其缩小到字符串。如果不缩小范围，<code>a</code>的类型仍然不清楚，因为它可能是数字，也可能是字符串。</p>
<h2 id="custom-typeguard-with-predicate">带有谓词的自定义类型保护</h2>
<p>创建自定义类型保护通常是使用类型保护的一个强大选项。当你通过自己编写来创建一个自定义类型的守卫时，你可以检查的东西是没有限制的。但是，如果自定义类型保护写得不正确，它会带来很多错误。所以，精准是关键。</p>
<p>自定义类型防护的示例如下所示:</p>
<pre class="“language-typescript">interface Necklace{
    kind: string;
    brand: string;
}
interface bracelet{
    brand: string;
    year: number;
}
type Accessory = Necklace | bracelet;

const isNecklace = (b: Accessory): b is Necklace =&gt; {
    return (b as Necklace).kind !== undefined
}
const Necklace: Accessory = {kind: "Choker", brand: "TASAKI"};
const bracelet: Accessory = {brand: "Cartier", year: 2021};
console.log(isNecklace(bracelet)) //Logs false
console.log(isNecklace(Necklace)) //Logs true
</pre>
<p>在上面的代码中，类型谓词<code>b is Necklace</code>将使 TypeScript 将类型简化为<code>Necklace</code>，而不是只返回一个布尔值。</p>
<h2 id="conclusion">结论</h2>
<p>TypeScript 类型保护有助于确保类型的值，改善整体代码流。在本文中，我们回顾了 TypeScript 中几种最有用的类型保护，并通过几个例子来了解它们的实际应用。</p>
<p>大多数情况下，您的用例可以使用<code>instanceof</code>型防护、<code>typeof</code>型防护或<code>in</code>型防护来解决，但是，您可以在绝对必要时使用定制型防护。</p>
<p>我希望你喜欢这篇文章！如果你有任何问题，一定要留下评论。</p><div class="code-block code-block-21">
<div class="blog-plug inline-plug typescript-plug"><h2><a class="signup" href="https://lp.logrocket.com/blg/typescript-signup" target="_blank" rel="noopener noreferrer"> LogRocket </a>:全面了解您的网络和移动应用</h2>
<a href="https://lp.logrocket.com/blg/typescript-signup" class="signup" target="_blank" rel="noopener noreferrer"><img class="alignnone size-full wp-image-46 jetpack-lazy-image" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/><noscript><img data-lazy-fallback="1" class="alignnone size-full wp-image-46" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/></noscript></a>
<p>LogRocket 是一个前端应用程序监控解决方案，可以让您回放问题，就像问题发生在您自己的浏览器中一样。LogRocket 不需要猜测错误发生的原因，也不需要向用户询问截图和日志转储，而是让您重放会话以快速了解哪里出错了。它可以与任何应用程序完美配合，不管是什么框架，并且有插件可以记录来自 Redux、Vuex 和@ngrx/store 的额外上下文。</p>
<p>除了记录 Redux 操作和状态，LogRocket 还记录控制台日志、JavaScript 错误、堆栈跟踪、带有头+正文的网络请求/响应、浏览器元数据和自定义日志。它还使用 DOM 来记录页面上的 HTML 和 CSS，甚至为最复杂的单页面和移动应用程序重新创建像素级完美视频。</p>
<a class="signup" href="https://lp.logrocket.com/blg/typescript-signup" target="_blank" rel="noopener noreferrer">Try it for free</a><p>.</p></div>
</div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
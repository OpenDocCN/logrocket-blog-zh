<html>
<head>
<title>Getting started with Create React App and TypeScript - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>开始使用 Create React App 和 TypeScript - LogRocket 博客</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/getting-started-create-react-app-typescript/#0001-01-01">https://blog.logrocket.com/getting-started-create-react-app-typescript/#0001-01-01</a></blockquote><div><article class="article-post">
<p><em> <strong>编者按</strong>:这篇文章最后一次验证准确性是在 2022 年 11 月 15 日</em>。</p>
<p>JavaScript 是一种奇妙的编程语言，它正在将其范围从浏览器扩展到 API、移动开发、桌面应用程序等等。然而，尽管 JavaScript 拥有强大的功能、持续的改进和不断增长的潜力，但它缺少一个有助于代码组织和效率的关键特性，即类型。</p>
<p>例如，考虑下面的代码:</p>
<pre>let someText = "Hello World!";
someText = 123;
someText = [123, 'hello', { isThisCorrect: true }]
</pre>
<p>在大多数编程语言中，上面的代码不起作用，但是 JavaScript 允许这样做。我们可以创建一个字符串形式的变量，然后给它赋值一个数字，对象，甚至数组。但是，这样做有利也有弊。</p>
<p>随着应用程序的扩展，项目依赖性增加，系统变得更加复杂。开发人员可能很难理解变量、属性和方法的完整上下文，尤其是在使用框架和外部依赖项时。</p>
<p>如果在编程时，我们的 IDE 可以建议并自动完成一个对象的属性，即使这个对象是远程获取操作的结果，这不是很好吗？或者，我们可以检查一个变量，很容易地看到它的所有方法？</p>
<p>TypeScript 通过向变量添加类型来解决这个问题。在本文中，我们将通过涵盖以下内容来探索 React 中的类型:</p>

<h2 id="setting-up-new-project-typescript">使用 TypeScript 设置新项目</h2>
<p id="tobeginletssetupourappintypescriptandpreconfigurewebpackbabelandourdependencesusingcreatereactappwiththefollowingcommand">首先，让我们使用 Create React App 和以下命令在 TypeScript 和 preconfigure webpack、Babel 中设置我们的应用程序和我们的依赖项:</p>
<pre>npx create-react-app my-app --template typescript
</pre>
<p>要启动项目，请运行:</p>
<pre>cd my-app
npm start
</pre>
<p>请注意，该站点看起来类似于 JavaScript 版本。然而，当我们开始查看代码时，您会注意到一些不同之处。</p>
<h2 id="typescript-compiler">类型脚本编译器</h2>
<p>让我们仔细看看组件和测试，从<code>App.tsx</code>文件开始。你可能注意到的第一件事是它的文件扩展名。所有的组件文件现在都是<code>tsx</code>而不是<code>js</code>或<code>jsx</code>，同样，像<code>setupTests.js</code>这样的文件现在是<code>setupTests.ts</code>。但是为什么呢？</p>
<p>在撰写本文时，web 浏览器和 Node.js 还不提供对 TypeScript 的直接支持。他们只理解 JavaScript，因此，我们需要将我们的类型脚本文件转换成 JavaScript 文件。TypeScript 编译器负责执行这项任务。</p>
<p>编译器需要知道哪些文件是纯 JavaScript，哪些文件需要编译，因此，使用了上面提到的不同文件扩展名。</p>
<h2 id="typing-variables-typescript">在 TypeScript 中键入变量</h2>
<p>JavaScript 不是类型化的，这意味着您不能将数据类型赋给变量，但 JavaScript 仍然理解数字、字符串和对象之间的区别。在运行时，JavaScript 会尽最大努力根据变量包含的值来推断变量的类型。</p>
<p>让我们看看下面的例子:</p>
<pre>let helloWorld = "Hello World";
</pre>
<p>因为包含在<code>helloWorld</code>变量中的值是一个字符串，所以该变量现在是类型<code>string</code>，并且您可以执行您通常会在字符串上执行的任何操作。但是，如果该变量在以后发生变化，该变量的类型也将发生变化。</p>
<p>TypeScript 采用同样的方法，在声明时根据变量的值为变量指定类型。因此，同一行代码将在 TypeScript 中工作。区别取决于当你想给变量赋一个不同类型的新值时会发生什么。</p>
<p>我们已经看到 JavaScript 允许您这样做，但是让我们看看如果我们用 TypeScript 做同样的事情会发生什么:</p>
<pre>let helloWorld = "Hello World";
helloWorld = 10;
</pre>
<p>有趣的是，无论你使用的是<a href="https://code.visualstudio.com/"> VS Code </a>、<a href="https://www.jetbrains.com/webstorm/"> WebStorm </a>还是任何其他支持 TypeScript 的 IDE，你的 IDE 都已经检测到了一个问题，用红色突出显示了这个变量，并给出了相关信息:</p>
<figure id="attachment_142588" aria-describedby="caption-attachment-142588" class="wp-caption aligncenter"><img data-attachment-id="142588" data-permalink="https://blog.logrocket.com/highlighted-errors-typescript-2/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/11/highlighted-errors-typescript.png" data-orig-size="730,205" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="highlighted-errors-typescript" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/11/highlighted-errors-typescript-300x84.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/11/highlighted-errors-typescript.png" decoding="async" class="wp-image-142588 size-full jetpack-lazy-image" src="../Images/a08041591d7aa630928745e416765da9.png" alt="Highlighted Errors TypeScript" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2022/11/highlighted-errors-typescript.png 730w, https://blog.logrocket.com/wp-content/uploads/2022/11/highlighted-errors-typescript-300x84.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2022/11/highlighted-errors-typescript.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/11/highlighted-errors-typescript.png"/><noscript><img data-lazy-fallback="1" data-attachment-id="142588" data-permalink="https://blog.logrocket.com/highlighted-errors-typescript-2/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/11/highlighted-errors-typescript.png" data-orig-size="730,205" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="highlighted-errors-typescript" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/11/highlighted-errors-typescript-300x84.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/11/highlighted-errors-typescript.png" decoding="async" loading="lazy" class="wp-image-142588 size-full" src="../Images/a08041591d7aa630928745e416765da9.png" alt="Highlighted Errors TypeScript" srcset="https://blog.logrocket.com/wp-content/uploads/2022/11/highlighted-errors-typescript.png 730w, https://blog.logrocket.com/wp-content/uploads/2022/11/highlighted-errors-typescript-300x84.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/11/highlighted-errors-typescript.png"/></noscript><figcaption id="caption-attachment-142588" class="wp-caption-text">WebStorm highlights errors in types when using TypeScript</figcaption></figure>
<p>此外，编译过程将导致错误，您将无法运行您的应用程序:</p>
<figure id="attachment_142596" aria-describedby="caption-attachment-142596" class="wp-caption aligncenter"><img data-attachment-id="142596" data-permalink="https://blog.logrocket.com/typescript-prevent-app-build-errors/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/11/typescript-prevent-app-build-errors.jpeg" data-orig-size="730,157" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;1&quot;}" data-image-title="typescript-prevent-app-build-errors" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/11/typescript-prevent-app-build-errors-300x65.jpeg" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/11/typescript-prevent-app-build-errors.jpeg" decoding="async" class="wp-image-142596 size-full jetpack-lazy-image" src="../Images/aac02f63e1abc085cb81dfd6705f1165.png" alt="Typescript Prevent App Build Errors" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2022/11/typescript-prevent-app-build-errors.jpeg 730w, https://blog.logrocket.com/wp-content/uploads/2022/11/typescript-prevent-app-build-errors-300x65.jpeg 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2022/11/typescript-prevent-app-build-errors.jpeg?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/11/typescript-prevent-app-build-errors.jpeg"/><noscript><img data-lazy-fallback="1" data-attachment-id="142596" data-permalink="https://blog.logrocket.com/typescript-prevent-app-build-errors/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/11/typescript-prevent-app-build-errors.jpeg" data-orig-size="730,157" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;1&quot;}" data-image-title="typescript-prevent-app-build-errors" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/11/typescript-prevent-app-build-errors-300x65.jpeg" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/11/typescript-prevent-app-build-errors.jpeg" decoding="async" loading="lazy" class="wp-image-142596 size-full" src="../Images/aac02f63e1abc085cb81dfd6705f1165.png" alt="Typescript Prevent App Build Errors" srcset="https://blog.logrocket.com/wp-content/uploads/2022/11/typescript-prevent-app-build-errors.jpeg 730w, https://blog.logrocket.com/wp-content/uploads/2022/11/typescript-prevent-app-build-errors-300x65.jpeg 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/11/typescript-prevent-app-build-errors.jpeg"/></noscript><figcaption id="caption-attachment-142596" class="wp-caption-text">TypeScript prevents the app from building if there are errors in Types</figcaption></figure>
<p>到目前为止，我们已经让 TypeScript 决定了变量的数据类型，这是通过推理调用的<a href="https://blog.logrocket.com/type-flowing-rethinking-typescript-typing-system/">类型。然而，在其他情况下，我们可能希望手动为变量分配一个类型，这可能是因为我们仍然没有它的值，或者因为变量可能有多种类型。</a></p>
<p>让我们使用显式类型声明一个变量:</p>
<pre>let helloWorld:string  = "Hello World";
</pre>
<p>很容易，我们可以在声明过程中在变量名后面传递类型。</p>
<h2 id="setting-up-new-react-application-typescript">使用 TypeScript 设置新的 React 应用程序</h2>
<p>React 本身与 JavaScript 配合得很好，但是，使用 TypeScript 会让我们受益匪浅。TypeScript 减少了 bug 和错误，使代码库更加可预测，并提高了组件利用率。</p>
<p>让我们为 GitHub 开发一个简单的搜索应用程序，允许用户使用<a href="https://docs.github.com/en/rest/search?apiVersion=2022-11-28#search-repositories"> GitHub 的搜索 API </a>搜索存储库。下面的 gif 展示了我们将要创建的应用程序的一个例子:</p>
<p><img data-attachment-id="142598" data-permalink="https://blog.logrocket.com/search-repositories-github-application/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/11/search-repositories-github-application.gif" data-orig-size="730,562" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="search-repositories-github-application" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/11/search-repositories-github-application-300x231.gif" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/11/search-repositories-github-application.gif" decoding="async" class="aligncenter wp-image-142598 size-full jetpack-lazy-image" src="../Images/b70a1fd4614cf5560c3907e96b5424c8.png" alt="Search Repositories Github Application" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2022/11/search-repositories-github-application.gif?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/11/search-repositories-github-application.gif"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="142598" data-permalink="https://blog.logrocket.com/search-repositories-github-application/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/11/search-repositories-github-application.gif" data-orig-size="730,562" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="search-repositories-github-application" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/11/search-repositories-github-application-300x231.gif" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/11/search-repositories-github-application.gif" decoding="async" loading="lazy" class="aligncenter wp-image-142598 size-full" src="../Images/b70a1fd4614cf5560c3907e96b5424c8.png" alt="Search Repositories Github Application" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/11/search-repositories-github-application.gif"/></noscript>
<p>你可以在<a href="https://github.com/bajcmartinez/react-typescript-example"> GitHub </a>上查看该应用的完整代码。</p>
<p>运行以下命令，使用<a href="https://reactjs.org/docs/create-a-new-react-app.html"> Create React App </a>启动一个新的兼容 TypeScript 的 React 应用程序:</p>
<pre>npx create-react-app my-app --template typescript
or
yarn create-react-app my-app --template typescript
</pre>
<p>接下来，使用以下命令启动项目:</p>
<pre>cd my-app
npm start
</pre>
<h3 id="remote-data-types">远程数据类型</h3>
<p>我们需要从我们的 API 获取数据，所以我们需要一个对象来存储它，并且该对象必须映射到一个类型。让我们通过分析响应和构建自定义类型来定义我们的 API 数据类型。下面是一个示例响应供参考:</p>
<pre>{
  "total_count": 40,
  "incomplete_results": false,
  "items": [
    {
      "id": 3081286,
      "node_id": "MDEwOlJlcG9zaXRvcnkzMDgxMjg2",
      "name": "Tetris",
      "full_name": "dtrupenn/Tetris",
      "owner": {
        "login": "dtrupenn",
        "id": 872147,
        "node_id": "MDQ6VXNlcjg3MjE0Nw==",
        "avatar_url": "https://secure.gravatar.com/avatar/e7956084e75f239de85d3a31bc172ace?d=https://a248.e.akamai.net/assets.github.com%2Fimages%2Fgravatars%2Fgravatar-user-420.png",
        "gravatar_id": "",
        "url": "https://api.github.com/users/dtrupenn",
        "received_events_url": "https://api.github.com/users/dtrupenn/received_events",
        "type": "User"
      },
      "private": false,
      "html_url": "https://github.com/dtrupenn/Tetris",
      "description": "A C implementation of Tetris using Pennsim through LC4",
      "fork": false,
      "url": "https://api.github.com/repos/dtrupenn/Tetris",
      "created_at": "2012-01-01T00:31:50Z",
      "updated_at": "2013-01-05T17:58:47Z",
      "pushed_at": "2012-01-01T00:37:02Z",
      "homepage": "",
      "size": 524,
      "stargazers_count": 1,
      "watchers_count": 1,
      "language": "Assembly",
      "forks_count": 0,
      "open_issues_count": 0,
      "master_branch": "master",
      "default_branch": "master",
      "score": 1.0
    }
  ]
}
</pre>
<p>我们的应用程序非常简单，所以我们不需要映射所有这些字段，但是让我们看看它是如何工作的。在<code>src</code>目录下创建一个<code>Types/GitHub.ts</code>文件。在这个文件中，我们将定义一个自定义数据类型来表示 JSON 响应。</p>
<p>TypeScript 有<a href="https://blog.logrocket.com/understanding-using-interfaces-typescript/">两个定义类型的主要选项，接口</a>和类型。各有各的属性和规则。在本文中，我们不会对它们进行过多的讨论，但是如果你想了解更多，我建议你阅读一下 TypeScript 中的<a href="https://blog.logrocket.com/types-vs-interfaces-in-typescript/">类型与接口。一般来说，你会希望使用道具和类型的接口来表示对象。</a></p>
<p>在我们的例子中，我们表示一个对象，所以我们将使用<code>types</code>语法来声明我们的<code>GitHubSearchResultType</code>，它由找到的存储库的<code>total_number</code>、一个<code>incomplete_results</code>标志、返回的<code>true</code>或<code>false</code>以及一个项目或存储库列表组成。</p>
<p>前两个属性非常简单。每一个都对应于一个<a href="https://www.typescriptlang.org/docs/handbook/basic-types.html"> TypeScript 基本类型</a>，所以我们可以立即引用它们:</p>
<pre>export type GitHubSearchResultType = {
    total_count: number;
    incomplete_results: boolean;
}
</pre>
<p>然而，当涉及到<code>items</code>属性时，情况就有点复杂了。我们知道这是一个对象数组，所以我们可以使用 TypeScript 中的<code>any</code>关键字，它将变量默认为 JavaScript 行为，忽略类型。它看起来类似于下面的代码:</p>
<pre>export type GitHubSearchResultType = {
    total_count: number;
    incomplete_results: boolean;
    Items: Array&lt;any&gt;;
}
</pre>
<p>注意，定义数组的语法有点不同，因为我们在一个定义中有两种类型，主类型<code>Array</code>和数组元素的类型，它们属于中间的<code>&lt;&gt;</code>。</p>
<p>虽然这样行得通，但并不理想。在大多数项目中，lint 规则禁止并监控<code>any</code>的使用。基本上，您会忽略开始使用 TypeScript 的原因。更好的方法是定义第二个自定义类型，并将数组映射到该类型，如下面的代码片段所示:</p>
<pre>typescript
export type GitHubSearchResultType = {
    total_count: number;
    incomplete_results: boolean;
    items: Array&lt;GitHubRepository&gt;
}
</pre>
<p>很清楚什么是项目，每个项目有什么属性。现在，我们只缺少<code>GitHubRepository</code>的定义:</p>
<pre>export type GitHubRepository = {
    id: string;
    full_name: string;
    html_url: string;
}
</pre>
<h3 id="building-component-listing-repositories">构建组件:列出存储库</h3>
<p>现在，我们可以构建我们的组件了。我们将从一个非常简单的组件开始，它将接收一个存储库列表，并将它们绘制在屏幕上。我们将这个组件命名为<code>ListRepositories.tsx</code>，并将其存储在<code>src/Components</code>文件夹中。</p>
<p>基于 TypeScript 的 React 组件与 JavaScript React 组件有两个主要区别:</p>
<ol>
<li>类型检查不需要<a href="https://blog.logrocket.com/comparing-typescript-and-proptypes-in-react-applications/"> PropTypes，因为我们有 TypeScript</a></li>
<li>组件声明略有不同</li>
</ol>
<p>先来了解一下如何用 TypeScript 定义道具。我们的组件需要访问我们将通过 props 接收的存储库列表，所以让我们使用<code>interface</code>语法来定义它:</p>
<pre>interface Props {
    repositories?: Array&lt;GitHubRepository&gt;;
}
</pre>
<p>与类型类似，接口在括号之间的主体中定义对象的属性，并且属性以相同的方式定义。</p>
<p>在我们的特定示例中，我们引入了一个称为可选属性的新概念，通过在属性名称后添加一个<code>?</code>来表示。这些可选属性可以是<code>undefined</code>、<code>null</code>或给定类型的值。</p>
<p>我们创造的<code>interface</code>叫做<code>Props</code>。不过，它可能是任何东西，比如<code>ListRepositoryProps</code>或<code>ListRepositoryPropsType</code>。</p>
<p>因此，当我们声明我们的组件时，我们必须告诉 React 类型的名称是什么。我们通过如下使用<code>React.FC</code>来实现:</p>
<pre>const ListRepositories: React.FC&lt;Props&gt; = (props) =&gt; {
</pre>
<p>在一行中，我们创建了一个功能组件，并告诉 React 我们的道具是<code>Props</code>类型的。因为它是一个功能组件，我们可以做一些很酷的事情，比如对象析构。现在，我们修改后的声明如下所示:</p>
<pre>const ListRepositories: React.FC&lt;Props&gt; = ({ repositories = [] }) =&gt; {
</pre>
<p>您可能想知道，如果我们总是需要一个值，为什么要将<code>repositories</code>属性设置为 optional。这个组件的父组件可能会传递一个<code>undefined</code>，如果是这样的话，我们可以假设一个空列表。</p>
<p>下面是该组件的完整代码:</p>
<pre>import React from 'react';
import {GitHubRepository} from "../Types/GitHub";

interface Props {
    repositories?: Array&lt;GitHubRepository&gt;;
}

const ListRepositories: React.FC&lt;Props&gt; = ({ repositories = [] }) =&gt; {
    return (
        &lt;ul&gt;
            {repositories.map(repository =&gt; (
                &lt;li key={repository.id}&gt;
                   &lt;a href={repository.html_url} target="_blank"&gt;{repository.full_name}&lt;/a&gt;
                &lt;/li&gt;
            ))}
        &lt;/ul&gt;
    );
}

export default ListRepositories;
</pre>
<h3 id="creating-search-form">创建搜索表单</h3>
<p>接下来，我们将构建一个新的组件，负责捕获用户输入并启动搜索操作。由于我们已经是 React 和 TypeScript 的专家，我将展示表单的完整代码，然后讨论下面的关键元素:</p>
<pre>import React from 'react';

interface Props {
    search(query: string): void;
}

const SearchForm: React.FC&lt;Props&gt; = (props) =&gt; {
    function handleSubmit(e: React.FormEvent) {
        e.preventDefault();
        const formData = new FormData(e.target as HTMLFormElement);
        props.search((formData.get('query') || '') as string);
    }

    return (
        &lt;form onSubmit={handleSubmit}&gt;
            &lt;label&gt;
                Query:
                &lt;br /&gt;
                &lt;input type="text" name="query" /&gt;
            &lt;/label&gt;
            &lt;button&gt;Search&lt;/button&gt;
        &lt;/form&gt;
    );
}

export default SearchForm;
</pre>
<p>像我们之前的组件一样，我们使用一个<code>interface</code>来定义我们的道具。然而，我们没有属性，而是有一个方法。</p>
<p><a href="https://blog.logrocket.com/definitive-guide-typing-functions-typescript/"> TypeScript 允许我们定义函数类型</a>。我们可以通过指定函数名、参数、类型和返回类型来实现。它还支持函数表达式和箭头函数，如下面的代码所示:</p>
<pre>//function expression
functionName(param1: type, …): type;

//arrow function
functionName: (param1: type, ...) =&gt; type;
</pre>
<p>示例:</p>
<pre>interface Props {
    search(query: string): void;
}

interface Props {
    search: (query: string) =&gt; void;
}
</pre>
<p>在这种形式中，我们还有另一种特殊的类型转换用法:</p>
<pre>props.search((formData.get('query') || '') as string);
</pre>
<p>为什么我们需要演员？<code>formData.get</code>函数是一个<a href="https://blog.logrocket.com/types-vs-interfaces-in-typescript/">联合类型</a>，这意味着它可以是多种类型中的一种，在本例中是<code>string</code>、<code>File</code>或<code>undefined</code>。我们知道，对于我们的目的，唯一的选择是字符串，因此，我们将。</p>
<h2 id="api-fetching-put-together">API 获取并把它们放在一起</h2>
<p>现在我们已经准备好了所有的部分，我们需要在<code>App.tsx</code>组件上组合它们，并添加从 GitHub API 获取远程数据的功能。</p>
<p>在我们揭示代码之前，重要的是澄清我们正在使用<a href="https://github.com/axios/axios"> Axios </a>从 API 获取数据。运行以下命令安装 Axios:</p>
<pre>npm install axios
</pre>
<p>现在，我们将运行下面的代码:</p>
<pre>import React from 'react';
import axios from 'axios';
import {GitHubRepository, GitHubSearchResultType} from "./Types/GitHub";
import SearchForm from "./Components/SearchForm";
import ListRepositories from "./Components/ListRepositories";

function App() {
    const [repositories, setRepositories] = React.useState&lt;Array&lt;GitHubRepository&gt;&gt;();

    // Performs the search
    async function search(query: string) {
         const result = await axios.get&lt;GitHubSearchResultType&gt;(`https://api.github.com/search/repositories?q=${query}`);
         setRepositories(result.data.items);
    }

    return (
        &lt;div&gt;
            &lt;SearchForm search={search}/&gt;
            &lt;ListRepositories repositories={repositories}/&gt;
        &lt;/div&gt;
    );
}

export default App;
</pre>
<p>上面的代码几乎是标准的 React 代码，除了两个使用<a href="https://www.typescriptlang.org/docs/handbook/generics.html">类型脚本泛型</a>的实例。</p>
<p>泛型允许定义具有空白类型，以便以后完成。React 中一个很好的例子是<code>React.useState</code>函数。<code>useState</code>将定义一个 getter 和 setter，我们可以在代码中使用它们来存储 React 状态中的信息。但是，React 如何知道这个 getter 和 setter 的类型呢？答案是泛型。基本上，像<code>useState</code>这样的函数应该声明如下:</p>
<pre>function useState&lt;S = undefined&gt;(): [S | undefined, Dispatch&lt;SetStateAction&lt;S | undefined&gt;&gt;];
</pre>
<p><code>S</code>可以是任意类型，在函数调用时指定如下:</p>
<pre>const [repositories, setRepositories] = React.useState&lt;Array&lt;GitHubRepository&gt;&gt;();
</pre>
<p>或者，通过使用隐式类型指定:</p>
<pre>const [someText, setSomeText] = React.useState('Hello World!');
</pre>
<p>使用泛型的第二个例子是当我们使用 Axios 时:</p>
<pre>const result = await axios.get&lt;GitHubSearchResultType&gt;(`https://api.github.com/search/repositories?q=${query}`);
         setRepositories(result.data.items);
</pre>
<p>在这种情况下，<code>GET</code>函数将返回映射到给定类型的 JSON 响应数据。</p>
<h2 id="conclusion">结论</h2>
<p>在本教程中，我们学习了如何利用 TypeScript 的强大功能来构建可伸缩和可维护的 React 应用程序。我希望你喜欢读这篇文章，就像我喜欢写它一样，正如我常说的，一旦你打字，你就再也不会回来了。感谢阅读！</p><div class="code-block code-block-17">
<div class="blog-plug inline-plug react-plug" vwo-el-id="26283398190">
<h2 vwo-el-id="41600691720"><a href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener"> LogRocket </a>:全面了解您的生产 React 应用</h2><p>调试 React 应用程序可能很困难，尤其是当用户遇到难以重现的问题时。如果您对监视和跟踪 Redux 状态、自动显示 JavaScript 错误以及跟踪缓慢的网络请求和组件加载时间感兴趣，</p><a href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" vwo-el-id="19356441070">try LogRocket</a><p>. </p><a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="19356441380">
<img class="first-react-image alignnone size-full wp-image-46 jetpack-lazy-image jetpack-lazy-image--handled" src="../Images/f300c244a1a1cf916df8b4cb02bec6c6.png" vwo-el-id="18272717540" data-lazy-loaded="1" data-original-src="https://files.readme.io/27c94e7-Image_2017-06-05_at_9.46.04_PM.png"/>
</a>
<a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="19356441690">
<img class="second-react-image alignnone size-full wp-image-46 jetpack-lazy-image jetpack-lazy-image--handled" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" vwo-el-id="30720362350" data-lazy-loaded="1" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/>
</a>
<p vwo-el-id="28675660440" class="">LogRocket 结合了会话回放、产品分析和错误跟踪，使软件团队能够创建理想的 web 和移动产品体验。这对你来说意味着什么？</p>
<p>LogRocket 不是猜测错误发生的原因，也不是要求用户提供截图和日志转储，而是让您回放问题，就像它们发生在您自己的浏览器中一样，以快速了解哪里出错了。</p>
<p>不再有嘈杂的警报。智能错误跟踪允许您对问题进行分类，然后从中学习。获得有影响的用户问题的通知，而不是误报。警报越少，有用的信号越多。</p>
<p vwo-el-id="28675660750">LogRocket Redux 中间件包为您的用户会话增加了一层额外的可见性。LogRocket 记录 Redux 存储中的所有操作和状态。</p>
<p vwo-el-id="28675661060">现代化您调试 React 应用的方式— <a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="40093418840">开始免费监控</a>。</p><div class="code-block code-block-21">
<div class="blog-plug inline-plug typescript-plug"><h2><a class="signup" href="https://lp.logrocket.com/blg/typescript-signup" target="_blank" rel="noopener noreferrer"> LogRocket </a>:全面了解您的网络和移动应用</h2>
<a href="https://lp.logrocket.com/blg/typescript-signup" class="signup" target="_blank" rel="noopener noreferrer"><img class="alignnone size-full wp-image-46 jetpack-lazy-image" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/><noscript><img data-lazy-fallback="1" class="alignnone size-full wp-image-46" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/></noscript></a>
<p>LogRocket 是一个前端应用程序监控解决方案，可以让您回放问题，就像问题发生在您自己的浏览器中一样。LogRocket 不需要猜测错误发生的原因，也不需要向用户询问截图和日志转储，而是让您重放会话以快速了解哪里出错了。它可以与任何应用程序完美配合，不管是什么框架，并且有插件可以记录来自 Redux、Vuex 和@ngrx/store 的额外上下文。</p>
<p>除了记录 Redux 操作和状态，LogRocket 还记录控制台日志、JavaScript 错误、堆栈跟踪、带有头+正文的网络请求/响应、浏览器元数据和自定义日志。它还使用 DOM 来记录页面上的 HTML 和 CSS，甚至为最复杂的单页面和移动应用程序重新创建像素级完美视频。</p>
<a class="signup" href="https://lp.logrocket.com/blg/typescript-signup" target="_blank" rel="noopener noreferrer">Try it for free</a><p>.</p></div>
</div>
</div></div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
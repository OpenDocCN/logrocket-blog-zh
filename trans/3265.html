<html>
<head>
<title>12 essential ESLint rules for React - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>React - LogRocket博客的12条基本原则</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/12-essential-eslint-rules-react/#0001-01-01">https://blog.logrocket.com/12-essential-eslint-rules-react/#0001-01-01</a></blockquote><div><article class="article-post">
<h2>介绍</h2>
<p>ESLint为JavaScript代码提供了一套全面的规则，涵盖了风格选择和防止常见错误。单独使用ESLint将会提升你的项目，但是有ESLint插件可以添加React特定的规则，帮助你编写可靠的React应用程序。</p>
<p>在本帖中，我们将回顾这些ESLint规则和插件，包括它们在钩子上的应用。这里有一些快速链接供您参考:</p>

<h2 id="installing-eslint">安装ESLint</h2>
<p>如果您的项目中还没有安装ESLint，您可以安装它并通过运行以下命令生成初始配置:</p>
<pre class="language-bash hljs">npm init @eslint/config
</pre>
<p>ESLint会问一些关于你的项目的问题。其中，它会询问您是否正在使用React。选择此选项，ESLint将与<code>eslint-plugin-react</code>一起安装。</p>
<h2 id="using-create-react-app-inbuilt-eslint-configuration">使用Create React应用程序的内置ESLint配置</h2>
<p>如果您的应用程序使用Create React App，您很可能不需要安装本文中提到的任何插件，甚至根本不需要安装ESLint。v3和更高版本的React-scripts(CRA的一个包)的所有版本都使用内置的Create React App ESLint配置，该配置已经设置为包括<code>eslint-plugin-react-hooks</code>插件(以及方便的<code>jsx-a11y</code>插件)。</p>
<p><em> <strong>注意，</strong>在CRA app中手动安装ESLint，或本文提到的其他插件，可能会导致版本冲突或其他问题</em></p>
<h2 id="configuring-eslint-react">为React配置ESLint</h2>
<p>使用React ESLint插件时，还应该向ESLint配置的settings对象添加React部分。这允许您指定正在使用的react版本，或者使用<code>latest</code>或<code>detect</code>特殊值来分别使用最新的react版本或检测项目正在使用的React版本:</p>
<pre class="language-javascript hljs">{
  ...other ESLint config
  settings: {
    react: {
      version: 'detect'
    }
  }
}
</pre>
<p>还有一些其他不太常用的配置选项，记录在<code>eslint-plugin-react</code>插件的npm页面上。</p>
<h2 id="react-hooks-rules">反应钩子规则(<code>eslint-plugin-react-hooks</code>)</h2>
<p>这个插件只包含两条规则，但是它们对于避免用钩子编写<a href="https://blog.logrocket.com/what-are-react-pure-functional-components/" target="_blank" rel="noopener">函数组件</a>时的常见陷阱是至关重要的。</p>
<h3 id="installation">装置</h3>
<p>从npm安装软件包:</p>
<pre class="language-bash hljs">npm install --save-dev eslint-plugin-react-hooks
</pre>
<p>要使用激活这两个规则的推荐配置，您需要更新您的ESLint配置文件，在<code>plugin:react-hooks/recommended</code>的<code>extends</code>部分添加一个条目:</p>
<pre class="language-javascript hljs">{
  ... other ESLint config
  extends: [
    'eslint:recommended',
    'plugin:react-hooks/recommended'
  ]
}
</pre>
<p>如果您发现违反规则的行为未被标记，请确保您已将此内容包含在<code>extends</code>部分。</p>
<h3 id="react-hooks-rules-of-hooks">反应钩/钩规则</h3>
<p>这条规则强制组件在使用钩子时遵循钩子的<a href="https://reactjs.org/docs/hooks-rules.html" target="_blank" rel="noopener">规则。在</a><a href="https://reactjs.org/docs/hooks-rules.html#explanation" target="_blank" rel="noopener"> React文档</a>中详细讨论了这些规则，但是在使用钩子时有两条规则必须遵守:</p>
<ol>
<li>钩子应该只从组件的顶层代码中调用。这实际上意味着钩子不应该被有条件地调用——它们应该在每次渲染时被调用，以同样的顺序，以避免问题和微妙的错误</li>
<li>钩子只能从一个函数组件或者另一个钩子中调用<ol>
<li>定制钩子经常从内置的，甚至其他定制钩子中组合行为</li>
</ol>
</li>
</ol>
<p>在默认配置中，违反此规则将导致错误，从而导致lint检查失败。</p>
<h3 id="react-hooks-exhaustive-deps">反应-钩子/详尽-deps</h3>
<p>这个规则强制执行关于传递给钩子的<a href="https://reactjs.org/docs/hooks-effect.html#tip-optimizing-performance-by-skipping-effects" target="_blank" rel="noopener">依赖数组</a>的内容的某些规则，比如<code>useEffect</code>、<code>useCallback</code>和<code>useMemo</code>。通常，在效果、回调或记忆值计算中引用的任何值都必须包含在依赖数组中。如果处理不当，可能会导致过时的状态数据或<a href="https://blog.logrocket.com/solve-react-useeffect-hook-infinite-loop-patterns/" target="_blank" rel="noopener">无限渲染循环</a>等问题。</p>
<p>这条规则有助于发现潜在的依赖相关的错误，但是有一些限制:</p>
<ul>
<li>默认情况下，不使用此规则检查带有依赖数组的自定义挂钩。它只适用于内置挂钩。如果您有一个带有依赖数组的定制钩子，那么您可以设置配置选项<code>additionalHooks</code>，它需要一个正则表达式来定义您的定制钩子的名称。React团队一般不建议这样做，正如在<a href="https://github.com/facebook/react/tree/main/packages/eslint-plugin-react-hooks#advanced-configuration"> <code>eslint-plugin-react-hooks</code>自述文件</a>中所讨论的。相反，该团队建议提供更高级别的API。</li>
<li>使用此规则将不检查带有依赖项数组的自定义挂钩。它只适用于内置挂钩</li>
<li>只有当规则是静态值数组时，它才能正确检查依赖关系。如果使用了对另一个数组的引用，或者将另一个数组扩展到该数组中，规则将发出警告，指出它无法确定依赖关系</li>
</ul>
<p>这条规则多少有些争议；GitHub 上有几个<a href="https://github.com/facebook/react/issues?q=is%3Aissue+exhaustive-deps+is%3Aclosed+sort%3Acomments-desc" target="_blank" rel="noopener">长的问题线程，但是React团队在征求和整合反馈方面做得很好。在默认配置中，违反此规则将被视为警告。</a></p>
<p>这条规则的细节可能会占据一整篇文章。要更深入地了解这条规则以及如何正确使用它，请参见LogRocket博客上的<a href="https://blog.logrocket.com/understanding-react-exhaustive-deps-linting-warning" target="_blank" rel="noopener">了解React exhaustive-deps林挺警告</a>一文。</p>
<h2 id="react-rules">反应规则(<code>eslint-plugin-react</code>)</h2>
<p>这个插件包含了更多特定于React核心的规则(在写的时候有100条规则)。大多数规则涵盖一般的React实践，其他规则涵盖与JSX语法相关的问题。让我们来看看一些比较有用的。</p>
<h3 id="installation-configuration">安装和配置</h3>
<p>如前所述，如果你的应用基于Create React App(并使用react-scripts)，那么你已经安装了这个插件。否则，您可以从npm安装它:</p>
<pre class="language-bash hljs">npm install --save-dev eslint-plugin-react
</pre>
<p>要使用推荐的规则集，只需将<code>'plugin:react/recommended'</code>添加到您的ESLint配置的<code>extends</code>部分:</p>
<pre class="language-javascript hljs">{
  ... other ESLint config
  extends: [
    'eslint:recommended',
    'plugin:react/recommended',
    'plugin:react-hooks/recommended'
  ]
}
</pre>
<p>如果您使用React 17或更高版本，此推荐配置包括一些不适用的规则。React的最新版本包括一个新的JSX变换，它不再要求React包含在您的组件中。这意味着您可以在使用JSX时删除<code>import React from</code> <code>'react';</code>等导入。</p>
<p>这将导致ESLint报告React不在范围内的错误(有关更多详细信息，请参见下面的规则<code>react/react-in-jsx-scope</code>)。如果这适用于您的应用程序，您需要将<code>plugin:react/jsx-runtime</code>添加到您的<code>extends</code>列表中:</p>
<pre class="language-javascript hljs">{
  ... other ESLint config
  extends: [
    'eslint:recommended',
    'plugin:react/recommended',
    'plugin:react/jsx-runtime',
    'plugin:react-hooks/recommended'
  ]
}
</pre>
<p>这将禁用相关规则，并防止ESLint将其报告为错误。</p>
<p>现在我们已经安装并配置了插件，让我们来看看一些更有用的插件。</p>
<h3 id="react-button-has-type">反应/按钮类型</h3>
<p>出于可访问性的原因，组件中大多数可点击的元素，不是到另一个URL <a href="https://blog.logrocket.com/building-accessible-glossary-vanilla-javascript/" target="_blank" rel="noopener">的简单链接，应该被实现为按钮</a>。一个常见的错误是，当这些按钮不用于提交表单时，忽略了它们的<code>type</code>属性。</p>
<p>当没有指定<code>type</code>时，按钮默认为<code>submit</code>类型。这可能会导致从<code>form</code>元素派生的按钮出现问题。在表单中单击这样的按钮将导致可能不需要的表单提交。</p>
<p>不打算提交表单的动作按钮应该有一个<code>button</code>的<code>type</code>属性。</p>
<p>这条规则强制所有按钮都显式地拥有一个<code>type</code>属性——即使是那些打算作为<strong>提交</strong>按钮的按钮。通过明确，避免了无意的提交，代码的意图也很清楚。</p>
<h3 id="react-prop-types">反应/推进类型</h3>
<p>要求所有的React组件在一个<code><a href="https://reactjs.org/docs/typechecking-with-proptypes.html" target="_blank" rel="noopener">PropTypes</a></code>声明中描述它们的属性。这些检查只在开发模式中抛出错误，但是可以帮助捕捉由于错误的属性被传递给组件而产生的错误。</p>
<p>如果您的项目使用TypeScript，也可以通过向描述它们的组件属性添加类型批注来满足此规则。</p>
<p>Dillion Megida的<a href="https://blog.logrocket.com/comparing-typescript-and-proptypes-in-react-applications/" target="_blank" rel="noopener">比较React应用程序中的TypeScript和PropTypes</a>中详细介绍了这两种方法。</p>
<h3 id="react-require-default-props">反应/要求-默认-道具</h3>
<p>根据组件的不同，有些道具可能是必需的，而有些是可选的。如果一个可选的道具没有传递给一个组件，它将会是<code>undefined</code>。这可能是意料之中的，但是如果不检查该值，可能会引入错误。</p>
<p>这条规则要求在组件的<code>defaultProps</code>声明中给每个可选属性一个默认值。如果这是组件所期望的，这个缺省值可以被显式地设置为<code>null</code>或<code>undefined</code>。</p>
<p>对于功能组件，有两种不同的策略可用于检查默认属性:</p>
<h4>默认道具</h4>
<p>这个策略期望函数组件有一个默认的<code>defaultProps</code>对象。</p>
<pre class="language-javascript hljs">const MyComponent = ({ action }) =&gt; { ... }

MyComponent.propTypes = {
  Action: PropTypes.string;
};

MyComponent.defaultProps = {
  action: 'init'
};</pre>
<h4>默认参数</h4>
<p>这种策略希望在函数声明中指定默认值，使用JavaScript的内置默认值语法。</p>
<pre class="language-javascript hljs">const MyComponent = ({ action = 'init' }) =&gt; { ... }

MyComponent.propTypes = {
  Action: PropTypes.string;
};</pre>
<p>如果使用<code>defaultArguments</code>策略，就不应该有<code>defaultProps</code>对象。如果有，这个规则就失效了。</p>
<h3 id="react-no-array-index-key">react/no-数组索引键</h3>
<p>当在React中呈现一个项目列表时，我们通常在一个数组上调用<code>map</code>，映射函数返回一个组件。为了跟踪列表中的每一项，React需要这些组件有一个<code>key</code>道具。</p>
<p>呈现列表的一个常见缺陷是使用数组索引作为键。这可能会导致不必要甚至不正确的渲染。React文档<a href="https://reactjs.org/docs/lists-and-keys.html#keys" target="_blank" rel="noopener">建议不要采用这种做法</a>，因为它会导致一些问题(还有一个关于如何使用键的<a href="https://reactjs.org/docs/reconciliation.html#recursing-on-children" target="_blank" rel="noopener">更详细的讨论</a>)。键应该是列表中该项目的唯一标识符，不会改变，就像数据库行中的主键值一样。</p>
<p>该规则确保数组索引不被用作键。</p>
<h3 id="react-jsx-scope">react/在jsx范围内反应</h3>
<p>考虑这个简单的React组件:</p>
<pre class="language-javascript hljs">const Greeter = ({ name }) =&gt; &lt;div&gt;Hello {name}!&lt;/div&gt;;</pre>
<p>根本没有引用<code>React</code>对象。然而，<code>React</code>仍然需要被导入，否则您将遇到一个错误。这是由于JSX的蒸发过程。浏览器不理解JSX，所以在构建过程中(通常使用Babel或TypeScript之类的工具)，JSX元素被转换成有效的JavaScript。</p>
<p>这生成的JavaScript代码调用<code>React.createElement</code>来代替JSX元素。上述组件可能会被转换成类似这样的内容:</p>
<pre class="language-javascript hljs">const Greeter = ({ name }) =&gt; React.createElement("div", null, "Hello ", name, "!");</pre>
<p>这里对<code>React</code>的引用是为什么<code>React</code>仍然必须被导入的原因。这个规则确保所有带有JSX标记的文件(甚至不一定是React组件)都有<code>React</code>(通常通过<code>import</code>或<code>require</code>调用)。</p>
<h3 id="react-jsx-uses-react">react/jsx-uses-react</h3>
<p>总是导入React对于正确的翻译是必要的，但是当ESLint查看文件时，它仍然是JSX，所以它不会在任何地方看到引用的<code>React</code>。如果项目使用了<code>no-unused-vars</code>规则，这会导致一个错误，因为<code>React</code>被导入了，但是没有在任何地方被使用。</p>
<p>该规则捕捉这种情况，并防止<code>no-unused-vars</code>在<code>React</code>导入时失败。</p>
<h3 id="react-display-name">反应/显示名称</h3>
<p>为了正确调试输出，所有React组件都应该有一个显示名称。在许多情况下，这不需要任何额外的代码。如果组件是一个命名函数，显示名称将是该函数的名称。在下面的例子中，组件的显示名称将是<code>MyComponent</code>。</p>
<ul>
<li><code>const MyComponent = () =&gt; { … }</code></li>
<li><code>const MyComponent = function() { return …; }</code></li>
<li><code>export default function MyComponent() { return …; }</code></li>
</ul>
<p>在某些情况下，自动显示名称会丢失。这通常是当组件声明被另一个函数或更高级的组件包装时，如下面的两个示例所示:</p>
<ul>
<li><code>const MyComponent = React.memo(() =&gt; { … });</code></li>
<li><code>const MyComponent = React.forwardRef((props, ref) =&gt; { … });</code></li>
</ul>
<p><code>MyComponent</code>名称被绑定到由<code>memo</code>和<code>forwardRef</code>返回的新的“外部”组件。组件本身现在没有显示名称，这将导致此规则失败。</p>
<p>当出现这些情况时，可以通过<code>displayName</code>属性手动指定显示名称，以满足规则:</p>
<pre class="language-javascript hljs">const MyComponent = React.memo(() =&gt; { ... });
MyComponent.displayName = 'MyComponent';</pre>
<h3>反应/无儿童道具</h3>
<p>React组件接受一个名为<code>children</code>的特殊道具。这个属性的值将是元素的开始和结束标记中的任何内容。考虑这个简单的<code>MyList</code>组件:</p>
<pre class="language-javascript hljs">const MyList = ({ children }) =&gt; {
  return &lt;ul&gt;{children}&lt;/ul&gt;;
};</pre>
<p>这将呈现外部的<code>ul</code>元素，我们放入该元素的任何子元素都将呈现在其中。</p>
<pre class="language-javascript hljs">&lt;MyList&gt;
  &lt;li&gt;item1&lt;/li&gt;
  &lt;li&gt;item2&lt;/li&gt;
&lt;/MyList&gt;</pre>
<p>这是React组件的首选模式。虽然不建议这样做，但是可以将子对象作为显式子属性传递:</p>
<pre class="language-javascript hljs">&lt;MyList children={&lt;li&gt;item1&lt;/li&gt;&lt;li&gt;item2&lt;/li&gt;} /&gt;</pre>
<p>上述用法实际上会导致错误，因为JSX表达式，像作为显式子属性传递的表达式一样，必须有一个根元素。这就要求孩子们被包裹在一个片段里:</p>
<pre class="language-javascript hljs">&lt;MyList children={&lt;&gt;&lt;li&gt;item1&lt;/li&gt;&lt;li&gt;item2&lt;/li&gt;&lt;/&gt;} /&gt;</pre>
<p>如第一个示例所示，子元素作为子元素直接传递给组件，因此组件是表达式的根元素。这里不需要片段或其他封闭元素。</p>
<p>这主要是一种风格上的选择/模式，但它确实可以防止无意中传递显式的<code>children</code> prop和子元素:</p>
<pre class="language-javascript hljs">&lt;MyList children={&lt;&gt;&lt;li&gt;item1&lt;/li&gt;&lt;li&gt;item2&lt;/li&gt;&lt;/&gt;}&gt;
  &lt;li&gt;item3&lt;/li&gt;
  &lt;li&gt;item4&lt;/li&gt;
&lt;/MyList&gt;</pre>
<p>在这种情况下，子元素(<code>item3</code>和<code>item4</code>)会被显示，但是<code>item1</code>和<code>item2</code>不会。这个规则确保子元素只以惯用的方式传递，作为子JSX元素。</p>
<h3 id="react-no-danger-with-children">对儿童有反应/无危险</h3>
<p>React的<code>dangerouslySetInnerHTML</code>属性允许将任意标记设置为元素的<code>innerHTML</code>属性。通常不建议这样做，因为这可能会将您的应用程序暴露给跨站点脚本(XSS)攻击。然而，如果您知道您可以信任输入，并且用例需要它，那么这种方法可能是必要的。</p>
<p>prop需要一个带有<code>__html</code>属性的对象，其值是一个原始的HTML字符串。该字符串将被设置为<code>innerHTML</code>。</p>
<p>因为这会替换任何现有的子内容，所以将它与<code>children</code> prop结合使用是没有意义的。事实上，如果您尝试这样做，React将会抛出一个错误。不像一些只在开发模式下出现的错误(像<code>PropTypes</code>验证错误)，这个错误会让你的应用崩溃。</p>
<p>该规则实施相同的规则。如果<code>dangerouslySetInnerHTML</code>用于子节点，lint规则将失效。最好在林挺或构建时捕获这些错误，而不是在应用程序部署后由用户报告！</p>
<h3 id="react-jsx-no-bind">react/jsx-no-bind</h3>
<p>每次渲染React组件时，都要付出性能代价。通常，某些模式或实践会导致组件不必要地重新呈现自身。这种行为有许多原因，这条规则有助于防止其中之一。</p>
<p>当组件内部定义了任何函数时，它将是每次渲染的一个新的函数对象。这意味着无论何时组件被重新渲染，道具都被认为是改变了的。即使有了<code>React.memo</code>，组件也会重新渲染。</p>
<p>如果子组件有任何将该函数作为依赖项的<code>useEffect</code>调用，这可能会导致效果再次运行，从而产生无限循环的可能性，这可能会冻结浏览器。</p>
<p>启用此规则后，任何作为属性传递的函数都将被标记。</p>
<p>有两种方法可以解决这个问题。如果函数不依赖于组件内部的任何其他东西，它可以被移到组件外部，在那里它只是一个普通的函数，将始终是同一个内存引用。这确保了每次都将相同的函数传递给prop。</p>
<p>对于函数<em>在某种程度上依赖于组件的情况，通常的解决方法是用<code><a href="https://reactjs.org/docs/hooks-reference.html#usecallback" target="_blank" rel="noopener">useCallback</a></code>钩子来记忆它。函数中引用的任何属性都必须包含在<code>useCallback</code>依赖数组中；有时这需要多层次的价值或功能记忆。</em></p>
<p>这增加了一些复杂性，但有助于减少额外的渲染和防止无限循环。</p>
<h2>包扎</h2>
<p>这里涉及的规则只是由<code>eslint-plugin-react</code>插件提供的一些规则。有些规则可能固执己见或过于热心，但大多数规则也有配置选项来使它们不那么严格。</p>
<p>还有另一个非常有用的ESLint插件，围绕JSX和可访问性实践:<code><a href="https://www.npmjs.com/package/eslint-plugin-jsx-a11y" target="_blank" rel="noopener">eslint-plugin-jsx-a11y</a></code>。这个插件中的规则检查你的JSX标记，以确保良好的HTML可访问性实践得到遵循。</p>
<p>这些React ESLint插件有助于避免常见的陷阱，尤其是如果您还是React新手的话。您甚至可以编写自己的规则和插件来涵盖其他情况！</p><div class="code-block code-block-17">
<div class="blog-plug inline-plug react-plug" vwo-el-id="26283398190">
<h2 vwo-el-id="41600691720"><a href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener"> LogRocket </a>:全面了解您的生产React应用</h2><p>调试React应用程序可能很困难，尤其是当用户遇到难以重现的问题时。如果您对监视和跟踪Redux状态、自动显示JavaScript错误以及跟踪缓慢的网络请求和组件加载时间感兴趣，</p><a href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" vwo-el-id="19356441070">try LogRocket</a><p>. </p><a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="19356441380">
<img class="first-react-image alignnone size-full wp-image-46 jetpack-lazy-image jetpack-lazy-image--handled" src="../Images/f300c244a1a1cf916df8b4cb02bec6c6.png" vwo-el-id="18272717540" data-lazy-loaded="1" data-original-src="https://files.readme.io/27c94e7-Image_2017-06-05_at_9.46.04_PM.png"/>
</a>
<a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="19356441690">
<img class="second-react-image alignnone size-full wp-image-46 jetpack-lazy-image jetpack-lazy-image--handled" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" vwo-el-id="30720362350" data-lazy-loaded="1" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/>
</a>
<p vwo-el-id="28675660440" class="">LogRocket 结合了会话回放、产品分析和错误跟踪，使软件团队能够创建理想的web和移动产品体验。这对你来说意味着什么？</p>
<p>LogRocket不是猜测错误发生的原因，也不是要求用户提供截图和日志转储，而是让您回放问题，就像它们发生在您自己的浏览器中一样，以快速了解哪里出错了。</p>
<p>不再有嘈杂的警报。智能错误跟踪允许您对问题进行分类，然后从中学习。获得有影响的用户问题的通知，而不是误报。警报越少，有用的信号越多。</p>
<p vwo-el-id="28675660750">LogRocket Redux中间件包为您的用户会话增加了一层额外的可见性。LogRocket记录Redux存储中的所有操作和状态。</p>
<p vwo-el-id="28675661060">现代化您调试React应用的方式— <a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="40093418840">开始免费监控</a>。</p>
</div></div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
<html>
<head>
<title>Using axios.all to make concurrent requests - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>使用 axios.all 进行并发请求</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/using-axios-all-make-concurrent-requests/#0001-01-01">https://blog.logrocket.com/using-axios-all-make-concurrent-requests/#0001-01-01</a></blockquote><div><article class="article-post">
 <p><code>axios.all</code>是 Axios 内置的一个助手方法，用来处理并发请求。<code>axios.all</code>方法允许我们一起向端点发出多个 HTTP 请求，而不是分别发出多个 HTTP 请求。</p>
<p><code>axios.all</code>函数接受一个必须是承诺的 iterable 对象，比如一个 JavaScript 数组，它返回一个响应数组。</p>
<p>在这篇文章中，我们将学习如何使用<code>axios.all</code>函数发出 HTTP 请求，使用<code>Promise.all</code>和<code>axios.all</code>的区别，以及在 Axios 中发出并发 API 请求。</p>
<h2>使用<code>axios.all</code></h2>
<p>为了开始使用<code>axios.all</code>方法，让<a href="https://blog.logrocket.com/how-to-make-http-requests-like-a-pro-with-axios/">向以下端点发出一个 HTTP 请求</a>:</p>
<pre>let endpoints = [
  'https://api.github.com/users/ejirocodes',
  'https://api.github.com/users/ejirocodes/repos',
  'https://api.github.com/users/ejirocodes/followers',
  'https://api.github.com/users/ejirocodes/following'
];

axios.all(endpoints.map((endpoint) =&gt; axios.get(endpoint))).then(
  (data) =&gt; console.log(data),
);
</pre>
<p>这里，我们声明了一个端点数组，我们称之为<code>endpoints</code>，并在 Axios 实例上调用<code>.all</code>方法。这映射通过端点数组中的每个项目。然后，在 Axios 实例上使用<code>GET</code>方法向我们的端点列表发出请求，我们从服务器获得每个响应。</p>
<p>该请求返回一个数组作为响应，数组中的数据根据我们的<code>endpoints</code>数组排序，这意味着 Axios 必须首先从以下端点获取数据:</p>
<pre>https://api.github.com/users/ejirocodes
</pre>
<p>然后，从端点返回的最后数据如下:</p>
<pre>https://api.github.com/users/ejirocodes/following
</pre>
<p>现在，让我们打开浏览器开发人员控制台和网络选项卡，确认 API 响应的顺序。</p>
<p><img data-attachment-id="75858" data-permalink="https://blog.logrocket.com/using-axios-all-make-concurrent-requests/console-tab-2/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2021/10/console-tab.png" data-orig-size="730,175" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="console-tab" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2021/10/console-tab-300x72.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2021/10/console-tab.png" decoding="async" class="size-full wp-image-75858 aligncenter jetpack-lazy-image" src="../Images/b1ae256d35a18a8bd95b4ee4e805c948.png" alt="console tab" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2021/10/console-tab.png 730w, https://blog.logrocket.com/wp-content/uploads/2021/10/console-tab-300x72.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2021/10/console-tab.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2021/10/console-tab.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="75858" data-permalink="https://blog.logrocket.com/using-axios-all-make-concurrent-requests/console-tab-2/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2021/10/console-tab.png" data-orig-size="730,175" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="console-tab" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2021/10/console-tab-300x72.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2021/10/console-tab.png" decoding="async" loading="lazy" class="size-full wp-image-75858 aligncenter" src="../Images/b1ae256d35a18a8bd95b4ee4e805c948.png" alt="console tab" srcset="https://blog.logrocket.com/wp-content/uploads/2021/10/console-tab.png 730w, https://blog.logrocket.com/wp-content/uploads/2021/10/console-tab-300x72.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2021/10/console-tab.png"/></noscript>
<p><img data-attachment-id="75860" data-permalink="https://blog.logrocket.com/using-axios-all-make-concurrent-requests/network-tab-3/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2021/10/network-tab.png" data-orig-size="730,144" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="network-tab" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2021/10/network-tab-300x59.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2021/10/network-tab.png" decoding="async" class="size-full wp-image-75860 aligncenter jetpack-lazy-image" src="../Images/265a8976afc2240e9c13744eb352fff6.png" alt="network tab" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2021/10/network-tab.png 730w, https://blog.logrocket.com/wp-content/uploads/2021/10/network-tab-300x59.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2021/10/network-tab.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2021/10/network-tab.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="75860" data-permalink="https://blog.logrocket.com/using-axios-all-make-concurrent-requests/network-tab-3/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2021/10/network-tab.png" data-orig-size="730,144" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="network-tab" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2021/10/network-tab-300x59.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2021/10/network-tab.png" decoding="async" loading="lazy" class="size-full wp-image-75860 aligncenter" src="../Images/265a8976afc2240e9c13744eb352fff6.png" alt="network tab" srcset="https://blog.logrocket.com/wp-content/uploads/2021/10/network-tab.png 730w, https://blog.logrocket.com/wp-content/uploads/2021/10/network-tab-300x59.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2021/10/network-tab.png"/></noscript>
<p>您可能会考虑坚持使用常规的<code>GET</code>方法分别发出多个 API 请求。但是，不像<code>axis.get</code>方法，如果一个承诺解决或拒绝，它不会影响其他人。使用<code>axios.all</code>方法，如果我们的一个承诺失败了，整个请求就失败了。</p>
<p>这意味着当我们使用<code>axios.all</code>时，为了从我们的端点获得成功的响应，所有的请求必须是成功的。</p>
<p>现在让我们通过添加<code>axios.spead</code>方法来重构我们的代码。该方法接受回调，并可以析构我们的响应数组，这使得我们的代码更具可读性:</p>
<pre>let endpoints = [
  'https://api.github.com/users/ejirocodes',
  'https://api.github.com/users/ejirocodes/repos',
  'https://api.github.com/users/ejirocodes/followers',
  'https://api.github.com/users/ejirocodes/following'
];

axios.all(promises.map((promise) =&gt; axios.get(promise))).then(
  axios.spread((user, repos, followers, following) =&gt; {
    console.log({ user, repos, followers, following });
  })
);
</pre>
<p>注意<code>axios.spread</code> helper 函数是多么有用:我们可以用它一次性获得所有数据，然后在回调中使用它。</p>
<p>通过这样调用<code>axios.spread((user, repos, followers, following)</code>，我们可以说我们想要命名 Axios 调用的第一个响应，<code>user</code>和<code>repo</code>。</p>
<p>现在，让我们把我们在顶部的东西带得更远一点；让我们取出将由服务器发送的<a href="https://github.com/axios/axios#response-schema">数据对象:</a></p>
<pre>axios.all(endpoints.map((endpoint) =&gt; axios.get(endpoint))).then(
  axios.spread(({data: user}, {data:repos}, {data:followers}, {data:following}) =&gt; {
    console.log({ user, repos, followers, following });
  })
);
</pre>
<p>我们可以用<a href="https://github.com/axios/axios#response-schema"> Axios 的响应模式</a>为每个包含以下数据对象的请求做这件事，这是服务器提供的响应。</p>
<p>所以本质上，我们使用对象析构来解包值，也就是说，将响应对象中的<code>data</code>解包成不同的变量，比如<code>user</code>、<code>repos</code>、<code>followers</code>和<code>following</code>。</p>
<p>另外，请注意，我们正在从每个响应中析构数据，并分别将其重命名为<code>user</code>、<code>repos</code>、<code>followers</code>和<code>following</code>。</p>
<h2><code>Promise.all</code>对<code>axios.all</code></h2>
<p>截至<a href="https://github.com/axios/axios/blob/76f09afc03fbcf392d31ce88448246bcd4f91f8c/CHANGELOG.md#0200-pre-july-15-2020">2020 年 7 月 15 日</a>，Axios 更新了其<a href="https://github.com/axios/axios#concurrency-deprecated"> GitHub 自述</a>文件，反映<code>axios.all</code> helper 方法已被弃用，<a href="https://blog.logrocket.com/understanding-promise-all-in-javascript/">应替换为</a> <code><a href="https://blog.logrocket.com/understanding-promise-all-in-javascript/">Promise.all</a></code>。</p>
<p>既然有一个<a href="https://github.com/axios/axios/issues/1042">非官方的提议要在 Axios 版本 1 中完全去掉</a> <code><a href="https://github.com/axios/axios/issues/1042">axios.all</a></code> <a href="https://github.com/axios/axios/issues/1042">和</a> <code><a href="https://github.com/axios/axios/issues/1042">axios.spread</a></code> <a href="https://github.com/axios/axios/issues/1042">方法</a>，那么让我们来看看如何使用像<code>Promise.all</code>和 ES6 参数析构这样的原生 JavaScript 特性来废除<code>axios.all</code>方法。</p>
<p>请注意，只有单据提供折旧，而不是代码库/库。因此，<code>axios.all</code>在最新版本的 Axios 中仍然有效，许多开发人员仍然在现代代码库中使用<code>axios.all</code>。指出这种贬值是因为预计<code>axios.all</code>会在未来的某个时候被取代。</p>
<p>然而，此时我们应该考虑一件重要的事情。<code>axios.all</code>是用 JavaScript 中的<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/all">原生</a> <code><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/all">Promise.all</a></code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/all">方法构建的助手方法。这意味着我们可以很容易地用<code>promise.all</code>代替<code>axios.all</code>方法。</a></p>
<p><code>Promise.all</code>方法返回一个承诺，当 iterable 参数中的所有承诺都解析时，该承诺也解析。</p>
<p>现在，让我们来看看实际情况:</p>
<pre>let endpoints = [
  'https://api.github.com/users/ejirocodes',
  'https://api.github.com/users/ejirocodes/repos',
  'https://api.github.com/users/ejirocodes/followers',
  'https://api.github.com/users/ejirocodes/following'
];

// Return our response in the allData variable as an array
Promise.all(endpoints.map((endpoint) =&gt; axios.get(endpoint))).then(
  axios.spread((...allData) =&gt; {
    console.log({ allData });
  })
);
</pre>
<p>上面的代码给出了与使用<code>axios.all</code>方法相同的结果。</p>
<p>注意，即使我们已经摆脱了<code>axios.all</code>方法，我们仍然在使用<code>axios.spread</code>助手；ES6 析构操作符可以很容易地替换它。</p>
<p>还要注意，我们同时使用数组和对象析构来提取服务器发送的数据对象:</p>
<pre>Promise.all(endpoints.map((endpoint) =&gt; axios.get(endpoint))).then(([{data: user}, {data: repos}, {data: followers}, {data: following}] )=&gt; {
      console.log({ user, repos, followers, following });
});
</pre>
<p>瞧啊。我们已经成功地使用本地 JavaScript 方法发出了一个并发 HTTP 请求。</p>
<h2>并发 API 请求与<code>Promise.all</code>和 Axios 发生反应</h2>
<p>要使用 Axios 和<code>Promise</code>在 React 应用程序中同时发出 API 请求，我们必须使用 React 钩子。</p>
<p>在这个例子中，我们将获得 GitHub 配置文件的关注者和关注数据。这个想法是，如果由于某种原因，API 对用户 GitHub 概要文件的<code>followers</code>数据的请求不成功，我们就无法获得对用户 GitHub 概要文件的<code>followers</code>数据的响应。</p>
<p>这意味着在计数之后请求用户的 GitHub 用户配置文件也将失败。</p>
<p>这是因为当我们发出并发请求时，一个请求的响应依赖于另一个请求。因此，本质上，如果至少有一个请求失败，我们希望两个或所有请求都失败。</p>
<p><img data-attachment-id="75862" data-permalink="https://blog.logrocket.com/using-axios-all-make-concurrent-requests/github-profile-followers-following/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2021/10/GitHub-profile-followers-following.png" data-orig-size="730,506" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="GitHub-profile-followers-following" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2021/10/GitHub-profile-followers-following-300x208.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2021/10/GitHub-profile-followers-following.png" decoding="async" class="size-full wp-image-75862 aligncenter jetpack-lazy-image" src="../Images/7df19a397187df86c03aa403185a9caa.png" alt="Github followers and following " data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2021/10/GitHub-profile-followers-following.png 730w, https://blog.logrocket.com/wp-content/uploads/2021/10/GitHub-profile-followers-following-300x208.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2021/10/GitHub-profile-followers-following.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2021/10/GitHub-profile-followers-following.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="75862" data-permalink="https://blog.logrocket.com/using-axios-all-make-concurrent-requests/github-profile-followers-following/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2021/10/GitHub-profile-followers-following.png" data-orig-size="730,506" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="GitHub-profile-followers-following" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2021/10/GitHub-profile-followers-following-300x208.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2021/10/GitHub-profile-followers-following.png" decoding="async" loading="lazy" class="size-full wp-image-75862 aligncenter" src="../Images/7df19a397187df86c03aa403185a9caa.png" alt="Github followers and following " srcset="https://blog.logrocket.com/wp-content/uploads/2021/10/GitHub-profile-followers-following.png 730w, https://blog.logrocket.com/wp-content/uploads/2021/10/GitHub-profile-followers-following-300x208.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2021/10/GitHub-profile-followers-following.png"/></noscript>
<p>使用<code>Promise.all</code>和 ES6 析构，让我们编写一个函数，在 React 应用程序中同时执行多个<code>GET</code>请求:</p>
<pre>// In our component, we have to save both data in our state using the useState hook
  const [followers, setFollowers] = useState([])
  const [followings, setFollowing] = useState([])

  const getGithubData = () =&gt; {
    let endpoints = [
      'https://api.github.com/users/ejirocodes',
      'https://api.github.com/users/ejirocodes/repos',
      'https://api.github.com/users/ejirocodes/followers',
      'https://api.github.com/users/ejirocodes/following'
    ];
    Promise.all(endpoints.map((endpoint) =&gt; axios.get(endpoint))).then(([{data: user}, {data: repos}, {data: followers}, {data: followings}] )=&gt; {
      setFollowers(followers)
      setFollowing(followings)
    });
  }
</pre>
<p>接下来，让我们在页面加载时调用函数。为了实现这种反应过来的方式，<a href="https://blog.logrocket.com/guide-to-react-useeffect-hook/">我们将使用</a> <a href="https://blog.logrocket.com/guide-to-react-useeffect-hook/"> <code>useEffect</code>钩子</a>:</p>
<pre>// remember to import useEffect from react
  useEffect(() =&gt; {
    getGithubData();
  }, []);
</pre>
<p>然后，将追随者和我们刚刚从各个端点接收到的数据呈现到 DOM:</p>
<pre>// Wherever your return statement is in your React app
      &lt;section style={{ display: 'flex' }}&gt;
          &lt;section&gt;
            &lt;h2&gt;Followers&lt;/h2&gt;
            {followers.length &gt; 0 &amp;&amp; (
              &lt;div&gt;
                {followers.map((follower) =&gt; (
                  &lt;div key={follower.id}&gt;
                    &lt;img src={follower.avatar_url} alt={follower.html_url} /&gt;
                    &lt;p&gt;GitHub Profile: {follower.html_url}&lt;/p&gt;
                  &lt;/div&gt;
                ))}
              &lt;/div&gt;
            )}
          &lt;/section&gt;
          &lt;section&gt;
            &lt;h2&gt;Following&lt;/h2&gt;
            {followings.length &gt; 0 &amp;&amp; (
              &lt;div&gt;
                {followings.map((following) =&gt; (
                  &lt;div key={following.id}&gt;
                    &lt;img src={following.avatar_url} alt={following.html_url} /&gt;
                    &lt;p&gt;GitHub Profile: {following.html_url}&lt;/p&gt;
                  &lt;/div&gt;
                ))}
              &lt;/div&gt;
            )}
          &lt;/section&gt;
        &lt;/section&gt;
</pre>
<h2>结论</h2>
<p>在本文中，我们介绍了如何使用<code>axios.all</code>方法生成并发的<a href="https://blog.logrocket.com/using-axios-all-make-concurrent-requests/"> HTTP 请求</a>，该方法构建在底层的<code>Promise.all</code> JavaScript 方法之上。</p>
<p>我们还看到了如何使用<code>axios.spread</code> helper 函数解包我们的响应数组，以及如何用 ES6 参数析构来替换它，特别是数组和对象析构方法。</p>
<p>最后，我们讨论了如何在 React 中使用钩子通过 Axios 和原生 JavaScript <code>Promise.all</code>方法发出并发 API 请求。</p>
<p>如果你想看源代码，我在 GitHub 上创建了一个库，包含了我们在这篇文章中提到的所有方法。</p>
<p>暂时就这样吧！请在下面的评论区告诉我你对这篇文章的看法。我在 Twitter 和 LinkedIn 上社交。感谢您的阅读，敬请期待更多内容。</p><div class="code-block code-block-27">
<div class="blog-plug inline-plug vanilla-javascript-cta"><h2>通过理解上下文，更容易地调试 JavaScript 错误</h2>
<p>调试代码总是一项单调乏味的任务。但是你越了解自己的错误，就越容易改正。</p>
<p>LogRocket 让你以新的独特的方式理解这些错误。我们的前端监控解决方案跟踪用户与您的 JavaScript 前端的互动，让您能够准确找出导致错误的用户行为。</p>
<a href="https://lp.logrocket.com/blg/javascript-signup" class="signup" target="_blank" rel="noopener noreferrer"><img class="alignnone size-full wp-image-46 jetpack-lazy-image" src="../Images/cbfed9be3defcb505e662574769a7636.png" alt="LogRocket Dashboard Free Trial Banner" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2020/06/reproduce-javascript-errors.gif?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/06/reproduce-javascript-errors.gif"/><noscript><img data-lazy-fallback="1" class="alignnone size-full wp-image-46" src="../Images/cbfed9be3defcb505e662574769a7636.png" alt="LogRocket Dashboard Free Trial Banner" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/06/reproduce-javascript-errors.gif"/></noscript></a>
<p>LogRocket 记录控制台日志、页面加载时间、堆栈跟踪、慢速网络请求/响应(带有标题+正文)、浏览器元数据和自定义日志。理解您的 JavaScript 代码的影响从来没有这么简单过！</p>
<a class="signup" href="https://lp.logrocket.com/blg/javascript-signup" target="_blank" rel="noopener noreferrer">Try it for free</a><p>.</p></div>


</div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>
 
</div>    
</body>
</html>
# 为你的 Flutter 应用选择正确的数据库

> 原文：<https://blog.logrocket.com/choosing-right-database-flutter-application/>

我们都同意，在移动应用程序开发生命周期的某些点上，我们会考虑存储和利用数据。这就是数据库派上用场的地方。

## 什么是数据库？

数据库是一种以结构化方式存储和使用电子信息(数据)或数据持久性的软件。与缓存相比，数据被可靠地存储(持久化)并可供使用，除非被有意擦除。

数据库允许开发人员使用编程语言或 API 来保存、读取、修改和删除数据库中的数据。这些活动在应用程序的后台执行，远离最终用户的视线。

CRUD 是最常见的数据库交互的同义词，它代表创建、读取、更新和删除。

## 数据库的类型

就本主题而言，我们将主要关注可用于移动技术的两种类型的数据库。数据库可以基于许多因素进行分类，这些因素包括它们支持的数据类型、它们如何扩展、它们如何定义以及它们的存储位置。

有很多数据库，但我们将坚持使用这两个:

*   非关系数据库(NoSQL)
*   关系数据库(SQL)

在本指南中，我们将探索 Flutter 中的数据库类型，并介绍如何在最短的时间内建立它们。

## SQL/关系数据库

[关系数据库](https://aws.amazon.com/relational-database/)是具有相互链接的关系和值的数据集。它们通常是由行和列组成的一组数据库表。它们保存关于一个对象的信息，并且每个表充当所表示的对象的蓝图。数据库中的每一列都保存与特定类型相关的数据，字段保存属性的精确值。

表中的行表示单个数据项的一组相关值。主键是分配给表中每一行的独特标识符，而外键用于链接数据库中其他表的行。

在不改变数据库表的情况下，可以以多种方式访问这些数据。

### sqlite

SQL，也称为关系数据库，它是任何技术堆栈中最受认可的数据库类型之一。让我们看看 Flutter 是如何执行 SQL 的。

sqflite 基本上是 SQLite 的一个实现。它为我们提供了许多功能，使我们能够完全控制我们的数据库，并帮助我们编写查询、关系和我们的应用程序所需的其他数据库功能。

让我们看看如何在我们的应用程序中根据[官方颤振插件页面](https://pub.dev/packages/sqflite)进行设置。

为了使用这个包，我们需要在我们的`pubspec`文件中添加依赖项，如安装页面所示:

```
// Get a location using getDatabasesPath
var databasesPath = await getDatabasesPath();
String path = join(databasesPath, 'demo.db');
// Delete the database
await deleteDatabase(path);
// open the database
Database database = await openDatabase(path, version: 1,
    onCreate: (Database db, int version) async {
  // When creating the db, create the table
  await db.execute(
      'CREATE TABLE Test (id INTEGER PRIMARY KEY, name TEXT, value INTEGER, num REAL)');
});
// Insert some records in a transaction
await database.transaction((txn) async {
  int id1 = await txn.rawInsert(
      'INSERT INTO Test(name, value, num) VALUES("some name", 1234, 456.789)');
  print('inserted1: $id1');
  int id2 = await txn.rawInsert(
      'INSERT INTO Test(name, value, num) VALUES(?, ?, ?)',
      ['another name', 12345678, 3.1416]);
  print('inserted2: $id2');
});
// Update some record
int count = await database.rawUpdate(
    'UPDATE Test SET name = ?, value = ? WHERE name = ?',
    ['updated name', '9876', 'some name']);
print('updated: $count');
// Get the records
List<Map> list = await database.rawQuery('SELECT * FROM Test');
List<Map> expectedList = [
  {'name': 'updated name', 'id': 1, 'value': 9876, 'num': 456.789},
  {'name': 'another name', 'id': 2, 'value': 12345678, 'num': 3.1416}
];
print(list);
print(expectedList);
assert(const DeepCollectionEquality().equals(list, expectedList));
// Count the records
count = Sqflite
    .firstIntValue(await database.rawQuery('SELECT COUNT(*) FROM Test'));
assert(count == 2);
// Delete a record
count = await database
    .rawDelete('DELETE FROM Test WHERE name = ?', ['another name']);
assert(count == 1);
// Close the database
await database.close();

```

我们刚才所做的是为我们的数据库创建一个定义的路径和存储名称，它将作为我们设备上的数据库位置。之后，我们利用`Database`类实例来打开我们的数据库，这为我们提供了一些功能，包括:

`onCreate`:这里我们要定义数据库创建时的逻辑
`OnOpen`:数据库打开时运行的代码

我们还将数据插入数据库，并在控制台上打印出结果。随后，我们还可以看到如何更新、删除和查询数据，并最终关闭我们的数据库。

### 漂流

Drift 以前被称为 Moor，是一个用于 Flutter 和 Dart 的反应式持久性库，构建于 SQLite 之上。

它更像是 SQLite 包的包装器，为我们提供了编写结构化关系数据库查询所需的相同功能和工具，而且它还需要时间来减少在传统 SQlite 场景中遇到的样板文件。

Moor 数据库的主要优点是它可以和 build_runner 一起使用。你可以在这里找到更多关于 build_runner 的信息。使用 build_runner 和 Moor，您不必手动输入所有的查询。您只需创建一个类，指定您希望作为类中的字段的行和列，并让代码生成使用 build_runner 生成所需的数据库初始化代码。

为了使用 Drift，你必须将它添加到你的`pubspec`文件中，并运行命令`flutter pub get`来获取你的依赖项，正如这里的[文档中所写的](https://drift.simonbinder.eu/docs/getting-started/):

```
/////
//// For more information on using drift, please see https://drift.simonbinder.eu/docs/getting-started/
import 'package:drift/drift.dart';
import 'package:drift/native.dart';
part 'main.g.dart';
class TodoItems extends Table {
  IntColumn get id => integer().autoIncrement()();
  TextColumn get title => text()();
  TextColumn get content => text().nullable()();
}
@DriftDatabase(tables: [TodoItems])
class Database extends _$Database {
  Database(QueryExecutor e) : super(e);
  @override
  int get schemaVersion => 1;
  @override
  MigrationStrategy get migration {
    return MigrationStrategy(
      onCreate: (m) async {
        await m.createAll();
        // Add a bunch of default items in a batch
        await batch((b) {
          b.insertAll(todoItems, [
            TodoItemsCompanion.insert(title: 'A first entry'),
            TodoItemsCompanion.insert(
              title: 'Todo: Checkout drift',
              content: const Value('Drift is a persistence library for Dart '
                  'and Flutter applications.'),
            ),
          ]);
        });
      },
    );
  }
  // The TodoItem class has been generated by drift, based on the TodoItems
  // table description.
  //
  // In drift, queries can be watched by using .watch() in the end.
  // For more information on queries, see https://drift.simonbinder.eu/docs/getting-started/writing_queries/
  Stream<List<TodoItem>> get allItems => select(todoItems).watch();
}
Future<void> main() async {
  // Create an in-memory instance of the database with todo items.
  final db = Database(NativeDatabase.memory());
  db.allItems.listen((event) {
    print('Todo-item in database: $event');
  });
  // Add another entry
  await db
      .into(db.todoItems)
      .insert(TodoItemsCompanion.insert(title: 'Another entry added later'));
  // Delete all todo items
  await db.delete(db.todoItems).go();
/////

```

以下是使用 Moor(漂移)的几个要点:

它产生强类型的结果，这减少了运行时出错的机会。它还集成了代码生成，以处理编写查询时涉及的大部分繁重工作。此外，它功能丰富，在 Android、iOS、MacOS、web、桌面和 Linux 上都受支持。

要广泛阅读关于漂移的内容，你可以在这里浏览他们的[官方文档网站。](https://drift.simonbinder.eu/docs/getting-started/)

### 地板

受 Room persistence 包的启发，Floor 为您的 Flutter 应用程序提供了一个很好的 SQLite 抽象。它提供了内存对象和数据库行之间的自动映射，以及通过 SQL 对数据库的完全控制。因此，要充分利用 Floor 的功能，需要彻底掌握 SQL 和 SQLite。

为了使用地板，基本上需要采取六个步骤:

1.  添加所需依赖项:///
    依赖项:
    flutter:
    SDK:flutter
    floor:^1.2.0
    dev*依赖项:
    floor*generator:^1.2.0
    build _ runner:^2.1.2
    ///
2.  创建一个实体
    我们的实体只是一个标有`@entity`注释的类，是我们希望我们的数据库表看起来像什么的表示或蓝图://entity/person . dart
    import ' package:floor/floor . dart '；
    @实体
    类人{
    @ primary key
    final int id；
    最终字符串名称；
    人(this.id，this . name)；
    }
    ///
3.  创建 DAO(数据访问对象)

数据访问对象只是让我们访问底层的 SQLite 数据库。它有一个抽象类，定义了我们需要使用的方法签名，它们都返回一个`Future`或`Stream`:

```
// dao/person_dao.dart
import 'package:floor/floor.dart';
@dao
abstract class PersonDao {
  @Query('SELECT * FROM Person')
  Future<List<Person>> findAllPersons();
  @Query('SELECT * FROM Person WHERE id = :id')
  Stream<Person?> findPersonById(int id);
  @insert
  Future<void> insertPerson(Person person);
}
///

```

1.  创建数据库:///
    // database.dart
    //所需包导入
    导入‘dart:async’；
    导入' package:floor/floor . dart '；
    导入' package:sqflite/sqflite.dart '为 sqf lite；
    导入'道/人 _ 道.镖'；
    导入' entity/person . dart '；
    part ' database . g . dart '；//生成的代码会在那里
    @Database(版本:1，实体:[Person])
    抽象类 AppDatabase 扩展 floor Database {
    Person Dao get Person Dao；
    }
    //
2.  运行代码生成器
    用`Flutter packages pub run build_runner build`运行生成器。要自动运行它，每当文件改变时，使用`flutter packages pub run build_runner watch`。
3.  使用生成的代码
    任何时候你需要访问你的数据库的实例，使用生成的`$FloorAppDatabase`类，它为我们提供对数据库的访问。该名称由`$Floor`和数据库类名组成。传递给`databaseBuilder()`的字符串将是数据库文件名。为了初始化数据库，调用`build()`并确保等待结果。

为了检索`PersonDao`实例，调用数据库实例上的`personDao` getter 就足够了。其功能如下所示:

```
final database = await $FloorAppDatabase.databaseBuilder('app_database.db').build();
final personDao = database.personDao;
final person = Person(1, 'Frank');
await personDao.insertPerson(person);
final result = await personDao.findPersonById(1);
///

```

要了解更多关于 Floor 的信息，你可以点击这里查看官方的回购示例。

## NoSQL/非关系数据库

这与关系数据库略有不同，在非关系数据库中，数据以非表格形式存储。存储基于类似结构化文档的格式，可以在存储各种数据格式的同时处理详细信息。

当谈到 Flutter 中的 NoSQL 数据库时，有几个非常有前途的选项可以考虑，其中最受欢迎的是 Google Firebase，这是一个在线利用云存储的工具，我们还有其他用户定制的选项，如 Objectbox、Hive 和 SharedPreferences。

* * *

### 更多来自 LogRocket 的精彩文章:

* * *

### 重火力点

要了解更多关于 Firebase 的详细信息，并接触他们的代码实验室，你可以点击这里的前往 [FlutterFire 概述页面。](https://firebase.flutter.dev/docs/overview/)

我个人喜欢使用 Firebase 的一个主要好处是，存储位置是基于云的，这意味着我们可以在多个设备上同步数据，而不是将数据保存到用户的特定设备上。

Firebase 提供了不止一个存储数据的选项:我们有 Firebase 存储、Firestore 和实时数据库。可以根据您的使用案例和要存储的数据类型来选择其中的每一项。对于简单的文件存储，Firebase Firestore 非常好用。

Firebase 也有一个免费计划，大多数其他高级功能需要付费，但总的来说，Firebase 很棒，很容易集成。

### 储备

[Hive](https://pub.dev/packages/hive) 是一个用纯 Dart 编写的轻量级、速度极快的键值数据库。

Hive 是 pub.dev 网站上点赞数最高的存储插件之一，很多人喜欢它的原因是它非常容易使用。

以下是如何设置它并立即在项目中使用它的示例片段:

```
var box = Hive.box('myBox');
box.put('name', 'David');
var name = box.get('name');
print('Name: $name');

```

看起来太简单了，对吧？这就是为什么它在 Flutter 社区中被广泛使用的原因之一。除了存储键值对，Hive 还可以用来存储对象:

```
@HiveType(typeId: 0)
class Person extends HiveObject {
  @HiveField(0)
  String name;
  @HiveField(1)
  int age;
}
var box = await Hive.openBox('myBox');
var person = Person()
  ..name = 'Dave'
  ..age = 22;
box.add(person);
print(box.getAt(0)); // Dave - 22
person.age = 30;
person.save();

```

要获得更多信息，请查看 [pub.dev 包页面](https://pub.dev/packages/hive)或 [Hive 文档](https://docs.hivedb.dev/#/)，如果您遇到任何问题，请确保在存储库问题页面上打开一个问题，或者查看是否有人之前遇到过这样的问题。

### ObjectBox

ObjectBox 是一个超快的数据库，用于在 Flutter 中本地存储对象。

它有一些好的特性，就像大多数其他特性一样，其中一些包括可伸缩性、静态类型、多平台(这意味着它可以在 Android、iOS、web 和桌面上运行)，以及内存性能良好。

要获得更多关于如何在您的应用程序中使用和实现 ObjectBox 进行本地存储的信息，请查看这里的官方教程。

### 共享 _ 首选项

shared_preferences 是移动开发人员在他们的应用程序上本地存储键值对的最常见方式之一，这是一个相对更容易和更快的选项。

使用 shared_preferences 的唯一缺点是它不适合存储大块数据和列表。

为了在 Flutter 中使用 shared_preferences，您只需添加依赖项并运行`Flutter pub get`命令。之后，创建一个`SharedPreferences`的实例并等待它，因为它返回一个`Future`。x

之后，使用实例提供的变量类型回调来保存数据，并在需要时使用类似的回调来检索数据。这看起来会像这样:

```
Future<SharedPreferences> _prefs = SharedPreferences.getInstance();
_prefs.setInt("counter", 1);
var result = _prefs.getInt("counter");

```

更多详细信息，请点击查看 [pub.dev 页面。](https://pub.dev/packages/shared_preferences/example)

## 最后的想法

Flutter 越来越受欢迎，但存储数据的选项却没有那么多。然而，可用的软件包可以满足您的需求。上述指南向我们展示了一些选项和需要考虑的要点。

例如，如果您需要存储数据并提供跨不同设备的同步，您必须使用 Firebase，如果您不打算连续存储数据，Hive 或 shared_preferences 可能是一个不错的选择。

这完全取决于您的使用案例和应用需求。

## 使用 [LogRocket](https://lp.logrocket.com/blg/signup) 消除传统错误报告的干扰

[![LogRocket Dashboard Free Trial Banner](img/d6f5a5dd739296c1dd7aab3d5e77eeb9.png)](https://lp.logrocket.com/blg/signup)

[LogRocket](https://lp.logrocket.com/blg/signup) 是一个数字体验分析解决方案，它可以保护您免受数百个假阳性错误警报的影响，只针对几个真正重要的项目。LogRocket 会告诉您应用程序中实际影响用户的最具影响力的 bug 和 UX 问题。

然后，使用具有深层技术遥测的会话重放来确切地查看用户看到了什么以及是什么导致了问题，就像你在他们身后看一样。

LogRocket 自动聚合客户端错误、JS 异常、前端性能指标和用户交互。然后 LogRocket 使用机器学习来告诉你哪些问题正在影响大多数用户，并提供你需要修复它的上下文。

关注重要的 bug—[今天就试试 LogRocket】。](https://lp.logrocket.com/blg/signup-issue-free)
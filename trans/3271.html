<html>
<head>
<title>How to implement redirects in Next.js - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>如何在Next.js - LogRocket博客中实现重定向</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/redirects-next-js/#0001-01-01">https://blog.logrocket.com/redirects-next-js/#0001-01-01</a></blockquote><div><article class="article-post">
<p>搜索引擎和用户都不希望找到不存在或不完整的页面。作为一个开发者，你也应该避免它，因为它会减少重复访问你的站点的次数，并影响它被搜索引擎索引的方式。</p>
<p>Next.js 是一个流行的框架，它构建在React库之上，并提供了许多有用的内置特性，其中之一就是处理重定向以避免这种情况。</p>
<p>在本文中，我们将设置一个应用程序，并仔细研究在Next.js项目中实现重定向的不同方法。我还将提供配置文件和路由的代码片段，并解释它们如何在Next.js中工作。</p>
<p>让我们开始吧。</p>

<h2 id="what-are-redirects">什么是重定向？</h2>
<p>重定向使用户能够将已执行的URL转移到新的URL，或者换句话说，将传入的请求从一个路径重新路由到另一个路径。</p>
<p>这些通常由服务器通过HTTP重定向状态码(3xx)来处理，也可以被网络爬虫理解。</p>
<p>重定向常用于以下情况:站点的某个部分不存在或正在建设中，内容已被移动到不同的URL，路由系统已更改，用户由于访问限制而被重定向，或许多其他情况。</p>
<h2 id="setting-up-the-nextjs-project">设置Next.js项目</h2>
<p>我们将使用<code>create-next-app</code>，这是Next.js官方支持的一种方式来设置开发服务器，我们将使用它来测试我们的重定向示例。</p>
<p>首先，打开您的终端并运行命令<code>npx create-next-app test-app</code>。这将创建一个新的项目文件夹，应用程序的所有逻辑都将存在其中。</p>
<p>接下来，通过运行<code>cd test-app</code>将工作目录更改为新创建的文件夹，然后运行<code>npm run dev</code>来启动开发服务器。</p>
<p>然后，打开浏览器，导航到<code><a href="https://localhost:3000" rel="nofollow">https://localhost:3000</a></code>查看应用的实时预览。</p>
<h2 id="defined-routes">定义的路线</h2>
<p>在Next.js中创建重定向的最常见方式是使用<code>next.config.js</code>文件，该文件应该位于产品结构的根级别。如果不是，请创建一个并包含以下代码:</p>
<pre class="language-javascript hljs">module.exports = {
  async redirects() {
    return [
      {
        source: '/',
        destination: '/welcome',
        permanent: true,
      },
    ]
  },
}
</pre>
<p>在上面的代码片段中，<code>source</code>属性是请求的路由，<code>destination</code>是我们希望将用户重定向到的路由，<code>permanent</code>控制我们是否希望为客户机和搜索引擎缓存重定向路由。</p>
<p>让我们为在配置中使用的<code>/welcome</code>创建一个新的路由。在<code>pages</code>文件夹的根级别，创建一个新文件<code>welcome.js</code>，并包含以下代码:</p>
<pre class="language-javascript hljs">export default function Welcome() {
  return &lt;h1&gt;Welcome page&lt;/h1&gt;;
}
</pre>
<p>现在，通过按键盘上的<strong> Ctrl+C </strong>重启开发服务器，然后运行；<code>npm run dev</code>重新开始。这对于我们在<code>next.config.js</code>中所做的更改生效是必要的。记住，对于本文中的其他示例，也要这样做。</p>
<p>要测试重定向，请打开浏览器并再次导航至<code><a href="https://localhost:3000" rel="nofollow">https://localhost:3000</a></code>。您现在应该会被自动重定向到<code><a href="https://localhost:3000/welcome" rel="nofollow">https://localhost:3000/welcome</a></code>。</p>
<h2 id="slug-matching">废料浆匹配</h2>
<p>js支持访问URL的slugs并为它们配置重定向。对于这个例子，让我们将<code>next.config.js</code>编辑成这样:</p>
<pre class="language-javascript hljs">module.exports = {
  async redirects() {
    return [
      {
        source: '/draft/:slug',
        destination: '/blog/:slug',
        permanent: true,
      },
    ]
  },
}
</pre>
<p>要设置路线，进入<code>pages</code>文件夹并创建两个名为<code>draft</code>和<code>blog</code>的新文件夹，然后在这两个文件夹中创建文件<code>article.js</code>。</p>
<p>在<code>draft/article.js</code>文件中，包含以下代码:</p>
<pre class="language-javascript hljs">export default function Article() {
  return &lt;h1&gt;Source route&lt;/h1&gt;;
}
</pre>
<p>在<code>blog/article.js</code>中，包括以下代码:</p>
<pre class="language-javascript hljs">export default function Article() {
  return &lt;h1&gt;Destination route&lt;/h1&gt;;
}
</pre>
<p>重启dev服务器后，尝试访问<code><a href="https://localhost:3000/draft/article" rel="nofollow">https://localhost:3000/draft/article</a></code>，你将被重定向到<code><a href="https://localhost:3000/blog/article" rel="nofollow">https://localhost:3000/blog/article</a></code>。该slug可以是URL中任何受支持的值，除非您为它创建了一个路由，并且没有在多个级别上嵌套它。</p>
<h2 id="wildcards">通配符</h2>
<p>要重定向嵌套路由，您可以使用通配符，这实际上将采用最后一个已知级别之后的所有路径，并重定向到新路由。这很简单，只需在URL中的目标位置添加一个<code>*</code>字符。</p>
<p>切换回<code>next.config.js</code>并将其更改为:</p>
<pre class="language-javascript hljs">module.exports = {
  async redirects() {
    return [
      {
        source: '/draft/:slug*',
        destination: '/blog/:slug*',
        permanent: true,
      },
    ]
  },
}
</pre>
<p>为了创建嵌套路线，我们必须在<code>draft</code>和<code>blog</code>文件夹中创建几个子文件夹。让我们假设我们想通过技术对文章进行分类，所以我们将两个文件夹都称为<code>react</code>。在两个新创建的文件夹中，添加文件<code>tutorial.js</code>。</p>
<p>在<code>draft/react/tutorial.js</code>中，包含以下代码:</p>
<pre class="language-javascript hljs">export default function Tutorial() {
  return &lt;h1&gt;Nested source route&lt;/h1&gt;;
}
</pre>
<p>在<code>blog/react/tutorial.js</code>中，包含以下代码:</p>
<pre class="language-javascript hljs">export default function Tutorial() {
  return &lt;h1&gt;Nested destination route&lt;/h1&gt;;
}
</pre>
<p>现在，重启开发服务器并访问<code><a href="https://localhost:3000/draft/react/tutorial" rel="nofollow">https://localhost:3000/draft/react/tutorial</a></code>。您应该会立即被重定向到<code><a href="https://localhost:3000/blog/react/tutorial" rel="nofollow">https://localhost:3000/blog/react/tutorial</a></code>。请注意，整个嵌套路径被重定向。</p>
<h2 id="regex-queries">正则表达式查询</h2>
<p>Regex是一个强大的工具，可以用来更有效地访问URL路径的不同部分。您将对重定向行为有更多的控制权，并被允许为重定向创建自定义规则。</p>
<p>将<code>next.config.js</code>更改为以下代码:</p>
<pre class="language-javascript hljs">module.exports = {
  async redirects() {
    return [
      {
        source: '/draft/:slug(^[a-z]+)',
        destination: '/blog/article',
        permanent: false,
      },
    ]
  },
}
</pre>
<p>在上面的代码片段中，我们只配置了由<code>a</code>到<code>z</code>字符组成的路由，这些路由被重定向到我们之前创建的<code>/blog/article</code>路由。</p>
<p>导航到项目结构中的<code>draft</code>文件夹，创建一个新文件<code>article123.js</code>，其中包含以下代码:</p>
<pre class="language-javascript hljs">export default function Article123() {
  return &lt;h1&gt;Source route&lt;/h1&gt;;
}
</pre>
<p>为了测试regex查询，重启dev服务器并尝试访问<code><a href="https://localhost:3000/draft/article" rel="nofollow">https://localhost:3000/draft/article</a></code>。您将被重定向到<code><a href="https://localhost:3000/blog/article" rel="nofollow">https://localhost:3000/blog/article</a></code>，因为该路线仅由字母组成。</p>
<p>现在尝试访问<code><a href="https://localhost:3000/draft/article123" rel="nofollow">https://localhost:3000/draft/article123</a></code>。您将看到您输入的URL的内容，并且不会被重定向，因为路由包含数字。</p>
<p>这里有几个有用的网站可以帮助你编写正则表达式查询:<a href="https://regex101.com/" target="_blank" rel="noopener"> regex101 </a>和<a href="https://regexr.com/" target="_blank" rel="noopener"> regexr </a>。</p>
<h2 id="base-path-support">基本路径支持</h2>
<p>Next.js还支持URL中基本路径的前缀。如果您必须设置多个重定向，并且不想为所有路由重复编写基本路径，这可能很有用。</p><div class="code-block code-block-54">
<hr/>
<h3>更多来自LogRocket的精彩文章:</h3>

<hr/></div>
<p>将<code>next.config.js</code>更改为以下代码:</p>
<pre class="language-javascript hljs">module.exports = {
  basePath: '/content',

  async redirects() {
    return [
      {
        source: '/draft/article',
        destination: '/blog/article',
        permanent: true,
      },
      {
        source: '/draft/react/tutorial',
        destination: '/blog/react/tutorial',
        basePath: false,
        permanent: true,
      },
    ]
  },
}
</pre>
<p>在第一个重定向对象中，源变成了<code>/content/draft/article</code>，目的地变成了<code>/content/blog/article</code>，而在第二个重定向对象中，基本路径被忽略，因为我们将<code>basePath</code>设置为<code>false</code>。</p>
<h2 id="request-parameters">请求参数</h2>
<p>使用Next.js，您可以进一步控制重定向、访问主机、头、cookie和查询值。使用<code>has</code>字段，您可以编写定制规则来控制在不同情况下是否应该执行重定向。</p>
<p>将<code>next.config.js</code>更改为以下代码:</p>
<pre class="language-javascript hljs">module.exports = {
  async redirects() {
    return [
      {
        source: '/',
        has: [
          {
            type: 'header',
            key: 'host',
            value: 'localhost:3000',
          },
        ],
        permanent: false,
        destination: '/welcome',
      },
    ];
  },
}
</pre>
<p><code>type</code>必须是<code>header</code>、<code>cookie</code>或<code>query</code>。<code>key</code>必须是所选类型中要匹配的字符串。<code>value</code>是可选的，如果未定义，将匹配<code>key</code>的任何值。</p>
<p>在上面的代码片段中，我们使用了<code>header</code>并检查了<code>host</code>键以获得<code>localhost:3000</code>值。如果请求中满足这些值，将进行重定向。</p>
<p>重启开发服务器并尝试访问<code><a href="https://localhost:3000" rel="nofollow">https://localhost:3000</a></code>。您将被重定向到<code><a href="https://localhost:3000/welcome" rel="nofollow">https://localhost:3000/welcome</a></code>，因为<code>host</code>值匹配。</p>
<p>现在用<strong> Ctrl+C </strong>关闭开发服务器并运行<code>npm run dev -- -p 8000</code>。这将在不同的端口上启动您的应用程序。现在在<code><a href="https://localhost:8000" rel="nofollow">https://localhost:8000</a></code>上访问您的应用程序。这次您将不会被重定向，因为<code>host</code>值与您的重定向配置不匹配。</p>
<h2 id="api-redirects">API重定向</h2>
<p>Next.js自带了一种处理API调用的内置方式。如果某个响应成功，您可以使用<code>redirect</code>方法来执行重定向。这在登录用户、提交表单和其他用例时非常方便。</p>
<p>要创建一个新的API路由，导航到<code>pages</code>中的<code>api</code>文件夹，创建一个新文件<code>data.js</code>，代码如下:</p>
<pre class="language-javascript hljs">export default async function handler(req, res) {
  console.log(`Name: ${req.body.name}`);
  try {
    // some await stuff here
    res.redirect(307, '/welcome');
  } catch (err) {
    res.status(500).send({ error: 'Error while fetching data' });
  }
}
</pre>
<p>然后，导航到<code>pages</code>文件夹的根级别并创建一个新文件<code>form.js</code>，以创建表单本身。在新创建的文件中包含以下代码:</p>
<pre class="language-javascript hljs">export default function Form() {
  return (
    &lt;form action='/api/data' method='post'&gt;
      &lt;label htmlFor='name'&gt;Your name:&lt;/label&gt;
      &lt;input type='text' id='name' name='name' /&gt;
      &lt;button type='submit'&gt;Submit&lt;/button&gt;
    &lt;/form&gt;
  );
}
</pre>
<p>现在打开浏览器，导航至<code><a href="https://localhost:3000/form" rel="nofollow">https://localhost:3000/form</a></code>。您将看到一个输入字段，输入您的姓名，然后单击submit按钮将值发送给API。输入任何值，提交它，您应该被重定向到<code><a href="https://localhost:3000/welcome" rel="nofollow">https://localhost:3000/welcome</a></code>。</p>
<p>为了确保API接收到您输入的值，切换回终端并检查打印的日志。该值应该显示在那里。</p>
<h2 id="uppercase-to-lowercase-urls">大写到小写的URL</h2>
<p>您可能想知道如何在Next.js中将大写URL重定向到小写URL。例如，假设您想将用户从<code>/About</code>重定向到<code>/about</code>。使用带有<code>source: '/About', destination: '/about'</code>的标准重定向解决方案是行不通的，因为重定向不区分大小写。</p>
<p>要解决这个问题，可以使用Next.js中间件。它使您能够在处理请求之前执行代码，允许您根据需要改变响应和重定向用户。</p>
<p>在项目的根目录下创建<code>middleware.js</code>文件，并包含以下代码:</p>
<pre class="language-javascript hljs">import { NextResponse } from "next/server";

const Middleware = (req) =&amp;gt; {
  if (req.nextUrl.pathname === req.nextUrl.pathname.toLowerCase())
    return NextResponse.next();

  return NextResponse.redirect(
    `${req.nextUrl.origin + req.nextUrl.pathname.toLowerCase()}`
  );
};

export default Middleware;
</pre>
<p>为了测试它，尝试利用任何以前创建的路线；您将被成功重定向到全小写的路由版本。现在，删除<code>middleware.js</code>文件；您会发现您无法访问全部小写的路由版本。</p>
<h2 id="getstaticprops-and-getserversideprops">getStaticProps and getServerSideProps</h2>
<p>如果你想通过Next.js的内置预渲染方法设置重定向，你可以在<code>getStaticProps</code>或<code>getServerSideProps</code>中包含它们。</p>
<p>使用<code>getStaticProps</code>，页面将在构建时预呈现(静态站点生成)。</p>
<p>要设置一个示例，导航到<code>pages</code>文件夹的根级别并编辑<code>index.js</code>:</p>
<pre class="language-javascript hljs">export default function Home() {
  return &lt;h1&gt;Home page&lt;/h1&gt;;
}

export async function getStaticProps() {
  const content = null;

  if (!content) {
    return {
      redirect: {
        permanent: false,
        destination: '/welcome',
      },
    };
  }

  return {
    props: {},
  };
}
</pre>
<p>类似地，对于服务器端呈现(SSG)，您将使用<code>getServerSideProps</code>，这将确保Next.js在每个请求上预先呈现页面。</p>
<p>要设置SSG示例，编辑如下所示的<code>index.js</code>:</p>
<pre class="language-javascript hljs">export default function Home() {
  return &lt;h1&gt;Home page&lt;/h1&gt;;
}

export async function getServerSideProps() {
  const content = null;

  if (!content) {
    return {
      redirect: {
        permanent: false,
        destination: '/welcome',
      },
    };
  }

  return {
    props: {},
  };
}
</pre>
<p>为了测试这两种情况中的任何一种，尝试访问<code><a href="https://localhost:3000" rel="nofollow">https://localhost:3000</a></code>，由于执行了<code>getStaticProps</code>或<code>getServerSideProps</code>中的重定向规则，您将被自动重定向到<code><a href="https://localhost:3000/welcome" rel="nofollow">https://localhost:3000/welcome</a></code>。</p>
<h2 id="redirecting-unauthenticated-users">重定向未经身份验证的用户</h2>
<p>在全栈开发中，您通常希望限制用户对私有URL的访问(那些需要验证才能查看的URL)。在这些情况下，您需要将用户重定向回登录屏幕。</p>
<p>首先，让我们看看如何认证静态生成的页面，其中用户是从客户端获取的。</p>
<p>首先创建一条受保护的新路径。接下来，在<code>pages</code>目录的根目录下创建一个新文件<code>profile.js</code>，并包含以下代码:</p>
<pre class="language-javascript hljs">import useUser from '../hooks/useUser';

const Profile = () =&amp;gt; {
  const user = useUser();

  if (!user) return null;
  return &amp;lt;h1&amp;gt;Hello, {user}&amp;lt;/h1&amp;gt;;
};

export default Profile;
</pre>
<p>然后，导航到<code>src</code>目录，创建一个新文件夹<code>hooks</code>，其中包含一个<code>useUser.js</code>文件，并包含以下代码:</p>
<pre class="language-javascript hljs">import { useEffect } from "react";
import Router from "next/router";

export function useUser() {
  const user = false;

  useEffect(() =&amp;gt; {
    if (!user) Router.push("/");
  }, [user]);
  return user;
}
</pre>
<p>在本教程中，我们为用户创建了一个示例变量。在实际场景中，您可能会使用类似于<a href="https://swr.vercel.app/"> swr </a>的东西来进行API调用，以检查是否有活动会话。</p>
<p>现在，尝试进入<code>/profile</code>路线。由于没有活动用户，您将被重定向到<code>/</code>路线。</p>
<p>接下来，将<code>user</code>值更改为某个字符串名称，并再次尝试访问<code>/profile</code>路由。对于您选择的值，您应该拥有对问候语的完全访问权限。</p>
<p>在Next.js中，我们还可以验证服务器呈现的页面。您可以使用<code>getServerSideProps</code>函数，该函数将在预呈现每个请求的页面时从服务器返回数据。</p>
<p>为了进行试验，用下面的代码更新<code>profile.js</code>文件:</p>
<pre class="language-javascript hljs">const Profile = ({ user }) =&amp;gt; {
  return &amp;lt;h1&amp;gt;Hello, {user}&amp;lt;/h1&amp;gt;;
};

export function getServerSideProps() {
  const user = false;

  if (!user) {
    return {
      redirect: {
        destination: "/",
        permanent: false,
      },
    };
  }

  return {
    props: {user},
  };
}

export default Profile;
</pre>
<p>请注意，活动用户将在服务器端获取。在本教程中，我们使用了一个用户变量来定义登录用户是否存在。</p>
<p>要查看重定向的工作情况，请尝试访问<code>/profile</code>路线。您将被重定向到<code>/</code>，因为应用程序中没有可用的活动用户。</p>
<p>现在，将<code>user</code>值更改为某个名称字符串，并尝试再次访问<code>/profile</code>路线。您将可以完全访问您选择的字符串值的问候语，因为它是通过props从服务器传递过来的。</p>
<h2 id="conclusion">结论</h2>
<p>在本文中，我们研究了在Next.js中实现重定向的几种方法。首先，我们使用<code>next.config.js</code>并为预定义的路由编写自定义配置，访问单级和嵌套路由，并使用regex增加对重定向的控制。</p>
<p>然后，我们进一步研究了如何基于收到的请求参数创建重定向，以及如何将大写路由重定向到小写路由。最后，我们研究了如何使用API路由、静态站点生成和服务器端呈现来实现重定向，以及如何重定向需要认证的路由。</p>
<p>我希望通过这篇文章你能学到一些新的东西，从这一点开始，你将能够在你未来的Next.js应用程序中为你的所有用例创建重定向。</p><div class="code-block code-block-30">
<div class="blog-plug inline-plug next-plug"><h2><a href="https://lp.logrocket.com/blg/nextjs-signup" target="_blank"> LogRocket </a>:全面了解生产Next.js应用</h2><p>调试下一个应用程序可能会很困难，尤其是当用户遇到难以重现的问题时。如果您对监视和跟踪状态、自动显示JavaScript错误、跟踪缓慢的网络请求和组件加载时间感兴趣，</p><a href="https://lp.logrocket.com/blg/nextjs-signup" target="_blank">try LogRocket</a><p>. </p><a class="signup" href="https://lp.logrocket.com/blg/nextjs-signup" target="_blank" rel="noopener noreferrer"><img class="alignnone size-full wp-image-46 jetpack-lazy-image" src="../Images/f300c244a1a1cf916df8b4cb02bec6c6.png" data-lazy-src="https://files.readme.io/27c94e7-Image_2017-06-05_at_9.46.04_PM.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://files.readme.io/27c94e7-Image_2017-06-05_at_9.46.04_PM.png"/><noscript><img data-lazy-fallback="1" class="alignnone size-full wp-image-46" src="../Images/f300c244a1a1cf916df8b4cb02bec6c6.png" data-original-src="https://files.readme.io/27c94e7-Image_2017-06-05_at_9.46.04_PM.png"/></noscript></a><a class="signup" href="https://lp.logrocket.com/blg/nextjs-signup" target="_blank" rel="noopener noreferrer"><img class="alignnone size-full wp-image-46 jetpack-lazy-image" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/><noscript><img data-lazy-fallback="1" class="alignnone size-full wp-image-46" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/></noscript></a><p>LogRocket 就像是网络和移动应用的DVR，记录下你的Next.js应用上发生的一切。您可以汇总并报告问题发生时应用程序的状态，而不是猜测问题发生的原因。LogRocket还可以监控应用程序的性能，报告客户端CPU负载、客户端内存使用等指标。</p><p>LogRocket Redux中间件包为您的用户会话增加了一层额外的可见性。LogRocket记录Redux存储中的所有操作和状态。</p><p>让您调试Next.js应用的方式现代化— <a class="signup" href="https://lp.logrocket.com/blg/nextjs-signup" target="_blank" rel="noopener noreferrer">开始免费监控</a>。</p></div></div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
<html>
<head>
<title>Understanding SharedArrayBuffer and cross-origin isolation - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>了解 SharedArrayBuffer 和跨源隔离- LogRocket 博客</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/understanding-sharedarraybuffer-and-cross-origin-isolation/#0001-01-01">https://blog.logrocket.com/understanding-sharedarraybuffer-and-cross-origin-isolation/#0001-01-01</a></blockquote><div><article class="article-post">
<p>JavaScript 内存以二进制形式存储程序开发和运行时使用的每一条数据和指令。JavaScript，也称为<a href="https://www.ecma-international.org/publications-and-standards/standards/ecma-262/" target="_blank" rel="noopener"> ECMAScript </a>，是一种<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Memory_Management" target="_blank" rel="noopener">内存管理的</a>语言。</p>
<p>JavaScript 引擎自己访问和管理内存，它为编写和执行的每个程序或代码块分配内存。它还对内存中不再存在的数据执行垃圾收集。</p>
<p>尽管 JavaScript 是一种内存管理语言，但它也有助于管理数据。但是它有缺陷。例如，JavaScript 可以为特定的程序或变量分配比内存中所需的空闲空间更多的空间。在某些情况下，JavaScript 中的垃圾收集可能会很慢。</p>
<p>为了让开发人员能够在内存的多个线程之间分配和共享视图中的数据(使用类型化数组)，<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/SharedArrayBuffer" target="_blank" rel="noopener">引入了<code>ArrayBuffer</code>和<code>SharedArrayBuffer</code>特性</a>。</p>
<h2>什么是<code>SharedArrayBuffer</code>？</h2>
<p>当讨论<code>SharedArrayBuffer</code>时，我们可以很容易地将注意力集中在物理词汇上:“共享”、“数组”和“缓冲区”。</p>
<p>数组是一种数据结构，在编程中用于存储由不同数据类型(字符串、布尔值、数字和对象)组成的数据元素。缓冲区是内存存储的一部分，用于在发送或接收数据之前临时存储数据。</p>
<p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer" target="_blank" rel="noopener"> <code>ArrayBuffer</code> </a>是一个与众不同的数组——它是一个字节数组，意味着只接受字节。</p>
<p>要在 JavaScript 中使用共享内存，您需要创建<code>SharedArrayBuffer</code>。这是通过使用<code>SharedArrayBuffer</code>对象来完成的，它创建了一个新的对象构造函数，用于在多个线程之间写入和共享数据。</p>
<h2><code>SharedArrayBuffer</code>的历史</h2>
<p>2018 年 1 月 5 日，<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/SharedArrayBuffer/SharedArrayBuffer" target="_blank" rel="noopener"> <code>SharedArrayBuffer</code>因现代<a href="https://googleprojectzero.blogspot.com/2018/01/reading-privileged-memory-with-side.html" target="_blank" rel="noopener"> CPU 架构</a>发现的漏洞攻击，在各大浏览器禁用</a>。</p>
<p>从那时起，<code>SharedArrayBuffer</code>在 Google Chrome v67 中重新启用，现在可以在启用了站点隔离功能的平台上使用，我们将在本文的后续部分中介绍。此更新可抵御 Spectre 漏洞攻击，并使您的站点更加安全。</p>
<p>下面，我们将探讨如何在 JavaScript 中使用<code>SharedArrayBuffer</code>来共享内存。首先，我们将共享内存，然后更新和同步它，最后，调试它。</p>
<h2>在 JavaScript 中使用<code>SharedArrayBuffer</code>共享内存</h2>
<p>使用<code>SharedArrayBuffer</code>的好处之一是能够在 JavaScript 中共享内存。在 JavaScript 中，<a href="https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Using_web_workers" target="_blank" rel="noopener"> web workers </a>作为一种在 JS 代码中创建线程的手段。</p>
<p>然而，web worker 也与<code>SharedArrayBuffer</code>一起使用，它通过直接指向存储或以前访问过每个数据的内存，允许 web worker 之间共享原始二进制数据。</p>
<p>让我们看一个如何使用<code>SharedArrayBuffer</code>共享内存的例子。</p>
<p>在我们开始之前，创建三个文件:<strong>index.html</strong>(我们链接脚本的地方)、<strong> script.js </strong>(主线程)和<strong> worker.js </strong>(工作线程)。</p>
<pre>&lt;!--index.html file--&gt;

&lt;DOCTYPE html&gt;
    &lt;html&gt;
    &lt;head&gt;
        &lt;title&gt;using shared array buffer&lt;/title&gt;
        &lt;meta charset="UTF-8"&gt;
        &lt;meta name="sharedArrayBuffer" description="using cross-orgiin-isolation in the web browser"&gt;
        &lt;script type="text/JavaScript" src="script.js"&gt;&lt;/script&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;h3&gt;Take a look at your browser console :)&lt;/h3&gt;
        &lt;script type="text/JavaScript" src="worker.js"&gt;&lt;/script&gt;
    &lt;/body&gt;
    &lt;/html&gt;
</pre>
<p>我们先来看看主线程(script.js 文件)。这里，我们访问<strong> worker.js </strong>，然后使用<code>SharedArrayBuffer</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/SharedArrayBuffer" target="_blank" rel="noopener">对象</a>创建一个共享内存，并将其单位长度字节数设置为<code>1024</code>(注意:可以使用任何所需的单位长度字节数)。</p>
<p>使用类型为<code><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Int16Array" target="_blank" rel="noopener">Int16Array</a></code>的类型化数组来解释被传递的数据，我们将一个数字分配给类型化数组(<code>20</code>)以从主线程共享。我们使用<code><a href="https://developer.mozilla.org/en-US/docs/Web/API/Worker/postMessage" target="_blank" rel="noopener">postMessage</a></code>将缓冲区发送给工作线程。</p>
<pre>/*MAIN THREAD*/

const newWorker = new Worker('worker.js');
const buffMemLength = new SharedArrayBuffer(1024); //byte length
let typedArr = new Int16Array(buffMemLength);
//original data
typedArr[0] = 20;
//sending the buffer to worker 
newWorker.postMessage(buffMemLength); 
</pre>
<p>为了与工作线程共享来自主线程的数据，我们设置了一个<code>eventListener</code>在收到数据时运行。这里，注意我们使用了一个<code>Int16</code>类型的数组来显示浏览器控制台中的数据。</p>
<pre>/*WORKER THREAD*/

addEventListener('message', ({ data }) =&gt; {
    let arr = new Int16Array(data);
    console.group('[the worker thread]');
    console.log('Data received from the main thread: %i', arr[0]);
    console.groupEnd();
    postMessage('Updated');
})
</pre>
<p>在您的浏览器控制台中，您应该会看到以下内容:</p>
<pre>[the worker thread]                      worker.js:7
Data received from main thread: 20       worker.js:8
</pre>
<h2>更新和同步共享内存</h2>
<p>自从 JavaScript 增加了<code>SharedArrayBuffer</code>之后，更新共享内存变得更加容易。使用前面的例子，我们将从工作线程中更新数据。</p>
<p>让我们将主线程中的原始<code>arr[0]</code>设置为上面在作用域(在工作线程中)中声明的<code>dataChanged</code>变量。</p>
<pre>/*WORKER THREAD*/

let BYTE_PER_LENTH = 5;
addEventListener('message', ({ data }) =&gt; {
    var arr = new Int16Array(data);
    console.group('[worker thread]');
    console.log('Data received from main thread: %i', arr[0]);
    console.groupEnd();

    //updating the data from the worker thread 
    let dataChanged = 5 * BYTE_PER_LENTH;
    arr[0] = dataChanged;
    //Sending to the main thread 
    postMessage('Updated');
})
</pre>
<p>为了从工作线程中更新数据，我们调用一个将在主线程中触发的<code>onmessage</code>事件，表明数据是从工作线程中更新的。</p>
<pre>/*MAIN THREAD*/

const newWorker = new Worker('worker.js');
const buffMemLength = new SharedArrayBuffer(1024); //byte length
var typedArr = new Int16Array(buffMemLength);
//original data
typedArr[0] = 20;
//sending the buffer to worker 
newWorker.postMessage(buffMemLength);

//onmessage event
newWorker.onmessage = (e) =&gt; {
    console.group('[the main thread]');
    console.log('Data updated from the worker thread: %i', typedArr[0]);
    console.groupEnd();
}
</pre>
<p>在浏览器控制台中，您应该会看到:</p>
<pre>[the worker thread]                            worker.js:7
Data received from main thread: 20             worker.js:8
[the main thread]                              script.js:15
Data updated from the worker thread: 25        script.js:16
</pre>
<p>同步共享内存是很重要的，因为在实现时，同步会导致共享内存同时运行而不会被改变。为了在共享内存中整合同步，开发人员使用了<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Atomics" target="_blank" rel="noopener">原子</a>操作。</p>
<p><code>Atomics</code>在<code>wait()</code>和<code>notify()</code>方法的帮助下，确保每个进程在下一个进程之前被连续执行，并且所有从内存中读取或写入特定内存的数据被一个接一个地执行。</p>
<h2>关于<code>SharedArrayBuffer</code>和跨原点隔离的最新更新</h2>
<p>自 2021 年 5 月以来，JavaScript 中对共享内存进行了几次重要更新，包括跨起源隔离，使开发人员能够更有效地调试共享内存。它目前在 Firefox 79+和桌面 Chrome 上受到支持，但 Chrome 92 的更新将可以访问跨源隔离页面的网站。</p>
<p>要实现<code>SharedArrayBuffer</code>，您需要一个安全的环境，使用一个或多个响应头指令来限制访问。这被称为跨源隔离，尽管以前不鼓励使用共享内存，但它已被证明是保护网站安全的更好方法。</p>
<h2>什么是跨原点隔离？</h2>
<p>跨来源隔离是添加到浏览器中的新安全功能(截至 2021 年 4 月)。简而言之，这是在顶级文档上发送两个 HTTP 头(COOP 和 COEP)的结果。这些头文件使您的网站能够访问 web APIs，如<code>SharedArrayBuffer</code>，并防止外部攻击(幽灵攻击、跨源攻击等)。</p>
<p>以前，使用共享内存的网站可以在未经许可的情况下加载跨源内容。这些网站可能会与不同来源的窗口弹出窗口进行交互，这可能会导致安全违规或漏洞，从而获取网站上的用户信息。对于使用共享内存的网站来说，安全和保护用户信息变得非常重要。</p><div class="code-block code-block-54">
<hr/>
<h3>更多来自 LogRocket 的精彩文章:</h3>

<hr/></div>
<h2>在您的网站上启用跨来源隔离</h2>
<p>现在，我们对跨源隔离的背景有了更多的了解，让我们在我们的网站上启用它。</p>
<p>首先，在文档的顶层启用跨来源开放策略(COOP)头，用<code>same-origin</code>:</p>
<pre>Cross-Origin-Opener-Policy: same-origin
</pre>
<p>此标题将页面与浏览器中的任何跨来源弹出窗口隔离开来，使它们无法访问文档或向它们发送直接消息。它还确保您的页面处于一个安全的上下文中，具有相同的顶级来源的页面。</p>
<p>接下来，发送一个跨来源嵌入器策略报头(COEP)，其值指示<code>require-CORP</code>(跨来源资源策略)。</p>
<pre>Cross-Origin-Embedder-Policy: require-corp
</pre>
<p>这可以确保从您的网站加载的所有资源都已加载到 corp。COEP 标头打破了所有需要与浏览器中跨来源窗口进行通信的集成，例如来自第三方服务器的认证和支付(结账)。</p>
<p>通过在文档的顶层设置这些标题，您的网站现在处于一个安全的环境中，并提供对 web APIs 的访问。</p><div class="code-block code-block-27">
<div class="blog-plug inline-plug vanilla-javascript-cta"><h2>通过理解上下文，更容易地调试 JavaScript 错误</h2>
<p>调试代码总是一项单调乏味的任务。但是你越了解自己的错误，就越容易改正。</p>
<p>LogRocket 让你以新的独特的方式理解这些错误。我们的前端监控解决方案跟踪用户与您的 JavaScript 前端的互动，让您能够准确找出导致错误的用户行为。</p>
<a href="https://lp.logrocket.com/blg/javascript-signup" class="signup" target="_blank" rel="noopener noreferrer"><img class="alignnone size-full wp-image-46 jetpack-lazy-image" src="../Images/cbfed9be3defcb505e662574769a7636.png" alt="LogRocket Dashboard Free Trial Banner" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2020/06/reproduce-javascript-errors.gif?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/06/reproduce-javascript-errors.gif"/><noscript><img data-lazy-fallback="1" class="alignnone size-full wp-image-46" src="../Images/cbfed9be3defcb505e662574769a7636.png" alt="LogRocket Dashboard Free Trial Banner" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/06/reproduce-javascript-errors.gif"/></noscript></a>
<p>LogRocket 记录控制台日志、页面加载时间、堆栈跟踪、慢速网络请求/响应(带有标题+正文)、浏览器元数据和自定义日志。理解您的 JavaScript 代码的影响从来没有这么简单过！</p>
<a class="signup" href="https://lp.logrocket.com/blg/javascript-signup" target="_blank" rel="noopener noreferrer">Try it for free</a><p>.</p></div>


</div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
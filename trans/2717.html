<html>
<head>
<title>Build React custom component library with Theme UI - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>用主题 UI 构建 React 定制组件库</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/build-react-custom-component-library-theme-ui/#0001-01-01">https://blog.logrocket.com/build-react-custom-component-library-theme-ui/#0001-01-01</a></blockquote><div><article class="article-post">
<p>React 是一个 JavaScript 工具包，可以为在线和移动应用程序创建漂亮的用户界面。它很容易与其他 JavaScript 框架和库接口，并且具有简短的、可重用的组件。</p>
<p>由于其强大的模块化，React 组件库加快了 UI 开发，并提供了很大的自由度。有几个<a href="https://blog.logrocket.com/top-9-ui-libraries-kits-react/" target="_blank" rel="noopener">流行的 React UI 库</a>；但是，它们可能无法提供所有项目所需的定制级别。</p>
<p>在本教程中，我们将回顾如何使用 TypeScript 在 React with <a href="https://theme-ui.com" target="_blank" rel="noopener"> Theme UI </a>中构建和发布自定义组件库。</p>
<h2 id="what-is-theme-ui">什么是主题 UI？</h2>
<p>主题 UI 是一个库，它使用基于约束的设计概念来创建主题化的用户界面。有了一个针对最佳开发人员人机工程学的广泛 API，主题 UI 可以用来创建定制的组件库、设计系统、web 应用程序、Gatsby 主题等等。</p>
<h2 id="getting-started">入门指南</h2>
<p>本实践教程具备以下先决条件:</p>
<ul>
<li><a href="https://nodejs.org/" target="_blank" rel="noopener"> Node.js </a>已安装</li>
<li>Ubuntu 20.04，或者你选择的操作系统</li>
<li>VS 代码，或者您选择的任何 IDE</li>
</ul>
<h2 id="project-setup">项目设置</h2>
<p>我们将首先运行以下命令为我们的项目创建一个文件夹:</p>
<pre class="language-shell hljs">mkdir themecomponentui &amp;&amp; cd themecomponentui
</pre>
<p>接下来，我们将使用<code>npm init</code>命令创建一个<code>package.json</code>文件来初始化一个新的 React 项目。然后，我们将使用以下命令安装 React 和 TypeScript:</p>
<pre class="language-shell hljs">npm i -D react @types/react typescript
</pre>
<p>上面命令中的<code>-D</code>标志表示模块应该作为<code>devDependencies</code>安装，因为我们在构建过程中需要它们。</p>
<p>安装了 React 和 TypeScript 之后，让我们根据下面的文件夹结构来组织我们的项目:</p>
<p>📦themecomponentui <br/> ┣ 📂src <br/> ┃ ┣ 📂components <br/> ┃ ┃ ┣ 📂Button <br/> ┃ ┃ ┣ 📂Input</p>
<p>现在，让我们为项目配置 TypeScript。</p>
<h2 id="configuring-typescript">配置 TypeScript</h2>
<p>我们将使用 TypeScript 来构建组件，使我们能够将该库作为一个模块来使用。</p>
<p>首先，我们将通过使用以下命令创建一个<code>tsconfig.json</code>文件来配置 TypeScript:</p>
<pre class="language-shell hljs">npx tsc --init
</pre>
<p>然后，我们将使用下面的代码片段更新<code>tsconfig.json</code>文件:</p>
<pre class="language-json hljs">{
  "compilerOptions": {
    "esModuleInterop": true,
    "strict": true,
    "skipLibCheck": true,
    "jsx": "react",
    "module": "ESNext",
    "declaration": true,
    "declarationDir": "types",
    "sourceMap": true,
    "outDir": "dist",
    "moduleResolution": "node",
    "emitDeclarationOnly": true,
    "allowSyntheticDefaultImports": true,
    "forceConsistentCasingInFileNames": true,
  },
  "exclude": [
    "dist",
    "node_modules",
  ],
}
</pre>
<p>在上面的代码中，我们添加了以下配置:</p>
<ul>
<li><code>"jsx": "react"</code>:将 JSX 码转换成 React 码</li>
<li><code>"skipLibCheck": true</code>:跳过声明文件的类型检查</li>
<li>为我们的库生成现代的 JavaScript 模块(ES6 或更高版本)</li>
<li><code>"declarationDir": "types"</code>:设置. d.ts 文件的目录</li>
<li><code>"sourceMap": true</code>:支持将 JavaScript 代码映射回其 TypeScript 文件源，以便调试</li>
<li><code>"outDir": "dist"</code>:设置项目构建的目录</li>
<li><code>"moduleResolution": "node"</code>:遵循 Node.js 规则查找模块</li>
<li><code>"emitDeclarationOnly": true</code>:允许 Rollup 生成 JavaScript 导出类型声明</li>
</ul>
<p>既然已经配置了 TypeScript，让我们继续配置 Rollup。</p>
<h2 id="configuring-rollup">配置汇总</h2>
<p>Rollup 是一个 JavaScript 模块捆绑器，它将微小的代码块组合起来，创建更大更复杂的东西，比如一个库或应用程序。它不像 CommonJS 和 AMD 那样使用独特的解决方案，而是利用代码的标准化 es 模块结构。</p>
<p>为了开始使用 Rollup，我们将使用以下命令安装它:</p>
<pre class="language-shell hljs">npm i -D rollup
</pre>
<p>在上面的代码中，我们将<code>-D</code>标志添加到 Rollup 安装命令中，以将其添加到我们的<code>devDependencies</code>中。安装完成后，我们还将安装以下汇总插件:</p>

<p>我们将运行以下命令来安装插件:</p>
<pre class="language-javascript hljs">npm i -D @rollup/plugin-node-resolve @rollup/plugin-commonjs @rollup/plugin-typescript rollup-plugin-peer-deps-external rollup-plugin-terser rollup-plugin-dts
</pre>
<p>安装完成后，我们将通过使用以下代码片段在项目根目录中创建一个<code>rollup.config.js</code>文件来配置 Rollup:</p>
<pre class="language-javascript hljs">import resolve from "@rollup/plugin-node-resolve";
import commonjs from "@rollup/plugin-commonjs";
import typescript from "@rollup/plugin-typescript";
import dts from "rollup-plugin-dts";
import { terser } from "rollup-plugin-terser";
import peerDepsExternal from 'rollup-plugin-peer-deps-external';
const packageJson = require("./package.json");

export default [
    {
        input: "src/index.ts",
        output: [
            {
                file: packageJson.main,
                format: "cjs",
                sourcemap: true,
            },
            {
                file: packageJson.module,
                format: "esm",
                sourcemap: true,
            },
        ],
        plugins: [
            peerDepsExternal(),
            resolve(),
            commonjs(),
            typescript({ tsconfig: "./tsconfig.json" }),
            terser(),
        ],
        external: ["react", "react-dom"]
    },
    {
        input: "dist/esm/types/index.d.ts",
        output: [{ file: "dist/index.d.ts", format: "esm" }],
        plugins: [dts()],
    },
];
</pre>
<p>在上面的代码中，我们配置了 CommonJS 和 ES 模块来处理项目构建过程。这将使我们能够使用命名导出和树摇动。它还提供了增强的静态分析、浏览器支持以及与其他 JavaScript 版本的兼容性。</p>
<p>接下来，我们需要在<code>package.json</code>文件中指定 CommonJS 文件和 es 模块的路径。我们将打开<code>package.json</code>文件并添加以下代码片段配置:</p>
<pre class="language-json hljs">"main": "dist/cjs/index.js",
"module": "dist/esm/index.js",
</pre>
<p>最后，我们将在<code>scripts</code>对象中添加构建命令:</p>
<pre class="language-json hljs">...
"scripts": {
   ...
    "build": "rollup -c"
  },
...
</pre>
<h2 id="creating-custom-components">创建自定义组件</h2>
<p>现在，让我们创建自定义组件。首先，我们将安装主题用户界面:</p>
<pre class="language-shell hljs">npm install -D theme-ui @emotion/react @emotion/styled @mdx-js/react
</pre>
<p>主题 UI 是一个灵活的 API 框架，所以我们可以选择使用原始 UI 组件库或者使用<a href="https://theme-ui.com/sx-prop/" target="_blank" rel="noopener"> <code>sx</code>道具</a>。出于本教程的演示目的，我们将使用<code>sx</code>道具。</p>
<h2 id="creating-button-component">创建按钮组件</h2>
<p>接下来，让我们创建按钮组件。我们将在<code>src/components/Button</code>文件夹中创建<code>Button.tsx</code>和<code>index.ts</code>文件。</p>
<p>打开<code>Button.tsx</code>文件并添加以下代码片段:</p>
<pre class="language-typescript hljs">/** @jsxImportSource theme-ui */
import * as React from "react";
import { MouseEventHandler } from "react";

export interface ButtonProps {
    label?: string;
    color?: string;
    fontFamily?: string
    onClick?: MouseEventHandler&lt;HTMLButtonElement&gt;
}

const Button = (props: ButtonProps) =&gt; {
    return &lt;button onClick={props.onClick} sx={{ color: props.color, fontFamily: props.fontFamily }}&gt;{props.label}&lt;/button&gt;;
};
export default Button;
</pre>
<p>在上面的代码中，我们在文件的顶部添加了<code>/** @jsxImportSource theme-ui */</code>注释来启用主题 UI <code>sx</code>道具。</p>
<p>接下来，我们导入 React 框架<code>MouseEventHandler</code>方法来启用按钮点击事件。</p>
<p>然后，我们定义了<code>interface</code> <code>ButtonProps</code>，指定了<code>Button</code>组件的属性。<code>?</code>符号表示一个可选属性(例如<code>color?: string</code>)，意味着如果我们不在组件中提供该属性，TypeScript 不会抛出错误。</p>
<p>接下来，我们创建了<code>Button</code>组件，并使用带有其他属性的主题 UI 的<code>sx</code>道具来设置样式。</p>
<p>现在，让我们使用下面的代码片段导出<code>index.ts</code>文件中的<code>Button</code>组件:</p>
<pre class="language-typescript hljs">export { default } from './Button'
</pre>
<h2 id="creating-the-input-component">创建<code>Input</code>组件</h2>
<p>我们将通过在<code>src/components/Input</code>文件夹中创建<code>Input.tsx</code>和<code>index.ts</code>文件来创建<code>Input</code>组件。</p>
<p>打开<code>Input.tsx</code>文件，并添加以下代码片段:</p>
<pre class="language-typescript hljs">/** @jsxImportSource theme-ui */
import * as React from "react";
import { ChangeEventHandler } from "react"

export interface InputProps {
    label?: string;
    disabled?: boolean;
    fontFamily?: string;
    placeholder?: string;
    paddding?: string;
    id?: string;
    onChange?: ChangeEventHandler&lt;HTMLInputElement&gt;
}

const Input = (props: InputProps) =&gt; {
    return (
        &lt;div&gt;
            &lt;label htmlFor={props.id ? props.id : 'text'}&gt;{props.label}&lt;/label&gt;
            &lt;input type='text' id={props.id ? props.id : 'text'} disabled={props.disabled} placeholder={props.placeholder} sx={{ padding: !props.paddding &amp;&amp; "4px", display: 'block' }}&gt;&lt;/input&gt;;
        &lt;/div&gt;
    );
};
export default Input;
</pre>
<p>在上面的代码中，我们在文件的开头添加了<code>/** @jsxImportSource theme-ui */</code>注释，以使用主题 UI 的<code>sx</code>属性来设置组件的样式。</p>
<p>接下来，我们定义了<code>Input</code>组件的<code>interface</code>。属性<code>onChange?</code>将使我们能够添加一个<code>onChange</code>事件到输入中。</p>
<p>我们创建了<code>Input</code>组件，它接受与<code>InputProps</code>接口匹配的<code>props</code>，并使用主题 UI 的<code>sx</code>属性和其他属性来设计组件的样式。</p>
<p>现在，让我们使用以下命令导出<code>index.ts</code>文件中的<code>Input</code>组件:</p>
<pre class="language-typescript hljs">export { default } from './Input'
</pre>
<p>我们将在<code>src/components</code>文件夹中创建一个<code>index.ts</code>文件，并像这样导出组件:</p>
<pre class="language-typescript hljs">export { default as Button } from './Button';
export { default as Input } from './Input'
</pre>
<p>现在，我们将构建项目:</p>
<pre class="language-shell hljs">npm run build
</pre>
<p>上面的命令将在项目根目录下创建一个<code>dist</code>文件夹。</p><div class="code-block code-block-54">
<hr/>
<h3>更多来自 LogRocket 的精彩文章:</h3>

<hr/></div>
<h2 id="publishing-to-npm">发布到国家预防机制</h2>
<p>下一步是将我们新创建的组件发布到 npm，这样我们就可以在项目中使用它们，并与朋友们分享。</p>
<p>要开始，请登录您的 npm 帐户:</p>
<pre class="language-shell hljs">npm login
</pre>
<p>如果你没有帐号，你可以在这里注册一个 npm 帐号。</p>
<p>登录后，输入您的帐户凭据以获得认证。动态口令代码将发送到您注册的电子邮件地址。要求时输入 OTP pin。</p>
<p>现在，通过运行以下命令发布您的包:</p>
<pre class="language-shell hljs">npm publish --access public
</pre>
<p>您已经成功地向 npm 发布了 React 自定义组件库！</p>
<h2 id="conclusion">结论</h2>
<p>在本教程中，我们介绍了主题 UI 库，并演示了如何使用主题 UI 来构建自定义的 React 组件库。我们还演示了如何为项目构建配置 TypeScript 和 Rollup，以及如何向 npm 发布自定义库。您可以通过创建更多带有主题 UI 的组件来扩展本教程，比如表单、框和网格。</p>
<p>感谢阅读。欢迎在下面分享和评论。</p><div class="code-block code-block-17">
<div class="blog-plug inline-plug react-plug" vwo-el-id="26283398190">
<h2 vwo-el-id="41600691720">使用 LogRocket 消除传统反应错误报告的噪音</h2>
<a href="https://lp.logrocket.com/blg/react-signup-issue-free" target="_blank" vwo-el-id="19356441070">LogRocket
</a><p>是一款 React analytics 解决方案，可保护您免受数百个误报错误警报的影响，只针对少数真正重要的项目。LogRocket 告诉您 React 应用程序中实际影响用户的最具影响力的 bug 和 UX 问题。</p><a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="19356441380">
<img class="first-react-image alignnone size-full wp-image-46 jetpack-lazy-image jetpack-lazy-image--handled" src="../Images/f300c244a1a1cf916df8b4cb02bec6c6.png" vwo-el-id="18272717540" data-lazy-loaded="1" data-original-src="https://files.readme.io/27c94e7-Image_2017-06-05_at_9.46.04_PM.png"/>
</a>
<a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="19356441690">
<img class="second-react-image alignnone size-full wp-image-46 jetpack-lazy-image jetpack-lazy-image--handled" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" vwo-el-id="30720362350" data-lazy-loaded="1" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/>
</a>
<a href="https://lp.logrocket.com/blg/react-signup-issue-free" target="_blank" rel="noopener noreferrer" vwo-el-id="35866400580">LogRocket
</a><p>自动聚合客户端错误、反应错误边界、还原状态、缓慢的组件加载时间、JS 异常、前端性能指标和用户交互。然后，LogRocket 使用机器学习来通知您影响大多数用户的最具影响力的问题，并提供您修复它所需的上下文。</p><p vwo-el-id="28675661060">关注重要的 React bug—<a class="signup" href="https://lp.logrocket.com/blg/react-signup-issue-free" target="_blank" rel="noopener noreferrer" vwo-el-id="40093418840">今天就试试 LogRocket】。</a></p>
</div></div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
<html>
<head>
<title>Using Flutter’s MethodChannel to invoke Kotlin code for Android </title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>使用Flutter的MethodChannel为Android调用Kotlin代码</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/using-flutters-methodchannel-invoke-kotlin-code-android/#0001-01-01">https://blog.logrocket.com/using-flutters-methodchannel-invoke-kotlin-code-android/#0001-01-01</a></blockquote><div><article class="article-post">
<p>开发一个Flutter移动应用程序需要渲染一些UI元素，这些元素会根据用户发起的触摸事件而改变，因此我们经常需要通过特定于平台的SDK来使用用户设备的硬件组件。</p>
<p>每个移动平台都提供内置的API来访问硬件组件和核心操作系统功能。例如，如果你用Kotlin构建了一个原生Android应用程序，你可以使用Android SDK中的<a href="https://developer.android.com/reference/kotlin/android/os/Vibrator" target="_blank" rel="noopener"> <code>Vibrator</code>类</a>来使用户的设备振动。</p>
<p>您可以在基于Kotlin的原生Android应用程序中使用现有的基于Kotlin/Java的共享库。但是如果你需要从你的Flutter应用程序中调用这个特定于平台的Kotlin代码呢？</p>
<p>Flutter允许您使用Dart内置的跨平台标准库来满足通用编程需求(即I/O、数学等)。).它还提供了平台通道API来与特定于平台的代码进行通信，以使用操作系统级API或调用用本机应用程序开发语言编写的代码段。</p>
<p>在本教程中，我将解释如何通过Flutter平台通道的<code>MethodChannel</code>类从Dart端调用Kotlin代码。此外，我将解释如何通过<code>EventChannel</code>进行事件驱动的颤振原生通信。</p>
<p><em>向前跳转:</em></p>

<h2 id="highlighted-features-method-channel"><code>MethodChannel</code>的突出特点</h2>
<p>Flutter为开发人员提供了<code>MethodChannel</code> Dart类，以便从Flutter环境中调用特定于平台的本机代码。此外，Flutter为您提供了将数据从本地主机应用程序代码发送回Flutter所需的API。检查<code>MethodChannel</code>提供的以下突出显示的功能:</p>
<h3>跨平台支持</h3>
<p>我们将讨论如何从Flutter调用Kotlin代码，但是Flutter框架实现允许您在iOS、Linux、macOS和Windows上调用本机代码。所以，调用Swift/Objective-C和C/C++代码也是可以的。</p>
<h3>性能优先设计</h3>
<p>与其他流行的跨平台应用开发框架不同，Flutter不使用嵌入式JavaScript执行环境。此外，它使用<a href="https://en.wikipedia.org/wiki/Ahead-of-time_compilation" target="_blank" rel="noopener"> AOT(提前)编译</a>来发布二进制文件，以实现接近本机的性能。</p>
<p>类似地，Flutter团队设计了Flutter-Native通信策略，采用性能优先的二进制消息协议，以实现更好的应用性能。因此，在Android上使用Kotlin和Dart来访问Android SDK没有明显的性能差异！</p>
<h3>双向通信支持</h3>
<p>基于Dart的<code>MethodChannel</code>类帮助您从Flutter调用特定于平台的代码。另一方面，Flutter公开了特定于平台的<code>MethodChannel</code> API，从原生端调用Dart代码。因此，您可以在Dart代码和特定于平台的本机代码之间建立一条双向通信线路。</p>
<h3>自动数据类型映射</h3>
<p>Flutter的底层平台通道API使用二进制消息传递协议，因此在Dart-to-Native通信期间，所有方法调用都被转换为字节流(参见Android类型转换实现如何使用<code>ByteBuffer</code> <a href="https://github.com/flutter/engine/blob/main/shell/platform/android/io/flutter/plugin/common/StandardMessageCodec.java" target="_blank" rel="noopener">这里</a>)。Flutter自动从字节流中删除数据记录，并在Dart和native端生成特定于语言的数据类型。因此，当使用一种语言时，即使有两种不同的环境，也可以将基于Dart的数据转换为Kotlin/Java数据，反之亦然。此外，类型转换功能可用于所有支持的平台。</p>
<h3>错误处理功能</h3>
<p>特定于平台的API通常会针对意外或失败事件抛出异常或返回错误代码。在本机端，我们可以轻松地使用本机SDK错误处理策略，但从Dart端我们能做什么呢？带有内置的错误处理支持并抛出Dart异常。此外，如果需要，可以使用异常实例中的错误代码来改进错误处理策略。</p>
<h2 id="flutter-method-channels-architecture">颤动的建筑</h2>
<p>你大概已经阅读了<code>MethodChannel</code>的概述和Flutter平台通道API的目标。颤振框架由两个关键部分组成:Dart框架和颤振引擎。</p>
<p>Dart框架由一个内置的小部件工具包实现组成，而Flutter引擎实现了嵌入Dart框架的本地主机应用。平台通道API通过双向通信线路将这两个组件连接在一起。</p>
<p><code>MethodChannel</code>实现是平台通道API的一部分，它允许您在Dart和本机代码上执行和提取命名方法的结果。</p>
<p>现在，你知道了<code>MethodChannel</code>的架构方面。你可以从<a href="https://blog.logrocket.com/complete-guide-flutter-architecture/" target="_blank" rel="noopener">这篇文章</a>和<a href="https://docs.flutter.dev/resources/architectural-overview" target="_blank" rel="noopener">官方文档</a>中了解更多关于整个Flutter架构的信息。</p>
<p>让我们开始实际应用吧！</p>
<h2 id="setting-new-project">设置新项目</h2>
<p>在本节中，我们将构建一个示例Flutter应用程序，并根据各种实际需求对其进行扩展，以了解如何使用<code>MethodChannel</code>将Kotlin和Dart连接在一起。</p>
<p>首先，使用以下命令创建一个新的颤振项目:</p>
<pre class="language-bash hljs">flutter create flutter_platform_channels_demo
cd flutter_platform_channels_demo
</pre>
<p>用<code>flutter run</code>命令运行新生成的应用程序，检查一切是否正常。</p>
<p>打开<code>android/app</code>目录可以检查原生安卓主机app源码。默认情况下，<code>flutter create</code>命令会生成一个基于Kotlin的主机应用，你可以在<code>MainActivity.kt</code>中找到Android应用的Kotlin代码。你不会在那里看到这么多代码，但是你会注意到它实现了<a href="https://github.com/flutter/engine/blob/main/shell/platform/android/io/flutter/embedding/android/FlutterActivity.java" target="_blank" rel="noopener"> <code>FlutterActivity</code>类</a>，颤振引擎的一部分。</p>
<p>现在，我们可以开始修改<code>MainActivity</code> Kotlin类来构建一个方法通道来连接Dart端。</p>
<h2 id="calling-kotlin-code-dart">从Dart调用Kotlin代码</h2>
<p>我们知道可以在Dart内生成一个随机数，但是让我们从Dart端调用Kotlin标准库的随机数生成器来开始使用<code>MethodChannel</code>。</p>
<p>首先，我们需要从Kotlin端注册一个方法调用处理程序。将以下代码添加到您的<code>MainActivity.kt</code>中:</p>
<pre class="language-kotlin hljs">package com.example.flutter_platform_channels_demo

import kotlin.random.Random
import androidx.annotation.NonNull
import io.flutter.embedding.android.FlutterActivity
import io.flutter.embedding.engine.FlutterEngine
import io.flutter.plugin.common.MethodChannel

class MainActivity: FlutterActivity() {
  override fun configureFlutterEngine(@NonNull flutterEngine: FlutterEngine) {
    super.configureFlutterEngine(flutterEngine)
    MethodChannel(flutterEngine.dartExecutor.binaryMessenger, "example.com/channel").setMethodCallHandler {
      call, result -&gt;
        if(call.method == "getRandomNumber") {
          val rand = Random.nextInt(100)
          result.success(rand)
        }
        else {
          result.notImplemented()
        }
    }
  }
}
</pre>
<p>这里，我们覆盖了来自<code>FlutterActivity</code>类的<code>configureFlutterEngine</code>方法来注册一个方法通道，用于构建与Dart的通信线路。当用特定的Android活动实例初始化Flutter引擎时，就会调用<code>configureFlutterEngine</code>方法，所以Flutter建议用它来注册方法通道处理程序。</p>
<p>方法通道就像由多个方法签名组成的命名空间，因此您可以使用一个方法通道来实现几个本机方法。在这个场景中，出于演示目的，我们实现了<code>getRandomNumber</code>方法。当特定的方法通道收到方法调用时，我们可以使用条件语句来标识方法名:</p>
<pre class="language-kotlin hljs">if(call.method == "getRandomNumber") {
    val rand = Random.nextInt(100)
    result.success(rand)
}
// ---
// ---
</pre>
<p>这里，我们使用<code>result.success</code>方法将生成的随机数返回到Dart环境。尽管我们不会故意从Dart中提供无效的方法名，但按如下方式处理未知的方法调用总是好的:</p>
<pre class="language-kotlin hljs">// ---
else {
   result.notImplemented()
}
</pre>
<p>现在，本机实现已经准备好接收来自Dart的方法调用。我们将修改Flutter的默认演示应用程序，以显示从Kotlin生成的随机数。在我们按下浮动操作按钮后，我们会看到一个新的随机数。</p>
<p>将以下代码添加到您的<code>main.dart</code>中:</p>
<pre class="language-dart hljs">import 'package:flutter/services.dart';
import 'package:flutter/material.dart';

void main() {
  runApp(const MyApp());
}

class MyApp extends StatelessWidget {
  const MyApp({super.key});
  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      title: 'Flutter Demo',
      theme: ThemeData(
        primarySwatch: Colors.blue,
      ),
      home: const MyHomePage(title: 'Flutter Demo Home Page'),
    );
  }
}

class MyHomePage extends StatefulWidget {
  const MyHomePage({super.key, required this.title});
  final String title;
  @override
  State&lt;MyHomePage&gt; createState() =&gt; _MyHomePageState();
}

class _MyHomePageState extends State&lt;MyHomePage&gt; {
  int _counter = 0;
  static const platform = MethodChannel('example.com/channel');
Future&lt;void&gt; _generateRandomNumber() async {
    int random;
    try {
      random = await platform.invokeMethod('getRandomNumber');
    } on PlatformException catch (e) {
      random = 0;
    }
setState(() {
      _counter = random;
    });
  }
  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: Text(widget.title),
      ),
      body: Center(
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: &lt;Widget&gt;[
            const Text(
              'Kotlin generates the following number:',
            ),
            Text(
              '$_counter',
              style: Theme.of(context).textTheme.headline4,
            ),
          ],
        ),
      ),
      floatingActionButton: FloatingActionButton(
        onPressed: _generateRandomNumber,
        tooltip: 'Generate',
        child: const Icon(Icons.refresh),
      ),
    );
  }
}
</pre>
<p>我们在Dart环境中创建了一个<code>MethodChannel</code>实例，如下所示:</p>
<pre class="language-dart hljs">static const platform = MethodChannel('example.com/channel');
</pre>
<p>注意，我们应该传递我们在Kotlin代码中使用的准确的方法通道名称——否则，特定的方法调用将抛出一个<code>MissingPluginException</code>。</p>
<p>当用户按下浮动操作按钮时，我们调用<code>_generateRandomNumber</code>方法。当特定的方法被调用时，应用程序通过<code>platform.invokeMethod(‘getRandomNumber’)</code>向方法通道发送消息。在内部，Flutter引擎触发方法通道处理程序，并执行我们之前编写的基于Kotlin的随机数生成代码。</p>
<p>运行应用程序并查看运行中的示例应用程序:</p>
<p><img data-attachment-id="137658" data-permalink="https://blog.logrocket.com/using-flutters-methodchannel-invoke-kotlin-code-android/attachment/flutter-sample-app/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/10/flutter-sample-app.gif" data-orig-size="730,1541" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="flutter-sample-app" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/10/flutter-sample-app-142x300.gif" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/10/flutter-sample-app-485x1024.gif" decoding="async" class="wp-image-137658 size-full aligncenter jetpack-lazy-image" src="../Images/9e9bb78ca44c010ea887b8ba1ad8f1dd.png" alt="Flutter sample app" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2022/10/flutter-sample-app.gif?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/10/flutter-sample-app.gif"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="137658" data-permalink="https://blog.logrocket.com/using-flutters-methodchannel-invoke-kotlin-code-android/attachment/flutter-sample-app/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/10/flutter-sample-app.gif" data-orig-size="730,1541" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="flutter-sample-app" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/10/flutter-sample-app-142x300.gif" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/10/flutter-sample-app-485x1024.gif" decoding="async" loading="lazy" class="wp-image-137658 size-full aligncenter" src="../Images/9e9bb78ca44c010ea887b8ba1ad8f1dd.png" alt="Flutter sample app" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/10/flutter-sample-app.gif"/></noscript>
<h2 id="returning-data-kotlin-dart">将数据从Kotlin返回到Dart</h2>
<p>在前面的例子中，我们从Kotlin向Dart返回了一个整数。当我们为一个特定的方法调用提供一个Kotlin <code>Int</code>类型时，Flutter会自动将其转换为Dart <code>int</code>类型。</p>
<p>类似地，Flutter的<code>Method Channel</code>实现自动转换所有的原子类型和一些复杂的内置对象，比如Kotlin <code>List</code>和<code>HashMap</code>。颤振文档中的下表<a href="https://docs.flutter.dev/development/platform-integration/platform-channels?tab=type-mappings-kotlin-tab#codec" target="_blank" rel="noopener">列出了所有支持的自动类型转换:</a></p>
<div>
<table>
<thead>
<tr>
<th>镖</th>
<th>科特林</th>
</tr>
</thead>
<tbody>
<tr>
<td>空</td>
<td>空</td>
</tr>
<tr>
<td>弯曲件</td>
<td>布尔代数学体系的</td>
</tr>
<tr>
<td>（同Internationalorganizations）国际组织</td>
<td>（同Internationalorganizations）国际组织</td>
</tr>
<tr>
<td>（同Internationalorganizations）国际组织</td>
<td>长的</td>
</tr>
<tr>
<td>两倍</td>
<td>两倍</td>
</tr>
<tr>
<td>String</td>
<td>String</td>
</tr>
<tr>
<td>Uint8List</td>
<td>ByteArray</td>
</tr>
<tr>
<td>Int32List</td>
<td>IntArray</td>
</tr>
<tr>
<td>Int64List</td>
<td>长数组</td>
</tr>
<tr>
<td>浮动32列表</td>
<td>漂浮阵列</td>
</tr>
<tr>
<td>Float64List列表</td>
<td>双阵列</td>
</tr>
<tr>
<td>目录</td>
<td>目录</td>
</tr>
<tr>
<td>Map</td>
<td>HashMap</td>
</tr>
</tbody>
</table>
</div>
<p>我们试着用Kotlin的<code>String</code>型，看看从镖这边会发生什么。使用下面的代码从<code>MainActivity.kt</code>中的Kotlin生成一个随机字符串:</p>
<pre class="language-kotlin hljs">override fun configureFlutterEngine(@NonNull flutterEngine: FlutterEngine) {
    super.configureFlutterEngine(flutterEngine)
    MethodChannel(flutterEngine.dartExecutor.binaryMessenger, "example.com/channel").setMethodCallHandler {
      call, result -&gt;
        if(call.method == "getRandomString") {
          val rand = ('a'..'z').shuffled().take(4).joinToString("")
          result.success(rand)
        }
        else {
          result.notImplemented()
        }
    }
  }
</pre>
<p>我们为Dart端的<code>getRandomString</code>方法返回一个四个字符长的随机字符串。现在，修改您的<code>main.dart</code>文件以接受来自Kotlin的字符串值，如下所示:</p>
<pre class="language-dart hljs">import 'package:flutter/services.dart';
import 'package:flutter/material.dart';

void main() {
  runApp(const MyApp());
}

class MyApp extends StatelessWidget {
  const MyApp({super.key});
  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      title: 'Flutter Demo',
      theme: ThemeData(
        primarySwatch: Colors.blue,
      ),
      home: const MyHomePage(title: 'Flutter Demo Home Page'),
    );
  }
}

class MyHomePage extends StatefulWidget {
  const MyHomePage({super.key, required this.title});
  final String title;
  @override
  State&lt;MyHomePage&gt; createState() =&gt; _MyHomePageState();
}

class _MyHomePageState extends State&lt;MyHomePage&gt; {
  String _counter = '';
  static const platform = MethodChannel('example.com/channel');
Future&lt;void&gt; _generateRandomString() async {
    String random = '';
    try {
      random = await platform.invokeMethod('getRandomString');
      print(random.runtimeType);
    } on PlatformException catch (e) {
      random = '';
    }
setState(() {
      _counter = random;
    });
  }
  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: Text(widget.title),
      ),
      body: Center(
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: &lt;Widget&gt;[
            const Text(
              'Kotlin generates the following string:',
            ),
            Text(
              '$_counter',
              style: Theme.of(context).textTheme.headline4,
            ),
          ],
        ),
      ),
      floatingActionButton: FloatingActionButton(
        onPressed: _generateRandomString,
        tooltip: 'Generate',
        child: const Icon(Icons.refresh),
      ),
    );
  }
}
</pre>
<p>上面的代码使用<code>print(random.runtimeType)</code>来检查<code>invokeMethod</code>方法的输出数据类型。在这种情况下，我们从Kotlin端接收一个字符串，并显示在Flutter应用程序屏幕上。运行上面的代码并按下浮动操作按钮，通过Kotlin生成随机字符串:</p>
<p><img data-attachment-id="137661" data-permalink="https://blog.logrocket.com/using-flutters-methodchannel-invoke-kotlin-code-android/attachment/generate-random-strings-kotlin/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/10/generate-random-strings-Kotlin.gif" data-orig-size="730,1541" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="generate-random-strings-Kotlin" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/10/generate-random-strings-Kotlin-142x300.gif" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/10/generate-random-strings-Kotlin-485x1024.gif" decoding="async" class="aligncenter wp-image-137661 size-full jetpack-lazy-image" src="../Images/afd65869ed3660e4ae4ab16b11e530b7.png" alt="generate random strings via Kotlin" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2022/10/generate-random-strings-Kotlin.gif?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/10/generate-random-strings-Kotlin.gif"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="137661" data-permalink="https://blog.logrocket.com/using-flutters-methodchannel-invoke-kotlin-code-android/attachment/generate-random-strings-kotlin/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/10/generate-random-strings-Kotlin.gif" data-orig-size="730,1541" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="generate-random-strings-Kotlin" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/10/generate-random-strings-Kotlin-142x300.gif" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/10/generate-random-strings-Kotlin-485x1024.gif" decoding="async" loading="lazy" class="aligncenter wp-image-137661 size-full" src="../Images/afd65869ed3660e4ae4ab16b11e530b7.png" alt="generate random strings via Kotlin" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/10/generate-random-strings-Kotlin.gif"/></noscript>
<p>如果你检查你的终端屏幕，你应该看到<code>print</code>函数输出<code>String</code>作为<code>random</code>变量的数据类型；如果是这样，那么我们知道类型转换起作用了。</p>
<p>尝试其他原始数据类型。我将在本教程的下一节解释如何在Kotlin和Dart之间传输复杂的数据类型和对象。</p>
<h2 id="passing-arguments-dart-kotlin">将参数从Dart传递到Kotlin</h2>
<p>我们已经讨论了如何通过<code>success</code>方法调用从Kotlin返回数据。如果需要从Dart向Kotlin发送一些数据怎么办？</p>
<p>当我们用特定的编程语言调用方法时，我们通常使用方法参数——同样的方法也适用于Flutter方法通道！您可以使用Dart动态映射通过<code>invokeMethod</code>方法传递命名参数。</p>
<p>假设您必须从Dart端配置随机字符串生成过程。例如，我们可以从Flutter应用程序代码中发送字符串长度和前缀。</p>
<p>首先，确定所需的参数:</p>
<ul>
<li><code>len</code>:随机字符串长度</li>
<li><code>prefix</code>:随机字符串的前缀</li>
</ul>
<p>通过<code>_generateRandomString</code>发送这些参数值:</p>
<pre class="language-dart hljs">Future&lt;void&gt; _generateRandomString() async {
    String random = '';
    try {
      var arguments = {
        'len': 3,
        'prefix': 'fl_',
      };
      random = await platform.invokeMethod('getRandomString', arguments);
    } on PlatformException catch (e) {
      random = '';
    }
setState(() {
      _counter = random;
    });
  }
</pre>
<p>接下来，更新Kotlin代码以使用命名参数:</p>
<pre class="language-kotlin hljs">if(call.method == "getRandomString") {
  val limit = call.argument("len") ?: 4
  val prefix = call.argument("prefix") ?: ""
  val rand = ('a'..'z')
                .shuffled()
                .take(limit)
                .joinToString(prefix = prefix, separator = "")
  result.success(rand)
}
</pre>
<p>上面的代码使用Kotlin的<a href="https://kotlinlang.org/docs/null-safety.html#elvis-operator" target="_blank" rel="noopener">猫王运算符<code>[?:]</code> </a>为<code>limit</code>和<code>prefix</code>常量设置默认值。运行应用程序。您将看到基于我们从方法通道的Dart端提供的参数的随机字符串:</p>
<p><img data-attachment-id="137663" data-permalink="https://blog.logrocket.com/using-flutters-methodchannel-invoke-kotlin-code-android/attachment/random-strings-parameters-provided-dart-side/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/10/random-strings-parameters-provided-dart-side.gif" data-orig-size="730,1541" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="random-strings-parameters-provided-dart-side" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/10/random-strings-parameters-provided-dart-side-142x300.gif" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/10/random-strings-parameters-provided-dart-side-485x1024.gif" decoding="async" class="aligncenter wp-image-137663 size-full jetpack-lazy-image" src="../Images/2922582f516c5077708331f2e139bbec.png" alt="Random strings based on parameters we’ve provided from the Dart side of the method channel" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2022/10/random-strings-parameters-provided-dart-side.gif?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/10/random-strings-parameters-provided-dart-side.gif"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="137663" data-permalink="https://blog.logrocket.com/using-flutters-methodchannel-invoke-kotlin-code-android/attachment/random-strings-parameters-provided-dart-side/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/10/random-strings-parameters-provided-dart-side.gif" data-orig-size="730,1541" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="random-strings-parameters-provided-dart-side" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/10/random-strings-parameters-provided-dart-side-142x300.gif" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/10/random-strings-parameters-provided-dart-side-485x1024.gif" decoding="async" loading="lazy" class="aligncenter wp-image-137663 size-full" src="../Images/2922582f516c5077708331f2e139bbec.png" alt="Random strings based on parameters we’ve provided from the Dart side of the method channel" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/10/random-strings-parameters-provided-dart-side.gif"/></noscript>
<p>进一步尝试使用不同的方法参数值，并尝试添加更多的参数。如果你需要传递一个方法参数，你可以直接传递特定的参数，而不需要创建一个动态映射来获得更好的可读性。查看以下代码片段如何发送随机字符串长度:</p>
<pre class="language-kotlin hljs">// Dart:
random = await platform.invokeMethod('getRandomString', 3);

// Kotlin
val limit = call.arguments() ?: 4
val rand = ('a'..'z')
              .shuffled()
              .take(limit)
              .joinToString("")
result.success(rand)
</pre>
<h2 id="error-handling-strategies">错误处理策略</h2>
<p>编程中有两种主要的错误处理策略:基于错误代码的和基于异常的。一些程序员混合使用两种错误处理策略。</p>
<p>对于Kotlin端的错误流，具有处理Dart异常的内置支持。此外，它还提供了一种在异常实例中用错误代码区分本机错误类型的方法。换句话说，<code>MethodChannel</code>为Flutter开发者提供了一种混合的错误处理策略。</p>
<p>在前面的例子中，我们使用<code>result.success</code>方法返回值，使用<code>result.notImplemented</code>处理未知的方法调用，这将在Dart中抛出<code>MissingPluginException</code>。</p>
<p>如果我们需要从Kotlin端创建一个Dart异常怎么办？方法<code>result.error</code>帮助你从Kotlin抛出一个Dart <code>PlatformException</code>实例。假设我们需要抛出一个异常，如果我们在前面的例子中为随机字符串长度提供了一个负值。</p>
<p>首先，按如下方式更新Kotlin代码，将异常通知Dart:</p>
<pre class="language-kotlin hljs">if(call.method == "getRandomString") {
  val limit = call.arguments() ?: 4
  if(limit &lt; 0) {
    result.error("INVALIDARGS", "String length should not be a negative integer", null)
  }
  else {
    val rand = ('a'..'z')
                  .shuffled()
                  .take(limit)
                  .joinToString("")
    result.success(rand)
  }
}
</pre>
<p>这里，我们通过<code>result.error</code>提供一个唯一的异常代码和消息。接下来，捕获异常并在Dart端使用它，如下所示:</p>
<pre class="language-dart hljs">Future&lt;void&gt; _generateRandomString() async {
    String random = '';
    try {
      random = await platform.invokeMethod('getRandomString', -5);
    } on PlatformException catch (e) {
      random = '';
      print('PlatformException: ${e.code} ${e.message}');
    }
    setState(() {
      _counter = random;
    });
  }
</pre>
<p>当您运行应用程序并按下浮动操作按钮时，您将在终端上看到异常代码和消息，因为我们从Dart端将<code>-5</code>作为字符串长度传递:</p>
<p><img data-attachment-id="137668" data-permalink="https://blog.logrocket.com/using-flutters-methodchannel-invoke-kotlin-code-android/attachment/exception-code/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/10/exception-code.gif" data-orig-size="730,240" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="exception-code" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/10/exception-code-300x99.gif" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/10/exception-code.gif" decoding="async" class="aligncenter wp-image-137668 size-full jetpack-lazy-image" src="../Images/fa892339bd502eb84b383c3c13b781fe.png" alt="Exception code" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2022/10/exception-code.gif?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/10/exception-code.gif"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="137668" data-permalink="https://blog.logrocket.com/using-flutters-methodchannel-invoke-kotlin-code-android/attachment/exception-code/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/10/exception-code.gif" data-orig-size="730,240" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="exception-code" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/10/exception-code-300x99.gif" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/10/exception-code.gif" decoding="async" loading="lazy" class="aligncenter wp-image-137668 size-full" src="../Images/fa892339bd502eb84b383c3c13b781fe.png" alt="Exception code" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/10/exception-code.gif"/></noscript>
<p>正如我们在上面的例子中看到的，您可以在Dart中捕获<code>PlatformException</code>，并且可以在异常实例中检查错误代码，以处理方法通道错误。另一种更抽象的方法是基于Kotlin错误代码创建自己的异常实例。检查Flutter相机插件的<code><a href="https://github.com/flutter/plugins/blob/main/packages/camera/camera_platform_interface/lib/src/types/camera_exception.dart" target="_blank" rel="noopener">CameraException</a></code>作为参考实现。</p>
<h2 id="invoking-native-sdk-functions-method-channel">通过<code>MethodChannel</code>调用原生SDK函数</h2>
<p>现在，我们知道如何使用<code>MethodChannel</code>从Dart调用Kotlin代码。在之前的演示中，我们已经使用了Kotlin的标准库特性。类似地，您可以在Flutter平台通道中重用预先实现的Kotlin/Java库。方法通道也可以使用原生SDK，这是Flutter平台通道实现的主要目标。</p>
<p>Flutter已经支持系统黑暗主题处理，并有其他原生SDK的插件，但让我们调用一些原生SDK APIs来进一步理解<code>MethodChannel</code>用例。</p>
<p>我们将编写一个本地方法来检查黑暗主题是否打开。首先，在你的<code>MainActivity.kt</code>中用Kotlin实现一个新的颤振方法通道:</p>
<pre class="language-kotlin hljs">package com.example.flutter_platform_channels_demo

import kotlin.random.Random
import androidx.annotation.NonNull
import android.content.res.Configuration
import io.flutter.embedding.android.FlutterActivity
import io.flutter.embedding.engine.FlutterEngine
import io.flutter.plugin.common.MethodChannel

class MainActivity: FlutterActivity() {
  override fun configureFlutterEngine(@NonNull flutterEngine: FlutterEngine) {
    super.configureFlutterEngine(flutterEngine)
    MethodChannel(flutterEngine.dartExecutor.binaryMessenger, "example.com/channel").setMethodCallHandler {
      call, result -&gt;sucess
        if(call.method == "isDarkMode") {
          val mode = getContext()
                        .getResources()
                        .getConfiguration().uiMode and Configuration.UI_MODE_NIGHT_MASK
          result.success(mode == Configuration.UI_MODE_NIGHT_YES)
        }
        else {
          result.notImplemented()
        }
    }
  }
}
</pre>
<p>这里我们使用Android SDK的配置API中的<a href="https://developer.android.com/reference/android/content/res/Configuration#uiMode" target="_blank" rel="noopener"> <code>uiMode</code>位掩码</a>来检测系统主题。接下来，通过更新<code>_MyHomePageState</code>实现来使用Dart中的<code>isDarkMode</code>方法:</p>
<pre class="language-dart hljs">class _MyHomePageState extends State&lt;MyHomePage&gt; {
  String _theme = '';
  static const platform = MethodChannel('example.com/channel');
  Future&lt;void&gt; _findColorTheme() async {
    bool isDarkMode;
    try {
      isDarkMode = await platform.invokeMethod('isDarkMode');
    } on PlatformException catch (e) {
      isDarkMode = false;
      print('PlatformException: ${e.code} ${e.message}');
    }
  setState(() {
      _theme = isDarkMode ? 'dark' : 'light';
    });
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: Text(widget.title),
      ),
      body: Center(
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: &lt;Widget&gt;[
            const Text(
              'System color theme:',
            ),
            Text(
              _theme,
              style: Theme.of(context).textTheme.headline4,
            ),
          ],
        ),
      ),
      floatingActionButton: FloatingActionButton(
        onPressed: _findColorTheme,
        tooltip: 'Find color theme',
        child: const Icon(Icons.refresh),
      ),
    );
  }
}
</pre>
<p>通过更改系统颜色主题来测试应用程序，如下所示:</p>
<p><img data-attachment-id="137676" data-permalink="https://blog.logrocket.com/using-flutters-methodchannel-invoke-kotlin-code-android/attachment/dark-theme-display/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/10/dark-theme-display.gif" data-orig-size="730,1541" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="dark-theme-display" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/10/dark-theme-display-142x300.gif" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/10/dark-theme-display-485x1024.gif" decoding="async" class="aligncenter wp-image-137676 size-full jetpack-lazy-image" src="../Images/781449894d572554d190773647eee6b1.png" alt="Dark theme display" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2022/10/dark-theme-display.gif?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/10/dark-theme-display.gif"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="137676" data-permalink="https://blog.logrocket.com/using-flutters-methodchannel-invoke-kotlin-code-android/attachment/dark-theme-display/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/10/dark-theme-display.gif" data-orig-size="730,1541" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="dark-theme-display" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/10/dark-theme-display-142x300.gif" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/10/dark-theme-display-485x1024.gif" decoding="async" loading="lazy" class="aligncenter wp-image-137676 size-full" src="../Images/781449894d572554d190773647eee6b1.png" alt="Dark theme display" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/10/dark-theme-display.gif"/></noscript>
<p>同样，你可以通过Flutter平台通道从Dart调用任何Android SDK APIs。</p>
<h2 id="using-event-channel-class">使用<code>EventChannel</code>类</h2>
<p>与传统的RESTful APIs一样，<code>MethodChannel</code>类提供了基于请求-响应的通信解决方案。如果我们在使用web应用程序时需要从服务器调用客户机，该怎么办？然后，我们倾向于选择像<a href="https://blog.logrocket.com/websockets-two-way-communication-react-app/" target="_blank" rel="noopener"> WebSockets </a>这样的事件驱动的通信机制。<code>EventChannel</code>类提供了异步事件流，用于在本地主机应用程序和Flutter之间建立事件驱动的通信线路。<code>EventChannel</code>类主要用于将本地事件发送到Dart端。</p>
<p>例如，我们可以将系统主题更改事件从Kotlin调度到Dart。此外，我们可以使用<code>EventChannel</code>来广播来自设备传感器的频繁事件。</p>
<p>之前，我们必须按下浮动操作按钮来检测当前的系统颜色主题。现在，我们将通过添加一个<code>EventChannel</code>实例来自动处理它，从而改进我们的应用程序。</p>
<p>首先，将以下代码添加到您的<code>MainActivity.kt</code>中:</p>
<pre class="language-kotlin hljs">package com.example.flutter_platform_channels_demo

import kotlin.random.Random
import androidx.annotation.NonNull
import android.os.Bundle
import android.content.res.Configuration
import android.content.pm.ActivityInfo
import io.flutter.embedding.android.FlutterActivity
import io.flutter.embedding.engine.FlutterEngine
import io.flutter.plugin.common.EventChannel
import io.flutter.plugin.common.EventChannel.EventSink
import io.flutter.plugin.common.EventChannel.StreamHandler

class MainActivity: FlutterActivity() {
  var events: EventSink? = null
  var oldConfig: Configuration? = null

  override fun onCreate(savedInstanceState: Bundle?) {
    super.onCreate(savedInstanceState)
    oldConfig = Configuration(getContext().getResources().getConfiguration())
  }

  override fun configureFlutterEngine(@NonNull flutterEngine: FlutterEngine) {
    super.configureFlutterEngine(flutterEngine)
EventChannel(flutterEngine.dartExecutor.binaryMessenger, "example.com/channel").setStreamHandler(
      object: StreamHandler {
        override fun onListen(arguments: Any?, es: EventSink) {
          events = es
          events?.success(isDarkMode(oldConfig))
        }
        override fun onCancel(arguments: Any?) {
        }
      }
    );
  }

  override fun onConfigurationChanged(newConfig: Configuration) {
    super.onConfigurationChanged(newConfig)
    if(isDarkModeConfigUpdated(newConfig)) {
      events?.success(isDarkMode(newConfig))
    }
    oldConfig = Configuration(newConfig)
  }

  fun isDarkModeConfigUpdated(config: Configuration): Boolean {
    return (config.diff(oldConfig) and ActivityInfo.CONFIG_UI_MODE) != 0
      &amp;&amp; isDarkMode(config) != isDarkMode(oldConfig);
  }

  fun isDarkMode(config: Configuration?): Boolean {
    return config!!.uiMode and Configuration.UI_MODE_NIGHT_MASK == Configuration.UI_MODE_NIGHT_YES
  }
}
</pre>
<p>我们使用<code>EventChannel</code>类来创建事件驱动的通信流。一旦附加了<code>EventChannel</code>处理程序，我们就可以使用<code>EventSink</code>实例向Dart端发送事件。事件在以下情况下发生:</p>
<ul>
<li>当Flutter应用程序初始化时，事件通道将接收一个具有当前主题状态的新事件</li>
<li>当用户从设置应用程序更改系统主题后返回应用程序时，事件通道将收到一个带有当前主题状态的新事件</li>
</ul>
<p>注意，这里我们使用一个布尔值作为事件有效载荷来标识黑暗模式是否被激活。现在，将以下代码添加到您的<code>main.dart</code>文件中，并完成实现:</p>
<pre class="language-dart hljs">import 'package:flutter/services.dart';
import 'package:flutter/material.dart';

void main() {
  runApp(const MyApp());
}

class MyApp extends StatelessWidget {
  const MyApp({super.key});
  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      title: 'Flutter Demo',
      theme: ThemeData(),
      darkTheme: ThemeData.dark(),
      themeMode: ThemeMode.system,
      home: const MyHomePage(title: 'Flutter Demo Home Page'),
    );
  }
}

class MyHomePage extends StatefulWidget {
  const MyHomePage({super.key, required this.title});
  final String title;
  @override
  State&lt;MyHomePage&gt; createState() =&gt; _MyHomePageState();
}

class _MyHomePageState extends State&lt;MyHomePage&gt; {
  String _theme = '';
  static const events = EventChannel('example.com/channel');

  @override
  void initState() {
    super.initState();
    events.receiveBroadcastStream().listen(_onEvent);
  }
  void _onEvent(Object? event) {
    setState(() {
      _theme = event == true ? 'dark' : 'light';
    });
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: Text(widget.title),
      ),
      body: Center(
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: &lt;Widget&gt;[
            const Text(
              'System color theme:',
            ),
            Text(
              _theme,
              style: Theme.of(context).textTheme.headline4,
            ),
          ],
        ),
      ),
    );
  }
}
</pre>
<p>上面的代码与我们之前创建的事件通道连接，并显示当前主题。每当从Kotlin端接收到新事件时，<code>EventChannel</code>实现就会触发<code>_onEvent</code>回调。</p>
<p>运行应用程序并激活/禁用黑暗模式。您应该会在应用程序屏幕上看到主题名称，如以下预览所示:</p>
<p><img data-attachment-id="137681" data-permalink="https://blog.logrocket.com/using-flutters-methodchannel-invoke-kotlin-code-android/attachment/deactivating-dark-mode/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/10/deactivating-dark-mode.gif" data-orig-size="730,1541" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="deactivating-dark-mode" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/10/deactivating-dark-mode-142x300.gif" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/10/deactivating-dark-mode-485x1024.gif" decoding="async" class="aligncenter wp-image-137681 size-full jetpack-lazy-image" src="../Images/5047604d20dd58da0b13e26bcdfe1e7e.png" alt="Deactivating dark mode" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2022/10/deactivating-dark-mode.gif?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/10/deactivating-dark-mode.gif"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="137681" data-permalink="https://blog.logrocket.com/using-flutters-methodchannel-invoke-kotlin-code-android/attachment/deactivating-dark-mode/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/10/deactivating-dark-mode.gif" data-orig-size="730,1541" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="deactivating-dark-mode" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/10/deactivating-dark-mode-142x300.gif" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/10/deactivating-dark-mode-485x1024.gif" decoding="async" loading="lazy" class="aligncenter wp-image-137681 size-full" src="../Images/5047604d20dd58da0b13e26bcdfe1e7e.png" alt="Deactivating dark mode" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/10/deactivating-dark-mode.gif"/></noscript>
<p>你会注意到应用程序的配色方案根据当前主题进行了更改。发生这种行为是因为我们用<code>ThemeMode.system</code>代替<code>themeMode</code>来使Flutter应用程序响应当前的系统主题，而这种行为不是使用<code>EventChannel</code> API的结果。</p>
<h2 id="sending-receiving-complex-objects">发送/接收复杂对象</h2>
<p>Flutter platform channels API自动转换内置的复杂类型，比如地图和列表。但是，在某些场景中，我们需要传递带有许多数据记录的更复杂的对象。您可以考虑以下策略来发送/接收此类复杂对象:</p>
<ul>
<li>将对象数据作为具有原始数据类型的地图进行传输。你可以写一个助手/工具方法来把你的复杂对象转换成一个地图</li>
<li>将对象序列化为与平台无关的格式，如JSON，并在使用前反序列化它</li>
<li>为序列化/反序列化编写自定义编解码器。检查<code><a href="//github.com/firebase/flutterfire/blob/3a3e52123f04eac6d73c21474155e6e67cb357c1/packages/cloud_firestore/cloud_firestore_platform_interface/lib/src/method_channel/utils/firestore_message_codec.dart#L24" target="_blank" rel="noopener">FirestoreMessageCodec</a></code>作为参考实现</li>
</ul>
<h3 id="packaging-native-code-modifications">打包本机代码修改</h3>
<p>Flutter允许您修改本机主机应用程序，并通过平台通道API建立与Dart的通信线路。在本教程中，我们通过直接更新基于Kotlin的主机应用程序来学习<code>MethodChannel</code>。您也可以使用相同的方法来重用您的Kotlin/Java库，调用Android SDK APIs，或者调用任何Kotlin代码段。在大多数情况下，您可以在其他Flutter应用程序中重用本机代码修改。</p>
<p>例如，如果你使用<code>MethodChannel</code>来振动用户的设备，你可能需要在你的其他应用程序中使用相同的原生实现。Flutter SDK提供了一个全功能的插件系统来创建、发布和集成可共享的插件。</p>
<p>假设你需要在多个Flutter apps中使用基于Kotlin的随机数生成器方法。然后，你可以创建一个Flutter插件并导入它，而不是修改每个原生主机应用程序。查看<a href="https://docs.flutter.dev/development/packages-and-plugins/developing-packages" target="_blank" rel="noopener">官方文档</a>开始开发颤振插件，检查<code><a href="https://github.com/flutter/plugins/tree/main/packages/shared_preferences/shared_preferences" target="_blank" rel="noopener">shared_preferences</a></code>插件了解推荐的颤振插件结构。</p>
<h2 id="method-channel-vs-event-channel-vs-basic-message-channel"><code>MethodChannel</code>对<code>EventChannel</code>对<code>BasicMessageChannel</code></h2>
<p><code>BasicMessageChannel</code>类也是Flutter平台通道API的一部分。它帮助您使用自定义编解码器实现低级通信线路。为连接Kotlin和Dart选择最合适的平台通道类将有助于激励您保持代码库的可读性、高效性和最小化。</p>
<p>看下面的对比表:</p>
<div>
<table>
<thead>
<tr>
<th>比较因素</th>
<th><code>MethodChannel</code></th>
<th><code>EventChannel</code></th>
<th><code>BasicMessageChannel</code></th>
</tr>
</thead>
<tbody>
<tr>
<td>通信类型</td>
<td>请求-响应(类似RPC)类型的方法调用</td>
<td>事件驱动流</td>
<td>低级消息</td>
</tr>
<tr>
<td>方向</td>
<td>双向的</td>
<td>双向的</td>
<td>双向的</td>
</tr>
<tr>
<td>一个通用用例示例</td>
<td>调用本机代码</td>
<td>订阅本地事件</td>
<td>实现自定义编解码器</td>
</tr>
</tbody>
</table>
</div>
<h2 id="conclusion">结论</h2>
<p>在本教程中，我们研究了Flutter平台通道API，并用实际例子测试了<code>MethodChannel</code>类。此外，我们还熟悉了<code>EventChannel</code>类，它帮助我们使用本地主机应用程序创建事件驱动的通信流。本教程着重于从Flutter调用Kotlin代码，但是Flutter框架也允许您调用其他平台语言。</p>
<p>我们通常需要调用Kotlin代码来重用它或者调用Android SDK函数。如果您已经从原生Android应用程序迁移到Flutter，但您仍然有大量业务逻辑编写在Kotlin/Java包中，或者您需要重用您基于Java的web API的业务逻辑，您可以使用<code>MethodChannel</code>高效地调用您现有的Kotlin代码。对于大多数Android SDK功能，你可以找到预先实现的插件。因此，在创建用于调用原生SDK的<code>MethodChannel</code>之前，检查现有的开源社区插件。</p>
<p><code>MethodChannel</code> API不提供代码生成，所以我们必须使用条件语句来区分方法调用，并通过动态Dart映射传递参数。此外，它不能保证类型安全。如果你寻找这样的功能，请查看<a href="https://pub.dev/packages/pigeon" target="_blank" rel="noopener"> <code>pigeon</code>套餐</a>。</p>
<p>总的来说，<code>MethodChannel</code> API是一个高效的、最小的、动态的、内置的机制，我们可以用它从你的Flutter应用中调用Kotlin代码。</p><div class="code-block code-block-32">
<div class="blog-plug inline-plug kotlin-plug"><h2>LogRocket :即时重现你的安卓应用中的问题。</h2><a class="signup" href="https://lp.logrocket.com/blg/kotlin-signup" target="_blank" rel="noopener noreferrer"><img class="alignnone size-full wp-image-46 jetpack-lazy-image" src="../Images/b5ae4bd0ecde7aa9d5288746416d5e18.png" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2022/11/react-native-plug_android-1.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/11/react-native-plug_android-1.png"/><noscript><img data-lazy-fallback="1" class="alignnone size-full wp-image-46" src="../Images/b5ae4bd0ecde7aa9d5288746416d5e18.png" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/11/react-native-plug_android-1.png"/></noscript></a><p><a href="https://lp.logrocket.com/blg/kotlin-signup" target="_blank" rel="noopener noreferrer"> LogRocket </a>是一款Android监控解决方案，可以帮助您即时重现问题，确定bug的优先级，并了解您的Android应用程序的性能。</p><p>LogRocket还可以向你展示用户是如何与你的应用程序互动的，从而帮助你提高转化率和产品使用率。LogRocket的产品分析功能揭示了用户不完成特定流程或不采用新功能的原因。</p><p>开始主动监控您的Android应用程序— <a class="signup" href="hhttps://lp.logrocket.com/blg/kotlin-signup" target="_blank" rel="noopener noreferrer">免费试用LogRocket】。</a></p></div>
</div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
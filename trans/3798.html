<html>
<head>
<title>A guide to R8 and code shrinking in Android </title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>Android中的R8和代码缩减指南</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/r8-code-shrinking-android-guide/#0001-01-01">https://blog.logrocket.com/r8-code-shrinking-android-guide/#0001-01-01</a></blockquote><div><article class="article-post">
<p>代码收缩是一种方法，它允许我们通过删除未使用的代码或重构现有代码来生成更小的apk，从而减少占用空间。除了收缩，混淆是另一种策略，让我们能够保护我们的Android应用程序免受逆向工程。</p>
<p>使用这两种策略将确保你的应用程序下载更快，更难被他人修改。</p>
<p>在本帖中，我们将讨论:</p>

<h2 id="r8-vs-proguard">R8对普罗瓜德</h2>
<p>在Android的早期版本中，代码收缩和优化被委托给一个名为<a href="https://www.guardsquare.com/proguard"> Proguard </a>的工具。不过从Android Gradle Plugin (AGP) v 3.4.0开始，Android就使用了<a href="https://android-developers.googleblog.com/2018/11/r8-new-code-shrinker-from-google-is.html"> R8编译器</a>。</p>
<p>虽然这两个工具都有助于代码压缩，但R8的功能比代码收缩更丰富。首先，R8对Kotlin的支持有限，而Proguard是为Java工具链构建的。R8实现了比Proguard更好的内联和概述(将公共代码提取到函数中),而后者在传播常量参数方面更好。</p>
<p>说到实际的代码压缩过程，R8的性能更好，实现了10%的压缩，而Proguard的压缩只有8.5%。</p>
<h2 id="stages-r8">R8的舞台</h2>
<p>R8编译器会做各种事情来减小最终APK的大小。其中包括:</p>
<ul>
<li><strong>解糖</strong>:这让我们可以使用Java 8和更高版本的API特性，而不用担心支持问题，R8编译器会处理将代码中使用的新特性回移植到旧的java APIs。</li>
<li>代码收缩:这是R8从你的应用中移除未使用代码的阶段，包括库依赖中未使用的代码</li>
<li><strong>资源收缩</strong>:一旦完成收缩代码，R8识别出未使用的资源，并删除未使用的字符串、drawables等。</li>
<li><strong>混淆:</strong>在这个阶段，R8确保你的类和它们的字段被重命名，也可能被重新打包，以防止逆向工程。这个过程会生成一个映射文件，如果需要的话，可以用它来重新获得实际的实体名称</li>
<li><strong>优化代码</strong>:在代码优化过程中，R8通过删除代码中不可到达的分支(而不是类/文件)来减少应用程序的占用空间和/或进一步提高效率。它使用了高级的优化规则，比如当只从一个地方调用一个方法时，在调用点内联该方法<ul>
<li>其他技术包括垂直类合并，其中，如果一个接口只有一个实现，它将两者合并在一个类下</li>
</ul>
</li>
</ul>
<p>一旦完成上述所有步骤，R8通过一个称为dexing的过程将字节码转换成dexcode。早期，这是D8编译器的一部分，但现在已经集成到R8编译器中。</p>
<p>现在我们对R8编译器有了一些了解，让我们看看代码收缩实际上是如何工作的。</p>
<h2 id="configuringcodeshrinking">配置代码收缩</h2>
<p>在Android中，我们可以通过在你的<code>build.gradle</code>文件中设置<code>minifyEnabled</code>标志为<code>true</code>来配置代码收缩。或者，您也可以启用<code>shrinkResources</code>来删除不需要的资源。</p>
<pre class="language-kotlin hljs">buildTypes{
        release{
            minifyEnabled true
            shrinkResources true
        proguardFiles getDefaultProguardFile('proguard-android-optimize.txt                           '), 'proguard-rules.pro'
        }
}
</pre>
<p>代码收缩从检查所谓的入口点开始。入口点在配置文件中声明，并通过<code>build.gradle</code>中的<code>proguardFiles</code>参数可用。</p>
<p>一旦R8有了一组入口点，它就开始搜索从这些入口点可以到达的所有类和实体。它继续构建这种令牌的列表。任何不可到达的令牌都将从最终输出中去除。</p>
<p>这一过程通常不是万无一失的，因为:</p>
<ul>
<li>我们的一些代码可能使用反射来查找类，这使得编译器很难知道某个特定的类是否被使用</li>
<li>您的应用程序可能会通过JNI从本机调用方法。由于R8被设计为处理Kotlin/Java代码而不是本地代码，我们需要指导它保留这些类</li>
</ul>
<p>这些入口点中有许多是在通过AGP插件提供的<code>proguard-android-optimize.txt</code>文件中定义的。这是它的部分快照:</p>
<p><img data-attachment-id="154620" data-permalink="https://blog.logrocket.com/r8-code-shrinking-android-guide/attachment/entry-points-defined-agp/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2023/01/entry-points-defined-agp.png" data-orig-size="730,242" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="entry-points-defined-agp" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2023/01/entry-points-defined-agp-300x99.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2023/01/entry-points-defined-agp.png" decoding="async" class="aligncenter size-full wp-image-154620 jetpack-lazy-image" src="../Images/751ebee8fa59fc23ea38679d5a5ba087.png" alt="The entry points are defined in the proguard-android-optimize file" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2023/01/entry-points-defined-agp.png 730w, https://blog.logrocket.com/wp-content/uploads/2023/01/entry-points-defined-agp-300x99.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2023/01/entry-points-defined-agp.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2023/01/entry-points-defined-agp.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="154620" data-permalink="https://blog.logrocket.com/r8-code-shrinking-android-guide/attachment/entry-points-defined-agp/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2023/01/entry-points-defined-agp.png" data-orig-size="730,242" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="entry-points-defined-agp" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2023/01/entry-points-defined-agp-300x99.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2023/01/entry-points-defined-agp.png" decoding="async" loading="lazy" class="aligncenter size-full wp-image-154620" src="../Images/751ebee8fa59fc23ea38679d5a5ba087.png" alt="The entry points are defined in the proguard-android-optimize file" srcset="https://blog.logrocket.com/wp-content/uploads/2023/01/entry-points-defined-agp.png 730w, https://blog.logrocket.com/wp-content/uploads/2023/01/entry-points-defined-agp-300x99.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2023/01/entry-points-defined-agp.png"/></noscript>
<p>让我们回顾一下上面两条规则的含义:</p>
<ol>
<li>保留getters和setters在扩展<code>View</code>的类中出现的所有函数，因此也保留了<code>View</code>类</li>
<li>保留与接收单个<code>View</code>参数的签名相匹配的所有活动函数，即XML中使用的click listeners，它是反射式查找的</li>
</ol>
<p>接下来，让我们了解一下为R8提供动力的模式。</p>
<h2 id="understanding-proguard-rule-schema">了解Proguard规则模式</h2>
<p>尽管我们将这些作为Proguard规则来讨论，但它们也是配置R8的相同规则。让我们更深入地研究如何编写它们。</p>
<p>典型的R8或普罗瓜德规则由三部分组成:</p>
<ol>
<li><strong>保留选项:</strong>保留选项定义为“谁”保留，如下所示:<ul>
<li>确保我们保留符合规则的目标</li>
<li>确保我们保留符合规则的类别</li>
<li><code>keepclasswithmembers</code>保留其成员符合规则的类</li>
<li>类似地，我们必须<code>keepclassmembers</code>只保留一个类的成员</li>
</ul>
</li>
<li><strong>令牌类型</strong>:表示我们规则的目标实体的类型，即<code>class</code>、<code>enum</code>或<code>interface</code></li>
<li><strong>通配符</strong>:这些通配符允许我们定义不同的格式来匹配不同的令牌，如下所示:</li>
</ol>
<p>这是因为我们的第一个通配符匹配器<code>*</code>匹配<code>Task</code>和<code>Storage</code>，我们可以重用它们来定义函数名的动态部分。</p>
<h2 id="writing-your-own-r8-rules">写你自己的R8规则</h2>
<p>通过AGP发货的R8或Proguard规则通常是足够的，但是，可能需要编写您自己的规则。在编写R8规则时，我们应该努力避免在keep规则中包含超出需要的内容，以确保我们可以压缩大部分代码。此外，我们指定的所有类都需要完全限定，也就是说，它们必须包含包名。</p>
<p>通常，XML文件中使用的枚举是被R8剔除的罪魁祸首。但是我们可以定义自己规则来保持它们，如下所示:</p>
<pre class="language-kotlin hljs">-keep enum com.demo.main.MediaType{ *; }
</pre>
<blockquote><p>注意:大括号中的<code>{*;}</code>意味着我们打算保留类/枚举的所有成员。</p></blockquote>
<p>另一个规则是保留类构造函数；以下是使用关键字<code>init</code>的方法:</p>
<pre class="language-kotlin hljs">-keep public class * extends android.view.View {
    public &lt;init&gt;(android.content.Context);
}
</pre>
<p>有时候，您的应用程序中可能包含一些实体，这些实体通过它们在jars中的完全限定名被反射性地查找。您可能希望只保留名称，防止R8混淆或重命名该类。您可以使用<code>keepnames</code>限定符来保留名称:</p>
<pre class="language-kotlin hljs">-keepnames class com.ext.library.ServiceProvider
</pre>
<p>保留类的另一种方法是用<code>@Keep</code>注释对它们进行注释。这些类通过<a href="https://github.com/androidx/androidx/blob/androidx-main/annotation/annotation/src/jvmMain/resources/META-INF/proguard/androidx-annotations.pro"> <code>androidx.annotation</code>库</a> Proguard规则保留。但是，您只能在您控制的源代码上使用它；此外，这是一个更通用的解决方案，会导致包含不使用的成员。</p>
<h2 id="resource-shrinking">资源萎缩</h2>
<p>资源收缩通常在代码收缩之后完成，但是我们可以使用<code>res/raw</code>文件夹中的<code>keep.xml</code>来指定资源保留，而不是使用Proguard规则。我们一般不需要这个，除非我们正在通过<a href="https://developer.android.com/reference/android/content/res/Resources#getIdentifier(java.lang.String,%20java.lang.String,%20java.lang.String)"> <code>Resources.getIdentifier()</code> </a>寻找资源。</p>
<p>在这种情况下，资源收缩器的行为是保守的。下面是一个例子:</p>
<pre class="language-kotlin hljs">val name = String.format("ic_%1d", angle + 1)
val res = resources.getIdentifier(name, "drawable", packageName)
</pre>
<p>收缩器使用模式匹配并保留所有资产，从<code>ic_</code>开始。我们还可以在我们的<code>keep.xml</code>中明确地保留一些资产，如下所示:</p>
<pre class="language-xml hljs">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;resources xmlns:tools="http://schemas.android.com/tools"
    tools:keep="@drawable/ic_sport*, @drawable/ic_banner_option, @layout/item_header"
    tools:discard="@drawable/wip" /&gt;
</pre>
<blockquote><p>注意:<code>discard</code>选项确保了<code>wip</code>如果没有被使用的话会从最终版本中移除。</p></blockquote>
<h2 id="debugging-r8-errors">调试R8错误</h2>
<p>偶尔在使用R8时，您会以<code>ClassNotFoundException</code>或<code>FieldNotFoundException</code>的形式结束资源丢失错误。然而，由于跟踪是模糊的，我们将需要使用一个叫做retrace的工具。</p>
<p>回撤通常出现在以下路径:<code>Android/sdk/tools/proguard/bin</code>。您可以通过使用<a href="http://proguardgui.sh"> proguardgui.sh命令</a>选择使用基于GUI的路线，如下所示:</p>
<p><img data-attachment-id="154622" data-permalink="https://blog.logrocket.com/r8-code-shrinking-android-guide/attachment/proguardgui-sh-command/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2023/01/proguardgui-sh-command.png" data-orig-size="730,428" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="proguardgui-sh-command" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2023/01/proguardgui-sh-command-300x176.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2023/01/proguardgui-sh-command.png" decoding="async" class="aligncenter size-full wp-image-154622 jetpack-lazy-image" src="../Images/a473b3b27329b17484706d02b52f1f61.png" alt="Using the Proguard GUI shell command" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2023/01/proguardgui-sh-command.png 730w, https://blog.logrocket.com/wp-content/uploads/2023/01/proguardgui-sh-command-300x176.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2023/01/proguardgui-sh-command.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2023/01/proguardgui-sh-command.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="154622" data-permalink="https://blog.logrocket.com/r8-code-shrinking-android-guide/attachment/proguardgui-sh-command/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2023/01/proguardgui-sh-command.png" data-orig-size="730,428" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="proguardgui-sh-command" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2023/01/proguardgui-sh-command-300x176.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2023/01/proguardgui-sh-command.png" decoding="async" loading="lazy" class="aligncenter size-full wp-image-154622" src="../Images/a473b3b27329b17484706d02b52f1f61.png" alt="Using the Proguard GUI shell command" srcset="https://blog.logrocket.com/wp-content/uploads/2023/01/proguardgui-sh-command.png 730w, https://blog.logrocket.com/wp-content/uploads/2023/01/proguardgui-sh-command-300x176.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2023/01/proguardgui-sh-command.png"/></noscript>
<p>一旦您发现是哪个类或成员导致了这个问题，您就可以通过为它包含一个特定的keep规则来轻松地解决这个问题:</p>
<pre class="language-kotlin hljs">-keep class com.demo.activities.MainActivity
</pre>
<p>R8通常剥离像行号和源文件名这样的元属性。我们可以通过使用<code>keepattributes</code>来保留这些信息，如下面的规则所示:</p>
<pre class="language-kotlin hljs">-keepattributes SourceFile, LineNumberTable
</pre>
<p>你可以在这里找到属性<a href="https://www.guardsquare.com/manual/configuration/attributes">的完整列表。</a></p>
<p>有时，您可能会看到，应该从最终APK中删除的成员实际上并没有被删除。我们可以通过使用<code>whyareyoukeeping</code>来找出原因:</p>
<pre class="language-kotlin hljs">-whyareyoukeeping class com.android.AndroidApplication
</pre>
<p>这将打印以下输出:</p>
<pre class="language-kotlin hljs">com.android.AndroidApplication
|- is referenced in keep rule:
|  /Users/anvith/Development/Android/project-demo/app/build/intermediates/aapt_proguard_file/release/aapt_rules.txt:3:1
</pre>
<p>调试时另一个有用的工具是列出所有未使用的类。这可以使用<code>printusage</code>来完成，如下所示:</p>
<pre class="language-kotlin hljs">-printusage
</pre>
<blockquote><p>关于R8规则的一个简短说明:最宽泛的规则优先。因此，如果<code>libraryA</code>附带一个规则来包含一个类的一个方法，而‘library b’附带一个规则来包含所有成员，那么<code>libraryB</code>的规则优先。</p></blockquote>
<p>最后，如果您希望看到与您的规则匹配的类，您可以使用下面的命令来观察匹配的结果:</p>
<pre class="language-kotlin hljs">-printseeds
</pre>
<h2 id="aggressive-shrinking-options">激进的缩水期权</h2>
<p>我们可以让R8在非兼容模式下运行，并在<code>gradle.properties</code>文件中声明以下属性，从而让它变得更加主动:</p>
<pre class="language-kotlin hljs">android.enableR8.fullMode=true</pre>
<p>该标志导致一些更严格的优化，如:</p>
<ul>
<li>除非明确指定，否则避免保留默认构造函数</li>
<li>属性(如<code>Signature</code>、<code>Annotations</code>等。)只为匹配的类保留，即使我们为所有实体指定了泛型<code>keepattributes</code></li>
</ul>
<p>类似于代码收缩选项，有一个积极的资源收缩模式可以添加到<code>keep.xml</code>:</p>
<pre class="language-xml hljs">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;resources xmlns:tools="http://schemas.android.com/tools"
    tools:shrinkMode="strict" /&gt;
</pre>
<h2 id="conclusion">结论</h2>
<p>在本文中，我们了解了R8以及如何为其配置规则。在这个过程中，我们还讨论了各种调试选项，以解决激进收缩的危险。</p>
<p>我希望您已经发现本文中的信息对于解决您的代码收缩问题是有用的，并准备好利用R8工具链！</p><div class="code-block code-block-32">
<div class="blog-plug inline-plug kotlin-plug"><h2>LogRocket :即时重现你的安卓应用中的问题。</h2><a class="signup" href="https://lp.logrocket.com/blg/kotlin-signup" target="_blank" rel="noopener noreferrer"><img class="alignnone size-full wp-image-46 jetpack-lazy-image" src="../Images/b5ae4bd0ecde7aa9d5288746416d5e18.png" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2022/11/react-native-plug_android-1.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/11/react-native-plug_android-1.png"/><noscript><img data-lazy-fallback="1" class="alignnone size-full wp-image-46" src="../Images/b5ae4bd0ecde7aa9d5288746416d5e18.png" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/11/react-native-plug_android-1.png"/></noscript></a><p><a href="https://lp.logrocket.com/blg/kotlin-signup" target="_blank" rel="noopener noreferrer"> LogRocket </a>是一款Android监控解决方案，可以帮助您即时重现问题，确定bug的优先级，并了解您的Android应用程序的性能。</p><p>LogRocket还可以向你展示用户是如何与你的应用程序互动的，从而帮助你提高转化率和产品使用率。LogRocket的产品分析功能揭示了用户不完成特定流程或不采用新功能的原因。</p><p>开始主动监控您的Android应用程序— <a class="signup" href="hhttps://lp.logrocket.com/blg/kotlin-signup" target="_blank" rel="noopener noreferrer">免费试用LogRocket】。</a></p></div>
</div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
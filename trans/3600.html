<html>
<head>
<title>Kotlin SharedPreferences data storage guide </title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>Kotlin SharedPreferences数据存储指南</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/android-data-storage-guide-kotlin-sharedpreferences/#0001-01-01">https://blog.logrocket.com/android-data-storage-guide-kotlin-sharedpreferences/#0001-01-01</a></blockquote><div><article class="article-post">
<p>你有没有想过如何在应用程序中存储一些值，而不会在关闭应用程序后丢失它们？Android提供了一种方法，如果你有一个小的键值集合想要保存的话！</p>
<p>在本文中，我们将看看Android的<code>SharedPreferences</code>API，然后演示如何在用例中使用<code>SharedPreferences</code>。</p>
<p><a href="https://developer.android.com/topic/libraries/architecture/datastore"> Jetpack DataStore </a>是一个现代的解决方案，它使用<a href="https://blog.logrocket.com/understanding-kotlin-design-patterns/"> Kotlin协程和流</a>来异步存储数据。将来，您可能会考虑从<code>SharedPreferences</code>迁移到Jetpack数据存储。然而，在本文中，我们将关注于<code>SharedPreferences</code>,因为它仍然有用，并且在撰写本文时仍然非常流行。</p>
<p><em>向前跳转:</em></p>

<h2 id="what-is-sharedpreferences">什么是<code>SharedPreferences</code>？</h2>
<p>是一个Android API，允许你创建和访问一个包含键值集合的文件。一个<code>SharedPreferences</code>对象提供了一些在文件上读写这些值的方法。每个<code>SharedPreferences</code>文件由框架管理，可以是应用程序私有的，也可以是共享的。</p>
<h2 id="accessing-kotlin-sharedpreferences-files">访问Kotlin <code>SharedPreferences</code>文件</h2>
<p>要创建或访问一个<code>SharedPreferences</code>文件，可以调用以下方法之一:<code>getSharedPreferences()</code>或<code>getDefaultSharedPreferences()</code>。</p>
<p>让我们来看看。</p>
<h3>getSharedPreferences(名称，模式)</h3>
<p>如果您需要创建或访问一个由名称标识的<code>SharedPreferences</code>文件，请使用<a href="https://developer.android.com/reference/kotlin/android/content/SharedPreferences"> getSharedPreferences()方法</a>。</p>
<p>这是这种方法的一个例子:</p>
<pre class="language-kotlin hljs">val sharedPreferences = activity?.getSharedPreferences(getString(R.string.preference_file_key), Context.MODE_PRIVATE)</pre>
<h3>getDefaultSharedPreferences()</h3>
<p>使用<a href="https://developer.android.com/reference/android/preference/PreferenceManager#getDefaultSharedPreferences(android.content.Context)"> getDefaultSharedPreferences()方法</a>获取整个应用程序的默认SharedPreferences文件。你应该知道这个方法需要额外的依赖。</p>
<p>此方法的以下示例需要在应用程序模块级别向<code>build.gradle</code>文件添加一个额外的依赖项:</p>
<p>这是依赖性:</p>
<pre class="language-kotlin hljs">implementation "androidx.preference:preference-ktx:1.2.0"</pre>
<p>下面是该方法的一个示例:</p>
<pre class="language-kotlin hljs">val sharedPreferences = PreferenceManager.getDefaultSharedPreferences(context)</pre>
<h2 id="sharing-kotlin-sharedpreferences-files">共享Kotlin <code>SharedPreferences</code>文件</h2>
<p><code>getSharedPreferences</code>方法的第二个参数是模式。此参数与文件共享的权限相关。</p>
<h3>与其他应用程序共享文件</h3>
<p>要与不共享您的用户ID的应用程序共享私人文件，您可以在早于7.0的Android版本上使用<code>MODE_WORLD_READABLE</code>。如果你尝试使用这种模式，Android 7.0+会抛出安全异常；从API级开始，它就被弃用了。</p>
<p>如果您遇到这个问题，一个解决方法是使用一个意图设置为<code><a href="https://developer.android.com/reference/android/content/Intent#FLAG_GRANT_READ_URI_PERMISSION">FLAG_GRANT_READ_URI_PERMISSION</a></code>的<a href="https://developer.android.com/reference/androidx/core/content/FileProvider">文件提供者</a>。欲了解更多信息，也请参阅关于<a href="https://developer.android.com/training/secure-file-sharing">共享文件</a>的官方文档。</p>
<h3>与您的应用程序共享文件</h3>
<p>要与任何共享您的用户ID的应用程序共享私人文件，您可以使用<code>MODE_PRIVATE</code>。</p>
<h2 id="reading-kotlin-sharedpreferences-files">读取科特林<code>SharedPreferences</code>文件</h2>
<p>要从一个<code>SharedPreferences</code>文件中检索值，您可以调用下面的任何方法，提供您想要的值的键，如果键不存在，还可以返回一个可选的默认值:</p>
<ul>
<li><code>contains(key: String)</code>使用此方法检查偏好文件是否包含特定偏好</li>
<li><code>edit()</code>使用该方法创建一个新的编辑器，通过它你可以对<code>SharedPreferences</code>文件中的数据进行<a href="https://kotlinlang.org/docs/multiplatform-mobile-concurrent-mutability.html#atomics">原子改变</a></li>
<li><code>getAll()</code>使用此方法检索<code>SharedPreferences</code>文件中的所有值</li>
<li><code>getInt(key: String, defValue: Integer)</code>使用此方法从<code>SharedPreferences</code>文件中检索一个<code>Integer</code>值</li>
<li><code>getBoolean(key: String, defValue: Boolean)</code>使用此方法从<code>SharedPreferences</code>文件中检索一个<code>Boolean</code>值</li>
<li><code>getFloat(key: String, defValue: Float)</code>使用此方法从<code>SharedPreferences</code>文件中检索一个<code>Float</code>值</li>
<li><code>getLong(key: String, defValue: Long)</code>使用此方法从<code>SharedPreferences</code>文件中检索一个<code>Long</code>值</li>
<li><code>getString(key: String, defValue: String)</code>使用此方法从<code>SharedPreferences</code>文件中检索一个<code>String</code>值</li>
<li><code>getStringSet(key: String, defValues: Set)</code>使用此方法从<code>SharedPreferences</code>文件中检索一组<code>String</code>值</li>
</ul>
<h2 id="writing-kotlin-sharedpreferences-files">编写Kotlin <code>SharedPreferences</code>文件</h2>
<p>要在<code>SharedPreferences</code>文件中写入值，通过调用<code>SharedPreferences</code>对象上的<code>edit()</code>来创建一个<code><a href="https://developer.android.com/reference/android/content/SharedPreferences.Editor">SharedPreferences.Editor</a></code>。使用<code>edit()</code>，你将能够调用以下方法:</p>
<ul>
<li><code>putInt(key: String, value: Integer)</code>使用此方法在<code>SharedPreferences</code>文件中插入一个<code>Integer</code>值</li>
<li><code>putBoolean(key: String, value: Boolean)</code>使用此方法在<code>SharedPreferences</code>文件中插入一个<code>Boolean</code>值</li>
<li><code>putFloat(key: String, value: Float)</code>使用此方法在<code>SharedPreferences</code>文件中插入一个<code>Float</code>值</li>
<li><code>putLong(key: String, value: Long)</code>使用此方法在<code>SharedPreferences</code>文件中插入一个<code>Long</code>值</li>
<li><code>putString(key: String, value: String)</code>使用此方法在<code>SharedPreferences</code>文件中插入一个<code>String</code>值</li>
<li><code>putStringSet(key: String, values: Set)</code>使用此方法在<code>SharedPreferences</code>文件中插入一组<code>String</code>值</li>
</ul>
<p>写入更改后，请务必调用<code>apply()</code>或<code>commit()</code>来保存您的更改。根据<a href="https://developer.android.com/training/data-storage/shared-preferences">官方Android文档</a>,<code>apply()</code>和<code>commit()</code>都会立即更改内存中的<code>SharedPreferences</code>对象，但将更新写入磁盘的方式不同。<code>apply()</code>异步写入更新，而<code>commit() </code>同步写入更新，如果从主线程调用，可能会导致UI渲染暂停。</p>
<p>这里有一个例子说明了上面的一些函数在一个<code>SharedPreferences</code>文件中检索和写入值:</p>
<pre class="language-kotlin hljs">val sharedPref = activity?.getPreferences(getString(R.string.preference_file_key), Context.MODE_PRIVATE) ?: return
with (sharedPref.edit()) {
    putInt(getString(R.string.saved_high_score_key), newHighScore)
    apply()
}</pre>
<h2 id="detecting-changes-kotlin-sharedpreferences-files">检测Kotlin <code>SharedPreferences</code>文件中的更改</h2>
<p>要检测<code>SharedPreferences</code>文件中的变化，您可以调用以下方法:</p>
<ul>
<li><code>registerOnSharedPreferenceChangeListener(listener: SharedPreferences.OnSharedPreferencechangeListener)</code>使用这个方法注册一个回调，当<code>SharedPreferences</code>文件中发生变化时，这个回调将被调用</li>
<li><code>unregisterOnSharedPreferenceChangeListener(listener: SharedPreferences.OnSharedPreferencechangeListener)</code>使用这个方法取消注册一个回调函数，当<code>SharedPreferences</code>文件发生变化时调用这个函数</li>
</ul>
<h2 id="sharedpreferences-use-case"><code>SharedPreferences</code>使用案例</h2>
<p>现在，我们来看看一个常见的场景，其中<code>SharedPreferences</code>可能是有用的。假设您想在用户第一次打开应用程序时显示一个入职页面。</p>
<p>为了实现这一点，您需要在一个<code>SharedPreferences</code>文件中存储一个布尔值，以指示特定用户是否第一次打开该应用程序。</p>
<h3 id="implementation">履行</h3>
<p>首先，打开<code>res/values/strings.xml</code>并添加我们的<code>SharedPreferences</code>文件的名称。</p>
<p>接下来，将以下代码添加到<code>strings.xml</code>文件中:</p>
<pre class="language-kotlin hljs">&lt;string name="app_shared_prefs"&gt;com.pp.sharedprefs.PREFERENCES_FILE_KEY&lt;/string&gt;</pre>
<p>您还需要添加一个标识我们的存储值的键。姑且称之为<code>FIRST_TIME_OPENING_KEY</code>。</p>
<p>将以下代码添加到<code>strings.xml</code>文件中:</p>
<pre class="language-kotlin hljs">&lt;string name="first_time_opening"&gt;FIRST_TIME_OPENING_KEY&lt;/string&gt;</pre>
<p>现在，转到您的活动，在调用<code>setContentView()</code>后，在<code>onCreate(savedInstanceState: Bundle?) </code>中添加以下代码:</p>
<pre class="language-kotlin hljs">getSharedPreferences(getString(R.string.app_shared_prefs), Context.MODE_PRIVATE)?.let { sharedPreferences -&gt;
        val isFirstTimeOpening = sharedPreferences.getBoolean(getString(R.string.first_time_opening), true)

        if (isFirstTimeOpening) {
            showOnboarding()
            with (sharedPreferences.edit()) {
                putBoolean(getString(R.string.first_time_opening), false)
                apply()
            }
        }
}</pre>
<p>在上面的代码中，我们通过调用<code>getSharedPreferences(name, mode)</code>来访问文件。</p>
<p>接下来，我们尝试从<code>SharedPreferences</code>文件中获取<code> FIRST_TIME_OPENING_KEY</code>的值。如果值不存在，我们返回<code>true</code>。</p>
<p>如果我们返回<code>true</code>，这是用户第一次打开app。在这种情况下，我们显示onboarding屏幕，并将<code>FIRST_TIME_OPENING_KEY</code>的值更改为<code>false</code>，这样用户就不会再看到onboarding屏幕。然后，我们调用<code>apply()</code>来结束更改。</p>
<p>应该可以了！</p>
<p>在我们的用例中，我们处理了一个onboarding屏幕。然而，这种解决方案适用于用户第一次打开应用程序时只运行一次的情况。</p>
<h3 id="reducing-code">一点额外的小好处:减少代码长度</h3>
<p>因为我们正在使用Kotlin，所以我们可以利用它的强大功能，通过<a href="https://kotlinlang.org/docs/extensions.html"> Kotlin扩展</a>来减少一点代码长度。</p>
<p>要使用Kotlin扩展，创建一个名为<code>SharedPreferencesHelper</code>的单独文件，然后添加以下内容:</p>
<pre class="language-kotlin hljs">fun SharedPreferences.edit(actions: SharedPreferences.Editor.() -&gt; Unit) {
    with (edit()) {
        actions(this)
        apply()
    }
}</pre>
<p>上面的代码将在<code>SharedPreferences interface</code>中添加一个名为<code>edit</code>的扩展函数。<code>edit()</code>函数采用一个<a href="https://kotlinlang.org/docs/lambdas.html">科特林λ函数</a>，它由花括号定义，是<code>SharedPreferences.Editor</code>的扩展。</p>
<p>在这个扩展函数中，我们已经在最后调用了<code>apply()</code>，所以当使用这个扩展在<code>SharedPreferences</code>文件中添加值时，没有必要重复这个过程。</p><div class="code-block code-block-54">
<hr/>
<h3>更多来自LogRocket的精彩文章:</h3>

<hr/></div>
<p>回到活动，替换以下代码:</p>
<pre class="language-kotlin hljs">with (sharedPreferences.edit()) {
        putBoolean(getString(R.string.first_time_opening), false)
        apply()
}</pre>
<p>使用以下代码片段:</p>
<pre class="language-kotlin hljs">sharedPreferences.edit {
        putBoolean(getString(R.string.first_time_opening), false)
}</pre>
<p>这段较短的代码应该会提供相同的结果！</p>
<h2>结论</h2>
<p>在本文中，我们研究并提供了使用Kotlin <code>SharedPreferences</code> API的解决方案。我们还演示了如何在一个涉及onboarding屏幕的例子中使用<code>SharedPreferences</code>。</p>
<p>关于这个主题的更多信息，请查看官方文档:<a href="https://developer.android.com/training/data-storage/shared-preferences"> SharedPreferences </a>、<a href="https://developer.android.com/topic/libraries/architecture/datastore"> Jetpack DataStore </a>和<a href="https://kotlinlang.org/docs/extensions.html"> Kotlin extensions </a>。</p>
<p>感谢您的阅读。我希望这篇文章能让你在使用<code>SharedPreferences</code>的时候生活得更轻松！</p><div class="code-block code-block-32">
<div class="blog-plug inline-plug kotlin-plug"><h2>LogRocket :即时重现你的安卓应用中的问题。</h2><a class="signup" href="https://lp.logrocket.com/blg/kotlin-signup" target="_blank" rel="noopener noreferrer"><img class="alignnone size-full wp-image-46 jetpack-lazy-image" src="../Images/b5ae4bd0ecde7aa9d5288746416d5e18.png" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2022/11/react-native-plug_android-1.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/11/react-native-plug_android-1.png"/><noscript><img data-lazy-fallback="1" class="alignnone size-full wp-image-46" src="../Images/b5ae4bd0ecde7aa9d5288746416d5e18.png" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/11/react-native-plug_android-1.png"/></noscript></a><p><a href="https://lp.logrocket.com/blg/kotlin-signup" target="_blank" rel="noopener noreferrer"> LogRocket </a>是一款Android监控解决方案，可以帮助您即时重现问题，确定bug的优先级，并了解您的Android应用程序的性能。</p><p>LogRocket还可以向你展示用户是如何与你的应用程序互动的，从而帮助你提高转化率和产品使用率。LogRocket的产品分析功能揭示了用户不完成特定流程或不采用新功能的原因。</p><p>开始主动监控您的Android应用程序— <a class="signup" href="hhttps://lp.logrocket.com/blg/kotlin-signup" target="_blank" rel="noopener noreferrer">免费试用LogRocket】。</a></p></div>
</div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
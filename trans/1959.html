<html>
<head>
<title>Dark mode in React: An in-depth guide - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>React 中的黑暗模式:深度指南</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/dark-mode-in-react-an-in-depth-guide/#0001-01-01">https://blog.logrocket.com/dark-mode-in-react-an-in-depth-guide/#0001-01-01</a></blockquote><div><article class="article-post">
<p>随着我们一天天向更好、更易访问的用户体验迈进，黑暗模式已经成为网络应用的主流功能。说到黑暗模式的开发，它不仅仅是添加一个简单的切换按钮和管理 CSS 变量。这里我们将讨论在 React app 中创建一个完整的黑暗模式体验。</p>
<p>以下是我们将要介绍的内容:</p>
<ul>
<li>使用系统设置</li>
<li>使用 CSS 变量管理主题</li>
<li>使用 react-toggle 实现颜色方案切换</li>
<li>使用 use-persisted-state 存储用户首选模式</li>
<li>选择适合更广泛受众的颜色组合</li>
<li>在黑暗模式下处理图像</li>
</ul>
<p>你可以在 Github 上找到<a href="https://sleepy-yalow-542f99.netlify.app/" target="_blank" rel="noopener">演示应用</a>和<a href="https://github.com/zsajjad/dark-mode-sample" target="_blank" rel="noopener">它的代码</a>。</p>
<h2>使用系统设置</h2>
<p>没有人想在用户登陆他们的网站时伤害他们的眼睛！最佳做法是根据设备的设置来设定应用程序的主题。CSS 媒体查询，通常用于响应式设计，也帮助我们检查其他设备特性。</p>
<p>这里我们将使用<code><a href="https://developer.mozilla.org/en-US/docs/Web/CSS/@media/prefers-color-scheme" target="_blank" rel="noopener">prefers-color-scheme</a></code>，根据设备选择的配色方案给出<code>dark</code>、<code>light</code>或<code>no-preference</code>。</p>
<p>即使是最简单的形式，这也能帮助我们为网络应用添加黑暗模式:</p>
<pre>@media (prefers-color-scheme: dark) {
  background-color: #1F2023
  color: #DADADA
}
</pre>
<p>与任何其他媒体查询一样，当设备的配色方案设置为深色时，将应用此块中的样式。将它放在一些组件样式中，看起来会像这样:</p>
<pre>import { styled } from '@linaria/react';

const Text = styled.p`
  margin: 12px;
  color: #1F2023;
  background-color: #FAFAFA;
  @media (prefers-color-scheme: dark) {
    background-color: #1F2023
    color: #DADADA
  }
`;
</pre>
<p>这是一个好的开始，但是你不能在每个组件中添加这些样式。在这种情况下，<a href="https://blog.logrocket.com/how-to-use-css-variables-like-a-pro/" target="_blank" rel="noopener"> CSS 变量</a>就是答案。</p>
<h2>使用 CSS 变量管理主题</h2>
<p>CSS 变量是 web 样式中很久很久以前就缺少的一个工具。现在所有的浏览器都可以使用 CSS 了，CSS 变得更有趣，痛苦也更少了。</p>
<p>CSS 变量的作用域是声明它们并参与级联的元素(即元素是子元素的覆盖值)。</p>
<p>我们可以利用 CSS 变量<a href="https://blog.logrocket.com/how-to-create-better-themes-with-css-variables-5a3744105c74/" target="_blank" rel="noopener">来定义应用程序的主题</a>。这里有一个小片段来回忆 CSS 变量是如何声明的:</p>
<pre>body {
  --color-background: #FAFAFA;
  --color-foreground: #1F2023;
}
</pre>
<p>为了在我们的组件中使用这些变量，我们将用变量交换颜色代码:</p>
<pre>const Text = styled.p`
  margin: 12px;
  color: var(--color-foreground);
  background-color: var(--color-background);
`;
</pre>
<p>现在，我们的颜色是通过 CSS 变量定义的，我们可以在 HTML 树的顶部更改值(例如，<code>&lt;body&gt;</code>)，并且可以在所有元素上看到反射:</p>
<pre>body {
  --color-background: #FAFAFA;
  --color-foreground: #1F2023;

  @media (prefers-color-scheme: dark) {
    --color-background: #1F2023;
    --color-foreground: #EFEFEF;
  }
}
</pre>
<h2>实现配色方案切换</h2>
<p>此时，我们有了最简单的解决方案，它基于设备的偏好。现在，我们必须针对本身不支持黑暗模式的设备对其进行扩展。</p>
<p>在这种情况下，我们必须让用户能够轻松地为我们的 web 应用程序设置偏好。我选择了<a href="https://github.com/aaronshaf/react-toggle">反应-切换</a>来使我们的解决方案在 a11y 时更好，并且美观。这可以通过简单的<code>button</code>和<code>useState</code>来实现。</p>
<p><img data-attachment-id="58974" data-permalink="https://blog.logrocket.com/dark-mode-in-react-an-in-depth-guide/react-dark-mode-toggle/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2021/07/React-dark-mode-toggle.gif" data-orig-size="730,365" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="React-dark-mode-toggle" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2021/07/React-dark-mode-toggle-300x150.gif" data-large-file="https://blog.logrocket.com/wp-content/uploads/2021/07/React-dark-mode-toggle.gif" decoding="async" class="size-full wp-image-58974 aligncenter jetpack-lazy-image" src="../Images/ce93d98a4c77a5c7ade9389ee725676a.png" alt="Gif of a toggle slider turning dark mode off and on" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2021/07/React-dark-mode-toggle.gif?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2021/07/React-dark-mode-toggle.gif"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="58974" data-permalink="https://blog.logrocket.com/dark-mode-in-react-an-in-depth-guide/react-dark-mode-toggle/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2021/07/React-dark-mode-toggle.gif" data-orig-size="730,365" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="React-dark-mode-toggle" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2021/07/React-dark-mode-toggle-300x150.gif" data-large-file="https://blog.logrocket.com/wp-content/uploads/2021/07/React-dark-mode-toggle.gif" decoding="async" loading="lazy" class="size-full wp-image-58974 aligncenter" src="../Images/ce93d98a4c77a5c7ade9389ee725676a.png" alt="Gif of a toggle slider turning dark mode off and on" data-original-src="https://blog.logrocket.com/wp-content/uploads/2021/07/React-dark-mode-toggle.gif"/></noscript>
<p>下面是我们的 toggle 组件的外观:</p>
<pre>import React, { useState } from "react";
import Toggle from "react-toggle";

export const DarkModeToggle: React.FC = () =&gt; {
  const [isDark, setIsDark] = useState&lt;boolean&gt;(true);

  return (
    &lt;Toggle
      className="dark-mode-toggle"
      checked={isDark}
      onChange={({ target }) =&gt; setIsDark(target.checked)}
      icons={{ checked: "🌙", unchecked: "🔆" }}
      aria-label="Dark mode toggle"
    /&gt;
  );
};
</pre>
<p>这个组件将保存用户选择的模式，但是默认值呢？我们的 CSS 解决方案尊重设备的偏好。为了在 react 组件中获取媒体查询结果，我们将利用<a href="https://github.com/contra/react-responsive"> react-responsive </a>。在幕后，它使用<code><a href="https://developer.mozilla.org/en-US/docs/Web/API/Window/matchMedia" target="_blank" rel="noopener">Window.matchMedia()</a></code>并在查询的输出改变时重新呈现我们的组件。</p>
<p>该按钮的更新版本如下所示:</p>
<pre>import React, { useState } from "react";
import Toggle from "react-toggle";

export const DarkModeToggle: React.FC = () =&gt; {
  const [isDark, setIsDark] = useState&lt;boolean&gt;(true);

  const systemPrefersDark = useMediaQuery(
    {
      query: '(prefers-color-scheme: dark)',
    },
    undefined,
    (isSystemDark: boolean) =&gt; setIsDark(isSystemDark)
  );

  return (
    &lt;Toggle
      className="dark-mode-toggle"
      checked={isDark}
      onChange={({ target }) =&gt; setIsDark(target.checked)}
      icons={{ checked: "🌙", unchecked: "🔆" }}
      aria-label="Dark mode toggle"
    /&gt;
  );
};
</pre>
<p><code>useMediaQuery</code>钩子接受一个查询、初始值和一个<code>onChange</code>处理程序，每当查询的输出发生变化时，这个处理程序就会被触发。</p>
<h2>在浏览器中模拟黑暗模式</h2>
<p>现在，我们的组件将与设备的首选项同步，并且它的值将相应地更新。但是我们如何测试它是否做对了呢？</p>
<p>由于开发人员友好的浏览器，我们可以从浏览器检查器模拟设备偏好；这是它在 Firefox 中的样子:</p>
<p><img data-attachment-id="58977" data-permalink="https://blog.logrocket.com/dark-mode-in-react-an-in-depth-guide/react-dark-mode-toggle-firefox/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2021/07/React-dark-mode-toggle-Firefox.gif" data-orig-size="730,162" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="React-dark-mode-toggle-Firefox" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2021/07/React-dark-mode-toggle-Firefox-300x67.gif" data-large-file="https://blog.logrocket.com/wp-content/uploads/2021/07/React-dark-mode-toggle-Firefox.gif" decoding="async" class="size-full wp-image-58977 aligncenter jetpack-lazy-image" src="../Images/1192dbf12d2627b9c59248d4e218fff2.png" alt="Gif of dark mode toggling on and off in Firefox" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2021/07/React-dark-mode-toggle-Firefox.gif?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2021/07/React-dark-mode-toggle-Firefox.gif"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="58977" data-permalink="https://blog.logrocket.com/dark-mode-in-react-an-in-depth-guide/react-dark-mode-toggle-firefox/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2021/07/React-dark-mode-toggle-Firefox.gif" data-orig-size="730,162" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="React-dark-mode-toggle-Firefox" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2021/07/React-dark-mode-toggle-Firefox-300x67.gif" data-large-file="https://blog.logrocket.com/wp-content/uploads/2021/07/React-dark-mode-toggle-Firefox.gif" decoding="async" loading="lazy" class="size-full wp-image-58977 aligncenter" src="../Images/1192dbf12d2627b9c59248d4e218fff2.png" alt="Gif of dark mode toggling on and off in Firefox" data-original-src="https://blog.logrocket.com/wp-content/uploads/2021/07/React-dark-mode-toggle-Firefox.gif"/></noscript>
<p>是时候将我们的切换组件的状态更改连接到 CSS 了。这可以通过几种不同的技术来实现。这里，我们选择了最简单的一个:在根 HTML 标签上添加一个类，让 CSS 变量完成剩下的工作。</p>
<p>为了适应这种情况，我们将更新 body 标签的 CSS:</p>
<pre>body {
  --color-background: #FAFAFA;
  --color-foreground: #1F2023;

  &amp;.dark {
    --color-background: #1F2023;
    --color-foreground: #EFEFEF;
  }
}
</pre>
<p>下面是我们根据状态添加和删除类的效果:</p>
<pre>...
useEffect(() =&gt; {
  if (isDark) {
    document.body.classList.add('dark');
  } else {
    document.body.classList.remove('dark');
  }
}, [isDark]); 
...
</pre>
<h2>使用 use-persisted-state 存储用户的首选模式</h2>
<p>如果我们在组件的状态中保留用户偏好的配色方案，这可能会有问题，因为我们将无法获取该组件之外的值。此外，一旦我们的应用程序再次安装，它就会消失。这两个问题可以用不同的方式解决，包括用 React Context 解决<a href="https://blog.logrocket.com/a-deep-dive-into-react-context-api/" target="_blank" rel="noopener">或者任何其他状态管理方法。</a></p>
<p>另一个解决方案是使用<a href="https://github.com/donavon/use-persisted-state">使用持久状态</a>。这将有助于我们满足所有要求。当应用程序在浏览器的不同标签中打开时，它使用<code>localStorage</code>保持状态并保持状态同步。</p>
<p>我们现在可以在一个自定义钩子中移动我们的黑暗模式状态，该钩子封装了与媒体查询和持久状态相关的所有逻辑。这个钩子应该是这样的:</p>
<pre>import { useEffect, useMemo } from 'react';
import { useMediaQuery } from 'react-responsive';
import createPersistedState from 'use-persisted-state';

const useColorSchemeState = createPersistedState('colorScheme');

export function useColorScheme(): {
  isDark: boolean;
  setIsDark: (value: boolean) =&gt; void;
} {
  const systemPrefersDark = useMediaQuery(
    {
      query: '(prefers-color-scheme: dark)',
    },
    undefined,
  );
  const [isDark, setIsDark] = useColorSchemeState&lt;boolean&gt;();
  const value = useMemo(() =&gt; isDark === undefined ? !!systemPrefersDark : isDark,
    [isDark, systemPrefersDark])
  useEffect(() =&gt; {
    if (value) {
      document.body.classList.add('dark');
    } else {
      document.body.classList.remove('dark');
    }
  }, [value]);
  return {
    isDark: value,
    setIsDark,
  };
}
</pre>
<p>切换按钮组件现在将更加简单:</p>
<pre>/**
 *
 * ColorSchemeToggle
 *
 */
import Toggle from 'react-toggle';
import { useColorScheme } from 'platform/ColorScheme';
import { DarkToggle } from './Styled';

const ColorSchemeToggle: React.FC = () =&gt; {
  const { value, setValue } = useColorScheme();
  return (
    &lt;DarkToggle&gt;
      &lt;Toggle
        checked={value === 'dark'}
        onChange={(event) =&gt; setValue(event.target.checked ? 'dark' : 'light')}
        icons={{ checked: '🌙', unchecked: '🔆' }}
        aria-label="Dark mode"
      /&gt;
    &lt;/DarkToggle&gt;
  );
};

export default ColorSchemeToggle;</pre>
<h2>选择深色主题颜色</h2>
<p>虽然黑暗模式本身可以被认为是<a href="https://blog.logrocket.com/a-developers-guide-to-designing-accessible-websites/" target="_blank" rel="noopener">一个辅助功能</a>，我们应该专注于保持这个功能对更广泛的受众是可访问的。</p>
<p>我们在演示中利用了 react-toggle 来确保用于改变配色方案的按钮遵循所有 a11y 标准。另一个重要的部分是在暗模式和亮模式下背景色和前景色的选择。在我看来，<a href="https://color.review/" target="_blank" rel="noopener"> colors.review </a>是测试颜色间对比度的绝佳工具；拥有 AAA 级使我们的应用程序更容易导航，看起来更舒服。</p>
<p><img data-attachment-id="58980" data-permalink="https://blog.logrocket.com/dark-mode-in-react-an-in-depth-guide/react-dark-mode-toggle-colors/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2021/07/React-Dark-Mode-Toggle-colors.gif" data-orig-size="600,517" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="React-Dark-Mode-Toggle-colors" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2021/07/React-Dark-Mode-Toggle-colors-300x259.gif" data-large-file="https://blog.logrocket.com/wp-content/uploads/2021/07/React-Dark-Mode-Toggle-colors.gif" decoding="async" class="size-full wp-image-58980 aligncenter jetpack-lazy-image" src="../Images/8c4cf32291f5f761019e12ffdbe77c54.png" alt="Gif of a React app with dark mode toggling under a photo of flowers" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2021/07/React-Dark-Mode-Toggle-colors.gif?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2021/07/React-Dark-Mode-Toggle-colors.gif"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="58980" data-permalink="https://blog.logrocket.com/dark-mode-in-react-an-in-depth-guide/react-dark-mode-toggle-colors/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2021/07/React-Dark-Mode-Toggle-colors.gif" data-orig-size="600,517" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="React-Dark-Mode-Toggle-colors" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2021/07/React-Dark-Mode-Toggle-colors-300x259.gif" data-large-file="https://blog.logrocket.com/wp-content/uploads/2021/07/React-Dark-Mode-Toggle-colors.gif" decoding="async" loading="lazy" class="size-full wp-image-58980 aligncenter" src="../Images/8c4cf32291f5f761019e12ffdbe77c54.png" alt="Gif of a React app with dark mode toggling under a photo of flowers" data-original-src="https://blog.logrocket.com/wp-content/uploads/2021/07/React-Dark-Mode-Toggle-colors.gif"/></noscript>
<h2>在黑暗模式下处理图像</h2>
<p>为了更好的美观，我们通常有明亮图像的页面。在黑暗模式下，明亮的图像可能会让用户感到不适。</p>
<p>有几种技术可以避免这些问题，包括对两种模式使用不同的图像以及改变 SVG 图像的颜色。一种方法是对所有图像元素使用 CSS 滤镜；当明亮的图像出现在用户的画布上时，这将有助于降低眼睛的疲劳。</p>
<p>为此，我们的全局样式如下所示:</p>
<pre>body {
  --color-background: #FAFAFA;
  --color-foreground: #1F2023;

  --image-grayscale: 0;
  --image-opacity: 100%;

  &amp;.dark {
    --color-background: #1F2023;
    --color-foreground: #EFEFEF;

    --image-grayscale: 50%;
    --image-opacity: 90%;
  }
}

img,
video {
  filter: grayscale(var(--image-grayscale)) opacity(var(--image-opacity));
}
</pre>
<h2>结论</h2>
<p>如今，web 应用程序中的可访问性不仅仅是一个实用工具。相反，这是基本要求之一。在这方面，当实现时，黑暗模式应该被认为是一个需要更多关注的完整功能，就像任何其他关键功能一样。</p>
<p>在本文中，我们建立了一种方法来最大限度地实现黑暗模式；如果你觉得我错过了什么，请在评论中告诉我。</p>
<div class="code-block code-block-17">
<div class="blog-plug inline-plug react-plug" vwo-el-id="26283398190">
<h2 vwo-el-id="41600691720"><a href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener"> LogRocket </a>:全面了解您的生产 React 应用</h2><p>调试 React 应用程序可能很困难，尤其是当用户遇到难以重现的问题时。如果您对监视和跟踪 Redux 状态、自动显示 JavaScript 错误以及跟踪缓慢的网络请求和组件加载时间感兴趣，</p><a href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" vwo-el-id="19356441070">try LogRocket</a><p>. </p><a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="19356441380">
<img class="first-react-image alignnone size-full wp-image-46 jetpack-lazy-image jetpack-lazy-image--handled" src="../Images/f300c244a1a1cf916df8b4cb02bec6c6.png" vwo-el-id="18272717540" data-lazy-loaded="1" data-original-src="https://files.readme.io/27c94e7-Image_2017-06-05_at_9.46.04_PM.png"/>
</a>
<a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="19356441690">
<img class="second-react-image alignnone size-full wp-image-46 jetpack-lazy-image jetpack-lazy-image--handled" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" vwo-el-id="30720362350" data-lazy-loaded="1" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/>
</a>
<p vwo-el-id="28675660440" class="">LogRocket 结合了会话回放、产品分析和错误跟踪，使软件团队能够创建理想的 web 和移动产品体验。这对你来说意味着什么？</p>
<p>LogRocket 不是猜测错误发生的原因，也不是要求用户提供截图和日志转储，而是让您回放问题，就像它们发生在您自己的浏览器中一样，以快速了解哪里出错了。</p>
<p>不再有嘈杂的警报。智能错误跟踪允许您对问题进行分类，然后从中学习。获得有影响的用户问题的通知，而不是误报。警报越少，有用的信号越多。</p>
<p vwo-el-id="28675660750">LogRocket Redux 中间件包为您的用户会话增加了一层额外的可见性。LogRocket 记录 Redux 存储中的所有操作和状态。</p>
<p vwo-el-id="28675661060">现代化您调试 React 应用的方式— <a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="40093418840">开始免费监控</a>。</p>
</div></div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
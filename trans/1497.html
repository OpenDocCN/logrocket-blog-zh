<html>
<head>
<title>React vs. web components - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>React 与 web 组件- LogRocket 博客</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/react-vs-web-components/#0001-01-01">https://blog.logrocket.com/react-vs-web-components/#0001-01-01</a></blockquote><div><article class="article-post">
<p>在本文中，我们将讨论 web 组件和 React。在继续之前，这里需要注意的一点是 React 和 web 组件服务于不同的目的。Web 组件允许我们编写可重用的、强封装的定制元素。然而，React 是一个声明性的 JavaScript 库，它解决了 UI 开发中的状态管理问题。今天，我们将讨论组件的类型，React 和 web 组件中提供的样式库，以及它们的可访问性。</p>
<h2>成分</h2>
<p>如前所述，我们可以用 web 组件编写可重用的 UI 元素。但是你可能认为我们也可以使用 React 做同样的事情，例如，我们可以创建一个组件并在项目的其他地方重用它。区别在于，React 组件只能在 React 应用程序中重用。另一方面，web 组件可以在任何地方使用。它可以用于反应，角度，或 Vue 等。，因为它包含在 HTML 规范中并且是本机的。例如，使用 web 组件创建的自定义 header 元素可以跨各种库和框架使用。</p>
<p>既然已经讨论过了，那就让我们来讨论一下它们所提供的组件类型。</p>
<h2>web 组件的类型</h2>
<p>web 组件有三种类型。</p>
<h3>自定义元素</h3>
<p>使用定制元素，我们可以创建一个新的定制 HTML 标签。它使用浏览器的 JavaScript API <code>customElements.define()</code>方法来做到这一点。自定义元素是一个 JavaScript 类，它扩展了<code>HTMLElement</code>。此外，定制元素的名称中需要一个连字符，这样 HTML 解析器才能识别它们。考虑下面的例子:</p>
<pre>&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
&lt;title&gt;Custom Element&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;div&gt;
&lt;h1&gt;Custom Element&lt;/h1&gt;
&lt;test-element&gt;&lt;/test-element&gt;
&lt;/div&gt;

&lt;script type="text/javascript"&gt;
class TestElement extends HTMLElement{
constructor() {
  super();
  this.setAttribute('name', 'ashton'); //setting an attribute

}
connectedCallback() {
    this.innerHTML = `&lt;div&gt;&lt;p&gt;Hello ${this.getAttribute('name')}!&lt;/p&gt;&lt;p&gt;Nice to meet you&lt;/p&gt;&lt;/div&gt;`;
  }
}
//register the custom element
customElements.define('test-element', TestElement);
&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</pre>
<h4>输出:</h4>
<p><img data-attachment-id="32683" data-permalink="https://blog.logrocket.com/react-vs-web-components/customelement/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2021/01/customelement.png" data-orig-size="514,236" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="customelement" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2021/01/customelement-300x138.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2021/01/customelement.png" decoding="async" class="aligncenter size-full wp-image-32683 jetpack-lazy-image" src="../Images/63d4ad471d23710c503584e421248882.png" alt="custom element" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2021/01/customelement.png 514w, https://blog.logrocket.com/wp-content/uploads/2021/01/customelement-300x138.png 300w" data-lazy-sizes="(max-width: 514px) 100vw, 514px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2021/01/customelement.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2021/01/customelement.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="32683" data-permalink="https://blog.logrocket.com/react-vs-web-components/customelement/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2021/01/customelement.png" data-orig-size="514,236" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="customelement" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2021/01/customelement-300x138.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2021/01/customelement.png" decoding="async" loading="lazy" class="aligncenter size-full wp-image-32683" src="../Images/63d4ad471d23710c503584e421248882.png" alt="custom element" srcset="https://blog.logrocket.com/wp-content/uploads/2021/01/customelement.png 514w, https://blog.logrocket.com/wp-content/uploads/2021/01/customelement-300x138.png 300w" sizes="(max-width: 514px) 100vw, 514px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2021/01/customelement.png"/></noscript>
<h3>阴影 DOM</h3>
<p>它允许你创建一个独立的组件，即<code>document.querySelector()</code>不会返回在影子 DOM 中定义的节点。此外，shadow DOM 中定义的样式也包含在其中，例如，作用域 CSS。如果您在阴影 DOM 中将 div 的背景颜色更改为蓝色，那么该 div 的背景将仅发生变化，其外部的 div 不会受到影响:</p>
<pre>&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
&lt;title&gt;Custom Element&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;div&gt;
&lt;h1&gt;Custom Element&lt;/h1&gt;
&lt;test-element&gt;&lt;/test-element&gt;
&lt;/div&gt;

&lt;script type="text/javascript"&gt;
class TestElement extends HTMLElement{
constructor() {
  super();
  this.setAttribute('name', 'ashton'); //setting an attribute
  const shadowRoot = this.attachShadow({mode: 'open'}); //attaches a shadow DOM tree to &lt;test-element&gt; and returns a reference

}
connectedCallback() {
    this.shadowRoot.innerHTML = `&lt;style&gt;
     div {
     background:cyan;
     }
    &lt;/style&gt;
    &lt;div&gt;&lt;p&gt;Hello ${this.getAttribute("name")}!&lt;/p&gt;&lt;p&gt;Nice to meet you&lt;/p&gt;&lt;/div&gt;`;
  }
}
//register the custom element
customElements.define('test-element', TestElement);
&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;</pre>
<h4>输出:</h4>
<p><img data-attachment-id="32686" data-permalink="https://blog.logrocket.com/react-vs-web-components/shadowdombluebackground/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2021/01/shadowdombluebackground.png" data-orig-size="902,202" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="shadowdombluebackground" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2021/01/shadowdombluebackground-300x67.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2021/01/shadowdombluebackground.png" decoding="async" class="aligncenter size-full wp-image-32686 jetpack-lazy-image" src="../Images/d91d0bdb5f3bafe392f634106191ba7f.png" alt="blue background added to custom element" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2021/01/shadowdombluebackground.png 902w, https://blog.logrocket.com/wp-content/uploads/2021/01/shadowdombluebackground-300x67.png 300w, https://blog.logrocket.com/wp-content/uploads/2021/01/shadowdombluebackground-768x172.png 768w" data-lazy-sizes="(max-width: 902px) 100vw, 902px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2021/01/shadowdombluebackground.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2021/01/shadowdombluebackground.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="32686" data-permalink="https://blog.logrocket.com/react-vs-web-components/shadowdombluebackground/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2021/01/shadowdombluebackground.png" data-orig-size="902,202" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="shadowdombluebackground" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2021/01/shadowdombluebackground-300x67.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2021/01/shadowdombluebackground.png" decoding="async" loading="lazy" class="aligncenter size-full wp-image-32686" src="../Images/d91d0bdb5f3bafe392f634106191ba7f.png" alt="blue background added to custom element" srcset="https://blog.logrocket.com/wp-content/uploads/2021/01/shadowdombluebackground.png 902w, https://blog.logrocket.com/wp-content/uploads/2021/01/shadowdombluebackground-300x67.png 300w, https://blog.logrocket.com/wp-content/uploads/2021/01/shadowdombluebackground-768x172.png 768w" sizes="(max-width: 902px) 100vw, 902px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2021/01/shadowdombluebackground.png"/></noscript>
<h3>模板</h3>
<p>模板允许我们在加载时使用<code>&lt;template&gt;</code>标签声明标记结构。该元素及其内容将不会呈现，直到我们手动获取其引用并将其附加到 DOM。它允许我们添加动态数据。因此，如果我们必须在不同的时间使用一些标记结构，我们可以使用模板，避免重复相同的代码:</p>
<pre>&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
&lt;title&gt;Custom Element&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;div&gt;
&lt;h1&gt;Custom Element&lt;/h1&gt;
&lt;template id="student_template"&gt;
&lt;style&gt;
    li {
      color:cyan;
      list-style: none;
    }
  &lt;/style&gt;
&lt;li&gt;
    &lt;span class="name"&gt;&lt;/span&gt; &amp;mdash;
    &lt;span class="score"&gt;&lt;/span&gt;
&lt;/li&gt;
&lt;/template&gt;
&lt;test-element&gt;&lt;/test-element&gt;
&lt;ul id="students"&gt;&lt;/ul&gt;
&lt;/div&gt;

&lt;script type="text/javascript"&gt;
class TestElement extends HTMLElement{
constructor() {
  super()
  const shadowRoot = this.attachShadow({ mode: "open" });

}
connectedCallback() {
let students = [
{name: "Emma", score: 90},
{name: "Ashton", score: 70},
{name: "Hannah", score: 85},
{name: "Steve", score: 90},
{name: "Amy", score: 75},
]

    students.forEach(student=&gt;{
    let template = document.getElementById("student_template");
    let templateContent = template.content.cloneNode(true);
    this.shadowRoot.appendChild(templateContent); //append a clone of the template content to the shadow root

    this.shadowRoot.querySelector('.name').innerHTML = student.name //add the name
    this.shadowRoot.querySelector('.score').innerHTML = student.score //add the score


    document.getElementById("students").appendChild(this.shadowRoot) //append the list to the ul students
    })
  }
}
//register the custom element
customElements.define('test-element', TestElement);
&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;</pre>
<h4>输出:</h4>
<p><img data-attachment-id="32689" data-permalink="https://blog.logrocket.com/react-vs-web-components/template/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2021/01/template.png" data-orig-size="542,212" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="template" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2021/01/template-300x117.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2021/01/template.png" decoding="async" class="aligncenter size-full wp-image-32689 jetpack-lazy-image" src="../Images/40970b73c3fd05d856570d0a68068989.png" alt="custom element with template tag" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2021/01/template.png 542w, https://blog.logrocket.com/wp-content/uploads/2021/01/template-300x117.png 300w" data-lazy-sizes="(max-width: 542px) 100vw, 542px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2021/01/template.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2021/01/template.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="32689" data-permalink="https://blog.logrocket.com/react-vs-web-components/template/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2021/01/template.png" data-orig-size="542,212" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="template" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2021/01/template-300x117.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2021/01/template.png" decoding="async" loading="lazy" class="aligncenter size-full wp-image-32689" src="../Images/40970b73c3fd05d856570d0a68068989.png" alt="custom element with template tag" srcset="https://blog.logrocket.com/wp-content/uploads/2021/01/template.png 542w, https://blog.logrocket.com/wp-content/uploads/2021/01/template-300x117.png 300w" sizes="(max-width: 542px) 100vw, 542px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2021/01/template.png"/></noscript>
<h2>反应组分</h2>
<p>React 组件有两种主要类型。</p>
<h3>类别组件</h3>
<p>类组件只是一个扩展了<code>React.Component</code>类的 JS 类。它接受道具，管理组件的状态，并通过 render 函数返回 JSX 代码。Props 包含从父组件传递的数据。组件的数据可以存储在状态对象中。每当状态改变时，组件都会重新呈现。它还包含生命周期方法，这些方法从组件的创建开始，一直运行到组件被销毁。例如，<code>constructor()</code>是组件实例被初始化时调用的第一个方法，因此状态在这里被初始化。</p>
<p>让我们看一个例子:</p>
<pre>import React from 'react';
import './style.css';

class MyComponent extends React.Component {

  constructor(props) {
    super(props);

    this.state = {
        value:"Touch me"
    };
  }
  buttonHandler=()=&gt;{
    if (this.state.value=="Touch me"){
      this.setState({value:'Touched!'})
    }
    else {
      this.setState({value:'Touch me'})
    }
  }
  render() {
    return(
      &lt;div&gt;
          &lt;h1&gt;My Component!&lt;/h1&gt;
          &lt;button onClick={this.buttonHandler} className="button"&gt;{this.state.value}&lt;/button&gt;
      &lt;/div&gt;
    );
  }
}
export default MyComponent;</pre>
<p><img data-attachment-id="32692" data-permalink="https://blog.logrocket.com/react-vs-web-components/mycomponentbutton/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2021/01/mycomponentbutton.png" data-orig-size="544,292" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="mycomponentbutton" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2021/01/mycomponentbutton-300x161.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2021/01/mycomponentbutton.png" decoding="async" class="aligncenter size-full wp-image-32692 jetpack-lazy-image" src="../Images/9c5232219cbb4dda5e3f93e05e850067.png" alt="my component button" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2021/01/mycomponentbutton.png 544w, https://blog.logrocket.com/wp-content/uploads/2021/01/mycomponentbutton-300x161.png 300w" data-lazy-sizes="(max-width: 544px) 100vw, 544px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2021/01/mycomponentbutton.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2021/01/mycomponentbutton.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="32692" data-permalink="https://blog.logrocket.com/react-vs-web-components/mycomponentbutton/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2021/01/mycomponentbutton.png" data-orig-size="544,292" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="mycomponentbutton" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2021/01/mycomponentbutton-300x161.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2021/01/mycomponentbutton.png" decoding="async" loading="lazy" class="aligncenter size-full wp-image-32692" src="../Images/9c5232219cbb4dda5e3f93e05e850067.png" alt="my component button" srcset="https://blog.logrocket.com/wp-content/uploads/2021/01/mycomponentbutton.png 544w, https://blog.logrocket.com/wp-content/uploads/2021/01/mycomponentbutton-300x161.png 300w" sizes="(max-width: 544px) 100vw, 544px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2021/01/mycomponentbutton.png"/></noscript>
<p>按下按钮时:</p>
<p><img data-attachment-id="32693" data-permalink="https://blog.logrocket.com/react-vs-web-components/mycomponentwithtouchedbutton/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2021/01/mycomponentwithtouchedbutton.png" data-orig-size="560,276" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="mycomponentwithtouchedbutton" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2021/01/mycomponentwithtouchedbutton-300x148.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2021/01/mycomponentwithtouchedbutton.png" decoding="async" class="aligncenter size-full wp-image-32693 jetpack-lazy-image" src="../Images/b34d4b7410372a1cbf0f2ff984a64274.png" alt="button reads &quot;touched!&quot;" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2021/01/mycomponentwithtouchedbutton.png 560w, https://blog.logrocket.com/wp-content/uploads/2021/01/mycomponentwithtouchedbutton-300x148.png 300w" data-lazy-sizes="(max-width: 560px) 100vw, 560px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2021/01/mycomponentwithtouchedbutton.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2021/01/mycomponentwithtouchedbutton.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="32693" data-permalink="https://blog.logrocket.com/react-vs-web-components/mycomponentwithtouchedbutton/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2021/01/mycomponentwithtouchedbutton.png" data-orig-size="560,276" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="mycomponentwithtouchedbutton" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2021/01/mycomponentwithtouchedbutton-300x148.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2021/01/mycomponentwithtouchedbutton.png" decoding="async" loading="lazy" class="aligncenter size-full wp-image-32693" src="../Images/b34d4b7410372a1cbf0f2ff984a64274.png" alt="button reads &quot;touched!&quot;" srcset="https://blog.logrocket.com/wp-content/uploads/2021/01/mycomponentwithtouchedbutton.png 560w, https://blog.logrocket.com/wp-content/uploads/2021/01/mycomponentwithtouchedbutton-300x148.png 300w" sizes="(max-width: 560px) 100vw, 560px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2021/01/mycomponentwithtouchedbutton.png"/></noscript>
<h3>功能组件</h3>
<p>简单地说，功能组件是一个返回 JSX 代码的 JavaScript 函数。以前，功能组件纯粹是表示性组件，因为它们不支持状态管理。然而，有了 React 钩子，我们现在也可以拥有状态和生命周期方法。</p>
<p>让我们用一个功能组件来做上面的例子:</p>
<pre>import React, {useState} from 'react';
import './style.css';

const MyComponent = (props) =&gt;{
    const [value, setValue] = useState("Touch me"); //creating a state using the useState hook

    const buttonHandler=()=&gt;{
    if (value=="Touch me"){
      setValue("Touched!") //set the value to Touched! if it is Touch me, changing state
    }
    else {
      setValue("Touch me") //changing state
    }
    }

    return (
      &lt;div&gt;
          &lt;h1&gt;My Component!&lt;/h1&gt;
          &lt;button onClick={buttonHandler} className="button"&gt;{value}&lt;/button&gt;
      &lt;/div&gt;
    )


}
export default MyComponent;</pre>
<p><img data-attachment-id="32695" data-permalink="https://blog.logrocket.com/react-vs-web-components/functionalcomponentbutton/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2021/01/functionalcomponentbutton.png" data-orig-size="532,262" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="functionalcomponentbutton" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2021/01/functionalcomponentbutton-300x148.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2021/01/functionalcomponentbutton.png" decoding="async" class="aligncenter size-full wp-image-32695 jetpack-lazy-image" src="../Images/092f6384ef1e60c358876f0052045205.png" alt="functional component button" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2021/01/functionalcomponentbutton.png 532w, https://blog.logrocket.com/wp-content/uploads/2021/01/functionalcomponentbutton-300x148.png 300w" data-lazy-sizes="(max-width: 532px) 100vw, 532px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2021/01/functionalcomponentbutton.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2021/01/functionalcomponentbutton.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="32695" data-permalink="https://blog.logrocket.com/react-vs-web-components/functionalcomponentbutton/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2021/01/functionalcomponentbutton.png" data-orig-size="532,262" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="functionalcomponentbutton" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2021/01/functionalcomponentbutton-300x148.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2021/01/functionalcomponentbutton.png" decoding="async" loading="lazy" class="aligncenter size-full wp-image-32695" src="../Images/092f6384ef1e60c358876f0052045205.png" alt="functional component button" srcset="https://blog.logrocket.com/wp-content/uploads/2021/01/functionalcomponentbutton.png 532w, https://blog.logrocket.com/wp-content/uploads/2021/01/functionalcomponentbutton-300x148.png 300w" sizes="(max-width: 532px) 100vw, 532px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2021/01/functionalcomponentbutton.png"/></noscript><br/>
When the button is pressed:<br/>
<img data-attachment-id="32696" data-permalink="https://blog.logrocket.com/react-vs-web-components/functionalcomponentwithtouchedbutton/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2021/01/functionalcomponentwithtouchedbutton.png" data-orig-size="630,284" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="functionalcomponentwithtouchedbutton" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2021/01/functionalcomponentwithtouchedbutton-300x135.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2021/01/functionalcomponentwithtouchedbutton.png" decoding="async" class="aligncenter size-full wp-image-32696 jetpack-lazy-image" src="../Images/1eef02707dfd161b29aca04bc8e86fed.png" alt="functional component with touched button" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2021/01/functionalcomponentwithtouchedbutton.png 630w, https://blog.logrocket.com/wp-content/uploads/2021/01/functionalcomponentwithtouchedbutton-300x135.png 300w" data-lazy-sizes="(max-width: 630px) 100vw, 630px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2021/01/functionalcomponentwithtouchedbutton.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2021/01/functionalcomponentwithtouchedbutton.png"/><noscript><img data-lazy-fallback="1" data-attachment-id="32696" data-permalink="https://blog.logrocket.com/react-vs-web-components/functionalcomponentwithtouchedbutton/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2021/01/functionalcomponentwithtouchedbutton.png" data-orig-size="630,284" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="functionalcomponentwithtouchedbutton" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2021/01/functionalcomponentwithtouchedbutton-300x135.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2021/01/functionalcomponentwithtouchedbutton.png" decoding="async" loading="lazy" class="aligncenter size-full wp-image-32696" src="../Images/1eef02707dfd161b29aca04bc8e86fed.png" alt="functional component with touched button" srcset="https://blog.logrocket.com/wp-content/uploads/2021/01/functionalcomponentwithtouchedbutton.png 630w, https://blog.logrocket.com/wp-content/uploads/2021/01/functionalcomponentwithtouchedbutton-300x135.png 300w" sizes="(max-width: 630px) 100vw, 630px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2021/01/functionalcomponentwithtouchedbutton.png"/></noscript>
<h2>式样</h2>
<p>说到构建组件，UI 是其中很大的一部分。你总是想创建漂亮的、吸引人的、用户友好的组件。然而，从头开始自己设计可能会有点乏味和耗时。此外，在 React 中，这变得更加困难，因为它不像 web 组件那样具有作用域样式。所以，你总是在寻找可以为你做这些工作的外部模块。</p>
<p>React 有一个庞大的生态系统。因此，与 web 组件相比，它有许多样式库和框架。</p>
<h3>反应</h3>
<h4>材料-用户界面</h4>
<p>它是 React 中最流行的 UI 框架之一。它由谷歌创建和维护。它提供了几个 UI 组件、样式、主题、布局和图标等。它是非常通用的，并且正在投入持续的工作和努力来不断改进它。它的最新稳定版本是截至 2020 年 12 月的 v4.11.1。</p>
<h4>反应引导</h4>
<p>React Bootstrap 是另一个流行的 React UI 框架，它取代了 Bootstrap JavaScript，并以 Bootstrap 为核心。它提供了各种组件、主题支持、布局等。它还有一个庞大的、不断增长的团队，其最新版本是支持 Bootstrap 4.5 的 v1.4.0。</p>
<h4>语义 UI 反应</h4>
<p>它是语义 UI 的 React 集成。它提供了许多很酷的自定义元素，例如，按钮、容器、加载器和输入等。它拥有与语义 UI 相同的样式系统和主题。所以，如果你知道它，你不需要学习任何新的东西。此外，它还有允许我们访问底层标记的子组件，正因为如此，我们可以灵活地定制元素。</p>
<h3>Web 组件</h3>
<h4>材料网组件</h4>
<p>这是 Material-UI 框架的 web 组件版本。然而，这仍然是一项正在进行的工作。它的最新版本是 v0.20.0，预计在 1.0 发布之前会有重大变化。</p>
<h4>web 组件中的引导</h4>
<p>有一些模块允许您在 web 组件中使用 Bootstrap。然而，有些仍然不稳定或正在开发中，有些则不像 React-Bootstrap 那样提供那么多功能。例如，bootstrap-webcomponents 是对 web 组件 bootstrap 的重写，但它仍处于开发模式。Aybolit Bootstrap 提供了一组受 Bootstrap 启发的 web 组件，但它没有广泛的组件和功能。</p>
<h4>Elix</h4>
<p>它是一个开放的现成 web 组件集合，用于常见的 UI 模式，如传送带、按钮和菜单等。它还让您可以灵活地定制它们，甚至基于现有的 Elix 组件创建新元素。</p>
<h2>可访问性(a11y)</h2>
<p>当我们谈论网站的可访问性时，我们的意思是它可以很容易地被每个人使用。如果我们的网站是用 React 或 web 组件创建的，那么这些组件需要是可访问的。那么，问题来了，他们是吗？</p>
<p>React 允许我们创建完全可访问的网站。这通常可以使用标准的 HTML 技术来完成。例如，我们可以像在普通 HTML 中一样在 JSX 使用<code>aria-*</code>属性，也就是说，它们不需要区分大小写。在 React 中，我们额外添加了一个 div 来包装所有元素，但是这样会破坏 HTML 语义，不是吗？的确如此，但是我们可以通过使用<code>&lt;React.Fragment&gt;</code>标签轻松解决这个问题。</p><div class="code-block code-block-54">
<hr/>
<h3>更多来自 LogRocket 的精彩文章:</h3>

<hr/></div>
<p>可访问性的另一个方面是应用程序应该只能通过键盘使用。现在，React 在运行时不断地改变 HTML DOM，正因为如此，键盘焦点可能会丢失。然而，我们可以在组件的各种生命周期方法中以编程方式设置焦点。此外，每当屏幕(组件)改变时，我们可以使用<code>react-document-title</code>改变标题。</p>
<p>Web 组件也是可访问的，因为自定义元素可以扩展任何本机 HTML 元素，因此，它继承了它的所有特征，包括可访问性功能。此外，还有一种误解，认为在影子 DOM 中创建的元素是不可访问的。然而，事实并非如此，屏幕阅读器可以很容易地访问内容。</p>
<p>本文到此为止。下表总结了这些差异。</p>
<table>
<thead>
<tr>
<th><strong>反应</strong></th>
<th><strong>网页组件</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>它是一个 JavaScript 库，用于为单页应用程序构建 UI 界面。</td>
<td>它是一组不同的技术，允许我们创建可重用和隔离的元素。</td>
</tr>
<tr>
<td>组件的类型包括功能性和类。</td>
<td>组件类型包括自定义元素、阴影 DOM 和模板。</td>
</tr>
<tr>
<td>基于状态变化的组件重渲染。</td>
<td>没有国家管理。</td>
</tr>
<tr>
<td>组件仅在 React 中可重用。</td>
<td>可互操作。</td>
</tr>
<tr>
<td>没有地方风格。</td>
<td>CSS 可以使用影子 DOM 来限定范围。</td>
</tr>
<tr>
<td>React 提供了单向数据流模式。</td>
<td>你必须自己实现数据绑定。</td>
</tr>
<tr>
<td>它的生态系统极其庞大和强大。它有一个庞大的社区和不断增长的工具和库。</td>
<td>生态系统没有 React 的生态系统庞大。</td>
</tr>
</tbody>
</table>
<p> </p><div class="code-block code-block-17">
<div class="blog-plug inline-plug react-plug" vwo-el-id="26283398190">
<h2 vwo-el-id="41600691720"><a href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener"> LogRocket </a>:全面了解您的生产 React 应用</h2><p>调试 React 应用程序可能很困难，尤其是当用户遇到难以重现的问题时。如果您对监视和跟踪 Redux 状态、自动显示 JavaScript 错误以及跟踪缓慢的网络请求和组件加载时间感兴趣，</p><a href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" vwo-el-id="19356441070">try LogRocket</a><p>. </p><a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="19356441380">
<img class="first-react-image alignnone size-full wp-image-46 jetpack-lazy-image jetpack-lazy-image--handled" src="../Images/f300c244a1a1cf916df8b4cb02bec6c6.png" vwo-el-id="18272717540" data-lazy-loaded="1" data-original-src="https://files.readme.io/27c94e7-Image_2017-06-05_at_9.46.04_PM.png"/>
</a>
<a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="19356441690">
<img class="second-react-image alignnone size-full wp-image-46 jetpack-lazy-image jetpack-lazy-image--handled" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" vwo-el-id="30720362350" data-lazy-loaded="1" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/>
</a>
<p vwo-el-id="28675660440" class="">LogRocket 结合了会话回放、产品分析和错误跟踪，使软件团队能够创建理想的 web 和移动产品体验。这对你来说意味着什么？</p>
<p>LogRocket 不是猜测错误发生的原因，也不是要求用户提供截图和日志转储，而是让您回放问题，就像它们发生在您自己的浏览器中一样，以快速了解哪里出错了。</p>
<p>不再有嘈杂的警报。智能错误跟踪允许您对问题进行分类，然后从中学习。获得有影响的用户问题的通知，而不是误报。警报越少，有用的信号越多。</p>
<p vwo-el-id="28675660750">LogRocket Redux 中间件包为您的用户会话增加了一层额外的可见性。LogRocket 记录 Redux 存储中的所有操作和状态。</p>
<p vwo-el-id="28675661060">现代化您调试 React 应用的方式— <a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="40093418840">开始免费监控</a>。</p>
</div></div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
<html>
<head>
<title>Build a Google Docs clone with React and Automerge - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>用 React 和 Automerge - LogRocket Blog 构建一个 Google Docs 克隆</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/build-google-docs-clone-react-automerge/#0001-01-01">https://blog.logrocket.com/build-google-docs-clone-react-automerge/#0001-01-01</a></blockquote><div><article class="article-post">
<p>协作在线文档在各行各业都很常见，它允许具有不同专业知识的人聚集在一起，将他们的工作写在(虚拟)纸上。它们提高参与度，提高生产率，鼓励解决问题，并允许参与者相互学习。</p>
<p>Automerge 是一个流行的库，用于在<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript" target="_blank" rel="noopener"> JavaScript </a>和<a href="https://reactjs.org/" target="_blank" rel="noopener"> React </a>生态系统中构建协作应用。它很容易设置和使用类似 JSON 的数据结构，不同的用户可以同时修改和合并该数据结构。</p>
<p>在本教程中，我们将构建一个<a href="https://docs.google.com" target="_blank" rel="noopener"> Google Docs </a>克隆，用户可以在其中创建、查看、编辑和删除文本文档。编辑器界面将支持<a href="https://en.wikipedia.org/wiki/WYSIWYG" target="_blank" rel="noopener">所见即所得</a>，所有编辑将在应用程序的不同实例之间自动同步。</p>
<p><img data-attachment-id="115914" data-permalink="https://blog.logrocket.com/build-google-docs-clone-react-automerge/attachment/google-docs-clone-output/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/06/google-docs-clone-output.png" data-orig-size="730,381" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="google-docs-clone-output" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/06/google-docs-clone-output-300x157.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/06/google-docs-clone-output.png" decoding="async" class="aligncenter wp-image-115914 size-full jetpack-lazy-image" src="../Images/89d3622161ad12225565ad7faf38be99.png" alt="Google Docs Clone Output" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2022/06/google-docs-clone-output.png 730w, https://blog.logrocket.com/wp-content/uploads/2022/06/google-docs-clone-output-300x157.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2022/06/google-docs-clone-output.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/06/google-docs-clone-output.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="115914" data-permalink="https://blog.logrocket.com/build-google-docs-clone-react-automerge/attachment/google-docs-clone-output/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/06/google-docs-clone-output.png" data-orig-size="730,381" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="google-docs-clone-output" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/06/google-docs-clone-output-300x157.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/06/google-docs-clone-output.png" decoding="async" loading="lazy" class="aligncenter wp-image-115914 size-full" src="../Images/89d3622161ad12225565ad7faf38be99.png" alt="Google Docs Clone Output" srcset="https://blog.logrocket.com/wp-content/uploads/2022/06/google-docs-clone-output.png 730w, https://blog.logrocket.com/wp-content/uploads/2022/06/google-docs-clone-output-300x157.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/06/google-docs-clone-output.png"/></noscript>
<p>作为参考，我们将要构建的项目部署在<a href="https://codesandbox.io/s/automerge-google-docs-rgsgcs" target="_blank" rel="noopener">这里</a>。</p>

<h2 id="initializing-a-react-app">初始化 React 应用程序</h2>
<p>首先，打开您的终端并运行命令<code>npx <a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="dab9a8bfbbaebff7a8bfbbb9aef7bbaaaa9ab6bbaebfa9ae">[email protected]</a> google-docs-clone</code>。该命令将创建一个全功能的 React 应用程序。</p>
<p>然后通过<code>cd google-docs-clone</code>在新创建的项目文件夹中更改您的工作目录，并运行<code>npm start</code>来启动 React developer 服务器。</p>
<p>现在，打开您的网络浏览器，导航到<a href="http://localhost:3000" target="_blank" rel="noopener"> http://localhost:3000 </a>查看您的应用。它应该是这样的:</p>
<p><img data-attachment-id="115916" data-permalink="https://blog.logrocket.com/build-google-docs-clone-react-automerge/attachment/localhost-react-output/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/06/localhost-react-output.png" data-orig-size="730,280" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="localhost-react-output" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/06/localhost-react-output-300x115.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/06/localhost-react-output.png" decoding="async" class="aligncenter wp-image-115916 size-full jetpack-lazy-image" src="../Images/9db321a8214c84a056c6e2239d35cbbf.png" alt="Localhost React Output" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2022/06/localhost-react-output.png 730w, https://blog.logrocket.com/wp-content/uploads/2022/06/localhost-react-output-300x115.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2022/06/localhost-react-output.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/06/localhost-react-output.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="115916" data-permalink="https://blog.logrocket.com/build-google-docs-clone-react-automerge/attachment/localhost-react-output/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/06/localhost-react-output.png" data-orig-size="730,280" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="localhost-react-output" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/06/localhost-react-output-300x115.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/06/localhost-react-output.png" decoding="async" loading="lazy" class="aligncenter wp-image-115916 size-full" src="../Images/9db321a8214c84a056c6e2239d35cbbf.png" alt="Localhost React Output" srcset="https://blog.logrocket.com/wp-content/uploads/2022/06/localhost-react-output.png 730w, https://blog.logrocket.com/wp-content/uploads/2022/06/localhost-react-output-300x115.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/06/localhost-react-output.png"/></noscript>
<p>切换回代码编辑器，删除<code>src</code>文件夹中的所有文件，因为我们将从头开始构建所有内容。</p>
<h2 id="installing-dependencies">安装依赖项</h2>
<p>为了安装所有必需的依赖项，在终端中运行以下命令:<code>npm install automerge react-quill react-router-dom uuid localforage</code>。</p>
<ul>
<li><a href="https://github.com/automerge/automerge" target="_blank" rel="noopener"> automerge </a>包将为应用程序提供核心功能，允许创建、编辑、删除和同步所有文档的数据</li>
<li><a href="https://github.com/zenoamaro/react-quill" target="_blank" rel="noopener"> react-quill </a>将用于 WYSIWYG 编辑器来编辑每个文档的内容。它将允许用户创建诸如标题、段落、列表和链接等元素</li>
<li><a href="https://v5.reactrouter.com/web/guides/quick-start" target="_blank" rel="noopener"> react-router-dom </a>将提供主仪表板和单个文档之间的路由，允许用户打开它们并切换回主页</li>
<li><a href="https://www.npmjs.com/package/uuid" target="_blank" rel="noopener"> uuid </a>包将为每个文档生成唯一的指示符，这些指示符将被传递给 URL 以使它们是唯一的</li>
<li><a href="https://github.com/localForage/localForage" target="_blank" rel="noopener">local feed</a>包将用于在用户机器上存储创建的数据。你也可以使用本地的<a href="https://developer.mozilla.org/en-US/docs/Web/API/Window/localStorage" target="_blank" rel="noopener">本地存储</a>，但是这个包会简化与它的交互</li>
</ul>
<h2 id="creating-the-base">创建基础</h2>
<p>我们首先需要创建将呈现我们的应用程序的主文件，并定义一些将在整个应用程序中使用的全局样式规则。</p>
<p>在<code>src</code>文件夹中，创建一个新文件<code>index.js</code>并包含以下代码:</p>
<pre class="language-javascript hljs">import ReactDOM from "react-dom/client";
import { BrowserRouter } from "react-router-dom";

import App from "./App";
import  "./styles.css";

const root = ReactDOM.createRoot(document.getElementById("root"));
root.render(
  &lt;BrowserRouter&gt;
    &lt;App /&gt;
  &lt;/BrowserRouter&gt;
);
</pre>
<p>我们导入了<code>ReactDOM</code>并创建了根元素，稍后我们用它来呈现应用程序。为了用<code>react-router-dom</code>，我们先导入，然后把整个 app 都包在里面。</p>
<p>创建一个新文件<code>styles.css</code>，并包含以下样式规则:</p>
<pre class="language-css hljs">* {
  margin: 0;
  padding: 0;
  box-sizing: border-box;
}

body {
  background-color: #eeeeee;
  min-height: 100vh;
}

.wrapper {
  font-family: sans-serif;
}

.ql-editor {
  min-height: calc(100vh - 100px);
  background-color: white;
}
</pre>
<p>我们首先删除了所有关于边距、填充和框大小的默认样式，这样我们的应用程序的布局在不同的浏览器上看起来是一样的。然后，我们将主体背景设置为非常浅的灰色，并确保它至少是视口的高度。</p>
<p>我们还将应用程序设置为使用 sans-serif 字体，并为编辑器窗口设置自定义规则。我们确保编辑器总是填充视口的高度，并将文本的背景颜色设置为白色，以便更好地与文本形成对比。</p>
<h2 id="creating-components">创建组件</h2>
<p>在终端中运行以下命令:</p>
<pre class="language-shell hljs">cd src &amp;&amp; mkdir components &amp;&amp; cd components &amp;&amp; touch ContentWrapper.js ContentWrapper.module.css Header.js Header.module.css DocumentCard.js DocumentCard.module.css AddButton.js AddButton.module.css
</pre>
<p>这将为应用程序创建所有必要的组件。</p>
<p>打开<code>ContentWrapper.js</code>并包含以下代码:</p>
<pre class="language-js hljs">lang=javascript
import styles from "./ContentWrapper.module.css";

export default function ({ children }) {
  return &lt;div className={styles.wrapper}&gt;{children}&lt;/div&gt;;
}
</pre>
<p>这将是主仪表板上所有文档卡片的包装组件。一旦实现了 app 逻辑，我们就会传递子组件。</p>
<p>打开<code>ContentWrapper.module.css</code>并包含以下样式规则:</p>
<pre class="language-css hljs">.wrapper {
  max-width: 1200px;
  margin: 20px auto;
  padding: 0 20px;
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
  gap: 20px;
}
</pre>
<p>我们确保包装宽度是有限的，居中，并在顶部和底部增加了一些余量。我们还在包装器的两侧添加了一些填充，这样内容在较小的屏幕上看起来也很好。</p>
<p>然后，我们将包装器设置为使用网格布局系统，其中每一列都不超过一定的宽度，并且响应不同的屏幕。为了改善布局，我们还在列之间添加了一些间隙。</p>
<p>打开<code>Header.js</code>并包含以下代码:</p>
<pre class="language-js hljs">lang=javascript
import styles from "./Header.module.css";

export default function ({ onClick }) {
  return (
    &lt;div className={styles.wrapper}&gt;
      &lt;p className={styles.title} onClick={onClick}&gt;
        Docs
      &lt;/p&gt;
    &lt;/div&gt;
  );
}
</pre>
<p>header 组件将显示 title 元素并接收<code>onClick</code> prop，这将把用户从应用程序的任何状态带到主仪表板。</p>
<p>打开<code>Header.module.css</code>并包含以下样式规则:</p>
<pre class="language-css hljs">.wrapper {
  background-color: #4480f7;
  padding: 20px;
  color: white;
}

.title {
  cursor: pointer;
}
</pre>
<p>我们将背景颜色设置为蓝色，添加一些填充，并将文本颜色设置为白色。为了改善 UX，我们将光标设置为当悬停在标题的 title 元素上时变为指针。</p>
<p>打开<code>DocumentCard.js</code>并包含以下代码:</p>
<pre class="language-js hljs">import styles from "./DocumentCard.module.css";

export default function ({ text, onClick, deleteHandler }) {
  const createTitle = (text) =&gt; {
    if (text.replace(/&lt;\/?[^&gt;]+(&gt;|$)/g, "")) {
      let parser = new DOMParser();
      const doc = parser.parseFromString(text, "text/html");
      const title =
        doc.body.childNodes[0].lastChild.innerHTML ||
        doc.body.childNodes[0].innerHTML;
      return title.length &gt; 10 ? `${title.slice(0, 10)}...` : title;
    }
    return "Untitled doc";
  };
  return (
    &lt;div className={styles.wrapper} onClick={onClick}&gt;
      &lt;div
        className={styles.preview}
        dangerouslySetInnerHTML={{ __html: text }}
      &gt;&lt;/div&gt;
      &lt;div className={styles.footer}&gt;
        &lt;div className={styles.title}&gt;{createTitle(text)}&lt;/div&gt;
        &lt;div className={styles.delete} onClick={deleteHandler}&gt;
          &lt;span role="img" aria-label="bin"&gt;
            ❌
          &lt;/span&gt;
        &lt;/div&gt;
      &lt;/div&gt;
    &lt;/div&gt;
  );
}
</pre>
<p>文件卡将由两个主要部分组成；预览区域和页脚。</p>
<p>预览区域将接收到<code>text</code> prop，这将是一串原始的 HTML 代码，我们将使用<code>dangerouslySetInnerHTML</code>来生成它的预览。</p>
<p>页脚将包含卡片的标题，该标题将从<code>text</code>属性中的第一个节点生成，并使用<code>createTitle</code>函数限制为 10 个字符。它还将包括删除按钮，这将允许用户删除卡与<code>deleteHandler</code>道具。</p><div class="code-block code-block-54">
<hr/>
<h3>更多来自 LogRocket 的精彩文章:</h3>

<hr/></div>
<p>卡片还会收到<code>onClick</code>道具，道具会打开卡片并显示编辑器。</p>
<p>打开<code>DocumentCard.module.css</code>并包含以下样式规则:</p>
<pre class="language-css hljs">.wrapper {
  background-color: white;
  padding: 10px;
  border: 1px solid rgb(223, 223, 223);
  border-radius: 5px;
}

.wrapper:hover {
  border: 1px solid #4480f7;
  cursor: pointer;
}

.preview {
  height: 200px;
  overflow: hidden;
  font-size: 50%;
  word-wrap: break-word;
}

.footer {
  display: grid;
  grid-template-columns: auto 20px;
  min-height: 40px;
  border-top: 1px solid rgb(223, 223, 223);
  padding-top: 10px;
}

.title {
  color: #494949;
  font-weight: bold;
}

.delete {
  font-size: 12px;
}
</pre>
<p>我们将卡片的主包装设为白色，添加一些填充，设置一个灰色边框，并为一些平滑的边缘添加一个边框半径。我们还确保卡片将边框颜色更改为蓝色，并将光标更改为悬停时的指针。</p>
<p>对于预览块，我们定义了一个特定的高度，通过将其正常大小减半来确保包含更多的文本，并确保较长的单词被拆分。</p>
<p>对于页脚区域，我们设置了一个特定的高度，在顶部添加了一些边距和填充，并使用网格布局将宽度分成两列。</p>
<p>第一列将包括标题，标题将使用深灰色并加粗。第二列将包括删除按钮，我们减小了它的字体大小。</p>
<p>打开<code>AddButton.js</code>并包含以下代码:</p>
<pre class="language-js hljs">import styles from "./AddButton.module.css";

export default function AddButton({ onClick }) {
  return (
    &lt;div className={styles.wrapper} onClick={onClick}&gt;
      &lt;p className={styles.sign}&gt;+&lt;/p&gt;
    &lt;/div&gt;
  );
}
</pre>
<p>add 按钮将包含加号并接收<code>onClick</code>属性，这将允许用户在单击它时创建一个新文档。</p>
<p>打开<code>AddButton.module.css</code>并包含以下样式规则:</p>
<pre class="language-css hljs">.wrapper {
  display: grid;
  place-items: center;
  height: 60px;
  width: 60px;
  border-radius: 50%;
  background-color: #4480f7;
  position: fixed;
  bottom: 20px;
  right: 20px;
}

.wrapper:hover {
  cursor: pointer;
  box-shadow: rgba(0, 0, 0, 0.1) 0px 20px 25px -5px,
    rgba(0, 0, 0, 0.04) 0px 10px 10px -5px;
}

.sign {
  font-size: 28px;
  color: white;
}
</pre>
<p>我们使用网格布局，将包装器的内容居中，将元素设置为使用特定的宽度和高度，将其设置为圆形，设置蓝色背景色，并确保它总是显示在屏幕的右下角。</p>
<p>为了改善 UX，我们还将光标设置为指针，并在悬停时显示一些方框阴影。为了改进 UI，我们还增加了加号的字体大小，并以白色显示。</p>
<h2 id="implementing-the-logic">实现逻辑</h2>
<p>在<code>src</code>文件夹中，创建一个新文件<code>App.js</code>，并包含以下代码:</p>
<pre class="language-js hljs">import { useState, useEffect, useCallback, useMemo } from "react";
import { useNavigate } from "react-router-dom";

import * as Automerge from "automerge";
import localforage from "localforage";
import Header from "./components/Header";
import ContentWrapper from "./components/ContentWrapper";
import DocumentCard from "./components/DocumentCard";
import AddButton from "./components/AddButton";

import ReactQuill from "react-quill";
import "react-quill/dist/quill.snow.css";

import { v4 as uuidv4 } from "uuid";

let doc = Automerge.init();

export default function App() {
  const navigate = useNavigate();

  const [editorVisible, setEditorVisible] = useState(false);
  const [editorValue, setEditorValue] = useState("");

  let docId = window.location.pathname.split("/").pop();
  let channel = useMemo(() =&gt; {
    return new BroadcastChannel(docId);
  }, [docId]);

  const initDocuments = useCallback(() =&gt; {
    if (localforage.getItem("automerge-data") &amp;&amp; !docId) {
      setEditorVisible(false);
      async function getItem() {
        return await localforage.getItem("automerge-data");
      }

      getItem()
        .then((item) =&gt; {
          if (item) {
            doc = Automerge.load(item);
            navigate(`/`);
          }
        })
        .catch((err) =&gt; console.log(err));
    }
  }, [navigate, docId]);

  useEffect(() =&gt; {
    initDocuments();
  }, [initDocuments]);

  const addDocument = () =&gt; {
    const id = uuidv4();
    let newDoc = Automerge.change(doc, (doc) =&gt; {
      setEditorValue("");
      if (!doc.documents) doc.documents = [];
      doc.documents.push({
        id,
        text: editorValue,
        done: false
      });
      navigate(`/${id}`);
    });

    let binary = Automerge.save(newDoc);
    localforage.clear();
    localforage
      .setItem("automerge-data", binary)
      .catch((err) =&gt; console.log(err));
    doc = newDoc;
  };

  const loadDocument = useCallback(() =&gt; {
    if (docId) {
      setEditorVisible(true);
      async function getItem() {
        return await localforage.getItem("automerge-data");
      }

      getItem()
        .then((item) =&gt; {
          if (item) {
            doc = Automerge.load(item);

            const itemIndex = doc.documents.findIndex(
              (item) =&gt; item.id === docId
            );
            if (itemIndex !== -1) {
              setEditorValue(doc.documents[itemIndex].text);
            } else {
              navigate("/");
              setEditorVisible(false);
            }
          }
        })
        .catch((err) =&gt; console.log(err));
    }
  }, [docId, navigate]);

  useEffect(() =&gt; {
    loadDocument();
  }, [loadDocument]);

  const updateDocument = useCallback(() =&gt; {
    if (Object.keys(doc).length !== 0) {
      const itemIndex = doc.documents.findIndex((item) =&gt; item.id === docId);

      if (itemIndex !== -1) {
        let newDoc = Automerge.change(doc, (doc) =&gt; {
          doc.documents[itemIndex].text = editorValue;
        });

        let binary = Automerge.save(newDoc);
        localforage
          .setItem("automerge-data", binary)
          .catch((err) =&gt; console.log(err));
        doc = newDoc;
        channel.postMessage(binary);
      }
    }
  }, [docId, editorValue, channel]);

  useEffect(() =&gt; {
    updateDocument();
  }, [updateDocument]);

  const deleteDocument = (docId) =&gt; {
    if (Object.keys(doc).length !== 0) {
      const itemIndex = doc.documents.findIndex((item) =&gt; item.id === docId);

      if (itemIndex !== -1) {
        let newDoc = Automerge.change(doc, (doc) =&gt; {
          doc.documents.splice(itemIndex, 1);
        });

        let binary = Automerge.save(newDoc);
        localforage
          .setItem("automerge-data", binary)
          .catch((err) =&gt; console.log(err));
        doc = newDoc;
        channel.postMessage(binary);
      }
      navigate("/");
    }
  };

  const syncDocument = useCallback(() =&gt; {
    channel.onmessage = (ev) =&gt; {
      let newDoc = Automerge.merge(doc, Automerge.load(ev.data));
      doc = newDoc;
    };
  }, [channel]);

  useEffect(() =&gt; {
    syncDocument();
  }, [syncDocument]);

  return (
    &lt;div className="wrapper"&gt;
      &lt;Header
        onClick={() =&gt; {
          setEditorVisible(false);
          navigate("/");
        }}
      /&gt;
      {!editorVisible ? (
        &lt;ContentWrapper&gt;
          {Object.keys(doc).length !== 0 &amp;&amp;
            doc.documents.map((document, index) =&gt; {
              return (
                &lt;DocumentCard
                  key={index}
                  text={document.text}
                  onClick={() =&gt; {
                    setEditorVisible(true);
                    navigate(`/${document.id}`);
                  }}
                  deleteHandler={(e) =&gt; {
                    e.stopPropagation();
                    deleteDocument(document.id);
                  }}
                /&gt;
              );
            })}
          &lt;AddButton
            onClick={() =&gt; {
              setEditorVisible(true);
              addDocument();
            }}
          /&gt;
        &lt;/ContentWrapper&gt;
      ) : (
        &lt;ReactQuill
          theme="snow"
          value={editorValue}
          onChange={setEditorValue}
        /&gt;
      )}
    &lt;/div&gt;
  );
}
</pre>
<p>首先，我们导入了所有必要的 React 挂钩来跟踪应用程序状态，并在执行某些操作时执行副作用，我们安装的所有依赖项实例以及我们在上一步中创建的所有组件。</p>
<p>然后，我们初始化了 Automerge 实例。我们还创建了<code>editorVisible</code>和<code>editorState</code>来跟踪编辑器的存在及其内容，并创建了几个函数来为应用程序提供创建、读取、更新、删除和同步功能:</p>
<p><code>initDocuments()</code>在初始启动时或 URL 更改为主仪表板时从 local feed 获取文档，以使用<code>automerge.load()</code>刷新内容</p>
<p>按下添加按钮后,<code>addDocument()</code>启动。它使用<code>automerge.change()</code>在数组对象中推送一个新文档，并使用<code>automerge.save()</code>保存它。</p>
<p><code>loadDocument()</code>用于在使用<code>automerge.load()</code>在所见即所得编辑器中打开特定文档后获取该文档的信息。</p>
<p>每次用户在编辑器中进行任何编辑时，都会使用<code>updateDocument()</code>。文档首先用<code>automerge.change()</code>编辑，然后用<code>automerge.save()</code>保存。</p>
<p>按下删除图标后，启动<code>deleteDocument()</code>；用<code>automerge.change()</code>从文档数组中删除文档，用<code>automerge.save()</code>保存。</p>
<p><code>syncDocument()</code>使用<code>automerge.merge()</code>功能同步来自应用程序其他实例的数据，并更新当前文档数组。</p>
<p>最后，我们渲染了所有导入的组件，并传递了所需的道具</p>
<h2 id="testing-the-app">测试应用程序</h2>
<p>首先，检查你的应用是否还在<a href="http://localhost:3000" rel="nofollow"> http://localhost:3000 </a>上运行。如果不是，请在您的终端中再次运行<code>npm start</code>。</p>
<p>点击右下角的<strong>添加</strong>按钮，创建一个新文档。您将被带到编辑器来创建内容。请注意，该文档收到了一个惟一的 ID。</p>
<p><img data-attachment-id="115921" data-permalink="https://blog.logrocket.com/build-google-docs-clone-react-automerge/attachment/app-test-final/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/06/app-test-final.gif" data-orig-size="730,381" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="app-test-final" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/06/app-test-final-300x157.gif" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/06/app-test-final.gif" decoding="async" class="aligncenter wp-image-115921 size-full jetpack-lazy-image" src="../Images/46a8dc7533be0d2c9e27c48c26d3a111.png" alt="App Test Final" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2022/06/app-test-final.gif?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/06/app-test-final.gif"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="115921" data-permalink="https://blog.logrocket.com/build-google-docs-clone-react-automerge/attachment/app-test-final/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/06/app-test-final.gif" data-orig-size="730,381" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="app-test-final" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/06/app-test-final-300x157.gif" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/06/app-test-final.gif" decoding="async" loading="lazy" class="aligncenter wp-image-115921 size-full" src="../Images/46a8dc7533be0d2c9e27c48c26d3a111.png" alt="App Test Final" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/06/app-test-final.gif"/></noscript>
<p>现在在你的浏览器上打开一个新的标签页。请注意，您在前一个选项卡中创建的所有文档都已经在那里了。打开它们中的任何一个并进行一些更改。</p>
<p>切换回另一个标签，打开您在前一个标签中编辑的文档，您所做的更改现在应该会自动同步。</p>
<p><img data-attachment-id="115918" data-permalink="https://blog.logrocket.com/build-google-docs-clone-react-automerge/attachment/app-test-thesis/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/06/app-test-thesis.gif" data-orig-size="730,469" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="app-test-thesis" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/06/app-test-thesis-300x193.gif" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/06/app-test-thesis.gif" decoding="async" class="aligncenter wp-image-115918 size-full jetpack-lazy-image" src="../Images/af4d32203ab810990a64e49b6bff8256.png" alt="App Test Thesis" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2022/06/app-test-thesis.gif?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/06/app-test-thesis.gif"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="115918" data-permalink="https://blog.logrocket.com/build-google-docs-clone-react-automerge/attachment/app-test-thesis/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/06/app-test-thesis.gif" data-orig-size="730,469" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="app-test-thesis" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/06/app-test-thesis-300x193.gif" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/06/app-test-thesis.gif" decoding="async" loading="lazy" class="aligncenter wp-image-115918 size-full" src="../Images/af4d32203ab810990a64e49b6bff8256.png" alt="App Test Thesis" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/06/app-test-thesis.gif"/></noscript>
<p>此外，如果有人试图在 URL 中使用错误的 ID 进行记录，应用程序会自动将用户重定向到主仪表板。</p>
<h2 id="conclusion">结论</h2>
<p>在本教程中，我们学习了如何实现文本文档的创建、读取、更新和删除功能。我们还使文档协同工作，这意味着所有的更改都会自动与应用程序的其他实例同步。</p>
<p>请随意<a href="https://codesandbox.io/s/automerge-google-docs-rgsgcs" target="_blank" rel="noopener">派生项目</a>并添加额外的特性来满足您的特定需求。例如，您可以添加云解决方案来存储数据，并为应用程序添加身份验证，以便您可以在线使用应用程序，并仅邀请特定用户使用它。</p>
<p>下一次你必须提出一个协作文档解决方案时，你将知道实现它所需的技术和工具。</p><div class="code-block code-block-17">
<div class="blog-plug inline-plug react-plug" vwo-el-id="26283398190">
<h2 vwo-el-id="41600691720">使用 LogRocket 消除传统反应错误报告的噪音</h2>
<a href="https://lp.logrocket.com/blg/react-signup-issue-free" target="_blank" vwo-el-id="19356441070">LogRocket
</a><p>是一款 React analytics 解决方案，可保护您免受数百个误报错误警报的影响，只针对少数真正重要的项目。LogRocket 告诉您 React 应用程序中实际影响用户的最具影响力的 bug 和 UX 问题。</p><a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="19356441380">
<img class="first-react-image alignnone size-full wp-image-46 jetpack-lazy-image jetpack-lazy-image--handled" src="../Images/f300c244a1a1cf916df8b4cb02bec6c6.png" vwo-el-id="18272717540" data-lazy-loaded="1" data-original-src="https://files.readme.io/27c94e7-Image_2017-06-05_at_9.46.04_PM.png"/>
</a>
<a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="19356441690">
<img class="second-react-image alignnone size-full wp-image-46 jetpack-lazy-image jetpack-lazy-image--handled" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" vwo-el-id="30720362350" data-lazy-loaded="1" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/>
</a>
<a href="https://lp.logrocket.com/blg/react-signup-issue-free" target="_blank" rel="noopener noreferrer" vwo-el-id="35866400580">LogRocket
</a><p>自动聚合客户端错误、反应错误边界、还原状态、缓慢的组件加载时间、JS 异常、前端性能指标和用户交互。然后，LogRocket 使用机器学习来通知您影响大多数用户的最具影响力的问题，并提供您修复它所需的上下文。</p><p vwo-el-id="28675661060">关注重要的 React bug—<a class="signup" href="https://lp.logrocket.com/blg/react-signup-issue-free" target="_blank" rel="noopener noreferrer" vwo-el-id="40093418840">今天就试试 LogRocket】。</a></p>
</div></div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
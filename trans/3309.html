<html>
<head>
<title>Caching clash: SWR vs. TanStack Query for React - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>缓存冲突:SWR vs. TanStack对React - LogRocket博客的查询</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/swr-vs-tanstack-query-react/#0001-01-01">https://blog.logrocket.com/swr-vs-tanstack-query-react/#0001-01-01</a></blockquote><div><article class="article-post">
<p>大多数React应用程序与远程数据源通信，以持久化和检索数据记录。如今，Web应用程序开发团队倾向于使用REST和类似GraphQL的通信模式来实现他们的远程数据源接口。然后，前端开发团队必须通过他们的React应用程序向各种库发出网络请求，以在客户端和服务器端之间同步数据。</p>
<p>对于与RESTful服务的通信，最简单的方法是使用组件中的<a href="https://blog.logrocket.com/axios-vs-fetch-best-http-requests/" target="_blank" rel="noopener">内置Fetch API或类似Axios </a>的库来装载类似状态的事件。然后，您必须编写额外的逻辑来实现加载状态UI增强。最后，为了通过数据缓存、重复数据删除API查询和预取使您的应用程序更加用户友好和优化，您可能需要编写比客户端业务逻辑更多的代码！</p>
<p>这就是像SWR和TanStack Query(以前的React Query)这样的库可以通过缓存、预取、查询重复数据删除和各种其他可用性功能来帮助您将数据源的状态与React应用程序的状态同步的地方。</p>
<p>在本文中，我将通过一个实际的示例项目来比较SWR和TanStack查询库的特性。以下是我们将要介绍的内容:</p>

<h2 id="react-swr">SWR的反应是什么？</h2>
<p><a href="https://github.com/vercel/swr" target="_blank" rel="noopener"> SWR </a>是一个开源的、轻量级的、支持类型脚本的库，它提供了几个钩子用于在React和缓存中获取数据。缩写“SWR”代表重新验证时的状态，这是HTTP <a href="https://tools.ietf.org/html/rfc5861" target="_blank" rel="noopener"> RFC 5861 </a>中的通用缓存原则。</p>
<p>React SWR于2019年通过其v0.1.2公开发布首次发布。</p>
<h3>突出显示的功能</h3>
<p>该库提供了以下突出的功能:</p>
<table>
<thead>
<tr>
<th>特征</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>轻巧的尺寸和高性能</td>
<td>根据BundlePhobia 的说法，SWR图书馆压缩后大约重4.2千字节。SWR开发团队通过树摇动捆绑策略关注性能和轻量级</td>
</tr>
<tr>
<td>最小的、可配置的、可重用的API</td>
<td>SWR also focuses on offering a minimal, developer-friendly API for React developers that provides performance-friendly features. You can implement most of the things you need with a single Hook, <code>useSWR</code>.
<p>尽管API很小，但它允许您使用全局配置和许多挂钩选项来调整缓存系统和行为。</p></td>
</tr>
<tr>
<td>面向开发人员和用户的内置功能</td>
<td>SWR支持分页请求，并提供了<code>useSWRInfinite</code>钩子来实现无限加载。它还可以与React Suspense API、SSG和SSR配合使用，并提供预取、焦点重新验证和网络状态重新获取，如应用程序用户的可用性增强。</td>
</tr>
</tbody>
</table>
<h2 id="using-react-swr">使用反应SWR</h2>
<p>现在，我们已经对SWR在React中优化数据获取的特性有了一个概述，让我们用SWR创建一个示例应用程序，并对其进行评估，以找到与TanStack Query的比较点。</p>
<p>我们可以通过在客户端延迟承诺来模拟API后端，以尝试SWR，但这种方法并不能提供真正的数据获取体验。让我们用Node.js创建一个简单的RESTful API。我们可以用<a href="https://github.com/typicode/json-server" target="_blank" rel="noopener"> <code>json-server</code>包</a>在几秒钟内创建一个RESTful API服务器。</p>
<p>首先，全局安装<code>json-server</code>包:</p>
<pre class="language-bash hljs">npm install -g json-server
# --- or ---
yarn global add json-server
</pre>
<p>接下来，将以下内容添加到名为<code>db.json</code>的新文件中:</p>
<pre class="language-json hljs">{
  "products": [
    {
      "id": 1,
      "name": "ProX Watch",
      "price": 20
    },
    {
      "id": 2,
      "name": "Magic Pencil",
      "price": 2
    },
    {
      "id": 3,
      "name": "RevPro Wallet",
      "price": 15
    },
    {
      "id": 4,
      "name": "Rice Cooker",
      "price": 25
    },
    {
      "id": 5,
      "name": "CookToday Oven",
      "price": 10
    }
  ]
}
</pre>
<p>接下来，运行以下命令来启动基于<code>db.json</code>文件的RESTful CRUD服务器:</p>
<pre class="language-bash hljs">json-server --watch --port=5000 --delay=1000 db.json
</pre>
<p>现在，我们可以通过<a href="http://localhost:5000/products" target="_blank" rel="noopener"> <code>http://localhost:5000/products</code> </a>访问我们的CRUD API。如果你愿意，你可以用邮差测试一下。在我们的示例中，我们添加了1000毫秒的延迟来模拟网络延迟。</p>
<p>让我们创建一个新的React应用程序，并通过SWR获取数据。如果你已经是SWR的用户或者你以前用过SWR，你可以在下面的<a href="https://github.com/codezri/react-swr-example" target="_blank" rel="noopener">这个GitHub库</a>和<a href="#tanstack-query">中查看完整的项目。</a></p>
<p>像往常一样创建一个新的React应用程序:</p>
<pre class="language-bash hljs">npx create-react-app react-swr-example
cd react-swr-example
</pre>
<h3 id="installing-swr-package">安装软件包</h3>
<p>接下来，使用以下命令安装<code>swr</code>包:</p>
<pre class="language-bash hljs">npm install swr
# --- or ---
yarn add swr
</pre>
<p>我们将在本教程中使用Axios，所以也用下面的命令安装它。您可以使用任何HTTP请求库或内置的<code>fetch</code>，因为SWR只希望得到承诺。</p>
<pre class="language-bash hljs">npm install axios
# --- or --- 
yarn add axios
</pre>
<h3 id="implementing-data-fetchers-custom-hooks-swr">实现数据提取器和自定义挂钩</h3>
<p>我们将通过创建一个简单的产品管理应用程序来评估SWR，该应用程序列出了一些产品，并允许您添加新产品。首先，我们需要将本地模拟API的基本URL存储在<code>.env</code>文件中。创建一个名为<code>.env</code>的新文件，并添加以下内容:</p>
<pre class="language-plaintext hljs">REACT_APP_API_BASE_URL = "http://localhost:5000"
</pre>
<p>接下来，通过将以下内容添加到<code>index.js</code>文件，使用Axios全局配置中的基本URL:</p>
<pre class="language-javascript hljs">import React from 'react';
import ReactDOM from 'react-dom/client';
import axios from 'axios';

import './index.css';
import App from './App';

axios.defaults.baseURL = process.env.REACT_APP_API_BASE_URL;

const root = ReactDOM.createRoot(document.getElementById('root'));
root.render(
    &lt;App /&gt;
);
</pre>
<p>我们将所有的应用程序组件保存在我们的<code>App.js</code>文件中，以保持教程的简单性。清理您的<code>App.js</code>文件中的所有内容，并添加以下导入:</p>
<pre class="language-javascript hljs">import React, { useState } from 'react';
import useSWR from 'swr';
import axios from 'axios';

import './App.css';
</pre>
<p>这里，我们从<code>swr</code>导入<code>useSWR</code>钩子来检索缓存的数据记录，而不是直接调用Axios函数。</p>
<p>为了在没有RESTful URL参数的情况下获取数据，我们通常需要向<code>useSWR</code>钩子提供两个参数:一个惟一的键(通常是URL)和一个fetcher函数，这是一个返回异步数据的JavaScript函数。</p>
<p>添加包含提取器的以下代码:</p>
<pre class="language-javascript hljs">function fetcher(url) {
  return axios.get(url).then(res =&gt; res.data);
}

async function addProduct(product) {
  let response = await axios.post('/products', product);
  return response.data;
}
</pre>
<p>这里，<code>fetcher</code>函数通过Axios异步返回数据，而<code>addProduct</code>函数类似地发布产品数据并返回新创建的产品。</p>
<p>现在，我们可以在功能组件中使用<code>useSWR(‘/products’, fetcher)</code>语句来获取缓存的产品，但是SWR开发者建议使用可重用的定制钩子。将以下挂钩添加到<code>App.js</code>文件中:</p>
<pre class="language-javascript hljs">function useProducts() {
  const { data, error, mutate } = useSWR('/products', fetcher);
  return {
    products: data,
    isLoading: !data,
    isError: !!error,
    mutate
  };
}
</pre>
<p>我们的<code>useProducts</code>自定义钩子输出以下道具:</p>
<ul>
<li><code>products</code>:从API取数据后的产品数组；如果API中没有可用数据，则变为<code>undefined</code></li>
<li><code>isLoading</code>:基于API数据加载指标</li>
<li><code>isError</code>:表示加载错误的布尔值</li>
<li><code>mutate</code>:更新缓存数据的功能，即时反映在UI上</li>
</ul>
<h3 id="using-swr-data-fetching">使用SWR获取数据</h3>
<p>现在我们可以使用<code>useProducts</code>数据钩子从后端数据更新UI。创建<code>Products</code>组件来列出所有可用的产品:</p>
<pre class="language-javascript hljs">function Products() {
  const { products, isLoading, isError } = useProducts();
  if(isError)
    return (
      &lt;div&gt;Unable to fetch products.&lt;/div&gt;
    );

  if(isLoading)
    return (
      &lt;div&gt;Loading products...&lt;/div&gt;
    );

  return (
    products.map((product) =&gt; (
      &lt;div key={product.id} className="product-item"&gt;
        &lt;div&gt;{product.name}&lt;/div&gt;
        &lt;div&gt;${product.price}&lt;/div&gt;
      &lt;/div&gt;
    ))
  );
}
</pre>
<p><code>Products</code>组件根据<code>useProducts</code>钩子属性进行有条件的渲染。如果你在许多组件中多次使用这个钩子，SWR将只发起一个HTTP请求，根据请求重复数据删除特性，然后，提取的数据将通过<code>useProducts</code>钩子与渲染过程的所有组件共享。</p>
<h3 id="mutating-cached-data-invalidating-requests-swr">变更缓存数据和使请求无效</h3>
<p>创建一个名为<code>AddProduct</code>的组件，并使用以下代码实现一种添加新产品的方法:</p>
<pre class="language-javascript hljs">function AddProduct({ goToList }) {
  const { products, mutate } = useProducts();
  const [product, setProduct] = useState({
    id: products.length + 1,
    name: '',
    price: null
  });
  const [disabled, setDisabled] = useState(true);

  async function handleAdd() {
    goToList();
    mutate(async () =&gt; {
      return [...products, await addProduct(product)]
    }, { optimisticData: [...products, product], rollbackOnError: true, revalidate: false } );
  }

  function handleFieldUpdate(e) {
    const element = e.target;
    const value = element.type === 'number' ? parseInt(element.value) : element.value;
    const nextProduct = {...product, [element.name]: value};

    setProduct(nextProduct);
    setDisabled(!nextProduct.name || !nextProduct.price);
  }

  return(
    &lt;div className="product-form"&gt;
      &lt;input
        type="text"
        name="name"
        placeholder="Name"
        autoFocus
        onChange={handleFieldUpdate}/&gt;
      &lt;input
        type="number"
        name="price"
        min="1"
        placeholder="Price"
        onChange={handleFieldUpdate}/&gt;
      &lt;button onClick={handleAdd} disabled={disabled}&gt;Add&lt;/button&gt;
    &lt;/div&gt;
  );
}
</pre>
<p>仔细阅读<code>mutate</code>函数调用:</p>
<pre class="language-javascript hljs">mutate(async () =&gt; {
  return [...products, await addProduct(product)]
}, {
    optimisticData: [...products, product],
    rollbackOnError: true,
    revalidate: false
    }
);
</pre>
<p>这里，我们要求SWR用<code>optimisticData</code>选项直接更新渲染产品；然后，我们可以使用<code>addProduct</code>函数调用将指定的元素插入数据库。我们还可以从异步函数返回更新的产品列表，因为我们的SWR变异需要从异步函数的返回值中获得更新的数据记录。</p>
<p>最后一步，添加导出的<code>App</code>组件并完成实现:</p>
<pre class="language-javascript hljs">function App() {
  const [ mode, setMode ] = useState('list');
  return (
    &lt;&gt;
    &lt;div className="menu-bar"&gt;
      &lt;div onClick={() =&gt; { setMode('list') }}
          className={mode === 'list' ? 'selected' : ''}&gt;All products&lt;/div&gt;
      &lt;div onClick={() =&gt; { setMode('add') }}
          className={mode === 'add' ? 'selected' : ''}&gt;Add product&lt;/div&gt;
    &lt;/div&gt;
    &lt;div className="wrapper"&gt;
      { mode === 'list' ? &lt;Products/&gt; :
          &lt;AddProduct goToList={() =&gt; setMode('list')}/&gt; }
    &lt;/div&gt;
    &lt;/&gt;
  );
}

export default App;
</pre>
<p>现在运行应用程序:</p>
<pre class="language-bash hljs">npm start
# --- or --- 
yarn start
</pre>
<p>首先，研究SWR如何缓存<code>ProductList</code>组件的数据——您将只看到一次加载文本。稍后，您将收到缓存的内容。</p>
<p>看下面的预告:</p>
<figure id="attachment_129811" aria-describedby="caption-attachment-129811" class="wp-caption aligncenter"><img data-attachment-id="129811" data-permalink="https://blog.logrocket.com/swr-vs-tanstack-query-react/attachment/caching-product-list-data-swr/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/09/caching-product-list-data-swr.gif" data-orig-size="730,439" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="caching-product-list-data-swr" data-image-description="" data-image-caption="&lt;p&gt;Caching the product list data with SWR&lt;/p&gt;&#10;" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/09/caching-product-list-data-swr-300x180.gif" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/09/caching-product-list-data-swr.gif" decoding="async" class="size-full wp-image-129811 jetpack-lazy-image" src="../Images/d9c533db66d2eea6a29400b34bf0213a.png" alt="Caching the product list data with SWR" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2022/09/caching-product-list-data-swr.gif?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/09/caching-product-list-data-swr.gif"/><noscript><img data-lazy-fallback="1" data-attachment-id="129811" data-permalink="https://blog.logrocket.com/swr-vs-tanstack-query-react/attachment/caching-product-list-data-swr/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/09/caching-product-list-data-swr.gif" data-orig-size="730,439" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="caching-product-list-data-swr" data-image-description="" data-image-caption="&lt;p&gt;Caching the product list data with SWR&lt;/p&gt;&#10;" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/09/caching-product-list-data-swr-300x180.gif" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/09/caching-product-list-data-swr.gif" decoding="async" loading="lazy" class="size-full wp-image-129811" src="../Images/d9c533db66d2eea6a29400b34bf0213a.png" alt="Caching the product list data with SWR" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/09/caching-product-list-data-swr.gif"/></noscript><figcaption id="caption-attachment-129811" class="wp-caption-text">Caching the product list data with SWR</figcaption></figure>
<p>接下来，注意SWR是如何通过在更新和重新获取<code>AddProduct</code>组件中的后台数据之前直接操作呈现的内容来提高可用性的。添加一个新产品，可以看到数据记录立即呈现出来，如下所示:</p>
<figure id="attachment_129816" aria-describedby="caption-attachment-129816" class="wp-caption aligncenter"><img data-attachment-id="129816" data-permalink="https://blog.logrocket.com/swr-vs-tanstack-query-react/attachment/updating-cached-content-before-api-call/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/09/updating-cached-content-before-api-call.gif" data-orig-size="730,439" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="updating-cached-content-before-api-call" data-image-description="" data-image-caption="&lt;p&gt;Updating the cached content before the API call&lt;/p&gt;&#10;" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/09/updating-cached-content-before-api-call-300x180.gif" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/09/updating-cached-content-before-api-call.gif" decoding="async" class="size-full wp-image-129816 jetpack-lazy-image" src="../Images/9ef5a6f8c9e8fe7fffddf11e1c0164f0.png" alt="Updating the cached content before the API call" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2022/09/updating-cached-content-before-api-call.gif?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/09/updating-cached-content-before-api-call.gif"/><noscript><img data-lazy-fallback="1" data-attachment-id="129816" data-permalink="https://blog.logrocket.com/swr-vs-tanstack-query-react/attachment/updating-cached-content-before-api-call/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/09/updating-cached-content-before-api-call.gif" data-orig-size="730,439" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="updating-cached-content-before-api-call" data-image-description="" data-image-caption="&lt;p&gt;Updating the cached content before the API call&lt;/p&gt;&#10;" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/09/updating-cached-content-before-api-call-300x180.gif" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/09/updating-cached-content-before-api-call.gif" decoding="async" loading="lazy" class="size-full wp-image-129816" src="../Images/9ef5a6f8c9e8fe7fffddf11e1c0164f0.png" alt="Updating the cached content before the API call" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/09/updating-cached-content-before-api-call.gif"/></noscript><figcaption id="caption-attachment-129816" class="wp-caption-text">Updating the cached content before the API call</figcaption></figure>
<p>最后，SWR提供了一些额外的功能，如重新验证焦点和检查网络选项卡，以查看网络呼叫:</p>
<figure id="attachment_129819" aria-describedby="caption-attachment-129819" class="wp-caption aligncenter"><img data-attachment-id="129819" data-permalink="https://blog.logrocket.com/swr-vs-tanstack-query-react/attachment/testing-revalidation-on-focus-feature/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/09/testing-revalidation-on-focus-feature.gif" data-orig-size="730,439" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="testing-revalidation-on-focus-feature" data-image-description="" data-image-caption="&lt;p&gt;Testing the revalidation-on-focus feature&lt;/p&gt;&#10;" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/09/testing-revalidation-on-focus-feature-300x180.gif" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/09/testing-revalidation-on-focus-feature.gif" decoding="async" class="size-full wp-image-129819 jetpack-lazy-image" src="../Images/521cee753caa125a0dca9ddded595439.png" alt="Testing the revalidation-on-focus feature" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2022/09/testing-revalidation-on-focus-feature.gif?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/09/testing-revalidation-on-focus-feature.gif"/><noscript><img data-lazy-fallback="1" data-attachment-id="129819" data-permalink="https://blog.logrocket.com/swr-vs-tanstack-query-react/attachment/testing-revalidation-on-focus-feature/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/09/testing-revalidation-on-focus-feature.gif" data-orig-size="730,439" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="testing-revalidation-on-focus-feature" data-image-description="" data-image-caption="&lt;p&gt;Testing the revalidation-on-focus feature&lt;/p&gt;&#10;" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/09/testing-revalidation-on-focus-feature-300x180.gif" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/09/testing-revalidation-on-focus-feature.gif" decoding="async" loading="lazy" class="size-full wp-image-129819" src="../Images/521cee753caa125a0dca9ddded595439.png" alt="Testing the revalidation-on-focus feature" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/09/testing-revalidation-on-focus-feature.gif"/></noscript><figcaption id="caption-attachment-129819" class="wp-caption-text">Testing the revalidation-on-focus feature</figcaption></figure>
<h2 id="tanstack-query">什么是TanStack查询？</h2>
<p>TanStack Query是另一个开源的、全功能的、支持TypeScript的库，它为React应用程序中的数据获取和缓存提供了一个API。它在一个<a href="https://github.com/TanStack/query/tree/main/packages/query-core" target="_blank" rel="noopener">单独的内部包</a>中实现了库的不可知核心逻辑，并专门为React提供了<a href="https://github.com/TanStack/query/tree/main/packages/react-query" target="_blank" rel="noopener"> React查询</a>适配器包。</p>
<p>React的TanStack Query提供了钩子、类和一个官方的、专用的基于GUI的开发工具，用于在React应用程序中同步客户端状态和服务器状态。类似地，开发团队计划为其他前端库提供官方适配器包，例如，TanStack Vue Query、Svelte Query等。</p>
<p>TanStack Query于2014年通过其v0.0.6公开发行版首次发布，比React的首次发布晚了大约一年。</p>
<h3>突出显示的功能</h3>
<p>该库提供了以下突出的功能:</p>
<table>
<thead>
<tr>
<th>特征</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>包含电池的框架式体验</td>
<td>TanStack Query为React开发人员提供了一种类似框架的体验，它有一个专用的开发人员工具、用于每个特定任务的专用挂钩、用于更好地组织代码的OOP类以及基于JavaScript-props的事件处理程序。</td>
</tr>
<tr>
<td>详细、可配置和可重用的API</td>
<td>TanStack Query致力于提供一个详细的、可配置的、全功能的API，用于在React应用程序中获取和缓存远程数据。为了更好地组织代码，它提供了来自API核心的多个钩子和类。</td>
</tr>
<tr>
<td>面向开发人员和用户的内置功能</td>
<td>TanStack Query supports paginated requests and provides the <code>useInfiniteQuery</code> Hook to implement infinite loading.
<p>它还为开发人员提供了React悬念API、SSG和SSR支持——预取、焦点重新验证和网络状态重新获取，如应用程序用户的可用性增强。</p></td>
</tr>
</tbody>
</table>
<h2 id="using-tanstack-query">使用临时查询</h2>
<p>现在，我们已经回顾了TanStack Query为React中的优化数据获取提供的功能，让我们创建一个示例应用程序并对其进行评估，以找出与React SWR的比较点。</p>
<p>如果您已经是一个TanStack Query用户，或者您以前尝试过TanStack Query，那么您可以在<a href="https://github.com/codezri/react-query-example" target="_blank" rel="noopener">这个GitHub库</a>中查看完整的项目，并跳到比较部分。</p>
<p>首先，配置模拟API服务器，并像我们在React SWR小节中所做的那样启动它。现在，创建另一个React项目，用TanStack Query实现前面的简单产品管理应用程序:</p>
<pre class="language-bash hljs">npx create-react-app tanstack-query-example
cd tanstack-query-example
</pre>
<h3 id="installing-tanstack-query-package">安装软件包</h3>
<p>使用以下命令安装<code>@tanstack/react-query</code>包:</p>
<pre class="language-bash hljs">npm install @tanstack/react-query
# --- or ---
yarn add @tanstack/react-query
</pre>
<p>安装Axios包，并按照我们在SWR部分所做的相同步骤定义基本URL。准备用TanStack Query重写之前的app吧！</p>
<p>清除<code>App.js</code>文件中的所有内容，并添加以下导入:</p>
<pre class="language-javascript hljs">import React, { useState } from 'react';
import {
  QueryClient,
  QueryClientProvider,
  useQuery,
  useQueryClient,
  useMutation } from '@tanstack/react-query';
import axios from 'axios';

import './App.css';
</pre>
<p>这里，<code>useQuery</code>和<code>useMutation</code>钩子帮助获取和更新数据(缓存的数据)。我们可以使用<code>QueryClient</code>类创建一个类似代理的实例来访问或操作缓存的数据。<code>useQueryClient</code>钩子返回所有应用程序组件中当前的<code>QueryClient</code>引用。</p>
<p><code>QueryClientProvider</code>组件支持访问整个React应用程序的缓存数据，类似于<a href="https://blog.logrocket.com/react-context-api-deep-dive-examples/" target="_blank" rel="noopener"> React上下文API </a>中内置的<code>Context.Provider</code>组件。</p>
<h3 id="implementing-data-fetchers-custom-hooks-tanstack-query">实现数据提取器和自定义挂钩</h3>
<p>与SWR类似，现在我们可以为Axios创建一个包装器，一个将产品插入数据库的函数，以及一个获取缓存产品的自定义挂钩，如下所示:</p>
<pre class="language-javascript hljs">function fetcher(url) {
  return axios.get(url).then(res =&gt; res.data);
}

async function addProduct(product) {
  let response = await axios.post('/products', product);
  return response.data;
}

function useProducts() {
  const { data, isLoading, error } = useQuery(['products'], () =&gt; fetcher('/products'));
  return {
    products: data,
    isLoading,
    isError: !!error
  };
}
</pre>
<p>与SWR不同，在这里，我们有方便的<code>isLoading</code>道具用于条件渲染，但在版本4中，我们需要向<code>useQuery</code>钩子发送基于数组的唯一键和URL段，因为钩子用上下文对象调用fetcher函数——它不像SWR那样直接传递唯一键字符串。</p>
<h3 id="using-tanstack-query-data-fetching">使用TanStack查询获取数据</h3>
<p>我们可以使用来自SWR项目的相同的<code>Products</code>组件源，因为定制钩子几乎是相同的:</p>
<pre class="language-javascript hljs">function Products() {
  const { products, isLoading, isError } = useProducts();

  if(isError)
    return (
      &lt;div&gt;Unable to fetch products.&lt;/div&gt;
    );

  if(isLoading)
    return (
      &lt;div&gt;Loading products...&lt;/div&gt;
    );

  return (
    products.map((product) =&gt; (
      &lt;div key={product.id} className="product-item"&gt;
        &lt;div&gt;{product.name}&lt;/div&gt;
        &lt;div&gt;${product.price}&lt;/div&gt;
      &lt;/div&gt;
    ))
  );
}
</pre>
<p>我们可以在多个组件中使用<code>useProducts</code>钩子，而不用担心RESTful HTTP请求重复的问题，因为TanStack Query也像SWR一样对类似的请求进行重复删除。</p>
<h3 id="mutating-cached-data-invalidating-requests-tanstack-query">变更缓存数据和使请求无效</h3>
<p>创建一个名为<code>AddProduct</code>的组件，并使用以下代码实现一种添加新产品的方法:</p>
<pre class="language-javascript hljs">function AddProduct({ goToList }) {
  const { products } = useProducts();
  const queryClient = useQueryClient();
  const mutation = useMutation((product) =&gt; addProduct(product), {
    onMutate: async (product) =&gt; {
      await queryClient.cancelQueries(['products']);

      const previousValue = queryClient.getQueryData(['products']);
      queryClient.setQueryData(['products'], (old) =&gt; [...old, product]);
      return previousValue;
    },
    onError: (err, variables, previousValue) =&gt;
      queryClient.setQueryData(['products'], previousValue),
    onSettled: () =&gt; queryClient.invalidateQueries(['products'])
  });

  const [product, setProduct] = useState({
    id: products ? products.length + 1 : 0,
    name: '',
    price: null
  });
  const [disabled, setDisabled] = useState(true);

  async function handleAdd() {
    setTimeout(goToList);
    mutation.mutate(product);
  }

  function handleFieldUpdate(e) {
    const element = e.target;
    const value = element.type === 'number' ? parseInt(element.value) : element.value;
    const nextProduct = {...product, [element.name]: value};

    setProduct(nextProduct);
    setDisabled(!nextProduct.name || !nextProduct.price);
  }

  return(
    &lt;div className="product-form"&gt;
      &lt;input
        type="text"
        name="name"
        placeholder="Name"
        autoFocus
        onChange={handleFieldUpdate}/&gt;
      &lt;input
        type="number"
        name="price"
        min="1"
        placeholder="Price"
        onChange={handleFieldUpdate}/&gt;
      &lt;button onClick={handleAdd} disabled={disabled}&gt;Add&lt;/button&gt;
    &lt;/div&gt;
  );
}
</pre>
<p>TanStack Query提供了一个全功能的突变API，它提供了对整个突变生命周期的透明访问。如你所见，我们有<code>onMutate</code>、<code>onError</code>和<code>onSettled</code>回调来实现我们的变异策略。</p><div class="code-block code-block-54">
<hr/>
<h3>更多来自LogRocket的精彩文章:</h3>

<hr/></div>
<p>在本例中，我们用新产品对象直接更新缓存数据，然后让TanStack Query向<code>POST</code>端点发送请求，以在后台更新服务器状态。</p>
<p>SWR提供的变异策略是一个内置特性，支持有限的定制，但这不是一个障碍，因为SWR的固定变异策略解决了几乎所有开发人员的需求。然而，与SWR不同，TanStack Query允许您按照自己的意愿实现变异策略。</p>
<p>让我们为<code>App</code>组件创建一个新的查询客户机:</p>
<pre class="language-javascript hljs">const queryClient = new QueryClient();
</pre>
<p>查询客户端实例有助于访问每个应用程序组件中的缓存数据记录。</p>
<p>最后，将导出的<code>App</code>组件源添加到您的<code>App.js</code>文件中:</p>
<pre class="language-javascript hljs">function App() {
  const [ mode, setMode ] = useState('list');
  return (
    &lt;QueryClientProvider client={queryClient}&gt;
      &lt;div className="menu-bar"&gt;
        &lt;div onClick={() =&gt; { setMode('list') }}
            className={mode === 'list' ? 'selected' : ''}&gt;All products&lt;/div&gt;
        &lt;div onClick={() =&gt; { setMode('add') }}
            className={mode === 'add' ? 'selected' : ''}&gt;Add product&lt;/div&gt;
      &lt;/div&gt;
      &lt;div className="wrapper"&gt;
        { mode === 'list' ? &lt;Products/&gt; :
            &lt;AddProduct goToList={() =&gt; setMode('list')}/&gt; }
      &lt;/div&gt;
    &lt;/QueryClientProvider&gt;
  );
}

export default App;
</pre>
<p>我们现在需要通过提供查询客户端引用，用<code>QueryClientProvider</code>库组件包装我们的应用程序组件，以使<code>useQueryClient</code>在所有子组件中正常运行。</p>
<p>启动RESTful模拟服务器并运行应用程序——您将看到我们用SWR实现的相同应用程序。尝试打开两个标签页，添加新产品；正如我们所期望的，您将看到焦点上的重新验证特性在起作用。</p>
<p>现在，让我们根据上面的发现比较一下SWR和TanStack查询库。</p>
<h2 id="swr-vs-tanstack-query">SWR对坦斯塔克的质疑</h2>
<h3 id="basic-crud-features">基本CRUD特征</h3>
<p>之前，我们尝试了数据检索和操作(获取和变异)来测试两个缓存库中的CRUD支持。SWR和TanStack Query都提供了实现示例应用程序所需的特性。</p>
<p>SWR力求以最小的方式给出每一个特性，这可能会激励开发人员为数据缓存相关的活动编写更少的代码。但是一个最小的API设计有时会带来深度定制的限制。与SWR相比，TanStack Query以一种更加可定制的方式提供了基本的抓取和变异功能，而SWR则以一种比TanStack Query更简单的方式提供了类似的功能。</p>
<p>这两个库都是后端不可知的，具有基于promise的fetcher函数，因此您可以将SWR和TanStack Query与REST、GraphQL或任何其他您喜欢的通信机制一起使用:Axios、<a href="https://github.com/developit/unfetch" target="_blank" rel="noopener"> Unfetch </a>、<a href="https://github.com/prisma-labs/graphql-request" target="_blank" rel="noopener"> graphql-request </a>等。</p>
<p>总的来说，这两个库都应该满足开发人员对基本获取和变异支持的需求。</p>
<h3 id="popularity-developer-support">受欢迎程度和开发者支持</h3>
<p>开源库通常会变得流行，并在一些情况下获得GitHub stargazers:</p>
<ul>
<li>当更多的开发人员使用特定的库时</li>
<li>当该库提供比一般水平更好的开发人员支持时</li>
<li>当他们的仓库维护良好时</li>
</ul>
<p>这两个图书馆都有许多GitHub观星者。这两个库都有很棒的开发人员社区——开发人员通过回答这些库的GitHub库上的支持查询来互相帮助。React SWR没有提供用于调试的官方开发工具，但是一个社区成员创建了一个用于调试的GUI开发工具。</p>
<p>与SWR相比，TanStack Query维护了更详细、更有条理、更有支持性的官方文档。然而，这两个库都提供了优秀的示例项目/代码片段，以便开发人员快速理解它们的基本概念。</p>

<p>对于第三方库，专用的GUI调试工具不是强制性的。尽管如此，像缓存这样的主题确实很复杂，所以一个用于缓存库的开发工具确实可以节省开发时间。</p>
<p>TanStack Query附带了一个官方开发工具，但是swr的开发人员社区为SWR创建了一个非官方的但是使用良好的swr-devtools。</p>
<p>swr-devtools是最小的，只显示只读数据，但是它包含了调试所需的关键信息:</p>
<figure id="attachment_129824" aria-describedby="caption-attachment-129824" class="wp-caption aligncenter"><img data-attachment-id="129824" data-permalink="https://blog.logrocket.com/swr-vs-tanstack-query-react/attachment/swr-devtools-community-gui-displays-past-queries/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/09/swr-devtools-community-gui-displays-past-queries.png" data-orig-size="800,220" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="swr-devtools-community-gui-displays-past-queries" data-image-description="" data-image-caption="&lt;p&gt;The SWR DevTools community GUI displays past queries&lt;/p&gt;&#10;" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/09/swr-devtools-community-gui-displays-past-queries-300x83.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/09/swr-devtools-community-gui-displays-past-queries.png" decoding="async" class="size-full wp-image-129824 jetpack-lazy-image" src="../Images/ecffd491118255656168fc793f414c06.png" alt="The SWR DevTools community GUI displays past queries" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2022/09/swr-devtools-community-gui-displays-past-queries.png 800w, https://blog.logrocket.com/wp-content/uploads/2022/09/swr-devtools-community-gui-displays-past-queries-300x83.png 300w, https://blog.logrocket.com/wp-content/uploads/2022/09/swr-devtools-community-gui-displays-past-queries-768x211.png 768w" data-lazy-sizes="(max-width: 800px) 100vw, 800px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2022/09/swr-devtools-community-gui-displays-past-queries.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/09/swr-devtools-community-gui-displays-past-queries.png"/><noscript><img data-lazy-fallback="1" data-attachment-id="129824" data-permalink="https://blog.logrocket.com/swr-vs-tanstack-query-react/attachment/swr-devtools-community-gui-displays-past-queries/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/09/swr-devtools-community-gui-displays-past-queries.png" data-orig-size="800,220" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="swr-devtools-community-gui-displays-past-queries" data-image-description="" data-image-caption="&lt;p&gt;The SWR DevTools community GUI displays past queries&lt;/p&gt;&#10;" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/09/swr-devtools-community-gui-displays-past-queries-300x83.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/09/swr-devtools-community-gui-displays-past-queries.png" decoding="async" loading="lazy" class="size-full wp-image-129824" src="../Images/ecffd491118255656168fc793f414c06.png" alt="The SWR DevTools community GUI displays past queries" srcset="https://blog.logrocket.com/wp-content/uploads/2022/09/swr-devtools-community-gui-displays-past-queries.png 800w, https://blog.logrocket.com/wp-content/uploads/2022/09/swr-devtools-community-gui-displays-past-queries-300x83.png 300w, https://blog.logrocket.com/wp-content/uploads/2022/09/swr-devtools-community-gui-displays-past-queries-768x211.png 768w" sizes="(max-width: 800px) 100vw, 800px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/09/swr-devtools-community-gui-displays-past-queries.png"/></noscript><figcaption id="caption-attachment-129824" class="wp-caption-text">The SWR DevTools community GUI displays past queries</figcaption></figure>
<p>与只读的swr-devtools不同，TanStack查询开发工具向您显示缓存的数据，并允许您操作缓存的内容:</p>
<figure id="attachment_129826" aria-describedby="caption-attachment-129826" class="wp-caption aligncenter"><img data-attachment-id="129826" data-permalink="https://blog.logrocket.com/swr-vs-tanstack-query-react/attachment/tanstack-query-devtools-gui-displays-current-queries/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/09/tanstack-query-devtools-gui-displays-current-queries.png" data-orig-size="800,265" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="tanstack-query-devtools-gui-displays-current-queries" data-image-description="" data-image-caption="&lt;p&gt;The TanStack Query DevTools GUI displays current queries&lt;/p&gt;&#10;" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/09/tanstack-query-devtools-gui-displays-current-queries-300x99.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/09/tanstack-query-devtools-gui-displays-current-queries.png" decoding="async" class="size-full wp-image-129826 jetpack-lazy-image" src="../Images/c434567539ad7c245c731b761733f4c8.png" alt="The TanStack Query DevTools GUI displays current queries" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2022/09/tanstack-query-devtools-gui-displays-current-queries.png 800w, https://blog.logrocket.com/wp-content/uploads/2022/09/tanstack-query-devtools-gui-displays-current-queries-300x99.png 300w, https://blog.logrocket.com/wp-content/uploads/2022/09/tanstack-query-devtools-gui-displays-current-queries-768x254.png 768w" data-lazy-sizes="(max-width: 800px) 100vw, 800px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2022/09/tanstack-query-devtools-gui-displays-current-queries.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/09/tanstack-query-devtools-gui-displays-current-queries.png"/><noscript><img data-lazy-fallback="1" data-attachment-id="129826" data-permalink="https://blog.logrocket.com/swr-vs-tanstack-query-react/attachment/tanstack-query-devtools-gui-displays-current-queries/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/09/tanstack-query-devtools-gui-displays-current-queries.png" data-orig-size="800,265" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="tanstack-query-devtools-gui-displays-current-queries" data-image-description="" data-image-caption="&lt;p&gt;The TanStack Query DevTools GUI displays current queries&lt;/p&gt;&#10;" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/09/tanstack-query-devtools-gui-displays-current-queries-300x99.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/09/tanstack-query-devtools-gui-displays-current-queries.png" decoding="async" loading="lazy" class="size-full wp-image-129826" src="../Images/c434567539ad7c245c731b761733f4c8.png" alt="The TanStack Query DevTools GUI displays current queries" srcset="https://blog.logrocket.com/wp-content/uploads/2022/09/tanstack-query-devtools-gui-displays-current-queries.png 800w, https://blog.logrocket.com/wp-content/uploads/2022/09/tanstack-query-devtools-gui-displays-current-queries-300x99.png 300w, https://blog.logrocket.com/wp-content/uploads/2022/09/tanstack-query-devtools-gui-displays-current-queries-768x254.png 768w" sizes="(max-width: 800px) 100vw, 800px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/09/tanstack-query-devtools-gui-displays-current-queries.png"/></noscript><figcaption id="caption-attachment-129826" class="wp-caption-text">The TanStack Query DevTools GUI displays current queries</figcaption></figure>
<p>根据GitHub问题跟踪者的消息，swr-devtools项目正计划在开发者工具面板中增加对缓存操作的支持。</p>
<h3 id="inbuilt-usability-features">内置可用性功能</h3>
<p>使用像SWR或TanStack Query这样的库有三个主要原因:</p>
<ol>
<li>减少同步服务器状态和反应应用程序状态所需的代码量</li>
<li>通过数据缓存和重复数据删除查询等概念，优化使用远程资源</li>
<li>通过实时体验提高应用程序的可用性</li>
</ol>
<p>可用性改进是缓存和查询优化的一个重要原因，因此这两个库都提供了以下可用性特性:</p>
<ul>
<li>重新验证焦点</li>
<li>网络状态重新获取</li>
<li>数据预取</li>
<li>基于时间间隔的重新验证</li>
</ul>
<p>TanStack Query提供了以下附加可用性功能:</p>
<ul>
<li>滚动恢复，用于在用户再次返回组件时保存无限滚动位置</li>
<li>查询取消以停止长时间运行的查询</li>
<li>离线突变支持</li>
</ul>
<h3 id="bundle-size-performance-optimizations">捆绑包大小和性能优化</h3>
<p>并非所有用户都有超快的互联网连接或使用高端电脑。因此，保持健康的捆绑包大小和实现性能优化有助于所有用户顺利运行您的应用程序，无论他们的互联网速度和电脑规格如何。为web应用程序消耗用户计算机的最佳硬件资源是一个很好的实践。</p>
<p>React SWR是一个非常轻量级的库:<a href="https://bundlephobia.com/package/swr@1.3.0" target="_blank" rel="noopener">bundle hobia</a>测得它的gzipped大小只有4.2kB，由于其广泛的特性，TanStack查询有点重，所以它是<a href="https://bundlephobia.com/package/@tanstack/react-query@4.0.10" target="_blank" rel="noopener"> 11.4 kB gzipped </a>。确实是React核心库的四倍以上！</p>
<p>这两个库都在内部进行渲染优化、请求重复数据删除和缓存优化。请注意，缓存库不会提高HTTP请求处理速度——HTTP请求性能取决于各种因素，如HTTP客户端库性能、浏览器的JavaScript引擎实现、网络速度、当前CPU负载等。</p>
<h2 id="swr-vs-tanstack-query-summary">SWR vs. TanStack查询:汇总</h2>
<p>我们用一张表来总结一下以上的比较因素。查看下表，并对SWR和TanStack查询进行对比:</p>
<table>
<thead>
<tr>
<th>比较因素</th>
<th>反应SWR</th>
<th>转移查询</th>
</tr>
</thead>
<tbody>
<tr>
<td>总体API设计</td>
<td>为开发人员提供了一个最小的API，具有一些固定的特性</td>
<td>为开发人员提供了一个详细且有些复杂的API，具有完全可定制的特性</td>
</tr>
<tr>
<td>捆绑尺寸(gzipped)</td>
<td>4.2 KB</td>
<td>11.4 KB</td>
</tr>
<tr>
<td>知名度、社区支持和文档</td>
<td>良好的社区、维护良好的存储库，以及总体良好的演示文档</td>
<td>良好的社区、维护良好的存储库，以及包含许多实际示例和完整API参考的信息丰富的文档</td>
</tr>
<tr>
<td>基本数据获取和变异功能</td>
<td>满足开发人员的需求，但是开发人员必须为某些特性编写额外的代码，并且可能面临深度定制问题</td>
<td>通过深度定制支持满足开发人员的需求。试图将它与较小的项目集成的开发人员可能会发现这个API比它应该有的要复杂一些</td>
</tr>
<tr>
<td>性能优化</td>
<td>支持请求重复数据删除、渲染优化和优化缓存</td>
<td>支持请求重复数据删除、渲染优化和优化缓存</td>
</tr>
<tr>
<td>内置可用性功能</td>
<td>基于时间间隔的焦点重新验证、网络状态重新获取、数据预取和重新验证</td>
<td>焦点的重新验证、网络状态重新获取、数据预取、基于间隔的重新验证、请求取消、离线突变和滚动恢复</td>
</tr>
<tr>
<td>面向开发人员的内置功能</td>
<td>提供分页和无限加载功能。开发者社区用Chrome和Firefox扩展实现了一个开发者工具GUI。支持将缓存持久化到外部存储位置(即<code>localStorage</code>)。</td>
<td>提供分页和无限加载功能。它附带了一个支持缓存操作的官方开发工具GUI。支持将缓存持久化到外部存储位置(即<code>localStorage</code>)。</td>
</tr>
<tr>
<td>反应悬念</td>
<td>支持</td>
<td>支持</td>
</tr>
<tr>
<td>对其他前端库的官方支持</td>
<td>没有，类似的社区库可用:<a href="https://github.com/ConsoleTVs/sswr" target="_blank" rel="noopener"> sswr </a></td>
<td>正在进行中，类似的社区图书馆可用:<a href="https://github.com/DamianOsipiuk/vue-query" target="_blank" rel="noopener"> vue-query </a></td>
</tr>
</tbody>
</table>
<h2>结论</h2>
<p>在本文中，我们用SWR和TanStack查询库创建了一个示例React应用程序，然后根据开发人员的体验和可用特性对它们进行了比较。</p>
<p>正如我们在这里所概述的，这两个库都有更好的性能，并且各有利弊。React SWR的目标是提供一个最小的API，通过维护一个轻量级的库来解决React请求处理中的缓存问题。同时，TanStack Query致力于为同样的问题提供一个功能全面的解决方案。</p>
<p>有时，TanStack Query看起来像一个框架，从一个开发工具包中提供您需要的一切，就像Angular——另一方面，SWR看起来更像React，因为它只专注于解决一个问题。React引入了功能组件来降低基于类的组件的复杂性，因此喜欢这种简单性的开发人员可能更喜欢SWR而不是TanStack Query。</p>
<p>喜欢使用详细/健壮的API并寻求类似框架的一体化数据缓存解决方案的开发人员可能会选择TanStack Query而不是SWR。TanStack查询团队计划为Svelte、SolidJS、Vue.js和vanilla JavaScript应用程序提供官方支持，并为核心的TanStack查询库提供适配器库。然而，前端开发者社区已经根据其他前端框架的TanStack Query和React SWR API实现了几个开源缓存库。</p>
<p>我们的结论？尝试两个库。根据您的API偏好选择一个。TanStack Query有几个独特的特性和深度定制，在撰写本文时SWR还不支持。这两个库很可能会变得同样功能齐全和健壮，特别是如果SWR承诺在不久的将来实现一些缺失的功能。</p>
<p>然而，从最小API设计的角度来看，SWR已经很完整了，它提供了您所寻求的强制特性，而没有进一步增加包的大小，这正是TanStack Query所能做到的。</p><div class="code-block code-block-17">
<div class="blog-plug inline-plug react-plug" vwo-el-id="26283398190">
<h2 vwo-el-id="41600691720"><a href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener"> LogRocket </a>:全面了解您的生产React应用</h2><p>调试React应用程序可能很困难，尤其是当用户遇到难以重现的问题时。如果您对监视和跟踪Redux状态、自动显示JavaScript错误以及跟踪缓慢的网络请求和组件加载时间感兴趣，</p><a href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" vwo-el-id="19356441070">try LogRocket</a><p>. </p><a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="19356441380">
<img class="first-react-image alignnone size-full wp-image-46 jetpack-lazy-image jetpack-lazy-image--handled" src="../Images/f300c244a1a1cf916df8b4cb02bec6c6.png" vwo-el-id="18272717540" data-lazy-loaded="1" data-original-src="https://files.readme.io/27c94e7-Image_2017-06-05_at_9.46.04_PM.png"/>
</a>
<a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="19356441690">
<img class="second-react-image alignnone size-full wp-image-46 jetpack-lazy-image jetpack-lazy-image--handled" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" vwo-el-id="30720362350" data-lazy-loaded="1" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/>
</a>
<p vwo-el-id="28675660440" class="">LogRocket 结合了会话回放、产品分析和错误跟踪，使软件团队能够创建理想的web和移动产品体验。这对你来说意味着什么？</p>
<p>LogRocket不是猜测错误发生的原因，也不是要求用户提供截图和日志转储，而是让您回放问题，就像它们发生在您自己的浏览器中一样，以快速了解哪里出错了。</p>
<p>不再有嘈杂的警报。智能错误跟踪允许您对问题进行分类，然后从中学习。获得有影响的用户问题的通知，而不是误报。警报越少，有用的信号越多。</p>
<p vwo-el-id="28675660750">LogRocket Redux中间件包为您的用户会话增加了一层额外的可见性。LogRocket记录Redux存储中的所有操作和状态。</p>
<p vwo-el-id="28675661060">现代化您调试React应用的方式— <a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="40093418840">开始免费监控</a>。</p>
</div></div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
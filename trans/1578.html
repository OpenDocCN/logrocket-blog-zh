<html>
<head>
<title>RTK Query: The future of data fetching and caching for Redux - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>RTK 查询:Redux - LogRocket 博客数据获取和缓存的未来</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/rtk-query-future-data-fetching-caching-redux/#0001-01-01">https://blog.logrocket.com/rtk-query-future-data-fetching-caching-redux/#0001-01-01</a></blockquote><div><article class="article-post">
<p>RTK Query 是 Redux 团队的一个实验库，主要目的是为您的 web 应用程序获取和缓存数据。它在引擎盖下利用 Redux，构建在<a href="https://blog.logrocket.com/smarter-redux-with-redux-toolkit/"> Redux 工具</a> <a href="https://blog.logrocket.com/smarter-redux-with-redux-toolkit/"> k </a> <a href="https://blog.logrocket.com/smarter-redux-with-redux-toolkit/"> it (RTK) </a>之上。RTK Query 提供了高级设置选项，以最灵活有效的方式处理您的获取和缓存需求。</p>
<p>虽然 RTK Query 在幕后使用了 Redux，但这并不意味着您需要对 Redux 有很深的理解才能使用它。但是学习 Redux 和 RTK 对于利用 RTK Query 为您的 web 应用程序提供的状态管理功能大有帮助。</p>

<div class="podcast-container">
<div class="podcast-embed">
<h2>我们不只是写 Redux，我们也谈论它。现在听着:</h2>
<p>或者以后订阅</p>
<h3>为什么要使用 RTK 查询？</h3>

</div>
</div>
<h2>今天，RTK Query 仍然处于它的 alpha 阶段，这意味着它的架构和 API 会有很多突破性的变化。尽管如此，它已经为数据缓存和获取提供了一个简单有效的解决方案。</h2>
<p>构建 RTK Query 是为了解决使用 Redux 作为状态管理系统时获取数据的需要。RTK Query 可以作为中间件添加，并提供强大的 React 钩子来帮助获取数据。尽管它刚刚起步，但可以肯定地说，当 RTK Query 投入生产时，它将是在各种规模的 JavaScript 应用程序中获取数据的完美候选。</p>
<p>在典型的小型 React 应用程序(没有 Redux)中，您将能够使用集成的<code><a href="https://rtk-query-docs.netlify.app/api/ApiProvider#apiprovider">ApiProvider</a></code>获取数据。另一方面，在更大的 app 中(使用 Redux)，你仍然可以在你的商店中插入 RTK Query 作为中间件。</p>
<p>RTK Query 的不可知论使得它很容易与任何能够使用 Redux (Vue.js，Svelte，Angular 等)的框架集成。).请注意，虽然 RTK Query 是不可知论者杜撰的，但它也非常固执己见，遵循 Redux 的既定范式。此外，RTK 查询是用 TypeScript 构建的，因此提供了一流的类型支持。</p>
<p>使用 RTK 查询获取和缓存数据</p>
<h2>首先:您需要设置您的项目来使用 RTK Query。我们需要创建一个服务定义来获取我们的公共 API。对于这个例子，我们使用了一个<a href="http://www.dnd5eapi.co/">地下城&amp;龙族 API </a>:</h2>
<p>正如<a href="https://rtk-query-docs.netlify.app/introduction/getting-started#create-an-api-service">在文档</a>中提到的，RTK Query 更喜欢集中其数据获取配置，这在不同的数据获取库中是不太可能的——这是它固执己见的部分原因。集中我们的设置有它的优点和缺点。例如，将我们的获取挂钩放在一起并不是一个坏主意，但是如果使用大量的 API，这可能会变得很麻烦。</p>
<pre>import { createApi, fetchBaseQuery } from "@rtk-incubator/rtk-query";

// Create your service using a base URL and expected endpoints
export const dndApi = createApi({
  reducerPath: "dndApi",
  baseQuery: fetchBaseQuery({ baseUrl: "https://www.dnd5eapi.co/api/" }),
  endpoints: (builder) =&gt; ({
    getMonstersByName: builder.query({
      query: (name: string) =&gt; `monsters/${name}`
    })
  })
});

export const { useGetMonstersByNameQuery } = dndApi;
</pre>
<p>下一步是通过添加我们生成的 reducer 和 API 中间件将这个服务添加到我们的商店中。这将打开缓存、预取、轮询和其他 RTK 查询功能。</p>
<p>接下来，您需要包装提供者，就像处理基本 Redux 存储一样，然后您可以使用之前定义的查询钩子在组件中进行查询。</p>
<pre>export const store = configureStore({
  reducer: { [dndApi.reducerPath]: dndApi.reducer },
  middleware: (getDefaultMiddleware) =&gt; getDefaultMiddleware().concat(dndApi.middleware)
});
</pre>
<p>完整的应用程序代码可以在 CodeSandbox 中找到。</p>
<pre>import * as React from "react";
import { useGetMonstersByNameQuery } from "./services/dnd";
export default function App() {
// Using a query hook automatically fetches data and returns query values
const { data, error, isLoading } = useGetMonstersByNameQuery("aboleth");
return (
  &lt;div className="App"&gt;
    {error ? (²²²²²²²²²
    &lt;&gt;Oh no, there was an error&lt;/&gt;
  ) : isLoading ? (
    &lt;&gt;Loading...&lt;/&gt;
  ) : data ? (
    &lt;&gt;
    &lt;h3&gt;{data.name}&lt;/h3&gt;
    &lt;h4&gt; {data.speed.walk} &lt;/h4&gt;
    &lt;/&gt;
  ) : null}
  &lt;/div&gt;
);
}
</pre>
<p>变异数据</p>
<h3>有时您需要创建或更新数据。RTK Query 以一种标准的方式帮助您做到这一点。提供的<code>useMutation</code>钩子返回一个包含触发器函数的元组和一个包含触发器结果的对象。与<code>useQuery</code>相反，突变只在触发器被调用时执行。</h3>
<p>在一个更高级的设置中，您可能有一个用例，在这个用例中，您需要在执行变异后将本地缓存与服务器同步。这称为重新验证。RTK Query <a href="https://rtk-query-docs.netlify.app/concepts/mutations#advanced-mutations-with-revalidation">提供了两个场景</a>来处理这个用例，您可以根据您的项目需求决定使用哪一个:</p>
<p>使某个类型的所有内容无效</p>
<ul>
<li>选择性地使列表无效</li>
<li>在使用 RTK 查询变异时，您还将拥有实现乐观更新行为所需的所有工具:您可以使用变异的<code>onStart</code>阶段，在那里您可以通过<code>updateQueryResult</code>手动设置缓存的数据。如果出现错误，您可以使用<code>onError</code>和<code>patchQueryResult</code>回滚到之前的状态。</li>
</ul>
<p>缓存在哪里发挥作用？</p>
<h3><a href="https://rtk-query-docs.netlify.app/concepts/queries/#avoiding-unnecessary-requests">RTK 查询中自动</a>缓存。如果您的数据发生变化(即无效)，仅针对发生变化的元素，<a href="https://rtk-query-docs.netlify.app/concepts/mutations#advanced-mutations-with-revalidation">重新提取</a>会自动发生。这是通过 RTK Query 强大的<code>queryCachedKey</code>处理的。</h3>
<p>一旦发出请求，RTK Query 将序列化参数以提供唯一的<code>queryCachedKey</code>。然后在所有将来的请求中验证该密钥，以防止不必要的重新提取。如果你需要检查这个行为，你总是可以调用钩子提供的<code>refetch</code>函数。</p>
<p>缓存行为在文档中用一个 CodeSandbox 示例进行了简洁的说明<a href="https://rtk-query-docs.netlify.app/concepts/queries/#observing-caching-behavior">。这显示了自动获取和缓存特性如何帮助减少请求数量。</a></p>
<p>查询状态</p>
<h3>同样重要的是要注意提取查询返回的状态是多么痛苦。RTK Query 公开了请求状态，可以直接在我们的应用程序中使用，如下例所示:</h3>
<p>条件提取</p>
<pre>isUninitialized: false; // Query has not started yet.
isLoading: false; // Query is currently loading for the first time. No data yet.
isFetching: false; // Query is currently fetching, but might have data from an earlier request.
isSuccess: false; // Query has data from a successful load.
isError: false; // Query is currently in "error" state.
</pre>
<h3>如上所述，<code>useQuery</code>自动获取您的数据并处理缓存。RTK Query 提供了一种方法，可以使用布尔<code>skip</code>参数来阻止查询自动运行，该参数可以<a href="https://rtk-query-docs.netlify.app/concepts/conditional-fetching#conditional-fetching">ad</a>T6】ded 到查询挂钩，这将有助于管理这种行为。将<code>skip</code>设置为<code>false</code> <a href="https://rtk-query-docs.netlify.app/concepts/conditional-fetching#conditional-fetching">会强烈影响</a>获取和缓存数据的方式。</h3>
<p>错误处理</p>
<h3 id="h3errorhandling">错误通过钩子提供的<code>error</code>属性返回。RTK Query 希望您以特定的格式返回有效负载(错误或成功),以帮助进行类型推断。</h3>
<p>如果您需要编辑您当前的返回格式，您可以使用一个自定义的<code>baseQuery</code>，它将帮助您塑造您返回的数据。</p>
<pre>return { error: { status: 500, data: { message: 'error reasons' } }; 
</pre>
<p>为了帮助您优雅地处理错误，RTK Query 公开了一个<code><a href="https://rtk-query-docs.netlify.app/concepts/error-handling#retrying-on-error">retry</a></code>实用程序，您可以用它来包装您的<code>baseQuery</code>以创建一个指定尝试次数的指数回退(<code>maxRetries</code>)。</p>
<p>此外，RTK Query 还使您能够在宏观层次上<a href="https://rtk-query-docs.netlify.app/concepts/error-handling#handling-errors-at-a-macro-level">管理您的错误，这可以帮助您记录未完成的异步调用的错误。</a></p>
<p>投票</p>
<h3>您还可以通过使用您的<code>useQuery</code>钩子上暴露的<code>pollingInterval</code>来获得拥有实时服务器的感觉。该参数接受一个以毫秒为单位的数字，它将是您的数据刷新的时间间隔。此外，您还可以手动刷新您的数据。</h3>
<p>预取</p>
<h3>预取就是在实际需要之前获取数据，例如，如果您需要在实际请求之前获取分页数据的下一页。</h3>
<p>RTK Query 通过允许您发送两个参数来处理这个问题:<code>isOlderThan</code>和<code>force</code>。<code>isOlderThan</code>将基于布尔值或时间戳运行查询，而<code>force</code>将忽略<code>isOlderThan</code>参数并运行查询，即使它存在于缓存中。</p>
<p>编码发生器</p>
<h3>由于它是集中式的，并且 RTK Query 与钩子一起工作，所以在服务文件中编写完整的 API 端点可能会很快变得很麻烦。为了解决这个问题，RTK Query 提供了一个与 OpenAPI 模式一起工作的<a href="https://github.com/rtk-incubator/rtk-query-codegen"> CodeGen </a>。</h3>
<p>可定制性</p>
<h2>对于每个 API 客户端库来说，完全可定制是至关重要的；Axios 就是一个很好的例子。这使得开发人员能够处理默认行为、拦截器和身份验证，而无需重复代码。</h2>
<p><code>createApi</code>是配置 RTK 查询的主要点。它公开了如下参数:</p>
<p><code>baseQuery</code>，它可以被定制来创建拦截器或模具返回格式</p>
<ul>
<li><code>endpoints</code>，这是您对服务器执行的一组操作</li>
<li>这是一个帮助以全局或粒度方式管理重取的实用程序</li>
<li>M  <a href="https://rtk-query-docs.netlify.app/api/createapi/">更多的</a>来处理你的 API 调用和 Redux 存储</li>
<li>与 react-query 比较</li>
</ul>
<h2>RTK 查询在使用钩子的方式上类似 react-query。然而，这两个库的方法略有不同。</h2>
<p>RTK Query 侧重于利用 Redux 的能力来提供一种更有效的声明性方法来获取数据。它还旨在本质上是不可知论的，紧密依赖于 Redux Toolkit。</p>
<p>它们的缓存策略也大不相同:RTK Query 在数据失效中是声明性的，它的缓存键是通过端点和参数创建的，而 react-query 使用手动缓存键进行失效，并通过用户定义的查询键进行缓存。</p>
<p>RTK Query 提供了更广泛的比较<a href="https://rtk-query-docs.netlify.app/introduction/comparison/#comparison">这里</a>。</p>
<p>结论</p>
<h2>当 RTK Query 进入生产阶段时，对于使用 Redux 进行状态管理的团队来说，它肯定会是一个很好的补充。早期迹象显示了巨大的希望——它已经提供了一个简单高效的解决方案。</h2>
<p>使用<a class="signup" href="https://lp.logrocket.com/blg/signup" target="_blank" rel="noopener noreferrer"> LogRocket </a>消除传统错误报告的干扰</p><div class="code-block code-block-1">
<div class="blog-plug base-cta"><h2><a href="https://lp.logrocket.com/blg/signup" target="_blank" rel="noopener noreferrer"> LogRocket </a>是一个数字体验分析解决方案，它可以保护您免受数百个假阳性错误警报的影响，只针对几个真正重要的项目。LogRocket 会告诉您应用程序中实际影响用户的最具影响力的 bug 和 UX 问题。</h2>
<a href="https://lp.logrocket.com/blg/signup" class="signup" target="_blank" rel="noopener noreferrer"><img class="alignnone size-full wp-image-46 jetpack-lazy-image" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/><noscript><img data-lazy-fallback="1" class="alignnone size-full wp-image-46" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/></noscript></a>
<p>然后，使用具有深层技术遥测的会话重放来确切地查看用户看到了什么以及是什么导致了问题，就像你在他们身后看一样。</p>
<p>LogRocket 自动聚合客户端错误、JS 异常、前端性能指标和用户交互。然后 LogRocket 使用机器学习来告诉你哪些问题正在影响大多数用户，并提供你需要修复它的上下文。</p>
<p>关注重要的 bug—<a class="signup" href="https://lp.logrocket.com/blg/signup-issue-free" target="_blank" rel="noopener noreferrer">今天就试试 LogRocket】。</a></p>
<p>Focus on the bugs that matter — <a class="signup" href="https://lp.logrocket.com/blg/signup-issue-free" target="_blank" rel="noopener noreferrer">try LogRocket today</a>.</p></div></div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
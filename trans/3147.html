<html>
<head>
<title>Create a table of contents with highlighting in React - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>在 React - LogRocket 博客中创建一个突出显示的目录</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/create-table-contents-highlighting-react/#0001-01-01">https://blog.logrocket.com/create-table-contents-highlighting-react/#0001-01-01</a></blockquote><div><article class="article-post">
<p>目录为站点查看者提供了页面内容的摘要，允许他们通过单击所需的标题快速导航到页面的各个部分。通常，目录是在文档和博客中实现的。</p>
<p>在本教程中，我们将学习如何创建一个粘滞的目录，它将动态地列出页面上可用的标题，突出显示活动的标题。当我们浏览文章时，当标题出现在屏幕上时，它会在目录中高亮显示，如下图所示:</p>
<p> </p>
<p><img data-attachment-id="123906" data-permalink="https://blog.logrocket.com/create-table-contents-highlighting-react/attachment/highlight-toc-demo/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/07/highlight-toc-demo.gif" data-orig-size="730,402" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="highlight-toc-demo" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/07/highlight-toc-demo-300x165.gif" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/07/highlight-toc-demo.gif" decoding="async" class="aligncenter wp-image-123906 size-full jetpack-lazy-image" src="../Images/4a3b471f4a7b5b405e24feea8096ae4f.png" alt="Highlight TOC Demo" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2022/07/highlight-toc-demo.gif?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/07/highlight-toc-demo.gif"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="123906" data-permalink="https://blog.logrocket.com/create-table-contents-highlighting-react/attachment/highlight-toc-demo/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/07/highlight-toc-demo.gif" data-orig-size="730,402" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="highlight-toc-demo" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/07/highlight-toc-demo-300x165.gif" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/07/highlight-toc-demo.gif" decoding="async" loading="lazy" class="aligncenter wp-image-123906 size-full" src="../Images/4a3b471f4a7b5b405e24feea8096ae4f.png" alt="Highlight TOC Demo" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/07/highlight-toc-demo.gif"/></noscript>
<p> </p>
<p>要学习本教程，您应该熟悉 React 和 React 钩子。您还应该在系统上安装 Node.js。本教程的完整代码可在 GitHub 上获得。我们开始吧！</p>

<h2 id="setting-up-react">设置 React</h2>
<p>对于本教程，我创建了一个 starter repo，其中包含了我们将用来创建目录的代码。首先，我们需要克隆回购协议。为此，请在终端中运行以下命令:</p>
<pre class="“language-bash hljs">$ git clone -b starter https://github.com/Tammibriggs/table-of-content.git

$ cd table-of-content

$ npm install
</pre>
<p>当我们用<code>$ npm start</code>命令启动应用程序时，我们应该看到以下页面:</p>
<p><img data-attachment-id="123890" data-permalink="https://blog.logrocket.com/create-table-contents-highlighting-react/attachment/react-starter-repo-text-display/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/07/react-starter-repo-text-display.png" data-orig-size="730,416" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="react-starter-repo-text-display" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/07/react-starter-repo-text-display-300x171.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/07/react-starter-repo-text-display.png" decoding="async" class="aligncenter wp-image-123890 size-full jetpack-lazy-image" src="../Images/aa6a573fc1a954018ba3ef644cbdd873.png" alt="React Starter Repo Text Display" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2022/07/react-starter-repo-text-display.png 730w, https://blog.logrocket.com/wp-content/uploads/2022/07/react-starter-repo-text-display-300x171.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2022/07/react-starter-repo-text-display.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/07/react-starter-repo-text-display.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="123890" data-permalink="https://blog.logrocket.com/create-table-contents-highlighting-react/attachment/react-starter-repo-text-display/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/07/react-starter-repo-text-display.png" data-orig-size="730,416" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="react-starter-repo-text-display" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/07/react-starter-repo-text-display-300x171.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/07/react-starter-repo-text-display.png" decoding="async" loading="lazy" class="aligncenter wp-image-123890 size-full" src="../Images/aa6a573fc1a954018ba3ef644cbdd873.png" alt="React Starter Repo Text Display" srcset="https://blog.logrocket.com/wp-content/uploads/2022/07/react-starter-repo-text-display.png 730w, https://blog.logrocket.com/wp-content/uploads/2022/07/react-starter-repo-text-display-300x171.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/07/react-starter-repo-text-display.png"/></noscript>
<h2 id="create-toc-component">创建一个目录组件</h2>
<p>让我们从创建 TOC 组件开始，它将是粘性的，位于屏幕的右侧。</p>
<p>在我们之前克隆的应用程序中，在<code>src</code>目录下创建一个<code>TableOfContent.js</code>文件和一个<code>tableOfContent.css</code>文件。将以下代码行添加到<code>TableOfContent.js</code>文件中:</p>
<pre class="language-javascript hljs">// src/TableOfContent.js
import './tableOfContent.css'

function TableOfContent() {
  return (
    &lt;nav&gt;
      &lt;ul&gt;
        &lt;li&gt;
          &lt;a href='#'&gt;A heading&lt;/a&gt;
        &lt;/li&gt;
      &lt;/ul&gt;
    &lt;/nav&gt;
  )
}
export default TableOfContent
</pre>
<p>在上面的代码中，注意我们将文本放在锚标记<code>&lt;a&gt;&lt;/a&gt;</code>中。在我们的目录中，我们将添加一些功能，这样当我们点击一个标题时，它将把我们带到页面上相应的部分。</p>
<p>通过在<code>href</code>属性中传递我们想要导航到的部分的 ID，我们可以很容易地用锚标记做到这一点。因此，我们页面上的所有部分都必须包含一个 ID，我已经将它包含在了<code>Content.js</code>文件中。</p>
<p>接下来，在<code>tableOfContent.css</code>文件中添加以下代码行:</p>
<pre class="language-css hljs">// src/tableOfContent.css
nav {
  width: 220px;
  min-width: 220px;
  padding: 16px;
  align-self: flex-start;
  position: -webkit-sticky;
  position: sticky;
  top: 48px;
  max-height: calc(100vh - 70px);
  overflow: auto;
  margin-top: 150px;
}

nav ul li {
  margin-bottom: 15px;
}
</pre>
<p>现在，为了显示这个组件，转到<code>App.js</code>文件并添加以下导入:</p>
<pre class="language-javascript hljs">import TableOfContent from './TableOfContent';
</pre>
<p>接下来，修改<code>App</code>组件，如下所示:</p>
<pre class="language-javascript hljs">// src/App.js
function App() {
  return (
    &lt;div className="wrapper"&gt;
      &lt;Content /&gt;
      &lt;TableOfContent /&gt;
    &lt;/div&gt;
  );
}
</pre>
<p>通过上面的代码，我们将在应用程序的右侧看到一个粘性组件。</p>
<h2 id="find-headings-on-page">找到页面上的标题</h2>
<p>为了找到页面上的所有标题，我们可以使用<code>querySelectorAll</code> document 方法，该方法返回一个<code><a href="https://developer.mozilla.org/en-US/docs/Web/API/NodeList">NodeList</a></code>，表示与指定的选择器组匹配的元素列表。</p>
<p>下面的例子显示了我们将如何使用<code>querySelectorAll</code>方法:</p>
<pre class="language-javascript hljs">const headings = document.querySelectorAll(h2, h3, h4)
</pre>
<p>我们已经指定了<code>h2</code>、<code>h3</code>和<code>h4</code>作为选择器，它们是一篇文章中可能使用的标题。我们没有包括<code>h1</code>,因为它主要用于页面的标题，我们希望我们的 TOC 只包含页面的子部分。</p>
<p>现在要找到标题，在<code>TableOfContent.js</code>文件中添加以下导入:</p>
<pre class="language-javascript hljs">import { useEffect, useState } from 'react';
</pre>
<p>接下来，在组件中，在 return 语句前添加以下代码行:</p>
<pre class="language-javascript hljs">// src/TableOfContent.js
const [headings, setHeadings] = useState([])

useEffect(() =&gt; {
  const elements = Array.from(document.querySelectorAll("h2, h3, h4"))
    .map((elem) =&gt; ({
      text: elem.innerText,
    }))
  setHeadings(elements)
}, [])
</pre>
<p>上面的代码将找到页面上所有指定的标题元素，然后将文本内容存储在状态中。</p>
<p>在上面的代码中，我们使用<code><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/from">Array.from</a></code>方法从<code>querySelectorAll</code>返回的<code>NodeList</code>中创建一个数组。我们这样做是因为有些功能，比如我们上面使用的<code>map</code>，在<code>NodeList</code>上没有实现。为了方便地处理找到的标题元素，我们将它们转换为一个数组。</p>
<p>现在，要显示 TOC 中的标题，请修改组件的 return 语句，使其看起来像下面的代码:</p>
<pre class="language-javascript hljs">// src/TableOfContent.js
return (
  &lt;nav&gt;
    &lt;ul&gt;
      {headings.map(heading =&gt; (
        &lt;li key={heading.text}&gt;
          &lt;a href='#'&gt;{heading.text}&lt;/a&gt;
        &amp;lt;/li&gt;
      ))}
    &lt;/ul&gt;
  &lt;/nav&gt;
)
</pre>
<p>现在，当我们在浏览器中打开应用程序时，我们会看到以下内容:</p>
<p><img data-attachment-id="123895" data-permalink="https://blog.logrocket.com/create-table-contents-highlighting-react/attachment/display-headings-toc/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/07/display-headings-TOC.png" data-orig-size="730,270" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="display-headings-TOC" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/07/display-headings-TOC-300x111.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/07/display-headings-TOC.png" decoding="async" class="aligncenter wp-image-123895 size-full jetpack-lazy-image" src="../Images/265f8613a3023b9bbf0ed08a72bb54d7.png" alt="Display Headings TOC" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2022/07/display-headings-TOC.png 730w, https://blog.logrocket.com/wp-content/uploads/2022/07/display-headings-TOC-300x111.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2022/07/display-headings-TOC.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/07/display-headings-TOC.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="123895" data-permalink="https://blog.logrocket.com/create-table-contents-highlighting-react/attachment/display-headings-toc/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/07/display-headings-TOC.png" data-orig-size="730,270" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="display-headings-TOC" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/07/display-headings-TOC-300x111.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/07/display-headings-TOC.png" decoding="async" loading="lazy" class="aligncenter wp-image-123895 size-full" src="../Images/265f8613a3023b9bbf0ed08a72bb54d7.png" alt="Display Headings TOC" srcset="https://blog.logrocket.com/wp-content/uploads/2022/07/display-headings-TOC.png 730w, https://blog.logrocket.com/wp-content/uploads/2022/07/display-headings-TOC-300x111.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/07/display-headings-TOC.png"/></noscript>
<h2 id="link-listing-heading-hierarchy">层次结构中的链接和列表标题</h2>
<p>现在，当我们点击目录中的标题时，它不会把我们带到正确的部分。你会注意到它们都在同一行，没有标明哪个是主标题或者副标题。让我们解决这个问题。</p>
<p>在<code>TableOfContent</code>组件中，将<code>useEffect</code>挂钩修改成如下代码所示:</p>
<pre class="language-javascript hljs">// src/TableOfContent.js
useEffect(() =&gt; {
  const elements = Array.from(document.querySelectorAll("h2, h3, h4"))
    .map((elem) =&gt; ({
      id: elem.id,
      text: elem.innerText,
      level: Number(elem.nodeName.charAt(1))
    }))
  setHeadings(elements)
}, [])
</pre>
<p>除了我们找到的标题文本，我们还向 state 添加了一个 ID 和一个<code>level</code>属性。我们将把 ID 传递给 TOC 文本的锚标记，这样当我们点击它时，我们将被带到页面的相应部分。然后，我们将使用<code>level</code>属性在 TOC 中创建一个层次结构。</p>
<p>修改<code>TableOfContent</code>组件的 return 语句中的<code>ul</code>元素，如下所示:</p>
<pre class="language-javascript hljs">// src/TableOfContent.js
&lt;ul&gt;
  {headings.map(heading =&gt; (
    &lt;li
      key={heading.id}
      className={getClassName(heading.level)}
      &gt;
      &lt;a
        href={`#${heading.id}`}
        onClick={(e) =&gt; {
          e.preventDefault()
          document.querySelector(`#${heading.id}`).scrollIntoView({
            behavior: "smooth"
          })}}
        &gt;
        {heading.text}
      &lt;/a&gt;
    &lt;/li&gt;
  ))}
&lt;/ul&gt;
</pre>
<p>在上面的代码中，除了将 ID 添加到锚标签<code>&lt;a&gt;&lt;/a&gt;</code>的<code>href</code>属性中，我们还添加了一个<code>onClick</code>事件，当该事件被触发时，将调用<code>scrollIntoView</code>使浏览器平滑地滚动到相应的部分。</p>
<p>在<code>li</code>元素中，我们在<code>className</code>属性中调用<code>getClassName(heading.level)</code>。我们将使用这个我们很快就会创建的特性，根据<code>level</code>属性的值设置不同的类名。因此，我们可以给目录中的副标题不同于主标题的样式。</p>
<p>接下来，为了创建<code>getClassName</code>函数，在<code>TableOfContent</code>组件之外添加以下代码:</p>
<pre class="language-javascript hljs">// src/TableOfContent.js
const getClassName = (level) =&gt; {
  switch (level) {
    case 2:
      return 'head2'
    case 3:
      return 'head3'
    case 4:
      return 'head4'
    default:
      return null
  }
}
</pre>
<p>现在，在 in <code>tableOfContent.css</code>文件中添加以下代码行:</p>
<pre class="language-css hljs">// src/tableOfContent.css
.head3{
  margin-left: 10px;
  list-style-type: circle;
}
.head4{
  margin-left: 20px;
  list-style-type: square;
}
</pre>
<p>使用上面的代码，当我们点击目录中的标题或副标题时，我们将被带到相应的部分。现在，我们的目录中有一个标题层次结构:</p>
<p><img data-attachment-id="123898" data-permalink="https://blog.logrocket.com/create-table-contents-highlighting-react/attachment/text-hierarchy-toc/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/07/text-hierarchy-toc.png" data-orig-size="730,233" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="text-hierarchy-toc" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/07/text-hierarchy-toc-300x96.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/07/text-hierarchy-toc.png" decoding="async" class="aligncenter wp-image-123898 size-full jetpack-lazy-image" src="../Images/cb3d16ac45d53b7bd7d8419315588ab2.png" alt="Text Hierarchy TOC" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2022/07/text-hierarchy-toc.png 730w, https://blog.logrocket.com/wp-content/uploads/2022/07/text-hierarchy-toc-300x96.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2022/07/text-hierarchy-toc.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/07/text-hierarchy-toc.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="123898" data-permalink="https://blog.logrocket.com/create-table-contents-highlighting-react/attachment/text-hierarchy-toc/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/07/text-hierarchy-toc.png" data-orig-size="730,233" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="text-hierarchy-toc" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/07/text-hierarchy-toc-300x96.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/07/text-hierarchy-toc.png" decoding="async" loading="lazy" class="aligncenter wp-image-123898 size-full" src="../Images/cb3d16ac45d53b7bd7d8419315588ab2.png" alt="Text Hierarchy TOC" srcset="https://blog.logrocket.com/wp-content/uploads/2022/07/text-hierarchy-toc.png 730w, https://blog.logrocket.com/wp-content/uploads/2022/07/text-hierarchy-toc-300x96.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/07/text-hierarchy-toc.png"/></noscript>
<h2 id="find-highlight-currently-active-heading">查找并突出显示当前活动的标题</h2>
<p>当标题在我们的页面上可见时，我们希望在目录中突出显示相应的文本。</p>
<p>为了检测标题的可见性，我们将使用<a href="https://developer.mozilla.org/en-US/docs/Web/API/Intersection_Observer_API">交叉点观察器 API </a>，它提供了一种监视目标元素的方法，当元素到达预定义的位置时执行一个函数。</p>
<h3 id="observing-active-headings-intersection-observer-api">使用交叉点观察器 API 观察活动标题</h3>
<p>使用交叉点观察器 API，我们将创建一个自定义挂钩，它将返回活动标题的 ID。然后，我们将使用返回的 ID 来突出显示 TOC 中相应的文本。</p>
<p>为此，在<code>src</code>目录中，创建一个<code>hook.js</code>文件，并添加以下代码行:</p>
<pre class="language-javascript hljs">// src/hooks.js
import { useEffect, useState, useRef } from 'react';

export function useHeadsObserver() {
  const observer = useRef()
  const [activeId, setActiveId] = useState('')

  useEffect(() =&gt; {
    const handleObsever = (entries) =&gt; {}

    observer.current = new IntersectionObserver(handleObsever, {
      rootMargin: "-20% 0% -35% 0px"}
    )

    return () =&gt; observer.current?.disconnect()
  }, [])

  return {activeId}
}
</pre>
<p>在上面的代码中，我们创建了一个交叉点观察器的新实例。我们传递了一个<code>handleObsever</code>回调和一个<code>options</code>对象，其中我们指定了观察者回调的执行环境。</p>
<p>在使用<code>rootMargin</code>属性的<code>object</code>中，我们将根元素的顶部缩小了 20 %,这是我们当前的整个页面，底部缩小了 35%。因此，当页眉位于页面的顶部 20%和底部 35%时，它不会被视为可见。</p><div class="code-block code-block-54">
<hr/>
<h3>更多来自 LogRocket 的精彩文章:</h3>

<hr/></div>
<p>让我们通过将标题传递给交叉点观察器的<code>observe</code>方法来指定我们想要观察的标题。我们还将修改<code>handleObsever</code>回调函数来设置 state 中相交标题的 ID。</p>
<p>为此，修改<code>useEffect</code>钩子，使其看起来像下面的代码:</p>
<pre class="language-javascript hljs">// src/hooks.js
useEffect(() =&gt; {
  const handleObsever = (entries) =&gt; {
    entries.forEach((entry) =&gt; {
      if (entry?.isIntersecting) {
        setActiveId(entry.target.id)
      }
    })
  }

  observer.current = new IntersectionObserver(handleObsever, {
    rootMargin: "-20% 0% -35% 0px"}
  )

  const elements = document.querySelectorAll("h2, h3", "h4")
  elements.forEach((elem) =&gt; observer.current.observe(elem))
  return () =&gt; observer.current?.disconnect()
}, [])
</pre>
<p>在<code>TableOfContent.js</code>文件中，用以下代码导入创建的钩子:</p>
<pre class="language-javascript hljs">// src/TableOfContent.js
import { useHeadsObserver } from './hooks'
</pre>
<p>现在，在<code>TableOfContent</code>组件中的<code>headings</code>状态之后调用钩子:</p>
<pre class="language-javascript hljs">// src/TableOfContent.js
const {activeId} = useHeadsObserver()
</pre>
<p>有了上面的代码，当一个 heading 元素相交时，就可以用<code>activeId</code>了。</p>
<h3 id="highlighting-active-heading">突出显示活动标题</h3>
<p>为了突出显示 TOC 中的活动标题，通过添加以下样式属性来修改<code>TableOfContent</code>组件的返回语句中的<code>li</code>元素的锚标记<code>&lt;a&gt;&lt;/a&gt;</code>:</p>
<pre class="language-css hljs">style={{
  fontWeight: activeId === heading.id ? "bold" : "normal" 
}}
</pre>
<p>现在，我们的锚标记将如下所示:</p>
<pre class="language-javascript hljs">// src/TableOfContent.js
&lt;a
  href={`#${heading.id}`} 
  onClick={(e) =&gt; {
    e.preventDefault()
    document.querySelector(`#${heading.id}`).scrollIntoView({
      behavior: "smooth"
    })}}
    style={{
      fontWeight: activeId === heading.id ? "bold" : "normal" 
    }}
  &gt;
  {heading.text}
&lt;/a&gt;
</pre>
<p>现在，当一个标题被激活时，它会变成粗体。这样，我们就完成了标题高亮的目录创建。</p>
<h3 id="drawbacks">突出显示目录项目的缺点</h3>
<p>在 TOC 中添加项目突出显示时，需要注意一些事项。首先，没有标准的方法将这个特性添加到 TOC 中。因此，在不同的网站上，实现是不同的，这意味着我们网站的用户必须了解我们的 TOC 是如何工作的。</p>
<p>此外，由于每个目录的每个标题之间的间距根据其下的文本而有所不同，因此我们对突出显示功能的实现可能不会对所有标题都准确。</p>
<h2 id="conclusion">结论</h2>
<p>将目录添加到您的博客或文章中可以为网站访问者创造更好的体验。在本教程中，我们学习了如何创建一个带有项目高亮显示的目录，以指示每个活动标题，帮助您的用户浏览您的站点并提高您的整体 UX。</p><div class="code-block code-block-17">
<div class="blog-plug inline-plug react-plug" vwo-el-id="26283398190">
<h2 vwo-el-id="41600691720"><a href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener"> LogRocket </a>:全面了解您的生产 React 应用</h2><p>调试 React 应用程序可能很困难，尤其是当用户遇到难以重现的问题时。如果您对监视和跟踪 Redux 状态、自动显示 JavaScript 错误以及跟踪缓慢的网络请求和组件加载时间感兴趣，</p><a href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" vwo-el-id="19356441070">try LogRocket</a><p>. </p><a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="19356441380">
<img class="first-react-image alignnone size-full wp-image-46 jetpack-lazy-image jetpack-lazy-image--handled" src="../Images/f300c244a1a1cf916df8b4cb02bec6c6.png" vwo-el-id="18272717540" data-lazy-loaded="1" data-original-src="https://files.readme.io/27c94e7-Image_2017-06-05_at_9.46.04_PM.png"/>
</a>
<a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="19356441690">
<img class="second-react-image alignnone size-full wp-image-46 jetpack-lazy-image jetpack-lazy-image--handled" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" vwo-el-id="30720362350" data-lazy-loaded="1" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/>
</a>
<p vwo-el-id="28675660440" class="">LogRocket 结合了会话回放、产品分析和错误跟踪，使软件团队能够创建理想的 web 和移动产品体验。这对你来说意味着什么？</p>
<p>LogRocket 不是猜测错误发生的原因，也不是要求用户提供截图和日志转储，而是让您回放问题，就像它们发生在您自己的浏览器中一样，以快速了解哪里出错了。</p>
<p>不再有嘈杂的警报。智能错误跟踪允许您对问题进行分类，然后从中学习。获得有影响的用户问题的通知，而不是误报。警报越少，有用的信号越多。</p>
<p vwo-el-id="28675660750">LogRocket Redux 中间件包为您的用户会话增加了一层额外的可见性。LogRocket 记录 Redux 存储中的所有操作和状态。</p>
<p vwo-el-id="28675661060">现代化您调试 React 应用的方式— <a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="40093418840">开始免费监控</a>。</p>
</div></div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
<html>
<head>
<title>Using Hooks with React Router - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>在 React 路由器上使用钩子</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/using-hooks-react-router/#0001-01-01">https://blog.logrocket.com/using-hooks-react-router/#0001-01-01</a></blockquote><div><article class="article-post">
<p><em> <strong>编者按</strong>:本文最后一次更新于 2022 年 11 月 16 日<a href="https://blog.logrocket.com/react-router-v6-future-reach-router/">包括 React 路由器 v6 </a>中所做的更改，包括删除了已弃用的<code>useHistory</code>钩子。</em></p>
<p>React 挂钩是随着 React v16.8.0 的发布而引入的，令人兴奋不已。与类组件相比，使用钩子，开发人员可以用更少的样板代码编写更干净的组件。许多流行的 React 包都增加了对钩子的支持，这样开发者就可以在功能组件中利用他们的 API。</p>
<p>React 路由器是 React 应用程序的首选路由解决方案，在其 5.0 版本中增加了钩子支持。这些<a href="https://reactrouter.com/web/api/Hooks"> React 路由器钩子</a>为开发者提供了处理路由器状态的新方法。在本教程中，你将<a href="https://blog.logrocket.com/how-react-hooks-can-replace-react-router/">学习如何在 React Router </a>中使用钩子，并最小化组件中的代码行数。我们开始吧！</p>

<h2 id="how-hooks-work-react-router">钩子如何与 React 路由器一起工作？</h2>
<p>为了演示钩子如何工作，我们将创建一个 React 项目并设置页面。要创建新的 React 应用程序，请运行以下命令:</p>
<pre>npx create-react-app router-hooks-demo
</pre>
<p><code>router-hooks-demo</code>是 app 的名字，不过你想怎么命名都行。接下来，添加<code><a href="https://www.npmjs.com/package/react-router-dom">react-router-dom</a></code>包:</p>
<pre>npm i react-router-dom --save
</pre>
<p>从<code>react-router-dom</code>包中导入<code>BrowserRouter</code>、<code>Link</code>、<code>Route</code>和<code>Routes</code>组件。我们将使用这些组件在 React 应用程序中配置客户端路由:</p>
<pre>import { BrowserRouter, Link, Route, Routes } from "react-router-dom";
</pre>
<p>对于这个演示，您将只有两个路线或页面，即<code>Home</code>页面和<code>User</code>页面。我们将主要致力于<code>User</code>页面:</p>
<pre>const User = () =&gt; {
  return &lt;div&gt;This is the user page&lt;/div&gt;;
};

const Home = () =&gt; {
  return &lt;div&gt;This is the home page&lt;/div&gt;;
};
</pre>
<p>在<code>App</code>组件中，创建一个导航栏，并使用 React Router 的<code>Link</code>组件向<code>Home</code>和<code>User</code>页面添加超链接。在网页上，<code>Link</code>组件被渲染成一个<code>&lt;a&gt;</code>标签:</p>
<pre>&lt;nav&gt;
  &lt;div&gt;
    &lt;Link to="/"&gt;Home&lt;/Link&gt;
  &lt;/div&gt;
  &lt;div&gt;
    &lt;Link to="/user/:id"&gt;User&lt;/Link&gt;
  &lt;/div&gt;
&lt;/nav&gt;
</pre>
<p>接下来，添加<code>Routes</code>和<code>Route</code>组件，然后将所有内容包装在<code>BrowserRouter</code>组件中:</p>
<pre>&lt;BrowserRouter&gt;
  &lt;nav&gt;
    &lt;div&gt;
      &lt;Link to="/"&gt;Home&lt;/Link&gt;
    &lt;/div&gt;
    &lt;div&gt;
      &lt;Link to="/user/:id"&gt;User&lt;/Link&gt;
    &lt;/div&gt;
  &lt;/nav&gt;
  &lt;Switch&gt;
    &lt;Route path="/" element={&lt;Home /&gt;} /&gt;
    &lt;Route path="/user/:id" element={&lt;User /&gt;} /&gt;
  &lt;/Switch&gt;
&lt;/BrowserRouter&gt;
</pre>
<p><code><a href="https://v5.reactrouter.com/web/api/BrowserRouter">BrowserRouter</a></code>组件启用客户端路由特性，并使用<a href="https://v5.reactrouter.com/web/api/history">浏览器<code>history</code> API </a>处理路由逻辑。当路由路径与活动 URL 匹配时,<code>Route</code>组件呈现页面 UI。<code>Routes</code>组件的工作是理解其子<code>Route</code>元素，并在用户导航到不同路线时决定呈现哪个元素。</p>
<p>最终的<code>App.js</code>文件应该如下所示:</p>
<pre>import React from "react";
import { BrowserRouter, Link, Route, Routes } from "react-router-dom";

const User = () =&gt; {
  return &lt;div&gt;This is the user page&lt;/div&gt;;
};

const Home = () =&gt; {
  return &lt;div&gt;This is the home page&lt;/div&gt;;
};

export default function App() {
  return (
    &lt;div className="App"&gt;
      &lt;BrowserRouter&gt;
        &lt;nav&gt;
          &lt;div&gt;
            &lt;Link to="/"&gt;Home&lt;/Link&gt;
          &lt;/div&gt;
          &lt;div&gt;
            &lt;Link to="/user/:id"&gt;User&lt;/Link&gt;
          &lt;/div&gt;
        &lt;/nav&gt;
        &lt;Routes&gt;
          &lt;Route path="/" element={&lt;Home /&gt;} /&gt;
          &lt;Route path="/user/:id" element={&lt;User /&gt;} /&gt;
        &lt;/Routes&gt;
      &lt;/BrowserRouter&gt;
    &lt;/div&gt;
  );
}
</pre>
<h2 id="why-react-router-hooks-useful">React 路由器钩子为什么有用？</h2>
<p>假设您需要访问一个<code>page</code>组件中 URL 的当前路径名。在挂钩之前，你必须将<code>page</code>组件传递给<code>Route</code>组件的<code>component</code>道具。然后，<code>Route</code>组件将注入<a href="https://reactrouter.com/web/api/Route/route-props">路由属性</a>、<code>match</code>、<code>location</code>和<code>history</code>。</p>
<p>虽然这种方法可行，但是组件变得难以阅读，并且很难理解在维护项目时是如何注入道具的。React 路由器作者添加了钩子支持，这样<code>page</code>组件就可以访问<code>history</code>、<code>location</code>和<code>match</code>对象，而不必将<code>page</code>组件作为<code>Route</code>组件中的<code>component</code>道具传递:</p>
<pre>// Route with component prop
&lt;Route path="/user/:id" component={User} /&gt;;

// User component
const User = (props) =&gt; {
  const location = props.location;

  console.log(location.pathname);

  return &lt;div&gt;This is the user page&lt;/div&gt;;
};
</pre>
<h2 id="react-router-hooks">React 路由器挂钩</h2>
<p>既然您已经理解了我们为什么要为路由添加钩子，那么让我们来看看钩子是如何工作的。</p>
<h3 id="useparams"><code>useParams</code></h3>
<p><code>useParams</code>钩子返回一个对象，该对象包含 URL 中存在的任何参数的键值对。例如，假设您有一个<code>User</code>页面组件，它接受一个<code>id</code>作为 URL 中的参数。您可以使用<code>useParams</code>挂钩访问参数:</p>
<pre>import { useParams } from "react-router-dom";

&lt;Route path="/user/:id" element={&lt;User /&gt;} /&gt;

const User = () =&gt; {
  const params = useParams();

  console.log(params);

  return (
    // ...
  )
}
</pre>
<p>如果您要将<code>234</code>作为用户 URL 中的 ID 传递给<code>/user/234</code>，那么<code>useParams()</code>钩子将返回以下对象:</p>
<pre>{
  id: 234,
}
</pre>
<p>您可以在页面上显示<code>id</code>参数，或者使用它从服务器获取用户信息:</p>
<pre>import { useParams } from "react-router-dom";

// /user/:id
const User = () =&gt; {
  const params = useParams();

  return (
    &lt;div&gt;
      &lt;p&gt;This is the user page&lt;/p&gt;
      &lt;p&gt;current user Id - {params.id}&lt;/p&gt;
    &lt;/div&gt;
  );
};
</pre>
<h3 id="use-navigate"><code>useNavigate</code></h3>
<p>在 React 路由器 v6 中，<code>useHistory</code>钩子已经停产，<a href="https://reactrouter.com/en/main/upgrading/v5#use-usenavigate-instead-of-usehistory">提供了<code>useNavigate</code> </a>作为它的替代品。从<code>useHistory</code>切换到<code>useNavigate</code>的主要原因是为了<a href="https://blog.logrocket.com/react-suspense-data-fetching/">提供与 React suspension</a>更好的兼容性。</p>
<p><code>useNavigate</code>钩子返回一个函数，让您处理路线更改并以编程方式导航:</p>
<pre>import { useNavigate, useParams } from "react-router-dom";

const User = () =&gt; {
  let navigate = useNavigate();
  const params = useParams();

  const handleBack = () =&gt; {
    navigate(-1);
  };

  const handleNavigation = () =&gt; {
    navigate("/user/5");
  };

  return (
    &lt;div&gt;
      &lt;div&gt;This is the user page&lt;/div&gt;
      &lt;div&gt;current user Id - {params.id}&lt;/div&gt;
      &lt;div&gt;
        &lt;button onClick={handleBack}&gt;Go Back&lt;/button&gt;
      &lt;/div&gt;
      &lt;div&gt;
        &lt;button onClick={handleNavigation}&gt;Go To Different User&lt;/button&gt;
      &lt;/div&gt;
    &lt;/div&gt;
  );
};
</pre>
<p>在上面的代码块中，我们向<code>User</code>页面组件添加了两个按钮。一个按钮将用户带到上一页，另一个按钮将用户导航到不同的页面。<code>navigate(-1)</code>方法相当于点击后退按钮。它将用户导航到上一页，并返回历史堆栈中的一个条目。</p>
<h3 id="use-location"><code>useLocation</code></h3>
<p><code>useLocation</code>钩子允许您访问代表活动 URL 的<code>location</code>对象。每当用户导航到一个新的 URL 时，<code>location</code>对象的值就会改变。当您必须在 URL 改变时触发任何事件时,<code>useLocation</code>钩子会很方便。</p>
<p>考虑到您必须跟踪用户个人资料页面上的视图。您可以使用 React 附带的<code>useEffect</code>钩子来检测<code>location</code>对象中的变化:</p>
<pre>import { useNavigate, useParams, useLocation } from "react-router-dom";

const User = () =&gt; {
  const navigate = useNavigate();
  const params = useParams();
  const location = useLocation();

  useEffect(() =&gt; {
    console.log(location.pathname);
    // Send request to your server to increment page view count
  }, [location]);

  const handleBack = () =&gt; {
    navigate(-1);
  };

  const handleNavigation = () =&gt; {
    navigate("/user/5");
  };

  return (
    &lt;div&gt;
      &lt;div&gt;This is the user page&lt;/div&gt;
      &lt;div&gt;current user Id - {params.id}&lt;/div&gt;
      &lt;div&gt;
        &lt;button onClick={handleBack}&gt;Go Back&lt;/button&gt;
      &lt;/div&gt;
      &lt;div&gt;
        &lt;button onClick={handleNavigation}&gt;Go To Different User&lt;/button&gt;
      &lt;/div&gt;
    &lt;/div&gt;
  );
};
</pre>
<h3 id="usematch"><code>useMatch</code></h3>
<p>React Router v6 已经停止使用<code>useRouteMatch</code>挂钩，<a href="https://reactrouter.com/en/main/upgrading/v5#replace-useroutematch-with-usematch">提供了<code>useMatch</code>挂钩</a>作为其替代品。<code>useMatch</code>返回与当前路线相关的路线匹配数据。它将活动 URL 与给定的路径进行匹配，类似于<code>Route</code>组件的工作方式。</p>
<p><code>useMatch</code>钩子解决什么问题？假设您有一条显示多篇博文的<code>/blog</code>路线和一条显示单篇博文详细信息的<code>blog/:id</code>路线:</p>
<pre>const App = () =&gt; {
  [const posts, setPosts] = useStatte([....])

  return (  
    &lt;Routes&gt;
      &lt;Route path="/blog/:id" element={&lt;Post post={post} /&gt;} /&gt;        
      &lt;Route path="/blog" element={&lt;Posts posts={posts} /&gt;} /&gt;   
      &lt;Route path="/" element={&lt;Home /&gt;} /&gt;      
    &lt;/Routes&gt;   
  )
}  
</pre>
<p>以前，您必须将所有的帖子传递给<code>Post</code>组件，并使用<code>useParams</code>钩子过滤掉特定的帖子:</p>
<pre>const Post = ({ posts }) =&gt; { 
  const id = useParams().id
  const post = posts.find(post =&gt; post.id === Number(id))

  return (
    &lt;div&gt;
      &lt;span&gt;{post.user}&lt;/span&gt;
      &lt;p&gt;{post.content}&lt;/p&gt;
    &lt;/div&gt;
  )
}
</pre>
<p>虽然这种方法可行，但是我们可以利用<code>useMatch</code>钩子来创建一个更干净的实现。<code>Post</code>组件只接收它应该显示的数据，而不是文章的数组。</p>
<p>使用<code>app</code>组件中的<code>useMatch</code>挂钩:</p>
<pre>import { useMatch } from "react-router-dom"

const App = () =&gt; {
  [const posts, setPosts] = useStatte([....])

  const match = useMatch('/blog/:id')  
  const post = match
  ? posts.find(post =&gt; post.id === Number(match.params.id))    
  : null

  return (  
    &lt;Routes&gt;
      &lt;Route path="/blog/:id" element={&lt;Post post={post} /&gt;} /&gt;        
      &lt;Route path="/blog" element={&lt;Posts posts={posts} /&gt;} /&gt;   
      &lt;Route path="/" element={&lt;Home /&gt;} /&gt;      
    &lt;/Routes&gt;   
  )
}  
</pre>
<p>通过这种实现，每当 URL 改变时，执行下面的命令来检查当前路由是否与期望的 URL 匹配:</p>
<pre>const match = useMatch('/posts/:id')
</pre>
<p>如果 URL 匹配，<code>match</code>变量将返回一个包含匹配 URL 数据的对象。然后，您可以从该对象访问<code>id</code>参数，用它过滤出正确的帖子数据，并将其传递给<code>Post</code>组件:</p>
<pre>const Post = ({ post }) =&gt; { 
  return (
    &lt;div&gt;
      &lt;span&gt;{post.user}&lt;/span&gt;
      &lt;p&gt;{post.content}&lt;/p&gt;
    &lt;/div&gt;
  )
}
</pre>
<h3 id="useroutes"><code>useRoutes</code></h3>
<p>React 路由器提供了两种在 React 应用程序中定义路由的方法。第一个也是最流行的是使用<code>&lt;Routes&gt;</code>和<code>&lt;Route&gt;</code>组件。第二种方法包括使用<a href="https://reactrouter.com/en/main/hooks/use-routes"> <code>useRoutes</code>钩子</a>和普通的 JavaScript 对象来声明您的路线。</p>
<p>要查看<code>useRoutes</code>挂钩是如何工作的，首先创建一个<code>routes.js</code>文件，您将在其中创建路线:</p>
<pre>import { useRoutes } from "react-router-dom";
import Home from "./pages/Home";
import Post from "./pages/Post";
import Posts from "./pages/Posts";
import User from "./pages/User";

export default function Router() {
  let element = useRoutes([
    { path: "/home", element: &lt;Home /&gt; },
    { path: "/posts", element: &lt;Post /&gt; },
    { path: "/post:id", element: &lt;Posts /&gt; },
    { path: "user", element: &lt;User /&gt; },
  ]);

  return element;
}
</pre>
<p>然后，将路线导入到您的<code>App.js</code>文件中:</p>
<pre>import { BrowserRouter } from "react-router-dom";
import Router from "./routes";

export default function App() {
  return (
    &lt;BrowserRouter&gt;
      &lt;div className="App"&gt;
        &lt;h1&gt;useRoutes Example&lt;/h1&gt;
        &lt;Router /&gt;
      &lt;/div&gt;
    &lt;/BrowserRouter&gt;
  );
}
</pre>
<p>使用一种方法定义路由优于另一种方法没有任何好处。这可以归结为你和你的团队的偏好和模式。</p>
<h2 id="conclusion">结论</h2>
<p>钩子是 React 生态系统的一个很好的补充。在本文中，我们回顾了一些用钩子处理路由的代码，使用了<code>useParams</code>、<code>useNavigate</code>、<code>useLocation</code>、<code>useMatch</code>和<code>useRoutes</code>钩子。现在，您已经准备好充分利用他们所提供的一切。</p><div class="code-block code-block-17">
<div class="blog-plug inline-plug react-plug" vwo-el-id="26283398190">
<h2 vwo-el-id="41600691720">使用 LogRocket 消除传统反应错误报告的噪音</h2>
<a href="https://lp.logrocket.com/blg/react-signup-issue-free" target="_blank" vwo-el-id="19356441070">LogRocket
</a><p>是一款 React analytics 解决方案，可保护您免受数百个误报错误警报的影响，只针对少数真正重要的项目。LogRocket 告诉您 React 应用程序中实际影响用户的最具影响力的 bug 和 UX 问题。</p><a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="19356441380">
<img class="first-react-image alignnone size-full wp-image-46 jetpack-lazy-image jetpack-lazy-image--handled" src="../Images/f300c244a1a1cf916df8b4cb02bec6c6.png" vwo-el-id="18272717540" data-lazy-loaded="1" data-original-src="https://files.readme.io/27c94e7-Image_2017-06-05_at_9.46.04_PM.png"/>
</a>
<a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="19356441690">
<img class="second-react-image alignnone size-full wp-image-46 jetpack-lazy-image jetpack-lazy-image--handled" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" vwo-el-id="30720362350" data-lazy-loaded="1" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/>
</a>
<a href="https://lp.logrocket.com/blg/react-signup-issue-free" target="_blank" rel="noopener noreferrer" vwo-el-id="35866400580">LogRocket
</a><p>自动聚合客户端错误、反应错误边界、还原状态、缓慢的组件加载时间、JS 异常、前端性能指标和用户交互。然后，LogRocket 使用机器学习来通知您影响大多数用户的最具影响力的问题，并提供您修复它所需的上下文。</p><p vwo-el-id="28675661060">关注重要的 React bug—<a class="signup" href="https://lp.logrocket.com/blg/react-signup-issue-free" target="_blank" rel="noopener noreferrer" vwo-el-id="40093418840">今天就试试 LogRocket】。</a></p>
</div></div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
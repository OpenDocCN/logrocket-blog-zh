<html>
<head>
<title>Building an audio player in React to play sound or music </title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>在React中构建一个音频播放器来播放声音或音乐</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/building-audio-player-react/#0001-01-01">https://blog.logrocket.com/building-audio-player-react/#0001-01-01</a></blockquote><div><article class="article-post">
<p>如果您运行podcast或任何其他与声音或音乐相关的web应用程序，您可能想要在项目中添加音频播放器。本指南将教你如何用React从头开始构建一个音频播放器。</p>
<p>音频播放器将提供控制功能，如播放或暂停曲目、调节音量、移动到下一首或上一首曲目、移动进度滑块等。我们还将对其进行定制，使其在不同浏览器间保持一致。</p>
<p>向前跳:</p>

<p>在开始本教程之前，请确保您对React 有一个基本的了解。</p>
<p>下面是我们将共同构建的最终产品的预览:</p>
<p><img data-attachment-id="159137" data-permalink="https://blog.logrocket.com/building-audio-player-react/attachment/img1-react-audio-player-end-product/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2023/02/img1-React-audio-player-end-product.jpeg" data-orig-size="730,455" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;1&quot;}" data-image-title="React-audio-player-end-product" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2023/02/img1-React-audio-player-end-product-300x187.jpeg" data-large-file="https://blog.logrocket.com/wp-content/uploads/2023/02/img1-React-audio-player-end-product.jpeg" decoding="async" class="aligncenter size-full wp-image-159137 jetpack-lazy-image" src="../Images/28d741fdbd65e5f1240a342e8fe137cf.png" alt="Reach Audio Player Project End Product Showing Paused Podcast Episode. Colored Boxes And Numbers In Circles Indicate Different Components Of Sound Player" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2023/02/img1-React-audio-player-end-product.jpeg 730w, https://blog.logrocket.com/wp-content/uploads/2023/02/img1-React-audio-player-end-product-300x187.jpeg 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2023/02/img1-React-audio-player-end-product.jpeg?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2023/02/img1-React-audio-player-end-product.jpeg"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="159137" data-permalink="https://blog.logrocket.com/building-audio-player-react/attachment/img1-react-audio-player-end-product/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2023/02/img1-React-audio-player-end-product.jpeg" data-orig-size="730,455" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;1&quot;}" data-image-title="React-audio-player-end-product" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2023/02/img1-React-audio-player-end-product-300x187.jpeg" data-large-file="https://blog.logrocket.com/wp-content/uploads/2023/02/img1-React-audio-player-end-product.jpeg" decoding="async" loading="lazy" class="aligncenter size-full wp-image-159137" src="../Images/28d741fdbd65e5f1240a342e8fe137cf.png" alt="Reach Audio Player Project End Product Showing Paused Podcast Episode. Colored Boxes And Numbers In Circles Indicate Different Components Of Sound Player" srcset="https://blog.logrocket.com/wp-content/uploads/2023/02/img1-React-audio-player-end-product.jpeg 730w, https://blog.logrocket.com/wp-content/uploads/2023/02/img1-React-audio-player-end-product-300x187.jpeg 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2023/02/img1-React-audio-player-end-product.jpeg"/></noscript>
<p>可以<a href="https://ibaslogic.github.io/react-audio-player/">和项目</a>互动，之后就可以开始了！</p>
<h2 id="setting-up-dev-environment">设置开发环境</h2>
<p>让我们运行下面的命令，用 <code><a href="https://blog.logrocket.com/getting-started-with-create-react-app-d93147444a27/">create-react-app</a></code>设置一个<a href="https://blog.logrocket.com/getting-started-with-create-react-app-d93147444a27/">开发环境:</a></p>
<pre class="language-bash hljs">npx create-react-app react-audio-player
</pre>
<p>然后执行以下操作来启动项目:</p>
<pre class="language-bash hljs">cd react-audio-player
npm start
</pre>
<h2 id="creating-react-audio-player-project-structure">创建React音频播放器项目结构</h2>
<p>正如你在上面的图片中看到的，我们可以把用户界面分成四个部分。图像上的数字标签对应于以下组件名称:</p>
<ol>
<li><code>AudioPlayer</code> —父/根组件</li>
<li><code>DisplayTrack</code> —呈现音频内容</li>
<li><code>Controls</code> —渲染音频控制和音量滑块</li>
<li><code>ProgressBar</code> —渲染音频进度条和时间</li>
</ol>
<p>记住这一点，我们将在<code>src/components</code>文件夹中创建组件文件。让我们确保我们的项目目录遵循以下结构:</p>
<pre class="language-javascript hljs">react-audio-player
   ...
    ├── src
    │    ├── components
    │    │      ├── AudioPlayer.js
    │    │      ├── Controls.js
    │    │      ├── DisplayTrack.js
    │    │      └── ProgressBar.js     
    │    ├── data
    │    ├── styles
    │    │      └── index.css
    │    ├── index.js
    │   ...
</pre>
<p>注意，我们还在<code>src</code>中添加了一个<code>data</code>文件夹和<code>styles/index.css</code>文件，分别保存音频文件和CSS。复制<code><a href="https://github.com/Ibaslogic/react-audio-player/blob/main/src/styles/index.css">react-audio-player</a></code> <a href="https://github.com/Ibaslogic/react-audio-player/blob/main/src/styles/index.css">项目样式</a>并粘贴到<code>styles/index.css</code>文件中。</p>
<p>接下来，在<code>components/AudioPlayer.js</code>文件中，让我们渲染一些简单的文本:</p>
<pre class="language-javascript hljs">const AudioPlayer = () =&gt; {
  return (
    &lt;div className="audio-player"&gt;
      &lt;div className="inner"&gt;Audio player content&lt;/div&gt;
    &lt;/div&gt;
  );
};
export default AudioPlayer;
</pre>
<p>之后，用以下内容替换<code>src/index.js</code>文件的内容:</p>
<pre class="language-javascript hljs">import React from 'react';
import ReactDOM from 'react-dom/client';
import AudioPlayer from './components/AudioPlayer';

import './styles/index.css';

const root = ReactDOM.createRoot(document.getElementById('root'));
root.render(
  &lt;React.StrictMode&gt;
    &lt;AudioPlayer /&gt;
  &lt;/React.StrictMode&gt;
);
</pre>
<p>保存文件并查看浏览器中呈现的<code>AudioPlayer</code>组件的内容。</p>
<h2 id="rendering-audio-player-child-components">呈现<code>AudioPlayer</code>子组件</h2>
<p>从<code>DisplayTrack</code>组件开始。在<code>components/DisplayTrack.js</code>文件中，让我们呈现一些简单的文本:</p>
<pre class="language-javascript hljs">const DisplayTrack = () =&gt; {
  return &lt;div&gt;DisplayTrack content here&lt;/div&gt;;
};
export default DisplayTrack;
</pre>
<p>然后，导入<code>components/AudioPlayer.js</code>文件中的组件:</p>
<pre class="language-javascript hljs">import DisplayTrack from './DisplayTrack';

const AudioPlayer = () =&gt; {
  return (
    &lt;div className="audio-player"&gt;
      &lt;div className="inner"&gt;
        &lt;DisplayTrack /&gt;
      &lt;/div&gt;
    &lt;/div&gt;
  );
};
export default AudioPlayer;
</pre>
<p>保存文件以查看呈现在前端的组件文本。</p>
<p>同样，让我们为其他子组件— <code>Controls</code>和<code>ProgressBar</code>呈现一些文本。之后，我们将它们导入并渲染到<code>components/AudioPlayer.js</code>文件中，如下所示:</p>
<pre class="language-javascript hljs">import DisplayTrack from './DisplayTrack';
import Controls from './Controls';
import ProgressBar from './ProgressBar';

const AudioPlayer = () =&gt; {
  return (
    &lt;div className="audio-player"&gt;
      &lt;div className="inner"&gt;
        &lt;DisplayTrack /&gt;
        &lt;Controls /&gt;
        &lt;ProgressBar /&gt;
      &lt;/div&gt;
    &lt;/div&gt;
  );
};
export default AudioPlayer;
</pre>
<p>保存所有文件，并确保组件的内容呈现在前端。</p>
<h2 id="embedding-sound-content-play-react-project">在React项目中嵌入要播放的声音内容</h2>
<p>我们将使用HTML <code>&lt;audio&gt;</code>元素在我们的项目中嵌入音频。这个元素有一个用于指定音频URL的<code>src</code>属性和一个用于显示浏览器对音频的特定控制的<code>controls</code>属性，比如播放、暂停和其他:</p>
<pre class="language-javascript hljs">&lt;audio src=" " controls /&gt;
</pre>
<h3>获取音频文件</h3>
<p>我们需要音频文件来使用<code>&lt;audio&gt;</code>元素。因此，让我们在<code>src/data</code>文件夹中创建一个<code>tracks.js</code>文件，然后<a href="https://github.com/Ibaslogic/react-audio-player/blob/main/src/data/tracks.js">将音轨</a>添加为一个对象数组，如下所示:</p>
<pre class="language-javascript hljs">// audio files
import beautiful from './a_beautiful_day.mp3';

// audio thumbnails
import trinix from './trinix.jpeg';

export const tracks = [
  {
    title: 'Trinix ft Rushawn – Its a beautiful day',
    src: beautiful,
    author: 'Trinix ft Rushawn',
    thumbnail: trinix,
  },
  // ...
];
</pre>
<p>您可以从项目资源库中复制<a href="https://github.com/Ibaslogic/react-audio-player/tree/main/src/data">样本音频文件，并在<code>src/data</code>文件夹中使用它们。</a></p>
<h3>渲染音频播放器</h3>
<p>因为我们将需要多个子组件中的音频数据，所以我们将在<code>AudioPlayer</code>父组件中导入播放列表文件。然后，我们将创建一个状态来处理当前的音轨。现在，我们将分配播放列表中的第一首曲目。</p>
<p><code>components/AudioPlayer.js</code>文件现在看起来像这样:</p>
<pre class="language-javascript hljs">import { useState } from 'react';
import { tracks } from '../data/tracks';

// import components
import DisplayTrack from './DisplayTrack';
import Controls from './Controls';
import ProgressBar from './ProgressBar';

const AudioPlayer = () =&gt; {
  const [currentTrack, setCurrentTrack] = useState(tracks[0]);
  return (
    &lt;div className="audio-player"&gt;
      &lt;div className="inner"&gt;
        &lt;DisplayTrack currentTrack={currentTrack} /&gt;
        &lt;Controls /&gt;
        &lt;ProgressBar /&gt;
      &lt;/div&gt;
    &lt;/div&gt;
  );
};
export default AudioPlayer;
</pre>
<p>在代码中，我们使用零<code>[0]</code>索引将数组中的第一个轨道分配给一个状态。注意我们是如何将状态传递给<code>DisplayTrack</code>组件的。</p>
<p>让我们从<code>components/DisplayTrack.js</code>文件中访问状态，并更新<code>&lt;audio&gt;</code>标签的<code>src</code>属性:</p>
<pre class="language-javascript hljs">const DisplayTrack = ({ currentTrack }) =&gt; {
  return (
    &lt;div&gt;
      &lt;audio src={currentTrack.src} controls /&gt;
    &lt;/div&gt;
  );
};
export default DisplayTrack;
</pre>
<p>如果我们保存所有文件，音频应该呈现如下:</p>
<p><img data-attachment-id="159139" data-permalink="https://blog.logrocket.com/building-audio-player-react/attachment/img2-simple-react-audio-player-default-controls/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2023/02/img2-Simple-React-audio-player-default-controls.png" data-orig-size="730,358" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Simple-React-audio-player-default-controls" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2023/02/img2-Simple-React-audio-player-default-controls-300x147.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2023/02/img2-Simple-React-audio-player-default-controls.png" decoding="async" class="aligncenter size-full wp-image-159139 jetpack-lazy-image" src="../Images/495631a8eeb556fa7d7fc392e8615502.png" alt="Simple React Audio Player With Default Controls And Styling Rendered In Browser" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2023/02/img2-Simple-React-audio-player-default-controls.png 730w, https://blog.logrocket.com/wp-content/uploads/2023/02/img2-Simple-React-audio-player-default-controls-300x147.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2023/02/img2-Simple-React-audio-player-default-controls.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2023/02/img2-Simple-React-audio-player-default-controls.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="159139" data-permalink="https://blog.logrocket.com/building-audio-player-react/attachment/img2-simple-react-audio-player-default-controls/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2023/02/img2-Simple-React-audio-player-default-controls.png" data-orig-size="730,358" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Simple-React-audio-player-default-controls" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2023/02/img2-Simple-React-audio-player-default-controls-300x147.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2023/02/img2-Simple-React-audio-player-default-controls.png" decoding="async" loading="lazy" class="aligncenter size-full wp-image-159139" src="../Images/495631a8eeb556fa7d7fc392e8615502.png" alt="Simple React Audio Player With Default Controls And Styling Rendered In Browser" srcset="https://blog.logrocket.com/wp-content/uploads/2023/02/img2-Simple-React-audio-player-default-controls.png 730w, https://blog.logrocket.com/wp-content/uploads/2023/02/img2-Simple-React-audio-player-default-controls-300x147.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2023/02/img2-Simple-React-audio-player-default-controls.png"/></noscript>
<p>音频控件的外观因浏览器而异。因此，我们将创建一个自定义控件来获得跨浏览器的一致外观和感觉，并添加额外的功能。</p>
<p>让我们从移除<code>&lt;audio&gt;</code>标签中的<code>controls</code>属性开始，以消除浏览器的默认控件。我们应该具备以下条件:</p>
<pre class="language-javascript hljs">&lt;audio src={currentTrack.src} /&gt;
</pre>
<p>接下来，我们将添加一些自定义控件。</p>
<h2 id="adding-custom-controls-react-sound-player">为React声音播放器添加自定义控制</h2>
<p>首先，我们需要控制图标。让我们在项目中运行以下命令，从<a href="https://blog.logrocket.com/react-icons-comprehensive-tutorial-examples/">React图标库</a>中获取图标:</p>
<pre class="language-bash hljs">npm install react-icons
</pre>
<p>之后，打开<code>components/Controls.js</code>文件，渲染控件图标。然后，我们应该有以下内容:</p>
<pre class="language-javascript hljs">import { useState } from 'react';

// icons
import {
  IoPlayBackSharp,
  IoPlayForwardSharp,
  IoPlaySkipBackSharp,
  IoPlaySkipForwardSharp,
  IoPlaySharp,
  IoPauseSharp,
} from 'react-icons/io5';

const Controls = () =&gt; {
  const [isPlaying, setIsPlaying] = useState(false);
  return (
    &lt;div className="controls-wrapper"&gt;
      &lt;div className="controls"&gt;
        &lt;button&gt;
          &lt;IoPlaySkipBackSharp /&gt;
        &lt;/button&gt;
        &lt;button&gt;
          &lt;IoPlayBackSharp /&gt;
        &lt;/button&gt;

        &lt;button&gt;
          {isPlaying ? &lt;IoPauseSharp /&gt; : &lt;IoPlaySharp /&gt;}
        &lt;/button&gt;
        &lt;button&gt;
          &lt;IoPlayForwardSharp /&gt;
        &lt;/button&gt;
        &lt;button&gt;
          &lt;IoPlaySkipForwardSharp /&gt;
        &lt;/button&gt;
      &lt;/div&gt;
    &lt;/div&gt;
  );
};

export default Controls;
</pre>
<p>在代码中，请注意我们使用了<a href="https://blog.logrocket.com/a-guide-to-usestate-in-react-ecb9952e406c/"/><code><a href="https://blog.logrocket.com/a-guide-to-usestate-in-react-ecb9952e406c/">useState()</a></code><a href="https://blog.logrocket.com/a-guide-to-usestate-in-react-ecb9952e406c/">钩子</a>来动态呈现播放和暂停图标。让我们添加单击按钮时切换图标的功能。</p>
<p>更新播放/暂停按钮以包含<a href="https://blog.logrocket.com/react-onclick-event-handlers-guide/"/><code><a href="https://blog.logrocket.com/react-onclick-event-handlers-guide/">onClick</a></code><a href="https://blog.logrocket.com/react-onclick-event-handlers-guide/">事件处理程序</a>，如下所示:</p>
<pre class="language-javascript hljs">&lt;button onClick={togglePlayPause}&gt;
  {isPlaying ? &lt;IoPauseSharp /&gt; : &lt;IoPlaySharp /&gt;}
&lt;/button&gt;
</pre>
<p>然后，在<code>return</code>语句上方添加以下处理程序，以便在单击<code>togglePlayPause</code>按钮时切换布尔状态值:</p>
<pre class="language-javascript hljs">const togglePlayPause = () =&gt; {
  setIsPlaying((prev) =&gt; !prev);
};
</pre>
<p>保存您的文件，并确保在您单击播放和暂停按钮时切换它们。</p>
<h2 id="play-pause-html-audio-methods"><code>play()</code>和<code>pause()</code> HTML音频方法</h2>
<p>为了播放和暂停音轨，<code>&lt;audio&gt;</code>元素公开了<code>play()</code>和<code>pause()</code>方法。要调用这些方法，我们必须能够访问<code>&lt;audio&gt;</code>元素。在React中，我们用<a href="https://blog.logrocket.com/accessing-previous-props-state-react-hooks/#useref-depth-overlooked-react-hook"/><code><a href="https://blog.logrocket.com/accessing-previous-props-state-react-hooks/#useref-depth-overlooked-react-hook">useRef</a></code><a href="https://blog.logrocket.com/accessing-previous-props-state-react-hooks/#useref-depth-overlooked-react-hook">钩子</a>来表示。</p>
<p>因为我们将在多个子组件中需要这个<code>&lt;audio&gt;</code>引用，所以我们将在它们的父组件中创建它。打开<code>components/AudioPlayer.js</code>文件，导入<code>useRef</code>钩子:</p>
<pre class="language-javascript hljs">import { useRef, useState } from 'react';
</pre>
<p>然后，初始化<code>return</code>语句上面的<code>useRef</code>，并将其传递给<code>DisplayTrack</code>和<code>Controls</code>组件:</p>
<pre class="language-javascript hljs">const AudioPlayer = () =&gt; {
  const [currentTrack, setCurrentTrack] = useState(tracks[0]);

  // reference
  const audioRef = useRef();

  return (
    &lt;div className="audio-player"&gt;
      &lt;div className="inner"&gt;
        &lt;DisplayTrack
          currentTrack={currentTrack}
          audioRef={audioRef}
        /&gt;
        &lt;Controls audioRef={audioRef} /&gt;
        &lt;ProgressBar /&gt;
      &lt;/div&gt;
    &lt;/div&gt;
  );
};
export default AudioPlayer;
</pre>
<p>在<code>DisplayTrack</code>组件中，让我们访问引用并将其分配给<code>&lt;audio&gt;</code>元素上的<code>ref</code>属性:</p>
<pre class="language-javascript hljs">const DisplayTrack = ({ currentTrack, audioRef }) =&gt; {
  return (
    &lt;div&gt;
      &lt;audio src={currentTrack.src} ref={audioRef} /&gt;
    &lt;/div&gt;
  );
};
export default DisplayTrack;
</pre>
<p>如果我们保存我们的文件，我们现在应该可以通过为<code>ref</code>返回的对象访问<code>&lt;audio&gt;</code>元素的方法和属性。您可以在<code>AudioPlayer</code>组件中记录<code>audioRef</code>，并在浏览器控制台中查看它返回的内容:</p>
<pre class="language-javascript hljs">const audioRef = useRef();
console.log(audioRef);
</pre>
<p>接下来，让我们打开<code>components/Controls.js</code>文件并访问引用变量。然后，在它的<code>current</code>对象上，我们可以调用<code>play()</code>和<code>pause()</code>方法:</p>
<pre class="language-javascript hljs">import { useState, useEffect } from 'react';

// icons here

const Controls = ({ audioRef }) =&gt; {
  // ...
  useEffect(() =&gt; {
    if (isPlaying) {
      audioRef.current.play();
    } else {
      audioRef.current.pause();
    }
  }, [isPlaying, audioRef]);

  return (
    // ...
  );
};

export default Controls;
</pre>
<p>上面代码中的重点是<a href="https://blog.logrocket.com/using-react-useeffect-hook-lifecycle-methods/"/><code><a href="https://blog.logrocket.com/using-react-useeffect-hook-lifecycle-methods/">useEffect</a></code><a href="https://blog.logrocket.com/using-react-useeffect-hook-lifecycle-methods/">钩子</a>。在钩子中，我们检查了<code>isPlaying</code>状态值是否为真，以播放或暂停音轨。</p>
<p>如果我们保存文件并访问前端，我们应该能够播放和暂停当前的音轨。</p>
<h2 id="displaying-current-track-data">显示当前轨道数据</h2>
<p>为了渲染当前的音轨标题、作者和缩略图，让我们打开<code>components/DisplayTrack.js</code>文件并更新JSX以包含数据:</p>
<pre class="language-javascript hljs">import { BsMusicNoteBeamed } from 'react-icons/bs';

const DisplayTrack = ({ currentTrack, audioRef }) =&gt; {
  return (
    &lt;div&gt;
      &lt;audio src={currentTrack.src} ref={audioRef} /&gt;
      &lt;div className="audio-info"&gt;
        &lt;div className="audio-image"&gt;
          {currentTrack.thumbnail ? (
            &lt;img src={currentTrack.thumbnail} alt="audio avatar" /&gt;
          ) : (
            &lt;div className="icon-wrapper"&gt;
              &lt;span className="audio-icon"&gt;
                &lt;BsMusicNoteBeamed /&gt;
              &lt;/span&gt;
            &lt;/div&gt;
          )}
        &lt;/div&gt;
        &lt;div className="text"&gt;
          &lt;p className="title"&gt;{currentTrack.title}&lt;/p&gt;
          &lt;p&gt;{currentTrack.author}&lt;/p&gt;
        &lt;/div&gt;
      &lt;/div&gt;
    &lt;/div&gt;
  );
};
export default DisplayTrack;
</pre>
<p>在上面的代码中，焦点是在<code>&lt;audio&gt;</code>标签下的<code>div</code>包装元素。在这个<code>div</code>中，我们从检查缩略图是否存在开始，以显示它或呈现自定义样式。</p>
<p>注意，我们从<code>react-icons</code>库中导入了一个图标来设计默认缩略图。随后，我们在缩略图后渲染了音轨标题和作者的名字。</p>
<p>如果我们保存文件，结果应该是这样的:</p>
<p><img data-attachment-id="159141" data-permalink="https://blog.logrocket.com/building-audio-player-react/attachment/img3-react-audio-player-custom-controls/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2023/02/img3-React-audio-player-custom-controls.png" data-orig-size="730,512" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="React-audio-player-custom-controls" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2023/02/img3-React-audio-player-custom-controls-300x210.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2023/02/img3-React-audio-player-custom-controls.png" decoding="async" class="aligncenter size-full wp-image-159141 jetpack-lazy-image" src="../Images/64d6e8b4a9542ad112189c64bce84cc7.png" alt="React Audio Player With Custom Controls And Styling Including Track Image, Title, And Author" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2023/02/img3-React-audio-player-custom-controls.png 730w, https://blog.logrocket.com/wp-content/uploads/2023/02/img3-React-audio-player-custom-controls-300x210.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2023/02/img3-React-audio-player-custom-controls.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2023/02/img3-React-audio-player-custom-controls.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="159141" data-permalink="https://blog.logrocket.com/building-audio-player-react/attachment/img3-react-audio-player-custom-controls/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2023/02/img3-React-audio-player-custom-controls.png" data-orig-size="730,512" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="React-audio-player-custom-controls" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2023/02/img3-React-audio-player-custom-controls-300x210.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2023/02/img3-React-audio-player-custom-controls.png" decoding="async" loading="lazy" class="aligncenter size-full wp-image-159141" src="../Images/64d6e8b4a9542ad112189c64bce84cc7.png" alt="React Audio Player With Custom Controls And Styling Including Track Image, Title, And Author" srcset="https://blog.logrocket.com/wp-content/uploads/2023/02/img3-React-audio-player-custom-controls.png 730w, https://blog.logrocket.com/wp-content/uploads/2023/02/img3-React-audio-player-custom-controls-300x210.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2023/02/img3-React-audio-player-custom-controls.png"/></noscript>
<h2 id="configuring-progress-bar-volume-slider">配置进度条和音量滑块</h2>
<p>为了添加这些功能，我们将使用HTML <code>input</code> range元素。从进度条开始，让我们打开<code>components/ProgressBar.js</code>文件并更新JSX，这样我们就有了以下内容:</p>
<pre class="language-javascript hljs">const ProgressBar = () =&gt; {
  return (
    &lt;div className="progress"&gt;
      &lt;span className="time current"&gt;00:00&lt;/span&gt;
      &lt;input type="range" /&gt;
      &lt;span className="time"&gt;03:34&lt;/span&gt;
    &lt;/div&gt;
  );
};

export default ProgressBar;
</pre>
<p>如果我们保存文件并查看项目，我们将看到浏览器的默认输入范围。使用CSS规则创建跨浏览器一致的range元素需要做更多的工作。</p>
<p>为此，让我们创建一个<code>styles/customize-progress-bar.css</code>文件，复制<code><a href="https://github.com/Ibaslogic/react-audio-player/blob/main/src/styles/customize-progress-bar.css">react-audio-player</a></code> <a href="https://github.com/Ibaslogic/react-audio-player/blob/main/src/styles/customize-progress-bar.css">项目的CSS规则</a>，并粘贴到新创建的CSS文件中。</p>
<p>接下来，在<code>src/index.js</code>中导入CSS文件:</p>
<pre class="language-css hljs">// css
import './styles/index.css';
import './styles/customize-progress-bar.css';
</pre>
<p>确保您保存了所有文件。</p>
<p>值得注意的是，我们在CSS文件中使用了一个CSS变量来动态分配进度宽度:</p>
<pre class="language-css hljs">input[type="range"] {
  --range-progress: 0;
  /* ... */
}

input[type="range"]::before {
  /* ... */
  background: #f50;
  width: var(--range-progress);
  /* ... */
}
</pre>
<p>我们从零值开始。我们将根据音频进度动态更新该值。现在，让我们暂时将CSS变量值修改为50%，如下所示:</p>
<pre class="language-css hljs">input[type="range"] {
  --range-progress: 50%;
  /* ... */
}
</pre>
<p>然后我们将有一个进度条，其样式达到总长度的50 %:</p>
<p><img data-attachment-id="159143" data-permalink="https://blog.logrocket.com/building-audio-player-react/attachment/img4-react-audio-player-progress-slider/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2023/02/img4-React-audio-player-progress-slider.png" data-orig-size="730,491" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="React-audio-player-progress-slider" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2023/02/img4-React-audio-player-progress-slider-300x202.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2023/02/img4-React-audio-player-progress-slider.png" decoding="async" class="aligncenter size-full wp-image-159143 jetpack-lazy-image" src="../Images/d4887851ccecd13dc408b3f2397809ba.png" alt="Custom Styled React Audio Player With Track Progress Slider Bar Added, Indicated By Orange Arrow" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2023/02/img4-React-audio-player-progress-slider.png 730w, https://blog.logrocket.com/wp-content/uploads/2023/02/img4-React-audio-player-progress-slider-300x202.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2023/02/img4-React-audio-player-progress-slider.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2023/02/img4-React-audio-player-progress-slider.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="159143" data-permalink="https://blog.logrocket.com/building-audio-player-react/attachment/img4-react-audio-player-progress-slider/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2023/02/img4-React-audio-player-progress-slider.png" data-orig-size="730,491" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="React-audio-player-progress-slider" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2023/02/img4-React-audio-player-progress-slider-300x202.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2023/02/img4-React-audio-player-progress-slider.png" decoding="async" loading="lazy" class="aligncenter size-full wp-image-159143" src="../Images/d4887851ccecd13dc408b3f2397809ba.png" alt="Custom Styled React Audio Player With Track Progress Slider Bar Added, Indicated By Orange Arrow" srcset="https://blog.logrocket.com/wp-content/uploads/2023/02/img4-React-audio-player-progress-slider.png 730w, https://blog.logrocket.com/wp-content/uploads/2023/02/img4-React-audio-player-progress-slider-300x202.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2023/02/img4-React-audio-player-progress-slider.png"/></noscript>
<p>让我们将分配给CSS变量的值返回给<code>0</code>:</p>
<pre class="language-css hljs">input[type="range"] {
  --range-progress: 0;
  /* ... */
}
</pre>
<h3>实施受控和非受控输入</h3>
<p>在React中，像range这样的表单输入既可以是受控的，也可以是不受控的。使用受控输入，组件管理状态，我们为每个状态更新编写一个处理程序。对于不受控制的输入，DOM管理状态，我们使用ref从DOM获取输入值。</p>
<p>我们将学习实现受控和非受控输入。我们将在进度条上实现非受控逻辑，在音量滑块上实现受控逻辑。</p>
<p>回到进度条，我们将得到对输入范围的引用。因为我们将在多个子组件中需要这个引用，所以我们将在它们的父组件中初始化它。</p>
<p>打开<code>components/AudioPlayer.js</code>文件，在<code>return</code>语句上方初始化一个ref，并将其传递给<code>&lt;ProgressBar /&gt;</code>:</p>
<pre class="language-javascript hljs">const AudioPlayer = () =&gt; {
  // ...
  const progressBarRef = useRef();

return (
  &lt;div className="audio-player"&gt;
    &lt;div className="inner"&gt;
      &lt;DisplayTrack
        currentTrack={currentTrack}
        audioRef={audioRef}
      /&gt;
      &lt;Controls audioRef={audioRef} /&gt;
      &lt;ProgressBar progressBarRef={progressBarRef} /&gt;
    &lt;/div&gt;
  &lt;/div&gt;
);
};
export default AudioPlayer;
</pre>
<p>为了使我们的代码简短，我们可以重写返回的JSX，这样我们就有了:</p>
<pre class="language-javascript hljs">return (
  &lt;div className="audio-player"&gt;
    &lt;div className="inner"&gt;
      &lt;DisplayTrack {...{ currentTrack, audioRef }} /&gt;
      &lt;Controls {...{ audioRef }} /&gt;
      &lt;ProgressBar {...{ progressBarRef }} /&gt;
    &lt;/div&gt;
  &lt;/div&gt;
);
</pre>
<p>让我们保存我们的文件，打开<code>components/ProgressBar.js</code>文件，访问引用，并将其分配给<code>&lt;input /&gt;</code>元素上的<code>ref</code>属性:</p>
<pre class="language-javascript hljs">const ProgressBar = ({ progressBarRef }) =&gt; {
  return (
    &lt;div className="progress"&gt;
      &lt;span className="time current"&gt;00:00&lt;/span&gt;
      &lt;input type="range" ref={progressBarRef} /&gt;
      &lt;span className="time"&gt;03:34&lt;/span&gt;
    &lt;/div&gt;
  );
};

export default ProgressBar;
</pre>
<p>现在我们有了对<code>&lt;input /&gt;</code>的引用，我们将添加一个<code>onChange</code>事件来获取每个点的输入值。我们还将默认值设置为<code>0</code>,这样范围缩略图从开始处开始。组件现在看起来像这样:</p>
<pre class="language-javascript hljs">const ProgressBar = ({ progressBarRef }) =&gt; {
  const handleProgressChange = () =&gt; {
    console.log(progressBarRef.current.value);
  };

  return (
    &lt;div className="progress"&gt;
      &lt;span className="time current"&gt;00:00&lt;/span&gt;
      &lt;input
        type="range"
        ref={progressBarRef}
        defaultValue="0"
        onChange={handleProgressChange}
      /&gt;
      &lt;span className="time"&gt;03:34&lt;/span&gt;
    &lt;/div&gt;
  );
};

export default ProgressBar;
</pre>
<p>当改变进度条时，我们将在浏览器控制台中看到相应的值。</p>
<p>我们现在将这个值赋给音频播放的<code>currentTime</code>属性。此属性使用秒作为度量单位返回音频播放的当前位置。</p>
<p>为了获得<code>currentTime</code>属性，我们需要音频引用。幸运的是，我们之前在<code>components/AudioPlayer.js</code>文件中创建了它。所以，让我们把它传递给<code>&lt;ProgressBar /&gt;</code>组件，这样我们就有了以下内容:</p>
<pre class="language-javascript hljs">&lt;ProgressBar {...{ progressBarRef, audioRef }} /&gt;
</pre>
<p>之后，打开<code>components/ProgressBar.js</code>文件，访问音频ref。然后，我们将进度条值分配给<code>currentTime</code>属性:</p>
<pre class="language-javascript hljs">const ProgressBar = ({ progressBarRef, audioRef }) =&gt; {
  const handleProgressChange = () =&gt; {
    audioRef.current.currentTime = progressBarRef.current.value;
  };
  return (
    // ...
  );
};

export default ProgressBar;
</pre>
<p>让我们保存所有文件。当我们改变进度条时，音频播放会跳到指定的位置。请注意，时间现在是静止的，范围进度颜色没有进展。我们会到达那里的！</p>
<h2 id="displaying-time-progress-duration">显示时间进度和持续时间</h2>
<p>我们将从创建保存音频时间的状态开始。在<code>components/AudioPlayer.js</code>文件中，添加状态并将状态变量传递给<code>&lt;ProgressBar /&gt;</code>:</p>
<pre class="language-javascript hljs">const AudioPlayer = () =&gt; {
  // ...
  const [timeProgress, setTimeProgress] = useState(0);
  const [duration, setDuration] = useState(0);

  // reference

  return (
    &lt;div className="audio-player"&gt;
      &lt;div className="inner"&gt;
        {/* ... */}
        &lt;ProgressBar
          {...{ progressBarRef, audioRef, timeProgress, duration }}
        /&gt;
      &lt;/div&gt;
    &lt;/div&gt;
  );
};
export default AudioPlayer;
</pre>
<p>保存文件，从<code>ProgressBar</code>组件获取状态，并在JSX中呈现它们:</p>
<pre class="language-javascript hljs">const ProgressBar = ({
  // ...
  timeProgress,
  duration,
}) =&gt; {
  // ...
  return (
    &lt;div className="progress"&gt;
      &lt;span className="time current"&gt;{timeProgress}&lt;/span&gt;
      {/* ... */}
      &lt;span className="time"&gt;{duration}&lt;/span&gt;
    &lt;/div&gt;
  );
};

export default ProgressBar;
</pre>
<h3>更新音频时间</h3>
<p>像当前时间一样，正如我们前面看到的，我们也可以通过<code>duration</code> audio属性访问音轨持续时间。</p>
<p>从持续时间开始，我们希望在音频元数据加载后立即获取并显示音轨持续时间。我们将在<code>&lt;audio /&gt;</code>上使用<code>onloadedmetadata</code>事件。</p>
<p>打开<code>components/DisplayTrack.js</code>文件并包含该事件:</p>
<pre class="language-javascript hljs">const DisplayTrack = ({ currentTrack, audioRef }) =&gt; {

  const onLoadedMetadata = () =&gt; {
    console.log(audioRef.current.duration);
  };

  return (
    &lt;div&gt;
      &lt;audio
        src={currentTrack.src}
        ref={audioRef}
        onLoadedMetadata={onLoadedMetadata}
      /&gt;
      {/* ... */}
    &lt;/div&gt;
  );
};
export default DisplayTrack;
</pre>
<p>如果我们保存并打开控制台，我们将看到以秒为单位的持续时间。</p>
<p>接下来，我们将使用音频持续时间更新持续时间状态变量，并确保<code>&lt;input&gt;</code>进度条的<code>max</code>属性与持续时间匹配。</p>
<p>在<code>AudioPlayer</code>组件中，让我们将<code>setDuration</code>和<code>progressBarRef</code>传递给<code>&lt;DisplayTrack /&gt;</code>:</p>
<pre class="language-javascript hljs">const AudioPlayer = () =&gt; {
  // ...

  return (
    &lt;div className="audio-player"&gt;
      &lt;div className="inner"&gt;
        &lt;DisplayTrack
          {...{ currentTrack, audioRef, setDuration, progressBarRef }}
        /&gt;
        {/* ... */}
      &lt;/div&gt;
    &lt;/div&gt;
  );
};
export default AudioPlayer;
</pre>
<p>然后，在<code>DisplayTrack</code>组件中，获取这些道具并更新<code>onloadedmetadata</code>处理程序:</p>
<pre class="language-javascript hljs">const DisplayTrack = ({
  // ...
  setDuration,
  progressBarRef,
}) =&gt; {
  const onLoadedMetadata = () =&gt; {
    const seconds = audioRef.current.duration;
    setDuration(seconds);
    progressBarRef.current.max = seconds;
  };

  return (
    // ...
  );
};
export default DisplayTrack;
</pre>
<p>现在，我们应该看到显示的音轨时长:</p>
<p><img data-attachment-id="159145" data-permalink="https://blog.logrocket.com/building-audio-player-react/attachment/img5-react-audio-player-track-duration-seconds/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2023/02/img5-React-audio-player-track-duration-seconds.png" data-orig-size="730,358" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="React-audio-player-track-duration-seconds" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2023/02/img5-React-audio-player-track-duration-seconds-300x147.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2023/02/img5-React-audio-player-track-duration-seconds.png" decoding="async" class="aligncenter size-full wp-image-159145 jetpack-lazy-image" src="../Images/fbd93d8b24d515892c1d7b3fc0d965fc.png" alt="Custom React Audio Player With Track Duration Displayed In Seconds, Indicated By Orange Arrow" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2023/02/img5-React-audio-player-track-duration-seconds.png 730w, https://blog.logrocket.com/wp-content/uploads/2023/02/img5-React-audio-player-track-duration-seconds-300x147.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2023/02/img5-React-audio-player-track-duration-seconds.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2023/02/img5-React-audio-player-track-duration-seconds.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="159145" data-permalink="https://blog.logrocket.com/building-audio-player-react/attachment/img5-react-audio-player-track-duration-seconds/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2023/02/img5-React-audio-player-track-duration-seconds.png" data-orig-size="730,358" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="React-audio-player-track-duration-seconds" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2023/02/img5-React-audio-player-track-duration-seconds-300x147.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2023/02/img5-React-audio-player-track-duration-seconds.png" decoding="async" loading="lazy" class="aligncenter size-full wp-image-159145" src="../Images/fbd93d8b24d515892c1d7b3fc0d965fc.png" alt="Custom React Audio Player With Track Duration Displayed In Seconds, Indicated By Orange Arrow" srcset="https://blog.logrocket.com/wp-content/uploads/2023/02/img5-React-audio-player-track-duration-seconds.png 730w, https://blog.logrocket.com/wp-content/uploads/2023/02/img5-React-audio-player-track-duration-seconds-300x147.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2023/02/img5-React-audio-player-track-duration-seconds.png"/></noscript>
<p>曲目持续时间目前只以秒为单位显示，但如果同时显示分钟和秒，会更容易阅读。让我们创建一个将时间格式化为所需显示的函数。</p>
<h3>格式化音频时间</h3>
<p>在<code>ProgressBar</code>组件中，在<code>return</code>语句上方添加以下代码:</p>
<pre class="language-javascript hljs">const formatTime = (time) =&gt; {
  if (time &amp;&amp; !isNaN(time)) {
    const minutes = Math.floor(time / 60);
    const formatMinutes =
      minutes &lt; 10 ? `0${minutes}` : `${minutes}`;
    const seconds = Math.floor(time % 60);
    const formatSeconds =
      seconds &lt; 10 ? `0${seconds}` : `${seconds}`;
    return `${formatMinutes}:${formatSeconds}`;
  }
  return '00:00';
};
</pre>
<p><code>formatTime</code>函数接受以秒为单位的时间参数，并将其重新格式化为分:秒。然后，我们将像这样使用JSX中的函数:</p>
<pre class="language-javascript hljs">return (
  &lt;div className="progress"&gt;
    &lt;span className="time current"&gt;{formatTime(timeProgress)}&lt;/span&gt;
    {/* ... */}
    &lt;span className="time"&gt;{formatTime(duration)}&lt;/span&gt;
  &lt;/div&gt;
);
</pre>
<p>保存文件，并查看我们想要的格式的音频时间。</p>
<h2 id="requestanimationframe-api"><code>requestAnimationFrame</code> API</h2>
<p>我们需要一种机制来告诉浏览器重新绘制每次更新，以显示当前时间和范围进度。虽然我们可能会想到使用<code>setInterval()</code>，但是当我们想要处理重复的动画时，<code>requestAnimationFrame</code>会更加高效和流畅。</p>
<p>这个API接受一个回调，每当它启动时就调用这个回调。为了触发API并告诉浏览器更新屏幕，我们可能会在音频开始播放且当前时间增加时调用它。</p>
<p>让我们打开<code>components/Controls.js</code>文件，一旦回放在<code>useEffect</code>钩子中进行，就触发这个API:</p>
<pre class="language-javascript hljs">const playAnimationRef = useRef();

const repeat = () =&gt; {
  console.log('run');

  playAnimationRef.current = requestAnimationFrame(repeat);
};

useEffect(() =&gt; {
  if (isPlaying) {
    audioRef.current.play();
    playAnimationRef.current = requestAnimationFrame(repeat);
  } else {
    audioRef.current.pause();
    cancelAnimationFrame(playAnimationRef.current);
  }
}, [isPlaying, audioRef, repeat]);
</pre>
<p><code>requestAnimationFrame</code>返回我们分配给<code>playAnimationRef.current</code>的<code>request-id</code>。ref将随时间保留返回的id。这个id允许我们在暂停播放后取消请求。</p>
<p>注意回调是如何递归调用自身来重复动画的。如果我们保存文件并单击音频播放按钮，我们将看到重复功能在浏览器控制台中重复运行。</p>
<p>我们还会看到一个终端警告，说重复函数改变了每次渲染的依赖关系。让我们通过将回调封装在<a href="https://blog.logrocket.com/react-usememo-vs-usecallback-a-pragmatic-guide/">一个</a> <code><a href="https://blog.logrocket.com/react-usememo-vs-usecallback-a-pragmatic-guide/">useCallback</a></code> <a href="https://blog.logrocket.com/react-usememo-vs-usecallback-a-pragmatic-guide/">钩子</a>中来记住回调的定义。让我们从React中导入<code>useCallback</code>:</p>
<pre class="language-javascript hljs">import {
  //...
  useCallback,
} from 'react';
</pre>
<p>然后，将<code>repeat</code>回调更新为以下内容:</p>
<pre class="language-javascript hljs">const repeat = useCallback(() =&gt; {
  console.log('run');

  playAnimationRef.current = requestAnimationFrame(repeat);
}, []);
</pre>
<p>接下来，我们将在该回调中定义以下功能:</p>
<ul>
<li>用当前音频时间更新<code>timeProgress</code>状态变量</li>
<li>确保进度条随着当前音频时间前进</li>
<li>动态更新音频进度，即设定播放部分的长度</li>
</ul>
<p>让我们将<code>progressBarRef</code>、<code>duration</code>状态变量和<code>setTimeProgress</code>从<code>AudioPlayer</code>组件传递到<code>Controls</code>组件:</p>
<pre class="language-javascript hljs">const AudioPlayer = () =&gt; {
  // ...
  return (
    &lt;div className="audio-player"&gt;
      &lt;div className="inner"&gt;
        {/* ... */}
        &lt;Controls
          {...{ audioRef, progressBarRef, duration, setTimeProgress }}
        /&gt;
        {/* ... */}
      &lt;/div&gt;
    &lt;/div&gt;
  );
};
export default AudioPlayer;
</pre>
<p>接下来，让我们访问<code>Controls</code>组件中的道具并更新<code>repeat</code>回调，这样我们就有了以下内容:</p>
<pre class="language-javascript hljs">const Controls = ({
  audioRef,
  progressBarRef,
  duration,
  setTimeProgress,
}) =&gt; {
  // ...

  const repeat = useCallback(() =&gt; {
    const currentTime = audioRef.current.currentTime;
    setTimeProgress(currentTime);
    progressBarRef.current.value = currentTime;
    progressBarRef.current.style.setProperty(
      '--range-progress',
      `${(progressBarRef.current.value / duration) * 100}%`
    );

    playAnimationRef.current = requestAnimationFrame(repeat);
  }, [audioRef, duration, progressBarRef, setTimeProgress]);

  // ...
  return (
    // ...
  );
};

export default Controls;
</pre>
<p>重点是<code>repeat</code>回调。通过<code>setTimeProgress</code>更新功能，我们可以更新音频经过时间。我们还将当前时间分配给距离值，以便它继续前进。</p>
<p>关于播放部分的长度，我们抓取了我们在CSS文件中声明的CSS变量并动态更新它。</p>
<p>如果我们保存文件并播放音轨，我们应该会看到以下行为:</p>
<p><img data-attachment-id="159147" data-permalink="https://blog.logrocket.com/building-audio-player-react/attachment/img6-react-audio-player-changing-progress-bar/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2023/02/img6-React-audio-player-changing-progress-bar.gif" data-orig-size="730,372" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="React-audio-player-changing-progress-bar" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2023/02/img6-React-audio-player-changing-progress-bar-300x153.gif" data-large-file="https://blog.logrocket.com/wp-content/uploads/2023/02/img6-React-audio-player-changing-progress-bar.gif" decoding="async" class="aligncenter size-full wp-image-159147 jetpack-lazy-image" src="../Images/ee2128b4edf800d792f379eb91a26275.png" alt="User Shown Clicking Play On Audio Player And Moving Progress Bar Forward And Backward" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2023/02/img6-React-audio-player-changing-progress-bar.gif?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2023/02/img6-React-audio-player-changing-progress-bar.gif"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="159147" data-permalink="https://blog.logrocket.com/building-audio-player-react/attachment/img6-react-audio-player-changing-progress-bar/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2023/02/img6-React-audio-player-changing-progress-bar.gif" data-orig-size="730,372" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="React-audio-player-changing-progress-bar" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2023/02/img6-React-audio-player-changing-progress-bar-300x153.gif" data-large-file="https://blog.logrocket.com/wp-content/uploads/2023/02/img6-React-audio-player-changing-progress-bar.gif" decoding="async" loading="lazy" class="aligncenter size-full wp-image-159147" src="../Images/ee2128b4edf800d792f379eb91a26275.png" alt="User Shown Clicking Play On Audio Player And Moving Progress Bar Forward And Backward" data-original-src="https://blog.logrocket.com/wp-content/uploads/2023/02/img6-React-audio-player-changing-progress-bar.gif"/></noscript>
<p>请注意，如果我们暂停音频，改变进度条将不会反映动画，直到我们再次按下播放。这是因为我们在暂停条件下调用了<code>cancelAnimationFrame</code>来取消它。</p>
<p>我们可以移除<code>cancelAnimationFrame</code>并将<code>requestAnimationFrame</code>移出状态，因此我们有以下内容:</p>
<pre class="language-javascript hljs">useEffect(() =&gt; {
  if (isPlaying) {
    audioRef.current.play();
  } else {
    audioRef.current.pause();
  }
  playAnimationRef.current = requestAnimationFrame(repeat);
}, [isPlaying, audioRef, repeat]);
</pre>
<p>该项目现在应该如预期的那样工作。</p>
<h2 id="navigating-tracks-react-music-player">在React音乐播放器中导航曲目</h2>
<p>让我们使用下一个、上一个、向前跳和向后跳按钮。我们将从给它们附加<code>onClick</code>事件开始。在<code>components/Controls.js</code>文件中，更新JSX中的<code>buttons</code>以包含<code>onClick</code>事件:</p>
<pre class="language-javascript hljs">return (
  &lt;div className="controls-wrapper"&gt;
    &lt;div className="controls"&gt;
      &lt;button onClick={handlePrevious}&gt;
        &lt;IoPlaySkipBackSharp /&gt;
      &lt;/button&gt;
      &lt;button onClick={skipBackward}&gt;
        &lt;IoPlayBackSharp /&gt;
      &lt;/button&gt;

      &lt;button onClick={togglePlayPause}&gt;
        {isPlaying ? &lt;IoPauseSharp /&gt; : &lt;IoPlaySharp /&gt;}
      &lt;/button&gt;
      &lt;button onClick={skipForward}&gt;
        &lt;IoPlayForwardSharp /&gt;
      &lt;/button&gt;
      &lt;button onClick={handleNext}&gt;
        &lt;IoPlaySkipForwardSharp /&gt;
      &lt;/button&gt;
    &lt;/div&gt;
  &lt;/div&gt;
);
</pre>
<p>然后，在<code>return</code>语句之上，添加它们各自的处理函数:</p>
<pre class="language-javascript hljs">const skipForward = () =&gt; {};

const skipBackward = () =&gt; {};

const handlePrevious = () =&gt; {};

const handleNext = () =&gt; {};
</pre>
<h3>处理下一首曲目</h3>
<p>为了处理下一首和上一首曲目，我们需要知道当前播放曲目的索引，并能够访问播放列表。在<code>components/AudioPlayer.js</code>文件中，让我们为轨道索引初始化一个状态:</p>
<pre class="language-javascript hljs">const [trackIndex, setTrackIndex] = useState(0);
</pre>
<p><code>currentTrack</code>状态当前应该是这样的:</p>
<pre class="language-javascript hljs">const [currentTrack, setCurrentTrack] = useState(tracks[0]);
</pre>
<p>让我们把它改为:</p>
<pre class="language-javascript hljs">const [currentTrack, setCurrentTrack] = useState(tracks[trackIndex]);
</pre>
<p>接下来，让我们将<code>tracks</code>、<code>trackIndex</code>、<code>setTrackIndex</code>和<code>setCurrentTrack</code>传递给<code>&lt;Controls /&gt;</code>组件:</p>
<pre class="language-javascript hljs">&lt;Controls
  {...{
    // ...
    tracks,
    trackIndex,
    setTrackIndex,
    setCurrentTrack,
  }}
/&gt;
</pre>
<p>我们将从<code>Controls</code>组件中访问它们作为道具，然后更新<code>handleNext</code>处理程序，因此我们有如下内容:</p>
<pre class="language-javascript hljs">const handleNext = () =&gt; {
  if (trackIndex &gt;= tracks.length - 1) {
    setTrackIndex(0);
    setCurrentTrack(tracks[0]);
  } else {
    setTrackIndex((prev) =&gt; prev + 1);
    setCurrentTrack(tracks[trackIndex + 1]);
  }
};
</pre>
<p>使用上面的代码，每当我们点击“下一个”按钮时，我们检查我们是否在最后一个索引中——即最后一个曲目。然后，我们将索引设置为<code>0</code>——即第一首曲目——并将曲目重置为播放列表中的第一项。否则，我们将索引和轨道设置为播放列表中的下一个。</p>
<p>保存文件，并确保“下一步”按钮按预期工作。</p>
<h3>处理上一首曲目</h3>
<p>类似于“下一个轨道”处理程序，让我们更新<code>handlePrevious</code>处理程序，这样我们就有了以下内容:</p>
<pre class="language-javascript hljs">const handlePrevious = () =&gt; {
  if (trackIndex === 0) {
    let lastTrackIndex = tracks.length - 1;
    setTrackIndex(lastTrackIndex);
    setCurrentTrack(tracks[lastTrackIndex]);
  } else {
    setTrackIndex((prev) =&gt; prev - 1);
    setCurrentTrack(tracks[trackIndex - 1]);
  }
};
</pre>
<p>如果当前曲目索引为<code>0</code>，我们将索引和曲目重置为播放列表中的最后一项。否则，我们将索引和轨道设置为播放列表中的前一个。</p>
<h3>向前和向后跳跃</h3>
<p>在用于向前和向后跳转的相应处理程序中，我们将从音频ref中访问当前时间，并分配一个以秒为单位的数值:</p>
<pre class="language-javascript hljs">const skipForward = () =&gt; {
  audioRef.current.currentTime += 15;
};

const skipBackward = () =&gt; {
  audioRef.current.currentTime -= 15;
};
</pre>
<p>我们分配了15秒的跳跃时间，如上图所示。保存并确保控制按钮按预期工作。</p>
<h2 id="adding-volume-slider">添加音量滑块</h2>
<p>正如我们前面提到的，我们将使用HTML input range元素通过滑块来控制音量。在<code>Controls</code>组件中，让我们在控制容器之后添加体积容器元素:</p>
<pre class="language-javascript hljs">return (
  &lt;div className="controls-wrapper"&gt;
    &lt;div className="controls"&gt;{/* ... */}&lt;/div&gt;
    &lt;div className="volume"&gt;
      &lt;button&gt;icons&lt;/button&gt;
      &lt;input type="range" min={0} max={100} /&gt;
    &lt;/div&gt;
  &lt;/div&gt;
);
</pre>
<p>我们还提到，我们将使这个输入滑块成为一个受控输入。</p>
<p>让我们从初始化<code>Controls</code>组件中的状态开始:</p>
<pre class="language-javascript hljs">const [volume, setVolume] = useState(60);
</pre>
<p>然后，更新输入元素以包含一个<code>value</code>和<code>onChange</code>属性:</p>
<pre class="language-javascript hljs">&lt;input
  type="range"
  min={0}
  max={100}
  value={volume}
  onChange={(e) =&gt; setVolume(e.target.value)}
/&gt;
</pre>
<p>接下来，我们将把<code>volume</code>状态变量的返回值附加到音频的<code>volume</code>属性。让我们通过在<code>Controls</code>组件内的<code>return</code>语句上方添加以下代码来实现这一点:</p>
<pre class="language-javascript hljs">useEffect(() =&gt; {
  if (audioRef) {
    audioRef.current.volume = volume / 100;
  }
}, [volume, audioRef]);
</pre>
<p>在这个组件中，我们可以访问音频参考。因为音频的音量属性的最大值是1，所以我们将我们的<code>volume</code>状态——其最大值是100——除以100，这样它们可以同步。</p>
<p>保存文件，并确保您可以增加和减少音量。</p>
<h3>设定体积进度的样式</h3>
<p>让我们利用<code>volume</code>状态变量来动态地设计卷进度。在volume input元素上，让我们添加一个<code>style</code>属性来样式化进度:</p>
<pre class="language-javascript hljs">&lt;input
  // ...
  style={{
    background: `linear-gradient(to right, #f50 ${volume}%, #ccc ${volume}%)`,
  }}
/&gt;
</pre>
<p>上面的代码使用CSS线性渐变来设置音量进度条的样式。随着<code>volume</code>状态的增加，进度条的橙色背景色也会匹配，直到它占据进度条的剩余长度。记得保存文件，并确保它的工作！</p>
<h3>设置音量图标</h3>
<p>在<code>Controls</code>组件中，让我们首先初始化一个状态，以便在音量静音时进行处理:</p>
<pre class="language-javascript hljs">const [muteVolume, setMuteVolume] = useState(false);
</pre>
<p>默认情况下，我们给它一个布尔值<code>false</code>。接下来，让我们在volume容器元素中定位下面的<code>button</code>:</p>
<pre class="language-javascript hljs">&lt;button&gt;icons&lt;/button&gt;
</pre>
<p>用以下代码替换它:</p>
<pre class="language-javascript hljs">&lt;button onClick={() =&gt; setMuteVolume((prev) =&gt; !prev)}&gt;
  {muteVolume || volume &lt; 5 ? (
    &lt;IoMdVolumeOff /&gt;
  ) : volume &lt; 40 ? (
    &lt;IoMdVolumeLow /&gt;
  ) : (
    &lt;IoMdVolumeHigh /&gt;
  )}
&lt;/button&gt;
</pre>
<p>在上面的代码中，我们附加了一个切换<code>muteVolume</code>状态的<code>onClick</code>事件。我们还使用了基于<code>volume</code>状态变量的值来动态渲染图标的条件。</p>
<p>在保存文件之前，让我们在文件顶部导入以下<code>react-icons</code>组件:</p>
<pre class="language-javascript hljs">import {
  IoMdVolumeHigh,
  IoMdVolumeOff,
  IoMdVolumeLow,
} from 'react-icons/io';
</pre>
<p>最后，在<code>useEffect</code>钩子中，让我们将布尔<code>muteVolume</code>状态分配给音频的<code>muted</code>属性:</p>
<pre class="language-javascript hljs">useEffect(() =&gt; {
  if (audioRef) {
    audioRef.current.volume = volume / 100;
    audioRef.current.muted = muteVolume;
  }
}, [volume, audioRef, muteVolume]);
</pre>
<p>保存并测试卷功能。应该能按预期工作！</p>
<h2 id="triggering-onended-event">触发<code>onEnded</code>事件</h2>
<p>当当前曲目到达结尾时，我们可以在<code>&lt;audio&gt;</code>元素上触发<code>onended</code>事件并动作。对于这个项目，我们将告诉音频播放器开始播放列表中的下一首曲目。</p>
<p>因为我们在<code>handleNext</code>处理程序中已经有了功能，让我们将处理程序从<code>components/Controls.js</code>文件移到<code>AudioPlayer</code>父组件中，这样我们也可以在<code>DisplayTrack</code>组件中访问它。</p>
<p>然后将其传递给<code>&lt;DisplayTrack /&gt;</code>和<code>&lt;Controls /&gt;</code>组件:</p>
<pre class="language-javascript hljs">return (
  &lt;div className="audio-player"&gt;
    &lt;div className="inner"&gt;
      &lt;DisplayTrack
        {...{
          // ...
          handleNext,
        }}
      /&gt;
      &lt;Controls
        {...{
          // ...
          handleNext,
        }}
      /&gt;
      {/* ... */}
    &lt;/div&gt;
  &lt;/div&gt;
);
</pre>
<p>在<code>DisplayTrack</code>组件中，将<code>handleNext</code>处理程序作为道具访问，并将其分配给<code>&lt;audio /&gt;</code>元素上的<code>onEnded</code>事件:</p>
<pre class="language-javascript hljs">&lt;audio
  // ...
  onEnded={handleNext}
/&gt;
</pre>
<p>保存文件并进入<code>Controls</code>组件以访问作为道具的<code>handleNext</code>处理程序。请记住，我们已经将它附加到文件中的next按钮图标。</p>
<p>保存所有文件并测试您的项目。它应该按预期工作！</p>
<h2 id="conclusion">结论</h2>
<p>我很高兴你在这里！创建音频播放器可能是一项单调乏味的任务，尤其是如果我们的目标是包含主要功能的话。</p>
<p>在本指南中，我们学习了如何创建React音频播放器，提供必要的功能，包括播放、暂停、音量、下一个、上一个和进度控制。我们还确保了音频播放器在不同浏览器上看起来一致。</p>
<p>我希望你喜欢阅读本指南。请在评论区告诉我你的想法，如果你觉得有用，记得在网上分享这个指南。</p>
<p>参考<a href="https://github.com/Ibaslogic/react-audio-player">最终源代码</a>和<a href="https://github.com/Ibaslogic/react-audio-player">现场项目</a>。</p><div class="code-block code-block-17">
<div class="blog-plug inline-plug react-plug" vwo-el-id="26283398190">
<h2 vwo-el-id="41600691720">使用LogRocket消除传统反应错误报告的噪音</h2>
<a href="https://lp.logrocket.com/blg/react-signup-issue-free" target="_blank" vwo-el-id="19356441070">LogRocket
</a><p>是一款React analytics解决方案，可保护您免受数百个误报错误警报的影响，只针对少数真正重要的项目。LogRocket告诉您React应用程序中实际影响用户的最具影响力的bug和UX问题。</p><a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="19356441380">
<img class="first-react-image alignnone size-full wp-image-46 jetpack-lazy-image jetpack-lazy-image--handled" src="../Images/f300c244a1a1cf916df8b4cb02bec6c6.png" vwo-el-id="18272717540" data-lazy-loaded="1" data-original-src="https://files.readme.io/27c94e7-Image_2017-06-05_at_9.46.04_PM.png"/>
</a>
<a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="19356441690">
<img class="second-react-image alignnone size-full wp-image-46 jetpack-lazy-image jetpack-lazy-image--handled" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" vwo-el-id="30720362350" data-lazy-loaded="1" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/>
</a>
<a href="https://lp.logrocket.com/blg/react-signup-issue-free" target="_blank" rel="noopener noreferrer" vwo-el-id="35866400580">LogRocket
</a><p>自动聚合客户端错误、反应错误边界、还原状态、缓慢的组件加载时间、JS异常、前端性能指标和用户交互。然后，LogRocket使用机器学习来通知您影响大多数用户的最具影响力的问题，并提供您修复它所需的上下文。</p><p vwo-el-id="28675661060">关注重要的React bug—<a class="signup" href="https://lp.logrocket.com/blg/react-signup-issue-free" target="_blank" rel="noopener noreferrer" vwo-el-id="40093418840">今天就试试LogRocket】。</a></p>
</div></div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
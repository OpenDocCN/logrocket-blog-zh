<html>
<head>
<title>Using RxJS Observables to transform data in TypeScript - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>使用 RxJS 观察值转换 TypeScript - LogRocket 博客中的数据</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/using-observables-transform-data-typescript/#0001-01-01">https://blog.logrocket.com/using-observables-transform-data-typescript/#0001-01-01</a></blockquote><div><article class="article-post">
<h2>介绍</h2>
<p>事件处理是构建 TypeScript 应用程序时的常见实现之一。</p>
<p>注册一个事件以及在事件被触发时执行一些动作需要一个可观察的模式，它提供了一个到事件流的单向流，使得调试和错误处理事件流变得容易得多。</p>
<p>在本文中，我们将探索可观察对象，它们如何用于处理事件驱动的数据，以及错误和异步数据。</p>
<ol>
<li>   <ol>
<li><a href="#what-are-rxjs-observables">什么是 RxJS 可观测量？</a></li>
<li><a href="#observable-operators">可观察算子</a></li>
<li><a href="#transforming-arrays-observable">用可观测值变换数组</a></li>
<li><a href="#combining-multiple-operators-event-stream-information">组合多个操作符进行事件流转换</a></li>
<li><a href="#handling-errors-observables">处理可观察到的错误</a></li>
</ol>
</li>
</ol>
<h2 id="what-are-rxjs-observables">什么是 RxJS 可观测量？</h2>
<p>JavaScript 的一个有趣但有时令人费解的部分是处理事件。</p>
<p>考虑一个像脸书这样的实时聊天应用程序，它在特定的时间范围内有多个事件发生。用户可以在他的新闻提要上键入一些文本，同时接收来自其他朋友的一些通知和消息，没有特定的顺序。现在，处理这些事件是应用程序的责任。这就是可观性的来源。</p>
<p>一个<a href="https://blog.logrocket.com/understanding-rxjs-observables/" target="_blank" rel="noopener">可观察的</a>是多个输入值的集合，这些输入值使用数组方法进行处理，比如<code>map</code>、<code>reduce</code>、<code>filter</code>等等。在处理异步操作时，例如发出 HTTP 请求、用户输入事件等，它非常方便。</p>
<p>可观察模式是一种设计模式，用于注册事件，以及在事件被触发时实现流程。专门从事事件处理的最强大和最流行的 JavaScript 库之一是 JavaScript 库的反应扩展，也称为 RxJS。</p>
<p>为了开始，我们需要确保已经安装了 RxJS 库。因此，我们使用以下命令安装该库:</p>
<pre class="language-bash hljs">npm install rxjs
</pre>
<p>这个库已经有了 TypeScript 需要的所有声明文件，所以没有必要单独安装它们。</p>
<p>为了创建一个可观察对象，我们需要来自 RxJS 的<code>Observable</code>类型和<code>of</code>方法，如下所示:</p>
<pre>import { of, Observable } from "rxjs"; 
const emitter : Observable&lt;string&gt; = of("Sam", "Ray", "Thomas");
</pre>
<p>在上面的代码片段中，我们从 RxJS 库中导入了<code>of</code>函数和<code>Observable</code>类型，然后从字符串<code>"Sam"</code>、<code>"Ray"</code>和<code>"Thomas"</code>中创建了一个<code>Observable</code>。</p>
<p>接下来，我们将订阅一个可观察值，如下所示:</p>
<pre>emitter.subscribe((value: string) =&gt; {
  console.log(`Name: ${value}`)
})
</pre>
<p>在上面的代码片段中，我们通过对<code>emitter</code>变量调用<code>subscribe</code>方法注册了一个观察者。由于<code>emitter</code>变量是可观察的类型，我们可以自动访问<code>subscribe</code>方法。<code>subscribe</code>方法接收一个函数作为参数，这个函数将为观察对象发出的每个值调用一次。</p>
<p>上述代码将输出以下可观察到的流:</p>
<pre>Name: Sam
Name: Ray
Name: Thomas
</pre>
<h2 id="observable-operators">可观察算子</h2>
<p>可管道操作符和创建操作符是 RxJS 中的两种操作符。</p>
<p>可管道操作符是将一个可观察值作为输入并返回另一个可观察值的方法。可以使用语法<code>observableInstance.pipe(operator())</code>将它们传送到 Observables。它包括<code><a href="https://rxjs.dev/api/operators/filter" target="_blank" rel="noopener">filter(...)</a></code>和<code><a href="https://rxjs.dev/api/operators/mergeMap" target="_blank" rel="noopener">mergeMap(...)</a></code>方法。</p>
<p>创建操作符是在被调用时创建新的可观察对象的操作符。</p>
<p>创建运算符包括以下内容:</p>

<p>您可以参考<a href="https://rxjs.dev/guide/operators" target="_blank" rel="noopener"> RxJS 官方文档</a>以获得完整的操作员列表。</p>
<h2 id="transforming-arrays-observable">用可观测值变换数组</h2>
<p>RxJS <code>from</code>方法允许对数组中的数据进行转换。它接收一个数组作为输入，并将数组中的每个数据转换为可观察数据。</p>
<p>让我们考虑下面的代码片段:</p>
<pre>const transformArray: Observable&lt;number&gt; = from([1, 2, 3, 4]);
transformArray.subscribe((value: number) =&gt; {
  console.log(`value: ${value}`);
});
</pre>
<p>上面的代码片段使用<code>from</code>方法将数组中的值转换为可观察值，然后对<code>transformArray</code>变量调用<code>subscribe</code>方法。<code>subscribe</code>方法接受一个函数，该函数为可观察对象发出的每个值执行。</p>
<h2 id="combining-multiple-operators-event-stream-information">组合多个操作符进行事件流转换</h2>
<p>RxJS 为我们提供了<code>pipe</code>方法，该方法允许将多个操作符方法组合起来进行事件流的复杂转换。</p>
<p>让我们考虑下面的代码:</p>
<pre>const emitter = of(4, 9, 16, 25)
const mapValue = emitter.pipe(
  map((value: number) =&gt; {
    return Math.sqrt(value)
  }),
  map((value: number) =&gt; {
    return `square root: ${value}`
  })
)
mapValue.subscribe((value: string) =&gt; {
  console.log(`string value emitted ${value}`)
})
</pre>
<p>这里，RxJS <code>of</code>方法用于从数字<code>4</code>、<code>9</code>、<code>16</code>和<code>25</code>中创建一个可观察值。<code>pipe</code>方法接受两个<code>map</code>方法。第一个<code>map</code>方法返回输入值的平方根，第二个<code>map</code>方法将第一个<code>map</code>方法的输出转换为字符串。</p>
<p>最后，对发出的每个可观察对象调用<code>subscribe</code>方法。</p>
<p>运行上面的代码将输出如下:</p>
<pre>string value emitted square root: 2 
string value emitted square root: 3 
string value emitted square root: 4
string value emitted square root: 5
</pre>
<h2 id="handling-errors-observables">处理可观察到的错误</h2>
<p>处理可观察流中的异常需要一个结构良好的机制来捕捉这些异常。</p><div class="code-block code-block-54">
<hr/>
<h3>更多来自 LogRocket 的精彩文章:</h3>

<hr/></div>
<p>让我们考虑下面的代码片段:</p>
<pre>interface IName {
  value: string;
}
interface IObj {
  name?: IName;
}
const emitObj: Observable&lt;IObj&gt; = of(
  { name: { value: "Bob" } },
  {},
  { name: { value: "Sam" } }
);
</pre>
<p>在上面的代码片段中，我们用类型为<code>string</code>的属性<code>value</code>创建了<code>IName</code>。此外，我们创建了具有可选属性<code>IName</code>的<code>IObj</code>。然后我们创建了<code>emitObj</code>可观察对象，它发出三个值。</p>
<p>现在让我们考虑以下可观察的流:</p>
<pre>const returnName = emitObj.pipe(
    map((value: IObj) =&gt; {
        return value.name!.value;
    })
);
returnName.subscribe((value: string) =&gt; {
    console.log(`name: ${value} `)
});
</pre>
<p>在上面的代码片段中，我们创建了一个可观察的流<code>returnName</code>，它返回输入流值的<code>name.value</code>属性。然后，我们订阅这个流，并将收到的值记录到控制台。</p>
<p>当我们运行这个代码片段时，我们将得到以下输出:</p>
<pre>name: Bob
TypeError: Cannot read property 'value' of undefined
</pre>
<p>发生这个错误是因为在我们的可观察流中发出的第二个值没有 name 属性，导致一个未定义的值。</p>
<p>为了修复这个错误，我们可以在我们的可观察流中为<code>subscribe</code>函数创建一个错误处理程序。</p>
<p>让我们考虑以下情况:</p>
<pre>returnName.subscribe(
  // called for each observable value
  (value: string| null) =&gt; {
    console.log(`name: ${value} `);
  },
  // called if an error occurs
  (error: unknown) =&gt; {
    console.log(`error : ${error}`);
  },
  // called when execution is done
  () =&gt; {
    console.log(`done`);
  }
);
</pre>
<p>这里，我们为<code>subscribe</code>方法提供了三个函数作为参数，第一个函数为可观察流发出的每个值调用，第二个函数在错误发生时调用，最后一个函数在<code>subscribe</code>方法执行完成时调用。</p>
<p>当我们运行这个代码片段时，我们将得到以下输出:</p>
<pre>name: Bob
TypeError: Cannot read property 'value' of undefined
</pre>
<p>这里发生的是由可观察流发出的第一个值由提供给<code>subscribe</code>方法的第一个函数处理。由可观察流发出的第二个值导致一个错误，这个错误被提供给<code>subscribe</code>方法的错误函数捕获。最后一个函数没有被调用，因为在可观察的流中出现了错误。</p>
<h3><code>catchError</code></h3>
<p>处理可观察错误的另一种方法是在可观察流本身中使用<code>catchError</code>操作符，这样我们就可以尽早发现这些错误。</p>
<p>让我们考虑下面的代码片段:</p>
<pre>const returnName = emitObj.pipe(
    map((value: IObj) =&gt; {
        return value!.name!.value;
    }),
    catchError((error: unknown) =&gt; {
        console.log(`stream caught : ${error}`);
        return of(null);
    })
);
</pre>
<p>这里，我们向可观察的流添加了一个<code>catchError</code>操作符。在这个函数中，我们将错误消息记录到控制台，然后返回一个可观察到的值<code>null</code>。通过这种实现，即使在可观察对象中出现错误，最后一个函数也会被触发。</p>
<p>当我们运行这个代码片段时，我们将得到以下输出:</p>
<pre>Name: Bob
stream caught : TypeError: Cannot read property 'value' of undefined
received null
done
</pre>
<p>这里发生的事情是，<code>map</code>方法为可观察流的第二个值生成一个错误，之后我们的<code>catchError</code>函数被调用，并出现以下错误:“无法读取 undefined 的属性‘value’。”同样，最后一个方法被触发。</p>
<p>一旦一个可观察的流中出现错误，该流将停止发出值。这就是为什么<code>emitObj</code>可观察流不发出它最后一个参数的值。</p>
<h2>结论</h2>
<p>在本文中，我们探索了使用可观察流的数据转换以及如何实现它们。此外，我们还讨论了使用可观察对象的错误处理，并提供了在处理可观察流时实现错误处理程序的策略。为了避免内存泄漏和意外结果，请确保取消订阅您手动订阅的任何订阅。</p>
<p>希望这篇文章对你有所帮助。你也可以查看官方的 RxJS 文档,深入了解 RxJS 可观察模块。另外，我推荐 Brian Troncone 的<a href="https://www.learnrxjs.io" target="_blank" rel="noopener"> learnrxjs.io </a>对 rxjs 概念进行更直观的解释。</p><div class="code-block code-block-21">
<div class="blog-plug inline-plug typescript-plug"><h2><a class="signup" href="https://lp.logrocket.com/blg/typescript-signup" target="_blank" rel="noopener noreferrer"> LogRocket </a>:全面了解您的网络和移动应用</h2>
<a href="https://lp.logrocket.com/blg/typescript-signup" class="signup" target="_blank" rel="noopener noreferrer"><img class="alignnone size-full wp-image-46 jetpack-lazy-image" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/><noscript><img data-lazy-fallback="1" class="alignnone size-full wp-image-46" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/></noscript></a>
<p>LogRocket 是一个前端应用程序监控解决方案，可以让您回放问题，就像问题发生在您自己的浏览器中一样。LogRocket 不需要猜测错误发生的原因，也不需要向用户询问截图和日志转储，而是让您重放会话以快速了解哪里出错了。它可以与任何应用程序完美配合，不管是什么框架，并且有插件可以记录来自 Redux、Vuex 和@ngrx/store 的额外上下文。</p>
<p>除了记录 Redux 操作和状态，LogRocket 还记录控制台日志、JavaScript 错误、堆栈跟踪、带有头+正文的网络请求/响应、浏览器元数据和自定义日志。它还使用 DOM 来记录页面上的 HTML 和 CSS，甚至为最复杂的单页面和移动应用程序重新创建像素级完美视频。</p>
<a class="signup" href="https://lp.logrocket.com/blg/typescript-signup" target="_blank" rel="noopener noreferrer">Try it for free</a><p>.</p></div>
</div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
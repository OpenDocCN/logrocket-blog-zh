<html>
<head>
<title>Configuring any GraphQL server with Envelop - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>用信封日志博客配置任何 GraphQL 服务器</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/configuring-any-graphql-server-envelop/#0001-01-01">https://blog.logrocket.com/configuring-any-graphql-server-envelop/#0001-01-01</a></blockquote><div><article class="article-post">
<p><a href="https://www.envelop.dev/" target="_blank" rel="noopener">envelope</a>是一个轻量级的 GraphQL 插件库，允许您向 GraphQL 执行层添加定制的特性，而不管您使用的是什么 GraphQL 服务器。</p>
<p>像<a href="https://apollographql.com/" target="_blank" rel="noopener"> Apollo GraphQL </a>和<a href="https://www.graphile.org/" target="_blank" rel="noopener"> Graphite </a>这样的 GraphQL 服务器已经有了运行良好的特定平台插件系统。不利的一面是，如果您出于任何原因选择迁移到 GraphQL 的不同实现，您将需要修改插件以与该特定实现一起工作。</p>
<h2>什么是信封？</h2>
<p>这就是信封的由来。Envelop 不是 GraphQL 服务器——它是 GraphQL 上的一个包装器，允许开发人员编写平台无关的插件。这意味着你只需要写一次你的插件就可以和 Envelop 一起工作并集成到任何 GraphQL 服务器中。</p>
<p>为了了解如何实现这一点，我们将把 Envelop 与<a href="https://www.fastify.io/" target="_blank" rel="noopener"> Fastify </a>和 Apollo GraphQL 集成在一起。</p>
<p>以下是您在本教程中需要遵循的内容:</p>

<h2>设置节点应用程序</h2>
<p>运行以下命令来安装我们需要的所有依赖项:</p>
<pre class="language-bash hljs">npm install  @envelop/core fastify graphql graphql-helix --save
</pre>
<p>接下来，我们需要创建一个服务器。创建一个<code>server.js</code>文件并添加以下代码:</p>
<pre>const { envelop, useSchema, useLogger } = require('@envelop/core');
const fastify = require('fastify');
const { processRequest, getGraphQLParameters } = require('graphql-helix');
</pre>
<p>在上面的代码中，我们导入了<code>envelop</code>及其插件。如果你使用过 React 钩子，你会对插件的命名约定很熟悉。信封插件以前缀和关键字<code>use</code>命名。在这个例子中，我们将添加<code>useSchema</code>和<code>useLogger</code>插件。</p>
<p>首先，我们将使用<a href="https://github.com/contrawork/graphql-helix" target="_blank" rel="noopener"> GraphQL Helix </a>来构建我们的 GraphQL 服务器，以捕获和处理对<a href="https://github.com/fastify/fastify" target="_blank" rel="noopener"> Fastify </a>服务器的请求。</p>
<h2>创建 GraphQL 模式</h2>
<p>接下来，我们将创建一个<code>schema.js</code>文件，在这里我们将定义我们的模式类型、突变和解析器，这样我们就可以创建一个歌曲库。该文件应包含以下内容:</p>
<pre>const {
 GraphQLObjectType,
 GraphQLSchema,
 GraphQLString,
} = require("graphql");
const schema = new GraphQLSchema({
 mutation: new GraphQLObjectType({
   name: "Mutation",
   fields: () =&gt; ({
     echo: {
       args: {
         text: {
           type: GraphQLString,
         },
       },
       type: GraphQLString,
       resolve: (_root, args) =&gt; {
         return args.text;
       },
     },
   }),
 }),
 query: new GraphQLObjectType({
   name: "Query",
   fields: () =&gt; ({
     song: {
       type: new GraphQLObjectType({
         name: "Song",
         fields: () =&gt; ({
           firstVerse: {
             type: GraphQLString,
             resolve: () =&gt; "Singing me a song is lovely.",
           },
           secondVerse: {
             type: GraphQLString,
             resolve: () =&gt;
               new Promise((resolve) =&gt;
                 setTimeout(
                   () =&gt; resolve("You never wanted to sing with me?"),
                   5000
                 )
               ),
           },
         }),
       }),
       resolve: () =&gt; ({}),
     },
   }),
 }),
});

module.exports = schema
</pre>
<h2>创建 Fastify 服务器</h2>
<p>我们将导入刚刚创建的模式，并在<code>server.js</code>中的螺旋库导入之后使用它，如下所示:</p>
<pre>const { envelop, useSchema, useLogger } = require('@envelop/core');
const fastify = require('fastify');
const { processRequest, getGraphQLParameters } = require('graphql-helix');
const mySchema = require("./mySchema"); //here
</pre>
<h2>将信封与我们的模式集成</h2>
<p>无论您使用什么样的 GraphQL 服务器和集成过程，下一步都相当简单。在我们的例子中，我们使用了两个插件，<code><a href="https://github.com/dotansimha/envelop/blob/main/packages/core/src/plugins/use-schema.ts" target="_blank" rel="noopener">useSchema()</a></code>和<code><a href="https://github.com/dotansimha/envelop/blob/main/packages/core/src/plugins/use-logger.ts" target="_blank" rel="noopener">useLogger()</a></code>。您可以使用任意多的插件——您只需要将插件添加到<code>plugins</code>数组中，就像这样:</p>
<pre>const getEnveloped = envelop({
 plugins: [useSchema(mySchema), useLogger()],
});
</pre>
<p>这是集成的一个关键部分，因为它为您提供了一个高层次的抽象，并允许您解耦所需的组件以供使用。</p>
<p>接下来，我们需要创建一个 Fastify 应用程序并集成 Envelop。</p>
<pre>const fastifyApp = fastify();
const port = 3000;

fastifyApp.route({
 method: ['POST'],
 url: '/graphql',
 async handler(req, res) {
   const { parse, validate, contextFactory, execute, schema } = getEnveloped({
     req,
   });
   const request = {
     body: req.body,
     headers: req.headers,
     method: req.method,
     query: req.query,
   };
   const { operationName, query, variables } = getGraphQLParameters(request);
   const result = await processRequest({
     operationName,
     query,
     variables,
     request,
     schema,
     parse,
     validate,
     execute,
     contextFactory,
   });
   if (result.type === 'RESPONSE') {
     res.status(result.status);
     res.send(result.payload);
   } else {
     res.send({ errors: [{ message: 'Not Supported' }] });
   }
 },
});
fastifyApp.listen(port, () =&gt; {
 console.log(`GraphQL server is running on port:`, port);
});
</pre>
<p>让我们来分解这个代码。我们首先设置服务器并配置 GraphQL 端点。然后我们从信封实例中导入<code>parse</code>、<code>contextFactory</code>、<code>execute</code>和<code>schema</code>，如下图所示:</p>
<pre>const { parse, validate, contextFactory, execute, schema } = getEnveloped({req});
</pre>
<p>这些是来自 Envelop 的一些参数，我们将传递给 Helix 来处理我们的 GraphQL 请求。</p>
<pre> const result = await processRequest({
     operationName,
     query,
     variables,
     request,
     schema,
     parse,
     validate,
     execute,
     contextFactory,
   });
</pre>
<p>现在我们可以用<code>node server.js</code>命令运行 API 来启动节点服务器。</p>
<h2>用 Postman 测试应用程序</h2>
<p>我们应该使用<a href="https://www.postman.com/" target="_blank" rel="noopener"> Postman </a>测试我们的应用程序。</p>
<figure id="attachment_64463" aria-describedby="caption-attachment-64463" class="wp-caption aligncenter"><img data-attachment-id="64463" data-permalink="https://blog.logrocket.com/configuring-any-graphql-server-envelop/graphql-envelop-postman-app-test/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2021/08/graphql-envelop-postman-app-test.png" data-orig-size="730,420" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Graphql envelop postman app test" data-image-description="" data-image-caption="&lt;p&gt;Screenshot from Postman GraphQL request.&lt;/p&gt;&#10;" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2021/08/graphql-envelop-postman-app-test-300x173.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2021/08/graphql-envelop-postman-app-test.png" decoding="async" class="size-full wp-image-64463 jetpack-lazy-image" src="../Images/cf0da4bb7cdc07ed0deac22778a56dc6.png" alt="Postman GraphQL Request Page Testing Our App" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2021/08/graphql-envelop-postman-app-test.png 730w, https://blog.logrocket.com/wp-content/uploads/2021/08/graphql-envelop-postman-app-test-300x173.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2021/08/graphql-envelop-postman-app-test.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2021/08/graphql-envelop-postman-app-test.png"/><noscript><img data-lazy-fallback="1" data-attachment-id="64463" data-permalink="https://blog.logrocket.com/configuring-any-graphql-server-envelop/graphql-envelop-postman-app-test/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2021/08/graphql-envelop-postman-app-test.png" data-orig-size="730,420" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Graphql envelop postman app test" data-image-description="" data-image-caption="&lt;p&gt;Screenshot from Postman GraphQL request.&lt;/p&gt;&#10;" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2021/08/graphql-envelop-postman-app-test-300x173.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2021/08/graphql-envelop-postman-app-test.png" decoding="async" loading="lazy" class="size-full wp-image-64463" src="../Images/cf0da4bb7cdc07ed0deac22778a56dc6.png" alt="Postman GraphQL Request Page Testing Our App" srcset="https://blog.logrocket.com/wp-content/uploads/2021/08/graphql-envelop-postman-app-test.png 730w, https://blog.logrocket.com/wp-content/uploads/2021/08/graphql-envelop-postman-app-test-300x173.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2021/08/graphql-envelop-postman-app-test.png"/></noscript><figcaption id="caption-attachment-64463" class="wp-caption-text">Screenshot from Postman GraphQL request.</figcaption></figure>
<p>就是这样！我们已经成功地集成了 Envelop，并为一个节点应用程序添加了一个自定义插件。</p>
<h2>集成信封和阿波罗图</h2>
<p>就像我前面提到的，你可以将 Envelop 与任何 GraphQL 服务器集成。让我们看看用<a href="https://www.apollographql.com/" target="_blank" rel="noopener"> Apollo GraphQL </a>的实现。</p>
<p>在一个单独的目录中，通过运行以下命令安装 GraphQL、Apollo 和<a href="https://www.graphql-tools.com/docs/introduction" target="_blank" rel="noopener"> GraphQL 工具</a>:</p>
<pre class="language-bash hljs">npm install @apollo/client graphql @graphql-tools/schema 
</pre>
<p>创建一个名为<code>app.js</code>的单独的 JavaScript 文件，并向其中添加以下代码。</p>
<pre>import { ApolloServer } from 'apollo-server';
import { envelop, useSchema, useLogger } from '@envelop/core';
import { makeExecutableSchema } from '@graphql-tools/schema';

const schema = makeExecutableSchema({
  typeDefs: /* GraphQL */ `
    type Query {
      hello: String!
    }
  `,
  resolvers: {
    Query: {
      hello: () =&gt; 'World',
    },
  },
});

const getEnveloped = envelop({
  plugins: [useSchema(schema), useLogger()],
});

const server = new ApolloServer({
  executor: async requestContext =&gt; {
    const { schema, execute, contextFactory } = getEnveloped({ req: requestContext.request.http });

    return execute({
      schema: schema,
      document: requestContext.document,
      contextValue: await contextFactory(),
      variableValues: requestContext.request.variables,
      operationName: requestContext.operationName,
    });
  },
});

server.listen(3000);
</pre>
<p>在上面的代码片段中，我们用 GraphQL 工具创建了一个可执行模式，用 Envelop 创建了一个实例，并添加了<code>useSchema()</code>和<code>useLogger()</code>插件。</p>
<pre>const getEnveloped = envelop({
  plugins: [useSchema(schema), useLogger()],
});
</pre>
<p>请注意，<code>useSchema</code>和<code>useLogger</code>都预先包装了信封。</p>
<p>最后，在 Apollo 服务器对象中，用信封对象中的参数覆盖 executor 对象。这就是将 Envelop 与您的 Apollo GraphQL 服务器集成所需的全部内容。</p>
<h2>结论</h2>
<p>如果您使用 GraphQL 构建应用程序，您会发现 Envelop 对您的项目是一个很好的补充。如果你喜欢保持你的代码<a href="https://en.wikipedia.org/wiki/Don%27t_repeat_yourself" target="_blank" rel="noopener">干燥</a>，这一点尤其正确，因为 Envelop 允许你编写模块化的 GraphQL 插件，可以在所有的 GraphQL 服务器实现上工作。感谢阅读！</p><div class="code-block code-block-24">
<div class="blog-plug inline-plug graphql-plug"><h2>监控生产中失败和缓慢的 GraphQL 请求</h2><p>虽然 GraphQL 有一些调试请求和响应的特性，但确保 GraphQL 可靠地为您的生产应用程序提供资源是一件比较困难的事情。如果您对确保对后端或第三方服务的网络请求成功感兴趣，</p><a href="https://lp.logrocket.com/blg/graphql-signup" target="_blank">try LogRocket</a><p>.</p><a class="signup" href="https://lp.logrocket.com/blg/graphql-signup" target="_blank" rel="noopener noreferrer"><img src="../Images/432a3823c85b3fb72a206e6236a29f48.png" data-lazy-src="https://files.readme.io/69aa835-Image_2019-11-09_at_1.28.05_PM.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" class=" jetpack-lazy-image" data-original-src="https://files.readme.io/69aa835-Image_2019-11-09_at_1.28.05_PM.png"/><noscript><img data-lazy-fallback="1" src="../Images/432a3823c85b3fb72a206e6236a29f48.png" data-original-src="https://files.readme.io/69aa835-Image_2019-11-09_at_1.28.05_PM.png"/></noscript><img class="alignnone size-full wp-image-46 jetpack-lazy-image" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/><noscript><img data-lazy-fallback="1" class="alignnone size-full wp-image-46" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/></noscript></a><a href="https://lp.logrocket.com/blg/graphql-signup" target="_blank" rel="noopener noreferrer">https://logrocket.com/signup/</a><p>LogRocket 就像是网络和移动应用的 DVR，记录下你网站上发生的每一件事。您可以汇总并报告有问题的 GraphQL 请求，以快速了解根本原因，而不是猜测问题发生的原因。此外，您可以跟踪 Apollo 客户机状态并检查 GraphQL 查询的键值对。</p><p>LogRocket 检测您的应用程序以记录基线性能计时，如页面加载时间、到达第一个字节的时间、慢速网络请求，还记录 Redux、NgRx 和 Vuex 操作/状态。</p><a class="signup" href="https://lp.logrocket.com/blg/graphql-signup" target="_blank" rel="noopener noreferrer">Start monitoring for free</a><p>.</p></div>


</div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
<html>
<head>
<title>Using the React children prop with TypeScript </title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>将React子属性与TypeScript一起使用</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/using-react-children-prop-with-typescript/#0001-01-01">https://blog.logrocket.com/using-react-children-prop-with-typescript/#0001-01-01</a></blockquote><div><article class="article-post">
<p>最初，在React中正确键入<code>children</code>道具可能会带来一些困难。如果您尝试将它们键入为特定的JSX类型，可能会在呈现子组件时遇到问题。还有一个选择悖论的问题，因为有多个可用选项来键入儿童道具。这可能会导致决策疲劳。</p>
<p>在这篇文章中，我将分享我根据经验推荐的解决方案。为了完整起见，我还将分享一些其他的、有争议的相关方法。</p>
<p><em>向前跳转:</em></p>

<p>让我们开始吧。</p>
<h2 id="children-jsx">JSX的儿童</h2>
<p>当你用开始和结束标签写一个JSX表达式时，在它们之间传递的内容被称为它们的“子元素”。</p>
<figure id="attachment_148491" aria-describedby="caption-attachment-148491" class="wp-caption aligncenter"><img data-attachment-id="148491" data-permalink="https://blog.logrocket.com/using-react-children-prop-with-typescript/attachment/children-passed-between-opening-closing-tag-jsx-expression/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/12/children-passed-between-opening-closing-tag-jsx-expression.png" data-orig-size="730,511" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="children-passed-between-opening-closing-tag-jsx-expression" data-image-description="" data-image-caption="&lt;p&gt;Children passed between the opening and closing tag of your JSX expression&lt;/p&gt;&#10;" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/12/children-passed-between-opening-closing-tag-jsx-expression-300x210.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/12/children-passed-between-opening-closing-tag-jsx-expression.png" decoding="async" class="size-full wp-image-148491 jetpack-lazy-image" src="../Images/41a15f63bc048055780ad71c63526528.png" alt="Children passed between the opening and closing tag of your JSX expression" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2022/12/children-passed-between-opening-closing-tag-jsx-expression.png 730w, https://blog.logrocket.com/wp-content/uploads/2022/12/children-passed-between-opening-closing-tag-jsx-expression-300x210.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2022/12/children-passed-between-opening-closing-tag-jsx-expression.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/12/children-passed-between-opening-closing-tag-jsx-expression.png"/><noscript><img data-lazy-fallback="1" data-attachment-id="148491" data-permalink="https://blog.logrocket.com/using-react-children-prop-with-typescript/attachment/children-passed-between-opening-closing-tag-jsx-expression/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/12/children-passed-between-opening-closing-tag-jsx-expression.png" data-orig-size="730,511" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="children-passed-between-opening-closing-tag-jsx-expression" data-image-description="" data-image-caption="&lt;p&gt;Children passed between the opening and closing tag of your JSX expression&lt;/p&gt;&#10;" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/12/children-passed-between-opening-closing-tag-jsx-expression-300x210.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/12/children-passed-between-opening-closing-tag-jsx-expression.png" decoding="async" loading="lazy" class="size-full wp-image-148491" src="../Images/41a15f63bc048055780ad71c63526528.png" alt="Children passed between the opening and closing tag of your JSX expression" srcset="https://blog.logrocket.com/wp-content/uploads/2022/12/children-passed-between-opening-closing-tag-jsx-expression.png 730w, https://blog.logrocket.com/wp-content/uploads/2022/12/children-passed-between-opening-closing-tag-jsx-expression-300x210.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/12/children-passed-between-opening-closing-tag-jsx-expression.png"/></noscript><figcaption id="caption-attachment-148491" class="wp-caption-text">Children passed between the opening and closing tag of your JSX expression</figcaption></figure>
<p>考虑下面这个虚构的例子:</p>
<pre class="language-javascript hljs">&lt;Border&gt; Hey, I represent the JSX children! &lt;/Border&gt;
</pre>
<p>在这个例子中，字符串<code>Hey, I represent the JSX children!</code>指的是在<code>Border</code>中呈现的子元素。</p>
<p>相反，为了访问在JSX结束和开始标记之间传递的内容，React在一个特殊的属性中传递这些内容:<code>props.children</code></p>
<p>例如，<code>Border</code>可以如下接收<code>children</code>道具:</p>
<pre class="language-javascript hljs">const Border = ({children}) =&gt; {
   return &lt;div style={{border: "1px solid red"}}&gt;
      {children}
   &lt;/div&gt;
}
</pre>
<p><code>Border</code>接受<code>children</code>道具，然后用<code>1px solid red</code>的边框样式在<code>div</code>内渲染<code>children</code>。</p>
<p>这是<code>children</code> prop的基本用法，即接收和操作在JSX表达式的开始和结束标签内传递的内容。</p>
<h2 id="supported-children-types">支持的子类型</h2>
<p>严格地说，在JSX表达式的开始和结束标记中，有一些受支持的内容类型。以下是一些最常用的方法:</p>
<h3>用线串</h3>
<p>文字字符串是有效的子类型，如下所示:</p>
<pre class="language-typescript hljs">&lt;YourComponent&gt; This is a valid child string &lt;/YourComponent /&gt;
</pre>
<p>注意在<code>YourComponent</code>中，<code>props.children</code>将仅仅是字符串<code>This is a valid child string</code>。</p>
<h3>JSX</h3>
<p>您同样可以将其他JSX元素作为有效的子元素进行传递。当组合不同的嵌套组件时，这通常很有帮助。下面是一个例子:</p>
<pre class="language-typescript hljs">&lt;Wrapper&gt;
  &lt;YourFirstComponent /&gt;
  &lt;YourSecondComponent /&gt;
&lt;/Wrapper&gt;
</pre>
<p>混合子类型也是完全可以接受的，如下所示:</p>
<pre class="language-typescript hljs">&lt;Wrapper&gt;
  I am a valid string child
  &lt;YourFirstComponent /&gt;
  &lt;YourSecondComponent /&gt;
&lt;/Wrapper&gt;
</pre>
<h3>JavaScript表达式</h3>
<p>表达式同样是有效的子类型，如下所示:</p>
<pre class="language-typescript hljs">&lt;YourFirstComponent&gt; {myScopedVariableReference} &lt;/YourFirstComponent&gt;
</pre>
<p>记住<code>JSX</code>中的表达式是用花括号写的。</p>
<h3>功能</h3>
<p>函数是同等有效的子类型，如下所示:</p>
<pre class="language-typescript hljs">&lt;YourFirstComponent&gt; 
  {() =&gt; &lt;div&gt;{myScopedVariableReference}&lt;/div&gt;} 
&lt;/YourFirstComponent&gt;
</pre>
<p>如您所见，<code>children</code>道具可以用相当多的数据类型来表示！您的第一反应可能是手动键入这些内容，就像这样:</p>
<pre class="language-typescript hljs">type Props = {
  children: string | JSX.Element | JSX.Element[] | () =&gt; JSX.Element
}

const YourComponent = ({children} : Props) =&gt; {
  return children
}
</pre>
<p>这似乎是个好主意，但它并不能完全代表<code>children</code>道具。那么片段、门户、被忽略的渲染值，比如<code>undefined</code>、<code>null</code>、<code>true</code>或者<code>false</code>呢？</p>
<p>完整的表示可能如下所示:</p>
<pre class="language-typescript hljs">type ReactText = string | number;
type ReactChild = ReactElement | ReactText;

interface ReactNodeArray extends Array&lt;ReactNode&gt; {}
type ReactFragment = {} | ReactNodeArray;
type ReactNode = ReactChild | ReactFragment | ReactPortal | boolean | null | undefined;

type Props = {
  children: ReactNode
}

// source: https://github.com/DefinitelyTyped/DefinitelyTyped/blob/d076add9f29db350a19bd94c37b197729cc02f87/types/react/index.d.ts
</pre>
<p>参见<a href="https://github.com/DefinitelyTyped/DefinitelyTyped/blob/d076add9f29db350a19bd94c37b197729cc02f87/types/react/index.d.ts#L190">反应入口</a>和<a href="https://github.com/DefinitelyTyped/DefinitelyTyped/blob/d076add9f29db350a19bd94c37b197729cc02f87/types/react/index.d.ts#L146">反应出口</a>的扩展类型。它们看起来复杂吗？他们很有可能知道。</p>
<p>我想说的是，在实践中，你不希望手动输入<code>children</code>道具。相反，我建议使用下面讨论的官方支持的类型。</p>
<h2 id="using-propswithchildren-type">使用<code>PropsWithChildren</code>类型</h2>
<p><code>React.PropsWithChildren</code>类型接受您的组件属性，并返回一个带有适当类型的<code>children</code>属性的联合类型。你不需要额外的工作。</p>
<p>实际上，下面是<a href="https://github.com/DefinitelyTyped/DefinitelyTyped/blob/d076add9f29db350a19bd94c37b197729cc02f87/types/react/index.d.ts#L822">对<code>PropsWithChildren</code>类型的定义</a>:</p>
<pre class="language-typescript hljs">type PropsWithChildren&lt;P&gt; = P &amp; { children?: ReactNode };
</pre>
<figure id="attachment_148502" aria-describedby="caption-attachment-148502" class="wp-caption aligncenter"><img data-attachment-id="148502" data-permalink="https://blog.logrocket.com/using-react-children-prop-with-typescript/attachment/how-propswithchildren-type-works/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/12/how-propswithchildren-type-works.png" data-orig-size="730,454" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="how-propswithchildren-type-works" data-image-description="" data-image-caption="&lt;p&gt;How the &lt;code&gt;propsWithChildren&lt;/code&gt; type works&lt;/p&gt;&#10;" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/12/how-propswithchildren-type-works-300x187.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/12/how-propswithchildren-type-works.png" decoding="async" class="size-full wp-image-148502 jetpack-lazy-image" src="../Images/84ccc4138823c4076f216aed49714ed8.png" alt="How the propsWithChildren type works" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2022/12/how-propswithchildren-type-works.png 730w, https://blog.logrocket.com/wp-content/uploads/2022/12/how-propswithchildren-type-works-300x187.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2022/12/how-propswithchildren-type-works.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/12/how-propswithchildren-type-works.png"/><noscript><img data-lazy-fallback="1" data-attachment-id="148502" data-permalink="https://blog.logrocket.com/using-react-children-prop-with-typescript/attachment/how-propswithchildren-type-works/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/12/how-propswithchildren-type-works.png" data-orig-size="730,454" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="how-propswithchildren-type-works" data-image-description="" data-image-caption="&lt;p&gt;How the &lt;code&gt;propsWithChildren&lt;/code&gt; type works&lt;/p&gt;&#10;" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/12/how-propswithchildren-type-works-300x187.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/12/how-propswithchildren-type-works.png" decoding="async" loading="lazy" class="size-full wp-image-148502" src="../Images/84ccc4138823c4076f216aed49714ed8.png" alt="How the propsWithChildren type works" srcset="https://blog.logrocket.com/wp-content/uploads/2022/12/how-propswithchildren-type-works.png 730w, https://blog.logrocket.com/wp-content/uploads/2022/12/how-propswithchildren-type-works-300x187.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/12/how-propswithchildren-type-works.png"/></noscript><figcaption id="caption-attachment-148502" class="wp-caption-text">How the <code>propsWithChildren</code> type works</figcaption></figure>
<p>假设你有一个组件<code>Foo</code>和道具<code>FooProps</code>:</p>
<pre class="language-typescript hljs">type FooProps = {
  name: 'foo'
}

export const Foo = (props: FooProps) =&gt; {
    return null
}
</pre>
<p>你可以继续介绍<code>children</code>道具如下:</p>
<pre class="language-typescript hljs">import { PropsWithChildren } from 'react'

type FooProps = {
  name: 'foo'
}

export const Foo = (props: PropsWithChildren&lt;FooProps&gt;) =&gt; {
    return props.children
}
</pre>
<p>当你将<code>PropsWithChildren</code>传递给你的组件道具<code>FooProps</code>时，你得到了内部类型化的<code>children</code>道具。</p>
<p>在大多数情况下，这是推荐的键入<code>children</code>属性的方式，因为它需要较少的样板文件，并且<code>children</code>属性是隐式类型的。</p>
<h2 id="explicitly-using-reactnode-type">显式使用<code>ReactNode</code>类型</h2>
<p>在必须显式键入<code>children</code>属性的情况下，可以继续使用<code>ReactNode</code>类型。</p>
<p>记住<code>PropsWithChildren</code>类型的定义:</p>
<pre class="language-typescript hljs">type PropsWithChildren&lt;P&gt; = P &amp; { children?: ReactNode };
</pre>
<figure id="attachment_148506" aria-describedby="caption-attachment-148506" class="wp-caption aligncenter"><img data-attachment-id="148506" data-permalink="https://blog.logrocket.com/using-react-children-prop-with-typescript/attachment/propswithchildren-type-leverages-reactnode-type/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/12/propswithchildren-type-leverages-reactnode-type.png" data-orig-size="730,454" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="propswithchildren-type-leverages-reactnode-type" data-image-description="" data-image-caption="&lt;p&gt;The propsWithChildren type leverages the reactNode type&lt;/p&gt;&#10;" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/12/propswithchildren-type-leverages-reactnode-type-300x187.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/12/propswithchildren-type-leverages-reactnode-type.png" decoding="async" class="size-full wp-image-148506 jetpack-lazy-image" src="../Images/8020037d909c66fb8f8179c8f15bf882.png" alt="The propsWithChildren type leverages the reactNode type" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2022/12/propswithchildren-type-leverages-reactnode-type.png 730w, https://blog.logrocket.com/wp-content/uploads/2022/12/propswithchildren-type-leverages-reactnode-type-300x187.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2022/12/propswithchildren-type-leverages-reactnode-type.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/12/propswithchildren-type-leverages-reactnode-type.png"/><noscript><img data-lazy-fallback="1" data-attachment-id="148506" data-permalink="https://blog.logrocket.com/using-react-children-prop-with-typescript/attachment/propswithchildren-type-leverages-reactnode-type/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/12/propswithchildren-type-leverages-reactnode-type.png" data-orig-size="730,454" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="propswithchildren-type-leverages-reactnode-type" data-image-description="" data-image-caption="&lt;p&gt;The propsWithChildren type leverages the reactNode type&lt;/p&gt;&#10;" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/12/propswithchildren-type-leverages-reactnode-type-300x187.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/12/propswithchildren-type-leverages-reactnode-type.png" decoding="async" loading="lazy" class="size-full wp-image-148506" src="../Images/8020037d909c66fb8f8179c8f15bf882.png" alt="The propsWithChildren type leverages the reactNode type" srcset="https://blog.logrocket.com/wp-content/uploads/2022/12/propswithchildren-type-leverages-reactnode-type.png 730w, https://blog.logrocket.com/wp-content/uploads/2022/12/propswithchildren-type-leverages-reactnode-type-300x187.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/12/propswithchildren-type-leverages-reactnode-type.png"/></noscript><figcaption id="caption-attachment-148506" class="wp-caption-text">The propsWithChildren type leverages the reactNode type</figcaption></figure>
<p>不依赖<code>PropsWithChildren</code>，也可以直接键入<code>children</code>道具:</p>
<pre class="language-typescript hljs">import { ReactNode } from 'react'

type FooProps = {
  name: 'foo'
  // look here 👇
  children: ReactNode
}

export const Foo = (props: FooProps) =&gt; {
    return props.children
}
</pre>
<h2 id="using-functioncomponent-fc-type">使用<code>FunctionComponent</code>(或<code>FC</code>)类型</h2>
<p><code>FunctionComponent</code>通用接口也可以用来适当地输入<code>children</code>属性。在内部，这个接口依赖于<code>PropsWithChildren</code>。</p>
<p>你可以这样使用它:</p>
<pre class="language-typescript hljs">import { FunctionComponent } from 'react'

type FooProps = {
  name: 'foo'
}

export const Foo: FunctionComponent&lt;FooProps&gt; = (props) =&gt; {
    return props.children
}
</pre>
<p>注意，为了方便起见，<code>FC</code>类型是<code>FunctionComponent</code>的别名。它们的用法相似，如下所示:</p>
<pre class="language-typescript hljs">import { FC } from 'react'

type FooProps = {
  name: 'foo'
}

export const Foo: FC&lt;FooProps&gt; = (props) =&gt; {
    return props.children
}
</pre>
<h2 id="using-component-type-class-components">将<code>Component</code>类型用于类组件</h2>
<p>大多数现代的React代码库不再使用类组件，除非在特定的用例中。<br/>如果你发现自己需要在一个类组件中键入<code>children</code>道具，利用<code>Component</code>道具，如下所示:</p>
<pre class="language-typescript hljs">import { Component } from 'react'

type FooProps = {
  name: 'foo'
}

class Foo extends Component&lt;FooProps&gt; {
  render() {
    return this.props.children
  }
}
</pre>
<p>类似于<code>FunctionComponent</code>接口及其<code>FC</code>别名，<code>Component</code>类型自动包含<code>children</code>道具。</p>
<h2>结论</h2>
<p>在可能的情况下，使用<code>PropsWithChildren</code>类型，但是也不要害怕直接键入<code>children</code>属性，无论是在类中还是在功能组件中。</p><div class="code-block code-block-17">
<div class="blog-plug inline-plug react-plug" vwo-el-id="26283398190">
<h2 vwo-el-id="41600691720"><a href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener"> LogRocket </a>:全面了解您的生产React应用</h2><p>调试React应用程序可能很困难，尤其是当用户遇到难以重现的问题时。如果您对监视和跟踪Redux状态、自动显示JavaScript错误以及跟踪缓慢的网络请求和组件加载时间感兴趣，</p><a href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" vwo-el-id="19356441070">try LogRocket</a><p>. </p><a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="19356441380">
<img class="first-react-image alignnone size-full wp-image-46 jetpack-lazy-image jetpack-lazy-image--handled" src="../Images/f300c244a1a1cf916df8b4cb02bec6c6.png" vwo-el-id="18272717540" data-lazy-loaded="1" data-original-src="https://files.readme.io/27c94e7-Image_2017-06-05_at_9.46.04_PM.png"/>
</a>
<a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="19356441690">
<img class="second-react-image alignnone size-full wp-image-46 jetpack-lazy-image jetpack-lazy-image--handled" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" vwo-el-id="30720362350" data-lazy-loaded="1" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/>
</a>
<p vwo-el-id="28675660440" class="">LogRocket 结合了会话回放、产品分析和错误跟踪，使软件团队能够创建理想的web和移动产品体验。这对你来说意味着什么？</p>
<p>LogRocket不是猜测错误发生的原因，也不是要求用户提供截图和日志转储，而是让您回放问题，就像它们发生在您自己的浏览器中一样，以快速了解哪里出错了。</p>
<p>不再有嘈杂的警报。智能错误跟踪允许您对问题进行分类，然后从中学习。获得有影响的用户问题的通知，而不是误报。警报越少，有用的信号越多。</p>
<p vwo-el-id="28675660750">LogRocket Redux中间件包为您的用户会话增加了一层额外的可见性。LogRocket记录Redux存储中的所有操作和状态。</p>
<p vwo-el-id="28675661060">现代化您调试React应用的方式— <a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="40093418840">开始免费监控</a>。</p>
</div></div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
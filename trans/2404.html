<html>
<head>
<title>What’s new in Next.js 12 - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>Next.js 12 - LogRocket 博客中的新内容</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/whats-new-next-js-12/#0001-01-01">https://blog.logrocket.com/whats-new-next-js-12/#0001-01-01</a></blockquote><div><article class="article-post">
<h2>介绍</h2>
<p>目前，Next.js 是 React 生态系统中最受欢迎的框架，随着 Next 12 的发布，情况只会越来越好。</p>
<p>接下来的 12 个特性包括性能优化、React 18 支持、中间件等等。让我们在下一节了解这些特性。</p>
<h2>新功能</h2>
<p>Next.js 世界里有一堆很棒的特性。在本节中，我们将详细了解它们。让我们开始吧。</p>
<h3>Rust 编译器</h3>
<p>Next 12 的关键特性之一是性能优化。为了提高性能，Next.js 用可扩展的 Rust 编译器取代了 Babel 编译器，该编译器利用了本地编译的优势。</p>
<p>根据文档，SWC 在单线程上比 Babel 快 20 倍，在四核上快 70 倍。</p>
<p>借助新的 Rust 编译器，Next.js 承诺优化捆绑和编译，本地刷新速度提高 3 倍，生产构建速度提高 5 倍。</p>
<p>其结果是更快的生产构建时间和本地开发中的即时反馈，从而带来更好的开发人员体验和更快的开发时间。</p>
<h3 id="middlewares">中间件</h3>
<p>Next 12 最酷的特性之一是中间件。根据文档，中间件使我们能够使用代码而不是配置。这意味着我们可以在请求完成之前运行代码，并且基于请求，我们可以通过重写、重定向、添加头等来修改响应。</p>
<p>中间件并不是一个新概念。像 Express.js 这样的框架使用中间件来拦截 HTTP 请求，并在它到达路由处理器之前对其进行处理。Next.js 同样使用中间件来给我们充分的灵活性。</p>
<p>要在 Next 中创建一个中间件，在 pages 目录中创建一个<code>_middleware.ts</code>文件。在文件内部，导出一个名为中间件的函数，如下所示:</p>
<pre class="language-typescript hljs">import {NextFetchEvent, NextRequest, NextResponse} from 'next/server'
export function middleware (req, event) {
  // your code 
}
</pre>
<p>此外，如果我们只想让中间件在页面的子集上运行，我们可以通过在页面目录的子目录中创建<code>_middleware.ts</code>文件来将中间件的范围扩大到子目录。</p>
<p>有了中间件，我们可以实现诸如<a href="https://github.com/vercel/examples/tree/main/edge-functions" target="_blank" rel="noopener">认证</a>、<a href="https://github.com/vercel/examples/tree/main/edge-functions" target="_blank" rel="noopener">僵尸防护</a>、<a href="https://github.com/vercel/examples/tree/main/edge-functions" target="_blank" rel="noopener">重定向和重写</a>、<a href="https://github.com/vercel/examples/tree/main/edge-functions" target="_blank" rel="noopener">服务器端分析</a>、<a href="https://github.com/vercel/examples/tree/main/edge-functions" target="_blank" rel="noopener">日志</a>、<a href="https://github.com/vercel/examples/tree/main/edge-functions" target="_blank" rel="noopener">处理不支持的浏览器</a>等等。</p>
<p>下一个中间件 API 扩展了本地 Web API 对象<code>FetchEvent</code>、<code>Response</code>和<code>Request</code>，以便在基于传入请求配置响应时给我们更多的控制和灵活性。</p>
<p>下面是中间件函数签名:</p>
<pre class="language-typescript hljs">import type { NextFetchEvent, NextRequest } from 'next/server';

export type Middleware = (request: NextRequest, event: NextFetchEvent) =&gt; 
  Promise&lt;Response | undefined&gt; | Response | undefined;
</pre>
<p><code>NextFetchEvent</code>是本机<code>FetchEvent</code>对象的扩展，并添加了<code>waituntil</code>方法，该方法可用于在响应发送后扩展中间件的执行。因此，使用<code>waituntil</code>方法，我们可以发送一个响应，并在中间件中继续后台工作。</p>
<p>当使用类似 Sentry 的工具在发送响应后发送响应时间和错误的日志时,<code>waituntil</code>方法会很有用。</p>
<p><code>NextRequest</code>对象扩展本地<code>Request</code>对象，而<code>NextResponse</code>对象扩展本地<code>Response</code>对象。</p>
<p>此外，Next.js 中间件函数在呈现 pages 目录中的每个页面之前运行，它使我们能够访问和修改传入的请求。</p>
<p>因此，中间件为我们提供了一种更有效的方式来共享页面之间的逻辑，从而保持代码的简洁和高效。</p>
<p>例如，为了在每个页面上验证用户身份验证凭证，通常的模式是在每个页面上导入身份验证逻辑。然而，有了中间件，我们只需在中间件中定义我们的逻辑，它就会自动在每个页面上运行。</p>
<p>此外，Next 中间件与 Vercel Edge 功能协同工作。<a href="https://github.com/vercel/examples/tree/main/edge-functions" target="_blank" rel="noopener"> Edge Functions </a>是像 AWS Lamda 和 Google Cloud Functions 这样的无服务器功能，它们像 CDN 一样部署到 Vercel 的<a href="https://vercel.com/docs/concepts/edge-network/overview" target="_blank" rel="noopener"> Edge 网络</a>。这使得我们的服务器端逻辑更接近原点；因此，我们的最终用户可以在零代码开始的情况下获得极快的执行速度。</p>
<p>传统上，为了提高速度，网络内容从 CDN 提供给最终用户。但是这些是静态页面，我们失去了动态内容。此外，我们使用服务器端呈现来呈现来自服务器的内容，以获得动态内容，但是我们损失了速度。</p><div class="code-block code-block-54">
<hr/>
<h3>更多来自 LogRocket 的精彩文章:</h3>

<hr/></div>
<p>但是，通过像 CDN 一样将我们的中间件部署到边缘，我们将我们的服务器逻辑移动到靠近访问者的起点。这样做的结果是我们得到了速度和动力。</p>
<h3>React 18 支持</h3>
<p>React 18 还在测试中。然而，React 18 的功能，如服务器端暂停和自动更新补丁，现在可以在 Next.js 12 中以实验性的标志提供，因为 Next 准备在 React 18 走向稳定版本时为其做准备。</p>
<p>React 18 支持 React 服务器组件和并发模式特性，如服务器端暂挂和 SSR 流。</p>
<p>悬念是一个组件，它允许您在呈现其子组件之前等待异步数据。在 React 18 之前，服务器上没有悬念，但 React 18 内置了对服务器端悬念和 SSR 流的支持，从而使我们能够使用 HTTP 流在服务器上呈现页面。</p>
<p>在接下来的 12 个版本中，要获得此功能，您可以选择实验性的并发功能:</p>
<pre class="language-javascript hljs">...
experimental: {
  concurrentFeatures: true,
}
...
</pre>
<p>请注意，要使上面的代码工作，请确保您安装了 React 的测试版:</p>
<pre class="language-bash hljs">npm install <a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="aec0cbd6daeec2cfdacbddda">[email protected]</a> <a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="cfbdaaaeacbb8fadaabbae">[email protected]</a> <a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="3240575351461f565d5f7250574653">[email protected]</a>
</pre>
<p>一旦这个实验性的并发特性被启用，SSR 将使用与<a href="https://nextjs.org/docs/middleware" target="_blank" rel="noopener">中间件</a>相同的<a href="https://nextjs.org/docs/api-reference/edge-runtime" target="_blank" rel="noopener"> Edge 运行时</a>。</p>
<p>这样做的结果是，我们可以使用基于 ES 2020 的悬念数据抓取、<a href="https://nextjs.org/docs/advanced-features/dynamic-import" target="_blank" rel="noopener"> <code>next/dynamic</code> </a>，以及带有悬念边界的 React.lazy:</p>
<pre class="language-typescript hljs">import dynamic from 'next/dynamic'
import { lazy } from 'react'

// These two methods are identical:
const Users = dynamic(() =&gt; import('./user'), { suspense: true })
const Footer = lazy(() =&gt; import('./footer'))

const Dashboard = () =&gt; {
  return (
    &lt;div&gt;
      &lt;Suspense fallback={&lt;Spinner /&gt;}&gt;
        &lt;Users /&gt;
      &lt;/Suspense&gt;
      &lt;Suspense fallback={&lt;Spinner /&gt;}&gt;
        &lt;Footer /&gt;
      &lt;/Suspense&gt;
    &lt;/div&gt;
  )
}

export default Dashboard;
</pre>
<p>React 服务器组件允许您从服务器上的 React 组件本地呈现 HTML。它使用 HTTP 流在服务器上渐进地呈现网页。使用 React 服务器组件，您可以立即从 edge 函数流式传输 HTML，并在数据进入时逐步显示更新。</p>
<p>此外，我们可以在 React 服务器组件内部直接获取数据，而不需要使用<code>getStaticProps</code>或<code>getServerSideProps</code>。当呈现 React 服务器组件时，它们不需要任何客户端 JavaScript。这使得最终用户下载的千字节数更少，页面呈现速度更快。</p>
<p>在接下来的 12 个版本中，您可以通过配置您的<code>next.config.js</code>文件来选择加入该体验功能:</p>
<pre class="language-javascript hljs">...
experimental: {
  concurrentFeatures: true,
  serverComponents: true,
}
...
</pre>
<p>为了在 Next 中创建一个 React 服务器组件，我们只需在组件的文件名后面添加<code>.sever.js</code>。此外，为了创建一个客户机组件，我们将<code>.client.js</code>添加到组件的文件名中。</p>
<p>考虑下面的代码:</p>
<pre class="language-javascript hljs">// pages/home.server.js
import React, { Suspense } from 'react'

import Users from '../components/users.server'
import Cart from '../components/cart.client'

const Home = () =&gt; {
  return (
    &lt;div&gt;
      &lt;h1&gt;React Server Component Demo&lt;/h1&gt;
      &lt;Suspense fallback={'Loading...'}&gt;
        &lt;Users /&gt;
      &lt;/Suspense&gt;
      &lt;Cart /&gt;
    &lt;/div&gt;
  )
}

export default Home;
</pre>
<p>在上面的代码中，<code>Home</code>和<code>Users</code>组件都是服务器组件，不会包含在客户端运行时中。<br/><code>Home</code>和<code>Users</code>都将始终在服务器端渲染并传输到客户端，但<code>Cart</code>仍将在客户端进行水合，就像普通的 React 组件一样。</p>
<p>注意，根据文档，没有“服务器/客户端”扩展的组件将被视为“通用组件”，可以由双方使用和呈现，这取决于它是从哪里导入的。</p>
<h3>ES 模块支持和 URL 导入</h3>
<p>在版本 11.1 中，Next 增加了对 ES 模块的实验性支持，但是在版本 12 中，这是默认的。</p>
<p>ES Modules 是 JavaScript 的官方 ECMAScript 模块标准，它受到 Node.js 和所有主流浏览器的支持。</p>
<p>接下来的 12 个模块优先于普通模块。但是，它仍然支持导入使用 CommonJS 的 NPM 模块。这有助于开发人员逐步采用 ES 模块，而不会中断更改。</p>
<p>此外，Next 12 实验性地支持使用 es 模块的包的 URL 导入。这意味着一个包可以直接从一个 URL 导入，不需要安装或者单独的构建步骤。此外，这些包被缓存在本地以支持离线开发。<br/>这样做的结果是 Next.js 可以像处理本地依赖一样处理远程 HTTP(S)资源。</p>
<p>当 Next 检测到 URL 导入时，它会生成一个<code>next.lock</code>文件来跟踪远程资源。Next 支持服务器和客户端 URL 导入。</p>
<p>要使用此功能，请在<code>next.config.js</code>中添加允许的 URL 前缀:</p>
<pre class="language-javascript hljs">module.exports = {
  experimental: {
    urlImports: ['https://cdn.skypack.dev']
  }
}
</pre>
<p>和导入模块:</p>
<pre class="language-javascript hljs">import confetti from 'https://cdn.skypack.dev/canvas-confetti'
</pre>
<p>任何服务于 es 模块的 CDN 都可以工作。例如 jsDelivr、JSPM 和 unpkg。</p>
<h3>Bot 感知的 ISR 回退</h3>
<p><a href="https://vercel.com/docs/concepts/next.js/incremental-static-regeneration" target="_blank" rel="noopener">增量静态再生</a>或 ISR，使我们能够在构建了我们的站点之后增量更新静态页面，而不需要重建整个站点。使用 ISR，静态页面是在运行时动态生成的，而不是在构建时。</p>
<p>使用 ISR 时，Next.js 使用从<code>getStaticPath</code>函数返回的路径确定静态站点生成要生成的页面。因此，如果我们返回 1000 篇被浏览最多的文章的路径，这些页面是在构建时生成的。</p>
<p>我们应用程序中的其他页面可以通过使用<code>fallback:blocking</code>或<code>fallback:true</code>按需生成。</p>
<p><code>fallback:blocking</code>是首选，因为当对尚未生成的页面发出请求时，Next 将第一次服务器呈现该页面，并从缓存中为后续请求提供服务。</p>
<p>但是当使用<code>fallback:true</code>时，Next.js 会在第一次请求时立即以加载状态提供一个静态页面。当数据完成加载时，Next 将重新呈现页面并缓存数据。</p>
<p>然而，有了机器人感知的 ISR 回退功能，当使用<code>fallback: true</code>搜索机器人等<a href="https://nextjs.org/learn/seo/introduction-to-seo/webcrawlers" target="_blank" rel="noopener">网络爬虫时，Next.js 将自动呈现 ISR 页面。但是 Next 仍然会向非 crawler 用户代理提供一个带有加载状态的静态页面。因此，这阻止了爬行器索引加载状态。</a></p>
<h3>使用 AVIF 的较小图像</h3>
<p>Next.js 内置的图像优化 API 现在支持 AVIF 图像。这使得图像比<code>WebP</code>小 20%。</p>
<p>这个特性是可选的，可以通过修改<code>next.config.js</code>文件中的<code>image.format</code>属性来启用:</p>
<pre class="language-javascript hljs">module.exports = {
  images: {
    formats: ['image/avif', 'image/webp']
  }
}
</pre>
<h3>输出文件跟踪</h3>
<p>通过将 Vercel 的<code>@verce/nft</code>包带到 Next.js 12 中，这一点得到了改善。这样，Nextjs 可以自动跟踪每个页面和 API 路由所需的文件，并在输出旁边输出这些跟踪结果。这允许集成商自动利用 Next 提供的跟踪。</p>
<h2>结论</h2>
<p>Next 12 是一个彻底的游戏改变者，它将改变我们构建 React 应用程序的方式，使之变得更好。尽管一些令人惊叹的功能还不稳定，但在我们等待 React 18 的稳定发布时，您仍然可以选择加入并在您的应用程序中使用它们。</p><div class="code-block code-block-30">
<div class="blog-plug inline-plug next-plug"><h2><a href="https://lp.logrocket.com/blg/nextjs-signup" target="_blank"> LogRocket </a>:全面了解生产 Next.js 应用</h2><p>调试下一个应用程序可能会很困难，尤其是当用户遇到难以重现的问题时。如果您对监视和跟踪状态、自动显示 JavaScript 错误、跟踪缓慢的网络请求和组件加载时间感兴趣，</p><a href="https://lp.logrocket.com/blg/nextjs-signup" target="_blank">try LogRocket</a><p>. </p><a class="signup" href="https://lp.logrocket.com/blg/nextjs-signup" target="_blank" rel="noopener noreferrer"><img class="alignnone size-full wp-image-46 jetpack-lazy-image" src="../Images/f300c244a1a1cf916df8b4cb02bec6c6.png" data-lazy-src="https://files.readme.io/27c94e7-Image_2017-06-05_at_9.46.04_PM.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://files.readme.io/27c94e7-Image_2017-06-05_at_9.46.04_PM.png"/><noscript><img data-lazy-fallback="1" class="alignnone size-full wp-image-46" src="../Images/f300c244a1a1cf916df8b4cb02bec6c6.png" data-original-src="https://files.readme.io/27c94e7-Image_2017-06-05_at_9.46.04_PM.png"/></noscript></a><a class="signup" href="https://lp.logrocket.com/blg/nextjs-signup" target="_blank" rel="noopener noreferrer"><img class="alignnone size-full wp-image-46 jetpack-lazy-image" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/><noscript><img data-lazy-fallback="1" class="alignnone size-full wp-image-46" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/></noscript></a><p>LogRocket 就像是网络和移动应用的 DVR，记录下你的 Next.js 应用上发生的一切。您可以汇总并报告问题发生时应用程序的状态，而不是猜测问题发生的原因。LogRocket 还可以监控应用程序的性能，报告客户端 CPU 负载、客户端内存使用等指标。</p><p>LogRocket Redux 中间件包为您的用户会话增加了一层额外的可见性。LogRocket 记录 Redux 存储中的所有操作和状态。</p><p>让您调试 Next.js 应用的方式现代化— <a class="signup" href="https://lp.logrocket.com/blg/nextjs-signup" target="_blank" rel="noopener noreferrer">开始免费监控</a>。</p></div></div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
<html>
<head>
<title>Building a chat application with React and Django Channels - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>用React和Django通道构建聊天应用程序</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/build-chat-application-react-django-channels/#0001-01-01">https://blog.logrocket.com/build-chat-application-react-django-channels/#0001-01-01</a></blockquote><div><article class="article-post">
<p>使用Django为HTTP连接和应用程序请求开发服务器是很常见的。然而，当开发一个应用程序时，需要一直打开连接进行双向连接，比如会议和聊天程序，使用HTTP连接是低效的。在这种情况下，使用WebSockets至关重要。</p>
<p>通过使用WebSockets，连接到开放网络的所有用户都可以实时接收相关数据，这提供了一种在客户机和服务器之间建立双向连接的方式。这是一个有状态的协议，这意味着在初始连接身份验证之后，将保存客户端凭据，并且在连接被破坏之前不需要进一步的身份验证。</p>
<p>在本教程中，我们将学习如何使用Django和React构建一个聊天应用程序。学完本教程后，你应该更熟悉WebSockets在Django和React中的工作方式。要阅读本文，您需要:</p>

<p>你可以在<a href="https://github.com/khabdrick/django-channels-react"> GitHub </a>上找到完整的应用。我们开始吧！</p>
<h2 id="tableofcontents">目录</h2>

<h2 id="websocket-features">WebSocket功能</h2>
<p>WebSocket是一种双向协议，这意味着数据可以在客户端和服务器之间即时交换，不会中断。出于同样的原因，WebSockets也被视为全双工通信。</p>
<p>WebSockets不需要任何特定的浏览器来工作；所有浏览器都兼容。WebSocket是一个带状态的协议。由于在主要连接验证之后保存客户端凭证，因此在连接丢失之前不需要再次进行额外的身份验证。</p>
<h2 id="use-websockets-django">如何在Django中使用WebSockets</h2>
<p>当你想用WebSockets做任何事情时，<a href="https://channels.readthedocs.io/en/stable/"> Django Channels </a>是必不可少的，所以用下面的命令安装它:</p>
<pre class="language-bash hljs">pip install channels
</pre>
<p>在这一节中，我们将设置Django来使用WebSockets，将其与构建普通的Django应用程序进行比较。</p>
<p>感谢Django通道，在Django中使用WebSockets非常简单。您可以使用Django通道构建一个<a href="https://asgi.readthedocs.io/en/latest/"> ASGI </a>(异步服务器网关接口)服务器，之后您可以构建一个群组，其中的成员可以即时相互发送文本。通信不是与特定的用户，而是与一个组，任何数量的用户都可以加入。</p>
<p>创建一个包含项目所有代码的文件夹。导航到您刚刚在终端上创建的文件夹，并运行<code>startproject</code>命令来创建一个新的Django项目:</p>
<pre class="language-django hljs">$ django-admin startproject chat .
</pre>
<p>现在，运行<code>$ python3 manage.py startapp app</code>创建一个新的应用程序。</p>
<p>您需要让您的Django项目知道已经添加了一个新的应用程序，并且安装了Channels插件。你可以通过更新<code>chat/settings.py</code>文件并将<code>'app'</code>添加到<code>INSTALLED_APPS</code>列表中来实现。它将类似于下面的代码:</p>
<pre class="language-django hljs"># project/settings.py
INSTALLED_APPS = [
   ...
   'channels',
   'app',
]
</pre>
<p>在<code>settings.py</code>文件中，您应该设置配置以允许Django和Django通道通过消息代理相互连接。为此，我们可以利用Redis这样的工具，但是在本例中，我们将坚持使用本地后端。将下面一行代码添加到您的<code>settings.py</code>文件中:</p>
<pre class="language-django hljs">ASGI_APPLICATION = "chat.routing.application" #routing.py will handle the ASGI
CHANNEL_LAYERS = {
    'default': {
        'BACKEND': "channels.layers.InMemoryChannelLayer"
        }
    }
</pre>
<p>在上面的代码中，需要使用<code>ASGI_APPLICATION</code>来运行ASGI服务器，并告诉Django当事件发生时该做什么。我们将把这个配置放在一个名为<code>routing.py</code>的文件中。路由Django通道类似于Django URL配置；当WebSocket请求被发送到服务器时，它选择运行什么代码。</p>
<p>在创建路由之前，我们将首先开发<a href="https://channels.readthedocs.io/en/stable/topics/consumers.html#consumers">消费者</a>。在Django通道中，消费者使您能够在代码中创建函数集，每当事件发生时都会调用这些函数。他们类似于Django里的<code>views</code>。</p>
<p>要开发消费者，打开<code>app/</code>文件夹，创建一个名为<code>consumers.py</code>的新文件，并粘贴以下代码:</p>
<pre class="language-django hljs"># app/consumers.py
import json
from asgiref.sync import async_to_sync
from channels.generic.websocket import WebsocketConsumer

class TextRoomConsumer(WebsocketConsumer):
    def connect(self):

        self.room_name = self.scope\['url_route'\]['kwargs']['room_name']
        self.room_group_name = 'chat_%s' % self.room_name
        # Join room group
        async_to_sync(self.channel_layer.group_add)(
            self.room_group_name,
            self.channel_name
        )
        self.accept()
    def disconnect(self, close_code):
        # Leave room group
        async_to_sync(self.channel_layer.group_discard)(
            self.room_group_name,
            self.channel_name
        )

    def receive(self, text_data):
        # Receive message from WebSocket
        text_data_json = json.loads(text_data)
        text = text_data_json['text']
        sender = text_data_json['sender']
        # Send message to room group
        async_to_sync(self.channel_layer.group_send)(
            self.room_group_name,
            {
                'type': 'chat_message',
                'message': text,
                'sender': sender
            }
        )

    def chat_message(self, event):
        # Receive message from room group
        text = event['message']
        sender = event['sender']
        # Send message to WebSocket
        self.send(text_data=json.dumps({
            'text': text,
            'sender': sender
        }))
</pre>
<p>现在，我们可以创建处理您刚刚创建的消费者的路由。创建一个名为<code>routing.py</code>的新文件，并粘贴下面的代码，这将编排消费者:</p>
<pre class="language-django hljs">from channels.routing import ProtocolTypeRouter, URLRouter
# import app.routing
from django.urls import re_path
from app.consumers import TextRoomConsumer
websocket_urlpatterns = [
    re_path(r'^ws/(?P&lt;room_name&gt;[^/]+)/$', TextRoomConsumer.as_asgi()),
]
# the websocket will open at 127.0.0.1:8000/ws/&lt;room_name&gt;
application = ProtocolTypeRouter({
    'websocket':
        URLRouter(
            websocket_urlpatterns
        )
    ,
})
</pre>
<h2 id="building-frontend">构建前端</h2>
<p>现在，让我们构建一个聊天应用程序的前端，它使用WebSockets连接到Django后端。我们将用React构建这一部分，并用MUI 添加样式。</p>
<p>在您的终端中，导航到项目的根目录并运行以下命令来获取React的Create React App样板代码:</p>
<pre class="language-bash hljs">npx create-react-app frontend
</pre>
<p>接下来，<code>cd</code>进入<code>frontend/</code>目录并运行以下命令来安装MUI和<a href="https://www.npmjs.com/package/websocket"> WebSocket </a>依赖项，这允许我们将React应用程序连接到WebSocket服务器:</p>
<pre class="language-bash hljs">npm install --save --legacy-peer-deps @material-ui/core
npm install websocket
</pre>
<p>删除<code>frontend/src/App.js</code>中的所有代码。我们将用本教程剩余部分中的代码替换它，从初始状态开始:</p>
<pre class="language-javascript hljs">import React, { Component } from 'react';
import { w3cwebsocket as W3CWebSocket } from "websocket";

class App extends Component {
  state = {
    filledForm: false,
    messages: [],
    value: '',
    name: '',
    room: 'test',
  }
  client = new W3CWebSocket('ws://127.0.0.1:8000/ws/' + this.state.room + '/'); //gets room_name from the state and connects to the backend server 
  render(){
    }

}
</pre>
<p>现在，我们需要处理当组件安装到浏览器上时会发生什么。我们希望应用程序连接到后端服务器，并在组件挂载时获取消息，所以我们将使用<code>componentDidMount()</code>。您可以通过在<code>render()</code>函数之前粘贴以下代码来实现这一点:</p>
<pre class="language-javascript hljs">...
componentDidMount() {
    this.client.onopen = () =&gt; {
      console.log("WebSocket Client Connected");
    };
    this.client.onmessage = (message) =&gt; {
      const dataFromServer = JSON.parse(message.data);
      if (dataFromServer) {
        this.setState((state) =&gt; ({
          messages: [
            ...state.messages,
            {
              msg: dataFromServer.text,
              name: dataFromServer.sender,
            },
          ],
        }));
      }
    };
  }
render() {
...
</pre>
<p>接下来，我们将创建用于更新状态的表单。我们将创建一个表单来更新发送者的<code>name </code>和房间名称。然后，我们将创建另一个表单来处理表单提交。将下面的代码粘贴到<code>render()</code>函数中:</p>
<pre class="language-javascript hljs">render() {
    const { classes } = this.props;
    return (
      &lt;Container component="main" maxWidth="xs"&gt;
        {this.state.filledForm ? (
          &lt;div style={{ marginTop: 50 }}&gt;
            Room Name: {this.state.room}
            &lt;Paper
              style={{height: 500, maxHeight: 500, overflow: "auto", boxShadow: "none", }}
            &gt;
              {this.state.messages.map((message) =&gt; (
                &lt;&gt;
                  &lt;Card className={classes.root}&gt;
                    &lt;CardHeader title={message.name} subheader={message.msg} /&gt;
                  &lt;/Card&gt;
                &lt;/&gt;
              ))}
            &lt;/Paper&gt;
            &lt;form
              className={classes.form}
              noValidate
              onSubmit={this.onButtonClicked}
            &gt;
              &lt;TextField id="outlined-helperText" label="Write text" defaultValue="Default Value"
                variant="outlined"
                value={this.state.value}
                fullWidth
                onChange={(e) =&gt; {
                  this.setState({ value: e.target.value });
                  this.value = this.state.value;
                }}
              /&gt;
              &lt;Button type="submit" fullWidth variant="contained" color="primary"
                className={classes.submit}
              &gt;
                Send Message
              &lt;/Button&gt;
            &lt;/form&gt;
          &lt;/div&gt;
        ) : (
          &lt;div&gt;
            &lt;CssBaseline /&gt;
            &lt;div className={classes.paper}&gt;
              &lt;form
                className={classes.form}
                noValidate
                onSubmit={(value) =&gt; this.setState({ filledForm: true })}
              &gt;
                &lt;TextField variant="outlined" margin="normal" required fullWidth label="Room name"
                  name="Room name"
                  autoFocus
                  value={this.state.room}
                  onChange={(e) =&gt; {
                    this.setState({ room: e.target.value });
                    this.value = this.state.room;
                  }}
                /&gt;
                &lt;TextField variant="outlined" margin="normal" required fullWidth name="sender" label="sender"
                  type="sender"
                  id="sender"
                  value={this.state.name}
                  onChange={(e) =&gt; {
                    this.setState({ name: e.target.value });
                    this.value = this.state.name;
                  }}
                /&gt;
                &lt;Button type="submit" fullWidth variant="contained" color="primary"
                  className={classes.submit}
                &gt;
                  Submit
                &lt;/Button&gt;
              &lt;/form&gt;
            &lt;/div&gt;
          &lt;/div&gt;
        )}
      &lt;/Container&gt;
    );
  }

export default withStyles(useStyles)(App);</pre>
<p>当您填写房间名称和发送者姓名时，状态中的<code>filledForm</code>会变为<code>true</code>，然后会呈现输入消息的表单。在我们的代码中，我们使用了一些需要导入的MUI类。你可以将下面的代码粘贴到你的<code>App.js</code>文件的顶部:</p>
<pre class="language-javascript hljs">import Button from "@material-ui/core/Button";
import CssBaseline from "@material-ui/core/CssBaseline";
import TextField from "@material-ui/core/TextField";
import Container from "@material-ui/core/Container";
import Card from "@material-ui/core/Card";
import CardHeader from "@material-ui/core/CardHeader";
import Paper from "@material-ui/core/Paper";
import { withStyles } from "@material-ui/core/styles";
const useStyles = (theme) =&gt; ({
  submit: {
    margin: theme.spacing(3, 0, 2),
  },
});
</pre>
<p>一旦消息表单被提交，当点击提交按钮时，我们将把文本发送到后端服务器。将下面的代码粘贴到<code>componentDidMount()</code>函数的正上方:</p>
<pre class="language-javascript hljs">  onButtonClicked = (e) =&gt; {
    this.client.send(
      JSON.stringify({
        type: "message",
        text: this.state.value,
        sender: this.state.name,
      })
    );
    this.state.value = "";
    e.preventDefault();
  };
  componentDidMount() { 
...
</pre>
<h2 id="testing-application">测试应用程序</h2>
<p>既然我们已经完成了应用程序的编码，我们就可以测试它了。首先，通过运行以下命令启动后端服务器。确保您位于<code>manage.py</code>文件所在的目录中:</p>
<pre class="language-django hljs">python manage.py runserver
</pre>
<p>在另一个终端窗口上，导航到<code>frontend/</code>目录，通过运行下面的命令运行前端服务器。React应用程序将自动打开:</p>
<pre class="language-bash hljs">npm start
</pre>
<p>填写姓名和房间名称。然后，在另一个名称不同但房间名称相同的浏览器中打开该应用程序。现在，您可以开始与自己聊天，您会注意到消息是实时收到的:</p>
<p><img data-attachment-id="132061" data-permalink="https://blog.logrocket.com/build-chat-application-react-django-channels/attachment/real-time-chat-application-django-example/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/09/real-time-chat-application-django-example.png" data-orig-size="730,390" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="real-time-chat-application-django-example" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/09/real-time-chat-application-django-example-300x160.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/09/real-time-chat-application-django-example.png" decoding="async" class="aligncenter wp-image-132061 size-full jetpack-lazy-image" src="../Images/a459779e6ac60592512ca9d9d7275ef1.png" alt="Real Time Chat Application Django Example" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2022/09/real-time-chat-application-django-example.png 730w, https://blog.logrocket.com/wp-content/uploads/2022/09/real-time-chat-application-django-example-300x160.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2022/09/real-time-chat-application-django-example.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/09/real-time-chat-application-django-example.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="132061" data-permalink="https://blog.logrocket.com/build-chat-application-react-django-channels/attachment/real-time-chat-application-django-example/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/09/real-time-chat-application-django-example.png" data-orig-size="730,390" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="real-time-chat-application-django-example" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/09/real-time-chat-application-django-example-300x160.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/09/real-time-chat-application-django-example.png" decoding="async" loading="lazy" class="aligncenter wp-image-132061 size-full" src="../Images/a459779e6ac60592512ca9d9d7275ef1.png" alt="Real Time Chat Application Django Example" srcset="https://blog.logrocket.com/wp-content/uploads/2022/09/real-time-chat-application-django-example.png 730w, https://blog.logrocket.com/wp-content/uploads/2022/09/real-time-chat-application-django-example-300x160.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/09/real-time-chat-application-django-example.png"/></noscript>
<h2 id="conclusion">结论</h2>
<p>在本文中，我们已经了解了WebSockets及其应用，以及如何通过利用Django通道在Django中使用它。最后，我们介绍了如何使用React建立到Django服务器的WebSocket连接。</p>
<p>尽管我们构建了一个高效的实时聊天应用程序，但您仍然可以进行改进。例如，为了存储消息，可以包含一个数据库连接。作为本地后端的替代，您可以考虑使用Redis作为消息代理。</p>
<p>我希望你喜欢这篇文章，如果你有任何问题，一定要留下评论。编码快乐！</p>
<div class="code-block code-block-17">
<div class="blog-plug inline-plug react-plug" vwo-el-id="26283398190">
<h2 vwo-el-id="41600691720"><a href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener"> LogRocket </a>:全面了解您的生产React应用</h2><p>调试React应用程序可能很困难，尤其是当用户遇到难以重现的问题时。如果您对监视和跟踪Redux状态、自动显示JavaScript错误以及跟踪缓慢的网络请求和组件加载时间感兴趣，</p><a href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" vwo-el-id="19356441070">try LogRocket</a><p>. </p><a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="19356441380">
<img class="first-react-image alignnone size-full wp-image-46 jetpack-lazy-image jetpack-lazy-image--handled" src="../Images/f300c244a1a1cf916df8b4cb02bec6c6.png" vwo-el-id="18272717540" data-lazy-loaded="1" data-original-src="https://files.readme.io/27c94e7-Image_2017-06-05_at_9.46.04_PM.png"/>
</a>
<a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="19356441690">
<img class="second-react-image alignnone size-full wp-image-46 jetpack-lazy-image jetpack-lazy-image--handled" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" vwo-el-id="30720362350" data-lazy-loaded="1" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/>
</a>
<p vwo-el-id="28675660440" class="">LogRocket 结合了会话回放、产品分析和错误跟踪，使软件团队能够创建理想的web和移动产品体验。这对你来说意味着什么？</p>
<p>LogRocket不是猜测错误发生的原因，也不是要求用户提供截图和日志转储，而是让您回放问题，就像它们发生在您自己的浏览器中一样，以快速了解哪里出错了。</p>
<p>不再有嘈杂的警报。智能错误跟踪允许您对问题进行分类，然后从中学习。获得有影响的用户问题的通知，而不是误报。警报越少，有用的信号越多。</p>
<p vwo-el-id="28675660750">LogRocket Redux中间件包为您的用户会话增加了一层额外的可见性。LogRocket记录Redux存储中的所有操作和状态。</p>
<p vwo-el-id="28675661060">现代化您调试React应用的方式— <a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="40093418840">开始免费监控</a>。</p>
</div></div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>
 
 </div>    
</body>
</html>
<html>
<head>
<title>Dynamically managing state with Legend-State </title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>用图例状态动态管理状态</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/react-state-management-legend-state/#0001-01-01">https://blog.logrocket.com/react-state-management-legend-state/#0001-01-01</a></blockquote><div><article class="article-post">
<p>当使用React和React Native等前端框架构建现代应用程序时，管理状态始终是必要的，并且可能是开发人员最头疼的问题。开发人员需要确定正确的模式来管理应用程序中的状态。</p>
<p>本文将介绍如何使用Legend-State作为React应用程序的状态管理系统。我们将构建一个简单的例子来看看Legend-State是如何工作的，它的用例，以及它与其他状态管理工具有何不同。</p>
<p>向前跳:</p>

<h2 id="legend-state">什么是传奇国家？</h2>
<p><a href="https://legendapp.com/open-source/state"> Legend-State </a>是一个新的快速状态管理库，它提供了一种优化应用程序的方法，以获得最佳的性能、可扩展性和开发人员体验。传奇之州由杰伊·梅斯特里奇建造和维护。Legend-State设计有现代浏览器功能，被<a href="https://www.legendapp.com/">传奇</a>和<a href="https://www.bravely.io/">勇敢</a>等公司使用。</p>
<p>Legend-State旨在解决在React应用程序中管理状态时开发人员的性能和工作负载问题，React应用程序在默认情况下没有进行优化。图例状态通过仅在必要时重新渲染组件来提高应用程序的性能，并且它允许您控制在哪些状态下触发重新渲染。Legend-State使React更容易理解，有了它，开发人员可以比简单的、未优化的React实现编写更少的代码。</p>

<p>有许多状态管理库，每个都有一组独特的功能。这就是传奇国度与他们的不同之处。</p>
<h3 id="fine-grained-reactivity">细粒度反应性</h3>
<p>Legend-State的反应能力让React应用程序更快。它最大限度地减少了渲染次数，并确保组件中的每次更新都会导致最少的渲染次数。使组件变小可以最大限度地提高React的效率，因为它要求状态更改只重新呈现最少的组件。每当状态更新通过props沿树向下传递时，组件树中的每个组件都会重新呈现。</p>
<p>Legend-State的细粒度反应性使用两个组件来隔离子组件，以便它们根据其可观测量的变化进行重新渲染，而无需重新渲染父组件:</p>
<ul>
<li><code>Computed</code>:在这个组件中，子组件的改变不会影响或重新渲染父组件，但是父组件的改变会重新渲染子组件</li>
<li><code>Memo</code>:与<code>Computed</code>类似，<code>Memo</code>不会重新渲染父组件变化的子组件。只有当它的可观测量发生变化时，它才会重新渲染</li>
</ul>
<h3 id="simplicity">简单</h3>
<p>Legend-State非常容易使用，并且没有使用样板代码。它没有特殊的钩子、高阶组件、函数或上下文等。你只需要访问这些状态，你的组件就会自动更新。</p>
<h3 id="fast">又快又小</h3>
<p>legend-State<a href="https://www.legendapp.com/open-source/state/fast/">超快</a>，文件大小只有3Kb，提高了一个网站或app的性能。图例状态被设计为尽可能高效，它只在有变化时才重新呈现组件。</p>
<h3 id="unopinionated">未电离的</h3>
<p>Legend-State是非终结化的，允许团队声明全局或组件内的状态。Legend-State在React组件中创建状态对象，然后通过<code>props</code>或<code>Context</code>将它们传递给子组件:</p>
<pre class="language-javascript hljs">import { useObservable } from "@legendapp/state/react"

// via props
const ViaProps = ({ count }) =&gt; {
  return &lt;div&gt;Count: {count}&lt;/div&gt;
}
const App = () =&gt; {
  const count = useObservable(0)
  return &lt;ViaProps count={count} /&gt;
}

// via context
const ViaContext = () =&gt; {
    const count = useContext(StateContext);
    return (
        &lt;div&gt;
            Count: {count}
        &lt;/div&gt;
    )
}
const App = () =&gt; {
    const count = useObservable(0)
    return (
        &lt;StateContext.Provider value={count}&gt;
          &lt;ViaContext count={count} /&gt;
        &lt;/StateContext.Provider&gt;
    )
}
</pre>
<h3 id="persisting-state">持续状态</h3>
<p>Legend-State有内置的<a href="https://www.legendapp.com/open-source/state/persistence">持久性</a>插件，可以从本地或远程存储中保存和加载。这些插件包括用于web上本地存储的本地提供者和React Native中的<a href="https://github.com/mrousavy/react-native-mmkv"> react-native-mmkv </a>。这些插件经过了全面的测试，以确保其准确性。Legend-State正在为web和React Native开发Firebase和Firestore远程持久性插件。</p>
<p>此外，Legend-State支持TypeScript，可以在React本机应用程序中用于管理状态。</p>
<h2 id="getting-started-legend-state-react-application">React应用程序中的图例状态入门</h2>
<p>让我们构建一个简单的投票应用程序来了解Legend-State是如何工作的。首先，让我们用下面的代码创建一个项目:</p>
<pre class="language-javascript hljs">npm create-react-app legend-state-app
</pre>
<p>这将初始化一个新的React项目。现在将<code>cd</code>添加到<code>legend-state-app</code>中，并安装图例状态:</p>
<pre class="language-javascript hljs">npm install @legendapp/state
</pre>
<p>运行上面的命令后，我们的图例状态管理库将被安装在我们的项目文件夹中。</p>
<h3 id="creating-card-component">创建一个<code>Card</code>组件</h3>
<p>我们将在<code>src/components</code>中创建一个<code>Card.js</code>文件来显示每个玩家的信息。这将显示玩家的姓名、国籍、国家，以及一个增加和减少投票的按钮:</p>
<pre class="language-javascript hljs">import React from "react";
import { Computed } from '@legendapp/state/react';

const Card = (props) =&gt; {
    const { player, increasevoteCount, decreaseVoteCount } = props
    return (
        &lt;section className="container"&gt;
            &lt;h1 className="text"&gt;{player.name}&lt;/h1&gt;
            &lt;h3 className="normal-text"&gt;{player.country}&lt;/h3&gt;
            &lt;p className="normal-text"&gt;{player.club}&lt;/p&gt;
               &lt;button className="button" onClick={() =&gt; increasevoteCount(player.id)}&gt;Vote&lt;/button&gt;
               &lt;button className="button normal" onClick={() =&gt; decreaseVoteCount(player.id)}&gt;Unvote&lt;/button&gt;
        &lt;/section&gt;
    )
});
export default Card;
</pre>
<p><code>player</code>、<code>increasevoteCount</code>和<code>decreaseVoteCount</code>函数的值将来自父组件:<code>App.js</code>作为道具。当你点击<code>Vote</code>按钮时，它调用<code>increasevoteCount</code>并用它传递<code>player</code>的<code>ID</code>，当你点击<code>decreaseVoteCount</code>时它也这样做。</p>
<h3 id="creating-state-observables">用可观察的事物创造我们的国家</h3>
<p>现在，让我们使用可观测量来定义我们的状态，它将包含我们的应用程序中使用的所有状态及其功能。可观察对象是包含任何变量(原语、数组、深度嵌套对象、函数)的对象，这些变量可以在状态发生变化时更新。</p>
<p>React使用可观测量有不同的方式:</p>
<ul>
<li>使用<code>enableLegendStateReact()</code>功能直接渲染可观察值，以自动提取状态，作为一个单独的、存储的组件及其跟踪上下文</li>
<li>使用<code>observer</code> HOC使组件自动监控被访问的观察对象的变化</li>
<li>使用<code>useSelector</code>钩子来计算一个值会自动监控任何被访问的可观察值，并且只有当计算值改变时才会重新渲染结果</li>
</ul>
<p>对于这个项目，我们将直接使用<code>enableLegendStateReact()</code>来渲染可观测的物体。用下面的代码更新我们的<code>App.js</code>文件:</p>
<pre class="language-javascript hljs">import React from 'react';
import { enableLegendStateReact, Memo } from "@legendapp/state/react"
import { observable } from '@legendapp/state';

enableLegendStateReact();

const state = observable({
  players: [
    {id: 1, name: 'Messi', club: 'Paris', country: 'ARG',},
    {id: 2, name: 'Ronaldo', club: 'Manchester', country: 'POR'}
  ],
  voteForM: 0,
  voteForC: 0
})
</pre>
<p>我们使用图例状态库中的observable函数创建了一个状态。</p>
<p>在observable函数中，我们创建了一个保存玩家数据数组的存储和一个记录投票相关状态的存储，其初始值设置为0。</p>
<h3 id="accessing-modifying-state-observables">访问和修改可观测量中的状态</h3>
<p>为了访问<code>observable</code>的原始值，我们将使用<code>get()</code>函数:</p>
<pre class="language-javascript hljs">function App() {
  const playersData = state.players.get();

  return (
    &lt;section className='App'&gt;
      &lt;h2&gt;Vote the Best Football player in the world&lt;/h2&gt;
      &lt;Memo&gt;
        {() =&gt; &lt;h1&gt;Messi: {state.voteForM} - {state.voteForC}: Ronaldo&lt;/h1&gt;}
      &lt;/Memo&gt;
      &lt;div className='card-container'&gt;
        {
          playersData.map((player) =&gt; (
            &lt;div key={player.id} className="card"&gt;
              &lt;Card
               player={player}
               increasevoteCount={player.id === 1 ? voteForMessi : voteForRonaldo}
               decreaseVoteCount={player.id === 1 ? unVoteForMessi : unVoteForRonaldo}
              /&gt;
            &lt;/div&gt;
          ))
        }
      &lt;/div&gt;
    &lt;/section&gt;
  )
export default App;
</pre>
<p>在上面的代码中，我们有一个包含玩家的state属性值的变量<code>playersData</code>。我们使用<code>playerData</code>变量来映射玩家的数组，并将每个玩家的数据传递给<code>Card</code>组件。</p>
<p>我们还看到函数<code>increasevoteCount</code>和<code>decreaseVoteCount</code>被传递给<code>Card</code>组件，并用于<code>increase</code>和<code>decrease</code>每个玩家的投票。因此，当我们单击<code>Card</code>组件中的<code>vote</code>或<code>unvote</code>按钮时，它会将玩家的<code>id</code> <em> <em/> </em>值传递给<code>App.js</code>。</p>
<p>要增加和减少投票，我们必须定义函数来处理操作:</p>
<pre class="language-javascript hljs">// increase player vote 
 const voteForMessi = () =&gt;  state.voteForM.set(state.voteForM.get() + 1)
 const voteForRonaldo = () =&gt; state.voteForC.set(state.voteForC.get() + 1)

// decrease player vote
  const unVoteForMessi = () =&gt;  state.voteForM.set(state.voteForM.get() - 1)
  const unVoteForRonaldo = () =&gt; state.voteForC.set(state.voteForC.get() - 1)
</pre>
<p>该函数获取每个玩家的当前值，并增加或减少投票字段。图例状态观察值使用<code>set()</code>函数修改状态。还有其他功能:</p>

<h3 id="adding-styles">向我们的应用程序添加样式</h3>
<p>在这一点上，我们的应用程序看起来不是很好。因此，让我们添加一些样式来改变应用程序的外观。将<code>index.css</code>更新为以下代码:</p>
<pre class="language-javascript hljs">*{
  padding: 0;
  margin: 0;
  box-sizing: border-box;
}
.container{
  display: block;
  padding: 10px;
  width: 100%;
  max-width: 50rem;
  color: rgb(17 24 39 );
  border-radius: 0.5rem;
  box-shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
}
.text{
  font-size: 1.5rem;
  line-height: 2rem;
  font-weight: 700;
  letter-spacing: -0.025em;
  color: rgb(17 24 39);
}
.normal-text{
  font-weight: 500;
  color: rgb(55 65 81 );
}
.button{
  display: block;
  width: 100%;
  align-items: center;
  padding: 0.75rem 0;
  font-weight: 700;
  font-size: 1rem;
  line-height: 1.25rem;
  border-radius: 0.5rem;
  border: none;
  margin: 6px 0;
  color: rgb(255 255 255);
  background-color: rgb(29 78 216);
}
.button.normal{
  background-color: rgb(255 255 255);
  color: rgb(29 78 216);
  border: 1px solid rgb(29 78 216);
}
.button.normal:hover{
  color: rgb(255 255 255);
  background-color: rgb(29 78 216);
}
.button:hover{
  background-color: rgb(21, 57, 156);
}
.App {
  text-align: center;
  padding: 10px;
  line-height: 2rem;
}
.card{
  margin: 6px 0;
}
@media (min-width: 768px) {
  .card-container{
    width: 100%;
    display: flex;
    align-items: center;
    justify-content: center;
    margin: 20px;
    gap: 20px;
  }
  .card{
    margin: 6px 0;
    width: 30%;
  }
}
</pre>
<p>一旦我们运行<code>npm start</code>来启动应用程序，我们得到的是:</p>
<p><img data-attachment-id="142182" data-permalink="https://blog.logrocket.com/react-state-management-legend-state/attachment/voting-app-example/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/11/voting-app-example.gif" data-orig-size="600,270" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Voting app example" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/11/voting-app-example-300x135.gif" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/11/voting-app-example.gif" decoding="async" class="aligncenter size-full wp-image-142182 jetpack-lazy-image" src="../Images/c920457d36233ed16512d205ca4deca6.png" alt="Voting App Example" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2022/11/voting-app-example.gif?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/11/voting-app-example.gif"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="142182" data-permalink="https://blog.logrocket.com/react-state-management-legend-state/attachment/voting-app-example/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/11/voting-app-example.gif" data-orig-size="600,270" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Voting app example" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/11/voting-app-example-300x135.gif" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/11/voting-app-example.gif" decoding="async" loading="lazy" class="aligncenter size-full wp-image-142182" src="../Images/c920457d36233ed16512d205ca4deca6.png" alt="Voting App Example" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/11/voting-app-example.gif"/></noscript>
<h3 id="persisting-state">持续状态</h3>
<p>Legend-State提供了一个插件，用于保存状态，防止数据丢失。Legend-State使用<code>persistObservable</code>将来自应用程序的数据保存在本地存储或远程存储中。这样，无论我们重新加载还是关闭页面，状态都不会重置。</p>
<p>为了将我们的数据存储在本地存储中，我们将导入插件并对其进行全局配置:</p>
<pre class="language-javascript hljs">// App.js

import { configureObservablePersistence, persistObservable } from '@legendapp/state/persist';
import { ObservablePersistLocalStorage } from '@legendapp/state/local-storage';


configureObservablePersistence({
  // Use Local Storage on web
  persistLocal: ObservablePersistLocalStorage
});
</pre>
<p>现在，让我们为我们想要坚持的每个可观察值调用<code>persistObservable</code>:</p>
<pre class="language-javascript hljs">persistObservable(state.voteForC, {
  local: 'voteC',
})
persistObservable(state.voteForM, {
  local: 'voteM',
})
</pre>
<p>上面，我们保存了<code>state.voteForC</code>和<code>state.voteForM</code>的值。本地存储密钥被分配一个唯一的名称。有了这些，我们在投票和刷新页面时不会丢失任何新数据。</p>
<h3 id="api-request-legend-state">带有图例状态的API请求</h3>
<p>Legend-State还提供了在React组件中使用的钩子，就像普通的<code>useState</code>钩子和<code>useEffect</code>钩子一样。但是这一次，它只在必要的时候呈现可观察的事物。我们将使用这个钩子发出一个API请求:</p>
<pre class="language-javascript hljs">import {useObservable, useComputed, useObserve, Show } from '@legendapp/state/react'

  const user = useObservable(() =&gt;
    fetch("https://randomuser.me/api/").then(response =&gt; response.json())
  )
</pre>
<p>这里，我们使用了<code>useObservable</code>钩子来保存并使用<code>fetch</code>函数发出一个API请求，该函数获取关于一个随机用户的信息。<code>useObservable</code>钩子也有助于在一个状态中本地保存多个值，或者当该状态特定于组件的生命周期时:</p>
<pre class="language-javascript hljs"> const details = useComputed(() =&gt; {
    const u = user.results.get()
    return u ? `${u[0].name.first} ${u[0].gender} ${u[0].location.country}` : "";
  });

  useObserve(() =&gt; console.log(details.get()))
</pre>
<p>我们使用<code>useComputed</code>返回用户的姓名、性别和国家。<code>useComputed</code>钩子用于根据许多可观察值计算值，如果其中一个值发生变化，钩子将被更新，因为它跟踪自动计算时访问的可观察值。</p>
<p><code>useObserve</code>类似于<code>useEffect</code>。它只在可观察到的变化时采取行动:</p>
<pre class="language-javascript hljs">  return (
    &lt;div&gt;
      &lt;Show if={userName} else={&lt;div&gt;Loading...&lt;/div&gt;}&gt;
        &lt;div&gt;
          &lt;h1&gt;{userName[0].name.first} {userName[0].name.last}&lt;/h1&gt;
          &lt;p&gt;{userName[0].location.country}&lt;/p&gt;
          &lt;h2&gt;{userName[0].email}&lt;h2&gt;
        &lt;/div&gt;
      &lt;/Show&gt;
    &lt;/div&gt;
  );
</pre>
<p>这里，我们使用Legend-State中的<code>Show</code>组件有条件地呈现我们的数据。<code>Show</code>组件用于根据<code>if</code> / <code>else</code>道具有条件的渲染子组件，当条件改变时，父组件不渲染。</p><div class="code-block code-block-54">
<hr/>
<h3>更多来自LogRocket的精彩文章:</h3>

<hr/></div>
<h2 id="conclusion">结论</h2>
<p>在本文中，我们了解了Legend-State，这是React和React本机应用程序的状态管理库，致力于为我们的应用程序提供更好的性能，并为开发人员提供更好的体验。我们使用Legend-State创建了一个投票应用程序来管理状态，并详细说明了Legend-State与其他状态管理器的不同之处。祝您在下一个React或React本机应用程序中使用Legend-State时愉快！</p>
<h2 id="resources">资源</h2>

<p>使用LogRocket消除传统反应错误报告的噪音</p><div class="code-block code-block-17">
<div class="blog-plug inline-plug react-plug" vwo-el-id="26283398190">
<h2 vwo-el-id="41600691720">是一款React analytics解决方案，可保护您免受数百个误报错误警报的影响，只针对少数真正重要的项目。LogRocket告诉您React应用程序中实际影响用户的最具影响力的bug和UX问题。</h2>
<a href="https://lp.logrocket.com/blg/react-signup-issue-free" target="_blank" vwo-el-id="19356441070">LogRocket
</a><p>自动聚合客户端错误、反应错误边界、还原状态、缓慢的组件加载时间、JS异常、前端性能指标和用户交互。然后，LogRocket使用机器学习来通知您影响大多数用户的最具影响力的问题，并提供您修复它所需的上下文。</p><a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="19356441380">
<img class="first-react-image alignnone size-full wp-image-46 jetpack-lazy-image jetpack-lazy-image--handled" src="../Images/f300c244a1a1cf916df8b4cb02bec6c6.png" vwo-el-id="18272717540" data-lazy-loaded="1" data-original-src="https://files.readme.io/27c94e7-Image_2017-06-05_at_9.46.04_PM.png"/>
</a>
<a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="19356441690">
<img class="second-react-image alignnone size-full wp-image-46 jetpack-lazy-image jetpack-lazy-image--handled" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" vwo-el-id="30720362350" data-lazy-loaded="1" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/>
</a>
<a href="https://lp.logrocket.com/blg/react-signup-issue-free" target="_blank" rel="noopener noreferrer" vwo-el-id="35866400580">LogRocket
</a><p>关注重要的React bug—<a class="signup" href="https://lp.logrocket.com/blg/react-signup-issue-free" target="_blank" rel="noopener noreferrer" vwo-el-id="40093418840">今天就试试LogRocket】。</a></p><p vwo-el-id="28675661060">Focus on the React bugs that matter —
<a class="signup" href="https://lp.logrocket.com/blg/react-signup-issue-free" target="_blank" rel="noopener noreferrer" vwo-el-id="40093418840">try LogRocket today</a>.
</p>
</div></div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
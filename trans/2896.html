<html>
<head>
<title>Rust enums and pattern matching - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>Rust 枚举和模式匹配</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/rust-enums-and-pattern-matching/#0001-01-01">https://blog.logrocket.com/rust-enums-and-pattern-matching/#0001-01-01</a></blockquote><div><article class="article-post">
<p>模式匹配和枚举可以用于很多事情，比如错误处理、处理空值等等。在本文中，我们将回顾模式匹配的基础，枚举，并了解枚举如何用于模式匹配，包括:</p>

<p>但是，要阅读本文，您必须至少对 Rust 编程语言有一个基本的了解。</p>
<h2 id="pattern-matching-in-rust">Rust 中的模式匹配</h2>
<p>模式匹配是编程语言的一种机制，它允许程序流根据给定的输入分支到多个分支之一。</p>
<p>假设我们有一个名为<code>name</code>的变量，它是一个代表人名的字符串。对于每个名称，我们显示一个水果，如下所示:</p>
<ul>
<li><code>John =&gt; papaya</code></li>
<li><code>Annie =&gt; blueberry</code></li>
<li><code>Michael =&gt; guava</code></li>
<li><code>Gabrielle =&gt; apple</code></li>
<li><code>Others =&gt; orange</code></li>
</ul>
<p>在这里，我们创建了五个分支；<code>=&gt;</code>左边的名字代表一个名字模式，右边的果实是会显示的分支。所以如果<code>name</code>是<code>John</code>，我们显示一个<code>papaya</code>，如果<code>name</code>是<code>Annie,</code>，我们显示<code>blueberry</code>，以此类推。</p>
<p>但是，如果<code>name</code>的值不是注册的模式，则默认为<code>Others</code>。</p>
<p>在 Rust 中，我们使用<code>match</code>语句执行模式匹配，我们可以在下面的代码中使用前面的例子:</p>
<pre class="language-rust hljs">match name {
  "John" =&gt; println!("papaya"),
  "Annie" =&gt; println!("blueberry"),
  "Michael" =&gt; println!("guava"),
  "Gabrielle" =&gt; println!("apple"),
  _ =&gt; println!("orange"),
}</pre>
<p>Rust 中的<code>match</code>语句的工作方式类似于 C++、Java、JavaScript 等其他编程语言中的<code>switch</code>语句。但是，<code>match</code>陈述比<code>switch</code>陈述有一些优势。</p>
<p>首先，它检查上面第一行的变量<code>name</code>是否匹配<code>=&gt;</code>左侧的任何值，然后执行匹配模式右侧的值。</p>
<p>如果所有模式与<code>name</code>变量不匹配，则默认为<code>_</code>(匹配每个值)并在终端显示<code>orange</code>。这就像我们之前看到的<code>Others</code>图案一样。</p>
<p>像这样创建模式匹配是非常强大的，但是如果我们想要执行一行以上的代码，我们用一个包含您想要执行的所有行的代码块替换<code>match</code>块中<code>=&gt;</code>的右侧。</p>
<p>在下面的例子中，我们修改了前面的<code>match</code>语句，为每个名字打印一个数字和一种颜色以及水果:</p>
<pre class="language-rust hljs">match name {
  "John" =&gt; {
    println!("4");
    println!("green");
    println!("papaya");
  },
  "Annie" =&gt; {
    println!("3");
    println!("blue");
    println!("blueberry");
  },
  "Michael" =&gt; {
    println!("2");
    println!("yellow");
    println!("guava");
  },
  "Gabrielle" =&gt; {
    println!("1");
    println!("purple");
    println!("apple");
  },
  _ =&gt; {
    println!("0");
    println!("orange");
    println!("orange");
  },
}</pre>
<p>在这里，我们转换了简单的行:</p>
<pre class="language-rust hljs">_ =&gt; println!("orange"),</pre>
<p>在<code>match</code>上执行多行代码的语句:</p>
<pre class="language-rust hljs">_ =&gt; {
    println!("0");
    println!("orange");
    println!("orange");
  },</pre>
<p>有了这个，我们可以执行不止一行。而且，如果我们想要返回值，我们可以使用 return 语句或者 Rust 的 return 快捷方式。快捷方式是通过删除最后一个表达式的分号来实现的:</p>
<pre class="language-rust hljs">_ =&gt; {
    println!("0");
    println!("orange");
    println!("orange");
    "This is for the others"
  },</pre>
<p>或者使用以下方法:</p>
<pre class="language-rust hljs">_ =&gt; {
    println!("0");
    println!("orange");
    println!("orange");
    return "This is for the others";
  },</pre>
<p>单线模式也将表达式的值返回到<code>=&gt;</code>的右侧，因此您可以执行以下操作:</p>
<pre class="language-rust hljs">let result = match name {
  "John" =&gt; "papaya",
  "Annie" =&gt; "blueberry",
  "Michael" =&gt; "guava",
  "Gabrielle" =&gt; "apple",
  _ =&gt; "orange",
};

println!("{}", result);</pre>
<p>这与第一个<code>match</code>语句示例的作用相同。</p>
<h2 id="using-enums-in-rust">在 Rust 中使用枚举</h2>
<p>枚举是表示具有多个变量的数据类型的可靠数据结构。枚举可以执行与结构相同的操作，但使用的内存和代码行更少。</p>
<p>我们可以在操作中使用枚举的任何变体，但是，我们只能使用基本枚举来指定我们将从函数中返回一个变体或者将它赋给一个变量。</p>
<p>这意味着基本枚举本身不能赋给变量。举一个枚举的例子，让我们创建一个具有三个变量的<code>vehicle</code>枚举:<code>Car</code>、<code>MotorCycle</code>和<code>Bicycle</code>。</p>
<pre class="language-rust hljs">enum Vehicle {
  Car,
  MotorCycle,
  Bicycle,
}</pre>
<p>然后，我们可以通过编写<code>Vehicle::&lt;variant&gt;</code>来访问变量:</p>
<pre class="language-rust hljs">let vehicle = Vehicle::Car;</pre>
<p>如果你想静态地输入它，你可以这样写:</p>
<pre class="language-rust hljs">let vehicle: Vehicle = Vehicle::Car;</pre>
<h3 id="pattern-matching-with-enums">枚举模式匹配</h3>
<p>正如我们可以对字符串、数字和其他数据类型执行模式匹配一样，我们也可以匹配枚举变量:</p>
<pre class="language-rust hljs">match vehicle {
    Vehicle::Car =&gt; println!("I have four tires"),
    Vehicle::MotorCycle =&gt; println!("I have two tires and run on gas"),
    Vehicle::Bicycle =&gt; println!("I have two tires and run on your effort")
  }</pre>
<p>在此，我们:</p>
<ol>
<li>将变量传递到一个<code>match</code>语句中</li>
<li>创建模式以匹配单个变体</li>
<li>编码一旦变量匹配任何模式将执行什么</li>
</ol>
<p>所以，我们可以写一个这样的程序:</p>
<pre class="language-rust hljs">enum Vehicle {
  Car,
  MotorCycle,
  Bicycle,
}

fn main() {
  let vehicle = Vehicle::Car;

  match vehicle {
    Vehicle::Car =&gt; println!("I have four tires"),
    Vehicle::MotorCycle =&gt; println!("I have two tires and run on gas"),
    Vehicle::Bicycle =&gt; println!("I have two tires and run on your effort")
  }
}</pre>
<p>这将导致以下结果:</p>
<pre class="language-rust hljs">&gt; rustc example.rs
&gt; ./example

I have four tires</pre>
<h3 id="adding-data-to-enum-variants">向枚举变量添加数据</h3>
<p>我们还可以向枚举变量中添加数据。我们必须通过添加一个括号来指定我们的变量可以保存数据，括号中包含它将保存的数据类型:</p>
<pre class="language-rust hljs">enum Vehicle {
  Car(String),
  MotorCycle(String),
  Bicycle(String),
}</pre>
<p>然后，我们可以这样使用它:</p>
<pre class="language-rust hljs">fn main() {
  let vehicle = Vehicle::Car("red".to_string());

  match vehicle {
    Vehicle::Car(color) =&gt; println!("I am {} and have four tires", color),
    Vehicle::MotorCycle(color) =&gt; println!("I am {} and have two tires and run on gas", color),
    Vehicle::Bicycle(color) =&gt; println!("I am {} and have two tires and run on your effort", color)
  }
}</pre>
<p>在此，我们:</p>
<ol>
<li>创建枚举的新实例，并将其赋给一个变量</li>
<li>将该变量放在一个<code>match</code>语句中</li>
<li>将每个枚举变量的内容析构到<code>match</code>语句中的一个变量中</li>
<li>在模式右侧的代码块中使用了析构变量。</li>
</ol>
<h2 id="result-and-option-enums"><code>Result</code>和<code>Option</code>枚举</h2>
<p><code>Result</code>和<code>Option</code>枚举是 Rust 中用于处理函数或变量的结果、错误和空值的标准库的一部分。</p>
<h3 id="result-enum"><code>Result</code>枚举</h3>
<p>这是 Rust 中一个非常常见的枚举，用于处理函数或变量的错误。它有两种变体:<code>Ok</code>和<code>Err</code>。</p>
<p>如果没有错误，<code>Ok</code>变量保存返回的数据，而<code>Err</code>变量保存错误消息。例如，我们可以创建一个返回枚举变量的函数:</p>
<pre class="language-rust hljs">fn divide(numerator: i32, denominator: i32) -&gt; Result&lt;i32, String&gt; {
    if denominator == 0 {
        return Err("Cannot divide by zero".to_string());
    } else {
        return Ok(numerator / denominator);
    }
}</pre>
<p>这个函数有两个参数。第一个是分子，第二个是分母。如果分母为零，则返回变量<code>Result::Err</code>，如果分母不为零，则返回结果<code>Result::Ok </code>。</p>
<p>然后，我们可以使用模式匹配函数:</p>
<pre class="language-rust hljs">fn main() {
    match divide(103, 2) {
        Ok(solution) =&gt; println!("The answer is {}", solution),
        Err(error) =&gt; println!("Error: {}", error)
    }
}</pre>
<p>在这个例子中；</p>
<ol>
<li>我们试图<code>divide 103 by 2</code></li>
<li>创建<code>Ok</code>模式匹配并提取它包含的数据。</li>
<li>在此之下，创建一个获取任何错误消息的<code>Err</code>模式</li>
</ol>
<p><code>Result</code>枚举还允许我们在不使用<code>match</code>语句的情况下处理错误。这意味着我们可以使用以下任何或所有选项:</p>
<ul>
<li><code>Unwrap</code>获取<code>Ok</code>变量中的数据</li>
<li><code>Unwrap_err</code>从<code>result</code>的<code>Err</code>变体中获取错误信息</li>
<li>如果值是一个<code>Err</code>变量，则<code>is_err</code>返回 true</li>
<li><code>Is_ok</code>确定该值是否为<code>Ok</code>变量<pre class="language-rust hljs">let number = divide(103, 2); if number.is_err() {   println!("Error: {}", number.unwrap_err()); } else if number.is_ok() {   println!("The answer is {}", number.unwrap()); }</pre></li>
</ul>
<p>Rust 中的所有<code>Result</code>枚举值都必须被使用，否则我们会收到来自编译器的警告，告诉我们有一个未使用的<code>Result</code>枚举。</p>
<h3 id="option-enum"><code>Option</code>枚举</h3>
<p>在 Rust 中使用<code>Option</code>枚举来表示可选值。它有两种变体:<code>Some</code>和<code>None</code>。</p>
<p>当输入包含值时使用<code>Some</code>，而<code>None</code>表示没有值。它通常与模式匹配语句一起使用，以处理函数或表达式中缺少可用值的情况。</p>
<p>所以在这里，我们可以修改<code>divide</code>函数，使用<code>Options</code>枚举来代替<code>Result</code>:</p>
<pre class="language-rust hljs">fn divide(numerator: i32, denominator: i32) -&gt; Option&lt;i32&gt; {
    if denominator == 0 {
        return None;
    } else {
        return Some(numerator / denominator);
    }
}</pre>
<p>在这个新的<code>divide</code>函数中，我们将返回类型从<code>Result</code>更改为<code>Option</code>，因此如果分母为零，则返回<code>None</code>，如果分母不为零，则返回结果<code>Some</code>。</p>
<p>然后，我们可以按以下方式使用新的<code>divide</code>函数:</p>
<pre class="language-rust hljs">fn main() {
    match divide(103, 0) {
        Some(solution) =&gt; println!("The answer is {}", solution),
        None =&gt; println!("Your numerator was about to be divided by zero :)")
    }
}</pre>
<p>在这个主函数中，我们将<code>Ok</code>变量从<code>Result</code>改为<code>Some</code>，将<code>Err</code>改为<code>None</code>。</p><div class="code-block code-block-54">
<hr/>
<h3>更多来自 LogRocket 的精彩文章:</h3>

<hr/></div>
<p>就像使用<code>Result</code>枚举一样，我们可以使用以下代码:</p>
<ul>
<li><code>unwrap</code>方法检索包含在<code>Some</code>中的值</li>
<li><code>unwrap_or</code>方法收集<code>Some</code>中的数据，如果表达式为<code>None</code>，则返回默认值</li>
<li><code>is_some</code>检查它是否不是<code>None</code></li>
<li><code>is_none</code>检查值是否为<code>None</code></li>
</ul>
<pre class="language-rust hljs">fn main() {

    let number = divide(103, 0);

    if number.is_some() {
        println!("number is: {}", number.unwrap());
    } else {
        println!("Is the result none: {}", number.is_none());
        println!("Result: {}", number.unwrap_or(0));
    }
}</pre>
<h2 id="conclusion">结论</h2>
<p>在本文中，我们看到了枚举和模式匹配是如何工作的，以及<code>match</code>语句如何比<code>switch</code>语句更高级。</p>
<p>最后，我们看到了如何使用枚举通过保存数据来改进模式匹配。</p>
<p>我希望这篇文章已经帮助您完全理解了模式匹配和枚举是如何工作的。如果你有任何不明白的地方，一定要在评论中告诉我。</p>
<p>感谢您的阅读，祝您愉快！</p><div class="code-block code-block-29">
<div class="blog-plug inline-plug rust-plug"><h2><a href="https://lp.logrocket.com/blg/rust-signup" target="_blank">log rocket</a>:Rust 应用的 web 前端的全面可见性</h2><p>调试 Rust 应用程序可能很困难，尤其是当用户遇到难以重现的问题时。如果您对监控和跟踪 Rust 应用程序的性能、自动显示错误、跟踪缓慢的网络请求和加载时间感兴趣，</p><a href="https://lp.logrocket.com/blg/rust-signup" target="_blank">try LogRocket</a><p>. </p><a class="signup" href="https://lp.logrocket.com/blg/rust-signup" target="_blank" rel="noopener noreferrer"><img class="alignnone size-full wp-image-46 jetpack-lazy-image" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/><noscript><img data-lazy-fallback="1" class="alignnone size-full wp-image-46" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/></noscript></a><p>LogRocket 就像是网络和移动应用程序的 DVR，记录你的 Rust 应用程序上发生的一切。您可以汇总并报告问题发生时应用程序的状态，而不是猜测问题发生的原因。LogRocket 还可以监控应用的性能，报告客户端 CPU 负载、客户端内存使用等指标。</p><p>现代化调试 Rust 应用的方式— <a class="signup" href="https://lp.logrocket.com/blg/rust-signup" target="_blank" rel="noopener noreferrer">开始免费监控</a>。</p></div>


</div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
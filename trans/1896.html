<html>
<head>
<title>React Hooks: The good, the bad, and the ugly - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>React Hooks:好的、坏的和丑陋的博客</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/react-hooks-the-good-the-bad-and-the-ugly/#0001-01-01">https://blog.logrocket.com/react-hooks-the-good-the-bad-and-the-ugly/#0001-01-01</a></blockquote><div><article class="article-post">
<p>随着<a href="https://blog.logrocket.com/introducing-react-16-8-featuring-official-support-for-hooks/" target="_blank" rel="noopener"> React 16.8 </a>的发布，钩子突然出现，其崇高的目标是改变我们编写 React 组件的方式。尘埃落定，钩子无处不在。钩子成功了吗？</p>
<p>最初的营销把钩子作为摆脱类组件的一种方式。类组件的主要问题是可组合性很难。重新共享生命周期事件<code>componentDidMount</code>和朋友中包含的逻辑导致了像<a href="https://reactjs.org/docs/higher-order-components.html" target="_blank" rel="noopener">高阶组件</a>和<code><a href="https://reactjs.org/docs/render-props.html" target="_blank" rel="noopener">renderProps</a></code>这样的模式，它们是具有边缘情况的笨拙模式。钩子最大的优点是它们能够隔离横切关注点，并且是可组合的。</p>
<h2>好人</h2>
<p>钩子做得好的是封装状态和共享逻辑。得益于钩子，<code><a href="https://reactrouter.com/web/guides/quick-start" target="_blank" rel="noopener">react-router</a></code>和<code><a href="https://react-redux.js.org/" target="_blank" rel="noopener">react-redux</a></code>等库包拥有更简单、更干净的 API。</p>
<p>下面是一些使用老式<a href="https://react-redux.js.org/api/connect" target="_blank" rel="noopener"> <code>connect</code> API </a>的示例代码。</p>
<pre class="language-typescript hljs">import React from 'react';
import { Dispatch } from 'redux';
import { connect } from 'react-redux';
import { AppStore, User } from '../types';
import { actions } from '../actions/constants';
import { usersSelector } from '../selectors/users';

const mapStateToProps = (state: AppStore) =&gt; ({
  users: usersSelector(state)
});

const mapDispatchToProps = (dispatch: Dispatch) =&gt; {
  return {
    addItem: (user: User) =&gt; dispatch({ type: actions.ADD_USER, payload: user })
  }
}

const UsersContainer: React.FC&lt;{users: User[], addItem: (user: User) =&gt; void}&gt; = (props) =&gt; {
  return (
    &lt;&gt;
      &lt;h1&gt;HOC connect&lt;/h1&gt;
      &lt;div&gt;
        {
          users.map((user) =&gt; {
            return (
              &lt;User user={user} key={user.id} dispatchToStore={props.addItem} /&gt;
            )
          })
        }
      &lt;/div&gt;
    &lt;/&gt;
  )
};

export default connect(mapStateToProps, mapDispatchToProps)(UsersContainer);
</pre>
<p>像这样的代码臃肿且重复。输入<code>mapStateToProps</code>和<code>mapDispatchToProps</code>很烦人。</p>
<p>下面是为了使用钩子而重构的相同代码:</p>
<pre class="language-typescript hljs">import React from 'react';
import { useSelector, useDispatch } from 'react-redux';
import { AppStore, User } from '../types';
import { actions } from '../actions/constants';

export const UsersContainer: React.FC = () =&gt; {
  const dispatch = useDispatch();
  const users: User[] = useSelector((state: AppStore) =&gt; state.users);

  return (
    &lt;&gt;
      &lt;h1&gt;Hooks&lt;/h1&gt;
      {
        users.map((user) =&gt; {
          return (
            &lt;User user={user} key={user.id} dispatchToStore={dispatch} /&gt;
          )
        })
      }
    &lt;/&gt;
  )
};
</pre>
<p>区别是白天和黑夜。钩子提供了一个更简洁的 API。钩子还消除了将所有东西包装在一个组件中的需要，这是另一个巨大的胜利。</p>
<h2>坏事</h2>
<h3>依赖数组</h3>
<p><a href="https://blog.logrocket.com/guide-to-react-useeffect-hook/"> <code>useEffect</code>钩子</a>接受一个函数参数和一个依赖数组作为第二个参数。</p>
<pre class="language-typescript hljs">import React, { useEffect, useState } from 'react';

export function Home() {
  const args = ['a'];
  const [value, setValue] = useState(['b']);

  useEffect(() =&gt; {
    setValue(['c']);
  }, [args]);

  console.log('value', value);
}
</pre>
<p>上面的代码将导致<code>useEffect</code>钩子无限旋转，因为这个看似无害的赋值:</p>
<pre class="language-typescript hljs">  const args = ['a'];
</pre>
<p>在每次新渲染时，React 将保留上一次渲染的依赖数组的副本。React 会将当前的依赖数组与前一个进行比较。使用<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is" target="_blank" rel="noopener"> <code>Object.is</code>方法</a>比较每个元素，以确定<code>useEffect</code>是否应该使用新值再次运行。对象是通过引用而不是通过值进行比较的。变量<code>args</code>将在每次重新渲染时成为一个新的对象，并且在内存中有一个与上次不同的地址。</p>
<p>突然间，变量赋值可能会有陷阱。不幸的是，围绕依赖数组有很多很多类似的陷阱。在依赖数组中内联创建一个 arrow 函数会导致同样的命运。</p>
<p>当然，解决方法是使用更多的钩子:</p>
<pre class="language-typescript hljs">import React, { useEffect, useState, useRef } from 'react';

export function Home() {
  const [value, setValue] = useState(['b']);
  const {current:a} = useRef(['a'])
  useEffect(() =&gt; {
    setValue(['c']);
  }, [a])
}
</pre>
<p>将标准的 JavaScript 代码打包成过多的<code><a href="https://blog.logrocket.com/usestate-vs-useref/" target="_blank" rel="noopener">useRef</a></code>、<code><a href="https://blog.logrocket.com/rethinking-hooks-memoization/" target="_blank" rel="noopener">useMemo</a></code>或<code><a href="https://blog.logrocket.com/react-usememo-vs-usecallback-a-pragmatic-guide/" target="_blank" rel="noopener">useCallback</a></code>钩子变得令人困惑和尴尬。<a href="https://www.npmjs.com/package/eslint-plugin-react-hooks" target="_blank" rel="noopener">eslit-plugin-reactor-hooks 插件</a>做了一个合理的工作，保持你在直截了当和狭窄，但臭虫并不少见，eslit 插件应该是一个补充，而不是强制性的。</p>
<h2>丑陋的</h2>
<p>我最近发布了一个 react 挂钩<a href="https://github.com/dagda1/cuttingedge/blob/main/packages/react-abortable-fetch/">react-aboratable-fetch</a>，将<code>runner</code>函数包装在<code>useRef</code>、<code>useCallback</code>或<code>useMemo</code>的组合中并不是一个很好的体验:</p>
<pre class="language-typescript hljs">const runner = useCallback(() =&gt; {
  task.current = run(function* (scope) {
    counter.current += 1;
    send(start);

    try {
        for (const job of fetchClient.current.jobs) {
          const {
            fetch: {
              request,
              init,
              contentType,
              onQuerySuccess = parentOnQuerySuccess,
              onQueryError = parentOnQueryError,
            },
          } = job;

          timeoutRef.current = timeout ? timeout : undefined;

// etc.</pre>
<p>产生的依赖数组非常大，并且需要随着代码的改变而保持最新，这很烦人。</p>
<pre class="language-typescript hljs">  }, [
    send,
    timeout,
    onSuccess,
    parentOnQuerySuccess,
    parentOnQueryError,
    retryAttempts,
    fetchType,
    acc,
    retryDelay,
    onError,
    abortable,
    abortController,
  ]);
</pre>
<p>最后，我必须小心地使用<code>useMemo</code>来记忆钩子函数的返回值，当然，还要处理另一个依赖数组:</p>
<pre class="language-typescript hljs">const result: QueryResult&lt;R&gt; = useMemo(() =&gt; {
    switch (machine.value as FetchStates) {
      case 'READY':
        return {
          state: 'READY',
          run: runner,
          reset: resetable,
          abort: aborter,
          data: undefined,
          error: undefined,
          counter: counter.current,
        };
      case 'LOADING':
        return {
          state: 'LOADING',
          run: runner,
          reset: resetable,
          abort: aborter,
          data: undefined,
          error: undefined,
          counter: counter.current,
        };
      case 'SUCCEEDED':
        return {
          state: 'SUCCEEDED',
          run: runner,
          reset: resetable,
          abort: aborter,
          data: machine.context.data,
          error: undefined,
          counter: counter.current,
        };
      case 'ERROR':
        return {
          state: 'ERROR',
          error: machine.context.error,
          data: undefined,
          run: runner,
          reset: resetable,
          abort: aborter,
          counter: counter.current,
        };
    }
  }, [machine.value, machine.context.data, machine.context.error, runner, resetable, aborter]);</pre>
<h3>执行次序</h3>
<p>钩子每次需要按照钩子的“<a href="https://reactjs.org/docs/hooks-rules.html" target="_blank" rel="noopener">规则”中规定的顺序运行:</a></p>
<blockquote><p>不要在循环、条件或嵌套函数中调用钩子。</p></blockquote>
<p>看起来很奇怪，React 开发人员没有想到会在事件处理程序中执行钩子。</p>
<p>通常的做法是从钩子返回一个函数，这个函数可以不按照钩子的顺序执行:</p>
<pre class="language-typescript hljs">const { run, state } = useFetch(`/api/users/1`, { executeOnMount: false });

return (
  &lt;button
    disabled={state !== 'READY'}
    onClick={() =&gt; {
      run();
    }}
  &gt;
    DO IT
  &lt;/button&gt;
);
</pre>
<h2>判决</h2>
<p>前面提到的<code>react-redux</code>代码的简化是引人注目的，并且导致了优秀的净代码减少。Hooks 比以前的现有产品需要更少的代码，仅此一点就应该让 Hooks 变得显而易见。</p>
<p>钩子的利大于弊，但并不是压倒性的胜利。钩子是一个优雅而聪明的想法，但是在实践中使用起来会很有挑战性。手动管理依赖图并在所有正确的地方记忆可能是大多数问题的根源，这需要重新思考。生成器函数可能更适合这里，因为它们有暂停和恢复执行的漂亮、独特的能力。</p>
<p>闭包是陷阱和陷阱的发源地。陈旧的闭包可以引用不是最新的变量。在使用钩子时，对闭包的了解是入门的一个障碍，为了进行调试，您必须具备这方面的知识。</p><div class="code-block code-block-17">
<div class="blog-plug inline-plug react-plug" vwo-el-id="26283398190">
<h2 vwo-el-id="41600691720">使用 LogRocket 消除传统反应错误报告的噪音</h2>
<a href="https://lp.logrocket.com/blg/react-signup-issue-free" target="_blank" vwo-el-id="19356441070">LogRocket
</a><p>是一款 React analytics 解决方案，可保护您免受数百个误报错误警报的影响，只针对少数真正重要的项目。LogRocket 告诉您 React 应用程序中实际影响用户的最具影响力的 bug 和 UX 问题。</p><a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="19356441380">
<img class="first-react-image alignnone size-full wp-image-46 jetpack-lazy-image jetpack-lazy-image--handled" src="../Images/f300c244a1a1cf916df8b4cb02bec6c6.png" vwo-el-id="18272717540" data-lazy-loaded="1" data-original-src="https://files.readme.io/27c94e7-Image_2017-06-05_at_9.46.04_PM.png"/>
</a>
<a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="19356441690">
<img class="second-react-image alignnone size-full wp-image-46 jetpack-lazy-image jetpack-lazy-image--handled" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" vwo-el-id="30720362350" data-lazy-loaded="1" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/>
</a>
<a href="https://lp.logrocket.com/blg/react-signup-issue-free" target="_blank" rel="noopener noreferrer" vwo-el-id="35866400580">LogRocket
</a><p>自动聚合客户端错误、反应错误边界、还原状态、缓慢的组件加载时间、JS 异常、前端性能指标和用户交互。然后，LogRocket 使用机器学习来通知您影响大多数用户的最具影响力的问题，并提供您修复它所需的上下文。</p><p vwo-el-id="28675661060">关注重要的 React bug—<a class="signup" href="https://lp.logrocket.com/blg/react-signup-issue-free" target="_blank" rel="noopener noreferrer" vwo-el-id="40093418840">今天就试试 LogRocket】。</a></p>
</div></div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
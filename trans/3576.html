<html>
<head>
<title>Password hashing in Node.js with bcrypt </title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>使用bcrypt在Node.js中进行密码散列</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/password-hashing-node-js-bcrypt/#0001-01-01">https://blog.logrocket.com/password-hashing-node-js-bcrypt/#0001-01-01</a></blockquote><div><article class="article-post">
<p>任何系统设计者的最大责任是保护用户数据。数据泄露会造成价值数百万的损失，根据Imperva的调查，美国的数据泄露成本最高。</p>
<p>当数据只是纯文本时，误用数据的可能性更高。如果您未能保护数据，下一步是通过加密使其不可读，这样攻击者就不会从中获得太多信息。例如，假设有人获得了你社交媒体个人资料的电子邮件和密码。在这种情况下，很容易在你不知情的情况下访问你的个人资料。但是，如果你的密码被加密了会怎么样呢？即使在攻击后，您的帐户也是安全的。</p>
<p>如果你想保护用户的邮件，那很好，但是保护用户密码是必须的。尽管用户必须设置强密码，但用户和系统都要进行密码保护。幸运的是，有许多方法可以执行加密/解密来帮助提高密码的安全性。本文将向您展示如何对Node.js中的bcrypt库使用密码散列。</p>
<p><em>向前跳转:</em></p>

<h2 id="password-hashing">什么是密码哈希？</h2>
<p><a href="https://blog.logrocket.com/building-a-password-hasher-in-node-js/">密码哈希</a>是使用特定算法将密码转换为字母数字的过程。当坏人破坏数据时，散列是有益的。有了哈希，他们得到的数据是哈希格式的，哈希后的数据是无法理解的。一些流行的密码哈希算法包括bcrypt和SHA。在本文中，我们将重点介绍如何使用bycrypt来散列Node.js中的密码。</p>
<pre class="language-shell hljs">hash('<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="f5bd908c85948686829a8791bc86a6949390b5">[email protected]</a>') = 1b21hb2hb1u2gu3g2fxy1v2ux1v2y3vu12g4u3ggvgu43598sa89da98sd79adshuavusdva9sdguasd
</pre>
<h2 id="password-hashing-node-js-bcrypt">使用bcrypt在Node.js中进行密码散列</h2>
<p>Bcrypt是一个l <a href="https://www.npmjs.com/package/bcrypt">库，帮助你散列密码</a>。它使用基于<a href="https://en.wikipedia.org/wiki/Blowfish_(cipher)"> Blowfish密码</a>的<a href="https://en.wikipedia.org/wiki/Password-hashing_function"> <code>password-hashing</code>函数</a>。Blowfish密码是一种对称分组密码，可提供业界最佳的加密速率；因此，它可以用于密码套件和加密产品。</p>
<p>Bcrypt使用<a href="https://en.wikipedia.org/wiki/Salt_(cryptography)"> salt </a>来抵御彩虹表、暴力等攻击。Bcrypt是一个自适应函数，所以如果你频繁调用bcrypt的函数，它会变得更慢。这阻碍了攻击者从暴力攻击中获益的能力。</p>
<h3 id="bcrypt-dependencies">Bcrypt依赖项</h3>
<p>Bcrypt需要一些依赖项才能正常工作。Bcrypt需要<a href="https://github.com/nodejs/node-gyp"> node-gyp </a>包，该包为<a href="https://blog.logrocket.com/tag/node/"> Node.js </a>编译本地附加模块。Bcrypt也依赖于<a href="https://blog.logrocket.com/implementing-cryptography-python/"> Python </a>，你将需要≥v2.x. Windows用户需要C#和C++选项随他们的VS实例一起安装。您还将需要<a href="https://www.openssl.org/"> OpenSSL v0.7.7 </a>。</p>
<h2 id="examples-password-hashing-bcrypt-node-js">Node.js中使用bcrypt的密码哈希示例</h2>
<p>出于数据安全的考虑，在存储用户密码之前，对其进行加盐和哈希处理是非常重要的。Bcrypt将简单的密码转换成称为哈希的固定长度字符。在散列密码之前，bcrypt应用一个<code>salt</code>，这是一个独特的随机字符串，使散列不可预测。</p>
<p>让我们创建一个Node.js项目，并使用bcrypt散列密码。制作了一个<code>server</code>文件后，需要安装bcrypt:</p>
<pre class="language-shell hljs">$ mkdir bcrypt_demo
$ cd mkdir
$ npm init -y
$ touch app.js
$ npm install bcrypt --save
</pre>
<p>现在，您已经准备好使用bcrypt了。让我们导入它并将<code>saltRounds</code>定义为成本或工作因素:</p>
<pre class="language-javascript hljs">const bcrypt = require("bcrypt")
const saltRounds = 10
const password = "<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="a6e7c2cbcfc8e6979495">[email protected]</a>"
</pre>
<h3 id="password-encryption-node-js-using-javascript-async-promise">Node.js中使用JavaScript <code>async</code> promise的密码加密</h3>
<p>JavaScript <code>Promise</code>是由<a href="https://blog.logrocket.com/the-visual-learners-guide-to-async-js-62a0a03d1d57/"> <code>async</code> </a>函数返回的对象，表示当前状态。当<code>Promise</code>返回给调用者时，它根据条件提供处理操作成功或失败的方法。</p>
<p>密码加密有两种方法。下面是第一种方法:</p>
<pre class="language-javascript hljs">bcrypt
  .genSalt(saltRounds)
  .then(salt =&gt; {
    console.log('Salt: ', salt)
    return bcrypt.hash(password, salt)
  })
  .then(hash =&gt; {
    console.log('Hash: ', hash)
  })
  .catch(err =&gt; console.error(err.message))
</pre>
<p>首先，我们将使用bcrypt的<code>genSalt</code>函数创建一个<code>salt</code>。这里，<code>genSalt</code>将把一个自变量作为一个<code>saltRound</code>数。然后，如果成功，我们将把结果和密码一起提供给hash。</p>
<p>作为成功的结果，我们将获得散列。在这个方法中，我们使用了JavaScript的<code>async</code> promise。</p>
<p>一旦触发节点<code>app.js</code>，您可以看到如下所示的输出:</p>
<pre class="language-shell hljs">Salt: $2b$10$t7oxiwchWGHa/B9w0AzrYO
Hash: $2b$10$t7oxiwchWGHa/B9w0AzrYO2WH2rQbA86YSuQjSTmwIrpC/0ZXN7V2
</pre>
<p>该哈希将与其他详细信息一起存储在数据库中。还有一件事，如果我重新运行代码，你认为我会得到结果吗？它每次都会生成相同的输出吗？</p>
<h3 id="using-bcrypt-compare-function-hash-passwords-node-js">使用<code>bcrypt.compare</code>函数散列Node.js中的密码</h3>
<p>显然，不是！<code>bcrypt.hash</code>每次都会根据特殊的salt生成一个唯一的hash。这就是它如何防止彩虹表攻击。现在，让我们看看第二种方法:</p>
<pre class="language-javascript hljs">bcrypt
  .hash(password, saltRounds)
  .then(hash =&gt; {
    console.log('Hash ', hash)
  })
  .catch(err =&gt; console.error(err.message))
</pre>
<p>这里，我们将调用<code>only has</code>函数，并且只提供<code>saltRound</code>。这也将每次生成一个唯一的散列。现在，我们将如何验证散列？这是执行用户登录所必需的。</p>
<p>因此，对于bcrypt，我们有一个<code>bcrypt.compare</code>函数来处理这一部分:</p>
<pre class="language-javascript hljs">bcrypt
  .hash(password, saltRounds)
  .then(hash =&gt; {
          userHash = hash 
    console.log('Hash ', hash)
    validateUser(hash)
  })
  .catch(err =&gt; console.error(err.message))

function validateUser(hash) {
    bcrypt
      .compare(password, hash)
      .then(res =&gt; {
        console.log(res) // return true
      })
      .catch(err =&gt; console.error(err.message))        
}
</pre>
<p>如果<code>res</code>为真，则为其匹配密码生成的散列。</p>
<h2 id="node-js-bcyrpt-password-hashing-information">Node.js bcrypt密码哈希信息</h2>
<p>正如您在最后看到的，您将得到一个60个字符长的散列:</p>
<pre class="language-shell hljs">$[algorithm]$[cost]$[salt][hash]
// $2b$10$b63K/D03WFBktWy552L5XuibmiD5SxCrKg9kHCqOYaZwxRjIg14u2
</pre>
<p>哈希的分叉是这样的:</p>
<ul>
<li><code>Algorithm</code>:将是<code>"$2a$" or "$2b$"</code>，意思是<code>BCrypt</code></li>
<li><code>Cost</code>:表示用于确定迭代次数的指数<code>2^n</code></li>
<li><code>Salt</code> : (16字节(128位))，base64编码为22个字符</li>
<li><code>Hash</code> : (24字节(192位))，base64编码为31个字符</li>
</ul>
<h3 id="password-hashing-data-costs">密码散列数据成本</h3>
<p>散列数据将经过一系列的<code>saltRounds</code>，产生任何系统或用户都无法预测的安全散列。然后，模块将使用给定值并执行<code>2^r</code>。哈希选项数据成本通常是指一轮哈希所需的时间，这取决于系统的硬件。</p>
<p>在2GHz内核处理器上，您可以大致预期以下内容:</p>
<pre class="language-plaintext hljs">rounds=8 : ~40 hashes/sec
rounds=9 : ~20 hashes/sec
rounds=10: ~10 hashes/sec
rounds=11: ~5  hashes/sec
rounds=12: 2-3 hashes/sec
rounds=13: ~1 sec/hash
rounds=14: ~1.5 sec/hash
rounds=15: ~3 sec/hash
rounds=25: ~1 hour/hash
rounds=31: 2-3 days/hash
</pre>
<h2 id="benefits-password-hashing-node-js-bcrypt">使用bcrypt在Node.js中进行密码散列的好处</h2>
<p>与MD5、SHA1、SHA2和SHA3等其他哈希方法相比，Bcrypt具有明显的优势。它们都可以在更短的时间内执行大量数据的哈希运算。假设攻击者有一个强大的系统，能够在几秒钟内尝试7亿到9亿个密码。您的包含字母数字和特殊字符值的密码将在几秒钟内被破解。</p>
<p>现在您知道了，所有这些哈希方法都不能用来加密密码。现在的主要问题是，bcrypt如何在这里提供显著的优势？Bcrypt是基于Blowfish键控时间表构建的，并使用了一个工作因子，它决定了哈希函数的开销。了解了这一点后，如果攻击者在单个时间范围内发出多个请求，bcrypt会变得更慢。所以一般来说，破解一个密码需要12年。</p>
<p>此外，bcrypt使用salt，这有助于防止像彩虹表攻击这样的攻击，并适合于保护密码。</p>
<h2>结论</h2>
<p>如您所知，保护数据以避免重大损害至关重要。攻击者可能会找到访问您的数据存储的方法，但是对于攻击者来说，加密良好的密码是浪费时间和精力。他们不会从我们的加密数据中得到任何好处。</p>
<p>Node.js允许我们毫无障碍地使用bcrypt。在处理用户的密码和其他敏感数据时，没有理由避免它。像bcrypt这样的安全散列函数对于构建一个健壮的系统应该是必要的。我建议你用它来储存密码。如果您已经使用bcrypt完成了散列，就不必处理暴露用户敏感信息的问题。</p><div class="code-block code-block-23">
<div class="blog-plug inline-plug node-plug"><h2>200只<img src="../Images/61167b9d027ca73ed5aaf59a9ec31267.png" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2019/10/green-check.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" class=" jetpack-lazy-image" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/10/green-check.png"/> <noscript> <img data-lazy-fallback="1" src="../Images/61167b9d027ca73ed5aaf59a9ec31267.png" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/10/green-check.png"/> </noscript>显示器出现故障，生产中网络请求缓慢</h2><p>部署基于节点的web应用程序或网站是容易的部分。确保您的节点实例继续为您的应用程序提供资源是事情变得更加困难的地方。如果您对确保对后端或第三方服务的请求成功感兴趣，</p><a href="https://lp.logrocket.com/blg/node-signup" target="_blank">try LogRocket</a><p>. </p><a class="signup" href="https://lp.logrocket.com/blg/node-signup" target="_blank" rel="noopener noreferrer"><img src="../Images/cae72fd2a54c5f02a6398c4867894844.png" alt="LogRocket Network Request Monitoring" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2019/12/network-request-filter-2-1.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" class=" jetpack-lazy-image" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/12/network-request-filter-2-1.png"/><noscript><img data-lazy-fallback="1" src="../Images/cae72fd2a54c5f02a6398c4867894844.png" alt="LogRocket Network Request Monitoring" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/12/network-request-filter-2-1.png"/></noscript></a><a href="https://lp.logrocket.com/blg/node-signup" target="_blank" rel="noopener noreferrer">https://logrocket.com/signup/</a><p>LogRocket 就像是网络和移动应用程序的DVR，记录下用户与你的应用程序交互时发生的一切。您可以汇总并报告有问题的网络请求，以快速了解根本原因，而不是猜测问题发生的原因。</p><p>LogRocket检测您的应用程序以记录基线性能计时，如页面加载时间、到达第一个字节的时间、慢速网络请求，还记录Redux、NgRx和Vuex操作/状态。</p><a class="signup" href="https://lp.logrocket.com/blg/node-signup" target="_blank" rel="noopener noreferrer">Start monitoring for free</a><p>. </p></div>
</div>

 <p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
<html>
<head>
<title>Using em vs. rem in CSS - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>在 CSS - LogRocket 博客中使用 em 与 rem</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/using-em-vs-rem-css/#0001-01-01">https://blog.logrocket.com/using-em-vs-rem-css/#0001-01-01</a></blockquote><div><article class="article-post">
<p>CSS 的核心功能是使浏览器能够对 HTML 元素进行样式化。CSS 通过为属性分配特定的值来实现这一点，例如背景、颜色、字体大小、边距、填充等等。</p>
<p>在 CSS 中，<code>em</code>和<code>rem</code>都是可伸缩的单元，它们也指定属性值。<code>em</code>和<code>rem</code>符合<a href="https://www.w3.org/WAI/fundamentals/accessibility-intro/" target="_blank" rel="noopener">网页可访问性标准</a>，并且与<code>px</code>不同，可扩展性更好。因此，它们更适合响应式设计。</p>
<p>在本文中，我们将了解<code>em</code>和<code>rem</code>相对长度单位。我们还将查看代码示例，以展示它们是如何工作的、它们的区别以及编码模式。最后，我们将了解它们能解决什么问题以及何时使用它们。</p>

<h2 id="background-information">背景资料</h2>
<p>CSS 语法相当简单，正如我们之前讨论的，包括给 HTML 元素的属性赋值。属性-值对被称为 CSS 声明。</p>
<p>考虑下面的代码:</p>
<pre class="language-css hljs">h1 {
  color: black;
  background-color: rgb(190,43,111,0.5);
  font-weight: 800;
  font-size: 1.5rem;
  padding: 4em;
  margin: 10px;
  weight: 100%;
  height: 100vh;
}
</pre>
<p>这段代码展示了一个 CSS 声明，它通过给元素的一些属性赋予特定的值来设置网页的<code>h1</code>元素的样式。我们看到一些属性，比如<code>font-size</code>、<code>padding</code>和<code>margin</code>，被赋予了数值。</p>
<p>在 CSS 中，有不同的数值类型:</p>
<ul>
<li>整数:整数，就像上面分配给属性<code>font-weight</code>的值<code>800</code></li>
<li>Numbers:十进制数字，就像上面传递给<a href="https://developer.mozilla.org/en-US/docs/Web/CSS/color_value/rgb" target="_blank" rel="noopener"> <code>rgb()</code> </a>函数表达式的 alpha 值。alpha 值为<code>0.5</code>，表示 50%的不透明度</li>
<li>百分比:如分配给<code>weight</code>属性的<code>100%</code></li>
<li>尺寸:带单位的数字，如<code>1.5rem</code>、<code>10px</code>或<code>100vh</code>。尺寸细分为<code>length</code>、<code>angle</code>、<code>time</code>和<code>resolutions</code>。在上面的例子中，每个维度(<code>em</code>、<code>px</code>、<code>rem</code>和<code>vh</code>)都属于长度类别</li>
</ul>
<h2 id="length-values">长度值</h2>
<p>长度值是分配给 CSS 属性的<a href="https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Types" target="_blank" rel="noopener"> CSS 数据类型</a>，如<code>weight</code>、<code>height</code>、<code>margin</code>、<code>padding</code>、<code>font-size</code>。长度值可以是绝对的，也可以是相对的。</p>
<p>绝对长度值是固定的单位，比如<code>px</code>。它们不是相对的，也不依赖于任何东西。</p>
<p>然而，相对长度值不是固定的。它们与其他东西相关，比如浏览器的默认字体大小或其他元素的字体大小。相对单位的例子包括<code>em</code>、<code>rem</code>和<code>vh</code>。</p>
<p>随着 web 开发随着设备数量的增加而发展，可伸缩单元比固定单元更受青睐，因为它们为构建响应性网站提供了所需的灵活性。</p>
<p>现在，我们将深入探讨<code>em</code>和<code>rem</code>。我们开始吧！</p>
<h2 id="what-em-rem-why-use">什么是<code>em</code>和<code>rem</code>，为什么要用？</h2>
<p><code>em</code>是相对于父元素字体大小的 CSS 单位，<code>rem</code>是相对于<code>html</code>元素字体大小的 CSS 单位。这两个都是可伸缩的单元，这意味着它们使我们能够相对于一个设定值来放大和缩小元素。这给我们的设计增加了更多的灵活性，并使我们的网站更加灵敏。</p>
<p>使用像<code>em</code>和<code>rem</code>这样的可伸缩单元的一个关键原因是可访问性。可访问性使所有用户，尤其是残疾用户，能够成功地与网站进行交互。使用像<code>px</code>这样的固定单位来设置元素、字体和空间大小的值并不能给我们这种可访问性，因为固定单位是不可伸缩的。</p>
<p>通过使用像<code>em</code>和<code>rem</code>这样的可扩展单元，我们使用户能够控制网站的规模，从而为我们提供我们想要的可访问性。</p>
<h2 id="em-vs-rem"><code>em</code>对<code>rem</code></h2>
<p><code>em</code>和<code>rem</code>是相似的，因为它们都是可扩展单元。它们的价值总是相对于其他东西的价值而言的。</p>
<p>最值得注意的是，<code>em</code>和<code>rem</code>在浏览器将它们转换成<code>px</code>的方式上有所不同。</p>
<p>如前所述，<code>em</code>值是相对于最近的父元素的<code>font-size</code>的，而<code>rem</code>值是相对于根元素的<code>font-size</code>，或者是<code>html</code>元素的<code>font-size</code>。而当根<code>font-size</code>没有显式设置时，<code>rem</code>值是相对于浏览器默认的<code>font-size</code>的<code>16px</code>。</p>
<p>这意味着当根<code>font-size</code>是<code>16px</code>时，<code>1rem</code>的值将是<code>16px</code> * 1 = <code>16px</code>。并且<code>10rem</code>的值将是<code>16px</code> * 10 = <code>160px</code>。</p>
<p>从上面我们可以看到,<code>rem</code>值是简单且可预测的，因此，我们可以控制元素如何从一个源轻松地扩展到整个页面。您可以在下面的演示中看到这一点:</p>
<pre class="language-css hljs">/* Root font-size on the document level */
html {
  font-size: 20px;
}

@media (max-width: 900px) {
  html { font-size: 16px; }
}

@media (max-width: 400px) {
  html { font-size: 12px; }
}

/* Type will scale with document */
h1 {
  font-size: 2.6rem;
}

h2 {
  font-size: 1.6rem;
}

h3 {
  font-size: 1.1rem;
}
</pre>
<p>在上面的代码中，为不同的<code>@media query</code>设置了不同的根<code>font-size</code>，类型<code>font-size</code>使用<code>rem</code>单位。这样做的结果是，类型将相对于为每个<code>@media query</code>设置的根<code>font-size</code>缩放。</p>
<p>请注意，显式地将根<code>font-size</code>设置为<code>px</code>值通常被认为是一个坏主意。这是因为它会覆盖用户的浏览器设置。推荐的方法是使用<code>%</code>单元或避免显式设置根<code>font-size</code>。这将<code>font-size</code>设置为浏览器默认<code>font-size</code>的<code>100%</code>，对于大多数浏览器来说是<code>16px</code>。</p><div class="code-block code-block-54">
<hr/>
<h3>更多来自 LogRocket 的精彩文章:</h3>

<hr/></div>
<p>虽然<code>rem</code>单元简单且可预测，但有时它们可能无法控制网页上特定区域的缩放比例。这是因为网页中的所有模块都很难相对于单个值精确地放大和缩小。</p>
<p>但是，因为<code>em</code>依赖于最近的父节点的<code>font-size</code>，所以它可以更详细地控制网页的特定区域如何缩放。因此，有了<code>em</code>，我们可以控制网页如何在模块层次上扩展。</p>
<h2 id="problems-working-em-rem">使用<code>em</code>和<code>rem</code>的问题</h2>
<p>如上所述，当使用<code>rem</code>时，有时很难让所有模块精确地缩放。一个建议的替代方案是使用<code>em</code>，因为模块中的组件更有可能相对于父组件精确地缩放。因此，所有侧边栏组件将相对于父侧边栏元素缩放，所有标题组件将相对于父标题元素缩放，等等。</p>
<p>让我们在模块化的层面上控制网页的规模，但这也带来了自身的问题。</p>
<h3 id="inheritance-em-values"><code>em</code>值的继承</h3>
<p>使用<code>em</code>单元时遇到的主要问题是由于对<code>em</code>值继承的影响。由于每个元素都继承了其最近的父元素的<code>font-size</code>，因此<code>em</code>值会随着嵌套级别的增加而线性复合。</p>
<p>为了详细说明这一点，让我们构建一个简单的应用程序。创建一个项目文件夹，并从该文件夹中运行以下命令:</p>
<pre class="language-bash hljs">npm init -y
</pre>
<p>然后运行以下命令安装<code>live-server</code>包:</p>
<pre class="language-css hljs">npm i live-server
</pre>
<p>现在，将<code>package.json</code>文件中的<code>scripts</code>属性替换为:</p>
<pre class="language-javascript hljs">"scripts": {
    "start": "live-server"
  },
</pre>
<p>在此之后，创建一个<code>index.html</code>文件并添加以下代码:</p>
<pre class="language-html hljs">&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;
    &lt;meta charset="UTF-8"&gt;
    &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt;
    &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;
    &lt;style&gt;
        .container {
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            width: 100wh;
        }
        .parent {
            font-size: 15px;
        }
        .em-child {
            font-size: 2em;
        }
        .rem-child {
            font-size: 2rem;
        }
    &lt;/style&gt;
    &lt;title&gt;Document&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;article class="container"&gt;
        &lt;div class="parent"&gt;
            I'm 15px
            &lt;div class="em-child"&gt;
                I'm 15px * 2 = 30px
                &lt;div class="em-child"&gt;
                    I'm 30px * 2 = 60px
                    &lt;div class="em-child"&gt;
                        I'm 60px * 2 = 120px.
                    &lt;/div&gt;
                &lt;/div&gt;
            &lt;/div&gt;
        &lt;/div&gt;
    &lt;/article&gt;
&lt;/body&gt;
&lt;/html&gt;
</pre>
<p>现在，运行<code>npm start</code>来启动开发服务器，我们得到:</p>
<p><img data-attachment-id="124658" data-permalink="https://blog.logrocket.com/using-em-vs-rem-css/attachment/compounding-effect-em-unit/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/07/compounding-effect-em-unit.png" data-orig-size="730,350" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="compounding-effect-em-unit" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/07/compounding-effect-em-unit-300x144.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/07/compounding-effect-em-unit.png" decoding="async" class="aligncenter size-full wp-image-124658 jetpack-lazy-image" src="../Images/bd64d0ed493f01012e4520027c68f8c7.png" alt="Compounding Effect Of Em Unit" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2022/07/compounding-effect-em-unit.png 730w, https://blog.logrocket.com/wp-content/uploads/2022/07/compounding-effect-em-unit-300x144.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2022/07/compounding-effect-em-unit.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/07/compounding-effect-em-unit.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="124658" data-permalink="https://blog.logrocket.com/using-em-vs-rem-css/attachment/compounding-effect-em-unit/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/07/compounding-effect-em-unit.png" data-orig-size="730,350" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="compounding-effect-em-unit" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/07/compounding-effect-em-unit-300x144.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/07/compounding-effect-em-unit.png" decoding="async" loading="lazy" class="aligncenter size-full wp-image-124658" src="../Images/bd64d0ed493f01012e4520027c68f8c7.png" alt="Compounding Effect Of Em Unit" srcset="https://blog.logrocket.com/wp-content/uploads/2022/07/compounding-effect-em-unit.png 730w, https://blog.logrocket.com/wp-content/uploads/2022/07/compounding-effect-em-unit-300x144.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/07/compounding-effect-em-unit.png"/></noscript>
<p>在上面的例子中，我们演示了一个<code>em</code>单元的复合效果。因为每个子元素都从最近的父元素继承了它的<code>font-size</code>，而最近的父元素又从最近的父元素继承了它的<code>font-size</code>(以此类推)，所以最终的<code>font-size</code>是不期望的<code>120px</code>。</p>
<p><code>rem</code>或“根<code>em</code>”就是为了解决这个问题而设计的。要看到这一点，用<code>index.html</code>文件中的<code>rem-child</code>类替换所有的<code>em-child</code>类，如下所示:</p>
<pre class="language-html hljs">&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;
    &lt;meta charset="UTF-8"&gt;
    &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt;
    &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;
    &lt;style&gt;
        .container {
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            width: 100wh;
        }
        .parent {
            font-size: 15px;
        }
        .em-child {
            font-size: 2em;
        }
        .rem-child {
            font-size: 2rem;
        }
    &lt;/style&gt;
    &lt;title&gt;Document&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;article class="container"&gt;
        &lt;div class="parent"&gt;
            I'm 15px
            &lt;div class="rem-child"&gt;
                I'm 15px * 2 = 30px
                &lt;div class="rem-child"&gt;
                    I'm 15px * 2 = 30px
                    &lt;div class="rem-child"&gt;
                        I'm 15px * 2 = 30px.
                    &lt;/div&gt;
                &lt;/div&gt;
            &lt;/div&gt;
        &lt;/div&gt;
    &lt;/article&gt;
&lt;/body&gt;
&lt;/html&gt;
</pre>
<p>我们得到了:</p>
<p><img data-attachment-id="124660" data-permalink="https://blog.logrocket.com/using-em-vs-rem-css/attachment/rem-child-example/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/07/rem-child-example.png" data-orig-size="730,350" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="rem-child-example" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/07/rem-child-example-300x144.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/07/rem-child-example.png" decoding="async" class="aligncenter size-full wp-image-124660 jetpack-lazy-image" src="../Images/b10ca2be4479ba14c9fe3a91bc165fad.png" alt="Rem Child Example" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2022/07/rem-child-example.png 730w, https://blog.logrocket.com/wp-content/uploads/2022/07/rem-child-example-300x144.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2022/07/rem-child-example.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/07/rem-child-example.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="124660" data-permalink="https://blog.logrocket.com/using-em-vs-rem-css/attachment/rem-child-example/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/07/rem-child-example.png" data-orig-size="730,350" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="rem-child-example" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/07/rem-child-example-300x144.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/07/rem-child-example.png" decoding="async" loading="lazy" class="aligncenter size-full wp-image-124660" src="../Images/b10ca2be4479ba14c9fe3a91bc165fad.png" alt="Rem Child Example" srcset="https://blog.logrocket.com/wp-content/uploads/2022/07/rem-child-example.png 730w, https://blog.logrocket.com/wp-content/uploads/2022/07/rem-child-example-300x144.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/07/rem-child-example.png"/></noscript>
<p><code>em</code>和<code>rem</code>都是可扩展单元，为我们的设计增加了灵活性。然而，最大的问题是何时使用<code>em</code>或<code>rem</code>。关于这一点还存在争议，但是从我们目前了解到的情况来看，我推荐使用<code>rem</code>来保证一致性和可预测性，如果你想在模块化的层面上扩展你的页面，那么使用<code>em</code>。</p>
<h2 id="scaling-sizing-em-rem">用<code>em</code>和<code>rem</code>缩放尺寸</h2>
<p>用 em 和 rem 创建常见的十进制属性值曾经是一个难题，因为数学通常很难计算。以下是一些常见的字体大小及其相应的 rem 值:</p>
<pre>14px = 0.875rem
16px = 1rem
20px = 1.25rem
24px = 1.5rem
30px = 1.875rem
</pre>
<p>然而，有不同的方法来解决这个问题。“62.5%”技术是一种流行的技术；它包括将基数<code>font-size</code>设置为其原始值(16px)的 62.5%，这将它重置为 10px(即 16 的 62.5%是 10)；然后我们可以用更方便的值来应用<code>rem</code> / <code>em</code>:</p>
<pre class="language-css hljs">body {
  font-size: 62.5%;
    /* 10px */
}

h1 {
  font-size: 2.4rem;
    /* 24px */
}

h2 {
  font-size: 2rem;
    /* 20px */
}

p {
  font-size: 1.4rem;
    /* 14px */
}</pre>
<p>同样的代码也适用于<code>em</code>，假设没有其他父元素用不同的值覆盖这些样式。</p>
<p>然而，这种方法有一些明显的缺点，特别是在重复方面。就像在我们之前的代码示例中一样，因为我们现在已经将基本字体大小定义为 10px，所以我们必须为应该从基本字体继承的每个其他元素显式定义<code>font-sizing</code>。例如，我们已经为<code>p</code>元素完成了这一步，并将不得不为每一个<code>li</code>、<code>span</code>和其他应该从<code>base</code>继承该值的类似元素重复这一步。</p>
<h2 id="css-libraries-using-em-rem">使用<code>em</code>和<code>rem</code>的 CSS 库</h2>
<p>与<code>em</code>相反，<code>rem</code>似乎在 CSS 库中更常见。使用 rem 的常见库包括:</p>
<ul>
<li>自举 v5</li>
<li>顺风 CSS</li>
<li>React MUI(包括对 62.5%技术的内置支持)</li>
<li>布尔玛</li>
</ul>
<p>此外，谷歌材料设计风格指南还推荐了用于其网络实现的<code>rem</code>单元。</p>
<h2 id="conclusion">结论</h2>
<p>在本文中，我们学习了<code>em</code>和<code>rem</code>，两个相似的、可伸缩的、相对的 CSS 单元。然而，它们之间的关键区别在于浏览器如何计算它们的像素值。</p>
<p>虽然这两个单元都为响应式设计提供了所需的灵活性，但<code>rem</code>因其简单性、一致性和可预测性而受到青睐。尽管使用<code>em</code>可能有些棘手，但是如果你喜欢在模块层次上扩展你的页面，它可能是正确的选择。</p><div class="code-block code-block-25">
<div class="blog-plug inline-plug css-plug"><h2>你的前端是否占用了用户的 CPU？</h2><p>随着 web 前端变得越来越复杂，资源贪婪的特性对浏览器的要求越来越高。如果您对监控和跟踪生产环境中所有用户的客户端 CPU 使用、内存使用等感兴趣，</p><a target="_blank" href="https://lp.logrocket.com/blg/css-signup">try LogRocket</a><p>.</p><a class="signup" href="https://lp.logrocket.com/blg/css-signup" target="_blank" rel="noopener noreferrer"><img class="alignnone size-full wp-image-46 jetpack-lazy-image" src="../Images/dacb06c713aec161ffeaffae5bd048cd.png" alt="LogRocket Dashboard Free Trial Banner" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2019/12/cpu-memory-usage.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/12/cpu-memory-usage.png"/><noscript><img data-lazy-fallback="1" class="alignnone size-full wp-image-46" src="../Images/dacb06c713aec161ffeaffae5bd048cd.png" alt="LogRocket Dashboard Free Trial Banner" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/12/cpu-memory-usage.png"/></noscript></a><a href="https://lp.logrocket.com/blg/css-signup" target="_blank" rel="noopener noreferrer">https://logrocket.com/signup/</a><p>LogRocket 就像是网络和移动应用的 DVR，记录你的网络应用或网站上发生的一切。您可以汇总和报告关键的前端性能指标，重放用户会话和应用程序状态，记录网络请求，并自动显示所有错误，而不是猜测问题发生的原因。</p><p>现代化您调试 web 和移动应用的方式— <a class="signup" href="https://lp.logrocket.com/blg/css-signup" target="_blank" rel="noopener noreferrer">开始免费监控</a>。</p></div>
</div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
<html>
<head>
<title>Integrating a Svelte app with Rust using WebAssembly - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>使用 WebAssembly - LogRocket 博客将一个苗条的应用程序与 Rust 集成</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/integrating-svelte-app-rust-webassembly/#0001-01-01">https://blog.logrocket.com/integrating-svelte-app-rust-webassembly/#0001-01-01</a></blockquote><div><article class="article-post">
<p>Svelte 是一个 JavaScript 框架，在 web 应用程序开发人员中很受欢迎。但是，如果我们为了速度、安全性和其他好处而想使用 Rust 编程语言，而不是 JavaScript 或 TypeScript，该怎么办呢？多亏了 WebAssembly，我们才能做到这一点。</p>
<p>WebAssembly 像 TypeScript 一样是类型安全的，因为它是预先编译的，而不是在运行时编译，甚至比 JavaScript 快得多。将这一点与 Svelte 的易用性及其无需虚拟 DOM 即可更新 UI 的能力结合起来，我们甚至可以让大型应用程序运行得非常快！</p>
<p>在本文中，我们将看到如何通过将 Rust 编译成 WebAssembly 来连接一个带有 Rust 代码的瘦前端，以及如何在 JavaScript 和 Rust 之间调用函数和传递数据。具体来说，我们将涵盖:</p>

<p>您将需要 Rust 的基本知识来跟随本教程。这可能包括读、写和理解变量声明、<code>if…else</code>块、循环和结构。一些关于苗条的知识也会有所帮助。</p>
<h2 id="what-svelte">什么是苗条？</h2>
<p>Svelte 是<a href="https://blog.logrocket.com/should-you-switch-react-svelte/" target="_blank" rel="noreferrer noopener">另一个前端框架，类似于 React </a>或 Vue。像这两个，可以用 Svelte 做单页应用。然而，Svelte 的一些特性使它与其他框架有着显著的不同。</p>
<p>例如，Svelte 不像其他的，它主要是一个编译框架；大多数苗条库是一个<code>devDependency</code>而不是一个运行时依赖。这有助于使最终的应用程序更小，更快地供客户端下载。</p>
<p>另一个区别是 Svelte 不使用虚拟 DOM。相反，它使用各种策略来只更新页面中发生变化的特定部分。这减少了开销，使应用程序更快。</p>
<p>Svelte 还提供了易用性，不需要类或函数来声明组件。每个细长的文件被视为一个组件本身。</p>
<p>最后，Svelte 的钩子很少。虽然生命周期特性需要钩子，但是 Svelte 不需要复杂的状态管理钩子。状态可以简单地通过声明一个变量来存储和使用，就像在普通 JavaScript 中一样。</p>
<h2 id="what-wasm">Wasm 是什么？</h2>
<p>WebAssembly (Wasm)是一种二进制指令格式，我们的浏览器可以与 JavaScript 一起运行。</p>
<p>然而，与 JavaScript 不同，它已经是二进制格式，在编译时已经解析了类型信息，并且不需要<a href="https://blog.logrocket.com/how-javascript-works-optimizing-the-v8-compiler-for-efficiency/" target="_blank" rel="noreferrer noopener">解释或即时编译</a>。由于这些和其他一些原因，它在许多情况下比 JavaScript 快得多。</p>
<p>Wasm 是一个编译目标，几种语言——包括 Rust——都可以编译到它上面。因此，我们可以用 Rust 编写程序，编译成 Wasm，然后在浏览器中用 JavaScript 运行它。</p>
<h2 id="why-wasm-rust">为什么用 Wasm 带锈？</h2>
<p><a href="https://blog.logrocket.com/getting-started-with-webassembly-and-rust/" target="_blank" rel="noreferrer noopener">使用带锈的 Wasm】可以有很多好处。让我们看几个实际的项目例子。</a></p>
<p>你可以在 Rust 中编写一个包含核心函数的库，然后通过将其编译成 Wasm，将其用于 web 应用程序和桌面或命令行应用程序。8086 仿真器就是这样一个例子。</p>
<p>在 8086 仿真器中，核心仿真器和编译器是在一个平台不可知的库中编写的，然后通过编写一个瘦的特定于平台的接口来适应命令行和 web 格式。</p>
<p>另一个很好的用途是快速获得库的交互式演示，而不必编写复杂的命令行程序或纯粹基于文本的示例。我们可以创建一个图形化的 web 界面，并从事件处理程序(如按钮点击)中调用库函数。</p>
<p>看看这个 <code><a href="https://yjdoc2.github.io/pcb-rs-examples/" target="_blank" rel="noreferrer noopener">pcb-rs</a></code> <a href="https://yjdoc2.github.io/pcb-rs-examples/" target="_blank" rel="noreferrer noopener">库示例</a>的<a href="https://yjdoc2.github.io/pcb-rs-examples/" target="_blank" rel="noreferrer noopener"> web 界面，它演示了这个用例。这个例子提供了一个硬件模拟库的演示，以及一个交互界面来使用它，用 Svelte 写的。</a></p>
<p>这不仅仅限于小项目；甚至像 Figma 这样的大型项目也使用 Wasm 来使他们的桌面应用适应网络，这样他们就可以方便容易地使用。</p>
<p>顺便说一下，Wasm 并不是服务器端逻辑的替代品。它仍然运行在客户端的浏览器中，所以您仍然需要一些东西来服务 Wasm 文件，即使它只是一个静态文件服务器。</p>
<h2 id="setting-up-system-rust-wasm-node-other">用 Rust、Wasm、Node 和其他软件包设置我们的系统</h2>
<p>让我们从设置系统开始。</p>
<p>首先，<a href="https://www.rust-lang.org/learn/get-started" target="_blank" rel="noreferrer noopener">按照他们官网</a>上的说明安装 Rust。这将在您的系统上安装和设置 Rust 语言工具，如编译器和标准库。</p>
<p>然后，<a href="https://rustwasm.github.io/wasm-pack/installer/" target="_blank" rel="noreferrer noopener">安装</a> <code><a href="https://rustwasm.github.io/wasm-pack/installer/" target="_blank" rel="noreferrer noopener">wasm-pack</a></code> <a href="https://rustwasm.github.io/wasm-pack/installer/" target="_blank" rel="noreferrer noopener">，一个把 Rust 编译成 Wasm </a>的辅助工具。该工具还负责下载编译到 Wasm 所需的工具链。</p>
<p>最后，按照安装指南通过<a href="https://docs.npmjs.com/downloading-and-installing-node-js-and-npm" target="_blank" rel="noreferrer noopener">安装 Node.js、npm 和 npx。你可能需要</a><a href="https://www.npmjs.com/package/npx" target="_blank" rel="noreferrer noopener">单独安装 npx 作为一个全局包</a>。</p>
<p>要检查所有设置是否正确，请尝试运行以下命令，并查看是否有任何内容出错:</p>
<pre class="language-shell hljs">&gt; npm --version
&gt; npx --version
&gt; node --version
&gt; cargo --version
&gt; rustc --version
&gt; wasm-pack --version
&gt; rustc --print target-list # This list should have wasm32 targets
</pre>
<p>如果这些命令运行时没有任何错误，那么我们就成功地完成了系统设置。</p>
<h2 id="setting-up-svelte-wasm-rust-project">建立我们的苗条+Wasm+Rust 项目</h2>
<p>有多种方法可以建立一个使用 Svelte、Wasm 和 Rust 的 web 项目。例如， <code><a href="https://github.com/rustwasm/wasm-pack" target="_blank" rel="noreferrer noopener">rust-wasm</a></code> <a href="https://github.com/rustwasm/wasm-pack" target="_blank" rel="noreferrer noopener">组</a>的<code><a href="https://github.com/rustwasm/wasm-pack" target="_blank" rel="noreferrer noopener">wasm-pack</a></code> <a href="https://github.com/rustwasm/wasm-pack" target="_blank" rel="noreferrer noopener">为简单的 HTML-CSS-JS 应用提供了模板。还有几个 React 或 Svelte with Rust 和 Wasm 的项目模板。</a></p>
<p>然而，代替任何模板，我们将使用一个 npm 插件，这将为我们的项目结构提供更多的灵活性。</p>
<h3 id="creating-svelte-app">创建我们苗条的应用程序</h3>
<p>首先，创建一个项目目录。在该目录中，我们将首先通过运行以下命令，使用他们的模板创建一个 Svelte 应用程序:</p>
<pre class="language-shell hljs">&gt; npx degit sveltejs/template svelte
</pre>
<p>在上面的代码中，我们将我们的应用程序命名为<code>svelte</code>，但是您可以随意命名。</p>
<p>再次在项目目录中，运行以下命令创建一个 Rust library 项目目录:</p>
<pre class="language-shell hljs">&gt; cargo new --lib rust
</pre>
<p>在上面的代码中，我们将库命名为<code>rust</code>，但是您可以给它一个不同的名称。</p><div class="code-block code-block-54">
<hr/>
<h3>更多来自 LogRocket 的精彩文章:</h3>

<hr/></div>
<p>现在，进入<code>svelte</code>目录，运行下面的命令来安装基本的依赖项:</p>
<pre class="language-shell hljs">&gt; npm install
</pre>
<p>在此之后，我们将安装<code>rollup-plugin-rust</code>，它会自动将 Rust 代码编译到 Wasm，并允许我们轻松地将 Rust 中的东西导入 JavaScript。</p>
<pre class="language-shell hljs">&gt; npm install @wasm-tool/rollup-plugin-rust
</pre>
<p>接下来，打开<code>rollup.config.js</code>文件并添加以下导入语句:</p>
<pre class="language-javascript hljs">import rust from '@wasm-tool/rollup-plugin-rust';
</pre>
<p>在同一个文件中，在<code>serve</code>函数之后，会有一个<code>export default</code>语句。此语句导出配置对象。在配置对象中，会有一个<code>plugins</code>数组。我们需要将 Rust 插件添加到这个数组中，就像这样:</p>
<pre class="language-javascript hljs">...
plugins: [
     rust({ 
        verbose: true,
        serverPath: "build/"
     }),
     svelte({
...
</pre>
<p><a href="https://github.com/wasm-tool/rollup-plugin-rust" target="_blank" rel="noreferrer noopener">插件提供了几个选项</a>。最重要的是，对于我们的项目:</p>
<ul>
<li>无论何时编译 Rust 代码，都会显示编译步骤及其输出</li>
<li><code>serverPath</code>指定 Wasm 文件将从哪个路径提供</li>
</ul>
<p>我们将<code>serverPath</code>设置为<code>build</code>,因为在开发模式下，Svelte 提供来自<code>build</code>目录的文件。如果我们想要部署我们的项目，需要相应地调整<code>serverPath</code>。</p>
<p>再次运行<code>npm install</code>来安装这个插件。这应该结束了我们的苗条应用程序的设置。</p>
<h3 id="setting-up-rust-project">为我们的项目设置 Rust</h3>
<p>要为我们的项目设置 Rust，请将目录更改为<code>rust</code>。打开<code>Cargo.toml</code>文件，在<code>[package]</code>键之后和<code>[dependencies]</code>键之前添加以下内容:</p>
<pre class="language-toml hljs">[lib]
crate-type = ["cdylib", "rlib"]
</pre>
<p>在<code>[dependencies]</code>键中，添加以下内容:</p>
<pre class="language-toml hljs">wasm-bindgen = "0.2.63"
</pre>
<p>运行一次<code>cargo build</code>来获取并安装依赖项。</p>
<p>至此，基本的项目设置已经就绪。</p>
<h2 id="connecting-svelte-rust">连接苗条和铁锈</h2>
<p>我们将首先通过从 Rust 公开一个简单的<code>add</code>函数并从 Svelte 调用它来连接 Svelte 和 Rust。这一步很简单，但将帮助我们验证两者都已连接并按预期运行。</p>
<p>在<code>rust</code>目录中，打开<code>src/lib.rs</code>文件并从中删除默认测试。在现在为空的文件中，添加以下内容:</p>
<pre class="language-rust hljs">use wasm_bindgen::prelude::*;

#[wasm_bindgen]
pub fn add(a: usize, b: usize) -&gt; usize {
    a + b
}
</pre>
<p>在上面的代码中，我们首先从<code>wasm_bindgen</code>导入了<code>prelude</code>，它提供了将 Rust 代码编译并绑定到 Wasm 所需的宏和其他项目。</p>
<p>此外，我们想要向 JavaScript 公开的任何东西都需要是公共的，因此函数上有了<code>pub</code>关键字。同时，<code>#[wasm_bindgen]</code>提供了必要的装订“胶水”</p>
<p>现在，回到<code>svelte</code>目录，打开<code>main.js</code>文件并添加下面的<code>import</code>命令:</p>
<pre class="language-javascript hljs">import wasm from '../../rust/Cargo.toml';
</pre>
<p>在上面的代码中，我们将导入称为<code>wasm</code>，但是您可以随意命名它。路径应该指向我们要编译的项目的<code>Cargo.toml</code>文件，导入为 Wasm。我们可以像这样导入多个项目，用不同的名称和对应的路径。</p>
<p>有了这个，我们之前安装的插件将拦截导入，编译 Rust 代码，设置 Wasm，并为我们将其连接到我们的 Svelte 应用程序！</p>
<p>因为 Wasm 导入需要异步完成，所以我们将应用程序定义和<code>export default</code>语句更改如下:</p>
<pre class="language-javascript hljs">import App from './App.svelte';
import wasm from '../../rust/Cargo.toml';

const init = async () =&gt; {
      const bindings = await wasm();
      const app = new App({
      target: document.body,
      props: {
                bindings,
              },
    });
};

init();
</pre>
<p>在上面的代码中，我们定义并调用了一个异步函数，它将等待导入，然后将其作为一个道具传递给应用程序。Rust 库使用<code>#[wasm_bindgen]</code>公开的一切现在都可以在这个导入的模块中访问；因此，我们的<code>add</code>函数可以作为<code>bindings.add</code>来访问。</p>
<p>现在我们将删除<code>App.svelte</code>文件中的所有内容，并添加以下内容:</p>
<pre class="language-javascript hljs">&lt;script&gt;
export let bindings;
&lt;/script&gt;

&lt;h1&gt;
{bindings.add(5,7)}
&lt;/h1&gt;
</pre>
<p>接下来，运行<code>svelte</code>文件夹中的<code>npm run dev</code>。如果到目前为止一切都是正确的，它应该显示 Rust 编译(尽管在您第一次运行时可能需要一些时间)。</p>
<p>编译完成后，会显示服务器连接到<code>localhost</code>的细长消息。当你打开<code>localhost</code>网址时，它应该显示数字 12。</p>
<p>恭喜你，我们已经把铁锈和苗条联系起来了！</p>
<p>您可以通过添加和公开更多的函数并从 JavaScript 调用它们来进行一些尝试。</p>
<p>目前只能传递简单的参数，比如<code>usize</code>、<code>bool</code>等等。然而，我们将在后面看到如何向 JavaScript 公开结构和<code>impl</code>方法，以及如何从 Rust 调用 JavaScript 函数。</p>
<p>在我们开始之前，让我们给这个苗条的应用添加一点风格。</p>
<h2 id="adding-style-carbon-components-svelte">用<code>carbon-components-svelte</code>添加样式</h2>
<p>这一小段将解释如何使用<code>carbon-components-svelte</code>为我们的苗条应用程序设置和添加风格。我们也可以<a href="https://blog.logrocket.com/svelte-material-ui-advanced-material-design-components/" target="_blank" rel="noreferrer noopener">使用一些其他的库来进行造型，比如材质 UI </a>或者 Bootstrap，这不会有太大的区别。</p>
<p>我们将使用最少的必要步骤快速添加<code>carbon-components-svelte</code>，但是您可以<a href="https://carbon-components-svelte.onrender.com/" target="_blank" rel="noreferrer noopener">查看库的文档</a>以获得更多详细信息和示例。</p>
<p>首先，通过在<code>svelte/</code>目录中运行以下命令来安装<code>carbon-components-svelte</code>:</p>
<pre class="language-shell hljs">&gt; npm i -D carbon-components-svelte
</pre>
<p>然后我们将样式表导入到<code>main.js</code>中。它支持一些开箱即用的主题，如<code>white</code>、<code>gray10</code>、<code>gray80</code>等，以及动态主题支持和自定义主题支持。我们将在这个例子中使用<code>gray80</code>主题。</p>
<p>在您的<code>main.js</code>文件中添加以下<code>import</code>命令:</p>
<pre class="language-javascript hljs">import "carbon-components-svelte/css/g80.css";
</pre>
<p>在<code>App.svelte</code>文件中做如下微小的改变:</p>
<pre class="language-javascript hljs">&lt;script&gt;
...
import {Content} from 'carbon-components-svelte';
...
&lt;/script&gt;

&lt;Content&gt;
&lt;h1&gt;
{bindings.add(5,7)}
&lt;/h1&gt;
&lt;/Content&gt;
</pre>
<p>如果你现在看一下这个页面，它会有一个漂亮的灰色背景，数字 12 和以前一样，现在增加了边距和填充。</p>
<p>虽然你可以<a href="https://blog.logrocket.com/build-web-components-svelte/" target="_blank" rel="noreferrer noopener">用苗条的</a>构建其他 web 组件，或者甚至<a href="https://blog.logrocket.com/build-your-own-component-library-svelte/" target="_blank" rel="noreferrer noopener">构建你自己的组件库</a>，这是我们将要做的样式的范围。除了稍后使用输入组件之外，我们将把重点放在连接 Rust 和 Svelte 上。</p>
<h2 id="exposing-structs-impl-methods">公开结构和<code>impl</code>方法</h2>
<p>下一节将稍微高级和复杂一些。我们将在 Rust 中定义一个结构，并在 JavaScript 中使用它来向函数传递值。我们还将看到如何公开<code>impl</code>方法并从 JavaScript 调用它们。</p>
<p>首先，让我们在 Rust 项目的<code>lib.rs</code>文件中添加一个名为<code>Car</code>的简单结构:</p>
<pre class="language-rust hljs">#[wasm_bindgen]
pub struct Car {
    pub number: usize,
    pub color:usize, // color in hex code
}

#[wasm_bindgen]
pub fn color(a: Car,color:usize) -&gt; Car {
    Car {
      number: a.number,
      color
    }
}
</pre>
<p>在上面的代码中，我们将<code>#[wasm_bindgen]</code> Rust 库和一个<code>color</code>函数添加到结构中，该函数带有一个<code>Car</code>类型参数和一个<code>usize</code>类型的<code>color</code>。我们还在<code>Car</code>的<code>number</code>和<code>color</code>字段上显式添加了<code>pub</code>，以确保它们被暴露给 JavaScript。</p>
<p>在我们的<code>svelte</code>目录中，让我们如下更改我们的<code>App.svelte</code>文件:</p>
<pre class="language-javascript hljs">&lt;script&gt;
export let bindings;
import {Content} from 'carbon-components-svelte';
let {Car,color} = bindings; // destructure for easier access
console.log(Car,color);
&lt;/script&gt;

&lt;Content&gt;
&lt;h1&gt;
&lt;/h1&gt;
&lt;/Content&gt;
</pre>
<p>在上面的代码中，我们析构了<code>bindings</code>来提取<code>Car</code>和<code>color</code>。我们还删除了对<code>add</code>的调用。</p>
<p>如果我们看一下控制台，我们可以看到<code>Car</code>是一个类，<code>color</code>是一个函数。然而，我们不能使用<code>new Car()</code>直接将<code>Car</code>实例化为一个类，因为本质上，它是一个 Rust 结构，本身并不拥有<code>constructor</code>。</p>
<p>因此，要实例化它，我们必须将<code>new</code>方法添加到<code>Car</code>类中，并公开它:</p>
<pre class="language-rust hljs">#[wasm_bindgen]
impl Car {
    pub fn new() -&gt; Self {
        Car { number: 0, color: 0 }
    }
}
</pre>
<p>注意，我们可以标记该结构的一个方法，比如上面代码中的<code>new</code>，作为一个<code>constructor</code>。然而，在下一节中，我们将只简要地触及这个概念。</p>
<p>接下来，在<code>App.svelte</code>中，添加以下内容:</p>
<pre class="language-javascript hljs">let {Car,color} = bindings; // destructure for easier access

let c = Car.new();
c.number = 5;
c.color = 775577;
console.log(c);

let c2 = color(c,557755);

console.log(c2.number,c2.color);
</pre>
<p>如果我们现在看一下控制台，我们可以看到第一个<code>console.log</code>显示如下:</p>
<pre class="language-javascript hljs">Object {ptr:...}
</pre>
<p>为了理解为什么<code>console.log(c)</code>会产生这个输出，我们必须理解<code>Car</code>实例到底是什么。</p>
<p>Wasm 在浏览器中的运行方式是基于堆栈的虚拟机。我们需要另外一整篇文章来讨论 WebAssembly 如何工作以及为什么工作。</p>
<p>出于我们的目的，我们需要理解的是 Wasm 有一个线性内存，就 Wasm 而言，它需要的一切都存储在那个内存中。</p>
<p>当我们从 Wasm 中获取一个对象时，它将它的指针存储在对象的线性内存中。因此，我们之前记录的对象只在线性内存中存储它们位置的指针。</p>
<p>对于较小的应用程序，我们可以忽略这些细节，但是随着应用程序规模的增长和传递的数据变得更加复杂，我们需要考虑这些细节。</p>
<p>例如，(几乎)所有跨越 JavaScript–Wasm 边界的东西都要从那个线性内存复制到 JavaScript 的内存；因此，具有许多值的大型对象将需要时间和计算能力来复制。</p>
<p>另一个问题是，在默认情况下，Wasm 有固定的 1MB 内存分配给它。如果需要一次传输的数据大于这个数，我们就会遇到内存限制错误。</p>
<p>事实上，由于 Wasm 代码中的其他信息也会占用一些 1MB 的内存，我们可能会比预期的更早达到内存限制。如果需要，我们将在本文的最后一节看到如何增加这个限制。</p>
<p>回到我们当前的实现，我们已经看到了如何公开和使用结构及其方法。接下来，让我们来看看如何公开相关的方法，或者采用<code>self</code>参数的函数:</p>
<pre class="language-rust hljs">#[wasm_bindgen]
impl Car {
    ...
    pub fn duplicate(&amp;self) -&gt; Self {
        Self {
            number: self.number + 1,
            mul: self.color,
        }
    }
    ...
}
</pre>
<p>在上面的代码中，我们不变地获取了<code>Car</code>，并使用<code>duplicate()</code>返回了一个新对象，其<code>number</code>比之前大一，其<code>color</code>相同。</p>
<p>接下来，在<code>App.svelte</code>中，运行以下程序:</p>
<pre class="language-javascript hljs">let c = Car.new();
c.number = 5;
c.color = 775577;

...

let c3 = c2.duplicate();

console.log(c3.number,c3.color);

console.log(c2,c3);
</pre>
<p>我们在这里可以看到<code>c3</code>具有按照复制函数设置的值。更重要的是，我们可以看到<code>c2</code>和<code>c3</code>具有不同的<code>ptr</code>值，这表明它们确实是不同的对象。</p>
<p>如果我们添加一个方法来可变地获取<code>Car</code>，如下所示:</p>
<pre class="language-rust hljs">...
 pub fn change_number(&amp;mut self,number:usize) {
    self.number = number;      
}
...
</pre>
<p>并在<code>c3</code>上这样称呼它:</p>
<pre class="language-javascript hljs">c3.change_number(7);
console.log(c3.number);
</pre>
<p>然后我们会看到<code>c3</code>的数字已经改变。</p>
<p>这里有一个有用的提示，当你不知道哪些属性可以从 JavaScript 访问时，<code>console.log</code>那个对象并打开那个对象的原型描述。</p>
<p>在对象的原型描述中，您将能够看到 JavaScript 可以访问的函数和参数。事实上，您可以通过点击参数旁边的<code>&gt;&gt;</code>来检查参数的值，这将显示它们的当前值。</p>
<p>因此，即使我们在调用<code>change_number</code>之前已经记录了<code>c3</code>对象，我们现在也可以在控制台原型中扩展它的<code>number</code>信息。通过这样做，我们看到它有了新的值，而不是原来的值，因为<code>change_number</code>函数可变地采用了<code>Car</code>。</p>
<h2 id="passing-complex-data-types-javascript-rust">在 JavaScript 和 Rust 之间传递复杂的数据类型</h2>
<p>到目前为止，我们传递的数据类型相当简单。甚至我们使用的结构也是由基本类型组成的。</p>
<p>我们也可以使用类似<code>Vec&lt;_&gt;</code>这样复杂的东西将向量从 Rust 传递给 JavaScript。所有这些工作的方式是<code>wasm_bindgen</code>实现了<code>derive</code>函数，该函数将 Rust 值转换成 JavaScript，反之亦然。</p>
<p>然而，没有被<code>wasm-bindgen</code>预定义的数据类型不能轻易传递。例如，让我们在我们的<code>Car</code>中添加一个<code>Box&lt;usize&gt;</code>，如下所示:</p>
<pre class="language-rust hljs">#[wasm_bindgen]
pub struct Car {
    pub number: usize,
    pub color:usize, // color in hex code
    pub boxed_value: Box&lt;usize&gt;
}
...
 pub fn new() -&gt; Self {
        Car { number: 0, color: 0, boxed_value: Box::new(5) }
}
</pre>
<p>现在，如果我们看一下运行<code>npm run dev</code>的控制台，我们会看到一个错误，如下所示:</p>
<pre class="language-shell hljs">error[E0277]: the trait bound `Box&lt;usize&gt;: IntoWasmAbi` is not satisfied
 --&gt; src/lib.rs:3:1
  |
3 | #[wasm_bindgen]
  | ^^^^^^^^^^^^^^^ the trait `IntoWasmAbi` is not implemented for `Box&lt;usize&gt;`
  |
  = help: the following implementations were found:
            &lt;Box&lt;[JsValue]&gt; as IntoWasmAbi&gt;
            &lt;Box&lt;[T]&gt; as IntoWasmAbi&gt;
            &lt;Box&lt;[f32]&gt; as IntoWasmAbi&gt;
            &lt;Box&lt;[f64]&gt; as IntoWasmAbi&gt;
          and 10 others
  = note: this error originates in the attribute macro `wasm_bindgen` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0277]: the trait bound `Box&lt;usize&gt;: FromWasmAbi` is not satisfied
 --&gt; src/lib.rs:3:1
  |
3 | #[wasm_bindgen]
  | ^^^^^^^^^^^^^^^ the trait `FromWasmAbi` is not implemented for `Box&lt;usize&gt;`
  |
  = help: the following implementations were found:
            &lt;Box&lt;[JsValue]&gt; as FromWasmAbi&gt;
            &lt;Box&lt;[T]&gt; as FromWasmAbi&gt;
            &lt;Box&lt;[f32]&gt; as FromWasmAbi&gt;
            &lt;Box&lt;[f64]&gt; as FromWasmAbi&gt;
          and 10 others
  = note: this error originates in the attribute macro `wasm_bindgen` (in Nightly builds, run with -Z macro-backtrace for more info)

For more information about this error, try `rustc --explain E0277`.


waiting for changes..
</pre>
<p>这个错误基本上解释了当跨越 Rust-Wasm-JavaScript 边界传递值时，需要名为<code>FromWasmAbi</code>和<code>ToWasmAbi</code>的特征。由于<code>Box&lt;usize&gt;</code>没有实现这些特征，价值观就无法传递。</p>
<p>这背后的一个原因，特别是对<code>Box&lt;_&gt;</code>来说，是盒子是值的容器。盒子将值存储在堆上而不是堆栈上，并管理内存，直到值被丢弃，之后内存被释放。</p>
<p>将这些值传递给 JavaScript 需要回答一些问题，比如谁实际处理内存，JavaScript 的垃圾收集器如何与这些信息交互。除此之外，由于 JavaScript 允许完全的可变性，它可以打破<code>Box</code>需要的保证并创建一个不安全的内存状态。</p>
<p>出于诸如此类的原因，<code>wasm_bindgen</code>在默认情况下不会实现它。此外，由于<code>Box</code>和<code>From/ToWasmAbi</code>特征都在我们的机箱之外，我们也不能为它实现它们。</p>
<p>考虑另一个类似的场景。假设我们使用了另一个箱子中没有实现某些特征的东西，但是我们需要在我们的结构中有这些特征，这又需要暴露给 JavaScript。这可以通过两种方式解决。</p>
<p>首先，不能安全传递或不能使用<code>serde-json</code>序列化的对象可以通过句柄暴露。</p>
<p>其次，可以使用 <code><a href="https://blog.logrocket.com/json-and-rust-why-serde_json-is-the-top-choice/" target="_blank" rel="noreferrer noopener">serde-json</a></code>进行<a href="https://blog.logrocket.com/json-and-rust-why-serde_json-is-the-top-choice/" target="_blank" rel="noreferrer noopener">序列化的对象可以使用<code>serde-json</code> crate 在它们的 JavaScript 表示之间进行转换，并进行传递。</a></p>
<p>我们将在接下来的章节中探索这些解决方案。</p>
<h3 id="using-handles-calling-javascript-functions-rust">使用句柄并从 Rust 调用 JavaScript 函数</h3>
<p>为了理解句柄的概念，记住<code>wasm_bindgen</code>只暴露那些被标记为<code>pub</code>的属性。任何私有属性很可能是不实现某些特征的类型。</p>
<p>让我们从<code>boxed_value</code>中移除<code>pub</code>，并在上面使用的代码中调整<code>color</code>函数:</p>
<pre class="language-rust hljs">#[wasm_bindgen]
pub struct Car {
    pub number: usize,
    pub color:usize, // color in hex code
    boxed_value: Box&lt;u8&gt;,
}

...

#[wasm_bindgen]
pub fn color(a: Car,color:usize) -&gt; Car {
    Car {
      number: a.number,
      color,
      boxed_value:Box::new(0)
    }
}
</pre>
<p>我们的代码应该再次编译！如果我们使用之前的原型技巧，我们会看到<code>boxed_value</code>确实无法从 JS 访问。你可以试着登录控制台来确认你是否想亲眼看看。</p>
<p>这种使用 Wasm 不兼容值的方法可以被认为是句柄。本质上，我们不能直接访问内部值，但是我们可以访问包含这些值的结构。</p>
<p>因此，我们可以使用这些结构来处理这些值。因为这些值仍然可以从 Rust 中访问，所以我们可以从 Rust 内部的函数对它们进行操作。让我们删除对<code>Box</code>所做的所有更改，并添加另一个结构:</p>
<pre class="language-rust hljs">pub struct OwnerID {
    id: usize,
}

#[wasm_bindgen]
pub struct Car {
    pub number: usize,
    pub color: usize, // color in hex code
    pub owner: OwnerID,
}
...
pub fn new() -&gt; Self {
    Self {
        add: 0,
        mul: 0,
        owner: OwnerID { id: 0 },
    }
}
...
#[wasm_bindgen]
pub fn color(a: Car,color:usize) -&gt; Car {
    Car {
      number: a.number,
      color,
      owner: OwnerID { id: 0 }
    }
}
</pre>
<p>使用上面显示的代码，我们会得到与之前相同的错误:</p>
<pre class="language-shell hljs">error[E0277]: the trait bound `OwnerID: IntoWasmAbi` is not satisfied
 --&gt; src/lib.rs:7:1
  |
7 | #[wasm_bindgen]
  | ^^^^^^^^^^^^^^^ the trait `IntoWasmAbi` is not implemented for `OwnerID`
  |
  = note: this error originates in the attribute macro `wasm_bindgen` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0277]: the trait bound `OwnerID: FromWasmAbi` is not satisfied
 --&gt; src/lib.rs:7:1
  |
7 | #[wasm_bindgen]
  | ^^^^^^^^^^^^^^^ the trait `FromWasmAbi` is not implemented for `OwnerID`
  |
  = note: this error originates in the attribute macro `wasm_bindgen` (in Nightly builds, run with -Z macro-backtrace for more info)
</pre>
<p>为了解决这个问题，像以前一样，我们可以从<code>Car</code>的<code>owner</code>中删除<code>pub</code>，代码将再次编译。然而，现在我们没有办法从 JavaScript 访问<code>owner</code>中的值。</p>
<p>如前所述，<code>Car</code>现在充当<code>OwnerID</code>的句柄；我们可以通过<code>Car</code>获取<code>OwnerID</code>的值。例如，要从<code>OwnerID</code>内部获取<code>id</code>的值，我们可以在<code>Car</code>上定义一个方法，如下所示:</p>
<pre class="language-rust hljs">#[wasm_bindgen]
impl Car {
...
 pub fn get_id(&amp;self) -&gt; usize {
        self.owner.id
    }
...
</pre>
<p>在<code>App.svelte</code>中，运行以下程序:</p>
<pre class="language-javascript hljs">console.log(c3.get_id());
</pre>
<p>现在我们可以看到<code>OwnerId</code>的值<code>id</code>。同样，我们可以定义方法来改变它的值。</p>
<p>此类句柄的另一个用途是当我们需要将不兼容的类型(如<code>Box</code>)传递给某个方法时。我们可以不公开该方法，而是公开另一个方法，该方法采用所需的值来构造不兼容的类型，然后从公开的方法内部调用不兼容的方法。</p>
<p>例如，假设我们有一个方法需要一个<code>OwnerID</code>作为参数。代替那个方法，我们可以公开另一个方法，它接受类型<code>usize</code>的<code>id</code>，从它构造<code>OwnerID</code>，然后调用带有构造的<code>OwnerID</code>作为参数的不兼容方法。</p>
<p>要从 Rust 中连接并调用一个 JavaScript 函数，我们需要将其声明为<code>extern "C"</code>，并用<code>#[wasm_bindgen]</code>进行注释，之后就可以调用该函数了。</p>
<p>值得注意的是，由于 Rust 没有函数重载或变量函数，我们需要声明我们想要在<code>extern</code>块中使用的每个参数组合。</p>
<p>例如，要从 Rust 调用<code>alert</code>,声明如下:</p>
<pre class="language-rust hljs">#[wasm_bindgen]
extern "C" {
    fn alert(s: &amp;str);
}

#[wasm_bindgen]
pub fn greet() {
    alert("Hello in JS from rust!");
}
</pre>
<p>然后，我们可以从 JavaScript 调用它，就像这样:</p>
<pre class="language-javascript hljs">...
let {Car,color,greet} = bindings; // destructure for easier access
...
greet();
</pre>
<p>要使用不同类型的参数调用<code>alert</code>,您需要声明另一个函数，并将其映射到 JavaScript 中的同一个函数。例如，对于以<code>usize</code>作为参数的警报，您需要如下声明它:</p>
<pre class="language-rust hljs">#[wasm_bindgen]
extern "C" {
    fn alert(s: &amp;str);
    #[wasm_bindgen(js_name = alert)]
    fn alert_usize(a: usize);
}
#[wasm_bindgen]
pub fn greet() {
    alert("Hello in JS from rust!");
    alert_usize(5);
}
</pre>
<p>关于如何将 JavaScript 函数绑定到 Rust 函数，如何在模块内绑定函数，以及如何将 struct 的方法绑定为暴露类的构造函数的更多详细信息，<a href="https://rustwasm.github.io/wasm-bindgen/reference/attributes/on-js-imports/index.html" target="_blank" rel="noreferrer noopener">查看</a> <code><a href="https://rustwasm.github.io/wasm-bindgen/reference/attributes/on-js-imports/index.html" target="_blank" rel="noreferrer noopener">wasm-bindgen</a></code> <a href="https://rustwasm.github.io/wasm-bindgen/reference/attributes/on-js-imports/index.html">参考</a>。</p>
<h3 id="using-rust-wasm-svelte-serde-json-approach">用<code>serde.json</code>方法通过 Wasm 使用 Rust</h3>
<p>现在让我们来看看如何使用我们之前提到的<code>serde.json</code>方法，通过一个在 Svelte 中使用 Rust 通过 Wasm 的示例应用程序。</p>
<p>假设您正在开发一个 web 应用程序，它从用户的文件中生成大量数字数据，然后用户可以用一种特殊的文件格式下载这些数据。您希望允许用户上传该文件，然后解析数据，这样您就不必再次生成数据，并且您已经选择通过 Wasm 来这样做。</p>
<p>下面例子中的数据格式保持简单，以避免分散我们学习如何将 Rust 连接到 Svelte 的主要目标的注意力。这将很容易为这个项目生成虚拟数据。</p>
<p>我们使用的格式有点类似于 CSV 文件，第一行的列名用逗号分隔，其余包含数据类型的“行”用分号分隔。我们不会有任何缺失值或使用其他类型的值。</p>
<p>我们的示例文件可能如下所示:</p>
<pre>A,B,C,D;10.2,5,-6.3,-7.8;8.77,5,89,-2.56,3.33
</pre>
<p>这里将不解释解析这些数据的详细代码，但是您可以在本文末尾链接的存储库中查看。对我们的目的来说，重要的是:</p>
<ul>
<li>该功能在名为<code>parser</code>的模块中定义</li>
<li>这个函数的名字是<code>parse</code>，它接受一个<code>&amp;str</code>作为输入</li>
<li>它返回一个<code>HashMap&lt;String,Vec&lt;f64&gt;&gt;</code>，其中字符串键将是第一行中定义的列名</li>
</ul>
<p>让我们创建一个名为<code>parser.rs</code>的新文件，并在其中编写我们的函数:</p>
<pre class="language-rust hljs">use std::collections::HashMap;
use wasm_bindgen::prelude::*;

#[wasm_bindgen]
pub fn parse(input: &amp;str) -&gt; HashMap&lt;String, Vec&lt;f64&gt;&gt; {
...
}
</pre>
<p>默认情况下，任何公共模块都将其内容(用<code>#[wasm_bindgen]</code>注释)导出到 JavaScript。因此，让我们在我们的<code>lib.rs</code>文件中添加以下内容:</p>
<pre class="language-rust hljs">pub mod parser;
</pre>
<p>如果我们现在尝试运行我们的代码，我们会得到以下错误:</p>
<pre class="language-shell hljs">the trait IntoWasmAbi is not implemented for HashMap&lt;String, Vec&lt;f64&gt;&gt;
</pre>
<p>我们可以尝试创建一个句柄，然后通过该句柄访问数据，但这会很繁琐。因为我们知道 JavaScript 中的<code>Map</code>、<code>Vec</code>和<code>String</code>对象存在兼容的数据结构，我们将使用前面提到的<code>serde-json</code>方法。</p>
<p>如下所示更改<code>Cargo.toml</code>文件:</p>
<pre class="language-toml hljs">serde = { version = "1.0.137", features = ["derive"] }
wasm-bindgen = { version= "0.2.63", features = ["serde-serialize"] }
</pre>
<p>接下来，按如下方式更改函数:</p>
<pre class="language-rust hljs">pub fn parse(input: &amp;str) -&gt; JsValue {
  let mut ret: HashMap&lt;String, Vec&lt;f32&gt;&gt; = HashMap::new();
  ...
  JsValue::from_serde(&amp;ret).unwrap()
}
</pre>
<p>现在它可以编译了，我们又回到了正轨。</p>
<p>我们可以从 JavaScript 通过如下所示的<code>App.svelte</code>访问<code>parse</code>函数:</p>
<pre class="language-javascript hljs">let {Car,color,greet,parse} = bindings; // destructure for easier access
console.log(parse("A,b,c;5;6.3;7.8"));
</pre>
<p>我们可以看到它返回一个对象，键作为列名，值作为各自值的数组。</p>
<p>接下来，我们将它连接到前端的一个事件，这样用户就可以上传文件并解析其内容。</p>
<p>为此，只需使用<code>carbon-components-svelte</code>的<code>FileUploader</code>组件。我们将首先在 UI 中显示结果，这样我们就可以知道文件正在被正确地上传和访问:</p>
<pre class="language-javascript hljs">&lt;script&gt;
...
import {Content,FileUploader} from 'carbon-components-svelte';

let files = []; // file handles will be added in this

let content = ""; // for us to see the contents

let reader = new FileReader();

// add listener to load event, which fires when file read is completed successfully
reader.addEventListener("load",() =&gt; {
  content = reader.result; // set content in ui, so we can see it
},false);

// this will be used as callback to file uploader
let add_handler = (e) =&gt; {
  reader.readAsText(e.detail[0]);
}
...
&lt;/script&gt;

&lt;Content&gt;

&lt;h1&gt;
    Connecting rust to Svelte Through wasm !
&lt;/h1&gt;

&lt;br /&gt;

&lt;div&gt;
  &lt;FileUploader
      labelTitle="Upload file"
      buttonLabel="Add file"
      labelDescription="Only txt files are accepted."
      accept={[".txt"]}
      bind:files
      status="complete"
      on:add={add_handler}
    /&gt;
&lt;/div&gt;

&lt;br /&gt;

&lt;h3&gt;
  File Contents Are :&lt;br/&gt;
  {content}
&lt;/h3&gt;

&lt;/Content&gt;
</pre>
<p>如果我们刷新页面并上传一个包含虚拟数据的文本文件，如下所示:</p>
<pre>A,B,C,D;
1.5,1.5,5.1,5.1;
7.5,5.7,5.5,7.7;
</pre>
<p>我们可以看到它上传了文件，其内容可以被读取。</p>
<p>现在，我们可以在事件监听器中调用<code>parse</code>函数，而不是显示内容。我们将获得解析后的数据，然后应用程序可以根据需要使用这些数据。</p>
<p>这样，我们已经成功地将我们的苗条应用程序连接到我们的 Rust 代码，并在它们之间传递数据！</p>
<h2 id="increasing-wasm-memory-size">增加 Wasm 内存大小</h2>
<p>如前所述，默认情况下，Wasm 代码有 1 MB 的堆栈内存供其使用。这个内存量对于许多应用程序来说已经足够了，但是有时候，我们可能需要更多的内存。在这种情况下，我们可以通过在一个<code>config</code>文件中设置一个特定的选项来增加大小。</p>
<p>比如我们前面提到的 8086 例子，虚拟机本身就需要 1 MB 的内存。除此之外，它还存储一些数据和一个小编译器。因此，默认的 1 MB 内存对于整个项目来说是不够的。</p>
<p>为了增加内存大小，我们必须在 Rust 项目目录中创建一个<code>.cargo</code>目录，在我们的例子中称为<code>rust</code>目录。接下来，在<code>.cargo</code>目录中创建一个名为<code>config</code>的文件。在这个文件中，我们可以指定分配给它的内存大小，如下所示:</p>
<pre class="language-toml hljs">[target.wasm32-unknown-unknown]
rustflags = [
"-C", "link-args=-z stack-size=2000000",
]
</pre>
<p>在上面的代码中，我们指定堆栈大小为 2 MB，以字节表示。现在，编译后的 Wasm 应用程序将被分配 2 MB 的堆栈内存，而不是默认的 1 MB。</p>
<h2 id="conclusion">结论</h2>
<p>现在你知道了如何使用 Wasm 将一个苗条的应用程序连接到 Rust 库，以及如何从 JavaScript 调用用 Rust 编写的函数。您还可以从 Rust 调用 JavaScript 函数，并跨越 Rust-JavaScript 边界传递复杂的数据结构。</p>
<p>有了这些知识，你现在可以编写可用于 web 和桌面应用程序的库，或者制作一个快速的交互界面来展示库的使用。</p>
<p>你可以在我的 Github 库中获得这个项目的代码。感谢您的阅读！</p><div class="code-block code-block-29">
<div class="blog-plug inline-plug rust-plug"><h2><a href="https://lp.logrocket.com/blg/rust-signup" target="_blank">log rocket</a>:Rust 应用的 web 前端的全面可见性</h2><p>调试 Rust 应用程序可能很困难，尤其是当用户遇到难以重现的问题时。如果您对监控和跟踪 Rust 应用程序的性能、自动显示错误、跟踪缓慢的网络请求和加载时间感兴趣，</p><a href="https://lp.logrocket.com/blg/rust-signup" target="_blank">try LogRocket</a><p>. </p><a class="signup" href="https://lp.logrocket.com/blg/rust-signup" target="_blank" rel="noopener noreferrer"><img class="alignnone size-full wp-image-46 jetpack-lazy-image" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/><noscript><img data-lazy-fallback="1" class="alignnone size-full wp-image-46" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/></noscript></a><p>LogRocket 就像是网络和移动应用程序的 DVR，记录你的 Rust 应用程序上发生的一切。您可以汇总并报告问题发生时应用程序的状态，而不是猜测问题发生的原因。LogRocket 还可以监控应用的性能，报告客户端 CPU 负载、客户端内存使用等指标。</p><p>现代化调试 Rust 应用的方式— <a class="signup" href="https://lp.logrocket.com/blg/rust-signup" target="_blank" rel="noopener noreferrer">开始免费监控</a>。</p></div>


</div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
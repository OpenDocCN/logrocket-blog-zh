<html>
<head>
<title>Comparing Elixir with Rust and Go - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>仙丹与Rust和Go - LogRocket博客的比较</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/comparing-elixir-rust-go/#0001-01-01">https://blog.logrocket.com/comparing-elixir-rust-go/#0001-01-01</a></blockquote><div><article class="article-post">
<p>编程从来都是为了快速高效地完成任务。新开发人员通常开始使用JavaScript或Python等语言编写代码，这些语言具有构建大规模应用程序的出色特性。</p>
<p>但是，随着应用程序的增长，可伸缩性、并发性和容错变得与应用程序功能一样重要。任何拥有合理数量客户的公司都会有不止一个语言堆栈，因为有些语言比其他语言更好地处理特定的任务。这就是像Elixir、Rust和Go这样的语言出现的原因。</p>
<p>在系统编程语言之战中，Elixir、Rust和Go脱颖而出，成为开发者的三大选择。在本文中，我们将研究Elixir，并简要比较它与Go和Rust的性能。</p>
<p><em>向前跳转:</em></p>

<h2 id="what-erlang">什么是二郎？</h2>
<p>在深入研究Elixir之前，让我们快速了解一下Erlang是什么。</p>
<p><a href="https://www.erlang.org/" target="_blank" rel="noopener"> Erlang </a>诞生于20世纪80年代，旨在解决可靠的电话切换问题。它的名字来源于爱立信语言，因为它是在爱立信计算机科学实验室创建的，用于构建下一代电话交换机。</p>
<p>Erlang提供了创建高度可伸缩的并发代码的特性，以及令人印象深刻的正常运行时间和容错能力。Erlang的一个额外优势是<a href="https://www.erlang.org/blog/a-brief-beam-primer/" target="_blank" rel="noopener"> BEAM虚拟机</a>，这是一个将Erlang代码编译成字节码的快速编译器。</p>
<h2 id="what-elixir">什么是仙丹？</h2>
<p><a href="https://elixir-lang.org/" target="_blank" rel="noopener"> Elixir </a>是构建在Erlang之上的函数式并发编程语言。像Erlang一样，Elixir使用BEAM VM工作。这使得Erlang VM具有更高的可扩展性和生产率，同时保持与Erlang生态系统的兼容性。</p>
<p>创造者<a href="https://github.com/josevalim" target="_blank" rel="noopener"> Jose Valim </a>将Elixir设计成一种高并发、低延迟的语言，能够处理大量数据。Elixir还使用了Ruby的一些最好的特性，尤其是它的语法相似性。</p>
<p>灵药属于<a href="https://en.wikipedia.org/wiki/Message_passing" target="_blank" rel="noopener">消息传递</a>语言的范畴。与大多数直接调用函数来执行动作的语言不同，消息传递语言基于接收到的消息来确定它们的动作。例如，他们可以在收到订单时生成发票。</p>
<p>在<a href="https://blog.logrocket.com/methods-for-microservice-communication/" target="_blank" rel="noopener">微服务架构</a>的时代，像Elixir这样的语言提供了构建无缝协同工作的并发应用程序的工具。既然你明白了什么是仙丹，那就来看看仙丹能做什么，不能做什么。</p>
<h2 id="elixir-pros">使用长生不老药的好处</h2>
<h3 id="pro-concurrency-scalability">并发性和可伸缩性</h3>
<p>并发性和可伸缩性是Elixir的核心理念。并发是指同时但独立地运行多个进程的能力。这是通过使用Erlang VM实现的。</p>
<p>Elixir的并发模型基于<a href="https://elixirschool.com/en/lessons/intermediate/concurrency" target="_blank" rel="noopener"> Actors </a>。在分布式体系结构中，参与者是纯粹通过消息传递与其他流程进行通信的流程。并发性与消息传递架构相结合，使得Elixir成为构建分布式应用程序的绝佳选择。</p>
<p>可伸缩性也内置于Elixir中。由于Elixir中构建的应用程序是一组独立的独立进程，它们之间的所有信息都通过消息传递。这使得Elixir应用程序高度可伸缩。如果一个函数需要更多的资源，你需要做的就是复制现有的函数，并将它们添加到应用程序中。</p>
<h3 id="pro-fault-tolerance">容错</h3>
<p>长生不老药计划理论上可以永远运行。作为开发人员，您理解编写和维护代码的困难。维护一个有许多移动部件的系统更具挑战性，尤其是在分布式架构中。</p>
<p>Elixir使用<a href="https://elixir-lang.org/getting-started/mix-otp/supervisor-and-application.html" target="_blank" rel="noopener">管理器和应用程序模型</a>来构建容错系统。在Elixir中，您将拥有一个启动应用程序中其他进程的顶级管理进程。这些子流程可以有更多的主管和他们自己的子流程。这种递归结构也称为监督树。</p>
<p>任何进程的管理者都可以重新启动所有失败的子进程。此外，如果主管愿意，他可以失败，将决策权委托给其上一级主管。这种进程的监督和应用模型是Elixir容错背后的核心原因。</p>
<h3 id="pro-easier-learning-curve">更容易的学习曲线</h3>
<p>与Rust和Go等语言相比，Elixir的学习曲线更容易。这是因为Elixir在语法上与Ruby相似。Elixir还被设计成更容易采用，不像Erlang，它有一个陡峭的学习曲线。</p>
<p>更容易的学习曲线有助于建立灵丹妙药团队和培训内部人员。这也可以从不断增长的社区对Elixir的支持中看出来，尽管它是一种相对较新的语言。</p>
<h2 id="elixir-cons">长生不老药</h2>
<h3 id="con-dynamically-typed">动态类型化</h3>
<p>虽然<a href="https://blog.logrocket.com/tag/rust/" target="_blank" rel="noopener"> Rust </a>和<a href="https://blog.logrocket.com/tag/go/" target="_blank" rel="noopener"> Go </a>是静态类型的语言，但Elixir是动态类型的。区别很简单:在Rust and Go中执行程序之前，必须先编译程序。这导致编译时间比Elixir慢。然而，这意味着Rust和Go在速度和内存消耗方面可以胜过Elixir。</p>
<h3 id="con-functional-language">函数式语言</h3>
<p>Elixir是一种纯函数式编程语言。Go和Rust提供了面向对象，使得构建复杂的类更加容易。然而，这是有意的。Elixir用于构建相互通信的分布式进程的集合，因此类和对象对于像Elixir这样的语言来说是多余的。</p>

<p>Elixir是一种相对较新的编程语言，因此寻找开发人员和支持可能是一个挑战。开发团队通常为特定的用例选择像Elixir这样的语言，所以Elixir社区仍然需要努力将其列入最常用的编程语言列表。</p>
<h2 id="who-uses-elixir">谁用长生不老药？</h2>
<ul>
<li>Adobe:使用Elixir构建客户端/云应用程序，实现无缝协作的摄影工作流程</li>
<li>Discord:使用Elixir进行大规模消息传递，管理数百万并发用户</li>
<li>摩托罗拉:将Erlang和Elixir用于需要可靠和容错的关键任务通信系统</li>
</ul>
<h2 id="comparing-elixir-go">灵丹妙药与围棋的比较:速度、规模和安全性</h2>
<p>Go是一种静态类型和编译的编程语言。Go作为一种系统编程语言越来越受欢迎，并且是少数几种支持编写AWS lambda函数的语言之一:</p>
<ul>
<li>速度:因为Go是一种编译语言，所以它在速度方面提供了更好的性能。编译后的程序在速度上总是更好，但是在开发时间上有所折衷</li>
<li>鳞片:如果你主要关心的是鳞片，仙丹是一个更好的选择。Go提供了可伸缩性，但在从头开始扩展应用程序方面，Elixir遥遥领先</li>
<li>安全性:Go提供了内存安全特性，但是Elixir具有更好的内存安全性，因为它只能与消息传递架构一起工作。由于Elixir进程只能共享内存，不能直接相互调用，因此与Go相比，Elixir在安全性方面得分更高</li>
</ul>
<h2 id="comparing-elixir-rust">仙丹与铁锈的比较:速度、规模和安全性</h2>
<p>Rust是开发人员社区中最受欢迎的编程语言之一。Rust的主要卖点是速度和内存安全。如果你想了解更多关于Rust的内容，可以看看我关于Rust迭代器和闭包的文章:</p>
<ul>
<li>速度:由于Rust也是一种像Go一样的编译语言，它在速度方面提供了更好的性能</li>
<li>伸缩性:由于其内置的并发性和容错设计，Elixir更容易伸缩。监督者模型还使Elixir程序更容易构建分布式应用程序。Rust也提供并发性，但是Elixir在分布式架构中表现更好</li>
<li>安全性:保证内存安全是开发者选择Rust的主要原因。由于变量和内存受到严格控制，Rust提供了比Elixir应用程序更好的安全性</li>
</ul>
<h2 id="benchmarks-elixir-rust-go">药剂、铁锈和围棋性能的基准</h2>
<p>让我们看看Elixir、Go和Rust之间的一些性能指标评测。我们将通过运行两个程序来看看这些语言的性能——一个<code>"Hello, World!"</code>函数和一个<a href="https://paperswithcode.com/method/spectral-normalization" target="_blank" rel="noopener">谱归一化函数</a>。</p>
<p>该函数在屏幕上打印文本<code>"Hello, world!"</code>，而谱范数函数计算矩阵的最大奇异值。</p>
<h3><span> <span> <code>Hello, World!</code> </span> </span> : <a href="https://github.com/hanabi1224/Programming-Language-Benchmarks/blob/main/bench/algorithm/helloworld/1.ex" target="_blank" rel="noopener">仙丹</a>vs<a href="https://github.com/hanabi1224/Programming-Language-Benchmarks/blob/main/bench/algorithm/helloworld/1.go" target="_blank" rel="noopener">围棋</a>vs<a href="https://github.com/hanabi1224/Programming-Language-Benchmarks/blob/main/bench/algorithm/helloworld/1.rs" target="_blank" rel="noopener">铁锈</a></h3>
<pre>  +-----------+--------------------+-----------------+------------+
  |   Metric  |       Elixir       |       Go        |   Rust     |
  +-----------+--------------------+-----------------+------------+
  |  Time     | 212 ms             | 1.7 ms          | 1.6 ms     |
  |  Memory   | 45.5 MB            | 2.0 MB          | 0.6 MB     |
  +-----------+--------------------+-----------------+------------+
</pre>
<h3>谱范:<a href="https://github.com/hanabi1224/Programming-Language-Benchmarks/blob/main/bench/algorithm/spectral-norm/1.ex" target="_blank" rel="noopener">仙丹</a>vs<a href="https://github.com/hanabi1224/Programming-Language-Benchmarks/blob/main/bench/algorithm/spectral-norm/1.go" target="_blank" rel="noopener">围棋</a>vs<a href="https://github.com/hanabi1224/Programming-Language-Benchmarks/blob/main/bench/algorithm/spectral-norm/8-m.rs" target="_blank" rel="noopener">铁锈</a></h3>
<pre>  +-----------+--------------------+-----------------+------------+
  |   Metric  |       Elixir       |       Go        |   Rust     |
  +-----------+--------------------+-----------------+------------+
  |  Time     | timeout            | 4892 ms         | 1058 ms    |
  |  Memory   | 0.0 MB             | 5.5 MB          | 2.6 MB     |
  +-----------+--------------------+-----------------+------------+
</pre>
<p>如你所见，Rust远远胜过Go和Elixir。Elixir在运行计算密集型操作(如spectral norm)时也会超时，因此对于复杂算法(如神经网络)来说，它不是一个很好的选择。</p>
<h2>摘要</h2>
<p>尽管是一种相对较新的编程语言，但Elixir有许多实际应用。分布式系统，包括<a href="https://blog.logrocket.com/tag/blockchain/" target="_blank" rel="noopener">区块链</a>和物联网服务，可以利用Elixir构建可靠的容错架构。随着越来越多的社区支持和更容易的学习曲线，Elixir是一种值得花时间学习的优秀语言。</p><div class="code-block code-block-29">
<div class="blog-plug inline-plug rust-plug"><h2><a href="https://lp.logrocket.com/blg/rust-signup" target="_blank">log rocket</a>:Rust应用的web前端的全面可见性</h2><p>调试Rust应用程序可能很困难，尤其是当用户遇到难以重现的问题时。如果您对监控和跟踪Rust应用程序的性能、自动显示错误、跟踪缓慢的网络请求和加载时间感兴趣，</p><a href="https://lp.logrocket.com/blg/rust-signup" target="_blank">try LogRocket</a><p>. </p><a class="signup" href="https://lp.logrocket.com/blg/rust-signup" target="_blank" rel="noopener noreferrer"><img class="alignnone size-full wp-image-46 jetpack-lazy-image" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/><noscript><img data-lazy-fallback="1" class="alignnone size-full wp-image-46" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/></noscript></a><p>LogRocket 就像是网络和移动应用程序的DVR，记录你的Rust应用程序上发生的一切。您可以汇总并报告问题发生时应用程序的状态，而不是猜测问题发生的原因。LogRocket还可以监控应用的性能，报告客户端CPU负载、客户端内存使用等指标。</p><p>现代化调试Rust应用的方式— <a class="signup" href="https://lp.logrocket.com/blg/rust-signup" target="_blank" rel="noopener noreferrer">开始免费监控</a>。</p></div>


</div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
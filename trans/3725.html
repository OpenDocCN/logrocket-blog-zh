<html>
<head>
<title>Test advanced coroutines with Kotlin Playground </title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>用Kotlin Playground测试高级协同程序</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/test-advanced-coroutines-kotlin-playground/#0001-01-01">https://blog.logrocket.com/test-advanced-coroutines-kotlin-playground/#0001-01-01</a></blockquote><div><article class="article-post">
<p>测试是开发人员生活中必不可少的一部分。经过测试的代码更容易维护，测试也经常作为文档。</p>
<p>如果你曾经和Kotlin一起工作过，你可能已经写了很多测试，但是你有没有试过和Kotlin Playground一起工作？</p>
<p>在本文中，我们将演示如何使用Kotlin Playground来测试您的代码。我们还将分享一些可以用来简化异步代码的高级协同程序概念。</p>
<p><em>向前跳转:</em></p>

<h2 id="what-is-kotlin-playground">什么是科特林游乐场？</h2>
<p>有时候我们只是想要一个快速的方法来测试一些东西，但是打开Android Studio或另一个代码编辑器需要一些时间。如果有一种方法可以快速检验你的想法会怎么样？这就是科特林游乐场的意义。</p>
<p>Playground是一个能够运行Kotlin代码的编辑器，最重要的是，它可以在你的浏览器上运行。它是由JetBrains开发和维护的。要访问它，请前往play.kotlinlang.org。</p>
<p>Kotlin Playground附带了所有的标准Kotlin库(集合、反射、协程等)。)但不支持添加新库，这意味着您只能使用它来原型化或测试依赖于标准Kotlin库的东西。</p>
<p>Kotlin Playground的一个很棒的特性是，它可以让你轻松地与他人分享你写的代码。只需复制页面URL并将其发送给其他人，或者使用“共享代码”按钮来获得代码的可嵌入版本。</p>
<p>科特林游乐场还有一个隐藏的特色。如果您按住Ctrl (Windows)或Command (Mac)键四处单击，将会创建更多光标。如果您需要同时编辑多行代码，这非常有用:</p>
<p><img data-attachment-id="150597" data-permalink="https://blog.logrocket.com/test-advanced-coroutines-kotlin-playground/attachment/editing-multiple-lines-of-code/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/12/editing-multiple-lines-of-code.png" data-orig-size="257,152" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Editing multiple lines of code" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/12/editing-multiple-lines-of-code.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/12/editing-multiple-lines-of-code.png" decoding="async" class="aligncenter wp-image-150597 size-full jetpack-lazy-image" src="../Images/906c19e7c01c7dbff2005fcfd881baa6.png" alt="Creating Multiple Cursors with Kotlin Playground" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2022/12/editing-multiple-lines-of-code.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/12/editing-multiple-lines-of-code.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="150597" data-permalink="https://blog.logrocket.com/test-advanced-coroutines-kotlin-playground/attachment/editing-multiple-lines-of-code/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/12/editing-multiple-lines-of-code.png" data-orig-size="257,152" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Editing multiple lines of code" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/12/editing-multiple-lines-of-code.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/12/editing-multiple-lines-of-code.png" decoding="async" loading="lazy" class="aligncenter wp-image-150597 size-full" src="../Images/906c19e7c01c7dbff2005fcfd881baa6.png" alt="Creating Multiple Cursors with Kotlin Playground" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/12/editing-multiple-lines-of-code.png"/></noscript>
<p>自2022年5月起，Playground也支持移动设备，所以你甚至不需要电脑来运行Kotlin代码。还添加了一个动作工具栏，允许您选择Kotlin版本、选择编译器和设置程序参数。</p>
<h2 id="getting-started-with-playground">游乐场入门</h2>
<p>为了在操场上运行代码，我们需要创建一个main方法；否则，我们将得到一个“在项目中没有找到main方法”的错误。</p>
<p>对于本教程，我将使用带有JVM编译器的Kotlin v1.7.21。请确保还将以下导入添加到文件的顶部:</p>
<pre class="language-kotlin hljs">import kotlin.test.*
import kotlinx.coroutines.*
</pre>
<p>这样做之后，你应该有一个类似这样的操场:</p>
<p><img data-attachment-id="150601" data-permalink="https://blog.logrocket.com/test-advanced-coroutines-kotlin-playground/attachment/playground-example/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/12/playground-example.png" data-orig-size="730,238" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Playground example" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/12/playground-example-300x98.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/12/playground-example.png" decoding="async" class="aligncenter wp-image-150601 size-full jetpack-lazy-image" src="../Images/4f00d7b5e69a29706b3942019e52c2e2.png" alt="Playground Example, Running Kotlin Code" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2022/12/playground-example.png 730w, https://blog.logrocket.com/wp-content/uploads/2022/12/playground-example-300x98.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2022/12/playground-example.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/12/playground-example.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="150601" data-permalink="https://blog.logrocket.com/test-advanced-coroutines-kotlin-playground/attachment/playground-example/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/12/playground-example.png" data-orig-size="730,238" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Playground example" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/12/playground-example-300x98.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/12/playground-example.png" decoding="async" loading="lazy" class="aligncenter wp-image-150601 size-full" src="../Images/4f00d7b5e69a29706b3942019e52c2e2.png" alt="Playground Example, Running Kotlin Code" srcset="https://blog.logrocket.com/wp-content/uploads/2022/12/playground-example.png 730w, https://blog.logrocket.com/wp-content/uploads/2022/12/playground-example-300x98.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/12/playground-example.png"/></noscript>
<p>如果您按下紫色的run按钮，代码应该会编译，您应该不会看到任何错误。</p>
<h2 id="understanding-advanced-kotlin-coroutines">了解高级Kotlin协同程序</h2>
<p>在我们深入测试之前，让我们回顾一些<a href="https://blog.logrocket.com/understanding-kotlin-coroutines/"> Kotlin协程概念</a>。</p>
<p><code>CoroutineContext</code>是协程的重要组成部分，它定义了协程的行为方式，并具有四个公共元素:</p>
<ul>
<li><code>Job</code>:控制协程的生命周期；默认情况下，这个元素是一个<code>Job </code>，但是您也可以指定一个<code>SupervisorJob</code></li>
<li><code>CoroutineDispatcher</code>:定义协程应该在哪个线程组中执行；大多数时候你会使用<code>Main</code>或<code>IO</code>调度程序</li>
<li><code>CoroutineExceptionHandler</code>:定义未捕获的异常应该发生什么</li>
<li><code>CoroutineName</code>:为协程定义一个名称(本文后面会详细介绍)</li>
</ul>
<p>如果您使用过<code>withContext</code> scope函数，您可能会对它的性能感到疑惑。如果您有一个很长的操作链，并且其中许多操作使用<code>withContext</code>来确保工作在正确的线程中执行，这难道不会增加很大的性能开销吗？</p>
<p>如果我们看一下它的<a href="https://github.com/Kotlin/kotlinx.coroutines/blob/master/kotlinx-coroutines-core/common/src/Builders.common.kt#L144">实现</a>，我们会看到有两条快速路径。第一个将当前上下文与新上下文进行比较。如果它们是相同的，就没有必要改变线程。第二条路径比较调度程序。如果它们是相同的，也没有必要改变线程。</p>
<p>因此，如果调度程序是相同的，我们不必担心线程，开销是最小的。</p>
<p>流动是价值流。如果您需要合并它们，有一个简洁的操作符可以实现，即<code>combine</code>操作符允许您根据需要合并任意多的流。下面是它最简单的签名:</p>
<pre class="language-kotlin hljs">fun &lt;T1, T2, R&gt; Flow&lt;T1&gt;.combine(flow: Flow&lt;T2&gt;, transform: suspend (T1, T2) -&gt; R): Flow&lt;R&gt;
</pre>
<p>让我们假设你有<code>flowA</code>和<code>flowB</code>并且你想合并它们。为此，请使用以下代码:</p>
<pre class="language-kotlin hljs">flowA.combine(flowB) { a, b -&gt;
    // combine them and emit a new value
}
</pre>
<p>或者，您可以使用上面代码的顶级版本:</p>
<pre class="language-kotlin hljs">combine(flowA, flowB) { a, b -&gt;
    // combine them and emit a new value
}
</pre>
<h2 id="testing-advanced-coroutines">测试高级协同程序</h2>
<p>现在，让我们继续测试。我们将看看如何测试正常的<code>suspend</code>功能，如何切换/注入测试调度程序，以及如何测试<code>launch</code> / <code>async</code>、<code>Job</code> / <code>SupervisorJob</code>和流。</p>
<h3 id="testing-normal-suspend-functions">测试正常<code>suspend</code>功能</h3>
<p>让我们从定义一个<code>suspend</code>函数开始，这样我们就有东西来编写我们的测试了。假设我们有一个函数返回某个特性是否被启用:</p>
<pre class="language-kotlin hljs">suspend fun isEnabled(): Boolean {
    delay(1_000)
    return true
}
</pre>
<p>现在，让我们在main函数中编写测试。<code>assertTrue</code>由<code>kotlin.test</code>提供，断言我们传入的变量是<code>true</code>；否则，它会引发异常:</p>
<pre class="language-kotlin hljs">fun main() {
    runBlocking {
        val result = isEnabled()
          assertTrue(result)
    }
}
</pre>
<p>如果我们运行这段代码，我们将不会得到任何输出，因为测试已经通过，但是如果我们将<code>isEnabled</code>改为返回<code>false</code>，我们将得到以下错误:</p>
<pre class="language-kotlin hljs">Exception in thread "main" java.lang.AssertionError: Expected value to be true.
</pre>
<p>如果您想向<code>assertTrue</code>添加自定义消息，请使用以下内容:</p>
<pre class="language-kotlin hljs">assertTrue(result, "result should be true but wasn't")
</pre>
<p>这将导致以下输出:</p>
<pre class="language-kotlin hljs">Exception in thread "DefaultDispatcher-worker-1 @coroutine#1" java.lang.AssertionError: result should be true but wasn't
</pre>
<h3 id="switching-injecting-test-dispatchers">切换/注入测试调度程序</h3>
<p>在代码中硬编码调度程序不是好的做法。只要有可能，您应该接受dispatcher作为您的类中的一个参数。</p>
<p>看一下下面的代码:</p>
<pre class="language-kotlin hljs">class Database {    
    private val scope = CoroutineScope(Dispatchers.IO)


    fun saveToDisk() {
        scope.launch {
            ...
          }
    }
}
</pre>
<p>这个很难测试。为了使事情更简单，我们可以将它更改如下:</p>
<pre class="language-kotlin hljs">class Database(private val scope: CoroutineScope) {
    fun saveToDisk() {
        scope.launch {
            ...
          }
    }
}
</pre>
<p>这样，可以在测试期间注入范围。</p>
<h3 id="testing-launch-async">测试<code>launch</code> / <code>async</code></h3>
<p><code>launch</code>和<code>async</code>可能是<code>Compose</code>中使用最多的功能，尤其是对Android开发者而言。那么，我们如何测试它们呢？</p>
<p>让我们从定义一个保存一些状态的简单函数开始。您不能调用<code>suspend</code>函数，因为在您的活动或片段中没有作用域。但是，使用协程可以帮助您避免阻塞主线程，当您将内容保存到后端时，可能会发生阻塞:</p>
<pre class="language-kotlin hljs">private val scope = CoroutineScope(Dispatchers.IO)

fun saveState() {
    scope.launch {
        // save state to backend, disk, ...
    }
}
</pre>
<p>假设我们没有数据库或服务器，让我们创建一个变量来假装我们做了一些事情:</p>
<pre class="language-kotlin hljs">private val state: Any? = null

fun saveState() {
    scope.launch {
        state = "application state"
    }
}
</pre>
<p>现在我们有了可测试的东西，让我们编写测试:</p>
<pre class="language-kotlin hljs">fun main() {
    runBlocking {
        saveState()
          assertNotNull(state)
    }
}
</pre>
<p>这应该可以，对吧？如果我们运行这段代码，我们会得到一个错误，说<code>state</code>是<code>null</code>。这段代码的问题是它调用了<code>saveState</code>，但并没有等待它执行，所以我们在操作完成前检查结果。</p>
<p>要解决这个问题，我们可以简单地在检查<code>state</code>之前添加一个小延迟，就像这样:</p>
<pre class="language-kotlin hljs">fun main() {
    runBlocking {
        saveState()
          delay(100)
          assertNotNull(state)
    }
}
</pre>
<p>这样，<code>saveState</code>就有时间在我们检查变量之前执行。然而，使用<code>delay</code>来测试您的代码并不是最佳实践。为什么正好是100毫秒而不是200毫秒？如果代码执行时间超过100ms怎么办？这就是为什么我们应该避免这种做法。在本文的稍后部分，我将向您展示一种更好的测试方法。</p>
<p>测试<code>async</code>也是类似的过程；让我们修改<code>saveState</code>，使其使用<code>async</code>:</p>
<pre class="language-kotlin hljs">fun saveState() {
    scope.launch {
        async { state = "application state" }.await()
    }
}

fun main() {
    runBlocking {
        saveState()
      delay(100)
          assertNotNull(state)
    }
}
</pre>
<p>现在，运行这段代码；你会看到它像预期的那样工作。</p>
<h3 id="testing-job-supervisorjob">测试<code>Job</code> / <code>SupervisorJob</code></h3>
<p>接下来，我们来探讨一下如何测试<code>Jobs</code>。如果你使用<code>GlobalScope</code>，测试你的代码是非常困难的，因为你不能替换或模仿它。此外，因为你不能取消<code>GlobalScope</code>，如果你使用它，你基本上失去了对工作的控制。相反，我们将为我们的测试定义一个定制的范围，如果需要，我们可以控制这个范围:</p>
<pre class="language-kotlin hljs">private val scope = CoroutineScope(Dispatchers.Default)
</pre>
<p>我们可以定义一个变量来跟踪<code>Job</code>并且修改<code>saveState</code>来将<code>launch</code>的结果赋给这个变量:</p>
<pre class="language-kotlin hljs">private var job: Job? = null
private var state: Any? = null

fun saveState() {
    job = scope.launch {
        println("application state")
    }
}
</pre>
<p>现在，在主函数中，我们可以测试<code>saveState</code>函数:</p>
<pre class="language-kotlin hljs">fun main() {
    runBlocking {
        saveState()
          job?.join()
          assertNotNull(state)
    }
}
</pre>
<p>运行这个，你应该不会得到任何错误。</p><div class="code-block code-block-54">
<hr/>
<h3>更多来自LogRocket的精彩文章:</h3>

<hr/></div>
<p>你可能会问，“为什么我们需要使用<code>join</code>？”嗯，调用<code>launch</code>不会阻塞代码执行，所以我们需要使用<code>join</code>来阻止主函数退出。</p>
<p>现在我们知道了如何测试一个<code>Job</code>，让我们学习如何测试一个<code>SupervisorJob</code>。</p>
<p>一个<code>SupervisorJob</code>类似于一个<code>Job</code>，除了它的子节点可以彼此独立地失败。让我们从改变我们的工作范围开始，让我们有一个主管的工作:</p>
<pre class="language-kotlin hljs">val scope = CoroutineScope(SupervisorJob())
</pre>
<p>现在，在我们的主函数中，让我们添加另一个<code>launch</code>来抛出一个错误:</p>
<pre class="language-kotlin hljs">fun main() {
    runBlocking {
        scope.launch { throw error("launch1") }.join()
      saveState().join()
          assertNotNull(state)
    }
}
</pre>
<p>运行这个命令，您会在输出中看到一个错误。嗯，难道不应该防止这种情况发生吗？如果我们更详细地分析它，我们会看到它确实防止了错误冒泡，但并没有阻止它被记录。如果您在断言下面添加一个<code>println</code>语句，您会看到它实际上被打印出来了；因此，即使第一个<code>launch</code>出错，第二个也能运行。</p>
<h3 id="testing-flows">测试流程</h3>
<p>为了测试流，我们将从添加一个新的导入开始:</p>
<pre class="language-kotlin hljs">import kotlinx.coroutines.flow.*
</pre>
<p>接下来，让我们创建一个名为<code>observeData</code>的函数，它只返回一个流:</p>
<pre class="language-kotlin hljs">fun observeData(): Flow&lt;String&gt; {
    return flowOf("a", "b", "c")
}
</pre>
<p>现在，在我们的main方法中，我们可以使用assertEquals函数来比较期望值和实际值:</p>
<pre class="language-kotlin hljs">suspend fun main() = runBlocking&lt;Unit&gt; {
    val expected = listOf("a", "b", "c")
    assertEquals(expected, observeData().toList())
}
</pre>
<h2 id="strategies-to-improve-testing">改进测试的策略</h2>
<p>现在，我们对如何测试高级协程有了更好的理解，让我们来看看一些使协程测试和调试更容易的策略。</p>
<h3 id="naming-your-coroutinescope">命名您的<code>CoroutineScope</code></h3>
<p>如果您有许多协同程序作用域，调试它们可能会很困难，因为它们都使用类似于@协同程序#1、@协同程序#2等的命名约定。</p>
<p>为了使调试更容易，我们可以将<code>CoroutineName(...)</code>添加到<code>CoroutineScope</code>中，就像这样:</p>
<pre class="language-kotlin hljs">private val scope = CoroutineScope(Dispatchers.Default + CoroutineName("database"))
</pre>
<p>如果在该范围内出现故障，我们将得到如下错误:</p>
<pre class="language-kotlin hljs">Exception in thread "DefaultDispatcher-worker-1 @database#2" java.lang.IllegalStateException: …
</pre>
<h3 id="following-coroutines-best-practices">遵循协程最佳实践</h3>
<p>为了使测试更容易，请遵循以下协程最佳实践:</p>
<ul>
<li>在类中注入调度程序:避免在类中硬编码调度程序。通过允许您替换它们，注入它简化了测试</li>
<li>避免:它让测试变得非常困难，这本身就是一个避免测试的好理由。这也使得控制作业的生命周期变得更加困难</li>
</ul>
<h2>结论</h2>
<p>在本文中，我们探索了如何使用Kotlin Playground测试协程。我们还看了一些协程概念，比如<code>CoroutineContext</code>和<code>Flow</code>。最后，我们讨论了一些使测试更容易的策略。</p>
<p>现在轮到你了；学习的最好方法是通过练习。下次见！</p><div class="code-block code-block-32">
<div class="blog-plug inline-plug kotlin-plug"><h2>LogRocket :即时重现你的安卓应用中的问题。</h2><a class="signup" href="https://lp.logrocket.com/blg/kotlin-signup" target="_blank" rel="noopener noreferrer"><img class="alignnone size-full wp-image-46 jetpack-lazy-image" src="../Images/b5ae4bd0ecde7aa9d5288746416d5e18.png" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2022/11/react-native-plug_android-1.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/11/react-native-plug_android-1.png"/><noscript><img data-lazy-fallback="1" class="alignnone size-full wp-image-46" src="../Images/b5ae4bd0ecde7aa9d5288746416d5e18.png" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/11/react-native-plug_android-1.png"/></noscript></a><p><a href="https://lp.logrocket.com/blg/kotlin-signup" target="_blank" rel="noopener noreferrer"> LogRocket </a>是一款Android监控解决方案，可以帮助您即时重现问题，确定bug的优先级，并了解您的Android应用程序的性能。</p><p>LogRocket还可以向你展示用户是如何与你的应用程序互动的，从而帮助你提高转化率和产品使用率。LogRocket的产品分析功能揭示了用户不完成特定流程或不采用新功能的原因。</p><p>开始主动监控您的Android应用程序— <a class="signup" href="hhttps://lp.logrocket.com/blg/kotlin-signup" target="_blank" rel="noopener noreferrer">免费试用LogRocket】。</a></p></div>
</div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
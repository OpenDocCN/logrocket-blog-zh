<html>
<head>
<title>Activity state and fragment lifecycle in Android apps with Kotlin - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>Android应用中的活动状态和片段生命周期</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/activity-state-fragment-lifecycle-android-apps-kotlin/#0001-01-01">https://blog.logrocket.com/activity-state-fragment-lifecycle-android-apps-kotlin/#0001-01-01</a></blockquote><div><article class="article-post">
<p>在现代Android开发中，活动状态和片段生命周期起着至关重要的作用，影响着实现决策以及最终用户看到和体验到的最终输出。在本文中，我们将回顾这些概念是什么，它们是如何工作的，以及在Android应用程序中实现它们的步骤。</p>
<p>为了跟随本教程，你需要具备Kotlin编程语言的基础知识以及安装的Android Studio或IntelliJ IDE。我们开始吧！</p>

<h2 id="what-activity-state">什么是活动状态？</h2>
<p>一个<a href="https://developer.android.com/reference/kotlin/android/app/Activity">活动</a>指的是用户可以执行的单个动作。在Android开发中，活动是一个Java类，它有一些预定义的函数，可以在不同的应用程序状态下触发，以执行任何类型的任务。该活动还负责创建、销毁和控制应用程序生命周期的其他状态。</p>
<p>一个<a href="https://developer.android.com/guide/components/activities/activity-lifecycle">活动类</a>处理许多计算细节，比如为你创建一个窗口。</p>
<p>在Android中，可以有多个活动，但是只有一个<code>MainActivity</code>，是应用的入口，就像Java中的<code>main()</code>方法开始执行一个程序一样。当我们调用<code>MainActivity</code>类时，执行从<code>onCreate()</code>方法开始。</p>
<p>所有活动的子类都实现了两个方法:</p>
<ul>
<li><code>onPause</code>:允许用户暂停与活动的主动交互</li>
<li><code>onCreate</code>:初始化您的活动。您必须以编程方式调用<code>setContentView()</code></li>
</ul>
<p>我们可以在下面的代码片段中表达这一点。我们使用<code>onCreate</code>方法来创建或启动一个活动，使用<code>super</code>关键字来调用超类构造函数，最后使用<code>setContentView</code>来设置XML:</p>
<pre class="language-kotlin hljs">package com.example.myfirstandroidapplication

import android.os.Bundle
import com.google.android.material.snackbar.Snackbar
import androidx.appcompat.app.AppCompatActivity
import androidx.core.view.WindowCompat
import androidx.navigation.findNavController
import androidx.navigation.ui.AppBarConfiguration
import androidx.navigation.ui.navigateUp
import androidx.navigation.ui.setupActionBarWithNavController
import android.view.Menu
import android.view.MenuItem
import com.example.myfirstandroidapplication.databinding.ActivityMainBinding

class MainActivity : AppCompatActivity() {

    private lateinit var appBarConfiguration: AppBarConfiguration
    private lateinit var binding: ActivityMainBinding

    override fun onCreate(savedInstanceState: Bundle?) {
        WindowCompat.setDecorFitsSystemWindows(window, false)
        super.onCreate(savedInstanceState)

        binding = ActivityMainBinding.inflate(layoutInflater)
        setContentView(binding.root)

        setSupportActionBar(binding.toolbar)

        val navController = findNavController(R.id.nav_host_fragment_content_main)
        appBarConfiguration = AppBarConfiguration(navController.graph)
        setupActionBarWithNavController(navController, appBarConfiguration)

        binding.fab.setOnClickListener { view -&gt;
            Snackbar.make(view, "Replace with your own action", Snackbar.LENGTH_LONG)
                .setAnchorView(R.id.fab)
                .setAction("Action", null).show()
        }
    }

    override fun onCreateOptionsMenu(menu: Menu): Boolean {
        // Inflate the menu; this adds items to the action bar if it is present.
        menuInflater.inflate(R.menu.menu_main, menu)
        return true
    }
</pre>
<p><a href="https://developer.android.com/guide/components/activities/state-changes">活动状态</a>是指由系统或用户触发的事件，导致活动从一种状态转换到另一种状态。</p>
<p>例如，当用户在应用程序中处于活动状态时，他们通常会在点击主页上的应用程序图标到启动应用程序之间转换，然后最终退出应用程序，从而导致状态变化。这些从一种状态到另一种状态的变化被称为活动状态变化。</p>
<h2 id="activity-lifecycle-concepts">什么是活动生命周期？</h2>
<p>系统中发生的活动变化在活动堆栈中管理。最新的活动通常放在当前堆栈的顶部，它成为正在运行的活动，而前一个活动在堆栈中仍然位于它的下面。</p>
<p><a href="https://developer.android.com/guide/components/activities/activity-lifecycle">活动生命周期</a>是指用户执行的整个活动，从启动应用到关闭所有操作。几个活动方法定义了活动的整个生命周期。举个例子，<code>onCreate()</code>是应用被用户启动后的初始状态。下面的代码片段显示了<code>onCreate()</code>方法的语法:</p>
<pre class="language-kotlin hljs">protected void onCreate()
</pre>
<p><code>onPause()</code>是暂停状态，当用户要决定下一步行动时，是退出还是继续使用应用程序:</p>
<pre class="language-kotlin hljs">protected void onPause()
</pre>
<p>当活动从暂停状态恢复时，调用<code>onStart()</code>状态，并使其对用户可见:</p>
<pre class="language-kotlin hljs">protected void onStart()
</pre>
<p><code>onDestroy()</code>是所有活动关闭时产生的状态，导致关闭所有操作:</p>
<pre class="language-kotlin hljs">protected void onDestroy()
</pre>
<p><code>onStop()</code>是用户点击home键产生的状态，通常是最小化app。这不应被误认为是应用程序关闭时的情况:</p>
<pre class="language-kotlin hljs">protected void onStop()
</pre>
<p><code>onResume()</code>是一个回调，当活动停止后重新启动时调用。下面的代码片段显示了该方法的语法:</p>
<pre class="language-kotlin hljs">protected void onResume()
</pre>
<p>上面列出的方法与<code>saveInstanceState()</code>方法结合使用来保存活动UI状态的配置:</p>
<pre class="language-kotlin hljs">public class Activity extends ApplicationContext {
      protected void onCreate(Bundle savedInstanceState);

      protected void onStart();

      protected void onRestart();

      protected void onResume();

      protected void onPause();

      protected void onStop();

      protected void onDestroy();
  }
</pre>
<h2 id="what-fragment-lifecycle">什么是碎片生命周期？</h2>
<p>片段是指活动UI的一部分，它允许我们在Android应用程序中创建多个屏幕。Android v3.0中引入了片段，以支持平板电脑等大屏幕上更灵活的UI设计。在撰写本文时，Android的最新版本<a href="https://www.android.com/android-12/"> v12.x包含了额外的特性</a>,比如更具表现力和动态的系统UI。</p>
<p>在应用程序中创建多个屏幕的一种方法是用一个片段替换另一个片段。</p>
<h2 id="relationship-between-activity-state-fragment-lifecycle">活动状态和片段生命周期之间的关系</h2>
<p>活动通常被认为是操作系统进入应用程序的入口点。在Android应用程序中，活动可以包含多个片段和函数。这些充当包含UI片段的框架，提供围绕该片段的UI元素。</p>
<p>虽然一个活动可以在没有片段的情况下存在，但是你不能在没有活动的情况下使用片段。UI片段的操作类似于活动布局中的视图。为此，您必须创建一个子类，如下面的代码所示:</p>
<pre class="language-kotlin hljs">class InfoFragment: Fragment{
@override fun onCreateView(...): View? {
     return inflater.inflate (
      R.layout.fragment_info,...)
  }
}
</pre>
<p>上面的代码片段显示了一个可重用的UI组件，它包含了扩展片段布局的UI逻辑。虽然大多数UI元素都在片段中实现，但操作系统只能打开活动。</p>
<p>注意，在活动内部，你可以通过调用<code>onCreate</code>中的<code>setContentView</code>来告诉Android使用哪个布局。在片段中，您必须手动膨胀并在<code>onCreateView</code>方法中返回膨胀的布局，这独立于<code>onCreate</code>方法。</p>
<p>下面的代码片段进一步强调了这一点:</p>
<pre class="language-kotlin hljs">// Activity 
override fun onCreate(savedInstanceState : Bundle?) {
  super.onCreate(savedInstanceState)
  val binding = DataBindingUtil
  .setContentView&lt;ActivityMainBinding&gt; (
  this, R.layout.activity_main)
  ...
}</pre>
<pre>// Fragment
override fun onCreateView (...): View? {
  return inflater.inflate (
  R.layout.fragment_message,...)
}</pre>
<p>虽然活动继承自<code>context</code>类，但片段没有。您需要使用片段中的<code>context</code>属性来访问<code>context</code>可以访问的应用数据，比如字符串或图像。</p>
<pre class="language-kotlin hljs">// Activity 
public class ActivityCompat extends ContextCompat</pre>
<pre class="language-kotlin hljs">//Fragment
open class Fragment: componentCallbacks</pre>
<pre class="language-kotlin hljs">context!!.getString(R.string.app_name)</pre>
<pre class="language-kotlin hljs">context!!.getDrawable(R.drawable.ic_launcher_background</pre>
<p>在Android中，你可以在不同的活动之间导航。它们被排列在一个堆栈中，最新的活动位于堆栈跟踪的顶部，称为<code>back stack</code>。</p>
<p>片段有一个类似的<code>back stack</code>，但是整个堆栈都包含在活动中。这是由一个名为<code>FragmentManager</code>的类控制的，我们接下来将回顾这个类。</p>
<h2 id="fragment-manager-fragment-lifecycle-state"><code>FragmentManager</code>和片段生命周期状态</h2>
<p>在Android应用程序开发中，<code><a href="https://developer.android.com/guide/fragments/fragmentmanager">FragmentManager</a></code>和片段生命周期负责应用程序经历的状态转换。</p>
<p>片段总是从在<code>INITIALIZED</code>状态下被实例化开始。为了让这个片段在其生命周期的不同状态之间转换，它必须被添加到<code>FragmentManager</code>中。<code>FragmentManager</code>决定了它的片段应该处于什么状态，也决定了片段的最大状态。</p>
<p>就像一个活动一样，片段也有自己的生命周期。每当用户与Android应用程序交互时，该片段在其生命周期中会经历不同的状态，包括:</p>
<ul>
<li><code>INITIALIZED</code></li>
<li><code>CREATED</code></li>
<li><code>STARTED</code></li>
<li><code>RESUMED</code></li>
<li><code>DESTROYED</code></li>
</ul>
<p>然而，了解片段的最好方法是实现它们。</p>
<h2 id="creating-adding-fragments-android-application">为Android应用程序创建和添加片段</h2>
<p>为了创建一个片段，我们将遵循下面的步骤:</p>
<ol>
<li>选择<strong>文件</strong>，点击<strong>新建</strong></li>
<li>点击下拉菜单中的<strong>片段</strong>和<strong>片段(空白)</strong></li>
<li>使用<code>TitleFragment</code>作为片段的名称</li>
<li>取消选中<strong>创建布局XML </strong></li>
<li>取消选中<strong>包含片段工厂方法</strong></li>
<li>取消选中<strong>包含接口回调</strong></li>
<li>选择<strong>结束</strong></li>
</ol>
<p>创建片段后，您必须将片段添加到您的应用程序中。要添加一个片段，首先点击<strong> <code>linear</code> </strong>布局，从<code>activity_main.xml</code>布局创建一个片段标签。给这个片段一个<code>fragment id</code>和一个<code>android:name</code>到片段类的完整路径。最后，将布局宽度和高度设置为<code>match_parent</code>，就可以开始了！</p>
<h2 id="conclusion">结论</h2>
<p>在本教程中，我们使用Kotlin编程语言讲述了Android应用程序中活动状态和片段生命周期的一些基本和高级概念。</p>
<p>片段支持模块化和代码重用，允许我们在许多活动中使用相同的列表视图。它们也有助于为Android平板设备构建多窗格界面。另一方面，活动状态生命周期提供了Android应用程序在其七个状态中的行为信息。最后，我们创建了一些片段生命周期的例子，比较了它们在活动状态之间的异同。</p>
<p>作为一名Android开发人员，在Android应用程序开发过程中，始终了解最新的技术发布并遵循最佳实践非常重要。我希望你喜欢这篇文章，如果你有任何问题，请留下评论。编码快乐！</p><div class="code-block code-block-32">
<div class="blog-plug inline-plug kotlin-plug"><h2>LogRocket :即时重现你的安卓应用中的问题。</h2><a class="signup" href="https://lp.logrocket.com/blg/kotlin-signup" target="_blank" rel="noopener noreferrer"><img class="alignnone size-full wp-image-46 jetpack-lazy-image" src="../Images/b5ae4bd0ecde7aa9d5288746416d5e18.png" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2022/11/react-native-plug_android-1.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/11/react-native-plug_android-1.png"/><noscript><img data-lazy-fallback="1" class="alignnone size-full wp-image-46" src="../Images/b5ae4bd0ecde7aa9d5288746416d5e18.png" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/11/react-native-plug_android-1.png"/></noscript></a><p><a href="https://lp.logrocket.com/blg/kotlin-signup" target="_blank" rel="noopener noreferrer"> LogRocket </a>是一款Android监控解决方案，可以帮助您即时重现问题，确定bug的优先级，并了解您的Android应用程序的性能。</p><p>LogRocket还可以向你展示用户是如何与你的应用程序互动的，从而帮助你提高转化率和产品使用率。LogRocket的产品分析功能揭示了用户不完成特定流程或不采用新功能的原因。</p><p>开始主动监控您的Android应用程序— <a class="signup" href="hhttps://lp.logrocket.com/blg/kotlin-signup" target="_blank" rel="noopener noreferrer">免费试用LogRocket】。</a></p></div>
</div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
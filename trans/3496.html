<html>
<head>
<title>Schema validation in TypeScript with Zod </title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>使用Zod在TypeScript中进行模式验证</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/schema-validation-typescript-zod/#0001-01-01">https://blog.logrocket.com/schema-validation-typescript-zod/#0001-01-01</a></blockquote><div><article class="article-post">
<p>TypeScript太牛了！近年来，它提高了开发人员的生产力和工具。TypeScript不仅有助于静态类型检查，还增加了一组面向对象编程(OOP)的概念，如泛型、模块、类、接口等等。</p>
<p>可以说，如果您曾经使用过TypeScript，那么回到只有JavaScript的代码库可能会很困难。虽然TypeScript在各方面看起来都很棒，但它有一个盲点——它只在编译时进行静态类型检查，根本没有任何运行时检查。</p>
<p>这就是佐德的切入点。在本文中，您将了解Zod中的模式设计和验证，以及如何在运行时在TypeScript代码库中运行它。</p>

<h2 id="what-zod-why-need-it">什么是佐德，我们为什么需要它？</h2>
<p>您可能会问自己，为什么有人首先需要运行时检查？</p>
<p>嗯，运行时检查有助于在服务器端获得正确验证的数据。在用户填写某种形式的表单的情况下，TypeScript不知道用户输入是否像您期望的那样在运行时在服务器上。</p>
<p>因此，Zod有助于数据完整性，并防止向数据库发送垃圾值。此外，最好在UI本身上记录一个错误，比如当您期望一个字符串时，用户输入了数字。</p>
<p>Zod 就是解决这个问题的工具。它填补了这个TypeScript盲点，有助于运行时的类型安全。Zod可以帮助您构建非常灵活的模式设计，并针对表单或用户输入运行它。</p>

<p>已经有一些工具，比如Yup、Joi、io-ts等等，做着和Zod一样的事情。虽然所有这些库对于模式设计和运行时验证来说都很棒，但是Zod在以下几个方面表现突出:</p>
<ul>
<li>灵活性:Zod非常灵活，可以将几个实例链接在一起，从而防止静态类型的重复</li>
<li>它没有依赖关系</li>
<li>尽管最好将Zod与TypeScript一起使用，但是如果您想要有限的、仅Zod类型的安全性，也可以在普通的JavaScript项目中使用它。它不依赖于类型脚本</li>
<li>它关注的是不变性，因此像<code>optional()</code>这样的方法返回一个新的实例，而不是完全改变同一个对象</li>
</ul>
<h2 id="benefits-using-zod-typescript">使用Zod和TypeScript的好处</h2>
<p>Zod与TypeScript配合得特别好。在典型的TypeScript代码库中，您要确保所有的静态类型安全都将由TypeScript在编译时处理。甚至大多数第三方包都将它们的代码与它们的<code>types</code>一起发布，比如React如何在一个名为<code>@types/react</code>的npm包下拥有它的类型。</p>
<p>使用Zod进行额外的运行时检查可以解决TypeScript的这些问题。您可能会遇到这样的问题，即使在使用了相应的<code>@types</code>包之后，您仍然需要将<code>undefined</code>或<code>unknown</code>分配给一个类型——唯一的原因是您事先不知道用户会输入什么或者响应结构是什么样的。</p>
<p>Zod以非常简洁的方式应用这些运行时检查。这实际上就像从TypeScript中提取数据类型并将它们扩展到特定于Zod的方法。Zod自动推断您已经在TypeScript中提到的类型，防止类型重复。</p>
<p>这些可链接的Zod的实用程序方法也启发了TypeScript实用程序，证明了这两者是如何一起发展的。</p>
<p>此外，在有些情况下，TypeScript的错误处理不是最理想的，Zod可以在运行时根据用户与UI的交互更好地显示错误。</p>
<h2 id="primitives-zod">Zod中的原语</h2>
<p>让我们从一个非常基本的Zod示例开始讨论模式验证:</p>
<pre class="language-javascript hljs">import { z } from "zod"
const dataInputFromUser = z.string().min(8).max(16)
dataInputFromUser.parse("A long text")
</pre>
<p>上面的代码将安全地解析。根据您的用例，您可以将用户导航到下一个输入或页面。</p>
<p>如果我们稍微调整一下线条，像这样:</p>
<pre class="language-javascript hljs">dataInputFromUser.parse("A really long text")
</pre>
<p>它会抛出一个异常:</p>
<pre class="language-javascript hljs">errors: [
    {
      code: 'too_big',
      maximum: 16,
      type: 'string',
      inclusive: true,
      message: 'String must contain at most 16 character(s)',
      path: []
    }
  ]
</pre>
<p>如果您需要更安全的异常处理，您可以使用<code>.safeParse()</code>方法简单地记录错误。</p>
<p>这是在Zod中使用原语的最简单的例子之一。原始值不仅仅局限于<code>string</code>，还提供了<code>number</code>、<code>bigint</code>、<code>boolean</code>、<code>date</code>等其他方法。还有一些空类型，如<code>undefined</code>、<code>null</code>和<code>void</code>。</p>
<p>利用这些原语和一些特定的方法可以实现非常灵活的模式设计:</p>
<pre class="language-javascript hljs">// email validation //
z.string().email().startsWith(string).trim().max(18).min(1)
// can be used for Terms &amp; Conditions check at runtime //
z.boolean()

// can be used for high-precision large values if they are being calculated at runtime //
z.bigint()
</pre>
<p>上面的例子将这些原语链接在一起，为电子邮件输入字段创建一个非常实用的运行时类型安全。</p>
<h2 id="objects-zod">Zod中的对象</h2>
<p>大多数面向用户的表单需要一些数据输入和不同数据类型的验证。这就是在Zod中使用对象更好的地方。您可以在运行时检查时为一组需要的属性创建一个模式。</p>
<pre class="language-javascript hljs">import { z } from 'zod'

const FormData = z.object({
  firstName: z.string().min(1).max(18),
  lastName: z.string().min(1).max(18),
  phone: z.string().min(10).max(14).optional(),
  email: z.string().email(),
  url: z.string().url().optional(),
});

const validateFormData = (inputs: unknown) =&gt; {
  const isValidData = FormData.parse(inputs);
  return isValidData;
};
</pre>
<p>在上面的TypeScript代码中，无法仅使用TypeScript在运行时实施模式验证，因此使用了<code>inputs: unknown</code>。</p>
<p>这就是可以使用<code>z.Object()</code>构建可扩展模式验证的地方。如果用户输入满足您的模式定义的字段，数据将被安全地解析。然后，您可以将数据发送到服务器。否则，将会抛出异常，就像我们在开始时看到的那样。</p>
<h2 id="composing-complex-schema-objects">构成复杂的模式对象</h2>
<p>可能会有这样的情况，除了一些额外的或缺少的类型之外，两个表单/字段的模式对象设计几乎是相同的。在这些情况下，您不需要一次又一次地复制相同的对象模式。相反，您可以通过使用Zod方法来防止重复，比如<code>merge()</code>和<code>extend()</code>。</p><div class="code-block code-block-54">
<hr/>
<h3>更多来自LogRocket的精彩文章:</h3>

<hr/></div>
<p>上面的代码可以通过删除<code>firstName</code>和<code>lastName</code>类型的重复来进一步改进，如下所示:</p>
<pre class="language-javascript hljs">const GenericStringContraint = z.string().min(1).max(18),

const FormData = z.object({
  firstName: GenericStringContraint, 
  lastName: GenericStringContraint, 
  // ...
});
</pre>
<p>这类似于以几种形式重复的数据类型块。比方说，<code>userId</code>和<code>fullName</code>在<code>Article</code>和<code>UserProfie</code>模式定义中重复出现，那么我们可以简单地将这两个“扩展”为:</p>
<pre class="language-javascript hljs">const UserData = z.object({
  userId: z.string().min(1).max(5),
  fullName : z.string().min(1).max(18),
});

const Article = UserData.extend({
  title: z.string().min(5),
 date: z.date()
});

const UserProfile = UserData.extend({
  isVerifield: z.boolean(),
  numberOfArticles: z.number().positive()
});
</pre>
<p>上述方法是一种更好的方法，可以使代码可维护，并避免数据重复。使用<code>extend()</code>时需要注意的一点是，它会改变模式对象，即覆盖它们。</p>
<p>与<code>extend()</code>方法非常相似，Zod也提供了一个<code>merge()</code>方法，两者略有不同。这在合并两个模式对象时很有用，不一定要“扩展”它们:</p>
<pre class="language-javascript hljs">import { z } from "zod"

const User = z.object({
  url: z.string().email().min(8),
  name: z.string(),
  age: z.number().min(2).max(3).optional()
})

const Skill = z.object({
  title: z.string().min(1),
})
const SkilledUser = User.merge(Skill)

const Data = SkilledUser.parse({
  url: "<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="46282728253f06212b272f2a6825292b">[email protected]</a>",
  name: "Nancy",
  age: 21,
  title: 'water surfing',
})

console.log(Data) // parses successfully
</pre>
<p>正如您在上面的代码中看到的，<code>title</code>数据字段已经合并到了<code>User</code>模式对象中，因此Zod会安全地解析它。在<code>title</code>字段是一个数字的情况下，比如说<code>20</code>，Zod会抛出一个错误，指出<code>title</code>只被限制为<code>z.string().min(1)</code>的类型。</p>
<p>Zod的<code>merge()</code>属性不像<code>extends()</code>那样重写字段。</p>
<h2 id="type-inferences-zod">Zod中的类型推理</h2>
<p>假设您已经在某个地方定义了自己的类型，并且希望一个新创建的变量从现有的变量中推导出它的类型。在这种情况下，Zod有一个方法可以推断出它的类型，如下所示:</p>
<pre class="language-javascript hljs">let fullName = z.string(); 
type fullName = z.infer&lt;typeof fullName&gt; // string

const userAge: fullName = 12; // Zod throws a Type Error Exception
const name: fullName = "Nancy"; // Parses safely
</pre>
<h2 id="conclusion">结论</h2>
<p>Zod提供了更多现成的API，但是我们已经介绍了几乎所有使用Zod和TypeScript构建模式验证的基本实体。我们还介绍了这些原语的功能有多强大，如果将它们链接在一起，可以为您的应用程序构建非常健壮和灵活的模式设计。</p>
<p>拥有运行时验证总是一个好主意，因为它使您的代码更具可读性，并在将用户输入重定向到服务器之前净化它们。</p>
<p>Zod强调DRY原则，并确保在一个地方定义的模式可以被标记化并用于其他类型，无论是通过推断那些类型还是扩展它们。这使得Zod从其他类似的库中脱颖而出。</p>
<p>将Zod与强大的编译类型检查系统TypeScript结合使用，可以使应用程序在当前的JAMstack应用程序中更加健壮。</p><div class="code-block code-block-21">
<div class="blog-plug inline-plug typescript-plug"><h2><a class="signup" href="https://lp.logrocket.com/blg/typescript-signup" target="_blank" rel="noopener noreferrer"> LogRocket </a>:全面了解您的网络和移动应用</h2>
<a href="https://lp.logrocket.com/blg/typescript-signup" class="signup" target="_blank" rel="noopener noreferrer"><img class="alignnone size-full wp-image-46 jetpack-lazy-image" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/><noscript><img data-lazy-fallback="1" class="alignnone size-full wp-image-46" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/></noscript></a>
<p>LogRocket 是一个前端应用程序监控解决方案，可以让您回放问题，就像问题发生在您自己的浏览器中一样。LogRocket不需要猜测错误发生的原因，也不需要向用户询问截图和日志转储，而是让您重放会话以快速了解哪里出错了。它可以与任何应用程序完美配合，不管是什么框架，并且有插件可以记录来自Redux、Vuex和@ngrx/store的额外上下文。</p>
<p>除了记录Redux操作和状态，LogRocket还记录控制台日志、JavaScript错误、堆栈跟踪、带有头+正文的网络请求/响应、浏览器元数据和自定义日志。它还使用DOM来记录页面上的HTML和CSS，甚至为最复杂的单页面和移动应用程序重新创建像素级完美视频。</p>
<a class="signup" href="https://lp.logrocket.com/blg/typescript-signup" target="_blank" rel="noopener noreferrer">Try it for free</a><p>.</p></div>
</div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
<html>
<head>
<title>Using stdout, stdin, and stderr in Node.js - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>在 Node.js - LogRocket 博客中使用 stdout、stdin 和 stderr</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/using-stdout-stdin-stderr-node-js/#0001-01-01">https://blog.logrocket.com/using-stdout-stdin-stderr-node-js/#0001-01-01</a></blockquote><div><article class="article-post">
<p><code>stdout</code>、<code>stdin</code>和<code>stderr</code>是标准流，它们在程序执行时将程序与其环境之间的输入和输出通信信道互连。</p>
<p>流通常指数据的流动。您可以将流视为工厂中连接到不同机器(在我们的例子中是程序)的传送带。不同的机器可以以某种方式用一根带子(管子)来排列、指挥和连接，以产生特定的结果。</p>
<p>正如我们可以连接物理 I/O 设备(通过鼠标输入，通过监视器输出)，标准流对此进行了抽象，为我们的代码提供了可组合性。</p>
<p><img data-attachment-id="113935" data-permalink="https://blog.logrocket.com/using-stdout-stdin-stderr-node-js/testimage-drawio/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/05/testimage.drawio.png" data-orig-size="730,361" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Testimage" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/05/testimage.drawio-300x148.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/05/testimage.drawio.png" decoding="async" class="aligncenter size-full wp-image-113935 jetpack-lazy-image" src="../Images/b953489a86a2ac87dab93489e29e5929.png" alt="Testimage" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2022/05/testimage.drawio.png 730w, https://blog.logrocket.com/wp-content/uploads/2022/05/testimage.drawio-300x148.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2022/05/testimage.drawio.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/05/testimage.drawio.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="113935" data-permalink="https://blog.logrocket.com/using-stdout-stdin-stderr-node-js/testimage-drawio/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/05/testimage.drawio.png" data-orig-size="730,361" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Testimage" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/05/testimage.drawio-300x148.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/05/testimage.drawio.png" decoding="async" loading="lazy" class="aligncenter size-full wp-image-113935" src="../Images/b953489a86a2ac87dab93489e29e5929.png" alt="Testimage" srcset="https://blog.logrocket.com/wp-content/uploads/2022/05/testimage.drawio.png 730w, https://blog.logrocket.com/wp-content/uploads/2022/05/testimage.drawio-300x148.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/05/testimage.drawio.png"/></noscript>
<p>就像我们可以用小命令组成强大的 Linux 命令一样，我们可以利用 Node.js 标准流在 Node.js 中实现同样的功能。</p>
<h2 id="node-js-stdin-stdout-stdin">Node.js <code>stdin</code>、<code>stdout</code>和<code>stdin</code></h2>
<p>当我们运行 Node.js 程序时，会为该程序的执行启动一个进程。</p>
<p>GNU 文档将进程定义为“分配系统资源的基本单位”。每个进程都有自己的地址空间和(通常)一个控制线程。进程执行程序；您可以让多个进程执行同一个程序，但每个进程在自己的地址空间中都有自己的程序副本，并独立于其他副本执行它</p>
<p>每个进程都用三个打开的文件描述符初始化，分别叫做<code>stdin</code>、<code>stdout</code>和<code>stderr</code>。</p>
<p>这三个文件描述符统称为标准流。</p>
<p>为一个流程启动一组三个标准流，我们可以通过 Node.js 中的<code>process</code>对象访问它们。</p>
<p>标准流被视为存在文件。访问任何文件的一种简单方法是使用与之相关联的唯一文件描述符。在这些标准流的情况下，每个标准流都分配有唯一的值。</p>
<ul>
<li><a href="https://nodejs.org/api/process.html#processstdin" target="_blank" rel="noopener"> <code>process.stdin</code> </a> (0):标准输入流，是程序的输入源</li>
<li><a href="https://nodejs.org/api/process.html#processstdout" target="_blank" rel="noopener"> <code>process.stdout</code> </a> (1):标准输出流，它是程序输出的一个来源</li>
<li><a href="https://nodejs.org/api/process.html#processstderr" target="_blank" rel="noopener"> <code>process.stderr</code> </a> (2):标准错误流，用于程序发出的错误消息和诊断</li>
</ul>
<h3 id="simple-use-stdin-stdout"><code>stdin</code>和<code>stdout</code>的简单使用</h3>
<p>让我们编写一个简单的应用程序，它通过终端接收数据，并将处理后的输出打印到终端中。</p>
<p>我们将创建一个 JavaScript 文件(<code>index.js</code>)并编写如下代码:</p>
<pre class="language-javascript hljs"> // index.js
process.stdin.on("data", data =&gt; {
    data = data.toString().toUpperCase()
    process.stdout.write(data + "\n")
})
</pre>
<p>运行上面的程序会创建一个事件监听器来监听数据输入，处理输入，并将输出打印到终端。</p>
<p><img data-attachment-id="113938" data-permalink="https://blog.logrocket.com/using-stdout-stdin-stderr-node-js/simple-result/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/05/simple-result.gif" data-orig-size="446,326" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Simple result" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/05/simple-result-300x219.gif" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/05/simple-result.gif" decoding="async" class="aligncenter size-full wp-image-113938 jetpack-lazy-image" src="../Images/3f2aced2b5e88dcbc337eaf48833d3cb.png" alt="Simple Result" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2022/05/simple-result.gif?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/05/simple-result.gif"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="113938" data-permalink="https://blog.logrocket.com/using-stdout-stdin-stderr-node-js/simple-result/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/05/simple-result.gif" data-orig-size="446,326" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Simple result" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/05/simple-result-300x219.gif" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/05/simple-result.gif" decoding="async" loading="lazy" class="aligncenter size-full wp-image-113938" src="../Images/3f2aced2b5e88dcbc337eaf48833d3cb.png" alt="Simple Result" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/05/simple-result.gif"/></noscript>
<p>我们可以通过按<code>ctrl + c</code>来停止终端中正在运行的进程。</p>
<h3 id="making-use-readline-create-interactive-terminal-scripts">利用<code>readline</code>创建交互式终端脚本</h3>
<p><code>readline</code>是一个 Node.js 模块，它提供了一个接口，用于从一个<a href="https://nodejs.org/api/stream.html#readable-streams" target="_blank" rel="noopener">可读的</a>流(比如<code>process.stdin</code>)中一次读取一行数据。</p>
<p>首先，我们将创建一个名为<code>index.js</code>的新 JavaScript 文件，将<code>readline</code>模块导入到我们的程序中，然后创建一个函数<code>ask</code>，它接收一个字符串作为参数，并在我们的终端中创建一个包含该字符串的提示:</p>
<pre class="language-javascript hljs">// index.js
const readline = require("readline")

function ask(question) {
    // asks a question and expect an answer
}
</pre>
<p>然后我们将使用<code>readline</code>创建一个接口，将<code>stdin</code>连接到<code>stdout</code>:</p>
<pre class="language-javascript hljs">// index.js
const readline = require("readline")

const rl = readline.createInterface({
    input: process.stdin, 
    output: process.stdout,
})

function ask(question) {
    // asks a question and expectings an answer
}
</pre>
<p>我们将完成<code>ask</code>函数来期待答案，并递归地重复整个过程:</p>
<pre class="language-javascript hljs"> // index.js
const readline = require("readline")

const rl = readline.createInterface({
    input: process.stdin, 
    output: process.stdout,
})

function ask(question) {
    rl.question(question, (answer) =&gt; {
        rl.write(`The answer received:  ${answer}\n`)

        ask(question)
    })
}

ask("What is your name: ")
</pre>
<p>运行上面的程序将创建一个终端接口，它一直循环，直到我们在终端中按下<code>ctrl + c</code>结束 Node.js 进程。</p>
<p><code>ctrl + c</code>向我们正在运行的名为<code>SIGKILL</code>的 Node.js 程序发送一个信号，告诉 Node.js 停止我们的程序执行。我们还可以通过调用<code>process.exit(exitCode)</code>，以编程方式通知 Node.js 停止执行我们的应用程序。</p>
<p>因此，我们将更新我们的<code>ask</code>函数，检查输入“q”的答案是否正确。如果输入是“q”，那么它应该退出应用程序:</p>
<pre class="language-javascript hljs">// index.js
const readline = require("readline")

const rl = readline.createInterface({
    input: process.stdin, 
    output: process.stdout,
})

function ask(question) {
    rl.question(question, (answer) =&gt; {
        if(answer === "q") {
            process.exit(1)
        }
        rl.write(`The answer received:  ${answer}\n`)

        ask(question)
    })
}

ask("What is your name: ") 
</pre>
<h3 id="what-stderr">什么是<code>stderr</code>？</h3>
<p>当我们编写应用程序或程序时，可能会由于许多原因而出现错误。<code>stderr</code>是默认的文件描述符<em> <em/> </em>，进程可以在其中写入错误消息。</p>
<p>请考虑下面的代码:</p>
<pre class="language-javascript hljs">// index.js
process.stderr.write("error! some error occurred\n")
</pre>
<p>用<code>node index.js</code>运行这个应用程序会将错误消息写到我们的终端，类似于<code>stdout</code>输出它的方式。</p>
<p>理解为什么<code>stdin</code>和<code>stdout</code>存在是非常简单的。然而，<code>stderr</code>似乎相当古怪。</p><div class="code-block code-block-54">
<hr/>
<h3>更多来自 LogRocket 的精彩文章:</h3>

<hr/></div>
<p>在基于 UNIX/Linux 的生态系统中，曾经有一段时间<code>stderr</code>不存在。UNIX 命令的所有输出都可以通过<code>stdout</code>传输，包括命令的预期结果和错误或诊断消息。</p>
<p>这不是最佳做法，因为错误也可能通过管道传递，而管道末端附加的命令可能不理解这一点。</p>
<p>因此，<code>stderr</code>被创建来通过一个不同的文件描述符，即<code>2</code>，引导错误或诊断消息。</p>
<p><em>注意，在 Linux 中，当您通过管道将命令连接在一起时，只会将预期的结果连接在一起。错误或诊断错误信息通过</em> <code>stderr</code> <em>文件描述符传送，并默认打印到终端。</em></p>
<p>让我们通过编写两个名为<code>logger.js</code>和<code>printer.js</code>的 Node.js 程序来处理这个问题。</p>
<p><code>logger.js</code>模拟了一个日志程序，但是在我们的例子中，日志已经被预定义了。</p>
<p>然后，<code>printer.js</code>将从<code>stdin</code>中读取数据，并将它们写入文件。</p>
<p>首先，我们将创建下面的<code>logger.js</code>:</p>
<pre class="language-javascript hljs">const logObject = [
    {
        type: "normal",
        message: "SUCCESS: 2 + 2 is 4"
    },
    {
        type: "normal",
        message: "SUCCESS 5 + 5 is 10"
    },
    {
        type: "error",
        message: "ERROR! 3 + 3 is not 4"
    },
    {
        type: "normal",
        message: "SUCESS 10 - 4 is 6"
    }
]

function logger() {
    logObject.forEach(log =&gt; {
        setTimeout(() =&gt; {
            if (log.type === "normal") process.stdout.write(log.message)
            else process.stderr.write(log.message + '\n')
        }, 500)
    })
}

logger()
</pre>
<p>接下来，我们将创建另一个 Node.js 文件，该文件创建或打开一个文本文件<code>logs.txt</code>，读取由<code>stdout</code>提供的输入，并将它们写入一个文件:</p>
<pre class="language-javascript hljs">const fs = require("fs")

fs.open("./logs.txt", "w", (err, fd) =&gt; {
    if (err) throw Error(err.message)
    process.stdin.on("data", data =&gt; {
        fs.write(fd, data.toString() + "\n", (err) =&gt; {
            if (err) throw Error(err.message)
        })
    })
})
</pre>
<p>要运行这个应用程序，我们可以通过运行以下命令在终端中传输这两个程序:</p>
<pre class="language-bash hljs">$ node logger.js | node printer.js
</pre>
<blockquote><p><strong>注意</strong>，如果你在 Windows 中用 Git Bash 运行上述命令，你可能会遇到错误<code>stdout is not a tty</code>。这可能是 Git Bash 的一个问题。您可以使用 Window Powershell 运行该命令，或者通过在文件顶部包含一个 shebang ( <code>#!/bin/env node</code>)并以<code>./logger.js | ./printer.js</code>的身份运行上面的命令来使该脚本可执行。</p></blockquote>
<p>执行后，我们可以确认只有通过<code>stdout</code>的成功日志到达了<code>logs.txt</code>:</p>
<pre class="language-txt hljs">// logs.txt
SUCCESS: 2 + 2 is 4
SUCCESS 5 + 5 is 10
SUCcESS 10 - 4 is 6
</pre>
<p>并且错误日志被打印到终端。这是<code>stderr</code>的默认行为，但是我们也可以通过重定向和管道来改变它。</p>
<h2 id="wrapping-up">包扎</h2>
<p>现在我们了解了什么是标准流，以及如何在 Node.js 应用程序中使用它们。我们也知道标准流如何帮助我们构建简单的程序，这些程序可以被引导来制定更复杂的程序。</p>
<p>例如，<code>printer.js</code>不一定需要知道<code>logger.js</code>做什么。所有的<code>printer.js</code>所做的就是从<code>stdout</code>接收数据并将数据写入文件。</p>
<p>如果它们共享相同的执行环境，可以重用并与其他程序组合，甚至与 Linux 命令组合。</p><div class="code-block code-block-23">
<div class="blog-plug inline-plug node-plug"><h2>200 只<img src="../Images/61167b9d027ca73ed5aaf59a9ec31267.png" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2019/10/green-check.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" class=" jetpack-lazy-image" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/10/green-check.png"/> <noscript> <img data-lazy-fallback="1" src="../Images/61167b9d027ca73ed5aaf59a9ec31267.png" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/10/green-check.png"/> </noscript>显示器出现故障，生产中网络请求缓慢</h2><p>部署基于节点的 web 应用程序或网站是容易的部分。确保您的节点实例继续为您的应用程序提供资源是事情变得更加困难的地方。如果您对确保对后端或第三方服务的请求成功感兴趣，</p><a href="https://lp.logrocket.com/blg/node-signup" target="_blank">try LogRocket</a><p>. </p><a class="signup" href="https://lp.logrocket.com/blg/node-signup" target="_blank" rel="noopener noreferrer"><img src="../Images/cae72fd2a54c5f02a6398c4867894844.png" alt="LogRocket Network Request Monitoring" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2019/12/network-request-filter-2-1.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" class=" jetpack-lazy-image" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/12/network-request-filter-2-1.png"/><noscript><img data-lazy-fallback="1" src="../Images/cae72fd2a54c5f02a6398c4867894844.png" alt="LogRocket Network Request Monitoring" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/12/network-request-filter-2-1.png"/></noscript></a><a href="https://lp.logrocket.com/blg/node-signup" target="_blank" rel="noopener noreferrer">https://logrocket.com/signup/</a><p>LogRocket 就像是网络和移动应用程序的 DVR，记录下用户与你的应用程序交互时发生的一切。您可以汇总并报告有问题的网络请求，以快速了解根本原因，而不是猜测问题发生的原因。</p><p>LogRocket 检测您的应用程序以记录基线性能计时，如页面加载时间、到达第一个字节的时间、慢速网络请求，还记录 Redux、NgRx 和 Vuex 操作/状态。</p><a class="signup" href="https://lp.logrocket.com/blg/node-signup" target="_blank" rel="noopener noreferrer">Start monitoring for free</a><p>. </p></div>
</div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
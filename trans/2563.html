<html>
<head>
<title>Build a profile frame generator with React Konva - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>用 React Konva - LogRocket 博客构建一个框架生成器</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/build-profile-frame-generator-react-konva/#0001-01-01">https://blog.logrocket.com/build-profile-frame-generator-react-konva/#0001-01-01</a></blockquote><div><article class="article-post">
<p>如果你花时间在社交媒体上，你可能见过你的一个朋友更改他们在脸书的个人资料照片，加入支持他们最喜欢的运动队的框。或者，你可能已经看到了一个同事的 LinkedIn 个人资料，其中有一个关于工作开放性的框架。在本文中，我们将使用<a href="https://github.com/dscnitrourkela/project-icecream/tree/cra-version"> React Konva </a>在 React 中构建我们自己的 profile picture frame 生成器。</p>
<p>作为一个例子，我们将使用一个<a href="https://github.com/dscnitrourkela/project-icecream">帧生成器，它是我为我大学的黑客马拉松帮助构建和维护的</a>。本教程结束时，您将能够构建一个供在线活动参与者使用的个人资料框架生成器。我们的最终输出将如下图所示:</p>
<p><img data-attachment-id="86045" data-permalink="https://blog.logrocket.com/build-profile-frame-generator-react-konva/react-frame-genrator-final/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/01/react-frame-genrator-final.png" data-orig-size="730,530" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="react-frame-genrator-final" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/01/react-frame-genrator-final-300x218.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/01/react-frame-genrator-final.png" decoding="async" class="aligncenter wp-image-86045 size-full jetpack-lazy-image" src="../Images/429f7159a027b03ce686503b1b74a7ce.png" alt="React Frame Genrator Final" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2022/01/react-frame-genrator-final.png 730w, https://blog.logrocket.com/wp-content/uploads/2022/01/react-frame-genrator-final-300x218.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2022/01/react-frame-genrator-final.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/01/react-frame-genrator-final.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="86045" data-permalink="https://blog.logrocket.com/build-profile-frame-generator-react-konva/react-frame-genrator-final/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/01/react-frame-genrator-final.png" data-orig-size="730,530" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="react-frame-genrator-final" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/01/react-frame-genrator-final-300x218.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/01/react-frame-genrator-final.png" decoding="async" loading="lazy" class="aligncenter wp-image-86045 size-full" src="../Images/429f7159a027b03ce686503b1b74a7ce.png" alt="React Frame Genrator Final" srcset="https://blog.logrocket.com/wp-content/uploads/2022/01/react-frame-genrator-final.png 730w, https://blog.logrocket.com/wp-content/uploads/2022/01/react-frame-genrator-final-300x218.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/01/react-frame-genrator-final.png"/></noscript>
<p>你也可以<a href="https://gracious-volhard-22bfe6.netlify.app">看看现场的例子</a>。我们开始吧！</p>
<h2>React Konva 是什么？</h2>
<p>HTML5 Canvas API 是一个强大的工具，用于在 web 应用中整合动态、高性能的视觉效果。Canvas 支持多种浏览器，并包括用于添加形状、图片和文本的内置 API。像<a href="https://konvajs.org/"> Konva.js </a>和<a href="https://p5js.org"> p5.js </a>这样的各种实用程序库已经在 Canvas 上创建，以协助事件处理和动画。</p>
<p>Canvas API 本质上是必不可少的，它是通过类似于<code>ctx.rect(x, y, width, height)</code>的方法与普通 JavaScript 交互而构建的。这种语法对于 React 开发人员来说是完全陌生的，并且与现代 React 模式不兼容。<a href="https://blog.logrocket.com/canvas-manipulation-react-konva/"> React Konva，Konva.js </a>的 React 包装器，允许你使用 React 组件接口连接 Konva API。</p>
<h3>先决条件</h3>
<p>要阅读本文，您应该<a href="https://blog.logrocket.com/getting-started-with-create-react-app-d93147444a27/">熟悉 React 并创建 React 应用程序</a>。你还应该了解<a href="https://blog.logrocket.com/why-use-redux-reasons-with-clear-examples-d21bffd5835/">状态管理工具，如 Redux </a>或<a href="https://blog.logrocket.com/react-context-api-deep-dive-examples/"> React 上下文 API </a>。此外，预先了解 React Konva 是有益的。</p>
<p>在本教程中，我们将使用以下技术:React、Create React App、styled-components、React Context API、React Konva 和 Netlify。我们开始吧！</p>
<h2>入门指南</h2>
<p>首先，我们将安装 Yarn 以使我们的开发过程更加顺畅。要运行这个命令，您需要安装 Node.js。您可以使用命令<code>node --version</code>检查 Node.js 是否已安装。安装 Node.js 将自动启用<code>npm</code>和<code>npx</code>命令:</p>
<pre class="language-bash hljs"># Globally install yarn
npm install -g yarn
</pre>
<p>接下来，我们将使用 Create React App 创建一个基本的 React 应用程序。</p>
<pre class="language-bash hljs"># Using npm
npx create-react-app profile-frames

# Using yarn
yarn create react-app profile-frames
</pre>
<p>让我们建立一个干净的目录结构；删除 Create React App 附带的所有文件，并创建所需的文件夹和文件，如下所示:</p>
<p><img data-attachment-id="86054" data-permalink="https://blog.logrocket.com/build-profile-frame-generator-react-konva/clean-directory-structure-2/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/01/clean-directory-structure-1.png" data-orig-size="422,690" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="clean-directory-structure" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/01/clean-directory-structure-1-183x300.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/01/clean-directory-structure-1.png" decoding="async" class="aligncenter wp-image-86054 size-full jetpack-lazy-image" src="../Images/9edb059c69eeb62f1720b85218eabc33.png" alt="Clean Directory Structure" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2022/01/clean-directory-structure-1.png 422w, https://blog.logrocket.com/wp-content/uploads/2022/01/clean-directory-structure-1-183x300.png 183w" data-lazy-sizes="(max-width: 422px) 100vw, 422px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2022/01/clean-directory-structure-1.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/01/clean-directory-structure-1.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="86054" data-permalink="https://blog.logrocket.com/build-profile-frame-generator-react-konva/clean-directory-structure-2/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/01/clean-directory-structure-1.png" data-orig-size="422,690" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="clean-directory-structure" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/01/clean-directory-structure-1-183x300.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/01/clean-directory-structure-1.png" decoding="async" loading="lazy" class="aligncenter wp-image-86054 size-full" src="../Images/9edb059c69eeb62f1720b85218eabc33.png" alt="Clean Directory Structure" srcset="https://blog.logrocket.com/wp-content/uploads/2022/01/clean-directory-structure-1.png 422w, https://blog.logrocket.com/wp-content/uploads/2022/01/clean-directory-structure-1-183x300.png 183w" sizes="(max-width: 422px) 100vw, 422px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/01/clean-directory-structure-1.png"/></noscript>
<ul>
<li><code>public</code>:用户可以直接访问该目录下的文件</li>
<li><code>src</code>:包含我们将要上传和构建的文件<ul>
<li><code>assets</code>:包含所有图像和帧</li>
<li><code>components</code>:包含组件</li>
<li>包含我们应用程序的不同屏幕</li>
<li><code>store</code>:包含处理应用程序全局状态管理的文件</li>
</ul>
</li>
</ul>
<p>要运行 React 应用程序，在<code>src</code>目录下创建<code>index.js</code>和<code>App.jsx</code>文件，然后添加以下代码:</p>
<pre class="language-javascript hljs">// App.jsx
import React from "react";

const App = () =&gt; {
  return (
    &lt;div&gt;
      &lt;h1&gt;Hello World&lt;/h1&gt;
    &lt;/div&gt;
  );
};

export default App;

// index.js
import React from "react";
import ReactDOM from "react-dom";

import App from "./App";

ReactDOM.render(
  &lt;React.StrictMode&gt;
    &lt;App /&gt;
  &lt;/React.StrictMode&gt;,
  document.querySelector("#root")
);
</pre>
<p>最后，我们将<a href="https://blog.logrocket.com/benefits-using-styled-components-react/">安装样式组件</a>并分别为 CSS 样式和画布操作反应 Konva:</p>
<pre>yarn add styled-components react-konva konva</pre>
<blockquote><p>在本文中，我们不会详细讨论 CSS 样式。您可以在上面的存储库中找到具体实现的细节。</p></blockquote>
<h2 id="listofourappsfeatures">列出我们应用的功能</h2>
<p>在我们开始编码之前，最好列出一份我们想要包含的特性的详细清单。我们的应用将包括以下功能，我们将基于此列表构建我们的组件:</p>
<ul>
<li>用户可以与不同的 Konva 元素交互的组件</li>
<li>由各种可供用户选择的框架选项组成的旋转木马</li>
<li>控制面板由以下部分组成:<ul>
<li>一个<code>upload image</code>按钮</li>
<li><code>Name</code>和<code>Guild</code>输入</li>
<li>一个<code>Download</code>按钮</li>
</ul>
</li>
</ul>
<p>下面的组件架构将适合我们的项目:</p>
<p><img data-attachment-id="87130" data-permalink="https://blog.logrocket.com/build-profile-frame-generator-react-konva/react-konva-project-architecture/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/01/react-konva-project-architecture.png" data-orig-size="730,415" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="react-konva-project-architecture" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/01/react-konva-project-architecture-300x171.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/01/react-konva-project-architecture.png" decoding="async" class="aligncenter wp-image-87130 size-full jetpack-lazy-image" src="../Images/ce8d0e63dfaa237651552260c02553fa.png" alt="React Konva Project Architecture" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2022/01/react-konva-project-architecture.png 730w, https://blog.logrocket.com/wp-content/uploads/2022/01/react-konva-project-architecture-300x171.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2022/01/react-konva-project-architecture.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/01/react-konva-project-architecture.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="87130" data-permalink="https://blog.logrocket.com/build-profile-frame-generator-react-konva/react-konva-project-architecture/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/01/react-konva-project-architecture.png" data-orig-size="730,415" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="react-konva-project-architecture" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/01/react-konva-project-architecture-300x171.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/01/react-konva-project-architecture.png" decoding="async" loading="lazy" class="aligncenter wp-image-87130 size-full" src="../Images/ce8d0e63dfaa237651552260c02553fa.png" alt="React Konva Project Architecture" srcset="https://blog.logrocket.com/wp-content/uploads/2022/01/react-konva-project-architecture.png 730w, https://blog.logrocket.com/wp-content/uploads/2022/01/react-konva-project-architecture-300x171.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/01/react-konva-project-architecture.png"/></noscript>
<h2 id="creatingthecanvascomponent">创建<code>Canvas</code>组件</h2>
<p>React Konva 有一个名为<code>Stage</code>的组件，可以用来渲染各种形状和项目。<code>Stage</code>的直接子组件需要是一个<code>Layer</code>组件，它可以容纳不同的组件，如图像、文本、形状等。在我们的演示中，一层就能完成任务。</p>
<p>在<code>components</code>目录中创建一个名为<code>Canvas.jsx</code>的新文件，并添加以下代码:</p>
<pre class="language-javascript hljs">import React, { useRef } from "react";

// Libraries
import { Layer, Stage, Image, Text } from "react-konva";

// Assets
import frame1 from "../assets/frame1";
import profile from "../assets/frame1";

const Canvas = () =&gt; {
  /**
   * A list of variables containing the various details that we
   * would require for all the different elements.
   * 
   * It is better to separate them now as we will be shifting 
   * them to their global states later
   */
  const stageRef = useRef();
  const stageDetails = {
    width: 350,
    height: 350,
    x: 0,
    y: 0,
  };

  const imageDetails = {
    originalDimensions: {
      width: 0,
      height: 0,
    },
    renderDimensions: {
      width: 300,
      height: 300,
    },
    position: {
      x: 0,
      y: 0,
    },
  };

  const textDetails = {
    name: {
      value: "name field",
      id: "user-name",
      dimensions: {
        width: 100,
        height: 50,
      },
      position: {
        x: 50,
        y: 50,
      },
    },
    guild: {
      value: "guild field",
      id: "user-guild",
      dimensions: {
        x: 100,
        y: 50,
      },
      position: {
        x: 100,
        y: 100,
      },
    },
  };

  return (
    &lt;Stage
      ref={stageRef}
      width={stageDetails.width}
      height={stageDetails.height}
      style={{ position: "relative" }}
    &gt;
      &lt;Layer&gt;
        &lt;Image
          image={profile}
          width={imageDetails.renderDimensions.width}
          height={imageDetails.renderDimensions.height}
          x={imageDetails.position.x}
          y={imageDetails.position.y}
        /&gt;

        &lt;Text
          text={textDetails.name.value}
          width={textDetails.name.dimensions.width}
          height={textDetails.name.dimensions.height}
          x={textDetails.name.position.x}
          y={textDetails.name.position.y}
        /&gt;
        &lt;Text
          text={textDetails.guild.value}
          width={textDetails.guild.dimensions.width}
          height={textDetails.guild.dimensions.height}
          x={textDetails.guild.position.x}
          y={textDetails.guild.position.y}
        /&gt;

        &lt;Image
          image={frame1}
          width={stageDetails.width}
          height={stageDetails.height}
          x={0}
          y={0}
          style={{ position: "absolute", top: 0, left: 0, zIndex: 100 }}
        /&gt;
      &lt;/Layer&gt;
    &lt;/Stage&gt;
  );
};

export default Canvas;
</pre>
<p>这段代码中有很多内容。让我们回顾一下传递给所有元素的不同道具。</p>
<p>每个<code>canvas</code>元素采用以下道具:</p>
<ul>
<li><code>width</code>和<code>height</code>，指定特定部件的尺寸</li>
<li><code>x</code>和<code>y</code>，指定组件的位置</li>
</ul>
<p><code>x</code>和<code>y</code>相对于<code>Stage</code>组件，从<code>Stage</code>组件的左上角开始。<code>Stage</code>组件需要一个引用，这个引用是使用<code>useRef</code>钩子创建的。</p>
<p>有两个图像组件，一个用于个人资料图片，一个用于框架。这些图像应该是高分辨率的，所以我们需要计算每张图像的渲染尺寸，以适应<code>Stage</code>组件。此外，有两个文本组件都有一个呈现内容的<code>text</code>属性，即我们提供的文本。</p>
<p>此时，您的下一步将是准备好<code>Stage</code>组件，但是您会注意到一些问题。首先，出现的文本没有背景。我们需要修复它，使它看起来不同于图像。此外，我们的元素都是不可变换的，这意味着我们不能改变大小或旋转元素。最后，我们的应用程序是静态的，但我们希望它是动态的和交互式的。</p>
<h2>创建定制的<code>text</code>组件</h2>
<p>内置的<code>text</code>组件不包含任何背景。我们将通过使用放置在一个<code>Rect</code>矩形组件之上的<code>text</code>组件来创建我们自己的定制组件。React Konva 提供了一个<code>group</code>组件，它只为一个组件而不是多个组件提供一组属性，比如尺寸和位置。</p>
<p>创建一个名为<code>CustomText.jsx</code>的新文件，并添加以下代码:</p>
<pre class="language-javascript hljs">import React from "react";

// Libraries
import { Rect, Text, Group } from "react-konva";

const CustomText = ({ dimensions, position, name }) =&gt; {
  const shapeRef = React.useRef(null);

  /**
   * As with other konva components, group also takes in
   * width, height and positions x and y.
   *
   * In addition to this, the properities of offsetX and offsetY
   * prop which shifts its coordinate system origin to the center instead
   * of the top-left corner are also added.
   *
   * This would help in positioning both the rectangle and the
   * text element at the center of the group.
   */
  const groupProps = {
    width: dimensions.width,
    height: dimensions.height,
    offsetX: dimensions.width / 2,
    offsetY: dimensions.height / 2,
    x: position.x,
    y: position.y,
  };

  return (
    &lt;Group ref={shapeRef} {...groupProps}&gt;
      {/* The width of both the elements are kept same */}
      {/* Not passing any positions defaults them to x=0 and y=0 */}
      &lt;Rect
        width={dimensions.width}
        height={dimensions.height}
        cornerRadius={[7, 7, 7, 7]}
                                fill="lightblue"
      /&gt;
      &lt;Text
        width={dimensions.width}
        height={dimensions.height}
        align='center'
        verticalAlign='middle'
        text={name}
        fontSize={20}
      /&gt;
    &lt;/Group&gt;
  );
};

export default CustomText;
</pre>
<p>现在，我们有了一个定制的<code>text</code>组件，它更清晰，更容易与背景图像区分开来。</p>
<h2 id="scaleyourcomponentswithtransformer">使用<code>Transformer</code>缩放您的组件</h2>
<p>至此，我们已经准备好了大部分组件。然而，我们缺少一个关键特性，它将为我们的应用程序带来全新的定制水平。</p>
<p>先说图像。在我们可以创建自定义的<code>image</code>组件之前，我们需要重构<code>Canvas</code>组件以包含状态，从而允许我们转移到一个具有交互的更动态的应用程序:</p>
<pre class="language-javascript hljs">import profile from "../assets/frame1";

const Canvas = () =&gt; {
        /* Existing Code */

        /**
   * Okay so the imageDetails variables are removed and 
   * shifted to a state. Not only this but also 2 new properties of 
   * scale defaulted to 1 which would determine
   * the size of our shape/element and id are added
   * 
   * In addition to that, a new state called selectedElement is also
   * selectedElement. This element stores an id or unique field which
   * showcases which element is currently selected.
   */
  const [selectedElement, setSelectedElement] = useState(null);
  const [imageDetails, setImageDetails] = useState({
    originalDimensions: {
      width: 0,
      height: 0,
    },
    renderDimensions: {
      width: 300,
      height: 300,
    },
    position: {
      x: 0,
      y: 0,
    },
    scale: 1,
    id: 'user-profile-image',
    image: profile
  });

        /* Existing code */
}

export default Canvas;
</pre>
<p>随着<code>Stage</code>被设置为包含状态，让我们构建我们的可转换图像组件。为了减少单个组件中的代码并避免任何重复，创建一个名为<code>CustomImage.jsx</code>的新文件。</p>
<p>React Konva 提供了一个<code>Transformer</code>组件，可以在形状周围创建一个框，因此用户可以轻松地调整它的大小或旋转它。将以下代码添加到<code>CustomImage.jsx</code>文件中:</p>
<pre class="language-javascript hljs">import React from "react";

// Components
import { Image, Transformer } from "react-konva";

const CustomImage = ({
  imageDetails,
  setImageDetails,
  isSelected,
  onSelect,
}) =&gt; {
  /**
   * Create references to the shape which needs to be transformed
   * and to the transformer component itself.
   */
  const shapeRef = React.useRef();
  const transformerRef = React.useRef();

  /**
   * This effect runs whenever the isSelected variable is toggled
   * The isSelected variable is set from the parent element which indicates
   * that the current element is selected and is to be transformed.
   */
  React.useEffect(() =&gt; {
    if (isSelected) {
      /**
       * Here you are instructing the transformer component via its ref to
       * enable the specified component i.e. the image is to be transformed
       * and then create the transformer box around it.
                         * This code will run everytime the isSelected variable is updated.
       */
      transformerRef.current?.nodes([shapeRef.current]);
      transformerRef.current?.getLayer().batchDraw();
    }
  }, [isSelected]);

  const {
    renderDimensions: { width, height },
    position: { x, y },
    image,
  } = imageDetails;

  /**
   * The most important handler functions for transformations
   * You need to handle 2 things -
   *    Change in Dimensions on transform and
   *    Change in Positions on drag
   */

  /**
   * This function handles the dimension changes of the shape
   * If you recall, you have set a property named scale equal to 1 on
   * initialisation.
   * Using this handler, you need to update the scale property of this
   * shape which can be obtained from the shapeRef
   */
  const onTransformEnd = () =&gt; {
    if (shapeRef.current) {
      const node = shapeRef.current;
      setImageDetails((current) =&gt; ({ ...current, scale: node.scale() }));
    }
  };

  /**
   * This function handles the positional changes of the shape
   * You have positions (x and y) properties in the state which you
   * will update through this handler, similar to the onTransformEnd
   * function.
   */
  const onDragEnd = () =&gt; {
    if (shapeRef.current) {
      const node = shapeRef.current;
      setImageDetails((current) =&gt; ({ ...current, x: node.x(), y: node.y() }));
    }
  };

  return (
    &lt;&gt;
      &lt;Image
        ref={shapeRef}
        image={image}
        width={width}
        height={height}
        x={x}
        y={y}

        /**
        onSelect is a function that toggles the isSelected
        variable. This function is called when image is
        clicked or tapped.
        */
        onClick={onSelect}
        onTap={onSelect}

        /** Transformation Handlers Explained above */
        onTransformEnd={onTransformEnd}
        onDragEnd={onDragEnd}
      /&gt;

      {isSelected &amp;&amp; (
        &lt;Transformer
          ref={transformerRef}
          boundBoxFunc={(oldBox, newBox) =&gt; {
            /**
              this function handles the sizing of the box
              Essentially what it does is adding a check
              to avoid reduction of size to 0
              if the newBox dimensions are less than 5 units,
              it returns the oldBox dimensions
             */
            if (newBox.width &lt; 5 || newBox.height &lt; 5) {
              return oldBox;
            }
            return newBox;
          }}
        /&gt;
      )}
    &lt;/&gt;
  );
};

export default CustomImage;
</pre>
<p>现在您已经设置了一个可转换的图像组件，让我们用这个新组件来更新我们的代码。在<code>Canvas.jsx</code>文件中，用以下代码替换图像组件:</p>
<blockquote><p>注意:因为您不希望框架是可转换的，所以只替换用于用户配置文件的图像组件。</p></blockquote>
<pre>&lt;CustomImage
  imageDetails={imageDetails}
  setImageDetails={setImageDetails}
  isSelected={selectedElement === imageDetails.id}
  onSelect={() =&gt; setSelectedElement(imageDetails.id)}
/&gt;
</pre>
<p>您还需要重构您的<code>CustomText</code>组件，使其可转换。</p>
<h2>是时候重构了</h2>
<p>根据当前的设置，我们在组件本身中存储了许多与状态相关的项目，如图像细节、文本细节、舞台细节以及处理函数。在这种情况下，您的代码将很快变得混乱和不可读。</p>
<p>此外，在我们的代码中只有三个组件的情况下，会出现大量的钻取，这不是好的实践。我们需要提升输入和上传按钮等组件所需的一些状态。</p>
<p>让我们建立全局状态管理。我们将使用上下文 API 和<code>useReducer</code>钩子。我认为，React 的核心是一个状态管理库，因此像 Redux 这样的外部库是不必要的。</p>
<p>在<code>store/actions</code>目录中，创建一个名为<code>frames.action.js</code>的新文件，并添加以下代码:</p>
<pre class="language-javascript hljs">/**
 * the useReducer hook from react takes the initialState as
 * one of its parameters. If no param is passed, the initial state
 * would be considered as null which not necessarily wrong but not at
 * all a better practice. It can lead to unknown undefined errors during
 * build time.
 * As defined below, this is the initial state structure considering all
 * the required fields related to the user profile image.
 */
export const initialState = {
  imageDetails: {
    originalDimensions: {
      width: 0,
      height: 0,
    },
    renderDimensions: {
      width: 0,
      height: 0,
    },
    position: {
      x: 0,
      y: 0,
    },
    scale: 1,
    id: "user-profile-image",
    image: null,
  },
};

/**
 * Similar to redux, define all the different types of
 * actions related to image state changes to avoid any errors down
 * the line.
 */
export const CANVAS_ACTIONS = Object.freeze({
  UPLOAD_IMAGE: "IMAGE/UPDATE_IMAGE_DETAILS",
  UPDATE_IMAGE_DIMENSIONS: "IMAGE/UPDATE_IMAGE_RENDER_DIMENSIONS",
  UPDATE_IMAGE_POSITION: "IMAGE/UPDATE_IMAGE_POSITIONS",
});
</pre>
<p>设置好我们的动作类型和初始状态后，让我们对减速器做同样的操作。在<code>store/reducers</code>目录下创建一个名为<code>frames.reducer.js</code>的文件，并添加以下代码:</p>
<pre class="language-javascript hljs">import { CANVAS_ACTIONS } from "../actions/compose.action";

/**
 * Similar to Redux, canvasReducer handles all the different
 * actions and the changes to be made to the state depending
 * on the action type.
 *
 * For now, each case returns the default state. You'll start
 * writing cases after the context API is setup
 */
export default function canvasReducer(state, action) {
  switch (action.type) {
    case CANVAS_ACTIONS.UPLOAD_IMAGE:
      return state;

    case CANVAS_ACTIONS.UPDATE_IMAGE_DIMENSIONS:
      return state;

    case CANVAS_ACTIONS.UPDATE_IMAGE_POSITIONS:
      return state;

    default:
      return state;
  }
}
</pre>
<p>在一个标准的 React 应用程序中，props 用于从父节点到子节点自顶向下地发送数据。然而，这种数据流对于应用程序中多个组件所需要的某些类型的 props 来说是不方便的。上下文 API 使得在组件之间共享这样的值成为可能，而不必通过组件树的每一层显式地传递一个属性。</p>
<p>在<code>store/contexts</code>目录下创建一个名为<code>canvas.context.js</code>的新文件，并添加以下代码:</p>
<pre class="language-javascript hljs">import React, { useReducer, useMemo, createContext, useContext } from "react";

// Reducer, Initial State, Types
import canvasReducer from "../reducers/frames.reducer";
import { initialState } from "../actions/frames.action";

/**
* use the createContext function from react to create a context component
*/
const FramesContext = createContext(initialState);

export function FramesCtxProvider(props) {
  /**
   * The useReducer hook provided by React enables you to create
   * global states. Similar to the useState hook, useReducer provides
   * access to the state through is first destructured variable and a
   * function - dispatch to which you pass an object consisting of 2 properites -
   *
   * dispatch({
   *         type: one of the types from CANVAS_ACTIONS,
   *         payload: data that would be sent to reducer function to update the state,
   * })
   */
  const [state, dispatch] = useReducer(canvasReducer, initialState);
  const value = useMemo(() =&gt; [state, dispatch], [state]);
  return &lt;FramesContext.Provider value={value} {...props} /&gt;;
}

/**
 * A very handy custom hook to easily get access to the state and dispatch functions
 * in any component
 *
 * This avoids quite a few steps where you would have to import the above context,
 * useContext hook from react and bunch of other steps.
 *
 * Instead, all you have to do now is import this hook and call it inside a component!
 */
export function useFrames() {
  const context = useContext(FramesContext);
  if (!context)
    throw new Error("useFrames must be used within a FramesCtxProvider");

  const [state, dispatch] = context;
  return [state, dispatch];
}
</pre>
<p>在使用 reducers 之前，您需要用上下文提供者包装您的应用程序。转到<code>App.jsx</code>，用以下代码更新它:</p>
<pre class="language-javascript hljs">import React from "react";

// Components
import { FramesCtxProvider } from "./store/contexts/frames.context";
import Frames from "./pages/Frame";

const App = () =&gt; {
  return (
    &lt;FramesCtxProvider&gt;
      &lt;Frames /&gt;
    &lt;/FramesCtxProvider&gt;
  );
};

export default App;

/* ==================== Inside pages/Frames.jsx ==================== */
import React from "react";

// Components
import Canvas from "../components/Canvas";

const Frames = () =&gt; {
  return (
    &lt;div&gt;
      &lt;Canvas /&gt;
    &lt;/div&gt;
  );
};

export default Frames;
</pre>
<p>理想情况下，对于结构良好的状态管理，您只需要上面的代码。然而，在撰写本文时，React Konva 不支持上下文 API。因此，我们需要设置我们的<code>canvas</code>组件来使它工作。在您的<code>Canvas.jsx</code>文件中，更新以下代码:</p>
<pre>/* Previous imports */
import { FramesContext, useFrames } from "../store/contexts/frames.context";

const Canvas = () =&gt; {
  /* remaining code */

  return (
    &lt;FramesContext.Consumer&gt;
      {(value) =&gt; (
        &lt;Stage
          ref={stageRef}
          width={stageDetails.width}
          height={stageDetails.height}
          style={{ position: "relative" }}
        &gt;
          &lt;FramesContext.Provider value={value}&gt;
            &lt;Layer&gt;
              {/* remaining code */}
            &lt;/Layer&gt;
          &lt;/FramesContext.Provider value={value}&gt;
        &lt;/Stage&gt;
      )}
    &lt;/FramesContext.Consumer&gt;
  )
}
</pre>
<p>现在，我们将更新我们的<code>reducer</code>函数来处理不同的更新，并用适当的动作类型调用 dispatch 函数。用下面的代码重构<code>frames.reducer.js</code>文件:</p>
<pre class="language-javascript hljs">export default function canvasReducer(state, action) {
  switch (action.type) {
    case CANVAS_ACTIONS.UPLOAD_IMAGE:
      return {
        ...state,
        originalDimensions: {
          width: action.payload.width,
          height: action.payload.height,
        },
        image: action.payload.image,
      };

    case CANVAS_ACTIONS.UPDATE_IMAGE_DIMENSIONS:
      return {
        ...state,
        scale: action.payload.scale,
      };

    case CANVAS_ACTIONS.UPDATE_IMAGE_POSITIONS:
      return {
        ...state,
        position: {
          x: action.payload.x,
          y: action.payload.y,
        },
      };

    default:
      return state;
  }
}
</pre>
<h2>更新组件以使用调度</h2>
<p>在我们的<code>Image</code>组件中，当<code>onTransformEnd</code>和<code>onDragEnd</code>分别被触发时，我们需要更新图像比例和图像位置:</p>
<pre class="language-javascript hljs">// State Handlers
import { useFrames } from "../store/contexts/frames.context";
import { CANVAS_ACTIONS } from "../store/actions/frames.action";

/* Remove the rest of the destructured props */
const CustomImage = ({ isSelected, onSelect }) =&gt; {
        /* Rest of code */

        const [state, dispatch] = useFrames();

        /* Update the destructured element to use the state */
  const {
    renderDimensions: { width, height },
    position: { x, y },
    image,
  } = state.imageDetails;

        /* Replace the setImageDetails with the following dispatch code */
  const onTransformEnd = () =&gt; {
    if (shapeRef.current) {
      const node = shapeRef.current;
      dispatch({
        type: CANVAS_ACTIONS.UPDATE_IMAGE_DIMENSIONS,
        payload: {
          scale: node.scale(),
        },
      });
    }
  };

        /* Replace the setImageDetails with the following dispatch code */
  const onDragEnd = () =&gt; {
    if (shapeRef.current) {
      const node = shapeRef.current;
      dispatch({
        type: CANVAS_ACTIONS.UPDATE_IMAGE_POSITIONS,
        payload: {
          x: node.x(),
          y: node.y(),
        },
      });
    }
  };

        /* Rest of code */

}
</pre>
<p>我们还需要在上传图像时更新图像细节，但我们将稍后再做。</p>
<h2>创建一个<code>upload image</code>组件</h2>
<p>为了将图像上传到我们的 profile frame 生成器，我们将创建一个相当简单的组件，它有一个类型为<code>image</code>的输入和一个具有类型为<code>upload image</code>的分派功能的<code>onChange</code>处理程序。</p>
<p>在组件目录中创建一个名为<code>UploadImage.jsx</code>的文件:</p>
<pre class="language-javascript hljs">import React from "react";

// State Handlers
import { CANVAS_ACTIONS } from "../store/actions/frames.action";
import { useFrames } from "../store/contexts/frames.context";

const UploadImage = () =&gt; {
  /**
   * Following is a destructuring way to get only dispatch
   */
  const [, dispatch] = useFrames();

  const handleInputChange = (e) =&gt; {
    /**
     * The following code is to get the image data and
     * the dimensions of the uploaded image. In order to get this
     * use the FileReader class.
     */
    if (e.target.files.length &gt; 0) {
      const file = e.target.files[0];
      const i = new Image();
      i.src = URL.createObjectURL(file);

      i.onload = () =&gt; {
        const reader = new FileReader();
        reader.readAsDataURL(file);
        reader.onload = () =&gt; {
          dispatch({
            type: CANVAS_ACTIONS.UPLOAD_IMAGE,
            payload: {
              image: i.src,
              originalDimensions: {
                width: i.width,
                height: i.height,
              },
            },
          });
        };
      };
    }
  };

  return (
    &lt;div&gt;
      &lt;label htmlFor='contained-button-file'&gt;
        &lt;button&gt;Upload Image&lt;/button&gt;
      &lt;/label&gt;

      &lt;input
        type='file'
        accept='image/*'
        style={{ display: "none" }}
        id='contained-button-file'
        maxFiles={1}
        onChange={handleInputChange}
      /&gt;
    &lt;/div&gt;
  );
};

export default UploadImage;
</pre>
<p>现在，上传功能已经准备好了，但是我们还有一个小问题要处理。目前，我们错误地硬编码了<code>CustomImage</code>组件的尺寸。如果上传的图像的长宽比不是 1:1 会怎样？</p>
<p><code>renderedDimensions</code>属性处于图像的初始状态，并且您正在获取上传时图像的原始尺寸。相反，我们将计算图像的纵横比，然后根据<code>stage</code>的大小，我们将计算图像的渲染尺寸。</p>
<p>在第一次调度之后，将以下代码添加到<code>handleImageInput</code>函数中:</p>
<pre class="language-javascript hljs">                                        const aspectRatio = i.width / i.height;
          const stageHeight = state.stageDetails.height;
          const stageWidth = state.stageDetails.width;
          dispatch({
            type: CANVAS_ACTIONS.UPDATE_IMAGE_RENDERED_DIMENSIONS,
            payload: {
              width: aspectRatio &gt; 1 ? stageWidth : stageHeight * aspectRatio,
              height: aspectRatio &gt; 1 ? stageWidth / aspectRatio : stageHeight,
            },
          });
</pre>
<h2>下载帧</h2>
<p>React Konva 提供了一种方法，通过我们传递给<code>Stage</code>组件的引用将画布转换成图像:</p>
<pre class="language-javascript hljs">const downloadURI = (uri, name) =&gt; {
  const link = document.createElement('a');
  link.download = name;
  link.href = uri;
  document.body.appendChild(link);
  link.click();
  document.body.removeChild(link);
};

const handleDownload = () =&gt; {
  if (stageRef.current) {
    const uri = stageRef.current.toDataURL();
    downloadURI(uri, 'certificate.png');
  }
};
</pre>
<p>您需要准备好输入组件，并在 stage 的<code>text</code>组件，即<code>CustomText</code>组件中显示值。实现这一点的方法与我们对图像遵循的步骤完全相同。这里是一个回顾:</p>
<p><img data-attachment-id="86185" data-permalink="https://blog.logrocket.com/build-profile-frame-generator-react-konva/text-component-download-methodology/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/01/text-component-download-methodology.png" data-orig-size="730,193" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="text-component-download-methodology" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/01/text-component-download-methodology-300x79.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/01/text-component-download-methodology.png" decoding="async" class="aligncenter wp-image-86185 size-full jetpack-lazy-image" src="../Images/1449af3cc0ff4b329502ab1d9db2e55b.png" alt="Text Component Download Methodology" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2022/01/text-component-download-methodology.png 730w, https://blog.logrocket.com/wp-content/uploads/2022/01/text-component-download-methodology-300x79.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2022/01/text-component-download-methodology.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/01/text-component-download-methodology.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="86185" data-permalink="https://blog.logrocket.com/build-profile-frame-generator-react-konva/text-component-download-methodology/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/01/text-component-download-methodology.png" data-orig-size="730,193" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="text-component-download-methodology" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/01/text-component-download-methodology-300x79.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/01/text-component-download-methodology.png" decoding="async" loading="lazy" class="aligncenter wp-image-86185 size-full" src="../Images/1449af3cc0ff4b329502ab1d9db2e55b.png" alt="Text Component Download Methodology" srcset="https://blog.logrocket.com/wp-content/uploads/2022/01/text-component-download-methodology.png 730w, https://blog.logrocket.com/wp-content/uploads/2022/01/text-component-download-methodology-300x79.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/01/text-component-download-methodology.png"/></noscript>
<h2>结论</h2>
<p>在本文中，我们学习了如何使用 React Konva 构建一个 profile 图片框架生成器。我们遵循复杂的状态管理模式，不需要任何外部包。我们还学习了如何在基于 React 的单页面应用程序中设置画布环境和操纵画布的不同方面。</p>
<p>如果您想让您的项目更具交互性，您可以将其他 React Konva 组件集成到您的应用程序中。请务必查看官方文档以了解更多详细信息。编码快乐！</p><div class="code-block code-block-17">
<div class="blog-plug inline-plug react-plug" vwo-el-id="26283398190">
<h2 vwo-el-id="41600691720">使用 LogRocket 消除传统反应错误报告的噪音</h2>
<a href="https://lp.logrocket.com/blg/react-signup-issue-free" target="_blank" vwo-el-id="19356441070">LogRocket
</a><p>是一款 React analytics 解决方案，可保护您免受数百个误报错误警报的影响，只针对少数真正重要的项目。LogRocket 告诉您 React 应用程序中实际影响用户的最具影响力的 bug 和 UX 问题。</p><a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="19356441380">
<img class="first-react-image alignnone size-full wp-image-46 jetpack-lazy-image jetpack-lazy-image--handled" src="../Images/f300c244a1a1cf916df8b4cb02bec6c6.png" vwo-el-id="18272717540" data-lazy-loaded="1" data-original-src="https://files.readme.io/27c94e7-Image_2017-06-05_at_9.46.04_PM.png"/>
</a>
<a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="19356441690">
<img class="second-react-image alignnone size-full wp-image-46 jetpack-lazy-image jetpack-lazy-image--handled" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" vwo-el-id="30720362350" data-lazy-loaded="1" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/>
</a>
<a href="https://lp.logrocket.com/blg/react-signup-issue-free" target="_blank" rel="noopener noreferrer" vwo-el-id="35866400580">LogRocket
</a><p>自动聚合客户端错误、反应错误边界、还原状态、缓慢的组件加载时间、JS 异常、前端性能指标和用户交互。然后，LogRocket 使用机器学习来通知您影响大多数用户的最具影响力的问题，并提供您修复它所需的上下文。</p><p vwo-el-id="28675661060">关注重要的 React bug—<a class="signup" href="https://lp.logrocket.com/blg/react-signup-issue-free" target="_blank" rel="noopener noreferrer" vwo-el-id="40093418840">今天就试试 LogRocket】。</a></p>
</div></div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
<html>
<head>
<title>Complete guide to authentication with React Router v6 - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>React 路由器 v6 认证完整指南</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/complete-guide-authentication-with-react-router-v6/#0001-01-01">https://blog.logrocket.com/complete-guide-authentication-with-react-router-v6/#0001-01-01</a></blockquote><div><article class="article-post">
<p><a href="https://reactrouter.com/docs/en/v6/getting-started/overview"> React Router v6 </a>是 React 应用程序的一个流行且强大的路由库。它提供了一种声明性的、基于组件的路由方法，并处理 URL 参数、重定向和加载数据等常见任务。</p>
<p>React Router 提供了一个最直观的 API，支持延迟加载和 SEO 友好的服务器端渲染。React 路由器的最新版本引入了许多新概念，如<code>&lt;Outlet /&gt;</code>和布局路由，但文档仍然很少。</p>
<p>本教程将演示如何使用 React Router v6 创建受保护的路由并添加身份验证。</p>
<p>所以，启动你最喜欢的文本编辑器，让我们开始吧！</p>
<p><em>向前跳转:</em></p>

<h2 id="getting-started">入门指南</h2>
<p>打开终端，通过运行以下命令创建一个新的 React 项目:</p>
<pre class="language-shell hljs">&gt; npx create-react-app ReactRouterAuthDemo
&gt; cd ReactRouterAuthDemo
</pre>
<p>接下来，在 React 应用程序中安装 React 路由器作为依赖项:</p>
<pre class="language-shell hljs">&gt; npm install react-router-dom
</pre>
<p>安装 React 路由器依赖项后，我们需要编辑<code>src/index.js</code>文件。</p>
<p>从<code>react-router-dom</code>导入<code>BrowserRouter</code>，然后用<code>&lt;BrowserRouter /&gt;</code>包裹<code>&lt;App /&gt;</code>组件，像这样:</p>
<pre class="language-javascript hljs">import { StrictMode } from "react";
import { createRoot } from "react-dom/client";
import { BrowserRouter } from "react-router-dom";

import App from "./App";

const rootElement = document.getElementById("root");
const root = createRoot(rootElement);

root.render(
  &lt;StrictMode&gt;
    &lt;BrowserRouter&gt;
      &lt;App /&gt;
    &lt;/BrowserRouter&gt;
  &lt;/StrictMode&gt;
);
</pre>
<p>现在，我们已经设置好在我们的应用程序中的任何地方使用 React 路由器组件和挂钩。</p>
<p>让我们用一些路径替换来自<code>App.js</code>文件的样板代码。</p>
<h2 id="basic-routing">基本路由</h2>
<p>React Router 提供了<code>&lt;Routes /&gt;</code>和<code>&lt;Route /&gt;</code>组件，使我们能够基于组件的当前位置来呈现组件:</p>
<pre class="language-javascript hljs">import { Routes, Route } from "react-router-dom";
import { LoginPage } from "./pages/Login";
import { HomePage } from "./pages/Home";
import "./styles.css";

export default function App() {
  return (
    &lt;Routes&gt;
      &lt;Route path="/" element={&lt;HomePage /&gt;} /&gt;
      &lt;Route path="/login" element={&lt;LoginPage /&gt;} /&gt;
    &lt;/Routes&gt;
  );
}
</pre>
<h3 id="basic-routing-with-route">用<code>&lt;Route &gt;</code>进行基本路由</h3>
<p><code>&lt;Route /&gt;</code>提供 app 上的路径和不同 React 组件之间的映射。例如，当有人导航到<code>/login</code>时，为了呈现<code>LoginPage</code>组件，我们只需要提供<code>&lt;Route /&gt;</code>，就像这样:</p>
<pre class="language-javascript hljs">&lt;Route path="/login" element={&lt;LoginPage /&gt;} /&gt;
</pre>
<p>组件可以被认为是一个 if 语句；只有当 URL 位置与指定的路径匹配时，它才会使用它的元素对 URL 位置进行操作。</p>
<h3 id="basic-routing-with-routes">用<code>&lt;Routes /&gt;</code>进行基本路由</h3>
<p><code>&lt;Routes /&gt;</code>组件是 React 路由器 v5 中<code>&lt;Switch /&gt;</code>组件的替代组件。</p>
<p>要使用<code>&lt;Routes /&gt;</code>，我们将首先在 pages 目录中创建包含以下内容的<code>Login.jsx</code>和<code>Home.jsx</code>文件:</p>
<pre class="language-javascript hljs">// Login.jsx
export const LoginPage = () =&gt; (
  &lt;div&gt;
    &lt;h1&gt;This is the Login Page&lt;/h1&gt;
  &lt;/div&gt;
);

// Home.jsx
export const HomePage = () =&gt; (
  &lt;div&gt;
    &lt;h1&gt;This is the Home Page&lt;/h1&gt;
  &lt;/div&gt;
);
</pre>
<p>接下来，我们将运行此命令来启动应用程序:</p>
<pre class="language-shell hljs">&gt; npm run start
</pre>
<p>在浏览器上，我们默认会看到<code>HomePage</code>组件。如果我们走<code>/login</code>路线，我们会看到<code>LoginPage</code>组件呈现在屏幕上。</p>
<p>或者，我们可以使用一个普通的 JavaScript 对象，在我们的应用程序中使用<code>useRoutes</code>钩子来表示路线。这是一种定义路线的功能方法，其工作方式与组合<code>&lt;Routes /&gt;</code>和<code>&lt;Route /&gt;</code>组件的方式相同:</p>
<pre class="language-javascript hljs">import { useRoutes } from "react-router-dom";
// ...

export default function App() {
  const routes = useRoutes([
    {
      path: "/",
      element: &lt;HomePage /&gt;
    },
    {
      path: "/login",
      element: &lt;LoginPage /&gt;
    }
  ]);
  return routes;
}
</pre>
<p>现在基本的设置已经完成，让我们看看如何创建受保护的路由，以便未经身份验证的用户不能访问我们应用程序中的某些内容。</p>
<h2 id="creating-protected-routes">创建受保护的路由</h2>
<p>在创建受保护的路由(也称为私有路由)之前，让我们创建一个定制钩子，它将使用<a href="https://reactjs.org/docs/context.html">上下文 API </a>和<code>useContext</code>钩子来处理经过身份验证的用户的状态:</p>
<pre class="language-javascript hljs">import { createContext, useContext, useMemo } from "react";
import { useNavigate } from "react-router-dom";
import { useLocalStorage } from "./useLocalStorage";
const AuthContext = createContext();

export const AuthProvider = ({ children }) =&gt; {
  const [user, setUser] = useLocalStorage("user", null);
  const navigate = useNavigate();

  // call this function when you want to authenticate the user
  const login = async (data) =&gt; {
    setUser(data);
    navigate("/profile");
  };

  // call this function to sign out logged in user
  const logout = () =&gt; {
    setUser(null);
    navigate("/", { replace: true });
  };

  const value = useMemo(
    () =&gt; ({
      user,
      login,
      logout
    }),
    [user]
  );
  return &lt;AuthContext.Provider value={value}&gt;{children}&lt;/AuthContext.Provider&gt;;
};

export const useAuth = () =&gt; {
  return useContext(AuthContext);
};
</pre>
<p>通过<code>useAuth</code>钩子，我们公开了用户的状态以及用户登录和注销的一些方法。当用户注销时，我们使用 React Router 的<code>useNavigate</code>钩子将他们重定向到主页。</p>
<p>为了在页面刷新时保持用户的状态，我们将使用<code>useLocalStorage</code>钩子来同步浏览器本地存储中的状态值:</p>
<pre class="language-javascript hljs">import { useState } from "react";

export const useLocalStorage = (keyName, defaultValue) =&gt; {
  const [storedValue, setStoredValue] = useState(() =&gt; {
    try {
      const value = window.localStorage.getItem(keyName);
      if (value) {
        return JSON.parse(value);
      } else {
        window.localStorage.setItem(keyName, JSON.stringify(defaultValue));
        return defaultValue;
      }
    } catch (err) {
      return defaultValue;
    }
  });
  const setValue = (newValue) =&gt; {
    try {
      window.localStorage.setItem(keyName, JSON.stringify(newValue));
    } catch (err) {}
    setStoredValue(newValue);
  };
  return [storedValue, setValue];
};
</pre>
<p><code>&lt;ProtectedRoute /&gt;</code>组件将简单地检查来自<code>useAuth</code>钩子的当前用户状态，然后如果用户未被认证，则重定向到主屏幕:</p>
<pre class="language-javascript hljs">import { Navigate } from "react-router-dom";
import { useAuth } from "../hooks/useAuth";

export const ProtectedRoute = ({ children }) =&gt; {
  const { user } = useAuth();
  if (!user) {
    // user is not authenticated
    return &lt;Navigate to="/" /&gt;;
  }
  return children;
};
</pre>
<p>为了重定向用户，我们使用了<code>&lt;Navigate /&gt;</code>组件。当父组件渲染时，<code>&lt;Navigate /&gt;</code>组件改变当前位置。在内部，它使用<code>useNavigate</code>钩子。</p>
<p>在<code>App.js</code>文件中，我们可以用<code>&lt;ProtectedRoute /&gt;</code>组件包装页面组件。在下面的例子中，我们用<code>&lt;ProtectedRoute /&gt;</code>包装了<code>&lt;SettingsPage /&gt;</code>和<code>&lt;ProfilePage /&gt;</code>组件。现在，当未经验证的用户试图访问<code>/profile</code>或<code>/settings</code>路径时，他们将被重定向到主页:</p>
<hr/>
<pre class="language-javascript hljs">import { Routes, Route } from "react-router-dom";
import { LoginPage } from "./pages/Login";
import { HomePage } from "./pages/Home";
import { SignUpPage } from "./pages/SignUp";
import { ProfilePage } from "./pages/Profile";
import { SettingsPage } from "./pages/Settings";
import { ProtectedRoute } from "./components/ProtectedRoute";


export default function App() {
  return (
    &lt;Routes&gt;
      &lt;Route path="/" element={&lt;HomePage /&gt;} /&gt;
      &lt;Route path="/login" element={&lt;LoginPage /&gt;} /&gt;
      &lt;Route path="/register" element={&lt;SignUpPage /&gt;} /&gt;
      &lt;Route
        path="/profile"
        element={
          &lt;ProtectedRoute&gt;
            &lt;ProfilePage /&gt;
          &lt;/ProtectedRoute&gt;
        }
      /&gt;
      &lt;Route
        path="/settings"
        element={
          &lt;ProtectedRoute&gt;
            &lt;SettingsPage /&gt;
          &lt;/ProtectedRoute&gt;
        }
      /&gt;
    &lt;/Routes&gt;
  );
}
</pre>
<p>如果受保护的路由数量有限，上面的方法就很好，但是如果有多条这样的路由，我们就必须包装每一条，这是很繁琐的。</p>
<p>相反，我们可以使用 React Router v6 嵌套路由特性将所有受保护的路由包装在一个布局中。</p>
<h2 id="using-nested-routes-and-outlet">使用嵌套路线和<code>&lt;Outlet /&gt;</code></h2>
<p>React Router v6 中最强大的功能之一是嵌套路由。此功能允许我们拥有包含其他子路由的路由。我们的大部分布局都与 URL 上的段相关联，React Router 完全支持这一点。</p>
<p>例如，我们可以向<code>&lt;HomePage /&gt;</code>和<code>&lt;LoginPage /&gt;</code>路线添加父<code>&lt;Route /&gt;</code>组件，如下所示:</p>
<pre class="language-javascript hljs">import { ProtectedLayout } from "./components/ProtectedLayout";
import { HomeLayout } from "./components/HomeLayout";
// ...

export default function App() {
  return (
    &lt;Routes&gt;
      &lt;Route element={&lt;HomeLayout /&gt;}&gt;
        &lt;Route path="/" element={&lt;HomePage /&gt;} /&gt;
        &lt;Route path="/login" element={&lt;LoginPage /&gt;} /&gt;
      &lt;/Route&gt;

      &lt;Route path="/dashboard" element={&lt;ProtectedLayout /&gt;}&gt;
        &lt;Route path="profile" element={&lt;ProfilePage /&gt;} /&gt;
        &lt;Route path="settings" element={&lt;SettingsPage /&gt;} /&gt;
      &lt;/Route&gt;
    &lt;/Routes&gt;
  );
}
</pre>
<p>父组件<code>&lt;Route /&gt;</code>也可以有一个路径，并负责在屏幕上呈现子组件<code>&lt;Route /&gt;</code>。</p>
<p>当用户导航到<code>/dashboard/profile</code>时，路由器将呈现<code>&lt;ProfilePage /&gt;</code>。为了实现这一点，父 route 元素必须有一个<code>&lt;Outlet /&gt;</code>组件来呈现子元素。<code>Outlet</code>组件使嵌套的 UI 在呈现子路由时可见。</p><div class="code-block code-block-54">
<hr/>
<h3>更多来自 LogRocket 的精彩文章:</h3>

<hr/></div>
<p>父路由元素还可以有附加的公共业务逻辑和用户界面。例如，在<code>&lt;ProtectedLayout /&gt;</code>组件中，我们包含了私有路线逻辑和一个公共导航栏，当子路线被渲染时，该导航栏将是可见的:</p>
<pre class="language-javascript hljs">import { Navigate, Outlet } from "react-router-dom";
import { useAuth } from "../hooks/useAuth";

export const ProtectedLayout = () =&gt; {
  const { user } = useAuth();

  if (!user) {
    return &lt;Navigate to="/" /&gt;;
  }

  return (
    &lt;div&gt;
      &lt;nav&gt;
        &lt;Link to="/settings"&gt;Settings&lt;/Link&gt;
        &lt;Link to="/profile"&gt;Profile&lt;/Link&gt;
      &lt;/nav&gt;
      &lt;Outlet /&gt;
    &lt;/div&gt;
  )
};
</pre>
<p>除了<code>&lt;Outlet /&gt;</code>组件，我们还可以选择使用<code>useOutlet</code>钩子来实现同样的目的:</p>
<pre class="language-javascript hljs">import { Link, Navigate, useOutlet } from "react-router-dom";
// ...

export const ProtectedLayout = () =&gt; {
  const { user } = useAuth();
  const outlet = useOutlet();

  if (!user) {
    return &lt;Navigate to="/" /&gt;;
  }

  return (
    &lt;div&gt;
      &lt;nav&gt;
        &lt;Link to="/settings"&gt;Settings&lt;/Link&gt;
        &lt;Link to="/profile"&gt;Profile&lt;/Link&gt;
      &lt;/nav&gt;
      {outlet}
    &lt;/div&gt;
  );
};
</pre>
<p>类似于受保护的路由，我们不希望经过身份验证的用户访问<code>/login</code>路径。让我们在<code>&lt;HomeLayout /&gt;</code>组件中处理它:</p>
<pre class="language-javascript hljs">import { Navigate, Outlet } from "react-router-dom";
import { useAuth } from "../hooks/useAuth";

export const HomeLayout = () =&gt; {
  const { user } = useAuth();

  if (user) {
    return &lt;Navigate to="/dashboard/profile" /&gt;;
  }

  return (
    &lt;div&gt;
      &lt;nav&gt;
        &lt;Link to="/"&gt;Home&lt;/Link&gt;
        &lt;Link to="/login"&gt;Login&lt;/Link&gt;
      &lt;/nav&gt;
      &lt;Outlet /&gt;
    &lt;/div&gt;
  )
};
</pre>
<p>你可以在这个<a href="https://codesandbox.io/s/react-router-v6-auth-demo-4jzltb"> CodeSandbox </a>中查看完整的代码和演示。</p>
<h2 id="using-react-rounter-v64-data-library-apis">使用 React 路由器 6.4 版数据库 API</h2>
<p>在 v6.4 中，<a href="https://reactrouter.com/en/main/start/overview"> React 路由器包引入了</a>新的路由器和数据 API。今后，所有 web 应用程序都应该使用<code>createBrowserRouter()</code>函数来启用数据 API 访问。将现有应用程序更新到新 API 的最快方法是用<code>createRoutesFromElements()</code>函数包装路由组件:</p>
<pre class="language-javascript hljs">export const router = createBrowserRouter(
  createRoutesFromElements(
    &lt;&gt;
      &lt;Route element={&lt;HomeLayout /&gt;}&gt;
        &lt;Route path="/" element={&lt;HomePage /&gt;} /&gt;
        &lt;Route path="/login" element={&lt;LoginPage /&gt;} /&gt;
      &lt;/Route&gt;

      &lt;Route path="/dashboard" element={&lt;ProtectedLayout /&gt;}&gt;
        &lt;Route path="profile" element={&lt;ProfilePage /&gt;} /&gt;
        &lt;Route path="settings" element={&lt;SettingsPage /&gt;} /&gt;
      &lt;/Route&gt;
    &lt;/&gt;
  )
);
</pre>
<p>在<code>index.js</code>文件中，使用<code>&lt;RouterProvider /&gt;</code>组件，而不是<code>&lt;BrowserRouter /&gt;</code>组件，并从<code>App.js</code>文件中传递导出的<code>router</code>对象。还要注意，没有<code>BrowserRouter</code><code>AuthProvider</code>将无法工作，因为它使用<code>useNavigate()</code>功能:</p>
<pre class="language-javascript hljs">import { router } from "./App";
...
root.render(
  &lt;StrictMode&gt;
    &lt;ThemeProvider theme={theme}&gt;
      &lt;RouterProvider router={router} /&gt;
    &lt;/ThemeProvider&gt;
  &lt;/StrictMode&gt;
);
</pre>
<p>为了在路由器上下文中使用<code>AuthProvider</code>，我们需要创建一个<code>&lt;AuthLayout /&gt;</code>组件，用<code>AuthProvider</code>包装<code>outlet</code>元素。这将使所有子路由都能够访问授权上下文:</p>
<pre class="language-javascript hljs">import { useLoaderData, useOutlet } from "react-router-dom";
import { AuthProvider } from "../hooks/useAuth";

export const AuthLayout = () =&gt; {
  const outlet = useOutlet();

  return (
    &lt;AuthProvider&gt;{outlet}&lt;/AuthProvider&gt;
  );
};
</pre>
<p>现在，我们可以使用<code>AuthLayout</code>组件作为根级路由，如下所示:</p>
<pre class="language-javascript hljs">export const router = createBrowserRouter(
  createRoutesFromElements(
    &lt;Route
      element={&lt;AuthLayout /&gt;}
    &gt;
      &lt;Route element={&lt;HomeLayout /&gt;}&gt;
        ...
      &lt;/Route&gt;

      &lt;Route path="/dashboard" element={&lt;ProtectedLayout /&gt;}&gt;
        ...
      &lt;/Route&gt;
    &lt;/Route&gt;
  )
);
</pre>
<p>此时，应用程序已经准备好访问数据 API。</p>
<p>通过 React Router 的数据 API，我们可以抽象出数据是如何获取的。通常，我们会使用<code>useEffect</code>钩子在组件内部加载数据。相反，我们可以使用路由器的<code>loader()</code>函数在呈现 route 元素之前获取数据。</p>
<p>考虑一个用例，当应用程序加载时，我们需要获取登录用户的数据。根据用户是否经过身份验证，我们可以将他们重定向到主页或仪表板。</p>
<p>为了模拟数据获取，我们可以将<code>Promise</code>与<code>setTimeout()</code>方法结合使用，并从<code>localStorage</code>获取用户:</p>
<pre class="language-javascript hljs">const getUserData = () =&gt;
  new Promise((resolve) =&gt;
    setTimeout(() =&gt; {
      const user = window.localStorage.getItem("user");
      resolve(user);
    }, 3000)
  );
</pre>
<p>使用<code>Route</code>组件上的<code>loader</code>道具，我们可以借助<code>defer()</code>效用函数将<code>getUserData()</code>承诺传递给<code>AuthLayout</code>组件。<code>defer()</code>函数允许我们在呈现<code>Route</code>组件之前传递承诺而不是解析的值:</p>
<pre class="language-javascript hljs">import {
  Route,
  createBrowserRouter,
  createRoutesFromElements,
  defer
} from "react-router-dom";

import { AuthLayout } from "./components/AuthLayout";
...
// ideally this would be an API call to server to get logged in user data
const getUserData = () =&gt;
  new Promise((resolve) =&gt;
    setTimeout(() =&gt; {
      const user = window.localStorage.getItem("user");
      resolve(user);
    }, 3000)
  );

export const router = createBrowserRouter(
  createRoutesFromElements(
    &lt;Route
      element={&lt;AuthLayout /&gt;}
      loader={() =&gt; defer({ userPromise: getUserData() })}
    &gt;
      &lt;Route element={&lt;HomeLayout /&gt;}&gt;
        ...
      &lt;/Route&gt;

      &lt;Route path="/dashboard" element={&lt;ProtectedLayout /&gt;}&gt;
        ...
      &lt;/Route&gt;
    &lt;/Route&gt;
  )
);
</pre>
<p>在<code>AuthLayout</code>组件中，您可以使用<code>useLoaderData</code>钩子访问<code>userPromise</code>。</p>
<p><code>Await</code>组件可以通过内置的错误处理机制呈现延迟值。组件<code>Await</code>应该被<a href="https://blog.logrocket.com/react-suspense-data-fetching/">包装在 React 悬念</a>中，以启用回退 UI。在这种情况下，我们渲染一个线性进度条，直到<code>userPromise</code>被解决。</p>
<p>如果承诺被拒绝，我们可以向<code>errorElement</code> prop 传递一个组件来呈现一个错误的 UI 状态。</p>
<p>最后，我们可以将用户数据作为初始值传递给<code>AuthProvider</code>:</p>
<pre class="language-javascript hljs">import { Suspense } from "react";
import { useLoaderData, useOutlet, Await } from "react-router-dom";
import LinearProgress from "@mui/material/LinearProgress";
import Alert from "@mui/material/Alert";
import { AuthProvider } from "../hooks/useAuth";

export const AuthLayout = () =&gt; {
  const outlet = useOutlet();

  const { userPromise } = useLoaderData();

  return (
    &lt;Suspense fallback={&lt;LinearProgress /&gt;}&gt;
      &lt;Await
        resolve={userPromise}
        errorElement={&lt;Alert severity="error"&gt;Something went wrong!&lt;/Alert&gt;}
        children={(user) =&gt; (
          &lt;AuthProvider userData={user}&gt;{outlet}&lt;/AuthProvider&gt;
        )}
      /&gt;
    &lt;/Suspense&gt;
  );
};
</pre>
<p>要验证错误情况，您可以拒绝如下所示的<code>Promise</code>:</p>
<pre class="language-javascript hljs">// for error
const getUserData = () =&gt;
  new Promise((resolve, reject) =&gt;
    setTimeout(() =&gt; {
      reject("Error");
    }, 3000)
  );
</pre>
<p>您可以在这个<a href="https://codesandbox.io/s/react-router-v6-auth-demo-updated-t28l48"> CodeSandbox </a>中查看与数据库集成的完整代码。</p>
<h2 id="conclusion">结论</h2>
<p>值得花一些时间来更好地理解 React Router v6 是如何工作的，特别是对于用户认证的常见用例。</p>
<p><a href="https://blog.logrocket.com/react-router-v6-future-reach-router/"> React 路由器 v6 是对之前版本的巨大改进</a>。它快速、稳定、可靠。除了更容易使用之外，它还有许多新功能，如<code>&lt;Outlet /&gt;</code>和一个改进的<code>&lt;Route /&gt;</code>组件，这大大简化了 React 应用程序中的路由。</p>
<p>有了 v6.4 中可用的新路由器和数据 API，您可以轻松处理乐观 UI、挂起和错误状态。您可以在组件外部抽象和加载数据，同时显示回退用户界面，直到数据准备就绪。</p>
<p>我希望本指南对您有所帮助，并且现在对如何使用 React Router v6 处理用户认证有了更好的理解。</p><div class="code-block code-block-17">
<div class="blog-plug inline-plug react-plug" vwo-el-id="26283398190">
<h2 vwo-el-id="41600691720"><a href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener"> LogRocket </a>:全面了解您的生产 React 应用</h2><p>调试 React 应用程序可能很困难，尤其是当用户遇到难以重现的问题时。如果您对监视和跟踪 Redux 状态、自动显示 JavaScript 错误以及跟踪缓慢的网络请求和组件加载时间感兴趣，</p><a href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" vwo-el-id="19356441070">try LogRocket</a><p>. </p><a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="19356441380">
<img class="first-react-image alignnone size-full wp-image-46 jetpack-lazy-image jetpack-lazy-image--handled" src="../Images/f300c244a1a1cf916df8b4cb02bec6c6.png" vwo-el-id="18272717540" data-lazy-loaded="1" data-original-src="https://files.readme.io/27c94e7-Image_2017-06-05_at_9.46.04_PM.png"/>
</a>
<a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="19356441690">
<img class="second-react-image alignnone size-full wp-image-46 jetpack-lazy-image jetpack-lazy-image--handled" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" vwo-el-id="30720362350" data-lazy-loaded="1" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/>
</a>
<p vwo-el-id="28675660440" class="">LogRocket 结合了会话回放、产品分析和错误跟踪，使软件团队能够创建理想的 web 和移动产品体验。这对你来说意味着什么？</p>
<p>LogRocket 不是猜测错误发生的原因，也不是要求用户提供截图和日志转储，而是让您回放问题，就像它们发生在您自己的浏览器中一样，以快速了解哪里出错了。</p>
<p>不再有嘈杂的警报。智能错误跟踪允许您对问题进行分类，然后从中学习。获得有影响的用户问题的通知，而不是误报。警报越少，有用的信号越多。</p>
<p vwo-el-id="28675660750">LogRocket Redux 中间件包为您的用户会话增加了一层额外的可见性。LogRocket 记录 Redux 存储中的所有操作和状态。</p>
<p vwo-el-id="28675661060">现代化您调试 React 应用的方式— <a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="40093418840">开始免费监控</a>。</p>
</div></div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
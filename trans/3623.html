<html>
<head>
<title>Building a full-stack TypeScript application with Turborepo </title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>使用Turborepo构建全栈类型脚本应用程序</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/build-full-stack-typescript-application-turborepo/#0001-01-01">https://blog.logrocket.com/build-full-stack-typescript-application-turborepo/#0001-01-01</a></blockquote><div><article class="article-post">
<p>无论你是构建一个全栈应用还是一个由多个前端和后端项目组成的应用，你都可能需要在不同程度上跨项目共享部分。</p>
<p>它可以是类型、实用程序、验证模式、组件、设计系统、开发工具或配置。Monorepos帮助开发人员在一个存储库中管理所有这些部分。</p>
<p>在本文中，我们将概述什么是monorepos以及使用Turborepo的好处。然后，我们将使用Turborepo和React以及Node.js，使用<a href="https://blog.logrocket.com/managing-full-stack-monorepo-pnpm/"> pnpm </a>工作区构建一个简单的全栈应用程序，并演示如何通过使用Turborepo来改进这个过程。</p>

<h2 id="what-is-a-monorepo">什么是单向回购？</h2>
<p>monorepo是包含多个应用程序和/或库的单个存储库。Monorepos简化了项目管理、代码共享、带有即时类型检查验证的交叉回购变更等等。</p>
<p>Turborepo是JavaScript/TypeScript生态系统中最好的monorepo工具之一。</p>
<p>它快速、易于配置和使用，独立于应用程序技术，并且可以逐步采用。它的学习曲线很短，进入门槛也很低——无论你是刚刚开始使用monorepos，还是经验丰富并希望尝试生态系统中的不同工具。</p>
<p>下面是单回购和多回购的结构示意图(来源可在此处找到<a href="https://monorepo.tools/#what-is-a-monorepo"/>):</p>
<p><img data-attachment-id="142871" data-permalink="https://blog.logrocket.com/build-full-stack-typescript-application-turborepo/attachment/monorepo-vs-polyrepo/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/11/monorepo-vs-polyrepo.png" data-orig-size="730,849" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="monorepo-vs-polyrepo" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/11/monorepo-vs-polyrepo-258x300.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/11/monorepo-vs-polyrepo.png" decoding="async" class="aligncenter wp-image-142871 size-full jetpack-lazy-image" src="../Images/e0f806ccee8e0bacb212e8d05063724d.png" alt="Monorepo-Vs-Polyrepo" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2022/11/monorepo-vs-polyrepo.png 730w, https://blog.logrocket.com/wp-content/uploads/2022/11/monorepo-vs-polyrepo-258x300.png 258w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2022/11/monorepo-vs-polyrepo.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/11/monorepo-vs-polyrepo.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="142871" data-permalink="https://blog.logrocket.com/build-full-stack-typescript-application-turborepo/attachment/monorepo-vs-polyrepo/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/11/monorepo-vs-polyrepo.png" data-orig-size="730,849" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="monorepo-vs-polyrepo" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/11/monorepo-vs-polyrepo-258x300.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/11/monorepo-vs-polyrepo.png" decoding="async" loading="lazy" class="aligncenter wp-image-142871 size-full" src="../Images/e0f806ccee8e0bacb212e8d05063724d.png" alt="Monorepo-Vs-Polyrepo" srcset="https://blog.logrocket.com/wp-content/uploads/2022/11/monorepo-vs-polyrepo.png 730w, https://blog.logrocket.com/wp-content/uploads/2022/11/monorepo-vs-polyrepo-258x300.png 258w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/11/monorepo-vs-polyrepo.png"/></noscript>
<h3 id="polyrepos">聚repos</h3>
<p>假设我们正在构建一个全栈应用程序；前端和后端都是两个独立的项目，每个项目都放在不同的存储库中——这就是polyrepo。</p>
<p>如果我们需要在前端和后端之间共享类型或实用程序，并且我们不想在两个项目中重复它们，我们必须创建第三个存储库，并将它们作为两个项目的外部包来使用。</p>
<p>每次我们修改共享包时，我们都必须构建并发布一个新版本。然后，所有使用这个包的项目应该更新到最新版本。</p>
<p>除了版本控制和发布的开销之外，这些多个部分很容易变得不同步，并且很有可能频繁中断。</p>
<p>根据你的项目，polyrepos还有其他缺点，使用monorepo是解决其中一些问题的替代方案。</p>
<h3 id="optimizing-monorepos">优化monrepos</h3>
<p>使用monorepos而没有合适的工具会使应用程序比使用polyrepos更难管理。要获得优化的monorepo，您需要一个缓存系统以及优化的任务执行，以节省开发和部署时间。</p>
<p>像<a href="https://lerna.js.org"> Lerna </a>、<a href="https://nx.dev"> Nx </a>、<a href="https://turborepo.org"> Turborepo </a>、<a href="https://moonrepo.dev"> Moon </a>、<a href="https://rushjs.io"> Rush </a>、<a href="https://bazel.build"> Bazel </a>等等工具，不一而足。今天，我们将使用Turborepo，因为它轻巧、灵活且易于使用。</p>
<p>您可以在<a href="https://monorepo.tools"> monorepo.tools </a>了解更多关于monorepos的信息，何时以及为何使用它们，以及各种工具之间的比较。</p>
<h3 id="what-is-turborepo">什么是Turborepo？</h3>
<p>Turborepo是JavaScript/TypeScript生态系统中流行的monorepo工具。它是用围棋写的，由<a href="https://twitter.com/jaredpalmer">贾里德·帕尔默</a>创作——一年前它被<a href="https://vercel.com/blog/vercel-acquires-turborepo">Vercel收购。</a></p>
<p>Turborepo速度快，易于使用和配置，是一个轻量级的层，可以很容易地添加或替换。它建立在工作区之上，这是所有主要包管理器都具有的特性。我们将在下一节更详细地讨论工作区。</p>
<p>一旦在monorepo中安装并配置了Turborepo，它将理解您的项目如何相互依赖，并最大限度地提高脚本和任务的运行速度。</p>
<p>Turborepo不会两次做同样的工作；它有一个缓存系统，允许跳过之前已经完成的工作。缓存还跟踪多个版本，因此如果您回滚到以前的版本，它可以重用以前版本的“文件”缓存。</p>
<p>Turborepo文档是了解更多信息的绝佳资源。<a href="https://turborepo.org/docs/handbook">官方Turborepo手册</a>还涵盖了monorepos的重要方面和相关主题，如迁移到monorepo、开发工作流、代码共享、林挺、测试、发布和部署。</p>
<h2 id="structuring-the-basemonorepo">构建基础单一报告</h2>
<h3 id="workspaces-with-pnpm">使用pnpm的工作区</h3>
<p>工作区是monorepo的基本构造块。所有主要的包管理器都内置了对工作区的支持，包括<a href="https://docs.npmjs.com/cli/v8/using-npm/workspaces"> npm </a>、<a href="https://classic.yarnpkg.com/lang/en/docs/workspaces"> yarn </a>和<a href="https://pnpm.io/workspaces"> pnpm </a>。</p>
<p>工作区支持在单个存储库中管理多个项目。每个项目都包含在一个工作空间中，有自己的<code>package.json</code>、源代码和配置文件。</p>
<p>在monorepo的根级别还有一个<code>package.json</code>和一个锁文件。锁文件保存了跨所有工作区安装的所有包的引用，因此您只需要运行一次<code>pnpm install</code>或<code>npm install</code>就可以安装所有的工作区依赖项。</p>
<p>我们将使用pnpm，不仅因为它的效率、速度和磁盘空间使用，还因为它对管理工作区有很好的支持，并且是Turborepo团队推荐的。</p>
<p>您可以查看这篇<a href="https://blog.logrocket.com/managing-full-stack-monorepo-pnpm">文章</a>，了解更多关于使用pnpm管理全栈monorepo的信息。</p>
<p>如果您没有安装pnpm，请查看他们的<a href="https://pnpm.io/installation">安装指南</a>。如果您愿意，也可以使用npm或yarn工作空间来代替pnpm工作空间。</p>
<h3 id="structure-overview">结构概述</h3>
<p>我们将从一般的高层结构开始。</p>
<p>首先，我们将把<code>api</code>、<code>web</code>和<code>types</code>放在monorepo根目录下的<code>packages</code>目录中。在根级别，我们还有一个用于pnpm的<code>package.json</code>和<code>pnpm-workspace.yaml</code>配置文件来指定哪些包是工作区，如下所示:</p>
<pre class="language-shell hljs">.
├── packages
│   ├── api/
│   ├── types/
│   └── web/
├── package.json
└── pnpm-workspace.yaml
</pre>
<p>我们可以使用下面的<code>mkdir</code>命令快速创建<code>packages</code>目录及其子目录:</p>
<pre class="language-shell hljs">mkdir -p packages/{api,types,web}
</pre>
<p>然后，我们将在monorepo根目录和三个包中运行<code>pnpm init</code>:</p>
<pre class="language-shell hljs">pnpm init

cd packages/api; pnpm init
cd ../../packages/types; pnpm init
cd ../../packages/web; pnpm init

cd ../..
</pre>
<p>注意，在使用<code>cd ../..</code>命令返回monorepo根目录之前，我们在每个<code>cd</code>命令后使用<code>../..</code>返回两个目录。</p>
<p>我们希望<code>packages</code>目录中的任何直接子目录都是工作区，但是pnpm和其他包管理器直到我们显式定义它们时才识别工作区。</p>
<p>配置工作区意味着我们要么通过单独列出每个工作区来指定工作区，要么使用一种模式一次匹配多个目录或工作区。该配置写在根级<code>pnpm-workspace.yaml</code>文件中。</p>
<p>我们将使用glob模式将所有的<code>packages</code>直接匹配到子目录。配置如下:</p>
<pre class="language-yaml hljs"># pnpm-workspace.yaml

packages:
  - 'packages/*'
</pre>
<p>出于性能原因，最好避免像<code>packages/**</code>这样的嵌套glob匹配，因为它不仅匹配直接的孩子，还匹配<code>packages</code>目录中的所有目录。</p>
<p>我们选择使用名称<code>packages</code>作为包含我们工作区的目录，但是它可以有不同的名称；<code>apps</code>和<code>libs</code>是我个人的喜好(受Nx启发)。</p>
<p>将它们添加到<code>[pnpm-workspace.yaml](<a href="https://pnpm.io/pnpm-workspace_yaml" rel="nofollow">https://pnpm.io/pnpm-workspace_yaml</a>)</code>后，您还可以拥有多个工作区目录。</p>
<p>在接下来的小节中，我们将为每个工作区设置一个基础项目，并安装它们的依赖项。</p>
<h2 id="shared-types-package-setup">共享类型包设置</h2>
<p>我们将从在<code>packages/types</code>设置类型包开始。</p>
<p><code>typescript</code>是这个工作区唯一需要的依赖项。下面是将其作为开发依赖项安装的命令:</p>
<pre class="language-shell hljs">pnpm add --save-dev typescript --filter types
</pre>
<p><code>package.json</code>应该是这样的:</p>
<pre class="language-json hljs">// packages/types/package.json

{
  "name": "types",
  "main": "./src/index.ts",
  "types": "./src/index.ts",
  "scripts": {
    "type-check": "tsc"
  },
  "devDependencies": {
    "typescript": "^4.8.4"
  }
}
</pre>
<p>我们现在将添加TypeScript的配置文件:</p>
<pre class="language-json hljs">// packages/types/tsconfig.json

{
  "compilerOptions": {
    "baseUrl": ".",
    "target": "es2017",
    "lib": ["dom", "dom.iterable", "esnext"],
    "allowJs": true,
    "skipLibCheck": true,
    "strict": true,
    "forceConsistentCasingInFileNames": true,
    "noEmit": true,
    "esModuleInterop": true,
    "module": "esnext",
    "moduleResolution": "node",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "jsx": "preserve"
  },
  "include": ["./src"]
}
</pre>
<p>现在一切都准备好了，让我们添加并导出我们将用于<code>api</code>和<code>web</code>的类型。</p>
<pre class="language-typescript hljs">// packages/types/src/index.ts

export type Workspace = {
  name: string
  version: string
}
</pre>
<p>共享的<code>types</code>工作区，或者任何与此相关的共享工作区，应该安装在使用它的其他工作区中。共享工作区将与消费工作区的<code>package.json</code>中的其他依赖项或开发依赖项一起列出。</p>
<p>pnpm有一个专用的协议(<code>workspace:&lt;version&gt;</code>)来解析带有链接的本地工作空间。您可能还想将工作区<code>&lt;version&gt;</code>更改为<code>*</code>，以确保您总是拥有最新的工作区版本。</p>
<p>我们可以使用下面的命令来安装<code>types</code>工作区:</p>
<pre class="language-shell hljs">pnpm add --save-dev <a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="e5919c958096a5928a978e9695848680">[email protected]</a> --filter &lt;workspace&gt;
</pre>
<blockquote><p><strong>注意</strong>，用于安装和引用<code>types</code>工作区的包名应该和<code>types</code>工作区<code>package.json</code>中定义的<code>name</code>字段完全一样</p></blockquote>
<h2 id="backend-setup-express-typescript-es-build-tsx">后端设置(快速、类型脚本、<code>esbuild</code>、<code>tsx</code>)</h2>
<p>我们现在将使用Node.js和Express at <code>packages/api</code>构建一个简单的后端API。</p>
<p>以下是我们的依赖项和开发依赖项:</p>
<pre class="language-shell hljs">pnpm add express cors --filter api
pnpm add --save-dev typescript esbuild tsx @types/{express,cors} --filter api
pnpm add --save-dev <a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="e6929f968395a69189948d9596878583">[email protected]</a> --filter api
</pre>
<p><code>package.json</code>应该是这样的:</p>
<pre class="language-shell hljs">// packages/api/package.json

{
  "name": "api",
  "scripts": {
    "dev": "tsx watch src/index.ts",
    "build": "esbuild src/index.ts --bundle --platform=node --outfile=dist/index.js --external:express --external:cors",
    "start": "node dist/index.js",
    "type-check": "tsc"
  },
  "dependencies": {
    "cors": "^2.8.5",
    "express": "^4.18.1"
  },
  "devDependencies": {
    "@types/cors": "^2.8.12",
    "@types/express": "^4.17.14",
    "esbuild": "^0.15.11",
    "tsx": "^3.10.1",
    "types": "workspace:*",
    "typescript": "^4.8.4"
  }
}
</pre>
<p>我们将使用来自<code>types</code>工作区的完全相同的<code>tsconfig.json</code>。</p>
<p>最后，我们将添加应用程序条目并公开一个端点:</p>
<pre class="language-typescript hljs">// packages/api/src/index.ts

import cors from 'cors'
import express from 'express'

import { Workspace } from 'types'

const app = express()
const port = 5000

app.use(cors({ origin: 'http://localhost:3000' }))

app.get('/workspaces', (_, response) =&gt; {
  const workspaces: Workspace[] = [
    { name: 'api', version: '1.0.0' },
    { name: 'types', version: '1.0.0' },
    { name: 'web', version: '1.0.0' },
  ]
  response.json({ data: workspaces })
})

app.listen(port, () =&gt; console.log(`Listening on http://localhost:${port}`))
</pre>
<h2 id="frontend-react-typescript-vite-setup">前端(React、TypeScript、Vite)设置</h2>
<p>这是我们将添加的最后一个工作区，它将位于<code>packages/web</code>中。这些是要安装的依赖项:</p>
<pre class="language-shell hljs">pnpm add react react-dom --filter web
pnpm add --save-dev typescript vite @vitejs/plugin-react @types/{react,react-dom} --filter web
pnpm add --save-dev <a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="681c11180d1b281f071a031b18090b0d">[email protected]</a> --filter web
</pre>
<p><code>package.json</code>应该是这样的:</p>
<pre class="language-json hljs">// packages/web/package.json

{
  "name": "web",
  "scripts": {
    "dev": "vite dev --port 3000",
    "build": "vite build",
    "start": "vite preview",
    "type-check": "tsc"
  },
  "dependencies": {
    "react": "^18.2.0",
    "react-dom": "^18.2.0"
  },
  "devDependencies": {
    "@types/react": "^18.0.21",
    "@types/react-dom": "^18.0.6",
    "@vitejs/plugin-react": "^2.1.0",
    "types": "workspace:*",
    "typescript": "^4.8.4",
    "vite": "^3.1.6"
  }
}
</pre>
<p>同样，我们将使用与用于<code>types</code>和<code>api</code>相同的<code>tsconfig.json</code>文件，在<code>compilerOptions</code>处只添加一行用于Vite的客户端类型:</p>
<pre class="language-json hljs">// packages/web/tsconfig.json

{
  "compilerOptions": {
    // ...
    "types": ["vite/client"]
  }
  // ...
}
</pre>
<p>现在，让我们添加<code>vite.config.ts</code>和条目<code>index.html</code>:</p>
<pre class="language-typescript hljs">// packages/web/vite.config.ts

import { defineConfig } from 'vite'
import react from '@vitejs/plugin-react'

export default defineConfig({
  plugins: [react()],
})
</pre>
<pre class="language-html hljs">
&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
  &lt;head&gt;
    &lt;meta charset="UTF-8" /&gt;
    &lt;meta name="viewport" content="width=device-width, initial-scale=1.0" /&gt;
    &lt;title&gt;Building a fullstack TypeScript project with Turborepo&lt;/title&gt;
  &lt;/head&gt;

  &lt;body&gt;
    &lt;div id="app"&gt;&lt;/div&gt;
    &lt;script type="module" src="/src/index.tsx"&gt;&lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;
</pre>
<p>最后，这是React应用程序在<code>src/index.tsx</code>的条目:</p>
<pre class="language-javascript hljs">// packages/web/src/index.tsx

import { StrictMode, useEffect, useState } from 'react'
import { createRoot } from 'react-dom/client'

import { Workspace } from 'types'

const App = () =&gt; {
  const [data, setData] = useState&lt;Workspace[]&gt;([])

  useEffect(() =&gt; {
    fetch('http://localhost:5000/workspaces')
      .then((response) =&gt; response.json())
      .then(({ data }) =&gt; setData(data))
  }, [])

  return (
    &lt;StrictMode&gt;
      &lt;h1&gt;Building a fullstack TypeScript project with Turborepo&lt;/h1&gt;
      &lt;h2&gt;Workspaces&lt;/h2&gt;
      &lt;pre&gt;{JSON.stringify(data, null, 2)}&lt;/pre&gt;
    &lt;/StrictMode&gt;
  )
}

const app = document.querySelector('#app')
if (app) createRoot(app).render(&lt;App /&gt;)
</pre>
<h2 id="adding-turbo-repo">添加Turborepo</h2>
<p>如果您的monorepo很简单，只有几个工作区，那么用pnpm工作区管理它们就足够了。</p>
<p>然而，对于更大的项目，我们需要一个更有效的monorepo工具来管理它们的复杂性和规模。Turborepo可以在不改变monorepo结构的情况下，通过加速林挺、测试和管道建设来改善您的工作空间。</p>
<p>速度的提升主要是因为Turborepo的<a href="https://turbo.build/repo/docs/core-concepts/caching">缓存系统</a>。运行任务后，在工作空间本身或相关工作空间发生变化之前，它不会再次运行。</p>
<p>另外，Turborepo可以多任务处理；它调度任务以最大化执行它们的速度。</p>
<blockquote><p><strong>注意</strong>，你可以在Turborepo <a href="https://turborepo.org/docs/core-concepts/running-tasks">核心概念指南</a>中阅读更多关于运行任务的信息</p></blockquote>
<p>下面是turborrepo文档中的一个例子，它比较了直接使用包管理器运行工作空间任务和使用turborrepo运行任务(图片来源<a href="https://turbo.build/repo/docs/core-concepts/monorepos/running-tasks">此处</a>):</p>
<p><img data-attachment-id="142873" data-permalink="https://blog.logrocket.com/build-full-stack-typescript-application-turborepo/attachment/turborepo-running-workspace-tasks/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/11/turborepo-running-workspace-tasks.png" data-orig-size="730,348" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="turborepo-running-workspace-tasks" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/11/turborepo-running-workspace-tasks-300x143.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/11/turborepo-running-workspace-tasks.png" decoding="async" class="aligncenter wp-image-142873 size-full jetpack-lazy-image" src="../Images/549d2cbc7ff461719263eb5a5f0d956e.png" alt="Turborepo Running Workspace Tasks" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2022/11/turborepo-running-workspace-tasks.png 730w, https://blog.logrocket.com/wp-content/uploads/2022/11/turborepo-running-workspace-tasks-300x143.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2022/11/turborepo-running-workspace-tasks.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/11/turborepo-running-workspace-tasks.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="142873" data-permalink="https://blog.logrocket.com/build-full-stack-typescript-application-turborepo/attachment/turborepo-running-workspace-tasks/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/11/turborepo-running-workspace-tasks.png" data-orig-size="730,348" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="turborepo-running-workspace-tasks" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/11/turborepo-running-workspace-tasks-300x143.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/11/turborepo-running-workspace-tasks.png" decoding="async" loading="lazy" class="aligncenter wp-image-142873 size-full" src="../Images/549d2cbc7ff461719263eb5a5f0d956e.png" alt="Turborepo Running Workspace Tasks" srcset="https://blog.logrocket.com/wp-content/uploads/2022/11/turborepo-running-workspace-tasks.png 730w, https://blog.logrocket.com/wp-content/uploads/2022/11/turborepo-running-workspace-tasks-300x143.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/11/turborepo-running-workspace-tasks.png"/></noscript>
<p>使用Turborepo运行相同的任务将导致更快、更优化的执行:</p>
<p><img data-attachment-id="142875" data-permalink="https://blog.logrocket.com/build-full-stack-typescript-application-turborepo/attachment/turborepo-running-tasks-comparison-with-tr/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/11/turborepo-running-tasks-comparison-with-tr.png" data-orig-size="730,420" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="turborepo-running-tasks-comparison-with-tr" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/11/turborepo-running-tasks-comparison-with-tr-300x173.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/11/turborepo-running-tasks-comparison-with-tr.png" decoding="async" class="aligncenter wp-image-142875 size-full jetpack-lazy-image" src="../Images/a91bf90deae813fbb4461294ea03a12d.png" alt="Turborepo Running Tasks Comparison With TR" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2022/11/turborepo-running-tasks-comparison-with-tr.png 730w, https://blog.logrocket.com/wp-content/uploads/2022/11/turborepo-running-tasks-comparison-with-tr-300x173.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2022/11/turborepo-running-tasks-comparison-with-tr.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/11/turborepo-running-tasks-comparison-with-tr.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="142875" data-permalink="https://blog.logrocket.com/build-full-stack-typescript-application-turborepo/attachment/turborepo-running-tasks-comparison-with-tr/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/11/turborepo-running-tasks-comparison-with-tr.png" data-orig-size="730,420" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="turborepo-running-tasks-comparison-with-tr" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/11/turborepo-running-tasks-comparison-with-tr-300x173.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/11/turborepo-running-tasks-comparison-with-tr.png" decoding="async" loading="lazy" class="aligncenter wp-image-142875 size-full" src="../Images/a91bf90deae813fbb4461294ea03a12d.png" alt="Turborepo Running Tasks Comparison With TR" srcset="https://blog.logrocket.com/wp-content/uploads/2022/11/turborepo-running-tasks-comparison-with-tr.png 730w, https://blog.logrocket.com/wp-content/uploads/2022/11/turborepo-running-tasks-comparison-with-tr-300x173.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/11/turborepo-running-tasks-comparison-with-tr.png"/></noscript>
<h3 id="installation-and-configuration">安装和配置</h3>
<p>如前所述，我们不需要修改工作空间设置来使用Turborepo。我们只需要做两件事来让它与我们现有的monorepo一起工作。</p>
<p>让我们首先在monorepo根目录安装<code>turbo</code>包:</p>
<pre class="language-shell hljs">pnpm add --save-dev --workspace-root turbo
</pre>
<p>让我们也将<code>.turbo</code>目录添加到<code>.gitignore</code>文件中，连同我们想要缓存的任务工件、文件和目录——就像我们例子中的<code>dist</code>目录。<code>.gitignore</code>文件应该是这样的:</p>
<pre>.turbo
node_modules
dist
</pre>
<blockquote><p><strong>注意:</strong>，如果您还没有初始化Git，请运行<code>git init</code>，确保已经在您的monorepo根目录中初始化了Git，因为Turborepo使用Git和文件哈希进行缓存</p></blockquote>
<p>现在，我们可以在<code>turbo.json</code>配置我们的Turborepo管道。管道允许我们在monorepo中声明哪些任务相互依赖。管道推断任务的依赖图，以适当地调度、执行和缓存任务输出。</p>
<p>每个管道直接键都是通过<code>turbo run &lt;task&gt;</code>可运行的任务。如果我们在工作区的<code>package.json</code> <code>scripts</code>中没有包含任务名称，那么对于相应的工作区，该任务将被忽略。</p>
<p>这些是我们想要为monorepo定义的任务:<code>dev</code>、<code>type-check</code>和<code>build</code>。</p>
<p>让我们开始定义每个任务及其选项:</p>
<pre class="language-json hljs">// turbo.json

{
  "pipeline": {
    "dev": {
      "cache": false
    },
    "type-check": {
      "outputs": []
    },
    "build": {
      "dependsOn": ["type-check"],
      "outputs": ["dist/**"]
    }
  }
}
</pre>
<p><code>cache</code>默认为启用选项；我们已经为<code>dev</code>任务禁用了它。<code>output</code>选项是一个数组。如果它是空的，它将缓存任务日志；否则，它将缓存任务指定的输出。</p>
<p>在运行<code>build</code>任务之前，我们使用<code>dependsOn</code>为每个工作区运行<code>type-check</code>任务。</p>
<p><code>cache</code>和<code>outputs</code>使用起来很简单，但是<code>dependsOn</code>有多种情况。你可以在参考<a href="https://turbo.build/repo/docs/reference/configuration">这里</a>了解更多配置选项。</p>
<p>以下是添加Turborepo后的文件结构概述:</p>
<pre class="language-shell hljs">.
├── packages
│   ├── api
│   │   ├── package.json
│   │   ├── src
│   │   │   └── index.ts
│   │   └── tsconfig.json
│   ├── types
│   │   ├── package.json
│   │   ├── src
│   │   │   └── index.ts
│   │   └── tsconfig.json
│   └── web
│       ├── index.html
│       ├── package.json
│       ├── src
│       │   └── index.tsx
│       ├── tsconfig.json
│       └── vite.config.ts
├── package.json
├── pnpm-lock.yaml
├── pnpm-workspace.yaml
└── turbo.json
</pre>
<h2 id="whatsnext">下一步是什么？</h2>
<p>Monorepos有助于管理和扩展复杂的应用程序。在很多用例中，在工作区上使用Turborepo是一个很好的选择。</p>
<p>我们仅仅触及了Turborepo的皮毛。你可以在GitHub 上的<a href="https://github.com/vercel/turborepo/tree/main/examples"> Turborepo示例目录中找到更多示例。</a><a href="https://github.com/skillrecordings/products">GitHub</a>上的技能记录也是另一个伟大的资源，自从Turborepo首次发布以来就一直存在。</p>
<p>我们强烈建议您看看<a href="https://turborepo.org/docs/core-concepts/why-turborepo"> Turborepo核心概念</a>和<a href="https://turborepo.org/docs/handbook">新手册</a>。在<a href="https://www.youtube.com/c/VercelHQ"> Vercel的频道</a>上也有几个关于Turborepo的视频，你可能会觉得有用。</p>
<p>欢迎在下面发表评论，分享你对Turborepo的看法，或者如果你有任何问题。如果你觉得这篇文章有用，请分享，并关注即将发布的文章！</p><div class="code-block code-block-21">
<div class="blog-plug inline-plug typescript-plug"><h2><a class="signup" href="https://lp.logrocket.com/blg/typescript-signup" target="_blank" rel="noopener noreferrer"> LogRocket </a>:全面了解您的网络和移动应用</h2>
<a href="https://lp.logrocket.com/blg/typescript-signup" class="signup" target="_blank" rel="noopener noreferrer"><img class="alignnone size-full wp-image-46 jetpack-lazy-image" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/><noscript><img data-lazy-fallback="1" class="alignnone size-full wp-image-46" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/></noscript></a>
<p>LogRocket 是一个前端应用程序监控解决方案，可以让您回放问题，就像问题发生在您自己的浏览器中一样。LogRocket不需要猜测错误发生的原因，也不需要向用户询问截图和日志转储，而是让您重放会话以快速了解哪里出错了。它可以与任何应用程序完美配合，不管是什么框架，并且有插件可以记录来自Redux、Vuex和@ngrx/store的额外上下文。</p>
<p>除了记录Redux操作和状态，LogRocket还记录控制台日志、JavaScript错误、堆栈跟踪、带有头+正文的网络请求/响应、浏览器元数据和自定义日志。它还使用DOM来记录页面上的HTML和CSS，甚至为最复杂的单页面和移动应用程序重新创建像素级完美视频。</p>
<a class="signup" href="https://lp.logrocket.com/blg/typescript-signup" target="_blank" rel="noopener noreferrer">Try it for free</a><p>.</p></div>
</div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
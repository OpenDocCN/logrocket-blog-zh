<html>
<head>
<title>Creating a React sortable table - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>创建一个 React 可排序的表格日志博客</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/creating-react-sortable-table/#0001-01-01">https://blog.logrocket.com/creating-react-sortable-table/#0001-01-01</a></blockquote><div><article class="article-post">
<p>有时，当我们创建一个表来显示应用程序中的数据时，我们可能希望为数据管理添加一个排序功能。</p>
<p>虽然有像<a href="https://blog.logrocket.com/complete-guide-building-smart-data-table-react/" target="_blank" rel="noopener">React Table</a>这样的库允许我们添加排序功能和更多功能，但有时使用库并不是最好的选择，尤其是如果我们想要一个完全灵活的简单表。</p>
<p>在本教程中，我们将介绍如何从头开始创建一个可排序的表。我们将通过单击表格标题对表格行进行升序或降序排序。</p>
<p>我们还将添加允许按特定列进行默认排序的功能，并且我们将构建一个可重用、可排序的表格组件。</p>
<p>最后，我们将学习如何正确使用 JavaScript <code>sort()</code>函数和一些重要的 React 原则。最终，我们将得到一个可排序的工作表，如下图所示。你可以<a href="https://ibaslogic.github.io/react-sortable-table/">与项目</a>互动，然后开始！</p>
<p><img data-attachment-id="120588" data-permalink="https://blog.logrocket.com/creating-react-sortable-table/attachment/react-sortable-table-final-project/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/03/react-sortable-table-final-project.png" data-orig-size="671,573" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="React sortable table final project" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/03/react-sortable-table-final-project-300x256.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/03/react-sortable-table-final-project.png" decoding="async" class="aligncenter wp-image-120588 size-full jetpack-lazy-image" src="../Images/a10d965de4ab405f232ad7a32962e7e7.png" alt="React Sortable Table Final Project" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2022/03/react-sortable-table-final-project.png 671w, https://blog.logrocket.com/wp-content/uploads/2022/03/react-sortable-table-final-project-300x256.png 300w" data-lazy-sizes="(max-width: 671px) 100vw, 671px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2022/03/react-sortable-table-final-project.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/03/react-sortable-table-final-project.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="120588" data-permalink="https://blog.logrocket.com/creating-react-sortable-table/attachment/react-sortable-table-final-project/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/03/react-sortable-table-final-project.png" data-orig-size="671,573" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="React sortable table final project" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/03/react-sortable-table-final-project-300x256.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/03/react-sortable-table-final-project.png" decoding="async" loading="lazy" class="aligncenter wp-image-120588 size-full" src="../Images/a10d965de4ab405f232ad7a32962e7e7.png" alt="React Sortable Table Final Project" srcset="https://blog.logrocket.com/wp-content/uploads/2022/03/react-sortable-table-final-project.png 671w, https://blog.logrocket.com/wp-content/uploads/2022/03/react-sortable-table-final-project-300x256.png 300w" sizes="(max-width: 671px) 100vw, 671px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/03/react-sortable-table-final-project.png"/></noscript>
<p>要学习本教程，您必须具备 React 的应用知识。</p>
<p><em>向前跳转:</em></p>

<h2 id="creating-the-table-markup-in-react">在 React 中创建表格标记</h2>
<p>让我们从用<code><a href="https://blog.logrocket.com/getting-started-with-create-react-app-d93147444a27/" target="_blank" rel="noopener">create-react-app</a></code>创建一个 React 项目开始，并启动开发服务器。一旦项目启动并运行，我们将创建表格标记。</p>
<p>回想一下 HTML，表格标记遵循包含表格<code>caption</code>的以下结构:</p>
<pre class="language-html hljs">&lt;table&gt;
  &lt;caption&gt;Caption here&lt;/caption&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;{/* ... */}&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;{/* ... */}&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
</pre>
<p>由于 React 是一个基于组件的库，我们可以将标记拆分成不同的组件文件。<code>Table</code>组件将作为父组件来保存<code>TableHead</code>和<code>TableBody</code>组件。</p>
<p>在这些子组件中，我们将分别呈现表格标题和主体内容。最后，我们将在<code>App</code>组件中呈现父组件。</p>
<p>在<code>src</code>文件夹中，让我们创建文件，这样我们就有了以下结构:</p>
<pre class="language-shell hljs">react-sortable-table
   ...
    ├── src
    │    ├── components
    │    │      ├── Table.js
    │    │      ├── TableBody.js
    │    │      └── TableHead.js      
    │    ├── images
    │    ├── App.js
    │    ├── index.css
    │    └── index.js
</pre>
<p>注意，我们还在<code>src</code>中添加了一个<code>images</code>文件夹。这将保存指示排序方向的图标。让我们从项目中获取图标<a href="https://github.com/Ibaslogic/react-sortable-table/tree/main/src/images" target="_blank" rel="noopener">，并将它们添加到<code>src/images</code>文件夹中。</a></p>
<p>接下来，打开<code>src/index.js</code>并更新文件，这样我们就有了:</p>
<pre class="language-javascript hljs">import React from 'react';
import ReactDOM from 'react-dom/client';
import './index.css';
import App from './App';

const root = ReactDOM.createRoot(document.getElementById('root'));
root.render(
 &lt;React.StrictMode&gt;
  &lt;App /&gt;
 &lt;/React.StrictMode&gt;
);
</pre>
<p>然后，更新<code>src/App.js</code>文件，这样我们就有了以下内容:</p>
<pre class="language-javascript hljs">const App = () =&gt; {
 return &lt;&gt;App&lt;/&gt;;
};

export default App;
</pre>
<p>在我们保存文件之前，让我们用这个项目的<a href="https://github.com/Ibaslogic/react-sortable-table/blob/main/src/index.css" target="_blank" rel="noopener"> CSS 文件</a>来替换<code>src/index.css</code>文件。如果我们现在保存文件，我们应该在前端看到一个简单的“App”文本。</p>
<h2 id="getting-the-tables-data">获取表的数据</h2>
<p>通常当我们使用表格时，我们从 API 或后端服务器异步获取表格数据。然而，对于本教程，我们将从 Mockaroo 生成一些模拟但真实的<a href="https://www.mockaroo.com/" target="_blank" rel="noopener">数据，并获得如下所示的返回 JSON 数据:</a></p>
<pre class="language-json hljs">[
 {
  "id": 1,
  "full_name": "Wendall Gripton",
  "email": "<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="9ee9f9defdecfbffeaf7e8fbb0f1ecf9">[email protected]</a>",
  "gender": "Male",
  "age": 100,
  "start_date": "2022-01-26"
 },
 // ...
]
</pre>
<p>那么，让我们在<code>src</code>文件夹中创建一个<code>data.json</code>，将<a href="https://github.com/Ibaslogic/react-sortable-table/blob/main/src/tableData1.json">项目文件中的数据复制到这里</a>，并粘贴到我们刚刚创建的文件中。现在，保存文件。</p>
<p>在文件中，您会注意到我们添加了一些<code>null</code>值来表示缺失的值。这是为了展示如何正确排序<code>null</code>数据类型的值。</p>
<h2 id="rendering-the-table-data">呈现表格数据</h2>
<p>在<code>components/Table.js</code>文件中，让我们从添加以下代码开始:</p>
<pre class="language-javascript hljs">import { useState } from "react";
import tableData1 from "../tableData1.json";
import TableBody from "./TableBody";
import TableHead from "./TableHead";

const Table = () =&gt; {
 const [tableData, setTableData] = useState(tableData1);

 const columns = [
  { label: "Full Name", accessor: "full_name" },
  { label: "Email", accessor: "email" },
  { label: "Gender", accessor: "gender" },
  { label: "Age", accessor: "age" },
  { label: "Start date", accessor: "start_date" },
 ];

 return (
  &lt;&gt;
   &lt;table className="table"&gt;
    &lt;caption&gt;
     Developers currently enrolled in this course, column headers are sortable.
    &lt;/caption&gt;
    &lt;TableHead columns={columns} /&gt;
    &lt;TableBody columns={columns} tableData={tableData} /&gt;
   &lt;/table&gt;
  &lt;/&gt;
 );
};

export default Table;
</pre>
<p>代码是不言自明的。我们导入了表数据，并将其存储在状态中。然后，我们通过 prop 将它传递给<code>TableBody</code>组件。我们还将表头定义为一个对象数组，并将它们分配给<code>columns</code>变量。</p>
<p>我们现在可以遍历<code>TableHead</code>组件中的变量来显示表格标题，并使用<code>accessor</code>键来动态访问和显示正文行数据。为此，<code>accessor</code>必须匹配<code>src/tableData1.json</code>文件中的数据键。</p>
<p>接下来，让我们访问子组件中的数据，以便呈现它们。让我们在<code>components/TableHead.js</code>文件中添加以下代码:</p>
<pre class="language-javascript hljs">const TableHead = ({ columns }) =&gt; {
 return (
  &lt;thead&gt;
   &lt;tr&gt;
    {columns.map(({ label, accessor }) =&gt; {
     return &lt;th key={accessor}&gt;{label}&lt;/th&gt;;
    })}
   &lt;/tr&gt;
  &lt;/thead&gt;
 );
};

export default TableHead;
</pre>
<p>接下来，让我们在<code>components/TableBody.js</code>文件中添加以下内容:</p>
<pre class="language-javascript hljs">const TableBody = ({ tableData, columns }) =&gt; {
 return (
  &lt;tbody&gt;
   {tableData.map((data) =&gt; {
    return (
     &lt;tr key={data.id}&gt;
      {columns.map(({ accessor }) =&gt; {
       const tData = data[accessor] ? data[accessor] : "——";
       return &lt;td key={accessor}&gt;{tData}&lt;/td&gt;;
      })}
     &lt;/tr&gt;
    );
   })}
  &lt;/tbody&gt;
 );
};

export default TableBody;
</pre>
<p>最后，更新<code>src/App.js</code>文件以包含<code>Table</code>组件:</p>
<pre class="language-javascript hljs">import Table from "./components/Table";

const App = () =&gt; {
 return (
  &lt;div className="table_container"&gt;
   &lt;h1&gt;Sortable table with React&lt;/h1&gt;
   &lt;Table /&gt;
  &lt;/div&gt;
 );
};

export default App;
</pre>
<p>让我们保存所有文件并检查前端。我们应该看到我们的表被渲染。</p>
<p><img data-attachment-id="96019" data-permalink="https://blog.logrocket.com/creating-react-sortable-table/attachment/rendered-table/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/03/rendered-table.png" data-orig-size="730,436" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Rendered table in frontend" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/03/rendered-table-300x179.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/03/rendered-table.png" decoding="async" class="aligncenter size-full wp-image-96019 jetpack-lazy-image" src="../Images/5ffc4f7cec25612947c3a937b399a076.png" alt="Rendered Table In Frontend" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2022/03/rendered-table.png 730w, https://blog.logrocket.com/wp-content/uploads/2022/03/rendered-table-300x179.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2022/03/rendered-table.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/03/rendered-table.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="96019" data-permalink="https://blog.logrocket.com/creating-react-sortable-table/attachment/rendered-table/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/03/rendered-table.png" data-orig-size="730,436" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Rendered table in frontend" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/03/rendered-table-300x179.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/03/rendered-table.png" decoding="async" loading="lazy" class="aligncenter size-full wp-image-96019" src="../Images/5ffc4f7cec25612947c3a937b399a076.png" alt="Rendered Table In Frontend" srcset="https://blog.logrocket.com/wp-content/uploads/2022/03/rendered-table.png 730w, https://blog.logrocket.com/wp-content/uploads/2022/03/rendered-table-300x179.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/03/rendered-table.png"/></noscript>
<h2 id="sorting-the-react-table-data">对 React 表数据进行排序</h2>
<p>现在，每当我们点击任何一个表格标题，我们就可以按升序或降序对特定的列进行排序。为了实现这一点，我们必须使用一个知道如何整理和排序项目的排序函数。在这种情况下，我们将使用<code>sort()</code>函数。</p>
<p>但是，根据项目的数据类型，我们可以使用不同的方法对元素进行排序。让我们快速看一下。</p>
<h3 id="the-basic-sort-function">基本<code>sort()</code>功能</h3>
<p>在最简单的形式中，我们可以使用<code>sort()</code>函数来排列<code>arr</code>数组中的元素:</p>
<pre class="language-javascript hljs">const arr = [3, 9, 6, 1];

arr.sort((a, b) =&gt; a - b);
console.log(arr); // [1, 3, 6, 9]
</pre>
<p>通过它的算法，<code>sort()</code>知道如何比较它的元素。默认情况下，它按升序排序。如果排序项是数字，则上述语法有效。对于字符串，我们有这样的东西:</p>
<pre class="language-javascript hljs">const arr2 = ["z", "a", "b", "c"];

arr2.sort((a, b) =&gt; (a &lt; b ? -1 : 1));
console.log(arr2); // ["a", "b", "c", "z"]
</pre>
<p>这里，<code>sort()</code>比较条目并返回一个整数，以了解条目在列表中是上移还是下移。在上面的实现中，如果比较函数返回一个负数，第一项<code>a</code>小于<code>b</code>，因此上移，这表示升序，反之亦然。</p>
<p>理解使用<code>sort()</code>函数的排序原理对于表格数据的排序至关重要。现在，让我们看更多的例子。</p>
<p>如果我们将以下数据按<code>name</code>排序:</p>
<pre class="language-javascript hljs">const data = [
  { name: "Ibas", age: 100 },
  {
    name: "doe",
    age: 36
  }
];
</pre>
<p>我们将有以下代码:</p>
<pre class="language-javascript hljs">const data1 = [...data].sort((a, b) =&gt; (a.name &lt; b.name ? -1 : 1));

data1.map((d) =&gt; console.log("without conversion", d.name)); // Ibas, doe
</pre>
<p>请注意，输出不是我们所期望的。基于默认的升序规则，我们期望<code>doe</code>在<code>Ibas</code>之前列出。这是因为字符是按 Unicode 值排序的。</p>
<p>在<a href="https://www.utf8-chartable.de/" target="_blank" rel="noopener"> Unicode 表</a>中，大写字母的值小于小写字母的值。为了确保看到预期的结果，我们必须通过将排序项转换为小写或大写，按不区分大小写进行排序。</p>
<p>我们的代码现在应该是这样的:</p>
<pre class="language-javascript hljs">const data2 = [...data].sort((a, b) =&gt;
  a.name.toLowerCase() &lt; b.name.toLowerCase() ? -1 : 1
);

data2.map((d) =&gt; console.log("with conversion", d.name)); // doe, Ibas
</pre>
<p>这和预期的一样有效。但是，在我们的项目中，我们将按照不同的数据类型对表头进行排序，这些数据类型包括<code>number</code>、<code>string</code>和<code>date</code>。</p>
<p>在上面的实现中，我们不能传递数字，因为<code>.toLowerCase()</code>函数只存在于字符串上。这就是<code>localeCompare()</code>函数的用武之地。</p>
<h3 id="using-localecompare-with-the-sort-function">将<code>localeCompare()</code>与<code>sort()</code>功能一起使用</h3>
<p>这个函数能够处理不同的数据类型，包括不同语言的字符串，因此它们以正确的顺序出现。这非常适合我们的用例。</p><div class="code-block code-block-54">
<hr/>
<h3>更多来自 LogRocket 的精彩文章:</h3>

<hr/></div>
<p>如果我们用它按照<code>name</code>对<code>data</code>数组进行排序，我们得到如下结果:</p>
<pre class="language-javascript hljs">const data3 = [...data].sort((a, b) =&gt; a.name.localeCompare(b.name));

data3.map((d) =&gt; console.log("with localeCompare", d.name, d.age)); // doe 36, Ibas 100
</pre>
<p>像前面的比较函数一样，<code>localeCompare()</code>也返回一个数字。在上面的实现中，如果<code>a.name</code>小于<code>b.name</code>，它将返回一个负数，反之亦然。这个函数只应用于字符串，但是它提供了一个数字排序的选项。</p>
<p>回到我们的<code>data</code>数组，我们可以通过调用<code>age</code>上的<code>.toString()</code>得到一个字符串表示来按照<code>age</code>号排序:</p>
<pre class="language-javascript hljs">const data4 = [...data].sort((a, b) =&gt;
  a.age.toString().localeCompare(b.age.toString())
);

data4.map((d) =&gt; console.log("with localeCompare", d.name, d.age)); // ibas 100, doe 36
</pre>
<p>同样，在代码中我们注意到<code>100</code>在<code>36</code>之前，这不是我们所期望的。这也是因为值是字符串，因此，<code>"100"</code> <code>&lt;</code> <code>"36"</code>是正确的。对于数字排序，我们必须指定<code>numeric</code>选项，因此我们有:</p>
<pre class="language-javascript hljs">const data5 = [...data].sort((a, b) =&gt;
  a.age.toString().localeCompare(b.age.toString(), "en", {
    numeric: true
  })
);

data5.map((d) =&gt; console.log("with localeCompare", d.name, d.age)); /// doe 36, Ibas 100
</pre>
<p>如上所述，我们现在得到了适当的安排。在代码中，我们还包含了一个可选的<code>"en"</code> locale 来指定应用程序语言。</p>
<p>既然我们已经更新了如何使用<code>sort()</code>函数，在我们的项目中实现它将是小菜一碟。</p>
<h2 id="handling-the-onclick-event-and-sorting-data">处理<code>onClick</code>事件并整理数据</h2>
<p>当我们单击一个特定的表格标题时，我们必须跟踪排序顺序和排序列。为此，我们必须使用<code>useState</code>钩子。</p>
<p>在<code>components/TableHead.js</code>中，导入<code>useState</code>钩子，使用方法如下:</p>
<pre class="language-javascript hljs">import { useState } from "react";

const TableHead = ({ columns }) =&gt; {
 const [sortField, setSortField] = useState("");
 const [order, setOrder] = useState("asc");
 return (
  // ...
 );
};

export default TableHead;
</pre>
<p>接下来，向表头<code>th</code>添加一个<code>onClick</code>事件，并在<code>return</code>语句上方添加其处理函数:</p>
<pre class="language-javascript hljs">const TableHead = ({ columns }) =&gt; {
 // ...
 const handleSortingChange = (accessor) =&gt; {
  console.log(accessor);
 };
 return (
  &lt;thead&gt;
   &lt;tr&gt;
    {columns.map(({ label, accessor }) =&gt; {
     return (
      &lt;th key={accessor} onClick={() =&gt; handleSortingChange(accessor)}&gt;
       {label}
      &lt;/th&gt;
     );
    })}
   &lt;/tr&gt;
  &lt;/thead&gt;
 );
};

export default TableHead;
</pre>
<p>让我们保存文件。如果我们打开控制台并单击表格标题，我们应该会看到它们各自的<code>accessor</code>键。</p>
<p>接下来，让我们定义一个逻辑，通过更新<code>handleSortingChange</code>处理程序来切换每个标题点击的顺序，这样我们就有了以下内容:</p>
<pre class="language-javascript hljs">const handleSortingChange = (accessor) =&gt; {
 const sortOrder =
  accessor === sortField &amp;&amp; order === "asc" ? "desc" : "asc";
 setSortField(accessor);
 setOrder(sortOrder);
 handleSorting(accessor, sortOrder);
};
</pre>
<p>此时，我们可以访问最新的排序顺序。现在，为了操作表数据，我们必须将<code>order</code>向上传递到父<code>Table</code>组件，我们已经使用<code>handleSorting()</code>函数调用完成了。</p>
<p>这是因为<code>Table</code>组件是保存状态数据的组件。因此，它是唯一可以改变它的组件。在 React 中，我们可以像在这个文件中一样引发一个事件，然后通过 props 在父组件中处理它。</p>
<p>因此，在我们保存文件之前，让我们确保我们析构了组件 prop，并且可以像这样访问<code>handleSorting</code>:</p>
<pre class="language-javascript hljs">const TableHead = ({ columns, handleSorting }) =&gt; {
</pre>
<p>现在，保存文件。</p>
<p>接下来，让我们打开<code>components/Table.js</code>文件来处理事件。首先，在<code>return</code>中，让我们确保将<code>handleSorting</code>作为道具传递给<code>TableHead</code>实例:</p>
<pre class="language-javascript hljs">return (
 &lt;&gt;
  &lt;table className="table"&gt;
   {/* ... */}
   &lt;TableHead columns={columns} handleSorting={handleSorting} /&gt;
   &lt;TableBody columns={columns} tableData={tableData} /&gt;
  &lt;/table&gt;
 &lt;/&gt;
);
</pre>
<p>我们可以重写上面的代码，让它看起来更简单，就像这样:</p>
<pre class="language-javascript hljs">return (
 &lt;&gt;
  &lt;table className="table"&gt;
   {/* ... */}
   &lt;TableHead {...{ columns, handleSorting }} /&gt;
   &lt;TableBody {...{ columns, tableData }} /&gt;
  &lt;/table&gt;
 &lt;/&gt;
);
</pre>
<p>以上两种方法都可以。</p>
<p>最后，让我们在<code>return</code>语句上方添加<code>handleSorting</code>处理程序:</p>
<pre class="language-javascript hljs">const handleSorting = (sortField, sortOrder) =&gt; {
 console.log(sortField, sortOrder)
};
</pre>
<p>让我们保存所有文件。</p>
<p><code>handleSorting</code>处理程序需要两个参数，因为我们从<code>TableHead</code>组件传递了它们。同时，每当我们单击表格标题时，我们都会将这些参数记录到控制台中。</p>
<p>接下来，我们将在使用<code>localeCompare()</code>的同时使用<code>sort()</code>函数来正确地对表格数据进行排序。幸运的是，我们在本教程的前面已经了解了这一点。</p>
<p>通过应用排序逻辑，<code>handleSorting</code>处理程序现在看起来像这样:</p>
<pre class="language-javascript hljs">const handleSorting = (sortField, sortOrder) =&gt; {
 if (sortField) {
  const sorted = [...tableData].sort((a, b) =&gt; {
   return (
    a[sortField].toString().localeCompare(b[sortField].toString(), "en", {
     numeric: true,
    }) * (sortOrder === "asc" ? 1 : -1)
   );
  });
  setTableData(sorted);
 }
};
</pre>
<p>代码应该足够清楚。如果您需要复习，请重温之前的解释。这里，我们按照列标题对表格数据进行排序，然后通过<code>setTableData()</code> updater 函数更新<code>tableData</code>状态。</p>
<p>注意我们是如何通过检查<code>"asc"</code>值并切换返回值来反转排序顺序的。</p>
<p>让我们保存并测试我们的项目。</p>
<p>在我们单击包含<code>null</code>值的列之前，该项目应该一直工作。让我们通过更新处理程序来检查<code>null</code>值来解决这个问题:</p>
<pre class="language-javascript hljs">const handleSorting = (sortField, sortOrder) =&gt; {
 if (sortField) {
  const sorted = [...tableData].sort((a, b) =&gt; {
   if (a[sortField] === null) return 1;
   if (b[sortField] === null) return -1;
   if (a[sortField] === null &amp;&amp; b[sortField] === null) return 0;
   return (
    a[sortField].toString().localeCompare(b[sortField].toString(), "en", {
     numeric: true,
    }) * (sortOrder === "asc" ? 1 : -1)
   );
  });
  setTableData(sorted);
 }
};
</pre>
<p>现在，保存文件并测试项目。应该能行。</p>
<h3 id="enabling-or-disabling-sorting-for-specific-columns">启用或禁用特定列的排序</h3>
<p>接下来，让我们向<code>columns</code>项添加一个<code>sortable</code>键，并指定一个布尔值来允许或不允许对任何列进行排序。</p>
<pre class="language-javascript hljs">const columns = [
 { label: "Full Name", accessor: "full_name", sortable: true },
 { label: "Email", accessor: "email", sortable: false },
 { label: "Gender", accessor: "gender", sortable: true },
 { label: "Age", accessor: "age", sortable: true },
 { label: "Start date", accessor: "start_date", sortable: true },
];
</pre>
<p>然后，我们可以在<code>TableHead</code>组件中访问这个键，并使用它来激活一个点击事件，如下所示:</p>
<pre class="language-javascript hljs">return (
 &lt;thead&gt;
  &lt;tr&gt;
   {columns.map(({ label, accessor, sortable }) =&gt; {
    return (
     &lt;th
      key={accessor}
      onClick={sortable ? () =&gt; handleSortingChange(accessor) : null}
     &gt;
      {label}
     &lt;/th&gt;
    );
   })}
  &lt;/tr&gt;
 &lt;/thead&gt;
);
</pre>
<p>现在，我们应该能够对任何列进行排序，除了那些值为<code>false</code>的列。</p>
<h2 id="displaying-icons-to-indicate-the-sorting-direction">显示图标以指示分类方向</h2>
<p>这很简单。这里，让我们动态地将<code>default</code>、<code>up</code>和<code>down</code>类名添加到表头的<code>th</code>元素中。这些类已经在我们的 CSS 文件中添加了箭头图标。在<code>components/TableHead.js</code>文件中，更新<code>return</code>语句，这样我们就有了以下内容:</p>
<pre class="language-javascript hljs">return (
 &lt;thead&gt;
  &lt;tr&gt;
   {columns.map(({ label, accessor, sortable }) =&gt; {
    const cl = sortable
     ? sortField === accessor &amp;&amp; order === "asc"
      ? "up"
      : sortField === accessor &amp;&amp; order === "desc"
      ? "down"
      : "default"
     : "";
    return (
     &lt;th
      // ...
      className={cl}
     &gt;
      {label}
     &lt;/th&gt;
    );
   })}
  &lt;/tr&gt;
 &lt;/thead&gt;
);
</pre>
<p>在代码中，我们使用嵌套的三元运算符来检查订单状态，并相应地分配类名。保存并测试您的项目。</p>
<h2 id="making-the-table-reusable">使桌子可重复使用</h2>
<p>React 允许我们在需要时重用组件逻辑。例如，如果我们需要在项目的不同部分包含另一个数据表，我们可以使用自定义钩子在组件之间提取和共享类似的逻辑。</p>
<p>在这里，我们将创建一个定制的钩子来重用不同表组件中的排序功能。</p>

<p>让我们从将排序逻辑提取到一个可重用的函数<code>useSortableTable</code>开始。在<code>src</code>文件夹中，创建一个名为<code>useSortableTable.js</code>的文件，并添加以下代码:</p>
<pre class="language-javascript hljs">import { useState } from "react";
export const useSortableTable = (data) =&gt; {
 const [tableData, setTableData] = useState(data);

 const handleSorting = (sortField, sortOrder) =&gt; {
  if (sortField) {
   const sorted = [...tableData].sort((a, b) =&gt; {
    if (a[sortField] === null) return 1;
    if (b[sortField] === null) return -1;
    if (a[sortField] === null &amp;&amp; b[sortField] === null) return 0;
    return (
     a[sortField].toString().localeCompare(b[sortField].toString(), "en", {
      numeric: true,
     }) * (sortOrder === "asc" ? 1 : -1)
    );
   });
   setTableData(sorted);
  }
 };

 return [tableData, handleSorting];
};
</pre>
<p>在上面的代码中，我们只将排序逻辑提取到一个定制的钩子文件中。钩子将表数据作为参数，并在我们单击列标题时返回排序后的数据。接下来，我们将使用钩子代替<code>Table</code>组件中的逻辑。</p>
<p>打开<code>components/Table.js</code>文件。然后，导入并使用<code>useSortableTable()</code>自定义钩子，如下所示:</p>
<pre class="language-javascript hljs">// ...
import { useSortableTable } from "../useSortableTable";

const Table = () =&gt; {
 const columns = [
  // ...
 ];
 const [tableData, handleSorting] = useSortableTable(tableData1);
 return (
  // ...
 );
};

export default Table;
</pre>
<p>有了这个实现，<code>Table</code>组件包含的代码更少。如果我们保存文件并测试我们的项目，它应该会像预期的那样工作。现在，我们可以在任何其他表组件中重用该逻辑。</p>
<h3 id="creating-a-reusable-table-component">创建可重用的<code>Table</code>组件</h3>
<p>在上一节中，我们学习了如何使用自定义钩子重用组件逻辑。这使我们能够重用排序功能。现在让我们来看看如何进一步抽象表逻辑，只暴露一个<code>Table</code>实例，在这个实例中我们可以传递一些与特定表相关的属性。</p>
<p>在我们的代码中，我们目前正在渲染<code>src/App.js</code>中的<code>&lt;Table /&gt;</code>。让我们从<code>Table</code>组件中取出与该表相关的所有数据，并在<code>src/App.js</code>中使用它。这些数据包括表体内容、列和表标题。</p>
<p><code>src/App.js</code>文件现在看起来像这样:</p>
<pre class="language-javascript hljs">import Table from "./components/Table";
import tableData1 from "./tableData1.json";

const columns = [
 // ...
];

const App = () =&gt; {
 return (
  &lt;div className="table_container"&gt;
   &lt;h1&gt;Sortable table with React&lt;/h1&gt;
   &lt;Table
    caption="Developers currently enrolled in this course, column headers are sortable."
    data={tableData1}
    columns={columns}
   /&gt;
  &lt;/div&gt;
 );
};

export default App;
</pre>
<p>现在，我们可以从<code>Table</code>组件接收道具，然后在我们的渲染中使用它们:</p>
<pre class="language-javascript hljs">// ...
const Table = ({ caption, data, columns }) =&gt; {
 const [tableData, handleSorting] = useSortableTable(data);

 return (
  &lt;&gt;
   &lt;table className="table"&gt;
    &lt;caption&gt;{caption}&lt;/caption&gt;
    &lt;TableHead {...{ columns, handleSorting }} /&gt;
    &lt;TableBody {...{ columns, tableData }} /&gt;
   &lt;/table&gt;
  &lt;/&gt;
 );
};

export default Table;
</pre>
<p>现在，保存文件并测试项目。</p>
<h3 id="rendering-another-data-table">呈现另一个数据表</h3>
<p>让我们获取另一个数据表，并使用相同的<code>Table</code>组件呈现它。首先，在<code>src</code>文件夹中创建一个<code>tableData2.json</code>文件。然后，从<a href="https://github.com/Ibaslogic/react-sortable-table/blob/main/src/tableData2.json">项目文件</a>中复制数据并粘贴到<code>tableData2.json</code>文件中。</p>
<p>接下来，让我们在<code>components</code>文件夹中创建一个名为<code>RenderAnotherTable.js</code>的组件文件，并呈现新的表格。</p>
<pre class="language-javascript hljs">import Table from "./Table";
import tableData2 from "../tableData2.json";

const columns = [
 { label: "Name", accessor: "name", sortable: true },
 { label: "Country", accessor: "country", sortable: true },
 { label: "GitHub username", accessor: "github_username", sortable: true },
 { label: "Course price", accessor: "money", sortable: true },
];

const RenderAnotherTable = () =&gt; {
 return (
  &lt;&gt;
   &lt;Table
    caption="List of developers with an affordable course."
    data={tableData2}
    columns={columns}
   /&gt;
  &lt;/&gt;
 );
};

export default RenderAnotherTable;
</pre>
<p>现在，我们可以在任何文件中呈现这个新组件。在我们的例子中，我们将在<code>src/App.js</code>文件中呈现它:</p>
<pre class="language-javascript hljs">import RenderAnotherTable from "./components/RenderAnotherTable";
// ...
const App = () =&gt; {
 return (
  &lt;div className="table_container"&gt;
   {/* ... */}
   &lt;br /&gt;
   &lt;RenderAnotherTable /&gt;
  &lt;/div&gt;
 );
};

export default App;
</pre>
<p>保存所有文件并测试您的项目。它应该像预期的那样工作。</p>
<h2 id="default-sorting-by-column">按列默认排序</h2>
<p>让我们添加逻辑，使我们能够在初始呈现时按特定列对表进行排序。让我们在<code>src/App.js</code>文件中找到<code>columns</code>数组，并添加一个带有<code>desc</code>值的<code>sortbyOrder</code>键:</p>
<pre class="language-javascript hljs">const columns = [
 // ...
 { label: "Gender", accessor: "gender", sortable: true, sortbyOrder: "desc" },
 // ...
];
</pre>
<p>这样，我们将根据<code>G``ender</code>列对表格进行降序排序。</p>
<p>在<code>Table</code>组件中，让我们也将<code>columns</code>传递给<code>useSortableTable</code>钩子，这样我们就可以定义默认的排序功能。</p>
<pre class="language-javascript hljs">const Table = ({ caption, data, columns }) =&gt; {
 const [tableData, handleSorting] = useSortableTable(data, columns);

 return (
  // ...
 );
};

export default Table;
</pre>
<p>接下来，打开<code>src/useSortableTable.js</code>文件并访问列:</p>
<pre class="language-javascript hljs">export const useSortableTable = (data, columns) =&gt; {
 const [tableData, setTableData] = useState(data);

 const handleSorting = (sortField, sortOrder) =&gt; {
  // ...
 };

 return [tableData, handleSorting];
};
</pre>
<p>在初始呈现时，我们不是将未排序的表数据传递给 state，而是传递一个函数来检测我们是否希望对特定列进行默认排序，然后返回排序后的表。</p>
<p>因此，让我们用一个函数来初始化状态，该函数接受数据和列，并定义默认的排序逻辑，如下所示:</p>
<pre class="language-javascript hljs">function getDefaultSorting(defaultTableData, columns) {
 const sorted = [...defaultTableData].sort((a, b) =&gt; {
  const filterColumn = columns.filter((column) =&gt; column.sortbyOrder);

  // Merge all array objects into single object and extract accessor and sortbyOrder keys
  let { accessor = "id", sortbyOrder = "asc" } = Object.assign(
   {},
   ...filterColumn
  );

  if (a[accessor] === null) return 1;
  if (b[accessor] === null) return -1;
  if (a[accessor] === null &amp;&amp; b[accessor] === null) return 0;

  const ascending = a[accessor]
   .toString()
   .localeCompare(b[accessor].toString(), "en", {
    numeric: true,
   });

  return sortbyOrder === "asc" ? ascending : -ascending;
 });
 return sorted;
}

export const useSortableTable = (data, columns) =&gt; {
 const [tableData, setTableData] = useState(getDefaultSorting(data, columns));

 // ...
 return [tableData, handleSorting];
};
</pre>
<p>在初始呈现时，我们检查是否有任何列有<code>sortbyOrder</code>键，然后按照指定的值对列进行排序；不是上升就是下降。如果我们保存我们的文件并测试项目，它应该工作。你可以在这里亲眼看看。</p>
<p>差不多就是这样！</p>
<h2 id="conclusion">结论</h2>
<p>向表中添加排序功能对于数据管理和改善用户体验至关重要，尤其是对于包含许多行的表。</p>
<p>在本教程中，我们学习了如何在不使用任何库的情况下向 React 表添加排序功能(包括根据特定列的默认排序功能)。我们还学习了如何重用表逻辑向项目的不同部分添加另一个数据表。</p>
<p>如果你喜欢这个教程，努力在网上分享它。如果你有问题或贡献，请在评论区分享你的想法。</p>
<p>你可以在我的 GitHub 上找到<a href="https://github.com/Ibaslogic/react-sortable-table" target="_blank" rel="noopener">项目源代码。</a></p><div class="code-block code-block-17">
<div class="blog-plug inline-plug react-plug" vwo-el-id="26283398190">
<h2 vwo-el-id="41600691720">使用 LogRocket 消除传统反应错误报告的噪音</h2>
<a href="https://lp.logrocket.com/blg/react-signup-issue-free" target="_blank" vwo-el-id="19356441070">LogRocket
</a><p>是一款 React analytics 解决方案，可保护您免受数百个误报错误警报的影响，只针对少数真正重要的项目。LogRocket 告诉您 React 应用程序中实际影响用户的最具影响力的 bug 和 UX 问题。</p><a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="19356441380">
<img class="first-react-image alignnone size-full wp-image-46 jetpack-lazy-image jetpack-lazy-image--handled" src="../Images/f300c244a1a1cf916df8b4cb02bec6c6.png" vwo-el-id="18272717540" data-lazy-loaded="1" data-original-src="https://files.readme.io/27c94e7-Image_2017-06-05_at_9.46.04_PM.png"/>
</a>
<a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="19356441690">
<img class="second-react-image alignnone size-full wp-image-46 jetpack-lazy-image jetpack-lazy-image--handled" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" vwo-el-id="30720362350" data-lazy-loaded="1" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/>
</a>
<a href="https://lp.logrocket.com/blg/react-signup-issue-free" target="_blank" rel="noopener noreferrer" vwo-el-id="35866400580">LogRocket
</a><p>自动聚合客户端错误、反应错误边界、还原状态、缓慢的组件加载时间、JS 异常、前端性能指标和用户交互。然后，LogRocket 使用机器学习来通知您影响大多数用户的最具影响力的问题，并提供您修复它所需的上下文。</p><p vwo-el-id="28675661060">关注重要的 React bug—<a class="signup" href="https://lp.logrocket.com/blg/react-signup-issue-free" target="_blank" rel="noopener noreferrer" vwo-el-id="40093418840">今天就试试 LogRocket】。</a></p>
</div></div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
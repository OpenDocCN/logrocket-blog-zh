<html>
<head>
<title>Using Jotai with Next.js </title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>通过Next.js使用Jotai</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/using-jotai-next-js/#0001-01-01">https://blog.logrocket.com/using-jotai-next-js/#0001-01-01</a></blockquote><div><article class="article-post">
<p>在过去的几年里，React生态系统简化并改进了网络。它为构建现代web应用程序带来了许多有用的模式和实践。</p>
<p>从一开始，React就将自己定位为一个非个人化的、仅供查看的库。这意味着React只负责视图层，或者渲染到屏幕上的内容。它通过改变DOM节点来做到这一点。如何在应用程序中共享状态的逻辑取决于开发人员。</p>
<p>在本文中，您将了解Jotai APIs，以及如何使用这些模式在Next.js应用程序中共享状态。</p>
<p>向前跳:</p>

<h2 id="sharing-state-react-apps">在React应用程序中共享状态</h2>
<p>尽管React提供了诸如<code>useState()</code>和<code>useContext()</code>这样的API来管理应用程序的状态，但是在构建应用程序时，这些API可能并不是最理想的。开发人员长期以来一直在构建和利用第三方状态管理库，如<a href="https://blog.logrocket.com/understanding-redux-tutorial-examples/"> Redux </a>、<a href="https://blog.logrocket.com/smarter-redux-redux-toolkit/"> Redux Toolkit </a>、<a href="https://blog.logrocket.com/managing-react-state-zustand/"> Zustand </a>等。</p>
<p>Jotai就是这样一个库，你可以用它来共享和管理你的应用程序的状态。Jotai与其他库的不同之处在于它采用了自底向上的方法:</p>
<p><img data-attachment-id="160326" data-permalink="https://blog.logrocket.com/using-jotai-next-js/attachment/bottom-up-vs-top-down-state-update-flow/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2023/02/Bottom-up-vs-top-down-state-update-flow.png" data-orig-size="730,386" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Bottom-up-vs-top-down-state-update-flow" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2023/02/Bottom-up-vs-top-down-state-update-flow-300x159.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2023/02/Bottom-up-vs-top-down-state-update-flow.png" decoding="async" class="aligncenter wp-image-160326 size-full jetpack-lazy-image" src="../Images/c18631f23d4834167c455a7bbbe52c52.png" alt="Simple Diagram Sketch Showing Difference Between Bottom Up Vs Top Down Approaches To State Update Flows" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2023/02/Bottom-up-vs-top-down-state-update-flow.png 730w, https://blog.logrocket.com/wp-content/uploads/2023/02/Bottom-up-vs-top-down-state-update-flow-300x159.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2023/02/Bottom-up-vs-top-down-state-update-flow.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2023/02/Bottom-up-vs-top-down-state-update-flow.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="160326" data-permalink="https://blog.logrocket.com/using-jotai-next-js/attachment/bottom-up-vs-top-down-state-update-flow/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2023/02/Bottom-up-vs-top-down-state-update-flow.png" data-orig-size="730,386" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Bottom-up-vs-top-down-state-update-flow" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2023/02/Bottom-up-vs-top-down-state-update-flow-300x159.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2023/02/Bottom-up-vs-top-down-state-update-flow.png" decoding="async" loading="lazy" class="aligncenter wp-image-160326 size-full" src="../Images/c18631f23d4834167c455a7bbbe52c52.png" alt="Simple Diagram Sketch Showing Difference Between Bottom Up Vs Top Down Approaches To State Update Flows" srcset="https://blog.logrocket.com/wp-content/uploads/2023/02/Bottom-up-vs-top-down-state-update-flow.png 730w, https://blog.logrocket.com/wp-content/uploads/2023/02/Bottom-up-vs-top-down-state-update-flow-300x159.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2023/02/Bottom-up-vs-top-down-state-update-flow.png"/></noscript>
<p>像Redux或Zustland这样的库在DOM树之外创建一个全局存储，并以自顶向下的方式将状态更新传递给子组件。Jotai做的正好相反——它的状态存在于React DOM树本身中，组件状态树以自底向上的方式更新。</p>
<h2 id="core-principles-jotai">Jotai的核心原则</h2>
<p>Jotai是一个非常小的图书馆，作为一个状态共享解决方案，它有很多事情要做。它的灵感来自于<a href="https://blog.logrocket.com/simple-state-management-react-recoil/">脸书的反冲</a>，它解决了一系列类似的问题，但被推荐给更大规模的组织。</p>
<p>与Jotai不同，反冲是一个固执己见的库，它有自己设置应用程序的方式。Jotai是完全非个人化的，并且提供了与React APIs非常相似的API，为具有React经验的开发人员提供了一种熟悉感。</p>
<p>Jotai依赖于它的原子性原则，即每个状态在其核心都可以被定义为一个<code>atom</code>。然后，这些<code>atoms</code>可以被链接和缩放在一起，形成复杂的状态。状态值只有在它的<code>atom</code>依赖关系改变时才会重新呈现。</p>
<p>这些依赖项跟踪器针对生产进行了高度优化。与React不同，你通常不需要使用任何记忆技术，比如<code><a href="https://blog.logrocket.com/react-memo-vs-usememo/">Memo</a></code> <a href="https://blog.logrocket.com/react-memo-vs-usememo/">组件或者</a> <code><a href="https://blog.logrocket.com/react-memo-vs-usememo/">useMemo</a></code> <a href="https://blog.logrocket.com/react-memo-vs-usememo/">钩子</a>。</p>
<p>例如，在下面的例子中，您可以用<code>atom</code> API初始化一个<code>atomCount</code>变量:</p>
<pre class="language-javascript hljs">import { useAtom, atom } from "jotai";

// states can be created using atom API
const atomCount = atom(5)

// pass the above atom variable to the `useAtom` hook to read and 
// mutate its values
const [count, setCount] = useAtom(atomCount)</pre>
<p>我们稍后将使用这种方法，通过一个名为<code>useAtom</code>的钩子来管理状态，这个钩子类似于React的<code>useState</code> API。</p>
<h2 id="performance-bottlenecks-next-js-applications">Next.js应用程序中的性能瓶颈</h2>
<p>使用大规模Next.js应用程序最棘手的部分之一是处理整个应用程序的状态。</p>
<p>React钩子通过<a href="https://blog.logrocket.com/react-context-api-deep-dive-examples/">提供上下文API </a>来处理不能通过<code>useState</code>钩子处理的应用程序范围的状态，从而简化了状态管理。然而，如果您对上下文API不太小心，就很容易遇到性能问题。</p>
<p>例如，在下面的例子中，通过将三个状态值<code>theme</code>、<code>isSignedIn</code>和<code>subscription</code>包装在<code>AppContext</code>提供者中，将它们传递给子组件:</p>
<pre class="language-javascript hljs">&lt;AppContext.Provider value={theme, isSignedIn, subscription}&gt;        
    &lt;Navbar /&gt;
    &lt;Main /&gt;
    &lt;Subscription /&gt;
&lt;/AppContext.Provider&gt;</pre>
<p>在这种情况下，即使单个状态值发生变化，所有三个子组件都会重新呈现自身。在扩展Next.js应用程序时，这种不必要的重新呈现问题会导致巨大的瓶颈。</p>
<p>要解决这个问题，首先，确保你使用的上下文API只处理那些应用程序范围内需要的状态，比如主题、全局语言等等。其次，正如React核心团队所建议的，只在相关的组件之间拆分上下文提供者。</p>
<p>在上面的例子中，<code>subscription</code>状态值与<code>&lt;Navbar /&gt;</code>或<code>&lt;Main /&gt;</code>组件无关。因此，您可以像这样分割上下文提供者:</p>
<pre class="language-javascript hljs">&lt;AppContext.Provider value={ theme, isSignedIn }&gt;        
    &lt;Navbar /&gt;
    &lt;Main /&gt;
&lt;/AppContext.Provider&gt;

&lt;SubscriptionContext.Provider value={ subscription }&gt;        
    &lt;Subscription /&gt;
&lt;/SubscriptionContext.Provider&gt;</pre>
<p>您可以使用的另一个技巧是在将状态值传递给上下文提供者之前用<code>useMemo</code>包装它们，这将进一步消除不必要的重新呈现的机会:</p>
<pre class="language-javascript hljs">const value = React.useMemo(() =&gt; [subscription, setSubscription], [subscription])

&lt;SubscriptionContext.Provider value={subscription}&gt;
    &lt;Subscription /&gt;
&lt;/SubscriptionContext.Provider&gt;</pre>
<p>这种模式将消除不必要的重新渲染问题。然而，在使用上下文API时，你必须非常小心；在处理数百个在大规模代码库中很常见的提供者API时，会有很多出错的地方。</p>
<p>Jotai用上下文API解决了大部分问题，比如手动记忆问题、拆分上下文提供者等等。让我们来探索如何。</p>
<h2 id="using-jotai-next-js">通过Next.js使用Jotai</h2>
<p>Jotai使用其原子原理来避免Next.js应用程序中经常出现的记忆化问题。您在Jotai中声明的所有内容都可以简化为<code>atoms</code>,默认情况下会被记忆，只有在状态改变时才会重新呈现:</p>
<pre class="language-javascript hljs">import { atom, useAtom } from 'jotai'
import { useState } from 'react';

const init = atom('hello world')
function App(){
  return (
    const [search, setSearch] = useAtom(init)
  return (
    &lt;input type="search" value={search} onChange={(e) =&gt; setSearch(e.target.value) } /&gt;
  ))
}</pre>
<p>您可能会注意到它与<code>useState</code>挂钩非常相似，除了<code>atoms</code>是在<code>App</code>组件之外声明的。这使得应用程序中的任何地方都具有更大的灵活性和可读性。</p>
<p>Jotai更进一步，允许你对这些<code>atoms</code>有更多的控制。您可以将<code>atoms</code>声明为只读、只写或只读写，如下所示:</p>
<pre class="language-javascript hljs">// declare your initial atom state value here
const atomCount = atom(5)

// make declared atom to be read-only using `get`
const readOnlyAtom = atom((get) =&gt; get(atomCount) * get(atomCount))

// this is write-only allows you to mutate the initial value using `get` &amp; //`set`

const writeOnlyAtom = atom(null, (get, set, _arg) =&gt; {
  set(atomCount, get(atomCount) - 12)
})

// read-write atoms allows you to both mutate &amp; read atom values
const readwriteAtom = atom(
  (get) =&gt; get(atomCount),
  (get, set, _arg) =&gt; {
    set(atomCount, get(atomCount) - 12)
  }
)

// read values using useAtom() hook
const [count, setCount] = useAtom(atomCount)
const [readAtom, setReadAtom] = useAtom(readOnlyAtom)
const [writeAtom, setWriteAtom] = useAtom(writeOnlyAtom)
const [readwriteonly, setReadWriteOnly] = useAtom(readwriteAtom)</pre>
<p>类似于React的上下文API，你可以用Jotai的提供者API来包装你的组件。将根组件包装在Next.js应用程序的<code>_app.tsx</code>文件中，如下所示:</p>
<pre class="language-javascript hljs">const counterInit = atom(0);

const Counter = () =&gt; {
  const [counter, setCounter] = useAtom(counterInit);
  return (
    &lt;&gt;
      &lt;h2&gt;{counter}&lt;/h2&gt;
      &lt;button onClick={() =&gt; setCounter((value) =&gt; value + 1)}&gt;inc&lt;/button&gt;
    &lt;/&gt;
  );
};

const App = () =&gt; {
  return (
    &lt;&gt;
      &lt;Provider initialValues={[[counterState, 10]]}&gt;
        &lt;Counter /&gt;
      &lt;/Provider&gt;

      &lt;Provider initialValues={[[counterState, 20]]}&gt;
        &lt;Counter /&gt;
      &lt;/Provider&gt;
    &lt;/&gt;
  );
};</pre>
<p>在上面的例子中:</p>
<ul>
<li>有两个子树包裹着<code>&lt;counter /&gt;</code>组件</li>
<li>提供者API将<code>initialValues</code>作为道具</li>
<li>您可以将初始状态作为数组传递给<code>atom</code>状态</li>
<li><code>App</code>组件将呈现<code>&lt;Counter /&gt;</code>组件的两个实例，初始值分别为<code>10</code>和<code>20</code></li>
</ul>
<p>Jotai的Provider API在创建组件集合并将它们封装在一个<code>Provider</code>中以将值传递给每个被封装的组件时非常有用。这些是默认优化的。</p>
<p>您可以为不同的作用域创建多个<code>Provider</code>子树，如下所示:</p>
<pre class="language-javascript hljs">  &lt;Provider initialValues={[languageAtom, initialValue]}&gt;
            &lt;App /&gt;
     &lt;/Provider&gt;

    &lt;Provider initialValues={[themeAtom, initialValue]}&gt;
            &lt;Main /&gt;
    &lt;/Provider&gt;</pre>
<h2 id="hydrating-ssr-pages-next-js-jotai">用Jotai对Next.js中的SSR页面进行补水</h2>
<p>当使用<a href="https://blog.logrocket.com/ssg-vs-ssr-in-next-js/">服务器端呈现(SSR)应用</a>时，尤其是在Next.js的情况下，必须预取Jotai中定义的<code>atoms</code>来生成SSR页面。</p>
<p>不幸的是，服务器端组件不能返回异步的基于承诺的事件。为了生成服务器端页面并预取从服务器发送的值<code>atoms</code>，Jotai公开了一个<code>useHydrateAtoms</code>钩子。</p>
<p>在一个典型的SSR页面中——或者，如果您使用Next.js v13或更新版本，一个使用<a href="https://blog.logrocket.com/react-server-components-nextjs-12/"> React服务器组件</a>的页面——您可以像这样使用<code>useHydrateAtoms</code>钩子:</p>
<pre class="language-javascript hljs">import { atom, useAtom } from 'jotai'
import { useHydrateAtoms } from 'jotai/utils'

const countInit = atom(0)

function CounterApp({ countSentFromServer }){
  useHydrateAtoms([[countInit, countSentFromServer]])
  const [count] = useAtom(countInit)
 
return (
    &lt;&gt;
        // count would be the value of `countSentFromServer`
      &lt;h1&gt; Count : { count } &lt;/h1&gt;
    &lt;/&gt;
  )
}</pre>
<p>在上面的例子中，Next.js将使用Jotai的<code>useHydrateAtoms</code>钩子合并这个页面。最初的计数值<code>0</code>现在将从服务器合并它的值。</p>
<p>一个值得讨论的重要模式是<code>atomWithHash</code> API。在Jotai中，您可以使用<code>atomWithHash</code> API订阅路由器事件的变化，如下所示:</p>
<pre class="language-javascript hljs">import React from 'react';
import { useAtom } from 'jotai';
import { atomWithLocation } from 'jotai-location';

const locationAtom = atomWithLocation();

function HomePage() {
  const [location, setLocation] = useAtom(locationAtom);
  return (
&lt;button onClick={() =&gt; setLoc((prev) =&gt; ({ ...prev, pathname: '/dashboard',
 searchParams: new URLSearchParams([['page', '1']]), }))}&gt;
     Goto Page 1
&lt;/button&gt;
  );
};</pre>
<p><code>atomWithHash</code> API是一个非常简单的API，它订阅路由器事件的变化。您可以将它与Next.js提供的<code>Router.events</code> API进一步配对，这将允许您通过订阅路由器事件中的更改来对服务器呈现的页面进行更多的控制:</p>
<pre class="language-javascript hljs">const pagination = atomWithHash('page', 1, {
  subscribe: (callbackFn) =&gt; {
     // triggers when route change is detected
    Router.events.on('routeChangeComplete', callbackFn)
   // return callback function for memory cleanup 
   return () =&gt; {
      Router.events.off('routeChangeComplete', callbackFn)
    }
  },
})</pre>
<p>在Next.js应用程序中，<code>atomWithHash</code> API可用于订阅路由器事件的变化。</p>
<h2>结论</h2>
<p>与其生态系统相比，Jotai是一个小库，它足够灵活，可以与其他模式和库(如Redux、Immer等)配对。Jotai并不努力取代现有的状态管理解决方案；相反，它可以与其他状态管理器并行工作，也可以与React本身并行工作。</p>
<p>Jotai APIs与React中的API非常相似，因此很容易学习。Jotai通常作为Context API和<code>useState</code>API的替代品而大放异彩，并且不需要任何额外的开销来扩展应用程序，React的Context API就是这种情况。</p><div class="code-block code-block-30">
<div class="blog-plug inline-plug next-plug"><h2><a href="https://lp.logrocket.com/blg/nextjs-signup" target="_blank"> LogRocket </a>:全面了解生产Next.js应用</h2><p>调试下一个应用程序可能会很困难，尤其是当用户遇到难以重现的问题时。如果您对监视和跟踪状态、自动显示JavaScript错误、跟踪缓慢的网络请求和组件加载时间感兴趣，</p><a href="https://lp.logrocket.com/blg/nextjs-signup" target="_blank">try LogRocket</a><p>. </p><a class="signup" href="https://lp.logrocket.com/blg/nextjs-signup" target="_blank" rel="noopener noreferrer"><img class="alignnone size-full wp-image-46 jetpack-lazy-image" src="../Images/f300c244a1a1cf916df8b4cb02bec6c6.png" data-lazy-src="https://files.readme.io/27c94e7-Image_2017-06-05_at_9.46.04_PM.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://files.readme.io/27c94e7-Image_2017-06-05_at_9.46.04_PM.png"/><noscript><img data-lazy-fallback="1" class="alignnone size-full wp-image-46" src="../Images/f300c244a1a1cf916df8b4cb02bec6c6.png" data-original-src="https://files.readme.io/27c94e7-Image_2017-06-05_at_9.46.04_PM.png"/></noscript></a><a class="signup" href="https://lp.logrocket.com/blg/nextjs-signup" target="_blank" rel="noopener noreferrer"><img class="alignnone size-full wp-image-46 jetpack-lazy-image" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/><noscript><img data-lazy-fallback="1" class="alignnone size-full wp-image-46" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/></noscript></a><p>LogRocket 就像是网络和移动应用的DVR，记录下你的Next.js应用上发生的一切。您可以汇总并报告问题发生时应用程序的状态，而不是猜测问题发生的原因。LogRocket还可以监控应用程序的性能，报告客户端CPU负载、客户端内存使用等指标。</p><p>LogRocket Redux中间件包为您的用户会话增加了一层额外的可见性。LogRocket记录Redux存储中的所有操作和状态。</p><p>让您调试Next.js应用的方式现代化— <a class="signup" href="https://lp.logrocket.com/blg/nextjs-signup" target="_blank" rel="noopener noreferrer">开始免费监控</a>。</p></div></div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
<html>
<head>
<title>How to virtualize large lists using react-window - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>如何使用 react-window - LogRocket 博客虚拟化大型列表</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/how-to-virtualize-large-lists-using-react-window/#0001-01-01">https://blog.logrocket.com/how-to-virtualize-large-lists-using-react-window/#0001-01-01</a></blockquote><div><article class="article-post">
<p>在这个由 JavaScript 支持的 web 页面的现代领域，DOM 可能是一个昂贵的抽象。如果没有合适的工具来提高性能，React 应用程序中的一个单独的道具更改就会导致元素不必要的重新渲染。</p>
<p>但是，即使没有 JavaScript 的参与，拥有一个大的 DOM 树也会减慢你的页面速度，破坏你的核心网络活力，给你的网络请求、运行时间和内存性能带来负担。</p>
<h2>DOM 大小的标准</h2>
<p><img data-attachment-id="59446" data-permalink="https://blog.logrocket.com/how-to-virtualize-large-lists-using-react-window/dom-performance-dashboard/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2021/07/dom-performance-dashboard.png" data-orig-size="730,535" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Dom performance dashboard" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2021/07/dom-performance-dashboard-300x220.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2021/07/dom-performance-dashboard.png" decoding="async" class="aligncenter size-full wp-image-59446 jetpack-lazy-image" src="../Images/9c67b4a0cbf72d77e9a130aad5f379a3.png" alt="DOM Dashboard With 76 Performance Rating" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2021/07/dom-performance-dashboard.png 730w, https://blog.logrocket.com/wp-content/uploads/2021/07/dom-performance-dashboard-300x220.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2021/07/dom-performance-dashboard.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2021/07/dom-performance-dashboard.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="59446" data-permalink="https://blog.logrocket.com/how-to-virtualize-large-lists-using-react-window/dom-performance-dashboard/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2021/07/dom-performance-dashboard.png" data-orig-size="730,535" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Dom performance dashboard" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2021/07/dom-performance-dashboard-300x220.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2021/07/dom-performance-dashboard.png" decoding="async" loading="lazy" class="aligncenter size-full wp-image-59446" src="../Images/9c67b4a0cbf72d77e9a130aad5f379a3.png" alt="DOM Dashboard With 76 Performance Rating" srcset="https://blog.logrocket.com/wp-content/uploads/2021/07/dom-performance-dashboard.png 730w, https://blog.logrocket.com/wp-content/uploads/2021/07/dom-performance-dashboard-300x220.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2021/07/dom-performance-dashboard.png"/></noscript>
<p>重要的是要记住，尽管浏览器可以处理更大的 DOM 树，但建议将 DOM 节点总数限制为 1500，DOM 深度限制为 32，单个父元素的 DOM 节点数限制为 60。</p>
<p>通过网络发送一个相当大的 HTML 文件，或者在运行时生成元素，直到超出性能预算，我们最终会得到一个过大的 DOM。</p>
<h2>使用原样、无限滚动和分页作为虚拟化的替代方案</h2>
<p>当显示一大组数据时，有许多方法可以实现可视化。呈现数据集最著名的方式是通过原样、分页或无限滚动。</p>
<p>我们可以这样设想这三个选项:</p>
<p><img data-attachment-id="59453" data-permalink="https://blog.logrocket.com/how-to-virtualize-large-lists-using-react-window/alternatives-virtualization-set-data/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2021/07/alternatives-virtualization-set-data.png" data-orig-size="534,488" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Alternatives virtualization set data" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2021/07/alternatives-virtualization-set-data-300x274.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2021/07/alternatives-virtualization-set-data.png" decoding="async" class="aligncenter size-full wp-image-59453 jetpack-lazy-image" src="../Images/2280eca4b80e2a4c86a61ded8022a3b3.png" alt="Single Column List Compared To Never Ending Column List Compared To New Page List" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2021/07/alternatives-virtualization-set-data.png 534w, https://blog.logrocket.com/wp-content/uploads/2021/07/alternatives-virtualization-set-data-300x274.png 300w" data-lazy-sizes="(max-width: 534px) 100vw, 534px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2021/07/alternatives-virtualization-set-data.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2021/07/alternatives-virtualization-set-data.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="59453" data-permalink="https://blog.logrocket.com/how-to-virtualize-large-lists-using-react-window/alternatives-virtualization-set-data/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2021/07/alternatives-virtualization-set-data.png" data-orig-size="534,488" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Alternatives virtualization set data" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2021/07/alternatives-virtualization-set-data-300x274.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2021/07/alternatives-virtualization-set-data.png" decoding="async" loading="lazy" class="aligncenter size-full wp-image-59453" src="../Images/2280eca4b80e2a4c86a61ded8022a3b3.png" alt="Single Column List Compared To Never Ending Column List Compared To New Page List" srcset="https://blog.logrocket.com/wp-content/uploads/2021/07/alternatives-virtualization-set-data.png 534w, https://blog.logrocket.com/wp-content/uploads/2021/07/alternatives-virtualization-set-data-300x274.png 300w" sizes="(max-width: 534px) 100vw, 534px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2021/07/alternatives-virtualization-set-data.png"/></noscript>
<p>当我们的页面上有连续的内容时，比如多个段落，我们会使用“原样”策略来呈现内容。为了优化我们的页面性能，我们求助于 CSS <code>content-visibility</code>属性。详见<a href="https://blog.logrocket.com/using-css-content-visibility-to-boost-your-rendering-performance/" target="_blank" rel="noopener">这篇博文</a>。</p>
<p>然而，使用<code>content-visibility</code>只会有助于初始渲染。当我们向下滚动页面到浏览器跳过渲染的区域时，我们将再次看到一个缓慢移动的页面。</p>
<p>无限滚动也是如此。不同之处在于，我们只在需要时请求内容。但是，我们最终会遇到同样的性能问题。</p>
<p>另一方面，分页是最具性能的呈现方式。它在初始呈现时只显示必要的内容，根据需要请求内容，并且 DOM 不会因为不必要的内容而膨胀。</p>
<p>但是，分页是一种不适合在网页上显示每个大型数据集的模式。相反，我们可以使用虚拟化。</p>
<h2>什么是虚拟化？</h2>
<p>虚拟化是一个渲染概念，它专注于跟踪用户的位置，并且在任何给定的滚动位置只提交与 DOM 视觉相关的内容。本质上，它为我们提供了分页的所有好处以及无限滚动的 UX。</p>
<p><img data-attachment-id="59466" data-permalink="https://blog.logrocket.com/how-to-virtualize-large-lists-using-react-window/virtualization-list/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2021/07/virtualization-list.png" data-orig-size="507,293" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Virtualization list" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2021/07/virtualization-list-300x173.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2021/07/virtualization-list.png" decoding="async" class="aligncenter size-full wp-image-59466 jetpack-lazy-image" src="../Images/14d80557b2b274c2787f30dac69959bc.png" alt="Rendering And Removing Column List" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2021/07/virtualization-list.png 507w, https://blog.logrocket.com/wp-content/uploads/2021/07/virtualization-list-300x173.png 300w" data-lazy-sizes="(max-width: 507px) 100vw, 507px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2021/07/virtualization-list.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2021/07/virtualization-list.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="59466" data-permalink="https://blog.logrocket.com/how-to-virtualize-large-lists-using-react-window/virtualization-list/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2021/07/virtualization-list.png" data-orig-size="507,293" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Virtualization list" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2021/07/virtualization-list-300x173.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2021/07/virtualization-list.png" decoding="async" loading="lazy" class="aligncenter size-full wp-image-59466" src="../Images/14d80557b2b274c2787f30dac69959bc.png" alt="Rendering And Removing Column List" srcset="https://blog.logrocket.com/wp-content/uploads/2021/07/virtualization-list.png 507w, https://blog.logrocket.com/wp-content/uploads/2021/07/virtualization-list-300x173.png 300w" sizes="(max-width: 507px) 100vw, 507px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2021/07/virtualization-list.png"/></noscript>
<p>为了虚拟化列表，我们使用给定列表项的维度预先计算列表的总高度，并将其乘以列表项的计数。</p>
<p>然后，我们定位项目以创建一个用户可以滚动浏览的列表。正确定位我们的元素是虚拟化效率的关键，因为可以添加或删除单个项目，而不会影响其他项目或导致它们回流(即，重新计算元素在页面上的位置的过程)。</p>
<p>然而，还有另一种方法来呈现数据。</p>
<h2>如何使用<code>react-window</code>虚拟化大型列表</h2>
<p>为了实现虚拟化，我们将使用<code><a href="https://github.com/bvaughn/react-window" target="_blank" rel="noopener">react-windo</a></code>，它是对<code>react-virtualized</code>的重写。你可以在这里阅读两个图书馆<a href="https://blog.logrocket.com/windowing-wars-react-virtualized-vs-react-window/" target="_blank" rel="noopener">的比较</a>。</p>
<p>要安装<code>react-window</code>，请运行以下命令:</p>
<pre>$ yarn add react-window # the library
$ yarn add -D @types/react-window # auto-completion
</pre>
<p><code>react-window</code>将作为依赖项安装，而它的类型将作为<code>devDependency</code>安装，即使我们没有使用 TypeScript。我们还需要<code><a href="https://github.com/marak/Faker.js/" target="_blank" rel="noopener">faker.js</a></code>来生成我们的大型数据集。</p>
<pre>$ yarn add faker
</pre>
<p>在我们的<code>App.js</code>中，我们将导入<code>faker</code>和<code>useState</code>，并用<code>faker</code>的<code>address.city</code>函数初始化我们的<code>data</code>状态。在我们的代码中，它将创建一个<code>length</code>为<code>10000</code>的数组。</p>
<pre>import React, { useState } from "react";
import * as faker from "faker";

const App = () =&gt; {
  const [data, setData] = useState(() =&gt;
    Array.from({ length: 10000 }, faker.address.city)
  );

  return (
    &lt;main&gt;
      &lt;ul style={{ width: "400px", height: "700px", overflowY: "scroll" }}&gt;
        {data.map((city, i) =&gt; (
          &lt;li key={i + city}&gt;{city}&lt;/li&gt;
        ))}
      &lt;/ul&gt;
    &lt;/main&gt;
  );
};
</pre>
<p>接下来，我们使用函数<a href="https://blog.logrocket.com/a-guide-to-usestate-in-react-ecb9952e406c/" target="_blank" rel="noopener">对我们的状态进行惰性初始化，以优化性能</a>。然后，我们给列表一个宽度和高度，并将<code>overflowY</code>设置为<code>scroll</code>，使列表可以滚动。</p>
<p>为了比较虚拟化前后的性能，我们将添加一个<code>reverse</code>按钮来反转我们的<code>data</code>数组。</p>
<pre>const App = () =&gt; {
  const [data, setData] = useState(() =&gt;
    Array.from({ length: 10000 }, faker.address.city)
  );

  const reverse = () =&gt; {
    setData((data) =&gt; data.slice().reverse());
  };

  return (
    &lt;main&gt;
      &lt;button onClick={reverse}&gt;Reverse&lt;/button&gt;
      &lt;ul style={{ width: "400px", height: "700px", overflowY: "scroll" }}&gt;
        {data.map((city, i) =&gt; (
          &lt;li style={{ height: "20px" }} key={i + city}&gt;{city}&lt;/li&gt;
        ))}
      &lt;/ul&gt;
    &lt;/main&gt;
  );
};
</pre>
<p class="codepen" data-height="300" data-default-tab="html,result" data-slug-hash="yLbaPvO" data-user="smhmd">参见<a href="https://codepen.io"> CodePen </a>上 Simohamed ( <a href="https://codepen.io/smhmd"> @smhmd </a> ) <br/>的 React 中的 Pen <a href="https://codepen.io/smhmd/pen/yLbaPvO">)非虚拟化列表。</a></p>
<p/>
<p>现在，尝试反向按钮，并注意更新是如何潜伏。</p>
<p>为了虚拟化这个列表，我们将使用<code>react-window</code>的<code>FixedSizeList</code>。</p>
<pre>import { FixedSizeList as List } from "react-window";

const App = () =&gt; {
  const [data, setData] = useState(() =&gt;
    Array.from({ length: 10000 }, faker.address.city)
  );
  const reverse = () =&gt; {
    setData((data) =&gt; data.slice().reverse());
  };

  return (
    &lt;main&gt;
      &lt;button onClick={reverse}&gt;Reverse&lt;/button&gt;
      &lt;List
        innerElementType="ul"
        itemCount={data.length}
        itemSize={20}
        height={700}
        width={400}
      &gt;
        {({ index, style }) =&gt; {
          return (
            &lt;li style={style}&gt;
              {data[index]}
            &lt;/li&gt;
          );
        }}
      &lt;/List&gt;
    &lt;/main&gt;
  );
};
</pre>
<p>我们可以以多种方式使用<code>FixedSizeList</code>。在这个实例中，我们创建了一个与我们的<code>data</code>(通过<code>itemCount</code>)长度相同的虚拟数组，并用它来索引我们的<code>data</code>。</p><div class="code-block code-block-54">
<hr/>
<h3>更多来自 LogRocket 的精彩文章:</h3>

<hr/></div>
<p>的孩子展示了一个渲染道具，它有每个索引和必要的样式(绝对定位样式等)。)传进去的。</p>
<p>我们也可以显式地传递我们的数据，并通过<code>itemData</code>在渲染道具中接收它，就像这样:</p>
<pre>&lt;List
  itemData={data}
  innerElementType="ul"
  itemCount={data.length}
  itemSize={20}
  height={700}
  width={400}
&gt;
  {({ data, index, style }) =&gt; {
    return &lt;li style={style}&gt;{data[index]}&lt;/li&gt;;
  }}
&lt;/List&gt;
</pre>
<p>注意，我们之前的内联样式现在被替换成了<code>width</code>和<code>height</code>道具。<code>overflowY</code>由<code>layout</code>道具控制，默认为<code>vertical</code>。</p>
<p>将<code>style</code> render prop 参数传递给最外层的元素(在我们的例子中是<code>li</code>)很重要。如果没有它，所有的元素将一个堆叠在另一个之上，没有任何东西可以滚动。</p>
<p><code>FixedSizeList</code>元素呈现两个默认为<code>div</code> s 的包装器元素，可以使用<code>innerElementType</code>和<code>outerElementType</code>进行定制。</p>
<p>在我们的例子中，出于可访问性的原因，我们将<code>innerElementType</code>设置为<code>ul</code>。但是，只能使用预定义的道具。添加<code>role</code>或<code>data-*</code>等道具不会有任何效果。</p>
<p>默认情况下，<code>FixedSizeList</code>将使用数据索引作为反应键。但是因为我们正在修改我们的数据数组，所以我们必须为我们的键使用唯一的值。为此，<code>FixedSizeList</code>公开了<code>itemKey</code>属性，该属性接受一个应该返回字符串或数字的函数。我们将使用<code>faker</code>的<code>datatype.uuid</code>功能。</p>
<pre>&lt;List
  itemKey={faker.datatype.uuid}
  itemData={data}
  innerElementType="ul"
  itemCount={data.length}
  itemSize={20}
  height={700}
  width={400}
&gt;
  {({ data, index, style }) =&gt; {
    return &lt;li style={style}&gt;{data[index]}&lt;/li&gt;;
  }}
&lt;/List&gt;
</pre>
<p class="codepen" data-height="300" data-default-tab="html,result" data-slug-hash="QWvKPdG" data-user="smhmd">参见<a href="https://codepen.io"> CodePen </a>上 Simohamed ( <a href="https://codepen.io/smhmd"> @smhmd </a> ) <br/>的 React 中的 Pen <a href="https://codepen.io/smhmd/pen/QWvKPdG">虚拟化列表。</a></p>
<p/>
<p>正如我提到的，我们可以使用 reverse 按钮即时比较虚拟化列表和非虚拟化列表。但是性能优化并没有就此结束。如果我们有一个昂贵的元素来呈现每个列表项，而不是单个的<code>li</code>，<code>react-window</code>允许我们在滚动时呈现一个简单的 UI。</p>
<p>为此，我们首先需要通过将<code>useIsScrolling</code>传递给我们的<code>FixedSizeList</code>来启用<code>isScrolling</code>布尔值。</p>
<pre>&lt;List
  useIsScrolling={true}
  itemCount={data.length}
  itemSize={20}
  height={700}
  width={400}
&gt;
  {({ index, style, isScrolling }) =&gt;
    isScrolling ? (
      &lt;Skeleton style={style} /&gt;
    ) : (
      &lt;ExpensiveItem index={index} style={style} /&gt;
    )
  }
&lt;/List&gt;;
</pre>
<p>这可能是这样的:</p>
<p><img data-attachment-id="59488" data-permalink="https://blog.logrocket.com/how-to-virtualize-large-lists-using-react-window/scrolling-virtualized-list-react-window/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2021/07/scrolling-virtualized-list-react-window.gif" data-orig-size="730,405" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Scrolling virtualized list react window" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2021/07/scrolling-virtualized-list-react-window-300x166.gif" data-large-file="https://blog.logrocket.com/wp-content/uploads/2021/07/scrolling-virtualized-list-react-window.gif" decoding="async" class="aligncenter wp-image-59488 size-full jetpack-lazy-image" src="../Images/535d3d70eb825549200a715ddd7346dc.png" alt="Delayed Rendering And Removing Data After Scrolling" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2021/07/scrolling-virtualized-list-react-window.gif?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2021/07/scrolling-virtualized-list-react-window.gif"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="59488" data-permalink="https://blog.logrocket.com/how-to-virtualize-large-lists-using-react-window/scrolling-virtualized-list-react-window/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2021/07/scrolling-virtualized-list-react-window.gif" data-orig-size="730,405" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Scrolling virtualized list react window" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2021/07/scrolling-virtualized-list-react-window-300x166.gif" data-large-file="https://blog.logrocket.com/wp-content/uploads/2021/07/scrolling-virtualized-list-react-window.gif" decoding="async" loading="lazy" class="aligncenter wp-image-59488 size-full" src="../Images/535d3d70eb825549200a715ddd7346dc.png" alt="Delayed Rendering And Removing Data After Scrolling" data-original-src="https://blog.logrocket.com/wp-content/uploads/2021/07/scrolling-virtualized-list-react-window.gif"/></noscript>
<p> </p>
<p class="codepen" data-height="300" data-default-tab="html,result" data-slug-hash="zYwoYrq" data-user="smhmd">在<a href="https://codepen.io"> CodePen </a>上看到 Simohamed ( <a href="https://codepen.io/smhmd"> @smhmd </a> ) <br/>的笔<a href="https://codepen.io/smhmd/pen/zYwoYrq">React 窗口滚动</a>。</p>
<p/>
<h2>如何使用<code>react-window</code>虚拟化网格</h2>
<p>现在我们知道了如何虚拟化列表，让我们学习虚拟化网格。这是一个类似的过程，但是不同之处在于，您必须在两个方向上添加数据的数量和维度:垂直方向(列)和水平方向(行)。</p>
<pre>import { FixedSizeGrid as Grid } from "react-window";
import * as faker from "faker";

const COLUMNS = 18;
const ROWS = 30;

const data = Array.from({ length: ROWS }, () =&gt;
  Array.from({ length: COLUMNS }, faker.internet.avatar)
);

function App() {
  return (
    &lt;Grid
      columnCount={COLUMNS}
      rowCount={ROWS}
      columnWidth={50}
      rowHeight={50}
      height={500}
      width={600}
    &gt;
      {({ rowIndex, columnIndex, style }) =&gt; {
        return &lt;img src={data\[rowIndex\][columnIndex]} alt="" /&gt;;
      }}
    &lt;/Grid&gt;
  );
}
</pre>
<p class="codepen" data-height="300" data-default-tab="html,result" data-slug-hash="MWmbPeX" data-user="smhmd">见<a href="https://codepen.io"> CodePen </a>上 Simohamed ( <a href="https://codepen.io/smhmd"> @smhmd </a> ) <br/>的笔<a href="https://codepen.io/smhmd/pen/MWmbPeX"> <br/>反应窗口网格</a>。</p>
<p>很简单，对吧？</p>
<p>结论</p>
<h2>在本文中，我们讨论了 DOM 的性能限制，以及如何使用多种呈现策略优化精益 DOM。我们还讨论了虚拟化如何通过使用<code>react-window</code>高效地显示大型数据集，以满足我们的性能目标。</h2>
<p><a href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener"> LogRocket </a>:全面了解您的生产 React 应用</p><div class="code-block code-block-17">
<div class="blog-plug inline-plug react-plug" vwo-el-id="26283398190">
<h2 vwo-el-id="41600691720">调试 React 应用程序可能很困难，尤其是当用户遇到难以重现的问题时。如果您对监视和跟踪 Redux 状态、自动显示 JavaScript 错误以及跟踪缓慢的网络请求和组件加载时间感兴趣，</h2><p>. </p><a href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" vwo-el-id="19356441070">try LogRocket</a><p>LogRocket 结合了会话回放、产品分析和错误跟踪，使软件团队能够创建理想的 web 和移动产品体验。这对你来说意味着什么？</p><a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="19356441380">
<img class="first-react-image alignnone size-full wp-image-46 jetpack-lazy-image jetpack-lazy-image--handled" src="../Images/f300c244a1a1cf916df8b4cb02bec6c6.png" vwo-el-id="18272717540" data-lazy-loaded="1" data-original-src="https://files.readme.io/27c94e7-Image_2017-06-05_at_9.46.04_PM.png"/>
</a>
<a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="19356441690">
<img class="second-react-image alignnone size-full wp-image-46 jetpack-lazy-image jetpack-lazy-image--handled" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" vwo-el-id="30720362350" data-lazy-loaded="1" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/>
</a>
<p vwo-el-id="28675660440" class="">LogRocket 不是猜测错误发生的原因，也不是要求用户提供截图和日志转储，而是让您回放问题，就像它们发生在您自己的浏览器中一样，以快速了解哪里出错了。</p>
<p>不再有嘈杂的警报。智能错误跟踪允许您对问题进行分类，然后从中学习。获得有影响的用户问题的通知，而不是误报。警报越少，有用的信号越多。</p>
<p>LogRocket Redux 中间件包为您的用户会话增加了一层额外的可见性。LogRocket 记录 Redux 存储中的所有操作和状态。</p>
<p vwo-el-id="28675660750">现代化您调试 React 应用的方式— <a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="40093418840">开始免费监控</a>。</p>
<p vwo-el-id="28675661060">Modernize how you debug your React apps —
<a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="40093418840">start monitoring for free</a>.
</p>
</div></div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
<html>
<head>
<title>Sharing content in Flutter apps using Share Plus - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>使用 Share Plus - LogRocket 博客在 Flutter 应用程序中共享内容</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/sharing-content-flutter-apps-share-plus/#0001-01-01">https://blog.logrocket.com/sharing-content-flutter-apps-share-plus/#0001-01-01</a></blockquote><div><article class="article-post">
<p>如果你是一个狂热的智能手机用户，很可能你在移动应用程序上看到了一些东西，你想与朋友分享，例如，在浏览你最喜欢的社交媒体平台或探索待售商品时。</p>
<p>让您的用户能够将您的应用程序中的内容共享给其他应用程序，可以改善整体用户体验。在本文中，您将学习如何使用<a href="https://pub.dev/packages/share_plus"> Share Plus 插件</a>在 Flutter 应用程序中实现内容共享。要继续阅读本文，您可以查看示例应用程序的<a href="https://github.com/Blazebrain/flutter_share">完整源代码</a>。我们开始吧！</p>
<h3>目录</h3>

<h2 id="sharing-files-text-images-between-apps">在应用程序之间共享文件、文本和图像</h2>
<p>在本教程中，我们将介绍如何将示例应用程序中的文本和图像共享给其他移动应用程序。我们将从<a href="https://www.fishwatch.gov/developers"> FishWatch API </a>获取一个鱼类物种列表，将其显示在我们的应用程序中，然后添加共享功能，使我们能够与任何其他应用程序共享每个鱼类物种的图像、名称、栖息地和配额等信息。让我们开始吧！</p>
<h2 id="file-sharing-sample-walkthrough">操作中的文件共享:示例应用程序演练</h2>
<h3 id="project-setup">项目设置</h3>
<p>通过运行以下命令创建新的代码库:</p>
<pre>flutter create flutter_share
</pre>
<p>上面的命令将创建基本文件，我们将基于这些文件构建我们的示例应用程序。接下来，我们将在<code>pubspec.yaml</code>文件中导入以下依赖项:</p>
<ul>
<li><a href="https://pub.dev/packages/http"> <code>http</code> </a>:向 FishWatch API 发出<code>GET</code>请求，检索各种鱼类的列表</li>
<li><a href="https://pub.dev/packages/stacked"> <code>stacked</code> </a>:一个架构解决方案，它使用<a href="https://blog.logrocket.com/provider-vs-riverpod-comparing-state-managers-in-flutter">提供者</a>在引擎盖下，让我们能够访问将会增加我们开发过程趣味的类</li>
<li><code><a href="https://pub.dev/packages/build_runner">build_runner</a></code>:提供从注释自动生成文件的运行命令</li>
<li><a href="https://pub.dev/packages/stacked_generator"> <code>stacked_generator</code> </a>:从堆叠标注生成文件</li>
<li><a href="https://pub.dev/packages/logger"> <code>logger</code> </a>:打印重要信息到调试控制台</li>
<li><a href="https://pub.dev/packages/share_plus"> <code>share_plus</code> </a>:我们将用来实现共享功能的包</li>
<li><a href="https://pub.dev/packages/permission_handler"> <code>permission_handler</code> </a>:允许我们请求使用手机的移动存储空间</li>
<li><a href="https://pub.dev/packages/image_downloader"> <code>image_downloader</code> </a>:使我们能够下载我们想要共享的图像文件</li>
</ul>
<pre>dependencies:
      cupertinoicons: ^1.0.2
      flutter:
        sdk: flutter
      http: ^0.13.4
      imagedownloader: ^0.31.0
      logger: ^1.1.0
      permissionhandler: ^8.3.0
      shareplus: ^3.0.4
      stacked: ^2.2.8
    devdependencies:
      buildrunner: ^2.1.7
      flutterlints: ^1.0.0
      fluttertest:
        sdk: flutter
      stacked_generator: ^0.5.7</pre>
<h2 id="setting-up-models">建立模型</h2>
<p>接下来，我们将建立模型来转换我们收到的数据。从 FishWatch API 文档中，我们看到该 API 返回名称、描述、图像和许多其他细节。但是，我们只需要名称、图像、蛋白质含量和配额。</p>
<p>在<code>lib</code>目录中创建一个名为<code>models</code>的文件夹，它将保存我们将使用的所有模型。创建一个名为<code>fish_response_model.dart</code>的文件，我们将在其中创建<code>FishResponseModel</code>类和<code>ImageGallery</code>模型类:</p>
<pre>class FishResponseModel {
  String? speciesName;
  String? protein;
  ImageGallery? speciesIllustrationPhoto;
  String? quote;
  FishResponseModel({
    required this.protein,
    required this.speciesIllustrationPhoto,
    required this.quote,
  });
  FishResponseModel.fromJson(Map&lt;String, dynamic&gt; json) {
    speciesName = json['Species Name'];
    protein = json['Protein'];
    quote = json['Quote'];
    speciesIllustrationPhoto =
        ImageGallery.fromJson(json['Species Illustration Photo']);
  }
}
class ImageGallery {
  String? src;
  String? alt;
  String? title;
  ImageGallery({this.src, this.alt, this.title});
  ImageGallery.fromJson(Map&lt;String, dynamic&gt; json) {
    src = json['src'];
    alt = json['alt'];
    title = json['title'];
  }
}
</pre>
<p>完成这些后，我们可以继续注册我们将在应用程序中使用的依赖项。</p>
<h2 id="registering-dependencies">注册依赖关系</h2>
<p>我们将把在应用程序中执行任务的服务注册为依赖项。我们将在本节中创建每个服务的基本结构，然后在后续的小节中充实它们。</p>
<p>在<code>lib</code>目录中创建一个名为<code>services</code>的文件夹，它将保存我们将在应用程序中使用的服务。<code>ApiService</code>处理来自应用程序的所有出站连接。创建一个名为<code>api_service.dart</code>的新文件。现在，我们将只添加基本结构:</p>
<pre>class ApiService {}
</pre>
<p><code>FishSpeciesService</code>服务类将处理与 FishWatch API 的交互。它将获取鱼类物种的列表，并将其传递到应用程序中。创建一个名为<code>fish_service.dart</code>的新文件，并将基本的类结构放在那里:</p>
<pre>class FishSpecieService {}
</pre>
<p>服务类将处理共享功能，使其在应用程序的任何部分都可以重用。对于其他服务，创建一个名为<code>share_service.dart</code>的新文件并放置基本的类结构，如下所示:</p>
<pre>class ShareService{}
</pre>
<p>接下来，我们将设置路线并注册服务。我们将使用来自<a href="https://pub.dev/packages/stacked">堆栈包</a>的<code>@StackedApp</code>注释。<code>@StackedApp</code>注释允许我们访问两个参数，路由和依赖关系。我们将使用依赖块来注册我们的服务。</p>
<p>在<code>lib</code>目录中创建一个名为<code>app</code>的文件夹，它将保存我们应用程序的所有配置细节。在这个文件夹中，创建一个名为<code>app.dart</code>的新文件。创建一个空类并用<code>@StackedApp</code>注释标记它。同样将<code>StackedLogger</code>传递给<code>logger</code>参数。接下来，在依赖块中将服务注册为<code>LazySingleton</code>:</p>
<pre>import 'package:flutter_share/services/api_service.dart';
import 'package:flutter_share/services/fish_species_service.dart';
import 'package:flutter_share/services/share_service.dart';
import 'package:stacked/stacked_annotations.dart';
@StackedApp(
  dependencies: [
    LazySingleton(classType: ApiService),
    LazySingleton(classType: FishSpecieService),
    LazySingleton(classType: ShareService)
  ],
  logger: StackedLogger(),
)
class AppSetup {}
</pre>
<p>现在，我们可以继续运行 Flutter 命令来生成安装配置所需的所有文件:</p>
<pre>flutter pub run build_runner build --delete-conflicting-outputs
</pre>
<h2 id="setting-up-services">设置服务</h2>
<p>现在我们已经注册了每个依赖项，我们可以继续从<code>ApiService</code>开始填充它们。该服务将处理来自我们应用程序的所有出站 HTTP 请求。它将为每种请求类型提供方法，<code>GET</code>、<code>POST</code>、<code>PUT</code>、<code>PATCH</code>和<code>DELETE</code>。然而，对于本文，我们将使用一个<code>GET</code>请求来调用<a href="https://www.fishwatch.gov/developers"> FishWatch API </a>端点。</p>
<p>将 HTTP 包作为<code>http</code>导入。在<code>ApiService</code>类中，创建一个新函数，它将接受一个 URL，我们将请求指向该 URL。使用 HTTP 包调用 URL，然后检查<code>statusCode</code>是否为<code>200</code>。如果是真的，我们会归还<code>decodedResponse</code>。</p>
<p>此外，我们用一个<code>try...catch</code>块包装整个调用，以便捕捉任何可能抛出的异常。这基本上是我们的<code>ApiService</code>文件中的所有内容:</p>
<pre>import 'dart:async';
import 'dart:convert';
import 'dart:io';
import 'package:http/http.dart' as http;
class ApiService {
  Future&lt;dynamic&gt; get(url) async {
    try {
      final response = await http.get(url);
      if (response.statusCode == 200) {
        return json.decode(response.body);
      }
    } on SocketException {
      rethrow;
    } on Exception catch (e) {
      throw Exception(e);
    }
  }
}
</pre>
<p>接下来，我们创建一个类来处理与 API 调用相关的常量，它将保存方案、主机 URL、URIs 等内容。在<code>lib</code>目录下，创建一个名为<code>utils</code>的新文件夹和一个名为<code>api_constants.dart</code>的新文件:</p>
<pre>class ApiConstants {
  static const scheme = 'https';
  static const baseUrl = 'fishwatch.gov';
  static const path = 'api/species';
  static get getFishSpecies =&gt; Uri(
        scheme: scheme,
        host: baseUrl,
        path: path,
      );
}
</pre>
<p>之后，<code>FishSpecieService</code>调用远程 API，获取数据并使用我们之前创建的模型解析数据:</p>
<pre>import 'package:flutter_share/models/fish_response_model.dart';
import 'package:flutter_share/app/app.locator.dart';
import 'package:flutter_share/services/api_service.dart';
import 'package:flutter_share/utils/api_constants.dart';
class FishSpecieService {
  final _apiService = locator&lt;ApiService&gt;();
  Future&lt;List&lt;FishResponseModel?&gt;?&gt; getFishSpecie() async {
    List&lt;FishResponseModel?&gt; fishSpeciesList = [];
    try {
      final response = await _apiService.get(ApiConstants.getFishSpecies);
      if (response != null) {
        for (var i = 0; i &lt; 15; i++) {
          final model = FishResponseModel.fromJson(response[i]);
          fishSpeciesList.add(model);
        }
        return fishSpeciesList;
      }
    } catch (e) {
      rethrow;
    }
  }
}
</pre>
<p>最后，我们创建了<code>ShareService</code>，它将公开一个方法来共享来自我们名为<code>onShare</code>的应用程序的数据。它将从要共享的列表中获取特定<code>fishSpecie</code>的模型。</p>
<p>首先，我们使用<a href="https://pub.dev/packages/permission_handler"> permission_handler </a>包来请求<code>PermissionStatus</code>存储权限。我们需要本地存储来保存我们想要共享的图像。我们下载图像，然后分享实际的图像，而不是图像的链接。</p>
<p>除此之外，在<code>AndroidManifest.xml</code>中，添加写入外部存储器的权限，即将图像下载到应用程序本地存储器:</p>
<pre>&lt;manifest xmlns:android="http://schemas.android.com/apk/res/android"
    package="com.example.flutter_share"&gt;
    &lt;uses-permission android:name="android.permission.INTERNET" /&gt;
    &lt;uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE"/&gt;
    ....
    &lt;/manifest&gt;
</pre>
<p>接下来，我们检查状态是否被拒绝。如果是，我们请求许可。</p>
<p>因为我们想要共享一个图像文件，并且我们正在从 FishWatch API 接收到每种鱼的图像链接，所以我们将使用<code>ImageDownloader</code>包下载图像。我们将对它调用<code>downloadImage</code>方法，并从我们的模型传入图像 URL。我们将响应分配给一个变量<code>imageId</code>，它将是下载图像的<code>imageId</code>。</p>
<p>接下来，我们检查<code>imageId</code>是否为空。如果是，我们返回并中断该函数。在确认了<code>imageId</code>不为空之后，我们使用来自<code>ImageDownloader</code>的<code>findPath</code>方法来获取保存在本地存储器上的图像的路径。这将是移动设备上实际图像文件的路径。</p>
<p>最后，我们从<code>share_plus</code>包中调用<code>shareFiles</code>对象，并将路径传递给<code>imageId</code>，以及作为主题的报价和显示物种名称和蛋白质含量的文本:</p>
<pre>import 'package:flutter_share/models/fish_response_model.dart';
import 'package:image_downloader/image_downloader.dart';
import 'package:permission_handler/permission_handler.dart';
import 'package:share_plus/share_plus.dart';
class ShareService {
  Future&lt;void&gt; onShare(FishResponseModel fishSpecie) async {
    var status = await Permission.storage.status;
    if (status.isDenied) {
      await Permission.storage.request();
    }
    var imageId = await ImageDownloader.downloadImage(
        fishSpecie.speciesIllustrationPhoto!.src!);
    if (imageId == null) {
      return;
    }
    var path = await ImageDownloader.findPath(imageId);
    await Share.shareFiles(
      [path!],
      text: '''Specie Name: ${fishSpecie.speciesName}\n'''
          '''Protein Content: ${fishSpecie.protein}\n''',
      subject: fishSpecie.quote,
    );
  }
}
</pre>
<p>至此，我们完成了对<code>ShareService</code>的设置。我们可以使用这个服务在应用程序的任何地方实现共享功能。</p>
<p>接下来，转到<code>main.dart</code>文件。在主块中，我们将调用<code>WidgetsFlutterBinding.ensureInitialized()</code>，然后调用<code>setUpLocator</code>函数，该函数将设置定位器，使所有注册的依赖项在整个应用程序中都可用:</p>
<pre>import 'package:flutter/material.dart';
import 'package:flutter_share/app/app.locator.dart';
import 'package:flutter_share/ui/views/home/home_view.dart';
void main() {
  WidgetsFlutterBinding.ensureInitialized();
  setupLocator();
  runApp(const MyApp());
}
class MyApp extends StatelessWidget {
  const MyApp({Key? key}) : super(key: key);
  @override
  Widget build(BuildContext context) {
    return const MaterialApp(
      title: 'Material App',
      home: HomeView(),
    );
  }
}
</pre>
<p>在这个阶段，我们已经成功地为共享功能奠定了基础。现在，我们可以继续构建用户界面，并最终使用该服务。</p>
<h2 id="implementing-share-functionality">实现共享功能</h2>
<p>在<code>lib</code>目录中创建一个名为<code>ui</code>的新文件夹，它将包含应用程序中的用户界面。我们只会有一个，<code>home_view</code>。创建一个名为<code>home_view</code>的新文件夹，我们将在其中存储两个文件<code>home_view.dart</code>和<code>home_viewmodel.dart</code>，它们将分别保存 UI 代码和 UI 逻辑。</p>
<p>在<code>home_viewmodel.dart</code>文件中，创建一个名为<code>HomeViewModel</code>的类。它将有两个功能，一个是使用<code>FishSpecieService</code>从 API 调用<code>getFishSpecie</code>，另一个是共享选中的<code>fishSpecie</code>。</p>
<p>我们将使用定位器访问各自的服务，然后使用服务获取各自的数据:</p>
<pre>import 'package:flutter/material.dart';
import 'package:flutter_share/app/app.locator.dart';
import 'package:flutter_share/models/fish_response_model.dart';
import 'package:flutter_share/services/fish_species_service.dart';
import 'package:flutter_share/services/share_service.dart';
import 'package:stacked/stacked.dart';

class HomeViewModel extends BaseViewModel {
  final _fishSpecieService = locator&lt;FishSpecieService&gt;();
  final _shareService = locator&lt;ShareService&gt;();
  List&lt;FishResponseModel?&gt;? fishSpeciesList = [];

  Future&lt;void&gt; getFishSpecies() async {
    try {
      fishSpeciesList = await runBusyFuture(
        _fishSpecieService.getFishSpecie(),
        throwException: true,
      );
      notifyListeners();
    } on Exception catch (e) {
      debugPrint(e.toString());
    }
  }

  Future&lt;void&gt; shareFishSeries(FishResponseModel fishSeries) async {
    try {
      await _shareService.onShare(fishSeries);
    } on Exception catch (e) {
      debugPrint(e.toString());
    }
  }

}
</pre>
<h2 id="building-user-interface">构建用户界面</h2>
<p>最后，在<code>home_view.dart</code>文件中，创建一个无状态小部件，这将是这个视图的基础。<code>HomeView</code>将显示在<code>HomeViewModel</code>中获取并存储到<code>fishesSpeciesList</code>中的鱼类种类列表。</p>
<p><code>HomeView</code>最重要的部分是共享按钮，我们将用它来触发共享功能。它将简单地调用<code>HomeViewModel</code>中的<code>shareFishSeries</code>函数，并向其传递所选种类的<code>fishSpecieModel</code>:</p>
<pre>   Row(
              mainAxisAlignment: MainAxisAlignment.end,
              children: [
                const Icon(Icons.share, size: 18),
                const SizedBox(width: 8),
                GestureDetector(
                  onTap: () {
                    homeViewModel!.shareFishSeries(fishSpecieModel!);
                  },
                  child: const Text(
                    'Share',
                    style: TextStyle(
                      fontSize: 16,
                      fontWeight: FontWeight.w500,
                    ),
                  ),
                )
              ],
            )
</pre>
<p>查看我们的<a href="https://gist.github.com/Blazebrain/4ebc9c3bdc7924b514565cb04e08e224"> <code>HomeView</code>的完整代码，在此要诀</a>。</p>
<p>有了这个，我们的示例应用程序就可以运行了！让我们构建并运行应用程序，看看这一切是如何实现的:</p>
<p><span class="embed-youtube"> <iframe loading="lazy" class="youtube-player" src="https://www.youtube.com/embed/dohGK3KzYAU?version=3&amp;rel=1&amp;showsearch=0&amp;showinfo=1&amp;iv_load_policy=1&amp;fs=1&amp;hl=en-US&amp;autohide=2&amp;wmode=transparent" allowfullscreen="true" sandbox="allow-scripts allow-same-origin allow-popups allow-presentation">视频</iframe> </span></p>
<p><a href="https://youtu.be/dohGK3KzYAU">https://youtu.be/dohGK3KzYAU</a></p>
<h2 id="conclusion">结论</h2>
<p>在本教程中，我们已经成功地从一个 API 中提取数据，然后与手机上的其他应用程序共享该数据的详细信息。现在，您可以与其他应用程序共享应用程序中的图像和文本。您还可以随意在这个应用程序上构建更多内容，并根据自己的需要对其进行定制。</p>
<p>我希望你喜欢这个教程！快乐编码。如果你有任何问题，欢迎在 Twitter <a href="https://www.twitter.com/Blazebrain01"> @Blazebrain </a>或<a href="https://www.linkedin.com/in/david-adegoke"> LinkedIn </a>上留言或联系我。</p>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
<html>
<head>
<title>Introduction to using Dart in Flutter - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>在 Flutter - LogRocket 博客中使用 Dart 的介绍</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/introduction-to-using-dart-in-flutter/#0001-01-01">https://blog.logrocket.com/introduction-to-using-dart-in-flutter/#0001-01-01</a></blockquote><div><article class="article-post">
<p>当涉及到跨平台开发时，Flutter 是快速发展的技术之一，制作 Flutter 应用程序背后的秘密武器是 Dart 语言。</p>
<p>虽然即使你不熟悉 Dart，你也可以开始开发一个 Flutter 应用程序，但是本教程将会涵盖你需要知道的基本语法和信息，以便你能够轻松地构建一个 Flutter 应用程序。</p>
<h2>Dart 是什么？</h2>
<p>Dart 是一种通用的客户端优化语言，用于在任何网络或移动平台上快速开发应用程序，可以在桌面和嵌入式设备上使用。Dart 语言的核心目标是为您提供一套工具和一种编程语言，使您富有成效，并随着开发人员的要求和需求的增长而发展。</p>
<p>Dart 是一种综合性语言，提供了优秀的语言能力，如<a href="https://dart.dev/" target="_blank" rel="noopener">未来、流、声音空安全等</a>。</p>
<p>Dart 旨在为大多数具有不同编程背景的开发人员所熟悉。因此，无论你是否有 JavaScript 和 TypeScript 的背景，或者你是否曾经是面向对象的程序员，你都会发现使用 Dart 很熟悉。</p>
<p>而且，由于 Dart 的架构，杀手级特性、热重载和声明式编程在 Flutter 中都是可能的。</p>
<p>更重要的是，Dart 还自带了很多内置库，比如 dart:async、dart:convert、dart:html、dart:io 等。，以及一个奇妙的生态系统和杰出的包管理器<a href="https://pub.dev" target="_blank" rel="noopener"> pub.dev </a>。</p>
<p>无论您是否想使用 Flutter，Dart 都是您在下一个应用程序中学习和使用的好选择。</p>
<p>如果你想快速尝试一下，你可以在线使用<a href="https://dartpad.dev/?null_safety=true" target="_blank" rel="noopener"> dartpad.dev </a>。</p>
<h2>如何使用 Dart</h2>
<p>在开始创建 Flutter 应用程序之前，您应该了解一些 Dart 概念:</p>
<h3>1.Main()函数:</h3>
<p>每个 app 的入口都是<em/><code>main()</code>功能。就算要在控制台打印东西，也要有一个<code>main()</code>部件。</p>
<pre>void main() {
  var list = ['apples', 'bananas', 'oranges'];
  list.forEach((item) {
    print('${list.indexOf(item)}: $item');
  });
}</pre>
<p>在 Flutter 中，你将从<code>PROJECT_ROOT/lib/main.dart</code>中的<code>main()</code>函数启动你的应用程序，在这里你将主窗口部件传递给<code>runApp()</code>，它将把它附加到屏幕上。那是第一个主要入口。</p>
<pre>void main() {
  runApp(MyApp());
}
</pre>
<h3>2.<code>:</code>(分号):</h3>
<p>在 Dart 中您需要<code>;</code>(分号)，正如您在上面的例子中看到的:</p>
<pre>runApp(MyApp());
</pre>
<h3>3.类型和空安全</h3>
<p>Dart 是一种类型安全的语言。它使用静态类型检查和运行时检查。当你学会了语法，你就能更快地理解 Flutter 代码。下面是对一个简单变量的剖析:</p>
<p>[修饰符][类型][变量名称]=[值]；</p>
<pre>// e.g: 
final String name = "Majid Hajian";
</pre>
<p>尽管类型是必需的，但由于类型推断，类型注释是可选的。所以，你可能会遇到这种情况:</p>
<pre>var name = "Majid Hajian"; // from now on `name` is a String;
</pre>
<p>Dart 中最常见的初始化变量修饰符是<code>var</code>、<code>final</code>、<code>const</code>和<code>late</code>，但是请记住，当在变量名前使用 type 时，可以使用除<code>var</code>之外的所有修饰符。</p>
<pre>var name = "Majid Hajian";
String name = "Majid Hajian";
final String name = "Majid Hajian";
const String name = "Majid Hajian";
</pre>
<p>使用<code>var</code>或不使用修饰符创建一个灵活的变量，这意味着你可以随时改变值。如果你不打算修改变量，你应该使用<code>final</code>，它只设置变量一次，或者使用<code>const</code>，它形成一个编译时常量。</p>
<p>但是还有更复杂的情况。我们来看看<code>Map</code>和<code>List</code>的类型定义:</p>
<pre>// Type of a List (Array): List&lt;TYPE_OF_MEMBER&gt;
// e.g: 
List&lt;String&gt; names = ['Majid', 'Hajian'];

// Type of a Map (Key-Values): Map&lt;Key_TYPE, VALUE_TYPE&gt;
// e.g: 
Map&lt;String, number&gt; ages = {'sara': 35, 'susan: 20};
</pre>
<p>在许多情况下，您可能没有向 Dart 分析器提供足够的信息，并且您可能会面临类型转换错误。让我们看一个例子:</p>
<pre>var names = [];
</pre>
<p>变量类型推断<code>List&lt;dynamic&gt;</code>和<code>dynamic</code>可以是任何类型，因为我们在初始化变量时没有提供数组的可能类型。因此，Dart 将类型转换为<code>List&lt;dynamic&gt;</code>，在那里它可以是任何东西。通过在初始化或启动变量时向值添加注释，我们可以防止这种类型的错误。</p>
<pre>final names = &lt;String&gt;[];
// Or
final List&lt;String&gt; names = [];
</pre>
<p>从 Dart 2.12 开始，Dart 是一种健全的空安全语言，这意味着代码中的类型在默认情况下是不可空的，这表明一个变量不能包含<code>null</code>，除非你允许它们包含。</p>
<pre>final String name = null;
// or
final String name; 
</pre>
<p>注意，上面的变量不再有效，因为我们用一个<code>null</code>值初始化了一个变量。因为我们还没有指定这一点，所以运行时 null-dereference 错误变成了编辑时分析错误。</p>
<p>这就是<code>?</code>派上用场的时候了。为了给变量赋值<code>null</code>,我们可以在类型声明中使用<code>?</code>。</p>
<pre>final String? name = null;
</pre>
<p>你会在 Flutter 2.0.0+和 Dart 2.12.0+中经常看到这种语法。</p>
<p>最后，在 Flutter 应用程序中，Dart 中最常见的内置类型如下:</p>
<ul>
<li>数字(int，double)</li>
<li>字符串(字符串)</li>
<li>Booleans (bool)</li>
<li>列表(List，也称为<em>数组</em></li>
<li>集合(集合)</li>
<li>地图(地图)</li>
<li>符号(符号)</li>
<li>值 null(空值)</li>
</ul>
<h3>4.班级</h3>
<p>Dart 是一种面向对象的语言，具有类和混合基本继承。这意味着你可以创建<code>abstract</code>类型、<code>class</code>，使用<code>implement</code>和<code>extends</code>。你也可以看到<code>with</code>，在那里你想要使用混音。</p>
<p>在 Dart 类中，<code>constructor</code>的名称与<code>className</code>相同，如下所示:</p>
<pre>class MyApp {
  MyApp(); // constructor
}
</pre>
<p>如果不需要初始化实例变量或创建对象，就不需要构造函数。如果需要的话，应该通过构造函数参数传递它们。</p><div class="code-block code-block-54">
<hr/>
<h3>更多来自 LogRocket 的精彩文章:</h3>

<hr/></div>
<pre>class MyApp {
MyApp(this.title);

final String? title;
}
</pre>
<p>在 Dart 2 中，你也不需要使用<code>new</code>关键字来实例化一个类。</p>
<pre>final myapp = MyApp('Majid Hajian');
print(myapp.title);
</pre>
<p>Flutter 中的所有 widgets 都是<code>StatelessWidget</code>或<code>StatefulWidget</code>的扩展类。因此，您可以创建您的小部件(类):</p>
<pre>class MyApp extends StatelessWidget {

}
</pre>
<p>与<code>StatefulWidget</code>对应的<code>StatelessWidget</code>和<code>State</code>对象都有<code>build()</code>方法来构建你的屏幕。因此，要实现要构建的小部件，必须@ override build()方法。</p>
<pre>class MyApp extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return Container();
  }
}

class MyApp extends StatefulWidget {
  @override
  _MyAppState createState() =&gt; _MyAppState();
}

class _MyAppState extends State&lt;MyApp&gt; {
  @override
  Widget build(BuildContext context) {
    return Container();
  }
}
</pre>
<p>惯例是以一个大写字母开始。</p>
<h3>5.镖中的参数</h3>
<p>无论是在类中还是在函数中，学习如何定义参数都是非常必要的，因为这是颤振开发的关键部分之一。</p>

<p>在 Dart 中，如果您想要定义一个必需的参数，您可以将它们传递给构造函数或函数。</p>
<pre>String getUrl(String prefix, String host) {
  return '';
}
// OR 
class MyApp {
  MyApp(this.title);

  final String? title;
}
</pre>
<p>在这两种情况下，您都需要将参数正确地传递到预期的位置。这就是我们所说的位置参数。</p>

<p>在许多情况下，您会发现您想要使一个参数可选。例如，要更改上面的代码，我们可以这样编码:</p>
<pre>String getUrl({String? prefix, String? host}) {
  return '';
}
// OR
class MyApp {
  MyApp({this.title});

  final String? title;
}
</pre>
<p>我们使用<code>{}</code>来定义我们的可选参数，这些参数如我们所描述的那样命名。现在，要使用命名参数，请使用参数的名称并赋值。</p>
<pre>getUrl( host: '', prefix: '');
//Or 
MyApp(title: 'Majid');
</pre>
<p>正如您所看到的，使用这种方法的主要优点是您不需要将值传递到参数的确切位置。</p>
<p>更重要的是，您的函数和类参数是自文档化的。换句话说，您可以简单地定义 param 的名称并传递值。当您希望为一个方法或类指定多个参数时，定义名称参数很有帮助。</p>
<p>你会经常在 Flutter 中遇到命名参数。下面是 Flutter 中的<code>Text</code>小部件的一个例子:</p>
<pre>Text(
    this.data, {
    Key key,
    this.style,
    this.strutStyle,
    this.textAlign,
    this.textDirection,
    this.locale,
    this.softWrap,
    this.overflow,
    this.textScaleFactor,
    this.maxLines,
    this.semanticsLabel,
    this.textWidthBasis,
    this.textHeightBehavior,
})
</pre>
<p><code>this.data</code>是位置的，这意味着第一个参数是必须传入的，但是其余的参数是可选的，因为它们是在<code>{}</code>中定义的。</p>
<p>你可能不会问为什么一个命名参数是必需的而不是可选的。在 Dart 2.12+中，现在有了<code>required</code>关键字，使得参数成为必须传入的。让我们看看上面的例子。</p>
<pre>class MyApp {
  MyApp({this.title}); // optional named parameter
  final String? title;
}
</pre>
<p>但是如果你在参数前使用了<code>required</code>关键字，我们将强制传递它，即使它是一个命名参数。</p>
<pre>class MyApp {
  MyApp({required this.title});

  final String? title;
}
</pre>
<p>如果你现在实例化<code>MyApp()</code>类，你也必须传递<code>title</code>；否则，编译器将抛出错误。</p>
<pre>print(MyApp(title: 'Majid'));
</pre>
<h3>6.省道格式</h3>
<p>Dart 附带了一个格式化工具，有助于提高代码的可读性。这里有一个技巧可以帮助你更好地格式化你的代码，特别是在 Flutter 中，你会有很多嵌套的小部件。能用的地方就用<code>,</code>！</p>
<pre> Column(
  mainAxisAlignment: MainAxisAlignment.center,
  children: &lt;Widget&gt;[
    Text('You have pushed the button this many times:'),
    Text('$_counter', style: Theme.of(context).textTheme.headline4),
  ],
),
</pre>
<p>这里有一个<code>Column</code>小部件，它有两个<code>Text</code>子部件。没有一个孩子在传递争论时使用<code>,</code>。文本很窄，不容易阅读，但是如果您在每个<code>Text</code>小部件的最后一个参数的末尾使用<code>,</code>，它将被格式化并且更加友好。</p>
<pre>Column(
  mainAxisAlignment: MainAxisAlignment.center,
  children: &lt;Widget&gt;[
    Text(
      'You have pushed the button this many times:',
    ),
    Text(
      '$_counter',
      style: Theme.of(context).textTheme.headline4,
    ),
  ],
),
</pre>
<p>你可以通过命令行中的格式工具或者你选择的编辑器以及 Dart 插件免费获得现成的格式。</p>
<h3>7.功能</h3>
<p>你可以在一个类中定义一个函数，也就是方法，或者在顶层定义一个函数。创建一个像下面的语法一样简单的函数。</p>
<pre>// top-level
getMyname() {
// logic
}

// OR 

class MyClass() {

  getMyName() { 
  }
}
</pre>
<h3>7.异步/等待</h3>
<p>Dart 通过 Future 或 Stream 提供异步编程。要定义一个<code>Future</code>，可以使用<code>async</code>关键字。</p>
<pre>Future&lt;String&gt; getUrl({String? prefix, String? host}) async {
  return 'd';
}
</pre>
<p>并且要等到值被解析，可以使用<code>await</code>关键字。</p>
<pre>main() async {  
  final url = await getUrl(prefix: '', host: '');
}
</pre>
<p>您应该使用包装在带有<code>async</code>关键字的函数/方法中的<code>await</code>关键字。</p>
<p>要创建一个<code>Stream</code>，您将使用<code>async*</code>关键字。现在，您可以订阅流，并在每次发出流时获取值，直到您取消此订阅。</p>
<pre> getUrl(prefix: '', host: '').listen(
    (String value) {
      print(value);
    },
  );
</pre>
<p>注意，<code>listen()</code>函数接受一个函数，即回调函数，因为在 Dart 中一切都是对象，所以即使在函数中也可以传递它们。这通常用于事件发生时的颤振，例如<code>onPressed</code>。</p>
<pre>TextButton(
      onPressed: () {
        // pressed
        // logic
      },
      child: Text('Submit'),
)
</pre>
<h2>了解 Flutter 小部件树</h2>
<p>现在，您应该能够阅读、理解和编写 Flutter 代码。为了证明这一点，让我们举个例子:</p>
<pre>class MyCustomWidget extends StatelessWidget {
  MyCustomWidget({this.counter});

  final String? counter;

  @override
  Widget build(BuildContext context) {
    return Center(
      child: Column(
        mainAxisAlignment: MainAxisAlignment.center,
        children: &lt;Widget&gt;[
          Text(
            'You have pushed the button this many times:',
          ),
          Text(
            '$counter',
            style: Theme.of(context).textTheme.headline4,
          ),
        ],
      ),
    );
  }
}
</pre>
<p>首先，您将在使用<code>extends</code>的地方创建自定义小部件。然后，你将<code>@override</code>这个<code>build()</code>方法。您将返回<code>Center</code>，这是一个带有几个名称参数的 Flutter 预定义小部件，包括您分配<code>Column</code>的<code>child</code>。</p>
<p><code>Column</code>有几个名称参数，这里只使用了<code>mainAxisAlignment</code>和<code>children</code>。您将有两个<code>Text</code>小部件，它们既有位置参数又有命名参数，等等。</p>
<p>您将会看到理解这段代码是多么容易，现在您甚至可以编写自己的代码了！</p>
<h2>结论</h2>
<p>Flutter 是一项帮助您创建跨平台应用程序的神奇技术，Dart 是它的基础。知道从哪里开始，先学什么，Dart 就很好学。</p>
<p>在本文中，我们回顾了 Flutter 中最广泛使用的基础知识，这样您就可以打开一个 Flutter 应用程序，不仅可以理解初始语法，还可以编写 Dart 代码。</p><div class="code-block code-block-1">
<div class="blog-plug base-cta"><h2>使用<a class="signup" href="https://lp.logrocket.com/blg/signup" target="_blank" rel="noopener noreferrer"> LogRocket </a>消除传统错误报告的干扰</h2>
<a href="https://lp.logrocket.com/blg/signup" class="signup" target="_blank" rel="noopener noreferrer"><img class="alignnone size-full wp-image-46 jetpack-lazy-image" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/><noscript><img data-lazy-fallback="1" class="alignnone size-full wp-image-46" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/></noscript></a>
<p><a href="https://lp.logrocket.com/blg/signup" target="_blank" rel="noopener noreferrer"> LogRocket </a>是一个数字体验分析解决方案，它可以保护您免受数百个假阳性错误警报的影响，只针对几个真正重要的项目。LogRocket 会告诉您应用程序中实际影响用户的最具影响力的 bug 和 UX 问题。</p>
<p>然后，使用具有深层技术遥测的会话重放来确切地查看用户看到了什么以及是什么导致了问题，就像你在他们身后看一样。</p>
<p>LogRocket 自动聚合客户端错误、JS 异常、前端性能指标和用户交互。然后 LogRocket 使用机器学习来告诉你哪些问题正在影响大多数用户，并提供你需要修复它的上下文。</p>
<p>关注重要的 bug—<a class="signup" href="https://lp.logrocket.com/blg/signup-issue-free" target="_blank" rel="noopener noreferrer">今天就试试 LogRocket】。</a></p></div></div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
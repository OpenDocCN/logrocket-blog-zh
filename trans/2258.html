<html>
<head>
<title>Using JavaScript's .at() method - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>使用 JavaScript 的。at()方法- LogRocket 博客</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/using-javascript-at-method/#0001-01-01">https://blog.logrocket.com/using-javascript-at-method/#0001-01-01</a></blockquote><div><article class="article-post">
<h2>JavaScript <code>.at()</code>方法是什么？</h2>
<p>JavaScript <code>.at()</code>方法允许开发人员根据索引无缝地抓取元素。</p>
<p>在 JavaScript 中选择元素是开发中常见的事情，但是，在使用<code>.at()</code>方法之前，JavaScript 已经有了从列表的开头或结尾或者在一个字符串中选择元素或字符的方法和技术。</p>
<p>括号符号<code>[]</code>通常用于获取特定索引处的元素。但这也有缺点。例如，我们不能使用像<code>arr[-1]</code>这样的负索引语法来访问列表中的最后一项，这在 Python 中很流行。</p>
<p>然后，开发人员必须求助于使用<code>slice()</code>方法和<code>length</code>属性来从列表末尾抓取项目，但是这些方法也有各自的缺点。</p>
<p>在本教程中，我们将看看 JavaScript <code>.at()</code>方法，它的用例，以及与先前存在的方法相比，它如何改善开发人员的体验。</p>
<h2>可索引对象原型</h2>
<p>可索引对象是可以创建索引条目的对象。在 JavaScript 中，它们包括像<code>Array</code>、<code>String</code>和<code>TypedArray</code>这样的类。</p>
<p>位于这些可索引对象的原型上的<code>.at()</code>方法表示为:<code>Array.prototype.at()</code>、<code>String.prototype.at()</code>和<code>%TypedArray%.prototype.at()</code>。因此，我们可以直接在对象实例上调用它。例如，数组的语法如下:</p>
<pre>array.at(index)</pre>
<h2>在<code>.at()</code>之前获取列表元素的现有方法</h2>
<p>为了了解<code>.at()</code>方法的优势，我们将快速浏览一些现有的方法进行比较。这也将作为初学者的复习。</p>
<p>让我们考虑一个名为<code>arr</code>的元素数组:</p>
<pre>const arr = [1, 2, "three", 4, 5, true, false];
</pre>
<p>通过在<code>arr</code>数组上使用括号符号<code>[]</code>，我们可以获得特定索引处的元素。例如，<code>arr[0]</code>返回第一个元素，<code>1</code>，依此类推。但是，为了从未知长度的末端获取一个项目，我们使用了<code>length</code>属性或<code>slice()</code>方法。</p>
<h3>使用<code>length</code>属性</h3>
<p>属性的语法是这样写的:</p>
<pre>arr[arr.length - N];
</pre>
<p>这里，<code>N</code>等于从列表末尾开始的第 n 个元素，通过使用该语法，我们可以从列表末尾获取任何元素。</p>
<p>在下面的代码中，我们使用语法来获取<code>arr</code>数组的最后一个元素:</p>
<pre>const arr = [1, 2, "three", 4, 5, true, false];
const lastItem = arr[arr.length - 1];
console.log(lastItem);  // Expected Output: false
</pre>
<p>这样做很好，但是对于一个简单的任务来说，语法可能不方便而且很乏味。此外，在处理函数的返回值时，它的一个缺点是迫使我们在应用语法之前首先将返回值存储在一个变量中:</p>
<pre>function appendNumber(arr, N) {
  arr.push(N);
  return arr;
}

const tempArr = appendNumber([1, 2, "three", 4, 5, true, false], 6);
console.log(tempArr[tempArr.length - 1]); // Expected Output: 6
</pre>
<p>在上面的代码中，在应用<code>length</code>属性之前，<code>appendNumber()</code>函数的返回值首先存储在<code>tempArr</code>变量中。</p>
<h3><code>slice()</code>法</h3>
<p>开发人员还可以使用下面的语法使用<code>slice()</code>方法来获取列表的最后一项:</p>
<pre>arr.slice(-1)[0]
</pre>
<p>这种语法允许负索引，您将在本教程后面的<code>.at()</code>方法中看到。</p>
<p>这里的负索引表示从数组末尾的偏移量。例如，<code>slice(-1)</code>从后面删除最后一项并返回一个新数组；<code>slice(-2)</code>删除最后两个，依此类推。</p>
<p>但是在这里，焦点是最后一项，因此在语法中是<code>slice(-1)</code>。然后，<code>[0]</code>符号选择该索引处的项目。</p>
<p>使用该语法，我们可以获取<code>arr</code>数组的最后一项，如下所示:</p>
<pre>const arr = [1, 2, "three", 4, 5, true, false];

console.log(arr.slice(-1)[0]); // Expected Output: false
</pre>
<p>与上面的<code>length</code>属性不同，这个方法不强迫我们在使用语法之前存储函数的返回值。因此使其更加灵活:</p>
<pre>function appendNumber(arr, N) {
  arr.push(N);
  return arr;
}

console.log(appendNumber([1, 2, "three", 4, 5, true, false], 6).slice(-1)[0]); // 6
</pre>
<p>语法看起来很奇怪，没有表达出它的意图。当然，这也很不方便。</p>
<h3>为什么不用<code>arr[-1]</code>访问最后一个数组元素？</h3>
<p>这个问题经常出现在 JavaScript 初学者身上，尤其是如果他们来自 Python 这样的编程语言。</p>
<p>JavaScript 中的<code>arr[-1]</code>符号是一个有效的对象属性。记住 JavaScript 中的一切，包括数组，都是对象。所以每当我们使用括号符号时，例如，<code>arr[0]</code>，我们用键<code>0</code>引用对象的属性。</p>
<p>通过重写对象符号中的<code>arr</code>数组，我们得到了这样的结果:</p>
<pre>const arr = {
  0: 1,
  1: 2,
  2: "three",
  // ...
};

console.log(arr[0]); // Expected Output: 1
</pre>
<p>在上面的代码中，我们没有一个键<code>-1</code>。所以，<code>arr[-1]</code>返回值<code>undefined</code>。如果对象属性有一个键<code>-1</code>，如下面的代码所示，<code>arr[-1]</code>返回其相应的值:</p>
<pre>const arr = {
  "-1": "valid"
};

console.log(arr[-1]); // Expected Output: valid
</pre>
<p>这意味着我们不能使用<code>arr[-1]</code>来获取最后一个元素，因为它已经是一个有效的语法了。为了使用负索引语法从列表末尾返回一个元素，我们将使用<code>.at()</code>方法。</p><div class="code-block code-block-54">
<hr/>
<h3>更多来自 LogRocket 的精彩文章:</h3>

<hr/></div>
<h2>使用<code>.at()</code>语法</h2>
<p>当使用<code>.at()</code>语法时，它接收要返回的项目的索引。当传递负索引时，它从列表或字符串的末尾开始计数，并返回找到的项或字符。否则，它返回<code>undefined</code>:</p>
<pre>at(index)
</pre>
<h2><code>.at()</code>实践中的方法</h2>
<p><code>.at()</code>方法接收要返回的项目的索引。在这一节中，我们将讨论它的用例。</p>
<p>让我们重温一下<code>arr</code>数组，看看<code>.at()</code>方法如何让我们无缝地返回一个索引元素:</p>
<pre>const arr = [1, 2, "three", 4, 5, true, false];

console.log(arr.at(0)); // Expected Output: 1
console.log(arr.at(2)); // Expected Output: "three"
console.log(arr.at(-1)); // Expected Output: false
console.log(arr.at(-3)); // Expected Output: 5</pre>
<pre>console.log(arr.at(7)); // Expected Output: undefined
</pre>
<p>当一个正索引传递给<code>.at()</code>方法时，它返回该索引处的元素。对于负索引，它从列表中的最后一个元素开始倒数，并返回该元素。</p>
<p>在上面的代码中，<code>at(-1)</code>从数组末尾开始计数 1，并返回<code>false</code>，这是找到的元素。同理，<code>at(-3)</code>从末尾数三，返回<code>5</code>。但是，如果找不到<code>.at()</code>索引，它将返回一个未定义的值。</p>
<p>像数组一样，我们可以对字符串做同样的事情:</p>
<pre>const str = "The last alphabet is z";

console.log(str.at(0)); // Expected Output: T
console.log(str.at(-1)); // Expected Output: z
</pre>
<p>正如我们所见，这种方法使用起来很愉快。仅仅通过<code>.at(-1)</code>，我们就获得了<code>str</code>字符串的最后一个字符。如果我们对<code>length</code>属性执行同样的任务，我们会有一个更长的语法，就像这样:</p>
<pre>console.log(str[str.length - 1]); // Expected Output: z
</pre>
<h3>处理函数的返回值</h3>
<p>与<code>length</code>属性不同的是，<code>.at()</code>方法不会强迫我们在使用函数之前将返回值存储在变量中。</p>
<p>下面的代码输出推入数组的最后一个元素:</p>
<pre>function appendNumber(arr, N) {
  arr.push(N);
  return arr;
}

console.log(appendNumber([1, 2, "three", 4, 5, true, false], 6).at(-1));
// Expected Output: 6
</pre>
<p>在代码中，<code>.at()</code>方法直接应用于返回值，而无需先将值存储在变量中。</p>
<h3><code>.at()</code>方法接受带小数的数字</h3>
<p>当带有小数的数字传递给<code>.at()</code>方法时，它会考虑小数点之前的值，并返回该索引处的项目。</p>
<p>让我们来看看下面的代码:</p>
<pre>const arr = [1, 2, "three", 4, 5, true, false];
console.log(arr.at(0.6)); // Expected Output: 1
console.log(arr.at(-3.6)); // Expected Output: 5
</pre>
<p>在上面的代码中，第一个控制台输出位于<code>0</code>索引处的项目，而第二个控制台从数组末尾开始计数 3，并输出找到的项目。</p>
<p>当我们想要随机选择一个索引元素时，这是有益的。这可以用一个石头剪子布游戏项目来演示。我们可以使用<code>.at()</code>方法语法来确定计算机的随机选择。</p>
<p>下面的代码说明了我们如何应用<code>.at()</code>方法来随机选择计算机的选项:</p>
<pre>const computerOptions = ["rock", "paper", "scissors"];
const randomIndex = Math.random() * computerOptions.length;

console.log(computerOptions.at(randomIndex));
</pre>
<p><img data-attachment-id="96693" data-permalink="https://blog.logrocket.com/using-javascript-at-method/image1-27/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2021/10/image1-2.gif" data-orig-size="595,261" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="javascript-.at()-method" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2021/10/image1-2-300x132.gif" data-large-file="https://blog.logrocket.com/wp-content/uploads/2021/10/image1-2.gif" decoding="async" class="aligncenter wp-image-96693 size-full jetpack-lazy-image" src="../Images/c5ff1b24a4350acddc8151a77c334fbc.png" alt="Rock-Paper-Scissors Generator Showing &quot;Paper,&quot; &quot;Rock,&quot;&quot;Paper&quot;" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2021/10/image1-2.gif?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2021/10/image1-2.gif"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="96693" data-permalink="https://blog.logrocket.com/using-javascript-at-method/image1-27/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2021/10/image1-2.gif" data-orig-size="595,261" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="javascript-.at()-method" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2021/10/image1-2-300x132.gif" data-large-file="https://blog.logrocket.com/wp-content/uploads/2021/10/image1-2.gif" decoding="async" loading="lazy" class="aligncenter wp-image-96693 size-full" src="../Images/c5ff1b24a4350acddc8151a77c334fbc.png" alt="Rock-Paper-Scissors Generator Showing &quot;Paper,&quot; &quot;Rock,&quot;&quot;Paper&quot;" data-original-src="https://blog.logrocket.com/wp-content/uploads/2021/10/image1-2.gif"/></noscript>
<p><a href="https://codesandbox.io/s/wonderful-river-dttqe?file=/script.js">在 CodeSandbox </a>上亲自尝试一下。</p>
<p><a href="https://blog.logrocket.com/building-random-number-generator-javascript-nodejs/">用<code>Math.random()</code>，我们得到一个在<code>0</code>(含)和数组长度之间的浮点数</a>。然后，当<code>.at()</code>方法接收这个浮点数作为索引时，它会考虑小数点之前的值，并返回该索引处的元素。</p>
<p>除非我们首先对随机数取整(即将该数四舍五入到最接近的整数)，否则不可能对同一任务使用方括号符号，如下面的代码所示:</p>
<pre>const randomIndex = Math.floor(Math.random() * computerOptions.length);

console.log(computerOptions[randomIndex]);
</pre>
<p>这是因为括号符号为带小数的数字返回一个<code>undefined</code>值:</p>
<pre>const arr = [1, 2, "three", 4, 5, true, false];
console.log(arr[0.6]); // Expected Output: undefined
</pre>
<p><code>.at()</code>方法为我们节省了使用<code>Math.floor</code>对随机数取整的额外步骤。</p>
<h3>浏览器对 JavaScript 的<code>.at()</code>方法的支持</h3>
<p>现代浏览器广泛支持<code>.at()</code>方法。点击查看<a href="https://caniuse.com/mdn-javascript_builtins_array_at">浏览器支持。</a></p>
<p><img data-attachment-id="96675" data-permalink="https://blog.logrocket.com/using-javascript-at-method/image1-24/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2021/10/image1-e1646755160960.png" data-orig-size="730,199" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="browser-support-javascript-.at()-method" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2021/10/image1-300x82.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2021/10/image1-1024x279.png" decoding="async" class="aligncenter wp-image-96675 size-full jetpack-lazy-image" src="../Images/ee5e9aa8fa4053a14f6d867899485a08.png" alt="Browser Support For Using The At() Method" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2021/10/image1-e1646755160960.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2021/10/image1-e1646755160960.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="96675" data-permalink="https://blog.logrocket.com/using-javascript-at-method/image1-24/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2021/10/image1-e1646755160960.png" data-orig-size="730,199" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="browser-support-javascript-.at()-method" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2021/10/image1-300x82.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2021/10/image1-1024x279.png" decoding="async" loading="lazy" class="aligncenter wp-image-96675 size-full" src="../Images/ee5e9aa8fa4053a14f6d867899485a08.png" alt="Browser Support For Using The At() Method" data-original-src="https://blog.logrocket.com/wp-content/uploads/2021/10/image1-e1646755160960.png"/></noscript>
<h2>结论</h2>
<p>正如我们在本教程中所看到的,<code>.at()</code>方法在根据索引抓取项目时非常有用。与先前存在的方法相比，它使用起来也很简洁。</p>
<p>如果你有任何问题或贡献，请在评论区分享。如果你喜欢这个教程，努力在网络上分享它。</p><div class="code-block code-block-27">
<div class="blog-plug inline-plug vanilla-javascript-cta"><h2>通过理解上下文，更容易地调试 JavaScript 错误</h2>
<p>调试代码总是一项单调乏味的任务。但是你越了解自己的错误，就越容易改正。</p>
<p>LogRocket 让你以新的独特的方式理解这些错误。我们的前端监控解决方案跟踪用户与您的 JavaScript 前端的互动，让您能够准确找出导致错误的用户行为。</p>
<a href="https://lp.logrocket.com/blg/javascript-signup" class="signup" target="_blank" rel="noopener noreferrer"><img class="alignnone size-full wp-image-46 jetpack-lazy-image" src="../Images/cbfed9be3defcb505e662574769a7636.png" alt="LogRocket Dashboard Free Trial Banner" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2020/06/reproduce-javascript-errors.gif?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/06/reproduce-javascript-errors.gif"/><noscript><img data-lazy-fallback="1" class="alignnone size-full wp-image-46" src="../Images/cbfed9be3defcb505e662574769a7636.png" alt="LogRocket Dashboard Free Trial Banner" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/06/reproduce-javascript-errors.gif"/></noscript></a>
<p>LogRocket 记录控制台日志、页面加载时间、堆栈跟踪、慢速网络请求/响应(带有标题+正文)、浏览器元数据和自定义日志。理解您的 JavaScript 代码的影响从来没有这么简单过！</p>
<a class="signup" href="https://lp.logrocket.com/blg/javascript-signup" target="_blank" rel="noopener noreferrer">Try it for free</a><p>.</p></div>


</div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
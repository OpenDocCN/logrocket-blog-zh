<html>
<head>
<title>Creating a Puppeteer microservice to deploy to Google Cloud Functions - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>创建一个木偶师微服务部署到谷歌云功能</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/creating-puppeteer-microservice-deploy-google-cloud-functions/#0001-01-01">https://blog.logrocket.com/creating-puppeteer-microservice-deploy-google-cloud-functions/#0001-01-01</a></blockquote><div><article class="article-post">
<p>木偶师是一个无头 Chrome 的高级抽象，拥有丰富的 API。这使得自动化与网页的交互变得非常方便。</p>
<p>本文将带您浏览一个用例，我们将在 GitHub 上搜索一个关键字，并获取第一个结果的标题。</p>
<p>这是一个纯粹为了演示的基本例子，甚至没有木偶师也能做到。因为关键字可以位于 GitHub 页面的 URL 和页面列表中，所以您可以直接导航到结果。</p>
<p>但是，假设您在 web 页面上的交互没有反映在页面 URL 中，并且没有公共 API 来获取数据，那么通过 Puppeteer 实现自动化就很方便了。</p>
<h2>设置木偶师和 Node.js</h2>
<p>让我们在一个文件夹中初始化一个 Node.js 项目。在您的系统终端上，导航到您希望包含项目的文件夹，并运行以下命令:</p>
<pre>npm init -y
</pre>
<p>这将生成一个<code>package.json</code>文件。接下来，安装木偶师 npm 包。</p>
<pre>npm install --save puppeteer
</pre>
<p>现在，创建一个名为<code>service.mjs</code>的文件。这种文件格式允许我们使用 ES 模块，并通过使用 Puppeteer 来负责抓取页面。让我们用木偶师完成一个快速测试，看看它是否有效。</p>
<p>首先，我们启动一个 Chrome 实例，并传递<code>headless: false</code>参数来显示它，而不是在没有 GUI 的情况下无头运行它。现在使用<code>newPage</code>方法创建一个页面，并使用<code>goto</code>方法导航到作为参数传递的网址:</p>
<pre>import puppeteer from 'puppeteer';

const browser = await puppeteer.launch({
  headless: false
});

const page = await browser.newPage();
await page.goto('https://www.github.com');
</pre>
<p>当您运行这段代码时，应该会弹出一个 Chrome 窗口，并在一个新的选项卡中导航到该 URL。</p>
<h2>使用木偶师自动化</h2>
<p>为了让 Puppeteer 与页面交互，我们需要手动检查页面并指定目标 DOM 元素。</p>
<p>我们需要确定选择器，即类名、id、元素类型或其中几个的组合。如果我们需要高水平的特异性，我们可以将这些选择器与各种木偶方法一起使用。</p>
<p>现在，让我们用浏览器检查一下<a href="https://www.github.com" target="_blank" rel="noopener">www.github.com</a>。我们需要能够将焦点放在页面顶部的搜索输入字段，然后键入我们想要搜索的关键字。然后我们需要 Git 键盘上的<code>Enter</code>按钮。</p>
<p>在你喜欢的浏览器上打开<a href="https://www.github.com" target="_blank" rel="noopener">www.github.com</a>——我用 Chrome，但任何浏览器都可以——在页面上点击右键，然后点击<strong>检查</strong>。然后，在<strong>元素</strong>标签下，你可以看到 DOM 树。使用检查窗格左上角的检查工具，您可以单击元素以在 DOM 树中突出显示它们:</p>
<p><img data-attachment-id="71688" data-permalink="https://blog.logrocket.com/creating-puppeteer-microservice-deploy-google-cloud-functions/dom-tree/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2021/10/dom-tree.png" data-orig-size="730,386" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="DOM tree" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2021/10/dom-tree-300x159.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2021/10/dom-tree.png" decoding="async" class="aligncenter size-full wp-image-71688 jetpack-lazy-image" src="../Images/2fb6712b2baff9a5ab69eab352e6a00e.png" alt="DOM Tree" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2021/10/dom-tree.png 730w, https://blog.logrocket.com/wp-content/uploads/2021/10/dom-tree-300x159.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2021/10/dom-tree.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2021/10/dom-tree.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="71688" data-permalink="https://blog.logrocket.com/creating-puppeteer-microservice-deploy-google-cloud-functions/dom-tree/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2021/10/dom-tree.png" data-orig-size="730,386" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="DOM tree" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2021/10/dom-tree-300x159.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2021/10/dom-tree.png" decoding="async" loading="lazy" class="aligncenter size-full wp-image-71688" src="../Images/2fb6712b2baff9a5ab69eab352e6a00e.png" alt="DOM Tree" srcset="https://blog.logrocket.com/wp-content/uploads/2021/10/dom-tree.png 730w, https://blog.logrocket.com/wp-content/uploads/2021/10/dom-tree-300x159.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2021/10/dom-tree.png"/></noscript>
<p>我们感兴趣的输入字段元素有几个类名，但只针对<code>.header-search-input</code>就足够了。为了确保我们引用了正确的元素，我们可以在浏览器控制台上快速测试它。点击<strong>控制台</strong>选项卡，对<code>Document</code>对象使用<code>querySelector</code>方法:</p>
<pre>document.querySelector('.header-search-input')
</pre>
<p>如果这返回了正确的元素，那么我们知道它将与木偶师一起工作。</p>
<p>注意，可能有几个元素匹配同一个选择器。在这种情况下，<code>querySelector</code>返回第一个匹配的元素。要引用正确的元素，您需要使用<code>querySelectorAll</code>，然后从返回的元素的<code>NodeList</code>中选择正确的索引。</p>
<p>这里有一点要注意。如果您调整 GitHub 网页的大小，输入栏将变得不可见，并在汉堡菜单中可用。</p>
<p>因为它是不可见的，除非汉堡包的菜单是打开的，我们不能关注它。为了确保输入字段可见，我们可以通过将<code>defaultViewport</code>对象传递给设置来显式设置浏览器窗口的大小。</p>
<pre>const browser = await puppeteer.launch({
  headless: false,
  defaultViewport: {
    width: 1920,
    height: 1080
  }
});
</pre>
<p>现在是时候使用查询来定位元素了。在尝试与元素交互之前，我们必须确保它已经呈现在页面上并准备好了。木偶戏就是因为这个原因才有了<code>waitForSelector</code>的方法。</p>
<p>它将选择器字符串作为第一个参数，将 options 对象作为第二个参数。因为我们要与元素交互，即聚焦，然后在输入字段中输入，我们需要让它在页面上可见，因此有了<code>visible: true</code>选项。</p>
<pre>const inputField = '.header-search-input';
await page.waitForSelector(inputField, { visible: true });
</pre>
<p>如前所述，我们需要关注输入字段元素，然后模拟输入。出于这些目的，木偶师有以下方法:</p>
<pre>const keyword = 'react';

await page.focus(inputField);
await page.keyboard.type(keyword);
</pre>
<p>到目前为止<code>service.mjs</code>看起来如下:</p>
<pre>import puppeteer from 'puppeteer';

const browser = await puppeteer.launch({
  headless: false,
  defaultViewport: {
    width: 1920,
    height: 1080
  }
});

const page = await browser.newPage();
await page.goto('https://www.github.com');

const inputField = '.header-search-input';
const keyword = 'react'

await page.waitForSelector(inputField);
await page.focus(inputField);
await page.keyboard.type(keyword);
</pre>
<p>当您运行代码时，您应该看到搜索字段被聚焦，并且键入了关键字<code>react</code>。</p>
<p>现在，模拟键盘上的<code>Enter</code>按键。</p>
<pre>await page.keyboard.press('Enter');
</pre>
<p>在我们按下<strong> Enter </strong>键后，Chrome 将导航到一个新的页面。如果我们手动搜索一个关键字并检查我们被导航到的页面，我们会发现我们感兴趣的元素的选择器是<code>.repo-list</code>。</p>
<p>此时，我们需要确保导航到新页面是完整的。为此，有一个<code>page.waitForNavigation</code>方法。导航之后，我们再次需要使用<code>page.waitForSelector</code>方法等待元素。</p><div class="code-block code-block-54">
<hr/>
<h3>更多来自 LogRocket 的精彩文章:</h3>

<hr/></div>
<p>然而，如果我们只对从元素中抓取一些数据感兴趣，我们不需要等到它在视觉上可见。所以，这一次，我们可以省略<code>{ visible: true }</code>选项，默认设置为<code>false</code>。</p>
<pre>const repoList = '.repo-list';

await page.waitForNavigation();
await page.waitForSelector(repoList);
</pre>
<p>一旦我们知道了<code>.repo-list</code>选择器在 DOM 树中，那么我们就可以通过使用<code>page.evaluate</code>方法来抓取标题。</p>
<p>首先，我们通过将<code>repoList</code>变量传递给<code>querySelector</code>来选择<code>.repo-list</code>。然后我们级联<code>querySelectorAll</code>来获得所有的<code>li</code>元素，并从元素的<code>NodeList</code>中选择第一个元素。</p>
<p>最后，我们添加了另一个针对<code>.f4.text-normal</code>查询的<code>querySelector</code>，它的标题是我们通过<code>innerText</code>访问的。</p>
<pre>const title = await page.evaluate((repoList) =&gt; (
  document
    .querySelector(repoList)
    .querySelectorAll('li')[0]
    .querySelector('.f4.text-normal')
    .innerText
), repoList);
</pre>
<p>现在，我们可以将所有内容包装在一个函数中，并将其导出到另一个文件中使用，在该文件中，我们将设置带有端点的 Express 服务器来提供数据。</p>
<p><code>service.mjs</code>的最终版本返回一个异步函数，该函数将关键字作为输入。在函数内部，我们使用一个<code>try…catch</code>块来捕捉并返回任何错误。最后，我们调用<code>browser.close</code>来关闭我们已经启动的浏览器。</p>
<pre>import puppeteer from 'puppeteer';

const service = async (keyword) =&gt; {
  const browser = await puppeteer.launch({
    headless: true,
    defaultViewport: {
      width: 1920,
      height: 1080
    }
  });

  const inputField = '.header-search-input';
  const repoList = '.repo-list';

  try {
    const page = await browser.newPage();
    await page.goto('https://www.github.com');

    await page.waitForSelector(inputField);
    await page.focus(inputField);
    await page.keyboard.type(keyword);

    await page.keyboard.press('Enter');

    await page.waitForNavigation();
    await page.waitForSelector(repoList);

    const title = await page.evaluate((repoList) =&gt; (
      document
        .querySelector(repoList)
        .querySelectorAll('li')[0]
        .querySelector('.f4.text-normal')
        .innerText
    ), repoList);

    await browser.close();
    return title;
  } catch (e) {
    throw e;
  }
}

export default service;
</pre>
<h2>创建 Express 服务器</h2>
<p>我们需要一个端点来提供数据，在这里我们捕获要搜索的关键字作为路由参数。因为我们将路由路径定义为<code>/:keyword</code>，所以它在<code>req.params</code>对象中用<code>keyword</code>的键暴露出来。接下来，我们调用<code>service</code>函数并传递这个关键字作为输入参数来运行 Puppeteer。</p>
<p><code>server.mjs</code>的内容如下:</p>
<pre>import express from 'express';
import service from './service.mjs';

const app = express();
app.listen(5000);

app.get('/:keyword', async (req, res) =&gt; {
  const { keyword } = req.params;
  try {
    const response = await service(keyword);
    res.status(200).send(response);
  } catch (e) {
    res.status(500).send(e);
  }
});
</pre>
<p>在终端中，运行<code>node server.mjs</code>启动服务器。在另一个终端窗口中，使用<code>curl</code>向端点发送请求。这将从条目标题中返回字符串值。</p>
<pre>curl localhost:5000/react
</pre>
<p>请注意，该服务器是最低要求。在生产中，您应该保护您的端点并设置 CORS，以防您需要从浏览器而不是服务器发送请求。</p>
<h2>部署到 Google 云功能</h2>
<p>现在，我们将把这个服务部署到一个无服务器的云功能中。云功能和服务器之间的主要区别在于，云功能可以根据请求快速调用，并保持一段时间以响应后续请求，而服务器始终处于运行状态。</p>
<p>部署到<a href="https://developers.google.com/learn/topics/functions" target="_blank" rel="noopener">谷歌云功能</a>非常简单。但是，为了成功运行 Puppeteer，您应该了解一些设置。</p>
<p>首先，给你的云功能分配足够的内存。根据我的测试，512MB 对于木偶师来说已经足够了，但是如果你遇到了与内存相关的问题，请分配更多的内存。</p>
<p><code>package.json</code>内容应该如下:</p>
<pre>{
  "name": "puppeteer-example",
  "version": "0.0.1",
  "type": "module",
  "dependencies": {
    "puppeteer": "^10.2.0",
    "express": "^4.17.1"
  }
}
</pre>
<p>我们添加了<code>puppeteer</code>和<code>express</code>作为依赖项，并设置了“type”:“module”以便使用 ES6 语法。</p>
<p>现在创建一个名为<code>service.js</code>的文件，并用我们在<code>service.mjs</code>中使用的相同内容填充它。</p>
<p><code>index.js</code>的内容如下:</p>
<pre>import express from 'express';
import service from './service.js';

const app = express();

app.get('/:keyword', async (req, res) =&gt; {
  const { keyword } = req.params;
  try {
    const response = await service(keyword);
    res.status(200).send(response);
  } catch (e) {
    res.status(500).send(e);
  }
});

export const run = app;
</pre>
<p>这里，我们从<code>server.js</code>导入了<code>express</code>包和我们的函数。</p>
<p>与我们在本地主机上测试的服务器代码不同，我们不需要监听端口，因为这是自动处理的。</p>
<p>而且，与本地主机不同，我们需要在云函数中导出<code>app</code>对象。将<strong>入口点</strong>设置为<code>run</code>或您正在导出的任何变量名，如下所示。默认设置为<code>helloWorld</code>。</p>
<p><img data-attachment-id="71690" data-permalink="https://blog.logrocket.com/creating-puppeteer-microservice-deploy-google-cloud-functions/entry-point/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2021/10/entry-point.png" data-orig-size="730,290" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Entry point" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2021/10/entry-point-300x119.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2021/10/entry-point.png" decoding="async" class="aligncenter size-full wp-image-71690 jetpack-lazy-image" src="../Images/ccc3eea4c28480286788bde2c617e665.png" alt="Entry Point" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2021/10/entry-point.png 730w, https://blog.logrocket.com/wp-content/uploads/2021/10/entry-point-300x119.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2021/10/entry-point.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2021/10/entry-point.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="71690" data-permalink="https://blog.logrocket.com/creating-puppeteer-microservice-deploy-google-cloud-functions/entry-point/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2021/10/entry-point.png" data-orig-size="730,290" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Entry point" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2021/10/entry-point-300x119.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2021/10/entry-point.png" decoding="async" loading="lazy" class="aligncenter size-full wp-image-71690" src="../Images/ccc3eea4c28480286788bde2c617e665.png" alt="Entry Point" srcset="https://blog.logrocket.com/wp-content/uploads/2021/10/entry-point.png 730w, https://blog.logrocket.com/wp-content/uploads/2021/10/entry-point-300x119.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2021/10/entry-point.png"/></noscript>
<p>为了方便测试我们的云功能，我们将其公开。选择<strong>云功能</strong> ( <em>注:旁边有复选框</em>)，点击顶部栏菜单中的<strong>权限</strong>按钮。这将显示一个侧面板，您可以在其中添加主体。点击<strong>添加负责人</strong>，在<strong>新负责人</strong>字段中搜索<code>allUsers</code>。最后，选择<code>Cloud Function Invoker</code>作为<strong>角色</strong>。</p>
<p>注意，一旦添加了这个主体，任何拥有触发器链接的人都可以调用这个函数。对于测试来说，这很好，但是要确保为您的云功能实现身份验证，以避免不希望的调用，这将反映在账单中。</p>
<p><img data-attachment-id="71692" data-permalink="https://blog.logrocket.com/creating-puppeteer-microservice-deploy-google-cloud-functions/add-principals/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2021/10/add-principals.png" data-orig-size="571,460" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Add principals" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2021/10/add-principals-300x242.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2021/10/add-principals.png" decoding="async" class="aligncenter size-full wp-image-71692 jetpack-lazy-image" src="../Images/632578f2b841fd86fa0cdc2b707c7db1.png" alt="Add Principals" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2021/10/add-principals.png 571w, https://blog.logrocket.com/wp-content/uploads/2021/10/add-principals-300x242.png 300w" data-lazy-sizes="(max-width: 571px) 100vw, 571px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2021/10/add-principals.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2021/10/add-principals.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="71692" data-permalink="https://blog.logrocket.com/creating-puppeteer-microservice-deploy-google-cloud-functions/add-principals/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2021/10/add-principals.png" data-orig-size="571,460" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Add principals" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2021/10/add-principals-300x242.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2021/10/add-principals.png" decoding="async" loading="lazy" class="aligncenter size-full wp-image-71692" src="../Images/632578f2b841fd86fa0cdc2b707c7db1.png" alt="Add Principals" srcset="https://blog.logrocket.com/wp-content/uploads/2021/10/add-principals.png 571w, https://blog.logrocket.com/wp-content/uploads/2021/10/add-principals-300x242.png 300w" sizes="(max-width: 571px) 100vw, 571px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2021/10/add-principals.png"/></noscript>
<p>现在单击您的函数来查看函数的详细信息。导航到<strong>触发器</strong>选项卡，在这里您将找到触发器 URL。单击此链接调用函数，该函数返回列表中第一个存储库的标题。现在，您可以在应用程序中使用该链接来获取数据。</p>
<h2>结论</h2>
<p>我们已经介绍了如何使用 Puppeteer 来自动化与网页的基本交互，并抓取内容以在节点服务器上使用 Express framework 提供服务。然后，我们将它部署在 Google Cloud Functions 上，以使它成为一个微服务，然后可以集成到另一个应用程序中使用。</p>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
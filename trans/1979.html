<html>
<head>
<title>Implementing scroll restoration in ecommerce React apps - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>在电子商务 React 应用程序中实现滚动恢复</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/implementing-scroll-restoration-in-ecommerce-react-apps/#0001-01-01">https://blog.logrocket.com/implementing-scroll-restoration-in-ecommerce-react-apps/#0001-01-01</a></blockquote><div><article class="article-post">
<p>卷轴恢复是一个我们认为理所当然的功能。对于传统的基于 HTML 的页面和导航(即服务器呈现的网站)，浏览器总是为我们处理这种交互。</p>
<p>随着从服务器端呈现向浏览器的转变，在客户端呈现的应用程序，甚至 JS 增强的 HTML 页面都失去了这一非常有用的用户体验特性。电子商务网站上的产品列表页面(PLP)是让滚动恢复正常工作的最重要的地方之一。在这篇文章中，我们将探索一种技术来手动恢复浏览器的滚动位置，以便我们的电子商务用户获得一致和高性能的体验。</p>
<h2>设置场景</h2>
<p>让我们想象一下，我们有一个 PLP 的电子商务网站，每行显示 4 个产品，每页显示 32 个产品。每张产品卡大约 500 像素高(包含产品图片、产品名称、颜色/尺寸信息、价格和一个“添加到购物车”按钮)。</p>
<p>现在让我们假设一个浏览网站的用户的浏览器分辨率为 1920 x 1080px。这意味着他们可以一次看到两排产品。对于该 PLP，总共有多达四个滚动“视窗”可供用户使用:每页 32 个产品，每行四个产品，总共八行，每个视窗两行。</p>
<p><img data-attachment-id="59715" data-permalink="https://blog.logrocket.com/implementing-scroll-restoration-in-ecommerce-react-apps/ecommerce-plp-example/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2021/07/Ecommerce-PLP-example.png" data-orig-size="730,412" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Ecommerce-PLP-example" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2021/07/Ecommerce-PLP-example-300x169.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2021/07/Ecommerce-PLP-example.png" decoding="async" class="size-full wp-image-59715 aligncenter jetpack-lazy-image" src="../Images/8690e3a6c8dd71d9cd3c7aa56c3a0045.png" alt="Screenshot of an example PLP with two rows of four products each" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2021/07/Ecommerce-PLP-example.png 730w, https://blog.logrocket.com/wp-content/uploads/2021/07/Ecommerce-PLP-example-300x169.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2021/07/Ecommerce-PLP-example.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2021/07/Ecommerce-PLP-example.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="59715" data-permalink="https://blog.logrocket.com/implementing-scroll-restoration-in-ecommerce-react-apps/ecommerce-plp-example/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2021/07/Ecommerce-PLP-example.png" data-orig-size="730,412" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Ecommerce-PLP-example" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2021/07/Ecommerce-PLP-example-300x169.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2021/07/Ecommerce-PLP-example.png" decoding="async" loading="lazy" class="size-full wp-image-59715 aligncenter" src="../Images/8690e3a6c8dd71d9cd3c7aa56c3a0045.png" alt="Screenshot of an example PLP with two rows of four products each" srcset="https://blog.logrocket.com/wp-content/uploads/2021/07/Ecommerce-PLP-example.png 730w, https://blog.logrocket.com/wp-content/uploads/2021/07/Ecommerce-PLP-example-300x169.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2021/07/Ecommerce-PLP-example.png"/></noscript>
<p>现在让我们假设一个用户向下滚动 PLP 并点击了第 15 个产品，因此浏览器将他们导航到该产品的产品描述页面(PDP)。这意味着他们在第四行选择了一个产品。</p>
<p>现在，用户希望返回到列表页面，继续浏览其余的产品，所以他们按了 back 按钮。浏览器向后导航，当列表页面完成加载时，可见的产品出现在第一行和第二行。</p>
<p>然后，用户必须手动向下滚动，搜索他们刚刚查看过的产品，以便继续查看其余的产品。这是电子商务用户感到沮丧的一个非常常见的原因，也是导致他们对网站和潜在品牌失去信任的一个原因。</p>
<p>用户不知道为什么会这样，但是作为开发人员，我们知道。我们的 PLP 完全在浏览器中呈现和填充，所以当浏览器第一次绘制 HTML(可能只包括页眉和页脚)时，呈现产品的部分只是一个空的 div。</p>
<p>当浏览器试图在导航到 PDP 之前使用滚动条所在的 Y 坐标本地恢复滚动位置时，页面将不够长。浏览器无法准确地恢复滚动位置，因为它不知道我们的应用程序何时完成渲染，因此也不知道何时应该恢复。</p>
<p>在这些情况下，我们需要自己处理恢复滚动位置。</p>
<h2>在开始之前</h2>
<p>为了真正理解什么是滚动恢复，让我们看一下需要手动控制滚动恢复的一些情况:服务器呈现的带有 JS 呈现内容的 web 页面(混合页面)，以及完全在客户端呈现的应用程序(例如，React 应用程序)。</p>
<p>首先，一个基线。这里我们有一个服务器渲染的网站，一旦开始渲染，浏览器就可以使用所有的 HTML:</p>
<p><img data-attachment-id="59718" data-permalink="https://blog.logrocket.com/implementing-scroll-restoration-in-ecommerce-react-apps/server-rendered-ecommerce-site/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2021/07/server-rendered-ecommerce-site.gif" data-orig-size="730,381" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="server-rendered-ecommerce-site" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2021/07/server-rendered-ecommerce-site-300x157.gif" data-large-file="https://blog.logrocket.com/wp-content/uploads/2021/07/server-rendered-ecommerce-site.gif" decoding="async" class="size-full wp-image-59718 aligncenter jetpack-lazy-image" src="../Images/8dd736ab075445f0073caad22935b2fe.png" alt="Gif of an example ecommerce site scrolling down" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2021/07/server-rendered-ecommerce-site.gif?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2021/07/server-rendered-ecommerce-site.gif"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="59718" data-permalink="https://blog.logrocket.com/implementing-scroll-restoration-in-ecommerce-react-apps/server-rendered-ecommerce-site/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2021/07/server-rendered-ecommerce-site.gif" data-orig-size="730,381" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="server-rendered-ecommerce-site" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2021/07/server-rendered-ecommerce-site-300x157.gif" data-large-file="https://blog.logrocket.com/wp-content/uploads/2021/07/server-rendered-ecommerce-site.gif" decoding="async" loading="lazy" class="size-full wp-image-59718 aligncenter" src="../Images/8dd736ab075445f0073caad22935b2fe.png" alt="Gif of an example ecommerce site scrolling down" data-original-src="https://blog.logrocket.com/wp-content/uploads/2021/07/server-rendered-ecommerce-site.gif"/></noscript>
<p>正如我们所看到的，从 PDP 导航回 PLP 可以完美地将滚动恢复到我们在导航到 PDP 之前最初点击的产品。</p>
<p>接下来，我们有一个混合页面。在这个页面中，浏览器在第一次画图时就可以看到大部分 HTML 内容，但有些内容——在本例中是产品列表——稍后由 JavaScript 填充。</p>
<p>我们可以看到，页眉和页脚的显示与产品的加载和呈现之间存在延迟:</p>
<p><img data-attachment-id="59720" data-permalink="https://blog.logrocket.com/implementing-scroll-restoration-in-ecommerce-react-apps/hybrid-ecommerce-example-page/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2021/07/Hybrid-ecommerce-example-page.gif" data-orig-size="730,381" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Hybrid-ecommerce-example-page" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2021/07/Hybrid-ecommerce-example-page-300x157.gif" data-large-file="https://blog.logrocket.com/wp-content/uploads/2021/07/Hybrid-ecommerce-example-page.gif" decoding="async" class="size-full wp-image-59720 aligncenter jetpack-lazy-image" src="../Images/5b49775375306a5712ed1e2ad602b7ec.png" alt="Gif of hybrid ecommerce site scrolling down" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2021/07/Hybrid-ecommerce-example-page.gif?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2021/07/Hybrid-ecommerce-example-page.gif"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="59720" data-permalink="https://blog.logrocket.com/implementing-scroll-restoration-in-ecommerce-react-apps/hybrid-ecommerce-example-page/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2021/07/Hybrid-ecommerce-example-page.gif" data-orig-size="730,381" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Hybrid-ecommerce-example-page" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2021/07/Hybrid-ecommerce-example-page-300x157.gif" data-large-file="https://blog.logrocket.com/wp-content/uploads/2021/07/Hybrid-ecommerce-example-page.gif" decoding="async" loading="lazy" class="size-full wp-image-59720 aligncenter" src="../Images/5b49775375306a5712ed1e2ad602b7ec.png" alt="Gif of hybrid ecommerce site scrolling down" data-original-src="https://blog.logrocket.com/wp-content/uploads/2021/07/Hybrid-ecommerce-example-page.gif"/></noscript>
<p>正如我们在本例中看到的，当导航回 PLP 时，浏览器停留在视窗的顶部，并且无法恢复滚动到我们在导航到 PDP 之前最初单击的产品位置。</p>
<p>最后，这里我们有一个完全用 React 构建的客户端应用程序:</p>
<p><img data-attachment-id="59724" data-permalink="https://blog.logrocket.com/implementing-scroll-restoration-in-ecommerce-react-apps/client-side-react-ecommerce-example/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2021/07/Client-side-react-ecommerce-example.gif" data-orig-size="730,381" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Client-side-react-ecommerce-example" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2021/07/Client-side-react-ecommerce-example-300x157.gif" data-large-file="https://blog.logrocket.com/wp-content/uploads/2021/07/Client-side-react-ecommerce-example.gif" decoding="async" class="aligncenter wp-image-59724 size-full jetpack-lazy-image" src="../Images/623615980c507313446c5af033a1b96e.png" alt="Gif of the same ecommerce site rendered on the client side" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2021/07/Client-side-react-ecommerce-example.gif?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2021/07/Client-side-react-ecommerce-example.gif"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="59724" data-permalink="https://blog.logrocket.com/implementing-scroll-restoration-in-ecommerce-react-apps/client-side-react-ecommerce-example/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2021/07/Client-side-react-ecommerce-example.gif" data-orig-size="730,381" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Client-side-react-ecommerce-example" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2021/07/Client-side-react-ecommerce-example-300x157.gif" data-large-file="https://blog.logrocket.com/wp-content/uploads/2021/07/Client-side-react-ecommerce-example.gif" decoding="async" loading="lazy" class="aligncenter wp-image-59724 size-full" src="../Images/623615980c507313446c5af033a1b96e.png" alt="Gif of the same ecommerce site rendered on the client side" data-original-src="https://blog.logrocket.com/wp-content/uploads/2021/07/Client-side-react-ecommerce-example.gif"/></noscript>
<p>在最后一个例子中，我们看到了与混合方法相似的行为；也就是说，浏览器无法滚动还原到最初点击的产品。</p>
<h2>实现滚动恢复</h2>
<p>对于混合页面和完全客户端应用来说，实现滚动恢复是非常相似的，因为我们将利用 JavaScript 来找到我们要将滚动位置恢复到的产品。出于本文的目的，我们将介绍在 React 应用程序中实现滚动恢复的<a href="https://blog.logrocket.com/advanced-react-router-concepts-code-splitting-animated-transitions-scroll-restoration-recursive-17096c0cf9db/#:~:text=of%20the%20app.-,Scroll%20restoration,-Scroll%20restoration%20can" target="_blank" rel="noopener">。</a></p>
<p>如果您想了解混合应用程序的滚动恢复实现，请查看本文的<a href="https://github.com/denno020/scroll-restoration" target="_blank" rel="noopener"> GitHub 资源库。我们有时会引用存储库中的代码，但重要的代码将出现在本文中。</a></p>
<h3>示例应用程序结构</h3>
<p>我们将从一个非常基本的应用程序开始，它有两个页面:第一个页面包含 32 个产品，其源代码在一个名为<code>PLP.jsx</code>的组件中，第二个页面只是一个空白页面，将作为我们的占位符 PDP，源代码在一个名为<code>PDP.jsx</code>的组件中。</p>
<p>我们还有一个<code>ProductCard.jsx</code>组件，用于呈现 32 种产品中的每一种。</p>
<h3>步骤 1:存储所选产品的参考</h3>
<p>首先，我们需要存储用户选择的产品的引用。我们将使用<code>sessionStorage</code>和产品 ID 来完成这项工作。</p>
<p>为什么是<code>sessionStorage</code>？这正是为本次演示选择的格式。我们可以很容易地<a href="https://blog.logrocket.com/how-to-choose-the-right-react-state-management-solution/" target="_blank" rel="noopener">使用一个全局状态管理器</a>来存储要恢复的产品的 ID，或者其他一些在内存中保存值的方法。此外，我们不需要这些数据保留很长时间(就像使用<code>localStorage</code>一样)。如果用户关闭标签，那么数据可以安全地被遗忘。</p>
<p>实现这一点所需的代码是一个简单的函数，当<code>ProductCard</code>组件中的一个链接被激活时，就会调用这个函数。为此，我们在我们的<code>PLP</code>组件中定义函数，并将其传递给<code>ProductCard</code>组件，在单击链接时调用它:</p>
<p><code>PLP.jsx</code></p>
<pre>const PLP = () =&gt; {
  const persistScrollPosition = (id) =&gt; {
    sessionStorage.setItem("scroll-position-product-id-marker", id);
  };

  return (
    &lt;ProductCard
      product={product}
      onSelect={persistScrollPosition}
    /&gt;
  );
}
</pre>
<p><code>ProductCard.jsx</code></p>
<pre>const ProductCard = (props) =&gt; {
  const { product, onSelect } = props;
  const { id } = product;

  return (
    &lt;div&gt;
      {/* ... */}
      &lt;Link to="/pdp" onClick={() =&gt; onSelect(id)} /&gt;
      {/* ... */}
    &lt;/div&gt;
  );
}
</pre>
<h3>步骤 2:手动将滚动恢复到先前选择的产品</h3>
<p>现在我们已经存储了被点击的产品，我们需要在 PLP 再次呈现时将浏览器滚动到该产品。</p>
<p>为此，我们将利用<code>setState</code>中的回调函数来呈现应用程序的其余部分，然后将一个<code>restorationRef</code>传递给需要滚动到视图中的<code>ProductCard</code>:</p>
<p><code>PLP.jsx</code></p>
<pre>const PLP = () =&gt; {
  // ...

  const [productMarkerId] = React.useState(() =&gt; {
    // Lazy initialise the productMarkerId
    const persistedId = sessionStorage.getItem(
      "scroll-position-product-id-marker"
    );

    sessionStorage.removeItem("scroll-position-product-id-marker");

    return persistedId ? persistedId : null;
  });

  // ...

  return (
    &lt;ProductCard
      product={product}
      onSelect={persistScrollPosition}
      restorationRef={Number(productMarkerId) === product.id ? restorationRef : null}
    /&gt;
  );
}
</pre>
<p><code>ProductCard.jsx</code></p>
<pre>const ProductCard = () =&gt; {
  const { restorationRef } = props;

  React.useEffect(() =&gt; {
    // restorationRef is only provided to the ProductCard that needs to be scrolled to
    if (!restorationRef) {
      return;
    }

    // Restoring scroll here ensures the previously selected product will always be restored, no matter how long the API request to get products takes
    restorationRef.current.scrollIntoView({ behavior: 'auto', block: 'center' });
  })

  // ...
};
</pre>
<p>神奇的事情发生在上面的<code>ProductCard.jsx</code>组件的第 11 行。已经选择了<code>behavior</code>的值<code>auto</code>，因为浏览器滚动恢复通常不使用动画，但是如果想要一个效果，我们可以很容易地使用<code>smooth</code>。</p>
<p>至于<code>block</code>，已经选择了<code>center</code>的值，因为它确保没有粘性元素会碍事。例如，如果我们使用值<code>start</code>，并且我们有一个粘性标题(这在电子商务中很常见)，那么产品行的顶部将被该标题覆盖。尽管这在技术上是正确的，但它不会给出准确的卷轴恢复体验。</p>
<p>就是这样！这就是我们手动实现滚动恢复所需的全部内容。🎉</p>
<p>然而，如果我们真的想追求高质量的用户体验，那么我们应该更进一步。</p>
<h3>步骤 3:有条件地恢复滚动到以前选择的产品</h3>
<p>想象一下这个场景:一个客户在 PLP 上选择了一个产品，并查看了该产品的描述页面。然后，他们使用菜单导航到另一个 PLP，并单击不同产品的描述页面，然后再次使用菜单返回到原始 PLP。用户一直在向前导航。你知道会发生什么吗？</p>
<p>那么，滚动将恢复到几个导航之前选择的产品，即使用户正向前移动到列表页面。这远远不是理想的行为，并且可能会给用户带来困惑。</p>
<p>为了解决这个问题，我们可以在惰性状态初始化函数中添加一个检查，以确定用户是实际返回到列表页面，还是只是从站点上的另一个页面再次导航到该页面。</p>
<p>在 React 中，我们可以使用 React 路由器和<code>useHistory</code>钩子，如下所示:</p>
<pre>import { useHistory } from 'react-router-dom';

const PLP = () =&gt; {
  const history = useHistory();
  // ...
  const [productMarkerId] = React.useState(() =&gt; {
    // History action will be POP when a user is "moving back" to a page. Alternative will be "PUSH"
    if (history.action !== 'POP') {
      return null;
    }

    // ...
  });
};
</pre>
<p>下一个问题是，如果列表页面使用非常常见的<a href="https://blog.logrocket.com/4-ways-to-render-large-lists-in-react/#:~:text=added%20to%20it.-,2.%20Infinite%20scroll,-Another%20way%20to" target="_blank" rel="noopener">无限加载模式</a>在用户向下滚动页面时提供无限的产品列表，会发生什么？当用户点击一个产品，然后点击返回按钮，应用程序如何知道加载什么，以便正确的产品可以滚动恢复？接下来让我们来看看。</p>
<h3>步骤 4:无限加载列表页面的滚动恢复</h3>
<p>对于无限加载列表页面，我们需要确保的第一件事是跟踪正在加载的页面。我们可以在状态值中很容易地做到这一点，但是这对用户来说不是很有用，特别是对于想要共享产品页面的用户。</p>
<p>我们应该考虑跟踪 URL 中最新加载的产品页面。这为用户提供了很好的反馈，可以看到他们已经加载了多少页面的产品(而不必在应用程序的用户界面中搜索试图找到这些信息)，这也让我们有机会使用 URL 栏中的页码进行滚动恢复！</p>
<p>在我们进入技术层面之前，让我们更新一下我们的示例场景:</p>
<p>想象一下，我们的电子商务网站只有一个列表页面。我们有 32 种产品，但我们不想一次展示所有产品，并呈现一个又大又长的页面。相反，我们希望只加载和呈现前 12 个，然后是后 12 个，最后 8 个。我们要用无限载荷来做这件事。</p>
<p>当用户接近最后一行产品时，他们会看到一个“Load Next”按钮，该按钮将加载下一页产品，并将它们添加到当前列表的末尾。当页面被加载时，URL 中的查询字符串会在最终页面被加载时将<code>?page=2</code>更新为<code>?page=3</code>。</p>
<p>然后，用户选择其中一个产品，并导航到该产品的描述页面。当用户查看完描述页面并触发后退按钮时，浏览器将加载哪个页面？</p>
<p>当我们返回时，浏览器将恢复导航事件之前我们所在的最近的 URL，这将是<code>?page=3</code>。假设用户最初选择的产品在第三页，我们的滚动恢复将没有问题。</p>
<p>但是，如果用户向下滚动以加载所有三个页面的产品，然后向上滚动并单击第二页数据集中的产品，会怎么样呢？当他们从描述页面触发后退动作时会发生什么？</p>
<p>结果的第三页仍然会被加载，用户选择的产品不会被找到，所以不会发生滚动恢复。用户将被留在视口的顶部，查看第三页的第一行产品。这不是用户所期望的，我们可以让这种体验变得更好。</p>
<p>回想一下我们添加到<code>PLP</code>组件中的<code>persistScrollPosition</code>函数。我们还可以添加一个步骤，在导航事件发生之前更新 URL 中的查询字符串。记住，<code>ProductCard</code>的<code>onSelect</code>道具被添加到<code>ProductCard</code>内<code>Link</code>组件的<code>onClick</code>道具中。</p>
<p>还要注意在<code>Link</code>组件中，<code>onClick</code>功能将在导航到<code>to</code>中的路径之前执行。</p>
<p>利用这些知识，我们可以在触发导航事件之前快速更改 URL 中的查询字符串。这意味着当用户点击描述页面上的后退按钮时，浏览器将加载包含用户最初选择的产品的产品页面！让我们看看代码:</p>
<pre>const PLP = () =&gt; {
  // ...

  const persistScrollPosition = (id, pageNo) =&gt; {
    // Set the page value in the query string to match the page that the selected product is on
    history.replace(`?page=${pageNo}`);
    // ...
  };

  // ...
}
</pre>
<blockquote><p>为了让这篇文章专注于滚动恢复技术，我不打算发布实现无限加载所需的所有更改。如果需要引用，可以在之前链接的 GitHub 存储库中找到实现的模式。</p></blockquote>
<p>正如我们在上面的代码中所看到的，我们简单地用所选产品被加载的页码来调用<code>history.replace</code>。这将需要对添加到<code>products</code>数组中的产品数据进行轻微的更新，以便它能够记住该产品实际属于哪个页面。</p>
<p>通过这个非常简单的更新，我们可以依靠浏览器用用户选择的产品的正确页码来恢复 URL，而不管有多少页面被无限加载，我们的滚动恢复机制将会启动并按预期工作。</p>
<h2>更进一步</h2>
<p>还有很多可以实现的滚动恢复来创造一个伟大的用户体验。为了不使这篇文章太长，这里有一个非常简单的概述，这些额外的功能可以使一个电子商务网站的用户体验高于其他水平。</p>
<h3>骨架装载机</h3>
<p>不要显示一个基本的加载信息，用“占位符”产品预先填充页面，当被替换时，不会导致滚动抖动。当浏览器尝试滚动还原，但由于产品尚未呈现，仅滚动到(非常短的)页面底部时，会发生 Scroll jank。</p>
<h3>利用<code>scrollRestoration</code>属性</h3>
<p>告诉浏览器，我们将通过将历史 API 中的<code>scrollRestoration</code>属性设置为<code>manual</code>来处理滚动恢复。这也有助于避免滚动抖动。</p>
<h3>易接近</h3>
<p>考虑卷轴恢复的可访问性。当用户向后导航时，哪个元素将获得焦点？应该关注哪一个元素？用户选择的产品将被恢复到视窗中，但是如果用户点击 tab 键会发生什么呢？</p>
<p>在上面的例子中，我们只跟踪单个产品进行滚动恢复，假设一个简单的 PLP → PDP → (back) PLP 模式。但是，如果用户通过多个不同的 PLP 和 PDP(使用菜单)向前移动，然后决定多次点击后退按钮，该怎么办呢？本文中的示例代码不会处理这个问题，但是为这个功能更新它是相当简单的。</p>
<h2>最后的想法</h2>
<p>如前所述，滚动恢复是一个我们以前完全依赖浏览器来处理的功能，所以我们从来没有考虑过它。然而，随着越来越多的客户端和渐进式网络应用程序的建立，这一简单的功能正在消失，这对电子商务应用程序的用户体验产生了负面影响。</p>
<p>在这篇文章中，我们讨论了一些简单的步骤，可以确保我们建立的电子商务网站易于导航，用户可以信任。</p><div class="code-block code-block-17">
<div class="blog-plug inline-plug react-plug" vwo-el-id="26283398190">
<h2 vwo-el-id="41600691720">使用 LogRocket 消除传统反应错误报告的噪音</h2>
<a href="https://lp.logrocket.com/blg/react-signup-issue-free" target="_blank" vwo-el-id="19356441070">LogRocket
</a><p>是一款 React analytics 解决方案，可保护您免受数百个误报错误警报的影响，只针对少数真正重要的项目。LogRocket 告诉您 React 应用程序中实际影响用户的最具影响力的 bug 和 UX 问题。</p><a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="19356441380">
<img class="first-react-image alignnone size-full wp-image-46 jetpack-lazy-image jetpack-lazy-image--handled" src="../Images/f300c244a1a1cf916df8b4cb02bec6c6.png" vwo-el-id="18272717540" data-lazy-loaded="1" data-original-src="https://files.readme.io/27c94e7-Image_2017-06-05_at_9.46.04_PM.png"/>
</a>
<a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="19356441690">
<img class="second-react-image alignnone size-full wp-image-46 jetpack-lazy-image jetpack-lazy-image--handled" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" vwo-el-id="30720362350" data-lazy-loaded="1" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/>
</a>
<a href="https://lp.logrocket.com/blg/react-signup-issue-free" target="_blank" rel="noopener noreferrer" vwo-el-id="35866400580">LogRocket
</a><p>自动聚合客户端错误、反应错误边界、还原状态、缓慢的组件加载时间、JS 异常、前端性能指标和用户交互。然后，LogRocket 使用机器学习来通知您影响大多数用户的最具影响力的问题，并提供您修复它所需的上下文。</p><p vwo-el-id="28675661060">关注重要的 React bug—<a class="signup" href="https://lp.logrocket.com/blg/react-signup-issue-free" target="_blank" rel="noopener noreferrer" vwo-el-id="40093418840">今天就试试 LogRocket】。</a></p>
</div></div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
<html>
<head>
<title>Dependency injection in Node.js with TypeDI - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>使用TypeDI - LogRocket Blog在Node.js中进行依赖注入</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/dependency-injection-node-js-typedi/#0001-01-01">https://blog.logrocket.com/dependency-injection-node-js-typedi/#0001-01-01</a></blockquote><div><article class="article-post">
<p>依赖注入是面向对象编程中的一个基本概念。这是一种将对象的创建与使用分离的方法。在本文中，我们将学习什么是依赖注入，以及如何使用<a href="https://docs.typestack.community/typedi/v/develop/01-getting-started" target="_blank" rel="noopener"> TypeDI库</a>在Node.js应用程序中使用它。</p>
<p>向前跳:</p>

<h2 id="dependency-injection">依赖注入</h2>
<p>依赖注入是一种设计模式，它允许我们将依赖注入到类中，而不是在类中创建依赖实例。</p>
<p>依赖注入可以帮助我们:</p>
<ul>
<li>编写灵活的类</li>
<li>轻松测试我们的代码</li>
<li>减少样板代码的数量</li>
<li>提高我们代码的可读性</li>
</ul>
<p>因此，很清楚为什么依赖注入对您的应用程序来说是一件好事，但是我们如何才能做到呢？</p>
<p>首先，让我们看看依赖注入解决了什么痛点。</p>
<p/>
<p>想象一个返回用户列表的标准API。请求流有三个步骤:</p>
<ol>
<li>请求将到达<code>Controller</code>，它处理所有的路由</li>
<li><code>Controller</code>将调用处理所有业务逻辑的<code>Service</code></li>
<li><code>Service</code>将调用<code>Repository</code>，后者处理所有的数据库调用</li>
</ol>
<pre class="language-typescript hljs">UserController -&gt; UserService -&gt; UserRepository</pre>
<p>所以<code>Controller</code>取决于<code>Service</code>，<code>Service</code>取决于<code>Repository</code>。这是Node.js应用程序中典型的依赖流。</p>
<p>如果我们查看代码，我们可以看到,<code>Controller</code>创建了<code>UserService</code>的实例，而<code>Service</code>创建了<code>Repository</code>的实例。</p>
<p>服务类将如下所示:</p>
<pre class="language-typescript hljs">import { UserRepository } from "./UserRepository";

export class UserService {
  userRepo: UserRepository;

  constructor() {
    this.userRepo = new UserRepository();
  }

  getUserData = () =&gt; {
    this.userRepo.getAll();
  };
}
</pre>
<p>控制器看起来会像这样:</p>
<pre class="language-typescript hljs">import { UserService } from "./UserService";

export class UserController {
  userService: UserService;

  constructor() {
    this.userService = new UserService();
  }

  getUserData = () =&gt; {
    this.userService.getUserData();
  };
}
</pre>
<p>现在，如果我们想使用<code>UserService</code>类，我们必须在<code>UserService</code>类中创建<code>UserRepository</code>的实例。</p>
<p>在另一个类中创建一个类实例不是一个好的实践，因为现在，这两个类(即<code>UserRepository</code>和<code>UserService</code>)有紧密的耦合。</p>
<p>假设我们想要测试我们的<code>UserService</code>类。我们希望我们的测试代码与实际的数据库交互吗？</p>
<p>不—我们想模拟数据库调用并测试我们的<code>UserService</code>类。否则:</p>
<ul>
<li>我们将不得不创建一个测试数据库</li>
<li>我们的测试套件将依赖于数据库。因此，如果数据库出现问题，您的测试套件也会出现问题</li>
<li>测试套件将会非常慢</li>
</ul>
<p>所以我们需要一种方法将<code>UserRepository</code>的实例注入到<code>UserService</code>类中。这就是依赖注入发挥作用的地方。</p>
<h2 id="achieving-dependency-injection-containers">用容器实现依赖注入</h2>
<p>实现依赖注入最常见的方式是使用依赖注入容器。</p>
<p>我们可以创建一个全局容器对象来保存依赖关系的所有实例，并且我们可以将依赖关系注入到类中。</p>
<p>注入依赖项的最常见方式是使用构造函数。我们可以使用我们的<code>UserService</code>类的构造函数来注入<code>UserRepository</code>类的实例。</p>
<p>我们的类看起来会像这样:</p>
<pre class="language-typescript hljs">import { UserRepository } from "./UserRepository";

export class UserService {
  userRepo: UserRepository;

  constructor(userRepo: UserRepository) {
    this.userRepo = userRepo;
  }

  getUserData = () =&gt; {
    this.userRepo.getAll();
  };
}
</pre>
<p>现在我们可以将<code>UserRepository</code>的实例传递给<code>UserService</code>类。你猜怎么着？</p>
<p>当我们测试<code>UserService</code>类时，我们可以将<code>UserRepository</code>的模拟实例传递给<code>UserService</code>类并测试它:</p>
<pre class="language-typescript hljs">import { UserService } from "./UserService";
import { UserRepository } from "./UserRepository";

const mockUserRepo = {
  getAll: jest.fn(),
};

const userService = new UserService(mockUserRepo);

userService.getUserData();

expect(mockUserRepo.getAll).toHaveBeenCalled();
</pre>
<p>我们仍然必须创建<code>UserRepository</code>类的实例，并将其注入到<code>UserService</code>类中，每当我们想要使用<code>UserService</code>类时，我们都必须这样做。但是我们不想每次都这样做——只做一次。</p>
<p>让我们看看如何实现这一点。</p>
<h2 id="typedi-achieving-dependency-injection-node-js">使用TypeDI实现Node.js中的依赖注入</h2>
<p>Node.js中实现依赖注入有多种方式，我们可以创建自己的依赖容器，自己创建实例，或者注入运行时。</p>
<p>但是在Node中实现依赖注入有更好的方法。它是通过使用一个名为<a href="https://docs.typestack.community/typedi/01-getting-started" target="_blank" rel="noopener"> TypeDI </a>的库来实现的，这个库支持多个DI容器，非常灵活和快速，并且简单易用。</p>
<p>依赖注入还有其他一些流行的选项，比如<a href="https://inversify.io/" target="_blank" rel="noopener"> inversify </a>和<a href="https://github.com/jeffijoe/awilix" target="_blank" rel="noopener"> awilix </a>，但是我发现TypeDI比其他的要干净得多。</p>
<h2 id="starter-project">启动项目</h2>
<p>如果您已经有一个现有的Express项目，可以跳过这一步。否则，您可以使用以下命令用Express.js和TypeScript构建一个样板项目。</p>
<pre class="language-typescript hljs">git clone https://github.com/Mohammad-Faisal/express-typescript-skeleton-boilerplate
</pre>
<p>首先，让我们在节点应用程序中安装依赖项。</p><div class="code-block code-block-54">
<hr/>
<h3>更多来自LogRocket的精彩文章:</h3>

<hr/></div>
<pre class="language-bash hljs">npm install typedi reflect-metadata
</pre>
<p>然后，修改我们的<code>tsconfig.json</code>文件以正确地使用<code>typedi</code>。在<code>compilerOptions</code>下增加以下三个选项:</p>
<pre class="language-json hljs">"experimentalDecorators": true,
"emitDecoratorMetadata": true,
"strictPropertyInitialization": false // this one is for preventing the typescript 
                                         errors while using @Inject()
</pre>
<p>现在，在我们的应用程序的开始导入<code>reflect-metadata</code>，如下所示，在<code>index.ts</code>文件中:</p>
<pre class="language-typescript hljs">import "reflect-metadata";
</pre>
<p>这将解决<code>reflect-metadata shim is required when using class decorators</code>错误。</p>
<p>基于用例，有多种方法可以使用TypeDI。让我们看看其中的几个。</p>
<h3 id="global-container">从全局容器中获取</h3>
<p>我们可以从全局容器中获取<code>UserRepository</code>的实例。这是对TypeDI的直接使用:</p>
<pre class="language-typescript hljs">import { UserRepository } from "./UserRepository";
import { Service, Inject, Container } from "typedi";

@Service()
export class UserService {
  getUserData = () =&gt; {
    const userRepo = Container.get(UserRepository);
    userRepo.getAll();
  };
}
</pre>
<p>但是你必须用<code>@Service()</code>装饰器来标记<code>UserRepository</code>类。否则，您将得到一个错误:</p>
<pre class="language-typescript hljs">import { Service } from "typedi";

@Service()
export class UserRepository {
  getAll = () =&gt; {
    console.log("Getting all the users");
  };
}
</pre>
<p>你可能想知道为什么我们在这里使用<code>@Service()</code>装饰器。</p>
<p><code>@Service()</code>装饰器用于在全局容器中将<code>UserRepository</code>注册为服务，这样我们就可以从全局容器中获得<code>UserRepository</code>的实例。</p>
<p>现在，当我们调用<code>Container.get(UserRepository)</code>时，它将返回<code>UserRepository</code>类的实例。</p>
<h3 id="injecting-userrepository-instance">注入<code>UserRepository</code>的实例</h3>
<p>我们还可以使用<code>@Inject()</code>装饰器将<code>UserRepository</code>的实例注入到<code>UserService</code>类中:</p>
<pre class="language-typescript hljs">import { UserRepository } from "./UserRepository";
import { Service, Inject, Container } from "typedi";

@Service()
export class UserService {
  @Inject()   // &lt;- notice here
  userRepo: UserRepository;

  getUserData = () =&gt; {
    this.userRepo.getAll();
  };
}
</pre>
<p>现在我们不必使用<code>Container.get(UserRepository)</code>来获得<code>UserRepository</code>类的实例。我们可以直接使用<code>this.userRepo</code>来访问<code>UserRepository</code>类的实例。</p>
<h3 id="injecting-dependency-using-constructor">使用构造函数注入依赖项</h3>
<p>我们可以使用类的构造函数注入依赖关系:</p>
<pre class="language-typescript hljs">import { UserRepository } from "./UserRepository";
import { Service, Inject } from "typedi";

@Service()
export class UserService {
  userRepo: UserRepository;

  constructor(@Inject() userRepo: UserRepository) {
    this.userRepo = userRepo;
  }

  logUserData = () =&gt; {
    this.userRepo.someFunction();
  };
}
</pre>
<p>这是向类中注入依赖关系的一种非常常见的方式。它遵循依赖注入模式。</p>
<p>这就是如何使用TypeDI在Node.js中实现依赖注入。</p>
<h2 id="other-benefits-typedi">TypeDI的其他优势</h2>
<p>使用TypeDI库还有其他好处。我们可以使用<code>Container</code>类在应用程序中设置全局变量。</p>
<p>首先，我们必须设置需要跨应用程序访问的变量:</p>
<pre class="language-typescript hljs">import 'reflect-metadata';
import { Container, Token } from 'typedi';

export const SOME_GLOBAL_CONFIG_VALUE = new Token&lt;string&gt;('SOME_CONFIG');
Container.set(SOME_GLOBAL_CONFIG_VALUE, 'very-secret-value');
</pre>
<p>现在，如果我们在应用程序中的任何地方需要这个值，我们可以使用下面这段代码:</p>
<pre class="language-typescript hljs">import { Container, Token } from 'typedi';

const MY_SECRET = Container.get(SOME_GLOBAL_CONFIG_VALUE);
</pre>
<p>这也是非常类型安全的，因为<code>Token</code>是类型化的。</p>
<p>多酷啊。</p>
<h2 id="conclusion">结论</h2>
<p>谢谢你读到这里。今天，我演示了Node.js应用程序上下文中的依赖注入。我们还在一个实际项目中学会了使用TypeDI库实现依赖注入。要了解更多信息，请查看这个项目的<a href="https://docs.typestack.community/typedi/v/develop/01-getting-started" target="_blank" rel="noopener"> TypeDI文档</a>和<a href="https://github.com/Mohammad-Faisal/dependency-injection-nodejs" target="_blank" rel="noopener"> GitHub库</a>。</p>
<p>我希望你今天学到了新东西。祝你今天休息愉快！</p><div class="code-block code-block-23">
<div class="blog-plug inline-plug node-plug"><h2>200只<img src="../Images/61167b9d027ca73ed5aaf59a9ec31267.png" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2019/10/green-check.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" class=" jetpack-lazy-image" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/10/green-check.png"/> <noscript> <img data-lazy-fallback="1" src="../Images/61167b9d027ca73ed5aaf59a9ec31267.png" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/10/green-check.png"/> </noscript>显示器出现故障，生产中网络请求缓慢</h2><p>部署基于节点的web应用程序或网站是容易的部分。确保您的节点实例继续为您的应用程序提供资源是事情变得更加困难的地方。如果您对确保对后端或第三方服务的请求成功感兴趣，</p><a href="https://lp.logrocket.com/blg/node-signup" target="_blank">try LogRocket</a><p>. </p><a class="signup" href="https://lp.logrocket.com/blg/node-signup" target="_blank" rel="noopener noreferrer"><img src="../Images/cae72fd2a54c5f02a6398c4867894844.png" alt="LogRocket Network Request Monitoring" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2019/12/network-request-filter-2-1.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" class=" jetpack-lazy-image" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/12/network-request-filter-2-1.png"/><noscript><img data-lazy-fallback="1" src="../Images/cae72fd2a54c5f02a6398c4867894844.png" alt="LogRocket Network Request Monitoring" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/12/network-request-filter-2-1.png"/></noscript></a><a href="https://lp.logrocket.com/blg/node-signup" target="_blank" rel="noopener noreferrer">https://logrocket.com/signup/</a><p>LogRocket 就像是网络和移动应用程序的DVR，记录下用户与你的应用程序交互时发生的一切。您可以汇总并报告有问题的网络请求，以快速了解根本原因，而不是猜测问题发生的原因。</p><p>LogRocket检测您的应用程序以记录基线性能计时，如页面加载时间、到达第一个字节的时间、慢速网络请求，还记录Redux、NgRx和Vuex操作/状态。</p><a class="signup" href="https://lp.logrocket.com/blg/node-signup" target="_blank" rel="noopener noreferrer">Start monitoring for free</a><p>. </p></div>
</div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
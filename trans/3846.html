<html>
<head>
<title>Building an Android app with GraphQL </title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>使用GraphQL构建Android应用程序</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/building-android-app-graphql/#0001-01-01">https://blog.logrocket.com/building-android-app-graphql/#0001-01-01</a></blockquote><div><article class="article-post">
<p>在经典的客户端-服务器架构中，Android应用程序可以充当前端客户端，依赖来自后端服务的数据。通常，开发人员依靠<a href="https://blog.logrocket.com/graphql-vs-grpc-vs-rest-choosing-right-api/"> REST和GraphQL </a> web规范来促进这种架构中的通信。</p>
<p>在本文中，我们将讨论GraphQL以及它优于REST的地方，最后，我们将编写一些代码来将Android应用程序连接到GraphQL服务器。</p>
<p><em>向前跳转:</em></p>

<h2 id="graphql">GraphQL是什么？</h2>
<p>GraphQL 是一种查询语言，用于从后端服务获取和变更数据。当与GraphQL服务交互时，只有一个入口点(URL)用于检索和变更数据。你可能会问，这怎么可能？嗯，有了<a href="https://blog.logrocket.com/graphql-queries-in-simple-terms/"> GraphQL查询</a>，你可以做任何简单的事情。</p>
<p>在向您展示一个示例查询之前，让我们先来讨论三个GraphQL操作符及其用法。GraphQL操作符用于在服务器上执行<a href="https://blog.logrocket.com/configuring-cloud-firestore-in-adonisjs-for-crud-requests/"> CRUD请求</a>，并监听事件。GraphQL中有三个主要的操作符:<a href="https://blog.logrocket.com/graphql-vs-grpc-vs-rest-choosing-right-api/#:~:text=values%20when%20queried.-,Defining%20queries%2C%20mutations%2C%20and%20subscriptions%20with%20schemas,-As%20mentioned%20before"> <code>Query</code>、<code>Mutation</code>和<code>Subscription</code> </a>:</p>
<ul>
<li><code>Query</code>:这对于从服务器获取数据很有用</li>
<li><code>Mutation</code>:该操作符用于创建、编辑和删除服务器上的数据</li>
<li>这个操作符并不出现在普通的用例中。但是，在实现客户机和服务器之间的实时通信时，它会很方便</li>
</ul>
<h3 id="benefits-graphql">GraphQL的优势</h3>
<p>首先，GraphQL解决了过度提取和提取不足的问题。GraphQL优于REST等其他web规范，因为客户端只能获取它需要的数据。</p>
<p>如果事情听起来仍然模糊不清，不要担心——当我们编写一些代码时，你会有所顿悟😊。</p>
<h2 id="starter-project">设置起始项目</h2>
<p>为了让事情变得更有趣，我们将使用<a href="https://docs.github.com/en/graphql"> GitHub GraphQL API </a>重构一个GitHub项目。</p>
<p>以下是我们将要重构的项目的一些注意事项:</p>

<h3 id="clone-project">克隆项目</h3>
<p>继续克隆这个GitHub Lagos项目示例应用程序，如下所示:</p>
<pre class="language-shell hljs">git clone https://github.com/Lamouresparus/GithubLagosProject.git
</pre>
<p>如果克隆成功，在<a href="https://developer.android.com/studio"> Android Studio </a>中打开项目并运行。如果一切正常，您将看到与下面截图中相同的内容:</p>
<p><img data-attachment-id="155958" data-permalink="https://blog.logrocket.com/building-android-app-graphql/attachment/graphql-android-studio/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2023/01/graphql-android-studio.png" data-orig-size="730,416" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Building an Android app with GraphQL" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2023/01/graphql-android-studio-300x171.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2023/01/graphql-android-studio.png" decoding="async" class="aligncenter size-full wp-image-155958 jetpack-lazy-image" src="../Images/fd2e44a7bd5a8efb6e447d13ca17cff0.png" alt="Building an Android App With GraphQL" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2023/01/graphql-android-studio.png 730w, https://blog.logrocket.com/wp-content/uploads/2023/01/graphql-android-studio-300x171.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2023/01/graphql-android-studio.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2023/01/graphql-android-studio.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="155958" data-permalink="https://blog.logrocket.com/building-android-app-graphql/attachment/graphql-android-studio/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2023/01/graphql-android-studio.png" data-orig-size="730,416" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Building an Android app with GraphQL" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2023/01/graphql-android-studio-300x171.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2023/01/graphql-android-studio.png" decoding="async" loading="lazy" class="aligncenter size-full wp-image-155958" src="../Images/fd2e44a7bd5a8efb6e447d13ca17cff0.png" alt="Building an Android App With GraphQL" srcset="https://blog.logrocket.com/wp-content/uploads/2023/01/graphql-android-studio.png 730w, https://blog.logrocket.com/wp-content/uploads/2023/01/graphql-android-studio-300x171.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2023/01/graphql-android-studio.png"/></noscript>
<h3 id="gradle-dependencies">添加必要的梯度依赖项</h3>
<pre class="language-shell-hljs">implementation("com.squareup.okhttp3:logging-interceptor:4.10.0")
implementation("com.apollographql.apollo3:apollo-runtime:3.6.2")
</pre>
<p>需要<code>Logging</code>拦截器来帮助将网络流量打印到<code>Logcat</code>窗口。第二个依赖项，<a href="https://blog.logrocket.com/graphql-local-state-management-apollo/"> Apollo </a>，是一个在Android上使用GraphQL APIs的库。Apollo之于GraphQL，就像return之于REST一样。</p>
<h2 id="migration-rest-graphql">从REST迁移到GraphQL</h2>
<p>迁移可能是一项令人生畏的任务，尤其是如果您是一项技术的新手，并且在这项工作中有许多接触点。然而，在代码库结构良好和模块化的情况下，迁移变得不那么复杂和危险。您可以安全地定位和更新组件，而不会影响整个系统。</p>
<p>在接下来的几个步骤中，我将向您展示如何迁移我们的项目以使用GitHub GraphQL API。</p>
<h3 id="replace-retrofit-apollo-client">用<code>ApolloClient</code>替换改装参考</h3>
<p>为了使用<code>ApolloClient</code>与GitHub GraphQL API通信，我们将需要进行迁移。首先，在<code>com.githublagos.di</code>中找到<code>NetworkModule</code>,用以下代码更新文件:</p>
<pre class="language-kotlin hljs">@Module
@InstallIn(SingletonComponent::class)
class NetworkModule {

    @Provides
    @Singleton
    fun okhttpClient(): OkHttpClient {
       val logging = HttpLoggingInterceptor()
           .apply { level = HttpLoggingInterceptor.Level.BODY  }
       return OkHttpClient.Builder()
           .addInterceptor(AuthInterceptor())
           .addInterceptor(logging)
           .build()
    }

    @Provides
    @Singleton
    fun provideApollo(client: OkHttpClient) : ApolloClient {
        return ApolloClient.Builder()
            .serverUrl("https://api.github.com/graphql")
            .okHttpClient(client).build()
    }
}
</pre>
<p>从上面的代码块来看，有两种对象类型:<code>OkHttpClient</code>和<code>ApolloClient</code>。这些被声明为依赖项，将在运行时通过带有句柄的<a href="https://blog.logrocket.com/kotlin-dependency-injection-koin-vs-hilt/">依赖项注入</a>来提供。</p>
<p><code>OkHttpClient</code>是一个HTTP引擎，由<code>ApolloClient</code>用于发出网络请求，而<code>ApolloClient</code>本身是一个库，用于向GraphQL服务器发起网络请求。</p>
<p>请注意我是如何用客户拦截器(<code>AuthInterceptor</code>)定制<code>OkHttpClient</code>的。我包含了拦截器来修改HTTP请求，使其包含一个授权头。</p>
<p><a href="https://docs.github.com/en/graphql/guides/forming-calls-with-graphql#authenticating-with-graphql"> GitHub GraphQL服务器</a>要求每个请求都使用正确的作用域进行认证。请参见下面不言自明的代码块:</p>
<pre class="language-kotlin hljs">class AuthInterceptor : Interceptor {
    override fun intercept(chain: Interceptor.Chain): Response {
        val request = chain.request().newBuilder()
            .addHeader("Authorization", "token put_your_personal_access_token_here")

       return chain.proceed(request.build())
    }
}
</pre>
<h3 id="define-graphql-schema-queries">定义GraphQL模式和<code>Queries</code></h3>
<p><a href="https://blog.logrocket.com/3-annotations-to-use-in-your-graphql-schema/"> GraphQL模式</a>定义了GitHub的API支持的所有对象类型。此模式中的对象类型用于构建发出网络请求的查询。按照以下步骤将模式包含在项目中:</p>
<ul>
<li>在<code>app/src/main</code>下创建一个<code>graphql</code>文件夹</li>
<li>下载<a href="https://docs.github.com/public/schema.docs.graphql"> GitHub模式</a></li>
<li>将您下载的模式移动到我们在第一步中创建的文件夹中</li>
</ul>
<p>现在，我们将构建我们的<code>query</code>来指定我们希望服务器返回给我们的数据。在同一个<code>GraphQL</code>文件夹中，创建一个<code>GetUsers.graphql</code>文件并粘贴到下面的代码块中:</p>
<pre class="language-graphql hljs">query GetUsers($query: String!, $pageSize:Int!, $after: String) {
    search(query: $query, type: USER, first: $pageSize, after: $after) {
        nodes {
            ... on User {
                avatarUrl
                login
                url
            }
        }
        pageInfo {
            endCursor
            hasNextPage
        }
    }
}
</pre>
<p>简而言之，上面的代码块是一个查询，将用于从GitHub GraphQL服务器请求用户列表。我们将在下面检查这个查询的每个组成部分。</p>
<p><code>GetUsers</code>是接受三个参数的查询:</p>
<ul>
<li><code>Query String</code>:这可以是像<code>location</code>、<code>language</code>等查询，以帮助缩小搜索结果的范围，满足我们的特定需求</li>
<li><code>Page Size</code>:这是我们希望服务器在每次搜索查询中返回的用户数量</li>
<li><code>After String</code>:这个字符串有助于在使用GitHub GraphQL服务器时实现<a href="https://blog.logrocket.com/ux-design/pagination-vs-infinite-scroll-ux/">分页</a>。该值可以是最后一个用户对象的游标ID。通常，对于初始搜索查询，我们将其设置为<code>null</code></li>
</ul>
<p><code>nodes</code>基本上是一个搜索项列表，在我们的GitHub模式中定义为<code>[SearchResultItem]</code>。<code>SearchResultItem</code>是一个联合类型，它属于模式中定义的其他几种类型。在我们的例子中，我们对<code>User</code>类型感兴趣。在<code>User</code>对象上的尾随语法是我们如何指定我们感兴趣的<code>SearchResultItem</code>类型。</p>
<p><code>pageInfo</code>请求基本页面信息。我们将使用返回的数据来实现分页。<code>endCursor</code>是当前页面最后一个<code>User</code>对象的光标ID。<code>hasNextPage</code>是一个布尔值，它评估是否有另一个用户页面。</p>
<p>现在，我们已经定义了一个GraphQL文件，但是我们不能在Kotlin代码中直接使用它。我们必须为代码生成重新构建项目，并创建文件的Kotlin表示。如果Gradle构建成功，您会发现在您的构建目录中创建了<code>GetUsersQuery</code>:</p>
<p><img data-attachment-id="155960" data-permalink="https://blog.logrocket.com/building-android-app-graphql/attachment/android-get-users-graphql/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2023/01/android-get-users-graphql.png" data-orig-size="730,378" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Example of the GetUser file in Android app with GraphQL" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2023/01/android-get-users-graphql-300x155.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2023/01/android-get-users-graphql.png" decoding="async" class="aligncenter size-full wp-image-155960 jetpack-lazy-image" src="../Images/a0cc6f2e8f066a8ff925a39203922c60.png" alt="Example of the GetUser File in Android App With GraphQL" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2023/01/android-get-users-graphql.png 730w, https://blog.logrocket.com/wp-content/uploads/2023/01/android-get-users-graphql-300x155.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2023/01/android-get-users-graphql.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2023/01/android-get-users-graphql.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="155960" data-permalink="https://blog.logrocket.com/building-android-app-graphql/attachment/android-get-users-graphql/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2023/01/android-get-users-graphql.png" data-orig-size="730,378" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Example of the GetUser file in Android app with GraphQL" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2023/01/android-get-users-graphql-300x155.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2023/01/android-get-users-graphql.png" decoding="async" loading="lazy" class="aligncenter size-full wp-image-155960" src="../Images/a0cc6f2e8f066a8ff925a39203922c60.png" alt="Example of the GetUser File in Android App With GraphQL" srcset="https://blog.logrocket.com/wp-content/uploads/2023/01/android-get-users-graphql.png 730w, https://blog.logrocket.com/wp-content/uploads/2023/01/android-get-users-graphql-300x155.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2023/01/android-get-users-graphql.png"/></noscript>
<h3 id="refactor-github-api">重构GitHub API</h3>
<p>在前面的步骤中，我们创建了<code>GetUsersQuery</code>和<code>ApolloClient</code>的<a href="https://blog.logrocket.com/youre-wrong-about-singletons/">单例实例</a>。这些对象将用于在GitHub GraphQL服务器上执行搜索。将以下代码复制到您的IDE中:</p>
<pre class="language-kotlin hljs">class GithubApi @Inject constructor(
    private val apolloClient: ApolloClient
) {

    // const val QUERY_LOCATION = "location:lagos"

    suspend fun getUsers(
        location: String = QUERY_LOCATION,
        endCursor: String?,
        pageSize: Int
    ): UsersResponseModel {
        val nextCursor = Optional.presentIfNotNull(endCursor)

        val query = GetUsersQuery(location, pageSize, nextCursor)
        val response = apolloClient.query(query).execute()

        val cursor = response.data?.search?.pageInfo?.endCursor

        val users = response.data?.search?.nodes?.map {
            val userName = it?.onUser?.login.orEmpty()
            val avatar = it?.onUser?.avatarUrl.orEmpty()
            val htmlUrl = it?.onUser?.url.orEmpty()
            UserRemote(userName, avatar, htmlUrl)
        }?.filter { it.login.isNotEmpty() }.orEmpty()

        return UsersResponseModel(cursor, users)
    }
}
</pre>
<p>在上面的代码块中，我将<code>GithubApi</code>从一个接口重构为一个接受<code>ApolloClient</code>作为参数的类类型。这个对象负责执行<code>queries</code>、<code>mutations</code>和<code>subscriptions</code>。</p>
<p><code>getUsers</code>的<code>method</code>签名接受一个可空的<code>endCursor</code>参数，使其成为可选的。在Apollo GraphQL中，我们使用一个<code>Optional</code>类型来表示一个可选值。这个对象是一个<a href="https://blog.logrocket.com/guide-using-sealed-classes-kotlin/"> Kotlin密封的类</a>，它可以是<code>Present</code>或<code>Absent</code>。</p>
<p>通过一行代码，我们可以执行一个GraphQL查询，如下所示:<code>apolloClient.query(query).execute()</code>。</p>
<p>这将完成所有繁重的工作，返回一个包含GitHub用户列表和页面信息的响应。</p>
<h3 id="update-github">更新<code>GithubUserSource</code></h3>
<p>如果你能走到这一步，恭喜你！这是重构的最后一部分。我们希望分页源代码依赖于Apollo GraphQL来根据滚动请求执行多个查询。</p>
<p>首先，定位<code>GithubUserSource</code>并用下面的代码块修复突变:</p>
<pre class="language-kotlin hljs">class GithubUserSource @Inject constructor(private val api: GithubApi) :
    PagingSource&lt;String, UserDomain&gt;() {

    override fun getRefreshKey(state: PagingState&lt;String, UserDomain&gt;): String? {
        return null
    }

    override suspend fun load(params: LoadParams&lt;String&gt;): LoadResult&lt;String, UserDomain&gt; {
        return try {
            val previousKey = params.key
            val result  = api.getUsers(pageSize = PAGE_SIZE, endCursor = previousKey )
            val nextKey = result.endCursor
            val userList = result.items.map { it.mapToDomain() }
            LoadResult.Page(
                data = userList,
                prevKey = previousKey,
                nextKey = nextKey
            )
        } catch (exception: IOException) {
            return LoadResult.Error(exception)
        } catch (exception: HttpException) {
            return LoadResult.Error(exception)
        } catch (exception :Exception){
            return LoadResult.Error(exception)
        }
    }
}
</pre>
<p>前者和新实现的主要区别在于<code>key</code>类型。因为我们使用最后一个用户对象的光标来方便我们的分页，所以我们将<code>PagingSource</code>定义为有一个<code>string</code>键，而不是一个<code>integer</code>。</p>
<p>当请求将更多内容加载到<code>listview</code>时，调用<code>load()</code>方法。每当这个调用发生时，我们从服务器获取用户，指定<code>page size</code>和<code>end cursor</code>作为参数。</p>
<p>在第一次调用时，<code>previousKey</code>将是<code>null</code>,因为在这种情况下，在分页源中没有缓存<code>nextKey</code>。如果操作成功，我们将得到一个包含用户信息和<code>end cursor</code>的响应。这个响应被映射到一个<code>LoadResult.Page</code>对象，并被提供给分页源。</p>
<p>瞧啊。我们已经使用<code>ApolloClient</code>将一个基于REST的Android项目重构为GraphQL。现在，您应该能够成功地构建和运行项目了。用户的屏幕上不会有可见的变化，因为我们只改变了数据源实现。</p>
<h2>结论</h2>
<p>从我作为移动开发者的角度来看，GraphQL在Android上很容易使用。我能想到的唯一学习曲线是查询语言的语法。除此之外，简直易如反掌！GraphQL <a href="https://graphql.org/learn/">文档</a>是了解更多信息的好地方。</p><div class="code-block code-block-32">
<div class="blog-plug inline-plug kotlin-plug"><h2>LogRocket :即时重现你的安卓应用中的问题。</h2><a class="signup" href="https://lp.logrocket.com/blg/kotlin-signup" target="_blank" rel="noopener noreferrer"><img class="alignnone size-full wp-image-46 jetpack-lazy-image" src="../Images/b5ae4bd0ecde7aa9d5288746416d5e18.png" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2022/11/react-native-plug_android-1.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/11/react-native-plug_android-1.png"/><noscript><img data-lazy-fallback="1" class="alignnone size-full wp-image-46" src="../Images/b5ae4bd0ecde7aa9d5288746416d5e18.png" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/11/react-native-plug_android-1.png"/></noscript></a><p><a href="https://lp.logrocket.com/blg/kotlin-signup" target="_blank" rel="noopener noreferrer"> LogRocket </a>是一款Android监控解决方案，可以帮助您即时重现问题，确定bug的优先级，并了解您的Android应用程序的性能。</p><p>LogRocket还可以向你展示用户是如何与你的应用程序互动的，从而帮助你提高转化率和产品使用率。LogRocket的产品分析功能揭示了用户不完成特定流程或不采用新功能的原因。</p><p>开始主动监控您的Android应用程序— <a class="signup" href="hhttps://lp.logrocket.com/blg/kotlin-signup" target="_blank" rel="noopener noreferrer">免费试用LogRocket】。</a></p></div>
</div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
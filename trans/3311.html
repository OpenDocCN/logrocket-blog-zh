<html>
<head>
<title>Introducing Zephyr: Tailwind CSS for React Native - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>介绍泽法:React Native - LogRocket博客的顺风CSS</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/zephyr-tailwind-css-react-native/#0001-01-01">https://blog.logrocket.com/zephyr-tailwind-css-react-native/#0001-01-01</a></blockquote><div><article class="article-post">
<p>用普通的CSS构建复杂的网络应用可能是一个令人生畏的挑战。因此，开发人员倾向于使用流行的样式库，如Bootstrap和Tailwind CSS，以缩短开发周期。</p>
<p>与web上的样式类似，使用React Native中的内置样式功能可能是一个缓慢而费力的过程。有类似于Bootstrap和Tailwind CSS的解决方案可用于React Native，其中一个这样的解决方案是React Native泽法。React Native泽法是一个受CSS启发的风格库，旨在提高您的开发速度，让React Native应用程序运行得更快。</p>
<p>还带来了Tailwind CSS体验React Native。如果你熟悉Tailwind CSS，你可以很容易地找到泽法，因为两者有相似之处。本文将向您介绍React Native泽法的主要特性。</p>

<h2 id="what-is-react-native-zephyr">泽法本土的反应是什么？</h2>
<p>React Native泽法是一个受顺风CSS启发的React原生样式库。它在React Native的上下文中实现了Tailwind CSS的一些核心思想，没有任何原生依赖。</p>
<p>虽然在撰写本文时，React Native泽法的一些关键特性仍在积极开发中，但以下是这些特性。</p>
<ul>
<li>它提供了一套现成的内置样式实用程序</li>
<li>它带有一个可扩展的默认主题</li>
<li>它支持开箱即用的黑暗模式</li>
</ul>
<p>上述特性使React Native泽法成为其他库中内置样式功能的更好替代方案。上面的功能绝不是详尽的，我建议查看官方文档以了解React Native泽法的更多内置功能。</p>
<p>React Native具有与web不直接兼容的样式功能。因此，可能很难直接将Bootstrap和Tailwind CSS等专注于web的样式解决方案转移到React Native。然而，由于两个库之间的相似性，您的一些顺风CSS技能集可以转移到React Native泽法。</p>
<p>如果您有一个现有的React本机项目，您可以从npm包注册表安装React本机泽法，如下所示:</p>
<pre class="language-shell hljs"># Using npm
npm i react-native-zephyr

# Using yarn
yarn add react-native-zephyr

# Using pnpm
pnpm add react-native-zephyr
</pre>
<h2 id="how-to-use-react-native-zephyr">如何使用React Native泽法</h2>
<p>React Native泽法使用<code>StyleProvider</code>组件来管理应用程序的配色方案等。要开始使用<code>react-native-zephyr</code>，请导入<code>StyleProvider</code>组件，并将您的应用程序包装在其中。</p>
<pre class="language-javascript hljs">import { StyleProvider } from "react-native-zephyr";
export const App = () =&gt; (
  &lt;StyleProvider&gt;
    { /* The rest of your app goes here */}
  &lt;/StyleProvider&gt;
);
</pre>
<p>React Native泽法导出了用于生成核心样式实用程序的<code>createStyleBuilder</code>函数。调用<code>createStyleBuilder</code>将返回<code>styles</code>、<code>useStyles</code>和<code>makeStyledComponent</code>实用函数。这些造型实用程序函数提供了React Native泽法的不同造型方法。</p>
<p>为了便于维护，React Native泽法建议创建一个专用的工具文件来管理您的造型工具。下面的代码显示了React Native泽法的基本样式实用程序文件。</p>
<pre class="language-javascript hljs">import { createStyleBuilder } from "react-native-zephyr";
export const { styles, useStyles, makeStyledComponent } = createStyleBuilder();
</pre>
<p><code>createStyleBuilder</code>函数也有一个可选参数，尽管我们在上面的例子中没有传递它，它可以用来覆盖或扩展默认主题。如果您像我们一样不带参数地调用<code>createStyleBuilder</code>，React Native泽法将使用默认主题。在接下来的章节中，我们将学习如何覆盖和扩展默认主题。</p>
<p>您可以将需要的内容从该实用程序文件导出到应用程序的其他组件。如上例所示，核心的样式工具是<code>styles</code>和<code>makeStyledComponent</code>函数以及<code>useStyles</code>钩子。</p>
<h2 id="how-to-use-the-styling-methods-in-react-native-zephyr">如何使用React Native泽法中的造型方法</h2>
<p>如前一节所述，React Native泽法建议创建一个专用的<code>styles.js</code>实用程序文件来管理其实用程序函数。调用<code>createStyleBuilder</code>函数返回<code>styles</code>和<code>makeStyledComponent</code>函数以及<code>useStyles</code>钩子。您可以将这些实用函数从<code>styles.js</code>文件导出到应用程序中需要它们的组件。</p>
<pre class="language-javascript hljs">import { createStyleBuilder } from "react-native-zephyr";
export const { styles, useStyles, makeStyledComponent } = createStyleBuilder();
</pre>
<p><code>styles</code>函数接受React本机泽法类名的数组，并返回React本机样式对象。您作为参数传递的类名来自您的主题和处理程序。您可以像这样使用<code>styles</code>函数:</p>
<pre class="language-javascript hljs">export default function App() {
  return (
    &lt;View style={styles("flex:1", "bg:black")} &gt;
      &lt;Text style={styles("color:white", "text:5xl")}&gt;
        Hello World
      &lt;/Text&gt;
    &lt;/View&gt;
  );
}
</pre>
<p>请注意，<code>styles</code>功能没有对黑暗模式的现成支持。所以只适合一次性的款式。</p>
<p>您还可以在React Native泽法中使用<code>makeStyledComponent</code>包装器来设计样式。顾名思义，<code>makeStyledComponent</code>是一个制作样式化组件的实用函数。<code>makeStyledComponent</code>实用函数将一个组件作为参数，并为该组件添加<code>class</code>和<code>darkClass</code>道具。它返回可以向其传递样式类的包装组件。</p>
<p>如上所述，最好在您的<code>styles.js</code>文件中创建样式化的组件，并像这样导出它们:</p>
<pre class="language-javascript hljs">export const StyledText = makeStyledComponent(Text);
export const StyledView = makeStyledComponent(View);
</pre>
<p><code>useStyles</code>钩子内部使用<code>styles</code>方法。与<code>styles</code>方法不同，<code>useStyles</code>钩子支持黑暗模式。像任何其他React挂钩一样，您只能将<code>useStyles</code>挂钩与功能组件和另一个挂钩一起使用——它返回一个可以传递给React本地元素的样式对象。</p>
<p>下面的代码演示了如何使用<code>useStyles</code>钩子。</p>
<pre class="language-javascript hljs">export default function App() {
  const wrapperStyles = useStyles({
    classes: ["flex:1", "bg:black"],
  });
  const textStyles = useStyles({
    classes: ["color:white", "text:5xl"],
  });
  return (
    &lt;View style={wrapperStyles}&gt;
      &lt;Text style={textStyles}&gt;Hello World&lt;/Text&gt;
      &lt;StatusBar style="auto" /&gt;
    &lt;/View&gt;
  );
}
</pre>
<h2 id="the-default-theme-in-react-native-zephyr">《反应土著泽法》中的默认主题</h2>
<p>React Native泽法有一个默认的主题，你可以不用配置就可以使用——我们从一开始就在使用它。默认主题的灵感来源于Tailwind CSS中的默认主题；如果默认主题不符合您的需求，您也可以扩展它。</p>
<p>默认主题带有几个样式约束；泽法本地使用它来生成样式类。</p><div class="code-block code-block-54">
<hr/>
<h3>更多来自LogRocket的精彩文章:</h3>

<hr/></div>
<p>如下例所示，当您将<code>pl:56</code>样式应用到元素时，React Native泽法将添加<code>224px</code>的左填充。在<code>pl:56</code>样式类中，<code>pl</code>是<code>paddingLeft</code>属性，<code>56</code>是默认的主题间距约束，当React Native泽法将样式转换为React Native style对象时，其大小为<code>224px</code>。文档中有一个默认主题约束及其相应比例的完整列表。</p>
<pre class="language-javascript hljs">&lt;StyledText classes={["pl:56"]}&gt;Hello World&lt;/StyledText&gt;
</pre>
<p>React Native泽法使用<code>spacing</code>约束来生成边距和填充，以及调整样式类的大小。默认主题包括其他几个约束，比如<code>opacities</code>和<code>letterSpacing</code>约束。</p>
<h2 id="extend-and-override-the-default-theme-in-react-native-zephyr">扩展并覆盖React Native泽法中的默认主题</h2>
<p>虽然它附带了一个默认的主题，但是React Native泽法允许您扩展和覆盖它。前面一节中介绍的<code>createStyleBuilder</code>函数将一个可选对象作为参数。该对象具有<code>overrideTheme</code>和<code>extendTheme</code>属性，分别用于覆盖和扩展默认主题。这两个属性的值可以是对象或函数。</p>
<p>如果您将<code>overrideTheme</code>属性的值设置为一个对象，如下例所示，React Native泽法将覆盖默认主题中的颜色。颜色<code>dark</code>、<code>light</code>和<code>brandColorPalette</code>将覆盖下面示例中的默认颜色。</p>
<pre class="language-javascript hljs">export const { makeStyledComponent, styles, useStyles } = createStyleBuilder({
 overrideTheme: {
  colors: {
    dark: "#737373",
    light: "#e5e5e5",
    brandColorPalette: "#a1323e",
  }
 }
});
</pre>
<p>您可以将<code>overrideTheme</code>属性的值设置为返回主题约束对象的函数，如下面的代码所示。当您将<code>overrideTheme</code>属性的值设置为一个函数时，您将可以访问基本字体大小。</p>
<pre class="language-javascript hljs">export const { makeStyledComponent, styles, useStyles } = createStyleBuilder({
  baseFontSize: 18,
  overrideTheme: ({ baseFontSize }) =&gt; {
    return {
      colors: {
        dark: "#737373",
        light: "#e5e5e5",
        brandColorPalette: "#a1323e",
      },
      spacing: {
        enormous: baseFontSize * 100,
      },
    };
  },
});
</pre>
<p>在上面的例子中，React Native泽法将用您在自定义主题中提供的颜色和间距覆盖默认主题中的颜色和间距。</p>
<p>您可以类似地使用<code>extendTheme</code>——与<code>overrideTheme</code>属性不同，<code>extendTheme</code>属性扩展了默认主题，而不是覆盖它。</p>
<pre class="language-javascript hljs">export const { makeStyledComponent, styles, useStyles } = createStyleBuilder({
  extendTheme: {
    colors: {
      brandColorPalette: "#a1323e",
    },
  },
});
</pre>
<p>如果您想要访问基本字体大小，您也可以将<code>extendTheme</code>属性的值设置为一个函数，该函数返回一个对象，如下所示:</p>
<pre class="language-javascript hljs">export const { makeStyledComponent, styles, useStyles } = createStyleBuilder({
  baseFontSize: 12,
  extendTheme: ({ baseFontSize }) =&gt; {
    return {
      spacing: {
        enormous: baseFontSize * 100,
      },
      colors: {
        brandColorPalette: "#a1323e",
      },
    };
  },
});
</pre>
<h2 id="conclusion">结论</h2>
<p>诸如Bootstrap和Tailwind CSS之类的样式解决方案很受欢迎，因为它们提高了开发速度。React Native泽法正试图将顺风CSS体验引入React Native，如果你已经熟悉顺风CSS，学习起来会很容易。</p>
<p>反应泽法本地配备了一个默认的主题，提供了一套慷慨的价值观，让你出发。如果默认主题不能满足您的需求，您可以按照本文所述扩展或覆盖它。虽然在撰写本文时还很年轻，但还是值得探索一下React Native泽法，看看它是否适合您——希望您会发现它对您的项目有用。</p>
<p>React Native泽法有几个我们在本文中没有涉及的特性。更多特性请查看官方文档。请在下面的评论区告诉我你的想法。</p><div class="code-block code-block-18">
<div class="blog-plug inline-plug react-native-plug"><h2><a href="https://lp.logrocket.com/blg/react-native-signup"> LogRocket </a>:即时重现React原生应用中的问题。</h2><a class="signup" href="https://lp.logrocket.com/blg/react-native-signup" target="_blank" rel="noopener noreferrer"><img class="alignnone size-full wp-image-46 jetpack-lazy-image" src="../Images/110055665562c1e02069b3698e6cc671.png" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2021/10/react-native-plug_v2-2.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2021/10/react-native-plug_v2-2.png"/><noscript><img data-lazy-fallback="1" class="alignnone size-full wp-image-46" src="../Images/110055665562c1e02069b3698e6cc671.png" data-original-src="https://blog.logrocket.com/wp-content/uploads/2021/10/react-native-plug_v2-2.png"/></noscript></a><p><a href="https://lp.logrocket.com/blg/react-native-signup" target="_blank" rel="noopener noreferrer"> LogRocket </a>是一款React原生监控解决方案，可帮助您即时重现问题、确定bug的优先级并了解React原生应用的性能。</p><p>LogRocket还可以向你展示用户是如何与你的应用程序互动的，从而帮助你提高转化率和产品使用率。LogRocket的产品分析功能揭示了用户不完成特定流程或不采用新功能的原因。</p><p>开始主动监控您的React原生应用— <a class="signup" href="https://lp.logrocket.com/blg/react-native-signup" target="_blank" rel="noopener noreferrer">免费试用LogRocket】。</a></p></div>
</div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
<html>
<head>
<title>How to implement JWT authentication in NestJS - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>如何在NestJS - LogRocket博客中实现JWT认证</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/how-to-implement-jwt-authentication-nestjs/#0001-01-01">https://blog.logrocket.com/how-to-implement-jwt-authentication-nestjs/#0001-01-01</a></blockquote><div><article class="article-post">
<p>身份验证是任何应用程序最重要的方面之一。它通过在授权用户访问应用程序的不同部分之前验证用户来提高应用程序的安全性。认证还能让公司跟踪有多少人在使用他们的产品。</p>
<p>正确配置身份验证至关重要。事实上，<a href="https://owasp.org/www-project-top-ten/" target="_blank" rel="noopener">开放web应用程序安全项目(OWASP) </a>在其十大Web应用程序安全风险列表中确定了身份识别和身份验证失败。</p>
<p>本教程将演示在NestJS中实现JWT用户认证的一步一步的过程。</p>
<p><em>向前跳转:</em></p>

<h2 id="prerequisites">先决条件</h2>
<p>本教程是一个实践演示。要继续操作，请确保您安装了以下软件:</p>
<ul>
<li><a href="https://nodejs.org/" target="_blank" rel="noopener"> Node.js </a> v14及以上</li>
<li><a href="https://www.mongodb.com" target="_blank" rel="noopener"> MongoDB </a></li>
<li>全球安装的纱线；使用命令<code>npm install --global yarn</code></li>
</ul>
<h2 id="what-is-nestjs">什么是NestJS？</h2>
<p>NestJS是Node.js的服务器端应用程序框架，允许您创建可伸缩的高效应用程序。它用TypeScript编写，用Express.js构造，这是一个轻量级框架，它本身很棒，但缺乏结构。</p>
<p>Nest支持面向对象编程、函数式编程和函数式反应式编程。如果你希望你的应用程序后端有很多结构，这个框架是一个很好的选择。</p>
<p>Nest的语法和结构与Angular类似，Angular是一个前端框架。它还使用了类型脚本、服务和依赖注入，就像Angular一样。Nest使用模块和控制器，并允许您使用命令行界面为文件创建控制器。</p>
<h2 id="getting-started">入门指南</h2>
<p>要设置项目，首先需要使用以下命令全局安装Nest CLI:</p>
<pre class="language-javascript hljs">npm i -g @nestjs/cli
</pre>
<p>安装完成后，创建一个新项目，如下所示:</p>
<pre class="language-javascript hljs">nest new auth-with-nest
</pre>
<p>接下来，会提示您选择一个包管理器来安装依赖项。在这个演示中，我们将使用纱线。</p>
<p><img data-attachment-id="127102" data-permalink="https://blog.logrocket.com/how-to-implement-jwt-authentication-nestjs/attachment/terminal-yarn/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/08/terminal-yarn.png" data-orig-size="730,165" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Terminal Yarn" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/08/terminal-yarn-300x68.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/08/terminal-yarn.png" decoding="async" class="aligncenter size-full wp-image-127102 jetpack-lazy-image" src="../Images/71e01ff68bee0aa93ba337daa753e9fd.png" alt="Terminal Yarn" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2022/08/terminal-yarn.png 730w, https://blog.logrocket.com/wp-content/uploads/2022/08/terminal-yarn-300x68.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2022/08/terminal-yarn.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/08/terminal-yarn.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="127102" data-permalink="https://blog.logrocket.com/how-to-implement-jwt-authentication-nestjs/attachment/terminal-yarn/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/08/terminal-yarn.png" data-orig-size="730,165" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Terminal Yarn" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/08/terminal-yarn-300x68.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/08/terminal-yarn.png" decoding="async" loading="lazy" class="aligncenter size-full wp-image-127102" src="../Images/71e01ff68bee0aa93ba337daa753e9fd.png" alt="Terminal Yarn" srcset="https://blog.logrocket.com/wp-content/uploads/2022/08/terminal-yarn.png 730w, https://blog.logrocket.com/wp-content/uploads/2022/08/terminal-yarn-300x68.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/08/terminal-yarn.png"/></noscript>
<p>选择<code>yarn</code>并按下<strong>回车</strong>键。现在，等待Yarn安装运行应用程序所需的所有依赖项。</p>
<h2 id="setting-up-the-mongodb-database">设置MongoDB数据库</h2>
<p>要设置和连接数据库，使用以下命令安装Mongoose包、bcrypt和NestJS包装器:</p>
<pre class="language-javascript hljs">npm install --save @nestjs/mongoose @types/bcrypt mongoose bcrypt
</pre>
<p>现在，更新<code>app.module.ts</code>文件并设置Mongoose，就像这样:</p>
<pre class="language-javascript hljs">import { MongooseModule } from '@nestjs/mongoose';
@Module({
  imports: [MongooseModule.forRoot('mongodb://localhost/authentication')],
})
</pre>
<p>在上面的代码片段中，我们将<code>MongooseModule</code>导入到根<code>AppModule</code>中。</p>
<h2 id="creating-the-user-module">创建用户模块</h2>
<p>为了保持代码整洁有序，请通过运行以下命令，专门为NestJS CLI用户创建一个模块:</p>
<pre class="language-javascript hljs">nest g module users
</pre>
<p>上面的代码用一个<code>users.module.ts</code>文件和一个<code>app.module.ts</code>更新文件创建了一个用户文件夹。</p>
<h2 id="creating-the-user-schema">创建用户模式</h2>
<p>要创建用户模式，在<code>src/users</code>文件夹中创建一个<code>users.model.ts</code>文件，并添加以下代码:</p>
<pre class="language-javascript hljs">import { Prop, Schema, SchemaFactory } from '@nestjs/mongoose';
import { Document } from 'mongoose';

export type UserDocument = User &amp; Document;

@Schema()
export class User {
  @Prop()
  username: string;

  @Prop()
  password: string;
}

export const UserSchema = SchemaFactory.createForClass(User);
</pre>
<p>这里，我们用<code>@Schema()</code>装饰器和<code>@Prop()</code>装饰器定义了<code>User</code>模式的形状。</p>
<p>Mongoose会将模式映射到一个MongoDB集合。该模式定义了集合文档的形状。</p>
<p>现在，替换<code>user/user.module.ts</code>文件中的代码，并使用以下代码使<code>userSchema</code>在导入中可用:</p>
<pre class="language-javascript hljs">import { Module } from '@nestjs/common';
import { UsersService } from './user.service';
import { UsersController } from './user.controller';
import { MongooseModule } from "@nestjs/mongoose"
import { UserSchema } from "./user.model"

@Module({
  imports: [MongooseModule.forFeature([{ name: "user", schema: UserSchema }])],
  providers: [UsersService],
  controllers: [UsersController]
})
export class UserModule {}
</pre>
<h2 id="creating-the-user-service">创建用户服务</h2>
<p>创建用户模式后，运行以下命令创建用户服务:</p>
<pre class="language-javascript hljs">nest g service users
</pre>
<p>这段代码创建一个<code>users.service.ts</code>文件并更新<code>app.module.ts</code>文件。</p>
<p><strong> <em>注意，</em> </strong> <em>您可以选择手动创建您的文件和文件夹，但是NestJS CLI将通过自动更新必要的文件夹使您的生活更加轻松</em></p>
<p>现在，将以下代码添加到<code>users.service.ts</code>文件中:</p>
<pre class="language-javascript hljs">import { Injectable } from '@nestjs/common';
import { InjectModel } from '@nestjs/mongoose';
import { Model } from 'mongoose';
import { User, UserDocument } from './users.model';

@Injectable()
export class UsersService {
    constructor(@InjectModel('user') private readonly userModel: Model&lt;UserDocument&gt;) { }
    async createUser(username: string, password: string): Promise&lt;User&gt; {
        return this.userModel.create({
            username,
            password,
        });
    }
    async getUser(query: object ): Promise&lt;User&gt; {
        return this.userModel.findOne(query);
    }
}
</pre>
<p>这里，我们使用<code>@InjectModel()</code>装饰器将<code>userModel</code>注入到<code>UsersService</code>中。</p>
<h2 id="creating-the-user-controller">创建用户控制器</h2>
<p>现在让我们创建一个用户控制器来定义API路由:</p>
<pre class="language-javascript hljs">nest g service users
</pre>
<p>将代码添加到<code>users.controller.ts</code>文件:</p>
<pre class="language-javascript hljs">import { Body, Controller, Post, Get, Param } from '@nestjs/common';
import { UsersService } from './users.service';
import { User } from './users.model';
import * as bcrypt from 'bcrypt';

@Controller('auth')
export class UsersController {
    constructor(private readonly usersService: UsersService) { }

    @Post('/signup')
    async createUser(
        @Body('password') password: string,
        @Body('username') username: string,
    ): Promise&lt;User&gt; {
        const saltOrRounds = 10;
        const hashedPassword = await bcrypt.hash(password, saltOrRounds);
        const result = await this.usersService.createUser(
            username,
            hashedPassword,
        );
        return result;
    }
}
</pre>
<p>这里，我们定义了两个API路由，并使用了我们创建的服务。我们使用<code>bcrypt</code>来<a href="https://blog.logrocket.com/building-a-password-hasher-in-node-js/" target="_blank" rel="noopener">散列用户密码</a>。</p>
<h2 id="creating-the-auth-module">创建身份验证模块</h2>
<p>让我们首先创建一个auth模块，如下所示:</p>
<pre class="language-javascript hljs">nest g module auth
</pre>
<p>该命令将创建一个新文件夹<code>auth</code>，并带有一个<code>auth.module.ts</code>文件；它还会更新<code>app.module.ts</code>文件。</p>
<h2 id="configuring-jwt">配置JWT</h2>
<p>现在，让我们实现一个<a href="https://blog.logrocket.com/jwt-authentication-best-practices/" target="_blank" rel="noopener"> JSON web令牌来验证用户</a>进入应用程序。</p>
<p>要开始使用，请安装以下依赖项:</p>
<pre class="language-javascript hljs">npm install --save @nestjs/jwt passport-jwt
npm install --save-dev @types/passport-jwt
</pre>
<p>接下来，创建一个新文件<code>local.auth.ts</code>，并添加以下代码:</p>
<pre class="language-javascript hljs">import { Strategy } from 'passport-local';
import { PassportStrategy } from '@nestjs/passport';
import { Injectable, UnauthorizedException } from '@nestjs/common';
import { AuthService } from './auth.service';

@Injectable()
export class LocalStrategy extends PassportStrategy(Strategy) {
  constructor(private authService: AuthService) {
    super();
  }

  async validate(username: string, password: string): Promise&lt;any&gt; {
    const user = await this.authService.validateUser(username, password);
    if (!user) {
      throw new UnauthorizedException();
    }
    return user;
  }
}
</pre>
<p>这里，我们实现了一个<a href="https://www.passportjs.org/packages/passport-local/" target="_blank" rel="noopener"> passport-local策略</a>来认证JSON web令牌。默认情况下，passport-local策略期望请求体中有<code>username</code>和<code>password</code>属性。</p>
<p>我们还实现了<code>validate()</code>方法，Passport中间件将调用该方法使用一组适当的特定于策略的参数来验证用户。</p>
<p>接下来，用以下代码替换<code>AuthModule</code>中的代码:</p>
<pre class="language-javascript hljs">import { Module } from "@nestjs/common"
import { UserModule } from "src/user/user.module";
import { AuthService } from "./auth.service"
import { PassportModule } from "@nestjs/passport"
import { JwtModule } from '@nestjs/jwt';
import { AuthController } from './auth.controller';
import { UsersService } from "src/user/user.service";
import { MongooseModule } from "@nestjs/mongoose"
import { UserSchema } from "../user/user.model"
import { LocalStrategy } from './local-strategy';


@Module({
  imports: [UserModule, PassportModule, JwtModule.register({
    secret: 'secretKey',
    signOptions: { expiresIn: '60s' },
  }), MongooseModule.forFeature([{ name: "user", schema: UserSchema }])],
  providers: [AuthService, UsersService, LocalStrategy],
  controllers: [AuthController],
})
export class AuthModule { }
</pre>
<p>这里，我们将<code>PassportModule</code>和<code>JwtModule</code>导入到导入数组中。然后，我们使用<code>register</code>方法注册JWT，提供秘密和到期时间。</p>
<p>我们还使<code>UserSchema</code>在导入中可用，并将<code>UserService</code>和我们的<code>LocalStrategy</code>添加到提供者数组中。</p>
<p><strong> <em>注意，</em> </strong> <em>为了安全起见，总是把你的JWT秘密保存在一个环境变量里</em></p>
<h2 id="creating-the-auth-service-and-controller">创建授权服务和控制器</h2>
<p>现在，让我们向应用程序添加身份验证功能。</p>
<p>配置好JWT和护照后，运行以下命令在<code>auth</code>文件夹中创建<code>auth.service.ts</code>和<code>auth.controller.ts</code>文件。：</p>
<pre class="language-javascript hljs">nest generate service auth
nest generate controller auth
</pre>
<p>接下来，打开<code>auth/auth.service.ts</code>文件，用下面的代码验证用户:</p>
<pre class="language-javascript hljs">import { Injectable, NotAcceptableException } from '@nestjs/common';
import { UsersService } from 'src/user/user.service';
import * as bcrypt from 'bcrypt';
import { JwtService } from '@nestjs/jwt';

@Injectable()
export class AuthService {
    constructor(private readonly usersService: UsersService, private jwtService: JwtService) { }
    async validateUser(username: string, password: string): Promise&lt;any&gt; {
        const user = await this.usersService.getUser({ username });
        if (!user) return null;
        const passwordValid = await bcrypt.compare(password, user.password)
        if (!user) {
            throw new NotAcceptableException('could not find the user');
        }
        if (user &amp;&amp; passwordValid) {
            return user;
        }
        return null;
    }
    async login(user: any) {
        const payload = { username: user.username, sub: user._id };
        return {
            access_token: this.jwtService.sign(payload),
        };
    }
}
</pre>
<p>这里，我们创建了<code>validateUser</code>方法来检查来自<code>user.model</code>的用户是否与来自数据库的用户记录相匹配。如果不匹配，该方法返回一个<code>null</code>值。</p>
<p>我们还创建了<code>login</code>方法，它使用<code>jwtService.sign</code>方法为来自<code>LocalStrategy</code>的<code>validate</code>返回的用户生成一个JWT访问令牌。</p>
<p>现在，将下面的代码片段添加到<code>auth/auth.controller.ts</code>文件中，为用户<code>login</code>创建一条路线。</p>
<pre class="language-javascript hljs">import { Controller, Request, Post, UseGuards } from '@nestjs/common';
import { AuthService } from './auth.service';
import { AuthGuard } from '@nestjs/passport';

@Controller()
export class AuthController {
    constructor(private authService: AuthService) { }

    @UseGuards(AuthGuard('local'))
    @Post('auth/login')
    async login(@Request() req) {
        return this.authService.login(req.user);
    }
}
</pre>
<p>这里，当用户请求登录路径时，我们使用了<code>@UseGuards()</code>装饰器来加强认证。使用<code>AuthGuard</code>类，我们能够使用<code>local</code>策略对用户进行身份验证。</p>
<h2 id="testing-the-application">测试应用程序</h2>
<p>现在让我们使用Postman测试应用程序。我们从<code>signup route</code>开始。</p>
<p>首先，启动应用程序:</p>
<pre class="language-javascript hljs">npm run start
</pre>
<p>接下来，打开Postman，通过向端点发送post请求来测试注册路由。<code>localhost:3000/users/signup</code>。</p>
<p><img data-attachment-id="127105" data-permalink="https://blog.logrocket.com/how-to-implement-jwt-authentication-nestjs/attachment/postman-signup-route/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/08/postman-signup-route.png" data-orig-size="730,488" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Postman signup route" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/08/postman-signup-route-300x201.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/08/postman-signup-route.png" decoding="async" class="aligncenter size-full wp-image-127105 jetpack-lazy-image" src="../Images/da22874c287cd5b71ce45c0642ac8788.png" alt="Postman Signup Route" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2022/08/postman-signup-route.png 730w, https://blog.logrocket.com/wp-content/uploads/2022/08/postman-signup-route-300x201.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2022/08/postman-signup-route.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/08/postman-signup-route.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="127105" data-permalink="https://blog.logrocket.com/how-to-implement-jwt-authentication-nestjs/attachment/postman-signup-route/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/08/postman-signup-route.png" data-orig-size="730,488" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Postman signup route" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/08/postman-signup-route-300x201.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/08/postman-signup-route.png" decoding="async" loading="lazy" class="aligncenter size-full wp-image-127105" src="../Images/da22874c287cd5b71ce45c0642ac8788.png" alt="Postman Signup Route" srcset="https://blog.logrocket.com/wp-content/uploads/2022/08/postman-signup-route.png 730w, https://blog.logrocket.com/wp-content/uploads/2022/08/postman-signup-route-300x201.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/08/postman-signup-route.png"/></noscript>
<p>现在，通过向端点发送post请求来测试登录端点。<code>localhost:3000/auth/login</code>。</p>
<p><img data-attachment-id="127107" data-permalink="https://blog.logrocket.com/how-to-implement-jwt-authentication-nestjs/attachment/post-request-endpoint/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/08/post-request-endpoint.png" data-orig-size="730,508" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Post request endpoint" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/08/post-request-endpoint-300x209.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/08/post-request-endpoint.png" decoding="async" class="aligncenter size-full wp-image-127107 jetpack-lazy-image" src="../Images/b283bedc7947bd36b66e5f2130a5bb5e.png" alt="Post Request Endpoint" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2022/08/post-request-endpoint.png 730w, https://blog.logrocket.com/wp-content/uploads/2022/08/post-request-endpoint-300x209.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2022/08/post-request-endpoint.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/08/post-request-endpoint.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="127107" data-permalink="https://blog.logrocket.com/how-to-implement-jwt-authentication-nestjs/attachment/post-request-endpoint/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/08/post-request-endpoint.png" data-orig-size="730,508" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Post request endpoint" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/08/post-request-endpoint-300x209.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/08/post-request-endpoint.png" decoding="async" loading="lazy" class="aligncenter size-full wp-image-127107" src="../Images/b283bedc7947bd36b66e5f2130a5bb5e.png" alt="Post Request Endpoint" srcset="https://blog.logrocket.com/wp-content/uploads/2022/08/post-request-endpoint.png 730w, https://blog.logrocket.com/wp-content/uploads/2022/08/post-request-endpoint-300x209.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/08/post-request-endpoint.png"/></noscript>
<p>如果数据库中存在<code>username</code>和<code>password</code>，用户将收到如上图所示的<code>access_token</code>。使用<code>access_token</code>，用户将能够访问API中受保护的路线。</p>
<h2 id="conclusion">结论</h2>
<p>在本教程中，我们概述了NestJS，然后演示了如何在NestJS API上实现JWT用户认证。</p>
<p>现在您已经了解了这些知识，那么您将如何在下一个Nest项目中处理用户认证呢？要了解关于NestJS JWT认证的更多信息，请参考官方文档。</p><div class="code-block code-block-2">
<div class="blog-plug base-cta"><h2>使用<a class="signup" href="https://lp.logrocket.com/blg/signup" target="_blank" rel="noopener noreferrer"> LogRocket </a>消除传统错误报告的干扰</h2>
<a href="https://lp.logrocket.com/blg/signup" class="signup" target="_blank" rel="noopener noreferrer"><img class="alignnone size-full wp-image-46 jetpack-lazy-image" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/><noscript><img data-lazy-fallback="1" class="alignnone size-full wp-image-46" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/></noscript></a>
<p><a href="https://lp.logrocket.com/blg/signup" target="_blank" rel="noopener noreferrer"> LogRocket </a>是一个数字体验分析解决方案，它可以保护您免受数百个假阳性错误警报的影响，只针对几个真正重要的项目。LogRocket会告诉您应用程序中实际影响用户的最具影响力的bug和UX问题。</p>
<p>然后，使用具有深层技术遥测的会话重放来确切地查看用户看到了什么以及是什么导致了问题，就像你在他们身后看一样。</p>
<p>LogRocket自动聚合客户端错误、JS异常、前端性能指标和用户交互。然后LogRocket使用机器学习来告诉你哪些问题正在影响大多数用户，并提供你需要修复它的上下文。</p>
<p>关注重要的bug—<a class="signup" href="https://lp.logrocket.com/blg/signup-issue-free" target="_blank" rel="noopener noreferrer">今天就试试LogRocket】。</a></p></div></div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
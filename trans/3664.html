<html>
<head>
<title>Using Flutter Rust Bridge for cross-platform development </title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>使用Flutter Rust Bridge进行跨平台开发</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/using-flutter-rust-bridge-cross-platform-development/#0001-01-01">https://blog.logrocket.com/using-flutter-rust-bridge-cross-platform-development/#0001-01-01</a></blockquote><div><article class="article-post">
<p>有时候，在跨平台开发中，我们需要在特定平台的基础上执行某些代码。对于Flutter应用程序，我们可以从一个丰富的插件库中使用许多平台的原生功能，而不必编写自己的实现，所以这可能不会太令人生畏。</p>
<p>然而，随着我们的需求变得越来越小众，我们可能会发现一个插件并不存在，以利用某个功能。这时，我们需要考虑编写自己的特定于平台的代码。</p>
<p>您所针对的平台已经有了一种语言，您可以使用它来实现该功能。例如，在Android上，你可以使用Kotlin或Java，而在Windows上，你可以使用C++。</p>
<p>所以，我们需要回答的第一个问题是:为什么我们会考虑将Rust用于我们的特定于平台的语言？</p>
<p>向前跳:</p>

<h2 id="why-rust-flutter">使用带颤振的铁锈的案例</h2>
<p>假设我们需要获取用户当前使用的设备的当前电池电量。如果没有插件提供这种功能，我们至少需要考虑两件事:</p>
<ul>
<li>如何在我们的原生代码和Flutter之间传输数据</li>
<li>特定于平台的语言(如C++/Kotlin/Swift/etc)</li>
</ul>
<p>现在让我们来探讨一下这些挑战。</p>
<h3 id="transmitting-data-native-code-flutter">在本机代码和Flutter之间传输数据</h3>
<p>如果我们有很多数据要在Flutter应用程序和本地代码之间传输，我们需要创建绑定来来回回地传输数据。在这个过程中涉及到相当多的样板文件，当我们的实现发生变化时，不得不更新这些绑定，这可能会令人沮丧和耗时。</p>
<p>幸运的是，有一个名为Pigeon 的<a href="https://pub.dev/packages/pigeon">包可以为开发者自动完成相当多的工作。这对我们的处境有帮助吗？</a></p>
<p>快速浏览一下Pigeon支持平台的文档，我们会发现Pigeon支持生成以下内容:</p>
<ul>
<li>iOS的目标-C代码(<a href="https://developer.apple.com/documentation/swift/imported_c_and_objective-c_apis/importing_objective-c_into_swift">可供Swift </a>访问)</li>
<li>iOS的实验性Swift代码</li>
<li>Android的Java代码(可由Kotlin访问)</li>
<li>Android的实验性Kotlin代码</li>
<li>Windows的实验性C++代码</li>
</ul>
<p>尽管Kotlin和Swift在目标移动平台上被采用，但鸽子对这些平台的支持仍处于试验阶段。</p>
<p>这对移动应用来说没什么大不了的，因为你可以从Kotlin调用Java代码，从Swift调用Objective-C代码。这允许您在应用程序中利用生成的鸽子代码。然而，桌面和网络应用是另一回事。</p>
<p>鸽子对Windows的支持是实验性的，对Linux的支持是不存在的。如果你希望把你的应用程序投入生产，使用一个实验性的生成器感觉不是一个好主意。无论如何，对于Linux或web，您都要回到手工编写平台绑定。</p>
<p>如果你正在编写一个面向许多平台的应用程序，尤其是当你的应用程序面向一个鸽子支持处于试验阶段或不存在的平台时，这可能会成为一件苦差事。这不是一个难以管理的工作量，但它仍然是一个工作量。</p>
<h3 id="drawbacks-platform-specific-languages">使用特定于平台的语言的缺点</h3>
<p>就其本质而言，Flutter是一种跨平台语言。这意味着，一些编写Flutter应用程序的人可能没有遇到真正的平台特定语言，如Kotlin或Swift。</p>
<p>在这些情况下，在StackOverflow中搜索一个实现并尝试猜测您的方法并不困难。Kotlin和Swift将为您管理内存，在对象不再被访问时处理它们，因此更难(尽管不是不可能)引入内存泄漏。</p>
<p>在Windows和Linux上，这是一个完全不同的命题。</p>
<p>要实现原生功能，你必须使用C++。由于Pigeon支持在Windows上是实验性的，在Linux上是不存在的，所以你不仅要用一种你可能不懂的语言编写你的特定于平台的代码，还要编写你的绑定代码。</p>
<p>让这个命题变得更加困难的事实是，你必须管理你自己的记忆和跟踪你自己的参考。最重要的是，任何发生在本机层的未被捕获的异常都将导致您的应用程序在桌面上崩溃。</p>
<p>简而言之，即使您可以创建绑定代码，您也只能绑定到您的(如果您是初学者)潜在的非常不安全的代码。不是很吸引人。</p>
<h2 id="how-rust-flutter-rust-bridge-resolves-problems">如何使用锈和颤振锈桥解决这些问题</h2>
<p>为了在我们的Flutter项目中使用Rust，我们必须使用<a href="https://github.com/fzyzcjy/flutter_rust_bridge">社区生产的</a> <code><a href="https://github.com/fzyzcjy/flutter_rust_bridge">flutter_rust_bridge</a></code> <a href="https://github.com/fzyzcjy/flutter_rust_bridge">包</a>。</p>
<p>这个包拥有广泛的平台支持，包括Android、iOS、Windows、Linux、macOS和Web。因此，无论你的目标是什么平台，你都可以使用Rust和Flutter Rust Bridge。</p>
<p>快速回顾锈桥和颤振锈桥的好处，它成为一个相当引人注目的案例。</p>
<p>首先，Flutter Rust Bridge会为您生成所有的绑定代码，并支持异步操作，比如发送到一个<code>Stream</code>。</p>
<p>其次，<a href="https://blog.logrocket.com/why-is-rust-popular/"> Rust是一种更容易使用的语言</a>，也比Windows上的C++更安全。</p>
<p>此外，你可以在你的Rust项目中使用Rust crates来利用本地功能，而不是编写你自己的实现。</p>
<p>最后，Rust代码中未被捕获的异常通过一个<code>panic</code>转移到Flutter，您可以相应地查看和排除故障。与导致桌面崩溃的Windows本机未捕获异常相比，这是一种更好的体验。</p>
<p>为了演示这一点，让我们创建一个简单的Flutter应用程序，它可以获取运行它的设备的当前电池电量。</p>
<h2 id="creating-flutter-rust-bridge-project">创建我们的颤振锈桥项目</h2>
<p>首先，让我们为<code>flutter_rust_bridge</code>安装一些依赖项。这是Rust编程语言和LLVM。</p>
<p>从<a href="https://www.rust-lang.org/tools/install">网站</a>下载并安装Rust开始。在命令窗口中，运行以下命令:</p>
<pre>winget install -e --id LLVM.LLVM
</pre>
<p>这将下载并设置LLVM。</p>
<p>如果你正在用Flutter和Rust创建一个新项目，你可以从Github 中克隆这个模板库。这个模板是现成的，包含了让Rust在你的Flutter项目中工作所需的所有零碎东西。然后，您可以跳到本教程的“编写Rust代码”部分。</p>
<p>但是，如果您有一个现有的带有Flutter的项目，并且想要添加Rust，请继续阅读。如果你对Rust如何集成到Flutter项目中感到好奇，这也会有所帮助。</p>
<p>在我的例子中，我们将把Rust与我通过运行<code>flutter create windows_battery_check</code>创建的一个全新的Flutter项目集成在一起。</p>
<p>因为我们将要对您的项目进行低级别的更改，所以现在是将您的代码签入您的源代码控制系统的理想时机。这样，如果我们不小心破坏了您的项目，就很容易撤销。</p>
<h3>配置Rust项目</h3>
<p>让我们浏览一下 <code><a href="https://cjycode.com/flutter_rust_bridge/integrate.html">flutter_rust_bridge</a></code>上的<a href="https://cjycode.com/flutter_rust_bridge/integrate.html">文档，以了解我们如何将Rust集成到我们的项目中。</a></p>
<p>这本身并不复杂。然而，如果我们做错了任何一步，我们的项目将无法构建，并且很难找出原因。我还会对我们正在做的事情做一些解释，以帮助你理解如果这也是你第一次接触铁锈会发生什么。</p>
<p>首先，导航到您的Flutter项目。在项目中，从命令行执行<code>cargo new native --lib</code>。</p>
<p>注意<code>native</code>只是Rust项目的项目名称。如果愿意，您可以更改它，但是请记住，每次我们在本文的代码示例中引用它时，您都必须更新它。</p>
<p>接下来，在本地目录中，打开<code>cargo.toml</code>。在<code>[dependencies]</code>标题下，添加以下内容:</p>
<pre class="language-toml hljs">flutter_rust_bridge = "1"
</pre>
<p>在<code>[package]</code>下增加以下条目:</p>
<pre class="language-toml hljs">[lib]
crate-type = ["lib", "cdylib", "staticlib"]
</pre>
<p>我们的<code>cargo.toml</code>文件现在应该是这样的:</p>
<p><img data-attachment-id="144750" data-permalink="https://blog.logrocket.com/using-flutter-rust-bridge-cross-platform-development/attachment/img1-cargo-toml-file-contents/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/12/img1-Cargo-toml-file-contents.png" data-orig-size="365,215" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Cargo-toml-file-contents" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/12/img1-Cargo-toml-file-contents-300x177.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/12/img1-Cargo-toml-file-contents.png" decoding="async" class="aligncenter size-full wp-image-144750 jetpack-lazy-image" src="../Images/dfb852346af5b0d739bbff1041c2aeb8.png" alt="Black Background With White Text Showing Code That Should Appear In Cargo Toml File" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2022/12/img1-Cargo-toml-file-contents.png 365w, https://blog.logrocket.com/wp-content/uploads/2022/12/img1-Cargo-toml-file-contents-300x177.png 300w" data-lazy-sizes="(max-width: 365px) 100vw, 365px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2022/12/img1-Cargo-toml-file-contents.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/12/img1-Cargo-toml-file-contents.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="144750" data-permalink="https://blog.logrocket.com/using-flutter-rust-bridge-cross-platform-development/attachment/img1-cargo-toml-file-contents/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/12/img1-Cargo-toml-file-contents.png" data-orig-size="365,215" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Cargo-toml-file-contents" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/12/img1-Cargo-toml-file-contents-300x177.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/12/img1-Cargo-toml-file-contents.png" decoding="async" loading="lazy" class="aligncenter size-full wp-image-144750" src="../Images/dfb852346af5b0d739bbff1041c2aeb8.png" alt="Black Background With White Text Showing Code That Should Appear In Cargo Toml File" srcset="https://blog.logrocket.com/wp-content/uploads/2022/12/img1-Cargo-toml-file-contents.png 365w, https://blog.logrocket.com/wp-content/uploads/2022/12/img1-Cargo-toml-file-contents-300x177.png 300w" sizes="(max-width: 365px) 100vw, 365px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/12/img1-Cargo-toml-file-contents.png"/></noscript>
<p>对于上下文，<code><a href="https://blog.logrocket.com/demystifying-cargo-in-rust/#cargolockvscargotoml">cargo.toml</a></code> <a href="https://blog.logrocket.com/demystifying-cargo-in-rust/#cargolockvscargotoml">是包含关于我们rust项目的</a>信息的文件。这个文件还包含了我们的项目所依赖的其他包——或者当处理Rust时，它们被称为crates。</p>
<p>我们继续。在<code>native</code>目录中，从命令提示符或终端执行以下命令:</p>
<pre>cargo install flutter_rust_bridge_codegen
flutter pub add --dev ffigen &amp;&amp; flutter pub add ffi
</pre>
<p>这将Rust的代码生成工具添加到Rust项目中，并将FFI生成位添加到Flutter项目中。</p>
<h3>配置我们的颤振项目</h3>
<p>在我们的<code>native</code>目录中，运行以下命令:</p>
<pre>flutter pub add flutter_rust_bridge
flutter pub add -d build_runner
flutter pub add -d freezed
flutter pub add freezed_annotation
</pre>
<p>这些组件实现了以下几点:</p>
<ul>
<li><code>flutter_rust_bridge</code>——颤振锈桥库的“颤振侧”部分</li>
<li><code>build_runner</code> —用于生成平台绑定中使用的Dart代码</li>
<li><code>freezed</code> —用于将物体从生锈状态转移到颤动状态</li>
</ul>
<h3>检查我们的配置</h3>
<p>我们已经涉及了相当多的东西，所以让我们花一点时间来检查我们的设置到目前为止是好的。如果我们不小心跳过了一个包或者犯了一个错误，什么都不会工作，并且很难找出原因。</p>
<p>我们的<code>native/config.toml</code>文件应该是这样的:</p>
<pre class="language-toml hljs">[package]
name = "native"
version = "0.1.0"
edition = "2021"

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[dependencies]
anyhow = "1"
flutter_rust_bridge = "1"
</pre>
<p>同时，我们的<code>pubspec.yaml</code>应该有这些依赖关系:</p>
<pre class="language-yaml hljs">dependencies:
  flutter:
    sdk: flutter
  cupertino_icons: ^1.0.2
  ffi: ^2.0.1
  flutter_rust_bridge: ^1.49.1
  freezed_annotation: ^2.2.0

dev_dependencies:
  flutter_test:
    sdk: flutter
  flutter_lints: ^2.0.0
  ffigen: ^7.2.0
  build_runner: ^2.3.2
  freezed: ^2.2.1
</pre>
<h3>设置我们的Windows项目集成</h3>
<p>终于到了将我们的原生Rust项目与Flutter整合的时候了。为此，下载Rust使用的<code><a href="https://raw.githubusercontent.com/Desdaemon/flutter_rust_bridge_template/main/windows/rust.cmake">cmake</a></code> <a href="https://raw.githubusercontent.com/Desdaemon/flutter_rust_bridge_template/main/windows/rust.cmake">文件，并将其放在项目的<code>windows</code>目录中。然后，在第57行的<code>include(flutter/generated_plugins.cmake)</code>之后，添加以下一行:</a></p>
<pre>include(./rust.cmake)
</pre>
<h3>回到我们的Rust项目配置</h3>
<p>现在，在您选择的编辑器中，从<code>native</code>目录中打开Rust项目。在<code>src</code>目录下创建一个名为<code>api.rs</code>的新文件。然后，打开<code>lib.rs</code>文件，将以下内容添加到文件的顶部:</p>
<pre class="language-rust hljs">mod api;
</pre>
<p>现在让我们编写一些非常基本的Rust代码，我们可以从我们的Flutter应用程序中调用它们。在我们的<code>api.rs</code>文件中，让我们添加一个非常简单的函数来测试我们的集成:</p>
<pre class="language-rust hljs">pub fn helloWorld() -&gt; String {
    String::from("Hello from Rust! 🦀")
}
</pre>
<h3>生成平台绑定代码</h3>
<p>现在终于到了生成代码的时候了，Flutter将使用这些代码来调用Rust功能。在项目的根目录下，运行以下命令:</p>
<pre>flutter_rust_bridge_codegen --rust-input native/src/api.rs --dart-output lib/bridge_generated.dart --dart-decl-output lib/bridge_definitions.dart
</pre>
<p>为了保持理智，您应该将这个命令保存到一个类似于<code>generate_bindings.bat</code>的文件中。在更新Rust代码并公开任何新功能后，您需要重新运行它。</p>
<p>打开你的颤振项目。在<code>lib</code>目录中，添加以下<code>native.dart</code>文件:</p>
<pre class="language-dart hljs">// This file initializes the dynamic library and connects it with the stub
// generated by flutter_rust_bridge_codegen.

import 'dart:ffi';

import 'dart:io' as io;

import 'package:windows_battery_check/bridge_generated.dart';

const _base = 'native';

// On MacOS, the dynamic library is not bundled with the binary,
// but rather directly **linked** against the binary.
final _dylib = io.Platform.isWindows ? '$_base.dll' : 'lib$_base.so';

final api = NativeImpl(io.Platform.isIOS || io.Platform.isMacOS
    ? DynamicLibrary.executable()
    : DynamicLibrary.open(_dylib));
</pre>
<p>就这样，我们结束了！我们的颤振项目现在可以调用Rust代码。</p>
<h3>从颤动中呼唤铁锈</h3>
<p>在我们的<code>main.dart</code>中，我们将调用非常简单的Rust代码。我们的小部件是这样做的:</p>
<pre class="language-dart hljs">import 'package:windows_battery_check/native.dart';
...

class HomePage extends StatelessWidget {
  const HomePage({Key? key}) : super(key: key);

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: Text("Flutter Battery Windows"),
      ),
      body: Center(
        child: FutureBuilder( // All Rust functions are called as Future's
          future: api.helloWorld(), // The Rust function we are calling.
          builder: (context, data) {
            if (data.hasData) {
              return Text(data.data!); // The string to display
            }
            return Center(
              child: CircularProgressIndicator(),
            );
          },
        ),
      ),
    );
  }
}
</pre>
<p>运行项目会出现以下窗口:</p>
<p><img data-attachment-id="144752" data-permalink="https://blog.logrocket.com/using-flutter-rust-bridge-cross-platform-development/attachment/img2-running-project-results-check-app-functionality/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/12/img2-Running-project-results-check-app-functionality.png" data-orig-size="730,523" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Running-project-results-check-app-functionality" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/12/img2-Running-project-results-check-app-functionality-300x215.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/12/img2-Running-project-results-check-app-functionality.png" decoding="async" class="aligncenter size-full wp-image-144752 jetpack-lazy-image" src="../Images/6304a83fdee9e1b9f0473eade024bd42.png" alt="Open Window Titled Windows Battery Check With Blue Bar At Top With White Text Reading Flutter Battery Windows. White Window Contents Contain Small Centered Text Reading Hello From Rust With Small Crab Emoji" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2022/12/img2-Running-project-results-check-app-functionality.png 730w, https://blog.logrocket.com/wp-content/uploads/2022/12/img2-Running-project-results-check-app-functionality-300x215.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2022/12/img2-Running-project-results-check-app-functionality.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/12/img2-Running-project-results-check-app-functionality.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="144752" data-permalink="https://blog.logrocket.com/using-flutter-rust-bridge-cross-platform-development/attachment/img2-running-project-results-check-app-functionality/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/12/img2-Running-project-results-check-app-functionality.png" data-orig-size="730,523" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Running-project-results-check-app-functionality" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/12/img2-Running-project-results-check-app-functionality-300x215.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/12/img2-Running-project-results-check-app-functionality.png" decoding="async" loading="lazy" class="aligncenter size-full wp-image-144752" src="../Images/6304a83fdee9e1b9f0473eade024bd42.png" alt="Open Window Titled Windows Battery Check With Blue Bar At Top With White Text Reading Flutter Battery Windows. White Window Contents Contain Small Centered Text Reading Hello From Rust With Small Crab Emoji" srcset="https://blog.logrocket.com/wp-content/uploads/2022/12/img2-Running-project-results-check-app-functionality.png 730w, https://blog.logrocket.com/wp-content/uploads/2022/12/img2-Running-project-results-check-app-functionality-300x215.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/12/img2-Running-project-results-check-app-functionality.png"/></noscript>
<p>我们的应用程序有效！现在让我们实际获取电池统计数据。</p>
<p>首先，让我们用检索Windows上的电池状态所需的依赖项来更新我们的<code>cargo.toml</code>。我们需要添加Windows机箱来利用Windows API的功能，我们还需要专门从这个机箱加载某些功能。</p>
<p>我们在<code>cargo.toml</code>中的依赖关系将如下所示:</p>
<pre class="language-toml hljs">[dependencies]
anyhow = "1.0.66"
flutter_rust_bridge = "1"

[target.'cfg(target_os = "windows")'.dependencies]
windows = {version = "0.43.0", features =["Devices_Power", "Win32_Foundation", "Win32_System_Power", "Win32_System_Com", "Foundation", "System_Power"]}
</pre>
<p>现在，是时候实现我们的应用程序实现的实际功能了。我们的应用实现了两个功能:</p>
<ol>
<li>检查系统中是否有电池</li>
<li>随着时间的推移发出电池状态更新</li>
</ol>
<p>现在让我们实现这些功能。</p>
<h3>检查电池是否存在</h3>
<p>我们从系统中检索当前电池状态的函数如下所示:</p>
<pre class="language-rust hljs">pub fn getBatteryStatus() -&gt; Result&lt;bool&gt; {
    // https://learn.microsoft.com/en-us/windows/win32/api/winbase/ns-winbase-system_power_status
    let mut powerStatus: SYSTEM_POWER_STATUS = SYSTEM_POWER_STATUS::default();
    unsafe {
        GetSystemPowerStatus(&amp;mut powerStatus);
        Ok(powerStatus.BatteryFlag != 128)
    }
}
</pre>
<p>本质上，我们为<code>SYSTEM_POWER_STATUS</code>创建一个容器，用默认值初始化它，然后将它传递给GetSystemPowerStatus函数。然后，<a href="https://learn.microsoft.com/en-us/windows/win32/api/winbase/ns-winbase-system_power_status">我们可以使用API文档来理解结果</a>。</p>
<p>在这种情况下，<code>128</code>表示没有电池。只要这个返回值不等于<code>128</code>，就应该有电池存在。</p>
<h3>随着时间的推移接收电池更新</h3>
<p>为了能够随着时间的推移接收电池更新，我们的应用程序必须通过<code>Stream</code>发送结果。幸运的是，<code>StreamSink</code>带有<code>flutter_rust_bridge</code>，所以通过流发送事件很简单。</p>
<p>在我们的<code>api.rs</code>中，靠近文件的顶部，添加一个定义我们的<code>Stream</code>的<code>RwLock</code>:</p>
<pre class="language-rust hljs">static BATTERY_REPORT_STREAM: RwLock&lt;Option&lt;StreamSink&lt;BatteryUpdate&gt;&gt;&gt; = RwLock::new(None);
</pre>
<p>然后，让我们创建一个名为<code>battery_event_stream</code>的新函数，它将这个<code>RwLock</code>的值赋给被传递给Rust的<code>Stream</code>:</p>
<pre class="language-rust hljs">pub fn battery_event_stream(s: StreamSink&lt;BatteryUpdate&gt;) -&gt; Result&lt;()&gt; {
    let mut stream = BATTERY_REPORT_STREAM.write().unwrap();
    *stream = Some(s);
    Ok(())
}
</pre>
<p>因为我们直接与Windows API交互，我们需要阅读关于<a href="https://learn.microsoft.com/is-is/uwp/api/windows.devices.power.batteryreport?view=winrt-19041">电池报告如何在Windows </a>上工作的文档。通过阅读这些API文档，我们可以理解<code>BatteryStruct</code>应该是什么样子，以及从<code>ChargingState</code>返回的值是什么意思。</p>
<p>数据模型如下所示:</p>
<pre class="language-rust hljs">#[derive(Debug)]
pub struct BatteryUpdate {
    pub charge_rates_in_milliwatts: Option&lt;i32&gt;,
    pub design_capacity_in_milliwatt_hours: Option&lt;i32&gt;,
    pub full_charge_capacity_in_milliwatt_hours: Option&lt;i32&gt;,
    pub remaining_capacity_in_milliwatt_hours: Option&lt;i32&gt;,
    pub status: ChargingState,
}

#[derive(Debug)]
pub enum ChargingState {
    Charging = 3,
    Discharging = 1,
    Idle = 2,
    NotPresent = 0,
    Unknown = 255,
}
</pre>
<p>随着我们的流被初始化，我们的数据模型被设置，最后是时候连接事件生成了。</p>
<p>为此，让我们创建一个<code>init</code>函数来设置订阅，并在电池状态改变时将事件发送到流中。当我们这样做时，我们需要小心，因为当设备被拔出时，某些属性(如<code>ChargeRateInMilliwatts</code>)将返回null。</p>
<p>幸运的是，通过在Rust中使用模式匹配，很容易安全地处理这些空值，正如我们在这里看到的:</p>
<pre class="language-rust hljs">pub fn init() {
    Battery::AggregateBattery().unwrap().ReportUpdated(&amp;TypedEventHandler::&lt;Battery, IInspectable&gt;::new(|battery, inspectable| {
        let agg_battery = Battery::AggregateBattery();
        let report = agg_battery.unwrap().GetReport().unwrap();

        let battery_outcome = BatteryUpdate {
            charge_rates_in_milliwatts: match report.ChargeRateInMilliwatts() {
                Ok(charge_rate) =&gt; {
                    Some(charge_rate.GetInt32().unwrap())
                }
                Err(_) =&gt; {
                    None
                }
            },
            design_capacity_in_milliwatt_hours: match report.DesignCapacityInMilliwattHours() {
                Ok(design_capacity) =&gt; {
                    Some(design_capacity.GetInt32().unwrap())
                }
                Err(_) =&gt; {
                    None
                }
            },
            full_charge_capacity_in_milliwatt_hours: match report.FullChargeCapacityInMilliwattHours() {
                Ok(full_charge) =&gt; {
                    Some(full_charge.GetInt32().unwrap())
                }
                Err(_) =&gt; {
                    None
                }
            },
            remaining_capacity_in_milliwatt_hours: match report.RemainingCapacityInMilliwattHours() {
                Ok(remaining_capacity) =&gt; {
                    Some(remaining_capacity.GetInt32().unwrap())
                }
                Err(_) =&gt; {
                    None
                }
            },
            status: match report.Status().unwrap().0 {
                3 =&gt; Charging,
                1 =&gt; Discharging,
                2 =&gt; Idle,
                0 =&gt; NotPresent,
                _ =&gt; Unknown
            },
        };

        println!("Handler Update{:?}", battery_outcome);
        match BATTERY_REPORT_STREAM.try_read() {
            Ok(s) =&gt; {
                s.as_ref().unwrap().add(battery_outcome);
            }
            Err(_) =&gt; {
                println!("Error when writing battery status.");
            }
        }
        Ok(())
    })).expect("Could not subscribe to battery updates");
}
</pre>
<p>在我们的<code>api.rs</code>中有了这段代码之后，是时候从命令行重新运行我们之前保存的命令了:</p>
<pre>flutter_rust_bridge_codegen --rust-input native/src/api.rs --dart-output lib/bridge_generated.dart --dart-decl-output lib/bridge_definitions.dart
</pre>
<h3>在Flutter应用程序中显示电池结果</h3>
<p>因为我们已经将Rust项目与我们的Flutter项目集成在一起，所以我们所要做的就是更新我们的代码以实现以下目标:</p>
<ol>
<li>调用<code>init</code>函数开始监听Rust库中的事件</li>
<li>使用<code>FutureBuilder</code>显示系统是否有电池</li>
<li>使用<code>StreamBuilder</code>显示电池状态的更新</li>
</ol>
<p>我们的<code>HomePage</code>小部件现在看起来如下，因为它可以直接调用Rust库👏：</p>
<pre class="language-dart hljs">class HomePage extends StatefulWidget {
  const HomePage({Key? key}) : super(key: key);

  @override
  State&lt;HomePage&gt; createState() =&gt; _HomePageState();
}

class _HomePageState extends State&lt;HomePage&gt; {

  @override
  void initState() {
    api.init();
    super.initState();
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: Text("Flutter Battery Windows"),
      ),
      body: Center(
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.center,
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            FutureBuilder( // For when results emit once
              future: api.getBatteryStatus(),
              builder: (context, data) {
                return Text(
                  'System has battery present: ${data.data}',
                  style: TextStyle(
                      color: (data.data ?? false) ? Colors.green : Colors.red),
                );
              },
            ),
            StreamBuilder( // For when there are results over time
              stream: api.batteryEventStream(),
              builder: (context, data) {
                if (data.hasData) {
                  return Column(
                    children: [
                      Text(
                          "Charge rate in milliwatts: ${data.data!.chargeRatesInMilliwatts.toString()}"),
                      Text(
                          "Design capacity in milliwatts: ${data.data!.designCapacityInMilliwattHours.toString()}"),
                      Text(
                          "Full charge in milliwatt hours: ${data.data!.fullChargeCapacityInMilliwattHours.toString()}"),
                      Text(
                          "Remaining capacity in milliwatts: ${data.data!.remainingCapacityInMilliwattHours}"),
                      Text("Battery status is ${data.data!.status}")
                    ],
                  );
                }
                return Column(
                  children: [
                    Text("Waiting for a battery event."),
                    Text(
                        "If you have a desktop computer with no battery, this event will never come..."),
                    CircularProgressIndicator(),
                  ],
                );
              },
            ),
          ],
        ),
      ),
    );
  }
}
</pre>
<p>随着代码的更新，我们可以继续在Windows上运行我们的Flutter应用程序。几秒钟后(或者，如果您拔掉笔记本电脑的电源)，应该会显示以下内容:</p>
<p><img data-attachment-id="144755" data-permalink="https://blog.logrocket.com/using-flutter-rust-bridge-cross-platform-development/attachment/img3-flutter-app-run-windows/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/12/img3-Flutter-app-run-Windows.png" data-orig-size="730,572" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Flutter-app-run-Windows" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/12/img3-Flutter-app-run-Windows-300x235.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/12/img3-Flutter-app-run-Windows.png" decoding="async" class="aligncenter size-full wp-image-144755 jetpack-lazy-image" src="../Images/6d70d7f8ab8f9c7411b44006d1d8ff1d.png" alt="Flutter Battery Check App Open In Window With Blue Bar At Top With White Text Reading Flutter Battery Windows. White App Background Contains Small Centered Text Showing Battery Info Readout" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2022/12/img3-Flutter-app-run-Windows.png 730w, https://blog.logrocket.com/wp-content/uploads/2022/12/img3-Flutter-app-run-Windows-300x235.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2022/12/img3-Flutter-app-run-Windows.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/12/img3-Flutter-app-run-Windows.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="144755" data-permalink="https://blog.logrocket.com/using-flutter-rust-bridge-cross-platform-development/attachment/img3-flutter-app-run-windows/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/12/img3-Flutter-app-run-Windows.png" data-orig-size="730,572" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Flutter-app-run-Windows" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/12/img3-Flutter-app-run-Windows-300x235.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/12/img3-Flutter-app-run-Windows.png" decoding="async" loading="lazy" class="aligncenter size-full wp-image-144755" src="../Images/6d70d7f8ab8f9c7411b44006d1d8ff1d.png" alt="Flutter Battery Check App Open In Window With Blue Bar At Top With White Text Reading Flutter Battery Windows. White App Background Contains Small Centered Text Showing Battery Info Readout" srcset="https://blog.logrocket.com/wp-content/uploads/2022/12/img3-Flutter-app-run-Windows.png 730w, https://blog.logrocket.com/wp-content/uploads/2022/12/img3-Flutter-app-run-Windows-300x235.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/12/img3-Flutter-app-run-Windows.png"/></noscript>
<p>随着时间的推移，当电池电量有更新时，这些值将通过流发出，UI将自动更新。</p>
<h2 id="conclusion">结论</h2>
<p>将Rust用于本机平台功能，尤其是在Windows上，可以使编写本机代码更加容易和安全。能够通过流接收事件也非常适合异步事件。</p>
<p>和往常一样，本指南中使用的代码示例可以从Github 上获得。该存储库中有两个文件夹。</p>
<p><code>batterytest</code>文件夹是一个独立的Rust控制台应用程序，它充当了我自己测试Windows API调用的沙箱。能够在添加Flutter解决方案之前检查我的调用是否正常，这本身就很有价值。</p>
<p><code>windows_battery_check</code>文件夹包含完整的Flutter项目，包括Rust库和代码。</p>
<p>快乐发展！</p><div class="code-block code-block-29">
<div class="blog-plug inline-plug rust-plug"><h2><a href="https://lp.logrocket.com/blg/rust-signup" target="_blank">log rocket</a>:Rust应用的web前端的全面可见性</h2><p>调试Rust应用程序可能很困难，尤其是当用户遇到难以重现的问题时。如果您对监控和跟踪Rust应用程序的性能、自动显示错误、跟踪缓慢的网络请求和加载时间感兴趣，</p><a href="https://lp.logrocket.com/blg/rust-signup" target="_blank">try LogRocket</a><p>. </p><a class="signup" href="https://lp.logrocket.com/blg/rust-signup" target="_blank" rel="noopener noreferrer"><img class="alignnone size-full wp-image-46 jetpack-lazy-image" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/><noscript><img data-lazy-fallback="1" class="alignnone size-full wp-image-46" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/></noscript></a><p>LogRocket 就像是网络和移动应用程序的DVR，记录你的Rust应用程序上发生的一切。您可以汇总并报告问题发生时应用程序的状态，而不是猜测问题发生的原因。LogRocket还可以监控应用的性能，报告客户端CPU负载、客户端内存使用等指标。</p><p>现代化调试Rust应用的方式— <a class="signup" href="https://lp.logrocket.com/blg/rust-signup" target="_blank" rel="noopener noreferrer">开始免费监控</a>。</p></div>


</div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
<html>
<head>
<title>Using Cap’n Proto in Rust to serialize and deserialize objects </title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>在Rust中使用Cap'n Proto来序列化和反序列化对象</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/using-capn-proto-rust-serialize-deserialize-objects/#0001-01-01">https://blog.logrocket.com/using-capn-proto-rust-serialize-deserialize-objects/#0001-01-01</a></blockquote><div><article class="article-post">
<p>当对象很大很复杂时，使用JSON和XML这样的格式进行序列化会变得低效。原因之一是这些格式将对象的结构与其包含的数据一起存储。</p>
<p>这种方法允许您在没有模式的情况下直接序列化和反序列化对象。然而，当对象非常复杂时，就占用的空间以及编码和解码的过程而言，它变得低效。</p>
<p>Cap'n Proto是一个数据序列化器，就像JSON和XML一样。但是与JSON和XML不同，它对编码和解码对象都使用模式。</p>
<p>模式的使用消除了在编码时存储对象结构的需要。由于不存储对象的结构，编码和解码非常有效。</p>
<p>在本文中，您将了解Cap'n Proto，它是如何工作的，以及如何在Rust项目中使用它。我们将涵盖:</p>

<p>为了阅读本文，您需要具备以下先决条件:</p>

<h2 id="overview-capn-proto">Cap'n Proto概述</h2>
<p>Cap'n Proto是一种数据交换格式，就像JSON、XML等等。</p>
<p>数据交换格式允许你<a href="https://blog.logrocket.com/rust-serialization-whats-ready-for-production-today/">执行序列化和反序列化</a>。序列化是将对象编码成字节。反序列化是指将字节解码回对象。</p>
<p>这些工具帮助开发人员在不同的计算机程序之间交换对象。</p>
<p>与JSON和许多其他数据交换格式不同，Cap'n Proto的大多数操作都需要一个模式。这个模式包括编码、解码和创建对象。</p>
<p>模式是描述对象结构的程序。即使在Cap'n Proto中，通常也有专门的语言来编写模式。在用Cap'n Proto编写模式之后，您需要将模式编译成您想要使用的编程语言。</p>
<p>Cap'n Proto有一个用于从模式创建对象的构建器，一个用于将对象编码成字节的序列化器，以及一个用于将字节解码成对象的读取器。下图概述了这三个组件:</p>
<p><img data-attachment-id="143343" data-permalink="https://blog.logrocket.com/using-capn-proto-rust-serialize-deserialize-objects/attachment/image1-building-encoding-decoding-objects-capn-proto/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/11/image1-Building-encoding-decoding-objects-Capn-Proto.png" data-orig-size="568,730" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Building-encoding-decoding-objects-Capn-Proto" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/11/image1-Building-encoding-decoding-objects-Capn-Proto-233x300.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/11/image1-Building-encoding-decoding-objects-Capn-Proto.png" decoding="async" src="../Images/597fb30824d041652dfbbee3460a1d75.png" alt="Three Part Diagram Stacked Vertically. Part One Labeled Building An Object. From Left To Right, Shows Schema Used By Builder To Create Object. Part Two Labeled Encoding. From Left To Right, Shows Object Being Encoded By Serializer Into Bytes. Part Three Labeled Decoding. From Left To Right, Shows Input Of Schema And Encoded Bytes Being Decoded By Reader Into Object." class="aligncenter size-full wp-image-143343 jetpack-lazy-image" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2022/11/image1-Building-encoding-decoding-objects-Capn-Proto.png 568w, https://blog.logrocket.com/wp-content/uploads/2022/11/image1-Building-encoding-decoding-objects-Capn-Proto-233x300.png 233w" data-lazy-sizes="(max-width: 568px) 100vw, 568px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2022/11/image1-Building-encoding-decoding-objects-Capn-Proto.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/11/image1-Building-encoding-decoding-objects-Capn-Proto.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="143343" data-permalink="https://blog.logrocket.com/using-capn-proto-rust-serialize-deserialize-objects/attachment/image1-building-encoding-decoding-objects-capn-proto/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/11/image1-Building-encoding-decoding-objects-Capn-Proto.png" data-orig-size="568,730" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Building-encoding-decoding-objects-Capn-Proto" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/11/image1-Building-encoding-decoding-objects-Capn-Proto-233x300.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/11/image1-Building-encoding-decoding-objects-Capn-Proto.png" decoding="async" loading="lazy" src="../Images/597fb30824d041652dfbbee3460a1d75.png" alt="Three Part Diagram Stacked Vertically. Part One Labeled Building An Object. From Left To Right, Shows Schema Used By Builder To Create Object. Part Two Labeled Encoding. From Left To Right, Shows Object Being Encoded By Serializer Into Bytes. Part Three Labeled Decoding. From Left To Right, Shows Input Of Schema And Encoded Bytes Being Decoded By Reader Into Object." class="aligncenter size-full wp-image-143343" srcset="https://blog.logrocket.com/wp-content/uploads/2022/11/image1-Building-encoding-decoding-objects-Capn-Proto.png 568w, https://blog.logrocket.com/wp-content/uploads/2022/11/image1-Building-encoding-decoding-objects-Capn-Proto-233x300.png 233w" sizes="(max-width: 568px) 100vw, 568px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/11/image1-Building-encoding-decoding-objects-Capn-Proto.png"/></noscript>
<p>除了将Cap'n Proto用作数据序列化器之外，您还可以将它用于RPC系统、数据库系统等等。在本文中，我们将关注Rust中Cap'n Proto的序列化和反序列化。</p>
<h2 id="getting-started-capn-proto-rust">Rust中的Cap'n Proto入门</h2>
<p>在这一节中，我将指导您定义必要的依赖项，创建一个模式，并为Rust项目编译使用Cap'n Proto的模式。</p>
<p>但是在开始之前，您需要初始化一个项目。运行下面的命令来初始化一个新项目:</p>
<pre class="language-toml hljs">$ cargo new --bin cap-n-proto-project 
</pre>
<p>现在，打开您的项目的<code>Cargo.toml</code>文件，添加以下内容来定义在Rust项目中使用Cap'n Proto的依赖关系:</p>
<pre class="language-toml hljs">[dependencies]
capnp  = "0.14"

[build-dependencies]
capnpc = "0.14"
</pre>
<p>下一步是创建一个模式。为此，首先创建一个名为<code>schemas</code>的文件夹。然后，在<code>schemas</code>文件夹中创建一个<code>person_schema.capnp</code>文件。最后，将以下内容写入您的<code>person_schema.capnp</code>文件:</p>
<pre class="language-c++ hljs">@0x8512a370fcfefa23;

struct Person {
 name @0 :Text;
 age @1 :UInt8;
}
</pre>
<p>在模式中，第一行是唯一的文件标识符。您可以通过在终端中运行<code>capnp id</code>来生成一个新的。</p>
<p>文件ID下的<code>struct</code>是一个名为<code>Person</code>的数据结构，有两个字段:<code>name</code>和<code>age</code>。</p>
<p>为了允许编码的对象与更新的模式兼容，Cap'n Proto要求您在每个字段后包含一个ID。每个ID以一个<code>@</code>符号开头，后面跟着一个整数。您应该使用的第一个数字是<code>0</code>。</p>
<p>当添加新字段时，您应该放置一个新的数字标签。例如:</p>
<pre class="language-c++ hljs"> name @0 :Text;
 age @1 :UInt8;
 new_field @2 :DataType;
</pre>
<p>创建模式后，按照下面的步骤设置其编译。</p>
<p>首先，<a href="https://capnproto.org/install.html">安装Cap'n Proto可执行文件</a>。编译架构需要可执行文件。</p>
<p>接下来，在<code>src</code>文件夹中创建一个<code>build.rs</code>文件。然后，将这段代码写入您的<code>build.rs</code>文件:</p>
<pre class="language-rust hljs">extern crate capnpc;

fn main () {
  capnpc::CompilerCommand::new()
    .output_path("src/")
    .src_prefix("schemas/")
    .file("schemas/person_schema.capnp")
    .run().unwrap();
</pre>
<p>让我们暂停一会儿，了解一下<code>build.rs</code>文件中发生了什么。上面的代码首先用<code>CompilerCommand</code>初始化一个编译器。然后，它注册一个<code>output_path</code>或目录，用于存放编译后的代码。</p>
<p>接下来，<code>.src_prefix</code>设置一个前缀，这样编译器就可以知道在给编译后的代码命名时要忽略哪些字符。然后，它提供一个到您想要编译的模式的<code>.file()</code>路径。最后，它执行编译器。</p>
<p>现在，让我们回到设置模式编译。打开您的<code>Cargo.toml</code>文件，注册运行<code>cargo build</code>时要执行的<code>src/build.rs</code>:</p>
<pre class="language-toml hljs">[package]
name = "proto-dev"
version = "0.1.0"
edition = "2021"
build = "src/build.rs"    # &lt;-- this line
</pre>
<p>添加了上面的代码后，无论何时运行<code>cargo build</code>，<code>cargo</code>都会在构建项目时编译模式。最后，在你的终端上运行<code>cargo build</code>命令。</p>
<p>当项目构建完成后，您会在<code>src</code>中看到一个<code>person_schema_capnp.rs</code>文件。</p>
<h2 id="serializing-objects">序列化对象</h2>
<p>现在您已经设置好了一切，是时候用Cap'n Proto做些实际的事情了。在这一节中，我将向您展示如何用您的模式创建一个对象，以及如何序列化该对象。</p><div class="code-block code-block-54">
<hr/>
<h3>更多来自LogRocket的精彩文章:</h3>

<hr/></div>
<p>下面是创建和序列化对象的代码。清除<code>main.rs</code>文件并将其粘贴到其中:</p>
<pre class="language-rust hljs">use capnp::message::Builder;
use capnp::serialize;

pub mod person_schema_capnp;

fn main() {
   let mut message = Builder::new_default();

   let mut person = message.init_root::&lt;person_schema_capnp::person::Builder&gt;();
   person.set_name("John");
   person.set_age(23);

   let data = serialize::write_message_to_words(&amp;message);
   println!("{:?}", data);
}
</pre>
<p>在上面的前两行代码中，我们从<code>capnp</code>导入了<code>Builder</code>和<code>serialize</code>。<code>Builder</code>允许您用模式构建一个对象，而<code>serialize</code>允许您序列化该对象。</p>
<p>然后我们从<code>person_schema_capnp.rs</code>导入模式，然后初始化一个消息生成器。</p>
<p>在<code>fn main()</code>下的第九行代码中，我们用模式的<code>Builder</code>在<code>message</code>中设置了一个<code>person</code>对象。在下面两行中，我们在对象中保存了两个值:<code>name</code>和<code>age</code>。</p>
<p>最后，我们将对象序列化为一个向量，然后在之后的行中打印出这个向量。</p>
<h2 id="deserializing-objects">反序列化对象</h2>
<p>既然您已经看到了如何在Rust中使用Cap'n Proto创建对象并将其序列化为矢量，那么现在就应该将矢量反序列化为对象了。在这一节中，我将向您展示如何操作。</p>
<p>首先，您需要从<code>capnp</code>导入<code>ReaderOptions</code>:</p>
<pre class="language-rust hljs">use capnp::message::ReaderOptions;
</pre>
<p>接下来，用<code>serialize</code>创建一个阅读器:</p>
<pre class="language-rust hljs">let reader = serialize::read_message(
       data.as_slice(),
       ReaderOptions::new()
   ).unwrap();
</pre>
<p>在上面的例子中，<code>data</code>是我们之前将<code>person</code>对象序列化成的向量。在将矢量传递给<code>serialize::read_message()</code>之前，你需要将矢量转换成切片。这就是我们用<code>data.as_slice()</code>的原因。</p>
<p>最后，使用<code>reader</code>变量和<code>person_schema_capnp.rs</code>模式的<code>Reader</code>来组装对象，如下所示:</p>
<pre class="language-rust hljs">let person = reader.get_root::&lt;person_schema_capnp::person::Reader&gt;().unwrap();
</pre>
<p>为了验证组装对象是否有效，您可以在下面添加这一行，以打印出我们存储在对象中的名称:</p>
<pre class="language-rust hljs">let name = person.get_name().unwrap();
println!("Name: {name}");
</pre>
<p>结合我们在上一节和本节中所做的，我们将在我们的<code>main.rs</code>文件中得到以下内容:</p>
<pre class="language-rust hljs">use capnp::message::Builder;
use capnp::message::ReaderOptions;
use capnp::serialize;

pub mod person_schema_capnp;

fn main() {

   // Creating object
   let mut message = Builder::new_default();
   let mut person = message.init_root::&lt;person_schema_capnp::person::Builder&gt;();
   person.set_name("John");
   person.set_age(23);

   // Serializing object
   let data = serialize::write_message_to_words(&amp;message);
   println!("{:?}", data);

   // Deserializing object
   let reader = serialize::read_message(
       data.as_slice(),
       ReaderOptions::new()
   ).unwrap();

   let person = reader.get_root::&lt;person_schema_capnp::person::Reader&gt;().unwrap();
   let name = person.get_name().unwrap();
   println!("Name: {name}");
}
</pre>
<p>一旦您在终端中运行下面的<code>cargo run</code>命令，您将得到如下输出:</p>
<pre class="language-toml hljs">$ cargo run
   Compiling cap-n-proto-project v0.1.0 (/path/to/project)
    Finished dev [unoptimized + debuginfo] target(s) in 2.55s
     Running `target/debug/cap-n-proto-project`
[0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 23, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 42, 0, 0, 0, 74, 111, 104, 110, 0, 0, 0, 0]
Name: John
</pre>
<p>输出显示了序列化的对象和打印的<code>Name</code>值，这验证了我们在Rust中使用Cap'n Proto成功地序列化和反序列化了我们的对象。</p>
<h2 id="conclusion">结论</h2>
<p>在本文中，您了解了Cap'n Proto以及如何在Rust中将它用作对象序列化器。</p>
<p>为了进一步加深你的知识，请务必查看GitHub 上的<a href="https://github.com/capnproto/capnproto-rust"> Cap'n Proto以及查看Rust文档的</a><a href="https://docs.capnproto-rust.org/capnp/index.html">。</a></p><div class="code-block code-block-29">
<div class="blog-plug inline-plug rust-plug"><h2><a href="https://lp.logrocket.com/blg/rust-signup" target="_blank">log rocket</a>:Rust应用的web前端的全面可见性</h2><p>调试Rust应用程序可能很困难，尤其是当用户遇到难以重现的问题时。如果您对监控和跟踪Rust应用程序的性能、自动显示错误、跟踪缓慢的网络请求和加载时间感兴趣，</p><a href="https://lp.logrocket.com/blg/rust-signup" target="_blank">try LogRocket</a><p>. </p><a class="signup" href="https://lp.logrocket.com/blg/rust-signup" target="_blank" rel="noopener noreferrer"><img class="alignnone size-full wp-image-46 jetpack-lazy-image" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/><noscript><img data-lazy-fallback="1" class="alignnone size-full wp-image-46" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/></noscript></a><p>LogRocket 就像是网络和移动应用程序的DVR，记录你的Rust应用程序上发生的一切。您可以汇总并报告问题发生时应用程序的状态，而不是猜测问题发生的原因。LogRocket还可以监控应用的性能，报告客户端CPU负载、客户端内存使用等指标。</p><p>现代化调试Rust应用的方式— <a class="signup" href="https://lp.logrocket.com/blg/rust-signup" target="_blank" rel="noopener noreferrer">开始免费监控</a>。</p></div>


</div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
<html>
<head>
<title>What’s new in the latest GraphQL spec - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>最新的 GraphQL spec - LogRocket 博客中有什么新内容</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/whats-new-latest-graphql-spec/#0001-01-01">https://blog.logrocket.com/whats-new-latest-graphql-spec/#0001-01-01</a></blockquote><div><article class="article-post">
<p>GraphQL 规范的新版本已经发布:【2021 年 10 月版。这个新版本比上一个版本(从 2018 年 6 月开始)晚了三年多，涉及 35 名贡献者，他们做出了近 100 项更改。</p>
<p>你可能会认为，在三年的工作之后，规范中会有主要的新特性。不过，检查一下<a href="https://github.com/graphql/graphql-spec/blob/main/changelogs/October2021.md" target="_blank" rel="noopener">变更日志</a>，我们可以看到大部分的改变都是简单的改进，只有一小部分是真正的新特性。你可能会想，如果其中只有几个是新特性，为什么这个新版本要花三年多的时间来制作呢？</p>
<p>在本文中，我们将解决这个问题，仔细研究新添加的特性，看看哪些令人兴奋的新特性没有出现在新版本中。</p>
<h2>为什么新规范过了这么久才发布？</h2>
<p>生产一个新版本的 GraphQL 规范基本上相当于标记了<a href="https://github.com/graphql/graphql-spec" target="_blank" rel="noopener"> GitHub repo <code>graphql/graphql-spec</code> </a>。为什么维护人员要花三年多的时间来做？</p>
<p>GraphQL Java 创建者和规范贡献者 Andi Marek 给了我们一个答案，他说<a href="https://www.graphql-java.com/blog/spec-releases-are-not-important/" target="_blank" rel="noopener">graph QL 规范发布并不重要</a>。正如他所解释的，除了正式发布之外，GraphQL spec 还<a href="https://spec.graphql.org/" target="_blank" rel="noopener">发布了预发布工作草案</a>，该草案更为常规且持续地更新:</p>
<p><img data-attachment-id="82793" data-permalink="https://blog.logrocket.com/whats-new-latest-graphql-spec/attachment/graphql-working-draft-spec-releases-page/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2021/12/graphql-working-draft-spec-releases-page.png" data-orig-size="730,456" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="graphql-working-draft-spec-releases-page" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2021/12/graphql-working-draft-spec-releases-page-300x187.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2021/12/graphql-working-draft-spec-releases-page.png" decoding="async" class="aligncenter size-full wp-image-82793 jetpack-lazy-image" src="../Images/06b602dec2d7a71776aeac1ab0fcb24a.png" alt="Working Draft in the GraphQL spec releases page" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2021/12/graphql-working-draft-spec-releases-page.png 730w, https://blog.logrocket.com/wp-content/uploads/2021/12/graphql-working-draft-spec-releases-page-300x187.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2021/12/graphql-working-draft-spec-releases-page.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2021/12/graphql-working-draft-spec-releases-page.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="82793" data-permalink="https://blog.logrocket.com/whats-new-latest-graphql-spec/attachment/graphql-working-draft-spec-releases-page/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2021/12/graphql-working-draft-spec-releases-page.png" data-orig-size="730,456" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="graphql-working-draft-spec-releases-page" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2021/12/graphql-working-draft-spec-releases-page-300x187.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2021/12/graphql-working-draft-spec-releases-page.png" decoding="async" loading="lazy" class="aligncenter size-full wp-image-82793" src="../Images/06b602dec2d7a71776aeac1ab0fcb24a.png" alt="Working Draft in the GraphQL spec releases page" srcset="https://blog.logrocket.com/wp-content/uploads/2021/12/graphql-working-draft-spec-releases-page.png 730w, https://blog.logrocket.com/wp-content/uploads/2021/12/graphql-working-draft-spec-releases-page-300x187.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2021/12/graphql-working-draft-spec-releases-page.png"/></noscript>
<p>因此，GraphQL 服务器、客户端和工具可以直接遵循正在进行的工作草案中的规范，而不需要等待三年以上才能加入新的特性。</p>
<h2>为 GraphQL 规范做出贡献的过程</h2>
<p>对 GraphQL 规范的补充必须满足<a href="https://github.com/graphql/graphql-spec/blob/main/CONTRIBUTING.md#guiding-principles" target="_blank" rel="noopener">指导原则</a>:</p>
<ul>
<li>向后兼容性</li>
<li>性能是一个特征</li>
<li>不赞成改变</li>
<li>启用由真实用例驱动的新功能</li>
<li>简单和一致胜过表达和简洁</li>
<li>保留选项值</li>
<li>可理解性和正确性一样重要</li>
</ul>
<p>纳入<code>graphql/graphql-spec</code>的<code>main</code>分支的所有变更都将经过严格的流程，这也是工作草案作为可靠的临时参考的原因。该流程<a href="https://github.com/graphql/graphql-spec/blob/main/CONTRIBUTING.md#rfc-contribution-stages" target="_blank" rel="noopener">要求冠军推动公关通过四个阶段</a>，然后才能合并:</p>
<ul>
<li>第 0 阶段:斯特劳曼</li>
<li>第一阶段:提案</li>
<li>第二阶段:草稿</li>
<li>第 4 阶段:接受</li>
</ul>
<figure id="attachment_82795" aria-describedby="caption-attachment-82795" class="wp-caption aligncenter"><img data-attachment-id="82795" data-permalink="https://blog.logrocket.com/whats-new-latest-graphql-spec/attachment/graphql-rfc-process/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2021/12/graphql-rfc-process.png" data-orig-size="730,411" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="graphql-rfc-process" data-image-description="" data-image-caption="&lt;p&gt;The GraphQL RFC process. Image credit: Robert Zhu&lt;/p&gt;&#10;" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2021/12/graphql-rfc-process-300x169.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2021/12/graphql-rfc-process.png" decoding="async" class="size-full wp-image-82795 jetpack-lazy-image" src="../Images/b4dd7e987cb9e4f9ca94fd77afb2e985.png" alt="The GraphQL RFC process" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2021/12/graphql-rfc-process.png 730w, https://blog.logrocket.com/wp-content/uploads/2021/12/graphql-rfc-process-300x169.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2021/12/graphql-rfc-process.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2021/12/graphql-rfc-process.png"/><noscript><img data-lazy-fallback="1" data-attachment-id="82795" data-permalink="https://blog.logrocket.com/whats-new-latest-graphql-spec/attachment/graphql-rfc-process/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2021/12/graphql-rfc-process.png" data-orig-size="730,411" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="graphql-rfc-process" data-image-description="" data-image-caption="&lt;p&gt;The GraphQL RFC process. Image credit: Robert Zhu&lt;/p&gt;&#10;" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2021/12/graphql-rfc-process-300x169.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2021/12/graphql-rfc-process.png" decoding="async" loading="lazy" class="size-full wp-image-82795" src="../Images/b4dd7e987cb9e4f9ca94fd77afb2e985.png" alt="The GraphQL RFC process" srcset="https://blog.logrocket.com/wp-content/uploads/2021/12/graphql-rfc-process.png 730w, https://blog.logrocket.com/wp-content/uploads/2021/12/graphql-rfc-process-300x169.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2021/12/graphql-rfc-process.png"/></noscript><figcaption id="caption-attachment-82795" class="wp-caption-text">The GraphQL RFC process. Image credit: <a href="https://www.youtube.com/watch?v=sMTNTy_aOU0" target="_blank" rel="noopener">Robert Zhu</a></figcaption></figure>
<p>在阶段 0，目标是尽早拒绝该提议(例如，因为它产生了不希望的副作用，增加了复杂性，该问题可以通过另一个提议或另一个原因来解决)。</p>
<p>如果没有被拒绝，提案将进入第 1 阶段，这表明指导规范开发的工作组承认这个问题需要解决，并且社区提供了一个或多个可能的解决方案并进行讨论。由于 GraphQL 规范是开源的，任何人都可以贡献自己的建议和解决方案。</p>
<p>在第 2 阶段，解决方案列表缩小到必须为<a href="https://github.com/graphql/graphql-js/" target="_blank" rel="noopener"> <code>graphql-js,</code>(参考 GraphQL 服务器实施)</a>成功实施的特定解决方案。</p>
<p>它在阶段 3“接受”结束，在这个阶段，解决方案被认为是完整的，并被添加到规范中。</p>
<p>要了解更多关于 GraphQL RFC 流程的信息，除了<a href="https://github.com/graphql/graphql-spec/blob/main/CONTRIBUTING.md" target="_blank" rel="noopener"> GraphQL 的投稿指南</a>，我推荐观看这些演讲:</p>

<h2>2021 年 10 月规格的新特性</h2>
<p>让我们探索一下最新 GraphQL 规范中添加的新特性。</p>
<h3>自定义标量规范 URL</h3>

<p>这个特性使我们能够通过一个新的指令<code>@specifiedBy</code>明确地识别定制标量的行为，该指令指向一个包含标量的数据格式、序列化和强制规则的文档。</p>
<p>例如，我们可以声明标量类型<code>DateTime</code>基于 RFC3339，如下所示:</p>
<pre class="language-graphql hljs">scalar DateTime @specifiedBy(url: "https://tools.ietf.org/html/rfc3339")
</pre>
<h3>实现其他接口的接口</h3>

<p>我们现在可以声明 GraphQL 接口本身实现了另一个接口:</p>
<pre class="language-graphql hljs">interface Node {
  id: ID!
}

interface Resource implements Node {
  id: ID!
  url: String
}

interface Image implements Resource &amp; Node {
  id: ID!
  url: String
  thumbnail: String
}
</pre>
<p>请注意，接口仍然必须从其实现的接口中定义字段。这就是为什么字段<code>id</code>在所有三个接口中— <code>Node</code>、<code>Resource</code>和<code>Image</code>—<code>url</code>在<code>Resource</code>和<code>Image</code>中。</p>
<p>另外，<code>Image</code>通过<code>Resource</code>传递实现接口<code>Node</code>，它也需要显式声明它——这就是它实现<code>Resource &amp; Node</code>的原因。</p>
<h3>可重复指令和指令顺序非常重要</h3>

<p>如果使用<code>repeatable</code>关键字声明，现在可以多次添加指令:</p>
<pre class="language-graphql hljs">directive @delegateField(name: String!) repeatable on OBJECT | INTERFACE

type Book
  @delegateField(name: "pageCount")
  @delegateField(name: "author")
{
  id: ID!
}
</pre>
<p>这个新特性表明，应用指令的顺序非常重要。例如，根据提供<code>content</code>参数的顺序，应用指令<code>@appendContent</code>两次将产生不同的结果:</p>
<pre class="language-graphql hljs">directive @appendContent(content: String!) repeatable on FIELD

query {
  post(id:1) {
    # Result: "Hello world! - By Leo - leoloso.com"
    title1: title
      @appendContent(content: " - By Leo")
      @appendContent(content: " - leoloso.com")
    # Result: "Hello world! - leoloso.com - By Leo"
    title2: title
      @appendContent(content: " - leoloso.com")
      @appendContent(content: " - By Leo")
  }
}
</pre>
<p>规范中还增加了声明指令顺序很重要的内容。</p>
<h2>未达到 2021 年 10 月规格的特性</h2>
<p>基本上， <code>graphql/graphql-spec</code>中的任何<a href="https://github.com/graphql/graphql-spec/pulls" target="_blank" rel="noopener">打开拉取请求仍在进行中:</a></p>
<figure id="attachment_82800" aria-describedby="caption-attachment-82800" class="wp-caption aligncenter"><img data-attachment-id="82800" data-permalink="https://blog.logrocket.com/whats-new-latest-graphql-spec/attachment/open-pull-requests-spec/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2021/12/open-pull-requests-spec.png" data-orig-size="730,599" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="open-pull-requests-spec" data-image-description="" data-image-caption="&lt;p&gt;Open PRs in the spec&lt;/p&gt;&#10;" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2021/12/open-pull-requests-spec-300x246.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2021/12/open-pull-requests-spec.png" decoding="async" class="size-full wp-image-82800 jetpack-lazy-image" src="../Images/0497a5455442133567effeb2c43df690.png" alt="The remaining open pull requests in the speec" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2021/12/open-pull-requests-spec.png 730w, https://blog.logrocket.com/wp-content/uploads/2021/12/open-pull-requests-spec-300x246.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2021/12/open-pull-requests-spec.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2021/12/open-pull-requests-spec.png"/><noscript><img data-lazy-fallback="1" data-attachment-id="82800" data-permalink="https://blog.logrocket.com/whats-new-latest-graphql-spec/attachment/open-pull-requests-spec/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2021/12/open-pull-requests-spec.png" data-orig-size="730,599" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="open-pull-requests-spec" data-image-description="" data-image-caption="&lt;p&gt;Open PRs in the spec&lt;/p&gt;&#10;" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2021/12/open-pull-requests-spec-300x246.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2021/12/open-pull-requests-spec.png" decoding="async" loading="lazy" class="size-full wp-image-82800" src="../Images/0497a5455442133567effeb2c43df690.png" alt="The remaining open pull requests in the speec" srcset="https://blog.logrocket.com/wp-content/uploads/2021/12/open-pull-requests-spec.png 730w, https://blog.logrocket.com/wp-content/uploads/2021/12/open-pull-requests-spec-300x246.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2021/12/open-pull-requests-spec.png"/></noscript><figcaption id="caption-attachment-82800" class="wp-caption-text">Open PRs in the spec</figcaption></figure>
<p>其中一些特性对 GraphQL 的未来非常重要，但可能需要几年时间才能将它们添加到规范中。</p>
<p>一个例子是包含多态输入联合类型，这将允许向同一个字段提供不同类型的值。这个特性将有助于<a href="https://github.com/graphql/graphql-spec/issues/215" target="_blank" rel="noopener">支持输入的标量类型</a>的联合(这在五年前就已经提出了)，并展示了对输出做同样事情的方法。</p>
<p>为什么要花这么长时间？答案是贡献者正在确保被接受的解决方案是可用的最佳解决方案。考虑到 GraphQL 已经变得如此之大，以及有多少利益相关者，这并不是一项容易的任务。</p>
<p>工作组阅读 GraphQL 输入联合上的<a href="https://github.com/graphql/graphql-wg/blob/main/rfcs/InputUnion.md" target="_blank" rel="noopener"> RFC，证明了挑战的范围，以及贡献者对细节的关注。这个提议已经被反复讨论了好几次，每一次都取代了前一次:</a></p>

<p>经过贡献者的详尽研究，以及工作组内部的协商，似乎<code>oneof</code>输入对象和<code>oneof</code>字段<a href="https://github.com/graphql/graphql-js/pull/1196#issuecomment-976455911" target="_blank" rel="noopener">将是选择的解决方案</a>。因此，这个特性将(或者应该)很快被合并到 GraphQL 规范中。</p>
<p>尽管这一过程可能需要很长时间，但这种详细的研究和尽职调查意味着没有捷径可走，让我们长期安心。每当新的提议最终被规范接受时，我们很可能不会为它所采用的解决方案而后悔。</p>
<p>在开放的 pr 中，还有其他几个 pr，一旦获得批准，将对 GraphQL 产生重大影响:</p>
<ul>
<li>允许完整的 Unicode 范围(<a href="https://github.com/graphql/graphql-spec/pull/849" target="_blank" rel="noopener"> #849 </a>)将在 GraphQL 查询中使用表情符号解锁🎉</li>
<li>输入值(<a href="https://github.com/graphql/graphql-spec/pull/805" target="_blank" rel="noopener"> #805 </a>)的弃用将增强版本控制</li>
<li><code>@defer</code>和<code>@stream</code>指令(<a href="https://github.com/graphql/graphql-spec/pull/742" target="_blank" rel="noopener"> #742 </a>)将提高获取数据时的性能</li>
</ul>
<p>我非常渴望看到这些 PRs 完成！</p>
<h2>结论</h2>
<p>在本文中，我们回顾了 2021 年 10 月的最新版本中添加了哪些重要贡献，并探索了接下来会有哪些令人兴奋的新功能。</p>
<p>新 GraphQL 规范的发布周期很慢，这就是为什么最新版本花了三年多才发布。这是有意为之的:GraphQL 已经很好地建立起来，并被无数的利益相关者使用，所以如果不仔细考虑就不能添加新的特性。除了我们上面列出的其他指导原则之外，当前的流程确保每个新功能都是确实需要的，并且不会与以前的版本不兼容。</p>
<p>然而，这并不代表一个问题，因为 GraphQL 生态系统可以依靠最新的工作草案保持稳定的发展速度，该草案正在不断更新最新的功能。</p><div class="code-block code-block-24">
<div class="blog-plug inline-plug graphql-plug"><h2>监控生产中失败和缓慢的 GraphQL 请求</h2><p>虽然 GraphQL 有一些调试请求和响应的特性，但确保 GraphQL 可靠地为您的生产应用程序提供资源是一件比较困难的事情。如果您对确保对后端或第三方服务的网络请求成功感兴趣，</p><a href="https://lp.logrocket.com/blg/graphql-signup" target="_blank">try LogRocket</a><p>.</p><a class="signup" href="https://lp.logrocket.com/blg/graphql-signup" target="_blank" rel="noopener noreferrer"><img src="../Images/432a3823c85b3fb72a206e6236a29f48.png" data-lazy-src="https://files.readme.io/69aa835-Image_2019-11-09_at_1.28.05_PM.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" class=" jetpack-lazy-image" data-original-src="https://files.readme.io/69aa835-Image_2019-11-09_at_1.28.05_PM.png"/><noscript><img data-lazy-fallback="1" src="../Images/432a3823c85b3fb72a206e6236a29f48.png" data-original-src="https://files.readme.io/69aa835-Image_2019-11-09_at_1.28.05_PM.png"/></noscript><img class="alignnone size-full wp-image-46 jetpack-lazy-image" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/><noscript><img data-lazy-fallback="1" class="alignnone size-full wp-image-46" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/></noscript></a><a href="https://lp.logrocket.com/blg/graphql-signup" target="_blank" rel="noopener noreferrer">https://logrocket.com/signup/</a><p>LogRocket 就像是网络和移动应用的 DVR，记录下你网站上发生的每一件事。您可以汇总并报告有问题的 GraphQL 请求，以快速了解根本原因，而不是猜测问题发生的原因。此外，您可以跟踪 Apollo 客户机状态并检查 GraphQL 查询的键值对。</p><p>LogRocket 检测您的应用程序以记录基线性能计时，如页面加载时间、到达第一个字节的时间、慢速网络请求，还记录 Redux、NgRx 和 Vuex 操作/状态。</p><a class="signup" href="https://lp.logrocket.com/blg/graphql-signup" target="_blank" rel="noopener noreferrer">Start monitoring for free</a><p>.</p></div>


</div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
<html>
<head>
<title>The guide to conditional types in TypeScript </title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>TypeScript中的条件类型指南</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/guide-conditional-types-typescript/#0001-01-01">https://blog.logrocket.com/guide-conditional-types-typescript/#0001-01-01</a></blockquote><div><article class="article-post">
<p>从2.8版开始，TypeScript引入了对条件类型的支持。它们可能是一个利基特性，但是，正如我们将看到的，它们是一个非常有用的附加功能，可以帮助我们编写可重用的代码。</p>
<p>在本文中，我们将了解什么是条件类型，以及为什么我们可能会频繁地使用它们，即使我们并不知道这一点。</p>

<h2 id="what-are-conditional-types">什么是条件类型？</h2>
<p>条件类型让我们根据条件确定性地定义类型转换。简而言之，它们是应用于类型级别而不是值级别的三元条件运算符。</p>
<p>条件类型定义如下:</p>
<pre class="language-typescript hljs">type ConditionalType = SomeType extends OtherType ? TrueType : FalseType</pre>
<p>简单地说，上面的定义如下:</p>
<blockquote><p>如果一个给定类型<code>SomeType</code>扩展了另一个给定类型<code>OtherType</code>，那么<code>ConditionalType</code>就是<code>TrueType</code>，否则就是<code>FalseType</code>。</p></blockquote>
<p>通常，<code>extends</code>在这里意味着任何类型为<code>SomeType</code>的值也是类型为<code>OtherType</code>的值。</p>
<p>条件类型可以是递归的；也就是说，一个或两个分支本身可以是条件类型:</p>
<pre class="language-typescript hljs">type Recursive&lt;T&gt; = T extends string[] ? string : (T extends number[] ? number : never)
 
const a: Recursive&lt;string[]&gt; = "10" // works
const b: Recursive&lt;string&gt; = 10 // Error: Type 'number' is not assignable to type 'never'.</pre>
<h3 id="constraints-on-conditional-types">条件类型的约束</h3>
<p>条件类型的主要优势之一是它们能够缩小泛型类型的可能实际类型。</p>
<p>例如，假设我们想要定义<code>ExtractIdType&lt;T&gt;</code>，从一个泛型<code>T</code>中提取一个名为<code>id</code>的属性的类型。在这种情况下，实际的泛型类型<code>T</code>必须有一个名为<code>id</code>的属性。起初，我们可能会想到类似下面的代码片段:</p>
<pre class="language-typescript hljs">type ExtractIdType&lt;T extends {id: string | number}&gt; = T["id"]

interface NumericId {
    id: number
}

interface StringId {
    id: string
}

interface BooleanId {
    id: boolean
}

type NumericIdType = ExtractIdType&lt;NumericId&gt; // type NumericIdType = number
type StringIdType = ExtractIdType&lt;StringId&gt; // type StringIdType = string
type BooleanIdType = ExtractIdType&lt;BooleanId&gt; // won't work</pre>
<p>这里，我们明确表示<code>T</code>必须有一个名为<code>id</code>的属性，类型可以是<code>string</code>或<code>number</code>。然后，我们定义了三个接口:<code>NumericId</code>、<code>StringId</code>和<code>BooleanId</code>。</p>
<p>如果我们试图提取<code>id</code>属性的类型，TypeScript会正确地分别为<code>StringId</code>和<code>NumericId</code>返回<code>string</code>和<code>number</code>。但是对于<code>BooleanId</code> : <code>Type 'BooleanId' does not satisfy the constraint '{ id: string | number; }'. Types of property 'id' are incompatible. Type 'boolean' is not assignable to type 'string | number'</code>则不成立。</p>
<p>但是，如果<code>T</code>没有定义所需的<code>id</code>属性，我们如何增强我们的<code>ExtractIdType</code>来接受任何类型<code>T</code>，然后求助于类似于<code>never</code>的东西呢？我们可以使用条件类型来做到这一点:</p>
<pre class="language-typescript hljs">type ExtractIdType&lt;T&gt; = T extends {id: string | number} ? T["id"] : never

interface NumericId {
    id: number
}

interface StringId {
    id: string
}

interface BooleanId {
    id: boolean
}

type NumericIdType = ExtractIdType&lt;NumericId&gt; // type NumericIdType = number
type StringIdType = ExtractIdType&lt;StringId&gt; // type StringIdType = string
type BooleanIdType = ExtractIdType&lt;BooleanId&gt; // type BooleanIdType = never</pre>
<p>通过简单地移动条件类型中的约束，我们能够使<code>BooleanIdType</code>的定义起作用。在第二个版本中，TypeScript知道如果第一个分支为真，那么<code>T</code>将有一个名为<code>id</code>的属性，类型为<code>string | number</code>。</p>
<h2 id="type-inference-in-conditional-types">条件类型中的类型推理</h2>
<p>使用条件类型来应用约束和提取属性类型是如此普遍，以至于我们可以为此使用一个更好的语法。例如，我们可以将<code>ExtractIdType</code>的定义改写如下:</p>
<pre class="language-typescript hljs">type ExtractIdType&lt;T&gt; = T extends {id: infer U} ? T["id"] : never

interface BooleanId {
    id: boolean
}

type BooleanIdType = ExtractIdType&lt;BooleanId&gt; // type BooleanIdType = boolean</pre>
<p>在这种情况下，我们细化了<code>ExtractIdType</code>类型。我们没有强制id属性的类型为string | number，而是使用<code>infer</code>关键字引入了一个新的类型<code>U</code>。因此，<code>BooleanIdType</code>不会再对<code>never</code>求值了。事实上，TypeScript会像预期的那样提取<code>boolean</code>。</p>
<p><code>infer</code>为我们提供了一种引入新的泛型类型的方法，而不是指定如何从真正的分支中检索元素类型。</p>
<p>在文章的最后，我们将看到一些有用的依赖于<code>infer</code>关键字的内置类型。</p>
<h2 id="distributive-conditional-types">分配条件类型</h2>
<p>在TypeScript中，条件类型分布在联合类型上。换句话说，当根据联合类型进行计算时，条件类型适用于联合的所有成员。让我们看一个例子:</p>
<pre class="language-typescript hljs">type ToStringArray&lt;T&gt; = T extends string ? T[] : never

type StringArray = ToStringArray&lt;string | number&gt;</pre>
<p>在上面的例子中，我们简单地定义了一个名为<code>ToStringArray</code>的条件类型，当且仅当它的泛型参数是<code>string</code>时，计算结果为<code>string[]</code>。否则评估为<code>never</code>。</p>
<p>现在让我们看看TypeScript如何评估<code>ToStringArray&lt;string | number&gt;</code>来定义<code>StringArray</code>。第一，<code>ToStringArray</code>分布在联邦:</p>
<pre class="language-typescript hljs">type StringArray = ToStringArray&lt;string&gt; | ToStringArray&lt;number&gt;</pre>
<p>然后，我们可以用它的定义代替<code>ToStringArray</code>:</p>
<pre class="language-typescript hljs">type StringArray = (string extends string ? string[] : never) | (number extends string ? number[] : never)</pre>
<p>评估条件句给我们留下以下定义:</p>
<pre class="language-typescript hljs">type StringArray = string[] | never</pre>
<p>由于<code>never</code>是任何类型的子类型，我们可以将其从联合中移除:</p>
<pre class="language-typescript hljs">type StringArray = string[]</pre>
<p>大多数情况下，条件类型的分配属性是需要的。尽管如此，为了避免这种情况，我们可以用方括号将<code>extends</code>关键字的两边括起来:</p>
<pre class="language-typescript hljs">type ToStringArray&lt;T&gt; = [T] extends [string] ? T[] : never</pre>
<p>在这种情况下，当评估<code>StringArray</code>时，<code>ToStringArray</code>的定义不再分布:</p>
<pre class="language-typescript hljs">type StringArray = ((string | number) extends string ? (string | number)[] : never)</pre>
<p>因此，由于<code>string | number</code>不延伸，<code>string, StringArray</code>将变成<code>never</code>。</p>
<p>最后，如果联合类型是一个更大的表达式(即函数、对象或元组)的一部分，那么分布式属性就不成立，不管这个更大的表达式是出现在<code>extends</code>之前还是之后。让我们看一个例子:</p>
<pre class="language-typescript hljs">type NonDistributiveFunction&lt;T&gt; = (() =&gt; T) extends (() =&gt; string | number) ? T : never</pre>
<pre class="language-typescript hljs">type Fun1 = NonDistributiveFunction&lt;string | boolean&gt; // type Fun1 = never

type Fun2 = NonDistributiveFunction&lt;string&gt; // type Fun2 = string</pre>
<h2 id="inbuilt-conditional-types">内置条件类型</h2>
<p>这最后一节展示了几个由TypeScript的标准库定义的条件类型的例子。</p>
<h3 id="nonnullable"><code>NonNullable&lt;T&gt;</code></h3>
<p><code>NonNullable&lt;T&gt;</code>从类型<code>T</code>中过滤出<code>null</code>和<code>undefined</code>值:</p>
<pre class="language-typescript hljs">type NonNullable&lt;T&gt; = T extends null | undefined ? never : T
type A = NonNullable&lt;number&gt; // number
type B = NonNullable&lt;number | null&gt; // number
type C = NonNullable&lt;number | undefined&gt; // number
type D = NonNullable&lt;null | undefined&gt; // never</pre>
<h3 id="extract-and-exclude"><code>Extract&lt;T, U&gt; and Exclude&lt;T, U&gt;</code></h3>
<p><code>Extract&lt;T, U&gt;</code>和<code> </code>是彼此的对立面。前者过滤<code>T</code>类型，保留所有可赋给<code>U</code>的类型。另一方面，后者将保留不可分配给<code>U</code>的类型:</p>
<pre class="language-typescript hljs">type Extract&lt;T, U&gt; = T extends U ? T : never
type Exclude&lt;T, U&gt; = T extends U ? never : T

type A = Extract&lt;string | string[], any[]&gt; // string[]
type B = Exclude&lt;string | string[], any[]&gt; // string

type C = Extract&lt;number, boolean&gt; // never
type D = Exclude&lt;number, boolean&gt; // number</pre>
<p>在上面的例子中，当定义<code>A</code>时，我们要求TypeScript从<code>string | string[]</code>中过滤掉所有不可分配给<code>any[]</code>的类型。那只会是字符串，因为<code>string[]</code>完全可以分配给<code>any[]</code>。相反，当我们定义<code>B</code>时，我们要求TypeScript做正好相反的事情。不出所料，结果是字符串，而不是<code>string[]</code>。</p>
<p>同样的论点适用于<code>C</code>和<code>D</code>。在<code>C</code>的定义中，数字不可分配给<code>boolean</code>。因此，TypeScript推断<code>never</code>是一种类型。到了定义<code>D</code>的时候，反而是TypeScript保留了<code>number</code>。</p>
<h3 id="parameters-and-returntype"><code>Parameters&lt;T&gt; and ReturnType&lt;T&gt;</code></h3>
<p><code>Parameters&lt;T&gt;</code>和<code>ReturnType&lt;T&gt;</code>让我们分别提取一个函数类型的所有参数类型和返回类型:</p>
<pre class="language-typescript hljs">type Parameters&lt;T&gt; = T extends (...args: infer P) =&gt; any ? P : never
type ReturnType&lt;T&gt; = T extends (...args: any) =&gt; infer R ? R : any
type A = Parameters&lt;(n: number, s: string) =&gt; void&gt; // [n: number, s: string]
type B = ReturnType&lt;(n: number, s: string) =&gt; void&gt; // void

type C = Parameters&lt;() =&gt; () =&gt; void&gt; // []
type D = ReturnType&lt;() =&gt; () =&gt; void&gt; // () =&gt; void
type E = ReturnType&lt;D&gt; // void</pre>
<p><code>Parameters&lt;T&gt;</code>的声明有点复杂。它基本上会产生一个包含所有参数类型的元组类型(如果<code>T</code>不是函数，则为<code>never</code>)。</p>
<p>特别地，<code>(...args: infer P) =&gt; any</code>表示一个函数类型，其中所有参数(<code>P</code>)的实际类型被推断出来。任何函数都可以赋给它，因为对参数的类型没有限制，返回类型是<code>any</code>。</p>
<p>类似地，<code>ReturnType&lt;T&gt;</code>提取函数的返回类型。在这种情况下，我们使用<code>any</code>来表示参数可以是任何类型。然后，我们推断返回类型<code>R</code>。</p>
<h3 id="constructorparameters-and-instancetype"><code>ConstructorParameters&lt;T&gt; and InstanceType&lt;T&gt;</code></h3>
<p><code>ConstructorParameters&lt;T&gt;</code>和<code>InstanceType&lt;T&gt;</code>与<code>Parameters&lt;T&gt;</code>和<code>ReturnType&lt;T&gt;</code>是一样的东西，应用于构造函数类型而不是函数类型:</p>
<pre class="language-typescript hljs">type ConstructorParameters&lt;T&gt; = T extends new (...args: infer P) =&gt; any ? P : never
type InstanceType&lt;T&gt; = T extends new (...args: any[]) =&gt; infer R ? R : any

interface PointConstructor {
    new (x: number, y: number): Point
}

class Point {
    private x: number;

    private y: number;

    constructor(x: number, y: number) {
            this.x = x;
            this.y = y
    }
}

type A = ConstructorParameters&lt;PointConstructor&gt; // [x: number, y: number]
type B = InstanceType&lt;PointConstructor&gt; // Point</pre>
<h2 id="conclusion">结论</h2>
<p>在本文中，我们探讨了TypeScript中的条件类型。我们从基本定义以及如何使用它来实施约束开始。然后我们看到了类型推理是如何工作的，并探索了<a href="https://blog.logrocket.com/understanding-discriminated-union-intersection-types-typescript/">联合类型</a>的分布式属性的工作原理。最后，我们查看了由TypeScript定义的一些常见的实用程序条件类型:我们分析了它们的定义，并用几个例子对它们进行了补充。</p>
<p>正如我们在本文中看到的，条件类型是类型系统的一个非常高级的特性。然而，我们最终很可能几乎每天都要使用它们，因为TypeScript的标准库广泛使用它们。</p>
<p>希望这篇文章能帮助你编写你自己的类型来简化你的代码，并使它更具可读性和可维护性。</p><div class="code-block code-block-21">
<div class="blog-plug inline-plug typescript-plug"><h2><a class="signup" href="https://lp.logrocket.com/blg/typescript-signup" target="_blank" rel="noopener noreferrer"> LogRocket </a>:全面了解您的网络和移动应用</h2>
<a href="https://lp.logrocket.com/blg/typescript-signup" class="signup" target="_blank" rel="noopener noreferrer"><img class="alignnone size-full wp-image-46 jetpack-lazy-image" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/><noscript><img data-lazy-fallback="1" class="alignnone size-full wp-image-46" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/></noscript></a>
<p>LogRocket 是一个前端应用程序监控解决方案，可以让您回放问题，就像问题发生在您自己的浏览器中一样。LogRocket不需要猜测错误发生的原因，也不需要向用户询问截图和日志转储，而是让您重放会话以快速了解哪里出错了。它可以与任何应用程序完美配合，不管是什么框架，并且有插件可以记录来自Redux、Vuex和@ngrx/store的额外上下文。</p>
<p>除了记录Redux操作和状态，LogRocket还记录控制台日志、JavaScript错误、堆栈跟踪、带有头+正文的网络请求/响应、浏览器元数据和自定义日志。它还使用DOM来记录页面上的HTML和CSS，甚至为最复杂的单页面和移动应用程序重新创建像素级完美视频。</p>
<a class="signup" href="https://lp.logrocket.com/blg/typescript-signup" target="_blank" rel="noopener noreferrer">Try it for free</a><p>.</p></div>
</div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
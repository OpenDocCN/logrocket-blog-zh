<html>
<head>
<title>5 GraphQL clients for JavaScript and Node.js - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>5 个用于 JavaScript 和 Node.js 的 GraphQL 客户端- LogRocket 博客</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/5-graphql-clients-for-javascript-and-node-js/#0001-01-01">https://blog.logrocket.com/5-graphql-clients-for-javascript-and-node-js/#0001-01-01</a></blockquote><div><article class="article-post">
<p>GraphQL 是一种用于 API 的查询语言和运行时。它使客户端能够指定查询，并允许服务器根据强类型模式验证数据。</p>
<p>与 REST APIs 不同，GraphQL 对所有操作使用单个端点。基于 GraphQL 的服务器只能通过 GraphQL 查询进行通信。对于简单的项目，使用 REST 客户端发送 GraphQL 查询是可行的，比如<a href="https://blog.logrocket.com/axios-or-fetch-api/"> Axios 或<code>fetch()</code> </a>。然而，对于具有高级需求的更大、更复杂的项目，需要一个 GraphQL 客户端。</p>
<p>GraphQL 客户端通过提取小细节和实现附加功能(其中一些包括缓存、查询批处理和重复数据删除，以及 GraphQL 查询结果的静态类型)来简化通信。</p>
<p>在本指南中，我们将比较以下五个 GraphQL 客户端，并从功能、社区支持和大小方面对每个客户端进行评估。</p>

<p>我们开始吧！</p>
<h2 id="graphqlrequest"><code>graphql-request</code></h2>
<p><code><a href="https://graphql.org/code/">graphql-request</a></code>是一个非常小的 GraphQL 客户端。该库是同构的，这意味着它支持 Node.js 和浏览器。它有一流的打字支持，所以打字永远不会过时。该库仅重 5.2 kb(T2)。</p>
<h3>活动</h3>
<p>在撰写本文时，<a href="https://github.com/prisma-labs/graphql-request"> 3.7K stars </a>的 GitHub 库活动是健康的。在 npm 上，<code>graphql-request</code>是<a href="https://www.npmjs.com/package/graphql-request#whats-the-difference-between-graphql-request-apollo-and-relay">在撰写本文时每周下载超过 130 万次</a>，所以你在网上寻找帮助应该不会有任何问题！</p>
<h3>赞成的意见</h3>
<p><code>graphql-request</code>易于使用，几乎没有学习曲线:</p>
<pre>import { GraphQLClient, gql } from 'graphql-request'
const query = gql`{
  hero {
    name  
  }
}`
const client = new GraphQLClient('&lt;graphql-endpoint&gt;')
const data = await client.request(query)
</pre>
<ul>
<li>适用于服务器和客户端</li>
<li>支持类型脚本</li>
<li>非常轻便</li>
<li>强大的社区支持</li>
</ul>
<h3>骗局</h3>
<ul>
<li>不支持查询缓存和重复数据删除等高级功能</li>
<li>不支持 GraphQL 订阅</li>
</ul>
<h2 id="apolloclient">阿波罗客户端</h2>
<p><a href="https://www.apollographql.com/docs/react/"> Apollo 客户端</a>是一个高级的 GraphQL 客户端，仅用于前端。它包括缓存、查询批处理、查询重复数据删除和分页功能。它还可以用来代替 Redux 存储管理本地状态。基库重约<a href="https://bundlephobia.com/package/@apollo/client@3.3.6"> 33.9kB </a>。</p>
<p>Apollo 客户端是用 TypeScript 编写的，所以 TypeScript 支持非常出色。它集成了流行的框架和库，如 React、Next.js、Angular 和 vue . js。Apollo Client 还有一个用于检查和查询的<a href="https://chrome.google.com/webstore/detail/apollo-client-devtools/jdkknkkbebbapilgoeccciglkfbmbnfm?utm_source=chrome-ntp-icon"> Chrome 扩展</a>。</p>
<h3>活动</h3>
<p>阿波罗客户端每月至少更新一次。它在 npm 上每周下载<a href="https://www.npmjs.com/package/apollo-client">超过 100 万次</a>，在撰写本文时在 GitHub 上拥有超过<a href="https://github.com/apollographql/apollo-client"> 16K 颗星星和 2K 个分叉</a>。</p>
<h3>赞成的意见</h3>
<ul>
<li>强大而全面</li>
<li>满足大多数使用案例</li>
<li>支持类型脚本</li>
<li>流行 UI 库和框架的集成</li>
<li>iOS 和 Android 的集成</li>
<li>用于检查查询的 Chrome 扩展</li>
</ul>
<p>除了在 npm 和 GitHub 上的活动，Apollo Client 还享有在线支持，其形式是专门的<a href="https://community.apollographql.com">社区论坛</a>。它也有来自<a href="https://www.apollographql.com">阿波罗 GraphQL 公司</a>的商业支持</p>
<h3>骗局</h3>
<ul>
<li>查询批处理、持久化查询和缓存等高级功能的学习曲线很陡</li>
</ul>
<h2 id="urql">urql</h2>
<p>urql 的目标是通过内置的缓存机制和合理的默认设置，既<a href="https://blog.logrocket.com/why-i-finally-switched-to-urql-from-apollo-client/">易用又</a>可扩展。除了在服务器端使用 Node.js 的核心库之外，urql 还有 Preact、react 和 Svelte 的客户端。</p>
<p>urql 的 bundle 尺寸很小，<a href="https://formidable.com/open-source/urql/docs/comparison/">只有 7.1kB </a>重。它是少数几个内置离线支持的 GraphQL 库之一。</p>
<h3>活动</h3>
<p>在撰写本文时，urql 库在 npm 上每周<a href="https://www.npmjs.com/package/urql">被下载 95K 次</a>，在 GitHub 上，urql 已经<a href="https://github.com/FormidableLabs/urql">收到超过 6K 颗星星</a>。</p>
<h3>赞成的意见</h3>
<p>urql 是健壮的，但对于基本功能来说仍然很容易使用:</p>
<pre>const QUERY = `
  query Test($id: ID!) {
    getUser(id: $id) {
      id
      name
    }
  }
`;
const result = client.readQuery(QUERY, { id: 'test' });
</pre>
<ul>
<li>清晰易读的文档</li>
<li>支持类型脚本</li>
<li>许多流行的 UI 库和框架的集成</li>
<li>用于检查查询的浏览器扩展</li>
<li>内置脱机支持</li>
<li>小捆尺寸</li>
</ul>
<h3>骗局</h3>
<ul>
<li>不支持角度</li>
<li>不支持查询批处理</li>
<li>没有内置的分页支持</li>
<li>与其他 GraphQL 客户端相比，社区规模较小</li>
</ul>
<h2 id="relay">继电器</h2>
<p>Relay 是一个由脸书开发的高性能和可伸缩的 GraphQL 客户端。</p>
<p>正如您可能猜到的那样，Relay 是在考虑 React 的情况下构建的。因此，它采用基于组件的方法来获取数据。Relay 是非常固执己见的，并且严格用于 React 前端。中继的<a href="https://bundlephobia.com/package/react-relay@11.0.2">包大小为 47.1 kB </a>。</p>
<h3>活动</h3>
<p>在撰写本文时，Relay 在 npm 上每周至少被下载<a href="https://www.npmjs.com/package/react-relay">94K 次</a>，并在 GitHub 上收到了超过 15K 颗星的<a href="https://github.com/facebook/relay">和超过 1.5K 个叉的</a>。</p>
<h3>赞成的意见</h3>
<ul>
<li>缓存、查询重复数据消除、分页和本地状态管理的高级功能</li>
<li>与 React 紧密集成，赋予它更高阶的组件和钩子</li>
<li>受到脸书和 Quora 等顶级公司的信任</li>
</ul>
<h3>骗局</h3>
<ul>
<li>只有支架起作用</li>
<li>非常固执己见，因为它僵化的传统</li>
<li>与其他客户相比，学习曲线更陡</li>
<li>文档很难解析</li>
<li>中继客户端只能与兼容<a href="https://blog.logrocket.com/making-a-graphql-server-compatible-with-relay/">中继的</a> GraphQL 服务器通信</li>
</ul>
<p>通过执行一个严格的惯例，接力减少了犯错的空间，这可能是积极的，也可能是消极的。</p>
<h2 id="graphqlhooks"><code>graphql-hooks</code></h2>
<p><code><a href="https://www.nearform.com/blog/introducing-graphql-hooks/">graphql-hooks</a></code>是 React 的一个非常小的 GraphQL 客户端。尽管很小，<code>graphql-hooks</code>却拥有一流的缓存、分页、认证、文件上传和服务器端渲染支持。它的包大小<a href="https://bundlephobia.com/package/graphql-hooks@5.2.0">仅重 3.6kB </a>。</p>
<p>客户端提供了<code>useQuery</code>、<code>useMutation</code>和<code>useSubscription</code> React 钩子，分别用于处理查询、突变和订阅。官方文档包括从阿波罗客户端迁移<a href="https://www.apollographql.com/docs/react/migrating/hooks-migration/">的指南。</a></p>
<h3>活动</h3>
<p><code>graphql-hooks</code>在 npm 上每月下载<a href="https://www.npmjs.com/package/graphql-hooks"> 6K 次，与 GitHub </a>上的<a href="https://github.com/nearform/graphql-hooks"> 1.5K 明星一起。</a></p>
<h3>赞成的意见</h3>
<ul>
<li>支持类型脚本</li>
<li>对缓存、分页和 SSR 等高级功能的支持是现成的</li>
<li>非常小的尺寸</li>
<li>API 的表面积很小</li>
</ul>
<h3>骗局</h3>
<ul>
<li>只有支架起作用</li>
<li>小社区</li>
</ul>
<h2 id="choosingtherightgraphqlclientforyourproject">为您的项目选择正确的 GraphQL 客户端</h2>
<p>下表总结了上面讨论的信息。</p>

<table class="tg">
<colgroup>
<col/>
<col/>
<col/>
<col/>
<col/>
<col/>
<col/>
<col/> </colgroup>
<thead>
<tr>
<th class="tg-cxfx"/>
<th class="tg-0pky"><span>C</span>T2 团结<br/>T5】支持</th>
<th class="tg-cxfx"><span>学习</span> <br/>曲线</th>
<th class="tg-0pky">大小</th>
<th class="tg-0pky"><span>打字稿</span>打字</th>
<th class="tg-0pky"><span>分页、</span>查询缓存、<br/>批处理和重复数据删除</th>
<th class="tg-0lax"><span>同构</span>支持</th>
<th class="tg-0lax"><span>与</span> UI 库和框架的集成</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tg-0pky"><code>graphql-request</code></td>
<td class="tg-0pky">伟大的</td>
<td class="tg-0pky"><span>低</span></td>
<td class="tg-0pky"><span> 5.2 kB </span></td>
<td class="tg-0pky">是</td>
<td class="tg-0pky">不</td>
<td class="tg-0lax">是</td>
<td class="tg-0lax">不</td>
</tr>
<tr>
<td class="tg-0lax"><span>阿波罗客户端</span></td>
<td class="tg-0lax">伟大的</td>
<td class="tg-0lax"><span>中等</span></td>
<td class="tg-0lax"><span> 33.9 kB </span></td>
<td class="tg-0lax">是</td>
<td class="tg-0lax">是</td>
<td class="tg-0lax">仅限客户端</td>
<td class="tg-0lax"><span>反应过来，下一个</span>。js，Angular，Svelte，Ember，web components，<br/> <span>和 Vue </span></td>
</tr>
<tr>
<td class="tg-0lax"><span> urql </span></td>
<td class="tg-0lax">公平的</td>
<td class="tg-0lax"><span>低</span></td>
<td class="tg-0lax"><span> 7.1 kB </span></td>
<td class="tg-0lax">是</td>
<td class="tg-0lax">不支持批处理</td>
<td class="tg-0lax">是</td>
<td class="tg-0lax"><span>反应，苗条，</span>和 Vue</td>
</tr>
<tr>
<td class="tg-0lax"><span>继电器</span></td>
<td class="tg-0lax">公平的</td>
<td class="tg-0lax"><span>高</span></td>
<td class="tg-0lax"><span> 47.1 kB </span></td>
<td class="tg-0lax">不</td>
<td class="tg-0lax">是</td>
<td class="tg-0lax">仅限客户端</td>
<td class="tg-0lax">仅反应</td>
</tr>
<tr>
<td class="tg-0lax"><code>graphql-hooks</code></td>
<td class="tg-0lax">低的</td>
<td class="tg-0lax"><span>低</span></td>
<td class="tg-0lax"><span> 3.6 kB </span></td>
<td class="tg-0lax">是</td>
<td class="tg-0lax">不支持批处理和重复数据删除</td>
<td class="tg-0lax">仅限客户端</td>
<td class="tg-0lax">仅反应</td>
</tr>
</tbody>
</table>
<p>为你的项目选择最好的客户很大程度上取决于你个人的目标和需求。但是，您可以使用下面列出的准则作为起点:</p>
<ul>
<li><code>graphql-request</code>:需求简单的服务器端或前端项目</li>
<li>阿波罗客户端:高级前端项目</li>
<li>urql:运行服务器端的缓存等高级特性</li>
<li>Relay:项目是基于 React 的，需要高级特性，并且包括许多组件</li>
<li>项目是基于 React 的，不需要高级特性</li>
</ul>
<h2 id="conclusion">结论</h2>
<p>GraphQL 客户端使得与 GraphQL APIs 的交互比直接调用它们容易得多。</p>
<p>每个 GraphQL 客户端都有其优点和缺点。选择一个能够为您的用例提供最佳特性的客户端对于一个平稳的开发体验是至关重要的。选择最佳的客户端将取决于您独特的项目，并不总是有一个显而易见的答案。希望这篇文章中的信息能帮助你开始！</p><div class="code-block code-block-24">
<div class="blog-plug inline-plug graphql-plug"><h2>监控生产中失败和缓慢的 GraphQL 请求</h2><p>虽然 GraphQL 有一些调试请求和响应的特性，但确保 GraphQL 可靠地为您的生产应用程序提供资源是一件比较困难的事情。如果您对确保对后端或第三方服务的网络请求成功感兴趣，</p><a href="https://lp.logrocket.com/blg/graphql-signup" target="_blank">try LogRocket</a><p>.</p><a class="signup" href="https://lp.logrocket.com/blg/graphql-signup" target="_blank" rel="noopener noreferrer"><img src="../Images/432a3823c85b3fb72a206e6236a29f48.png" data-lazy-src="https://files.readme.io/69aa835-Image_2019-11-09_at_1.28.05_PM.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" class=" jetpack-lazy-image" data-original-src="https://files.readme.io/69aa835-Image_2019-11-09_at_1.28.05_PM.png"/><noscript><img data-lazy-fallback="1" src="../Images/432a3823c85b3fb72a206e6236a29f48.png" data-original-src="https://files.readme.io/69aa835-Image_2019-11-09_at_1.28.05_PM.png"/></noscript><img class="alignnone size-full wp-image-46 jetpack-lazy-image" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/><noscript><img data-lazy-fallback="1" class="alignnone size-full wp-image-46" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/></noscript></a><a href="https://lp.logrocket.com/blg/graphql-signup" target="_blank" rel="noopener noreferrer">https://logrocket.com/signup/</a><p>LogRocket 就像是网络和移动应用的 DVR，记录下你网站上发生的每一件事。您可以汇总并报告有问题的 GraphQL 请求，以快速了解根本原因，而不是猜测问题发生的原因。此外，您可以跟踪 Apollo 客户机状态并检查 GraphQL 查询的键值对。</p><p>LogRocket 检测您的应用程序以记录基线性能计时，如页面加载时间、到达第一个字节的时间、慢速网络请求，还记录 Redux、NgRx 和 Vuex 操作/状态。</p><a class="signup" href="https://lp.logrocket.com/blg/graphql-signup" target="_blank" rel="noopener noreferrer">Start monitoring for free</a><p>.</p></div>


</div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
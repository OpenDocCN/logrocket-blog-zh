<html>
<head>
<title>Ruck vs. Aleph.js for building React apps in Deno </title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>Ruck vs. Aleph.js在Deno中构建React应用</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/ruck-aleph-building-react-apps-deno/#0001-01-01">https://blog.logrocket.com/ruck-aleph-building-react-apps-deno/#0001-01-01</a></blockquote><div><article class="article-post">
<p>在现代时代建立一个前端是艰难的，因为你必须做出过多的选择。开发人员通常会使用流行的框架，比如React，然后发现自己需要更多的工具来完成工作。</p>
<p>这些工具可能包括捆扎机、试运转机和棉绒机。不仅如此，他们还需要考虑SEO、样式资产、路由、数据获取等等。开发人员在创建生产就绪、高性能的React应用程序时，应该评估所有这些因素。</p>
<p>像<a href="https://create-react-app.dev/"> create-react-app </a>和<a href="https://nextjs.org/"> Next.js </a>这样的项目已经因为提供了那些靠自己实现起来很乏味的功能而广受欢迎。<a href="https://deno.land"> Deno </a>是一个新的JavaScript运行时，正在获得社区的支持。Deno通过支持<a href="https://flaviocopes.com/es-modules/"> ES模块</a>、<a href="https://github.com/WICG/import-maps">导入映射</a>和<a href="https://deno.land/manual@v1.26.0/runtime/web_platform_apis#fetch-api">获取API </a>与已建立的web标准保持一致。</p>
<p>现在的React框架大多只支持在服务器上使用Node.js进行渲染，但是<a href="https://blog.logrocket.com/using-ultra-new-react-web-framework/">一些新的框架确实支持Deno </a>。Deno为Node.js框架必须自己提供的功能提供了许多内置工具。</p>
<p>Deno支持ES模块和TypeScript，因此这些较新的框架可以避免构建步骤，如transpilation。Deno还有一个大型的标准库、用于常见任务(如林挺、格式化和测试)的开发工具，以及一个包管理器。</p>
<p>一些开发人员对Deno持谨慎态度，因为它不支持npm，也不兼容所有Node.js第三方包。根据我的经验，有很多方法可以解决这些限制。</p>
<p><a href="https://ruck.tech"> Ruck </a>和<a href="https://alephjs.org"> Aleph.js </a>是Deno-native React web框架；两者都支持服务器端呈现、数据获取、路由和修改HTTP服务器响应等特性。</p>
<p>在本文中，我们将讨论Ruck和Aleph.js之间的主要相似之处和不同之处，在选择使用哪种框架时，这些相似之处和不同之处是很重要的。</p>
<p><em>向前跳转:</em></p>

<h2 id="ruck-overview">Ruck概述</h2>
<p>Ruck是用Deno构建React应用程序的最小框架。它倾向于Deno特有的特性，如es模块和导入映射，这使它成为新运行时的绝佳展示平台。</p>
<p>然而，Ruck不使用捆绑器，所以它不支持用JSX编写React组件，所有配置都是在代码中定义的。到处使用<code>createElement</code>并不是最好的开发者体验！</p>
<p>我可以看到另一个框架采用Ruck来解决这些问题。如果你想控制正在发生的一切，并且不喜欢大多数框架的“魔力”，Ruck就是你要找的东西。</p>
<p>下面是一个用Ruck编写的示例组件:</p>
<pre class="language-javascript hljs">import { createElement as h } from "react";
import useOnClickRouteLink from "ruck/useOnClickRouteLink.mjs";
import useRoute from "ruck/useRoute.mjs";

export const css = new Set([
  "/components/ExampleComponent.css",
]);

export default function ExampleComponent({ href, children }) {
  return createElement("a", 
                { className: "NavLink__a", href, onClick: () =&gt; console.log('Hello World!') },
                children
        );
}
</pre>
<h2 id="alephjs-overview">Aleph.js概述</h2>
<p>Aleph.js是一个使用Deno构建React应用的全栈web框架。它是仅次于<a href="https://fresh.deno.dev"> Fresh </a>，作为<a href="https://yoshixmk.github.io/deno-x-ranking/">最流行的Deno-native React框架</a>。它倾向于Deno的一些特性，但也提供了更多。</p>
<p>Aleph.js的灵感来自Next.js它甚至为一些特性提供了相同的语法。Aleph.js支持服务器端呈现和静态站点生成，创建独立的API、基于文件的路由和热模块重载。为了支持独立的文件类型，如JSX和CSS，Aleph.js使用<a href="https://esbuild.github.io"> esbuild </a>而不是webpack。</p>
<p>下面是一个用Aleph.js编写的示例组件:</p>
<pre class="language-javascript hljs">import React from 'react';
import Logo from '../components/logo.tsx

export default function ExampleComponent() {
  return (
    &lt;div&gt;
      &lt;Logo /&gt;
      &lt;h1&gt;Hello World!&lt;/h1&gt;
    &lt;/div&gt;
  )
}
</pre>
<h2 id="similarities-between-ruck-and-alephjs">Ruck和Aleph.js之间的相似性</h2>
<p>Ruck和Aleph.js有很多相似之处，比如内置对<a href="https://github.com/WICG/import-maps#the-basic-idea">导入地图</a>的支持。如果不使用npm或另一个包管理器，Deno依赖于<a href="https://deno.land/manual/linking_to_external_code"> HTTP imports </a>。这意味着导入通常是这样的:</p>
<pre class="language-javascript hljs">import React from "&lt;https://esm.sh/stable/<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="0d7f686c6e794d3c35233f233d">[email protected]</a>/es2021/react.js”&gt;;
</pre>
<p>Deno建议将所有模块导入放到一个单独的<code>deps.ts</code>文件中，以便重新导出。这种方法的问题在于，进口产品仍与Node.js/webpack同类产品不兼容。</p>
<p>处理这个问题的一个更好的方法(与浏览器兼容的方法)是使用导入映射。导入映射是浏览器的一项最新功能，它让浏览器知道模块的依赖项位于何处。</p>
<p>下面是一个导入映射的示例:</p>
<pre class="language-javascript hljs">{
  "imports": {
    "react": "&lt;https://esm.sh/stable/<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="2a584f4b495e6a1b120418041a">[email protected]</a>/es2021/react.js&gt;",
  }
}
</pre>
<p>下面是一个使用导入映射的组件:</p>
<pre class="language-javascript hljs">import React from "react";

export default function ExampleComponent() {
  return &lt;div /&gt;;
}
</pre>
<p>要在Aleph.js中使用导入映射，我们需要在根目录中定义一个名为<code>import_map.json</code>的文件。在Ruck中使用导入地图也很简单；我们定义文件并在运行时将其传递给Deno，如下所示:</p>
<pre class="language-javascript hljs">deno run \\
    --allow-env \\
    --allow-net \\
    --allow-read \\
    --import-map=importMap.json \\
    scripts/ruck-serve.mjs
</pre>
<p>导入地图的问题是浏览器支持仍然很差；Safari和Firefox都不提供内置支持。好消息是Ruck使用了一个shim来为老版本的浏览器提供支持。</p>
<p>Ruck和Aleph.js之间的另一个相似之处是它们专注于服务器端呈现React组件。与客户端渲染相比，SSR可以提供增强的性能、SEO和其他好处。</p>
<p>如果React组件依赖于获取的数据，选择在服务器上这样做意味着组件可以在向客户端发送数据之前进行呈现。这意味着无需向用户显示加载状态，并且性能通常会更好。</p>
<p>Ruck在组件级支持服务器上的数据获取，而其他框架通常只在页面级支持。Aleph.js允许您通过在页面组件文件中定义一个<a href="https://alephjs.vercel.app/docs/basic-features/ssr-and-ssg"> SSR函数</a>来实现这一点。Aleph.js还支持在组件中使用一个特殊的钩子<code>useDeno</code>。</p>
<p>下面的例子展示了在Aleph.js中使用<code>useDeno</code>在服务器端获取数据:</p>
<pre class="language-javascript hljs">import React from 'react'
import { useDeno, useRouter } from 'aleph'

export default function Post() {
  const { params } = useRouter()
  const post = useDeno(async () =&gt; {
    return await (await fetch(`https://.../post/${params.id}`)).json()
  })

  return (
    &lt;h1&gt;{post.title}&lt;/h1&gt;
  )
}
</pre>
<p>当使用CSS设计React应用时，Ruck和Aleph.js都支持组件级CSS导入。这允许在浏览器请求时发送CSS，比如在组件呈现时。</p>
<p>Ruck通过一个名为<code>css</code>的导出组件变量来实现这一点。你可以用Aleph.js 以多种方式在<a href="https://alephjs.vercel.app/docs/basic-features/built-in-css-support">中实现相同的行为，但是推荐的方法是使用</a><a href="https://github.com/css-modules/css-modules"> CSS模块</a>。</p>
<p>下面的例子展示了Ruck中<code>css</code>函数的用法:</p>
<pre class="language-javascript hljs">import React from 'react'
import Heading, { css as cssHeading } from "./Heading.mjs";
import Para, { CSS as CSS paragraph } from "./Para.mjs";

export const css = new Set([
  ...cssHeading,
  ...cssParagraph,
  "/components/ExampleComponent.css",
]);

export default function ExampleComponent() {
   ...
}
</pre>
<p>这里有一个例子演示了Aleph.js中的<code>css</code>模块的使用:</p>
<pre class="language-javascript hljs">import React from 'react'
import styles from './exampleComponent.module.css'

export default function ExampleComponent() {
  return (
    &lt;&gt;
      &lt;h1 className={styles.title}&gt;Hi :)&lt;/h1&gt;
    &lt;/&gt;
  )
}
</pre>
<p>作为服务器端呈现应用程序的一个好处是在呈现生命周期中可以访问HTTP请求。如果您需要访问标头或更改响应，这可能会很有帮助。</p>
<p>使用Ruck，HTTP响应在React上下文中可用，<code>TransferContext</code>。在Aleph.js中我们可以使用<code>SSR</code>函数。</p>
<p>下面是一个在Ruck中修改HTTP响应的例子:</p>
<pre class="language-javascript hljs">import React from 'react';
import TransferContext from "ruck/TransferContext.mjs";

export default function PageError({ errorStatusCode, title, description }) {
  const ruckTransfer = useContext(TransferContext);

  if (ruckTransfer) ruckTransfer.responseInit.status = errorStatusCode;

  ...
}
</pre>
<p>下面是一个在Aleph.js中修改HTTP响应的例子:</p>
<pre class="language-javascript hljs">import React from 'react';
import { useDeno } from 'aleph';

export default function ExampleComponent() {
  const isLoggedIn = useDeno(req =&gt; {
    return req.headers.get('Auth') === 'XXX'
  }, { revalidate: true })

  return (
    &lt;p&gt;isLoggedIn: {isLoggedIn}&lt;/p&gt;
  )
}
</pre>
<h2 id="differences-between-ruck-and-alephjs">Ruck和Aleph.js的区别</h2>
<p>Ruck和Aleph.js框架之间有显著的差异，特别是在受欢迎程度和开发人员体验方面。因为Ruck是新的，它缺乏像Aleph.js这样的成熟框架所拥有的社区支持。</p><div class="code-block code-block-54">
<hr/>
<h3>更多来自LogRocket的精彩文章:</h3>

<hr/></div>
<p>Aleph.js有4.7k颗GitHub星，而Ruck有94颗。当然，GitHub star count并不总是框架功能的最佳衡量标准，但它能让您很好地理解开发人员的意图。</p>
<p>Ruck更喜欢配置而不是惯例。它迎合了那些喜欢对他们的应用程序如何运行进行高度控制的开发人员。例如，使用Ruck，您必须完全自己定义web应用程序路由器如何工作，而Aleph.js会为您处理大部分工作。例如，你可以在<a href="https://github.com/jaydenseric/ruck#examples"> Ruck库的自述文件</a>中看到路由器的例子。</p>
<p>Aleph.js可以零配置运行，并提供项目模板帮助开发人员入门。您可以选择加入基于配置的功能。使用Ruck，您必须花时间自己设置应用程序的基础。</p>
<p>如果您的web应用程序拥有构建时所需的所有数据，静态网站是理想的。这可以简化部署，因为不需要运行Deno服务器。将HTML、CSS和JavaScript的构建文件夹放置到一个部署目标，如GitHub Pages或Cloudflare。</p>
<p><a href="https://alephjs.vercel.app/docs/basic-features/ssr-and-ssg"> Aleph.js支持静态站点生成</a>，这对于这些情况很有帮助，而Ruck不支持。像Next.js中的<code>getStaticPaths</code>一样，您可以在组件文件内的<code>ssr</code>函数中定义路径的键，以指定该路由可以处理的路径:</p>
<pre class="language-javascript hljs">import type { SSROptions } from 'aleph/types';

export const ssr: SSROptions = {
  paths: async () =&gt; {
    const posts = await (await fetch('https://.../api/posts')).json()
    return posts.map(({ id }) =&gt; `/post/${id}`)
  }
}
</pre>
<p>接下来，运行<code>aleph build</code>；就这么简单！</p>
<h2 id="final-thoughts">最后的想法</h2>
<p>随着Deno越来越受欢迎，Ruck和Aleph.js都应该被视为在Deno中构建react应用程序的可行选项。这些基于Deno的React web框架迎合了两组不同的开发人员。由于Ruck是一个新人，它没有Aleph.js那样的水平，但它提供了更多的控制。</p>
<p>Aleph.js提供了很好的开发者体验，不需要任何配置，而且有很多强大的特性。这些最小的框架提供了许多内置的现代浏览器功能，这可以导致最小和精简的技术堆栈。这与当今前端生态系统的复杂性形成了鲜明对比。</p>
<p>Deno的大量内置特性减少了第三方工具的工作量。React框架可以专注于开发创新和有趣的新功能，而开发人员可以放心地知道他们为自己的web应用程序技术堆栈做出了一个伟大的选择。</p><div class="code-block code-block-17">
<div class="blog-plug inline-plug react-plug" vwo-el-id="26283398190">
<h2 vwo-el-id="41600691720"><a href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener"> LogRocket </a>:全面了解您的生产React应用</h2><p>调试React应用程序可能很困难，尤其是当用户遇到难以重现的问题时。如果您对监视和跟踪Redux状态、自动显示JavaScript错误以及跟踪缓慢的网络请求和组件加载时间感兴趣，</p><a href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" vwo-el-id="19356441070">try LogRocket</a><p>. </p><a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="19356441380">
<img class="first-react-image alignnone size-full wp-image-46 jetpack-lazy-image jetpack-lazy-image--handled" src="../Images/f300c244a1a1cf916df8b4cb02bec6c6.png" vwo-el-id="18272717540" data-lazy-loaded="1" data-original-src="https://files.readme.io/27c94e7-Image_2017-06-05_at_9.46.04_PM.png"/>
</a>
<a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="19356441690">
<img class="second-react-image alignnone size-full wp-image-46 jetpack-lazy-image jetpack-lazy-image--handled" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" vwo-el-id="30720362350" data-lazy-loaded="1" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/>
</a>
<p vwo-el-id="28675660440" class="">LogRocket 结合了会话回放、产品分析和错误跟踪，使软件团队能够创建理想的web和移动产品体验。这对你来说意味着什么？</p>
<p>LogRocket不是猜测错误发生的原因，也不是要求用户提供截图和日志转储，而是让您回放问题，就像它们发生在您自己的浏览器中一样，以快速了解哪里出错了。</p>
<p>不再有嘈杂的警报。智能错误跟踪允许您对问题进行分类，然后从中学习。获得有影响的用户问题的通知，而不是误报。警报越少，有用的信号越多。</p>
<p vwo-el-id="28675660750">LogRocket Redux中间件包为您的用户会话增加了一层额外的可见性。LogRocket记录Redux存储中的所有操作和状态。</p>
<p vwo-el-id="28675661060">现代化您调试React应用的方式— <a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="40093418840">开始免费监控</a>。</p>
</div></div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
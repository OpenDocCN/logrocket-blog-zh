<html>
<head>
<title>Using SQLite with React Native  - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>使用 SQLite 和 React Native - LogRocket 博客</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/using-sqlite-with-react-native/#0001-01-01">https://blog.logrocket.com/using-sqlite-with-react-native/#0001-01-01</a></blockquote><div><article class="article-post">
<p>开发人员使用 C 语言库 SQLite 作为移动应用程序中的数据存储非常常见。SQLite 对于离线应用程序特别有用，许多平台都包括对 SQLite 的现成支持，这使得安装非常简单。</p>
<p>在本文中，我们将在 React 本机应用程序中使用 SQLite 来建立一个简单的待办事项列表应用程序，它将向我们展示所有 CRUD 操作是如何工作的。考虑到 TypeScript 在代码质量和可维护性方面的优势，我们也将使用它。</p>
<h3>先决条件:</h3>
<ul>
<li>对 React 和 React Native 有基本的了解</li>
<li>熟悉打字稿</li>
</ul>
<h2 id="gettingstarted">入门指南</h2>
<p>我们将创建一个待办事项列表应用程序，包括以下内容:</p>
<ul>
<li><strong>完成</strong>按钮:清除已完成的项目</li>
<li><strong>添加待办事项</strong>按钮:添加新项目</li>
<li>两个<code>useState</code>调用:一个用于保存待办事项列表，一个用于跟踪新的待办事项</li>
<li>应用程序组件:处理用户事件，如添加和删除待办事项</li>
<li>哑组件:显示待办事项列表项</li>
</ul>
<p>注意，我们将使用一组功能组件和几个新的 hook APIs 来实现状态管理。</p>
<h3>设置 React 本机和类型脚本</h3>
<p>我们将从使用 TypeScript 创建一个 React 本机应用程序开始:</p>
<pre>npx react-native init MyApp --template react-native-template-typescript</pre>
<p>您可以<a href="https://github.com/dilantha111/example-react-native-sqlite/tree/start">克隆 React 应用程序</a>,并在通读本文时继续工作。</p>
<p>您将看到存储库中有两个分支，<code>start</code>和<code>main</code>。我们将从<code>start</code>分公司开始。</p>
<h3>SQLite 简介</h3>
<p>让我们将 SQLite 引入我们的应用程序。为了连接 SQLite，我们将使用<code><a href="https://www.npmjs.com/package/react-native-sqlite-storage">react-native-sqlite-storage</a></code>库。</p>
<p>要安装 SQLite，请在终端中运行以下代码:</p>
<pre>npm install --save react-native-sqlite-storage</pre>
<h2 id="installreactnativepackages">安装 React 本地包</h2>
<h3>ios</h3>
<p>如果您使用的是 iOS，运行下面的命令来安装必要的 React 原生包:</p>
<pre>cd ios &amp;&amp; pod install &amp;&amp; cd ..</pre>
<p>如果您运行的是 React Native 0.59 或更低版本，您有两种选择来安装 React Native 包，这取决于您是否使用 CocoaPods。</p>
<h4>有椰子的:</h4>
<p>如果您正在运行 CocoaPods，请将下面的代码添加到您的 podfile 中:</p>
<pre>pod 'React', :path =&gt; '../node_modules/react-native'
pod 'react-native-sqlite-storage', :path =&gt; '../node_modules/react-native-sqlite-storage'
</pre>
<p>运行<code>pod install</code>或<code>pod update</code>。</p>
<h4>没有椰子</h4>
<p>如果你没有运行 CocoaPods，你必须使用<code>react-native link</code>。如果您遇到任何错误，您必须从 Xcode 打开项目并手动添加依赖项。更多详情，请参考<a href="https://www.npmjs.com/package/react-native-sqlite-storage">库文档</a>。</p>
<h3>机器人</h3>
<p>如果您在 React Native .60 或更高版本中使用设备的 SQLite，您不必采取任何额外的步骤。</p>
<p>但是，如果您使用的是与<code>react-native-sqlite-storage</code>库捆绑在一起的 SQLite，您可以将下面的代码添加到您的<code>react-native.config.js</code>文件中:</p>
<pre>module.exports = {
  ...,
  dependencies: {
    ...,
    "react-native-sqlite-storage": {
      platforms: {
        android: {
          sourceDir:
            "../node_modules/react-native-sqlite-storage/platforms/android-native",
          packageImportPath: "import io.liteglue.SQLitePluginPackage;",
          packageInstance: "new SQLitePluginPackage()"
        }
      }
    }
    ...
  }
  ...
};
</pre>
<p>如果你运行的是旧版本的 React Native，你必须手动更新<code>Gradle</code>文件。有关完整配置，请参考<a href="https://www.npmjs.com/package/react-native-sqlite-storage">库文档</a>。</p>
<h2 id="implementadatastoreservice">实施数据存储服务</h2>
<p>现在，我们已经准备好实现数据存储服务。我们将引入一个名为<code>db-service.ts</code>的新<code>.ts</code>文件，我们可以在其中添加所有的<code>db</code>操作。首先，让我们创建一个方法来获得一个<code>db</code>连接。</p>
<p>由于我们使用的是 TypeScript，我们可以安装<code>@types/react-native-sqlite-storage</code>来使用包含的类型。如果你坚持使用 JavaScript，你可以不安装这个库。</p>
<p>使用以下代码添加<code>db</code>连接方法:</p>
<pre>import {openDatabase} from 'react-native-sqlite-storage';

export const getDBConnection = async () =&gt; {
  return openDatabase({name: 'todo-data.db', location: 'default'});
};
</pre>
<p>如果在我们启动应用程序时还没有表，我们需要创建一个。运行以下代码添加另一个方法:</p>
<pre>export const createTable = async (db: SQLiteDatabase) =&gt; {
  // create table if not exists
  const query = `CREATE TABLE IF NOT EXISTS ${tableName}(
        value TEXT NOT NULL
    );`;

  await db.executeSql(query);
};
</pre>
<p>因为我们在库中使用基于 promise 的 API，所以将下面的代码添加到我们的<code>db-service.ts</code>文件中很重要:</p>
<pre>enablePromise(true);
</pre>
<p>接下来，我们将添加保存、删除和获取待办事项的方法。添加这些方法后，我们的<code>db</code>服务文件将看起来像下面的代码块:</p>
<pre>import { enablePromise, openDatabase, SQLiteDatabase } from 'react-native-sqlite-storage';
import { ToDoItem } from '../models';

const tableName = 'todoData';

enablePromise(true);

export const getDBConnection = async () =&gt; {
  return openDatabase({ name: 'todo-data.db', location: 'default' });
};

export const createTable = async (db: SQLiteDatabase) =&gt; {
  // create table if not exists
  const query = `CREATE TABLE IF NOT EXISTS ${tableName}(
        value TEXT NOT NULL
    );`;

  await db.executeSql(query);
};

export const getTodoItems = async (db: SQLiteDatabase): Promise&lt;ToDoItem[]&gt; =&gt; {
  try {
    const todoItems: ToDoItem[] = [];
    const results = await db.executeSql(`SELECT rowid as id,value FROM ${tableName}`);
    results.forEach(result =&gt; {
      for (let index = 0; index &lt; result.rows.length; index++) {
        todoItems.push(result.rows.item(index))
      }
    });
    return todoItems;
  } catch (error) {
    console.error(error);
    throw Error('Failed to get todoItems !!!');
  }
};

export const saveTodoItems = async (db: SQLiteDatabase, todoItems: ToDoItem[]) =&gt; {
  const insertQuery =
    `INSERT OR REPLACE INTO ${tableName}(rowid, value) values` +
    todoItems.map(i =&gt; `(${i.id}, '${i.value}')`).join(',');

  return db.executeSql(insertQuery);
};

export const deleteTodoItem = async (db: SQLiteDatabase, id: number) =&gt; {
  const deleteQuery = `DELETE from ${tableName} where rowid = ${id}`;
  await db.executeSql(deleteQuery);
};

export const deleteTable = async (db: SQLiteDatabase) =&gt; {
  const query = `drop table ${tableName}`;

  await db.executeSql(query);
};
</pre>
<p>我们添加了一个<code>deleteTable</code>方法，这在我们开发应用程序时会很有用。稍后，我们将为用户添加一个使用<code>deleteTable</code>方法清除所有数据的特性。</p>
<p>我们可以使用 SQLite 自带的<code>rowid</code>作为主键。我们已经更新了待办事项，使其具有 ID 和值，而不是简单的字符串，这样我们就可以轻松地删除项目。</p>
<p>接下来，我们将为我们的<code>ToDoItem</code>类型添加一个模型。将以下代码添加到名为<code>index.ts</code>的文件中，该文件位于的另一个名为<code>models</code>的文件夹中:</p>
<pre>export type ToDoItem = {
  id: number;
  value: string;
};
</pre>
<h2 id="usingthedbservice">使用<code>db</code>服务</h2>
<p>我们必须在<code>App.tsx</code>使用我们的<code>db</code>服务。遵循以下四个步骤:</p>
<p>1.)更新<code>ToDoItem</code>组件和<code>App</code>组件以使用新的<code>ToDoItem</code>类型<br/> 2。)从 SQLite <br/> 3 加载数据。)保存数据到<code>db</code> <br/> 4。)更新<code>db</code>中已删除的项目</p>
<p>首先，让我们完成对<code>db</code>的设置，然后我们来看看<code>App.tsx</code>和<code>ToDoItem.tsx</code>文件的最终结果。</p>
<h3>加载数据</h3>
<p>为了在我们的应用程序中加载数据，我们将使用<code>useEffect</code>和<code>useCallback</code>钩子:</p>
<pre>const loadDataCallback = useCallback(async () =&gt; {
    try {
      const initTodos = [{ id: 0, value: 'go to shop' }, { id: 1, value: 'eat at least a one healthy foods' }, { id: 2, value: 'Do some exercises' }];
      const db = await getDBConnection();
      await createTable(db);
      const storedTodoItems = await getTodoItems(db);
      if (storedTodoItems.length) {
        setTodos(storedTodoItems);
      } else {
        await saveTodoItems(db, initTodos);
        setTodos(initTodos);
      }
    } catch (error) {
      console.error(error);
    }
  }, []);

  useEffect(() =&gt; {
    loadDataCallback();
  }, [loadDataCallback]);
</pre>
<p>在上面的代码片段中，我们从<code>db</code>中读取数据。如果我们存储了任何待办事项，我们就用这些来初始化应用程序。如果没有，我们将把初始值保存到<code>db</code>中，并使用该数据初始化应用程序。</p>
<h3>添加项目</h3>
<p>若要添加待办事项，请运行以下代码:</p>
<pre>const addTodo = async () =&gt; {
    if (!newTodo.trim()) return;
    try {
      const newTodos = [...todos, {
        id: todos.reduce((acc, cur) =&gt; {
          if (cur.id &gt; acc.id) return cur;
          return acc;
        }).id + 1, value: newTodo
      }];
      setTodos(newTodos);
      const db = await getDBConnection();
      await saveTodoItems(db, newTodos);
      setNewTodo('');
    } catch (error) {
      console.error(error);
    }
  };
</pre>
<h3>删除项目</h3>
<p>最后，运行下面的代码删除一个待办事项:</p>
<pre>const deleteItem = async (id: number) =&gt; {
    try {
      const db = await getDBConnection();
      await deleteTodoItem(db, id);
      todos.splice(id, 1);
      setTodos(todos.slice(0));
    } catch (error) {
      console.error(error);
    }
  };
</pre>
<p>我们最终的<code>App.tsx</code>文件应该看起来像下面的代码:</p>
<pre>/**
 * Sample React Native App
 * https://github.com/facebook/react-native
 *
 * Generated with the TypeScript template
 * https://github.com/react-native-community/react-native-template-typescript
 *
 * @format
 */
import React, { useCallback, useEffect, useState } from 'react';
import {
  Button,
  SafeAreaView,
  ScrollView,
  StatusBar,
  StyleSheet,
  Text,
  TextInput,
  useColorScheme,
  View,
} from 'react-native';
import { ToDoItemComponent } from './components/ToDoItem';
import { ToDoItem } from './models';
import { getDBConnection, getTodoItems, saveTodoItems, createTable, clearTable, deleteTodoItem } from './services/db-service';
const App = () =&gt; {
  const isDarkMode = useColorScheme() === 'dark';
  const [todos, setTodos] = useState&lt;ToDoItem[]&gt;([]);
  const [newTodo, setNewTodo] = useState('');
  const loadDataCallback = useCallback(async () =&gt; {
    try {
      const initTodos = [{ id: 0, value: 'go to shop' }, { id: 1, value: 'eat at least a one healthy foods' }, { id: 2, value: 'Do some exercises' }];
      const db = await getDBConnection();
      await createTable(db);
      const storedTodoItems = await getTodoItems(db);
      if (storedTodoItems.length) {
        setTodos(storedTodoItems);
      } else {
        await saveTodoItems(db, initTodos);
        setTodos(initTodos);
      }
    } catch (error) {
      console.error(error);
    }
  }, []);
  useEffect(() =&gt; {
    loadDataCallback();
  }, [loadDataCallback]);
  const addTodo = async () =&gt; {
    if (!newTodo.trim()) return;
    try {
      const newTodos = [...todos, {
        id: todos.length ? todos.reduce((acc, cur) =&gt; {
          if (cur.id &gt; acc.id) return cur;
          return acc;
        }).id + 1 : 0, value: newTodo
      }];
      setTodos(newTodos);
      const db = await getDBConnection();
      await saveTodoItems(db, newTodos);
      setNewTodo('');
    } catch (error) {
      console.error(error);
    }
  };
  const deleteItem = async (id: number) =&gt; {
    try {
      const db = await getDBConnection();
      await deleteTodoItem(db, id);
      todos.splice(id, 1);
      setTodos(todos.slice(0));
    } catch (error) {
      console.error(error);
    }
  };
  return (
    &lt;SafeAreaView&gt;
      &lt;StatusBar barStyle={isDarkMode ? 'light-content' : 'dark-content'} /&gt;
      &lt;ScrollView
        contentInsetAdjustmentBehavior="automatic"&gt;
        &lt;View style={[styles.appTitleView]}&gt;
          &lt;Text style={styles.appTitleText}&gt; ToDo Application &lt;/Text&gt;
        &lt;/View&gt;
        &lt;View&gt;
          {todos.map((todo) =&gt; (
            &lt;ToDoItemComponent key={todo.id} todo={todo} deleteItem={deleteItem} /&gt;
          ))}
        &lt;/View&gt;
        &lt;View style={styles.textInputContainer}&gt;
          &lt;TextInput style={styles.textInput} value={newTodo} onChangeText={text =&gt; setNewTodo(text)} /&gt;
          &lt;Button
            onPress={addTodo}
            title="Add ToDo"
            color="#841584"
            accessibilityLabel="add todo item"
          /&gt;
        &lt;/View&gt;
      &lt;/ScrollView&gt;
    &lt;/SafeAreaView&gt;
  );
};
const styles = StyleSheet.create({
  appTitleView: {
    marginTop: 20,
    justifyContent: 'center',
    flexDirection: 'row',
  },
  appTitleText: {
    fontSize: 24,
    fontWeight: '800'
  },
  textInputContainer: {
    marginTop: 30,
    marginLeft: 20,
    marginRight: 20,
    borderRadius: 10,
    borderColor: 'black',
    borderWidth: 1,
    justifyContent: 'flex-end'
  },
  textInput: {
    borderWidth: 1,
    borderRadius: 5,
    height: 30,
    margin: 10,
    backgroundColor: 'pink'
  },
});
export default App;
</pre>
<p>最后，我们最终的<code>ToDoItem.tsx</code>文件应该看起来像下面的代码块:</p>
<pre>import React from 'react';
import {
  Button,
  StyleSheet,
  Text,
  View,
} from 'react-native';
import { ToDoItem } from '../models';
export const ToDoItemComponent: React.FC&lt;{
  todo: ToDoItem;
  deleteItem: Function;
}&gt; = ({ todo: {id, value}, deleteItem }) =&gt; {
  return (
    &lt;View style={styles.todoContainer}&gt;
      &lt;View style={styles.todoTextContainer}&gt;
        &lt;Text
          style={styles.sectionTitle}&gt;
          {value}
        &lt;/Text&gt;
      &lt;/View&gt;
      &lt;Button
        onPress={() =&gt; deleteItem(id)}
        title="done"
        color="#841584"
        accessibilityLabel="add todo item"
      /&gt;
    &lt;/View&gt;
  );
};
const styles = StyleSheet.create({
  todoContainer: {
    marginTop: 10,
    paddingHorizontal: 24,
    backgroundColor: 'deepskyblue',
    marginLeft: 20,
    marginRight: 20,
    borderRadius: 10,
    borderColor: 'black',
    borderWidth: 1,
  },
  todoTextContainer: {
    justifyContent: 'center',
    flexDirection: 'row',
  },
  sectionTitle: {
    fontSize: 20,
    fontWeight: '400',
  }
});
</pre>
<p>你有它！我们完成的 React 本机待办事项应用程序应该如下图所示:</p>
<p><img data-attachment-id="55059" data-permalink="https://blog.logrocket.com/using-sqlite-with-react-native/react-native-sqlite-final-todo-application/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2021/06/react-native-sqlite-final-todo-application.png" data-orig-size="730,1464" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="react-native-sqlite-final-todo-application" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2021/06/react-native-sqlite-final-todo-application-150x300.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2021/06/react-native-sqlite-final-todo-application-511x1024.png" decoding="async" class="aligncenter wp-image-55059 size-full jetpack-lazy-image" src="../Images/a226bb26dce46eb723f677a669546068.png" alt="React Native Sqlite Final Todo Application" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2021/06/react-native-sqlite-final-todo-application.png 730w, https://blog.logrocket.com/wp-content/uploads/2021/06/react-native-sqlite-final-todo-application-150x300.png 150w, https://blog.logrocket.com/wp-content/uploads/2021/06/react-native-sqlite-final-todo-application-511x1024.png 511w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2021/06/react-native-sqlite-final-todo-application.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2021/06/react-native-sqlite-final-todo-application.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="55059" data-permalink="https://blog.logrocket.com/using-sqlite-with-react-native/react-native-sqlite-final-todo-application/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2021/06/react-native-sqlite-final-todo-application.png" data-orig-size="730,1464" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="react-native-sqlite-final-todo-application" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2021/06/react-native-sqlite-final-todo-application-150x300.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2021/06/react-native-sqlite-final-todo-application-511x1024.png" decoding="async" loading="lazy" class="aligncenter wp-image-55059 size-full" src="../Images/a226bb26dce46eb723f677a669546068.png" alt="React Native Sqlite Final Todo Application" srcset="https://blog.logrocket.com/wp-content/uploads/2021/06/react-native-sqlite-final-todo-application.png 730w, https://blog.logrocket.com/wp-content/uploads/2021/06/react-native-sqlite-final-todo-application-150x300.png 150w, https://blog.logrocket.com/wp-content/uploads/2021/06/react-native-sqlite-final-todo-application-511x1024.png 511w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2021/06/react-native-sqlite-final-todo-application.png"/></noscript>
<h2 id="conclusion">结论</h2>
<p>在本教程中，我们学习了如何将 SQLite 数据库与 React 本机应用程序连接起来，然后使用 TypeScript 创建了我们自己的应用程序。</p>
<p>我们使用了连接器库<code>react-native-sqlite-storage</code>，完成了 CRUD 操作。然后，我们将这些操作与 React 状态更新结合起来，并考虑了简单状态管理和持久化数据之间的差异。</p>
<p>我希望你喜欢这篇文章，不要忘记评论任何想法和改进。编码快乐！</p><div class="code-block code-block-18">
<div class="blog-plug inline-plug react-native-plug"><h2><a href="https://lp.logrocket.com/blg/react-native-signup"> LogRocket </a>:即时重现 React 原生应用中的问题。</h2><a class="signup" href="https://lp.logrocket.com/blg/react-native-signup" target="_blank" rel="noopener noreferrer"><img class="alignnone size-full wp-image-46 jetpack-lazy-image" src="../Images/110055665562c1e02069b3698e6cc671.png" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2021/10/react-native-plug_v2-2.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2021/10/react-native-plug_v2-2.png"/><noscript><img data-lazy-fallback="1" class="alignnone size-full wp-image-46" src="../Images/110055665562c1e02069b3698e6cc671.png" data-original-src="https://blog.logrocket.com/wp-content/uploads/2021/10/react-native-plug_v2-2.png"/></noscript></a><p><a href="https://lp.logrocket.com/blg/react-native-signup" target="_blank" rel="noopener noreferrer"> LogRocket </a>是一款 React 原生监控解决方案，可帮助您即时重现问题、确定 bug 的优先级并了解 React 原生应用的性能。</p><p>LogRocket 还可以向你展示用户是如何与你的应用程序互动的，从而帮助你提高转化率和产品使用率。LogRocket 的产品分析功能揭示了用户不完成特定流程或不采用新功能的原因。</p><p>开始主动监控您的 React 原生应用— <a class="signup" href="https://lp.logrocket.com/blg/react-native-signup" target="_blank" rel="noopener noreferrer">免费试用 LogRocket】。</a></p></div>
</div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
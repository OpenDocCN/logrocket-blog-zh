<html>
<head>
<title>Understanding the exclamation mark in TypeScript - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>理解 TypeScript - LogRocket 博客中的惊叹号</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/understanding-exclamation-mark-typescript/#0001-01-01">https://blog.logrocket.com/understanding-exclamation-mark-typescript/#0001-01-01</a></blockquote><div><article class="article-post">
<p>感叹号<code>!</code>在 TypeScript 中被称为非空断言操作符。在本文中，我们将交替使用这些术语。但是这个操作符是做什么的呢？</p>
<p>在本文中，我们将了解:</p>

<h2 id="what-typescript-exclamation-mark">什么是打字稿感叹号？</h2>
<p>非空断言操作符告诉 TypeScript 编译器，作为可选类型的值不能是<code>null</code>或<code>undefined</code>。例如，如果我们定义一个变量可能是一个字符串或者是未定义的，那么<code>!</code>操作符告诉编译器忽略它未定义的可能性。</p>
<h2 id="what-exclamation-mark-does-typescript">感叹号在打字稿中的作用</h2>
<p>假设一个变量被定义为可能为空或未定义，就像这样:</p>
<pre class="language-typescript hljs">let x: string | undefined 
</pre>
<p>或者，假设函数被定义为接受可选参数，如下所示:</p>
<pre class="language-typescript hljs">function printString (str ?: string) { … }
</pre>
<p>在这些情况下，如果我们试图将该变量作为一个明确的类型来引用，那么 TypeScript 编译器会给我们一个错误消息，如下所示:</p>
<pre class="language-typescript hljs">Object is possibly 'undefined'. ts(2532)
</pre>
<p>我们可以使用非空断言操作符明确地告诉编译器这个变量有一个值，并且不是<code>null</code>或<code>undefined</code>。让我们回顾几个例子，以便更好地理解 TypeScript 中的感叹号。</p>
<h3>示例 1:对接受<code>string</code>的函数使用<code>string | null</code>类型的变量</h3>
<p>假设我们定义了一个类型为<code>string | null</code>的变量<code>word</code>。这意味着在我们的代码中，<code>word</code>既可以保存一个<code>string</code>值，也可以保存一个<code>null</code>值。</p>
<p>如果我们试图使用一个仅对<code>word</code>上的<code>string</code>类型可用的函数，TypeScript 将拒绝它，因为在我们的代码中有可能<code>word</code>持有一个<code>null</code>值类型:</p>
<pre class="language-typescript hljs">let word : string | null = null
const num = 1
if (num) {
    word = "Hello World!"    
}
console.log(word.toLowerCase()) // Error: Object is possibly 'null'.ts(2531)
</pre>
<p>使用<code>!</code>非空断言操作符，我们可以告诉 TypeScript 我们确信<code>word</code>永远不会成为<code>null</code>(或<code>undefined</code>)，因此它可以放心地对它应用字符串函数:</p>
<pre class="language-typescript hljs">let word : string | null = null
const num = 1
if (num) {
    word = "Hello World!"    
}
console.log(word!.toLowerCase())
</pre>
<p>有了这个小小的添加，编译器不再认为<code>word</code>有可能为空。</p>
<h3>示例 2:将可选参数的值赋给函数中的变量</h3>
<p>在另一个例子中，假设我们创建了一个接受可选参数<code>personName</code>的函数<code>printName</code>。</p>
<p>请注意，使用<code>?:</code>将函数参数定义为可选与将类型定义为可能未定义是一样的。例如，<code>arg?: string</code>与<code>arg: string | undefined</code>相同。</p>
<p>如果我们试图将可选参数<code>personName</code>重新分配给另一个类型为<code>string</code>的变量，将会发生以下情况:</p>
<pre class="language-typescript hljs">function printName(personName?: string) {
    const fullName: string = personName 
/** 
 * Error: Type 'string | undefined' is not assignable to type 'string'. 
 * Type 'undefined' is not assignable to type 'string'.
 */
    console.log(`The name is ${fullName}`)
}
</pre>
<p>我们可以使用<code>!</code>操作符修复上面代码片段中抛出的类型脚本错误:</p>
<pre class="language-typescript hljs">function printName(personName?: string) {
    const fullName: string = personName! 
    console.log(`The name is ${fullName}`)
}
</pre>
<p>现在，编译器知道 personName 不能为空或未定义，这使得它可以赋给类型<code>string</code>。</p>
<h3>示例 3:打印函数中可选对象参数的属性</h3>
<p>在我们的最后一个例子中，我们将定义一个类型<code>Person</code>和一个函数<code>printName</code>，该函数接受类型<code>Person</code>的可选参数。让我们看看如果我们尝试使用<code>printName</code>来打印<code>Person</code>的 name 属性会发生什么:</p>
<pre class="language-typescript hljs">interface Person {
    name: string
    age: number
}

function printName(person?: Person) {
    console.log(`The name is ${person.name}`) // Error: Object is possibly 'undefined'. ts(2532)
}
</pre>
<p>让我们使用<code>!</code>操作符来修复这个类型脚本错误:</p>
<pre class="language-typescript hljs">interface Person {
    name: string
    age: number
}

function printName(person?: Person) {
    console.log(`The name is ${person!.name}`)
}
</pre>
<p>注意，TypeScript 有一个替代方法来引用可能为空或未定义的对象上的属性和函数，称为可选链接操作符<code>?.</code>。例如，如果变量未定义或为空，<code>person?.name</code>或<code>word?.toString()</code>将返回<code>undefined</code>。</p>
<p>然而，可选的链接操作符<code>?.</code>无法解决第二个例子中的类型错误，在这个例子中，我们试图将变量类型<code>string | undefined</code>的值赋给变量类型<code>string</code>。在本文最后一节中了解更多关于<a href="#alternatives-using-typescript-exclamation-mark">可选链接的信息。</a></p>
<h2 id="popular-use-cases-typescript-exclamation-mark">打字稿感叹号的常见用例</h2>
<p>正如我们在例子中看到的，当我们希望 TypeScript 将变量作为一个实体类型时,<code>!</code>操作符非常有用。当我们确定没有这样的情况时，这可以防止我们必须处理任何空的或未定义的情况。</p>
<p>现在我们已经看到了一些例子来更好地理解 TypeScript 感叹号，让我们来看看这个操作符的一些流行用例。</p>
<h3 id="performing-lookups-on-array">在数组上执行查找</h3>
<p>假设我们有一个对象数组，我们想挑选一个具有特定属性值的对象，如下所示:</p>
<pre class="language-typescript hljs">interface Person {
    name: string
    age: number
    sex: string
}

const people: Person[] = [
  {
      name: 'Gran',
      age: 70,
      sex: 'female'
  },
  {
      name: 'Papa',
      age: 72,
      sex: 'male'
  },
  {
      name: 'Mom',
      age: 35,
      sex: 'female'
  },
  {
      name: 'Dad',
      age: 38,
      sex: 'male'
  }
]

const femalePerson = people.find(p =&gt; p.sex === 'female')
</pre>
<p>在上面的代码片段中，TypeScript 将把<code>femalePerson</code>的类型定义为<code>Person | undefined</code>,因为<code>people.find</code>可能不会产生任何结果——换句话说，它将是未定义的。</p>
<p>然而，如果<code>femalePerson</code>的类型为<code>Person | undefined</code>，我们将无法将它作为参数传递给类型为<code>Person</code>的函数。</p>
<p>当我们在这些数组上执行查找时，我们通常确信它们已经定义了值，因此我们不相信存在任何未定义的情况。我们的<code>!</code>操作符可以将我们从额外的——或不必要的——无效或未定义的案例处理中解救出来。</p>
<p>添加非空断言操作符，如下所示:</p>
<pre class="language-typescript hljs">const femalePerson = people.find(p =&gt; p.sex === 'female')!
</pre>
<p>这将使<code>femalePerson</code>具有类型<code>Person</code>。</p>
<h3 id="react-refs-event-handling">反应引用和事件处理</h3>
<p><a href="https://blog.logrocket.com/complete-guide-react-refs/" target="_blank" rel="noreferrer noopener"> React 引用用于访问</a>呈现的 HTML DOM 节点或 React 元素。使用<code>React.createRef&lt;HTMLDivElement&gt;()</code>创建引用，然后使用<code>ref</code>属性将其附加到元素。</p>
<p>为了使用 React refs，我们访问当前属性<code>ref.current</code>。在元素被渲染之前，<code>ref.current</code>可能是<code>null</code>，因此它具有以下类型:</p>
<pre class="language-typescript hljs">HTMLDivElement | null
</pre>
<p>要将一个事件附加到<code>ref.current</code>，我们首先必须处理可能的<code>null</code>值。这里有一个例子:</p>
<pre class="language-typescript hljs">import React from 'react'

const ToggleDisplay = () =&gt; {
    const displayRef = React.createRef&lt;HTMLDivElement&gt;()

    const toggleDisplay = () =&gt; {
        if (displayRef.current) {
            displayRef.current.toggleAttribute('hidden')
        }
    }

    return (
        &lt;div&gt;
            &lt;div class="display-panel" ref="displayRef"&gt;
                &lt;p&gt; some content &lt;/p&gt;
            &lt;/div&gt;
            &lt;button onClick={toggleDisplay}&gt;Toggle Content&lt;/button&gt;
        &lt;div&gt;
    )
}
</pre>
<p>在上面的代码片段中，在调用<code>toggleAttribute</code>函数之前，我们必须使用<code>if</code>语句来处理<code>displayRef.current</code>的类型检查。</p>
<p>在大多数情况下，我们确信如果按钮<code>onClick</code>事件被触发，那么我们的元素已经被渲染了。因此，没有必要进行检查。使用<code>!</code>操作符可以消除这种不必要的检查，就像这样:</p>
<pre class="language-typescript hljs">const displayRef = React.createRef&lt;HTMLDivElement&gt;()

const toggleDisplay = () =&gt; displayRef.current!.toggleAttribute('hidden')

return (
        &lt;div&gt;
        ...
</pre>
<h2 id="downside-using-exclamation-mark-typescript">在 TypeScript 中使用感叹号的缺点是</h2>
<p><code>!</code>操作符不会改变代码的运行时行为。如果您断言的值不是<code>null</code>或<code>undefined</code>实际上是<code>null</code>或<code>undefined</code>，将会出现一个错误并中断您代码的执行。</p>
<p>记住，TypeScript 和 JavaScript 的区别在于类型的断言。在 JavaScript 中，我们不需要也不使用<code>!</code>操作符，因为没有严格的类型限制。</p>
<p>JavaScript 变量可以用<code>string</code>进行实例化，并在代码执行期间更改为<code>object</code>、<code>null</code>或<code>number</code>。这就让开发人员来处理不同的情况。</p>
<p>使用<code>!</code>操作符剥夺了 TypeScript 防止运行时类型错误的“超级能力”。因此，使用<code>!</code>操作符并不是最佳实践。</p>
<h3>非空断言的单个感叹号<code>!</code></h3>
<p>TypeScript 优于 JavaScript 的地方在于它为我们的代码提供了类型安全。然而，我们有时可能希望禁用 TypeScript 的严格类型检查—例如，为了灵活性或向后兼容性。在这种情况下，我们可以使用非空断言操作符<code>!</code>。</p>
<p>虽然这是一个有用的特性，但我鼓励您探索更安全的类型断言方法。通过<a href="https://blog.logrocket.com/linting-typescript-using-eslint-and-prettier/" target="_blank" rel="noopener">将<code>typescript-eslint</code>包</a>添加到您的项目中，<a href="https://github.com/typescript-eslint/typescript-eslint/blob/main/packages/eslint-plugin/docs/rules/no-non-null-assertion.md" target="_blank" rel="noopener">应用<code>no-non-null-assertion</code> lint 规则</a>，您可以进一步阻止在您的项目中和您的团队中使用这个操作。</p>
<h2 id="alternatives-using-typescript-exclamation-mark">使用 TypeScript 感叹号的替代方法</h2>
<p>您可以使用可选的链接或类型谓词来替代非空断言。</p>
<p><a href="https://blog.logrocket.com/16-useful-typescript-javascript-shorthands-know/#optional-chaining" target="_blank" rel="noreferrer noopener">可选链接是一种打字稿速记</a>，它允许我们轻松地处理变量是否被定义的情况。当变量未定义或为空时，参考值默认为值<code>undefined</code>。下面是一个可选链接的示例:</p>
<pre class="language-typescript hljs">interface Person {
    name: string
    age: number
    sex: string
}

function printName(person?: Person): void {
    console.log('The name of this person is', person?.name)
}
</pre>
<p>在上面的例子中，如果<code>person</code>未定义，我们的打印输出如下:</p>
<pre class="language-typescript hljs">'The name of this person is undefined'</pre>
<p><a href="https://www.typescriptlang.org/docs/handbook/2/narrowing.html#using-type-predicates" target="_blank" rel="noreferrer noopener">在类型脚本</a>中使用类型谓词是通过定义一个函数来完成的，该函数执行布尔测试并以<code>arg is Type</code>的形式返回类型谓词。这里有一个例子:</p>
<pre class="language-typescript hljs">interface Person {
    name: string
    age: number
    sex: string
}

function validatePerson(person?: Person) person is Person {
    return !!person
}
</pre>
<p>使用这个类型谓词，我们可以在执行任何进一步的操作之前首先验证对象，如下所示:</p>
<pre class="language-typescript hljs">function printName(person?: Person) {
    if (!validatePerson(person)) {
        console.log('Person is invalid')
        return
    }

    console.log(`The name is ${person.name}`)
}
</pre>
<h2 id="double-exclamation-marks-typescript">打字稿中的双感叹号<code>!!</code></h2>
<p>当我们谈到感叹号<code>!</code>时，TypeScript 也使用双感叹号<code>!!</code>将非布尔类型值转换(也称为 cast)为布尔类型。这里有一个例子:</p>
<pre class="language-typescript hljs">const emptyStr = ''
const nonEmptyStr = 'test'

const emptyStrBool = !!emptyStr //false
const nonEmptyStrBool = !!nonEmptyStr //true
</pre>
<p>在上面的例子中，我们使用<code>!!</code>操作符将字符串变量转换为布尔型。但是你可能想知道，为什么这两个字符串有不同的布尔结果？答案是一个字符串(空字符串)为假，而另一个(非空字符串)为真。让我们稍微探索一下。</p>
<h3>真值和假值</h3>
<p>true/falsy 指的是值在条件语句中的求值方式，而不管它们的实际类型。</p>
<p>想想<code>if/else</code>的陈述，他们评估的是表达的真假，而不是它的实际价值。以下是一些真实/虚假的表达:</p>
<pre class="language-typescript hljs">const num1 = 12
const num2 = 26

// expression 1 - falsey
if (num1 &gt; num2) {
   ...
}

// expression 2 - truthy
if (num1) {
   ...
}
</pre>
<p>总之，当一个 falsy 表达式被转换成 Boolean 时，它的计算结果是<code>false</code>，如果它的计算结果是<code>true</code>，那么它就是 the。</p>
<p><em>注意，在 TypeScript 中(在 JavaScript 中也是如此)，空值如</em> <code>0</code> <em>、</em> <code>''</code> <em>、</em> <code>undefined</code> <em>和</em> <code>null</code> <em>都是假值，在转换为布尔值时将计算为</em> <code>false</code> <em>值。</em></p>
<h3>布尔转换的双感叹号<code>!!</code></h3>
<p>TypeScript(和 JavaScript)允许您使用双感叹号简写将非布尔值转换为布尔值。这在需要使用非布尔值结果或变量返回布尔值的 TypeScript(具有严格的类型定义)中尤其有用。</p>
<h2 id="conclusion">结论</h2>
<p>TypeScript 优于 JavaScript 的地方在于它为我们的代码提供了类型安全。然而，我们有时可能希望禁用 TypeScript 的严格类型检查—例如，为了灵活性或向后兼容性。在这种情况下，我们可以使用非空断言操作符。</p>
<p>虽然这是一个有用的特性，但我鼓励您探索更安全的类型断言方法。您可以更进一步，通过<a href="https://blog.logrocket.com/linting-typescript-using-eslint-and-prettier/" target="_blank" rel="noreferrer noopener">将</a> <code><a href="https://blog.logrocket.com/linting-typescript-using-eslint-and-prettier/" target="_blank" rel="noreferrer noopener">typescript-eslint</a></code> <a href="https://blog.logrocket.com/linting-typescript-using-eslint-and-prettier/" target="_blank" rel="noreferrer noopener">包</a>添加到您的项目中，并<a href="https://github.com/typescript-eslint/typescript-eslint/blob/main/packages/eslint-plugin/docs/rules/no-non-null-assertion.md" target="_blank" rel="noreferrer noopener">应用</a> <code><a href="https://github.com/typescript-eslint/typescript-eslint/blob/main/packages/eslint-plugin/docs/rules/no-non-null-assertion.md" target="_blank" rel="noreferrer noopener">no-non-null-assertion</a></code> <a href="https://github.com/typescript-eslint/typescript-eslint/blob/main/packages/eslint-plugin/docs/rules/no-non-null-assertion.md" target="_blank" rel="noreferrer noopener"> lint 规则</a>，来防止在您的项目和团队中使用该操作。</p><div class="code-block code-block-21">
<div class="blog-plug inline-plug typescript-plug"><h2><a class="signup" href="https://lp.logrocket.com/blg/typescript-signup" target="_blank" rel="noopener noreferrer"> LogRocket </a>:全面了解您的网络和移动应用</h2>
<a href="https://lp.logrocket.com/blg/typescript-signup" class="signup" target="_blank" rel="noopener noreferrer"><img class="alignnone size-full wp-image-46 jetpack-lazy-image" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/><noscript><img data-lazy-fallback="1" class="alignnone size-full wp-image-46" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/></noscript></a>
<p>LogRocket 是一个前端应用程序监控解决方案，可以让您回放问题，就像问题发生在您自己的浏览器中一样。LogRocket 不需要猜测错误发生的原因，也不需要向用户询问截图和日志转储，而是让您重放会话以快速了解哪里出错了。它可以与任何应用程序完美配合，不管是什么框架，并且有插件可以记录来自 Redux、Vuex 和@ngrx/store 的额外上下文。</p>
<p>除了记录 Redux 操作和状态，LogRocket 还记录控制台日志、JavaScript 错误、堆栈跟踪、带有头+正文的网络请求/响应、浏览器元数据和自定义日志。它还使用 DOM 来记录页面上的 HTML 和 CSS，甚至为最复杂的单页面和移动应用程序重新创建像素级完美视频。</p>
<a class="signup" href="https://lp.logrocket.com/blg/typescript-signup" target="_blank" rel="noopener noreferrer">Try it for free</a><p>.</p></div>
</div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
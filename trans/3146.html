<html>
<head>
<title>Creating split OTP input fields in React Native - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>在 React Native - LogRocket 博客中创建分割 OTP 输入字段</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/creating-split-otp-input-fields-react-native/#0001-01-01">https://blog.logrocket.com/creating-split-otp-input-fields-react-native/#0001-01-01</a></blockquote><div><article class="article-post">
<p>作为 React 本地开发人员，我们经常需要创建要求用户输入一次性密码(OTP)的身份验证流。</p>
<p>当我们考虑创建这个特性所带来的<code>TextInput</code>的处理时，OTP 可能是一项令人生畏的任务。经典的<code>TextInput</code>显示将用户输入的文本输出到一个框中，尽管被星号隐藏。但是，如果我们想要分割显示，为每个 OTP 数字创建一个框，该怎么办呢？我们完全可以做到！</p>
<p>在本文中，我们将学习如何在 React Native 中创建分割 OTP 输入字段，而不使用外部包。</p>

<h2 id="setting-up-environment">设置环境</h2>
<p>为了设置开发环境，我们将使用<a href="https://docs.expo.dev/workflow/expo-cli/" target="_blank" rel="noopener"> Expo CLI </a>。要在 Expo 中创建新的 React 本地项目，请运行以下命令:</p>
<pre class="language-bash hljs">expo init splitOTP
</pre>
<p>选择<strong>空白</strong>选项，这将引导您的项目。接下来，运行<code>expo start</code>来启动 Metro 服务器。你可以在 Android 模拟器或 iOS 模拟器上打开应用程序。本文中的截图将是 Android 的，但在 iOS 上应该几乎相同。</p>
<p>现在，我们的模拟器应该是这样的:</p>
<p><img data-attachment-id="123817" data-permalink="https://blog.logrocket.com/creating-split-otp-input-fields-react-native/attachment/opening-screen-android-4/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/07/opening-screen-android-3.png" data-orig-size="398,840" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="opening-screen-android" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/07/opening-screen-android-3-142x300.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/07/opening-screen-android-3.png" decoding="async" class="aligncenter size-full wp-image-123817 jetpack-lazy-image" src="../Images/0879ed06a13ce3faae6c65db4700bf36.png" alt="Opening Screen On Android" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2022/07/opening-screen-android-3.png 398w, https://blog.logrocket.com/wp-content/uploads/2022/07/opening-screen-android-3-142x300.png 142w" data-lazy-sizes="(max-width: 398px) 100vw, 398px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2022/07/opening-screen-android-3.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/07/opening-screen-android-3.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="123817" data-permalink="https://blog.logrocket.com/creating-split-otp-input-fields-react-native/attachment/opening-screen-android-4/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/07/opening-screen-android-3.png" data-orig-size="398,840" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="opening-screen-android" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/07/opening-screen-android-3-142x300.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/07/opening-screen-android-3.png" decoding="async" loading="lazy" class="aligncenter size-full wp-image-123817" src="../Images/0879ed06a13ce3faae6c65db4700bf36.png" alt="Opening Screen On Android" srcset="https://blog.logrocket.com/wp-content/uploads/2022/07/opening-screen-android-3.png 398w, https://blog.logrocket.com/wp-content/uploads/2022/07/opening-screen-android-3-142x300.png 142w" sizes="(max-width: 398px) 100vw, 398px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/07/opening-screen-android-3.png"/></noscript>
<p>我们将使用<code>styled-components</code>进行应用程序样式化，您可以安装:</p>
<pre class="language-bash hljs">&gt;npm i start 
</pre>
<p>或者…</p>
<pre class="language-bash hljs">yarn add styled-components
</pre>
<h2 id="implementing-split-otp-input-fields-application">在应用程序中实现分割 OTP 输入字段</h2>
<p>实现 split OTP 特性的概念是让<code>TextInput</code>成为我们的参考组件，或者换句话说，成为我们的事实来源。对于这个文本输入接收到的每个数字，我们将以框的形式呈现一个样式化的<code>View</code>。</p>
<p>之后，文本输入将被隐藏，并根据需要使用<code>useRef</code>钩子调用。我把容器<code>View</code>的<code>background-color</code>改成了更暗的颜色，这样我们的实现就更加清晰可见了。</p>
<figure id="attachment_123750" aria-describedby="caption-attachment-123750" class="wp-caption aligncenter"><img data-attachment-id="123750" data-permalink="https://blog.logrocket.com/creating-split-otp-input-fields-react-native/attachment/concept-work/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/07/concept-work.png" data-orig-size="730,722" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="concept-work" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/07/concept-work-300x297.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/07/concept-work.png" decoding="async" class="wp-image-123750 size-full jetpack-lazy-image" src="../Images/b7b4b299ec36a774386b6c8cd726ea41.png" alt="Concept Of Work For Split OTP Boxes" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2022/07/concept-work.png 730w, https://blog.logrocket.com/wp-content/uploads/2022/07/concept-work-300x297.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2022/07/concept-work.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/07/concept-work.png"/><noscript><img data-lazy-fallback="1" data-attachment-id="123750" data-permalink="https://blog.logrocket.com/creating-split-otp-input-fields-react-native/attachment/concept-work/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/07/concept-work.png" data-orig-size="730,722" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="concept-work" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/07/concept-work-300x297.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/07/concept-work.png" decoding="async" loading="lazy" class="wp-image-123750 size-full" src="../Images/b7b4b299ec36a774386b6c8cd726ea41.png" alt="Concept Of Work For Split OTP Boxes" srcset="https://blog.logrocket.com/wp-content/uploads/2022/07/concept-work.png 730w, https://blog.logrocket.com/wp-content/uploads/2022/07/concept-work-300x297.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/07/concept-work.png"/></noscript><figcaption id="caption-attachment-123750" class="wp-caption-text">Pictorial representation of our work concept.</figcaption></figure>
<p>下面的代码片段显示了我们的条目文件<code>App.js</code>，我们在其中修改了背景颜色:</p>
<pre class="language-javascript hljs">export default function App() {
 return (
   &lt;View style={styles.container}&gt;
     &lt;Text
       style={{
         color: "white",
       }}
     &gt;
       Open up App.js to start working on your app!
     &lt;/Text&gt;
     &lt;StatusBar style="auto" /&gt;
   &lt;/View&gt;
 );
}

const styles = StyleSheet.create({
 container: {
   flex: 1,
   backgroundColor: "#141414",
   alignItems: "center",
   justifyContent: "center",
 },
});
</pre>
<p><img data-attachment-id="123755" data-permalink="https://blog.logrocket.com/creating-split-otp-input-fields-react-native/attachment/opening-screen-black-background-android/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/07/opening-screen-black-background-android-e1657554382546.png" data-orig-size="398,858" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="opening-screen-black-background-android" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/07/opening-screen-black-background-android-e1657554382546-139x300.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/07/opening-screen-black-background-android-475x1024.png" decoding="async" class="aligncenter size-full wp-image-123755 jetpack-lazy-image" src="../Images/7b86935657fdb18d1c86a8fd89fd4d9a.png" alt="Opening Screen With Black Background Android" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2022/07/opening-screen-black-background-android-e1657554382546.png 398w, https://blog.logrocket.com/wp-content/uploads/2022/07/opening-screen-black-background-android-e1657554382546-139x300.png 139w" data-lazy-sizes="(max-width: 398px) 100vw, 398px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2022/07/opening-screen-black-background-android-e1657554382546.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/07/opening-screen-black-background-android-e1657554382546.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="123755" data-permalink="https://blog.logrocket.com/creating-split-otp-input-fields-react-native/attachment/opening-screen-black-background-android/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/07/opening-screen-black-background-android-e1657554382546.png" data-orig-size="398,858" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="opening-screen-black-background-android" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/07/opening-screen-black-background-android-e1657554382546-139x300.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/07/opening-screen-black-background-android-475x1024.png" decoding="async" loading="lazy" class="aligncenter size-full wp-image-123755" src="../Images/7b86935657fdb18d1c86a8fd89fd4d9a.png" alt="Opening Screen With Black Background Android" srcset="https://blog.logrocket.com/wp-content/uploads/2022/07/opening-screen-black-background-android-e1657554382546.png 398w, https://blog.logrocket.com/wp-content/uploads/2022/07/opening-screen-black-background-android-e1657554382546-139x300.png 139w" sizes="(max-width: 398px) 100vw, 398px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/07/opening-screen-black-background-android-e1657554382546.png"/></noscript>
<h3 id="rendering-textinput-component">呈现<code>TextInput</code>组件</h3>
<p>接下来，我们将创建<code>components</code>文件夹。在这个文件夹中，我们将有另一个名为<code>OTP</code>的文件夹，它将存放<code>OTPInput.js</code>和<code>Styles.js</code>文件。</p>
<p>在<code>OTPInput.js</code>文件中，我们将使用样式化的组件创建两个组件:<code>TextInputHidden</code>，稍后我们将隐藏的文本输入；和<code>OTPInputContainer</code>，住房文本输入本身。</p>
<p>下面是我们的<code>Styles.js</code>文件:</p>
<pre class="language-javascript hljs">import styled from "styled-components/native";

export const OTPInputContainer = styled.View`
 justify-content: center;
 align-items: center;
`;

export const TextInputHidden = styled.TextInput`
 width: 300px;
 border-color: #e5e5e5;
 border-width: 1px;
 border-radius: 5px;
 padding: 15px;
`;
</pre>
<p>下面是我们的<code>OTPInput.js</code>文件中的代码:</p>
<pre class="language-javascript hljs">import React from "react";
import { OTPInputContainer, TextInputHidden } from "./styles";

const OTPInput = () =&gt; {
 return (
   &lt;OTPInputContainer&gt;
     &lt;TextInputHidden /&gt;
   &lt;/OTPInputContainer&gt;
 );
};

export default OTPInput;
</pre>
<p>现在，我们将使用<code>App.js</code>中的<code>OTPInput</code>组件，这样我们可以在我们的仿真器/模拟器中呈现整个实现:</p>
<pre class="language-javascript hljs">import { StatusBar } from "expo-status-bar";
import { StyleSheet, Text, View } from "react-native";
import OTPInput from "./components/OTP/OTPInput";

export default function App() {
 return (
   &lt;View style={styles.container}&gt;
     &lt;OTPInput /&gt;
     &lt;StatusBar style="auto" /&gt;
   &lt;/View&gt;
 );
}

const styles = StyleSheet.create({
 container: {
   flex: 1,
   backgroundColor: "#141414",
   alignItems: "center",
   justifyContent: "center",
 },
});
</pre>
<p><img data-attachment-id="123819" data-permalink="https://blog.logrocket.com/creating-split-otp-input-fields-react-native/attachment/render-implementation-android-3/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/07/render-implementation-android-2.png" data-orig-size="398,838" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="render-implementation-android" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/07/render-implementation-android-2-142x300.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/07/render-implementation-android-2.png" decoding="async" class="aligncenter wp-image-123819 size-full jetpack-lazy-image" src="../Images/4beaeac52a2a6f94435ded15234c59b7.png" alt="Rendering Implementation On Android" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2022/07/render-implementation-android-2.png 398w, https://blog.logrocket.com/wp-content/uploads/2022/07/render-implementation-android-2-142x300.png 142w" data-lazy-sizes="(max-width: 398px) 100vw, 398px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2022/07/render-implementation-android-2.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/07/render-implementation-android-2.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="123819" data-permalink="https://blog.logrocket.com/creating-split-otp-input-fields-react-native/attachment/render-implementation-android-3/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/07/render-implementation-android-2.png" data-orig-size="398,838" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="render-implementation-android" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/07/render-implementation-android-2-142x300.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/07/render-implementation-android-2.png" decoding="async" loading="lazy" class="aligncenter wp-image-123819 size-full" src="../Images/4beaeac52a2a6f94435ded15234c59b7.png" alt="Rendering Implementation On Android" srcset="https://blog.logrocket.com/wp-content/uploads/2022/07/render-implementation-android-2.png 398w, https://blog.logrocket.com/wp-content/uploads/2022/07/render-implementation-android-2-142x300.png 142w" sizes="(max-width: 398px) 100vw, 398px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/07/render-implementation-android-2.png"/></noscript>
<p>我们将初始化<code>App.js</code>中的一些状态，并将它们作为道具传递给<code>OTPInput.js</code>文件。</p>
<p>第一个状态将是<code>code</code>，一个空字符串，它将存储在输入字段中输入的值。</p>
<p>第二个状态是<code>isPinReady</code>，一个布尔值，默认为<code>false</code>，当用户输入所需的预期位数时为<code>true</code>。</p>
<p>现在，我们将预期数字的最大长度声明为 4(这可以根据您的用例来声明)。</p>
<p>我们将把这些状态作为道具传递给<code>OTPInput</code>组件。接下来，我们将析构我们作为道具传递到<code>App.js</code>中的<code>OTPInput.js</code>组件的所有值。被析构的值将被传递给<code>TextInputHidden</code>。</p>
<p>接下来，我们将把<code>TextInput</code>组件的值设置为<code>code</code>状态，并将<code>onChangeText</code>设置为<code>setCode</code>。当用户输入值时,<code>onChangeText</code>将更新代码状态(之前设置为空字符串)。</p>
<p>由于我们只期望数字被输入到输入字段，我们将<code>keyboardType</code>设置为<code>number-pad</code>并将<code>maxLength</code>设置为可以输入的最大数字。在我们的例子中，也是四个。</p>
<p>为了在输入失焦时处理<code>onBlur</code>事件，我们将使用<code>useRef</code>钩子和<code>handleOnBlur</code>函数。我们将用<code>useRef</code>创建一个参考变量，并将初始值设为<code>null</code>。对于<code>handleOnBlur</code>函数，我们做一个声明供以后使用。</p>
<p>现在，在我们的<code>App.js</code>文件中，我们将设置所有状态，并将其作为道具传递给<code>OTPInput</code>组件，如下所示:</p>
<pre class="language-javascript hljs">import { useState } from "react";
import { StatusBar } from "expo-status-bar";
import { StyleSheet, Text, View } from "react-native";
import OTPInput from "./components/OTP/OTPInput";

export default function App() {
 const [otpCode, setOTPCode] = useState("");
 const [isPinReady, setIsPinReady] = useState(false);
 const maximumCodeLength = 4;
 return (
   &lt;View style={styles.container}&gt;
     &lt;OTPInput
       code={otpCode}
       setCode={setOTPCode}
       maximumLength={maximumCodeLength}
       setIsPinReady={setIsPinReady}
     /&gt;
     &lt;StatusBar style="auto" /&gt;
   &lt;/View&gt;
 );
}

const styles = StyleSheet.create({
 container: {
   flex: 1,
   backgroundColor: "#141414",
   alignItems: "center",
   justifyContent: "center",
 },
});
</pre>
<p>在<code>OTPInput.js</code>中，我们将接收传递给<code>OTPInput</code>组件的道具，并将其析构以供使用:</p>
<pre class="language-javascript hljs">import React, { useRef } from "react";
import { OTPInputContainer, TextInputHidden } from "./styles";

const OTPInput = ({ code, setCode, maximumLength, setIsPinReady }) =&gt; {
 const inputRef = useRef();

 const handleOnBlur = () =&gt; {};
 return (
   &lt;OTPInputContainer&gt;
     &lt;TextInputHidden
       value={code}
       onChangeText={setCode}
       maxLength={maximumLength}
       ref={inputRef}
       onBlur={handleOnBlur}
     /&gt;
   &lt;/OTPInputContainer&gt;
 );
};

export default OTPInput;
</pre>
<h3 id="creating-split-input-boxes-components">创建拆分输入框组件</h3>
<p>现在，我们将为分割输入框本身创建一些组件。首先，我们将创建一个名为<code>SplitOTPBoxesContainer</code>的<code>Pressable </code>组件，并给它一些样式。然后，我们将制作一个名为<code>SplitBoxes</code>的<code>View</code>组件来呈现我们的分割框，并制作一个文本组件(<code>SplitBoxText</code>)来显示文本。</p><div class="code-block code-block-54">
<hr/>
<h3>更多来自 LogRocket 的精彩文章:</h3>

<hr/></div>
<p>您可以在下面的<code>Styles.js</code>文件中看到代码:</p>
<pre class="language-javascript hljs">export const SplitOTPBoxesContainer = styled.Pressable`
 width: 80%;
 flex-direction: row;
 justify-content: space-evenly;
`;
export const SplitBoxes = styled.View`
 border-color: #e5e5e5;
 border-width: 2px;
 border-radius: 5px;
 padding: 12px;
 min-width: 50px;
`;

export const SplitBoxText = styled.Text`
 font-size: 20px;
 text-align: center;
 color: #e5e5e5;
`;
</pre>
<p>回到<code>OTPInput.js</code>，我们将把<code>SplitOTPBoxesContainer</code>放在<code>TextInputHidden</code>组件的上面。</p>
<p>在<code>SplitOTPBoxesContainer</code>中，我们将映射<code>TextInputHidden</code>组件的数字，并为每个数字呈现一个框。我们将使用<code>Array.fill()</code>方法创建一个最大长度为 4 的数组，并用<code>0</code>初始化输入字段索引。</p>
<pre class="language-javascript hljs">const boxArray = new Array(maximumLength).fill(0);
</pre>
<p>当我们将<code>boxArray</code>记录到控制台时，我们得到的结果是:</p>
<pre class="language-shell hljs">Array [
   0,
   0,
   0,
   0,
 ]
</pre>
<p>现在，我们将创建一个函数来处理数组中每个值的映射，并为每个值呈现一个框。它将从<code>Array.map</code>方法接收值和索引。</p>
<p>我们首先创建一个变量<code>emptyInput</code>，这是一个空字符串，当一个输入框为空时就会呈现出来。将使用索引从代码输入字符串中提取每个数字，如果是空的，将返回我们之前声明的<code>emptyInput</code>变量。</p>
<p>然后，<code>SplitBoxes</code>的<code>View</code>组件将与<code>SplitBoxText</code>一起返回。<code>SplitBoxText</code>的值将是数字，索引将作为键传递给<code>SplitBoxes</code>。</p>
<p>在<code>SplitOTPBoxesContainer</code>中，我们将映射通过<code>boxArray</code>并进入<code>boxDigit</code>功能来渲染分割框。这将参照<code>boxArray</code>中的数字数量来渲染方框，数字数量将是四。</p>
<p>我们将在我们的<code>OTPInput.js</code>文件中实现它:</p>
<pre class="language-javascript hljs">const OTPInput = ({ code, setCode, maximumLength, setIsPinReady }) =&gt; {
 const boxArray = new Array(maximumLength).fill(0);
 const inputRef = useRef();

 const boxDigit = (_, index) =&gt; {
   const emptyInput = "";
   const digit = code[index] || emptyInput;
   return (
     &lt;SplitBoxes key={index}&gt;
       &lt;SplitBoxText&gt;{digit}&lt;/SplitBoxText&gt;
     &lt;/SplitBoxes&gt;
   );
 };

 const handleOnBlur = () =&gt; {};
 return (
   &lt;OTPInputContainer&gt;
     &lt;SplitOTPBoxesContainer&gt;{boxArray.map(boxDigit)}&lt;/SplitOTPBoxesContainer&gt;
     &lt;TextInputHidden
       value={code}
       onChangeText={setCode}
       maxLength={maximumLength}
       ref={inputRef}
       onBlur={handleOnBlur}
     /&gt;
   &lt;/OTPInputContainer&gt;
 );
};
</pre>
<p>现在，我们可以检查我们的仿真器/模拟器中的分割框，并输入一些值！</p>
<p><img data-attachment-id="123821" data-permalink="https://blog.logrocket.com/creating-split-otp-input-fields-react-native/attachment/check-split-boxes-android-2/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/07/check-split-boxes-android-1.png" data-orig-size="398,856" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="check-split-boxes-android" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/07/check-split-boxes-android-1-139x300.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/07/check-split-boxes-android-1.png" decoding="async" class="aligncenter wp-image-123821 size-full jetpack-lazy-image" src="../Images/8604adb628edfdb63af256fd5d80c6af.png" alt="Check Split Boxes Android" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2022/07/check-split-boxes-android-1.png 398w, https://blog.logrocket.com/wp-content/uploads/2022/07/check-split-boxes-android-1-139x300.png 139w" data-lazy-sizes="(max-width: 398px) 100vw, 398px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2022/07/check-split-boxes-android-1.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/07/check-split-boxes-android-1.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="123821" data-permalink="https://blog.logrocket.com/creating-split-otp-input-fields-react-native/attachment/check-split-boxes-android-2/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/07/check-split-boxes-android-1.png" data-orig-size="398,856" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="check-split-boxes-android" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/07/check-split-boxes-android-1-139x300.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/07/check-split-boxes-android-1.png" decoding="async" loading="lazy" class="aligncenter wp-image-123821 size-full" src="../Images/8604adb628edfdb63af256fd5d80c6af.png" alt="Check Split Boxes Android" srcset="https://blog.logrocket.com/wp-content/uploads/2022/07/check-split-boxes-android-1.png 398w, https://blog.logrocket.com/wp-content/uploads/2022/07/check-split-boxes-android-1-139x300.png 139w" sizes="(max-width: 398px) 100vw, 398px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/07/check-split-boxes-android-1.png"/></noscript>
<h3 id="highlighting-current-otp-digit">突出显示当前 OTP 数字</h3>
<p>当我们按下每个输入框时，我们需要用它的背景色高亮显示当前的输入框并触发键盘。记住我们有<code>SplitOTPBoxesContainer</code>，一个可挤压的组件。我们将用函数<code>handleOnPress</code>将<code>onPress</code>道具传递给它。</p>
<p>为了实现这一点，我们将声明一个布尔状态来检查我们是否在焦点上。输入框默认为<code>false</code>。</p>
<p>在<code>handleOnPress</code>函数中，我们将创建的焦点状态设置为<code>true</code>,并使用<code>inputRef</code>来触发它聚焦。在<code>handleOnBlur</code>功能中，我们将焦点状态设置回<code>false</code>。</p>
<p>此时，我们应该能够按下<code>TextInput</code>来输入 PIN 数字，并在分割框和<code>TextInput</code>中看到它们:</p>
<pre class="language-javascript hljs"> const [isInputBoxFocused, setIsInputBoxFocused] = useState(false);

 const handleOnPress = () =&gt; {
   setIsInputBoxFocused(true);
   inputRef.current.focus();
 };

 const handleOnBlur = () =&gt; {
   setIsInputBoxFocused(false);
 };
</pre>
<p>为了完成当前框的高亮显示，我们将在我们的<code>Styles.js</code>文件中创建一个名为<code>SplitBoxesFocused</code>的新样式组件，它将基于<code>SplitBoxes</code>，修改<code>background</code>和<code>border-color</code>:</p>
<pre class="language-javascript hljs">export const SplitBoxesFocused = styled(SplitBoxes)`
 border-color: #ecdbba;
 background-color: grey;
`;
</pre>
<p>在<code>boxDigit</code>函数中，我们将建立几个变量:</p>
<ul>
<li><code>isCurrentValue</code>:检查映射的当前值是否是当前需要关注的数字或方框</li>
<li><code>isLastValue</code>:检查最后一位数字</li>
<li><code>isCodeComplete</code>:检查代码长度是否与我们之前指定的最大长度相同，将为<code>true</code></li>
<li><code>isValueFocused</code>:检查数值是否聚焦。如果这是当前或最后的值，并且代码是完整的，这将是<code>true</code>。</li>
</ul>
<p>现在，我们想在<code>SplitBoxes</code>和<code>SplitBoxesFocused</code>之间切换。我们将创建一个名为<code>StyledSplitBoxes</code>的新变量。如果文本输入和值都被聚焦，我们将返回<code>SplitBoxesFocused</code>；否则，我们将返回<code>SplitBoxes</code>。</p>
<p>接下来，我们将把<code>StyledSplitBoxes</code>替换为<code>SplitBoxes</code>。我们可以用指定的背景颜色来呈现焦点输入框。</p>
<pre class="language-javascript hljs">const boxDigit = (_, index) =&gt; {
   const emptyInput = "";
   const digit = code[index] || emptyInput;

   const isCurrentValue = index === code.length;
   const isLastValue = index === maximumLength - 1;
   const isCodeComplete = code.length === maximumLength;

   const isValueFocused = isCurrentValue || (isLastValue &amp;&amp; isCodeComplete);

   const StyledSplitBoxes =
     isInputBoxFocused &amp;&amp; isValueFocused ? SplitBoxesFocused : SplitBoxes;
   return (
     &lt;StyledSplitBoxes key={index}&gt;
       &lt;SplitBoxText&gt;{digit}&lt;/SplitBoxText&gt;
     &lt;/StyledSplitBoxes&gt;
   );
</pre>
<p><img data-attachment-id="123797" data-permalink="https://blog.logrocket.com/creating-split-otp-input-fields-react-native/attachment/highlight-current-box-android-2/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/07/highlight-current-box-android-1.png" data-orig-size="419,878" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="highlight-current-box-android" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/07/highlight-current-box-android-1-143x300.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/07/highlight-current-box-android-1.png" decoding="async" class="aligncenter size-full wp-image-123797 jetpack-lazy-image" src="../Images/5ee85d2ddb30d8e4b7b326ae68712c81.png" alt="Check Split Boxes On Android" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2022/07/highlight-current-box-android-1.png 419w, https://blog.logrocket.com/wp-content/uploads/2022/07/highlight-current-box-android-1-143x300.png 143w" data-lazy-sizes="(max-width: 419px) 100vw, 419px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2022/07/highlight-current-box-android-1.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/07/highlight-current-box-android-1.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="123797" data-permalink="https://blog.logrocket.com/creating-split-otp-input-fields-react-native/attachment/highlight-current-box-android-2/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/07/highlight-current-box-android-1.png" data-orig-size="419,878" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="highlight-current-box-android" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/07/highlight-current-box-android-1-143x300.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/07/highlight-current-box-android-1.png" decoding="async" loading="lazy" class="aligncenter size-full wp-image-123797" src="../Images/5ee85d2ddb30d8e4b7b326ae68712c81.png" alt="Check Split Boxes On Android" srcset="https://blog.logrocket.com/wp-content/uploads/2022/07/highlight-current-box-android-1.png 419w, https://blog.logrocket.com/wp-content/uploads/2022/07/highlight-current-box-android-1-143x300.png 143w" sizes="(max-width: 419px) 100vw, 419px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/07/highlight-current-box-android-1.png"/></noscript>
<h3 id="adding-dynamism-split-input-fields">为我们的分割输入字段增加活力</h3>
<p>如果我们想给我们的应用程序添加活力，让它看起来更好呢？</p>
<p>为了实现这一点，我们可以使用<code>useEffect</code>钩子，每当所有需要的数字都被填满时，就将<code>setIsPinReady</code>的值更新为<code>true</code>。</p>
<pre class="language-javascript hljs"> useEffect(() =&gt; {
   // update pin ready status
   setIsPinReady(code.length === maximumLength);
   // clean up function
   return () =&gt; {
     setIsPinReady(false);
   };
 }, [code]);
</pre>
<p><code>code</code>是作为一个依赖项添加的，所以<code>useEffect</code>只有在<code>code</code>值改变时才会运行。然后，我们将更新<code>TextInputHidden</code>样式的组件以完全隐藏它，但不会失去任何控制:</p>
<pre class="language-javascript hljs">export const TextInputHidden = styled.TextInput`
 position: absolute;
 opacity: 0;
`;
</pre>
<p><img data-attachment-id="123825" data-permalink="https://blog.logrocket.com/creating-split-otp-input-fields-react-native/attachment/dynamism-android-2/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/07/dynamism-android-1.png" data-orig-size="398,847" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="dynamism-android" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/07/dynamism-android-1-141x300.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/07/dynamism-android-1.png" decoding="async" class="aligncenter wp-image-123825 size-full jetpack-lazy-image" src="../Images/808f938a7f88f9c2f6e4b9aa654b489e.png" alt="Dynamism On Android" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2022/07/dynamism-android-1.png 398w, https://blog.logrocket.com/wp-content/uploads/2022/07/dynamism-android-1-141x300.png 141w" data-lazy-sizes="(max-width: 398px) 100vw, 398px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2022/07/dynamism-android-1.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/07/dynamism-android-1.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="123825" data-permalink="https://blog.logrocket.com/creating-split-otp-input-fields-react-native/attachment/dynamism-android-2/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/07/dynamism-android-1.png" data-orig-size="398,847" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="dynamism-android" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/07/dynamism-android-1-141x300.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/07/dynamism-android-1.png" decoding="async" loading="lazy" class="aligncenter wp-image-123825 size-full" src="../Images/808f938a7f88f9c2f6e4b9aa654b489e.png" alt="Dynamism On Android" srcset="https://blog.logrocket.com/wp-content/uploads/2022/07/dynamism-android-1.png 398w, https://blog.logrocket.com/wp-content/uploads/2022/07/dynamism-android-1-141x300.png 141w" sizes="(max-width: 398px) 100vw, 398px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/07/dynamism-android-1.png"/></noscript>
<h3 id="hiding-keyboard-pressing-outside-split-boxes">在分离框外按压时隐藏键盘</h3>
<p>如果键盘被拉起，用户按下屏幕上框外的任何地方，键盘应该被关闭。我们可以使用 React Native 中的<code>Pressable</code>和<code>Keyboard</code>。</p>
<p>包装文本输入的<code>View</code>组件将被替换为<code>Pressable</code>组件，并附加<code>onPress</code>函数来调用<code>keyboard.dismiss</code>函数，如下图所示:</p>
<pre class="language-javascript hljs">import { StyleSheet, Text, View, Pressable, Keyboard } from "react-native";
import OTPInput from "./components/OTP/OTPInput";

export default function App() {
 const [otpCode, setOTPCode] = useState("");
 const [isPinReady, setIsPinReady] = useState(false);
 const maximumCodeLength = 4;
 return (
   &lt;Pressable style={styles.container} onPress={Keyboard.dismiss}&gt;
     &lt;OTPInput
       code={otpCode}
       setCode={setOTPCode}
       maximumLength={maximumCodeLength}
       setIsPinReady={setIsPinReady}
     /&gt;
     &lt;StatusBar style="auto" /&gt;
   &lt;/Pressable&gt;
 );
}
</pre>
<h3 id="syncing-submit-button-otp-input-state">将提交按钮与 OTP 输入状态同步</h3>
<p>假设我们在设计中有一个 submit 按钮，需要和这个特性一起实现。</p>
<p>我们可以首先使用<code>TouchableOpaity</code>和<code>Text</code>组件创建按钮，并在<code>Styles.js</code>中呈现它:</p>
<pre class="language-javascript hljs">export const ButtonContainer = styled.TouchableOpacity`
 background-color: #d8e9a8;
 padding: 20px;
 justify-content: center;
 align-items: center;
 width: 200px;
 margin-top: 30px;
`;

export const ButtonText = styled.Text`
 color: black;
 font-size: 20px;
`;
</pre>
<p>然后，在我们的<code>App.js</code>文件中，我们将使用我们刚刚创建的两个组件:</p>
<pre class="language-javascript hljs">export default function App() {
 const [otpCode, setOTPCode] = useState("");
 const [isPinReady, setIsPinReady] = useState(false);
 const maximumCodeLength = 4;
 return (
   &lt;Pressable style={styles.container} onPress={Keyboard.dismiss}&gt;
     &lt;OTPInput
       code={otpCode}
       setCode={setOTPCode}
       maximumLength={maximumCodeLength}
       setIsPinReady={setIsPinReady}
     /&gt;

     &lt;ButtonContainer&gt;
       &lt;ButtonText&gt;Login&lt;/ButtonText&gt;
     &lt;/ButtonContainer&gt;
     &lt;StatusBar style="auto" /&gt;
   &lt;/Pressable&gt;
 );
}
</pre>
<p>使用<code>isPinReady</code>状态，我们可以根据是否输入了所有数字来切换该按钮是激活还是非激活。</p>
<pre class="language-javascript hljs">&lt;
ButtonContainer
       disabled={!isPinReady}
       style={{
         backgroundColor: !isPinReady ? "grey" : "#000000",
       }}
     &gt;
       &lt;ButtonText
         style={{
           color: !isPinReady ? "black" : "#EEEEEE",
         }}
       &gt;
         Login
       &lt;/ButtonText&gt;
     &lt;/ButtonContainer&gt;
</pre>
<p>我们做到了！</p>

<p>结论</p>
<h2 id="conclusion">我们已经成功地在 React Native 中创建了一个拆分 OTP 输入字段！通过修改最大长度数，可以将它调整为用户需要输入的位数。</h2>
<p>你可以在这里找到<a href="https://github.com/Taofiqq/splitOTP" target="_blank" rel="noopener"> GitHub 库的链接。</a></p>
<p><a href="https://lp.logrocket.com/blg/react-native-signup"> LogRocket </a>:即时重现 React 原生应用中的问题。</p><div class="code-block code-block-18">
<div class="blog-plug inline-plug react-native-plug"><h2><a href="https://lp.logrocket.com/blg/react-native-signup" target="_blank" rel="noopener noreferrer"> LogRocket </a>是一款 React 原生监控解决方案，可帮助您即时重现问题、确定 bug 的优先级并了解 React 原生应用的性能。</h2><a class="signup" href="https://lp.logrocket.com/blg/react-native-signup" target="_blank" rel="noopener noreferrer"><img class="alignnone size-full wp-image-46 jetpack-lazy-image" src="../Images/110055665562c1e02069b3698e6cc671.png" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2021/10/react-native-plug_v2-2.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2021/10/react-native-plug_v2-2.png"/><noscript><img data-lazy-fallback="1" class="alignnone size-full wp-image-46" src="../Images/110055665562c1e02069b3698e6cc671.png" data-original-src="https://blog.logrocket.com/wp-content/uploads/2021/10/react-native-plug_v2-2.png"/></noscript></a><p>LogRocket 还可以向你展示用户是如何与你的应用程序互动的，从而帮助你提高转化率和产品使用率。LogRocket 的产品分析功能揭示了用户不完成特定流程或不采用新功能的原因。</p><p>开始主动监控您的 React 原生应用— <a class="signup" href="https://lp.logrocket.com/blg/react-native-signup" target="_blank" rel="noopener noreferrer">免费试用 LogRocket】。</a></p><p>Start proactively monitoring your React Native apps — <a class="signup" href="https://lp.logrocket.com/blg/react-native-signup" target="_blank" rel="noopener noreferrer">try LogRocket for free</a>.</p></div>
</div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
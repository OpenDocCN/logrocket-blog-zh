<html>
<head>
<title>Building an accessible menubar component using React - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>使用 React - LogRocket 博客构建一个可访问的菜单栏组件</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/building-accessible-menubar-component-react/#0001-01-01">https://blog.logrocket.com/building-accessible-menubar-component-react/#0001-01-01</a></blockquote><div><article class="article-post">
<p>上周，我看了佩德罗·杜阿尔特的精彩“<a href="https://www.youtube.com/watch?v=lY-RQjWeweo" target="_blank" rel="noopener">所以你认为你可以在 Next.js Conf 上建立一个下拉菜单</a>”演讲。它启发我写了一个我自己的可访问组件 menubar 小部件。</p>
<p>我对可访问性非常感兴趣，尤其是前端 web 开发。在我迄今为止研究的所有模式中，菜单栏是最复杂的。<a href="https://reach.tech/" target="_blank" rel="noopener"> Reach </a>、<a href="https://www.radix-ui.com/" target="_blank" rel="noopener"> Radix </a>、<a href="https://react-spectrum.adobe.com/react-aria/index.html" target="_blank" rel="noopener"> React Aria </a>都提供了灵活易得的 React <a href="https://blog.logrocket.com/build-component-library-react-typescript/" target="_blank" rel="noopener">组件</a>。</p>
<p>然而，我很难找到任何提供开箱即用菜单栏组件的库。鉴于材料的复杂性和缺乏，我想我应该与社区分享我的发现。</p>
<h2 id="introduction">创建可访问的<code>Menubar</code>组件</h2>
<p>本文将解释我如何用 React 创建一个可访问的<code>Menubar</code>组件。目标是为 menubar 小部件创建一个符合 WAI-ARIA <a href="https://www.w3.org/TR/wai-aria-practices/#menu" target="_blank" rel="noopener">设计模式</a>的组件。</p>
<p>以下是我们将要介绍的内容:</p>

<p>为简洁起见，本文将集中讨论带有单个子菜单的水平菜单栏。它还假设您对 React 挂钩和<a href="https://kentcdodds.com/blog/compound-components-with-react-hooks" target="_blank" rel="noopener">复合组件</a>模式感到满意。我已经将该解决方案作为 CodeSandbox 链接包含在下面。</p>


<p>我们将从需求开始。神话大学已经为他们的网站请求了一个可访问的站点导航。</p>
<p>首先，我们将在一个无序列表中对超链接集合进行分组。我们还将在导航部分包装列表。</p>
<p>HTML 可能看起来像这样:</p>
<pre class="language-html hljs">&gt;&lt;nav&gt;
        &lt;ul&gt;
                &lt;li&gt;
                      &lt;a href="/#about"&gt;About&lt;/a&gt;
                &lt;/li&gt;

                &lt;li&gt;
                      &lt;a href="/#admissions"&gt;Admissions&lt;/a&gt;
                &lt;/li&gt;

                &lt;li&gt;
                      &lt;a href="/#academics"&gt;Academics&lt;/a&gt;
                &lt;/li&gt;
        &lt;/ul&gt;
&lt;/nav&gt;
</pre>
<p>乍一看，这种标记看起来很全面，但是对于那些依赖辅助技术的人来说，它有多容易理解呢？此外，用户可以使用预期的键盘控件来导航菜单栏吗？</p>
<p>尽管我们已经提供了语义 HTML，但是当前的迭代被认为是不可访问的。标记缺少关键的<code>aria-</code>角色，这些角色为链接和小部件本身提供上下文。糟糕的键盘支持也意味着用户只能浏览链接列表。</p>
<p>让我们改善这两个方面。</p>
<p>我们将从创建两个功能组件开始。一个是父<code>Menubar</code>列表，另一个是子<code>MenuItem</code>列表项。我们将一起使用这些来组成一个复合的<code>&lt;Menubar /&gt;</code>组件。</p>
<p>父元素<code>Menubar</code>返回一个无序列表元素。因为它是小部件的根元素，我们将赋予它<code>menubar</code>角色。<code>aria-orientation</code>属性允许辅助技术决定菜单的方向。最后，让我们包含一个定制的<code>data-</code>属性，用于稍后的定位和样式。</p>
<pre class="language-jsx hljs">function Menubar({ children, ...props }) {
  const listProps = {
        ...props,
        "aria-orientation": "horizontal",
            "data-menubar-list": "",
        role: "menubar",
  };

  return &lt;ul {...listProps}&gt;{children}&lt;/ul&gt;;
};
</pre>
<p>第二个组件是<code>MenuItem</code>。它接受单个节点作为其<code>children</code>属性，并返回包装在列表项元素中的节点。</p>
<p>辅助技术应该只宣告子节点。默认情况下，列表项元素具有<code>lisitem</code>角色。通过将它重写为<code>none</code>，我们将它从可访问性树中完全移除。然后，我们通过<a href="https://reactjs.org/docs/react-api.html#cloneelement" target="_blank" rel="noopener">克隆元素</a>并浅层合并道具，为子节点分配<code>menuitem</code>角色。</p>
<pre class="language-jsx hljs">function MenuItem({ children, ...props }) {
  const listItemProps = {
        ...props,
            "data-menubar-listitem": "",
        role: "none"
  };

  const childProps = {
            "data-menubar-menuitem": "",
        role: "menuitem",
  };

  return (
        &lt;li {...listItemProps}&gt;
                {React.cloneElement(children, childProps)}
        &lt;/li&gt;
    );
};
</pre>
<p>最后，让我们给导航元素添加一个匹配的<code>aria-label</code>。</p>
<p>当前的 React 标记如下所示:</p>
<pre class="language-html hljs">&lt;nav aria-label="Mythical University"&gt;
        &lt;Menubar aria-label="Mythical University"&gt;
            &lt;MenuItem&gt;
                  &lt;a href="/#about"&gt;About&lt;/a&gt;
            &lt;/MenuItem&gt;

            &lt;MenuItem&gt;
                  &lt;a href="/#admissions"&gt;Admissions&lt;/a&gt;
            &lt;/MenuItem&gt;

            &lt;MenuItem&gt;
                  &lt;a href="/#academics"&gt;Academics&lt;/a&gt;
            &lt;/MenuItem&gt;
      &lt;/Menubar&gt;
&lt;/nav&gt;
</pre>
<p>它将编译成以下 HTML:</p>
<pre class="language-html hljs">&lt;nav aria-label="Mythical University"&gt;
        &lt;ul
          aria-label="Mythical University"
          aria-orientation="horizontal"
            data-menubar-list
          role="menubar"
        &gt;
              &lt;li data-menubar-listitem role="none"&gt;
                    &lt;a data-menubar-menuitem href="/#about" role="menuitem"&gt;
                      About
                    &lt;/a&gt;
              &lt;/li&gt;

              &lt;li data-menubar-listitem role="none"&gt;
                    &lt;a data-menubar-menuitem href="/#admissions" role="menuitem"&gt;
                      Admissions
                    &lt;/a&gt;
              &lt;/li&gt;

              &lt;li data-menubar-listitem role="none"&gt;
                    &lt;a data-menubar-menuitem href="/#academics" role="menuitem"&gt;
                      Academics
                    &lt;/a&gt;
              &lt;/li&gt;
        &lt;/ul&gt;
&lt;/nav&gt;
</pre>
<p>到目前为止，我们已经为那些使用辅助技术的人改进了菜单栏，但是那些依赖键盘控制的人呢？为了导航菜单项列表，<code>Menubar</code>组件需要知道每个子组件<code>MenuItem</code>。我们可以通过使用 React <code>createContext()</code>和<code>useEffect()</code>钩子来实现这一点。</p>
<p>让我们首先创建一个新的<code>MenubarContext</code>:</p>
<pre class="language-jsx hljs">export const MenubarContext = React.createContext(null);
</pre>
<p><code>MenubarContext</code>将在父<code>Menubar</code>中存储嵌套<code>MenuItem</code>节点的<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set" target="_blank" rel="noopener">集合</a>。我们将<code>Set</code>包含在用<code>useRef()</code>钩子创建的可变 ref 对象中，并将<code>current</code>值存储在一个变量中。</p>
<p>这允许我们操作<code>Set</code>的内容，而不需要重新渲染<code>Menubar</code>。接下来，我们将使用<code>useMemo()</code>钩子来记忆一个对象，并将<code>menuItems</code>指定为一个属性。最后，我们将把对象传递给<code>MenubarContext.Provider</code>的值属性。</p>
<pre class="language-jsx hljs">function Menubar({ children, ...props }) {
  const menuItems = React.useRef(new Set()).current;
    const value = React.useMemo(() =&gt; ({ menuItems }), [menuItems]);
    const listProps = { ... };

  return (
        &lt;MenubarContext.Provider value={value}&gt;
                &lt;ul {...listProps}&gt;
                        {children}
                &lt;/ul&gt;
        &lt;/MenubarContext.Provider&gt;
    );
};
</pre>
<p><code>MenuItem</code>只应该是<code>Menubar</code>组件的子组件。为了加强这一点，让我们在<code>useContext()</code>钩子找不到<code>MenubarContext</code>的时候抛出一个错误。这允许我们断言<code>menuItems</code>存在于下面的条件语句中:</p>
<pre class="language-jsx hljs">const menubarContext = React.useContext(MenubarContext);

if (!menubarContext) {
    throw new Error("MenuItem must be used within a Menubar Context");
}

const { menuItems } = menubarContext;
</pre>
<p>让我们用<code>useRef()</code>钩子创建一个对<code>MenuItem</code> DOM 节点的对象引用。然后，让我们使用<code>useEffect()</code>钩子来触发一个副作用，将节点添加到<code>menuItems</code> <code>Set</code>。如果<code>MenuItem</code>卸载，我们还将返回一个清理函数来将它从<code>Set</code>中移除。</p>
<pre class="language-jsx hljs">const { menuItems } = menubarContext;

const menuItemRef = React.useRef(null);

const listItemProps = {
    [ ... ],
    ref: menuItemRef,
};

React.useEffect(() =&gt; {
  const menuItemNode = menuItemRef.current;

  if (menuItemNode) {
    menuItems.add(menuItemNode);
  }

  return () =&gt; {
    menuItems.delete(menuItemNode);
  };
}, [menuItems]);

return (
    &lt;li {...listItemProps}&gt;
                {React.cloneElement(children, childProps)}
        &lt;/li&gt;
);
</pre>
<h3 id="roving-tab-index">漫游标签索引</h3>
<p>我们现在有了对每个<code>MenuItem</code>节点的引用。有了它们，我们可以应用<a href="https://www.w3.org/TR/wai-aria-practices-1.1/#kbd_roving_tabindex" target="_blank" rel="noopener">漫游标签索引</a>模式来管理组件内的焦点。为此，<code>Menubar</code>需要跟踪当前和之前聚焦的<code>MenuItem</code>。我们可以通过在<code>Menubar</code>的组件状态中存储当前和先前节点的索引来做到这一点。</p>
<p>当前索引是使用 React <code>useState()</code>钩子存储的有状态值。当菜单栏第一次挂载时，第一个<code>MenuItem</code>子菜单应该有一个标签索引<code>0</code>。因此，我们可以将<code>0</code>指定为当前索引的默认状态。</p>
<p>我们可以使用自定义挂钩来跟踪之前的索引。钩子接受当前索引作为函数参数。如果钩子没有返回值，我们可以假设一个不存在，退回到<code>null</code>。</p>
<pre class="language-jsx hljs">/* https://usehooks.com/usePrevious/ */

const [currentIndex, setCurrentIndex] = React.useState(0);
const previousIndex = usePrevious(currentIndex) ?? null;

function usePrevious(value) {
    const ref = React.useRef();

    React.useEffect(() =&gt; {
        ref.current = value;
    }, [value]);

    return ref.current;
}
</pre>
<p>为了应用移动标签索引，<code>menuItems[currentIndex]</code>节点必须具有标签索引<code>0</code>。组件标签序列中的所有其他元素都应该有一个标签索引<code>-1</code>。每当用户从一个菜单项导航到另一个菜单项时，都会发生以下情况:</p>
<ul>
<li>当前节点应该模糊，其标签索引应该设置为<code>-1</code></li>
<li>下一个节点的标签索引被设置为<code>0</code></li>
<li>下一个节点接收焦点</li>
</ul>
<p>让我们为此利用 React <code>useEffect()</code>钩子。我们将传递当前和以前的索引作为效果依赖。每当任一索引改变时，该效果将更新所有适当的索引。</p>
<p>(注意:我们将 tab index 属性应用于<code>MenuItem</code>的第一个子元素，而不是列表项包装器)</p>
<pre class="language-jsx hljs">React.useEffect(() =&gt; {
        if (currentIndex !== previousIndex) {
            const items = Array.from(menuItems);
            const currentNode = items[currentIndex]?.firstChild;
            const previousNode = items[previousIndex]?.firstChild;

            previousNode?.setAttribute("tabindex", "-1");
            currentNode?.setAttribute("tabindex", "0");
            currentNode?.focus();
        }
}, [currentIndex, previousIndex, menuItems]);
</pre>
<p>我们不必为每个菜单项添加标签索引；我们可以更新<code>MenuItem</code>组件来为我们做这件事！我们可以假设如果<code>menuItems</code> <code>Set</code>为空，那么该节点就是序列中的第一个菜单项。</p><div class="code-block code-block-54">
<hr/>
<h3>更多来自 LogRocket 的精彩文章:</h3>

<hr/></div>
<p>让我们添加一些组件状态来跟踪<code>MenuItem</code>是否是集合中的第一个节点。如果是，我们可以给它的标签索引赋值<code>0</code>——否则，我们将返回到<code>-1</code>。</p>
<pre class="language-jsx hljs">const [isFirstChild, setIsFirstChild] = React.useState(false);
const menuItemRef = React.useRef(null);
const { menuItems } = menubarContext;

const listItemProps = {
    [ ... ],
    ref: menuItemRef,
};

const childProps = {
        [ ... ],
      tabIndex: isFirstChild ? "0" : "-1",
};

React.useEffect(() =&gt; {
      const menuItemNode = menuItemRef.current;

        if (menuItemNode) {
            if (!menuItems.size) {
                  setIsFirstChild(true);
            }

            menuItems.add(menuItemNode);
        }

      return () =&gt; {
            menuItems.delete(menuItemNode);
      };
}, [menuItems]);

return (
        &lt;li {...listItemProps}&gt;
                {React.cloneElement(children, childProps)}
        &lt;/li&gt;;
);
</pre>
<h3 id="keyboard-controls">键盘控制</h3>
<p>接下来，我们将使用<code>Menubar</code>的<code>onKeyDown()</code>事件根据用户的按键更新当前索引。用户可以通过五种主要方法浏览菜单项。</p>
<p>他们可以:</p>
<ul>
<li>返回上一个项目</li>
<li>前进到下一个</li>
<li>跳到第一个</li>
<li>跳到最后一页</li>
<li>移到下一场比赛</li>
</ul>
<p>让我们将该逻辑封装到一些助手方法中，我们可以将它们传递给<code>keyDown</code>事件。</p>
<pre class="language-jsx hljs">// Moves focus to the first item in the menubar.
const first = () =&gt; setCurrentIndex(0);

// Moves focus to last item in the menubar.
const last = () =&gt; setCurrentIndex(menuItems.size - 1);

// Moves focus to the next item in the menubar. 
// If focus is on the last item, moves focus to the first item.
const next = () =&gt; {
  const index = currentIndex === menuItems.size - 1 ? 0 : currentIndex + 1;
  setCurrentIndex(index);
};

// Moves focus to the previous item in the menubar. 
// If focus is on the first item, moves focus to the last item.
const previous = () =&gt; {
  const index = currentIndex === 0 ? menuItems.size - 1 : currentIndex - 1;
  setCurrentIndex(index);
};

// Moves focus to next item in the menubar that starts with the character. 
// If none of the items start with the typed character, focus does not move.
const match = (e) =&gt; {
  const items = Array.from(menuItems);

  const reorderedItems = [
      ...items.slice(currentIndex),
      ...items.slice(0, currentIndex)
  ];

  const matches = reorderedItems.filter((menuItem) =&gt; {
      const { textContent } = menuItem.firstChild;
      const firstLetter = textContent.toLowerCase().charAt(0);
      return e.key === firstLetter;
  });

  if (!matches.length) {
      return;
  }

  const currentNode = items[currentIndex];
  const nextMatch = matches.includes(currentNode) ? matches[1] : matches[0];
  const index = items.findIndex((item) =&gt; item === nextMatch);

  setCurrentIndex(index);
};
</pre>
<p>定义了助手方法后，我们可以将它们分配给适当的键码。我们将检查按键是否匹配任何与移动相关的按键；如果没有，我们将默认使用<code>match()</code> helper 方法。</p>
<pre class="language-jsx hljs">const keyDown = (e) =&gt; {
    e.stopPropagation();

    switch (e.code) {
                case "ArrowLeft":
            e.preventDefault();
            previous();
            break;
        case "ArrowRight":
            e.preventDefault();
            next();
            break;
                case "End":
            e.preventDefault();
            last();
            break;
        case "Home":
            e.preventDefault();
            first();
            break;
        default:
                        match(e);
            break;
    }
};

const listProps = {
    [ ... ],
        onKeyDown: (e) =&gt; {
          keyDown(e);
    },
};
</pre>
<p>注意，我们在大多数助手方法上调用了<code>e.preventDefault()</code>。这是为了抑制用户与菜单栏交互时的任何默认浏览器行为。例如，默认情况下，<code>End</code>键将用户滚动到页面底部。</p>
<p>假设我们没有阻止默认行为；每当用户试图跳到最后一个菜单项时，滚动位置就会跳到页面的底部！</p>
<p>我们不能在默认情况下调用<code>e.preventDefault()</code>。如果我们这样做，它将忽略任何默认的浏览器行为，而不是开关的情况下捕获。这可能会导致不良行为。例如，如果菜单栏中的菜单项有焦点，用户按下<code>ctrl + r</code>来刷新页面。如果我们在默认情况下调用<code>e.preventDefault()</code>，它会忽略刷新请求。然后它会将<code>r</code>键传递给<code>match</code>助手方法。</p>
<p>我们现在有了一个完全可访问的菜单栏小部件来收集导航链接！每个菜单项都为辅助技术提供丰富的上下文信息。它还允许那些依赖键盘支持的人按照他们的期望导航链接列表。</p>
<p>组件 API 与上一个示例相比没有变化…</p>
<pre class="language-html hljs">&lt;nav aria-label="Mythical University"&gt;
        &lt;Menubar aria-label="Mythical University"&gt;
              &lt;MenuItem&gt;
                    &lt;a href="/#about"&gt;About&lt;/a&gt;
              &lt;/MenuItem&gt;

              &lt;MenuItem&gt;
                    &lt;a href="/#admissions"&gt;Admissions&lt;/a&gt;
              &lt;/MenuItem&gt;

              &lt;MenuItem&gt;
                    &lt;a href="/#academics"&gt;Academics&lt;/a&gt;
              &lt;/MenuItem&gt;
        &lt;/Menubar&gt;
&lt;/nav&gt;
</pre>
<p>…然而，编译后的 HTML 标记现在包括菜单项上的制表符索引。</p>
<p>进步！</p>
<pre class="language-html hljs">&lt;nav aria-label="Mythical University"&gt;
        &lt;ul
          aria-label="Mythical University"
          aria-orientation="horizontal"
          data-menubar-list
          role="menubar"
        &gt;
              &lt;li data-menubar-listitem role="none"&gt;
                    &lt;a data-menubar-menuitem href="/#about" role="menuitem" tabindex="0"&gt;
                          About
                    &lt;/a&gt;
              &lt;/li&gt;

              &lt;li data-menubar-listitem role="none"&gt;
                    &lt;a data-menubar-menuitem href="/#admissions" role="menuitem" tabindex="-1"&gt;
                          Admissions
                    &lt;/a&gt;
              &lt;/li&gt;

              &lt;li data-menubar-listitem role="none"&gt;
                    &lt;a data-menubar-menuitem href="/#academics" role="menuitem" tabindex="-1"&gt;
                          Academics
                    &lt;/a&gt;
              &lt;/li&gt;
        &lt;/ul&gt;
&lt;/nav&gt;
</pre>

<p>前一个例子对于一个链接集合来说很好，但是如果我们用一个下拉菜单来显示第二组导航链接，会怎么样呢？</p>
<pre class="language-html hljs">&lt;nav aria-label="Mythical University"&gt;
        &lt;Menubar aria-label="Mythical University"&gt;
              &lt;MenuItem&gt;
                    &lt;a href="/#about"&gt;About&lt;/a&gt;
              &lt;/MenuItem&gt;

              &lt;MenuItem&gt;
                        &lt;button&gt;Admissions&lt;/button&gt;

                        &lt;ul&gt;
                                &lt;li&gt;&lt;a href="/#visit"&gt;Visit&lt;/a&gt;&lt;/li&gt;
                                &lt;li&gt;&lt;a href="/#photo-tour"&gt;Photo Tour&lt;/a&gt;&lt;/li&gt;
                                &lt;li&gt;&lt;a href="/#connect"&gt;Connect&lt;/a&gt;&lt;/li&gt;
                        &lt;/ul&gt;
              &lt;/MenuItem&gt;

              &lt;MenuItem&gt;
                    &lt;a href="/#academics"&gt;Academics&lt;/a&gt;
              &lt;/MenuItem&gt;
        &lt;/Menubar&gt;
&lt;/nav&gt;
</pre>
<p>为此，我们需要创建第二个复合组件——<code>&lt;Submenu /&gt;</code>。它由三个功能组件组成:</p>
<ul>
<li><code>Submenu</code>将保存共享逻辑和组件状态</li>
<li><code>Trigger</code>将允许用户扩展菜单</li>
<li><code>List</code>将显示扩展的菜单项</li>
</ul>
<p><code>MenubarContext</code>跟踪<code>Menubar</code>中的菜单项。接下来，让我们创建一个<code>SubmenuContext</code>来跟踪嵌套在<code>Submenu</code>中的菜单项。</p>
<pre class="language-jsx hljs">export const SubmenuContext = React.createContext(null);
</pre>
<p>让我们从定义<code>Submenu</code>组件开始。它将与<code>Menubar</code>共享一些类似的行为和功能。除了索引跟踪，它还需要知道它的菜单是否扩展了。我们可以用<code>useState()</code>声明另一个状态变量。相反，将逻辑合并到一个 reducer 函数中更有意义。</p>
<p><code>Submenu</code>父组件的目的是保存复合组件的状态。它还负责向其子组件分发共享逻辑。我们将逻辑分配给一个记忆化的对象，然后将该对象传递给一个<code>SubmenuContext.Provider</code>的 value 属性。</p>
<pre class="language-jsx hljs">const submenuInitialState = {
  currentIndex: null,
  previousIndex: null,
    isExpanded: false,
};

function submenuReducer(state, action) {
  switch (action.type) {
    case "expand":
      return { ...state, isExpanded: true };
    case "collapse":
      return submenuInitialState;
    case "move":
      return {
        ...state,
        isExpanded: true,
        currentIndex: action.index,
        previousIndex: state.currentIndex
      };
    default:
      throw new Error(`${action.type} not recognised`);
  }
}

const Submenu = ({ children }) =&gt; 
  const menuItems = React.useRef(new Set()).current;
    const [state, dispatch] = React.useReducer(submenuReducer, submenuInitialState);
  const value = React.useMemo(() =&gt; ({ menuItems }), [menuItems]);

  return (
    &lt;SubmenuContext.Provider value={value}&gt;
            {children}
        &lt;/SubmenuContext.Provider&gt;
  );
};
</pre>
<p>现在，让我们定义导航子菜单菜单项的助手方法。这些几乎和<code>Menubar</code>助手一模一样。关键的区别是它们分派 reducer 动作，而不是直接更新组件状态。</p>
<pre class="language-jsx hljs">const open = React.useCallback(() =&gt; dispatch({ type: "expand" }), []);

const close = React.useCallback(() =&gt; dispatch({ type: "collapse" }), []);

const first = React.useCallback() =&gt; dispatch({ type: "move", index: 0 }), []);

const last = React.useCallback(() =&gt; (
        dispatch({ type: "move", index: menuItems.size - 1 }), [menuItems.size]
));

const move = React.useCallback((index) =&gt; dispatch({ type: "move", index }), []);

const value = React.useMemo(() =&gt; ({ open, close, first, last, move }),
  [open, close, first, last, move]
);

return (
    &lt;SubmenuContext.Provider value={value}&gt;
            {children}
        &lt;/SubmenuContext.Provider&gt;
);
</pre>
<p>一些功能需求需要子组件了解它们的兄弟组件。我们可以通过定义<code>id</code>和<code>Submenu</code>中每个子组件的引用来实现这一点。注意，我们将<code>menuId</code>存储在一个引用对象中。这是为了防止<code>uniqueId()</code>函数在每次渲染时重新生成<code>id</code>。每个子组件现在都可以从<code>useContext()</code>钩子中检索值。</p>
<pre class="language-jsx hljs">const id = React.useRef(_.uniqueId("submenu--")).current;
const buttonId = `button--${id}`;
const listId = `list--${id}`;

const buttonRef = React.useRef(null);
const listRef = React.useRef(null);

const value = React.useMemo(
  () =&gt; ({ buttonId, buttonRef, listId, listRef })
  [buttonId, buttonRef, listId, listRef]
);
</pre>
<p>现在让我们来管理<code>Submenu</code>中的焦点。我们将从添加另一个副作用开始。如果被跟踪的索引不匹配，它将聚焦于当前索引的第一个子索引。每当我们更新当前索引时，我们关注新的当前节点的第一个子节点。</p>
<pre class="language-jsx hljs">React.useEffect(() =&gt; {
    const items = Array.from(menuItems);

    if (currentIndex !== previousIndex) {
      const currentNode = items[currentIndex]?.firstChild;
      currentNode?.focus();
    }
}, [menuItems, currentIndex, previousIndex]);
</pre>
<p>子菜单不遵循漫游选项卡索引模式。相反，子菜单中每个菜单项的标签索引将始终是<code>-1</code>。这需要对<code>MenuItem</code>组件做一点小小的改动。如果一个<code>SubmenuContext</code>存在，我们可以假设<code>MenuItem</code>在一个<code>Submenu</code>中，并将<code>-1</code>应用于它的标签索引。</p>
<pre class="language-jsx hljs">const [isFirstChild, setIsFirstChild] = React.useState(false);
const submenuContext = React.useContext(SubmenuContext);

const childProps = {
        [ ... ],
      tabIndex: !submenuContext &amp;&amp; isFirstChild ? "0" : "-1",
};
</pre>
<h3 id="trigger">引发</h3>
<p>定义了<code>Submenu</code>之后，让我们创建<code>Trigger</code>组件。我们将从从<code>SubmenuContext</code>中检索<code>buttonId</code>和<code>buttonRef</code>开始。因为按钮的默认类型是<code>submit</code>，所以将其覆盖为<code>button</code>通常是个好主意。</p>
<p>最后，<code>Trigger</code>只能是<code>Submenu</code>的子元素。像以前一样，如果我们在一个<code>SubmenuContext</code>之外使用它，让我们抛出一个错误。</p>
<pre class="language-jsx hljs">const Trigger = ({ onKeyDown, ...props }) =&gt; {
  const context = React.useContext(SubmenuContext);

  if (!context) {
    throw new Error("Trigger must be used within a Submenu Context");
  }

  const { buttonId, buttonRef } = context;

    const buttonProps = {
            ...props,
        id: buttonId,
          ref: buttonRef,
        type: "button",  
  }

  return &lt;button {...buttonProps} /&gt;;
};
</pre>
<p>接下来，让我们添加适当的<code>aria-</code>属性。<code>aria-haspopup='true'</code>将通知辅助技术该按钮控制一个子菜单。为了更进一步，我们还可以添加<code>aria-controls</code>属性。这将通知屏幕阅读器由<code>Trigger</code>控制的确切子菜单。</p>
<p>让我们也从<code>SubmenuContext</code>中检索<code>listId</code>和<code>isExpanded</code>状态。我们将把<code>listId</code>分配给<code>aria-controls</code>。然后，剩下的就是将<code>isExpanded</code>状态分配给<code>aria-expanded</code>属性。辅助技术现在可以识别菜单按钮控件，以及它们是打开还是关闭。</p>
<pre class="language-jsx hljs">const { buttonId, buttonRef, listId, isExpanded } = submenuContext;

const buttonProps = {
    ...props,
        "aria-haspopup": true,
    "aria-expanded": isExpanded,
    "aria-controls": listId,
        "data-menubar-submenu-trigger": "",
    id: buttonId,
    ref: buttonRef,
    type: "button",
};
</pre>
<p>现在，让我们给<code>Trigger</code>添加键盘支持。<code>Trigger</code>将是菜单栏菜单项的兄弟。这意味着它应该执行与菜单栏链接相同的<code>keyDown</code>事件。它还需要一些额外的功能。除了菜单项行为，触发器还应该:</p>
<ul>
<li><code>ArrowUp</code>:打开子菜单，聚焦最后一项</li>
<li><code>ArrowDown</code>:打开子菜单，聚焦第一项</li>
<li><code>Space</code>、<code>Enter</code>:打开子菜单，聚焦到第一项</li>
</ul>
<p>为此，我们将从<code>SubmenuContext</code>中检索一些方法，并将它们分配给相关的<code>e.code</code>。注意，我们只想对唯一的事件执行<code>e.stopPropagation()</code>方法。</p>
<p>这样做允许所有其他事件冒泡到<code>MenuBar</code>。这是防止我们必须复制菜单项的<code>keydown</code>事件的原因。</p>
<pre class="language-jsx hljs">const { first, last } = submenuContext;

const keyDown = (e) =&gt; {
    switch (e.code) {
      case "ArrowUp":
        e.stopPropagation();
        last();
        break;
      case "ArrowDown":
        e.stopPropagation();
        first();
        break;
      case "Enter":
      case "Space":
        e.stopPropagation();
        first();
        break;
      default:
        break;
    }
};

const buttonProps = {
      [ ... ],
      onKeyDown: (e) =&gt; {
        onKeyDown?.(e);
        keyDown(e);
      },
};
</pre>
<p>假设当用户按下<code>ArrowLeft</code>或<code>ArrowRight</code>键时，打开一个子菜单。子菜单应关闭并聚焦于上一个或下一个<code>Menubar</code>菜单项。如果根菜单项也是一个子菜单，它应该展开菜单，但保持焦点在触发器上。</p>
<p><code>Trigger</code>通过检查事件是否源自子菜单菜单项来实现这一点。这确保了当其他<code>keydown</code>方法聚焦触发器时，菜单不会展开。</p>
<pre class="language-jsx hljs">const buttonProps = {
        [ ... ],
        onFocus: (e) =&gt; {
              const isFromSubmenu = e.relatedTarget?.getAttribute(
                    "data-menubar-submenu-menuitem"
                ) === "";

              if (isFromSubmenu) {
                open();
              }
        }
};
</pre>
<h3 id="list">目录</h3>
<p>现在我们有了一个<code>Trigger</code>，我们需要做的就是创建一个子菜单<code>List</code>。像<code>Trigger</code>一样，如果在<code>SubmenuContext</code>中没有使用<code>List</code>组件，我们将抛出一个错误。</p>
<p>让我们也定义一些属性。首先，我们将应用<code>role='menu'</code>并从<code>SubmenuContext</code>中检索<code>listId</code>。我们将从上下文中检索<code>isExpanded</code>，并将其分配给<code>aria-hidden</code>属性。如果菜单没有展开，这将从可访问性树中隐藏<code>List</code>。</p>
<p>接下来，让我们通过将<code>buttonId</code>分配给<code>aria-labelledby</code>属性来标记菜单。最后，我们将使用<code>aria-orientation</code>属性为辅助技术提供菜单的方向。</p>
<pre class="language-jsx hljs">const List = ({ children, ...props }) =&gt; {
  const submenuContext = React.useContext(SubmenuContext);

  if (!submenuContext ) {
        throw new Error("List must be used within a Submenu Context");
  }

  const { listId, listRef, isExpanded } = submenuContext;

  const listProps = {
      ...props,
        "aria-hidden": !isExpanded,
      "aria-labelledby": buttonId,
      "aria-orientation": "vertical",
        "data-menubar-submenu-list": "",
        id: listId,
        ref: listRef,
      role: "menu",
};

  return (
      &lt;ul {...listProps}&gt;
            {children}
      &lt;/ul&gt;
  );
};
</pre>
<p>现在让我们添加一些特定于<code>List</code>组件的<code>keydown</code>事件。我们将从<code>SubmenuContext</code>中取回合适的助手。同样，我们只想停止那些我们不希望上升到<code>Menubar</code>的<code>keydown</code>事件的事件的传播。</p>
<pre class="language-jsx hljs">const { close, first, last, move } = submenuContext;

const keyDown = (e) =&gt; {
      switch (e.code) {
            case "ArrowUp":
                  e.stopPropagation();
                  e.preventDefault();
                  previous();
                  break;
            case "ArrowDown":
                  e.stopPropagation();
                  e.preventDefault();
                  next();
                  break;
            case "ArrowLeft":
                  e.preventDefault();
                  close();
                  break;
            case "ArrowRight":
                  e.preventDefault();
                  close();
                  break;
            case "Home":
                  e.stopPropagation();
                  e.preventDefault();
                  first();
                  break;
            case "End":
                  e.stopPropagation();
                  e.preventDefault();
                  last();
                  break;
            case "Enter":
            case "Space":
                  close();
                  break;
            case "Escape":
                  e.stopPropagation();
                  e.preventDefault();
                  close();
                  break;
            case "Tab":
                  close();
                  break;
            default:
                  e.stopPropagation();
                  match(e);
                  break;
      }
};

const listProps = {
      [ ... ],
        onKeyDown: (e) =&gt; {
            e.preventDefault();
            keyDown(e);
      },
};
</pre>
<p>在大多数情况下，<code>MenuItem</code>组件将在<code>Submenu</code>内工作。我们需要做一些修改来确保<code>Menubar</code>和<code>Submenu</code>都可以使用这个组件。</p>
<p>第一个变化是确保正确的<code>menuItems</code> <code>Set</code>接收到<code>menuItem</code>节点。如果<code>MenuItem</code>可以检索到<code>SubmenuContext</code>，我们可以断言子菜单是祖先元素。如果它返回一个假值，那么<code>MenuItem</code>必须属于菜单栏。</p>
<p>让我们更新错误以检查<code>SubmenuContext</code>。只有当两个上下文都不存在时，才会引发错误。一个<code>MenuItem</code>现在可以是一个<code>Menubar</code>或者一个<code>Submenu</code>的子节点。</p>
<pre class="language-jsx hljs">const menubarContext = React.useContext(MenubarContext);
const submenuContext = React.useContext(SubmenuContext);

if (!menubarContext &amp;&amp; !submenuContext) {
    throw new Error(
        "MenuItem must be used within either a Menubar or Submenu Context"
    );
}
</pre>
<p>我们需要对<code>MenuItem</code>组件做最后一个更改。让我们重温一下<code>Submenu</code>的结构。</p>
<p><code>MenuItem</code>当前克隆了它的<code>children</code>道具并附加了额外的道具。在下面的例子中，我们可以看到<code>MenuItem</code>的子组件是<code>Submenu</code>组件。<code>Submenu</code>返回一个上下文提供者作为其父元素。提供者不会从 render 返回任何内容，因此 props 不会附加到任何 DOM 节点。</p>
<pre class="language-html hljs">&lt;Menubar aria-label="Menubar example"&gt;
  &lt;MenuItem&gt;
        &lt;SubmenuContext.Provider {...menuItemProps}&gt;
          &lt;Trigger /&gt;
          &lt;List /&gt;
        &lt;/SubmenuContext.Provider&gt;
  &lt;/MenuItem&gt; 
&lt;/Menubar&gt;
</pre>
<p>相反，我们希望将<code>MenuItem</code>的<code>childProps</code>追加到子菜单<code>Trigger</code>上。为此，<code>MenuItem</code>组件需要检查其<code>children</code>的类型。</p>
<p>如果类型是一个节点，那么我们克隆它并添加属性。如果该类型是一个函数，那么我们提供 props 作为函数签名中的一个参数。</p>
<p>这允许我们灵活地选择哪个元素应该接收属性，并且还保留了默认情况下将属性附加到子元素上的便利性。</p>
<pre class="language-jsx hljs">return (
    &lt;li {...listItemProps}&gt;
          { typeof children === "function"
                ? children(childProps)
                : React.cloneElement(children, childProps)
                }
    &lt;/li&gt;
);

MenuItem.propTypes = {
  children: PropTypes.oneOfType([PropTypes.node, PropTypes.func]).isRequired,
};
</pre>
<p>这给我们留下了这个灵活的 React 标记:</p>
<pre class="language-html hljs">&lt;nav aria-label="Mythical University"&gt;
        &lt;Menubar aria-label="Mythical University"&gt;
              &lt;MenuItem&gt;
                        &lt;a href="/#about"&gt;About&lt;/a&gt;
                &lt;/MenuItem&gt; 

              &lt;MenuItem&gt;
                    {(menuItemProps) =&gt; (
                            &lt;Submenu&gt;
                                  &lt;Trigger {...menuItemProps}&gt;
                                            Admissions
                                    &lt;/Trigger&gt;

                                  &lt;List&gt;
                                            &lt;MenuItem&gt;
                                                    &lt;a href="/#visit"&gt;Visit&lt;/a&gt;
                                            &lt;/MenuItem&gt; 

                                            &lt;MenuItem&gt;
                                                    &lt;a href="/#photo-tour"&gt;Photo Tour&lt;/a&gt;
                                            &lt;/MenuItem&gt; 

                                            &lt;MenuItem&gt;
                                                    &lt;a href="/#connect"&gt;Connect&lt;/a&gt;
                                            &lt;/MenuItem&gt; 
                                    &lt;/List&gt;
                            &lt;/Submenu&gt;
                    )}
                &lt;/MenuItem&gt; 

                &lt;MenuItem&gt;
                        &lt;a href="/#academics"&gt;Academics&lt;/a&gt;
                &lt;/MenuItem&gt; 
        &lt;/Menubar&gt;
&lt;/nav&gt;
</pre>
<p>…编译成这个漂亮的、可访问的 HTML:</p>
<pre class="language-html hljs">&lt;nav aria-label="Mythical University"&gt;
        &lt;ul
          aria-label="Mythical University"
            aria-orientation="horizontal"
            data-menubar-list
          role="menubar"
        &gt;
              &lt;li data-menubar-listitem role="none"&gt;
                    &lt;a data-menubar-menuitem href="/#about" role="menuitem" tabindex="0"&gt;
                              About
                    &lt;/a&gt;
                &lt;/li&gt;

              &lt;li data-menubar-listitem role="none"&gt;
                    &lt;button
                            aria-controls="list--submenu--1"
                            aria-expanded="false"
                            aria-haspopup="true"
                            data-menubar-menuitem
                            data-menubar-submenu-trigger
                            id="button--submenu--1"
                      role="menuitem"
                      tabindex="-1"
                      type="button"
                    &gt;
                          Admissions
                    &lt;/button&gt;

                    &lt;ul
                          aria-hidden="true"
                          aria-labelledby="button--submenu--1"
                          aria-orientation="vertical"
                                data-menubar-submenu-list
                                id="list--submenu--1"
                          role="menu"
                    &gt;
                              &lt;li data-menubar-submenu-listitem role="none"&gt;
                                &lt;a
                                                data-menubar-submenu-menuitem
                                      href="/#visit"
                                      role="menuitem"
                                      tabindex="-1" 
                                &gt;
                                      Visit
                                &lt;/a&gt;
                            &lt;/li&gt;

                                &lt;li data-menubar-submenu-listitem role="none"&gt;
                                &lt;a
                                                data-menubar-submenu-menuitem
                                      href="/#photo-tour"
                                      role="menuitem"
                                      tabindex="-1" 
                                &gt;
                                      Photo Tour
                                &lt;/a&gt;
                            &lt;/li&gt;

                                &lt;li data-menubar-submenu-listitem role="none"&gt;
                                &lt;a
                                                data-menubar-submenu-menuitem
                                      href="/#connect"
                                      role="menuitem"
                                      tabindex="-1" 
                                &gt;
                                      Connect
                                &lt;/a&gt;
                            &lt;/li&gt;
                    &lt;/ul&gt;
              &lt;/li&gt;

                &lt;li data-menubar-listitem role="none"&gt;
                    &lt;a data-menubar-menuitem href="/#academics" role="menuitem" tabindex="-1"&gt;
                      Academics
                    &lt;/a&gt;
                &lt;/li&gt;
        &lt;/ul&gt;
&lt;/nav&gt;
</pre>
<p>现在，剩下的就是为鼠标指针事件、嵌套子菜单和全套单元测试添加额外的逻辑了！</p>
<p>不幸的是，我们认为这些特性超出了本文的讨论范围，需要后续的文章来讨论。我已经在页面顶部的<a href="https://codesandbox.io/s/a11y-menubar-ej7kh?file=/src/App.js" target="_blank" rel="noopener"> CodeSandbox 演示</a>中包含了所有额外的逻辑和单元测试。</p>
<p>特别感谢<a href="https://twitter.com/jjenzz" target="_blank" rel="noopener"> Jenna Smith </a>为最初的 API 设计做出的宝贵贡献。</p>
<p>如果您有任何问题或反馈，请随时联系我们，如果您喜欢这篇文章，可以考虑在<a href="https://ajames.dev/twitter" target="_blank" rel="noopener"> Twitter </a>上关注我。</p><div class="code-block code-block-17">
<div class="blog-plug inline-plug react-plug" vwo-el-id="26283398190">
<h2 vwo-el-id="41600691720"><a href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener"> LogRocket </a>:全面了解您的生产 React 应用</h2><p>调试 React 应用程序可能很困难，尤其是当用户遇到难以重现的问题时。如果您对监视和跟踪 Redux 状态、自动显示 JavaScript 错误以及跟踪缓慢的网络请求和组件加载时间感兴趣，</p><a href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" vwo-el-id="19356441070">try LogRocket</a><p>. </p><a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="19356441380">
<img class="first-react-image alignnone size-full wp-image-46 jetpack-lazy-image jetpack-lazy-image--handled" src="../Images/f300c244a1a1cf916df8b4cb02bec6c6.png" vwo-el-id="18272717540" data-lazy-loaded="1" data-original-src="https://files.readme.io/27c94e7-Image_2017-06-05_at_9.46.04_PM.png"/>
</a>
<a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="19356441690">
<img class="second-react-image alignnone size-full wp-image-46 jetpack-lazy-image jetpack-lazy-image--handled" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" vwo-el-id="30720362350" data-lazy-loaded="1" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/>
</a>
<p vwo-el-id="28675660440" class="">LogRocket 结合了会话回放、产品分析和错误跟踪，使软件团队能够创建理想的 web 和移动产品体验。这对你来说意味着什么？</p>
<p>LogRocket 不是猜测错误发生的原因，也不是要求用户提供截图和日志转储，而是让您回放问题，就像它们发生在您自己的浏览器中一样，以快速了解哪里出错了。</p>
<p>不再有嘈杂的警报。智能错误跟踪允许您对问题进行分类，然后从中学习。获得有影响的用户问题的通知，而不是误报。警报越少，有用的信号越多。</p>
<p vwo-el-id="28675660750">LogRocket Redux 中间件包为您的用户会话增加了一层额外的可见性。LogRocket 记录 Redux 存储中的所有操作和状态。</p>
<p vwo-el-id="28675661060">现代化您调试 React 应用的方式— <a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="40093418840">开始免费监控</a>。</p>
</div></div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
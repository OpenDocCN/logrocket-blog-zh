<html>
<head>
<title>How to validate forms in Remix - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>如何在 Remix - LogRocket 博客中验证表单</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/how-to-validate-forms-remix/#0001-01-01">https://blog.logrocket.com/how-to-validate-forms-remix/#0001-01-01</a></blockquote><div><article class="article-post">
<p><a href="https://blog.logrocket.com/remix-guide-newly-open-sourced-react-framework/" target="_blank" rel="noopener"> Remix </a>消除了手动将表单连接到状态的需要，或者像在典型的 React 应用程序中一样，使用<code>submit</code>事件监听器在客户端处理表单提交。相反，Remix 把我们带回了 PHP 等语言处理表单的传统方式。</p>
<p>当用 React 处理表单时，我们必须设置状态表单数据和错误，决定我们是否要使用受控或不受控变量，并处理<code>onChange</code>、<code>onBlur</code>和<code>onSubmit</code>事件。</p>
<p>在本文中，我们将学习表单如何在 Remix 中工作，以及验证它们的不同方法。我们还将学习如何设置自定义验证，以及如何用<a href="https://www.remix-validated-form.io/">重新混合已验证的表单</a>来验证表单。</p>
<p>最后，我们将看看 Remix 提供的定制<code>Form</code>组件，以及 Remix 在处理表单时如何采取与 React 不同的方法。</p>
<h2>混音的形式方法</h2>
<p>Remix 带回了处理表单的传统方法。</p>
<p>Remix 提供了一些函数(名为<code>action</code>和<code>loader</code>，我们可以用它们来执行服务器端操作和访问表单数据。有了这些函数，我们不再需要向前端提供 JavaScript 来提交表单，从而减轻了浏览器的负载。</p>
<p>在其他框架中，我们可能需要使用 JavaScript 进行<code>fetch</code>或<code>axios</code>调用，但是在 Remix 中我们不需要这样做。它有助于保持事情简单。</p>
<h2><code>Form</code>组件</h2>
<p>Remix 提供了一个定制的<code>Form</code>组件，其工作方式与原生 HTML <code>&lt;form&gt;</code>元素相同。与 React 表单不同，在 React 表单中，我们必须设置<code>onChange</code>、<code>onSubmit</code>或<code>onClick</code>事件处理程序，而在使用 Remix 时，我们不需要这样做。此外，我们不需要为表单设置状态，因为我们可以从 web 的<code><a href="https://developer.mozilla.org/en-US/docs/Web/API/FormData/FormData" target="_blank" rel="noopener">formData()</a></code> API 访问表单数据。</p>
<p><code>Form</code>是一个支持 Remix 的增强型 HTML 表单组件。除了与服务器的交互是通过<code>fetch</code>而不是新的文档请求之外，它的行为与普通表单一样，允许组件在表单提交和返回数据时为页面添加更好的用户体验。</p>
<p><code>Form</code>会自动对当前页面路由做一个<code>POST</code>请求。然而，我们也可以为<code>PUT</code>和<code>DELETE</code>请求配置它。需要一个动作方法来处理来自表单的请求。</p>
<h2>在 Remix 中设置表单</h2>
<p>让我们看看混音的基本形式是什么样的:</p>
<pre class="language-javascript hljs">import { Form, useActionData } from "remix";


export async function action({ request }) {
  //here, do something with the form data and return a value  
}

export default function Sign() {
  const data = useActionData(); //we access the return value of the action here

  return (
    &lt;Form
      method="post"
      style={{ fontFamily: "system-ui, sans-serif", lineHeight: "1.4" }}
    &gt;
      &lt;div&gt;
        &lt;label&gt;
          Name: &lt;input name="name" type="text" /&gt;
        &lt;/label&gt;
      &lt;/div&gt;
      &lt;div&gt;
        &lt;label&gt;
          Email: &lt;input name="email" type="email" /&gt;
        &lt;/label&gt;
      &lt;/div&gt;
      &lt;div&gt;
        &lt;label&gt;
          Password: &lt;input name="password" type="password" /&gt;
        &lt;/label&gt;
      &lt;/div&gt;
      &lt;div&gt;
        &lt;label&gt;
          Confirm Password: &lt;input name="confirmPassword" type="password" /&gt;
        &lt;/label&gt;
      &lt;/div&gt;
      &lt;button type="submit"&gt;Create Account&lt;/button&gt;
    &lt;/Form&gt;
  );
}
</pre>
<p>这里，我们使用 Remix 的<code>Form</code>组件和<code>useActionData</code>钩子，我们将在后面使用。当用户提交表单时，Remix 使用 fetch API 自动向服务器发出包含表单数据的 POST 请求。</p>
<p><code>useActionData</code>从路由的动作返回 JSON 解析的数据。它最常用于处理表单验证错误。</p>
<p>动作是当我们提交表单时只在服务器上运行的功能。对<code>POST</code>、<code>PATCH</code>、<code>PUT</code>和<code>DELETE</code>方法调用动作，因为动作意味着修改或变更数据。</p>
<h2>在 Remix 中验证表单</h2>
<p>首先，让我们为表单字段设置验证逻辑:</p>
<pre class="language-javascript hljs">const validateName = (name) =&gt; {
  if (!name) {
    return "Name is required";
  } else if (typeof name !== "string" || name.length &lt; 3) {
    return `Name must be at least 3 characters long`;
  }
};

const validateEmail = (email) =&gt; {
  if (!email) {
    return "Email is Required";
  } else if (!/^[^\<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="b6c5f6">[email protected]</a>]<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="e7cca7">[email protected]</a>[^\<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="423102">[email protected]</a>]+\.[^\<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="770437">[email protected]</a>]+$/.test(email)) {
    return "Invalid emaill address";
  }
};

const validatePassword = (password) =&gt; {
  if (!password) {
    return "Password is required";
  } else if (typeof password !== "string" || password.length &lt; 6) {
    return `Passwords must be at least 6 characters long`;
  }
};

const validateComfirmPassword = (password, confirmPassword) =&gt; {
  if (!confirmPassword) {
    return "Confirm Password is required";
  } else if (password !== confirmPassword) {
    return "Password does not match";
  }

};
</pre>
<p>验证逻辑很简单。我们检查输入字段是否为空，或者它们是否满足某一组要求。如果他们没有通过这些检查，我们将返回错误消息。</p>
<p>接下来，我们为表单设置动作:</p>
<pre class="language-javascript hljs">export const action = async ({ request }) =&gt; {
  const data = Object.fromEntries(await request.formData());

  console.log(data);
  // outputs { name: '', email: '', password: '', confirmPassword: '' }

  const formErrors = {
    name: validateName(data.name),
    email: validateEmail(data.email),
    password: validatePassword(data.password),
    confirmPassword: validateComfirmPassword(
      data.password,
      data.confirmPassword
    ),
  };

  //if there are errors, we return the form errors
  if (Object.values(formErrors).some(Boolean)) return { formErrors };

  //if there are no errors, we return the form data
  return { data };
};
</pre>
<p>这里，我们创建一个<code>formErrors</code>对象，并将验证函数的返回值传递给它们各自的键。</p>
<p>然后，检查是否有错误，返回<code>formErrors</code>，否则我们返回数据。在现实世界的项目中，我们会将用户重定向到另一条路线。</p>
<p>最后，让我们将操作与表单挂钩，并显示错误(如果有错误的话):</p>
<pre class="language-javascript hljs">export default function Sign() {
  const actionData = useActionData();

  return (
    &lt;Form
      method="post"
      style={{ fontFamily: "system-ui, sans-serif", lineHeight: "1.4" }}
    &gt;
      &lt;div&gt;
        &lt;label&gt;
          Name: &lt;input name="name" type="text" /&gt;
        &lt;/label&gt;
        {actionData?.formErrors?.name ? (
          &lt;p style={{ color: "red" }}&gt;{actionData?.formErrors?.name}&lt;/p&gt;
        ) : null}
      &lt;/div&gt;

      &lt;div&gt;
        &lt;label&gt;
          Email: &lt;input name="email" type="email" /&gt;
        &lt;/label&gt;
        {actionData?.formErrors?.email ? (
          &lt;p style={{ color: "red" }}&gt;{actionData?.formErrors?.email}&lt;/p&gt;
        ) : null}
      &lt;/div&gt;

      &lt;div&gt;
        &lt;label&gt;
          Password: &lt;input name="password" type="password" /&gt;
        &lt;/label&gt;
        {actionData?.formErrors?.password ? (
          &lt;p style={{ color: "red" }}&gt;{actionData?.formErrors?.password}&lt;/p&gt;
        ) : null}
      &lt;/div&gt;

      &lt;div&gt;
        &lt;label&gt;
          Confirm Password: &lt;input name="confirmPassword" type="password" /&gt;
        &lt;/label&gt;
        {actionData?.formErrors?.confirmPassword ? (
          &lt;p style={{ color: "red" }}&gt;
            {actionData?.formErrors?.confirmPassword}
          &lt;/p&gt;
        ) : null}
      &lt;/div&gt;

      &lt;button type="submit"&gt;Create Account&lt;/button&gt;
    &lt;/Form&gt;
  );
}
</pre>
<p>这里，我们从<code>actionData</code>访问<code>formErrors</code>对象，并有条件地为每个字段呈现适当的表单错误。</p>
<p>将所有这些放在一起，我们得到了下面的最终代码:</p>
<pre class="language-javascript hljs">import { Form, useActionData } from "remix";

const validateName = (name) =&gt; {
//validation logic here
};

const validateEmail = (email) =&gt; {
//validation logic here
};

const validatePassword = (password) =&gt; {
//validation logic here
};

const validateComfirmPassword = (password, confirmPassword) =&gt; {
//validation logic here
};

export const action = async ({ request }) =&gt; {
  const data = Object.fromEntries(await request.formData());

  const formErrors = {
    name: validateName(data.name),
    email: validateEmail(data.email),
    password: validatePassword(data.password),
    confirmPassword: validateComfirmPassword(
      data.password,
      data.confirmPassword
    ),
  };

  if (Object.values(formErrors).some(Boolean)) return { formErrors };

  return { data };
};

export default function Sign() {
  const actionData = useActionData();

  return (
    &lt;Form
      method="post"
      style={{ fontFamily: "system-ui, sans-serif", lineHeight: "1.4" }}
    &gt;
      &lt;div&gt;
        &lt;label&gt;
          Name: &lt;input name="name" type="text" /&gt;
        &lt;/label&gt;
        {actionData?.formErrors?.name ? (
          &lt;p style={{ color: "red" }}&gt;{actionData?.formErrors?.name}&lt;/p&gt;
        ) : null}
      &lt;/div&gt;

      &lt;div&gt;
        &lt;label&gt;
          Email: &lt;input name="email" type="" /&gt;
        &lt;/label&gt;
        {actionData?.formErrors?.email ? (
          &lt;p style={{ color: "red" }}&gt;{actionData?.formErrors?.email}&lt;/p&gt;
        ) : null}
      &lt;/div&gt;

      &lt;div&gt;
        &lt;label&gt;
          Password: &lt;input name="password" type="password" /&gt;
        &lt;/label&gt;
        {actionData?.formErrors?.password ? (
          &lt;p style={{ color: "red" }}&gt;{actionData?.formErrors?.password}&lt;/p&gt;
        ) : null}
      &lt;/div&gt;

      &lt;div&gt;
        &lt;label&gt;
          Confirm Password: &lt;input name="confirmPassword" type="password" /&gt;
        &lt;/label&gt;
        {actionData?.formErrors?.confirmPassword ? (
          &lt;p style={{ color: "red" }}&gt;
            {actionData?.formErrors?.confirmPassword}
          &lt;/p&gt;
        ) : null}
      &lt;/div&gt;

      &lt;button type="submit"&gt;Create Account&lt;/button&gt;
    &lt;/Form&gt;
  );
}
</pre>
<p>至此，我们已经成功地设置了一个 Remix 表单的自定义验证。虽然这种方法可行，但它不能完全满足所有可能的表单验证需求。</p>
<p>例如，验证逻辑仅在我们提交表单时运行。理想情况下，我们应该在用户输入或关注某个字段时验证表单。我们可以设置这个逻辑，但是编码起来会很繁琐，而且我们还需要解决几个易访问性问题。</p>
<p>幸运的是，我们可以使用一个库来正确处理 Remix 表单的验证。</p>
<h2>使用重新混合验证表单验证重新混合表单</h2>
<p>Remix Validated Form(简称 RVF)提供了一个用于验证 Remix 表单的<code>Form</code>组件和实用程序。</p>
<p>RVF 是验证库不可知的。它有针对<a href="https://blog.logrocket.com/comparing-schema-validation-libraries-zod-vs-yup/" target="_blank" rel="noopener"> Yup 和 Zod </a>的官方适配器，但是我们可以<a href="https://www.remix-validated-form.io/validation-library-support" target="_blank" rel="noopener">创建我们自己的适配器</a>来支持我们选择的验证库。</p>
<p>让我们看看如何使用 RVF。</p>
<p>首先，我们设置一个定制的<code>Input</code>组件，如下所示:</p>
<pre class="language-javascript hljs">import { useField } from "remix-validated-form";

export const Input = ({ name, label }) =&gt; {
  const { error, getInputProps } = useField(name);

  return (
    &lt;div&gt;
      &lt;label htmlFor={name}&gt;
        {label}: {""}
      &lt;/label&gt;
      &lt;input {...getInputProps({ id: name })} /&gt;
      {error &amp;&amp; &lt;p style={{ color: "red" }}&gt;{error}&lt;/p&gt;}
    &lt;/div&gt;
  );
};
</pre>
<p><code>useField</code>钩子返回<code>getInputProps</code>,它是一个 prop-getter，如果存在的话，还会返回一个验证错误消息。我们传入输入的名称和标签，并有条件地呈现错误消息。</p>
<p>接下来，我们设置一个定制的<code>SubmitBtn</code>组件:</p>
<pre class="language-javascript hljs">import { useIsSubmitting } from "remix-validated-form";

export const SubmitBtn = () =&gt; {
  const isSubmitting = useIsSubmitting();

  return (
    &lt;button type="submit" disabled={isSubmitting}&gt;
      {isSubmitting ? "Submitting..." : "Submit"}
    &lt;/button&gt;
  );
};
</pre>
<p><code>useIsSubmitting</code>返回一个<code>isSubmitting</code>布尔值，通知我们提交事件何时发生(当用户提交表单时)。</p>
<p>现在，设置一个<code>validator</code>，RVF 将在后台使用它来验证表单字段。我们将使用 Zod 来创建验证模式:</p>
<pre class="language-javascript hljs">export const validator = withZod(
  z
    .object({
      name: z
        .string()
        .nonempty("Name is required")
        .min(3, "Name must be at least 3 characters long"),
      email: z
        .string()
        .nonempty("Email is required")
        .email("Invalid emaill address"),
      password: z
        .string()
        .nonempty("Password is required")
        .min(6, "Password must be at least 6 characters long"),
      confirmPassword: z.string(),
    })
    .refine(({ password, confirmPassword }) =&gt; password === confirmPassword, {
      message: "Passwords must match",
      path: ["confirmPassword"],
    })
);
</pre>
<p>接下来，我们为表单创建一个动作:</p>
<pre class="language-javascript hljs">export const action = async ({ request }) =&gt; {

  const result = await validator.validate(await request.formData());

  if (result.error) {
    // validationError comes from `remix-validated-form`
    return validationError(result.error);
  }

  return result;
};
</pre>
<p>如果存在错误，这将返回错误，否则返回表单数据。</p>
<p>现在，让我们将<code>Input</code>、<code>SubmitBtn</code>、<code>validator</code>和我们之前创建的动作放在一起，创建一个注册表单:</p>
<pre class="language-javascript hljs">export default function Sign() {
  const actionData = useActionData();
  console.log(actionData);
  return (
    &lt;ValidatedForm
      validator={validator}
      method="post"
      defaultValues={{ name: "Nefe", email: "<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="acc2c9cac9c6cdc1c9dfecd5cdc4c3c382cfc3c1">[email protected]</a>" }}
      style={{ fontFamily: "system-ui, sans-serif", lineHeight: "1.4" }}
    &gt;
      &lt;Input name="name" label="Name" /&gt;
      &lt;Input name="email" label="Email" /&gt;
      &lt;Input name="password" label="Password" /&gt;
      &lt;Input name="confirmPassword" label="Confirm Password" /&gt;
      &lt;SubmitBtn /&gt;
    &lt;/ValidatedForm&gt;
  );
}
</pre>
<p><code>ValidatedForm</code>是 RVF 的主要形体成分。以下是它接受的一些道具:</p>
<ul>
<li><code>defaultValues</code>，一个包含每个表单字段初始值的对象(这是一个可选字段)</li>
<li><code>validator</code>，描述如何验证表单的对象</li>
<li><code>resetAfterSubmit</code>，一个布尔值，在表单成功提交后将表单重置为默认值</li>
</ul>
<p>将所有这些放在一起，我们得到了下面的最终代码:</p>
<pre class="language-javascript hljs">import { useActionData } from "remix";
import { ValidatedForm } from "remix-validated-form";
import { withZod } from "@remix-validated-form/with-zod";
import { SubmitBtn } from "~/components/submitBtn";
import { Input } from "~/components/Input";
import { z } from "zod";

export const validator = withZod(
//validation logic here
);

export const action = async ({ request }) =&gt; {
  const result = await validator.validate(await request.formData());

  if (result.error) {
    return validationError(result.error);
  }

  return result;
};

export default function Sign() {
  const actionData = useActionData();

  return (
    &lt;ValidatedForm
      validator={validator}
      method="post"
      defaultValues={{ name: "Nefe", email: "<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="bed0dbd8dbd4dfd3dbcdfec7dfd6d1d190ddd1d3">[email protected]</a>" }}
      style={{ fontFamily: "system-ui, sans-serif", lineHeight: "1.4" }}
    &gt;
      &lt;Input name="name" label="Name" /&gt;
      &lt;Input name="email" label="Email" /&gt;
      &lt;Input name="password" label="Password" /&gt;
      &lt;Input name="confirmPassword" label="Confirm Password" /&gt;
      &lt;SubmitBtn /&gt;
    &lt;/ValidatedForm&gt;
  );
}
</pre>
<h2>结论</h2>
<p>在本文中，我们学习了一种新的(但实际上是旧的)管理 web 表单的方法。我们已经看到了 Remix 的方法与 React 在处理表单方面的不同。</p>
<p>我们还学习了如何为我们的表单设置自定义验证，以及如何使用 Remix Validated 表单来验证它们。</p><div class="code-block code-block-1">
<div class="blog-plug base-cta"><h2>使用<a class="signup" href="https://lp.logrocket.com/blg/signup" target="_blank" rel="noopener noreferrer"> LogRocket </a>消除传统错误报告的干扰</h2>
<a href="https://lp.logrocket.com/blg/signup" class="signup" target="_blank" rel="noopener noreferrer"><img class="alignnone size-full wp-image-46 jetpack-lazy-image" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/><noscript><img data-lazy-fallback="1" class="alignnone size-full wp-image-46" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/></noscript></a>
<p><a href="https://lp.logrocket.com/blg/signup" target="_blank" rel="noopener noreferrer"> LogRocket </a>是一个数字体验分析解决方案，它可以保护您免受数百个假阳性错误警报的影响，只针对几个真正重要的项目。LogRocket 会告诉您应用程序中实际影响用户的最具影响力的 bug 和 UX 问题。</p>
<p>然后，使用具有深层技术遥测的会话重放来确切地查看用户看到了什么以及是什么导致了问题，就像你在他们身后看一样。</p>
<p>LogRocket 自动聚合客户端错误、JS 异常、前端性能指标和用户交互。然后 LogRocket 使用机器学习来告诉你哪些问题正在影响大多数用户，并提供你需要修复它的上下文。</p>
<p>关注重要的 bug—<a class="signup" href="https://lp.logrocket.com/blg/signup-issue-free" target="_blank" rel="noopener noreferrer">今天就试试 LogRocket】。</a></p></div></div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
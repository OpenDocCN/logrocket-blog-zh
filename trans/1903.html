<html>
<head>
<title>Implementing 3D Secure in Stripe - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>在 Stripe - LogRocket 博客中实现 3D 安全</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/implementing-3d-secure-in-stripe/#0001-01-01">https://blog.logrocket.com/implementing-3d-secure-in-stripe/#0001-01-01</a></blockquote><div><article class="article-post">
<p>在我们生活的世界中，我们与许多在线服务进行交互，并通过在线支付网关向这些服务进行支付。作为开发者，我们有责任以一种对用户和收款方都安全的方式集成这些支付网关。</p>
<p>在本文中，我们将介绍如何使用 Stripe 实现在线支付的 3D 安全保护。</p>
<h2>什么是 3D 安全？</h2>
<p>3D Secure 是 Stripe 在实际处理支付之前验证用户身份的一种方式。当用户输入他的卡的详细信息时，他会得到一个弹出或重定向的提示来验证支付。</p>
<p>它通常通过 OTP 来验证身份，但也可能取决于发行该卡的银行。在某些国家/地区，3D Secure 不是必需的，但在印度等国家/地区，3D Secure 是必需的。</p>
<p>你可以在你的 Stripe 帐户中设置你的雷达规则以要求 3D 安全认证，但是如果你的支付表单中没有代码来使 3D 安全弹出窗口工作，那么这是没有用的。</p>
<p>在本文中，我们将使用 NodeJS、React 和 Stripe 创建一个简单的捐赠 web 应用程序。我们将讨论以下主题:</p>
<ul>
<li>设置条带并获取 API 密钥</li>
<li>设置 NodeJS 后端和 React 前端</li>
<li>在前端创建一个结帐表单</li>
<li>以通常的方式处理付款</li>
<li>如果需要身份验证，使用 3D Secure 作为后备方案</li>
<li>确认付款</li>
<li>添加定期付款(订阅)</li>
<li>测试我们的集成</li>
</ul>
<h2>你需要什么？</h2>
<ul>
<li>代码编辑器——我更喜欢使用 VSCode，但是你可以使用任何你选择的代码编辑器</li>
<li>已安装的节点</li>
<li>一个<a href="https://stripe.com" target="_blank" rel="noopener">条纹</a>账户</li>
<li>命令行的基本知识</li>
<li>ReactJS 和 NodeJS 的基本知识</li>
</ul>
<h2>我们开始吧！</h2>
<p>首先，我们将在后端工作。我更喜欢“API 优先的方法”,这意味着你首先创建一个 API，然后处理前端的其余部分。</p>
<p>我们将使用 NodeJS、Express 和 Stripe 包来创建我们的后端，以获取与支付相关的内容。</p>
<h3>启动后端</h3>
<p>让我们创建我们的后端。为此，请打开终端/命令提示符并键入以下命令，在所需的文件夹中启动 NodeJS 项目:</p>
<pre>npm init -y
</pre>
<p>运行该命令将在文件夹中生成一个<code>package.json</code>文件。</p>
<p>现在，使用以下命令打开文件夹中的 VSCode，以便我们可以开始编辑:</p>
<pre>code .
</pre>
<p>现在开放了 VSCode，可以使用集成终端了，生活会更轻松。只需在 Windows 上点击<strong> Ctrl + J </strong>或在 Mac 上点击<strong> Command + J </strong>即可在 VSCode 中打开终端。</p>
<p>让我们安装几个软件包，这将有助于我们进一步的项目。在终端中键入以下命令，我们将会看到这些包会做什么:</p>
<pre>npm install express cors stripe dotenv
</pre>
<p>这些是正在安装的软件包:</p>
<ul>
<li><code>Express</code>用于轻松创建 HTTP 服务器</li>
<li>帮助我们消除客户应用程序中的交叉起源错误</li>
<li><code>Stripe</code>是到条带的实际连接。我们可以获取付款细节，并使用这个包创建付款</li>
<li><code>Dotenv</code>帮助我们启用环境变量来存储敏感数据</li>
</ul>
<h3>向环境变量添加条带密钥</h3>
<p>在进一步讨论这个支付系统之前，让我们在环境变量中设置 Stripe 密钥。</p>
<p>所有秘密的 API 密钥和凭证都必须存储在环境变量中，以便在实际代码被盗时数据不会被盗。</p>
<p>要获取您的条纹密钥，请打开您的<a href="https://dashboard.stripe.com/login" target="_blank" rel="noopener">条纹仪表板</a>，您将看到类似下图的侧边菜单:</p>
<p><img data-attachment-id="56422" data-permalink="https://blog.logrocket.com/implementing-3d-secure-in-stripe/stripe-dashboard/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2021/06/Stripe-dashboard.png" data-orig-size="542,922" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Stripe-dashboard" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2021/06/Stripe-dashboard-176x300.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2021/06/Stripe-dashboard.png" decoding="async" class="size-full wp-image-56422 aligncenter jetpack-lazy-image" src="../Images/7bb8a917ed23e233397adb5626ca5179.png" alt="Screenshot of Stripe dashboard" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2021/06/Stripe-dashboard.png 542w, https://blog.logrocket.com/wp-content/uploads/2021/06/Stripe-dashboard-176x300.png 176w" data-lazy-sizes="(max-width: 542px) 100vw, 542px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2021/06/Stripe-dashboard.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2021/06/Stripe-dashboard.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="56422" data-permalink="https://blog.logrocket.com/implementing-3d-secure-in-stripe/stripe-dashboard/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2021/06/Stripe-dashboard.png" data-orig-size="542,922" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Stripe-dashboard" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2021/06/Stripe-dashboard-176x300.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2021/06/Stripe-dashboard.png" decoding="async" loading="lazy" class="size-full wp-image-56422 aligncenter" src="../Images/7bb8a917ed23e233397adb5626ca5179.png" alt="Screenshot of Stripe dashboard" srcset="https://blog.logrocket.com/wp-content/uploads/2021/06/Stripe-dashboard.png 542w, https://blog.logrocket.com/wp-content/uploads/2021/06/Stripe-dashboard-176x300.png 176w" sizes="(max-width: 542px) 100vw, 542px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2021/06/Stripe-dashboard.png"/></noscript>
<p>现在，点击<strong>开发者</strong>，然后点击<strong> API 键</strong>。在那里你应该可以看到你的条纹可公开密钥。</p>
<p>现在，我们需要秘钥。请注意，您不应该与任何人共享您的密钥。共享您的密钥将允许其他人访问您的 Stripe 帐户。</p>
<p>另一方面，可发布密钥是我们在前端使用的密钥，是否有人可以访问并不重要，因为它是公开的。</p>
<p>现在，复制您的条带密钥并转到 VSCode，创建一个名为<code>.env</code>的新文件，并将密钥粘贴为以下格式:</p>
<pre>STRIPE_SECRET_KEY=(secret key here)
</pre>
<p><code>.env</code>文件用于存储环境变量。<code>dotenv</code>包将搜索这个文件来加载环境变量。既然<code>.env</code>文件已经完成，我们不需要在本教程中再次接触环境变量。</p>
<h3>安装 Nodemon</h3>
<p>按照教程操作时，您可能需要多次重新启动服务器。为了避免这种情况，我们可以安装一个名为<code>nodemon</code>的全局包，它会在我们保存文件时自动重启我们的服务器。<a href="https://blog.logrocket.com/nodemon-tutorial-automatically-restart-node-js-apps-with-nodemon/">你可以在这里</a>阅读更多关于 Nodemon 的内容。</p>
<p>在终端中键入以下命令:</p>
<pre>npm install -g nodemon
</pre>
<p>如果需要，使用<code>sudo</code>,因为 Nodemon 应该是全局安装的，所以它需要 root 权限。</p>
<h3>设置 Express 服务器</h3>
<p>让我们创建将运行我们的服务器的文件。我们可以将其命名为<code>index.js</code>,因为在<code>package.json</code>文件中它被默认指定为<code>main</code>。如果你愿意，你可以改变名字，但是在本教程中我们将坚持使用<code>index.js</code>。</p>
<p>让我们首先创建一个快速服务器和一个简单的路由:</p>
<pre>const express = require("express");
const app = express();
const PORT = process.env.PORT || 5000;
const cors = require("cors");

app.use(cors());
app.use(express.json());
app.use(express.urlencoded({ extended: true }));

app.get("/", (req, res) =&gt; res.json({ status: 200, message: "API Works" }));

app.listen(PORT, () =&gt; console.log(`Server running on port ${PORT}`));
</pre>
<p>这创建了一个简单的 Express 服务器，有一个 home route，它简单地返回一个 JSON，说明 API 工作了。</p>
<p>在这里，我们将端口设置为<code>process.env.PORT || 5000</code>,因为如果您决定将此服务器部署到 Heroku 这样的服务，他们将在自己的端口上托管它，这些端口存储在他们的环境变量中，所以我们让他们决定端口。如果<code>process.env.PORT</code>未定义，则 app 在本地运行，将使用端口 5000。</p>
<p>我们使用<code>cors</code>包作为一个快速中间件，这样客户端应用程序可以正确地与我们的服务器交互，而不会出现任何跨源错误。您可以根据需要配置<code>cors</code>包，但是对于本教程，我们将只允许任何流量。</p>
<p>在中间件部分，我们还允许 JSON 和 url 编码的数据通过请求体，Express 会自动为我们解析它。</p>
<p>现在，如果您转到 Postman 或任何其他 HTTP 客户端并在<code><a href="http://localhost:5000" rel="nofollow">http://localhost:5000</a></code>上执行 GET 请求，您将获得以下 JSON 响应:</p>
<pre>{
  "status": 200,
  "message": "API Works"
}
</pre>
<p>如果您看到此消息，您的 Express 服务器设置正确。现在让我们进入下一步。</p>
<h3>设置<code>dotenv</code></h3>
<p>现在让我们配置<code>dotenv</code>包，以便它可以正确识别来自<code>.env</code>文件的环境变量。在顶部编写以下代码:</p>
<pre>require("dotenv").config();
</pre>
<h3>初始化条带</h3>
<p>现在让我们建立到 Stripe 的连接。在之前的教程中，我们已经安装了一个名为<code>stripe</code>的包，它将帮助我们与 Stripe 进行通信。但首先，我们需要向它提供我们的 Stripe 密钥，以便它可以与我们的 Stripe 帐户进行交互。</p>
<p>在我们之前创建的文件的顶部包含以下代码片段:</p>
<pre>const Stripe = require("stripe");
const stripe = Stripe(process.env.STRIPE_SECRET_KEY);
</pre>
<p>前面我们处理了环境变量，这里是我们使用存储的<code>STRIPE_SECRET_KEY</code>的地方。现在，Stripe 可以识别您的帐户，我们可以与 Stripe 进一步互动。</p>
<p>整个代码现在应该显示如下内容:</p>
<pre>require("dotenv").config();
const express = require("express");
const app = express();
const PORT = process.env.PORT || 5000;
const cors = require("cors");
const Stripe = require("stripe");
const stripe = Stripe(process.env.STRIPE_SECRET_KEY);

app.use(cors());
app.use(express.json());
app.use(express.urlencoded({ extended: true }));

app.get("/", (req, res) =&gt; res.json({ status: 200, message: "API Works" }));

app.listen(PORT, () =&gt; console.log(`Server running on port ${PORT}`));
</pre>
<h3>收集支付数据</h3>
<p>让我们想一想，我们需要从用户那里收集哪些数据来启动支付。为了本教程，我们将保持简单:</p>
<ul>
<li>电子邮件地址</li>
<li>付款金额</li>
<li><code>paymentMethod</code>，由前端条纹生成的 ID，代表一张特定的卡</li>
<li>订阅，不是<code>onetime</code>就是<code>monthly</code>。如果订阅设置为<code>monthly</code>，我们将设置定期付款</li>
</ul>
<p>由于我们正在“创建”付款，我们将使用 POST 请求。使用 POST 请求的另一个原因是，我们发送给服务器的数据不像 GET 请求那样显示在 URL 本身中。另外，GET 请求可以通过浏览器直接访问，这不是我们想要的。</p>
<p>因此，让我们创建一个 POST 请求监听器并收集数据:</p>
<pre>app.post("/donate", async (req, res) =&gt; {
  try {
    let { email, amount, paymentMethod, subscription } = req.body;
    if (!email || !amount || !paymentMethod || !subscription) 
      return res.status(400).json({ status: 400, message: "All fields are required!" });
    amount = parseInt(amount);

    if (subscription === "onetime") {
      // One time payment code here
    }

    if (subscription === "monthly") {
      // Recurring payment code here
    }

    res.status(400).json({ status: 400, message: "Invalid type" });
  } catch(err) {
    console.error(err);
    res.status(500).json({ status: 200, message: "Internal server error" });
  }
});
</pre>
<p>在上面的代码中，我们执行了以下操作:</p>
<ul>
<li>当然是在<code>/donate</code>路线上设置一个 POST 监听器</li>
<li>从用户处收集<code>email</code>、<code>amount</code>和<code>paymentMethod</code></li>
<li>验证字段，以便如果任何字段缺失，将会发送一条错误消息</li>
<li>有时，客户端应用程序可能会将<code>amount</code>作为字符串发送，在这种情况下，我们使用<code>parseInt()</code>函数将金额转换为整数值</li>
</ul>
<p>首先，我们将处理一次性付款。</p>
<h3>尝试简单的 HTTP 支付</h3>
<p>我们仅在需要时使用 3D secure，或者根据条纹仪表板中的雷达规则使用 3D secure。我们必须在使用 3D Secure 之前尝试 HTTP 支付，因为有些卡不支持 3D Secure。</p>
<p>现在该联系条纹了:</p>
<pre>const paymentIntent = await stripe.paymentIntents.create({
  amount: Math.round(amount * 100),
  currency: "INR",
  receipt_email: email,
  description: "Payment for donation",
  payment_method: paymentMethod,
  confirm: true
});
</pre>
<p>这将立即启动支付。<code>confirm</code>字段告诉 Stripe 在收到付款后立即确认。如果您不指定<code>confirm</code>，它不会向用户收费，并且您需要在再次请求条带化之前手动确认订单。</p>
<p>在<code>amount</code>字段中，指定辅助货币单位(例如，USD 是美分，INR 是 paisa)。<code>Math.round()</code>这里用来去掉任何小数，因为 Stripe 不喜欢小数。</p>
<p>根据您的 Stripe 帐户位置指定货币。对我来说是印度，所以我用<code>INR</code>作为货币。</p>
<p>一旦付款完成，收据将发送到指定的电子邮件。在这种情况下，我们提到我们从用户那里收集的电子邮件。</p>
<p>现在让我们检查一下这个简单的 HTTP 支付是否成功。为此，我们可以检查<code>paymentIntent</code>的状态属性:</p>
<pre>if (paymentIntent.status === "succeeded") {
  // Payment successful!
  return res.json({
    status: 200,
    message: "Payment Successful!",
    id: paymentIntent.id
  });
}
&gt;</pre>
<p>简单的 HTTP 支付就这么多。这里，<code>paymentIntent.id</code>可以作为支付 ID。我们使用<code>return</code>立即停止进一步的执行，这样就不会出现意外的错误。</p>
<p>但是，如果状态不是<code>succeeded</code>而是<code>requires_action</code>，则意味着需要 3D 安全。下面是我们如何应对 3D 安全:</p>
<ul>
<li>我们将获得付款意向的<code>client_secret</code></li>
<li>我们将把<code>client_secret</code>发送到前端</li>
<li>前端将使用 3D secure 通过<code>client_secret</code>进行认证</li>
<li>我们将在后端制定一个路线，以再次检查支付状态</li>
</ul>
<h3>获取<code>client_secret</code>并发送到前端</h3>
<p>让我们检查我们创建的支付意图是否需要 3D secure，然后向客户发送密码:</p>
<pre>if (paymentIntent.status === "requires_action") {
  return res.json({ 
    status: 200,
    message: "3D secure required",
    actionRequired: true,
    clientSecret: paymentIntent.client_secret
  });
}
</pre>
<p>这样，我们将客户端机密发送到前端。一旦我们完成了后端部分，我们将在本文的后面处理前端。</p>
<p>最后，如果状态既不是<code>succeeded</code>也不是<code>requires_action</code>，我们将通知用户支付失败。我们在之前的案例中使用了<code>return</code>，所以我们不需要使用<code>else</code>:</p>
<pre>return res.status(400).json({
  status: 400,
  message: "Payment failed!"
});
</pre>
<h2>处理经常性付款</h2>
<p>我们不会在经常性付款中直接使用付款意向。创建定期付款的流程略有不同:</p>
<ul>
<li>首先，我们创建一个价格，这将是我们的捐赠金额</li>
<li>接下来，我们用用户的电子邮件创建一个 Stripe 客户</li>
<li>然后我们创建一个订阅并向客户收取费用。如果需要身份验证，Stripe 将每月向客户发送一封电子邮件，要求付款</li>
<li>最后，我们让用户在我们的网站上支付第一张发票</li>
</ul>
<p>之前，我们为<code>monthly</code>订阅类型创建了一个<code>if</code>语句。所有的定期支付代码都在里面。</p>
<h3>创建价格</h3>
<p>让我们进入第一步，创建价格:</p>
<pre>const price = await stripe.prices.create({
  unit_amount: Math.round(amount * 100),
  recurring: { interval: "month" },
  currency: "INR",
  product_data: {
    name: "Recurring donation"
  }
});
</pre>
<p>这里的<code>unit_amount</code>是实际数量——我们已经讨论过如何将其发送到条带。</p>
<p>我们还为<code>recurring</code>提供了一个<code>interval</code>。在这种情况下，我们将其设置为<code>month</code>。<code>product_data</code>对象包含一些关于产品本身的信息。在这种情况下，它只是一个捐赠，所以我们只指定它。</p>
<h3>创建客户</h3>
<p>现在，让我们创建客户:</p>
<pre>const customer = await stripe.customers.create({
  email, 
  description: "Donation customer",
  payment_method: paymentMethod,
  invoice_settings: {
    default_payment_method: paymentMethod
  }
});
</pre>
<p>在这里，我们指定了<code>paymentMethod</code>，这样我们就可以在需要时立即向客户收费，而不会有任何麻烦。</p>
<h3>创建订阅</h3>
<p>这是客户实际收费的地方。当启动订阅时，会生成一张用户可以支付的发票，但我们会让用户立即支付发票以开始订阅。</p>
<p>我们可以从订阅中获取<code>paymentIntent</code>,然后我们可以像以前一样进行检查:</p>
<pre>const subscribe = await stripe.subscriptions.create({
  customer: customer.id,
  items: [{ price: price.id }],
  expand: ["latest_invoice.payment_intent"]
});
</pre>
<p>我们传入客户 ID 和价格，将所有东西连接在一起。此外，为了访问最新发票的<code>paymentIntent</code>，我们使用了<code>expand</code>属性。</p>
<p>当我们尝试创建订阅时，Stripe 已经尝试了基于 HTTP 的支付。现在，我们需要像以前一样关注 3D 安全支付:</p>
<pre>if (
  subscribe.latest_invoice.payment_intent.status === "requires_action"
) {
  // proceed to 3ds
  return res.status(200).json({
    status: 200,
    message: "3D Secure required",
    actionRequired: true,
    clientSecret: subscribe.latest_invoice.payment_intent.client_secret,
    id: subscribe.latest_invoice.payment_intent.id,
  });
}
if (subscribe.latest_invoice.payment_intent.status === "succeeded") {
  return res.json({
    status: 200,
    message: "Payment successful!",
  });
}
return res.status(400).json({ status: 400, message: "Payment failed!" });
</pre>
<p>这和我们一次性付款的方法一样。我们已经完成了后端的支付路线。</p>
<p>还有一条路要走——检查路。在前端进行身份验证后，我们需要一个路由来检查和验证后端的状态:</p>
<pre>app.get("/check/:id", async (req, res) =&gt; {
  try {
    const id = req.params.id;
    const paymentIntent = await stripe.paymentIntents.retrieve(id);
    if (paymentIntent?.status === "succeeded") {
      return res.json({
        status: 200,
        message: "Payment successful!",
        id,
      });
    }
    res
      .status(400)
      .json({
        status: 200,
        message: "Payment failed! Please try again later.",
      });
  } catch (err) {
    console.error(err);
    res.status(500).json({ status: 500, message: "Internal server error" });
  }
});
</pre>
<p>这一次我们使用 GET 请求并检查支付是否真正完成。如果你不想使用 webhook，而想马上为用户提供虚拟服务，这是可以做到的。</p>
<p>这将是你的应用程序知道支付成功和用户可以使用的地方。但在这种情况下，这是一个捐赠网站，我们不需要在这里做任何特殊的事情。</p>
<h3>完成<code>index.js</code>代码</h3>
<p>您的<code>index.js</code>文件现在应该是这样的:</p>
<pre>require("dotenv").config();
const express = require("express");
const app = express();
const PORT = process.env.PORT || 5000;
const cors = require("cors");
const Stripe = require("stripe");
const stripe = Stripe(process.env.STRIPE_SECRET_KEY);

app.use(cors());
app.use(express.json());
app.use(express.urlencoded({ extended: true }));

app.get("/", (req, res) =&gt; res.json({ status: 200, message: "API Works" }));

app.post("/donate", async (req, res) =&gt; {
  try {
    let { email, amount, paymentMethod, subscription } = req.body;
    if (!email || !amount || !paymentMethod || !subscription) 
      return res.status(400).json({ status: 400, message: "All fields are required!" });
    amount = parseInt(amount);

    if (subscription === "onetime") {
      // One time payment code here
      const paymentIntent = await stripe.paymentIntents.create({
        amount: Math.round(amount * 100),
        currency: "INR",
        receipt_email: email,
        description: "Payment for donation",
        payment_method: paymentMethod,
        confirm: true
      });
      if (paymentIntent.status === "succeeded") {
        // Payment successful!
        return res.json({
          status: 200,
          message: "Payment Successful!",
          id: paymentIntent.id
        });
      }
      if (paymentIntent.status === "requires_action") {
        return res.json({ 
          status: 200,
          message: "3D secure required",
          actionRequired: true,
          clientSecret: paymentIntent.client_secret
        });
      }
      return res.status(400).json({
        status: 400,
        message: "Payment failed!"
      });
    }

    if (subscription === "monthly") {
      // Recurring payment code here
      const price = await stripe.prices.create({
        unit_amount: Math.round(amount * 100),
        recurring: { interval: "month" },
        currency: "INR",
        product_data: {
          name: "Recurring donation"
        }
      });

      const customer = await stripe.customers.create({
        email, 
        description: "Donation customer",
        payment_method: paymentMethod,
        invoice_settings: {
          default_payment_method: paymentMethod
        }
      });

      const subscribe = await stripe.subscriptions.create({
        customer: customer.id,
        items: [{ price: price.id }],
        expand: ["latest_invoice.payment_intent"]
      });

      if (
        subscribe.latest_invoice.payment_intent.status === "requires_action"
      ) {
        // proceed to 3ds
        return res.status(200).json({
          status: 200,
          message: "3D Secure required",
          actionRequired: true,
          clientSecret: subscribe.latest_invoice.payment_intent.client_secret,
          id: subscribe.latest_invoice.payment_intent.id,
        });
      }
      if (subscribe.latest_invoice.payment_intent.status === "succeeded") {
        return res.json({
          status: 200,
          message: "Payment successful!",
        });
      }
      return res.status(400).json({ status: 400, message: "Payment failed!" });
    }

    res.status(400).json({ status: 400, message: "Invalid type" });
  } catch(err) {
    console.error(err);
    res.status(500).json({ status: 200, message: "Internal server error" });
  }
});

app.listen(PORT, () =&gt; console.log(`Server running on port ${PORT}`));
</pre>
<h2>创建前端</h2>
<p>现在让我们转到前端，了解如何触发 3D 安全认证以及如何发起支付。</p>
<p>我们不会在前端做任何花哨的造型。让我们保持简单，把重点放在支付方面的事情。</p>
<p>我们将在前端使用 React。创建一个名为<code>frontend</code>的新文件夹，在该文件夹中打开终端，并键入以下命令:</p>
<pre>npx create-react-app .
</pre>
<p><code>.</code>指定我们正在当前文件夹中创建一个 React 应用程序。</p>
<p>现在让我们安装一些制作这个应用程序时需要的包:</p>
<pre>npm install axios @stripe/react-stripe-js @stripe/stripe-js
</pre>
<ul>
<li><code>axios</code>是一个库，可以轻松地发出 HTTP 请求，而不会干扰<code>fetch</code> API</li>
<li>这两个条带包对于创建<a href="https://stripe.com/payments/elements" target="_blank" rel="noopener">条带元素</a>和与条带通信都很有用</li>
</ul>
<p>现在，使用以下命令在 React 应用程序中打开 VSCode:</p>
<pre>code .
</pre>
<p>进入集成终端后，键入以下命令启动 React 应用程序:</p>
<pre>npm start
</pre>
<p>应该会打开一个新的浏览器选项卡，您应该会看到以下屏幕:</p>
<p><img data-attachment-id="56424" data-permalink="https://blog.logrocket.com/implementing-3d-secure-in-stripe/blank-react-app/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2021/06/Blank-React-app.png" data-orig-size="730,406" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Blank-React-app" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2021/06/Blank-React-app-300x167.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2021/06/Blank-React-app.png" decoding="async" class="size-full wp-image-56424 aligncenter jetpack-lazy-image" src="../Images/fff4e21be6a9d90261894c129534975b.png" alt="Screenshot of blank React app" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2021/06/Blank-React-app.png 730w, https://blog.logrocket.com/wp-content/uploads/2021/06/Blank-React-app-300x167.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2021/06/Blank-React-app.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2021/06/Blank-React-app.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="56424" data-permalink="https://blog.logrocket.com/implementing-3d-secure-in-stripe/blank-react-app/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2021/06/Blank-React-app.png" data-orig-size="730,406" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Blank-React-app" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2021/06/Blank-React-app-300x167.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2021/06/Blank-React-app.png" decoding="async" loading="lazy" class="size-full wp-image-56424 aligncenter" src="../Images/fff4e21be6a9d90261894c129534975b.png" alt="Screenshot of blank React app" srcset="https://blog.logrocket.com/wp-content/uploads/2021/06/Blank-React-app.png 730w, https://blog.logrocket.com/wp-content/uploads/2021/06/Blank-React-app-300x167.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2021/06/Blank-React-app.png"/></noscript>
<p>如果您看到这个屏幕，您已经成功地启动了一个 React 应用程序。现在让我们做一些清理工作。</p>
<p>删除<code>src</code>中以下我们不需要的文件:</p>
<ul>
<li><code>App.test.js</code></li>
<li><code>setupTests.js</code></li>
<li><code>logo.svg</code></li>
</ul>
<p>一旦你删除这些文件，你会看到一个错误弹出。那是因为我们打碎了一些东西。</p>
<p>转到<code>App.js</code>并删除顶部的徽标导入和第一个<code>div</code>下的内容。移除<code>App.css</code>中的一切。</p>
<p>您的<code>App.js</code>应该是这样的:</p>
<pre>import "./App.css";
function App() {
  return &lt;div className="app"&gt;&lt;/div&gt;;
}
export default App;
</pre>
<p>接下来，让我们创建一个名为<code>Checkout</code>的新组件。在<code>src</code>中创建两个文件:<code>Checkout.js</code>和<code>Checkout.css</code>。</p>
<p>由于我们在本教程中没有关注样式，所以我提供了一个 CSS 文件的内容，但是我们不会在<code>Checkout.css</code>中讲述实际发生的事情:</p>
<pre>.checkout {
  display: flex;
  align-items: center;
  justify-content: center;
  height: 100vh;
  width: 100%;
}
.checkout__container {
  background-color: #f5f5f5;
  padding: 20px;
  width: 25%;
  display: flex;
  flex-direction: column;
}
.checkout__textBox {
  padding: 10px;
  font-size: 18px;
  margin-bottom: 10px;
}
.checkout__radio {
  margin-bottom: 10px;
}
.checkout__btn {
  margin-top: 10px;
  padding: 10px;
  font-size: 18px;
  border: none;
  background-color: #0984e3;
  color: white;
}
</pre>
<p>现在，打开<code>Checkout.js</code>并创建一个 React 功能组件:</p>
<pre>import React from "react";
function Checkout() {
  return &lt;div className="checkout"&gt;&lt;/div&gt;;
}
export default Checkout;
</pre>
<p>现在让我们导入这个组件并在<code>App.js</code>中使用它:</p>
<pre>import { Elements } from "@stripe/react-stripe-js";
import { loadStripe } from "@stripe/stripe-js";
import "./App.css";
import Checkout from "./Checkout";
const stripePromise = loadStripe("(publishable key here)");
function App() {
  return (
    &lt;div className="app"&gt;
      &lt;Elements stripe={stripePromise}&gt;
        &lt;Checkout /&gt;
      &lt;/Elements&gt;
    &lt;/div&gt;
  );
}
export default App;
</pre>
<p>我们将我们的<code>Checkout</code>组件包装在 Stripe 提供给我们的<code>Elements</code>中。该组件充当我们需要的所有条带元素和服务的包装器。</p>
<p>我们使用<code>loadStripe()</code>函数并传入可发布的密钥，然后传入<code>stripePromise</code>作为<code>Elements</code>组件中的<code>stripe</code>作为道具。</p>
<p>现在让我们转到<code>Checkout.js</code>并制作表单的基本布局:</p>
<pre>import { CardElement } from "@stripe/react-stripe-js";
import React, { useState } from "react";
function Checkout() {
  const [email, setEmail] = useState("");
  const [amount, setAmount] = useState("");
  const [subscription, setSubscription] = useState("onetime");
  const handleSubmit = async (e) =&gt; {
    try {
      e.preventDefault();
    } catch (error) {
      console.error(error);
      alert("Payment failed!");
    }
  };
  return (
    &lt;div className="checkout"&gt;
      &lt;form className="checkout__container" onSubmit={handleSubmit}&gt;
        &lt;input
          type="email"
          value={email}
          className="checkout__textBox"
          onChange={(e) =&gt; setEmail(e.target.value)}
          placeholder="E-mail Address"
        /&gt;
        &lt;input
          type="number"
          value={amount}
          className="checkout__textBox"
          onChange={(e) =&gt; setAmount(e.target.value)}
          placeholder="Amount"
        /&gt;
        &lt;div className="checkout__radio"&gt;
          &lt;input
            type="radio"
            onChange={(e) =&gt; setSubscription("onetime")}
            checked={subscription === "onetime"}
          /&gt;
          Onetime
        &lt;/div&gt;
        &lt;div className="checkout__radio"&gt;
          &lt;input
            type="radio"
            onChange={(e) =&gt; setSubscription("monthly")}
            checked={subscription === "monthly"}
          /&gt;
          Monthly
        &lt;/div&gt;
        &lt;CardElement
          options={{
            style: {
              base: {
                fontSize: "16px",
                color: "#424770",
                "::placeholder": {
                  color: "#aab7c4",
                },
              },
              invalid: {
                color: "#9e2146",
              },
            },
          }}
        /&gt;
        &lt;button className="checkout__btn" type="submit"&gt;
          Donate
        &lt;/button&gt;
      &lt;/form&gt;
    &lt;/div&gt;
  );
}
export default Checkout;
</pre>
<p>我们创建了一个基本的形式，要求电子邮件和所需的金额。<code>CardElement</code>组件用于显示一个小元素，供用户输入卡的详细信息。</p>
<p>现在让我们来处理用户提交表单时的事件:</p>
<pre>const handleSubmit = async (e) =&gt; {
  try {
    e.preventDefault();
    if (!elements || !stripe) return;
    const cardElement = elements.getElement(CardElement);
    const { error, paymentMethod } = await stripe.createPaymentMethod({
      type: "card",
      card: cardElement,
    });
  } catch (error) {
    console.error(error);
    alert("Payment failed!");
  }
};
</pre>
<p>首先，我们将检查条带和元素是否已加载。如果没有，那么表单将什么也不做。如何在不加载 Stripe 的情况下处理支付？</p>
<p>然后我们到了<code>cardElement</code>。它太容易被发现的原因是因为在整个表单中只能有一个<code>CardElement</code>。</p>
<p>接下来，我们从在<code>cardElement</code>中输入的细节创建一个<code>paymentMethod</code>，它将返回一个包含付款方式 ID 的对象，这是我们在后端需要的。</p>
<p>现在让我们打我们的后端和处理付款。</p>
<p>首先让我们导入<code>axios</code>:</p>
<pre>import axios from "axios"
</pre>
<p>然后，让我们向后端发出请求，提供有关付款的信息:</p>
<pre>const res = await axios.post("http://localhost:5000/donate", {
  amount,
  email,
  subscription,
  stripeToken: paymentMethod.id,
});
</pre>
<p>如果请求中有错误或者响应代码指向错误，代码将停止执行并转到<code>catch</code>块来处理错误。</p>
<p>现在后端将尝试执行简单的 HTTP 支付，我们将得到一个响应。如果我们需要 3D 安全，<code>actionRequired</code>将会是<code>true</code>:</p>
<pre>if (res.data.actionRequired) {
  // We perform 3D Secure authentication
  const { paymentIntent, error } = await stripe.confirmCardPayment(
    res.data.clientSecret
  );
  if (error) return alert("Error in payment, please try again later");
  if (paymentIntent.status === "succeeded")
    return alert(`Payment successful, payment ID - ${res.data.id}`);
  const res2 = await axios.get(`http://localhost:5000/check/${res.data.id}`);
  alert(`Payment successful, payment ID - ${res.data.id}`);
} else {
  // Simple HTTP Payment was successful
  alert(`Payment successful, payment ID - ${res.data.id}`);
}
</pre>
<p>这里，我们检查<code>actionRequired</code>是否为<code>true</code>。如果是，我们需要触发一个 3D 安全认证弹出窗口。我们通过将从服务器获得的 T2 传递给来自 T4 的 T3 函数来实现。</p>
<p>然后，我们取回<code>paymentIntent</code>,并通过将付款意向 ID 发送到我们的 Express 服务器的<code>/check</code>路线来检查来自我们的服务器的付款。如果支付成功，该路径返回 200 状态代码，否则我们的代码将通过前面解释的<code>catch</code>块。</p>
<p>这就是触发 3D 安全的方法。下面是<code>Checkout.js</code>的完整代码:</p>
<pre>import { CardElement } from "@stripe/react-stripe-js";
import React, { useState } from "react";
import axios from "axios";

function Checkout() {
  const [email, setEmail] = useState("");
  const [amount, setAmount] = useState("");
  const [subscription, setSubscription] = useState("onetime");
  const handleSubmit = async (e) =&gt; {
    try {
      e.preventDefault();
      if (!elements || !stripe) return;
      const cardElement = elements.getElement(CardElement);
      const { error, paymentMethod } = await stripe.createPaymentMethod({
        type: "card",
        card: cardElement,
      });
      const res = await axios.post("http://localhost:5000/donate", {
        amount,
        email,
        subscription,
        stripeToken: paymentMethod.id,
      });
      if (res.data.actionRequired) {
        // We perform 3D Secure authentication
        const { paymentIntent, error } = await stripe.confirmCardPayment(
          res.data.clientSecret
        );
        if (error) return alert("Error in payment, please try again later");
        if (paymentIntent.status === "succeeded")
          return alert(`Payment successful, payment ID - ${res.data.id}`);
        const res2 = await axios.get(`http://localhost:5000/check/${res.data.id}`);
        alert(`Payment successful, payment ID - ${res.data.id}`);
      } else {
        // Simple HTTP Payment was successful
        alert(`Payment successful, payment ID - ${res.data.id}`);
      }
    } catch (error) {
      console.error(error);
      alert("Payment failed!");
    }
  };

  return (
    &lt;div className="checkout"&gt;
      &lt;form className="checkout__container" onSubmit={handleSubmit}&gt;
        &lt;input
          type="email"
          value={email}
          className="checkout__textBox"
          onChange={(e) =&gt; setEmail(e.target.value)}
          placeholder="E-mail Address"
        /&gt;
        &lt;input
          type="number"
          value={amount}
          className="checkout__textBox"
          onChange={(e) =&gt; setAmount(e.target.value)}
          placeholder="Amount"
        /&gt;
        &lt;div className="checkout__radio"&gt;
          &lt;input
            type="radio"
            onChange={(e) =&gt; setSubscription("onetime")}
            checked={subscription === "onetime"}
          /&gt;
          Onetime
        &lt;/div&gt;
        &lt;div className="checkout__radio"&gt;
          &lt;input
            type="radio"
            onChange={(e) =&gt; setSubscription("monthly")}
            checked={subscription === "monthly"}
          /&gt;
          Monthly
        &lt;/div&gt;
        &lt;CardElement
          options={{
            style: {
              base: {
                fontSize: "16px",
                color: "#424770",
                "::placeholder": {
                  color: "#aab7c4",
                },
              },
              invalid: {
                color: "#9e2146",
              },
            },
          }}
        /&gt;
        &lt;button className="checkout__btn" type="submit"&gt;
          Donate
        &lt;/button&gt;
      &lt;/form&gt;
    &lt;/div&gt;
  );
}
export default Checkout;
</pre>
<p>为了测试您的条带集成，这里有一些由 Stripe 提供的<a href="https://stripe.com/docs/testing">卡细节</a>以供测试。你需要在测试模式下使用这些卡，你不会被收费。</p>
<p>当您使用 3D Secure 进入卡时，将会打开一个弹出窗口。在生产环境中，将向用户的电话号码发送一条短信，以验证支付。</p>
<p>您可以将您的雷达规则设置为强制支持卡的 3D 安全，但请注意，雷达规则并非适用于所有国家。</p>
<h2>下一步是什么？</h2>
<p>我建议从 Stripe 中查看更多信息，如 Apple Pay、Google Pay、储值卡、非工作时间支付以及其他多种支付方式。</p>
<p>您也可以查看 Stripe Checkout，您只需传入产品，付款将由 Stripe 处理。</p><div class="code-block code-block-22">
<div class="blog-plug inline-plug ecomm-plug"><h2><a href="https://lp.logrocket.com/blg/ecommerce-signup"> LogRocket </a>:看看用户为什么不完成你的电子商务流程中的一个步骤的技术和 UX 原因。</h2><a class="signup" href="https://lp.logrocket.com/blg/ecommerce-signup" target="_blank" rel="noopener noreferrer"><img class="alignnone size-full wp-image-46 jetpack-lazy-image" src="../Images/d60d88871d85e76e0dcca90f4bbaf78c.png" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2020/12/insights-step-2-lg.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/12/insights-step-2-lg.png"/><noscript><img data-lazy-fallback="1" class="alignnone size-full wp-image-46" src="../Images/d60d88871d85e76e0dcca90f4bbaf78c.png" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/12/insights-step-2-lg.png"/></noscript></a><p>LogRocket 就像是一个网络和移动应用程序和网站的 DVR，记录你的电子商务应用程序上发生的一切。LogRocket 没有猜测用户不转化的原因，而是主动揭示了阻止你转化的根本原因，比如 JavaScript 错误或死点击。LogRocket 还可以监控应用的性能，报告客户端 CPU 负载、客户端内存使用等指标。</p><p>开始主动监控您的电子商务应用程序— <a class="signup" href="https://lp.logrocket.com/blg/ecommerce-signup" target="_blank" rel="noopener noreferrer">免费试用</a>。</p></div></div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
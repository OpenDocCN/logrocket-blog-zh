<html>
<head>
<title>Getting started with PixiJS and React: Create a canvas - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>PixiJS 和 React 入门:创建一个 canvas - LogRocket 博客</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/getting-started-pixijs-react-create-canvas/#0001-01-01">https://blog.logrocket.com/getting-started-pixijs-react-create-canvas/#0001-01-01</a></blockquote><div><article class="article-post">
<p>曾几何时，在网络上创建丰富的交互式图形体验只能通过现已废弃的 Adobe flash player 插件来实现。但是，WebGL 的出现改变了游戏规则。它带来了一个丰富的网络可视化时代。</p>
<p>WebGL 是一个 JavaScript 渲染 API，提供高性能 2D 和 3D 交互式图形功能以及 GPU 加速。与它的前身不同，这种 API 可以在任何没有插件的兼容网络浏览器中工作。然而，WebGL 有一个更陡峭的学习曲线，所以在 API 上构建了几个框架来减轻直接使用它的复杂性。</p>
<p>以下是基于 WebGL 构建的一些最流行的框架:</p>

<p>在本文中，我们将回顾开始使用 PixiJS 需要知道的一切，pix ijs 是一个用于通过 React 渲染 2D 图形的超快速 WebGL 框架。本文的演示部分将包括几个 PixiJS 动画示例。</p>
<p><em>向前跳转:</em></p>

<h2 id="prerequisites">先决条件</h2>
<p>要学习本教程，您应该具备以下条件:</p>
<ul>
<li>React 及其概念的基础知识</li>
<li>对 PixiJS(通常称为 PIXI)的基本了解</li>
</ul>
<h2 id="implement-pixijs-in-react">在 React 中实现 PixiJS</h2>
<p>PixiJS 被设计成开箱即用的 HTML5。在 React 这样的库中实现它需要一个助手库，比如<a href="https://reactpixi.org" target="_blank" rel="noopener"> ReactPixi </a>，这将有助于 PixiJS 应用程序的集成和呈现。</p>
<p>ReactPixi 是一个开源库，用于在 React 中呈现高性能的 PixiJS 应用程序。该库提供了有用的组件，使得使用 React 的声明式风格编写 PixiJS 应用程序更加容易和快速。</p>
<p>让我们通过一个例子来看看如何在 react 中实现和呈现 PixiJS 应用程序。</p>
<h2 id="set-up-a-react-project">建立一个 React 项目</h2>
<p>作为第一步，我们需要建立一个样例 React 项目并安装所需的包。</p>
<p>让我们通过在终端中运行以下命令，用<a href="https://create-react-app.dev" target="_blank" rel="noopener"> create-react-app </a>引导 React 应用程序:</p>
<pre class="language-javascript hljs">npx create-react-app pixi-react-app
</pre>
<p>create-react-app 会在一个<code>pixi-react-app</code>文件夹里面安装 react 的最新版本。然而，在撰写本文时，ReactPixi 不支持 React v18。因此，在我们可以在我们的项目中使用这个库之前，我们需要将 React 降级到版本 17。</p>
<p>为此，首先，打开项目根文件夹中的<code>package.json</code>文件，并替换以下代码行:</p>
<pre class="language-javascript hljs">"react": "^18.0.0"
"react-dom": "^18.0.0"
</pre>
<p>使用以下代码片段:</p>
<pre class="language-javascript hljs">"react": "^17.0.2"
"react-dom": "^17.0.2"
</pre>
<p>接下来，转到<code>index.js</code>文件并替换以下代码:</p>
<pre class="language-javascript hljs">import ReactDOM from 'react-dom/client'
</pre>
<p>使用此命令:</p>
<pre class="language-javascript hljs">import ReactDOM from 'react-dom';
</pre>
<p>此外，替换以下代码:</p>
<pre class="language-javascript hljs">const root = ReactDOM.createRoot(document.getElementById('root'));
root.render(
  &lt;React.StrictMode&gt;
    &lt;App /&gt;
  &lt;/React.StrictMode&gt;
);
</pre>
<p>使用以下代码片段:</p>
<pre class="language-javascript hljs">ReactDOM.render(
  &lt;React.StrictMode&gt;
    &lt;App /&gt;
  &lt;/React.StrictMode&gt;,
  document.getElementById('root')
);
</pre>
<p>最后，删除项目根文件夹中的<code>node_modules</code>文件夹，并运行:</p>
<pre class="language-javascript hljs">npm install
</pre>
<p>运行上述命令后，您的 React 项目将降级到 v17。现在您可以安装 PixiJS 和 ReactPixi 了:</p>
<pre class="language-javascript hljs">npm install pixi.js @inlet/react-pixi
</pre>
<h2 id="create-a-pixijs-canvas">创建 PixiJS 画布</h2>
<p>建立项目后，清理样板代码和文件。接下来，打开<code>App.js</code>文件，从 ReactPixi 导入<code>Stage</code>组件:</p>
<pre class="language-javascript hljs">import Stage from "@inlet/react-pixi"
</pre>
<p>PIXI 不直接向 DOM 渲染对象。相反，它有一个渲染器，可以生成 HTML5 画布，作为浏览器中精灵和纹理等对象的显示区域。我们刚刚导入的<code>Stage</code>组件包含创建 PIXI 渲染器的底层代码。</p>
<p>该组件还作为一个根容器对象，在 PIXI 称为<code>Stage</code>。这个<code>Stage</code>对象是一个根容器，它保存了我们希望 PIXI 显示给渲染器的所有对象。</p>
<p>您可以将<code>Stage</code>组件添加到<code>App.js</code>组件，如下所示:</p>
<pre class="language-javascript hljs">const App = () =&gt; {
  return(
  &lt;Stage&gt;
  &lt;/Stage&gt;
)}
</pre>
<p>现在，通过在终端中运行<code>npm start</code>来启动开发服务器。您应该会在浏览器中看到一个类似下图的矩形画布元素。</p>
<p><img data-attachment-id="119776" data-permalink="https://blog.logrocket.com/getting-started-pixijs-react-create-canvas/attachment/black-rectangle/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/06/black-rectangle.png" data-orig-size="730,372" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Black rectangle" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/06/black-rectangle-300x153.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/06/black-rectangle.png" decoding="async" class="aligncenter size-full wp-image-119776 jetpack-lazy-image" src="../Images/92643beb227b543bd9f3f34b431ef01d.png" alt="Black Rectangle" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2022/06/black-rectangle.png 730w, https://blog.logrocket.com/wp-content/uploads/2022/06/black-rectangle-300x153.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2022/06/black-rectangle.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/06/black-rectangle.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="119776" data-permalink="https://blog.logrocket.com/getting-started-pixijs-react-create-canvas/attachment/black-rectangle/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/06/black-rectangle.png" data-orig-size="730,372" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Black rectangle" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/06/black-rectangle-300x153.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/06/black-rectangle.png" decoding="async" loading="lazy" class="aligncenter size-full wp-image-119776" src="../Images/92643beb227b543bd9f3f34b431ef01d.png" alt="Black Rectangle" srcset="https://blog.logrocket.com/wp-content/uploads/2022/06/black-rectangle.png 730w, https://blog.logrocket.com/wp-content/uploads/2022/06/black-rectangle-300x153.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/06/black-rectangle.png"/></noscript>
<p>呈现的黑色方块是 PIXI 将显示对象的显示区域。</p>
<p><code>Stage</code>组件接受可用于配置画布的属性。例如，<code>width</code>和<code>height</code>道具被设置为确定画布的尺寸。</p>
<pre class="language-javascript hljs">const App = () =&gt; {
  return(
  &lt;Stage width={300} height={300}&gt;
  &lt;/Stage&gt;
)}
</pre>
<p>我们还可以使用<code>options</code>属性为<code>Stage</code>组件设置更多属性，比如抗锯齿(<code>antialias</code>)、<code>autoDensity</code>和<code>backgroundColor</code>。</p>
<pre class="language-javascript hljs">const App = () =&gt; {
  return(
  &lt;Stage 
  width={300} 
  height={300} 
  options={{ 
  backgroundColor: 0x012b30, 
  antialias: true 
  }}&gt;

  &lt;/Stage&gt;
)}
</pre>
<p>现在，让我们看看如何将对象渲染到画布上。</p>
<h2 id="render-sprites">渲染精灵</h2>
<p>精灵是精灵的组成部分。这些特殊的图像可以用代码操纵和控制。在属性的帮助下，小精灵对于制作交互式和动画图形非常有用，这些属性让我们可以控制它们的位置、大小和许多其他特性。</p>
<p>用 ReactPixi 渲染精灵相当简单。该库提供了一个<code>Sprite</code>组件，可用于将图像加载和渲染到浏览器中。该组件消除了在将 sprite 图像加载到渲染器之前将其转换为 WebGL 纹理的复杂性。</p>
<p>要使用<code>Sprite</code>组件，将其导入到<code>App.js</code>文件中，如下所示:</p>
<pre class="language-javascript hljs">import { Stage, Sprite} from '@inlet/react-pixi'
</pre>
<p><code>Sprite</code>组件提供了几个有用的属性，可以用来操作和控制精灵图像的外观和位置。一个例子是<code>image</code>属性，它接受要呈现到画布上的图像的相对或绝对 URL。</p>
<p>将 sprite 加载到画布上就像将<code>Sprite</code>组件嵌套在<code>Stage</code> JSX 标签中，并将指向图像源的 URL 传递给<code>image</code>道具一样简单:</p>
<pre class="language-javascript hljs">...
import wizard from "./wizard.png";

const App = () =&gt; {
  return(
  &lt;Stage ...&gt;
      &lt;Sprite image={wizard} /&gt;
  &lt;/Stage&gt;
)} 
</pre>
<p>加载图像并保存项目后，您应该会在浏览器的画布中看到<code>Sprite</code>图像。</p>
<figure id="attachment_119779" aria-describedby="caption-attachment-119779" class="wp-caption aligncenter"><img data-attachment-id="119779" data-permalink="https://blog.logrocket.com/getting-started-pixijs-react-create-canvas/attachment/sprite-in-canvas/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/06/sprite-in-canvas.png" data-orig-size="730,484" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Sprite in canvas" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/06/sprite-in-canvas-300x199.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/06/sprite-in-canvas.png" decoding="async" class="wp-image-119779 size-full jetpack-lazy-image" src="../Images/590fd970d14b02aa5436354aea5b883c.png" alt="Sprite in Canvas" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2022/06/sprite-in-canvas.png 730w, https://blog.logrocket.com/wp-content/uploads/2022/06/sprite-in-canvas-300x199.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2022/06/sprite-in-canvas.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/06/sprite-in-canvas.png"/><noscript><img data-lazy-fallback="1" data-attachment-id="119779" data-permalink="https://blog.logrocket.com/getting-started-pixijs-react-create-canvas/attachment/sprite-in-canvas/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/06/sprite-in-canvas.png" data-orig-size="730,484" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Sprite in canvas" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/06/sprite-in-canvas-300x199.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/06/sprite-in-canvas.png" decoding="async" loading="lazy" class="wp-image-119779 size-full" src="../Images/590fd970d14b02aa5436354aea5b883c.png" alt="Sprite in Canvas" srcset="https://blog.logrocket.com/wp-content/uploads/2022/06/sprite-in-canvas.png 730w, https://blog.logrocket.com/wp-content/uploads/2022/06/sprite-in-canvas-300x199.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/06/sprite-in-canvas.png"/></noscript><figcaption id="caption-attachment-119779" class="wp-caption-text">Thanks to <a href="https://luizmelo.itch.io/" target="_blank" rel="noopener">LuizMelo</a> for making this sprite free for us to use.</figcaption></figure>
<p><code>Sprite</code>组件的一些可选道具包括<code>width</code>和<code>height</code>道具以及<code>x</code>和<code>y</code>道具。<code>width</code>和<code>height</code>属性用于操纵精灵的尺寸，而<code>x</code>和<code>y</code>属性用于定位精灵。<code>x</code>支柱将精灵定位在 x 轴上，而<code>y</code>支柱将其定位在 y 轴上。</p>
<pre class="language-javascript hljs">&lt;Sprite image={wizard} x={150} y={150}/&gt;
</pre>
<h2 id="render-graphics">渲染图形</h2>
<p>我们可以用 ReactPixi 做更多的事情，而不仅仅是将图像加载到渲染器中。该库提供了一个<code>Graphics</code>组件，它利用 PIXI 的低级绘图工具，使我们能够绘制不同种类的形状和线条，并向渲染器添加纹理。</p>
<p>让我们使用<code>Graphics</code>组件向渲染器绘制一个矩形。</p>
<p>首先，从 ReactPixi 导入<code>Graphics</code>组件，并将其嵌套在<code>Stage</code>标记中:</p>
<pre class="language-javascript hljs">import { Stage, Sprite, Graphics} from '@inlet/react-pixi'
</pre>
<p>接下来，用下面的代码创建一个函数，并将其作为一个值传递到<code>Graphics draw</code>属性中:</p>
<pre class="language-javascript hljs">const App = () =&gt; {

    const draw = g =&gt; {
      g.beginFill(0x0033cc, 1) 
      g.drawRect(250, 150, 150, 120)
      g.endFill()
    };

  return(
  &lt;Stage ...&gt;
      &lt;Sprite image={wizard} /&gt;
      &lt;Graphics draw={draw}/&gt;
  &lt;/Stage&gt;
)} 
</pre>
<p>在 draw 函数中，我们将使用<code>beginFill</code>方法设置形状的填充颜色，然后使用<code>drawRect</code>方法绘制形状。<code>drawRect</code>的参数分别是<code>x</code>、<code>y</code>、<code>height</code>和<code>width</code>属性。</p>
<p>保存项目后，我们之前在画布中加载的<code>Sprite</code>图像旁边会出现一个蓝框。</p>
<p><img data-attachment-id="119781" data-permalink="https://blog.logrocket.com/getting-started-pixijs-react-create-canvas/attachment/sprite-blue-rectangle/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/06/sprite-blue-rectangle.png" data-orig-size="730,478" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Sprite blue rectangle" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/06/sprite-blue-rectangle-300x196.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/06/sprite-blue-rectangle.png" decoding="async" class="aligncenter size-full wp-image-119781 jetpack-lazy-image" src="../Images/85ab08a4987ab9047299e7e50bc81dee.png" alt="Sprite Blue Rectangle" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2022/06/sprite-blue-rectangle.png 730w, https://blog.logrocket.com/wp-content/uploads/2022/06/sprite-blue-rectangle-300x196.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2022/06/sprite-blue-rectangle.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/06/sprite-blue-rectangle.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="119781" data-permalink="https://blog.logrocket.com/getting-started-pixijs-react-create-canvas/attachment/sprite-blue-rectangle/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/06/sprite-blue-rectangle.png" data-orig-size="730,478" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Sprite blue rectangle" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/06/sprite-blue-rectangle-300x196.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/06/sprite-blue-rectangle.png" decoding="async" loading="lazy" class="aligncenter size-full wp-image-119781" src="../Images/85ab08a4987ab9047299e7e50bc81dee.png" alt="Sprite Blue Rectangle" srcset="https://blog.logrocket.com/wp-content/uploads/2022/06/sprite-blue-rectangle.png 730w, https://blog.logrocket.com/wp-content/uploads/2022/06/sprite-blue-rectangle-300x196.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/06/sprite-blue-rectangle.png"/></noscript>
<p>我们可以通过在<code>draw</code>函数中添加一个<code>lineStyle</code>方法并赋予它以下属性来给形状一个轮廓:</p>
<pre class="language-javascript hljs">  const draw = g =&gt; {
    ...
    g.lineStyle(4,0xff0000,1) 
    g.endFill()
  };
</pre>
<p><img data-attachment-id="119783" data-permalink="https://blog.logrocket.com/getting-started-pixijs-react-create-canvas/attachment/blue-rectangle-red-outline/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/06/blue-rectangle-red-outline.png" data-orig-size="730,447" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Blue rectangle red outline" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/06/blue-rectangle-red-outline-300x184.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/06/blue-rectangle-red-outline.png" decoding="async" class="aligncenter size-full wp-image-119783 jetpack-lazy-image" src="../Images/bb5550b6b03eb93cf4033ca42fc3c47b.png" alt="Blue Rectangle Red Outline" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2022/06/blue-rectangle-red-outline.png 730w, https://blog.logrocket.com/wp-content/uploads/2022/06/blue-rectangle-red-outline-300x184.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2022/06/blue-rectangle-red-outline.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/06/blue-rectangle-red-outline.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="119783" data-permalink="https://blog.logrocket.com/getting-started-pixijs-react-create-canvas/attachment/blue-rectangle-red-outline/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/06/blue-rectangle-red-outline.png" data-orig-size="730,447" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Blue rectangle red outline" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/06/blue-rectangle-red-outline-300x184.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/06/blue-rectangle-red-outline.png" decoding="async" loading="lazy" class="aligncenter size-full wp-image-119783" src="../Images/bb5550b6b03eb93cf4033ca42fc3c47b.png" alt="Blue Rectangle Red Outline" srcset="https://blog.logrocket.com/wp-content/uploads/2022/06/blue-rectangle-red-outline.png 730w, https://blog.logrocket.com/wp-content/uploads/2022/06/blue-rectangle-red-outline-300x184.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/06/blue-rectangle-red-outline.png"/></noscript>
<p>属性是一个回调函数，每次它的属性改变时都会被调用。所以一定要通过在 React 的<code>useCallback</code>钩子中声明<code>draw</code>函数来记住它:</p>
<pre class="language-javascript hljs">  const draw = useCallback(g =&gt; {
    g.beginFill(0x0033cc, 1)
    g.lineStyle(4,0xff0000,1) 
    g.drawRect(250, 150, 150, 120)
    g.endFill()
  },[]);
</pre>
<h2 id="render-text">呈现文本</h2>
<p>ReactPixi 的<code>Text</code>组件利用 Pixi 的<code>Text</code>对象向渲染器显示文本。该组件有两个主要属性:<code>text</code>，它接受要显示的文本，以及<code>style</code>，它接受定义文本属性的对象。</p>
<pre class="language-javascript hljs">&lt;Text
    text="Hello World"
    style={
      new TextStyle({
        align: 'center',
        fill: ['#ffffff', '#00ff99'], // gradient
        stroke: '#01d27e',
        strokeThickness: 5,
        letterSpacing: 20,
  /&gt;        
</pre>
<p>要在项目中使用<code>Text</code>组件，首先从 ReactPixi 导入它:</p>
<pre class="language-javascript hljs">import { Stage, Sprite, Graphics, Text } from '@inlet/react-pixi';
</pre>
<p>接下来，将其添加到<code>Stage</code>中，并向其传递一些<code>textStyle</code>道具:</p>
<pre class="language-javascript hljs">const textStyle = new TextStyle({
  align: "center",
  fontWeight: "bold",
  fill: ["#26f7a3", "#01d27e"],
  stroke: "#eef1f5",
  strokeThickness: 1,
  letterSpacing: 5,
  wordWrap: false,
  wordWrapWidth: 350
})

const App = () =&gt; (
  &lt;Stage ...&gt;
     ….
     &lt;Text text="Hello Logrocketer" style={textStyle}/&gt;
     ….
  &lt;/Stage&gt;
);
</pre>
<p>保存项目后，我们看到文本“Hello Logrocketer”呈现在画布上。</p>
<p><img data-attachment-id="119785" data-permalink="https://blog.logrocket.com/getting-started-pixijs-react-create-canvas/attachment/hello-logrocketer-text/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/06/hello-logrocketer-text.png" data-orig-size="730,447" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Hello Logrocketer text" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/06/hello-logrocketer-text-300x184.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/06/hello-logrocketer-text.png" decoding="async" class="aligncenter size-full wp-image-119785 jetpack-lazy-image" src="../Images/45bd69df1586a344d6d7ddac7fbe5806.png" alt="Hello Logrocketer Text" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2022/06/hello-logrocketer-text.png 730w, https://blog.logrocket.com/wp-content/uploads/2022/06/hello-logrocketer-text-300x184.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2022/06/hello-logrocketer-text.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/06/hello-logrocketer-text.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="119785" data-permalink="https://blog.logrocket.com/getting-started-pixijs-react-create-canvas/attachment/hello-logrocketer-text/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/06/hello-logrocketer-text.png" data-orig-size="730,447" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Hello Logrocketer text" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/06/hello-logrocketer-text-300x184.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/06/hello-logrocketer-text.png" decoding="async" loading="lazy" class="aligncenter size-full wp-image-119785" src="../Images/45bd69df1586a344d6d7ddac7fbe5806.png" alt="Hello Logrocketer Text" srcset="https://blog.logrocket.com/wp-content/uploads/2022/06/hello-logrocketer-text.png 730w, https://blog.logrocket.com/wp-content/uploads/2022/06/hello-logrocketer-text-300x184.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/06/hello-logrocketer-text.png"/></noscript>
<h2 id="add-filters">添加过滤器</h2>
<p>ReactPixi 提供了一个<code>withFilters</code>函数，它简化了在渲染器中向对象添加过滤器的过程。该函数使用 PIXI 的全局对象来访问过滤器对象及其属性。</p>
<p>为了给我们的 sprite 添加滤镜，我们必须首先从 PixiJS 导入<code>withFilters</code>函数和<code>PIXI</code>全局对象，如下所示:</p>
<pre class="language-javascript hljs">import { Stage, Sprite, Graphics, Text, withFilter } from '@inlet/react-pixi';
import * as PIXI from 'pixi.js';
</pre>
<p><code>withFilters</code>函数接受两个参数，一个容器组件和一个对象配置。</p>
<pre class="language-javascript hljs">const Filters = withFilters(Container, {
  blur: PIXI.filters.BlurFilter
});
</pre>
<p><code>Container</code>参数赋予<code>withFilters</code>函数容器对象的特征。</p>
<p>如前所述，容器是一个用于对要在渲染器中显示的其他对象进行分组的对象。我们在<code>Container</code>上设置的过滤器将应用于嵌套在容器中的对象。</p>
<p>第二个参数是过滤器配置，包含过滤器的首选项。这是我们从<code>PIXI</code>全局对象访问<code>filter</code>对象并设置我们想要应用到容器的过滤器种类的地方。在本例中，我们使用<code>BlurFilter</code>对象属性应用了一个<code>blur</code>滤镜。</p>
<p>不要忘记从 ReactPixi 导入<code>Container</code>组件，如下所示:</p>
<pre class="language-javascript hljs">import { Stage, Sprite, Graphics, Text, withFilter, Container } from '@inlet/react-pixi';
</pre>
<p>现在我们已经配置了一个过滤器容器，让我们将它应用到我们的<code>Sprite</code>中。将<code>Filters</code>容器添加到<code>Stage</code>中，并将<code>Sprite</code>组件嵌套在其中。然后，向容器传递一个<code>blur</code>道具，并赋予其以下属性:</p>
<pre class="language-javascript hljs">const App = () =&gt; (
  &lt;Stage&gt;
     ….
    &lt;Filters blur={{ blur: 5 }} &gt;
      &lt;Sprite image={wizard} .../&gt;
    &lt;/Filters&gt;
     ….
  &lt;/Stage&gt;
);
</pre>
<p>这将在渲染器中给精灵添加一个模糊滤镜效果。您可以通过更改<code>blur</code>属性的值来调整模糊效果。</p>
<p><img data-attachment-id="119787" data-permalink="https://blog.logrocket.com/getting-started-pixijs-react-create-canvas/attachment/blurred-canvas/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/06/blurred-canvas.png" data-orig-size="730,446" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Blurred canvas" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/06/blurred-canvas-300x183.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/06/blurred-canvas.png" decoding="async" class="aligncenter size-full wp-image-119787 jetpack-lazy-image" src="../Images/0c3168d6e8d700743fb0206378fc948d.png" alt="Blurred Canvas" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2022/06/blurred-canvas.png 730w, https://blog.logrocket.com/wp-content/uploads/2022/06/blurred-canvas-300x183.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2022/06/blurred-canvas.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/06/blurred-canvas.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="119787" data-permalink="https://blog.logrocket.com/getting-started-pixijs-react-create-canvas/attachment/blurred-canvas/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/06/blurred-canvas.png" data-orig-size="730,446" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Blurred canvas" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/06/blurred-canvas-300x183.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/06/blurred-canvas.png" decoding="async" loading="lazy" class="aligncenter size-full wp-image-119787" src="../Images/0c3168d6e8d700743fb0206378fc948d.png" alt="Blurred Canvas" srcset="https://blog.logrocket.com/wp-content/uploads/2022/06/blurred-canvas.png 730w, https://blog.logrocket.com/wp-content/uploads/2022/06/blurred-canvas-300x183.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/06/blurred-canvas.png"/></noscript>
<h2 id="animate-sprites">动画精灵</h2>
<p>一个环，也称为游戏循环，是需要在 PIXI 动画对象。<code>gameLoop</code>函数每秒钟被调用 60 次，嵌套在函数中的每个代码都被同样频繁地调用。</p>
<p>例如，下面的代码将使向导精灵以每帧 1 个像素的速度向左移动:</p>
<pre class="language-javascript hljs">function setup() {
  app.ticker.add((delta) =&gt; gameLoop(delta));
}
function gameLoop(delta) {
  wizard.x -= 1;
}
</pre>
<p>使用 PIXI 的 ticker 事件创建了一个 looper 函数；它相当于 JavaScript 的<code>requestAnimationFrame</code>方法。ReactPixi 提供了一个<code>useTick</code>钩子，将侦听器绑定到 ticker 事件。有了它，我们可以动画显示<code>Sprite</code>的位置和状态。</p>
<p>在我们开始制作动画之前，我们将首先分别从 ReactPixi 和 React 导入<code>useTick</code>和<code>useState</code>钩子:</p>
<pre class="language-javascript hljs">import { useTick, ... } from '@inlet/react-pixi';
import {..., useState} from 'react'
</pre>
<p>接下来，让我们为向导<code>Sprite</code>创建一个新组件，并将其嵌套在<code>App.js</code>组件的容器中:</p>
<pre class="language-javascript hljs">...
const Wizard = () =&gt;{
  return(
    &lt;Sprite
      image={wizard}
      x={x}
      y={y}
      anchor={0.5}
      scale={1.3}
    /&gt;
  )
}

const App = () =&gt; (
  &lt;Stage ...&gt;
    &lt;Wizard /&gt;
     ….
  &lt;/Stage&gt;
);
</pre>
<p>现在。在<code>Sprite</code>组件函数中添加以下代码:</p>
<pre class="language-javascript hljs">import { Stage, Container, Sprite, Text, Graphics, withFilters,useTick } from '@inlet/react-pixi'
import { useState, useCallback} from "react";
import * as PIXI from "pixi.js"
import wizard from "./wizard.png";

let i = 0;

const Wizard = () =&gt;{
  const [x, setX] = useState(0)
  const [y, setY] = useState(0)

  useTick(delta =&gt;{
    i += 0.05 * delta;
    setX(Math.sin(i) * 100)
    setY(Math.sin(i/1.5) * 100)
   });

  return(
    &lt;Sprite
      image={wizard}
      x={x}
      y={y}
      anchor={0.5}
      scale={1.3}
    /&gt;
  )
}
const App = () =&gt; (
  &lt;Stage ...&gt;
    &lt;Wizard /&gt;
     ….
  &lt;/Stage&gt;
);
</pre>
<p>在上面的代码块中，我们声明了一个变量<code>i</code>，并给它赋值<code>0</code>。接下来，我们使用<code>useState</code>钩子创建两个状态变量<code>x</code>和<code>y</code>，初始值为<code>0</code>。然后，我们调用<code>useTick</code>钩子并传递给它一个回调函数。</p>
<p>在回调函数中，我们将一个<code>delta</code>值赋给<code>i</code>变量，并将变量值乘以 100 的正弦结果设置给<code>x</code>和<code>y</code>状态变量。</p>
<p>最后，我们将<code>x</code>和<code>y</code>状态变量的值分别传递给<code>Sprite</code>的<code>x</code>和<code>y</code>道具。</p>
<p>保存代码后，您的 sprite 应该像下面的向导一样显示动画:</p>
<p><img data-attachment-id="119789" data-permalink="https://blog.logrocket.com/getting-started-pixijs-react-create-canvas/attachment/sprite-dragged-around/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/06/sprite-dragged-around.gif" data-orig-size="730,429" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Sprite dragged around" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/06/sprite-dragged-around-300x176.gif" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/06/sprite-dragged-around.gif" decoding="async" class="aligncenter size-full wp-image-119789 jetpack-lazy-image" src="../Images/5b87d3f56349f6f2d2907f2602bcde8b.png" alt="Sprite Dragged Around" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2022/06/sprite-dragged-around.gif?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/06/sprite-dragged-around.gif"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="119789" data-permalink="https://blog.logrocket.com/getting-started-pixijs-react-create-canvas/attachment/sprite-dragged-around/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/06/sprite-dragged-around.gif" data-orig-size="730,429" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Sprite dragged around" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/06/sprite-dragged-around-300x176.gif" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/06/sprite-dragged-around.gif" decoding="async" loading="lazy" class="aligncenter size-full wp-image-119789" src="../Images/5b87d3f56349f6f2d2907f2602bcde8b.png" alt="Sprite Dragged Around" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/06/sprite-dragged-around.gif"/></noscript>
<h2 id="conclusion">结论</h2>
<p>在本文中，我们演示了如何创建 PIXI 画布，将精灵、文本和图形对象加载到渲染器中，为对象添加滤镜，以及制作对象动画。</p>
<p>本文的目的是让您了解如何在 React 中实现 PixiJS 应用程序。请访问<a href="https://reactpixi.org" target="_blank" rel="noopener"> ReactPixi </a>和<a href="https://pixijs.com" target="_blank" rel="noopener"> PixiJS </a>文档，了解关于该框架的更多信息，以及如何使用它在项目中创建复杂的交互。</p><div class="code-block code-block-17">
<div class="blog-plug inline-plug react-plug" vwo-el-id="26283398190">
<h2 vwo-el-id="41600691720">使用 LogRocket 消除传统反应错误报告的噪音</h2>
<a href="https://lp.logrocket.com/blg/react-signup-issue-free" target="_blank" vwo-el-id="19356441070">LogRocket
</a><p>是一款 React analytics 解决方案，可保护您免受数百个误报错误警报的影响，只针对少数真正重要的项目。LogRocket 告诉您 React 应用程序中实际影响用户的最具影响力的 bug 和 UX 问题。</p><a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="19356441380">
<img class="first-react-image alignnone size-full wp-image-46 jetpack-lazy-image jetpack-lazy-image--handled" src="../Images/f300c244a1a1cf916df8b4cb02bec6c6.png" vwo-el-id="18272717540" data-lazy-loaded="1" data-original-src="https://files.readme.io/27c94e7-Image_2017-06-05_at_9.46.04_PM.png"/>
</a>
<a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="19356441690">
<img class="second-react-image alignnone size-full wp-image-46 jetpack-lazy-image jetpack-lazy-image--handled" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" vwo-el-id="30720362350" data-lazy-loaded="1" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/>
</a>
<a href="https://lp.logrocket.com/blg/react-signup-issue-free" target="_blank" rel="noopener noreferrer" vwo-el-id="35866400580">LogRocket
</a><p>自动聚合客户端错误、反应错误边界、还原状态、缓慢的组件加载时间、JS 异常、前端性能指标和用户交互。然后，LogRocket 使用机器学习来通知您影响大多数用户的最具影响力的问题，并提供您修复它所需的上下文。</p><p vwo-el-id="28675661060">关注重要的 React bug—<a class="signup" href="https://lp.logrocket.com/blg/react-signup-issue-free" target="_blank" rel="noopener noreferrer" vwo-el-id="40093418840">今天就试试 LogRocket】。</a></p>
</div></div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
<html>
<head>
<title>How ArrowJS compares to React and Vue.js </title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>ArrowJS如何与React和Vue.js进行比较</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/how-arrowjs-compares-react-vue-js/#0001-01-01">https://blog.logrocket.com/how-arrowjs-compares-react-vue-js/#0001-01-01</a></blockquote><div><article class="article-post">
<p>前端生态系统充斥着过多的框架，似乎每天都有新的框架发布。虽然这些框架中的许多可能没有更流行的框架使用广泛，但其中一些提供了独特的方法，可能会引起您的兴趣。</p>
<p>在本文中，我们将介绍用于构建反应式用户界面的JavaScript工具<a href="https://www.arrow-js.com"> ArrowJS </a>，并将其方法与React和Vue.js等流行的UI框架进行比较。我们将探索ArrowJS与这些传统框架的不同之处以及它的与众不同之处。</p>
<p><em>向前跳转:</em></p>

<h2 id="prerequisites">先决条件</h2>
<p>要理解本文中共享的概念和示例，您应该具备以下条件:</p>
<ul>
<li>系统上安装的Node.js</li>
<li>JavaScript、Vue和React的基础知识</li>
</ul>
<h2 id="what-arrowjs">什么是ArrowJS？</h2>
<p>ArrowJS是一个使用纯JavaScript构建反应式用户界面的实验性工具。它使用现代JavaScript特性，如模板文字、模块和代理，来实现其模板结构、可观察数据和声明性/反应性DOM呈现功能。</p>
<p>ArrowJS 的创造者认为，没有必要用复杂的框架来创建令人印象深刻和高性能的网络用户界面，因为JavaScript已经发展得足够强大，可以在本地处理这些任务。</p>
<p>因此，ArrowJS没有依赖项，没有虚拟DOM，没有构建工具，也没有特殊的模板语言。它也非常轻量级，重量不到3kB (min+Gzip)。这使得它比React和Vue等具有类似功能的框架更快。</p>
<p>与许多其他JavaScript框架不同，ArrowJS不使用构建工具或模板语言。这意味着在构建期间不需要编译或转换，从而获得更好的性能。</p>
<p>相比之下，React使用JSX作为其模板语言，必须编译并转换为本机JavaScript渲染函数，才能在浏览器中运行。</p>
<h2 id="why-use-arrowjs">为什么要用ArrowJS？</h2>
<p>考虑使用ArrowJS有几个原因，包括以下主要好处:</p>
<ul>
<li>使用普通JavaScript构建用户界面:使用ArrowJS，您无需学习新的语言或框架，因为您可以使用现有的JavaScript知识来创建强大的用户界面</li>
<li><strong>反应式编程模型</strong>:使用ArrowJS，每当底层数据发生变化时，您的UI都会自动更新，这使得构建能够实时对变化做出反应的动态响应用户界面变得更加容易</li>
<li>轻量级和易于使用:ArrowJS有一个简单的API和一个小的内存，所以你可以把它添加到你的项目中，而不需要增加额外的代码和复杂性</li>
</ul>
<p>在本文的稍后部分，我们将深入探讨这些好处。</p>
<h2 id="getting-started-arrowjs">箭头入门</h2>
<p>设置ArrowJS应用程序有三种可能的方法:使用包管理器、本地安装或通过CDN。让我们来看看每个选项。</p>
<h3 id="installation-package-manager">从软件包管理器安装</h3>
<p>如前所述，默认情况下，ArrowJS不包含构建工具或捆绑器。但是，如果您想使用npm或Yarn之类的包管理器来引导您的项目，并利用热模块重载之类的特性，您可以使用Vite或Snowpack之类的<a href="https://blog.logrocket.com/vite-vs-snowpack-a-comparison-of-frontend-build-tools/">工具来捆绑您的项目</a>。</p>
<p>使用以下命令通过npm或Yarn安装ArrowJS:</p>
<pre class="language-shell hljs">//npm 
npm install @arrow-js/core

//Yarn
yarn add @arrow-js/core
</pre>
<h3 id="installation-local-file-system">从本地文件系统安装</h3>
<p>要在本地安装ArrowJS，您需要从GitHub下载ArrowJS包，并将其直接添加到您的项目中。然后，在脚本模块中引用它，如下所示:</p>
<pre class="language-javascript hljs">&lt;script type="module"&gt;
 import { reactive, html } from '/js/arrow.js';
 //your app’s code goes here
&lt;/script&gt;
</pre>
<h3 id="installation-cdn">从CDN安装</h3>
<p>通过CDN安装ArrowJS非常简单，只需在脚本中添加以下import语句:</p>
<pre class="language-javascript hljs">&lt;script type="module"&gt;
 import { reactive, html } from npm install @arrow-js/core'https://cdn.skypack.dev/@arrow-js/core';
 // Start your app here!
&lt;/script&gt;
</pre>
<h2 id="understanding-arrowjs-building-blocks">了解箭头构建模块</h2>
<p>ArrowJS基于两个组合表达式:静态和反应式。然而，该工具的创造者认为，反应应该是一个选项，而不是一个要求。因此，ArrowJS在默认情况下是静态的，在选择时是反应性的，并且只提供三个函数来处理模板和反应性功能:</p>
<ul>
<li><code>reactive</code> ( <code>r</code>)</li>
<li><code>watch</code> ( <code>w</code>)</li>
<li><code>html</code> ( <code>t</code>)</li>
</ul>
<h3 id="reactive">ArrowJS <code>reactive</code>功能</h3>
<p><code>reactive</code>函数，简称为<code>r</code>,是一个ArrowJS函数，它将通用数据对象转换为观察数据对象。该函数监视对象的变化，并根据需要自动更新任何相关的模板或依赖项。</p>
<p>使用<code>reactive</code>函数很简单；只需将您想要监控的对象作为参数传递给<code>reactive</code>函数调用<code>reactive(object)</code>，如下所示:</p>
<pre class="language-javascript hljs">import { reactive } from '@arrow-js/core'

const users = reactive({
 name: “John”,
 age: 25
})
</pre>
<p>在本例中，假设我们有一个依赖于反应数据中任何对象属性的变量。当对象属性改变时，应变量的值将相应地更新:</p>
<pre class="language-javascript hljs">import { reactive } from '@arrow-js/core'

const users = reactive({
 name: "John",
 age: 25
})

users.name = "Mike"

const data = user.name;

console.log(data);

//logs 'Mike' to the console
</pre>
<p>然而，ArrowJS提供了<code>$on</code>和<code>$off</code>方法，允许我们观察反应属性的变化。</p>
<p><code>$on</code>方法接受两个参数:属性名和回调函数。此方法观察指定属性的更改，并在发生更改时运行回调函数:</p>
<pre class="language-javascript hljs">import { reactive } from "@arrow-js/core";

const users = reactive({
 name: "John",
 age: 25,
});

const nameFunc = (value) =&gt; {
 console.log(`name changed to ${value}`);
 const data = value;
 }

users.$on("name", nameFunc);

setTimeout(() =&gt; {
 users.name = "Mike";
}, 2000);

//"name changed to Mike" will get logged to the console two seconds after initialization
</pre>
<p>在上面的例子中，<code>$o</code> n回调函数将在name属性改变时运行。</p>
<p>另一方面，<code>$off</code>方法用于从<code>$on</code>方法中移除附加的回调。</p>
<p>例如，如果我们想要阻止<code>reactive</code>函数观察<code>name</code>属性，我们将使用下面的代码:</p>
<pre class="language-javascript hljs">const users = reactive({
 name: "John",
 age: 25,
});

const nameFunc = (value) =&gt; {
 console.log(`name changed to ${value}`);
 const data = value;
};

users.$on("name", nameFunc);

setTimeout(() =&gt; {
 users.name = "Mike";
}, 2000);

users.$off("name", nameFunc);

//We stopped observing 'name' with $off
// so changing users.name will not log anything
</pre>
<h3 id="watch">ArrowJS <code>watch</code>功能</h3>
<p>或者，我们可以使用ArrowJS <code>watch</code>函数来跟踪和取消跟踪反应属性。<code>watch</code>函数，简称<code>w</code>，是一个内置的ArrowJS函数，就像<code>reactive</code>函数一样。但是，与<code>r</code>函数不同的是，<code>watch</code>接受一个函数并跟踪该函数的任何反应依赖性:</p>
<pre class="language-javascript hljs">import { reactive, watch } from "@arrow-js/core";
 price: 25,
 tax: 10,
});

function total() {
 console.log(`Total: ${data.price + data.tax}`);
}

setTimeout(() =&gt; {
 data.price = 35;
}, 2000);

watch(total);

//"Total: 45" will be logged to the console two seconds after initialization
</pre>
<p><code>watch</code>功能将监控<code>price</code>和<code>tax</code>无功属性的任何值变化。它还为这些属性激活<code>$on</code>观察器，并自动检测它们何时不再被函数使用，此时它将调用<code>$off</code>观察器并停止跟踪属性。</p>
<h3 id="html">ArrowJS <code>html</code>功能</h3>
<p>ArrowJS <code>html</code>函数，简称为<code>t</code>，用于创建箭头模板并安装到DOM中。它使用带标签的模板文本以声明方式呈现内容。</p>
<p>要创建一个ArrowJS模板，您可以用关键字<code>html</code>或其简写<code>t</code>作为记号标记的前缀，并添加要呈现的元素。</p>
<p>例如，关键字或其简写后跟一个开始记号(<code>html'</code>或<code>t'</code>)表示模板的开始，而结束记号表示模板的结束。</p>
<p>然后，我们可以在刻度内添加要呈现的元素，就像这样:<code>html`elements to be rendered`</code>或<code>t`elements to be rendered`</code></p>
<p>这里有一个例子:</p>
<pre class="language-javascript hljs">import { html } from '@arrow-js/core'

const appElement = document.getElementById('app');

const template = html`&lt;p&gt;Hello World&lt;/p&gt;`

template(appElement)
</pre>
<p>在上面的代码中，我们引用了DOM中的一个元素，并将我们的模板安装到它上面。</p>
<h2 id="feature-comparison">特征比较</h2>
<p>让我们仔细看看ArrowJS的一些特性，看看它们与React和Vue的特性相比如何。</p>
<h3 id="module-structure-syntaxes">模块结构和语法</h3>
<p>与Vue、React和大多数其他JavaScript框架不同，ArrowJS不使用基于组件的方法。相反，它依赖于函数。但是由于JavaScript组件本质上是幕后的函数，所以这两种方法实际上非常相似。</p>
<p>这些框架的不同之处在于它们封装的模板种类和它们的整体结构。例如，Vue使用单文件组件结构，其中组件的模板、逻辑和样式都包含在单个<code>.vue</code>文件中:</p>
<pre class="language-javascript hljs">&lt;template&gt;
 &lt;!-- html markup --&gt;
&lt;/template&gt;

&lt;script&gt;
 // JavaScript code
&lt;/script&gt;

&lt;style&gt;
 /* CSS styles */
&lt;/style&gt;
</pre>
<p>相比之下，ArrowJS使用标准的JavaScript脚本模块和本机代码和函数:</p>
<pre class="language-javascript hljs">import { r, t } from "@arrow-js/core";

const appElement = document.getElementById("app");

// JavaScript code
const user = r({});

const template = t`
 &lt;div class="container"&gt;
 &lt;!-- html markup --&gt;
 &lt;/div&gt;
`;

template(appElement);
</pre>
<p>乍一看，ArrowJS似乎与Vue没有太大的不同，因为两个框架都将它们的模板和逻辑封装在一个模块中。然而，ArrowJS使用<a href="https://blog.logrocket.com/16-useful-typescript-javascript-shorthands-know/#template-literals">模板文字</a>(一个本地JavaScript特性)来插入表达式并直接将元素呈现到DOM中。同时，Vue依赖于虚拟DOM，它是实际DOM的抽象。</p>
<h3 id="events">事件</h3>
<p>ArrowJS和其他框架的另一个显著区别是将事件侦听器绑定到DOM元素的语法。该工具使用后面跟有事件名称的<code>@</code>符号来表示事件监听器:</p>
<pre class="language-javascript hljs">const clickHandler = () =&gt;{
 console.log("clicked");
}

const template = t`
 &lt;button @click="${clickHandler}"&gt;Click&lt;/button&gt;
`;
</pre>
<p>这将自动转换成一个等效的表达式:</p>
<pre class="language-javascript hljs">document.getElementById("btn").addEventListener("click", () =&gt; {
 console.log("clicked");
});
</pre>
<p>相比之下，React和Vue在将事件侦听器绑定到元素时使用camelCase命名约定和事件指令:</p>
<pre class="language-javascript hljs">//React
const MyButton = () =&gt; {
 handleClick = () =&gt; {
 // do something when the button is clicked
 };

 return &lt;button onClick={handleClick}&gt;Click me&lt;/button&gt;;
};
Vue
&lt;template&gt;
 &lt;button v-on:click="handleClick"&gt;
 Click me
 &lt;/button&gt;
&lt;/template&gt;

&lt;script&gt;
 export default {
 methods: {
 handleClick() {
 // do something when the button is clicked
 }
 }
 }
&lt;/script&gt;
</pre>
<h3 id="reactivity">反应</h3>
<p>反应性是一种编程范式，它允许我们声明性地调整以适应变化。这仅仅是一个概念，而不是编程语言的默认特性。然而，它可以使用不同的工具和技术来实现，这取决于给定系统的特定需求和约束。</p>
<p>在JavaScript中，可以使用React和Vue等框架和库来实现反应性，这些框架和库是为构建反应性用户界面而设计的。这些框架使用虚拟DOM来处理反应，当发生变化时，更新它以反映最新的数据。然后，该框架将虚拟DOM与真实DOM进行比较，以确定UI的哪些部分需要更新。</p>
<p>鉴于ArrowJS使用原生JavaScript，您可能会好奇它是如何处理反应的。解决方案是一个自定义依赖类。</p>
<p>JavaScript中的反应性可以使用一个依赖类来实现，该类接受两个属性:一个值getter和一个回调函数。值getter是一个依赖于多个变量或依赖项来获取其值的函数。</p>
<p>每当依赖项的值改变时，JavaScript将自动调用回调函数，并将当前值与先前值进行比较。</p>
<p>这就是ArrowJS如何使用<code>reactive</code>和<code>watch</code>功能来处理引擎盖下的反应。而且，因为ArrowJS不依赖于像虚拟DOM这样的机制，所以它的效果是即时的。</p>
<p>另一件要考虑的事情是，与其他框架相比，ArrowJS中反应式实现的简洁性。例如，下面的代码演示了如何在显示用户的<code>name</code>和<code>age</code>的React组件中实现反应:</p>
<pre class="language-javascript hljs">import { useState, useEffect } from 'react';

function ReactiveComponent() {
 // Create a state variable called "user" to hold the reactive data
 const [user, setUser] = useState({ name: 'John Doe', age: 32 });

 // Use the useEffect hook to specify a function that will be executed
 // whenever the user's data changes
 useEffect(() =&gt; {
 // Update the UI to reflect the latest user data
 // (e.g., update the name and age displayed on the screen)
 });

 // Return the JSX for the component, which includes the current
 // user's name and age
 return (
 &lt;div&gt;
 &lt;p&gt;Name: {user.name}&lt;/p&gt;
 &lt;p&gt;Age: {user.age}&lt;/p&gt;
 &lt;/div&gt;
 );
}
</pre>
<p>下面是ArrowJS中相同的实现:</p>
<pre class="language-javascript hljs">import { r, html } from "@arrow-js/core";

const appElement = document.getElementById("app");

// Create a state variable called "user" to hold the reactive data
const user = r({ name: "John Doe", age: 32 });

 // Dom template which includes the current
 // user's name and age
const template = html`
 &lt;div&gt;
 &lt;p&gt;Name: ${user.name}&lt;/p&gt;
 &lt;p&gt;Age: ${user.age}&lt;/p&gt;
 &lt;/div&gt;
`;

// Map template to Dom
template(appElement);
</pre>
<h3 id="declarative-rendering">声明性渲染</h3>
<p>这些框架共有的一个方面是它们如何在模板中呈现声明性数据属性。React使用一个由单花括号表示的占位符将反应内容和变量插入到字符串中，如下所示:</p>
<pre class="language-javascript hljs">&lt;div&gt;
 &lt;p&gt;Name: {user.name}&lt;/p&gt;
 &lt;p&gt;Age: {user.age}&lt;/p&gt;
&lt;/div&gt;
</pre>
<p>相比之下，Vue使用双花括号，通常称为mustache语法，将动态值插入到字符串中。例如，上面的模板将在Vue中呈现如下:</p>
<pre class="language-javascript hljs">&lt;div&gt;
 &lt;p&gt;Name: {{user.name}}&lt;/p&gt;
 &lt;p&gt;Age: {{user.age}}&lt;/p&gt;
&lt;/div&gt;
</pre>
<p>因为ArrowJS使用本地JavaScript来呈现元素，所以它可以访问模板文字提供的特殊占位符语法。这些占位符称为模板标签，使用<code>${}</code>语法表示，用于在运行时将动态值插入模板。这使得ArrowJS可以创建包含动态数据的模板，只要数据发生变化，这些模板就会更新。</p>
<p>模板标签用于将JavaScript表达式的结果插入模板。要创建模板标签，只需在<code>${}</code>占位符中放置一个表达式。计算字符串时，会计算表达式，其值会插入到模板中的占位符位置:</p>
<pre class="language-javascript hljs">const template = html`
 &lt;div&gt;
 &lt;p&gt;Name: ${user.name}&lt;/p&gt;
 &lt;p&gt;Age: ${user.age}&lt;/p&gt;
 &lt;/div&gt;
`;
</pre>
<p>如您所见，模板标签的语法类似于React和Vue中使用的语法，除了符号<code>$</code>。</p>
<p>模板标签提供了一种简单明了的方法将动态值插入模板。这些标记可以与其他语言特性(如箭头函数和析构)结合使用，以创建清晰易读的代码。</p>
<h2 id="conclusion">结论</h2>
<p>在本文中，我们介绍了ArrowJS，讨论了它的许多优点，并将它的特性与React和Vue进行了比较。ArrowJS仍处于试验阶段，但事实证明它是一个强大的工具，可以用原生JavaScript构建快速、反应式的用户界面。</p>
<p>与传统方法相比，用ArrowJS构建ui有几个优点，包括改进的性能和与现有代码的轻松集成。原生JavaScript的使用使得ArrowJS成为任何开发人员工具箱中有价值的补充。</p><div class="code-block code-block-28">
<div class="blog-plug inline-plug js-libraries-plug"><h2>您是否添加了新的JS库来提高性能或构建新特性？如果他们反其道而行之呢？</h2><p>毫无疑问，前端变得越来越复杂。当您向应用程序添加新的JavaScript库和其他依赖项时，您将需要更多的可见性，以确保您的用户不会遇到未知的问题。</p>
<p>LogRocket 是一个前端应用程序监控解决方案，可以让您回放JavaScript错误，就像它们发生在您自己的浏览器中一样，这样您就可以更有效地对错误做出反应。</p><a class="signup" href="https://lp.logrocket.com/blg/javascript-signup" target="_blank" rel="noopener noreferrer"><img class="alignnone size-full wp-image-46 jetpack-lazy-image" src="../Images/e8a0ab42befa3b3b1ae08c1439527dc6.png" alt="LogRocket Dashboard Free Trial Banner" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2019/10/errors-screenshot.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/10/errors-screenshot.png"/><noscript><img data-lazy-fallback="1" class="alignnone size-full wp-image-46" src="../Images/e8a0ab42befa3b3b1ae08c1439527dc6.png" alt="LogRocket Dashboard Free Trial Banner" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/10/errors-screenshot.png"/></noscript></a>
<a href="https://lp.logrocket.com/blg/javascript-signup" target="_blank" rel="noopener noreferrer">https://logrocket.com/signup/</a><p><a href="https://lp.logrocket.com/blg/javascript-signup" target="_blank" rel="noopener noreferrer"> LogRocket </a>可以与任何应用程序完美配合，不管是什么框架，并且有插件可以记录来自Redux、Vuex和@ngrx/store的额外上下文。您可以汇总并报告问题发生时应用程序的状态，而不是猜测问题发生的原因。LogRocket还可以监控应用的性能，报告客户端CPU负载、客户端内存使用等指标。</p><p>自信地构建— <a class="signup" href="https://lp.logrocket.com/blg/javascript-signup" target="_blank" rel="noopener noreferrer">开始免费监控</a>。</p></div>


</div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
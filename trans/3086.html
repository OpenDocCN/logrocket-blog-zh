<html>
<head>
<title>How to extend enums in TypeScript - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>如何在 TypeScript - LogRocket 博客中扩展枚举</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/extend-enums-typescript/#0001-01-01">https://blog.logrocket.com/extend-enums-typescript/#0001-01-01</a></blockquote><div><article class="article-post">
<p>TypeScript 深受开发人员社区的喜爱，原因有很多，其中之一是因为它提供了对其中编写的代码的静态检查。</p>
<p>在开发生命周期的早期发现问题可以节省调试随机、模糊错误的时间，这些错误有时会在使用像 JavaScript 这样的动态语言时突然出现。</p>
<p>TypeScript 有助于提高代码的可预测性和文档化程度，使重构更加容易，并有助于减少您在生产应用程序运行时可能遇到的潜在错误。在过去的五年里，它 93%的开发者满意率和暴涨的<a href="https://www.typescriptlang.org/" target="_blank" rel="noopener">使用率</a>证明了它的受欢迎程度和影响力。</p>
<p>对 TypeScript 至关重要的一种语言机制是枚举。在本文中，我们将讨论:</p>

<h2 id="what-are-enums">TypeScript 中的枚举是什么？</h2>
<p>有趣的是，枚举不像大多数 TypeScript 那样是打字的一个特性——事实上，它们是增强语言的少数新特性之一。</p>
<p>枚举允许开发人员为变量定义一组严格的选项。例如:</p>
<pre class="language-typescript hljs">enum Door {
  Open,
  Closed,
  Ajar // half open, half closed
}
</pre>
<p>enum 默认为 number enums，所以上面的 enum 本质上是一个以<code>0</code>、<code>1</code>和<code>2</code>为键的对象，这一点我们可以在<a href="https://dev.to/kealanparr/compiling-vs-transpiling-3h9i" target="_blank" rel="noopener"> transpiled </a> JavaScript 代码中看到。</p>
<pre class="language-typescript hljs">"use strict";
var Door;
(function (Door) {
    Door[Door["Open"] = 0] = "Open";
    Door[Door["Closed"] = 1] = "Closed";
    Door[Door["Ajar"] = 2] = "Ajar"; // half open, half closed
})(Door || (Door = {}));
console.log(Door.FullyOpened);
</pre>
<p>在 TypeScript 中，还可以使用字符串枚举，如下所示:</p>
<pre class="language-typescript hljs">enum Door {
  Open = "open",
  Closed = "closed",
  Ajar = "ajar" // half open, half closed
}
</pre>
<p>如果您随后使用这个<code>Door</code>枚举，您可以确保变量只使用枚举中指定的三个选项。所以，你不可能偶然错误地赋值，或者这样容易地产生错误。</p>
<p>如果您尝试使用另一个变量，它将抛出如下类型错误:</p>
<pre class="language-typescript hljs">enum Door {
  Open = "open",
  Closed = "closed",
  Ajar = "ajar" // half open, half closed
}
console.log(Door.FulyOpened)
</pre>
<p><code>Property 'FullyOpened' does not exist on type 'typeof Door'.</code></p>
<h2 id="why-would-you-need-to-extend-an-enum">为什么我们需要扩展一个枚举？</h2>
<p>扩展是面向对象的四个支柱之一，也是 TypeScript 中的一个语言特性。扩展一个枚举允许你复制一个变量定义并添加一些额外的东西。</p>
<p>例如，您可能会尝试这样做:</p>
<pre class="language-typescript hljs">enum Door {
  Open = "open",
  Closed = "closed",
  Ajar = "ajar" // half open, half closed
}

enum DoorFrame extends Door { // This will not work!
  Missing = "noDoor"
}

console.log(DoorFrame.Missing)
</pre>
<p>然后，我们可以在一个枚举中添加额外的属性，或者甚至将两个枚举合并在一起，仍然可以在我们的枚举上获得严格的类型，同时还可以在它们被定义后更改它们。</p>
<p>但是请注意，上面的代码片段不起作用！它无法传输文件并抛出四个不同的错误。</p>
<h2 id="can-you-extend-enums">你能扩展 enums 吗？</h2>
<p>简单的回答是不，你不能扩展枚举，因为 TypeScript 没有提供语言特性来扩展它们。但是，您可以利用一些变通方法来实现继承所能实现的效果。</p>
<h3>TypeScript 中的类型联合</h3>
<pre class="language-typescript hljs">enum Door {
  Open = "open",
  Closed = "closed",
  Ajar = "ajar" // half open, half closed
}

enum DoorFrame {
  Missing = "noDoor"
}

type DoorState = Door | DoorFrame; 

let door: DoorState;
door = Door.Ajar
console.log(door) // 'ajar'
door = DoorFrame.Missing
console.log(door) // 'noDoor'
</pre>
<p>在上面的代码块中，我们使用了一个<a href="https://www.typescriptlang.org/docs/handbook/unions-and-intersections.html">联合类型</a>。该联合的作用就像一个“或”，这仅仅意味着<code>DoorState</code>类型要么是<code>Door</code>类型，要么是<code>DoorFrame</code>类型。</p>
<p>这意味着<code>DoorState</code>可以互换使用两个枚举中的任何一个变量。</p>
<p>然而，一个重要的警告是，它只能使用两个枚举的类型。在 TypeScript 中，不可能使用像<code>ajar</code>和<code>noDoor</code>这样的值。你需要使用像<code>DoorFrame.Missing</code>这样的类型，这是一个限制。</p>
<h3>扩展语法</h3>
<p>我们在前面的 transpiled 代码中已经看到，enum 变成了一个 JavaScript 对象，带有您的 enum 指定的键和值。</p>
<p>在 TypeScript 中，如果我们愿意，我们可以编写纯 JavaScript。事实上，这是 TypeScript 的一大优势。例如，您可以将所有的<code>file.js</code>重命名为<code>file.ts</code>，并关闭对代码的编译器检查。只要运行编译/传输步骤，一切都会很好，代码没有任何变化。</p>
<p>我们可以利用这一点，因为我们知道当我们的 enum 转换成 JavaScript 时，它将是一个 JavaScript 对象文字，并使用 spread 语法，<a href="https://wringing.it/blog/typescript-enum-composition/" target="_blank" rel="noopener">如下所示</a>:</p>
<pre class="language-typescript hljs">enum Move {
  LEFT = 'Left',
  RIGHT = 'Right',
  FORWARD = 'Forward',
  BACKWARD = 'Backward'
}
const myMove = {
  ...Move,
  JUMP: 'Jump'
}
</pre>
<p>然而，这个解决方案已经被描述过了，因为它不如 union 类型的解决方案好，因为它不如我们的第一个解决方案健壮。这是因为枚举的“组合”发生在运行时，而当我们使用类型联合时，类型检查可以发生在编译/转换时，而不是运行时。</p>
<h2 id="typescript-enum-best-practices">TypeScript 枚举最佳实践</h2>
<p>我们已经讨论了如何在 Typescript 中扩展枚举，但是枚举并不是解决所有问题的灵丹妙药。如果使用不当，枚举会降低代码的可读性、可伸缩性和可维护性，而不是改善代码。</p>
<p>因此，让我们介绍一些在 TypeScript 中使用枚举时的最佳实践和常用模式。</p>
<h3>1.避免异源枚举</h3>
<p>我已经解释了我们可以有这样的字符串枚举:</p>
<pre class="language-typescript hljs">enum Seasons {
  Summer = "Summer",
  Winter = "Winter",
  Spring = "Spring",
  Fall = "Fall"
}
</pre>
<p>除此之外还有这样的数字枚举:</p>
<pre class="language-typescript hljs">enum Decision {
  Yes,
  No
}
</pre>
<p>但是，还有第三种类型的枚举，你可能不知道，称为<a href="https://www.typescriptlang.org/docs/handbook/enums.html#heterogeneous-enums" target="_blank" rel="noopener">异构枚举</a>。这是您可以在同一个枚举中使用字符串和数字枚举的地方。</p>
<p>文档中的一个例子是:</p>
<pre class="language-typescript hljs">enum BooleanLikeHeterogeneousEnum {
  No = 0,
  Yes = "YES",
}
</pre>
<p>值得注意的是，即使是文档也不鼓励这种做法，因为在这种情况下，使用这种方法意味着您可能需要:</p>
<ul>
<li>重新考虑这两个变量之间的关系</li>
<li>创建两个单独的枚举</li>
<li>使它们都符合一种数据类型</li>
</ul>
<h3>2.“枚举作为配置”反模式</h3>
<p>有时，代码功能可能会被强制遵守枚举选项，这可能会很快变成反模式。</p>
<p>下面是一个例子:</p>
<pre class="language-typescript hljs">enum Operators {
  Add,
  Subtract
}
function calculate(op: Operators, firstNumber: number, secondNumber: number) {
  switch(op) {
    case Operators.Add: return firstNumber + secondNumber
    case Operators.Subtract: return firstNumber - secondNumber
  }
} 
</pre>
<p>上面的代码看起来相当简单和安全，因为我们的例子确实是简单和安全的。</p>
<p>但是在大型代码库中，当您像这样将实现细节严格绑定到枚举类型时，可能会导致一些问题:</p>
<ul>
<li>您创建了两个真实的来源(如果枚举发生变化，枚举和函数都需要更新)</li>
<li>这种模式将在代码中传播元数据</li>
<li>代码块不再是通用的</li>
</ul>
<p>如果您需要做类似上面的事情，一个更简单(也更简洁)的模式可能是这样的。</p>
<pre class="language-typescript hljs">const Operators = {

  Add: {
    id: 0,
    apply(firstNumber: number, secondNumber: number) { return firstNumber + secondNumber }
  },

  Subtract: {
    id: 1,
    apply(firstNumber: number, secondNumber: number) { return firstNumber - secondNumber }
  }
}
</pre>
<p>你可以在这里或者这里阅读更多关于这个模式的内容<a href="https://medium.com/thousandeyes-engineering/the-distributed-enum-anti-pattern-3ebb23cbc5d8" target="_blank" rel="noopener">。</a></p>
<h3>3.枚举最能代表的数据类型</h3>
<p>有一种方法可以将代码中使用的不同类型的数据组合在一起:离散变量或连续变量。</p>
<p>离散变量是在它们的表示之间有空格的数据，并且只有几个表示。这里有几个例子:</p>
<ul>
<li>一周中的几天<ul>
<li>孟人</li>
<li>周二</li>
<li>结婚</li>
<li>周四</li>
<li>Fri</li>
<li>坐</li>
<li>太阳</li>
</ul>
</li>
<li>季节<ul>
<li>夏天</li>
<li>冬天</li>
<li>春天</li>
<li>秋天</li>
</ul>
</li>
</ul>
<p>离散数据是放置在枚举中的一个很好的候选者，它可以帮助代码清晰和重用。连续数据是指落入连续序列中的没有间隙的数据，如数字。根据测量结果，这些参数可能会有所不同:</p>
<ul>
<li>某人的体重</li>
<li>汽车的速度</li>
</ul>
<p>离散数据是很好的候选数据，可以在枚举中使用，而连续数据不应该在枚举中使用。你能想象年龄的枚举吗？</p><div class="code-block code-block-54">
<hr/>
<h3>更多来自 LogRocket 的精彩文章:</h3>

<hr/></div>
<pre class="language-typescript hljs">enum Age {
  Zero,
  One,
  Two,
  Three,
  Four,
  Five,
  Six
}
</pre>
<p>这不是一个放置在 enum 中的好选择，因为它需要不断地更新和修改，导致维护的噩梦。</p>
<p>您应该只在枚举中添加离散的、高度稳定的数据类型。</p>
<h2 id="conclusion">结论</h2>
<p>我希望这篇文章对你有所帮助，让你更好地理解什么是枚举，它们解决的问题，合并两个枚举的用例，以及如何实现它！黑客快乐。</p><div class="code-block code-block-21">
<div class="blog-plug inline-plug typescript-plug"><h2><a class="signup" href="https://lp.logrocket.com/blg/typescript-signup" target="_blank" rel="noopener noreferrer"> LogRocket </a>:全面了解您的网络和移动应用</h2>
<a href="https://lp.logrocket.com/blg/typescript-signup" class="signup" target="_blank" rel="noopener noreferrer"><img class="alignnone size-full wp-image-46 jetpack-lazy-image" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/><noscript><img data-lazy-fallback="1" class="alignnone size-full wp-image-46" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/></noscript></a>
<p>LogRocket 是一个前端应用程序监控解决方案，可以让您回放问题，就像问题发生在您自己的浏览器中一样。LogRocket 不需要猜测错误发生的原因，也不需要向用户询问截图和日志转储，而是让您重放会话以快速了解哪里出错了。它可以与任何应用程序完美配合，不管是什么框架，并且有插件可以记录来自 Redux、Vuex 和@ngrx/store 的额外上下文。</p>
<p>除了记录 Redux 操作和状态，LogRocket 还记录控制台日志、JavaScript 错误、堆栈跟踪、带有头+正文的网络请求/响应、浏览器元数据和自定义日志。它还使用 DOM 来记录页面上的 HTML 和 CSS，甚至为最复杂的单页面和移动应用程序重新创建像素级完美视频。</p>
<a class="signup" href="https://lp.logrocket.com/blg/typescript-signup" target="_blank" rel="noopener noreferrer">Try it for free</a><p>.</p></div>
</div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
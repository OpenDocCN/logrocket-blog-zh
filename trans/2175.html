<html>
<head>
<title>React Tracked: Manage state and prevent excessive re-rendering - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>React Tracked:管理状态并防止过多的重新渲染</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/react-tracked-manage-state-prevent-excessive-re-rendering/#0001-01-01">https://blog.logrocket.com/react-tracked-manage-state-prevent-excessive-re-rendering/#0001-01-01</a></blockquote><div><article class="article-post">
<p>在过去的几年中，React 中的状态管理经历了重大的演变。有了像内置 React Context API 和 React Redux 这样的解决方案，保持全局状态和跟踪变化变得前所未有的简单。然而，在实现这些工具时，一个持续的挑战是优化性能和防止组件不必要的重新呈现。</p>
<p>而在较小的应用程序中，过多的重新渲染可能不会引起注意或者没有负面影响，随着应用程序的增长，每次重新渲染都可能导致 UI 延迟或滞后。在本教程中，我们将使用<a href="https://github.com/dai-shi/react-tracked"> React Tracked </a>，一个用于状态使用跟踪的库，通过防止不必要的重新渲染来优化我们的应用程序的性能。</p>
<h2>安装 React Tracked</h2>
<p>首先，在您的机器上建立一个新的 React 项目。在终端中打开项目，并添加以下命令来安装 React 跟踪库:</p>
<pre class="language-terminal hljs">yarn add react-tracked scheduler 
</pre>
<p>现在，让我们通过给它以下结构来清理我们的项目:</p>
<p><img data-attachment-id="67549" data-permalink="https://blog.logrocket.com/react-tracked-manage-state-prevent-excessive-re-rendering/react-tracked-project-structure/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2021/09/react-tracked-project-structure.png" data-orig-size="191,322" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="react-tracked-project-structure" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2021/09/react-tracked-project-structure-178x300.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2021/09/react-tracked-project-structure.png" decoding="async" class="aligncenter wp-image-67549 size-full jetpack-lazy-image" src="../Images/4237ad8432b94324faf5ed752bfdff48.png" alt="React Tracked Project Structure" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2021/09/react-tracked-project-structure.png 191w, https://blog.logrocket.com/wp-content/uploads/2021/09/react-tracked-project-structure-178x300.png 178w" data-lazy-sizes="(max-width: 191px) 100vw, 191px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2021/09/react-tracked-project-structure.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2021/09/react-tracked-project-structure.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="67549" data-permalink="https://blog.logrocket.com/react-tracked-manage-state-prevent-excessive-re-rendering/react-tracked-project-structure/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2021/09/react-tracked-project-structure.png" data-orig-size="191,322" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="react-tracked-project-structure" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2021/09/react-tracked-project-structure-178x300.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2021/09/react-tracked-project-structure.png" decoding="async" loading="lazy" class="aligncenter wp-image-67549 size-full" src="../Images/4237ad8432b94324faf5ed752bfdff48.png" alt="React Tracked Project Structure" srcset="https://blog.logrocket.com/wp-content/uploads/2021/09/react-tracked-project-structure.png 191w, https://blog.logrocket.com/wp-content/uploads/2021/09/react-tracked-project-structure-178x300.png 178w" sizes="(max-width: 191px) 100vw, 191px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2021/09/react-tracked-project-structure.png"/></noscript>
<h2>设置我们的应用程序</h2>
<p>让我们比较一下 React Tracked 和共享状态的普通 React 实现。我们将创建一个简单的全局上下文，它有两个计数器组件，每个组件使用一个值。</p>
<p>在<code>App.js</code>中添加以下代码:</p>
<pre>import Counter1 from "./Counter1";
import Counter2 from "./Counter2";

import { SharedStateProvider } from "./store";

function App() {
  return (
    &lt;&gt;
      &lt;SharedStateProvider&gt;
        &lt;div
          style={{
            display: "flex",
            flexDirection: "row",
            border: "1px solid black",
            justifyContent: "space-around",
          }}
        &gt;
          &lt;Counter1 /&gt;
          &lt;Counter2 /&gt;
        &lt;/div&gt;
      &lt;/SharedStateProvider&gt;
    &lt;/&gt;
  );
}

export default App;
</pre>
<p>要创建计数器组件，请在每个文件中添加以下代码:</p>
<h3><code>Counter1</code></h3>
<pre>import React from "react";
import { useSharedState } from "./store";

export default function Counter1() {
  const [state, setState] = useSharedState();

  const increment = () =&gt; {
    setState((prev) =&gt; ({ ...prev, count1: prev.count1 + 1 }));
  };

  return (
    &lt;div&gt;
      {state.count1}
      {console.log("render counter 1")}

      &lt;button onClick={increment}&gt;Increment count1&lt;/button&gt;

    &lt;/div&gt;
  );
}
</pre>
<h3><code>Counter2</code></h3>
<pre>import React from "react";
import { useSharedState } from "./store";

export default function Counter2() {
  const [state, setState] = useSharedState();

  const increment = () =&gt; {
    setState((prev) =&gt; ({ ...prev, count2: prev.count2 + 1 }));
  };

  return (
    &lt;div&gt;
      {state.count1}
      {console.log("render counter 2")}

      &lt;button onClick={increment}&gt;Increment count2&lt;/button&gt;

    &lt;/div&gt;
  );
}
</pre>
<h3><code>store.js</code></h3>
<p>最后，让我们创建我们的<code>store.js</code>文件，它使用全局计数器上下文和计数器组件中状态的<code>useSharedState()</code>钩子:</p>
<pre>import React, { createContext, useState, useContext } from "react";

const initialState = {
  count1: 0,
  count2: 0,
};

const useValue = () =&gt; useState(initialState);

const MyContext = createContext(null);

export const useSharedState = () =&gt; {
  const value = useContext(MyContext);
  return value;
};

export const SharedStateProvider = ({ children }) =&gt; (
  &lt;MyContext.Provider value={useValue()}&gt;{children}&lt;/MyContext.Provider&gt;
);
</pre>
<p>要运行该项目，请添加以下命令:</p>
<pre class="language-terminal hljs">yarn start
</pre>
<p>现在，我们将在浏览器屏幕上看到以下输出:</p>
<p><img data-attachment-id="67551" data-permalink="https://blog.logrocket.com/react-tracked-manage-state-prevent-excessive-re-rendering/react-tracked-counter-increment-button/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2021/09/react-tracked-counter-increment-button.png" data-orig-size="681,56" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="react-tracked-counter-increment-button" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2021/09/react-tracked-counter-increment-button-300x25.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2021/09/react-tracked-counter-increment-button.png" decoding="async" class="aligncenter wp-image-67551 size-full jetpack-lazy-image" src="../Images/d51f23094136cbb9ff0cee135ff9e53f.png" alt="React Tracked Counter Increment Button" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2021/09/react-tracked-counter-increment-button.png 681w, https://blog.logrocket.com/wp-content/uploads/2021/09/react-tracked-counter-increment-button-300x25.png 300w" data-lazy-sizes="(max-width: 681px) 100vw, 681px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2021/09/react-tracked-counter-increment-button.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2021/09/react-tracked-counter-increment-button.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="67551" data-permalink="https://blog.logrocket.com/react-tracked-manage-state-prevent-excessive-re-rendering/react-tracked-counter-increment-button/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2021/09/react-tracked-counter-increment-button.png" data-orig-size="681,56" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="react-tracked-counter-increment-button" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2021/09/react-tracked-counter-increment-button-300x25.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2021/09/react-tracked-counter-increment-button.png" decoding="async" loading="lazy" class="aligncenter wp-image-67551 size-full" src="../Images/d51f23094136cbb9ff0cee135ff9e53f.png" alt="React Tracked Counter Increment Button" srcset="https://blog.logrocket.com/wp-content/uploads/2021/09/react-tracked-counter-increment-button.png 681w, https://blog.logrocket.com/wp-content/uploads/2021/09/react-tracked-counter-increment-button-300x25.png 300w" sizes="(max-width: 681px) 100vw, 681px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2021/09/react-tracked-counter-increment-button.png"/></noscript>
<p>打开浏览器控制台，按下每个<strong>增量</strong>按钮三次。我们将收到以下输出:</p>
<p><img data-attachment-id="67556" data-permalink="https://blog.logrocket.com/react-tracked-manage-state-prevent-excessive-re-rendering/increment-button-re-render-output/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2021/09/increment-button-re-render-output.png" data-orig-size="242,248" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="increment-button-re-render-output" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2021/09/increment-button-re-render-output.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2021/09/increment-button-re-render-output.png" decoding="async" class="aligncenter wp-image-67556 size-full jetpack-lazy-image" src="../Images/7762d24aca562c548508e4fb25678c97.png" alt="Increment Button Re-render Output" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2021/09/increment-button-re-render-output.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2021/09/increment-button-re-render-output.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="67556" data-permalink="https://blog.logrocket.com/react-tracked-manage-state-prevent-excessive-re-rendering/increment-button-re-render-output/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2021/09/increment-button-re-render-output.png" data-orig-size="242,248" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="increment-button-re-render-output" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2021/09/increment-button-re-render-output.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2021/09/increment-button-re-render-output.png" decoding="async" loading="lazy" class="aligncenter wp-image-67556 size-full" src="../Images/7762d24aca562c548508e4fb25678c97.png" alt="Increment Button Re-render Output" data-original-src="https://blog.logrocket.com/wp-content/uploads/2021/09/increment-button-re-render-output.png"/></noscript>
<p>无论状态是否更新，每个组件都会重新呈现。理想情况下，组件应该只在状态改变时才重新呈现。</p>
<p>在我们的示例中，总共应该有六次重新渲染，两个组件都有三次，但是，我们得到了 12 次，这表明两个组件在每次单击时都重新渲染了。</p>
<h2>呈现一个大列表</h2>
<p>现在，让我们尝试呈现一个大的元素列表。将下面的代码添加到<code>Counter1</code>和<code>Counter2</code>中，在每个组件中生成 10，000 个随机数的列表:</p>
<pre>import React, { useEffect, useState } from "react";
import { useSharedState } from "./store";

export default function Counter1() {
  const [state, setState] = useSharedState();

  const [randomNumbers, setRandomNumbers] = useState([]);
  const increment = () =&gt; {
    setState((prev) =&gt; ({ ...prev, count1: prev.count1 + 1 }));
  };
  const generateHugeList = () =&gt; {
    let list = [];
    for (let i = 0; i &lt; 10000; i++) {
      list.push(Math.floor(Math.random() * 10));
    }
    setRandomNumbers(list);
  };
  useEffect(() =&gt; {
   generateHugeList();
  }, []);
  return (
    &lt;div&gt;
      {state.count1}
      {console.log("render counter 1")}

      &lt;button onClick={increment}&gt;Increment count1&lt;/button&gt;
      {randomNumbers.map((number) =&gt; {
        return &lt;p&gt;{number}&lt;/p&gt;;
      })}
    &lt;/div&gt;
  );
}
</pre>
<p>计数器组件在浏览器上呈现列表，产生类似如下的输出:</p>
<p><img data-attachment-id="67560" data-permalink="https://blog.logrocket.com/react-tracked-manage-state-prevent-excessive-re-rendering/random-numbers-counter-components/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2021/09/random-numbers-counter-components.png" data-orig-size="681,611" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="random-numbers-counter-components" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2021/09/random-numbers-counter-components-300x269.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2021/09/random-numbers-counter-components.png" decoding="async" class="aligncenter wp-image-67560 size-full jetpack-lazy-image" src="../Images/fecf6792057fdd65754b096de72bf791.png" alt="Random Numbers Counter Components" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2021/09/random-numbers-counter-components.png 681w, https://blog.logrocket.com/wp-content/uploads/2021/09/random-numbers-counter-components-300x269.png 300w" data-lazy-sizes="(max-width: 681px) 100vw, 681px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2021/09/random-numbers-counter-components.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2021/09/random-numbers-counter-components.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="67560" data-permalink="https://blog.logrocket.com/react-tracked-manage-state-prevent-excessive-re-rendering/random-numbers-counter-components/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2021/09/random-numbers-counter-components.png" data-orig-size="681,611" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="random-numbers-counter-components" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2021/09/random-numbers-counter-components-300x269.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2021/09/random-numbers-counter-components.png" decoding="async" loading="lazy" class="aligncenter wp-image-67560 size-full" src="../Images/fecf6792057fdd65754b096de72bf791.png" alt="Random Numbers Counter Components" srcset="https://blog.logrocket.com/wp-content/uploads/2021/09/random-numbers-counter-components.png 681w, https://blog.logrocket.com/wp-content/uploads/2021/09/random-numbers-counter-components-300x269.png 300w" sizes="(max-width: 681px) 100vw, 681px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2021/09/random-numbers-counter-components.png"/></noscript>
<p>随着这些新元素的引入，我们的应用程序需要更多的时间来加载:</p>
<p><img data-attachment-id="67562" data-permalink="https://blog.logrocket.com/react-tracked-manage-state-prevent-excessive-re-rendering/application-load-time-new-elements/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2021/09/application-load-time-new-elements.png" data-orig-size="643,38" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="application-load-time-new-elements" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2021/09/application-load-time-new-elements-300x18.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2021/09/application-load-time-new-elements.png" decoding="async" class="aligncenter wp-image-67562 size-full jetpack-lazy-image" src="../Images/0a30e819af63b883b2cd68beede653f0.png" alt="Application Load Time New Elements" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2021/09/application-load-time-new-elements.png 643w, https://blog.logrocket.com/wp-content/uploads/2021/09/application-load-time-new-elements-300x18.png 300w" data-lazy-sizes="(max-width: 643px) 100vw, 643px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2021/09/application-load-time-new-elements.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2021/09/application-load-time-new-elements.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="67562" data-permalink="https://blog.logrocket.com/react-tracked-manage-state-prevent-excessive-re-rendering/application-load-time-new-elements/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2021/09/application-load-time-new-elements.png" data-orig-size="643,38" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="application-load-time-new-elements" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2021/09/application-load-time-new-elements-300x18.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2021/09/application-load-time-new-elements.png" decoding="async" loading="lazy" class="aligncenter wp-image-67562 size-full" src="../Images/0a30e819af63b883b2cd68beede653f0.png" alt="Application Load Time New Elements" srcset="https://blog.logrocket.com/wp-content/uploads/2021/09/application-load-time-new-elements.png 643w, https://blog.logrocket.com/wp-content/uploads/2021/09/application-load-time-new-elements-300x18.png 300w" sizes="(max-width: 643px) 100vw, 643px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2021/09/application-load-time-new-elements.png"/></noscript>
<p>第一次加载时，CPU 使用率跃升至 100 %:</p>
<p><img data-attachment-id="67574" data-permalink="https://blog.logrocket.com/react-tracked-manage-state-prevent-excessive-re-rendering/cpu-usage-graph-first-load/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2021/09/cpu-usage-graph-first-load.png" data-orig-size="458,107" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="cpu-usage-graph-first-load" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2021/09/cpu-usage-graph-first-load-300x70.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2021/09/cpu-usage-graph-first-load.png" decoding="async" class="aligncenter wp-image-67574 size-full jetpack-lazy-image" src="../Images/84649d7b011f7af78fd461397fcfdef4.png" alt="CPU Usage Graph First Load" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2021/09/cpu-usage-graph-first-load.png 458w, https://blog.logrocket.com/wp-content/uploads/2021/09/cpu-usage-graph-first-load-300x70.png 300w" data-lazy-sizes="(max-width: 458px) 100vw, 458px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2021/09/cpu-usage-graph-first-load.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2021/09/cpu-usage-graph-first-load.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="67574" data-permalink="https://blog.logrocket.com/react-tracked-manage-state-prevent-excessive-re-rendering/cpu-usage-graph-first-load/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2021/09/cpu-usage-graph-first-load.png" data-orig-size="458,107" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="cpu-usage-graph-first-load" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2021/09/cpu-usage-graph-first-load-300x70.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2021/09/cpu-usage-graph-first-load.png" decoding="async" loading="lazy" class="aligncenter wp-image-67574 size-full" src="../Images/84649d7b011f7af78fd461397fcfdef4.png" alt="CPU Usage Graph First Load" srcset="https://blog.logrocket.com/wp-content/uploads/2021/09/cpu-usage-graph-first-load.png 458w, https://blog.logrocket.com/wp-content/uploads/2021/09/cpu-usage-graph-first-load-300x70.png 300w" sizes="(max-width: 458px) 100vw, 458px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2021/09/cpu-usage-graph-first-load.png"/></noscript>
<p>React 将在第一次渲染时将所有元素绘制到浏览器 DOM 中，因此 100%的 CPU 使用率是典型的。但是，在单击每个计数器组件上的<strong>增量</strong>按钮后，CPU 使用率保持在 100 %,这表明两个计数器都在不断地重新呈现:</p>
<p><img data-attachment-id="67784" data-permalink="https://blog.logrocket.com/react-tracked-manage-state-prevent-excessive-re-rendering/react-re-render-graph/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2021/09/react-re-render-graph.gif" data-orig-size="730,319" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="react-re-rendering-cpu-usage-graph" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2021/09/react-re-render-graph-300x131.gif" data-large-file="https://blog.logrocket.com/wp-content/uploads/2021/09/react-re-render-graph.gif" decoding="async" class="aligncenter wp-image-67784 size-full jetpack-lazy-image" src="../Images/1971f8403f5186c34da3f207bc660ad0.png" alt="React Re-rendering CPU Usage Graph" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2021/09/react-re-render-graph.gif?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2021/09/react-re-render-graph.gif"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="67784" data-permalink="https://blog.logrocket.com/react-tracked-manage-state-prevent-excessive-re-rendering/react-re-render-graph/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2021/09/react-re-render-graph.gif" data-orig-size="730,319" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="react-re-rendering-cpu-usage-graph" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2021/09/react-re-render-graph-300x131.gif" data-large-file="https://blog.logrocket.com/wp-content/uploads/2021/09/react-re-render-graph.gif" decoding="async" loading="lazy" class="aligncenter wp-image-67784 size-full" src="../Images/1971f8403f5186c34da3f207bc660ad0.png" alt="React Re-rendering CPU Usage Graph" data-original-src="https://blog.logrocket.com/wp-content/uploads/2021/09/react-re-render-graph.gif"/></noscript>
<p> </p>
<h2 id="reacttracked">防止重新渲染的选项</h2>
<p>防止重新渲染的一个流行方法是<a href="https://blog.logrocket.com/getting-started-react-redux-firebase/">在 React Redux </a>中使用选择器，这是订阅 Redux 存储并在调度动作时运行的函数。选择器使用<code>===</code>作为严格的质量检查，每当数据改变时重新呈现组件。虽然这个过程对变量很有效，但每次数据改变时返回新引用的函数会不断地重新呈现。</p>
<p>另一方面，React Tracked 包装了<span class=" author-d-iz88z86z86za0dz67zz78zz78zz74zz68zjz80zz71z9iz90z8qz88zz81zgg0oaqdz77zz70zbz75zz76zsz88znz66zcz85zxm8z122zz65zaz90zz83zi">上下文对象，并通过使用 JavaScript 代理的</span>返回自己的提供者，以跟踪状态的单个属性的变化。</p>
<p>代理包装单个对象，截取或改变其基本操作。React Tracked 实现了检查组件内部状态的代理，只有当信息改变时才重新呈现它。要查看代理的运行情况，让我们在应用程序中实现 React Tracked。</p>
<h2 id="reacttracked">呈现跟踪了反应的列表</h2>
<p>首先，我们需要通过添加以下代码来修改我们之前创建的<code>store.js</code>文件:</p>
<pre>import { useState } from "react";
import { createContainer } from "react-tracked";

const initialState = {
  count1: 0,
  count2: 0,
};

const useMyState = () =&gt; useState(initialState);

export const { Provider: SharedStateProvider, useTracked: useSharedState } =
  createContainer(useMyState);
</pre>
<p>在上面的代码中，我们导入了<code>createContainer()</code>，它返回一个 React 跟踪的提供者。<code>useTracked</code>钩子为我们的状态创建一个代理。</p>
<p>现在，让我们重新构建项目，并将之前的输出与 React Tracked 的输出进行比较:</p>
<p> </p>
<p><img data-attachment-id="67790" data-permalink="https://blog.logrocket.com/react-tracked-manage-state-prevent-excessive-re-rendering/react-tracked-cpu-usage-graph/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2021/09/react-tracked-cpu-usage-graph.gif" data-orig-size="730,319" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="react-tracked-cpu-usage-graph" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2021/09/react-tracked-cpu-usage-graph-300x131.gif" data-large-file="https://blog.logrocket.com/wp-content/uploads/2021/09/react-tracked-cpu-usage-graph.gif" decoding="async" class="aligncenter wp-image-67790 size-full jetpack-lazy-image" src="../Images/fc8b783295f6c492d0036d02a146aa27.png" alt="React Tracked CPU Usage Graph" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2021/09/react-tracked-cpu-usage-graph.gif?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2021/09/react-tracked-cpu-usage-graph.gif"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="67790" data-permalink="https://blog.logrocket.com/react-tracked-manage-state-prevent-excessive-re-rendering/react-tracked-cpu-usage-graph/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2021/09/react-tracked-cpu-usage-graph.gif" data-orig-size="730,319" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="react-tracked-cpu-usage-graph" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2021/09/react-tracked-cpu-usage-graph-300x131.gif" data-large-file="https://blog.logrocket.com/wp-content/uploads/2021/09/react-tracked-cpu-usage-graph.gif" decoding="async" loading="lazy" class="aligncenter wp-image-67790 size-full" src="../Images/fc8b783295f6c492d0036d02a146aa27.png" alt="React Tracked CPU Usage Graph" data-original-src="https://blog.logrocket.com/wp-content/uploads/2021/09/react-tracked-cpu-usage-graph.gif"/></noscript>
<p>例如，当我们选择<strong>递增计数 1 </strong>按钮时，在第一次渲染时，<code>Counter1</code>和<code>Counter2</code>都会被渲染。然而，在随后的点击中，只有<code>Counter1</code>被重新渲染，减少了 CPU 的使用，提高了我们应用的性能。</p>
<h2>结论</h2>
<p>在本教程中，我们探讨了由不必要的重新渲染导致的不必要的性能缺陷。虽然像 React Redux 和 React Context API 这样的工具可以很容易地跟踪应用程序状态的变化，但它们并没有提供一个简单的解决方案来最小化重新呈现。</p>
<p>使用 React Tracked 库，我们构建了一个应用程序，并最大限度地减少了重新呈现计数器组件的次数，从而减少了 CPU 的使用并提高了整体性能。我希望你喜欢这个教程！</p><div class="code-block code-block-17">
<div class="blog-plug inline-plug react-plug" vwo-el-id="26283398190">
<h2 vwo-el-id="41600691720"><a href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener"> LogRocket </a>:全面了解您的生产 React 应用</h2><p>调试 React 应用程序可能很困难，尤其是当用户遇到难以重现的问题时。如果您对监视和跟踪 Redux 状态、自动显示 JavaScript 错误以及跟踪缓慢的网络请求和组件加载时间感兴趣，</p><a href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" vwo-el-id="19356441070">try LogRocket</a><p>. </p><a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="19356441380">
<img class="first-react-image alignnone size-full wp-image-46 jetpack-lazy-image jetpack-lazy-image--handled" src="../Images/f300c244a1a1cf916df8b4cb02bec6c6.png" vwo-el-id="18272717540" data-lazy-loaded="1" data-original-src="https://files.readme.io/27c94e7-Image_2017-06-05_at_9.46.04_PM.png"/>
</a>
<a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="19356441690">
<img class="second-react-image alignnone size-full wp-image-46 jetpack-lazy-image jetpack-lazy-image--handled" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" vwo-el-id="30720362350" data-lazy-loaded="1" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/>
</a>
<p vwo-el-id="28675660440" class="">LogRocket 结合了会话回放、产品分析和错误跟踪，使软件团队能够创建理想的 web 和移动产品体验。这对你来说意味着什么？</p>
<p>LogRocket 不是猜测错误发生的原因，也不是要求用户提供截图和日志转储，而是让您回放问题，就像它们发生在您自己的浏览器中一样，以快速了解哪里出错了。</p>
<p>不再有嘈杂的警报。智能错误跟踪允许您对问题进行分类，然后从中学习。获得有影响的用户问题的通知，而不是误报。警报越少，有用的信号越多。</p>
<p vwo-el-id="28675660750">LogRocket Redux 中间件包为您的用户会话增加了一层额外的可见性。LogRocket 记录 Redux 存储中的所有操作和状态。</p>
<p vwo-el-id="28675661060">现代化您调试 React 应用的方式— <a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="40093418840">开始免费监控</a>。</p>
</div></div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
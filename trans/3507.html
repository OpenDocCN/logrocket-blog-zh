<html>
<head>
<title>Kotlin queue guide for Android </title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>for Android队列指南</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/kotlin-queue-guide-for-android/#0001-01-01">https://blog.logrocket.com/kotlin-queue-guide-for-android/#0001-01-01</a></blockquote><div><article class="article-post">
<p>Kotlin编程语言是Android开发的绝佳选择。然而，像任何编程语言一样，它<a href="https://blog.logrocket.com/kotlin-vs-java-android-development/#what-kotlin">需要考虑时间和空间的复杂性</a>并利用最佳方法来解决这些问题。因此，扎实掌握Kotlin中的数据结构和算法将对保证更好的代码效率起到至关重要的作用。</p>
<p>其中一个数据结构是Kotlin队列，这是一个集合接口，用于按照FIFO概念存储和删除数据，这意味着第一个进来的值将是第一个出去的值。在本文中，我们将深入探讨Kotlin队列，涵盖不同的类型及其优点。要跟随本教程，您需要以下内容:</p>
<ul>
<li>科特林的基础知识</li>
<li>安装了Android Studio或IntelliJ IDE</li>
</ul>
<h2 id="tableofcontents">目录</h2>

<p>我们开始吧！</p>
<h2 id="what-kotlin-queue">什么是科特林队列？</h2>
<p>队列是Kotlin中的一种接口集合，它使您能够根据自己的偏好以更有效的方式组织数据。队列接口最流行的实现是<code><a href="https://developer.android.com/reference/kotlin/java/util/LinkedList">LinkedList</a></code>，其他的包括<code>ArrayDeque</code>和<code>PriorityQueue</code>。</p>
<h2 id="why-need-queue-android-development">为什么我们在Android开发中需要队列？</h2>
<p>队列在Android开发中的重要性怎么强调都不为过。队列在存储数据或事件以供以后处理的任何地方起缓冲区的作用。本质上，队列是一个集合，用于在处理之前保存元素。</p>
<p>除了基本的收集操作之外，Kotlin队列还提供额外的操作，比如插入、提取和检查。这些方法有两种形式，一种是当操作失败时抛出异常，另一种是返回特殊值，如<code>null</code>、<code>true</code>或<code>false</code>。</p>
<p>Kotlin队列的一些重要应用包括多程序设计、网络和作业调度以及共享资源。多程序设计包括在系统主存中运行的多个程序；将这些程序组织成一个队列确保了系统的有序性。当一台计算机被安排一个接一个地执行特定数量的作业时，就发生了作业调度。这些分配给处理器的作业被组织成一个队列。最后，队列充当单个共享资源的等待列表。</p>
<p>此外，队列还用于交换机或路由器等网络设备中。另一个应用程序是邮件队列，它包含一个存储数据和控制邮件文件的目录。</p>
<p>在Kotlin中，我们可以使用队列轻松管理大量数据或处理进程间通信。</p>
<h2 id="type-queues-kotlin">科特林的队列类型</h2>
<p>Kotlin中有四种主要的队列类型:简单队列、优先级队列、循环队列和双端队列。</p>
<h3 id="simple-queue">简单队列</h3>
<p>在简单队列(也称为线性队列)中，元素的插入(称为入队操作)发生在后端，元素的移除(称为出队操作)发生在前端。</p>
<h3 id="priority-queue">优先队列</h3>
<p>优先级队列根据某种优先级排列队列中的元素。例如，如果具有最高值的元素具有优先级，它将创建一个值顺序递减的队列。或者，如果具有最低值的元素具有最高优先级，它将创建一个值顺序递增的队列。</p>
<h3 id="circular-queue">循环排队</h3>
<p>线性队列和循环队列实际上非常相似。循环队列中的元素充当一个环，这意味着最后一个元素连接到第一个元素。当有空闲空间时，内存的使用效率会更高。当队列中的特定位置没有元素时，可以将另一个元素添加到该位置。</p>
<h3 id="dequeue">出列</h3>
<p>在出列(也称为双端队列)中，可以在队列的两端插入或移除元素，这与只有一端的其他队列不同。然而，它可能不服从FIFO操作。</p>
<h2 id="implementation-queue">队列的实现</h2>
<p>要在Kotlin中实现我们的队列，我们有两个选择。首先，顺序分配涉及使用数组实现队列，我们可以用数组来组织有限数量的元素。另一方面，<code>LinkedList</code>分配涉及使用<code>LinkedList</code>实现队列，它可以组织无限数量的元素。</p>
<h2 id="creation-kotlin-queue">创建Kotlin队列</h2>
<p>下面的代码片段展示了使用<code>LinkedList</code>在Kotlin中实例化队列的过程:</p>
<pre class="language-kotlin hljs">import java.util.LinkedList

fun main(args: Array&lt;String&gt;)
{
     val namesOfVideoGames = LinkedList&lt;String&gt;()
     namesOfVideoGames.addAll(list.Of("playstation5","Sega","X-Box","Nintendo"));

     for (games in namesOfVideoGames){
         println(games)
        }
}
</pre>
<p>在实例化过程之后，我们使用一个<code>forEach</code>循环列出添加到队列中的所有元素:</p>
<pre class="language-kotlin hljs">output:
playstation5
Sega
X-Box
Nintendo
</pre>
<h2 id="methods-kotlin-queue-enqueue-dequeue-empty-peek">科特林队列的方法:<code>enqueue</code>、<code>dequeue</code>、<code>isEmpty</code>和<code>peek</code></h2>
<p>队列有四种操作:</p>
<ul>
<li><code>dequeue</code>:删除队列前面的元素并返回</li>
<li><code>enqueue</code>:在队列后面插入一个元素，如果操作成功返回<code>true</code></li>
<li><code>isEmpty</code>:使用<code>count</code>属性检查队列是否为空</li>
<li><code>peek</code>:返回队列前面的元素，但不删除它</li>
</ul>
<h3>在队列中添加元素</h3>
<pre class="language-kotlin hljs">import java.util.LinkedList
fun main()
{
        val queueExample = LinkedList&lt;Int&gt;()

    queueExample.add(1)
    queueExample.add(2)

    print(queueA.poll())
}
</pre>
<p>上面的代码显示了将数值<code>1</code>和<code>2</code>添加到<code>queueExample</code>中。</p>
<p><code>poll()</code>和<code>remove()</code>方法的不同之处仅在于队列为空时它们各自的行为。<code>poll()</code>方法返回一个<code>null</code>值，而<code>remove()</code>方法抛出一个异常。队列接口的<code>poll()</code>方法返回并移除容器前端的元素:</p>
<pre class="language-kotlin hljs">public A remove() {
    A y = poll();
    if (y != null)
        return y;
    else
        throw new NoSuchElementException();
}


val universityStudentQueue: Queue&lt;String&gt; = LinkedList&lt;String&gt;(mutableListOf("Peter", "Joe", "Elena", "Rocky", "Groovy"))
  println(universityStudentQueue) 
  universityStudentQueue.add("Barack")
  println(universityStudentQueue)
</pre>
<p>上面的代码片段显示了向队列列表添加字符串值。这里，我们使用一组名称值来实例化<code>universityStudentQueue</code>，稍后我们打印这些名称，它们是Peter、Joe、Elena、Rocky和Groovy。然而，这个名单上又多了一个名字，巴拉克。请注意，这个新值按照严格的FIFO概念，位于队列的最后一个位置。</p>
<h3>将元素添加到队列的末尾</h3>
<p>我们可以使用<code>addLast</code>方法或<code>add</code>方法将元素添加到队列的末尾:</p>
<pre class="language-kotlin hljs">import java.util.LinkedList

fun main(args: Array&lt;String&gt;)
{
    var universityStudentQueue = LinkedList&lt;String&gt;();
    universityStudentQueue.addAll(listOf("Mary", "Glory", "Becky"))

   universityStudentQueue.addLast("Michael")
}
</pre>
<h3><code>OfferLast</code>:安全地将元素添加到队列中</h3>
<p>下面的代码演示了一种替代<code>addLast</code>方法的安全方法，称为<code>OfferLast</code>。如果达到或超过了队列容量限制，它将引发异常。当<code>add</code>元素失败时，返回<code>false</code>:</p>
<pre class="language-kotlin hljs">import java.util.LinkedList

fun main(args: Array&lt;String&gt;)
{
    var universityStudentQueue = LinkedList&lt;String&gt;();
    universityStudentQueue.addAll(listOf("Mary", "Glory", "Becky"))

    val offerLast: Boolean = planetsQueue.offerLast("Jupiter")

    println("Offer last result =  $offerLast")

    for(student in universityStudentQueue)
    {
        println(student)
    }
}


Output:
Offer last result = true
Mary
Glory
Becky
</pre>
<h3><code>pollFirst</code>:从队列中安全地删除元素</h3>
<p><code>pollFirst</code>是<code>removeFirst</code>函数的替代函数，在未能从队列中移除元素时返回<code>null</code>,而不是抛出异常:</p>
<pre class="language-kotlin hljs">import java.util.LinkedList

fun main(args: Array&lt;String&gt;)
{
    var universityStudentQueue = LinkedList&lt;String&gt;();
    universityStudentQueue.addAll(listOf("Elena", "Peter", "Roosevelt"))

    var student = universityStudentQueue.pollFirst()
    println(student)

    student = universityStudentQueue.pollFirst()
    println(student)

    student = universityStudentQueue.pollFirst()
    println(student)

    student = universityStudentQueue.pollFirst()
    println(student)
}


Output:
Elena
Peter
Roosevelt
null
</pre>
<p>队列的<code>pollFirst</code>函数的最后一个结果返回<code>null</code>,因为队列是空的，并且<code>pollFirst</code>在该点没有更多的元素要移除。</p>
<h3>从队列中安全地获取元素</h3>
<p><code>peekFirst</code>或<code>peekFunction</code>用于从队列中选取第一个元素。它是<code>getFirst</code>函数或<code>first</code>属性的替代，当没有检索到元素时，返回<code>null</code>而不是抛出异常:</p>
<pre class="language-kotlin hljs">import java.util.LinkedList

fun main(args: Array&lt;String&gt;)
{
    var universityStudentQueue = LinkedList&lt;String&gt;();
    universityStudentQueue.addAll(listOf("Owoitakata", "Lucky", "Leroey"))

    var student = universityStudentQueue.peekFirst()
    println("Peekfirst $student")

    student = universityStudentQueue.pollFirst()
    println("Removed $student")

    student = universityStudentQueue.pollFirst()
    println("Removed $student")

    student = universityStudentQueue.pollFirst()
    println("Removed $student")

    student = universityStudentQueue.peekFirst()
    println("PeekFirst $student")
}



Output:
Peekfirst Owoitakata
Removed Owoitakata
Removed Lucky
Removed Leroey
PeekFirst null
</pre>
<h2 id="handling-queue-errors-kotlin">在Kotlin中处理队列错误</h2>
<p>作为一种异步编程范式，Kotlin需要良好的异常和错误处理技术。</p>
<p>每当您启动一个异步操作时，它将无任何错误地运行，并以结果结束。这构成了真正的威胁，因为程序执行过程中出现的错误可能会被忽视。与任何未处理的异常一样，应用程序通常会崩溃。</p>
<p>假设任何异步操作都将成功无误地运行，这是一个非常冒险的举动。为了充分理解协程执行中的错误和异常处理，首先理解这些错误和异常是如何传播的是很重要的。</p><div class="code-block code-block-54">
<hr/>
<h3>更多来自LogRocket的精彩文章:</h3>

<hr/></div>
<p>在Kotlin中，只有未检查的异常，这些异常只能在运行时被捕获。抛出异常的一般方法是使用<code>throw</code>表达式，如下面的代码片段所示:</p>
<pre class="language-kotlin hljs">throw Exception("Exception occurred here")
</pre>
<p>注意，所有的异常类都是<code>Throwable</code>类的后代。Kotlin队列中的一些常见异常包括:</p>
<ul>
<li><code>NullPointerException</code>:通常在试图调用<code>null</code>对象的属性或方法时抛出</li>
<li><code>Arithmetic Exception</code>:执行无效的算术数值运算时抛出</li>
<li><code>SecurityException</code>:当存在安全违规时抛出</li>
<li><code>ArrayIndexOutOfBoundException</code>:当我们试图访问一个数组的无效索引值时抛出</li>
</ul>
<p>让我们将下面的代码片段作为算术异常的示例:</p>
<pre class="language-kotlin hljs">fun main(args : Array&lt;String&gt;){
    var number = 500 / 0      // arithmetic exception is thrown here
    println(number)
}
</pre>
<p>Kotlin中处理异常的四种常见方法是:</p>
<ul>
<li><code>try...catch</code></li>
<li><code>try-catch-finally</code></li>
<li><code>try-finally</code></li>
</ul>
<h3><code>try...catch</code></h3>
<p><code>try</code>块编写您认为可能抛出异常的语句，而<code>catch</code>块编写异常处理代码:</p>
<pre class="language-kotlin hljs">fun main(args: Array&lt;String&gt;)
{        
        try
    {
        var i: Int = 100;
        throw Exception("Exception thrown in first try!")
    }
    catch(e: Exception)
    {
        e.printStackTrace()
    }
    println("Successful!")        
}
</pre>
<h3><code>Try-catch-finally</code></h3>
<p>由于有了<code>finally</code>块，<code>try-catch-finally</code>异常非常重要，它有助于您编写始终执行的代码。因此，无论<code>try</code>块中发生什么，无论是否发生异常，都会执行<code>finally</code>块中的语句:</p>
<pre class="language-kotlin hljs">fun main(args: Array&lt;String&gt;)
{        
        try
    {
        var i: Int = 1000;
        throw Exception("Exception thrown in first try!")
    }
    catch(e: Exception)
    {
        e.printStackTrace()
    }
    finally{
        println("Finally Block Result!")
    }
}
</pre>
<h3><code>Try-finally</code></h3>
<p><code>try-finally</code>异常只有<code>try</code>和<code>finally</code>块。它很有用，因为它有助于块确保正确释放资源:</p>
<pre class="language-kotlin hljs">fun main(args: Array&lt;String&gt;)
{        
        try
    {
        var i: Int = 10;
        throw Exception("Throwing Exception!")
    }
    finally
    {
        println("Break the rules!");
    }
}
</pre>
<h2 id="retrying-failed-items-queue-based-system">在基于队列的系统上重试失败的项目</h2>
<p>在基于队列的系统中，我们可以实现重试逻辑，使系统能够执行特定的代码片段指定的次数。在下面的代码中，我们用指定的最大重试值将代码写在循环内的<code>try...catch</code>块中:</p>
<pre class="language-kotlin hljs">import kotlin.random.Random

const val MAXIMUM_NUMBER_OF_RETRIES = 4

fun main() {
    for (i in 0..MAXIMUM_NUMBER_OF_RETRIES) {
        try {
            // generate 0 or 1 with equal probability
            val zeroOrOne = Random.nextInt(2)
           println("The random number is.. $zeroOrOne")

            // 50% probability of "ArithmeticException: / by zero"
            val rand = 1 / zeroOrOne

           // don't retry on success
            break
        } catch (e: ArithmeticException) {
           // handle exception
           println(e.message) // log exception

           // Sleep time is 1 seconds before retrying
          Thread.sleep(1000)

          // throw exception if the last re-try fails
          if (i == MAXIMUM_NUMBER_OF_RETRIES) {
                throw e
            }
        }
    }
}
</pre>
<p>以下是输出:</p>
<pre class="language-kotlin hljs">The random number is...0
/ by zero
The random number is...0
/ by zero
The random number is...0
/ by zero
The random number is...1
</pre>
<p>在上面的代码片段中，输出值各不相同。如果代码抛出一个<code>ArithmeticException</code>，则控制转到<code>catch</code>块。处理此异常后，每秒钟重试一次。在所有重试都失败后，最后一次重试失败，系统抛出异常。</p>
<h2 id="conclusion">结论</h2>
<p>在本教程中，我们深入探讨了Kotlin队列，包括它们的创建、操作、异常，并讨论了错误发生时的处理方法。我们首先介绍了Kotlin队列及其在Android开发中的优势。然后，我们讲述了Kotlin队列实例化的过程，以及队列用来执行某些操作的一些方法。</p>
<p>我想你也会同意Kotlin队列数据结构在提高代码效率方面提供了巨大的优势。编码快乐！</p><div class="code-block code-block-32">
<div class="blog-plug inline-plug kotlin-plug"><h2>LogRocket :即时重现你的安卓应用中的问题。</h2><a class="signup" href="https://lp.logrocket.com/blg/kotlin-signup" target="_blank" rel="noopener noreferrer"><img class="alignnone size-full wp-image-46 jetpack-lazy-image" src="../Images/b5ae4bd0ecde7aa9d5288746416d5e18.png" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2022/11/react-native-plug_android-1.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/11/react-native-plug_android-1.png"/><noscript><img data-lazy-fallback="1" class="alignnone size-full wp-image-46" src="../Images/b5ae4bd0ecde7aa9d5288746416d5e18.png" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/11/react-native-plug_android-1.png"/></noscript></a><p><a href="https://lp.logrocket.com/blg/kotlin-signup" target="_blank" rel="noopener noreferrer"> LogRocket </a>是一款Android监控解决方案，可以帮助您即时重现问题，确定bug的优先级，并了解您的Android应用程序的性能。</p><p>LogRocket还可以向你展示用户是如何与你的应用程序互动的，从而帮助你提高转化率和产品使用率。LogRocket的产品分析功能揭示了用户不完成特定流程或不采用新功能的原因。</p><p>开始主动监控您的Android应用程序— <a class="signup" href="hhttps://lp.logrocket.com/blg/kotlin-signup" target="_blank" rel="noopener noreferrer">免费试用LogRocket】。</a></p></div>
</div>

<p class="clearfix"/>
<p class="clearfix"/>
 </article>

</div>    
</body>
</html>
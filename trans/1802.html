<html>
<head>
<title>A detailed look at basic SQL.js features - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>详细了解 SQL.js 的基本特性</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/detailed-look-basic-sqljs-features/#0001-01-01">https://blog.logrocket.com/detailed-look-basic-sqljs-features/#0001-01-01</a></blockquote><div><article class="article-post">
<p>SQL 或结构化查询语言是一种特定于领域的语言，旨在访问和操作关系数据库中的数据。在 SQL 语句的帮助下，您可以在关系数据库上执行创建、更新、检索和删除数据等操作。</p>
<p>关系数据库是一种数据模型，它使用行和列来组织表中的数据。虽然可能有多个使用 SQL 的关系数据库管理系统，但几乎所有这些系统都被设计为作为服务器端进程工作。其中包括:</p>
<ul>
<li>关系型数据库</li>
<li>一种数据库系统</li>
<li>SQLite</li>
<li>MSSQL</li>
</ul>
<p>在本教程中，我们将讨论 SQL.js，这是一个 JavaScript SQL 库，使您能够完全在浏览器中创建和查询关系数据库。</p>
<p>我们将通过每个部分的详细示例来完成以下步骤:</p>

<h2 id="#What-is-SQL.js">什么是 SQL.js？</h2>
<p><a href="https://github.com/sql-js/sql.js/" target="_blank" rel="noopener"> SQL.js </a>是一个 JavaScript 库，允许您完全在浏览器中创建和查询关系数据库。它使用存储在浏览器内存中的虚拟数据库文件，所以它不会持久保存对数据库所做的更改。</p>
<p>这个库还使用<a href="https://emscripten.org/docs/introducing_emscripten/about_emscripten.html" target="_blank" rel="noopener"> Emscripten </a>将 SQLite 编译成<a href="https://webassembly.org/" target="_blank" rel="noopener"> WebAssembly (Wasm) </a>。有了这个特性，您可以轻松地在 SQL.js 中使用现有的 SQLite 数据库，还可以将 SQL.js 中创建的数据库转换为 SQLite。</p>
<h2 id="#Pros-cons-using-SQL.js">使用 SQL.js 的利与弊</h2>
<p>使用 SQL.js 有几个好处。它是为客户端构建的，完全在客户端工作，这意味着它不需要任何服务器端进程来工作。它比 MySQL、PostgreSQL 和其他需要第三方软件才能使用的软件更容易设置。开始使用 SQL.js 就像在现有的 HTML 项目中安装 jQuery 一样简单。SQL.js 支持执行包含多个语句的单个 SQL 字符串，如下所示:</p>
<pre>sqlstr = "CREATE TABLE tableName(colA, colB);";
sqlstr += "INSERT INTO hello VALUES (0, 'hello');"
    ....
</pre>
<p>但是还有一个重要的缺点:使用 SQL.js 时对数据库的更改不是持久的。再读一遍:当你重新加载你的浏览器时，对你的数据库所做的所有改变都将不复存在。这是因为 SQL.js 使用存储在浏览器内存中的虚拟数据库文件。但是，您可以导入任何现有的 SQLite 文件，并将创建的数据库导出为 JavaScript 类型的数组。</p>
<h2 id="#Installation-browser-node.js">安装 SQL.js</h2>
<h3>浏览器安装</h3>
<p>将 SQL.js 集成到一个新的基于客户端的项目中非常容易。您可以从包含 CDN 或下载源文件并将它们链接到您的标记页面开始。</p>
<p>默认情况下，SQL.js 使用 WebAssembly，除了 JavaScript 库之外，还需要加载一个<code>.wasm</code>文件。您可以<a href="https://sql.js.org/dist/sql-wasm.wasm" target="_blank" rel="noopener">在线下载该文件</a>，并使用<code>locateFile</code>功能将该文件加载到您的网页中，如下所示:</p>
<pre>&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
  &lt;head&gt;
    &lt;title&gt;Page Title&lt;/title&gt;
    &lt;script src="https://cdnjs.cloudflare.com/ajax/libs/sql.js/1.5.0/sql-wasm.js"&gt;&lt;/script&gt;
    &lt;script&gt;
      // Load sql.js WebAssembly file
      let config = {
        locateFile: () =&gt; "/path/to/downloaded/sql-wasm.wasm",
      };
      initSqlJs(config).then(function (SQL) {
          console.log("sql.js initialized 🎉");
      });
    &lt;/script&gt;
  &lt;/head&gt;
  &lt;body&gt;&lt;/body&gt;
&lt;/html&gt;
</pre>
<p>在上面的代码块中，我们使用<code>initSqlJs</code>异步加载 Wasm 二进制文件，并在加载所需文件后初始化 SQL.js。</p>
<h3>Node.js 安装</h3>
<p>在基于节点的项目中安装 SQL.js 也非常简单。要安装它，您只需运行:</p>
<pre>npm install sql.js
</pre>
<p>或者，您可以从前面的链接中下载<code>sql-wasm.js</code>和<code>sql-wasm.wasm</code>，并使用 Node.js <code>require</code>函数将它们加载到您的项目中。</p>
<p>此外，在基于节点的项目中，您可以跳过<code>locateFile</code>方法来加载<code>sql-wasm.wasm</code>文件，因为如果它与您正在处理的当前文件在同一个文件夹中，它会自动加载。因此，我们的代码将如下所示:</p>
<pre>var initSqlJs = require("./sql-wasm.js");

initSqlJs().then(function (SQL) {
  console.log("sql.js initialized 🎉");
});
</pre>
<h2 id="#Writing-SQL-queries-prepared-statements">编写 SQL 查询和准备好的语句</h2>
<p>既然我们已经完成了安装和初始化 SQL.js 所需的所有步骤，让我们深入了解它的用法。</p>
<h3>创建数据库</h3>
<p>下面的代码创建了一个新的数据库:</p>
<pre>const db = new SQL.Database();
</pre>
<p>值得注意的是，<code>SQL.Database()</code>方法接受一个可选参数<code>data</code>，它必须是一个代表 SQLite 数据库文件的<code>Uint8Array</code>。例如，在 Node.js 中，我们可以加载一个现有的<code>.sqlite</code>文件，如下所示:</p>
<pre>let fs = require("fs");
let initSqlJs = require("./sql-wasm.js");
let filebuffer = fs.readFileSync("/path/to/sample.sqlite");

initSqlJs().then(function (SQL) {
  // Create a new database with our existing sample.sqlite file
  const db = new SQL.Database(filebuffer);
});
</pre>
<p>在上面的代码中，我们使用内置的 Node.js <code>fs</code>和<code>path</code>模块来读取我们现有的<code>sample.sqlite</code>文件。</p>
<h3>运行 SQL 语句</h3>
<p>SQL 语句可以是在数据库中创建或检索一条信息的请求，也可以是对现有数据执行操作的请求。</p>
<p>使用 SQL.js，您可以轻松运行一条语句，而无需读取其结果。语法如下所示:</p>
<pre>db.run(stmt);
</pre>
<p>参数<code>stmt</code>当然是您的 SQL 语句。下面是一个如何在数据库中创建一个名为<code>users</code>的新表的例子，该表包含 ID、姓名、电话号码和地址列。它还会在该表中插入一个新行。</p>
<pre>let initSqlJs = require("./sql-wasm.js");

initSqlJs().then(function (SQL) {
  const db = new SQL.Database();
  // RUNNING SQL QUERIES 👇
  db.run("CREATE TABLE users (id, name, phone, address);");
  db.run(
    `INSERT INTO users (id, name, phone, address)
        VALUES (1, 'John Doe', '+234-907788', '12 Igodan Street, Okitipupa')`
  );
});
</pre>
<h3>准备好的 SQL 语句</h3>
<p>您可以使用预处理语句高效地重复执行相同或相似的 SQL 语句。预处理语句的解析时间比运行 SQL 语句要短得多，因为只需对查询做一次准备。它们对于 SQL 注入也非常有用，因为您不需要对参数值进行转义，参数值稍后会使用不同的协议进行传输。</p>
<p>借助 SQL.js，我们还可以使用<code>.prepare()</code>方法编写预准备语句:</p>
<pre>var stmt = db.prepare(preparedStatement);
</pre>
<p>下面是一个示例，用于获取我们之前的数据库中 ID 在 1 到 10 之间的所有用户:</p>
<p><code>var stmt = db.prepare("SELECT * FROM users WHERE id BETWEEN $start AND $end");</code></p>
<pre>  stmt.bind({ $start: 1, $end: 2 });
  while (stmt.step()) {
    var row = stmt.getAsObject();
    console.log("Here is a user row: " + JSON.stringify(row));
  }
</pre>
<p>在编写好准备好的 SQL 语句之后，我们使用<code>.bind()</code>方法来绑定语句所需的值(上面示例中的<code>start</code>和<code>end</code>)。接下来，我们将使用一个<code>while</code>循环返回所有可能的行，并将它们记录到控制台。</p>
<h3>将数据库写入磁盘</h3>
<p>SQL.js 还提供了一个通过<code>db.export()</code>方法将数据库作为<code>.sqlite</code>文件导出/写入磁盘的选项。结果将作为<code>Uint8Array</code>返回，您可以使用 Node.js <code>Buffer</code>类和文件系统包将数据库写入磁盘:</p>
<pre>var fs = require("fs");
/***
  Code to create a database here
***/
// Export database 👇
var data = db.export();
var buffer = new Buffer(data);
fs.writeFileSync("new-db.sqlite", buffer);
</pre>
<p>运行上面的代码后，您应该会在项目根文件夹中看到一个名为<code>new-db.sqlite</code>的新文件。</p>
<h2>结论</h2>
<p>在本文中，我们介绍了 SQL.js、它提供的特性以及如何在实际应用程序中使用它。虽然 SQL.js 可能非常适合构建离线优先的应用程序，如笔记应用程序，但如果您希望从管理面板管理用户数据，您可能需要考虑使用其他关系数据库(MySQL、PostgreSQL)。</p><div class="code-block code-block-28">
<div class="blog-plug inline-plug js-libraries-plug"><h2>您是否添加了新的 JS 库来提高性能或构建新特性？如果他们反其道而行之呢？</h2><p>毫无疑问，前端变得越来越复杂。当您向应用程序添加新的 JavaScript 库和其他依赖项时，您将需要更多的可见性，以确保您的用户不会遇到未知的问题。</p>
<p>LogRocket 是一个前端应用程序监控解决方案，可以让您回放 JavaScript 错误，就像它们发生在您自己的浏览器中一样，这样您就可以更有效地对错误做出反应。</p><a class="signup" href="https://lp.logrocket.com/blg/javascript-signup" target="_blank" rel="noopener noreferrer"><img class="alignnone size-full wp-image-46 jetpack-lazy-image" src="../Images/e8a0ab42befa3b3b1ae08c1439527dc6.png" alt="LogRocket Dashboard Free Trial Banner" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2019/10/errors-screenshot.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/10/errors-screenshot.png"/><noscript><img data-lazy-fallback="1" class="alignnone size-full wp-image-46" src="../Images/e8a0ab42befa3b3b1ae08c1439527dc6.png" alt="LogRocket Dashboard Free Trial Banner" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/10/errors-screenshot.png"/></noscript></a>
<a href="https://lp.logrocket.com/blg/javascript-signup" target="_blank" rel="noopener noreferrer">https://logrocket.com/signup/</a><p><a href="https://lp.logrocket.com/blg/javascript-signup" target="_blank" rel="noopener noreferrer"> LogRocket </a>可以与任何应用程序完美配合，不管是什么框架，并且有插件可以记录来自 Redux、Vuex 和@ngrx/store 的额外上下文。您可以汇总并报告问题发生时应用程序的状态，而不是猜测问题发生的原因。LogRocket 还可以监控应用的性能，报告客户端 CPU 负载、客户端内存使用等指标。</p><p>自信地构建— <a class="signup" href="https://lp.logrocket.com/blg/javascript-signup" target="_blank" rel="noopener noreferrer">开始免费监控</a>。</p></div>


</div>
<h3>进一步阅读</h3>


<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
<html>
<head>
<title>Remix vs. Next.js vs. SvelteKit - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>remix vs . next . js vs . SvelteKit-log rocket 博客</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/react-remix-vs-next-js-vs-sveltekit/#0001-01-01">https://blog.logrocket.com/react-remix-vs-next-js-vs-sveltekit/#0001-01-01</a></blockquote><div><article class="article-post">
<p><em> <strong>编者按</strong>:这篇文章最后一次更新是在 2022 年 12 月 15 日，包括了关于部署和错误处理的章节。</em></p>
<p>Remix 是 React 路由器创建者的一个全栈 web 框架，已经从付费模式过渡到免费模式，这对 React 和更大的元框架社区来说都是一个大新闻。</p>
<p>在过去的几年中，SaaS 范式的使用，即通常由开源技术在云中使用的业务模型，已经在行业内得到巩固。例如，React 元框架 Next.js 和 Gatsby 都提供付费托管服务，这些服务具有为优化而定制的附加功能。</p>
<p>同样，Shopify 发布了一个名为<a href="https://hydrogen.shopify.dev/"> Hydrogen </a>的 React 元框架，以及一个名为 Oxygen 的<a href="https://shopify.dev/custom-storefronts/oxygen">托管服务。Neo4j、ArangoDB 和 MongoDB 等数据库都提供云数据库服务，使得采用和使用更加容易。最终，混音创作者也计划发布一个个性化的优化平台。</a></p>
<p>与此同时，Remix 竞争对手 Next.js 背后的创作者 Vercel 在雇佣苗条创作者 Rich Harris 全职工作于主要的苗条元框架 SvelteKit 方面有了有趣的发展。</p>
<p>作为一个用于服务器端渲染的<a href="https://blog.logrocket.com/guide-to-remix-react-framework/">框架，Remix </a>旨在满足与 Next.js 和 SvelteKit 等框架相同的一些需求。在本文中，我们将比较它们的一些特性，从启动项目到添加样式。在本文结束时，您应该能够更好地为您独特的项目选择一个。我们开始吧！</p>
<blockquote><p><strong> N.B. </strong>，Vue、Angular 和<a href="https://blog.logrocket.com/introduction-solidjs/"> SolidJS </a>的等价元框架分别是 Nuxt.js、Angular Universal 和 SolidStart。</p></blockquote>

<h2 id="initiating-project">启动一个项目</h2>
<p>首先，我们将考虑在每个框架中创建新项目的命令:</p>
<pre>//Remix
npx <a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="6e0d1c0b0f1a0b431c0b0307162e020f1a0b1d1a">[email protected]</a>
</pre>
<p>当生成一个 Remix 项目时，您可以选择一个为部署到不同的托管服务而定制的模板，如 Netlify、Cloudflare、Fly.io、Vercel 等。每个都配有文档，使部署变得轻而易举:</p>
<pre>//Next.js
npx <a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="f1928394908594dc9f948985dc908181b19d9085948285">[email protected]</a>
//SvelteKit
npm init <a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="3d4e4b585149587d53584549">[email protected]</a> my-app
</pre>
<h2 id="routing">按指定路线发送</h2>
<p>路由决定了访问网站上不同页面所需的 URL。所有三个元框架都使用基于文件的路由，这是所有元框架主要使用的。该 URL 基于该特定页面的文件的名称和位置。</p>
<p>下面，您将看到一些不同文件如何在每个元框架中映射到 URL 的例子，包括一个带有 URL 参数的例子，它将 URL 的一部分定义为一个可以检索的变量。</p>
<h3>再搅拌</h3>
<p>Remix 是建立在<a href="https://blog.logrocket.com/react-router-v6/"> React 路由器 v6 </a>之上的。因此，您可以在客户端代码中使用许多最新的<a href="https://blog.logrocket.com/using-hooks-react-router/">钩子，如<code>useParams</code>和<code>useNavigate</code> </a>来处理导航，<a href="https://blog.logrocket.com/migrating-react-router-v6-guide/">类似于正常使用 React Router v6 </a>:</p>
<p><code>/</code>→<code>app/routes/index.js</code><br/><code>/hello</code>→<code>app/routes/hello/index.js or app/routes/hello.js</code><br/><code>/use_param/:id</code>→<code>app/routes/use_param/$id.js</code></p>
<h3>Next.js</h3>
<p><code>/</code>→<code>pages/index.js</code><br/>→<code>/hello</code>→<code>pages/hello/index.js</code>或者<code>pages/hello.js</code> <br/> <code>/use_param/:id</code> → <code>pages/use_param/[id].js</code></p>
<h3>苗条套装</h3>
<p><code>/</code>→<code>src/routes/index.svelte</code><br/>→<code>/hello </code>→<code>src/routes/hello/index.svelte</code>或者<code>src/routes/hello.svelte</code> <br/> <code>/use_param/:id</code> → <code>src/routes/use_param/[id].svelte</code></p>
<h2 id="loading-data-server-side">在服务器端加载数据</h2>
<p>使用元框架的一个主要好处是在页面水合之前处理大量的数据准备，比如 API 调用、转换等。当您使用元框架时，您不必准备加载器或类似于<code>useEffect</code>钩子的东西来处理这些问题的异步本质。</p>
<p>在所有三个元框架中，每个页面上都有一个我们可以定义的功能，在将页面发送到用户浏览器之前，该功能将从服务器上运行。</p>
<h3>再搅拌</h3>
<p>在 Remix 中，我们定义了一个名为<code>loader</code>的函数，它将被传递一个对象，该对象包含 URL 参数和请求数据等内容，我们将使用这些内容来准备任何数据。然后，<code>loader</code>函数可以返回页面需要的任何数据。然后可以使用<code>useLoaderData</code>钩子在组件中检索这些数据，如下所示:</p>
<pre>import { useLoaderData } from "remix";

export let loader = async ({ params, request }) =&gt; {
   // get a param from the url
   const id = params.id
   // getting data from the url query string
   const url = new URL(request.url)
   const limit = url.searchParams.get("limit")

   return {id, limit}
};

export default function SomePage() {
  let {id, limit} = useLoaderData();
  return (
    &lt;div&gt;
      &lt;h1&gt;The params is: {id}&lt;/h1&gt;
      &lt;h1&gt;The limit url query is: {limit}&lt;/h1&gt;
    &lt;/div&gt;
  );
}
</pre>
<h3>Next.js</h3>
<p>同样，在 Next.js 中，可以导出一个名为<code>getServerSideProps</code>的函数。返回值可以定义对<code>page</code>组件的支持:</p>
<pre>export const getServerSideProps = async ({ params, query }) =&gt; {
   // get a param from the url
   const id = params.id
   // getting data from the url query string
   const limit = query.limit

   return {props: {id, limit}}
};

export default function SomePage() {
  let {id, limit} = useLoaderData();
  return (
    &lt;div&gt;
      &lt;h1&gt;The params is: {id}&lt;/h1&gt;
      &lt;h1&gt;The limit url query is: {limit}&lt;/h1&gt;
    &lt;/div&gt;
  );
}
</pre>
<h3>苗条套装</h3>
<p>使用 SvelteKit，您可以在单独指定的脚本块中定义一个名为<code>load</code>的函数。就像前面的例子一样，您可以处理任何 API 调用和数据准备，然后将用作道具的数据返回给<code>page</code>组件:</p>
<pre>&lt;script context="module"&gt;
        // Load function to define data
        export function load({ page }) {
   // get params from url
   const id = page.params.id
   // get data from url query
   const limit = page.query.get("limit")
                return {
                        props: {
                                id,
            limit
                        }
                };
        }
&lt;/script&gt;

&lt;script&gt;
   // normal client side javascript block
        export let id;
   export let limit
&lt;/script&gt;

&lt;div&gt;
   &lt;h1&gt;The params is: {id}&lt;/h1&gt;
   &lt;h1&gt;The limit url query is: {limit}&lt;/h1&gt;
&lt;/div&gt;
</pre>
<h2 id="pre-rendering-pages-static-site-generators">将页面预呈现为静态站点生成器</h2>
<p>将页面预渲染为静态站点生成器可能是特性集中最大的转移。在撰写本文时，Remix 不支持页面的预渲染，而 Next.js 和 SvelteKit 支持，这意味着您也可以将它们用作静态站点生成器。</p>
<h3>再搅拌</h3>
<p>在撰写本文时，Remix 还不支持静态站点生成，但它提供了一个关于使用分布式云技术来优化你的应用的<a href="https://remix.run/docs/en/v1/guides/performance">指南。</a></p>
<h3>Next.js</h3>
<p>如果您喜欢页面被预渲染，只需导出<code>getStaticProps</code>而不是<code>getServerSideProps</code>。否则，我们将观察到与之前相同的模式:</p>
<h3>苗条套装</h3>
<p>如果您希望在模块脚本博客中预先呈现您的页面，只需设置以下代码:</p>
<pre>export const prerender = true;
</pre>
<p>上面的代码将告诉 SvelteKit 预先呈现页面，而不是在每次请求时都呈现。</p>
<h2 id="api-routing">API 路由</h2>
<p>虽然我们可以用<code>loader</code>、<code>getServerSideProps</code>或<code>load</code>函数在服务器端处理逻辑，但是 API 键和其他数据不应该出现在这段代码中。您可能仍然需要专用的 API URLs，其中的代码只在服务器端可见并运行。</p>
<h3>再搅拌</h3>
<p>如果您创建一个不导出组件的文件，那么它将被视为一个资源路径，可以创建一个 JSON 响应，如下所示:</p>
<pre>export function loader({ params }) {
  const id = params.id
  return new Response({id}, {
    status: 200,
    headers: {
      "Content-Type": "application/json"
    }
  });
}
</pre>
<h3>Next.js</h3>
<p>如果您创建一个导出路由功能的路由，如在 Express 中的<code>pages/api</code>文件夹中，它将被视为类似于 API 路由:</p>
<pre>export default function handler(req, res) {
  res.status(200).json({ id: req.params.id })
}
</pre>
<h3>苗条套装</h3>
<p>如果你有一个 JavaScript 或 TypeScript 文件而不是一个 Svelte 文件，导出一个函数，它将被当作一个 API 路由。函数的名称将决定它是对哪种方法的响应:</p>
<pre>export async function get({ params }) {
        return {
          body: {id: params.id}
        }
}
</pre>
<h2 id="styling">式样</h2>
<p>谈到样式，这三个框架可以有很大的不同。</p>
<h3>再搅拌</h3>
<p>Remix 有一种内置的方式，通过链接标签链接传统的 CSS 样式表，方法是在<code>pages</code> JavaScript 文件中导出一个链接函数。如果链接标签出现在根目录或模板中，页面的链接标签将在后面插入。因此，您不需要将所有的 CSS 都显示在每个页面上来优化每页发送的 CSS 数量:</p>
<pre>export function links() {
  return [
    {
      rel: "stylesheet",
      href: "https://unpkg.com/<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="5d303239382f33703e2e2e702f382e38291d6c7369736d">[email protected]</a>/dist/reset.min.css"
    }
  ];
}
</pre>
<h3>Next.js</h3>
<p>您也可以使用<code>helmet</code>组件来添加链接标签，但是您也可以使用 s<a href="https://blog.logrocket.com/best-styling-options-nextjs/">styled-components、JSS、Emotion、Sass 或任何其他 CSS 抽象</a>来导入标准 CSS 样式表。</p>
<h3>苗条套装</h3>
<p>像 Vue 一样，Svelte 使用单文件组件，所以 CSS 在组件文件中。</p>
<h2 id="error-handling">错误处理</h2>
<p>尽管您尽了最大努力来发布高性能、无错误的应用程序，但错误还是会发生。网络不能在你的<code>localhost</code>上运行，因此你需要为这些错误做好准备，并在它们出现时处理它们。</p>
<h3>再搅拌</h3>
<p>Remix 内置了对服务器和客户端渲染的错误处理支持。错误边界不会阻止整个页面的呈现，因为它们只替换视图中发生错误的部分。</p>
<p>重新混合中的错误在组件树中冒泡，直到它们找到一个错误边界来呈现它们:</p>
<pre>import { ErrorBoundaryComponent } from "remix";

export const ErrorBoundary: ErrorBoundaryComponent = ({ error }) =&gt; {
  return (
    &lt;div&gt;
      &lt;p&gt;An error occured!&lt;/p&gt;
      &lt;pre className="mt-4"&gt;{error.message}&lt;/pre&gt;
    &lt;/div&gt;
  );
};
</pre>
<h3>Next.js</h3>
<p>为了处理错误，<a href="https://blog.logrocket.com/react-error-handling-react-error-boundary/"> Next.js 使用 React 的<code>ErrorBoundary</code>组件</a>:</p>
<pre>class ErrorBoundary extends React.Component {
  constructor(props) {
    super(props)
    // Define a state variable to track whether is an error or not
    this.state = { hasError: false }
  }

  static getDerivedStateFromError(error) {
    // Update state so the next render will show the fallback UI
    return { hasError: true }
  }

  componentDidCatch(error, errorInfo) {
    // You can use your own error logging service here
    console.log({ error, errorInfo })
  }

  render() {
    // Check if the error is thrown
    if (this.state.hasError) {
      // You can render any custom fallback UI
      return (
        &lt;div&gt;
          &lt;h2&gt;Oops, there is an error!&lt;/h2&gt;
          &lt;button
            type="button"
            onClick={() =&gt; this.setState({ hasError: false })}
          &gt;
            Try again?
          &lt;/button&gt;
        &lt;/div&gt;
      )
    }

    // Return children components in case of no error
    return this.props.children
  }
}

export default ErrorBoundary
</pre>
<p><code>ErrorBoundary</code>组件跟踪一个<code>hasError</code>状态变量，这是一个布尔值。如果有错误，<code>ErrorBoundary</code>组件将呈现一个回退 UI，如果没有，它将呈现其子组件。</p>
<h3>苗条套装</h3>
<p>与 Remix 和 Next.js 不同，SvelteKit 没有任何形式的<code>ErrorBoundary</code>组件来处理错误。相反，您必须通过创建一个<code>+error.svelte</code>来处理错误，它将捕获并呈现错误。</p>
<p>Sveltekit 中的 Error 对象包含一个带有<code>string</code>值的<code>message</code>属性，它提供了关于错误性质的更多细节。</p>
<p>您可以使用从<code>@sveltejs/kit</code>导入的<code><a href="https://kit.svelte.dev/docs/modules#sveltejs-kit-error">error</a></code>助手创建错误。考虑这样一个场景，您想要获取一篇文章的详细信息，但是没有找到:</p>
<pre>export async function load({ params }) {
  const post = await db.getPost(params.slug);

  if (!post) {
    throw error(500, {
      message: 'An error occured!'
    });
  }

  return { post };
}
</pre>
<p><code>+error.svelte</code>组件将自动捕捉错误并显示出来:</p>
<pre>&lt;script&gt;
  import { page } from '$app/stores';
&lt;/script&gt;

&lt;h1&gt;{$page.error.message}&lt;/h1&gt; 
</pre>
<h2 id="deployment">部署</h2>
<h3>再搅拌</h3>
<p>像<a href="https://fly.io/docs/languages-and-frameworks/remix/"> Fly </a>、<a href="https://vercel.com/guides/deploying-remix-with-vercel"> Vercel </a>、<a href="https://render.com/docs/deploy-remix"> Render </a>、<a href="https://www.netlify.com/blog/how-to-deploy-remix-apps-on-netlify/"> Netlify </a>和<a href="https://developers.cloudflare.com/pages/framework-guides/remix/"> Cloudflare </a>这样的几个平台提供了涵盖如何部署 Remix 应用的演练指南。Remix 还<a href="https://remix.run/docs/en/v1/guides/deployment">提供了几个模板</a>，您可以使用 CLI 利用它们进行快速部署。</p>
<h3>Next.js</h3>
<p>Next.js 背后的创造者 Vercel 通常是部署 Next.js 应用的首选。Next.js 提供了更大的部署灵活性，因为它<a href="https://nextjs.org/learn/basics/deploying-nextjs-app/other-hosting-options">可以部署到任何支持 Node.js 的托管提供商</a>，其中一些托管提供商包括 Netlify、Cloudflare、Render、AWS 和 Heroku。注意<a href="https://blog.logrocket.com/choosing-best-nextjs-hosting-platform/"> Next.js 比 SvelteKit 和 Remix 有更多的部署选项</a>。</p>
<h3>苗条套装</h3>
<p>Vercel 和<a href="https://render.com/docs/deploy-sveltekit"> Render </a>为从 GitHub、GitBucket 和 GitLab 快速部署 SvelteKit 应用程序提供直接、一流的支持。对于其他平台，您可以利用 SvelteKit 的<a href="https://kit.svelte.dev/docs/adapters">适配器 API </a>来优化部署。<a href="https://docs.netlify.com/integrations/frameworks/sveltekit/#automatic-framework-detection"> Netlify </a>和<a href="https://developers.cloudflare.com/pages/framework-guides/deploy-a-svelte-site/"> Cloudflare </a>提供了如何使用适配器部署 SvelteKit 应用程序的指南。</p>
<h2 id="where-remix-differ">混音真正的区别在哪里？</h2>
<p>Remix 在处理表单的方式上确实有独特而有价值的不同。在现代框架中，我们已经放弃了表单的传统功能，而不是从 JavaScript 内部劫持流程。对于那些很久以前开发 web 应用程序的人来说，您可能还记得这样的表单:</p>
<pre>&lt;form method="post" action="/user/new"&gt;
        &lt;input type="text" name="username"&gt;
        &lt;input type="password" name="password"&gt;
        &lt;input type="submit" value="new user"&gt;
&lt;/form&gt;
</pre>
<p>请求方法和发出请求的位置都完全在表单中定义，所以不需要<code>onSubmit</code>处理程序或<code>preventDefault</code>。在我们的例子中，它工作正常，因为我们有 Perl 或 PHP 脚本在另一端等待处理该请求。混音有一个自定义的<code>Form</code>组件，包含了这种体验的感觉。</p>
<p>下面是来自<a href="https://remix.run/docs/en/v1/guides/data-writes#building-the-form"> Remix 文档</a>的示例组件，展示了<code>Form</code>组件的运行:</p>
<pre>import type { ActionFunction } from "remix";
import { redirect } from "remix";

// Note the "action" export name, this will handle our form POST
export const action = async ({
  request
}) =&gt; {
  const formData = await request.formData();
  const project = await createProject(formData);
  return redirect(`/projects/${project.id}`);
};

export default function NewProject() {
  return (
    &lt;form method="post" action="/projects/new"&gt;
      &lt;p&gt;
        &lt;label&gt;
          Name: &lt;input name="name" type="text" /&gt;
        &lt;/label&gt;
      &lt;/p&gt;
      &lt;p&gt;
        &lt;label&gt;
          Description:
          &lt;br /&gt;
          &lt;textarea name="description" /&gt;
        &lt;/label&gt;
      &lt;/p&gt;
      &lt;p&gt;
        &lt;button type="submit"&gt;Create&lt;/button&gt;
      &lt;/p&gt;
    &lt;/form&gt;
  );
}
</pre>
<p>当提交表单时，它会向<code>/projects/new</code>发出一个<code>POST</code>请求。前者将使用导出操作函数进行处理，然后重定向到正确的路由。旧的又是新的！</p>
<h2 id="conclusion">结论</h2>
<p>如果您想带来一些老式、全栈的 web 应用程序的感觉，但仍然想在需要时在客户端获得 React 的好处，Remix 是元框架的一个很好的选择。</p>
<p>虽然缺乏静态预渲染使得它很难用于某些用例，如博客和营销渠道，但 Remix 对于具有大量动态内容的网站来说是一个强大的补充。</p>
<p>有一点是肯定的，目前在前端框架领域寻找创新的地方实际上是在元框架中，如 Remix、Next.js、SvelteKit、Nuxt.js、Gatsby、SolidStart、Gridsome 等。我们甚至正在进入一个元-元框架存在的时代。我在看你，<a href="https://blitzjs.com/"> Blitz.js </a>，建立在 Next.js 之上。</p>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
<html>
<head>
<title>Kotlin IntArray, Array, and emptyList() </title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>Kotlin IntArray、Array和emptyList()</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/kotlin-intarray-array-emptylist/#0001-01-01">https://blog.logrocket.com/kotlin-intarray-array-emptylist/#0001-01-01</a></blockquote><div><article class="article-post">
<p>Kotlin是一种非常强大的静态类型编程语言，允许我们编写非常有表现力而又简洁的代码。正如现代语言中常见的那样，这种表达能力通常意味着我们可以用几种方式实现相同的功能。一个典型的例子是根据我们的需要选择一个合适的集合类。</p>
<p>事实上，Kotlin库提供了各种不同的集合，也就是说，将许多(可能是零个)集合项目进行类型分组。</p>
<p>在本文中，我们将研究Kotlin中的数组和整数。我们将分析表示整数数组的两种不同类型，<code>IntArray</code>和<code>Array</code>。最后，我们将比较<code>IntArray</code>和<code>Array with </code>列表，它们是不同的集合类型。</p>
<p><em>向前跳转:</em></p>

<h2 id="intarray-array-int"><code>IntArray</code>对<code>Array</code></h2>
<p>Koltin有两种不同的数组实现。</p>
<p>第一个是<code>Array</code>类，是类型<code>T</code>的泛型，代表类型<code>T</code>的元素数组。<code>Array</code>定义了几个方法，允许我们读/写给定索引处的元素，查询大小，等等。这些数组实现是<em>不变的</em>。因此，如果<code>T</code>是子类型<code>U</code>，那么<code>Array</code>不被认为是<code>Array<u/></code>的子类型。</p>
<p>对于原始类型，Kotlin也为我们提供了专用的数组，比如<code>IntArray</code>或者<code>ShortArray</code>。在这些“原始”数组和它们的通用对应物(例如，<code>Array</code>)之间没有子类型。尽管如此，它们还是有相同的方法。</p>
<p>一个<code>IntArray</code>和一个<code>Array</code>之间的主要区别在于，前者被表示为一个<code>int[]</code>，而后者被编译成一个<code>Integer[]</code>。</p>
<h3 id="type-class">类型与类别</h3>
<p>Kotlin中的<code>IntArray</code>和an <code>Array</code>的实际区别，和Java中的<code>int</code>和<code>Integer</code>的区别基本相同。前者是基本类型，而不是类，存储代表给定整数的实际二进制值。后者是一个Java类，定义了一个<code>int</code>类型的字段。</p>
<p>作为一个类，<code>Integer</code>更有表现力，因为我们可以调用它的方法。尽管如此，<code>int</code>带来了更好的性能，因为使用<code>Integer</code>甚至会增加最简单计算的开销。</p>
<h3 id="performance">表演</h3>
<p>在性能关键的情况下，<code>IntArray</code>比<code>Array</code>表现更好。根据Kotlin Academy的书<em>有效Kotlin </em> 的<a href="https://kt.academy/article/ek-arrays">“第55项】可知，后者分配的字节数是前者的5倍。具体来说，为了存储100万个号码，<code>IntArray</code>需要4，000，016字节，而<code>Array</code>分配20，000，040字节。</a></p>
<p>处理原始数组也更快。同样，根据<em>有效科特林</em>的“第55项”，用<code>IntArray</code>计算一百万个整数的平均值要快25%。</p>
<h3 id="initialization">初始化</h3>
<p><code>IntArray</code>和的另一个区别。基本数组可以不初始化。更具体地说，默认情况下，数组的元素将被设置为<code>0</code>:</p>
<pre class="language-kotlin hljs">val intArr = IntArray(5)
println(intArr.joinToString(" "))</pre>
<p>上面的例子将打印<code>0 0 0 0 0</code>。</p>
<p>另一方面，我们没有为<code>Array</code>提供这种方便的初始化。事实上，它的构造函数输入两个参数，一个是大小，另一个是有效的非空默认值:</p>
<pre class="language-kotlin hljs">val arrInt = Array&lt;Int&gt;(5) { 1 }
println(arrInt.joinToString(" "))</pre>
<p>上面的例子会打印<code>1 1 1 1 1</code>。</p>
<p>我们也可以使用<code>null</code>值，但是结果数组的类型会有所不同——我们必须小心<code>nulls</code>:</p>
<pre class="language-kotlin hljs">val arrInt = arrayOfNulls&lt;Int&gt;(5) // Array&lt;Int?&gt;
println(arrInt.joinToString(" "))</pre>
<p>上面的代码片段将打印出<code>null null null null null</code>，但是数组的类型现在是<code>Array&lt;Int?&gt;</code>而不是<code>Array</code>。</p>
<h3 id="creation">创造</h3>
<p>Kotlin还为我们提供了工厂函数来创建这两种类型的数组:</p>
<pre class="language-kotlin hljs">val intArray: IntArray = intArrayOf(0, 1, 2, 3)
val arrayInt: Array&lt;Int&gt; = arrayOf&lt;Int&gt;(0, 1, 2, 3)</pre>
<h3 id="conversion">转换</h3>
<p>我们可以把一个<code>IntArray</code>变成一个<code>Array</code>，反之亦然，分别使用<code>IntArray::toTypedArray()</code>和<code>Array::toIntArray()</code>:</p>
<pre class="language-kotlin hljs">val arrayInt: Array&lt;Int&gt; = intArrayOf(0, 1, 2, 3).toTypedArray()
val intArray: IntArray = arrayOf&lt;Int&gt;(0, 1, 2, 3).toIntArray()</pre>
<p>最后要注意的是，<code>IntArray</code>和<code>Array</code>的大小是固定的。一旦我们设置了元素的数量，我们就不能在数组中添加或删除元素。</p>
<h2 id="emptylist"><code>emptyList()</code></h2>
<p>除了数组，Kotlin还为我们提供了其他类型的集合。一个例子是<code>List</code>。Kotlin中的列表和数组有几个不同之处。以下是主要区别:</p>
<ul>
<li><strong> Class vs. list </strong> : <code>Array</code>是一个类，而<code>List</code>和<code>MutableList</code>是不同实现的接口。数组是顺序的固定大小的内存区域，编译成JVM数组。然而，对于列表，这完全取决于实际的实现。例如，<code>ArrayList</code>使用了一个隐藏的数组，因此它的运行时性能与<code>Array</code>相似</li>
<li><strong>调整大小</strong> : <code>MutableList</code>可调整大小，而<code>Array</code>和<code>List</code>不可调整大小</li>
<li><strong>可变性</strong> : <code> Array</code>是可变的，而<code>List</code>不是。如果我们想修改列表中的元素，我们必须使用<code>MutableList</code></li>
<li><strong>不变性对协方差</strong> : <code>Array</code>和<code>MutableList are</code>对<code>T</code>不变，而<code>List</code>是协变的。这意味着如果<code>T</code>是<code>U</code>的子类型，那么<code>List</code>就是<code>List<u/></code>的子类型</li>
<li><strong>类型</strong>:<code>Array</code>和<code>MutableList</code>都是原始类型的优化数组类型</li>
</ul>
<p>我们可以使用<code>emptyList()</code>方法初始化一个空列表，然后用<code>List::toTypedArray()</code>将它转换成<code>Array</code>的一个实例，就像我们对<code>IntArray</code>所做的那样:</p>
<pre class="language-kotlin hljs">val list: List&lt;Int&gt; = emptyList()
val array: Array&lt;Int&gt; = list.toTypedArray()</pre>
<h2 id="using-arrays-kotlin">在Kotlin中使用数组</h2>
<p>让我们看看主要的函数，看看它们是如何在Kotlin中处理数组的。在下面的例子中，给出的方法适用于<code>IntArray</code>和<code>Array</code>。</p>
<h3 id="getting-setting-elements">获取和设置元素</h3>
<p>使用数组时最常见的操作无疑是获取和设置元素。我们可以用<code>get</code>和<code>set</code>方法做到这一点。这样的方法经常被调用，以至于Kotlin为它们定义了语法糖:</p>
<pre class="language-kotlin hljs">val array = intArrayOf(1, 12, 856, 0, -10)
    
println(array[2]) // same as array.get(2)
array[2] = 78 // same as array.set(2, 78)
println(array[2])</pre>
<p>上面的例子将打印出<code>856</code>和<code>78</code>，确认数组已经被修改。</p>
<p>但是，如果数组没有在给定的索引处定义，Kotlin将抛出一个<code>IndexOutOfBoundsException</code>:</p>
<pre class="language-kotlin hljs">val array = intArrayOf(1, 12, 856, 0, -10)
    
println(array[7])</pre>
<p>上面的示例将失败，并出现以下异常:</p>
<pre class="language-shell hljs">Exception in thread "main" java.lang.ArrayIndexOutOfBoundsException: Index 7 out of bounds for length 5</pre>
<h3 id="traversing-array">遍历数组</h3>
<p>我们可以使用<code>for</code>循环或<code>while</code>循环遍历Kotlin中的数组。但是，这些方法的水平都有点低。或者，Kotlin为我们提供了通用的<code>forEach</code>函数，它比循环更具声明性:</p>
<pre class="language-kotlin hljs">val array = intArrayOf(1, 12, 856, 0, -10)
    
array.forEach{ println(it) }</pre>
<p>上面的例子将打印数组的所有元素，每行一个。</p><div class="code-block code-block-54">
<hr/>
<h3>更多来自LogRocket的精彩文章:</h3>

<hr/></div>
<p>有时候，让Kotlin在遍历数组时为数组元素分配索引可能会很有用。我们可以用<code>forEachIndexed</code>做到这一点:</p>
<pre class="language-kotlin hljs">val array = intArrayOf(1, 12, 856, 0, -10)
    
array.forEachIndexed{ index, elem -&gt;
    println("Element at index $index: $elem")
}</pre>
<p>上面的示例将打印以下输出:</p>
<pre class="language-kotlin hljs">Element at index 0: 1 
Element at index 1: 12
Element at index 2: 856
Element at index 3: 0
Element at index 4: -10
</pre>
<p>我们也可以使用<code>fold</code>来遍历数组。当我们想从数组中计算一个值时，我们通常会这样做。例如，我们可以用它来对一个数组的所有元素求和:</p>
<pre class="language-kotlin hljs">val array = intArrayOf(1, 12, 856, 0, -10)
    
val sum = array.fold(0, { acc, elem -&gt;
    acc + elem
})
    
println(sum)</pre>
<p>当使用<code>fold</code>时，第一个参数是我们计算的初始值，在上面的例子中是<code>0</code>。第二个参数是一个二元函数，用于用数组的每个元素更新部分结果。这种函数的第一个参数是所谓的累加器，而第二个参数是数组的一个元素。上面的例子将打印出<code>859</code>，和预期的一样。</p>
<h3 id="sorting-reserving-array">排序和反转数组</h3>
<p>排序和反转数组是就地操作。这意味着它们不会返回一个新的数组，而是改变现有的数组。</p>
<p>为了对数组进行排序，我们可以调用它的<code>sort</code>方法:</p>
<pre class="language-kotlin hljs">val array = arrayOf(1, 12, 856, 0, -10)
    
array.sort()
   
println(array.joinToString(" "))</pre>
<p>上面的例子将打印<code>-10 0 1 12 856</code>，显示数组被修改。事实上，<code>sort</code>方法返回了<code>Unit</code>。</p>
<p>类似地，要反转一个数组，我们可以使用<code>reverse</code>:</p>
<pre class="language-kotlin hljs">val array = arrayOf(1, 12, 856, 0, -10)
    
array.reverse()
    
println(array.joinToString(" "))</pre>
<p>上面的例子将打印出<code>-10 0 856 12 1</code>，显示数组被反向放置。反转也可以是部分的，也就是说，我们可以指定一个起点和一个终点:</p>
<pre class="language-kotlin hljs">val array = arrayOf(1, 12, 856, 0, -10)
    
array.reverse(1, 3)
    
println(array.joinToString(" "))</pre>
<p>在这种情况下，该示例将打印<code>1 856 12 0 -10</code>，其中索引<code>1</code>(包含)到<code>3</code>(不包含)的元素，即第二个和第三个元素被颠倒。</p>
<h2>结论</h2>
<p>在本文中，我们研究了<code>IntArray</code>和<code>Array</code>之间的差异，比较了创建每种类型实例的不同方式。我们讨论了这两种类型数组的不同用例，将它们与列表进行了比较，并了解了如何将列表转换为数组。</p>
<p>最后，我们探讨了一些最常见的数组操作，特别是如何设置或获取元素，以及如何遍历、排序和反转数组。</p><div class="code-block code-block-32">
<div class="blog-plug inline-plug kotlin-plug"><h2>LogRocket :即时重现你的安卓应用中的问题。</h2><a class="signup" href="https://lp.logrocket.com/blg/kotlin-signup" target="_blank" rel="noopener noreferrer"><img class="alignnone size-full wp-image-46 jetpack-lazy-image" src="../Images/b5ae4bd0ecde7aa9d5288746416d5e18.png" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2022/11/react-native-plug_android-1.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/11/react-native-plug_android-1.png"/><noscript><img data-lazy-fallback="1" class="alignnone size-full wp-image-46" src="../Images/b5ae4bd0ecde7aa9d5288746416d5e18.png" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/11/react-native-plug_android-1.png"/></noscript></a><p><a href="https://lp.logrocket.com/blg/kotlin-signup" target="_blank" rel="noopener noreferrer"> LogRocket </a>是一款Android监控解决方案，可以帮助您即时重现问题，确定bug的优先级，并了解您的Android应用程序的性能。</p><p>LogRocket还可以向你展示用户是如何与你的应用程序互动的，从而帮助你提高转化率和产品使用率。LogRocket的产品分析功能揭示了用户不完成特定流程或不采用新功能的原因。</p><p>开始主动监控您的Android应用程序— <a class="signup" href="hhttps://lp.logrocket.com/blg/kotlin-signup" target="_blank" rel="noopener noreferrer">免费试用LogRocket】。</a></p></div>
</div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
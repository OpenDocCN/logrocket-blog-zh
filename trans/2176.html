<html>
<head>
<title>How to detect a click outside a React component - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>如何检测 React 组件外部的点击</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/detect-click-outside-react-component-how-to/#0001-01-01">https://blog.logrocket.com/detect-click-outside-react-component-how-to/#0001-01-01</a></blockquote><div><article class="article-post">
<p>Web 开发人员倾向于使用多个组件来使他们基于 React 的 web 应用程序更加动态，以增强可用性和灵活性。</p>
<p>React 组件是一个独立的、可重用的、隔离的 UI 构建块，用 JSX(或 TSX)编写。Web 应用程序通常允许用户一次与一个组件进行交互，例如，用户可以打开一个 HTML 弹出窗口并与弹出窗口的内容进行交互。如果用户在弹出窗口区域之外单击，web 应用程序要么关闭弹出窗口，要么阻止用户关闭弹出窗口。</p>
<p>Web 开发人员还使用自定义下拉菜单让用户从几个选项列表中进行选择。如果用户在自定义下拉列表打开时单击其外部，下拉列表将被关闭。</p>
<p>在这类场景中，如果用户在特定组件之外单击，我们必须触发一些操作。</p>
<p>在本教程中，我将解释如何扩展您的函数式和基于类的 React 组件来检测外部点击，并且我将解释使用流行的 npm 库完成相同任务的另一种方法。</p>
<h2>检测功能组件的外部点击</h2>
<p>让我们通过创建一个名为<code>InfoBox</code>的 React 功能组件来构建一个 HTML 工具提示。当用户单击按钮时，工具提示将会出现，如果用户在工具提示组件之外单击，工具提示将会关闭。我们需要检测 React 组件外部的点击，以实现该场景的解决方案。</p>
<p>首先，我们将创建一个新的 React 应用程序来开始。您也可以将以下外部点击检测代码添加到您现有的 React 应用程序中。</p>
<p>输入以下命令并创建一个新的应用程序。</p>
<pre class="language-bash hljs">npx create-react-app react-outside-click   
cd react-outside-click
yarn start
</pre>
<p>现在，我们需要创建一个新的功能组件来实现工具提示组件。将以下代码添加到<code>./src/components/InfoBoxFunctional.js</code>中。</p>
<pre class="language-javascript hljs">import { useEffect, useRef } from 'react';

export function InfoBox(props) {
  const ref = useRef(null);
  const { onClickOutside } = props;

  useEffect(() =&gt; {
    const handleClickOutside = (event) =&gt; {
      if (ref.current &amp;&amp; !ref.current.contains(event.target)) {
        onClickOutside &amp;&amp; onClickOutside();
      }
    };
    document.addEventListener('click', handleClickOutside, true);
    return () =&gt; {
      document.removeEventListener('click', handleClickOutside, true);
    };
  }, [ onClickOutside ]);

  if(!props.show)
    return null;

  return (
    &lt;div ref={ref} className='info-box'&gt;
        {props.message}
    &lt;/div&gt; );
}
</pre>
<p>上面的代码片段在<code>useRef</code>钩子的帮助下将当前组件实例的 DOM 引用分配给<code>ref</code>变量。之后，它在整个<a href="https://developer.mozilla.org/en-US/docs/Web/API/Document" target="_blank" rel="noopener">文档</a>的<code>useEffect</code>钩子中注册一个点击处理程序来检测全局点击事件。</p>
<p>我们还可以从<code>useEffect</code>钩子返回一个带有清理代码的函数，这意味着当组件被卸载时，我们可以注销我们的全局 click 事件监听器。可以看到，上面的代码用<code>removeEventListener</code> DOM API 函数实现了清理代码。</p>
<h3>准备<code>InfoBox</code>工具提示组件</h3>
<p><code>InfoBox</code>组件支持三个道具:</p>
<ul>
<li><code>message</code>:指定工具提示信息</li>
<li><code>onClickOutside</code>:设置有外部点击事件时需要触发的回调</li>
<li><code>show</code>:可见性状态，表示组件是隐藏还是可见。如果为真，工具提示可见；如果没有，组件函数将返回<code>null</code>并且不会呈现任何内容</li>
</ul>
<p>每当用户点击文档时，就会触发<code>handleClickOutside</code>功能。因此，如果我们直接调用<code>onClickOutside</code>，<a href="https://blog.logrocket.com/controlling-tooltips-pop-up-menus-using-compound-components-in-react-ccedc15c7526/" target="_blank" rel="noopener">，即使用户点击工具提示本身，工具提示也会消失</a>。</p>
<p>上面的代码通过<code>contains</code> DOM API 函数检查用户是否点击了工具提示(或其子项)。因此，如果在工具提示组件实例之外发生单击事件，就会执行<code>onClickOutside</code>回调。</p>
<p><code>InfoBox</code>组件现在准备好了。将下面的 CSS 代码添加到<code>./src/index.css</code>文件中，为<code>InfoBox</code>组件应用一些样式。如果你愿意，你也可以将你的信息框相关的 CSS 移动到一个单独的文件中。出于演示目的，我们将使用<code>index.css</code>文件。</p>
<pre class="language-css hljs">body {
  margin: 0;
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen',
    'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans', 'Helvetica Neue',
    sans-serif;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
}
.container {
  display: flex;
  justify-content: center;
  padding-top: 40vh;
}
.container .info-box-wrapper {
  position: relative;
}
.container .info-box {
  user-select: none;
  width: 300px;
  background: #ffc00d;
  font-size: 14px;
  padding: 12px;
  box-shadow: 2px 2px 12px rgba(0, 0, 0, 0.2);
  border-radius: 4px;
  top: 20px;
  position: absolute;
}
</pre>
<p>最后，用下面的代码更新您的<code>./src/App.js</code>文件，让我们的主应用程序开始工作。</p>
<pre class="language-javascript hljs">import { useState } from 'react';
import { InfoBox } from './components/InfoBoxFunctional.js';
function App() {
  let [showInfo1, setShowInfo1] = useState(false);
  return (
    &lt;div className="container"&gt;
      &lt;div className="info-box-wrapper"&gt;
        &lt;button onClick={() =&gt; {setShowInfo1(true)}} style={{marginRight: '4px'}}&gt;Show InfoBox Functional&lt;/button&gt;
        &lt;InfoBox show={showInfo1} onClickOutside={() =&gt; {setShowInfo1(false)}} message="Click outside to close this"/&gt;
      &lt;/div&gt;
    &lt;/div&gt;
  );
}
export default App;
</pre>
<p>上面的代码呈现了一个带有打开信息框的单击操作的按钮。组件是可重用的(您可以创建许多信息框)，我们像往常一样将所需的道具传递给它。</p>
<p>看看下面正在运行的应用程序。我们可以通过单击 InfoBox 实例的外部来关闭它。此外，当你点击按钮或组件时，它不会消失。</p>
<p><img data-attachment-id="67564" data-permalink="https://blog.logrocket.com/detect-click-outside-react-component-how-to/detect-click-outside-functional-component/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2021/09/detect-click-outside-functional-component.gif" data-orig-size="730,404" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="detect-click-outside-functional-component" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2021/09/detect-click-outside-functional-component-300x166.gif" data-large-file="https://blog.logrocket.com/wp-content/uploads/2021/09/detect-click-outside-functional-component.gif" decoding="async" class="aligncenter size-full wp-image-67564 jetpack-lazy-image" src="../Images/f69c58d9693e0a95e26491d4b0a40421.png" alt="Detect an outside click with a functional component" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2021/09/detect-click-outside-functional-component.gif?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2021/09/detect-click-outside-functional-component.gif"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="67564" data-permalink="https://blog.logrocket.com/detect-click-outside-react-component-how-to/detect-click-outside-functional-component/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2021/09/detect-click-outside-functional-component.gif" data-orig-size="730,404" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="detect-click-outside-functional-component" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2021/09/detect-click-outside-functional-component-300x166.gif" data-large-file="https://blog.logrocket.com/wp-content/uploads/2021/09/detect-click-outside-functional-component.gif" decoding="async" loading="lazy" class="aligncenter size-full wp-image-67564" src="../Images/f69c58d9693e0a95e26491d4b0a40421.png" alt="Detect an outside click with a functional component" data-original-src="https://blog.logrocket.com/wp-content/uploads/2021/09/detect-click-outside-functional-component.gif"/></noscript>
<h2 id="detectinganoutsideclickofaclassbasedcomponent">检测基于类的组件的外部点击</h2>
<p>基于类的组件方法看起来非常类似于功能组件。我们使用相同的道具、DOM APIs 和实现逻辑，但是我们必须以基于类的风格编写代码。将以下代码添加到<code>./src/components/InfoBoxClassBased.js</code>。</p>
<pre class="language-javascript hljs">import React from 'react';

export class InfoBox extends React.Component {
  constructor(props) {
    super(props);
    this.ref = React.createRef();
    this.handleClickOutside = this.handleClickOutside.bind(this);
  }

  handleClickOutside(event) {
    if (this.ref.current &amp;&amp; !this.ref.current.contains(event.target)) {
      this.props.onClickOutside &amp;&amp; this.props.onClickOutside();
    }
  };

  componentDidMount() {
    document.addEventListener('click', this.handleClickOutside, true);
  }

  componentWillUnmount() {
    document.removeEventListener('click', this.handleClickOutside, true);
  };

  render() {
    if(!this.props.show)
      return null;
    return (
      &lt;div ref={this.ref} className='info-box'&gt;
        {this.props.message}
      &lt;/div&gt; );
  }
}
</pre>
<p>上面的代码片段类似于功能组件代码，但是有一些不同。例如，我们使用<code>React.createRef</code>而不是<code>useRef</code>钩子，因为我们<a href="https://blog.logrocket.com/react-hooks-frustrations/" target="_blank" rel="noopener">不能对基于类的组件</a>使用 React 钩子。</p>
<p>现在，通过添加新的组件引用来更新您的<code>App.js</code>，如下所示。请注意，我们在演示应用程序中同时使用了功能组件和基于类的组件，但是您可以根据需要仅使用基于类的实现。</p>
<p>让我们再看一下正在运行的应用程序。现在，有两个 InfoBox 实例:基于类的实现和函数实现。</p>
<p><img data-attachment-id="67566" data-permalink="https://blog.logrocket.com/detect-click-outside-react-component-how-to/detect-click-outside-class-based-component/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2021/09/detect-click-outside-class-based-component.gif" data-orig-size="730,404" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="detect-click-outside-class-based-component" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2021/09/detect-click-outside-class-based-component-300x166.gif" data-large-file="https://blog.logrocket.com/wp-content/uploads/2021/09/detect-click-outside-class-based-component.gif" decoding="async" class="aligncenter size-full wp-image-67566 jetpack-lazy-image" src="../Images/00b0b48a1c99efa026643fafd0d1c76c.png" alt="Detect an outside click with a class-based component" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2021/09/detect-click-outside-class-based-component.gif?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2021/09/detect-click-outside-class-based-component.gif"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="67566" data-permalink="https://blog.logrocket.com/detect-click-outside-react-component-how-to/detect-click-outside-class-based-component/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2021/09/detect-click-outside-class-based-component.gif" data-orig-size="730,404" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="detect-click-outside-class-based-component" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2021/09/detect-click-outside-class-based-component-300x166.gif" data-large-file="https://blog.logrocket.com/wp-content/uploads/2021/09/detect-click-outside-class-based-component.gif" decoding="async" loading="lazy" class="aligncenter size-full wp-image-67566" src="../Images/00b0b48a1c99efa026643fafd0d1c76c.png" alt="Detect an outside click with a class-based component" data-original-src="https://blog.logrocket.com/wp-content/uploads/2021/09/detect-click-outside-class-based-component.gif"/></noscript>
<p>这里我们使用了<code>click</code>事件来绑定点击事件监听器。也可以根据自己的需求使用<code>mousedown</code>事件。你可以在我的 GitHub 上找到<a href="https://github.com/codezri/react-outside-click" target="_blank" rel="noopener">的完整源代码。</a></p>
<h2>反应外部点击处理程序:一种替代方法</h2>
<p>正如我之前提到的，您可以轻松地将这个外部点击检测代码添加到任何 React 组件中。该实现由一些 DOM API 函数调用和 React API 用法组成。但是，现在，我们已经有了 npm 库来处理我们能想到的任何与 React 相关的事情——包括几个用于这个场景的库。如果您需要将这种外部点击检测逻辑添加到许多组件中，并且您不想自己实现它，那么您可以使用一个库。<a href="https://www.npmjs.com/package/react-outside-click-handler" target="_blank" rel="noopener">react-outside-click-handler</a>是一个相当流行的处理外部点击事件的库。像任何其他 npm 库一样，这也会对您的产品包大小产生一些影响。反应外部点击处理程序增加了您的生产包大小约 20 kB。让我们用这个 npm 库更新我们的项目。我们将通过添加对这个 npm 库的引用来修改功能性和基于类的组件。将当前项目复制到另一个目录，并将其重命名为<code>react-outside-click-lib</code>。使用以下命令安装 npm 库。</p>
<pre class="language-bash hljs">yarn add react-outside-click-handler
</pre>
<p>更新两个组件。首先，将下面的代码添加到<code>./src/components/InfoBoxFunctional.js</code>中。</p>
<pre class="language-javascript hljs">export function InfoBox(props) {  
   if(!props.show)
    return null; 

  return (
  &lt;div className='info-box'&gt;
      {props.message}
  &lt;/div&gt; );
}
</pre>
<p>之后，你可以添加下面的代码到<code>./src/components/InfoBoxClassBased.js</code>。</p>
<pre class="language-javascript hljs">import React from 'react';
export class InfoBox extends React.Component {
  render() {
    if(!this.props.show)
      return null; 
    return (
      &lt;div className='info-box'&gt;
        {this.props.message}
      &lt;/div&gt; );
  }
}
</pre>
<p>正如您现在所看到的，我们在两个组件中都没有自己的外部点击检测实现。让我们使用 npm 库再次激活外部点击检测功能。</p>
<p>用以下代码更新您的<code>App.js</code>。</p>
<pre class="language-javascript hljs">import { useState } from 'react';
import { InfoBox as InfoBox1 } from './components/InfoBoxFunctional.js';
import { InfoBox as InfoBox2 } from './components/InfoBoxClassBased.js';
import OutsideClickHandler from 'react-outside-click-handler';
function App() {
  let [showInfo1, setShowInfo1] = useState(false);
  let [showInfo2, setShowInfo2] = useState(false);
return (
    &lt;div className="container"&gt;
      &lt;div className="info-box-wrapper"&gt;
        &lt;button onClick={() =&gt; {setShowInfo1(true)}} style={{marginRight: '4px'}}&gt;Show InfoBox Functional&lt;/button&gt;
        &lt;OutsideClickHandler onOutsideClick={() =&gt; {setShowInfo1(false)}}&gt;
          &lt;InfoBox1 show={showInfo1} message="Click outside to close this"/&gt;
        &lt;/OutsideClickHandler&gt;
      &lt;/div&gt;
      &lt;div className="info-box-wrapper"&gt;
        &lt;button onClick={() =&gt; {setShowInfo2(true)}}&gt;Show InfoBox Class-based&lt;/button&gt;
        &lt;OutsideClickHandler onOutsideClick={() =&gt; {setShowInfo2(false)}}&gt;
          &lt;InfoBox2 show={showInfo2} message="Click outside to close this"/&gt;
        &lt;/OutsideClickHandler&gt;
      &lt;/div&gt;
    &lt;/div&gt;
  );
}
export default App;
</pre>
<p>这里我们用库中定义的<code>OutSideClickHandler</code>组件包装我们的 InfoBox 组件。我们可以使用<code>onOutsideClick</code> prop 来传递回调以执行一些代码——只要用户在特定组件之外单击。</p>
<p>请参见下面的运行应用程序。您将看到我们之前使用的相同应用程序，但这一次，我们使用的是第三方库。</p>
<p><img data-attachment-id="67568" data-permalink="https://blog.logrocket.com/detect-click-outside-react-component-how-to/detect-outside-click-with-react-outside-click-handler/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2021/09/detect-outside-click-with-react-outside-click-handler.gif" data-orig-size="730,404" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="detect-outside-click-with-react-outside-click-handler" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2021/09/detect-outside-click-with-react-outside-click-handler-300x166.gif" data-large-file="https://blog.logrocket.com/wp-content/uploads/2021/09/detect-outside-click-with-react-outside-click-handler.gif" decoding="async" class="aligncenter size-full wp-image-67568 jetpack-lazy-image" src="../Images/d22dbf9720e88b4fec93e25e397a3fa8.png" alt="Detect an outside click with the React Outside Click Handler library" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2021/09/detect-outside-click-with-react-outside-click-handler.gif?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2021/09/detect-outside-click-with-react-outside-click-handler.gif"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="67568" data-permalink="https://blog.logrocket.com/detect-click-outside-react-component-how-to/detect-outside-click-with-react-outside-click-handler/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2021/09/detect-outside-click-with-react-outside-click-handler.gif" data-orig-size="730,404" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="detect-outside-click-with-react-outside-click-handler" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2021/09/detect-outside-click-with-react-outside-click-handler-300x166.gif" data-large-file="https://blog.logrocket.com/wp-content/uploads/2021/09/detect-outside-click-with-react-outside-click-handler.gif" decoding="async" loading="lazy" class="aligncenter size-full wp-image-67568" src="../Images/d22dbf9720e88b4fec93e25e397a3fa8.png" alt="Detect an outside click with the React Outside Click Handler library" data-original-src="https://blog.logrocket.com/wp-content/uploads/2021/09/detect-outside-click-with-react-outside-click-handler.gif"/></noscript>
<p>你可以在我的 GitHub 上找到<a href="https://github.com/codezri/react-outside-click-lib" target="_blank" rel="noopener">的完整源代码。</a></p>
<h2>结论</h2>
<p>外部点击检测在各种 UI 元素中非常有用，比如弹出窗口、下拉菜单和菜单。Web 开发人员往往倾向于为他们自己可以实现的简单事情集成库。添加过多的依赖项会降低 web 应用程序的速度，增加包的大小，降低代码库的可维护性。</p>
<p>因此，如果您能够自己实现这种外部点击检测就更好了，但如果您不能——毕竟，我们现在需要 web 应用程序的快速功能实现——如果您集成<a href="https://www.npmjs.com/package/react-outside-click-handler" target="_blank" rel="noopener"> React 外部点击处理程序库</a>就不会有任何问题，因为它只会稍微增加您的产品包大小，只有 20 千字节。</p><div class="code-block code-block-17">
<div class="blog-plug inline-plug react-plug" vwo-el-id="26283398190">
<h2 vwo-el-id="41600691720">使用 LogRocket 消除传统反应错误报告的噪音</h2>
<a href="https://lp.logrocket.com/blg/react-signup-issue-free" target="_blank" vwo-el-id="19356441070">LogRocket
</a><p>是一款 React analytics 解决方案，可保护您免受数百个误报错误警报的影响，只针对少数真正重要的项目。LogRocket 告诉您 React 应用程序中实际影响用户的最具影响力的 bug 和 UX 问题。</p><a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="19356441380">
<img class="first-react-image alignnone size-full wp-image-46 jetpack-lazy-image jetpack-lazy-image--handled" src="../Images/f300c244a1a1cf916df8b4cb02bec6c6.png" vwo-el-id="18272717540" data-lazy-loaded="1" data-original-src="https://files.readme.io/27c94e7-Image_2017-06-05_at_9.46.04_PM.png"/>
</a>
<a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="19356441690">
<img class="second-react-image alignnone size-full wp-image-46 jetpack-lazy-image jetpack-lazy-image--handled" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" vwo-el-id="30720362350" data-lazy-loaded="1" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/>
</a>
<a href="https://lp.logrocket.com/blg/react-signup-issue-free" target="_blank" rel="noopener noreferrer" vwo-el-id="35866400580">LogRocket
</a><p>自动聚合客户端错误、反应错误边界、还原状态、缓慢的组件加载时间、JS 异常、前端性能指标和用户交互。然后，LogRocket 使用机器学习来通知您影响大多数用户的最具影响力的问题，并提供您修复它所需的上下文。</p><p vwo-el-id="28675661060">关注重要的 React bug—<a class="signup" href="https://lp.logrocket.com/blg/react-signup-issue-free" target="_blank" rel="noopener noreferrer" vwo-el-id="40093418840">今天就试试 LogRocket】。</a></p>
</div></div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
<html>
<head>
<title>Understanding Magic-RegExp as a RegExp alternative - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>理解Magic-RegExp作为RegExp的替代</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/understanding-magic-regexp-regexp-alternative/#0001-01-01">https://blog.logrocket.com/understanding-magic-regexp-regexp-alternative/#0001-01-01</a></blockquote><div><article class="article-post">
<p>正则表达式(或Regex)是一种模式，可用于在字符串中搜索与该模式匹配的内容。它通常用于查找和替换操作，以及表单输入验证和不同类型的字符串操作。</p>
<p>Magic-RegExp的目标是创建一个可编译的、类型安全的、可读的RegEx替代方法，使这个过程变得更加容易。</p>
<p>当您刚刚开始使用正则表达式时，它可能看起来有点奇怪，可能需要一些时间来适应。</p>
<p>为了充分理解这个主题，我们探索一下为什么在我们的项目中使用正则表达式是很重要的。</p>
<p>很多时候，我们的任务是验证必须符合模式的输入。解决这个问题的一个方法(我认为不是一个好方法)是尝试写一些<code>if</code>语句；但是，随着我们的继续，我们会发现它可能很难阅读和维护——因此需要一个更好的解决方案，比如正则表达式(或RegExp)。</p>
<p>在本文中，我们将了解正则表达式，以及如何使用Magic-RegExp来改进和简化项目正则表达式的创建。</p>
<p>让我们跳进来吧！</p>
<p><em>向前跳转:</em></p>

<h2 id="creating-regexp">在RegExp中创建</h2>
<p>在JavaScript中，我们主要有两种创建正则表达式的方法。</p>
<p>第一种，也是首选的方法，是使用字面符号，在两个正斜杠之间写表达式:</p>
<pre class="language-javascript hljs">const pattern = /[a-zA-Z]+ing$/;
</pre>
<p>我们可以使用new关键字及其构造函数创建RegExp对象的实例:</p>
<pre class="language-javascript hljs">const pattern = new RegExp('[a-zA-Z]+ing');
</pre>
<p>如果模式将作为用户输入，我们主要使用第二种方法，因为它支持赋值变量，而第一种方法是不可能的。</p>
<h2 id="limitations-working-regexp">使用RegExp的限制</h2>
<h3 id="validating-url">验证URL</h3>
<p>让我们假设我们想要验证一个URL——让我们看看一个有效的URL可以有不同的格式。</p>
<pre class="language-javascript hljs">http://www.google.com
www.google.com
google.com
telegram.org
egghead.io
w3schools.com
<blockquote class="embedly-card" data-card-controls="1" data-card-align="center" data-card-theme="light"><p>世界上最大的网络开发者网站。HTML教程这是一个标题，这是一个段落。亲自尝试了解更多通过我们免费的“我的学习”计划跟踪您的进度。登录您的帐户，开始赢取积分！注册免费的W3Schools著名的颜色选择器:玩游戏测试你的技能！</p></blockquote>
<blockquote class="embedly-card" data-card-controls="1" data-card-align="center" data-card-theme="light"><p>TypeScript通过向语言中添加类型来扩展JavaScript。TypeScript通过在运行代码之前捕捉错误并提供修复来加快您的开发体验。</p></blockquote>
</pre>
<p>在本文的范围内，为了简洁起见，我们将把对有效URL的探索限制在上面。</p>
<h3 id="developing-pseudocode">开发伪代码</h3>
<p>让我们开发一个伪代码来帮助我们编写验证相似模式的正则表达式。</p>
<ol>
<li>可以以<code>http</code>或者<code>https</code>开头(这个好像是<code>optional</code>)</li>
<li>后面是冒号<code>:</code>和两个正斜杠<code>//</code>(这也是<code>optional</code>)</li>
<li>紧随其后的是<code>www.</code>(这似乎也是<code>optional</code>)</li>
<li>它后面跟着一个可以包含数字的字母</li>
<li>它后面是一个<code>.</code>(句号)</li>
<li>它可以以<code>io</code>、<code>org</code>或<code>com</code>结尾</li>
</ol>
<p>为了从上面的伪代码开发我们的模式，我们必须熟悉一些正则表达式语法。</p>
<p>要跟踪并实时查看比赛，您可以使用工具<a href="https://regex101.com/r/WrPyo5/1" target="_blank" rel="noopener"> regex101 </a>。随意添加更多的网址，并使用这个工具。</p>
<h3 id="pseudocodes-1-2">伪代码1和2</h3>
<p>必须以<code>http</code>或<code>https</code>开头:</p>
<p>我们使用脱字符号来表示开始，后面跟着字母<code>http</code>，<code>^</code>，所以我们有<code>^http</code>，但是我们可以有一个可选的<code>s</code>。为了使一个字母可选，我们在它后面添加了特殊字符<code>?</code>，所以我们的表达式现在是<code>^https?</code>。</p>
<p>这之后是一个冒号<code>:</code>——我们简单地附加这个东西，所以我们有<code>^https?:</code>，然后是两个正斜杠<code>//</code>。理想情况下。我们应该像添加冒号<code>:</code>一样添加这个字符，但是我们不能这样做，因为它们是特殊字符，所以我们必须用一个<code>\</code>反斜杠对它们进行转义。</p>
<p>因此，我们的表达式现在变成了<code>^https?:\/\/</code>，但是从上面的URL示例中我们可以看到，URL可以以“https://”或“http://”开头，这意味着整个表达式是可选的。从上面我们已经建立的例子中，我们通过在它后面附加一个<code>?</code>来使一个字母可选。如果我们这样做，它将只使最后一个字母可选；但是我们想要的是使整个组可选——因此我们用括号将它括起来，使它成为一个捕获组(实际上，使它作为一个单元运行),然后我们添加了<code>?</code>。</p>
<p>下面是我们得到的表达式:<br/> <code>(^https?:\/\/)?</code></p>
<h3 id="pseudocode-3">伪代码3</h3>
<p>我们将“www”附加到前面的表达式中，我们有了<code>(^https?:\/\/)?www</code>，但是后面是一个<code>.</code>，这是一个特殊的字符，因此我们必须对它进行转义，所以我们的表达式现在将是<code>(^https?:\/\/)?www\.</code>。根据我们的分析，整个“www。”是可选的，所以我们把它放在组里然后使它可选:<br/> <code>(^https?:\/\/)?(www\.)?</code></p>
<h3 id="pseudocode-4">伪代码4</h3>
<p>然后，一个有效的URL后跟一个可以包含数字的单词。任何单词字符都可以包含<code>a-z (a, b, c to z)</code>或<code>A-Z (A to Z)</code>或<code>0-9</code>甚至一个<code>_</code>——组合在一起就是这样:<code>[A-Za-z0-9_]</code>；或者，在一个特殊字符下:<code>\w</code>。</p>
<p>这两者是等效的，但后者因为简洁而更受青睐。我们将把它添加到我们的表达式中:<br/> <code>^(https?:\/\/)?(www\.)?[A-Za-z0-9_]</code> <br/> <code>^(https?:\/\/)?(www\.)?\w</code></p>
<p>上述两种模式是等价的，但是为了简洁起见，我们将坚持后者。</p>
<p>如果我们使用像<a href="https://regex101.com/" target="_blank" rel="noopener"> Regex101 </a>这样的在线工具运行测试，我们会发现它只匹配一个单词字符，我们需要匹配的是任何单词字符的一个或多个出现。有一个特殊字符允许我们这样做，它是加号<code>+</code>，表示前面的字符出现一次或多次。</p>
<p>因此，我们的表达式现在将是:<br/> <code>^(https?:\/\/)?(www\.)?\w+</code></p>
<h3 id="pseudocode-5">伪代码5</h3>
<p>然后它后面跟着一个<code>.</code>，这是一个我们必须转义的特殊字符，添加这个in将我们的表达式修改为:<br/> <code>^(https?:\/\/)?(www\.)?\w+\.</code></p>
<h3 id="pseudocode-6">伪代码6</h3>
<p>这表示我们的URL可以以“com”、“io”或“org”结尾。为此，我们需要另一个特殊字符，<code>|</code>。这用来表示一组中的一个选择。</p>
<p>我们现在有:<br/> <code>^(https?:\/\/)?(www\.)?\w+\.(com|org|io)$/</code></p>
<p>此外，我们可以添加修改RegExp默认行为的标志。这些标志如下:</p>
<ul>
<li>i: <code>ignoreCase</code>这意味着它应该不区分大小写(将匹配“HI”(“HI”、“Ih”或“iH”)的任何组合)</li>
<li>g: <code>global</code>表示应该尽可能多的匹配；默认情况下，它在第一次匹配后停止</li>
<li>m: <code>multiline</code>意味着它应该继续跨多行搜索匹配</li>
</ul>
<p>将这些相加得到表达式:<br/> <code>/^(https?:\/\/)?(www\.)?\w+\.(com|org|io)$/mig</code></p>
<p>我们可以使用两种方法来测试我们的表达式是否如预期的那样工作:</p>
<pre class="language-javascript hljs">const pattern = /^(https?:\/\/)?(www\.)?\w+\.(com|org|io)$/mig
pattern.test('www.google.com') // returns true
pattern.test('lovelife') // return false

<blockquote class="embedly-card" data-card-controls="1" data-card-align="center" data-card-theme="light"><p>搜索世界信息，包括网页、图像、视频等。谷歌有许多特殊功能来帮助你准确地找到你想要的东西。</p></blockquote>
www.google.com
google.com
telegram.org
egghead.io
w3schools.com
<blockquote class="embedly-card" data-card-controls="1" data-card-align="center" data-card-theme="light"><p>世界上最大的网络开发者网站。HTML教程这是一个标题，这是一个段落。亲自尝试了解更多通过我们免费的“我的学习”计划跟踪您的进度。登录您的帐户，开始赢取积分！注册免费的W3Schools著名的颜色选择器:玩游戏测试你的技能！</p></blockquote>
https://www.typescriptlang.org`.match(/^(https?:\/\/)?(www\.)?\w+\.(com|org|io)$/gmi)

['http://www.google.com', 'www.google.com', 'google.com', 'telegram.org', 'egghead.io', 'w3schools.com', 'https://www.w3schools.com', 'https://www.typescriptlang.org']
The match method retunrs an array of all matches.
</pre>
<p>从上面可以明显看出，一开始使用RegExp可能会有点令人不安，因为需要理解相当多的术语以及如何应用它们。这就是Magic-RegExp的用武之地。</p><div class="code-block code-block-54">
<hr/>
<h3>更多来自LogRocket的精彩文章:</h3>

<hr/></div>
<h2 id="getting-started-magic-regexp">Magic-RegExp入门</h2>
<p>Magic-RegExp简化了创建正则表达式的过程，使其读起来像普通英语——它是一个编译好的、类型安全的、可读的RegExp替代物。</p>
<p>要开始，我们可以简单地使用我们最喜欢的包管理器安装它；<code>npm</code>、<code>pnpm</code>或<code>yarn</code></p>
<pre class="language-javascript hljs">npm install magic-regexp
</pre>
<p>我们也可以将它包含在流行的框架中，如Nuxt (Vue.js)或Next.js (React)。我建议访问官方<a href="https://regexp.dev/getting-started/setup" target="_blank" rel="noopener">页面</a>了解更多细节。</p>
<p>我们可以尝试使用上面的伪代码重新创建上面的正则表达式，但是首先我们将启动一个新的Node.js应用程序来测试这个。</p>
<pre class="language-javascript hljs">mkdir regExp // make a project directory
cd regExp  // go into the directory
touch app.js // create an entry point for our application
npm init -y // set default options

npm i magic-regexp
</pre>
<p>现在我们已经设置好了项目，我们可以打开app.js并开始编写代码。</p>
<pre class="language-javascript hljs">import {
  createRegExp,
  exactly,
  wordChar,
  oneOrMore,
  anyOf,
} from "magic-regexp";
const regExp = createRegExp(
  exactly("http")
    .and(exactly("s").optionally())
    .and("://")
    .optionally()
    .and(exactly("www.").optionally())
    .and(oneOrMore(wordChar))
    .and(exactly("."))
    .and(anyOf("com", "org", "io")),
  ["g", "m", "i"]
);
console.log(regExp); 

/(https?:\/\/)?(www\.)?\w+\.(com|org|io)/gmi
</pre>
<p>我们导入<code>createRegExp</code>函数，并使用附带的函数来组成我们的表达式，如上所示。</p>
<p>从上面，我们可以看到它读起来更接近于简单的英语，我们可以很容易地从伪代码中写出来。</p>
<p>即使生成的RegExp并不完全相同(不同之处在于开始的<code>^</code>和结束的<code>$</code>)；它们非常相似，并且毫无问题地通过了我们所有的测试条件。</p>
<p>这非常简单且容易实现，因为不了解RegExp的内部工作原理就可以实现。很整洁，是吧？</p>
<p>关于magic-regexp更全面的列表，请访问<a href="https://regexp.dev/getting-started/examples" target="_blank" rel="noopener">文档</a></p>
<h2 id="conclusion">结论</h2>
<p>很明显，通过使用Magic-RegExp库，我们可以在很少或没有RegExp知识的情况下完成很多工作。</p>
<p>它可以更快地产生表达式，更容易调试和阅读，虽然它有包大小的开销，但这是最小的，很容易被忽略。</p><div class="code-block code-block-28">
<div class="blog-plug inline-plug js-libraries-plug"><h2>您是否添加了新的JS库来提高性能或构建新特性？如果他们反其道而行之呢？</h2><p>毫无疑问，前端变得越来越复杂。当您向应用程序添加新的JavaScript库和其他依赖项时，您将需要更多的可见性，以确保您的用户不会遇到未知的问题。</p>
<p>LogRocket 是一个前端应用程序监控解决方案，可以让您回放JavaScript错误，就像它们发生在您自己的浏览器中一样，这样您就可以更有效地对错误做出反应。</p><a class="signup" href="https://lp.logrocket.com/blg/javascript-signup" target="_blank" rel="noopener noreferrer"><img class="alignnone size-full wp-image-46 jetpack-lazy-image" src="../Images/e8a0ab42befa3b3b1ae08c1439527dc6.png" alt="LogRocket Dashboard Free Trial Banner" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2019/10/errors-screenshot.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/10/errors-screenshot.png"/><noscript><img data-lazy-fallback="1" class="alignnone size-full wp-image-46" src="../Images/e8a0ab42befa3b3b1ae08c1439527dc6.png" alt="LogRocket Dashboard Free Trial Banner" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/10/errors-screenshot.png"/></noscript></a>
<a href="https://lp.logrocket.com/blg/javascript-signup" target="_blank" rel="noopener noreferrer">https://logrocket.com/signup/</a><p><a href="https://lp.logrocket.com/blg/javascript-signup" target="_blank" rel="noopener noreferrer"> LogRocket </a>可以与任何应用程序完美配合，不管是什么框架，并且有插件可以记录来自Redux、Vuex和@ngrx/store的额外上下文。您可以汇总并报告问题发生时应用程序的状态，而不是猜测问题发生的原因。LogRocket还可以监控应用的性能，报告客户端CPU负载、客户端内存使用等指标。</p><p>自信地构建— <a class="signup" href="https://lp.logrocket.com/blg/javascript-signup" target="_blank" rel="noopener noreferrer">开始免费监控</a>。</p></div>


</div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
<html>
<head>
<title>Creating physics-based animations in React with renature - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>在 React with renature - LogRocket 博客中创建基于物理的动画</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/physics-based-animations-react-renature/#0001-01-01">https://blog.logrocket.com/physics-based-animations-react-renature/#0001-01-01</a></blockquote><div><article class="article-post">
<h2>介绍</h2>
<p><code>renature</code>是 React 基于物理学的动画库，灵感来自自然世界。它从我们宇宙的物理学中获得灵感，并模拟真实世界的力，如重力、摩擦、空气阻力和流体动力学。</p>
<p><code>renature</code>受到其他流行的基于物理的动画库的影响，如<a href="https://www.react-spring.io/">的 react-spring </a>和<a href="https://www.framer.com/motion/">的 Framer Motion </a>的元素。在本文中，我们将通过构建几个例子和应用程序来学习如何在<code>renature</code>中创建动画。</p>
<h2>基本实现</h2>
<p>首先:通过运行下面的命令安装<code>renature</code>包:</p>
<pre>npm install --save renature
# or
yarn add renature</pre>
<p>提供了六个我们可以用来制作动画的钩子。前三种是<code>useFriction</code>、<code>useGravity</code>和<code>useFluidResistance</code>挂钩。这些钩子激活了单个元素的属性。</p>
<p>它们都以类似的方式工作，但正如它们的名字所暗示的，它们所模仿的自然力量和它们所依赖的物理学会有所不同。此外，根据您使用的力的不同，配置对象也不同。</p>
<p>还有<code>useFrictionGroup</code>、<code>useGravityGroup</code>和<code>useFluidResistanceGroup</code>钩子，我们可以用它们同时制作一组元素属性的动画。</p>
<p>让我们看看使用<code>useFriction</code>钩子的基本实现。</p>
<pre>import { useFriction } from "renature";
import "./styles.css";

export default function App() {
  const [props] = useFriction({
    from: {
      transform: "translateX(100px)"
    },
    to: {
      transform: "translateX(300px)"
    },
    config: {
      mu: 0.2,
      mass: 20,
      initialVelocity: 5
    },
    repeat: Infinity
  });

  return (
    &lt;div className="App"&gt;
      &lt;div {...props} className="box" /&gt;
    &lt;/div&gt;
  );
}</pre>
<p>如果你熟悉 react-spring，你会注意到<code>renature</code>有一个类似的声明式 API。<code>renature</code>中的每一个钩子都需要<code>from</code>和<code>to</code>属性，在这些属性中我们描述了我们想要动画化的 CSS 状态。如果在<code>from</code>中为一个属性设置了一个值，而在<code>to</code>中没有，那么这个属性将被忽略，并且不会被激活。</p>
<p>有时，我们可能希望我们的动画不停顿地无限运行。我们可以通过将<code>repeat: Infinity</code>应用到我们的动画配置中来做到这一点。</p>
<p>因为我们使用了<code>useFriction</code>钩子，所以我们传入了相应的物理参数。顾名思义，<code>useFriction</code>挂钩是仿照摩擦力设计的。这些参数是:</p>
<ul>
<li><code>mu</code>，即动摩擦系数</li>
<li><code>mass</code>，即运动物体的质量</li>
<li><code>initialVelocity</code>，这是运动的初始速度</li>
</ul>
<p>关于<code>renature</code>的奇妙之处在于，你不需要成为一个科学大师来制作令人敬畏的动画。</p>
<h2>用<code>renature</code>制作多个属性的动画</h2>
<p>所以我们已经看到了<code>useFriction</code>钩子是如何工作的，以及如何激活一个元素的<code>transform</code>属性。必要时，我们还可以同时制作多个属性的动画:</p>
<pre>import { useFriction } from "renature";
import "./styles.css";

export default function App() {
  const [props] = useFriction({
    from: {
      transform: "translateX(100px), rotate(0deg)",
      background: "red",
      borderRadius: "0%"
    },
    to: {
      transform: "translateX(300px), rotate(360deg)",
      background: "steelblue",
      borderRadius: "50%"
    },
    config: {
      mu: 0.2,
      mass: 20,
      initialVelocity: 5
    },
    repeat: Infinity
  });

  return (
    &lt;div className="App"&gt;
      &lt;div {...props} className="box" /&gt;
    &lt;/div&gt;
  );
}</pre>
<p>若要制作元素的多个属性的动画，请添加要制作动画的元素的更多属性。</p>
<h2>在组中创建动画</h2>
<p>我们可能希望同时激活多个元素。成组的动画允许我们指定要制作动画的元素数量，并为每个元素单独设置配置。</p>
<pre>import { useGravityGroup } from "renature";
import "./styles.css";
export default function App() {
  const [nodes] = useGravityGroup(3, (i) =&gt; ({
    from: {
      transform: "translate(0px, 0px) scale(1) skewY(0deg)",
      opacity: 0
    },
    to: {
      transform: "translate(20px, 20px) scale(1.2) skewY(5deg)",
      opacity: 1
    },
    config: {
      moverMass: 10000,
      attractorMass: 10000000000000,
      r: 10
    },
    repeat: Infinity,
    delay: i * 500
  }));
  return (
    &lt;div className="App"&gt;
      &lt;div className="container"&gt;
        {nodes.map((props, i) =&gt; {
          return &lt;div className="box" key={i} {...props} /&gt;;
        })}
      &lt;/div&gt;
    &lt;/div&gt;
  );
}</pre>
<p>我们使用<code>useGravityGroup</code>来创建上面的分组动画。所有成组的动画挂钩都采用相似的形式:</p>
<pre>const [props] = use&lt;Force&gt;Group(n: number, fn: (index: number) =&gt; Config);</pre>
<p>您可以通过在动画配置中指定<code>delay</code>属性来延迟<code>renature</code>中的动画。<code>delay</code>期待一个以毫秒为单位的数字，一旦指定的<code>delay</code>过去，就会启动动画。这最常用于分组动画，在这种情况下，您希望以固定的间隔交错设置子动画。</p>
<h2>控制动画状态</h2>
<p>我们来看看如何在<code>renature</code>中控制动画状态。我们可以启动、停止、暂停、延迟和运行动画特定的次数。我们已经了解了如何重复和延迟动画。</p>
<p>为了控制动画状态，<code>renature</code>提供了一个<code>controller</code> API。<code>controller</code>是由<code>renature</code>钩子返回的第二个对象，它有三个方法——<code>start</code>、<code>pause</code>和<code>stop</code>——用于与动画的播放状态进行交互。</p>
<pre>import { useFriction } from "renature";
import "./styles.css";
import Button from "./Button";

export default function App() {
  const [props, controller] = useFriction({
    from: {
      transform: "translateY(0px)",
      opacity: 1,
      borderRadius: "10%"
    },
    to: {
      transform: "translateY(50px)",
      opacity: 0,
      borderRadius: "50%"
    },
    repeat: Infinity,
    pause: true //Signal that the animation should not run on mount.
  });

  return (
    &lt;div className="App"&gt;
      &lt;div className="btn-box"&gt;
        &lt;Button action={controller.start} text="start" /&gt;
        &lt;Button action={controller.pause} text="pause" /&gt;
        &lt;Button action={controller.stop} text="stop" /&gt;
      &lt;/div&gt;
      &lt;div className="box" {...props} /&gt;
    &lt;/div&gt;
  );
}</pre>
<p>我们使用<code>controller</code> API 中可用的<code>controller.start</code>方法来启动动画。为此，我们需要在动画配置中包含<code>pause: true</code>,以防止动画立即在挂载上运行。</p>
<p>为了暂停正在运行的动画，我们使用了<code>controller.pause</code>方法。此方法将停止帧循环，但保留动画状态。这意味着我们可以使用<code>controller.start</code>随时恢复动画。</p>
<p>要停止一个正在运行的动画，我们使用<code>controller.stop</code>方法。不像<code>controller.pause</code>，这将破坏动画状态，所以我们应该只在我们确定想要动画结束时使用它。</p>
<h2><code>renature</code>演示</h2>
<p>现在我们知道了如何使用<code>renature</code>创建动画，让我们看看一些现实世界的应用程序。</p>
<h3>卡片悬停演示</h3>
<p>你是否曾经将鼠标悬停在一张卡片上，看到图像沿着其容器的宽度和高度放大或缩小？让我们使用<code>renature</code>重新创建那个效果。</p>
<p>这是我们将要构建的沙盒:</p>
<p/>
<p>虽然 CSS 不是这个主题的重点，但我们需要一些 CSS 来实现它应有的效果。</p><div class="code-block code-block-54">
<hr/>
<h3>更多来自 LogRocket 的精彩文章:</h3>

<hr/></div>
<pre class="css">.card-box {
  width: 200px;
  border: 1px solid grey;
  overflow: hidden;
  margin-bottom: 2rem;
}</pre>
<p>我们必须为<code>card-box</code> div 设置一个<code>overflow: hidden</code>,以确保当图像缩放时，它仍然被限制在它的容器中。解释完之后，让我们回到<code>renature</code>。</p>
<p>使用我们所学的关于控制动画状态的知识，每当我们悬停在<code>img-box</code> div 内外时，我们就调用<code>controller.start</code>和<code>controller.pause</code>方法。</p>
<pre>export default function Card({ imgUrl, props, controller }) {
  return (
    &lt;div className="card-box"&gt;
      &lt;div
        className="img-box"
        {...props}
        onMouseEnter={controller.start}
        onMouseLeave={controller.pause}
      &gt;
        &lt;img src={imgUrl} /&gt;
      &lt;/div&gt;

      //more stuff below...</pre>
<h3>通知 toast 演示</h3>
<p>通知吐司是应用程序中常用的组件之一。让我们使用<code>renature</code>创建一个。</p>
<p>这是我们将要构建的沙盒:</p>
<p/>
<p>对于 CSS，我们必须将 toast 的不透明度设置为 0，以便它只在按钮被单击时显示。</p>
<pre>return (
    &lt;div className="App"&gt;
      &lt;button onClick={controller.start}&gt;show toast&lt;/button&gt;
      &lt;Toast props={props} /&gt;
    &lt;/div&gt;
);</pre>
<p>当按钮被点击时，我们调用<code>controller.start</code>方法。这将启动动画，吐司下降到视图中。</p>
<h2>无障碍问题</h2>
<p>不是每个人都喜欢装饰性的动画或过渡，一些用户在面对视差滚动、缩放效果等时会经历明显的精神和身体上的困难。因此，我们必须确保我们的动画不会给应用程序用户带来可访问性问题。</p>
<p>在<code>renature</code>的配置对象中，我们可以包含一个可选的<code>reducedMotion</code>属性。如果未指定，并且最终用户喜欢减少运动，动画元素将立即设置为<code>to</code>状态，以避免潜在的有害动画。</p>
<h2>结论</h2>
<p>虽然我在本文中做了一些演示，展示了如何在现实世界的应用程序中使用<code>renature</code>,但如果团队能包含更多可能对开发人员有用的实用演示，那就太棒了。不管怎样，<code>renature</code>是一个非常棒的基于物理学的动画库。</p><div class="code-block code-block-17">
<div class="blog-plug inline-plug react-plug" vwo-el-id="26283398190">
<h2 vwo-el-id="41600691720">使用 LogRocket 消除传统反应错误报告的噪音</h2>
<a href="https://lp.logrocket.com/blg/react-signup-issue-free" target="_blank" vwo-el-id="19356441070">LogRocket
</a><p>是一款 React analytics 解决方案，可保护您免受数百个误报错误警报的影响，只针对少数真正重要的项目。LogRocket 告诉您 React 应用程序中实际影响用户的最具影响力的 bug 和 UX 问题。</p><a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="19356441380">
<img class="first-react-image alignnone size-full wp-image-46 jetpack-lazy-image jetpack-lazy-image--handled" src="../Images/f300c244a1a1cf916df8b4cb02bec6c6.png" vwo-el-id="18272717540" data-lazy-loaded="1" data-original-src="https://files.readme.io/27c94e7-Image_2017-06-05_at_9.46.04_PM.png"/>
</a>
<a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="19356441690">
<img class="second-react-image alignnone size-full wp-image-46 jetpack-lazy-image jetpack-lazy-image--handled" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" vwo-el-id="30720362350" data-lazy-loaded="1" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/>
</a>
<a href="https://lp.logrocket.com/blg/react-signup-issue-free" target="_blank" rel="noopener noreferrer" vwo-el-id="35866400580">LogRocket
</a><p>自动聚合客户端错误、反应错误边界、还原状态、缓慢的组件加载时间、JS 异常、前端性能指标和用户交互。然后，LogRocket 使用机器学习来通知您影响大多数用户的最具影响力的问题，并提供您修复它所需的上下文。</p><p vwo-el-id="28675661060">关注重要的 React bug—<a class="signup" href="https://lp.logrocket.com/blg/react-signup-issue-free" target="_blank" rel="noopener noreferrer" vwo-el-id="40093418840">今天就试试 LogRocket】。</a></p>
</div></div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
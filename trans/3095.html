<html>
<head>
<title>How to build a notes app with React and localStorage - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>如何用 React 和 localStorage - LogRocket Blog 构建一个 notes 应用程序</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/notes-app-react-localstorage/#0001-01-01">https://blog.logrocket.com/notes-app-react-localstorage/#0001-01-01</a></blockquote><div><article class="article-post">
<p>在本文中，我们将学习如何在 React 中创建一个 notes 应用程序，并将该应用程序与<code>localStorage</code>集成。我们的应用程序的主要功能将包括创建笔记，设置字符限制，删除笔记，并将其保存在<code>localStorage</code>中。我们开始吧！</p>

<h2 id="creating-new-react-app">创建新的 React 应用程序</h2>
<p>首先，我们需要为我们的项目创建一个空白的 React 应用程序。使用以下命令从头开始创建 React 应用程序:</p>
<pre class="language-bash">npx create-react-app my-app
cd my-app
npm start
</pre>
<p>接下来，删除<code>App.js</code>文件中的所有内容，使其为空。我们将在这里添加所有组件。</p>
<h3 id="file-structure">文件结构</h3>
<p>因为我们的应用程序会有很多文件，所以文件结构很重要。首先，在<code>src</code>文件夹中创建一个<code>Components</code>文件夹。在<code>Components</code>文件夹中，再创建三个名为<code>NoteComponents</code>、<code>css</code>和<code>img</code>的文件夹。</p>
<p>您的目录可能如下所示:</p>
<p><img data-attachment-id="121683" data-permalink="https://blog.logrocket.com/notes-app-react-localstorage/attachment/file-structure-directory/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/06/file-structure-directory.png" data-orig-size="388,247" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="file-structure-directory" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/06/file-structure-directory-300x191.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/06/file-structure-directory.png" decoding="async" class="aligncenter wp-image-121683 size-full jetpack-lazy-image" src="../Images/89a2b12853255c39465c3f72be073bcc.png" alt="File Structure Directory" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2022/06/file-structure-directory.png 388w, https://blog.logrocket.com/wp-content/uploads/2022/06/file-structure-directory-300x191.png 300w" data-lazy-sizes="(max-width: 388px) 100vw, 388px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2022/06/file-structure-directory.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/06/file-structure-directory.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="121683" data-permalink="https://blog.logrocket.com/notes-app-react-localstorage/attachment/file-structure-directory/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/06/file-structure-directory.png" data-orig-size="388,247" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="file-structure-directory" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/06/file-structure-directory-300x191.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/06/file-structure-directory.png" decoding="async" loading="lazy" class="aligncenter wp-image-121683 size-full" src="../Images/89a2b12853255c39465c3f72be073bcc.png" alt="File Structure Directory" srcset="https://blog.logrocket.com/wp-content/uploads/2022/06/file-structure-directory.png 388w, https://blog.logrocket.com/wp-content/uploads/2022/06/file-structure-directory-300x191.png 300w" sizes="(max-width: 388px) 100vw, 388px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/06/file-structure-directory.png"/></noscript>
<p>接下来，在 CSS 文件夹中创建一个名为<code>App.css</code>的新文件，并将以下代码添加到您的<code>App.js</code>文件中:</p>
<pre class="language-css">import { React } from "react";
import "./Components/css/App.css";
function App() {
  return (
    &lt;div className="main"&gt;
    &lt;/div&gt;
  );
}
export default App;
</pre>
<h2 id="notes-grid">笔记网格</h2>
<p>在<code>App.css</code>文件中，我们需要设计页面和主<code>div</code>的样式。除此之外，我们将使用 CSS Grid 创建一个三列注释网格，并使其具有响应性。因此，在平板电脑上，我们将有两列，在移动设备上，我们将有一列。</p>
<p>我还添加了一个背景图片，但是你可以用你选择的任何图片来替换它。图像保存在我们之前创建的<code>img</code>文件夹中。</p>
<pre class="language-css">@import url('https://fonts.googleapis.com/css2?family=Montserrat:<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="5720303f2317636767">[email protected]</a>;800&amp;display=swap');
body {
    background-image: url("../img/background.jpg");
    background-repeat: no-repeat;
    background-size: cover;
    font-family: "Montserrat";
}
.main {
    max-width: 960px;
    margin: 0px auto;
    padding: 0px 15px;
    min-height: 100vh;
}
.header {
    display: flex;
    width: 100%;
    justify-content: space-between;
    align-items: center;
    margin: 10px 0px;
}
.notes__title {
    color: #fff;
    font-size: 38px;
    font-family: "Montserrat";
    font-weight: 400;
}
.notes {
    max-width: 1200px;
    margin: 0 auto;
    display: grid;
    grid-gap: 1rem;
    grid-template-columns: repeat(3, minmax(300px, 1fr));
}
@media screen and (max-width: 900px) {
    .notes {
        grid-template-columns: repeat(2, minmax(300px, 1fr));
    }
}
@media screen and (max-width: 500px) {
    .notes {
        grid-template-columns: repeat(1, minmax(300px, 1fr));
    }
}
</pre>
<h2 id="adding-title">添加标题</h2>
<p>现在，我们需要在<code>NoteComponents</code>文件夹中创建一个名为<code>Header.js</code>的文件。<code>Header.js</code>将包含页面标题，因此它完全是可选的:</p>
<pre class="language-javascript">import React from "react";
function Header() {
  return (
    &lt;div className="header"&gt;
      &lt;h1 className="notes__title"&gt;Notes&lt;/h1&gt;
    &lt;/div&gt;
  );
}
export default Header;
</pre>
<h2 id="creating-note">创建便笺</h2>
<p>让我们为稍后将使用的单个便笺创建以下基本布局和模板:</p>
<ul>
<li>注释体:包含用户输入的文本</li>
<li>附注页脚:包含删除图标</li>
</ul>
<p>此外，页脚将有一个添加按钮和一个字符计数器。现在，创建一个名为<code>Note.js</code>的新文件，并添加以下代码:</p>
<pre class="language-javascript">import React from "react";
import DeleteForeverOutlinedIcon from "@mui/icons-material/DeleteForeverOutlined";
function Note() {
  return (
    &lt;div className="note"&gt;
      &lt;div className="note__body"&gt;&lt;/div&gt;
      &lt;div className="note__footer" style={{ justifyContent: "flex-end" }}&gt;
        &lt;DeleteForeverOutlinedIcon
          className="note__delete"
          aria-hidden="true"
        &gt;&lt;/DeleteForeverOutlinedIcon&gt;
      &lt;/div&gt;
    &lt;/div&gt;
  );
}
export default Note;
</pre>
<p>删除图标是从 MUI 图标导入的<a href="https://mui.com/">。您可以使用以下命令安装 MUI 图标:</a></p>
<pre class="language-javascript">npm install @mui/icons-material
</pre>
<h2 id="adding-styling">添加样式</h2>
<p>接下来，创建一个名为<code>Note.css</code>的新 CSS 文件，它将包含注释的样式。我们将使用玻璃态来改善笔记的外观。Glassmorphism 是一种模仿磨砂玻璃外观的 UI 设计趋势。它是通过使用半透明背景和模糊效果来实现的。</p>
<p>下面的 CSS 代码还包含我们稍后将创建的笔记表单的样式。将以下代码添加到<code>Note.css</code>:</p>
<pre class="language-css">.note {
    background: rgba(255, 255, 255, 0.1);
    backdrop-filter: blur(5px);
    box-shadow: inset -6px -4px 2px rgba(255, 255, 255, 0.03);
    border-radius: 15px;
    border: 1.5px solid rgba(255, 255, 255, 0.326);
    color: #fff;
    padding: 15px;
    min-height: 140px;
    display: flex;
    flex-direction: column;
    justify-content: space-between;
    word-wrap: break-word;
}
.note__footer {
    display: flex;
    align-items: center;
    justify-content: space-between;
    margin-bottom: 15px;
}
.note textarea {
    white-space: pre-wrap;
    background: transparent;
    border: none;
    color: #fff;
    resize: none;
    font-size: 18px;
}
.note textarea:focus {
    outline: none;
}
.note textarea::placeholder {
    color: #fff;
}
.note__save {
    background: transparent;
    transition: 0.1s ease-in-out;
    border: 1.5px solid #fff;
    border-radius: 10px;
    color: #fff;
    padding: 4px 10px;
    font-size: 13px;
    cursor: pointer;
}
.note__save:hover {
    background: #fff;
    border: 1.5px solid #fff;
    color: #4b1589;
}
.note__delete {
    cursor: pointer;
}
.note__delete:hover {
    transform: scale(1.1);
}
.char__progress {
    background-color: #fff!important;
}
</pre>
<h2 id="creating-notes-container">创建 notes 容器</h2>
<p>现在，我们将在<code>NoteComponents</code>文件夹中创建一个名为<code>Notes.js</code>的新文件。<code>Notes.js</code>将包含所有的状态和功能，并将所有的组件链接在一起。在<code>Notes.js</code>中，我们将首先导入刚刚创建的<code>Note</code>组件以及<code>Note.css</code>文件:</p>
<pre class="language-css">import { React, useState, useEffect } from "react";
import "../css/Note.css";
import Note from "./Note"
function Notes() {
  return (
    &lt;div className="notes"&gt;
      &lt;Note /&gt;
      &lt;Note /&gt;
      &lt;Note /&gt;
    &lt;/div&gt;
  );
}
export default Notes;
</pre>
<p>在上面的代码中，我渲染了一些示例注释来看看我们的应用程序是什么样子的。记得将<code>Header.js</code>和<code>Notes.js</code>文件导入到<code>App.js</code>中。到目前为止，您的<code>App.js</code>文件应该如下所示:</p>
<pre class="language-javascript">import { React } from "react";
import "./Components/css/App.css";
import Header from "./Components/NoteComponents/Header";
import Notes from "./Components/NoteComponents/Notes";
function App() {
  return (
    &lt;div className="main"&gt;
      &lt;Header /&gt;
      &lt;Notes /&gt;
    &lt;/div&gt;
  );
}
export default App;
</pre>
<p>此时，您的应用程序应该如下图所示:</p>
<p><img data-attachment-id="121685" data-permalink="https://blog.logrocket.com/notes-app-react-localstorage/attachment/creating-header-notes-app-js/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/06/creating-header-notes-app-js.png" data-orig-size="730,332" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="creating-header-notes-app-js" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/06/creating-header-notes-app-js-300x136.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/06/creating-header-notes-app-js.png" decoding="async" class="aligncenter wp-image-121685 size-full jetpack-lazy-image" src="../Images/d1b4b643f671827f287f2e49622df05c.png" alt="Creating Header Notes App JS" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2022/06/creating-header-notes-app-js.png 730w, https://blog.logrocket.com/wp-content/uploads/2022/06/creating-header-notes-app-js-300x136.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2022/06/creating-header-notes-app-js.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/06/creating-header-notes-app-js.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="121685" data-permalink="https://blog.logrocket.com/notes-app-react-localstorage/attachment/creating-header-notes-app-js/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/06/creating-header-notes-app-js.png" data-orig-size="730,332" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="creating-header-notes-app-js" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/06/creating-header-notes-app-js-300x136.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/06/creating-header-notes-app-js.png" decoding="async" loading="lazy" class="aligncenter wp-image-121685 size-full" src="../Images/d1b4b643f671827f287f2e49622df05c.png" alt="Creating Header Notes App JS" srcset="https://blog.logrocket.com/wp-content/uploads/2022/06/creating-header-notes-app-js.png 730w, https://blog.logrocket.com/wp-content/uploads/2022/06/creating-header-notes-app-js-300x136.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/06/creating-header-notes-app-js.png"/></noscript>
<p>现在，我们将在<code>Notes.js</code>中创建两个状态。第一个将我们所有的笔记存储为一个数组，第二个将存储输入文本:</p>
<pre class="language-javascript">//states
const [notes, setNotes] = useState([]);
const [inputText, setInputText] = useState("");
</pre>
<h2 id="creating-note-form">创建便笺表单</h2>
<p>现在，我们将创建一个用作表单的固定注释。它将有一个类似于普通便笺的外观，但它将有一个保存按钮和一个带进度条的字符计数器，而不是删除图标。在固定的注释中，用户将在<code>texarea</code>中输入文本，并且他们可以通过点击保存按钮来创建新的注释。</p>
<p>创建一个名为<code>CreateNote.js</code>的新文件，然后向其中添加以下代码:</p>
<pre class="language-javascript">import { React } from "react";
function CreateNote() {
  return (
    &lt;div className="note" style={{ background: "rgba(255, 255, 255, 0)" }}&gt;
      &lt;textarea
        cols="10"
        rows="5"
        placeholder="Type...."
        maxLength="100"
      &gt;&lt;/textarea&gt;
      &lt;div className="note__footer"&gt;
        &lt;span className="label"&gt; left&lt;/span&gt;
        &lt;button className="note__save"&gt;Save&lt;/button&gt;
      &lt;/div&gt;
    &lt;/div&gt;
  );
}
export default CreateNote;
</pre>
<p>您可能会注意到<code>texarea</code>上的<code>maxLength</code>属性。这将用户可以输入的字符数限制为一个指定的值，在我们的例子中是 100 个。这是必要的，否则，用户可以输入任意多的字符，导致状态和 UI 出现问题。继续导入<code>CreateNote</code>组件:</p>
<pre class="language-javascript">import CreateNote from "./CreateNote";
</pre>
<p>现在，在<code>Notes.js</code>文件中调用它:</p>
<pre class="language-javascript">&lt;div className="notes"&gt;
  &lt;Note /&gt;
  &lt;Note /&gt;
  &lt;CreateNote /&gt;
&lt;/div&gt;
</pre>
<p>您的页面应该如下所示:</p>
<p><img data-attachment-id="121687" data-permalink="https://blog.logrocket.com/notes-app-react-localstorage/attachment/app-js-browser-view/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/06/app-js-browser-view.png" data-orig-size="730,329" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="app-js-browser-view" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/06/app-js-browser-view-300x135.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/06/app-js-browser-view.png" decoding="async" class="aligncenter wp-image-121687 size-full jetpack-lazy-image" src="../Images/84dbde1e56cdb14807c02649949dc4f9.png" alt="App JS Browser View" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2022/06/app-js-browser-view.png 730w, https://blog.logrocket.com/wp-content/uploads/2022/06/app-js-browser-view-300x135.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2022/06/app-js-browser-view.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/06/app-js-browser-view.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="121687" data-permalink="https://blog.logrocket.com/notes-app-react-localstorage/attachment/app-js-browser-view/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/06/app-js-browser-view.png" data-orig-size="730,329" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="app-js-browser-view" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/06/app-js-browser-view-300x135.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/06/app-js-browser-view.png" decoding="async" loading="lazy" class="aligncenter wp-image-121687 size-full" src="../Images/84dbde1e56cdb14807c02649949dc4f9.png" alt="App JS Browser View" srcset="https://blog.logrocket.com/wp-content/uploads/2022/06/app-js-browser-view.png 730w, https://blog.logrocket.com/wp-content/uploads/2022/06/app-js-browser-view-300x135.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/06/app-js-browser-view.png"/></noscript>
<h2 id="main-functions">主要功能</h2>
<p>至此，我们已经基本上创建了示例应用程序的主要组件。现在，我们需要创建几个函数，这些函数从表单中获取用户输入，将其保存在输入状态中，然后在用户每次单击 save 按钮时使用它来生成新的注释。</p>
<p>所有这些函数都将添加到<code>Notes.js</code>文件中，该文件是连接每个单个注释和表单的主文件。</p>
<h3 id="input-text-function">输入文本功能</h3>
<p>输入文本函数将接受用户输入，并将其设置为输入状态。稍后，我们将在笔记表单中将此称为道具:</p>
<pre class="language-javascript">// get text and store in state
const textHandler = (e) =&gt; {
  setInputText(e.target.value);
};
</pre>
<h3 id="save-note-function">保存便笺功能</h3>
<p>当用户单击表单上的保存按钮时，保存注释功能将运行。我们在后面的笔记表格中也会把这个叫做道具。</p>
<p>首先，保存笔记功能将在<code>note</code>状态下创建一个新的笔记。它将从输入状态中获取用户输入，并使用惟一的 ID 在数组中创建一个对象。其次，它将清除文本区域，以便在提交后，框是空的。</p>
<p><a href="https://www.npmjs.com/package/uuid"> uuid v4 </a>将创建唯一的 id，它也将被用作映射注释的键。您可以使用以下命令安装 uuid v4:</p>
<pre class="language-bash">npm install uuidv4
</pre>
<p>按如下方式使用它:</p>
<pre class="language-javascript">import { v4 as uuid } from "uuid";
</pre>
<p>下面是保存按钮功能的完整代码:</p>
<pre class="language-javascript">// add new note to the state array
const saveHandler = () =&gt; {
  setNotes((prevState) =&gt; [
    ...prevState,
    {
      id: uuid(),
      text: inputText,
    },
  ]);
  //clear the textarea
  setInputText("");
};
</pre>
<h3 id="delete-note-function">删除笔记功能</h3>
<p>当用户点击 delete 图标时，我们将运行 delete note 函数，该函数将通过过滤从数组中删除注释。ID 参数将是被点击的笔记的唯一 ID:</p>
<pre class="language-javascript">//delete note function
const deleteNote = (id) =&gt; {
  const filteredNotes = notes.filter((note) =&gt; note.id !== id);
  setNotes(filteredNotes);
};
</pre>
<h2 id="linking-functions">链接功能</h2>
<p>现在我们已经创建了函数，我们需要将它们传递给我们的 note 表单。我们将为此使用道具。要将属性传递给<code>CreateNote</code>组件，请在<code>Notes.js</code>文件中进行以下更改:</p>
<pre class="language-javascript">&amp;lt;CreateNote
  textHandler={textHandler}
  saveHandler={saveHandler}
  inputText={inputText}
/&gt;
</pre>
<p>现在，保存和文本函数以及输入状态被传递给了<code>CreateNote</code>组件。接下来，在<code>CreateNote.js</code>文件中，如下调用 props:</p>
<pre class="language-javascript">function CreateNote({ textHandler, saveHandler, inputText })
</pre>
<p>我们将在三个地方使用它们:</p>
<ol>
<li>我们将把<code>textarea</code>的值设置为<code>inputText</code></li>
<li>当使用<code>onChange</code>的<code>textarea</code>发生任何变化时，我们将运行<code>textHandler</code>函数</li>
<li>我们将在保存按钮上运行<code>saveHandler</code>函数<code>onClick</code></li>
</ol>
<p>您的<code>CreateNote.js</code>文件现在应该看起来像下面的代码:</p>
<pre class="language-javascript">import { React } from "react";
function CreateNote({ textHandler, saveHandler, inputText }) {
  return (
    &lt;div className="note" style={{ background: "rgba(255, 255, 255, 0)" }}&gt;
      &lt;textarea
        cols="10"
        rows="5"
        value={inputText}
        placeholder="Type...."
        onChange={textHandler}
        maxLength="100"
      &gt;&lt;/textarea&gt;
      &lt;div className="note__footer"&gt;
        &lt;span className="label"&gt; left&lt;/span&gt;
        &lt;button className="note__save" onClick={saveHandler}&gt;
          Save
        &lt;/button&gt;
      &lt;/div&gt;
    &lt;/div&gt;
  );
}
export default CreateNote;
</pre>
<h2 id="displaying-notes">显示注释</h2>
<p>几节之前，我们渲染了几个<code>Note</code>组件，看看它们看起来如何，只是为了测试。为了使应用程序动态化，我们将从<code>notes</code>数组中映射出注释。<code>map()</code>函数通过为每个数组元素调用一个函数来创建一个新数组，在我们的例子中是<code>notes</code>数组。</p>
<p>我们在<code>Notes.js</code>文件的返回函数中添加了<code>map()</code>函数:</p>
<pre class="language-javascript">return (
  &lt;div className="notes"&gt;
    {notes.map((note) =&gt; (
      &lt;Note
        key={note.id}
        id={note.id}
        text={note.text}
        deleteNote={deleteNote}
      /&gt;
    ))}
    &lt;CreateNote
      textHandler={textHandler}
      saveHandler={saveHandler}
      inputText={inputText}
    /&gt;
  &lt;/div&gt;
);
</pre>
<p>上面的代码遍历了<code>notes</code>数组中的每个元素。然后，它使用用户输入和我们创建的惟一 ID 创建一个新的注释。该 ID 将用于删除函数的参数</p>
<p>一个<code>key</code>是一个特殊的字符串属性，在创建元素列表时需要包含它，就像我们例子中的 notes。</p>
<p>正如您在上面的代码中看到的，我们将删除函数和文本作为道具传递给了<code>Note</code>组件。现在，在<code>Note.js</code>文件中，我们可以将<code>text</code>和删除功能分别添加到<code>note</code>主体和<code>delete</code>图标中:</p>
<pre class="language-javascript">function Note({ id, text, deleteNote }) {
  return (
    &lt;div className="note"&gt;
      &lt;div className="note__body"&gt;{text}&lt;/div&gt;
      &lt;div className="note__footer" style={{ justifyContent: "flex-end" }}&gt;
        &lt;DeleteForeverOutlinedIcon
          className="note__delete"
          onClick={() =&gt; deleteNote(id)}
          aria-hidden="true"
        &gt;&lt;/DeleteForeverOutlinedIcon&gt;
      &lt;/div&gt;
    &lt;/div&gt;
  );
}
</pre>
<p>现在，我们的 notes 应用程序功能齐全了！</p>
<h2 id="adding-character-counter">添加字符计数器</h2>
<p>在创建笔记表单时，我们已经给<code>textarea</code>添加了一个字符限制，以及一个显示剩余字符的标签。</p>
<p>现在，让我们计算 100 个字符中还剩多少个字符，并显示在我们的应用程序中。</p><div class="code-block code-block-54">
<hr/>
<h3>更多来自 LogRocket 的精彩文章:</h3>

<hr/></div>
<p>在<code>CreateNote.js</code>文件中，在 return 语句前添加以下代码:</p>
<pre class="language-javascript">//character limit
const charLimit = 100;
const charLeft = charLimit - inputText.length;
</pre>
<p>上面的代码通过从 100 中减去当前的输入长度来计算剩余的字符，我们将当前的输入长度作为一个道具。随着用户键入，该值将继续减小。</p>
<p>我们可以简单地在<code>span</code>标签中调用它:</p>
<pre class="language-javascript">&lt;span className="label"&gt;{charLeft} left&lt;/span&gt;
</pre>
<h2 id="adding-progress-bar">添加进度条</h2>
<p>我们可以通过添加一个线性进度条来反映字符数，从而进一步改进表单。线性进度条将从 MUI 中使用，它有许多预构建的进度条。您可以使用以下命令安装 MUI:</p>
<pre class="language-javascript">npm install @mui/material
</pre>
<p>像这样将其导入到<code>CreateNote.js</code>文件中:</p>
<pre class="language-javascript">import LinearProgress from "@mui/material/LinearProgress";
</pre>
<p>为了满足我们的要求，我们将把它的变量设置为判别式，把它的值设置为我们已经计算过的<code>charLeft</code>。</p>
<p>您的完整的<code>CreateNote.js</code>文件将类似于以下代码:</p>
<pre class="language-javascript">import { React } from "react";
import LinearProgress from "@mui/material/LinearProgress";
function CreateNote({ textHandler, saveHandler, inputText }) {
  //character limit
  const charLimit = 100;
  const charLeft = charLimit - inputText.length;
  return (
    &lt;div className="note" style={{ background: "rgba(255, 255, 255, 0)" }}&gt;
      &lt;textarea
        cols="10"
        rows="5"
        value={inputText}
        placeholder="Type...."
        onChange={textHandler}
        maxLength="100"
      &gt;&lt;/textarea&gt;
      &lt;div className="note__footer"&gt;
        &lt;span className="label"&gt;{charLeft} left&lt;/span&gt;
        &lt;button className="note__save" onClick={saveHandler}&gt;
          Save
        &lt;/button&gt;
      &lt;/div&gt;
      &lt;LinearProgress
        className="char__progress"
        variant="determinate"
        value={charLeft}
      /&gt;
    &lt;/div&gt;
  );
}
export default CreateNote;
</pre>
<h2 id="saving-notes-localstorage">将笔记保存到<code>localStorage</code></h2>
<p>最后，我们需要将注释保存到浏览器<code>localStorage</code>中，这样当我们刷新页面或者关闭页面然后再打开时，我们的数据不会丢失。</p>
<p>在<code>Notes.js</code>文件中，我们将创建两个函数:一个保存数据，一个读取数据。我们将运行代码来保存<code>useEffect</code>中的数据，并添加<code>notes</code>状态作为第二个参数，这样每次数据发生变化时我们都会保存数据:</p>
<pre class="language-javascript">//saving data to local storage
useEffect(() =&gt; {
  localStorage.setItem("Notes", JSON.stringify(notes));
}, [notes]);
</pre>
<p>我们使用<code>JSON.stringify</code>将对象转换成一个字符串，这样它就可以被存储。同样，为了读取数据，我们也将使用<code>useEffect</code>钩子。但是，这一次，第二个参数将是一个空数组，因为我们只想在页面加载时获取一次数据:</p>
<pre class="language-javascript">//get the saved notes and add them to the array
useEffect(() =&gt; {
  const data = JSON.parse(localStorage.getItem("Notes"));
  if (data) {
    setNotes(data);
  }
}, []);
</pre>
<h2>结论</h2>
<p>我们完事了。你可以在<a href="https://codesandbox.io/s/notes-app-with-react-js-and-localstorage-ifsglz"> CodeSandbox </a>上找到完整的代码。</p>
<p>在本文中，我们使用 React 和<code>localStorage</code>从头构建了一个 notes 应用程序。我们的应用程序具有所有需要的功能，例如，存储用户输入，保存和删除它。我们使用<code>localStorage</code>将数据保存到浏览器中。因此，当我们刷新页面时，它不会丢失。我们甚至更进一步添加了字符计数和进度条，这样用户就知道他们还有多少空间可以输入。</p>
<p>我希望你喜欢这篇文章，如果你有任何问题，一定要留下评论。感谢您的阅读！</p><div class="code-block code-block-17">
<div class="blog-plug inline-plug react-plug" vwo-el-id="26283398190">
<h2 vwo-el-id="41600691720">使用 LogRocket 消除传统反应错误报告的噪音</h2>
<a href="https://lp.logrocket.com/blg/react-signup-issue-free" target="_blank" vwo-el-id="19356441070">LogRocket
</a><p>是一款 React analytics 解决方案，可保护您免受数百个误报错误警报的影响，只针对少数真正重要的项目。LogRocket 告诉您 React 应用程序中实际影响用户的最具影响力的 bug 和 UX 问题。</p><a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="19356441380">
<img class="first-react-image alignnone size-full wp-image-46 jetpack-lazy-image jetpack-lazy-image--handled" src="../Images/f300c244a1a1cf916df8b4cb02bec6c6.png" vwo-el-id="18272717540" data-lazy-loaded="1" data-original-src="https://files.readme.io/27c94e7-Image_2017-06-05_at_9.46.04_PM.png"/>
</a>
<a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="19356441690">
<img class="second-react-image alignnone size-full wp-image-46 jetpack-lazy-image jetpack-lazy-image--handled" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" vwo-el-id="30720362350" data-lazy-loaded="1" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/>
</a>
<a href="https://lp.logrocket.com/blg/react-signup-issue-free" target="_blank" rel="noopener noreferrer" vwo-el-id="35866400580">LogRocket
</a><p>自动聚合客户端错误、反应错误边界、还原状态、缓慢的组件加载时间、JS 异常、前端性能指标和用户交互。然后，LogRocket 使用机器学习来通知您影响大多数用户的最具影响力的问题，并提供您修复它所需的上下文。</p><p vwo-el-id="28675661060">关注重要的 React bug—<a class="signup" href="https://lp.logrocket.com/blg/react-signup-issue-free" target="_blank" rel="noopener noreferrer" vwo-el-id="40093418840">今天就试试 LogRocket】。</a></p>
</div></div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
<html>
<head>
<title>A complete guide to CSV files in Node.js - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>Node.js - LogRocket 博客中 CSV 文件的完整指南</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/complete-guide-csv-files-node-js/#0001-01-01">https://blog.logrocket.com/complete-guide-csv-files-node-js/#0001-01-01</a></blockquote><div><article class="article-post">
<h2>介绍</h2>
<p>逗号分隔值也称为 CSV，是统计分析工具和电子表格应用程序存储和交换表格数据集的最常见和最基本的格式之一。由于其受欢迎程度，管理机构和其他重要组织共享 CSV 格式的官方数据集并不少见。</p>
<p>尽管简单、受欢迎且使用广泛，但使用一个应用程序创建的 CSV 文件在另一个应用程序中显示不正确是很常见的。这是因为没有应用程序必须遵守的官方通用 CSV 规范。因此，存在几种略有不同的实现。</p>
<p>大多数现代操作系统和编程语言，包括 JavaScript 和 Node.js 运行时环境，都有用于读取、写入和解析 CSV 文件的应用程序和包。</p>
<p>在本文中，我们将学习如何在 Node 中管理 CSV 文件。我们还将强调不同 CSV 实现中的细微差异。我们将看到的一些流行的包包括<a href="https://github.com/mafintosh/csv-parser" target="_blank" rel="noopener"> csv 解析器</a>、<a href="https://www.papaparse.com/" target="_blank" rel="noopener"> Papa 解析器</a>和<a href="https://c2fo.github.io/fast-csv/" target="_blank" rel="noopener"> Fast-CSV </a>。</p>
<p>我们还将进一步强调非官方的<a href="https://datatracker.ietf.org/doc/html/rfc4180.html" target="_blank" rel="noopener"> RFC 4180 技术标准</a>，它试图记录大多数 CSV 实现所使用的格式。</p>
<h2>什么是 CSV 文件？</h2>
<p>CSV 文件是普通的文本文件，由以矩形形式排列的数据组成。当您以 CSV 格式保存表格数据集时，换行符将分隔连续的行，而逗号将分隔一行中的连续条目。下图显示了一个表格数据集及其相应的 CSV 格式。</p>
<p><img data-attachment-id="94323" data-permalink="https://blog.logrocket.com/complete-guide-csv-files-node-js/csv-formats/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/02/CSV-formats.png" data-orig-size="259,386" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="CSV-formats" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/02/CSV-formats-201x300.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/02/CSV-formats.png" decoding="async" class="size-full wp-image-94323 aligncenter jetpack-lazy-image" src="../Images/f8b8651c324e0fd216d232b4ff97d4df.png" alt="Guide to CSV formats" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2022/02/CSV-formats.png 259w, https://blog.logrocket.com/wp-content/uploads/2022/02/CSV-formats-201x300.png 201w" data-lazy-sizes="(max-width: 259px) 100vw, 259px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2022/02/CSV-formats.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/02/CSV-formats.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="94323" data-permalink="https://blog.logrocket.com/complete-guide-csv-files-node-js/csv-formats/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/02/CSV-formats.png" data-orig-size="259,386" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="CSV-formats" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/02/CSV-formats-201x300.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/02/CSV-formats.png" decoding="async" loading="lazy" class="size-full wp-image-94323 aligncenter" src="../Images/f8b8651c324e0fd216d232b4ff97d4df.png" alt="Guide to CSV formats" srcset="https://blog.logrocket.com/wp-content/uploads/2022/02/CSV-formats.png 259w, https://blog.logrocket.com/wp-content/uploads/2022/02/CSV-formats-201x300.png 201w" sizes="(max-width: 259px) 100vw, 259px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/02/CSV-formats.png"/></noscript>
<p>在上面的 CSV 数据中，第一行由字段名称组成，尽管情况可能并不总是如此。因此，在开始读取和解析数据集之前，有必要对其进行调查。</p>
<p>虽然逗号分隔值这个名称似乎表明逗号应该总是分隔每个记录中的后续条目，但是一些应用程序生成的 CSV 文件使用分号而不是逗号作为分隔符。</p>
<p>如前所述，尽管存在非官方的 RFC 4180 技术标准，但没有 CSV 实现应该遵循的官方通用标准。然而，这个标准是在 CSV 格式流行多年后才出现的。</p>
<h2>如何在 Node.js 中管理 CSV 文件</h2>
<p>在上一节中，我们简要介绍了 CSV 文件。在本节中，您将学习如何使用内置和第三方包在 Node 中读取、写入和解析 CSV 文件。</p>
<h3>使用<code>fs</code>模块</h3>
<p><code>fs</code>模块是处理 Node 中文件的实际模块。下面的代码使用了<code>fs</code>模块的<code>readFile</code>函数来读取<code>data.csv</code>文件:</p>
<pre class="language-javascript hljs">const fs = require("fs");
fs.readFile("data.csv", "utf-8", (err, data) =&gt; {
  if (err) console.log(err);
  else console.log(data);
});
</pre>
<p>下面的相应示例使用<code>fs</code>模块的<code>writeFile</code>函数写入 CSV 文件:</p>
<pre class="language-javascript hljs">const fs = require("fs");
const data = `
id,name,age
1,Johny,45
2,Mary,20
`;

fs.writeFile("data.csv", data, "utf-8", (err) =&gt; {
  if (err) console.log(err);
  else console.log("Data saved");
});
</pre>
<p>如果你不熟悉在 Node 中读写文件，可以看看我的<a href="https://blog.logrocket.com/reading-writing-json-files-nodejs-complete-tutorial/" target="_blank" rel="noopener">完整教程在 Node </a>中读写 JSON 文件。</p>
<p>如果您使用<code>fs.readFile</code>、<code>fs.writeFile</code>或上面例子中的同步对应物，Node 将在处理文件之前将整个文件读入内存。通过<code>fs</code>模块的<code>createReadStream</code>和<code>createWriteStream</code>功能，<a href="https://blog.logrocket.com/working-node-js-streams/" target="_blank" rel="noopener">可以使用流代替</a>来减少内存占用和数据处理时间。</p>
<p>下面的例子使用了<code>createReadStream</code>函数来读取一个<code>data.csv</code>文件:</p>
<pre class="language-javascript hljs">const fs = require("fs");
fs.createReadStream("data.csv", { encoding: "utf-8" })
  .on("data", (chunk) =&gt; {
    console.log(chunk);
  })
  .on("error", (error) =&gt; {
    console.log(error);
  });
</pre>
<p>此外，我们将在接下来的小节中看到的大多数第三方包也使用流。</p>
<h3>使用 csv 解析器包</h3>
<p>这是一个相对较小的第三方软件包，您可以从 npm 软件包注册表中安装。它能够解析 CSV 文件并将其转换为 JSON。</p>
<p>下面的代码演示了如何从 CSV 文件中读取数据，并使用 csv-parser 将其转换为 JSON。我们正在使用<code>fs</code>模块的<code>createReadStream</code>方法创建一个可读的流，并通过管道将其传递给<code>csv-parser()</code>的返回值:</p>
<pre class="language-javascript hljs">const fs = require("fs");
const csvParser = require("csv-parser");

const result = [];

fs.createReadStream("./data.csv")
  .pipe(csvParser())
  .on("data", (data) =&gt; {
    result.push(data);
  })
  .on("end", () =&gt; {
    console.log(result);
  });
</pre>
<p>有一个可选的配置对象可以传递给 csv-parser。默认情况下，<code>csv-parser</code>将数据集的第一行视为<code>field names(headers)</code>。</p>
<p>如果数据集没有标题，或者连续的数据点不是以逗号分隔的，则可以使用可选的配置对象来传递信息。该对象有额外的配置键，您可以在文档中读到。</p>
<p>在上面的例子中，我们从文件中读取 CSV 数据。您也可以使用像 Axios 或<a href="https://blog.logrocket.com/using-needle-send-http-requests-nodejs/" target="_blank" rel="noopener"> Needle </a>这样的 HTTP 客户端从服务器获取数据。下面的代码说明了如何去做:</p>
<pre class="language-javascript hljs">const csvParser = require("csv-parser");
const needle = require("needle");

const result = [];

const url = "https://people.sc.fsu.edu/~jburkardt/data/csv/deniro.csv";

needle
  .get(url)
  .pipe(csvParser())
  .on("data", (data) =&gt; {
    result.push(data);
  })
  .on("done", (err) =&gt; {
    if (err) console.log("An error has occurred");
    else console.log(result);
  });
</pre>
<p>在执行上面的代码之前，您需要首先安装 Needle。<code>get</code>请求方法返回一个流，您可以通过管道将它传递给<code>csv-parser()</code>。如果针头不适合您，您也可以使用另一个包装。</p>
<p>上面的例子只强调了 csv-parser 所能做的一小部分。如前所述，一个 CSV 文档的实现可能与另一个不同。Csv-parser 具有处理这些差异的内置功能。</p>
<p>虽然 csv-parser 是为了与 Node 一起工作而创建的，但是您可以在浏览器中使用诸如<a href="https://browserify.org/" target="_blank" rel="noopener"> Browserify </a>这样的工具来使用它。</p>
<h3>使用 Papa 解析包</h3>
<p>Papa Parse 是另一个在 Node 中解析 CSV 文件的包。与 csv-parser 不同，Papa Parse 是为浏览器创建的。因此，如果您打算在 Node 中使用它，它的功能是有限的。</p>
<p>我们在下面的例子中说明了如何使用 Papa Parse 来解析 CSV 文件。和以前一样，我们必须使用<code>fs</code>模块的<code>createReadStream</code>方法来创建一个读取流，然后我们通过管道将它传递给<code>papaparse.parse()</code>的返回值。</p>
<p>用于解析的<code>papaparse.parse</code>函数带有可选的第二个参数。在下面的例子中，我们用属性<code>header</code>传递第二个参数。如果<code>header</code>属性的值是<code>true</code>，<code>papaparse</code>会将我们 CSV 文件中的第一行视为<code>column(field) names</code>。</p><div class="code-block code-block-54">
<hr/>
<h3>更多来自 LogRocket 的精彩文章:</h3>

<hr/></div>
<p>该对象还有其他字段，您可以在文档中查找。不幸的是，有些属性仍然仅限于浏览器，在 Node 中还不可用。</p>
<pre class="language-javascript hljs">const fs = require("fs");
const Papa = require("papaparse");

const results = [];

const options = { header: true };

fs.createReadStream("data.csv")
  .pipe(Papa.parse(Papa.NODE_STREAM_INPUT, options))
  .on("data", (data) =&gt; {
    results.push(data);
  })
  .on("end", () =&gt; {
    console.log(results);
  });
</pre>
<p>类似地，您还可以使用 Axios 或 Needle 之类的 HTTP 客户端从远程服务器获取 CSV 数据集作为可读流，并像以前一样将其传输到<code>papa-parse.parse()</code>的返回值。</p>
<p>在下面的例子中，我演示了如何使用 Needle 从服务器获取数据。值得注意的是，使用类似于<code>needle.get</code>的 HTTP 方法之一发出网络请求会返回一个可读的流:</p>
<pre class="language-javascript hljs">const needle = require("needle");
const Papa = require("papaparse");

const results = [];
const options = { header: true };

const csvDatasetUrl = "https://people.sc.fsu.edu/~jburkardt/data/csv/deniro.csv";

needle
  .get(csvDatasetUrl)
  .pipe(Papa.parse(Papa.NODE_STREAM_INPUT, options))
  .on("data", (data) =&gt; {
    results.push(data);
  })
  .on("end", () =&gt; {
    console.log(results);
  });
</pre>
<h3>使用 Fast-CSV 包</h3>
<p>这是一个灵活的第三方包，用于解析和格式化 CSV 数据集，将<code>@fast-csv/format</code>和<code>@fast-csv/parse</code>包组合成一个包。您可以使用<code>@fast-csv/format</code>和<code>@fast-csv/parse</code>分别格式化和解析 CSV 数据集。</p>
<p>以下示例说明了如何使用 Fast-CSV 读取 CSV 文件并将其解析为 JSON:</p>
<pre class="language-javascript hljs">const fs = require("fs");
const fastCsv = require("fast-csv");

const options = {
  objectMode: true,
  delimiter: ";",
  quote: null,
  headers: true,
  renameHeaders: false,
};

const data = [];

fs.createReadStream("data.csv")
  .pipe(fastCsv.parse(options))
  .on("error", (error) =&gt; {
    console.log(error);
  })
  .on("data", (row) =&gt; {
    data.push(row);
  })
  .on("end", (rowCount) =&gt; {
    console.log(rowCount);
    console.log(data);
  });
</pre>
<p>上面，我们将可选参数传递给了<code>fast-csv.parse</code>函数。<code>options</code>对象主要用于处理 CSV 文件之间的变化。如果没有通过，<code>csv-parser</code>将使用缺省值。对于这个例子，我对大多数选项使用默认值。</p>
<p>在大多数 CSV 数据集中，第一行包含列标题。默认情况下，Fast-CSV 将第一行视为数据记录。如果数据集中的第一行包含列标题，您需要将<code>headers</code>选项设置为<code>true</code>，如上例所示。</p>
<p>同样，正如我们在开始部分提到的，一些 CSV 文件可能不是逗号分隔的。您可以使用<code>delimiter</code>选项来更改默认分隔符，就像我们在上面的例子中所做的那样。</p>
<p>我们可以不像前面的例子那样通过管道传递可读流，而是将它作为参数传递给<code>parseStream</code>函数，如下例所示:</p>
<pre class="language-javascript hljs">const fs = require("fs");
const fastCsv = require("fast-csv");

const options = {
  objectMode: true,
  delimiter: ",",
  quote: null,
  headers: true,
  renameHeaders: false,
};

const data = [];

const readableStream = fs.createReadStream("data.csv");

fastCsv
  .parseStream(readableStream, options)
  .on("error", (error) =&gt; {
    console.log(error);
  })
  .on("data", (row) =&gt; {
    data.push(row);
  })
  .on("end", (rowCount) =&gt; {
    console.log(rowCount);
    console.log(data);
  });
</pre>
<p>上面的函数是您可以使用 Fast-CSV 解析 CSV 文件的主要函数。您也可以使用<code>parseFile</code>和<code>parseString</code>函数，但我们不会在这里介绍它们。关于它们的更多信息，你应该去阅读文档。</p>
<h2>结论</h2>
<p>逗号分隔值格式是最流行的数据交换格式之一。CSV 数据集由人类和机器都可读的简单文本文件组成。尽管它很受欢迎，但没有通用的标准。</p>
<p>非官方的 RFC 4180 技术标准试图标准化这种格式，但是在不同的 CSV 实现之间存在一些细微的差异。这些差异的存在是因为 CSV 格式是在 RFC 4180 技术标准出现之前开始的。因此，一个应用程序生成的 CSV 数据集在另一个应用程序中显示不正确是很常见的。</p>
<p>您可以使用内置功能或第三方包来读取、写入和解析 Node 中的简单 CSV 数据集。我们看到的大多数 CSV 包都足够灵活，可以处理不同 CSV 实现产生的细微差异。</p><div class="code-block code-block-23">
<div class="blog-plug inline-plug node-plug"><h2>200 只<img src="../Images/61167b9d027ca73ed5aaf59a9ec31267.png" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2019/10/green-check.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" class=" jetpack-lazy-image" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/10/green-check.png"/> <noscript> <img data-lazy-fallback="1" src="../Images/61167b9d027ca73ed5aaf59a9ec31267.png" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/10/green-check.png"/> </noscript>显示器出现故障，生产中网络请求缓慢</h2><p>部署基于节点的 web 应用程序或网站是容易的部分。确保您的节点实例继续为您的应用程序提供资源是事情变得更加困难的地方。如果您对确保对后端或第三方服务的请求成功感兴趣，</p><a href="https://lp.logrocket.com/blg/node-signup" target="_blank">try LogRocket</a><p>. </p><a class="signup" href="https://lp.logrocket.com/blg/node-signup" target="_blank" rel="noopener noreferrer"><img src="../Images/cae72fd2a54c5f02a6398c4867894844.png" alt="LogRocket Network Request Monitoring" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2019/12/network-request-filter-2-1.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" class=" jetpack-lazy-image" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/12/network-request-filter-2-1.png"/><noscript><img data-lazy-fallback="1" src="../Images/cae72fd2a54c5f02a6398c4867894844.png" alt="LogRocket Network Request Monitoring" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/12/network-request-filter-2-1.png"/></noscript></a><a href="https://lp.logrocket.com/blg/node-signup" target="_blank" rel="noopener noreferrer">https://logrocket.com/signup/</a><p>LogRocket 就像是网络和移动应用程序的 DVR，记录下用户与你的应用程序交互时发生的一切。您可以汇总并报告有问题的网络请求，以快速了解根本原因，而不是猜测问题发生的原因。</p><p>LogRocket 检测您的应用程序以记录基线性能计时，如页面加载时间、到达第一个字节的时间、慢速网络请求，还记录 Redux、NgRx 和 Vuex 操作/状态。</p><a class="signup" href="https://lp.logrocket.com/blg/node-signup" target="_blank" rel="noopener noreferrer">Start monitoring for free</a><p>. </p></div>
</div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
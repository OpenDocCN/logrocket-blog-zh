<html>
<head>
<title>Building cross-platform apps with Expo instead of React Native - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>用 Expo 而不是 React Native - LogRocket 博客构建跨平台应用</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/building-cross-platform-apps-expo-instead-of-react-native/#0001-01-01">https://blog.logrocket.com/building-cross-platform-apps-expo-instead-of-react-native/#0001-01-01</a></blockquote><div><article class="article-post">
<p>在本教程中，我们将学习如何使用<a href="https://expo.io/" target="_blank" rel="noopener"> Expo </a>构建一个运行在 iOS、Android 和 web 上的跨平台应用程序。</p>
<h2>React Native vs. Expo:有什么区别？</h2>
<p>在我们开始使用 Expo 之前，我想介绍一下它与 React Native 的相似之处和不同之处。</p>
<p>简而言之，Expo 是 React Native 的超集。React Native 做 Expo 能做的一切，React Native 做不到 Expo 能做的一切(默认)。</p>
<p>React Native 为您提供了所有的工具和选项，而 Expo 为您做出了一些决定。这些决策是基于 React 本地应用通常需要什么，因此，从等式中去掉了许多繁琐的工作和决策。</p>
<p>此外，因为它是一个标准化的平台，它使您能够利用许多令人惊叹的工具和服务，如 Expo Snack，它允许您在浏览器中构建本机应用。</p>
<p>现在，让我们用 Expo 构建一个跨平台的应用程序。</p>
<h2>安装 Expo</h2>
<p>Expo 有一些我见过的最好的文档，但是我会给你一个如何安装它的快速纲要。</p>
<p>有趣的是，尽管 Expo 是 React Native 的超集，但我们实际上不必在我们的系统上安装 React Native 来构建 Expo 应用程序。我们将利用他们的基础架构在幕后完成繁重的工作。</p>
<p>世博会有三个要求:</p>
<ol>
<li><a href="https://nodejs.org/en/" target="_blank" rel="noopener"> Node.js(随 LTS 版本走)</a></li>
<li><a href="https://git-scm.com/downloads" target="_blank" rel="noopener">去</a></li>
<li><a href="https://facebook.github.io/watchman/docs/install#buildinstall" target="_blank" rel="noopener"> Watchman </a> (Watchman 看文件自动刷新 app)</li>
</ol>
<p>有了这些系统，你就可以通过 NPM 在全球范围内安装 Expo CLI。</p>
<pre>npm install --global expo-cli
</pre>
<p>通过运行<code>expo whoami</code>来验证安装。您应该看到您没有登录。</p>
<p>因为我们将利用博览会的基础设施，我们需要创建一个帐户。您可以通过<code>expo register</code>或使用<code>expo login</code>登录您现有的账户来完成。</p>
<p>在我们开始构建之前，让我们想想如何运行我们的应用程序。我们将在三个平台上工作:iOS、Android 和 web。</p>
<p>网络是最简单的。对于 iOS 和 Android，我会建议从 app store 下载 Expo Go 应用。这将允许您在您的设备上访问您的世博会应用程序，而不必通过发布过程。不要担心，以后你可以用你自己的品牌发布你的应用——这只会让开发变得非常快。</p>
<h2>创建跨平台应用程序</h2>
<p>创建新的 Expo 应用程序就像运行以下命令行一样简单:</p>
<pre>expo init MyCrossPlatformApp
</pre>
<p>当您运行它时，应该会提示您选择一个模板。</p>
<blockquote><p>关于托管与裸工作流的重要说明:“托管”意味着您正在利用 Expo 的基础设施。“裸露”意味着你在使用他们的模板，断开他们的服务，然后自己管理一切。您始终可以从受管工作流导出到裸工作流，但不能返回。我总是建议从管理工作流开始。</p></blockquote>
<p>我将选择“tabs (TypeScript)”模板，这样我们就能获得最大的收益(即导航全部设置好)。</p>
<p><img data-attachment-id="41599" data-permalink="https://blog.logrocket.com/building-cross-platform-apps-expo-instead-of-react-native/typescript-tab/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2021/04/typescript-tab.png" data-orig-size="730,224" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="TypeScript tab" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2021/04/typescript-tab-300x92.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2021/04/typescript-tab.png" decoding="async" class="aligncenter size-full wp-image-41599 jetpack-lazy-image" src="../Images/668255bc76d066726e9f6770c84af8ef.png" alt="TypeScript Tab" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2021/04/typescript-tab.png 730w, https://blog.logrocket.com/wp-content/uploads/2021/04/typescript-tab-300x92.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2021/04/typescript-tab.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2021/04/typescript-tab.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="41599" data-permalink="https://blog.logrocket.com/building-cross-platform-apps-expo-instead-of-react-native/typescript-tab/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2021/04/typescript-tab.png" data-orig-size="730,224" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="TypeScript tab" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2021/04/typescript-tab-300x92.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2021/04/typescript-tab.png" decoding="async" loading="lazy" class="aligncenter size-full wp-image-41599" src="../Images/668255bc76d066726e9f6770c84af8ef.png" alt="TypeScript Tab" srcset="https://blog.logrocket.com/wp-content/uploads/2021/04/typescript-tab.png 730w, https://blog.logrocket.com/wp-content/uploads/2021/04/typescript-tab-300x92.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2021/04/typescript-tab.png"/></noscript>
<p>我们做到了！一款跨平台的应用，可以在 iOS、Android 和网络上运行。运行<code>yarn start</code>,它会打印出一个二维码，你可以从你的 iOS 或 Android 设备上的摄像头扫描该二维码，以打开 Expo Go 应用程序，运行它，并在每次文件保存时获得实时刷新。</p>
<p>或者，您可以运行<code>yarn web</code>，它将打开浏览器。</p>
<p>如果您的机器上安装了 iOS 模拟器或 Android 模拟器，您可以运行它们，它会打开相应的模拟器或模拟器，但这不是必需的。</p>
<h2>世博项目导航</h2>
<p>我们选择的世博会模板为您搭建了一个很好的平台。您可能会对各种文件和文件夹感兴趣:</p>
<ul>
<li><strong>app . tsx</strong>–这是我们文件的入口点。这是进行应用程序所需的任何设置工作的好地方</li>
<li><strong>屏幕/</strong>–该目录包含我们在导航器中注册的屏幕</li>
<li><strong>导航/</strong>–该目录管理与导航相关的一切。由于我们针对的所有平台，它可能会变得非常广泛，但是 Expo 模板中包含的 React 导航大大简化了事情</li>
<li><strong>Hooks/</strong>–Hooks 是 React/React 原生应用中管理功能的常用方式。这个目录编译来自应用程序的定制钩子</li>
<li><strong>constants/</strong>–该目录用于保存不变的静态值</li>
<li><strong>components/</strong>–这个目录是您想要存储组成应用程序功能的可重用组件的地方。它们被屏幕甚至其他组件使用</li>
</ul>
<h2>在 Expo 中编写代码和创建待办事项列表</h2>
<p>让我们进入一些代码，创建一个简单的待办事项列表。我们将在<code>screens/TabOneScreen.tsx</code>工作。继续删除文件中的所有内容。</p>
<p>首先，我们有我们的进口。这些是我们将用来构建我们的用户界面，然后添加功能。</p>
<pre>import * as React from "react";
import { StyleSheet, TextInput, ScrollView, View, Text } from "react-native";
</pre>
<p>注意，<code>react-native</code>导入实际上映射到应用程序运行平台的底层原生视图。例如，一个<code>View</code>变成了:</p>
<ul>
<li>iOS → <code>UIView</code></li>
<li>安卓→ <code>ViewGroup</code></li>
<li>网页→ <code>div</code></li>
</ul>
<p>接下来，让我们创建一个任务列表。</p>
<pre>// ... 

export default function TabOneScreen() {
  const tasks = [
    { title: "Delete everything", complete: true },
    { title: "Make a working todo list", complete: false },
  ];

  return (
    &lt;ScrollView
      style={styles.container}
      contentContainerStyle={styles.contentContainer}
    &gt;
      &lt;View style={styles.tasksContainer}&gt;
        {tasks.map((task, index) =&gt; {
          const textStyles = [styles.taskText];

          if (task.complete) {
            textStyles.push(styles.taskTextComplete);
          }

          return (
            &lt;Text style={textStyles}&gt;
              {task.title}
            &lt;/Text&gt;
          );
        })}
      &lt;/View&gt;
    &lt;/ScrollView&gt;
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: "#fff",
  },
  contentContainer: {
    marginVertical: 10,
    marginHorizontal: 20,
  },
  tasksContainer: {
    marginTop: 15,
  },
  taskText: {
    fontSize: 18,
    marginVertical: 3,
  },
  taskTextComplete: {
    textDecorationLine: "line-through",
    fontSize: 18,
    marginVertical: 3,
  },
});
</pre>
<p><img data-attachment-id="41600" data-permalink="https://blog.logrocket.com/building-cross-platform-apps-expo-instead-of-react-native/tab-one-title/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2021/04/tab-one-title.png" data-orig-size="730,1580" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Tab one title" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2021/04/tab-one-title-139x300.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2021/04/tab-one-title-473x1024.png" decoding="async" class="aligncenter size-full wp-image-41600 jetpack-lazy-image" src="../Images/ba180d43df08a3cecb97362c143b99aa.png" alt="Tab One Title" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2021/04/tab-one-title.png 730w, https://blog.logrocket.com/wp-content/uploads/2021/04/tab-one-title-139x300.png 139w, https://blog.logrocket.com/wp-content/uploads/2021/04/tab-one-title-473x1024.png 473w, https://blog.logrocket.com/wp-content/uploads/2021/04/tab-one-title-710x1536.png 710w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2021/04/tab-one-title.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2021/04/tab-one-title.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="41600" data-permalink="https://blog.logrocket.com/building-cross-platform-apps-expo-instead-of-react-native/tab-one-title/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2021/04/tab-one-title.png" data-orig-size="730,1580" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Tab one title" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2021/04/tab-one-title-139x300.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2021/04/tab-one-title-473x1024.png" decoding="async" loading="lazy" class="aligncenter size-full wp-image-41600" src="../Images/ba180d43df08a3cecb97362c143b99aa.png" alt="Tab One Title" srcset="https://blog.logrocket.com/wp-content/uploads/2021/04/tab-one-title.png 730w, https://blog.logrocket.com/wp-content/uploads/2021/04/tab-one-title-139x300.png 139w, https://blog.logrocket.com/wp-content/uploads/2021/04/tab-one-title-473x1024.png 473w, https://blog.logrocket.com/wp-content/uploads/2021/04/tab-one-title-710x1536.png 710w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2021/04/tab-one-title.png"/></noscript>
<p>我们有一组任务来跟踪一个标题和一个完整的状态，我们通过<code>map</code>迭代这些任务，并将它们呈现在屏幕上。</p>
<p>与 web 相比，Expo/React Native 的独特之处在于，我们需要明确声明该视图应该是可滚动的。这就是<code>ScrollView</code>的用途。</p>
<p>最后，我们使用<code>StyleSheet</code>为我们的屏幕定义一些样式。这些映射到典型的 CSS 属性，但是采用 CSS-in-JS 格式。</p>
<p>现在让我们捕捉用户输入。我们将使用<code>TextInput</code>和 React 状态来这样做。</p>
<pre>export default function TabOneScreen() {
  const tasks = [
    { title: "Delete everything", complete: true },
    { title: "Make a working todo list", complete: false },
  ];
  const [inputValue, setInputValue] = React.useState("");

  return (
    &lt;ScrollView
      style={styles.container}
      contentContainerStyle={styles.contentContainer}
    &gt;
      &lt;TextInput
        value={inputValue}
        style={styles.input}
        onChangeText={(text) =&gt; setInputValue(text)}
        placeholder="Next task"
        onSubmitEditing={() =&gt; {
          setInputValue("");
        }}
      /&gt;
      &lt;View style={styles.tasksContainer}&gt;
        {tasks.map((task, index) =&gt; {
          const textStyles = [styles.taskText];

          if (task.complete) {
            textStyles.push(styles.taskTextComplete);
          }

          return (
            &lt;Text style={textStyles}&gt;
              {task.title}
            &lt;/Text&gt;
          );
        })}
      &lt;/View&gt;
    &lt;/ScrollView&gt;
  );
}

const styles = StyleSheet.create({
  //...

  input: {
    backgroundColor: "#f3f3f3",
    paddingHorizontal: 10,
    paddingVertical: 5,
    borderRadius: 5,
    width: "80%",
    fontSize: 20,
    borderWidth: 1,
    borderColor: "#dad4d4",
  },
});
</pre>
<p><img data-attachment-id="41601" data-permalink="https://blog.logrocket.com/building-cross-platform-apps-expo-instead-of-react-native/tab-one-title-2/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2021/04/tab-one-title-2.png" data-orig-size="730,1580" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Tab one title 2" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2021/04/tab-one-title-2-139x300.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2021/04/tab-one-title-2-473x1024.png" decoding="async" class="aligncenter size-full wp-image-41601 jetpack-lazy-image" src="../Images/4ff6bd1133843f3e342ae535926c408f.png" alt="Tab One Title 2" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2021/04/tab-one-title-2.png 730w, https://blog.logrocket.com/wp-content/uploads/2021/04/tab-one-title-2-139x300.png 139w, https://blog.logrocket.com/wp-content/uploads/2021/04/tab-one-title-2-473x1024.png 473w, https://blog.logrocket.com/wp-content/uploads/2021/04/tab-one-title-2-710x1536.png 710w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2021/04/tab-one-title-2.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2021/04/tab-one-title-2.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="41601" data-permalink="https://blog.logrocket.com/building-cross-platform-apps-expo-instead-of-react-native/tab-one-title-2/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2021/04/tab-one-title-2.png" data-orig-size="730,1580" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Tab one title 2" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2021/04/tab-one-title-2-139x300.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2021/04/tab-one-title-2-473x1024.png" decoding="async" loading="lazy" class="aligncenter size-full wp-image-41601" src="../Images/4ff6bd1133843f3e342ae535926c408f.png" alt="Tab One Title 2" srcset="https://blog.logrocket.com/wp-content/uploads/2021/04/tab-one-title-2.png 730w, https://blog.logrocket.com/wp-content/uploads/2021/04/tab-one-title-2-139x300.png 139w, https://blog.logrocket.com/wp-content/uploads/2021/04/tab-one-title-2-473x1024.png 473w, https://blog.logrocket.com/wp-content/uploads/2021/04/tab-one-title-2-710x1536.png 710w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2021/04/tab-one-title-2.png"/></noscript>
<p>类似于<code>View</code>如何映射到每个平台上的底层本地组件，一个<code>TextInput</code>做同样的事情。我们已经设置了它来捕获用户输入的值，并通过<code>React.useState</code>存储在 state 中。按下输入/完成按钮后，数值将被重置。</p>
<p><code>React.useState</code>是您希望如何管理动态变化的数据，以便随着数据的变化，UI 也随之更新。</p>
<p>目前，当我们提交输入时，它只是重置输入值。让我们实际存储和显示他们的输入。</p>
<pre>// ...

const useTasks = () =&gt; {
  const [tasks, setTasks] = React.useState([
    { title: "Delete everything", complete: true },
    { title: "Make a working todo list", complete: false },
  ]);

  const addTask = (title: string) =&gt; {
    setTasks((existingTasks) =&gt; [...existingTasks, { title, complete: false }]);
  };

  return {
    tasks,
    addTask, 
  };
};

export default function TabOneScreen() {
  const { tasks, addTask } = useTasks();
  const [inputValue, setInputValue] = React.useState("");

  return (
    &lt;ScrollView
      style={styles.container}
      contentContainerStyle={styles.contentContainer}
    &gt;
      &lt;TextInput
        value={inputValue}
        style={styles.input}
        onChangeText={(text) =&gt; setInputValue(text)}
        placeholder="Next task"
        onSubmitEditing={() =&gt; {
          addTask(inputValue);
          setInputValue("");
        }}
      /&gt;
      {/* ... */}
    &lt;/ScrollView&gt;
  );
}

// ...
</pre>
<p>这里，我们创建了一个名为<code>useTasks</code>的定制钩子。在其中，我们使用<code>React.useState</code>跟踪我们的任务数组，因为它会动态变化，因此，当数据变化时，我们需要重新呈现我们的屏幕。</p>
<p>我们还创建了一个<code>addTask</code>函数，它将适当格式化的任务附加到我们的任务列表中。</p>
<p>现在，通过添加<code>addTask(inputValue)</code>，用户在<code>onSubmitEditing</code> prop 中输入和提交的文本将被添加到任务数组中，并在屏幕上自动更新。</p>
<p>最后，让我们允许用户切换任务是否已经完成。</p>
<pre>// ...

const useTasks = () =&gt; {
  const [tasks, setTasks] = React.useState([
    { title: "Delete everything", complete: true },
    { title: "Make a working todo list", complete: false },
  ]);

  const addTask = (title: string) =&gt; {
    setTasks((existingTasks) =&gt; [...existingTasks, { title, complete: false }]);
  };

  const toggleTaskStatus = (index: number) =&gt; {
    setTasks((existingTasks) =&gt; {
      const target = existingTasks[index];
      return [
        ...existingTasks.slice(0, index),
        {
          ...target,
          complete: !target.complete,
        },
        ...existingTasks.slice(index + 1),
      ];
    });
  };

  return {
    tasks,
    addTask,
    toggleTaskStatus,
  };
};

export default function TabOneScreen() {
  const { tasks, addTask, toggleTaskStatus } = useTasks();
  const [inputValue, setInputValue] = React.useState("");

  return (
    &lt;ScrollView
      style={styles.container}
      contentContainerStyle={styles.contentContainer}
    &gt;
      {/* ... */}
      &lt;View style={styles.tasksContainer}&gt;
        {tasks.map((task, index) =&gt; {
          const textStyles = [styles.taskText];

          if (task.complete) {
            textStyles.push(styles.taskTextComplete);
          }

          return (
            &lt;Text style={textStyles} onPress={() =&gt; toggleTaskStatus(index)}&gt;
              {task.title}
            &lt;/Text&gt;
          );
        })}
      &lt;/View&gt;
    &lt;/ScrollView&gt;
  );
}

// ...
</pre>
<p>在定制的<code>useTasks</code>钩子内部，我们创建了一个<code>toggleTaskStatus</code>函数，它将在给定的索引处查找任务，并切换其完成状态，从而改变样式。</p>
<p>同样，因为我们使用的是<code>React.useState</code>，只要我们调用函数，UI 就会用更新的数据重新呈现。</p>
<p>下面是我们完成的这个文件的代码:</p>
<pre>// screens/TabOneScreen.tsx

import * as React from "react";
import { StyleSheet, TextInput, ScrollView, View, Text } from "react-native";

const useTasks = () =&gt; {
  const [tasks, setTasks] = React.useState([
    { title: "Delete everything", complete: true },
    { title: "Make a working todo list", complete: false },
  ]);

  const addTask = (title: string) =&gt; {
    setTasks((existingTasks) =&gt; [...existingTasks, { title, complete: false }]);
  };

  const toggleTaskStatus = (index: number) =&gt; {
    setTasks((existingTasks) =&gt; {
      const target = existingTasks[index];
      return [
        ...existingTasks.slice(0, index),
        {
          ...target,
          complete: !target.complete,
        },
        ...existingTasks.slice(index + 1),
      ];
    });
  };

  return {
    tasks,
    addTask,
    toggleTaskStatus,
  };
};

export default function TabOneScreen() {
  const { tasks, addTask, toggleTaskStatus } = useTasks();
  const [inputValue, setInputValue] = React.useState("");

  return (
    &lt;ScrollView
      style={styles.container}
      contentContainerStyle={styles.contentContainer}
    &gt;
      &lt;TextInput
        value={inputValue}
        style={styles.input}
        onChangeText={(text) =&gt; setInputValue(text)}
        placeholder="Next task"
        onSubmitEditing={() =&gt; {
          addTask(inputValue);
          setInputValue("");
        }}
      /&gt;
      &lt;View style={styles.tasksContainer}&gt;
        {tasks.map((task, index) =&gt; {
          const textStyles = [styles.taskText];

          if (task.complete) {
            textStyles.push(styles.taskTextComplete);
          }

          return (
            &lt;Text style={textStyles} onPress={() =&gt; toggleTaskStatus(index)}&gt;
              {task.title}
            &lt;/Text&gt;
          );
        })}
      &lt;/View&gt;
    &lt;/ScrollView&gt;
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: "#fff",
  },
  contentContainer: {
    marginVertical: 10,
    marginHorizontal: 20,
  },
  tasksContainer: {
    marginTop: 15,
  },
  taskText: {
    fontSize: 18,
    marginVertical: 3,
  },
  taskTextComplete: {
    textDecorationLine: "line-through",
    fontSize: 18,
    marginVertical: 3,
  },
  input: {
    backgroundColor: "#f3f3f3",
    paddingHorizontal: 10,
    paddingVertical: 5,
    borderRadius: 5,
    width: "80%",
    fontSize: 20,
    borderWidth: 1,
    borderColor: "#dad4d4",
  },
});
</pre>
<h2>使用 NPM 的代码</h2>
<p>React Native 最伟大的部分之一是，我们可以利用广泛的 NPM 生态系统，在我们的应用程序中使用第三方代码。让我们迁移我们的<code>TextInput</code>来使用<code>styled-components</code>。</p>
<p>首先，我们将安装软件包。</p>
<pre>yarn add styled-components
</pre>
<p>然后，我们可以用一个<code>styled-components</code>版本替换我们的<code>TextInput</code>。</p>
<pre>import * as React from "react";
import { StyleSheet, ScrollView, View, Text } from "react-native";
import styled from "styled-components/native";

const Input = styled.TextInput`
  background-color: #f3f3f3;
  border-radius: 5;
  padding-left: 10;
  padding-right: 10;
  padding-top: 5;
  padding-bottom: 5;
  width: 80%;
  font-size: 20;
  border-width: 1;
  border-color: #dad4d4;
`;

// ...

export default function TabOneScreen() {
  const { tasks, addTask, toggleTaskStatus } = useTasks();
  const [inputValue, setInputValue] = React.useState("");

  return (
    &lt;ScrollView
      style={styles.container}
      contentContainerStyle={styles.contentContainer}
    &gt;
      &lt;Input
        value={inputValue}
        onChangeText={(text: string) =&gt; setInputValue(text)}
        placeholder="Next task"
        onSubmitEditing={() =&gt; {
          addTask(inputValue);
          setInputValue("");
        }}
      /&gt;
      {/* ... */}
    &lt;/ScrollView&gt;
  );
}

// ...
</pre>
<p>这里最棒的是，就像使用 React Native 的核心组件一样，<a href="https://styled-components.com/" target="_blank" rel="noopener">风格组件</a>将继续将我们的组件翻译成应用程序运行平台的相关原生组件。我们在这里也可以使用传统的 CSS。</p>
<p>使用<code>styled-components</code>完成的代码:</p>
<pre>import * as React from "react";
import { StyleSheet, ScrollView, View, Text } from "react-native";
import styled from "styled-components/native";

const Input = styled.TextInput`
  background-color: #f3f3f3;
  border-radius: 5;
  padding-left: 10;
  padding-right: 10;
  padding-top: 5;
  padding-bottom: 5;
  width: 80%;
  font-size: 20;
  border-width: 1;
  border-color: #dad4d4;
`;

const useTasks = () =&gt; {
  const [tasks, setTasks] = React.useState([
    { title: "Delete everything", complete: true },
    { title: "Make a working todo list", complete: false },
  ]);

  const addTask = (title: string) =&gt; {
    setTasks((existingTasks) =&gt; [...existingTasks, { title, complete: false }]);
  };

  const toggleTaskStatus = (index: number) =&gt; {
    setTasks((existingTasks) =&gt; {
      const target = existingTasks[index];
      return [
        ...existingTasks.slice(0, index),
        {
          ...target,
          complete: !target.complete,
        },
        ...existingTasks.slice(index + 1),
      ];
    });
  };

  return {
    tasks,
    addTask,
    toggleTaskStatus,
  };
};

export default function TabOneScreen() {
  const { tasks, addTask, toggleTaskStatus } = useTasks();
  const [inputValue, setInputValue] = React.useState("");

  return (
    &lt;ScrollView
      style={styles.container}
      contentContainerStyle={styles.contentContainer}
    &gt;
      &lt;Input
        value={inputValue}
        onChangeText={(text: string) =&gt; setInputValue(text)}
        placeholder="Next task"
        onSubmitEditing={() =&gt; {
          addTask(inputValue);
          setInputValue("");
        }}
      /&gt;
      &lt;View style={styles.tasksContainer}&gt;
        {tasks.map((task, index) =&gt; {
          const textStyles = [styles.taskText];

          if (task.complete) {
            textStyles.push(styles.taskTextComplete);
          }

          return (
            &lt;Text style={textStyles} onPress={() =&gt; toggleTaskStatus(index)}&gt;
              {task.title}
            &lt;/Text&gt;
          );
        })}
      &lt;/View&gt;
    &lt;/ScrollView&gt;
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: "#fff",
  },
  contentContainer: {
    marginVertical: 10,
    marginHorizontal: 20,
  },
  tasksContainer: {
    marginTop: 15,
  },
  taskText: {
    fontSize: 18,
    marginVertical: 3,
  },
  taskTextComplete: {
    textDecorationLine: "line-through",
    fontSize: 18,
    marginVertical: 3,
  },
});
</pre>
<p>伙计们，这就是使用 Expo 构建一个运行在 iOS、Android 和 web 上的跨平台应用程序的全部内容！这是一个奇妙的工作流程、公司和团队，它将允许您在创建真正的本地体验的同时，倍增您的开发影响。</p><div class="code-block code-block-18">
<div class="blog-plug inline-plug react-native-plug"><h2><a href="https://lp.logrocket.com/blg/react-native-signup"> LogRocket </a>:即时重现 React 原生应用中的问题。</h2><a class="signup" href="https://lp.logrocket.com/blg/react-native-signup" target="_blank" rel="noopener noreferrer"><img class="alignnone size-full wp-image-46 jetpack-lazy-image" src="../Images/110055665562c1e02069b3698e6cc671.png" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2021/10/react-native-plug_v2-2.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2021/10/react-native-plug_v2-2.png"/><noscript><img data-lazy-fallback="1" class="alignnone size-full wp-image-46" src="../Images/110055665562c1e02069b3698e6cc671.png" data-original-src="https://blog.logrocket.com/wp-content/uploads/2021/10/react-native-plug_v2-2.png"/></noscript></a><p><a href="https://lp.logrocket.com/blg/react-native-signup" target="_blank" rel="noopener noreferrer"> LogRocket </a>是一款 React 原生监控解决方案，可帮助您即时重现问题、确定 bug 的优先级并了解 React 原生应用的性能。</p><p>LogRocket 还可以向你展示用户是如何与你的应用程序互动的，从而帮助你提高转化率和产品使用率。LogRocket 的产品分析功能揭示了用户不完成特定流程或不采用新功能的原因。</p><p>开始主动监控您的 React 原生应用— <a class="signup" href="https://lp.logrocket.com/blg/react-native-signup" target="_blank" rel="noopener noreferrer">免费试用 LogRocket】。</a></p></div>
</div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
<html>
<head>
<title>Microservices with NestJS, Kafka, and TypeScript </title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>使用NestJS、Kafka和TypeScript的微服务</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/microservices-nestjs-kafka-typescript/#0001-01-01">https://blog.logrocket.com/microservices-nestjs-kafka-typescript/#0001-01-01</a></blockquote><div><article class="article-post">
<p>微服务架构是一种日益流行的架构模式，它遵循SOA(面向服务的架构)概念。它有几个优点和缺点，但它最重要的优点之一是与其他体系结构相比，它允许更容易的可伸缩性。</p>
<p>本指南将演示如何通过Kafka和TypeScript使用NestJS构建微服务。</p>
<p><em>向前跳转:</em></p>

<h2 id="setting-up-the-project-workspace">设置项目工作环境</h2>
<p>让我们从为我们的演示设置项目工作环境开始。在继续之前，请确保您已经在本地计算机上安装并运行了Apache Kafka。您可以查看本指南，了解如何<a href="https://blog.logrocket.com/building-rust-microservices-apache-kafka/#getting-started-kafka">在本地</a>设置卡夫卡。</p>
<p>您将创建一个身份验证微服务来创建和保存用户详细信息。除了auth微服务，您还需要一个API网关来将事件从HTTP API端点发送到微服务。</p>
<p>因为您将创建多个后端服务，所以最好有一个monorepo来实现代码共享。monorepo是一个单一版本控制的代码库，包括各种应用程序和库。</p>
<p>Nx是一个管理monorepos的流行工具。这个框架允许您在monorepo中设计和扩展web应用程序和服务。</p>
<p>通过运行以下命令创建Nx工作区:</p>
<pre class="language-typescript hljs">&gt; npx <a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="8deeffe8ecf9e8a0e3f5a0fae2ffe6fefdeceee8cde1ecf9e8fef9">[email protected]</a></pre>
<p><img data-attachment-id="141478" data-permalink="https://blog.logrocket.com/microservices-nestjs-kafka-typescript/attachment/command-to-run-nx-workspace/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/11/command-to-run-nx-workspace.png" data-orig-size="730,226" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Command to run nx workspace" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/11/command-to-run-nx-workspace-300x93.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/11/command-to-run-nx-workspace.png" decoding="async" class="aligncenter size-full wp-image-141478 jetpack-lazy-image" src="../Images/1b0326dc614c74e2f2b6795c3c0c8b5e.png" alt="Command to Run Nx Workspace" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2022/11/command-to-run-nx-workspace.png 730w, https://blog.logrocket.com/wp-content/uploads/2022/11/command-to-run-nx-workspace-300x93.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2022/11/command-to-run-nx-workspace.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/11/command-to-run-nx-workspace.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="141478" data-permalink="https://blog.logrocket.com/microservices-nestjs-kafka-typescript/attachment/command-to-run-nx-workspace/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/11/command-to-run-nx-workspace.png" data-orig-size="730,226" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Command to run nx workspace" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/11/command-to-run-nx-workspace-300x93.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/11/command-to-run-nx-workspace.png" decoding="async" loading="lazy" class="aligncenter size-full wp-image-141478" src="../Images/1b0326dc614c74e2f2b6795c3c0c8b5e.png" alt="Command to Run Nx Workspace" srcset="https://blog.logrocket.com/wp-content/uploads/2022/11/command-to-run-nx-workspace.png 730w, https://blog.logrocket.com/wp-content/uploads/2022/11/command-to-run-nx-workspace-300x93.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/11/command-to-run-nx-workspace.png"/></noscript>
<p>创建工作区时指定<code>nest</code>选项，并将应用程序命名为<code>api-gateway</code>。</p>
<p>创建工作空间后，通过运行以下命令安装项目依赖项:</p>
<pre class="language-typescript hljs">&gt; cd nestjs-microservices
&gt; npm i @nestjs/microservices kafkajs class-validator class-transformer
</pre>
<h2 id="getting-started-with-the-api-gateway">API网关入门</h2>
<p>API网关是微服务架构中的服务之一，它将客户端和外部应用程序连接到内部服务。API gateway处理路由、转换和聚合请求数据，并实现共享逻辑，如身份验证和限速器。</p>
<p><img data-attachment-id="141480" data-permalink="https://blog.logrocket.com/microservices-nestjs-kafka-typescript/attachment/user-gateway-kafka-auth-microservice/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/11/user-gateway-kafka-auth-microservice.png" data-orig-size="730,231" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="User gateway Kafka auth microservice" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/11/user-gateway-kafka-auth-microservice-300x95.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/11/user-gateway-kafka-auth-microservice.png" decoding="async" class="aligncenter size-full wp-image-141480 jetpack-lazy-image" src="../Images/9ceadaef6af99ef0fd62a7bf7b5ce84d.png" alt="User Gateway Kafka Auth Microservice" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2022/11/user-gateway-kafka-auth-microservice.png 730w, https://blog.logrocket.com/wp-content/uploads/2022/11/user-gateway-kafka-auth-microservice-300x95.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2022/11/user-gateway-kafka-auth-microservice.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/11/user-gateway-kafka-auth-microservice.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="141480" data-permalink="https://blog.logrocket.com/microservices-nestjs-kafka-typescript/attachment/user-gateway-kafka-auth-microservice/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/11/user-gateway-kafka-auth-microservice.png" data-orig-size="730,231" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="User gateway Kafka auth microservice" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/11/user-gateway-kafka-auth-microservice-300x95.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/11/user-gateway-kafka-auth-microservice.png" decoding="async" loading="lazy" class="aligncenter size-full wp-image-141480" src="../Images/9ceadaef6af99ef0fd62a7bf7b5ce84d.png" alt="User Gateway Kafka Auth Microservice" srcset="https://blog.logrocket.com/wp-content/uploads/2022/11/user-gateway-kafka-auth-microservice.png 730w, https://blog.logrocket.com/wp-content/uploads/2022/11/user-gateway-kafka-auth-microservice-300x95.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/11/user-gateway-kafka-auth-microservice.png"/></noscript>
<p>通常，当前端应用调用注册API时，API网关会向Kafka队列发出<code>create_user</code>事件。auth微服务将从队列中轮询<code>create_user</code>事件，并从事件负载中创建一个用户。</p>
<p>在这种架构模式下，前端应用不会直接与微服务交互。通常，在现实场景中，API网关还具有额外的功能，如日志记录、分析和负载平衡。</p>
<p>在api-gateway应用程序中，创建auth模块，负责处理与身份验证相关的请求，如注册。使用auth模块中的<code>@nestjs/microservices</code>包中的<code>ClientsModule</code>配置Kafka客户端。</p>
<p><code>ClientsModule</code>公开了一个静态的<code>register()</code>方法，该方法将描述微服务传输器的对象数组作为参数。每个传输器对象都有一个<code>name</code>属性、一个<code>transporter</code>属性(在本例中是<code>Transport.Kafka</code>)和一个特定于传输器的<code>options</code>属性。<code>name</code>属性定义了注入令牌，稍后您可以在服务类中使用它来发布事件:</p>
<pre class="language-typescript hljs">// apps/api-gateway/src/auth/auth.module.ts

import { Module } from '@nestjs/common';
import { ClientsModule, Transport } from '@nestjs/microservices';
import { AuthController } from './auth.controller';
import { AuthService } from './auth.service';

@Module({
  imports: [
    ClientsModule.register([
      {
        name: 'AUTH_MICROSERVICE',
        transport: Transport.KAFKA,
        options: {
          client: {
            clientId: 'auth',
            brokers: ['localhost:9092'],
          },
          producerOnlyMode: true,
          consumer: {
            groupId: 'auth-consumer',
          },
        },
      },
    ]),
  ],
  providers: [AuthService],
  controllers: [AuthController],
})
export class AuthModule {} 
</pre>
<p>因为传输是Kafka，<code>options</code>属性将定义Kafka客户端对象，它包括<code>clientId</code>、<code>brokers</code>和一个带有<code>groupId</code>的<code>consumer</code>对象。在这里，您指定的<code>groupId</code>是必不可少的，因为具有相同<code>groupId</code>的消费者只能读取发布的事件。</p>
<p>例如，使用<code>groupId</code> auth-consumer的消费者只能阅读使用<code>groupId:</code> <code>'auth-consumer'</code>发布的事件。<code>producerOnlyMode</code>选项将绕过api-gateway应用程序的消费者组注册，仅作为生产者。</p>
<h3 id="code-sharing-among-microservices">微服务之间的代码共享</h3>
<p>由于创建用户的HTTP请求负载和事件负载是相同的，所以最好创建一个共享数据传输对象(DTO ),所有服务都可以在monorepo中访问它。</p>
<p>通过运行以下命令创建共享库:</p>
<pre class="language-typescript hljs">&gt; nx g @nrwl/node:lib shared
</pre>
<p>接下来，创建一个<code>dto</code>文件夹；在<code>create-user.dto.ts</code>文件中添加具有强制<code>name</code>和<code>email</code>属性的<code>CreateUserDto</code>类；</p>
<pre class="language-typescript hljs">// libs/shared/src/lib/dto/create-user.dto.ts

import { IsEmail, IsNotEmpty, IsString } from 'class-validator';

export class CreateUserDto {
  @IsString()
  @IsNotEmpty()
  name: string;

  @IsEmail()
  @IsNotEmpty()
  email: string;
}</pre>
<pre class="language-typescript hljs">// libs/shared/src/lib/dto/index.ts

export * from './create-user.dto';
</pre>
<p>现在，在<code>paths</code>对象中添加一个条目，用于解析<code>tsconfig.base.json</code>文件中的<code>dto</code>文件:</p>
<pre class="language-typescript hljs">{
  ...
  "paths": {
      ...
      "@nestjs-microservices/shared/dto": ["libs/shared/src/lib/dto/index.ts"]
  }
  ...
}
</pre>
<p>回到api-gateway应用程序，创建<code>AuthService</code>将事件发布到auth微服务。</p>
<p>通过使用<code>@Inject()</code>装饰器创建一个<code>ClientKafka</code>的实例，并使用在Kafka传输的<code>name</code>属性中指定的<code>AUTH_MICROSERVICE</code>注入标记。使用客户端实例，您可以访问<code>emit()</code>方法来发布<code>create_user</code>事件和有效负载:</p>
<pre class="language-typescript hljs">// apps/api-gateway/src/auth/auth.service.ts

import { Inject, Injectable } from '@nestjs/common';
import { ClientKafka } from '@nestjs/microservices';
import { CreateUserDto } from '@nestjs-microservices/shared/dto';

@Injectable()
export class AuthService {
  constructor(
    @Inject('AUTH_MICROSERVICE') private readonly authClient: ClientKafka
  ) {}

  createUser(createUserDto: CreateUserDto) {
    this.authClient.emit('create_user', JSON.stringify(createUserDto));
  }
}
</pre>
<p>接下来，在<code>AuthController</code>类中，创建一个用于创建用户的API端点，并调用<code>AuthService</code>的<code>createUser</code>方法:</p>
<pre class="language-typescript hljs">// apps/api-gateway/src/auth/auth.controller.ts

import { Body, Controller, Post, ValidationPipe } from '@nestjs/common';
import { AuthService } from './auth.service';
import { CreateUserDto } from '@nestjs-microservices/shared/dto';

@Controller('auth')
export class AuthController {
  constructor(private readonly authService: AuthService) {}

  @Post('sign-up')
  createUser(@Body(ValidationPipe) createUserDto: CreateUserDto) {
    return this.authService.createUser(createUserDto);
  }
}
</pre>
<h2 id="creating-the-auth-microservice">创建授权微服务</h2>
<p>接下来，您将创建auth微服务来使用API网关发送的<code>create_user</code>消息。</p>
<p>要创建授权微服务应用程序，请运行以下命令:</p>
<pre class="language-typescript hljs">&gt; nx g @nrwl/nest:app auth-microservice
</pre>
<p>在auth-microservice app的<code>main.ts</code>文件中，去掉<code>bootstrap()</code>函数的样板代码，替换为<code>NestFactory.createMicroservice()</code>方法。</p>
<p>将第一个参数中的<code>AppModule</code>和第二个参数中的Kafka <code>transport</code>对象传递给<code>createMicroservice()</code>方法。在<code>consumer</code>对象的<code>groupId</code>属性中，确保您指定了与api-gateway应用程序的<code>AuthModule</code>中使用的值相同的值:</p>
<pre class="language-typescript hljs">// apps/auth-microservice/src/main.ts

async function bootstrap() {
  const app = await NestFactory.createMicroservice&lt;MicroserviceOptions&gt;(
    AppModule,
    {
      transport: Transport.KAFKA,
      options: {
        client: {
          brokers: ['localhost:9092'],
        },
        consumer: {
          groupId: 'auth-consumer',
        },
      },
    }
  );
  await app.listen();
}
</pre>
<p>接下来，在共享库中创建一个<code>User</code>实体来表示用户数据。在<code>UsersRepository</code>类中使用这个实体it来执行类似保存用户数据和通过<code>id</code>检索单个用户的操作:</p>
<pre class="language-typescript hljs">// libs/shared/src/lib/entities/user.entity.ts

export class User {
  id?: number;
  name: string;
  email: string;
}</pre>
<pre class="language-typescript hljs">// libs/shared/src/lib/entities/index.ts

export * from './user.entity';</pre>
<pre class="language-typescript hljs">// apps/auth-microservice/src/app/users.repository.ts

import { Injectable } from '@nestjs/common';
import { User } from '@nestjs-microservices/shared/entities';

@Injectable()
export class UsersRepository {
  private readonly users: User[] = [];

  save(user: User) {
    this.users.push({ ...user, id: this.users.length + 1 });
  }

  findOne(id: number) {
    return this.users.find((u) =&gt; u.id === id) || null;
  }
}
</pre>
<p>通常，在NestJS应用程序中，TypeORM用于通过数据库管理数据，但是为了演示的简洁，我们将数据存储在内存中。</p>
<p>在<code>AppService</code>中，创建<code>createUser()</code>和<code>getUser()</code>方法，分别用<code>UsersRepository</code>方法创建和查找用户:</p>
<pre class="language-typescript hljs">// apps/auth-microservice/src/app/app.service.ts

import { CreateUserDto } from '@nestjs-microservices/shared/dto';
import { User } from '@nestjs-microservices/shared/entities';
import { Injectable } from '@nestjs/common';
import { UsersRepository } from './users.repository';

@Injectable()
export class AppService {
  constructor(private readonly usersRepository: UsersRepository) {}

  createUser(data: CreateUserDto): void {
    this.usersRepository.save(data);
  }

  getUser(id: number): User {
    return this.usersRepository.findOne(id);
  }
}
</pre>
<p>现在在<code>app.controller.ts</code>文件中，创建一个方法来处理<code>create_user</code>事件。使用<code>@EventPattern()</code>装饰器创建一个事件处理程序并传递事件名称。您可以使用<code>@Payload()</code>装饰器访问事件数据，类似于<code>@Body()</code>装饰器，您可以使用<code>ValidationPipe</code>来验证有效负载对象:</p>
<pre class="language-typescript hljs">// apps/auth-microservice/src/app/app.controller.ts

import { CreateUserDto } from '@nestjs-microservices/shared/dto';
import { Controller, ParseIntPipe, ValidationPipe } from '@nestjs/common';
import { EventPattern, MessagePattern, Payload } from '@nestjs/microservices';

import { AppService } from './app.service';

@Controller()
export class AppController {
  constructor(private readonly appService: AppService) {}

  @EventPattern('create_user')
  handleUserCreate(@Payload(ValidationPipe) data: CreateUserDto) {
    this.appService.createUser(data);
  }
}
</pre>
<h2 id="adding-the-payments-microservice">添加支付微服务</h2>
<p>现在auth微服务已经启动并运行，让我们添加一个支付微服务来处理用户帐户的支付，并完成整个架构。</p>
<p><img data-attachment-id="141482" data-permalink="https://blog.logrocket.com/microservices-nestjs-kafka-typescript/attachment/payments-microservice-architecture/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/11/payments-microservice-architecture.png" data-orig-size="730,385" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Payments microservice architecture" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/11/payments-microservice-architecture-300x158.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/11/payments-microservice-architecture.png" decoding="async" class="aligncenter wp-image-141482 size-full jetpack-lazy-image" src="../Images/93b5c655ec0dfef650a994bfd5928169.png" alt="Auth Microservice Architecture for Payment Processing" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2022/11/payments-microservice-architecture.png 730w, https://blog.logrocket.com/wp-content/uploads/2022/11/payments-microservice-architecture-300x158.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2022/11/payments-microservice-architecture.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/11/payments-microservice-architecture.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="141482" data-permalink="https://blog.logrocket.com/microservices-nestjs-kafka-typescript/attachment/payments-microservice-architecture/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/11/payments-microservice-architecture.png" data-orig-size="730,385" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Payments microservice architecture" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/11/payments-microservice-architecture-300x158.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/11/payments-microservice-architecture.png" decoding="async" loading="lazy" class="aligncenter wp-image-141482 size-full" src="../Images/93b5c655ec0dfef650a994bfd5928169.png" alt="Auth Microservice Architecture for Payment Processing" srcset="https://blog.logrocket.com/wp-content/uploads/2022/11/payments-microservice-architecture.png 730w, https://blog.logrocket.com/wp-content/uploads/2022/11/payments-microservice-architecture-300x158.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/11/payments-microservice-architecture.png"/></noscript>
<p>第一步是在api-gateway应用程序中创建一个API端点，前端应用程序可以调用它来启动支付。在请求正文中，您需要<code>userId</code>和支付金额。</p>
<p>API网关将发出一个名为<code>process_payment</code>的事件和支付数据，支付微服务将读取这些数据。支付微服务将需要用户详细信息来处理支付。因为您只传递了<code>userId</code>，其余的数据将通过发布<code>get_user</code>事件从auth服务中检索。</p>
<p>在api-gateway应用程序中，您将创建支付模块并注册Kafka客户端，类似于您为auth模块设置它的方式。对于支付模块，<code>groupId</code>将是<code>payment-consumer</code>:</p>
<pre class="language-typescript hljs">// apps/api-gateway/src/payment/payments.module.ts

import { Module } from '@nestjs/common';
import { ClientsModule, Transport } from '@nestjs/microservices';
import { PaymentController } from './payment.controller';
import { PaymentService } from './payment.service';

@Module({
  imports: [
    ClientsModule.register([
      {
        name: 'PAYMENT_MICROSERVICE',
        transport: Transport.KAFKA,
        options: {
          client: {
            clientId: 'payment',
            brokers: ['localhost:9092'],
          },
          consumer: {
            groupId: 'payment-consumer',
          },
        },
      },
    ]),
  ],
  providers: [PaymentService],
  controllers: [PaymentController],
})
export class PaymentModule {}
</pre>
<p>然后，在共享库中创建<code>MakePaymentDto</code>，它将用于表示处理支付的有效负载:</p>
<pre class="language-typescript hljs">// libs/shared/src/lib/dto/make-payment.dto.ts

import { IsNotEmpty, IsNumber } from 'class-validator';

export class MakePaymentDto {
  @IsNotEmpty()
  @IsNumber()
  userId: number;

  @IsNotEmpty()
  @IsNumber()
  amount: number;
}
</pre>
<p>接下来，在<code>PaymentController</code>中，添加一个POST API来创建发布<code>process_payment</code>事件的入口点:</p>
<pre class="language-typescript hljs">// apps/api-gateway/src/payment/payment.controller.ts

import { Body, Controller, Post, ValidationPipe } from '@nestjs/common';
import { PaymentService } from './payment.service';
import { MakePaymentDto } from '@nestjs-microservices/shared/dto';

@Controller('payments')
export class PaymentController {
  constructor(private readonly paymentService: PaymentService) {}

  @Post('pay')
  makePayment(@Body(ValidationPipe) makePaymentDto: MakePaymentDto) {
    return this.paymentService.makePayment(makePaymentDto);
  }
}
</pre>
<p>在<code>PaymentService</code>中，使用<code>@Inject()</code>装饰器和<code>PAYMENT_MICROSERVICE</code>作为注入令牌来注入<code>ClientKafka</code>。现在，使用Kafka客户端发出<code>process_payment</code>事件:</p>
<pre class="language-typescript hljs">// apps/api-gateway/src/payment/payment.service.ts

import { Inject, Injectable } from '@nestjs/common';
import { ClientKafka } from '@nestjs/microservices';
import { MakePaymentDto } from '@nestjs-microservices/shared/dto';

@Injectable()
export class PaymentService {
  constructor(
    @Inject('PAYMENT_MICROSERVICE') private readonly paymentClient: ClientKafka
  ) {}

  makePayment(makePaymentDto: MakePaymentDto) {
    this.paymentClient.emit('process_payment', JSON.stringify(makePaymentDto));
  }
}
</pre>
<p>支付集成的API网关部分已经完成。现在，让我们用微服务应用程序来构建。</p>
<h2 id="building-the-microservice-app">构建微服务应用</h2>
<p>首先运行以下命令来创建支付微服务应用程序:</p>
<pre class="language-typescript hljs">&gt; nx g @nrwl/nest:app payments-microservice
</pre>
<p>类似于auth-microservice，用<code>createMicroservice()</code>方法替换<code>main.ts file</code>的内容。在这里，您还将使用值<code>'payment-consumer'</code>来定义<code>groupId</code>:</p>
<pre class="language-typescript hljs">// apps/payments-microservice/src/main.ts

import { NestFactory } from '@nestjs/core';
import { MicroserviceOptions, Transport } from '@nestjs/microservices';

import { AppModule } from './app/app.module';

async function bootstrap() {
  const app = await NestFactory.createMicroservice&lt;MicroserviceOptions&gt;(
    AppModule,
    {
      transport: Transport.KAFKA,
      options: {
        client: {
          brokers: ['localhost:9092'],
        },
        consumer: {
          groupId: 'payment-consumer',
        },
      },
    }
  );
  await app.listen();
}

bootstrap();
</pre>
<p>现在，在<code>app.module.ts</code>文件中注册一个向auth-microservice发送事件的Kafka客户端:</p>
<pre class="language-typescript hljs">// apps/payments-microservice/src/app/app.module.ts

import { Module } from '@nestjs/common';
import { ClientsModule, Transport } from '@nestjs/microservices';

import { AppController } from './app.controller';
import { AppService } from './app.service';

@Module({
  imports: [
    ClientsModule.register([
      {
        name: 'AUTH_MICROSERVICE',
        transport: Transport.KAFKA,
        options: {
          client: {
            clientId: 'auth',
            brokers: ['localhost:9092'],
          },
          consumer: {
            groupId: 'auth-consumer',
          },
        },
      },
    ]),
  ],
  controllers: [AppController],
  providers: [AppService],
})
export class AppModule {}
</pre>
<p>在<code>AppService</code>中，将发布事件的Kafka客户端注入auth-microservice app。当您发出<code>get_user</code>事件时，您需要监听来自auth微服务的响应；这与你为<code>create_user</code>事件所做的不同。</p>
<p>对于Kafka通信，事件的响应在NestJS现成处理的回复事件中返回。Nest自动在一个以关键字<code>.reply</code>结束的新事件中发回回复。微服务之间的这种通信被称为<a href="https://blog.logrocket.com/nodejs-pub-sub-messaging-brokers/">请求-响应模式</a>。</p>
<p>要在<code>AppService</code>中配置这种通信，您需要实现<code>onModuleInit</code>接口并使用<code>onModuleInit()</code>生命周期方法来订阅使用<code>subscribeToResponseOf()</code>方法的<code>get_user</code>事件的响应。您不必为<code>get_user.reply</code>事件手动添加任何处理程序，因为Nest会处理这些。</p>
<pre class="language-typescript hljs">// apps/payments-microservice/src/app/app.service.ts

import { MakePaymentDto } from '@nestjs-microservices/shared/dto';
import { User } from '@nestjs-microservices/shared/entities';
import { Inject, Injectable, OnModuleInit } from '@nestjs/common';
import { ClientKafka } from '@nestjs/microservices';

@Injectable()
export class AppService implements OnModuleInit {
  constructor(
    @Inject('AUTH_MICROSERVICE') private readonly authClient: ClientKafka
  ) {}

  processPayment(makePaymentDto: MakePaymentDto) {
    const { userId, amount } = makePaymentDto;
    console.log('process payment');
    this.authClient
      .send('get_user', JSON.stringify({ userId }))
      .subscribe((user: User) =&gt; {
        console.log(
          `process payment for user ${user.name} - amount: ${amount}`
        );
      });
  }

  onModuleInit() {
    this.authClient.subscribeToResponseOf('get_user');
  }
}
</pre>
<p>不使用<code>emit()</code>方法来发布<code>get_user</code>事件，而是使用<code>send()</code>方法。<code>send()</code>方法使您能够使用回调来订阅事件的回复。</p>
<p>现在，通过在支付<code>AppController</code>中添加<code>process_payment</code>事件的事件处理程序来结束支付微服务:</p>
<pre class="language-typescript hljs">// apps/payments-microservice/src/app/app.controller.ts

import { MakePaymentDto } from '@nestjs-microservices/shared/dto';
import { Controller, ValidationPipe } from '@nestjs/common';
import { EventPattern, Payload } from '@nestjs/microservices';

import { AppService } from './app.service';

@Controller()
export class AppController {
  constructor(private readonly appService: AppService) {}

  @EventPattern('process_payment')
  handleProcessPayment(@Payload(ValidationPipe) data: MakePaymentDto) {
    this.appService.processPayment(data);
  }
}
</pre>
<p>接下来，切换回auth-microservice app的<code>AppController</code>，添加<code>get_user</code>事件的处理程序，完成请求-响应通信。对于请求-响应消息传递模式，您需要使用<code>@MessagePattern()</code>装饰器来消费事件:</p>
<pre class="language-typescript hljs">// apps/auth-microservice/src/app/app.controller.ts


@Controller()
export class AppController {

  @MessagePattern('get_user')
  handleGetUser(@Payload('userId', ParseIntPipe) userId: number) {
    return this.appService.getUser(userId);
  }
}
</pre>
<h2 id="running-and-testing-the-services">运行和测试服务</h2>
<p>要测试并查看所有运行中的服务，您需要在单独的终端上分别运行以下命令:</p>
<pre class="language-typescript hljs">&gt; nx serve api-gateway
&gt; nx serve auth-microservice
&gt; nx serve payments-microservice
</pre>
<p>现在微服务已经启动并运行，让我们用Postman测试一下。</p>
<p>选择<code>/api/auth/signup</code> API来创建用户:</p>
<p><img data-attachment-id="141485" data-permalink="https://blog.logrocket.com/microservices-nestjs-kafka-typescript/attachment/create-user-api/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/11/create-user-api.png" data-orig-size="730,418" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Create user API" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/11/create-user-api-300x172.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/11/create-user-api.png" decoding="async" class="aligncenter wp-image-141485 size-full jetpack-lazy-image" src="../Images/36922ee19a444d5c6823d9530e463975.png" alt="Testing NestJS and Kafka Microservices with Postman" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2022/11/create-user-api.png 730w, https://blog.logrocket.com/wp-content/uploads/2022/11/create-user-api-300x172.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2022/11/create-user-api.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/11/create-user-api.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="141485" data-permalink="https://blog.logrocket.com/microservices-nestjs-kafka-typescript/attachment/create-user-api/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/11/create-user-api.png" data-orig-size="730,418" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Create user API" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/11/create-user-api-300x172.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/11/create-user-api.png" decoding="async" loading="lazy" class="aligncenter wp-image-141485 size-full" src="../Images/36922ee19a444d5c6823d9530e463975.png" alt="Testing NestJS and Kafka Microservices with Postman" srcset="https://blog.logrocket.com/wp-content/uploads/2022/11/create-user-api.png 730w, https://blog.logrocket.com/wp-content/uploads/2022/11/create-user-api-300x172.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/11/create-user-api.png"/></noscript>
<p>接下来，调用<code>/api/payments/pay</code> API用<code>userId</code>和<code>amount</code>处理支付:</p>
<p><img data-attachment-id="141487" data-permalink="https://blog.logrocket.com/microservices-nestjs-kafka-typescript/attachment/process-payment-api/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/11/process-payment-api.png" data-orig-size="730,502" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Process payment API" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/11/process-payment-api-300x206.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/11/process-payment-api.png" decoding="async" class="aligncenter wp-image-141487 size-full jetpack-lazy-image" src="../Images/2705f24a4937a2113a8326ea07f07c28.png" alt="Calling the Microservices API" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2022/11/process-payment-api.png 730w, https://blog.logrocket.com/wp-content/uploads/2022/11/process-payment-api-300x206.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2022/11/process-payment-api.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/11/process-payment-api.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="141487" data-permalink="https://blog.logrocket.com/microservices-nestjs-kafka-typescript/attachment/process-payment-api/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/11/process-payment-api.png" data-orig-size="730,502" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Process payment API" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/11/process-payment-api-300x206.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/11/process-payment-api.png" decoding="async" loading="lazy" class="aligncenter wp-image-141487 size-full" src="../Images/2705f24a4937a2113a8326ea07f07c28.png" alt="Calling the Microservices API" srcset="https://blog.logrocket.com/wp-content/uploads/2022/11/process-payment-api.png 730w, https://blog.logrocket.com/wp-content/uploads/2022/11/process-payment-api-300x206.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/11/process-payment-api.png"/></noscript>
<p><img data-attachment-id="141489" data-permalink="https://blog.logrocket.com/microservices-nestjs-kafka-typescript/attachment/console-message/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/11/console-message.png" data-orig-size="730,177" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Console message" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/11/console-message-300x73.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/11/console-message.png" decoding="async" class="aligncenter wp-image-141489 size-full jetpack-lazy-image" src="../Images/5fda48007e54eff9052b4d04e8972b3e.png" alt="Console Message Confirming Microservices Set Up" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2022/11/console-message.png 730w, https://blog.logrocket.com/wp-content/uploads/2022/11/console-message-300x73.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2022/11/console-message.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/11/console-message.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="141489" data-permalink="https://blog.logrocket.com/microservices-nestjs-kafka-typescript/attachment/console-message/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/11/console-message.png" data-orig-size="730,177" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Console message" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/11/console-message-300x73.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/11/console-message.png" decoding="async" loading="lazy" class="aligncenter wp-image-141489 size-full" src="../Images/5fda48007e54eff9052b4d04e8972b3e.png" alt="Console Message Confirming Microservices Set Up" srcset="https://blog.logrocket.com/wp-content/uploads/2022/11/console-message.png 730w, https://blog.logrocket.com/wp-content/uploads/2022/11/console-message-300x73.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/11/console-message.png"/></noscript>
<p>如果微服务之间的通信设置正确，您应该会在终端上看到一条控制台消息，如上所示。</p>
<h2 id="conclusion">结论</h2>
<p>本文研究了使用NestJS和Kafka的微服务架构构建健壮的应用程序。我们展示了如何结合使用这些技术来创建一个可伸缩的、可靠的、易于维护的系统。如果您正在寻找一种方法来构建易于开发和部署的微服务，那么这个堆栈是值得考虑的。</p>
<p>您可以通过使用Kafka通信创建重试逻辑来进一步探索微服务，以便在微服务关闭时关键数据不会丢失。</p>
<p>作为参考，您可以在<a href="https://github.com/vijitail/nestjs-kafka-microservices"> GitHub </a>上找到本指南的完整代码。</p><div class="code-block code-block-21">
<div class="blog-plug inline-plug typescript-plug"><h2><a class="signup" href="https://lp.logrocket.com/blg/typescript-signup" target="_blank" rel="noopener noreferrer"> LogRocket </a>:全面了解您的网络和移动应用</h2>
<a href="https://lp.logrocket.com/blg/typescript-signup" class="signup" target="_blank" rel="noopener noreferrer"><img class="alignnone size-full wp-image-46 jetpack-lazy-image" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/><noscript><img data-lazy-fallback="1" class="alignnone size-full wp-image-46" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/></noscript></a>
<p>LogRocket 是一个前端应用程序监控解决方案，可以让您回放问题，就像问题发生在您自己的浏览器中一样。LogRocket不需要猜测错误发生的原因，也不需要向用户询问截图和日志转储，而是让您重放会话以快速了解哪里出错了。它可以与任何应用程序完美配合，不管是什么框架，并且有插件可以记录来自Redux、Vuex和@ngrx/store的额外上下文。</p>
<p>除了记录Redux操作和状态，LogRocket还记录控制台日志、JavaScript错误、堆栈跟踪、带有头+正文的网络请求/响应、浏览器元数据和自定义日志。它还使用DOM来记录页面上的HTML和CSS，甚至为最复杂的单页面和移动应用程序重新创建像素级完美视频。</p>
<a class="signup" href="https://lp.logrocket.com/blg/typescript-signup" target="_blank" rel="noopener noreferrer">Try it for free</a><p>.</p></div>
</div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

 </div>    
</body>
</html>
<html>
<head>
<title>Swapping GraphQL servers with the least effort - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>用最少的努力交换 GraphQL 服务器</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/swapping-graphql-servers-with-least-effort/#0001-01-01">https://blog.logrocket.com/swapping-graphql-servers-with-least-effort/#0001-01-01</a></blockquote><div><article class="article-post">
<p>“针对接口而不是实现进行编码”是指不直接调用功能，而是通过一个契约来调用，该契约列举了所需的输入和预期的输出，并隐藏了实现是如何完成的。这种策略有助于将应用程序从特定的实现、提供者或堆栈中分离出来，并使您能够在它们之间进行交换，而不必更改应用程序代码。</p>
<p>我们可以用 GraphQL 通过使用源代码插件来执行这个策略，就像 Gatsby 举例说明的<a href="https://www.gatsbyjs.com/docs/creating-a-source-plugin" target="_blank" rel="noopener">。源插件检索特定 GraphQL 服务器所需的数据，允许我们在安装不同的源插件后，用另一个 GraphQL 服务器交换向应用程序提供数据的 graph QL 服务器。</a></p>
<figure id="attachment_66287" aria-describedby="caption-attachment-66287" class="wp-caption aligncenter"><img data-attachment-id="66287" data-permalink="https://blog.logrocket.com/swapping-graphql-servers-with-least-effort/attachment/gatsby-plugin-director/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2021/09/gatsby-plugin-director.png" data-orig-size="730,528" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="gatsby-plugin-director" data-image-description="" data-image-caption="&lt;p&gt;Gatsby offers over 500 plugins in its directory&lt;/p&gt;&#10;" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2021/09/gatsby-plugin-director-300x217.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2021/09/gatsby-plugin-director.png" decoding="async" class="size-full wp-image-66287 jetpack-lazy-image" src="../Images/5052e4797ec8ef77d5228514e361117b.png" alt="The Gatsby plugin directory" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2021/09/gatsby-plugin-director.png 730w, https://blog.logrocket.com/wp-content/uploads/2021/09/gatsby-plugin-director-300x217.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2021/09/gatsby-plugin-director.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2021/09/gatsby-plugin-director.png"/><noscript><img data-lazy-fallback="1" data-attachment-id="66287" data-permalink="https://blog.logrocket.com/swapping-graphql-servers-with-least-effort/attachment/gatsby-plugin-director/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2021/09/gatsby-plugin-director.png" data-orig-size="730,528" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="gatsby-plugin-director" data-image-description="" data-image-caption="&lt;p&gt;Gatsby offers over 500 plugins in its directory&lt;/p&gt;&#10;" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2021/09/gatsby-plugin-director-300x217.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2021/09/gatsby-plugin-director.png" decoding="async" loading="lazy" class="size-full wp-image-66287" src="../Images/5052e4797ec8ef77d5228514e361117b.png" alt="The Gatsby plugin directory" srcset="https://blog.logrocket.com/wp-content/uploads/2021/09/gatsby-plugin-director.png 730w, https://blog.logrocket.com/wp-content/uploads/2021/09/gatsby-plugin-director-300x217.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2021/09/gatsby-plugin-director.png"/></noscript><figcaption id="caption-attachment-66287" class="wp-caption-text">Gatsby offers over 500 plugins in its directory</figcaption></figure>
<p>源代码插件方法产生了一个可靠的、可扩展的架构，但是它非常耗时，因为我们需要了解 GraphQL 服务器的所有细节。它适用于通用应用程序，如 Gatsby，但对于我们自己从头构建的定制应用程序来说，可能有些矫枉过正，我们可能希望这些应用程序可以重用于需求略有不同的不同客户。</p>
<p>对于这种情况，有一个更简单的策略:我们可以使用 GraphQL 查询作为应用程序和服务器之间的中介，只对 GraphQL 查询执行任何需要的修改，保持业务逻辑不变。</p>
<p>在本文中，我们将探索这种方法。</p>
<h2>使用 GraphQL 查询作为接口</h2>
<p>GraphQL 查询充当客户机和服务器之间的接口。当执行一个查询时，GraphQL 服务器将处理它并将所需的数据返回给客户机。但是数据从哪里来呢？是如何获得的？客户端<a href="https://blog.logrocket.com/client-side-query-customization-in-graphql/" target="_blank" rel="noopener">不知道，也不关心</a>。</p>
<figure id="attachment_66289" aria-describedby="caption-attachment-66289" class="wp-caption aligncenter"><img data-attachment-id="66289" data-permalink="https://blog.logrocket.com/swapping-graphql-servers-with-least-effort/attachment/graphql-query-acts-as-interface/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2021/09/graphql-query-acts-as-interface.png" data-orig-size="730,299" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="graphql-query-acts-as-interface" data-image-description="" data-image-caption="&lt;p&gt;The GraphQL query acts as an interface between client and server&lt;/p&gt;&#10;" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2021/09/graphql-query-acts-as-interface-300x123.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2021/09/graphql-query-acts-as-interface.png" decoding="async" class="size-full wp-image-66289 jetpack-lazy-image" src="../Images/709703dbcdea55b9eae4657aa6eb1006.png" alt="GraphQL query as interface" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2021/09/graphql-query-acts-as-interface.png 730w, https://blog.logrocket.com/wp-content/uploads/2021/09/graphql-query-acts-as-interface-300x123.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2021/09/graphql-query-acts-as-interface.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2021/09/graphql-query-acts-as-interface.png"/><noscript><img data-lazy-fallback="1" data-attachment-id="66289" data-permalink="https://blog.logrocket.com/swapping-graphql-servers-with-least-effort/attachment/graphql-query-acts-as-interface/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2021/09/graphql-query-acts-as-interface.png" data-orig-size="730,299" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="graphql-query-acts-as-interface" data-image-description="" data-image-caption="&lt;p&gt;The GraphQL query acts as an interface between client and server&lt;/p&gt;&#10;" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2021/09/graphql-query-acts-as-interface-300x123.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2021/09/graphql-query-acts-as-interface.png" decoding="async" loading="lazy" class="size-full wp-image-66289" src="../Images/709703dbcdea55b9eae4657aa6eb1006.png" alt="GraphQL query as interface" srcset="https://blog.logrocket.com/wp-content/uploads/2021/09/graphql-query-acts-as-interface.png 730w, https://blog.logrocket.com/wp-content/uploads/2021/09/graphql-query-acts-as-interface-300x123.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2021/09/graphql-query-acts-as-interface.png"/></noscript><figcaption id="caption-attachment-66289" class="wp-caption-text">The GraphQL query acts as an interface between client and server</figcaption></figure>
<p>对查询的响应将具有与查询相同的形状。对于<a href="https://newapi.getpop.org/graphiql/?query=%7B%0A%20%20post(id%3A1)%20%7B%0A%20%20%20%20id%0A%20%20%20%20title%0A%20%20%7D%0A%7D" target="_blank" rel="noopener">这个 GraphQL 查询</a>:</p>
<pre class="language-graphql hljs">{
  post(id: 1) {
    id
    title
  }
}
</pre>
<p>…答案将是:</p>
<pre class="language-json hljs">{
  "data": {
    "post": {
      "id": 1,
      "title": "Hello world!"
    }
  }
}
</pre>
<p>给定具有不同参数的相同查询，返回的数据将是不同的，但是形状将是恒定的。这意味着只要查询没有改变，应用程序就不需要改变它用来读取和处理数据的逻辑。</p>
<p>然后，GraphQL 查询可以承担源插件的角色，充当应用程序和 GraphQL 服务器之间的中介。只要查询没有改变，哪个 GraphQL 服务器执行查询就无关紧要，我们可以无缝地将一个 GraphQL 服务器与另一个交换。</p>
<h2>查询依赖于 GraphQL 模式</h2>
<p>现在，最后一段有点太乐观了，因为 GraphQL 查询可能需要根据 GraphQL 服务器而改变。更准确地说，查询是基于 GraphQL 模式的，如果<a href="https://blog.logrocket.com/anti-patterns-graphql-schema-design/" target="_blank" rel="noopener">不同的服务器公开不同的模式</a>，那么查询也会不同。</p>
<p>考虑 WordPress 的两个 GraphQL 服务器是如何公开 CMS 的数据模型的。此图显示了由<a href="https://www.wpgraphql.com/" target="_blank" rel="noopener"> WPGraphQL </a>创建的 GraphQL 模式:</p>
<figure id="attachment_66291" aria-describedby="caption-attachment-66291" class="wp-caption aligncenter"><img data-attachment-id="66291" data-permalink="https://blog.logrocket.com/swapping-graphql-servers-with-least-effort/attachment/schema-exposed-wpgraphql/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2021/09/schema-exposed-wpgraphql.png" data-orig-size="730,408" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="schema-exposed-wpgraphql" data-image-description="" data-image-caption="&lt;p&gt;The schema exposed by WPGraphQL &lt;/p&gt;&#10;" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2021/09/schema-exposed-wpgraphql-300x168.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2021/09/schema-exposed-wpgraphql.png" decoding="async" class="size-full wp-image-66291 jetpack-lazy-image" src="../Images/2b15bd0f9ffbf7da7e010cfcb725798a.png" alt="The schema exposed by WPGraphQL " data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2021/09/schema-exposed-wpgraphql.png 730w, https://blog.logrocket.com/wp-content/uploads/2021/09/schema-exposed-wpgraphql-300x168.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2021/09/schema-exposed-wpgraphql.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2021/09/schema-exposed-wpgraphql.png"/><noscript><img data-lazy-fallback="1" data-attachment-id="66291" data-permalink="https://blog.logrocket.com/swapping-graphql-servers-with-least-effort/attachment/schema-exposed-wpgraphql/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2021/09/schema-exposed-wpgraphql.png" data-orig-size="730,408" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="schema-exposed-wpgraphql" data-image-description="" data-image-caption="&lt;p&gt;The schema exposed by WPGraphQL &lt;/p&gt;&#10;" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2021/09/schema-exposed-wpgraphql-300x168.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2021/09/schema-exposed-wpgraphql.png" decoding="async" loading="lazy" class="size-full wp-image-66291" src="../Images/2b15bd0f9ffbf7da7e010cfcb725798a.png" alt="The schema exposed by WPGraphQL " srcset="https://blog.logrocket.com/wp-content/uploads/2021/09/schema-exposed-wpgraphql.png 730w, https://blog.logrocket.com/wp-content/uploads/2021/09/schema-exposed-wpgraphql-300x168.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2021/09/schema-exposed-wpgraphql.png"/></noscript><figcaption id="caption-attachment-66291" class="wp-caption-text">The schema exposed by WPGraphQL</figcaption></figure>
<p>另一张图片显示了由 WordPress 的<a href="https://graphql-api.com" target="_blank" rel="noopener"> GraphQL API 提供的 GraphQL 模式:</a></p>
<figure id="attachment_66293" aria-describedby="caption-attachment-66293" class="wp-caption aligncenter"><img data-attachment-id="66293" data-permalink="https://blog.logrocket.com/swapping-graphql-servers-with-least-effort/attachment/schema-exposed-graphql-api-wordpress/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2021/09/schema-exposed-graphql-api-wordpress.png" data-orig-size="730,408" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="schema-exposed-graphql-api-wordpress" data-image-description="" data-image-caption="&lt;p&gt;The schema exposed by the GraphQL API for WordPress&lt;/p&gt;&#10;" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2021/09/schema-exposed-graphql-api-wordpress-300x168.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2021/09/schema-exposed-graphql-api-wordpress.png" decoding="async" class="size-full wp-image-66293 jetpack-lazy-image" src="../Images/33f2933e486393eb24f7b60a6f4bb6d8.png" alt="The schema exposed by the GraphQL API for WordPress" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2021/09/schema-exposed-graphql-api-wordpress.png 730w, https://blog.logrocket.com/wp-content/uploads/2021/09/schema-exposed-graphql-api-wordpress-300x168.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2021/09/schema-exposed-graphql-api-wordpress.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2021/09/schema-exposed-graphql-api-wordpress.png"/><noscript><img data-lazy-fallback="1" data-attachment-id="66293" data-permalink="https://blog.logrocket.com/swapping-graphql-servers-with-least-effort/attachment/schema-exposed-graphql-api-wordpress/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2021/09/schema-exposed-graphql-api-wordpress.png" data-orig-size="730,408" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="schema-exposed-graphql-api-wordpress" data-image-description="" data-image-caption="&lt;p&gt;The schema exposed by the GraphQL API for WordPress&lt;/p&gt;&#10;" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2021/09/schema-exposed-graphql-api-wordpress-300x168.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2021/09/schema-exposed-graphql-api-wordpress.png" decoding="async" loading="lazy" class="size-full wp-image-66293" src="../Images/33f2933e486393eb24f7b60a6f4bb6d8.png" alt="The schema exposed by the GraphQL API for WordPress" srcset="https://blog.logrocket.com/wp-content/uploads/2021/09/schema-exposed-graphql-api-wordpress.png 730w, https://blog.logrocket.com/wp-content/uploads/2021/09/schema-exposed-graphql-api-wordpress-300x168.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2021/09/schema-exposed-graphql-api-wordpress.png"/></noscript><figcaption id="caption-attachment-66293" class="wp-caption-text">The schema exposed by the GraphQL API for WordPress</figcaption></figure>
<p>在这两个模式中，相同的字段具有不同的名称，并且公开了不同的类型，部分原因是 WPGraphQL 使用了<a href="https://relay.dev/graphql/connections.htm" target="_blank" rel="noopener"> GraphQL 游标连接规范</a>，但是 WP 的 GraphQL API 不使用。因此，在 WPGraphQL 中有效的查询很可能在 WP 的 GraphQL API 中无效，反之亦然。</p>
<p>例如，基于 WPGraphQL 的<a href="https://github.com/colbyfayock/next-wordpress-starter" target="_blank" rel="noopener"> Next.js WordPress starter </a>包含<a href="https://github.com/colbyfayock/next-wordpress-starter/blob/fa87808/src/data/categories.js#L3-L17" target="_blank" rel="noopener">这个查询</a>:</p>
<pre class="language-graphql hljs">{
  categories(first: 10000) {
    edges {
      node {
        categoryId
        description
        id
        name
        slug
      }
    }
  }
}
</pre>
<p>适用于 WP 的 GraphQL API 的等价查询如下:</p>
<pre class="language-graphql hljs">{
  postCategories(limit: 10000) {
    id
    description
    globalID
    name
    slug
  }
}
</pre>
<p>我们可以理解这两个查询之间的差异:</p>
<p><img data-attachment-id="66296" data-permalink="https://blog.logrocket.com/swapping-graphql-servers-with-least-effort/attachment/differences-between-queries/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2021/09/differences-between-queries.png" data-orig-size="730,186" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="differences-between-queries" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2021/09/differences-between-queries-300x76.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2021/09/differences-between-queries.png" decoding="async" class="aligncenter size-full wp-image-66296 jetpack-lazy-image" src="../Images/6d5783f497b2758f47174870cbf38b2b.png" alt="A graph displaying the differences between the two queries." data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2021/09/differences-between-queries.png 730w, https://blog.logrocket.com/wp-content/uploads/2021/09/differences-between-queries-300x76.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2021/09/differences-between-queries.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2021/09/differences-between-queries.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="66296" data-permalink="https://blog.logrocket.com/swapping-graphql-servers-with-least-effort/attachment/differences-between-queries/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2021/09/differences-between-queries.png" data-orig-size="730,186" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="differences-between-queries" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2021/09/differences-between-queries-300x76.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2021/09/differences-between-queries.png" decoding="async" loading="lazy" class="aligncenter size-full wp-image-66296" src="../Images/6d5783f497b2758f47174870cbf38b2b.png" alt="A graph displaying the differences between the two queries." srcset="https://blog.logrocket.com/wp-content/uploads/2021/09/differences-between-queries.png 730w, https://blog.logrocket.com/wp-content/uploads/2021/09/differences-between-queries-300x76.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2021/09/differences-between-queries.png"/></noscript>
<p>将 Next.js WordPress starter 中的 WPGraphQL 查询替换为 WP 的 GraphQL API 中的对等查询，这本身是行不通的。这是因为逻辑仍然会根据原始查询的形状和字段从响应中访问数据。运行启动器不出所料地失败了:</p>
<figure id="attachment_66299" aria-describedby="caption-attachment-66299" class="wp-caption aligncenter"><img data-attachment-id="66299" data-permalink="https://blog.logrocket.com/swapping-graphql-servers-with-least-effort/attachment/error-produced-when-running-starter/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2021/09/error-produced-when-running-starter.png" data-orig-size="730,600" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="error-produced-when-running-starter" data-image-description="" data-image-caption="&lt;p&gt;An error is produced when running the starter&lt;/p&gt;&#10;" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2021/09/error-produced-when-running-starter-300x247.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2021/09/error-produced-when-running-starter.png" decoding="async" class="size-full wp-image-66299 jetpack-lazy-image" src="../Images/37d60de8cedb61aef158de744bf2fc28.png" alt="An error is produced when running the starter" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2021/09/error-produced-when-running-starter.png 730w, https://blog.logrocket.com/wp-content/uploads/2021/09/error-produced-when-running-starter-300x247.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2021/09/error-produced-when-running-starter.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2021/09/error-produced-when-running-starter.png"/><noscript><img data-lazy-fallback="1" data-attachment-id="66299" data-permalink="https://blog.logrocket.com/swapping-graphql-servers-with-least-effort/attachment/error-produced-when-running-starter/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2021/09/error-produced-when-running-starter.png" data-orig-size="730,600" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="error-produced-when-running-starter" data-image-description="" data-image-caption="&lt;p&gt;An error is produced when running the starter&lt;/p&gt;&#10;" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2021/09/error-produced-when-running-starter-300x247.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2021/09/error-produced-when-running-starter.png" decoding="async" loading="lazy" class="size-full wp-image-66299" src="../Images/37d60de8cedb61aef158de744bf2fc28.png" alt="An error is produced when running the starter" srcset="https://blog.logrocket.com/wp-content/uploads/2021/09/error-produced-when-running-starter.png 730w, https://blog.logrocket.com/wp-content/uploads/2021/09/error-produced-when-running-starter-300x247.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2021/09/error-produced-when-running-starter.png"/></noscript><figcaption id="caption-attachment-66299" class="wp-caption-text">An error is produced when running the starter</figcaption></figure>
<p>一个可能的解决方案是替换用于检索数据的逻辑。例如，<a href="https://github.com/colbyfayock/next-wordpress-starter/blob/274f0917360898c2a1cb67538c3bfb528523afea/src/lib/categories.js#L24" target="_blank" rel="noopener">下面的逻辑</a>:</p>
<pre>const categories = data?.data.categories.edges.map(({ node = {} }) =&gt; node);
</pre>
<p>…可以这样替换:</p>
<pre>const categories = data?.data.postCategories;
</pre>
<p>但这正是我们想要避免的。我们希望将更改保持在最低限度，只修改 GraphQL 查询“接口”，并保持业务逻辑不变。</p>
<p>幸运的是，通过按照以下步骤修改 GraphQL 查询，可以弥合这些差异:</p>
<ol>
<li><a href="#keeping-graphql-queries-detached-application">保持 GraphQL 查询与应用程序分离</a></li>
<li><a href="#adapting-field-names-via-aliases">通过别名修改字段名</a></li>
<li><a href="#adapting-shape-response-via-self-field">通过<code>self</code>字段</a>调整响应的形状</li>
</ol>
<p>让我们看看如何通过这三个步骤让 Next.js WordPress starter 与 WP 的 GraphQL API 一起工作。</p>
<h2 id="keeping-graphql-queries-detached-application">1.保持 GraphQL 查询与应用程序分离</h2>
<p>从应用程序逻辑中分离 GraphQL 查询包括:</p>
<ul>
<li>将每个 GraphQL 查询(或一组查询)存储在单独的文件中，并将它们全部存储在特定的文件夹中</li>
<li>导出查询并将它们导入应用程序</li>
</ul>
<p>Next.js WordPress starter 已经有了这样的布局。所有的查询都放在<code>src/data</code>下的单独文件中(有一些例外)，并且<a href="https://github.com/colbyfayock/next-wordpress-starter/blob/23599b4fba3d54c6d8df06c0609d05df57eef1b9/src/data/categories.js#L3-L17" target="_blank" rel="noopener">它们被导出</a>:</p>
<pre class="language-graphql hljs">export const QUERY_ALL_CATEGORIES = gql`
  {
    categories(first: 10000) {
      edges {
        node {
          databaseId
          description
          id
          name
          slug
        }
      }
    }
  }
`;
</pre>
<p>然后，应用程序可以<a href="https://github.com/colbyfayock/next-wordpress-starter/blob/274f0917360898c2a1cb67538c3bfb528523afea/src/lib/categories.js" target="_blank" rel="noopener">导入并使用 GraphQL 查询</a>:</p>
<pre>import { QUERY_ALL_CATEGORIES } from 'data/categories';

export async function getAllCategories() {
  const apolloClient = getApolloClient();

  const data = await apolloClient.query({
    query: QUERY_ALL_CATEGORIES,
  });

  const categories = data?.data.categories.edges.map(({ node = {} }) =&gt; node);

  return {
    categories,
  };
}
</pre>
<p>由于这种设置，所有的修改只能在<code>src/data</code>下的文件上进行。</p>
<h2 id="adapting-field-names-via-aliases">2.通过别名修改字段名</h2>
<p>一个<a href="https://graphql.org/learn/queries/#aliases" target="_blank" rel="noopener">字段别名</a>可以用来在对 WPGraphQL 模式的响应中重命名一个字段。</p>
<p>这样，字段<code>postCategories</code>、<code>id</code>和<code>globalID</code>可以使用应用程序期望的名称分别检索到:<code>categories</code>、<code>categoryId</code>和<code>id</code>:</p>
<pre class="language-graphql hljs">{
  categories: postCategories(limit: 10000) {
    categoryId: id
    description
    id: globalID
    name
    slug
  }
}
</pre>
<p>请注意 WPGraphQL 中的字段<code>categories</code>有参数<code>first</code>，而它对应的字段<code>postCategories</code>使用参数<code>limit</code>。但是，因为字段参数没有反映在响应中的字段名称中，所以我们不需要担心它们。</p>
<h2 id="adapting-shape-response-via-self-field">3.通过<code>self</code>字段调整响应的形状</h2>
<p>最后一个挑战有点棘手:我们需要修改响应的形状，为来自<a href="https://relay.dev/graphql/connections.htm" target="_blank" rel="noopener">光标连接规范</a>的<code>edges</code>和<code>node</code>添加额外的级别。</p>
<p>为了实现这一点，我们将为 GraphQL 模式中的所有类型引入一个<code>self</code>字段，该字段将回显它所应用的对象:</p>
<pre class="language-graphql hljs">type QueryRoot {
  self: QueryRoot!
}

type Post {
  self: Post!
}

type User {
  self: User!
}
</pre>
<p><code>self</code>字段允许您在不离开被查询对象的情况下向查询追加额外的级别。运行<a href="https://newapi.getpop.org/graphiql/?query=%7B%0A%20%20__typename%0A%20%20self%20%7B%0A%20%20%20%20__typename%0A%20%20%7D%0A%20%20%0A%20%20post(id%3A%201)%20%7B%0A%20%20%20%20self%20%7B%0A%20%20%20%20%20%20id%0A%20%20%20%20%20%20__typename%0A%20%20%20%20%7D%0A%20%20%7D%0A%20%20%0A%20%20user(id%3A%201)%20%7B%0A%20%20%20%20self%20%7B%0A%20%20%20%20%20%20id%0A%20%20%20%20%20%20__typename%0A%20%20%20%20%7D%0A%20%20%7D%0A%7D" target="_blank" rel="noopener">本查询</a>:</p>
<pre class="language-graphql hljs">{
  __typename
  self {
    __typename
  }

  post(id: 1) {
    self {
      id
      __typename
    }
  }

  user(id: 1) {
    self {
      id
      __typename
    }
  }
}
</pre>
<p>…产生这样的反应:</p>
<pre class="language-json hljs">{
  "data": {
    "__typename": "QueryRoot",
    "self": {
      "__typename": "QueryRoot"
    },
    "post": {
      "self": {
        "id": 1,
        "__typename": "Post"
      }
    },
    "user": {
      "self": {
        "id": 1,
        "__typename": "User"
      }
    }
  }
}
</pre>
<p>现在，我们可以使用<code>self</code>来人为添加<code>node</code>和<code>edges</code>级别:</p>
<pre class="language-graphql hljs">{
  categories: self {
    edges: postCategories(limit: 10000) {
      node: self {
        categoryId: id
        description
        id: globalID
        name
        slug
      }
    }
  }
}
</pre>
<p><code>edges</code>和<code>self</code>的 GraphQL 模式中的对象类型明显不同。但这对应用程序来说无关紧要，因为它不与 GraphQL 服务器中建模的实际对象进行交互。</p>
<p>相反，它以 JSON 对象的形式接收数据，来自<code>PostConnection</code>或<code>Post</code>对象的字段数据将是相同的。</p>
<p>请注意，<code>categories</code>字段是通过<code>self</code>解析的，而<code>edges</code>是通过<code>postCategories</code>解析的——而不是相反。这是为了确保返回元素的基数与 WPGraphQL 模式定义的匹配:</p>
<pre class="language-graphql hljs">type RootQuery {
  categories: RootQueryToCategoryConnection
}

type RootQueryToCategoryConnection {
  edges: [RootQueryToCategoryConnectionEdge]
}

type RootQueryToCategoryConnectionEdge {
  node: Category
}
</pre>
<p>如果修改后的 GraphQL 查询是反过来的(即查询<code>categories: postCategories</code>和<code>edges: self</code>，那么访问数据将会失败，因为<code>data.categories</code>将会是一个数组，所以<code>data.categories.edges</code>在执行时将会抛出一个错误:</p>
<pre>const categories = data?.data.categories.edges.map(({ node = {} }) =&gt; node);
</pre>
<h2>修改后的查询</h2>
<p>这是最后一个适合 WP 的 GraphQL API 的查询:</p>
<pre class="language-graphql hljs">{
  categories: self {
    edges: postCategories(limit: 10000) {
      node: self {
        databaseId: id
        description
        id
        name
        slug
      }
    }
  }
}
</pre>
<p>在对<code>src/data</code> 中的所有<a href="https://github.com/leoloso/next-wordpress-starter/tree/Add-plugin-GraphQL-API-for-WP-as-the-GraphQL-source/src/data" target="_blank" rel="noopener">graph QL 查询应用了相同的策略之后，针对 WP 端点的 GraphQL API 运行 starter 可以很好地工作:</a></p>
<figure id="attachment_66301" aria-describedby="caption-attachment-66301" class="wp-caption aligncenter"><img data-attachment-id="66301" data-permalink="https://blog.logrocket.com/swapping-graphql-servers-with-least-effort/attachment/successfully-running-starter-different-graphql-server/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2021/09/successfully-running-starter-different-graphql-server.png" data-orig-size="730,670" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="successfully-running-starter-different-graphql-server" data-image-description="" data-image-caption="&lt;p&gt;Successfully running the starter with a different GraphQL server&lt;/p&gt;&#10;" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2021/09/successfully-running-starter-different-graphql-server-300x275.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2021/09/successfully-running-starter-different-graphql-server.png" decoding="async" class="size-full wp-image-66301 jetpack-lazy-image" src="../Images/601ec1093fa347bcca0ae453a79e76db.png" alt="Successfully running the starter with a different GraphQL server" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2021/09/successfully-running-starter-different-graphql-server.png 730w, https://blog.logrocket.com/wp-content/uploads/2021/09/successfully-running-starter-different-graphql-server-300x275.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2021/09/successfully-running-starter-different-graphql-server.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2021/09/successfully-running-starter-different-graphql-server.png"/><noscript><img data-lazy-fallback="1" data-attachment-id="66301" data-permalink="https://blog.logrocket.com/swapping-graphql-servers-with-least-effort/attachment/successfully-running-starter-different-graphql-server/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2021/09/successfully-running-starter-different-graphql-server.png" data-orig-size="730,670" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="successfully-running-starter-different-graphql-server" data-image-description="" data-image-caption="&lt;p&gt;Successfully running the starter with a different GraphQL server&lt;/p&gt;&#10;" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2021/09/successfully-running-starter-different-graphql-server-300x275.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2021/09/successfully-running-starter-different-graphql-server.png" decoding="async" loading="lazy" class="size-full wp-image-66301" src="../Images/601ec1093fa347bcca0ae453a79e76db.png" alt="Successfully running the starter with a different GraphQL server" srcset="https://blog.logrocket.com/wp-content/uploads/2021/09/successfully-running-starter-different-graphql-server.png 730w, https://blog.logrocket.com/wp-content/uploads/2021/09/successfully-running-starter-different-graphql-server-300x275.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2021/09/successfully-running-starter-different-graphql-server.png"/></noscript><figcaption id="caption-attachment-66301" class="wp-caption-text">Successfully running the starter with a different GraphQL server</figcaption></figure>
<h2>结论</h2>
<p>在本文中，我们探索了依赖于特定 GraphQL 服务器的应用程序如何以最少的工作量适应不同的 GraphQL 服务器。</p>
<p>解决方案包括让 GraphQL 查询成为应用程序和服务器之间的中介，并且只对查询执行所有需要的更改，以避免修改业务逻辑。</p><div class="code-block code-block-24">
<div class="blog-plug inline-plug graphql-plug"><h2>监控生产中失败和缓慢的 GraphQL 请求</h2><p>虽然 GraphQL 有一些调试请求和响应的特性，但确保 GraphQL 可靠地为您的生产应用程序提供资源是一件比较困难的事情。如果您对确保对后端或第三方服务的网络请求成功感兴趣，</p><a href="https://lp.logrocket.com/blg/graphql-signup" target="_blank">try LogRocket</a><p>.</p><a class="signup" href="https://lp.logrocket.com/blg/graphql-signup" target="_blank" rel="noopener noreferrer"><img src="../Images/432a3823c85b3fb72a206e6236a29f48.png" data-lazy-src="https://files.readme.io/69aa835-Image_2019-11-09_at_1.28.05_PM.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" class=" jetpack-lazy-image" data-original-src="https://files.readme.io/69aa835-Image_2019-11-09_at_1.28.05_PM.png"/><noscript><img data-lazy-fallback="1" src="../Images/432a3823c85b3fb72a206e6236a29f48.png" data-original-src="https://files.readme.io/69aa835-Image_2019-11-09_at_1.28.05_PM.png"/></noscript><img class="alignnone size-full wp-image-46 jetpack-lazy-image" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/><noscript><img data-lazy-fallback="1" class="alignnone size-full wp-image-46" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/></noscript></a><a href="https://lp.logrocket.com/blg/graphql-signup" target="_blank" rel="noopener noreferrer">https://logrocket.com/signup/</a><p>LogRocket 就像是网络和移动应用的 DVR，记录下你网站上发生的每一件事。您可以汇总并报告有问题的 GraphQL 请求，以快速了解根本原因，而不是猜测问题发生的原因。此外，您可以跟踪 Apollo 客户机状态并检查 GraphQL 查询的键值对。</p><p>LogRocket 检测您的应用程序以记录基线性能计时，如页面加载时间、到达第一个字节的时间、慢速网络请求，还记录 Redux、NgRx 和 Vuex 操作/状态。</p><a class="signup" href="https://lp.logrocket.com/blg/graphql-signup" target="_blank" rel="noopener noreferrer">Start monitoring for free</a><p>.</p></div>


</div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
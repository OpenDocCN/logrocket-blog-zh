<html>
<head>
<title>Getting started with the View Transitions API </title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>视图转换API入门</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/getting-started-view-transitions-api/#0001-01-01">https://blog.logrocket.com/getting-started-view-transitions-api/#0001-01-01</a></blockquote><div><article class="article-post">
<p>网络对我们呈现和显示内容的渠道、交互性的水平以及我们可以集成到应用程序中的独特体验没有任何限制。</p>
<p>作为开发人员，我们可以通过利用许多可用的工具和技术来定义用户如何体验web，确保用户体验到web的独特性和美感。</p>
<p>给网络增添趣味的一种常见方式是给应用程序添加<a href="https://blog.logrocket.com/guide-to-css-animation-for-javascript-developers/">动画和过渡</a>，比如当用户悬停在按钮上时背景颜色会发生变化，或者当用户向下滚动页面时博客卡会左右滑动。这些简单的过渡可以区分平淡的体验和充满活力的体验。</p>
<p>除了使用第三方工具，如<a href="https://animate.style/"> Animate.css </a>、<a href="https://animista.net/"> Animsta </a>、<a href="https://greensock.com/gsap/"> GSAP </a>或<a href="https://blog.logrocket.com/tag/css/">普通的旧CSS </a>，我们还可以利用名为<a href="https://github.com/WICG/view-transitions">视图过渡API </a>的浏览器API来创建令人惊叹和引人注目的动画和过渡。在本文中，我们将学习API是如何工作的，并探索一个演示。</p>
<p><em>向前跳转:</em></p>

<h2 id="view-transitions-api">什么是视图转换API？</h2>
<p><a href="https://drafts.csswg.org/css-view-transitions/">视图转换API </a>，正式名称为共享元素转换API，是一个在<a href="https://blog.logrocket.com/single-page-applications-css-transitions/">单页动画</a> (SPA)中轻松创建转换和动画的API。它仅限于spa，因为这是它目前支持的唯一应用程序。</p>
<p>API让我们控制如何定义动画和过渡。我们可以使用浏览器支持的默认动画属性或者<a href="https://blog.logrocket.com/css-before-after-custom-animations-transitions/">创建自定义效果</a>。</p>
<p>此外，API会自动为我们转换元素的大小和位置。它跟踪并计算这些属性在状态之前和之后的变化，并向它们添加适当的转换。</p>
<p>在撰写本文时，视图转换API仅在Chrome v104+和Canary中可用。要激活它，首先导航至<code>chrome://flags/</code>。然后，启用<code>Experimental Web Platform features</code>和<code>viewTransition API for navigations</code>。</p>
<h2 id="view-transitions-api-works">视图转换API如何工作</h2>
<p>视图转换API的神奇工作方式发生在幕后。浏览器获取页面当前状态的屏幕截图，并在页面转换到另一个状态时处理转换。状态改变可以是元素从一个位置移动到另一个位置或者页面导航等等。</p>
<p>浏览器更新DOM，并应用必要的逻辑在状态之间进行动画处理。然后，浏览器应用交叉淡入淡出作为先前和当前状态之间的默认过渡。</p>
<p>当API处于活动状态时，它会构建一个<a href="https://blog.logrocket.com/css-pseudo-elements-guide/">伪元素</a>树，如下所示:</p>
<pre class="language-css hljs">::view-transition
└─ ::view-transition-group(root)
   └─ ::view-transition-image-pair(root)
      ├─ ::view-transition-old(root)
      └─ ::view-transition-new(root)
</pre>
<p>让我们分解代码片段中的伪元素:</p>
<ul>
<li><code>::view-transition</code>:其他伪元素的容器元素</li>
<li><code>::view-transition-group</code>:负责动画显示两个状态之间的大小和位置</li>
<li><code>::view-transition-image-pair</code>:保存新旧状态的截图</li>
<li><code>::view-transition-old(root)</code>:保存之前状态的截图</li>
<li><code>::view-transition-new(root)</code>:保存新状态的表示</li>
</ul>
<p>先前的状态从<code>opacity: 1</code>到<code>opacity: 0</code>是动画，而新的状态从<code>opacity: 0</code>到<code>opacity: 1</code>，创建交叉淡入淡出。动画是用<a href="https://www.youtube.com/watch?v=93kLe0wJbJY"> CSS动画</a>完成的，这意味着我们可以用CSS定制它们:</p>
<pre class="language-css hljs">::view-transition-old(root),
::view-transition-new(root) {
  animation-duration: 5s;
}

We can also set up even more complex animation customizations if needed:
//language: CSS

@keyframes slide-from-right {
  from { transform: translateX(30px); }
}

@keyframes slide-to-left {
  to { transform: translateX(-30px); }
}

::view-transition-old(root) {
  animation: 300ms cubic-bezier(0.4, 0, 0.2, 1) both slide-to-left;
}

::view-transition-new(root) {
  animation: 300ms cubic-bezier(0.4, 0, 0.2, 1) both slide-from-right;
}
</pre>
<p>我们可以使用默认的交叉淡入淡出过渡，或者根据我们的喜好设置更复杂的过渡。</p>
<p>这个API的一个优点是，浏览器完成了跟踪和计算状态间变化的所有繁重工作，并以高性能的方式处理转换。</p>
<h2 id="view-transitions-api-demo">查看转换API演示</h2>
<p>让我们创建一个简单的演示应用程序来看看视图转换API在实践中是如何工作的。我们将用基本的<a href="https://blog.logrocket.com/tag/html/"> HTML </a>、<a href="https://blog.logrocket.com/tag/css/"> CSS </a>和<a href="https://blog.logrocket.com/tag/vanilla-javascript/"> JavaScript </a>创建这个演示。</p>
<p>它是一个由任务的两个动作组成的待办app:<code>Not Done</code>和<code>Done</code>。未完成的任务带有一个可点击的<strong>按钮</strong>来标记它们已经完成。</p>
<p>下面的GIF显示了该应用程序的用户界面和功能。注意当任务从一个部分转移到另一个部分时，<a href="https://blog.logrocket.com/css-reference-guide-transitions/">转换效果</a>是如何发生的:</p>
<p><img data-attachment-id="154942" data-permalink="https://blog.logrocket.com/getting-started-view-transitions-api/attachment/view-transitions-api-demo/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2023/01/view-transitions-api-demo.gif" data-orig-size="730,411" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Demo of a to-do app using the View Transitions API" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2023/01/view-transitions-api-demo-300x169.gif" data-large-file="https://blog.logrocket.com/wp-content/uploads/2023/01/view-transitions-api-demo.gif" decoding="async" class="aligncenter size-full wp-image-154942 jetpack-lazy-image" src="../Images/c606374ea1dbfb4c0577b868fb9b2088.png" alt="Demo of a To-Do App Using the View Transitions API " data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2023/01/view-transitions-api-demo.gif?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2023/01/view-transitions-api-demo.gif"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="154942" data-permalink="https://blog.logrocket.com/getting-started-view-transitions-api/attachment/view-transitions-api-demo/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2023/01/view-transitions-api-demo.gif" data-orig-size="730,411" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Demo of a to-do app using the View Transitions API" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2023/01/view-transitions-api-demo-300x169.gif" data-large-file="https://blog.logrocket.com/wp-content/uploads/2023/01/view-transitions-api-demo.gif" decoding="async" loading="lazy" class="aligncenter size-full wp-image-154942" src="../Images/c606374ea1dbfb4c0577b868fb9b2088.png" alt="Demo of a To-Do App Using the View Transitions API " data-original-src="https://blog.logrocket.com/wp-content/uploads/2023/01/view-transitions-api-demo.gif"/></noscript>
<p>这是HTML的一个快照:</p>
<pre class="language-html hljs">&lt;div class="grid"&gt;
  &lt;article class="col"&gt;
    &lt;h2&gt;Not Done&lt;/h2&gt;
    &lt;ul id="list-not-done"&gt;
      &lt;li&gt;
        &lt;div class="title"&gt;Learn programming&lt;/div&gt;
        &lt;button onclick="isTaskComplete(true)"&gt;✅&lt;/button&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;div class="title"&gt;Read a LogRocket article&lt;/div&gt;
        &lt;button onclick="isTaskComplete(true)"&gt;✅&lt;/button&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;div class="title"&gt;Watch One Piece&lt;/div&gt;
        &lt;button onclick="isTaskComplete(true)"&gt;✅&lt;/button&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/article&gt;
  &lt;article class="col"&gt;
    &lt;h2&gt;Done&lt;/h2&gt;
    &lt;ul id="list-done"&gt;
      &lt;li&gt;Wash clothes&lt;/li&gt;
      &lt;li&gt;Set an alarm&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/article&gt;
&lt;/div&gt;
</pre>
<p>在上面的代码中，我们将一个<code>isTaskComplete</code>函数传递给按钮的<code>click</code>事件。我们将进一步了解<code>isTaskComplete</code>接下来会做什么。</p>
<h3 id="setting-javascript-aspect">设置JavaScript方面</h3>
<p>现在，让我们设置演示的JavaScript方面，并探索一下<code>isTaskComplete</code>函数的作用:</p>
<pre class="language-javascript hljs">async function isTaskComplete(taskComplete) {
  const task = this.window.event.target.closest("li");


  // Get the id of the target list
  const destination = document.getElementById(
    `list-${taskComplete ? "done" : "not-done"}`
  );


  // We'll use this class to hide the button when a task is done
  task.classList.add("task-done");


  if (document.createDocumentTransition) {
    const taskTransition = document.createDocumentTransition();
    // Activate the animation
    await taskTransition.start(() =&gt; destination.appendChild(task));
  } else {
    destination.appendChild(task);
  }
}
</pre>
<p>我们来分解一下上面的代码。首先，<code>isTaskComplete</code>函数接受一个布尔值作为参数。从那里，我们初始化了一个包含离事件发生地最近的<code>li</code>的<code>task</code>变量。</p>
<p><code>destination</code>变量的值根据<code>taskComplete</code>的状态而变化。当<code>taskComplete</code>为<code>true</code>时，目的地为<code>list-done</code>。但是，当<code>taskComplete</code>为<code>false</code>时，目的地为<code>list-not-done</code>。</p>
<p>我们还在<code>task</code>中添加了一个<code>task-done</code>类，用于在任务被标记为完成时隐藏按钮。此外，我们检查了浏览器是否支持带有<code>if</code>语句的视图转换API。如果没有，我们使用<code>createDocumentTransition</code>方法创建一个<code>taskTransition</code>实例，使用<code>start</code>方法触发转换。</p>
<p>如果浏览器不支持视图转换API，我们直接添加任务，而不添加任何从一个位置到另一个位置的状态变化转换。</p>
<p>这里是我们添加的<code>task-done</code>类。它负责隐藏任务的<code>button</code>:</p>
<pre class="language-javascript hljs">.task-done button {
  visibility: hidden;
}
</pre>
<p>这个实现揭示了视图转换API是如何工作的。</p>
<h2>结论</h2>
<p>视图转换API开辟了一个新的可能性边界，这就是我们可以带给web的独特而愉悦的体验。尽管它很棒，但重要的是要记住，在撰写本文时，它仍处于测试阶段。因此，API随时都会发生变化。然而，这不会阻止我们去试验和了解它！</p>
<p>这里有一些很棒的例子、演示和视图转换API的实现，你应该看看:<a href="https://twitter.com/geoffrich_"> Geoff Rich </a>用<a href="https://blog.logrocket.com/exploring-sveltekit-the-newest-svelte-based-framework/"> SvelteKit </a>构建了这个<a href="https://sveltekit-shared-element-transitions-codelab.vercel.app/fruits">水果数据应用</a>并写了一篇关于它的文章，<a href="https://twitter.com/charca"> Maxi Ferreira </a>用<a href="https://blog.logrocket.com/astro-build-faster-apps-less-javascript/"> Astro </a>和<a href="https://www.maxiferreira.com/blog/astro-page-transitions/">制作了一个</a><a href="https://astro-movies.netlify.app/">电影应用</a>解释了他是如何实现的，以及<a href="https://twitter.com/jaffathecake"> Jake Archibald </a></p><div class="code-block code-block-25">
<div class="blog-plug inline-plug css-plug"><h2>你的前端是否占用了用户的CPU？</h2><p>随着web前端变得越来越复杂，资源贪婪的特性对浏览器的要求越来越高。如果您对监控和跟踪生产环境中所有用户的客户端CPU使用、内存使用等感兴趣，</p><a target="_blank" href="https://lp.logrocket.com/blg/css-signup">try LogRocket</a><p>.</p><a class="signup" href="https://lp.logrocket.com/blg/css-signup" target="_blank" rel="noopener noreferrer"><img class="alignnone size-full wp-image-46 jetpack-lazy-image" src="../Images/dacb06c713aec161ffeaffae5bd048cd.png" alt="LogRocket Dashboard Free Trial Banner" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2019/12/cpu-memory-usage.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/12/cpu-memory-usage.png"/><noscript><img data-lazy-fallback="1" class="alignnone size-full wp-image-46" src="../Images/dacb06c713aec161ffeaffae5bd048cd.png" alt="LogRocket Dashboard Free Trial Banner" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/12/cpu-memory-usage.png"/></noscript></a><a href="https://lp.logrocket.com/blg/css-signup" target="_blank" rel="noopener noreferrer">https://logrocket.com/signup/</a><p>LogRocket 就像是网络和移动应用的DVR，记录你的网络应用或网站上发生的一切。您可以汇总和报告关键的前端性能指标，重放用户会话和应用程序状态，记录网络请求，并自动显示所有错误，而不是猜测问题发生的原因。</p><p>现代化您调试web和移动应用的方式— <a class="signup" href="https://lp.logrocket.com/blg/css-signup" target="_blank" rel="noopener noreferrer">开始免费监控</a>。</p></div>
</div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
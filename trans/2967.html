<html>
<head>
<title>Understanding TypeScript 4.7 and ECMAScript module support - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>了解 TypeScript 4.7 和 ECMAScript 模块支持- LogRocket 博客</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/typescript-4-7-ecmascript-module-support/#0001-01-01">https://blog.logrocket.com/typescript-4-7-ecmascript-module-support/#0001-01-01</a></blockquote><div><article class="article-post">
<p>作为 TypeScript 4.7 版本的一部分，对 Node.js 的 ECMAScript 模块支持进行了重大升级。</p>

<h2 id="ashorthistoryofecmascriptmodules">ECMAScript 模块简史</h2>
<p>当 ES6 在 2015 年回归时，它带来了 JavaScript 模块的概念。当时它被称为“ES6 模块”。现在它们被称为 ECMAScript 模块。</p>
<p>虽然使用 ECMAScript 模块语义编写代码对于前端来说很快，但对于后端(通常是 Node.js)来说却不是这样。这有很多原因:</p>
<ol>
<li>Node.js 中已经使用了一个已经建立的模块系统，叫做<a href="https://en.wikipedia.org/wiki/CommonJS" target="_blank" rel="noopener"> CommonJS </a></li>
<li>Node.js 本身最初并不支持 ECMAScript 模块；很大程度上是因为支持 CommonJS <em>和 ECMAScript 模块</em>的相关问题</li>
</ol>
<p>然而，随着 Node.js 14 的发布，对 ECMAScript 模块(也称为“ESM”)的支持开始了。如果你对该模块支持的细节感兴趣，那么值得阅读这篇关于 ECMAScript 模块的文章。</p>
<h2 id="typescript-support">类型脚本支持</h2>
<p>TypeScript 团队一直在尝试从 Node.js 的角度为 ECMAScript 模块提供支持的方法，随着 TypeScript 4.7 支持的发布。</p>
<p>在这篇文章中，我们将通过尝试使用新的 ECMAScript 模块支持在 TypeScript 中构建一个简单的模块来测试这种支持。当我们这样做时，我们将讨论在 TypeScript 中为 Node.js 编写 ECMAScript 模块是什么样子。</p>
<p>我们走吧！</p>
<h2 id="making-a-module">制作模块</h2>
<p>我们将制作一个名为<code>greeter</code>的模块—让我们初始化它:</p>
<pre class="language-shell hljs">mkdir greeter
cd greeter
npm init --yes
</pre>
<p>我们现在有一个看起来像这样的<code>package.json</code>:</p>
<pre class="language-json hljs">{
  "name": "greeter",
  "version": "1.0.0",
  "description": "",
  "main": "index.js",
  "scripts": {
    "test": "echo \"Error: no test specified\" &amp;&amp; exit 1"
  },
  "keywords": [],
  "author": "",
  "license": "ISC"
}
</pre>
<p>Node.js 支持<code>package.json</code>中一个名为<code>type</code>的新设置。<a href="https://nodejs.org/api/packages.html#type" target="_blank" rel="noopener">这可以设置为“模块”或“公共代码”</a>。引用文档:</p>
<blockquote><p>当最近的父 package.json 文件包含值为<code>"module"</code>的顶级字段<code>"type"</code>时，以<code>.js</code>结尾的文件作为 es 模块加载。</p></blockquote>
<p>考虑到这一点，我们将为我们的<code>package.json</code>添加一个<code>"type": "module"</code>。</p>
<p>我们现在支持 ECMAScript 模块，让我们开始添加一些类型脚本。</p>
<h2 id="adding-typescript-47">添加 TypeScript 4.7</h2>
<p>为了利用 TypeScript ECMAScript 模块支持，我们将安装 TypeScript 4.7(目前处于测试阶段):</p>
<pre>npm install <a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="d3a7aaa3b6a0b0a1baa3a793e7fde4fde3feb1b6a7b2">[email protected]</a> --save
</pre>
<p>准备就绪后，我们将初始化一个 TypeScript 项目:</p>
<pre>npx tsc --init
</pre>
<p>这将创建一个包含许多选项的<code>tsconfig.json</code>文件。我们将把<code>module</code>选项调整为<code>nodenext</code>，以选择 ECMAScript 模块支持:</p>
<pre class="language-json hljs">{
  "compilerOptions": {
    // ...
    "module": "nodenext" /* Specify what module code is generated. */,
    "outDir": "./lib" /* Specify an output folder for all emitted files. */,
    "declaration": true /* Generate .d.ts files from TypeScript and JavaScript files in your project. */

    // ...
  }
}
</pre>
<p>我们还设置了<code>outDir</code>选项，这样编译后的 JavaScript 将进入该目录，还设置了<code>declaration</code>选项，这样将生成<code>.d.ts</code>文件。我们还将更新我们的<code>package.json</code>的<code>"scripts"</code>部分，以包括<code>build</code>和<code>start</code>脚本:</p>
<pre class="language-json hljs">  "scripts": {
    "build": "tsc",
    "start": "node lib/index.js"
  },
</pre>
<h2 id="writing-typescript-ecmascript-modules">编写 TypeScript ECMAScript 模块</h2>
<p>完成所有这些设置后，我们就可以编写一些 TypeScript ECMAScript 模块了。首先我们将编写一个<code>greetings.ts</code>模块:</p>
<pre class="language-typescript hljs">export function helloWorld(): string {
  return 'hello world!';
}
</pre>
<p>这没有什么新的或令人惊讶的；它只是一个模块，导出一个名为<code>helloWorld</code>的函数。当我们编写我们的<code>index.ts</code>模块时，它变得更加有趣:</p>
<pre class="language-typescript hljs">import { helloWorld } from './greetings.js';

const greeting = helloWorld();

console.log(greeting);
</pre>
<p>上面的代码导入我们的<code>helloWorld</code>函数，然后执行它；将输出写入控制台。</p>
<p>不是特别值得注意；但是，我们导入的方式是。</p>
<p>我们从<code>'./greetings.js'</code>进口。过去我们会写道:</p>
<pre class="language-typescript hljs">import { helloWorld } from './greetings';
</pre>
<p>现在我们写:</p>
<pre class="language-typescript hljs">import { helloWorld } from './greetings.js';
</pre>
<p>这可能感觉有点奇怪和不自然，因为我们的代码库中没有<code>greetings.js</code>；只有<code>greetings.ts</code>。我们正在编写的导入反映了最终将被执行的代码；一旦我们的类型脚本被编译成 JavaScript。在 ES 模块中，相对导入路径需要使用扩展。</p>
<p>证明这是合法的最简单的方法是运行以下代码:</p>
<pre class="language-shell hljs">npm run build &amp;&amp; npm start
</pre>
<p>这导致:</p>
<pre class="language-shell hljs">&gt; <a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="d5b2a7b0b0a1b0a795e4fbe5fbe5">[email protected]</a> build
&gt; tsc


&gt; <a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="7710051212031205374659475947">[email protected]</a> start
&gt; node lib/index.js

hello world!
</pre>
<p>所以，它起作用了！</p>
<h2 id="ecmascript-and-commonjs-side-by-side">ECMAScript 和 CommonJS 并排</h2>
<p>ECMAScript 模块支持的一部分是能够根据文件后缀指定文件的模块类型。如果您使用<code>.mjs</code>，您明确地说一个文件是一个 ECMAScript 模块。如果您使用<code>.cjs</code>，您就明确地说一个文件是一个 CommonJS 模块。如果你用 TypeScript 创作，你将分别使用<code>mts</code>和<code>cts</code>，它们将被传输到<code>mjs</code>和<code>cjs</code>。</p>
<p>令人高兴的是，Node.js 允许 es 模块导入 CommonJS 模块，就像它们是带有默认导出的 ES 模块一样；这对 interop 来说是个好消息。让我们通过编写一个<code>oldGreetings.cts</code>模块来测试一下:</p>
<pre class="language-typescript hljs">export function helloOldWorld(): string {
  return 'hello old world!';
}
</pre>
<p>和之前完全一样的语法。我们将调整我们的<code>index.ts</code>来消费这个:</p>
<pre class="language-typescript hljs">import { helloWorld } from './greetings.js';
import { helloOldWorld } from './oldGreetings.cjs';

console.log(helloWorld());
console.log(helloOldWorld());
</pre>
<p>注意，我们是从<code>'./oldGreetings.cjs'</code>导入的。</p>
<p>我们来看看它是否有效:</p>
<pre class="language-shell hljs">npm run build &amp;&amp; npm start
</pre>
<p>这导致:</p>
<pre class="language-shell hljs">&gt; <a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="355247505041504775041b051b05">[email protected]</a> build
&gt; tsc


&gt; <a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="3651445353425344760718061806">[email protected]</a> start
&gt; node lib/index.js

hello world!
hello old world!
</pre>
<p>确实管用！</p>
<h2 id="what-files-are-emitted">发出什么文件？</h2>
<p>在我们结束之前，看看运行我们的<code>npm run build</code>时 TypeScript 在做什么可能会很有趣。它将我们的类型脚本转换成我们的<code>lib</code>目录中的 JavaScript:</p>
<p><img data-attachment-id="111768" data-permalink="https://blog.logrocket.com/typescript-4-7-ecmascript-module-support/screenshot-output-files/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/05/screenshot-output-files.png" data-orig-size="331,314" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="screenshot-output-files" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/05/screenshot-output-files-300x285.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/05/screenshot-output-files.png" decoding="async" class="aligncenter wp-image-111768 size-full jetpack-lazy-image" src="../Images/878cf85615ad5cb384a6b0ee90fe864e.png" alt="Screenshot of output files" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2022/05/screenshot-output-files.png 331w, https://blog.logrocket.com/wp-content/uploads/2022/05/screenshot-output-files-300x285.png 300w" data-lazy-sizes="(max-width: 331px) 100vw, 331px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2022/05/screenshot-output-files.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/05/screenshot-output-files.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="111768" data-permalink="https://blog.logrocket.com/typescript-4-7-ecmascript-module-support/screenshot-output-files/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/05/screenshot-output-files.png" data-orig-size="331,314" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="screenshot-output-files" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/05/screenshot-output-files-300x285.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/05/screenshot-output-files.png" decoding="async" loading="lazy" class="aligncenter wp-image-111768 size-full" src="../Images/878cf85615ad5cb384a6b0ee90fe864e.png" alt="Screenshot of output files" srcset="https://blog.logrocket.com/wp-content/uploads/2022/05/screenshot-output-files.png 331w, https://blog.logrocket.com/wp-content/uploads/2022/05/screenshot-output-files-300x285.png 300w" sizes="(max-width: 331px) 100vw, 331px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/05/screenshot-output-files.png"/></noscript>
<p>注意<code>greetings.ts</code>文件产生了<code>greetings.js</code>和一个<code>greetings.d.ts</code>文件，而<code>oldGreetings.cts</code>产生了<code>oldGreetings.cjs</code>和一个<code>oldGreetings.d.cts</code>文件；反映所代表的不同模块类型。</p>
<p>查看发出的 JavaScript 的差异也很有趣。当你考虑源文件是多么相似的时候。如果你看看<code>greetings.js</code>:</p>
<pre class="language-javascript hljs">export function helloWorld() {
  return 'hello world!';
}
</pre>
<p>这是与<code>greetings.ts</code>相同的代码，但是去掉了类型。然而，如果我们看一下<code>oldGreetings.cjs</code>，我们会看到:</p>
<pre class="language-javascript hljs">'use strict';
Object.defineProperty(exports, '__esModule', { value: true });
exports.helloOldWorld = void 0;
function helloOldWorld() {
  return 'hello old world!';
}
exports.helloOldWorld = helloOldWorld;
</pre>
<p>中间是与<code>oldGreetings.cts</code>相同的代码，但是去掉了类型，但是围绕着 TypeScript 为我们在互操作中提供帮助而发出的样板代码。</p>
<h2 id="conclusion">结论</h2>
<p>我们已经看到了对 ECMAScript 模块的 TypeScript 支持，以及如何设置一个模块来支持它。</p>
<p>如果你想进一步了解这个主题，<a href="https://devblogs.microsoft.com/typescript/announcing-typescript-4-7-beta/#esm-nodejs" target="_blank" rel="noopener"> TypeScript 4.7 beta 发行说明</a>是一个很好的资源。</p><div class="code-block code-block-21">
<div class="blog-plug inline-plug typescript-plug"><h2><a class="signup" href="https://lp.logrocket.com/blg/typescript-signup" target="_blank" rel="noopener noreferrer"> LogRocket </a>:全面了解您的网络和移动应用</h2>
<a href="https://lp.logrocket.com/blg/typescript-signup" class="signup" target="_blank" rel="noopener noreferrer"><img class="alignnone size-full wp-image-46 jetpack-lazy-image" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/><noscript><img data-lazy-fallback="1" class="alignnone size-full wp-image-46" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/></noscript></a>
<p>LogRocket 是一个前端应用程序监控解决方案，可以让您回放问题，就像问题发生在您自己的浏览器中一样。LogRocket 不需要猜测错误发生的原因，也不需要向用户询问截图和日志转储，而是让您重放会话以快速了解哪里出错了。它可以与任何应用程序完美配合，不管是什么框架，并且有插件可以记录来自 Redux、Vuex 和@ngrx/store 的额外上下文。</p>
<p>除了记录 Redux 操作和状态，LogRocket 还记录控制台日志、JavaScript 错误、堆栈跟踪、带有头+正文的网络请求/响应、浏览器元数据和自定义日志。它还使用 DOM 来记录页面上的 HTML 和 CSS，甚至为最复杂的单页面和移动应用程序重新创建像素级完美视频。</p><div class="code-block code-block-23">
<div class="blog-plug inline-plug node-plug"><h2>200 只<img src="../Images/61167b9d027ca73ed5aaf59a9ec31267.png" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2019/10/green-check.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" class=" jetpack-lazy-image" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/10/green-check.png"/> <noscript> <img data-lazy-fallback="1" src="../Images/61167b9d027ca73ed5aaf59a9ec31267.png" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/10/green-check.png"/> </noscript>显示器出现故障，生产中网络请求缓慢</h2><p>部署基于节点的 web 应用程序或网站是容易的部分。确保您的节点实例继续为您的应用程序提供资源是事情变得更加困难的地方。如果您对确保对后端或第三方服务的请求成功感兴趣，</p><a href="https://lp.logrocket.com/blg/node-signup" target="_blank">try LogRocket</a><p>. </p><a class="signup" href="https://lp.logrocket.com/blg/node-signup" target="_blank" rel="noopener noreferrer"><img src="../Images/cae72fd2a54c5f02a6398c4867894844.png" alt="LogRocket Network Request Monitoring" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2019/12/network-request-filter-2-1.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" class=" jetpack-lazy-image" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/12/network-request-filter-2-1.png"/><noscript><img data-lazy-fallback="1" src="../Images/cae72fd2a54c5f02a6398c4867894844.png" alt="LogRocket Network Request Monitoring" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/12/network-request-filter-2-1.png"/></noscript></a><a href="https://lp.logrocket.com/blg/node-signup" target="_blank" rel="noopener noreferrer">https://logrocket.com/signup/</a><p>LogRocket 就像是网络和移动应用程序的 DVR，记录下用户与你的应用程序交互时发生的一切。您可以汇总并报告有问题的网络请求，以快速了解根本原因，而不是猜测问题发生的原因。</p><p>LogRocket 检测您的应用程序以记录基线性能计时，如页面加载时间、到达第一个字节的时间、慢速网络请求，还记录 Redux、NgRx 和 Vuex 操作/状态。</p><a class="signup" href="https://lp.logrocket.com/blg/node-signup" target="_blank" rel="noopener noreferrer">Start monitoring for free</a><p>. </p></div>
</div>
<a class="signup" href="https://lp.logrocket.com/blg/typescript-signup" target="_blank" rel="noopener noreferrer">Try it for free</a><p>.</p></div>
</div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
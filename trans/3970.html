<html>
<head>
<title>Build a project using Angular and NestJS </title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>使用Angular和NestJS构建一个项目</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/build-project-using-angular-nestjs/#0001-01-01">https://blog.logrocket.com/build-project-using-angular-nestjs/#0001-01-01</a></blockquote><div><article class="article-post">
<p>使用Angular和NestJS构建项目是创建健壮的全栈web应用程序的好方法。Angular是一个流行的前端JavaScript框架，它为构建丰富的交互式用户界面提供了一整套功能。相比之下，使用Node.js构建的后端框架NestJS提供了一套健壮的工具，用于构建高效且可伸缩的服务器端应用程序。</p>
<p>这两个框架一起为构建现代web应用程序提供了一个完整的解决方案，从前端用户界面到服务器端后端逻辑。在本教程中，我们将学习如何使用Angular和NestJS来构建一个项目，包括设置开发环境、创建组件和服务、处理路由以及进行API调用。</p>
<p>本教程将为您提供如何使用Angular和NestJS构建web应用程序的全面理解。阅读完本文后，您将能够使用这个强大的堆栈创建自己的项目。</p>
<p><em>向前跳转:</em></p>

<h2 id="prerequisites">先决条件</h2>
<p>要开始学习本教程，请确保您具备以下条件:</p>
<ul>
<li>已安装Node.js和npm</li>
</ul>
<h2 id="similarities-angular-nestjs">Angular和NestJS之间的相似性</h2>
<p>NestJS和Angular都是基于JavaScript的web应用程序框架，并且使用JavaScript作为它们的主要编程语言。这两个框架还共享以下特性:</p>
<ul>
<li>使用基于组件的架构来组织和模块化代码</li>
<li>使用TypeScript，JavaScript的类型化超集。这允许在开发过程的早期捕捉错误，并使代码更易于维护</li>
<li>为构建动态的交互式用户界面提供强大的工具</li>
</ul>
<p>但是，也有一些不同之处:</p>
<ul>
<li>NestJS构建在流行的Node.js web框架ExpressJS之上，而Angular使用MVC(模型-视图-控制器)模式来构建应用程序</li>
<li>NestJS是后端框架，Angular是前端框架</li>
</ul>
<p>NestJS和Angular在全栈web开发中很好地互补。总之，他们可以创建一个完整的web应用程序，具有健壮的后端和动态的交互式前端。</p>
<h2 id="setting-up-nestjs-project">建立NestJS项目</h2>
<p>要设置一个NestJS项目，您需要首先安装NestJS CLI工具，如下所示:</p>
<pre class="language-bash hljs"> npm i -g @nestjs/cli
</pre>
<p>接下来，使用您选择的项目名称运行下面的命令来创建一个新项目。对于本教程，我们使用<code>tasks</code>作为项目名称:</p>
<pre class="language-bash hljs">nest new tasks
</pre>
<p>该命令将提示您选择要为您的项目管理的包。例如，可以在npm和Yarn之间进行选择。对于本教程，我们将使用npm。一旦您选择了首选的包管理器，项目的依赖项将被安装。</p>
<p>现在，导航到项目目录并运行开发服务器:</p>
<pre class="language-bash hljs">cd tasks
npm run start:dev
</pre>
<p>一旦开发服务器开始运行，您应该会看到“Hello World！”通过在浏览器中导航到<a href="http://localhost:3000" rel="nofollow"> http://localhost:3000 </a>发送消息。</p>
<h2 id="setting-up-new-angular-project">设置新的角度项目</h2>
<p>现在您的NestJS项目已经设置好了，您可以为应用程序的前端创建一个新的Angular项目。</p>
<p>通过在终端中运行以下命令来安装Angular CLI:</p>
<pre class="language-bash hljs">npm install -g @angular/cli
</pre>
<p>接下来，使用您选择的项目名称运行下面的命令来创建一个新项目。在本演示中，我们使用<code>tasks-ui</code>作为项目名称:</p>
<p><code>ng</code> <code>tasks-ui</code></p>
<p>现在导航到项目目录并安装项目依赖项:</p>
<pre class="language-bash hljs">cd tasks-ui
npm install
&lt;</pre>
<p>最后，使用以下命令运行开发:</p>
<pre class="language-bash hljs">ng serve
</pre>
<p>一旦开发服务器开始运行，您应该能够通过在浏览器中导航到<a href="http://localhost:4200" rel="nofollow"> http://localhost:4200 </a>来看到默认的Angular应用程序。</p>
<h2 id="creating-task-application">创建任务应用程序</h2>
<p>既然已经设置好了后端和前端服务器，那么就该创建任务应用程序来保存和显示您的日常任务列表了。</p>
<p>首先，您将创建后端API。这将包括创建路由、控制器和服务来处理任务数据，以及CRUD操作。</p>
<h3 id="creating-service">创建服务</h3>
<p>首先在项目的根目录下创建一个<code>tasks.json</code>文件。这个文件将作为存储您的任务记录的数据库。</p>
<p>接下来，用下面的代码更新<code>src/app.service.ts</code>文件:</p>
<pre class="language-typescript hljs">import { Injectable } from '@nestjs/common';
import * as fs from 'fs';
export interface Tasks {
  id: number;
  name: string;
  completed: boolean;
}
@Injectable()
export class AppService {
  private tasks: Array&lt;Tasks&gt;;
  constructor() {
    this.tasks = JSON.parse(fs.readFileSync('tasks.json', 'utf8'));
  }
  getTasks(): Tasks[] {
    return this.tasks;
  }
  createTask(name: string): Tasks[] {
    const task = { id: this.tasks.length + 1, name, completed: false };
    this.tasks = [...this.tasks, { ...task}];
    fs.writeFileSync('tasks.json', JSON.stringify(this.tasks));
    return this.tasks;
  }
  deleteTask(id: number): Tasks[] {
    const index = this.tasks.findIndex((task) =&gt; task.id === id);
    this.tasks.splice(index, 1);
    return this.tasks;
  }
}
</pre>
<p>这段代码实现了一个允许您管理任务列表的服务。该服务利用<code>@nestjs/common</code>模块为NestJS提供装饰器和实用函数，并利用<code>fs</code>模块与文件系统进行交互。</p>
<p>定义了一个<code>Tasks</code> <code>interface</code>来构造服务将管理的每个任务对象。<code>@Injectable()</code>装饰器被用来制造<code>AppService</code>级可注射。</p>
<p>私有属性<code>tasks</code>被定义为保存一组<code>Tasks</code>对象，并通过从<code>tasks.json</code>文件中读取任务并将其解析为一组任务对象，在构造函数中进行初始化。该服务有三种方法:</p>
<ul>
<li><code>getTasks()</code>:返回当前任务列表</li>
<li><code>createTask(name: string)</code>:用给定的名称创建一个新的<code>task</code>对象，将其添加到任务列表中，然后将更新后的列表写入<code>tasks.json</code>文件</li>
<li><code>deleteTask(id: number)</code>:根据给定的<code>id</code>从列表中删除任务</li>
</ul>
<h3 id="creating-controller">创建控制器</h3>
<p>NestJS中的控制器负责处理传入的HTTP请求并返回适当的响应。它充当客户端和服务之间的中介，接收来自客户端的输入，对其进行处理，然后返回响应。</p>
<p>要为应用程序创建控制器，您需要定义处理不同请求的路线和方法。这将允许我们的应用程序处理各种类型的客户端请求，比如GET、POST、PUT和DELETE。</p>
<p>要为<code>AppService</code>创建控制器，用以下代码更新<code>src/app.controllers.ts</code>文件:</p>
<pre class="language-typescript hljs">import {
  Controller,
  Get,
  Post,
  Body,
  Delete,
  Param,
  HttpException,
  HttpStatus,
} from '@nestjs/common';
import { AppService } from './app.service';
import { Tasks } from './app.service';
@Controller('api/todos')
export class AppController {
  constructor(private readonly appService: AppService) {}
  @Get()
  getTodos(): Tasks[] {
    try {
      return this.appService.getTasks();
    } catch (error) {
      throw new HttpException(error.message, HttpStatus.INTERNAL_SERVER_ERROR);
    }
  }
  @Post()
  createTodo(@Body() { name }: Tasks): Tasks[] {
    try {
      return this.appService.createTask(name);
    } catch (error) {
      throw new HttpException(error.message, HttpStatus.INTERNAL_SERVER_ERROR);
    }
  }
  @Delete(':id')
  deleteTodo(@Param('id') id: number): Tasks[] {
    try {
      return this.appService.deleteTask(id);
    } catch (error) {
      throw new HttpException(error.message, HttpStatus.INTERNAL_SERVER_ERROR);
    }
  }
}
</pre>
<p>这段代码定义了一个控制器，用于处理NestJS应用程序中与任务相关的请求。控制器用从<code>@nestjs/common</code>导入的<code>@Controller</code>装饰器来装饰。</p>
<p>装饰器接受一个字符串参数，它定义了控制器的端点。在这种情况下，终点是<code>api/tasks</code>。代码还导入了其他装饰器，如<code>@Get</code>、<code>@Post</code>、@ <code>Body</code>、<code>@Delete</code>和<code>@Param</code> <em> <em/> </em>，它们用于处理不同类型的请求并从请求中提取数据。</p>
<p>导入<code>AppService</code> <em> <em/> </em>是因为它是一个依赖项，用于处理应用程序的逻辑。控制器有三种方法:<code>getTasks()</code>、<code>createTask()</code>和<code>deleteTask()</code>。</p>
<p>每个方法都用一个对应于它处理的HTTP请求类型的装饰器来装饰。<code>getTasks()</code>方法用<code>@Get()</code>修饰，通过调用<code>AppService</code>的<code>getTasks()</code>方法返回任务列表。</p><div class="code-block code-block-54">
<hr/>
<h3>更多来自LogRocket的精彩文章:</h3>

<hr/></div>
<p><code>createTasks()</code>方法用<code>@Post()</code>和<code>@Body()</code>修饰。它通过调用<code>AppService</code>的<code>createTask()</code>方法并传入任务名称来创建一个新任务。</p>
<p><code>deleteTask()</code>方法用<code>@Delete()</code>和<code>@Param()</code>修饰。它通过调用<code>AppService</code>的<code>deleteTask()</code>方法并传入任务<code>id</code>来删除任务。</p>
<p>这些方法还包括使用try-catch块进行错误处理，并在错误发生时抛出带有<code>HttpStatus.INTERNAL_SERVER_ERROR</code>的<code>HttpException</code>。</p>
<h2 id="creating-application-user-interface">创建应用程序用户界面</h2>
<p>现在任务API已经完成，您已经成功地完成了应用程序后端部分的构建！</p>
<p>现在是时候使用Angular创建应用程序的UI，然后使用API从用户界面管理任务了。</p>
<h3 id="creating-angular-service">创建角度服务</h3>
<p>首先，使用以下命令生成任务的服务:</p>
<pre class="language-typescript hljs">ng generate service tasks
</pre>
<p>该命令在<code>src/app</code>目录中用服务名创建一个新的服务文件，并将其注册到<code>app.module.t</code> s文件中。</p>
<p>接下来，用下面的代码片段更新<code>tasks.service.ts</code>文件，以添加使用NestJS APIs的服务:</p>
<pre class="language-typescript hljs">import { Injectable } from '@angular/core';
import { HttpClient } from '@angular/common/http';
import { map } from 'rxjs';
@Injectable({
  providedIn: 'root',
})
export class TaskService {
  host = 'http://localhost:3000/api';
  // eslint-disable-next-line @typescript-eslint/no-empty-function
  constructor(private http: HttpClient) {}
  getTasks() {
    return this.http.get(`${this.host}/tasks`).pipe(map((res) =&gt; res));
  }
  addTask(todo: string) {
    return this.http.post(`${this.host}/tasks`, {
      name: todo,
      completed: false,
    });
  }
  deleteTask(id: number) {
    return this.http.delete(`${this.host}/tasks/${id}`);
  }
}
</pre>
<p>上面的代码在Angular中定义了一个服务，用于处理与功能相关的任务。服务用从<code>@angular/core</code>导入的<code>@Injectable</code>装饰器来装饰。</p>
<p>该服务有一个<code>host</code>属性，保存后端API的基本URL。此外，还导入了<code>HttpClient</code>模块向后端发出HTTP请求。</p>
<p>该服务有三种方法:<code>getTasks()</code>、<code>addTask()</code>和<code>deleteTask()</code>。<code>getTasks()</code>方法向后端发出GET请求来检索任务。<code>addTask()</code>方法向后端发出一个POST请求来添加一个新任务。<code>deleteTask()</code>方法向后端发出删除请求，删除一个特定的任务。</p>
<p>每个方法都使用<code>HttpClient</code>模块向后端发出相应的HTTP请求并返回响应。<code>map</code>操作符从可观察的接口中提取响应。</p>
<h3 id="updating-app-component">更新应用程序组件</h3>
<p>接下来，用下面的代码更新<code>app.components.ts</code>文件，以订阅您刚刚创建的服务:</p>
<pre class="language-typescript hljs">import { Component } from '@angular/core';
import { TaskService } from './todo.service';
interface Task {
  id: number;
  name: string;
  completed: boolean;
}
@Component({
  selector: 'app-root',
  templateUrl: './app.component.html',
  styleUrls: ['./app.component.css'],
})
export class AppComponent {
  tasks: Task[];
  task: string;
  // eslint-disable-next-line @typescript-eslint/no-empty-function
  constructor(
    private taskService: TaskService,
  ) {
    this.tasks = [];
    this.task = '';
  }
  title = 'task-ui';
  ngOnInit() {
    this.taskService.getTasks().subscribe((data) =&gt; {
      console.log(data);
      this.tasks = data as Task[];
    });
  }

  addTask(task: string) {
    this.taskService.addTask(task).subscribe();
    this.task ='';
  }

  deleteTask(id: number) {
    this.taskService.deleteTask(id).subscribe((data) =&gt; {
      console.log(data);
    });
  }
}
</pre>
<p>上面的代码定义了一个<code>AppComponent</code>类。<code>AppComponent</code>用从<code>@angular/core</code>进口的<code>@Component</code>装饰器装饰。它有一个<code>selector</code>、<code>templateUrl</code>和<code>styleUrls</code>属性，分别用于指定组件的选择器、模板和样式。</p>
<p><code>TaskService</code>被导入并注入到组件的构造函数中。</p>
<p>该组件有三个属性:</p>
<ul>
<li><code>tasks</code>:对象<code>Task</code>的数组</li>
<li><code>task</code>:用于存储用户想要添加的任务</li>
<li><code>title</code>:用于存储应用程序的标题</li>
</ul>
<p>当初始化<code>TaskService</code>组件时，调用<code>ngOnInit()</code>方法。该组件有三种方法:</p>
<ul>
<li><code>getTasks()</code>:调用从后端检索任务</li>
<li><code>addTask()</code>:当用户想要添加一个新任务到后台时调用</li>
<li><code>deleteTask()</code>:当用户想要从后端删除任务时调用</li>
</ul>
<h3 id="updating-app-template">更新应用程序模板</h3>
<p>让我们利用<code>AppComponent</code>中定义的方法和变量来显示从API返回的任务，并附加事件处理程序来提交表单以添加新任务和删除现有任务。</p>
<p>用以下代码更新<code>app.component.html</code>文件:</p>
<pre class="language-html hljs">&lt;html lang="en"&gt;
  &lt;head&gt;
    &lt;meta charset="UTF-8" /&gt;
    &lt;meta http-equiv="X-UA-Compatible" content="IE=edge" /&gt;
    &lt;meta name="viewport" content="width=device-width, initial-scale=1.0" /&gt;
    &lt;link
      href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.2.1/css/all.min.css"
      rel= "stylesheet"
    /&gt;
    &lt;script src="https://cdnjs.cloudflare.com/ajax/libs/angular.js/1.8.3/angular.min.js"&gt;&lt;/script&gt;
    &lt;title&gt;Document&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;div class="main" ng-app="mytodo" ng-controller="myCtrl"&gt;
      &lt;h1&gt;Todo List App&lt;/h1&gt;
      &lt;div class="search"&gt;
        &lt;input type="text" [(ngModel)]="task" /&gt;
        &lt;span (click)="addTask(task)"&gt;&lt;i class="fas fa-plus"&gt;&lt;/i&gt;&lt;/span&gt;
      &lt;/div&gt;
      &lt;ul&gt;
        &lt;li *ngFor= "let task of tasks"&gt;
          {{ task.name
          }}&lt;i class="fas fa-trash-alt" (click)="deleteTask(task.id)"&gt;&lt;/i&gt;
        &lt;/li&gt;
      &lt;/ul&gt;
      &lt;p&gt;&lt;/p&gt;
    &lt;/div&gt;
  &lt;/body&gt;
&lt;/html&gt;
</pre>
<p>这段代码是<code>AppComponent</code>模板的一部分。它包括一个输入字段、一个按钮和一个无序列表。使用<code>ngModel</code>指令将输入字段绑定到组件的<code>task</code>属性。</p>
<p>输入字段的值双向绑定到<code>task</code>属性，因此当用户在输入字段中键入内容时，<code>task</code>属性的值会更新，当<code>task</code>属性的值更新时，输入字段也会更新。</p>
<p>按钮元素有一个图标和一个使用<code>(click)</code>事件绑定到<code>addTask()</code>组件方法的事件。当用户点击这个图标时，用任务文本调用<code>addTask()</code>方法。</p>
<p>无序列表使用<code>ngFor</code>指令遍历<code>tasks</code>数组。该指令为<code>tasks</code>数组中的每个任务创建一个新的列表项元素，并将任务数据绑定到<code>task</code>变量。每个列表项元素显示任务名称，并有一个垃圾桶图标，该图标带有一个使用<code>(click)</code>事件绑定到组件的<code>deleteTask()</code>方法的事件。当用户点击垃圾桶图标时，任务<code>id</code>调用<code>deleteTask()</code>方法。</p>
<h3 id="updating-styling">更新样式</h3>
<p>为了增强应用程序的外观，用以下样式表更新<code>src/styles.css</code>文件中的样式:</p>
<pre class="language-css hljs">body{
    justify-content: center;
    display: flex;
    font-family: 'Poppins', sans-serif;
}
.main{
    width: 500px;
    padding: 15p;
    background-color: #ededed  ;
}
h1{
    text-align: center;
    color: #e69d17;
    margin: 10px;
}
input[type=text]{
    width: 90%;
    padding: 10px;
    font-size: 16px;
    margin-left: 8px;
    border-radius: 3px;
    border: none;
    outline: none;
}
.search {
    position: relative;
}
.search span{
    position: absolute;
    top: -10px;
    right: -4px;
    background: #e69d17;
    padding: 20px;
    display: flex;
    border-radius: 50%;
    width: 15px;
    height: 15px;
    cursor: pointer;

}
.search span i{
    line-height: -100%;
}
ul {
    padding: 2px;
    list-style: none;
}
ul li {
    background-color: #fff;
    margin: 5px;
    padding: 10px;
    border-right: 4px solid #e69d17;
    border-left: 4px solid #e69d17;
}
ul li i {
    padding: 4px;
    float: right;
    cursor: pointer;
}
p{
    color: red;
    text-align: center;
}
</pre>
<p>上面的样式表将设置输入字段的样式，并将添加按钮(+)放置在字段旁边。它还将按行格式化任务，并在每个任务项旁边添加一个删除(trash)图标。</p>
<h2 id="testing-full-stack-application">测试全栈应用</h2>
<p>现在是时候验证您的应用程序是否正常运行了。在运行应用程序之前，您需要启用一个代理来防止CORS(跨源资源共享)问题。对于试图从其他服务器访问资源的客户端请求，代理充当中间人。这可以提高网络性能、安全性和合规性。</p>
<p>要启用代理，在您的<code>src</code>目录中创建一个名为<code>proxy.config.json</code>的文件，并添加以下配置:</p>
<pre class="language-json hljs">{
    "/api": {
      "target": "http://localhost:3000",
      "secure": false,
      "pathRewrite": {"^/api" : ""}
    }
  }
</pre>
<p>现在运行后端和前端开发服务器，导航到<a href="http://localhost:4200/"> http://localhost:4200/ </a>预览前端:</p>
<p><img data-attachment-id="160117" data-permalink="https://blog.logrocket.com/build-project-using-angular-nestjs/attachment/full-stack-angular-nestjs-application/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2023/02/full-stack-angular-nestjs-application.png" data-orig-size="720,259" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Full-stack Angular NestJS application" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2023/02/full-stack-angular-nestjs-application-300x108.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2023/02/full-stack-angular-nestjs-application.png" decoding="async" class="aligncenter wp-image-160117 size-full jetpack-lazy-image" src="../Images/c98008cf23b8e038a5921b9a1ae4413c.png" alt="Full-stack Angular NestJS Application" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2023/02/full-stack-angular-nestjs-application.png 720w, https://blog.logrocket.com/wp-content/uploads/2023/02/full-stack-angular-nestjs-application-300x108.png 300w" data-lazy-sizes="(max-width: 720px) 100vw, 720px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2023/02/full-stack-angular-nestjs-application.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2023/02/full-stack-angular-nestjs-application.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="160117" data-permalink="https://blog.logrocket.com/build-project-using-angular-nestjs/attachment/full-stack-angular-nestjs-application/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2023/02/full-stack-angular-nestjs-application.png" data-orig-size="720,259" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Full-stack Angular NestJS application" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2023/02/full-stack-angular-nestjs-application-300x108.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2023/02/full-stack-angular-nestjs-application.png" decoding="async" loading="lazy" class="aligncenter wp-image-160117 size-full" src="../Images/c98008cf23b8e038a5921b9a1ae4413c.png" alt="Full-stack Angular NestJS Application" srcset="https://blog.logrocket.com/wp-content/uploads/2023/02/full-stack-angular-nestjs-application.png 720w, https://blog.logrocket.com/wp-content/uploads/2023/02/full-stack-angular-nestjs-application-300x108.png 300w" sizes="(max-width: 720px) 100vw, 720px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2023/02/full-stack-angular-nestjs-application.png"/></noscript>
<p>您可以通过点击<strong> + </strong>图标添加更多任务，并通过点击回收站图标删除任务。</p>
<h2 id="conclusion">结论</h2>
<p>在本教程中，我们介绍了如何使用Angular和NestJS构建一个项目。我们首先解释了两个框架之间的相似之处。然后，我们为NestJS和Angular设置开发服务器。接下来，我们创建了一个将数据写入JSON文件的NestJS服务，作为应用程序的数据库。然后我们实现了一个Angular服务，它向NestJS后端发送API请求来执行CRUD操作。</p>
<p>最后，我们更新了Angular App组件类，以创建允许从App模板进行数据操作的方法。既然您已经学习了如何在构建全栈应用程序时集成Angular和NestJS，那么您可以在下一个项目中使用这些框架。您还可以通过从GitHub 克隆<a href="https://github.com/Claradev32/angular-nest.js-fullstack-app">完整项目来更新后端，以使用实际的数据库，如MongoDB或MySQL。</a></p>
<p>我希望这篇教程对你有所帮助，并给你一些在下一个项目中使用Angular和NestJS的想法。编码快乐！</p><div class="code-block code-block-19">
<div class="blog-plug inline-plug angular-plug"><h2>像用户一样体验Angular应用程序</h2><p>调试Angular应用程序可能很困难，尤其是当用户遇到难以重现的问题时。如果您对监视和跟踪生产中所有用户的角度状态和动作感兴趣，</p><a href="https://lp.logrocket.com/blg/angular-signup">try LogRocket</a><p>. </p><a class="signup" href="https://lp.logrocket.com/blg/angular-signup" target="_blank" rel="noopener noreferrer"><img class="alignnone size-full wp-image-46 jetpack-lazy-image" src="../Images/2794ac39244976f37c4941d9a910be23.png" alt="LogRocket Dashboard Free Trial Banner" data-lazy-src="https://files.readme.io/610d6a7-687474703a2f2f692e696d6775722e636f6d2f696147547837412e706e67.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://files.readme.io/610d6a7-687474703a2f2f692e696d6775722e636f6d2f696147547837412e706e67.png"/><noscript><img data-lazy-fallback="1" class="alignnone size-full wp-image-46" src="../Images/2794ac39244976f37c4941d9a910be23.png" alt="LogRocket Dashboard Free Trial Banner" data-original-src="https://files.readme.io/610d6a7-687474703a2f2f692e696d6775722e636f6d2f696147547837412e706e67.png"/></noscript></a><a href="https://lp.logrocket.com/blg/angular-signup" target="_blank" rel="noopener noreferrer">https://logrocket.com/signup/</a><p>LogRocket 就像是网络和移动应用程序的DVR，记录你网站上发生的一切，包括网络请求、JavaScript错误等等。您可以汇总并报告问题发生时应用程序的状态，而不是猜测问题发生的原因。</p><p>LogRocket NgRx插件将角度状态和动作记录到LogRocket控制台，为您提供导致错误的环境，以及出现问题时应用程序的状态。</p><p>现代化调试Angular应用的方式- <a class="signup" href="https://lp.logrocket.com/blg/angular-signup" target="_blank" rel="noopener noreferrer">开始免费监控</a>。</p></div>
</div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
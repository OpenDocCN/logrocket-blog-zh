<html>
<head>
<title>Understanding SolidJS’ updated batch function </title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>了解SolidJS更新的批处理功能</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/understanding-solidjs-updated-batch-function/#0001-01-01">https://blog.logrocket.com/understanding-solidjs-updated-batch-function/#0001-01-01</a></blockquote><div><article class="article-post">
<p>所有框架旨在改进的最紧迫的挑战之一是状态和反应性管理，正如对框架和库所做的开发一样，如<a href="https://www.solidjs.com"> SolidJS </a>、React、Svelte、Angular和Vue。</p>
<p>批处理状态更新是框架试图改进其反应模型的一种方式。框架允许开发人员指定哪些更改是相关的，以便UI更新被延迟，直到所有相关的值都被更改，而不是重新呈现UI来响应每个单独的状态更改。</p>
<p>在React 18中，这个问题通过自动批处理特性得到了解决，该特性在批处理的基础上进行了改进，增加了事件、异步事件和钩子。这种行为是自动的，需要您使用<code>flushSync</code>方法来防止它。</p>
<p>虽然已经有一段时间了，<a href="https://www.solidjs.com/docs/latest#batch"> Solid最近对其<code>batch</code>功能</a>进行了更新，该功能允许开发者根据他们特定应用的需求手动决定何时进行批处理。在本文中，我们将探索它是如何工作的。</p>

<h2 id="refresher-solid-js-terminology">固体术语复习</h2>
<p>Solid是一个前端框架，与Angular、Vue和React等替代框架相比，它提供了一些好处。</p>
<p>像Svelte一样，Solid也是编译的，所以不需要将整个框架发送给每个最终用户，而是编译代码并转化成普通的JS。因此，您只是向最终用户交付了小得多的包所必需的代码。</p>
<p>像React一样，Solid使用JSX作为一种表达UI的方式。在Solid中，一个反应值被称为一个信号，一个应该在这些值改变时运行的操作被称为一个效果。</p>
<p>为了创建一个信号，我们使用<code>createSignal</code>，它类似于React中的<code>useState</code>。为了创造一种效果，我们使用<code>createEffect</code>。但是，组件返回的JSX会被自动视为一种效果。</p>
<p>这与React相反，在React中，每次状态改变时，组件功能都完整地运行。在Solid中，只有显式指定的内部效果代码才会在状态更新时重复。因此，与在React中使用<code>useEffect</code>来指定不需要在每次更新时运行的代码不同，在Solid中，如果您将代码封装在<code>createEffect</code>中，代码只在更新时运行。</p>
<h2 id="what-happens-without-batch">没有<code>batch</code>会怎样？</h2>
<p>为了测试这个例子，你可以从这个回购的主分支<a href="https://github.com/AlexMercedCoder/solidjs-batch-example">中克隆代码。所有相关代码都在下面的<code>/src/App.jsx</code>中:</a></p>
<pre class="language-javascript hljs">import logo from './logo.svg';
import styles from './App.module.css';
import {createSignal, createEffect} from "solid-js"
function App() {
  const [p1, setP1] = createSignal("Alex Merced")
  const [p2, setP2] = createSignal("Tony Merced")
  let p1Input
  let p2Input
  createEffect(() =&gt; console.log(p1(), p2()))
  return (
    &lt;div class={styles.App}&gt;
      &lt;header class={styles.header}&gt;
        &lt;h1&gt;Player: {p1}&lt;/h1&gt;
        &lt;h1&gt;Player: {p2}&lt;/h1&gt;
      &lt;/header&gt;
      &lt;form onSubmit={(event) =&gt; {
        event.preventDefault()
        setP1(p1Input.value)
        setP2(p2Input.value)
      }}&gt;
        &lt;input type="text" placeholder="player 1" name="p1" ref={p1Input}/&gt;
        &lt;input type="text" placeholder="player 2" name="p2" ref={p2Input}/&gt;
        &lt;input type="submit"/&gt;
      &lt;/form&gt;
    &lt;/div&gt;
  );
}
export default App;
</pre>
<p>我们有两个信号:电抗值<code>p1</code>和<code>p2</code>。这两个值在UI中都显示为<code>h1</code>。为了展示它们是如何变化的，我们创建了一个将它们都记录到终端的效果。</p>
<p>表单中有两个输入。当提交表单时，信号的值被分别设置为这些输入的值。在这里，我们看到一些独特的事情发生。假设您在第一个输入中输入<code>Bread</code>，在第二个输入中输入<code>Cheese</code>。提交表单时，您将看到以下控制台日志:</p>
<pre class="language-javascript hljs">Bread Tony Merced
Bread Cheese
</pre>
<p>当我们在第20行更改<code>p1</code>时，它触发所有依赖于该值的效果，用两个控制台日志重新运行UI更新和效果。然后，当<code>p2</code>被更改时，整个事情再次发生，因此出现了第二个日志。</p>
<p>最终，最终的UI实际上取决于它们的值。为了提高效率，你应该等待两个值都被更新来重新运行所有的从属效果，这就是<code>batch</code>的用武之地。</p>
<h2 id="using-batch-solid-js">在实体中使用<code>batch</code></h2>
<p>要查看示例代码，您可以<a href="https://github.com/AlexMercedCoder/solidjs-batch-example/tree/batch">克隆存储库的这个分支</a>。假设我们的<code>src/App.jsx</code>文件中有下面的代码:</p>
<pre class="language-javascript hljs">import logo from "./logo.svg";
import styles from "./App.module.css";
import { createSignal, createEffect, batch } from "solid-js";
function App() {
  const [p1, setP1] = createSignal("Alex Merced");
  const [p2, setP2] = createSignal("Tony Merced");
  let p1Input;
  let p2Input;
  createEffect(() =&gt; console.log(p1(), p2()));
  return (
    &lt;div class={styles.App}&gt;
      &lt;header class={styles.header}&gt;
        &lt;h1&gt;Player: {p1}&lt;/h1&gt;
        &lt;h1&gt;Player: {p2}&lt;/h1&gt;
      &lt;/header&gt;
      &lt;form
        onSubmit={(event) =&gt; {
          event.preventDefault();
          batch(() =&gt; {
            setP1(p1Input.value);
            setP2(p2Input.value);
          });
        }}
      &gt;
        &lt;input type="text" placeholder="player 1" name="p1" ref={p1Input} /&gt;
        &lt;input type="text" placeholder="player 2" name="p2" ref={p2Input} /&gt;
        &lt;input type="submit" /&gt;
      &lt;/form&gt;
    &lt;/div&gt;
  );
}
export default App;
</pre>
<p>在上面的代码片段中，我们在第3行添加了<code>batch</code>的导入，并在第19行将两个值更新封装在对<code>batch</code>的调用中。</p>
<p>如果您再次用<code>bread</code>和<code>cheese</code>填写输入，在点击<strong>提交</strong>后，您将只能看到一个控制台日志:</p>
<pre class="language-javascript hljs">bread cheese
</pre>
<p><code>batch</code>延迟运行效果，直到<code>batch</code>回调中的所有状态更新完成。这减少了我们代码中运行效果的次数，从而提高了代码的整体效率。</p>
<h2 id="when-to-use-batch-solid">什么时候应该用<code>batch</code>？</h2>
<p>在应用程序的早期版本中，您可能不会费心使用<code>batch</code>，而是仅仅关注于构建一个功能性的应用程序。但是，随着你的应用程序成熟，你需要优化性能，批处理状态更新，<a href="https://blog.logrocket.com/react-re-reselect-better-memoization-cache-management/">记忆复杂的计算，以及其他技术</a>可以真正帮助你的应用程序尽可能平稳地运行。</p>
<p>底线是，如果你正在更新几个独特的信号，但你不想在它们都完成更新之前运行效果，使用<code>batch</code>。</p>
<h2 id="conclusion">结论</h2>
<p>批处理是有用的，因为它可以防止更清晰的应用程序的冗余操作。React采用的方法是假设您总是想要批处理，而Solid提供了工具，让您更容易地表达您想要的结果，并且只在您需要时进行批处理，而不是在您不需要时。我希望你喜欢这篇文章，如果你有任何问题，一定要留下评论。编码快乐！</p><div class="code-block code-block-28">
<div class="blog-plug inline-plug js-libraries-plug"><h2>您是否添加了新的JS库来提高性能或构建新特性？如果他们反其道而行之呢？</h2><p>毫无疑问，前端变得越来越复杂。当您向应用程序添加新的JavaScript库和其他依赖项时，您将需要更多的可见性，以确保您的用户不会遇到未知的问题。</p>
<p>LogRocket 是一个前端应用程序监控解决方案，可以让您回放JavaScript错误，就像它们发生在您自己的浏览器中一样，这样您就可以更有效地对错误做出反应。</p><a class="signup" href="https://lp.logrocket.com/blg/javascript-signup" target="_blank" rel="noopener noreferrer"><img class="alignnone size-full wp-image-46 jetpack-lazy-image" src="../Images/e8a0ab42befa3b3b1ae08c1439527dc6.png" alt="LogRocket Dashboard Free Trial Banner" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2019/10/errors-screenshot.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/10/errors-screenshot.png"/><noscript><img data-lazy-fallback="1" class="alignnone size-full wp-image-46" src="../Images/e8a0ab42befa3b3b1ae08c1439527dc6.png" alt="LogRocket Dashboard Free Trial Banner" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/10/errors-screenshot.png"/></noscript></a>
<a href="https://lp.logrocket.com/blg/javascript-signup" target="_blank" rel="noopener noreferrer">https://logrocket.com/signup/</a><p><a href="https://lp.logrocket.com/blg/javascript-signup" target="_blank" rel="noopener noreferrer"> LogRocket </a>可以与任何应用程序完美配合，不管是什么框架，并且有插件可以记录来自Redux、Vuex和@ngrx/store的额外上下文。您可以汇总并报告问题发生时应用程序的状态，而不是猜测问题发生的原因。LogRocket还可以监控应用的性能，报告客户端CPU负载、客户端内存使用等指标。</p><p>自信地构建— <a class="signup" href="https://lp.logrocket.com/blg/javascript-signup" target="_blank" rel="noopener noreferrer">开始免费监控</a>。</p></div>


</div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
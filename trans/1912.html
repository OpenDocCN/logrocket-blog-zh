<html>
<head>
<title>React localization with i18next - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>使用 i18next - LogRocket 博客对本地化做出反应</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/react-localization-with-i18next/#0001-01-01">https://blog.logrocket.com/react-localization-with-i18next/#0001-01-01</a></blockquote><div><article class="article-post">
<p>对于希望通过提高转化率来提高用户满意度和实现业务目标的开发人员来说，构建满足本地市场需求的应用程序至关重要。</p>
<p>对于 React 应用程序，有许多国际化选项可以针对这类受众。在本指南中，我们将回顾最流行的解决方案之一:i18next。</p>
<p>由于本地化过程(也称为 l10n ),该框架无缝地使应用适应特定的本地市场和文化。</p>
<p>本地化不仅仅是将单词从一种语言翻译成另一种语言。除了翻译，它还帮助我们考虑文化差异，如货币、单位位置、数字和日期格式、多元化，甚至当地的外观。</p>
<p>这是本地化应用程序的外观:</p>
<p><img data-attachment-id="56925" data-permalink="https://blog.logrocket.com/react-localization-with-i18next/final-localized-app/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2021/06/Final-localized-app.png" data-orig-size="730,403" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Final localized app" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2021/06/Final-localized-app-300x166.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2021/06/Final-localized-app.png" decoding="async" class="aligncenter wp-image-56925 size-full jetpack-lazy-image" src="../Images/6e64cdc0c3168638900375822abe5bc1.png" alt="Final Localized Application Using i18next" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2021/06/Final-localized-app.png 730w, https://blog.logrocket.com/wp-content/uploads/2021/06/Final-localized-app-300x166.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2021/06/Final-localized-app.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2021/06/Final-localized-app.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="56925" data-permalink="https://blog.logrocket.com/react-localization-with-i18next/final-localized-app/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2021/06/Final-localized-app.png" data-orig-size="730,403" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Final localized app" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2021/06/Final-localized-app-300x166.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2021/06/Final-localized-app.png" decoding="async" loading="lazy" class="aligncenter wp-image-56925 size-full" src="../Images/6e64cdc0c3168638900375822abe5bc1.png" alt="Final Localized Application Using i18next" srcset="https://blog.logrocket.com/wp-content/uploads/2021/06/Final-localized-app.png 730w, https://blog.logrocket.com/wp-content/uploads/2021/06/Final-localized-app-300x166.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2021/06/Final-localized-app.png"/></noscript>
<p>在本教程中，我们一起构建这个应用程序。您可以在这里与最终项目<a href="https://react-i18next-project.herokuapp.com/">互动。</a></p>
<h2>为什么要使用 i18next 框架？</h2>
<p>i18next 框架非常灵活，因为它支持插件，允许我们添加一些我们必须自己构建的特性。</p>
<p>我们还可以选择将翻译分成不同的文件，并在需要时加载它们。这意味着我们不需要在加载页面之前加载所有的翻译文件，从而减少缓慢的加载时间。</p>
<h2>先决条件</h2>
<ul>
<li>对 React 的基本理解</li>
<li>安装在计算机上的 Node.js</li>
</ul>
<h2>下载启动项目</h2>
<p>使用这个简单的<a href="https://github.com/Ibaslogic/react_i18next_starter"> React 项目与</a>一起工作，让我们在我们的计算机终端中运行以下命令:</p>
<pre>git clone https://github.com/Ibaslogic/react_i18next_starter
</pre>
<p>完成后，用代码编辑器打开<code>project</code>文件夹。在<code>project</code>目录下，运行<code>npm install</code>生成一个<code>node_modules</code>文件夹。</p>
<p>然后，通过运行<code>npm start</code>启动开发服务器，在<a href="http://localhost:3000/" rel="nofollow"> http://localhost:3000/ </a>等待查看应用程序在浏览器中的加载情况。</p>
<p><img data-attachment-id="56928" data-permalink="https://blog.logrocket.com/react-localization-with-i18next/reacti18next-home-screen-english/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2021/06/Reacti18next-home-screen-english.png" data-orig-size="730,336" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Reacti18next home screen English" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2021/06/Reacti18next-home-screen-english-300x138.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2021/06/Reacti18next-home-screen-english.png" decoding="async" class="aligncenter size-full wp-image-56928 jetpack-lazy-image" src="../Images/0dbfb0b0ee520a4a9ab109a2e36d7038.png" alt="Reacti18next Home Screen Rendered In English" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2021/06/Reacti18next-home-screen-english.png 730w, https://blog.logrocket.com/wp-content/uploads/2021/06/Reacti18next-home-screen-english-300x138.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2021/06/Reacti18next-home-screen-english.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2021/06/Reacti18next-home-screen-english.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="56928" data-permalink="https://blog.logrocket.com/react-localization-with-i18next/reacti18next-home-screen-english/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2021/06/Reacti18next-home-screen-english.png" data-orig-size="730,336" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Reacti18next home screen English" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2021/06/Reacti18next-home-screen-english-300x138.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2021/06/Reacti18next-home-screen-english.png" decoding="async" loading="lazy" class="aligncenter size-full wp-image-56928" src="../Images/0dbfb0b0ee520a4a9ab109a2e36d7038.png" alt="Reacti18next Home Screen Rendered In English" srcset="https://blog.logrocket.com/wp-content/uploads/2021/06/Reacti18next-home-screen-english.png 730w, https://blog.logrocket.com/wp-content/uploads/2021/06/Reacti18next-home-screen-english-300x138.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2021/06/Reacti18next-home-screen-english.png"/></noscript>
<p><code>project</code>结构应该是这样的:</p>
<pre>project_folder
    ├── node_modules
    ├── public
    ├── src
    │    ├── components
    │    │      ├── App.js
    │    │      ├── Content.js
    │    │      ├── Footer.js
    │    │      └── Header.js
    │    ├── index.css
    │    └── index.js
    ├── .gitignore
    ├── package-lock.json
    ├── package.json
    ├── README.md
    └── yarn.lock
</pre>
<p>目前，我们的重点是<code>src</code>文件夹。在那里，我们拥有所有包含我们可以本地化的内容的 React 组件。</p>
<h2>安装<code>i18next</code>和<code>react-i18next</code>包</h2>
<p>要使用 i18next 本地化 React 应用程序，我们必须将<code>i18next</code>和<code>react-i18next</code>包添加到我们的项目中。</p>
<p><code>i18next</code>提供所有的翻译功能，而<code>react-i18next</code>增加了一些额外的 React 功能，如挂钩、hoc、渲染道具等。</p>
<p>通过运行以下命令来安装它们:</p>
<pre>npm install react-i18next i18next
</pre>
<h2>设置配置文件</h2>
<p>在<code>src</code>文件夹中创建一个名为<code>i18n.js</code>的文件，并添加以下翻译配置:</p>
<pre>import i18n from "i18next";
import { initReactI18next } from "react-i18next";

i18n
  .use(initReactI18next)
  .init({
    resources: {
      en: {
        translation: {
          //English translations here
        },
      },
      ja: {
        translation: {
          //Japanese translations here
        },
      },
    },
    lng: "en",
    fallbackLng: "en",
  });

export default i18n;
</pre>
<p>通过从<code>i18next</code>内核导入<code>i18n</code>实例，我们可以通过模块提供的<code>initReactI18next</code>对象将<code>react-i18next</code>模块绑定到它。这确保了 i18next 框架将<code>i18n</code>实例传递给<code>react-i18next</code>模块。</p>
<p>调用<code>use()</code>函数加载并绑定任何插件到<code>i18n</code>实例。</p>
<p>然后，我们通过调用定义基本配置选项的<code>init()</code>函数和<a href="https://www.i18next.com/overview/configuration-options">来初始化我们的配置。</a></p>
<p>我们还添加了<code>resources</code>、<code>lng</code>和<code>fallbackLng</code>对象属性。在<code>resources</code>中，我们为英语和日语两种语言提供了<code>translation</code>对象。</p>
<p><code>en</code>和<code>ja</code>分别是代表英语和日语的 ISO 标准代码。在此查看所有<a href="http://www.gnu.org/savannah-checkouts/gnu/gettext/manual/gettext.html#Language-Codes"> ISO 标准</a> <a href="http://www.gnu.org/savannah-checkouts/gnu/gettext/manual/gettext.html#Language-Codes">语言缩写</a>。</p>
<p>接下来，在<code>src/index.js</code>中导入配置文件，就像这样:</p>
<pre>import "./i18n";
</pre>
<p>别忘了保存文件！</p>
<h2>翻译一条简单的短信</h2>
<p>首先，让我们翻译来自我们的起始项目的一个简单的标题消息，“欢迎来到 react-i18 下一个教程。”</p>
<p>更新<code>src/i18n.js</code>文件以包含英语和日语翻译:</p>
<pre>// ...
resources: {
  en: {
    translation: {
      //English translations here
      "welcome text": "Welcome to the react-i18next tutorial",
    },
  },
  ja: {
    translation: {
      //Japanese translations here
      "welcome text": "react-i18nextチュートリアルへようこそ",
    },
  },
},
// ...
</pre>
<p>保存文件。</p>
<p>正如在<code>translation</code>对象中所看到的，我们用 JSON 格式定义了我们的消息，在支持的地区中给它一个惟一的键。</p>
<p>在这个项目中，我们使用<a href="https://translate.google.com/"> Google Translate </a>翻译成目标语言。</p>
<h3>通过<code>t()</code>访问翻译后的信息</h3>
<p><code>i18next</code>通过<code>i18n</code>实例提供了一个名为<code>t()</code>的翻译函数。它接受一个查找翻译对象的键，并返回与当前语言的键匹配的字符串。</p>
<p>根据 React 组件的类型，我们可以用不同的方式访问<code>t()</code>,比如使用:</p>

<p>在本指南中，我们将使用<code>useTranslation</code>挂钩。</p>
<h3>使用<code>useTranslation</code>挂钩</h3>
<p>打开<code>components/Content.js</code>文件，导入<code>useTranslation</code>钩子，像这样:</p>
<pre>import { useTranslation } from 'react-i18next';
</pre>
<p>然后，在<code>return</code>语句的上方添加这一行:</p>
<pre>const { t, i18n } = useTranslation();
</pre>
<p>从钩子中，我们可以访问<code>t</code>函数和<code>i18n</code>实例。我们只需要<code>t</code>功能来翻译我们的内容。在本指南的后面，我们将使用<code>i18n</code>实例来更改应用程序语言。目前，我们可以移除<code>i18n</code>。</p>
<p>接下来，用包含翻译键的<code>t</code>函数替换<code>h1</code>文本，这样我们就有了以下内容:</p>
<pre>import { useTranslation } from "react-i18next";

const Content = () =&gt; {
  const { t } = useTranslation();

  return (
    &lt;div className="container hero"&gt;
      &lt;h1&gt;{t("welcome text")}&lt;/h1&gt;
      {/* ... */}
    &lt;/div&gt;
  );
};

export default Content;
</pre>
<p>保存文件并重新加载前端。</p>
<p>什么都没变。但是，让我们暂时将<code>src/i18n.js</code>文件中的<code>lng</code>属性改为日语(<code>ja</code>)并保存该文件:</p>
<pre>i18n
  .use(initReactI18next)
  .init({
    resources: {
      // ...
    },
    lng: "ja",
    fallbackLng: "en",
  });
</pre>
<p>重新加载页面后，我们将看到呈现的日文文本:</p>
<p><img data-attachment-id="56927" data-permalink="https://blog.logrocket.com/react-localization-with-i18next/render-app-text-japanese/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2021/06/Render-app-text-japanese.png" data-orig-size="730,327" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Render app text japanese" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2021/06/Render-app-text-japanese-300x134.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2021/06/Render-app-text-japanese.png" decoding="async" class="aligncenter wp-image-56927 size-full jetpack-lazy-image" src="../Images/8816bb0aaebfd14ecb5a334f7fdba85b.png" alt="Rendered App Text In Japanese With Page Reload" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2021/06/Render-app-text-japanese.png 730w, https://blog.logrocket.com/wp-content/uploads/2021/06/Render-app-text-japanese-300x134.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2021/06/Render-app-text-japanese.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2021/06/Render-app-text-japanese.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="56927" data-permalink="https://blog.logrocket.com/react-localization-with-i18next/render-app-text-japanese/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2021/06/Render-app-text-japanese.png" data-orig-size="730,327" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Render app text japanese" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2021/06/Render-app-text-japanese-300x134.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2021/06/Render-app-text-japanese.png" decoding="async" loading="lazy" class="aligncenter wp-image-56927 size-full" src="../Images/8816bb0aaebfd14ecb5a334f7fdba85b.png" alt="Rendered App Text In Japanese With Page Reload" srcset="https://blog.logrocket.com/wp-content/uploads/2021/06/Render-app-text-japanese.png 730w, https://blog.logrocket.com/wp-content/uploads/2021/06/Render-app-text-japanese-300x134.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2021/06/Render-app-text-japanese.png"/></noscript>
<h2>延迟从服务器加载翻译文件</h2>
<p>目前，我们已经将所有的翻译加载到配置文件中。这并不理想，尤其是当我们在一个更大的项目中添加更多的语言和内容时。</p>
<p>通过将翻译从代码中分离出来并在需要时加载，提供了一种更好的优化代码的方法。为此，我们将安装一个插件。</p>
<h3>安装<code>i18next-http-backend</code></h3>
<p><code>i18next-http-backend</code>包从后端服务器加载翻译文件:</p>
<pre>npm install i18next-http-backend
</pre>
<p>接下来，更新<code>i18n.js</code>配置文件以包含插件:</p>
<pre>import i18n from "i18next";
import { initReactI18next } from "react-i18next";
import Backend from "i18next-http-backend";

i18n
  .use(Backend)
  .use(initReactI18next)
  .init({
    ...
  });

export default i18n;
</pre>
<p>默认情况下，这个插件希望从<code>public/locales/{lng}/translation.json</code>目录加载我们的翻译文件，其中<code>lng</code>是语言代码。</p>
<p>虽然我们也可以将目录从配置文件的<a href="https://github.com/i18next/i18next-http-backend">更改为自定义目录，但我们将坚持使用默认目录。</a></p>
<p>让我们为我们支持的每种语言创建<code>translation.json</code>文件。在这种情况下，我们将支持英语、阿拉伯语、法语和日语。</p>
<p>文件结构应该如下所示:</p>
<pre>public
  ├── locales
  │     ├── ar
  │     │   └── translation.json 
  │     ├── en
  │     │   └── translation.json
  │     ├── fr
  │     │   └── translation.json
  │     ├── ja
  │     │   └── translation.json
</pre>
<p>在<code>en/translation.json</code>文件中，添加以下内容:</p>
<pre>{
  "welcome text": "Welcome to the react-i18next tutorial"
}
</pre>
<p>在<code>ar/translation.json</code>文件中，添加以下内容:</p>
<pre>{
  "welcome text": "مرحبًا بك في البرنامج التعليمي react-i18next"
}
</pre>
<p>对于其他支持的语言环境，请使用谷歌翻译。稍后，我们将更新我们的翻译文件，以适应其他文本。</p>
<p>记得保存所有文件。</p>
<p>我们现在可以删除<code>src/i18n.js</code>文件中的<code>resources</code>属性，因为我们现在可以从后端加载翻译。</p>
<p>配置文件现在看起来像这样:</p>
<pre>// ...
i18n
  .use(Backend)
  .use(initReactI18next)
  .init({
    lng: "en",
    fallbackLng: "en",
  });
// ...
</pre>
<p>如果我们保存文件并重新加载前端，我们会遇到应用程序中断。i18next 框架希望我们在等待从后端加载翻译文本的同时处理应用程序的状态。</p>
<p>为此，我们将把顶层组件包装在 React 的<code>Suspense</code>组件中。这允许我们在等待阶段显示一些后备信息，例如装载指示器。</p>
<p>打开<code>src/index.js</code>文件并使用<code>Suspense</code>组件，如下所示:</p>
<pre>ReactDOM.render(
  &lt;React.StrictMode&gt;
    &lt;Suspense fallback={&lt;div&gt;Loading...&lt;/div&gt;}&gt;
      &lt;App /&gt;
    &lt;/Suspense&gt;
  &lt;/React.StrictMode&gt;,
  document.getElementById("root")
);
</pre>
<p>接下来，在文件顶部导入<code>Suspense</code>组件:</p>
<pre>import React, { Suspense } from "react";
</pre>
<p>属性接受一个文本字符串或者任何我们想要呈现的 React 元素。保存文件，应用程序应该工作。</p>
<p>如果我们将配置文件中的<code>lng</code>属性更改为<code>ar</code>或任何支持的语言，我们将在前端看到翻译。</p>
<p><img data-attachment-id="56929" data-permalink="https://blog.logrocket.com/react-localization-with-i18next/change-lng-property/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2021/06/Change-lng-property.png" data-orig-size="730,330" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Change lng property" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2021/06/Change-lng-property-300x136.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2021/06/Change-lng-property.png" decoding="async" class="aligncenter size-full wp-image-56929 jetpack-lazy-image" src="../Images/115fffe9d7ccf22b07466919a61f1be0.png" alt="Change lng Property To Update Translation In The Frontend" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2021/06/Change-lng-property.png 730w, https://blog.logrocket.com/wp-content/uploads/2021/06/Change-lng-property-300x136.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2021/06/Change-lng-property.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2021/06/Change-lng-property.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="56929" data-permalink="https://blog.logrocket.com/react-localization-with-i18next/change-lng-property/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2021/06/Change-lng-property.png" data-orig-size="730,330" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Change lng property" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2021/06/Change-lng-property-300x136.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2021/06/Change-lng-property.png" decoding="async" loading="lazy" class="aligncenter size-full wp-image-56929" src="../Images/115fffe9d7ccf22b07466919a61f1be0.png" alt="Change lng Property To Update Translation In The Frontend" srcset="https://blog.logrocket.com/wp-content/uploads/2021/06/Change-lng-property.png 730w, https://blog.logrocket.com/wp-content/uploads/2021/06/Change-lng-property-300x136.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2021/06/Change-lng-property.png"/></noscript>
<p>既然我们已经介绍了基础知识，让我们快速翻译一下其他页面内容。</p>
<h2>插值、格式化和多元化</h2>
<p>到目前为止，我们已经介绍了如何翻译一个简单的文本字符串。如前所述，本地化不仅仅是语言之间的翻译。必须考虑文化差异。</p>
<p>接下来，我们将讨论如何格式化和翻译文本丰富的消息。如果我们看一下我们的应用程序，我们会看到我们有数字、日期和货币位置要针对不同的地区进行格式化。</p>
<p>我们也有一个随着用户点击按钮而增加的数字计数，并且必须格式化文本以考虑复数形式。</p>
<h3>插入文字</h3>
<p>当文本包含必须格式化的数字或日期时，我们使用插值。这是允许在我们的翻译中插入值的功能之一。</p>
<p>使用前端文本“用所选语言格式化 3，000”，我们将在文本中插入“3000”。</p>
<p>在<code>en/translation.json</code>文件中，将其添加到 JSON:</p>
<pre>{
  ...
  "formatNumber": "Formatting {{num}} in the selected language"
}
</pre>
<p>注意我们是如何用占位符替换数字的。</p>
<p>在阿拉伯文文件中，添加以下内容:</p>
<pre>{
  ...
  "formatNumber": "تنسيق {{num}} في اللغة المختارة"
}
</pre>
<p>确保为其他支持的语言环境添加翻译并保存所有文件。</p>
<p>接下来，我们将使用翻译功能<code>t()</code>，根据当前语言翻译和格式化我们的消息。</p>
<p>在<code>components/Content.js</code>中，找到这个元素:</p>
<pre>&lt;p&gt;Formatting 3,000 in the selected language&lt;/p&gt;
</pre>
<p>替换为以下内容:</p>
<pre>&lt;p&gt;{t("formatNumber", { num: 3000 })}&lt;/p&gt;
</pre>
<p>这里，我们将要插值的数字作为<code>t()</code>函数的第二个参数进行传递。object 属性中使用的<code>num</code>必须匹配翻译文件中的占位符——在我们的例子中是<code>{{num}}</code>。</p>
<p>保存文件并测试工作。</p>
<p>如果我们将<code>i18n.js</code>文件中的<code>lng</code>属性改为<code>ar</code>，我们将得到:</p>
<p><img data-attachment-id="56930" data-permalink="https://blog.logrocket.com/react-localization-with-i18next/interpolate-number-translation/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2021/06/Interpolate-number-translation.png" data-orig-size="730,226" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Interpolate number translation" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2021/06/Interpolate-number-translation-300x93.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2021/06/Interpolate-number-translation.png" decoding="async" class="aligncenter size-full wp-image-56930 jetpack-lazy-image" src="../Images/f550a2a9af3e3fefdd8e6f99c7115be9.png" alt="Interpolate The Number Translation To Update For The Arabic Format" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2021/06/Interpolate-number-translation.png 730w, https://blog.logrocket.com/wp-content/uploads/2021/06/Interpolate-number-translation-300x93.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2021/06/Interpolate-number-translation.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2021/06/Interpolate-number-translation.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="56930" data-permalink="https://blog.logrocket.com/react-localization-with-i18next/interpolate-number-translation/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2021/06/Interpolate-number-translation.png" data-orig-size="730,226" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Interpolate number translation" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2021/06/Interpolate-number-translation-300x93.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2021/06/Interpolate-number-translation.png" decoding="async" loading="lazy" class="aligncenter size-full wp-image-56930" src="../Images/f550a2a9af3e3fefdd8e6f99c7115be9.png" alt="Interpolate The Number Translation To Update For The Arabic Format" srcset="https://blog.logrocket.com/wp-content/uploads/2021/06/Interpolate-number-translation.png 730w, https://blog.logrocket.com/wp-content/uploads/2021/06/Interpolate-number-translation-300x93.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2021/06/Interpolate-number-translation.png"/></noscript>
<p>接下来，我们必须根据当前语言格式化插入的数字。</p>
<h3>格式化</h3>
<p>默认情况下，i18next 不支持格式化数字或日期。但是，它确实允许我们使用 moment.js、Luxon 和 date-fns 等<a href="https://blog.logrocket.com/javascript-date-libraries/">库进行格式化，或者通过 Intl API 进行格式化。</a></p>
<p>在这个项目中，我们将<a href="https://blog.logrocket.com/react-intl-internationalize-your-react-apps/#Intl-API">使用<code>Intl</code> API </a>为我们格式化；很简单，和 i18next 配合很好。这个 Intl API 通过它的<code>Intl</code>对象为我们提供了所需的构造函数。</p>
<p>对于我们格式化，我们只需要<code>Intl.NumberFormat()</code>和<code>Intl.DateTimeFormat()</code>构造函数。</p>
<p>为了格式化我们之前插入的数字，我们必须在配置中添加另一个名为<code>interpolation</code>的转换选项，并定义一个处理格式化的函数。</p>
<p>现在的配置如下所示:</p>
<pre>i18n
  .use(Backend)
  .use(initReactI18next)
  .init({
    lng: "ar",
    fallbackLng: "en",
    interpolation: {
      format: (value, format, lng) =&gt; {
        if (format === "number") {
          return new Intl.NumberFormat(lng).format(value);
        }
      },
    },
  });
</pre>
<p>重点是<code>format</code>功能。在那里，我们定义了一个条件来检查我们需要格式化的值是否是一个数字。然后，我们必须使用 Intl API 返回当前语言的格式化值。</p>
<p>为了确保条件返回 true，我们必须在翻译中更新占位符<code>{{ }}</code>，以包含<code>number</code>。</p>
<p>对于英语，更新<code>en</code>如下:</p>
<pre>"formatNumber": "Formatting {{num, number}} in the selected language"
</pre>
<p>对于阿拉伯语，更新<code>ar</code>如下:</p>
<pre>"formatNumber": "تنسيق {{num, number}} في اللغة المختارة"
</pre>
<p>更新其他支持的语言环境的翻译文件，并保存它们。</p>
<p>现在，应用程序看起来应该是这样的:</p>
<p><img data-attachment-id="56931" data-permalink="https://blog.logrocket.com/react-localization-with-i18next/updated-arabic-number-format/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2021/06/Updated-Arabic-number-format.png" data-orig-size="730,231" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Updated Arabic number format" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2021/06/Updated-Arabic-number-format-300x95.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2021/06/Updated-Arabic-number-format.png" decoding="async" class="aligncenter size-full wp-image-56931 jetpack-lazy-image" src="../Images/374b876a9777ab0929d9212174bef52e.png" alt="Updated Arabic Number Format From Interpolated Number" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2021/06/Updated-Arabic-number-format.png 730w, https://blog.logrocket.com/wp-content/uploads/2021/06/Updated-Arabic-number-format-300x95.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2021/06/Updated-Arabic-number-format.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2021/06/Updated-Arabic-number-format.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="56931" data-permalink="https://blog.logrocket.com/react-localization-with-i18next/updated-arabic-number-format/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2021/06/Updated-Arabic-number-format.png" data-orig-size="730,231" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Updated Arabic number format" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2021/06/Updated-Arabic-number-format-300x95.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2021/06/Updated-Arabic-number-format.png" decoding="async" loading="lazy" class="aligncenter size-full wp-image-56931" src="../Images/374b876a9777ab0929d9212174bef52e.png" alt="Updated Arabic Number Format From Interpolated Number" srcset="https://blog.logrocket.com/wp-content/uploads/2021/06/Updated-Arabic-number-format.png 730w, https://blog.logrocket.com/wp-content/uploads/2021/06/Updated-Arabic-number-format-300x95.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2021/06/Updated-Arabic-number-format.png"/></noscript>
<p>使用同样的方法，让我们翻译<code>components/Content.js</code>文件中的其他文本，并格式化日期和货币位置。</p>
<p>更新<code>en/translation.json</code>以包括以下内容:</p>
<pre>{
  ...
  "formatCurrency": "Displaying {{price, currency}} in the selected locale",
  "formatDate": "Today's date: {{today, date}}"
}
</pre>
<p>在<code>ar/translation.json</code>中，添加:</p>
<pre>{
  ...
  "formatCurrency": "عرض {{price, currency}} دولارًا في اللغة المحددة",
  "formatDate": "تاريخ اليوم: {{today, date}}"
}
</pre>
<p>同样，为其他受支持的语言环境添加翻译。</p>
<p>之后，更新<code>components/Content.js</code>文件以访问翻译:</p>
<pre>const Content = () =&gt; {
  // ...

  return (
    &lt;div className="container hero"&gt;
      &lt;h1&gt;{t("welcome text")}&lt;/h1&gt;
      &lt;p&gt;{t("formatCurrency", { price: 69.99 })}&lt;/p&gt;
      &lt;p&gt;{t("formatNumber", { num: 3000 })}&lt;/p&gt;
      &lt;p&gt;{t("formatDate", { today: new Date() })}&lt;/p&gt;
    &lt;/div&gt;
  );
};
</pre>
<p>最后，在<code>i18n.js</code>文件中，更新<code>format</code>函数:</p>
<pre>format: (value, format, lng) =&gt; {
  // ...
  if (format === "date") {
    return new Intl.DateTimeFormat(lng).format(value);
  }
  if (format === "currency") {
    return new Intl.NumberFormat(lng, {
      style: "currency",
      currency: "USD",
    }).format(value);
  }
},
</pre>
<p>在这个文件中，我们使用了<code>Intl.DateTimeFormat()</code>构造函数来格式化日期。注意我们是如何为<code>Intl.NumberFormat()</code>提供额外的选项来格式化货币的。在这里找到<a href="https://www.currency-iso.org/dam/downloads/lists/list_one.xml">货币代码列表</a>。</p>
<p>保存所有文件并重新加载前端。</p>
<p>默认情况下，i18next 对值进行转义，以减少跨站点脚本(XSS)攻击，如下图所示。</p>
<p><img data-attachment-id="56932" data-permalink="https://blog.logrocket.com/react-localization-with-i18next/i18next-escapes-values/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2021/06/i18next-escapes-values.png" data-orig-size="730,249" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="i18next escapes values" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2021/06/i18next-escapes-values-300x102.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2021/06/i18next-escapes-values.png" decoding="async" class="aligncenter size-full wp-image-56932 jetpack-lazy-image" src="../Images/e308f183597c16875475e17bbea486b7.png" alt="i18next Escapes Values To Reduce Cross-Site Scripting " data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2021/06/i18next-escapes-values.png 730w, https://blog.logrocket.com/wp-content/uploads/2021/06/i18next-escapes-values-300x102.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2021/06/i18next-escapes-values.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2021/06/i18next-escapes-values.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="56932" data-permalink="https://blog.logrocket.com/react-localization-with-i18next/i18next-escapes-values/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2021/06/i18next-escapes-values.png" data-orig-size="730,249" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="i18next escapes values" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2021/06/i18next-escapes-values-300x102.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2021/06/i18next-escapes-values.png" decoding="async" loading="lazy" class="aligncenter size-full wp-image-56932" src="../Images/e308f183597c16875475e17bbea486b7.png" alt="i18next Escapes Values To Reduce Cross-Site Scripting " srcset="https://blog.logrocket.com/wp-content/uploads/2021/06/i18next-escapes-values.png 730w, https://blog.logrocket.com/wp-content/uploads/2021/06/i18next-escapes-values-300x102.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2021/06/i18next-escapes-values.png"/></noscript>
<p>但是，React 应用是受 XSS 保护的。因此，让我们通过在<code>interpolation</code>中添加<code>escapeValue</code>并分配一个<code>false</code>值来防止 i18next 对值进行转义。</p>
<pre>interpolation: {
  format: (value, format, lng) =&gt; {
    // ...
  },
  escapeValue: false // react already safes from xss
},
</pre>
<p>保存并重新加载前端，它应该工作。</p>
<h3>多元化</h3>
<p>目前在我们的应用程序中，点击前端计数按钮不会改变计数语句。例如，当计数为单数时，语句应该为“您点击了 1 次”</p>
<p>因此，让我们开始将翻译添加到各种翻译文件中。更新<code>en/translation.json</code>文件以包括以下内容:</p>
<pre>{
  ...
  "clickCount": "You've clicked {{count}} time",
  "clickCount_plural": "You've clicked {{count}} times"
}
</pre>
<p>这里，我们用占位符替换消息中的动态计数。这个占位符变量必须称为<code>count</code>。我们也提供我们翻译的复数形式。</p>
<p>为了告诉 i18next 是呈现单数还是复数消息，我们必须将不带<code>_plural</code>的<code>clickCount</code>键和动态计数值一起传递给呈现中的<code>t</code>函数。</p>
<p>如果计数为<code>1</code>，则呈现单数消息，否则呈现复数形式。</p>
<p>让我们更新其他地区的翻译文件。对于<code>ja/translation.json</code>文件，添加以下内容:</p>
<pre>{
  ...
  "clickCount": "{{count}}回クリックしました"
}
</pre>
<p>请注意，我们没有添加复数等价物。这是因为日语(<code>ja</code>)只有一个复数形式。参见每种语言的<a href="http://docs.translatehouse.org/projects/localization-guide/en/latest/l10n/pluralforms.html?id=l10n/pluralforms">复数形式。</a></p>
<p>和英语一样，法语也有两种复数形式。然而，有些单词的单复数形式相同。</p>
<p>例如，如果我们将消息翻译成法语，我们将在<code>fr/translation.json</code>文件中得到以下内容:</p>
<pre>{
  ...
  "clickCount": "Vous avez cliqué {{count}} fois",
  "clickCount_plural": "Vous avez cliqué {{count}} fois"
}
</pre>
<p>因为两者的形式相同，所以我们可以忽略第二个，这样:</p>
<pre>{
  ...
  "clickCount": "Vous avez cliqué {{count}} fois",
}
</pre>
<p>对于阿拉伯语，除了单数形式之外，还有五种复数形式，所以我们必须定义每一种形式，就像这样:</p>
<pre>clickCount_0; //c = 0 i.e zero
clickCount_1; //c = 1 i.e singular
clickCount_2; //c =2 i.e two
clickCount_3; //3 &lt;= c &lt;=10 i.e few
clickCount_4; //11 &lt;= c &lt;=99 i.e many
clickCount_5; //&gt;= 100 i.e other
</pre>
<p>我们必须维护相同的键名，在我们的例子中，维护的是<code>clickCount</code>，就像我们在其他翻译文件中使用的一样。</p>
<p>i18next 根据计数自动选择合适的表单。当计数为<code>0</code>、<code>1</code>或<code>2</code>时，i18next 渲染分配给它们各自键<code>clickCount_0</code>、<code>clickCount_1</code>和<code>clickCount_2</code>的翻译。</p>
<p>但是，当计数在<code>3</code>和<code>10</code>之间时，i18next 渲染分配给<code>clickCount_3</code>的翻译，<code>11</code>到<code>99</code>渲染分配给<code>clickCount_4</code>的翻译，在<code>100</code>或以上的计数渲染分配给<code>clickCount_5</code>的翻译。</p>
<p>如果我们将字符串“你点击了{{n}}次”翻译成阿拉伯语，其中“n”是一个从 0 到无穷大的数字，我们可以使用 Google Translate 得到以下结果:</p>
<pre>{
  ...
  "clickCount_0": "لقد نقرت {{count}} مرة",
  "clickCount_1": "لقد نقرت مرة واحدة",
  "clickCount_2": "لقد نقرت مرتين",
  "clickCount_3": "لقد نقرت {{count}} مرات",
  "clickCount_4": "لقد نقرت {{count}} مرة",
  "clickCount_5": "لقد نقرت {{count}} مرة"
}
</pre>
<p>现在，保存文件。</p>
<p>打开<code>components/Footer.js</code>文件访问<code>t</code>功能。首先，导入翻译挂钩，就像这样:</p>
<pre>import { useTranslation } from "react-i18next";
</pre>
<p>在<code>return</code>语句上方，从钩子中访问<code>t</code>函数:</p>
<pre>const { t } = useTranslation();
</pre>
<p>现在，我们可以用它代替文本来翻译它；因此，找到以下元素:</p>
<pre>&lt;p&gt;You've clicked {count} times&lt;/p&gt;
</pre>
<p>然后，用这个替换它:</p>
<pre>&lt;p&gt;{t("clickCount", { count: count })}&lt;/p&gt;
</pre>
<p>保存文件，重新加载前端，并测试项目。</p>
<h2><code>Trans</code>组件</h2>
<p>要翻译用<code>strong</code>、<code>i</code>或<code>br</code>元素格式化的字符串，或者要包含一个链接，我们必须使用 i18next 中的<code>Trans</code>组件。</p>
<p>如果我们打开<code>components/Footer.js</code>文件，我们可以翻译并格式化以下元素:</p>
<pre>&lt;p&gt;
  Let's &lt;strong&gt; click the button &lt;/strong&gt; below:
&lt;/p&gt;
</pre>
<p>这里的逻辑很简单；我们将把<code>p</code>元素文本分解成节点，并给它们分配一个索引号，如下所示:</p>
<pre>  Let's --&gt; index 0
  &lt;strong&gt; click the button &lt;/strong&gt; --&gt; index 1
  below: --&gt; index 2
</pre>
<p>接下来，在<code>Footer.js</code>文件中导入<code>Trans</code>组件来换行:</p>
<pre>// ...

import { useTranslation, Trans } from "react-i18next";

const Footer = () =&gt; {
  // ...

  return (
    &lt;div className="container mt"&gt;
      {/* Footer content here */}
      &lt;p&gt;
        &lt;Trans i18nKey="clickButtonText"&gt;
          Let's &lt;strong&gt; click the button &lt;/strong&gt; below:
        &lt;/Trans&gt;
      &lt;/p&gt;
      {/* ... */}
    &lt;/div&gt;
  );
};

// ...
</pre>
<p>注意，我们已经将<code>i18nKey</code>道具添加到了<code>Trans</code>组件中。我们将使用它的值作为翻译文件中的键。</p>
<p>我们现在可以使用这个索引号作为占位符来引用翻译文件中的内部元素。</p>
<p>在<code>en/translation.json</code>文件中，我们有以下内容:</p>
<pre>{
  ...
  "clickButtonText": "Let's &lt;1&gt;click the button&lt;/1&gt; below:"
}
</pre>
<p>钥匙来自<code>Trans</code> <code>i18nKey</code>道具。</p>
<p>在<code>ar/translation.json</code>文件中，我们有以下内容:</p>
<pre>{
  ...
  "clickButtonText": "دعنا &lt;1&gt; انقر فوق الزر &lt;/ 1&gt; أدناه: "
}
</pre>
<p>更新其他支持的翻译文件，保存它们，然后重新加载前端并查看更改。</p>
<h3>Translate button text</h3>
<p>为了翻译按钮文本，让我们用<code>t</code>函数替换<code>component/Footer.js</code>文件中的文本:</p>
<pre>&lt;button onClick={onChange}&gt;{t("click")}&lt;/button&gt;
</pre>
<p>然后，更新翻译文件以包含键值对。</p>
<p>在<code>en/translation.json</code>文件中，添加:</p>
<pre>"click": "Click here"
</pre>
<p>在<code>ar/translation.json</code>文件中，添加:</p>
<pre>"click": "انقر هنا"
</pre>
<p>使用谷歌翻译更新其他翻译文件。</p>
<h3>翻译菜单项</h3>
<p>要翻译菜单项，首先将其添加到<code>en/translation.json</code>文件中:</p>
<pre>"menu" : {
  "aboutProject" : "About the project",
  "contactUs": "Contact us" 
}
</pre>
<p>然后，将其添加到<code>ar/translation.json</code>文件:</p>
<pre>"menu" : {
  "aboutProject" : "حول المشروع",
  "contactUs": "اتصل بنا" 
}
</pre>
<p>同样，使用谷歌翻译更新其他翻译文件并保存它们。</p>
<p>接下来，打开<code>components/Header.js</code>文件并导入顶部的<code>useTranslation</code>:</p>
<pre>import { useTranslation } from "react-i18next";
</pre>
<p>然后，使用<code>t</code>功能翻译菜单标题:</p>
<pre>import { useTranslation } from "react-i18next";

const Header = () =&gt; {
  const { t } = useTranslation();
  const menu = [
    {
      title: t("menu.aboutProject"),
      // ...
    },
    {
      title: t("menu.contactUs"),
      // ...
    },
  ];

  return (
    // ...
  );
};

// ...
</pre>
<p>如果我们保存文件并重新加载前端，我们将看到菜单项和所有页面内容被正确翻译。</p>
<p><img data-attachment-id="56934" data-permalink="https://blog.logrocket.com/react-localization-with-i18next/translate-menu-items-arabic/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2021/06/Translate-Menu-items-Arabic.png" data-orig-size="730,348" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Translate menu items Arabic" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2021/06/Translate-Menu-items-Arabic-300x143.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2021/06/Translate-Menu-items-Arabic.png" decoding="async" class="aligncenter size-full wp-image-56934 jetpack-lazy-image" src="../Images/abd9086a31aa35919c8360233a093679.png" alt="Translate Menu Items Into Arabic In Frontend" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2021/06/Translate-Menu-items-Arabic.png 730w, https://blog.logrocket.com/wp-content/uploads/2021/06/Translate-Menu-items-Arabic-300x143.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2021/06/Translate-Menu-items-Arabic.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2021/06/Translate-Menu-items-Arabic.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="56934" data-permalink="https://blog.logrocket.com/react-localization-with-i18next/translate-menu-items-arabic/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2021/06/Translate-Menu-items-Arabic.png" data-orig-size="730,348" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Translate menu items Arabic" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2021/06/Translate-Menu-items-Arabic-300x143.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2021/06/Translate-Menu-items-Arabic.png" decoding="async" loading="lazy" class="aligncenter size-full wp-image-56934" src="../Images/abd9086a31aa35919c8360233a093679.png" alt="Translate Menu Items Into Arabic In Frontend" srcset="https://blog.logrocket.com/wp-content/uploads/2021/06/Translate-Menu-items-Arabic.png 730w, https://blog.logrocket.com/wp-content/uploads/2021/06/Translate-Menu-items-Arabic-300x143.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2021/06/Translate-Menu-items-Arabic.png"/></noscript>
<h2>检测用户的语言</h2>
<p>我们必须为用户提供一个在前端切换语言的选项，同时将选定的语言环境保存在浏览器存储中。这使得内容能够在后续访问中以首选语言显示。</p>
<p>i18next 为此提供了一个插件，所以让我们使用以下命令来安装它:</p>
<pre>npm install i18next-browser-languagedetector
</pre>
<p>安装后，将插件导入并添加到配置文件中:</p>
<pre>// ...
import LanguageDetector from "i18next-browser-languagedetector";

i18n
  // ...
  .use(LanguageDetector)
  .init({
    fallbackLng: "en",
    detection: {
      order: ["path", "localStorage", "htmlTag", "cookie"],
      caches: ["localStorage", "cookie"], // cache user language on
    },
    interpolation: {
      // ...
    },
  });

export default i18n;
</pre>
<p>在设置中，我们移除了<code>lng</code>属性，因为应用程序现在依赖插件来检测当前语言。在<code>detection</code>属性中，我们已经指定了检测用户语言的顺序。</p>
<p>订单中的第一项具有最高优先级，并按该顺序递减。这意味着插件首先检查<code>path</code>，然后是<code>localStorage</code>，依此类推。</p>
<p>现在，我们可以从 URL 路径<a href="http://localhost:3000/ar"> http://localhost:3000/ar </a>访问区域设置内容。</p>
<p>我们必须将<code>path</code>指定为数组中的第一项，以通过路径访问区域设置内容。但是，请注意，仍然会从其他指定的存储中检测到用户的区域设置。</p>
<p>保存文件并重新加载前端；通过将一个区域设置传递给 URL 路径<a href="http://localhost:3000/ar">http://localhost:3000/</a>ar 来测试项目。</p>
<h2>创建语言切换器</h2>
<p>要创建语言切换器，首先打开<code>components/Header.js</code>文件并在<code>return</code>语句上方添加支持的语言:</p>
<pre>// Languages
const languages = [
  { name: "English", code: "en" },
  { name: "日本語", code: "ja" },
  { name: "Français", code: "fr" },
  { name: "العربية", code: "ar" },
];
</pre>
<p>接下来，在 JSX 中找到这个元素:</p>
<pre>&lt;div className="switcher"&gt;
  {/* Language switch dropdown here */}
&lt;/div&gt;
</pre>
<p>更新它，这样我们就有了以下内容:</p>
<pre>&lt;div className="switcher"&gt;
  {/* Language switch dropdown here */}
  &lt;span&gt;Languages&lt;/span&gt;{" "}
  &lt;select&gt;
    {languages.map(({ name, code }) =&gt; (
      &lt;option key={code} value={code}&gt;
        {name}
      &lt;/option&gt;
    ))}
  &lt;/select&gt;
&lt;/div&gt;
</pre>
<p>保存文件。代码应该是不言自明的，因为它是<a href="https://ibaslogic.com/react-tutorial-for-beginners/">基本反应</a>。</p>
<p>切换器现在应该显示在前端，虽然它还没有工作。我们需要让下拉元素成为一个<a href="https://blog.logrocket.com/forms-in-react-in-2020/">受控组件</a>。</p>
<p>我们需要做的就是将一个<code>value</code>道具和<code>onChange</code>传递给<code>select</code>元素:</p>
<pre>&lt;select onChange="" value=""&gt;
  {/* ... */}
&lt;/select&gt;
</pre>
<p>当<code>onChange</code>触发一个更新语言环境的函数时，<code>value</code>属性获取当前的语言环境。</p>
<p>我们可以通过安装一个名为<code>js-cookie</code>的包从存储器中获取当前的区域设置值。这允许我们从 cookie 中获取区域设置字符串:</p>
<pre>npm install js-cookie
</pre>
<p>接下来，在<code>Header.js</code>文件的顶部导入<code>Cookies</code>对象:</p>
<pre>import Cookies from "js-cookie";
</pre>
<p>然后，在<code>return</code>语句上方添加以下代码:</p>
<pre>const currentLocale = Cookies.get("i18next") || "en";
</pre>
<p>这个包使用<code>get()</code>方法从存储器中读取一个 cookie，并接受 cookie 的名称。</p>
<p>对于 i18next 框架，cookie 名称是<code>i18next</code>。我们可以在浏览器 devtools 的存储 cookies 中找到这个名字。</p>
<p>接下来，定义一个状态，该状态接受当前的区域设置并将其分配给 dropdown 元素的<code>value</code>属性。</p>
<p>仍然在<code>Header.js</code>文件中，导入文件顶部的<code>useState</code>:</p>
<pre>import { useState } from "react";
</pre>
<p>然后，定义一个<code>language</code>变量，并通过<code>useState</code>钩子传入当前区域设置。</p>
<p>在<code>return</code>语句上方添加以下内容:</p>
<pre>const [language, setLanguage] = useState(currentLocale);
</pre>
<p>既然<code>language</code>已经有了当前的区域设置，我们可以将它传递给<code>value</code>属性:</p>
<pre>&lt;select onChange={handleChangeLocale} value={language}&gt;
  {/* ... */}
&lt;/select&gt;
</pre>
<p>注意，我们还添加了<code>handleChangeLocale</code>处理程序来触发更新。</p>
<p>让我们快速创建它。在<code>return</code>语句上方添加以下代码:</p>
<pre>const handleChangeLocale = (e) =&gt; {
  const lang = e.target.value;
  setLanguage(lang);
};
</pre>
<p>代码根据用户的选择更新语言下拉列表。我们必须更进一步，更新应用程序语言。</p>
<p>如前所述，需要使用<code>i18n</code>实例来更改语言。现在，我们可以用它来抓取<code>changeLanguage()</code> API 来接受用户选择的语言。</p>
<p>像<code>t</code>函数一样，我们也可以从<code>useTranslation()</code>钩子访问<code>i18n</code>实例。</p>
<p>因此，更新钩子以包含<code>i18n</code>:</p>
<pre>const { t, i18n } = useTranslation();
</pre>
<p>然后，在<code>handleChangeLocale</code>处理器中使用它:</p>
<pre>const handleChangeLocale = (e) =&gt; {
  const lang = e.target.value;
  setLanguage(lang);
  i18n.changeLanguage(lang);
};
</pre>
<p>保存并测试应用程序。</p>
<h2>从右向左呈现阿拉伯语内容</h2>
<p>如果我们临时打开浏览器 devtools 并向<code>body</code>元素添加一个<code>dir="rtl"</code>，我们将看到内容从右向左显示。在我们的应用程序中，我们需要定位<code>body</code>元素，并在页面加载时添加<code>dir</code>属性。</p>
<p>更新<code>languages</code>数组中的阿拉伯语，将它的方向包含在<code>components/Header.js</code>文件中:</p>
<pre>const languages = [
  // ...
  { name: "العربية", code: "ar", dir: "rtl" },
];
</pre>
<p>之后，在<code>return</code>语句上方添加以下代码:</p>
<pre>const currentLangObj = languages.find((lang) =&gt; lang.code === currentLocale);

useEffect(() =&gt; {
  document.body.dir = currentLangObj.dir || 'ltr'
}, [currentLangObj])
</pre>
<p><a href="https://blog.logrocket.com/lifecycle-methods-with-the-useeffect-hook/">导入文件顶部的<code>useEffect</code> <br/>勾</a>:</p>
<pre>import { useState, useEffect } from "react";
</pre>
<p><code>find()</code>方法允许我们获取所选地区的语言对象。在这个对象中，我们可以访问阿拉伯语方向，当页面加载时，我们将它分配给<code>body.dir</code>属性。</p>
<h2>翻译应用程序标题</h2>
<p>在这里，我们将为我们的应用标题和下拉列表旁边的<strong>语言</strong>文本添加翻译。</p>
<p>在<code>en/translation.json</code>中，添加:</p>
<pre>{
  ...
  "app_title": "React-i18next tutorial",
  "languages": "Languages"  
}
</pre>
<p>为其他支持的语言环境添加翻译并保存所有文件。</p>
<p>回到<code>components/Header.js</code>文件，更新<code>useEffect</code>以包含应用标题的翻译功能:</p>
<pre>useEffect(() =&gt; {
  document.body.dir = currentLangObj.dir || "ltr";
  document.title = t("app_title");
}, [currentLangObj, t]);
</pre>
<p>最后，在 JSX 中找到这个元素:</p>
<pre>&lt;span&gt;Languages&lt;/span&gt;
</pre>
<p>用翻译功能替换它:</p>
<pre>&lt;span&gt;{t('languages')}&lt;/span&gt;
</pre>
<p>保存文件并测试应用程序。一切都应该按预期运行。</p>
<p>恭喜你！我们完了！</p>
<h2>结论</h2>
<p>我很高兴你在这里。关于在 React 应用程序中使用 i18next 框架，您已经学到了很多。我们几乎涵盖了利用 i18next 所需的所有用例。现在，您知道了如何使用它来本地化 React 应用程序。</p>
<p>如果你喜欢这个指南，请在网上分享。如果你有任何问题或贡献，请通过评论区告诉我。</p>
<p>你可以在这个 GitHub 库中看到<a href="https://github.com/Ibaslogic/react_i18next_project">完整的 i18next 项目源代码。</a></p><div class="code-block code-block-17">
<div class="blog-plug inline-plug react-plug" vwo-el-id="26283398190">
<h2 vwo-el-id="41600691720">使用 LogRocket 消除传统反应错误报告的噪音</h2>
<a href="https://lp.logrocket.com/blg/react-signup-issue-free" target="_blank" vwo-el-id="19356441070">LogRocket
</a><p>是一款 React analytics 解决方案，可保护您免受数百个误报错误警报的影响，只针对少数真正重要的项目。LogRocket 告诉您 React 应用程序中实际影响用户的最具影响力的 bug 和 UX 问题。</p><a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="19356441380">
<img class="first-react-image alignnone size-full wp-image-46 jetpack-lazy-image jetpack-lazy-image--handled" src="../Images/f300c244a1a1cf916df8b4cb02bec6c6.png" vwo-el-id="18272717540" data-lazy-loaded="1" data-original-src="https://files.readme.io/27c94e7-Image_2017-06-05_at_9.46.04_PM.png"/>
</a>
<a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="19356441690">
<img class="second-react-image alignnone size-full wp-image-46 jetpack-lazy-image jetpack-lazy-image--handled" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" vwo-el-id="30720362350" data-lazy-loaded="1" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/>
</a>
<a href="https://lp.logrocket.com/blg/react-signup-issue-free" target="_blank" rel="noopener noreferrer" vwo-el-id="35866400580">LogRocket
</a><p>自动聚合客户端错误、反应错误边界、还原状态、缓慢的组件加载时间、JS 异常、前端性能指标和用户交互。然后，LogRocket 使用机器学习来通知您影响大多数用户的最具影响力的问题，并提供您修复它所需的上下文。</p><p vwo-el-id="28675661060">关注重要的 React bug—<a class="signup" href="https://lp.logrocket.com/blg/react-signup-issue-free" target="_blank" rel="noopener noreferrer" vwo-el-id="40093418840">今天就试试 LogRocket】。</a></p>
</div></div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
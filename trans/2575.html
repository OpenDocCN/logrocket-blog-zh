<html>
<head>
<title>Creating interactive backgrounds in React with tsParticles - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>在与粒子反应中创建交互式背景</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/creating-interactive-backgrounds-react-tsparticles/#0001-01-01">https://blog.logrocket.com/creating-interactive-backgrounds-react-tsparticles/#0001-01-01</a></blockquote><div><article class="article-post">
<p>从<a href="https://threejs-journey.com/" target="_blank" rel="noopener"> 3D 插图</a>到<a href="https://nova.app/" target="_blank" rel="noopener">动画背景</a>和<a href="https://www.apple.com/macbook-pro/" target="_blank" rel="noopener">基于滚动的故事讲述</a>——如果你想在网络上脱颖而出，互动内容是必不可少的解决方案。虽然它确实需要更多的时间和经验来很好地实现，但结果可能真的令人震惊。</p>
<p>也就是说，在这篇文章中，我想向你展示一个在你的网站上实现交互式背景的捷径，只需要一点点努力。这个快捷方式就是<a href="https://particles.js.org/" target="_blank" rel="noopener">ts particles</a>——一个帮助你创建交互式粒子背景的库。在它的帮助下，您将能够立即创建令人惊叹的视觉效果！</p>
<p><img data-attachment-id="86719" data-permalink="https://blog.logrocket.com/creating-interactive-backgrounds-react-tsparticles/tsparticles-landing-page/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/01/tsparticles-landing-page.png" data-orig-size="730,456" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="tsparticles-landing-page" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/01/tsparticles-landing-page-300x187.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/01/tsparticles-landing-page.png" decoding="async" class="aligncenter size-full wp-image-86719 jetpack-lazy-image" src="../Images/eef497f77664a2fb9de36c707a4a7e59.png" alt="The tsParticles landing page" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2022/01/tsparticles-landing-page.png 730w, https://blog.logrocket.com/wp-content/uploads/2022/01/tsparticles-landing-page-300x187.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2022/01/tsparticles-landing-page.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/01/tsparticles-landing-page.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="86719" data-permalink="https://blog.logrocket.com/creating-interactive-backgrounds-react-tsparticles/tsparticles-landing-page/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/01/tsparticles-landing-page.png" data-orig-size="730,456" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="tsparticles-landing-page" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/01/tsparticles-landing-page-300x187.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/01/tsparticles-landing-page.png" decoding="async" loading="lazy" class="aligncenter size-full wp-image-86719" src="../Images/eef497f77664a2fb9de36c707a4a7e59.png" alt="The tsParticles landing page" srcset="https://blog.logrocket.com/wp-content/uploads/2022/01/tsparticles-landing-page.png 730w, https://blog.logrocket.com/wp-content/uploads/2022/01/tsparticles-landing-page-300x187.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/01/tsparticles-landing-page.png"/></noscript>
<h2>什么是粒子</h2>
<p>tsParticles 是<a href="https://vincentgarreau.com/particles.js/" target="_blank" rel="noopener"> particles.js </a>的精神继承者，后者是一个功能相似的老库。这些改进包括 TypeScript 的使用、与领先框架的第一方集成以及一些新特性。除此之外，该库向后兼容 particles.js —所有配置选项都是相同的。</p>
<p>该库使用 HTML Canvas 来创建比屏幕上浮动的点更高级的背景，一些示例包括用于底层图像的粒子遮罩，以产生良好的显示效果，或者用于在矢量形状内组织粒子的多边形遮罩。您还可以为粒子使用自定义图形，应用自定义动画，管理由不同用户操作触发的效果，等等！</p>
<p>总的来说，尽管只使用了一个 config 对象，这个库的通用性和可配置性令人难以置信。此外，TypeScript 类型和专用集成不仅适用于 React、Vue 和 Angular，还适用于像 Svelte 和 Solid 这样的框架，这是一种很好的开发体验。</p>
<h2>创建交互式背景</h2>
<p>为了展示如何使用粒子，我们将探索一些独特的，互动的背景。这应该让您很好地了解什么是可能的，并让您了解一些配置选项。</p>
<h3>设置</h3>
<p>在这个演示中，我们将使用 React 和官方的<a href="https://github.com/matteobruni/tsparticles/tree/main/components/react" target="_blank" rel="noopener">ts 粒子 React 组件</a>。下面的命令设置一个 React Vite 模板，安装必要的依赖项，并运行开发服务器，这样您只需几秒钟就可以开始工作了。</p>
<pre class="language-bash hljs">npm init <a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="05736c716045696471607671">[email protected]</a> backgrounds --template react-ts
cd backgrounds
npm install react-tsparticles
npm run dev
</pre>
<p>要开始使用 tsParticles，请导入并渲染<code>src/app.tsx</code>文件中的<code>Particles</code>组件。</p>
<pre class="language-javascript hljs">import Particles, { ISourceOptions } from "react-tsparticles";

const App = () =&gt; {
  const options: ISourceOptions = {
    // ...
  };

  return &lt;Particles options={options} /&gt;;
};

export default App;
</pre>
<p>该组件接受几个道具——其中最重要的是<code>options</code>,因为它负责配置粒子视觉效果的几乎所有方面。<a href="https://github.com/matteobruni/tsparticles/tree/main/components/react#props%5C" target="_blank" rel="noopener">其他道具</a>配置画布或包装元素，提供对 tsParticles 实例的访问以进行额外的控制，等等。</p>
<h3>配置选项</h3>
<p>关注选项，让我们使用它们来创建我们的第一个交互背景。</p>
<pre class="language-css hljs">// ...
const options: ISourceOptions = {
  background: {
    color: "#0d47a1",
  },
  interactivity: {
    events: {
      onClick: {
        enable: true,
        mode: "push",
      },
      onHover: {
        enable: true,
        mode: "repulse",
      },
      resize: true,
    },
    modes: {
      bubble: {
        distance: 400,
        duration: 2,
        opacity: 0.8,
        size: 40,
      },
      push: {
        quantity: 4,
      },
      repulse: {
        distance: 200,
        duration: 0.4,
      },
    },
  },
  particles: {
    color: {
      value: "#ffffff",
    },
    links: {
      color: "#ffffff",
      distance: 150,
      enable: true,
      opacity: 0.5,
      width: 1,
    },
    collisions: {
      enable: true,
    },
    move: {
      direction: "none",
      enable: true,
      outMode: "bounce",
      random: false,
      speed: 6,
      straight: false,
    },
    number: {
      density: {
        enable: true,
        value_area: 800,
      },
      value: 80,
    },
    opacity: {
      value: 0.5,
    },
    shape: {
      type: "circle",
    },
    size: {
      random: true,
      value: 5,
    },
  },
};
// ...
</pre>
<p>上述配置以互连点的形式创建了最容易识别的基于粒子的背景之一:</p>
<p class="codepen" data-height="300" data-theme-id="dark" data-default-tab="css,result" data-slug-hash="yLzRmOx" data-user="areknawo">见<a href="https://codepen.io"> CodePen </a>上阿雷克·纳沃(<a href="https://codepen.io/areknawo">@阿雷克那沃</a> ) <br/>的笔<a href="https://codepen.io/areknawo/pen/yLzRmOx"> <br/> tsParticles 浮游粒子</a>。</p>
<p/>
<p>配置 tsParticles 相对简单，由于 TypeScript 类型化，您不必记忆或阅读文档来了解所有选项。<br/>以下是一些帮助您入门的选项的详细信息:</p>
<ul>
<li><code>background</code>配置粒子后面的一切。您可以使用各种格式的纯色(十六进制、RGB、HSL 等。)、图像、不同的不透明度等等</li>
<li><code>interactivity</code>控制当用户点击或悬停在背景上时会发生什么</li>
<li><code>events</code>定义如何处理选定的事件</li>
<li><code>modes</code>配置用于事件处理的动作</li>
<li><code>particles</code>对控制粒子和相关视觉效果显示方式的所有属性进行分组。从这里，您可以配置一切，从粒子的颜色和运动行为，到它们之间的连接线</li>
</ul>
<p>tsParticles 提供了更多的选项，所有这些都可以通过 TypeScript 支持的自动完成或官方文档来探索。</p>
<h2>创造五彩纸屑的效果</h2>
<p>现在我们对粒子的工作原理有了基本的了解，让我们来创造一些更有趣的东西。我们将实现一个五彩纸屑效果，类似于你可以在苹果 iMessages 中发送的内容。</p>
<p>我们将使用粒子发射器来实现五彩纸屑从一个点爆炸的效果，而不仅仅是粒子四处漂浮。让我们使用下面的配置创建一个。</p>
<pre class="language-css hljs">// ...
const options: ISourceOptions = {
  fullScreen: true,
  fpsLimit: 60,
  detectRetina: true,
  emitters: {
    startCount: 0,
    position: { x: 50, y: 50 },
    size: {
      width: 0,
      height: 0,
    },
    rate: {
      delay: 0,
      quantity: 10,
    },
    life: {
      duration: 0,
      count: 1,
    },
  },
};
// ...
</pre>
<p>使用上述<code>emitters</code>部分的参数，我们在全屏画布的正中央创建一个不可见的发射器。<code>life</code>对象指定在无限长的时间内只有一个发射器。此外，根据<code>rate</code>对象的值，发射器将无延迟地发射十个粒子。</p>
<p>有了这样的设置，剩下要做的就是指定发射粒子的外观和行为。为此，在<code>particles</code>部分设置以下选项。</p>
<pre class="language-css hljs">// ...
const options: ISourceOptions = {
  // ...
  emitters: {
    // ...
  },
  particles: {
    number: {
      value: 0,
    },
    color: {
      value: ["#FF5A86", "#953AFE", "#FFC326", "#46C0FF"],
    },
    shape: {
      type: ["square", "circle"],
    },
    opacity: {
      value: 1,
      animation: {
        enable: true,
        minimumValue: 0,
        speed: 0.5,
        startValue: "max",
        destroy: "min",
      },
    },
    size: {
      value: 5,
    },
    links: {
      enable: false,
    },
    life: {
      duration: {
        sync: true,
        value: 3,
      },
      count: 1,
    },
    move: {
      angle: {
        value: 45,
        offset: 0,
      },
      drift: {
        min: -0,
        max: 0,
      },
      enable: true,
      gravity: {
        enable: true,
        acceleration: 20,
      },
      speed: 90,
      decay: 1 - 0.9,
      direction: -90,
      random: true,
      straight: false,
      outModes: {
        default: "none",
        bottom: "destroy",
      },
    },
    rotate: {
      value: {
        min: 0,
        max: 360,
      },
      direction: "random",
      animation: {
        enable: true,
        speed: 60,
      },
    },
    tilt: {
      direction: "random",
      enable: true,
      value: {
        min: 0,
        max: 360,
      },
      animation: {
        enable: true,
        speed: 60,
      },
    },
    roll: {
      darken: {
        enable: true,
        value: 25,
      },
      enable: true,
      speed: {
        min: 15,
        max: 25,
      },
    },
    wobble: {
      distance: 20,
      enable: true,
      speed: {
        min: -15,
        max: 15,
      },
    },
  },
};
// ...
</pre>
<p>一般来说，上述配置使粒子模仿五彩纸屑。它们有不同的颜色、形状，可以移动、旋转、倾斜等等。这里最重要的选项是:</p>
<ul>
<li><code>number.value</code>，控制漂浮颗粒的数量(应为<code>0</code>)</li>
<li><code>move.gravity</code>，这产生了一个将粒子拉下来的力</li>
</ul>
<p>下面是最终结果:</p>
<p class="codepen" data-height="300" data-theme-id="dark" data-default-tab="css,result" data-slug-hash="jOGeMXR" data-user="areknawo">请看<a href="https://codepen.io"> CodePen </a>上阿莱克·纳沃(<a href="https://codepen.io/areknawo">@阿莱克纳沃</a> ) <br/>的笔<a href="https://codepen.io/areknawo/pen/jOGeMXR"> <br/> tsParticles 五彩纸屑</a>。</p>
<p>事先调整</p>
<h3>正如你所看到的，粒子的结构变得非常复杂。为了解决这个问题，有一个预置的功能，这样你就可以共享和重用它们。</h3>
<p>您还可以使用任何官方或社区预设，并在其上应用您的自定义选项，以更快地实现您想要的效果。</p>
<p>为了向您展示如何使用预设，我们将使用海葵预设，它从画布的中心产生触手状的粒子。</p>
<p>首先，从 npm 安装<a href="https://www.npmjs.com/package/tsparticles-preset-sea-anemone" target="_blank" rel="noopener">预置包</a>:</p>
<p>要加载预设，您需要访问 tsParticles 实例。为此，使用<code>init</code>属性设置在初始化 tsParticles 时使用的回调函数。回调将接收所述实例作为参数。</p>
<pre class="language-bash hljs">npm install tsparticles-preset-sea-anemone
</pre>
<p>在选项中，确保通过名称指定<code>preset</code>,并包含您想要定制的任何其他属性。默认情况下，预设会产生以下效果:</p>
<pre class="language-javascript hljs">import Particles, { ISourceOptions, Main } from "react-tsparticles";
import { loadSeaAnemonePreset } from "tsparticles-preset-sea-anemone";

const App = () =&gt; {
  const options: ISourceOptions = {
    preset: "seaAnemone",
  };
  const initialize = (instance: Main) =&gt; {
    loadSeaAnemonePreset(instance);
  };

  return &lt;Particles options={options} init={initialize} /&gt;;
};

export default App;
</pre>
<p>参见<a href="https://codepen.io"> CodePen </a>上阿雷克·纳沃(<a href="https://codepen.io/areknawo">@阿雷克那沃</a> ) <br/>的笔<a href="https://codepen.io/areknawo/pen/vYeVoYL"> <br/> tsParticles 海葵预置</a>。</p>
<p class="codepen" data-height="300" data-theme-id="dark" data-default-tab="css,result" data-slug-hash="vYeVoYL" data-user="areknawo">See the Pen <a href="https://codepen.io/areknawo/pen/vYeVoYL"><br/>
tsParticles Sea Anemone Preset</a> by Arek Nawo (<a href="https://codepen.io/areknawo">@areknawo</a>)<br/>
on <a href="https://codepen.io">CodePen</a>.</p>
<p>正如我们之前提到的，tsParticles 还允许您定义自己的预设。为此，只需定义预设选项并创建一个加载函数，该函数接受您的 tsParticles 实例作为参数。在函数内部，使用实例的<code>addPreset</code>方法注册预置，传递您的自定义名称和定义的选项。</p>
<p>使用这样的预置和使用第三方的一模一样。</p>
<pre class="language-javascript hljs">// ...
const options: ISourceOptions = {
  // preset options
};
const loadCustomPreset = (main: Main) =&gt; {
  main.addPreset("customPreset", options);
};
</pre>
<p>其他自定义</p>
<pre class="language-javascript hljs">// ...

const App = () =&gt; {
  const options: ISourceOptions = {
    preset: "customPreset",
  };
  const initialize = (instance: Main) =&gt; {
    loadCustomPreset(instance);
  };

  return &lt;Particles options={options} init={initialize} /&gt;;
};
</pre>
<h3>最重要的是，tsParticles 允许通过插件和高级配置选项进行更高级的定制。</h3>
<p>插件与预设非常相似——它是一个接受粒子实例并使用一种可用方法改变它的函数。除了用<code>addPreset</code>定义预设，你还可以用<code>addShape</code>添加自定义粒子形状，或者用<code>addInteractor</code>进行自定义交互。</p>
<p>为了给你一个创建你自己的插件是多么容易的例子，让我们创建一个给粒子添加六边形的插件。</p>
<p>更多来自 LogRocket 的精彩文章:</p><div class="code-block code-block-54">
<hr/>
<h3>该形状是使用 HTML Canvas 上下文和提供的粒子配置绘制的，类似于我们的五彩纸屑演示中的样子。</h3>

<hr/></div>
<pre class="language-javascript hljs">const loadHexagonShape = (main: Main) =&gt; {
  main.addShape("hexagon", (context, particle, radius) =&gt; {
    const angle = (2 * Math.PI) / 6;

    context.beginPath();
    for (let i = 0; i &lt; 6; i++) {
      context.lineTo(
        radius * Math.cos(angle * i),
        radius * Math.sin(angle * i)
      );
    }
    context.closePath();
    context.stroke();
  });
};
</pre>
<p>请看<a href="https://codepen.io"> CodePen </a>上阿雷克·纳沃(<a href="https://codepen.io/areknawo">@阿雷克那沃</a> ) <br/>的笔<a href="https://codepen.io/areknawo/pen/zYEmVqR"> <br/> tsParticles 五彩六边形纸屑</a>。</p>
<p class="codepen" data-height="300" data-theme-id="dark" data-default-tab="css,result" data-slug-hash="zYEmVqR" data-user="areknawo">See the Pen <a href="https://codepen.io/areknawo/pen/zYEmVqR"><br/>
tsParticles Colorful Hexagon Confetti</a> by Arek Nawo (<a href="https://codepen.io/areknawo">@areknawo</a>)<br/>
on <a href="https://codepen.io">CodePen</a>.</p>
<p>除了插件，还有许多高级配置选项可以帮助你达到想要的效果。五彩纸屑演示中使用的<code>emitters</code>属性就是其中之一，还有很多！值得注意的例子包括用于指定粒子应该覆盖什么矢量形状的<code>polygon</code>属性，以及用于创建发射器的反面的<code>absorbers</code>属性——一个吸收附近粒子的类似黑洞的实体。</p>
<p>在您的配置中添加以下位，以在特定位置创建一个吸收器，当它吸收更多的粒子时，它的大小会增长(达到某个极限)。</p>
<p>下面是我们将它应用于五彩纸屑演示时的情况。</p>
<pre class="language-javascript hljs">// ...
const options: ISourceOptions = {
  // ...
  absorbers: {
    color: "#ffffff",
    position: { x: 70, y: 50 },
    size: {
      value: 50,
      limit: 150
    }
  }
  // ...
};
// ...
</pre>
<p>请看<a href="https://codepen.io"> CodePen </a>上阿莱克·纳沃(<a href="https://codepen.io/areknawo">@阿莱克纳沃</a> ) <br/>的笔<a href="https://codepen.io/areknawo/pen/zYEmVqR"> <br/> tsParticles 五彩六边形纸屑</a>。</p>
<p class="codepen" data-height="300" data-theme-id="dark" data-default-tab="css,result" data-slug-hash="zYEmVqR" data-user="areknawo">See the Pen <a href="https://codepen.io/areknawo/pen/zYEmVqR"><br/>
tsParticles Colorful Hexagon Confetti</a> by Arek Nawo (<a href="https://codepen.io/areknawo">@areknawo</a>)<br/>
on <a href="https://codepen.io">CodePen</a>.</p>
<p>总的来说，这个库肯定有很多定制的可能性。正因为如此，当人们试图达到某种特定的效果时，很容易迷失方向。在这种情况下，我建议查看库作者的<a href="https://codepen.io/collection/DPOage" target="_blank" rel="noopener"> CodePen 集合</a>，其中包含了各种可以使用并从中获取灵感的配置。以下是我最喜欢的几个:</p>
<p>参见<a href="https://codepen.io"> CodePen </a>上 Matteo Bruni(<a href="https://codepen.io/matteobruni">@ matteobruni</a>)<br/>的 Pen <a href="https://codepen.io/matteobruni/pen/MWaePMa"> <br/> tsParticles 多路径多边形遮罩</a>。</p>
<p class="codepen" data-height="300" data-theme-id="dark" data-default-tab="css,result" data-slug-hash="MWaePMa" data-user="matteobruni">See the Pen <a href="https://codepen.io/matteobruni/pen/MWaePMa"><br/>
tsParticles polygon mask with multiple paths</a> by Matteo Bruni (<a href="https://codepen.io/matteobruni">@matteobruni</a>)<br/>
on <a href="https://codepen.io">CodePen</a>.</p>
<p>见<a href="https://codepen.io"> CodePen </a>上 Matteo Bruni(<a href="https://codepen.io/matteobruni">@ matteobruni</a>)<br/>的笔<a href="https://codepen.io/matteobruni/pen/yLNpgKW"> <br/> tsParticles 多边形遮罩</a>。</p>
<p class="codepen" data-height="300" data-theme-id="dark" data-default-tab="css,result" data-slug-hash="yLNpgKW" data-user="matteobruni">See the Pen <a href="https://codepen.io/matteobruni/pen/yLNpgKW"><br/>
tsParticles Polygon Mask</a> by Matteo Bruni (<a href="https://codepen.io/matteobruni">@matteobruni</a>)<br/>
on <a href="https://codepen.io">CodePen</a>.</p>
<p>参见 Matteo Bruni(<a href="https://codepen.io/matteobruni">@ matteobruni</a>)<br/>上<a href="https://codepen.io"> CodePen </a>的 Pen <a href="https://codepen.io/matteobruni/pen/MWKaRYy"> <br/> tsParticles 外置柏林噪声发生器</a>。</p>
<p class="codepen" data-height="300" data-theme-id="dark" data-default-tab="css,result" data-slug-hash="MWKaRYy" data-user="matteobruni">结论</p>
<p>所以，如你所见，粒子库的可能性几乎是无限的。可以肯定地说，你可以定制这个库的几乎所有方面。然而，最好的一点是它是渐进的——你可以根据自己的需要定制，而库将永远支持你。</p>
<h2>有了 tsParticles 这样的库，给你自己的网站带来互动的视觉效果变得前所未有的简单。现在轮到你好好利用它，创造一些特别的东西了！</h2>
<p><a href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener"> LogRocket </a>:全面了解您的生产 React 应用</p>
<p>调试 React 应用程序可能很困难，尤其是当用户遇到难以重现的问题时。如果您对监视和跟踪 Redux 状态、自动显示 JavaScript 错误以及跟踪缓慢的网络请求和组件加载时间感兴趣，</p><div class="code-block code-block-17">
<div class="blog-plug inline-plug react-plug" vwo-el-id="26283398190">
<h2 vwo-el-id="41600691720">. </h2><p>LogRocket 结合了会话回放、产品分析和错误跟踪，使软件团队能够创建理想的 web 和移动产品体验。这对你来说意味着什么？</p><a href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" vwo-el-id="19356441070">try LogRocket</a><p>LogRocket 不是猜测错误发生的原因，也不是要求用户提供截图和日志转储，而是让您回放问题，就像它们发生在您自己的浏览器中一样，以快速了解哪里出错了。</p><a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="19356441380">
<img class="first-react-image alignnone size-full wp-image-46 jetpack-lazy-image jetpack-lazy-image--handled" src="../Images/f300c244a1a1cf916df8b4cb02bec6c6.png" vwo-el-id="18272717540" data-lazy-loaded="1" data-original-src="https://files.readme.io/27c94e7-Image_2017-06-05_at_9.46.04_PM.png"/>
</a>
<a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="19356441690">
<img class="second-react-image alignnone size-full wp-image-46 jetpack-lazy-image jetpack-lazy-image--handled" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" vwo-el-id="30720362350" data-lazy-loaded="1" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/>
</a>
<p vwo-el-id="28675660440" class="">不再有嘈杂的警报。智能错误跟踪允许您对问题进行分类，然后从中学习。获得有影响的用户问题的通知，而不是误报。警报越少，有用的信号越多。</p>
<p>LogRocket Redux 中间件包为您的用户会话增加了一层额外的可见性。LogRocket 记录 Redux 存储中的所有操作和状态。</p>
<p>现代化您调试 React 应用的方式— <a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="40093418840">开始免费监控</a>。</p>
<p vwo-el-id="28675660750">The LogRocket Redux middleware package adds an extra layer of visibility into your user sessions. LogRocket logs all actions and state from your Redux stores.
</p>
<p vwo-el-id="28675661060">Modernize how you debug your React apps —
<a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="40093418840">start monitoring for free</a>.
</p>
</div></div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
# gqlgen:构建更快的 GraphQL 服务器- LogRocket 博客

> 原文：<https://blog.logrocket.com/gqlgen-build-faster-graphql-server/>

GraphQL 是一种查询语言和运行时，由脸书创建，作为使用 REST APIs 的替代方案。Go 是一种较低级的编译编程语言，由 Google 创建，在创建快速运行的 API 方面非常流行。

在编写 API 时，GraphQL 和 Go 各有独特的优势。在本文中，我们将探索 [gqlgen](https://gqlgen.com/getting-started/) ，它结合了两种技术的优点，帮助您使用 Go 轻松编写 GraphQL APIs。

首先，我们将研究使用 gqlgen 这样的工具的优势，包括 GraphQL 和 Go 的有益特性。然后，我们将学习如何通过构建一个简单的待办事项列表应用程序来开始使用 gqlgen。我们开始吧！

## GraphQL 和 Go 的内部工作方式

在 GraphQL 中，不是用不同的 HTTP 动词向不同的 URL 发出请求，而是将所有请求作为对单个 URL 的`POST`请求。在`POST`请求中，在主体中发送一个字符串，表示要运行什么查询或变异以及要返回什么属性。

GraphQL APIs 是自文档化的，所以当使用 GraphQL 或 GraphQL Playground 这样的[工具时，你可以很容易地看到 API 的所有细节，几乎就像 REST APIs 的 Swagger，但是内置的。](https://blog.logrocket.com/complete-guide-to-graphql-playground/)

另一方面，Go 可以提供比 JavaScript、Python 和 Ruby 等高级语言更快的性能，以及比使用 C 或 C++更简单的语法和工具链。

## gqlgen 入门

要跟随本教程，您需要安装 Go。写这篇文章的时候，我正在运行 Go v1.17.4。

打开 VS 代码或者你喜欢的 IDE 到一个空的文件夹，然后打开终端。创建新的 Go 模块。我给我的取名为`my/graphql/api`，但是你可以用任何你想用的名字:

```
go mod init my/graphql/api

```

要将 gqlgen 作为依赖项安装，请运行以下两个命令:

```
go get github.com/99designs/gqlgen

go run github.com/99designs/gqlgen init

```

上面的代码将生成以下文件结构:

```
├── go.mod
├── go.sum
├── gqlgen.yml               - For Configuration
├── graph
│   ├── generated            - The Generated Runtime
│   │   └── generated.go
│   ├── model                - For any models and database connections
│   │   └── models_gen.go
│   ├── resolver.go          - Write all your resolvers here
│   ├── schema.graphqls      - Your Schema
│   └── schema.resolvers.go  - the resolver implementation for schema.graphql
└── server.go                - The entry point to your app. Customize it however you see fit

```

## 设置我们的待办事项列表

在`schema.graphqls`中，您将看到下面的默认代码，其中包含一个示例待办事项列表:

```
# GraphQL schema example
#
# https://gqlgen.com/getting-started/

type Todo {
  id: ID!
  text: String!
  done: Boolean!
  user: User!
}

type User {
  id: ID!
  name: String!
}

type Query {
  todos: [Todo!]!
}

input NewTodo {
  text: String!
  userId: String!
}

type Mutation {
  createTodo(input: NewTodo!): Todo!
}

```

我们来分析一下。API 中的每个数据类型都应该得到如下类型注释:

```
type Todo {
  id: ID!
  text: String!
  done: Boolean!
  user: User!
}

```

感叹号表示必填字段。您还可以创建用作解析器参数的`input`类型。在 REST API 中，这些相当于控制器动作函数。一个`input`类型看起来像下面的代码，我们可以在我们的解析器类型中使用它:

```
input NewTodo {
  text: String!
  userId: String!
}

```

我们还必须声明所有的解析器，这些解析器分为两类:

*   `query`:用于获取信息，相当于 REST API `GET` routes
*   `mutations`:用于创建、更新、删除数据，相当于`REST`、`POST`和`PUT`

```
type Query {
  todos: [Todo!]!
}

type Mutation {
  createTodo(input: NewTodo!): Todo!
}

```

我们将在`Query`类型中声明所有可能的查询，变异将在`Mutation`类型中进行。本质上，`Query`和`Mutation`是两个函数签名列表。注意，我们需要以名为`input`的参数形式向`createTodo`解析器提供一个输入，它必须与`NewTodo`输入类型相匹配。

通过以这种方式定义模式，GraphQL 是自文档化的，知道当不同的请求进来时运行哪个函数。然而，我们确实需要定义解析器函数，以配合将在`schema.resolvers.go`中找到的解析器声明:

```
package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.

import (
        "context"
        "fmt"
        "my/graphql/api/graph/generated"
        "my/graphql/api/graph/model"
)

func (r *mutationResolver) CreateTodo(ctx context.Context, input model.NewTodo) (*model.Todo, error) {
        panic(fmt.Errorf("not implemented"))
}

func (r *queryResolver) Todos(ctx context.Context) ([]*model.Todo, error) {
        panic(fmt.Errorf("not implemented"))
}

// Mutation returns generated.MutationResolver implementation.
func (r *Resolver) Mutation() generated.MutationResolver { return &mutationResolver{r} }

// Query returns generated.QueryResolver implementation.
func (r *Resolver) Query() generated.QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }

```

注意，解析器函数已经存在，这是 gqlgen 的亮点之一。一旦您编写了您的模式，您就可以在`models_gen.go`文件中添加相应的模型，如下所示:

```
// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package model

type NewTodo struct {
        Text   string `json:"text"`
        UserID string `json:"userId"`
}

type Todo struct {
        ID   string `json:"id"`
        Text string `json:"text"`
        Done bool   `json:"done"`
        User *User  `json:"user"`
}

type User struct {
        ID   string `json:"id"`
        Name string `json:"name"`
}

```

当您运行命令`go run github.com/99designs/gqlgen generate`时，它使用这两个输入为解析器生成样板文件，因此您可以专注于实现。

在`resolver.go`文件中，我们可以将属性添加到`Resolver`结构中，这可以通过由`r`表示的解析器实例来实现。我们将添加一个属性，它是待办事项的数组，我们可以用它来跟踪已经创建的待办事项:

```
package graph

import "my/graphql/api/graph/model"

// This file will not be regenerated automatically.
//
// It serves as dependency injection for your app, add any dependencies you require here.

type Resolver struct{
        todos []*model.Todo
}

```

现在，让我们在`schema.resolvers.go`中实现这些解析器功能:

```
package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.

import (
        "context"
        "my/graphql/api/graph/generated"
        "my/graphql/api/graph/model"
        "strconv"
)

func (r *mutationResolver) CreateTodo(ctx context.Context, input model.NewTodo) (*model.Todo, error) {

        id := strconv.Itoa(len(r.todos))

        // CREATE A NEW TODO
        todo := &model.Todo{
                Text:   input.Text,
                ID:     id,
                User: &model.User{ID: input.UserID, Name: "user " + input.UserID},
        }
        // ADD THE TODO TO THE TODOS ARRAY
        r.todos = append(r.todos, todo)
        // RETURN THE TODO
        return todo, nil
}

func (r *queryResolver) Todos(ctx context.Context) ([]*model.Todo, error) {
        // RETURN ALL THE TODOS
        return r.todos, nil
}

// Mutation returns generated.MutationResolver implementation.
func (r *Resolver) Mutation() generated.MutationResolver { return &mutationResolver{r} }

// Query returns generated.QueryResolver implementation.
func (r *Resolver) Query() generated.QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }

```

您可能对下面的代码感到疑惑:

```
// Mutation returns generated.MutationResolver implementation.
func (r *Resolver) Mutation() generated.MutationResolver { return &mutationResolver{r} }

// Query returns generated.QueryResolver implementation.
func (r *Resolver) Query() generated.QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }

```

本质上，上面的代码创建了一个`queryResolver`和`mutationResolver`的实例。两者都继承了我们前面看到的`Resolver`结构，使得数组对所有解析器都可用。我们的解析器变成了这些结构的方法。简而言之，创建了`Resolver`的一个实例，然后将它传递给`queryResolver`和`mutationResolver`的一个实例。

## 测试我们的 API

现在，让我们测试我们的 API。使用以下命令运行服务器:

```
go run server.go

```

转到`localhost:8080`，你就可以访问 GraphQL Playground，一个测试 GraphQL APIs 的工具。点击**文档**查看我之前提到的自我文档。

以下查询将显示我们的待办事项，这些事项目前为空:

```
{
  todos{
    id
    text
    done
  }
}

```

GraphQL 的一个有趣的特性是，你不必接收每个字段；您可以指定要在查询中包含哪些字段。下面是一个将添加待办事项的变异示例:

```
# I Specify that it's a mutation
mutation {
  # I invoke the createTodo mutation and pass it the input
  createTodo(input: {
    text: "This is a new todo"
    userId: "alex"
  })
  # Specify which properties I want from the return value
  {
    id
    text
    done
  }
}

```

继续添加一些待办事项，然后再次尝试通过查询获取这些事项。

### 测试 gqlgen `generate`

接下来，让我们通过添加一个模型并看到它自动生成所有必要的代码来测试生成特性。继续更新您的模式，如下所示:

```
# GraphQL schema example
#
# https://gqlgen.com/getting-started/

type Todo {
  id: ID!
  text: String!
  done: Boolean!
  user: User!
}

type Dog {
  id: ID!
  name: String
}

type User {
  id: ID!
  name: String!
}

type Query {
  todos: [Todo!]!
  dogs: [Dog!]!
}

input NewTodo {
  text: String!
  userId: String!
}

input NewDog {
  name: String!
}

type Mutation {
  createTodo(input: NewTodo!): Todo!
  createDog(input: NewDog!): Dog
}

```

然后，运行下面的命令:

```
go run github.com/99designs/gqlgen generate

```

您会注意到模型和解析器是自动生成的。如果您只是写出您的模式，gqlgen 可以帮助您推出许多样板文件。多牛逼啊！

## 结论

在本文中，我们介绍了如何使用 gqlgen 创建 GraphQL API，它允许我们使用 Go 无缝地编写 graph QL API，而无需编写过多的样板代码。

通过将 GraphQL 的优点(如自文档化)与 Go 的速度和简单语法结合起来，我们构建了一个更快、性能更好的应用程序。我希望你喜欢这篇文章！

## 监控生产中失败和缓慢的 GraphQL 请求

虽然 GraphQL 有一些调试请求和响应的特性，但确保 GraphQL 可靠地为您的生产应用程序提供资源是一件比较困难的事情。如果您对确保对后端或第三方服务的网络请求成功感兴趣，

[try LogRocket](https://lp.logrocket.com/blg/graphql-signup)

.

[![](img/432a3823c85b3fb72a206e6236a29f48.png)![LogRocket Dashboard Free Trial Banner](img/d6f5a5dd739296c1dd7aab3d5e77eeb9.png)](https://lp.logrocket.com/blg/graphql-signup)[https://logrocket.com/signup/](https://lp.logrocket.com/blg/graphql-signup)

LogRocket 就像是网络和移动应用的 DVR，记录下你网站上发生的每一件事。您可以汇总并报告有问题的 GraphQL 请求，以快速了解根本原因，而不是猜测问题发生的原因。此外，您可以跟踪 Apollo 客户机状态并检查 GraphQL 查询的键值对。

LogRocket 检测您的应用程序以记录基线性能计时，如页面加载时间、到达第一个字节的时间、慢速网络请求，还记录 Redux、NgRx 和 Vuex 操作/状态。

[Start monitoring for free](https://lp.logrocket.com/blg/graphql-signup)

.
<html>
<head>
<title>Styled-components vs. Emotion for handling CSS - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>风格化组件与情感处理 CSS - LogRocket 博客</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/styled-components-vs-emotion-for-handling-css/#0001-01-01">https://blog.logrocket.com/styled-components-vs-emotion-for-handling-css/#0001-01-01</a></blockquote><div><article class="article-post">
<h2 id="introduction">介绍</h2>
<p>随着 JavaScript 在过去几年中经历了许多调整和改进，我们已经看到了几个在 JavaScript 代码中处理 CSS 的新库。样式组件(styled-components)和<a href="https://github.com/emotion-js/emotion">情感(Emotion)</a>是两个主要的 CSS-in-JS 库，开发人员在设计流行的 JavaScript 框架(如 React)中的组件时通常会用到它们。</p>
<p>在本文中，我们将比较风格化组件和情感，包括差异、缺点和好处。</p>
<h2 id="overview">概观</h2>
<h3><strong>样式</strong>–<strong>组件</strong></h3>
<p>样式化组件库允许开发人员创建新的样式化 react 组件和重新样式化现有 react 组件。<code>Props</code>是样式化组件的<a href="https://styled-components.com/docs/basics#passed-props">主要功能元素</a>，尤其是对象样式的变化。</p>
<p>在我看来，styled-components 的最大优点是，只要它接受一个<code>className</code>属性，你就可以使用这个特定的库来设计任何组件的样式。您还可以使用<code>withComponent</code>函数助手来改变附加到特定组件的渲染标签。如果您希望以后在不同的组件中重用特定组件的某些样式，这可能是需要的。在这种情况下，您必须更改呈现的标记来执行操作。</p>
<h3><strong>情感</strong></h3>
<p>情感的使用与样式化组件的使用非常不同。这个库的主要特点是，对于使用 JavaScript 编写不同的 CSS 样式，样式组合是可预测的。该库支持字符串和对象样式。</p>
<p>一般来说，使用情感有两种主要方法:框架无关和 with React。每种方法都有优点和缺点，我们将在下面讨论。</p>
<h4><strong>与框架无关的</strong></h4>
<p>与其他类型的样式化方法不同，框架无关的方法不需要外部插件或额外的设置。Emotion 有一个可靠的支持系统——不管是什么框架——它能熟练处理自动供应商前缀、嵌套选择器和其他功能。</p>
<p>此外，使用与框架无关的方法，很容易生成不同的类名，因为您可以使用最简单的 CSS 函数来这样做。</p>
<h4><strong>反应方法</strong></h4>
<p>带着感情使用 React 方法是创建独特和非常规的<a href="https://blog.logrocket.com/the-best-react-inline-style-libraries-comparing-radium-aphrodite-emotion-849ef148c473/">内联设计作品</a>的最佳方法，并且在可配置的构建环境中应用时效果最佳。当您使用这种方法时，您可以获得专门的 CSS prop 支持，确保增强的样式选项，以及零配置的服务器端呈现。</p>
<h2 id="comparingstyledcomponentstoemotionjs">将风格成分与情感相比较</h2>
<p>当谈到为 JavaScript 编写 CSS 时，styled-components 和 Emotion 都非常高效，性能良好，并且有一个专门的开发人员基础，他们将每个库用于特定的目的。</p>
<p>在接下来的几节中，我们将看看使用每个库的不同原因，以帮助您决定哪一个适合您。</p>
<h3><strong>你为什么会选择样式组件？</strong></h3>
<p>样式化组件是 React 组件的简化版本，这使得向样式化组件传递属性变得相当容易。这个特性使得使用样式化组件编写 CSS 的过程更加容易。您还可以通过样式化组件重新设计现有常规组件的样式和主题。</p>
<p>对于执行主题化任务，样式化组件是一个很好的选择，它支持许多定制的外观、主题和感觉。样式化组件还允许适用于所有类型的样式化组件的全局样式化。当您<a href="https://blog.logrocket.com/build-your-own-styled-components-library/">创建一个适用于所有组件的全局样式</a>时，您可以在同时处理不同样式的组件时节省时间和精力。</p>
<p>除了上面列出的特性，样式化组件可以很容易地从一个 HTML 组件切换到另一个 HTML 组件。就 CSS 编写而言，这种灵活性使这个库比其他方法更好。例如，一旦某些 HTML 元素由样式化组件呈现，开发人员就可以向这些 HTML 元素添加额外的属性。</p>
<p>最后，styled-components 与几乎所有 CSS 框架兼容，可以帮助您满足所有的主题化和样式化需求。</p>
<h3>为什么要用情感来写 CSS？</h3>
<p>总的来说，Emotion 比其他库对开发者更友好。Emotion 的最大优势是它易于处理的对象样式，可以用来编写 CSS。</p>
<p>例如，以样式化组件为例，开发人员必须为不同的组件创建唯一的名称，同时避免相同的命名样式。如果您未能遵循独特的风格，或者您在没有有意义的描述符的情况下命名一个组件，那么您所有的努力都可能在几秒钟内付诸东流。另一方面，命名任务在情感上相当简单，因为它们依赖于 CSS 道具的应用。</p>
<p>最后，许多开发人员更喜欢 Emotion，而不是其他 CSS-in-JS 替代方案，因为它体积小、性能高、整体灵活。</p>
<h2 id="differentstylingoptionswithstyledcomponentsandemotion">不同的造型选项，带有不同风格的组件和情感</h2>
<h3><strong>使用</strong> <strong> s </strong> tyled 组件进行造型</h3>
<p>我们将从查看一些样式组件的示例代码开始:</p>
<pre>import styled from '@emotion/styled'

const Button = styled.button`
  color: turquoise;
`

render(&lt;Button&gt;This my button component.&lt;/Button&gt;)
</pre>
<p>请注意，您可以通过实现 props 来更改组件的样式，或者创建新的样式:</p>
<pre>import styled from '@emotion/styled'

const Button = styled.button`
  color: ${props =&gt;
    props.primary ? 'hotpink' : 'turquoise'};
`

const Container = styled.div(props =&gt; ({
  display: 'flex',
  flexDirection: props.column &amp;&amp; 'column'
}))

render(
  &lt;Container column&gt;
    &lt;Button&gt;This is a regular button.&lt;/Button&gt;
    &lt;Button primary&gt;This is a primary button.&lt;/Button&gt;
  &lt;/Container&gt;
)
</pre>
<p>在下面的例子中，我们可以使用<code>className</code>道具来创建样式:</p>
<pre>import styled from '@emotion/styled'
const Basic = ({ className }) =&gt; (
  &lt;div className={className}&gt;Some text&lt;/div&gt;
)

const Fancy = styled(Basic)`
  color: hotpink;
`

render(&lt;Fancy /&gt;)
</pre>
<p>最后，我们可以更改样式化组件中的呈现标签。在下面的代码块中，请注意第二个组件如何与 Section 具有相同的样式，但呈现为旁白:</p>
<pre>import styled from '@emotion/styled'

const Section = styled.section`
  background: #333;
  color: #fff;
`
const Aside = Section.withComponent('aside')
render(
  &lt;div&gt;
    &lt;Section&gt;This is a section&lt;/Section&gt;
    &lt;Aside&gt;This is an aside&lt;/Aside&gt;
  &lt;/div&gt;
)
</pre>
<h3><strong>使用情感进行框架无关的造型</strong></h3>
<p>由于 Emotion 简化了组件的样式，与框架无关的方法非常简单:</p>
<pre>import { css, cx } from '@emotion/css'

const color = 'white'

render(
  &lt;div
    className={css`
      padding: 32px;
      background-color: hotpink;
      font-size: 24px;
      border-radius: 4px;
      &amp;:hover {
        color: ${color};
      }
    `}
  &gt;
    Hover to change color.
  &lt;/div&gt;
)
</pre>
<h3><strong>使用情感来设计 React 中组件的样式</strong></h3>
<p>该方法在反应上同样简单:</p>
<pre>// this comment tells babel to convert jsx to calls to a function called jsx instead of React.createElement
/** @jsx jsx */
import { css, jsx } from '@emotion/react'

const color = 'white'

render(
  &lt;div
    css={css`
      padding: 32px;
      background-color: hotpink;
      font-size: 24px;
      border-radius: 4px;
      &amp;:hover {
        color: ${color};
      }
    `}
  &gt;
    Hover to change color.
  &lt;/div&gt;
)
</pre>
<h2 id="conclusion">结论</h2>
<p>对于简单、高效和不复杂的样式，Emotion 是一个很好的 CSS-to-JS 库。另一方面，对于更独特和复杂的样式选项，样式化组件可能是更好的选择。正如编写 CSS 时经常遇到的情况一样，大部分决策过程都取决于项目设置和个人偏好。</p><div class="code-block code-block-17">
<div class="blog-plug inline-plug react-plug" vwo-el-id="26283398190">
<h2 vwo-el-id="41600691720">使用 LogRocket 消除传统反应错误报告的噪音</h2>
<a href="https://lp.logrocket.com/blg/react-signup-issue-free" target="_blank" vwo-el-id="19356441070">LogRocket
</a><p>是一款 React analytics 解决方案，可保护您免受数百个误报错误警报的影响，只针对少数真正重要的项目。LogRocket 告诉您 React 应用程序中实际影响用户的最具影响力的 bug 和 UX 问题。</p><a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="19356441380">
<img class="first-react-image alignnone size-full wp-image-46 jetpack-lazy-image jetpack-lazy-image--handled" src="../Images/f300c244a1a1cf916df8b4cb02bec6c6.png" vwo-el-id="18272717540" data-lazy-loaded="1" data-original-src="https://files.readme.io/27c94e7-Image_2017-06-05_at_9.46.04_PM.png"/>
</a>
<a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="19356441690">
<img class="second-react-image alignnone size-full wp-image-46 jetpack-lazy-image jetpack-lazy-image--handled" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" vwo-el-id="30720362350" data-lazy-loaded="1" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/>
</a>
<a href="https://lp.logrocket.com/blg/react-signup-issue-free" target="_blank" rel="noopener noreferrer" vwo-el-id="35866400580">LogRocket
</a><p>自动聚合客户端错误、反应错误边界、还原状态、缓慢的组件加载时间、JS 异常、前端性能指标和用户交互。然后，LogRocket 使用机器学习来通知您影响大多数用户的最具影响力的问题，并提供您修复它所需的上下文。</p><p vwo-el-id="28675661060">关注重要的 React bug—<a class="signup" href="https://lp.logrocket.com/blg/react-signup-issue-free" target="_blank" rel="noopener noreferrer" vwo-el-id="40093418840">今天就试试 LogRocket】。</a></p>
</div></div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

 </div>    
</body>
</html>
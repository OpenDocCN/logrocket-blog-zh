<html>
<head>
<title>Lit vs. React: A comparison guide - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>Lit 与 React:比较指南</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/lit-vs-react-comparison-guide/#0001-01-01">https://blog.logrocket.com/lit-vs-react-comparison-guide/#0001-01-01</a></blockquote><div><article class="article-post">
<p>对于开发人员来说，选择前端框架可能是一个困难的决定，因为有太多的选择。React 是最受欢迎的选择之一。这是一项完善的计划，截止到<a href="https://2021.stateofjs.com/en-US/libraries/front-end-frameworks" target="_blank" rel="noopener"> 2021 年 JS 状态调查</a>，满意度达到 84%。尽管如此，还有其他几个具有有趣特性和功能的框架值得研究。</p>
<p>为下一个项目选择前端框架时，请考虑以下问题:</p>
<ul>
<li>这个框架有我需要的特性吗？</li>
<li>与其他框架相比，这个框架有多快？</li>
<li>这个框架有多容易学习和使用？</li>
<li>什么规模的社区使用这个框架？</li>
</ul>
<p>另一种反应是<a href="https://lit.dev" target="_blank" rel="noopener"> Lit </a>，截至<a href="https://2021.stateofjs.com/en-US/libraries/front-end-frameworks" target="_blank" rel="noopener"> 2021 年 JS 状态调查</a>，其满意度为 77%。<a href="https://blog.logrocket.com/getting-started-lit-html-litelement/" target="_blank" rel="noopener"> Lit 易于学习和使用</a>，它的小体积意味着快速的加载时间。</p>
<p>在本教程中，我们将比较反应和照明。我们还将在 Lit 中创建一个示例项目。</p>
<p><em>向前跳转:</em></p>

<p>我们开始吧！</p>
<h2 id="whats-new-in-lit">Lit 有什么新内容？</h2>
<p>Lit 有几个区别于其他前端框架的特性:</p>
<ul>
<li>LitElement 基类是本机 HTMLElement 的方便且通用的扩展。这个类可以被扩展来定义我们的组件</li>
<li>表达性和声明性模板使得定义组件应该如何呈现变得容易</li>
<li>反应属性是 Lit 组件的内部状态。当反应属性更改时，组件会自动重新渲染</li>
<li>作用域样式有助于保持 CSS 选择器的简单，确保组件样式不会影响其他上下文</li>
<li>支持普通 Javascript、类型脚本和人机工程学(装饰器和类型声明)</li>
</ul>
<h2 id="lit-vs-react">点燃与反应</h2>
<p>Lit 的核心概念和特性与 React 相似，但也有一些显著的不同。比如 React 从 2013 年就有了，受欢迎程度远远超过 Lit。在撰写本文时，React 在 npm 上的周下载量约为<a href="https://www.npmjs.com/package/react" target="_blank" rel="noopener">1590 万，相比之下，Lit 在 npm </a>上的周下载量为<a href="https://www.npmjs.com/package/lit" target="_blank" rel="noopener">12.7 万。</a></p>
<p>但是，Lit 比 React 更快，占用的内存也更少。一项公开的基准比较显示 lit-html 比 React 的 VDOM 快 8-10%。与 React 的 40kB 相比，Lit 的内存大小只有 5kB。</p>
<p>这两个框架还提供了其他很酷的特性。让我们看看他们是如何比较的。</p>
<h2 id="jsx-and-templating">JSX 和模板</h2>
<p>JSX 是 JavaScript 的语法扩展，功能类似于模板语言，但具有 JavaScript 的全部功能。React 用户可以使用 JSX 轻松地用 JavaScript 代码编写模板。Lit 模板服务于类似的目的，但是将组件 UI 表达为其状态的函数。</p>
<p>下面是 React 中 JSX 模板的一个例子:</p>
<pre class="language-javascript hljs">import 'react';
import ReactDOM from 'react-dom';

const name = 'World';
const el = (
  &lt;&gt;
    &lt;h1&gt;Hello, {name}&lt;/h1&gt;
    &lt;div&gt;How are you? &lt;/div&gt;
  &lt;/&gt;
);
ReactDOM.render(
  el,
  mountNode
);
</pre>
<p>下面是一个在 Lit 中使用模板的例子:</p>
<pre class="language-javascript hljs">import {html, render} from 'lit';

const name = 'World';
const el = html`
  &lt;h1&gt;Hello, ${name}&lt;/h1&gt;
  &lt;div&gt;How are you?&lt;/div&gt;`;

render(
  el,
  mountNode
);
</pre>
<p>正如我们在上面的例子中所看到的，Lit 不需要 React 片段来对其模板中的多个元素进行分组。相反，Lit 模板用 HTML <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals#tagged_templates" target="_blank" rel="noopener">标记的模板文字</a>包装。</p>
<h2 id="components-and-props">组件和道具</h2>
<p>组件是自包含的、可重用的代码片段。它们执行与 JavaScript 函数相同的操作，但是它们独立工作并返回 HTML。React 组件分为两种类型:类组件和功能组件。</p>
<h3 id="class-components">类别组件</h3>
<p>React 类组件的 Lit 等价物被称为<a href="https://lit.dev/docs/api/LitElement/" target="_blank" rel="noopener"> LitElement </a>。</p>
<p>下面是 React 中基于类的组件的一个示例:</p>
<pre class="language-javascript hljs">import React from 'react';
import ReactDOM from 'react-dom';

class Welcome extends React.Component {
  constructor(props) {
    super(props);
    this.state = {name: ''};
  }

  render() {
    return &lt;h1&gt;Hello, {this.props.name}&lt;/h1&gt;;
  }
}

const el = &lt;Welcome name="World"/&gt;
ReactDOM.render(
  el,
  mountNode
);
</pre>
<p>下面是 Lit 中的同一个例子，使用<code>LitElement</code>:</p>
<pre class="language-javascript hljs">import {LitElement, html} from 'lit';

class WelcomeBanner extends LitElement {
  static get properties() {
    return {
      name: {type: String}
    }
  }

  constructor() {
    super();
    this.name = '';
  }

  render() {
    return html`&lt;h1&gt;Hello, ${this.name}&lt;/h1&gt;`
  }
}

customElements.define('welcome-banner', WelcomeBanner);
</pre>
<p>在为 LitElement 组件定义和呈现模板之后，我们将以下内容添加到我们的 HTML 文件中:</p>
<pre class="language-javascript hljs">&lt;!-- index.html --&gt;
&lt;head&gt;
  &lt;script type="module" src="./index.js"&gt;&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;welcome-banner name="World"&gt;&lt;/welcome-banner&gt;
&lt;/body&gt;
</pre>
<p>现在，让我们看看功能组件是如何在这些框架中创建的。</p>
<h3 id="functional-components">功能组件</h3>
<p>Lit 不使用 JSX，所以与 React 功能组件没有一一对应的关系。然而，更简单的方法是编写一个函数，它接收属性，然后根据这些属性呈现 DOM。</p>
<p>下面是 React 中一个功能组件的示例:</p>
<pre class="language-javascript hljs">function Welcome(props) {
  return &lt;h1&gt;Hello, {props.name}&lt;/h1&gt;;
}

const el = &lt;Welcome name="World"/&gt;
ReactDOM.render(
  el,
  mountNode
);
</pre>
<p>下面是 Lit 中的同一个例子:</p>
<pre class="language-javascript hljs">import {html, render} from 'lit';

function Welcome(props) {
  return html`&lt;h1&gt;Hello, ${props.name}&lt;/h1&gt;`;
}

render(
  Welcome({name: 'World}),
  document.body.querySelector('#root')
);
</pre>
<h2 id="state-and-lifecycle-methods">状态和生命周期方法</h2>
<p><code>state</code>是一个包含组件数据或信息的 React 对象。组件的<code>state</code>会随着时间而改变。每当它的<code>state</code>改变时，组件就会重新呈现。</p>
<p>Lit 的<a href="https://lit.dev/docs/components/properties/" target="_blank" rel="noopener">反应属性</a>是 React 的<code>state</code>和<code>props</code>的混合。更改后，反应属性可以触发组件生命周期，重新渲染组件，并可以选择读取或写入属性。反应属性有两种变体:</p>
<ul>
<li>公共反应属性</li>
<li>内部反应状态</li>
</ul>
<p>反应属性在 React 中实现，如下所示:</p>
<pre class="language-javascript hljs">import React from 'react';

class MyEl extends React.Component {
  constructor(props) {
    super(props)
    this.state = {name: 'there'}
  }

  componentWillReceiveProps(nextProps) {
    if (this.props.name !== nextProps.name) {
      this.setState({name: nextProps.name})
    }
  }
}
</pre>
<p>反应属性在 Lit 中实现，如下所示:</p>
<pre class="language-typescript hljs">import {LitElement} from 'lit';
import {property} from 'lit/decorators.js';

class MyEl extends LitElement {
  @property() name = 'there';
}
</pre>
<p>内部反应状态指的是不向组件的公共 API 公开的反应属性。这些状态属性缺少相应的属性，并且不适合在组件外部使用。组件的内部反应状态应由组件本身决定。</p>
<p>React 和 Lit 具有相似的生命周期，但有一些小而显著的差异。让我们仔细看看这些框架共有的一些方法。</p>
<h3 id="constructor"><code>constructor</code></h3>
<p><code>constructor</code>方法在 React 和 Lit 中都可用。当从<code>class</code>创建一个对象时，它被自动调用。</p>
<p>下面是 React 中的<code>constructor</code>方法的一个例子:</p>
<pre class="language-javascript hljs">import React from 'react';
import Chart from 'chart.js';

class MyEl extends React.Component {
  constructor(props) {
    super(props);
    this.state = { counter: 0 };
    this._privateProp = 'private';
  }
</pre>
<p>下面是 Lit 中的<code>constructor</code>方法的一个例子:</p>
<pre class="language-javascript hljs">class MyEl extends LitElement {
  static get properties() {
    return { counter: {type: Number} }
  }
  constructor() {
    this.counter = 0;
    this._privateProp = 'private';
  }
</pre>
<h3 id="render"><code>render</code></h3>
<p><code>render</code>方法在 React 和 Lit 中都可用。它显示指定元素内的代码。</p>
<p>下面是 React 中的<code>render</code>方法的一个例子:</p>
<pre class="language-javascript hljs">render() {
    return &lt;div&gt;Hello World&lt;/div&gt;
  }
</pre>
<p>下面是 Lit 中的<code>render</code>方法的一个例子:</p>
<pre class="language-javascript hljs">render() {
    return html`&lt;div&gt;Hello World&lt;/div&gt;`;
  }
</pre>
<h3 id="componentdidmount-vs-firstupdated-and-connectedcallback"><code>componentDidMount</code>对<code>firstUpdated</code>和<code>connectedCallback</code></h3>
<p>React 中的<code>componentDidMount</code>函数类似于 Lit 的<code>firstUpdated</code>和<code>connectedCallback</code>生命周期回调的组合。该函数在组件安装后调用。</p>
<p>下面是 React 中的<code>componentDidMount</code>方法的一个例子:</p>
<pre class="language-javascript hljs">componentDidMount() {
    this._chart = new Chart(this.chartElRef.current, {...});
  }

  componentDidMount() {
    this.window.addEventListener('resize', this.boundOnResize);
  }
</pre>
<p>以下是 Lit 中的<code>firstUpdated</code>和<code>connectedCallback</code>生命周期回调的示例:</p>
<pre class="language-javascript hljs">firstUpdated() {
    this._chart = new Chart(this.chartEl, {...});
  }

  connectedCallback() {
    super.connectedCallback();
    this.window.addEventListener('resize', this.boundOnResize);
  }
</pre>
<h3 id="componentdidupdate-vs-updated"><code>componentDidUpdate</code>对<code>updated</code></h3>
<p>React 中的<code>componentDidUpdate</code>功能相当于 Lit 中的<code>updated</code>。它在组件的属性或状态改变后被调用。</p>
<p>下面是 React 中的<code>componentDidUpdate</code>方法的一个例子:</p>
<pre class="language-javascript hljs">componentDidUpdate(prevProps) {
    if (this.props.title !== prevProps.title) {
      this._chart.setTitle(this.props.title);
    }
  }
</pre>
<p>下面是 Lit 中的<code>updated</code>方法的一个例子:</p>
<pre class="language-javascript hljs">updated(prevProps: PropertyValues&lt;this&gt;) {
    if (prevProps.has('title')) {
      this._chart.setTitle(this.title);
    }
  }
</pre>
<h3 id="componentwillunmount-vs-disconnectedcallback"><code>componentWillUnmount</code>对<code>disconnectedCallback</code></h3>
<p>React 中的<code>componentWillUnmount</code>功能相当于 Lit 中的<code>disconnectedCallback</code>。该函数在组件被销毁或卸载后调用。</p>
<p>下面是 React 中的<code>componentWillUnmount</code>方法的一个例子:</p>
<pre class="language-javascript hljs">componentWillUnmount() {
    this.window.removeEventListener('resize', this.boundOnResize);
  }
}
</pre>
<p>下面是 Lit 中的<code>disconnectedCallback</code>方法的一个例子:</p>
<pre class="language-javascript hljs">disconnectedCallback() {
    super.disconnectedCallback();
    this.window.removeEventListener('resize', this.boundOnResize);
  }
}
</pre>
<h2 id="hooks">钩住</h2>
<p>挂钩是允许 React 功能组件“挂钩”React 状态和生命周期特性的功能。钩子在类内不起作用，但是它们允许我们在没有类的情况下使用 React。</p>
<p>与 React 不同，Lit 不提供从函数创建定制元素的方法，但是 LitElement 通过以下方式解决了 React 类组件的大多数主要问题:</p>
<ul>
<li>在构造函数中不接受参数</li>
<li>自动绑定所有@event 绑定(通常是自定义元素的引用)</li>
<li>将类属性实例化为类成员</li>
</ul>
<p>这里有一个 React 中钩子的例子(在制作钩子的时候):</p>
<pre class="language-javascript hljs"> 
import React from 'react';
import ReactDOM from 'react-dom';

class MyEl extends React.Component {
  constructor(props) {
    super(props); // Leaky implementation
    this.state = {count: 0};
    this._chart = null; // Deemed messy
  }

  render() {
    return (
      &lt;&gt;
        &lt;div&gt;Num times clicked {count}&lt;/div&gt;
        &lt;button onClick={this.clickCallback}&gt;click me&lt;/button&gt;
      &lt;/&gt;
    );
  }

  clickCallback() {
    // Errors because `this` no longer refers to the component
    this.setState({count: this.count + 1});
  }
}
</pre>
<p>下面是同样的例子，使用 LitElement:</p>
<pre class="language-typescript hljs">class MyEl extends LitElement {
  @property({type: Number}) count = 0; // No need for constructor to set state
  private _chart = null; // Public class fields introduced to JS in 2019

  render() {
    return html
        &lt;div&gt;Num times clicked ${count}&lt;/div&gt;
        &lt;button @click=${this.clickCallback}&gt;click me&lt;/button&gt;`;
  }

  private clickCallback() {
    // No error because `this` refers to component
    this.count++;
  }
}
</pre>
<h2 id="refs">参考文献</h2>
<p>Refs 是 React 函数，允许我们访问 DOM 元素和我们创建的任何 React 元素。当我们想在不使用道具的情况下改变子组件的值时，就会用到它们。</p>
<p>在 Lit 中，ref 是使用<code>@query</code>和<code>@queryAll</code>装饰器创建的。这些装饰器分别相当于<code>querySelector</code>和<code>querySelectorAll</code>，直接呈现给 DOM。</p><div class="code-block code-block-54">
<hr/>
<h3>更多来自 LogRocket 的精彩文章:</h3>

<hr/></div>
<p>下面是 React 中 refs 函数的一个示例:</p>
<pre class="language-javascript hljs">const RefsExample = (props) =&gt; {
 const inputRef = React.useRef(null);
 const onButtonClick = React.useCallback(() =&gt; {
   inputRef.current?.focus();
 }, [inputRef]);

 return (
   &lt;div&gt;
     &lt;input type={"text"} ref={inputRef} /&gt;
     &lt;br /&gt;
     &lt;button onClick={onButtonClick}&gt;
       Click to focus on the input above!
     &lt;/button&gt;
   &lt;/div&gt;
 );
};
</pre>
<p>下面是在 Lit 中使用<code>@query</code>装饰器的同一个例子:</p>
<pre class="language-typescript hljs">@customElement("my-element")
export class MyElement extends LitElement {
  @query('input') // Define the query
  inputEl!: HTMLInputElement; // Declare the prop

  // Declare the click event listener
  onButtonClick() {
    // Use the query to focus
    this.inputEl.focus();
  }

  render() {
    return html
      &lt;input type="text"&gt;
      &lt;br /&gt;
      &lt;!-- Bind the click listener --&gt;
      &lt;button @click=${this.onButtonClick}&gt;
        Click to focus on the input above!
      &lt;/button&gt;
   ;
  }
}
</pre>
<h2 id="creating-basic-to-do-project-lit">在 Lit 中创建基本的待办事项项目</h2>
<p>让我们通过创建一个示例待办事项项目来看看 Lit 的实际应用。</p>
<p>首先，运行命令克隆 Lit starter JavaScript 项目:</p>
<pre class="language-javascript hljs">git clone https://github.com/lit/lit-element-starter-js.git
</pre>
<p>然后，cd 到项目文件夹，并使用以下命令安装所需的包:</p>
<pre class="language-javascript hljs">npm install
</pre>
<p>安装完成后，进入<code>lit-element-starter-js/my-element.js</code>文件。删除样板代码，并使用以下代码片段创建一个<code>Todo</code>组件:</p>
<pre class="language-javascript hljs">import {LitElement, html, css} from 'lit';
class Todo extends LitElement {
  constructor() {
    super();
  }
  render() {
    return html
      &lt;div class="todos-wrapper"&gt;
        &lt;h4&gt;My Todos List&lt;/h4&gt;
        &lt;input placeholder="Add task..."/&gt;
        &lt;button&gt;Add&lt;/button&gt;
        &lt;div class="list"&gt;
            #Todo List
        &lt;/div&gt;
      &lt;/div&gt;
    ;
  }
}
customElements.define('my-element', Todo);
</pre>
<p>上面的代码用一个<code>constructor</code>方法和一个<code>render</code>方法创建了一个<code>Todo</code>组件，在这个组件中应用程序的所有反应属性都将被定义，这个组件呈现包含输入字段和按钮的 JSX。</p>
<p>接下来，让我们定义应用程序的属性。因为这是一个待办事项应用程序，我们需要一个<code>TodosList</code>来存储任务，需要一个<code>input</code>属性来获取用户输入。</p>
<p>现在，我们将下面的代码片段添加到<code>Todos</code>类中:</p>
<pre class="language-javascript hljs">static properties = {
    TodosList: {type: Array},
    input: {type: String},
  };
</pre>
<p>然后，我们将使用下面的代码为<code>constructor</code>方法中的<code>TodosList</code>和<code>input</code>属性分配初始值:</p>
<pre class="language-javascript hljs"> this.TodosList = [];
 this.input = null;
</pre>
<p>接下来，我们将创建一个添加和更新待办任务的方法:</p>
<pre class="language-javascript hljs">setInput(event) {
    this.input = event.target.value;
  }

  addTodo() {
      this.TodosList.push({
      name: this.input,
      id: this.TodosList.length + 1,
      completed: false,
    });
    this.requestUpdate();
  }

 updateTodo(todo) {
    todo.completed = !todo.completed;
    this.requestUpdate();
  }
</pre>
<p>我们可以在上面的代码中看到，在修改状态后，<code>addTodo</code>和<code>updateTodo</code>方法中调用了<code>requestUpdate()</code>函数。这些方法改变了<code>TodosList</code>属性，所以我们调用了<code>requestUpdate()</code>函数来更新组件状态。</p>
<p>接下来，我们将修改<code>render</code>方法，将事件监听器添加到上面创建的方法中，并显示待办任务。</p>
<pre class="language-javascript hljs"> render() {
    return html
      &lt;div class="todos-wrapper"&gt;
        &lt;h4&gt;My Todos List&lt;/h4&gt;
        &lt;input placeholder="Add task..." @input=${this.setInput} /&gt;
        &lt;button @click=${this.addTodo}&gt;Add&lt;/button&gt;
        &lt;div class="list"&gt;
          ${this.TodosList.map(
            (todo) =&gt; html`
              &lt;li
                @click=${() =&gt; this.updateTodo(todo)}
                class=${todo.completed &amp;&amp; 'completed'}
              &gt;
                ${todo.name}
              &lt;/li&gt;
          )}
        &lt;/div&gt;
      &lt;/div&gt;
    ;
  }
</pre>
<p>最后，让我们添加一些样式，使应用程序看起来更有吸引力:</p>
<pre class="language-javascript hljs">static styles = css
    .todos-wrapper {
      width: 35%;
      margin: 0px auto;
      background-color: rgb(236, 239, 241);
      padding: 20px;
    }
    .list {
      margin-top: 9px;
    }
    .list li {
      background-color: white;
      list-style: none;
      padding: 6px;
      margin-top: 3px;
    }
    .completed {
      text-decoration-line: line-through;
      color: #777;
    }
    input {
      padding: 5px;
      width: 70%;
    }
    button {
      padding: 5px;
    }
  ;
</pre>
<p>现在，让我们运行应用程序:</p>
<pre class="language-javascript hljs">npm run serve
</pre>
<p>这是我们的待办事项项目示例！</p>
<p><img data-attachment-id="104833" data-permalink="https://blog.logrocket.com/lit-vs-react-comparison-guide/attachment/sample-project-todos-list/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/05/sample-project-todos-list.png" data-orig-size="636,314" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Sample project Todos List" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/05/sample-project-todos-list-300x148.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/05/sample-project-todos-list.png" decoding="async" class="aligncenter size-full wp-image-104833 jetpack-lazy-image" src="../Images/fbb033896e13f438f13466d517612018.png" alt="Sample Project Todos List" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2022/05/sample-project-todos-list.png 636w, https://blog.logrocket.com/wp-content/uploads/2022/05/sample-project-todos-list-300x148.png 300w" data-lazy-sizes="(max-width: 636px) 100vw, 636px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2022/05/sample-project-todos-list.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/05/sample-project-todos-list.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="104833" data-permalink="https://blog.logrocket.com/lit-vs-react-comparison-guide/attachment/sample-project-todos-list/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/05/sample-project-todos-list.png" data-orig-size="636,314" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Sample project Todos List" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/05/sample-project-todos-list-300x148.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/05/sample-project-todos-list.png" decoding="async" loading="lazy" class="aligncenter size-full wp-image-104833" src="../Images/fbb033896e13f438f13466d517612018.png" alt="Sample Project Todos List" srcset="https://blog.logrocket.com/wp-content/uploads/2022/05/sample-project-todos-list.png 636w, https://blog.logrocket.com/wp-content/uploads/2022/05/sample-project-todos-list-300x148.png 300w" sizes="(max-width: 636px) 100vw, 636px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/05/sample-project-todos-list.png"/></noscript>
<h2 id="should-switch-react-lit">我应该从 React 切换到 Lit 吗？</h2>
<p>每个框架都有独特的优点和缺点。React <a href="https://reactjs.org/docs/design-principles.html#stability" target="_blank" rel="noopener">为许多大公司</a>的网络应用提供支持，比如脸书、Twitter 和 Airbnb。它还有一个由<a href="https://reactjs.org/community/support.html" target="_blank" rel="noopener">开发者和贡献者</a>组成的庞大社区。</p>
<p>如果你目前正在使用 React，并且对这个选择感到满意，那么我认为你没有理由要换。但是，如果您正在处理一个需要真正快速性能的项目，那么您可以考虑使用 Lit。</p>
<p>要了解更多关于 Lit 的信息，请查看其官方文档。</p><div class="code-block code-block-17">
<div class="blog-plug inline-plug react-plug" vwo-el-id="26283398190">
<h2 vwo-el-id="41600691720"><a href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener"> LogRocket </a>:全面了解您的生产 React 应用</h2><p>调试 React 应用程序可能很困难，尤其是当用户遇到难以重现的问题时。如果您对监视和跟踪 Redux 状态、自动显示 JavaScript 错误以及跟踪缓慢的网络请求和组件加载时间感兴趣，</p><a href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" vwo-el-id="19356441070">try LogRocket</a><p>. </p><a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="19356441380">
<img class="first-react-image alignnone size-full wp-image-46 jetpack-lazy-image jetpack-lazy-image--handled" src="../Images/f300c244a1a1cf916df8b4cb02bec6c6.png" vwo-el-id="18272717540" data-lazy-loaded="1" data-original-src="https://files.readme.io/27c94e7-Image_2017-06-05_at_9.46.04_PM.png"/>
</a>
<a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="19356441690">
<img class="second-react-image alignnone size-full wp-image-46 jetpack-lazy-image jetpack-lazy-image--handled" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" vwo-el-id="30720362350" data-lazy-loaded="1" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/>
</a>
<p vwo-el-id="28675660440" class="">LogRocket 结合了会话回放、产品分析和错误跟踪，使软件团队能够创建理想的 web 和移动产品体验。这对你来说意味着什么？</p>
<p>LogRocket 不是猜测错误发生的原因，也不是要求用户提供截图和日志转储，而是让您回放问题，就像它们发生在您自己的浏览器中一样，以快速了解哪里出错了。</p>
<p>不再有嘈杂的警报。智能错误跟踪允许您对问题进行分类，然后从中学习。获得有影响的用户问题的通知，而不是误报。警报越少，有用的信号越多。</p>
<p vwo-el-id="28675660750">LogRocket Redux 中间件包为您的用户会话增加了一层额外的可见性。LogRocket 记录 Redux 存储中的所有操作和状态。</p>
<p vwo-el-id="28675661060">现代化您调试 React 应用的方式— <a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="40093418840">开始免费监控</a>。</p>
</div></div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
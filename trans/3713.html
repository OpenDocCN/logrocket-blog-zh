<html>
<head>
<title>Phero: Build a type-safe, full-stack app with TypeScript </title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>费罗:用TypeScript构建一个类型安全的全栈应用</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/phero-build-type-safe-full-stack-apps-with-typescript/#0001-01-01">https://blog.logrocket.com/phero-build-type-safe-full-stack-apps-with-typescript/#0001-01-01</a></blockquote><div><article class="article-post">
<p><strong> <em>编者按</em> </strong> : <em>本帖于2022年12月29日更新，提及了新功能。</em></p>
<p>将后端API更改同步到客户端应用是前端开发人员面临的一个常见问题。当后端API接口改变时，客户端应用可能需要手动更新以防止错误或崩溃。</p>
<p>费罗就是为了解决这个问题而设计的。由<a href="https://pressplay.dev/"> Press Play </a>的人在2020年开发的，它最初是为了管理他们的软件产品的类型和接口而创建的，这消耗了大量的API端点。Phero是使用TypeScript开发的，可以与任何基于TypeScript的框架一起工作。它将处理后端代码并为前端生成一个类型安全的客户端。</p>
<p>使用Phero，您可以像调用本地函数一样从前端调用后端服务/函数。从2022年9月开始开源。</p>
<p>让我们仔细看看费罗。</p>
<p><em>向前跳转:</em></p>

<h2 id="what-problem-does-phero-solve">费罗解决什么问题？</h2>
<p>让我们用一个典型的Node.js/Express web API作为例子。我们公开一个端点，如下所示:</p>
<pre class="language-javascript hljs"># API
export enum UserRole {
  ADMIN = "admin",
  USER = "user",
}
export interface User {
  name: string;
  age: number;
  role: UserRole;
}
export interface Users {
  [key: number]: User;
}
app.get("users/:userId", (req, res) =&gt; {
  res.send(
     {
      name: "Jane",
      age: 30,
      role: UserRole.USER
    });
});</pre>
<p>在客户端应用程序中，我们需要创建另一组类型/接口，然后转换响应JSON以获得类型化的响应对象。</p>
<pre class="language-json hljs"># Client App
export enum UserRole {
  ADMIN = "admin",
  USER = "user",
}

export interface User {
  name: string;
  age: number;
  role: UserRole;
}

const response = await fetch(`${Root_URL}/users/1`);
const user = await response.json() as User;</pre>
<p>这种模式存在一些问题。首先，在客户端和服务器端都有重复的类型和接口。这种重复会使应用程序难以维护。</p>
<p>其次，当API发生变化时(即添加了新的<code>UserType</code>)，如果没有更新，客户端应用程序可能会崩溃——即使您更新了客户端，旧版本的客户端应用程序仍会有同样的问题。因此，服务器和客户机都需要同时更新，以确保向后兼容性。</p>
<p>为了克服上述问题，一种常见的做法是向客户端代码添加JSON响应。但是额外的验证需要额外的工作，并且不够安全，因为它不能在编译时捕捉问题。</p>
<p>费罗为这个问题提供了一个干净的解决方案。</p>
<h2 id="how-does-phero-work">费罗是如何工作的？</h2>
<p>在幕后，费罗使用了<a href="https://blog.logrocket.com/introduction-to-rpc-using-go-and-node/">远程过程调用(RPC) </a>。RPC是一种通信协议，允许一台机器上的程序调用另一台机器上的服务，而不知道它是远程的。</p>
<p>下图显示了使用RPC的Phero客户端和服务通信。</p>
<figure id="attachment_146404" aria-describedby="caption-attachment-146404" class="wp-caption aligncenter"><img data-attachment-id="146404" data-permalink="https://blog.logrocket.com/phero-build-type-safe-full-stack-apps-with-typescript/attachment/phero-client-connection-rpc/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/12/phero-client-connection-rpc.png" data-orig-size="730,666" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="phero-client-connection-rpc" data-image-description="" data-image-caption="&lt;p&gt;A diagram illustrating the connection between Phero and the client via RPC&lt;/p&gt;&#10;" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/12/phero-client-connection-rpc-300x274.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/12/phero-client-connection-rpc.png" decoding="async" class="size-full wp-image-146404 jetpack-lazy-image" src="../Images/5408d49e07a101bf1ecb2458eb16b9e2.png" alt="A diagram illustrating the connection between Phero and the client via RPC" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2022/12/phero-client-connection-rpc.png 730w, https://blog.logrocket.com/wp-content/uploads/2022/12/phero-client-connection-rpc-300x274.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2022/12/phero-client-connection-rpc.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/12/phero-client-connection-rpc.png"/><noscript><img data-lazy-fallback="1" data-attachment-id="146404" data-permalink="https://blog.logrocket.com/phero-build-type-safe-full-stack-apps-with-typescript/attachment/phero-client-connection-rpc/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/12/phero-client-connection-rpc.png" data-orig-size="730,666" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="phero-client-connection-rpc" data-image-description="" data-image-caption="&lt;p&gt;A diagram illustrating the connection between Phero and the client via RPC&lt;/p&gt;&#10;" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/12/phero-client-connection-rpc-300x274.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/12/phero-client-connection-rpc.png" decoding="async" loading="lazy" class="size-full wp-image-146404" src="../Images/5408d49e07a101bf1ecb2458eb16b9e2.png" alt="A diagram illustrating the connection between Phero and the client via RPC" srcset="https://blog.logrocket.com/wp-content/uploads/2022/12/phero-client-connection-rpc.png 730w, https://blog.logrocket.com/wp-content/uploads/2022/12/phero-client-connection-rpc-300x274.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/12/phero-client-connection-rpc.png"/></noscript><figcaption id="caption-attachment-146404" class="wp-caption-text">A diagram illustrating the connection between Phero and the client via RPC</figcaption></figure>
<p>您可以使用任何基于TypeScript的框架来构建您的后端和前端；除此之外，一个启用信息素的应用程序包含三个组件:</p>
<ol>
<li>客户端应用程序:您的客户端应用程序只需要在与服务器交互时使用生成的Phero客户端文件</li>
<li>服务器app:服务器组件的入口点是<code>Phero.ts</code>；只要Phero文件公开了函数，您还可以灵活地组织服务器项目结构</li>
<li>费罗生成的代码:生成的文件是后端和前端之间的粘合剂，包括客户端存根和服务器端存根文件。存根使服务器和客户机能够使用HTTP协议通过RPC进行通信</li>
</ol>
<p>Phero利用TypeScript编译器API来分析类型和接口。它还生成验证器来解析客户机和服务器之间的传入和传出数据。它公开了后端公开的所有域类型和接口；因此，如果返回输入错误或不正确的数据，将会引发编译时错误。</p>
<h3 id="benefits-working-with-phero">与费罗合作的好处</h3>
<p>费罗的好处包括:</p>
<ul>
<li>纯类型脚本(不需要其他依赖项)</li>
<li>端到端类型安全</li>
<li>分离后端和前端，就像它们没有分离一样</li>
<li>使用任何基于类型脚本的框架</li>
</ul>
<h2 id="getting-started-with-phero">开始使用费罗</h2>
<p>让我们来看看构建一个费罗应用程序的过程。由于Phero是一个纯TypeScript库，所以唯一的依赖项是npm和TypeScript。</p>
<h3 id="backend-setup">后端设置</h3>
<p>首先，让我们初始化一个Node.js应用程序。我们在下面创建一个<code>api</code>目录。你想叫它什么都可以。</p>
<pre class="language-bash hljs"># bash script
#  Create a Server folder
mkdir api
cd ./api
# Initialise the server app, and get TypeScript ready 
npm init -y
npm install typescript --save-dev
npx tsc --init

​# edit tsconfig.json file to add the following entries
# it is a temporary workaround until the bug is fixed in Phero CLI
{
 "compilerOptions": {
   ...
   "rootDir": "src",
   "outDir": "dist"
 }
}
# Add Phero to your backend project
npx phero init server</pre>
<p>以上命令成功完成后，您将在<code>api/src</code>文件夹中拥有一个新的<code>phero.ts</code>文件。</p>
<pre class="language-typescript hljs"># api/src/phero.ts
import { createService } from '@phero/server'

async function helloWorld(name: string): Promise&lt;string&gt; {
  return `Hi there, ${name}!`
}

export const helloWorldService = createService({
  helloWorld
})</pre>
<p>生成的<code>Phero.ts</code>文件公开了一个<code>helloWorld</code>服务，并准备好供客户端使用。</p>
<h3 id="frontend-setup">前端设置</h3>
<p>让我们运行下面的脚本来设置客户端。我们创建了一个<code>app</code>子文件夹，但是它可以被命名为其他名称。费罗CLI可以扫描依赖关系，以确定项目是<code>phero-server</code>还是<code>phero-client</code>项目。</p>
<pre class="language-bash hljs"># bash script 
# from your project root directory, create a app subfolder 
mkdir app
cd ../app

# initialise a node app
npm init -y
npm install typescript --save-dev
npx tsc --init

# Add Phero to your frontend project:
npx phero init client</pre>
<p><code>phero init client</code>命令安装<code>@phero/client</code>并生成一个<code>Phero.ts</code>文件。</p>
<pre class="language-typescript hljs"># app/src/Phero.ts
import { PheroClient } from "./phero.generated";

const fetch = window.fetch.bind(this);
const client = new PheroClient(fetch);

async function main() {
  const message = await client.helloWorldService.helloWorld('Jim')
  console.log(message) // `Hi there, Jim!`
}

main()</pre>
<h3 id="run-cli-start-dev-environment">运行CLI启动开发环境</h3>
<p>现在我们可以运行Phero CLI来启动开发环境。</p>
<pre class="language-bash hljs"># back to the project root directory
cd ../
npx phero</pre>
<p>上述命令启动服务器，同时为前端(或多个前端)生成一个SDK。您应该会在控制台中看到以下输出:</p>
<figure id="attachment_146409" aria-describedby="caption-attachment-146409" class="wp-caption aligncenter"><img data-attachment-id="146409" data-permalink="https://blog.logrocket.com/phero-build-type-safe-full-stack-apps-with-typescript/attachment/console-output-phero-sdk/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/12/console-output-phero-sdk.png" data-orig-size="730,40" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="console-output-phero-sdk" data-image-description="" data-image-caption="&lt;p&gt;The output of the Phero SDK installation in the console&lt;/p&gt;&#10;" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/12/console-output-phero-sdk-300x16.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/12/console-output-phero-sdk.png" decoding="async" class="size-full wp-image-146409 jetpack-lazy-image" src="../Images/8b7ab5da2404cf6294077131bbf9f522.png" alt="The output of the Phero SDK installation in the console" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2022/12/console-output-phero-sdk.png 730w, https://blog.logrocket.com/wp-content/uploads/2022/12/console-output-phero-sdk-300x16.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2022/12/console-output-phero-sdk.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/12/console-output-phero-sdk.png"/><noscript><img data-lazy-fallback="1" data-attachment-id="146409" data-permalink="https://blog.logrocket.com/phero-build-type-safe-full-stack-apps-with-typescript/attachment/console-output-phero-sdk/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/12/console-output-phero-sdk.png" data-orig-size="730,40" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="console-output-phero-sdk" data-image-description="" data-image-caption="&lt;p&gt;The output of the Phero SDK installation in the console&lt;/p&gt;&#10;" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/12/console-output-phero-sdk-300x16.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/12/console-output-phero-sdk.png" decoding="async" loading="lazy" class="size-full wp-image-146409" src="../Images/8b7ab5da2404cf6294077131bbf9f522.png" alt="The output of the Phero SDK installation in the console" srcset="https://blog.logrocket.com/wp-content/uploads/2022/12/console-output-phero-sdk.png 730w, https://blog.logrocket.com/wp-content/uploads/2022/12/console-output-phero-sdk-300x16.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/12/console-output-phero-sdk.png"/></noscript><figcaption id="caption-attachment-146409" class="wp-caption-text">The output of the Phero SDK installation in the console</figcaption></figure>
<p>在前端项目中，会生成一个<code>phero.generated.ts </code>文件。它是用于连接到服务器存根的RPC客户端存根。顾名思义，它不应该手动更新。当CLI运行时，它会自动与任何服务器端更改同步。</p>
<p>虽然基本设置已经完成，但我们还不能运行客户端来证明它正在工作，因为我们还没有一个合适的客户端应用程序可以在浏览器中运行。</p>
<p>让我们构建一个React客户端应用程序来进行端到端测试。</p>
<h3 id="creating-react-client-app">创建React客户端应用程序</h3>
<p>运行以下命令来生成React应用程序的框架。</p>
<pre class="language-bash hljs">npx create-react-app react-app --template typescript</pre>
<p>然后，就可以如下图启动app了。</p>
<pre class="language-bash hljs">cd react-app
npm start</pre>
<p>现在我们有了一个工作的React应用程序，所以下一步是给它添加费罗。</p>
<pre class="language-bash hljs"># bash script
npx phero init client
cd .. # Back to project root directory
# run Phero CLI to start the dev environment
npx phero</pre>
<p>上面的命令将在React项目中生成<code>phero.generated.ts</code>文件。</p>
<p>最后一步是打开<code>src/App.tsx</code>，用下面的代码片段替换原来的代码:</p>
<pre class="language-typescript hljs">import { PheroClient } from './phero.generated';
import { useCallback, useEffect } from "react";

const phero = new PheroClient(window.fetch.bind(this))

function App() {
  const getHello = useCallback(async () =&gt; {
      const message = await phero.helloWorldService.helloWorld('Jim');
      console.log(message);
  }, [])

  useEffect(() =&gt; {
    getHello()
  }, [getHello])</pre>
<p>上面的代码片段将初始化一个<code>PheroClient</code>，并调用<code>helloWorldService.helloWorld</code>方法。</p>
<p>要验证应用程序是否正常工作，请打开<code><a href="http://localhost:3000/">http://localhost:3000/</a></code>并打开<a href="https://blog.logrocket.com/debugging-node-js-chrome-devtools/"> Chrome DevTools </a>。您可以在<strong>网络</strong>选项卡中看到控制台消息和客户端到服务器的RPC调用。</p>
<figure id="attachment_146414" aria-describedby="caption-attachment-146414" class="wp-caption aligncenter"><img data-attachment-id="146414" data-permalink="https://blog.logrocket.com/phero-build-type-safe-full-stack-apps-with-typescript/attachment/client-server-rpc-call-network-tab/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/12/client-server-rpc-call-network-tab.png" data-orig-size="730,166" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="client-server-rpc-call-network-tab" data-image-description="" data-image-caption="&lt;p&gt;The client-server RPC call as shown in the Network tab&lt;/p&gt;&#10;" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/12/client-server-rpc-call-network-tab-300x68.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/12/client-server-rpc-call-network-tab.png" decoding="async" class="size-full wp-image-146414 jetpack-lazy-image" src="../Images/74ae228cf89356a26618897b4a73953b.png" alt="The client-server RPC call as shown in the Network tab" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2022/12/client-server-rpc-call-network-tab.png 730w, https://blog.logrocket.com/wp-content/uploads/2022/12/client-server-rpc-call-network-tab-300x68.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2022/12/client-server-rpc-call-network-tab.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/12/client-server-rpc-call-network-tab.png"/><noscript><img data-lazy-fallback="1" data-attachment-id="146414" data-permalink="https://blog.logrocket.com/phero-build-type-safe-full-stack-apps-with-typescript/attachment/client-server-rpc-call-network-tab/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/12/client-server-rpc-call-network-tab.png" data-orig-size="730,166" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="client-server-rpc-call-network-tab" data-image-description="" data-image-caption="&lt;p&gt;The client-server RPC call as shown in the Network tab&lt;/p&gt;&#10;" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/12/client-server-rpc-call-network-tab-300x68.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/12/client-server-rpc-call-network-tab.png" decoding="async" loading="lazy" class="size-full wp-image-146414" src="../Images/74ae228cf89356a26618897b4a73953b.png" alt="The client-server RPC call as shown in the Network tab" srcset="https://blog.logrocket.com/wp-content/uploads/2022/12/client-server-rpc-call-network-tab.png 730w, https://blog.logrocket.com/wp-content/uploads/2022/12/client-server-rpc-call-network-tab-300x68.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/12/client-server-rpc-call-network-tab.png"/></noscript><figcaption id="caption-attachment-146414" class="wp-caption-text">The client-server RPC call as shown in the Network tab</figcaption></figure>
<p>你可以在<a href="https://github.com/sunnyy02/PheroDemo">的GitHub repo </a>中找到相关的源代码。</p>
<h2 id="error-handling-with-phero">用信息素处理错误</h2>
<p>使用Phero，我们可以在前端处理定制的服务器端错误，就像处理本地函数一样。</p>
<p>让我们继续前面的API例子。如果用户不能通过他们给定的用户ID被找到，我们希望在后端抛出一个<code>UserNotExistException</code>错误。</p>
<pre class="language-typescript hljs">class UserNotExistException extends Error {
  constructor(userId: number) {
    super()
  }
}
app.get("users/:userId", (req, res) =&gt; {
    const user = db.getById(userId);
    if(user === null) {
      throw new UserNotExistException(userId);
    }
    return user;    
});</pre>
<p>然后在前端，我们可以如下处理错误。请注意，<code>UserNotExistException</code>是由生成的费罗文件暴露在客户端的。</p>
<pre class="language-typescript hljs">import {
 PheroClient,
 UserNotExistException,
} from "./phero.generated"

const fetch = window.fetch.bind(this)
const client = new PheroClient(fetch)
 try {
   const user = await client.userService.getUser(1)
 } catch (error) {
   if (error instanceof UserNotExistException ) {
     console.log("User not found")
   } else {
     console.log("Unexpected error")
   }
 }</pre>
<p>同样，我们在用费罗处理错误时获得了类型安全。此外，<code>userId</code>在服务器端被填充为错误的属性，并且可以通过<code>error.userId</code>在客户端访问。</p>
<h2 id="deploying-production">部署到生产</h2>
<p>在本地开发环境中，默认的Phero服务器API在<code>port 3030</code>运行。当部署到更高的环境或生产环境时，您可能需要使用不同的端口号。与任何Node.js API一样，端口号可通过在运行时传入环境变量<code>PORT</code>或使用<code>.env</code>文件来配置。</p>
<p>例如，要在<code>port 8080</code>运行服务器API:</p>
<pre class="language-bash hljs">cd ./.build
PORT=8080 node index.js</pre>
<p>在非本地环境中，您可能还需要在客户端配置API URl。我们可以将URL存储在一个环境变量中，并将URl传递给<code>PheroClient</code>,如下所示。</p>
<pre class="language-typescript hljs">import { PheroClient } from "./phero.generated"
const client = new PheroClient(fetch, `${API_ROOT}`)</pre>
<p>要构建用于部署的服务器代码包，请运行下面的命令。</p>
<pre class="language-bash hljs">cd ./server
npx phero server export</pre>
<p>这将把包文件生成到<code>.build</code>目录中。可以用标准的Node.js命令启动服务器。</p>
<p>目前，费罗服务器可以运行在任何基于节点的服务器上。以下新的导出和部署功能可用于不同的云平台:</p>

<h2 id="migrating-existing-app-phero">迁移现有应用程序以使用费罗</h2>
<p>如果你想迁移一个现有的服务器应用程序来使用费罗，你可能要先重组你的费罗应用程序。</p>
<p>费罗没有太多限制。您只需要将<code>Phero.ts</code>定义为后端应用程序的入口点，并从费罗文件中导出您的服务。您可以使用任何基于TypeScript的框架来设计您的服务和功能。</p>
<p>假设我们需要将一个Node.js/Express API应用程序迁移到费罗。我们需要定义清晰的需要从前端调用的函数“组”。在Express中，您通常会将它们分组到“<code>Routers</code>”中。我们可以把这些组织转化成费罗的服务。您当前在这些路由器中拥有的所有路由都可以迁移到常规的TypeScript函数。</p>
<p>例如，该功能:</p>
<pre class="language-typescript hljs">router.post('/example-route', (req, res) =&gt; {
  const data: MyData = req.body

  res.send({ output: 123 })
})</pre>
<p>路由器迁移后会变成如下:</p>
<pre class="language-typescript hljs">async function exampleFunction(data: MyData): Promise&lt;{ output: number }&gt; {
  return { output: 123 }
}</pre>
<p>在设计新的费罗服务接口时，您应该考虑类型。如果你只使用像string和number这样的基本类型，那么Phero提供的类型安全对你来说可能是多余的。在Phero后端定义良好约束的类型将有助于您在前端检测编译时的错误。</p>
<h2>摘要</h2>
<p>费罗是后端和前端之间的类型安全粘合剂。这是在前端开发中确保更好的类型安全的可行解决方案。使用Phero，您可以从前端调用后端函数或处理后端错误，具有端到端的类型安全性。它会帮助你写出更简洁的代码，让你在重构中安心。</p>
<p>希望这篇文章对你有用。编码快乐！</p><div class="code-block code-block-21">
<div class="blog-plug inline-plug typescript-plug"><h2><a class="signup" href="https://lp.logrocket.com/blg/typescript-signup" target="_blank" rel="noopener noreferrer"> LogRocket </a>:全面了解您的网络和移动应用</h2>
<a href="https://lp.logrocket.com/blg/typescript-signup" class="signup" target="_blank" rel="noopener noreferrer"><img class="alignnone size-full wp-image-46 jetpack-lazy-image" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/><noscript><img data-lazy-fallback="1" class="alignnone size-full wp-image-46" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/></noscript></a>
<p>LogRocket 是一个前端应用程序监控解决方案，可以让您回放问题，就像问题发生在您自己的浏览器中一样。LogRocket不需要猜测错误发生的原因，也不需要向用户询问截图和日志转储，而是让您重放会话以快速了解哪里出错了。它可以与任何应用程序完美配合，不管是什么框架，并且有插件可以记录来自Redux、Vuex和@ngrx/store的额外上下文。</p>
<p>除了记录Redux操作和状态，LogRocket还记录控制台日志、JavaScript错误、堆栈跟踪、带有头+正文的网络请求/响应、浏览器元数据和自定义日志。它还使用DOM来记录页面上的HTML和CSS，甚至为最复杂的单页面和移动应用程序重新创建像素级完美视频。</p>
<a class="signup" href="https://lp.logrocket.com/blg/typescript-signup" target="_blank" rel="noopener noreferrer">Try it for free</a><p>.</p></div>
</div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
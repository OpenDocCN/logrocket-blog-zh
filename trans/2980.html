<html>
<head>
<title>Build strongly typed polymorphic components with React and TypeScript - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>用 React 和 TypeScript 构建强类型多态组件</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/build-strongly-typed-polymorphic-components-react-typescript/#0001-01-01">https://blog.logrocket.com/build-strongly-typed-polymorphic-components-react-typescript/#0001-01-01</a></blockquote><div><article class="article-post">
<p>在这篇详细的(解释性的)指南中，我将讨论如何用 TypeScript 构建强类型多态 React 组件。我们将涵盖以下部分:</p>

<p>如您所见，这相当长，所以可以随意跳过。如果你想跟着做，在我的 GitHub 上启动<a href="https://github.com/ohansemmanuel/polymorphic-react-component" target="_blank" rel="noopener">官方代码库</a>作为参考。</p>
<h2 id="real-world-examples-polymorphic-components">多态组件的真实例子</h2>
<p>有一个非零的机会，你已经使用了多态组件。开源<a href="https://blog.logrocket.com/build-component-library-react-typescript/" target="_blank" rel="noopener">组件库</a>通常实现某种多态组件。</p>
<p>让我们考虑一些你可能熟悉的:脉轮 UI <code>as</code>道具和 MUI <code>component</code>道具。</p>
<h3 id="chakra-uis-as-prop">查克拉 UI 的<code>as</code>道具</h3>
<p><img data-attachment-id="112870" data-permalink="https://blog.logrocket.com/build-strongly-typed-polymorphic-components-react-typescript/chakra-ui-2/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/05/chakra-ui.jpeg" data-orig-size="730,495" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;1&quot;}" data-image-title="Chakra UI" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/05/chakra-ui-300x203.jpeg" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/05/chakra-ui.jpeg" decoding="async" class="aligncenter size-full wp-image-112870 jetpack-lazy-image" src="../Images/e970b8dfb7f886b3ee300aa945d5ee53.png" alt="Chakra UI" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2022/05/chakra-ui.jpeg 730w, https://blog.logrocket.com/wp-content/uploads/2022/05/chakra-ui-300x203.jpeg 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2022/05/chakra-ui.jpeg?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/05/chakra-ui.jpeg"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="112870" data-permalink="https://blog.logrocket.com/build-strongly-typed-polymorphic-components-react-typescript/chakra-ui-2/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/05/chakra-ui.jpeg" data-orig-size="730,495" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;1&quot;}" data-image-title="Chakra UI" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/05/chakra-ui-300x203.jpeg" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/05/chakra-ui.jpeg" decoding="async" loading="lazy" class="aligncenter size-full wp-image-112870" src="../Images/e970b8dfb7f886b3ee300aa945d5ee53.png" alt="Chakra UI" srcset="https://blog.logrocket.com/wp-content/uploads/2022/05/chakra-ui.jpeg 730w, https://blog.logrocket.com/wp-content/uploads/2022/05/chakra-ui-300x203.jpeg 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/05/chakra-ui.jpeg"/></noscript>
<p><a href="https://chakra-ui.com/" target="_blank" rel="noopener">查克拉 UI </a>如何实现多态道具？答案是通过暴露一个<code>as</code>道具。将<code>as</code>属性传递给一个组件，以确定它最终应该呈现什么容器元素。</p>
<p><a href="http://chakra-ui.com/docs/components/layout/box#as-prop"> <img data-attachment-id="112872" data-permalink="https://blog.logrocket.com/build-strongly-typed-polymorphic-components-react-typescript/chakra-ui-as-prop/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/05/chakra-ui-as-prop.png" data-orig-size="730,346" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Chakra UI as prop" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/05/chakra-ui-as-prop-300x142.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/05/chakra-ui-as-prop.png" decoding="async" class="aligncenter size-full wp-image-112872 jetpack-lazy-image" src="../Images/cdb05b0b601e5be305d795d40b69ccc5.png" alt="Chakra UI As Prop" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2022/05/chakra-ui-as-prop.png 730w, https://blog.logrocket.com/wp-content/uploads/2022/05/chakra-ui-as-prop-300x142.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2022/05/chakra-ui-as-prop.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/05/chakra-ui-as-prop.png"/> <noscript> <img data-lazy-fallback="1" data-attachment-id="112872" data-permalink="https://blog.logrocket.com/build-strongly-typed-polymorphic-components-react-typescript/chakra-ui-as-prop/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/05/chakra-ui-as-prop.png" data-orig-size="730,346" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Chakra UI as prop" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/05/chakra-ui-as-prop-300x142.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/05/chakra-ui-as-prop.png" decoding="async" loading="lazy" class="aligncenter size-full wp-image-112872" src="../Images/cdb05b0b601e5be305d795d40b69ccc5.png" alt="Chakra UI As Prop" srcset="https://blog.logrocket.com/wp-content/uploads/2022/05/chakra-ui-as-prop.png 730w, https://blog.logrocket.com/wp-content/uploads/2022/05/chakra-ui-as-prop-300x142.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/05/chakra-ui-as-prop.png"/> </noscript></a></p>
<p>要使用<code>as</code>属性，您需要做的就是将它传递给组件，在本例中是<code>Box</code>:</p>
<pre class="language-javascript hljs">&lt;Box as='button' borderRadius='md' bg='tomato' color='white' px={4} h={8}&gt;
  Button
&lt;/Box&gt;
</pre>
<p>现在，组件将呈现一个<code>button</code>元素。</p>
<p><img data-attachment-id="112874" data-permalink="https://blog.logrocket.com/build-strongly-typed-polymorphic-components-react-typescript/box-component-rendered-as-button/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/05/box-component-rendered-as-button.png" data-orig-size="730,271" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="The Box component rendered as a button" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/05/box-component-rendered-as-button-300x111.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/05/box-component-rendered-as-button.png" decoding="async" class="aligncenter size-full wp-image-112874 jetpack-lazy-image" src="../Images/a9ff7c9e3cfb01e1059911ce318cbe2e.png" alt="The Box Component Rendered As A Button" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2022/05/box-component-rendered-as-button.png 730w, https://blog.logrocket.com/wp-content/uploads/2022/05/box-component-rendered-as-button-300x111.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2022/05/box-component-rendered-as-button.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/05/box-component-rendered-as-button.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="112874" data-permalink="https://blog.logrocket.com/build-strongly-typed-polymorphic-components-react-typescript/box-component-rendered-as-button/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/05/box-component-rendered-as-button.png" data-orig-size="730,271" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="The Box component rendered as a button" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/05/box-component-rendered-as-button-300x111.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/05/box-component-rendered-as-button.png" decoding="async" loading="lazy" class="aligncenter size-full wp-image-112874" src="../Images/a9ff7c9e3cfb01e1059911ce318cbe2e.png" alt="The Box Component Rendered As A Button" srcset="https://blog.logrocket.com/wp-content/uploads/2022/05/box-component-rendered-as-button.png 730w, https://blog.logrocket.com/wp-content/uploads/2022/05/box-component-rendered-as-button-300x111.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/05/box-component-rendered-as-button.png"/></noscript>
<p>如果你把<code>as</code>道具改成了<code>h1</code>:</p>
<pre class="language-javascript hljs">&lt;Box as="h1"&gt; Hello &lt;/Box&gt;
</pre>
<p>现在，<code>Box</code>组件呈现一个<code>h1</code>:</p>
<p><img data-attachment-id="112876" data-permalink="https://blog.logrocket.com/build-strongly-typed-polymorphic-components-react-typescript/box-component-rendered-as-h1/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/05/box-component-rendered-as-h1.png" data-orig-size="730,238" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="The Box component rendered as an h1" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/05/box-component-rendered-as-h1-300x98.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/05/box-component-rendered-as-h1.png" decoding="async" class="aligncenter size-full wp-image-112876 jetpack-lazy-image" src="../Images/943fb125b2ffb960cfae7fb3da07fa2d.png" alt="The Box Component Rendered As An H1" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2022/05/box-component-rendered-as-h1.png 730w, https://blog.logrocket.com/wp-content/uploads/2022/05/box-component-rendered-as-h1-300x98.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2022/05/box-component-rendered-as-h1.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/05/box-component-rendered-as-h1.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="112876" data-permalink="https://blog.logrocket.com/build-strongly-typed-polymorphic-components-react-typescript/box-component-rendered-as-h1/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/05/box-component-rendered-as-h1.png" data-orig-size="730,238" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="The Box component rendered as an h1" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/05/box-component-rendered-as-h1-300x98.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/05/box-component-rendered-as-h1.png" decoding="async" loading="lazy" class="aligncenter size-full wp-image-112876" src="../Images/943fb125b2ffb960cfae7fb3da07fa2d.png" alt="The Box Component Rendered As An H1" srcset="https://blog.logrocket.com/wp-content/uploads/2022/05/box-component-rendered-as-h1.png 730w, https://blog.logrocket.com/wp-content/uploads/2022/05/box-component-rendered-as-h1-300x98.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/05/box-component-rendered-as-h1.png"/></noscript>
<p>那是多态组件在起作用！它可以被渲染成完全独特的元素，只需传递一个道具。</p>
<h3 id="muis-component-prop">梅的<code>component</code>道具</h3>
<p><img data-attachment-id="112878" data-permalink="https://blog.logrocket.com/build-strongly-typed-polymorphic-components-react-typescript/mui-component-prop/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/05/MUI-component-prop.jpeg" data-orig-size="730,495" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;1&quot;}" data-image-title="MUI’s Component prop" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/05/MUI-component-prop-300x203.jpeg" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/05/MUI-component-prop.jpeg" decoding="async" class="aligncenter size-full wp-image-112878 jetpack-lazy-image" src="../Images/6b3c87bb73f388418a2fc445818b0f67.png" alt="MUI's Component Prop" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2022/05/MUI-component-prop.jpeg 730w, https://blog.logrocket.com/wp-content/uploads/2022/05/MUI-component-prop-300x203.jpeg 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2022/05/MUI-component-prop.jpeg?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/05/MUI-component-prop.jpeg"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="112878" data-permalink="https://blog.logrocket.com/build-strongly-typed-polymorphic-components-react-typescript/mui-component-prop/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/05/MUI-component-prop.jpeg" data-orig-size="730,495" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;1&quot;}" data-image-title="MUI’s Component prop" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/05/MUI-component-prop-300x203.jpeg" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/05/MUI-component-prop.jpeg" decoding="async" loading="lazy" class="aligncenter size-full wp-image-112878" src="../Images/6b3c87bb73f388418a2fc445818b0f67.png" alt="MUI's Component Prop" srcset="https://blog.logrocket.com/wp-content/uploads/2022/05/MUI-component-prop.jpeg 730w, https://blog.logrocket.com/wp-content/uploads/2022/05/MUI-component-prop-300x203.jpeg 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/05/MUI-component-prop.jpeg"/></noscript>
<p>与 Chakra UI 类似，<a href="https://blog.logrocket.com/definitive-guide-react-material/" target="_blank" rel="noopener"> MUI </a>允许一个名为<code>component</code>的多态道具，其实现方式类似:将它传递给一个组件，并声明想要呈现的元素或定制组件。</p>
<p>下面是官方文件中的一个例子:</p>
<p><a href="https://mui.com/material-ui/guides/composition/#component-prop"> <img data-attachment-id="112880" data-permalink="https://blog.logrocket.com/build-strongly-typed-polymorphic-components-react-typescript/mui-component-prop-2/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/05/MUI-component-prop-1.jpeg" data-orig-size="730,495" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;1&quot;}" data-image-title="The MUI Component prop" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/05/MUI-component-prop-1-300x203.jpeg" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/05/MUI-component-prop-1.jpeg" decoding="async" class="aligncenter size-full wp-image-112880 jetpack-lazy-image" src="../Images/e7b880a805fd9da35dea9f6e9c26b761.png" alt="The MUI Component Prop" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2022/05/MUI-component-prop-1.jpeg 730w, https://blog.logrocket.com/wp-content/uploads/2022/05/MUI-component-prop-1-300x203.jpeg 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2022/05/MUI-component-prop-1.jpeg?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/05/MUI-component-prop-1.jpeg"/> <noscript> <img data-lazy-fallback="1" data-attachment-id="112880" data-permalink="https://blog.logrocket.com/build-strongly-typed-polymorphic-components-react-typescript/mui-component-prop-2/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/05/MUI-component-prop-1.jpeg" data-orig-size="730,495" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;1&quot;}" data-image-title="The MUI Component prop" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/05/MUI-component-prop-1-300x203.jpeg" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/05/MUI-component-prop-1.jpeg" decoding="async" loading="lazy" class="aligncenter size-full wp-image-112880" src="../Images/e7b880a805fd9da35dea9f6e9c26b761.png" alt="The MUI Component Prop" srcset="https://blog.logrocket.com/wp-content/uploads/2022/05/MUI-component-prop-1.jpeg 730w, https://blog.logrocket.com/wp-content/uploads/2022/05/MUI-component-prop-1-300x203.jpeg 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/05/MUI-component-prop-1.jpeg"/> </noscript></a></p>
<pre class="language-javascript hljs">&lt;List component="nav"&gt;
  &lt;ListItem button&gt;
    &lt;ListItemText primary="Trash" /&gt;
  &lt;/ListItem&gt;
&lt;/List&gt;
</pre>
<p><code>List</code>被传递一个<code>nav</code>的组件道具；当这个被渲染时，它将渲染一个<code>nav</code>容器元素。</p>
<p>另一个用户可能使用相同的组件，但不是用于导航；相反，他们可能想要呈现一个待办事项列表:</p>
<pre class="language-javascript hljs">&lt;List component="ol"&gt;
  ...
&lt;/List&gt;
</pre>
<p>在这种情况下，<code>List</code>将呈现一个有序列表<code>ol</code>元素。</p>
<p>说到灵活性！请参见多态组件用例的<a href="https://github.com/ohansemmanuel/polymorphic-react-component/blob/master/use-cases.pdf" target="_blank" rel="noopener">摘要。</a></p>
<p>正如您将在本文接下来的部分中看到的，多态组件非常强大。除了接受元素类型的道具之外，它们还可以接受自定义组件作为道具。</p>
<p>这将在本文的下一节讨论。现在，让我们开始构建我们的第一个多态组件！</p>
<h2 id="building-simple-polymorphic-component">构建简单的多态组件</h2>
<p>与您所想的相反，构建您的第一个多态组件非常简单。下面是一个基本实现:</p>
<pre class="language-javascript hljs">const MyComponent = ({ as, children }) =&gt; {
  const Component = as || "span";

  return &lt;Component&gt;{children}&lt;/Component&gt;;
};
</pre>
<p>这里注意多态道具<code>as</code>类似于查克拉 UI 的。这是我们用来控制多态组件的渲染元素的道具。</p>
<p>其次，注意<code>as</code>道具不是直接渲染的。以下是错误的:</p>
<pre class="language-javascript hljs">const MyComponent = ({ as, children }) =&gt; {
  // wrong render below 👇 
  return &lt;as&gt;{children}&lt;/as&gt;;
};
</pre>
<p>当<a href="https://reactjs.org/docs/jsx-in-depth.html#choosing-the-type-at-runtime" target="_blank" rel="noopener">在运行时</a>呈现一个元素类型的时候，必须先把它赋给一个大写的变量，然后再呈现这个大写的变量。</p>
<p><img data-attachment-id="112883" data-permalink="https://blog.logrocket.com/build-strongly-typed-polymorphic-components-react-typescript/using-capitalized-variable/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/05/using-capitalized-variable.png" data-orig-size="730,232" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Using a capitalized variable" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/05/using-capitalized-variable-300x95.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/05/using-capitalized-variable.png" decoding="async" class="aligncenter size-full wp-image-112883 jetpack-lazy-image" src="../Images/5f9ed41ae4b8d81974bbbc146cd99cfb.png" alt="Using A Capitalized Variable" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2022/05/using-capitalized-variable.png 730w, https://blog.logrocket.com/wp-content/uploads/2022/05/using-capitalized-variable-300x95.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2022/05/using-capitalized-variable.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/05/using-capitalized-variable.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="112883" data-permalink="https://blog.logrocket.com/build-strongly-typed-polymorphic-components-react-typescript/using-capitalized-variable/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/05/using-capitalized-variable.png" data-orig-size="730,232" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Using a capitalized variable" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/05/using-capitalized-variable-300x95.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/05/using-capitalized-variable.png" decoding="async" loading="lazy" class="aligncenter size-full wp-image-112883" src="../Images/5f9ed41ae4b8d81974bbbc146cd99cfb.png" alt="Using A Capitalized Variable" srcset="https://blog.logrocket.com/wp-content/uploads/2022/05/using-capitalized-variable.png 730w, https://blog.logrocket.com/wp-content/uploads/2022/05/using-capitalized-variable-300x95.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/05/using-capitalized-variable.png"/></noscript>
<p>现在，您可以继续使用该组件，如下所示:</p>
<pre class="language-javascript hljs">&lt;MyComponent as="button"&gt;Hello Polymorphic!&lt;MyComponent&gt;
&lt;MyComponent as="div"&gt;Hello Polymorphic!&lt;/MyComponent&gt;
&lt;MyComponent as="span"&gt;Hello Polymorphic!&lt;/MyComponent&gt;
&lt;MyComponent as="em"&gt;Hello Polymorphic!&lt;/MyComponent&gt;
</pre>
<p>注意，不同的<code>as</code>道具被传递给上面的渲染组件。</p>
<p><img data-attachment-id="112885" data-permalink="https://blog.logrocket.com/build-strongly-typed-polymorphic-components-react-typescript/different-rendered-elements/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/05/different-rendered-elements.jpeg" data-orig-size="730,488" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;1&quot;}" data-image-title="The different rendered elements" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/05/different-rendered-elements-300x201.jpeg" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/05/different-rendered-elements.jpeg" decoding="async" class="aligncenter size-full wp-image-112885 jetpack-lazy-image" src="../Images/84b03409c0f9b3b3413d326fe0fcd4e6.png" alt="The Different Rendered Elements" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2022/05/different-rendered-elements.jpeg 730w, https://blog.logrocket.com/wp-content/uploads/2022/05/different-rendered-elements-300x201.jpeg 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2022/05/different-rendered-elements.jpeg?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/05/different-rendered-elements.jpeg"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="112885" data-permalink="https://blog.logrocket.com/build-strongly-typed-polymorphic-components-react-typescript/different-rendered-elements/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/05/different-rendered-elements.jpeg" data-orig-size="730,488" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;1&quot;}" data-image-title="The different rendered elements" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/05/different-rendered-elements-300x201.jpeg" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/05/different-rendered-elements.jpeg" decoding="async" loading="lazy" class="aligncenter size-full wp-image-112885" src="../Images/84b03409c0f9b3b3413d326fe0fcd4e6.png" alt="The Different Rendered Elements" srcset="https://blog.logrocket.com/wp-content/uploads/2022/05/different-rendered-elements.jpeg 730w, https://blog.logrocket.com/wp-content/uploads/2022/05/different-rendered-elements-300x201.jpeg 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/05/different-rendered-elements.jpeg"/></noscript>
<h2 id="problems-simple-implementation">这个简单实现的问题是</h2>
<p>上一节中的实现虽然相当标准，但有许多缺点。让我们来探索其中的一些。</p>
<h3 id="as-prop-receive-invalid-html-elements">1.<code>as</code>属性可以接收无效的 HTML 元素</h3>
<p>目前，用户可以编写以下内容:</p>
<pre class="language-javascript hljs">&lt;MyComponent as="emmanuel"&gt;Hello Wrong Element&lt;/MyComponent&gt;
</pre>
<p>这里传的<code>as</code>道具是<code>emmanuel</code>。Emmanuel 显然是一个错误的 HTML 元素，但是浏览器也试图渲染这个元素。</p>
<p><img data-attachment-id="112887" data-permalink="https://blog.logrocket.com/build-strongly-typed-polymorphic-components-react-typescript/rendering-a-wrong-html-element-type/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/05/rendering-a-wrong-html-element-type.png" data-orig-size="730,321" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Rendering a wrong HTML element type" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/05/rendering-a-wrong-html-element-type-300x132.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/05/rendering-a-wrong-html-element-type.png" decoding="async" class="aligncenter size-full wp-image-112887 jetpack-lazy-image" src="../Images/f3a4824ee27fcadaa15628ee91fe0c19.png" alt="Rendering A Wrong HTML Element Type" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2022/05/rendering-a-wrong-html-element-type.png 730w, https://blog.logrocket.com/wp-content/uploads/2022/05/rendering-a-wrong-html-element-type-300x132.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2022/05/rendering-a-wrong-html-element-type.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/05/rendering-a-wrong-html-element-type.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="112887" data-permalink="https://blog.logrocket.com/build-strongly-typed-polymorphic-components-react-typescript/rendering-a-wrong-html-element-type/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/05/rendering-a-wrong-html-element-type.png" data-orig-size="730,321" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Rendering a wrong HTML element type" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/05/rendering-a-wrong-html-element-type-300x132.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/05/rendering-a-wrong-html-element-type.png" decoding="async" loading="lazy" class="aligncenter size-full wp-image-112887" src="../Images/f3a4824ee27fcadaa15628ee91fe0c19.png" alt="Rendering A Wrong HTML Element Type" srcset="https://blog.logrocket.com/wp-content/uploads/2022/05/rendering-a-wrong-html-element-type.png 730w, https://blog.logrocket.com/wp-content/uploads/2022/05/rendering-a-wrong-html-element-type-300x132.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/05/rendering-a-wrong-html-element-type.png"/></noscript>
<p>理想的开发体验是在开发过程中显示出某种错误。例如，用户可能打了一个简单的错别字——<code>divv</code>而不是<code>div</code>——却没有得到任何错误的提示。</p>
<h3 id="wrong-attributes-passed-valid-elements">2.可以为有效元素传递错误的属性</h3>
<p>考虑以下组件用法:</p>
<pre class="language-javascript hljs">&lt;MyComponent as="span" href="https://www.google.com"&gt;
   Hello Wrong Attribute
&lt;/MyComponent&gt;
</pre>
<p>消费者可以将一个<code>span</code>元素传递给<code>as</code>道具，以及一个<code>href</code>道具。</p>
<p>这在技术上是无效的。一个<code>span</code>元素不(也不应该)接受一个<code>href</code>属性。这是无效的 HTML 语法。然而，我们构建的组件的消费者仍然可以继续编写，并且在开发过程中不会出现错误。</p>
<h3 id="no-attribute-support">3.没有属性支持！</h3>
<p>再次考虑简单的实现:</p>
<pre class="language-javascript hljs">const MyComponent = ({ as, children }) =&gt; {
  const Component = as || "span";

  return &lt;Component&gt;{children}&lt;/Component&gt;;
};
</pre>
<p>这个组件接受的唯一道具是<code>as</code>和<code>children</code>，没有其他的。甚至对有效的<code>as</code>元素属性也没有属性支持，也就是说，如果<code>as</code>是锚元素<code>a</code>，我们也应该支持向组件传递一个<code>href</code>。</p>
<pre class="language-javascript hljs">&lt;MyComponent as="a" href="..."&gt;A link &lt;/MyComponent&gt;
</pre>
<p>即使在上面的例子中传递了<code>href</code>,组件实现也没有收到其他的支持。只有<code>as</code>和<code>children</code>被解构。</p>
<p>您最初的想法可能是继续将每个其他属性传递给组件，如下所示:</p>
<pre class="language-javascript hljs">const MyComponent = ({ as, children, ...rest }) =&gt; {
  const Component = as || "span";

  return &lt;Component {...rest}&gt;{children}&lt;/Component&gt;;
};
</pre>
<p>这似乎是一个体面的解决方案，但现在它突出了上面提到的第二个问题。错误的属性现在也会传递给组件。</p>
<p>请考虑以下情况:</p>
<pre class="language-javascript hljs">&lt;MyComponent as="span" href="https://www.google.com"&gt;
   Hello Wrong Attribute
&lt;/MyComponent&gt;
</pre>
<p>并注意最终呈现的标记:</p>
<p><img data-attachment-id="112889" data-permalink="https://blog.logrocket.com/build-strongly-typed-polymorphic-components-react-typescript/span-element-with-href-attribute/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/05/span-element-with-href-attribute.png" data-orig-size="730,441" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="A span element with an href attribute" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/05/span-element-with-href-attribute-300x181.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/05/span-element-with-href-attribute.png" decoding="async" class="aligncenter size-full wp-image-112889 jetpack-lazy-image" src="../Images/bf2387151da3eb5b58e78fc0dec2e339.png" alt="A Span Element With An Href Attribute" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2022/05/span-element-with-href-attribute.png 730w, https://blog.logrocket.com/wp-content/uploads/2022/05/span-element-with-href-attribute-300x181.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2022/05/span-element-with-href-attribute.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/05/span-element-with-href-attribute.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="112889" data-permalink="https://blog.logrocket.com/build-strongly-typed-polymorphic-components-react-typescript/span-element-with-href-attribute/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/05/span-element-with-href-attribute.png" data-orig-size="730,441" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="A span element with an href attribute" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/05/span-element-with-href-attribute-300x181.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/05/span-element-with-href-attribute.png" decoding="async" loading="lazy" class="aligncenter size-full wp-image-112889" src="../Images/bf2387151da3eb5b58e78fc0dec2e339.png" alt="A Span Element With An Href Attribute" srcset="https://blog.logrocket.com/wp-content/uploads/2022/05/span-element-with-href-attribute.png 730w, https://blog.logrocket.com/wp-content/uploads/2022/05/span-element-with-href-attribute-300x181.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/05/span-element-with-href-attribute.png"/></noscript>
<p>带有<code>href</code>的<code>span</code>是无效的 HTML。</p>
<h3 id="why-is-this-bad">为什么这样不好？</h3>
<p>总的来说，我们简单实现的当前问题很糟糕，因为:</p>
<ul>
<li>它提供了糟糕的开发者体验</li>
<li>它不是类型安全的。虫子可以(也将会)爬进来</li>
</ul>
<p>我们如何解决这些问题？需要明确的是，这里没有魔杖可以挥舞。然而，我们将利用 TypeScript 来确保您构建强类型多态组件。</p>
<p>完成后，使用您的组件的开发人员将避免上述运行时错误，而是在开发或构建时发现它们——这都要感谢 TypeScript。</p>
<h2 id="how-to-use-typescript-build-strongly-typed-polymorphic-components-react">如何在 React 中使用 TypeScript 构建强类型多态组件</h2>
<p>如果您正在阅读本文，前提条件是您已经了解一些 TypeScript——至少是基础知识。如果你不知道什么是 TypeScript，我强烈建议你先阅读一下这个文档。</p>
<p>在本节中，我们将使用 TypeScript 来解决上述问题，并构建强类型多态组件。</p>
<p>我们首先要满足的前两个要求包括:</p>
<ul>
<li><code>as</code>属性不应该接收无效的 HTML 元素字符串</li>
<li>不应为有效元素传递错误的属性</li>
</ul>
<p>在下一节中，我们将介绍 TypeScript 泛型，以使我们的解决方案更加健壮、对开发人员更友好、更适合生产。</p>
<h3 id="ensuring-as-prop-only-receives-valid-html-element-strings">确保<code>as</code> prop 只接收有效的 HTML 元素字符串</h3>
<p>这是我们目前的解决方案:</p>
<pre class="language-javascript hljs">const MyComponent = ({ as, children }) =&gt; {
  const Component = as || "span";

  return &lt;Component&gt;{children}&lt;/Component&gt;;
};
</pre>
<p>为了使本指南的下一节更加实用，我们将把组件的名称从<code>MyComponent</code>改为<code>Text</code>，并假设我们正在构建一个多态的<code>Text</code>组件。</p>
<pre class="language-javascript hljs">const Text = ({ as, children }) =&gt; {
  const Component = as || "span";

  return &lt;Component&gt;{children}&lt;/Component&gt;;
};
</pre>
<p>现在，根据你对泛型的了解，很明显我们最好用泛型来表示<code>as</code>，也就是说，基于用户传入的变量类型。</p>
<p><img data-attachment-id="112892" data-permalink="https://blog.logrocket.com/build-strongly-typed-polymorphic-components-react-typescript/as-prop/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/05/as-prop.png" data-orig-size="730,342" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="The as prop" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/05/as-prop-300x141.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/05/as-prop.png" decoding="async" class="aligncenter size-full wp-image-112892 jetpack-lazy-image" src="../Images/4740027cd7533d1d64f651f3a72cec47.png" alt="The As Prop" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2022/05/as-prop.png 730w, https://blog.logrocket.com/wp-content/uploads/2022/05/as-prop-300x141.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2022/05/as-prop.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/05/as-prop.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="112892" data-permalink="https://blog.logrocket.com/build-strongly-typed-polymorphic-components-react-typescript/as-prop/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/05/as-prop.png" data-orig-size="730,342" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="The as prop" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/05/as-prop-300x141.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/05/as-prop.png" decoding="async" loading="lazy" class="aligncenter size-full wp-image-112892" src="../Images/4740027cd7533d1d64f651f3a72cec47.png" alt="The As Prop" srcset="https://blog.logrocket.com/wp-content/uploads/2022/05/as-prop.png 730w, https://blog.logrocket.com/wp-content/uploads/2022/05/as-prop-300x141.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/05/as-prop.png"/></noscript>
<p>让我们继续，并按如下方式迈出第一步:</p>
<pre class="language-typescript hljs">export const Text = &lt;C&gt;({
  as,
  children,
}: {
  as?: C;
  children: React.ReactNode;
}) =&gt; {
  const Component = as || "span";

  return &lt;Component&gt;{children}&lt;/Component&gt;;
};
</pre>
<p>注意泛型<code>C</code>是如何定义的，然后在属性<code>as</code>的类型定义中传递。</p>
<p>然而，如果您编写了这个看似完美的代码，您将会看到 TypeScript 用比您想要的更多的弯曲的红线喊出许多错误🤷‍♀️</p>
<p><img data-attachment-id="112894" data-permalink="https://blog.logrocket.com/build-strongly-typed-polymorphic-components-react-typescript/jsx-generic-error/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/05/jsx-generic-error.png" data-orig-size="730,579" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="The JSX generic error" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/05/jsx-generic-error-300x238.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/05/jsx-generic-error.png" decoding="async" class="aligncenter size-full wp-image-112894 jetpack-lazy-image" src="../Images/5d06856dcdbd51fd57cfce86a50ae016.png" alt="The JSX Generic Error" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2022/05/jsx-generic-error.png 730w, https://blog.logrocket.com/wp-content/uploads/2022/05/jsx-generic-error-300x238.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2022/05/jsx-generic-error.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/05/jsx-generic-error.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="112894" data-permalink="https://blog.logrocket.com/build-strongly-typed-polymorphic-components-react-typescript/jsx-generic-error/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/05/jsx-generic-error.png" data-orig-size="730,579" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="The JSX generic error" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/05/jsx-generic-error-300x238.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/05/jsx-generic-error.png" decoding="async" loading="lazy" class="aligncenter size-full wp-image-112894" src="../Images/5d06856dcdbd51fd57cfce86a50ae016.png" alt="The JSX Generic Error" srcset="https://blog.logrocket.com/wp-content/uploads/2022/05/jsx-generic-error.png 730w, https://blog.logrocket.com/wp-content/uploads/2022/05/jsx-generic-error-300x238.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/05/jsx-generic-error.png"/></noscript>
<p>这里发生的是<code>.tsx</code>文件中泛型的<a href="https://stackoverflow.com/questions/32308370/what-is-the-syntax-for-typescript-arrow-functions-with-generics?" target="_blank" rel="noopener">语法中的一个缺陷。有两种方法可以解决这个问题。</a></p>
<h3 id="add-comma-after-generic-declaration">1.在泛型声明后添加一个逗号</h3>
<p>这是声明多个泛型的语法。一旦这样做了，TypeScript 编译器就会清楚地理解您的意图，错误就会被排除。</p>
<pre class="language-typescript hljs">// note the comma after "C" below 👇
export const Text = &lt;C,&gt;({
  as,
  children,
}: {
  as?: C;
  children: React.ReactNode;
}) =&gt; {
  const Component = as || "span";

  return &lt;Component&gt;{children}&lt;/Component&gt;;
};</pre>
<h3 id="constrain-generic">2.约束类属</h3>
<p>第二种选择是在您认为合适的时候约束类属。对于初学者，您可以使用如下的<code>unknown</code>类型:</p>
<pre class="language-typescript hljs">// note the extends keyword below 👇
export const Text = &lt;C extends unknown&gt;({
  as,
  children,
}: {
  as?: C;
  children: React.ReactNode;
}) =&gt; {
  const Component = as || "span";

  return &lt;Component&gt;{children}&lt;/Component&gt;;
};</pre>
<p>现在，我将坚持第二个解决方案，因为它更接近我们的最终解决方案。不过，在大多数情况下，我使用多重通用语法，只添加一个逗号。</p>
<p>然而，对于我们当前的解决方案，我们得到了另一个 TypeScript 错误:</p>
<blockquote><p>JSX 元素类型“Component”没有任何构造或调用签名。ts(2604)</p></blockquote>
<p><img data-attachment-id="112896" data-permalink="https://blog.logrocket.com/build-strongly-typed-polymorphic-components-react-typescript/no-construct-or-call-error/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/05/no-construct-or-call-error.png" data-orig-size="730,579" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="No construct or call error" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/05/no-construct-or-call-error-300x238.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/05/no-construct-or-call-error.png" decoding="async" class="aligncenter size-full wp-image-112896 jetpack-lazy-image" src="../Images/77623ab1f5a70fb3c46fb36f930f58a0.png" alt="No Construct Or Call Error" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2022/05/no-construct-or-call-error.png 730w, https://blog.logrocket.com/wp-content/uploads/2022/05/no-construct-or-call-error-300x238.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2022/05/no-construct-or-call-error.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/05/no-construct-or-call-error.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="112896" data-permalink="https://blog.logrocket.com/build-strongly-typed-polymorphic-components-react-typescript/no-construct-or-call-error/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/05/no-construct-or-call-error.png" data-orig-size="730,579" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="No construct or call error" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/05/no-construct-or-call-error-300x238.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/05/no-construct-or-call-error.png" decoding="async" loading="lazy" class="aligncenter size-full wp-image-112896" src="../Images/77623ab1f5a70fb3c46fb36f930f58a0.png" alt="No Construct Or Call Error" srcset="https://blog.logrocket.com/wp-content/uploads/2022/05/no-construct-or-call-error.png 730w, https://blog.logrocket.com/wp-content/uploads/2022/05/no-construct-or-call-error-300x238.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/05/no-construct-or-call-error.png"/></noscript>
<p>这类似于我们使用<code>echoLength</code>函数时的错误。就像访问未知变量类型的<code>length</code>属性一样，这里可以这么说:试图将任何泛型类型呈现为有效的 React 组件是没有意义的。</p>
<p>我们只需要约束泛型来适应有效的 React 元素类型。</p>
<p>为了实现这一点，我们将利用内部 React 类型:<code>React.ElementType</code>，并确保泛型被约束为适合该类型:</p>
<pre class="language-typescript hljs">// look just after the extends keyword 👇
export const Text = &lt;C extends React.ElementType&gt;({
  as,
  children,
}: {
  as?: C;
  children: React.ReactNode;
}) =&gt; {
  const Component = as || "span";

  return &lt;Component&gt;{children}&lt;/Component&gt;;
};
</pre>
<p>请注意，如果您使用的是旧版本的 React，您可能需要导入新版本的 React，如下所示:</p>
<pre class="language-bash hljs">import React from 'react'
</pre>
<p>有了这个，我们就不会再有错误了！</p>
<p>现在，如果您继续按如下方式使用这个组件，它会工作得很好:</p>
<pre class="language-javascript hljs">&lt;Text as="div"&gt;Hello Text world&lt;/Text&gt;
</pre>
<p>然而，如果您传递一个无效的<code>as</code>属性，您现在将得到一个适当的 TypeScript 错误。考虑下面的例子:</p>
<pre class="language-javascript hljs">&lt;Text as="emmanuel"&gt;Hello Text world&lt;/Text&gt;
</pre>
<p>并抛出错误:</p>
<blockquote><p>类型“emmanuel”不能赋给类型“ElementType | undefined”。</p></blockquote>
<p><img data-attachment-id="112898" data-permalink="https://blog.logrocket.com/build-strongly-typed-polymorphic-components-react-typescript/type-emmanuel-not-assginable-error/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/05/type-emmanuel-not-assginable-error.jpeg" data-orig-size="730,579" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;1&quot;}" data-image-title="Type emmanuel is not assignable error" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/05/type-emmanuel-not-assginable-error-300x238.jpeg" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/05/type-emmanuel-not-assginable-error.jpeg" decoding="async" class="aligncenter size-full wp-image-112898 jetpack-lazy-image" src="../Images/6cd2419345effb5e7bbe8d1c23cd94c6.png" alt="Type Emmanuel Is Not Assignable Error" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2022/05/type-emmanuel-not-assginable-error.jpeg 730w, https://blog.logrocket.com/wp-content/uploads/2022/05/type-emmanuel-not-assginable-error-300x238.jpeg 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2022/05/type-emmanuel-not-assginable-error.jpeg?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/05/type-emmanuel-not-assginable-error.jpeg"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="112898" data-permalink="https://blog.logrocket.com/build-strongly-typed-polymorphic-components-react-typescript/type-emmanuel-not-assginable-error/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/05/type-emmanuel-not-assginable-error.jpeg" data-orig-size="730,579" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;1&quot;}" data-image-title="Type emmanuel is not assignable error" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/05/type-emmanuel-not-assginable-error-300x238.jpeg" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/05/type-emmanuel-not-assginable-error.jpeg" decoding="async" loading="lazy" class="aligncenter size-full wp-image-112898" src="../Images/6cd2419345effb5e7bbe8d1c23cd94c6.png" alt="Type Emmanuel Is Not Assignable Error" srcset="https://blog.logrocket.com/wp-content/uploads/2022/05/type-emmanuel-not-assginable-error.jpeg 730w, https://blog.logrocket.com/wp-content/uploads/2022/05/type-emmanuel-not-assginable-error-300x238.jpeg 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/05/type-emmanuel-not-assginable-error.jpeg"/></noscript><br/>
This is excellent! We now have a solution that doesn’t accept gibberish for the <code>as</code> prop and will also prevent against nasty typos, e.g., <code>divv</code> instead of <code>div</code>.
<p>这是一个更好的开发者体验！</p>
<h2 id="handling-valid-component-attributes-typescript-generics">用 TypeScript 泛型处理有效的组件属性</h2>
<p>在解决第二个用例时，您将会体会到泛型的真正强大之处。首先，让我们了解我们在这里试图完成什么。</p>
<p>一旦我们收到一个通用的<code>as</code>类型，我们希望确保传递给我们的组件的剩余属性是相关的，基于<code>as</code>属性。</p>
<p>例如，如果一个用户传入了一个<code>img</code>的<code>as</code>道具，我们希望<code>href</code>同样是一个有效的道具！</p>
<p><img data-attachment-id="112900" data-permalink="https://blog.logrocket.com/build-strongly-typed-polymorphic-components-react-typescript/as-prop-and-href/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/05/as-prop-and-href.png" data-orig-size="730,349" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="As prop and href" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/05/as-prop-and-href-300x143.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/05/as-prop-and-href.png" decoding="async" class="aligncenter size-full wp-image-112900 jetpack-lazy-image" src="../Images/3985285f9fc772a8203898a05d45fa75.png" alt="As Prop And Href" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2022/05/as-prop-and-href.png 730w, https://blog.logrocket.com/wp-content/uploads/2022/05/as-prop-and-href-300x143.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2022/05/as-prop-and-href.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/05/as-prop-and-href.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="112900" data-permalink="https://blog.logrocket.com/build-strongly-typed-polymorphic-components-react-typescript/as-prop-and-href/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/05/as-prop-and-href.png" data-orig-size="730,349" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="As prop and href" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/05/as-prop-and-href-300x143.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/05/as-prop-and-href.png" decoding="async" loading="lazy" class="aligncenter size-full wp-image-112900" src="../Images/3985285f9fc772a8203898a05d45fa75.png" alt="As Prop And Href" srcset="https://blog.logrocket.com/wp-content/uploads/2022/05/as-prop-and-href.png 730w, https://blog.logrocket.com/wp-content/uploads/2022/05/as-prop-and-href-300x143.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/05/as-prop-and-href.png"/></noscript>
<p>为了让您了解我们是如何实现这一目标的，请看一下我们解决方案的当前状态:</p>
<pre class="language-typescript hljs">export const Text = &lt;C extends React.ElementType&gt;({
  as,
  children,
}: {
  as?: C;
  children: React.ReactNode;
}) =&gt; {
  const Component = as || "span";

  return &lt;Component&gt;{children}&lt;/Component&gt;;
};
</pre>
<p>该组件的属性现在由对象类型表示:</p>
<pre class="language-typescript hljs">{
  as?: C;
  children: React.ReactNode;
}
</pre>
<p>在伪代码中，我们希望如下所示:</p>
<pre class="language-typescript hljs">{
  as?: C;
  children: React.ReactNode;
} &amp; {
  ...otherValidPropsBasedOnTheValueOfAs
}
</pre>
<p><img data-attachment-id="112904" data-permalink="https://blog.logrocket.com/build-strongly-typed-polymorphic-components-react-typescript/pseudocode/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/05/pseudocode.png" data-orig-size="730,294" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Pseudocode" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/05/pseudocode-300x121.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/05/pseudocode.png" decoding="async" class="aligncenter size-full wp-image-112904 jetpack-lazy-image" src="../Images/ed99b08c6dd8f60beacaba30c52b982f.png" alt="Pseudocode" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2022/05/pseudocode.png 730w, https://blog.logrocket.com/wp-content/uploads/2022/05/pseudocode-300x121.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2022/05/pseudocode.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/05/pseudocode.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="112904" data-permalink="https://blog.logrocket.com/build-strongly-typed-polymorphic-components-react-typescript/pseudocode/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/05/pseudocode.png" data-orig-size="730,294" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Pseudocode" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/05/pseudocode-300x121.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/05/pseudocode.png" decoding="async" loading="lazy" class="aligncenter size-full wp-image-112904" src="../Images/ed99b08c6dd8f60beacaba30c52b982f.png" alt="Pseudocode" srcset="https://blog.logrocket.com/wp-content/uploads/2022/05/pseudocode.png 730w, https://blog.logrocket.com/wp-content/uploads/2022/05/pseudocode-300x121.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/05/pseudocode.png"/></noscript>
<p>这个要求足以让人抓住救命稻草。我们不可能编写一个基于<code>as</code>的值来确定适当类型的函数，手动列出一个联合类型并不明智。</p>
<p>那么，如果有一个从<code>React</code>提供的类型作为一个“函数”,根据你传递给它的内容返回有效的元素类型呢？</p>
<p>在介绍解决方案之前，让我们先做一点重构。让我们把组件的道具抽成一个单独的类型:</p>
<pre class="language-typescript hljs">// 👇 See TextProps pulled out below 
type TextProps&lt;C extends React.ElementType&gt; = {
  as?: C;
  children: React.ReactNode;
} 

export const Text = &lt;C extends React.ElementType&gt;({
  as,
  children,
}: TextProps&lt;C&gt;) =&gt; { // 👈 see TextProps used 
  const Component = as || "span";
  return &lt;Component&gt;{children}&lt;/Component&gt;;
};
</pre>
<p>这里重要的是注意泛型是如何传递给<code>TextProps&lt;C&gt;</code>的。类似于 JavaScript 中的函数调用——但有尖括号。</p>
<p>这里的魔术棒是利用如下所示的<code>React.ComponentPropsWithoutRef</code>类型:</p>
<pre class="language-typescript hljs">type TextProps&lt;C extends React.ElementType&gt; = {
  as?: C;
  children: React.ReactNode;
} &amp; React.ComponentPropsWithoutRef&lt;C&gt;; // 👈 look here 

export const Text = &lt;C extends React.ElementType&gt;({
  as,
  children,
}: TextProps&lt;C&gt;) =&gt; {
  const Component = as || "span";
  return &lt;Component&gt;{children}&lt;/Component&gt;;
};
</pre>
<p>请注意，我们在这里引入了一个交叉点。本质上，我们说，<code>TextProps</code>的类型是一个包含<code>as</code>、<code>children</code>和其他一些由<code>React.ComponentPropsWithoutRef</code>表示的类型的对象类型。</p>
<p><img data-attachment-id="112906" data-permalink="https://blog.logrocket.com/build-strongly-typed-polymorphic-components-react-typescript/react-componentpropswithoutref/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/05/react-componentpropswithoutref.png" data-orig-size="730,294" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="React.ComponentPropsWithoutRef" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/05/react-componentpropswithoutref-300x121.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/05/react-componentpropswithoutref.png" decoding="async" class="aligncenter size-full wp-image-112906 jetpack-lazy-image" src="../Images/6dc76d978b355056a9047d2a703c4810.png" alt="React.ComponentPropsWithoutRef" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2022/05/react-componentpropswithoutref.png 730w, https://blog.logrocket.com/wp-content/uploads/2022/05/react-componentpropswithoutref-300x121.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2022/05/react-componentpropswithoutref.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/05/react-componentpropswithoutref.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="112906" data-permalink="https://blog.logrocket.com/build-strongly-typed-polymorphic-components-react-typescript/react-componentpropswithoutref/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/05/react-componentpropswithoutref.png" data-orig-size="730,294" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="React.ComponentPropsWithoutRef" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/05/react-componentpropswithoutref-300x121.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/05/react-componentpropswithoutref.png" decoding="async" loading="lazy" class="aligncenter size-full wp-image-112906" src="../Images/6dc76d978b355056a9047d2a703c4810.png" alt="React.ComponentPropsWithoutRef" srcset="https://blog.logrocket.com/wp-content/uploads/2022/05/react-componentpropswithoutref.png 730w, https://blog.logrocket.com/wp-content/uploads/2022/05/react-componentpropswithoutref-300x121.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/05/react-componentpropswithoutref.png"/></noscript>
<p>如果您阅读代码，可能会明白这里发生了什么。</p>
<p>基于由泛型<code>C</code>表示的<code>as</code>的类型，<code>React.componentPropsWithoutRef</code>将返回与传递给<code>as</code>属性的字符串属性相关的有效组件属性。</p>
<p>还有更重要的一点需要注意。</p>
<p><img data-attachment-id="112908" data-permalink="https://blog.logrocket.com/build-strongly-typed-polymorphic-components-react-typescript/different-componentprops-type-variants/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/05/different-componentprops-type-variants.png" data-orig-size="730,579" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Different ComponentProps type variants" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/05/different-componentprops-type-variants-300x238.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/05/different-componentprops-type-variants.png" decoding="async" class="aligncenter size-full wp-image-112908 jetpack-lazy-image" src="../Images/1591997b1b5654b3943ca546ff6dc004.png" alt="Different ComponentProps Type Variants" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2022/05/different-componentprops-type-variants.png 730w, https://blog.logrocket.com/wp-content/uploads/2022/05/different-componentprops-type-variants-300x238.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2022/05/different-componentprops-type-variants.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/05/different-componentprops-type-variants.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="112908" data-permalink="https://blog.logrocket.com/build-strongly-typed-polymorphic-components-react-typescript/different-componentprops-type-variants/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/05/different-componentprops-type-variants.png" data-orig-size="730,579" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Different ComponentProps type variants" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/05/different-componentprops-type-variants-300x238.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/05/different-componentprops-type-variants.png" decoding="async" loading="lazy" class="aligncenter size-full wp-image-112908" src="../Images/1591997b1b5654b3943ca546ff6dc004.png" alt="Different ComponentProps Type Variants" srcset="https://blog.logrocket.com/wp-content/uploads/2022/05/different-componentprops-type-variants.png 730w, https://blog.logrocket.com/wp-content/uploads/2022/05/different-componentprops-type-variants-300x238.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/05/different-componentprops-type-variants.png"/></noscript>
<p>如果你刚开始打字并依赖编辑器的智能感知，你会发现有三种类型的<code>React.ComponentProps...</code>:</p>
<ol>
<li><code>React.ComponentProps</code></li>
<li><code>React.ComponentPropsWithRef</code></li>
<li><code>React.ComponentPropsWithoutRef</code></li>
</ol>
<p>如果您尝试使用第一个选项<code>ComponentProps</code>，您会看到一个相关的注释，内容如下:</p>
<blockquote><p>如果<code>ref</code>被转发，则<em>优先于<code>ComponentPropsWithRef</code>，如果不支持 refs，则优先于<code>ComponentPropsWithoutRef</code>。</em></p></blockquote>
<p><img data-attachment-id="112910" data-permalink="https://blog.logrocket.com/build-strongly-typed-polymorphic-components-react-typescript/prefer-componentpropswithref-or-without/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/05/prefer-componentpropswithref-or-without.png" data-orig-size="730,579" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Note to prefer ComponentPropsWithRef or ComponentPropsWithoutRef" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/05/prefer-componentpropswithref-or-without-300x238.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/05/prefer-componentpropswithref-or-without.png" decoding="async" class="aligncenter size-full wp-image-112910 jetpack-lazy-image" src="../Images/323e9db3fdb8b0fdb91f94f864c82fc8.png" alt="Note To Prefer ComponentPropsWithRef Or ComponentPropsWithoutRef" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2022/05/prefer-componentpropswithref-or-without.png 730w, https://blog.logrocket.com/wp-content/uploads/2022/05/prefer-componentpropswithref-or-without-300x238.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2022/05/prefer-componentpropswithref-or-without.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/05/prefer-componentpropswithref-or-without.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="112910" data-permalink="https://blog.logrocket.com/build-strongly-typed-polymorphic-components-react-typescript/prefer-componentpropswithref-or-without/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/05/prefer-componentpropswithref-or-without.png" data-orig-size="730,579" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Note to prefer ComponentPropsWithRef or ComponentPropsWithoutRef" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/05/prefer-componentpropswithref-or-without-300x238.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/05/prefer-componentpropswithref-or-without.png" decoding="async" loading="lazy" class="aligncenter size-full wp-image-112910" src="../Images/323e9db3fdb8b0fdb91f94f864c82fc8.png" alt="Note To Prefer ComponentPropsWithRef Or ComponentPropsWithoutRef" srcset="https://blog.logrocket.com/wp-content/uploads/2022/05/prefer-componentpropswithref-or-without.png 730w, https://blog.logrocket.com/wp-content/uploads/2022/05/prefer-componentpropswithref-or-without-300x238.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/05/prefer-componentpropswithref-or-without.png"/></noscript>
<p>这正是我们所做的。现在，我们将忽略支持<code>ref</code>道具的用例，坚持使用<code>ComponentPropsWithoutRef</code>。</p>
<p>现在，让我们试一试解决方案！</p>
<p>如果您继续错误地使用这个组件，例如，将一个有效的<code>as</code>道具与其他不兼容的道具一起传递，您将会得到一个错误。</p>
<pre class="language-typescript hljs">&lt;Text as="div" href="www.google.com"&gt;Hello Text world&lt;/Text&gt;
</pre>
<p>值<code>div</code>对于<code>as</code>属性完全有效，但是<code>div</code>不应该有<code>href</code>属性。</p>
<p>这是错误的，并且被 TypeScript 用错误:<code>Property 'href' does not exist on type ...</code>正确地捕捉到。</p>
<p><img data-attachment-id="112913" data-permalink="https://blog.logrocket.com/build-strongly-typed-polymorphic-components-react-typescript/property-href-doesnt-exist-error/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/05/property-href-doesnt-exist-error.png" data-orig-size="730,579" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Property href does not exist error" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/05/property-href-doesnt-exist-error-300x238.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/05/property-href-doesnt-exist-error.png" decoding="async" class="aligncenter size-full wp-image-112913 jetpack-lazy-image" src="../Images/3c9b8e54cef98ce82eb7798c79c11c19.png" alt="Property Href Does Not Exist Error" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2022/05/property-href-doesnt-exist-error.png 730w, https://blog.logrocket.com/wp-content/uploads/2022/05/property-href-doesnt-exist-error-300x238.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2022/05/property-href-doesnt-exist-error.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/05/property-href-doesnt-exist-error.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="112913" data-permalink="https://blog.logrocket.com/build-strongly-typed-polymorphic-components-react-typescript/property-href-doesnt-exist-error/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/05/property-href-doesnt-exist-error.png" data-orig-size="730,579" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Property href does not exist error" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/05/property-href-doesnt-exist-error-300x238.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/05/property-href-doesnt-exist-error.png" decoding="async" loading="lazy" class="aligncenter size-full wp-image-112913" src="../Images/3c9b8e54cef98ce82eb7798c79c11c19.png" alt="Property Href Does Not Exist Error" srcset="https://blog.logrocket.com/wp-content/uploads/2022/05/property-href-doesnt-exist-error.png 730w, https://blog.logrocket.com/wp-content/uploads/2022/05/property-href-doesnt-exist-error-300x238.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/05/property-href-doesnt-exist-error.png"/></noscript>
<p>这太棒了！我们有一个更好、更强大的解决方案。</p>
<p>最后，确保<a href="https://blog.logrocket.com/solving-prop-drilling-react-apps/" target="_blank" rel="noopener">将其他道具向下</a>传递给渲染元素:</p>
<pre class="language-typescript hljs">type TextProps&lt;C extends React.ElementType&gt; = {
  as?: C;
  children: React.ReactNode;
} &amp; React.ComponentPropsWithoutRef&lt;C&gt;; 

export const Text = &lt;C extends React.ElementType&gt;({
  as,
  children,
  ...restProps, // 👈 look here
}: TextProps&lt;C&gt;) =&gt; {
  const Component = as || "span";

  // see restProps passed 👇
  return &lt;Component {...restProps}&gt;{children}&lt;/Component&gt;;
};
</pre>
<p>我们继续吧。</p>
<h2 id="handling-default-as-attributes">处理默认<code>as</code>属性</h2>
<p>再次考虑我们当前的解决方案:</p>
<pre class="language-typescript hljs">export const Text = &lt;C extends React.ElementType&gt;({
  as,
  children,
  ...restProps
}: TextProps&lt;C&gt;) =&gt; {
  const Component = as || "span"; // 👈 look here

  return &lt;Component {...restProps}&gt;{children}&lt;/Component&gt;;
};
</pre>
<p>特别是，如果省略了<code>as</code>属性，要注意缺省元素是在哪里提供的。</p>
<pre class="language-typescript hljs">const Component = as || "span"
</pre>
<p>这在 JavaScript 世界中通过实现得到了恰当的体现:如果<code>as</code>是可选的，它将默认为<code>span</code>。</p>
<p>问题是，在<code>as</code>没有通过的情况下，TypeScript 如何处理这种情况？我们是否同样传递了一个默认类型？</p>
<p>答案是否定的，但下面是一个实际的例子。假设您继续使用<code>Text</code>组件，如下所示:</p>
<pre>&lt;Text&gt;Hello Text world&lt;/Text&gt;
</pre>
<p>请注意，我们在这里没有通过<code>as</code>道具。TypeScript 会知道这个组件的有效属性吗？</p>
<p>让我们继续添加一个<code>href</code>:</p>
<pre class="language-typescript hljs">&lt;Text href="https://www.google.com"&gt;Hello Text world&lt;/Text&gt;
</pre>
<p>如果你继续这样做，你不会得到任何错误。那很糟糕。</p>
<p>一个<code>span</code>不应该接收一个<code>href</code>属性。虽然我们在实现中默认使用了一个<code>span</code>，但是 TypeScript 并不知道这个默认值。让我们用一个简单、通用的默认赋值来解决这个问题:</p>
<pre class="language-typescript hljs">type TextProps&lt;C extends React.ElementType&gt; = {
  as?: C;
  children: React.ReactNode;
} &amp; React.ComponentPropsWithoutRef&lt;C&gt;;

/**
* See default below. TS will treat the rendered element as a 
span and provide typings accordingly
*/
export const Text = &lt;C extends React.ElementType = "span"&gt;({
  as,
  children,
  ...restProps
}: TextProps&lt;C&gt;) =&gt; {
  const Component = as || "span";
  return &lt;Component {...restProps}&gt;{children}&lt;/Component&gt;;
};
</pre>
<p>下面突出了重要的一点:</p>
<pre class="language-typescript hljs">&lt;C extends React.ElementType = "span"&gt;
</pre>
<p>瞧啊！我们之前的例子现在应该在没有<code>as</code>道具的情况下将<code>href</code>传递给<code>Text</code>组件时抛出一个错误。</p>
<p>错误应为:<code>Property 'href' does not exist on type ...</code>。</p>
<p><img data-attachment-id="112916" data-permalink="https://blog.logrocket.com/build-strongly-typed-polymorphic-components-react-typescript/property-href-doesnt-exist-error-2/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/05/property-href-doesnt-exist-error-1.png" data-orig-size="730,579" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Property href does not exist on type" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/05/property-href-doesnt-exist-error-1-300x238.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/05/property-href-doesnt-exist-error-1.png" decoding="async" class="aligncenter size-full wp-image-112916 jetpack-lazy-image" src="../Images/dcb7c844cf16ae0ba17685131512b3aa.png" alt="Property Href Does Not Exist On Type" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2022/05/property-href-doesnt-exist-error-1.png 730w, https://blog.logrocket.com/wp-content/uploads/2022/05/property-href-doesnt-exist-error-1-300x238.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2022/05/property-href-doesnt-exist-error-1.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/05/property-href-doesnt-exist-error-1.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="112916" data-permalink="https://blog.logrocket.com/build-strongly-typed-polymorphic-components-react-typescript/property-href-doesnt-exist-error-2/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/05/property-href-doesnt-exist-error-1.png" data-orig-size="730,579" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Property href does not exist on type" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/05/property-href-doesnt-exist-error-1-300x238.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/05/property-href-doesnt-exist-error-1.png" decoding="async" loading="lazy" class="aligncenter size-full wp-image-112916" src="../Images/dcb7c844cf16ae0ba17685131512b3aa.png" alt="Property Href Does Not Exist On Type" srcset="https://blog.logrocket.com/wp-content/uploads/2022/05/property-href-doesnt-exist-error-1.png 730w, https://blog.logrocket.com/wp-content/uploads/2022/05/property-href-doesnt-exist-error-1-300x238.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/05/property-href-doesnt-exist-error-1.png"/></noscript>
<h2 id="making-component-reusable-props">使组件及其道具可重用</h2>
<p>我们当前的解决方案比我们开始时的要好得多。为自己走到这一步而感到欣慰——从这里开始，事情只会变得更加有趣。</p>
<p>本节中要满足的用例在现实世界中非常适用。如果您正在构建某种组件，那么该组件很有可能还会接受该组件特有的一些特定道具。</p>
<p>我们当前的解决方案考虑了<code>as</code>、<code>children</code>以及基于<code>as</code>道具的其他组件道具。然而，如果我们想让这个组件处理自己的道具呢？</p>
<p>让我们来做点实际的。我们将让<code>Text</code>组件接收一个<code>color</code>道具。这里的<code>color</code>要么是彩虹的颜色，要么是<code>black</code>。</p>
<p>我们将继续进行，并表示如下:</p>
<pre class="language-typescript hljs">type Rainbow =
  | "red"
  | "orange"
  | "yellow"
  | "green"
  | "blue"
  | "indigo"
  | "violet";
</pre>
<p>接下来，我们必须如下定义<code>TextProps</code>对象中的<code>color</code>属性:</p>
<pre class="language-typescript hljs">type TextProps&lt;C extends React.ElementType&gt; = {
  as?: C;
  color?: Rainbow | "black"; // 👈 look here
  children: React.ReactNode;
} &amp; React.ComponentPropsWithoutRef&lt;C&gt;;
</pre>
<p>在我们继续之前，让我们进行一点重构。让我们用一个<code>Props</code>对象来表示<code>Text</code>组件的实际道具，并且在<code>TextProps</code>对象中只输入我们组件特有的道具。</p>
<p>这将变得显而易见，您将在下面看到:</p>
<pre class="language-typescript hljs">// new "Props" type
type Props &lt;C extends React.ElementType&gt; = TextProps&lt;C&gt;

export const Text = &lt;C extends React.ElementType = "span"&gt;({
  as,
  children,
  ...restProps,
}: Props&lt;C&gt;) =&gt; {
  const Component = as || "span";
  return &lt;Component {...restProps}&gt;{children}&lt;/Component&gt;;
};
</pre>
<p>现在我们来清理一下<code>TextProps</code>:</p>
<pre class="language-typescript hljs">// before 
type TextProps&lt;C extends React.ElementType&gt; = {
  as?: C;
  color?: Rainbow | "black"; // 👈 look here
  children: React.ReactNode;
} &amp; React.ComponentPropsWithoutRef&lt;C&gt;;

// after
type TextProps&lt;C extends React.ElementType&gt; = {
  as?: C;
  color?: Rainbow | "black";
};
</pre>
<p>现在，<code>TextProps</code>应该只包含特定于我们的<code>Text</code>组件的道具:<code>as</code>和<code>color</code>。</p>
<p>我们现在必须更新<code>Props</code>的定义，以包含我们已经从<code>TextProps</code>中移除的类型，即<code>children</code>和<code>React.ComponentPropsWithoutRef&lt;C&gt;</code>。</p>
<p>对于<code>children</code>道具，我们将利用<code>React.PropsWithChildren</code>道具。</p>
<p><img data-attachment-id="112918" data-permalink="https://blog.logrocket.com/build-strongly-typed-polymorphic-components-react-typescript/propswithchildren-type/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/05/propswithchildren-type.png" data-orig-size="730,306" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="The PropsWithChildren type" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/05/propswithchildren-type-300x126.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/05/propswithchildren-type.png" decoding="async" class="aligncenter size-full wp-image-112918 jetpack-lazy-image" src="../Images/ca4f78c6569d727d8bf00f50c68fce0a.png" alt="The PropsWithChildren Type" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2022/05/propswithchildren-type.png 730w, https://blog.logrocket.com/wp-content/uploads/2022/05/propswithchildren-type-300x126.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2022/05/propswithchildren-type.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/05/propswithchildren-type.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="112918" data-permalink="https://blog.logrocket.com/build-strongly-typed-polymorphic-components-react-typescript/propswithchildren-type/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/05/propswithchildren-type.png" data-orig-size="730,306" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="The PropsWithChildren type" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/05/propswithchildren-type-300x126.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/05/propswithchildren-type.png" decoding="async" loading="lazy" class="aligncenter size-full wp-image-112918" src="../Images/ca4f78c6569d727d8bf00f50c68fce0a.png" alt="The PropsWithChildren Type" srcset="https://blog.logrocket.com/wp-content/uploads/2022/05/propswithchildren-type.png 730w, https://blog.logrocket.com/wp-content/uploads/2022/05/propswithchildren-type-300x126.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/05/propswithchildren-type.png"/></noscript>
<p>很容易推理出来。您将组件道具传递给它，它将为您注入子道具定义:</p>
<pre class="language-typescript hljs">type Props &lt;C extends React.ElementType&gt; = 
React.PropsWithChildren&lt;TextProps&lt;C&gt;&gt;
</pre>
<p>注意我们如何使用尖括号；这是传递泛型的语法。本质上，<code>React.PropsWithChildren</code>接受你的组件属性作为一个类属，并用<code>children</code>属性增加它。太棒了。</p>
<p>对于<code>React.ComponentPropsWithoutRef&lt;C&gt;</code>，我们将继续利用这里的交集类型:</p>
<pre class="language-typescript hljs">type Props &lt;C extends React.ElementType&gt; = 
React.PropsWithChildren&lt;TextProps&lt;C&gt;&gt; &amp; 
React.ComponentPropsWithoutRef&lt;C&gt;
</pre>
<p>这是完整的当前解决方案:</p>
<pre class="language-typescript hljs">type Rainbow =
  | "red"
  | "orange"
  | "yellow"
  | "green"
  | "blue"
  | "indigo"
  | "violet";

type TextProps&lt;C extends React.ElementType&gt; = {
  as?: C;
  color?: Rainbow | "black";
};

type Props &lt;C extends React.ElementType&gt; = 
React.PropsWithChildren&lt;TextProps&lt;C&gt;&gt; &amp; 
React.ComponentPropsWithoutRef&lt;C&gt;

export const Text = &lt;C extends React.ElementType = "span"&gt;({
  as,
  children,
}: Props&lt;C&gt;) =&gt; {
  const Component = as || "span";
  return &lt;Component&gt; {children} &lt;/Component&gt;;
};
</pre>
<p>我知道这些可能感觉很多，但是当你仔细看的时候就会明白了。它实际上只是把你到目前为止学到的所有东西放在一起！</p>
<p>完成这个必要的重构后，我们现在可以继续我们的解决方案了。我们现在所拥有的实际上是可行的。我们已经显式地输入了<code>color</code>属性，您可以如下使用它:</p>
<pre class="language-typescript hljs">&lt;Text color="violet"&gt;Hello world&lt;/Text&gt;
</pre>
<h2 id="strictly-omitting-generic-component-props">严格省略通用组件属性</h2>
<p>只有一件事让我不太舒服:<code>color</code>对许多 HTML 标签来说也是一个有效的属性，HTML5 之前也是如此。因此，如果我们从类型定义中移除了<code>color</code>，它将被接受为任何有效的字符串。</p>
<p>见下文:</p>
<pre class="language-typescript hljs">type TextProps&lt;C extends React.ElementType&gt; = {
  as?: C;
  // remove color from the definition here
};
</pre>
<p><img data-attachment-id="112920" data-permalink="https://blog.logrocket.com/build-strongly-typed-polymorphic-components-react-typescript/removing-color-type-definition/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/05/removing-color-type-definition.png" data-orig-size="730,579" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Removing the color type definition" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/05/removing-color-type-definition-300x238.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/05/removing-color-type-definition.png" decoding="async" class="aligncenter size-full wp-image-112920 jetpack-lazy-image" src="../Images/43725560639c1f34e4a6c5aabfce7995.png" alt="Removing The Color Type Definition" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2022/05/removing-color-type-definition.png 730w, https://blog.logrocket.com/wp-content/uploads/2022/05/removing-color-type-definition-300x238.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2022/05/removing-color-type-definition.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/05/removing-color-type-definition.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="112920" data-permalink="https://blog.logrocket.com/build-strongly-typed-polymorphic-components-react-typescript/removing-color-type-definition/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/05/removing-color-type-definition.png" data-orig-size="730,579" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Removing the color type definition" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/05/removing-color-type-definition-300x238.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/05/removing-color-type-definition.png" decoding="async" loading="lazy" class="aligncenter size-full wp-image-112920" src="../Images/43725560639c1f34e4a6c5aabfce7995.png" alt="Removing The Color Type Definition" srcset="https://blog.logrocket.com/wp-content/uploads/2022/05/removing-color-type-definition.png 730w, https://blog.logrocket.com/wp-content/uploads/2022/05/removing-color-type-definition-300x238.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/05/removing-color-type-definition.png"/></noscript>
<p>现在，如果你继续像以前一样使用<code>Text</code>，它同样有效:</p>
<pre class="language-typescript hljs">&lt;Text color="violet"&gt;Hello world&lt;/Text&gt;
</pre>
<p>这里唯一的区别是它是如何被输入的。<code>color</code>现在由以下定义表示:</p>
<pre class="language-typescript hljs">color?: string | undefined
</pre>
<p><img data-attachment-id="112922" data-permalink="https://blog.logrocket.com/build-strongly-typed-polymorphic-components-react-typescript/default-color-type/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/05/default-color-type.png" data-orig-size="730,579" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="The default color type" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/05/default-color-type-300x238.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/05/default-color-type.png" decoding="async" class="aligncenter size-full wp-image-112922 jetpack-lazy-image" src="../Images/0d7c741721e444beac1b90f7dabd70df.png" alt="The Default Color Type" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2022/05/default-color-type.png 730w, https://blog.logrocket.com/wp-content/uploads/2022/05/default-color-type-300x238.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2022/05/default-color-type.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/05/default-color-type.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="112922" data-permalink="https://blog.logrocket.com/build-strongly-typed-polymorphic-components-react-typescript/default-color-type/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/05/default-color-type.png" data-orig-size="730,579" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="The default color type" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/05/default-color-type-300x238.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/05/default-color-type.png" decoding="async" loading="lazy" class="aligncenter size-full wp-image-112922" src="../Images/0d7c741721e444beac1b90f7dabd70df.png" alt="The Default Color Type" srcset="https://blog.logrocket.com/wp-content/uploads/2022/05/default-color-type.png 730w, https://blog.logrocket.com/wp-content/uploads/2022/05/default-color-type-300x238.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/05/default-color-type.png"/></noscript>
<p>同样，这不是我们在类型中写的定义！</p>
<p>这是默认的 HTML 类型，其中<code>color</code>是大多数 HTML 元素的有效属性。参见<a href="https://stackoverflow.com/questions/67142430/why-color-appears-as-html-attribute-on-a-div" target="_blank" rel="noopener">堆栈溢出问题</a>了解更多上下文。</p>
<h3 id="two-potential-solutions">两种可能的解决方案</h3>
<p>现在，有两条路可以走。第一个是保留我们的初始解决方案，其中我们明确声明了<code>color</code> prop:</p>
<pre class="language-typescript hljs">type TextProps&lt;C extends React.ElementType&gt; = {
  as?: C;
  color?: Rainbow | "black"; // 👈 look here
};
</pre>
<p>第二个选项可以说提供了更多的类型安全。为了实现这一点，您必须意识到前面的默认<code>color</code>定义来自于哪里:T1。这是在<code>as</code>类型的基础上增加的其他道具。</p>
<p>因此，有了这些信息，我们可以显式地从<code>React.ComponentPropsWithoutRef&lt;C&gt;</code>中删除组件类型中存在的任何定义。</p>
<p>在实际操作之前，这可能很难理解，所以让我们一步一步来。</p>
<p>如前所述，<code>React.ComponentPropsWithoutRef&lt;C&gt;</code>包含基于<code>as</code>类型的所有其他有效道具，例如<code>href</code>、<code>color</code>等。，其中这些类型都有自己的定义，例如，<code>color?: string | undefined</code>等。：</p>
<p><img data-attachment-id="112924" data-permalink="https://blog.logrocket.com/build-strongly-typed-polymorphic-components-react-typescript/componentpropswithoutref-type/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/05/componentpropswithoutref-type.png" data-orig-size="730,364" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="The ComponentPropsWithoutRef type" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/05/componentpropswithoutref-type-300x150.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/05/componentpropswithoutref-type.png" decoding="async" class="aligncenter size-full wp-image-112924 jetpack-lazy-image" src="../Images/ccd21ecfeeba11a2ba2ad41d393e9f2e.png" alt="The ComponentPropsWithoutRef Type" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2022/05/componentpropswithoutref-type.png 730w, https://blog.logrocket.com/wp-content/uploads/2022/05/componentpropswithoutref-type-300x150.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2022/05/componentpropswithoutref-type.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/05/componentpropswithoutref-type.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="112924" data-permalink="https://blog.logrocket.com/build-strongly-typed-polymorphic-components-react-typescript/componentpropswithoutref-type/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/05/componentpropswithoutref-type.png" data-orig-size="730,364" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="The ComponentPropsWithoutRef type" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/05/componentpropswithoutref-type-300x150.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/05/componentpropswithoutref-type.png" decoding="async" loading="lazy" class="aligncenter size-full wp-image-112924" src="../Images/ccd21ecfeeba11a2ba2ad41d393e9f2e.png" alt="The ComponentPropsWithoutRef Type" srcset="https://blog.logrocket.com/wp-content/uploads/2022/05/componentpropswithoutref-type.png 730w, https://blog.logrocket.com/wp-content/uploads/2022/05/componentpropswithoutref-type-300x150.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/05/componentpropswithoutref-type.png"/></noscript>
<p>有可能存在于<code>React.ComponentPropsWithoutRef&lt;C&gt;</code>中的一些值也存在于我们的组件 props 类型定义中。在我们的例子中，<code>color</code>存在于两者之中！</p>
<p><img data-attachment-id="112926" data-permalink="https://blog.logrocket.com/build-strongly-typed-polymorphic-components-react-typescript/componentpropswithoutref-and-textprops/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/05/componentpropswithoutref-and-textprops.png" data-orig-size="730,402" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="ComponentPropsWithoutRef and TextProps" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/05/componentpropswithoutref-and-textprops-300x165.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/05/componentpropswithoutref-and-textprops.png" decoding="async" class="aligncenter size-full wp-image-112926 jetpack-lazy-image" src="../Images/defa8258a163827ed38c46eb62375ca1.png" alt="ComponentPropsWithoutRef And TextProps" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2022/05/componentpropswithoutref-and-textprops.png 730w, https://blog.logrocket.com/wp-content/uploads/2022/05/componentpropswithoutref-and-textprops-300x165.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2022/05/componentpropswithoutref-and-textprops.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/05/componentpropswithoutref-and-textprops.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="112926" data-permalink="https://blog.logrocket.com/build-strongly-typed-polymorphic-components-react-typescript/componentpropswithoutref-and-textprops/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/05/componentpropswithoutref-and-textprops.png" data-orig-size="730,402" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="ComponentPropsWithoutRef and TextProps" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/05/componentpropswithoutref-and-textprops-300x165.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/05/componentpropswithoutref-and-textprops.png" decoding="async" loading="lazy" class="aligncenter size-full wp-image-112926" src="../Images/defa8258a163827ed38c46eb62375ca1.png" alt="ComponentPropsWithoutRef And TextProps" srcset="https://blog.logrocket.com/wp-content/uploads/2022/05/componentpropswithoutref-and-textprops.png 730w, https://blog.logrocket.com/wp-content/uploads/2022/05/componentpropswithoutref-and-textprops-300x165.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/05/componentpropswithoutref-and-textprops.png"/></noscript>
<p>我们将显式删除组件类型定义中存在的任何类型，而不是依赖我们的<code>color</code>定义来覆盖来自<code>React.ComponentPropsWithoutRef&lt;C&gt;</code>的内容。</p>
<p><img decoding="async" src="../Images/767c6a63fcf60f8dacb2885e0aa720f4.png" alt="Removing existing props from ComponentPropsWithoutRef" data-lazy-src="https://i.imgur.com/Vd2YT3K.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" class=" jetpack-lazy-image" data-original-src="https://i.imgur.com/Vd2YT3K.png"/></p><noscript><img data-lazy-fallback="1" decoding="async" src="../Images/767c6a63fcf60f8dacb2885e0aa720f4.png" alt="Removing existing props from ComponentPropsWithoutRef" data-original-src="https://i.imgur.com/Vd2YT3K.png"/></noscript>
<p>因此，如果我们的组件类型定义中存在任何类型，我们将从<code>React.ComponentPropsWithoutRef&lt;C&gt;</code>中显式删除这些类型。</p>
<h3 id="&quot;removing-types-from-reactcomponentpropswithoutrefc">从<code>React.ComponentPropsWithoutRef&lt;C&gt;</code>中移除类型</h3>
<p>这是我们之前看到的:</p>
<pre class="language-typescript hljs">type Props &lt;C extends React.ElementType&gt; = 
React.PropsWithChildren&lt;TextProps&lt;C&gt;&gt; &amp; 
React.ComponentPropsWithoutRef&lt;C&gt;
</pre>
<p>我们将更有选择性，而不是像交集类型那样添加来自<code>React.ComponentPropsWithoutRef&lt;C&gt;</code>的所有内容。我们将使用<code>Omit</code>和<code>keyof</code> TypeScript 实用程序类型来执行一些 TypeScript 魔术。</p>
<p>看一看:</p>
<pre class="language-typescript hljs">// before 
type Props &lt;C extends React.ElementType&gt; = 
React.PropsWithChildren&lt;TextProps&lt;C&gt;&gt; &amp; 
React.ComponentPropsWithoutRef&lt;C&gt;

// after
type Props &lt;C extends React.ElementType&gt; = 
React.PropsWithChildren&lt;TextProps&lt;C&gt;&gt; &amp;   
Omit&lt;React.ComponentPropsWithoutRef&lt;C&gt;, keyof TextProps&lt;C&gt;&gt;;
</pre>
<p>这是重要的一点:</p>
<pre class="language-typescript hljs">Omit&lt;React.ComponentPropsWithoutRef&lt;C&gt;, keyof TextProps&lt;C&gt;&gt;;
</pre>
<p><code>Omit</code>接受两个泛型。第一个是对象类型，第二个是您希望从对象类型中“省略”的类型的并集。</p>
<p>这是我最喜欢的例子。考虑如下的<code>Vowel</code>对象类型:</p>
<pre class="language-typescript hljs">type Vowels = {
  a: 'a',
  e: 'e',
  i: 'i',
  o: 'o',
  u: 'u'
}
</pre>
<p>这是键和值的对象类型。假设我想从<code>Vowels</code>中派生出一个新的类型，叫做<code>VowelsInOhans</code>。</p>
<p>嗯，我确实知道名字<code>Ohans</code>包含两个元音，<code>o</code>和<code>a</code>。代替手动声明这些:</p>
<pre class="language-typescript hljs">type VowelsInOhans = {
  a: 'a',
  o: 'o'
}
</pre>
<p>我可以继续利用<code>Omit</code>如下:</p>
<pre class="language-typescript hljs">type VowelsInOhans = Omit&lt;Vowels, 'e' | 'i' | 'u'&gt;
</pre>
<p><img data-attachment-id="112932" data-permalink="https://blog.logrocket.com/build-strongly-typed-polymorphic-components-react-typescript/vowelsinohans/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/05/vowelsinohans.png" data-orig-size="730,579" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="The VowelsInOhans type using Omit" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/05/vowelsinohans-300x238.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/05/vowelsinohans.png" decoding="async" class="aligncenter size-full wp-image-112932 jetpack-lazy-image" src="../Images/0281f33a00384e8b579fff0f7d0caa44.png" alt="The VowelsInOhans Type Using Omit" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2022/05/vowelsinohans.png 730w, https://blog.logrocket.com/wp-content/uploads/2022/05/vowelsinohans-300x238.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2022/05/vowelsinohans.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/05/vowelsinohans.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="112932" data-permalink="https://blog.logrocket.com/build-strongly-typed-polymorphic-components-react-typescript/vowelsinohans/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/05/vowelsinohans.png" data-orig-size="730,579" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="The VowelsInOhans type using Omit" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/05/vowelsinohans-300x238.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/05/vowelsinohans.png" decoding="async" loading="lazy" class="aligncenter size-full wp-image-112932" src="../Images/0281f33a00384e8b579fff0f7d0caa44.png" alt="The VowelsInOhans Type Using Omit" srcset="https://blog.logrocket.com/wp-content/uploads/2022/05/vowelsinohans.png 730w, https://blog.logrocket.com/wp-content/uploads/2022/05/vowelsinohans-300x238.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/05/vowelsinohans.png"/></noscript>
<p><code>Omit</code>将从对象类型<code>Vowels</code>中“省略”掉<code>e</code>、<code>i</code>和<code>u</code>键。</p>
<p>另一方面，<a href="https://blog.logrocket.com/how-to-use-keyof-operator-typescript/"> TypeScript 的<code>keyof</code>操作符</a>可以像你想象的那样工作。想想 JavaScript 中的<code>Object.keys</code>:给定一个<code>object</code>类型，<code>keyof</code>将返回对象键的联合类型。</p>
<p>唷！那是一口。这里有一个例子:</p>
<pre class="language-typescript hljs">type Vowels = {
  a: 'a',
  e: 'e',
  i: 'i',
  o: 'o',
  u: 'u'
}

type Vowel = keyof Vowels 
</pre>
<p>现在，<code>Vowel</code>将是<code>Vowels</code>的键的联合类型，即:</p>
<pre>type Vowel = 'a' | 'e' | 'i' | 'o' | 'u'
</pre>
<p>如果将这些放在一起，再看一看我们的解决方案，就会发现一切都很完美:</p>
<pre>Omit&lt;React.ComponentPropsWithoutRef&lt;C&gt;, keyof TextProps&lt;C&gt;&gt;;
</pre>
<p>返回我们的组件道具的键的联合类型。这又被传递到<code>Omit</code>以从<code>React.ComponentPropsWithoutRef&lt;C&gt;</code>中省略它们。</p>
<p>太棒了。🕺</p>
<p>最后，让我们继续将<code>color</code>道具传递给渲染元素:</p>
<pre>export const Text = &lt;C extends React.ElementType = "span"&gt;({
  as,
  color, // 👈 look here
  children,
  ...restProps
}: Props&lt;C&gt;) =&gt; {
  const Component = as || "span";

  // 👇 compose an inline style object
  const style = color ? { style: { color } } : {};

  // 👇 pass the inline style to the rendered element
  return (
    &lt;Component {...restProps} {...style}&gt;
      {children}
    &lt;/Component&gt;
  );
};
</pre>
<h2 id="create-reusable-utility-polymorphic-types">为多态类型创建可重用的实用程序</h2>
<p>我们终于找到了一个行之有效的解决方案。然而，现在让我们更进一步。</p>
<p>我们的解决方案非常适合我们的<code>Text</code>组件。然而，如果您更希望有一个可以在您选择的任何组件上重用的解决方案，以便您可以为每个用例拥有一个可重用的解决方案，那该怎么办呢？</p>
<p>让我们开始吧。首先，这是当前没有注释的完整解决方案:</p>
<pre>type Rainbow =
  | "red"
  | "orange"
  | "yellow"
  | "green"
  | "blue"
  | "indigo"
  | "violet";

type TextProps&lt;C extends React.ElementType&gt; = {
  as?: C;
  color?: Rainbow | "black";
};

type Props&lt;C extends React.ElementType&gt; = React.PropsWithChildren&lt;
  TextProps&lt;C&gt;
&gt; &amp;
  Omit&lt;React.ComponentPropsWithoutRef&lt;C&gt;, keyof TextProps&lt;C&gt;&gt;;

export const Text = &lt;C extends React.ElementType = "span"&gt;({
  as,
  color,
  children,
  ...restProps
}: Props&lt;C&gt;) =&gt; {
  const Component = as || "span";

  const style = color ? { style: { color } } : {};

  return (
    &lt;Component {...restProps} {...style}&gt;
      {children}
    &lt;/Component&gt;
  );
};
</pre>
<p>简洁实用。</p>
<p>如果我们使它可重复使用，那么它必须适用于任何组件。这意味着移除硬编码的<code>TextProps</code>并用一个泛型来表示它——这样任何人都可以传入他们需要的任何组件道具。</p>
<p>目前，我们用定义<code>Props&lt;C&gt;</code>来表示我们的组件道具。其中<code>C</code>表示为<code>as</code>属性传递的元素类型。</p>
<p>我们现在将把它改为:</p>
<pre class="language-typescript hljs">// before
Props&lt;C&gt;

// after 
PolymorphicProps&lt;C, TextProps&gt;
</pre>
<p><code>PolymorphicProps</code>代表我们将很快编写的实用程序类型。但是，请注意，它接受两个泛型类型，第二个是正在讨论的组件属性:<code>TextProps</code>。</p>
<p>继续定义<code>PolymorphicProps</code>类型:</p>
<pre class="language-typescript hljs">type PolymorphicComponentProp&lt;
  C extends React.ElementType,
  Props = {}
&gt; = {} // 👈 empty object for now 
</pre>
<p>上面的定义应该是可以理解的。<code>C</code>表示<code>as</code>中传入的元素类型，<code>Props</code>是实际的组件道具，<code>TextProps</code>。</p>
<p>首先，让我们将之前的<code>TextProps</code>分解成以下内容:</p>
<pre class="language-typescript hljs">type AsProp&lt;C extends React.ElementType&gt; = {
  as?: C;
};

type TextProps = { color?: Rainbow | "black" };
</pre>
<p>所以，我们已经把<code>AsProp</code>和<code>TextProps</code>分开了。平心而论，它们代表了两种不同的东西。这是一个更好的表示。</p>
<p>现在，让我们改变<code>PolymorphicComponentProp</code>工具定义，以包括<code>as</code>道具、组件道具和<code>children</code>道具，就像我们过去所做的那样:</p>
<pre class="language-typescript hljs">type AsProp&lt;C extends React.ElementType&gt; = {
  as?: C;
};

type PolymorphicComponentProp&lt;
  C extends React.ElementType,
  Props = {}
&gt; = React.PropsWithChildren&lt;Props &amp; AsProp&lt;C&gt;&gt;
</pre>
<p>我相信现在你已经明白这里发生了什么:我们有一个交集类型<code>Props</code>(代表组件道具)和<code>AsProp</code>代表<code>as</code>道具。这些都被传入<code>PropsWithChildren</code>来添加<code>children</code>道具定义。太棒了。</p>
<p>现在，我们需要包含添加了<code>React.ComponentPropsWithoutRef&lt;C&gt;</code>定义的位。但是，我们必须记住忽略组件定义中存在的属性。<br/>让我们想出一个稳健的解决方案。</p>
<p>写出一个新的类型，只包含我们想要省略的道具。即<code>AsProp</code>的按键以及组件道具。</p>
<pre class="language-typescript hljs">type PropsToOmit&lt;C extends React.ElementType, P&gt; = keyof (AsProp&lt;C&gt; &amp; P);
</pre>
<p>还记得<code>keyof</code>实用程序类型吗？</p>
<p><code>PropsToOmit</code>现在将包含我们想要省略的道具的联合类型，这是由<code>P</code>表示的组件的每个道具和由<code>AsProps</code>表示的实际多态道具<code>as</code>。</p>
<p>将所有这些很好地放在<code>PolymorphicComponentProp</code>定义中:</p>
<pre class="language-typescript hljs">type AsProp&lt;C extends React.ElementType&gt; = {
  as?: C;
};

// before 
type PolymorphicComponentProp&lt;
  C extends React.ElementType,
  Props = {}
&gt; = React.PropsWithChildren&lt;Props &amp; AsProp&lt;C&gt;&gt;

// after
type PolymorphicComponentProp&lt;
  C extends React.ElementType,
  Props = {}
&gt; = React.PropsWithChildren&lt;Props &amp; AsProp&lt;C&gt;&gt; &amp;
  Omit&lt;React.ComponentPropsWithoutRef&lt;C&gt;, 
   PropsToOmit&lt;C, Props&gt;&gt;;
</pre>
<p>这里重要的是我们添加了以下定义:</p>
<pre class="language-typescript hljs">Omit&lt;React.ComponentPropsWithoutRef&lt;C&gt;, 
   PropsToOmit&lt;C, Props&gt;&gt;;
</pre>
<p>这基本上省略了<code>React.componentPropsWithoutRef</code>中正确的类型。你还记得<code>omit</code>如何运作吗<a href="https://www.typescriptlang.org/docs/handbook/utility-types.html#omittype-keys" target="_blank" rel="noopener">？</a></p>
<p>虽然看起来很简单，但是您现在有了一个可以在不同项目的多个组件上重用的解决方案！</p>
<p>下面是完整的实现:</p>
<pre class="language-typescript hljs">type PropsToOmit&lt;C extends React.ElementType, P&gt; = keyof (AsProp&lt;C&gt; &amp; P);

type PolymorphicComponentProp&lt;
  C extends React.ElementType,
  Props = {}
&gt; = React.PropsWithChildren&lt;Props &amp; AsProp&lt;C&gt;&gt; &amp;
  Omit&lt;React.ComponentPropsWithoutRef&lt;C&gt;, PropsToOmit&lt;C, Props&gt;&gt;;
</pre>
<p>现在我们可以继续在我们的<code>Text</code>组件上使用<code>PolymorphicComponentProp</code>,如下所示:</p>
<pre class="language-typescript hljs">export const Text = &lt;C extends React.ElementType = "span"&gt;({
  as,
  color,
  children,
  // look here 👇
}: PolymorphicComponentProp&lt;C, TextProps&gt;) =&gt; {
  const Component = as || "span";
  const style = color ? { style: { color } } : {};
  return &lt;Component {...style}&gt;{children}&lt;/Component&gt;;
};
</pre>
<p>多好啊！如果您构建了另一个组件，您可以像这样输入它:</p>
<pre class="language-typescript hljs">PolymorphicComponentProp&lt;C, MyNewComponentProps&gt;
</pre>
<p>你听到那声音了吗？那是胜利的声音——你已经走了这么远！</p>
<h2 id="supporting-refs-polymorphic-components">多态组件中的支持引用</h2>
<p>到目前为止，你还记得每一次提到<code>React.ComponentPropsWithoutRef</code>吗？😅组件道具… <em>不带</em>参赛。好了，现在是把裁判放进去的时候了！</p>
<p>这是我们解决方案的最后也是最复杂的部分。我需要你耐心等待，但我也会尽我所能详细解释每一步。</p>
<p>先说第一件事，你还记得<a href="https://blog.logrocket.com/complete-guide-react-refs/" target="_blank" rel="noopener">如何在</a>工作中做出反应吗？这里最重要的概念是，你不能将<code>ref</code>作为一个道具传递，并期望它像其他道具一样传递到你的组件中。在功能组件中处理<code>refs</code>的推荐方式是使用<a href="https://blog.logrocket.com/cleaning-up-the-dom-with-forwardref-in-react/" target="_blank" rel="noopener"> <code>forwardRef</code>函数</a>。</p>
<p>让我们从实际问题开始。</p>
<p>如果您现在继续传递一个<code>ref</code>到我们的<code>Text</code>组件，您将得到一个显示为<code>Property 'ref' does not exist on type ...</code>的错误。</p>
<pre class="language-typescript hljs">// Create the ref object 
const divRef = useRef&lt;HTMLDivElement | null&gt;(null);
... 
// Pass the ref to the rendered Text component
&lt;Text as="div" ref={divRef}&gt;
  Hello Text world
&lt;/Text&gt;
</pre>
<p><img data-attachment-id="112934" data-permalink="https://blog.logrocket.com/build-strongly-typed-polymorphic-components-react-typescript/property-ref-doesnt-exist-error/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/05/property-ref-doesnt-exist-error.jpeg" data-orig-size="730,579" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;1&quot;}" data-image-title="Property ref does not exist error" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/05/property-ref-doesnt-exist-error-300x238.jpeg" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/05/property-ref-doesnt-exist-error.jpeg" decoding="async" class="aligncenter size-full wp-image-112934 jetpack-lazy-image" src="../Images/30ba977047cfb788c35c01d882c6dafd.png" alt="Property Ref Does Not Exist Error" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2022/05/property-ref-doesnt-exist-error.jpeg 730w, https://blog.logrocket.com/wp-content/uploads/2022/05/property-ref-doesnt-exist-error-300x238.jpeg 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2022/05/property-ref-doesnt-exist-error.jpeg?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/05/property-ref-doesnt-exist-error.jpeg"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="112934" data-permalink="https://blog.logrocket.com/build-strongly-typed-polymorphic-components-react-typescript/property-ref-doesnt-exist-error/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/05/property-ref-doesnt-exist-error.jpeg" data-orig-size="730,579" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;1&quot;}" data-image-title="Property ref does not exist error" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/05/property-ref-doesnt-exist-error-300x238.jpeg" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/05/property-ref-doesnt-exist-error.jpeg" decoding="async" loading="lazy" class="aligncenter size-full wp-image-112934" src="../Images/30ba977047cfb788c35c01d882c6dafd.png" alt="Property Ref Does Not Exist Error" srcset="https://blog.logrocket.com/wp-content/uploads/2022/05/property-ref-doesnt-exist-error.jpeg 730w, https://blog.logrocket.com/wp-content/uploads/2022/05/property-ref-doesnt-exist-error-300x238.jpeg 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/05/property-ref-doesnt-exist-error.jpeg"/></noscript>
<p>这是意料之中的。</p>
<p>我们支持 refs 的第一步是在如下所示的<code>Text</code>组件中使用<code>forwardRef</code>:</p>
<pre class="language-typescript hljs">// before 
export const Text = &lt;C extends React.ElementType = "span"&gt;({
  as,
  color,
  children,
}: PolymorphicComponentProp&lt;C, TextProps&gt;) =&gt; {
  ...
};


// after
import React from "react";

export const Text = React.forwardRef(
  &lt;C extends React.ElementType = "span"&gt;({
    as,
    color,
    children,
  }: PolymorphicComponentProp&lt;C, TextProps&gt;) =&gt; {
    ...
  }
);
</pre>
<p>这本质上只是将前面的代码包装在<code>React.forwardRef</code>中，仅此而已。</p>
<p>现在，<code>React.forwardRef</code>有以下签名:</p>
<pre class="language-typescript hljs">React.forwardRef((props, ref) ... )
</pre>
<p>本质上，收到的第二个参数是<code>ref</code>对象。让我们继续处理这个问题:</p>
<pre class="language-typescript hljs">type PolymorphicRef&lt;C extends React.ElementType&gt; = unknown;

export const Text = React.forwardRef(
  &lt;C extends React.ElementType = "span"&gt;(
    { as, color, children }: PolymorphicComponentProp&lt;C, TextProps&gt;,
    // 👇 look here
    ref?: PolymorphicRef&lt;C&gt;
  ) =&gt; {
    ...
  }
);
</pre>
<p>我们在这里做的是添加第二个参数，<code>ref</code>，并声明其类型为<code>PolymorphicRef</code>，现在它只是指向<code>unknown</code>。</p>
<p>注意<code>PolymorphicRef</code>接受泛型<code>C</code>。这类似于以前的解决方案——<code>div</code>的<code>ref</code>对象不同于<code>span</code>的对象，因此我们需要考虑传递给<code>as</code>属性的元素类型。</p>
<p>请注意<code>PolymorphicRef</code>类型。我们如何基于<code>as</code>道具得到<code>ref</code>对象类型？</p>
<p>给你点提示:<code>React.ComponentPropsWithRef</code>！</p>
<p>请注意，这里用 ref 表示<em>。没有</em>裁判就没有<em>。</em></p>
<p>本质上，如果这是一个键包(事实上就是这样)，它将包含所有基于元素类型的相关组件属性，加上 ref 对象。</p>
<p><img data-attachment-id="112936" data-permalink="https://blog.logrocket.com/build-strongly-typed-polymorphic-components-react-typescript/componentpropswithref-type/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/05/componentpropswithref-type.png" data-orig-size="730,337" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="The ComponentPropsWithRef type" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/05/componentpropswithref-type-300x138.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/05/componentpropswithref-type.png" decoding="async" class="aligncenter size-full wp-image-112936 jetpack-lazy-image" src="../Images/f8384bffe4d8c4bb4bfc836b589ca17b.png" alt="The ComponentPropsWithRef Type" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2022/05/componentpropswithref-type.png 730w, https://blog.logrocket.com/wp-content/uploads/2022/05/componentpropswithref-type-300x138.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2022/05/componentpropswithref-type.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/05/componentpropswithref-type.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="112936" data-permalink="https://blog.logrocket.com/build-strongly-typed-polymorphic-components-react-typescript/componentpropswithref-type/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/05/componentpropswithref-type.png" data-orig-size="730,337" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="The ComponentPropsWithRef type" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/05/componentpropswithref-type-300x138.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/05/componentpropswithref-type.png" decoding="async" loading="lazy" class="aligncenter size-full wp-image-112936" src="../Images/f8384bffe4d8c4bb4bfc836b589ca17b.png" alt="The ComponentPropsWithRef Type" srcset="https://blog.logrocket.com/wp-content/uploads/2022/05/componentpropswithref-type.png 730w, https://blog.logrocket.com/wp-content/uploads/2022/05/componentpropswithref-type-300x138.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/05/componentpropswithref-type.png"/></noscript>
<p>所以现在，如果我们知道这个对象类型包含了<code>ref</code>键，我们也可以通过下面的方法来得到这个引用类型:</p>
<pre class="language-typescript hljs">// before 
type PolymorphicRef&lt;C extends React.ElementType&gt; = unknown;

// after 
type PolymorphicRef&lt;C extends React.ElementType&gt; =
  React.ComponentPropsWithRef&lt;C&gt;["ref"];
</pre>
<p>本质上，<code>React.ComponentPropsWithRef&lt;C&gt;</code>返回一个对象类型，例如，</p>
<pre class="language-typescript hljs">{
  ref: SomeRefDefinition, 
  // ... other keys, 
  color: string 
  href: string 
  // ... etc
}
</pre>
<p>为了挑选出<code>ref</code>类型，我们可以这样做:</p>
<pre class="language-typescript hljs">React.ComponentPropsWithRef&lt;C&gt;["ref"];
</pre>
<p>注意，语法类似于 JavaScript 中的属性访问器语法，即<code>["ref"]</code>。现在我们已经输入了<code>ref</code>属性，我们可以继续将它传递给呈现的元素:</p>
<pre class="language-typescript hljs">export const Text = React.forwardRef(
  &lt;C extends React.ElementType = "span"&gt;(
    { as, color, children }: PolymorphicComponentProp&lt;C, TextProps&gt;,
    ref?: PolymorphicRef&lt;C&gt;
  ) =&gt; {
    //...

    return (
      &lt;Component {...style} ref={ref}&gt; // 👈 look here
        {children}
      &lt;/Component&gt;
    );
  }
);
</pre>
<p>我们已经取得了相当大的进步！事实上，如果您像我们之前一样继续检查<code>Text</code>的用法，就不会再有错误了:</p>
<pre class="language-typescript hljs">// create the ref object 
const divRef = useRef&lt;HTMLDivElement | null&gt;(null);
... 
// pass ref to the rendered Text component
&lt;Text as="div" ref={divRef}&gt;
  Hello Text world
&lt;/Text&gt;
</pre>
<p>然而，我们的解决方案仍然没有我想要的那么强类型化。让我们继续更改传递给<code>Text</code>的 ref，如下所示:</p>
<pre class="language-typescript hljs">// create a "button" ref object 
const buttonRef = useRef&lt;HTMLButtonElement | null&gt;(null);
... 
// pass a button ref to a "div". NB: as = "div"
&lt;Text as="div" ref={buttonRef}&gt;
  Hello Text world
&lt;/Text&gt;
</pre>
<p>TypeScript 应该在这里抛出一个错误，但它没有。我们正在创建一个<code>button</code> ref，但是将它传递给一个<code>div</code>元素。这是不对的。</p>
<p><img data-attachment-id="112938" data-permalink="https://blog.logrocket.com/build-strongly-typed-polymorphic-components-react-typescript/no-error-thrown/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/05/no-error-thrown.png" data-orig-size="730,579" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="No error thrown when a wrong element ref is passed" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/05/no-error-thrown-300x238.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/05/no-error-thrown.png" decoding="async" class="aligncenter size-full wp-image-112938 jetpack-lazy-image" src="../Images/1e84a4a02287c3005831a08395564dfc.png" alt="No Error Thrown When A Wrong Element Ref Is Passed" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2022/05/no-error-thrown.png 730w, https://blog.logrocket.com/wp-content/uploads/2022/05/no-error-thrown-300x238.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2022/05/no-error-thrown.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/05/no-error-thrown.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="112938" data-permalink="https://blog.logrocket.com/build-strongly-typed-polymorphic-components-react-typescript/no-error-thrown/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/05/no-error-thrown.png" data-orig-size="730,579" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="No error thrown when a wrong element ref is passed" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/05/no-error-thrown-300x238.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/05/no-error-thrown.png" decoding="async" loading="lazy" class="aligncenter size-full wp-image-112938" src="../Images/1e84a4a02287c3005831a08395564dfc.png" alt="No Error Thrown When A Wrong Element Ref Is Passed" srcset="https://blog.logrocket.com/wp-content/uploads/2022/05/no-error-thrown.png 730w, https://blog.logrocket.com/wp-content/uploads/2022/05/no-error-thrown-300x238.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/05/no-error-thrown.png"/></noscript>
<p>如果你看一下<code>ref</code>的确切类型，它看起来是这样的:</p>
<pre class="language-typescript hljs">React.RefAttributes&lt;unknown&gt;.ref?: React.Ref&lt;unknown&gt;
</pre>
<p>你看到那里的<code>unknown</code>了吗？那是打字弱的表现。理想情况下，我们应该让<code>HTMLDivElement</code>将 ref 对象显式定义为一个<code>div</code>元素 ref。</p>
<p>我们有工作要做。让我们首先看看<code>Text</code>组件的其他道具的类型，它们仍然引用了<code>PolymorphicComponentProp</code>类型。把这个换成一种新型的叫做<code>PolymorphicComponentPropWithRef</code>。这将只是<code>PolymorphicComponentProp</code>和 ref 道具的联合。(你猜对了。)</p>
<p>这是:</p>
<pre class="language-typescript hljs">type PolymorphicComponentPropWithRef&lt;
  C extends React.ElementType,
  Props = {}
&gt; = PolymorphicComponentProp&lt;C, Props&gt; &amp; 
{ ref?: PolymorphicRef&lt;C&gt; };
</pre>
<p>这只是前面的<code>PolymorphicComponentProp</code>和<code>{ ref?: PolymorphicRef&lt;C&gt; }</code>的并集。</p>
<p>现在我们需要改变组件的属性来引用新的<code>PolymorphicComponentPropWithRef</code>类型:</p>
<pre class="language-typescript hljs">// before
type TextProps = { color?: Rainbow | "black" };

export const Text = React.forwardRef(
  &lt;C extends React.ElementType = "span"&gt;(
    { as, color, children }: PolymorphicComponentProp&lt;C, TextProps&gt;,
    ref?: PolymorphicRef&lt;C&gt;
  ) =&gt; {
    ...
  }
);


// now 
type TextProps&lt;C extends React.ElementType&gt; = 
PolymorphicComponentPropWithRef&lt;
  C,
  { color?: Rainbow | "black" }
&gt;;

export const Text = React.forwardRef(
  &lt;C extends React.ElementType = "span"&gt;(
    { as, color, children }: TextProps&lt;C&gt;, // 👈 look here
    ref?: PolymorphicRef&lt;C&gt;
  ) =&gt; {
    ...
  }
);
</pre>
<p>我们已经更新了<code>TextProps</code>来引用<code>PolymorphicComponentPropWithRef</code>,现在它作为<code>Text</code>组件的道具被传递。可爱！</p>
<p>还有最后一件事要做:为<code>Text</code>组件提供一个类型注释。它看起来类似于:</p>
<pre class="language-typescript hljs">export const Text : TextComponent = ...
</pre>
<p><code>TextComponent</code>是我们将要写的类型注释。在这里，它被完整地写出来:</p>
<pre class="language-typescript hljs">type TextComponent = &lt;C extends React.ElementType = "span"&gt;(
  props: TextProps&lt;C&gt;
) =&gt; React.ReactElement | null;
</pre>
<p>这本质上是一个函数组件，它接收<code>TextProps</code>并返回<code>React.ReactElement | null</code>，其中<code>TextProps</code>如前所述:</p>
<pre class="language-typescript hljs">type TextProps&lt;C extends React.ElementType&gt; = 
PolymorphicComponentPropWithRef&lt;
  C,
  { color?: Rainbow | "black" }
&gt;;
</pre>
<p>这样，我们现在有了一个完整的解决方案！</p>
<p>我现在要分享完整的解决方案。乍一看，这似乎令人望而生畏，但是请记住，我们已经一行一行地完成了您在这里看到的所有内容。带着那份自信去读吧。</p>
<pre class="language-typescript hljs">import React from "react";

type Rainbow =
  | "red"
  | "orange"
  | "yellow"
  | "green"
  | "blue"
  | "indigo"
  | "violet";

type AsProp&lt;C extends React.ElementType&gt; = {
  as?: C;
};

type PropsToOmit&lt;C extends React.ElementType, P&gt; = keyof (AsProp&lt;C&gt; &amp; P);

// This is the first reusable type utility we built
type PolymorphicComponentProp&lt;
  C extends React.ElementType,
  Props = {}
&gt; = React.PropsWithChildren&lt;Props &amp; AsProp&lt;C&gt;&gt; &amp;
  Omit&lt;React.ComponentPropsWithoutRef&lt;C&gt;, PropsToOmit&lt;C, Props&gt;&gt;;

// This is a new type utitlity with ref!
type PolymorphicComponentPropWithRef&lt;
  C extends React.ElementType,
  Props = {}
&gt; = PolymorphicComponentProp&lt;C, Props&gt; &amp; { ref?: PolymorphicRef&lt;C&gt; };

// This is the type for the "ref" only
type PolymorphicRef&lt;C extends React.ElementType&gt; =
  React.ComponentPropsWithRef&lt;C&gt;["ref"];

/**
* This is the updated component props using PolymorphicComponentPropWithRef
*/
type TextProps&lt;C extends React.ElementType&gt; = 
PolymorphicComponentPropWithRef&lt;
  C,
  { color?: Rainbow | "black" }
&gt;;

/**
* This is the type used in the type annotation for the component
*/
type TextComponent = &lt;C extends React.ElementType = "span"&gt;(
  props: TextProps&lt;C&gt;
) =&gt; React.ReactElement | null;

export const Text: TextComponent = React.forwardRef(
  &lt;C extends React.ElementType = "span"&gt;(
    { as, color, children }: TextProps&lt;C&gt;,
    ref?: PolymorphicRef&lt;C&gt;
  ) =&gt; {
    const Component = as || "span";

    const style = color ? { style: { color } } : {};

    return (
      &lt;Component {...style} ref={ref}&gt;
        {children}
      &lt;/Component&gt;
    );
  }
);
</pre>
<p>这就对了。</p>
<h2 id="conclusion-ideas-next-steps">结论和下一步的想法</h2>
<p>您已经在 React with TypeScript 中成功构建了一个用于处理多态组件的健壮解决方案。我知道这不容易，但你做到了。</p>
<p>感谢跟随。记得启动官方的<a href="https://github.com/ohansemmanuel/polymorphic-react-component" target="_blank" rel="noopener"> GitHub 库</a>，在那里你会找到本指南的所有代码。如果你想和我分享你对这个教程的想法，或者只是简单地联系，你可以在<a href="https://github.com/ohansemmanuel" target="_blank" rel="noopener"> GitHub </a>、<a href="https://www.linkedin.com/in/ohans-emmanuel/" target="_blank" rel="noopener"> LinkedIn </a>或<a href="https://twitter.com/ohansemmanuel" target="_blank" rel="noopener"> Twitter </a>上找到/关注我。</p><div class="code-block code-block-17">
<div class="blog-plug inline-plug react-plug" vwo-el-id="26283398190">
<h2 vwo-el-id="41600691720">使用 LogRocket 消除传统反应错误报告的噪音</h2>
<a href="https://lp.logrocket.com/blg/react-signup-issue-free" target="_blank" vwo-el-id="19356441070">LogRocket
</a><p>是一款 React analytics 解决方案，可保护您免受数百个误报错误警报的影响，只针对少数真正重要的项目。LogRocket 告诉您 React 应用程序中实际影响用户的最具影响力的 bug 和 UX 问题。</p><a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="19356441380">
<img class="first-react-image alignnone size-full wp-image-46 jetpack-lazy-image jetpack-lazy-image--handled" src="../Images/f300c244a1a1cf916df8b4cb02bec6c6.png" vwo-el-id="18272717540" data-lazy-loaded="1" data-original-src="https://files.readme.io/27c94e7-Image_2017-06-05_at_9.46.04_PM.png"/>
</a>
<a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="19356441690">
<img class="second-react-image alignnone size-full wp-image-46 jetpack-lazy-image jetpack-lazy-image--handled" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" vwo-el-id="30720362350" data-lazy-loaded="1" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/>
</a>
<a href="https://lp.logrocket.com/blg/react-signup-issue-free" target="_blank" rel="noopener noreferrer" vwo-el-id="35866400580">LogRocket
</a><p>自动聚合客户端错误、反应错误边界、还原状态、缓慢的组件加载时间、JS 异常、前端性能指标和用户交互。然后，LogRocket 使用机器学习来通知您影响大多数用户的最具影响力的问题，并提供您修复它所需的上下文。</p><p vwo-el-id="28675661060">关注重要的 React bug—<a class="signup" href="https://lp.logrocket.com/blg/react-signup-issue-free" target="_blank" rel="noopener noreferrer" vwo-el-id="40093418840">今天就试试 LogRocket】。</a></p>
</div></div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
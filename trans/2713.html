<html>
<head>
<title>Extending object-like types with interfaces in TypeScript - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>在 TypeScript - LogRocket 博客中用接口扩展类对象类型</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/extending-object-like-types-interfaces-typescript/#0001-01-01">https://blog.logrocket.com/extending-object-like-types-interfaces-typescript/#0001-01-01</a></blockquote><div><article class="article-post">
<p>接口是 TypeScript 的核心特性之一，它允许开发人员灵活而富有表现力地对他们的代码施加约束，以减少错误并提高代码可读性。让我们深入探索接口的各种特性，以及如何在我们的程序中更好地利用它们。</p>
<p>向前跳:</p>

<li><a href="#expanding-interfaces-typescript">扩展 TypeScript 中的接口</a></li>

<li><a href="#use-cases-interfaces-typescript">TypeScript 中接口的用例</a></li>

<li><a href="#pros-cons-interfaces-typescript">TypeScript 中接口的利与弊</a></li>

<h2 id="what-typescript-interfaces">什么是 TypeScript 接口？</h2>
<p>首先，一点背景。接口是开发人员命名类型的一种方式，以便以后在程序中引用。例如，一个公共图书馆的管理软件可能有一个代表图书馆藏书的数据的<code>Book</code>接口:</p>
<pre class="typescript hljs">interface Book {
  title: string;
  author: string;
  isbn: string;
}
</pre>
<p>有了它，我们可以确保程序中的图书数据包含标题、作者和 ISBN 的基本信息。如果没有，TypeScript 编译器将抛出一个错误:</p>
<pre class="typescript hljs">const tale: Book = {
  title: 'A Tale of Two Cities',
  author: 'Charles Dickens',
  // Error: Property 'isbn' is missing in type '{ title: string; author: string; }' but required in type 'Book'.
};
</pre>
<p>在我们上面的<code>Book</code>接口示例中，所有的属性都是根据需要定义的。然而，我们也可以定义一个接口来期望一些可选的属性。这可以通过在属性定义中添加<code>?</code>符号来实现。</p>
<p>为了演示这一点，让我们向我们的<code>Book</code>接口添加一个可选的布尔属性<code>signedCopy</code>:</p>
<pre class="typescript hljs">interface Book {
  title: string;
  author: string;
  isbn: string;
  signedCopy?: boolean;
}
</pre>
<h3 id="interfaces-vs-types">接口与类型</h3>
<p>如果您以前编写过 TypeScript 代码，您可能熟悉类型别名，这是命名类型的另一种常用方法，您可能会问，“为什么使用接口而不是类型，反之亦然？”</p>
<p>主要的区别在于，接口可以被重新打开，以便在程序的不同部分添加额外的属性(通过<a href="https://www.typescriptlang.org/docs/handbook/declaration-merging.html" target="_blank" rel="noopener">声明合并</a>),而类型别名则不能。让我们看看如何利用声明合并，以及您可能需要的一些情况。</p>
<h2 id="expanding-interfaces-typescript">在 TypeScript 中扩展接口</h2>
<h3 id="declaration-merging">选项 1:声明合并</h3>
<p>如上所述，可以重新打开接口来添加新的属性和扩展类型的定义。下面是一个无意义的例子来说明这种能力:</p>
<pre class="typescript hljs">interface Stock {
  value: number;
}

interface Stock {
  tickerSymbol: string;
}
</pre>
<p>当然，同样的界面不太可能像这样在附近重新打开。用一句话来定义会更清楚:</p>
<pre class="typescript hljs">interface Stock {
  value: number;
  tickerSymbol: string;
}
</pre>
<p>那么，你什么时候想在程序的不同部分扩展一个接口呢？让我们看一个真实的用例。</p>
<h3 id="declaration-merging-disparate-user-preferences">合并声明以争论不同的用户偏好</h3>
<p>假设您正在编写一个 React 应用程序，并且您需要一些页面来允许用户配置信息，比如他们的配置文件、通知首选项和可访问性设置。</p>
<p>为了清晰和用户体验，您将这三个关注点分成了三个单独的页面，其中源代码将位于三个文件中:<code>Profile.tsx</code>、<code>Notifications.tsx</code>和<code>Accessibility.tsx</code>。</p>
<p>从应用程序架构的角度来看，如果所有用户的偏好都包含在一个对象中就好了，这个对象遵循一个我们称之为<code>Preferences</code>的接口。这样，只需一两个端点，而不是几个端点，就可以轻松地用后端 API 加载和保存 preferences 对象。</p>
<p>下一个问题是:“应该在哪里定义<code>Preferences</code>接口？”您可以将接口放在它自己的文件中，<code>preferences.ts</code>，并将<code>import</code>放到三个页面中——或者，您可以利用声明合并，让每个页面只定义它关心的<code>Preferences</code>的属性，如下所示:</p>
<pre class="typescript hljs">// Profile.tsx

interface Preferences {
  avatarUrl: string;
  username: string;
}

const Profile = (props) =&gt; {
  // ... UI for managing the user's profile ...
}
</pre>
<pre class="typescript hljs">// Notifications.tsx

interface Preferences {
  smsEnabled: boolean;
  emailEnabled: boolean;
}

const Notification = (props) =&gt; {
  // ... UI for managing the user's notification preferences ...
}
</pre>
<pre class="typescript hljs">// Accessibility.tsx

interface Preferences {
  highContrastMode: boolean;
}

const Accessibility = (props) =&gt; {
  // ... UI for managing the user's accessibility settings ...
}
</pre>
<p>最后，<code>Preferences</code>接口将解析为完全包含所有属性，如所期望的:</p>
<pre class="typescript hljs">interface Preferences {
  avatarUrl: string;
  username: string;
  smsEnabled: boolean;
  emailEnabled: boolean;
  highContrastMode: boolean;
}
</pre>
<p>UI 代码现在只与它管理的<code>Preferences</code>的属性放在一起，使得程序更容易理解和维护。不错！</p>
<h3 id="extending-interfaces-typescript">选项 2:在 TypeScript 中扩展接口</h3>
<p>在 TypeScript 中扩展接口的另一种方法是将一个或多个接口混合到一个新接口中:</p>
<pre class="typescript hljs">interface Pet {
  name: string;
  age: number;
}

interface Dog extends Pet {
  breed: string;
}

interface Fish extends Pet {
  finColor: string;
}

const betta: Fish = {
  name: 'Sophie',
  age: 2,
  finColor: 'black',
};
</pre>
<p>这对于面向对象的程序员来说可能很熟悉。然而，接口提供了一个在传统面向对象编程中通常找不到的关键特性:多重继承。</p>
<h3 id="extending-multiple-interfaces-typescript">在 TypeScript 中扩展多个接口</h3>
<p>多重继承允许我们将多个接口的行为和属性合并到一个接口中。</p>
<p>扩展多个接口指的是组合的概念，其中接口被设计为扩展它需要的属性。它不同于面向对象程序设计中的继承概念，在面向对象程序设计中，一个对象是一个给定类的子对象，并强制扩展父对象的属性。</p>
<p>让我们来看一个用例，看看什么时候您可能想要这样做。</p>
<h3 id="extending-interfaces-form-type-safe-global-state-store">扩展接口以形成类型安全的全局状态存储</h3>
<p>假设您正在构建一个应用程序，使用户能够在一个地方跟踪他们的待办事项列表和日常日程。您将拥有一些不同的 UI 组件来跟踪这些任务:</p>
<pre class="typescript hljs">// todo-list.ts

interface ToDoListItem {
  title: string;
  completedDate: Date | null;
}

interface ToDoList {
  todos: ToDoListItem[];
}

// ... application code for managing to-do lists ...
</pre>
<pre class="typescript hljs">// calendar.ts

interface CalendarEvent {
  title: string;
  start: Date;
  end: Date;
}

interface Calendar {
  events: CalendarEvent[];
}

// ... application code for managing the calendar ...
</pre>
<p>既然您已经创建了跟踪两个状态的基本接口，那么您可能希望用一个接口来表示整个应用程序的状态。我们可以使用<code>extends</code>关键字来创建这样一个接口。我们还将添加一个<code>modified</code>字段，以便我们知道我们的状态最后一次更新是什么时候:</p>
<pre class="typescript hljs">interface AppState extends ToDoList, Calendar {
  modified: Date;
}
</pre>
<p>现在您可以使用<code>AppState</code>接口来确保应用程序正确处理状态:</p>
<pre class="typescript hljs">function persist(state: AppState) {
  // ... save the state to a storage layer ...
}

persist({
  todos: [
    { title: 'Text Marcy', completedDate: new Date('2022-02-05') },
    { title: 'Buy groceries', completedDate: null },
  ],
  events: [
    {
      title: 'Study',
      start: new Date('2022-02-11 08:00:00'),
      end: new Date('2022-02-11 10:00:00'),
    },
  ],
  modified: new Date('2022-02-06'),
});
</pre>
<h3 id="extending-types">扩展类型</h3>
<p>虽然使用类型别名无法重新打开接口，但这种扩展类型的方法是可行的，只是在语法上有一些细微的差别。下面是使用<code>type</code>代替<code>interface</code>的等效示例:</p>
<pre class="typescript hljs">type ToDoListItem = {
  title: string;
  completedDate: Date | null;
}
type ToDoList = {
  todos: ToDoListItem[];
}
type CalendarEvent = {
  title: string;
  start: Date;
  end: Date;
}
type Calendar = {
  events: CalendarEvent[];
}
type AppState = ToDoList &amp; Calendar &amp; {
  modified: Date;
}
function persist(state: AppState) {
  // ... save the state to a storage layer ...
}
persist({
  todos: [
    { title: 'Text Marcy', completedDate: new Date('2022-02-05') },
    { title: 'Buy groceries', completedDate: null },
  ],
  events: [
    {
      title: 'Study',
      start: new Date('2022-02-11 08:00:00'),
      end: new Date('2022-02-11 10:00:00'),
    },
  ],
  modified: new Date('2022-02-06'),
});
</pre>
<p>组合多个类型定义的过程称为交集，并使用<code>&amp;</code>符号来执行。通过阅读 TypeScript 中的<a href="https://blog.logrocket.com/types-vs-interfaces-in-typescript/">强大的类型选项来了解更多信息。</a></p>
<h2 id="use-cases-interfaces-typescript">TypeScript 中接口的用例</h2>
<p>接口可用于定义函数或类的预期属性，包括必需属性和可选属性。让我们看几个用例。</p>
<h3 id="using-interfaces-functions">为函数使用接口</h3>
<p>我们可以使用接口来指定函数的预期参数和结果:</p>
<pre class="typescript hljs"> // function
interface Person {
  firstName: string
  lastName: string
  age?: number
}

interface Bio {
  fullName: string
  yearOfBirth?: number
}

function getBio(person: Person): Bio {
  let yearOfBirth: number // is initially undefined

  if (person?.age) {
      const today = new Date()

      yearOfBirth = today.getFullYear() - person.age
  }

  return {
    fullName: `${person.firstName} ${person.lastName}`,
    yearOfBirth
  }
}
</pre>
<p>在上面的例子中，我们定义了一个接口<code>Person</code>。这个<code>Person</code>对象具有必需的属性<code>firstName</code>和<code>lastName</code>以及可选属性<code>age</code>，这是预期的函数参数。</p>
<p>我们还定义了一个接口<code>Bio</code>，它有一个必需属性<code>fullName</code>和一个可选属性<code>yearOfBirth</code>，函数会返回这个属性。</p>
<h3 id="using-interfaces-class-definitions">为类定义使用接口</h3>
<p>我们可以为一个类定义一个接口，指定它的预期属性和它们的形状，然后使用<code>implements</code>关键字将这个定义应用到这个类:</p>
<pre class="typescript hljs">interface Animal {
   name: string
   canWalk(): boolean
}

class Cat implements Animal {
   name: string

   constructor() {
      this.name = 'Cat'
   }

   canWalk() {
     return true
   }
}

const cat = new Cat()
console.log(cat.canWalk())
</pre>
<p>在上面的例子中，我们已经定义了一个接口<code>Animal</code>，由类<code>Cat</code>实现。这意味着<code>Cat</code>必须拥有<code>Animal</code>中定义的所有必需属性。</p>
<h2 id="pros-cons-interfaces-typescript">TypeScript 中接口的利与弊</h2>
<p>当我们讨论接口的利弊时，我们在很大程度上是在讨论 TypeScript 和 JavaScript 的利弊。这是因为通过接口键入和定义形状是 TypeScript 的核心功能。</p>
<p>先说优点。</p>
<p>使用 TypeScript 接口，我们定义了预期的内容，并赋予代码一定程度的一致性和可靠性。通过设置变量、函数参数或函数结果的类型，我们知道会发生什么，并且会得到一些编译时错误，提醒我们发生了不允许的事情。</p>
<p>在下面的示例中，我们的 JavaScript 函数没有使用类型来描述预期的内容，这可能会导致意外的结果:</p>
<pre class="language-javascript hljs">// JavaScript
function (a, b) =&gt; a + b
</pre>
<pre class="language-typescript hljs">// TypeScript
function (a: number, b: number): number =&gt; a + b
</pre>
<p>在我们的 JavaScript 示例中，一个可能的错误是传递一个字符串而不是一个数字。结果将是一个字符串结果(来自连接)，其中应该是一个数字。</p><div class="code-block code-block-54">
<hr/>
<h3>更多来自 LogRocket 的精彩文章:</h3>

<hr/></div>
<p>TypeScript 中的编译时错误发生在生成时，最重要的是发生在函数或代码运行之前。这意味着可以更快地检测到错误，并且在它们造成任何损害之前就检测到。</p>
<p>最后，使用接口定义代码形状使得代码库更容易管理。推而广之，这也有可能提高团队工作的整体绩效。</p>
<p>现在，让我们探讨一下在 TypeScript 中使用接口的一些缺点。</p>
<p>很容易完全依赖接口和类型来防止错误，并产生错误的安全感。虽然它有助于定义预期和非预期的形状，但它并不是防弹的。</p>
<p>此外，实现类型和接口可以非常容易且快速地使代码库变得复杂。只要想想接受和处理不同形状或类型的变量的函数，以及随之而来的无穷无尽的函数重载。</p>
<h2>结论</h2>
<p>在 TypeScript 中，有几种不同的方法可以用接口扩展类似对象的类型，有时，您可以使用类型别名。</p>
<p>在这种情况下，甚至官方文件也说它们大多可以互换，这取决于风格、偏好、组织、习惯等。但是，如果您想在程序的不同部分声明同一类型的不同属性，请使用 TypeScript 接口。</p><div class="code-block code-block-21">
<div class="blog-plug inline-plug typescript-plug"><h2><a class="signup" href="https://lp.logrocket.com/blg/typescript-signup" target="_blank" rel="noopener noreferrer"> LogRocket </a>:全面了解您的网络和移动应用</h2>
<a href="https://lp.logrocket.com/blg/typescript-signup" class="signup" target="_blank" rel="noopener noreferrer"><img class="alignnone size-full wp-image-46 jetpack-lazy-image" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/><noscript><img data-lazy-fallback="1" class="alignnone size-full wp-image-46" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/></noscript></a>
<p>LogRocket 是一个前端应用程序监控解决方案，可以让您回放问题，就像问题发生在您自己的浏览器中一样。LogRocket 不需要猜测错误发生的原因，也不需要向用户询问截图和日志转储，而是让您重放会话以快速了解哪里出错了。它可以与任何应用程序完美配合，不管是什么框架，并且有插件可以记录来自 Redux、Vuex 和@ngrx/store 的额外上下文。</p>
<p>除了记录 Redux 操作和状态，LogRocket 还记录控制台日志、JavaScript 错误、堆栈跟踪、带有头+正文的网络请求/响应、浏览器元数据和自定义日志。它还使用 DOM 来记录页面上的 HTML 和 CSS，甚至为最复杂的单页面和移动应用程序重新创建像素级完美视频。</p>
<a class="signup" href="https://lp.logrocket.com/blg/typescript-signup" target="_blank" rel="noopener noreferrer">Try it for free</a><p>.</p></div>
</div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
<html>
<head>
<title>React Native: JWT authentication using Axios interceptors - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>React Native:使用 Axios 拦截器的 JWT 认证</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/react-native-jwt-authentication-using-axios-interceptors/#0001-01-01">https://blog.logrocket.com/react-native-jwt-authentication-using-axios-interceptors/#0001-01-01</a></blockquote><div><article class="article-post">
<h2 id="introduction">介绍</h2>
<p>React Native 是开发复杂移动应用程序的流行选择，无需深入了解 Android 或 iOS。React Native 的主要卖点是，您可以重用很大一部分 React web 应用程序代码来构建移动应用程序。</p>
<p>几乎每个 app 都需要用户认证。一个很好的选择是使用像谷歌或脸书这样的社交网站。这样，我们将大大简化认证过程，因为我们可以轻松集成内置插件。</p>
<p>然而，许多组织都有我们的应用程序需要处理的自定义身份验证系统。与 React 类似，React Native 也是独立的，因此在实现如此复杂的功能时需要做出很多决定。</p>
<p><img data-attachment-id="84119" data-permalink="https://blog.logrocket.com/react-native-jwt-authentication-using-axios-interceptors/react-native-jwt-authentication-using-axios-interceptors-4/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2021/12/react-native-jwt-authentication-using-axios-interceptors-4.png" data-orig-size="500,934" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="react-native-jwt-authentication-using-axios-interceptors" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2021/12/react-native-jwt-authentication-using-axios-interceptors-4-161x300.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2021/12/react-native-jwt-authentication-using-axios-interceptors-4.png" decoding="async" class="aligncenter wp-image-84119 size-full jetpack-lazy-image" src="../Images/1b660c1ec5888ec72177b4c6064925a6.png" alt="Building Demo App" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2021/12/react-native-jwt-authentication-using-axios-interceptors-4.png 500w, https://blog.logrocket.com/wp-content/uploads/2021/12/react-native-jwt-authentication-using-axios-interceptors-4-161x300.png 161w" data-lazy-sizes="(max-width: 500px) 100vw, 500px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2021/12/react-native-jwt-authentication-using-axios-interceptors-4.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2021/12/react-native-jwt-authentication-using-axios-interceptors-4.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="84119" data-permalink="https://blog.logrocket.com/react-native-jwt-authentication-using-axios-interceptors/react-native-jwt-authentication-using-axios-interceptors-4/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2021/12/react-native-jwt-authentication-using-axios-interceptors-4.png" data-orig-size="500,934" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="react-native-jwt-authentication-using-axios-interceptors" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2021/12/react-native-jwt-authentication-using-axios-interceptors-4-161x300.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2021/12/react-native-jwt-authentication-using-axios-interceptors-4.png" decoding="async" loading="lazy" class="aligncenter wp-image-84119 size-full" src="../Images/1b660c1ec5888ec72177b4c6064925a6.png" alt="Building Demo App" srcset="https://blog.logrocket.com/wp-content/uploads/2021/12/react-native-jwt-authentication-using-axios-interceptors-4.png 500w, https://blog.logrocket.com/wp-content/uploads/2021/12/react-native-jwt-authentication-using-axios-interceptors-4-161x300.png 161w" sizes="(max-width: 500px) 100vw, 500px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2021/12/react-native-jwt-authentication-using-axios-interceptors-4.png"/></noscript>
<p>为了演示如何认证用户，我们将构建一个演示应用程序。该应用程序只有一个功能:显示一只猫的随机图片。但是要看到这一点，用户必须经过身份验证。</p>
<h2 id="what-is-a-json-web-token">什么是 JSON Web 令牌？</h2>
<p>简而言之，<a href="https://blog.logrocket.com/jwt-authentication-best-practices/" target="_blank" rel="noopener"> JSON Web 令牌(JWT) </a>是使用 JSON 格式在两方或多方之间交换信息的一种安全方式。</p>
<h3 id="how-does-it-work">它是如何工作的？</h3>
<p>使用正确的凭据成功进行身份验证后，我们将收到两个令牌:一个访问令牌和一个刷新令牌。我们应该发回访问令牌，通常在每个认证请求的<code>Authorization</code>头中。访问令牌是一条敏感的信息，因为如果攻击者设法窃取了它，他就可以冒充我们。由于我们将它附加到每个请求中，因此风险更高。因此，访问令牌必须是短期的，这样攻击者就不能长时间使用它。</p>
<p>在访问令牌过期后，我们可以使用刷新令牌要求一个新的令牌。为了更好的用户体验，这个过程需要是平滑的。说到 UX，我们希望用户在关闭并再次打开应用程序后仍能登录。为了实现这一点，我们需要持久化令牌。</p>
<h2 id="demo">演示</h2>
<h3 id="backend">后端</h3>
<p>我已经用 Express 和 MongoDB 实现了后端。</p>
<p>运行它需要 Node.js 和 Docker:</p>
<pre class="language-bash hljs">git clone https://github.com/cristian-rita/express-jwt-authentication.git
npm install
docker run --name mongodb -d -p 27017:27017 mongo
npm run dev</pre>
<p>服务器公开了四个 API 端点:</p>
<ul>
<li><code>/api/register</code></li>
<li><code>/api/login</code></li>
<li><code>/api/refreshToken</code></li>
<li><code>/api/cat</code></li>
</ul>
<p>为简单起见，让我们手动创建一个用户:</p>
<pre class="language-bash hljs">curl -X POST -H "Content-Type: application/json" -d '{"email":"<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="1a707572745a7e757f34797577">[email protected]</a>", "password":"test", "firstName":"John", "lastName":"Doe"}' http://localhost:3000/api/register</pre>
<h3 id="mobile-application">移动应用程序</h3>
<p><a href="https://github.com/cristian-rita/react-native-jwt-example" target="_blank" rel="noopener">该应用的最终版本可在此处获得</a>。</p>
<p>我们将初始化一个空的 React 本机应用程序:</p>
<pre class="language-bash hljs">npx react-native init ReactNativeJWTExample</pre>
<p>现在我们需要安装一些依赖项:</p>
<pre class="language-bash hljs">npm install axios axios-auth-refresh react-native-keychain"
npx pod-install</pre>
<p>在<code>src/context</code>下，创建两个文件:</p>
<pre class="language-javascript hljs">//AuthContext.js
import React, {createContext, useState} from 'react';
import * as Keychain from 'react-native-keychain';

const AuthContext = createContext(null);
const {Provider} = AuthContext;

const AuthProvider = ({children}) =&gt; {
  const [authState, setAuthState] = useState({
    accessToken: null,
    refreshToken: null,
    authenticated: null,
  });

  const logout = async () =&gt; {
    await Keychain.resetGenericPassword();
    setAuthState({
      accessToken: null,
      refreshToken: null,
      authenticated: false,
    });
  };

  const getAccessToken = () =&gt; {
    return authState.accessToken;
  };

  return (
    &lt;Provider
      value={{
        authState,
        getAccessToken,
        setAuthState,
        logout,
      }}&gt;
      {children}
    &lt;/Provider&gt;
  );
};

export {AuthContext, AuthProvider};</pre>
<p>这里没什么特别的。我们使用上下文 API 来管理身份验证状态。</p>
<p>还有一个参考<code>Keychain</code>。正如我之前告诉你的，我们需要持久化访问和刷新令牌。</p>
<p>一种可能是使用 AsyncStorage，相当于浏览器的 LocalStorage。AsyncStorage 不安全，因为它没有加密。在这里保存敏感数据是一个糟糕的主意。react-native-keychain 包使用<code>Keychain</code>服务来安全地存储数据:</p>
<pre class="language-javascript hljs">import React, {createContext, useContext} from 'react';
import axios from 'axios';
import {AuthContext} from './AuthContext';
import createAuthRefreshInterceptor from 'axios-auth-refresh';
import * as Keychain from 'react-native-keychain';

const AxiosContext = createContext();
const {Provider} = AxiosContext;

const AxiosProvider = ({children}) =&gt; {
  const authContext = useContext(AuthContext);

  const authAxios = axios.create({
    baseURL: 'http://localhost:3000/api',
  });

  const publicAxios = axios.create({
    baseURL: 'http://localhost:3000/api',
  });

  authAxios.interceptors.request.use(
    config =&gt; {
      if (!config.headers.Authorization) {
        config.headers.Authorization = `Bearer ${authContext.getAccessToken()}`;
      }

      return config;
    },
    error =&gt; {
      return Promise.reject(error);
    },
  );

  const refreshAuthLogic = failedRequest =&gt; {
    const data = {
      refreshToken: authContext.authState.refreshToken,
    };

    const options = {
      method: 'POST',
      data,
      url: 'http://localhost:3001/api/refreshToken',
    };

    return axios(options)
      .then(async tokenRefreshResponse =&gt; {
        failedRequest.response.config.headers.Authorization =
          'Bearer ' + tokenRefreshResponse.data.accessToken;

        authContext.setAuthState({
          ...authContext.authState,
          accessToken: tokenRefreshResponse.data.accessToken,
        });

        await Keychain.setGenericPassword(
          'token',
          JSON.stringify({
            accessToken: tokenRefreshResponse.data.accessToken,
            refreshToken: authContext.authState.refreshToken,
          }),
        );

        return Promise.resolve();
      })
      .catch(e =&gt; {
        authContext.setAuthState({
          accessToken: null,
          refreshToken: null,
        });
      });
  };

  createAuthRefreshInterceptor(authAxios, refreshAuthLogic, {});

  return (
    &lt;Provider
      value={{
        authAxios,
        publicAxios,
      }}&gt;
      {children}
    &lt;/Provider&gt;
  );
};

export {AxiosContext, AxiosProvider};</pre>
<p>我们公开了两个<code>axios</code>的实例。一个用于认证 API 调用，另一个用于公共调用。</p>
<p>Axios 是一个简单的 HTTP 客户端，具有一些独特的功能。Axios 允许我们拦截请求或响应。我们使用拦截器在<code>Authorization</code>头中发送访问令牌。</p>
<p>我们使用的另一个拦截器来自 axios-auth-refresh 包。从客户端的角度来看，除非我们验证过期日期，否则不可能确定访问令牌是否已经过期。这种检查可能很棘手，所以最好依靠服务器来告诉我们访问令牌是否仍然有效。</p>
<p>这种方法的缺点是，我们意识到访问令牌只有在 HTTP 调用失败后才会过期。在这种情况下，我们首先需要刷新访问令牌，然后重试失败的请求。axios-auth-refresh 包为我们处理了所有这些复杂性。</p>
<p><img data-attachment-id="83351" data-permalink="https://blog.logrocket.com/react-native-jwt-authentication-using-axios-interceptors/react-native-jwt-authentication-using-axios-interceptors-2/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2021/12/react-native-jwt-authentication-using-axios-interceptors-2.png" data-orig-size="730,73" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="react-native-jwt-authentication-using-axios-interceptors-2" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2021/12/react-native-jwt-authentication-using-axios-interceptors-2-300x30.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2021/12/react-native-jwt-authentication-using-axios-interceptors-2.png" decoding="async" class="aligncenter size-full wp-image-83351 jetpack-lazy-image" src="../Images/c18ba6bf1f097b14241c269529e4f93d.png" alt="Axios-Auth-Refresh Package" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2021/12/react-native-jwt-authentication-using-axios-interceptors-2.png 730w, https://blog.logrocket.com/wp-content/uploads/2021/12/react-native-jwt-authentication-using-axios-interceptors-2-300x30.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2021/12/react-native-jwt-authentication-using-axios-interceptors-2.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2021/12/react-native-jwt-authentication-using-axios-interceptors-2.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="83351" data-permalink="https://blog.logrocket.com/react-native-jwt-authentication-using-axios-interceptors/react-native-jwt-authentication-using-axios-interceptors-2/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2021/12/react-native-jwt-authentication-using-axios-interceptors-2.png" data-orig-size="730,73" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="react-native-jwt-authentication-using-axios-interceptors-2" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2021/12/react-native-jwt-authentication-using-axios-interceptors-2-300x30.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2021/12/react-native-jwt-authentication-using-axios-interceptors-2.png" decoding="async" loading="lazy" class="aligncenter size-full wp-image-83351" src="../Images/c18ba6bf1f097b14241c269529e4f93d.png" alt="Axios-Auth-Refresh Package" srcset="https://blog.logrocket.com/wp-content/uploads/2021/12/react-native-jwt-authentication-using-axios-interceptors-2.png 730w, https://blog.logrocket.com/wp-content/uploads/2021/12/react-native-jwt-authentication-using-axios-interceptors-2-300x30.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2021/12/react-native-jwt-authentication-using-axios-interceptors-2.png"/></noscript>
<p>现在我们修改<code>index.js</code>文件以使用新创建的上下文提供者:</p>
<pre class="language-javascript hljs">//index.js
import {AppRegistry} from 'react-native';
import App from './App';
import {name as appName} from './app.json';
import {AuthProvider} from './src/context/AuthContext';
import {AxiosProvider} from './src/context/AxiosContext';
import React from 'react';

const Root = () =&gt; {
  return (
    &lt;AuthProvider&gt;
      &lt;AxiosProvider&gt;
        &lt;App /&gt;
      &lt;/AxiosProvider&gt;
    &lt;/AuthProvider&gt;
  );
};
AppRegistry.registerComponent(appName, () =&gt; Root);</pre>
<p>在<code>App.js</code>文件中，我们尝试从密钥库中加载令牌。如果没有令牌，我们将呈现<strong>登录</strong>屏幕。否则，我们显示<strong>仪表板</strong>:</p>
<pre class="language-javascript hljs">// App.js

import React, {useCallback, useContext, useEffect, useState} from 'react';
import Login from './src/components/Login';
import {AuthContext} from './src/context/AuthContext';
import * as Keychain from 'react-native-keychain';
import Dashboard from './src/components/Dashboard';
import Spinner from './src/components/Spinner';

const App = () =&gt; {
  const authContext = useContext(AuthContext);
  const [status, setStatus] = useState('loading');

  const loadJWT = useCallback(async () =&gt; {
    try {
      const value = await Keychain.getGenericPassword();
      const jwt = JSON.parse(value.password);

      authContext.setAuthState({
        accessToken: jwt.accessToken || null,
        refreshToken: jwt.refreshToken || null,
        authenticated: jwt.accessToken !== null,
      });
      setStatus('success');
    } catch (error) {
      setStatus('error');
      console.log(`Keychain Error: ${error.message}`);
      authContext.setAuthState({
        accessToken: null,
        refreshToken: null,
        authenticated: false,
      });
    }
  }, []);

  useEffect(() =&gt; {
    loadJWT();
  }, [loadJWT]);

  if (status === 'loading') {
    return &lt;Spinner /&gt;;
  }

  if (authContext?.authState?.authenticated === false) {
    return &lt;Login /&gt;;
  } else {
    return &lt;Dashboard /&gt;;
  }
};

export default App;</pre>
<p>在检查<code>Keychain</code>时，我们显示一个我们在<code>src/components/Spinner.js</code>中创建的微调器:</p>
<pre class="language-javascript hljs">// src/components/Spinner.js

import React from 'react';
import {ActivityIndicator, StyleSheet, View} from 'react-native';

const Spinner = () =&gt; (
  &lt;View style={styles.container}&gt;
    &lt;ActivityIndicator size="large" color="#007aff" /&gt;
  &lt;/View&gt;
);

const styles = StyleSheet.create({
  container: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
  },
});

export default Spinner;</pre>
<p>现在我们已经实现了认证流程，我们还需要实现另外两个组件，<strong>登录</strong>和<strong>仪表板</strong>:</p>
<pre class="language-javascript hljs">// src/components/Login.js

import {
  View,
  Text,
  StyleSheet,
  SafeAreaView,
  TextInput,
  Button,
  Alert,
} from 'react-native';
import React, {useContext, useState} from 'react';
import {AuthContext} from '../context/AuthContext';
import * as Keychain from 'react-native-keychain';
import {AxiosContext} from '../context/AxiosContext';

const Login = () =&gt; {
  const [email, setEmail] = useState('');

  const [password, setPassword] = useState('');
  const authContext = useContext(AuthContext);
  const {publicAxios} = useContext(AxiosContext);

  const onLogin = async () =&gt; {
    try {
      const response = await publicAxios.post('/login', {
        email,
        password,
      });

      const {accessToken, refreshToken} = response.data;
      authContext.setAuthState({
        accessToken,
        refreshToken,
        authenticated: true,
      });

      await Keychain.setGenericPassword(
        'token',
        JSON.stringify({
          accessToken,
          refreshToken,
        }),
      );
    } catch (error) {
      Alert.alert('Login Failed', error.response.data.message);
    }
  };

  return (
    &lt;SafeAreaView style={styles.container}&gt;
      &lt;Text style={styles.logo}&gt;Cats&lt;/Text&gt;
      &lt;View style={styles.form}&gt;
        &lt;TextInput
          style={styles.input}
          placeholder="Email"
          placeholderTextColor="#fefefe"
          keyboardType="email-address"
          autoCapitalize="none"
          onChangeText={text =&gt; setEmail(text)}
          value={email}
        /&gt;

        &lt;TextInput
          style={styles.input}
          placeholder="Password"
          placeholderTextColor="#fefefe"
          secureTextEntry
          onChangeText={text =&gt; setPassword(text)}
          value={password}
        /&gt;
      &lt;/View&gt;
      &lt;Button title="Login" style={styles.button} onPress={() =&gt; onLogin()} /&gt;
    &lt;/SafeAreaView&gt;
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#000',
    alignItems: 'center',
    justifyContent: 'flex-start',
    width: '100%',
  },
  logo: {
    fontSize: 60,
    color: '#fff',
    margin: '20%',
  },
  form: {
    width: '80%',
    margin: '10%',
  },
  input: {
    fontSize: 20,
    color: '#fff',
    paddingBottom: 10,
    borderBottomColor: '#fff',
    borderBottomWidth: 1,
    marginVertical: 20,
  },
  button: {},
});

export default Login;</pre>
<p><img data-attachment-id="84121" data-permalink="https://blog.logrocket.com/react-native-jwt-authentication-using-axios-interceptors/react-native-jwt-authentication-using-axios-interceptors-3-2/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2021/12/react-native-jwt-authentication-using-axios-interceptors-3-1.png" data-orig-size="500,934" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="react-native-jwt-authentication-using-axios-interceptors-3" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2021/12/react-native-jwt-authentication-using-axios-interceptors-3-1-161x300.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2021/12/react-native-jwt-authentication-using-axios-interceptors-3-1.png" decoding="async" class="aligncenter size-full wp-image-84121 jetpack-lazy-image" src="../Images/4f0a67524d1b1b0438ae7035858bdf9d.png" alt="Login for Demo App" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2021/12/react-native-jwt-authentication-using-axios-interceptors-3-1.png 500w, https://blog.logrocket.com/wp-content/uploads/2021/12/react-native-jwt-authentication-using-axios-interceptors-3-1-161x300.png 161w" data-lazy-sizes="(max-width: 500px) 100vw, 500px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2021/12/react-native-jwt-authentication-using-axios-interceptors-3-1.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2021/12/react-native-jwt-authentication-using-axios-interceptors-3-1.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="84121" data-permalink="https://blog.logrocket.com/react-native-jwt-authentication-using-axios-interceptors/react-native-jwt-authentication-using-axios-interceptors-3-2/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2021/12/react-native-jwt-authentication-using-axios-interceptors-3-1.png" data-orig-size="500,934" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="react-native-jwt-authentication-using-axios-interceptors-3" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2021/12/react-native-jwt-authentication-using-axios-interceptors-3-1-161x300.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2021/12/react-native-jwt-authentication-using-axios-interceptors-3-1.png" decoding="async" loading="lazy" class="aligncenter size-full wp-image-84121" src="../Images/4f0a67524d1b1b0438ae7035858bdf9d.png" alt="Login for Demo App" srcset="https://blog.logrocket.com/wp-content/uploads/2021/12/react-native-jwt-authentication-using-axios-interceptors-3-1.png 500w, https://blog.logrocket.com/wp-content/uploads/2021/12/react-native-jwt-authentication-using-axios-interceptors-3-1-161x300.png 161w" sizes="(max-width: 500px) 100vw, 500px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2021/12/react-native-jwt-authentication-using-axios-interceptors-3-1.png"/></noscript>
<p>登录非常简单。我们展示一个表单，并用 Axios 的公共实例调用 API。如果登录成功，我们将访问和刷新令牌保存到<code>Keychain</code>:</p>
<pre class="language-javascript hljs">// src/components/Dashboard.js

import React, {useContext, useState} from 'react';
import {Button, Image, StyleSheet, View} from 'react-native';
import {AuthContext} from '../context/AuthContext';
import {AxiosContext} from '../context/AxiosContext';
import Spinner from './Spinner';

const Dashboard = () =&gt; {
  const axiosContext = useContext(AxiosContext);
  const authContext = useContext(AuthContext);
  const [image, setImage] = useState(null);
  const [status, setStatus] = useState('idle');

  const loadImage = async () =&gt; {
    setStatus('loading');
    try {
      const response = await axiosContext.authAxios.get('/cat');
      setImage(response.data);
      setStatus('success');
    } catch (error) {
      setStatus('error');
    }
  };

  if (status === 'loading') {
    return &lt;Spinner /&gt;;
  }

  return (
    &lt;View style={styles.container}&gt;
      &lt;Image
        source={{uri: image}}
        width={300}
        height={500}
        style={styles.image}
      /&gt;

      &lt;View style={styles.buttonGroup}&gt;
        &lt;Button title="Get Image" onPress={loadImage} /&gt;
        &lt;Button title="Logout" onPress={() =&gt; authContext.logout()} /&gt;
      &lt;/View&gt;
    &lt;/View&gt;
  );
};

const styles = StyleSheet.create({
  container: {
    justifyContent: 'center',
    alignItems: 'center',
    flex: 1,
  },
  image: {
    width: '90%',
    height: '50%',
    resizeMode: 'contain',
  },
  buttonGroup: {
    marginTop: 20,
    flexDirection: 'row',
    justifyContent: 'space-between',
    width: '90%',
  },
});
export default Dashboard;</pre>
<p><code>Dashboard</code>组件有两个按钮:一个用于通过调用<code>/api/cat</code>获取新图像，另一个用于注销。</p>
<p>现在，您应该能够使用我们之前创建的用户登录并测试应用程序了。</p>
<pre class="prettyprint">Email: <a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="204a4f484e60444f450e434f4d">[email protected]</a>
Passwod: test</pre>
<p>请记住，有更好的方法来处理这些 API 请求。此外，我们应该有更好的错误处理，但我们试图让应用程序尽可能简单。</p>
<h2 id="conclusion">结论</h2>
<p>实现身份验证不是一项简单的任务。尽管我们创建了一个简单的应用程序，但是您可以将这些想法作为起点，并围绕它们进行构建。例如，添加导航就像用专用于公共导航的导航栈替换<code>Login</code>组件，用用于认证导航的导航栈替换<code>Dashboard</code>组件一样简单。</p><div class="code-block code-block-18">
<div class="blog-plug inline-plug react-native-plug"><h2><a href="https://lp.logrocket.com/blg/react-native-signup"> LogRocket </a>:即时重现 React 原生应用中的问题。</h2><a class="signup" href="https://lp.logrocket.com/blg/react-native-signup" target="_blank" rel="noopener noreferrer"><img class="alignnone size-full wp-image-46 jetpack-lazy-image" src="../Images/110055665562c1e02069b3698e6cc671.png" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2021/10/react-native-plug_v2-2.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2021/10/react-native-plug_v2-2.png"/><noscript><img data-lazy-fallback="1" class="alignnone size-full wp-image-46" src="../Images/110055665562c1e02069b3698e6cc671.png" data-original-src="https://blog.logrocket.com/wp-content/uploads/2021/10/react-native-plug_v2-2.png"/></noscript></a><p><a href="https://lp.logrocket.com/blg/react-native-signup" target="_blank" rel="noopener noreferrer"> LogRocket </a>是一款 React 原生监控解决方案，可帮助您即时重现问题、确定 bug 的优先级并了解 React 原生应用的性能。</p><p>LogRocket 还可以向你展示用户是如何与你的应用程序互动的，从而帮助你提高转化率和产品使用率。LogRocket 的产品分析功能揭示了用户不完成特定流程或不采用新功能的原因。</p><p>开始主动监控您的 React 原生应用— <a class="signup" href="https://lp.logrocket.com/blg/react-native-signup" target="_blank" rel="noopener noreferrer">免费试用 LogRocket】。</a></p></div>
</div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
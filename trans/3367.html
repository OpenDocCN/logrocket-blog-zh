<html>
<head>
<title>Exploring JSPyBridge, a new library for using Python in JavaScript - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>在JavaScript - LogRocket博客中探索JSPyBridge，一个使用Python的新库</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/exploring-jspybridge-library-python-javascript/#0001-01-01">https://blog.logrocket.com/exploring-jspybridge-library-python-javascript/#0001-01-01</a></blockquote><div><article class="article-post">
<p>Node.js和Python是两种最流行的软件开发工具。每一种都有其优点和缺点，有时很难从中做出选择，这取决于手头的任务。例如，Node.js运行时很快，并且有一个拥有数百万个包的大型社区，但当涉及到数据科学和机器学习包时，它与Python相比就相形见绌了。</p>
<p>根据您的问题，您可能会发现自己同时需要Node.js和Python然而，这些语言互不相同，没有任何交流机制。</p>
<p>为了补救这一点，创建了<a href="https://github.com/extremeheat/JSPyBridge" target="_blank" rel="noopener"> JSPyBridge </a>来允许Node.js和Python进行互操作。语言互操作允许Node.js和Python协同工作，就像它们是同一个系统的一部分并共享数据结构一样。使用JSPyBridge，您可以在Node.js中导入和使用Python API方法，就像它们是本机的一样，反之亦然。</p>
<p>在本教程中，我们将使用JSPyBridge在Node.js和Python之间进行互操作。在前半部分，我们将看看如何在Python中访问和使用Node.js函数、包、类和数组。在第二部分，我们将看看如何在Node.js中使用Python函数、模块、类和数组。</p>
<p><em>向前跳转:</em></p>

<h3>先决条件</h3>
<p>为了从本教程中获得最大收益，您应该具备:</p>
<ul>
<li>您的计算机上安装的Node.js v ≥ 14</li>
<li>Python v ≥ 3.8已安装</li>
<li>如何使用Node.js和Python的基本知识</li>
</ul>
<h2 id="what-is-jspybridge">JSPyBridge是什么？</h2>
<p>JSPyBridge是一个允许Node.js和Python互操作的桥梁。您可以将它视为两种编程语言之间的文字桥梁，从一种语言获取数据或对象，并对它们进行转换，以便另一种语言可以解析它们。</p>
<p>Python和Node.js之间可以共享的一些对象是函数、类、可迭代对象和回调。例如，在使用JSPyBridge时，可以将Python中的函数导入Node.js，调用它，并访问Node.js中的返回值。</p>
<p>以下是JSPyBridge特性的简要概述:</p>
<ul>
<li>碎片帐集</li>
<li>扩展和调用类</li>
<li>支持回调、函数、类和可重复项</li>
<li>导入本地文件</li>
<li>管理错误</li>
</ul>
<p>更多特性，参见<a href="https://github.com/extremeheat/JSPyBridge#bridge-feature-comparison" target="_blank" rel="noopener">桥特性比较</a>表。</p>
<h2 id="accessing-javascript-python">在Python中访问JavaScript</h2>
<p>在这一节中，我们将看看如何在Python中访问Node.js函数、包、类和数组。为此，我们将创建一个项目目录并下载<a href="https://pypi.org/project/javascript/" target="_blank" rel="noopener"> <code>javascript</code>模块</a>，它是JSPyBridge的一个依赖项。</p>
<p>首先，创建项目目录，并使用以下命令切换到该目录:</p>
<pre class="language-bash hljs">mkdir python_demo &amp;&amp; cd python_demo
</pre>
<p>因为这是一个Python目录，所以为项目创建一个虚拟环境:</p>
<pre class="language-bash hljs">python3 -m venv venv
</pre>
<p>激活虚拟环境:</p>
<pre class="language-bash hljs">source venv/bin/activate
</pre>
<p>创建虚拟环境后，安装<code>javascript</code>模块:</p>
<pre class="language-bash hljs">pip3 install javascript
</pre>
<p>现在我们已经设置好了环境，我们将开始用Python互操作Node.js。</p>
<h3 id="importing-javascript-function-python">在Python中导入JavaScript函数</h3>
<p>让我们用Python创建并调用一个JavaScript函数。该函数会将整数值格式化为您选择的货币。然后，您将导入Python中的JavaScript函数，向其传递参数，并打印返回值。</p>
<p>在编辑器中打开<code>formatCurrency.js</code>文件，并添加以下内容:</p>
<pre class="language-javascript hljs">function formatCurrency(value, type) {
  format = new Intl.NumberFormat("en-US", {
    style: "currency",
    currency: type,
  }).format;
  return format(value);
}
module.exports = { formatCurrency };
</pre>
<p>在前面的代码块中，我们定义了一个<code>formatCurrency()</code>函数，它有两个参数:</p>
<ol>
<li><code>value</code>、钱的数量</li>
<li><code>type</code>，我们希望金额格式化的货币</li>
</ol>
<p>在这个函数中，我们创建了一个<code>Intl.NumberFormat</code>实例，它将语言<code>en-US</code>作为第一个参数，将包含格式化选项的对象作为第二个参数。</p>
<p>对象有两个属性:<code>style</code>和<code>currency</code>。<code>style</code>属性接受格式样式，这里是<code>currency</code>字符串。<code>currency</code>属性接受短格式的货币名称，它存储在<code>type</code>变量中。</p>
<p>一旦创建了<code>Intl.NumberFormat</code>实例，就会返回一个函数并存储在<code>format</code>变量中。接下来，调用带有参数<code>value</code>的<code>format()</code>函数。一旦<code>format()</code>函数运行，<code>formatCurrency()</code>函数返回结果。最后，我们导出函数<code>formatCurrency()</code>,以便它可以在Python中使用。</p>
<p>既然已经定义了函数，我们将在Python中引用它。在编辑器中打开并创建<code>format_currencies.py</code>文件，并添加以下内容:</p>
<pre class="language-python hljs">from javascript import require

data = require("./formatCurrency.js")

value = 2000000

print(data.formatCurrency(value, "USD"))
print(data.formatCurrency(value, "EUR"))
</pre>
<p>首先，我们从<code>javascript</code>模块导入<code>require</code>方法。接下来，我们调用带有JavaScript文件路径的<code>require()</code>方法<code>formatCurrency.js</code>。之后，我们定义一个整数并存储在<code>value</code>变量中。在最后两行中，我们用<code>value</code>变量和我们想要的货币来调用<code>formatCurrency()</code>。</p>
<p>现在，运行<code>format_currency.py</code>文件:</p>
<pre class="language-bash hljs">python3 format_currencies.py
</pre>
<p>运行该文件时，您将看到如下所示的输出:</p>
<pre class="language-plaintext hljs">$2,000,000.00
€2,000,000.00
</pre>
<p>这表明Python调用了JavaScript函数，检索了返回值，并将其记录在终端中。</p>
<h3 id="importing-using-node-js-packages-python">在Python中导入和使用Node.js包</h3>
<p>Node.js有许多可以在项目中使用的包，JSPyBridge允许您在Python中导入和使用它们。您甚至不必使用npm来安装它们——当您使用包名调用<code>require()</code>方法时，JSPyBridge会自动为您获取包。</p>
<p>在这一节中，我们将使用Python中的<a href="https://www.npmjs.com/package/sqlstring" target="_blank" rel="noopener"> sqlstring </a> npm包。<code>sqlstring</code>模块可以用来转义和格式化MySQL的SQL语句。</p>
<p>在文本编辑器中打开<code>generateSQL.py</code>文件:</p>
<pre class="language-python hljs">from javascript import require

sqlString = require("sqlstring")

name = input("What is your name?n")
sql = sqlString.format("SELECT *  FROM customers WHERE name = ?", [name])

print(sql)
</pre>
<p>首先，我们从<code>javascript</code>模块导入<code>require</code>方法。第二，我们调用带有参数<code>sqlstring</code>的<code>require()</code>方法。接下来，我们调用Python的<code>input()</code>方法来获取用户输入，之后，我们调用<code>sqlstring</code>模块的<code>format()</code>方法，该方法将一个SQL查询作为参数。最后，我们打印格式化的SQL查询。</p>
<p>现在运行该文件，并在出现提示时输入一个名称:</p>
<pre class="language-bash hljs">python3 generateSQL.py
</pre>
<p>运行该文件会产生如下所示的输出:</p>
<pre class="language-plaintext hljs"> Installing 'sqlstring' version 'latest'... This will only happen once.

added 1 package, and audited 2 packages in 502ms

found 0 vulnerabilities

 OK.
What is your name?
john

SELECT *  FROM customers WHERE name = 'john'
</pre>
<p>请注意，在输出中，当您第一次运行该文件时，JSPyBridge下载了该包。下载后，该模块用于生成SQL语句，Python将该语句记录在终端中。</p>
<h3 id="using-es2015-python">在Python中使用ES2015</h3>
<p>在本节中，我们将导入一个ECMAScript 2015 (ES6)类，实例化它，然后调用Python中的instance方法。</p>
<p>创建一个名为<code>person.js</code>的新文件:</p>
<pre class="language-javascript hljs">class Person {
  constructor(firstName, lastName) {
    this.firstName = firstName;
    this.lastName = lastName;
  }

  getFullName() {
    return `${this.firstName} ${this.lastName}`;
  }
}

module.exports = { Person };
</pre>
<p><code>Person</code>类有两个参数:<code>firstName</code>和<code>lastName</code>。它还有一个<code>getFullName()</code>方法，该方法连接<code>firstName</code>和<code>lastName</code>参数来产生一个全名。</p>
<p>为了使用Python中的类，我们使用<code>module.exports</code>将其导出。现在，在您的编辑器中创建另一个文件<code>create_person.py</code>并添加以下内容:</p>
<pre class="language-python hljs">from javascript import require

data = require("./person.js")
person_one = data.Person.new("John", "Doe")
print(person_one.getFullName())
</pre>
<p>这里，我们导入<code>require()</code>并引用JavaScript文件<code>person.js</code>。接下来，我们通过调用<code>new()</code>方法来创建类<code>Person</code>的实例，该方法将名和姓作为参数。最后，我们调用<code>Person</code>类的<code>getFullName()</code>方法，并在终端中打印返回值。</p>
<p>保存文件并运行<code>person.py</code>:</p>
<pre class="language-bash hljs">python3 create_person.py
</pre>
<p>运行该文件将产生以下输出:</p>
<pre class="language-plaintext hljs">John Doe
</pre>
<p>输出显示名字和姓氏已经连接在一起。这证实了我们可以在Python中调用和使用JavaScript ES2015类。</p><div class="code-block code-block-54">
<hr/>
<h3>更多来自LogRocket的精彩文章:</h3>

<hr/></div>
<h3 id="using-javascript-iterables-Python">在Python中使用JavaScript iterables</h3>
<p>让我们在Node.js中创建一个数组，导出它，并在Python中迭代它。我们将在<code>formatCurrency.js</code>程序的基础上构建，并利用<code>formatCurrency()</code>函数来格式化多个值，并将它们追加到一个数组中。该数组将被导出并在Python中迭代。</p>
<p>用以下内容创建以下文件<code>formatValues.js</code>:</p>
<pre class="language-javascript hljs">values = [200, 40000000, 2938, 80999];
usd_values = [];
function formatCurrency(value, type) {
  format = new Intl.NumberFormat("en-US", {
    style: "currency",
    currency: type,
  }).format;
  return format(value);
}

for (let i = 0; i &lt; values.length; i++) {
  usd_values.push(formatCurrency(values[i], "USD"));
}

module.exports = { items: usd_values };
</pre>
<p>我们创建一个<code>values</code>数组，包含要格式化为货币的数字。接下来，我们定义一个空数组、<code>usd_values</code>值和<code>formatCurrency()</code>函数，它将给定值格式化为您选择的货币。</p>
<p>接下来，我们迭代<code>values</code>数组，在每次迭代中，我们调用<code>formatCurrency()</code>函数并将格式化后的值推入<code>usd_values</code>数组。一旦循环结束，我们导出一个具有<code>items</code>属性的对象，其值是<code>usd_values</code>数组。</p>
<p>接下来，我们将在Python中导入数组。用以下内容创建<code>list_currencies.py</code>文件:</p>
<pre class="language-python hljs">from javascript import require

data = require("./formatValues.js")
for item in data.items:
    print(item)
</pre>
<p>首先，我们引用<code>formatValues.js</code>文件。接下来，我们迭代Node.js数组，并在每次迭代中打印值。</p>
<p>现在，使用<code>python3</code>命令运行该文件:</p>
<pre class="language-bash hljs">python3 list_currencies.py
</pre>
<p>运行该命令时，您将看到类似于以下内容的输出:</p>
<pre class="language-plaintext hljs">$200.00
$40,000,000.00
$2,938.00
$80,999.00
</pre>
<p>输出证实了我们可以在Python中迭代JavaScript数组。</p>
<h3 id="importing-javascript-file-python-different-directory">从不同的目录导入Python中的JavaScript文件</h3>
<p>到目前为止，我们已经了解了如何从Node.js导入函数、类和iterables，并在同一个项目目录中用Python运行它们。在本节中，我们将把位于另一个目录中的Node.js数组导入Python，并遍历每个元素。</p>
<p>首先，移出项目目录:</p>
<pre class="language-bash hljs">cd ..
</pre>
<p>接下来，创建一个新的项目目录，并移到该目录中:</p>
<pre class="language-bash hljs">mkdir currency_app &amp;&amp; cd currency_app
</pre>
<p>将目录初始化为npm项目:</p>
<pre class="language-bash hljs">npm init -y
</pre>
<p>接下来，安装<code>[uuid](<a href="https://www.npmjs.com/package/uuid" rel="nofollow">https://www.npmjs.com/package/uuid</a>)</code> <a href="https://www.npmjs.com/package/uuid">包</a>，它会生成一个通用的惟一标识符(UUID ),您可以用它来惟一地标识对象:</p>
<pre class="language-bash hljs">npm install uuid
</pre>
<p>接下来，创建一个新文件<code>formatValues.js</code>，并添加以下内容:</p>
<pre class="language-javascript hljs">const { v4: uuidv4 } = require("uuid");

values = [200, 40000000, 2938, 80999];
usd_values = [];
function formatCurrency(value, type) {
  format = new Intl.NumberFormat("en-US", {
    style: "currency",
    currency: type,
  }).format;
  return format(value);
}

for (let i = 0; i &lt; values.length; i++) {
  usd_values.push({
    id: uuidv4(),
    currency: formatCurrency(values[i], "USD"),
  });
}

console.log(usd_values);

module.exports = { items: usd_values };
</pre>
<p>该文件重用了我们在上一节中使用的大量代码；然而，现在有了新的变化。首先，我们导入UUID模块。在<code>for</code>循环中，我们不是只推送值，而是创建一个具有以下属性的对象:<code>id</code>和<code>currency</code>。</p>
<p>属性<code>id</code>被赋予一个UUID，它是通过调用UUID模块的<code>uuidv4()</code>函数生成的。属性<code>currency</code>被赋予一个调用<code>formatCurrency()</code>函数返回的值。最后，我们有一个<code>console.log()</code>方法来记录控制台中的<code>usd_values</code>数组。</p>
<p>这样，使用<code>node</code>命令运行文件:</p>
<pre class="language-bash hljs">node formatValues.js
</pre>
<p>您将看到如下所示的输出:</p>
<pre class="language-plaintext hljs">[
  { id: 'bfdb0bd6-0e9a-4275-812f-dd1b81dde930', currency: '$200.00' },
  {
    id: '31b0d44a-8987-4f50-a683-99f4af477e6d',
    currency: '$40,000,000.00'
  },
  { id: 'ab9f0e76-875d-4e77-8bb9-61015b8a1a46', currency: '$2,938.00' },
  {
    id: 'f035883d-952a-4642-8c66-379858601f5f',
    currency: '$80,999.00'
  }
]
</pre>
<p>输出显示确认对象是用UUIDs创建的。</p>
<p>现在，移除<code>formatValues.js</code>文件中的<code>console.log()</code>方法。我们不再需要它了，因为数组内容将以Python显示。</p>
<p>现在我们知道程序成功运行了，我们将把数组导入到主项目目录中，<code>python_demo</code>。</p>
<p>返回到主项目目录:</p>
<pre class="language-bash hljs">cd .. &amp;&amp; cd python_demo
</pre>
<p>在项目目录中，使用以下内容在编辑器中创建一个<code>list_usd_values_with_uuid.py</code>文件:</p>
<pre class="language-python hljs">from javascript import require

data = require("./../currency_app/formatValues.js")
for item in data.items:
    print(f'ID: {item.id}')
    print(f'Amount in USD: {item.currency}')
    print("n")
</pre>
<p>在代码块中，我们引用了位于另一个目录中的<code>formatCurrencies.js</code>。接下来，我们遍历数组中的所有元素，并在控制台中打印商品UUID和格式化后的货币。</p>
<p>现在，运行<code>list_usd_values_with_uuid.py</code>文件:</p>
<pre class="language-bash hljs">python list_usd_values_with_uuid.py
</pre>
<p>运行代码会产生以下结果:</p>
<pre class="language-plaintext hljs">ID: 35295372-eedc-44bd-8e19-360a990a1a44
Amount in USD: $200.00


ID: c446ae79-3904-4c8b-8e74-31d4184612ca
Amount in USD: $40,000,000.00


ID: 13ce5e1a-7f0a-4d81-bfd4-d18229a1b159
Amount in USD: $2,938.00


ID: 755e1f39-3cad-4128-b806-4681acccd7d7
Amount in USD: $80,999.00
</pre>
<p>正如您在输出中看到的，我们可以成功地迭代另一个项目目录中的数组。</p>
<p>现在您已经知道了如何使用JSPyBridge来访问Python中的Node.js API，我们将在下一节中访问Python API。</p>
<h2 id="accessing-python-node-js">在Node.js中访问Python</h2>
<p>在本节中，我们将访问Node.js中的Python模块、本地Python文件、函数、类和iterables。</p>
<p>首先，移出当前目录，回到主目录:</p>
<pre class="language-bash hljs">cd ..
</pre>
<p>现在，在主目录中，创建一个新目录，并将其更改为:</p>
<pre class="language-bash hljs">mkdir node_demo &amp;&amp; cd node_demo
</pre>
<p>由于这是一个Node.js目录，初始化<code>npm</code>:</p>
<pre class="language-bash hljs">npm init -y
</pre>
<p>接下来，安装<a href="https://www.npmjs.com/package/pythonia" target="_blank" rel="noopener"> pythonia包</a>，它是Node.js的桥梁:</p>
<pre class="language-bash hljs">npm install pythonia
</pre>
<p>接下来，在<code>package.json</code>的末尾添加<code>"type": "module"</code>行，以允许Node.js使用ES2015模块:</p>
<pre class="language-json hljs">{
  ...
  "license": "ISC",
  "dependencies": {
    "pythonia": "^1.0.0"
  },
  "type": "module"
}
</pre>
<p>至此，您现在可以在Node.js中使用JSPyBridge了。接下来，我们将导入一个Python函数并在Node.js中调用它。</p>
<h3 id="importing-python-function-node-js">在Node.js中导入Python函数</h3>
<p>在本节中，我们将在Python中创建一个函数，导入它，然后在Node.js中运行该函数。该函数将利用Python中的<a href="https://docs.python.org/3/library/random.html" target="_blank" rel="noopener"> <code>random</code>模块</a>。</p>
<p>创建一个<code>random_choices.py</code>文件并添加以下内容:</p>
<pre class="language-python hljs">import random


def get_random_word():
    colors = ["red", "green", "blue", "yellow"]
    return random.choice(colors)
</pre>
<p>在第一行，从Python导入<code>random</code>模块。然后我们定义一个函数<code>get_random_word()</code>，它在<code>colors</code>数组中打乱并返回一个随机值。</p>
<p>接下来，用以下代码创建<code>pickRandomValue.js</code>文件:</p>
<pre class="language-javascript hljs">import { python } from "pythonia";
const rand = await python("./random_choices.py");
console.log(await rand.get_random_word());
python.exit();
</pre>
<p>从<code>pythonia</code>包中导入<code>python</code>函数。接下来，用<code>random_choices.py</code>路径作为参数调用<code>python()</code>函数，然后启动一个Python进程。</p>
<p>在Node.js中，JSPyBridge要求每个Python API调用都以<code>await</code>关键字为前缀。接下来，我们调用<code>get_random_word()</code>函数并将结果记录到终端中。最后，我们退出流程。</p>
<p>现在，用<code>node</code>命令运行该文件:</p>
<pre class="language-bash hljs">node pickRandomValue.js
</pre>
<p>运行该命令时，您将看到类似于以下内容的输出:</p>
<pre class="language-bash hljs">red
</pre>
<p>输出显示<code>red</code>。您的可能会显示不同的颜色，因为毕竟包返回随机值。</p>
<h3 id="working-python-third-party-modules-node-js">在Node.js中使用Python第三方模块</h3>
<p>在本节中，我们将使用Node.js中的第三方Python模块。我们的程序将使用<a href="https://matplotlib.org/" target="_blank" rel="noopener"> Matplotlib </a>和<a href="https://numpy.org/" target="_blank" rel="noopener"> NumPy </a>来创建一个图表。</p>
<p>首先，停用当前的虚拟环境:</p>
<pre class="language-bash hljs">deactivate
</pre>
<p>在目录中创建新的虚拟环境:</p>
<pre class="language-bash hljs">python3 -m venv venv
</pre>
<p>激活虚拟环境:</p>
<pre class="language-bash hljs">source venv/bin/activate
</pre>
<p>接下来，使用以下命令安装以下模块:</p>
<pre class="language-bash hljs">pip3 install numpy matplotlib
</pre>
<p>要使用JavaScript中的模块，创建一个<code>plot_graph.js</code>文件并添加以下内容:</p>
<pre class="language-javascript hljs">import { python } from 'pythonia'
const np = await python('numpy')
const plt = await python('matplotlib.pyplot')


const x = await np.array([1, 2, 3])
const y = await np.array([4, 1, 2])

await plt.plot(x, y)

await plt.title('matplotlib graph in Node.js')

await plt.savefig('graph.png')
python.exit()
</pre>
<p>首先，我们从<code>pythonia</code>导入<code>python()</code>函数。在接下来的两行中，我们调用<code>python</code>函数来导入NumPy和Matplotlib模块。</p>
<p>接下来，我们使用<code>np.array()</code>方法定义数组，它们存储在<code>x</code>和<code>y</code>变量中。接下来，我们调用<code>plt.plot()</code>，它将<code>x</code>和<code>y</code>变量中的数组作为参数。之后，我们使用<code>plt.title()</code>方法来定义图表的标题。然后我们调用<code>plt.savefig()</code>将图表作为图像保存在目录中。最后，我们退出Python进程。</p>
<p>现在，运行该文件:</p>
<pre class="language-bash hljs">node plot_graph.js
</pre>
<p>当该命令运行时，您的目录中会有一个图像<code>graph.png</code>，看起来像这样:<br/> <img data-attachment-id="133031" data-permalink="https://blog.logrocket.com/exploring-jspybridge-library-python-javascript/attachment/matplotlib-graph-generated-node-js-2-2/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/09/matplotlib-graph-generated-node-js-2-1.png" data-orig-size="730,548" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="matplotlib-graph-generated-node-js (2)" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/09/matplotlib-graph-generated-node-js-2-1-300x225.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/09/matplotlib-graph-generated-node-js-2-1.png" decoding="async" class="alignnone wp-image-133031 size-full jetpack-lazy-image" src="../Images/a7d1ace492ae26829d76527367122b55.png" alt="Matplotlib Graph in Node.js" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2022/09/matplotlib-graph-generated-node-js-2-1.png 730w, https://blog.logrocket.com/wp-content/uploads/2022/09/matplotlib-graph-generated-node-js-2-1-300x225.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2022/09/matplotlib-graph-generated-node-js-2-1.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/09/matplotlib-graph-generated-node-js-2-1.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="133031" data-permalink="https://blog.logrocket.com/exploring-jspybridge-library-python-javascript/attachment/matplotlib-graph-generated-node-js-2-2/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/09/matplotlib-graph-generated-node-js-2-1.png" data-orig-size="730,548" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="matplotlib-graph-generated-node-js (2)" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/09/matplotlib-graph-generated-node-js-2-1-300x225.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/09/matplotlib-graph-generated-node-js-2-1.png" decoding="async" loading="lazy" class="alignnone wp-image-133031 size-full" src="../Images/a7d1ace492ae26829d76527367122b55.png" alt="Matplotlib Graph in Node.js" srcset="https://blog.logrocket.com/wp-content/uploads/2022/09/matplotlib-graph-generated-node-js-2-1.png 730w, https://blog.logrocket.com/wp-content/uploads/2022/09/matplotlib-graph-generated-node-js-2-1-300x225.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/09/matplotlib-graph-generated-node-js-2-1.png"/></noscript>
<h3 id="using-python-classes-node-js">在Node.js中使用Python类</h3>
<p>在本节中，我们将在Python中定义一个类，并在Node.js中实例化它。</p>
<p>用以下内容创建<code>person.py</code>文件:</p>
<pre class="language-python hljs">class Person:
    def __init__(self, firstName, lastName):
        self.firstName = firstName
        self.lastName = lastName

    def getFullName(self):
        return f"{self.firstName} {self.lastName}"
</pre>
<p>Python类类似于我们之前定义的ES2015 <code>Person</code>类。这个类有两个参数:<code>firstName</code>和<code>lastName</code>。它还有一个<code>getFullName()</code>方法，返回这个人的全名。</p>
<p>要使用Node.js中的<code>Person</code>类，请导入<code>createPerson.js</code>文件:</p>
<pre class="language-javascript hljs">import { python } from "pythonia";
const data = await python("./person.py");
const person1 = await data.Person("John", "Doe");
console.log(await person1.getFullName());
python.exit();
</pre>
<p>首先，我们从<code>pythonia</code>导入<code>Python</code>函数，然后引用<code>person.py</code>文件。其次，我们通过调用<code>Person</code>类创建一个实例，将名字和姓氏作为参数。我们调用<code>getFullName()</code>方法，它返回全名，然后我们在控制台中打印出来。最后，和往常一样，我们退出Python进程。</p>
<p>现在，使用<code>node</code>运行文件:</p>
<pre class="language-bash hljs">node createPerson.js
</pre>
<p>它将产生如下所示的输出:</p>
<pre class="language-bash hljs">John Doe
</pre>
<p>这表明我们可以在Node.js中成功使用Python类。</p>
<h3 id="using-python-iterables-node-js">在Node.js中使用Python iterables</h3>
<p>在本节中，我们将使用Python创建一个列表，并遍历Node.js中的每个元素。</p>
<p>首先，用下面的代码创建<code>get_dir_contents.py</code>:</p>
<pre class="language-python hljs">import os

dir_files = os.listdir("./node_modules")
</pre>
<p>我们从导入<code>os</code>模块开始。接下来，我们调用<code>os</code>模块的<code>listdir()</code>方法，该方法返回给定目录<code>node_modules</code>中所有文件的列表。</p>
<p>现在我们已经有了Python中的列表，我们将导入它并在Node.js中调用它。</p>
<p>首先，创建<code>listDir.js</code>文件并添加以下内容:</p>
<pre class="language-javascript hljs">import { python } from "pythonia";
const obj = await python("./get_dir_contents.py");
const dirFiles = await obj.dir_files;

for await (const file of dirFiles) {
  console.log(file);
}

python.exit();
</pre>
<p>首先，我们使用在第一行中导入的<code>python()</code>函数来引用<code>listDir.py</code>文件。接下来，我们解包<code>dir_files</code>数组并将其存储在<code>dirFiles</code>变量中。</p>
<p>之后，我们定义一个<code>for await</code>循环来遍历所有元素，并在每次迭代过程中记录控制台中的每个文件。JSPyBridge不建议在Python中循环数组时使用其他循环。</p>
<p>接下来，运行<code>listDir.js</code>文件:</p>
<pre class="language-bash hljs">node listDir.js
</pre>
<p>当该命令运行时，您将看到类似如下的输出:</p>
<pre class="language-plaintext hljs">ansi-styles
color-name
has-flag
ws
pythonia
chalk
.package-lock.json
caller
supports-color
color-convert
</pre>
<p>这表明Node.js可以遍历Python数组。</p>
<h2>结论</h2>
<p>在本文中，我们学习了如何使用JSPyBridge实现Node.js和Python的互操作。在前半部分，我们研究了如何在Python中使用JSPyBridge。我们学习了如何导入和使用以下内容:</p>
<table>
<thead>
<tr>
<th>Python中的Node.js</th>
<th>Node.js中的Python</th>
</tr>
</thead>
<tbody>
<tr>
<td>
 
</td>
<td>功能<ul>
<li>班</li>
<li>可重复的</li>
<li>第三方模块</li>
<li>要了解关于JSPyBridge的更多信息，请访问JSPyBridge文档。你也可以在他们的GitHub repo 中查看更多<a href="https://github.com/extremeheat/JSPyBridge/tree/master/examples" target="_blank" rel="noopener">的例子。如果你想学习如何在前端使用Python，请看</a><a href="https://blog.logrocket.com/pyscript-run-python-browser/" target="_blank" rel="noopener">的PyScript教程</a>。</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>200只<img src="../Images/61167b9d027ca73ed5aaf59a9ec31267.png" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2019/10/green-check.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" class=" jetpack-lazy-image" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/10/green-check.png"/> <noscript> <img data-lazy-fallback="1" src="../Images/61167b9d027ca73ed5aaf59a9ec31267.png" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/10/green-check.png"/> </noscript>显示器出现故障，生产中网络请求缓慢</p><div class="code-block code-block-23">
<div class="blog-plug inline-plug node-plug"><h2>部署基于节点的web应用程序或网站是容易的部分。确保您的节点实例继续为您的应用程序提供资源是事情变得更加困难的地方。如果您对确保对后端或第三方服务的请求成功感兴趣，</h2><p>. </p><a href="https://lp.logrocket.com/blg/node-signup" target="_blank">try LogRocket</a><p>LogRocket 就像是网络和移动应用程序的DVR，记录下用户与你的应用程序交互时发生的一切。您可以汇总并报告有问题的网络请求，以快速了解根本原因，而不是猜测问题发生的原因。</p><a class="signup" href="https://lp.logrocket.com/blg/node-signup" target="_blank" rel="noopener noreferrer"><img src="../Images/cae72fd2a54c5f02a6398c4867894844.png" alt="LogRocket Network Request Monitoring" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2019/12/network-request-filter-2-1.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" class=" jetpack-lazy-image" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/12/network-request-filter-2-1.png"/><noscript><img data-lazy-fallback="1" src="../Images/cae72fd2a54c5f02a6398c4867894844.png" alt="LogRocket Network Request Monitoring" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/12/network-request-filter-2-1.png"/></noscript></a><a href="https://lp.logrocket.com/blg/node-signup" target="_blank" rel="noopener noreferrer">https://logrocket.com/signup/</a><p>您是否添加了新的JS库来提高性能或构建新特性？如果他们反其道而行之呢？</p><div class="code-block code-block-28">
<div class="blog-plug inline-plug js-libraries-plug"><h2>毫无疑问，前端变得越来越复杂。当您向应用程序添加新的JavaScript库和其他依赖项时，您将需要更多的可见性，以确保您的用户不会遇到未知的问题。</h2><p>LogRocket 是一个前端应用程序监控解决方案，可以让您回放JavaScript错误，就像它们发生在您自己的浏览器中一样，这样您就可以更有效地对错误做出反应。</p>
<p><a href="https://lp.logrocket.com/blg/javascript-signup" target="_blank" rel="noopener noreferrer"> LogRocket </a>可以与任何应用程序完美配合，不管是什么框架，并且有插件可以记录来自Redux、Vuex和@ngrx/store的额外上下文。您可以汇总并报告问题发生时应用程序的状态，而不是猜测问题发生的原因。LogRocket还可以监控应用的性能，报告客户端CPU负载、客户端内存使用等指标。</p><a class="signup" href="https://lp.logrocket.com/blg/javascript-signup" target="_blank" rel="noopener noreferrer"><img class="alignnone size-full wp-image-46 jetpack-lazy-image" src="../Images/e8a0ab42befa3b3b1ae08c1439527dc6.png" alt="LogRocket Dashboard Free Trial Banner" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2019/10/errors-screenshot.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/10/errors-screenshot.png"/><noscript><img data-lazy-fallback="1" class="alignnone size-full wp-image-46" src="../Images/e8a0ab42befa3b3b1ae08c1439527dc6.png" alt="LogRocket Dashboard Free Trial Banner" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/10/errors-screenshot.png"/></noscript></a>
<a href="https://lp.logrocket.com/blg/javascript-signup" target="_blank" rel="noopener noreferrer">https://logrocket.com/signup/</a><p>自信地构建— <a class="signup" href="https://lp.logrocket.com/blg/javascript-signup" target="_blank" rel="noopener noreferrer">开始免费监控</a>。</p><p>LogRocket检测您的应用程序以记录基线性能计时，如页面加载时间、到达第一个字节的时间、慢速网络请求，还记录Redux、NgRx和Vuex操作/状态。</p></div>


</div><p>. </p><a class="signup" href="https://lp.logrocket.com/blg/node-signup" target="_blank" rel="noopener noreferrer">Start monitoring for free</a><p>. </p></div>
</div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
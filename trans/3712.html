<html>
<head>
<title>Top 5 Web APIs for performance-based analysis (and how to use them) </title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>基于性能的分析的5大Web APIs(以及如何使用它们)</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/top-5-web-apis-performance-based-analysis/#0001-01-01">https://blog.logrocket.com/top-5-web-apis-performance-based-analysis/#0001-01-01</a></blockquote><div><article class="article-post">
<h2>介绍</h2>
<p>有许多工具可以用来分析应用程序的性能。在本文中，我们将探索内置于所有现代浏览器中的性能API。浏览器对这些API的支持非常好，甚至可以追溯到Internet Explorer 9。</p>
<p>在页面的生存期内，浏览器忙于在后台收集性能计时数据。它知道导航过程的每一步需要多长时间，并跟踪任何外部资源(静态资产、API请求等)的连接和下载时间。).</p>
<p>我们将从这个特性的大脑——性能接口——开始，看看它是如何计算时间戳和持续时间的。接下来，我们将研究一些不同的条目类型，以及如何创建我们自己的定制计时来分析任意代码的性能。</p>
<p><em>向前跳转:</em></p>

<h2 id="performance-interface-high-resolution-time"><code>Performance</code>界面和高分辨率时间</h2>
<p>内置的性能监控API都是<code>Performance</code>接口的一部分，通过<code>window.performance</code>对象公开。它捕获许多性能计时，包括:</p>
<ul>
<li>页面加载和导航</li>
<li>资源加载</li>
<li>用户定义的性能计数器</li>
</ul>
<p>当试图捕捉精确的性能计时时，使用<code>Date.now()</code>创建时间戳并不理想。在记录时间时，系统时钟可能稍慢或稍快。这被称为<a href="https://en.wikipedia.org/wiki/Clock_drift">时钟漂移</a>，它在某种程度上影响所有的计算机。</p>
<p>这可能会导致计时不准确，尤其是当与网络时间协议(NTP)服务器的同步导致系统时间调整时。这可能会扭曲与任何先前时间戳的比较。</p>
<p>因此，性能计时改为使用<code>DOMHighResTimeStamp</code>。这种时间戳的主要区别在于:</p>
<ul>
<li>时间戳以毫秒为单位，但包括精确到微秒级(通常精确到五微秒)的小数部分</li>
<li>时间戳不是与之前的系统时间进行比较，而是表示从<em>时间起点</em>开始经过的时间，当页面加载时从零开始</li>
</ul>
<h2 id="performance-timeline-api">性能时间线API</h2>
<p>从页面第一次加载开始(更准确地说，是当<a href="https://developer.mozilla.org/en-US/docs/Glossary/Browsing_context">浏览器上下文</a>被创建时)，<code>window.performance</code>对象维护一个性能事件缓冲区。这是一个动态数据结构，其他操作(如异步请求和自定义用户计时)会向该时间线添加新条目。</p>
<h3 id="performanceentry">性能条目</h3>
<p>时间轴由实现<code>PerformanceEntry</code>接口的对象组成。有不同类型的性能条目，它们由来自不同API的子类型提供，但是它们都被收集在单个时间线中。</p>
<p>条目中的属性因子类型而异，但通常都有以下共同点:</p>
<ul>
<li><code>name</code>:条目的标识符。用于名称的值取决于条目类型；许多条目类型在这里使用URL</li>
<li><code>entryType</code>:指定性能输入的类型。每个<code>PerformanceEntry</code>子类型指定它自己的<code>entryType</code>；例如，一个<code>PerformanceNavigationTiming</code>条目具有一个<code>navigation</code>的<code>entryType</code></li>
<li><code>startTime</code>:相对于时间起点的高分辨率时间戳(通常为<code>0</code>，表示上下文创建的时刻)</li>
<li><code>duration</code>:另一个定义事件持续时间的高分辨率时间戳</li>
</ul>
<h3 id="finding-entries-timeline">从时间轴中查找条目</h3>
<p><code>Performance</code>对象有三种方法来查找性能条目。每个方法返回一个<code>PerformanceEntry</code>对象的数组:</p>
<ol>
<li><code>getEntries</code>:返回时间线中的所有条目</li>
<li><code>getEntriesByName</code>:返回给定名称的所有条目。也可以给定一个给定的条目类型来过滤结果</li>
<li><code>getEntriesByType</code>:返回给定类型的所有条目</li>
</ol>
<p>您还可以通过创建一个<code><a href="https://developer.mozilla.org/en-US/docs/Web/API/PerformanceObserver">PerformanceObserver</a></code>来监听运行时添加的新条目。这是一个处理新条目的回调函数，并提供条目类型监听的标准。未来任何符合标准的条目都将被传递给回调。</p>
<h2 id="resource-timing-api">资源计时API</h2>
<p>资源定时API为浏览器发出的每个网络请求提供了<code>PerformanceResourceTiming</code>条目。这包括异步<code>XMLHttpRequest</code>或<code>fetch</code>请求、JavaScript和CSS文件(以及引用的资源，如图像)和文档本身。</p>
<p>计时主要与网络事件有关，如DNS查找、建立连接、跟踪重定向和接收响应。完整列表可在<code><a href="https://developer.mozilla.org/en-US/docs/Web/API/PerformanceResourceTiming">PerformanceResourceTiming documentation</a></code>中查看。</p>
<p>这些条目的<code>name</code>属性将引用下载的资源的URL。条目还包括一个表示请求类型的<code>initiatorType</code>属性。常见的启动器类型有<code>css</code>、<code>script</code>、<code>fetch</code>、<code>link</code>和<code>other</code>。</p>
<p>除了计时信息，每个条目还包括响应正文的大小。</p>
<p>下面是一个来自<a href="https://logrocket.com"> LogRocket网站</a>的示例条目，加载了从<code>link</code>标签引用的Avenir重字体文件:</p>
<pre class="language-json hljs">{
    "name": "https://logrocket.com/static/Avenir-Heavy-65df024d7123b4108578ddbe666a9cba.ttf",
    "entryType": "resource",
    "startTime": 211.10000002384186,
    "duration": 104.69999998807907,
    "initiatorType": "link",
    "nextHopProtocol": "h2",
    "workerStart": 0,
    "redirectStart": 0,
    "redirectEnd": 0,
    "fetchStart": 211.10000002384186,
    "domainLookupStart": 211.10000002384186,
    "domainLookupEnd": 211.10000002384186,
    "connectStart": 211.10000002384186,
    "connectEnd": 211.10000002384186,
    "secureConnectionStart": 211.10000002384186,
    "requestStart": 218.80000001192093,
    "responseStart": 286.4000000357628,
    "responseEnd": 315.80000001192093,
    "transferSize": 59155,
    "encodedBodySize": 58855,
    "decodedBodySize": 134548,
    "serverTiming": []
}</pre>
<h2 id="navigation-timing-api">导航定时API</h2>
<p>性能缓冲区中的第一个条目是具有<code>navigation</code>的<code>entryType</code>的<code>PerformanceNavigationTiming</code>条目。只有一个<code>navigation</code>条目，它的<code>startTime</code>将是<code>0</code>，因为它代表时间线的开始。它包含导航到当前页面和加载当前页面时发生的各种事件的计时。</p>
<p><code>PerformanceNavigationTiming</code>从<code>PerformanceResourceTiming</code>扩展而来，继承了它所有的网络属性。它还包括与加载DOM内容和触发<code>load</code>事件相关的计时。</p>
<p>这里是一个<code>PerformanceNavigationTiming</code>条目，同样使用LogRocket网站:</p>
<pre class="language-json hljs">{
    "name": "https://logrocket.com/",
    "entryType": "navigation",
    "startTime": 0,
    "duration": 2886.300000011921,
    "initiatorType": "navigation",
    "nextHopProtocol": "h2",
    "workerStart": 0,
    "redirectStart": 0,
    "redirectEnd": 0,
    "fetchStart": 18.100000023841858,
    "domainLookupStart": 20.600000023841858,
    "domainLookupEnd": 58.80000001192093,
    "connectStart": 58.80000001192093,
    "connectEnd": 110.19999998807907,
    "secureConnectionStart": 78.19999998807907,
    "requestStart": 110.30000001192093,
    "responseStart": 183.60000002384186,
    "responseEnd": 209.19999998807907,
    "transferSize": 93203,
    "encodedBodySize": 92903,
    "decodedBodySize": 468095,
    "serverTiming": [],
    "unloadEventStart": 0,
    "unloadEventEnd": 0,
    "domInteractive": 1371.9000000357628,
    "domContentLoadedEventStart": 1384,
    "domContentLoadedEventEnd": 1385,
    "domComplete": 2879.900000035763,
    "loadEventStart": 2880.199999988079,
    "loadEventEnd": 2886.300000011921,
    "type": "navigate",
    "redirectCount": 0,
    "activationStart": 0
}</pre>
<h2 id="creating-your-own-timings-with-user-timing-api">使用用户计时API创建自己的计时</h2>
<p>有时，除了资源和页面加载之外，您可能还需要测量其他操作。也许您想看看一段JavaScript执行得有多好，或者测量两个事件之间的时间。<a href="https://developer.mozilla.org/en-US/docs/Web/API/User_Timing_API">用户计时API </a>允许我们创建“标记”(时间点)和“度量”(测量两个标记之间的时间)。</p>
<p>这些函数在性能时间线中创建新的条目:<code>PerformanceMark</code>和<code>PerformanceMeasure</code>。</p>
<h3 id="creating-marks">创建标记</h3>
<p>性能标记是应用程序运行时的一个命名时刻。它用于捕获要监控的重要事件的时间戳。通过用名称调用<code>performance.mark</code>来创建标记。</p>
<p>假设我们想计算渲染一个UI组件需要多长时间。我们可以捕捉两个标记:一个在渲染开始之前，另一个在渲染完成时:</p>
<pre class="language-javascript hljs">performance.mark('render-start');

// Perform the rendering logic
uiComponent.render();

performance.mark('render-end');</pre>
<p>这将向时间线添加两个性能条目，这两个条目都具有条目类型<code>mark</code>。</p>
<p>我们可以通过获取类型为<code>mark</code>的所有性能条目来验证这一点:</p>
<pre class="language-javascript hljs">performance.getEntriesByType('mark');</pre>
<p>返回的条目数组将包括我们的<code>render-start</code>和<code>render-end</code>标记。每个标记将开始时间指定为高分辨率时间戳。</p>
<h3 id="creating-measures">创建度量</h3>
<p>为了计算这些测试之间经过的时间，我们可以调用<code>performance.measure</code>。该函数有三个参数:</p>
<ol>
<li>度量的唯一名称</li>
<li>开始标记的名称</li>
<li>结束标记的名称</li>
</ol>
<pre class="language-javascript hljs">performance.measure('render', 'render-start', 'render-end');</pre>
<p><code>performance.measure</code>计算两个命名标记之间的时间。时间度量将被捕获到一个新的性能条目中，在性能时间线中的<code>entryType</code>为<code>measure</code>。</p>
<p>下面的演示展示了实际操作中的标记和测量。</p>
<p class="codepen" data-height="300" data-default-tab="html,result" data-slug-hash="ZERemzE" data-user="thinksInCode">参见<a href="https://codepen.io"> CodePen </a>上Joe Attardi(<a href="https://codepen.io/thinksInCode">@ thinksInCode</a>)<br/>的Pen <a href="https://codepen.io/thinksInCode/pen/ZERemzE"> <br/>绩效评分与衡量</a>。</p>
<p/>
<h2 id="watching-new-performance-entries-with-performanceobserver">用<code>PerformanceObserver</code>观察新的性能条目</h2>
<p>到目前为止，我们已经看到了如何调用<code>getEntries</code>和<code>getEntriesByType</code>来按需检索性能条目。使用<code>PerformanceObserver</code> API，我们可以监听新的性能条目。我们可以设置标准来定义我们感兴趣的事件类型，并提供在创建匹配条目时调用的函数。</p>
<p>这个回调被传递给<code>PerformanceObserver</code>构造函数。当接收到新条目时，这个函数用一个<code>PerformanceObserverEntryList</code>调用，它是一个包含所有新创建条目的可迭代数据结构。观察者本身也作为第二个参数传递给回调。</p><div class="code-block code-block-54">
<hr/>
<h3>更多来自LogRocket的精彩文章:</h3>

<hr/></div>
<p>一旦我们定义了回调并创建了一个<code>PerformanceObserver</code>，它将不会生效，直到观察者的<code>observe</code>方法被调用。</p>
<p>以下是监听所有<code>resource</code>性能条目的示例:</p>
<pre class="language-javascript hljs">const observer = new PerformanceObserver(list =&gt; {
  list.getEntries().forEach(entry =&gt; {
    console.log(entry);
  });
});

observer.observe({ type: 'resource' });</pre>
<p>这里有一个监听资源条目和发送HTTP请求的演示:</p>
<p class="codepen" data-height="300" data-default-tab="html,result" data-slug-hash="oNyWZmR" data-user="thinksInCode">参见<a href="https://codepen.io"> CodePen </a>上Joe Attardi(<a href="https://codepen.io/thinksInCode">@ thinksInCode</a>)<br/>的Pen<a href="https://codepen.io/thinksInCode/pen/oNyWZmR"><br/>performance observer Demo</a>。</p>
<p/>
<h2 id="browser-support-performance-timing-apis">浏览器对性能计时API的支持</h2>
<p>性能计时API有很好的浏览器支持。根据来自<a href="https://caniuse.com/mdn-api_performance">caniuse.com</a>的数据，对核心性能API的支持可以追溯到几年前，版本有:</p>
<ul>
<li>铬6</li>
<li>边缘12</li>
<li>野生动物园8</li>
<li>火狐7</li>
<li>甚至Internet Explorer支持这些API回到IE9！</li>
</ul>
<h2 id="pros-cons-using-performance-api">使用性能API的利与弊</h2>
<p>像任何工具一样，使用这些API有优点也有缺点。</p>
<p>使用性能计时API来分析应用程序性能的最大优势在于，它们不需要外部库或服务来捕获数据。它们与浏览器很好地集成在一起，特别是为了导航和资源计时的目的。为这些性能条目提供了详细信息。时序精度非常高，不受时钟漂移的影响。</p>
<p>导航计时在上下文创建的瞬间开始收集，因此不会像使用外部工具那样丢失数据。</p>
<p>这些工具的缺点是它们本身通常不足以成为真正的解决方案。尽管它们捕获了许多关于浏览器会话的有用数据，但仍然存在一些缺口，您可能需要外部库或服务来填补。</p>
<h3 id="reporting-data">报告数据</h3>
<p>我们需要一种方法将数据从用户的电脑中取出，并很可能放入一个分析工具中，以使其发挥作用。这从客户端来说并不是很难解决；我们只需要把现有的数据打包送到某个地方。</p>
<p>T2信标API T3可能是一个很好的解决方案。这是一个轻量级的“单向”HTTP请求，特别适合发送分析数据。信标和使用<code>XMLHttpRequest</code>或<code>fetch</code>的传统异步请求有一些不同:</p>
<ul>
<li><strong>数据保证会被发送</strong>:如果我们发起一个获取请求，而用户在请求发送之前离开了我们的应用，数据就会丢失。一旦启动，即使我们离开或关闭标签，也会发送一个信标</li>
<li><strong>请求是“发射并忘记”</strong>:一旦信标被发送，浏览器不等待响应。请求是单向的，因为任何返回的响应都将被丢弃，并且不能被执行</li>
<li><strong>限于<code>POST</code> </strong> <strong>请求</strong>:信标无法通过<code>PUT</code>或<code>PATCH</code>等其他方式发送请求</li>
</ul>
<p>请注意，任何版本的Internet Explorer都不支持信标。</p>
<h3 id="aggregating-data">汇总数据</h3>
<p>来自性能时间线的数据大部分是原始计时。没有元数据，如操作系统或浏览器版本。这些数据必须单独获得并充分匿名，以便与性能计时一起发送。</p>
<h3 id="data-not-persisted">数据不是持久的</h3>
<p>缓冲区中的所有性能条目都是特定于当前页面的。这对于<a href="https://blog.logrocket.com/micro-frontend-apps-single-spa/">单页应用</a>来说不是问题，但是对于多页应用来说，当导航离开时，所有先前的性能数据都会丢失。</p>
<p>这可以通过在离开页面时发送一个信标，或者使用一些中间的持久存储(<a href="https://blog.logrocket.com/web-storage-made-simple-use-local-storage-state/"> web存储</a>、IndexedDB等)很容易地解决。).</p>
<h3 id="limitations">限制</h3>
<p>Performance API的目的完全是为了捕获性能计时。它不提供任何其他类型的数据。如果您需要监控用户行为或其他指标，您将需要使用其他工具。</p>
<h2>摘要</h2>
<p>性能API可能只是整体分析解决方案的一部分，但它们是性能计时信息的宝贵来源，否则很难准确捕获。更好的是，我们可以免费获得它，不需要加载任何额外的JavaScript或手动触发任何数据收集！</p>
<p>我们确实需要做一些额外的工作来打包数据并将其发送到集合中，但这是内置于当今浏览器中的一个非常强大的工具。它在移动设备浏览器上也得到很好的支持。</p><div class="code-block code-block-27">
<div class="blog-plug inline-plug vanilla-javascript-cta"><h2>通过理解上下文，更容易地调试JavaScript错误</h2>
<p>调试代码总是一项单调乏味的任务。但是你越了解自己的错误，就越容易改正。</p>
<p>LogRocket 让你以新的独特的方式理解这些错误。我们的前端监控解决方案跟踪用户与您的JavaScript前端的互动，让您能够准确找出导致错误的用户行为。</p>
<a href="https://lp.logrocket.com/blg/javascript-signup" class="signup" target="_blank" rel="noopener noreferrer"><img class="alignnone size-full wp-image-46 jetpack-lazy-image" src="../Images/cbfed9be3defcb505e662574769a7636.png" alt="LogRocket Dashboard Free Trial Banner" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2020/06/reproduce-javascript-errors.gif?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/06/reproduce-javascript-errors.gif"/><noscript><img data-lazy-fallback="1" class="alignnone size-full wp-image-46" src="../Images/cbfed9be3defcb505e662574769a7636.png" alt="LogRocket Dashboard Free Trial Banner" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/06/reproduce-javascript-errors.gif"/></noscript></a>
<p>LogRocket记录控制台日志、页面加载时间、堆栈跟踪、慢速网络请求/响应(带有标题+正文)、浏览器元数据和自定义日志。理解您的JavaScript代码的影响从来没有这么简单过！</p>
<a class="signup" href="https://lp.logrocket.com/blg/javascript-signup" target="_blank" rel="noopener noreferrer">Try it for free</a><p>.</p></div>


</div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
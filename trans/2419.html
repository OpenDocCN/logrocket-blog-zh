<html>
<head>
<title>Create dynamic lists in Android with RecyclerView - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>使用 RecyclerView - LogRocket 博客在 Android 中创建动态列表</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/create-dynamic-lists-in-android-with-recyclerview/#0001-01-01">https://blog.logrocket.com/create-dynamic-lists-in-android-with-recyclerview/#0001-01-01</a></blockquote><div><article class="article-post">
<p>在本文中，我们将学习如何创建一个动态的<code>RecyclerView.Adapter</code>,使我们能够在 Android 应用程序中为不同的后端控制的<code>viewType</code>显示一个带有不同<code>ViewHolder</code>的项目列表。</p>
<p>这个列表将是异构的，这意味着它将包含一个从网格和嵌套的水平列表范围的 UI，等等。</p>
<h2>构建后端响应</h2>
<p>在我们进入代码并开始创建动态适配器之前，我们必须讨论后端响应通常是如何构造的，以及我们如何将它们映射到 Kotlin 类以最终获得我们的内容。</p>
<p>服务器响应可能如下所示:</p>
<pre class="language-json hljs">[
    {
        "type": "caraousel",
        "image-urls": [...]
    },
    {
        "type" : "banner",
        "banner-url" : ".."
    }, 
    {
        "type": "horizontal-list",
        "data" : [
            {...}, {...}, {...}
        ]
    }
]
</pre>
<p>这里，我们有一个带有<code>type</code>属性的对象列表，该属性指示它将包含哪种数据。现在，如果我们简单地在默认配置中使用 Gson 或 Jackson 这样的 JSON 反序列化器，就会导致运行时崩溃。</p>
<p>一种变通解决方案是创建一个数据类，如下所示:</p>
<pre class="language-kotlin hljs">data class ApiResponse (
    val type: String,
    val imageUrls: List&lt;String&gt;? = null,
    val bannerUrl: String? = null,
    val data: List&lt;CustomData&gt;? = null
)
</pre>
<p>上述解决方案适用于少数类型，但是随着我们的类型开始增长，这个类会变得臃肿，我们必须到处添加空检查。</p>
<p>一种更简化的方法是让我们的 JSON 反序列化器知道数据将是多态的，并且根据类型，其他属性将被分配给<a href="https://blog.logrocket.com/tag/kotlin/">一个适当的 Kotlin 类类型</a>。</p>
<p>让我们看一个使用<code>Retrofit</code>库的<code>Moshi</code>适配器的例子。</p>
<h2>使用<code>Moshi</code>多态 JSON 适配器</h2>
<p>为了使用<code>Moshi</code>多态 JSON 适配器，我们必须在我们的<code>build.gradle</code>文件中添加所需的依赖项:</p>
<pre class="language-groovy hljs">implementation "com.squareup.moshi:moshi:1.12.0"
implementation "com.squareup.moshi:moshi-adapters:1.12.0"
implementation "com.squareup.moshi:moshi-kotlin:1.12.0"
implementation "com.squareup.retrofit2:converter-moshi:2.9.0"
</pre>
<p>然后我们可以开始创建所需的<a href="https://blog.logrocket.com/using-kotlin-data-classes-to-eliminate-java-pojo-boilerplates/"> Kotlin 数据类</a>，在这个场景中，使用 Kotlin 的<code>sealed</code>类是最理想的。</p>
<p>首先，将所有不同的类型映射到一个<code>enum</code>:</p>
<pre class="language-kotlin hljs">enum class ResponseType {
    @Json(name = "banner") BANNER,
    @Json(name = "quote") QUOTE,
    @Json(name = "carousel") CAROUSEL,
    @Json(name = "contact") CONTACT,
    @Json(name = "grid") GRID
}
</pre>
<p>然后，创建一个父类<code>sealed</code>,并向其中添加所有公共属性。在我们的例子中，我们只添加了<code>type</code>字段:</p>
<pre class="language-kotlin hljs">sealed class Response(@Json(name = "type") val type: ResponseType)
</pre>
<p>接下来，我们可以创建代表不同类型的不同数据类，所有这些数据类都将扩展上面的<code>sealed</code>类:</p>
<pre class="language-kotlin hljs">sealed class Response(@Json(name = "type") val type: ResponseType)

data class Banner(@Json(name = "banner-url") val bannerUrl: String): Response(ResponseType.BANNER)

data class Quote(val quote: String, val author: String): Response(ResponseType.QUOTE)

data class Carousel(@Json(name = "image-urls") val imageUrls: List&lt;String&gt;): Response(ResponseType.CAROUSEL)

data class Contacts(@Json(name = "contacts") val contactList: List&lt;Contact&gt;): Response(ResponseType.CONTACT)

data class Grid(@Json(name = "grid-urls") val gridUrls: List&lt;String&gt;): Response(ResponseType.GRID)

data class Contact(
    val name: String,
    val avatar: String,
    val city: String,
    val id: String
)
</pre>
<p>我们现在可以继续创建<code>Moshi</code>的多态适配器，并将上述每个数据类映射到服务器响应的<code>type</code>字段:</p>
<pre class="language-kotlin hljs">val polymorphicAdapter = 
    PolymorphicJsonAdapterFactory.of(Response::class.java, "type")
            .withSubtype(Banner::class.java, "banner")
            .withSubtype(Quote::class.java, "quote")
            .withSubtype(Carousel::class.java, "carousel")
            .withSubtype(Contacts::class.java, "contact")
            .withSubtype(Grid::class.java, "grid")

val moshi: Moshi = Moshi.Builder()
    .add(polymorphicAdapter)
    .add(KotlinJsonAdapterFactory())
    .build()
</pre>
<p>然后，将上面的<code>Moshi</code>实例传递给我们的<code>Retrofit</code>适配器，如下所示:</p>
<pre class="language-kotlin hljs">val retrofit: Retrofit = Retrofit.Builder()
    .baseUrl("https://my-json-server.typicode.com/jobinlawrance/")
    .addConverterFactory(MoshiConverterFactory.create(moshi))
    .addCallAdapterFactory(RxJava2CallAdapterFactory.create())
    .build()
</pre>
<p>为了测试我们上面的适配器并进一步开发，<a href="https://my-json-server.typicode.com/jobinlawrance/dynamic-recycler-view/dynamic-list">我创建了一个模拟 API </a>。使用<code>Retrofit</code>向这个端点发出一个<code>GET</code>请求，我们可以成功地看到适配器正在工作。</p>
<p>现在，让我们继续编写与 UI 相关的代码。</p>
<h2>用户界面模型</h2>
<p>尽管我们可以使用上面为数据建模编写的数据类，但作为一种干净的做法，我们将为我们的 UI 逻辑创建单独的数据类。</p>
<p>让我们首先创建一个<a href="https://www.geeksforgeeks.org/marker-interface-java/">标记接口</a>作为我们 UI 数据类的基础，每个数据类对应于我们想要显示的不同类型的视图:</p>
<pre class="language-kotlin hljs">// this is our marker interface
interface BaseUI 

data class BannerUI(val imageUrl: String): BaseUI

data class QuoteUI(val quote: String, val author: String): BaseUI

data class CarouselUI(val imageUrls: List&lt;String&gt;): BaseUI

data class ContactListUI(val contacts: List&lt;ContactUI&gt;): BaseUI

data class GridUI(val imageUrls: List&lt;String&gt;): BaseUI

data class ContactUI(
    val name: String,
    val avatar: String,
    val city: String,
    val id: String
)
</pre>
<p>现在，创建一个简单的实用程序扩展，将我们的每个数据模型映射到 UI 模型:</p>
<pre class="language-kotlin hljs">fun Banner.toBannerUI() = BannerUI(imageUrl = bannerUrl)

fun Quote.toQuoteUI() = QuoteUI(quote, author)

fun Carousel.toCarouselUI() = CarouselUI(imageUrls)

fun Contact.toContactUI() = ContactUI(name, avatar, city, id)

fun Contacts.toContactListUI() = 
    ContactListUI(contacts = contactList.map { it.toContactUI() })

fun Grid.toGridUI() = GridUI(imageUrls = gridUrls)

fun Response.toBaseUI(): BaseUI =
    when(this) {
        is Banner -&gt; this.toBannerUI()
        is Carousel -&gt; this.toCarouselUI()
        is Contacts -&gt; this.toContactListUI()
        is Grid -&gt; this.toGridUI()
        is Quote -&gt; this.toQuoteUI()
    }

fun List&lt;Response&gt;.toBaseUIList(): List&lt;BaseUI&gt; {
    return this.map { it.toBaseUI() }
}
</pre>
<h2>创建<code>ViewHolder</code>和适配器</h2>
<p>接下来，让我们继续创建我们不同的 ui 来显示在我们的单个<code>recyclerview</code>中，每个 ui 都有自己的<code>RecyclerView.ViewHolder</code></p>
<p>首先，从在我们的<code>build.gradle</code>文件中添加一些必要的依赖项开始:</p>
<pre class="language-groovy hljs">implementation "androidx.recyclerview:recyclerview:1.2.1"
implementation 'com.github.bumptech.glide:glide:4.12.0'
annotationProcessor 'com.github.bumptech.glide:compiler:4.12.0'
</pre>
<p>以下是我们将为本文创建的不同类型的视图及其对应的<code>ViewHolder</code>:</p>
<ol>
<li>旗帜</li>
<li>引用</li>
<li>旋转木马</li>
<li>格子</li>
<li>联系人(嵌套的<code>Recyclerview</code>)</li>
</ol>
<p>这些将与以下<code>ViewHolder</code>相对应:</p>

<p>以上所有的<code>ViewHolder</code>都扩展了一个基类<code>ViewHolder</code>:</p>
<pre class="language-kotlin hljs">abstract class BaseViewHolder&lt;in T&gt;(binding: ViewBinding) :
    RecyclerView.ViewHolder(binding.root) {

    val context: Context = binding.root.context
    abstract fun bind(item: T)
}
</pre>
<p>当我们创建动态适配器时，我们必须覆盖一个额外的<code>getItemViewType()</code>方法来通知我们的<code>RecyclerView.Adapter</code>关于不同的<code>viewType</code>:</p>
<pre class="language-kotlin hljs">override fun getItemViewType(position: Int): Int {
    return when (uiList[position]) {
        is BannerUI -&gt; BANNER.ordinal
        is QuoteUI -&gt; QUOTE.ordinal
        is CarouselUI -&gt; CAROUSEL.ordinal
        is ContactListUI -&gt; CONTACT.ordinal
        is GridUI -&gt; GRID.ordinal
        else -&gt; -1
    }
}
</pre>
<p>我们返回<code>enum ordrinal</code>(或者我们可以返回布局 ID int，例如，<code>R.layout.some_layout</code>)作为唯一的整数。</p>
<p>在我们的<code>onCreateViewHolder()</code>方法中，我们可以检查<code>viewType</code>字段并创建适当的<code>ViewHolder</code>:</p>
<pre class="language-kotlin hljs">override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): 
  BaseViewHolder&lt;BaseUI&gt; {
    val inflater = LayoutInflater.from(parent.context)
    return when (viewType) {
        BANNER.ordinal -&gt; {
            val binding = ViewholderBannerBinding.inflate(inflater, parent, false)
            BannerViewHolder(binding)
        }
        QUOTE.ordinal -&gt; {
            val binding = ViewholderQuoteBinding.inflate(inflater, parent, false)
            QuoteViewHolder(binding)
        }
        CAROUSEL.ordinal -&gt; {
            val binding = ViewholderCarouselBinding.inflate(inflater, parent, false)
            CarouselViewHolder(binding)
        }
        CONTACT.ordinal -&gt; {
            val binding = ViewholderContactsBinding.inflate(inflater, parent, false)
            ContactsViewHolder(binding)
        }
        GRID.ordinal -&gt; {
            val binding = ViewholderGridBinding.inflate(inflater, parent, false)
            GridViewHolder(binding)
        }
        else -&gt; throw IllegalArgumentException("The viewtype value of $viewType is not supported")
    } as BaseViewHolder&lt;BaseUI&gt;
}
</pre>
<p>最后，在我们的<code>onBindViewHolder()</code>中，我们可以简单地在我们的<code>BaseViewHolder</code>上调用<code>holder.bind(uiList[position])</code>。</p>
<p><img data-attachment-id="80222" data-permalink="https://blog.logrocket.com/create-dynamic-lists-in-android-with-recyclerview/final-recyclerview-dynamic-list-app/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2021/11/Final-RecyclerView-dynamic-list-app.gif" data-orig-size="360,760" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Final RecyclerView dynamic list app" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2021/11/Final-RecyclerView-dynamic-list-app-142x300.gif" data-large-file="https://blog.logrocket.com/wp-content/uploads/2021/11/Final-RecyclerView-dynamic-list-app.gif" decoding="async" class="aligncenter size-full wp-image-80222 jetpack-lazy-image" src="../Images/4cd65567c41abff2f2e3518a156f26dd.png" alt="Final RecyclerView Dynamic List App, Showing The Four Different Types Of Lists, Including Multimedia Elements" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2021/11/Final-RecyclerView-dynamic-list-app.gif?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2021/11/Final-RecyclerView-dynamic-list-app.gif"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="80222" data-permalink="https://blog.logrocket.com/create-dynamic-lists-in-android-with-recyclerview/final-recyclerview-dynamic-list-app/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2021/11/Final-RecyclerView-dynamic-list-app.gif" data-orig-size="360,760" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Final RecyclerView dynamic list app" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2021/11/Final-RecyclerView-dynamic-list-app-142x300.gif" data-large-file="https://blog.logrocket.com/wp-content/uploads/2021/11/Final-RecyclerView-dynamic-list-app.gif" decoding="async" loading="lazy" class="aligncenter size-full wp-image-80222" src="../Images/4cd65567c41abff2f2e3518a156f26dd.png" alt="Final RecyclerView Dynamic List App, Showing The Four Different Types Of Lists, Including Multimedia Elements" data-original-src="https://blog.logrocket.com/wp-content/uploads/2021/11/Final-RecyclerView-dynamic-list-app.gif"/></noscript>
<p>这是最终完成的应用程序；<a href="https://github.com/jobinlawrance/dynamic-recycler-view/blob/main/app/src/main/java/com/jobinlawrance/dynamicrecyclerview/ui/DynamicListAdapter.kt"> t </a> <a href="https://github.com/jobinlawrance/dynamic-recycler-view/blob/main/app/src/main/java/com/jobinlawrance/dynamicrecyclerview/ui/DynamicListAdapter.kt">他完整的适配器代码可以在这里找到</a>。</p>
<h2>附着在固体上</h2>
<p>上面的代码实现了我们最初的目标，即使用一个<code>RecyclerView</code>来显示一个动态列表，但是这个解决方案并不完美。</p>
<p>这对于小项目来说没问题，但是如果我们看一下我们的适配器，我们可以看到任何时候我们添加一个新的<code>viewType</code>，我们必须对我们的<code>adapter</code>类进行修改，这将最终加载<code>adapter</code>类。</p>
<p>现在，<a href="https://blog.logrocket.com/solid-principles-single-responsibility-in-javascript-frameworks/">我们违反了 SOLID 的开/关原则</a>，它说，“软件实体(类、模块、函数等。)应该对扩展开放，但对修改关闭。”</p>
<p>为了开始坚持 SOLID，我们可以将作为静态方法的<code>ViewHolder</code>实例化代码移动到每个单独的<code>ViewHolder</code>中。例如，让我们将下面的代码添加到<code>QuoteViewHolder</code>类中:</p>
<pre class="language-kotlin hljs">companion object {
    fun createViewHolder(inflater: LayoutInflater, parent: ViewGroup): 
      QuoteViewHolder {
        val binding = ViewholderQuoteBinding.inflate(inflater, parent, false)
        return QuoteViewHolder(binding)
    }
}
</pre>
<p>现在，让我们使用<a href="https://en.wikipedia.org/wiki/Visitor_pattern">访问者模式</a>，并将检查<code>viewType</code>的责任委派给一个单独的类。</p>
<p>我们首先定义一个<code>Visitable</code>接口:</p>
<pre class="language-kotlin hljs">interface Visitable {
    fun type(typeFactory: TypeFactory) : Int
}
</pre>
<p>然后，我们可以将我们的<code>BaseUI</code>扩展到接口:</p>
<pre class="language-kotlin hljs">interface BaseUI: Visitable
</pre>
<p>我们可以创建<code>TypeFactory</code>接口来处理不同的类型，使用方法重载来处理多个<code>viewType</code>:</p>
<pre class="language-kotlin hljs">class TypeFactoryImpl : TypeFactory {
    override fun type(bannerUI: BannerUI): Int = ResponseType.BANNER.ordinal
    override fun type(quoteUI: QuoteUI): Int = ResponseType.QUOTE.ordinal
    override fun type(carouselUI: CarouselUI): Int = ResponseType.CAROUSEL.ordinal
    override fun type(contactListUI: ContactListUI): Int = ResponseType.CONTACT.ordinal
    override fun type(gridUI: GridUI): Int = ResponseType.GRID.ordinal

    override fun holder(
        inflater: LayoutInflater,
        parent: ViewGroup,
        viewType: Int
    ): BaseViewHolder&lt;*&gt; {
        return when (viewType) {
            ResponseType.BANNER.ordinal -&gt; 
                BannerViewHolder.createViewHolder(inflater, parent)
            ResponseType.QUOTE.ordinal -&gt; 
                QuoteViewHolder.createViewHolder(inflater, parent)
            ResponseType.CAROUSEL.ordinal -&gt; 
                CarouselViewHolder.createViewHolder(inflater, parent)
            ResponseType.CONTACT.ordinal -&gt; 
                ContactsViewHolder.createViewHolder(inflater, parent)
            ResponseType.GRID.ordinal -&gt; 
                GridViewHolder.createViewHolder(inflater, parent)
            else -&gt; throw 
                  IllegalArgumentException(
                    "The viewtype value of $viewType is not supported"
                  )
        }
    }
}
</pre>
<p>这里，<code>holder</code>函数负责创建我们不同的<code>ViewHolder</code>。</p>
<p>现在，我们可以将<code>TypeFactory</code>传递给不同的<code>viewType</code>并实现<code>type</code>方法:</p>
<pre class="language-kotlin hljs">data class BannerUI(val imageUrl: String): BaseUI {
    override fun type(typeFactory: TypeFactory): Int {
        return typeFactory.type(this)
    }
}

data class QuoteUI(val quote: String, val author: String): BaseUI {
    override fun type(typeFactory: TypeFactory): Int {
        return typeFactory.type(this)
    }
}

data class CarouselUI(val imageUrls: List&lt;String&gt;): BaseUI {
    override fun type(typeFactory: TypeFactory): Int {
        return typeFactory.type(this)
    }
}

data class ContactListUI(val contacts: List&lt;ContactUI&gt;): BaseUI {
    override fun type(typeFactory: TypeFactory): Int {
        return typeFactory.type(this)
    }
}

data class GridUI(val imageUrls: List&lt;String&gt;): BaseUI {
    override fun type(typeFactory: TypeFactory): Int {
        return typeFactory.type(this)
    }
}
</pre>
<p>我们的适配器的<code>onCreateViewHolder</code>和<code>getItemViewType</code>可以简单地将<code>TypeFactory</code>委托给上述视图，从而使<code>adapter</code>类非常精简:</p>
<pre class="language-kotlin hljs">override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): 
    BaseViewHolder&lt;BaseUI&gt; {
    val inflater = LayoutInflater.from(parent.context)
    return typeFactory.holder(inflater, parent, viewType) as BaseViewHolder&lt;BaseUI&gt;
}

override fun onBindViewHolder(holder: BaseViewHolder&lt;BaseUI&gt;, position: Int) {
    holder.bind(uiList[position])
}

override fun getItemCount(): Int = uiList.size

override fun getItemViewType(position: Int): Int {
    return uiList[position].type(typeFactory)
}
</pre>
<p>下次我们添加新的<code>viewType</code>时，我们根本不需要接触适配器类！</p>
<p>访问者模式的实现可以在<a href="https://github.com/jobinlawrance/dynamic-recycler-view">样本回购</a>的<code><a href="https://github.com/jobinlawrance/dynamic-recycler-view/tree/feature/visitor-pattern">feature/visitor-pattern</a></code> <a href="https://github.com/jobinlawrance/dynamic-recycler-view/tree/feature/visitor-pattern">分支</a>中找到。</p>
<h2>结论</h2>
<p>总之，我们看到了如何使用多态适配器在 Kotlin 中映射动态服务器响应。我们还创建了多个<code>ViewHolder</code>并使用<code>recyclerview</code>适配器的<code>getItemViewType</code>函数来指定我们不同的<code>viewType</code></p>
<p>最后，我们使用了一个访问者模式来清理我们的适配器类，这样当我们添加一个新的<code>viewType</code>时，我们不需要编辑我们现有的适配器代码。</p><div class="code-block code-block-32">
<div class="blog-plug inline-plug kotlin-plug"><h2>LogRocket :即时重现你的安卓应用中的问题。</h2><a class="signup" href="https://lp.logrocket.com/blg/kotlin-signup" target="_blank" rel="noopener noreferrer"><img class="alignnone size-full wp-image-46 jetpack-lazy-image" src="../Images/b5ae4bd0ecde7aa9d5288746416d5e18.png" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2022/11/react-native-plug_android-1.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/11/react-native-plug_android-1.png"/><noscript><img data-lazy-fallback="1" class="alignnone size-full wp-image-46" src="../Images/b5ae4bd0ecde7aa9d5288746416d5e18.png" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/11/react-native-plug_android-1.png"/></noscript></a><p><a href="https://lp.logrocket.com/blg/kotlin-signup" target="_blank" rel="noopener noreferrer"> LogRocket </a>是一款 Android 监控解决方案，可以帮助您即时重现问题，确定 bug 的优先级，并了解您的 Android 应用程序的性能。</p><p>LogRocket 还可以向你展示用户是如何与你的应用程序互动的，从而帮助你提高转化率和产品使用率。LogRocket 的产品分析功能揭示了用户不完成特定流程或不采用新功能的原因。</p><p>开始主动监控您的 Android 应用程序— <a class="signup" href="hhttps://lp.logrocket.com/blg/kotlin-signup" target="_blank" rel="noopener noreferrer">免费试用 LogRocket】。</a></p></div>
</div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
<html>
<head>
<title>Implementing local notifications in Flutter - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>在 Flutter - LogRocket 博客中实现本地通知</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/implementing-local-notifications-in-flutter/#0001-01-01">https://blog.logrocket.com/implementing-local-notifications-in-flutter/#0001-01-01</a></blockquote><div><article class="article-post">
<p>通知提醒用户有关他们订阅的应用程序和服务的重要信息。它们旨在改善用户体验，提高应用程序的参与度。</p>
<p>说到移动应用，有两种类型的通知，推送通知和本地通知。在本文中，我们将使用<a href="https://pub.dev/packages/flutter_local_notifications" target="_blank" rel="noopener">flutter _ local _ notifications</a>包在 Android 和 iOS 平台中实现本地通知。</p>
<h1>什么是本地通知？</h1>
<p>使用本地通知是一种在不使用互联网连接的情况下与用户互动并将他们的注意力吸引回你的应用程序的方式，提醒和待办事项应用程序等应用程序会大量使用它们。它们通常是预先安排好的，当用户在应用程序中执行某些操作时就会触发。</p>
<h1>本地通知与推送通知</h1>
<p>本地通知和推送通知的主要区别在于，本地通知由应用程序在本地安排，并由同一设备交付，而推送通知则从远程服务器发送。让我们构建一个项目，这样您就可以看到本地通知是如何工作的。</p>
<h2>向 Flutter 应用程序添加依赖关系</h2>
<p>第一步是在您的终端中运行下面的命令，将最新版本的 flutter_local_notifications 添加到您的<code>pubspec.yaml</code>文件中。</p>
<pre>//run this command in the terminal 
$ flutter pub add flutter_local_notifications
</pre>
<p>接下来，创建一个名为<code>notification_service.dart</code>的新 Dart 文件。你可以给它任何你想要的文件名，但是我更喜欢根据它们的功能来命名文件。</p>
<p>在 Flutter 中，最好的做法是将逻辑从 UI 中分离出来。为此，我们将在<code>notification_service.dart</code>文件中创建一个名为<code>NotificationService</code>的类。这个类将处理所有的通知逻辑，并公开创建、发送、调度和取消通知的方法。</p>
<pre>import 'package:flutter_local_notifications/flutter_local_notifications.dart';

class NotificationService {
  //Singleton pattern
  static final NotificationService _notificationService =
      NotificationService._internal();
  factory NotificationService() {
    return _notificationService;
  }
  NotificationService._internal();

    //instance of FlutterLocalNotificationsPlugin
  final FlutterLocalNotificationsPlugin flutterLocalNotificationsPlugin = 
      FlutterLocalNotificationsPlugin();
}
</pre>
<p>让我们分析一下上面的代码中发生了什么:</p>
<p>我们使用单例模式创建了<code>NotificationService</code>类。此外，在第 12 行，我们创建了一个<code>FlutterLocalNotificationsPlugin</code>的实例，它为 Android 和 iOS 平台初始化 Flutter 本地通知设置。</p>
<h2>配置特定于平台的初始化设置</h2>
<p>让我们来看看如何为 Android 和 iOS 平台配置初始化设置。</p>
<p><strong>配置 Android 初始化设置</strong> <br/>要配置 Android 初始化设置，我们需要传入一个必需的参数，它是将显示在通知栏中的应用程序图标:</p>
<pre>final AndroidInitializationSettings initializationSettingsAndroid = 
  AndroidInitializationSettings('app_icon');
</pre>
<p>现在我们需要将我们的图标作为一个可提取的资源添加到 Android head 项目中。下面是完成此操作的完整路径:</p>
<p><code>YOUR_APPLICATION_FOLDER_NAME\android\app\src\main\res\drawable\YOUR_APP_ICON.png</code></p>
<p><strong>为 iOS 配置初始化设置</strong> <br/>为 iOS 配置这些设置有点复杂，因为我们必须考虑在不同版本的 iOS 操作系统中处理通知的多种方式。</p>
<p>首先，将下面几行添加到 iOS 项目的<code>AppDelegate.swift</code>文件中的<code>didFinishLaunchingWithOptions</code>方法中。</p>
<pre>if #available(iOS 10.0, *) {
  UNUserNotificationCenter.current().delegate = self as? UNUserNotificationCenterDelegate
}
</pre>
<p>我们的<code>AppDelegate.swift</code>文件应该是这样的:</p>
<pre>import UIKit
import Flutter
@UIApplicationMain
@objc class AppDelegate: FlutterAppDelegate {
  override func application(
    _ application: UIApplication,
    didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]?
  ) -&gt; Bool {
    if #available(iOS 10.0, *) {
      UNUserNotificationCenter.current().delegate = self as UNUserNotificationCenterDelegate
    }
    GeneratedPluginRegistrant.register(with: self)
    return super.application(application, didFinishLaunchingWithOptions: launchOptions)
  }
}
</pre>
<p><code>IOSInitializationSettings</code>对象接受三个参数:<code>requestSoundPermission</code>、<code>requestBadgePermission</code>和<code>requestAlertPermission</code>。这些参数控制用户请求的权限。</p>
<p>根据您的用例，您可以选择将所有通知权限设置为<code>false</code>，然后在应用程序的适当位置调用具有所需权限的<code>requestIOSPermissions</code>方法，如下所示。</p>
<pre>//Initialization Settings for iOS devices 
    final IOSInitializationSettings initializationSettingsIOS =
        IOSInitializationSettings(
      requestSoundPermission: false,
      requestBadgePermission: false,
      requestAlertPermission: false,
    );


 void requestIOSPermissions(
    FlutterLocalNotificationsPlugin flutterLocalNotificationsPlugin) {
  flutterLocalNotificationsPlugin
      .resolvePlatformSpecificImplementation&lt;
          IOSFlutterLocalNotificationsPlugin&gt;()
      ?.requestPermissions(
        alert: true,
        badge: true,
        sound: true,
      );
}
</pre>
<h2>创建<code>InitializationSettings</code>对象</h2>
<p>下一步是创建一个<code>InitializationSettings</code>对象。这个插件用于初始化 Android 和 iOS 平台的设置。</p>
<p>一般来说，<code>InitializationSettings</code>有三个命名的可选参数，<code>android</code>、<code>iOS</code>和<code>macOS</code>，它们接受相应的平台初始化设置参数。</p>
<pre>final InitializationSettings initializationSettings =
        InitializationSettings(
            android: initializationSettingsAndroid,
            iOS: initializationSettingsIOS);
</pre>
<p>在配置了特定于平台的初始化设置之后，我们将创建方法<code>init</code>，它将包含我们所有的初始化设置逻辑，并在应用程序启动时从我们的<code>main.dart</code>文件中被调用。</p>
<pre> Future&lt;void&gt; init() async {

    //Initialization Settings for Android
    final AndroidInitializationSettings initializationSettingsAndroid =
        AndroidInitializationSettings('app_icon');

    //Initialization Settings for iOS 
    final IOSInitializationSettings initializationSettingsIOS =
        IOSInitializationSettings(
      requestSoundPermission: false,
      requestBadgePermission: false,
      requestAlertPermission: false,
    );

    //InitializationSettings for initializing settings for both platforms (Android &amp; iOS)
    final InitializationSettings initializationSettings =
        InitializationSettings(
            android: initializationSettingsAndroid,
            iOS: initializationSettingsIOS);

    await flutterLocalNotificationsPlugin.initialize(
      initializationSettings,
    );
  }
</pre>
<p>在上面的代码中，我们将特定于平台的初始化设置传递给了<code>InitializationSettings</code>对象。</p>
<p>下一步是在<code>FlutterLocalNotificationsPlugin</code>对象上调用<code>initialize</code>方法。这个方法接受两个参数,<code>InitializationSettings</code>对象和<code>onSelectNotification</code>属性。</p><div class="code-block code-block-54">
<hr/>
<h3>更多来自 LogRocket 的精彩文章:</h3>

<hr/></div>
<p><code>onSelectNotification</code>属性接受一个回调函数，当通知被点击时该函数将被触发。这个函数包含一个名为<code>payload</code>的必需参数，它包含通过通知传递的任何数据。</p>
<pre>Future selectNotification(String payload) async {
    await Navigator.push(
      context,
      MaterialPageRoute&lt;void&gt;(builder: (context) =&gt; SecondScreen(payload)),
    );
}
</pre>
<p>这里，这个回调函数将触发到<code>SecondScreen</code>的导航，并在用户点击通知时显示与通知相关联的<code>payload</code>。</p>
<p>我们的<code>init</code>方法现在应该是这样的:</p>
<pre> Future&lt;void&gt; init() async {

    //Initialization Settings for Android
    final AndroidInitializationSettings initializationSettingsAndroid =
        AndroidInitializationSettings('app_icon');

    //Initialization Settings for iOS 
    final IOSInitializationSettings initializationSettingsIOS =
        IOSInitializationSettings(
      requestSoundPermission: false,
      requestBadgePermission: false,
      requestAlertPermission: false,
    );

    //InitializationSettings for initializing settings for both platforms (Android &amp; iOS)
    final InitializationSettings initializationSettings =
        InitializationSettings(
            android: initializationSettingsAndroid,
            iOS: initializationSettingsIOS);

    await flutterLocalNotificationsPlugin.initialize(
      initializationSettings, 
      onSelectNotification: selectNotification
    );
  }

Future selectNotification(String payload) async {
    await Navigator.push(
      context,
      MaterialPageRoute&lt;void&gt;(builder: (context) =&gt; SecondScreen(payload)),
    );
}
</pre>
<p>让我们回到我们的<code>main.dart</code>文件。在<code>main</code>函数中，当应用程序在 iOS 设备上启动时，我们将调用<code>init</code>方法和<code>requestiOSPermissions</code>方法向用户请求权限。</p>
<pre>Future&lt;void&gt; main() async {
  WidgetsFlutterBinding.ensureInitialized();
  await NotificationService().init(); // 
  await NotificationService().requestIOSPermissions(); // 
  runApp(MyApp());
}
</pre>
<h2>在 Flutter 中显示通知</h2>
<p>为了显示通知，我们需要创建一个特定于平台的<code>NotificationDetails</code>实例，该实例接受每个平台特有的参数。</p>
<p><code>AndroidNotificationDetails</code>处理 Android 设备中通知的配置。它接受几个参数，比如<code>channelID</code>、<code>channelName</code>、<code>channelDescription</code>、<code>priority</code>、<code>importance</code>等等。</p>
<p><code>iOSNotificationDetails</code>处理 iOS 设备中通知的配置，它接受诸如<code>presentAlert</code>、<code>presentBadge</code>、<code>badgeNumber</code>、<code>subtitle</code>、<code>sound</code>等参数。</p>
<p>下面是<code>AndroidNotificationDetails</code>实例的样子:</p>
<pre>  AndroidNotificationDetails _androidNotificationDetails =
      AndroidNotificationDetails(
    'channel ID',
    'channel name',
    'channel description',
    playSound: true,
    priority: Priority.high,
    importance: Importance.high,
  );
</pre>
<p>下面是<code>iOSNotificationDetails</code>实例的样子:</p>
<pre> IOSNotificationDetails _iosNotificationDetails = IOSNotificationDetails(
    presentAlert: bool?,
    presentBadge: bool?,
    presentSound: bool?,
    badgeNumber: int?
    attachments: List&lt;IOSNotificationAttachment&gt;?
    subtitle: String?, 
        threadIdentifier: String?
  );
</pre>
<p>现在，下一步是创建一个<code>NotificationDetails</code>对象，它接受特定于平台的通知细节对象作为参数。</p>
<pre>const NotificationDetails platformChannelSpecifics = 
  NotificationDetails(
    android: _androidNotificationDetails,
    iOS: _iOSNotificationDetails);
</pre>
<p>接下来我们需要调用<code>FlutterLocalNotificationsPlugin</code>的<code>show</code>方法。<code>show</code>方法负责创建推送通知，它需要一些参数，如<code>id</code>、<code>title</code>、<code>body</code>、<code>notificationDetails</code>和<code>payload</code>。</p>
<blockquote><p><code>id</code>:通知的唯一标识符<br/> <code>title</code>:通知的标题<br/> <code>body</code>:通知消息<br/> <code>notificationDetails</code>:其中我们传入的<code>notificationDetails</code>对象<br/> <code>payload</code>:保存当通知被点击时通过通知传递的数据</p></blockquote>
<pre>await flutterLocalNotificationsPlugin.show(
      0,
      'Notification Title',
      'This is the Notification Body',
      platformChannelSpecifics,
      payload: 'Notification Payload',
    );
</pre>
<p>现在，让我们创建一个<code>showNotification</code>方法并将所有的逻辑封装在其中，然后我们可以从任何地方调用这个方法来显示通知。</p>
<pre>class NotificationService {
  ....
  Future&lt;void&gt; showNotifications() async {
    await flutterLocalNotificationsPlugin.show(
      0,
      'Notification Title',
      'This is the Notification Body',
      platformChannelSpecifics,
      payload: 'Notification Payload',
    );
  }
}
</pre>
<h2>在 Flutter 中调度本地通知</h2>
<p>为了安排一个通知，我们需要调用<code>FlutterLocalNotificationsPlugin</code>的<code>zoneSchedule</code>方法。这个方法需要一个由<code>timezone</code>包提供的<code>TZDateTime</code>类的实例。</p>
<p>因为<code>flutter_local_notifications</code>插件已经依赖于<code>timezone</code>包，所以没有必要在我们的<code>pubspec.yaml</code>文件中添加<code>timezone</code>包作为依赖项。我们只需要将它导入到我们的<code>notification_service.dart</code>文件中并初始化它。</p>
<pre>import 'package:flutter_local_notifications/flutter_local_notifications.dart';
import 'package:timezone/data/latest.dart' as tz;
import 'package:timezone/timezone.dart' as tz;

....

Future&lt;void&gt; init() async {
    final AndroidInitializationSettings initializationSettingsAndroid =
        AndroidInitializationSettings('app_icon');

    final IOSInitializationSettings initializationSettingsIOS =
        IOSInitializationSettings(
      requestSoundPermission: false,
      requestBadgePermission: false,
      requestAlertPermission: false,
    );

    final InitializationSettings initializationSettings =
        InitializationSettings(
            android: initializationSettingsAndroid,
            iOS: initializationSettingsIOS);

    //initialize timezone package here 
    tz.initializeTimeZones();  //  &lt;----

    await flutterLocalNotificationsPlugin.initialize(
      initializationSettings, 
      onSelectNotification: selectNotification
    );
}
</pre>
<p><code>zoneSchedule</code>方法接受几个参数，包括<code>id</code>、<code>title</code>、<code>body</code>、<code>scheduledDate</code>、<code>notificationDetails</code>、<code>payload</code>、<code>uiLocalNotificationDateInterpretation</code>和<code>androidAllowWhileIdle</code>。</p>
<blockquote><p><code>scheduleDate</code>参数指定何时应该显示通知。<code>androidAllowWhileIdle</code>设置为<code>true</code>时，无论设备是否处于低功耗模式，都会确保显示预定通知。</p></blockquote>
<pre>await flutterLocalNotificationsPlugin.zonedSchedule(
        0,
        "Notification Title",
        "This is the Notification Body!",
        tz.TZDateTime.now(tz.local).add(const Duration(seconds: 5)),
        platformChannelSpecifics,
        androidAllowWhileIdle: true,
        uiLocalNotificationDateInterpretation:
            UILocalNotificationDateInterpretation.absoluteTime);
</pre>
<p>现在，让我们创建一个<code>scheduleNotification</code>方法并将所有的逻辑封装在其中，然后我们可以从任何地方调用这个方法来创建一个预定的通知。</p>
<pre>class NotificationService {
  ....
  Future&lt;void&gt; scheduleNotifications() async {
    await flutterLocalNotificationsPlugin.zonedSchedule(
        0,
        "Notification Title",
        "This is the Notification Body!",
        tz.TZDateTime.now(tz.local).add(const Duration(minutes: 5)),
        platformChannelSpecifics,
        androidAllowWhileIdle: true,
        uiLocalNotificationDateInterpretation:
            UILocalNotificationDateInterpretation.absoluteTime);
  }
}
</pre>
<h2>在 Flutter 中取消本地通知</h2>
<p>取消通知时，您可以取消特定通知，也可以取消所有待定通知。让我们来看看您如何做到这一点:</p>
<p><strong>取消单个通知</strong> <br/>要取消一个特定的通知，让我们创建一个名为<code>cancelNotification</code>的新方法，它将包含来自<code>FlutterLocalNotificationsPlugin</code>对象的<code>cancel</code>方法。该方法需要一个参数，即通知的<code>id</code>。</p>
<pre>class NotificationService {
  ....
  Future&lt;void&gt; cancelNotifications() async {
    await flutterLocalNotificationsPlugin.cancel(NOTIFICATION_ID);
  }
}
</pre>
<p><strong>取消所有通知</strong> <br/>要取消所有未决通知，让我们创建一个新方法<code>cancelAllNotifications</code>，它将包含来自<code>FlutterLocalNotificationsPlugin</code>对象的<code>cancelAll</code>方法。</p>
<p>与取消单个通知不同，取消通知的方法只接受一个参数，这个方法不接受任何参数。</p>
<pre>class NotificationService {
  ....
  Future&lt;void&gt; cancelAllNotifications() async {
    await flutterLocalNotificationsPlugin.cancelAll();
  }
}
</pre>
<p>这里有一个<a href="https://github.com/iloveteajay/flutter_local_notification/tree/master/tasker" target="_blank" rel="noopener"> GitHub 库</a>，它包含了本教程的所有代码。如果您想看到最终的构建，只需克隆这个库并在您的计算机上运行它。</p>
<h2>结论</h2>
<p>本地通知对于通知或提醒用户重要信息非常有用，并且可以在没有互联网连接的情况下实现。</p>
<p>你可以阅读 flutter_local_notifications 包<a href="https://pub.dev/packages/flutter_local_notifications" target="_blank" rel="noopener">文档</a>来学习在你的项目中使用本地通知的其他方法。</p><div class="code-block code-block-1">
<div class="blog-plug base-cta"><h2>使用<a class="signup" href="https://lp.logrocket.com/blg/signup" target="_blank" rel="noopener noreferrer"> LogRocket </a>消除传统错误报告的干扰</h2>
<a href="https://lp.logrocket.com/blg/signup" class="signup" target="_blank" rel="noopener noreferrer"><img class="alignnone size-full wp-image-46 jetpack-lazy-image" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/><noscript><img data-lazy-fallback="1" class="alignnone size-full wp-image-46" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/></noscript></a>
<p><a href="https://lp.logrocket.com/blg/signup" target="_blank" rel="noopener noreferrer"> LogRocket </a>是一个数字体验分析解决方案，它可以保护您免受数百个假阳性错误警报的影响，只针对几个真正重要的项目。LogRocket 会告诉您应用程序中实际影响用户的最具影响力的 bug 和 UX 问题。</p>
<p>然后，使用具有深层技术遥测的会话重放来确切地查看用户看到了什么以及是什么导致了问题，就像你在他们身后看一样。</p>
<p>LogRocket 自动聚合客户端错误、JS 异常、前端性能指标和用户交互。然后 LogRocket 使用机器学习来告诉你哪些问题正在影响大多数用户，并提供你需要修复它的上下文。</p>
<p>关注重要的 bug—<a class="signup" href="https://lp.logrocket.com/blg/signup-issue-free" target="_blank" rel="noopener noreferrer">今天就试试 LogRocket】。</a></p></div></div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
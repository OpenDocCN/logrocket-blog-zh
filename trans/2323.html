<html>
<head>
<title>Python file handling: A complete guide - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>Python 文件处理:完整指南</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/python-file-handling-guide/#0001-01-01">https://blog.logrocket.com/python-file-handling-guide/#0001-01-01</a></blockquote><div><article class="article-post">
<p>Python 是一种流行的解释型和动态类型编程语言，用于构建 web 服务、桌面应用程序、自动化脚本和机器学习项目。程序员在处理基于 Python 的软件项目时，经常需要访问操作系统的文件系统。</p>
<p>例如，我们使用文本文件作为输入，编写文本文件作为输出，并经常处理二进制文件。像任何其他流行的通用编程语言一样，Python 也提供了跨平台的文件处理特性。Python 通过几个内置函数和标准模块提供了文件处理特性。</p>
<p>在本文中，我将解释您需要了解的关于 Python 文件处理的一切，包括:</p>

<h2>先决条件</h2>
<p>在开始学习本教程之前，请确保您已经安装了 Python 3 解释器。否则，安装来自<a href="https://www.python.org/downloads/" target="_blank" rel="noopener">官方版本</a>的最新 Python 解释器。您也可以在现有的 Python 项目中使用本教程的代码片段。</p>
<h2 id="reading-files-python">用 Python 读取文件</h2>
<p>作为第一项活动，让我们编写一些代码来读取一个文本文件。我们需要首先创建一个文件对象来读取文件。</p>
<p>Python 提供了内置的<code>open</code>函数来创建具有多种模式的文件对象，例如读模式、写模式等。创建一个名为<code>myFile.txt</code>的文本文件，输入以下内容。</p>
<pre class="language-plaintext hljs">Programming languages
C
C++
Python
JavaScript
Go
</pre>
<p>现在，创建一个名为<code>main.py</code>的新文件，并添加以下代码片段。</p>
<pre class="language-python hljs">myFile = open("myFile.txt", "r") # or open("myFile.txt")
print(myFile.read())
myFile.close()
</pre>
<p>上面代码片段的第一行用给定的文件名创建了<code>myFile</code> file 对象。内置的<code>open</code>函数使用读取模式创建一个文件处理程序，因为我们已经通过第二个参数提供了<code>r</code>标志。</p>
<p>确保在使用文件后调用<code>close</code>方法来释放资源。<code>read</code>方法返回文件内容，所以一旦执行上面的代码，您就会看到内容，如下所示。</p>
<p><img data-attachment-id="75100" data-permalink="https://blog.logrocket.com/python-file-handling-guide/content-displayed-read-method/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2021/11/content-displayed-read-method.png" data-orig-size="730,330" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="content-displayed-read-method" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2021/11/content-displayed-read-method-300x136.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2021/11/content-displayed-read-method.png" decoding="async" class="aligncenter size-full wp-image-75100 jetpack-lazy-image" src="../Images/7983ea5bab646c042024e46026c5cb01.png" alt="The content is displayed in read method" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2021/11/content-displayed-read-method.png 730w, https://blog.logrocket.com/wp-content/uploads/2021/11/content-displayed-read-method-300x136.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2021/11/content-displayed-read-method.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2021/11/content-displayed-read-method.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="75100" data-permalink="https://blog.logrocket.com/python-file-handling-guide/content-displayed-read-method/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2021/11/content-displayed-read-method.png" data-orig-size="730,330" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="content-displayed-read-method" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2021/11/content-displayed-read-method-300x136.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2021/11/content-displayed-read-method.png" decoding="async" loading="lazy" class="aligncenter size-full wp-image-75100" src="../Images/7983ea5bab646c042024e46026c5cb01.png" alt="The content is displayed in read method" srcset="https://blog.logrocket.com/wp-content/uploads/2021/11/content-displayed-read-method.png 730w, https://blog.logrocket.com/wp-content/uploads/2021/11/content-displayed-read-method-300x136.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2021/11/content-displayed-read-method.png"/></noscript>
<p><code>read</code>方法一次读取整个文件。如果您不想一次读取所有内容，您可以用<code>read</code>方法的参数指定一个字节大小。例如，下面的代码片段只读取前 11 个字节。</p>
<pre class="language-python hljs">myFile = open("myFile.txt", "r")
print(myFile.read(11)) # Programming
myFile.close()
</pre>
<p>您将看到第一个单词(“编程”)作为输出——因为第一个单词有 11 个字母，在<a href="https://en.wikipedia.org/wiki/ASCII" target="_blank" rel="noopener"> ASCII 编码</a>中，一个字母的大小等于一个字节。如果您再次打印<code>read(11)</code>的结果，您将会看到接下来的 11 个字节(" languages\n ")，因为文件光标在之前的<code>read(11)</code>方法调用中移动了 11 个位置。您可以使用<code>seek</code>方法将文件光标重置回起点，如下例所示。</p>
<pre class="language-python hljs">myFile = open("myFile.txt")

print(myFile.read(11)) # Programming
print(myFile.read(10)) # languages
myFile.seek(0) # Sets file cursor to the beginning
print(myFile.read(11)) # Programming
myFile.close() 
</pre>
<p>在大多数情况下，逐行处理文件内容很容易。您不需要自己实现面向行的文件读取机制——Python 提供了逐行读取文件的内置特性。您可以使用<code>for-in</code>循环和<code>readlines</code>方法逐行读取文件，如下所示。</p>
<pre class="language-python hljs">myFile = open("myFile.txt", "r")
for line in myFile.readlines():
    print(line)
myFile.close()
</pre>
<p>用一个<code>for-enumerate</code>循环可以获得当前行号，因为<code>readlines</code>方法将使用<a href="https://blog.logrocket.com/working-lists-python/" target="_blank" rel="noopener">列表类型</a>返回行。下面的代码片段将打印行内容及其各自的行号。</p>
<pre class="language-python hljs">myFile = open("myFile.txt", "r")
for i, line in enumerate(myFile.readlines()):
    print(i, line) # line number and content
myFile.close()
</pre>
<h2 id="writing-files-python">用 Python 写文件</h2>
<p>前面，我们通过使用<code>r</code>标志创建了具有读取模式的文件对象。使用读取模式无法写入文件，因此我们必须使用写入模式(<code>w</code>)来写入文件。</p>
<p>也可以使用<code>r+</code>或<code>w+</code>标志同时启用读取和写入模式；我们将在接下来的例子中使用<code>w+</code>旗帜。</p>
<p>为了开始文件写入，让我们通过编写一些 Python 代码将下面的文本输入到当前的<code>myFile.txt</code>中。</p>
<pre class="language-plaintext hljs">Programming languages
Rust
Ruby
TypeScript
Dart
Assembly
</pre>
<p>使用下面的脚本用上面的内容更新<code>myFile.txt</code>。</p>
<pre class="language-python hljs">myFile = open("myFile.txt", "w")

content = """Programming languages
Rust
Ruby
TypeScript
Dart
Assembly"""

myFile.write(content)
myFile.close()
</pre>
<p>这里，我们使用 Python 多行字符串语法定义了文本文件内容，并使用<code>write</code>方法将内容写入文件。确保使用带<code>w</code>标志的写模式，否则写操作将失败，并出现<code>io.UnsupportedOperation</code>异常。</p>
<p>有时，我们经常需要在现有文件中添加新的内容。在这些场景中，由于资源消耗较高，读写整个内容并不是一个好方法。相反，我们可以使用追加模式(<code>a</code>)。</p>
<p>看看下面的代码。它将在<code>myFile.txt</code>的列表中添加一种新的编程语言。</p>
<pre class="language-python hljs">myFile = open("myFile.txt", "a")
myFile.write("\nBash")
myFile.close()
</pre>
<p>上面的代码片段向现有文件添加了一个新行字符(<code>\n</code>)和一个新单词，而没有写入整个文件内容。因此，我们将在编程语言列表中看到一个新条目。尝试添加更多条目，看看会发生什么！</p><div class="code-block code-block-54">
<hr/>
<h3>更多来自 LogRocket 的精彩文章:</h3>

<hr/></div>
<h2 id="reading-file-attributes-python">在 Python 中读取文件属性</h2>
<p>除了原始文件内容，磁盘上的文件将包含一些元数据或文件属性，包括大小、上次修改时间、上次访问时间等。</p>
<p>查看下面的文件代码，它显示了文件大小、上次访问时间和上次修改时间。</p>
<pre class="language-python hljs">import os, time

stat = os.stat("myFile.txt")
print("Size: %s bytes" % stat.st_size)
print("Last accessed: %s" % time.ctime(stat.st_atime))
print("Last modified: %s" % time.ctime(stat.st_mtime))
</pre>
<p><code>os.stat</code>函数返回一个带有许多文件属性细节的 stat 结果对象。这里我们使用<code>st_size</code>来获取文件大小，<code>at_atime</code>来获取最后一次访问文件的时间戳，<code>st_mtime</code>来获取最后一次修改的时间戳。根据您的操作系统，统计结果对象可能会有所不同。例如，在 Windows 操作系统上，您可以通过<code>st_file_attributes</code>键检索特定于 Windows 的文件属性。</p>
<p>如果只需要获取文件大小，可以使用<code>os.path.getsize</code>方法，而不需要检索所有元数据，如下面的代码所示。</p>
<pre class="language-python hljs">import os, time

size = os.path.getsize("myFile.txt")
print("Size: %s bytes" % size)
</pre>
<h2 id="creating-new-python-directories">创建新的 Python 目录</h2>
<p>Python 提供了<code>os.mkdir</code>函数来创建单个目录。下面的代码片段在当前工作目录中创建<code>myFolder</code>。</p>
<pre class="language-python hljs">import os

os.mkdir("myFolder")
</pre>
<p>如果你试图用上面的代码递归地创建多个目录，它将会失败。例如，您不能一次创建<code>myFolder/abc</code>，因为它需要创建多个目录。在这些场景中，<code>os.makedirs</code>函数将帮助我们，如下所示。</p>
<pre class="language-python hljs">import os

os.makedirs("myFolder/abc") # Creates both "myFolder" and "abc"
</pre>
<h2 id="reading-python-directory-contents">读取 Python 目录内容</h2>
<p>Python 还提供了一个简单的 API 来通过<code>os.listdir</code>函数列出目录内容。下面的代码片段列出了当前工作目录中的所有文件和目录。</p>
<pre class="language-python hljs">import os

cur_dir = os.getcwd()
entries = os.listdir(cur_dir)

print("Found %s entries in %s" % (len(entries), cur_dir))
print('-' * 10)
for entry in entries:
    print(entry)
</pre>
<p>一旦您执行了上面的脚本，它将显示您当前目录的条目，如下所示。</p>
<p><img data-attachment-id="75103" data-permalink="https://blog.logrocket.com/python-file-handling-guide/current-directory-entries/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2021/11/current-directory-entries.png" data-orig-size="730,274" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="current-directory-entries" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2021/11/current-directory-entries-300x113.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2021/11/current-directory-entries.png" decoding="async" class="aligncenter size-full wp-image-75103 jetpack-lazy-image" src="../Images/436b596128089e537ce745e6de063f68.png" alt="The entries in your current directory" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2021/11/current-directory-entries.png 730w, https://blog.logrocket.com/wp-content/uploads/2021/11/current-directory-entries-300x113.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2021/11/current-directory-entries.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2021/11/current-directory-entries.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="75103" data-permalink="https://blog.logrocket.com/python-file-handling-guide/current-directory-entries/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2021/11/current-directory-entries.png" data-orig-size="730,274" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="current-directory-entries" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2021/11/current-directory-entries-300x113.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2021/11/current-directory-entries.png" decoding="async" loading="lazy" class="aligncenter size-full wp-image-75103" src="../Images/436b596128089e537ce745e6de063f68.png" alt="The entries in your current directory" srcset="https://blog.logrocket.com/wp-content/uploads/2021/11/current-directory-entries.png 730w, https://blog.logrocket.com/wp-content/uploads/2021/11/current-directory-entries-300x113.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2021/11/current-directory-entries.png"/></noscript>
<p>尝试从不同的目录执行脚本。然后，它将显示该特定目录的条目，因为我们使用了<code>os.getcwd</code>函数来获取当前的工作目录。</p>
<p>有时我们需要递归地列出目录内容。<code>os.walk</code>函数帮助我们进行递归目录列表。下面的代码递归地列出了当前工作目录的所有条目。</p>
<pre class="language-python hljs">import os

cur_dir = os.getcwd()
for root, sub_dirs, files in os.walk(cur_dir):
    rel_root = os.path.relpath(root)
    print("Showing entries of %s" % rel_root)
    print("-" * 10)
    for entry in sub_dirs + files:
            print(entry)
</pre>
<p><code>os.walk</code>函数在内部有一个递归实现。它为每个条目返回三个值:</p>
<ul>
<li>根</li>
<li>子目录</li>
<li>文件条目</li>
</ul>
<p>这里我们分别使用了<code>root</code>、<code>sub_dirs</code>和<code>files</code>变量，用<a href="https://blog.logrocket.com/for-while-loops-python/" target="_blank" rel="noopener">for 循环</a>来捕获所有条目。</p>
<p><img data-attachment-id="75105" data-permalink="https://blog.logrocket.com/python-file-handling-guide/capture-all-entries-for-loop/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2021/11/capture-all-entries-for-loop.png" data-orig-size="730,387" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="capture-all-entries-for-loop" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2021/11/capture-all-entries-for-loop-300x159.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2021/11/capture-all-entries-for-loop.png" decoding="async" class="aligncenter size-full wp-image-75105 jetpack-lazy-image" src="../Images/f547f52e465d4b0ed42d7986839774ef.png" alt="All entries are captured using a for-loop" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2021/11/capture-all-entries-for-loop.png 730w, https://blog.logrocket.com/wp-content/uploads/2021/11/capture-all-entries-for-loop-300x159.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2021/11/capture-all-entries-for-loop.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2021/11/capture-all-entries-for-loop.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="75105" data-permalink="https://blog.logrocket.com/python-file-handling-guide/capture-all-entries-for-loop/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2021/11/capture-all-entries-for-loop.png" data-orig-size="730,387" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="capture-all-entries-for-loop" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2021/11/capture-all-entries-for-loop-300x159.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2021/11/capture-all-entries-for-loop.png" decoding="async" loading="lazy" class="aligncenter size-full wp-image-75105" src="../Images/f547f52e465d4b0ed42d7986839774ef.png" alt="All entries are captured using a for-loop" srcset="https://blog.logrocket.com/wp-content/uploads/2021/11/capture-all-entries-for-loop.png 730w, https://blog.logrocket.com/wp-content/uploads/2021/11/capture-all-entries-for-loop-300x159.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2021/11/capture-all-entries-for-loop.png"/></noscript>
<h2 id="removing-files-directories-python">在 Python 中移除文件或目录</h2>
<p>我们可以使用<code>os.remove</code>函数删除一个文件。可以在<code>os.remove</code>之前使用<code>os.path.exists</code>函数来防止异常。请看下面的示例代码片段。</p>
<pre class="language-python hljs">import os

file_to_remove = "myFile.txt"

if os.path.exists(file_to_remove):
    os.remove(file_to_remove)
else:
    print("%s doesn't exist!" % file_to_remove)
</pre>
<p>Python 标准库还提供了<code>os.rmdir</code>函数来删除单个目录。它的行为类似于<code>os.mkdir</code>，如果特定的目录有一些条目，它不会删除这个目录。首先，尝试用下面的代码删除一个目录。</p>
<pre class="language-python hljs">import os

dir_to_remove = "myFolder"

if os.path.exists(dir_to_remove):
    os.rmdir(dir_to_remove)
else:
    print("%s doesn't exist!" % dir_to_remove)
</pre>
<p>如果<code>myFolder</code>包含子文件夹或文件，上面的代码将抛出一个错误。使用下面的代码片段递归删除一个目录。</p>
<pre class="language-python hljs">import os, shutil

dir_to_remove = "myFolder"

if os.path.exists(dir_to_remove):
    shutil.rmtree(dir_to_remove) # Recursively remove all entries
else:
    print("%s doesn't exist!" % dir_to_remove)
</pre>
<h2 id="performing-file-searches-python">在 Python 中执行文件搜索</h2>
<p>当我们使用自动化脚本时，有时我们需要在磁盘上执行文件搜索。例如，程序员经常需要通过他们的 Python 脚本找到日志文件、图像文件和各种文本文件。在 Python 中执行文件搜索有几种不同的方法:</p>
<ul>
<li>使用<code>os.listdir</code>函数查找所有条目，并在<code>for</code>循环中使用<code>if</code>条件检查每个条目</li>
<li>用<code>os.walktree</code>函数递归查找所有条目，并用<code>for</code>循环中的<code>if</code>条件验证每个条目。</li>
<li>用<code>glob.glob</code>函数查询所有条目，只获取你需要的条目</li>
</ul>
<p>总的来说，第三种方法最适合大多数场景，因为它具有内置的过滤支持、非常好的性能，并且只需要开发人员编写最少的代码(更 Pythonic 化)。让我们用 Python glob 模块实现一个文件搜索。</p>
<pre class="language-python hljs">import glob, os

query = "**/*.py"

entries = glob.glob(query, recursive=True)
no_of_entries = len(entries)
if no_of_entries == 0:
    print("No results for query: %s" % query)
else:
    print("Found %s result(s) for query: %s" % (no_of_entries, query))

print("-" * 10)
for entry in entries:
    print(entry)
</pre>
<p>上面的代码递归地列出了当前目录中的所有 Python 源文件。查询变量中的前两个星号(<code>**</code>)指示 Python 搜索每个子目录，而最后一个星号表示任何文件名。</p>
<p>运行上面的脚本。您将看到 Python 源文件，如下所示。</p>
<p><img data-attachment-id="75107" data-permalink="https://blog.logrocket.com/python-file-handling-guide/python-source-files/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2021/11/python-source-files.png" data-orig-size="730,318" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="python-source-files" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2021/11/python-source-files-300x131.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2021/11/python-source-files.png" decoding="async" class="aligncenter size-full wp-image-75107 jetpack-lazy-image" src="../Images/110e715e21c0449bd2572d6815af842e.png" alt="The Python source files after you run the script" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2021/11/python-source-files.png 730w, https://blog.logrocket.com/wp-content/uploads/2021/11/python-source-files-300x131.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2021/11/python-source-files.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2021/11/python-source-files.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="75107" data-permalink="https://blog.logrocket.com/python-file-handling-guide/python-source-files/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2021/11/python-source-files.png" data-orig-size="730,318" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="python-source-files" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2021/11/python-source-files-300x131.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2021/11/python-source-files.png" decoding="async" loading="lazy" class="aligncenter size-full wp-image-75107" src="../Images/110e715e21c0449bd2572d6815af842e.png" alt="The Python source files after you run the script" srcset="https://blog.logrocket.com/wp-content/uploads/2021/11/python-source-files.png 730w, https://blog.logrocket.com/wp-content/uploads/2021/11/python-source-files-300x131.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2021/11/python-source-files.png"/></noscript>
<p>尝试通过改变<code>query</code>变量来搜索不同的文件类型。</p>
<h2 id="processing-binary-files-python">用 Python 处理二进制文件</h2>
<p>之前，我们处理文本文件。默认情况下，内置的<code>open</code>函数使用文本模式(<code>t</code>)创建文件对象。图像文件、zip 文件和视频文件等非文本文件不能作为纯文本文件查看，因为没有可读的英语句子二进制文件。因此，我们必须通过字节级(或位级)处理将二进制文件视为非文本文件。</p>
<p>为了开始二进制文件处理，让我们写一个有一些字节的二进制文件。我们将把下面的字节保存到<code>myFile.bin</code>中。</p>
<pre class="language-plaintext hljs">01010000 01111001 01110100 01101000 01101111 01101110
</pre>
<p>为简单起见，我们可以分别用下面的十进制值来表示上述字节。</p>
<pre class="language-plaintext hljs">80 121 116 104 111 110
</pre>
<p>现在，将以下代码添加到 Python 源文件中，并执行它来创建二进制文件。</p>
<pre class="language-python hljs">myBinaryFile = open("myFile.bin", "wb") # wb -&gt; write binary
bytes = bytearray([80, 121, 116, 104, 111, 110])
myBinaryFile.write(bytes)
myBinaryFile.close()
</pre>
<p>这里，我们将一个字节数组实例传递给 file 对象的<code>write</code>方法。另外，请注意，我们使用二进制模式(<code>b</code>)来创建文件对象。执行上述代码片段后，用您喜欢的文本编辑器打开新创建的<code>myFile.bin</code>。您将看到以下结果。</p>
<p><img data-attachment-id="75109" data-permalink="https://blog.logrocket.com/python-file-handling-guide/myfile-bin-view/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2021/11/myfile-bin-view.png" data-orig-size="730,370" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="myfile-bin-view" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2021/11/myfile-bin-view-300x152.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2021/11/myfile-bin-view.png" decoding="async" class="aligncenter size-full wp-image-75109 jetpack-lazy-image" src="../Images/0449a6958b3b6072cd98fc58e327884f.png" alt="The view of the myFile.bin file" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2021/11/myfile-bin-view.png 730w, https://blog.logrocket.com/wp-content/uploads/2021/11/myfile-bin-view-300x152.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2021/11/myfile-bin-view.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2021/11/myfile-bin-view.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="75109" data-permalink="https://blog.logrocket.com/python-file-handling-guide/myfile-bin-view/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2021/11/myfile-bin-view.png" data-orig-size="730,370" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="myfile-bin-view" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2021/11/myfile-bin-view-300x152.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2021/11/myfile-bin-view.png" decoding="async" loading="lazy" class="aligncenter size-full wp-image-75109" src="../Images/0449a6958b3b6072cd98fc58e327884f.png" alt="The view of the myFile.bin file" srcset="https://blog.logrocket.com/wp-content/uploads/2021/11/myfile-bin-view.png 730w, https://blog.logrocket.com/wp-content/uploads/2021/11/myfile-bin-view-300x152.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2021/11/myfile-bin-view.png"/></noscript>
<p>我们已经收到“Python”作为输出，因为字节数组的字节表示已知的 ASCII 字符。例如，<code>80</code> ( <code>01010000</code>)代表 ASCII 编码中的字母<code>P</code>。即使我们在二进制文件中保存了可读的文本，几乎所有的二进制文件都包含不可读的字节流。尝试通过文本编辑器打开图像文件。</p>
<p>现在，我们可以在下面的示例代码中看到二进制文件读取操作。</p>
<pre class="language-python hljs">myBinaryFile = open("myFile.bin", "rb")

bytes = myBinaryFile.read()
print(bytes) # bytearray(b'Python')
print("Bytes: ", list(bytes)) # Bytes:  [80, 121, 116, 104, 111, 110]
myBinaryFile.close()
</pre>
<p>Python 使用二进制模式的<code>read</code>方法返回字节。这里我们使用<code>bytearray</code>构造函数将字节转换成了一个<code>bytearray</code>实例。</p>

<p>程序员经常将归档文件与基于 Python 的 web 应用程序、web 服务、桌面应用程序和实用程序一起使用，以便一次输出或输入多个文件。例如，如果您正在构建一个基于 web 的文件管理器，您可以为用户提供一个功能，通过编程生成的 zip 文件一次下载多个文件。</p>
<p>Python 标准库通过<code>shutil</code>模块提供了归档文件处理 API。首先，让我们用<code>myFolder</code>的内容做一个存档。看看下面的代码。确保在运行代码片段之前创建<code>myFolder</code>并在其中添加一些文件。</p>
<pre class="language-python hljs">import shutil

output_file = "myArchive"
input_dir = "myFolder"
shutil.make_archive(output_file, "zip", input_dir)
</pre>
<p>您可以使用下面的代码将归档文件提取到<code>myNewFolder</code>中。</p>
<pre class="language-python hljs">import shutil

input_file = "myArchive.zip"
output_dir = "myNewFolder"
shutil.unpack_archive(input_file, output_dir)
</pre>
<h2 id="copying-moving-files">复制和移动文件</h2>
<p><code>shutil</code>模块还提供了跨平台的 API 函数来复制和移动文件。看看下面的例子。</p>
<pre class="language-python hljs">import shutil

# copy main.py -&gt; main_copy.py
shutil.copy("main.py", "main_copy.py")
# move (rename) main_copy.py -&gt; main_backup.py 
shutil.move("main_copy.py", "main_backup.py")
# recursive copy myFolder -&gt; myFolder_copy
shutil.copytree("myFolder", "myFolder_copy")
# move (rename) myFolder_copy -&gt; myFolder_backup
# if myFolder_backup exists, source is moved inside folder
shutil.move("myFolder_copy", "myFolder_backup")
print("Done.")
</pre>
<h2 id="python-file-handling-best-practices">Python 文件处理最佳实践</h2>
<p>程序员遵循不同的编码实践。类似地，Python 程序员在处理文件时也遵循不同的编码实践。</p>
<p>例如，一些程序员手动使用 try-finally 阻塞和关闭文件处理程序。一些程序员通过省略<code>close</code>方法调用让垃圾收集器关闭文件处理程序——这不是一个好的做法。同时，其他程序员使用<code>with</code>语法来处理文件处理程序。</p>
<p>在这一节中，我将总结 Python 中文件处理的一些最佳实践。首先，看看下面遵循文件处理最佳实践的代码。</p>
<pre class="language-python hljs">def print_file_content(filename):
    with open(filename) as myFile:
        content = myFile.read()
        print(content)

file_to_read = "myFile.txt"

try:        
    print_file_content(file_to_read)
except:
    print("Unable to open file %s " % file_to_read)
else:
    print("Successfully print %s's content" % file_to_read)
</pre>
<p>这里，我们使用了<code>with</code>关键字来隐式关闭文件处理程序。此外，我们用 try-except 块处理可能的异常。当您使用 Python 文件处理时，可以确保您的代码具有以下几点。</p>
<ul>
<li>永远不要忽略异常——尤其是对于长时间运行的 Python 流程。但是，可以忽略简单实用程序脚本的异常，因为未处理的异常会阻止实用程序脚本继续运行</li>
<li>如果没有使用<code>with</code>语法，请确保正确关闭打开的文件处理程序。Python 垃圾收集器将清理未关闭的文件处理程序，但是通过我们的代码关闭文件处理程序总是好的，以避免不必要的资源使用</li>
<li>确保在代码库中统一文件处理语法。例如，如果您使用<code>with</code>关键字来处理文件，请确保在处理文件的所有地方使用相同的语法</li>
<li>当使用多个处理程序进行读写时，避免再次打开同一个文件。相反，使用<code>flush</code>和<code>seek</code>方法，如下所示:</li>
</ul>
<pre class="language-python hljs">def process_file(filename):
    with open(filename, "w+") as myFile: 
    # w+: read/write and create if doesn't exist unlike r+
        # Write content
        myFile.write("Hello Python!")
        print("Cursor position: ", myFile.tell()) # 13
        # Reset internal buffer
        myFile.flush()
        # Set cursor to the beginning
        myFile.seek(0)
        print("Cursor position: ", myFile.tell()) # 0
        # Print new content
        content = myFile.read()
        print(content)
        print("Cursor position: ", myFile.tell()) # 13
file_to_read = "myFile.txt"
try:        
    process_file(file_to_read)
except:
    print("Unable to process file %s " % file_to_read)
else:
    print("Successfully processed %s" % file_to_read)</pre>
<p>以上内容先将一个字符串保存到文件中。之后，它通过重置内部缓冲区再次读取新添加的内容。<code>flush</code>方法清除内存中临时保存的数据，因此下一次读取将返回新添加的内容。此外，我们需要使用<code>seek(0)</code>方法调用将光标重置到开头，因为<code>write</code>方法将它设置到结尾。</p>
<h2>结论</h2>
<p>Python 为程序员提供了一种简单的语法。因此，几乎所有的文件操作都很容易实现。但是，Python 在标准库设计上有一些问题，所以同一件事有多个 API 函数。因此，您必须根据您的要求选择最合适的标准模块。</p>
<p>此外，与其他流行的编程语言相比，Python 是一种很慢的语言。记住这一点，确保在不使用太多资源的情况下优化您的 Python 脚本。例如，您可以通过逐行处理大型文本文件来优化性能，而不必一次处理全部内容。</p>
<p>在本教程中，我们讨论了通用文本文件处理和二进制文件处理。如果您需要处理特定的文件格式，选择一个更好的库或标准模块可能是值得的。例如，您可以使用<a href="https://docs.python.org/3/library/csv.html" target="_blank" rel="noopener"> csv 标准模块</a>处理 csv 文件，使用<a href="https://github.com/mstamy2/PyPDF2" target="_blank" rel="noopener"> PyPDF2 库</a>处理 PDF 文件。另外，<a href="https://docs.python.org/3/library/pickle.html" target="_blank" rel="noopener"> pickle 标准模块</a>帮助你存储(和加载)Python 数据对象和文件。</p>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
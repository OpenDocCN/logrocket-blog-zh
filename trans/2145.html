<html>
<head>
<title>Build an Instagram-like infinite scrolling feed with React Query - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>用 React Query - LogRocket 博客构建一个类似 Instagram 的无限滚动提要</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/build-instagram-infinite-scrolling-feed-react-query/#0001-01-01">https://blog.logrocket.com/build-instagram-infinite-scrolling-feed-react-query/#0001-01-01</a></blockquote><div><article class="article-post">
<p>无限滚动是一种流行的交互模式，允许用户在向下滚动页面的同时不断加载内容。这意味着应用程序获取一小块数据，并随着用户滚动继续获取更多数据。</p>
<p>这种模式最常见的一个用例出现在 Instagram 和 Twitter 等大型社交媒体网站上。与在初始加载期间获取网站的全部数据相比，这提供了重大的性能改进。</p>
<p>在本文中，我们将学习如何使用 React Query 的<code>useInifiniteQuery()</code>钩子在 React 应用程序中构建一个类似 Instagram 的无限滚动提要。</p>
<h2>React 查询先决条件和演示</h2>
<p>本文假设您对 React 组件、常见的挂钩(如<a href="https://blog.logrocket.com/noobs-guide-to-usestate/"> <code>useState()</code> </a>和<code><a href="https://blog.logrocket.com/guide-to-react-useeffect-hook/">useEffect()</a></code>)有基本的了解，并且熟悉向 React 项目添加 npm 包。</p>
<p>如果你是 React Query 的新手，你可以看看 React Query 的新特性来了解更多关于它的信息和它的好处。然而，在本文中我们将只讨论<code>useInfiniteQuery()</code>钩子。</p>
<p>要完整预览这个项目，请访问这个<a href="https://codesandbox.io/s/completed-demo-r9fkj"> CodeSandbox 链接，查看源代码和演示</a>。</p>
<p><img data-attachment-id="66150" data-permalink="https://blog.logrocket.com/build-instagram-infinite-scrolling-feed-react-query/final-react-query-instagram-page/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2021/09/Final-React-Query-Instagram-page.gif" data-orig-size="730,411" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Final React Query Instagram page" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2021/09/Final-React-Query-Instagram-page-300x169.gif" data-large-file="https://blog.logrocket.com/wp-content/uploads/2021/09/Final-React-Query-Instagram-page.gif" decoding="async" class="aligncenter size-full wp-image-66150 jetpack-lazy-image" src="../Images/b431ab9cdc02b32557fe2f4219a12994.png" alt="The Final Instagram-Like Page Using React Query, Shows A User Scrolling Through Photos That Continuously Load As The User Nears The Bottom" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2021/09/Final-React-Query-Instagram-page.gif?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2021/09/Final-React-Query-Instagram-page.gif"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="66150" data-permalink="https://blog.logrocket.com/build-instagram-infinite-scrolling-feed-react-query/final-react-query-instagram-page/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2021/09/Final-React-Query-Instagram-page.gif" data-orig-size="730,411" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Final React Query Instagram page" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2021/09/Final-React-Query-Instagram-page-300x169.gif" data-large-file="https://blog.logrocket.com/wp-content/uploads/2021/09/Final-React-Query-Instagram-page.gif" decoding="async" loading="lazy" class="aligncenter size-full wp-image-66150" src="../Images/b431ab9cdc02b32557fe2f4219a12994.png" alt="The Final Instagram-Like Page Using React Query, Shows A User Scrolling Through Photos That Continuously Load As The User Nears The Bottom" data-original-src="https://blog.logrocket.com/wp-content/uploads/2021/09/Final-React-Query-Instagram-page.gif"/></noscript>
<h2>为什么使用 React Query？</h2>
<p>React 是一个非个人化的 JavaScript 库，用于构建交互式和可伸缩的 web 应用程序。然而，这种非个人化的特性也是一把双刃剑，因为它没有内置的数据获取解决方案。</p>
<p>虽然您可以实现自己的数据获取机制，但 React Query 以挂钩的形式提供了一种更简单、更有效的方式来管理异步服务器状态。</p>
<p>这些挂钩还带来了缓存响应数据、对多个请求进行重复数据删除以及更多性能优化的额外好处。</p>
<p>这个库中一些最常用的钩子是<code>useQuery()</code>钩子，它从 API 获取数据，以及<code>useMutation()</code>钩子，它创建、更新和删除服务器数据。</p>
<p><code>useInfiniteQuery()</code>钩子只是<code>useQuery()</code>钩子的一个修改版本，提供无限滚动功能。</p>
<h2>理解<code>useInfiniteQuery()</code>挂钩</h2>
<p>在深入项目之前，让我们花点时间了解一下<code>useInfiniteQuery()</code>钩子是如何工作的，以及如何使用它。这个钩子带有两个强制参数:查询键和查询函数，以及一个可选的<code>options</code>对象。</p>
<p>这个钩子返回一些值和函数，这些值和函数可以检索获取的数据，检查查询的状态(比如<code>error</code>、<code>loading</code>、<code>fetching</code>或<code>idle</code>，并检查是否有更多的页面或其他信息要发送给无限滚动条组件。</p>
<p>关于<code><a href="https://react-query.tanstack.com/reference/useInfiniteQuery">useInfiniteQuery()</a></code> <a href="https://react-query.tanstack.com/reference/useInfiniteQuery">钩子的详细解释，参见官方 API 参考文档</a>。</p>
<p>现在，让我们在接下来的几节中探索这个钩子的实际用法。</p>
<h2>构建<code>useInfiniteQuery()</code>项目</h2>
<p>为了与这个项目一起编码，您可以访问这个<a href="https://codesandbox.io/s/starter-files-6b55e"> CodeSandbox 链接来获得预安装了所有依赖项的 starter 文件</a>，或者通过运行这个命令使用<code>create-react-app</code>工具在您的本地机器上创建一个新的 React 应用程序:</p>
<pre>npx create-react-app infinite-scroll
</pre>
<p>如果您选择在本地计算机上创建 React 应用程序，请使用下面给出的命令安装 React Query 和 infinite scroller 组件:</p>
<pre>npm install react-query react-infinite-scroller
#or
yarn add react-query react-infinite-scroller
</pre>
<p>虽然 React Query 可以帮助您获取数据，但是否提供 infinite scroller 组件的 UI 实现取决于您。这就是我们使用<code>react-infinite-scroller</code>库的原因。</p>
<h3>配置反应查询</h3>
<p>在我们开始使用 React Query 的钩子之前，我们必须从<code>react-query</code>导入<code>QueryClient</code>和<code>QueryClientProvider</code>,并在<code>index.js</code>文件中用<code>&lt;App /&gt;</code>组件包装它。</p>
<p>这确保了 React 应用程序中的所有组件都可以访问钩子和缓存:</p>
<pre>#index.js
import { QueryClient, QueryClientProvider } from "react-query";
import { ReactQueryDevtools } from "react-query/devtools";
import ReactDOM from "react-dom";
import App from "./App";

const queryClient = new QueryClient();

ReactDOM.render(
  &lt;QueryClientProvider client={queryClient}&gt;
    &lt;App /&gt;
    &lt;ReactQueryDevTools /&gt;
  &lt;/QueryClientProvider&gt;,
 document.getElementById("root")
);
</pre>
<p>这段代码呈现了我们的图片最终将驻留的登录页面:</p>
<p><img data-attachment-id="66152" data-permalink="https://blog.logrocket.com/build-instagram-infinite-scrolling-feed-react-query/blank-scrolling-feed-page/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2021/09/Blank-scrolling-feed-page.png" data-orig-size="730,423" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Blank scrolling feed page" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2021/09/Blank-scrolling-feed-page-300x174.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2021/09/Blank-scrolling-feed-page.png" decoding="async" class="aligncenter size-full wp-image-66152 jetpack-lazy-image" src="../Images/152b20f0713ae98f846a93d5440ef450.png" alt="Blank Scrolling Feed Page Where Photos Will Eventually Be Placed" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2021/09/Blank-scrolling-feed-page.png 730w, https://blog.logrocket.com/wp-content/uploads/2021/09/Blank-scrolling-feed-page-300x174.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2021/09/Blank-scrolling-feed-page.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2021/09/Blank-scrolling-feed-page.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="66152" data-permalink="https://blog.logrocket.com/build-instagram-infinite-scrolling-feed-react-query/blank-scrolling-feed-page/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2021/09/Blank-scrolling-feed-page.png" data-orig-size="730,423" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Blank scrolling feed page" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2021/09/Blank-scrolling-feed-page-300x174.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2021/09/Blank-scrolling-feed-page.png" decoding="async" loading="lazy" class="aligncenter size-full wp-image-66152" src="../Images/152b20f0713ae98f846a93d5440ef450.png" alt="Blank Scrolling Feed Page Where Photos Will Eventually Be Placed" srcset="https://blog.logrocket.com/wp-content/uploads/2021/09/Blank-scrolling-feed-page.png 730w, https://blog.logrocket.com/wp-content/uploads/2021/09/Blank-scrolling-feed-page-300x174.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2021/09/Blank-scrolling-feed-page.png"/></noscript>
<p>在上面的例子中，我们还导入了 React Query Devtools，这是一个方便的工具，带有内置的<code>react-query</code>来监控网络请求和其他查询细节。</p>
<p>这样，我们就完成了将 React Query 集成到 React 项目中。就这么简单。</p>
<h3>使用 Lorem Picsum API</h3>
<p>为了显示无限滚动提要的图像，我们将使用<a href="https://picsum.photos/"> Lorem Picsum API </a>以 JSON 格式获取一组图像及其信息。更具体地说，我们将使用以下 API 端点:</p>
<pre>https://picsum.photos/v2/list?page=1&amp;limit=10
</pre>
<p>使用<code>limit</code>查询参数，我们可以将每个 API 调用获取的图像数量设置为<code>10</code>。这最初检索 10 个图像，并且每当用户接近到达提要的末尾时继续获取 10 个以上的图像。</p>
<p>通过增加查询参数<code>page</code>,我们可以获取下一组图像。最初，<code>page</code>查询参数被设置为<code>1</code>以从第一页开始。</p>
<p>来自上述端点的响应如下所示:</p>
<pre>[
  {
    "id": "0",
    "author": "Alejandro Escamilla",
    "width": 5616,
    "height": 3744,
    "url": "https://unsplash.com/photos/yC-Yzbqy7PY",
    "download_url": "https://picsum.photos/id/0/5616/3744"
  },
  {
    ...
  },
  {
    ...
  }
]
</pre>
<p>同样值得注意的是，这个 API 端点总共提供了 1000 个图像。因此，使用每个 API 调用 10 个图像的限制，我们可以预期有 100 页图像。</p><div class="code-block code-block-54">
<hr/>
<h3>更多来自 LogRocket 的精彩文章:</h3>

<hr/></div>
<h3>构建和设计一个组件</h3>
<p>让我们制作一个简单的 React 组件来显示图像及其作者。首先，在<code>src</code>目录中创建一个名为<code>components</code>的文件夹。在这个<code>components</code>文件夹中，创建一个名为<code>PostCard.jsx</code>的新文件，并粘贴以下代码:</p>
<pre>// components/PostCard.jsx
const PostCard = ({ post }) =&gt; {
  return (
    &lt;div className="post-card"&gt;
      &lt;h4&gt;{post.author}&lt;/h4&gt;
      &lt;img src={post.download_url} alt={post.author} /&gt;
    &lt;/div&gt;
  );
};
export default PostCard;
</pre>
<p>该组件采用一个名为<code>post</code>的道具，并使用<code>author</code>和<code>download_url</code>属性来显示作者的姓名和图像。要设计这个组件的样式，将下面给出的 CSS 附加到<code>App.css</code>文件中:</p>
<pre>// App.css
.post-card {
  display: flex;
  flex-direction: column;
  border: 1px solid #dbdbdb;
  margin-bottom: 1.5rem;
}
.post-card h4 {
  background: #fafafa;
  padding: 0.5rem;
}
.post-card img {
  height: 300px;
  width: 500px;
  object-fit: cover;
}
</pre>
<p><code>PostCard</code>组件现在可以在<code>App.js</code>文件中使用了。现在让我们继续从 API 获取数据。</p>
<h3>实现无限滚动</h3>
<p>要开始在我们的应用程序中实现无限滚动，让我们创建一个名为<code>fetchPosts()</code>的函数，向端点发出一个<code>GET</code>请求，并根据页码和限制检索一组帖子:</p>
<pre>const fetchPosts = async ({ pageParam = 1 }) =&gt; {
  const response = await fetch(
    `https://picsum.photos/v2/list?page=${pageParam}&amp;limit=10`
  );
  const results = await response.json();
  return { results, nextPage: pageParam + 1, totalPages: 100 };
};
</pre>
<p>该函数还接受 React Query 在调用该函数时自动传递的<code>pageParam</code>参数。在这种情况下，<code>pageParam</code>是页码。</p>
<p>由于我们使用的 API 没有在响应中提供总页数和下一页的页码，所以让我们返回一个带有这些属性的自定义对象，因为我们知道下一页的页码将是当前页码加 1，总页数将是 100。</p>
<p>现在，从<code>react-query</code>导入<code>useInfiniteQuery()</code>钩子，并以这种方式使用它:</p>
<pre>const { data, isLoading, isError, hasNextPage, fetchNextPage } =
  useInfiniteQuery("posts", fetchPosts, {
    getNextPageParam: (lastPage, pages) =&gt; {
      if (lastPage.nextPage &lt; lastPage.totalPages) return lastPage.nextPage;
      return undefined;
    },
  });
</pre>
<p>将<code>"posts"</code>作为查询键，将<code>fetchPosts</code>函数作为查询函数。作为第三个参数，传递一个包含<code>getNextPageParam</code>函数的对象，如上所示。</p>
<p>这个函数获取下一页的页码。如果我们已经在最后一页，我们可以返回<code>undefined</code>，这样 React Query 就不会试图获取更多数据。</p>
<p>最后，我们可以析构出由页面、<code>isLoading</code>布尔、<code>isError</code>布尔、<code>hasNext</code>布尔和<code>fetchNextPage</code>函数组成的<code>data</code>数组来相应地呈现 UI。</p>
<h3>导入<code>InfiniteScroll</code>组件</h3>
<p>现在，从<code>react-infinite-scroller</code>导入<code>InfiniteScroll</code>组件。映射通过<code>data.pages</code>数组的每一页里面的所有帖子来渲染<code>&lt;InfiniteScroll&gt;</code>里面的<code>&lt;PostCard /&gt;</code>组件:</p>
<pre>&lt;InfiniteScroll hasMore={hasNextPage} loadMore={fetchNextPage}&gt;
  {data.pages.map((page) =&gt;
    page.results.map((post) =&gt; &lt;PostCard key={post.id} post={post} /&gt;)
  )}
&lt;/InfiniteScroll&gt;;
</pre>
<p><code>&lt;InfiniteScroll&gt;</code>组件有两个道具:<code>hasMore</code>，一个布尔值用来检查是否有更多的页面要获取，还有一个<code>loadMore</code>函数用来在用户接近页面末尾时获取更多的文章。</p>
<p>从<code>useInfiniteQuery()</code>的返回属性中构造的<code>hasNextPage</code>布尔可以用作<code>hasMore</code>属性的值。</p>
<p>类似地，return 属性还包含一个<code>fetchNextPage</code>函数，该函数可以获取下一页的结果，并用作<code>loadMore</code>属性的值。</p>
<p>最后，在将所有代码片段和一些条件渲染拼凑在一起后，我们的<code>App.js</code>文件看起来会像这样:</p>
<pre>// App.js
import InfiniteScroll from "react-infinite-scroller";
import { useInfiniteQuery } from "react-query";
import Navbar from "./components/Navbar";
import PostCard from "./components/PostCard";
import "./styles.css";
export default function App() {
  const fetchPosts = async ({ pageParam = 1 }) =&gt; {
    const response = await fetch(
      `https://picsum.photos/v2/list?page=${pageParam}&amp;limit=10`
    );
    const results = await response.json();
    return { results, nextPage: pageParam + 1, totalPages: 100 };
  };
  const {
    data,
    isLoading,
    isError,
    hasNextPage,
    fetchNextPage
  } = useInfiniteQuery("posts", fetchPosts, {
    getNextPageParam: (lastPage, pages) =&gt; {
      if (lastPage.nextPage &lt; lastPage.totalPages) return lastPage.nextPage;
      return undefined;
    }
  });
  return (
    &lt;div className="App"&gt;
      &lt;Navbar /&gt;
      &lt;main&gt;
        {isLoading ? (
          &lt;p&gt;Loading...&lt;/p&gt;
        ) : isError ? (
          &lt;p&gt;There was an error&lt;/p&gt;
        ) : (
          &lt;InfiniteScroll hasMore={hasNextPage} loadMore={fetchNextPage}&gt;
            {data.pages.map((page) =&gt;
              page.results.map((post) =&gt; &lt;PostCard key={post.id} post={post} /&gt;)
            )}
          &lt;/InfiniteScroll&gt;
        )}
      &lt;/main&gt;
    &lt;/div&gt;
  );
}
</pre>
<p>因此，最终呈现出类似 instagram 的无限滚动提要:</p>
<p><img data-attachment-id="66154" data-permalink="https://blog.logrocket.com/build-instagram-infinite-scrolling-feed-react-query/final-react-scrolling-feed-layout/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2021/09/Final-React-scrolling-feed-layout.png" data-orig-size="730,428" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Final React scrolling feed layout" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2021/09/Final-React-scrolling-feed-layout-300x176.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2021/09/Final-React-scrolling-feed-layout.png" decoding="async" class="aligncenter size-full wp-image-66154 jetpack-lazy-image" src="../Images/8fd89854aacb94361ba30bb23ff8c5d0.png" alt="Final React Query Scrolling Feed Layout, Shows Heading, Two Photos, Each With A Title And The Author Of Each Post" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2021/09/Final-React-scrolling-feed-layout.png 730w, https://blog.logrocket.com/wp-content/uploads/2021/09/Final-React-scrolling-feed-layout-300x176.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2021/09/Final-React-scrolling-feed-layout.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2021/09/Final-React-scrolling-feed-layout.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="66154" data-permalink="https://blog.logrocket.com/build-instagram-infinite-scrolling-feed-react-query/final-react-scrolling-feed-layout/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2021/09/Final-React-scrolling-feed-layout.png" data-orig-size="730,428" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Final React scrolling feed layout" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2021/09/Final-React-scrolling-feed-layout-300x176.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2021/09/Final-React-scrolling-feed-layout.png" decoding="async" loading="lazy" class="aligncenter size-full wp-image-66154" src="../Images/8fd89854aacb94361ba30bb23ff8c5d0.png" alt="Final React Query Scrolling Feed Layout, Shows Heading, Two Photos, Each With A Title And The Author Of Each Post" srcset="https://blog.logrocket.com/wp-content/uploads/2021/09/Final-React-scrolling-feed-layout.png 730w, https://blog.logrocket.com/wp-content/uploads/2021/09/Final-React-scrolling-feed-layout-300x176.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2021/09/Final-React-scrolling-feed-layout.png"/></noscript>
<h2>结论</h2>
<p>至此，您已经使用 React Query、Lorem Picsum API 和 React <code>InfiniteScroll</code>组件成功构建了自己的无限滚动图像提要。您可以使用这个概念为您的项目构建任何类型的无限滚动提要。</p><div class="code-block code-block-17">
<div class="blog-plug inline-plug react-plug" vwo-el-id="26283398190">
<h2 vwo-el-id="41600691720">使用 LogRocket 消除传统反应错误报告的噪音</h2>
<a href="https://lp.logrocket.com/blg/react-signup-issue-free" target="_blank" vwo-el-id="19356441070">LogRocket
</a><p>是一款 React analytics 解决方案，可保护您免受数百个误报错误警报的影响，只针对少数真正重要的项目。LogRocket 告诉您 React 应用程序中实际影响用户的最具影响力的 bug 和 UX 问题。</p><a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="19356441380">
<img class="first-react-image alignnone size-full wp-image-46 jetpack-lazy-image jetpack-lazy-image--handled" src="../Images/f300c244a1a1cf916df8b4cb02bec6c6.png" vwo-el-id="18272717540" data-lazy-loaded="1" data-original-src="https://files.readme.io/27c94e7-Image_2017-06-05_at_9.46.04_PM.png"/>
</a>
<a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="19356441690">
<img class="second-react-image alignnone size-full wp-image-46 jetpack-lazy-image jetpack-lazy-image--handled" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" vwo-el-id="30720362350" data-lazy-loaded="1" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/>
</a>
<a href="https://lp.logrocket.com/blg/react-signup-issue-free" target="_blank" rel="noopener noreferrer" vwo-el-id="35866400580">LogRocket
</a><p>自动聚合客户端错误、反应错误边界、还原状态、缓慢的组件加载时间、JS 异常、前端性能指标和用户交互。然后，LogRocket 使用机器学习来通知您影响大多数用户的最具影响力的问题，并提供您修复它所需的上下文。</p><p vwo-el-id="28675661060">关注重要的 React bug—<a class="signup" href="https://lp.logrocket.com/blg/react-signup-issue-free" target="_blank" rel="noopener noreferrer" vwo-el-id="40093418840">今天就试试 LogRocket】。</a></p>
</div></div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
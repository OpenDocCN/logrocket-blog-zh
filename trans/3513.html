<html>
<head>
<title>Kotlin dependency injection: Koin vs. Hilt </title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>Kotlin依赖注入:Koin vs. Hilt</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/kotlin-dependency-injection-koin-vs-hilt/#0001-01-01">https://blog.logrocket.com/kotlin-dependency-injection-koin-vs-hilt/#0001-01-01</a></blockquote><div><article class="article-post">
<p>依赖注入是一种广泛使用的技术，它允许程序员为任何类提供它的依赖，而不是让类自己获得它们。这种技术也被认为非常适合Android开发生态系统。正如Android的官方文档所建议的，依赖注入允许程序员为良好的应用程序架构打下基础，因为它具有多种优势，如代码的可重用性、易于重构以及易于测试。</p>
<p>由于它的许多优点，以及这种模式的解耦本质，依赖注入几乎是每个现代Android项目的必须。有这么多选择库和工具来实现依赖注入，或者DI，很难决定使用什么框架。</p>
<p>在本文中，我们将探索两个最受欢迎的现代Android开发的DI库:<a href="https://dagger.dev/hilt/">匕首之柄</a>和新人<a href="https://insert-koin.io/">柯恩</a>。</p>
<p>向前跳:</p>

<h2 id="hilt">柄</h2>
<p>刀柄框架是匕首DI库上面的一层。更具体地说，Hilt构建在Dagger 2库之上，该库目前由Google维护。</p>
<p>除了将Dagger实现简化到Android应用程序中，Hilt的一些其他目标是标准化组件和范围集，以使Dagger的设置更容易，并提供一种简单的方法来为不同的构建类型提供绑定，正如其<a href="https://dagger.dev/hilt/">文档</a>所解释的那样。</p>
<p>换句话说，使用Hilt本质上意味着使用Dagger 2，它们可以同时存在于同一个项目中。让我们看看匕首之前，我们潜入剑柄。</p>
<h2 id="dagger">匕首简史</h2>
<p>2012年，<a href="https://github.com/square/dagger"> Square发布了用于快速依赖注入的Dagger库</a>。四年后，谷歌接手了这个项目，并推出了新的和改进的Dagger 2，这个版本的库是基于Hilt构建的。</p>
<p>这个开源库是用Java编写的，在编译时生成普通的Java源代码来实现它的注入分析。</p>
<h2 id="how-does-dagger-work">匕首是如何工作的？</h2>
<p>Dagger/Hilt使用一系列注释来指示为其依赖注入生成哪种代码。Dagger和Hilt的主要区别在于，Hilt框架会自动生成很多Android项目通常需要的Dagger设置代码，这让开发人员避免了遇到太多样板代码。</p>
<p>下面是如何使用<code>Application</code>对象初始化Android应用程序中的Hilt库:</p>
<pre class="language-kotlin hljs">@HiltAndroidApp
class App : Application() {
    // Don't forget to declare your Application object in the Manifest!
    ...
}
</pre>
<p>一旦你的Hilt应用程序被初始化，我们需要告诉Hilt哪些类可以作为依赖注入。</p>
<p>为此，我们需要将<code>@Inject</code>注释添加到类的构造函数中，以便Dagger声明它们进行注入:</p>
<pre class="language-kotlin hljs">class InjectedClass @Inject constructor(
    private val param: InjectedParam
) { ... }

class InjectedParam @Inject constructor() { ... }
</pre>
<p>注意，为注入而注释的类中的所有参数也需要被注释。</p>
<p>在注释了打算注入的类之后，您需要首先开始注释具有生命周期意识的入口点<em>、</em>或依赖容器，它们允许将依赖注入其中。</p>
<p>只有到那时，我们才能再次使用<code>@Inject</code>注释，根据需要带来依赖关系:</p>
<pre class="language-kotlin hljs">@AndroidEntryPoint
class MainActivity: FragmentActivity() {
    @Inject lateinit var injectedClass: InjectedClass

    override fun onCreate() {
        ...
    }
}
</pre>
<p>Hilt可以做很多安卓职业的入口，包括<code>Application</code>、<code>BroadcastReceiver</code>、<code>View</code>、<code>Service</code>、<code>Activity</code>，但前提是要扩展<code>FragmentActivity</code>。<code>Fragment</code>也可以作为一个入口，但是根据<a href="https://developer.android.com/codelabs/android-hilt#4"> Android codelab </a>的说法，它要扩展Jetpack的<code>Fragment</code>类而不是旧的Android的。</p>
<h3 id="dagger-compile-time-dependency">Dagger编译时依赖</h3>
<p>Dagger Hilt框架是一个编译时依赖项。这意味着它生成的所有代码以及所有错误检查都发生在编译时，这会导致编译失败。这使得确定当前的DI策略是否有缺陷变得非常容易。</p>
<h3 id="hilt-modern-android-development">现代Android开发中的手柄(MAD)</h3>
<p>Hilt最大的优势在于Google将其整合到了他们的开发生态系统中。</p>
<p>Hilt是Android推荐的实现依赖注入的方式，现在它和<a href="https://developer.android.com/jetpack?gclid=Cj0KCQjwnP-ZBhDiARIsAH3FSReWVeFGrEROLmhF6PBEXjLdXrl9rXPUBusN2fSdAa99GasQX_mkTygaAsYfEALw_wcB&amp;gclsrc=aw.ds"> Android Jetpack </a>一起打包。</p>
<p>根据<a href="https://developer.android.com/training/dependency-injection#hilt"> Android的官方文档</a>，通过为项目中的每个Android类提供容器并自动管理它们的生命周期，Hilt定义了一种在应用中实现DI的标准方式。</p>
<h2 id="what-is-koin">什么是Koin？</h2>
<p>Koin是Kotzilla的一个开源库，几乎是匕首/刀柄的对立面。Koin创建于2017年，完全用Kotlin编写，它提供了一种不同的实现依赖注入的方法。</p>
<p>Koin实现依赖注入的方式与传统的依赖注入如此不同，以至于有人声称它根本不是依赖注入。</p>
<p>Koin使用一种叫做服务定位器的模式，根据Google 的说法，<em>，</em> <a href="https://developer.android.com/topic/architecture#dependencies">通过提供一个注册中心来工作，在那里类可以获得它们的依赖，而不是直接构造它们。同时，传统的依赖注入有另一个类为你提供依赖。</a></p>
<p>关于这场辩论的更多信息，请看Elye对这个话题的深入探讨。在本文中，当谈到Koin库及其用法时，我们将坚持依赖注入。</p>
<h2 id="how-does-koin-work">Koin是怎么工作的？</h2>
<p>Koin没有通过注释来引导自己，而是使用模块来声明所有的类或工厂，这些类或工厂将作为依赖项注入到其他类中。</p>
<p>下面是如何使用<code>Application</code>对象初始化Android应用程序的Koin库:</p>
<pre class="language-kotlin hljs">class App : Application() {
    // Don't forget to declare your Application object in the Manifest!
  override fun onCreate() {
    super.onCreate()
    // Start Koin
    startKoin {
      // Feed in Context
      androidContext(this)
            ...
    }
  } 
    ...
}
</pre>
<p>一旦Koin被初始化，添加和注入依赖项就很简单了。</p>
<p>所有的依赖项都需要存在于一个<code>module</code>对象中，然后直接提供给Koin实例。我们可以通过以下方式做到这一点:</p>
<pre class="language-kotlin hljs">class InjectedParam()
class InjectedClass(val subclass: InjectedParam)

val appModule = module {
    single { InjectedParam() }
    single { InjectedClass(get()) }
}

class App : Application() {
  override fun onCreate() {
    super.onCreate()
    // Start Koin
    startKoin {
      // Feed in Context
      androidContext(this)
            // Load dependencies module
            modules(appModule)
    }
  } 
    ...
}
</pre>
<p>一旦你的依赖项在一个模块中，你可以通过使用<code>inject</code>委托函数直接注入到你的源代码中:</p>
<pre class="language-kotlin hljs">class MainActivity : Activity() {
    val injectedClass: InjectedClass by inject()

    override fun onCreate() {
        ...
    }
}
</pre>
<h3 id="koin-runtime-dependency">Koin运行时依赖</h3>
<p>不同于匕首/刀柄，Koin是一个运行时依赖。这意味着它不仅不会在编译时生成任何代码，而且在您构建项目时也不会抱怨缺少依赖项。</p>
<p>相反，如果您的应用程序缺少依赖项，将会抛出一个异常，很可能会导致崩溃。</p>
<h3 id="koin-modern-android-development">现代Android开发中的koin(MAD)</h3>
<p>Koin最大的优势就是完全用Kotlin写的。随着MAD转向一个更加Kotlinized的生态系统，在Kotlin优先项目中使用Kotlin库有很多好处。</p>
<p>此外，因为它不是作为另一个库的一层而存在，所以Koin是非常轻量级的，不会给你的项目增加额外的编译时间。</p><div class="code-block code-block-54">
<hr/>
<h3>更多来自LogRocket的精彩文章:</h3>

<hr/></div>
<h2 id="comparing-dagger-koin-features">比较匕首和锦鲤的特点</h2>
<p>现在我们已经研究了这两个库的背景和规范，让我们再来看看它们实现的一些细节，并比较它们以更好地理解它们的区别。</p>
<h3 id="ease-of-use">易用性</h3>
<p>我觉得在比较匕首/剑柄和锦鲤的时候，第一个也是最重要的一个问题就是:哪个更好用？我们已经讨论了如何初始化和使用这两个库的最简单的例子，所以这实际上取决于个人偏好。</p>
<p>如果您是那种喜欢在整个项目中使用注释来更好地捕捉意图的开发人员，那么Hilt可能是更好的选择，这样您就可以使用这方面的开发。</p>
<p>然而，更广泛的观点是Koin比Hilt更容易管理。Koin不仅使代码非常集中，而不是必须标记每个单独的对象，而且它还使用Kotlin最新和最棒的工具来方便访问和注入您的依赖项。如果你只是喜欢你的注释，那么<a href="https://insert-koin.io/docs/quickstart/android-annotations"> Koin有一个注释策略</a>,它可以作为一种选择或者与它们的常规用法结合使用。</p>
<h3 id="handling-errors">处理错误</h3>
<p>知道你的依赖注入策略何时不完整，或者是否失败，是非常重要的。因为匕首/刀柄和Koin库的处理方式不同，这个任务在两个选项之间也有很大的不同。</p>
<p>虽然Hilt编译时依赖允许我们通过编译错误更快地发现错误，但Koin将正确构建，并且仅在错误的依赖被触发时才表达其运行时异常。</p>
<p>这两个库各有优缺点，因为Hilt的编译时分析也会导致给定应用程序的构建时间变慢。</p>
<h3 id="performance-impact">对性能的影响</h3>
<p>每个库的依赖类型对性能有不同的影响。</p>
<p>Hilt的编译时分析和类生成极大地影响了应用程序的编译时间，但是所有的事情都会在构建生命周期中更早地得到排序，保持运行时性能不变。</p>
<p>另一方面，Koin的运行时依赖项和代码分析会对应用程序的运行时性能产生轻微影响，因为所有的依赖项都必须在应用程序运行时进行排序，而不是事先进行排序。</p>
<h2 id="dagger-vs-koin">匕首大战柯因</h2>
<p>此时，你一定在问自己:那么，哪个更好呢？最终，这取决于你的项目的细节，规模，年龄，团队的整体经验。我不能为你开出解决方案——这是每个开发团队必须自己做出的决定！</p>
<p>如果您正在阅读本文，试图为您的项目选择这些库，我建议考虑以下几点:</p>
<ol>
<li>如果你有一个相当年轻或新的项目，考虑选择与你的项目共享相同主语言的库；也就是说，Java项目可以使用Dagger，而Kotlin项目更喜欢Koin</li>
<li>如果你认为自己是一个开发新手，不想被DI困扰，Koin是一个不错的选择，因为它被认为更容易学习和使用</li>
<li>如果你是一个喜欢阅读文档的开发者，Hilt可能是一个更好的解决方案，因为Android开发者网站有完整的文档、用例，甚至还有一个官方代码实验室供你参考</li>
<li>虽然我没有在这篇文章中讨论匕首2的高级用法，但是一个可能需要更高级的DI用法的项目可能应该选择剑柄，以便在需要时可以使用匕首的全部</li>
<li>如果您的项目使用或打算使用Kotlin多平台工具来开发重用您的Kotlin代码的iOS应用程序，Koin可能是一个更好的解决方案，因为它目前支持DI模式，作为kot Lin iOS多平台的一部分</li>
</ol>
<p>如果这些指标还不够有说服力，这里有一个比较它们属性的图表，你可以照着做:</p>
<table>
<thead>
<tr>
<th>柄</th>
<th>柯因</th>
<th>程序设计语言</th>
</tr>
</thead>
<tbody>
<tr>
<td>Java(Java)</td>
<td>科特林？科特林</td>
<td>要求科特林</td>
</tr>
<tr>
<td>❌</td>
<td>✅</td>
<td>Kotlin多平台支持</td>
</tr>
<tr>
<td>❌</td>
<td>✅</td>
<td>开放源码</td>
</tr>
<tr>
<td>需要同意</td>
<td>✅</td>
<td>近似的包装尺寸(。zip)</td>
</tr>
<tr>
<td>20 MB</td>
<td>1兆字节</td>
<td>依赖类型</td>
</tr>
<tr>
<td>建造时间</td>
<td>运行时间</td>
<td>依赖注入类型</td>
</tr>
<tr>
<td>传统DI</td>
<td>服务定位器</td>
<td>生成代码</td>
</tr>
<tr>
<td>✅</td>
<td>❌</td>
<td>构建时性能影响</td>
</tr>
<tr>
<td>❌</td>
<td>✅</td>
<td>运行时性能影响</td>
</tr>
<tr>
<td>✅</td>
<td>❌</td>
<td>错误处理</td>
</tr>
<tr>
<td>编译错误</td>
<td>运行时异常</td>
<td>本机组件兼容性</td>
</tr>
<tr>
<td>视图模型、工作管理器、导航、撰写</td>
<td>视图模型、工作管理器、合成</td>
<td>结论</td>
</tr>
</tbody>
</table>
<h2 id="conclusion">选择依赖注入库不应该是一个负担。请记住，选择阿迪图书馆不是一个架构决策，而是实现细节的一部分<em>。</em>这意味着，无论您为项目选择什么，都要确保它以一种易于替换的方式集成，以防最初的决策过时，或者替代选项随着时间的推移变得更加方便！</h2>
<p>LogRocket :即时重现你的安卓应用中的问题。</p><div class="code-block code-block-32">
<div class="blog-plug inline-plug kotlin-plug"><h2><a href="https://lp.logrocket.com/blg/kotlin-signup" target="_blank" rel="noopener noreferrer"> LogRocket </a>是一款Android监控解决方案，可以帮助您即时重现问题，确定bug的优先级，并了解您的Android应用程序的性能。</h2><a class="signup" href="https://lp.logrocket.com/blg/kotlin-signup" target="_blank" rel="noopener noreferrer"><img class="alignnone size-full wp-image-46 jetpack-lazy-image" src="../Images/b5ae4bd0ecde7aa9d5288746416d5e18.png" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2022/11/react-native-plug_android-1.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/11/react-native-plug_android-1.png"/><noscript><img data-lazy-fallback="1" class="alignnone size-full wp-image-46" src="../Images/b5ae4bd0ecde7aa9d5288746416d5e18.png" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/11/react-native-plug_android-1.png"/></noscript></a><p>LogRocket还可以向你展示用户是如何与你的应用程序互动的，从而帮助你提高转化率和产品使用率。LogRocket的产品分析功能揭示了用户不完成特定流程或不采用新功能的原因。</p><p>开始主动监控您的Android应用程序— <a class="signup" href="hhttps://lp.logrocket.com/blg/kotlin-signup" target="_blank" rel="noopener noreferrer">免费试用LogRocket】。</a></p><p>Start proactively monitoring your Android apps — <a class="signup" href="hhttps://lp.logrocket.com/blg/kotlin-signup" target="_blank" rel="noopener noreferrer">try LogRocket for free</a>.</p></div>
</div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
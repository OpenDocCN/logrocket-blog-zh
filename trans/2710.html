<html>
<head>
<title>Validating arrays and nested values in Laravel - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>验证 Laravel - LogRocket 博客中的数组和嵌套值</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/validating-arrays-nested-values-laravel/#0001-01-01">https://blog.logrocket.com/validating-arrays-nested-values-laravel/#0001-01-01</a></blockquote><div><article class="article-post">
 <p>随着前端架构的复杂性增加，开发人员能够向后端提交更复杂的数据变得比以往任何时候都更加重要。</p>
<p>因为我们正在构建更复杂的表单，所以我们需要更有效的方法来验证和处理来自这些表单的数据。幸运的是，Laravel 提供了许多方法，可以轻松地验证来自前端的数据。</p>

<h2 id="Basics-of-validation-in-Laravel">Laravel 中的验证基础</h2>
<p>在我们讨论验证数组和嵌套数组之前，让我们先概述一下 Laravel 验证的基础知识。</p>
<p>通常，进入 Laravel 的 HTTP 请求主要是在控制器中处理的(也有其他地方处理请求，比如中间件，但那是另一篇文章中的讨论)。因此，许多开发人员也选择在这里存放他们的验证方法。</p>
<p>假设我们正在构建一个非常简单的库存软件。在这个软件中，我们将把商品存储在数据库的“产品”表中。我们访问和管理表的模型是<code>Product</code>，控制器将被命名为<code>ProductController</code></p>
<p>在我们的表单中，有项目名称、SKU 和价格字段。当发出 POST 请求时，我们需要验证这些项目。</p>
<pre class="language-php hljs">public function store(Request $request)
{
    $validated = $request-&gt;validate([
        'item_name' =&gt; 'required|string|max:255',
        'sku' =&gt; 'required|string|regex:​​/^[a-zA-Z0-9]+$/',
        'price' =&gt; 'required|numeric'
    ]);

    Product::create($validated);
}
</pre>
<p>上面的代码是我们在控制器中验证请求的最简单的方法。请注意，在每个键(属性)旁边都有一个字符串，管道将我们想要验证属性的所有规则分隔开来。</p>
<p>令人惊奇的是，通过一些规则，你可以提供更多的上下文来说明你想要什么。例如，在上面的代码块中，您会看到<code>max:255</code>，这意味着<code>item_name</code>不能超过 255 个字符；<code>regex:​​/^[a-zA-Z0-9]+$/</code>表示我们只需要字母数字字符。这些仅仅是 Laravel 内置的众多规则中的一小部分。</p>
<p>当上面的项目通过验证后，会产生一个带有相关错误消息的 HTTP 重定向。但是，如果发出一个 XHR 请求(类似于来自 API 的请求)，就不会进行重定向，而是用 JSON 和 422 HTTP 状态代码进行响应。</p>
<p>一些 Laravel 开发人员选择使用更复杂的验证方法对此进行扩展。一种方法是使用<code>Validator</code>对象。</p>
<pre class="language-php hljs"> public function store(Request $request)
{
    $validator = Validator::make($request-&gt;all(), [
        'item_name' =&gt; 'required|string|max:255',
        'sku' =&gt; 'required|string|regex:​​/^[a-zA-Z0-9]+$/',
        'price' =&gt; 'required|numeric'
    ]);

    If ($validator-&gt;fails()){
        // Do something
    }
    Product::create($validated);
}
</pre>
<p>Laravel devs 扩展验证的另一种方式是通过使用表单请求将验证从控制器中分离出来。这是我个人最喜欢的扩展验证的方式，因为当我制定自定义规则、<a href="https://laravel.com/docs/8.x/validation#adding-after-hooks-to-form-requests" target="_blank" rel="noopener">使用 After Validation Hooks </a>或扩展规则等时，我能够整齐地组织一切。</p>
<pre class="language-php hljs"> &lt;?php

namespace App\Http\Requests;

use Illuminate\Foundation\Http\FormRequest;

class ProductRequest extends FormRequest
{
    public function authorize()
    {
        return true;
    }

    public function rules()
    {
        return [
            'item_name' =&gt; 'required|string|max:255',
            'sku' =&gt; 'required|string|regex:​​/^[a-zA-Z0-9]+$/',
            'price' =&gt; 'required|numeric'
        ];
    }
}
</pre>
<h2 id="Validating-simple-nested-attributes">验证简单嵌套属性</h2>
<p>比方说，我想让我的库存软件变得复杂一点，有一个包含两个嵌套字段的<code>item</code>字段:<code>name</code>和<code>description</code>。</p>
<p>在前端，它看起来像这样:</p>
<pre class="language-php hljs">&lt;form method="POST"&gt;
    &lt;input type="text" name="item['name']" /&gt;
    &lt;input type="text" name="item['description']" /&gt;
    &lt;input type="text" name="sku" /&gt;
    &lt;input type="text" name="price" /&gt;
    &lt;button type="submit"&gt;Submit&lt;/button&gt;
&lt;/form&gt;
</pre>
<p>假设我们现在使用表单请求来验证传入的数据，因为我们希望更好地组织数据。规则方法将如下所示:</p>
<pre class="language-html hljs">public function rules()
{
    return [
        'item.name' =&gt; 'required|string|max:255',
        'item.description' =&gt; 'nullable|string|min:60',
        'sku' =&gt; 'required|string|regex:​​/^[a-zA-Z0-9]+$/',
        'price' =&gt; 'required|numeric'
    ];
}
</pre>
<p>然后，我们可以在控制器中使用经过验证的数据，如下所示:</p>
<pre class="language-php hljs">public function store(ProductRequest $request)
{
    // Do something or just save straight to the db like below
   Product::create($request-&gt;validated());
}
</pre>
<p>如您所见，我们使用点符号来表示嵌套属性。当我们想要定制错误消息时，点符号也很重要。例如，如果我们想定制当有人在价格字段中输入字母字符时的错误消息，我们可以这样做:</p>
<pre class="language-php hljs">public function messages()
{
    return [
        'price.required' =&gt; 'You must have a price.',
        'price.numeric' =&gt; 'You have invalid characters in the price field'
    ];
}
</pre>
<p>请注意，当我们制作自定义消息时，我们使用“字段[点]规则”这一语法。</p>
<h2 id="Validating-arrays-and-nested-attributes">验证数组和嵌套属性</h2>
<p>假设我们通过使用包含可重复部分的表单使数据收集变得更加复杂。例如，我们希望存储不同种类的商品，比如颜色不同、价格不同的商品。</p>
<pre class="language-html hljs">&lt;form method="POST"&gt;
    &lt;label&gt;Item 1&lt;/label&gt;
    &lt;input type="text" name="item[0][name]" /&gt;
    &lt;input type="text" name="item[0][description]" /&gt;
    &lt;input type="text" name="sku[0]" /&gt;
    &lt;input type="text" name="price[0]" /&gt;
    &lt;button type="submit"&gt;Submit&lt;/button&gt;

    &lt;label&gt;Item 2&lt;/label&gt;
    &lt;input type="text" name="item[1][name]" /&gt;
    &lt;input type="text" name="item[1][description]" /&gt;
    &lt;input type="text" name="sku[1]" /&gt;
    &lt;input type="text" name="price[1]" /&gt;
    &lt;button type="submit"&gt;Submit&lt;/button&gt;

    &lt;label&gt;Item 3&lt;/label&gt;
    &lt;input type="text" name="item[2][name]" /&gt;
    &lt;input type="text" name="item[2][description]" /&gt;
    &lt;input type="text" name="sku[2]" /&gt;
    &lt;input type="text" name="price[2]" /&gt;
    &lt;button type="submit"&gt;Submit&lt;/button&gt;
&lt;/form&gt;
</pre>
<p>我们有三个迭代的项目需要验证。HTML 没有限制表单中可以提交的数组元素的数量，所以如果我们必须单独验证每个元素，这将是一个令人头疼的问题。</p>
<p>幸运的是，Laravel 提供了一种简单的方法，通过使用点符号和<code>*</code>字符来验证数组和嵌套数组输入。</p>
<pre class="language-php hljs">public function rules()
{
    return [
        'item.*.name' =&gt; 'required|string|max:255',
        'item.*.description' =&gt; 'sometimes|nullable|string|min:60',
        'sku' =&gt; 'required|array',
        'sku.*' =&gt; 'sometimes|required|string|regex:​​/^[a-zA-Z0-9]+$/',
        'sku' =&gt; 'required|array',
        'price.*' =&gt; 'sometimes|required|numeric'
    ];
}
</pre>
<p><code>*</code>字符替换数组中元素的迭代次数。当我们进行更复杂的嵌套时，这也非常有用。</p>
<p>假设我们有一个<code>months_available</code>字段，每个字段都是您可以选择的月份列表。无需为我们的深层嵌套属性命名，我们可以验证每个月数组和嵌套数组中的每个月，如下所示:</p>
<pre class="language-php hljs">public function rules()
{
    return [
        'item.*.name' =&gt; 'required|string|max:255',
        'item.*.description' =&gt; 'sometimes|nullable|string|min:60',
        'sku' =&gt; 'required|array',
        'sku.*' =&gt; 'sometimes|required|string|regex:​​/^[a-zA-Z0-9]+$/',
        'sku' =&gt; 'required|array',
        'price.*' =&gt; 'sometimes|required|numeric',
        'months_available' =&gt; 'required|array',
        'months_available.*' =&gt; 'sometimes|required|array',
        'months_available.*.*' =&gt; 'sometimes|required|string',
    ];
}
</pre>
<p>如果我们要为每个属性编写自定义消息，我们将得到如下内容:</p>
<pre class="language-php hljs">public function messages()
{
    return [
        'item.*.name.required' =&gt; 'You must have an item name.',
        'item.*.name.max' =&gt; 'The item name must not surpass 255 characters.',
        'item.*.description.min' =&gt; 'The description must have a minimum of 60 characters.',
        'sku.*.regex' =&gt; 'The SKU must only have alphanumeric characters.',
        'price.*.numeric' =&gt; 'You have invalid characters in the price field.'
    ];
}
</pre>
<h2 id="Important-rules-for-array-validation">数组验证的重要规则</h2>
<p>既然您正在使用数组，那么有些规则尤其重要。我们将讨论其中的一些，并为每一个提供示例，以帮助您更好地理解它们。</p>
<h3><code>array</code></h3>
<p>这确保了输入的值是一个数组。可以提供一个列表作为这个规则的上下文，告诉 Laravel 确保键出现在输入中。</p>
<pre class="language-php hljs">public function rules()
    {
        return [
            'item' =&gt; 'array:name', // name must be present in input
        ];
    }</pre>
<h3><code>distinct</code></h3>
<p>这确保了数组中没有重复的元素。当您需要唯一的值(如 id)时，这很有用。</p><div class="code-block code-block-54">
<hr/>
<h3>更多来自 LogRocket 的精彩文章:</h3>

<hr/></div>
<pre class="language-php hljs">public function rules()
    {
        return [
            'item.*.id' =&gt; 'distinct', 
        ];
    }</pre>
<h3><code>exclude_if, exclude_unless, exclude_without</code></h3>
<p>每个规则将当前字段与另一个字段进行比较，并根据条件将其从返回的数据中排除。<code>exclude_if</code>如果另一个字段等于某个值，则排除当前字段，<code>exclude_unless</code>除非另一个字段等于某个值，否则排除当前字段，<code>exclude_without </code>如果另一个字段不存在，则排除当前字段。</p>
<pre class="language-php hljs">public function rules()
    {
        return [
            'tag' =&gt; 'exclude_if:product_type,"digital"|required|array', // 
            'item_code' =&gt; 'exclude_unless:sku,null|required|array',
            'discount' =&gt; 'exclude_without:price|sometimes|array'
        ];
    }
</pre>
<h3 class="language-php hljs"><code>required</code></h3>
<p>该规则确保当前字段存在并有数据，因此不能为空。</p>
<h3><code>sometimes</code></h3>
<p>这将验证当前字段是否存在。当您验证数组中的嵌套值时，您会经常用到这一点，因为有时迭代的某个属性会丢失；即使存在其他属性。</p>
<p>这不是<code>required</code>的反义词，因为你可以一起使用它们。例如，因为数据可能有<code>item.5.name</code>，验证器可能期望有一个<code>item.5.description</code>。有了<code>sometimes</code>，它知道当它不存在时，它不必担心，也不会抛出令人讨厌的异常。</p>
<pre class="language-php hljs">public function rules()
{
    return [
         ‘item.*.name’ =&gt; ‘required|string|max:255’,
                 ‘item.*.description’ =&gt; ‘sometimes|nullable|string|min:60’,
    ];
}


</pre>
<h2>结论</h2>
<p>尽管我们已经介绍了很多，但是在 Laravel 中验证嵌套数据还有更多的事情要做。它不仅提供了验证数据的方法，还为您提供了定制数据验证规则的方法。</p>
<p>库存系统并不是唯一将复杂的嵌套数据提供给后端进行验证的例子，因为一些具有多页表单的网站属于这一类别，还有允许用户使用可重复的模块和块来构建网页和其他数字项目的软件。</p>
<p>关于 Laravel 验证可以做的更多令人惊奇的事情，请参见 Laravel 文档。</p><div class="code-block code-block-2">
<div class="blog-plug base-cta"><h2>使用<a class="signup" href="https://lp.logrocket.com/blg/signup" target="_blank" rel="noopener noreferrer"> LogRocket </a>消除传统错误报告的干扰</h2>
<a href="https://lp.logrocket.com/blg/signup" class="signup" target="_blank" rel="noopener noreferrer"><img class="alignnone size-full wp-image-46 jetpack-lazy-image" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/><noscript><img data-lazy-fallback="1" class="alignnone size-full wp-image-46" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/></noscript></a>
<p><a href="https://lp.logrocket.com/blg/signup" target="_blank" rel="noopener noreferrer"> LogRocket </a>是一个数字体验分析解决方案，它可以保护您免受数百个假阳性错误警报的影响，只针对几个真正重要的项目。LogRocket 会告诉您应用程序中实际影响用户的最具影响力的 bug 和 UX 问题。</p>
<p>然后，使用具有深层技术遥测的会话重放来确切地查看用户看到了什么以及是什么导致了问题，就像你在他们身后看一样。</p>
<p>LogRocket 自动聚合客户端错误、JS 异常、前端性能指标和用户交互。然后 LogRocket 使用机器学习来告诉你哪些问题正在影响大多数用户，并提供你需要修复它的上下文。</p>
<p>关注重要的 bug—<a class="signup" href="https://lp.logrocket.com/blg/signup-issue-free" target="_blank" rel="noopener noreferrer">今天就试试 LogRocket】。</a></p></div></div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
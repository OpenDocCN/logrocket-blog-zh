<html>
<head>
<title>Roda, the routing tree web toolkit: A tutorial - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>洛达，路由树网络工具包:教程-日志火箭博客</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/roda-the-routing-tree-web-toolkit-a-tutorial/#0001-01-01">https://blog.logrocket.com/roda-the-routing-tree-web-toolkit-a-tutorial/#0001-01-01</a></blockquote><div><article class="article-post">
<p>洛达是一个 Ruby web 框架，旨在将 Sinatra 和 Cuba 的精华引入 Ruby web 开发。洛达是围绕“路由树”的概念设计的</p>
<p>在 web 开发中，路由是接受请求，然后找到处理该请求的代码的过程。考虑如下所示的 HTTP 请求路径。</p>
<pre><code>GET users/1/invoices
</code></pre>
<p>当决定如何处理路由时，典型的 web 框架(例如 Ruby on Rails 或 Sinatra)会查看完整的请求路径，迭代一系列可能的路由来匹配请求。</p>
<p>另一方面，诸如洛达之类的路由树框架在继续之前检查请求路径的每一段。</p>
<p>在处理上述请求时，洛达查看了第一个片段<code>/users</code>。如果该段与请求不匹配，它会跳过整个<code>/users</code>分支，从而不考虑<code>/users</code>下的其他路由。如果<code>/users</code>匹配，它将在<code>/users</code>分支中查找<code>/1</code>。它继续这种方式，直到找到路线，或者如果路线不能匹配，返回一个<code>404</code>(未找到)状态。</p>
<h2 id="whyroda">为什么是洛达？</h2>
<h3 id="performance">表演</h3>
<p>由于路由处理不涉及路由数组的迭代，与其他 Ruby 框架相比，每个请求的开销要低得多。<br/> <figure id="attachment_38521" aria-describedby="caption-attachment-38521" class="wp-caption alignnone"> <img data-attachment-id="38521" data-permalink="https://blog.logrocket.com/roda-the-routing-tree-web-toolkit-a-tutorial/roda-requests-memory-comparison-2/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2021/03/Roda-requests-memory-comparison-1.png" data-orig-size="880,562" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Roda-requests-memory-comparison" data-image-description="" data-image-caption="&lt;p&gt;Source: Roda website&lt;/p&gt;&#10;" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2021/03/Roda-requests-memory-comparison-1-300x192.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2021/03/Roda-requests-memory-comparison-1.png" decoding="async" src="../Images/f662cd97b4997b05ae4b2e01152e6398.png" alt="A graph comparing Roda's ability to serve more requests while using less memory as compared to other Ruby frameworks" class="size-full wp-image-38521 jetpack-lazy-image" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2021/03/Roda-requests-memory-comparison-1.png 880w, https://blog.logrocket.com/wp-content/uploads/2021/03/Roda-requests-memory-comparison-1-300x192.png 300w, https://blog.logrocket.com/wp-content/uploads/2021/03/Roda-requests-memory-comparison-1-768x490.png 768w" data-lazy-sizes="(max-width: 880px) 100vw, 880px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2021/03/Roda-requests-memory-comparison-1.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2021/03/Roda-requests-memory-comparison-1.png"/> <noscript> <img data-lazy-fallback="1" data-attachment-id="38521" data-permalink="https://blog.logrocket.com/roda-the-routing-tree-web-toolkit-a-tutorial/roda-requests-memory-comparison-2/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2021/03/Roda-requests-memory-comparison-1.png" data-orig-size="880,562" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Roda-requests-memory-comparison" data-image-description="" data-image-caption="&lt;p&gt;Source: Roda website&lt;/p&gt;&#10;" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2021/03/Roda-requests-memory-comparison-1-300x192.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2021/03/Roda-requests-memory-comparison-1.png" decoding="async" loading="lazy" src="../Images/f662cd97b4997b05ae4b2e01152e6398.png" alt="A graph comparing Roda's ability to serve more requests while using less memory as compared to other Ruby frameworks" class="size-full wp-image-38521" srcset="https://blog.logrocket.com/wp-content/uploads/2021/03/Roda-requests-memory-comparison-1.png 880w, https://blog.logrocket.com/wp-content/uploads/2021/03/Roda-requests-memory-comparison-1-300x192.png 300w, https://blog.logrocket.com/wp-content/uploads/2021/03/Roda-requests-memory-comparison-1-768x490.png 768w" sizes="(max-width: 880px) 100vw, 880px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2021/03/Roda-requests-memory-comparison-1.png"/> </noscript> <figcaption id="caption-attachment-38521" class="wp-caption-text">来源:洛达网站</figcaption> </figure></p>
<h3 id="usability">可用性</h3>
<p>路由树的有趣之处不仅在于性能，还在于在路由过程中的任何时候，您都可以对当前请求进行操作。</p>
<h3 id="simplicity">简单</h3>
<p>洛达设计简单，内部和外部都是如此。它使用一个路由树来让你写更简单和干巴巴的代码。</p>
<h3 id="reliability">可靠性</h3>
<p>洛达几乎没有全球命名空间污染。路由树内部使用的所有实例变量都以下划线(<code>@_variable</code>)为前缀，因此它们不会与用户想要使用的实例变量冲突。此外，洛达为常数加上前缀<code>Roda::</code> ( <code>Roda::constant</code>)，以避免与应用程序中使用的常数冲突。</p>
<h3 id="extensibility">展开性</h3>
<p>洛达通过广泛的插件支持是可扩展的。您可以覆盖洛达的任何部分，并调用<code>super</code>来获得默认行为。</p>
<h2 id="asimpleroutingtree">简单的路由树</h2>
<p>让我们从创建一个非常小的 web 应用程序开始，来理解使用洛达是什么样子的。洛达更像是一个 Ruby 库，而不是一个框架，并且没有用于执行常规任务的 CLI 实用命令。因此，与 Rails 和其他框架不同，它没有用于创建新项目、生成模型、控制器和其他命令重复任务的命令。</p>
<p>让我们创建一个目录来保存我们的项目文件。</p>
<pre><code>mkdir my_roda_app
</code></pre>
<p>然后我们添加一个<code>Gemfile</code>来管理我们将要使用的宝石。将<code>roda</code> gem 添加到文件中，然后添加<code>puma</code>，这将是我们的 web 应用服务器。我们的<code>Gemfile</code>会是这个样子。</p>
<pre><code>source "https://rubygems.org"

gem "roda"
gem "puma"
</code></pre>
<p>现在我们运行<code>bundle install</code>来安装我们添加的 gems。</p>
<pre><code>bundle install
</code></pre>
<p>大多数 Ruby web 框架都是建立在 Rack 之上的，根据 Rack 的<a href="https://github.com/rack/rack">文档</a>，它是一个模块化的 Ruby web 服务器接口。</p>
<blockquote><p>Rack 为用 Ruby 开发 web 应用程序提供了一个最小的、模块化的、适应性强的接口。通过以尽可能简单的方式包装 HTTP 请求和响应，它将 web 服务器、web 框架和它们之间的软件(所谓的中间件)的 API 统一和提取到一个方法调用中。</p>
<p>机架文档</p></blockquote>
<p>洛达是机架兼容的，所以我们首先使用标准文件名<code>config.ru</code>创建一个机架备份文件。在其中我们需要<code>roda</code>，然后创建一个新的类来表示我们的应用程序。这个应用程序将继承自<code>Roda</code>类。</p>
<p>因为洛达是建立在框架之上的，所以从<code>Roda</code>继承的每个类都隐含地成为框架应用。为了告诉 Rack(和 web 服务器)为 HTTP 请求执行我们的应用程序，我们必须告诉<code>run</code>这个<code>App</code>类。</p>
<pre><code>require "roda"

class App &lt; Roda
  route do |r|
   "Hello World!"
  end
end

run App
</code></pre>
<p>然后从命令行，我们运行<code>rackup</code>命令来启动 web 服务器并开始服务请求。</p>
<pre><code>rackup
</code></pre>
<p>打开浏览器，导航到<a href="http://127.0.0.1:9292" rel="nofollow"> http://127.0.0.1:9292 </a>看到“Hello world！”</p>
<p><img decoding="async" src="../Images/68930ea53942d2f467efe72b8d198e5f.png" alt="" data-lazy-src="https://paper-attachments.dropbox.com/s_F117773A177B84BF407498A4C9D3AE3DDB2314809F8CC5276F64D78AEF4D6542_1612616971385_Screenshot+2021-02-06+at+14.08.42.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" class=" jetpack-lazy-image" data-original-src="https://paper-attachments.dropbox.com/s_F117773A177B84BF407498A4C9D3AE3DDB2314809F8CC5276F64D78AEF4D6542_1612616971385_Screenshot+2021-02-06+at+14.08.42.png"/></p><noscript><img data-lazy-fallback="1" decoding="async" src="../Images/68930ea53942d2f467efe72b8d198e5f.png" alt="" data-original-src="https://paper-attachments.dropbox.com/s_F117773A177B84BF407498A4C9D3AE3DDB2314809F8CC5276F64D78AEF4D6542_1612616971385_Screenshot+2021-02-06+at+14.08.42.png"/></noscript>
<p>我们的应用程序在当前状态下返回“Hello world！”作为对每个请求路由的响应。让我们介绍一下洛达的路由方法，让应用程序返回相同的响应，但只针对特定的请求路径和方法。</p>
<h2 id="rodaroutingtreemethods">洛达路由树方法</h2>
<h3 id="ronmethod"><code>r.on</code>方法</h3>
<p>第一种路由树方法是<code>r.on</code>，在路由树中创建分支。让我们将<code>r.on</code>添加到我们的示例应用程序中。</p><div class="code-block code-block-54">
<hr/>
<h3>更多来自 LogRocket 的精彩文章:</h3>

<hr/></div>
<pre><code>require "roda"

class App &lt; Roda
  route do |r|
    r.on 'users' do
     "Hello Users!"
    end
  end
end

run App
</code></pre>
<p>我们用字符串<code>users</code>调用了<code>r.on</code>，如果请求路径以<code>users</code>开头，它将匹配当前的请求路径。</p>
<p><code>Roda.route</code>方法是路由树的开始。所有进入我们应用程序的请求都将让位于传递给<code>Roda.route</code>的块。该块产生了一个带有一些附加方法的路由请求实例。按照惯例，块自变量被命名为<code>r</code>(例如<code>|r|</code>)。传递给路由请求实例的附加方法(例如，<code>r.on</code>)用于路由请求。</p>
<p>路由方法接受称为匹配器的参数，用于匹配当前请求。在上面的例子中，我们将字符串匹配器<code>users</code>作为参数传递给<code>r.on</code>来创建<code>users</code>分支。</p>
<p>在洛达中，字符串匹配器通常匹配请求路径的第一段。因此，如果请求路径以<code>users</code>开头，它将匹配并被重定向到传入的块，后者返回“Hello Users！”洛达用作响应主体的字符串。</p>
<p>如果请求路径以<code>profile</code>开始(不匹配)，那么<code>r.on</code>返回<code>nil</code>而不向阻塞让步，执行将在调用后继续。如果不存在其他块，就像上面的例子一样，<code>Roda.route</code>将返回<code>nil</code>，洛达将返回一个带有空响应体的<code>404</code>状态代码。</p>
<h3 id="rismethod"><code>r.is</code>方法</h3>
<p><code>r.on</code>将匹配所有以<code>users</code>开始的请求路径，包括<code>users/non-existent-user</code>。通常，这不是我们想要的。相反，我们希望为任何没有被特别处理的路径返回一个<code>404</code>响应。</p>
<p>这就是<code>r.is</code>派上用场的地方。只有当所有参数都匹配并且匹配后路径中没有其他条目时，它才匹配路径。换句话说，它最终确定了路由路径。</p>
<p><code>r.is</code>将只匹配<code>users</code>而不匹配<code>users/non-existent-user</code>。洛达的路由是结合使用<code>r.on</code>和<code>r.is</code>方法完成的。<code>r.on</code>对请求路径进行前缀匹配，<code>r.is</code>对请求路径进行全匹配。因此，当<code>r.on</code>创建分支时，<code>r.is</code>创建叶节点。</p>
<p>让我们在例子中添加一个<code>r.on</code>。</p>
<pre><code>require "roda"

class App &lt; Roda
  route do |r|
    r.on 'users' do
      r.is "list" do
       "Hello Users!"
      end
    end
  end
end

run App
</code></pre>
<p>我们的应用程序将匹配任何带有路径<code>/users/list</code>的请求。<code>r.on</code>创建一个处理<code>users</code>下所有路径的分支，<code>r.is</code>创建一个仅当当前路径是<code>list</code>时才匹配的节点。<code>r.is</code>能够匹配<code>list</code>，因为当请求被路由时，请求路径被修改。</p>
<p>当对<code>users/list</code>的请求进来时，路由树使用初始请求路径<code>users</code>。当<code>r.on "users"</code>请求方法匹配时，它从请求路径的前面消耗<code>users</code>。在<code>r.on</code>块中，请求路径是空的。</p>
<p>在下一个<code>r.is</code>块中，当前路径是<code>list</code>，并且只有当它的所有匹配器在整个请求路径上都一致时才会匹配。所以在这个例子中，请求将被匹配，并且“Hello Users！”会被归还。</p>
<h3 id="rget"><code>r.get</code></h3>
<p>路由通常也会考虑请求方法。当<code>r.on</code>和<code>r.is</code>关注使用请求路径的路由时，<code>r.get</code>基于<code>GET</code>请求方法进行路由。如果在没有匹配器的情况下调用它，它会对请求方法进行简单的匹配。如果使用匹配器调用，将根据请求路径执行终端匹配。</p>
<pre><code>require "roda"

class App &lt; Roda
  route do |r|
    r.on 'users' do
      r.is "list" do
        r.get do
         "Hello Users!"
        end
      end
    end
  end
end

run App
</code></pre>
<p>一个<code>GET users/list</code>请求将返回“你好，用户！”</p>
<h3 id="rpost"><code>r.post</code></h3>
<p>当<code>r.get</code>匹配<code>GET</code>请求时，<code>r.post</code>匹配<code>POST</code>请求。</p>
<pre><code>require "roda"

class App &lt; Roda
  route do |r|
    r.on 'users' do
      r.is "list" do
        r.get do
         "Hello Users!"
        end
        r.post do
         "User added"
        end
      end
    end
  end
end

run App
</code></pre>
<p>一个<code>POST users/list</code>请求将返回“用户已添加”<code>r.get</code>和<code>r.post</code>用于处理相似请求路径上的各种请求方法。</p>
<h2 id="codeexecutionduringrouting">路由期间的代码执行</h2>
<p>洛达能够在路由过程中执行代码。这使得编写更简单、更简洁的代码变得容易，并且避免了代码重复。</p>
<p>如果您想在访问一条路线之前检查某人是否登录，您可以将检查登录的代码放在<code>Roda.route</code>块的第一行。这在处理同一请求路径的不同请求方法时很有用。例如，<code>GET</code>请求将找到一个用户并返回他们的详细信息，而<code>POST</code>请求将找到一个用户并更新他们的详细信息。</p>
<p>我们可以将查找用户的逻辑抽象为由两种请求方法共享的路由块，如下所示。</p>
<pre><code>class App &lt; Roda
  route do |r|
    require_login!
    r.on 'users' do
      r.is ":id" do |user_id|
        @user = User.find(user_id)
        r.get do
         @user
        end
        r.post do
         @user.update(params[:user])
        end
      end
    end
  end
end

run App
</code></pre>
<h2 id="conclusion">结论</h2>
<p>洛达的设计是轻量级的，只提供让你的应用程序快速运行的基本功能。所有附加功能都通过<a href="http://roda.jeremyevans.net/documentation.html#included-plugins">插件</a>加载；洛达有超过 60 个内置插件，所有插件的质量都和洛达一样，所以你很少需要外部插件。</p>
<h2 id="credits">信用</h2>
<p><a href="https://github.com/jeremyevans/roda">Github 上的杰雷米·埃文斯</a><br/><a href="https://www.youtube.com/watch?v=W8zglFFFRMM&amp;t=184s">ruby conf 2014–洛达:路由树 Web 框架由杰雷米·埃文斯</a> <br/> <a href="https://fiachetti.gitlab.io/mastering-roda/">掌握洛达</a></p><div class="code-block code-block-1">
<div class="blog-plug base-cta"><h2>使用<a class="signup" href="https://lp.logrocket.com/blg/signup" target="_blank" rel="noopener noreferrer"> LogRocket </a>消除传统错误报告的干扰</h2>
<a href="https://lp.logrocket.com/blg/signup" class="signup" target="_blank" rel="noopener noreferrer"><img class="alignnone size-full wp-image-46 jetpack-lazy-image" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/><noscript><img data-lazy-fallback="1" class="alignnone size-full wp-image-46" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/></noscript></a>
<p><a href="https://lp.logrocket.com/blg/signup" target="_blank" rel="noopener noreferrer"> LogRocket </a>是一个数字体验分析解决方案，它可以保护您免受数百个假阳性错误警报的影响，只针对几个真正重要的项目。LogRocket 会告诉您应用程序中实际影响用户的最具影响力的 bug 和 UX 问题。</p>
<p>然后，使用具有深层技术遥测的会话重放来确切地查看用户看到了什么以及是什么导致了问题，就像你在他们身后看一样。</p>
<p>LogRocket 自动聚合客户端错误、JS 异常、前端性能指标和用户交互。然后 LogRocket 使用机器学习来告诉你哪些问题正在影响大多数用户，并提供你需要修复它的上下文。</p>
<p>关注重要的 bug—<a class="signup" href="https://lp.logrocket.com/blg/signup-issue-free" target="_blank" rel="noopener noreferrer">今天就试试 LogRocket】。</a></p></div></div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
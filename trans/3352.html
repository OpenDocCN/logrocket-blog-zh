<html>
<head>
<title>useState with URLs: How to persist state with useSearchParams - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>如何用useSearchParams - LogRocket博客保持状态</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/use-state-url-persist-state-usesearchparams/#0001-01-01">https://blog.logrocket.com/use-state-url-persist-state-usesearchparams/#0001-01-01</a></blockquote><div><article class="article-post">
<p>React <code>useState</code>钩子是在<a href="https://blog.logrocket.com/tag/react/"> React </a>中的组件上下文中持久化状态的一个好方法。这篇文章演示了一个简单的React钩子，它在URL查询字符串中存储状态，构建在React Router <code>useSearchParams</code>钩子之上。</p>

<h2 id="usestate-hook"><code>useState</code>钩子</h2>
<p><a href="https://blog.logrocket.com/a-guide-to-usestate-in-react-ecb9952e406c/">挂钩</a>的用法如下:</p>
<pre class="language-typescript hljs">const [greeting, setGreeting] = useState('hello world');

// ....

setTotal('hello John'); // will set greeting to 'hello John'
</pre>
<p>但是，使用<code>useState</code>有一个缺点；这种状态不是持久的，也不是可共享的。因此，如果你想让其他人看到你在应用程序中看到的东西，你就要依赖他们执行让你的应用程序进入当前状态的相同操作。</p>
<p>这样做既费时又容易出错，所以如果有一种简单的方法来共享状态不是很好吗？</p>
<h2 id="a-stateful-url">有状态的URL</h2>
<p>在用户之间共享状态的一种有效方法是使用URL，而不需要后端持久化。URL可以包含路由和查询字符串/搜索参数形式的所需状态。搜索参数特别强大，因为它们完全是通用的和可定制的。</p>
<p>多亏了<a href="https://developer.mozilla.org/en-US/docs/Web/API/URLSearchParams"> <code>URLSearchParams</code> API </a>，不需要往返服务器就可以操作查询字符串。这是一个我们可以建立的基础。只要没有超过URL限制(大约2000个字符<a href="https://stackoverflow.com/a/417184/761388"/>，我们就可以自由地在URL中保持状态。</p>
<p>考虑一下:<br/>【https://our-app.com/?greeting=hi】<br/>上面的URL存储了一个单独的状态:<code>greeting</code>。</p>
<p>现在考虑:【https://our-app.com】<a href="https://our-app.com/?greeting=hi&amp;name=john">？greeting=hi &amp; name=john </a></p>
<h2 id="usesearchparams-hook"><code>useSearchParams</code>钩子</h2>
<p>如果你正在使用React，<a href="https://blog.logrocket.com/react-router-hooks-cleaner-components/"> React路由器</a>使得URL中的消费状态，特别是以查询字符串或搜索参数的形式，变得简单明了。这是通过<a href="https://reactrouter.com/docs/en/v6/hooks/use-search-params"> <code>useSearchParams</code>挂钩</a>实现的:</p>
<pre class="language-typescript hljs">import { useSearchParams } from "react-router-dom";

const [searchParams, setSearchParams] = useSearchParams();

const greeting = searchParams.get('greeting');

// ...

setSearchParams({ 'greeting': 'bonjour' }); // will set URL like so https://our-app.com?greeting=bonjour - this value will feed through to anything driven by the URL
</pre>
<p>这是本地持久化状态和以可共享方式持久化状态的一个很好的机制。</p>
<p>这种方法的一个显著优点是它不需要发送到服务器。它只是使用了像<code>URLSearchParams</code> API这样的浏览器API。更改查询字符串参数完全在本地即时发生。</p>
<h2 id="usesearchparamsstate-hook"><code>useSearchParamsState</code>钩子</h2>
<p><code>useSearchParams</code>钩子不做的是维护其他查询字符串或搜索参数。</p>
<p>如果我们在您的应用程序中维护多个状态，这可能意味着多个查询字符串或搜索参数。那么，非常有用的是一个钩子，它允许我们在不丢失其他状态的情况下更新状态。</p>
<p>此外，如果我们不必先获取<code>searchParams</code>对象，然后再操纵它，那就太好了。我们的<code>useSearchParamsState</code>挂钩时间到了:</p>
<pre class="language-typescript hljs">import { useSearchParams } from "react-router-dom";

export function useSearchParamsState(
    searchParamName: string,
    defaultValue: string
): readonly [
    searchParamsState: string,
    setSearchParamsState: (newState: string) =&gt; void
] {
    const [searchParams, setSearchParams] = useSearchParams();

    const acquiredSearchParam = searchParams.get(searchParamName);
    const searchParamsState = acquiredSearchParam ?? defaultValue;

    const setSearchParamsState = (newState: string) =&gt; {
        const next = Object.assign(
            {},
            [...searchParams.entries()].reduce(
                (o, [key, value]) =&gt; ({ ...o, [key]: value }),
                {}
            ),
            { [searchParamName]: newState }
        );
        setSearchParams(next);
    };
    return [searchParamsState, setSearchParamsState];
}
</pre>
<p>上面的钩子可以粗略地认为是<code>useState&lt;string&gt;</code>，但是在URL中存储状态。<br/>我们来想想它是如何工作的。初始化时，挂钩接受两个参数:</p>
<ul>
<li><code>searchParamName</code>:保存状态的查询字符串参数的名称</li>
<li><code>defaultValue</code>:查询字符串中没有值时的回退值</li>
</ul>
<p>然后吊钩继续缠绕<code>useSearchParams</code>吊钩。它向<code>searchParams</code>询问所提供的<code>searchParamName</code>，如果不存在，则返回到<code>defaultValue</code>。</p>
<p><code>setSearchParamsState</code>方法定义看起来有些复杂，但本质上它所做的就是获取现有搜索参数的内容，并为当前属性应用新的状态。</p>
<p>可能值得在这里暂停一下，观察一下这个实现中隐藏的一个观点:同一个搜索参数有多个值实际上是有效的。虽然这是可能的，但这种情况很少使用；这种实现只允许任何给定参数有一个值，因为这是非常有用的行为。</p>
<p>有了这些，我们就有了一个可以这样使用的钩子:</p>
<pre class="language-typescript hljs">const [greeting, setGreeting] = useSearchParamsState("greeting", "hello");
</pre>
<p>上面的代码返回一个<code>greeting</code>值，这个值是从<code>greeting</code>搜索参数中得到的。它还返回一个<code>setGreeting</code>函数，允许我们设置<code>greeting</code>值。这和<code>useState</code>是同一个API，所以反应用户应该感觉很习惯。太棒了。</p>
<h2 id="performance-usesearchparamsstate-hook-vs-usesearchparams-hook">表演:<code>useSearchParamsState</code>勾手vs<code>useSearchParams</code>勾手</h2>
<p>在这一点上，你可能想知道“为什么我们不总是使用<code>useSearchParamsState</code>钩子？”归结起来只有一个原因:性能。<code>useSearchParamsState</code>钩比<code>useState</code>钩慢。我们来想想为什么。</p>
<p>如果我们使用的是<code>useState</code>钩子，那么最终在代表我们应用程序的程序内部会有一个变量被更新。这是内部状态。然而，对于<code>useSearchParamsState</code>钩子来说，情况略有不同。</p>
<p>正如我们已经看到的，React路由器中的<code>useSearchParamsState</code>钩子是建立在<code>useSearchParams</code>钩子之上的。如果我们看看钩子的<a href="https://github.com/remix-run/react-router/blob/590b7a25a454d998c83f4e5d6f00ad5a6217533b/packages/react-router-dom/index.tsx#L785">实现，我们可以看到它依赖于各种浏览器API，比如<code>location</code>和<code>History</code>:</a></p>
<p><img data-attachment-id="154049" data-permalink="https://blog.logrocket.com/use-state-url-persist-state-usesearchparams/attachment/usesearchparams-hook-performance-react-router/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/09/usesearchparams-hook-performance-react-router.png" data-orig-size="720,146" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="useSearchParams Hook performance React Router" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/09/usesearchparams-hook-performance-react-router-300x61.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/09/usesearchparams-hook-performance-react-router.png" decoding="async" class="aligncenter wp-image-154049 size-full jetpack-lazy-image" src="../Images/4da0fed7e660c55460a5206101754a21.png" alt="useSearchParams Hook Performance React Router" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2022/09/usesearchparams-hook-performance-react-router.png 720w, https://blog.logrocket.com/wp-content/uploads/2022/09/usesearchparams-hook-performance-react-router-300x61.png 300w" data-lazy-sizes="(max-width: 720px) 100vw, 720px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2022/09/usesearchparams-hook-performance-react-router.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/09/usesearchparams-hook-performance-react-router.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="154049" data-permalink="https://blog.logrocket.com/use-state-url-persist-state-usesearchparams/attachment/usesearchparams-hook-performance-react-router/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/09/usesearchparams-hook-performance-react-router.png" data-orig-size="720,146" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="useSearchParams Hook performance React Router" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/09/usesearchparams-hook-performance-react-router-300x61.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/09/usesearchparams-hook-performance-react-router.png" decoding="async" loading="lazy" class="aligncenter wp-image-154049 size-full" src="../Images/4da0fed7e660c55460a5206101754a21.png" alt="useSearchParams Hook Performance React Router" srcset="https://blog.logrocket.com/wp-content/uploads/2022/09/usesearchparams-hook-performance-react-router.png 720w, https://blog.logrocket.com/wp-content/uploads/2022/09/usesearchparams-hook-performance-react-router-300x61.png 300w" sizes="(max-width: 720px) 100vw, 720px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/09/usesearchparams-hook-performance-react-router.png"/></noscript>
<p>这里的结果是对于我们的应用程序来说,<code>useSearchParamsState</code>钩子的状态是<code>external</code>。它可能不会有这种感觉，因为我们不必设置数据库或API，它的状态是外部的。状态存在于浏览器的API中，随之而来的是性能损失。下面是每次我们改变状态时发生的情况:</p>
<ul>
<li>React路由器中的<code>useSearchParams</code>钩子调用<code>History</code> API</li>
<li>浏览器更新URL</li>
<li>运行在应用程序根的React路由器实例检测到<code>location.search</code>的变化，并为应用程序显示一个新值</li>
<li>应用程序中依赖于该值的代码会做出反应</li>
</ul>
<p>以上比仅仅调用<code>useState</code>和依赖局部变量要慢。然而，它并没有慢得多。我一般不会有问题，因为现在的浏览器速度非常快。尽管如此，如果您打算编写尽可能高性能的代码，您可能希望避免这个钩子。</p>
<p>任何涉及外部API的东西，即使是存在于浏览器中的API，也会比局部变量慢。我认为这是一个重要因素的应用程序很少，但它仍然值得考虑。</p>
<h2 id="persisting-query-string-across-your-site">在您的站点中持久化查询字符串</h2>
<p>现在，我们有了这个令人兴奋的机制，它允许我们在URL中存储状态，因此，通过向某人发送URL可以轻松地共享状态。</p>
<p>同样有用的是一种在我们的站点中导航而不丢失状态的方法。假设我在URL中选择并存储了一个日期范围。当我从一个屏幕点击到另一个屏幕时，我想坚持这一点——我不想在每个屏幕上重新选择日期范围。</p>
<p>我们如何做到这一点？事实证明这很容易。我们需要的只是<code>useLocation</code>钩子和相应的<code>location.search</code>属性。它表示查询字符串，所以每次我们呈现一个链接时，我们只需像这样包含它:</p>
<pre class="language-typescript hljs">const [location] = useLocation();

return (&lt;Link to={`/my-page${location.search}`}&gt;Page&lt;/&gt;)
</pre>
<p>现在，当我们浏览我们的站点时，这种状态将被保持。</p>
<h2 id="conclusion">结论</h2>
<p>在这篇文章中，我们创建了一个<code>useSearchParamsState</code>钩子，它允许为了共享的目的将状态保存到URL中。</p><div class="code-block code-block-54">
<hr/>
<h3>更多来自LogRocket的精彩文章:</h3>

<hr/></div>
<div class="code-block code-block-17">
<div class="blog-plug inline-plug react-plug" vwo-el-id="26283398190">
<h2 vwo-el-id="41600691720">使用LogRocket消除传统反应错误报告的噪音</h2>
<a href="https://lp.logrocket.com/blg/react-signup-issue-free" target="_blank" vwo-el-id="19356441070">LogRocket
</a><p>是一款React analytics解决方案，可保护您免受数百个误报错误警报的影响，只针对少数真正重要的项目。LogRocket告诉您React应用程序中实际影响用户的最具影响力的bug和UX问题。</p><a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="19356441380">
<img class="first-react-image alignnone size-full wp-image-46 jetpack-lazy-image jetpack-lazy-image--handled" src="../Images/f300c244a1a1cf916df8b4cb02bec6c6.png" vwo-el-id="18272717540" data-lazy-loaded="1" data-original-src="https://files.readme.io/27c94e7-Image_2017-06-05_at_9.46.04_PM.png"/>
</a>
<a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="19356441690">
<img class="second-react-image alignnone size-full wp-image-46 jetpack-lazy-image jetpack-lazy-image--handled" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" vwo-el-id="30720362350" data-lazy-loaded="1" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/>
</a>
<a href="https://lp.logrocket.com/blg/react-signup-issue-free" target="_blank" rel="noopener noreferrer" vwo-el-id="35866400580">LogRocket
</a><p>自动聚合客户端错误、反应错误边界、还原状态、缓慢的组件加载时间、JS异常、前端性能指标和用户交互。然后，LogRocket使用机器学习来通知您影响大多数用户的最具影响力的问题，并提供您修复它所需的上下文。</p><p vwo-el-id="28675661060">关注重要的React bug—<a class="signup" href="https://lp.logrocket.com/blg/react-signup-issue-free" target="_blank" rel="noopener noreferrer" vwo-el-id="40093418840">今天就试试LogRocket】。</a></p>
</div></div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
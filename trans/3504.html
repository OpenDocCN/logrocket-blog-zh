<html>
<head>
<title>Advanced uses of Dart mixins: Avoiding duplicate methods </title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>Dart混合的高级用途:避免重复方法</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/advanced-uses-dart-mixins-avoiding-duplicate-methods/#0001-01-01">https://blog.logrocket.com/advanced-uses-dart-mixins-avoiding-duplicate-methods/#0001-01-01</a></blockquote><div><article class="article-post">
<p>我在Dart中遇到的一个困难是一次只能继承或扩展一个类的限制。您可以通过使用Dart mixins来改进类继承和代码可重用性，从而绕过这个约束，尤其是在更复杂的架构中。</p>
<p>说到类的可重用性，Dart提供了很多，尤其是自从Dart 2.1引入mixin关键字以来。通过Dart混合，跨多个类层次重用任何类的代码都变得很容易。</p>
<p>在本教程中，我们将学习更多关于混合的一般知识，看看Dart混合，并学习如何在Dart类中避免重复的方法。</p>
<p>以下是我们将要介绍的内容:</p>

<p>要阅读本文，您应该对Dart有一个基本的了解。我已经使用<a href="https://dartpad.dev/?" target="_blank" rel="noopener"> dartpad.dev </a>编写了本教程中的示例程序。</p>
<h2 id="what-are-dart-mixins">什么是Dart mixins？</h2>
<p>Dart mixins是以关键字<code>mixin</code>开头的特殊类，包含其他类可以使用的方法集合。Dart mixins鼓励代码重用，并帮助您避免多重继承带来的限制。它允许您以标准类继承不允许的方式向类添加额外的特性。</p>
<p>让我们考虑一个典型的电子商务应用程序中的角色分配:</p>
<pre class="language-dart hljs">void main() {
  Moderator().viewAllProducts();
}

class User {
  void viewAllProducts() {
    print('Viewed all products');
  }

  void purchaseProduct() {
    print('Purchased a designer bag');
  }
}

class Vendor {
  void createStore() {
    print('Created EA sports stores');
  }

  void deleteStore() {
    print('Delete EA sports stores');
  }
}

class Moderator {
  void approveStore() {
    print('Approved EA sports stores');
  }

  void viewAllProducts() {
    print('Viewed all products');
  }
}
</pre>
<p>每个类中的方法都是不言自明的。仔细观察代码片段，您会注意到在<code>User</code>和<code>Moderator</code>类中都有一个方法重复(<code>viewAllProducts</code>)。尽管这很有效，但不是一个好的实践。</p>
<h2 id="drawbacks-of-dart-mixins">省道混合线的缺点</h2>
<p>虽然Flutter mixins减少了继承遇到的缺点，但它不能取代继承，因为它有自己的缺点。</p>
<p>过度使用<code>class Vendor</code>与<code>CanViewAllProducts,CanRemoveProduct,...</code>等mixins，违背了单一责任原则，难以理解类目的。此外，在运行时，代码执行往往会在不同的mixins中跳转，这使得调试和遵循执行顺序变得困难。</p>
<p>此外，使用mixins会导致很长的编译时间。在使用mixins之前要小心风险，你将更有可能享受它们的好处。</p>
<h2 id="avoiding-duplicate-methods-in-dart-classes">避免Dart类中的重复方法</h2>
<p>为了避免代码重复，我们将利用Dart类继承。</p>
<p>在Dart中，继承是一个类从另一个类派生其属性和方法的过程。</p>
<p>让我们删除重复的<code>viewAllProducts</code>方法，并允许<code>Moderator</code>类从<code>User</code>类派生出<code>viewAllProducts</code>方法:</p>
<pre class="language-dart hljs">void main() {
  Moderator().viewAllProducts();
}

class User {
  void viewAllProducts() {
    print('Viewed all products');
  }

  void purchaseProduct() {
    print('Purchased a designer bag');
  }
}

class Moderator extends User {
  void approveStore() {
    print('Approved EA sports stores');
  }
}
</pre>
<p>在<a href="https://dartpad.dev/?" target="_blank" rel="noopener"> dartpad.dev </a>上执行上面的代码片段，您应该会得到与前面代码片段相同的结果。</p>
<p>这很好，但是接下来还有一个关于继承的问题，我们将继续讨论。你有没有注意到我们的<code>Moderator</code>类也从<code>User</code>类派生了<code>purchaseProduct</code>方法，这是完全不必要的，因为我们希望<code>Moderator</code>从<code>User</code>类只派生<code>viewAllProducts</code>？这就是Dart mixins派上用场的地方。</p>
<h3 id="multilevel-inheritance-in-dart">Dart中的多级继承</h3>
<p>当一个类继承另一个子类时，就会发生多级继承。Dart允许一个类从另一个子类继承方法和属性。</p>
<p>让我们考虑下面的片段:</p>
<pre class="language-dart hljs">void main() {
  Vendor().viewAllProducts();
  Vendor().purchaseProducts();
  Vendor().approveStore();
  Vendor().createStore();
  Vendor().deleteStore();
}

class User {
  void viewAllProducts() {
    print('Viewed all products');
  }

  void purchaseProducts() {
    print('Purchased 2 designer bags');
  }
}

class Moderator extends User {
  void approveStore() {
    print('Approved EA sports stores');
  }
}

class Vendor extends Moderator {
  void createStore() {
    print('Created EA sports stores');
  }

  void deleteStore() {
    print('Delete EA sports stores');
  }
}
</pre>
<p><img data-attachment-id="138248" data-permalink="https://blog.logrocket.com/advanced-uses-dart-mixins-avoiding-duplicate-methods/attachment/user-moderator-vendor/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/10/user-moderator-vendor.png" data-orig-size="730,463" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="User moderator vendor" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/10/user-moderator-vendor-300x190.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/10/user-moderator-vendor.png" decoding="async" class="aligncenter size-full wp-image-138248 jetpack-lazy-image" src="../Images/50c7c6719a8cb6b163c8f6db121404b8.png" alt="User Moderator Vendor" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2022/10/user-moderator-vendor.png 730w, https://blog.logrocket.com/wp-content/uploads/2022/10/user-moderator-vendor-300x190.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2022/10/user-moderator-vendor.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/10/user-moderator-vendor.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="138248" data-permalink="https://blog.logrocket.com/advanced-uses-dart-mixins-avoiding-duplicate-methods/attachment/user-moderator-vendor/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/10/user-moderator-vendor.png" data-orig-size="730,463" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="User moderator vendor" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/10/user-moderator-vendor-300x190.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/10/user-moderator-vendor.png" decoding="async" loading="lazy" class="aligncenter size-full wp-image-138248" src="../Images/50c7c6719a8cb6b163c8f6db121404b8.png" alt="User Moderator Vendor" srcset="https://blog.logrocket.com/wp-content/uploads/2022/10/user-moderator-vendor.png 730w, https://blog.logrocket.com/wp-content/uploads/2022/10/user-moderator-vendor-300x190.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/10/user-moderator-vendor.png"/></noscript>
<p>这里，<code>Vendor</code>类从<code>Moderator</code>类继承了<code>approveStore</code>方法。因为<code>Moderator</code>类是<code>User</code>类的子类，所以从其父类<code>User</code>继承的<code>viewAllProducts</code>和<code>purchaseProducts</code>方法被传递给<code>Vendor</code>类(其子类)。</p>
<h3 id="multiple-inheritance-in-dart">Dart中的多重继承</h3>
<p>当一个类从多个父类继承时，这就是所谓的多重继承。</p>
<p>让我们用以下方法考虑第四种类型的用户<code>Admin</code>:</p>
<ul>
<li><code>approveStore</code></li>
<li><code>deleteStore</code></li>
<li><code>viewAllProducts</code></li>
</ul>
<p>您可能会想到通过允许<code>Admin</code>类从<code>Moderator</code>和<code>Vendor</code>类继承上述方法来避免代码重复。不幸的是，Dart不支持多重继承，这意味着一个类不能扩展多个类。所以，我们转向Dart mixins。</p>
<h2 id="creating-mixins-with-dart">使用Dart创建mixins</h2>
<p>为了创建一个mixin，我们将利用<code>mixin</code>关键字:</p>
<pre class="language-dart hljs">mixin MixinName {
  //Define reusable methods
}
</pre>
<p>让我们解决前面提到的继承问题，我们的<code>Moderator</code>类也从<code>User</code>类派生了<code>purchaseProduct</code>方法，但是我们希望<code>Moderator</code>只从<code>User</code>类派生<code>viewAllProducts</code>:</p>
<pre class="language-dart hljs">mixin CanViewAllProducts {
  void viewAllProducts() {
    print('Viewed all products');
  }
}
</pre>
<p>为了使用<code>CanViewAllProducts</code> mixins，我们将如下利用<code>with</code>关键字:</p>
<pre class="language-dart hljs">class Moderator with CanViewAllProducts {
  void approveStore() {
    print('Approved EA sports stores');
  }
}
</pre>
<p>现在，我们的<code>Moderator</code>类可以通过<code>canViewAllProducts</code> mixin访问<code>viewAllProducts</code>方法，而无需继承不必要的方法。<code>CanViewAllProducts</code>mixin可以在需要其方法的多个类中重用。</p>
<p>Dart允许我们将继承与混合结合起来，如下所示:</p>
<pre class="language-dart hljs">mixin CanViewAllProducts {
  void viewAllProducts() {
    print('Viewed all products');
  }
}

class User {
  void purchaseProducts() {
    print('Purchased 2 designer bags');
  }
}

class Vendor extends User with CanViewAllProducts {
  void createStore() {
    print('Created EA sports stores');
  }
}
</pre>
<p>Dart还允许一个类使用多个mixin，用逗号分隔每个mixin。</p>
<p>让我们看一个例子:</p>
<pre class="language-dart hljs">mixin CanRemoveProduct {
  void removeProduct() {
    print('Remove product');
  }
}
class Vendor extends User with CanViewAllProducts,CanRemoveProduct {
  void createStore() {
    print('Created EA sports stores');
  }
}
</pre>
<h2 id="conclusion">结论</h2>
<p>Dart混合在开发复杂程度可能会增加的应用程序时非常有用。在开发复杂的Dart应用程序时，您可能会发现需要同时扩展多个类，而这在Dart中是不支持的。</p>
<p>Dart mixins可以帮助您克服一次只能从一个类继承或扩展的限制，并改进类继承和代码可重用性。更多开发者内容，可以在Twitter上关注我<a href="https://mobile.twitter.com/5x_dev" target="_blank" rel="noopener">@ 5x _ dev</a>。</p><div class="code-block code-block-4">
<div class="blog-plug base-cta"><h2>使用<a class="signup" href="https://lp.logrocket.com/blg/signup" target="_blank" rel="noopener noreferrer"> LogRocket </a>消除传统错误报告的干扰</h2>
<a href="https://lp.logrocket.com/blg/signup" class="signup" target="_blank" rel="noopener noreferrer"><img class="alignnone size-full wp-image-46 jetpack-lazy-image" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/><noscript><img data-lazy-fallback="1" class="alignnone size-full wp-image-46" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/></noscript></a>
<p><a href="https://lp.logrocket.com/blg/signup" target="_blank" rel="noopener noreferrer"> LogRocket </a>是一个数字体验分析解决方案，它可以保护您免受数百个假阳性错误警报的影响，只针对几个真正重要的项目。LogRocket会告诉您应用程序中实际影响用户的最具影响力的bug和UX问题。</p>
<p>然后，使用具有深层技术遥测的会话重放来确切地查看用户看到了什么以及是什么导致了问题，就像你在他们身后看一样。</p>
<p>LogRocket自动聚合客户端错误、JS异常、前端性能指标和用户交互。然后LogRocket使用机器学习来告诉你哪些问题正在影响大多数用户，并提供你需要修复它的上下文。</p>
<p>关注重要的bug—<a class="signup" href="https://lp.logrocket.com/blg/signup-issue-free" target="_blank" rel="noopener noreferrer">今天就试试LogRocket】。</a></p></div></div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
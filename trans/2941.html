<html>
<head>
<title>Build a Spotify clone with React and ts-audio - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>用 React 和 ts-audio - LogRocket 博客构建一个 Spotify 克隆</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/build-spotify-clone-react-ts-audio/#0001-01-01">https://blog.logrocket.com/build-spotify-clone-react-ts-audio/#0001-01-01</a></blockquote><div><article class="article-post">
<p>音乐播放器是允许您收听音频文件和录音的设备或应用程序。有许多可用的音乐播放器，但在本文中，我们将使用 React 和<a href="https://www.npmjs.com/package/ts-audio"> ts-audio </a>构建一个<a href="https://www.spotify.com/us/">流行音乐流媒体服务 Spotify </a>的克隆。</p>
<p>你可能认为本教程会使用 Spotify API，然而，Spotify 和其他音乐数据库并没有在它们的响应体中提供流媒体链接或 URL。Spotify API 确实提供了一个预览 URL，但是歌曲的时长仅限于 30 秒，这对于我们的例子来说是不够的。因此，我们不会使用 Spotify API 或向任何音乐 API 或数据库发出任何请求。</p>
<p>相反，我们将使用由歌曲和图片组成的虚拟数据。但是，如果您尝试使用一个带有可流式链接的 API，您也可以应用本文中使用的方法。你可以在 GitHub repo 找到本教程的完整代码<a href="https://github.com/iamfortune/Spotify-clone-with-Ts-audio">。我们开始吧！</a></p>

<h2 id="what-ts-audio">什么是 ts-audio？</h2>
<p>ts-audio 是一个不可知的库，它使得<a href="https://developer.mozilla.org/en-US/docs/Web/API/AudioContext"> <code>AudioContext</code> API </a>更容易交互。ts-audio 为您提供了播放、暂停等方法，并允许您创建播放列表。ts-audio 提供以下功能:</p>
<ul>
<li>包括一个简单的 API，它抽象了<code>AudioContext</code> API 的复杂性</li>
<li>提供跨浏览器支持</li>
<li>轻松创建音频播放列表</li>
<li>适用于任何编译成 JavaScript 的语言</li>
</ul>
<h2 id="building-spotify-clone-with-tsaudio">用 ts-audio 构建 Spotify 克隆</h2>
<p>让我们用下面的命令创建一个新的 React 应用程序:</p>
<pre class="language-bash">npx create-react-app ts-audio
</pre>
<p>如果您使用 Yarn，运行下面的命令:</p>
<pre class="language-bash">yarn create react-app ts-audio
</pre>
<p>对于教程的其余部分，我将使用纱线。接下来，我们安装 ts-audio 包，如下所示:</p>
<pre class="language-bash">yarn add ts-audio
</pre>
<p>在其核心，ts-audio 有两个组件，<code>Audio</code>和<code>AudioPlaylist</code>。组件是我们可以用特定参数调用的函数。</p>
<h3 id="using-audio-component">使用<code>Audio</code>组件</h3>
<p>组件允许我们传入一首要播放的歌曲。它还为我们提供了某些方法，如<code>play()</code>、<code>pause()</code>、<code>stop()</code>等等:</p>
<pre class="language-javascript">// App.js

import Audio from 'ts-audio';
import Lazarus from './music/Lazarus.mp3';

export default function App() {
  const audio = Audio({
    file: Lazarus
  })

  const play = () =&gt; {
    audio.play()
  }

    const pause = () =&gt; {
    audio.pause()
  }

    const stop = () =&gt; {
    audio.stop()
  }

  return (
    &lt;&gt;
      &lt;button onClick={play}&gt;Play&lt;/button&gt;
      &lt;button onClick={pause}&gt;Pause&lt;/button&gt;
      &lt;button onClick={stop}&gt;Stop&lt;/button&gt;
    &lt;/&gt;
  )
}
</pre>
<p>在上面的代码块中，我们从 ts-audio 导入了<code>Audio</code>组件和我们想要播放的歌曲。我们创建了一个音频实例，将其设置为导入的<code>Audio</code>组件，然后将导入的音乐传递给由<code>Audio</code>元素公开的文件参数。</p>
<p>我们利用了 ts-audio 提供给我们的方法，比如<code>play()</code>和<code>pause()</code>，然后通过函数将它们传递给按钮。</p>
<h3 id="using-audio-playlist-component">使用<code>AudioPlaylist</code>组件</h3>
<p><code>AudioPlaylist</code>组件允许我们传入多首歌曲，但它们必须在一个数组中，否则 ts-audio 不会播放它们。<code>AudioPlaylist</code>组件为我们提供了<code>play()</code>、<code>pause()</code>、<code>stop()</code>、<code>next()</code>和<code>prev()</code>等方法。</p>
<p>下面的代码块是如何使用<code>AudioPlaylist</code>组件的例子:</p>
<pre class="language-javascript">// App.js

import { AudioPlaylist } from 'ts-audio';
import Lazarus from './music/Lazarus.mp3';
import Sia from './music/Sia - Bird Set Free.mp3';

export default function App() {
  const playlist = AudioPlaylist({
    files: [Lazarus, Sia]
  })

  const play = () =&gt; {
    playlist.play()
  }

  const pause = () =&gt; {
    playlist.pause()
  }

  const next = () =&gt; {
    playlist.next()
  }

  const previous = () =&gt; {
    playlist.prev()
  }

  const stop = () =&gt; {
    playlist.stop()
  }

  return (
    &lt;&gt;
      &lt;button onClick={play}&gt;Play&lt;/button&gt;
      &lt;button onClick={pause}&gt;Pause&lt;/button&gt;
      &lt;button onClick={next}&gt;Next&lt;/button&gt;
      &lt;button onClick={prev}&gt;Prev&lt;/button&gt;
      &lt;button onClick={stop}&gt;Stop&lt;/button&gt;
    &lt;/&gt;
  )
}
</pre>
<p>音乐播放器将具有以下功能:</p>
<ul>
<li>每当我们点击<strong>下一首</strong>或<strong>上一首</strong>时，将艺术家更改为当前歌曲的艺术家</li>
<li>将图像更改为当前歌曲的图像</li>
<li>将歌曲标题更改为当前歌曲</li>
</ul>
<p>在<code>src</code>文件夹中，分别创建两个名为<code>images</code>和<code>music</code>的文件夹。导航到<code>images</code>文件夹，粘贴您可能需要的任何照片。在<code>music</code>文件夹中，你可以粘贴任何你想要使用的音频文件。</p>
<p>在下面的 GitHub repos 中，你可以获得本教程使用的<a href="https://github.com/iamfortune/Spotify-clone-with-Ts-audio/tree/main/src/images">图片文件</a>和<a href="https://github.com/iamfortune/Spotify-clone-with-Ts-audio/tree/main/src/images">获取音频文件</a>。接下来，将歌曲和图像导入<code>App.js</code>，如下所示:</p>
<pre class="language-javascript">import { AudioPlaylist } from 'ts-audio';

// Music import
import Eyes from './music/01. Jon Bellion - Eyes To The Sky.mp3';
import Mood from './music/24kGoldn-Mood-Official-Audio-ft.-Iann-Dior.mp3';
import Audio from './music/audio.mp3';
import Broken from './music/Cant Be Broken .mp3';
import Lazarus from './music/Lazarus.mp3';
import Sia from './music/Sia - Bird Set Free.mp3';
import Nobody from './music/T-Classic-Nobody-Fine-Pass-You.mp3';
import Yosemite from './music/Yosemite.mp3';

// Pictures import
import EyesImg from './images/Eyes to the sky.jpeg';
import MoodImg from './images/mood.jpeg';
import AudioImg from './images/lana.jpeg';
import BrokenImg from './images/lil wayne.jpeg';
import LazarusImg from './images/dave.jpeg';
import SiaImg from './images/sia.jpeg';
import NobodyImg from './images/nobody.jpeg';
import YosemiteImg from './images/travis.jpeg';

export default function App() {
  const songs =  [
      {
        title: 'Eyes to the sky',
        artist: 'Jon Bellion',
        img_src: EyesImg,
        src: Eyes,
      },
      {
        title: 'Lazarus',
        artist: 'Dave',
        img_src: LazarusImg,
        src: Lazarus,
      },
      {
        title: 'Yosemite',
        artist: 'Travis scott',
        img_src: YosemiteImg,
        src: Yosemite,
      },
      {
        title: 'Bird set free',
        artist: 'Sia',
        img_src: SiaImg,
        src: Sia,
      },
      {
        title: 'Cant be broken',
        artist: 'Lil wayne',
        img_src: BrokenImg,
        src: Broken,
      },
      {
        title: 'Mood',
        artist: '24kGoldn',
        img_src: MoodImg,
        src: Mood,
      },
      {
        title: 'Nobody fine pass you',
        artist: 'T-Classic',
        img_src: NobodyImg,
        src: Nobody,
      },
      {
        title: 'Dark paradise',
        artist: 'Lana Del Ray',
        img_src: AudioImg,
        src: Audio,
      },
    ]

  const playlist = AudioPlaylist({
      files: songs.map((song) =&gt; song.src),
    });

  const handlePlay = () =&gt; {
    playlist.play();
  };

  const handlePause = () =&gt; {
    playlist.pause();
  };

  const handleSkip = () =&gt; {
    playlist.next();
  };

  const handlePrevious = () =&gt; {
    playlist.prev();
  };

  return (
    &lt;&gt;
      &lt;button onClick={handlePlay}&gt;Play&lt;/button&gt;
      &lt;button onClick={handlePause}&gt;Pause&lt;/button&gt;
      &lt;button onClick={handleSkip}&gt;Next&lt;/button&gt;
      &lt;button onClick={handlePrevious}&gt;Prev&lt;/button&gt;     
    &lt;/&gt;
  );
}
</pre>
<p>在上面的代码块中，我们导入了歌曲和图像。接下来，我们创建了一个包含对象的歌曲数组。每个对象都有一个用于导入图像的<code>title</code>、<code>artist</code>、<code>img_src</code>，以及用于导入歌曲的<code>src</code>。</p>
<p>之后，我们通过 song 数组映射到歌曲的<code>src</code>，并将其传递到 files 参数中。记住，我们必须把它作为一个数组传入，但是然后<code>map()</code>方法通过调用一个函数来创建一个新的数组。因此，我们可以将它传递给<code>files</code>参数。</p>
<p>我们还创建了自己的方法，并将它们传递给各个按钮。我们将创建一个<code>Player.js</code>文件来处理按钮，同时处理<code>App.js</code>中的功能:</p>
<pre class="language-javascript">// Player.js

export default function Player({ play, pause, next, prev }) {
  return (
    &lt;div className="c-player--controls"&gt;
      &lt;button onClick={play}&gt;Play&lt;/button&gt;
      &lt;button onClick={pause}&gt;Pause&lt;/button&gt;
      &lt;button onClick={next}&gt;Next&lt;/button&gt;
      &lt;button onClick={prev}&gt;Previous&lt;/button&gt; 
    &lt;/div&gt;
  );
}
</pre>
<p>在上面的代码块中，我们创建了一个<code>Player.js</code>文件，然后捕捉来自<code>App.js</code>的道具，最后将它们传递到按钮中。</p>
<h3 id="creating-functionalities">创建功能</h3>
<p>为了创建应用程序的功能，我们导入<code>useState</code>来获取歌曲的当前索引。然后，我们将图像设置为当前照片，将艺术家设置为当前艺术家，将标题设置为当前标题:</p>
<pre class="language-javascript">// App.js

import React, { useState } from 'react';
import Player from './Player';
import { AudioPlaylist } from 'ts-audio';
// Music import

// Pictures import

export default function App() {
  const [currentSong, setCurrentSong] = useState(0);
  const [isPlaying, setIsPlaying] = useState(false);


  // Songs Array

  const playlist =AudioPlaylist({
      files: songs.map((song) =&gt; song.src),
    });

  const handlePlay = () =&gt; {
    playlist.play();
    setIsPlaying(true);
  };

  const handlePause = () =&gt; {
    playlist.pause();
    setIsPlaying(false);
  };

  const handleSkip = () =&gt; {
    playlist.next();
    setIsPlaying(true);
    setCurrentSong(
      (currentSong) =&gt; (currentSong + 1 + songs.length) % songs.length
    );
  };

  const handlePrevious = () =&gt; {
    playlist.prev();
    setIsPlaying(true);
    setCurrentSong(
      (currentSong) =&gt; (currentSong - 1 + songs.length) % songs.length
    );
  };
  return (
    &lt;&gt;
      &lt;div className="App"&gt;
        &lt;div className="c-player"&gt;
          &lt;div className="c-player--details"&gt;
            {' '}
            &lt;div className="details-img"&gt;
              {' '}
              &lt;img src={songs[currentSong].img_src} alt="img" /&gt;
            &lt;/div&gt;
            &lt;h1 className="details-title"&gt;{songs[currentSong].title}&lt;/h1&gt;
            &lt;h2 className="details-artist"&gt;{songs[currentSong].artist}&lt;/h2&gt;
          &lt;/div&gt;
          &lt;Player
            play={handlePlay}
            pause={handlePause}
            isPlaying={isPlaying}
            setIsPlaying={setIsPlaying}
            next={handleSkip}
            prev={handlePrevious}
          /&gt;
        &lt;/div&gt;
      &lt;/div&gt;
    &lt;/&gt;
  );
}
</pre>
<p>我们创建了一个状态事件，并将其设置为零。当我们点击<strong>下一个</strong>按钮时，我们将状态设置为当前状态的余数 1 和歌曲长度之和除以歌曲长度:</p>
<pre class="“language-javascript">currentSong + 1 + songs.length) % songs.length</pre>
<p>当我们点击<strong>上一首</strong>按钮时，我们将状态设置为当前歌曲的剩余部分，减去 1，加上歌曲的长度除以歌曲的长度:</p>
<pre class="“language-javascript">currentSong - 1 + songs.length) % songs.length</pre>
<p>我们还创建了一个状态事件来检查歌曲是否正在播放，然后我们将它作为道具传递给<code>Player</code>组件。最后，我们处理了更改图像、艺术家和歌名的功能。</p>
<p>当我们启动应用程序时，一切似乎都正常；点击<strong>下一个</strong>按钮时，图像会发生变化。但是，播放的歌曲与屏幕上显示的图片和艺术家姓名不匹配。有时，两首或多首歌曲会同时播放。</p>
<h2 id="problem-solving">解决问题:不匹配的歌曲细节</h2>
<p>当我们点击<strong>下一个</strong>或<strong>上一个</strong>按钮时，我们正在重新计算值并有效地导致重新渲染。为了停止这种情况，我们将歌曲数组和创建的播放列表实例包装在一个<code>useMemo</code>钩子中，如下所示:</p>
<pre class="language-javascript">// App.js

import React, { useState, useMemo } from 'react';
import Player from './Player';
import { AudioPlaylist } from 'ts-audio';
// Music import

// Pictures import

export default function App() {
  const [currentSong, setCurrentSong] = useState(0);

  const songs = useMemo(
    () =&gt; [
      {
        title: 'Eyes to the sky',
        artist: 'Jon Bellion',
        img_src: EyesImg,
        src: Eyes,
      },
      {
        title: 'Lazarus',
        artist: 'Dave',
        img_src: LazarusImg,
        src: Lazarus,
      },
      {
        title: 'Yosemite',
        artist: 'Travis scott',
        img_src: YosemiteImg,
        src: Yosemite,
      },
      {
        title: 'Bird set free',
        artist: 'Sia',
        img_src: SiaImg,
        src: Sia,
      },
      {
        title: 'Cant be broken',
        artist: 'Lil wayne',
        img_src: BrokenImg,
        src: Broken,
      },
      {
        title: 'Mood',
        artist: '24kGoldn',
        img_src: MoodImg,
        src: Mood,
      },
      {
        title: 'Nobody fine pass you',
        artist: 'T-Classic',
        img_src: NobodyImg,
        src: Nobody,
      },
      {
        title: 'Dark paradise',
        artist: 'Lana Del Ray',
        img_src: AudioImg,
        src: Audio,
      },
    ],
    []
  );

  const playlist = useMemo(() =&gt; {
    return AudioPlaylist({
      files: songs.map((song) =&gt; song.src),
    });
  }, [songs]);
</pre>
<p><code>useMemo</code>钩子有效地缓存了这个值，这样就不需要重新计算，也就不会导致重新渲染。</p>
<h2 id="adding-styling">添加样式</h2>
<p>在本教程中，我们将使用<a href="https://fontawesome.com/v5/docs/web/use-with/react">字体中的图标。您可以使用下面的命令安装 Font Awesome 软件包:</a></p>
<pre>yarn add @fortawesome/fontawesome-svg-core
yarn add @fortawesome/free-solid-svg-icons
yarn add @fortawesome/react-fontawesome
</pre>
<p>将以下代码复制并粘贴到<code>Player.js</code>文件中:</p>
<pre class="language-javascript">// Player.js

import { FontAwesomeIcon } from '@fortawesome/react-fontawesome';
import { faPlay, faPause, faForward, faBackward } from '@fortawesome/free-solid-svg-icons';
export default function Player({ play, pause, next, prev, isPlaying, setIsPlaying }) {
  return (
    &lt;div className="c-player--controls"&gt;
      &lt;button className="skip-btn" onClick={prev}&gt;
        &lt;FontAwesomeIcon icon={faBackward} /&gt;
      &lt;/button&gt;
      &lt;button
        className="play-btn"
        onClick={() =&gt; setIsPlaying(!isPlaying ? play : pause)}
      &gt;
        &lt;FontAwesomeIcon icon={isPlaying ? faPause : faPlay} /&gt;
      &lt;/button&gt;
      &lt;button className="skip-btn" onClick={next}&gt;
        &lt;FontAwesomeIcon icon={faForward} /&gt;
      &lt;/button&gt;
    &lt;/div&gt;
  );
}
</pre>
<p>在上面的代码块中，我们从<code>App.js</code>文件中获取道具，然后在<code>Player.js</code>文件中处理它们。对于样式，将下面的代码复制并粘贴到您的<code>index.css</code>文件中:</p>
<pre class="“language-javascript">* {
  margin: 0;
  padding: 0;
  box-sizing: border-box;
  font-family: 'Fira Sans', sans-serif;
}
body {
  background-color: #ddd;
}
.App {
  display: flex;
  align-items: center;
  justify-content: center;
  min-height: 100vh;
  max-width: 100vw;
}
.c-player {
  display: block;
  background-color: #0a54aa;
  max-width: 400px;
  display: block;
  margin: 0px auto;
  padding: 50px;
  border-radius: 16px;
  box-shadow: inset -6px -6px 12px rgba(0, 0, 0, 0.8),
    inset 6px 6px 12px rgba(255, 255, 255, 0.4);
}
.c-player &gt; h4 {
  color: #fff;
  font-size: 14px;
  text-transform: uppercase;
  font-weight: 500;
  text-align: center;
}
.c-player &gt; p {
  color: #aaa;
  font-size: 14px;
  text-align: center;
  font-weight: 600;
}
.c-player &gt; p span {
  font-weight: 400;
}
.c-player--details .details-img {
  position: relative;
  width: fit-content;
  margin: 0 auto;
}
.c-player--details .details-img img {
  display: block;
  margin: 50px auto;
  width: 100%;
  max-width: 250px;
  border-radius: 50%;
  box-shadow: 6px 6px 12px rgba(0, 0, 0, 0.8),
    -6px -6px 12px rgba(255, 255, 255, 0.4);
}
.c-player--details .details-img:after {
  content: '';
  display: block;
  position: absolute;
  top: -25px;
  left: -25px;
  right: -25px;
  bottom: -25px;
  border-radius: 50%;
  border: 3px dashed rgb(255, 0, 0);
}
.c-player--details .details-title {
  color: #eee;
  font-size: 28px;
  text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8),
    -2px -2px 4px rgba(255, 255, 255, 0.4);
  text-align: center;
  margin-bottom: 10px;
}
.c-player--details .details-artist {
  color: #aaa;
  font-size: 20px;
  text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8),
    -2px -2px 4px rgba(255, 255, 255, 0.4);
  text-align: center;
  margin-bottom: 20px;
}
.c-player--controls {
  display: flex;
  align-items: center;
  justify-content: center;
  margin-bottom: 30px;
}
.c-player--controls .play-btn {
  display: flex;
  margin: 0 30px;
  padding: 20px;
  border-radius: 50%;
  box-shadow: 4px 4px 10px rgba(0, 0, 0, 0.8),
    -4px -4px 10px rgba(255, 255, 255, 0.4),
    inset -4px -4px 10px rgba(0, 0, 0, 0.4),
    inset 4px 4px 10px rgba(255, 255, 255, 0.4);
  border: none;
  outline: none;
  background-color: #ff0000;
  color: #fff;
  font-size: 24px;
  cursor: pointer;
}
.c-player--controls .skip-btn {
  background: none;
  border: none;
  outline: none;
  cursor: pointer;
  color: rgb(77, 148, 59);
  font-size: 18px;
}
</pre>
<h2 id="conclusion">结论</h2>
<p>在本文中，我们已经了解了 ts-audio，这是一个与<code>AudioContext</code> API 一起工作的不可知的、易于使用的库。我们了解了 ts-audio 的方法，以及它如何使处理音频文件变得更加容易。最后，我们学习了如何使用 ts-audio 构建一个可工作的音乐播放器。</p><div class="code-block code-block-17">
<div class="blog-plug inline-plug react-plug" vwo-el-id="26283398190">
<h2 vwo-el-id="41600691720">使用 LogRocket 消除传统反应错误报告的噪音</h2>
<a href="https://lp.logrocket.com/blg/react-signup-issue-free" target="_blank" vwo-el-id="19356441070">LogRocket
</a><p>是一款 React analytics 解决方案，可保护您免受数百个误报错误警报的影响，只针对少数真正重要的项目。LogRocket 告诉您 React 应用程序中实际影响用户的最具影响力的 bug 和 UX 问题。</p><a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="19356441380">
<img class="first-react-image alignnone size-full wp-image-46 jetpack-lazy-image jetpack-lazy-image--handled" src="../Images/f300c244a1a1cf916df8b4cb02bec6c6.png" vwo-el-id="18272717540" data-lazy-loaded="1" data-original-src="https://files.readme.io/27c94e7-Image_2017-06-05_at_9.46.04_PM.png"/>
</a>
<a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="19356441690">
<img class="second-react-image alignnone size-full wp-image-46 jetpack-lazy-image jetpack-lazy-image--handled" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" vwo-el-id="30720362350" data-lazy-loaded="1" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/>
</a>
<a href="https://lp.logrocket.com/blg/react-signup-issue-free" target="_blank" rel="noopener noreferrer" vwo-el-id="35866400580">LogRocket
</a><p>自动聚合客户端错误、反应错误边界、还原状态、缓慢的组件加载时间、JS 异常、前端性能指标和用户交互。然后，LogRocket 使用机器学习来通知您影响大多数用户的最具影响力的问题，并提供您修复它所需的上下文。</p><p vwo-el-id="28675661060">关注重要的 React bug—<a class="signup" href="https://lp.logrocket.com/blg/react-signup-issue-free" target="_blank" rel="noopener noreferrer" vwo-el-id="40093418840">今天就试试 LogRocket】。</a></p>
</div></div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
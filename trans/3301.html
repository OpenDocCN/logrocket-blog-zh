<html>
<head>
<title>Implementing a component visibility sensor with React Native - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>用React Native - LogRocket博客实现组件可见性传感器</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/implementing-component-visibility-sensor-react-native/#0001-01-01">https://blog.logrocket.com/implementing-component-visibility-sensor-react-native/#0001-01-01</a></blockquote><div><article class="article-post">
<p>这篇文章是关于如何在React本地应用程序中实现组件的可见性传感器。在垂直或水平<code><a href="https://reactnative.dev/docs/flatlist" target="_blank" rel="noopener">FlatList</a></code>及其<a href="https://reactnative.dev/docs/flatlist#onviewableitemschanged" target="_blank" rel="noopener">道具</a>的帮助下，无论何时列表项在视窗中出现或消失，都可以观察事件。使用这个概念，您可以对这些事件做出反应，例如，开始自动播放视频或出于营销目的跟踪“组件可见事件”。</p>
<p>在本帖中，我们将讨论如何使用一个示例项目在React Native中实现组件可见性传感器，并通过以下部分逐步构建解决方案:</p>

<p>每个“临时解决方案”都包含对解决方案不完整的原因的解释(即，由于React本机渲染错误，正如您将看到的)。我想解释事物不工作的不同原因；在我们的<code>FlatList</code>回调的限制(必须是稳定的)和这些如何反应记忆挂钩(<code>useCallback</code>、<code>useEffect</code>等)之间存在相互作用。)工作。</p>
<h2 id="scope-example-project">示例项目的范围</h2>
<p>本文给出的代码示例是GitHub伙伴项目的一部分。这是一个使用打字稿的<a href="https://expo.dev/" target="_blank" rel="noopener">世博项目</a>，用<a href="https://docs.expo.dev/get-started/create-a-new-app/" target="_blank" rel="noopener"> create-expo-app </a>搭建。</p>
<p>演示用例有意保持简单，只关注使用<code>FlatList</code> API。它显示《星球大战》中的角色，并追踪那些出现在屏幕上的角色至少两秒钟。如果它们出现多次，将只被跟踪一次。因此，示例应用程序并没有在可见性事件上展示花哨的动画，因为这超出了范围。</p>
<p>相比之下，当<code>FlatList</code>触发可见性变化事件时调用的逻辑只是一个跟踪功能，以保持简单。这与在常见的业务应用程序中跟踪用户事件是一致的。</p>
<p>下面的截屏展示了示例应用程序。</p>
<p><img data-attachment-id="129482" data-permalink="https://blog.logrocket.com/implementing-component-visibility-sensor-react-native/attachment/example-visibility-sensor-app/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/08/example-visibility-sensor-app.gif" data-orig-size="730,794" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="example-visibility-sensor-app" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/08/example-visibility-sensor-app-276x300.gif" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/08/example-visibility-sensor-app.gif" decoding="async" class="aligncenter size-full wp-image-129482 jetpack-lazy-image" src="../Images/3b983f6fce4f9dac31881af8aeff8a17.png" alt="Our example app with a visibility sensor" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2022/08/example-visibility-sensor-app.gif?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/08/example-visibility-sensor-app.gif"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="129482" data-permalink="https://blog.logrocket.com/implementing-component-visibility-sensor-react-native/attachment/example-visibility-sensor-app/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/08/example-visibility-sensor-app.gif" data-orig-size="730,794" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="example-visibility-sensor-app" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/08/example-visibility-sensor-app-276x300.gif" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/08/example-visibility-sensor-app.gif" decoding="async" loading="lazy" class="aligncenter size-full wp-image-129482" src="../Images/3b983f6fce4f9dac31881af8aeff8a17.png" alt="Our example app with a visibility sensor" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/08/example-visibility-sensor-app.gif"/></noscript>
<h2 id="look-flatlists-api">看一看<code>FlatList</code>的API</h2>
<p>在我深入到示例项目的实现细节之前，让我们看一下实现列表项可见性检测器的关键<a href="https://github.com/facebook/react-native/blob/main/Libraries/Lists/FlatList.js" target="_blank" rel="noopener"> <code>FlatList</code>道具</a>。</p>
<p>原则上，你必须使用两个<code>FlatList</code>道具:</p>

<p>通过<code>viewabilityConfig</code>，你可以决定“可视”对你的应用意味着什么。我最常用的配置是检测在最短时间(<code>y</code>毫秒)内至少有<code>x</code>个百分比可见的列表项。</p>
<pre class="language-javascript hljs">viewabilityConfig={{
  itemVisiblePercentThreshold: 75,
  minimumViewTime: 2000,
}}
</pre>
<p>在这个示例配置中，当列表项在至少<code>2</code>秒内至少有<code>75</code>个百分比在视口内时，它们被认为是可见的。</p>
<p>看看<a href="https://github.com/facebook/react-native/blob/main/Libraries/Lists/ViewabilityHelper.js#L34" target="_blank" rel="noopener"> <code>ViewabilityHelper</code> </a>的<code>ViewabilityConfig</code>部分，找出其他有效的设置，以及它们的类型定义。</p>
<p>您需要另一个<code>FlatList</code>属性<code>onViewableItemsChanged</code>，根据我们的<code>viewabilityConfig</code>类型定义的设置，每当列表项的可见性改变时，就会调用这个属性。</p>
<pre class="language-javascript hljs">// ...
  &lt;FlatList
      data={listItems}
      renderItem={renderItem}
      onViewableItemsChanged={info =&gt; {
        // access info and do sth with viewable items
      })}
      viewabilityConfig={{
        itemVisiblePercentThreshold: 100,
        minimumViewTime: 2000,
      }}
      // ...
  /&gt;
  // ...
</pre>
<p>让我们仔细看看<a href="https://github.com/facebook/react-native/blob/main/Libraries/Lists/VirtualizedList.js" target="_blank" rel="noopener"> <code>onViewabilityItemsChanged</code> </a>的签名，定义在<code>VirtualizedList</code>中，是<code>FlatList</code>内部使用的。<code>info</code>参数有以下<a href="https://github.com/facebook/react-native/blob/main/Libraries/Lists/VirtualizedList.js#L247" target="_blank" rel="noopener">流程类型定义</a>:</p>
<pre class="language-javascript hljs">// flow definition part of VirtualizedList.js

onViewableItemsChanged?: ?(info: {
    viewableItems: Array&lt;ViewToken&gt;,
    changed: Array&lt;ViewToken&gt;,
    ...
  }) =&gt; void
</pre>
<p>一个<a href="https://github.com/facebook/react-native/blob/main/Libraries/Lists/ViewabilityHelper.js#L15" target="_blank" rel="noopener"> <code>ViewToken</code>对象</a>保存了关于列表项可见性状态的信息。</p>
<pre class="language-javascript hljs">// flow definition part of ViewabilityHelper.js

type ViewToken = {
  item: any,
  key: string,
  index: ?number,
  isViewable: boolean,
  section?: any,
  ...
};
</pre>
<p>我们如何利用这一点？让我们看看下一个TypeScript片段。</p>
<pre class="language-typescript hljs">const onViewableItemsChanged = (info: { viewableItems: ViewToken[]; changed: ViewToken[] }): void =&gt; {      
      const visibleItems = info.changed.filter((entry) =&gt; entry.isViewable);
      visibleItems.forEach((visible) =&gt; console.log(visible.item));
  }  
</pre>
<p>在这个例子中，我们只对可以用<code>info.changed</code>访问的已更改的<code>ViewToken</code>感兴趣。这里，我们想要记录符合<code>viewabilityConfig</code>标准的列表项。从<code>ViewToken</code>定义中可以看出，实际的列表项存储在<code>item</code>中。</p>
<h3><code>viewableItems</code>和<code>changed</code>有什么区别？</h3>
<p>在<code>viewabilityConfig</code>调用<code>onViewableItemsChanged</code>后，<code>viewableItems</code>存储每一个符合我们<code>viewabilityConfig</code>标准的列表项。然而，<code>changed</code>只保存最后一次<code>onViewableItemsChanged</code>调用的增量(即最后一次迭代)。</p>
<p>如果你必须对200毫秒内可见的列表项和500毫秒内可见的列表项做不同的事情，你可以使用<code>FlatList</code>的<a href="https://reactnative.dev/docs/flatlist#viewabilityconfigcallbackpairs" target="_blank" rel="noopener"> <code>viewabilityConfigCallbackPairs</code> prop </a>，它接受一个<code>ViewabilityConfigCallbackPair</code>对象的数组。</p>
<p>这是<code>viewabilityConfigCallbackPairs</code>的流类型定义，是<a href="https://github.com/facebook/react-native/blob/main/Libraries/Lists/VirtualizedList.js#L290" target="_blank" rel="noopener"> <code>VirtualizedList</code> </a>的一部分。</p>
<pre class="language-javascript hljs">// VirtualizedList.js

  viewabilityConfigCallbackPairs?: Array&lt;ViewabilityConfigCallbackPair&gt;
</pre>
<p><code>ViewabilityConfigCallbackPair</code>的流类型定义是<a href="https://github.com/facebook/react-native/blob/main/Libraries/Lists/ViewabilityHelper.js#L24" target="_blank" rel="noopener"> <code>ViewabilityHelper</code> </a>的一部分。</p>
<pre class="language-javascript hljs">// ViewabilityHelper.js
export type ViewabilityConfigCallbackPair = {
  viewabilityConfig: ViewabilityConfig,
  onViewableItemsChanged: (info: {
    viewableItems: Array&lt;ViewToken&gt;,
    changed: Array&lt;ViewToken&gt;,
    ...
  }) =&gt; void,
  ...
};
</pre>
<p>这里有一个例子:</p>
<pre class="language-javascript hljs">&lt;FlatList
    data={listItems}
    renderItem={renderItem}
    viewabilityConfigCallbackPairs={[
      {
        viewabilityConfig: {
          minimumViewTime: 200,
          itemVisiblePercentThreshold: 100,
        },
        onViewableItemsChanged: onViewableItemsChanged100
      },
      {
        viewabilityConfig: {
          minimumViewTime: 500,
          itemVisiblePercentThreshold: 75
        },
        onViewableItemsChanged: onViewableItemsChanged75
      }
    ]}
    // ...
/&gt;
</pre>
<p>如果你对列表项检测算法的实现细节感兴趣，可以<a href="https://suelan.github.io/2020/01/21/onViewableItemsChanged/#How-does-onViewableItemsChanged-works" target="_blank" rel="noopener">在这里</a>了解一下。</p>
<h2 id="flatlist-api-distilled"><code>FlatList</code>的API蒸馏(<code>onViewableItemsChanged</code>，<code>viewabilityConfig</code>)</h2>
<p>根据我们目前对相关API部分的了解，创建一个可见性传感器似乎很简单。然而，传递给<code>onViewableItemsChanged</code> prop的函数的实现涉及到一些陷阱。</p>
<p>因此，我将把不同的版本作为例子，直到我们得到最终的解决方案。由于<code>FlatList</code> API的实现方式和React的工作方式，每个中间解决方案都有缺陷。</p>
<p>我们将讨论两种不同的用例。第一个是一个简单的例子，每当一个列表元素出现在屏幕上时触发一个事件。第二个到第四个更复杂的例子是在彼此的基础上构建的，用来演示当一个列表项在视图中时如何触发事件，但是只触发一次。</p>
<p>我们正在讨论第二个用例，因为它需要管理状态，这也是这个<code>FlatList</code>呈现错误的丑陋之处。</p>
<p>以下是我们将尝试的解决方案，以及每种方案的缺点:</p>
<ol>
<li>跟踪每一次<em>星球大战</em>人物(即列表元素)出现在屏幕上</li>
<li>通过引入状态，每个字符只跟踪一次</li>
<li>尝试修复导致陈旧闭包问题的<code>useCallback</code>解决方案(参见配套项目<a href="https://github.com/doppelmutzi/companion-project-rn-visibility-sensor/tree/stale-closure" target="_blank" rel="noopener">分支陈旧闭包</a></li>
<li>通过使用状态更新函数访问先前的状态来解决问题(参见配套项目<a href="https://github.com/doppelmutzi/companion-project-rn-visibility-sensor/tree/master" target="_blank" rel="noopener">分支主管</a></li>
</ol>
<h2 id="interim-solution-1-track-every-time-list-element-appears-screen">临时解决方案1:每次列表元素出现在屏幕上时进行跟踪</h2>
<p>这个<code>onViewableItemsChanged</code>的第一个实现跟踪每一个可见的项目，无论它何时出现在屏幕上。</p>
<pre class="language-javascript hljs">const trackItem = (item: StarWarsCharacter) =&gt;
    console.log("### track " + item.name);
const onViewableItemsChanged =
  (info: { changed: ViewToken[] }): void =&gt; {
    const visibleItems = info.changed.filter((entry) =&gt; entry.isViewable);
    visibleItems.forEach((visible) =&gt; {
      trackItem(visible.item);
    });
  };
</pre>
<p>我们使用传递给函数的<code>info</code>参数的<code>changed</code>对象。我们遍历这个<code>ViewToken</code>数组，只将当前在屏幕上可见的列表项存储在<code>visibleItems</code>变量中。然后，我们只需调用简化的<code>trackItem</code>函数，通过将列表项的名称打印到控制台来模拟跟踪调用。</p>
<p>这应该可以，对吧？不幸的是，没有。我们得到一个渲染错误。</p>
<p><img data-attachment-id="129484" data-permalink="https://blog.logrocket.com/implementing-component-visibility-sensor-react-native/attachment/render-error-when-function-created-multiple-times/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/08/render-error-when-function-created-multiple-times.png" data-orig-size="730,935" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="render-error-when-function-created-multiple-times" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/08/render-error-when-function-created-multiple-times-234x300.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/08/render-error-when-function-created-multiple-times.png" decoding="async" class="aligncenter size-full wp-image-129484 jetpack-lazy-image" src="../Images/6ff06671dd1368b43f688a2b7c3d5746.png" alt="Render error whenever the function is created multiple times" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2022/08/render-error-when-function-created-multiple-times.png 730w, https://blog.logrocket.com/wp-content/uploads/2022/08/render-error-when-function-created-multiple-times-234x300.png 234w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2022/08/render-error-when-function-created-multiple-times.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/08/render-error-when-function-created-multiple-times.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="129484" data-permalink="https://blog.logrocket.com/implementing-component-visibility-sensor-react-native/attachment/render-error-when-function-created-multiple-times/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/08/render-error-when-function-created-multiple-times.png" data-orig-size="730,935" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="render-error-when-function-created-multiple-times" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/08/render-error-when-function-created-multiple-times-234x300.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/08/render-error-when-function-created-multiple-times.png" decoding="async" loading="lazy" class="aligncenter size-full wp-image-129484" src="../Images/6ff06671dd1368b43f688a2b7c3d5746.png" alt="Render error whenever the function is created multiple times" srcset="https://blog.logrocket.com/wp-content/uploads/2022/08/render-error-when-function-created-multiple-times.png 730w, https://blog.logrocket.com/wp-content/uploads/2022/08/render-error-when-function-created-multiple-times-234x300.png 234w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/08/render-error-when-function-created-multiple-times.png"/></noscript>
<p><code>FlatList</code> <a href="https://github.com/facebook/react-native/issues/30171">的实现不允许传递给<code>onViewableItemsChanged</code>属性的函数的</a>在应用程序的生命周期中被重新创建。</p>
<p>为了解决这个问题，我们必须确保函数在最初创建后不会改变；它需要在渲染周期中保持稳定。</p>
<p>我们如何做到这一点？我们可以使用<a href="https://reactjs.org/docs/hooks-reference.html#usecallback" target="_blank" rel="noopener"> <code>useCallback</code>挂钩</a>。</p>
<pre class="language-javascript hljs">const onViewableItemsChanged = useCallback(
    (info: { changed: ViewToken[] }): void =&gt; {
      const visibleItems = info.changed.filter((entry) =&gt; entry.isViewable);
      visibleItems.forEach((visible) =&gt; {
        trackItem(visible.item);
      });
    },
    []
  );
</pre>
<p>有了<code>useCallback</code>,我们的函数被记忆，并且不会被重新创建，因为没有可以改变的依赖关系。渲染问题消失，跟踪按预期工作。</p>
<p><img data-attachment-id="129486" data-permalink="https://blog.logrocket.com/implementing-component-visibility-sensor-react-native/attachment/track-character-every-time-appear-screen/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/08/track-character-every-time-appear-screen.png" data-orig-size="730,671" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="track-character-every-time-appear-screen" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/08/track-character-every-time-appear-screen-300x276.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/08/track-character-every-time-appear-screen.png" decoding="async" class="aligncenter wp-image-129486 size-full jetpack-lazy-image" src="../Images/4794ee70dfa3a9e4e585a928280ae71c.png" alt="Track a character every time they appear on screen" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2022/08/track-character-every-time-appear-screen.png 730w, https://blog.logrocket.com/wp-content/uploads/2022/08/track-character-every-time-appear-screen-300x276.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2022/08/track-character-every-time-appear-screen.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/08/track-character-every-time-appear-screen.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="129486" data-permalink="https://blog.logrocket.com/implementing-component-visibility-sensor-react-native/attachment/track-character-every-time-appear-screen/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/08/track-character-every-time-appear-screen.png" data-orig-size="730,671" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="track-character-every-time-appear-screen" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/08/track-character-every-time-appear-screen-300x276.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/08/track-character-every-time-appear-screen.png" decoding="async" loading="lazy" class="aligncenter wp-image-129486 size-full" src="../Images/4794ee70dfa3a9e4e585a928280ae71c.png" alt="Track a character every time they appear on screen" srcset="https://blog.logrocket.com/wp-content/uploads/2022/08/track-character-every-time-appear-screen.png 730w, https://blog.logrocket.com/wp-content/uploads/2022/08/track-character-every-time-appear-screen-300x276.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/08/track-character-every-time-appear-screen.png"/></noscript>
<h2 id="interim-solution-2-track-list-element-once-introducing-state">临时解决方案2:通过引入状态只跟踪一次列表元素</h2>
<p>接下来，我们想跟踪每个星球大战角色一次。因此，我们可以引入一个反应状态<code>alreadySeen</code>，来跟踪用户已经看到的字符。</p>
<p>如您所见，<code>useState</code>钩子存储了一个<code>SeenItem</code>数组。传递给<code>onViewableItemsChanged</code>的函数被包装到一个<code>useCallback</code>钩子中，并带有一个依赖项<code>alreadySeen</code>。这是因为我们使用这个状态变量来计算传递给<code>setAlreadySeen</code>的下一个状态。</p>
<pre class="language-typescript hljs">// TypeScript definitions
interface StarWarsCharacter {
  name: string;
  picture: string;
}
type SeenItem = {
  [key: string]: StarWarsCharacter;
};
interface ListViewProps {
  characters: StarWarsCharacter[];
}
export function ListView({
  characters,
}: ListViewProps) {
const [alreadySeen, setAlreadySeen] = useState&lt;SeenItem[]&gt;([]);
const onViewableItemsChanged = useCallback(
    (info: { changed: ViewToken[] }): void =&gt; {
      const visibleItems = info.changed.filter((entry) =&gt; entry.isViewable);
      // perform side effect
      visibleItems.forEach((visible) =&gt; {
        const exists = alreadySeen.find((prev) =&gt; visible.item.name in prev);
        if (!exists) trackItem(visible.item);
      });
      // calculate new state
      setAlreadySeen([
        ...alreadySeen,
        ...visibleItems.map((visible) =&gt; ({
          [visible.item.name]: visible.item,
        })),
      ]);
    },
    [alreadySeen]
  );
  // return JSX
}
</pre>
<p>同样，我们有一个问题。由于依赖关系<code>alreadySeen</code>，函数被创建了不止一次，因此，我们再次为我们的渲染错误感到高兴。</p>
<p>我们<em>可以</em>通过用ESLint <code>ignore</code>注释省略依赖性来消除渲染错误。</p>
<pre class="language-javascript hljs">const onViewableItemsChanged = useCallback(
    (info: { changed: ViewToken[] }): void =&gt; {
        // ...
    },
    // bad fix
    // eslint-disable-next-line react-hooks/exhaustive-deps
    []
  );
</pre>
<p>但是，正如我在关于<code>useEffect</code>钩子的文章中指出的，你永远不应该省略钩子内部使用的依赖。ESLint react-hooks插件告诉你缺少依赖是有原因的。</p>
<p>在我们的例子中，我们得到了一个<a href="https://dmitripavlutin.com/react-hooks-stale-closures/" target="_blank " rel="noopener">陈旧闭包</a>问题，我们的<code>alreadySeen</code>状态变量不再更新。该值仍然是初始值，是一个空数组。</p>
<p><img data-attachment-id="129488" data-permalink="https://blog.logrocket.com/implementing-component-visibility-sensor-react-native/attachment/initial-value-array-does-not-get-updated/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/08/initial-value-array-does-not-get-updated.gif" data-orig-size="730,732" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="initial-value-array-does-not-get-updated" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/08/initial-value-array-does-not-get-updated-300x300.gif" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/08/initial-value-array-does-not-get-updated.gif" decoding="async" class="aligncenter size-full wp-image-129488 jetpack-lazy-image" src="../Images/6d1c7bee885f68d8f71f73fd5a880e12.png" alt="The initial value of the array does not get updated" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2022/08/initial-value-array-does-not-get-updated.gif?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/08/initial-value-array-does-not-get-updated.gif"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="129488" data-permalink="https://blog.logrocket.com/implementing-component-visibility-sensor-react-native/attachment/initial-value-array-does-not-get-updated/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/08/initial-value-array-does-not-get-updated.gif" data-orig-size="730,732" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="initial-value-array-does-not-get-updated" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/08/initial-value-array-does-not-get-updated-300x300.gif" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/08/initial-value-array-does-not-get-updated.gif" decoding="async" loading="lazy" class="aligncenter size-full wp-image-129488" src="../Images/6d1c7bee885f68d8f71f73fd5a880e12.png" alt="The initial value of the array does not get updated" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/08/initial-value-array-does-not-get-updated.gif"/></noscript>
<p>但是如果我们按照ESLint插件告诉我们的去做，我们又会遇到烦人的渲染错误。我们走进了死胡同。</p>
<p>不知何故，由于<code>FlatList</code>实现的限制，我们需要找到一个具有空依赖数组的解决方案。</p>
<h2 id="interim-solution-3-try-fix-stale-closure-issue-return-empty-dependency-array">临时解决方案3:尝试修复陈旧的闭包问题，并返回到一个空的依赖数组</h2>
<p>我们如何回到一个空的依赖数组？我们可以使用state updater函数，它可以接受一个带有前一状态的函数作为参数。你可以在我的关于<code>useState</code>和<code>useRef</code>的区别的<a href="https://blog.logrocket.com/usestate-vs-useref/" target="_blank " rel="noopener">日志文章</a>中找到更多关于状态更新函数的信息。</p>
<pre class="language-javascript hljs">  const onViewableItemsChanged = useCallback(
    (info: { changed: ViewToken[] }): void =&gt; {
      const visibleItems = info.changed.filter((entry) =&gt; entry.isViewable);
      setAlreadySeen((prevState: SeenItem[]) =&gt; {
        // perform side effect
        visibleItems.forEach((visible) =&gt; {
          const exists = prevState.find((prev) =&gt; visible.item.name in prev);
          if (!exists) trackItem(visible.item);
        });
        // calculate new state
        return [
          ...prevState,
          ...visibleItems.map((visible) =&gt; ({
            [visible.item.name]: visible.item,
          })),
        ];
      });
    },
    []
  );
</pre>
<p>它们之间的主要区别是状态更新函数可以访问以前的状态，因此，我们不必直接访问状态变量<code>alreadySeen</code>。这样，我们就有了一个空的依赖数组，函数就像预期的那样工作(参见上一节中关于配套项目的截屏)。</p>
<p>下一节将进一步讨论呈现错误和陈旧闭包问题。</p>
<h2 id="close-look-problem-with-onviewableitemschanged">用<code>onViewableItemsChanged</code>仔细看看这个问题</h2>
<p>React的记忆挂钩，比如<code>useEffect</code>和<code>useCallback</code>，是以这样一种方式构建的，即每个组件上下文变量都被添加到依赖数组中。这样做的原因是，只有当这些依赖关系中至少有一个相对于上次运行发生了变化时，才会调用挂钩。</p>
<p>为了帮助你完成这个麻烦且容易出错的任务，React团队已经构建了一个ESLint插件。然而，即使你知道依赖关系在运行时不会再改变，作为一个好的开发人员，你也必须将它添加到依赖数组中。插件作者知道，例如，状态更新器函数是稳定的，所以插件在数组中不需要它，这与其他(非纯)函数不同。</p>
<p>如果您从自定义钩子返回这样一个状态更新函数，并在React组件中使用它，插件会错误地声明将它添加为依赖项。在这种情况下，您必须添加一个ESLint <code>disable</code>注释来屏蔽插件(或者接受警告)。</p>
<p>然而，这是不好的做法。尽管将它添加到依赖数组应该不成问题，但是钩子的使用变得更加健壮，因为这个变量可能会随着时间而改变，例如在重构之后。如果它给你制造了一个问题，你很可能在你的项目中有一个bug。</p>
<p>来自<code>FlatList</code>的这个<code>onViewableItemsChanged</code>属性的问题是，您根本不能向依赖数组添加任何依赖。这是<code>FlatList</code>实现的一个限制，与内存化钩子的概念相矛盾。</p>
<p>因此，你必须找到一个解决方案来摆脱依赖。您很可能想要使用我上面描述的方法，使用一个状态更新函数，该函数接受一个回调函数来访问以前的状态。</p>
<p>如果您想要重构<code>onViewableItemsChanged</code>函数的实现——通过将它放入一个自定义钩子中来降低复杂性或提高可测试性——就不可能防止依赖。目前还没有办法告诉React定制钩子像内置的<code>useRef</code>钩子或者状态更新函数那样返回一个稳定的依赖关系。</p>
<p>在我目前工作的项目中，我选择添加一个ESLint <code>disable</code>注释，因为我知道来自我的自定义钩子的依赖性是稳定的。此外，您可以忽略作为定制挂钩结果的<a href="https://www.geeksforgeeks.org/pure-functions-in-javascript/" target="_blank " rel="noopener">纯函数</a>，或者从另一个文件导入它们，因为它们本身不使用任何依赖关系。</p>
<pre class="language-javascript hljs">useCallback(
    () =&gt; {
      /* 
        Uses state updater functions from a custom hook or imported pure functions.
        The ESLint plugin does not know that the functions are stable / do not use any dependencies. It does not know that they can be omitted from the array list.
      /*      
    }, 
    // eslint-disable-next-line react-hooks/exhaustive-deps
    []
)
</pre>
<p>过去已经有<a href="https://github.com/facebook/react/issues/22539" target="_blank " rel="noopener">多次</a> <a href="https://github.com/facebook/react/issues/16873" target="_blank " rel="noopener">讨论</a> <a href="https://github.com/facebook/react/pull/20513" target="_blank " rel="noopener">关于将自定义钩子的返回值标记为稳定，但是还没有官方的解决方案。</a></p>
<h2>摘要</h2>
<p><code>FlatList</code>的<code>onViewableItemsChanged</code> API提供了检测屏幕上出现或消失的组件的能力。一个<code>FlatList</code>可以垂直和水平使用。因此，这可以在大多数用例中使用，因为屏幕组件通常组织在一个列表中。</p>
<p>这种方法的问题是，首先，视口检测逻辑的实现是有限的、乏味的，并且容易出错。这是因为被分配的函数在初始创建后不得重新创建。这意味着你根本不能依赖任何依赖！否则，您会得到一个渲染错误。</p>
<p>总而言之，您可以选择以下方法来解决这个问题:</p>
<ul>
<li>用一个空的依赖数组将分配给<code>onViewableItemsChanged</code>的函数包装到一个<code>useCallback</code>钩子中</li>
<li>如果您在函数中使用一个或多个组件状态变量，那么您必须使用状态更新器函数，该函数接受一个可以访问先前状态的回调，这样您就可以摆脱状态依赖</li>
<li>如果你依赖一个状态更新函数或者来自另一个文件的纯函数(比如一个导入的或者定制的钩子)，你可以保留空的依赖数组，忽略ESLint插件的警告</li>
<li>如果您依赖于任何其他依赖项(例如，属性、上下文、自定义钩子的状态变量等)。)，你必须找到一个不使用它们的解决方案</li>
</ul>
<p>如果你想在可见性改变事件上执行复杂的任务，你必须设计你的事件，用状态更新函数更新你的状态变量，为<code>useCallback</code>钩子保留一个空的依赖数组。然后，您可以响应状态变化，例如用一个<code>useEffect</code>钩子，来执行依赖于依赖关系的逻辑。这样的场景可能会变得复杂，但是使用我们在这里讨论的变通方法，您应该可以更容易地找到并实现适合您的解决方案。</p><div class="code-block code-block-18">
<div class="blog-plug inline-plug react-native-plug"><h2><a href="https://lp.logrocket.com/blg/react-native-signup"> LogRocket </a>:即时重现React原生应用中的问题。</h2><a class="signup" href="https://lp.logrocket.com/blg/react-native-signup" target="_blank" rel="noopener noreferrer"><img class="alignnone size-full wp-image-46 jetpack-lazy-image" src="../Images/110055665562c1e02069b3698e6cc671.png" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2021/10/react-native-plug_v2-2.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2021/10/react-native-plug_v2-2.png"/><noscript><img data-lazy-fallback="1" class="alignnone size-full wp-image-46" src="../Images/110055665562c1e02069b3698e6cc671.png" data-original-src="https://blog.logrocket.com/wp-content/uploads/2021/10/react-native-plug_v2-2.png"/></noscript></a><p><a href="https://lp.logrocket.com/blg/react-native-signup" target="_blank" rel="noopener noreferrer"> LogRocket </a>是一款React原生监控解决方案，可帮助您即时重现问题、确定bug的优先级并了解React原生应用的性能。</p><p>LogRocket还可以向你展示用户是如何与你的应用程序互动的，从而帮助你提高转化率和产品使用率。LogRocket的产品分析功能揭示了用户不完成特定流程或不采用新功能的原因。</p><p>开始主动监控您的React原生应用— <a class="signup" href="https://lp.logrocket.com/blg/react-native-signup" target="_blank" rel="noopener noreferrer">免费试用LogRocket】。</a></p></div>
</div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
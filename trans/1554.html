<html>
<head>
<title>What you need to know about React Server Components - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>关于 React 服务器组件你需要知道什么</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/what-you-need-to-know-about-react-server-components/#0001-01-01">https://blog.logrocket.com/what-you-need-to-know-about-react-server-components/#0001-01-01</a></blockquote><div><article class="article-post">
<p>现代应用程序需要大量的时间来研究、设计、开发和测试。有很多不同的技术可以用来构建现代应用程序，每种技术都是为了解决特定的问题，每种技术都有其优缺点。构建现代应用程序没有灵丹妙药。</p>
<p>当使用 React 时，我们可以说出一些现在使用的不同技术，但最常用的是服务器端渲染和客户端渲染。这两种技术都解决了特定的问题，是开发人员构建丰富的现代应用程序时最常用的技术。</p>
<p>2020 年底，React 团队提出了一个名为<a href="https://reactjs.org/blog/2020/12/21/data-fetching-with-react-server-components.html" target="_blank" rel="noopener"> React 服务器组件</a>的 React 新功能。从那时起，React 社区开始讨论这种构建 React 应用程序的新方法的利弊，以及它如何影响 React 应用程序的未来。</p>
<p>我们将讨论 React 服务器组件，以及它们将如何改变 React 应用程序的现代构建方式。</p>
<h2>React 服务器组件</h2>
<p>在了解更多关于 React 服务器组件的信息之前，请记住它仍处于开发阶段，不建议用于生产。</p>
<p>来自<a href="https://github.com/reactjs/rfcs/pull/188" target="_blank" rel="noopener"> React 团队</a>:</p>
<blockquote><p>服务器组件允许开发人员构建跨服务器和客户端的应用程序，将客户端应用程序的丰富交互性与传统服务器渲染的改进性能相结合。</p></blockquote>
<p><a href="https://reactjs.org/blog/2020/12/21/data-fetching-with-react-server-components.html" target="_blank" rel="noopener"> React 服务器组件</a>对捆绑包大小没有任何影响，它可能会改变我们构建 React 应用的方式。这不仅会减少包本身的大小，还会改善初始页面加载时间。</p>
<p><a href="https://reactjs.org/blog/2020/12/21/data-fetching-with-react-server-components.html" target="_blank" rel="noopener"> React 服务器组件</a>在服务器上呈现，并且只有呈现的内容被发送到客户端:</p>
<pre>import db from "database";

const Comment = (props) =&gt; {
  const { id } = props;
  const comment = db.comments.get(id);
  return (
    &lt;div&gt;
      &lt;h1&gt;{comment.title}&lt;/h1&gt;
      &lt;p&gt;{comment.text}&lt;/p&gt;
    &lt;/div&gt;
  );
};
</pre>
<p>React 服务器组件看起来像一个传统的 React 组件，它接受 props 并有一个 render 方法。它只有一些附加功能，例如:</p>
<ul>
<li>他们可以直接访问服务器数据源，如微服务、函数、数据库等。这种能力带来的可能性是巨大的，我们将能够创建与各种数据源一起工作的内部 API，我们可以访问我们组件内部的服务器，而不必将它直接暴露给 API。</li>
<li>它们是按照一个有效的命名约定创建的，在组件名称后使用<code>.server.js</code>后缀。例如，如果你的组件将被命名为<code>note.js</code>，那么它必须被命名为<code>note.server.js</code>。客户端组件将分别按照组件名称后使用<code>.client.js</code>后缀的命名约定创建。</li>
</ul>
<p>React 服务器组件并不能解决我们现在面临的所有问题。以下是 React 服务器组件不具备的一些功能:</p>
<ul>
<li>React 服务器组件不能有状态，因为它们对每个请求只执行一次，所以不支持使用 React 钩子来处理状态数据，比如<code>useState</code>和<code>useReducer</code></li>
<li>React 服务器组件不能使用 React 挂钩来呈现生命周期方法，如<code>useEffect</code>和<code>useLayoutEffect</code></li>
<li>React 服务器组件不能使用浏览器专用的 API</li>
</ul>
<p>我们可以创建 React 组件和钩子，既可以用在我们的服务器组件上，也可以用在客户机组件上。钩子是在组件之间共享逻辑的一种非常简单而强大的方式，我们仍然可以在服务器组件中使用它。</p>
<p>我们应该确保遵守所有的约束条件，包括:</p>
<ul>
<li>我们<strong>不能</strong>使用像 useState 或 useReducer 这样的钩子来利用状态逻辑</li>
<li>我们<strong>不能</strong>使用服务器端数据源</li>
<li>我们<strong>不能</strong>使用依赖于状态、效果或浏览器专用 API 的定制钩子</li>
</ul>
<p>在遵循了所有的约束之后，我们可以创建在服务器端和客户端都可以使用的组件和钩子。</p>
<p>传统的 React 组件被称为客户端组件，因为它是在客户端呈现的。客户端组件是您所熟悉的组件，它可以处理状态数据，可以与仅支持浏览器的 API 一起工作，等等。</p>
<p>React 服务器组件可以呈现服务器组件、本机 HTML 元素或客户端组件。假设我们有一个名为<code>CommentLikeButton</code>的组件，它是一个客户端组件，我们可以简单地将它导入到我们的服务器组件中，然后毫无问题地使用它:</p>
<pre>import db from "database";
import CommentLikeButton from 'CommentLikeButton.client';

const Comment = (props) =&gt; {
  const { id } = props;
  const comment = db.comments.get(id);
  return (
    &lt;div&gt;
      &lt;h1&gt;{comment.title}&lt;/h1&gt;
      &lt;section&gt;{comment.body}&lt;/section&gt;
      &lt;CommentLikeButton /&gt;
    &lt;/div&gt;
  );
};
</pre>
<h2>RSC 与。战略科研署</h2>
<p>服务器端渲染是一种在服务器端渲染应用程序的技术，将 HTML 发送到客户端，然后由浏览器渲染 HTML。这是服务器端渲染应用的两个最重要的优势之一:</p>
<ul>
<li><strong>性能— </strong>客户端收到的 HTML 文件已经填充了内容并准备好呈现，因此浏览器不需要获取任何 JavaScript</li>
<li><strong> SEO — </strong>由于 JavaScript 通常需要搜索引擎花费更多时间来渲染应用程序，因此 SEO 性能得以提高。因为客户机需要的所有内容都在服务器上呈现，所以文件将准备好呈现，从而产生更好的排序搜索</li>
</ul>
<p>服务器组件是在服务器端呈现的组件，但不是 HTML。服务器组件使用一种特殊的格式呈现，并传输到客户端。这是 React 服务器组件的呈现方式:</p>
<p><img data-attachment-id="34016" data-permalink="https://blog.logrocket.com/what-you-need-to-know-about-react-server-components/react-server-component-render/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2021/02/react-server-component-render.png" data-orig-size="730,122" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="React server component render" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2021/02/react-server-component-render-300x50.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2021/02/react-server-component-render.png" decoding="async" class="aligncenter size-full wp-image-34016 jetpack-lazy-image" src="../Images/7785aacc56ed329fbafa153face7db75.png" alt="React Server Component Render" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2021/02/react-server-component-render.png 730w, https://blog.logrocket.com/wp-content/uploads/2021/02/react-server-component-render-300x50.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2021/02/react-server-component-render.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2021/02/react-server-component-render.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="34016" data-permalink="https://blog.logrocket.com/what-you-need-to-know-about-react-server-components/react-server-component-render/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2021/02/react-server-component-render.png" data-orig-size="730,122" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="React server component render" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2021/02/react-server-component-render-300x50.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2021/02/react-server-component-render.png" decoding="async" loading="lazy" class="aligncenter size-full wp-image-34016" src="../Images/7785aacc56ed329fbafa153face7db75.png" alt="React Server Component Render" srcset="https://blog.logrocket.com/wp-content/uploads/2021/02/react-server-component-render.png 730w, https://blog.logrocket.com/wp-content/uploads/2021/02/react-server-component-render-300x50.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2021/02/react-server-component-render.png"/></noscript>
<p>React 服务器组件用于呈现组件的流目前没有标准协议，但看起来很像 JSON 格式。</p>
<p>尽管 React 服务器组件非常强大，但它们不会取代服务器端呈现的应用程序。我们需要辨别一些差异:</p>
<ul>
<li>React 服务器组件可以随时重新呈现，而 SSR 应用程序可以重新呈现，但它们将重新呈现一个全新的 HTML 页面，并丢失其应用程序状态(如果有的话)</li>
<li>React 服务器组件可以从树中的任何位置访问服务器数据源，如微服务、函数、数据库，而对于 SSR 应用程序，尤其是 Next，我们需要使用 getServerProps()，它只在页面的顶层工作</li>
</ul>
<p>大多数时候，当我们使用服务器端渲染时，我们只使用它一次进行初始渲染。可以多次重新提取服务器组件来重新呈现我们的数据。我们可以定期重新获取我们的服务器组件，服务器会将更新流传下来，而不会丢失我们的客户端组件上的任何状态数据。</p>
<h2>React 服务器组件的影响</h2>
<p>web 开发社区中发布的每一个新事物都可以改变我们正在构建的方式，并将在未来构建现代应用程序。开发人员总是在寻找新的技术来改进他们的应用程序，当然，React 服务器组件可能会带来一种构建现代应用程序的新方法。</p>
<p>我们知道 React 服务器组件不同于服务器端渲染应用程序，我们使用一种特殊的格式进行渲染，并且我们还可以根据需要多次重新提取组件以重新渲染数据。仅通过这两个特性，我们就可以很容易地改变我们构建 React 应用程序的整个方式。</p>
<p>使用 React 服务器组件，我们可以通过混合客户端和服务器端呈现的组件来构建现代应用程序，我们可以只使用 React 服务器组件呈现一小部分 UI 服务器端，而使用传统 React 组件呈现其他 UI 部分。</p>
<p>尽管 React Server Components 是一项新技术，但它有许多潜在的出色特性，这些特性无疑将改善未来构建现代应用程序的方式，例如零捆绑包大小、直接从服务器访问数据源、与客户端组件集成等。</p>
<h2>结论</h2>
<p>React 有许多不同的技术来构建现代应用程序，React 服务器组件是一种非常强大的技术，用于在服务器端呈现组件，并仅将内容发送给客户端。正如我们所看到的，服务器组件与服务器端呈现的应用还是有一点点不同，它有一些不同的功能。React 团队仍在研究和开发服务器组件，但我们可以预测 React 应用的未来非常光明，允许开发人员将服务器端渲染和客户端渲染的组件混合在一起，改善客户端体验和应用性能。</p><div class="code-block code-block-17">
<div class="blog-plug inline-plug react-plug" vwo-el-id="26283398190">
<h2 vwo-el-id="41600691720">使用 LogRocket 消除传统反应错误报告的噪音</h2>
<a href="https://lp.logrocket.com/blg/react-signup-issue-free" target="_blank" vwo-el-id="19356441070">LogRocket
</a><p>是一款 React analytics 解决方案，可保护您免受数百个误报错误警报的影响，只针对少数真正重要的项目。LogRocket 告诉您 React 应用程序中实际影响用户的最具影响力的 bug 和 UX 问题。</p><a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="19356441380">
<img class="first-react-image alignnone size-full wp-image-46 jetpack-lazy-image jetpack-lazy-image--handled" src="../Images/f300c244a1a1cf916df8b4cb02bec6c6.png" vwo-el-id="18272717540" data-lazy-loaded="1" data-original-src="https://files.readme.io/27c94e7-Image_2017-06-05_at_9.46.04_PM.png"/>
</a>
<a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="19356441690">
<img class="second-react-image alignnone size-full wp-image-46 jetpack-lazy-image jetpack-lazy-image--handled" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" vwo-el-id="30720362350" data-lazy-loaded="1" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/>
</a>
<a href="https://lp.logrocket.com/blg/react-signup-issue-free" target="_blank" rel="noopener noreferrer" vwo-el-id="35866400580">LogRocket
</a><p>自动聚合客户端错误、反应错误边界、还原状态、缓慢的组件加载时间、JS 异常、前端性能指标和用户交互。然后，LogRocket 使用机器学习来通知您影响大多数用户的最具影响力的问题，并提供您修复它所需的上下文。</p><p vwo-el-id="28675661060">关注重要的 React bug—<a class="signup" href="https://lp.logrocket.com/blg/react-signup-issue-free" target="_blank" rel="noopener noreferrer" vwo-el-id="40093418840">今天就试试 LogRocket】。</a></p>
</div></div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
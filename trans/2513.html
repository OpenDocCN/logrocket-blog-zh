<html>
<head>
<title>Improve modal management in React with nice-modal-react - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>使用 nice-modal-react - LogRocket 博客改进 React 中的模态管理</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/improve-modal-management-react-nice-modal-react/#0001-01-01">https://blog.logrocket.com/improve-modal-management-react-nice-modal-react/#0001-01-01</a></blockquote><div><article class="article-post">
<p>在信息时代，情态动词的使用可以显著提高网站和网络应用的 UX。我们在任何地方都能看到它们，从像使用模态创建新推文的 Twitter 这样的网站，到在几乎每个企业的后台运行的复杂管理系统。</p>
<p>模态的主要优点是它们独立于活动页面，这意味着它们可以用于添加、更新、删除或查看信息，它们易于打开和关闭，它们不需要更改当前的 URL，并且背景信息通常是完全或部分可见的。</p>
<p>在本教程中，我们将探索<a href="https://github.com/eBay/nice-modal-react" target="_blank" rel="noopener"> nice-modal-react </a>，这是由<a href="https://ebay.com" target="_blank" rel="noopener">易贝</a>的开发团队为<a href="https://reactjs.org" target="_blank" rel="noopener"> React </a>创建的一个有用的模态实用程序。在内部测试和使用该工具一年后，他们好心地让公众可以使用它。</p>
<p>我们还将构建一个演示应用程序，以在实践中应用所有已审查的功能。预计我们将能够使用模态来创建新数据，以及编辑和删除现有数据:</p>
<p><img data-attachment-id="84253" data-permalink="https://blog.logrocket.com/improve-modal-management-react-nice-modal-react/crud-notes/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/01/crud-notes.png" data-orig-size="730,300" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="CRUD notes" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/01/crud-notes-300x123.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/01/crud-notes.png" decoding="async" class="aligncenter size-full wp-image-84253 jetpack-lazy-image" src="../Images/34138d91e131702ed734be80b76825eb.png" alt="CRUD Notes" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2022/01/crud-notes.png 730w, https://blog.logrocket.com/wp-content/uploads/2022/01/crud-notes-300x123.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2022/01/crud-notes.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/01/crud-notes.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="84253" data-permalink="https://blog.logrocket.com/improve-modal-management-react-nice-modal-react/crud-notes/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/01/crud-notes.png" data-orig-size="730,300" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="CRUD notes" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/01/crud-notes-300x123.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/01/crud-notes.png" decoding="async" loading="lazy" class="aligncenter size-full wp-image-84253" src="../Images/34138d91e131702ed734be80b76825eb.png" alt="CRUD Notes" srcset="https://blog.logrocket.com/wp-content/uploads/2022/01/crud-notes.png 730w, https://blog.logrocket.com/wp-content/uploads/2022/01/crud-notes-300x123.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/01/crud-notes.png"/></noscript>
<p>作为参考，这里是最终项目的<a href="https://codesandbox.io/s/nice-modal-react-182gc" target="_blank" rel="noopener">源代码</a>。</p>
<h2>为什么要用 nice-modal-react？</h2>
<p><a href="https://github.com/eBay/nice-modal-react" target="_blank" rel="noopener"> nice-modal-react </a>包是一个用<a href="https://www.typescriptlang.org/" target="_blank" rel="noopener">类型脚本</a>编写的零依赖实用程序，它使用上下文来控制整个应用程序中模态的状态。</p>
<p>该工具的主要优点是基于承诺的模态处理。这意味着您可以使用 props 来更新状态，而不是使用 props 来与组件交互。</p>
<p>您可以轻松地在整个应用程序中导入模态<code>components</code>或使用组件的特定<code>id</code>，因此您根本不必导入组件。</p>
<p>关闭模态独立于代码的其余部分，因此您可以从组件本身关闭组件，无论它显示在应用程序中的什么位置。</p>
<p>理解<a href="https://github.com/eBay/nice-modal-react" target="_blank" rel="noopener"> nice-modal-react </a>不是模态组件本身是至关重要的。您需要自己创建实际的模型(或者使用 UI 库中的预建组件，如<a href="https://mui.com/" target="_blank" rel="noopener">材质 UI </a>、<a href="https://ant.design/" target="_blank" rel="noopener">蚂蚁设计</a>或<a href="https://chakra-ui.com/" target="_blank" rel="noopener">脉轮</a>)。</p>
<h2>初始化 React 应用程序</h2>
<p>我们将首先使用<a href="https://create-react-app.dev/" target="_blank" rel="noopener"> Create React app </a>创建一个 React App。在您的终端中运行以下命令:<code>npx create-react-app crud-notes</code>。</p>
<p>安装完成后，您将看到在当前工作目录中创建了一个新的项目文件夹。</p>
<p>接下来，通过运行<code>cd crud-notes</code>更改目录，然后通过运行<code>npm start</code>启动应用程序。该命令应该会打开您的默认浏览器并显示 React 应用程序。</p>
<p>如果没有自动打开，在浏览器的地址栏输入<code><a href="http://localhost:3000" rel="nofollow">http://localhost:3000</a></code>并执行。</p>
<p>回到项目中，导航到<code>src</code>文件夹，找到文件<code>App.js</code>、<code>App.css</code>、<code>index.js</code>，并删除其中的内容，因为我们将从头开始编写所有内容。</p>
<p>同样，将<code>App.css</code>重命名为<code>styles.css</code>并删除<code>index.css</code>文件。</p>
<p>在新重命名的<code>styles.css</code>文件中，包含以下样式规则:</p>
<pre>css
@import url("https://fonts.googleapis.com/css2?family=Montserrat&amp;display=swap");

* {
  margin: 0;
  padding: 0;
  box-sizing: border-box;
  font-family: "Montserrat", sans-serif;
}

body {
  padding: 20px;
}

.App {
  max-width: 500px;
  margin: 0 auto;
  text-align: center;
}</pre>
<p>首先，我们为<code>margin</code>、<code>padding</code>和<code>border-box</code>声明了一些重置规则，因此所有的元素在所有的浏览器中都是同等显示的。我们还确保应用程序使用蒙特塞拉特岛字体。</p>
<p>然后，我们在主体中添加了一些<code>padding</code>，将应用包装器设置为不超过<code>500px</code>，将它放在视口的中心，并将文本放在视口的中心。</p>
<h2>设置 nice-modal-react</h2>
<p>安装 nice-modal-react 包本身就像运行<code>npm install @ebay/nice-modal-react</code>一样简单。它将向您的节点模块添加一个小的(在 gzip 之后大约 2KB)和无依赖性的包。</p>
<p>为了在整个应用程序中使用它，我们将设置一个单独的提供者，该提供者将使用<a href="https://reactjs.org/docs/context.html" target="_blank" rel="noopener"> React Context </a>来全局控制状态。</p>
<p>为此，打开<code>index.js</code>根文件，导入<code>NiceModal</code>组件，并将其包在<code>App</code>组件周围:</p>
<pre>javascript
import ReactDOM from "react-dom";
import NiceModal from "@ebay/nice-modal-react";
import App from "./App";

const rootElement = document.getElementById("root");

ReactDOM.render(
  &lt;NiceModal.Provider&gt;
    &lt;App /&gt;
  &lt;/NiceModal.Provider&gt;,
  rootElement
);</pre>
<p>在这一点上，我们已经设置了使用 nice-modal-react 的项目，所以我们可以开始为应用程序构建单独的组件。</p>
<h2>创建组件</h2>
<p>首先，我们需要为必要的组件创建单独的文件:<code>Modal</code>、<code>Button</code>和<code>Note</code>。为了保持一切井然有序，我们将创建一个单独的<code>components</code>文件夹，并为每个组件创建一个单独的<code>.js</code>文件和<code>.css</code>文件。</p>
<p>您可以手动创建这些文件，但是我建议使用以下命令来节省时间:</p>
<pre>bash
mkdir components &amp;&amp; cd components &amp;&amp; touch Modal.js Modal.css Button.js Button.css Note.js Note.css</pre>
<h3>情态的</h3>
<p>打开<code>Modal.js</code>并包含以下代码:</p>
<pre>javascript
import { useState } from "react";
import NiceModal, { useModal } from "@ebay/nice-modal-react";
import "./Modal.css";
import Button from "./Button";

const Modal = NiceModal.create(
  ({ title, subtitle, action, bgColor, note = "" }) =&gt; {
    const [input, setInput] = useState(note);
    const modal = useModal();
    return (
      &lt;div className="background"&gt;
        &lt;div className="modal"&gt;
          &lt;h1&gt;{title}&lt;/h1&gt;
          &lt;p className="subtitle"&gt;{subtitle}&lt;/p&gt;
          {action === "Save" &amp;&amp; (
            &lt;input
              className="input"
              type="text"
              value={input}
              onChange={(e) =&gt; {
                setInput(e.target.value);
              }}
            /&gt;
          )}
          &lt;div className="actions"&gt;
            &lt;Button
              name={action}
              backgroundColor={bgColor}
              onClick={() =&gt; {
                if (action === "Save") {
                  if (input) {
                    modal.resolve(input);
                    modal.remove();
                    console.log("Note saved");
                  } else {
                    console.log("Note is empty");
                  }
                } else {
                  modal.resolve();
                  modal.remove();
                  console.log("Note removed");
                }
              }}
            /&gt;
            &lt;Button
              name="Cancel"
              backgroundColor="silver"
              onClick={() =&gt; {
                modal.remove();
              }}
            /&gt;
          &lt;/div&gt;
        &lt;/div&gt;
      &lt;/div&gt;
    );
  }
);

export default Modal;</pre>
<p>首先，我们导入了<code>useState</code>来跟踪添加和编辑动作的输入状态，以及将成为我们的模型包装器的<code>NiceModal</code>组件。我们还为取消操作导入了外部样式表和<code>Button</code>组件来关闭模态。</p>
<p>我们使用<code>NiceModal.create</code>作为模态包装器。你可以认为这是创建一个基本组件，并将其包装成一个高阶函数。一旦我们将<code>Modal</code>组件导入到<code>App.js</code>中，它就会收到<code>title</code>、<code>subtitle</code>、<code>action</code>、<code>bgColor</code>和<code>note</code>道具。</p>
<p>添加和编辑模式将有一个输入字段，用户可以从零开始添加注释标题或编辑现有的注释标题。</p>
<p>输入的状态将存储在状态变量中，并传递给<code>App.js</code>使用。我还添加了一个简单的验证，这样用户就不能添加空的注释。</p>
<p>添加和编辑模式将包括保存选项，而删除模式将有一个删除按钮。每个模式的保存/删除旁边都有一个取消按钮，用于关闭该模式。</p><div class="code-block code-block-54">
<hr/>
<h3>更多来自 LogRocket 的精彩文章:</h3>

<hr/></div>
<p>打开<code>Modal.css</code>并包含以下样式规则:</p>
<pre>css
.background {
  width: 100vw;
  height: 100vh;
  position: absolute;
  left: 0;
  top: 0;
  display: grid;
  place-items: center;
  background-color: rgba(0, 0, 0, 0.7);
}

.modal {
  padding: 20px;
  width: 300px;
  border-radius: 10px;
  text-align: center;
  background-color: white;
  word-break: break-all;
}

.subtitle {
  margin-bottom: 20px;
}

.input {
  width: 100%;
  height: 25px;
  border: 1px solid silver;
  border-radius: 5px;
  padding: 0px 10px;
}

.actions {
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 20px;
  margin-top: 20px;
}</pre>
<p>我们将模态背景设置为填充所有的视口，使用黑色的<code>background-color</code>和<code>0.7</code>不透明度，并将子元素居中，这将是模态包装器。</p>
<p>对于实际的<code>modal</code>，我们设置了<code>padding</code>、特定的<code>width</code>、<code>border-radius</code>，将文本居中，将<code>background-color</code>设置为白色，并添加了一个<code>word-break</code>来拆分超出包装宽度的单词。</p>
<p>我们在字幕下面设置了一个<code>margin</code>，把它和输入区、动作区分开。</p>
<p><code>input</code>将使用整个可用宽度，有一个特定的<code>height</code>，一个带圆角的<code>border</code>，还有一些左右两侧的<code>padding</code>。</p>
<p><code>actions</code>区域将保存几个用于编辑和删除功能的<code>Button</code>组件，并被设置为将可用的<code>width</code>分成两列，一些<code>gap</code>在中间，<code>margin</code>在上面。</p>
<h3>纽扣</h3>
<p>打开<code>Button.js</code>并包含以下代码:</p>
<pre>javascript
import "./Button.css";

const Button = ({ name, backgroundColor, onClick }) =&gt; {
  return (
    &lt;button className="button" onClick={onClick} style={{ backgroundColor }}&gt;
      {name}
    &lt;/button&gt;
  );
};

export default Button;</pre>
<p>首先，我们导入样式表来样式化组件。然后，我们创建了一个简单的按钮组件，一旦导入并在<code>App.js</code>中使用，它将接收<code>name</code>、<code>backgroundColor</code>和<code>onClick</code>道具。</p>
<p>打开<code>Button.css</code>文件，包含以下样式规则:</p>
<pre>css
.button {
  border: none;
  padding: 5px 10px;
  cursor: pointer;
  border-radius: 5px;
  width: 100%;
}</pre>
<p>我们去掉了默认的按钮<code>border</code>，增加了一些<code>padding</code>，设置<code>cursor</code>为指针，增加了一些<code>border-radius</code>为平滑的边角，设置按钮填充可用的<code>width</code>。</p>
<h3>注意</h3>
<p>打开<code>Note.js</code>文件，包括以下内容:</p>
<pre>javascript
import "./Note.css";
import Button from "./Button";

const Note = ({ title, onClickEdit, onClickDelete }) =&gt; {
  return (
    &lt;div className="note"&gt;
      &lt;p&gt;{title}&lt;/p&gt;
      &lt;Button name="Edit" backgroundColor="gold" onClick={onClickEdit} /&gt;
      &lt;Button name="Delete" backgroundColor="tomato" onClick={onClickDelete} /&gt;
    &lt;/div&gt;
  );
};

export default Note;</pre>
<p>我们导入样式表来样式化组件，以及外部的<code>Button</code>组件，因此我们可以重用它来编辑和删除功能。</p>
<p><code>Note</code>组件包括笔记的<code>title</code>，以及我们在<code>App.js</code>中导入和使用<code>Note</code>组件时会传入的<code>Button</code>组件的<code>onClickEdit</code>和<code>onClickDelete</code>道具。</p>
<p>打开<code>Note.css</code>，包括以下内容:</p>
<pre>css
.note {
  display: grid;
  grid-template-columns: auto 70px 70px;
  gap: 20px;
  margin: 20px auto;
  text-align: left;
  word-break: break-all;
}

@media screen and (max-width: 400px) {
  .note {
    grid-template-columns: 1fr;
  }
}</pre>
<p>我们将注释设置为使用三列布局，中间有一个<code>20px</code>间隔，而编辑和删除按钮将使用固定的<code>width</code>，其余可用的<code>width</code>将用于注释<code>title</code>。我们还将<code>margin</code>设置在顶部，将文本居中放置在左侧，并添加了一个<code>word-break</code>以便自动拆分较长的单词。</p>
<p>我们还为响应创建了一些媒体规则。对于屏幕宽度<code>400px</code>和更小的，注释将切换到一列布局，这意味着所有包含的元素(标题、编辑按钮和删除按钮)将直接显示在彼此下方。</p>
<h2>实现逻辑</h2>
<p>现在，让我们把所有东西放在一起，为我们的应用程序创建逻辑。打开<code>App.js</code>并包含以下代码:</p>
<pre>javascript
import { useState } from "react";
import NiceModal from "@ebay/nice-modal-react";
import Modal from "../components/Modal";
import Note from "../components/Note";
import Button from "../components/Button";
import "./styles.css";

const noteList = [
  "My awesome third note",
  "My awesome second note",
  "My awesome first note"
];

const getNoteIndex = (e) =&gt;
  Array.from(e.target.parentElement.parentNode.children).indexOf(
    e.target.parentElement
  );

export default function App() {
  const [notes, setNotes] = useState(noteList);

  const showAddModal = () =&gt; {
    NiceModal.show(Modal, {
      title: "Add a new note",
      subtitle: "Enter the title",
      action: "Save",
      bgColor: "lime green"
    }).then((note) =&gt; {
      setNotes([note, ...notes]);
    });
  };

  const showEditModal = (e) =&gt; {
    NiceModal.show(Modal, {
      title: "Edit the note",
      subtitle: "Rename the Title",
      action: "Save",
      bgColor: "gold",
      note: notes[getNoteIndex(e)]
    }).then((note) =&gt; {
      const notesArr = [...notes];
      notesArr[getNoteIndex(e)] = note;
      setNotes(notesArr);
    });
  };

  const showDeleteModal = (e) =&gt; {
    NiceModal.show(Modal, {
      title: "Confirm Delete",
      subtitle: `The "${notes[getNoteIndex(e)]}" will be permanently removed`,
      action: "Delete",
      bgColor: "tomato",
      note: notes[getNoteIndex(e)]
    }).then(() =&gt; {
      const notesArr = [...notes];
      notesArr.splice(getNoteIndex(e), 1);
      setNotes(notesArr);
    });
  };

  return (
    &lt;div className="App"&gt;
      &lt;h1&gt;CRUD Notes&lt;/h1&gt;
      &lt;p style={{ marginBottom: "20px" }}&gt;Using nice-modal-react&lt;/p&gt;
      &lt;Button
        name="Add"
        backgroundColor="lime green"
        onClick={() =&gt; {
          showAddModal();
        }}
      /&gt;
      &lt;div&gt;
        {notes.map((note, index) =&gt; {
          return (
            &lt;Note
              key={index}
              note={note}
              onClickEdit={showEditModal}
              onClickDelete={showDeleteModal}
            /&gt;
          );
        })}
      &lt;/div&gt;
    &lt;/div&gt;
  );
}</pre>
<p>首先，我们导入了<code>useState</code>钩子，以便在使用应用程序时更新 notes 对象时跟踪它。我们还导入了<code>NiceModal</code>组件和我们在前一阶段创建的每个单独的组件。</p>
<p>为了设置组件的样式，我们将使用我们创建的外部样式表。</p>
<p>然后我们创建了一个<code>noteList</code>数组来保存应用程序的示例注释。我们还创建了<code>getNoteIndex</code>函数，这样我们就能够识别用户在列表中点击的特定笔记的索引。</p>
<p>在<code>App</code>函数中，我们首先将样本注释列表设置为<code>notes</code>变量。然后我们创建了三个不同的函数来处理添加、编辑和删除按钮的点击。</p>
<p>每个函数打开模态，并传入我们在<code>Modal</code>组件中定义的必要属性。按下“保存”或“删除”按钮后，笔记列表会相应更新。</p>
<p>最后，我们渲染了应用程序的<code>title</code>、<code>subtitle</code>，添加了带有必要道具的<code>Add</code>按钮，并通过<code>notes</code>变量循环显示所有的注释。</p>
<p>一切都是有组织的，模态本身没有单一的状态变量，然而我们成功地处理了三种不同的模态。</p>
<p>至此，您应该有了一个工作演示。让我们来测试一下！</p>
<p>确保您的 React 应用程序仍在终端中运行。如果没有，再次运行<code>npm start</code>。现在，打开浏览器并导航至<code><a href="http://localhost:3000" target="_blank" rel="noopener">http://localhost:3000</a></code>。您应该会看到一个功能齐全的 CRUD Notes 演示应用程序。</p>
<p><img data-attachment-id="84256" data-permalink="https://blog.logrocket.com/improve-modal-management-react-nice-modal-react/add-new-note/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/01/add-new-note.gif" data-orig-size="730,351" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Add and delete new note" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/01/add-new-note-300x144.gif" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/01/add-new-note.gif" decoding="async" class="aligncenter size-full wp-image-84256 jetpack-lazy-image" src="../Images/50365d6d42c8207a01cef77502b2159c.png" alt="Add and Delete New Note" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2022/01/add-new-note.gif?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/01/add-new-note.gif"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="84256" data-permalink="https://blog.logrocket.com/improve-modal-management-react-nice-modal-react/add-new-note/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/01/add-new-note.gif" data-orig-size="730,351" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Add and delete new note" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/01/add-new-note-300x144.gif" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/01/add-new-note.gif" decoding="async" loading="lazy" class="aligncenter size-full wp-image-84256" src="../Images/50365d6d42c8207a01cef77502b2159c.png" alt="Add and Delete New Note" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/01/add-new-note.gif"/></noscript>
<h2>结论</h2>
<p>虽然这可能看起来像一个基本的 notes 应用程序，但我们实现了构建真实 CRUD 应用程序所需的所有功能。我们关注的是行为和状态，所以请确保根据您在项目中的具体需求来调整模态的内容。</p>
<p>此外，可以随意向表单中添加一些高级输入验证，或者编写一些后端程序，这样所有的值都存储在数据库中，并且不会丢失数据。目前，只有空输入的<code>console.log</code>语句，数据存储在状态中。</p>
<p>因为它是开源的，所以请查看这个<a href="https://github.com/eBay/nice-modal-react" target="_blank" rel="noopener"> GitHub 库</a>,并随时向项目贡献任何想法或功能请求，以使它变得更好！</p><div class="code-block code-block-17">
<div class="blog-plug inline-plug react-plug" vwo-el-id="26283398190">
<h2 vwo-el-id="41600691720">使用 LogRocket 消除传统反应错误报告的噪音</h2>
<a href="https://lp.logrocket.com/blg/react-signup-issue-free" target="_blank" vwo-el-id="19356441070">LogRocket
</a><p>是一款 React analytics 解决方案，可保护您免受数百个误报错误警报的影响，只针对少数真正重要的项目。LogRocket 告诉您 React 应用程序中实际影响用户的最具影响力的 bug 和 UX 问题。</p><a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="19356441380">
<img class="first-react-image alignnone size-full wp-image-46 jetpack-lazy-image jetpack-lazy-image--handled" src="../Images/f300c244a1a1cf916df8b4cb02bec6c6.png" vwo-el-id="18272717540" data-lazy-loaded="1" data-original-src="https://files.readme.io/27c94e7-Image_2017-06-05_at_9.46.04_PM.png"/>
</a>
<a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="19356441690">
<img class="second-react-image alignnone size-full wp-image-46 jetpack-lazy-image jetpack-lazy-image--handled" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" vwo-el-id="30720362350" data-lazy-loaded="1" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/>
</a>
<a href="https://lp.logrocket.com/blg/react-signup-issue-free" target="_blank" rel="noopener noreferrer" vwo-el-id="35866400580">LogRocket
</a><p>自动聚合客户端错误、反应错误边界、还原状态、缓慢的组件加载时间、JS 异常、前端性能指标和用户交互。然后，LogRocket 使用机器学习来通知您影响大多数用户的最具影响力的问题，并提供您修复它所需的上下文。</p><p vwo-el-id="28675661060">关注重要的 React bug—<a class="signup" href="https://lp.logrocket.com/blg/react-signup-issue-free" target="_blank" rel="noopener noreferrer" vwo-el-id="40093418840">今天就试试 LogRocket】。</a></p>
</div></div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
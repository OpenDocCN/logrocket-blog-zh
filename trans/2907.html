<html>
<head>
<title>How to solve the React useEffect Hook's infinite loop patterns - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>如何解决 React useEffect 钩子的无限循环模式</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/solve-react-useeffect-hook-infinite-loop-patterns/#0001-01-01">https://blog.logrocket.com/solve-react-useeffect-hook-infinite-loop-patterns/#0001-01-01</a></blockquote><div><article class="article-post">
<p>React 的<code>useEffect</code>钩子让用户可以处理应用程序的副作用。一些例子可以是:</p>
<ul>
<li><a href="https://blog.logrocket.com/data-fetching-react-native/" target="_blank" rel="noopener">从网络获取数据</a>:通常，应用程序在第一次挂载时获取并填充数据。这可以通过<code>useEffect</code>功能实现</li>
<li>操作 UI:应用程序应该响应一个按钮点击事件(例如，打开一个菜单)</li>
<li>设置或结束定时器:如果某个变量达到一个预定义的值，一个内置的定时器应该停止或启动自己</li>
</ul>
<p>尽管<code>useEffect</code>钩子的<a href="https://blog.logrocket.com/guide-to-react-useeffect-hook/">用法在 React 生态系统中很常见，但掌握它需要时间。正因为如此，许多新手开发人员配置他们的<code>useEffect</code>函数的方式会导致无限循环问题。在本文中，您将了解臭名昭著的无限循环以及如何解决它。</a></p>
<p>这就是我们今天要学习的内容:</p>

<p>我们开始吧！</p>
<h2 id="what-causes-infinite-loops-and-how-to-solve-them">什么导致无限循环以及如何解决它们</h2>
<h3 id="passing-no-dependencies-in-dependency-array">在依赖项数组中不传递依赖项</h3>
<p>如果您的<code>useEffect</code>函数不包含任何依赖项，将会出现无限循环。</p>
<p>例如，看看下面的代码:</p>
<pre class="language-javascript hljs">function App() {
  const [count, setCount] = useState(0); //initial value of this 
  useEffect(() =&gt; {
    setCount((count) =&gt; count + 1); //increment this Hook
  }); //no dependency array.
  return (
    &lt;div className="App"&gt;
      &lt;p&gt; value of count: {count} &lt;/p&gt;
    &lt;/div&gt;
  );
}
</pre>
<p><code>useEffect</code>如果没有依赖关系，默认情况下在每个更新周期触发。因此，这里的应用程序将在每次渲染时执行<code>setCount</code>函数。因此，这导致了一个无限循环:</p>
<p><img data-attachment-id="105736" data-permalink="https://blog.logrocket.com/solve-react-useeffect-hook-infinite-loop-patterns/infinite-loop/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/04/infinite-loop.gif" data-orig-size="517,403" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Infinite loop" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/04/infinite-loop-300x234.gif" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/04/infinite-loop.gif" decoding="async" class="aligncenter size-full wp-image-105736 jetpack-lazy-image" src="../Images/2cb7b28811dc2989b86c3136549e02e7.png" alt="Infinite Loop" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2022/04/infinite-loop.gif?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/04/infinite-loop.gif"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="105736" data-permalink="https://blog.logrocket.com/solve-react-useeffect-hook-infinite-loop-patterns/infinite-loop/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/04/infinite-loop.gif" data-orig-size="517,403" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Infinite loop" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/04/infinite-loop-300x234.gif" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/04/infinite-loop.gif" decoding="async" loading="lazy" class="aligncenter size-full wp-image-105736" src="../Images/2cb7b28811dc2989b86c3136549e02e7.png" alt="Infinite Loop" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/04/infinite-loop.gif"/></noscript>
<h4 id="what-causes-this-problem">是什么导致了这个问题？</h4>
<p>让我们一步一步地分解我们的问题:</p>
<ol>
<li>在第一次渲染时，React 检查<code>count</code>的值。这里，由于<code>count</code>是<code>0</code>，程序执行<code>useEffect</code>功能</li>
<li>稍后，<code>useEffect</code>调用<code>setCount</code>方法并更新<code>count</code>钩子的值</li>
<li>之后，React 重新渲染 UI 以显示<code>count</code>的更新值</li>
<li>此外，由于<code>useEffect</code>在每个渲染周期运行，它会重新调用<code>setCount</code>函数</li>
<li>由于上述步骤会在每次渲染时发生，这会导致应用程序崩溃</li>
</ol>
<h4 id="how-to-fix-this">如何解决这个问题</h4>
<p>为了缓解这个问题，我们必须使用一个依赖数组。这告诉 React 仅在特定值更新时调用<code>useEffect</code>。</p>
<p>下一步，追加一个空白数组作为依赖项，如下所示:</p>
<pre class="language-javascript hljs">useEffect(() =&gt; {
  setCount((count) =&gt; count + 1);
}, []); //empty array as second argument.
</pre>
<p>这告诉 React 在第一次挂载时执行<code>setCount</code>函数。</p>
<p><img data-attachment-id="105740" data-permalink="https://blog.logrocket.com/solve-react-useeffect-hook-infinite-loop-patterns/execute-setcount-function-on-first-mount/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/04/execute-setcount-function-on-first-mount.png" data-orig-size="336,229" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Execute setCount Function on the First Mount" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/04/execute-setcount-function-on-first-mount-300x204.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/04/execute-setcount-function-on-first-mount.png" decoding="async" class="aligncenter size-full wp-image-105740 jetpack-lazy-image" src="../Images/4e824db619959e85026f492b5d80a0c6.png" alt="Execute SetCount Function On The First Mount" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2022/04/execute-setcount-function-on-first-mount.png 336w, https://blog.logrocket.com/wp-content/uploads/2022/04/execute-setcount-function-on-first-mount-300x204.png 300w" data-lazy-sizes="(max-width: 336px) 100vw, 336px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2022/04/execute-setcount-function-on-first-mount.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/04/execute-setcount-function-on-first-mount.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="105740" data-permalink="https://blog.logrocket.com/solve-react-useeffect-hook-infinite-loop-patterns/execute-setcount-function-on-first-mount/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/04/execute-setcount-function-on-first-mount.png" data-orig-size="336,229" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Execute setCount Function on the First Mount" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/04/execute-setcount-function-on-first-mount-300x204.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/04/execute-setcount-function-on-first-mount.png" decoding="async" loading="lazy" class="aligncenter size-full wp-image-105740" src="../Images/4e824db619959e85026f492b5d80a0c6.png" alt="Execute SetCount Function On The First Mount" srcset="https://blog.logrocket.com/wp-content/uploads/2022/04/execute-setcount-function-on-first-mount.png 336w, https://blog.logrocket.com/wp-content/uploads/2022/04/execute-setcount-function-on-first-mount-300x204.png 300w" sizes="(max-width: 336px) 100vw, 336px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/04/execute-setcount-function-on-first-mount.png"/></noscript>
<h3 id="using-a-function-as-a-dependency">将函数用作依赖项</h3>
<p>如果您将一个方法传递到您的<code>useEffect</code>依赖数组中，React 将抛出一个错误，表明您有一个无限循环:</p>
<pre class="language-javascript hljs">function App() {
  const [count, setCount] = useState(0);

  function logResult() {
    return 2 + 2;
  }
  useEffect(() =&gt; {
    setCount((count) =&gt; count + 1);
  }, [logResult]); //set our function as dependency
  return (
    &lt;div className="App"&gt;
      &lt;p&gt; value of count: {count} &lt;/p&gt; {/*Display the value of count*/}
    &lt;/div&gt;
  );
}
</pre>
<p>在这个代码片段中，我们将我们的<code>logResult</code>方法传递给了<code>useEffect</code>数组。理论上，React 只需要在第一次渲染时增加<code>count</code>的值。</p>
<p><img data-attachment-id="105742" data-permalink="https://blog.logrocket.com/solve-react-useeffect-hook-infinite-loop-patterns/passing-logresult-method-into-useeffect-array/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/04/passing-logresult-method-into-useeffect-array.png" data-orig-size="446,301" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Passing the logResult method into the useEffect array" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/04/passing-logresult-method-into-useeffect-array-300x202.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/04/passing-logresult-method-into-useeffect-array.png" decoding="async" class="aligncenter size-full wp-image-105742 jetpack-lazy-image" src="../Images/fc1158ff1d79e3491b2095d69c7297f9.png" alt="Passing The LogResult Method Into The UseEffect Array" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2022/04/passing-logresult-method-into-useeffect-array.png 446w, https://blog.logrocket.com/wp-content/uploads/2022/04/passing-logresult-method-into-useeffect-array-300x202.png 300w" data-lazy-sizes="(max-width: 446px) 100vw, 446px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2022/04/passing-logresult-method-into-useeffect-array.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/04/passing-logresult-method-into-useeffect-array.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="105742" data-permalink="https://blog.logrocket.com/solve-react-useeffect-hook-infinite-loop-patterns/passing-logresult-method-into-useeffect-array/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/04/passing-logresult-method-into-useeffect-array.png" data-orig-size="446,301" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Passing the logResult method into the useEffect array" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/04/passing-logresult-method-into-useeffect-array-300x202.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/04/passing-logresult-method-into-useeffect-array.png" decoding="async" loading="lazy" class="aligncenter size-full wp-image-105742" src="../Images/fc1158ff1d79e3491b2095d69c7297f9.png" alt="Passing The LogResult Method Into The UseEffect Array" srcset="https://blog.logrocket.com/wp-content/uploads/2022/04/passing-logresult-method-into-useeffect-array.png 446w, https://blog.logrocket.com/wp-content/uploads/2022/04/passing-logresult-method-into-useeffect-array-300x202.png 300w" sizes="(max-width: 446px) 100vw, 446px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/04/passing-logresult-method-into-useeffect-array.png"/></noscript>
<h4 id="what-causes-this-problem">是什么导致了这个问题？</h4>
<ol>
<li>需要记住的一点是，<code>useEffect</code>使用了一个叫做<a href="https://learntechsystems.com/what-is-shallow-comparison-in-js/" target="_blank" rel="noopener">浅层比较</a>的概念。这样做是为了验证依赖关系是否已经更新</li>
<li>这里的问题是在每次渲染的时候，React 重新定义了<code>logResult</code>的引用</li>
<li>因此，这将在每个周期重新触发<code>useEffect</code>功能</li>
<li>因此，React 调用<code>setCount</code>钩子，直到你的应用遇到一个<strong>更新深度</strong>错误。这会给你的程序带来错误和不稳定性</li>
</ol>
<h4 id="how-to-fix-this">如何解决这个问题</h4>
<p>解决这个问题的一个方法是使用<code>useCallback</code>钩子。这允许开发者<a href="https://blog.logrocket.com/rethinking-hooks-memoization/">记忆他们的函数</a>，确保参考值保持不变。由于稳定的参考值，React 不应该无限地重新呈现 UI:</p>
<pre class="language-javascript hljs">const logResult = useCallback(() =&gt; {
  return 2 + 2;
}, []); //logResult is memoized now.
useEffect(()=&gt; {
  setCount((count)=&gt; count+1);
},[logResult]); //no infinite loop error, since logResult reference stays the same.
</pre>
<p>这将是结果:</p>
<p><img data-attachment-id="105744" data-permalink="https://blog.logrocket.com/solve-react-useeffect-hook-infinite-loop-patterns/ensuring-reference-value-stays-the-same/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/04/ensuring-reference-value-stays-the-same.png" data-orig-size="383,251" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Ensuring that the reference value stays the same" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/04/ensuring-reference-value-stays-the-same-300x197.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/04/ensuring-reference-value-stays-the-same.png" decoding="async" class="aligncenter size-full wp-image-105744 jetpack-lazy-image" src="../Images/e740891d569a6e5455d9358ffcb2e1b6.png" alt="Ensuring That The Reference Value Stays The Same" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2022/04/ensuring-reference-value-stays-the-same.png 383w, https://blog.logrocket.com/wp-content/uploads/2022/04/ensuring-reference-value-stays-the-same-300x197.png 300w" data-lazy-sizes="(max-width: 383px) 100vw, 383px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2022/04/ensuring-reference-value-stays-the-same.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/04/ensuring-reference-value-stays-the-same.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="105744" data-permalink="https://blog.logrocket.com/solve-react-useeffect-hook-infinite-loop-patterns/ensuring-reference-value-stays-the-same/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/04/ensuring-reference-value-stays-the-same.png" data-orig-size="383,251" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Ensuring that the reference value stays the same" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/04/ensuring-reference-value-stays-the-same-300x197.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/04/ensuring-reference-value-stays-the-same.png" decoding="async" loading="lazy" class="aligncenter size-full wp-image-105744" src="../Images/e740891d569a6e5455d9358ffcb2e1b6.png" alt="Ensuring That The Reference Value Stays The Same" srcset="https://blog.logrocket.com/wp-content/uploads/2022/04/ensuring-reference-value-stays-the-same.png 383w, https://blog.logrocket.com/wp-content/uploads/2022/04/ensuring-reference-value-stays-the-same-300x197.png 300w" sizes="(max-width: 383px) 100vw, 383px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/04/ensuring-reference-value-stays-the-same.png"/></noscript>
<h3 id="using-an-array-as-a-dependency">将数组用作依赖项</h3>
<p>将数组变量传递给依赖项也会运行无限循环。考虑以下代码示例:</p>
<pre class="language-javascript hljs">const [count, setCount] = useState(0); //iniital value will be 0.
const myArray = ["one", "two", "three"];

useEffect(() =&gt; {
  setCount((count) =&gt; count + 1); //just like before, increment the value of Count
}, [myArray]); //passing array variable into dependencies
</pre>
<p>在这个块中，我们将变量<code>myArray</code>传递给依赖参数。</p>
<p><img data-attachment-id="105747" data-permalink="https://blog.logrocket.com/solve-react-useeffect-hook-infinite-loop-patterns/passing-myarray-variable-into-dependency-argument/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/04/passing-myarray-variable-into-dependency-argument.gif" data-orig-size="517,403" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Passing our myArray variable into our dependency argument" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/04/passing-myarray-variable-into-dependency-argument-300x234.gif" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/04/passing-myarray-variable-into-dependency-argument.gif" decoding="async" class="aligncenter size-full wp-image-105747 jetpack-lazy-image" src="../Images/d1a7142f8d7899078dc46c7007a81c25.png" alt="Passing Our MyArray Variable Into Our Dependency Argument" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2022/04/passing-myarray-variable-into-dependency-argument.gif?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/04/passing-myarray-variable-into-dependency-argument.gif"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="105747" data-permalink="https://blog.logrocket.com/solve-react-useeffect-hook-infinite-loop-patterns/passing-myarray-variable-into-dependency-argument/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/04/passing-myarray-variable-into-dependency-argument.gif" data-orig-size="517,403" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Passing our myArray variable into our dependency argument" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/04/passing-myarray-variable-into-dependency-argument-300x234.gif" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/04/passing-myarray-variable-into-dependency-argument.gif" decoding="async" loading="lazy" class="aligncenter size-full wp-image-105747" src="../Images/d1a7142f8d7899078dc46c7007a81c25.png" alt="Passing Our MyArray Variable Into Our Dependency Argument" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/04/passing-myarray-variable-into-dependency-argument.gif"/></noscript>
<h4 id="what-causes-this-problem">是什么导致了这个问题？</h4>
<p>既然<code>myArray</code>的值在整个程序中不会改变，为什么我们的代码会多次触发<code>useEffect</code>？</p>
<ol>
<li>在这里，回想一下 React 使用浅层比较来检查依赖项的引用是否已经更改。</li>
<li>由于对<code>myArray</code>的引用在每次渲染时都会不断变化，<code>useEffect</code>将触发<code>setCount</code>回调</li>
<li>因此，由于<code>myArray's</code>参考值不稳定，React 将在每个渲染周期调用<code>useEffect</code>。最终，这会导致您的应用程序崩溃</li>
</ol>
<h4 id="how-to-fix-this">如何解决这个问题</h4>
<p>为了解决这个问题，我们可以使用一个<code><a href="https://www.react.express/hooks/useref" target="_blank" rel="noopener">useRef</a></code>钩子。这将返回一个可变对象，确保引用不会改变:</p>
<pre class="language-javascript hljs">const [count, setCount] = useState(0);
//extract the 'current' property and assign it a value
const { current: myArray } = useRef(["one", "two", "three"]);

useEffect(() =&gt; {
  setCount((count) =&gt; count + 1);
}, [myArray]); //the reference value is stable, so no infinite loop
</pre>
<h3 id="passing-an-object-as-a-dependency">将对象作为依赖项传递</h3>
<p>在<code>useEffect</code>依赖数组中使用一个对象也会导致无限循环问题。</p>
<p>考虑以下代码:</p>
<pre class="language-javascript hljs">const [count, setCount] = useState(0);
const person = { name: "Rue", age: 17 }; //create an object
useEffect(() =&gt; {
  //increment the value of count every time
  //the value of 'person' changes
  setCount((count) =&gt; count + 1);
}, [person]); //dependency array contains an object as an argument
return (
  &lt;div className="App"&gt;
    &lt;p&gt; Value of {count} &lt;/p&gt;
  &lt;/div&gt;
);
</pre>
<p>控制台中的结果表明程序无限循环:</p>
<p><img data-attachment-id="105750" data-permalink="https://blog.logrocket.com/solve-react-useeffect-hook-infinite-loop-patterns/console-result-showing-infinite-looping/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/04/console-result-showing-infinite-looping.png" data-orig-size="730,62" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Console result showing infinite looping" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/04/console-result-showing-infinite-looping-300x25.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/04/console-result-showing-infinite-looping.png" decoding="async" class="aligncenter size-full wp-image-105750 jetpack-lazy-image" src="../Images/6180b8cd4134db71d245e8449041afad.png" alt="Console Result Showing Infinite Looping" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2022/04/console-result-showing-infinite-looping.png 730w, https://blog.logrocket.com/wp-content/uploads/2022/04/console-result-showing-infinite-looping-300x25.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2022/04/console-result-showing-infinite-looping.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/04/console-result-showing-infinite-looping.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="105750" data-permalink="https://blog.logrocket.com/solve-react-useeffect-hook-infinite-loop-patterns/console-result-showing-infinite-looping/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/04/console-result-showing-infinite-looping.png" data-orig-size="730,62" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Console result showing infinite looping" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/04/console-result-showing-infinite-looping-300x25.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/04/console-result-showing-infinite-looping.png" decoding="async" loading="lazy" class="aligncenter size-full wp-image-105750" src="../Images/6180b8cd4134db71d245e8449041afad.png" alt="Console Result Showing Infinite Looping" srcset="https://blog.logrocket.com/wp-content/uploads/2022/04/console-result-showing-infinite-looping.png 730w, https://blog.logrocket.com/wp-content/uploads/2022/04/console-result-showing-infinite-looping-300x25.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/04/console-result-showing-infinite-looping.png"/></noscript>
<h4 id="what-causes-this-issue">是什么导致了这个问题？</h4>
<ol>
<li>和之前一样，React 使用浅层比较来检查<code>person</code>的参考值是否有变化</li>
<li>由于<code>person</code>对象的参考值在每次渲染时都会改变，React 会重新运行<code>useEffect</code></li>
<li>因此，这将在每个更新周期调用<code>setCount</code>。这意味着我们现在有一个无限循环</li>
</ol>
<h4 id="how-to-fix-this">如何解决这个问题</h4>
<p>那么我们如何摆脱这个问题呢？</p>
<p>这就是<code>useMemo</code>的用武之地。当依赖关系改变时，这个钩子将计算一个记忆值。除此之外，由于我们有一个记忆化的变量，这确保了状态的参考值在每次渲染期间不会改变:</p>
<pre class="language-javascript hljs">//create an object with useMemo
const person = useMemo(
  () =&gt; ({ name: "Rue", age: 17 }),
  [] //no dependencies so the value doesn't change
);
useEffect(() =&gt; {
  setCount((count) =&gt; count + 1);
}, [person]);
</pre>
<h3 id="passing-an-incorrect-dependency">传递不正确的依赖关系</h3>
<p>如果将错误的变量传递给<code>useEffect</code>函数，React 将抛出一个错误。</p>
<p>下面是一个简单的例子:</p>
<pre class="language-javascript hljs">const [count, setCount] = useState(0);

useEffect(() =&gt; {
  setCount((count) =&gt; count + 1);
}, [count]); //notice that we passed count to this array.

return (
  &lt;div className="App"&gt;
    &lt;button onClick={() =&gt; setCount((count) =&gt; count + 1)}&gt;+&lt;/button&gt;
    &lt;p&gt; Value of count{count} &lt;/p&gt;
  &lt;/div&gt;
);
</pre>
<p><img data-attachment-id="105766" data-permalink="https://blog.logrocket.com/solve-react-useeffect-hook-infinite-loop-patterns/passing-incorrect-dependency/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/04/passing-incorrect-dependency.gif" data-orig-size="730,400" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Passing an incorrect dependency" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/04/passing-incorrect-dependency-300x164.gif" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/04/passing-incorrect-dependency.gif" decoding="async" class="aligncenter size-full wp-image-105766 jetpack-lazy-image" src="../Images/bed1e269a1f3b3f48653a866a324f8dc.png" alt="Passing An Incorrect Dependency" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2022/04/passing-incorrect-dependency.gif?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/04/passing-incorrect-dependency.gif"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="105766" data-permalink="https://blog.logrocket.com/solve-react-useeffect-hook-infinite-loop-patterns/passing-incorrect-dependency/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/04/passing-incorrect-dependency.gif" data-orig-size="730,400" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Passing an incorrect dependency" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/04/passing-incorrect-dependency-300x164.gif" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/04/passing-incorrect-dependency.gif" decoding="async" loading="lazy" class="aligncenter size-full wp-image-105766" src="../Images/bed1e269a1f3b3f48653a866a324f8dc.png" alt="Passing An Incorrect Dependency" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/04/passing-incorrect-dependency.gif"/></noscript>
<h4 id="what-causes-this-issue">是什么导致了这个问题？</h4>
<ol>
<li>在上面的代码中，我们告诉在<code>useEffect</code>方法中更新<code>count</code>的值</li>
<li>此外，注意我们也将<code>count</code>钩子传递给了它的依赖数组</li>
<li>这意味着每次<code>count</code>的值更新时，React 都会调用<code>useEffect</code></li>
<li>结果，<code>useEffect</code>钩子调用<code>setCount</code>，从而再次更新<code>count</code></li>
<li>因此，React 现在正在无限循环中运行我们的函数</li>
</ol>
<h4 id="how-to-fix-this-issue">如何解决这个问题</h4>
<p>要摆脱无限循环，只需使用一个空的依赖数组，如下所示:</p>
<pre class="language-javascript hljs">const [count, setCount] = useState(0);
//only update the value of 'count' when component is first mounted
useEffect(() =&gt; {
  setCount((count) =&gt; count + 1);
}, []);
</pre>
<p>这将告诉 React 在第一次渲染时运行<code>useEffect</code>。</p>
<p><img data-attachment-id="105776" data-permalink="https://blog.logrocket.com/solve-react-useeffect-hook-infinite-loop-patterns/run-useeffect-first-render/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/04/run-useeffect-first-render.gif" data-orig-size="730,400" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Run useEffect on first render" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/04/run-useeffect-first-render-300x164.gif" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/04/run-useeffect-first-render.gif" decoding="async" class="aligncenter size-full wp-image-105776 jetpack-lazy-image" src="../Images/8808bcd07a073cf9b092d01a9d144a0d.png" alt="Run UseEffect On First Render" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2022/04/run-useeffect-first-render.gif?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/04/run-useeffect-first-render.gif"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="105776" data-permalink="https://blog.logrocket.com/solve-react-useeffect-hook-infinite-loop-patterns/run-useeffect-first-render/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/04/run-useeffect-first-render.gif" data-orig-size="730,400" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Run useEffect on first render" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/04/run-useeffect-first-render-300x164.gif" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/04/run-useeffect-first-render.gif" decoding="async" loading="lazy" class="aligncenter size-full wp-image-105776" src="../Images/8808bcd07a073cf9b092d01a9d144a0d.png" alt="Run UseEffect On First Render" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/04/run-useeffect-first-render.gif"/></noscript>
<h2 id="conclusion">结论</h2>
<p>尽管 React 挂钩是一个简单的概念，但是在将它们合并到您的项目中时，有许多规则需要记住。这将确保您的应用程序保持稳定、优化，并且在生产过程中不会出现错误。</p>
<p>此外，<a href="https://create-react-app.dev/" target="_blank" rel="noopener"> Create React App </a> CLI 的最新版本也在运行时检测并报告无限循环错误。这有助于开发人员在这些问题进入生产服务器之前发现并减轻它们。</p>
<p><img data-attachment-id="105761" data-permalink="https://blog.logrocket.com/solve-react-useeffect-hook-infinite-loop-patterns/react-hooks-exhaustive-deps/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/04/react-hooks-exhaustive-deps.png" data-orig-size="730,105" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="React Hooks Exhaustive Deps" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/04/react-hooks-exhaustive-deps-300x43.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/04/react-hooks-exhaustive-deps.png" decoding="async" class="aligncenter size-full wp-image-105761 jetpack-lazy-image" src="../Images/91610811ea8182be37c29f2f48bd2225.png" alt="React Hooks Exhaustive Deps" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2022/04/react-hooks-exhaustive-deps.png 730w, https://blog.logrocket.com/wp-content/uploads/2022/04/react-hooks-exhaustive-deps-300x43.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2022/04/react-hooks-exhaustive-deps.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/04/react-hooks-exhaustive-deps.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="105761" data-permalink="https://blog.logrocket.com/solve-react-useeffect-hook-infinite-loop-patterns/react-hooks-exhaustive-deps/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/04/react-hooks-exhaustive-deps.png" data-orig-size="730,105" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="React Hooks Exhaustive Deps" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/04/react-hooks-exhaustive-deps-300x43.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/04/react-hooks-exhaustive-deps.png" decoding="async" loading="lazy" class="aligncenter size-full wp-image-105761" src="../Images/91610811ea8182be37c29f2f48bd2225.png" alt="React Hooks Exhaustive Deps" srcset="https://blog.logrocket.com/wp-content/uploads/2022/04/react-hooks-exhaustive-deps.png 730w, https://blog.logrocket.com/wp-content/uploads/2022/04/react-hooks-exhaustive-deps-300x43.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/04/react-hooks-exhaustive-deps.png"/></noscript>
<p>非常感谢您的阅读！编码快乐！</p><div class="code-block code-block-17">
<div class="blog-plug inline-plug react-plug" vwo-el-id="26283398190">
<h2 vwo-el-id="41600691720">使用 LogRocket 消除传统反应错误报告的噪音</h2>
<a href="https://lp.logrocket.com/blg/react-signup-issue-free" target="_blank" vwo-el-id="19356441070">LogRocket
</a><p>是一款 React analytics 解决方案，可保护您免受数百个误报错误警报的影响，只针对少数真正重要的项目。LogRocket 告诉您 React 应用程序中实际影响用户的最具影响力的 bug 和 UX 问题。</p><a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="19356441380">
<img class="first-react-image alignnone size-full wp-image-46 jetpack-lazy-image jetpack-lazy-image--handled" src="../Images/f300c244a1a1cf916df8b4cb02bec6c6.png" vwo-el-id="18272717540" data-lazy-loaded="1" data-original-src="https://files.readme.io/27c94e7-Image_2017-06-05_at_9.46.04_PM.png"/>
</a>
<a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="19356441690">
<img class="second-react-image alignnone size-full wp-image-46 jetpack-lazy-image jetpack-lazy-image--handled" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" vwo-el-id="30720362350" data-lazy-loaded="1" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/>
</a>
<a href="https://lp.logrocket.com/blg/react-signup-issue-free" target="_blank" rel="noopener noreferrer" vwo-el-id="35866400580">LogRocket
</a><p>自动聚合客户端错误、反应错误边界、还原状态、缓慢的组件加载时间、JS 异常、前端性能指标和用户交互。然后，LogRocket 使用机器学习来通知您影响大多数用户的最具影响力的问题，并提供您修复它所需的上下文。</p><p vwo-el-id="28675661060">关注重要的 React bug—<a class="signup" href="https://lp.logrocket.com/blg/react-signup-issue-free" target="_blank" rel="noopener noreferrer" vwo-el-id="40093418840">今天就试试 LogRocket】。</a></p>
</div></div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>
 
</div>    
</body>
</html>
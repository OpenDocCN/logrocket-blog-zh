<html>
<head>
<title>Implementing cryptography with Python - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>用 Python - LogRocket 博客实现密码学</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/implementing-cryptography-python/#0001-01-01">https://blog.logrocket.com/implementing-cryptography-python/#0001-01-01</a></blockquote><div><article class="article-post">
<h2>什么是密码学？</h2>
<p>密码术是通过使用代码加密和解密数据来创建安全通信信道的艺术，这意味着除了指定的人之外，没有人能够看到传输的数据。</p>
<p>密码术主要使用数学原理和一系列公式和算法来加密消息，使得解密这些消息变得不可能。它在当今世界无处不在，从保护社交媒体平台的日常通信到保护在线电子商务的银行交易活动。</p>
<h2>有哪些不同类型的加密技术？</h2>
<p>有三种主要的加密类型:</p>
<ol>
<li>对称密钥加密</li>
<li>非对称密钥加密</li>
<li>散列法</li>
</ol>
<p>让我们深入看看每一个！</p>
<h2>对称密钥加密</h2>
<p><a href="https://doubleoctopus.com/security-wiki/encryption-and-cryptography/symmetric-key-cryptography/" target="_blank" rel="noopener">对称密钥加密</a>是解密和加密消息的最快和最简单的方法之一。它主要涉及使用一个密钥，称为秘密密钥，用于加密和解密数据。它也被称为私钥加密，以及秘密密钥、共享密钥、一键和私钥加密。</p>
<p>数据被转换成任何人都无法理解的形式，从而使数据免受攻击者的攻击。它主要用于加密大量数据。对称密钥加密有两种方法类型，用于将明文转换为密文:分组密码和流密码。</p>
<p>分组密码采用<a href="https://techdifferences.com/difference-between-block-cipher-and-stream-cipher.html" target="_blank" rel="noopener">电子码组</a> ( <a href="https://techdifferences.com/difference-between-block-cipher-and-stream-cipher.html" target="_blank" rel="noopener"> ECB </a>)和<a href="https://techdifferences.com/difference-between-block-cipher-and-stream-cipher.html" target="_blank" rel="noopener">密码码组</a> ( <a href="https://techdifferences.com/difference-between-block-cipher-and-stream-cipher.html" target="_blank" rel="noopener"> CBC </a>)的算法模式。它们接受文本输入，并通过获取一个文本块并生成一个相同大小的密文来将它们转换成密文。块密码比流密码相对较慢，因为文本块需要被覆盖、加密和解密。</p>
<p>另一方面，流密码使用密文反馈(CFB)和输出反馈(OFB)模式，通过一次输入 1 个字节将明文转换为密文，使流密码比块密码更快。流密码使用 XOR 将明文转换为密文。</p>
<p>对称密钥算法的一些例子是:</p>

<h3>用 Python 实现的凯撒密码</h3>
<p>凯撒密码是对称密钥加密的一个例子，它是实现加密的最古老和最简单的方法之一。凯撒密码是一种替代密码，在这种密码中，字母按固定的位置数移动它们的顺序。</p>
<p>加密和解密凯撒密码很容易，因为方法是固定的，不需要密钥。因此，任何知道该方法的人都能够很容易地解密该消息。</p>
<p>例如，如果您将字母表中的每个字母移动三个字母，像“cat”这样的简单单词将被加密为“fdw”。如果你不知道“猫”这个词是如何被加密的，那么这个词就很难理解。</p>
<p>现在，让我们创建一个简单的加密和解密密文的 Python 程序:</p>
<pre>alphabets = 'abcdefghijklmnopqrstuvwxyz'
def encrypt_caesar(num, text):
 result = ' '
 for k in text.lower():
  try:
    i = (alphabets.index(k) + num) % 26
    results += alphabets[i]
  except ValueError:
   results+= k
 return results.lower()
num =int(input("please input the shift:\t"))
text=input("please input the text: \t")
ciphertext = encrypt_caesar(num, text)
print(“Encoded text:”,ciphertext)</pre>
<p>结果如下:</p>
<p><img data-attachment-id="76567" data-permalink="https://blog.logrocket.com/implementing-cryptography-python/encoded-text/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2021/11/encoded-text.png" data-orig-size="418,62" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Encoded text" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2021/11/encoded-text-300x44.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2021/11/encoded-text.png" decoding="async" class="aligncenter size-full wp-image-76567 jetpack-lazy-image" src="../Images/7eac5d48eccf2fa69f682b8c22b6579f.png" alt="Encoded Text" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2021/11/encoded-text.png 418w, https://blog.logrocket.com/wp-content/uploads/2021/11/encoded-text-300x44.png 300w" data-lazy-sizes="(max-width: 418px) 100vw, 418px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2021/11/encoded-text.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2021/11/encoded-text.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="76567" data-permalink="https://blog.logrocket.com/implementing-cryptography-python/encoded-text/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2021/11/encoded-text.png" data-orig-size="418,62" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Encoded text" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2021/11/encoded-text-300x44.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2021/11/encoded-text.png" decoding="async" loading="lazy" class="aligncenter size-full wp-image-76567" src="../Images/7eac5d48eccf2fa69f682b8c22b6579f.png" alt="Encoded Text" srcset="https://blog.logrocket.com/wp-content/uploads/2021/11/encoded-text.png 418w, https://blog.logrocket.com/wp-content/uploads/2021/11/encoded-text-300x44.png 300w" sizes="(max-width: 418px) 100vw, 418px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2021/11/encoded-text.png"/></noscript>
<p>首先，我们创建了一个名为<code>alphabets</code>的变量，在其中我们写了所有的字母表字母。然后，我们创建了一个名为<code>encrypt_ceaser(num, text)</code>的函数，我们将在其中放置 shift 键和需要加密的文本。</p>
<pre>for k in text.lower():</pre>
<p>通过使用一个<code>for</code>循环，我们将以小写形式插入输入字符串。</p>
<pre>for k in text.lower():
 try:
    i = (alphabets.index(k) - num) % 26
     results += key[i]
   except ValueError:
    results += k
  return results.lower()</pre>
<p><code>try</code>方法和<code>except</code>方法，<code>ValueError</code>，用于捕捉程序间的错误。在<code>try</code>之后，我们用<code>index</code> <em>对字符串中的字母进行计数。</em></p>
<p>文本中的所有字母用 shift 键相加，然后除以 26。一旦循环完成，字母将按照移位值移位。</p>
<pre>num =int(input("Please input the shift:\t"))
text=input("Please input the text: \t")
ciphertext = decrypt_caesar(num, text)
print ("Decoded text:",ciphertext)
</pre>
<p>使用<code>input()</code>方法，我们为程序获取用户输入。然后，在密文中创建一个变量，我们称之为<code>encrypt_caesar( num, text)</code>。<code>print</code>语句用于打印编码后的密文。</p>
<p>现在，为了解密文本，我们将减去相同的密钥值:<code>3</code></p>
<pre>alphabets= 'abcdefghijklmnopqrstuvwxyz'
def decrypt_caesar(num, text):
 results = ''
 for k in text.lower():
  try:
    i = (alphabets.index(k) - num) % 26
    results +=alphabets[i]
  except ValueError:
   results += k
 return results.lower()
num =int(input("please input the shift:\t"))
text=input("please input the text: \t")
ciphertext = decrypt_caesar(num, text)
print(“Decoded text:”,ciphertext)</pre>
<p>这是解密文本的结果。</p>
<p><img data-attachment-id="76570" data-permalink="https://blog.logrocket.com/implementing-cryptography-python/decoded-text/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2021/11/decoded-text.png" data-orig-size="407,63" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Decoded text" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2021/11/decoded-text-300x46.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2021/11/decoded-text.png" decoding="async" class="aligncenter size-full wp-image-76570 jetpack-lazy-image" src="../Images/5a89c9df8927eddf7721241dc0014739.png" alt="Decoded Text" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2021/11/decoded-text.png 407w, https://blog.logrocket.com/wp-content/uploads/2021/11/decoded-text-300x46.png 300w" data-lazy-sizes="(max-width: 407px) 100vw, 407px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2021/11/decoded-text.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2021/11/decoded-text.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="76570" data-permalink="https://blog.logrocket.com/implementing-cryptography-python/decoded-text/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2021/11/decoded-text.png" data-orig-size="407,63" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Decoded text" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2021/11/decoded-text-300x46.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2021/11/decoded-text.png" decoding="async" loading="lazy" class="aligncenter size-full wp-image-76570" src="../Images/5a89c9df8927eddf7721241dc0014739.png" alt="Decoded Text" srcset="https://blog.logrocket.com/wp-content/uploads/2021/11/decoded-text.png 407w, https://blog.logrocket.com/wp-content/uploads/2021/11/decoded-text-300x46.png 300w" sizes="(max-width: 407px) 100vw, 407px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2021/11/decoded-text.png"/></noscript>
<p>尽管这个程序与我们之前创建的程序非常相似，但我们还是做了一些小的改动来解密文本。</p>
<p>我们没有使用<code>i = (alphabets.index(k) + num)</code> % 26，而是在<code>i = (alphabets.index(k) - num) % 26</code>中使用了一个<code>-</code>来解码密文。</p>
<h2>非对称密钥加密</h2>
<p>非对称密钥加密比对称加密更复杂、更慢。也称为公钥加密，它涉及使用两个不同的密钥(有时更多)来加密和解密数据。</p>
<p>本质上，公钥将用于加密数据，只有相应的私钥才能解密数据，从而使非对称密钥更加安全。</p><div class="code-block code-block-54">
<hr/>
<h3>更多来自 LogRocket 的精彩文章:</h3>

<hr/></div>
<p>例如，在阅读这篇博文时，你正在使用非对称加密技术。您的 HTTPS 网站 URL 旁边的锁状符号表示您已使用 SSL/TLS 证书安全地连接到该网站。</p>
<p>非对称密钥加密验证服务器的身份并创建非对称加密。</p>
<p><a href="https://cheapsslsecurity.com/blog/what-is-asymmetric-encryption-understand-with-simple-examples/" target="_blank" rel="noopener">非对称密钥算法</a>的一些例子有:</p>
<ul>
<li>里维斯特-沙米尔-阿德曼(RSA)</li>
<li>数字签名算法(DSA)</li>
<li>椭圆曲线密码(ECC)</li>
</ul>
<p>让我们使用名为<a href="https://pycryptodome.readthedocs.io/en/latest/src/introduction.html" target="_blank" rel="noopener"> Cryptodome </a>的 Python 包用 Python 生成一个 RSA 密钥:</p>
<pre>from Crypto.PublicKey import RSA
key = RSA.generate(3072)
file= open('Rsakey.pem','wb')
file.write(key.exportKey('PEM'))
file.close()</pre>
<p>让我们安装 Cryptodome:</p>
<pre>pip install cryptodome</pre>
<p>为了生成一个密钥，我们将使用<code>key.generate(bit size)</code>。<code>bit size</code>必须在 2048-4096 之间，以确保密钥的安全和长度。</p>
<pre>file = open('Rsakey.pem','wb')</pre>
<p>这里，<code>wb</code>* *的意思是“用二进制写。”</p>
<p>接下来，让我们创建一个<code>.pem</code> ( <a href="https://en.wikipedia.org/wiki/Privacy-Enhanced_Mail" target="_blank" rel="noopener">隐私增强邮件</a>)，一种用于存储密钥和证书的文件格式</p>
<pre>file.write(key.exportkey('PEM'))</pre>
<p>我们将使用<code>.write</code>函数打印文件中的密钥，并使用<code>.exportkey</code>以 PEM 格式导出文件。最后，我们将使用<code>file.close</code>关闭文件。</p>
<p>打开<code>Rsakey.pem file</code>:</p>
<p><img data-attachment-id="76572" data-permalink="https://blog.logrocket.com/implementing-cryptography-python/rsakey-pem-file/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2021/11/rsakey-pem-file.png" data-orig-size="561,743" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Rsakey.pem file" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2021/11/rsakey-pem-file-227x300.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2021/11/rsakey-pem-file.png" decoding="async" class="aligncenter size-full wp-image-76572 jetpack-lazy-image" src="../Images/281622f3b57f52faf1831168245f5b52.png" alt="Rsakey.pem File" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2021/11/rsakey-pem-file.png 561w, https://blog.logrocket.com/wp-content/uploads/2021/11/rsakey-pem-file-227x300.png 227w" data-lazy-sizes="(max-width: 561px) 100vw, 561px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2021/11/rsakey-pem-file.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2021/11/rsakey-pem-file.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="76572" data-permalink="https://blog.logrocket.com/implementing-cryptography-python/rsakey-pem-file/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2021/11/rsakey-pem-file.png" data-orig-size="561,743" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Rsakey.pem file" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2021/11/rsakey-pem-file-227x300.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2021/11/rsakey-pem-file.png" decoding="async" loading="lazy" class="aligncenter size-full wp-image-76572" src="../Images/281622f3b57f52faf1831168245f5b52.png" alt="Rsakey.pem File" srcset="https://blog.logrocket.com/wp-content/uploads/2021/11/rsakey-pem-file.png 561w, https://blog.logrocket.com/wp-content/uploads/2021/11/rsakey-pem-file-227x300.png 227w" sizes="(max-width: 561px) 100vw, 561px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2021/11/rsakey-pem-file.png"/></noscript>
<h2>散列法</h2>
<p>哈希是使用数学算法将任意长度的输入转换为固定大小的文本字符串的过程。这意味着任何大小的文本，不管有多长，都可以通过算法转换成数字和字母的数组。</p>
<p>用于转换文本的数学算法称为哈希函数，输出称为哈希值。散列算法被设计成不可逆的，使它们免受攻击者的攻击。</p>
<p>哈希用于用户验证和存储密码。MD5 和 SHA-1 散列法早期用于身份验证和存储密码，但后来因为不安全而被弃用。目前最安全的算法有<a href="https://en.wikipedia.org/wiki/Argon2" target="_blank" rel="noopener"> Argon2 </a>、<a href="https://auth0.com/blog/hashing-in-action-understanding-bcrypt/" target="_blank" rel="noopener"> bycrpt </a>和<a href="https://cryptobook.nakov.com/mac-and-key-derivation/scrypt" target="_blank" rel="noopener"> scrypt </a>以及<a href="https://cryptobook.nakov.com/mac-and-key-derivation/pbkdf2" target="_blank" rel="noopener"> PBKDF2 </a>。</p>
<p>现在，让我们创建一个简单的散列程序，这样我们就可以加密一个字符串。首先，通过编写以下代码，让我们看看 Python 中有多少种散列算法可用:</p>
<pre>import hashlib
Hash_Algorithms_available = hashlib.algorithms_available
print(Hash_Algorithms_available)

Output: {'sha256', 'md4', 'whirlpool', 'sha384', 'sha224', 'sm3', 'blake2s', 'blake2b', 'ripemd160', 'sha512_256', 'md5', 'sha512_224', 'shake_128', 'sha512', 'sha1', 'sha3_384', 'sha3_256', 'sha3_512', 'md5-sha1', 'shake_256', 'sha3_224'}</pre>
<p>首先，让我们来看一个简单的 MD5 Python 散列程序，因为它是最常见的 Python 散列示例之一:</p>
<pre>import hashlib #importing libraries
module = hashlib.md5() #selecting the hashing module 
module.update(b"You are Awesome ") #inputting the text and b implies bytecode
print(module.hexdigest())</pre>
<p>生成的十六进制为:</p>
<pre>83d38079ecb05b2b0ad97ffa50a951eb</pre>
<p>这里，我们导入了 Python 中可用的模块<code>hashlib</code>，并创建了一个名为<code>module</code>的变量，在这里我们选择了散列时要使用的 Python 散列算法。</p>
<p><code>.update</code>是 hashlib 中的一个内置函数，它将数据作为输入并生成散列。字母<code>b</code>表示该字符串是一个字节字符串，<code>.digest</code>给出了从数据中生成的散列字符串:</p>
<p>现在，让我们看看一个简单的 bcrypt Python 散列程序的运行情况。</p>
<pre>import bcrypt #importing libraries
input_password = b"YouareAwesome!" #inputting the text and b implies bytecode 
hashed_password = bcrypt.hashpw(input_password, bcrypt.gensalt())
print(hashed_password)</pre>
<p>生成的十六进制为:<code>b'$2b$12$ZVMHgLah4CtGM1FGIXeEWusNA23wz1dqEc27a3rwwm9Fa4XVPLVLG'&lt;/code</code></p>
<p><a href="https://pypi.org/project/bcrypt/" target="_blank" rel="noopener"> Bcrypt </a>是 Python 中可用的一个包，可以通过一个简单的 pip 语句安装:</p>
<pre>pip install bcrypt</pre>
<p>然后我们可以导入包<code>import bcrypt</code>并使用<code>bcrypt.hashpw()</code>函数，该函数有两个参数:<code>byte</code>和<code>salt</code>。</p>
<p><code>Salt</code>是散列函数中使用的随机数据，它创建随机字符串并使每个散列不可预测。</p>
<h2>结论</h2>
<p>在本文中，您了解了加密技术以及加密数据的各种方法。我们还为加密和解密创建了一个简单的 Python 程序。</p>
<p>实现加密是非常重要的。当您在数据库中存储密码时，请确保您使用的是最新、最强的加密和哈希标准。</p>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
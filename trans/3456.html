<html>
<head>
<title>Building a REST API with Elixir and Phoenix - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>用Elixir和Phoenix - LogRocket博客构建REST API</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/build-rest-api-elixir-phoenix/#0001-01-01">https://blog.logrocket.com/build-rest-api-elixir-phoenix/#0001-01-01</a></blockquote><div><article class="article-post">
<p>Phoenix是2022年最受开发人员喜爱的框架，而且是遥遥领先。作为Elixir生态系统的一部分，它非常适合web开发，它的可靠性和可伸缩性使它成为任何项目的好选择。</p>
<p>在本教程中，我们将探索什么是Elixir，Phoenix web框架，以及如何使用Elixir和Phoenix为您的项目构建REST API。</p>
<p><em>向前跳过</em></p>

<h2 id="what-is-elixir-and-phoenix-web-framework">什么是仙丹和凤凰网框架？</h2>
<p>Elixir是一种构建在Erlang之上的功能性动态类型语言。开发Elixir的Jose Valim在Ruby on Rails团队工作，当他试图用Ruby on Rails和Erlang解决性能瓶颈时，他创建了这个程序。</p>
<p>因此，Elixir的语法与Ruby on Rails的语法有许多相似之处。</p>
<p>Elixir主要用于创建高度可伸缩的应用程序，这些应用程序具有容错性且易于维护。酏剂的一些主要特征是:</p>
<ol>
<li>它将代码编译成运行在Erlang VM上的字节码</li>
<li>它强调高阶函数和递归</li>
<li>强大的模式匹配</li>
<li>它是一种动态类型语言，所以它在运行时而不是编译时检查所有类型</li>
</ol>
<h2 id="benefits-of-elixir">长生不老药的好处</h2>
<p>由于Elixir构建于Erlang VM BEAM之上，因此它具有一些有助于构建优秀应用程序的关键特性。这些特征是:</p>
<ol>
<li><strong>并发</strong> : Elixir使用进程线程来执行。这些线程是隔离的、基于CPU的，并通过消息进行通信</li>
<li><strong>可伸缩性</strong>:伸缩一个Elixir应用程序很简单，因为它使用轻量级线程，可以用很少的进程运行</li>
<li><strong>可靠性</strong>:构建容错应用是Elixir的主要特性之一。当Elixir应用程序在生产中失败时，监管系统会快速重启轻量级流程，从而减少停机时间</li>
</ol>
<p>当构建web应用程序时，每次都很难从零开始构建基本功能，这就是Phoenix web framework的用武之地。</p>
<h2 id="introduction-to-phoenix">凤凰城简介</h2>
<p><a href="https://blog.logrocket.com/create-graphql-api-react-phoenix-2/"> Phoenix </a>是Elixir生态系统中的一个web框架。它带有开箱即用的模块，有助于构建高度可伸缩和容错的应用程序。Phoenix是一个模型-视图-控制器(MVC)框架，类似于Ruby on Rails和Django。</p>
<p>Phoenix framework的杀手锏之一是<a href="https://hexdocs.pm/phoenix_live_view/Phoenix.LiveView.html" rel="noopener"> LiveView </a>。Phoenix LiveView是一个构建在Phoenix之上的库，有助于构建实时应用程序，而无需编写客户端JavaScript。它计算页面变化并通过WebSocket推送更新。</p>
<h2 id="how-phoenix-works">菲尼克斯是如何工作的</h2>
<p><a href="https://hexdocs.pm/plug/readme.html">插头</a>是凤凰的基本元素。插件是一种用功能组成web应用程序的规范——Phoenix接收一个传入的请求，并将其转换为<a href="https://hexdocs.pm/plug/Plug.Conn.html" rel="noopener"> Conn </a>，这是一种处理HTTP连接中的请求和响应的数据结构。</p>
<p><img data-attachment-id="136281" data-permalink="https://blog.logrocket.com/build-rest-api-elixir-phoenix/attachment/phoenix-plugs-web-app-functions/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/10/phoenix-plugs-web-app-functions.png" data-orig-size="730,191" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="phoenix-plugs-web-app-functions" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/10/phoenix-plugs-web-app-functions-300x78.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/10/phoenix-plugs-web-app-functions.png" decoding="async" class="aligncenter wp-image-136281 size-full jetpack-lazy-image" src="../Images/fa40df089d544bbd963bbd4bc30ca4cc.png" alt="Phoenix Plugs Web App Functions" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2022/10/phoenix-plugs-web-app-functions.png 730w, https://blog.logrocket.com/wp-content/uploads/2022/10/phoenix-plugs-web-app-functions-300x78.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2022/10/phoenix-plugs-web-app-functions.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/10/phoenix-plugs-web-app-functions.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="136281" data-permalink="https://blog.logrocket.com/build-rest-api-elixir-phoenix/attachment/phoenix-plugs-web-app-functions/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/10/phoenix-plugs-web-app-functions.png" data-orig-size="730,191" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="phoenix-plugs-web-app-functions" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/10/phoenix-plugs-web-app-functions-300x78.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/10/phoenix-plugs-web-app-functions.png" decoding="async" loading="lazy" class="aligncenter wp-image-136281 size-full" src="../Images/fa40df089d544bbd963bbd4bc30ca4cc.png" alt="Phoenix Plugs Web App Functions" srcset="https://blog.logrocket.com/wp-content/uploads/2022/10/phoenix-plugs-web-app-functions.png 730w, https://blog.logrocket.com/wp-content/uploads/2022/10/phoenix-plugs-web-app-functions-300x78.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/10/phoenix-plugs-web-app-functions.png"/></noscript>
<p>数据结构通过几个插件来完成功能并返回响应。为了简化它:</p>
<ol>
<li>收到请求</li>
<li>将其转换为<code>conn</code></li>
<li>穿过几个塞子</li>
<li>返回响应</li>
</ol>
<h2 id="lifecycle-of-phoenix-requests">凤凰请求的生命周期</h2>
<p>正如我们已经注意到的，phoenix中的传入请求要经过几个插件才能返回所需的响应——让我们来看看插件和流程的细节:</p>
<p><img data-attachment-id="136283" data-permalink="https://blog.logrocket.com/build-rest-api-elixir-phoenix/attachment/incoming-request-to-endpoints/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/10/incoming-request-to-endpoints.png" data-orig-size="730,520" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="incoming-request-to-endpoints" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/10/incoming-request-to-endpoints-300x214.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/10/incoming-request-to-endpoints.png" decoding="async" class="aligncenter wp-image-136283 size-full jetpack-lazy-image" src="../Images/d8cf125437199d9af2c6aa9b9abbb176.png" alt="Incoming Request To Endpoints" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2022/10/incoming-request-to-endpoints.png 730w, https://blog.logrocket.com/wp-content/uploads/2022/10/incoming-request-to-endpoints-300x214.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2022/10/incoming-request-to-endpoints.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/10/incoming-request-to-endpoints.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="136283" data-permalink="https://blog.logrocket.com/build-rest-api-elixir-phoenix/attachment/incoming-request-to-endpoints/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/10/incoming-request-to-endpoints.png" data-orig-size="730,520" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="incoming-request-to-endpoints" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/10/incoming-request-to-endpoints-300x214.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/10/incoming-request-to-endpoints.png" decoding="async" loading="lazy" class="aligncenter wp-image-136283 size-full" src="../Images/d8cf125437199d9af2c6aa9b9abbb176.png" alt="Incoming Request To Endpoints" srcset="https://blog.logrocket.com/wp-content/uploads/2022/10/incoming-request-to-endpoints.png 730w, https://blog.logrocket.com/wp-content/uploads/2022/10/incoming-request-to-endpoints-300x214.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/10/incoming-request-to-endpoints.png"/></noscript>
<p>Phoenix在端点接收一个请求，端点将它转换成一个<code>Conn</code>数据结构，转发给路由器。</p>
<p>路由器将<code>Conn</code>数据结构通过管道传输到控制器，控制器与模型进行交互，从数据库中获取数据，并使用模板进行渲染。模板可以是HTML或JSON文件。在这里，端点、路由器和控制器是插件Phoenix中的一切都是可组合的函数，将数据转换成不同的结构。</p>
<h2 id="rest-api-using-elixir-and-phoenix">使用Elixir和Phoenix创建REST API</h2>
<p>现在我们已经熟悉了Phoenix web框架，让我们用Elixir和Phoenix构建一个REST API用于一个项目。这里，我们将创建一个REST API，它将<code>users</code>信息传递给Postgres数据库。</p>
<p>API将在<code>/api/users</code>下提供用户信息，包括GET、PUT、POST、DELETE请求。</p>
<p>为此，我们需要使用存储在数据库中的必需字段创建数据库模式:</p>
<ol>
<li><code>id</code> →表中主键。</li>
<li><code>name</code> →字符串包含用户名。</li>
<li><code>email</code> →邮箱字段，应该是唯一的。</li>
<li><code>role</code> →用户角色。</li>
<li><code>address</code> →用户地址。</li>
</ol>
<h2 id="prerequisites">先决条件</h2>
<p>在您继续之前，我建议您满足以下先决条件:</p>
<ol>
<li>对Elixir语法的基本理解。你可以参考<a href="https://elixir-lang.org/getting-started/introduction.html" rel="noopener">官方文档</a>来开始使用语法</li>
<li>在你的机器上安装药剂。我们将在下一节讨论如何安装Elixir</li>
<li>在你的机器上安装Postgres。或者，您可以使用Docker运行Postgres(这是我们将在本教程中做的)</li>
<li>使用Postman客户端或替代方法来测试API</li>
</ol>
<h2 id="getting-started">入门指南</h2>
<p>首先，让我们在您的机器上安装Elixir。要在macOS上安装elixir，可以使用家酿软件包管理器。</p>
<p><strong>在</strong> <strong> macOS上安装仙丹</strong></p>
<p>安装前，使用以下工具更新Homebrew:</p>
<pre>$ brew update
</pre>
<p>此后，您可以使用以下方法安装Elixir:</p>
<pre>$ brew install elixir
</pre>
<p>你还需要安装药剂包管理器<a href="https://hex.pm/"> Hex </a>。运行以下命令安装Hex:</p>
<pre>$ mix local.hex
</pre>
<p>要验证安装是否成功，您可以运行以下命令来检查版本:</p>
<pre>$ elixir -v
</pre>
<p><img data-attachment-id="136292" data-permalink="https://blog.logrocket.com/build-rest-api-elixir-phoenix/attachment/verify-elixir-installation-successful/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/10/verify-elixir-installation-successful.png" data-orig-size="730,57" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="verify-elixir-installation-successful" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/10/verify-elixir-installation-successful-300x23.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/10/verify-elixir-installation-successful.png" decoding="async" class="aligncenter wp-image-136292 size-full jetpack-lazy-image" src="../Images/26c03c98747671c04dfeac9497969cb8.png" alt="Verify Elixir Installation Successful" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2022/10/verify-elixir-installation-successful.png 730w, https://blog.logrocket.com/wp-content/uploads/2022/10/verify-elixir-installation-successful-300x23.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2022/10/verify-elixir-installation-successful.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/10/verify-elixir-installation-successful.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="136292" data-permalink="https://blog.logrocket.com/build-rest-api-elixir-phoenix/attachment/verify-elixir-installation-successful/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/10/verify-elixir-installation-successful.png" data-orig-size="730,57" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="verify-elixir-installation-successful" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/10/verify-elixir-installation-successful-300x23.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/10/verify-elixir-installation-successful.png" decoding="async" loading="lazy" class="aligncenter wp-image-136292 size-full" src="../Images/26c03c98747671c04dfeac9497969cb8.png" alt="Verify Elixir Installation Successful" srcset="https://blog.logrocket.com/wp-content/uploads/2022/10/verify-elixir-installation-successful.png 730w, https://blog.logrocket.com/wp-content/uploads/2022/10/verify-elixir-installation-successful-300x23.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/10/verify-elixir-installation-successful.png"/></noscript>
<p>(注:对于其他操作系统，您可以参考<a href="https://elixir-lang.org/install.html" rel="noopener"> Elixir官方指南</a>，它提供了简单的安装分步指南)</p>
<p><strong>安装凤凰</strong></p>
<p>现在我们已经安装了Elixir，让我们使用Phoenix框架启动一个项目来构建一个REST API。</p>
<pre class="language-elixir">$ mix archive.install hex phx_new 1.5.3
</pre>
<p>这将在您的计算机上安装Phoenix 1.5.3。要创建一个新项目，您需要在终端中运行以下命令:</p>
<pre class="language-elixir">$ mix phx.new users_api --no-html --no-webpack --binary-id 

$ cd users_api
</pre>
<p>这将创建一个users_api目录，其中包含Phoenix应用程序的所有样板文件。它遵循这样的目录结构:</p>
<pre class="language-elixir">├── _build
├── assets
├── config
├── deps
├── lib
│   ├── hello
│   ├── hello.ex
│   ├── hello_web
│   └── hello_web.ex
├── priv
└── test
</pre>
<p>(注:凤凰官方文档详细解释了目录结构，可以参考<a href="https://hexdocs.pm/phoenix/directory_structure.html" rel="noopener">这里</a>)</p>
<p><code>--no-html</code>和<code>--no-webpack</code>参数指示命令不要生成HTML文件和静态资产，因为我们只构建了一个REST API。</p>
<p><code>--binary-id</code>将配置Ecto对数据库模式(如主键值)使用UUID。</p>
<p>现在，我们将用样板代码搭建应用程序。让我们运行Postgres数据库，并将应用程序连接到数据库。</p>
<h2 id="setup-and-configure-database">设置和配置数据库</h2>
<p>首先，确保你在你的机器上安装了<a href="https://docs.docker.com/engine/install/" rel="noopener"> Docker </a>。通过Docker运行Postgres很简单；只需要运行以下命令:</p>
<pre class="language-elixir">$ docker run --name phoenix-postgres -e POSTGRES_USER=postgres -e POSTGRES_PASSWORD=postgres -p 5500:5432 -d postgres
</pre>
<p>这里，我们为Docker容器指定了<code>--name</code>，为<code>POSTGRES_USER</code>和<code>POSTGRES_PASSWORD</code>指定了环境。我们还需要通过指定<code>-p</code>来映射端口。最后，我们以分离模式提取Docker图像。</p><div class="code-block code-block-54">
<hr/>
<h3>更多来自LogRocket的精彩文章:</h3>

<hr/></div>
<p>Postgres启动并运行后，我们在Phoenix应用程序中配置数据库。Phoenix提供了一个配置目录来设置应用程序中的数据库、cron作业、记录器和堆栈跟踪。</p>
<p>要在开发环境中配置数据库，请用Postgres数据库凭证更改<code>config/dev.exs</code>。</p>
<pre class="language-elixir"># Configure your database
config :users_api, UsersApi.Repo,
  username: "postgres",
  password: "postgres",
  database: "users_api_dev",
  hostname: "localhost",
  port: "5500",
  show_sensitive_data_on_connection_error: true,
  pool_size: 10
</pre>
<p>之后，您可以为开发环境创建一个数据库，如下所示:</p>
<pre>$ mix ecto.create
</pre>
<p>您可以使用以下命令删除数据库:</p>
<pre>$ mix ecto.drop
</pre>
<h2 id="schema-and-migration">模式和迁移</h2>
<p>创建数据库并在应用程序中进行配置后，您需要对数据进行建模，以便在应用程序中访问它。</p>
<p><strong>凤凰语境</strong></p>
<p>在我们开始模式设计之前，了解Phoenix <a href="https://hexdocs.pm/phoenix/contexts.html" rel="noopener">上下文</a>很重要。上下文是将相关功能组合在一起的模块。当你设计一个应用程序时，Phoenix会帮助你根据上下文对模块进行分组。把它想象成领域驱动设计中的领域。</p>
<p>上下文将根据功能将不同的模块组合在一起。</p>
<p>举个例子，Elixir <code>Logger.info/1</code>由几个模块组成，但是我们可以在单个<code>Logger</code>模块上下文中访问这些模块。</p>
<p>要为建模创建上下文，您可以在应用程序中使用Phoenix generator命令:</p>
<pre class="language-elixir">$ mix phx.gen.context Admin User users 
  name:string email:string:unique role:string address:string
</pre>
<p>在这里，我们有:</p>
<ul>
<li><code>Admin</code>，作为上下文的模块名</li>
<li><code>User</code>，作为模式的模块名</li>
<li><code>Users</code>，作为数据库表名</li>
</ul>
<p>要在生成数据库表时定义<code>users</code>字段及其类型，可以参考<a href="https://hexdocs.pm/phoenix/Mix.Tasks.Phx.Gen.Schema.html" rel="noopener">十六进制文档</a>中的schema字段定义。</p>
<p>一旦运行该命令，它将创建包含模式定义的<code>lib/admin/user.ex</code>。</p>
<pre class="language-elixir">defmodule UsersApi.Admin.User do
  use Ecto.Schema
  import Ecto.Changeset
  @primary_key {:id, :binary_id, autogenerate: true}
  @foreign_key_type :binary_id
  schema "users" do
    field :address, :string
    field :email, :string
    field :name, :string
    field :role, :string
    timestamps()
  end
  @doc false
  def changeset(user, attrs) do
    user
    |&gt; cast(attrs, [:name, :email, :role, :address])
    |&gt; validate_required([:name, :email, :role, :address])
    |&gt; unique_constraint(:email)
  end
end
</pre>
<p>它还为<code>users_api/admin.ex</code>中的<code>users</code>模块搭建了REST API。</p>
<pre class="language-elixir">defmodule UsersApi.Admin do
  @moduledoc """
  The Admin context.
  """
  import Ecto.Query, warn: false
  alias UsersApi.Repo
  alias UsersApi.Admin.User
  @doc """
  Returns the list of users.
  ## Examples
      iex&gt; list_users()
      [%User{}, ...]
  """
  def list_users do
    Repo.all(User)
  end
  @doc """
  Gets a single user.
  Raises `Ecto.NoResultsError` if the User does not exist.
  ## Examples
      iex&gt; get_user!(123)
      %User{}
      iex&gt; get_user!(456)
      ** (Ecto.NoResultsError)
  """
  def get_user!(id), do: Repo.get!(User, id)
  @doc """
  Creates a user.
  ## Examples
      iex&gt; create_user(%{field: value})
      {:ok, %User{}}
      iex&gt; create_user(%{field: bad_value})
      {:error, %Ecto.Changeset{}}
  """
  def create_user(attrs \\ %{}) do
    %User{}
    |&gt; User.changeset(attrs)
    |&gt; Repo.insert()
  end
  @doc """
  Updates a user.
  ## Examples
      iex&gt; update_user(user, %{field: new_value})
      {:ok, %User{}}
      iex&gt; update_user(user, %{field: bad_value})
      {:error, %Ecto.Changeset{}}
  """
  def update_user(%User{} = user, attrs) do
    user
    |&gt; User.changeset(attrs)
    |&gt; Repo.update()
  end
  @doc """
  Deletes a user.
  ## Examples
      iex&gt; delete_user(user)
      {:ok, %User{}}
      iex&gt; delete_user(user)
      {:error, %Ecto.Changeset{}}
  """
  def delete_user(%User{} = user) do
    Repo.delete(user)
  end
  @doc """
  Returns an `%Ecto.Changeset{}` for tracking user changes.
  ## Examples
      iex&gt; change_user(user)
      %Ecto.Changeset{data: %User{}}
  """
  def change_user(%User{} = user, attrs \\ %{}) do
    User.changeset(user, attrs)
  end
end
</pre>
<h2 id="running-migration">运行迁移</h2>
<p>要为定义的数据模式运行迁移，您需要运行以下命令:</p>
<pre class="language-elixir">$ mix ecto.migrate
</pre>
<p>一旦您运行迁移，它将在数据库中创建一个包含已定义字段的表，就像模式中一样。</p>
<h2 id="scaffolding-controller-and-view">脚手架控制器和视图</h2>
<p>现在，我们已经在应用程序中定义了数据库模式和模型，我们需要将它与控制器和视图连接起来以返回响应。</p>
<p>为了生成特定模块的控制器和视图，Phoenix提供了一个生成器命令，可以生成样板代码:</p>
<pre class="language-elixir">$ mix phx.gen.json Admin User users 
  name:string email:string:unique role:string address:string --no-context --no-schema
</pre>
<p>上述命令会生成:</p>
<ul>
<li>在<code>lib/users_api_web/controllers/users_controller.ex</code>为用户提供CRUD控制器</li>
<li>查看，在<code>lib/users_api_web/view/users_view.ex</code>呈现用户的JSON</li>
</ul>
<p>我们还提到了<code>--no-context</code>和<code>--no-schema</code>，因为我们已经在创建数据库模式时生成了它们。</p>
<p>Phoenix还提供了<code>users_api_web/controllers/fallback_controller.ex</code>来处理错误和任何故障的回退。我们可以编辑它们来处理不同的错误代码。例如，您可以编辑回退控制器来处理<code>UnAuthorized</code>错误。</p>
<pre class="language-elixir">defmodule MyFallbackController do
  use Phoenix.Controller

  def call(conn, {:error, :not_found}) do
    conn
    |&gt; put_status(:not_found)
    |&gt; put_view(MyErrorView)
    |&gt; render(:"404")
  end

  def call(conn, {:error, :unauthorized}) do
    conn
    |&gt; put_status(403)
    |&gt; put_view(MyErrorView)
    |&gt; render(:"403")
  end
end
</pre>
<p>默认情况下，Phoenix在主控制器中配置后备控制器——您可以在<code>users_api_web/controllers/user_controller.ex</code>中更改它们。</p>
<pre class="language-elixir">  action_fallback UsersApiWeb.FallbackController
</pre>
<p>一旦创建了控制器和视图，就需要在<code>lib/users_api_web/router.ex</code>中为控制器添加一条路线。</p>
<pre class="language-elixir">defmodule UsersApiWeb.Router do
  use UsersApiWeb, :router
  pipeline :api do
    plug :accepts, ["json"]
  end
  scope "/api", UsersApiWeb do
    pipe_through :api
    get "/users", UserController, :index
    put "/users", UserController, :edit
    post "/users", UserController, :create
    delete "/users", UserController, :delete
  end
  # Enables LiveDashboard only for development
  #
  # If you want to use the LiveDashboard in production, you should put
  # it behind authentication and allow only admins to access it.
  # If your application does not have an admins-only section yet,
  # you can use Plug.BasicAuth to set up some basic authentication
  # as long as you are also using SSL (which you should anyway).
  if Mix.env() in [:dev, :test] do
    import Phoenix.LiveDashboard.Router
    scope "/" do
      pipe_through [:fetch_session, :protect_from_forgery]
      live_dashboard "/dashboard", metrics: UsersApiWeb.Telemetry
    end
  end
end
</pre>
<p>如您所见，您可以将不同的路由组合成一个端点。在这里，我们将所有的<code>/users</code>路由嵌套在<code>/api</code>范围内。在<code>/api</code>范围内，我们为<code>Users</code> API配置CRUD。</p>
<p>还有另一个为模块配置CRUD请求的简化版本。我们可以使用Phoenix路由器模块中的<code>resources</code>:</p>
<pre class="language-elixir">resources "/users", UserController
</pre>
<p>通过这样配置它的<code>resources</code>;它简化了一行中的所有请求。</p>
<pre class="language-elixir"> scope "/api", UsersApiWeb do
    pipe_through :api
    resources "/users", UserController, except: [:new, :edit]
</pre>
<p>现在，您可以使用以下代码运行应用程序:</p>
<pre class="language-elixir">$ mix phx.server
</pre>
<p><img data-attachment-id="136297" data-permalink="https://blog.logrocket.com/build-rest-api-elixir-phoenix/attachment/run-the-application-compiling/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/10/run-the-application-compiling.png" data-orig-size="730,139" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="run-the-application-compiling" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/10/run-the-application-compiling-300x57.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/10/run-the-application-compiling.png" decoding="async" class="aligncenter wp-image-136297 size-full jetpack-lazy-image" src="../Images/1d6b7ac811aa83e6da2e757c44fd7fba.png" alt="Run The Application Compiling" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2022/10/run-the-application-compiling.png 730w, https://blog.logrocket.com/wp-content/uploads/2022/10/run-the-application-compiling-300x57.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2022/10/run-the-application-compiling.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/10/run-the-application-compiling.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="136297" data-permalink="https://blog.logrocket.com/build-rest-api-elixir-phoenix/attachment/run-the-application-compiling/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/10/run-the-application-compiling.png" data-orig-size="730,139" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="run-the-application-compiling" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/10/run-the-application-compiling-300x57.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/10/run-the-application-compiling.png" decoding="async" loading="lazy" class="aligncenter wp-image-136297 size-full" src="../Images/1d6b7ac811aa83e6da2e757c44fd7fba.png" alt="Run The Application Compiling" srcset="https://blog.logrocket.com/wp-content/uploads/2022/10/run-the-application-compiling.png 730w, https://blog.logrocket.com/wp-content/uploads/2022/10/run-the-application-compiling-300x57.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/10/run-the-application-compiling.png"/></noscript>
<h2 id="conclusion">结论</h2>
<p>你完了！感谢跟随本教程，我希望你觉得有用，并随时在下面的评论中发布你的发现。可以在<a href="http://localhost:4000" rel="nofollow"> http://localhost:4000 </a>测试API，这里可以参考本教程<a href="https://github.com/ganeshmani/phoenix-rest-api-tutorial" rel="noopener">的完整代码。</a></p><div class="code-block code-block-4">
<div class="blog-plug base-cta"><h2>使用<a class="signup" href="https://lp.logrocket.com/blg/signup" target="_blank" rel="noopener noreferrer"> LogRocket </a>消除传统错误报告的干扰</h2>
<a href="https://lp.logrocket.com/blg/signup" class="signup" target="_blank" rel="noopener noreferrer"><img class="alignnone size-full wp-image-46 jetpack-lazy-image" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/><noscript><img data-lazy-fallback="1" class="alignnone size-full wp-image-46" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/></noscript></a>
<p><a href="https://lp.logrocket.com/blg/signup" target="_blank" rel="noopener noreferrer">log火箭</a>是一款数字体验分析解决方案，只需几个真正重要的项目，便可保护您免受数百次假阳性错误警报的影响。LogRocket告诉您在应用程序中实际影响用户的最具影响力的bug和UX问题。</p>
<p>然后，使用具有深层技术遥测的会话重放来确切地查看用户看到了什么以及是什么导致了问题，就像你在他们身后看一样。</p>
<p>LogRocket自动聚合客户端错误、JS异常、前端性能指标和用户交互。然后LogRocket使用机器学习来告诉你哪些问题正在影响大多数用户，并提供你需要修复它的上下文。</p>
<p>关注重要的bug—<a class="signup" href="https://lp.logrocket.com/blg/signup-issue-free" target="_blank" rel="noopener noreferrer">今天就试试LogRocket】。</a></p></div></div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
<html>
<head>
<title>React Server Components in Next.js 12 - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>Next.js 12 - LogRocket 博客中的 React 服务器组件</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/react-server-components-nextjs-12/#0001-01-01">https://blog.logrocket.com/react-server-components-nextjs-12/#0001-01-01</a></blockquote><div><article class="article-post">
<p>人们一直在努力为 React 应用提供一致的渲染解决方案。到 2020 年 12 月，React 团队引入了 React 服务器组件的概念——在本文中缩写为“RSC”——这是他们即将推出的版本 React 18 的一个功能。</p>
<p>RSC 是一个实验性的、选择加入的特性，旨在通过在服务器上呈现包括组件在内的所有内容来减少我们通常交给客户端的工作。这种方法产生零包大小的组件，从而缩短了 web 页面的加载时间。</p>
<p>Next.js 背后的公司 Vercel 一直在与 React 团队合作，推出他们的最新版本 Next.js 12，该版本将 React 18(包括 RSC)直接集成到框架中。<a href="https://nextjs.org/blog/next-12" target="_blank" rel="noopener">查看 Next.js 12 特性的完整列表</a>。</p>
<h2 id="prerequisites">先决条件</h2>
<p>对于本教程，您需要:</p>
<ul>
<li>Node.js 的最新版本</li>
<li>Next.js 的基础知识</li>
<li>React 18 安装在您的项目中</li>
</ul>
<p><em>注意，</em> <em> React 18 还在 alpha 中，</em> <em>它</em> <em>还不适宜在刚刚生产时使用。此外，RSC 将不会与 React 18 </em> <em>的第一个版本一起发布，并且只在某些框架中可用——如</em> <em> Next.js </em> <em>和</em><em>Hydrogen——打着实验的旗号。这篇文章只能作为我们期待稳定版本时的指南。</em></p>
<p>在我们深入 RSC 之前，让我们看看 Next.js 提供的以前的预渲染解决方案</p>
<h2 id="taking-a-look-back">回顾过去</h2>
<p>Next.js 介绍了几种预呈现内容的巧妙技术，包括:</p>
<h3 id="server-side-rendering-ssr">服务器端呈现(SSR)</h3>
<p>在服务器端呈现中，您的应用程序的数据在服务器上提取，并且为每条路线生成 HTML 页面并发送给用户。当收到时，用户的浏览器运行客户端 JavaScript 代码，使生成的 HTML 具有交互性，这就是所谓的水合作用。</p>
<p>这样，当你的用户第一次登陆你的页面时，他们就有内容可以看，而不是提供一个空白的白屏(<em>内心畏缩<em/>–</em>骨架，至少？)同时获取外部数据——单页 React 应用程序就是这种情况。</p>
<h3 id="static-site-generation-ssg">静态站点生成(SSG)</h3>
<p>我们所知道的传统的基于 JavaScript 的网站实际上是静态网站。这里，编译和呈现网站的过程是在运行时在浏览器中完成的。Next.js 通过在构建时编译和呈现网站对此进行了改进。</p>
<p>输出是一堆静态文件、HTML 文件以及 JavaScript 和 CSS 等资产。与 SSR 类似，这种方法为您的用户预先呈现网站的内容，而不依赖于他们的互联网速度来在屏幕上显示内容。</p>
<p>Next.js 还有其他预渲染方法，比如</p>

<p>尽管取得了成功，SSR 和 SSG 都有他们的挫折。SSR 网站的托管成本很高，随着应用程序变大，SSG 会大幅增加构建时间。<a href="https://frontend-digest.com/client-side-rendering-vs-server-side-rendering-vs-static-site-generation-2a0702cbb08d?gi=8064817c7490" target="_blank" rel="noopener">选择前广泛阅读</a>。</p>
<p>这就是英国皇家莎士比亚剧团来帮忙的地方。让我们进入正题吧！</p>
<h2 id="what-do-react-server-components-really-do">React 服务器组件实际上是做什么的？</h2>
<p>简单地说，<a href="https://blog.logrocket.com/what-you-need-to-know-about-react-server-components/" target="_blank" rel="noopener"> React 服务器组件</a>是存储在服务器上的组件。因此，它们有两个主要优势:</p>
<ul>
<li>直接访问后端/数据库，这使得获取数据更快</li>
<li>它们对应用程序的整体包大小没有任何影响。有了它，您甚至可以为您可能需要的任何功能导入大型库:</li>
</ul>
<div>
<pre class="language-bash hljs">npm install largest-package</pre>
</div>
<p>但是，因为 RSC 没有连接到浏览器，所以它们没有客户端交互性，因此不能管理状态。这意味着不支持像<code>useState</code>、<code>useEffect</code>和<a href="https://nextjs.org/docs/advanced-features/react-18#unsupported-nextjs-apis" target="_blank" rel="noopener">这样的钩子以及其他一些 next . js API</a>。</p>
<p>当与客户端组件和<code>Suspense</code>结合使用时，React 服务器组件——使用<code>.server.js</code>扩展创建——可以通过 HTTP 流预呈现内容。</p>
<p><a href="https://www.pubnub.com/learn/glossary/what-is-http-streaming/" target="_blank" rel="noopener"> HTTP 流</a>是一种推式数据传输技术，它允许 web 服务器通过一个保持无限开放的 HTTP 连接向客户端连续发送数据。这是在服务器和客户端之间传输动态数据的有效方法。</p>
<p>举个例子:</p>
<pre class="language-javascript hljs">// my-rsc.server.js
import {db} from 'database'

// access backend 
const posts = db.posts.get(id);

return (
  &lt;Page&gt;
  &lt;Suspense fallback={&lt;Spinner/&gt;}&gt; 
      &lt;BlogPosts posts={posts} /&gt;
    &lt;Suspense/&gt;
    &lt;Footer /&gt;
  &lt;Page/&gt;
)
</pre>
<p>当点击这个路径时，组件呈现页面上的所有内容，同时显示一个回退组件<code>Spinner</code>作为<code>BlogPosts</code>的后台数据。返回的数据随后流入客户端组件<code>BlogPosts</code>。</p>
<p>本质上，<code>Suspense</code>阻止需要额外计算的子组件阻塞整个应用程序，从而让我们击败标准的 React 瀑布架构。</p>
<h2 id="using-react-server-components-in-nextjs-12">在 Next.js 12 中使用 React 服务器组件</h2>
<p>可以通过在终端中运行以下命令来安装 Next.js 12:</p>
<pre class="language-bash hljs">npx create-next-app nextjs12-project
</pre>
<p>这将使用最新版本创建一个新的 Next.js 应用程序。</p>
<p>接下来，使用以下命令安装 React 18 的测试版:</p>
<pre class="language-bash hljs">npm install <a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="dcb2b9a4a89cb0bda8b9afa8">[email protected]</a> <a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="3a485f5b594e7a585f4e5b">[email protected]</a> <a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="9deff8fcfee9b0f9f2f0ddfff8e9fc">[email protected]</a>
</pre>
<p>这将 React 版本更新到 18。</p>
<p>下载完成后，继续编辑位于文件夹根目录下的<code>next.config.js</code>文件，并添加以下代码:</p>
<pre class="language-javascript hljs">// next.config.js
module.exports = {
  experimental: {
    concurrentFeatures: true,
    serverComponents: true,
  },
}
</pre>
<p>这个配置同时启用 React 服务器组件和<a href="https://reactjs.org/docs/concurrent-mode-suspense.html#what-is-suspense-exactly" target="_blank" rel="noopener">并发模式</a>。</p>
<p>并发模式使 React 应用程序能够保持响应，并根据用户的设备功能和网络速度进行调整。这个特点就是<a href="https://reactjs.org/docs/concurrent-mode-suspense.html#what-is-suspense-exactly">悬念</a>的来源。</p>
<p>最后，创建一个包含以下内容的<code>pages/_document.js</code>文件:</p>
<pre class="language-javascript hljs">// _document.js
import { Html, Head, Main, NextScript } from 'next/document'

export default function Document() {
  return (
    &lt;Html&gt;
      &lt;Head /&gt;
      &lt;body&gt;
        &lt;Main /&gt;
        &lt;NextScript /&gt;
      &lt;/body&gt;
    &lt;/Html&gt;
  )
}
</pre>
<p>现在您已经准备好在您的应用程序中使用 RSC 了！</p>
<p>对于本教程，我将使用 Vercel 创建的 Hacker News 项目来解释 RSC 在 Next.js 12 中是如何使用的，而不是从头开始创建一个项目。<a href="https://github.com/vercel/next-rsc-demo" target="_blank" rel="noopener">这里储存库</a>。</p>
<p>打开终端，将存储库克隆到您的首选目录中:</p>
<pre class="language-bash hljs"><a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="b0f3d8d9dec7d9dbd5f0f3d8d9dec7d9dbd5">[email protected]</a> ~/Desktop/codebase/code
λ git clone https://github.com/vercel/next-rsc-demo.git
</pre>
<p>在文本编辑器中打开这个项目，让我们检查一下文件。我们将从<code>pages/index.js</code>开始:</p>
<pre class="language-javascript hljs">// index.js
export default function Page() {
  return (
    &lt;div className="container"&gt;
      {/* code ... */}
      &lt;h1&gt;React Server Components in Next.js&lt;/h1&gt;
      {/* code ... */}
      &lt;h2&gt;React Server Components with Streaming&lt;/h2&gt;
      &lt;section&gt;
        &lt;a href="/rsc" target="_blank"&gt;
          RSC + HTTP Streaming
        &lt;/a&gt;
      &lt;/section&gt;
      {/* code ... */}
    &lt;/div&gt;
  );
}
</pre>
<p>这个索引页面包含其他路线的链接，每个路线都显示相同的黑客新闻应用程序，但呈现方法不同。</p><div class="code-block code-block-54">
<hr/>
<h3>更多来自 LogRocket 的精彩文章:</h3>

<hr/></div>
<p>我们将重点关注<code>pages/rsc.server.js</code>中的 RSC 方法:</p>
<pre class="language-javascript hljs">// rsc.server.js
import { Suspense } from 'react'

// Shared Components
import Spinner from '../components/spinner'

// Server Components
import SystemInfo from '../components/server-info.server'

// Client Components
import Page from '../components/page.client'
import Story from '../components/story.client'
import Footer from '../components/footer.client'

// Utils
import fetchData from '../lib/fetch-data'
import { transform } from '../lib/get-item'
import useData from '../lib/use-data'

function StoryWithData({ id }) {
  const data = useData(`s-${id}`, () =&gt; fetchData(`item/${id}`).then(transform))
  return &lt;Story {...data} /&gt;
}

function NewsWithData() {
  const storyIds = useData('top', () =&gt; fetchData('topstories'))
  return (
    &lt;&gt;
      {storyIds.slice(0, 30).map((id) =&gt; {
        return (
          &lt;Suspense fallback={&lt;Spinner /&gt;} key={id}&gt;
            &lt;StoryWithData id={id} /&gt;
          &lt;/Suspense&gt;
        )
      })}
    &lt;/&gt;
  )
}

export default function News() {
  return (
    &lt;Page&gt;
      &lt;Suspense fallback={&lt;Spinner /&gt;}&gt;
        &lt;NewsWithData /&gt;
      &lt;/Suspense&gt;
      &lt;Footer /&gt;
      &lt;SystemInfo /&gt;
    &lt;/Page&gt;
  )
}
</pre>
<p>该组件以博客页面为特色，其中<code>NewsWithData</code>组件——负责获取帖子的组件——被包装在<code>Suspense</code>中:</p>
<pre class="language-javascript hljs">&lt;Suspense fallback={&lt;Spinner /&gt;}&gt;
  &lt;NewsWithData /&gt;
&lt;/Suspense&gt;
</pre>
<p>这里，<code>NewsWithData</code>使用了两个函数<code>fetchData</code>和<code>useData</code>，从 API 中获取所有帖子的<code>storyIds</code>。然后，它为每个帖子设计了一个<code>StoryWithData</code>组件。然后，<br/> <code>StoryWithData</code>使用这些函数获取每个帖子的内容，并将其传输到<code>Story</code>客户端组件。</p>
<pre class="language-javascript hljs">// rsc.server.js 
function StoryWithData({ id }) {
  const data = useData(`s-${id}`, () =&gt; fetchData(`item/${id}`).then(transform))
 // Story is client component imported in a server component
  return &lt;Story {...data} /&gt;
}
</pre>
<p><code>Story.client.js</code>在 UI 中显示帖子，并通过为每个帖子实现 upvotes 来为应用程序添加客户端交互性。</p>
<pre class="language-javascript hljs">// story.client.js
// client components are regularreact components you're already familiar with

// client component can use state
import { useState } from 'react'

export default function Story({
  id,
  title,
  date,
  url,
  user,
  score,
  commentsCount,
}) {
  const { host } = url ? new URL(url) : { host: '#' }
  const [voted, setVoted] = useState(false)
  return (
    <p margin:="">{/*代码...*/}</p>
  )
}</pre>
<p>与<code>pages/csr.js</code>中的客户端渲染方法相比，可以在项目上观察到 RSC 的现场效果。</p>
<p>在节流网络上，使用 CSR 的页面明显较慢，因为浏览器将数据获取与组件的水合作用结合在一起。<a href="https://youtu.be/WlP2TB2ORL4?t=445" target="_blank" rel="noopener">点击这里观看演示</a>。</p>
<h2 id="conclusion">结论</h2>
<p>React 服务器组件是一个惊人的特性，因为它们有效地处理渲染，并让我们构建跨服务器和客户端的应用程序。组件现在可以更快地加载，因为大部分计算都从客户端转移到了服务器组件。RSC 的正式发布将为未来 React 应用程序的架构带来变化。</p>
<h2 id="references">参考</h2>
<p>由于这仍然是一个突破性的话题，请参考以下材料了解更多信息:</p>

<p> </p><div class="code-block code-block-17">
<div class="blog-plug inline-plug react-plug" vwo-el-id="26283398190">
<h2 vwo-el-id="41600691720">使用 LogRocket 消除传统反应错误报告的噪音</h2>
<a href="https://lp.logrocket.com/blg/react-signup-issue-free" target="_blank" vwo-el-id="19356441070">LogRocket
</a><p>是一款 React analytics 解决方案，可保护您免受数百个误报错误警报的影响，只针对少数真正重要的项目。LogRocket 告诉您 React 应用程序中实际影响用户的最具影响力的 bug 和 UX 问题。</p><a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="19356441380">
<img class="first-react-image alignnone size-full wp-image-46 jetpack-lazy-image jetpack-lazy-image--handled" src="../Images/f300c244a1a1cf916df8b4cb02bec6c6.png" vwo-el-id="18272717540" data-lazy-loaded="1" data-original-src="https://files.readme.io/27c94e7-Image_2017-06-05_at_9.46.04_PM.png"/>
</a>
<a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="19356441690">
<img class="second-react-image alignnone size-full wp-image-46 jetpack-lazy-image jetpack-lazy-image--handled" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" vwo-el-id="30720362350" data-lazy-loaded="1" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/>
</a>
<a href="https://lp.logrocket.com/blg/react-signup-issue-free" target="_blank" rel="noopener noreferrer" vwo-el-id="35866400580">LogRocket
</a><p>自动聚合客户端错误、反应错误边界、还原状态、缓慢的组件加载时间、JS 异常、前端性能指标和用户交互。然后，LogRocket 使用机器学习来通知您影响大多数用户的最具影响力的问题，并提供您修复它所需的上下文。</p><p vwo-el-id="28675661060">关注重要的 React bug—<a class="signup" href="https://lp.logrocket.com/blg/react-signup-issue-free" target="_blank" rel="noopener noreferrer" vwo-el-id="40093418840">今天就试试 LogRocket】。</a></p>
</div></div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
<html>
<head>
<title>Rust microservices in server-side WebAssembly </title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>信任服务器端WebAssembly中的微服务</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/rust-microservices-server-side-webassembly/#0001-01-01">https://blog.logrocket.com/rust-microservices-server-side-webassembly/#0001-01-01</a></blockquote><div><article class="article-post">
<p>在过去几年中，Rust编程语言已经成为主流。它一直被开发者评为最受欢迎的编程语言，并且已经被T2纳入Linux内核。Rust使开发人员能够编写正确的、内存安全的程序，这些程序和C程序一样快，一样小。它非常适合需要高可靠性和高性能的基础设施软件<a href="https://blog.logrocket.com/template-rendering-in-rust/" rel="noopener">，包括服务器端应用</a>。</p>
<p>然而，对于服务器端应用程序，Rust也带来了一些挑战。Rust程序编译成本机代码，不可移植，在多租户云环境下不安全。我们还缺乏工具来管理和协调云中的本地应用程序。</p>
<p>因此，服务器端Rust应用程序通常运行在虚拟机或Linux容器中，这带来了大量的内存和CPU开销。这削弱了Rust在效率方面的优势，并使其难以在资源受限的环境中部署服务，如边缘数据中心和边缘云。这个问题的解决方案是<a href="https://webassembly.org" rel="noopener"> WebAssembly (Wasm) </a>。</p>
<p>Wasm程序作为web浏览器中的安全运行时启动，可以安全地隔离在它们自己的沙箱中。有了新一代Wasm运行时，比如Cloud Native Computing Foundation的<a href="https://github.com/WasmEdge/WasmEdge" rel="noopener"> WasmEdge运行时</a>，现在就可以在服务器上运行Wasm应用了。可以将Rust程序编译成Wasm字节码，然后在云端部署Wasm应用程序。</p>
<p>根据发表在IEEE Software 上的<a href="https://arxiv.org/abs/2010.07115" rel="noopener">研究，Wasm应用比Linux容器中的本地编译Rust应用快100倍(特别是在启动时),小1/100。这使得它们特别适合资源受限的环境，如边缘云。</a></p>
<p>Wasm运行时沙箱的攻击面要小得多，并且提供了比Linux容器更好的隔离。此外，Wasm运行时可以跨操作系统和硬件平台移植。Rust程序一旦编译成Wasm，就可以从开发到生产，从云端到边缘的任何地方运行。</p>
<figure id="attachment_138492" aria-describedby="caption-attachment-138492" class="wp-caption aligncenter"><img data-attachment-id="138492" data-permalink="https://blog.logrocket.com/rust-microservices-server-side-webassembly/attachment/wasmedge-sandbox-environment/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/10/wasmedge-sandbox-environment.png" data-orig-size="730,471" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="WasmEdge sandbox environment" data-image-description="" data-image-caption="&lt;p&gt;The anatomy of a Rust microservice in a WebAssembly sandbox.&lt;/p&gt;&#10;" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/10/wasmedge-sandbox-environment-300x194.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/10/wasmedge-sandbox-environment.png" decoding="async" class="wp-image-138492 size-full jetpack-lazy-image" src="../Images/f5b45146ed52168fdbebda3dd6711f68.png" alt="Rust Microservice In WasmEdge Sandbox Environment" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2022/10/wasmedge-sandbox-environment.png 730w, https://blog.logrocket.com/wp-content/uploads/2022/10/wasmedge-sandbox-environment-300x194.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2022/10/wasmedge-sandbox-environment.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/10/wasmedge-sandbox-environment.png"/><noscript><img data-lazy-fallback="1" data-attachment-id="138492" data-permalink="https://blog.logrocket.com/rust-microservices-server-side-webassembly/attachment/wasmedge-sandbox-environment/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/10/wasmedge-sandbox-environment.png" data-orig-size="730,471" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="WasmEdge sandbox environment" data-image-description="" data-image-caption="&lt;p&gt;The anatomy of a Rust microservice in a WebAssembly sandbox.&lt;/p&gt;&#10;" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/10/wasmedge-sandbox-environment-300x194.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/10/wasmedge-sandbox-environment.png" decoding="async" loading="lazy" class="wp-image-138492 size-full" src="../Images/f5b45146ed52168fdbebda3dd6711f68.png" alt="Rust Microservice In WasmEdge Sandbox Environment" srcset="https://blog.logrocket.com/wp-content/uploads/2022/10/wasmedge-sandbox-environment.png 730w, https://blog.logrocket.com/wp-content/uploads/2022/10/wasmedge-sandbox-environment-300x194.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/10/wasmedge-sandbox-environment.png"/></noscript><figcaption id="caption-attachment-138492" class="wp-caption-text">The anatomy of a Rust microservice in a WebAssembly sandbox.</figcaption></figure>
<p>在本文中，我们将介绍在Rust中构建微服务所需的工具、库、API、框架和技术。我们还将演示如何在WasmEdge WebAssembly运行时部署、运行和扩展这些微服务。</p>
<p><em>向前跳转:</em></p>

<h2 id="prerequisites">先决条件</h2>
<p>要阅读本文，您应该具备以下条件:</p>
<ul>
<li>微服务设计模式的基础知识</li>
<li>Linux操作系统的基本知识</li>
<li>熟悉Rust编程语言</li>
<li>SQL数据库的基础知识</li>
</ul>
<h2 id="creating-a-web-service">创建web服务</h2>
<p>微服务首先是一个web服务器。WasmEdge运行时支持异步和非阻塞网络套接字。你可以用Rust编写网络应用，编译成Wasm，在WasmEdge运行时运行。在Rust生态系统中，WasmEdge支持以下内容:</p>
<ul>
<li>用于异步网络应用的<a href="https://github.com/WasmEdge/tokio" rel="noopener"> tokio </a>和<a href="https://github.com/WasmEdge/mio" rel="noopener"> mio </a>机箱</li>
<li>用于HTTP服务器和客户端应用程序的<a href="https://github.com/WasmEdge/hyper" rel="noopener">超级</a>机箱</li>
</ul>
<p>下面的例子来自于<a href="https://github.com/second-state/microservice-rust-mysql" rel="noopener"> microservice-rust-mysql </a>演示应用，展示了如何在<a href="https://hyper.rs" rel="noopener"> hyper </a>中为WasmEdge创建一个web服务器。web服务器的主要监听循环如下:</p>
<pre class="language-rust hljs">    let addr = SocketAddr::from(([0, 0, 0, 0], 8080));
    let make_svc = make_service_fn(|_| {
        let pool = pool.clone();
        async move {
            Ok::&lt;_, Infallible&gt;(service_fn(move |req| {
                let pool = pool.clone();
                handle_request(req, pool)
            }))
        }
    });
    let server = Server::bind(&amp;addr).serve(make_svc);
    if let Err(e) = server.await {
        eprintln!("server error: {}", e);
    }
    Ok(())
</pre>
<p>一旦请求进来，事件处理程序<code>handle_request(),</code>就会被异步调用，这样它就可以处理多个并发请求。它根据请求方法和路径生成响应:</p>
<pre class="language-rust hljs">async fn handle_request(req: Request&lt;Body&gt;, pool: Pool) -&gt; Result&lt;Response&lt;Body&gt;, anyhow::Error&gt; {
    match (req.method(), req.uri().path()) {
        (&amp;Method::GET, "/") =&gt; Ok(Response::new(Body::from(
            "... ...",
        ))),

        // Simply echo the body back to the client.
        (&amp;Method::POST, "/echo") =&gt; Ok(Response::new(req.into_body())),

        (&amp;Method::GET, "/init") =&gt; {
            let mut conn = pool.get_conn().await.unwrap();
            "DROP TABLE IF EXISTS orders;".ignore(&amp;mut conn).await?;
            "CREATE TABLE orders (order_id INT, product_id INT, quantity INT, amount FLOAT, shipping FLOAT, tax FLOAT, shipping_address VARCHAR(20));".ignore(&amp;mut conn).await?;
            drop(conn);
            Ok(Response::new(Body::from("{\"status\":true}")))
        }

        (&amp;Method::POST, "/create_order") =&gt; {
            // ... ...
        }

        // Return the 404 Not Found for other routes.
        _ =&gt; {
            let mut not_found = Response::default();
            *not_found.status_mut() = StatusCode::NOT_FOUND;
            Ok(not_found)
        }
    }
}


</pre>
<p>现在我们有了一个用于web服务的HTTP服务器。</p>
<h2 id="creating-a-web-service-client">创建web服务客户端</h2>
<p>典型的web服务还需要消费其他web服务。通过tokio和/或mio crates，WasmEdge应用程序可以轻松地为web服务集成HTTP客户端。WasmEdge支持以下防锈板条箱:</p>
<ul>
<li>用于易于使用的HTTP客户端的<a href="https://github.com/WasmEdge/reqwest" rel="noopener"> reqwest </a>机箱</li>
<li>用于http和HTTPS客户端的<a href="https://github.com/second-state/http_req" rel="noopener"> http_req </a>机箱</li>
</ul>
<p>以下示例显示了如何从微服务对web服务API进行HTTP POST:</p>
<pre class="language-rust hljs">    let client = reqwest::Client::new();

    let res = client
        .post("http://eu.httpbin.org/post")
        .body("msg=WasmEdge")
        .send()
        .await?;
    let body = res.text().await?;

    println!("POST: {}", body);
</pre>
<h2 id="creating-a-database-client">创建数据库客户机</h2>
<p>大部分微服务都有数据库做后盾。WasmEdge支持以下MySQL驱动程序的Rust crates:</p>
<ul>
<li>myql机箱是一个同步的MySQL客户端</li>
<li><a href="https://github.com/WasmEdge/mysql_async_wasi" rel="noopener"> mysql_async </a>是一个异步mysql客户端</li>
</ul>
<p>以下示例显示了如何将一组记录插入到数据库表中:</p>
<pre class="language-rust hljs">    let orders = vec![
        Order::new(1, 12, 2, 56.0, 15.0, 2.0, String::from("Mataderos 2312")),
        Order::new(2, 15, 3, 256.0, 30.0, 16.0, String::from("1234 NW Bobcat")),
        Order::new(3, 11, 5, 536.0, 50.0, 24.0, String::from("20 Havelock")),
        Order::new(4, 8, 8, 126.0, 20.0, 12.0, String::from("224 Pandan Loop")),
        Order::new(5, 24, 1, 46.0, 10.0, 2.0, String::from("No.10 Jalan Besar")),
    ];

    r"INSERT INTO orders (order_id, production_id, quantity, amount, shipping, tax, shipping_address)
      VALUES (:order_id, :production_id, :quantity, :amount, :shipping, :tax, :shipping_address)"
        .with(orders.iter().map(|order| {
            params! {
                "order_id" =&gt; order.order_id,
                "production_id" =&gt; order.production_id,
                "quantity" =&gt; order.quantity,
                "amount" =&gt; order.amount,
                "shipping" =&gt; order.shipping,
                "tax" =&gt; order.tax,
                "shipping_address" =&gt; &amp;order.shipping_address,
            }
        }))
        .batch(&amp;mut conn)
        .await?;
</pre>
<p>以下示例显示了如何查询数据库表并返回记录集合:</p>
<pre class="language-rust hljs">    let loaded_orders = "SELECT * FROM orders"
        .with(())
        .map(
            &amp;mut conn,
            |(order_id, production_id, quantity, amount, shipping, tax, shipping_address)| {
                Order::new(
                    order_id,
                    production_id,
                    quantity,
                    amount,
                    shipping,
                    tax,
                    shipping_address,
                )
            },
        )
        .await?;
    dbg!(loaded_orders.len());
    dbg!(loaded_orders);
</pre>
<h2 id="building-running-and-deploying-the-microservice">构建、部署和运行微服务</h2>
<p><a href="https://github.com/second-state/microservice-rust-mysql" rel="noopener">微服务-rust-mysql </a>项目提供了一个数据库驱动的微服务的完整例子。让我们以它为例来构建、部署和运行这个服务。</p>
<p>Docker CLI和Docker Desktop为WasmEdge应用程序开发提供了无缝支持。从项目报告的根目录，您只需要一个命令来构建和启动微服务的所有组件(即WasmEdge应用程序和一个<a href="https://mariadb.org" rel="noopener"> MariaDB </a>数据库服务器):</p>
<pre class="language-rust hljs">docker compose up
</pre>
<p>然后，您可以使用curl通过微服务测试数据库上的CRUD操作。</p>
<p>或者，您可以:</p>

<p>以下命令在Linux系统上安装上述先决条件:</p>
<pre class="language-rust hljs">// Install Rust
curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh

// Install WasmEdge
curl -sSf https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/utils/install.sh | bash -s -- -e all

// Install MySQL. It is available as a package in most Linux distros
sudo apt-get update
sudo apt-get -y install mysql-server libmysqlclient-dev
sudo service mysql start
</pre>
<p>接下来，将微服务应用程序构建到Wasm字节码中:</p>
<pre class="language-rust hljs">cargo build --target wasm32-wasi --release
</pre>
<p>然后，在WasmEdge运行时启动微服务:</p>
<pre class="language-rust hljs">wasmedge --env "DATABASE_URL=mysql://user:<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="50203123232734106162677e607e607e61">[email protected]</a>:3306/mysql" order_demo_service.wasm
</pre>
<p>然后，您可以使用微服务的web API来访问数据库:</p>
<pre class="language-rust hljs">// Init the database table
curl http://localhost:8080/init

// Insert a set of records
curl http://localhost:8080/create_orders -X POST -d @orders.json

// Query the records from the database
curl http://localhost:8080/orders

// Update the records
curl http://localhost:8080/update_order -X POST -d @update_order.json

// Delete a record by its id
curl http://localhost:8080/delete_order?id=2
</pre>
<h2 id="going-to-production">投入生产</h2>
<p>到目前为止，我们已经看到了一个完整的数据库驱动的微服务在运行。然而，在现实世界中，一个公司可能有数百个微服务。它们必须由诸如Kubernetes之类的云原生框架来管理和编排。</p>
<p>WasmEdge应用程序完全符合OCI标准。它们可以在Docker Hub或其他开放容器倡议存储库中进行管理和存储。通过<a href="https://opensource.com/article/22/10/wasm-containers" rel="noopener"> crun集成</a>，WasmEdge可以与Linux容器应用在同一个Kubernetes集群中并行运行。这个库展示了如何在流行的容器工具链中运行WasmEdge应用程序，包括CRI-O、containerd、Kubernetes、Kind、OpenYurt、KubeEdge等等。</p>
<figure id="attachment_138489" aria-describedby="caption-attachment-138489" class="wp-caption aligncenter"><img data-attachment-id="138489" data-permalink="https://blog.logrocket.com/rust-microservices-server-side-webassembly/attachment/container-ecosystem-kubernetes-stack/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/10/container-ecosystem-kubernetes-stack.png" data-orig-size="424,593" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Container ecosystem in Kubernetes stack" data-image-description="" data-image-caption="&lt;p&gt;WebAssembly runtime in the Kubernetes stack.&lt;/p&gt;&#10;" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/10/container-ecosystem-kubernetes-stack-215x300.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/10/container-ecosystem-kubernetes-stack.png" decoding="async" class="wp-image-138489 size-full jetpack-lazy-image" src="../Images/0c73f57c108530647c221d030be47b22.png" alt="Container Ecosystem in Kubernetes Stack" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2022/10/container-ecosystem-kubernetes-stack.png 424w, https://blog.logrocket.com/wp-content/uploads/2022/10/container-ecosystem-kubernetes-stack-215x300.png 215w" data-lazy-sizes="(max-width: 424px) 100vw, 424px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2022/10/container-ecosystem-kubernetes-stack.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/10/container-ecosystem-kubernetes-stack.png"/><noscript><img data-lazy-fallback="1" data-attachment-id="138489" data-permalink="https://blog.logrocket.com/rust-microservices-server-side-webassembly/attachment/container-ecosystem-kubernetes-stack/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/10/container-ecosystem-kubernetes-stack.png" data-orig-size="424,593" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Container ecosystem in Kubernetes stack" data-image-description="" data-image-caption="&lt;p&gt;WebAssembly runtime in the Kubernetes stack.&lt;/p&gt;&#10;" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/10/container-ecosystem-kubernetes-stack-215x300.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/10/container-ecosystem-kubernetes-stack.png" decoding="async" loading="lazy" class="wp-image-138489 size-full" src="../Images/0c73f57c108530647c221d030be47b22.png" alt="Container Ecosystem in Kubernetes Stack" srcset="https://blog.logrocket.com/wp-content/uploads/2022/10/container-ecosystem-kubernetes-stack.png 424w, https://blog.logrocket.com/wp-content/uploads/2022/10/container-ecosystem-kubernetes-stack-215x300.png 215w" sizes="(max-width: 424px) 100vw, 424px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/10/container-ecosystem-kubernetes-stack.png"/></noscript><figcaption id="caption-attachment-138489" class="wp-caption-text">WebAssembly runtime in the Kubernetes stack.</figcaption></figure>
<p>此外，微服务通常与服务框架一起部署。例如，<a href="https://dapr.io" rel="noopener"> Dapr </a>是一个流行的微服务运行时框架。它为每个微服务提供“边车”服务。微服务通过Dapr API访问sidecar，以发现和调用网络上的其他服务，管理状态数据，并访问消息队列。</p>
<p>用于WASI的<a href="https://github.com/second-state/dapr-sdk-wasi" rel="noopener">Dapr SDK</a>( web assembly系统接口)使基于WasmEdge的微服务能够访问其连接的Dapr侧柜。<a href="https://github.com/second-state/dapr-wasm" rel="noopener">一个完整的演示应用</a>也可用，它有一个Jamstack静态web前端、三个微服务和一个数据库服务。</p>
<h2>结论</h2>
<p>在本文中，我们讨论了为什么WebAssembly对于基于Rust的服务器端应用程序来说是一个很好的运行时沙盒格式。我们通过具体的代码示例演示了如何创建HTTP web服务、使用其他web服务、从Rust访问关系数据库，然后在WasmEdge中运行编译后的应用程序。我们还研究了部署问题，比如Kubernetes和Dapr集成。</p>
<p>有了这些板条箱和模板应用，你将能够在Rust中构建你自己的轻量级微服务！</p>
<p>除了微服务之外，WasmEdge运行时还可以广泛用作许多不同场景中的应用程序沙箱:</p>
<ul>
<li><a href="https://flows.network/" rel="noopener"> flows.network </a>是SaaS自动化的无服务器平台。您可以使用Rust和WebAssembly为SaaS产品创建机器人、定制和连接器</li>
<li>您可以为WebAssembly中的数据库创建<a href="https://www.secondstate.io/articles/udf-saas-extension/" rel="noopener">用户定义函数</a>(UDF)和提取-转换-加载(ETL)函数，并以“无服务器”的方式将这些函数嵌入数据库或与数据库放在一起</li>
<li>你可以使用WebAssembly为edge设备创建可移植的高性能应用，运行Android、Open Harmony，甚至是T2的seL4和RTOS</li>
<li>WebAssembly被广泛用作区块链执行智能合同的运行时。例如，WasmEdge为Polkadot、FileCoin和XRP (Ripple)网络运营节点和智能合约。被称为<a href="https://ewasm.readthedocs.io/en/mkdocs/" target="_blank" rel="noopener"> ewasm </a>的下一代以太坊区块链虚拟机也是基于WebAssembly的</li>
</ul>
<p>要了解WasmEdge的更多信息，请参见<a href="https://wasmedge.org/book/en/" rel="noopener">官方文档</a>。</p><div class="code-block code-block-29">
<div class="blog-plug inline-plug rust-plug"><h2><a href="https://lp.logrocket.com/blg/rust-signup" target="_blank">log rocket</a>:Rust应用的web前端的全面可见性</h2><p>调试Rust应用程序可能很困难，尤其是当用户遇到难以重现的问题时。如果您对监控和跟踪Rust应用程序的性能、自动显示错误、跟踪缓慢的网络请求和加载时间感兴趣，</p><a href="https://lp.logrocket.com/blg/rust-signup" target="_blank">try LogRocket</a><p>. </p><a class="signup" href="https://lp.logrocket.com/blg/rust-signup" target="_blank" rel="noopener noreferrer"><img class="alignnone size-full wp-image-46 jetpack-lazy-image" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/><noscript><img data-lazy-fallback="1" class="alignnone size-full wp-image-46" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/></noscript></a><p>LogRocket 就像是网络和移动应用程序的DVR，记录你的Rust应用程序上发生的一切。您可以汇总并报告问题发生时应用程序的状态，而不是猜测问题发生的原因。LogRocket还可以监控应用的性能，报告客户端CPU负载、客户端内存使用等指标。</p><p>现代化调试Rust应用的方式— <a class="signup" href="https://lp.logrocket.com/blg/rust-signup" target="_blank" rel="noopener noreferrer">开始免费监控</a>。</p></div>


</div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
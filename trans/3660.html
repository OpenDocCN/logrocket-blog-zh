<html>
<head>
<title>Using the CSS :modal pseudo-selector </title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>使用CSS:模态伪选择器</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/css-modal-pseudo-selector/#0001-01-01">https://blog.logrocket.com/css-modal-pseudo-selector/#0001-01-01</a></blockquote><div><article class="article-post">
<p>“伪”这个词被定义为虚假的东西，表面上看起来是一回事，但行为却像是另一回事。因此，当我们提到伪元素或伪类(伪选择器)时，我们指的是行为类似于HTML元素或类但不在标记中的东西。</p>
<p>因此，HTML并不像看上去那样简单。我们可以用CSS 来<a href="https://blog.logrocket.com/new-css-style-queries/">样式化UI的某些部分，这些部分在我们的标记中并不存在。</a></p>
<p>一个简单的例子见于<code>form input</code>元素上的<code>placeholder</code>属性的样式，如下所示:</p>
<pre class="language-html hljs">&lt;form&gt;
   &lt;input placeholder="Enter Email"&gt;
   &lt;input placeholder="Enter Password"&gt;
&lt;/form&gt;</pre>
<p>因为<code>placeholder</code>是作为<code>input</code>的属性存在的，所以它不是HTML元素。然而，我们可以通过将<a href="https://blog.logrocket.com/tag/css/"> CSS </a>中的<a href="https://blog.logrocket.com/css-pseudo-elements-guide/">伪元素</a>作为目标来设计<code>placeholder</code>的样式，如下所示:</p>
<pre class="language-html hljs">input::placeholder {
  color: red
}
</pre>
<p>下面是代码的一个交互式示例:</p>
<p class="codepen" data-height="399.94140625" data-default-tab="html,result" data-slug-hash="qBKEbWM" data-user="Lawrenceagles">参见<a href="https://codepen.io"> CodePen </a>上Lawrence Eagles(<a href="https://codepen.io/Lawrenceagles">@ Lawrence Eagles</a>)<br/>的未命名的笔。</p>
<p/>
<p>因此，伪元素代表了DOM的一个实际部分，它可以<a href="https://blog.logrocket.com/best-practices-improving-css-performance/">使您的代码更加高效</a>。</p>
<p>在本文中，我们的重点是<code>:modal</code> CSS伪选择器。然而，在深入研究之前，我们将通过学习更多关于伪元素和伪类的知识来奠定基础，并且，基于我们的知识，我们将学习关于<code>:modal</code>伪选择器的知识。</p>
<p>让我们在下一节开始学习更多关于伪元素和伪类的知识。</p>
<p><em>向前跳转:</em></p>

<h2 id="pseudo-elements-pseudo-classes">什么是伪元素和伪类？</h2>
<p>在这一节中，我们将学习更多关于伪元素和伪类的知识。我们将通过详细阐述涉及不同伪元素和伪类的代码示例来扩展我们的知识。</p>
<p>我们先来看伪元素。</p>
<h3 id="pseudo-elements">伪元素</h3>
<p>伪元素总是有一个双列— <code>::pseudo-element-name</code>，以区别于伪类— <code>:pseudo-class-name</code>。如下图所示:</p>
<pre class="language-css hljs">// psuedo-element
input::placeholder {
  color: red
}

// psuedo-class
input:focus {
  color: red
}</pre>
<p>如上所述，伪元素代表DOM的一部分，但在标记中不可见。我们还提到，它们使您的代码更加高效，因为它们提供了一种简单有效的方法来定位和样式化DOM。</p>
<p>让我们通过查看一些伪元素以及它们如何使我们能够定位和样式化DOM中的元素来详细说明。</p>
<p><code>::file-selector-button</code>是一个CSS伪元素，表示一个HTML的按钮——<a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input/file"><code>type="file"</code></a>的<a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input"> <code>&lt;input&gt;</code> </a>元素，看起来不可能样式化。</p>
<p>然而，使用<code>::file-selector-button</code>伪元素，我们可以轻松地设计这个文件上传按钮的样式，如下所示:</p>
<pre class="language-html hljs">&lt;!-- HTML --&gt;
&lt;form&gt;
   &lt;label for="avatar"&gt;Choose a profile picture:&lt;/label&gt;&lt;br&gt;
   &lt;input type="file"
       name="avatar"
       accept="image/png, image/jpeg"&gt;
&lt;/form&gt;</pre>
<pre class="language-css hljs">//CSS
body {
  display: grid;
  place-items: center;
  min-height: 100vh;
  background-color: #eee;
}

input[type="file"] {
  margin-top: 1rem;
  padding: 1.5em;
  border: 2px dashed grey;
  background-color: #fff;
}

input[type="file"]::file-selector-button {
  padding: 1em 1.5em;
  border-width: 0;
  border-radius: 1rem;
  background-color: dodgerblue;
  color: #FFFFFF;
  font-weight: bold;
  transition: all .25s ease-in-out;
  cursor: pointer;
  margin-right: 1em;
}</pre>
<p>在这里，我们得到以下样式的文件上传按钮:</p>
<p><img data-attachment-id="144612" data-permalink="https://blog.logrocket.com/css-modal-pseudo-selector/attachment/css-modal-pseudo-selector/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/11/css-modal-pseudo-selector.png" data-orig-size="730,320" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="CSS :modal pseudo-selector style" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/11/css-modal-pseudo-selector-300x132.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/11/css-modal-pseudo-selector.png" decoding="async" class="aligncenter size-full wp-image-144612 jetpack-lazy-image" src="../Images/c32e1076b272a9f91bba7eab41185540.png" alt="CSS :modal Pseudo-Selector Style" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2022/11/css-modal-pseudo-selector.png 730w, https://blog.logrocket.com/wp-content/uploads/2022/11/css-modal-pseudo-selector-300x132.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2022/11/css-modal-pseudo-selector.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/11/css-modal-pseudo-selector.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="144612" data-permalink="https://blog.logrocket.com/css-modal-pseudo-selector/attachment/css-modal-pseudo-selector/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/11/css-modal-pseudo-selector.png" data-orig-size="730,320" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="CSS :modal pseudo-selector style" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/11/css-modal-pseudo-selector-300x132.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/11/css-modal-pseudo-selector.png" decoding="async" loading="lazy" class="aligncenter size-full wp-image-144612" src="../Images/c32e1076b272a9f91bba7eab41185540.png" alt="CSS :modal Pseudo-Selector Style" srcset="https://blog.logrocket.com/wp-content/uploads/2022/11/css-modal-pseudo-selector.png 730w, https://blog.logrocket.com/wp-content/uploads/2022/11/css-modal-pseudo-selector-300x132.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/11/css-modal-pseudo-selector.png"/></noscript>
<p>您可以查看下面的代码:</p>
<p class="codepen" data-height="399.81640625" data-default-tab="html,result" data-slug-hash="qBKEJjd" data-user="Lawrenceagles">见笔<a href="https://codepen.io/Lawrenceagles/pen/qBKEJjd"> <br/>文件上传</a>作者Lawrence Eagles(<a href="https://codepen.io/Lawrenceagles">@ Lawrence Eagles</a>)<br/>上<a href="https://codepen.io"> CodePen </a>。</p>
<p/>
<p> </p>
<p><a href="https://blog.logrocket.com/how-to-use-css-before-after-create-custom-animations-transitions/"> <code>::before</code>和<code>::after</code> </a>是迄今为止最强大的，也可以说是最流行的伪元素。这些伪元素使我们能够在HTML其他元素之前或之后插入内容，这完全由CSS代码来处理。</p>
<p>考虑下面的代码:</p>
<pre class="language-html hljs">&lt;!-- HTML --&gt;
&lt;div class="summary" id="text"&gt;
   Lorem Ipsum is simply dummy text of the printing and typesetting industry. Lorem Ipsum has been the industry's standard dummy text ever since the 1500s, when an unknown printer took a galley of type and scrambled it to make a type specimen book. It has survived not only five centuries, but also the leap into electronic typesetting, remaining essentially unchanged. It was popularised in the 1960s with the release of Letraset sheets containing Lorem Ipsum passages, and more recently with desktop publishing software like Aldus PageMaker including versions of Lorem Ipsum.
&lt;/div&gt;</pre>
<pre class="language-css hljs">// CSS
body {
   padding: 20px;
}

.summary::before, .summary::after {
   content: "";
   padding: 4px;
   margin: 10px auto;
   width: 100%;
   height: 10px;
   display: inline-block;
}

#text::before {
   background: red;
}

#text::after {
   background: blue;
}</pre>
<p>在上面的代码中，我们用<code>summary</code>类定位<code>div</code>，并在其内容前插入一个空字符串。</p>
<p>我们使用<code>::before</code>和<code>::after</code>伪元素插入这些内容:</p>
<p><img data-attachment-id="144610" data-permalink="https://blog.logrocket.com/css-modal-pseudo-selector/attachment/css-before-after-pseudo-elements/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/11/css-before-after-pseudo-elements.png" data-orig-size="730,320" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="CSS pseudo-elements styling" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/11/css-before-after-pseudo-elements-300x132.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/11/css-before-after-pseudo-elements.png" decoding="async" class="aligncenter size-full wp-image-144610 jetpack-lazy-image" src="../Images/60c6f66759a42e2b032ad74e688cff85.png" alt="CSS Pseudo-Elements Styling" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2022/11/css-before-after-pseudo-elements.png 730w, https://blog.logrocket.com/wp-content/uploads/2022/11/css-before-after-pseudo-elements-300x132.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2022/11/css-before-after-pseudo-elements.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/11/css-before-after-pseudo-elements.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="144610" data-permalink="https://blog.logrocket.com/css-modal-pseudo-selector/attachment/css-before-after-pseudo-elements/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/11/css-before-after-pseudo-elements.png" data-orig-size="730,320" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="CSS pseudo-elements styling" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/11/css-before-after-pseudo-elements-300x132.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/11/css-before-after-pseudo-elements.png" decoding="async" loading="lazy" class="aligncenter size-full wp-image-144610" src="../Images/60c6f66759a42e2b032ad74e688cff85.png" alt="CSS Pseudo-Elements Styling" srcset="https://blog.logrocket.com/wp-content/uploads/2022/11/css-before-after-pseudo-elements.png 730w, https://blog.logrocket.com/wp-content/uploads/2022/11/css-before-after-pseudo-elements-300x132.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/11/css-before-after-pseudo-elements.png"/></noscript>
<h3 id="pseudo-classes">伪类</h3>
<p>伪类或伪选择器允许我们根据DOM元素的状态来设计它的样式。例如，<code>:first-child</code>表示兄弟元素列表中的第一个子元素，可以使用<code>:first-child</code>伪类进行样式化。另一方面，<code>:last-child</code>表示兄弟元素列表中的最后一个子元素。处于这种状态的元素可以使用<code>last-child</code>伪类进行样式化。</p>
<p>伪类的行为就好像我们在标记中添加了额外的类。这允许我们减少在标记中使用的类的数量。因此，它们帮助我们编写更干净、更灵活和可维护的代码。</p>
<p>考虑下面的HTML代码:</p>
<pre class="language-html hljs">&lt;ul&gt;
  &lt;li&gt;😍&lt;/li&gt; 
  &lt;li&gt;🥳&lt;/li&gt; 
  &lt;li&gt;🥸&lt;/li&gt; 
  &lt;li&gt;😇&lt;/li&gt; 
  &lt;li&gt;🤩&lt;/li&gt; 
  &lt;li&gt;😎&lt;/li&gt; 
  &lt;li&gt;🥰&lt;/li&gt; 
&lt;/ul&gt;</pre>
<p>在上面的HTML代码中，我们可以根据第一个<code>li</code>内容和最后一个<code>li</code>内容的状态有选择地将它们作为目标，并对它们进行样式化，如下所示:</p>
<pre class="language-css hljs">ul {
  list-style-type: none;
   font-size: 2rem;
   text-align: center;
}

ul&gt;li {
   margin: 0.5rem;
}

ul&gt;li:first-child {
   font-size: 4rem;
}

ul&gt;li:last-child {
   font-size: 4rem;
}</pre>
<p>在这里，我们得到:</p>
<p><img data-attachment-id="144608" data-permalink="https://blog.logrocket.com/css-modal-pseudo-selector/attachment/css-pseudo-selector-example/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/11/css-pseudo-selector-example.png" data-orig-size="730,320" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="CSS styling with the pseudo-selector" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/11/css-pseudo-selector-example-300x132.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/11/css-pseudo-selector-example.png" decoding="async" class="aligncenter size-full wp-image-144608 jetpack-lazy-image" src="../Images/018cbc4645b277221418dcbe538d0563.png" alt="CSS Styling with the Pseudo-Selector" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2022/11/css-pseudo-selector-example.png 730w, https://blog.logrocket.com/wp-content/uploads/2022/11/css-pseudo-selector-example-300x132.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2022/11/css-pseudo-selector-example.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/11/css-pseudo-selector-example.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="144608" data-permalink="https://blog.logrocket.com/css-modal-pseudo-selector/attachment/css-pseudo-selector-example/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/11/css-pseudo-selector-example.png" data-orig-size="730,320" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="CSS styling with the pseudo-selector" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/11/css-pseudo-selector-example-300x132.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/11/css-pseudo-selector-example.png" decoding="async" loading="lazy" class="aligncenter size-full wp-image-144608" src="../Images/018cbc4645b277221418dcbe538d0563.png" alt="CSS Styling with the Pseudo-Selector" srcset="https://blog.logrocket.com/wp-content/uploads/2022/11/css-pseudo-selector-example.png 730w, https://blog.logrocket.com/wp-content/uploads/2022/11/css-pseudo-selector-example-300x132.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/11/css-pseudo-selector-example.png"/></noscript>
<p>由于元素的状态会因为用户的交互而改变，伪类使我们能够在用户与DOM元素交互时对它们进行样式化。这些伪类(也称为动态伪类)的行为就像一个表示元素状态的类由于用户的操作而被添加到元素中一样。</p>
<p><code><a href="https://developer.mozilla.org/en-US/docs/Web/CSS/:hover">:hover</a></code>元素是当用户用鼠标指针悬停在该元素上时处于悬停状态的按钮。我们可以使用<code>:hover</code>伪类在悬停状态下选择元素并设置样式。当用户通过选择<code><a href="https://developer.mozilla.org/en-US/docs/Web/CSS/:focus">:focus</a></code>元素来聚焦该元素时，该元素有一个处于焦点状态的表单输入。我们可以使用<code>:focus</code>伪类在焦点状态期间选择并样式化该元素。</p>
<p>然而，在本文中，我们主要关注的是<code>:modal</code>伪选择器，我们将在下一节开始学习它。</p>
<h2 id="css-modal-pseudo-selector">CSS <code>:modal</code>伪选择器</h2>
<p>令人敬畏和强大的<code>:modal</code>是一个CSS伪选择器或伪类，它提供了一种检测模态元素的内在方法。这使得开发人员无需额外的CSS类就可以设计这些元素的样式。</p>
<p>因此，简而言之，<code>:modal</code>伪选择器选择一个元素，该元素处于一种状态，在该状态改变之前，它不会与外部的其他DOM元素进行交互——模态是关闭的。</p>
<h3 id="modal-pseudo-selector-action"><code>:modal</code>动作中的伪选择器</h3>
<p>可以弹出打开一个模态并排除与该模态之外的其他元素的所有交互的元素的一些例子是:</p>
<ul>
<li><code><a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/dialog">dialog</a></code>:用<code>showModal()</code> API打开的对话框元素</li>
<li><code><a href="https://developer.mozilla.org/en-US/docs/Web/CSS/:fullscreen">:fullscreen</a></code>:用<code>requestFullscreen()</code> API打开时的<code>:fullscreen</code>伪类</li>
</ul>
<p>让我们通过一些代码示例来了解更多关于<code>:modal</code>伪选择器的信息。考虑下面的代码:</p>
<pre class="language-html hljs">&lt;!-- HTML --&gt;
&lt;section id="container"&gt;
  &lt;dialog&gt;
    &lt;p&gt;Lorem Ipsum is simply dummy text of the printing and typesetting industry.&lt;/p&gt;
    &lt;button id="close-modal-btn" class="modal-btn"&gt;Close&lt;/button&gt;
  &lt;/dialog&gt;
  &lt;button id="open-modal-btn" class="modal-btn"&gt;Open Modal&lt;/button&gt;
&lt;/section&gt;</pre>
<pre class="language-css hljs">/* CSS */
*,
*:after,
*:before {
  box-sizing: border-box;
}

body {
  display: grid;
  place-items: center;
  min-height: 100vh;
  background: gray;
  font-family: "Google Sans", sans-serif, system-ui;
}

:modal {
  padding: 8rem;
  border: 1px solid black;
  border-radius: 2rem;
  gap: 3rem;
  background: orange;
  overflow: hidden;
}

:modal::backdrop {
  background: hsl(0 0% 10% / 0.5);
}

:modal[open] {
  display: grid;
}

.modal-btn {
  padding: 0.8rem 1.5rem;
  border: 1px solid black;
  border-radius: 1rem;
}</pre>
<pre class="language-javascript hljs">// JavaScript
const Container = document.querySelector("#container");
const DIALOG = document.querySelector("dialog");

Container.addEventListener(
  "click",
  function (event) {
    let modalStyle;
    if (event.target.matches("#open-modal-btn")) {
      modalStyle = "showModal";
    }

    if (event.target.matches("#close-modal-btn")) {
      modalStyle = "close";
    }

    DIALOG[modalStyle]();
  },

  false
);</pre>
<p>在上面的代码示例中，我们使用<a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/dialog#advanced_example"> <code>dialog</code> </a>元素在标记中创建了一个模态。我们使用CSS中的<code>:modal</code>伪类来定位和设计这个模型。在JavaScript中，我们使用<code>event-delegation</code>来监听<code>click</code>事件。然后我们将<code>modalStyle</code>设置为<code>showModal</code>——打开模态或者<code>close</code>——关闭模态。</p>
<p>您可以在运行中看到这一点，并实时使用代码:</p>
<p class="codepen" data-height="399.85546875" data-default-tab="html,result" data-slug-hash="YzvXYqR" data-user="Lawrenceagles">参见<a href="https://codepen.io"> CodePen </a>上Lawrence Eagles(<a href="https://codepen.io/Lawrenceagles">@ Lawrence Eagles</a>)<br/>的Pen<a href="https://codepen.io/Lawrenceagles/pen/YzvXYqR">Dialog-modal</a>。</p>
<p>结论</p>
<h2>在本文中，我们学习了伪元素和伪选择器，它们是伪元素的CSS对应物。这些类似乎是在用户与DOM交互时添加到元素中的。我们也看到了它们是如何让我们减少使用的类的数量，写出更干净、更易维护的代码。</h2>
<p>最后，我们学习了<code>:modal</code> CSS伪选择器，它为我们提供了一种不需要额外CSS类就可以定位和样式化模态的方法。</p>
<p>阅读完本文后，我希望您已经掌握了足够的知识，可以开始使用伪选择器和伪元素编写更干净、更易维护的标记和样式。</p>
<p>你的前端是否占用了用户的CPU？</p><div class="code-block code-block-25">
<div class="blog-plug inline-plug css-plug"><h2>随着web前端变得越来越复杂，资源贪婪的特性对浏览器的要求越来越高。如果您对监控和跟踪生产环境中所有用户的客户端CPU使用、内存使用等感兴趣，</h2><p>.</p><a target="_blank" href="https://lp.logrocket.com/blg/css-signup">try LogRocket</a><p>LogRocket 就像是网络和移动应用的DVR，记录你的网络应用或网站上发生的一切。您可以汇总和报告关键的前端性能指标，重放用户会话和应用程序状态，记录网络请求，并自动显示所有错误，而不是猜测问题发生的原因。</p><a class="signup" href="https://lp.logrocket.com/blg/css-signup" target="_blank" rel="noopener noreferrer"><img class="alignnone size-full wp-image-46 jetpack-lazy-image" src="../Images/dacb06c713aec161ffeaffae5bd048cd.png" alt="LogRocket Dashboard Free Trial Banner" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2019/12/cpu-memory-usage.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/12/cpu-memory-usage.png"/><noscript><img data-lazy-fallback="1" class="alignnone size-full wp-image-46" src="../Images/dacb06c713aec161ffeaffae5bd048cd.png" alt="LogRocket Dashboard Free Trial Banner" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/12/cpu-memory-usage.png"/></noscript></a><a href="https://lp.logrocket.com/blg/css-signup" target="_blank" rel="noopener noreferrer">https://logrocket.com/signup/</a><p>现代化您调试web和移动应用的方式— <a class="signup" href="https://lp.logrocket.com/blg/css-signup" target="_blank" rel="noopener noreferrer">开始免费监控</a>。</p><p>Modernize how you debug web and mobile apps — <a class="signup" href="https://lp.logrocket.com/blg/css-signup" target="_blank" rel="noopener noreferrer">Start monitoring for free</a>.</p></div>
</div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
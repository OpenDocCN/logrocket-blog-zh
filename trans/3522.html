<html>
<head>
<title>How to debounce and throttle in Vue </title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>如何在vue中声讨和节流</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/debounce-throttle-vue/#0001-01-01">https://blog.logrocket.com/debounce-throttle-vue/#0001-01-01</a></blockquote><div><article class="article-post">
<p>当您构建任何类型的web应用程序时，性能都是您主要关心的问题，尤其是对于进行交互的站点。当应用程序执行繁重的计算或调用API时，侦听用户键入输入、滚动和调整大小等事件可能会导致应用程序变得无响应。</p>
<p><code>debounce</code>和<code>throttle</code>是两种通过限制函数调用来降低事件处理程序速度的技术。在本文中，我们将学习如何在Vue应用程序中去抖和节流观察器和事件处理程序。</p>
<h2 id="tableofcontents">目录</h2>

<h2 id="create-debounce-function">创建一个<code>debounce</code>函数</h2>
<p>去抖是一种技术，可以通过等待触发事件<span>直到一定时间过去来提高应用程序的性能；执行</span> <code>debounce</code> <span>功能允许功能在再次运行前等待设定的时间。</span></p>
<p>在进入代码之前，我们先了解一下去抖背后的想法。作为一个例子，假设一个用户在一个文本框中输入，当用户输入时，我们想从一个API中获取数据。如果我们调用API的次数和用户在键盘上输入的次数一样多，应用程序将会产生大量的网络请求，导致性能下降。</p>
<p>让我们假设你想去抖一个函数，在我们的例子中，是<code>search</code>函数。我们将该函数设置为在特定时间段后执行，该时间段是用户在输入每个新字符之前离开键盘的估计时间。如果用户在这个时间段内输入，我们将函数调用推迟到下一个时间间隔。使用这种方法，我们可以减少键入间隔内的函数调用次数:</p>
<p>下面是<code>debounce</code>函数的代码片段:</p>
<pre class="language-javascript hljs">export function debounce(fn, wait){
    let timer;
   return function(...args){
     if(timer) {
        clearTimeout(timer); // clear any pre-existing timer
     }
     const context = this; // get the current context
     timer = setTimeout(()=&gt;{
        fn.apply(context, args); // call the function if time expires
     }, wait);
   }
}
</pre>
<p><code>debounce</code>函数有两个参数，要去抖的函数和以毫秒为单位的等待时间。它返回一个函数，以后可以调用:</p>
<pre class="language-javascript hljs">const debouncedFunction = debounce(function() { ... }, 300);
console.log(typeof debouncedFunction); // `function`
When the debounce function is triggered:</pre>
<p>在上面的代码中，我们取消了任何预先存在的超时，并根据指定的等待时间安排了一个新的超时。当超时过期时，我们用参数调用回调函数。</p>
<h2 id="create-throttle-function">创建一个<code>throttle</code>函数</h2>
<p>当用户在特定时间内没有执行事件时，<code>debounce</code>调用函数，而当用户正在执行事件时，<code>throttle</code>以特定时间间隔调用函数。</p>
<p>例如，如果我们用300毫秒的定时器去抖<code>search</code>函数，那么只有当用户在300毫秒内没有执行搜索时，才会调用该函数。然而，如果我们用300毫秒限制搜索函数，那么当用户输入时，每300毫秒调用一次该函数。</p>
<p>下面是我们示例中的<code>throttle</code>函数的代码片段:</p>
<pre class="language-javascript hljs">export function throttle(fn, wait){
    let throttled = false;
    return function(...args){
        if(!throttled){
            fn.apply(this,args);
            throttled = true;
            setTimeout(()=&gt;{
                throttled = false;
            }, wait);
        }
    }
}
</pre>
<p>当<code>throttle</code>函数被触发时，<code>throttled</code>变量被设置为<code>false</code>，所提供的函数被带参数调用。</p>
<p>在函数调用之后，我们将<code>throttled</code>变量设置为<code>true</code>。如果在此指定时间内有任何事件发生，该函数不会被调用，直到<code>throttle</code>变量被设置为<code>true</code>。<code>setTimeout</code>负责在等待时间到期后给<code>throttled</code>赋值一个变量。</p>
<h2 id="debounce-watcher">谴责观察者</h2>
<p>让我们创建一个简单的组件，我们的任务是当用户在文本框中键入内容时调用Fetch API并记录值:</p>
<pre class="language-javascript hljs">&lt;template&gt;
 &lt;div id="app"&gt;
  &lt;input v-model="value" type="text" /&gt;
  &lt;p&gt;{{ value }}&lt;/p&gt;
&lt;/div&gt;
&lt;/template&gt;
&lt;script&gt;
export default {
  data() {
    return {
      value: "",
    };
  },
  watch: {
    value(newValue, oldValue) {
      console.log("value changed: ", newValue, oldValue);
      // call fetch API to get results
    }
  }
};
&lt;/script&gt;
</pre>
<p>在上面的例子中，每次用户输入一个值，它都会被记录到控制台并调用API。我们不能如此频繁地调用API而不降低应用程序的性能。因此，我们将对上面的活动进行去抖，并在观察器中调用这个去抖函数。为此，我们可以使用前面创建的<code>debounce</code>函数。</p>
<p>下面是去抖后的代码:</p>
<pre class="language-javascript hljs">&lt;template&gt;
 &lt;div id="app"&gt;
  &lt;input v-model="value" type="text" /&gt;
  &lt;p&gt;{{ value }}&lt;/p&gt;
&lt;/div&gt;
&lt;/template&gt;
&lt;script&gt;
import {debounce} from "./Utils.js";
export default {
  data() {
    return {
      value: "",
    };
  },
  created(){
     this.debouncedFetch = debounce((newValue, oldValue)=&gt;{
            console.log("value changed: ", newValue, oldValue);
           // call fetch API to get results
     }, 1000);
  },
  watch: {
    value(...args) {
      this.debouncedFetch(...args);
    }
  }
};
&lt;/script&gt;
</pre>
<p>在上面的代码中，如果自上一次输入活动以来已经过了1000毫秒，用户可以登录到控制台或调用API。</p>
<p>我们将通过创建一个<code>debouncedFetch</code>的实例在观察器上实现去抖动，该实例调用带有回调和等待时间的<code>debounce</code>函数。这个实例是在<code>created()</code>钩子中创建的，然后我们在观察器中用正确的参数调用<code>debouncedFetch</code>。</p>
<h2 id="debounce-event-handler">谴责事件处理程序</h2>
<p>去抖动观察器和事件处理程序是相似的。让我们考虑同样的例子，用户在文本框中输入内容。键入之后，我们将登录到控制台并调用Fetch API。</p>
<p>下面是去抖前的例子:</p>
<pre class="language-javascript hljs">&lt;template&gt;
  &lt;input v-on:input="onChange" type="text" /&gt;
&lt;/template&gt;
&lt;script&gt;
export default {
  methods: {
    onChange(event) {
      console.log('changed value', event.target.value);
      // call fetch API to get results
    }
  }
};
&lt;/script&gt; 
</pre>
<p>现在，我们将去抖<code>onChange</code>事件处理程序，以限制用户输入时的函数调用。</p>
<p>在<code>created()</code>钩子中，通过传递一个事件处理程序和一个等待时间来创建一个<code>debounce</code>函数的实例，并将其命名为<code>onChangeDebounced</code>。然后，将<code>onChangeDebounced</code>分配给一个<code>@input</code>事件处理程序:</p>
<pre class="language-javascript hljs">&lt;template&gt;
  &lt;input @input="onChangeDebounced" type="text" /&gt;
&lt;/template&gt;
&lt;script&gt;
import {debounce} from './Utils.js';
export default {
  created() {
    this.onChangeDebounced = debounce(event =&gt; {
      console.log('changed value:', event.target.value);
      // call fetch API to get results
    }, 1000);
  },
};
&lt;/script&gt;
</pre>
<h2 id="conclusion">结论</h2>
<p>在本教程中，我们学习了Vue中的去抖动和节流观察器和事件处理程序。<code>debounce</code>和<code>throttle</code>是两种强大的技术，通过限制函数调用来降低事件处理程序的速度，从而提高应用程序的性能。</p>
<p>既然您已经理解了<code>debounce</code>和<code>throttle</code>是如何工作的，请在您自己的项目中尝试一下。您应该会看到立竿见影的性能优势。留下评论，让我知道进展如何！</p><div class="code-block code-block-20">
<div class="blog-plug inline-plug vue-inline"><h2>像用户一样体验您的Vue应用</h2><p>调试Vue.js应用程序可能会很困难，尤其是当用户会话期间有几十个(如果不是几百个)突变时。如果您对监视和跟踪生产中所有用户的Vue突变感兴趣，</p><a href="https://lp.logrocket.com/blg/vue-signup" target="_blank">try LogRocket</a><p>. </p><a class="signup" href="https://lp.logrocket.com/blg/vue-signup" target="_blank" rel="noopener noreferrer"><img class="alignnone size-full wp-image-46 jetpack-lazy-image" src="../Images/0d269845910c723dd7df26adab9289cb.png" alt="LogRocket Dashboard Free Trial Banner" data-lazy-src="https://files.readme.io/00591d0-687474703a2f2f692e696d6775722e636f6d2f6a3049327856572e706e67.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://files.readme.io/00591d0-687474703a2f2f692e696d6775722e636f6d2f6a3049327856572e706e67.png"/><noscript><img data-lazy-fallback="1" class="alignnone size-full wp-image-46" src="../Images/0d269845910c723dd7df26adab9289cb.png" alt="LogRocket Dashboard Free Trial Banner" data-original-src="https://files.readme.io/00591d0-687474703a2f2f692e696d6775722e636f6d2f6a3049327856572e706e67.png"/></noscript></a><a href="https://lp.logrocket.com/blg/vue-signup" target="_blank" rel="noopener noreferrer">https://logrocket.com/signup/</a><p>LogRocket 就像是网络和移动应用程序的DVR，记录你的Vue应用程序中发生的一切，包括网络请求、JavaScript错误、性能问题等等。您可以汇总并报告问题发生时应用程序的状态，而不是猜测问题发生的原因。</p><p>LogRocket Vuex插件将Vuex突变记录到LogRocket控制台，为您提供导致错误的环境，以及出现问题时应用程序的状态。</p><p>现代化您调试Vue应用的方式- <a class="signup" href="https://lp.logrocket.com/blg/vue-signup" target="_blank" rel="noopener noreferrer">开始免费监控</a>。</p></div>


</div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
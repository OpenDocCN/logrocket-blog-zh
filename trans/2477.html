<html>
<head>
<title>Building your first DApp with Flutter and Solidity - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>用颤振和坚固性建造你的第一个 DApp</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/building-dapp-flutter-solidity/#0001-01-01">https://blog.logrocket.com/building-dapp-flutter-solidity/#0001-01-01</a></blockquote><div><article class="article-post">
<p>区块链技术和一般的加密空间是当今世界的主要趋势之一。诸如 NFT、ETF、DApps 和 DeFi 等越来越多的流行词汇是这一论断不可否认的标志。</p>
<p>即使在移动和网络技术领域，分散式应用和分散式网络的概念现在也是一个东西，任何想要保持领先和跟上时代的人都在追赶当前的潮流。</p>
<p>在我们继续之前，让我们简要定义一些我们将在本文中遇到的术语。</p>
<h2 id="what-is-a-smart-contract">什么是智能合同？</h2>
<p>我们都知道合同是两个人或两方之间的协议。这将使智能合同成为用代码编写并保存在区块链网络上的可验证、不可逆和自动执行的协议的扩展。</p>
<p>据 Investopedia 称，另一方面，区块链网络是一个分布式数据库，由计算机网络的节点共享。作为一个数据库，区块链以数字格式存储电子信息。</p>
<p>在本文中，我将带您了解:</p>
<ul>
<li>如何通过使用<a href="https://blog.logrocket.com/smart-contract-programming-languages/">S</a><a href="https://blog.logrocket.com/smart-contract-programming-languages/" target="_blank" rel="noopener">solidity 编程语言</a>构建一个简单的智能契约来实现分散应用程序的概念</li>
<li>以及使用 Flutter 将其连接到应用程序客户端的步骤</li>
</ul>
<h2 id="getting-started">入门指南</h2>
<p>我们要构建的是一个简单的智能契约，用于在 alpha 和 beta 两个值之间进行投票。就本教程的范围而言，我们不会深入任何复杂的内容，比如验证用户和用户可以投票的次数；我们将专注于在 Solidity 中创建一个简单的智能契约，并使用 Flutter 在我们的应用程序中部署它。<a href="https://blog.logrocket.com/complete-guide-flutter-architecture/" target="_blank" rel="noopener"> Flutter 是一个 UI 工具包，使用户能够快速创建 UI，并增加了灵活性</a>。</p>
<p>首先，我们需要下载并使用 MetaMask。因此，<a href="https://metamask.io" target="_blank" rel="noopener">点击这个链接将 MetaMask 扩展添加到你的浏览器</a>(最好是 Chrome)。</p>
<p>完成后，创建并设置您的加密钱包。由于这是为了学习，将你的网络从<strong>以太坊主网</strong>改为<strong>林克比测试网络</strong>，如下图所示。</p>
<figure data-carousel-extra="{&quot;blog_id&quot;:1,&quot;permalink&quot;:&quot;https:\/\/blog.logrocket.com\/building-dapp-flutter-solidity\/&quot;}" class="is-layout-flex wp-block-gallery-1 wp-block-gallery columns-3 is-cropped">

</figure>
<p>一旦你解决了这个问题，你将需要一些测试乙醚来处理天然气费时，进行某些交易与我们的智能合同。你可以做的一个方法是利用水龙头。请点击链接获取详细说明。</p>
<p>我们要做的下一件事是用 Solidity 编写我们的智能合同。我们将使用 Remix，这是一个用于 Solidity 的在线集成开发环境(IDE)，类似于 Dart 的 DartPad。</p>
<p><a href="http://remix.ethereum.org/#optimize=false&amp;runs=200&amp;evmVersion=null&amp;version=soljson-v0.8.7+commit.e28d00a7.js" target="_blank" rel="noopener">Remix IDE 的链接可以在这里找到</a>。</p>
<p>如果您在 ide 左侧找到的文件夹令人困惑，您可以删除并创建一个新文件。我们将创建一个名为<code>voting.sol</code>的新文件。</p>
<p><code>sol</code>扩展名代表可靠性，就像编写 Dart 和 Flutter 类时用于创建文件的<code>.dart</code>扩展名一样:</p>
<pre class="wp-block-preformatted">pragma solidity 0.6.6;&#13;
&#13;
contract Voting{&#13;
&#13;
int alpha;&#13;
int beta;&#13;
&#13;
constructor() public {&#13;
   alpha  = 0;&#13;
    beta = 0;&#13;
}&#13;
&#13;
function getTotalVotesAlpha() view public returns(int) {&#13;
    return alpha;&#13;
}&#13;
&#13;
function getTotalVotesBeta() view public returns(int){&#13;
    return beta;&#13;
}&#13;
&#13;
function voteAlpha () public{&#13;
    alpha = alpha+1;&#13;
}&#13;
&#13;
function voteBeta () public{&#13;
    beta = beta+1;&#13;
}&#13;
}&#13;
</pre>
<p>现在，让我们来了解一下这个简单智能合约的结构:</p>
<pre class="wp-block-preformatted">pragma solidity 0.6.6;&#13;
</pre>
<p>第一行是我们将使用的 Solidity 版本的声明，在我们的例子中是版本 0.6.6。</p>
<p>我们代码的第 3 行是如何声明契约，类似于其他编程语言中的类声明:</p>
<pre class="wp-block-preformatted">int alpha;&#13;
int beta;&#13;
</pre>
<p>我们还有两个整型变量声明，分别是<code>alpha</code>和<code>beta</code>:</p>
<pre class="wp-block-preformatted">constructor() public {&#13;
   alpha  = 0;&#13;
    beta = 0;&#13;
}&#13;
</pre>
<p>接下来是我们的构造函数声明，每当我们创建这个类的实例时，我们都希望使用构造函数来初始化我们的字段:</p>
<pre class="wp-block-preformatted">function getTotalVotesAlpha() view public returns(int) {&#13;
    return alpha;&#13;
}&#13;
&#13;
function getTotalVotesBeta() view public returns(int){&#13;
    return beta;&#13;
}&#13;
</pre>
<p>接下来我们有上面这两个函数，它们做类似的事情。第一个函数返回<code>alpha</code>的值，第二个函数返回<code>beta</code>的值。如果你仔细观察，你会注意到添加了<code>view</code>属性。这意味着这个函数是一个只读函数，不修改我们合同中的任何字段。</p>
<p>在 Solidity 中，我们所有的函数都标有访问修饰符，它们决定了函数或字段的范围。在我们的例子中，我们有一个<code>public</code>访问修饰符，这意味着这个函数可以从我们的契约外部调用。</p>
<p>最后，<code>return</code>类型是在花括号之前指定的。</p>
<p>我们函数的其余部分只是增加字段的值<code>1</code>。</p>
<p>现在点击<strong> Compile </strong>，它位于我们 IDE 的左侧窗格，如下图所示。</p>

<p>一旦您的智能合同编译成功，单击<strong> Deploy </strong>并运行选项卡，如下所示。把你的环境从<strong> JavaScript VM </strong>换成<strong> Injected Web3 </strong>。</p>

<p>一旦你完成了这些，你可以再次点击<strong>编译</strong>标签，从智能契约中选择一个或多个你想要测试的函数，并在终端中查看结果。</p>
<p>在成功编写智能合同之后，我们需要一个区块链服务器来运行。有很多方法可以做到这一点——其中之一就是使用<a href="https://www.trufflesuite.com/ganachehttps://www.trufflesuite.com/ganache" target="_blank" rel="noopener"> Ganache </a>来运行个人区块链。但是为了简单起见，我们将使用<a href="https://infura.io/" target="_blank" rel="noopener"> Infura </a>，这是一个为我们提供区块链访问以太坊的平台。</p>
<p>只需创建一个帐户，并在平台上创建一个项目，你就会得到一个网址。记下并确保将创建的项目的网络从<strong> Mainnet </strong>更改为<strong> Rinkeby </strong>。</p>

<p>在网络下方，你可以看到我们提供了两个链接。你可以选择其中的任何一个，然后你就可以开始了。</p>
<p>接下来我们要做的是创建一个新的 Flutter 项目，并在我们的<code>pubspec</code>文件中添加以下依赖项:</p>
<pre class="wp-block-preformatted">web3dart: ^2.3.3&#13;
http: ^0.13.4&#13;
</pre>
<p>我们的屏幕将是一个简单的屏幕，有两个按钮来投票<code>alpha</code>或<code>beta</code>，我们将在按钮上方显示总得分。</p>

<p>我们从创建这些变量开始:</p>
<pre class="wp-block-preformatted language-dart hljs">late Client httpClient;&#13;
&#13;
late Web3Client ethClient;&#13;
&#13;
//Ethereum address&#13;
final String myAddress = "0x8fF1b659bDC9D6eF5d99823B155cfdf47eF2944d";&#13;
&#13;
//url from Infura&#13;
final String blockchainUrl = "https://rinkeby.infura.io/v3/4e577288c5b24f17a04beab17cf9c959";&#13;
&#13;
//strore the value of alpha and beta&#13;
var totalVotesA;&#13;
var totalVotesB;&#13;
</pre>
<p>在我们的<code>initState</code>回调中，我们将初始化我们的<code>httpClient</code>和<code>Web3client</code>，并调用一个方法从我们的智能契约中获取<code>alpha</code>和<code>beta</code>的值:</p>
<pre class="wp-block-preformatted language-dart hljs">@override&#13;
void initState() {&#13;
  httpClient = Client();&#13;
  ethClient = Web3Client(&#13;
      blockchainUrl,&#13;
      httpClient);&#13;
  getTotalVotes();&#13;
  super.initState();&#13;
}&#13;
</pre>
<p>为了理解<code>getTotalVotes</code>应该如何工作，让我们来看看下面的函数，并对它们进行分解。</p>

<p>在此之前，我们将返回到 Remix IDE，在<strong> Solidity 编译器</strong>选项卡上，我们将复制智能合约的 ABI，如上图所示，将其带到我们的 Flutter IDE，并创建一个新文件。在我们的例子中，我们将其命名为<code>contract.json</code>，它将位于我们的 assets 文件夹中。之后，我们继续将它添加到我们的<code>pubspec file</code>并运行<code>flutter pub get</code>命令:</p>
<pre class="wp-block-preformatted language-dart hljs"># To add assets to your application, add an assets section, like this:&#13;
assets:&#13;
  - assets/contract.json&#13;
&#13;
&#13;
Future&lt;DeployedContract&gt; getContract() async {&#13;
//obtain our smart contract using rootbundle to access our json file&#13;
  String abiFile = await rootBundle.loadString("assets/contract.json");&#13;
&#13;
&#13;
  String contractAddress = "0xee3F5a4361ec47C57394Fc028C3fBCCd0e9f1B5d";&#13;
&#13;
&#13;
  final contract = DeployedContract(ContractAbi.fromJson(abiFile, "Voting"),&#13;
      EthereumAddress.fromHex(contractAddress));&#13;
&#13;
  return contract;&#13;
}&#13;
&#13;
Future&lt;List&lt;dynamic&gt;&gt; callFunction(String name) async {&#13;
  final contract = await getContract();&#13;
  final function = contract.function(name);&#13;
  final result = await ethClient&#13;
      .call(contract: contract, function: function, params: []);&#13;
  return result;&#13;
}&#13;
&#13;
Future&lt;void&gt; getTotalVotes() async {&#13;
  List&lt;dynamic&gt; resultsA = await callFunction("getTotalVotesAlpha");&#13;
  List&lt;dynamic&gt; resultsB = await callFunction("getTotalVotesBeta");&#13;
  totalVotesA = resultsA[0];&#13;
  totalVotesB = resultsB[0];&#13;
&#13;
  setState(() {});&#13;
}&#13;
</pre>
<p>使用我们的<code>web3dart</code>包中的<code>DeployedContract</code>类构造一个契约，它接受 ABI 文件、我们的智能契约的名称(在我们的例子中是<code>Voting</code>)和契约地址，并从我们的函数返回它。</p>
<p>注意，要获取合同地址，请返回到您的 Remix IDE，单击<strong>部署并运行</strong>选项卡，然后单击<strong>部署</strong> <strong>合同</strong>下面的复制图标，如下图所示。</p>

<p>下一个函数将用于调用我们的智能合约内部的函数:</p>
<pre class="wp-block-preformatted language-dart hljs">final result = await ethClient&#13;
      .call(contract: contract, function: function, params: []);&#13;
</pre>
<p>上面一行是我们如何用来自<code>web3dart</code> <code>EthereumClient</code>类的调用扩展连接到我们的智能契约。该操作的结果是该函数返回的列表:</p>
<pre class="wp-block-preformatted language-dart hljs">Future&lt;List&lt;dynamic&gt;&gt; callFunction(String name) async {&#13;
  final contract = await getContract();&#13;
  final function = contract.function(name);&#13;
  final result = await ethClient&#13;
      .call(contract: contract, function: function, params: []);&#13;
  return result;&#13;
}&#13;
</pre>
<p>最后，在<code>getTotalVotes</code>方法中，我们将使用这个<code>callFunction</code>来调用像<code>getTotalVotesAlpha</code>和<code>getTotalVotesBeta</code>这样的函数，它们是我们在智能契约中创建的。请确保您传递的名称与您部署的契约上的名称完全匹配。</p>
<p>一旦我们完成了接收投票值的函数，下一个动作就是投票。与我们所做的类似，我们将使用 ABI 文件通过调用其中的函数来构造一个请求。</p>
<p>投票操作的不同之处在于，我们做的是<code>write</code>请求，而不是<code>read</code>请求。因此，我们将利用元掩码中的私钥。或者您可以使用任何私钥；它会通过，因为这是一个测试帐户。</p>
<p>此外，我们不使用<code>call</code>，而是使用<code>sendTransaction</code>并传递我们的私有密钥，一个事务对象，并指定<code>chainId</code>，在我们的例子中(Rinkeby)是<code>4</code>:</p>
<pre class="wp-block-preformatted language-dart hljs">Future&lt;void&gt; vote(bool voteAlpha) async {&#13;
  snackBar(label: "Recording vote");&#13;
  //obtain private key for write operation&#13;
  Credentials key = EthPrivateKey.fromHex(&#13;
      "f6417d3d4c5cc294ace85aa196fcde0ca792550e085f65fff459423e597ff306");&#13;
&#13;
  //obtain our contract from abi in json file&#13;
  final contract = await getContract();&#13;
&#13;
  // extract function from json file&#13;
  final function = contract.function(&#13;
    voteAlpha ? "voteAlpha" : "voteBeta",&#13;
  );&#13;
&#13;
  //send transaction using the our private key, function and contract&#13;
  await ethClient.sendTransaction(&#13;
      key,&#13;
      Transaction.callContract(&#13;
          contract: contract, function: function, parameters: []),&#13;
      chainId: 4);&#13;
  ScaffoldMessenger.of(context).removeCurrentSnackBar();&#13;
  snackBar(label: "verifying vote");&#13;
  //set a 20 seconds delay to allow the transaction to be verified before trying to retrieve the balance&#13;
  Future.delayed(const Duration(seconds: 20), () {&#13;
    ScaffoldMessenger.of(context).removeCurrentSnackBar();&#13;
    snackBar(label: "retrieving votes");&#13;
    getTotalVotes();&#13;
&#13;
    ScaffoldMessenger.of(context).clearSnackBars();&#13;
  });&#13;
}&#13;
</pre>
<p>之后，我们设置了一个<code>20</code>秒的延迟，因为在再次检索我们的余额之前，交易需要一段时间才能得到验证。</p>
<p>如果一切都设置好了，当您运行您的项目时，您将拥有这个。</p>

<h2 id="final-thoughts">最后的想法</h2>
<p>智能契约的这个简单实现应该让您开始探索和学习更多内容。您可以决定添加一些有趣的特性，比如身份验证，确保一个用户不会投票超过一次，并对您的应用程序应用良好的状态管理方法。</p>
<p>要了解更多关于可靠性的知识，你可以<a href="https://docs.soliditylang.org/en/v0.8.10/" target="_blank" rel="noopener">点击这里</a>查看他们的文档。</p>
<p>要访问该项目的存储库，请查看下面的链接:</p>
<p><a href="https://github.com/Ekeminie/blockchain-evoting" target="_blank" rel="noopener">https://github . com/ekeminie/block chain-evolved</a></p>
<p/><div class="code-block code-block-26">
<div class="blog-plug inline-plug blockchain-plug"><h2>加入像 Bitso 和 Coinsquare 这样的组织，他们使用 LogRocket 主动监控他们的 Web3 应用</h2><p>影响用户在您的应用中激活和交易的能力的客户端问题会极大地影响您的底线。如果您对监控 UX 问题、自动显示 JavaScript 错误、跟踪缓慢的网络请求和组件加载时间感兴趣，</p><a target="_blank" href="https://lp.logrocket.com/blg/web3-signup">try LogRocket</a><p>.</p><a class="signup" href="https://lp.logrocket.com/blg/web3-signup" target="_blank" rel="noopener noreferrer"><img class="alignnone size-full wp-image-46 jetpack-lazy-image" src="../Images/dacb06c713aec161ffeaffae5bd048cd.png" alt="LogRocket Dashboard Free Trial Banner" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2019/12/cpu-memory-usage.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/12/cpu-memory-usage.png"/><noscript><img data-lazy-fallback="1" class="alignnone size-full wp-image-46" src="../Images/dacb06c713aec161ffeaffae5bd048cd.png" alt="LogRocket Dashboard Free Trial Banner" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/12/cpu-memory-usage.png"/></noscript></a><a href="https://lp.logrocket.com/blg/web3-signup" target="_blank" rel="noopener noreferrer">https://logrocket.com/signup/</a><p>LogRocket 就像是网络和移动应用的 DVR，记录你的网络应用或网站上发生的一切。您可以汇总和报告关键的前端性能指标，重放用户会话和应用程序状态，记录网络请求，并自动显示所有错误，而不是猜测问题发生的原因。</p><p>现代化您调试 web 和移动应用的方式— <a class="signup" href="https://lp.logrocket.com/blg/web3-signup" target="_blank" rel="noopener noreferrer">开始免费监控</a>。</p></div>
</div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
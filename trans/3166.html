<html>
<head>
<title>How to use Redux in Next.js - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>如何在 Next.js - LogRocket 博客中使用 Redux</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/use-redux-next-js/#0001-01-01">https://blog.logrocket.com/use-redux-next-js/#0001-01-01</a></blockquote><div><article class="article-post">
<p><em> <strong>编者按:</strong>这篇文章于 2023 年 2 月 22 日更新，包含了关于在 Next.js 中保持认证状态的信息，并提供了关于在 Next.js 中何时使用或避免使用 Redux 的额外见解。</em></p>
<p>Redux 是 React 生态系统中最受欢迎的状态管理解决方案之一。如今，有<a href="https://blog.logrocket.com/react-hooks-context-redux-state-management/">大量的替代品</a>，但 Redux 仍然是最值得信赖和广泛使用的工具。</p>
<p>由于这个原因，许多使用 Next.js 的项目也想利用 Redux。但是在下一个应用程序中使用 Redux 有一些问题，设置并不总是简单明了的。这就是为什么本文将带您了解如何使用 Redux 建立 Next.js 项目。</p>
<h2>内容</h2>

<h2 id="why-use-redux-next-js">为什么要在 Next.js 中使用 Redux？</h2>
<p>在下一个应用程序中使用 Redux 有很多原因。让我们来看看其中的一些。</p>
<h3 id="sharing state">共享状态</h3>
<p>通常，中央状态用于管理树中组件之间的共享数据。在 React 中，数据只向下流动，这意味着您可以将数据从父组件传递到子组件。</p>
<p>这种限制有时会使事情变得困难，因为组件树中的组件可能不靠近，甚至可能没有父子路径。</p>
<p>在这种情况下，使用一个包装所有组件的公共存储完全有意义，您可以考虑 Redux。</p>
<h3 id="redux-very-powerful">Redux 很厉害</h3>
<p>Redux 作为一个状态管理解决方案非常强大。它已经存在了一段时间，所以它有很好的社区支持。</p>
<p>如果您正在构建一些严重的东西，并且不确定将来可能会出现哪些用例，Redux 很可能会为您提供一个解决方案。虽然没有什么是完全经得起未来考验的，但 Redux 是长期项目的安全赌注。</p>
<h3 id="everybody-knows-redux">每个人都知道 Redux</h3>
<p>在许多项目中，速度通常是优先考虑的。许多 React 开发人员已经熟悉了 Redux，如果可能的话，公司通常希望在所有项目中使用相同的工具。</p>
<p>这意味着即使你在一家公司工作，在 Next 中建立一个新项目，你也可能会被迫使用 Redux，所以仅仅根据流行程度来学习如何使用它是一个好主意。</p>
<h3 id="redux-very-flexible">Redux 非常灵活</h3>
<p>Redux 如此受欢迎的一个主要原因是它的灵活性。Redux 提供了广泛的特性、中间件、缓存和性能。它有一个非常活跃的开发者社区。此外，Redux 可以分离应用程序内部的关注点，从而在将来实现更好的代码管理。</p>
<p>如果你开始在你的应用中使用 Redux，你将不会被它的特性所限制。事实上，它将开启许多新的可能性。您可以选择在您的应用程序中包含或不包含这些功能。</p>
<p>即使你选择不使用 Redux，学习一个新的概念从来都不是坏事！因此，让我们深入研究一下，看看如何将 Redux 集成到 Next.js 应用程序中。</p>
<h2 id="building-sample-next-js-application-redux">使用 Next.js 和 Redux 构建示例应用程序</h2>
<p>今天，我们将构建一个简单的应用程序，它跟踪用户是否登录，然后根据状态更改按钮上方的文本:</p>
<p><img decoding="async" src="../Images/9cd9b5a90cec78622b3239c413951283.png" alt="Sample app login button" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2022/07/Sample-app-login-button.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" class=" jetpack-lazy-image" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/07/Sample-app-login-button.png"/></p><noscript><img data-lazy-fallback="1" decoding="async" src="../Images/9cd9b5a90cec78622b3239c413951283.png" alt="Sample app login button" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/07/Sample-app-login-button.png"/></noscript>
<p><img decoding="async" src="../Images/6f5731f1d4424d222167bdf0c144c31a.png" alt="Sample app logout button" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2022/07/Sample-app-logout-button.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" class=" jetpack-lazy-image" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/07/Sample-app-logout-button.png"/></p><noscript><img data-lazy-fallback="1" decoding="async" src="../Images/6f5731f1d4424d222167bdf0c144c31a.png" alt="Sample app logout button" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/07/Sample-app-logout-button.png"/></noscript>
<p>这个项目旨在演示如何使用 Redux，所以我在这里保持简单，这样我们就可以专注于 Redux 与 Next 的集成。展望未来，我们有两个选择。我们可以使用普通的<a href="https://redux.js.org/"> Redux </a>，也可以使用<a href="https://redux-toolkit.js.org/"> Redux 工具包</a>。</p>
<p>Redux 正在许多遗留项目中使用，但是推荐使用 Redux Toolkit ,因为它减少了大量样板代码，并提高了性能。然而，这两者的设置几乎相同。</p>
<p>让我们通过运行以下命令来创建启动项目:</p>
<pre class="language-shell hljs">yarn create next-app --typescript
</pre>
<p>您可以通过运行<code>yarn dev</code>并在浏览器上访问<a href="http://localhost:3000/"> http://localhost:3000/ </a>来查看项目的运行情况。</p>
<h3 id="installing-dependencies">安装依赖项</h3>
<p>让我们安装 Redux Toolkit 所需的依赖项:</p>
<pre class="language-shell hljs">yarn add @reduxjs/toolkit react-redux
</pre>
<p>当我们使用 Next 时，我们需要一个额外的包来处理我们的服务器端渲染:</p>
<pre class="language-shell hljs">yarn add next-redux-wrapper
</pre>
<h3 id="creating-slice">创建切片</h3>
<p>让我们创建一个名为<code>store</code>的新文件夹，并在其中创建一个名为<code>authSlice.ts</code>的文件。<a href="https://redux.js.org/tutorials/essentials/part-2-app-structure">官方文档</a>将切片定义为:“你的应用中单个特性的 Redux reducer 逻辑和动作的集合。”</p>
<p>我们将把我们的<code>authState</code>的逻辑放在这个<code>authSlice.ts</code>文件中:</p>
<pre class="language-typescript hljs">import { createSlice } from "@reduxjs/toolkit";
import { AppState } from "./store";
import { HYDRATE } from "next-redux-wrapper";

// Type for our state
export interface AuthState {
  authState: boolean;
}

// Initial state
const initialState: AuthState = {
  authState: false,
};

// Actual Slice
export const authSlice = createSlice({
  name: "auth",
  initialState,
  reducers: {
    // Action to set the authentication status
    setAuthState(state, action) {
      state.authState = action.payload;
    },
  },

  // Special reducer for hydrating the state. Special case for next-redux-wrapper
  extraReducers: {
    [HYDRATE]: (state, action) =&gt; {
      return {
        ...state,
        ...action.payload.auth,
      };
    },
  },
});

export const { setAuthState } = authSlice.actions;

export const selectAuthState = (state: AppState) =&gt; state.auth.authState;

export default authSlice.reducer;
</pre>
<p>这是一个简单的切片。任何使用 Redux 的普通 React 应用程序的一个片段都是这样的。接下来还没有什么特别的。</p>
<p>我们在这里做的唯一一件事是在我们的商店中定义<code>authState</code>并创建设置名为<code>setAuthState</code>的<code>authState</code>的动作。</p>
<p>在第 27 行，您会注意到我们在这里添加了一个特殊的缩减器，名为<code>HYDRATE</code>。<code>HYDRATE</code>动作处理器必须在现有状态(如果有的话)的基础上正确地协调水合状态。</p>
<p>基本上，当任何页面刷新发生时，如果你从一个页面导航到另一个页面，或者调用了<code>getStaticProps</code>或<code>getServerSideProps</code>函数，一个<code>HYDRATE</code>动作将在那一刻被调度。这个动作的<code>payload</code>会包含静态生成或者服务器端渲染时的状态，所以你的 reducer 必须把它和现有的客户端状态正确合并。</p>
<h3 id="creating-store">创建商店</h3>
<p>接下来，创建一个名为<code>store.ts</code>的文件来创建商店，并在那里添加我们的<code>authSlice</code>:</p>
<pre class="language-typescript hljs">import { configureStore, ThunkAction, Action } from "@reduxjs/toolkit";
import { authSlice } from "./authSlice";
import { createWrapper } from "next-redux-wrapper";

const makeStore = () =&gt;
  configureStore({
    reducer: {
      [authSlice.name]: authSlice.reducer,
    },
    devTools: true,
  });

export type AppStore = ReturnType&lt;typeof makeStore&gt;;
export type AppState = ReturnType&lt;AppStore["getState"]&gt;;
export type AppThunk&lt;ReturnType = void&gt; = ThunkAction&lt;
  ReturnType,
  AppState,
  unknown,
  Action
&gt;;

export const wrapper = createWrapper&lt;AppStore&gt;(makeStore);
</pre>
<p>注意第 22 行，我们导出了一个特殊的<code>wrapper</code>函数。这个包装器消除了我们在普通 React 应用程序中使用的<code>Provider</code>的需要。</p><div class="code-block code-block-54">
<hr/>
<h3>更多来自 LogRocket 的精彩文章:</h3>

<hr/></div>
<h3 id="updating-app">更新应用程序</h3>
<p>我们还需要做最后一件事来完成 Redux 架构的设置。打开<code>_app.tsx</code>文件，像这样包装我们的组件:</p>
<pre class="language-typescript hljs">import "../styles/globals.css";
import type { AppProps } from "next/app";
import { wrapper } from "../store/store";

function MyApp({ Component, pageProps }: AppProps) {
  return &lt;Component {...pageProps} /&gt;;
}

export default wrapper.withRedux(MyApp);
</pre>
<p>注意第 9 行，我们用<code>withRedux</code>包装了组件。我们也可以包装单个页面，但不推荐这样做；当我们从一个页面导航到另一个页面时，如果那个特定的页面没有换行，它就会崩溃。</p>
<h2 id="using-redux-store">使用 Redux 商店</h2>
<p>我们的 Redux 设置完成了！让我们像这样在<code>index.tsx</code>页面中使用我们的 Redux 存储:</p>
<pre class="language-typescript hljs">import type { NextPage } from "next";
import { selectAuthState, setAuthState } from "../store/authSlice";
import { useDispatch, useSelector } from "react-redux";

const Home: NextPage = () =&gt; {
  const authState = useSelector(selectAuthState);
  const dispatch = useDispatch();
  return (
    &lt;div&gt;
      &lt;div&gt;{authState ? "Logged in" : "Not Logged In"}&lt;/div&gt;
      &lt;button
        onClick={() =&gt;
          authState
            ? dispatch(setAuthState(false))
            : dispatch(setAuthState(true))
        }
      &gt;
        {authState ? "Logout" : "LogIn"}
      &lt;/button&gt;
    &lt;/div&gt;
  );
};

export default Home;
</pre>
<p>任何 Redux 存储都有两个主要目的:读取和更新。<br/>在第 6 行，你可以看到我们正在使用<code>react-redux</code>提供的<code>useSelector</code>函数读取状态。</p>
<p>我们有一个可以切换<code>authState</code>的按钮，基于此，我们正在更改按钮上的文本。</p>
<h2 id="persisting-state-next-js">在 Next.js 中保持页面导航之间的状态</h2>
<p>现在我们已经成功地建立了我们的 Redux 商店。您可以通过单击按钮来验证它，这将基于当前状态调度操作并更新存储，最终将更改状态。</p>
<p>但是如果你刷新你的页面，你会看到这个状态不再持续。这是因为，在 Next 中，每个页面都是按需呈现的，这意味着当您从一个页面导航到另一个页面时，以前的状态将会消失。</p>
<p>对于这种情况，如果用户已经登录，那么每当您切换到另一个页面时，用户将自动注销，因为初始的<code>authState</code>被定义为 false。</p>
<p>为了解决这个问题，我们将利用我们之前创建的包装器函数，并使用 Next 的特殊函数<code>getServerSideProps</code>，因为每次页面加载时都会调用这个函数。</p>
<p>让我们将下面的代码添加到我们的<code>index.tsx</code>文件中:</p>
<pre class="language-typescript hljs">export const getServerSideProps = wrapper.getServerSideProps(
  (store) =&gt;
    async ({ params }) =&gt; {
      // we can set the initial state from here
      // we are setting to false but you can run your custom logic here
      await store.dispatch(setAuthState(false)); 
      console.log("State on server", store.getState());
      return {
        props: {
          authState: false,
        },
      };
    }
);
</pre>
<p>我们在这里生成的是<code>getServerSideProps</code>函数内部的初始状态，所以即使你刷新页面；您将看到状态值保持不变。</p>
<h2 id="persisting-authentication-state-next-js">在 Next.js 中持久化身份验证状态</h2>
<p>当涉及到身份验证时，状态不仅需要在页面转换之间持久化，还需要在刷新期间持久化。这是必要的，这样用户就不必在每次刷新页面时登录。</p>
<p>为了正确地持久化认证状态，我们可以使用<code>[redux-persist](<a href="https://www.npmjs.com/package/redux-persist" rel="nofollow">https://www.npmjs.com/package/redux-persist</a>)</code>库。让我们看看如何整合这一点。</p>
<p>首先，安装依赖项，如下所示:</p>
<pre class="language-shell hljs">yarn add redux-persist
</pre>
<p>然后，打开<code>store.ts</code>文件，创建一个名为<code>makeStore</code>的新函数:</p>
<pre class="language-typescript hljs">import { persistReducer, persistStore } from "redux-persist";
import storage from "redux-persist/lib/storage";

const rootReducer = combineReducers({
  [authSlice.name]: authSlice.reducer,
});

const makeConfiguredStore = () =&gt;
  configureStore({
    reducer: rootReducer,
    devTools: true,
  });

export const makeStore = () =&gt; {
  const isServer = typeof window === "undefined";
  if (isServer) {
    return makeConfiguredStore();
  } else {
    // we need it only on client side
    const persistConfig = {
      key: "nextjs",
      whitelist: ["auth"], // make sure it does not clash with server keys
      storage,
    };
    const persistedReducer = persistReducer(persistConfig, rootReducer);
    let store: any = configureStore({
      reducer: persistedReducer,
      devTools: process.env.NODE_ENV !== "production",
    });
    store.__persistor = persistStore(store); // Nasty hack
    return store;
  }
};

// Previous codes 

export const wrapper = createWrapper&lt;AppStore&gt;(makeStore);
</pre>
<p>在上面的代码中，我们试图理解我们是在处理服务器状态还是客户端状态。因为在服务器端，我们不需要持久性。</p>
<p>接下来，我们根据它是客户机还是服务器调用不同配置的<code>makeConfiguredStore</code>。在处理客户端状态时，我们需要使用<code>redux-toolkit</code>导出的<code>persistReducer</code>函数创建一个<code>persistedReducer</code>。我们使用<code>persistConfig</code>来指定密钥和存储类型。具体到<code>redux-tookit</code>，这里就不赘述了。然后，我们将这个<code>persistStore</code>赋给<code>store.__persistor</code>并返回它。</p>
<p>我们需要修改我们的<code>_app.tsx</code>文件来利用这个持久化的缩减器。</p>
<p>最终的代码如下所示:</p>
<pre class="language-typescript hljs">import "../styles/globals.css";
import type { AppProps } from "next/app";
import { wrapper } from "../store/store";
import { PersistGate } from "redux-persist/integration/react";
import { useStore } from "react-redux";
function MyApp({ Component, pageProps }: AppProps) {
  const store: any = useStore();
  return (
    &lt;PersistGate persistor={store.__persistor} loading={&lt;div&gt;Loading&lt;/div&gt;}&gt;
      &lt;Component {...pageProps} /&gt;
    &lt;/PersistGate&gt;
  );
}
export default wrapper.withRedux(MyApp);
</pre>
<p>基本上，我们用<code>PersistGate</code>包装我们的组件，并传递<code>store.__persistor</code>和一个可选的<code>loading</code>组件，以向用户显示我们的状态何时恢复。</p>
<p>现在，如果一切顺利，我们现在可以刷新我们的应用程序，身份验证状态将持续！</p>
<p>万岁！我们成功地将<code>redux-persist</code>添加到我们的应用程序中，允许我们管理身份验证。</p>
<h2 id="when-avoid-using-redux-next-js">什么时候应该避免在 Next.js 中使用 Redux？</h2>
<p>在某些情况下，Redux 可能不是最佳选择。像其他任何东西一样，Redux 也有一些缺点，在与 Next.js 集成时尤其如此。</p>
<p>我们来讨论一些不应该使用 Redux 的场景。</p>
<h3 id="building-small-scale-project">你正在建立一个小规模的项目</h3>
<p>如果您只是在构建一个小规模的项目，那么 Redux 可能有些过头了。在 Next.js 中，默认的状态管理解决方案能够并且将能够处理几乎所有的用例。因此，除非您构建一些重要的东西或概念验证，否则您应该考虑默认的状态管理解决方案。</p>
<h3 id="setup-complex">设置很复杂</h3>
<p>在 Next.js 中集成 Redux 是一个复杂的过程。如果您需要快速发布一个特性，使用 Redux 可能不是您的最佳选择。</p>
<h3 id="reacts-context-api-sufficient">反应的上下文应用编程接口就足够了</h3>
<p><a href="https://reactjs.org/docs/context.html">上下文</a>是 React 自己为组件间共享状态的解决方案。根据<a href="https://reactjs.org/docs/context.html">文件</a>:</p>
<blockquote><p>“上下文提供了一种通过组件树传递数据的方式，而不必在每一级手动向下传递属性。”</p></blockquote>
<p>这和 Redux 在做的事情一模一样。所以如果你不需要 Redux 那些花哨的功能，那就别费劲用了。对于大多数用例，React 的上下文 API 就足够了。</p>
<h2 id="conclusion">结论</h2>
<p>这就是如何将 Redux 与 Next.js 应用程序集成的方法！你可以在这里找到这个项目的 GitHub 库。我也鼓励你阅读<a href="https://github.com/kirill-konshin/next-redux-wrapper"> next-redux-wrapper </a>的文档，以了解更多关于其他用例的信息。</p>
<p>祝您愉快！</p><div class="code-block code-block-30">
<div class="blog-plug inline-plug next-plug"><h2><a href="https://lp.logrocket.com/blg/nextjs-signup" target="_blank"> LogRocket </a>:全面了解生产 Next.js 应用</h2><p>调试下一个应用程序可能会很困难，尤其是当用户遇到难以重现的问题时。如果您对监视和跟踪状态、自动显示 JavaScript 错误、跟踪缓慢的网络请求和组件加载时间感兴趣，</p><a href="https://lp.logrocket.com/blg/nextjs-signup" target="_blank">try LogRocket</a><p>. </p><a class="signup" href="https://lp.logrocket.com/blg/nextjs-signup" target="_blank" rel="noopener noreferrer"><img class="alignnone size-full wp-image-46 jetpack-lazy-image" src="../Images/f300c244a1a1cf916df8b4cb02bec6c6.png" data-lazy-src="https://files.readme.io/27c94e7-Image_2017-06-05_at_9.46.04_PM.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://files.readme.io/27c94e7-Image_2017-06-05_at_9.46.04_PM.png"/><noscript><img data-lazy-fallback="1" class="alignnone size-full wp-image-46" src="../Images/f300c244a1a1cf916df8b4cb02bec6c6.png" data-original-src="https://files.readme.io/27c94e7-Image_2017-06-05_at_9.46.04_PM.png"/></noscript></a><a class="signup" href="https://lp.logrocket.com/blg/nextjs-signup" target="_blank" rel="noopener noreferrer"><img class="alignnone size-full wp-image-46 jetpack-lazy-image" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/><noscript><img data-lazy-fallback="1" class="alignnone size-full wp-image-46" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/></noscript></a><p>LogRocket 就像是网络和移动应用的 DVR，记录下你的 Next.js 应用上发生的一切。您可以汇总并报告问题发生时应用程序的状态，而不是猜测问题发生的原因。LogRocket 还可以监控应用程序的性能，报告客户端 CPU 负载、客户端内存使用等指标。</p><p>LogRocket Redux 中间件包为您的用户会话增加了一层额外的可见性。LogRocket 记录 Redux 存储中的所有操作和状态。</p><p>让您调试 Next.js 应用的方式现代化— <a class="signup" href="https://lp.logrocket.com/blg/nextjs-signup" target="_blank" rel="noopener noreferrer">开始免费监控</a>。</p></div></div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
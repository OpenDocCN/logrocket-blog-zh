<html>
<head>
<title>Comparing Wayne.js with Express.js for service worker routing </title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>Wayne.js与Express.js在服务人员路由方面的比较</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/comparing-wayne-js-express-js-service-worker-routing/#0001-01-01">https://blog.logrocket.com/comparing-wayne-js-express-js-service-worker-routing/#0001-01-01</a></blockquote><div><article class="article-post">
<p>在本文中，我们将描述如何将一个简单的REST API从Express.js导出到Wayne.js，我们不会仅仅改变一个框架；我们将从云范式转换到边缘范式。<a href="https://blog.logrocket.com/express-js-5-migration-guide/"> Express.js </a>是一个简单的web服务器，旨在容纳一个<a href="https://blog.logrocket.com/10-best-practices-for-rest-api-design/"> REST API </a>，在较小的规模上，它再现了在云环境中的服务器上执行REST API的工作负载的概念。<a href="https://github.com/jcubic/wayne"> Wayne.js </a>是一个小工具包，允许你在浏览器中组装REST API。</p>
<p>令人惊讶的是，这些天你可以看到不同的设计范例在两个不同的方向推动精化。有可能理解这两种截然不同的观点为何仍然有意义。我指的是<a href="https://blog.logrocket.com/demystifying-edge-functions/">边缘计算</a>和<a href="https://en.wikipedia.org/wiki/Cloud_computing">云计算</a>的概念，它们是决定系统的大部分计算在哪里进行的完全不同的方法。在云计算中，计算是在云中进行的。在边缘计算中，工作负载在边缘设备上执行，如运行在用户PC、手机等设备上的浏览器。</p>
<p>为了更好地理解这些机制，我准备了一个包含三个目录的<a href="https://github.com/rosdec/wayne"> GitHub库</a>。首先，<code>basic</code>目录包含了服务工作者的基本实现，这将让我们探索它提供的简单机制。第二个目录是<code>simple-express</code>，这是一个使用Express.js和Node.js实现的简单REST API。它将是我们的参考实现，我将向您展示如何将其迁移到Wayne.js。第三个目录是<code>Wayne</code>目录，其中包含REST API的Wayne.js版本。</p>
<p><em>向前跳转:</em></p>

<h2 id="wayne-js">Wayne.js是什么？</h2>
<p>Wayne.js被设计成在浏览器中运行的服务工作者中实现HTTP服务器。服务人员在浏览器中托管简单的代理机制，以控制浏览器和云之间的流量，尤其是在没有或无法访问互联网的情况下。Wayne.js利用<a href="https://blog.logrocket.com/every-website-deserves-a-service-worker/">服务工作者</a>的概念来托管比简单的代理机制更具表现力的东西。</p>
<p>Wayne.js在服务工作器中使用Express.js的精确语义来实现一个可以在浏览器中运行的REST API。使用服务人员很简单，它由安装服务人员的代码和它实现的逻辑组成。安装Wayne.js的代码非常简单。</p>
<h3 id="installing-wayne-js">安装Wayne.js</h3>
<p>首先，检查<code>navigator</code>对象中<code>serviceWorker</code>容器的可用性。这是必要的，因为它可能无法在较旧的浏览器上或在私人浏览模式下使用:</p>
<pre class="language-javascript hljs">if ('serviceWorker' in navigator) {
 navigator.serviceWorker.register('/sw.js').then(function (registration) { 
  console.log('Service Worker installation success! Scope:',
   registration.scope);
 }).catch(function (error) {
  console.log('Service Worker installation failed:', error);
 });
}
</pre>
<p><code>serviceWorker</code>引入了<code>register</code>方法来告诉浏览器为服务工作者的逻辑实现哪个JavaScript文件。这里有一个显示<code>sw.js</code>文件的例子:</p>
<pre class="language-javascript hljs">self.addEventListener('install', event =&gt; {
    console.log("Service Worker Installed");
});

self.addEventListener('activate', event =&gt; {
    console.log("Service Worker Activated");
});

self.addEventListener('fetch', event =&gt; {
    console.log("Requested URL: " + event.request.url);
});
</pre>
<p>如您所见，它将打印一条关于服务人员生命周期中每个事件的消息。第一个事件是<code>install</code>，做一个你的服务人员需要的一次性初始化是有帮助的。</p>
<h3 id="activating-wayne-js">激活Wayne.js</h3>
<p>第二件事在服务人员的一生中只会发生一次。这与<code>install</code>不同，因为<code>activate</code>仅在第一次安装服务工作程序时触发，而不是每次安装新版本的服务工作程序时触发。这是因为先前版本的服务工作程序已经在运行。</p>
<p>要强制激活服务人员的新版本，您可以要求您的浏览器在每个页面上安装并激活，重新加载以始终运行最新版本。例如，Google Chrome中的“重新加载时更新”复选框位于开发人员窗口的“应用程序”选项卡中。对于开发服务人员来说，一个很好的经验法则是始终检查您运行的是不是最新版本，甚至卸载并重新安装它，以确保万无一失。当事情不顺利的时候，这将省去很多麻烦。</p>
<p>为了检查一切是否正常，使用您选择的web服务器(我通常使用<a href="https://www.npmjs.com/package/http-server"> http-server </a>)提供页面，您将在控制台窗口中看到正确触发的事件:</p>
<p><img data-attachment-id="143469" data-permalink="https://blog.logrocket.com/comparing-wayne-js-express-js-service-worker-routing/attachment/wayne-js-express-js-event-firing/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/12/wayne-js-express-js-event-firing.png" data-orig-size="730,292" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Wayne.js and Express.js event successfully firing" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/12/wayne-js-express-js-event-firing-300x120.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/12/wayne-js-express-js-event-firing.png" decoding="async" class="aligncenter size-full wp-image-143469 jetpack-lazy-image" src="../Images/3b767b721d9be9b3ce42f46ec55c30c1.png" alt="Wayne.js and Express.js Event Successfully Firing" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2022/12/wayne-js-express-js-event-firing.png 730w, https://blog.logrocket.com/wp-content/uploads/2022/12/wayne-js-express-js-event-firing-300x120.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2022/12/wayne-js-express-js-event-firing.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/12/wayne-js-express-js-event-firing.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="143469" data-permalink="https://blog.logrocket.com/comparing-wayne-js-express-js-service-worker-routing/attachment/wayne-js-express-js-event-firing/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/12/wayne-js-express-js-event-firing.png" data-orig-size="730,292" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Wayne.js and Express.js event successfully firing" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/12/wayne-js-express-js-event-firing-300x120.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/12/wayne-js-express-js-event-firing.png" decoding="async" loading="lazy" class="aligncenter size-full wp-image-143469" src="../Images/3b767b721d9be9b3ce42f46ec55c30c1.png" alt="Wayne.js and Express.js Event Successfully Firing" srcset="https://blog.logrocket.com/wp-content/uploads/2022/12/wayne-js-express-js-event-firing.png 730w, https://blog.logrocket.com/wp-content/uploads/2022/12/wayne-js-express-js-event-firing-300x120.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/12/wayne-js-express-js-event-firing.png"/></noscript>
<h2 id="rest-api-express-js-wayne-js">从Express.js到Wayne.js的REST API</h2>
<p>在资源库的目录<code>simple-express</code>中，您会发现一个简单的REST API。这不是非常令人兴奋，但它不仅仅是一句“你好，世界！”显示API基础的API。它有两个<code>GET</code>服务:一个获取<code>query</code>字符串的参数，另一个没有参数。此外，API的主体中有一个接受参数的<code>POST</code>服务。</p>
<p>这是一个Express.js项目，所以您将能够用一个简单的执行<code>simple-express.js</code>的<code>node.</code>来执行它。这将在<code>index.html</code>文件中分配API服务并服务于web应用程序UI。通过摆弄web应用程序，您将能够理解您可以做什么——只需向数组中添加元素并列出它们。</p>
<h3 id="relocating-wayne-js">搬迁至Wayne.js</h3>
<p>至此，你应该明白Wayne.js的神奇之处在哪里了。Wayne.js是一个特殊的服务工作者，它通过将通常位于服务器端点的<code>fetch</code>操作重定向到服务工作者文件中实现的方法来模仿REST API的结构。</p>
<p>如果你把<code>simple-express/simple-express.js</code>和<code>wayne/wayne-service-worker.js</code>放在一起看，你会发现它们几乎是一样的。别担心。我们将很快讨论它们的细微差别，但是这里有一个范式的转变。</p>
<h2 id="comparing-wayne-js-express-js">比较Wayne.js和Express.js</h2>
<p>Express.js版本在服务器上执行，而Wayne.js版本驻留在浏览器中。澄清一下，Wayne.js API版本是由<code>http-server</code>执行的。这是从服务器的角度来看的，这表明API和前端是服务于浏览器的静态文件。整个API逻辑只在浏览器中执行。这可以通过检查HTTP服务器日志来轻松验证:</p>
<p><img data-attachment-id="143471" data-permalink="https://blog.logrocket.com/comparing-wayne-js-express-js-service-worker-routing/attachment/comparing-wayne-js-express-js-http-server-log/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/12/comparing-wayne-js-express-js-HTTP-server-log.png" data-orig-size="730,32" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Comparing Wanye.js and Express.js HTTP server log" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/12/comparing-wayne-js-express-js-HTTP-server-log-300x13.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/12/comparing-wayne-js-express-js-HTTP-server-log.png" decoding="async" class="aligncenter size-full wp-image-143471 jetpack-lazy-image" src="../Images/fe61ef39b989c036373a72d3277f06d4.png" alt="Comparing Wanye.js and Express.js HTTP Server Log" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2022/12/comparing-wayne-js-express-js-HTTP-server-log.png 730w, https://blog.logrocket.com/wp-content/uploads/2022/12/comparing-wayne-js-express-js-HTTP-server-log-300x13.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2022/12/comparing-wayne-js-express-js-HTTP-server-log.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/12/comparing-wayne-js-express-js-HTTP-server-log.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="143471" data-permalink="https://blog.logrocket.com/comparing-wayne-js-express-js-service-worker-routing/attachment/comparing-wayne-js-express-js-http-server-log/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/12/comparing-wayne-js-express-js-HTTP-server-log.png" data-orig-size="730,32" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Comparing Wanye.js and Express.js HTTP server log" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/12/comparing-wayne-js-express-js-HTTP-server-log-300x13.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/12/comparing-wayne-js-express-js-HTTP-server-log.png" decoding="async" loading="lazy" class="aligncenter size-full wp-image-143471" src="../Images/fe61ef39b989c036373a72d3277f06d4.png" alt="Comparing Wanye.js and Express.js HTTP Server Log" srcset="https://blog.logrocket.com/wp-content/uploads/2022/12/comparing-wayne-js-express-js-HTTP-server-log.png 730w, https://blog.logrocket.com/wp-content/uploads/2022/12/comparing-wayne-js-express-js-HTTP-server-log-300x13.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/12/comparing-wayne-js-express-js-HTTP-server-log.png"/></noscript>
<p>一旦<code>index.html</code>和<code>wayne-service-worker.js</code>被提供给浏览器，与前端的每一次后续交互都将发生在浏览器中，不会在<code>http-server</code>上产生日志。这显示了这种方法的真正潜力，因为您甚至可以关闭服务器。因此，交互和API调用永远不会离开浏览器，使您的应用程序即使在脱机模式下也能运行:</p>
<p><img data-attachment-id="143473" data-permalink="https://blog.logrocket.com/comparing-wayne-js-express-js-service-worker-routing/attachment/wayne-js-express-js-working-offline/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/12/wayne-js-express-js-working-offline.png" data-orig-size="730,354" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Wayne.js vs. Express.js working offline" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/12/wayne-js-express-js-working-offline-300x145.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/12/wayne-js-express-js-working-offline.png" decoding="async" class="aligncenter size-full wp-image-143473 jetpack-lazy-image" src="../Images/9df20e7d18eae343da781c685fe72cf0.png" alt="Wayne.js Vs. Express.js Working Offline" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2022/12/wayne-js-express-js-working-offline.png 730w, https://blog.logrocket.com/wp-content/uploads/2022/12/wayne-js-express-js-working-offline-300x145.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2022/12/wayne-js-express-js-working-offline.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/12/wayne-js-express-js-working-offline.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="143473" data-permalink="https://blog.logrocket.com/comparing-wayne-js-express-js-service-worker-routing/attachment/wayne-js-express-js-working-offline/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/12/wayne-js-express-js-working-offline.png" data-orig-size="730,354" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Wayne.js vs. Express.js working offline" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/12/wayne-js-express-js-working-offline-300x145.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/12/wayne-js-express-js-working-offline.png" decoding="async" loading="lazy" class="aligncenter size-full wp-image-143473" src="../Images/9df20e7d18eae343da781c685fe72cf0.png" alt="Wayne.js Vs. Express.js Working Offline" srcset="https://blog.logrocket.com/wp-content/uploads/2022/12/wayne-js-express-js-working-offline.png 730w, https://blog.logrocket.com/wp-content/uploads/2022/12/wayne-js-express-js-working-offline-300x145.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/12/wayne-js-express-js-working-offline.png"/></noscript>
<p>Wayne.js和Express.js对于服务工作者路由的区别之一在于如何处理<code>query</code>字符串参数。在Express.js(右)中，参数用冒号指定，而在Wayne.js中，每个参数用花括号定义(右边的第19行和左边的第11行)。</p>
<p>另一个区别是请求<code>body</code>是立即可用的，而在Wayne.js中，它是通过一个承诺来访问的(左边的第32行和右边的第24行)。在这个机制上，<a href="https://github.com/jcubic/wayne#api-reference">文档</a>更深入一点。它为<code>body</code>提供了不同的访问器，以不同的格式返回它:</p>
<ul>
<li><code>arrayBuffer()</code>:对于一个<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer"> <code>ArrayBuffer</code> </a>表示</li>
<li><code>blob()</code>:获取请求体的非结构化<a href="https://developer.mozilla.org/en-US/docs/Web/API/Blob"> <code>Blob</code> </a>表示</li>
<li><code>formData()</code>:用于<code><a href="https://developer.mozilla.org/en-US/docs/Web/API/FormData"><code>FormData</code> </a> </code>处理结构化的基于表单的请求</li>
<li><code>json()</code>:让你把身体当作<a href="https://developer.mozilla.org/en-US/docs/Web/API/Request/json"> <code>JSON</code> </a></li>
<li>请求体最直接的表示，任何进一步的解析都留给你</li>
</ul>
<p>正如您所看到的，通过这些方法，您将能够处理您期望在REST API中处理的所有标准格式。Wayne提供的附加功能是<code>redirect()</code>操作，它允许您将API调用重定向到其他端点。它的工作原理与Express相同，但是考虑到浏览器内API的不同架构，您可以使用这种机制来做一些聪明的事情。</p>
<p>假设您的本地API可以在浏览器离线时提供近似的结果，并可以在浏览器再次在线时重定向到同一API的更强大版本，这可以通过重定向调用来实现。</p>
<p>这是实现<a href="https://blog.logrocket.com/why-you-should-turn-your-app-into-a-pwa/">渐进式Web应用</a> (PWA)的正确方式。这些网络应用将在有限或没有互联网接入的情况下继续工作，并在连接重新建立时无缝工作。</p>
<p>如果您一直关注我，那么通过查看代码，应该可以清楚地看到，为Express.js或Wayne.js编写REST API之间没有(显著的)区别，主要区别在于Wayne.js允许您直接在浏览器中迁移REST API，为您的web应用程序/API组合提供完全不同的架构支持。这意味着更多的代码在浏览器中执行，将计算推到边缘，并且在极端情况下可以提供更多的灵活性，其中您的web应用程序可以在极端条件下保持工作(即，没有或不可靠的互联网连接)。</p>
<h2>结论</h2>
<p>Wayne.js是一种设计REST API及其前端的智能方法，它让您无需(太多)修改就可以将任何REST API移植到浏览器中运行。本文描述了如何将一个简单的REST API从Express.js导出到Wayne.js，目的是展示如何在浏览器中运行的Wayne.js服务工作器中实现REST API。从更具战略性的角度来看，Wayne.js可能是朝着开发一个在有限的互联网连接下继续工作的PWA迈出的一步。</p><div class="code-block code-block-23">
<div class="blog-plug inline-plug node-plug"><h2>200只<img src="../Images/61167b9d027ca73ed5aaf59a9ec31267.png" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2019/10/green-check.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" class=" jetpack-lazy-image" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/10/green-check.png"/> <noscript> <img data-lazy-fallback="1" src="../Images/61167b9d027ca73ed5aaf59a9ec31267.png" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/10/green-check.png"/> </noscript>显示器出现故障，生产中网络请求缓慢</h2><p>部署基于节点的web应用程序或网站是容易的部分。确保您的节点实例继续为您的应用程序提供资源是事情变得更加困难的地方。如果您对确保对后端或第三方服务的请求成功感兴趣，</p><a href="https://lp.logrocket.com/blg/node-signup" target="_blank">try LogRocket</a><p>. </p><a class="signup" href="https://lp.logrocket.com/blg/node-signup" target="_blank" rel="noopener noreferrer"><img src="../Images/cae72fd2a54c5f02a6398c4867894844.png" alt="LogRocket Network Request Monitoring" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2019/12/network-request-filter-2-1.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" class=" jetpack-lazy-image" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/12/network-request-filter-2-1.png"/><noscript><img data-lazy-fallback="1" src="../Images/cae72fd2a54c5f02a6398c4867894844.png" alt="LogRocket Network Request Monitoring" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/12/network-request-filter-2-1.png"/></noscript></a><a href="https://lp.logrocket.com/blg/node-signup" target="_blank" rel="noopener noreferrer">https://logrocket.com/signup/</a><p>LogRocket 就像是网络和移动应用程序的DVR，记录下用户与你的应用程序交互时发生的一切。您可以汇总并报告有问题的网络请求，以快速了解根本原因，而不是猜测问题发生的原因。</p><p>LogRocket检测您的应用程序以记录基线性能计时，如页面加载时间、到达第一个字节的时间、慢速网络请求，还记录Redux、NgRx和Vuex操作/状态。</p><a class="signup" href="https://lp.logrocket.com/blg/node-signup" target="_blank" rel="noopener noreferrer">Start monitoring for free</a><p>. </p></div>
</div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
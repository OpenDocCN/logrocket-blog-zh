<html>
<head>
<title>How to build a geocaching app with Android’s Fused Location </title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>如何使用Android的融合位置构建地理藏宝应用</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/how-to-build-geocaching-app-androids-fused-location/#0001-01-01">https://blog.logrocket.com/how-to-build-geocaching-app-androids-fused-location/#0001-01-01</a></blockquote><div><article class="article-post">
<p>根据牛津词典，地理藏宝是指“一项活动或消遣，其中一个项目或一个装有几个项目的容器被隐藏在一个特定的位置，以便GPS用户使用互联网上发布的坐标找到。”</p>
<p>对于地理藏宝应用程序，我们希望应用程序在用户位于项目a的特定半径范围内时通知用户。假设用户(由标记表示)将项目存储在由另一个标记表示的坐标中。在这种情况下，项目的标记是静态的，而用户的标记是动态的。</p>
<p>使用Android中的融合位置库，我们可以构建一个地理藏宝应用程序，提供关于当前用户坐标的后台服务通知。如果用户在缓存的五英里半径范围内，他们将收到通知，如果他们靠近或远离该项目，将继续更新距离计算。</p>
<p>在本教程结束时，我们的应用程序将如下所示:</p>
<p> </p>
<p><img data-attachment-id="145616" data-permalink="https://blog.logrocket.com/how-to-build-geocaching-app-androids-fused-location/attachment/geocaching-app-3/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/12/geocaching-app.gif" data-orig-size="350,739" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Geocaching app" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/12/geocaching-app-142x300.gif" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/12/geocaching-app.gif" decoding="async" class="aligncenter size-full wp-image-145616 jetpack-lazy-image" src="../Images/ed200704b1fbe6b63f4bafc8bb937c20.png" alt="Geocaching App" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2022/12/geocaching-app.gif?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/12/geocaching-app.gif"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="145616" data-permalink="https://blog.logrocket.com/how-to-build-geocaching-app-androids-fused-location/attachment/geocaching-app-3/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/12/geocaching-app.gif" data-orig-size="350,739" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Geocaching app" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/12/geocaching-app-142x300.gif" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/12/geocaching-app.gif" decoding="async" loading="lazy" class="aligncenter size-full wp-image-145616" src="../Images/ed200704b1fbe6b63f4bafc8bb937c20.png" alt="Geocaching App" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/12/geocaching-app.gif"/></noscript>
<p>向前跳:</p>

<h2 id="prerequisites">先决条件</h2>
<p>读者需要在其特定设备上安装<a href="https://developer.android.com/studio?gclid=Cj0KCQjw--2aBhD5ARIsALiRlwCoYCg3Mx_u8KzH64Fklt5kQGDUdg6MUGPwmcTH1ktpLeoyPIdCjLgaApS-EALw_wcB&amp;gclsrc=aw.ds#downloads">Android</a><a href="https://developer.android.com/studio?gclid=Cj0KCQjw--2aBhD5ARIsALiRlwCoYCg3Mx_u8KzH64Fklt5kQGDUdg6MUGPwmcTH1ktpLeoyPIdCjLgaApS-EALw_wcB&amp;gclsrc=aw.ds#downloads">S</a><a href="https://developer.android.com/studio?gclid=Cj0KCQjw--2aBhD5ARIsALiRlwCoYCg3Mx_u8KzH64Fklt5kQGDUdg6MUGPwmcTH1ktpLeoyPIdCjLgaApS-EALw_wcB&amp;gclsrc=aw.ds#downloads">tudio</a>代码编辑器和Kotlin。</p>
<h2 id="getting-started">入门指南</h2>
<p>我们将从创建一个谷歌<code>MapFragment</code>开始。为此，创建一个新的Android Studio项目。选择<strong>谷歌地图活动</strong>作为您的模板，并填写我们的应用名称和包名称。这样做可以减少很多流程，因为现在我们只需要从Google控制台获取一个API键:</p>
<p><img data-attachment-id="145526" data-permalink="https://blog.logrocket.com/how-to-build-geocaching-app-androids-fused-location/attachment/google-mapfragment-process/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/12/google-mapfragment-process.png" data-orig-size="720,405" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Google MapFragment Process" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/12/google-mapfragment-process-300x169.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/12/google-mapfragment-process.png" decoding="async" class="aligncenter size-full wp-image-145526 jetpack-lazy-image" src="../Images/1ef8e53ef62405c47a83889e8a3f5ac1.png" alt="Google MapFragment Process" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2022/12/google-mapfragment-process.png 720w, https://blog.logrocket.com/wp-content/uploads/2022/12/google-mapfragment-process-300x169.png 300w" data-lazy-sizes="(max-width: 720px) 100vw, 720px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2022/12/google-mapfragment-process.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/12/google-mapfragment-process.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="145526" data-permalink="https://blog.logrocket.com/how-to-build-geocaching-app-androids-fused-location/attachment/google-mapfragment-process/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/12/google-mapfragment-process.png" data-orig-size="720,405" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Google MapFragment Process" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/12/google-mapfragment-process-300x169.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/12/google-mapfragment-process.png" decoding="async" loading="lazy" class="aligncenter size-full wp-image-145526" src="../Images/1ef8e53ef62405c47a83889e8a3f5ac1.png" alt="Google MapFragment Process" srcset="https://blog.logrocket.com/wp-content/uploads/2022/12/google-mapfragment-process.png 720w, https://blog.logrocket.com/wp-content/uploads/2022/12/google-mapfragment-process-300x169.png 300w" sizes="(max-width: 720px) 100vw, 720px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/12/google-mapfragment-process.png"/></noscript>
<p><img data-attachment-id="145530" data-permalink="https://blog.logrocket.com/how-to-build-geocaching-app-androids-fused-location/attachment/new-project-android-studio/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/12/new-project-android-studio.png" data-orig-size="720,405" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="New project in Android Studio" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/12/new-project-android-studio-300x169.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/12/new-project-android-studio.png" decoding="async" class="aligncenter size-full wp-image-145530 jetpack-lazy-image" src="../Images/f4204ee235e81718e75f985010d0e01e.png" alt="New Project In Android Studio" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2022/12/new-project-android-studio.png 720w, https://blog.logrocket.com/wp-content/uploads/2022/12/new-project-android-studio-300x169.png 300w" data-lazy-sizes="(max-width: 720px) 100vw, 720px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2022/12/new-project-android-studio.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/12/new-project-android-studio.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="145530" data-permalink="https://blog.logrocket.com/how-to-build-geocaching-app-androids-fused-location/attachment/new-project-android-studio/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/12/new-project-android-studio.png" data-orig-size="720,405" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="New project in Android Studio" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/12/new-project-android-studio-300x169.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/12/new-project-android-studio.png" decoding="async" loading="lazy" class="aligncenter size-full wp-image-145530" src="../Images/f4204ee235e81718e75f985010d0e01e.png" alt="New Project In Android Studio" srcset="https://blog.logrocket.com/wp-content/uploads/2022/12/new-project-android-studio.png 720w, https://blog.logrocket.com/wp-content/uploads/2022/12/new-project-android-studio-300x169.png 300w" sizes="(max-width: 720px) 100vw, 720px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/12/new-project-android-studio.png"/></noscript>
<p><img data-attachment-id="145528" data-permalink="https://blog.logrocket.com/how-to-build-geocaching-app-androids-fused-location/attachment/google-maps-activity-project/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/12/google-maps-activity-project.png" data-orig-size="720,405" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Google Maps Activity Project" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/12/google-maps-activity-project-300x169.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/12/google-maps-activity-project.png" decoding="async" class="aligncenter size-full wp-image-145528 jetpack-lazy-image" src="../Images/d255fd66326d5fa2a4d1139744a0e1c9.png" alt="Google Maps Activity Project" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2022/12/google-maps-activity-project.png 720w, https://blog.logrocket.com/wp-content/uploads/2022/12/google-maps-activity-project-300x169.png 300w" data-lazy-sizes="(max-width: 720px) 100vw, 720px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2022/12/google-maps-activity-project.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/12/google-maps-activity-project.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="145528" data-permalink="https://blog.logrocket.com/how-to-build-geocaching-app-androids-fused-location/attachment/google-maps-activity-project/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/12/google-maps-activity-project.png" data-orig-size="720,405" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Google Maps Activity Project" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/12/google-maps-activity-project-300x169.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/12/google-maps-activity-project.png" decoding="async" loading="lazy" class="aligncenter size-full wp-image-145528" src="../Images/d255fd66326d5fa2a4d1139744a0e1c9.png" alt="Google Maps Activity Project" srcset="https://blog.logrocket.com/wp-content/uploads/2022/12/google-maps-activity-project.png 720w, https://blog.logrocket.com/wp-content/uploads/2022/12/google-maps-activity-project-300x169.png 300w" sizes="(max-width: 720px) 100vw, 720px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/12/google-maps-activity-project.png"/></noscript>
<p>接下来，我们将前往<a href="https://console.cloud.google.com/apis"> Google开发者控制台</a>获取API密钥。</p>
<p>然后，选择<strong>创建凭证</strong>和<strong> API key </strong>来创建API key:</p>

<p>复制我们新创建的键，转到<code>AndroidManifest.xml</code>文件，用关键字API key将它粘贴到元数据标签属性<code>value</code>:</p>
<p><img data-attachment-id="145540" data-permalink="https://blog.logrocket.com/how-to-build-geocaching-app-androids-fused-location/attachment/paste-new-key-metadata-tag/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/12/paste-new-key-metadata-tag.png" data-orig-size="730,375" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Paste new key into metadata tag" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/12/paste-new-key-metadata-tag-300x154.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/12/paste-new-key-metadata-tag.png" decoding="async" class="aligncenter size-full wp-image-145540 jetpack-lazy-image" src="../Images/86ae4dadbebdb12f59d48506b0a894ea.png" alt="Paste New Key Into Metadata Tag" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2022/12/paste-new-key-metadata-tag.png 730w, https://blog.logrocket.com/wp-content/uploads/2022/12/paste-new-key-metadata-tag-300x154.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2022/12/paste-new-key-metadata-tag.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/12/paste-new-key-metadata-tag.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="145540" data-permalink="https://blog.logrocket.com/how-to-build-geocaching-app-androids-fused-location/attachment/paste-new-key-metadata-tag/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/12/paste-new-key-metadata-tag.png" data-orig-size="730,375" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Paste new key into metadata tag" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/12/paste-new-key-metadata-tag-300x154.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/12/paste-new-key-metadata-tag.png" decoding="async" loading="lazy" class="aligncenter size-full wp-image-145540" src="../Images/86ae4dadbebdb12f59d48506b0a894ea.png" alt="Paste New Key Into Metadata Tag" srcset="https://blog.logrocket.com/wp-content/uploads/2022/12/paste-new-key-metadata-tag.png 730w, https://blog.logrocket.com/wp-content/uploads/2022/12/paste-new-key-metadata-tag-300x154.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/12/paste-new-key-metadata-tag.png"/></noscript>
<h2 id="creating-functionalities">创建功能</h2>
<p>按照上面的步骤操作后，我们只剩下一个由Android Studio自动创建的自定义谷歌地图了。在本节中，我们希望使用<code>fusedlcation</code> API为用户获得连续的位置更新，即使在关闭应用程序之后。我们将通过后台通知更新来实现这一点。</p>
<p>首先，转到模块<code>build.gradle</code>文件，添加下面的依赖项:</p>
<pre class="language-gradle hljs">implementation 'com.google.android.gms:play-services-location:20.0.0'
implementation "org.jetbrains.kotlinx:kotlinx-coroutines-android:1.3.9"
</pre>
<p><img data-attachment-id="145542" data-permalink="https://blog.logrocket.com/how-to-build-geocaching-app-androids-fused-location/attachment/adding-dependencies-to-buildgradle-model/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/12/adding-dependencies-to-buildgradle-model.png" data-orig-size="730,410" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Adding Dependencies To Build.Gradle File" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/12/adding-dependencies-to-buildgradle-model-300x168.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/12/adding-dependencies-to-buildgradle-model.png" decoding="async" class="aligncenter size-full wp-image-145542 jetpack-lazy-image" src="../Images/aad519c542c2059dad101a874cee1cf8.png" alt="Adding Dependencies To Build.Gradle File" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2022/12/adding-dependencies-to-buildgradle-model.png 730w, https://blog.logrocket.com/wp-content/uploads/2022/12/adding-dependencies-to-buildgradle-model-300x168.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2022/12/adding-dependencies-to-buildgradle-model.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/12/adding-dependencies-to-buildgradle-model.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="145542" data-permalink="https://blog.logrocket.com/how-to-build-geocaching-app-androids-fused-location/attachment/adding-dependencies-to-buildgradle-model/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/12/adding-dependencies-to-buildgradle-model.png" data-orig-size="730,410" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Adding Dependencies To Build.Gradle File" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/12/adding-dependencies-to-buildgradle-model-300x168.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/12/adding-dependencies-to-buildgradle-model.png" decoding="async" loading="lazy" class="aligncenter size-full wp-image-145542" src="../Images/aad519c542c2059dad101a874cee1cf8.png" alt="Adding Dependencies To Build.Gradle File" srcset="https://blog.logrocket.com/wp-content/uploads/2022/12/adding-dependencies-to-buildgradle-model.png 730w, https://blog.logrocket.com/wp-content/uploads/2022/12/adding-dependencies-to-buildgradle-model-300x168.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/12/adding-dependencies-to-buildgradle-model.png"/></noscript>
<p>接下来，返回到<code>AndroidManifest.xml</code>文件，在applications标签的正上方设置以下权限:</p>
<pre class="language-xml hljs">&lt;uses-permission android:name="android.permission.INTERNET" /&gt;
&lt;uses-permission android:name="android.permission.ACCESS_COARSE_LOCATION" /&gt;
&lt;uses-permission android:name="android.permission.ACCESS_FINE_LOCATION" /&gt;
&lt;uses-permission android:name="android.permission.FOREGROUND_SERVICE" /&gt;
</pre>
<h3 id="creating-abstractions-permission-settings">创建抽象和权限设置</h3>
<p>我们不想打开一个应用程序，并自动获得位置访问(好吧，应用程序不这样工作)。相反，我们希望客户端得到一个通知，要求访问一些系统设置。</p>
<p>我们将构建一个接口文件，抽象出根文件夹中的位置更新，并将其命名为<code>ClientInfo.kt</code>。在该接口中，我们将创建一个函数，其参数interval指定了我们希望位置更新的频率。该函数将从我们之前添加到依赖项的协程库中返回一个类型为<code>Location</code>的<code>Flow</code>。</p>
<p>我们还将创建一个类，以便在GPS关闭时传递消息:</p>
<pre class="language-kotlin hljs">interface ClientInfo {
    fun getLocationUpdates(interval: Long): Flow&lt;Location&gt;

    class LocException(message: String): Exception()
}
</pre>
<p>现在，我们需要展示<code>ClientInfo</code>的实现。因此，在同一个根文件夹中，创建一个名为<code>DefaultClientInfo.kt</code>的类文件，它将实现我们上面声明的接口(<code>ClientInfo</code>)。该类将接受两个构造函数参数:<code>Context</code>和<code>FusedLocationProviderClient</code>。</p>
<p>接下来，我们将覆盖<code>getLocationUpdates</code>函数，并使用<em> <code>callbackFlow</code> </em>实例，我们将首先检查用户是否接受了位置许可。我们将通过在同一个根文件夹中创建一个名为<code>ExtendContext.kt</code>的实用程序文件来编写一个返回布尔值的扩展函数。</p>
<p>该函数将检查是否授予了<code>COARSE</code>和<code>FINE_LOCATION</code>权限:</p>
<pre class="language-xml hljs">fun Context.locationPermission(): Boolean{
    return  ContextCompat.checkSelfPermission(
        this,
        Manifest.permission.ACCESS_COARSE_LOCATION
    )== PackageManager.PERMISSION_GRANTED &amp;&amp;
            ContextCompat.checkSelfPermission(
                this,
                Manifest.permission.ACCESS_FINE_LOCATION
            ) == PackageManager.PERMISSION_GRANTED
}
</pre>
<p>如果用户有允许的权限，我们想检查他们是否可以使用<code>SytemService LocationManager</code>获取他们的位置(如果位置被启用)。</p>
<p>现在我们可以获取用户的位置，我们需要创建一个请求来指定获取用户位置的频率和数据的准确性。此外，我们将创建一个回调函数，每当<a href="https://developers.google.com/android/reference/com/google/android/gms/location/FusedLocationProviderClient">F</a>T3】usedLocationProviderClient获取一个新位置时，该回调函数将使用<code>onLocationResult</code>函数。</p>
<p>最后，我们将使用<code>fusedlocation.requestLocationUpdates</code>方法调用回调函数、请求和一个looper。下面是实现过程:</p>
<pre class="language-kotlin hljs">class DefaultClientInfo(
    private val context:Context,
    private val fusedlocation: FusedLocationProviderClient
):ClientInfo{

    @SuppressLint("MissingPermission")
    override fun getLocationUpdates(interval: Long): Flow&lt;Location&gt; {
        return callbackFlow {
            if(!context.locationPermission()){
                throw ClientInfo.LocException("Missing Permission")
            }

            val locationManager = context.getSystemService(Context.LOCATION_SERVICE) as LocationManager
            val hasGPS = locationManager.isProviderEnabled(LocationManager.GPS_PROVIDER)
            val hasNetwork = locationManager.isProviderEnabled(LocationManager.NETWORK_PROVIDER)
            if(!hasGPS &amp;&amp; hasNetwork){
                throw  ClientInfo.LocException("GPS is unavailable")
            }

            val locationRequest = LocationRequest.create().apply {
                setInterval(interval)
                fastestInterval = interval
                priority = Priority.PRIORITY_HIGH_ACCURACY
            }
            val locationCallback = object : LocationCallback(){
                override fun onLocationResult(result: LocationResult) {
                    super.onLocationResult(result)
                    result.locations.lastOrNull()?.let{ location -&gt;
                        launch { send(location) }
                    }
                }
            }

            fusedlocation.requestLocationUpdates(
                locationRequest,
                locationCallback,
                Looper.getMainLooper()
            )

            awaitClose {
                fusedlocation.removeLocationUpdates(locationCallback)
            }
        }
    }
}
</pre>
<h3 id="creating-foreground-service">创建前台服务</h3>
<p>为了创建前台服务，我们将在我们的根项目中创建另一个名为<code>locservices.kt</code>的类文件，并使它从服务类继承。使用协程，我们将创建一个绑定到服务生命周期的<code>serviceScope</code>，调用我们之前创建的<code>ClientInfo</code>抽象，以及一个存储缓存坐标信息的类。</p>
<pre class="language-kotlin hljs">class LocServices: Service(){

    private val serviceScope = CoroutineScope(SupervisorJob() + Dispatchers.IO)
    private lateinit var clientInfo: ClientInfo

}
</pre>
<p>接下来，我们将创建一个返回<code>null</code>的<code>onBind</code>函数，因为我们没有将服务绑定到任何东西。然后，我们将使用<code>onCreate</code>函数来调用<code>DefaultClientInfo</code>类，其中我们将提供<code><em>applicationContext</em></code>和<br/> <code>LocationServices.getFusedLocationProviderClient(<em>applicationContext</em>)</code>作为参数。</p>
<pre class="language-kotlin hljs">class LocServices: Service(){

    // do something

    override fun onBind(p0: Intent?): IBinder? {
        return null
    }

    override fun onCreate() {
        super.onCreate()
        clientInfo = DefaultClientInfo(
            applicationContext,
            LocationServices.getFusedLocationProviderClient(applicationContext)
        )
    }
}
</pre>
<p>现在，我们将创建一个<code>companion object</code>，并在其中创建一个常量值<code>START</code>，当我们想要开始跟踪时，我们会将它发送给服务。然后，我们将调用服务的<code>onStartCommand()</code>函数，并提供我们之前创建的常量作为链接到<code>start()</code>函数的<code>intent</code>:</p>
<pre class="language-kotlin hljs">class LocServices: Service(){

    override fun onStartCommand(intent: Intent?, flags: Int, startId: Int): Int {
        when(intent?.action){
            START -&gt; start()
        }
        return super.onStartCommand(intent, flags, startId)
    }

    @SuppressLint("NewApi")
    private fun start(){
    }

    companion object{
        const val START = "Start"
    }
}
</pre>
<p><code>start</code>函数将处理通知，以提醒用户他们的位置正被主动监控。这意味着我们想要提供给用户的信息是他们和缓存之间的距离(以米为单位)。为此，我们将使用<a href="https://en.wikipedia.org/wiki/Haversine_formula">Ha</a>T3】正矢公式，该公式使用球面上两点的坐标来计算它们之间的距离。</p>
<p>因此，使用我们的<code>callbackflow</code>，我们将调用<code>clientInfo.getLocationUpdates(interval)</code>方法，并使用<code>coroutines</code>提供的<code>onEach</code>方法，我们将能够获得更新的纬度和经度。</p>
<p>正如我们前面所说的，我们希望用户知道他们和缓存之间的距离，但是有一个问题。我们不希望用户不断收到通知，告诉他们与缓存之间的距离。</p>
<p>因此，我们将创建一个条件语句，检查用户是否在缓存的一千米半径内。如果为真，用户将得到一个持续的通知，通知他们是否离缓存更远或更近。一旦他们进入50米半径范围内，他们会收到不同的消息通知，并且服务会停止:</p>
<pre class="language-kotlin hljs">class LocServices: Service(){

    @SuppressLint("NewApi")
    private fun start(){
        val notif = NotificationCompat.Builder(this, "location")
            .setContentTitle("Geocaching")
            .setContentText("runnning in the background")
            .setSmallIcon(R.drawable.ic_launcher_background)
            .setOngoing(true)
        val notificationManager = getSystemService(Context.NOTIFICATION_SERVICE) as NotificationManager

        clientInfo
            .getLocationUpdates(1000L)
            .catch { e -&gt; e.printStackTrace() }
            .onEach { location -&gt;
                val lat1 = location.latitude
                val long1 = location.longitude
                val radius = 6371 //in km
                val lat2 = secrets.d
                val long2 = secrets.d1
                val dlat = Math.toRadians(lat2 - lat1)
                val dlong = Math.toRadians(long2 - long1)
                val a = sin(dlat / 2) * sin(dlong / 2) + cos(Math.toRadians(lat1)) * cos(Math.toRadians(lat2)) * sin(dlong / 2) * sin(dlong / 2)
                val c = 2 * asin(sqrt(a))
                val valuresult = radius * c
                val km = valuresult / 1
                val meter = km * 1000
                val truemeter = String.format("%.2f", meter)
                if (meter &gt; 100 &amp;&amp; meter &lt;= 1000){
                    val updatednotif = notif
                        .setContentText("You are $truemeter meters away")
                    notificationManager.notify(1, updatednotif.build())
                }
                if (meter &lt; 100){
                    val getendnotice = notif
                        .setContentText("You are $truemeter meters away, continue with your search")
                        .setOngoing(false)
                    notificationManager.notify(1, getendnotice.build())
                    stopForeground(STOP_FOREGROUND_DETACH)
                    stopSelf()
                }
            }
            .launchIn(serviceScope)
        startForeground(1, notif.build())
    }
}
</pre>
<p>最后，我们将创建一个<code>onDestroy</code>函数，当我们关闭应用程序或清除系统缓存时，该函数会取消服务。下面是代码的实现:</p>
<pre class="language-kotlin hljs">class LocServices: Service(){
    override fun onDestroy() {
        super.onDestroy()
        serviceScope.cancel()
    }
}
</pre>
<p>现在我们已经准备好前台服务，我们将返回到<code>AndroidManifest.xml</code>文件和元数据标签正上方的标签:</p>
<pre class="language-xml hljs">&lt;service android:name=".fusedLocation.LocServices"
    android:foregroundServiceType = "location"/&gt;
</pre>
<h3 id="notificationchannel">通知渠道</h3>
<p>如果我们想为用户到缓存的距离创建一个通知，我们需要创建一个通道来发送通知。让我们首先创建一个名为<code>LocationApp.kt</code>的类，我们将创建一个<code>Application()</code>。</p>
<p>在<code>onCreate</code>函数中，我们将从Android oreo OS向上创建一个通知通道。代码如下所示:</p>
<pre class="language-kotlin hljs">class LocationApp: Application() {

    override fun onCreate() {
        super.onCreate()
        if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O) {
            val channel = NotificationChannel(
                "location",
                "Location",
                NotificationManager.IMPORTANCE_LOW
            )
            val notificationManager = getSystemService(Context.NOTIFICATION_SERVICE) as NotificationManager
            notificationManager.createNotificationChannel(channel)
        }
    }
}
</pre>
<p>最后，我们将属性添加到下面的<code>AndroidManifest.xml</code>文件的应用程序标签中:</p>
<pre class="language-xml hljs">android:name=".fusedLocation.LocationApp"
</pre>
<h3 id="mapsactivity-kt">MapsActivity.kt</h3>
<p>当我们创建Google Maps活动时，我们得到了一个<code>MapsActivity.kt</code>文件，而不是常规的<code>MainActivity.kt</code>。这个文件处理带有标记的地图的创建。我们需要对此做一些改变。所以，让我们创建三个<code>private lateinit</code>变量:<code>LocationCallback</code>、<code>LocationRequest</code>和<code>FusedLocationProviderClient</code>。</p>
<p>接下来，我们将创建三个函数；<code>launchintent</code>、<code>getupdatedlocation</code>和<code>startupdate</code>。我们将在<code>onMapReady</code>回调函数中调用它们。</p>
<p><code>launchintent</code>函数处理位置许可请求，<code>getupdatedlocation</code>函数取<code>LocationRequest</code>和<code>LocationCallback</code>。<code>getupdatedlocation</code>函数也将使用它的意图来处理启动函数的调用。</p>
<p>最后，在<code>startupdate</code>函数中，我们将使用<code>fusedlocation.requestLocationUpdates</code>方法来调用回调函数、请求和一个循环(设置为null)。</p>
<p>下面是代码的样子:</p>
<pre class="language-kotlin hljs">class MapsActivity : AppCompatActivity(), OnMapReadyCallback{

    companion object{
        private var firsttime = true
    }

    private lateinit var mMap: GoogleMap
    private lateinit var binding: ActivityMapsBinding
    private lateinit var locationCallback: LocationCallback
    private lateinit var locationRequest: LocationRequest
    private lateinit var fusedLocationProviderClient: FusedLocationProviderClient
    private var mMarker: Marker? = null
    private var secrets = Secretlocation()

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)

        binding = ActivityMapsBinding.inflate(layoutInflater)
        setContentView(binding.root)
        fusedLocationProviderClient = LocationServices.getFusedLocationProviderClient(this)

        // Obtain the SupportMapFragment and get notified when the map is ready to be used.
        val mapFragment = supportFragmentManager
            .findFragmentById(R.id.map) as SupportMapFragment
        mapFragment.getMapAsync(this)
    }

    private fun launchintent() {
        ActivityCompat.requestPermissions(
            this,
            arrayOf(
                Manifest.permission.ACCESS_COARSE_LOCATION,
                Manifest.permission.ACCESS_FINE_LOCATION
            ),
            0
        )
    }

    private fun getupdatedlocation(){
        locationRequest = LocationRequest.create().apply {
            interval = 10000
            fastestInterval = 5000
            priority = Priority.PRIORITY_HIGH_ACCURACY
        }

        locationCallback = object : LocationCallback(){
            override fun onLocationResult(result: LocationResult) {
                if (result.locations.isNotEmpty()){
                    val location = result.lastLocation
                    if (location != null){
                        mMarker?.remove()
                        val lat1 = location.latitude
                        val long1 = location.longitude
                        val d = secrets.d
                        val d1 = secrets.d1
                        val latlong = LatLng(lat1, long1)
                        val stuff = LatLng(d, d1)

                        val stuffoption= MarkerOptions().position(stuff).title("$stuff").icon(
                            BitmapDescriptorFactory.defaultMarker(BitmapDescriptorFactory.HUE_ORANGE))
                        mMarker = mMap.addMarker(stuffoption)
                        val markerOptions = MarkerOptions().position(latlong).title("$latlong")
                        mMarker = mMap.addMarker(markerOptions)
                        if (firsttime){
                            mMap.animateCamera(CameraUpdateFactory.newLatLngZoom(latlong, 17f ))
                            firsttime = false
                        }
                    }
                }
            }
        }
        Intent(applicationContext, LocServices::class.java).apply {
            action = LocServices.START
            startService(this)
        }
    }

    @SuppressLint("MissingPermission")
    private fun startupdate(){
        fusedLocationProviderClient.requestLocationUpdates(
            locationRequest,
            locationCallback,
            null
        )
    }

    override fun onMapReady(googleMap: GoogleMap) {
        mMap = googleMap
        launchintent()
        getupdatedlocation()
        startupdate()
        mMap.uiSettings.isZoomControlsEnabled = true
    }
}
</pre>
<p>当我们运行我们的应用程序时，我们应该得到下面的结果:</p>
<p><img data-attachment-id="145544" data-permalink="https://blog.logrocket.com/how-to-build-geocaching-app-androids-fused-location/attachment/final-application-demo/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/12/final-application-demo.gif" data-orig-size="600,321" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Final app demo" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/12/final-application-demo-300x161.gif" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/12/final-application-demo.gif" decoding="async" class="aligncenter size-full wp-image-145544 jetpack-lazy-image" src="../Images/622b6bc98a1b1ab68d8c6e31825b631b.png" alt="Final App Demo" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2022/12/final-application-demo.gif?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/12/final-application-demo.gif"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="145544" data-permalink="https://blog.logrocket.com/how-to-build-geocaching-app-androids-fused-location/attachment/final-application-demo/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/12/final-application-demo.gif" data-orig-size="600,321" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Final app demo" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/12/final-application-demo-300x161.gif" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/12/final-application-demo.gif" decoding="async" loading="lazy" class="aligncenter size-full wp-image-145544" src="../Images/622b6bc98a1b1ab68d8c6e31825b631b.png" alt="Final App Demo" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/12/final-application-demo.gif"/></noscript>
<h2 id="conclusion">结论</h2>
<p>在本教程中，我们使用Android的融合位置库创建了一个地图，它会不断更新用户在地图上的位置。我们还创建了一个前台服务来确定用户和特定物品之间的距离。最后，我们创建了一个通知，每当我们的用户接近缓存。</p>
<p>感谢您的阅读，祝您编码愉快！</p><div class="code-block code-block-32">
<div class="blog-plug inline-plug kotlin-plug"><h2>LogRocket :即时重现你的安卓应用中的问题。</h2><a class="signup" href="https://lp.logrocket.com/blg/kotlin-signup" target="_blank" rel="noopener noreferrer"><img class="alignnone size-full wp-image-46 jetpack-lazy-image" src="../Images/b5ae4bd0ecde7aa9d5288746416d5e18.png" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2022/11/react-native-plug_android-1.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/11/react-native-plug_android-1.png"/><noscript><img data-lazy-fallback="1" class="alignnone size-full wp-image-46" src="../Images/b5ae4bd0ecde7aa9d5288746416d5e18.png" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/11/react-native-plug_android-1.png"/></noscript></a><p><a href="https://lp.logrocket.com/blg/kotlin-signup" target="_blank" rel="noopener noreferrer"> LogRocket </a>是一款Android监控解决方案，可以帮助您即时重现问题，确定bug的优先级，并了解您的Android应用程序的性能。</p><p>LogRocket还可以向你展示用户是如何与你的应用程序互动的，从而帮助你提高转化率和产品使用率。LogRocket的产品分析功能揭示了用户不完成特定流程或不采用新功能的原因。</p><p>开始主动监控您的Android应用程序— <a class="signup" href="hhttps://lp.logrocket.com/blg/kotlin-signup" target="_blank" rel="noopener noreferrer">免费试用LogRocket】。</a></p></div>
</div>

<p class="clearfix"/>
 <p class="clearfix"/>
</article>

</div>    
</body>
</html>
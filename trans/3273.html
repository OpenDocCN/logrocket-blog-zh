<html>
<head>
<title>A guide to JWT authentication in Go - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>Go - LogRocket博客中的JWT认证指南</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/jwt-authentication-go/#0001-01-01">https://blog.logrocket.com/jwt-authentication-go/#0001-01-01</a></blockquote><div><article class="article-post">
<p>JSON Web令牌(JWT)是处理在线身份验证的一种流行方法，您可以用任何服务器端编程语言实现JWT身份验证。</p>
<p>对于JWTs的一般背景阅读，我建议通过LogRocket博客上的这些文章学习更多关于JWTs、最佳实践和用JWTs保护RESTful APIs的T2的知识。</p>
<p>本文旨在帮助您开始使用<code>golang-jwt</code>包在您的<a href="https://blog.logrocket.com/tag/go/"> Go </a> web应用程序中实现JWT认证。</p>
<p>由于其特性和易用性，<code><a href="https://github.com/golang-jwt/jwt" target="_blank" rel="noopener">golang-jwt</a></code>包是在Go中实现jwt最流行的包。<code>golang-jwt</code>包提供了生成和验证jwt的功能。</p>
<h3>先决条件</h3>
<p>您需要满足这些基本要求才能从本教程中获得最大收益。</p>
<ul>
<li>在你的机器上安装Go 1.16或更高版本(出于<a href="https://github.com/dgrijalva/jwt-go/issues/216" target="_blank" rel="noopener">安全</a>原因)</li>
<li>用Go或任何其他语言构建web应用程序的经验(可选)</li>
</ul>
<h3>目录</h3>

<h2 id="getting-started-golang-jwt-package">开始使用戈朗-JWT软件包</h2>
<p>在设置好Go工作空间并初始化Go模块文件<code>go.mod</code>之后，在工作空间目录中的终端上运行这个命令来安装<code>golang-jwt</code>包:</p>
<pre class="language-go hljs">go get github.com/golang-jwt/jwt
</pre>
<p>一旦安装了<code>golang-jwt</code>，创建一个Go文件并导入这些包和模块:</p>
<pre class="language-go hljs">import (
   "log"
    "encoding/json"
   "github.com/golang-jwt/jwt"
   "net/http"
   "time"
)
</pre>
<p>在本教程中，您将使用这些包来记录错误、设置服务器和设置令牌过期时间。</p>
<h2 id="setting-web-server-go">在Go中设置web服务器</h2>
<p>让我们从创建一个简单的web服务器开始，它的端点将通过JWT来保护。</p>
<pre class="language-go hljs">func main() {
   http.HandleFunc("/home", handlePage)
   err := http.ListenAndServe(":8080", nil)
   if err != nil {
      log.Println("There was an error listening on port :8080", err)
   }

}
</pre>
<p>main函数用您将要设置的处理函数<code>handlePage</code>来设置home端点。<code>handlePage</code>函数将使用JWTs保护页面。服务器被设置为监听端口<code>:8080</code>，但是你可以使用任何你选择的端口。</p>
<p>如果在请求体编码后请求被授权，<code>handlePage</code>处理函数将返回<code>Message</code>结构的编码JSON作为对客户端的响应。</p>
<pre class="language-go hljs">type Message struct {
        Status string `json:"status"`
        Info   string `json:"info"`
}

func handlePage(writer http.ResponseWriter, request *http.Request) {
        writer.Header().Set("Content-Type", "application/json")
        var message Message
        err := json.NewDecoder(request.Body).Decode(&amp;message)
        if err != nil {
                return
        }
        err = json.NewEncoder(writer).Encode(message)
        if err != nil {
                return
        }
}
</pre>
<p>在这一点上，<code>handlePage</code>函数还没有被认证，对页面的请求可以自由地工作。在本教程的后面，您将了解如何向您的处理函数添加身份验证。</p>
<p><img data-attachment-id="128478" data-permalink="https://blog.logrocket.com/jwt-authentication-go/attachment/local-host-home/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/08/local-host-home.png" data-orig-size="730,414" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="API network page" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/08/local-host-home-300x170.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/08/local-host-home.png" decoding="async" class="aligncenter size-full wp-image-128478 jetpack-lazy-image" src="../Images/b8953f57c855a46143c8eadcd8a35abb.png" alt="API network page" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2022/08/local-host-home.png 730w, https://blog.logrocket.com/wp-content/uploads/2022/08/local-host-home-300x170.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2022/08/local-host-home.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/08/local-host-home.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="128478" data-permalink="https://blog.logrocket.com/jwt-authentication-go/attachment/local-host-home/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/08/local-host-home.png" data-orig-size="730,414" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="API network page" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/08/local-host-home-300x170.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/08/local-host-home.png" decoding="async" loading="lazy" class="aligncenter size-full wp-image-128478" src="../Images/b8953f57c855a46143c8eadcd8a35abb.png" alt="API network page" srcset="https://blog.logrocket.com/wp-content/uploads/2022/08/local-host-home.png 730w, https://blog.logrocket.com/wp-content/uploads/2022/08/local-host-home-300x170.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/08/local-host-home.png"/></noscript>
<h2 id="generating-jwts-using-golang-jwt-package">使用<code>Golang-JWT</code>包生成用于认证的jwt</h2>
<p>您将需要一个密钥来使用<code>golang-jwt</code>包生成JWT令牌。下面是本教程的一个私钥示例；但是，您应该使用加密的安全字符串作为您的密钥，并从环境变量文件(。env)。</p>
<p>查看<a href="https://blog.logrocket.com/express-style-api-go-fiber/" target="_blank" rel="noopener">这篇</a>文章，了解如何在Go应用程序中使用环境变量。</p>
<pre class="language-go hljs">var sampleSecretKey = []byte("SecretYouShouldHide")
</pre>
<p>请注意，无论谁拥有您用于jwt的秘密密钥，都可以对您的应用程序的用户进行身份验证。在这种情况下,<code>sampleSecretKey</code>变量保存私钥。</p>
<p>这是一个生成JWT令牌的函数。该函数应该返回一个字符串和一个错误。如果生成JWT时出错，该函数将返回一个空字符串和错误。如果没有错误，函数返回JWT字符串和<code>nil</code>类型。</p>
<pre><code>func generateJWT() (string, error) {

}
</code></pre>
<p>您可以使用JWT包的<code>New</code>方法创建一个新的令牌。<code>New</code>方法接受一个签名方法(JWT的加密算法)并返回一个JWT令牌。</p>
<pre class="language-go hljs">token := jwt.New(jwt.SigningMethodEdDSA)
</pre>
<p>如果要修改JWT，可以使用令牌的<code>Claims</code>方法。</p>
<pre class="language-go hljs">claims := token.Claims.(jwt.MapClaims)
claims["exp"] = time.Now().Add(10 * time.Minute)
claims["authorized"] = true
claims["user"] = "username"
</pre>
<p>在本例中，您使用<code>time</code>模块以及用户名和授权状态为JWT设置了一个到期时间，即十分钟。尝试验证JWT时，您将能够检索声明。</p>
<p>生成JWT的最后一部分是使用您的秘密密钥对字符串进行签名。您可以使用令牌的<code>SignedString</code>方法对令牌字符串进行签名。<code>SignedString</code>方法获取密钥并返回一个签名的令牌字符串。</p>
<pre class="language-go hljs">tokenString, err := token.SignedString(sampleSecretKey)
if err != nil {
    return "", err
 }

 return tokenString, nil
</pre>
<p>如果对令牌进行签名时出现错误，您可以返回一个空字符串和错误。<br/>不像饼干，你不需要储存JWT；您所需要的只是您的签名密钥来验证令牌。</p>
<h2 id="verifying-jwt-tokens">验证JWT令牌</h2>
<p>验证jwt的传统方法使用中间件(接受其他处理函数进行操作的处理函数)。下面是如何使用中间件来验证请求是否被授权。</p>
<pre class="language-go hljs">func verifyJWT(endpointHandler func(writer http.ResponseWriter, request *http.Request)) http.HandlerFunc {

}
</pre>
<p><code>verifyJWT</code>函数是一个中间件，它接受您想要验证的请求的处理函数。处理函数使用请求头中的令牌参数来验证请求，并根据状态做出响应。</p>
<pre><code> return http.HandlerFunc(func(writer http.ResponseWriter, request *http.Request) {

})
</code></pre>
<p>如果请求被授权，<code>verifyJWT</code>函数返回作为参数传入的处理函数。</p><div class="code-block code-block-54">
<hr/>
<h3>更多来自LogRocket的精彩文章:</h3>

<hr/></div>
<p>验证jwt的第一步是检查请求头中的令牌。</p>
<pre class="language-go hljs">if request.Header["Token"] != nil {

}
</pre>
<p>如果有令牌，您可以继续验证令牌并验证声明。</p>
<p>您必须解析令牌，并且可以使用<code>jwt</code>包的<code>Parse</code>方法解析令牌。<code>parse</code>方法接受令牌和JWT装饰函数，并返回一个接口和一个错误。</p>
<p>您需要使用与生成令牌时使用的签名方法相同的方法，来使用令牌的<code>Method</code>方法验证签名。在这种情况下，签名方法是ECDSA方法。</p>
<pre class="language-go hljs">token, err := jwt.Parse(request.Header\["Token"\][0], func(token *jwt.Token) (interface{}, error) {
            _, ok := token.Method.(*jwt.SigningMethodECDSA)
            if !ok {
               writer.WriteHeader(http.StatusUnauthorized)
               _, err := writer.Write([]byte("You're Unauthorized!"))
               if err != nil {
                  return nil, err

               }
            }
            return "", nil

         })
</pre>
<p>如果签名验证失败(函数返回<code>!ok</code>，可以向客户端返回一个<code>StatusUnauthorized</code>头。</p>
<pre class="language-go hljs">if err != nil {
               writer.WriteHeader(http.StatusUnauthorized)
               _, err2 := writer.Write([]byte("You're Unauthorized due to error parsing the JWT"))
              if err2 != nil {
                      return
                }
}
</pre>
<p>在上面的代码中，有一个解析令牌的错误。因此，用户是未授权的，您可以编写一个消息并返回一个未授权的状态。</p>
<p>您可以使用令牌的<code>Valid</code>方法来验证令牌。</p>
<pre class="language-go hljs">if token.Valid {
                      endpointHandler(writer, request)
                        } else {
                                writer.WriteHeader(http.StatusUnauthorized)
                                _, err := writer.Write([]byte("You're Unauthorized due to invalid token"))
                                if err != nil {
                                        return
                                }
}
</pre>
<p>如果令牌有效，您可以将端点处理程序与处理程序函数的<code>writer</code>和<code>request</code>参数一起传入，以便中间件函数返回端点。</p>
<p>下面是客户端请求头中没有标记的情况下的<code>else</code>语句:</p>
<pre class="language-go hljs">else {
          writer.WriteHeader(http.StatusUnauthorized)
          _, err := writer.Write([]byte("You're Unauthorized due to No token in the header"))
           if err != nil {
               return
           }
}
</pre>
<p>因为您使用的是中间件，所以路由声明中的处理函数将是<code>verifyJWT</code>中间件，路由的处理函数作为参数。</p>
<pre class="language-go hljs">http.HandleFunc("/home", verifyJWT(handlePage))
</pre>
<p>一旦您将验证功能添加到路由中，端点就通过了身份验证。</p>
<p><img data-attachment-id="128493" data-permalink="https://blog.logrocket.com/jwt-authentication-go/attachment/endpoint-authenticated/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/08/endpoint-authenticated.png" data-orig-size="730,365" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Endpoint authenticated" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/08/endpoint-authenticated-300x150.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/08/endpoint-authenticated.png" decoding="async" class="aligncenter size-full wp-image-128493 jetpack-lazy-image" src="../Images/67fbf183ff5c971b7b9d6e111a23292c.png" alt="Endpoint authenticated" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2022/08/endpoint-authenticated.png 730w, https://blog.logrocket.com/wp-content/uploads/2022/08/endpoint-authenticated-300x150.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2022/08/endpoint-authenticated.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/08/endpoint-authenticated.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="128493" data-permalink="https://blog.logrocket.com/jwt-authentication-go/attachment/endpoint-authenticated/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/08/endpoint-authenticated.png" data-orig-size="730,365" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Endpoint authenticated" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/08/endpoint-authenticated-300x150.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/08/endpoint-authenticated.png" decoding="async" loading="lazy" class="aligncenter size-full wp-image-128493" src="../Images/67fbf183ff5c971b7b9d6e111a23292c.png" alt="Endpoint authenticated" srcset="https://blog.logrocket.com/wp-content/uploads/2022/08/endpoint-authenticated.png 730w, https://blog.logrocket.com/wp-content/uploads/2022/08/endpoint-authenticated-300x150.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/08/endpoint-authenticated.png"/></noscript>
<p>在客户端，客户端必须提供一个颁发的令牌。这里有一个使用<code>generateJWT</code>函数在请求中添加令牌的函数。</p>
<pre class="language-go hljs">func authPage(writer http.ResponseWriter, ) {
        token, err := generateJWT()
        if err != nil {
                        return
        } 
        client := &amp;http.Client{}
        request, _ := http.NewRequest("POST", "&lt;http://localhost:8080/&gt;", nil)
        request.Header.Set("Token", token)
        _, _ = client.Do(request)

}
</pre>
<p>在<code>authPage</code>函数中，<code>token</code>变量保存来自<code>generateJWT</code>函数的令牌。使用对<code>http</code>包的<code>Client</code>类型的引用，您可以创建一个新的客户机并向端点发出请求。<code>request</code>变量是请求实例，使用请求实例的<code>header</code>方法的<code>Set</code>方法，您可以在请求头中设置令牌，如上所示。</p>
<p>您还可以选择将令牌设置为cookie，并在客户端向经过身份验证的端点发出请求时检索它进行验证。</p>

<p>生成JWT时，您可以选择在令牌中嵌入信息。在<code>generateJWT</code>函数中，您将<code>username</code>变量添加到了<code>claims</code>地图中。</p>
<p>下面是如何提取索赔，以<code>username</code>索赔为例。在验证令牌签名时，您可以使用中间件或向验证函数添加功能。</p>
<pre class="language-go hljs">func extractClaims(_ http.ResponseWriter, request *http.Request) (string, error) {
        if request.Header["Token"] != nil {
                tokenString := request.Header\["Token"\][0]
                token, err := jwt.Parse(tokenString, func(token *jwt.Token) (interface{}, error) {

          if _, ok := token.Method.(*jwt.SigningMethodECDSA); !ok {
                return nil, fmt.Errorf("there's an error with the signing method")
          }
                return sampleSecretKey, nil

            })

            if err != nil {
                        return "Error Parsing Token: ", err
                }
}
</pre>
<p>在<code>extractClaims</code>功能中，过程与<code>verifyJWT</code>功能相同；您从标头中检索了令牌，解析了令牌，并验证了签名。</p>
<pre class="language-go hljs">claims, ok := token.Claims.(jwt.MapClaims)
          if ok &amp;&amp; token.Valid {
                username := claims["username"].(string)
                return username, nil
          }

        }
        return "unable to extract claims", nil
</pre>
<p>在验证令牌时，您可以使用<code>Claims</code>方法检索声明，并使用声明映射检索JWT中的数据，如上所示。</p>
<h2 id="conclusion">结论</h2>
<p>本教程通过使用<code>golang-jwt</code>包，教你如何使用JWT认证来认证你的API和web页面端点。你可以在本教程中找到完整的代码作为<a href="https://gist.github.com/Goodnessuc/c92210cab062c541109e4fcf78bdfbe6" target="_blank" rel="noopener"> GitHub要点</a>。</p>
<p>记住为您的秘密密钥使用环境变量，并且不要在jwt中隐藏敏感数据。LogRocket博客上有很多JWT教程，你可以去看看，开始使用你感兴趣的语言或框架！</p><div class="code-block code-block-2">
<div class="blog-plug base-cta"><h2>使用<a class="signup" href="https://lp.logrocket.com/blg/signup" target="_blank" rel="noopener noreferrer"> LogRocket </a>消除传统错误报告的干扰</h2>
<a href="https://lp.logrocket.com/blg/signup" class="signup" target="_blank" rel="noopener noreferrer"><img class="alignnone size-full wp-image-46 jetpack-lazy-image" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/><noscript><img data-lazy-fallback="1" class="alignnone size-full wp-image-46" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/></noscript></a>
<p><a href="https://lp.logrocket.com/blg/signup" target="_blank" rel="noopener noreferrer"> LogRocket </a>是一个数字体验分析解决方案，它可以保护您免受数百个假阳性错误警报的影响，只针对几个真正重要的项目。LogRocket会告诉您应用程序中实际影响用户的最具影响力的bug和UX问题。</p>
<p>然后，使用具有深层技术遥测的会话重放来确切地查看用户看到了什么以及是什么导致了问题，就像你在他们身后看一样。</p>
<p>LogRocket自动聚合客户端错误、JS异常、前端性能指标和用户交互。然后LogRocket使用机器学习来告诉你哪些问题正在影响大多数用户，并提供你需要修复它的上下文。</p>
<p>关注重要的bug—<a class="signup" href="https://lp.logrocket.com/blg/signup-issue-free" target="_blank" rel="noopener noreferrer">今天就试试LogRocket】。</a></p></div></div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
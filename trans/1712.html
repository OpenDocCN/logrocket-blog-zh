<html>
<head>
<title>Using provide/inject in Vue.js 3 with the Composition API - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>在 Vue.js 3 中使用 provide/inject 与组合 API - LogRocket 博客</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/provide-inject-vue-js-3-composition-api/#0001-01-01">https://blog.logrocket.com/provide-inject-vue-js-3-composition-api/#0001-01-01</a></blockquote><div><article class="article-post">
<p>通常，当我们想要将数据从父组件传递到子组件时，我们使用 props。Vue.js 让这变得简单明了。但是，当我们需要将数据从父级组件传递到深层嵌套的子组件时，我们可能会遇到挫折。</p>
<p>如果我们使用 props，我们最终会将数据传递给 Vue 组件树的每一层上的每个组件，以便数据到达其最终目的地。这就是所谓的道具演练，可能会导致我们的应用程序看起来比实际更复杂。如果它是一个简单状态的应用程序，那么在其中使用 Vuex 就有些过分了。</p>
<p>对我们来说幸运的是，Vue 有<code>provide</code> / <code>inject</code> API，随着 Vue 3 中 Composition API 的引入，它变得前所未有的好。</p>
<p>使用<code>provide</code>和<code>inject</code>对，父组件可以向它们的子组件发送数据，而不管组件层次有多深。父组件有一个<code>provide</code>函数来提供数据，子组件有一个<code>inject</code>函数来开始使用这些数据。</p>
<p><img data-attachment-id="43292" data-permalink="https://blog.logrocket.com/provide-inject-vue-js-3-composition-api/children-components-three-levels-provide-inject-pair/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2021/04/children-components-three-levels-provide-inject-pair.jpg" data-orig-size="730,434" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;1&quot;}" data-image-title="children-components-3-levels-provide-inject-pair" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2021/04/children-components-three-levels-provide-inject-pair-300x178.jpg" data-large-file="https://blog.logrocket.com/wp-content/uploads/2021/04/children-components-three-levels-provide-inject-pair.jpg" decoding="async" class="aligncenter wp-image-43292 size-full jetpack-lazy-image" src="../Images/397fb13e9334bbe58519ff344985e60b.png" alt="Children Components 3 Levels Provide Inject Pair" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2021/04/children-components-three-levels-provide-inject-pair.jpg 730w, https://blog.logrocket.com/wp-content/uploads/2021/04/children-components-three-levels-provide-inject-pair-300x178.jpg 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2021/04/children-components-three-levels-provide-inject-pair.jpg?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2021/04/children-components-three-levels-provide-inject-pair.jpg"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="43292" data-permalink="https://blog.logrocket.com/provide-inject-vue-js-3-composition-api/children-components-three-levels-provide-inject-pair/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2021/04/children-components-three-levels-provide-inject-pair.jpg" data-orig-size="730,434" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;1&quot;}" data-image-title="children-components-3-levels-provide-inject-pair" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2021/04/children-components-three-levels-provide-inject-pair-300x178.jpg" data-large-file="https://blog.logrocket.com/wp-content/uploads/2021/04/children-components-three-levels-provide-inject-pair.jpg" decoding="async" loading="lazy" class="aligncenter wp-image-43292 size-full" src="../Images/397fb13e9334bbe58519ff344985e60b.png" alt="Children Components 3 Levels Provide Inject Pair" srcset="https://blog.logrocket.com/wp-content/uploads/2021/04/children-components-three-levels-provide-inject-pair.jpg 730w, https://blog.logrocket.com/wp-content/uploads/2021/04/children-components-three-levels-provide-inject-pair-300x178.jpg 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2021/04/children-components-three-levels-provide-inject-pair.jpg"/></noscript>
<p>在上图中，我们有三个级别的子组件。我们要传递的数据包含在父组件中，数据的预期目的地深深地嵌套在组件树的第三层中。我们可以使用 props 来实现这一点，但代价是代码的简单性和可读性。让我们看看如何在不牺牲这两者的情况下做到这一点。</p>
<p>首先，我们需要用下面的命令安装最新版本的<a href="https://github.com/vuejs/vue-cli"> Vue CLI v4.5 </a>:</p>
<pre>yarn global add @vue/<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="a0c3ccc9e0cec5d8d4">[email protected]</a>
#OR
npm install -g @vue/<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="80e3ece9c0eee5f8f4">[email protected]</a>
</pre>
<p>运行以下命令创建新的 Vue 应用程序:</p>
<pre>vue create provide-inject-tutorial
</pre>
<h2 id="h2usingtheprovideapi">使用<code>provide</code> API</h2>
<p><code>provide</code> API 是一个函数，我们用它来定义我们想要传递给子组件的数据。</p>
<p>当在<code>setup()</code>中使用<code>provide</code>函数时，我们从从<code>vue</code>显式导入函数开始。这允许我们在调用<code>provide</code>时定义每个属性。</p>
<p><code>provide</code>函数接受两个参数:</p>
<ol>
<li>属性的名称(字符串)</li>
<li>属性值(包含多个值的字符串或对象)</li>
</ol>
<pre>&lt;!-- src/components/MyMap.vue --&gt;
&lt;template&gt;
  &lt;MyMarker /&gt;
&lt;/template&gt;

&lt;script&gt;
import { provide } from 'vue'
import MyMarker from './MyMarker.vue

export default {
  components: {
    MyMarker
  },
  setup() {
    provide('location', 'North Pole')
    provide('geolocation', {
      longitude: 90,
      latitude: 135
    })
  }
}
&lt;/script&gt;</pre>
<p>在上面的代码中导入了<code>provide</code>函数后，我们在<code>setup</code>函数中调用它。接下来，我们传递第一个<code>provide</code>函数的参数如下:属性名<code>'location'</code>和一个值<code>'North Pole'</code>。</p>
<p>对于第二个<code>provide</code>函数，我们传递一个包含<code>latitude</code>和<code>longitude</code>值的对象，并将其属性名设置为<code>'geolocation'</code>。</p>
<h2 id="h2usingtheinjectapi">使用<code>inject</code> API</h2>
<p><code>inject</code> API 是我们用来从我们的提供者组件接收数据的函数。</p>
<p>正如我们对<code>provide</code>函数所做的那样，我们也必须从<code>vue</code>导入<code>inject</code>函数。这让我们可以在组件中的任何地方调用和使用该函数。</p>
<p><code>inject</code>函数有两个参数:</p>
<ol>
<li>被注入的属性的名称</li>
<li>可选的默认值</li>
</ol>
<p>让我们看看下面的代码:</p>
<pre>&lt;!-- src/components/MyMarker.vue --&gt;
&lt;script&gt;
import { inject } from 'vue'

export default {
  setup() {
    const userLocation = inject('location', 'The Universe')
    const userGeolocation = inject('geolocation')

    return {
      userLocation,
      userGeolocation
    }
  }
}
&lt;/script&gt;
</pre>
<p>首先，我们将<code>inject</code>函数导入到我们的<code>MyMarker</code>组件中。然后，在我们的<code>setup</code>函数中，我们将第一个属性名为<code>'location'</code>的<code>provide</code>函数赋给了<code>userLocation</code>变量。我们还提供了一个可选的默认回退值<code>'The Universe'</code>。</p>
<p>接下来，我们将属性名为<code>'geolocation'</code>的第二个<code>provide</code>函数赋给<code>userGeoLocation</code>变量。我们<code>return</code>了<code>userLocation</code>和<code>userGeoLocation</code>变量，之后我们可以在<code>MyMarker</code>组件的任何地方自由使用它们的值。</p>
<h2 id="h2makingtheprovideinjectpairreactive">使<code>provide</code> / <code>inject</code>对反应</h2>
<p>遗憾的是，开箱后，<code>provide</code> / <code>inject</code>对没有反应。谢天谢地，有一种方法可以让<a href="https://blog.logrocket.com/how-to-make-provide-inject-reactive/">通过使用 Vue API 提供的<code>ref</code>或<code>reactive</code>函数来实现这一点</a>。</p>
<p>我们首先必须从<code>vue</code>导入它们，然后调用<code>ref</code>或<code>reactive</code>函数。我们将把它的参数设置为要传递给所需子组件的值，并将函数存储在一个变量中。然后我们调用<code>provide</code>函数并传递属性名及其值。</p>
<p>现在，如果任何一个属性发生变化，<code>MyMarker</code>组件也会自动更新！</p>
<p>我们现在可以如下更新我们的代码:</p>
<pre>&lt;!-- src/components/MyMap.vue --&gt;
&lt;template&gt;
  &lt;MyMarker /&gt;
&lt;/template&gt;

&lt;script&gt;
import { provide, reactive, ref } from 'vue'
import MyMarker from './MyMarker.vue

export default {
  components: {
    MyMarker
  },
  setup() {
    const location = ref('North Pole')
    const geolocation = reactive({
      longitude: 90,
      latitude: 135
    })

    provide('location', location)
    provide('geolocation', geolocation)
  }
}
&lt;/script&gt;
</pre>
<p>在导入<code>ref</code>和<code>reactive</code>函数后，我们调用<code>ref</code>函数并给它一个参数(值<code>'North Pole'</code>，然后将<code>ref</code>函数赋给<code>location</code>变量。</p>
<p>对于<code>reactive</code>函数，我们调用它并以对象的形式给它传递一个参数。然后我们将<code>reactive</code>函数赋给<code>geolocation</code>变量。完成这些之后，我们可以调用<code>provide</code>函数，并向它传递我们想要传递的数据的属性名和值。</p>
<p>在第一个<code>provide</code>函数中，我们将属性名设置为<code>'location'</code>，并将其值设置为等于<code>location</code>，这是我们分配给<code>ref</code>函数的值。</p>
<p>而在第二个<code>provide</code>函数中，我们将其属性名设置为<code>'geolocation'</code>，其值等于<code>geolocation</code>，这是我们分配给<code>reactive</code>函数的值。</p>
<h2 id="h2whentousetheprovideinjectfunctionpair">何时使用<code>provide</code> / <code>inject</code>函数对</h2>
<ul>
<li>如果应用程序有一个相当简单的状态，使用 Vuex 将是大材小用</li>
<li>如果您的应用程序有太多的组件级别，并且中间的组件在将数据传递给所需的组件之前不使用数据</li>
<li>如果数据仅由少数组件使用。但是如果数据将被更多的组件使用，Vuex 将是一个更好的解决方案</li>
</ul>
<p>我们已经学习了如何使用组合 API 使用<code>provide</code> / <code>inject</code>函数对在 Vue.js 3 中深度嵌套的组件之间传递数据。我们已经介绍了如何使它具有反应性，以及何时应该使用它的不同用例。要了解更多关于<code>provide</code> / <code>inject</code>函数对的信息，请访问<a href="https://v3.vuejs.org/guide/composition-api-provide-inject.html">官方文档</a>。</p><div class="code-block code-block-20">
<div class="blog-plug inline-plug vue-inline"><h2>像用户一样体验您的 Vue 应用</h2><p>调试 Vue.js 应用程序可能会很困难，尤其是当用户会话期间有几十个(如果不是几百个)突变时。如果您对监视和跟踪生产中所有用户的 Vue 突变感兴趣，</p><a href="https://lp.logrocket.com/blg/vue-signup" target="_blank">try LogRocket</a><p>. </p><a class="signup" href="https://lp.logrocket.com/blg/vue-signup" target="_blank" rel="noopener noreferrer"><img class="alignnone size-full wp-image-46 jetpack-lazy-image" src="../Images/0d269845910c723dd7df26adab9289cb.png" alt="LogRocket Dashboard Free Trial Banner" data-lazy-src="https://files.readme.io/00591d0-687474703a2f2f692e696d6775722e636f6d2f6a3049327856572e706e67.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://files.readme.io/00591d0-687474703a2f2f692e696d6775722e636f6d2f6a3049327856572e706e67.png"/><noscript><img data-lazy-fallback="1" class="alignnone size-full wp-image-46" src="../Images/0d269845910c723dd7df26adab9289cb.png" alt="LogRocket Dashboard Free Trial Banner" data-original-src="https://files.readme.io/00591d0-687474703a2f2f692e696d6775722e636f6d2f6a3049327856572e706e67.png"/></noscript></a><a href="https://lp.logrocket.com/blg/vue-signup" target="_blank" rel="noopener noreferrer">https://logrocket.com/signup/</a><p>LogRocket 就像是网络和移动应用程序的 DVR，记录你的 Vue 应用程序中发生的一切，包括网络请求、JavaScript 错误、性能问题等等。您可以汇总并报告问题发生时应用程序的状态，而不是猜测问题发生的原因。</p><p>LogRocket Vuex 插件将 Vuex 突变记录到 LogRocket 控制台，为您提供导致错误的环境，以及出现问题时应用程序的状态。</p><p>现代化您调试 Vue 应用的方式- <a class="signup" href="https://lp.logrocket.com/blg/vue-signup" target="_blank" rel="noopener noreferrer">开始免费监控</a>。</p></div>


</div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
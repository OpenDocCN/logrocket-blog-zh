<html>
<head>
<title>Testing Next.js apps with Jest - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>使用 Jest - LogRocket 博客测试 Next.js 应用程序</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/testing-next-js-apps-jest/#0001-01-01">https://blog.logrocket.com/testing-next-js-apps-jest/#0001-01-01</a></blockquote><div><article class="article-post">
<p>作为一名开发人员，您知道测试对于任何生产级别的项目有多重要。编写测试需要一些时间，但是从长远来看，它们会帮助你解决代码库中的问题。您还可以将这些测试集成到 GitHub 操作中，这样无论何时您部署到生产环境中或者有人发出 pull 请求，测试都会自动运行，并且您会收到任何失败测试的通知。</p>
<p>Jest 是一款令人惊叹的内置工具，用于测试 React 应用。由于<a href="https://blog.logrocket.com/whats-new-next-js-12/" target="_blank" rel="noopener"> Next.js 发布了 v12 </a>，它也内置了 Jest 配置，由 Rust 编译器提供支持(这是下一个 v12 更新的一个亮点)。</p>
<p>在本教程中，我们将学习如何通过编写一个计算器应用程序的简单测试来设置 Jest 与 Next。我们还将看到当我们模拟测试失败时会发生什么，因此您可以决定 Jest 对于您自己的项目是否足够有效。</p>
<h3>内容</h3>

<h3 id="prerequisites">先决条件</h3>
<ul>
<li>React 和 Next.js 的工作知识</li>
<li>如何测试应用程序的工作知识</li>
<li>代码编辑器——我更喜欢 Visual Studio 代码</li>
<li>安装在计算机上的 Node.js</li>
</ul>
<p>如果你在教程的某个地方卡住了，请随意参考<a href="https://github.com/atharvadeosthale/jest-tutorial-article" target="_blank" rel="noopener"> GitHub 库</a>。</p>
<h2 id="creating-new-nextjs-app">创建新的 Next.js 应用程序</h2>
<p>导航到一个安全的目录，并在终端中输入以下命令来设置新的<a href="https://blog.logrocket.com/testing-error-handling-patterns-next-js/" target="_blank" rel="noopener">下一个应用程序</a>:</p>
<pre class="language-shell hljs">npx create-next-app jest-tutorial
</pre>
<p>您可以用应用程序的任何其他名称替换<code>jest-tutorial</code>。安装完成后，在代码编辑器中打开项目，并在终端中运行以下命令来启动开发服务器:</p>
<pre class="language-shell hljs">npm run dev
</pre>
<h2 id="creating-calculator">创建计算器</h2>
<p>因为我们在这里特别关注测试，所以我们不会讨论计算器是如何工作的。然而，为了让我们测试，这里是计算器的代码。</p>
<p><code>pages</code>目录下<code>index.js</code>的内容如下:</p>
<pre class="language-javascript hljs">import Head from "next/head";
import Image from "next/image";
import { useState } from "react";
import styles from "../styles/Home.module.css";
export default function Home() {
  const [num1, setNum1] = useState(0);
  const [num2, setNum2] = useState(0);
  const [result, setResult] = useState(0);
  const add = () =&gt; {
    setResult(parseInt(num1) + parseInt(num2));
  };
  const subtract = () =&gt; {
    setResult(parseInt(num1) - parseInt(num2));
  };
  const multiply = () =&gt; {
    setResult(parseInt(num1) * parseInt(num2));
  };
  const divide = () =&gt; {
    setResult(parseInt(num1) / parseInt(num2));
  };
  return (
    &lt;div className={styles.container}&gt;
      &lt;Head&gt;
        &lt;title&gt;Create Next App&lt;/title&gt;
        &lt;meta name="description" content="Generated by create next app" /&gt;
        &lt;link rel="icon" href="/favicon.ico" /&gt;
      &lt;/Head&gt;
      &lt;div className={styles.result} data-testid="result"&gt;
        {result}
      &lt;/div&gt;
      &lt;input
        type="number"
        className={styles.input}
        data-testid="num1"
        value={num1}
        onChange={(e) =&gt; setNum1(e.target.value)}
      /&gt;
      &lt;input
        type="number"
        className={styles.input}
        data-testid="num2"
        value={num2}
        onChange={(e) =&gt; setNum2(e.target.value)}
      /&gt;
      &lt;button onClick={add} className={styles.button} data-testid="add"&gt;
        Add
      &lt;/button&gt;
      &lt;button
        onClick={subtract}
        className={styles.button}
        data-testid="subtract"
      &gt;
        Subtract
      &lt;/button&gt;
      &lt;button
        onClick={multiply}
        className={styles.button}
        data-testid="multiply"
      &gt;
        Multiply
      &lt;/button&gt;
      &lt;button onClick={divide} className={styles.button} data-testid="divide"&gt;
        Divide
      &lt;/button&gt;
    &lt;/div&gt;
  );
}
</pre>
<p>上面代码中需要注意的一点是添加到元素中的<code>data-testid</code>属性，比如结果区域、输入字段和按钮。这个 ID 帮助我们识别测试文件中的特定字段，并在测试时对它们执行操作。这些 id 在生产中不会有任何影响。</p>
<p>以下是<code>styles</code>目录下<code>Home.module.css</code>的内容:</p>
<pre class="language-css hljs">.container {
  padding: 0 2rem;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  height: 100vh;
  background-color: #121212;
  color: white;
}
.result {
  font-size: 4rem;
  font-weight: bold;
  margin-bottom: 1rem;
}
.input {
  margin: 0.5rem 0;
  padding: 0.5rem;
  font-size: large;
  width: 13rem;
  background-color: #121212;
  border: 1px solid #525252;
  color: white;
  border-radius: 10px;
}
.button {
  font-size: large;
  padding: 0.5rem;
  width: 13rem;
  margin: 0.5rem 0;
  border: 1px solid black;
  background-color: black;
  border-radius: 10px;
  color: white;
}
</pre>
<p>现在，当您访问<code><a href="http://localhost:3000" rel="nofollow">http://localhost:3000</a></code>时，您应该会看到我们的计算器启动并运行:</p>
<p><img data-attachment-id="100885" data-permalink="https://blog.logrocket.com/testing-next-js-apps-jest/calculator-app/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/03/calculator-app.png" data-orig-size="483,562" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="calculator-app" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/03/calculator-app-258x300.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/03/calculator-app.png" decoding="async" class="size-full wp-image-100885 aligncenter jetpack-lazy-image" src="../Images/5c5203686dfa6ed14a30320ff2a60529.png" alt="calculator app" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2022/03/calculator-app.png 483w, https://blog.logrocket.com/wp-content/uploads/2022/03/calculator-app-258x300.png 258w" data-lazy-sizes="(max-width: 483px) 100vw, 483px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2022/03/calculator-app.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/03/calculator-app.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="100885" data-permalink="https://blog.logrocket.com/testing-next-js-apps-jest/calculator-app/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/03/calculator-app.png" data-orig-size="483,562" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="calculator-app" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/03/calculator-app-258x300.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/03/calculator-app.png" decoding="async" loading="lazy" class="size-full wp-image-100885 aligncenter" src="../Images/5c5203686dfa6ed14a30320ff2a60529.png" alt="calculator app" srcset="https://blog.logrocket.com/wp-content/uploads/2022/03/calculator-app.png 483w, https://blog.logrocket.com/wp-content/uploads/2022/03/calculator-app-258x300.png 258w" sizes="(max-width: 483px) 100vw, 483px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/03/calculator-app.png"/></noscript>
<p>现在，让我们继续使用 Jest 测试这个计算器！</p>
<h2 id="setting-up-jest">设置笑话</h2>
<p>要设置 Jest，我们需要安装一些必需的包。在终端中运行以下命令来安装它们:</p>
<pre class="language-shell hljs">npm install --save-dev jest @testing-library/react @testing-library/jest-dom
</pre>
<p>记住，我们在这里使用<code>--save-dev</code>，这意味着这些包包含在我们的<code>devDependencies</code>中，不会在生产中使用。</p>
<p>现在，让我们创建一个新文件来存储 Jest 配置。在项目根文件夹中，用以下配置创建一个名为<code>jest.config.js</code>的新文件(这些配置来自官方的下一个<a href="https://nextjs.org/docs/testing" target="_blank" rel="noopener">文档</a>):</p>
<pre class="language-javascript hljs">const nextJest = require("next/jest");
const createJestConfig = nextJest({
  dir: "./",
});
const customJestConfig = {
  moduleDirectories: ["node_modules", "&lt;rootDir&gt;/"],
  testEnvironment: "jest-environment-jsdom",
};
module.exports = createJestConfig(customJestConfig);
</pre>
<p>现在，转到<code>package.json</code>并添加一个名为<code>test</code>的脚本，它运行命令<code>jest</code> <code>--watch</code>。</p>
<p>您的脚本应该如下所示:</p>
<pre class="language-javascript hljs">"scripts": {
  "dev": "next dev",
  "build": "next build",
  "start": "next start",
  "lint": "next lint",
  "test": "jest --watch"
},
</pre>
<p>现在我们的配置已经准备好了，我们可以继续编写测试了。</p>
<h2 id="testing-nextjs-calculator-app-jest">用 Jest 测试 Next.js 计算器应用程序</h2>
<p>在项目根目录中，创建一个名为<code>tests</code>的新文件夹，Jest 将使用它来查找测试。然后，创建一个名为<code>index.test.js</code>的新文件。</p>
<p>首先，让我们导入一些依赖项:</p>
<pre class="language-javascript hljs">import Home from "../pages/index";
import "@testing-library/jest-dom";
import { fireEvent, render, screen } from "@testing-library/react";
</pre>
<p>我们将从下一个应用程序中直接导入<code>Home</code>组件，因为我们将在测试期间渲染它。</p>
<p>现在，让我们编写一个测试，看看是否所有元素都正确呈现:</p>
<pre class="language-javascript hljs">describe("Calculator", () =&gt; {
  it("renders a calculator", () =&gt; {
    render(&lt;Home /&gt;);
    // check if all components are rendered
    expect(screen.getByTestId("result")).toBeInTheDocument();
    expect(screen.getByTestId("num1")).toBeInTheDocument();
    expect(screen.getByTestId("num2")).toBeInTheDocument();
    expect(screen.getByTestId("add")).toBeInTheDocument();
    expect(screen.getByTestId("subtract")).toBeInTheDocument();
    expect(screen.getByTestId("multiply")).toBeInTheDocument();
    expect(screen.getByTestId("divide")).toBeInTheDocument();
  });
});
</pre>
<p>这些测试通常是人类可读的。让我们看看上面的代码发生了什么:</p>
<p>首先，<code>describe</code>函数描述了模块是什么。你可以给它取任何你想要的名字；运行测试时，该名称将显示在控制台中。</p>
<p>接下来，<code>it</code>函数指定了一个单独的测试。在<code>describe</code>中可以有多个<code>it</code>。</p>
<p>然后我们呈现出从<code>pages</code>目录下的<code>index.js</code>导入的<code>&lt;Home/&gt;</code>组件。这将模拟一个 DOM 并在其上呈现组件。</p>
<p>下面的<code>expect</code>函数检查条件是<code>true</code>还是<code>false</code>。它的结果告诉你测试的结果。如果这些<code>expect</code>语句中的任何一个是<code>false</code>，测试将失败，您将在控制台中看到一条错误消息。</p>
<p>最后，我们使用<code>toBeInTheDocument()</code>来检查元素是否确实存在于 Jest 创建的 DOM 中。我们在页面中提供了测试 id，所以 Jest 更容易识别这些元素。</p>
<p>现在，您可以运行测试了。在您的终端中使用以下命令:</p>
<pre class="language-shell hljs">npm run test
</pre>
<p>您应该会看到这样的测试结果:</p>
<pre class="language-shell hljs"> PASS  __tests__/index.test.js
  Calculator
    ✓ renders a calculator (15 ms)

Test Suites: 1 passed, 1 total
Tests:       1 passed, 1 total
Snapshots:   0 total
Time:        0.554 s, estimated 1 s
Ran all test suites.

Watch Usage: Press w to show more.
</pre>
<p>一旦您运行 test 命令，一旦项目中的任何文件被保存，它就会自动重新运行测试，因此我们不需要终止并重启测试终端。</p>
<h2 id="testing-calculator-operations-simulating-error">测试计算器操作并模拟错误</h2>
<p>现在，让我们创建一个测试来检查数字相加是否正确:</p>
<pre class="language-javascript hljs">it("adds numbers", () =&gt; {
  render(&lt;Home /&gt;);
  // check if adds properly
  const num1input = screen.getByTestId("num1");
  const num2input = screen.getByTestId("num2");
  const addButton = screen.getByTestId("add");
  const resultArea = screen.getByTestId("result");
  fireEvent.change(num1input, { target: { value: 5 } });
  fireEvent.change(num2input, { target: { value: 8 } });
  addButton.click();
  expect(resultArea).toHaveTextContent("13");
});
</pre>
<p>在上面的代码中，我们模拟了在计算器中打字和按键。我们还提供两个数字相加，并检查计算器提供的结果是否相同。</p>
<p>保存文件后，检查终端，您的测试应该会自动重新运行并提供以下输出:</p>
<pre class="language-shell hljs"> PASS  __tests__/index.test.js
  Calculator
    ✓ renders a calculator (18 ms)
    ✓ adds numbers (9 ms)

Test Suites: 1 passed, 1 total
Tests:       2 passed, 2 total
Snapshots:   0 total
Time:        0.526 s, estimated 1 s
Ran all test suites.

Watch Usage: Press w to show more.
</pre>
<p>完美！现在，让我们尝试在应用程序中模拟一个错误。首先，我们将对实际的计算器应用程序进行修改，使它不像预期的那样工作。为此，将<code>index.js</code>中的<code>add</code>功能更改如下:</p>
<pre class="language-javascript hljs">const add = () =&gt; {
  setResult(parseInt(num1) - parseInt(num2));
};
</pre>
<p>这里我们改变了函数，使它减去而不是增加。保存文件时，您应该会立即看到一个错误:</p>
<pre class="language-javascript hljs"> FAIL  __tests__/index.test.js
  Calculator
    ✓ renders a calculator (14 ms)
    ✕ adds numbers (13 ms)

  ● Calculator › adds numbers

    expect(element).toHaveTextContent()

    Expected element to have text content:
      13
    Received:
      -3

      28 |     addButton.click();
      29 |
    &gt; 30 |     expect(resultArea).toHaveTextContent("13");
         |                        ^
      31 |   });
      32 | });
      33 |

      at Object.&lt;anonymous&gt; (__tests__/index.test.js:30:24)

Test Suites: 1 failed, 1 total
Tests:       1 failed, 1 passed, 2 total
Snapshots:   0 total
Time:        0.667 s, estimated 1 s
Ran all test suites.

Watch Usage: Press w to show more.
</pre>
<p>Jest 试图添加数字，并没有看到我们预期的数字，这意味着<code>add</code>函数存在一些问题。这就是当测试失败时，如何检查代码中的问题。恢复您在<code>index.js</code>文件中所做的更改，使内容恢复到原始工作顺序。</p>
<p>现在，让我们再添加几个测试来检查是否所有的操作都运行良好。以下是<code>index.test.js</code>的完整代码:</p>
<pre class="language-javascript hljs">import Home from "../pages/index";
import "@testing-library/jest-dom";
import { fireEvent, render, screen } from "@testing-library/react";
describe("Calculator", () =&gt; {
  it("renders a calculator", () =&gt; {
    render(&lt;Home /&gt;);
    // check if all components are rendered
    expect(screen.getByTestId("result")).toBeInTheDocument();
    expect(screen.getByTestId("num1")).toBeInTheDocument();
    expect(screen.getByTestId("num2")).toBeInTheDocument();
    expect(screen.getByTestId("add")).toBeInTheDocument();
    expect(screen.getByTestId("subtract")).toBeInTheDocument();
    expect(screen.getByTestId("multiply")).toBeInTheDocument();
    expect(screen.getByTestId("divide")).toBeInTheDocument();
  });
  it("adds numbers", () =&gt; {
    render(&lt;Home /&gt;);
    // check if adds properly
    const num1input = screen.getByTestId("num1");
    const num2input = screen.getByTestId("num2");
    const addButton = screen.getByTestId("add");
    const resultArea = screen.getByTestId("result");
    fireEvent.change(num1input, { target: { value: 5 } });
    fireEvent.change(num2input, { target: { value: 8 } });
    addButton.click();
    expect(resultArea).toHaveTextContent("13");
  });
  it("subtracts numbers", () =&gt; {
    render(&lt;Home /&gt;);
    // check if adds properly
    const num1input = screen.getByTestId("num1");
    const num2input = screen.getByTestId("num2");
    const subtractButton = screen.getByTestId("subtract");
    const resultArea = screen.getByTestId("result");
    fireEvent.change(num1input, { target: { value: 8 } });
    fireEvent.change(num2input, { target: { value: 5 } });
    subtractButton.click();
    expect(resultArea).toHaveTextContent("3");
  });
  it("multiplies numbers", () =&gt; {
    render(&lt;Home /&gt;);
    // check if adds properly
    const num1input = screen.getByTestId("num1");
    const num2input = screen.getByTestId("num2");
    const multiplyButton = screen.getByTestId("multiply");
    const resultArea = screen.getByTestId("result");
    fireEvent.change(num1input, { target: { value: 5 } });
    fireEvent.change(num2input, { target: { value: 8 } });
    multiplyButton.click();
    expect(resultArea).toHaveTextContent("40");
  });
  it("divides numbers", () =&gt; {
    render(&lt;Home /&gt;);
    // check if adds properly
    const num1input = screen.getByTestId("num1");
    const num2input = screen.getByTestId("num2");
    const divideButton = screen.getByTestId("divide");
    const resultArea = screen.getByTestId("result");
    fireEvent.change(num1input, { target: { value: 20 } });
    fireEvent.change(num2input, { target: { value: 2 } });
    divideButton.click();
    expect(resultArea).toHaveTextContent("10");
  });
});
</pre>
<p>保存文件后，您应该会看到所有测试都通过了，如下所示:</p>
<pre class="language-javascript hljs"> PASS  __tests__/index.test.js
  Calculator
    ✓ renders a calculator (14 ms)
    ✓ adds numbers (6 ms)
    ✓ subtracts numbers (4 ms)
    ✓ multiplies numbers (4 ms)
    ✓ divides numbers (4 ms)

Test Suites: 1 passed, 1 total
Tests:       5 passed, 5 total
Snapshots:   0 total
Time:        0.674 s, estimated 1 s
Ran all test suites.

Watch Usage: Press w to show more.
</pre>
<h2 id="conclusion">结论</h2>
<p>读完这篇文章后，我希望您了解了测试在生产级项目中的重要性。特别是对于大型项目，手动测试会花费很多时间。因此，用 Jest 编写自动化测试是一个很好的解决方案。每次你发布一个特性，当某个测试失败时，你会收到通知，这样你就可以立即进行修复。</p><div class="code-block code-block-30">
<div class="blog-plug inline-plug next-plug"><h2><a href="https://lp.logrocket.com/blg/nextjs-signup" target="_blank"> LogRocket </a>:全面了解生产 Next.js 应用</h2><p>调试下一个应用程序可能会很困难，尤其是当用户遇到难以重现的问题时。如果您对监视和跟踪状态、自动显示 JavaScript 错误、跟踪缓慢的网络请求和组件加载时间感兴趣，</p><a href="https://lp.logrocket.com/blg/nextjs-signup" target="_blank">try LogRocket</a><p>. </p><a class="signup" href="https://lp.logrocket.com/blg/nextjs-signup" target="_blank" rel="noopener noreferrer"><img class="alignnone size-full wp-image-46 jetpack-lazy-image" src="../Images/f300c244a1a1cf916df8b4cb02bec6c6.png" data-lazy-src="https://files.readme.io/27c94e7-Image_2017-06-05_at_9.46.04_PM.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://files.readme.io/27c94e7-Image_2017-06-05_at_9.46.04_PM.png"/><noscript><img data-lazy-fallback="1" class="alignnone size-full wp-image-46" src="../Images/f300c244a1a1cf916df8b4cb02bec6c6.png" data-original-src="https://files.readme.io/27c94e7-Image_2017-06-05_at_9.46.04_PM.png"/></noscript></a><a class="signup" href="https://lp.logrocket.com/blg/nextjs-signup" target="_blank" rel="noopener noreferrer"><img class="alignnone size-full wp-image-46 jetpack-lazy-image" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/><noscript><img data-lazy-fallback="1" class="alignnone size-full wp-image-46" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/></noscript></a><p>LogRocket 就像是网络和移动应用的 DVR，记录下你的 Next.js 应用上发生的一切。您可以汇总并报告问题发生时应用程序的状态，而不是猜测问题发生的原因。LogRocket 还可以监控应用程序的性能，报告客户端 CPU 负载、客户端内存使用等指标。</p><p>LogRocket Redux 中间件包为您的用户会话增加了一层额外的可见性。LogRocket 记录 Redux 存储中的所有操作和状态。</p><p>让您调试 Next.js 应用的方式现代化— <a class="signup" href="https://lp.logrocket.com/blg/nextjs-signup" target="_blank" rel="noopener noreferrer">开始免费监控</a>。</p></div></div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
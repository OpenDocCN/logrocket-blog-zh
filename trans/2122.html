<html>
<head>
<title>What’s new in Svelte: Summer 2021 - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>《苗条身材:2021 年夏天》中的新内容</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/whats-new-svelte-summer-2021/#0001-01-01">https://blog.logrocket.com/whats-new-svelte-summer-2021/#0001-01-01</a></blockquote><div><article class="article-post">
<h2>介绍</h2>
<p>Svelte 是一个令人兴奋的新 JavaScript 框架，它提供了一种构建 web 应用程序的新方法。</p>
<p/>
<p>Svelte 借用了 React 和 Vue 等旧 JavaScript 框架的一些概念。有了这些方面的知识，我们可以很容易地过渡到苗条。</p>
<p>今年夏天，Svelte 的许多每月更新都集中在增强开发者体验上——<code>DX</code>，性能改进，更好的<code>TypeScript</code>支持，以及一些错误修复。让我们来看看其中的一些:</p>
<h2>纤薄的新功能</h2>
<h3>1.<code>await</code>速记</h3>
<p>根据<a href="https://svelte.dev/docs#await">细长文档</a> , <code>await</code>模块允许你对一个承诺的三种可能状态进行分支:待定、完成或拒绝。</p>
<p>考虑下面的代码:</p>
<pre>{#await promise}
        &lt;!-- pending state --&gt;
        &lt;p&gt;Loading...&lt;/p&gt;
{:then value}
        &lt;!-- fulfilled state --&gt;
        &lt;p&gt;The value is {value}&lt;/p&gt;
{:catch error}
        &lt;!-- rejected state --&gt;
        &lt;p&gt;An error occurred: {error.message}&lt;/p&gt;
{/await}
</pre>
<p>在上面的代码中，我们有 pending、fulfilled 和 rejected。<code>{#await}</code>块匹配当前语法中的所有三个；但是，当我们不需要显示加载状态时，没有办法省略初始块。</p>
<p><code>await</code>简写语法使我们能够省略 promise 的 resolve 值的加载状态块。<br/>考虑下面的代码:</p>
<pre>{#await promise then value}
        &lt;p&gt;Do somthing with value{value}&lt;/p&gt;
{/await}
</pre>
<p>类似地，我们可以省略<code>then</code>块，如下所示:</p>
<pre>{#await promise catch error}
        &lt;p&gt;Something went wrong: {error.message}&lt;/p&gt;
{/await}
</pre>
<h3>2.添加<code>trusted</code>事件修改器</h3>
<p>Svelte 提供了不同的<a href="https://svelte.dev/tutorial/event-modifiers">事件修改器</a>来改变事件的行为。我们通过使用<a href="https://en.wikipedia.org/wiki/Vertical_bar">管道字符</a>将这些修饰符标记到事件的末尾。</p>
<p>考虑下面的代码:</p>
<pre>&lt;script&gt;
    function handleSubmit() {
          console.log("submitting for data");
    }
&lt;/script&gt;

&lt;form on:submit|preventDefault={handleSubmit}&gt;
  // do something
&lt;/form&gt;
</pre>
<p>在上面的代码中，我们用<code>preventDefault</code>修改了<code>submit</code>事件。因此，我们防止页面在提交表单时被重新加载。</p>
<p><code>isTrusted</code>修饰符使事件能够检查事件是否可信，并且只有当事件可信时才触发处理程序。也就是说，如果<code>event.isTrusted</code>是<code>true</code>。如果事件是由用户操作触发的，则该事件是可信的:</p>
<pre>&lt;button on:click|trusted={() =&gt; console.log('Trusted event'); }&gt;&lt;/button&gt;
</pre>
<h3>3.组件中对<code>export { ... } from</code>语法的支持</h3>
<p>该功能旨在通过提供一种简洁的方式来增强开发人员的体验，以便在使用 bundler 文件处理程序(如<a href="https://github.com/rollup/plugins/tree/master/packages/url"> @rollup/plugin-url </a>和<a href="https://v4.webpack.js.org/loaders/file-loader/"> Webpack <code>file-loader</code> </a>)时导入文件。</p>
<p>目前，我们要做的是:</p>
<pre>import dogImgJpg from './dogImgJpg.jpg';
export let dogImg = dogImgJpg;
</pre>
<p>上面的模式有点冗长，因为我们必须显式地<code>import</code>和<code>export</code>文件。</p>
<p>像<code>export {…} from</code>这样的语法会抛出一个错误，因为它不包含必要的<code>import</code>。然而，Svelte 现在在 v3.41.0 中支持这个特性。所以我们可以简单地导出上面的<code>dogImgJpg.jpg</code>图像，方法是:</p>
<pre>export { default as dogImg } from './dogImgJpg.jpg';
</pre>
<p>这隐式地导入了<code>dogImgJpg</code>。</p>
<h3>4.导出道具时对象析构</h3>
<p>类似地，该功能旨在通过使我们能够析构对象属性并在一行中导出它们来增强开发人员的体验:</p>
<pre>const man = {surname: 'eagles', firstname: 'lawrence'};
export let {surname} = man;
</pre>
<h3>5.添加一个<code>errorMode</code>编译器选项</h3>
<p>这个特性给苗条的<a href="https://svelte.dev/docs#svelte_compile">编译器选项</a> — <code>svelte.compile()</code>增加了一个<code>errorMode</code>。当<code>errorMode</code>设置为<code>warn</code>时，Svelte 会将错误记录为警告并继续编译，而不是抛出错误。</p>
<p>这也是 Svelte 在<code><a href="https://github.com/sveltejs/svelte-preprocess/issues/318">svelte/preproccess</a></code>上工作的一部分，旨在改善 TypeScript 文件的预处理。</p>
<h3>6.在阴影 DOM 中渲染苗条的组件</h3>
<p>这个吸引人的特性使得在创建组件时通过指定一个<code>ShadowRoot</code>作为<code>target</code>在影子 DOM 中使用 Svelte 成为可能。</p>
<p>这使得利用阴影 DOM 的样式封装成为可能，这在 Svelte 中很难做到，因为 Svelte 总是将样式附加到<code>document.head</code>中。你可以<a href="https://github.com/sveltejs/svelte/pull/5870">在这里</a>了解更多关于样式封装和影子 DOM 的知识。</p>
<h3>7.引入带有 VS 代码扩展的新 TypeScript 插件</h3>
<p>Svelte 增加了一个 TypeScript 插件和 VS 代码扩展。</p>
<p>VS 代码扩展——svelote for VS Code——使用 svelote 语言服务器为 VS 代码中的 svelote 文件提供智能感知。此外，这个扩展捆绑了一个更漂亮的插件，作为苗条文件的格式化程序。</p>
<p>我们可以通过调整我们的 VS 代码设置来用这个格式化程序格式化我们的苗条文件，如下所示:</p>
<pre>...
"[svelte]": {
  "editor.defaultFormatter": "svelte.svelte-vscode"
},
...
</pre>
<p>此外，在安装和使用该扩展之前，需要注意以下几点:</p>
<ul>
<li>如果你使用的是詹姆斯·比特莱斯的旧版本，卸载它。通过运行:code–uninstall-extension jamesbirtles . svelte-vs code，您可以很容易地通过<code>CLI</code>做到这一点</li>
</ul>
<h3>8.为 SvelteKit 推出新的<code>svelte/ssr</code>套装<code>ssr</code></h3>
<p><a href="https://blog.logrocket.com/exploring-sveltekit-the-newest-svelte-based-framework/">svelite kit</a>就是 svelite next . js 是什么反应。SvelteKit 是一个用于构建不同规模的 web 应用程序的框架。并且它提供了对路由、代码分割、服务器端渲染和离线支持等的支持。</p>
<p>有了这个特性，在为<code>ssr</code>构建时，<code>svelte</code>被解析为<code>svelte/ssr</code>。这为生命周期事件处理程序启用了<a href="https://developer.mozilla.org/en-US/docs/Glossary/Tree_shaking">树摇动</a>，这是 JavaScript 中的一种技术，用于删除死代码并为生产准备我们的代码。</p>
<p>需要注意的是，在<code>SSR mode</code>中，所有简单的生命周期方法——<code>onMount</code>、<code>beforeUpate</code>、<code>afterUpdate</code>和<code>onDestroy</code>——都不做任何事情。因此，它们应该从最终束中移除。</p>
<p>然而，像<a href="https://rollupjs.org/guide/en/"> Rollup </a>和<a href="https://webpack.js.org"> Webpack </a>这样的构建工具无法检测到这一点。因此，它们最终出现在生成的包中。这为进一步优化我们的代码留下了空间。</p>
<p>新的<code>svelte/ssr</code>包是<code>svelte</code>的等效模块，但是生命周期方法被设计为<code><a href="https://en.wikipedia.org/wiki/NOP_(code)">noops</a></code>。<code>Noops</code>或<code>no-ops</code>可以设计在<code>ES6</code>中，如下图所示:</p>
<pre>const noop = () =&gt; {};
</pre>
<p>通过这样做，这些生命周期方法现在可以由细长的 bundler 插件如<code>rollup-plugin-svelte</code>和<code>@sveltejs/vite-plugin-svelt</code>使用树摇动来移除。这就产生了一个更加优化和生产就绪的代码。</p>
<h3>9.更新<code>svelte-check</code></h3>
<p>最新版本的<code>svelte-check</code>提供了到你的<code>tsconfig.json</code>或<code>jsconfig.json</code>的路径。因此，只能对该配置中引用的文件运行诊断。比如:<code>svelte-check --tsconfig "./tsconfig.json"</code>。</p>
<h2>结论</h2>
<p>Svelte 是一项了不起的技术，它为如何构建 web 应用程序提供了一个全新的视角。</p>
<p>即使你有使用框架如 Vue、Angular 或 React 进行 web 开发的经验，你仍然会被苗条的身材所吸引。</p>
<p>随着夏季的升温，Svelte 推出了几个有趣而诱人的新功能和增强功能，保持了凉爽。如果你还没有使用过<a href="https://blog.logrocket.com/how-to-build-a-simple-svelte-js-app/">svelite</a>，现在是时候试试了。</p>
<p>你可以在 Svelte 的更新日志中了解更多关于 Svelte 的更新。</p><div class="code-block code-block-1">
<div class="blog-plug base-cta"><h2>使用<a class="signup" href="https://lp.logrocket.com/blg/signup" target="_blank" rel="noopener noreferrer"> LogRocket </a>消除传统错误报告的干扰</h2>
<a href="https://lp.logrocket.com/blg/signup" class="signup" target="_blank" rel="noopener noreferrer"><img class="alignnone size-full wp-image-46 jetpack-lazy-image" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/><noscript><img data-lazy-fallback="1" class="alignnone size-full wp-image-46" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/></noscript></a>
<p><a href="https://lp.logrocket.com/blg/signup" target="_blank" rel="noopener noreferrer"> LogRocket </a>是一个数字体验分析解决方案，它可以保护您免受数百个假阳性错误警报的影响，只针对几个真正重要的项目。LogRocket 会告诉您应用程序中实际影响用户的最具影响力的 bug 和 UX 问题。</p>
<p>然后，使用具有深层技术遥测的会话重放来确切地查看用户看到了什么以及是什么导致了问题，就像你在他们身后看一样。</p>
<p>LogRocket 自动聚合客户端错误、JS 异常、前端性能指标和用户交互。然后 LogRocket 使用机器学习来告诉你哪些问题正在影响大多数用户，并提供你需要修复它的上下文。</p>
<p>关注重要的 bug—<a class="signup" href="https://lp.logrocket.com/blg/signup-issue-free" target="_blank" rel="noopener noreferrer">今天就试试 LogRocket】。</a></p></div></div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
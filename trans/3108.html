<html>
<head>
<title>Pathfinding in Rust: A tutorial with examples - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>Rust 中的寻路:示例教程- LogRocket 博客</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/pathfinding-rust-tutorial-examples/#0001-01-01">https://blog.logrocket.com/pathfinding-rust-tutorial-examples/#0001-01-01</a></blockquote><div><article class="article-post">
<p>寻路是许多应用中的一个重要问题。在本文中，我们将看看 Rust 语言中的一些寻路选项。</p>
<p>我们将涵盖的内容:</p>

<h2 id="what-pathfinding">什么是寻路？</h2>
<p>简单来说，寻路就是寻找两点之间的最短路径。在最简单的情况下，答案是“一条直线”，但事情可以变得比这复杂得多！</p>
<p>一些复杂因素的例子有:</p>
<ul>
<li>无法逾越的障碍</li>
<li>更难通过的地形</li>
</ul>
<p>例如，要处理更难通过的地形，可以给这两个点一个通过成本。然后，您可以将目标更改为找到这两点之间成本最低的路线。</p>
<h2 id="usages-pathfinding">寻路的用法</h2>
<p>寻路在许多应用中使用。一些最常见的是机器人和视频游戏，如 roguelike 游戏。</p>
<p>在机器人学中，机器人的一个常见任务是在环境中导航，并尽快从 A 点到达 B 点。</p>
<p>在视频游戏中，由计算机控制的角色可能需要在环境中移动位置。此外，如果游戏允许玩家设置路点，它可能还想显示到达下一个路点的最快方法。</p>
<h2 id="pathfinding-examples-rust">Rust 中的寻路示例</h2>
<p>既然我们已经确定了寻路的有用性，那么让我们来看几个在<a href="https://blog.logrocket.com/why-is-rust-popular/" target="_blank" rel="noreferrer noopener"> Rust，一种越来越流行的编程语言</a>中寻路的例子。</p>
<p>对于这些例子，我们将使用名副其实的<code><a href="https://crates.io/crates/pathfinding" target="_blank" rel="noreferrer noopener">pathfinding</a></code>板条箱，这是在<a href="https://crates.io/" target="_blank" rel="noreferrer noopener">Rust 社区的板条箱注册表</a>上最受欢迎的寻路板条箱。</p>
<p>请注意，大多数寻路算法是根据节点而不是连续空间来工作的。这篇<a href="https://www.gamasutra.com/view/feature/3096/toward_more_realistic_pathfinding.php" target="_blank" rel="noreferrer noopener">游戏开发者文章</a>讨论了一些让这些算法的结果看起来更自然的方法。</p>
<h3 id="example-rust-pathfinding-framework">Rust 寻路框架示例</h3>
<p>你可以查看我们将在 GitHub repo 中使用的<a href="https://github.com/gregstoll/rust-pathfinding" target="_blank" rel="noreferrer noopener">完整代码。</a></p>
<p><code><a href="https://github.com/gregstoll/rust-pathfinding/blob/main/src/lib.rs#L11" target="_blank" rel="noreferrer noopener">Board</a></code> <a href="https://github.com/gregstoll/rust-pathfinding/blob/main/src/lib.rs#L11" target="_blank" rel="noreferrer noopener">结构</a>定义了一个矩形棋盘，其中每个单元格都可能是一个障碍，或者有一个与移动到它相关联的成本。</p>
<p><code>Board::new()</code>允许创建电路板并用<code>Vec&lt;string&gt;</code>指定这些单元。在此字符串中，值在 1 到 9 之间的字符表示可以按定义的成本移动到的单元格。同时，字符“X”表示有障碍。</p>
<p>请注意，这些算法支持单元之间的单向链接。为了简单起见，我们不允许在<code>Board</code>结构中使用该功能。</p>
<p><code>Board::get_successors()</code>接受一个单元格位置并返回一个<code>Vec</code>单元格，这些单元格可以直接移动到它们的成本。正如我们将看到的，这是我们在寻路箱中将要看到的所有算法中使用的一个关键方法。</p>
<p>还有<code>Board::draw_to_image()</code>，这是用<code>Board</code>单元格编写图像的一种便捷方式——也可以选择一个路径。这种方法使用<code><a href="https://crates.io/crates/imageproc" target="_blank" rel="noreferrer noopener">imageproc</a></code>板条箱来绘图。</p>
<h3 id="using-breadth-first-search-pathfinding-rust">使用广度优先搜索在 Rust 中寻路</h3>
<p><a href="https://en.wikipedia.org/wiki/Breadth-first_search" target="_blank" rel="noreferrer noopener">广度优先搜索是一种相当简单的算法</a>，用于寻找从起始节点到目标节点的最短路径。从起始节点开始，它一次处理每个连接的节点。</p>
<p>如果那个节点是目标节点，那么我们就完成了！否则，我们将它的每个连接放入节点队列中查看并继续。</p>
<p>广度优先搜索算法不考虑节点的成本，但这是一个非常简单的例子。您可以使用广度优先搜索查看本例的完整源代码。</p>
<p>下面的代码显示了实际执行广度优先搜索的调用:</p>
<pre class="language-rust hljs">    let result = bfs(
        &amp;start,
        |p| board.get_successors(p).iter().map(|successor| successor.pos).collect::&lt;Vec&lt;_&gt;&gt;(), 
        |p| *p==goal);
</pre>
<p>根据 <code><a href="https://docs.rs/pathfinding/3.0.12/pathfinding/directed/bfs/fn.bfs.html" target="_blank" rel="noreferrer noopener">bfs()</a></code>的<a href="https://docs.rs/pathfinding/3.0.12/pathfinding/directed/bfs/fn.bfs.html" target="_blank" rel="noreferrer noopener">文档，参数为:</a></p>
<ul>
<li>开始的节点</li>
<li>接受一个节点并返回一个可以直接移动到的节点的<code>Vec</code>的函数</li>
<li>接受一个节点并返回它是否是目标节点的函数</li>
</ul>
<p>注意，由于广度优先搜索不支持节点的成本，我们必须映射<code>Board::get_successors()</code>的结果来移除成本。</p>
<p>此外，正如文档中提到的，接受一个节点并返回它是否是目标节点比仅仅接受目标节点更灵活。这是因为它允许多个目标节点，或者对一个节点是否是目标进行某种动态计算。</p>
<p>在这种情况下，我们只需要一个目标节点，这也很容易做到！</p>
<p><code>bfs()</code>返回<code>Option&lt;Vec&lt;N&gt;&gt;</code>，其中<code>N</code>是您传入的节点的类型。这是一个<code>Option&lt;&gt;</code>，因为从起点到目标可能没有路径；在那种情况下<code>None</code>被退回。否则，它返回从起点到目标的路径的<code>Vec</code>，包括两个端点。</p>
<p>要运行该示例，请使用<code>cargo run --bin bfs</code>。下图显示了从开始(蓝色)节点到目标(绿色)节点的路径:</p>
<p><img data-attachment-id="122269" data-permalink="https://blog.logrocket.com/pathfinding-rust-tutorial-examples/attachment/result-of-breadth-first-search-from-blue-node-to-green-node/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/06/Result-of-breadth-first-search-from-blue-node-to-green-node.png" data-orig-size="500,500" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Result-of-breadth-first-search-from-blue-node-to-green-node" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/06/Result-of-breadth-first-search-from-blue-node-to-green-node-300x300.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/06/Result-of-breadth-first-search-from-blue-node-to-green-node.png" decoding="async" class="aligncenter wp-image-122269 size-full jetpack-lazy-image" src="../Images/2c148e96f8e563bf4324a4ff7e375856.png" alt="Grey Arrows Indicating Result Of A Breadth-First Search From Blue Node To Green Node" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2022/06/Result-of-breadth-first-search-from-blue-node-to-green-node.png 500w, https://blog.logrocket.com/wp-content/uploads/2022/06/Result-of-breadth-first-search-from-blue-node-to-green-node-300x300.png 300w, https://blog.logrocket.com/wp-content/uploads/2022/06/Result-of-breadth-first-search-from-blue-node-to-green-node-150x150.png?crop=1 150w" data-lazy-sizes="(max-width: 500px) 100vw, 500px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2022/06/Result-of-breadth-first-search-from-blue-node-to-green-node.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/06/Result-of-breadth-first-search-from-blue-node-to-green-node.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="122269" data-permalink="https://blog.logrocket.com/pathfinding-rust-tutorial-examples/attachment/result-of-breadth-first-search-from-blue-node-to-green-node/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/06/Result-of-breadth-first-search-from-blue-node-to-green-node.png" data-orig-size="500,500" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Result-of-breadth-first-search-from-blue-node-to-green-node" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/06/Result-of-breadth-first-search-from-blue-node-to-green-node-300x300.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/06/Result-of-breadth-first-search-from-blue-node-to-green-node.png" decoding="async" loading="lazy" class="aligncenter wp-image-122269 size-full" src="../Images/2c148e96f8e563bf4324a4ff7e375856.png" alt="Grey Arrows Indicating Result Of A Breadth-First Search From Blue Node To Green Node" srcset="https://blog.logrocket.com/wp-content/uploads/2022/06/Result-of-breadth-first-search-from-blue-node-to-green-node.png 500w, https://blog.logrocket.com/wp-content/uploads/2022/06/Result-of-breadth-first-search-from-blue-node-to-green-node-300x300.png 300w, https://blog.logrocket.com/wp-content/uploads/2022/06/Result-of-breadth-first-search-from-blue-node-to-green-node-150x150.png?crop=1 150w" sizes="(max-width: 500px) 100vw, 500px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/06/Result-of-breadth-first-search-from-blue-node-to-green-node.png"/></noscript>
<h3 id="accounting-costs-rust-pathfinding-dijkstras-algorithm">用 Dijkstra 算法计算 Rust 寻路的代价</h3>
<p><a href="https://en.wikipedia.org/wiki/Dijkstra's_algorithm" target="_blank" rel="noreferrer noopener"> Dijkstra 算法</a>是另一种寻找从起始节点到目标节点最短路径的算法。与广度优先搜索不同，它在计算中使用了移动到一个节点的成本。</p>
<p>确保使用 Dijkstra 的算法查看本例的<a href="https://github.com/gregstoll/rust-pathfinding/blob/main/src/bin/dijkstra.rs" target="_blank" rel="noreferrer noopener">完整源代码。</a></p>
<p>下面是运行 Dijkstra 算法的调用:</p>
<pre class="language-rust hljs">    let result = dijkstra(
        &amp;start,
        |p| board.get_successors(p).iter().map(|s| (s.pos, s.cost)).collect::&lt;Vec&lt;_&gt;&gt;(),
        |p| *p==goal);
</pre>
<p>根据 <code><a href="https://docs.rs/pathfinding/3.0.12/pathfinding/directed/dijkstra/fn.dijkstra.html" target="_blank" rel="noreferrer noopener">dijkstra()</a></code>的<a href="https://docs.rs/pathfinding/3.0.12/pathfinding/directed/dijkstra/fn.dijkstra.html" target="_blank" rel="noreferrer noopener">文档，论据与<code>bfs()</code>非常相似。唯一的区别是第二个参数现在是元组的<code>Vec</code>，每个元组包含以下内容:</a></p>
<ul>
<li>可以直接移动到的节点</li>
<li>移动到该节点的开销</li>
</ul>
<p>再次，类似于<code>bfs()</code>，<code>dijkstra()</code>返回<code>Option&lt;(Vec&lt;N&gt;, C)&gt;</code>；元组的第二个成员是从起始节点到目标节点的总开销。</p>
<p>要运行这个例子，使用<code>cargo run --bin dijkstra</code>，这里是显示从开始节点(蓝色数字的那个)到目标节点(绿色数字的那个)的路径的结果图像:</p>
<p><img data-attachment-id="122274" data-permalink="https://blog.logrocket.com/pathfinding-rust-tutorial-examples/attachment/result-of-dijkstras-algorithm-from-blue-node-to-green-node/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/06/Result-of-Dijkstras-algorithm-from-blue-node-to-green-node.png" data-orig-size="500,500" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Result-of-Dijkstra’s-algorithm-from-blue-node-to-green-node" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/06/Result-of-Dijkstras-algorithm-from-blue-node-to-green-node-300x300.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/06/Result-of-Dijkstras-algorithm-from-blue-node-to-green-node.png" decoding="async" class="aligncenter wp-image-122274 size-full jetpack-lazy-image" src="../Images/5018295f749a126ffec5813700a9122a.png" alt="Grid With Various Costs Assigned To Each Square From One To Nine With Grey Arrows Indicating Path From Blue Node To Green Node Using Dijkstra's Algorithm" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2022/06/Result-of-Dijkstras-algorithm-from-blue-node-to-green-node.png 500w, https://blog.logrocket.com/wp-content/uploads/2022/06/Result-of-Dijkstras-algorithm-from-blue-node-to-green-node-300x300.png 300w, https://blog.logrocket.com/wp-content/uploads/2022/06/Result-of-Dijkstras-algorithm-from-blue-node-to-green-node-150x150.png?crop=1 150w" data-lazy-sizes="(max-width: 500px) 100vw, 500px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2022/06/Result-of-Dijkstras-algorithm-from-blue-node-to-green-node.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/06/Result-of-Dijkstras-algorithm-from-blue-node-to-green-node.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="122274" data-permalink="https://blog.logrocket.com/pathfinding-rust-tutorial-examples/attachment/result-of-dijkstras-algorithm-from-blue-node-to-green-node/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/06/Result-of-Dijkstras-algorithm-from-blue-node-to-green-node.png" data-orig-size="500,500" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Result-of-Dijkstra’s-algorithm-from-blue-node-to-green-node" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/06/Result-of-Dijkstras-algorithm-from-blue-node-to-green-node-300x300.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/06/Result-of-Dijkstras-algorithm-from-blue-node-to-green-node.png" decoding="async" loading="lazy" class="aligncenter wp-image-122274 size-full" src="../Images/5018295f749a126ffec5813700a9122a.png" alt="Grid With Various Costs Assigned To Each Square From One To Nine With Grey Arrows Indicating Path From Blue Node To Green Node Using Dijkstra's Algorithm" srcset="https://blog.logrocket.com/wp-content/uploads/2022/06/Result-of-Dijkstras-algorithm-from-blue-node-to-green-node.png 500w, https://blog.logrocket.com/wp-content/uploads/2022/06/Result-of-Dijkstras-algorithm-from-blue-node-to-green-node-300x300.png 300w, https://blog.logrocket.com/wp-content/uploads/2022/06/Result-of-Dijkstras-algorithm-from-blue-node-to-green-node-150x150.png?crop=1 150w" sizes="(max-width: 500px) 100vw, 500px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/06/Result-of-Dijkstras-algorithm-from-blue-node-to-green-node.png"/></noscript>
<p>请注意，由于节点的成本，该路径比直接路径更迂回一些。</p>
<h3 id="rust-pathfinding-using-a-star-search-algorithm">使用 A*搜索算法的 Rust 寻路</h3>
<p>我们之前看到的两个搜索都是从尝试每个连接的节点开始的。然而，问题中通常有更多的结构是这些算法没有利用的。</p>
<p>例如，如果你的目标节点在你的开始节点的正西方，那么第一次移动应该是在西方的方向！</p>
<p><a href="https://en.wikipedia.org/wiki/A*_search_algorithm" target="_blank" rel="noreferrer noopener"> A*搜索算法</a>(读作“A-star”)利用了这个额外的结构。它要求您传递一个启发式函数来估计从一个节点到目标的距离，并且这个估计值总是小于或等于实际距离。</p>
<p>使用这种试探，A*搜索算法可以首先尝试成本更低的路径。它还可以计算出何时可以停止，因为没有更短的路径。</p>
<p>警告:如果启发式算法不遵守这个属性，算法可能不会返回最短路径！如果你担心这一点，你可以用 Dijkstra 的算法运行一些测试用例，并确认 A*和 Dijkstra 的算法给出相同的结果，以确保启发式算法是有效的。</p>
<p>通常，如果您在二维空间中进行寻路，忽略成本并只计算两个节点之间的距离的启发式方法效果很好。</p>
<p>对于我们的例子<code>Board</code>，我们不允许对角线移动，所以两个单元格之间的距离是<a href="https://en.wikipedia.org/wiki/Taxicab_geometry" target="_blank" rel="noreferrer noopener">曼哈顿距离</a>。由于到达任何单元的最小成本是<code>1</code>，我们可以用它作为我们的启发式算法。</p>
<p>这里是使用 A*搜索算法的这个例子的<a href="https://github.com/gregstoll/rust-pathfinding/blob/main/src/bin/astar.rs" target="_blank" rel="noreferrer noopener">完整源代码，这里是运行它的调用:</a></p>
<pre class="language-rust hljs">    let result = astar(
        &amp;start,
        |p| board.get_successors(p).iter().map(|s| (s.pos, s.cost)).collect::&lt;Vec&lt;_&gt;&gt;(),
        |p| ((p.0 - goal.0).abs() + (p.1 - goal.1).abs()) as u32,
        |p| *p==goal);
</pre>
<p>根据 <code><a href="https://docs.rs/pathfinding/3.0.12/pathfinding/directed/astar/fn.astar.html" target="_blank" rel="noreferrer noopener">astar()</a></code>的<a href="https://docs.rs/pathfinding/3.0.12/pathfinding/directed/astar/fn.astar.html" target="_blank" rel="noreferrer noopener">文档，参数和返回值与<code>dijkstra()</code>相同，除了启发式函数，它是第三个参数。</a></p>
<p>如上所述，我们使用像元之间的曼哈顿距离作为启发式距离，即 x 值之差加上 y 值之差。</p>
<p>要运行该示例，请使用<code>cargo run --bin astar</code>。这是生成的图像:</p>
<p><img data-attachment-id="122278" data-permalink="https://blog.logrocket.com/pathfinding-rust-tutorial-examples/attachment/result-of-a-star-search-from-blue-node-to-green-node/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/06/Result-of-A-star-search-from-blue-node-to-green-node.png" data-orig-size="500,500" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Result-of-A-star-search-from-blue-node-to-green-node" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/06/Result-of-A-star-search-from-blue-node-to-green-node-300x300.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/06/Result-of-A-star-search-from-blue-node-to-green-node.png" decoding="async" class="aligncenter wp-image-122278 size-full jetpack-lazy-image" src="../Images/20f05fa0596871d54e8406d23844d82a.png" alt="Grid With Various Costs Assigned To Each Square With Grey Arrows Indicating Path From Blue Node To Green Node Using A Star Search" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2022/06/Result-of-A-star-search-from-blue-node-to-green-node.png 500w, https://blog.logrocket.com/wp-content/uploads/2022/06/Result-of-A-star-search-from-blue-node-to-green-node-300x300.png 300w, https://blog.logrocket.com/wp-content/uploads/2022/06/Result-of-A-star-search-from-blue-node-to-green-node-150x150.png?crop=1 150w" data-lazy-sizes="(max-width: 500px) 100vw, 500px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2022/06/Result-of-A-star-search-from-blue-node-to-green-node.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/06/Result-of-A-star-search-from-blue-node-to-green-node.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="122278" data-permalink="https://blog.logrocket.com/pathfinding-rust-tutorial-examples/attachment/result-of-a-star-search-from-blue-node-to-green-node/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/06/Result-of-A-star-search-from-blue-node-to-green-node.png" data-orig-size="500,500" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Result-of-A-star-search-from-blue-node-to-green-node" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/06/Result-of-A-star-search-from-blue-node-to-green-node-300x300.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/06/Result-of-A-star-search-from-blue-node-to-green-node.png" decoding="async" loading="lazy" class="aligncenter wp-image-122278 size-full" src="../Images/20f05fa0596871d54e8406d23844d82a.png" alt="Grid With Various Costs Assigned To Each Square With Grey Arrows Indicating Path From Blue Node To Green Node Using A Star Search" srcset="https://blog.logrocket.com/wp-content/uploads/2022/06/Result-of-A-star-search-from-blue-node-to-green-node.png 500w, https://blog.logrocket.com/wp-content/uploads/2022/06/Result-of-A-star-search-from-blue-node-to-green-node-300x300.png 300w, https://blog.logrocket.com/wp-content/uploads/2022/06/Result-of-A-star-search-from-blue-node-to-green-node-150x150.png?crop=1 150w" sizes="(max-width: 500px) 100vw, 500px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/06/Result-of-A-star-search-from-blue-node-to-green-node.png"/></noscript>
<h2 id="conclusion">结论</h2>
<p>当谈到 Rust 中的寻路时，A*搜索通常用于机器人和视频游戏应用程序。然而，A*搜索的一个缺点是它需要大量的内存来运行。</p>
<p>有一些变体，如<a href="https://en.wikipedia.org/wiki/Iterative_deepening_A*" target="_blank" rel="noreferrer noopener">迭代深化 A*搜索</a>和<a href="https://en.wikipedia.org/wiki/Fringe_search" target="_blank" rel="noreferrer noopener">边缘搜索</a>，可以改善其内存使用，寻路箱通过<code><a href="https://docs.rs/pathfinding/3.0.12/pathfinding/directed/idastar/fn.idastar.html" target="_blank" rel="noreferrer noopener">idastar()</a></code>和<code><a href="https://docs.rs/pathfinding/3.0.12/pathfinding/directed/fringe/fn.fringe.html" target="_blank" rel="noreferrer noopener">fringe()</a></code>方法支持这两种方法。这些方法与上面的<code>astar()</code>方法采用相同的参数，所以很容易试用。</p>
<p>如果你想在 Rust 中做一些探索，<a href="https://github.com/gregstoll/rust-pathfinding" target="_blank" rel="noreferrer noopener">克隆回购并尝试一下</a>！</p><div class="code-block code-block-29">
<div class="blog-plug inline-plug rust-plug"><h2><a href="https://lp.logrocket.com/blg/rust-signup" target="_blank">log rocket</a>:Rust 应用的 web 前端的全面可见性</h2><p>调试 Rust 应用程序可能很困难，尤其是当用户遇到难以重现的问题时。如果您对监控和跟踪 Rust 应用程序的性能、自动显示错误、跟踪缓慢的网络请求和加载时间感兴趣，</p><a href="https://lp.logrocket.com/blg/rust-signup" target="_blank">try LogRocket</a><p>. </p><a class="signup" href="https://lp.logrocket.com/blg/rust-signup" target="_blank" rel="noopener noreferrer"><img class="alignnone size-full wp-image-46 jetpack-lazy-image" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/><noscript><img data-lazy-fallback="1" class="alignnone size-full wp-image-46" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/></noscript></a><p>LogRocket 就像是网络和移动应用程序的 DVR，记录你的 Rust 应用程序上发生的一切。您可以汇总并报告问题发生时应用程序的状态，而不是猜测问题发生的原因。LogRocket 还可以监控应用的性能，报告客户端 CPU 负载、客户端内存使用等指标。</p><p>现代化调试 Rust 应用的方式— <a class="signup" href="https://lp.logrocket.com/blg/rust-signup" target="_blank" rel="noopener noreferrer">开始免费监控</a>。</p></div>


</div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
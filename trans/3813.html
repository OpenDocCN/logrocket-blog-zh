<html>
<head>
<title>Matching static and dynamic patterns in Nuxt 3 </title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>Nuxt 3中静态和动态模式的匹配</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/matching-static-dynamic-patterns-nuxt-3/#0001-01-01">https://blog.logrocket.com/matching-static-dynamic-patterns-nuxt-3/#0001-01-01</a></blockquote><div><article class="article-post">
<p>自2021年10月发布以来，Nuxt 3获得了广泛的好评。这个版本有一些很酷的特性，比如匹配动态路由的括号符号，以及服务器路由和一般工作流程的改进。</p>
<p>这篇文章将讨论Nuxt 3中的路由模式。我们将涵盖:</p>

<p>作为本教程的先决条件，你应该具备Vue.js框架的<a href="https://blog.logrocket.com/supercharge-vue-js-nuxt-js-apps-vueuse/">基础知识。</a></p>
<h2 id="mixing-matching-static-dynamic-text-route">在路线中混合和匹配静态和动态文本</h2>
<p>在Nuxt 3中，我们可以通过使用<code>:</code>字符来表示动态段，从而在路径中混合和匹配静态和动态段。例如，如果我们想定义一条路由，其静态路径为<code>/products</code>，动态分段为<code>id</code>，我们可以这样实现:</p>
<pre class="language-javascript hljs">{
  path: '/products/:id',
  component: ProductPage
}
</pre>
<p>在本例中，<code>id</code>段将被视为动态段，这意味着它可以是我们传递给路由的任何值。例如，如果我们导航到<code>**/products/123**</code> URL，<code>id</code>段将被设置为<code>123</code>。</p>
<p>要访问组件中动态段的值，我们可以使用Nuxt.js提供的<code>$route</code>对象。例如，如果我们想要访问<code>ProductPage</code>组件中的<code>id</code>段，我们可以像这样使用<code>$route.params</code>属性:</p>
<pre class="language-javascript hljs">export default {
  computed: {
    productId() {
      return this.$route.params.id
    }
  }
}
</pre>
<p>然后，我们可以使用组件中的<code>productId</code> computed属性来访问<code>id</code>段的值。请记住，<code>$route</code>对象是反应性的，这意味着每当路线改变时，它都会自动更新。</p>
<p>总之，为了在Nuxt.js v3中混合和匹配路由路径中的静态和动态段，我们可以使用<code>:</code>字符来表示动态段。然后，我们可以使用组件中的<code>$route</code>对象来访问这些段的值。</p>
<p>我们可以在Nuxt 2中使用相同的策略实现这一点，但是对动态文件使用不同的命名模式。例如，在Nuxt 3中，动态文件用<code>[]</code>符号表示，而在Nuxt 2中，我们将使用<code>_</code>符号。</p>
<h2 id="creating-partial-matches-child-routes">在子路由上创建部分匹配</h2>
<p>在Nuxt 3中，可以使用动态参数在子路由中实现部分匹配。</p>
<p>动态参数是以冒号<code>:</code>开头的路径段，匹配任何值。例如，如果您想创建一个匹配任何用户ID的路由，您可以像这样定义一个路由:</p>
<pre class="language-javascript hljs">/users/:id
</pre>
<p>该路由将匹配任何以<code>/users/</code>开头、后跟任何值的URL。例如，此路由将匹配以下所有URL:</p>
<pre class="language-javascript hljs">/users/123
/users/abc
/users/user123
</pre>
<p>要访问route组件中动态参数的值，可以使用<code>$route.params</code>对象。例如，如果URL是<code>/users/123</code>，您可以像这样访问<code>id</code>参数的值:</p>
<pre class="language-javascript hljs">const id = this.$route.params.id
</pre>
<p>您也可以在子路由中使用动态参数。例如，如果您有一个显示用户详细信息的路由，您可以像这样定义子路由:</p>
<pre class="language-javascript hljs">/users/:id/details
</pre>
<p>仅当URL是<code>/users/:id</code>路由的子级时，才会匹配此路由。它将从父路由继承<code>id</code>参数的值。但是，它与下面的URL不匹配，因为它们没有<code>:child</code>参数的值:</p>
<pre class="language-javascript hljs">/parent
/parent/
</pre>
<p>为了使路由匹配部分URL，我们可以在路径中使用<code>_</code>语法，如下所示:</p>
<pre class="language-javascript hljs">{
    path: '/parent/_*',
    component: './parent/child.vue'
}
</pre>
<p>上述路由将匹配以下URL:</p>
<pre class="language-javascript hljs">/parent/abc
/parent/xyz
/parent
/parent/
</pre>
<p>现在，<code>_</code>参数将匹配URL的<code>/parent/</code>部分之后的任何值，包括一个空字符串。</p>
<h2 id="multiple-dynamic-parameters-route-matching">使用多个动态参数进行路线匹配</h2>
<p>在Nuxt 3中，可以使用多个动态参数来实现复杂的路由匹配。</p>
<p>例如，如果您想要创建一个与<a href="https://blog.logrocket.com/using-shopify-hydrogen-build-modern-ecommerce-storefronts/">产品详细信息页面</a>相匹配的路线，您可以像这样定义一个路线:</p>
<pre class="language-javascript hljs">/products/:category/:productId
</pre>
<p>上面的路由将匹配任何以<code>/products/</code>开头，后跟一个<code>category</code>参数值，再后跟一个<code>productId</code>参数值的URL。例如，此路由将匹配以下所有URL:</p>
<pre class="language-javascript hljs">/products/books/123
/products/clothing/abc
/products/electronics/xyz
</pre>
<p>要访问route组件中的动态参数值，可以使用<code>$route.params</code>对象。例如，如果URL是<code>/products/books/123</code>，您可以像这样访问<code>category</code>和<code>productId</code>参数的值:</p>
<pre class="language-javascript hljs">const category = this.$route.params.category
const productId = this.$route.params.productId
</pre>
<p>您也可以在子路由中使用动态参数。例如，如果您有一个显示产品评论的路由，您可以像这样定义一个子路由:</p>
<pre class="language-javascript hljs">/products/:category/:productId/reviews
</pre>
<p>只有当URL是<code>/products/:category/:productId</code>路由的子级时，上述路由才会匹配。此外，它将从父路由继承<code>category</code>和<code>productId</code>参数的值。</p>
<p>您也可以在<code>nuxt.config.js</code>文件中定义多条动态路线。例如，如果您想要在<code>/profile/:id</code> URL上提供一个用户配置文件列表，我们可以像这样定义一个动态路由:</p>
<pre class="language-javascript hljs">// nuxt.config.js

export default {
  // ... other Nuxt.js configuration options

  // define the dynamic routes
  generate: {
    routes: [
      '/profile/:id',
      // add additional dynamic routes here as needed
    ]
  }
}
</pre>
<p>然后，在<code>pages/users/[id].vue</code>页面组件中，您可以使用Nuxt.js提供的<code>$route</code>对象来访问<code>id</code>参数。例如:</p>
<pre class="language-javascript hljs">// pages/products/[id].vue

export default {
  data() {
    return {
      product: null
    }
  },
  async asyncData({ $route }) {
    // fetch the user data using the `id` parameter from the URL
    const product = await fetchProducts($route.params.id)

    return {
      product
    }
  }
}
</pre>
<p>当呈现页面时，Nuxt.js将在适当的URL(例如，<code>/users/123</code>)自动生成页面的静态版本，用户数据已经包含在页面中。这允许我们使用动态路由，同时受益于静态站点生成的<a href="https://blog.logrocket.com/ssg-vs-ssr-in-next-js/">性能优势。</a></p>
<h2 id="conclusion">结论</h2>
<p>最后，让我们快速总结一下本文所涉及的内容。</p>
<p>Nuxt是一个类似Next.js 的<a href="https://blog.logrocket.com/next-js-vs-nuxt-js/">框架，用于构建服务器渲染的Vue.js应用。它提供了一种强大的方法，使用页面和布局的概念为您的应用程序创建路线。在Nuxt 3中，可以使用静态模式和动态参数来定义匹配特定URL模式的路由。</a></p>
<p>静态模式是与特定URL完全匹配的简单字符串模式。例如，您可以定义一个类似于<code>/about</code>的路由，它与<code>/about</code> URL完全匹配。</p>
<p>另一方面，动态参数是以冒号<code>:</code>开始并匹配任何值的路径段。您可以使用动态参数来创建匹配任何可能值的路径，从而更容易创建可处理动态数据的路径。</p>
<p>在这篇文章中，我们回顾了Nuxt 3中一些流行的路由改进和一些实际的实现例子，期待下一个版本。让我知道你对Nuxt团队有什么期望，或者通过阅读更多关于使用Nuxt 开发<a href="https://blog.logrocket.com/tag/nuxtjs/">的内容来磨练你的技能。</a></p><div class="code-block code-block-4">
<div class="blog-plug base-cta"><h2>使用<a class="signup" href="https://lp.logrocket.com/blg/signup" target="_blank" rel="noopener noreferrer"> LogRocket </a>消除传统错误报告的干扰</h2>
<a href="https://lp.logrocket.com/blg/signup" class="signup" target="_blank" rel="noopener noreferrer"><img class="alignnone size-full wp-image-46 jetpack-lazy-image" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/><noscript><img data-lazy-fallback="1" class="alignnone size-full wp-image-46" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/></noscript></a>
<p><a href="https://lp.logrocket.com/blg/signup" target="_blank" rel="noopener noreferrer"> LogRocket </a>是一个数字体验分析解决方案，它可以保护您免受数百个假阳性错误警报的影响，只针对几个真正重要的项目。LogRocket会告诉您应用程序中实际影响用户的最具影响力的bug和UX问题。</p>
<p>然后，使用具有深层技术遥测的会话重放来确切地查看用户看到了什么以及是什么导致了问题，就像你在他们身后看一样。</p>
<p>LogRocket自动聚合客户端错误、JS异常、前端性能指标和用户交互。然后LogRocket使用机器学习来告诉你哪些问题正在影响大多数用户，并提供你需要修复它的上下文。</p>
<p>关注重要的bug—<a class="signup" href="https://lp.logrocket.com/blg/signup-issue-free" target="_blank" rel="noopener noreferrer">今天就试试LogRocket】。</a></p></div></div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
<html>
<head>
<title>New ES2021 features you may have missed - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>你可能错过的 ES2021 新功能- LogRocket 博客</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/new-es2021-features-you-may-have-missed/#0001-01-01">https://blog.logrocket.com/new-es2021-features-you-may-have-missed/#0001-01-01</a></blockquote><div><article class="article-post">
<p id="newes2021featuresyoumayhavemissedcopy">对于那些不知道的人来说，<a href="https://tc39.es/"> TC39 </a>是 ECMAScript (JavaScript)规范标准化背后的组织。自从 2015 年 ES6 发布以来，每年发布新功能已经成为常态。</p>
<p>对于要添加到年度版本中的特性，它必须经过四个提议阶段，最后一个阶段是批准。让我们看看目前处于<a href="https://github.com/tc39/proposals/blob/master/finished-proposals.md">最后阶段</a>的五个功能提案，预计发布日期为 2021 年年中。</p>
<h2>1.逻辑赋值运算符</h2>
<p>新的<a href="https://tc39.es/proposal-logical-assignment/">逻辑赋值运算符</a> <code>&amp;&amp;=</code>、<code>||=</code>和<code>??=</code>与现有的<a href="https://blog.logrocket.com/a-comprehensive-guide-to-javascript-expressions/">逻辑运算符</a>非常相似，对于给变量赋值默认值非常有用。</p>
<h3>逻辑或赋值运算符(<code>||=</code>)</h3>
<pre>x ||= y</pre>
<p>逻辑 or 赋值运算符是一种短路运算，就像逻辑 OR 运算符(<code>||</code>)一样。上面的表达式与<code>x || (x = y)</code>相同，也就是说只有当<code>x</code>为<a href="https://developer.mozilla.org/en-US/docs/Glossary/Falsy"> falsy </a>时，<code>y</code>才会被赋值给<code>x</code>。否则，<code>x</code>保留其原始值。</p>
<p><strong>举例:</strong></p>
<pre>const giveKey = () =&gt; {
  //perform randon computations
  return "somekey";
}
let userDetails = {name:"chika", age:5, room:10, key:""}
userDetails.key ||= giveKey()
console.log(userDetails.key)

//output : somekey
</pre>
<p><code>console.log(userDetails.key)</code>返回<code>"somekey"</code>，因为原始键值是一个空字符串，这是一个 falsy 值。</p>
<h3>逻辑与赋值运算符(<code>&amp;&amp;=</code>)</h3>
<pre>x &amp;&amp;= y
</pre>
<p>逻辑 AND 赋值运算符与逻辑 or 赋值运算符相反。在这种情况下，当且仅当<code>x</code>是一个<a href="https://developer.mozilla.org/en-US/docs/Glossary/Truthy">真值</a>时，<code>y</code>才被赋值给<code>x</code>。否则，它将保留其原始值。</p>
<p><strong>举例:</strong></p>
<pre>const deleteKey = () =&gt; {
  //perform randon computations
  return " ";
}
let userDetails = {name:"chika", age:5, room:10, key:"990000"}
userDetails.key &amp;&amp;= deleteKey()
console.log(userDetails.key)

//output : ""
</pre>
<p><code>userDetails.key &amp;&amp;= deleteKey()</code>从<code>deleteKey</code>函数返回一个空字符串，因为<code>userDetails</code>的前一个值是一个数字，这是一个真值。</p>
<h3>逻辑零赋值运算符(<code>??=</code>)</h3>
<pre>x ??= y
</pre>
<p>如果<code>x</code>为空(即空或未定义)，则<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Logical_nullish_assignment">逻辑空运算符</a> r 仅将<code>y</code>分配给<code>x</code>。</p>
<p><strong>举例:</strong></p>
<pre>const getKey = () =&gt; {
  //perform randon computations
  return "somekey";
}
let userDetails = {name:"chika", age:5, room:10,}
userDetails.key ??= getKey()
console.log(userDetails.key)

//output : "somekey"
</pre>
<p>这里的输出是<code>"somekey"</code>，因为<code>userDetails.key</code>在响应对象中不存在(即，它是未定义的)。</p>
<h2 id="h22stringreplaceall">2.<code>String.replaceAll</code></h2>
<pre>const newString = oldString.replaceAll(pattern, replacement);
</pre>
<p><code><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/replaceAll">replaceAll</a></code>方法返回一个新字符串，其中所有出现的<code>pattern</code>都被传递给它的<code>replacement</code>替换。<code>pattern</code>参数可以是一个字符串或正则表达式模式，<code>replacement</code>可以是一个字符串或一个创建新字符串来替换<code>pattern</code>的函数。</p>
<p><code>replaceAll</code>方法是<code><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/replace">String.replace</a></code>方法的延续，只是用<code>replacement</code>替换了第一次出现的<code>pattern</code>。</p>
<p><strong>举例:</strong></p>
<pre>const str = "Linda is a self-taught developer.Linda will rule the world";

let newStr = str.replace("Linda","Micheal")
//output: Micheal is a self-taught developer.Linda will rule the world

let newStr = str.replaceAll("Linda","Micheal")
//output: Micheal is a self-taught developer.Micheal will rule the world
</pre>
<h2>3.数字分隔符</h2>
<p>数字分隔符通过使用下划线(<code>_</code>)字符来分隔数字组，就像在书写中使用逗号来分隔数字一样，从而提高了大数字的可读性。考虑一下数字<code>1200044555</code>。乍一看，这个数字是 12 亿之类的，很难破译。</p>
<p><strong>举例:</strong></p>
<pre>const billGatesNetWorth = 1_200_044_555;
</pre>
<p>现在这个可读性更强了。请注意，这不会带来任何性能优势，也不会影响平等性。<code>1_200_044_555</code>仍然等于<code>1200044555</code>。</p>
<h2 id="h24promiseany">4.<code>Promise.any</code></h2>
<pre>Promise.any([promise1, promise2, promise3, ...]).then(....do something)
</pre>
<p><code><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/any">Promise.any()</a></code>方法是一种新的承诺方法，它接受一系列承诺，并解析到成功解析的第一个承诺的值。换句话说，如果任何一个承诺成功，则<code>Promise.any</code>成功；如果所有承诺都拒绝，则<code>Promise.any</code>拒绝。</p>
<p><strong>举例:</strong></p>
<pre>const promise1 = new Promise((resolve) =&gt; setTimeout((resolve) =&gt; resolve, 300, 'faster');
const promise2 = new Promise((reject) =&gt; setTimeout( (reject) =&gt;reject, 100,"fastest")
const promise3 = new Promise((resolve) =&gt; setTimeout( (resolve) =&gt; resolve,700,'fast');
const promises = [promise1, promise2, promise3];

Promise.any(promises).then((value)=&gt;console.log(value));

//Output: faster
</pre>
<h2>5.<code>WeakRef</code></h2>
<pre>const weakRef = new WeakRef({
   name:"Linda";
});
console.log(weakRef.deref().name)

//output: Linda
</pre>
<p>根据 TC39 提案注释,<code>WeakRef</code>是一个应该避免的高级特性。要理解<code>WeakRef</code>做什么，首先需要理解 JavaScript 中对象引用和<a href="https://blog.logrocket.com/javascript-garbage-collection-browser-vs-server/">垃圾收集</a>的概念。</p>
<pre>const obj = {}
</pre>
<p>当您在 JavaScript 中创建一个对象并将其赋给一个变量时，浏览器上运行的 JavaScript 引擎会分配一个存储该对象的内存地址。另一方面，对象被赋给的变量存储的是对象的内存地址，而不是对象本身的值。所以，你可以说<code>obj</code>保存了一个对分配给它的对象的引用。</p>
<p>随着对象被创建并存储在内存中，在某个时候，浏览器可能会开始耗尽内存，需要释放内存空间。垃圾收集是浏览器引擎通过删除不再被任何变量引用的对象来释放内存空间的过程。</p>
<p><code>WeakRef</code>创建传递给它的对象的弱引用。这意味着每当浏览器需要运行垃圾收集时，如果对该对象的唯一引用来自一个<code>WeakRef</code>变量，JavaScript 引擎可以安全地从内存中删除该对象并释放空间。这可能是 WebSocket 数据的理想选择，因为它们的生命周期很短。</p>
<p>用<code>new WeakRef</code>构造函数创建一个<code>WeakRef</code>，可以通过<code>deRef</code>方法访问<code>WeakRef</code>变量的值。</p>
<h2>如何立即开始在您的代码库中使用 ES2021 功能</h2>
<p>最新版本的主流浏览器，如 Chrome 85、Firefox 79 和 Safari 14，已经支持 ES2021 的新功能。然而，为了让你的代码能够在老版本的浏览器中运行，你需要用<a href="https://babeljs.io/"> B </a> <a href="https://babeljs.io/"> abel </a>编译器来设置你的项目。</p>
<p>安装以下软件包:</p>
<pre>npm install --save-dev @babel/core @babel/cli @babel/preset-env 
npm install core-js
</pre>
<p>在项目的根目录下创建一个<code>babel.config.json</code>文件:</p>
<pre>{
    "presets": [
        [
            "@babel/preset-env",
            {
                "useBuiltIns": "usage",
                "corejs": {
                    "version": "3.8",
                    "proposals": true
                }
            }
        ]
    ]
}
</pre>
<p>上面的配置指示 Babel 使用 env 预置，它包含所有最新 JavaScript 特性的转换，这些特性已经进入了 TC39 提案流程的第四阶段。它还指示 Babel 在需要时从 core JS 中检索 polyfills。</p>
<p>在项目的根目录下创建一个<code>.browserlistrc</code>文件，指定 Babel 转换代码的目标浏览器:</p>
<pre>defaults
maintained node versions
</pre>
<p><code>defaults</code>查询指示 Babel 仅转换和聚合填充以下代码:</p>
<ul>
<li>最近两个版本的浏览器</li>
<li>市场份额使用率超过 0.5%的浏览器</li>
<li>没有死亡的浏览器</li>
</ul>
<p><code>maintained node versions</code>声明 Babel 应该为所有仍然由 Node.js 基金会维护的节点版本转换和聚合代码。</p>
<p>现在，您可以运行:</p>
<pre>./node_modules/.bin/babel src --out-dir lib
</pre>
<p>这将解析并转换你在<code>src</code>目录中的所有 JavaScript 文件为适合旧浏览器的代码(由你的<code>.browserlistrc</code>文件指定),并将每个文件输出到<code>lib</code>目录。</p>
<blockquote><p><strong>注意事项</strong>。，如果您使用的是 Create React App 或 vue-cli 之类的工具链，这些配置已经被抽象化了。</p></blockquote>
<p>仅此而已。你可以走了。立即开始使用 ES2021 吧！</p><div class="code-block code-block-27">
<div class="blog-plug inline-plug vanilla-javascript-cta"><h2>通过理解上下文，更容易地调试 JavaScript 错误</h2>
<p>调试代码总是一项单调乏味的任务。但是你越了解自己的错误，就越容易改正。</p>
<p>LogRocket 让你以新的独特的方式理解这些错误。我们的前端监控解决方案跟踪用户与您的 JavaScript 前端的互动，让您能够准确找出导致错误的用户行为。</p>
<a href="https://lp.logrocket.com/blg/javascript-signup" class="signup" target="_blank" rel="noopener noreferrer"><img class="alignnone size-full wp-image-46 jetpack-lazy-image" src="../Images/cbfed9be3defcb505e662574769a7636.png" alt="LogRocket Dashboard Free Trial Banner" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2020/06/reproduce-javascript-errors.gif?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/06/reproduce-javascript-errors.gif"/><noscript><img data-lazy-fallback="1" class="alignnone size-full wp-image-46" src="../Images/cbfed9be3defcb505e662574769a7636.png" alt="LogRocket Dashboard Free Trial Banner" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/06/reproduce-javascript-errors.gif"/></noscript></a>
<p>LogRocket 记录控制台日志、页面加载时间、堆栈跟踪、慢速网络请求/响应(带有标题+正文)、浏览器元数据和自定义日志。理解您的 JavaScript 代码的影响从来没有这么简单过！</p>
<a class="signup" href="https://lp.logrocket.com/blg/javascript-signup" target="_blank" rel="noopener noreferrer">Try it for free</a><p>.</p></div>


</div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
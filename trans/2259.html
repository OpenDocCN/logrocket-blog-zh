<html>
<head>
<title>Reading and writing JSON files in Node.js: A complete tutorial - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>在 Node.js 中读写 JSON 文件:完整教程- LogRocket 博客</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/reading-writing-json-files-nodejs-complete-tutorial/#0001-01-01">https://blog.logrocket.com/reading-writing-json-files-nodejs-complete-tutorial/#0001-01-01</a></blockquote><div><article class="article-post">
<h2>JSON 简介</h2>
<p>JavaScript Object Notation，简称 JSON，是互联网上最流行的数据存储和数据交换格式之一。JSON 语法的简单性使得人类和机器很容易读写。</p>
<p>尽管名字如此，JSON 数据格式的使用并不局限于 JavaScript。大多数编程语言都实现了可以轻松转换成 JSON 的数据结构，反之亦然。</p>
<p>JavaScript 以及 Node.js 运行时环境也不例外。通常情况下，这些 JSON 数据需要从一个文件中读取或写入到一个文件中，以实现持久性。节点运行时环境有内置的<code>fs</code>模块，专门用于处理文件。</p>
<p>本文是关于如何使用内置的<code>fs</code>模块读写 JSON 格式数据的综合指南。我们还将了解一些第三方 npm 包，它们简化了 JSON 格式数据的处理。</p>
<h2>序列化和反序列化 JSON</h2>
<p>序列化是将对象或数据结构修改为易于存储或通过互联网传输的格式的过程。您可以通过应用相反的过程来恢复序列化数据。</p>
<p>反序列化是指将序列化的数据结构转换为其原始格式。</p>
<p>您几乎总是需要将 JSON 或 JavaScript 对象序列化为 Node 中的 JSON 字符串。在将其写入存储设备或通过互联网传输之前，您可以使用<code>JSON.stringify</code>方法:</p>
<pre class="language-javascript hljs">const config = { ip: '1234.22.11', port: 3000};
console.log(JSON.stringify(config));
</pre>
<p>另一方面，在读取 JSON 文件之后，您需要在访问或操作数据之前使用<code>JSON.parse</code>方法将 JSON 字符串反序列化为普通的 JavaScript 对象:</p>
<pre class="language-javascript hljs">const config = JSON.stringify({ ip: '1234.22.11', port: 3000});
console.log(JSON.parse(config));
</pre>
<p><code>JSON.stringify</code>和<code>JSON.parse</code>是节点中全局可用的方法。在使用之前，您不需要安装或要求。</p>
<h2><code>fs</code>模块介绍</h2>
<p>因为<code>fs</code>模块是内置的，所以不需要安装。它提供了一些函数，可以用来读写 JSON 格式的数据，等等。</p>
<p>由<code>fs</code>模块公开的每个函数都有同步、回调和基于承诺的形式。方法的同步和回调变量可以从同步和回调 API 中访问。可以从基于承诺的 API 访问函数的基于承诺的变体。</p>
<h3>同步 API</h3>
<p>内置<code>fs</code>模块的同步方法阻塞事件循环和剩余代码的进一步执行，直到操作成功或失败。通常情况下，阻塞事件循环并不是您想要做的事情。</p>
<p>所有同步功能的名称都以<code>Sync</code>字符结尾。例如，<code>writeFileSync</code>和<code>readFileSync</code>都是同步函数。</p>
<p>您可以通过要求<code>fs</code>来访问同步 API:</p>
<pre class="language-javascript hljs">const fs = require('fs');

// Blocks the event loop
fs.readFileSync(path, options);
</pre>
<h3>回调 API</h3>
<p>与阻塞事件循环的同步方法不同，回调 API 的相应方法是异步的。您将把一个回调函数作为最后一个参数传递给该方法。</p>
<p>如果出现错误，回调函数将调用一个<code>Error</code>对象作为第一个参数。回调函数的其余参数取决于<code>fs</code>方法。</p>
<p>您也可以像同步 API 一样通过要求<code>fs</code>来访问回调 API 的方法:</p>
<pre class="language-javascript hljs">const fs = require('fs');

fs.readFile(path, options, callback);
</pre>
<h3>基于承诺的 API</h3>
<p>基于承诺的 API 是异步的，就像回调 API 一样。它返回一个承诺，您可以通过承诺链或异步等待来管理它。</p>
<p>您可以通过要求<code>fs/promises</code>来访问基于承诺的 API:</p>
<pre class="language-javascript hljs">const fs = require('fs/promises');

fs.readFile(path)
  .then((data) =&gt; {
    // Do something with the data
  })
  .catch((error) =&gt; {
    // Do something if error 
  });
</pre>
<p>我们使用了 commonJS 语法来访问上面代码片段中的模块。我们将在整篇文章中使用 commonJS 语法，因为 Node 默认将 JavaScript 代码视为 commonJS 模块。如果您愿意，也可以使用 ES6 模块。</p>
<p>根据节点文档，内置<code>fs</code>模块的回调 API 比基于 promise 的 API 性能更好。因此，本文中的大多数示例将使用回调 API。</p>
<h2>如何读取 Node.js 中的 JSON 文件</h2>
<p>节点运行时环境有内置的<code>require</code>函数和<code>fs</code>模块，您可以使用它们来加载或读取 JSON 文件。因为<code>require</code>是全球通用的，你不需要要求它。</p><div class="code-block code-block-54">
<hr/>
<h3>更多来自 LogRocket 的精彩文章:</h3>

<hr/></div>
<p>但是，在使用之前，您需要使用<code>fs</code>模块。我将在下面的小节中讨论如何使用内置的<code>fs</code>模块和<code>require</code>函数读取 JSON 文件。</p>
<h3>如何使用全局<code>require</code>函数加载 JSON 文件</h3>
<p>可以使用全局<code>require</code>函数同步加载 Node 中的 JSON 文件。使用<code>require</code>加载文件后，文件被缓存。因此，使用<code>require</code>再次加载文件将会加载缓存的版本。在服务器环境中，该文件将在下一次服务器重启时再次加载。</p>
<p>因此，建议使用<code>require</code>加载静态 JSON 文件，比如不经常改变的配置文件。如果你加载的 JSON 文件不断变化，就不要使用<code>require</code>，因为它会缓存加载的文件，如果你再次需要同一个文件，就使用缓存的版本。您最近的更改将不会被反映出来。</p>
<p>假设您有一个包含以下内容的<code>config.json</code>文件:</p>
<pre class="language-javascript hljs">{
    "port": "3000",
    "ip": "127.00.12.3"
}
</pre>
<p>您可以使用下面的代码在 JavaScript 文件中加载<code>config.json</code>文件。<code>require</code>总是将 JSON 数据作为 JavaScript 对象加载:</p>
<pre class="language-javascript hljs">const config = require('./config.json');
console.log(config);
</pre>
<h3>如何使用<code>fs.readFile</code>方法读取 JSON 文件</h3>
<p>可以使用<code>readFile</code>方法读取 JSON 文件。它异步读取内存中整个文件的内容，因此它不是读取大型 JSON 文件的最佳方法。</p>
<p><code>readFile</code>方法有三个参数。下面的代码片段显示了它的函数签名:</p>
<pre class="language-javascript hljs">fs.readFile(path, options, callback);
</pre>
<p>第一个参数<code>path</code>是文件名或文件描述符。第二个是可选的对象参数，第三个是一个<code>callback</code>函数。也可以将字符串而不是对象作为第二个参数传递。如果你传递一个字符串，那么它必须被编码。</p>
<p><code>callback</code>函数有两个参数。如果出现错误，第一个参数是<code>error</code>对象，第二个参数是序列化的 JSON 数据。</p>
<p>下面的代码片段将读取<code>config.json</code>文件中的 JSON 数据，并将其记录在终端上:</p>
<pre class="language-javascript hljs">const fs = require('fs');

fs.readFile('./config.json', 'utf8', (error, data) =&gt; {
     if(error){
        console.log(error);
        return;
     }
     console.log(JSON.parse(data));

})
</pre>
<p>在开始处理生成的 JavaScript 对象之前，确保反序列化传递给<code>callback</code>函数的 JSON 字符串。</p>
<h3>如何使用<code>fs.readFileSync</code>方法读取 JSON 文件</h3>
<p><code>readFileSync</code>是另一个类似于<code>readFile</code>的读取 Node 中文件的内置方法。两者的区别在于，<code>readFile</code>异步读取文件，而<code>readFileSync</code>同步读取文件。因此，<code>readFileSync</code>阻塞事件循环和剩余代码的执行，直到所有数据都被读取。</p>
<p>要理解同步和异步代码的区别，可以在这里阅读文章“<a href="https://blog.logrocket.com/understanding-asynchronous-javascript/" target="_blank" rel="noopener">了解异步 JavaScript </a>”。</p>
<p>下面是<code>fs.readFileSync</code>的函数签名:</p>
<pre class="language-javascript hljs">fs.readFileSync(path, options);
</pre>
<p><code>path</code>是要读取的 JSON 文件的路径，可以传递一个对象作为第二个参数。第二个参数是可选的。</p>
<p>在下面的代码片段中，我们使用<code>readFileSync</code>从<code>config.json</code>文件中读取 JSON 数据:</p>
<pre class="language-javascript hljs">const { readFileSync } = require('fs');
const data = readFileSync('./config.json');
console.log(JSON.parse(data));
</pre>
<h2>如何在 Node.js 中写入 JSON 文件</h2>
<p>就像读取 JSON 文件一样，<code>fs</code>模块提供了写入 JSON 文件的内置方法。</p>
<p>你可以使用<code>fs</code>模块的<code>writeFile</code>和<code>writeFileSync</code>方法。两者的区别在于<code>writeFile</code>是异步的，而<code>writeFileSync</code>是同步的。在编写 JSON 文件之前，确保使用<code>JSON.stringify</code>方法将 JavaScript 对象序列化为 JSON 字符串。</p>
<h3>如何使用<code>fs.writeFile</code>方法写入 JSON 文件</h3>
<p>如果您没有将可选的格式化参数传递给指定如何格式化 JSON 数据的<code>JSON.stringify</code>方法，那么<code>JSON.stringify</code>将在一行中格式化您的 JSON 数据。</p>
<p>如果您传递给<code>writeFile</code>方法的路径是一个现有的 JSON 文件，那么该方法将覆盖指定文件中的数据。如果文件不存在，它将创建一个新文件:</p>
<pre class="language-javascript hljs">const { writeFile } = require('fs');

const path = './config.json';
const config = { ip: '192.0.2.1', port: 3000 };

writeFile(path, JSON.stringify(config, null, 2), (error) =&gt; {
  if (error) {
    console.log('An error has occurred ', error);
    return;
  }
  console.log('Data written successfully to disk');
});
</pre>
<h3>如何使用<code>fs.writeFileSync</code>方法写入 JSON 文件</h3>
<p>与<code>writeFile</code>不同，<code>writeFileSync</code>同步写入文件。如果您使用<code>writeFileSync</code>，您将阻塞事件循环和剩余代码的执行，直到操作成功或出现错误。如果您传递的路径不存在，它将创建一个新文件，如果存在，它将覆盖它。</p>
<p>在下面的代码片段中，我们正在写入<code>config.json</code>文件。我们将代码包装在<code>try-catch</code>中，这样我们可以捕捉任何错误:</p>
<pre class="language-javascript hljs">const { writeFileSync } = require('fs');

const path = './config.json';
const config = { ip: '192.0.2.1', port: 3000 };

try {
  writeFileSync(path, JSON.stringify(config, null, 2), 'utf8');
  console.log('Data successfully saved to disk');
} catch (error) {
  console.log('An error has occurred ', error);
}
</pre>
<h3>如何附加一个 JSON 文件</h3>
<p>Node 没有内置的函数来追加或更新现成的现有 JSON 文件的字段。但是，您可以使用<code>fs</code>模块的<code>readFile</code>方法读取 JSON 文件，更新它，并用更新后的 JSON 覆盖 JSON 文件。</p>
<p>下面是一个代码片段，说明了如何去做:</p>
<pre class="language-javascript hljs">const { writeFile, readFile } = require('fs');
const path = './config.json';

readFile(path, (error, data) =&gt; {
  if (error) {
    console.log(error);
    return;
  }
  const parsedData = JSON.parse(data);
  parsedData.createdAt = new Date().toISOString();
  writeFile(path, JSON.stringify(parsedData, null, 2), (err) =&gt; {
    if (err) {
      console.log('Failed to write updated data to file');
      return;
    }
    console.log('Updated file successfully');
  });
});
</pre>
<h2>如何使用第三方 npm 包读写 JSON 文件</h2>
<p>在这一节中，我们将研究用于读写 JSON 格式数据的最流行的第三方节点包。</p>
<h3>如何使用<code>jsonfile</code> npm 包读写 JSON 文件</h3>
<p><code>jsonfile</code>是一个流行的 npm 包，用于在 Node 中读写 JSON 文件。您可以使用下面的命令安装它:</p>
<pre class="language-javascript hljs">npm i jsonfile
</pre>
<p>它类似于<code>fs</code>模块的<code>readFile</code>和<code>writeFile</code>方法，尽管<code>jsonfile</code>比内置方法有一些优势。</p>
<p>该软件包的一些功能如下:</p>
<ul>
<li>它开箱即用地序列化和反序列化 JSON</li>
<li>它有一个内置的实用程序，可以将数据附加到 JSON 文件中</li>
<li>支持承诺链</li>
</ul>
<p>您可以在下面的代码片段中看到运行中的<code>jsonfile</code>包:</p>
<pre class="language-javascript hljs">const jsonfile = require('jsonfile');
const path = './config.json';

jsonfile.readFile(path, (err, data) =&gt; {
  if (err) {
    console.log(err);
    return;
  }
  console.log(data);
});
</pre>
<p>您还可以使用承诺链来代替传递回调函数，如上例所示:</p>
<pre class="language-javascript hljs">const jsonfile = require('jsonfile');
const path = './config.json';

jsonfile
  .readFile(path)
  .then((data) =&gt; {
    console.log(data);
  })
  .catch((err) =&gt; {
    console.log(err);
  });
</pre>
<h3>如何使用<code>fs-extra</code> npm 包读写 JSON 文件</h3>
<p><code>fs-extra</code>是另一个流行的节点包，你可以用它来处理文件。虽然您可以使用这个包来管理 JSON 文件，但是它有一些方法，这些方法的功能不仅仅是读写 JSON 文件。</p>
<p>顾名思义，<code>fs-extra</code>拥有<code>fs</code>模块提供的所有功能，甚至更多。根据文档，您可以使用<code>fs-extra</code>包来代替<code>fs</code>模块。</p>
<p>在使用之前，您需要先从 npm 安装<code>fs-extra</code>:</p>
<pre class="language-javascript hljs">npm install fs-extra
</pre>
<p>下面的代码展示了如何使用<code>fs-extra</code>包的<code>readJson</code>方法读取 JSON 文件。您可以使用回调函数、承诺链接或<code>async/await</code>:</p>
<pre class="language-javascript hljs">const fsExtra = require('fs-extra');
const path = './config.json';

// Using callback
fsExtra.readJson(path, (error, config) =&gt; {
  if (error) {
    console.log('An error has occurred');
    return;
  }
  console.log(config);
});

// Using promise chaining
fsExtra
  .readJson(path)
  .then((config) =&gt; {
    console.log(config);
  })
  .catch((error) =&gt; {
    console.log(error);
  });

// Using async/await
async function readJsonData() {
  try {
    const config = await fsExtra.readJson(path);
    console.log(config);
  } catch (error) {
    console.log(error);
  }
}
readJsonData();
</pre>
<p>下面的代码说明了如何使用<code>writeJson</code>方法编写 JSON 数据:</p>
<pre class="language-javascript hljs">const { writeJson } = require('fs-extra');

const path = './config.json';
const config = { ip: '192.0.2.1', port: 3000 };

// Using callback
writeJson(path, config, (error) =&gt; {
  if (error) {
    console.log('An error has occurred');
    return;
  }
  console.log('Data written to file successfully ');
});

// Using promise chaining
writeJson(path, config)
  .then(() =&gt; {
    console.log('Data written to file successfully ');
  })
  .catch((error) =&gt; {
    console.log(error);
  });

// Using async/await
async function writeJsonData() {
  try {
    await writeJson(path, config);
    console.log('Data written to file successfully ');
  } catch (error) {
    console.log(error);
  }
}
writeJsonData();
</pre>
<p>就像<code>fs</code>模块一样，<code>fs-extra</code>既有异步方法也有同步方法。在写入 JSON 文件之前，不需要对 JavaScript 对象进行字符串化。</p>
<p>类似地，在读取 JSON 文件后，您不需要解析到 JavaScript 对象。该模块为您开箱即用。</p>
<h3>如何使用<code>bfj</code> npm 包读写 JSON 文件</h3>
<p><code>bfj</code>是另一个可以用来处理 JSON 格式数据的 npm 包。根据文档，它是为管理大型 JSON 数据集而创建的。</p>
<blockquote><p><code>bfj</code>实现异步函数并使用预先分配的固定长度数组来尝试和缓解与解析和字符串化大型 JSON 或 JavaScript 数据集相关的问题—<a href="https://gitlab.com/philbooth/bfj/-/blob/master/README.md" target="_blank" rel="noopener">bfj 文档</a></p></blockquote>
<p>您可以使用<code>read</code>方法读取 JSON 数据。<code>read</code>方法是异步的，它返回一个承诺。</p>
<p>假设您有一个<code>config.json</code>文件，您可以使用以下代码来读取它:</p>
<pre class="language-javascript hljs">const bfj = require('bfj');
const path = './config.json';

bfj
  .read(path)
  .then((config) =&gt; {
    console.log(config);
  })
  .catch((error) =&gt; {
    console.log(error);
  });
</pre>
<p>类似地，您可以使用<code>write</code>方法将数据写入 JSON 文件:</p>
<pre class="language-javascript hljs">const bfj = require('bfj');
const path = './config.json';

const config = { ip: '192.0.2.1', port: 3000 };
bfj
  .write(path, config)
  .then(() =&gt; {
    console.log('Data has been successfully written to disk');
  })
  .catch((error) =&gt; {
    console.log(error);
  });
</pre>
<p>有许多你可以在文档中读到的功能。它是专门为处理大型 JSON 数据而创建的。它也很慢，所以只有在处理相对较大的 JSON 数据集时才应该使用它。</p>
<h2>结论</h2>
<p>正如上面几节所解释的，JSON 是互联网上最流行的数据交换格式之一。</p>
<p>节点运行时环境有内置的<code>fs</code>模块，您可以使用它来处理一般的文件。<code>fs</code>模块有一些方法，您可以使用回调 API、基于 promise 的 API 或同步 API 来读写 JSON 文件。</p>
<p>因为回调 API 的方法比基于承诺的 API 的方法性能更好，正如文档中所强调的，您最好使用回调 API。</p>
<p>除了内置的<code>fs</code>模块，还有<code>jsonfile</code>、<code>fs-extra</code>、<code>bfj</code>等几个流行的第三方包存在。它们有额外的实用函数，使得处理 JSON 文件变得轻而易举。另一方面，您应该评估向您的应用程序添加第三方包的局限性。</p><div class="code-block code-block-23">
<div class="blog-plug inline-plug node-plug"><h2>200 只<img src="../Images/61167b9d027ca73ed5aaf59a9ec31267.png" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2019/10/green-check.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" class=" jetpack-lazy-image" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/10/green-check.png"/> <noscript> <img data-lazy-fallback="1" src="../Images/61167b9d027ca73ed5aaf59a9ec31267.png" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/10/green-check.png"/> </noscript>显示器出现故障，生产中网络请求缓慢</h2><p>部署基于节点的 web 应用程序或网站是容易的部分。确保您的节点实例继续为您的应用程序提供资源是事情变得更加困难的地方。如果您对确保对后端或第三方服务的请求成功感兴趣，</p><a href="https://lp.logrocket.com/blg/node-signup" target="_blank">try LogRocket</a><p>. </p><a class="signup" href="https://lp.logrocket.com/blg/node-signup" target="_blank" rel="noopener noreferrer"><img src="../Images/cae72fd2a54c5f02a6398c4867894844.png" alt="LogRocket Network Request Monitoring" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2019/12/network-request-filter-2-1.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" class=" jetpack-lazy-image" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/12/network-request-filter-2-1.png"/><noscript><img data-lazy-fallback="1" src="../Images/cae72fd2a54c5f02a6398c4867894844.png" alt="LogRocket Network Request Monitoring" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/12/network-request-filter-2-1.png"/></noscript></a><a href="https://lp.logrocket.com/blg/node-signup" target="_blank" rel="noopener noreferrer">https://logrocket.com/signup/</a><p>LogRocket 就像是网络和移动应用程序的 DVR，记录下用户与你的应用程序交互时发生的一切。您可以汇总并报告有问题的网络请求，以快速了解根本原因，而不是猜测问题发生的原因。</p><p>LogRocket 检测您的应用程序以记录基线性能计时，如页面加载时间、到达第一个字节的时间、慢速网络请求，还记录 Redux、NgRx 和 Vuex 操作/状态。</p><a class="signup" href="https://lp.logrocket.com/blg/node-signup" target="_blank" rel="noopener noreferrer">Start monitoring for free</a><p>. </p></div>
</div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
<html>
<head>
<title>Understanding and using the new CSS style queries - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>理解和使用新的CSS样式查询</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/new-css-style-queries/#0001-01-01">https://blog.logrocket.com/new-css-style-queries/#0001-01-01</a></blockquote><div><article class="article-post">
<p>如果你一直在关注<a href="https://blog.logrocket.com/cascade-layers-subgrid-container-queries-whats-new-css/#" target="_blank" rel="noopener">最新的CSS发展</a>，你可能会对响应式web开发的未来感到非常兴奋。容器查询是CSS中最令人兴奋的新增功能之一，它吸引了大多数前端开发人员的关注。如果你不熟悉容器查询，你可以在上面的链接中阅读。</p>
<p>关于容器查询的很多兴奋之处都集中在容器大小查询上。但是容器查询还有一个更令人兴奋的方面，大多数开发人员都不知道:容器样式查询。在这篇文章中，我们将会看到你需要知道的关于样式查询的一切。</p>
<p>本文假设您至少对一种编程语言有基本的了解，最好是CSS，并且能够使用像<a href="https://www.google.com/chrome/canary/" target="_blank" rel="noopener"> Chrome Canary这样的实验性浏览器。</a></p>
<p>在本文中，我们将讨论:</p>

<p>事不宜迟，让我们言归正传。</p>
<h2 id="what-are-style-queries">什么是样式查询？</h2>
<p>容器查询的工作方式类似于媒体查询，但它们允许您直接基于组件的大小或样式而不是设备的视口来查询组件。如果你想了解更多关于如何根据大小查询容器的信息，请参考上面的链接。大多数开发人员使用容器查询来根据容器的大小查询容器，如下所示:</p>
<pre class="language-css hljs">.card {
  /* query the inline-direction size of this parent */
  container-type: inline-size;
  display :block;
  background: blue;
}

@container (min-width: 600px) {
  .card {
    /* styles to apply when the card container is greater than or equal to 600px */
    display: flex;
    background: green;
  }
}
</pre>
<p>上面的代码根据卡片的大小查询卡片容器，只有当卡片的宽度大于或等于420px时，效果才会改变。</p>
<p>样式查询的工作方式相同，但是它们允许您在查询容器中查询父元素的计算值或样式，然后根据父元素将样式应用到子元素。</p>
<p>更简单地说，您可以使用样式查询根据容器的样式而不仅仅是大小来查询容器。它是这样工作的:</p>
<pre class="language-css hljs">@container style(color: purple) {
      /* styles to apply when the card container has a color of purple */
  .card {
    /* To change the background to green: */
    background: green;
  }
}
</pre>
<p>如果父节的颜色是紫色，上面的代码会将卡片或节的背景更改为绿色。与大小查询不同，在大小查询中，您必须使用<code>container-type</code>标签将元素建立为查询容器，除非另有说明，否则所有元素都被视为样式查询的查询容器。</p>
<p>接下来，我们将看看何时何地使用样式查询。</p>
<h2 id="using-style-queries">何时何地使用CSS样式查询</h2>
<p>CSS样式查询可以查询父容器的不可继承的样式，并将所述样式应用于子容器。CSS中不可继承的样式包括高度、宽度、边框、边距、填充等。为了了解其工作原理，让我们创建一张卡片:</p>
<pre class="language-html hljs">&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;
  &lt;meta charset="UTF-8"&gt;
  &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt;
  &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;
  &lt;title&gt;Document&lt;/title&gt;
  &lt;link rel="stylesheet" href="style.css"&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div class="card"&gt;
      &lt;div class="cardheader"&gt;
        &lt;img src="https://images.unsplash.com/photo-1657664042448-c955b411d9d0?ixlib=rb-1.2.1&amp;ixid=MnwxMjA3fDF8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&amp;auto=format&amp;fit=crop&amp;w=1032&amp;q=80" class="card-img" alt=""&gt;
      &lt;/div&gt;
      &lt;div class="card-body"&gt;
        &lt;h5 class="title"&gt;A card&lt;/h5&gt;
        &lt;p class="text"&gt;Lorem ipsum dolor sit amet consectetur adipisicing elit. Sint facere, neque fugit rem recusandae libero aliquid do&lt;/p&gt;
        &lt;button class="btn"&gt;Get started&lt;/button&gt;
      &lt;/div&gt;
    &lt;/div&gt;


&lt;/body&gt;
&lt;/html&gt;
</pre>
<p>现在，让我们设计卡片的样式:</p>
<pre class="language-html hljs">.card{
    width:400px;
    padding: 20px;
    border-radius: 4px;
    border: solid 3px red;
    background-color: blueviolet;
    border-color: red;
}

.card-header{
    margin: -20px -20px 0 -20px;

}

.card-img{
    width: 100%;
    height: auto;
}

.title {
    font-size: 1.5rem;
    margin-bottom: 0.5rem;
}

.btn{
    border: solid 2px;
    width: 100%;
    padding: 0.75rem 1rem;
    border-radius: 4px;
    background-color: lightblue;
    color: black;
    font-weight: 600;
    cursor: pointer;
    border-color: black;
}

.btn:hover{
    background-color: brown;
}
</pre>
<p>上面的代码看起来会像这样:</p>
<p><img data-attachment-id="127388" data-permalink="https://blog.logrocket.com/new-css-style-queries/attachment/creating-card-using-style-query/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/08/creating-card-using-style-query.jpg" data-orig-size="463,475" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;FIMBER&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;1658109761&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Creating a card using style query" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/08/creating-card-using-style-query-292x300.jpg" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/08/creating-card-using-style-query.jpg" decoding="async" class="aligncenter size-full wp-image-127388 jetpack-lazy-image" src="../Images/a4bbe91da797e40109b03365a5c61a63.png" alt="Creating A Card Using Style Query" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2022/08/creating-card-using-style-query.jpg 463w, https://blog.logrocket.com/wp-content/uploads/2022/08/creating-card-using-style-query-292x300.jpg 292w" data-lazy-sizes="(max-width: 463px) 100vw, 463px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2022/08/creating-card-using-style-query.jpg?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/08/creating-card-using-style-query.jpg"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="127388" data-permalink="https://blog.logrocket.com/new-css-style-queries/attachment/creating-card-using-style-query/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/08/creating-card-using-style-query.jpg" data-orig-size="463,475" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;FIMBER&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;1658109761&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Creating a card using style query" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/08/creating-card-using-style-query-292x300.jpg" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/08/creating-card-using-style-query.jpg" decoding="async" loading="lazy" class="aligncenter size-full wp-image-127388" src="../Images/a4bbe91da797e40109b03365a5c61a63.png" alt="Creating A Card Using Style Query" srcset="https://blog.logrocket.com/wp-content/uploads/2022/08/creating-card-using-style-query.jpg 463w, https://blog.logrocket.com/wp-content/uploads/2022/08/creating-card-using-style-query-292x300.jpg 292w" sizes="(max-width: 463px) 100vw, 463px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/08/creating-card-using-style-query.jpg"/></noscript>
<p>如果我们希望按钮继承卡片的边框颜色，我们将运行以下代码:</p>
<pre class="language-css hljs">@container style(border-color: red) {
  .btn {
    border-color: red;
  }
}
</pre>
<p>结果将如下所示:</p>
<p><img data-attachment-id="127390" data-permalink="https://blog.logrocket.com/new-css-style-queries/attachment/editing-container-style/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/08/editing-container-style.jpg" data-orig-size="470,468" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;FIMBER&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;1658109417&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Editing container style" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/08/editing-container-style-300x300.jpg" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/08/editing-container-style.jpg" decoding="async" class="aligncenter size-full wp-image-127390 jetpack-lazy-image" src="../Images/5beebef4575a4c6d62e891f70ff334ed.png" alt="Editing Container Style" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2022/08/editing-container-style.jpg 470w, https://blog.logrocket.com/wp-content/uploads/2022/08/editing-container-style-300x300.jpg 300w, https://blog.logrocket.com/wp-content/uploads/2022/08/editing-container-style-150x150.jpg?crop=1 150w" data-lazy-sizes="(max-width: 470px) 100vw, 470px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2022/08/editing-container-style.jpg?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/08/editing-container-style.jpg"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="127390" data-permalink="https://blog.logrocket.com/new-css-style-queries/attachment/editing-container-style/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/08/editing-container-style.jpg" data-orig-size="470,468" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;FIMBER&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;1658109417&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Editing container style" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/08/editing-container-style-300x300.jpg" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/08/editing-container-style.jpg" decoding="async" loading="lazy" class="aligncenter size-full wp-image-127390" src="../Images/5beebef4575a4c6d62e891f70ff334ed.png" alt="Editing Container Style" srcset="https://blog.logrocket.com/wp-content/uploads/2022/08/editing-container-style.jpg 470w, https://blog.logrocket.com/wp-content/uploads/2022/08/editing-container-style-300x300.jpg 300w, https://blog.logrocket.com/wp-content/uploads/2022/08/editing-container-style-150x150.jpg?crop=1 150w" sizes="(max-width: 470px) 100vw, 470px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/08/editing-container-style.jpg"/></noscript>
<p>与大小查询不同，样式查询没有固定的用例。当然，它们看起来很酷，是新的，并且让你的代码看起来更好，但是它们目前没有解决任何具体的问题。几乎所有样式查询都可以用类或数据属性来完成。</p>
<p>例如，上述功能可以通过直接定位按钮并将其边框指定为红色，或者通过创建自定义变量并将其添加到按钮样式中来实现。</p>
<p>然而，当与大小查询结合使用时，样式查询可以大放异彩，这实际上只有在使用<a href="https://developer.mozilla.org/en-US/docs/Web/CSS/Using_CSS_custom_properties" target="_blank" rel="noopener">高阶变量</a>(自定义属性)时才有用。这里有一个例子:</p>
<pre class="language-css hljs">@container card (min-width: 600px) and style(--responsive: true) {
  /* styles for responsive components at a minimum width of 600px  */
}
</pre>
<p>将样式查询与大小查询一起使用将允许您应用特定的逻辑，从而产生更灵活的组件拥有的样式。这是一个方便的技巧，如果样式查询最终发布，我们可能会看到它变得流行起来。</p>
<h2 id="issues-style-queries">样式查询的问题</h2>
<p>就目前的情况来看，在发布样式查询之前，还有很多工作要做。样式查询收到了很多beta测试者的负面评论，但是最重要的问题是<a href="https://github.com/w3c/csswg-drafts/issues/7185" target="_blank" rel="noopener">缺乏对非定制CSS属性的特异性</a>。</p>
<p>例如，没有人知道<code>style(width: calc(…))</code>将如何表现，或者样式查询将如何处理像<code>style(color: inherit)</code>这样的简写属性。这些问题可能会导致编码过程中的重大问题，并可能导致开发人员不使用样式查询。</p>
<p>虽然这些问题可能有一些解决方案,但在这些问题得到解决之前，样式查询不太可能与大小查询一起发布，因为容器大小查询仍然保留了许多没有样式查询的功能。</p>
<h2 id="polyfills-style-queries">对于要在非实验性浏览器中使用的样式查询，是否存在聚合填充？</h2>
<p>目前，没有可用于样式查询的聚合填充。针对容器查询的唯一的<a href="https://github.com/GoogleChromeLabs/container-query-polyfill" target="_blank" rel="noopener"> polyfill </a>只涵盖了容器大小查询，但是在撰写本文时，还没有针对容器样式查询做任何事情。</p>
<p>如果你想帮CSS世界一个忙，为样式查询创建一个polyfill，这里有一个<a href="https://philipwalton.com/articles/the-dark-side-of-polyfilling-css/" target="_blank" rel="noopener">指南</a>供你使用。</p>
<h2 id="conclusion">结论</h2>
<p>虽然样式查询可能不是自媒体查询以来响应式web设计的最佳选择，但它们仍然有很大的潜力。如果在发布时所有的问题都解决了，它们对开发人员来说还是很有价值的。</p><div class="code-block code-block-25">
<div class="blog-plug inline-plug css-plug"><h2>你的前端是否占用了用户的CPU？</h2><p>随着web前端变得越来越复杂，资源贪婪的特性对浏览器的要求越来越高。如果您对监控和跟踪生产环境中所有用户的客户端CPU使用、内存使用等感兴趣，</p><a target="_blank" href="https://lp.logrocket.com/blg/css-signup">try LogRocket</a><p>.</p><a class="signup" href="https://lp.logrocket.com/blg/css-signup" target="_blank" rel="noopener noreferrer"><img class="alignnone size-full wp-image-46 jetpack-lazy-image" src="../Images/dacb06c713aec161ffeaffae5bd048cd.png" alt="LogRocket Dashboard Free Trial Banner" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2019/12/cpu-memory-usage.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/12/cpu-memory-usage.png"/><noscript><img data-lazy-fallback="1" class="alignnone size-full wp-image-46" src="../Images/dacb06c713aec161ffeaffae5bd048cd.png" alt="LogRocket Dashboard Free Trial Banner" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/12/cpu-memory-usage.png"/></noscript></a><a href="https://lp.logrocket.com/blg/css-signup" target="_blank" rel="noopener noreferrer">https://logrocket.com/signup/</a><p>LogRocket 就像是网络和移动应用的DVR，记录你的网络应用或网站上发生的一切。您可以汇总和报告关键的前端性能指标，重放用户会话和应用程序状态，记录网络请求，并自动显示所有错误，而不是猜测问题发生的原因。</p><p>现代化您调试web和移动应用的方式— <a class="signup" href="https://lp.logrocket.com/blg/css-signup" target="_blank" rel="noopener noreferrer">开始免费监控</a>。</p></div>
</div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
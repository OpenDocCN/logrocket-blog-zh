<html>
<head>
<title>Generate TypeScript and C# clients with NSwag based on an API - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>基于 API - LogRocket 博客使用 NSwag 生成 TypeScript 和 C#客户端</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/generate-typescript-csharp-clients-nswag-api/#0001-01-01">https://blog.logrocket.com/generate-typescript-csharp-clients-nswag-api/#0001-01-01</a></blockquote><div><article class="article-post">
<p>为 API 生成客户端是减少您在构建项目时必须做的工作量的一个巨大方法。当代码可以通过像<a href="https://github.com/RicoSuter/NSwag"> NSwag </a>这样的工具快速准确地自动生成时，为什么还要手写呢？引用文档:</p>
<blockquote><p>NSwag 项目提供了从现有的 ASP.NET Web API 控制器生成 OpenAPI 规范的工具，以及从这些 OpenAPI 规范生成客户端代码的工具。该项目在一个工具链中结合了 Swashbuckle (OpenAPI/Swagger 生成)和 AutoRest(客户端生成)的功能。</p></blockquote>
<p>有一些很棒的帖子向您展示了如何使用直接来自. NET 项目的<code>nswag.json</code>文件用 NSwag 生成客户端。</p>
<p>但是，如果您想纯粹为了它的客户机生成功能而使用 NSwag，该怎么办呢？您可能有一个用另一种语言/平台编写的 API，它公开了一个 Swagger 端点，您只是希望为它创建一个客户端。你是怎么做到的？</p>
<p>此外，如果您想对正在生成的客户端进行一些特殊的定制，您可能会发现自己很难在<code>nswag.json</code>中进行配置。在这种情况下，可以用一个简单的。NET 控制台应用程序。</p>
<p>为了寻找上述问题的答案，本帖将:</p>
<ul>
<li>创建一个公开 Swagger 端点的. NET API(或者，您可以使用任何其他的 Swagger 端点；<a href="https://blog.logrocket.com/documenting-your-express-api-with-swagger/">例如，Express API </a></li>
<li>创建一个可以从 Swagger 端点创建 TypeScript 和 C#客户端的. NET 控制台应用程序</li>
<li>创建一个脚本，该脚本在运行时创建一个 TypeScript 客户端</li>
<li>在简单的 TypeScript 应用程序中使用生成的客户端来使用 API</li>
</ul>
<p>在继续之前，请注意，您将同时需要<a href="https://nodejs.org/en/"> Node.js </a>和<a href="https://dotnet.microsoft.com/download">。NET SDK </a>安装完毕。</p>
<h2>创建一个 API</h2>
<p>我们现在将创建一个 API 来公开一个<a href="https://swagger.io/resources/open-api/"> Swagger/OpenAPI </a>端点。在我们这样做的同时，我们将创建一个 TypeScript React 应用程序，供我们稍后使用。我们将转到命令行并输入以下命令，这些命令使用。NET SDK、节点和<code>create-react-app</code>包:</p>
<pre class="language-shell hljs">mkdir src
cd src
npx create-react-app client-app --template typescript
mkdir server-app
cd server-app
dotnet new api -o API
cd API
dotnet add package NSwag.AspNetCore</pre>
<p>我们现在有了一个依赖于 NSwag 的. NET API。我们将开始使用它，用以下内容替换已经生成的<code>Startup.cs</code>:</p>
<pre class="language-csharp hljs">using Microsoft.AspNetCore.Builder;
using Microsoft.AspNetCore.Hosting;
using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Hosting;

namespace API
{
    public class Startup
    {
        const string ALLOW_DEVELOPMENT_CORS_ORIGINS_POLICY = "AllowDevelopmentSpecificOrigins";
        const string LOCAL_DEVELOPMENT_URL = "http://localhost:3000";

        public Startup(IConfiguration configuration)
        {
            Configuration = configuration;
        }

        public IConfiguration Configuration { get; }

        // This method gets called by the runtime. Use this method to add services to the container.
        public void ConfigureServices(IServiceCollection services)
        {

            services.AddControllers();

            services.AddCors(options =&gt; {
                options.AddPolicy(name: ALLOW_DEVELOPMENT_CORS_ORIGINS_POLICY,
                    builder =&gt; {
                        builder.WithOrigins(LOCAL_DEVELOPMENT_URL)
                            .AllowAnyMethod()
                            .AllowAnyHeader()
                            .AllowCredentials();
                    });
            });

            // Register the Swagger services
            services.AddSwaggerDocument();
        }

        // This method gets called by the runtime. Use this method to configure the HTTP request pipeline.
        public void Configure (IApplicationBuilder app, IWebHostEnvironment env)
        {
            if (env.IsDevelopment())
            {
                app.UseDeveloperExceptionPage();
            } 
            else
            {
                app.UseExceptionHandler("/Error");
                // The default HSTS value is 30 days. You may want to change this for production scenarios, see https://aka.ms/aspnetcore-hsts.
                app.UseHsts ();
                app.UseHttpsRedirection();
            }

            app.UseDefaultFiles();
            app.UseStaticFiles();

            app.UseRouting();

            app.UseAuthorization();

            // Register the Swagger generator and the Swagger UI middlewares
            app.UseOpenApi();
            app.UseSwaggerUi3();

            if (env.IsDevelopment())
                app.UseCors(ALLOW_DEVELOPMENT_CORS_ORIGINS_POLICY);

            app.UseEndpoints(endpoints =&gt;
            {
                endpoints.MapControllers();
            });
        }
    }
}
</pre>
<p>上述<code>Startup.cs</code>中需要注意的重大变化有:</p>
<ol>
<li>用<code>UseOpenApi</code>和<code>UseSwaggerUi3</code>公开一个 Swagger 端点。NSwag 将在您的应用程序中为所有控制器自动创建 Swagger 端点。的。NET 模板附带了一个<code>WeatherForecastController</code>。</li>
<li>允许<a href="https://docs.microsoft.com/en-us/aspnet/core/security/cors">跨来源请求(CORS) </a>，这在开发过程中很有用(并且将有助于以后的演示)。</li>
</ol>
<p>回到我们项目的根目录，我们将初始化一个 npm 项目。我们将使用它来放置一些方便的<a href="https://docs.npmjs.com/cli/v6/using-npm/scripts"> <code>npm scripts</code> </a>，这将使我们的项目更容易工作。所以我们将<code>npm init</code>并接受所有的默认值。</p>
<p>现在我们要添加一些我们的脚本将会用到的依赖项:<code>npm install cpx cross-env npm-run-all start-server-and-test</code></p>
<p>我们还会给自己的<code>package.json</code>加上一些<code>scripts</code>:</p>
<pre class="language-json hljs">  "scripts": {
    "postinstall": "npm run install:client-app &amp;&amp; npm run install:server-app",
    "install:client-app": "cd src/client-app &amp;&amp; npm install",
    "install:server-app": "cd src/server-app/API &amp;&amp; dotnet restore",
    "build": "npm run build:client-app &amp;&amp; npm run build:server-app",
    "build:client-app": "cd src/client-app &amp;&amp; npm run build",
    "postbuild:client-app": "cpx \"src/client-app/build/**/*.*\" \"src/server-app/API/wwwroot/\"",
    "build:server-app": "cd src/server-app/API &amp;&amp; dotnet build --configuration release",
    "start": "run-p start:client-app start:server-app",
    "start:client-app": "cd src/client-app &amp;&amp; npm start",
    "start:server-app": "cross-env ASPNETCORE_URLS=http://*:5000 ASPNETCORE_ENVIRONMENT=Development dotnet watch --project src/server-app/API run --no-launch-profile"
  }</pre>
<p>让我们看看上面的脚本为我们提供了什么。在我们项目的根中运行<code>npm install</code>不仅会为我们的根<code>package.json</code>安装依赖项。感谢我们的<code>postinstall</code>、<code>install:client-app</code>和<code>install:server-app</code>脚本，它将安装 React 应用程序和。NET 应用程序依赖项。</p>
<p>运行<code>npm run build</code>将构建我们的客户端和服务器应用程序，运行<code>npm run start</code>将启动我们的 React 应用程序和我们的。NET app。我们的 React 应用程序将在<code><a href="http://localhost:3000" rel="nofollow">http://localhost:3000</a></code>启动。我们的。NET app 将在<code><a href="http://localhost:5000" rel="nofollow">http://localhost:5000</a></code>启动(一些环境变量用<a href="https://github.com/kentcdodds/cross-env"> <code>cross-env</code> </a>传递给它)。</p>
<p>一旦运行了<code>npm run start</code>，您将在<code><a href="http://localhost:5000/swagger" rel="nofollow">http://localhost:5000/swagger</a></code>找到一个大摇大摆的端点:</p>
<p><img data-attachment-id="31999" data-permalink="https://blog.logrocket.com/generate-typescript-csharp-clients-nswag-api/swagger-interface-screenshot/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2021/01/swagger-interface-screenshot.png" data-orig-size="730,440" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Screenshot of the Swagger interface" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2021/01/swagger-interface-screenshot-300x181.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2021/01/swagger-interface-screenshot.png" decoding="async" class="aligncenter size-full wp-image-31999 jetpack-lazy-image" src="../Images/6026195f39e0a2d23a3141ee60a9d6a7.png" alt="A Screenshot of the Swagger Interface" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2021/01/swagger-interface-screenshot.png 730w, https://blog.logrocket.com/wp-content/uploads/2021/01/swagger-interface-screenshot-300x181.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2021/01/swagger-interface-screenshot.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2021/01/swagger-interface-screenshot.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="31999" data-permalink="https://blog.logrocket.com/generate-typescript-csharp-clients-nswag-api/swagger-interface-screenshot/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2021/01/swagger-interface-screenshot.png" data-orig-size="730,440" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Screenshot of the Swagger interface" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2021/01/swagger-interface-screenshot-300x181.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2021/01/swagger-interface-screenshot.png" decoding="async" loading="lazy" class="aligncenter size-full wp-image-31999" src="../Images/6026195f39e0a2d23a3141ee60a9d6a7.png" alt="A Screenshot of the Swagger Interface" srcset="https://blog.logrocket.com/wp-content/uploads/2021/01/swagger-interface-screenshot.png 730w, https://blog.logrocket.com/wp-content/uploads/2021/01/swagger-interface-screenshot-300x181.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2021/01/swagger-interface-screenshot.png"/></noscript>
<h2>客户端生成器项目</h2>
<p>既然我们已经搭建了我们的大摇大摆的 API，我们想把控制台应用程序放在一起，它将生成我们的类型化客户端。</p>
<pre class="language-shell hljs">cd src/server-app
dotnet new console -o APIClientGenerator
cd APIClientGenerator
dotnet add package NSwag.CodeGeneration.CSharp
dotnet add package NSwag.CodeGeneration.TypeScript
dotnet add package NSwag.Core</pre>
<p>我们现在有了一个控制台应用程序，它依赖于 NSwag 的代码生成部分。让我们改变一下<code>Program.cs</code>来利用这一点:</p>
<pre class="language-csharp hljs">using System;
using System.IO;
using System.Threading.Tasks;
using NJsonSchema;
using NJsonSchema.CodeGeneration.TypeScript;
using NJsonSchema.Visitors;
using NSwag;
using NSwag.CodeGeneration.CSharp;
using NSwag.CodeGeneration.TypeScript;

namespace APIClientGenerator
{
    class Program
    {
        static async Task Main(string[] args)
        {
            if (args.Length != 3)
                throw new ArgumentException("Expecting 3 arguments: URL, generatePath, language");

            var url = args[0];
            var generatePath = Path.Combine(Directory.GetCurrentDirectory(), args[1]);
            var language = args[2];

            if (language != "TypeScript" &amp;&amp; language != "CSharp")
                throw new ArgumentException("Invalid language parameter; valid values are TypeScript and CSharp");

            if (language == "TypeScript") 
                await GenerateTypeScriptClient(url, generatePath);
            else
                await GenerateCSharpClient(url, generatePath);
        }

        async static Task GenerateTypeScriptClient(string url, string generatePath) =&gt;
            await GenerateClient(
                document: await OpenApiDocument.FromUrlAsync(url),
                generatePath: generatePath,
                generateCode: (OpenApiDocument document) =&gt;
                {
                    var settings = new TypeScriptClientGeneratorSettings();

                    settings.TypeScriptGeneratorSettings.TypeStyle = TypeScriptTypeStyle.Interface;
                    settings.TypeScriptGeneratorSettings.TypeScriptVersion = 3.5M;
                    settings.TypeScriptGeneratorSettings.DateTimeType = TypeScriptDateTimeType.String;

                    var generator = new TypeScriptClientGenerator(document, settings);
                    var code = generator.GenerateFile();

                    return code;
                }
            );

        async static Task GenerateCSharpClient(string url, string generatePath) =&gt;
            await GenerateClient(
                document: await OpenApiDocument.FromUrlAsync(url),
                generatePath: generatePath,
                generateCode: (OpenApiDocument document) =&gt;
                {
                    var settings = new CSharpClientGeneratorSettings
                    {
                        UseBaseUrl = false
                    };

                    var generator = new CSharpClientGenerator(document, settings);
                    var code = generator.GenerateFile();
                    return code;
                }
            );

        private async static Task GenerateClient(OpenApiDocument document, string generatePath, Func&lt;OpenApiDocument, string&gt; generateCode)
        {
            Console.WriteLine($"Generating {generatePath}...");

            var code = generateCode(document);

            await System.IO.File.WriteAllTextAsync(generatePath, code);
        }
    }
}</pre>
<p>我们为自己创造了一个简单的。NET 控制台应用程序，它为给定的 Swagger URL 创建 TypeScript 和 C#客户端。它需要三个参数:</p>
<ul>
<li><code>url</code>–为其生成客户端的<code>swagger.json</code>文件的 URL</li>
<li><code>generatePath</code>–生成的客户端文件应放置的路径，相对于此项目</li>
<li><code>language</code>–客户端生成的语言；有效值为“TypeScript”和“CSharp”</li>
</ul>
<p>要用它创建一个 TypeScript 客户机，我们可以使用下面的命令:</p>
<pre class="language-shell hljs">dotnet run --project src/server-app/APIClientGenerator http://localhost:5000/swagger/v1/swagger.json src/client-app/src/clients.ts TypeScript</pre>
<p>然而，为了成功运行，我们首先必须确保 API 正在运行。如果我们有一个可以运行的命令，那就太好了:</p>
<ul>
<li>调出 API</li>
<li>生成客户端</li>
<li>关闭 API</li>
</ul>
<p>让我们做那个。</p>
<h2 id="buildingamakeaclientscript">构建“创建客户端”脚本</h2>
<p>在项目的根目录中，我们将添加下面的<code>scripts</code>:</p>
<pre class="language-json hljs">    "generate-client:server-app": "start-server-and-test generate-client:server-app:serve http-get://localhost:5000/swagger/v1/swagger.json generate-client:server-app:generate",
    "generate-client:server-app:serve": "cross-env ASPNETCORE_URLS=http://*:5000 ASPNETCORE_ENVIRONMENT=Development dotnet run --project src/server-app/API --no-launch-profile",
    "generate-client:server-app:generate": "dotnet run --project src/server-app/APIClientGenerator http://localhost:5000/swagger/v1/swagger.json src/client-app/src/clients.ts TypeScript",</pre>
<p>让我们看看这里发生了什么。运行<code>npm run generate-client:server-app</code>将使用<code><a href="https://github.com/bahmutov/start-server-and-test">start-server-and-test</a></code>包通过运行<code>generate-client:server-app:serve</code>脚本来加速我们的<code>server-app</code>。</p>
<p><code>start-server-and-test</code>等待 Swagger 端点开始响应请求。当它开始响应时，<code>start-server-and-test</code>运行<code>generate-client:server-app:generate</code>脚本，该脚本运行我们的 APIClientGenerator 控制台应用程序，并向它提供可以找到我们的 Swagger 的 URL、要生成的文件的路径以及“类型脚本”的语言</p>
<p>如果你想生成一个 C#客户端——比方说，如果你正在<a href="https://blog.logrocket.com/js-free-frontends-blazor/">编写一个 Blazor 应用程序</a>——那么你可以如下修改<code>generate-client:server-app:generate</code>脚本:</p>
<pre class="language-json hljs">   "generate-client:server-app:generate": "dotnet run --project src/server-app/ApiClientGenerator http://localhost:5000/swagger/v1/swagger.json clients.cs CSharp",</pre>
<h2 id="consumeourgeneratedapiclient">消费我们生成的 API 客户端</h2>
<p>让我们运行<code>npm run generate-client:server-app</code>命令。它创建了一个<code>clients.ts</code>文件，这个文件很好地放在我们的<code>client-app</code>中。我们一会儿会练习一下。</p>
<p>首先，让我们按照<a href="https://create-react-app.dev/docs/proxying-api-requests-in-development/"> create-react-app 文档</a>中的说明启用从我们的<code>client-app</code>到我们的<code>server-app</code>的代理，并将以下内容添加到我们的<code>client-app/package.json</code>:</p>
<pre class="language-json hljs">  "proxy": "http://localhost:5000"</pre>
<p>现在让我们用<code>npm run start</code>启动我们的应用程序。然后我们将把<code>App.tsx</code>的内容替换为:</p>
<pre class="language-typescript hljs">import React from "react";
import "./App.css";
import { WeatherForecast, WeatherForecastClient } from "./clients";

function App() {
  const [weather, setWeather] = React.useState&lt;WeatherForecast[] | null&gt;();
  React.useEffect(() =&gt; {
    async function loadWeather() {
      const weatherClient = new WeatherForecastClient(/* baseUrl */ "");
      const forecast = await weatherClient.get();
      setWeather(forecast);
    }
    loadWeather();
  }, [setWeather]);

  return (
    &lt;div className="App"&gt;
      &lt;header className="App-header"&gt;
        {weather ? (
          &lt;table&gt;
            &lt;thead&gt;
              &lt;tr&gt;
                &lt;th&gt;Date&lt;/th&gt;
                &lt;th&gt;Summary&lt;/th&gt;
                &lt;th&gt;Centigrade&lt;/th&gt;
                &lt;th&gt;Fahrenheit&lt;/th&gt;
              &lt;/tr&gt;
            &lt;/thead&gt;
            &lt;tbody&gt;
              {weather.map(({ date, summary, temperatureC, temperatureF }) =&gt; (
                &lt;tr key={date}&gt;
                  &lt;td&gt;{new Date(date).toLocaleDateString()}&lt;/td&gt;
                  &lt;td&gt;{summary}&lt;/td&gt;
                  &lt;td&gt;{temperatureC}&lt;/td&gt;
                  &lt;td&gt;{temperatureF}&lt;/td&gt;
                &lt;/tr&gt;
              ))}
            &lt;/tbody&gt;
          &lt;/table&gt;
        ) : (
          &lt;p&gt;Loading weather...&lt;/p&gt;
        )}
      &lt;/header&gt;
    &lt;/div&gt;
  );
}

export default App;</pre>
<p>在上面的<code>React.useEffect</code>中，您可以看到我们创建了自动生成的<code>WeatherForecastClient</code>的一个新实例。然后我们调用<code>weatherClient.get()</code>，它向服务器发送<code>GET</code>请求以获取数据，并以强类型的方式提供数据(<code>get()</code>返回一个数组<code>WeatherForecast</code>)。页面上显示如下:</p>
<p><img data-attachment-id="31998" data-permalink="https://blog.logrocket.com/generate-typescript-csharp-clients-nswag-api/use-generated-client/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2021/01/use-generated-client.gif" data-orig-size="730,431" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Loading data from the server" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2021/01/use-generated-client-300x177.gif" data-large-file="https://blog.logrocket.com/wp-content/uploads/2021/01/use-generated-client.gif" decoding="async" class="aligncenter size-full wp-image-31998 jetpack-lazy-image" src="../Images/c83c99028e54553bc4e6c2c50a538b38.png" alt="Loading Data from the Server" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2021/01/use-generated-client.gif?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2021/01/use-generated-client.gif"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="31998" data-permalink="https://blog.logrocket.com/generate-typescript-csharp-clients-nswag-api/use-generated-client/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2021/01/use-generated-client.gif" data-orig-size="730,431" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Loading data from the server" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2021/01/use-generated-client-300x177.gif" data-large-file="https://blog.logrocket.com/wp-content/uploads/2021/01/use-generated-client.gif" decoding="async" loading="lazy" class="aligncenter size-full wp-image-31998" src="../Images/c83c99028e54553bc4e6c2c50a538b38.png" alt="Loading Data from the Server" data-original-src="https://blog.logrocket.com/wp-content/uploads/2021/01/use-generated-client.gif"/></noscript>
<p>如您所见，我们正在使用自动生成的客户端从服务器加载数据。我们正在减少我们必须编写的代码量<em>和</em>我们正在减少出错的可能性。</p><div class="code-block code-block-21">
<div class="blog-plug inline-plug typescript-plug"><h2><a class="signup" href="https://lp.logrocket.com/blg/typescript-signup" target="_blank" rel="noopener noreferrer"> LogRocket </a>:全面了解您的网络和移动应用</h2>
<a href="https://lp.logrocket.com/blg/typescript-signup" class="signup" target="_blank" rel="noopener noreferrer"><img class="alignnone size-full wp-image-46 jetpack-lazy-image" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/><noscript><img data-lazy-fallback="1" class="alignnone size-full wp-image-46" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/></noscript></a>
<p>LogRocket 是一个前端应用程序监控解决方案，可以让您回放问题，就像问题发生在您自己的浏览器中一样。LogRocket 不需要猜测错误发生的原因，也不需要向用户询问截图和日志转储，而是让您重放会话以快速了解哪里出错了。它可以与任何应用程序完美配合，不管是什么框架，并且有插件可以记录来自 Redux、Vuex 和@ngrx/store 的额外上下文。</p>
<p>除了记录 Redux 操作和状态，LogRocket 还记录控制台日志、JavaScript 错误、堆栈跟踪、带有头+正文的网络请求/响应、浏览器元数据和自定义日志。它还使用 DOM 来记录页面上的 HTML 和 CSS，甚至为最复杂的单页面和移动应用程序重新创建像素级完美视频。</p>
<a class="signup" href="https://lp.logrocket.com/blg/typescript-signup" target="_blank" rel="noopener noreferrer">Try it for free</a><p>.</p></div>
</div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
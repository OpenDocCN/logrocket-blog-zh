<html>
<head>
<title>How to write a declarative JavaScript promise wrapper - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>如何写一个声明性的 JavaScript promise wrapper-log rocket 博客</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/write-declarative-javascript-promise-wrapper/#0001-01-01">https://blog.logrocket.com/write-declarative-javascript-promise-wrapper/#0001-01-01</a></blockquote><div><article class="article-post">
<p>JavaScript 是单线程编程语言，这意味着它只能同步执行代码，或者一次从上到下执行一行代码。然而，<a href="https://blog.logrocket.com/understanding-asynchronous-javascript/" target="_blank" rel="noopener">异步编程</a>被引入来解决这个问题。</p>
<p>这个核心 JavaScript 概念使一个函数能够在等待其他函数完成执行的同时执行。我们使用异步函数对后端进行 API 调用。我们还使用它们来读写文件或数据库。这个概念对于服务器端开发人员和客户端开发人员来说都很方便。</p>
<p>在本指南中，我们将演示如何用 JavaScript 编写声明性异步函数调用。我们还将展示它如何有助于使我们的代码更具可读性和更易于维护。</p>
<p><em>向前跳转:</em></p>

<h2 id="declarative-programming">声明式编程</h2>
<p>在深入研究代码之前，让我们回顾一下声明式编程模式。</p>
<p>声明式编程是一种编程范式，它通常显示代码的逻辑，但不显示实现逻辑的步骤。对于这种类型的编程，通常看不出幕后发生了什么。</p>
<p>相反，命令式编程需要编写一步一步的代码，每一步都有详细的解释。这可以为将来可能需要处理代码的开发人员提供有用的背景知识，但是这会导致代码非常长。命令式编程通常是不必要的；这取决于我们的目标。</p>
<p>使用内置的 JavaScript 方法可以实现声明性编程。声明式编程允许我们编写可读性更强的代码，因此也更容易理解。</p>
<p>例如，使用声明式编程，我们不需要使用<code>for</code>循环来迭代数组。相反，我们可以简单地使用内置的数组方法，比如<code>map()</code>、<code>reduce()</code>和<code>forEach()</code>。</p>
<p>下面是一个命令式编程示例，展示了一个使用递减<code>for</code>循环反转字符串的函数:</p>
<pre class="language-javascript hljs">const reverseString = (str) =&gt; {
    let reversedString = "";

    for (var i = str.length - 1; i &gt;= 0; i--) { 
        reversedString += str[i];
    }
    return reversedString; 
}
</pre>
<p>但是，当我们只用两行代码就可以实现相同的解决方案时，为什么要写十行代码呢？</p>
<p>下面是相同代码的声明式编程版本，使用 JavaScript 内置数组方法:</p>
<pre class="language-javascript hljs">const reverseString = (str) =&gt; {
  return str.split("").reverse().join("");  
} 
</pre>
<p>这个代码片段使用两行代码来反转一个字符串。它非常简短，开门见山。</p>
<h2 id="what-is-promise-in-javascript">JavaScript 中的承诺是什么？</h2>
<p>一个<a href="https://blog.logrocket.com/understanding-promise-all-in-javascript/" target="_blank" rel="noopener">承诺</a>是一个 JavaScript 对象，包含一个异步函数的结果。换句话说，它表示异步函数中已经完成或失败的任务。</p>
<pre class="language-javascript hljs">const promise = new Promise (function (resolve, reject) {
    // code to execute
})
</pre>
<p><code>promise</code>构造函数接受一个参数，一个回调函数，也称为 executor。执行器函数接受两个回调函数:<code>resolve</code>和<code>reject</code>。如果 executor 函数成功执行，则调用<code>resolve()</code>方法，并且<code>promise</code>状态从待定变为已完成。如果 executor 函数失败，那么调用<code>reject()</code>方法，并且<code>promise</code>状态从 pending 变为 failed。</p>
<p>要访问解析的值，使用<code>.then ()</code>方法链接<code>promise</code>，如下所示:</p>
<pre class="language-javascript hljs">promise.then(resolvedData =&gt; {
  // do something with the resolved value
})
</pre>
<p>类似地，在拒绝值的情况下，使用<code>.catch()</code>方法:</p>
<pre class="language-javascript hljs">promise.then(resolvedData =&gt; {
  // do something with the resolved value
}).catch(err =&gt; {
  // handle the rejected value
})
</pre>
<h2 id="async-await-syntax"><code>async/await</code>语法</h2>
<p>当我们有几个嵌套的回调函数或<code>.then</code>函数时，维护代码及其可读性通常会变得很困难。</p>
<p>关键字<code>async</code>帮助我们在 JavaScript 中定义处理异步操作的函数。同时，<code>await</code>关键字用于指示 JavaScript 引擎在返回结果之前等待函数完成。</p>
<p>语法只是围绕承诺的语法糖。它帮助我们实现更清晰、更易于维护的代码。</p>
<pre class="language-javascript hljs">const getUsers = async () =&gt; {
  const res = await fetch('https://jsonplaceholder.typicode.com/users');
  const data = await res.json();
  return data;
}
</pre>
<p>使承诺或异步功能以同步方式执行。然而，用一个<code>try...catch</code>块包装<code>await</code>关键字以避免意外错误总是一个好的做法。</p>
<p>这里有一个例子，我们在一个<code>try...catch</code>块中包装了<code>await</code>关键字和<code>getUsers()</code>函数，就像这样:</p>
<pre class="language-javascript hljs">const onLoad = async () =&gt; {
  try {
    const users = await getUsers();
    // do something with the users
  } catch (err) {
    console.log(err)
    // handle the error
  }
}
</pre>
<h2 id="custom-promise-wrapper">自定义<code>promise</code>包装</h2>
<p><code>async/await</code>在现代 JavaScript 中是一个如此棒的特性的原因之一是它帮助我们避免了回调地狱。</p>
<p>尽管如此，处理来自多个<code>async</code>函数的错误可能会导致这样的结果:</p>
<pre class="language-javascript hljs">try {
  const a = await asyncFuncOne();
} catch (errA) {
  // handle error
}

try {
  const b = await asyncFunctionTwo();
} catch (errB) {
  // handle error
}

try {
  const c = await asyncFunctionThree();
} catch (errC) {
  // handle error
}
</pre>
<p>如果我们在一个<code>try</code>块中添加所有的<code>async</code>函数，我们将在<code>catch</code>块中编写多个<code>if</code>条件，因为我们的<code>catch</code>块现在更通用了:</p>
<pre class="language-javascript hljs">try {
  const a = await asyncFuncOne();
  const b = await asyncFunctionTwo();
  const c = await asyncFunctionThree();
} catch (err) {
  if(err.message.includes('A')) {
    // handle error for asyncFuncOne
  }
  if(err.message.includes('B')) {
    // handle error for asyncFunctionTwo
  }
  if(err.message.includes('C')) {
    // handle error for asyncFunctionThree
  }
}
</pre>
<p>这使得代码可读性更差，更难维护，即使使用<code>async/await</code>语法也是如此。</p>
<p>为了解决这个问题，我们可以写一个效用函数来包装承诺，避免重复的<code>try...catch</code>块。</p>
<p>效用函数将接受一个承诺作为参数，在内部处理错误，并返回一个包含两个元素的数组:解析值和拒绝值。</p>
<p>该函数将解析承诺并返回数组第一个元素中的数据。错误将在数组的第二个元素中返回。如果承诺被解决，第二个元素将作为<code>null</code>返回。</p><div class="code-block code-block-54">
<hr/>
<h3>更多来自 LogRocket 的精彩文章:</h3>

<hr/></div>
<pre class="language-javascript hljs">const promiser = async (promise) =&gt; {
  try {
    const data = await promise;
    return [data, null]
  } catch (err){
    return [null, error]
  }
}
</pre>
<p>我们可以进一步重构上面的代码，通过使用<code>.then()</code>和<code>.catch()</code>处理程序方法返回<code>promise</code>来移除<code>try...catch</code>块:</p>
<pre class="language-javascript hljs">const promiser = (promise) =&gt; {
  return promise.then((data) =&gt; [data, null]).catch((error) =&gt; [null, error]);
};
</pre>
<p>我们可以在下面看到实用程序的用法:</p>
<pre class="language-javascript hljs">const demoPromise = new Promise((resolve, reject) =&gt; {
  setTimeout(() =&gt; {
    // resolve("Yaa!!");
    reject("Naahh!!");
  }, 5000);
});

const runApp = async () =&gt; {
  const [data, error] = await promiser(demoPromise);
  if (error) {
    console.log(error);
    return;
  }
  // do something with the data
};

runApp();
</pre>
<p>现在，让我们来看一个真实的用例。下面，<code>generateShortLink</code>函数使用 URL shortener 服务来缩短一个完整长度的 URL。</p>
<p>这里，<code>axios.get()</code>方法由<code>promiser()</code>函数包装，以返回来自 URL shortener 服务的响应。</p>
<pre class="language-javascript hljs">import promiser from "./promise-wrapper";
import axios from "axios";

const generateShortLink = async (longUrl) =&gt; {
  const [response, error] = await promiser(
    axios.get(`https://api.1pt.co/addURL?long=${longUrl}`)
  );

  if (error) return null;

  return `https://1pt.co/${response.data.short}`;
};
</pre>
<p>为了比较，下面是没有<code>promiser()</code>包装函数的情况:</p>
<pre class="language-javascript hljs">const generateShortLink = async (longUrl) =&gt; {
  try {
    const response = await axios.get(
      `https://api.1pt.co/addURL?long=${longUrl}`
    );
    return `https://1pt.co/${response.data.short}`;
  } catch (err) {
    return null;
  }
};
</pre>
<p>现在，让我们通过创建一个使用<code>generateShortLink()</code>方法的表单来完成这个例子:</p>
<pre class="language-javascript hljs">const form = document.getElementById("shortLinkGenerator");

const longUrlField = document.getElementById("longUrl");

const result = document.getElementById("result");

form.addEventListener("submit", async (e) =&gt; {
  e.preventDefault();
  const longUrl = longUrlField.value;
  const shortLink = await generateShortLink(longUrl);
  if (!shortLink) result.innerText = "Could not generate short link";
  else result.innerHTML = `&lt;a href="${shortLink}"&gt;${shortLink}&lt;/a&gt;`;
});


&lt;!-- HTML --&gt;
&lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;title&gt;Demo&lt;/title&gt;
    &lt;meta charset="UTF-8" /&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;div id="app"&gt;
      &lt;form id="shortLinkGenerator"&gt;
        &lt;input type="url" id="longUrl" /&gt;
        &lt;button&gt;Generate Short Link&lt;/button&gt;
      &lt;/form&gt;
      &lt;div id="result"&gt;&lt;/div&gt;
    &lt;/div&gt;
    &lt;script src="src/index.js"&gt;&lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;
</pre>
<p>下面是<a href="https://codesandbox.io/s/great-pare-lmr09j?file=/src/index.js" target="_blank" rel="noopener">完整代码和演示</a>供大家参考。</p>
<p>到目前为止，<code>promiser()</code>函数只能包装一个<code>async</code>函数。然而，大多数用例会要求它处理多个独立的<code>async</code>功能。</p>
<p>为了处理许多承诺，我们可以使用<code>Promise.all()</code>方法，并将一组<code>async</code>函数传递给<code>promiser</code>函数:</p>
<pre class="language-javascript hljs">const promiser = (promise) =&gt; {
  if (Array.isArray(promise)) promise = Promise.all(promise);
  return promise.then((data) =&gt; [data, null]).catch((error) =&gt; [null, error]);
};
</pre>
<p>下面是一个与多个<code>async</code>函数一起使用的<code>promiser()</code>函数的例子:</p>
<pre class="language-javascript hljs">import axios from "axios";
import promiser from "./promiser";

const categories = ["science", "sports", "entertainment"];

const requests = categories.map((category) =&gt;
  axios.get(`https://inshortsapi.vercel.app/news?category=${category}`)
);

const runApp = async () =&gt; {
  const [data, error] = await promiser(requests);
  if (error) {
    console.error(error?.response?.data);
    return;
  }
  console.log(data);
};

runApp();
</pre>
<h2 id="promise-all-vs-promise-allsettled"><code>Promise.all()</code>对<code>Promise.allSettled()</code></h2>
<p>这可能是澄清关于两个方法的任何混淆的好时机:<code>Promise.all()</code>和<code>Promise.allSettled()</code>。</p>
<p>只有当所有给定的承诺都兑现时才会解决。如果任何一个承诺被拒绝，<code>Promise.all()</code>将作为一个整体拒绝，这在任务相互依赖的情况下非常有用，如果一个任务失败，您希望停止一系列功能。</p>
<p>要处理多个承诺，还可以使用<code>Promise.allSettled()</code>方法。</p>
<p><code>Promise.allSettled()</code>用于多个互不依赖的异步任务。<code>Promise.allSettled()</code>不拒绝；相反，它等待所有承诺完成并返回，不管它们是否成功。<code>Promise.allSettled()</code>一旦所有给定的承诺完成，包括完成的和拒绝的实例，就将自己标记为完成。</p>
<pre class="language-javascript hljs">Promise.allSettled([
  Promise.resolve(39),
  Promise.reject("An error occurred"),
  new Promise(resolve =&gt; setTimeout(() =&gt; resolve(100), 2000)),
  70
]).then(v =&gt; console.log(v))
</pre>
<p>如下所示，<code>Promise.allSettled()</code>方法返回一个对象数组，该数组指定每个承诺的状态及其解析值或拒绝的错误消息。</p>
<pre class="language-javascript hljs">[{
  status: "fulfilled",
  value: 39
}, {
  reason: "An error occurred",
  status: "rejected"
}, {
  status: "fulfilled",
  value: 100
}, {
  status: "fulfilled",
  value: 70
}]
</pre>
<p>下面是一个用于<code>Promise.allSettled()</code>的包装函数，它将只返回解析的值，并且在拒绝承诺的情况下将返回 null。</p>
<pre class="language-javascript hljs">const settler = (promise) =&gt; {
  if (Array.isArray(promise)) {
    return Promise.allSettled(promise).then(settledPromises =&gt; settledPromises.map((settledPromise) =&gt;
      (settledPromise.status === 'fulfilled') ? settledPromise.value : null
    ))
  }
  return promise.then((data) =&gt; data).catch((error) =&gt; null);
};


settler([
  Promise.resolve(39),
  Promise.reject("An error occurred"),
  new Promise(resolve =&gt; setTimeout(() =&gt; resolve(100), 3000)),
  70
]).then(v =&gt; console.log(v))

// [39, null, 100, 70]
</pre>
<p>那么应该用哪种方法呢？这取决于你的需求。如果你想让你的职能继续下去，即使有些承诺被拒绝，那么<code>Promise.allSettled()</code>就是你要走的路。但是如果你需要实现所有的承诺来让你的功能按预期工作，你应该选择<code>Promise.all()</code>。</p>
<h2 id="conclusion">结论</h2>
<p>本指南中分享的用 JavaScript 编写声明性异步函数调用的解决方案对于大多数场景都是理想的。但是，您可能需要考虑一些额外的用例。例如，您可能只想处理预期的错误，并抛出在 promise 执行期间发生的任何异常错误。</p>
<p>任何方法都有利弊。对于您的特定用例，理解并考虑它们是很重要的。</p>
<p>在继续您的编码之旅时，本文中分享的知识是创建更复杂的 API 和实用函数的一个很好的切入点。祝你好运，编码快乐！</p><div class="code-block code-block-27">
<div class="blog-plug inline-plug vanilla-javascript-cta"><h2>通过理解上下文，更容易地调试 JavaScript 错误</h2>
<p>调试代码总是一项单调乏味的任务。但是你越了解自己的错误，就越容易改正。</p>
<p>LogRocket 让你以新的独特的方式理解这些错误。我们的前端监控解决方案跟踪用户与您的 JavaScript 前端的互动，让您能够准确找出导致错误的用户行为。</p>
<a href="https://lp.logrocket.com/blg/javascript-signup" class="signup" target="_blank" rel="noopener noreferrer"><img class="alignnone size-full wp-image-46 jetpack-lazy-image" src="../Images/cbfed9be3defcb505e662574769a7636.png" alt="LogRocket Dashboard Free Trial Banner" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2020/06/reproduce-javascript-errors.gif?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/06/reproduce-javascript-errors.gif"/><noscript><img data-lazy-fallback="1" class="alignnone size-full wp-image-46" src="../Images/cbfed9be3defcb505e662574769a7636.png" alt="LogRocket Dashboard Free Trial Banner" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/06/reproduce-javascript-errors.gif"/></noscript></a>
<p>LogRocket 记录控制台日志、页面加载时间、堆栈跟踪、慢速网络请求/响应(带有标题+正文)、浏览器元数据和自定义日志。理解您的 JavaScript 代码的影响从来没有这么简单过！</p>
<a class="signup" href="https://lp.logrocket.com/blg/javascript-signup" target="_blank" rel="noopener noreferrer">Try it for free</a><p>.</p></div>


</div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
<html>
<head>
<title>Building a full-stack app with Bud and Go - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>使用Bud和Go - LogRocket博客构建全栈应用</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/full-stack-bud-go/#0001-01-01">https://blog.logrocket.com/full-stack-bud-go/#0001-01-01</a></blockquote><div><article class="article-post">
<p>全栈框架有许多形状和大小，但它们通常有两种通用模型。第一个模型包括像<a href="https://rubyonrails.org/" target="_blank" rel="noopener"> Ruby on Rails </a>和<a href="https://laravel.com/" target="_blank" rel="noopener"> Laravel </a>这样的框架，它们以后端为中心，具有帮助你在同一个项目中构建前端的特性，以及易于使用的约定和模板。然后是第二个模型，包括<a href="https://nextjs.org/" target="_blank" rel="noopener"> Next.js </a>、<a href="https://nuxtjs.org/" target="_blank" rel="noopener"> Nuxt.js </a>和<a href="https://kit.svelte.dev/" target="_blank" rel="noopener"> SvelteKit </a>，它们更加以前端为中心，但允许您在同一个项目中创建无服务器的函数作为后端。</p>
<p>新的Go框架<a href="https://denim-cub-301.notion.site/Hey-Bud-4d81622cc49942f9917c5033e5205c69" target="_blank" rel="noopener"> Bud </a>与这些全栈框架不同，它有一个框架，开始时非常简洁，但允许前端和后端代码根据用户的需求进行扩展，而不是扩展出一个复杂的CLI，其中可能包含不必要的文件和配置。Bud是一个框架，它使事情变得简单，但可以在需要时扩展。</p>
<p>Bud内置了前端开发Svelte的功能，后端使用Go，使用更快的工具集来开发web堆栈的各个部分。让我们测试一下Bud，并创建一个调用一些后端端点的页面。</p>
<p>在这篇文章中:</p>

<h2 id="setting-up-bud-framework">建立Bud框架</h2>
<p>先决条件:</p>
<ul>
<li>Curl安装在您的终端环境中</li>
<li>Go v1.6以上版本</li>
<li>节点. js</li>
</ul>
<p>要安装Bud，运行以下命令:<br/> <code>curl -sf <a href="https://raw.githubusercontent.com/livebud/bud/main/install.sh" rel="nofollow">https://raw.githubusercontent.com/livebud/bud/main/install.sh</a> | sh</code></p>
<p>使用命令<code>bud -h</code>确认一切正常。然后，用<code>bud create first-app</code>新建一个app。</p>
<p>这会给你一个模块名。Go中模块名称的标准是您将它推到的存储库的名称，比如<code>github.com/username/repo-name</code>。让我们将目录更改到新的应用程序文件夹中，<code>cd first-app</code>。</p>
<p>运行<code>npm install</code>安装所有依赖项。</p>
<p>要运行开发服务器，运行命令<code>bud run</code>，服务器应该允许您的web应用程序在<code>localhost:3000</code>可见。</p>
<h2 id="bud-folder-structure">芽文件夹结构</h2>
<p>检查项目时，您会看到以下结构:</p>
<pre class="language-bash hljs">/first-app
├─ /bud 
├─ /node_modules 
├─ .gitignore
├─ go.mod
├─ go.sum
├─ package.json
└─ package.lock.json
</pre>
<p>每当你运行<code>bud run</code>的时候，框架就会查看你的代码，在这个文件夹里生成必要的Go app，你就不需要去碰这个文件夹里的文件了。当您准备好部署应用程序时，运行<code>bud build</code>，这将把所有东西打包到<code>/bud/app</code>文件夹中的一个二进制文件中。</p>
<p>可以添加以下目录，这些目录将被框架识别:</p>
<ul>
<li>这个文件夹将包含代表你的应用程序的后端路径的控制器文件。每个文件都可以通过文件名为端点提供标准的CRUD路由</li>
<li><code>view</code>:该文件夹可以包含细长的文件，并会根据文件名自动生成路径</li>
<li><code>public</code>:托管静态资产，如图像和CSS文件</li>
<li>这个目录将被忽略，所以它是一个存放特定于应用程序的代码的好地方，这些代码不应该被视为后端或前端路径</li>
</ul>
<h2 id="creating-root-page">在Bud中创建根页面</h2>
<p>虽然我们的页面是用Svelte定义的，但是我们应该总是为页面准备一个相应的控制器。让我们首先创建一个<code>controller</code>文件夹，并在该文件夹中创建一个名为<code>controller.go</code>的文件。这将处理端点<code>/</code>。</p>
<p>对于所有其他控制器，您将创建一个文件夹，其中包含一个名称相似的Go文件。</p>
<p>例如，端点<code>/posts</code>将是<code>/controller/posts/posts.go</code>，等等。</p>
<p>在每个文件中，我们应该声明一个<code>Controller</code>结构，然后定义将这个结构作为接收方的方法。下面是我们根路由的<code>controller.go</code>的样子:</p>
<pre class="language-go hljs">package Controller
// Controller Struct to house all Action methods
type Controller struct {}
// Index shows a list of users
// Will automatically render view/index.svelte
// GET /users
func (c *Controller) Index() {}
</pre>
<p>方法触发器的名字就是RESTful约定的名字，我们不需要输入所有的代码。这里，<code>index</code>方法将从我们的<code>view</code>文件夹中名为<code>index.svelte</code>的文件中返回一个视图。</p>
<p>视图基本上是通过基于文件的路由来完成的，如果您曾经使用过Next、Nuxt或SvelteKit，您会很熟悉这一点。因为Bud用的是Svelte，<code>index.svelte</code>应该代表你的主页面。因此，在您的项目中创建一个<code>view</code>文件夹，并在其中用下面的代码创建<code>index.svelte</code>。</p>
<pre class="language-html hljs">&lt;div&gt;
    &lt;h1&gt;Here is the Main page of your app&lt;/h1&gt;
    &lt;section&gt;
        &lt;button on:click={handleClick}&gt;Click This&lt;/button&gt;
    &lt;/section&gt;
&lt;/div&gt;
&lt;script&gt;
    const handleClick = (event) =&gt; {
        alert("You Clicked the button")
    }
&lt;/script&gt;
&lt;style&gt;
    h1, section {
        text-align: center;
    }
    button {
        border: none;
        padding: 10px;
        font-size: 1em;
        background-color: brown;
        color: white;
        border-radius: 40px;
    }
&lt;/style&gt;
</pre>
<p>现在，如果我们运行我们的Bud服务器并前往<code>localhost:3000</code>，我们将看到我们的页面在运行。现在，Bud可以在任何控制器中处理以下操作:</p>
<table>
<thead>
<tr>
<th>行动方法</th>
<th>HTTP方法</th>
<th>统一资源定位器</th>
<th>呈现的模板</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>index</code></td>
<td>得到</td>
<td>/端点</td>
<td><code>/view/endpoint/index.svelte</code></td>
</tr>
<tr>
<td><code>show</code></td>
<td>得到</td>
<td>/endpoint/:id</td>
<td><code>/view/endpoint/show.svelte</code></td>
</tr>
<tr>
<td><code>new</code></td>
<td>得到</td>
<td>/端点/新建</td>
<td><code>/view/endpoint/new.svelte</code></td>
</tr>
<tr>
<td><code>create</code></td>
<td>邮政</td>
<td>/端点</td>
<td>没有模板</td>
</tr>
<tr>
<td><code>edit</code></td>
<td>得到</td>
<td>/endpoint/:id/edit</td>
<td><code>/view/endpoint/edit.svelte</code></td>
</tr>
<tr>
<td><code>update</code></td>
<td>放</td>
<td>/endpoint/:id</td>
<td>没有模板</td>
</tr>
<tr>
<td><code>delete</code></td>
<td>删除</td>
<td>/endpoint/:id</td>
<td>没有模板</td>
</tr>
</tbody>
</table>
<h2 id="delivering-data-view">向您的视图交付数据</h2>
<p>呈现视图的方法的返回值将作为道具传递给Svelte模板:</p>
<ul>
<li>如果动作返回一个结构，比如一个<code>Dog</code>结构，它将作为一个名为<code>dog</code>的属性被传递</li>
<li>如果动作返回一个<code>Dog</code>结构的数组，那么这个属性就叫做<code>dogs</code></li>
<li>如果动作返回指定的返回值，那么每个返回值都是匹配名称的属性</li>
</ul>
<p>让我们给我们的根视图发送一些道具并更新<code>controller/controller.go</code>:</p>
<pre class="language-go hljs">package controller
// Controller Struct to house all Action methods
type Controller struct {}
// Define a Struct of data to send to template
type Alex struct {
    Name string
    Age int
}
// Index shows a list of users
// Will automatically render view/index.svelte
// Define our struct as the return value and return it
// GET /users
func (c *Controller) Index() Alex {
    return Alex{"Alex Merced", 37}
}
</pre>
<p>现在，让我们更新我们的视图来引入道具，并在我们单击按钮时使用它。相应地更新<code>view/index.svelte</code>:</p>
<pre class="language-html hljs">&lt;div&gt;
    &lt;h1&gt;Here is the Main page of your app&lt;/h1&gt;
    &lt;section&gt;
        &lt;button on:click={handleClick}&gt;Click This&lt;/button&gt;
    &lt;/section&gt;
&lt;/div&gt;
&lt;script&gt;
    export let alex;
    const handleClick = (event) =&gt; {
        alert(`My name is ${alex.Name} and age is ${alex.Age}`)
    }
&lt;/script&gt;
&lt;style&gt;
    h1, section {
        text-align: center;
    }
    button {
        border: none;
        padding: 10px;
        font-size: 1em;
        background-color: brown;
        color: white;
        border-radius: 40px;
    }
&lt;/style&gt;
</pre>
<p>点击按钮。请注意，我们的Go方法返回的数据正在我们的Svelte模板中使用。整洁！</p>
<h2 id="bud-compares-other-frameworks">Bud与其他框架相比如何</h2>
<p>还有许多功能Bud还没有，但考虑到它还处于早期阶段，这是相当令人印象深刻的。让我们将Bud与我们希望在未来看到的其他框架和功能进行比较。</p>
<h3 id="ruby-on-rails-laravel">Bud vs. Ruby on Rails and Laravel</h3>
<p>这些框架可以很容易地添加web套接字、通道等特性。巴德已经保留了一些未来的目录名称，暗示最终将包括这些功能。</p>
<h3 id="next-js-nuxt-js-sveltekit">Bud vs. Next.js、Nuxt.js和SvelteKit</h3>
<p>虽然允许某种程度的服务器端渲染，但Next、Nuxt和SvelteKit仍然分别严重依赖React、Vue和Svelte的客户端特性。这使得在它们内部使用像Redux这样的状态管理解决方案成为可能。与此同时，Bud使用更传统的方法让后端管理状态，还没有一个清晰的路径来实现类似的状态管理模式。在对RESTful约定和web标准的依赖方面，它可能更类似于Remix.js。</p>
<h2 id="conclusion">结论</h2>
<p>Bud采用了许多约定，比如我们在Next和Ruby on Rails等框架中看到的基于文件的路由和RESTful控制器方法，并将它们捆绑到一个框架中。虽然Bud仍在努力构建更多的功能和特性，以成为一个强大的框架，为Laravel等所有场景提供解决方案，但Bud提供了一个简单的基于约定的工作流程，使使用Go和Svelte并从中受益变得轻而易举。</p><div class="code-block code-block-4">
<div class="blog-plug base-cta"><h2>使用<a class="signup" href="https://lp.logrocket.com/blg/signup" target="_blank" rel="noopener noreferrer"> LogRocket </a>消除传统错误报告的干扰</h2>
<a href="https://lp.logrocket.com/blg/signup" class="signup" target="_blank" rel="noopener noreferrer"><img class="alignnone size-full wp-image-46 jetpack-lazy-image" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/><noscript><img data-lazy-fallback="1" class="alignnone size-full wp-image-46" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/></noscript></a>
<p><a href="https://lp.logrocket.com/blg/signup" target="_blank" rel="noopener noreferrer"> LogRocket </a>是一个数字体验分析解决方案，它可以保护您免受数百个假阳性错误警报的影响，只针对几个真正重要的项目。LogRocket会告诉您应用程序中实际影响用户的最具影响力的bug和UX问题。</p>
<p>然后，使用具有深层技术遥测的会话重放来确切地查看用户看到了什么以及是什么导致了问题，就像你在他们身后看一样。</p>
<p>LogRocket自动聚合客户端错误、JS异常、前端性能指标和用户交互。然后LogRocket使用机器学习来告诉你哪些问题正在影响大多数用户，并提供你需要修复它的上下文。</p>
<p>关注重要的bug—<a class="signup" href="https://lp.logrocket.com/blg/signup-issue-free" target="_blank" rel="noopener noreferrer">今天就试试LogRocket】。</a></p></div></div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
<html>
<head>
<title>Exploring competitive features in Node.js v18 and v19 </title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>探索Node.js v18和v19中的竞争特性</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/exploring-competitive-features-node-js-v18-v19/#0001-01-01">https://blog.logrocket.com/exploring-competitive-features-node-js-v18-v19/#0001-01-01</a></blockquote><div><article class="article-post">
<p>自从2009年发布以来，Node.js一直是一个流行的JavaScript运行时。但是两个新运行时的出现，<a href="https://deno.land/"> Deno </a>和<a href="https://bun.sh/"> Bun </a>，为它们与Node形成对比的新特性带来了大量宣传。</p>
<p>从远处看，Node.js似乎停滞不前，没有任何令人兴奋的事情发生——但事实并非如此。最近的两个Node.js版本，v18和v19，提供了许多重要的特性:</p>
<ul>
<li>对浏览器API的实验性支持，如<a href="https://blog.logrocket.com/fetch-api-node-js/"> Fetch </a>和web streams API</li>
<li>一个实验性的内置测试跑步者</li>
<li>支持Chromium最新版本的V8引擎</li>
<li>对<code>watch</code>模式的实验性支持，它取代了像<a href="https://www.npmjs.com/package/nodemon"> nodemon </a>这样的工具</li>
</ul>
<p>在本教程中，我们将探索Node.js v18和v19中的以下新功能:</p>

<h2 id="node-js-v18-features">Node.js v18功能</h2>
<p>Node.js v18于2022年4月19日发布，并在2022年10月Node.js v19发布时成为当前版本。当前版本意味着该版本获得了Node.js新版本的不间断特性。</p>
<p>Node.js v18获得了<code>watch</code>模式特性，该特性在v19发布时在Node v18中被反向移植。2022年10月25日，Node.js v18被提升为LTS(长期支持)，并将继续接受支持，直到2025年。</p>
<p>以下是Node.js v18中可用的一些功能。</p>
<h3 id="inbuilt-fetch-api">内置提取API</h3>
<p>在Node.js v18之前，您不能使用Node.js中的Fetch API从API请求数据。你必须用Node.js v18安装<a href="https://github.com/node-fetch/node-fetch"> node-fetch </a>、<a href="https://axios-http.com/"> Axios </a>或其他第三方包，由于v18的实验性Fetch API，你不再需要安装任何一个包，这是全球可用的。</p>
<p>让我们看看如何在Node.js v18中使用Fetch API。首先，创建一个<code>getData.js</code>文件，并添加以下向API发送请求的函数:</p>
<pre class="language-javascript hljs">async function fetchData() {
  const response = await fetch(
    "https://random-data-api.com/api/name/random_name"
  );
  if (response.ok) {
    const data = await response.json();
    console.log(data);
  }
}

fetchData();
</pre>
<p>保存文件内容，然后用<code>node</code>命令运行文件:</p>
<pre class="language-bash hljs">node getData.js
</pre>
<p>该命令运行时，输出如下所示:</p>
<pre class="language-plaintext hljs">(node:29835) ExperimentalWarning: The Fetch API is an experimental feature. This feature could change at any time
(Use `node --trace-warnings ...` to show where the warning was created)
{
  id: 6638,
  uid: '75026571-e272-4298-b2c0-c3e9e6363437',
  name: 'Candy Kane',
  ...
  prefix: 'Rep.',
  initials: 'LBS'
}
</pre>
<p>在输出中，Node.js记录了一条警告，指出Fetch API是实验性的。在警告之后，我们看到API返回的JSON数据。</p>
<h3 id="inbuilt-test-runner-module">内置<strong>测试转轮模块</strong></h3>
<p>开发人员通常使用单元测试来测试软件组件。在Node.js的早期版本中，我们可以用<a href="https://nodejs.org/api/assert.html"> <code>assert</code>库</a>编写简单的测试。但是随着我们的测试越来越大，我们组织测试和编写描述性消息的需求也越来越大。</p>
<p>作为一种解决方案，测试运行程序如<a href="https://jestjs.io/"> Jest </a>、<a href="https://jasmine.github.io/"> Jasmine </a>和<a href="https://mochajs.org/"> Mocha </a>出现了，并且已经成为单元测试的首选工具。</p>
<p>随着Node.js v18的发布，Node.js中现在包含了一个测试运行器，可以通过以下方式访问:</p>
<pre class="language-javascript hljs">import test from 'node:test';
</pre>
<p>注意，我们使用<code>node:</code>方案来导入模块。您也可以使用CommonJS:</p>
<pre class="language-javascript hljs">const test = require('node:test')
</pre>
<p>让我们学习如何使用它。首先，使用以下内容初始化npm:</p>
<pre class="language-bash hljs">npm init -y
</pre>
<p>在您的<code>package.json</code>文件中，启用ES模块:</p>
<pre class="language-json hljs">{
  ...
  "license": "ISC"
  "type": "module",
}
</pre>
<p>接下来，创建一个<code>math.js</code>文件，并添加一个返回两个数相加结果的函数:</p>
<pre class="language-javascript hljs">const sum = (a, b) =&gt; {
  return a + b;
};

export default sum;
</pre>
<p>要使用Node.js测试运行器测试该函数，请创建一个包含以下内容的<code>test.js</code>文件:</p>
<pre class="language-javascript hljs">import test from "node:test";
import assert from "assert/strict";
import sum from "./math.js";

test("Sum function", async (t) =&gt; {
  await t.test("It should add two numbers", () =&gt; {
    assert.equal(sum(2, 2), 4);
  });
  await t.test("It should not subtract numbers", () =&gt; {
    assert.notEqual(sum(3, 2), 1);
  });
});
</pre>
<p>在第一行中，我们导入测试运行程序。在第二行中，我们导入了<code>assert</code>库，随后，导入了<code>math.js</code>文件中的<code>sum()</code>函数。</p>
<p>之后，我们创建一个包含两个子测试的测试用例，测试<code>sum()</code>函数是否正常工作。</p>
<p>现在，运行测试:</p>
<pre class="language-bash hljs">node test.js
</pre>
<p>您的输出将如下所示:</p>
<pre class="language-text hljs">TAP version 13
# Subtest: Sum function
    # Subtest: It should add two numbers
    ok 1 - It should add two numbers
      ---
      duration_ms: 1.171389
      ...
    # Subtest: It should not subtract numbers
    ok 2 - It should not subtract numbers
      ---
      duration_ms: 0.279246
      ...
    1..2
ok 1 - Sum function
  ---
  duration_ms: 5.522232
  ...
1..1
# tests 1
# pass 1
# fail 0
# cancelled 0
# skipped 0
# todo 0
</pre>
<p>在输出中，我们可以看到Node.js有运行测试的描述消息。</p>
<h3 id="web-streams-api-support">Web流API支持</h3>
<p>Web Streams API是Node.js中的一个实验性特性，它允许您将一个大文件(如视频或文本文件)分解成可以逐渐使用的小块。这有助于避免内存问题。在Node.js的旧版本中，您可以使用<a href="https://blog.logrocket.com/working-node-js-streams/"> Node.js流</a>来消耗大文件。但是浏览器中的JavaScript应用程序没有这个功能。后来，<a href="https://streams.spec.whatwg.org/"> WHATWG </a>定义了Web Streams API，它现在已经成为JavaScript应用中的流数据标准。</p>
<p>Node.js直到v18才支持这个API。在v18中，所有的流API对象，比如<code>ReadableStream</code>、<code>WritableStream</code>和<code>TransformStream</code>，都是可用的。要了解更多关于如何使用Streams API的信息，请查看<a href="https://nodejs.org/api/webstreams.html">文档</a>。</p>
<h3 id="building-binaries-snapshot">使用快照功能构建二进制文件</h3>
<p>另一个令人兴奋的特性是能够构建单个可执行的Node.js二进制文件。在Node.js v18之前，构建Node.js二进制文件的唯一方法是使用第三方包，比如<a href="https://github.com/vercel/pkg"> pkg </a>。</p>
<p>但是现在，您可以利用实验性的快照标志<code>--node-snapshot-main</code>来构建二进制文件。有关该功能如何工作的更多细节，请参见<a href="https://blog.logrocket.com/snapshot-flags-node-js-v18-8/">本教程</a>。</p>
<h3 id="v8-engine-upgraded-v10-1">V8发动机升级至v10.1</h3>
<p>Node.js构建在V8引擎之上，由Google创建，并为Chromium执行JavaScript而维护。在每个版本中，它都引入了新的特性和一些性能改进，这些都体现在Node.js中。</p>
<p>Google发布了V8 10.1，引入了一些新的数组方法，比如<code>findLast()</code>和<code>findLastIndex()</code>，还有<a href="https://v8.dev/blog/v8-release-99#intl-enumeration"> <code>Intl.supportedValuesOf(code)</code> </a>。V8引擎还为<a href="https://v8.dev/blog/v8-release-99#intl.locale-extensions"> <code>Intl.Locale</code> API </a>增加了新方法，并优化了<a href="https://v8.dev/blog/faster-class-features">类字段和私有方法</a>。</p>
<h2 id="watch-mode-node-js-v19-features"><code>watch</code>模式和其他Node.js v19特性</h2>
<p>Node.js v19发布于2022年10月18日。由于19是奇数，它将永远不会被提升到LTS，但将继续获得支持，直到2023年4月发布新的偶数版本Node.js。</p>
<p>虽然与Node.js v18相比，Node.js v19没有发布很多功能，但它也向过去的Node版本提供了一个最受欢迎的功能:<code>watch</code>模式。</p>
<p>当您在Node.js中创建和启动服务器，然后对该文件进行更改时，Node.js不会自动获取新的更改。你要么需要重启服务器，要么使用像<a href="https://blog.logrocket.com/configuring-nodemon-with-typescript/"> nodemon </a>这样的工具，当它检测到新的变化时，会自动重新运行文件。</p>
<p>随着Node.js v19的发布，这不再是必要的。Node v19以及Node v 18 . 11 . 0现在能够在使用<code>node --watch</code>功能检测到新变化时自动重启进程，该功能目前处于试验阶段。</p>
<p>要在监视模式下运行文件，请使用<code>--watch</code>标志:</p>
<pre class="language-bash hljs">node --watch index.js
</pre>
<p>当您编辑<code>index.js</code>文件时，您将看到进程自动重新启动，新的更改在不停止服务器的情况下得到反映。</p>
<p>如前所述，这个特性也被反向移植到Node.js ≥ v18.11.0，这意味着如果这是你唯一需要的特性，你就不必使用Node.js v19。</p>
<h3 id="http-s-1.1-Keep-Alive-by-default">默认为HTTP(S)/1.1 <code>KeepAlive</code></h3>
<p>Node.js使用一个<code><a href="https://nodejs.org/api/http.html#class-httpagent">http.globalAgent</a></code>用于输出HTTP连接，使用<code><a href="https://nodejs.org/api/https.html#class-httpsagent">https.globalAgent</a></code>用于输出HTTPS连接。这些代理确保TCP连接的持久性，以及HTTP客户端可以为多个请求重用连接。</p>
<p>通过将HTTP 1.1 <a href="https://en.wikipedia.org/wiki/Keepalive"> <code>keepAlive</code> </a>选项设置为<code>true</code>，可以将代理配置为重用连接；否则，将它设置为<code>false</code>以避免重用连接，这会使事情变得更慢。</p>
<p>对于Node.js版本≤18，HTTP/HTTPS的传出连接将<code>keepAlive</code>选项设置为<code>fal``se</code>，因此连接不会被多个请求重用，从而导致性能降低。在Node.js v19中，<code>keepAlive</code>选项现在被设置为<code>true</code>，这意味着您的出站连接将会更快，而无需进行任何配置。</p>
<p>我们来验证一下。假设你用的是<a href="https://github.com/nvm-sh/nvm"> nvm </a>，可以安装Node.js ≤ v18，临时切换到它:</p>
<pre class="language-bash hljs">nvm install v18.12.1
node -v
// Output
// v18.12.1
</pre>
<p>创建一个<code>checkHttpAlive.js</code>文件，并添加以下代码来检查<code>http.globalAgent</code>:</p>
<pre class="language-javascript hljs">const http = require('node:http');
console.log(http.globalAgent);
</pre>
<p>您的输出将如下所示:</p>
<pre class="language-text hljs">// Output
Agent {
  ...
  keepAliveMsecs: 1000,
  keepAlive: false,  // this is the keepAlive option
  ...
}
</pre>
<p>在输出中，您会注意到节点v18上的<code>keepAlive</code>默认设置为<code>false</code>。</p>
<p>我们来对比一下Node.js v19。使用nvm将Node.js版本切换到v19:</p>
<pre class="language-bash hljs">nvm install v19.0.1
node -v
// output:
// v19.0.1
</pre>
<p>再次运行<code>checkHttpAlive.js</code>文件:</p>
<pre class="language-bash hljs">node checkHttpAlive.js
</pre>
<p>输出将与以下内容匹配:</p>
<pre class="language-text hljs">// output
Agent {
  ...
  keepAliveMsecs: 1000,
  keepAlive: true,
  ...
}
</pre>
<p>在输出中，您可以看到Node.js v19中的<code>keepAlive</code>选项默认设置为<code>true</code>。</p>
<h3><strong> V8 </strong> <strong>发动机升级至10.7 </strong></h3>
<p>Node.js v19的V8引擎已升级至10.7版本。它没有附带很多特性——它只是在JavaScript API中添加了<code>Intl.NumberFormat</code>特性。</p>
<p><code>Intl.NumberFormat</code>将一个数字国际化为一种货币。一个例子:</p>
<pre class="language-javascript hljs">&gt; new Intl.NumberFormat('en-US', { style: 'currency', currency: 'GBP' }).format(3392.10)
'£3,392.10'     // output
</pre>
<h2 id="conclusion">结论</h2>
<p>在本文中，我们探索了Node.js v18和v19中很酷的特性。首先，我们看了v18中的新特性，包括内置的Fetch API、新的测试运行器和快照特性、<code>watch</code>模式，以及对Web Streams API的支持。然后我们查看了Node v19中的新特性，包括<code>watch</code>模式和HTTP 1.1 <code>keepAlive</code>特性。</p><div class="code-block code-block-54">
<hr/>
<h3>更多来自LogRocket的精彩文章:</h3>

<hr/></div>
<p>尽管Node.js的新特性令人兴奋，但这些特性中的大部分已经存在于Bun和Deno中。运行时还包括一些有用的特性，比如原生类型脚本支持、web sockets API以及比Node.js更快的执行速度</p>
<p>如果你不确定用哪个Node.js版本，我会推荐v18。它的支持将持续到2025年，不像Node v19，其支持将于明年结束。如果您想更深入地了解这些特性，请参考<a href="https://nodejs.org/en/docs/">文档页面</a>。</p><div class="code-block code-block-23">
<div class="blog-plug inline-plug node-plug"><h2>200只<img src="../Images/61167b9d027ca73ed5aaf59a9ec31267.png" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2019/10/green-check.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" class=" jetpack-lazy-image" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/10/green-check.png"/> <noscript> <img data-lazy-fallback="1" src="../Images/61167b9d027ca73ed5aaf59a9ec31267.png" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/10/green-check.png"/> </noscript>显示器出现故障，生产中网络请求缓慢</h2><p>部署基于节点的web应用程序或网站是容易的部分。确保您的节点实例继续为您的应用程序提供资源是事情变得更加困难的地方。如果您对确保对后端或第三方服务的请求成功感兴趣，</p><a href="https://lp.logrocket.com/blg/node-signup" target="_blank">try LogRocket</a><p>. </p><a class="signup" href="https://lp.logrocket.com/blg/node-signup" target="_blank" rel="noopener noreferrer"><img src="../Images/cae72fd2a54c5f02a6398c4867894844.png" alt="LogRocket Network Request Monitoring" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2019/12/network-request-filter-2-1.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" class=" jetpack-lazy-image" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/12/network-request-filter-2-1.png"/><noscript><img data-lazy-fallback="1" src="../Images/cae72fd2a54c5f02a6398c4867894844.png" alt="LogRocket Network Request Monitoring" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/12/network-request-filter-2-1.png"/></noscript></a><a href="https://lp.logrocket.com/blg/node-signup" target="_blank" rel="noopener noreferrer">https://logrocket.com/signup/</a><p>LogRocket 就像是网络和移动应用程序的DVR，记录下用户与你的应用程序交互时发生的一切。您可以汇总并报告有问题的网络请求，以快速了解根本原因，而不是猜测问题发生的原因。</p><p>LogRocket检测您的应用程序以记录基线性能计时，如页面加载时间、到达第一个字节的时间、慢速网络请求，还记录Redux、NgRx和Vuex操作/状态。</p><a class="signup" href="https://lp.logrocket.com/blg/node-signup" target="_blank" rel="noopener noreferrer">Start monitoring for free</a><p>. </p></div>
</div>

<p class="clearfix"/>
 <p class="clearfix"/>
</article>

</div>    
</body>
</html>
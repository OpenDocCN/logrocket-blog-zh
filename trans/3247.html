<html>
<head>
<title>An intro to routing in Go with Gorilla Mux - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>Go with Gorilla Mux - LogRocket博客中的路由介绍</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/routing-go-gorilla-mux/#0001-01-01">https://blog.logrocket.com/routing-go-gorilla-mux/#0001-01-01</a></blockquote><div><article class="article-post">
<p><em> <strong>编者按:</strong>这篇文章于2023年3月1日更新，包括了关于匹配路由、并发性以及HttpRouter的信息。</em></p>
<p>HTTP路由器是帮助接收网络请求并将其转发给指定处理程序的工具和库。HTTP路由器运行在服务器上，拦截传入的请求，并将请求指定给指定的处理函数。</p>
<p>路由器因后端框架而异；为了更快地构建软件，大多数后端框架都附带了路由器和许多其他功能。</p>
<p>Gorilla Mux包是Go生态系统中最受欢迎的路由器和项目之一，由于该包的多样化功能，它被用于像T2 Geth T3这样受欢迎的项目中。Gorilla Mux提供匹配路由、服务静态文件、服务单页应用程序(spa)、中间件、处理CORS请求和测试处理程序的功能。</p>
<p><em> <strong>注意，</strong>截至2022年12月，整个<a href="https://github.com/gorilla">大猩猩网络工具包</a>在GitHub上进入存档模式。用项目维护人员的话说，这意味着:</em></p>
<blockquote><p>所有存储库都进入了“只读”模式。任何仍在使用它们的人都可以克隆它们，获得它们，并继续用它们构建项目。实际上，在过去的12个月里，这里真的没有什么变化，也不会破坏现有的项目。这确实表明这些库不会有未来的发展。<br/>…欢迎人们(一如既往地)分享它们:所有的Gorilla库都获得了许可(MIT、BSD-3和Apache 2.0)。”</p></blockquote>
<p>你可以在这里阅读关于为什么工具包被存档<a href="https://github.com/gorilla">的更多细节。</a></p>
<p>本教程将指导您使用Gorilla Mux包作为应用程序的路由器。通过使用Gorilla Mux构建一个简单的API，您将了解如何使用它。</p>
<p><em>向前跳转:</em></p>

<h2 id="getting-started-gorilla-mux">Gorilla Mux入门</h2>
<p><img decoding="async" class="aligncenter jetpack-lazy-image" src="../Images/2a78f15f2607c704babd1c5dfe73e615.png" alt="Gorilla Mux" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2022/08/gorilla-mux.jpeg?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/08/gorilla-mux.jpeg"/></p><noscript><img data-lazy-fallback="1" decoding="async" loading="lazy" class="aligncenter" src="../Images/2a78f15f2607c704babd1c5dfe73e615.png" alt="Gorilla Mux" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/08/gorilla-mux.jpeg"/></noscript>
<p>设置好Go工作空间后，在工作目录中运行以下命令来安装Gorilla Mux包:</p>
<pre class="language-go hljs">go get -u github.com/gorilla/mux
</pre>
<p>安装Gorilla Mux包后，在Go文件的顶部导入您将在本教程中使用的包和模块，如下所示:</p>
<pre class="language-go hljs">import (
        "encoding/json"
        "github.com/gorilla/mux"
        "log"
        "net/http"
)
</pre>
<p>Gorilla Mux依赖于标准的<code>http</code>包，您将在本教程的许多部分使用<code>http</code>包，包括设置服务器。您将使用<code>json</code>包对JSON的结构进行编码和解码，反之亦然。</p>
<h2 id="parsing-structs-json-go">在Go中将结构解析成JSON</h2>
<p>以下是您将在本教程中用作数据模型的结构类型:</p>
<pre class="language-go hljs">type Bio struct {
        Name string `json:"name"`
        Age  int    `json:"age"`
}
</pre>
<p>Gorilla Mux不像<a href="https://blog.logrocket.com/building-microservices-go-fiber/"> Fiber </a>那样提供解析JSON结构的功能。相反，在本教程中，您将使用标准库中的<code>json</code>包来解码JSON请求，并将结构编码为对客户端的JSON响应。</p>
<p>这里有一个用<code>json</code>包编码和解码的例子。首先创建您想要解码的Go变量:</p>
<pre class="language-go hljs">var human Bio
</pre>
<p><code>human</code>变量是<code>Bio</code>结构的实例化。您可以使用由<code>json.NewDecoder</code>返回的<code>Decoder</code>结构的<code>Decode</code>方法将HTTP请求的JSON主体解析成初始化的结构。</p>
<pre class="language-go hljs">err := json.NewDecoder(request.Body).Decode(&amp;human)
if err != nil {
  log.Fatalln("There was an error decoding the request body into the struct")
}
</pre>
<p>类似地，您可以使用由<code>NewEncoder</code>返回的<code>Encoder</code>结构的<code>Encode</code>方法来编写一个将被编码为JSON的结构给客户端。</p>
<pre class="language-go hljs">err = json.NewEncoder(writer).Encode(&amp;human)
if err != nil {
  log.Fatalln("There was an error encoding the initialized struct")
}
</pre>
<p>现在，您已经熟悉了使用JSON的基础知识，让我们继续学习路由。</p>
<h2 id="routing-gorilla-mux-package">Gorilla Mux封装路由</h2>
<p>您可以使用<code>NewRouter</code>方法创建一个路由器实例，如下所示:</p>
<pre class="language-go hljs">router := mux.NewRouter()
</pre>
<p>在声明了一个新的路由器实例之后，您可以使用路由器实例的<code>HandleFunc</code>方法将路由分配给处理程序函数，以及处理程序函数处理的请求类型。这里有一个例子:</p>
<pre class="language-go hljs">router.HandleFunc("/api/v1/example", exampleHandler).Methods("GET")
</pre>
<p><code>HandleFunc</code>方法将<code>api/v1/example</code>路由分配给<code>exampleHandler</code>处理函数来处理<code>GET</code>请求。</p>
<p>这些是您将在本教程中构建的CRUD API端点的路由器声明:</p>
<pre class="language-go hljs">router.HandleFunc("/create", create).Methods("POST")
router.HandleFunc("/read", read).Methods("GET")
router.HandleFunc("/update", update).Methods("PUT")
router.HandleFunc("/delete", delete_).Methods("DELETE")
</pre>
<p>您的下一个任务是创建这些处理函数并设置一个服务器。</p>
<h2 id="matching-routes-gorilla-mux">Gorilla Mux中的匹配路线</h2>
<p>在继续创建处理程序之前，让我们暂停一下，仔细看看如何使用Gorilla Mux匹配路径。现在，您的路由基于应用程序的根和HTTP请求方法。例如，宣言:</p>
<pre class="language-go hljs"> router.HandleFunc("/create", create).Methods("POST")
</pre>
<p>当客户端向地址<code>yourserveraddress.com/create</code>发出POST请求时，我们将调用<code>create</code>处理程序。然而，Gorilla Mux提供了更精确地确定端点匹配路线的方法。</p>
<p>让我们假设您想确保您的<code>create</code>处理程序只处理通过HTTPS发出的请求。您需要做的就是将一个scheme匹配链接到route声明，就像这样:</p>
<pre class="language-go hljs"> router.HandleFunc("/create", create).Methods("POST").Schemes("https")
</pre>
<p>Gorilla Mux为其他几个标准提供了匹配。比如可以按主机URL匹配路由，像这样:<code>router.HandleFunc("/route",</code> <code>handler).Host("www.yourdomain.com")</code>。该声明将只处理对URL <code><a href="http://www.yourdomain.com/route" rel="nofollow">http://www.yourdomain.com/route</a></code>的请求。</p>
<p>Mux还允许您:</p>
<ul>
<li>按路径前缀匹配路由</li>
<li>基于HTTP头的存在匹配路由</li>
<li>基于请求中的查询参数匹配路线</li>
<li>根据您的需求定义自定义匹配函数</li>
</ul>
<p>你可以在这里找到使用这些匹配<a href="https://github.com/gorilla/mux#matching-routes">的例子。关于用Mux匹配路由，有一个警告:如果一个传入的请求匹配两个或更多的路由声明(存在路由冲突)，那么总是使用第一个路由声明来处理请求。</a></p>
<p>因为将相同的匹配应用到几个不同的路由是乏味的，并且会使您的代码更难阅读，Gorilla Mux提供了一个称为子路由的功能。此功能允许您创建一个路由器，将一组匹配应用于您向其注册的所有路由。这里有一个例子:</p>
<pre class="language-go hljs">router := mux.NewRouter()
s := router.Host("www.yourdomain.com").Headers("Connection", "Keep-Alive").Subrouter()
s.HandleFunc("/create", handler)
s.HanldeFunc("/update", updateHandler)
</pre>
<p>只有当请求具有适当的<code>Host</code>和<code>Headers</code>时，才会处理<code>/create</code>和<code>/update</code>路线。现在您已经理解了路由匹配的工作原理，您可以继续创建您的处理程序了。</p>
<h2 id="setting-up-handler-functions">设置处理函数</h2>
<p>处理函数是您为应用程序声明业务逻辑的地方。根据操作的不同，您的处理程序将需要一个<code>writer</code>对象(向客户端写入响应)和一个<code>request</code>对象(获取关于传入请求的信息)。</p>
<p>这些对象通常分别是<code>http.ResponseWriter</code>和/或<code>*http.Request</code>类型的实例。下面是一个向客户端返回JSON响应的典型处理函数的框架示例:</p>
<pre class="language-go hljs">func example(writer http.ResponseWriter, request *http.Request) {
    writer.Header().Set("Content-Type", "application/json")
}
</pre>
<p>下一步是创建将在本教程中使用的数据存储:</p>
<pre class="language-go hljs">var BioData = make([]Bio, 0)
</pre>
<p>上面的<code>BioData</code>变量是您之前定义的<code>Bio</code>类型的一部分。这个数据存储对于本教程来说已经足够了，但是您的项目可能会有更复杂的需求，需要您使用数据库。如果你不熟悉在Go中使用数据库，你可以查看一下关于<a href="https://blog.logrocket.com/how-to-use-mongodb-with-go/"> MongoDB </a>和<a href="https://blog.logrocket.com/how-to-build-a-rest-api-with-golang-using-gin-and-gorm/"> GORM ORM </a>的教程。</p>
<p>现在您的数据存储已经就绪，您可以开始创建您的<code>request</code>处理程序了。<code>create</code>处理函数被分配来处理<code>POST</code>请求，因此它的业务逻辑会将<code>request</code>主体中的新JSON对象保存到应用程序的数据存储中。下面是<code>create</code>函数的代码:</p>
<pre class="language-go hljs">func create(writer http.ResponseWriter, request *http.Request) {
        writer.Header().Set("Content-Type", "application/json")
        writer.WriteHeader(http.StatusOK)
        var human Bio
        err := json.NewDecoder(request.Body).Decode(&amp;human)
        if err != nil {
            log.Fatalln("There was an error decoding the request body into the struct")
        }
        BioData = append(BioData, human)
        err = json.NewEncoder(writer).Encode(&amp;human)
        if err != nil {
                log.Fatalln("There was an error encoding the initialized struct")
        }
}
</pre>
<p><code>create</code>处理函数在收到请求时将<code>StatusOk</code>头写入客户端，将JSON请求体解码成<code>human</code>结构实例，将<code>human</code>结构保存到<code>BioData</code>片，并通过将<code>human</code>结构作为对客户端的响应来结束。</p>
<p>接下来是<code>read</code>处理程序。<code>read</code>处理函数被分配给<code>GET</code>请求；因此，其业务逻辑将从数据存储中获取数据，并根据客户端的请求将匹配的数据返回给客户端:</p>
<pre class="language-go hljs">func read(writer http.ResponseWriter, request *http.Request) {
        writer.Header().Set("Content-Type", "application/json")
                name := mux.Vars(request)["name"]
        for _, structs := range BioData {
                if structs.Name == name {
                        err := json.NewEncoder(writer).Encode(&amp;structs)
                        if err != nil {
                                log.Fatalln("There was an error encoding the initialized struct")
                        }
                }
        }

}
</pre>
<p><code>read</code>函数通过使用<code>mux</code>包的<code>Vars</code>方法读取请求的<code>name</code>参数来工作。然后，它遍历用作数据存储的<code>BioData</code>片，并将匹配<code>name</code>参数的结构作为JSON返回给客户机。</p>
<p><code>update</code>处理函数被分配给<code>PUT</code>请求，因此它的业务逻辑应该更新请求指定的<code>BioData</code>数据存储中的结构:</p>
<pre class="language-go hljs">func update(writer http.ResponseWriter, request *http.Request) {
        writer.Header().Set("Content-Type", "application/json")
        var human Bio
        err := json.NewDecoder(request.Body).Decode(&amp;human)
        if err != nil {
                log.Fatalln("There was an error decoding the request body into the struct")
        }
        for index, structs := range BioData {
                if structs.Name == human.Name {
                        BioData = append(BioData[:index], BioData[index+1:]...)
                }
        }
        BioData = append(BioData, human)
        err = json.NewEncoder(writer).Encode(&amp;human)
        if err != nil {
                log.Fatalln("There was an error encoding the initialized struct")
        }
}
</pre>
<p><code>update</code>函数将请求体中的JSON解析成<code>human</code>变量，循环遍历<code>BioData</code>片，删除条目(如果存在的话)，最后将<code>human</code>结构从请求体追加到<code>BioData</code>片。</p>
<p><code>delete_</code>处理函数被分配给<code>DELETE</code>请求；因此，其业务逻辑将从数据存储中删除指定的结构:</p>
<pre class="language-go hljs">func delete_(writer http.ResponseWriter, request *http.Request) {
        writer.Header().Set("Content-Type", "application/json")
        name := mux.Vars(request)["name"]
        indexChoice := 0
        for index, structs := range BioData {
                if structs.Name == name {
                        indexChoice = index
                }
        }
        BioData = append(BioData[:indexChoice], BioData[indexChoice+1:]...)
}
</pre>
<p><code>delete_</code>函数从请求中检索name参数，遍历<code>BioData</code>数据存储，并删除条目(如果存在的话)。</p>
<p>既然已经设置了处理函数，最后一步就是设置监听请求的服务器。</p><div class="code-block code-block-54">
<hr/>
<h3>更多来自LogRocket的精彩文章:</h3>

<hr/></div>
<h2 id="setting-up-server">设置服务器</h2>
<p>您可以使用<code>http</code>包的<code>ListenAndServe</code>方法来设置服务器。<code>ListenAndServe</code>方法将您希望服务器运行的端口和路由器实例(如果有的话)作为参数。这是您的应用程序的服务器:</p>
<pre class="language-go hljs">func RunServer() {
        router := mux.NewRouter()
        router.HandleFunc("/create", create).Methods("POST")
        router.HandleFunc("/read", read).Methods("GET")
        router.HandleFunc("/update", update).Methods("PUT")
        router.HandleFunc("/delete", delete_).Methods("DELETE")

        err := http.ListenAndServe(":8080", router)
        if err != nil {
                log.Fatalln("There's an error with the server," err)
        }

}
</pre>
<p>调用项目的<code>main</code>函数中的<code>RunServer</code>函数应该会在本地主机端口<code>8080</code>上启动一个服务器。</p>
<p>这就是开始使用Gorilla Mux构建应用程序所需的全部信息！</p>
<h2 id="gorilla-mux-concurrency">Gorilla Mux和并发</h2>
<p>与使用标准库的ServeMux相比，使用Gorilla Mux对应用程序的并发性没有太大影响。在处理传入请求时，每个处理函数仍将在单独的goroutine中被调用。</p>
<p>那么这对你意味着什么呢？这意味着在修改处理程序之间共享的数据时必须小心，这样可以避免竞争情况。实现这一点最简单的方法通常是首先避免共享数据，只使用局部变量。然而，如果共享数据是不可避免的，那么一定要用一个<a href="https://pkg.go.dev/sync?utm_source=godoc#Mutex">互斥锁</a>或其他同步机制来保护对数据的所有访问。</p>
<h2 id="gorilla-mux-router-vs-chi-router">Gorilla Mux路由器与Chi路由器</h2>
<p><img decoding="async" class="aligncenter jetpack-lazy-image" src="../Images/2f3c527891f5d661b768b5d254776233.png" alt="Chi Router" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2022/08/chi-router.jpeg?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/08/chi-router.jpeg"/></p><noscript><img data-lazy-fallback="1" decoding="async" loading="lazy" class="aligncenter" src="../Images/2f3c527891f5d661b768b5d254776233.png" alt="Chi Router" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/08/chi-router.jpeg"/></noscript>
<p>Chi是一个轻量级、可组合的路由器，用于在Go中构建HTTP服务。您会发现<code>Chi</code>路由器对于构建您想要长期维护和支持的大型RESTful API服务非常有用。Heroku、Cloudflare和99designs在生产中使用Chi路由器。</p>
<p><code>Chi</code>建立在<code>context</code>包的基础上，使其适合处理跨处理程序链的信令、取消和请求范围的操作。<code>Chi</code>包还包含用于中间件和生成文档的子包，以及用于管理HTTP请求和响应负载的呈现包。</p>
<p>这里有一个使用Chi路由器进行路由的快速示例:</p>
<pre class="language-go hljs">import (
        "net/http"
        "github.com/go-chi/chi/v5"
        "github.com/go-chi/chi/v5/middleware"
)

func main() {
        router := chi.NewRouter()
        router.Use(middleware.Logger)
        router.Get("/", func(writer http.ResponseWriter, request *http.Request) {
                writer.Write([]byte("welcome to the chi"))
        })
        http.ListenAndServe(":3000", router)
}
</pre>
<p><code>main</code>函数启动一个监听端口<code>3000</code>的服务器，并向客户端写入一个字符串作为响应。</p>
<p>当您开始一个新项目时，您可能想知道使用哪个路由器。下面是两个路由器包之间的比较，以帮助您根据您正在构建的内容做出决定:</p>
<table>
<thead>
<tr>
<th><strong>公制</strong></th>
<th><strong>大猩猩Mux </strong></th>
<th><strong>驰路由器</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>速度</strong></td>
<td><strong/><a href="https://github.com/julienschmidt/go-http-routing-benchmark"><strong>见基准</strong> </a></td>
<td><strong/><a href="https://github.com/julienschmidt/go-http-routing-benchmark"><strong>见基准</strong> </a></td>
</tr>
<tr>
<td><strong>文件生成</strong></td>
<td><strong>否</strong></td>
<td><strong>是</strong></td>
</tr>
<tr>
<td><strong>人气</strong></td>
<td><strong> 17k星，GitHub上的</strong> <strong> 77k项目所使用的</strong> <strong/></td>
<td><strong> 12k stars，由GitHub上的11k项目使用</strong></td>
</tr>
<tr>
<td><strong>渲染</strong></td>
<td><strong>是</strong></td>
<td><strong>是</strong></td>
</tr>
<tr>
<td><strong>中间件</strong></td>
<td><strong>是</strong></td>
<td><strong>是</strong></td>
</tr>
<tr>
<td><strong> WebSockets </strong></td>
<td><strong>是</strong></td>
<td><strong>是</strong></td>
</tr>
<tr>
<td><strong>测试</strong></td>
<td><strong>是</strong></td>
<td><strong>是</strong></td>
</tr>
</tbody>
</table>
<p>Gorilla Mux和Chi路由器在路由方面都很棒，但你会发现大多数Go开发人员都使用Gorilla Mux，因为它比较老，而且Gorilla Mux有更多的学习资源。</p>
<h2 id="gorilla-mux-router-vs-httprouter">Gorilla Mux路由器与http路由器</h2>
<p><img data-attachment-id="161726" data-permalink="https://blog.logrocket.com/routing-go-gorilla-mux/attachment/httprouter/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/08/httprouter.jpeg" data-orig-size="720,360" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;1&quot;}" data-image-title="HttpRouter" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/08/httprouter-300x150.jpeg" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/08/httprouter.jpeg" decoding="async" class="aligncenter wp-image-161726 size-full jetpack-lazy-image" src="../Images/b48992b8f1d2798f637d08edb75e2cd2.png" alt="HttpRouter" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2022/08/httprouter.jpeg 720w, https://blog.logrocket.com/wp-content/uploads/2022/08/httprouter-300x150.jpeg 300w" data-lazy-sizes="(max-width: 720px) 100vw, 720px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2022/08/httprouter.jpeg?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/08/httprouter.jpeg"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="161726" data-permalink="https://blog.logrocket.com/routing-go-gorilla-mux/attachment/httprouter/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/08/httprouter.jpeg" data-orig-size="720,360" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;1&quot;}" data-image-title="HttpRouter" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/08/httprouter-300x150.jpeg" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/08/httprouter.jpeg" decoding="async" loading="lazy" class="aligncenter wp-image-161726 size-full" src="../Images/b48992b8f1d2798f637d08edb75e2cd2.png" alt="HttpRouter" srcset="https://blog.logrocket.com/wp-content/uploads/2022/08/httprouter.jpeg 720w, https://blog.logrocket.com/wp-content/uploads/2022/08/httprouter-300x150.jpeg 300w" sizes="(max-width: 720px) 100vw, 720px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/08/httprouter.jpeg"/></noscript>
<p>HttpRouter 是一款用于Go应用的快速、小型路由器，已经存在很长时间了。它如此快速可靠，以至于被用作几个Go web框架的路由器，其中最流行的是Gin。以下是<a href="https://github.com/julienschmidt/httprouter">医生</a>对HttpRouter的评价:</p>
<blockquote><p>HttpRouter是一个轻量级高性能HTTP请求路由器(也称为多路复用器或简称为mux ),用于Go。</p>
<p>与Go的<code>net/http</code>包的<a href="https://golang.org/pkg/net/http/#ServeMux">默认mux </a>相反，这个路由器支持路由模式中的变量，并与请求方法相匹配。它的伸缩性也更好。</p>
<p>该路由器针对高性能和小内存占用进行了优化。即使有很长的路径和大量的路由，它也能很好地扩展。压缩动态trie(基数树)结构用于高效匹配</p></blockquote>
<p>为了让您感受一下它是如何工作的，这里有一个使用HttpRouter进行路由的小演示:</p>
<pre class="language-go hljs">import (
   "github.com/julienschmidt/HttpRouter"
   "log"
   "net/http"
)

func main() {
   router := HttpRouter.New()
   router.GET("/", func(w http.ResponseWriter, r *http.Request, _ HttpRouter.Params) {
      w.Write([]byte("Hello from http router"))
   })

   log.Fatal(http.ListenAndServe(":8080", router))
}
</pre>
<p>就像Chi一样，在这个演示中,<code>main</code>函数启动一个服务器，监听端口<code>8080</code>,并向客户端写一个hello响应。为了帮助您选择最适合您需求的路由器，下面是HttpRouter和Mux之间的比较:</p>
<table>
<thead>
<tr>
<th><strong>公制</strong></th>
<th><strong>大猩猩Mux </strong></th>
<th><strong>Http<em><em/></em></strong>R<strong><em>o</em></strong>uter</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>速度</strong></td>
<td><strong/><a href="https://github.com/julienschmidt/go-http-routing-benchmark"><strong>见基准</strong> </a></td>
<td><strong>极快，</strong> <a href="https://github.com/julienschmidt/go-http-routing-benchmark"> <strong>见基准</strong> </a></td>
</tr>
<tr>
<td><strong>文件生成</strong></td>
<td><strong>否</strong></td>
<td><strong>否</strong></td>
</tr>
<tr>
<td><strong>人气</strong></td>
<td><strong> 17k星，GitHub上的</strong> <strong> 77k项目所使用的</strong> <strong/></td>
<td><strong> 1 <em> <em/> </em> </strong> 5 <strong> <em> k星，使用过的</em> </strong> <strong>由</strong> 16 <strong> k项目上的GitHub </strong></td>
</tr>
<tr>
<td><strong>渲染</strong></td>
<td><strong>是</strong></td>
<td><strong>是</strong></td>
</tr>
<tr>
<td><strong>中间件</strong></td>
<td><strong>是</strong></td>
<td><strong>是</strong></td>
</tr>
<tr>
<td><strong> WebSockets </strong></td>
<td><strong>是</strong></td>
<td><strong>否</strong></td>
</tr>
<tr>
<td><strong>测试</strong></td>
<td><strong>是</strong></td>
<td><strong>是</strong></td>
</tr>
</tbody>
</table>
<p>大猩猩Mux和HttpRouter都是优秀的路由器。HttpRouter的优点是速度快和简洁，但是Mux提供了更多的灵活性和功能。</p>
<h2 id="conclusion">结论</h2>
<p>在本教程中，您了解了Gorilla Mux、HttpRouter和Chi路由器包，如何使用Gorilla Mux路由器路由和构建API，以及如何评估这三个包以帮助您为项目做出更好的决策。</p>
<p>看看这些<a href="https://blog.logrocket.com/5-top-go-web-frameworks/"> Go框架</a>如何帮助您更快地构建web应用程序。</p><div class="code-block code-block-2">
<div class="blog-plug base-cta"><h2>使用<a class="signup" href="https://lp.logrocket.com/blg/signup" target="_blank" rel="noopener noreferrer"> LogRocket </a>消除传统错误报告的干扰</h2>
<a href="https://lp.logrocket.com/blg/signup" class="signup" target="_blank" rel="noopener noreferrer"><img class="alignnone size-full wp-image-46 jetpack-lazy-image" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/><noscript><img data-lazy-fallback="1" class="alignnone size-full wp-image-46" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/></noscript></a>
<p><a href="https://lp.logrocket.com/blg/signup" target="_blank" rel="noopener noreferrer"> LogRocket </a>是一个数字体验分析解决方案，它可以保护您免受数百个假阳性错误警报的影响，只针对几个真正重要的项目。LogRocket会告诉您应用程序中实际影响用户的最具影响力的bug和UX问题。</p>
<p>然后，使用具有深层技术遥测的会话重放来确切地查看用户看到了什么以及是什么导致了问题，就像你在他们身后看一样。</p>
<p>LogRocket自动聚合客户端错误、JS异常、前端性能指标和用户交互。然后LogRocket使用机器学习来告诉你哪些问题正在影响大多数用户，并提供你需要修复它的上下文。</p>
<p>关注重要的bug—<a class="signup" href="https://lp.logrocket.com/blg/signup-issue-free" target="_blank" rel="noopener noreferrer">今天就试试LogRocket】。</a></p></div></div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
<html>
<head>
<title>Displaying images with the React Native Image component - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>使用 React 本地图像组件显示图像</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/displaying-images-with-the-react-native-image-component/#0001-01-01">https://blog.logrocket.com/displaying-images-with-the-react-native-image-component/#0001-01-01</a></blockquote><div><article class="article-post">
<p>在一个由产品的美学价值决定的时代，图像对于传达产品的独特性至关重要。图像有助于传达我们所制造的产品的理念、解决方案和特性。</p>
<p>作为开发人员，我们必须拥有最好的工具来实现这些品质——这就是 React Native <code>Image</code>组件赋予我们的能力。在本文中，我们将深入 React Native <code>Image</code>组件的基础知识，讨论可用的类型和属性，并讨论它的局限性和替代方案。</p>
<h2>图像类型</h2>
<p>在我们深入研究 image 组件的细节之前，让我们回顾一下我们为移动应用程序准备的各种类型的图像，特别是 React Native <code>Image</code>组件期望的图像类型。</p>
<ul>
<li>本地图像:用户设备上可用的图像，可以临时使用，也可以在相机胶卷中找到</li>
<li>网络图像:通过网络传送的图像，例如从 Google 找到并加载的图像</li>
<li>静态资源:设备中始终相同的可用资源——它们既不是动态加载的，也不会改变</li>
</ul>
<h2>性能</h2>
<p>React Native <code>Image</code>组件提供了一些属性，您可以根据团队的业务或技术需求来配置组件和显示图像。它们有很多，但是我们现在只关注基本的。</p>
<h3><code>source</code></h3>
<p>这是告诉组件关于您想要加载的图像的主要属性。您可以在这里使用本地或远程文件，基本上，只需传递图像的 URI 来加载它。如果您需要指定图像的宽度和高度尺寸，您也可以通过它传递多个 URIs，并让设备选择最好的一个来使用。</p>
<p><code>source</code>也将接受一个 cache 属性，告诉组件如何缓存网络图像，但这只适用于 iOS。</p>
<h3><code>defaultSource</code></h3>
<p>当您的组件希望加载网络映像时，此属性非常有用。可以指定默认映像，该映像将一直加载，直到网络映像可用。</p>
<h3><code>resizeMode</code></h3>
<p>此道具控制当图像尺寸不适合框架大小时如何调整图像。可用的值有:</p>
<ul>
<li><code>cover</code>:将图像的宽度和高度缩放至等于或大于视图的尺寸</li>
<li><code>contain</code>:与 cover 属性相反，<code>contain</code>缩放图像的宽度和高度，使其等于或小于视图的大小</li>
<li><code>stretch</code>:独立缩放宽度和高度</li>
<li><code>repeat</code>:重复图像以覆盖视图，直到它被填满</li>
<li><code>center</code>:在视图中沿两个维度居中显示图像</li>
<li><code>style</code>:用于对图像组件进行样式化</li>
</ul>
<p>如果你感兴趣，可以<a href="https://reactnative.dev/docs/image#resizemode" target="_blank" rel="noopener">浏览 React 原生文档中的其他道具</a>。</p>
<h3>React Native 中的背景图像</h3>
<p>CSS 通常是用于添加背景图像的语言，但 React Native 提供了一个<code>ImageBackground</code>组件，使类似的功能在 web 应用程序中可用。<code>ImageBackground</code>组件也接受与<code>Image</code>组件相同的属性。</p>
<h2>使用反应本机映像组件</h2>
<p>现在我们已经讨论了理论，让我们用一个演示来实践一下。首先，您需要使用<a href="https://reactnative.dev/docs/environment-setup" target="_blank" rel="noopener">这个 React 本地环境设置</a>。对于本教程，我遵循 Expo 安装和设置说明。</p>
<p>如果您愿意跟随，您可以<a href="https://github.com/themmyloluwaa/rn-images" target="_blank" rel="noopener">克隆这个库</a>并签出到<code>startup</code>分支。最终代码在<code>main</code>分支中。</p>
<p>首先，让我们给应用程序添加一个背景图片。对于这个演示，我在<code>src/assets</code>目录中添加了一个名为“static-image”的图像。我们将使用它来演示 React 本机如何加载静态图像。</p>
<p>打开<code>App.js </code>并添加以下代码:</p>
<pre>import { StatusBar } from "expo-status-bar";
import React from "react";
import { StyleSheet, Text, View, ImageBackground } from "react-native";

const staticImage = require("./src/assets/static-image.png");
export default function App() {
 return (
   &lt;View style={styles.container}&gt;
     &lt;ImageBackground source={staticImage} style={styles.ImageBackground}&gt;
       &lt;StatusBar style="auto" /&gt;
       {/* TODO: something goes here  */}
     &lt;/ImageBackground&gt;
   &lt;/View&gt;
 );
}

const styles = StyleSheet.create({
 container: {
   flex: 1,
   backgroundColor: "#fff",
   alignItems: "center",
   justifyContent: "center",
 },
 ImageBackground: {
   flex: 1,
   resizeMode: "cover",
   width: "100%",
   alignItems: "center",
 },

});
</pre>
<p>如您所见，我们导入了<code>ImageComponent</code>，然后将静态图像的位置存储在一个名为<code>staticImage<strong>.</strong></code>的变量中。CommonJS 语法用于告诉<code>metro</code>服务器何时在应用程序包中加载图像。<code>require</code>语句告诉<code>metro</code>服务器将图像包含在包中。</p>
<p>然后，我们将所有子组件包装在<code>ImageBackground</code>组件中，并指定样式。为了确保我们的风格翻译，图像应该覆盖整个视图-指定我们写“100%宽度”-所有的孩子应该对齐和中心对齐。</p>
<p>接下来，将包含在<code>images</code>文件中的<code>image</code>数组导入到<code>src</code>中。还要从 React Native 导入<code>ScrollView</code>、Image 和<code>ActivityIndicator</code>组件。</p>
<p>将此语句添加到您的<code>App.js</code>函数中的<code>return</code>语句之前，如下所示:</p>
<pre>const [loading, setLoading] = React.useState(false);
</pre>
<p>这用于存储每个图像的加载状态。稍后我们将使用它来显示一个加载组件。</p>
<p>然后，用以下代码替换待办事项部分:</p>
<pre>&lt;ScrollView
         style={styles.ImageContainer}
         contentContainerStyle={{
           flexDirection: "row",
           flexWrap: "wrap",
           justifyContent: "center",
         }}
         horizontal={false}
       &gt;
         {IMAGES.map((image, i) =&gt; {
           return (
             &lt;View
               style={{
                 padding: 5,
               }}
               key={i}
             &gt;
               &lt;Image
                 source={{ uri: image }}
                 style={[
                   styles.Image,
                   {
                     width: i % 2 === 1 ? 150 : 95,
                     height: i % 2 === 1 ? 150 : 95,
                   },
                 ]}
                 resizeMode="center"
                 onLoadStart={() =&gt; setLoading(true)}
                 onLoadEnd={() =&gt; setLoading(false)}
               /&gt;
               {loading &amp;&amp; &lt;ActivityIndicator color="green" size="large" /&gt;}
             &lt;/View&gt;
           );
         })}
       &lt;/ScrollView&gt;
</pre>
<p><code>image</code>数组包含大量超出屏幕当前视窗的图像，所以我们将使用<code>ScrollView</code>组件而不是普通的<code>View</code>来确保用户可以在视窗内滚动到应用程序的其他部分。样式告诉<code>ScrollView</code>组件包装所有图像，使它们很好地堆叠在一起，并在一行而不是默认列中显示图像。</p>
<p><code>image</code>数组是循环的，我将数组中包含的图像传递给<code>source</code>道具中的<code>uri</code>键。我还应用了不同的宽度和高度，这取决于图像的索引是奇数还是偶数。<code>resizeMode</code>集合告诉图像组件将图像沿视图的两个维度居中。</p>
<p>最后，我应用样式并使用图像组件的<code>onLoadStart </code>和<code>onLoadEnd </code>道具获得图像加载状态。</p>
<p>最后，我使用图像的加载状态来呈现一个<code>ActivityIndicator</code>组件，它将在图像加载时显示。</p>
<p>将这些样式添加到<code>style</code>对象:</p>
<pre>ImageContainer: {
   marginHorizontal: 16,
   marginTop: 30,
   width: "100%",
 },
 Image: {
   shadowColor: "black",
   shadowOffset: {
     width: -10,
     height: 9,
   },
   shadowOpacity: 0.5,
   shadowRadius: 2,
   elevation:5
 },
</pre>
<p>然后，应用<code>elevation</code>和<code>shadow</code>样式给图像一个阴影效果。Android 将使用仰角样式，而 iOS 将使用阴影属性。这是我们的最终产品:</p>
<p><img data-attachment-id="51907" data-permalink="https://blog.logrocket.com/displaying-images-with-the-react-native-image-component/final-result-react-native-image-component-demo/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2021/05/final-result-react-native-image-component-demo.png" data-orig-size="730,1502" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="final-result-react-native-image-component-demo" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2021/05/final-result-react-native-image-component-demo-146x300.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2021/05/final-result-react-native-image-component-demo-498x1024.png" decoding="async" class="aligncenter size-full wp-image-51907 jetpack-lazy-image" src="../Images/143469059429bcd2f119554ac5306398.png" alt="Final result of our React Native Image component demo" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2021/05/final-result-react-native-image-component-demo.png 730w, https://blog.logrocket.com/wp-content/uploads/2021/05/final-result-react-native-image-component-demo-146x300.png 146w, https://blog.logrocket.com/wp-content/uploads/2021/05/final-result-react-native-image-component-demo-498x1024.png 498w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2021/05/final-result-react-native-image-component-demo.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2021/05/final-result-react-native-image-component-demo.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="51907" data-permalink="https://blog.logrocket.com/displaying-images-with-the-react-native-image-component/final-result-react-native-image-component-demo/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2021/05/final-result-react-native-image-component-demo.png" data-orig-size="730,1502" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="final-result-react-native-image-component-demo" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2021/05/final-result-react-native-image-component-demo-146x300.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2021/05/final-result-react-native-image-component-demo-498x1024.png" decoding="async" loading="lazy" class="aligncenter size-full wp-image-51907" src="../Images/143469059429bcd2f119554ac5306398.png" alt="Final result of our React Native Image component demo" srcset="https://blog.logrocket.com/wp-content/uploads/2021/05/final-result-react-native-image-component-demo.png 730w, https://blog.logrocket.com/wp-content/uploads/2021/05/final-result-react-native-image-component-demo-146x300.png 146w, https://blog.logrocket.com/wp-content/uploads/2021/05/final-result-react-native-image-component-demo-498x1024.png 498w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2021/05/final-result-react-native-image-component-demo.png"/></noscript>
<h2>限制</h2>
<p>虽然 React Native <code>Image</code>组件配备了一些令人惊叹的功能，但是在使用它时，仍然会遇到一些限制。</p>
<h3>渐进图像加载</h3>
<p>截至本文发布时，React Native <code>Image</code>还不支持渐进式图像加载特性。要做到这一点，你需要一个外部映像包或者<a href="https://medium.com/react-native-training/progressive-image-loading-in-react-native-e7a01827feb7" target="_blank" rel="noopener">自己建立一个</a>。</p>
<h3>图像格式</h3>
<p><code>Image</code>组件仅支持以下图像格式:</p>
<ul>
<li>PNG</li>
<li>JPG/JPEG</li>
<li>位图文件的扩展名(Bitmap)</li>
<li>GIF 格式</li>
<li>WEBP</li>
<li>私营部门司(仅监督办)</li>
</ul>
<p>如果您的项目需要扩展到这些支持的格式之外，这将不是适合您的组件。</p>
<h2>结论</h2>
<p>我们已经了解了 React Native <code>Image</code>组件的惊人功能，尤其是它如何使我们能够与用户进行可视化交流。使用这个组件我们可以实现很多事情——您甚至可以构建另一个高级图像组件来解决我们讨论过的一些限制！所以，年轻的学徒们，我给你们提供了塑造银河系所需要的一切。</p>
<p>如果你卡住了，有任何问题或更正，或者你只是想保持联系，不要犹豫，在 Twitter 上联系我。愿原力与你同在！</p><div class="code-block code-block-18">
<div class="blog-plug inline-plug react-native-plug"><h2><a href="https://lp.logrocket.com/blg/react-native-signup"> LogRocket </a>:即时重现 React 原生应用中的问题。</h2><a class="signup" href="https://lp.logrocket.com/blg/react-native-signup" target="_blank" rel="noopener noreferrer"><img class="alignnone size-full wp-image-46 jetpack-lazy-image" src="../Images/110055665562c1e02069b3698e6cc671.png" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2021/10/react-native-plug_v2-2.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2021/10/react-native-plug_v2-2.png"/><noscript><img data-lazy-fallback="1" class="alignnone size-full wp-image-46" src="../Images/110055665562c1e02069b3698e6cc671.png" data-original-src="https://blog.logrocket.com/wp-content/uploads/2021/10/react-native-plug_v2-2.png"/></noscript></a><p><a href="https://lp.logrocket.com/blg/react-native-signup" target="_blank" rel="noopener noreferrer"> LogRocket </a>是一款 React 原生监控解决方案，可帮助您即时重现问题、确定 bug 的优先级并了解 React 原生应用的性能。</p><p>LogRocket 还可以向你展示用户是如何与你的应用程序互动的，从而帮助你提高转化率和产品使用率。LogRocket 的产品分析功能揭示了用户不完成特定流程或不采用新功能的原因。</p><p>开始主动监控您的 React 原生应用— <a class="signup" href="https://lp.logrocket.com/blg/react-native-signup" target="_blank" rel="noopener noreferrer">免费试用 LogRocket】。</a></p></div>
</div>
<h2>进一步阅读</h2>


<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
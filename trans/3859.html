<html>
<head>
<title>Go migration guide: Node.js, Python, and Rust </title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>Go迁移指南:Node.js、Python和Rust</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/go-migration-guide-node-js-python-rust/#0001-01-01">https://blog.logrocket.com/go-migration-guide-node-js-python-rust/#0001-01-01</a></blockquote><div><article class="article-post">
<p>Go编程语言以其表达能力、简单的语法和其他特性而闻名。Go的主要目标是构建可伸缩的、可靠的软件系统，因为它的性能、并发支持、简单性以及通过非世代并发、三色标记和清除垃圾收集器的高效内存管理。</p>
<p>多年来，Go已经在许多领域获得了广泛采用，尤其是服务器端开发。出于可伸缩性和其他原因，许多公司和开发人员已经转向使用其他语言开发他们的应用程序。Go还提供了跨一些支持语言的交叉编译，如C和<a href="https://blog.logrocket.com/exploring-carbon-new-superset-c-plus-plus/"> C++ </a>，并且有许多工具可以将其他语言交叉编译到Go，反之亦然。</p>
<p>迁移到一种新的编程语言可能很复杂，这是一个需要仔细规划和考虑的过程；然而，成功的迁移可能证明对您的应用有益。</p>
<p>本文概述了从<a href="https://blog.logrocket.com/node-js-vs-python-how-to-choose-the-best-technology-develop-backend/"> Node.js、Python </a>或<a href="https://blog.logrocket.com/when-to-use-rust-when-to-use-golang/"> Rust to Go </a>的迁移过程。我们还将讨论成功迁移的最佳实践和技巧。</p>
<p><em>向前跳转:</em></p>

<h2 id="migration-process">迁移过程</h2>
<p>在语言之间进行迁移之前，您首先要考虑的事情之一是语言特性和您想要利用的特性之间的权衡。</p>
<p>移植代码库不仅仅是重写或翻译代码库以获得相同的功能。各种编程语言有不同的特性，并在多个特性上进行权衡。</p>
<p>例如，大多数垃圾收集语言都以内存管理的快速访问为代价，这对于构建像操作系统和浏览器这样的低级软件可能很重要。这里有几个可行的步骤来迁移你现有的代码库。</p>
<h3 id="migrating-existing-codebases-go">将您现有的代码库迁移到Go</h3>
<p>首先，您需要分析您当前的代码库，以识别迁移中可能出现的潜在问题。比如第三方库支持，功能支持等等。下一步是规划您的迁移过程。</p>
<p>这一步需要您为迁移过程划分或创建一个时间表，以便您的代码库被正确地迁移，而不会破坏现有的代码，并且迁移的需求是可用的。</p>
<p>一旦满足了所有要求，您就可以将现有的代码转换或交叉编译成您选择的语言了——在这种情况下，开始吧。Go生态系统中有自动和手动代码转换的工具，比如<a href="https://github.com/gopherjs/gopherjs"> gopherjs </a>或者<a href="https://github.com/go-python/gopy"> gopy </a>。</p>
<p>在转换/交叉编译成目标语言之后，您需要测试代码，以确保所有的功能都按计划运行，并且实现了移植的本质。您可以执行<a href="https://blog.logrocket.com/a-deep-dive-into-unit-testing-in-go/">单元测试</a>、<a href="https://blog.logrocket.com/advanced-unit-testing-patterns-go/">集成测试</a>，以及性能和压力测试，以确保您的应用程序是稳定的、可伸缩的和可靠的。</p>
<p>典型迁移过程的最后阶段是部署。如果代码按计划运行并且迁移成功，您就可以部署到支持新语言的新的或现有的基础设施。</p>
<p>一个成功的迁移过程是这样的:迁移的最终目标得以实现，代码按计划运行，新特性得到利用。迁移可能很昂贵，尤其是对于大型代码库。因此，为了成功的迁移过程，您必须考虑上述步骤。</p>
<h2 id="migrating-python-go">从Python迁移到Go</h2>
<p>Python是一种高级的、垃圾收集的、解释的编程语言，应用于web开发、数据分析、科学计算和人工智能。像Go一样，Python因其简单性和可读性而闻名，并且这种语言有一个由第三方库和框架组成的繁荣的生态系统<a href="https://blog.logrocket.com/exploring-jspybridge-library-python-javascript/"/>。</p>
<p>将Python代码迁移到Go意味着您正在迁移一个基于web的应用程序。这是因为，在撰写本文时，Go还没有因为其他应用程序而出名，比如Python。从Python移植AI和数据分析代码库到Go可能有风险。</p>
<p>将Python代码库迁移到Go是提高应用程序可伸缩性的好方法。你可以利用Go的<a href="https://blog.logrocket.com/concurrency-patterns-golang-waitgroups-goroutines/">并发特性</a>和数据类型。一旦您熟悉了这两种语言的语法，您就可以手动或自动地迁移您的代码。</p>
<h3 id="manual-migration">手动迁移</h3>
<p>对于手动迁移，您需要考虑数据类型和语法的差异，同时注意您想要利用的特性和编程语言的差异。</p>
<p>以下是一个Python函数的示例，该函数将一组数字作为参数，并返回这些数字的总和:</p>
<pre class="language-python hljs"># python
def sum_numbers(numbers):
    total = 0
    for number in numbers:
        total += number
    return total
</pre>
<p>下面是代码的Go等价物:</p>
<pre class="language-go hljs">// golang
func sumNumbers(numbers []int) int {
    total := 0
    for _, number := range numbers {
        total += number
    }
    return total
}
</pre>
<p>Go不使用列表。该数据类型被称为<a href="https://blog.logrocket.com/go-generics-past-designs-present-release-features/#examples-functions-go-generics:~:text=in%20Go%20today.-,Sorting%20a%20slice%20of%20any%20type,-//%20import%20the%20constraint">片</a>。此外，缩进在Go中不像在Python中那样重要。此外，Python不像Go要求的那样需要函数的返回类型。这些是手动迁移需要考虑的众多因素之一。</p>
<h3 id="automatic-migration">自动迁移</h3>
<p>对于自动迁移，您可以使用代码转换库来完成所有的代码重写，同时手动测试代码是否按预期工作。这里有几个库，可以用来转换Python代码。</p>
<p><a href="https://github.com/go-python/gopy"> gopy包</a>是一个Go库，用于在Go中编写Python扩展。该包提供了从Python调用Go函数的功能，反之亦然，以及许多其他功能。</p>
<p>在工作目录的终端中运行以下命令来安装gopy包:</p>
<pre class="language-shell hljs"># shell
go get github.com/go-python/gopy
</pre>
<p>下面是一个示例，说明如何使用gopy包将Python文件加载到包中，从而将Python代码转换为Go代码:</p>
<pre class="language-go hljs">// golang
package main

import (
        "fmt"

        "github.com/go-python/gopy"
)

func main() {
        // Initialize the Python interpreter
        initErr := gopy.Initialize()
        if initErr != nil {
                fmt.Println(initErr)
                return
        }
        defer gopy.Finalize()

        // Convert the Python code to Go code
        convertedCode, convertErr := gopy.Convert("python_code.py")
        if convertErr != nil {
                fmt.Println(convertErr)
                return
        }

        fmt.Println(convertedCode)
}
</pre>
<p>在代码示例中，<code>Convert</code>函数将Python文件的路径作为参数，并以字符串形式返回等价的Go代码。</p>
<p><a href="https://github.com/jianyuan/py2go"> py2go包</a>提供了一个命令行实用程序，用于将Python代码转换为更广泛的Python结构(从类到函数和模块),并生成惯用的go代码。</p>
<p><a href="https://pkg.go.dev/github.com/esimov/pigo/core"> pigo包</a>包含将Python代码转换为C的工具，然后可以在编译期间编译并与go运行时链接，以生成Go可执行文件。它可以处理各种Python特性，比如类、函数和模块，并且可以生成有效的清晰的C代码。</p>
<p>请记住，在为任何用例部署代码之前，您必须测试代码转换的状态。</p>
<h2 id="migrating-rust-go">从Rust迁移到Go</h2>
<p>据<a href="https://www.rust-lang.org/">官网</a>介绍，Rust是一种流行的系统编程语言，运行速度快得惊人，防止segfaults，保证线程安全。<a href="https://blog.logrocket.com/current-state-rust-web-frameworks/"> Rust </a>由Mozilla基金会于2010年开发，因其性能、可靠性和安全特性在开发者中赢得了声誉。</p>
<p>Rust和Go都是用于构建可伸缩系统的现代编程语言。Rust和Go用于构建服务于许多用户的可伸缩web应用程序。</p>
<p>从设计上来说，Rust和Go在语法和其他方面都非常不同。Go使用垃圾收集器管理内存，不像Rust使用<a href="https://blog.logrocket.com/introducing-the-rust-borrow-checker/">借用检查器</a>来执行其<a href="https://blog.logrocket.com/understanding-ownership-in-rust/">所有权规则</a>以实现灵活性和高效的内存管理。</p>
<p>语言的另一个<a href="https://blog.logrocket.com/comparing-elixir-rust-go/">区别是Rust是静态类型的，而Go是动态类型的。最后，这些语言有不同的并发方法。Rust使用一个由</a><a href="https://blog.logrocket.com/deep-dive-concurrency-rust-programming-language/">线程安全引用和互斥</a>组成的系统来确保安全的数据可访问性，而Go使用<a href="https://blog.logrocket.com/how-use-go-channels/">通道</a>和<a href="https://blog.logrocket.com/concurrency-patterns-golang-waitgroups-goroutines/"> goroutines </a>进行多线程通信。</p>
<p>将Rust代码移植到Go代码的过程是相同的，反之亦然。您需要遵循上面讨论的迁移过程。</p>
<p>这是一个典型的Rust函数，你必须指定函数的返回类型。</p>
<pre class="language-rust hljs">// rust
fn add(x: i32, y: i32) -&gt; i32 {
    x + y
}
</pre>
<p><code>add</code>函数将两个<code>32-bit</code>整数相加，并返回等价的<code>32-bit</code>整数。</p>
<p>下面是<code>add</code>函数的Go等价函数，其中返回类型是从<code>return</code>语句中推断出来的:</p>
<pre class="language-go hljs">// golang
func add(x int, y int) int {
    return x + y
}
</pre>
<p>你需要掌握这两种语言来进行手动和自动转换，因为这两种语言之间有很多差异。与Rust相比，Go更容易学习和使用，因为Rust的学习曲线很陡。你可以用<a href="https://blog.logrocket.com/getting-up-to-speed-with-rust/">这本初学者指南</a>温习铁锈。</p>
<p>不幸的是，在撰写本文时，还没有用于Rust和Go之间自动迁移的代码转换工具。然而，如果你想把你的Go代码库移植到Rust，有一些像<a href="https://github.com/bk-rs/golang-rs"> golang-rs </a>这样的包可以帮助你把<a href="https://blog.logrocket.com/exploring-structs-interfaces-go/"> Go结构</a>转换成<a href="https://blog.logrocket.com/fundamentals-for-using-structs-in-rust/"> Rust结构</a>。</p>
<h2 id="migrating-node-js-go">从Node.js迁移到Go</h2>
<p>JavaScript是一种通用的编程语言，主要用于创建交互式动态网站和网络应用。JavaScript可以在浏览器、移动设备和许多引擎上运行，这使得JavaScript适合<a href="https://blog.logrocket.com/building-web-components-with-webc-vanilla-javascript/">为许多环境构建前端和后端</a>应用程序。</p>
<p>JavaScript和Go都被用作后端语言，但这两种语言之间存在差异。比如JavaScript是动态类型的语言，而Go是静态类型的。Go有对并发的支持，JavaScript没有对并发操作的原生支持。</p>
<p>从JavaScript到Go的手动代码迁移过程与上面的过程相同。当您手动浏览每一行并重写相应的代码时，您将需要相当好的两种语言的专业知识。</p>
<p>JavaScript中有一个将两个整数相加的函数:</p>
<pre class="language-javascript hljs">// javascript
function add(x, y) {
  return x + y;
}
</pre>
<p>下面是用Go编写的相应代码:</p>
<pre class="language-go hljs">// golang
func add(x int, y int) int {
  return x + y
}
</pre>
<p>Go函数需要输入参数和返回类型。但是，JavaScript使用半列，没有缩进。</p>
<p>对于自动代码迁移，您可以使用gopherjs包将JavaScript代码转换成Go，反之亦然，尽管JavaScript to Go功能还不成熟。</p>
<p>在工作目录的终端中运行这个命令来安装gopherjs包:</p>
<pre class="language-shell hljs"># shell
go get github.com/gopherjs/gopherjs
</pre>
<p>下面是一个将JavaScript函数转换成Go代码的例子:</p>
<pre class="language-go hljs">// golang
import (
        "fmt"
        "github.com/gopherjs/gopherjs/js"
)

func main() {
        // Convert the JavaScript code to Go code using GopherJS
        convertedCode := js.Global.Get("eval").Invoke("(function() { return 'Hello, World!'; })()")

        // Print the result of the converted code
        fmt.Println(convertedCode.String()) // Output: "Hello, World!"
}
</pre>
<p>该示例使用JavaScript中的<code>eval</code>函数执行一个JavaScript函数，该函数返回字符串“Hello，World！”与<code>fmt</code>包装一起印刷在控制台上。</p>
<h2>结论</h2>
<p>本文是Rust、Node.js和Python编程语言的迁移指南。您了解了迁移过程以及语言和Go之间的差异，并且概述了使用一些Go包的自动代码迁移。</p>
<p>在我看来，代码迁移过程中最关键的一步是测试代码的错误，你不应该为了避免破坏现有的功能而跳过这一步。</p><div class="code-block code-block-23">
<div class="blog-plug inline-plug node-plug"><h2>200只<img src="../Images/61167b9d027ca73ed5aaf59a9ec31267.png" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2019/10/green-check.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" class=" jetpack-lazy-image" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/10/green-check.png"/> <noscript> <img data-lazy-fallback="1" src="../Images/61167b9d027ca73ed5aaf59a9ec31267.png" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/10/green-check.png"/> </noscript>显示器出现故障，生产中网络请求缓慢</h2><p>部署基于节点的web应用程序或网站是容易的部分。确保您的节点实例继续为您的应用程序提供资源是事情变得更加困难的地方。如果您对确保对后端或第三方服务的请求成功感兴趣，</p><a href="https://lp.logrocket.com/blg/node-signup" target="_blank">try LogRocket</a><p>. </p><a class="signup" href="https://lp.logrocket.com/blg/node-signup" target="_blank" rel="noopener noreferrer"><img src="../Images/cae72fd2a54c5f02a6398c4867894844.png" alt="LogRocket Network Request Monitoring" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2019/12/network-request-filter-2-1.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" class=" jetpack-lazy-image" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/12/network-request-filter-2-1.png"/><noscript><img data-lazy-fallback="1" src="../Images/cae72fd2a54c5f02a6398c4867894844.png" alt="LogRocket Network Request Monitoring" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/12/network-request-filter-2-1.png"/></noscript></a><a href="https://lp.logrocket.com/blg/node-signup" target="_blank" rel="noopener noreferrer">https://logrocket.com/signup/</a><p>LogRocket 就像是网络和移动应用程序的DVR，记录下用户与你的应用程序交互时发生的一切。您可以汇总并报告有问题的网络请求，以快速了解根本原因，而不是猜测问题发生的原因。</p><p>LogRocket检测您的应用程序以记录基线性能计时，如页面加载时间、到达第一个字节的时间、慢速网络请求，还记录Redux、NgRx和Vuex操作/状态。</p><a class="signup" href="https://lp.logrocket.com/blg/node-signup" target="_blank" rel="noopener noreferrer">Start monitoring for free</a><p>. </p></div>
</div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
<html>
<head>
<title>Creating custom themes with Tailwind CSS - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>用顺风 CSS 创建自定义主题</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/creating-custom-themes-tailwind-css/#0001-01-01">https://blog.logrocket.com/creating-custom-themes-tailwind-css/#0001-01-01</a></blockquote><div><article class="article-post">
<p>为你的网站提供不同的主题有很大的吸引力。它不仅允许你通过点击一个按钮来改变网站的整体外观，而且它也成为了一个重要的辅助功能。</p>
<p>使用<a href="https://blog.logrocket.com/theming-react-components-tailwind-css/" target="_blank" rel="noopener"> Tailwind CSS </a>有多种方式来创建定制主题，这是一个实用的 CSS 框架。在本文中，我们将介绍实现替换主题的各种方法以及每种方法的优缺点。</p>
<h2>使用插件主题化顺风 CSS</h2>
<p>主题化你的顺风 CSS 网站最简单的方法是在一个模式中使用你的颜色(主题),并启用一个插件如<a href="https://nightwindcss.com/" target="_blank" rel="noopener"> Nightwind </a>来反转它。例如，Nightwind 会对你的调色板进行映射，使光线模式下的刻度颜色<code>500</code>变成黑暗模式下的<code>400</code>，或者一种模式下的<code>bg-red-900</code>变成另一种模式下的<code>bg-red-50</code>。</p>
<p>为了防止 Nightwind 中的这种着色反转，您可以使用实用程序类<code>nightwind-prevent</code>，该类禁用 Nightwind 对元素的效果，而不影响其后代节点。另一方面，使用<code>nightwind-prevent-block</code>也涵盖了后代。</p>
<p>您可以在此查看一个活生生的例子:</p>
<blockquote class="embedly-card" data-card-controls="1" data-card-align="center" data-card-theme="light">

<p>一个为 Tailwind CSS 开发的高级在线平台，让你可以直接在浏览器中使用 Tailwind 的所有构建时特性。</p>
</blockquote>
<p/>
<h3>赞成使用夜风主题</h3>
<ul>
<li>需要最少努力的自动化过程</li>
<li>某些插件效果通常可以被覆盖</li>
</ul>
<h3>使用夜风的缺点</h3>
<ul>
<li>太确定了。例如，如果你使用<code>bg-white</code>作为网站背景，它的黑暗模式变体是令人不愉快的漆黑</li>
</ul>
<h3>夜风的替代品:</h3>

<h2>使用内置的黑暗模式来设置顺风 CSS 的样式</h2>
<p>以<code>variant</code>的形式，Tailwind 提供了一个主题化 API，它提供了我们将在本文中讨论的所有方法中最强的控制。默认情况下，<code>dark</code>变量只对与颜色相关的类启用，比如文本、背景和边框颜色。</p>
<pre class="language-css hljs">&lt;p class="text-black dark:text-white"&gt;The quick brown fox jumps over the lazy dog&lt;/p&gt;</pre>
<p>使用这个标记，<code>dark:text-white</code>类将在启用黑暗模式时将段落变白。这是一种比使用插件更加明确和强大的主题化方法。</p>
<p>使用这个 API，你可以创建一个在黑暗和光明模式下看起来完全不同的站点。这里，我们根据主题展示了不同的图像:</p>
<pre class="language-css hljs">&lt;div&gt;
  &lt;img class="dark:hidden" src="./sun.png" alt="the sun"&gt;
  &lt;img src="./moon.png" alt="the moon"&gt;
&lt;/div&gt;</pre>
<p><a href="https://twitter.com/quarterdeck/status/1350416361701470210" target="_blank" rel="noopener">这是 Tailwind </a>中黑暗模式 API 背后的许多可能性的主要例子，当处于黑暗模式时，网站的整个外观和感觉都会改变，而不仅仅是反转颜色:</p>
<p><img data-attachment-id="64997" data-permalink="https://blog.logrocket.com/creating-custom-themes-tailwind-css/ezgif-com-gif-maker_1/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2021/09/ezgif.com-gif-maker_1.gif" data-orig-size="600,375" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="custom-theming-tailwindcss" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2021/09/ezgif.com-gif-maker_1-300x188.gif" data-large-file="https://blog.logrocket.com/wp-content/uploads/2021/09/ezgif.com-gif-maker_1.gif" decoding="async" class="aligncenter size-full wp-image-64997 jetpack-lazy-image" src="../Images/8776329fc5ade04bb37f91add40ec862.png" alt="" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2021/09/ezgif.com-gif-maker_1.gif?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2021/09/ezgif.com-gif-maker_1.gif"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="64997" data-permalink="https://blog.logrocket.com/creating-custom-themes-tailwind-css/ezgif-com-gif-maker_1/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2021/09/ezgif.com-gif-maker_1.gif" data-orig-size="600,375" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="custom-theming-tailwindcss" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2021/09/ezgif.com-gif-maker_1-300x188.gif" data-large-file="https://blog.logrocket.com/wp-content/uploads/2021/09/ezgif.com-gif-maker_1.gif" decoding="async" loading="lazy" class="aligncenter size-full wp-image-64997" src="../Images/8776329fc5ade04bb37f91add40ec862.png" alt="" data-original-src="https://blog.logrocket.com/wp-content/uploads/2021/09/ezgif.com-gif-maker_1.gif"/></noscript>
<h2>使用顺风 CSS 启用黑暗模式</h2>
<p>Tailwind 支持两种黑暗模式变体策略:<code>media</code>和<code>class</code>。</p>
<pre class="language-css hljs">// tailwind.config.js
module.exports = {
  darkMode: 'media', // or 'class'
}</pre>
<p><code>media</code>策略通过查询<a href="https://blog.logrocket.com/new-media-queries-you-need-to-know/#preferscolorscheme" target="_blank" rel="noopener"> <code>prefer-color-scheme</code> </a>媒体查询，从用户自己的操作系统设置中为黑暗模式选择当前主题，生成如下所示的 CSS:</p>
<pre class="language-css hljs">@media (prefers-color-scheme: dark) {
  .dark\:bg-white {
    background-color: white;
  }
}</pre>
<p>使用这种策略，用户只能通过在操作系统级别上切换黑暗模式偏好来切换主题。</p>
<p>这就是<code>class</code>策略的用武之地。它通过使用 CSS 作用于类名<code>dark</code>来启用黑暗模式，从而为您提供对应用程序当前主题的更多控制。这意味着黑暗模式将为任何具有<code>dark</code>类的元素的后代启用:</p>
<pre class="language-css hljs">.dark .dark\:bg-white {
  background-color: white;
}</pre>
<pre>&lt;div&gt;
  &lt;!-- the text will be black --&gt;
  &lt;p class="text-black dark:text-white"&gt;&lt;/p&gt;
&lt;/div&gt;

&lt;div class="dark"&gt;
  &lt;!-- the text will be white --&gt;
  &lt;p class="text-black dark:text-white"&gt;&lt;/p&gt;
&lt;/div&gt;</pre>
<p>通常，<code>dark</code>类进入根<code>html</code>标签来启用或禁用整个应用程序的黑暗模式。然而，通过使用<code>class</code>变体，默认用户操作系统偏好的便利性不再是自动的。</p>
<p>我们可以通过在<code>html</code>标签上硬编码(或排除)<code>dark</code>类来为所有用户选择一个默认主题，但更动态的方法是将当前主题存储在<code>localStorage</code>中，并使用操作系统偏好作为后备。</p>
<p>为此，我们可以使用以下 JavaScript 代码:</p>
<pre class="language-javascript hljs">const isDarkSet = localStorage.theme === 'dark';
const isThemeStored = 'theme' in localStorage;
const isDarkPrefered = window.matchMedia('(prefers-color-scheme: dark)').matches;

if (isDarkThemeSet || (!isThemeStored &amp;&amp; isDarkPrefered)) {
  document.documentElement.classList.add('dark')
} else {
  document.documentElement.classList.remove('dark')
}</pre>
<p>这需要尽可能早地放在文档中，以避免<a href="https://en.wikipedia.org/wiki/Flash_of_unstyled_content" target="_blank" rel="noopener">闪现未样式化的内容</a> (FOUC)，其中站点在页面变得可见后改变其 CSS。</p>
<p>为此，我们可以在<code>index.html</code>文件中的<code>html</code>标签下的<code>script</code>标签中添加这段代码。例如，一些 web 框架，如 Next.js，不直接公开<code>index.html</code>文件。接下来，代码必须放在<code><a href="https://nextjs.org/docs/advanced-features/custom-document" target="_blank" rel="noopener">pages/_document.js</a></code>里面。</p>
<p>之后，要启用或禁用黑暗模式，我们可以切换<code>dark</code>类并更新<code>localStorage</code>:</p>
<pre class="language-css hljs">const themeSwitch = document.querySelector('.switch')

themeSwitch.addEventListener('click', () =&gt; {
  document.documentElement.classList.toggle('dark')
  localStorage.theme = localStorage.theme === 'dark' ? 'light' : 'dark'
})
</pre>
<blockquote class="embedly-card" data-card-controls="1" data-card-align="center" data-card-theme="light">

<p>一个为 Tailwind CSS 开发的高级在线平台，让你可以直接在浏览器中使用 Tailwind 的所有构建时特性。</p>
</blockquote>
<p/>
<h3>在顺风 CSS 中启用黑暗模式的好处</h3>
<ul>
<li>主题化影响的不仅仅是颜色。它可以影响资产、布局等。</li>
</ul>
<h3>骗局</h3>
<ul>
<li>变得冗长，因为标记中有更多的实用程序类</li>
<li>限于两个主题</li>
</ul>
<h2>通过 CSS 自定义属性使用顺风 CSS 进行多主题化</h2>
<p>CSS 自定义属性的主要用途之一是创建主题。在 Tailwind 中，使用自定义属性不像使用普通 CSS 那样简单，这是因为它是在幕后组成的。</p>
<p>例如，支持边框颜色实用程序是毫不费力的，因为在<code>border</code>简写旁边有一个手写的<code>border-color</code>属性。但是，支持文本不透明度并不那么简单，因为 CSS 不提供文本不透明度属性。</p>
<p>Tailwind CSS 使用 CSS 自定义属性来规避这些限制。为了使文本不透明度实用程序类成为可能，文本颜色类是这样编写的:</p>
<pre class="language-css hljs">.text-black {
  --text-opacity: 1;
  color: rgba(0, 0, 0, var(--text-opacity));
}</pre>
<p>使用这个，可以通过改变<code>--text-opacity</code>自定义属性来改变元素的文本不透明度:</p>
<pre class="language-css hljs">.text-opacity-50 {
  --text-opacity: 0.5;
}</pre>
<p>将这两个类组合在一个元素中——<code>text-black text-opacity-50</code>——将得到预期的半透明文本。</p>
<h3>在顺风 CSS 中扩展配置</h3>
<p>与使用真实颜色扩展 Tailwind 的默认调色板不同，Tailwind 无法访问自定义属性背后的值来正确添加中间自定义属性:</p>
<pre>module.exports = {
  theme: {
    extend: {
      colors: {
        white: '#ffffff',
        variable: 'var(--white-color)',
      },
    },
  },
}</pre>
<p>顺风可以将十六进制颜色转换成 T2 颜色。对于<code>variable</code>颜色就不一样了。</p>
<p>幸运的是，Tailwind 通过使用颜色函数而不是字符串来支持添加中间自定义属性:</p>
<pre class="language-css hljs">module.exports = {
  theme: {
    extend: {
      colors: {
        variable: ({ opacityValue }) =&gt;
          opacityValue
            ? `rgba(var(--white-color), ${opacityValue})`
            : `rgb(var(--white-color))`,
      },
    },
  },
}</pre>
<p>该函数接收<code>opacityValue</code>作为参数，我们可以用它来创建颜色实用程序类。这意味着我们必须使用<code>RGB</code>值来定义我们的自定义属性。</p>
<h3>使用自定义属性创建主题</h3>
<p>要使用自定义属性创建主题，我们可以使用调色板扩展<code>base</code>样式:</p>
<pre class="language-css hljs">@tailwind base;
@tailwind components;
@tailwind utilities;

@layer base {
  :root {
    --bg-primary: 255, 255, 255;
    --bg-secondary: 245, 246, 247;
    --bg-tertiary: 238, 238, 238;

    --text-primary: 0, 0, 0;
    --text-secondary: 56, 63, 74;
    --text-tertiary: 255, 255, 255;
  }
}</pre>
<p>在我们的<code>tailwind.config.js</code>文件中，我们可以使用<code>generateColorClass</code>函数将它们注册为新颜色:</p>
<pre>const generateColorClass = (variable) =&gt; {
  return ({ opacityValue }) =&gt;
    opacityValue
      ? `rgba(var(--${variable}), ${opacityValue})`
      : `rgb(var(--${variable}))`
}

const textColor = {
  primary: generateColorClass('text-primary'),
  secondary: generateColorClass('text-secondary'),
  tertiary: generateColorClass('text-tertiary'),
}

const backgroundColor = {
  primary: generateColorClass('bg-primary'),
  secondary: generateColorClass('bg-secondary'),
  tertiary: generateColorClass('bg-tertiary'),
}

module.exports = {
  theme: {
    extend: {
      textColor,
      backgroundColor,
    },
  },
}
</pre>
<p>这将为<code>text</code>和<code>background</code>颜色属性创建<code>primary</code>、<code>secondary</code>和<code>tertiary</code>实用程序类。</p>
<p>为了提供伴随这些实用程序类的多个主题，我们可以更新我们的<code>base</code>样式:</p>
<pre class="language-css hljs">@layer base {
  :root {
    --bg-primary: 255, 255, 255;
    --bg-secondary: 245, 246, 247;
    --bg-tertiary: 238, 238, 238;

    --text-primary: 0, 0, 0;
    --text-secondary: 56, 63, 74;
    --text-tertiary: 255, 255, 255;
  }

  .dark {
    /*
    * update all colors:
    * --bg-primary: ...
    */
  }

  .coffee {
    /*
    * update all colors:
    * --bg-primary: ...
    */
  }
}</pre>
<p>和前面的方法很相似，我们可以通过在根<code>html</code>元素上有一个<code>dark</code>或<code>coffee</code>类来启用这些主题。</p>
<p> </p>
<blockquote class="embedly-card" data-card-controls="1" data-card-align="center" data-card-theme="light">

<p>一个为 Tailwind CSS 开发的高级在线平台，让你可以直接在浏览器中使用 Tailwind 的所有构建时特性。</p>
</blockquote>
<p/><div class="code-block code-block-54">
<hr/>
<h3>更多来自 LogRocket 的精彩文章:</h3>

<hr/></div>
<h3>使用 CSS 自定义属性创建主题的优点</h3>
<ul>
<li>您可以创建无限数量的主题</li>
<li>与内置的黑暗模式变体方法相比，提供了一种自动和轻松的方法，因为内置的黑暗模式将创建更多的实用程序类</li>
</ul>
<h3>使用自定义属性的缺点</h3>
<ul>
<li>您不能轻易覆盖自定义属性</li>
</ul>
<h2>结论</h2>
<p>在本文中，我们介绍了如何使用插件、内置的黑暗模式变体和 CSS 自定义属性，使用 Tailwind CSS 对您的应用程序进行主题化。每种方法在使用前都有利弊要考虑，其中一种方法可能最大限度地控制，而另一种方法则优先考虑易用性。感谢阅读。</p><div class="code-block code-block-25">
<div class="blog-plug inline-plug css-plug"><h2>你的前端是否占用了用户的 CPU？</h2><p>随着 web 前端变得越来越复杂，资源贪婪的特性对浏览器的要求越来越高。如果您对监控和跟踪生产环境中所有用户的客户端 CPU 使用、内存使用等感兴趣，</p><a target="_blank" href="https://lp.logrocket.com/blg/css-signup">try LogRocket</a><p>.</p><a class="signup" href="https://lp.logrocket.com/blg/css-signup" target="_blank" rel="noopener noreferrer"><img class="alignnone size-full wp-image-46 jetpack-lazy-image" src="../Images/dacb06c713aec161ffeaffae5bd048cd.png" alt="LogRocket Dashboard Free Trial Banner" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2019/12/cpu-memory-usage.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/12/cpu-memory-usage.png"/><noscript><img data-lazy-fallback="1" class="alignnone size-full wp-image-46" src="../Images/dacb06c713aec161ffeaffae5bd048cd.png" alt="LogRocket Dashboard Free Trial Banner" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/12/cpu-memory-usage.png"/></noscript></a><a href="https://lp.logrocket.com/blg/css-signup" target="_blank" rel="noopener noreferrer">https://logrocket.com/signup/</a><p>LogRocket 就像是网络和移动应用的 DVR，记录你的网络应用或网站上发生的一切。您可以汇总和报告关键的前端性能指标，重放用户会话和应用程序状态，记录网络请求，并自动显示所有错误，而不是猜测问题发生的原因。</p><p>现代化您调试 web 和移动应用的方式— <a class="signup" href="https://lp.logrocket.com/blg/css-signup" target="_blank" rel="noopener noreferrer">开始免费监控</a>。</p></div>
</div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
<html>
<head>
<title>A guide to React Native Navigation - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>React 本地导航指南- LogRocket 博客</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/guide-react-native-navigation/#0001-01-01">https://blog.logrocket.com/guide-react-native-navigation/#0001-01-01</a></blockquote><div><article class="article-post">
<p>移动应用最重要的一个方面是拥有不同的屏幕，并能够在它们之间移动，每个屏幕为用户提供不同的用途。</p>
<p>在本文中，我们将了解如何在 React 本机应用程序中启用导航。我们还将通过构建一个电子商务应用程序来了解 React Native 最常用的导航方法— <a href="https://reactnavigation.org/docs/stack-navigator/" target="_blank" rel="noopener">堆栈导航器</a>、<a href="https://reactnavigation.org/docs/bottom-tab-navigator/" target="_blank" rel="noopener">底部标签导航器</a>和<a href="https://reactnavigation.org/docs/drawer-navigator/" target="_blank" rel="noopener">抽屉导航器</a>。</p>
<h2>React 本机导航库</h2>
<p>React Native 本身并没有为你的应用提供任何导航支持。您将需要集成一个第三方库来启用导航。三个最常见的库是:</p>
<ul>
<li><a href="https://reactnavigation.org/" target="_blank" rel="noopener"> React 导航</a>:大多数导航都是在 JavaScript 层中执行的，必要时可以使用本地 API</li>
<li><a href="https://wix.github.io/react-native-navigation/docs/before-you-start/" target="_blank" rel="noopener"> React 本地导航</a>:这使用平台级 API 来执行导航</li>
<li><a href="https://github.com/aksonov/react-native-router-flux" target="_blank" rel="noopener"> React Native Router Flux </a>:这个库在内部使用 React 导航，但是公开了一组不同的 API 来启用导航</li>
</ul>
<p>对于本教程，我们将使用<a href="https://reactnavigation.org/" target="_blank" rel="noopener"> React 导航</a> v6 库创建一个无缝导航体验。</p>
<h2>安装 React 导航</h2>
<p>安装非常简单，但是 React Navigation 需要安装一些对等依赖项:</p>
<pre class="language-bash hljs">yarn add @react-navigation/native
yarn add @react-navigation/native-stack
yarn add react-native-screens 
yarn add react-native-safe-area-context
</pre>
<p>要安装 iOS 的本机依赖项，请运行:</p>
<pre class="language-bash hljs">pod install --project-directory=ios
</pre>
<h3>在 Android 上安装 React 导航</h3>
<p>要在 Android 上完成库安装，我们必须完成一个额外的步骤。打开<code>MainActivity</code>文件并添加以下代码片段:</p>
<pre>@Override
protected void onCreate(Bundle savedInstanceState) {
  // Make sure your import android.os.Bundle
  super.onCreate(null);
}
</pre>
<p>此时，您的项目已经准备好使用我们将介绍的第一种导航类型，堆栈导航。</p>
<h2>在 React Native 中实现堆栈导航</h2>
<p><img data-attachment-id="82341" data-permalink="https://blog.logrocket.com/guide-react-native-navigation/stack-navigation-example/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2021/12/stack-navigation-example.gif" data-orig-size="730,1593" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Stack navigation example" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2021/12/stack-navigation-example-137x300.gif" data-large-file="https://blog.logrocket.com/wp-content/uploads/2021/12/stack-navigation-example-469x1024.gif" decoding="async" class="aligncenter size-full wp-image-82341 jetpack-lazy-image" src="../Images/76ac688076feb9fdf6a06e1ceea0865b.png" alt="Stack Navigation Example" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2021/12/stack-navigation-example.gif?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2021/12/stack-navigation-example.gif"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="82341" data-permalink="https://blog.logrocket.com/guide-react-native-navigation/stack-navigation-example/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2021/12/stack-navigation-example.gif" data-orig-size="730,1593" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Stack navigation example" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2021/12/stack-navigation-example-137x300.gif" data-large-file="https://blog.logrocket.com/wp-content/uploads/2021/12/stack-navigation-example-469x1024.gif" decoding="async" loading="lazy" class="aligncenter size-full wp-image-82341" src="../Images/76ac688076feb9fdf6a06e1ceea0865b.png" alt="Stack Navigation Example" data-original-src="https://blog.logrocket.com/wp-content/uploads/2021/12/stack-navigation-example.gif"/></noscript>
<p>堆栈导航是每个应用程序都有的最基本的导航类型。它用于描述一个逻辑流程，为用户提供执行特定步骤以到达目的地的感觉。</p>
<p>例如，在电子商务应用程序中，常见的导航堆栈类似于:</p>
<blockquote><p>搜索要购买的商品→商品详情→查看购物车→支付→下单</p></blockquote>
<p>让我们看看如何创建<code>Search → Item Detail</code>堆栈。其他屏幕将只是相同过程的复制。</p>
<p>在 React 导航中，所有的屏幕都需要围绕<code>NavigationContainer</code>组件，如下所示:</p>
<pre class="language-typescript hljs">import {NavigationContainer} from '@react-navigation/native';
import React from 'react';
import {SafeAreaView} from 'react-native';


export const MyApp = () =&gt; {
  return (
    &lt;SafeAreaView&gt;
      &lt;NavigationContainer&gt;
        {/* Rest of my components wrapped inside a NavigationContainer */}
      &lt;/NavigationContainer&gt;
    &lt;/SafeAreaView&gt;
  );
};

const styles = StyleSheet.create({
  fullScreen: {flex: 1, alignItems: 'center', justifyContent: 'center'},
});
</pre>
<p>要创建用户可以从一个屏幕导航到另一个屏幕的堆栈，需要记住三个方面:</p>
<ol>
<li><code>createNativeStackNavigator</code>:创建一个堆栈</li>
<li>封装上面创建的堆栈中的所有屏幕(当你看下面的代码时会更清楚)</li>
<li><code>Screen</code>:可以放在<code>Navigator</code>里面的每一个单独的屏幕</li>
</ol>
<p>让我们来扩展一下上面的代码片段。第一步是创建带有两个屏幕的堆栈导航器，<code>Search</code>和<code>ItemDetail</code>。当你从一个屏幕导航到另一个屏幕时，你可能想要传递一些数据，这就是为什么我定义了<code>OrderPlacementStackParams</code>。这是完全可选的。</p>
<p><code>OrderPlacementStack</code>有两个属性:<code>Navigator</code>和<code>Screen</code>。</p>
<pre class="language-typescript hljs">type OrderPlacementStackParams = {
  Search: undefined;
  ItemDetail: {itemId: string};
};

// create the stack navigator below
const OrderPlacementStack = createNativeStackNavigator&lt;OrderPlacementStackParams&gt;();

// If you are not using typescript or do not want to add the types you can do the following
// const OrderPlacementStack = createNativeStackNavigator(); 
</pre>
<p>在<code>NavigationContainer</code>组件中，让我们创建实际的导航器和其中的屏幕。</p>
<pre class="language-typescript hljs">// Add the boilerplate code to create the stack components

export const MyApp = () =&gt; {
  return (
    &lt;SafeAreaView style={{flex:1, backgroundColor:'white'}}&gt;
      &lt;NavigationContainer&gt;
        &lt;OrderPlacementStack.Navigator initialRouteName={'Search'}&gt;
          {/* Your screens go here which will be added in the next step */}
        &lt;/OrderPlacementStack.Navigator&gt;
      &lt;/NavigationContainer&gt;
    &lt;/SafeAreaView&gt;
  );
};
</pre>
<p>既然我们已经准备好了样板文件，让我们从搜索屏幕开始。导航器内的每个屏幕都将被赋予两个道具:</p>

<p>我们将为它们创建类型:</p>
<pre class="language-typescript hljs">type SearchNavigationProp = NativeStackNavigationProp&lt;
  OrderPlacementStackParams,
  'Search'
&gt;;

type SearchRouteProp = RouteProp&lt;OrderPlacementStackParams, 'Search'&gt;;

interface ISearchScreenProps {
  navigation: SearchNavigationProp;
  route: SearchRouteProp;
}

const SearchScreen = ({navigation, route}: ISearchScreenProps) =&gt; {
  return (
    &lt;SafeAreaView style={styles.fullScreen}&gt;
      &lt;TouchableOpacity&gt;
        &lt;Text&gt;Go to Item Detail Screen&lt;/Text&gt;
      &lt;/TouchableOpacity&gt;
    &lt;/SafeAreaView&gt;
  );
};
</pre>
<p>不要太担心现在什么都不做。我们将对其进行整合，以确保您可以从那里转到<code>ItemDetail</code>屏幕。</p>
<p>现在您已经有了<code>SearchScreen</code>组件，让我们将它添加到我们的堆栈中。</p>
<pre class="language-typescript hljs">&lt;NavigationContainer&gt;
    &lt;OrderPlacementStack.Navigator initialRouteName={'Search'}&gt;
      &lt;OrderPlacementStack.Screen name="Search" component={SearchScreen} /&gt;
    &lt;/OrderPlacementStack.Navigator&gt;
&lt;/NavigationContainer&gt;
</pre>
<p>在上面的代码片段中，我们将<code>Screen</code>包装在<code>Navigator</code>属性中。确保<code>Screen</code>的<code>name</code>属性与我们之前定义的<code>OrderPlacementStackParams</code>类型中定义的键相同。</p>
<p>这样，您就完成了创建堆栈导航的整个设置。现在，您所要做的就是对其他屏幕重复相同的步骤。</p>
<h3>在堆栈中的屏幕之间导航</h3>
<p>接下来，让我们尝试添加<code>ItemDetail</code>屏幕，看看我们如何从<code>SearchScreen</code>导航到<code>ItemDetail</code>屏幕。</p>
<pre class="language-typescript hljs">type ItemDetailNavigationProp = NativeStackNavigationProp&lt;
  OrderPlacementStackParams,
  'ItemDetail'
&gt;;

type ItemDetailRouteProp = RouteProp&lt;OrderPlacementStackParams, 'ItemDetail'&gt;;

interface IItemDetailScreenProps {
  navigation: ItemDetailNavigationProp;
  route: ItemDetailRouteProp;
}

const ItemDetailScreen = ({navigation, route}: IItemDetailScreenProps) =&gt; {
  return (
    &lt;SafeAreaView style={styles.fullScreen}&gt;
      &lt;TouchableOpacity&gt;
        &lt;Text&gt;
          `This is the Item Detail Screen with Item Id: ${route.params.itemId}`
        &lt;/Text&gt;
      &lt;/TouchableOpacity&gt;
    &lt;/SafeAreaView&gt;
  );
};
</pre>
<p>现在忽略第 18 行的<code>route.params.itemId</code>。稍后我会解释的。将该屏幕添加到<code>OrderPlacementStack.Navigator</code>中。</p>
<pre class="language-typescript hljs">&lt;NavigationContainer&gt;
  &lt;OrderPlacementStack.Navigator initialRouteName={'Search'}&gt;
    &lt;OrderPlacementStack.Screen name="Search" component={SearchScreen} /&gt;
    {/*  Add the item detail screen as shown below */}
    &lt;OrderPlacementStack.Screen
      name="ItemDetail"
      component={ItemDetailScreen}
    /&gt;
    {/*  Add the item detail screen as shown above */}
  &lt;/OrderPlacementStack.Navigator&gt;
&lt;/NavigationContainer&gt;
</pre>
<p>当我点击<code>Search</code>屏幕中的<strong>转到项目详情屏幕</strong>按钮时，我们需要一种方法转到该屏幕。为了在屏幕间导航，我们将使用<code>navigation</code>道具。您在<code>navigation</code>对象中公开了两个 API，可以帮助您转到不同的屏幕。它们是:</p>
<ol>
<li><code>push</code>:推送屏幕的新实例，即使它已经存在于当前堆栈中</li>
<li><code>navigate</code>:如果组件及其名称存在于当前堆栈中，则进入该屏幕。如果没有，它会创建一个新的屏幕实例，并将其推送到堆栈上</li>
</ol>
<p>使用这些 API，只要它对您的应用程序有意义。我们将使用<code>navigate</code> API，尽管它们有相同的签名。</p>
<h3>在 React Native 中的屏幕间导航时传递属性</h3>
<p>注意在<code>OrderPlacementStackParams</code>中,<code>ItemDetail</code>屏幕需要一个<code>itemId</code>,这是有意义的，因为如果你想显示特定项目的细节，你需要一些标识符。</p>
<p>现在我们将整合<code>TouchableOpacity</code>动作和<code>Search</code>屏幕。用以下代码替换<code>TouchableOpacity</code>:</p>
<pre class="language-typescript hljs">&lt;TouchableOpacity
  onPress={() =&gt; {
    // Here you're asking the navigation stack to push the screen with
    // `ItemDetail` as its identifier
    // with data: {itemId: '1'}
    navigation.navigate('ItemDetail', {itemId: '1'});
  }}&gt;
    &lt;Text&gt;Go to Item Detail Screen&lt;/Text&gt;
&lt;/TouchableOpacity&gt;
</pre>
<p>现在可以使用<code>route</code>道具在<code>ItemDetail</code>屏幕中访问传递的<code>{itemId: 1}</code>数据。</p>
<p><code>route</code>道具有一个<code>params</code>对象，它将包含这个对象。因此，您可以使用<code>route.params.itemId</code>来访问<code>itemId</code>属性。</p>
<h3>配置标题</h3>
<p>默认情况下，React Navigation 为 iOS 和 Android 都设置了一个默认标题，但在大多数情况下，您会想要自定义它。你可以通过使用<code>navigation</code>道具上的<code>setOptions</code>方法来实现。</p>
<p>在<code>setOptions</code>方法中，您返回一个具有某些属性的对象，这些属性将帮助您定制整个标题或标题的某些部分。</p><div class="code-block code-block-54">
<hr/>
<h3>更多来自 LogRocket 的精彩文章:</h3>

<hr/></div>
<p>现在我们来看看如何定制整个标题。你可以通过调用<code>setOptions</code>方法并覆盖<code>header</code>键，用<code>useEffect</code>钩子来实现:</p>
<pre class="language-typescript hljs">useEffect(() =&gt; {
    navigation.setOptions({
      // You can get the reference to navigation and route props here as well if you need it.
      header: ({navigation, route}) =&gt; (
        &lt;View
          style={{height: 56, justifyContent: 'center', alignItems: 'center'}}&gt;
          &lt;Text&gt;Custom Header on Search Screen&lt;/Text&gt;
        &lt;/View&gt;
      ),
    });
}, []);
</pre>
<p>您还可以使用其他键来自定义您的标题。一些常见的有:</p>
<ul>
<li><code>title</code>:返回一个你想要作为屏幕标题的字符串</li>
<li><code>headerLeft</code>:返回一个组件，该组件将被呈现为标题上的左按钮</li>
<li><code>headerRight</code>:返回一个组件，该组件将被呈现为标题上的左按钮</li>
<li><code>headerStyle</code>:为整个 header 组件提供样式</li>
</ul>
<p>如果你想改变标题的默认设置，你可以使用<code>screenOptions</code>属性在<code>Navigator</code>对象本身中设置标题的公共<code>options</code>。</p>
<p>例如，如果您希望标题栏的默认背景颜色为橙色，您可以这样做:</p>
<blockquote><p>调用<code>navigation.setOptions</code> API 将覆盖所有这些默认选项。注意，在这里，我们不是在谈论<code>navigation</code>道具，而是在谈论<code>Navigator</code>对象。</p></blockquote>
<pre class="language-typescript hljs">&lt;NavigationContainer&gt;
  &lt;OrderPlacementStack.Navigator 
    initialRouteName={'Search'} 
     screenOptions={() =&gt; ({
        headerStyle: {backgroundColor: 'orange'},
      })}&gt;
    &lt;OrderPlacementStack.Screen name="Search" component={SearchScreen} /&gt;
    {/*  Add the item detail screen as shown below */}
    &lt;OrderPlacementStack.Screen
      name="ItemDetail"
      component={ItemDetailScreen}
    /&gt;
    {/*  Add the item detail screen as shown above */}
  &lt;/OrderPlacementStack.Navigator&gt;
&lt;/NavigationContainer&gt;
</pre>
<h3>使用 React 导航向后导航</h3>
<p>要返回上一屏幕，使用<code>navigation</code>道具上的<code>goBack</code>方法。</p>
<pre class="language-typescript hljs">navigation.goBack();
</pre>
<h3>模态导航</h3>
<p>模态表示通常表示当前流程中新流程的开始，或者当您希望用户在进入下一步之前采取一些行动时使用。</p>
<p>这些屏幕的动画通常在 iOS 和 Android 上都不同于常规的堆栈导航动画，这使用户感觉他们正在执行一个步骤并进入流程。模态动画告诉用户一个新的流程正在开始。</p>
<p>让我们给我们的<code>OrderPlacementStack</code>添加一个新的屏幕，我们将有模式地呈现它。</p>
<pre class="language-typescript hljs">type OrderPlacementStackParams = {
  Search: undefined;
  ItemDetail: {itemId: string};
  Filter: undefined; // added a new screen called Filter
};

type FilterNavigationProp = NativeStackNavigationProp&lt;
  OrderPlacementStackParams,
  'Filter'
&gt;;
type FilterRouteProp = RouteProp&lt;OrderPlacementStackParams, 'Filter'&gt;;
interface IFilterScreenProps {
  navigation: FilterNavigationProp;
  route: FilterRouteProp;
}
const FilterScreen = ({navigation, route}: IFilterScreenProps) =&gt; {
  return (
    &lt;SafeAreaView style={styles.fullScreen}&gt;
      &lt;Text&gt;{`Filter Screen`}&lt;/Text&gt;
    &lt;/SafeAreaView&gt;
  );
};
</pre>
<p>通过添加这个新屏幕来更新<code>OrderPlacementStack</code>。</p>
<pre class="language-typescript hljs">&lt;OrderPlacementStack.Navigator
      initialRouteName={'Search'}
      screenOptions={() =&gt; ({
        headerStyle: {backgroundColor: 'white'},
      })}&gt;
      &lt;OrderPlacementStack.Screen name="Search" component={SearchScreen} /&gt;
      &lt;OrderPlacementStack.Screen
        name="ItemDetail"
        component={ItemDetailScreen}
      /&gt;
      {/* Added the new FilterScreen here */}
      &lt;OrderPlacementStack.Screen
        name="Filter"
        component={FilterScreen}
        options={{presentation: 'modal'}}
      /&gt;
&lt;/OrderPlacementStack.Navigator&gt;
</pre>
<p>您可以通过将<code>presentation</code>作为<code>modal</code>输入来更新屏幕选项，从而有模式地呈现任何屏幕。</p>
<p>调用下面的方法，<code>Filter</code>屏幕应该有模式地出现:</p>
<pre class="language-typescript hljs">navigation.navigate('Filter');
</pre>
<p>现在让我们在<code>Search</code>屏幕上添加一个按钮。</p>
<pre class="language-typescript hljs">&lt;TouchableOpacity
        onPress={() =&gt; {
          // Here you're asking the navigation stack to push the screen with
          // `ItemDetail` as its identifier
          // with data: {itemId: '1'}
          navigation.push('Filter');
        }}&gt;
        &lt;Text&gt;Go to Filter Screen&lt;/Text&gt;
&lt;/TouchableOpacity&gt;
</pre>
<p><img data-attachment-id="82344" data-permalink="https://blog.logrocket.com/guide-react-native-navigation/swapping-navigation-screens/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2021/12/swapping-navigation-screens.gif" data-orig-size="730,1588" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Swapping navigation screens" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2021/12/swapping-navigation-screens-138x300.gif" data-large-file="https://blog.logrocket.com/wp-content/uploads/2021/12/swapping-navigation-screens-471x1024.gif" decoding="async" class="aligncenter size-full wp-image-82344 jetpack-lazy-image" src="../Images/01cd921c378e9c2fdcf3357b19a6e0f0.png" alt="Swapping Navigation Screens" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2021/12/swapping-navigation-screens.gif?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2021/12/swapping-navigation-screens.gif"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="82344" data-permalink="https://blog.logrocket.com/guide-react-native-navigation/swapping-navigation-screens/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2021/12/swapping-navigation-screens.gif" data-orig-size="730,1588" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Swapping navigation screens" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2021/12/swapping-navigation-screens-138x300.gif" data-large-file="https://blog.logrocket.com/wp-content/uploads/2021/12/swapping-navigation-screens-471x1024.gif" decoding="async" loading="lazy" class="aligncenter size-full wp-image-82344" src="../Images/01cd921c378e9c2fdcf3357b19a6e0f0.png" alt="Swapping Navigation Screens" data-original-src="https://blog.logrocket.com/wp-content/uploads/2021/12/swapping-navigation-screens.gif"/></noscript>
<p>这就完成了堆栈导航中导航屏幕的所有基础。让我们看看底部的选项卡导航。</p>
<h3>在 React Native 中创建底部选项卡导航</h3>
<p><img data-attachment-id="82346" data-permalink="https://blog.logrocket.com/guide-react-native-navigation/bottom-navigation-example/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2021/12/bottom-navigation-example.gif" data-orig-size="730,1593" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Bottom navigation example" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2021/12/bottom-navigation-example-137x300.gif" data-large-file="https://blog.logrocket.com/wp-content/uploads/2021/12/bottom-navigation-example-469x1024.gif" decoding="async" class="aligncenter size-full wp-image-82346 jetpack-lazy-image" src="../Images/1e369aa781b00c4b49ef67a03725c309.png" alt="Bottom Navigation Example" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2021/12/bottom-navigation-example.gif?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2021/12/bottom-navigation-example.gif"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="82346" data-permalink="https://blog.logrocket.com/guide-react-native-navigation/bottom-navigation-example/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2021/12/bottom-navigation-example.gif" data-orig-size="730,1593" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Bottom navigation example" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2021/12/bottom-navigation-example-137x300.gif" data-large-file="https://blog.logrocket.com/wp-content/uploads/2021/12/bottom-navigation-example-469x1024.gif" decoding="async" loading="lazy" class="aligncenter size-full wp-image-82346" src="../Images/1e369aa781b00c4b49ef67a03725c309.png" alt="Bottom Navigation Example" data-original-src="https://blog.logrocket.com/wp-content/uploads/2021/12/bottom-navigation-example.gif"/></noscript>
<p>这一部分将与堆栈导航部分非常相似，因为它使用了非常相似的 API。</p>
<p>让我们以这样的方式重新设计应用程序，有两个底部标签，第一个标签是“商店”，你可以在那里买东西，第二个标签是“个人资料”部分。</p>
<p>让我们首先将整个<code>Item Search</code>和<code>Detail</code>栈提取到它的组件中，并将其称为<code>OrderPlacementStackComponent</code>。现在新建一个<code>ProfileStackComponent</code>。</p>
<pre class="language-typescript hljs">const OrderPlacementStackComponent = () =&gt; {
  return (
    &lt;OrderPlacementStack.Navigator
      initialRouteName={'Search'}
      screenOptions={() =&gt; ({
        header: () =&gt; {
          return &lt;View style={{height: 56, backgroundColor: 'red'}} /&gt;;
        },
      })}&gt;
      &lt;OrderPlacementStack.Screen name="Search" component={SearchScreen} /&gt;
      &lt;OrderPlacementStack.Screen
        name="ItemDetail"
        component={ItemDetailScreen}
      /&gt;
    &lt;/OrderPlacementStack.Navigator&gt;
  );
};

const ProfileStack = createNativeStackNavigator(); // Defined it without the types here for brevity

const SettingsScreen = ({navigation}) =&gt; {
  return (
    &lt;View style={{flex: 1, justifyContent: 'center', alignItems: 'center'}}&gt;
      &lt;TouchableOpacity onPress={() =&gt; navigation.navigate('Login')}&gt;
        &lt;Text&gt;Go to Login Screen&lt;/Text&gt;
      &lt;/TouchableOpacity&gt;
    &lt;/View&gt;
  );
};
const LoginScreen = ({navigation}) =&gt; {
  return (
    &lt;View style={{flex: 1, justifyContent: 'center', alignItems: 'center'}}&gt;
      &lt;Text&gt;Login screen&lt;/Text&gt;
    &lt;/View&gt;
  );
};
const ProfileStackComponent = () =&gt; {
  return (
    &lt;ProfileStack.Navigator initialRouteName={'Settings'}&gt;
      &lt;ProfileStack.Screen name="Settings" component={SettingsScreen} /&gt;
      &lt;ProfileStack.Screen name="Login" component={LoginScreen} /&gt;
    &lt;/ProfileStack.Navigator&gt;
  );
}
</pre>
<h3>安装和使用</h3>
<p>在使用底部选项卡导航之前，您必须安装以下依赖项:</p>
<pre class="language-bash hljs">yarn add @react-navigation/bottom-tabs
</pre>
<p>类似于我们如何创建堆栈导航器，我们必须创建一个选项卡导航器。</p>
<pre class="language-typescript hljs">type BottomTabParams = {
  Store: undefined;
  Profile: undefined;
};

const AppBottomTab = createBottomTabNavigator&lt;BottomTabParams&gt;();
</pre>
<p>让我们用选项卡导航器替换<code>NavigationContainer</code>中的组件。它的结构类似于堆栈导航器，其中有两个属性，即<code>Navigator</code>和<code>Screen</code>，用于构成整个选项卡结构。</p>
<pre class="language-typescript hljs">&lt;NavigationContainer&gt;
  &lt;AppBottomTab.Navigator
    screenOptions={() =&gt; ({
      headerShown: false,
    })}&gt;
    &lt;AppBottomTab.Screen
      name="Store"
      component={OrderPlacementStackComponent}
    /&gt;
    &lt;AppBottomTab.Screen
      name="Profile"
      component={ProfileStackComponent}
    /&gt;
    &lt;/AppBottomTab.Navigator&gt;
&lt;/NavigationContainer&gt;
</pre>
<p>运行应用程序。你会看到一个底部的标签栏，有两个标签，“商店”和“个人资料”</p>
<h3>配置选项卡栏</h3>
<p>通常，您会想要为底部选项卡栏进行自定义:</p>
<ul>
<li>标签图标</li>
<li>当标签为活动标签时的标签图标状态，而当标签为非活动标签时的标签图标状态</li>
<li>标签上的徽章图标</li>
</ul>
<p>我们将像在堆栈导航器中一样使用<code>screenOptions</code>。您可以使用<code>tabBarIcon</code>键返回一个定制的标签栏组件。</p>
<pre class="language-typescript hljs">&lt;NavigationContainer&gt;
    &lt;AppBottomTab.Navigator
      screenOptions={({route}) =&gt; ({
        headerShown: false,
        tabBarActiveTintColor: 'red',
        tabBarInactiveTintColor: 'gray',
        tabBarIcon: ({focused, size, color}) =&gt; {
          return focused ? (
            &lt;CustomFocusedTabbarIcon size={size} color={color} /&gt;
          ) : (
            &lt;CustomUnfocusedTabbarIcon size={size} color={color} /&gt;
          );
        },
      })}&gt;
      &lt;AppBottomTab.Screen
        name="StoreTab"
        component={OrderPlacementStackComponent}
      /&gt;
      {/* ProfileStack component may be another component */}
      &lt;AppBottomTab.Screen
        name="ProfileTab"
        component={ProfileStackComponent}
      /&gt;
    &lt;/AppBottomTab.Navigator&gt;
&lt;/NavigationContainer&gt;
</pre>
<p><code>tabBarIcon</code>属性提供了三个属性作为函数的输入，该函数需要返回您的定制标签栏图标组件:</p>
<ul>
<li><code>focused</code>:该页签是否为当前活动页签</li>
<li><code>size</code>:自定义组件可渲染的大小</li>
<li><code>color</code>:你需要用来渲染组件的颜色。这可以通过使用<code>tabBarActiveTintColor</code>和<code>tabBarInactiveTintColor</code>来覆盖，并且根据选项卡是否为<code>focused</code>,<code>color</code>的值将成为活动色调颜色或非活动色调颜色。</li>
</ul>
<h3>在选项卡间导航</h3>
<p>选项卡之间的导航通过使用<code>navigation</code>对象上的<code>navigate</code> API 来执行:</p>
<pre class="language-typescript hljs">navigation.navigate('ProfileTab') // navigate to the ProfileStackComponent
</pre>
<h3>React Native 中的抽屉导航</h3>
<p><img data-attachment-id="82348" data-permalink="https://blog.logrocket.com/guide-react-native-navigation/drawer-navigation-example/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2021/12/drawer-navigation-example.gif" data-orig-size="730,1593" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Drawer navigation example" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2021/12/drawer-navigation-example-137x300.gif" data-large-file="https://blog.logrocket.com/wp-content/uploads/2021/12/drawer-navigation-example-469x1024.gif" decoding="async" class="aligncenter size-full wp-image-82348 jetpack-lazy-image" src="../Images/0736bd99fd2903e0471aa280ee54a7ab.png" alt="Drawer Navigation Example" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2021/12/drawer-navigation-example.gif?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2021/12/drawer-navigation-example.gif"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="82348" data-permalink="https://blog.logrocket.com/guide-react-native-navigation/drawer-navigation-example/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2021/12/drawer-navigation-example.gif" data-orig-size="730,1593" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Drawer navigation example" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2021/12/drawer-navigation-example-137x300.gif" data-large-file="https://blog.logrocket.com/wp-content/uploads/2021/12/drawer-navigation-example-469x1024.gif" decoding="async" loading="lazy" class="aligncenter size-full wp-image-82348" src="../Images/0736bd99fd2903e0471aa280ee54a7ab.png" alt="Drawer Navigation Example" data-original-src="https://blog.logrocket.com/wp-content/uploads/2021/12/drawer-navigation-example.gif"/></noscript>
<p>现在让我们看看最后一个常见的导航模式:抽屉导航。抽屉导航用于为用户提供一个从抽屉访问应用中所有流程的简单点，以防应用有很多流程(即屏幕)。</p>
<h3>安装抽屉导航</h3>
<pre class="language-bash hljs">yarn add @react-navigation/drawer
yarn add react-native-gesture-handler 
yarn add react-native-reanimated
pod install --project-directory=ios
</pre>
<p>确保在您的<code>index.js</code>中输入以下内容:</p>
<pre class="language-typescript hljs">import 'react-native-gesture-handler';
</pre>
<h2>抽屉导航的使用</h2>
<p>一般来说，应用程序不会在同一个应用程序中同时使用底部标签导航和抽屉导航，所以让我们重新开始。</p>
<p>与前面的章节类似，您首先需要使用<code>createDrawerNavigation</code> API 创建您的<code>DrawerStack</code>。</p>
<pre class="language-typescript hljs">type DrawerAppStackParams = {
  Search: undefined;
  MyOrders: undefined;
};
// Create the Drawer Stack Navigator
const DrawerStack = createDrawerNavigator&lt;DrawerAppStackParams&gt;();
</pre>
<p>接下来，使用<code>DrawerStack</code>对象提供给我们的相同的<code>Navigator</code>和<code>Screen</code>属性创建整个堆栈。</p>
<p>不要忘记将整个堆栈包装在<code>NavigationContainer</code>对象中。</p>
<pre class="language-typescript hljs">export const App = () =&gt; {
  return (
    &lt;SafeAreaView style={{flex: 1, backgroundColor: 'white'}}&gt;
      &lt;NavigationContainer&gt;
        &lt;DrawerStack.Navigator
          initialRouteName={'Search'}&gt;
          &lt;DrawerStack.Screen name={'Search'} component={SearchScreen} /&gt;
          &lt;DrawerStack.Screen name={'MyOrders'} component={MyOrderScreen} /&gt;
        &lt;/DrawerStack.Navigator&gt;
      &lt;/NavigationContainer&gt;
    &lt;/SafeAreaView&gt;
  );
};
</pre>
<p>下面是我如何定义<code>SearchScreen</code>和<code>MyOrderScreen</code>组件的。</p>
<p>这些组件也可能是堆栈导航组件。为了简单起见，我将返回常规的 React 本机组件。</p>
<pre class="language-typescript hljs">const SearchScreen = ({navigation, route}) =&gt; {
  return (
    &lt;SafeAreaView style={styles.fullScreen}&gt;
        &lt;Text&gt;This is the Search Screen&lt;/Text&gt;
    &lt;/SafeAreaView&gt;
  );
};
const MyOrderScreen = ({navigation, route}) =&gt; {
  return (
    &lt;SafeAreaView style={styles.fullScreen}&gt;
      &lt;Text&gt;This is the my orders screen&lt;/Text&gt;
    &lt;/SafeAreaView&gt;
  );
};
</pre>
<p>一旦你运行这个应用程序，你应该可以在屏幕的左上角看到汉堡图标。这是您访问抽屉菜单的方式。您可以导航到您已经声明为抽屉导航的一部分的屏幕(在我们的例子中，是<code>SearchScreen</code>和<code>MyOrderScreen</code>)。</p>
<h2>打开和关闭抽屉</h2>
<p>在上面的部分中，我们看到，只要将整个堆栈包装在<code>DrawerStack</code>中，就会得到一个汉堡包图标，单击它就会打开抽屉。</p>
<p>但是，如果您希望它也出现在按钮点击或屏幕内的任何其他动作上，该怎么办呢？或者，如果您想要创建一个自定义导航堆栈标题，在其中添加您自己的自定义图标来打开抽屉，该怎么办？</p>
<p>您可以使用<code>navigation</code>对象上的<code>openDrawer</code>和<code>closeDrawer</code>API 来实现这一点，该对象被传递到每个屏幕，并且是<code>DrawerStack</code>的一部分。</p>
<pre class="language-typescript hljs">navigation.openDrawer() // opens the drawer
navigation.closeDrawer() // closes the drawer
</pre>
<h2>定制抽屉</h2>
<p>就像前面的部分一样，您可以使用<code>DrawerStack.Navigator</code>组件上的<code>drawerContent</code> prop 定制抽屉。</p>
<p>下面是一个如何使用<code>drawerContent</code>属性返回自定义抽屉组件的例子:</p>
<pre class="language-typescript hljs">const CustomDrawer = ({props, navigation}) =&gt; {
  return (
    &lt;View
      style={{
        justifyContent: 'center',
        alignItems: 'center',
        flex: 1,
      }}&gt;
      &lt;Text&gt;This is a custom drawer&lt;/Text&gt;
    &lt;/View&gt;
  );
};
export const App = () =&gt; {
  return (
    &lt;SafeAreaView style={{flex: 1, backgroundColor: 'white'}}&gt;
      &lt;NavigationContainer&gt;
        &lt;DrawerStack.Navigator
          initialRouteName={'Search'}
          drawerContent={({navigation}) =&gt; {
            const customProps = {}; // You can pass in any custom props here in case you have to
            return &lt;CustomDrawer props={customProps} navigation={navigation} /&gt;;
          }}&gt;
          &lt;DrawerStack.Screen name={'Search'} component={SearchScreen} /&gt;
          &lt;DrawerStack.Screen name={'MyOrders'} component={MyOrderScreen} /&gt;
        &lt;/DrawerStack.Navigator&gt;
      &lt;/NavigationContainer&gt;
    &lt;/SafeAreaView&gt;
  );
};
</pre>
<p>假设您还可以将<code>navigation</code>对象传递给您的定制抽屉组件，那么您也可以使用它在屏幕之间导航。</p>
<p><img data-attachment-id="82350" data-permalink="https://blog.logrocket.com/guide-react-native-navigation/navigating-between-screens/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2021/12/navigating-between-screens.gif" data-orig-size="730,1588" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Navigating between screens" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2021/12/navigating-between-screens-138x300.gif" data-large-file="https://blog.logrocket.com/wp-content/uploads/2021/12/navigating-between-screens-471x1024.gif" decoding="async" class="aligncenter size-full wp-image-82350 jetpack-lazy-image" src="../Images/fd67b8882caa60fe2ddeb46aee8fc7b3.png" alt="Navigating Between Screens" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2021/12/navigating-between-screens.gif?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2021/12/navigating-between-screens.gif"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="82350" data-permalink="https://blog.logrocket.com/guide-react-native-navigation/navigating-between-screens/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2021/12/navigating-between-screens.gif" data-orig-size="730,1588" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Navigating between screens" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2021/12/navigating-between-screens-138x300.gif" data-large-file="https://blog.logrocket.com/wp-content/uploads/2021/12/navigating-between-screens-471x1024.gif" decoding="async" loading="lazy" class="aligncenter size-full wp-image-82350" src="../Images/fd67b8882caa60fe2ddeb46aee8fc7b3.png" alt="Navigating Between Screens" data-original-src="https://blog.logrocket.com/wp-content/uploads/2021/12/navigating-between-screens.gif"/></noscript>
<h2>覆盖默认抽屉的自定义样式</h2>
<p>如果您不想从头开始创建一个定制的抽屉组件，您可以使用<code>DrawerStack.Navigator</code>上的<code>screenOptions</code> prop 来覆盖库提供的抽屉组件的一些基本样式和组件。</p>
<p>您可以使用的一些常用键有:</p>
<ul>
<li><code>drawerActiveTintColor</code>:指定抽屉中活动项目的颜色</li>
<li><code>drawerInactiveTintColor</code>:指定抽屉中非活动项目的颜色</li>
<li><code>drawerStyle</code>:覆盖整个默认抽屉组件的样式</li>
<li><code>drawerLabelStyle</code>:覆盖抽屉中项目的文本样式</li>
</ul>
<p>这里有一个如何使用它的例子:</p>
<pre class="language-typescript hljs">&lt;DrawerStack.Navigator
    initialRouteName={'Search'}
    screenOptions={{
      drawerStyle: {backgroundColor: 'white'},
      drawerActiveTintColor: 'black',
      drawerInactiveTintColor: 'gray',
    }}&gt;
      &lt;DrawerStack.Screen name={'Search'} component={SearchScreen} /&gt;
      &lt;DrawerStack.Screen name={'MyOrders'} component={MyOrderScreen} /&gt;
&lt;/DrawerStack.Navigator&gt;
</pre>
<h2>结论</h2>
<p>在本文中，我们使用 React 导航库介绍了大多数 React 本机应用程序中三种最常见的导航形式。React Navigation 为我们提供了简单的 API，将这些流合并到您的应用程序中。</p><div class="code-block code-block-18">
<div class="blog-plug inline-plug react-native-plug"><h2><a href="https://lp.logrocket.com/blg/react-native-signup"> LogRocket </a>:即时重现 React 原生应用中的问题。</h2><a class="signup" href="https://lp.logrocket.com/blg/react-native-signup" target="_blank" rel="noopener noreferrer"><img class="alignnone size-full wp-image-46 jetpack-lazy-image" src="../Images/110055665562c1e02069b3698e6cc671.png" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2021/10/react-native-plug_v2-2.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2021/10/react-native-plug_v2-2.png"/><noscript><img data-lazy-fallback="1" class="alignnone size-full wp-image-46" src="../Images/110055665562c1e02069b3698e6cc671.png" data-original-src="https://blog.logrocket.com/wp-content/uploads/2021/10/react-native-plug_v2-2.png"/></noscript></a><p><a href="https://lp.logrocket.com/blg/react-native-signup" target="_blank" rel="noopener noreferrer"> LogRocket </a>是一款 React 原生监控解决方案，可帮助您即时重现问题、确定 bug 的优先级并了解 React 原生应用的性能。</p><p>LogRocket 还可以向你展示用户是如何与你的应用程序互动的，从而帮助你提高转化率和产品使用率。LogRocket 的产品分析功能揭示了用户不完成特定流程或不采用新功能的原因。</p><p>开始主动监控您的 React 原生应用— <a class="signup" href="https://lp.logrocket.com/blg/react-native-signup" target="_blank" rel="noopener noreferrer">免费试用 LogRocket】。</a></p></div>
</div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
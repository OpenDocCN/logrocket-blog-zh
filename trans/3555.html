<html>
<head>
<title>Understanding relative and absolute imports in Next.js </title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>了解Next.js中的相对和绝对导入</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/understanding-relative-absolute-imports-next-js/#0001-01-01">https://blog.logrocket.com/understanding-relative-absolute-imports-next-js/#0001-01-01</a></blockquote><div><article class="article-post">
<p>构建一个基于组件的项目，就像React的Next.js框架，需要导入模块或组件文件来创建一个完整的用户界面。</p>
<p>当我们导入模块在文件中使用时，我们必须知道如何确定导入的模块相对于当前文件的位置。要做到这一点，我们必须了解什么是相对和绝对进口。</p>
<p>在这一课中，我们将讨论相对和绝对导入，并学习如何在Next.js应用程序中实现它们。我们将涵盖:</p>

<h2 id="next-js-relative-imports">Next.js相对导入</h2>
<p>在相对导入中，文件的导入路径应该相对于导入语句所在的位置。相对导入一般以<code>./</code>、<code>../</code>开头，以此类推。</p>
<p>让我们考虑一个典型的Next.js文件结构:</p>
<pre class="language-javascript hljs">project
    ├── components
    │      ├── Footer.js
    │      ├── Header.js
    │      └── Layout.js
</pre>
<p>通常，当我们有像<code>Header.js</code>和<code>Footer.js</code>这样的包含可以跨多个页面共享的内容的文件时，我们会将它们导入到一个<code>Layout.js</code>文件中来组成网页。如果我们在<code>Layout.js</code>中正确导入这些组件文件，我们将在顶部得到如下导入:</p>
<pre class="language-javascript hljs">import Header from './Header';
import Footer from './Footer';
</pre>
<p>文件扩展名默认为<code>.js</code>，所以我们在文件路径中忽略了它。</p>
<p>现在，让我们来分解一下<code>''</code>中的路径:</p>
<p>在路径中添加<code>./</code>意味着JavaScript将查找相对于“当前”目录的文件。这是因为<code>Header.js</code>和<code>Footer.js</code>文件与<code>Layout.js</code>文件位于同一个文件夹中——在本例中是<code>components</code>文件夹。</p>
<p>此外，我们在Next.js中有一个<code>pages/_app.js</code>文件，让我们使用<code>Layout</code>组件来包装顶级的<code>Component</code>。因此，让我们考虑以下更新的结构:</p>
<pre class="language-javascript hljs">project
    ├── components
    │      ├── Footer.js
    │      ├── Header.js
    │      └── Layout.js     
    │── pages
    │      ├── _app.js
    │      ├── ...
</pre>
<p>现在，在<code>pages/_app.js</code>文件中导入<code>Layout.js</code>文件的<code>Layout</code>组件，如下所示:</p>
<pre class="language-javascript hljs">import Layout from '../components/Layout';
</pre>
<p>在<code>pages/_app.js</code>文件内的相对文件路径中使用<code>../</code>可以让我们跳出当前目录——<code>pages</code>——这样我们就可以进入<code>components</code>文件夹来访问<code>Layout.js</code>文件。</p>
<p>让我们看另一个例子。假设我们有以下文件结构:</p>
<pre class="language-javascript hljs">project
   ...
    │── pages
    │      ├── blog
    │      │    │── index.js
    │      │    └── ...
    │      ├── _app.js
    │      ├── ...    
    │── styles
    │      ├── Blog.module.css
    │      ├── ...
</pre>
<p>让我们分解一下如何将<code>Blog.module.css</code>文件导入到<code>pages/blog/index.js</code>文件中:</p>
<p>首先，我们将跳出当前目录——目录<code>blog</code>——进入父目录— <code>pages</code> —在我们的文件路径中使用<code>../</code>。</p>
<p>然后，从<code>pages</code>目录，我们也将进入它的父目录——根目录——所以相对路径现在看起来像这样:<code>../../</code>。</p>
<p>然后我们将从根目录进入<code>styles</code>目录，因此路径看起来像<code>../../styles</code>。</p>
<p>最后，我们可以访问<code>Blog.module.css</code>，所以我们有:<code>../../styles/Blog.module.css</code>。</p>
<p>如果我们将上述步骤付诸实施，导入和文件路径将如下所示:</p>
<pre class="language-javascript hljs">import styles from '../../styles/Blog.module.css';
</pre>
<p>总之，我们在一个文件中使用<code>./</code>来引用一个与该文件位于同一目录中的模块。同样，我们在文件中使用<code>../</code>来引用父目录中的模块，在文件中使用<code>../../</code>来引用父目录中的模块，等等。</p>
<h3 id="drawback-relative-imports">相对进口退税</h3>
<p>相对进口并不总是友好的。事实上，他们可能会很困惑！正如我们在上面看到的，我们必须仔细跟踪我们当前所在的目录的级别。</p>
<p>此外，相对导入会导致糟糕的开发体验，尤其是在复杂的项目中。如果我们的应用程序增长，我们可能最终会得到一个看起来像这样的路径:</p>
<pre class="language-javascript hljs">'../../../styles/Blog.module.css';
</pre>
<p>对于嵌套非常深的路径，该路径可能看起来更加复杂。</p>
<p>如果我们更改文件位置，问题可能会恶化，因为这可能需要我们更新文件路径。为了改善开发人员的体验，我们将学习如何配置Next.js项目来支持绝对导入。</p>
<h2 id="next-js-absolute-imports">Next.js绝对导入</h2>
<p>绝对导入提供了一种直接导入模块的方法。此导入类型指定从项目根目录开始的路径。</p>
<p>现在，不用像在相对导入的情况下那样担心跟踪目录级别:</p>
<pre class="language-javascript hljs">'../../../styles/Blog.module.css';
</pre>
<p>我们将有一个更干净的方法，看起来像这样:</p>
<pre class="language-javascript hljs">'styles/Blog.module.css';
</pre>
<p>在上面的代码中，我假设项目根目录下存在<code>styles</code>目录。</p>
<p>我们还可以使用一个别名，如下所示:</p>
<pre class="language-javascript hljs">'@styles/Blog.module.css';
</pre>
<p>让我们仔细看看在Next.js项目中使用绝对导入。</p>
<h3 id="creating-jsconfig-json-file">创建一个<code>jsconfig.json</code>文件</h3>
<p><code>jsconfig.json</code>文件让我们为一个项目指定一个基本目录。从9.4版本开始，Next.js允许我们使用这个文件来标识根文件，并执行绝对导入所需的路径映射。</p>
<p>首先，我们将在项目的根目录下创建一个<code>jsconfig.json</code>,并添加以下配置:</p>
<pre class="language-json hljs">{
  "compilerOptions": {
    "baseUrl": "."
  }
}
</pre>
<p>注意<a href="https://blog.logrocket.com/using-next-js-with-typescript/">如果我们使用的是TypeScript </a>，我们会在<code>tsconfig.json</code>中添加代码。</p>
<p><code>baseUrl</code>选项让我们指定基目录来解析模块。通过分配一个<code>.</code>，JavaScript或TypeScript将在与<code>jsconfig.json</code>相同的目录中查找文件——即根目录。</p>
<p>因此，我们之前的相对导入示例如下所示:</p>
<pre class="language-javascript hljs">import styles from '../../styles/Blog.module.css';
</pre>
<p>现在将如下所示:</p>
<pre class="language-javascript hljs">import styles from 'styles/Blog.module.css';
</pre>
<p>同样，在上面的代码中，我假设项目根目录下存在<code>styles</code>目录。</p>
<p>注意，每当我们修改<code>jsconfig.json</code>或<code>tsconfig.json</code>文件时，我们必须重启dev服务器。</p>
<h3 id="configuring-baseurl">配置<code>baseUrl</code></h3>
<p>开发人员通常会在项目根目录下创建一个<code>src</code>文件夹来保存工作文件。让我们考虑以下结构:</p>
<pre class="language-javascript hljs">project
   ...
    │── src
    │    ├── components    
    │    │── pages
    │    │── styles
    │    │── ...
    │
    │── jsconfig.json
</pre>
<p>在这种情况下，我们可以通过将<code>baseUrl</code>更新为指向<code>src</code>来告诉JavaScript或TypeScript从<code>src</code>文件夹开始查找文件:</p>
<pre class="language-javascript hljs">{
  "compilerOptions": {
    "baseUrl": "src"
  }
}
</pre>
<p>文件中指定的<code>src</code>目录必须相对于项目根目录。现在，这个更新将允许从<code>src</code>目录绝对导入。</p>
<h2 id="configuring-module-aliases-simplify-next-js-absolute-imports">配置模块别名以简化Next.js绝对导入</h2>
<p>对于包含文件的不同层次的深度嵌套目录的更重要的项目，我们可能希望创建定制的模块别名来匹配不同的目录，而不是只匹配基本目录。</p>
<p>考虑以下结构:</p>
<pre class="language-javascript hljs">project
   ...
    │── src
    │    ├── components 
    │    │       │── homePage
    │    │       │      │── Hero.js
    │    │       │      │── Testimonial.js
    │    │       │      │── ...               
    │    │       │── blogPage
    │    │       │── ...  
    │    │── pages
    │    │     │── index.js
    │    │     │── ... 
    │    │── styles
    │    │── ...
    │
    │── jsconfig.json
</pre>
<p>如我们所知，通过使用相对导入，我们可以从<code>pages/index.js</code>内部导入<code>Testimonial.js</code>组件文件，如下所示:</p>
<pre class="language-javascript hljs">import Testimonial from '../components/homePage/testimonial'
</pre>
<p>我们还学习了使用绝对导入来简化上述过程，因此我们有以下内容:</p>
<pre class="language-javascript hljs">import Testimonial from 'components/homePage/testimonial'
</pre>
<p>现在，通过配置模块别名，我们可以进一步简化绝对导入，这样我们可以得到以下内容:</p>
<pre class="language-javascript hljs">import Testimonial from '@homePage/testimonial' 
</pre>
<p>让我们探索一下如何使用<code>paths</code>选项来实现这一点。</p>
<h3 id="paths-option"><code>paths</code>选项</h3>
<p>在配置中添加一个<code>paths</code>选项可以让我们配置模块别名。考虑到上面的文件结构，我们将更新配置文件以包含<code>paths</code>条目。从根开始，<code>jsconfig.json</code>文件看起来像这样:</p>
<pre class="language-json hljs">{
  "compilerOptions": {
    "baseUrl": ".",
    "paths": {
      "@homePage/*": ["src/components/homePage/*"],
      "@blogPage/*": ["src/components/blogPage/*"],
      "@styles/*": ["src/styles/*"],
    }
  }
}
</pre>
<p><code>paths</code>对象包含相对于<code>baseUrl</code>解析的条目。在上面的代码中，条目是相对于项目根的。</p>
<p>如果我们将<code>src</code>指定为<code>baseUrl</code>，那么路径条目将如下所示:</p>
<pre class="language-javascript hljs">{
  "compilerOptions": {
    "baseUrl": "src",
    "paths": {
      "@homePage/*": ["components/homePage/*"],
      "@blogPage/*": ["components/blogPage/*"],
      "@styles/*": ["styles/*"],
    }
  }
}
</pre>
<p>在这种情况下，条目是相对于<code>src</code>目录的，而目录又是相对于项目根目录的。以上代码块都可以工作。</p>
<p>上述配置为中的所有文件创建路径别名:</p>
<ol>
<li><code>homePage</code>文件夹使用<code>@homePage</code></li>
<li><code>blogPage</code>文件夹使用<code>@blogPage</code></li>
<li><code>styles</code>文件夹使用<code>@styles</code></li>
</ol>
<p>所以我们不用<code>components/homePage/Hero</code>，而是用<code>@homePage/Hero</code>。像<a href="https://blog.logrocket.com/understanding-typescripts-benefits-pitfalls/#excellent-code-completion"> VS Code这样的代码编辑器也知道如何为路径自动完成提供适当的智能感知</a>。</p>
<h2 id="next-js-absolute-imports-not-working">如何排除Next.js绝对导入不工作的故障</h2>
<p>如果到目前为止您已经学习了这一课，那么您应该不会遇到绝对导入的问题。然而，我们将提到两个步骤，它们通常有助于解决或防止用户在为绝对导入配置Next.js时遇到的一些常见陷阱。</p>
<p>首先，我们必须确保我们的Next.js版本至少是v9.4。然后，如果我们修改了<code>jsconfig.json</code>配置文件，我们必须总是重新启动Next.js项目。</p>
<p>遵循这两个步骤应该可以避免遇到Next.js absolute imports不工作的问题，或者帮助您解决现有的错误。</p>
<h2 id="migrating-next-js-project-relative-imports-absolute-imports">将Next.js项目从使用相对导入迁移到绝对导入</h2>
<p>到目前为止，我们已经讨论了所有我们需要知道的关于相对和绝对进口的内容。这一节将实现我们在Next.js应用程序中学到的内容。</p>
<p>在另一篇博文中，我们讨论了如何将RSS提要添加到Next.js应用程序中。在那一课中，我们使用了一个Next.js项目，该项目使用相对导入来加载文件。我们将重构模块的路径以使用绝对导入。</p>
<p>让我们克隆这个项目，然后按照步骤来支持绝对导入。</p>
<h3 id="clone-next-js-project">克隆Next.js项目</h3>
<p>使用以下命令克隆项目:</p>
<pre class="language-javascript hljs">git clone https://github.com/Ibaslogic/nextjs-mdx-blog-rss
</pre>
<p>接下来，<code>cd</code>进入项目，并运行将依赖项安装到本地<code>node_modules</code>文件夹的命令:</p>
<pre class="language-bash hljs">cd nextjs-mdx-blog-rss

npm install
# or
yarn
</pre>
<p>最后，运行项目:</p>
<pre class="language-bash hljs">npm run dev
# or
yarn dev
</pre>
<p>该项目应该在<a href="http://localhost:3000"> http://localhost:3000 </a>启动并运行。</p>
<h3 id="project-structure">项目结构</h3>
<p>如果我们打开源代码，我们应该有一个更接近如下的文件结构:</p>
<pre class="language-javascript hljs">nextjs-mdx-blog-rss
   ...
    ├── components
    │      ├── Footer.js
    │      ├── Header.js
    │      ├── Layout.js
    │      └── MdxComponents.js
    ├── pages
    │      ├── api
    │      ├── blog
    │      │    ├── [slug].js
    │      │    └── index.js
    │      ├── _app.js
    │      ├── ...
    │      └── index.js
    ├── posts
    ├── public
    ├── styles
    ├── utils
    │      ├── generateRSSFeed.js
    │      ├── mdx.js
    ├── menuItems.js
   ... 
</pre>
<h3 id="add-support-absolute-imports">添加对绝对导入的支持</h3>
<p>如果我们浏览项目文件夹并打开文件，我们已经使用相对导入将文件内容包含在另一个文件中。为了添加对绝对导入的支持，我们将使用以下步骤。</p>
<p>首先，在项目的根目录中添加一个<code>jsconfig.json</code>文件，并添加以下代码:</p>
<pre class="language-json hljs">{
  "compilerOptions": {
    "baseUrl": "."
  }
}
</pre>
<p>接下来，保存文件并重启dev服务器。</p>
<p>我们现在可以用上面的代码定义来自项目根的绝对导入。换句话说，现在所有的导入都是相对于项目的根的。所以，我们现在可以直接从根目录导入模块，比如<code>components</code>、<code>styles</code>和<code>utils</code>。</p>
<p>例如，在<code>blog/[slug].js</code>文件中查找<code>MDXComponents</code>导入，并使用相对导入进行更新，如下所示:</p>
<pre class="language-javascript hljs">import MDXComponents from '../../components/MdxComponents';
</pre>
<p>…改为使用绝对导入，如下所示:</p>
<pre class="language-javascript hljs">import MDXComponents from 'components/MdxComponents'; 
</pre>
<p>让我们对其他进口货也这样做。我们将在下一步中配置一个可选的模块别名，以进一步简化绝对导入。</p>
<p>让我们打开<code>jsconfig.json</code>文件并更新配置，这样我们就有了以下内容:</p>
<pre class="language-json hljs">{
  "compilerOptions": {
    "baseUrl": ".",
    "paths": {
      "@components/*": ["components/*"],
      "@styles/*": ["styles/*"],
      "@utils/*": ["utils/*"],
    }
  }
}
</pre>
<p>我们将保存文件并重启开发服务器。</p>
<p>现在，我们可以像这样指定一个路径:</p>
<pre class="language-javascript hljs">import MDXComponents from '@components/MdxComponents';
</pre>
<p>而不是这个:</p>
<pre class="language-javascript hljs">import MDXComponents from 'components/MdxComponents'; 
</pre>
<p>让我们再次为其他进口做同样的事情。如果我们想把工作文件放在可选的<code>src</code>文件夹中，我们需要遵循下面三个步骤。</p>
<p>在项目根目录下创建一个<code>src</code>文件夹，并将<code>components</code>、<code>pages</code>、<code>styles</code>和<code>utils</code>文件夹连同<code>menuItems.js</code>文件一起移动到<code>src</code>文件夹中。</p>
<p>接下来，更新配置<code>baseUrl</code>以指向<code>src</code>:</p>
<pre class="language-javascript hljs">{
  "compilerOptions": {
    "baseUrl": "src",
    "paths": {
      "@components/*": ["components/*"],
      "@styles/*": ["styles/*"],
      "@utils/*": ["utils/*"],
    }
  }
}
</pre>
<p>重新启动开发服务器。</p>
<p>让我们确保项目按预期进行。看最后的<a href="https://github.com/Ibaslogic/nextjs-mdx-rss-absolute-import">项目源代码这里</a>。</p>
<h2 id="conclusion">结论</h2>
<p>正如我们所了解的，相对导入不需要像绝对导入那样的任何配置。然而，相对导入有时会令人困惑，并可能导致糟糕的开发人员体验。我们有了一个更精确简洁的方法，用绝对导入来导入Next.js中的模块。</p>
<p>在本课中，我们讨论了相对和绝对导入类型以及如何在Next.js项目中实现它们。我希望你喜欢阅读本指南。有什么想法可以在评论区分享。</p><div class="code-block code-block-30">
<div class="blog-plug inline-plug next-plug"><h2><a href="https://lp.logrocket.com/blg/nextjs-signup" target="_blank"> LogRocket </a>:全面了解生产Next.js应用</h2><p>调试下一个应用程序可能会很困难，尤其是当用户遇到难以重现的问题时。如果您对监视和跟踪状态、自动显示JavaScript错误、跟踪缓慢的网络请求和组件加载时间感兴趣，</p><a href="https://lp.logrocket.com/blg/nextjs-signup" target="_blank">try LogRocket</a><p>. </p><a class="signup" href="https://lp.logrocket.com/blg/nextjs-signup" target="_blank" rel="noopener noreferrer"><img class="alignnone size-full wp-image-46 jetpack-lazy-image" src="../Images/f300c244a1a1cf916df8b4cb02bec6c6.png" data-lazy-src="https://files.readme.io/27c94e7-Image_2017-06-05_at_9.46.04_PM.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://files.readme.io/27c94e7-Image_2017-06-05_at_9.46.04_PM.png"/><noscript><img data-lazy-fallback="1" class="alignnone size-full wp-image-46" src="../Images/f300c244a1a1cf916df8b4cb02bec6c6.png" data-original-src="https://files.readme.io/27c94e7-Image_2017-06-05_at_9.46.04_PM.png"/></noscript></a><a class="signup" href="https://lp.logrocket.com/blg/nextjs-signup" target="_blank" rel="noopener noreferrer"><img class="alignnone size-full wp-image-46 jetpack-lazy-image" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/><noscript><img data-lazy-fallback="1" class="alignnone size-full wp-image-46" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/></noscript></a><p>LogRocket 就像是网络和移动应用的DVR，记录下你的Next.js应用上发生的一切。您可以汇总并报告问题发生时应用程序的状态，而不是猜测问题发生的原因。LogRocket还可以监控应用程序的性能，报告客户端CPU负载、客户端内存使用等指标。</p><p>LogRocket Redux中间件包为您的用户会话增加了一层额外的可见性。LogRocket记录Redux存储中的所有操作和状态。</p><p>让您调试Next.js应用的方式现代化— <a class="signup" href="https://lp.logrocket.com/blg/nextjs-signup" target="_blank" rel="noopener noreferrer">开始免费监控</a>。</p></div></div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
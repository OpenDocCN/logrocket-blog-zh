<html>
<head>
<title>React Native CI/CD using GitHub Actions - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>使用 GitHub 操作对本机 CI/CD 做出反应- LogRocket 博客</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/react-native-ci-cd-using-github-actions/#0001-01-01">https://blog.logrocket.com/react-native-ci-cd-using-github-actions/#0001-01-01</a></blockquote><div><article class="article-post">
<p>时间是我们人类最宝贵的财富。作为开发人员，我们花了太多的时间做两件事:盯着我们的代码想知道为什么它不工作，以及等待我们的应用程序构建。没有人喜欢等到构建完成，然后在回家之前发布它。为什么不自动化呢？CI/CD？是啊！React 本地应用也是如此。</p>
<p>今天，我们有很棒的工具可用于 React 原生应用的 CI/CD。GitHub Actions、GitLab CI/CD、CircleCI、Travis CI 和许多其他工具正在帮助开发人员节省大量时间和资源。今天，我们将对 React 本机应用程序的 CI/CD 使用 Github 操作。</p>
<p>这篇文章是我们之前讨论用 React 本地测试库测试 React 本地应用的文章的延续。虽然这不是必要的阅读，但是我们讨论了一些提交前的任务来保持代码的质量。基于同一个应用程序，我们将在这里完成 CI/CD 管道。</p>
<h2>关于带有 GitHub 动作的 CI/CD</h2>
<p>GitHub Actions 允许我们定义基于相关条件运行的工作流。每个存储库可以包含基于不同事件触发不同作业的多个工作流。每次触发 GitHub 都会选择<code>.github/workflows/</code>中的所有 YAML 文件，并执行所需的工作流。如果工作流突然结束，则该操作会被标记为失败。</p>
<p>为了完成一些基本任务，比如检查我们的项目或缓存文件，GitHub 有一系列官方维护的动作。我们也可以利用<a href="https://github.com/marketplace?type=actions&amp;verification=verified">社区维护的几个开源动作</a>。</p>
<h2>我们的目标</h2>
<p>因此，我们的要求如下:</p>
<ul>
<li>对于开发分支上的每个拉请求，执行所有测试<strong>【CI】</strong></li>
<li>在开发分支的每次推送中，通过 Firebase 应用分发<strong>【CD】</strong>分发我们的 Android 应用</li>
<li>在 alpha 分支的每次推送中，通过 Google Play 控制台<strong>【CD】</strong>发布我们应用程序的 alpha 版本</li>
<li>在主分支的每次推送中，通过 Google Play 控制台<strong>【CD】</strong>发布我们应用程序的测试版</li>
</ul>
<p>如上所述，我们的第一个需求属于 CI(持续集成)阶段。这允许我们建立一种自动化的方法来保持开发快速进行，而不破坏我们的应用程序。CD(连续交付)从 CI 结束的地方开始。CD 自动向选定的环境交付我们的应用程序。</p>
<h2>为 React 本地应用添加 CI 工作流</h2>
<p>概括地说，我们有两种不同的工作流:CI 和 CD。任何工作流都可以在不同的触发器上执行；在我们的例子中，CI 工作流将在受保护分支上的每个拉请求上执行，而 CD 工作流在受保护分支上的每个推请求上执行。</p>
<p>为了为我们的 repo 设置 CI 工作流，我们将在<code>.github/workflows/</code>中添加一个新文件<code>ci.yml</code>。</p>
<h3>定义我们的 CI 工作流程</h3>
<p>我们的 CI 工作流触发器是受保护分支上的拉请求。下面是<a href="https://github.com/zsajjad/testing-app/blob/main/.github/workflows/ci.yml#L1">我们的工作流配置</a>应该是什么样子:</p>
<pre>name: Continuous Integration

on:
  pull_request:
    branches:
      - develop
      - alpha 
      - main</pre>
<p>正如所见，这将在定义的分支上的每个拉请求上执行。</p>
<h3>项目检验</h3>
<p>我们通过 GitHub Actions 定义的每个工作流都在一个单独的虚拟机中执行。为了在我们的代码库上执行任何操作，我们需要在分配的实例上签出 repo。如前所述，GitHub 有各种各样的实用操作来处理这些任务。这里<a href="https://github.com/zsajjad/testing-app/blob/main/.github/workflows/ci.yml#L15">我们将使用结帐动作</a>:</p>
<pre>    - name: Checkout
      uses: actions/<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="d5b6bdb0b6bebaa0a195a3e7">[email protected]</a></pre>
<h3>安装依赖项</h3>
<p>一旦我们的结帐完成，我们将设置我们的环境和项目。要在 GitHub VM 中运行任何 Node.js 项目，我们可以使用<a href="https://github.com/actions/setup-node">官方节点设置动作</a>。</p>
<p>因为我们使用 React 本地测试库执行测试，所以我们必须安装一些 npm 依赖项。在这一步，我们将<a href="https://github.com/zsajjad/testing-app/blob/main/.github/workflows/ci.yml#L17">在 runner 上设置一个节点环境</a>并安装我们的 npm 依赖项。</p>
<pre>    - uses: actions/<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="6f1c0a1b1a1f4201000b0a2f020e1c1b0a1d">[email protected]</a>
    - uses: c-hive/<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="e88f8089c591899a86c58b898b808da89ed9">[email protected]</a>

    - name: Install node modules
      run: |
        yarn install</pre>
<p>为了进行后续操作，我们可以缓存项目的 npm 依赖项。我们利用了 C-Hive 的单行纱线模块缓存动作。</p>
<h3>运行我们的测试</h3>
<p>既然节点环境和依赖项已经可用，让我们开始执行我们的测试套件。这就像<a href="https://github.com/zsajjad/testing-app/blob/main/.github/workflows/ci.yml#L24">使用本地 CLI 运行我们的测试</a>一样简单。</p>
<pre>    - name: Run test
      run: |
        yarn test-ci</pre>
<p>如前所述，这个作业将在每个拉请求时执行；GitHub 将显示每个 PR 的管道执行结果。下面是它的截图:</p>
<p><img data-attachment-id="31134" data-permalink="https://blog.logrocket.com/react-native-ci-cd-using-github-actions/successful-pipeline-execution/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/12/successful-pipeline-execution.png" data-orig-size="730,219" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Successful execution of the pipeline" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/12/successful-pipeline-execution-300x90.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/12/successful-pipeline-execution.png" decoding="async" class="aligncenter size-full wp-image-31134 jetpack-lazy-image" src="../Images/d823419a648be04a149b23cdc8927ebf.png" alt="Successful Execution of the Pipeline in GitHub Actions" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2020/12/successful-pipeline-execution.png 730w, https://blog.logrocket.com/wp-content/uploads/2020/12/successful-pipeline-execution-300x90.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2020/12/successful-pipeline-execution.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/12/successful-pipeline-execution.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="31134" data-permalink="https://blog.logrocket.com/react-native-ci-cd-using-github-actions/successful-pipeline-execution/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2020/12/successful-pipeline-execution.png" data-orig-size="730,219" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Successful execution of the pipeline" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2020/12/successful-pipeline-execution-300x90.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2020/12/successful-pipeline-execution.png" decoding="async" loading="lazy" class="aligncenter size-full wp-image-31134" src="../Images/d823419a648be04a149b23cdc8927ebf.png" alt="Successful Execution of the Pipeline in GitHub Actions" srcset="https://blog.logrocket.com/wp-content/uploads/2020/12/successful-pipeline-execution.png 730w, https://blog.logrocket.com/wp-content/uploads/2020/12/successful-pipeline-execution-300x90.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/12/successful-pipeline-execution.png"/></noscript>
<p>这就结束了我们的 CI 工作流程。这个工作流将使我们的应用程序在代码质量方面更具可伸缩性，因为合并到我们 repo 中的任何代码都将通过我们的质量检查。</p>
<h2>添加我们的构建作业</h2>
<p>因为我们有一个完整的决定性 CI 阶段，所以合并到我们受保护的分支中的任何代码都通过了所有测试。因此，一旦合并了任何 PR，就可以安全地构建我们的应用程序了。在我们的 CD 管道中，我们将开始构建我们的应用程序，并根据我们的要求发布它们。</p>
<p>对于 Android 应用，我们构建工作的步骤如下:</p>
<h3>设置梯度缓存</h3>
<p>就像我们没有 npm 依赖一样，我们将缓存我们的梯度依赖和包装，以保持我们的构建更快。<a href="https://github.com/zsajjad/testing-app/blob/main/.github/workflows/main-cd.yml#L26">我们将在这里使用 GitHub 的缓存操作</a>:</p>
<pre>    - name: Cache Gradle Wrapper
      uses: actions/<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="ee8d8f8d868bae98dc">[email protected]</a>
      with:
        path: ~/.gradle/wrapper
        key: ${{ runner.os }}-gradle-wrapper-${{ hashFiles('gradle/wrapper/gradle-wrapper.properties') }}

    - name: Cache Gradle Dependencies
      uses: actions/<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="4f2c2e2c272a0f397d">[email protected]</a>
      with:
        path: ~/.gradle/caches
        key: ${{ runner.os }}-gradle-caches-${{ hashFiles('gradle/wrapper/gradle-wrapper.properties') }}
        restore-keys: |
          ${{ runner.os }}-gradle-caches-</pre>
<p>我们正在分别缓存我们的 Gradle 依赖项和包装器，以确保它们可用于后续的构建，并为我们节省一些宝贵的 CI/CD 时间。</p>
<h3>生成 Android 发布版本</h3>
<p>现在我们将<a href="https://github.com/zsajjad/testing-app/blob/main/.github/workflows/main-cd.yml#L40">开始 Android 应用的构建过程</a>:</p>
<pre>    - name: Make Gradlew Executable
      run: cd android &amp;&amp; chmod +x ./gradlew

    - name: Build Android App Bundle
      run: |
        cd android &amp;&amp; ./gradlew bundleRelease --no-daemon</pre>
<p>在某些 Linux 环境中，Gradle 默认是不可执行的。因此，为了安全起见，我们在开始繁重的构建过程之前确保<code>gradlew</code>是可执行的。</p>
<p>因为所有的动作都是作为单独的实例执行的，所以让 Gradle 守护进程运行是没有意义的；这会给记忆造成额外的负担。因此，我们在构建步骤中添加了一个<code>--no-daemon</code>标志。</p>
<h3>签署 Android 版本</h3>
<p>为了应用程序的安全性，建议我们继续在代码库之外签名属性。一旦我们的构建完成，我们将有一个未签名的应用捆绑包可用。为了对这个包进行签名，我们将使用一个开源签名动作，<a href="https://github.com/r0adkll/sign-android-release">r0 adkll/sign-Android-release</a>。</p>
<p><a href="https://github.com/zsajjad/testing-app/blob/main/.github/workflows/main-cd.yml#L47">这是我们签署发布的步骤</a>:</p>
<pre>    - name: Sign App Bundle
      id: sign_app
      uses: r0adkll/<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="f3809a949dde929d97819c9a97de81969f96928096b385c2">[email protected]</a>
      with:
        releaseDirectory: android/app/build/outputs/bundle/release
        signingKeyBase64: ${{ secrets.ANDROID_SIGNING_KEY }}
        alias: ${{ secrets.ANDROID_SIGNING_ALIAS }}
        keyStorePassword: ${{ secrets.ANDROID_SIGNING_STORE_PASSWORD }}
        keyPassword: ${{ secrets.ANDROID_SIGNING_KEY_PASSWORD }}</pre>
<p>这项任务使用了我们项目中的秘密。我们可以使用以下命令生成<code>signingKeyBase64</code>:</p>
<pre>openssl base64 &lt; some_signing_key.jks | tr -d '\n' | tee some_signing_key.jks.base64.txt</pre>
<p>输出的内容。txt 文件将是 Base64 签名密钥。</p>
<h3>上传神器</h3>
<p>GitHub Actions 允许我们保存任何作业的输出。这些文件可以在以后下载用于测试或备份。我们将<a href="https://github.com/zsajjad/testing-app/blob/main/.github/workflows/main-cd.yml#L57">上传我们的签名应用程序作为这项工作的工件</a>。</p>
<pre>    - name: Upload Artifact
      uses: actions/<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="453035292a2421682437312c23242631053377">[email protected]</a>
      with:
        name: Signed App Bundle
        path: ${{steps.sign_app.outputs.signedReleaseFile}}</pre>
<p>这里的一个关键部分是我们签名的 APK 的路径；这是通过我们前面的步骤<code>sign_app</code>生成的，它输出了已签名的 APK 的路径。这里，我们将使用相同的路径。</p>
<p>工作的构建阶段到此结束！签名包或 APK 现在可供我们使用。</p>
<h2 id="distributingourappviafirebase">通过 Firebase 发布我们的应用</h2>
<p>正如我们在上面的需求中提到的，在每次推送到<code>develop</code>分支时，我们都必须使用 Firebase 应用分发来分发我们的应用。为了使用 Firebase CLI，<a href="https://github.com/zsajjad/testing-app/blob/main/.github/workflows/develop-cd.yml#L53">我们将在实例上全局安装<code>firebase-tools</code></a>，并使其<code>PATH</code>可用。</p>
<pre>    - name: Distribute app via Firebase App Distribution
      env:
          firebaseToken: ${{ secrets.FIREBASE_TOKEN }}
          firebaseGroups: ${{ secrets.FIREBASE_GROUPS }}
          firebaseAppId: ${{ secrets.FIREBASE_APP_ID }}
          notes: ${{ github.event.head_commit.message }}
      run: |
        yarn global add firebase-tools
        export PATH="$(yarn global bin):$PATH"
        firebase \
          appdistribution:distribute android/app/build/outputs/apk/release/app-release.apk \
          --app $firebaseAppId \
          --release-notes "$notes" \
          --groups "$firebaseGroups" \
          --token "$firebaseToken"</pre>
<p>这里我们使用<code>firebaseToken</code>、<code>firebaseGroups</code>和<code>firebaseAppId</code>，都来自我们的秘密。我们在 env 中设置了这些值，然后在 CLI 命令中使用了 env 变量。这是获取秘密和其他变量的另一种方式。</p>
<p>此外，我们还访问了 GitHub 事件中 head commit 的消息。关于作业、提交等的广泛信息。在工作流上下文中<a href="https://docs.github.com/en/free-pro-team@latest/actions/reference/context-and-expression-syntax-for-github-actions">是否可用。</a></p>
<h2>通过游戏控制台分发</h2>
<p>让我们去打一个本垒打。在这一步中，我们将通过 Google Play 控制台分发我们的签名应用程序。这个过程需要<a href="https://developers.google.com/android-publisher/getting_started">设置 Google Play 开发者 API </a>并将其与 Play 控制台连接。完成这个设置后，我们将获得一个 JSON 文件，其中包含关于服务帐户的所有信息。我们会把它放在我们的项目秘密里。</p>
<p><a href="https://github.com/zsajjad/testing-app/blob/main/.github/workflows/main-cd.yml#L63">对于这一步</a>，我们将使用开源的<a href="https://github.com/r0adkll/upload-google-play">r0adkll/upload-Google-Play</a>，它完成了所有与 Play API 相关的繁重工作。</p>
<pre>    - name: Deploy to Play Store (BETA)
      uses: r0adkll/<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="c8bdb8a4a7a9ace5afa7a7afa4ade5b8a4a9b188bef9">[email protected]</a>
      with:
        serviceAccountJsonPlainText: ${{ secrets.ANDROID_SERVICE_ACCOUNT }}
        packageName: com.testedapp
        releaseFile: a${{steps.sign_app.outputs.signedReleaseFile}}
        track: beta
        inAppUpdatePriority: 3
        userFraction: 0.5
        whatsNewDirectory: android/release-notes/</pre>
<p>兴奋来了——我们的测试应用现在交付给最终用户，无需任何手动干预！</p>
<h2>下一步是什么？</h2>
<p>正如开始时所讨论的，<a href="https://blog.logrocket.com/from-front-end-developer-to-a-devops-an-intro-to-ci-cd-7a8a8713fb34/">CI/CD</a>的主要目标是节省开发人员的时间，并保持代码库和最终应用程序的质量不变。利用 GitHub 动作可以节省大量时间，而这些时间是我们手工构建和发布应用程序所花费的。</p>
<p>CI 还将允许开发人员只提取通过我们所有质量标准和测试的代码，这意味着更少的错误和更快的迭代。除了免费披萨，还有什么能让你更开心？</p>
<p>然而，我在使用 GitHub Actions 时错过的一个重要特性是在不同的作业之间共享步骤的能力。在我们的案例中，我们必须在所有的工作中克隆、安装依赖项并运行测试。</p>
<p>目前，所有脚本中都定义了步骤；如果我们在不同的工作之间共享步骤，这种冗余是可以避免的。让我们<a href="https://github.community/t/reusing-sharing-inheriting-steps-between-jobs-declarations/16851/4">继续关注这个讨论</a>并希望它能尽快出现在 GitHub Actions 中。</p>
<p>您可以更深入地了解如何并行和相互依赖地执行多个任务。此外，您可以创建工作流模板，以便在不同的项目之间共享<a href="https://docs.github.com/en/free-pro-team@latest/actions/learn-github-actions/sharing-workflows-with-your-organization"/>。分享你用 GitHub Actions 做的很酷的事情，并在下面的评论中做出本地反应！</p><div class="code-block code-block-18">
<div class="blog-plug inline-plug react-native-plug"><h2><a href="https://lp.logrocket.com/blg/react-native-signup"> LogRocket </a>:即时重现 React 原生应用中的问题。</h2><a class="signup" href="https://lp.logrocket.com/blg/react-native-signup" target="_blank" rel="noopener noreferrer"><img class="alignnone size-full wp-image-46 jetpack-lazy-image" src="../Images/110055665562c1e02069b3698e6cc671.png" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2021/10/react-native-plug_v2-2.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2021/10/react-native-plug_v2-2.png"/><noscript><img data-lazy-fallback="1" class="alignnone size-full wp-image-46" src="../Images/110055665562c1e02069b3698e6cc671.png" data-original-src="https://blog.logrocket.com/wp-content/uploads/2021/10/react-native-plug_v2-2.png"/></noscript></a><p><a href="https://lp.logrocket.com/blg/react-native-signup" target="_blank" rel="noopener noreferrer"> LogRocket </a>是一款 React 原生监控解决方案，可帮助您即时重现问题、确定 bug 的优先级并了解 React 原生应用的性能。</p><p>LogRocket 还可以向你展示用户是如何与你的应用程序互动的，从而帮助你提高转化率和产品使用率。LogRocket 的产品分析功能揭示了用户不完成特定流程或不采用新功能的原因。</p><p>开始主动监控您的 React 原生应用— <a class="signup" href="https://lp.logrocket.com/blg/react-native-signup" target="_blank" rel="noopener noreferrer">免费试用 LogRocket】。</a></p></div>
</div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
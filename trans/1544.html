<html>
<head>
<title>Macros in Rust: A tutorial with examples - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>Rust 中的宏:示例教程</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/macros-in-rust-a-tutorial-with-examples/#0001-01-01">https://blog.logrocket.com/macros-in-rust-a-tutorial-with-examples/#0001-01-01</a></blockquote><div><article class="article-post">
<p>在本教程中，我们将涵盖你需要知道的关于 Rust 宏的一切，包括 Rust 中宏的介绍和如何使用 Rust 宏的示例演示。</p>
<p>我们将讨论以下内容:</p>
<p>什么是 Rust 宏？</p>

<h2 id="whatarerustmacros">Rust 对宏有极好的支持。宏使您能够编写编写其他代码的代码，这就是所谓的元编程。</h2>
<p>宏提供了类似于函数的功能，但没有运行时成本。但是，由于宏是在编译时扩展的，所以编译时会有一些开销。</p>
<p>Rust 宏与 C 中的宏非常不同。Rust 宏应用于令牌树，而 C 宏是文本替换。</p>
<p>Rust 中宏的类型</p>
<h2 id="typesofmacrosinrust">Rust 有两种类型的宏:</h2>
<p><strong>声明性宏</strong>使您能够编写类似于匹配表达式的东西，对您作为参数提供的 Rust 代码进行操作。它使用您提供的代码来生成替换宏调用的代码</p>
<ol>
<li><strong>程序宏</strong>允许你对给出的 Rust 代码的抽象语法树(AST)进行操作。proc 宏是从一个<code>TokenStream</code>(或两个)到另一个<code>TokenStream</code>的函数，其中输出代替了宏调用</li>
<li>让我们放大声明性和过程性宏，并探索一些如何在 Rust 中使用宏的例子。</li>
</ol>
<p>Rust 中的声明性宏</p>
<h2 id="declarativemacrosinrust">这些宏是使用<code>macro_rules!</code>声明的。声明性宏功能稍弱，但提供了一个易于使用的界面来创建宏以删除重复的代码。常见的声明性宏之一是<code>println!</code>。声明性宏提供了一个类似于接口的<code>match</code>,在匹配时，宏被替换为匹配 arm 中的代码。</h2>
<p>创建声明性宏</p>
<h3 id="creatingdeclarativemacros">这段代码创建了一个将两个数相加的宏。<code><a href="https://doc.rust-lang.org/rust-by-example/macros.html">[macro_rules!]</a></code>与宏的名称、<code>add</code>和宏的主体一起使用。</h3>
<pre>// use macro_rules! &lt;name of macro&gt;{&lt;Body&gt;}
macro_rules! add{
 // macth like arm for macro
    ($a:expr,$b:expr)=&gt;{
 // macro expand to this code
        {
// $a and $b will be templated using the value/variable provided to macro
            $a+$b
        }
    }
}

fn main(){
 // call to macro, $a=1 and $b=2
    add!(1,2);
}
</pre>
<p>宏并不将两个数相加，它只是用代码替换自己来将两个数相加。宏的每个分支都接受函数的一个参数，并且可以为参数分配多种类型。如果<code>add</code>函数也可以接受单个参数，我们添加另一个分支。</p>
<p>一个宏中可以有多个分支，根据不同的参数扩展到不同的代码。每个分支可以接受多个参数，以符号<code>$</code>开头，后面跟一个标记类型:</p>
<pre>macro_rules! add{
 // first arm match add!(1,2), add!(2,3) etc
    ($a:expr,$b:expr)=&gt;{
        {
            $a+$b
        }
    };
// Second arm macth add!(1), add!(2) etc
    ($a:expr)=&gt;{
        {
            $a
        }
    }
}

fn main(){
// call the macro
    let x=0;
    add!(1,2);
    add!(x);
}
</pre>
<p><code>item</code> —一个项目，如函数、结构、模块等。</p>
<ul>
<li><code>block</code> —一个块(即一组语句和/或表达式，用大括号括起来)</li>
<li><code>stmt</code> —一份声明</li>
<li><code>pat</code> —一种模式</li>
<li><code>expr</code> —一种表达方式</li>
<li><code>ty</code> —一种类型</li>
<li><code>ident</code> —一个标识符</li>
<li><code>path</code> —一条路径(如<code>foo</code>、<code>::std::mem::replace</code>、<code>transmute::&lt;_, int&gt;</code>、…)</li>
<li><code>meta</code> —元项；放在<code>#[...]</code>和<code>#![...]</code>属性里面的东西</li>
<li><code>tt</code> —单个令牌树</li>
<li><code>vis</code> —可能为空的<code>Visibility</code>限定符</li>
<li>在本例中，我们使用带有标记类型<code>ty</code>的<code>$typ</code>参数作为数据类型，如<code>u8</code>、<code>u16</code>等。该宏在将数字相加之前转换为特定的类型。</li>
</ul>
<p>Rust 宏还支持接受不固定数量的参数。运算符与正则表达式非常相似。<code>*</code>用于零个或多个标记类型，而<code>+</code>用于零个或一个参数。</p>
<pre>macro_rules! add_as{
// using a ty token type for macthing datatypes passed to maccro
    ($a:expr,$b:expr,$typ:ty)=&gt;{
        $a as $typ + $b as $typ
    }
}

fn main(){
    println!("{}",add_as!(0,2,u8));
}
</pre>
<p>重复的令牌类型用<code>$()</code>括起来，后面跟一个分隔符和一个<code>*</code>或一个<code>+</code>，表示令牌将重复的次数。分隔符用于区分不同的标记。跟随有<code>*</code>或<code>+</code>的<code>$()</code>块用于指示代码的重复块。在上面的例子中，<code>+$a</code>是一个重复的代码。</p>
<pre>macro_rules! add_as{
    (
  // repeated block
  $($a:expr)
 // seperator
   ,
// zero or more
   *
   )=&gt;{
       { 
   // to handle the case without any arguments
   0
   // block to be repeated
   $(+$a)*
     }
    }
}

fn main(){
    println!("{}",add_as!(1,2,3,4)); // =&gt; println!("{}",{0+1+2+3+4})
}
</pre>
<p>如果仔细观察，您会注意到代码中添加了一个额外的零，以使语法有效。为了删除这个零并使<code>add</code>表达式与参数相同，我们需要创建一个名为<a href="https://danielkeep.github.io/tlborm/book/pat-incremental-tt-munchers.html">TT·蒙奇</a>的新宏。</p>
<p>TT 咀嚼器以递归方式分别处理每个令牌。一次处理一个令牌更容易。宏有三个分支:</p>
<pre>macro_rules! add{
 // first arm in case of single argument and last remaining variable/number
    ($a:expr)=&gt;{
        $a
    };
// second arm in case of two arument are passed and stop recursion in case of odd number ofarguments
    ($a:expr,$b:expr)=&gt;{
        {
            $a+$b
        }
    };
// add the number and the result of remaining arguments 
    ($a:expr,$($b:tt)*)=&gt;{
       {
           $a+add!($($b)*)
       }
    }
}

fn main(){
    println!("{}",add!(1,2,3,4));
}
</pre>
<p>如果只传递了一个参数，则第一个分支处理该情况</p>
<ol>
<li>第二个函数处理两个参数被传递的情况</li>
<li>第三个分支用剩余的参数再次调用<code>add</code>宏</li>
<li>宏参数不需要用逗号分隔。多个令牌可以与不同的令牌类型一起使用。例如，括号可以与<code>ident</code>标记类型一起使用。Rust 编译器获取匹配的 arm，并从参数字符串中提取变量。</li>
</ol>
<p>如果运算返回<code>Err</code>或运算的值返回<code>Ok</code>，则<code>ok_or_return</code>宏返回函数。它将一个函数作为参数，并在 match 语句中执行它。对于传递给函数的参数，它使用重复。</p>
<pre>macro_rules! ok_or_return{
// match something(q,r,t,6,7,8) etc
// compiler extracts function name and arguments. It injects the values in respective varibles.
    ($a:ident($($b:tt)*))=&gt;{
       {
        match $a($($b)*) {
            Ok(value)=&gt;value,
            Err(err)=&gt;{
                return Err(err);
            }
        }
        }
    };
}

fn some_work(i:i64,j:i64)-&gt;Result&lt;(i64,i64),String&gt;{
    if i+j&gt;2 {
        Ok((i,j))
    } else {
        Err("error".to_owned())
    }
}

fn main()-&gt;Result&lt;(),String&gt;{
    ok_or_return!(some_work(1,4));
    ok_or_return!(some_work(1,0));
    Ok(())
}
</pre>
<p>通常，需要将几个宏组合成一个宏。在这些情况下，使用内部宏规则。它有助于操纵宏观输入，写出干净的 TT 咀嚼者。</p>
<p>要创建内部规则，请添加以<code>@</code>开头的规则名称作为参数。现在，除非被明确指定为参数，否则宏永远不会匹配内部规则。</p>
<p>Rust 中带有声明性宏的高级解析</p>
<pre>macro_rules! ok_or_return{
 // internal rule.
    (@error $a:ident,$($b:tt)* )=&gt;{
        {
        match $a($($b)*) {
            Ok(value)=&gt;value,
            Err(err)=&gt;{
                return Err(err);
            }
        }
        }
    };

// public rule can be called by the user.
    ($a:ident($($b:tt)*))=&gt;{
        ok_or_return!(@error $a,$($b)*)
    };
}

fn some_work(i:i64,j:i64)-&gt;Result&lt;(i64,i64),String&gt;{
    if i+j&gt;2 {
        Ok((i,j))
    } else {
        Err("error".to_owned())
    }
}

fn main()-&gt;Result&lt;(),String&gt;{
   // instead of round bracket curly brackets can also be used
    ok_or_return!{some_work(1,4)};
    ok_or_return!(some_work(1,0));
    Ok(())
}
</pre>
<h3 id="advancedparsinginrustwithdeclarativemacros">宏有时执行需要对 Rust 语言本身进行解析的任务。</h3>
<p>把我们到目前为止讨论过的所有概念放在一起，让我们创建一个宏，通过添加关键字<code>pub</code>的后缀来公开一个结构。</p>
<p>首先，我们需要解析 Rust 结构以获得结构的名称、结构的字段和字段类型。</p>
<p>解析结构的名称和字段</p>
<h3 id="parsingthenameandfieldofastruct">一个<code>struct</code>声明的开头有一个可见性关键字(比如<code>pub</code>)，接着是<code>struct</code>关键字，然后是<code>struct</code>的名称和<code>struct</code>的主体。</h3>
<p><img data-attachment-id="33828" data-permalink="https://blog.logrocket.com/macros-in-rust-a-tutorial-with-examples/parsing-struct-name-field-diagram/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2021/02/Parsing-Struct-Name-Field-Diagram.png" data-orig-size="661,251" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Parsing Struct Name Field Diagram" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2021/02/Parsing-Struct-Name-Field-Diagram-300x114.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2021/02/Parsing-Struct-Name-Field-Diagram.png" decoding="async" class="aligncenter wp-image-33828 size-full jetpack-lazy-image" src="../Images/611944389a451027ecbdce335d0c8246.png" alt="Parsing Struct Name Field Diagram" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2021/02/Parsing-Struct-Name-Field-Diagram.png 661w, https://blog.logrocket.com/wp-content/uploads/2021/02/Parsing-Struct-Name-Field-Diagram-300x114.png 300w" data-lazy-sizes="(max-width: 661px) 100vw, 661px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2021/02/Parsing-Struct-Name-Field-Diagram.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2021/02/Parsing-Struct-Name-Field-Diagram.png"/></p>
<p><code>$vis</code>将具有可见性，而<code>$struct_name</code>将具有一个结构名。要使一个结构成为公共的，我们只需要添加<code>pub</code>关键字并忽略<code>$vis</code>变量。</p><noscript><img data-lazy-fallback="1" data-attachment-id="33828" data-permalink="https://blog.logrocket.com/macros-in-rust-a-tutorial-with-examples/parsing-struct-name-field-diagram/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2021/02/Parsing-Struct-Name-Field-Diagram.png" data-orig-size="661,251" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Parsing Struct Name Field Diagram" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2021/02/Parsing-Struct-Name-Field-Diagram-300x114.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2021/02/Parsing-Struct-Name-Field-Diagram.png" decoding="async" loading="lazy" class="aligncenter wp-image-33828 size-full" src="../Images/611944389a451027ecbdce335d0c8246.png" alt="Parsing Struct Name Field Diagram" srcset="https://blog.logrocket.com/wp-content/uploads/2021/02/Parsing-Struct-Name-Field-Diagram.png 661w, https://blog.logrocket.com/wp-content/uploads/2021/02/Parsing-Struct-Name-Field-Diagram-300x114.png 300w" sizes="(max-width: 661px) 100vw, 661px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2021/02/Parsing-Struct-Name-Field-Diagram.png"/></noscript>
<pre>macro_rules! make_public{
    (
  // use vis type for visibility keyword and ident for struct name
     $vis:vis struct $struct_name:ident { }
    ) =&gt; {
        {
            pub struct $struct_name{ }
        }
    }
}
</pre>
<p><img data-attachment-id="33829" data-permalink="https://blog.logrocket.com/macros-in-rust-a-tutorial-with-examples/make-struct-public-with-keyword/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2021/02/Make-Struct-Public-with-Keyword.png" data-orig-size="521,321" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Make Struct Public with Keyword" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2021/02/Make-Struct-Public-with-Keyword-300x185.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2021/02/Make-Struct-Public-with-Keyword.png" decoding="async" class="aligncenter wp-image-33829 size-full jetpack-lazy-image" src="../Images/c035824167b45f5432716debc8b322e8.png" alt="Make Struct Public with Keyword" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2021/02/Make-Struct-Public-with-Keyword.png 521w, https://blog.logrocket.com/wp-content/uploads/2021/02/Make-Struct-Public-with-Keyword-300x185.png 300w" data-lazy-sizes="(max-width: 521px) 100vw, 521px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2021/02/Make-Struct-Public-with-Keyword.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2021/02/Make-Struct-Public-with-Keyword.png"/></p>
<p>一个<code>struct</code>可能包含多个具有相同或不同数据类型和可见性的字段。<code>ty</code>标记类型用于数据类型，<code>vis</code>用于可见性，<code>ident</code>用于字段名。我们将对零个或多个字段使用<code>*</code>重复。</p><noscript><img data-lazy-fallback="1" data-attachment-id="33829" data-permalink="https://blog.logrocket.com/macros-in-rust-a-tutorial-with-examples/make-struct-public-with-keyword/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2021/02/Make-Struct-Public-with-Keyword.png" data-orig-size="521,321" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Make Struct Public with Keyword" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2021/02/Make-Struct-Public-with-Keyword-300x185.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2021/02/Make-Struct-Public-with-Keyword.png" decoding="async" loading="lazy" class="aligncenter wp-image-33829 size-full" src="../Images/c035824167b45f5432716debc8b322e8.png" alt="Make Struct Public with Keyword" srcset="https://blog.logrocket.com/wp-content/uploads/2021/02/Make-Struct-Public-with-Keyword.png 521w, https://blog.logrocket.com/wp-content/uploads/2021/02/Make-Struct-Public-with-Keyword-300x185.png 300w" sizes="(max-width: 521px) 100vw, 521px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2021/02/Make-Struct-Public-with-Keyword.png"/></noscript>
<p>通常<code>struct</code>会附加一些元数据或者程序宏，比如<code>#[derive(Debug)]</code>。这些元数据需要保持完整。使用<code>meta</code>类型解析元数据。</p>
<pre> macro_rules! make_public{
    (
     $vis:vis struct $struct_name:ident {
        $(
 // vis for field visibility, ident for field name and ty for field data type
        $field_vis:vis $field_name:ident : $field_type:ty
        ),*
    }
    ) =&gt; {
        {
            pub struct $struct_name{
                $(
                pub $field_name : $field_type,
                )*
            }
        }
    }
}
</pre>

<p>我们的<code>make_public</code>宏现在准备好了。为了了解<code>make_public</code>是如何工作的，让我们使用<a href="https://play.rust-lang.org/"> Rust Playground </a>将宏扩展为实际编译的代码。</p>
<pre>macro_rules! make_public{
    (
     // meta data about struct
     $(#[$meta:meta])* 
     $vis:vis struct $struct_name:ident {
        $(
        // meta data about field
        $(#[$field_meta:meta])*
        $field_vis:vis $field_name:ident : $field_type:ty
        ),*$(,)+
    }
    ) =&gt; {
        { 
            $(#[$meta])*
            pub struct $struct_name{
                $(
                $(#[$field_meta:meta])*
                pub $field_name : $field_type,
                )*
            }
        }
    }
}</pre>
<p>扩展后的代码如下所示:</p>
<pre>macro_rules! make_public{
    (
     $(#[$meta:meta])* 
     $vis:vis struct $struct_name:ident {
        $(
        $(#[$field_meta:meta])*
        $field_vis:vis $field_name:ident : $field_type:ty
        ),*$(,)+
    }
    ) =&gt; {

            $(#[$meta])*
            pub struct $struct_name{
                $(
                $(#[$field_meta:meta])*
                pub $field_name : $field_type,
                )*
            }
    }
}

fn main(){
    make_public!{
        #[derive(Debug)]
        struct Name{
            n:i64,
            t:i64,
            g:i64,
        }
    }
}
</pre>
<p>声明性宏的限制</p>
<pre>// some imports


macro_rules! make_public {
    ($ (#[$ meta : meta]) * $ vis : vis struct $ struct_name : ident
     {
         $
         ($ (#[$ field_meta : meta]) * $ field_vis : vis $ field_name : ident
          : $ field_type : ty), * $ (,) +
     }) =&gt;
    {

            $ (#[$ meta]) * pub struct $ struct_name
            {
                $
                ($ (#[$ field_meta : meta]) * pub $ field_name : $
                 field_type,) *
            }
    }
}

fn main() {
        pub struct name {
            pub n: i64,
            pub t: i64,
            pub g: i64,
    }
}
</pre>
<h3 id="limitationsofdeclarativemacros">声明性宏有一些限制。有些与 Rust 宏本身有关，而有些则更具体地与声明性宏有关。</h3>
<p>缺乏对宏自动完成和扩展的支持</p>
<ul>
<li>调试声明性宏很困难</li>
<li>有限的修改能力</li>
<li>大型二进制文件</li>
<li>更长的编译时间(这适用于声明性和过程性宏)</li>
<li>Rust 中的程序宏</li>
</ul>
<h2 id="proceduralmacrosinrust"><a href="https://blog.logrocket.com/procedural-macros-in-rust/">程序宏</a>是宏的更高级版本。程序宏允许您扩展 Rust 的现有语法。它接受任意输入并返回有效的 Rust 代码。</h2>
<p>程序宏是将一个<code>TokenStream</code>作为输入并返回另一个<code>Token Stream</code>的函数。程序宏操纵输入<code>TokenStream</code>产生输出流。</p>
<p>有三种类型的程序宏:</p>
<p>类似属性的宏</p>
<ol>
<li>派生宏</li>
<li>类似函数的宏</li>
<li>我们将在下面详细讨论每种程序宏类型。</li>
</ol>
<p>类似属性的宏</p>
<h3 id="attributelikemacros">类似属性的宏使您能够创建一个自定义属性，该属性将自身附加到某个项，并允许对该项进行操作。它也可以接受参数。</h3>
<p>在上面的代码中，<code>some_attribute_macros</code>是一个属性宏。它操纵功能<code>perform_task</code>。</p>
<pre>#[some_attribute_macro(some_argument)]
fn perform_task(){
// some code
}
</pre>
<p>要编写一个类似属性的宏，首先使用<code>cargo new macro-demo --lib</code>创建一个项目。一旦项目准备就绪，更新<code>Cargo.toml</code>以通知 cargo 项目将创建程序宏。</p>
<p>现在我们都准备好进入过程宏了。</p>
<pre># Cargo.toml
[lib]
proc-macro = true
</pre>
<p>程序宏是以<code>TokenStream</code>作为输入并返回另一个<code>TokenStream</code>的公共函数。要编写一个过程化的宏，我们需要编写解析器来解析<code>TokenStream</code>。Rust 社区有一个很好的解析<code>TokenStream</code>的工具<code>syn</code>。</p>
<p><code><a href="https://docs.rs/syn/1.0.53/syn/">syn</a></code>为 Rust 语法提供了现成的解析器，可以用来解析<code>TokenStream</code>。您也可以通过组合提供<code>syn</code>的低级解析器来解析您的语法。</p>
<p>在<code>Cargo.toml</code>中增加<code>syn</code>和<code>quote</code>:</p>
<p>现在我们可以使用编译器提供的用于编写过程宏的<code>proc_macro</code>箱，在<code>lib.rs</code>中编写一个类似属性的宏。程序宏机箱不能导出除程序宏之外的任何内容，并且机箱中定义的程序宏不能在机箱本身中使用。</p>
<pre># Cargo.toml
[dependencies]
syn = {version="1.0.57",features=["full","fold"]}
quote = "1.0.8"
</pre>
<p>为了测试我们添加的宏，通过创建一个名为<code>tests</code>的文件夹并在文件夹中添加文件<code>attribute_macro.rs</code>来创建一个迎合测试。在这个文件中，我们可以使用类似属性的宏进行测试。</p>
<pre>// lib.rs
extern crate proc_macro;
use proc_macro::{TokenStream};
use quote::{quote};

// using proc_macro_attribute to declare an attribute like procedural macro
#[proc_macro_attribute]
// _metadata is argument provided to macro call and _input is code to which attribute like macro attaches
pub fn my_custom_attribute(_metadata: TokenStream, _input: TokenStream) -&gt; TokenStream {
    // returing a simple TokenStream for Struct
    TokenStream::from(quote!{struct H{}})
}
</pre>
<p>使用<code>cargo test</code>命令运行上述测试。</p>
<pre>// tests/attribute_macro.rs

use macro_demo::*;

// macro converts struct S to struct H
#[my_custom_attribute]
struct S{}

#[test]
fn test_macro(){
// due to macro we have struct H in scope
    let demo=H{};
}
</pre>
<p>现在我们已经了解了过程宏的基础，让我们使用<code>syn</code>进行一些高级的<code>TokenStream</code>操作和解析。</p>
<p>为了了解如何使用<code>syn</code>进行解析和操作，让我们以<a href="https://github.com/dtolnay/syn/blob/master/examples/trace-var/trace-var/src/lib.rs"> <code>syn</code> GitHub repo </a>为例。此示例创建一个 Rust 宏，该宏在值发生变化时跟踪变量。</p>
<p>首先，我们需要确定我们的宏将如何操作它附加的代码。</p>
<p><code>trace_vars</code>宏取其需要跟踪的变量名，并在每次输入变量<code>a</code>的值改变时注入一个打印语句。它跟踪输入变量的值。</p>
<pre>#[trace_vars(a)]
fn do_something(){
  let a=9;
  a=6;
  a=0;
}
</pre>
<p>首先，解析类似属性的宏所附加的代码。<code>syn</code>为 Rust 函数语法提供了一个内置的解析器。<code>ItemFn</code>将解析函数，如果语法无效，将抛出一个错误。</p>
<p>现在我们已经解析了<code>input</code>，让我们转到<code>metadata</code>。对于<code>metadata</code>，没有内置的解析器可以工作，所以我们必须使用<code>syn</code>的<code>parse</code>模块自己写一个。</p>
<pre>#[proc_macro_attribute]
pub fn trace_vars(_metadata: TokenStream, input: TokenStream) -&gt; TokenStream {
// parsing rust function to easy to use struct
    let input_fn = parse_macro_input!(input as ItemFn);
    TokenStream::from(quote!{fn dummy(){}})
}
</pre>
<p>为了让<code>syn</code>工作，我们需要实现由<code>syn</code>提供的<code>Parse</code>特征。<code>Punctuated</code>用于创建由<code>,</code>分隔的<code>Indent</code>的<code>vector</code>。</p>
<pre>#[trace_vars(a,c,b)] // we need to parse a "," seperated list of tokens
// code
</pre>
<p>一旦我们实现了<code>Parse</code>特征，我们就可以使用<code>parse_macro_input</code>宏来解析<code>metadata</code>。</p>
<pre>struct Args{
    vars:HashSet&lt;Ident&gt;
}

impl Parse for Args{
    fn parse(input: ParseStream) -&gt; Result&lt;Self&gt; {
        // parses a,b,c, or a,b,c where a,b and c are Indent
        let vars = Punctuated::&lt;Ident, Token![,]&gt;::parse_terminated(input)?;
        Ok(Args {
            vars: vars.into_iter().collect(),
        })
    }
}
</pre>
<p>我们现在将修改<code>input_fn</code>以在变量改变值时添加<code>println!</code>。要添加这个，我们需要过滤有赋值的大纲，并在那一行之后插入一个 print 语句。</p>
<pre>#[proc_macro_attribute]
pub fn trace_vars(metadata: TokenStream, input: TokenStream) -&gt; TokenStream {
    let input_fn = parse_macro_input!(input as ItemFn);
// using newly created struct Args
    let args= parse_macro_input!(metadata as Args);
    TokenStream::from(quote!{fn dummy(){}})
}
</pre>
<p>在上面的例子中，<code>quote</code>宏用于模板化和编写 Rust。<code>#</code>用于注入变量的值。</p>
<pre>impl Args {
    fn should_print_expr(&amp;self, e: &amp;Expr) -&gt; bool {
        match *e {
            Expr::Path(ref e) =&gt; {
 // variable shouldn't start wiht ::
                if e.path.leading_colon.is_some() {
                    false
// should be a single variable like `x=8` not n::x=0 
                } else if e.path.segments.len() != 1 {
                    false
                } else {
// get the first part
                    let first = e.path.segments.first().unwrap();
// check if the variable name is in the Args.vars hashset
                    self.vars.contains(&amp;first.ident) &amp;&amp; first.arguments.is_empty()
                }
            }
            _ =&gt; false,
        }
    }

// used for checking if to print let i=0 etc or not
    fn should_print_pat(&amp;self, p: &amp;Pat) -&gt; bool {
        match p {
// check if variable name is present in set
            Pat::Ident(ref p) =&gt; self.vars.contains(&amp;p.ident),
            _ =&gt; false,
        }
    }

// manipulate tree to insert print statement
    fn assign_and_print(&amp;mut self, left: Expr, op: &amp;dyn ToTokens, right: Expr) -&gt; Expr {
 // recurive call on right of the assigment statement
        let right = fold::fold_expr(self, right);
// returning manipulated sub-tree
        parse_quote!({
            #left #op #right;
            println!(concat!(stringify!(#left), " = {:?}"), #left);
        })
    }

// manipulating let statement
    fn let_and_print(&amp;mut self, local: Local) -&gt; Stmt {
        let Local { pat, init, .. } = local;
        let init = self.fold_expr(*init.unwrap().1);
// get the variable name of assigned variable
        let ident = match pat {
            Pat::Ident(ref p) =&gt; &amp;p.ident,
            _ =&gt; unreachable!(),
        };
// new sub tree
        parse_quote! {
            let #pat = {
                #[allow(unused_mut)]
                let #pat = #init;
                println!(concat!(stringify!(#ident), " = {:?}"), #ident);
                #ident
            };
        }
    }
}
</pre>
<p>现在我们将对<code>input_fn</code>执行 DFS 并插入 print 语句。<code>syn</code>提供了一个<code>Fold</code>特征，可以在任何<code>Item</code>上为 DFS 实现。我们只需要修改与我们想要操作的令牌类型相对应的特征方法。</p>
<p><code>Fold</code>特征用于进行<code>Item</code>的 DFS。它使您能够对各种令牌类型使用不同的行为。</p>
<pre>impl Fold for Args {
    fn fold_expr(&amp;mut self, e: Expr) -&gt; Expr {
        match e {
// for changing assignment like a=5
            Expr::Assign(e) =&gt; {
// check should print
                if self.should_print_expr(&amp;e.left) {
                    self.assign_and_print(*e.left, &amp;e.eq_token, *e.right)
                } else {
// continue with default travesal using default methods
                    Expr::Assign(fold::fold_expr_assign(self, e))
                }
            }
// for changing assigment and operation like a+=1
            Expr::AssignOp(e) =&gt; {
// check should print
                if self.should_print_expr(&amp;e.left) {
                    self.assign_and_print(*e.left, &amp;e.op, *e.right)
                } else {
// continue with default behaviour
                    Expr::AssignOp(fold::fold_expr_assign_op(self, e))
                }
            }
// continue with default behaviour for rest of expressions
            _ =&gt; fold::fold_expr(self, e),
        }
    }

// for let statements like let d=9
    fn fold_stmt(&amp;mut self, s: Stmt) -&gt; Stmt {
        match s {
            Stmt::Local(s) =&gt; {
                if s.init.is_some() &amp;&amp; self.should_print_pat(&amp;s.pat) {
                    self.let_and_print(s)
                } else {
                    Stmt::Local(fold::fold_local(self, s))
                }
            }
            _ =&gt; fold::fold_stmt(self, s),
        }
    }
}
</pre>
<p>现在，我们可以使用<code>fold_item_fn</code>在解析后的代码中插入打印语句。</p>
<p>这个代码示例来自<a href="https://github.com/dtolnay/syn/blob/master/examples/trace-var/trace-var/src/lib.rs"> <code>syn</code>示例报告</a>，这是学习过程宏的一个极好的资源。</p>
<pre>#[proc_macro_attribute]
pub fn trace_var(args: TokenStream, input: TokenStream) -&gt; TokenStream {
// parse the input
    let input = parse_macro_input!(input as ItemFn);
// parse the arguments
    let mut args = parse_macro_input!(args as Args);
// create the ouput
    let output = args.fold_item_fn(input);
// return the TokenStream
    TokenStream::from(quote!(#output))
}
</pre>
<p>自定义派生宏</p>
<h3 id="customderivemacros">Rust 中自定义派生宏允许自动实现特征。这些宏使您能够使用<code>#[derive(Trait)]</code>实现特征。</h3>
<p><code>syn</code>对<code>derive</code>宏有很好的支持。</p>
<p>要在 Rust 中编写一个定制的派生宏，我们可以使用<code>DeriveInput</code>解析输入来派生宏。我们还将使用<code>proc_macro_derive</code>宏来定义一个定制的派生宏。</p>
<pre>#[derive(Trait)]
struct MyStruct{}
</pre>
<p>使用<code>syn</code>可以编写更高级的程序宏。从<code>syn</code>的回购中查看<a href="https://github.com/dtolnay/syn/blob/master/examples/heapsize/heapsize_derive/src/lib.rs">这个例子</a>。</p>
<pre>#[proc_macro_derive(Trait)]
pub fn derive_trait(input: proc_macro::TokenStream) -&gt; proc_macro::TokenStream {
    let input = parse_macro_input!(input as DeriveInput);

    let name = input.ident;

    let expanded = quote! {
        impl Trait for #name {
            fn print(&amp;self) -&gt; usize {
                println!("{}","hello from #name")
           }
        }
    };

    proc_macro::TokenStream::from(expanded)
}
</pre>
<p>类似函数的宏</p>
<h3 id="functionlikemacros">类似函数的宏类似于声明性宏，因为它们是用宏调用操作符<code>!</code>调用的，看起来像函数调用。它们对括号内的代码进行操作。</h3>
<p>以下是如何在 Rust 中编写类似函数的宏:</p>
<p>类似函数的宏不是在运行时执行，而是在编译时执行。它们可以在 Rust 代码中的任何地方使用。类似函数的宏也接受一个<code>TokenStream</code>并返回一个<code>TokenStream</code>。</p>
<pre>#[proc_macro]
pub fn a_proc_macro(_input: TokenStream) -&gt; TokenStream {
    TokenStream::from(quote!(
            fn anwser()-&gt;i32{
                5
            }
))
}
</pre>
<p>使用程序宏的优点包括:</p>
<p>使用<code>span</code>更好地处理错误</p>
<ul>
<li>更好地控制产量</li>
<li>社区建造的板条箱<code>syn</code>和<code>quote</code></li>
<li>比声明性宏更强大</li>
<li>结论</li>
</ul>
<h2 id="conclusion">在这个 Rust 宏教程中，我们介绍了 Rust 中宏的基础知识，定义了声明性和过程性宏，并介绍了如何使用各种语法和社区构建的框架编写这两种类型的宏。我们还概述了使用每种 Rust 宏的优点。</h2>
<p><a href="https://lp.logrocket.com/blg/rust-signup" target="_blank">log rocket</a>:Rust 应用的 web 前端的全面可见性</p><div class="code-block code-block-29">
<div class="blog-plug inline-plug rust-plug"><h2>调试 Rust 应用程序可能很困难，尤其是当用户遇到难以重现的问题时。如果您对监控和跟踪 Rust 应用程序的性能、自动显示错误、跟踪缓慢的网络请求和加载时间感兴趣，</h2><p>. </p><a href="https://lp.logrocket.com/blg/rust-signup" target="_blank">try LogRocket</a><p>LogRocket 就像是网络和移动应用程序的 DVR，记录你的 Rust 应用程序上发生的一切。您可以汇总并报告问题发生时应用程序的状态，而不是猜测问题发生的原因。LogRocket 还可以监控应用的性能，报告客户端 CPU 负载、客户端内存使用等指标。</p><a class="signup" href="https://lp.logrocket.com/blg/rust-signup" target="_blank" rel="noopener noreferrer"><img class="alignnone size-full wp-image-46 jetpack-lazy-image" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/><noscript><img data-lazy-fallback="1" class="alignnone size-full wp-image-46" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/></noscript></a><p>现代化调试 Rust 应用的方式— <a class="signup" href="https://lp.logrocket.com/blg/rust-signup" target="_blank" rel="noopener noreferrer">开始免费监控</a>。</p><p>Modernize how you debug your Rust apps — <a class="signup" href="https://lp.logrocket.com/blg/rust-signup" target="_blank" rel="noopener noreferrer">start monitoring for free</a>.</p></div>


</div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
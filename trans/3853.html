<html>
<head>
<title>How to create and read QR codes in Node.js </title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>如何在Node.js中创建和读取二维码</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/create-read-qr-codes-node-js/#0001-01-01">https://blog.logrocket.com/create-read-qr-codes-node-js/#0001-01-01</a></blockquote><div><article class="article-post">
<p>二维码是一种便捷高效的信息存储和共享方式。使用流行的JavaScript运行时环境Node.js可以轻松读写二维码。在本文中，我们将使用三个流行的库来详细介绍在Node中读取和写入二维码的步骤:读取二维码的<a href="https://github.com/edi9999/jsqrcode"> qrcode-reader </a>和<a href="https://github.com/oliver-moran/jimp"> jimp </a>，以及生成二维码的<a href="https://github.com/soldair/node-qrcode"> qrcode </a>。</p>
<p>向前跳:</p>

<h2 id="writing-qr-codes-node">在节点中写入QR码</h2>
<p>qrcode库为编写QR码提供了一个简单的API。</p>
<h3 id="installing-qrcode-library">安装二维码库</h3>
<p>要安装qrcode库，您需要在系统上安装Node.js和NPM(node . js包管理器)。如果没有安装这些工具，可以从<a href="https://nodejs.org/en/"> Node.js </a>网站下载安装。</p>
<p>一旦安装了Node.js和npm，就可以使用npm安装qrcode库及其依赖项。</p>
<p>打开终端窗口并运行以下命令:</p>
<pre class="language-javascript hljs">npm install qrcode</pre>
<h3 id="generating-qr-code-images">生成QR码图像</h3>
<p>要生成QR码图像，您可以使用QR码模块中的<code>toFile</code>方法。此方法将文件路径、要在QR码中编码的文本和options对象作为参数，并在指定的文件路径生成QR码图像文件。</p>
<p>以下是如何使用<code>toFile</code>方法生成QR码图像文件的示例:</p>
<pre class="language-javascript hljs">// __ Importing qrcode __ \\
const QRCode = require('qrcode');

QRCode.toFile('/output-file-path/file.png', 'Encode this text in QR code', {
  errorCorrectionLevel: 'H'
}, function(err) {
  if (err) throw err;
  console.log('QR code saved!');
});</pre>
<p>此代码将生成一个具有指定文本和纠错级别的QR码图像文件，并将其保存到指定的输出文件中。</p>
<p>纠错级别指定QR码中编码的冗余量，以允许在扫描码时纠正错误。</p>
<p>除了生成二维码图像文件，二维码库还允许您生成其他格式的二维码图像，如JPEG或SVG。为此，您可以使用<code>toString</code>方法，该方法返回一个包含指定格式的QR码图像数据的字符串。</p>
<p>以下是如何使用<code>toString</code>方法生成SVG格式的QR码图像的示例:</p>
<pre class="language-javascript hljs">// __ Importing qrcode __ \\
const QRCode = require('qrcode');

QRCode.toString('Encode this text in QR code', {
  errorCorrectionLevel: 'H',
  type: 'svg'
}, function(err, data) {
  if (err) throw err;
  console.log(data);
});</pre>
<p>这段代码将生成一个具有指定文本和纠错级别的QR码图像，并将其作为一个SVG数据字符串返回。然后，您可以使用这些数据在浏览器或其他应用程序中显示QR码图像。</p>
<p>您可以扫描下面的二维码，并在上面的代码片段中看到您作为<code>toString</code>方法的输入给出的字符串。</p>
<p>这是输出:</p>
<p id="gdcalert1"><img data-attachment-id="156149" data-permalink="https://blog.logrocket.com/create-read-qr-codes-node-js/attachment/qr-code-output/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2023/01/qr-code-output.png" data-orig-size="420,426" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="QR code output" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2023/01/qr-code-output-296x300.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2023/01/qr-code-output.png" decoding="async" class="aligncenter size-full wp-image-156149 jetpack-lazy-image" src="../Images/3d195f9fbbdccfae6a0964e5f6974c50.png" alt="QR Code Output" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2023/01/qr-code-output.png 420w, https://blog.logrocket.com/wp-content/uploads/2023/01/qr-code-output-296x300.png 296w" data-lazy-sizes="(max-width: 420px) 100vw, 420px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2023/01/qr-code-output.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2023/01/qr-code-output.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="156149" data-permalink="https://blog.logrocket.com/create-read-qr-codes-node-js/attachment/qr-code-output/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2023/01/qr-code-output.png" data-orig-size="420,426" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="QR code output" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2023/01/qr-code-output-296x300.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2023/01/qr-code-output.png" decoding="async" loading="lazy" class="aligncenter size-full wp-image-156149" src="../Images/3d195f9fbbdccfae6a0964e5f6974c50.png" alt="QR Code Output" srcset="https://blog.logrocket.com/wp-content/uploads/2023/01/qr-code-output.png 420w, https://blog.logrocket.com/wp-content/uploads/2023/01/qr-code-output-296x300.png 296w" sizes="(max-width: 420px) 100vw, 420px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2023/01/qr-code-output.png"/></noscript>
<h2 id="reading-qr-codes-node">读取节点中的二维码</h2>
<p>在本节中，您将阅读在上一节中生成并保存的QR码文件。</p>
<p>要在Node中读取二维码，您将使用二维码阅读器和jimp库。这些库提供了简单的API，用于从图像和视频源解析和读取QR码。</p>
<h3 id="installing-qrcode-reader-jimp-libraries">安装二维码阅读器和jimp库</h3>
<p>要安装qrcode-reader和jimp库，您将再次需要安装读取qrcode所需的npm包。</p>
<p>打开终端窗口并运行以下命令:</p>
<pre class="language-javascript hljs">npm install qrcode-reader jimp</pre>
<h3 id="reading-qr-codes-image-files">从图像文件中读取QR码</h3>
<p>要从图像文件中读取QR码，您可以使用QR码阅读器模块的<code>decode</code>方法和jimp模块的<code>read</code>方法。jimp <code>read</code>方法解析图像，图像将由二维码阅读器模块的<code>decode</code>方法解码。</p>
<p>以下是如何使用<code>read</code>和<code>decode</code>方法从我们之前保存的图像中读取二维码的示例:</p>
<pre class="language-javascript hljs">// __ Importing jimp __ \\
const Jimp = require("jimp");

// __ Importing filesystem = __ \\
const fs = require('fs')

// __ Importing qrcode-reader __ \\
const qrCodeReader = require('qrcode-reader');
 
// __ Read the image and create a buffer __ \\
const buffer = fs.readFileSync('/output-file-path/file.png');
 
// __ Parse the image using Jimp.read() __ \\
Jimp.read(buffer, function(err, image) {
    if (err) {
        console.error(err);
    }
// __ Creating an instance of qrcode-reader __ \\

    const qrCodeInstance = new qrCodeReader();

    qrCodeInstance.callback = function(err, value) {
        if (err) {
            console.error(err);
        }
// __ Printing the decrypted value __ \\
        console.log(value.result);
    };

// __ Decoding the QR code __ \\
    qrCodeInstance.decode(image.bitmap);
});</pre>
<p>该代码将从图像文件中读取QR码，并将结果记录到控制台。如果QR码被成功解码，结果将是一个包含QR码文本的字符串。如果二维码无法解码，结果将为空。</p>
<p>在下面的输出中，您可以看到我们使用qrcode库编码的字符串。</p>
<p>这是输出:</p>
<pre class="language-javascript hljs">Encode this text in QR code</pre>
<p>可以看到二维码库非常有用，可以配合不同的参数来创建二维码。这个库最好的一点是它可以与React.js应用程序和Node.js服务器一起工作。</p>
<p>您可能想知道在Node.js后端服务中使用二维码的潜在用例是什么。让我们演示一个示例，创建一个简单的登录路径，并根据来自前端的QR码对用户进行身份验证。</p>
<h2 id="creating-backend-node">在节点中创建后端</h2>
<p>首先，运行以下代码:</p>
<pre class="language-javascript hljs">mkdir my-server</pre>
<p>然后，我们初始化后端服务器:</p>
<pre class="language-javascript hljs">npm init</pre>
<p>接下来，我们必须创建<code>controller</code>和<code>route</code>文件:</p>
<pre class="language-javascript hljs">touch controller.js route.js</pre>
<p>现在，安装节点包:</p>
<pre class="language-javascript hljs">npm install express jsonwebtoken nodemon</pre>
<p>这个库用于创建一个服务器并监听Node.js中的一个端口</p>
<p>这个库被用来创建一个JWT并发送给客户端</p>
<p>这个库用于检测服务器代码的实时变化</p>
<p>这将提示您输入一些元数据并创建一个<code>package-lock.json</code>文件。</p>
<p>初始化后端后，下一步是安装必要的依赖项:</p>
<pre class="language-javascript hljs">Npm install express jsonwebtoken qrcode</pre>
<p>当我们的服务器配置好后，让我们为登录创建一个控制器函数。将以下代码复制并粘贴到controller.js文件中:</p>
<pre class="language-javascript hljs">// __ controller.js __\\

exports.login = async (req, res) =&gt; {
  try {

// __ Extract the secret from the request body. __ \\
    const secret = req.body.secret;
// __ Validate the secret. __ \\

    if (secret === VALID_SECRET) {
// __ Generate a JWT token. __ \\
      const token = jwt.sign({ user: 'example' }, JWT_SECRET, { expiresIn: '1h' });

// __ Send the JWT token to the client. __ \\
      res.json({ token });
    } else {

// __ If the secret is invalid, return an error. __ \\
      res.status(401).json({ error: 'Invalid QR code' });
    }
  } catch (error) {
    console.error(error);
    res.status(500).json({ error: 'Server error' });
  }
};

exports.test = async (req, res) =&gt; {

console.log("Hitting the test route");
return res.status(200).json( {message: "Hitting the test route"} );
}</pre>
<p>在上面的代码中，我们创建了一个登录控制器，它从请求体中提取秘密并验证它。如果验证成功，它会创建一个JWT令牌，用这个秘密对其进行签名，然后将其发送回客户端。如果验证失败，它用状态代码401 <strong>响应。</strong></p>
<p><em>注意</em>，我们在文件中添加了一个测试函数来检查我们服务器的活性。</p>
<p>控制器完成后，我们现在将创建一个登录路由来公开我们的资源。将以下代码复制并粘贴到route.js文件中:</p>
<pre class="language-javascript hljs">// __ route.js __ \\

const app = require("express");
const router = app.Router();

const authController = require("./controller");
router.post("/login", authController.login);
router.get("/test", authController.test);

module.exports = router;</pre>
<p>最后一步是为index.js编写代码，我们的服务器将启动并运行:</p>
<pre class="language-javascript hljs">// __ index.js __ \\
const express = require("express");
const app = express();

const auth = require("./route");

app.use("/auth", auth);

const port = process.env.PORT || 3001;
app.listen(port, () =&gt; {
console.log(`Listening to port ${port}...`);
});</pre>
<h2 id="running-server">运行我们的服务器</h2>
<p>要运行服务器，首先在package.json中的脚本对象中添加以下代码:</p>
<pre class="language-javascript hljs">"start": "nodemon index.js",</pre>
<p>现在，运行:</p>
<pre class="language-javascript hljs">npm start</pre>
<p>您的输出应该如下所示:</p>
<p id="gdcalert2"><img data-attachment-id="156153" data-permalink="https://blog.logrocket.com/create-read-qr-codes-node-js/attachment/output-running-server/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2023/01/output-running-server.png" data-orig-size="636,311" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Output after running the server" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2023/01/output-running-server-300x147.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2023/01/output-running-server.png" decoding="async" class="aligncenter size-full wp-image-156153 jetpack-lazy-image" src="../Images/c2ba865aac7a28c22b6a60f9553af5f0.png" alt="Output After Running The Server" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2023/01/output-running-server.png 636w, https://blog.logrocket.com/wp-content/uploads/2023/01/output-running-server-300x147.png 300w" data-lazy-sizes="(max-width: 636px) 100vw, 636px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2023/01/output-running-server.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2023/01/output-running-server.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="156153" data-permalink="https://blog.logrocket.com/create-read-qr-codes-node-js/attachment/output-running-server/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2023/01/output-running-server.png" data-orig-size="636,311" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Output after running the server" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2023/01/output-running-server-300x147.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2023/01/output-running-server.png" decoding="async" loading="lazy" class="aligncenter size-full wp-image-156153" src="../Images/c2ba865aac7a28c22b6a60f9553af5f0.png" alt="Output After Running The Server" srcset="https://blog.logrocket.com/wp-content/uploads/2023/01/output-running-server.png 636w, https://blog.logrocket.com/wp-content/uploads/2023/01/output-running-server-300x147.png 300w" sizes="(max-width: 636px) 100vw, 636px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2023/01/output-running-server.png"/></noscript>
<p>让我们通过点击之前配置的测试路径来测试我们的服务器。我们可以用很多方法测试，比如用Postman或者Thunder客户端，但是我会用一个curl请求。</p>
<p>打开您的终端并运行以下命令:</p>
<pre class="language-javascript hljs">curl -I http://localhost:3001/auth/test</pre>
<p>输出应该如下所示:</p>
<p id="gdcalert3"><img data-attachment-id="156156" data-permalink="https://blog.logrocket.com/create-read-qr-codes-node-js/attachment/output-curl-request/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2023/01/output-curl-request.png" data-orig-size="565,240" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Output after using curl request" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2023/01/output-curl-request-300x127.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2023/01/output-curl-request.png" decoding="async" class="aligncenter size-full wp-image-156156 jetpack-lazy-image" src="../Images/534f77a7655783469c2e4ebcd1c6ba23.png" alt="Output After Using Curl Request" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2023/01/output-curl-request.png 565w, https://blog.logrocket.com/wp-content/uploads/2023/01/output-curl-request-300x127.png 300w" data-lazy-sizes="(max-width: 565px) 100vw, 565px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2023/01/output-curl-request.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2023/01/output-curl-request.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="156156" data-permalink="https://blog.logrocket.com/create-read-qr-codes-node-js/attachment/output-curl-request/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2023/01/output-curl-request.png" data-orig-size="565,240" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Output after using curl request" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2023/01/output-curl-request-300x127.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2023/01/output-curl-request.png" decoding="async" loading="lazy" class="aligncenter size-full wp-image-156156" src="../Images/534f77a7655783469c2e4ebcd1c6ba23.png" alt="Output After Using Curl Request" srcset="https://blog.logrocket.com/wp-content/uploads/2023/01/output-curl-request.png 565w, https://blog.logrocket.com/wp-content/uploads/2023/01/output-curl-request-300x127.png 300w" sizes="(max-width: 565px) 100vw, 565px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2023/01/output-curl-request.png"/></noscript>
<p>现在我们已经测试了服务器的活性，我们可以从构建的前端向登录路由发送请求，并对用户进行身份验证。</p>
<h2 id="conclusion">结论</h2>
<p>在本教程中，我们学习了如何使用二维码以方便高效的方式存储和共享信息。无论我们需要为web或移动应用程序编码数据，都可以使用节点运行时环境轻松实现。我们还学习了如何在QR码中以不同形式编码数据，例如SVG文件。最后，我们创建了一个Node.js服务器，通过使用来自前端的QR码秘密对用户进行签名，使用JWT令牌对用户进行身份验证。</p>
<p>要进一步探索节点模块，请访问它们的<a href="https://nodejs.org/api/packages.html">文档页面</a>。</p>
<p>编码快乐！😇</p><div class="code-block code-block-23">
<div class="blog-plug inline-plug node-plug"><h2>200只<img src="../Images/61167b9d027ca73ed5aaf59a9ec31267.png" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2019/10/green-check.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" class=" jetpack-lazy-image" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/10/green-check.png"/> <noscript> <img data-lazy-fallback="1" src="../Images/61167b9d027ca73ed5aaf59a9ec31267.png" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/10/green-check.png"/> </noscript>显示器出现故障，生产中网络请求缓慢</h2><p>部署基于节点的web应用程序或网站是容易的部分。确保您的节点实例继续为您的应用程序提供资源是事情变得更加困难的地方。如果您对确保对后端或第三方服务的请求成功感兴趣，</p><a href="https://lp.logrocket.com/blg/node-signup" target="_blank">try LogRocket</a><p>. </p><a class="signup" href="https://lp.logrocket.com/blg/node-signup" target="_blank" rel="noopener noreferrer"><img src="../Images/cae72fd2a54c5f02a6398c4867894844.png" alt="LogRocket Network Request Monitoring" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2019/12/network-request-filter-2-1.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" class=" jetpack-lazy-image" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/12/network-request-filter-2-1.png"/><noscript><img data-lazy-fallback="1" src="../Images/cae72fd2a54c5f02a6398c4867894844.png" alt="LogRocket Network Request Monitoring" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/12/network-request-filter-2-1.png"/></noscript></a><a href="https://lp.logrocket.com/blg/node-signup" target="_blank" rel="noopener noreferrer">https://logrocket.com/signup/</a><p>LogRocket 就像是网络和移动应用程序的DVR，记录下用户与你的应用程序交互时发生的一切。您可以汇总并报告有问题的网络请求，以快速了解根本原因，而不是猜测问题发生的原因。</p><p>LogRocket检测您的应用程序以记录基线性能计时，如页面加载时间、到达第一个字节的时间、慢速网络请求，还记录Redux、NgRx和Vuex操作/状态。</p><a class="signup" href="https://lp.logrocket.com/blg/node-signup" target="_blank" rel="noopener noreferrer">Start monitoring for free</a><p>. </p></div>
</div>

<p class="clearfix"/>
<p class="clearfix"/>
 </article>


</div>    
</body>
</html>
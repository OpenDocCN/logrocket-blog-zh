<html>
<head>
<title>Understanding TypeScript’s benefits and pitfalls - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>了解TypeScript的优点和缺点</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/understanding-typescripts-benefits-pitfalls/#0001-01-01">https://blog.logrocket.com/understanding-typescripts-benefits-pitfalls/#0001-01-01</a></blockquote><div><article class="article-post">
<p>JavaScript的动态类型允许灵活性，但是它增加了额外的复杂性和风险。如果有人将一个<code>Number</code>传递给一个需要一个<code>Date</code>的函数，这个函数很可能会抛出一个异常，除非这个函数添加一些额外的代码来确保这个参数实际上是一个<code>Date</code>。</p>
<p>类型检查是TypeScript的主要优点。通过将静态类型添加到语言中，我们可以在构建时发现许多这样的问题。它们可以在代码发布前修复。</p>
<p>当然，这不是万灵药。像任何工具一样，有积极和消极的方面。在本帖中，我们将讨论:</p>

<h2 id="good">好人</h2>
<p>让我们从探索TypeScript的好处开始。还有许多其他的没有在这里列出，但这些是最好的一些。</p>
<h3 id="excellent-code-completion">出色的代码完成</h3>
<p>我主要使用Visual Studio代码作为我的IDE。在其众多强大的特性中，VS代码带有内置的TypeScript智能。弹出代码完成可用于web平台API以及任何具有类型定义的第三方包(现在，在2022年，大多数都有)。</p>
<p>不记得拼接数组的参数了？VS代码已经覆盖了你。考虑这个简单的数组:</p>
<pre class="language-typescript hljs">const numbers = [1, 2, 3];</pre>
<p>当我开始调用<code>numbers</code>数组上的一个函数时，VS Code的智能感知开始工作，并向我显示匹配的函数:</p>
<p><img data-attachment-id="135541" data-permalink="https://blog.logrocket.com/understanding-typescripts-benefits-pitfalls/attachment/matching-functions-intellisense/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/10/matching-functions-intellisense.png" data-orig-size="730,384" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="matching-functions-intellisense" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/10/matching-functions-intellisense-300x158.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/10/matching-functions-intellisense.png" decoding="async" class="alignnone wp-image-135541 size-full jetpack-lazy-image" src="../Images/f8a73d65711bd13019fee190381571f2.png" alt="matching functions from IntelliSense" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2022/10/matching-functions-intellisense.png 730w, https://blog.logrocket.com/wp-content/uploads/2022/10/matching-functions-intellisense-300x158.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2022/10/matching-functions-intellisense.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/10/matching-functions-intellisense.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="135541" data-permalink="https://blog.logrocket.com/understanding-typescripts-benefits-pitfalls/attachment/matching-functions-intellisense/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/10/matching-functions-intellisense.png" data-orig-size="730,384" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="matching-functions-intellisense" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/10/matching-functions-intellisense-300x158.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/10/matching-functions-intellisense.png" decoding="async" loading="lazy" class="alignnone wp-image-135541 size-full" src="../Images/f8a73d65711bd13019fee190381571f2.png" alt="matching functions from IntelliSense" srcset="https://blog.logrocket.com/wp-content/uploads/2022/10/matching-functions-intellisense.png 730w, https://blog.logrocket.com/wp-content/uploads/2022/10/matching-functions-intellisense-300x158.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/10/matching-functions-intellisense.png"/></noscript>
<p>我看到了函数签名和每个参数的描述。当我继续键入对<code>splice</code>的调用时，当前参数被突出显示:</p>
<p><img data-attachment-id="135543" data-permalink="https://blog.logrocket.com/understanding-typescripts-benefits-pitfalls/attachment/splice-parameter/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/10/splice-parameter.png" data-orig-size="730,341" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="splice-parameter-highlighting" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/10/splice-parameter-300x140.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/10/splice-parameter.png" decoding="async" class="alignnone wp-image-135543 size-full jetpack-lazy-image" src="../Images/4279683c417d3e7fcec8a59852365650.png" alt="Splice parameter highlighting." data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2022/10/splice-parameter.png 730w, https://blog.logrocket.com/wp-content/uploads/2022/10/splice-parameter-300x140.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2022/10/splice-parameter.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/10/splice-parameter.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="135543" data-permalink="https://blog.logrocket.com/understanding-typescripts-benefits-pitfalls/attachment/splice-parameter/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/10/splice-parameter.png" data-orig-size="730,341" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="splice-parameter-highlighting" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/10/splice-parameter-300x140.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/10/splice-parameter.png" decoding="async" loading="lazy" class="alignnone wp-image-135543 size-full" src="../Images/4279683c417d3e7fcec8a59852365650.png" alt="Splice parameter highlighting." srcset="https://blog.logrocket.com/wp-content/uploads/2022/10/splice-parameter.png 730w, https://blog.logrocket.com/wp-content/uploads/2022/10/splice-parameter-300x140.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/10/splice-parameter.png"/></noscript>
<p>如果我错误地调用了一个函数，我会立即得到红色下划线:</p>
<p><img data-attachment-id="135546" data-permalink="https://blog.logrocket.com/understanding-typescripts-benefits-pitfalls/attachment/incorrect-function-red-underline/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/10/incorrect-function-red-underline.png" data-orig-size="730,185" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="incorrect-function-red-underline" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/10/incorrect-function-red-underline-300x76.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/10/incorrect-function-red-underline.png" decoding="async" class="alignnone wp-image-135546 size-full jetpack-lazy-image" src="../Images/7f441b02ebe55a110bf85ccb55f3c6ab.png" alt="Incorrect function red highlighting." data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2022/10/incorrect-function-red-underline.png 730w, https://blog.logrocket.com/wp-content/uploads/2022/10/incorrect-function-red-underline-300x76.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2022/10/incorrect-function-red-underline.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/10/incorrect-function-red-underline.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="135546" data-permalink="https://blog.logrocket.com/understanding-typescripts-benefits-pitfalls/attachment/incorrect-function-red-underline/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/10/incorrect-function-red-underline.png" data-orig-size="730,185" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="incorrect-function-red-underline" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/10/incorrect-function-red-underline-300x76.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/10/incorrect-function-red-underline.png" decoding="async" loading="lazy" class="alignnone wp-image-135546 size-full" src="../Images/7f441b02ebe55a110bf85ccb55f3c6ab.png" alt="Incorrect function red highlighting." srcset="https://blog.logrocket.com/wp-content/uploads/2022/10/incorrect-function-red-underline.png 730w, https://blog.logrocket.com/wp-content/uploads/2022/10/incorrect-function-red-underline-300x76.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/10/incorrect-function-red-underline.png"/></noscript>
<p>当然，VS代码只是一个编辑器；许多其他现代编辑器和ide也提供一流的类型脚本支持。</p>
<h3 id="support-incremental-adoption">支持增量采用</h3>
<p>TypeScript有<a href="https://www.typescriptlang.org/tsconfig" target="_blank" rel="noopener">许多配置选项</a>，包括许多控制严格类型检查的选项。</p>
<p>当您从简单的配置开始并关闭严格的检查时，进入的障碍降低了，您的项目可以开始享受静态类型的好处。随着您和您的团队对TypeScript越来越熟悉，可以添加额外的选项来开始进行更严格的检查。</p>
<p>TypeScript可以在JavaScript文件的项目中引入，因为它输出JavaScript。在构建过程之后，一切都只是JavaScript。这允许更渐进地过渡到TypeScript您可以从一两个类型脚本文件开始，而不是将所有的<code>*.js</code>文件重命名为<code>*.ts</code>并可能得到许多错误(取决于配置设置)。最终，文件可以被重命名为<code>*.ts</code>，出现的新类型错误可以被解决。</p>
<h3 id="better-third-party-library-integration">更好的第三方库集成</h3>
<p>当使用TypeScript处理第三方包时，您可能不会经常在编辑器和带有文档的浏览器选项卡之间切换。npm上的许多库都附带了TypeScript类型定义(<code>d.ts</code>)文件。</p>
<p>npm网站还显示了任何包含内置类型定义的包的类型脚本标签:</p>
<p><img data-attachment-id="135549" data-permalink="https://blog.logrocket.com/understanding-typescripts-benefits-pitfalls/attachment/typescript-badge-definitions/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/10/typescript-badge-definitions.png" data-orig-size="730,179" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="typescript-badge-definitions" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/10/typescript-badge-definitions-300x74.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/10/typescript-badge-definitions.png" decoding="async" class="alignnone wp-image-135549 size-full jetpack-lazy-image" src="../Images/bd19c06b509c388eb82e1e2767dd22ba.png" alt="Typescript badge for typescript definitions" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2022/10/typescript-badge-definitions.png 730w, https://blog.logrocket.com/wp-content/uploads/2022/10/typescript-badge-definitions-300x74.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2022/10/typescript-badge-definitions.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/10/typescript-badge-definitions.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="135549" data-permalink="https://blog.logrocket.com/understanding-typescripts-benefits-pitfalls/attachment/typescript-badge-definitions/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/10/typescript-badge-definitions.png" data-orig-size="730,179" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="typescript-badge-definitions" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/10/typescript-badge-definitions-300x74.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/10/typescript-badge-definitions.png" decoding="async" loading="lazy" class="alignnone wp-image-135549 size-full" src="../Images/bd19c06b509c388eb82e1e2767dd22ba.png" alt="Typescript badge for typescript definitions" srcset="https://blog.logrocket.com/wp-content/uploads/2022/10/typescript-badge-definitions.png 730w, https://blog.logrocket.com/wp-content/uploads/2022/10/typescript-badge-definitions-300x74.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/10/typescript-badge-definitions.png"/></noscript>

<p>有很多其他的包不包含类型定义。为了支持这些情况，微软还运行了<a href="https://github.com/DefinitelyTyped/DefinitelyTyped" target="_blank" rel="noopener"> DefinitelyTyped </a>项目，这是一个GitHub资源库，社区成员可以在这里提交缺少的库和工具的类型定义。</p>
<p>这些类型在<code>@types</code>范围下作为单独的包发布。这些类型通常不是由包的作者提供的。一般来说，除非一个包过时了或者被放弃了，否则你很有可能找到你今天正在使用的任何包的类型定义。</p>
<p>如果你是一个库作者，你甚至不需要手写定义。TypeScript编译器可以配置为根据库中的模块自动生成这些<code>d.ts</code>文件。</p>
<h2 id="not-so-good">不太好的人</h2>
<p>TypeScript并非没有批评者。有时候，我其实很赞同他们说的话。TypeScript也有它的缺点，有时会令人讨厌。</p>
<h3 id="safety-not-guaranteed-runtime">不保证安全(运行时)</h3>
<p>使用TypeScript很容易让人产生一种虚假的安全感。即使您的整个项目是用TypeScript编写的，具有严格的类型定义，并且打开了最严格的类型检查，您仍然是不安全的。</p>
<p>TypeScript在生成时执行所有类型检查。也许有一天浏览器会支持原生运行TypeScript，但目前，TypeScript编译器会检查您的代码，确保您没有任何类型错误，并输出可以在浏览器(或Node.js环境)中运行的普通JavaScript。</p>
<p>这个生成的JavaScript不包含类型检查。没错，在运行时，都没了。至少，您可以确信它处理的任何代码都不会有类型错误；你的应用不会因为有人试图在一个<code>Date</code>对象上调用<code>splice</code>而爆炸。</p>
<p>然而，大多数应用程序并不存在于真空中。当您从API请求数据时会发生什么？假设您编写了一个函数来处理来自一个记录良好的API的数据。您可以创建一个接口来模拟数据的预期形状，所有使用它的函数都使用这种类型信息。</p>
<p>也许这个特定的服务改变了他们的API数据的格式，而你错过了更新。突然，您传递的数据与函数的类型定义不匹配。嘣！控制台中出现异常。</p>
<p>并非一切都没了。Sneh Pandya 在【TypeScript运行时类型检查方法中讨论了一些运行时检查类型的选项。</p>

<p>让我们使用JavaScript来监听文本输入上的输入事件:</p>
<pre class="language-javascript hljs">document.querySelector('#username').addEventListener('input', event =&gt; {
  console.log(event.target.value);
});</pre>
<p>每当用户输入一些内容时，它都会被打印到控制台。这在浏览器中有效，一切正常。</p>
<p>让我们将完全相同的代码放到TypeScript中。它会给我们一些关于引用<code>event.target.value</code>的错误。</p>
<p>首先是:</p>
<pre class="language-plaintext hljs">Object is possibly 'null'.
</pre>
<p>TypeScript推断事件参数属于类型<code>Event</code>，即所有DOM事件的基接口。根据规范，<code>Event</code>的目标属性可能是<code>null</code>(例如，直接创建的没有给定目标的<code>Event</code>对象)。</p>
<p>DOM类型定义将<code>Event.target</code>的类型指定为<code>EventTarget | null</code>。TypeScript告诉我们，<code>event.target</code>可能是<code>null</code>——不是基于我们的代码，而是基于定义本身。</p>
<p>在这个例子中，我们知道<code>event.target</code>将被定义，因为事件来自于<code>&lt;input&gt;</code>元素，我们为其添加了一个监听器。我们可以有把握地假设<code>event.target</code>不为空。为此，我们可以使用TypeScript的<a href="https://blog.logrocket.com/understanding-exclamation-mark-typescript/" target="_blank" rel="noopener">非空断言操作符</a>(<code>!</code>操作符)。应该非常小心地使用这个操作符，但是这里是安全的:</p>
<pre class="language-typescript hljs">input.addEventListener('input', event =&gt; {
  console.log('Got value:', event.target!.value);
});</pre>
<p>这解决了“可能为空”的错误，但是还有另一个问题:</p>
<pre class="language-plaintext hljs">Property 'value' does not exist on type 'EventTarget'.
</pre>
<p>我们知道这里的<code>event.target</code>指的是<code>&lt;input&gt;</code>元素(一个<code>HTMLInputElement</code>)，但是类型定义说<code>event.target</code>是<code>EventTarget</code>的类型，而<em>没有</em>属性。</p>
<p>为了安全地访问<code>value</code>属性，我们需要将<code>event.target</code>转换为<code>HTMLInputElement</code>:</p>
<pre class="language-typescript hljs">input.addEventListener('input', event =&gt; {
  const target = event.target as HTMLInputElement;
  console.log('Got value:', target.value);
});</pre>
<p>注意，我们也不再需要<code>!</code>操作符。当我们将<code>event.target</code>设定为<code>HTMLInputElement</code>时，我们不会考虑它是<code>null</code>的可能性(如果有这种可能性，我们会将其设定为<code> HTMLInputElement | null</code>)。</p>
<h3 id="error-messages-difficult-decipher">错误消息可能很难解读</h3>
<p>简单的类型错误通常很容易理解和修复，但是有时TypeScript会产生一些错误消息，这些消息在最好的情况下是无用的，在最坏的情况下是不可理解的。</p>
<p>下面是一个简单用户数据库的一些代码:</p>
<pre class="language-typescript hljs">interface User {
  username: string;
  roles: string[];
}

const users: User[] = [
  { username: 'bob', roles: ['admin', 'user']},
  { username: 'joe', roles: ['user']}
];</pre>
<p>我们有一个用户列表和一个描述用户的类型定义。用户有一个用户名和一个或多个角色。让我们编写一个函数，生成这些用户的所有唯一角色的数组:</p>
<pre class="language-typescript hljs">const roles = users.reduce((result, user) =&gt; { // Huge error here!
  return [
    ...result,
    ...user.roles.filter(role =&gt; !result.includes(role)) // Minor error here
  ];
}, []);</pre>
<p>我们从一个空数组开始，对于每个用户，我们添加每个我们还没有见过的角色。</p>
<p>我们得到的错误消息可能会让初学者永远远离TypeScript:</p>
<pre class="language-plaintext hljs">No overload matches this call.
  Overload 1 of 3, '(callbackfn: (previousValue: User, currentValue: User, currentIndex: number, array: User[]) =&gt; User, initialValue: User): User', gave the following error.
    Argument of type '(result: never[], user: User) =&gt; Role[]' is not assignable to parameter of type '(previousValue: User, currentValue: User, currentIndex: number, array: User[]) =&gt; User'.
      Types of parameters 'result' and 'previousValue' are incompatible.
        Type 'User' is missing the following properties from type 'never[]': length, pop, push, concat, and 26 more.
  Overload 2 of 3, '(callbackfn: (previousValue: never[], currentValue: User, currentIndex: number, array: User[]) =&gt; never[], initialValue: never[]): never[]', gave the following error.
    Argument of type '(result: never[], user: User) =&gt; Role[]' is not assignable to parameter of type '(previousValue: never[], currentValue: User, currentIndex: number, array: User[]) =&gt; never[]'.
      Type 'Role[]' is not assignable to type 'never[]'.
        Type 'string' is not assignable to type 'never'.
          Type 'string' is not assignable to type 'never'.</pre>
<p>我们如何解决这个巨大的错误信息？我们需要对传递给<code>reduce</code>的回调做一点小小的改变。TypeScript已经正确地推断出<code>user</code>参数的类型是<code>User</code>(因为我们在一个由<code>User</code> s组成的数组上调用<code>reduce</code>，但是它找不到<code>result</code>数组的类型。在这种情况下，TypeScript赋予空数组一种类型<code>never[]</code>。</p>
<p>要解决这个问题，我们只需向<code>result</code>数组添加一个类型，并告诉TypeScript它是一个<code>Role</code>的数组，错误消失，构建过程成功。</p>
<pre class="language-typescript hljs">const roles = users.reduce((result: Role[], user) =&gt; {
  return [
    ...result,
    ...user.roles.filter(role =&gt; !result.includes(role))
  ];
}, []);</pre>
<p>我们收到的错误消息虽然在技术上是正确的，但却难以理解(尤其是对初学者而言)。</p>
<h3 id="build-performance-suffer">构建性能可能会受到影响</h3>
<p>TypeScript的类型检查优势不是没有代价的。类型检查会减慢构建过程，尤其是在大型项目中。如果您运行的是在代码更改时重新加载的开发服务器，当您等待代码生成时，缓慢的TypeScript生成步骤会降低开发速度。</p>
<p>有一些方法可以解决这个问题。例如，可以用Babel代替TypeScript编译器，用<code>@babel/plugin-transform-typescript plugin</code>将TypeScript转换成JavaScript。此插件仅传输文件；它不执行类型检查。</p>
<p>通过使用<code>noEmit</code>选项运行TypeScript编译器，可以单独进行类型检查。这将检查类型，但不会输出任何JavaScript。通过使用两步过程，当您需要快速开发服务器时，可以跳过类型检查，类型检查可以作为额外的测试步骤或产品构建的一部分来完成。</p>
<h3 id="not-foolproof">这不是万无一失的</h3>
<p>当我们将某些内容转换为另一种类型或使用转义符(如非空断言操作符)时，TypeScript相信我们的话。如果我在表达式后添加了<code>!</code>操作符，TypeScript不会警告我它可能是<code>null</code>的情况。我可能错过了一个可能的场景，其中值实际上可能是<code>null</code>，并引入了一个bug。早先关于虚假安全感的警告在这里同样适用。</p>
<p>由于这有效地禁用了类型检查，许多项目使用了一个<a href="https://typescript-eslint.io/rules/no-non-null-assertion/" target="_blank" rel="noopener"> ESLint规则</a>，禁止使用<code>!</code>操作符。</p>
<h2>接受好的和坏的</h2>
<p>不同的团队会对这些好处和痛点产生不同的共鸣。对某些人来说，好处可能超过性能、严格性和无益的错误。然而，其他人可能认为这不值得。</p>
<p>当遇到令人困惑的错误时，一些开发人员可能会将值强制转换为<code>any</code>，这通常会满足TypeScript的要求(但代价是可能会出现本来可以避免的错误)。对此也有一个T2法则。当然，也有绕过ESLint的方法。</p>
<p>有效地使用TypeScript需要耐心和耐心去倾听编译器告诉你的东西。花时间正确地解决一个棘手的错误可能是痛苦的，但如果你坚持下去，通常会有回报。</p>
<p>另一方面，如果您预期使用<code>!</code>操作符，强制转换为<code>any</code>，并使用其他技巧来消除错误，您将无法获得TypeScript的全部好处。在这种情况下，你可能要考虑是否值得做出改变。</p><div class="code-block code-block-21">
<div class="blog-plug inline-plug typescript-plug"><h2><a class="signup" href="https://lp.logrocket.com/blg/typescript-signup" target="_blank" rel="noopener noreferrer"> LogRocket </a>:全面了解您的网络和移动应用</h2>
<a href="https://lp.logrocket.com/blg/typescript-signup" class="signup" target="_blank" rel="noopener noreferrer"><img class="alignnone size-full wp-image-46 jetpack-lazy-image" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/><noscript><img data-lazy-fallback="1" class="alignnone size-full wp-image-46" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/></noscript></a>
<p>LogRocket 是一个前端应用程序监控解决方案，可以让您回放问题，就像问题发生在您自己的浏览器中一样。LogRocket不需要猜测错误发生的原因，也不需要向用户询问截图和日志转储，而是让您重放会话以快速了解哪里出错了。它可以与任何应用程序完美配合，不管是什么框架，并且有插件可以记录来自Redux、Vuex和@ngrx/store的额外上下文。</p>
<p>除了记录Redux操作和状态，LogRocket还记录控制台日志、JavaScript错误、堆栈跟踪、带有头+正文的网络请求/响应、浏览器元数据和自定义日志。它还使用DOM来记录页面上的HTML和CSS，甚至为最复杂的单页面和移动应用程序重新创建像素级完美视频。</p>
<a class="signup" href="https://lp.logrocket.com/blg/typescript-signup" target="_blank" rel="noopener noreferrer">Try it for free</a><p>.</p></div>
</div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
<html>
<head>
<title>Authentication with Phoenix </title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>通过Phoenix认证</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/phoenix-authentication/#0001-01-01">https://blog.logrocket.com/phoenix-authentication/#0001-01-01</a></blockquote><div><article class="article-post">
<p>Phoenix是一个基于Elixir的web开发框架，它使用服务器端模型视图控制器(MVC)设计模式。它的实现(组件和结构)可以与其他知名框架相媲美，包括Ruby on Rails、Node的Express.js和Python的Django。Phoenix利用了众所周知的web开发结构，如果您已经在该领域工作过，那么学习起来很简单。</p>
<p>在本教程中，我们将学习如何使用<code>phx.gen.auth</code>生成器向Phoenix应用程序添加身份验证。由于其灵活性、安全性以及实现了Elixir的最佳实践，所以<code>phx.gen.auth</code>生成器被广泛使用。<code>Phx.gen.auth</code>包含在Phoenix框架中，是向Phoenix应用程序添加身份验证的推荐方式。</p>
<p>我们将涵盖:</p>

<h2>先决条件</h2>

<p>要在您的系统上安装Elixir，请访问<a href="https://elixir-lang.org/install.html"> Elixir文档</a>，并按照您的操作系统的安装说明进行操作。</p>
<h2 id="getting-started-phoenix">凤凰城入门</h2>
<p>运行以下命令在您的系统上安装Phoenix:</p>
<pre class="language-elixir hljs">mix archive.install hex phx_new 
</pre>
<p>上面的命令指示<a href="https://elixir-lang.org/getting-started/mix-otp/introduction-to-mix.html"> Mix </a>安装Phoenix框架。与其他主流编程语言类似，Elixir提供了Mix build工具来帮助编译、创建和测试应用程序，以及安装、更新和卸载依赖项。如果没有Mix这样的工具，使用Elixir是不可想象的。</p>
<h2 id="creating-phoenix-application">创建Phoenix应用程序</h2>
<p>通过用<code>phx.new</code>命令提供<code>--no-ecto</code>标志，可以创建一个没有数据库的Phoenix应用程序，但是因为我们需要数据持久性，所以我们将使用数据库。本课选择的数据库是PostgreSQL，Phoenix应用程序的标准选择。</p>
<p>要安装PostgreSQL，<a href="https://www.enterprisedb.com/downloads/postgres-postgresql-downloads">参考文档</a>或者你可以访问这个<a href="https://blog.logrocket.com/build-rest-api-elixir-phoenix/">教程</a>来使用Docker安装和运行:</p>
<pre class="language-elixir hljs">mix phx.new todo_app
</pre>
<p>这里，<code>todo</code>是我们希望创建的应用程序的名称。当提示<code>Fetch and install dependencies? [Yn]</code>时，选择<strong>是</strong>。在获取依赖项之后，我们还有几个步骤来启动和运行我们的应用程序。</p>
<p>首先，我们必须进入我们新创建的应用程序目录:</p>
<pre class="language-elixir hljs">cd todo_app 
</pre>
<h2 id="updating-database-credentials">更新数据库凭据</h2>
<p>接下来，我们必须配置我们的数据库，找到<code>config/dev.exs</code>，并且<br/>更新下面一行来反映我们的Postgres数据库<code>username</code>和<code>password</code>:</p>
<pre class="language-elixir hljs">username: "postgres",
password: "postgres",
</pre>
<p>然后，运行以下命令创建数据库:</p>
<pre class="language-elixir hljs">mix ecto.create
</pre>
<p>最后，我们可以使用以下命令运行我们的服务器:</p>
<pre class="language-elixir hljs">mix phx.server
</pre>
<p>访问<code><a href="http://localhost:4000" rel="nofollow">http://localhost:4000</a></code>查看您的Phoenix应用程序:</p>
<p><img data-attachment-id="148709" data-permalink="https://blog.logrocket.com/phoenix-authentication/attachment/phoenix-app/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/12/phoenix-app.png" data-orig-size="730,331" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Phoenix app" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/12/phoenix-app-300x136.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/12/phoenix-app.png" decoding="async" class="aligncenter size-full wp-image-148709 jetpack-lazy-image" src="../Images/b84bf68e7b56a498c624210795020487.png" alt="Phoenix App" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2022/12/phoenix-app.png 730w, https://blog.logrocket.com/wp-content/uploads/2022/12/phoenix-app-300x136.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2022/12/phoenix-app.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/12/phoenix-app.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="148709" data-permalink="https://blog.logrocket.com/phoenix-authentication/attachment/phoenix-app/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/12/phoenix-app.png" data-orig-size="730,331" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Phoenix app" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/12/phoenix-app-300x136.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/12/phoenix-app.png" decoding="async" loading="lazy" class="aligncenter size-full wp-image-148709" src="../Images/b84bf68e7b56a498c624210795020487.png" alt="Phoenix App" srcset="https://blog.logrocket.com/wp-content/uploads/2022/12/phoenix-app.png 730w, https://blog.logrocket.com/wp-content/uploads/2022/12/phoenix-app-300x136.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/12/phoenix-app.png"/></noscript>
<h2 id="generating-mvc-html-resource-using-phxgenhtml">使用<code>phx.gen.html</code>为HTML资源生成MVC</h2>
<p>Phoenix为我们提供了一种为HTML资源生成控制器、视图和上下文的方法:</p>
<pre class="language-elixir hljs">mix phx.gen.html Todo Task tasks name:string completed:boolean</pre>
<p>我们向<code>phx.gen.html</code>生成器提供了两个参数，第一个是上下文模块，接下来是模式模块的名称，最后是模式的复数名称(该名称将用作模式表名称)。<code>name:string</code>和<code>completed:boolean</code>是将在<code>tasks</code>表中创建的两个字段。</p>
<p>看终端，可以看到凤凰提供的指令:</p>
<p>首先，我们必须将<code>resources "/tasks", TaskController</code>复制到我们的<code>lib/todo_app_web/router.ex</code>文件中:</p>
<pre class="language-elixir hljs">defmodule TodoAppWeb.Router do
use TodoAppWeb, :router
...

scope "/", TodoAppWeb do
pipe_through(:browser)
get("/", PageController, :index)
resources "/tasks", TaskController #updated
end
...</pre>
<p><code>resources</code>代表不同的HTTP方法——Phoenix提供了<code>resources</code>,而不是显式地写出每个方法。</p>
<p>然后，我们必须更新我们的数据库，以更新由<code>phx.gen.html</code>所做的更改:</p>
<pre class="language-elixir hljs">mix ecto.migrate</pre>
<p>最后，要访问生成的任务路径，请访问<code><a href="http://localhost:4000/tasks" rel="nofollow">http://localhost:4000/tasks</a></code>:</p>
<p><img data-attachment-id="148711" data-permalink="https://blog.logrocket.com/phoenix-authentication/attachment/phoenix-framework-tasks/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/12/phoenix-framework-tasks.png" data-orig-size="730,332" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Phoenix framework tasks" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/12/phoenix-framework-tasks-300x136.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/12/phoenix-framework-tasks.png" decoding="async" class="aligncenter size-full wp-image-148711 jetpack-lazy-image" src="../Images/da98f2b0ffe3ae446ec98aa9c07b5ad3.png" alt="Phoenix Framework Tasks" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2022/12/phoenix-framework-tasks.png 730w, https://blog.logrocket.com/wp-content/uploads/2022/12/phoenix-framework-tasks-300x136.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2022/12/phoenix-framework-tasks.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/12/phoenix-framework-tasks.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="148711" data-permalink="https://blog.logrocket.com/phoenix-authentication/attachment/phoenix-framework-tasks/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/12/phoenix-framework-tasks.png" data-orig-size="730,332" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Phoenix framework tasks" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/12/phoenix-framework-tasks-300x136.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/12/phoenix-framework-tasks.png" decoding="async" loading="lazy" class="aligncenter size-full wp-image-148711" src="../Images/da98f2b0ffe3ae446ec98aa9c07b5ad3.png" alt="Phoenix Framework Tasks" srcset="https://blog.logrocket.com/wp-content/uploads/2022/12/phoenix-framework-tasks.png 730w, https://blog.logrocket.com/wp-content/uploads/2022/12/phoenix-framework-tasks-300x136.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/12/phoenix-framework-tasks.png"/></noscript>
<p>在上面的截图中，我添加了几个未完成的任务。你可以随意做同样的事情，并尝试一下这个应用程序。Phoenix为这些生成的资源提供了开箱即用的CRUD能力，因此不需要任何额外的代码，我们就可以从数据库中创建、更新和删除任务。</p>
<h2 id="authentication-phxgenauth">使用<code>phx.gen.auth</code>验证</h2>
<p>Phoenix提供了一种非常简单的方法，使用<code>phx.gen.auth</code>生成器向我们的应用程序添加身份验证。让我们看看如何做到这一点。</p>
<p>在您的终端中，运行:</p>
<pre class="language-elixir hljs">mix phx.gen.auth Accounts User users</pre>
<p>使用这个命令，用一个模块为<code>Accounts.User</code>模式创建一个<code>Accounts</code>上下文。最后一个参数是模式模块的复数形式，它创建数据库表名和路由助手。<code>mix phx.gen.auth</code>生成器类似于<code>mix phx.gen.htm``l</code>生成器，除了它不接受添加到模式中的额外字段列表，并且它生成更多的上下文函数。</p>
<p>查看我们的终端，我们可以看到Phoenix已经生成了几个文件，并且还更新了现有的文件。我们稍后将查看其中的一些文件，尤其是<code>lib/todo_app_web/router.ex</code>文件，但是让我们快速运行几个命令。</p>
<p>在您的终端中，运行:</p>
<pre class="language-elixir hljs">mix deps.get</pre>
<p>此命令更新您的应用程序依赖项。我们还需要更新我们的数据库，以反映由<code>phx.gen.auth</code>生成器所做的更改。</p>
<p>现在，运行以下命令:</p>
<pre class="language-elixir hljs">mix ecto.migrate</pre>
<p>如果我们检查浏览器中运行的应用程序，我们可以看到由<code>phx.gen.auth</code>生成器生成的<code>Register</code>和<code>Log in</code>:</p>
<p><img data-attachment-id="148714" data-permalink="https://blog.logrocket.com/phoenix-authentication/attachment/phoenix-registration-login/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/12/phoenix-registration-login.png" data-orig-size="730,335" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Phoenix registration and login" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/12/phoenix-registration-login-300x138.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/12/phoenix-registration-login.png" decoding="async" class="aligncenter size-full wp-image-148714 jetpack-lazy-image" src="../Images/710c76a233f7ff63ceb24cae9fa4f06f.png" alt="Phoenix Registration And Login" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2022/12/phoenix-registration-login.png 730w, https://blog.logrocket.com/wp-content/uploads/2022/12/phoenix-registration-login-300x138.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2022/12/phoenix-registration-login.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/12/phoenix-registration-login.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="148714" data-permalink="https://blog.logrocket.com/phoenix-authentication/attachment/phoenix-registration-login/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/12/phoenix-registration-login.png" data-orig-size="730,335" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Phoenix registration and login" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/12/phoenix-registration-login-300x138.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/12/phoenix-registration-login.png" decoding="async" loading="lazy" class="aligncenter size-full wp-image-148714" src="../Images/710c76a233f7ff63ceb24cae9fa4f06f.png" alt="Phoenix Registration And Login" srcset="https://blog.logrocket.com/wp-content/uploads/2022/12/phoenix-registration-login.png 730w, https://blog.logrocket.com/wp-content/uploads/2022/12/phoenix-registration-login-300x138.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/12/phoenix-registration-login.png"/></noscript>
<p>在应用程序上注册，您应该会看到一个“用户创建成功”的弹出消息。</p>
<h2 id="exploring-files-created-phxgenauth">浏览由<code>phx.gen.auth</code>创建的文件</h2>
<p>让我们来看看由<code>phx.gen.auth</code>创建的一些文件。</p>
<p>位于<code>lib/todo_app_web/router.ex</code>的路由器文件已经存在，<code>phx.gen.auth</code>生成器只是添加了几行代码:</p>
<pre class="language-elixir hljs">...
## Authentication routes
  scope "/", TodoAppWeb do
    pipe_through [:browser, :redirect_if_user_is_authenticated]
    get "/users/register", UserRegistrationController, :new
    post "/users/register", UserRegistrationController, :create
    get "/users/log_in", UserSessionController, :new
    post "/users/log_in", UserSessionController, :create
    get "/users/reset_password", UserResetPasswordController, :new
    post "/users/reset_password", UserResetPasswordController, :create
    get "/users/reset_password/:token", UserResetPasswordController, :edit
    put "/users/reset_password/:token", UserResetPasswordController, :update
  end

  scope "/", TodoAppWeb do
    pipe_through [:browser, :require_authenticated_user]
    get "/users/settings", UserSettingsController, :edit
    put "/users/settings", UserSettingsController, :update
    get "/users/settings/confirm_email/:token", UserSettingsController, :confirm_email
  end

  scope "/", TodoAppWeb do
    pipe_through [:browser]
    delete "/users/log_out", UserSessionController, :delete
    get "/users/confirm", UserConfirmationController, :new
    post "/users/confirm", UserConfirmationController, :create
    get "/users/confirm/:token", UserConfirmationController, :edit
    post "/users/confirm/:token", UserConfirmationController, :update
  end
...
</pre>
<p><code>:require_authenticated_user</code>和<code>:redirect_if_user_is_authenticated</code>称为插头。之后出现的路由遵循它们所声明的规则。</p>
<p><code>:require_authenticated_user</code>插件允许我们保护路由不被未经认证的用户访问，而<code>:redirect_if_user_is_authenticated</code>插件允许我们阻止经过认证的用户访问某些路由。</p>
<p><code>:require_authenticated_user</code>和<code>:redirect_if_user_is_authenticated</code>插头均来自<code>lib\todo_app_web\controllers\user_auth.ex</code>控制器；</p>
<pre class="language-elixir hljs">def redirect_if_user_is_authenticated(conn, _opts) do
    if conn.assigns[:current_user] do
      conn
      |&gt; redirect(to: signed_in_path(conn))
      |&gt; halt()
    else
      conn
    end
  end
  @doc """
  Used for routes that require the user to be authenticated.
  If you want to enforce the user email is confirmed before
  they use the application at all, here would be a good place.
  """
  def require_authenticated_user(conn, _opts) do
    if conn.assigns[:current_user] do
      conn
    else
      conn
      |&gt; put_flash(:error, "You must log in to access this page.")
      |&gt; maybe_store_return_to()
      |&gt; redirect(to: Routes.user_session_path(conn, :new))
      |&gt; halt()
    end
</pre>
<h2 id="adding-authentication-tasks-routes">向我们的<code>/tasks</code>路线添加身份验证</h2>
<p>目前，我们的<code>/tasks</code>路线不要求用户在访问它们之前进行身份验证。如果我们愿意，我们可以将我们的<code>/tasks</code>路由分成不同的HTTP方法。因此，这一行只有一个<code>resource</code>来访问所有方法:</p>
<pre class="language-elixir hljs">resources "/tasks", TaskController</pre>
<p>与以下内容相同:</p>
<pre class="language-elixir hljs">get "/tasks", TaskController, :index
post "/tasks", TaskController, :create
get "/tasks/new", TaskController, :new
get "/tasks/:id", TaskController, :show
get "/tasks/:id/edit", TaskController, :edit
put "/tasks/:id/update", TaskController, :update
delete "/tasks/:id/delete", TaskController, :delete
</pre>
<p>为了使这些路由要求用户认证，我们所要做的就是将<code>resources</code>放在<code>:require_authenticated_user</code>插头后面:</p>
<pre class="language-elixir hljs">scope "/", TodoAppWeb do
    pipe_through [:browser, :require_authenticated_user]
    ...
    resources "/tasks", TaskController
  end
</pre>
<p>注销应用程序，然后尝试访问<code>http:localhost:4000/tasks</code>路线。您将被重定向到登录路径，并显示一条错误消息:</p>
<p><img data-attachment-id="148716" data-permalink="https://blog.logrocket.com/phoenix-authentication/attachment/phoenix-login-error-message/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/12/phoenix-login-error-message.png" data-orig-size="730,316" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Phoenix login error message" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/12/phoenix-login-error-message-300x130.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/12/phoenix-login-error-message.png" decoding="async" class="aligncenter size-full wp-image-148716 jetpack-lazy-image" src="../Images/9bfd40188ecee81767aca744479f60a8.png" alt="Phoenix Login Error Message" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2022/12/phoenix-login-error-message.png 730w, https://blog.logrocket.com/wp-content/uploads/2022/12/phoenix-login-error-message-300x130.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2022/12/phoenix-login-error-message.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/12/phoenix-login-error-message.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="148716" data-permalink="https://blog.logrocket.com/phoenix-authentication/attachment/phoenix-login-error-message/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/12/phoenix-login-error-message.png" data-orig-size="730,316" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Phoenix login error message" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/12/phoenix-login-error-message-300x130.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/12/phoenix-login-error-message.png" decoding="async" loading="lazy" class="aligncenter size-full wp-image-148716" src="../Images/9bfd40188ecee81767aca744479f60a8.png" alt="Phoenix Login Error Message" srcset="https://blog.logrocket.com/wp-content/uploads/2022/12/phoenix-login-error-message.png 730w, https://blog.logrocket.com/wp-content/uploads/2022/12/phoenix-login-error-message-300x130.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/12/phoenix-login-error-message.png"/></noscript>
<p>您只能在登录时访问这些路线。就是这样！我们已经在Phoenix应用程序中实现了身份验证。</p>
<h2 id="conclusion">结论</h2>
<p>在本教程中，我们学习了如何在Phoenix应用程序中实现身份验证，方法是使用<code>phx.gen.auth</code>生成器为我们的应用程序生成身份验证，并了解它为我们提供的中间件。希望在这篇教程的帮助下，你可以用Phoenix实现更多。</p><div class="code-block code-block-4">
<div class="blog-plug base-cta"><h2>使用<a class="signup" href="https://lp.logrocket.com/blg/signup" target="_blank" rel="noopener noreferrer"> LogRocket </a>消除传统错误报告的干扰</h2>
<a href="https://lp.logrocket.com/blg/signup" class="signup" target="_blank" rel="noopener noreferrer"><img class="alignnone size-full wp-image-46 jetpack-lazy-image" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/><noscript><img data-lazy-fallback="1" class="alignnone size-full wp-image-46" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/></noscript></a>
<p><a href="https://lp.logrocket.com/blg/signup" target="_blank" rel="noopener noreferrer"> LogRocket </a>是一个数字体验分析解决方案，它可以保护您免受数百个假阳性错误警报的影响，只针对几个真正重要的项目。LogRocket会告诉您应用程序中实际影响用户的最具影响力的bug和UX问题。</p>
<p>然后，使用具有深层技术遥测的会话重放来确切地查看用户看到了什么以及是什么导致了问题，就像你在他们身后看一样。</p>
<p>LogRocket自动聚合客户端错误、JS异常、前端性能指标和用户交互。然后LogRocket使用机器学习来告诉你哪些问题正在影响大多数用户，并提供你需要修复它的上下文。</p>
<p>关注重要的bug—<a class="signup" href="https://lp.logrocket.com/blg/signup-issue-free" target="_blank" rel="noopener noreferrer">今天就试试LogRocket】。</a></p></div></div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
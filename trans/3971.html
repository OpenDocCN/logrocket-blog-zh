<html>
<head>
<title>How to force a Vue component to re-render </title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>如何强制一个Vue组件重新渲染</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/force-vue-component-re-render/#0001-01-01">https://blog.logrocket.com/force-vue-component-re-render/#0001-01-01</a></blockquote><div><article class="article-post">
<p>Vue.js是一个通用的、可增量采用的JavaScript UI框架。凭借其<a href="https://blog.logrocket.com/your-guide-to-reactivity-in-vue-js/">独特的架构和反应系统</a>，只要JavaScript状态发生变化，Vue就会更新DOM。然而，在某些情况下，这种方法是不够的，我们需要重新呈现单个组件。</p>
<p>在本文中，我们将回顾一些有效地重新呈现Vue组件的最佳实践，这样我们就可以避免重新加载整个页面。以下四个基本实践适用于Vue 2和Vue 3。我们开始吧！</p>
<p><em>向前跳转:</em></p>

<h2 id="hot-reload">热重装</h2>
<p>每当我们更新一个文件时，热重载不仅仅是重载一个页面。当我们在启用热重载的情况下修改一个<code>*.vue</code>文件中的组件时，Vue将交换该组件的所有实例，而不刷新页面。因此，它保留了我们的应用程序的当前状态以及交换的组件，从而在您显著修改组件的模板或样式时改善了开发人员的体验。</p>
<h3>使用热重装</h3>
<p>每当您使用Vue CLI搭建项目时，热重新加载将被启用。此外，当您手动设置一个新项目时，当您使用<code>webpack-dev-server --hot</code>为您的项目提供服务时，会自动启用热重装。</p>
<p>对于高级用例，我推荐查看一下<a href="https://github.com/vuejs/vue-hot-reload-api"> vue-hot-reload-api </a>，这是Vue Loader内部使用的。</p>
<h3>禁用热重装</h3>
<p>热重装始终自动启用，除非在以下情况下:</p>
<ul>
<li>webpack<code>target</code>为[t1(SSR)</li>
<li>webpack简化了代码</li>
<li><code>process.env.NODE_ENV === 'production'</code></li>
</ul>
<p>要特别禁用热重装，使用<code>hotReload: false</code>选项:</p>
<pre class="language-javascript hljs">module: {
  rules: [
    {
      test: /\.vue$/,
      loader: 'vue-loader',
      options: {
        hotReload: false // disables Hot Reload
      }
    }
  ]
}
</pre>
<h3>国家保存规则</h3>
<p>当重新渲染组件时，热重载过程遵循一组<a href="https://vue-loader.vuejs.org/guide/hot-reload.html#state-preservation-rules">状态保存规则</a>。</p>
<p>如果你编辑一个组件的<code>&lt;template&gt;</code>,被编辑组件的实例将在适当的位置重新渲染，保持所有现有的私有状态。这可以通过组合模板来创建新的渲染函数，而不会产生副作用。</p>
<p>当一个组件的<code>&lt;script&gt;</code>部分被改变时，被修改组件的实例将被销毁并在适当的位置重新创建。这是因为<code>&lt;script&gt;</code>中的生命周期挂钩可能会产生副作用，需要重新加载而不是重新渲染来保持一致性。</p>
<p>因此，在组件生命周期挂钩中使用计时器或其他全局副作用时，应该小心谨慎。有时，如果一个组件有全局副作用，我们必须重新加载整个页面。</p>
<p>请记住，应用程序状态不受<code>&lt;style&gt;</code>热重载的影响，因为它是通过<code>vue-style-loader</code>独立运行的。</p>
<h2 id="vue-v-if-hack">黑客攻击</h2>
<p>Vue库中包含的<a href="https://vuejs.org/guide/essentials/conditional.html"> <code>v-if</code>指令</a>仅在给定条件为<code>true</code>时呈现组件。如果是<code>false</code>，组件不会出现在DOM中。因此，创造性地使用<code>v-if</code>指令可能是一个更好的解决方案。</p>
<p>在这个模板中，让我们设置一个<code>v-if</code>指令:</p>
<pre class="language-bash hljs">&lt;template&gt;
  &lt;MyComponent v-if="renderComponent" /&gt;
&lt;/template&gt;
</pre>
<p>在<code>script</code>部分，我们将添加一个名为<code>forceRender</code>的方法，它使用<code><a href="https://vuejs.org/api/general.html#nexttick">nextTick</a></code>，一个等待下一次DOM更新刷新的实用程序:</p>
<pre class="language-javascript hljs">import { nextTick, ref } from 'vue';
const renderComponent = ref(true);

const forceRender = async () =&gt; {
  // Here, we'll remove MyComponent
  renderComponent.value = false;

   // Then, wait for the change to get flushed to the DOM
  await nextTick();

  // Add MyComponent back in
  renderComponent.value = true;
};
</pre>
<p>在我们使用选项API而不是<a href="https://blog.logrocket.com/how-to-build-applications-with-vues-composition-api/">组合API </a>的场景中，我们的<code>script</code>看起来更像下面的代码:</p>
<pre class="language-javascript hljs">export default {
  data() {
    return {
      renderComponent: true,
    };
  },
  methods: {
    async forceRender() {
   // Remove MyComponent from the DOM
   this.renderComponent = false;

   // Then, wait for the change to get flushed to the DOM
      await this.$nextTick();

      // Add MyComponent back in
      this.renderComponent = true;
    }
  }
};
</pre>
<p>在上面的代码片段中，<code>renderComponent</code>最初被设置为<code>true</code>，呈现<code>MyComponent</code>。每当我们调用<code>forceRender</code>，<code>renderComponent</code>就被设置为<code>false</code>。这样做会停止渲染<code>MyComponent</code>，因为<code>v-if</code>指令现在计算为<code>false</code>。</p>
<p>在<code>MyComponent</code>停止渲染后，我们立即等待滴答，然后将<code>renderComponent</code>设置回<code>true</code>。这也将<code>v-if</code>指令设置为<code>true</code>，这将呈现<code>MyComponent</code>的刷新实例</p>
<p>有两个因素对解读<code>nextTick()</code>如何运作至关重要。首先，我们必须等到下一个tick，除非我们对<code>renderComponent</code>的更新会自行取消，我们不会注意到任何变化。</p>
<p>在Vue中，可以在状态改变后立即使用<code>nextTick()</code>来等待DOM更新完成。我们可以将回调作为参数传递，或者等待返回的承诺。</p>
<p>Vue将销毁之前的组件，因为当我们第二次渲染它时，它会创建一个全新的组件。因此，我们新的<code>MyComponent</code>将经历所有典型的生命周期，<code>created</code>，<code>mounted</code>，等等。</p>
<h2 id="vues-built-in-force-update-method">Vue的内置<code>forceUpdate</code>方法</h2>
<p>正如Vue官方文档所推荐的，内置的<code>forceUpdate</code>方法是手动更新组件的最佳方式之一。</p>
<p>通常，Vue会更新视图以响应依赖关系的变化。即使所有的依赖关系都没有改变，我们仍然可以通过调用<code><a href="https://vuejs.org/api/component-instance.html#forceupdate">forceUpdate</a></code>方法来强制更新，这将强制组件实例重新呈现。</p>
<p>然而，这违背了整个反应系统的目的。因此，在这些情况下，不建议将其作为一种修复方法。我们错误地认为Vue会对特定属性或变量的变化做出反应，但这并不总是反应系统的工作方式。</p>
<p>下面的代码演示了如何使用Vue Options API调用<code>forceUpdate</code>方法:</p>
<pre class="language-javascript hljs">export default {
  methods: {
    ForcesUpdateComponent() {
      // our code
      this.$forceUpdate();  // Notice we have to use a $ here
      // our code
    }
  }
}
</pre>
<p>这个方法只存在于组件实例中，所以我们需要发挥一点创造性，使用Vue 3的组合API来调用它:</p>
<pre class="language-javascript hljs">import { getCurrentInstance } from 'vue';

const methodThatForcesUpdate = () =&gt; {
  // our code
  const instance = getCurrentInstance();
  instance.proxy.forceUpdate();
  // our code
};
</pre>
<p>我们可能想要使用<code>forceUpdate</code>方法的唯一情况是当我们已经使用高级反应性API显式地创建了一个非反应性组件状态时。然而，鉴于Vue的全自动反应系统，这是可选的。</p>
<h2 id="the-key-changing-technique">换键技术</h2>
<p>使用键改变技术，我们提供一个<code>key</code>属性来通知Vue一个特定的组件被连接到一个特定的数据。如果<code>key</code>保持不变，组件不会改变。但是，如果<code>key</code>改变了，Vue知道它需要删除以前的组件并生成一个新的组件。</p>
<h3>为什么Vue需要一个<code>key</code>？</h3>
<p>让我们更深入地研究一下<code>key</code>属性具体做什么，以及我们为什么需要它。让我们假设我们正在呈现一个组件列表，其中包括以下一个或多个组件:</p>
<ul>
<li>地方政府</li>
<li>一个初始化过程，或者使用Vue 3的<code>setup</code>函数，或者在使用选项API时使用<code>created</code>和<code>mounted</code>钩子</li>
<li>通过jQuery或普通API实现的非反应式DOM操作</li>
</ul>
<p>当排序或更新那个列表时，我们不想重新呈现列表上的所有内容；我们只想重新呈现我们更新过的列表部分。为了实现这一点，我们将提供一个<code>key</code>属性来帮助Vue跟踪什么已经改变，什么没有改变。由于数组的索引与列表中的具体条目无关，在这种情况下使用它没有任何意义。</p>
<p>换键技术被认为是强制Vue重新渲染组件的最佳方式。下面是说明这一点的基本方法:</p>
<pre class="language-javascript hljs">&lt;template&gt;
  &lt;MyComponent :key="componentKey" /&gt;
&lt;/template&gt;

&lt;script&gt;
import { ref } from 'vue';
const componentKey = ref(0);

const forceRender = () =&gt; {
  componentKey.value += 1;
};
&lt;/script&gt;
</pre>
<p>在上面的代码片段中，我们将为<code>MyComponent</code>添加一个<code>key</code>属性，然后每当我们需要重新呈现<code>MyComponent</code>时就更改那个<code>key</code>。</p><div class="code-block code-block-54">
<hr/>
<h3>更多来自LogRocket的精彩文章:</h3>

<hr/></div>
<p>使用Options API而不是Vue 3或Composition API，看起来如下所示:</p>
<pre class="language-javascript hljs">export default {
  data() {
    return {
      componentKey: 0,
    };
  },
  methods: {
    forceRender() {
      this.componentKey += 1;
    }
  }
}
</pre>
<p>每当调用<code>forceRender</code>时，<code>componentKey</code>的值就会改变。当这种情况发生时，Vue将意识到它必须销毁组件并初始化一个新的组件。我们还将得到一个子组件，它将重置其状态并重新初始化自身。</p>
<h2 id="conclusion">结论</h2>
<p>理想情况下，我们应该能够利用Vue强大的反应系统，避免使用这种粗糙的解决方法，但有些情况下，我们必须强制组件重新渲染，以完成手头的任务。在本文中，我们介绍了强制Vue组件重新呈现的四种不同方法，包括热重载、<code>v-if</code> hack、<code>forceUpdate</code>方法，最后是密钥更改技术。</p>
<p>正确的方法最终将取决于您发现自己所处的独特情况，然而，密钥更改技术通常是一个安全的赌注。我希望你喜欢这篇文章！如果你有任何问题，一定要留下评论。编码快乐！</p><div class="code-block code-block-20">
<div class="blog-plug inline-plug vue-inline"><h2>像用户一样体验您的Vue应用</h2><p>调试Vue.js应用程序可能会很困难，尤其是当用户会话期间有几十个(如果不是几百个)突变时。如果您对监视和跟踪生产中所有用户的Vue突变感兴趣，</p><a href="https://lp.logrocket.com/blg/vue-signup" target="_blank">try LogRocket</a><p>. </p><a class="signup" href="https://lp.logrocket.com/blg/vue-signup" target="_blank" rel="noopener noreferrer"><img class="alignnone size-full wp-image-46 jetpack-lazy-image" src="../Images/0d269845910c723dd7df26adab9289cb.png" alt="LogRocket Dashboard Free Trial Banner" data-lazy-src="https://files.readme.io/00591d0-687474703a2f2f692e696d6775722e636f6d2f6a3049327856572e706e67.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://files.readme.io/00591d0-687474703a2f2f692e696d6775722e636f6d2f6a3049327856572e706e67.png"/><noscript><img data-lazy-fallback="1" class="alignnone size-full wp-image-46" src="../Images/0d269845910c723dd7df26adab9289cb.png" alt="LogRocket Dashboard Free Trial Banner" data-original-src="https://files.readme.io/00591d0-687474703a2f2f692e696d6775722e636f6d2f6a3049327856572e706e67.png"/></noscript></a><a href="https://lp.logrocket.com/blg/vue-signup" target="_blank" rel="noopener noreferrer">https://logrocket.com/signup/</a><p>LogRocket 就像是网络和移动应用程序的DVR，记录你的Vue应用程序中发生的一切，包括网络请求、JavaScript错误、性能问题等等。您可以汇总并报告问题发生时应用程序的状态，而不是猜测问题发生的原因。</p><p>LogRocket Vuex插件将Vuex突变记录到LogRocket控制台，为您提供导致错误的环境，以及出现问题时应用程序的状态。</p><p>现代化您调试Vue应用的方式- <a class="signup" href="https://lp.logrocket.com/blg/vue-signup" target="_blank" rel="noopener noreferrer">开始免费监控</a>。</p></div>


</div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
<html>
<head>
<title>Using Dagger with Docker for better CI/CD </title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>使用Dagger和Docker以获得更好的CI/CD</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/using-dagger-with-docker-for-better-ci-cd/#0001-01-01">https://blog.logrocket.com/using-dagger-with-docker-for-better-ci-cd/#0001-01-01</a></blockquote><div><article class="article-post">
<p>在开发或本地环境中构建和管理应用程序可能是开发人员的日常工作。像任何事情，如果更直白一点不是很好吗？幸运的是，有一种工具叫做匕首！</p>
<p>在本文中，我们将展示如何使用Dagger和Docker来改进您的<a href="https://blog.logrocket.com/ci-cd-tools-compared-circleci-travis-ci-vs-major-csps/"> CI/CD </a>管道。</p>
<p><em>向前跳转:</em></p>

<h2 id="ci-cd-important">为什么CI/CD很重要</h2>
<p>CI/CD管道已经成为我们软件开发生命周期的重要部分。虽然它们使得可靠和一致地发布软件变得容易得多，但是它们也增加了一定程度的复杂性，并且需要开发人员记住一点学习曲线。</p>
<p>大多数CI/CD工具都托管在云上，这意味着您必须将您的更改推送到远程存储库，并且通常要等待很长时间才能执行CI流程。</p>
<p>你可能会想为什么我们不能在本地运行它。嗯，大多数CI/CD工具都不能在本地工作，而能在本地工作的工具也很难安装。我们需要的是能够在我们的机器上本地运行我们的CI/CD管道，同时在我们选择的基于云的CI/CD工具中运行。</p>
<p>这就是匕首的用处。</p>
<h2 id="what-dagger">匕首是什么？</h2>
<p>Dagger是一个用于CI/CD的开源开发工具包。它使用Cue工作，这是一种由Google开发的强大的配置语言，有助于验证和定义基于文本的动态配置。我们还将使用BuildKit，在其中执行Dagger的配置。</p>
<p>此外，客户机-服务器架构与Docker的概念相同。同时，Dagger <a href="https://docs.dagger.io/1223/custom-buildkit/">守护进程</a>引擎可以在任何容器运行时运行。</p>
<p>Dagger旨在通过标准化我们编写CI/CD管道的方式来解决许多问题。在本教程中，我们将探索如何安装和设置Dagger并构建一个容器映像。</p>
<p>在我们继续之前，有必要熟悉以下技术:</p>
<ul>
<li>Dagger:一个允许在本地开发、测试和执行管道的工具</li>
<li>CUE:一种帮助验证和定义基于文本的动态配置的语言</li>
<li>Docker:一个用于开发、发布和运行应用程序的开源平台</li>
<li>CI/CD:持续集成(CI)和持续交付(CD)是一种现代软件开发实践，在这种实践中，增量代码变更是一致且可靠的</li>
</ul>
<blockquote><p><b>注意</b>，Dagger的配置在<a href="https://docs.docker.com/develop/develop-images/build_enhancements/"> BuildKit </a>中执行——这是Docker引擎最常用的功能之一</p></blockquote>
<h2 id="installation"><strong>安装</strong></h2>
<p>在开始之前，您需要安装Docker引擎，因为这是Dagger工作所必需的。如果你没有安装Docker，你可以使用Docker <a href="https://docs.docker.com/get-docker/">安装</a>脚本来安装。</p>
<h3 id="docker">码头工人</h3>
<p>运行以下命令开始:</p>
<pre class="language-shell hljs">curl -fsSL https://get.docker.com -o get-docker.sh
sh get-docker.sh
</pre>
<p>一旦完成，您可以运行<code>docker version</code>来确保Docker安装正确。</p>
<h3 id="dagger">匕首</h3>
<p>下一步是安装Dagger，这可以使用以下安装脚本来完成:</p>
<pre class="language-shell hljs">cd /usr/local
curl -L https://dl.dagger.io/dagger/install.sh | sh
</pre>
<p>如果您不是超级用户，您可能需要在最后一个命令前面加上<code>sudo</code>。</p>
<p>一旦完成，运行命令<code>dagger version</code>确认Dagger的安装。</p>
<blockquote><p><strong>注意</strong>，如果你没有运行Linux或macOS，或者你在安装过程中遇到任何问题，你可以查看官方安装指南<a href="https://docs.dagger.io/install/">这里</a>。</p></blockquote>
<h2 id="dagger-does">匕首能做什么</h2>
<p>在任何CI系统中，您都需要以某种格式(很可能是YAML)定义步骤和操作，并在您的CI系统中运行它。</p>
<p>匕首可以:</p>
<ol>
<li>用你喜欢的编程语言自动操作</li>
<li>在本地机器上立即测试和调试</li>
<li>在任何Docker兼容的运行时上与现有管道集成</li>
<li>重用大型且不断增长的目录中的操作</li>
<li>使用提示语言将它们联系在一起</li>
</ol>
<h2 id="dagger-actions-lifecycle">匕首动作和生命周期</h2>
<p>正如在<a href="https://docs.dagger.io/1221/action/">官方文档</a>中提到的，动作是Dagger的基本构建模块——它们将复杂的自动化抽象成可以重用的简单组件。</p>
<p>可以使用以下命令执行操作:</p>
<pre class="language-shell hljs">dagger do &lt;action_name&gt;
</pre>
<p>Dagger的一个很酷的特点是不需要区分管道和步骤；一切都只是一个动作。</p>
<p>有两种类型的匕首动作:</p>
<ul>
<li>核心动作，由Dagger引擎本身实现</li>
<li>复合动作，由其他动作组成</li>
</ul>
<p>复合动作有四个生命周期阶段:</p>
<ul>
<li>定义:描述动作的输入、输出、子动作及其连接的提示语法</li>
<li>集成:动作定义和Dagger计划之间的关系</li>
<li>发现:识别复合动作</li>
<li>执行:运行复合动作</li>
</ul>
<p><img data-attachment-id="142272" data-permalink="https://blog.logrocket.com/using-dagger-with-docker-for-better-ci-cd/attachment/lifecycle-dagger-composite-action-2/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/11/lifecycle-dagger-composite-action-1.png" data-orig-size="730,1268" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="lifecycle-dagger-composite-action" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/11/lifecycle-dagger-composite-action-1-173x300.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/11/lifecycle-dagger-composite-action-1-590x1024.png" decoding="async" class="aligncenter wp-image-142272 size-full jetpack-lazy-image" src="../Images/c411c3e55e560bfecf675b98e7a265fd.png" alt="Lifecycle Of A Dagger Composite Action" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2022/11/lifecycle-dagger-composite-action-1.png 730w, https://blog.logrocket.com/wp-content/uploads/2022/11/lifecycle-dagger-composite-action-1-173x300.png 173w, https://blog.logrocket.com/wp-content/uploads/2022/11/lifecycle-dagger-composite-action-1-590x1024.png 590w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2022/11/lifecycle-dagger-composite-action-1.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/11/lifecycle-dagger-composite-action-1.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="142272" data-permalink="https://blog.logrocket.com/using-dagger-with-docker-for-better-ci-cd/attachment/lifecycle-dagger-composite-action-2/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/11/lifecycle-dagger-composite-action-1.png" data-orig-size="730,1268" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="lifecycle-dagger-composite-action" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/11/lifecycle-dagger-composite-action-1-173x300.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/11/lifecycle-dagger-composite-action-1-590x1024.png" decoding="async" loading="lazy" class="aligncenter wp-image-142272 size-full" src="../Images/c411c3e55e560bfecf675b98e7a265fd.png" alt="Lifecycle Of A Dagger Composite Action" srcset="https://blog.logrocket.com/wp-content/uploads/2022/11/lifecycle-dagger-composite-action-1.png 730w, https://blog.logrocket.com/wp-content/uploads/2022/11/lifecycle-dagger-composite-action-1-173x300.png 173w, https://blog.logrocket.com/wp-content/uploads/2022/11/lifecycle-dagger-composite-action-1-590x1024.png 590w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/11/lifecycle-dagger-composite-action-1.png"/></noscript>
<h2 id="setting-dagger-plan">建立我们的匕首计划</h2>
<p>一切从计划开始！关键字<code>dagger.#Plan</code>用于识别Dagger配置文件中的一个计划。</p>
<p>计划是行动的执行上下文。它规定:</p>
<ul>
<li>向最终用户呈现什么操作</li>
<li>这些任务之间的相关性</li>
<li>任务和客户端系统之间的交互</li>
</ul>
<p>现在，让我们继续使用Dagger来构建容器图像。</p>
<h2 id="building-docker-images-dagger">用匕首塑造码头工人形象</h2>
<p>Dagger可以执行常规的Docker文件来构建容器映像。</p>
<p>首先，您需要创建一个包含以下内容的<code>main.py</code>文件(这将是一个Python应用程序):</p>
<pre class="language-python hljs"># filename: main.py

from flask import Flask
app = Flask(__name__)
@app.route("/")
def hello_world():
    return "&lt;p&gt;Hello, Dagger!&lt;/p&gt;"
</pre>
<p>下一步是创建Dagger配置文件；<code>dagger.cue</code>。</p>
<pre class="language-json hljs">// filename: dagger.cue
package main

import (
    "dagger.io/dagger"
    "universe.dagger.io/docker"
)

#PythonBuild: docker.#Dockerfile &amp; {
    dockerfile: contents: """
        FROM python:3.7-stretch
        RUN apt-get update -y
        RUN apt-get install -y python-pip python-dev build-essential
        COPY . /app
        WORKDIR /app
        RUN pip install flask
        ENTRYPOINT ["python"]
        CMD ["main.py"]
        """
}

dagger.#Plan &amp; {
    client: filesystem: "./": read: contents: dagger.#FS
    actions: build: #PythonBuild &amp; {
        source: client.filesystem."./".read.contents
    }
}
</pre>
<p>从Dagger配置中可以看到，该操作从我们之前创建的Python应用程序构建了一个Docker映像。</p>
<p>此外，构建步骤是使用内联方法定义的，这允许我们在Dagger的配置中编写Dockerfile内容。</p>
<p>这是初始化和更新项目所必需的，因为这会安装这些必需的Dagger包。您可以使用以下命令来完成此操作:</p>
<pre class="language-shell hljs">dagger project init
dagger project update
</pre>
<p>现在，我们可以使用Docker继续执行构建计划。若要触发生成操作，请运行以下命令:</p>
<pre class="language-shell hljs">dagger do build 
</pre>
<p>您还可以通过检查Docker映像列表来验证映像是否存在，从而确认Dagger已经使用Docker文件内容成功构建了容器映像，如下所示:</p>
<p><img data-attachment-id="142274" data-permalink="https://blog.logrocket.com/using-dagger-with-docker-for-better-ci-cd/attachment/dockerfile-contents-2/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/11/dockerfile-contents-1.png" data-orig-size="730,172" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="dockerfile-contents" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/11/dockerfile-contents-1-300x71.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/11/dockerfile-contents-1.png" decoding="async" class="aligncenter wp-image-142274 size-full jetpack-lazy-image" src="../Images/e5d53b0a5831adc1cb85a06d53debb0d.png" alt="Dockerfile Contents " data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2022/11/dockerfile-contents-1.png 730w, https://blog.logrocket.com/wp-content/uploads/2022/11/dockerfile-contents-1-300x71.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2022/11/dockerfile-contents-1.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/11/dockerfile-contents-1.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="142274" data-permalink="https://blog.logrocket.com/using-dagger-with-docker-for-better-ci-cd/attachment/dockerfile-contents-2/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/11/dockerfile-contents-1.png" data-orig-size="730,172" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="dockerfile-contents" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/11/dockerfile-contents-1-300x71.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/11/dockerfile-contents-1.png" decoding="async" loading="lazy" class="aligncenter wp-image-142274 size-full" src="../Images/e5d53b0a5831adc1cb85a06d53debb0d.png" alt="Dockerfile Contents " srcset="https://blog.logrocket.com/wp-content/uploads/2022/11/dockerfile-contents-1.png 730w, https://blog.logrocket.com/wp-content/uploads/2022/11/dockerfile-contents-1-300x71.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/11/dockerfile-contents-1.png"/></noscript>
<p>现在，您知道如何用Dagger构建容器图像了！</p>
<h2 id="benefits-dagger-docker-ci-cd">在CI/CD中使用Dagger和Docker的好处</h2>
<p>Dagger正在努力取代复杂的Bash脚本，许多现有的CI/CD系统需要这些脚本来代替更模块化、更快速和更便携的组件。</p>
<p>您可以创建可重用的模块，这些模块适应您的需求并依赖于您用来生成它们的工具，其他人可以使用您的模块作为起点来创建适合他们独特用例的新模块。</p>
<p>作为一个在咨询公司工作的人，我们有许多用例，在这些用例中，我们必须频繁地在使用不同CI/CD堆栈的项目之间切换。因此，在当前CI运行程序的基础上构建一个抽象层的承诺对我来说很有吸引力——独立于CI运行程序，我们可以建立自己的流程，并将它们应用到我们的项目中。</p>
<h2 id="conclusion">结论</h2>
<p>结束我们今天的文章，有几个用例来说明为什么您可能希望将Dagger与Docker一起用于您的CI/CD管道。</p>
<p>如果您经常编写复杂的构建或部署脚本，在团队之间共享大部分脚本，花费大量时间尝试调试CI中的问题，或者更喜欢本地构建是一个简单的脚本，那么Dagger很可能是您的工具。</p>
<p>同样，如果您的CI管道在可以并行化的情况下花费太长时间来串行执行任务，那么它可能也适合您。最后，我们今天工作的项目展示了使用Dagger创建容器图像是多么简单！</p>
<p>以下是一些对您的项目有用的附加资源:</p>

<p>在下面的评论区让我知道你使用Dagger和Docker的经历吧！</p><div class="code-block code-block-4">
<div class="blog-plug base-cta"><h2>使用<a class="signup" href="https://lp.logrocket.com/blg/signup" target="_blank" rel="noopener noreferrer"> LogRocket </a>消除传统错误报告的干扰</h2>
<a href="https://lp.logrocket.com/blg/signup" class="signup" target="_blank" rel="noopener noreferrer"><img class="alignnone size-full wp-image-46 jetpack-lazy-image" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/><noscript><img data-lazy-fallback="1" class="alignnone size-full wp-image-46" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/></noscript></a>
<p><a href="https://lp.logrocket.com/blg/signup" target="_blank" rel="noopener noreferrer"> LogRocket </a>是一个数字体验分析解决方案，它可以保护您免受数百个假阳性错误警报的影响，只针对几个真正重要的项目。LogRocket会告诉您应用程序中实际影响用户的最具影响力的bug和UX问题。</p>
<p>然后，使用具有深层技术遥测的会话重放来确切地查看用户看到了什么以及是什么导致了问题，就像你在他们身后看一样。</p>
<p>LogRocket自动聚合客户端错误、JS异常、前端性能指标和用户交互。然后LogRocket使用机器学习来告诉你哪些问题正在影响大多数用户，并提供你需要修复它的上下文。</p>
<p>关注重要的bug—<a class="signup" href="https://lp.logrocket.com/blg/signup-issue-free" target="_blank" rel="noopener noreferrer">今天就试试LogRocket】。</a></p></div></div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
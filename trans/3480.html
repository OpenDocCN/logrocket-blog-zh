<html>
<head>
<title>Building a simple guessing game with Rust Rhai - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>用Rust Rhai - LogRocket博客构建一个简单的猜谜游戏</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/building-game-rust-rhai/#0001-01-01">https://blog.logrocket.com/building-game-rust-rhai/#0001-01-01</a></blockquote><div><article class="article-post">
<p>Rhai是Rust的一种简单的嵌入式脚本语言。它提供了一种向Rust应用程序添加脚本的安全有效的方法。Rhai的语法与JavaScript密切相关，这使得它更容易相对快速地掌握。</p>
<p>在这篇文章中，我们将看看Rhai，并用Rust和Rhai构建一个非常简单的游戏。</p>
<p>如果你是Rust的新手，你可以看看我们的档案<a href="https://blog.logrocket.com/tag/rust/" target="_blank" rel="noopener">这里</a>找到大量关于Rust开发的所有基础知识的信息，作为起点，你可能会感兴趣。</p>
<p>也就是说，让我们继续这篇文章，在学习Rhai如何使用Rust之前，先快速浏览一下它。</p>
<p><em>向前跳转:</em></p>

<h2 id="rust">什么是铁锈？</h2>
<p>Rust是当今非常流行的语言。几年来，它一直被开发者选为最受欢迎的编程语言。尽管它的学习曲线很陡，但是一旦你掌握了它，Rust会比其他语言提供很多好处，比如安全性、可维护性和可伸缩性。</p>
<p>许多公司已经采用Rust作为他们技术堆栈的一部分。Rust也有一个强大的社区支持它，如果你正在长期寻找一个可扩展的和稳定的编程语言，它是一个很好的选择。</p>
<p>现在您已经知道了什么是Rust，让我们看看Rhai以及它能为您做什么。</p>
<h2 id="rhai">Rhai</h2>
<p>Rhai，也称为RhaiScript，是一种快速的嵌入式脚本语言。它的核心目的是让您能够在Rust应用程序中编写脚本。</p>
<p>“Rhai”这个名字来自Chai，一种C++语言的脚本语言。和Rhai类似，Chai可以用来用C++写脚本。还有其他脚本语言，如Lua，它可以与多种语言一起工作，如C和Python。</p>
<p>使用Rhai的一个主要优势是其简单的语法。与Rust不同，正如我提到的，Rust的学习曲线相对较陡，Rhai在语法上类似于JavaScript。</p>
<p>这使得Rhai在构建大规模Rust应用程序时非常有用。您甚至可以使用Rhai在Rust中编写复杂的算法，这是为Rust编写脚本的理想选择。</p>
<p>此外，与JavaScript等其他脚本语言相比，Rhai是内存安全的。Rust的核心原则之一是内存安全，所以Rhai总是在受控的环境中运行——Rhai脚本不能改变其环境中的任何值，并且总是在沙箱中运行。使Rhai对开发人员极具吸引力的其他一些特性包括:</p>
<ul>
<li>动态打字</li>
<li>与本机Rust函数和类型紧密集成</li>
<li>支持通过作用域将Rust值作为变量或常量传递到脚本中</li>
<li>从Rust调用脚本定义的函数</li>
<li>对额外依赖的需求最小</li>
<li>插件和库可以用来扩展Rhai的功能</li>
<li>函数和运算符重载</li>
<li>可以捕获共享值的闭包的可用性</li>
<li>用于修复错误的调试界面</li>
</ul>
<h2 id="writing-scripts-rhai">用Rhai编写脚本</h2>
<p>现在您已经知道了Rhai可以做什么，让我们看几个Rhai脚本的例子。</p>
<p>如果你想跟进，你可以使用<a href="https://rhai.rs/playground/stable/" target="_blank" rel="noopener">在线游乐场</a>自己尝试一些脚本。要在你的系统上安装和运行Rhai，你可以遵循这里的安装说明<a href="https://rhai.rs/book/start/install.html" target="_blank" rel="noopener"/>。</p>
<p>首先，让我们用Rhai写一个hello world函数。</p>
<p>要在Rhai中使用Rust，您必须创建一个脚本引擎实例。然后，您可以编写您的Rhai脚本，并通过调用run()函数来执行它。</p>
<pre class="language-rhai hljs">use rhai::{Engine, EvalAltResult};

pub fn main() -&gt; Result&lt;(), Box&lt;EvalAltResult&gt;&gt;
{
  let engine = Engine::new(); // create an instance of "Engine"
  let script = "print('Hello World');"; // one line Rhai script stored in a variable
  engine.run(script)?; // Run the script
  Ok(())
}
</pre>
<p>看看上面的例子，我们调用“Engine”的一个实例来运行hello world脚本。但是运行Rhai脚本的最佳方式是将代码保存在文件中，然后从Rust函数中调用它们。</p>
<p>这是另一个从Rhai脚本文件执行hello world代码的例子。首先，在. rhai文件中编写Rhai代码。</p>
<pre class="language-rhai hljs">// fiename: helloworld.rhai
print("Hello world");
</pre>
<p>然后，您可以使用run_file或eval_file方法从Rust函数调用您的Rhai文件。</p>
<pre class="language-rust hljs">// filename hello.rs
use rhai::{Engine, EvalAltResult};

pub fn main() -&gt; Result&lt;(), Box&lt;EvalAltResult&gt;&gt;
{
  let engine = Engine::new(); // create an instance of "Engine"
  engine.run_file("helloworld.rhai".into())?; // run the rhai script
  Ok(())
}
</pre>
<h2 id="writing-game-rhai">用Rhai写游戏</h2>
<p>现在让我们用Rust和Rhai来尝试一个简单的游戏。我们将编写一个猜谜游戏，生成一个1到100之间的随机数，用户将一直猜，直到猜对为止。</p>
<p>我们将使用货物启动一个项目。<a href="https://doc.rust-lang.org/cargo/" target="_blank" rel="noopener"> Cargo </a>是Rust的一个包管理器，类似于Node.js的npm，除了一些其他有用的功能，它还可以帮助我们创建新项目和管理项目中的依赖关系。</p>
<p>(注意:<a href="https://github.com/manishmshiva/guessing-game-rust-rhai" target="_blank" rel="noopener">这里的</a>是项目的完整源代码，如果你想继续的话)</p>
<pre class="language-rhai hljs">$ cargo new guessing_game
     Created binary (application) `guessing_game` package
$ cd guessing_game
$ ls
Cargo.toml src
</pre>
<p>Cargo.toml文件包含项目的依赖项。在这个项目中，我们将使用两个依赖项— Rand和Rhai。</p><div class="code-block code-block-54">
<hr/>
<h3>更多来自LogRocket的精彩文章:</h3>

<hr/></div>
<p>我们需要Rand模块来生成一个随机数。Rhai模块用于调用Rhai引擎运行我们的脚本。</p>
<p>现在我们已经设置了项目，我们可以开始编写代码了。我们的游戏逻辑是这样工作的:</p>
<ul>
<li>生成一个1到100之间的数字</li>
<li>从用户那里获得猜测值作为输入。=</li>
<li>如果数字大于猜测值，让用户知道并再次获得猜测值</li>
<li>如果数字小于猜测值，让用户知道并再次猜测</li>
<li>如果用户猜出了正确的数字，告诉他们他们赢了，并退出该功能</li>
</ul>
<p>在这个猜谜游戏中，我们将把条件流委托给Rhai。我们将从用户那里获得输入，并将输入和目标数一起发送给Rhai，告诉我们猜测值是大于、小于还是正确。</p>
<p>在我们开始写脚本之前，让我们理解作用域的概念。在Rust中，您可以创建一个作用域并向其中添加值。然后，可以将这个范围发送给我们的Rhai脚本，该脚本可以访问这个范围中的值。理解这一点很重要，因为由于内存安全的限制，Rhai不能直接改变Rust程序中的任何值。</p>
<p>因此，让我们编写一个Rhai脚本，其中的函数接受一个参数，即猜测。我们将在Rust中创建一个作用域，并在运行时添加原始目标数并发送给Rhai。</p>
<pre class="language-rhai hljs">// filename: guess.rhai

fn guess(input) {
    if input == target{
        print(`Congrats! You Won!!!`);
        return true;
    }
    else if input &gt; target{
        print(`INPUT TOO BIG`);
        return false;
    }
    else{
        print(`INPUT TOO SMALL`);
        return false;
    }
}
</pre>
<p>现在，让我们用Rust调用这个脚本。我们将把用户输入提示放在一个循环中，并使用Rhai来检查他们是否猜到了正确的数字。我们将向用户发送反馈，直到他们猜出正确的数字。</p>
<p>在前面的示例中，我们看到了运行脚本的engine.run_file函数。更好的方法是先编译脚本，然后调用脚本中的函数。对于Rhai，我们使用AST编译器。AST编译器超出了本文的范围，所以如果您想了解更多，这里的是一个很好的参考资料。</p>
<pre class="language-rhai hljs">// src/main.rs
use rhai::{Engine, Scope, EvalAltResult};
use rand::Rng;
use std::io;
pub fn main() -&gt; Result&lt;(), Box&lt;EvalAltResult&gt;&gt;{

    let engine = Engine::new(); //invoke the RHAI engine
    let mut scope = Scope::new(); // create a new scope

    let target = rand::thread_rng().gen_range(1..=100); // generate a random number between 1 and 100
    scope.push("target", target); // adding the target number to scope for Rhai

    // use ast compiler to compile the script
    let ast = engine.compile_file("guess.rhai".into())?;

    println!("{}","Guess the number!");

    // loop till the user guesses the correct number
    loop{
        let mut input = String::new(); // variable to get user input

        // get the input from user
        io::stdin()
            .read_line(&amp;mut input)
            .expect("Failed to read line");

        // convert the input from string to number
        let guess: i32 = input
            .trim()
            .parse()
            .expect("Wanted a number");

        // call the guess function from the compiled script and pass scope along with the input number. Returns a boolean value. 
        let result = engine.call_fn::&lt;bool&gt;(&amp;mut scope, &amp;ast, "guess", ( guess,) )?;

        // if "true" is returned, break out of the loop
        if result {
            break
        };
    }

    Ok(())
}
</pre>
<p>您可以看到，我们已经调用了Rhai引擎的一个实例，随后创建了一个范围。随后生成一个1到100之间的随机数，并将其推送到作用域。</p>
<p>然后，我们编译Rhai脚本，用于调用“guess”函数。现在，我们可以创建一个循环，从用户那里获得输入，并使用Rhai脚本运行逻辑。</p>
<p>如果猜测正确，脚本返回true。这是用来中断循环的。我们使用engine.call_fn方法来传递元组中的作用域、函数名和函数参数。</p>
<p>现在，让我们运行我们的脚本。我们可以使用“货物运行”命令来构建和运行我们的Rust程序。</p>
<pre><code>$ cargo run
</code></pre>
<p><img data-attachment-id="137307" data-permalink="https://blog.logrocket.com/building-game-rust-rhai/attachment/cargo-run-command-display/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/10/cargo-run-command-display.png" data-orig-size="730,245" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="cargo-run-command-display" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/10/cargo-run-command-display-300x101.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/10/cargo-run-command-display.png" decoding="async" class="wp-image-137307 size-full aligncenter jetpack-lazy-image" src="../Images/d04733b3f7e3b924421959046e4591d1.png" alt="The cargo run command display" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2022/10/cargo-run-command-display.png 730w, https://blog.logrocket.com/wp-content/uploads/2022/10/cargo-run-command-display-300x101.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2022/10/cargo-run-command-display.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/10/cargo-run-command-display.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="137307" data-permalink="https://blog.logrocket.com/building-game-rust-rhai/attachment/cargo-run-command-display/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/10/cargo-run-command-display.png" data-orig-size="730,245" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="cargo-run-command-display" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/10/cargo-run-command-display-300x101.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/10/cargo-run-command-display.png" decoding="async" loading="lazy" class="wp-image-137307 size-full aligncenter" src="../Images/d04733b3f7e3b924421959046e4591d1.png" alt="The cargo run command display" srcset="https://blog.logrocket.com/wp-content/uploads/2022/10/cargo-run-command-display.png 730w, https://blog.logrocket.com/wp-content/uploads/2022/10/cargo-run-command-display-300x101.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/10/cargo-run-command-display.png"/></noscript>
<p>恭喜你。你已经用Rust和Rhai编写了你的第一个游戏。您还可以使用Rhai来实现更复杂的脚本和算法，这些脚本和算法在Rust中可能更难编写。</p>
<h2 id="limitations-rhai">Rhai的局限性</h2>
<p>到目前为止，我们已经看到了很多关于Rhai和使用Rhai编写脚本的内容。现在，让我们看看Rhai的一些缺点。</p>
<ul>
<li>有限的脚本功能:Rhai不支持类或其他复杂的数据结构，所以Rhai最适合编写实用程序脚本，而不是全面的应用程序</li>
<li>没有垃圾收集:和Rust一样，Rhai也没有垃圾收集</li>
<li>没有正式的语言语法:与JavaScript或Lua等脚本语言不同，Rhai缺乏正式的语言语法。这限制了Rhai在面向对象语法方面的能力，比如使用继承、接口或泛型</li>
</ul>
<h2 id="alternatives-rhai">Rhai的替代品</h2>
<p>Rhai并不是Rust唯一的脚本语言。让我们来看看您可能希望考虑的其他几个选项。</p>
<h3 id="gamelisp">游戏列表</h3>
<p>如果你正在寻找一个编写游戏的脚本引擎，Gamelisp 是Rhai的一个很好的替代品。Gamelisp可以很容易地与Rust集成，并且比Rhai拥有更多的功能来编写游戏。这包括垃圾收集、内存安全以及与Rust api的无缝集成。</p>
<h3 id="throne">君主</h3>
<p><a href="https://lib.rs/crates/throne" target="_blank" rel="noopener">王座</a>是Rust的另一个有用的游戏脚本语言。它提供了快速原型和故事逻辑功能，这使它成为在Rust中编写游戏的绝佳选择。与Rhai相比，王座相对不受欢迎，但正在稳步赢得一个开发者社区。</p>
<h3 id="dyon">双荷子</h3>
<p>Dyon是Rust的另一种动态脚本语言。Dyon的特性包括4D向量、宏和动态模块。如果你想写简单的游戏和交互式编程环境，这是一个很好的选择。</p>
<h2 id="conclusion">结论</h2>
<p>Rhai是一种非常棒的Rust脚本语言。在使用Rust这样复杂的语言时，它为开发人员提供了简单的脚本编写体验。从编写复杂的算法到简单的游戏，Rhai都是很好的工具。</p>
<p>与任何脚本语言一样，Rhai也面临着it挑战。它是为使用Rust而设计的，所以它没有提供使用JavaScript等语言时所期望的全部功能。也就是说，在用Rust构建应用程序时，Rhai是脚本语言的绝佳选择。</p><div class="code-block code-block-29">
<div class="blog-plug inline-plug rust-plug"><h2><a href="https://lp.logrocket.com/blg/rust-signup" target="_blank">log rocket</a>:Rust应用的web前端的全面可见性</h2><p>调试Rust应用程序可能很困难，尤其是当用户遇到难以重现的问题时。如果您对监控和跟踪Rust应用程序的性能、自动显示错误、跟踪缓慢的网络请求和加载时间感兴趣，</p><a href="https://lp.logrocket.com/blg/rust-signup" target="_blank">try LogRocket</a><p>. </p><a class="signup" href="https://lp.logrocket.com/blg/rust-signup" target="_blank" rel="noopener noreferrer"><img class="alignnone size-full wp-image-46 jetpack-lazy-image" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/><noscript><img data-lazy-fallback="1" class="alignnone size-full wp-image-46" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/></noscript></a><p>LogRocket 就像是网络和移动应用程序的DVR，记录你的Rust应用程序上发生的一切。您可以汇总并报告问题发生时应用程序的状态，而不是猜测问题发生的原因。LogRocket还可以监控应用的性能，报告客户端CPU负载、客户端内存使用等指标。</p><p>现代化调试Rust应用的方式— <a class="signup" href="https://lp.logrocket.com/blg/rust-signup" target="_blank" rel="noopener noreferrer">开始免费监控</a>。</p></div>


</div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
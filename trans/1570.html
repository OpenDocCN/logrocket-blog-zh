<html>
<head>
<title>Theming in Next.js with styled-components and useDarkMode - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>在 Next.js 中使用 styled-components 和 useDarkMode - LogRocket 博客进行主题化</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/theming-in-next-js-with-styled-components-and-usedarkmode/#0001-01-01">https://blog.logrocket.com/theming-in-next-js-with-styled-components-and-usedarkmode/#0001-01-01</a></blockquote><div><article class="article-post">
 <p>除了功能性，颜色可以说是应用程序第二重要的方面。正确的配色方案有助于你为你的应用程序设置基调，并向用户展示如何与之互动。</p>
<p>在许多情况下，让用户选择他们喜欢的配色方案并在主题之间切换可能是一个卖点。但是你不想让你的用户被众多的主题所淹没。通常情况下，浅色和深色主题是你创建一个漂亮的用户界面所需要的。</p>
<p>在本教程中，我们将向您展示如何使用<a href="https://styled-components.com/">s</a><a href="https://styled-components.com/">tyled-</a><a href="https://styled-components.com/">c</a><a href="https://styled-components.com/">components</a>库和<a href="https://github.com/donavon/use-dark-mode"> <code>useDarkMode</code> </a>钩子有效地实现黑暗模式和主题 Next.js 应用程序。</p>
<p>我们将讨论以下内容:</p>

<h2 id="whatisdarkmode">什么是黑暗模式？</h2>
<p>深色模式是在深色背景上显示浅色文本和界面元素的任何界面的配色方案，这使得屏幕在手机、平板电脑和计算机上更容易观看。黑暗模式减少了屏幕发出的光线，同时保持可读性所需的最低颜色对比度。</p>
<p>浅色模式是更流行的配色方案，它在明亮的背景上显示较暗的文本。</p>
<p>使用黑暗模式的好处包括:</p>
<ul>
<li>节能</li>
<li>减少对眼睛的压力</li>
<li>看起来很酷</li>
</ul>
<h2 id="whatisstyledcomponents">什么是样式组件？</h2>
<p><a href="https://blog.logrocket.com/using-styled-components-in-react/"> styled-components </a>是一个<a href="https://blog.logrocket.com/5-things-you-can-do-in-css-in-js-that-you-didnt-know-about-c422fb67ceb6/"> CSS-in-JS </a>库，它极大地改善了现代前端开发人员的开发体验，同时提供了近乎完美的用户体验。除了让开发人员能够编写组件范围的 CSS 之外，styled-components 还有许多其他好处，包括:</p>
<ul>
<li>自动供应商前缀</li>
<li>每个样式组件的唯一类名</li>
<li>更容易维护样式——开发人员可以删除或修改样式，而不会影响其他组件</li>
</ul>
<h2 id="themingwithstyledcomponents">使用样式化组件进行主题化</h2>
<p>首先使用 create-next-app 设置一个 Next.js 应用程序，然后安装 styled-components 包。</p>
<pre>npm i styled-components
</pre>
<p>要在 Next.js 应用中使用<a href="https://blog.logrocket.com/build-your-own-styled-components-library/">s</a><a href="https://blog.logrocket.com/build-your-own-styled-components-library/">tyled-</a><a href="https://blog.logrocket.com/build-your-own-styled-components-library/">c</a><a href="https://blog.logrocket.com/build-your-own-styled-components-library/">组件</a>，进入<code>_app.js</code>文件，导入<code>ThemeProvider</code>组件，用<code>ThemeProvider</code>包装应用。</p>
<p>接受一个主题对象作为道具，然后将该对象动态地重新暴露给组件树中任何更深层次的样式化组件。</p>
<pre>import { ThemeProvider } from "styled-components"
</pre>
<p>接下来，创建一个<code>ThemeConfig.js</code>文件。</p>
<pre>import { createGlobalStyle} from "styled-components"

export const lightTheme = {
  body: '#FFF',
  text: '#363537',
  toggleBorder: '#FFF',
  background: '#363537',
}

export const darkTheme = {
  body: '#363537',
  text: '#FAFAFA',
  toggleBorder: '#6B8096',
  background: '#999',
}

export const GlobalStyles = createGlobalStyle`
  body {
    background: ${({ theme }) =&gt; theme.body};
    color: ${({ theme }) =&gt; theme.text};
    font-family: Tahoma, Helvetica, Arial, Roboto, sans-serif;
    transition: all 0.50s linear;
  }
`
</pre>
<p>在这里，我们定义了<code>lightTheme</code>、<code>darkTheme</code>和<code>GlobalStyles</code>。我们需要他们稍后应用程序的主题。在<code>lightTheme</code>中，我们定义了灯光模式样式。在<code>darkTheme</code>中，我们定义了黑暗模式的样式。</p>
<p>我们也从样式化组件中导入<a href="https://styled-components.com/docs/api#createglobalstyle"> <code>createGlobalStyle</code> </a>。该方法生成一个 React 组件，当该组件被添加到组件树中时，会将全局样式注入到文档中。</p>
<p>在<code>GlobalStyles</code>中，我们定义了应用程序主体的样式。当我们从亮模式切换到暗模式时，我们希望背景颜色和文本颜色发生变化。</p>
<p>我们从<code>ThemeProvider</code>中获取当前活动主题的上下文，无论是<code>lightTheme</code>还是<code>darkTheme</code>，并使用该主题的样式来确定应用程序的背景颜色和文本颜色。这样，当我们从亮模式切换到暗模式时，应用程序的主题会动态变化。</p>
<p>现在我们已经为应用程序设置了亮暗主题，我们需要实现切换功能来在亮暗模式之间切换。</p>
<p>为此，在<code>_app.js</code>文件中创建一个主题状态，并设置一个<code>toggleTheme</code>函数:</p>
<pre>const [theme, setTheme] = useState("light") 

const toggleTheme = () =&gt; {
    theme == 'light' ? setTheme('dark') : setTheme('light')
}
</pre>
<p>我们将主题状态传递给<code>ThemeProvider</code>，并根据状态在<code>lightTheme</code>和<code>darkTheme</code>之间切换。</p>
<p><code>toggleTheme</code>是负责检查从<code>light</code>到<code>dark</code>的主题状态的函数。然后，我们将<code>toggleTheme</code>函数传递给一个按钮:</p>
<pre>import { useState } from "react"
import { ThemeProvider } from "styled-components";

const [theme, setTheme] = useState("light") 

const toggleTheme = () =&gt; {
    theme == 'light' ? setTheme('dark') : setTheme('light')
}

return (
  &lt;ThemeProvider&gt;
    &lt;button onClick={toggleTheme}&gt;Switch Theme&lt;/button&gt;
    &lt;Component {...pageProps} /&gt;
  &lt;/ThemeProvider&gt;
) 
</pre>
<p>到目前为止，我们已经为应用程序定义了<code>lightTheme</code>、<code>darkTheme</code>、<code>GlobalStyles</code>和切换功能。现在，让我们把所有东西都放到<code>_app.js</code>文件中:</p>
<pre>import { useState } from "react"
import { ThemeProvider } from "styled-components";
import { lightTheme, darkTheme, GlobalStyles } from "../themeConfig" 

function MyApp({ Component, pageProps }) {
  const [theme, setTheme] = useState("light") 

  const toggleTheme = () =&gt; {
    theme == 'light' ? setTheme('dark') : setTheme('light')
  }

  return (
    &lt;ThemeProvider theme={theme == 'light' ? lightTheme : darkTheme}&gt;
      &lt;GlobalStyles /&gt;
      &lt;button onClick={toggleTheme}&gt;Switch Theme&lt;/button&gt;
      &lt;Component {...pageProps} /&gt;
    &lt;/ThemeProvider&amp;gt;
  ) 
}
export default MyApp
</pre>
<p>这样，我们就成功地使用样式化组件为 Next.js 应用程序设置了主题。</p>
<h2 id="themingwiththeusedarkmodehook">用<code>useDarkMode</code>钩子进行主题化</h2>
<p>钩子是一个有用的样式选择，可以用于主题化。当与样式组件结合使用时，它使应用程序主题化变得简单而有趣。</p>
<p>有了<code>useDarkMode</code>钩子，我们不需要设置一个<code>theme</code>状态或者创建一个从亮到暗模式切换的<code>toggleTheme</code>函数。<code>useDarkMode</code>我们会处理好的。</p>
<p>要开始使用<code>useDarkMode</code>挂钩，首先安装它:</p>
<pre>npm i use-dark-mode
</pre>
<p>接下来，创建钩子的新实例并开始使用它。我在我的<code>_app.js</code>文件中这样做了:</p>
<pre>const darkmode = useDarkMode(true)
</pre>
<p>我们创建的<code>darkmode</code>对象有几个属性。我们需要的是它的<code>value</code>属性。这是一个布尔值，用于检查黑暗模式是否处于活动状态。</p>
<pre>const theme = darkmode.value ? darkTheme : lightTheme

return (
  &lt;ThemeProvider theme={theme}&gt;
    &lt;GlobalStyles /&gt;
    &lt;button onClick={darkmode.toggle}&gt;Switch Mode&lt;/button&gt;
    &lt;button onClick={darkmode.enable}&gt;Dark Mode&lt;/button&gt;
    &lt;button onClick={darkmode.disable}&gt;Light Mode&lt;/button&gt;
    &lt;Component {...pageProps} /&gt;
  &lt;/ThemeProvider&gt;
) 
</pre>
<p>基于<code>darkmode</code>的<code>value</code>，我们在<code>lightTheme</code>和<code>darkTheme</code>之间切换，并将活动主题传递给<code>theme</code>常量。我们将这个活动主题传递到<code>ThemeProvider</code>的<code>theme</code>道具中。</p><div class="code-block code-block-54">
<hr/>
<h3>更多来自 LogRocket 的精彩文章:</h3>

<hr/></div>
<p>我们要设置按钮在亮暗模式之间切换，<code>darkmode</code>对象自带<code>enable()</code>、<code>disable()</code>和<code>toggle()</code>功能。</p>
<p>因此，我们通过将样式化组件与<code>useDarkMode</code>相结合，为我们的应用程序设定了主题。</p>
<p>Next.js 在服务器上呈现页面。虽然这有它的好处，但也有一个代价:SSR 不知道特定于客户端的偏好，比如<code>prefers-color-scheme</code>。这意味着当页面加载到服务器上时，最初没有选择正确的主题。这导致亮暗主题之间的“闪烁”。</p>
<p>为了解决这个问题，我们设置了一个<code>isMounted</code>状态，并将其设置为<code>false</code>。</p>
<pre>const [isMounted, setIsMounted] = useState(false)

useEffect(() =&gt; {
  setIsMounted(true)
}, [])

return (
  &lt;ThemeProvider theme={theme}&gt;
    &lt;GlobalStyles /&gt;
    ...
    {isMounted &amp;&amp; &lt;Component {...pageProps} /&gt;}
  &lt;/ThemeProvider&gt;
) 
</pre>
<p>我们使用<code>useEffect</code>来确定应用程序何时安装，并且仅当<code>isMounted</code>为真时才显示它。这种方式消除了短暂的闪烁。</p>
<p>让我们把这些放在一起:</p>
<pre>import { useState, useEffect } from "react"
import useDarkMode from "use-dark-mode"
import { ThemeProvider } from "styled-components";
import { lightTheme, darkTheme, GlobalStyles } from "../themeConfig"

function MyApp({ Component, pageProps }) {
  const [isMounted, setIsMounted] = useState(false)
  const darkmode = useDarkMode(true)
  const theme = darkmode.value ? darkTheme : lightTheme

  useEffect(() =&gt; {
    setIsMounted(true)
  }, [])

  return (
    &lt;ThemeProvider theme={theme}&gt;
      &lt;GlobalStyles /&gt;
      &lt;button onClick={darkmode.toggle}&gt;Switch Mode&lt;/button&gt;
      &lt;button onClick={darkmode.enable}&gt;Dark Mode&lt;/button&gt;
      &lt;button onClick={darkmode.disable}&gt;Light Mode&lt;/button&gt;
      {isMounted &amp;&amp; &lt;Component {...pageProps} /&gt;}
    &lt;/ThemeProvider&gt;
  ) 
}

export default MyApp
</pre>
<h2 id="usingusedarkmodeandcss">使用<code>useDarkMode</code>和 CSS</h2>
<p>根据你的项目的需要和要求，你可能不需要像样式组件一样使用 CSS-in-JS 库来为你的应用程序设置主题。你也可以使用 CSS 用<code>useDarkMode</code>为你的应用设置主题。</p>
<p>要使用 CSS 将你的应用主题化为<code>useDarkMode</code>，在你的<code>globals.css</code>文件中创建<code>body.light-mode</code>和<code>body.dark-mode</code>类。这些是被<code>useDarkMode</code>认可的特殊阶层。</p>
<pre>body.dark-mode {
  color: #fff;
  background: #363537;

//dark mode styles
}

body.light-mode {
  color: #363537;
  background: #fafafa;

//light mode styles
} 
</pre>
<p>将您在<code>lightTheme</code>和<code>darkTheme</code>中定义的样式复制到这些类中。就是这么快这么简单。</p>
<h2 id="conclusion">结论</h2>
<p>无论是与 CSS-in-JS 库(如 styled-components)结合使用，还是与 CSS 结合使用,<code>useDarkMode</code> Hook 都使应用程序主题化变得更加容易和快速。</p>
<p>当涉及到你的 Next.js 应用的主题化时，你有很多选择。</p><div class="code-block code-block-25">
<div class="blog-plug inline-plug css-plug"><h2>你的前端是否占用了用户的 CPU？</h2><p>随着 web 前端变得越来越复杂，资源贪婪的特性对浏览器的要求越来越高。如果您对监控和跟踪生产环境中所有用户的客户端 CPU 使用、内存使用等感兴趣，</p><a target="_blank" href="https://lp.logrocket.com/blg/css-signup">try LogRocket</a><p>.</p><a class="signup" href="https://lp.logrocket.com/blg/css-signup" target="_blank" rel="noopener noreferrer"><img class="alignnone size-full wp-image-46 jetpack-lazy-image" src="../Images/dacb06c713aec161ffeaffae5bd048cd.png" alt="LogRocket Dashboard Free Trial Banner" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2019/12/cpu-memory-usage.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/12/cpu-memory-usage.png"/><noscript><img data-lazy-fallback="1" class="alignnone size-full wp-image-46" src="../Images/dacb06c713aec161ffeaffae5bd048cd.png" alt="LogRocket Dashboard Free Trial Banner" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/12/cpu-memory-usage.png"/></noscript></a><a href="https://lp.logrocket.com/blg/css-signup" target="_blank" rel="noopener noreferrer">https://logrocket.com/signup/</a><p>LogRocket 就像是网络和移动应用的 DVR，记录你的网络应用或网站上发生的一切。您可以汇总和报告关键的前端性能指标，重放用户会话和应用程序状态，记录网络请求，并自动显示所有错误，而不是猜测问题发生的原因。</p><p>现代化您调试 web 和移动应用的方式— <a class="signup" href="https://lp.logrocket.com/blg/css-signup" target="_blank" rel="noopener noreferrer">开始免费监控</a>。</p></div>
</div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
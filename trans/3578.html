<html>
<head>
<title>Create a custom debounce Hook in React </title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>在React中创建一个自定义的去抖钩子</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/create-custom-debounce-hook-react/#0001-01-01">https://blog.logrocket.com/create-custom-debounce-hook-react/#0001-01-01</a></blockquote><div><article class="article-post">
<p>React v16.8 引入了React钩子和编写功能组件的新一波可能性。有了React钩子，我们可以单独创建可重用的逻辑，这有助于我们<a href="https://blog.logrocket.com/react-hooks-context-redux-state-management/">写出更好、更易管理的代码</a>。</p>
<p>在本文中，我们将在React应用程序中编写一个自定义的反跳钩子，它将延迟几秒钟来处理我们传递的值。我们将创建一个简单的React应用程序来搜索<a href="https://rickandmortyapi.com/"> Rick和Morty </a>角色，并使用自定义的反跳React钩子优化我们的应用程序。</p>
<p><em>向前跳转:</em></p>

<h2 id="what-debounce">什么是去抖？</h2>
<p>去抖是对任何昂贵函数的结果的优化技术。这些函数可能需要大量的执行工作，因此我们将通过模拟一段时间的延迟执行来创建这种效果。使用反跳可以通过分块执行的动作、添加延迟响应和执行最后一次调用来改进React应用程序。</p>
<p>React内置了很多钩子，包括use、<code>useState</code>、<code>useEffect</code>、<code>useMemo</code>、<code>useContext</code>等等。我们甚至可以组合多个钩子，为我们的React应用程序创建<a href="https://blog.logrocket.com/create-your-own-custom-react-hooks/">定制钩子。定制的React钩子是以<code>use</code>关键字开始的函数，后跟我们正在制作的钩子的名字。</a></p>
<p>在创建去抖挂钩之前，我们需要了解以下内容:</p>
<ul>
<li>在循环、条件或嵌套函数中不调用挂钩</li>
<li>多个钩子可以用来建立新的钩子</li>
<li>钩子只能从React函数中调用</li>
<li>钩子是为功能部件制造的。</li>
<li>以单词“use”开头的名称挂钩</li>
</ul>
<p>我们正在构建一个应用程序，它将模拟通过按键发送到后端的过多API调用。为了减少过多的调用，我们将引入<code><a href="https://blog.logrocket.com/how-and-when-to-debounce-or-throttle-in-react/">useDebounce React Hook</a></code>。这个钩子将消耗我们传递的值和计时器。</p>
<p>如果动作被连续调用，我们将只执行最近的用户动作。使用反跳React钩子将减少对服务器不必要的API调用，并优化我们的应用程序以获得更好的性能。</p>
<p>我们开始吧！</p>
<h2 id="creating-react-app">创建我们的React应用</h2>
<p>对于这个应用程序，我们将使用一个简单的React、Vite.js和JavaScript应用程序。我们将在<a href="https://blog.logrocket.com/advanced-techniques-chakra-ui/">查克拉界面</a>中添加一些造型点缀。</p>
<p>让我们用这个命令创建一个Vite.js应用程序:</p>
<pre class="language-javascript hljs">npm create <a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="d5a3bca1b095b9b4a1b0a6a1">[email protected]</a> react-useDebounce
cd react-useDebounce
npm i @chakra-ui/react @emotion/react @emotion/styled framer-motion
</pre>
<p>添加完所有包后，我们可以开始创建<code>components</code>文件夹。我们将从一个简单的<code>TextField</code>开始，它将从Chakra导入:</p>
<pre class="language-javascript hljs">export default function Inputfield({onChange, value}) {
 return (
   &lt;div&gt;
     &lt;Input onChange={onChange} value={value} placeholder='Search your character' size='md' /&gt;
   &lt;/div&gt;
 )
}
</pre>
<p>这个组件是一个简单的输入，它接受一个<code>onChange</code>函数和一个作为道具的<code>value</code>。我们将使用来自API的响应来列出我们找到的所有字符。</p>
<p>我们需要调用我们的端点并接收来自它的响应，因此我们将创建一个<code>Utils</code>文件夹并使用浏览器本地<code><a href="https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API">fetch</a></code> API获取数据:</p>
<pre class="language-javascript hljs">export async function getCharacter(value) {
 const data = await fetch(
   `https://rickandmortyapi.com/api/character/?name=${value}`
 )
 const response = await data.json()
 if (response === undefined || response.error) {
   throw new Error(`HTTP error! status: ${response.error}`);
 }
 return response
}
</pre>
<p>这里，我们创建了一个函数，它对服务器进行API调用，并将数据解析到JSON。我们还添加了一个基本的错误处理，以防我们从服务器收到一个<code>error</code>或<code>undefined</code>。</p>
<h2 id="writing-custom-debounce-react-hook">编写我们的自定义谴责反应钩</h2>
<p>现在，我们可以继续创建一个<code>Hooks</code>文件夹，在其中添加我们为应用程序创建的挂钩。你可以在这里重温使用React钩子的最佳实践。</p>
<p>在<code>useDebounce.jsx</code>内部，我们将编写我们的<code>useDebounce</code>函数:</p>
<pre class="language-javascript hljs">import { useState, useEffect } from 'react'

export const useDebounce = (value, milliSeconds) =&gt; {
 const [debouncedValue, setDebouncedValue] = useState(value);

 useEffect(() =&gt; {
   const handler = setTimeout(() =&gt; {
     setDebouncedValue(value);
   }, milliSeconds);

   return () =&gt; {
     clearTimeout(handler);
   };
 }, [value, milliSeconds]);

 return debouncedValue;
};
</pre>
<p>在这个函数中你看不到什么变化，但是不要担心，我们会在运行过程中修正这个问题。如果你熟悉<code>setTimeOut</code>和<code>clearTimeOut</code>函数，这并不新鲜。</p>
<p>该函数将值和毫秒作为第二个参数，以特定的时间间隔扩展其执行。我们还通过一个<code>cleanup return</code>调用清空了时间，并添加了<code>value</code>和<code>milliSeconds</code>作为一个<code>dependency</code>数组。以下是关于这些函数的更多信息:</p>
<ul>
<li>这个钩子帮助我们存储需要的值</li>
<li><code>useEffect()</code>:用清除功能更新去抖值</li>
<li><code>setTimeOut()</code>:创建超时延迟</li>
<li><code>clearTimeOut</code>:清理、拆卸与用户输入相关的组件</li>
</ul>
<p>我们可以在应用程序中实现反跳React挂钩:</p>
<pre class="language-javascript hljs">import { useState, useEffect } from 'react'
import { ChakraProvider, Heading, Text, Box } from '@chakra-ui/react'
import Inputfield from './components/input-field'
import { useDebounce } from './hooks/useDebounce'
import { getCharacter } from './utils/getCharacter'
import './App.css'

function App() {
 const [query, setQuery] = useState('')
 const [listing, setListing] = useState('')
 const [loading, setLoading] = useState(false)

 const searchQuery = useDebounce(query, 2000)

 useEffect(() =&gt; {
   setListing('')
   if (searchQuery || query.length &lt; 0) searchCharacter();
   async function searchCharacter() {
     setListing('')
     setLoading(true)
     const data = await getCharacter(searchQuery)
     setListing(data.results)
     setLoading(false)
   }
 }, [searchQuery])

 return (
   &lt;div className="App"&gt;
     &lt;ChakraProvider&gt;
       &lt;Heading mb={4}&gt;Search Rick and Morty Character&lt;/Heading&gt;
       &lt;Text fontSize='md' textAlign="left" mb={10}&gt;
         With a debouce hook implemented
       &lt;/Text&gt;
       &lt;Inputfield mb={10} onChange={(event) =&gt; setQuery(event.target.value)} value={query} /&gt;
       {loading &amp;&amp; &lt;Text mb={10} mt={10} textAlign="left"&gt;Loading...&lt;/Text&gt;}
       {listing &amp;&amp; &lt;Box mt={10} display={'block'}&gt;{listing.map(character =&gt; (
         &lt;Box key={character.id} mb={10}&gt;
           &lt;img src={character.image} alt={character.name} /&gt;
           {character.name}
         &lt;/Box&gt;
       ))}&lt;/Box&gt;}
     &lt;/ChakraProvider&gt;
   &lt;/div&gt;
 )
}

export default App
</pre>
<p>到目前为止，我们已经完成了基本的实现，并使用了<code>useState</code>来存储我们的<code>searchQuery</code>字的状态。</p>
<p>找到结果后，我们将使用数据设置我们的<code>listing</code>状态。因为这是一个异步动作，所以我们添加了<code>loading</code>来继续跟踪<code>data loading</code>状态。</p>
<p>尽管这是一个简单的反跳钩子的实现，我们将改进和重构我们的代码。让我们开始改进我们的代码。</p>
<h2 id="improving-debounce-hook-react">提高我们的反应谴责挂钩</h2>
<p>为了改进React中的去抖钩子，我们将使用<code><a href="https://developer.mozilla.org/en-US/docs/Web/API/AbortController">AbortController</a></code>，这是一个所有现代浏览器都内置的WebAPI。这个API帮助我们停止任何正在进行的Web请求。</p>
<p>要开始使用该控制器，请用以下代码实例化它:</p>
<p><code>const controller = new AbortController();</code></p>
<p>使用控制器，我们可以访问两个属性:</p>
<ul>
<li><code>abort()</code>:执行时，取消正在进行的请求</li>
<li><code>Signal</code>:保持<code>controller</code>和请求取消之间的连接</li>
</ul>
<p>我们现在可以对我们的<code>debounce</code>钩子做进一步的调整。当我们没有收到一个<code>milliSeconds</code>值时，我们将提供一个可选值:</p>
<pre class="language-javascript hljs">const timer = setTimeout(() =&gt; setDebouncedValue(value), milliSeconds || 1000)
</pre>
<p>在<code>getCharacter</code>函数中，我们将传入<code>controller</code>的<code>signal</code>属性。现在，我们将对我们的主文件进行一些重要的修改。</p>
<p>让我们来看一下引入的变化:</p>
<pre class="language-javascript hljs">import { useState, useEffect, useRef } from 'react'
import { ChakraProvider, Heading, Text, Box, Button, SimpleGrid } from '@chakra-ui/react'
import Inputfield from './components/input-field'
import { useDebounce } from './hooks/useDebounce'
import { getCharacter } from './utils/getCharacter'
import './App.css'

function App() {
 const [query, setQuery] = useState('')
 const [listing, setListing] = useState('')
 const [loading, setLoading] = useState(false)
 const controllerRef = useRef()

 const searchQuery = useDebounce(query, 2000)
 const controller = new AbortController();
 controllerRef.current = controller;
  const searchCharacter = async () =&gt; {
   setListing('')
   setLoading(true)
   const data = await getCharacter(searchQuery, controllerRef.current?.signal)
   controllerRef.current = null;
   setListing(data.results)
   setLoading(false)
 }

 useEffect(() =&gt; {
   if (searchQuery || query.trim().length &lt; 0) searchCharacter()
   return cancelSearch()
 }, [searchQuery])

 const cancelSearch = () =&gt; {
   controllerRef.current.abort();
 }

 return (
   &lt;div className="App"&gt;
     &lt;ChakraProvider&gt;
       &lt;Heading mb={4}&gt;Search Rick and Morty  Character&lt;/Heading&gt;
       &lt;Text fontSize='md' textAlign="left" mb={10}&gt;
         With a debounce hook implemented
       &lt;/Text&gt;

       &lt;SimpleGrid columns={1} spacing={10}&gt;
         &lt;Box&gt;
           &lt;Inputfield mb={10} onChange={(event) =&gt; setQuery(event.target.value)} value={query} /&gt;
         &lt;/Box&gt;
       &lt;/SimpleGrid&gt;

       {loading &amp;&amp; &lt;Text mb={10} mt={10} textAlign="left"&gt;Loading...&lt;/Text&gt;}
       {listing &amp;&amp; &lt;Box mt={10} display={'block'}&gt;{listing.map(character =&gt; (
         &lt;Box key={character.id} mb={10}&gt;
           &lt;img src={character.image} alt={character.name} /&gt;
           {character.name}
         &lt;/Box&gt;
       ))}&lt;/Box&gt;}
       {!listing &amp;&amp; !loading &amp;&amp; &lt;Box mt={10} display={'block'} color={'#c8c8c8'}&gt;You have started your search&lt;/Box&gt;}
     &lt;/ChakraProvider&gt;
   &lt;/div&gt;
 )
}

export default App
</pre>
<p>这里，我们在应用程序中引入了一个额外的挂钩。我们使用<code>controller</code>构造函数来创建一个新的<code>AbortSignal</code>实例，并将<code>controller</code>分配给<code>useRef</code>。<code>useRef</code>帮助我们从DOM中获取元素来监视状态变化。</p>
<p>在我们的API调用过程中，我们用<code>controllerRef.current.signal</code>传递了当前的<code>signal option</code>。我们添加了一个<code>cancel</code>控制器，用于在<code>searchQuery</code>值改变时调用<a href="https://blog.logrocket.com/understanding-react-useeffect-cleanup-function/">清理函数</a>:</p>
<ul>
<li><code>Aborted</code>:表示信号已经中止的<code>Boolean</code>值，初始为<code>false</code>，触发时，初始为<code>null</code></li>
<li><code>abortController.abort()</code>:这有助于我们停止<code>fetch</code>请求</li>
</ul>
<p>我们还可以多次调用服务器，并根据需要中止请求。这在处理网络流量和优化技术时很方便。</p>
<h2>结论</h2>
<p>在本文中，我们成功地创建了一个反跳React挂钩，以限制React应用程序中对服务器的不必要调用和处理。使用这种技术有助于改进React应用程序。</p>
<p>我们可以将这种去抖优化技术用于昂贵的动作，如调整事件大小、拖动事件、击键监听器和滚动事件。这可以帮助我们运行具有已知性能优势的应用程序。要找到完整的工作代码，请查看GitHub库。</p>
<p>编码快乐！</p><div class="code-block code-block-17">
<div class="blog-plug inline-plug react-plug" vwo-el-id="26283398190">
<h2 vwo-el-id="41600691720"><a href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener"> LogRocket </a>:全面了解您的生产React应用</h2><p>调试React应用程序可能很困难，尤其是当用户遇到难以重现的问题时。如果您对监视和跟踪Redux状态、自动显示JavaScript错误以及跟踪缓慢的网络请求和组件加载时间感兴趣，</p><a href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" vwo-el-id="19356441070">try LogRocket</a><p>. </p><a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="19356441380">
<img class="first-react-image alignnone size-full wp-image-46 jetpack-lazy-image jetpack-lazy-image--handled" src="../Images/f300c244a1a1cf916df8b4cb02bec6c6.png" vwo-el-id="18272717540" data-lazy-loaded="1" data-original-src="https://files.readme.io/27c94e7-Image_2017-06-05_at_9.46.04_PM.png"/>
</a>
<a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="19356441690">
<img class="second-react-image alignnone size-full wp-image-46 jetpack-lazy-image jetpack-lazy-image--handled" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" vwo-el-id="30720362350" data-lazy-loaded="1" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/>
</a>
<p vwo-el-id="28675660440" class="">LogRocket 结合了会话回放、产品分析和错误跟踪，使软件团队能够创建理想的web和移动产品体验。这对你来说意味着什么？</p>
<p>LogRocket不是猜测错误发生的原因，也不是要求用户提供截图和日志转储，而是让您回放问题，就像它们发生在您自己的浏览器中一样，以快速了解哪里出错了。</p>
<p>不再有嘈杂的警报。智能错误跟踪允许您对问题进行分类，然后从中学习。获得有影响的用户问题的通知，而不是误报。警报越少，有用的信号越多。</p>
<p vwo-el-id="28675660750">LogRocket Redux中间件包为您的用户会话增加了一层额外的可见性。LogRocket记录Redux存储中的所有操作和状态。</p>
<p vwo-el-id="28675661060">现代化您调试React应用的方式— <a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="40093418840">开始免费监控</a>。</p>
</div></div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
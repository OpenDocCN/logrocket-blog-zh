# 如何防范正则表达式拒绝服务(ReDoS)攻击

> 原文：<https://blog.logrocket.com/protect-against-regex-denial-of-service-redos-attacks/>

在本教程中，我们将向您展示如何保护正则表达式免受拒绝服务(DoS)攻击。我们将回顾正则表达式一般是如何工作的，重点是容易受到拒绝服务攻击的正则表达式，以及保护我们的应用程序免受损害的各种方法。

我们将详细介绍以下内容:

要学习本教程，您应该对正则表达式有基本的了解。

稍后我们将使用 Node.js 运行时来运行一些示例，因此安装 Node.js 是非常必要的。如果你没有在本地安装 Node.js，你可以去[官方 Node.js 网站](https://nodejs.org/en/download/)为你的操作系统下载 LTS 版本。

## 什么是正则表达式拒绝服务(ReDoS)？

ReDoS 攻击是众多拒绝服务攻击的一种。DoS 攻击的主要目标是使最终用户无法访问应用程序/服务器资源。

下面是 DoS 攻击的工作原理:威胁者试图利用漏洞来削弱系统。例如，攻击者可能会发送大量请求，使服务器不堪重负，迫使它在不成比例的时间内响应所有请求。这也迫使服务器使用大量资源，并可能导致系统崩溃。

ReDoS 攻击遵循相同的蓝图:攻击者利用正则表达式引擎在匹配正则表达式时面临的特定漏洞，从而花费大量时间来执行该正则表达式。这实际上会使系统崩溃或停止系统对用户请求的响应。

2019 年发表的一份 [Snyk 报告](https://snyk.io/blog/redos-vulnerabilities-in-npm-spikes-by-143-and-xss-continues-to-grow/)显示，ReDoS 攻击呈上升趋势。2018 年，ReDoS 漏洞增加了 143%，其中 Node.js 应用受到的影响最大。因为 Node 的事件循环是单线程的，这种攻击旨在阻塞事件循环，这可能会产生毁灭性的影响。

## 正则表达式是如何工作的？

在我们继续之前，让我们快速回顾一下正则表达式匹配是如何工作的；这将帮助我们更好地理解一些正则表达式如何以及为什么容易受到拒绝服务攻击。

正则表达式模式匹配可以通过构建有限状态机来完成。您可以将此视为一台抽象机器，它接受一组输入和一组可以在该输入上执行以产生指定输出的操作。

有限状态机在任何给定时间都可以处于有限数量的状态中的一种。当有限状态机从一种状态变为另一种状态时，就会发生转换。有限状态机的一个例子是咖啡自动售货机，它根据用户的选择倒出特定种类的咖啡。

如前所述，正则表达式匹配可以通过构建有限状态机来完成。正则表达式也可以很容易地从有限状态转换为不确定状态，特别是对于每个接收到的输入都有几个可能的下一个状态的表达式。

在这种情况下，在转换之后，正则表达式引擎可以使用几种算法来确定下一个状态，但是让我们把重点放在最有问题的算法上:

*   引擎会尝试所有可能的路径，直到找到匹配项，或者所有路由都尝试过但失败(这称为回溯)。这是有问题的，因为对于长度为 *n* 的输入，有指数数量的路径 *n* ，所以最坏的情况是，在指数时间内得到结果
*   该引擎尝试再次将其从非确定性自动化转换为确定性自动化。这是有问题的，因为根据执行路径的不同，转换可能需要指数时间才能完成

因此，当这两种算法中的任何一种应用于特定的正则表达式时，就会发生正则表达式拒绝服务。恶意用户可以利用这一点，并触发这两种情况中的一种，从而导致正则表达式引擎最糟糕的运行时复杂性。

## 什么类型的正则表达式容易受到 DOS 攻击？

让我们看一个容易受到 DoS 攻击的正则表达式的例子。首先，我们需要安装一个名为 [gnomon](https://github.com/paypal/gnomon) 的工具，这是一个命令行实用程序，我们将使用它来检查一个命令执行需要多长时间。

前往您的终端，运行以下命令:

```
npm install -g gnomon

```

我们将关注第一个问题，因为这是更严重的问题发生的地方。

假设我们有一个模式，`/^(\w+\s?)*$/`、**、**，它包含一组单词，每个单词后有一个可选的空格。量词`^`和`$`匹配行首和行尾的单词。

让我们试一组没有特殊字符的单词:

```
node -p "/^(\w+\s?)*$/.test('Only valid characters')" | gnomon

```

我们看到它匹配，在我的终端上执行这个正则表达式花了 0.0058 秒。

让我们试着在最后一个单词的末尾用一个特殊的字符组成一个句子:

```
node -p "/^(\w+\s?)*$/.test('Invalid characters!')" | gnomon

```

正如所料，它返回了`false`，执行这个正则表达式花费了大约 0.0061 秒。

完美，一切正常。但问题是，对于包含特殊字符的更长的句子，regex 引擎可能需要很长时间来执行正则表达式。

让我们看看实际情况。在您的终端中运行以下命令:

```
node -p "/^(\w+\s?)*$/.test('A long sentence with invalid characters that takes soo much time to be matched that it potentially causes our CPU usage to increase drastically!!!')" | gnomon

```

你不应该期待这个命令会有什么结果😅。如果我们打开任务管理器，我们可以看到特定的进程使用了极高的 CPU 百分比来执行正则表达式。从本质上讲，我们应该注意到当前整体 CPU 使用率的急剧增加。

如您所见，攻击者可以利用看似简单的正则表达式模式使我们的系统使用比预期更多的资源，更长的输入会导致我们的系统挂起或崩溃。

让我们更深入地了解一下为什么会这样:

*   这个问题的主要原因是正则表达式引擎中一个叫做回溯的特性。引擎首先检查输入，并尝试匹配括号中包含的内容`\w+\s?`
*   由于量词`+`很贪婪，它试图找到尽可能多的有效词，所以返回`A` `long sentence with invalid characters that takes so``o` `much time to be matched that it potentially causes our CPU usage to increase`
*   然后可以应用星形量词`(\w+\s?)*`,但是输入中不再有有效的单词，所以它不会返回任何东西
*   由于我们模式中的`$`量词，正则表达式引擎试图匹配输入的结尾。尽管如此，我们仍然有一个无效的单词，`drastically!!!`，所以没有匹配
*   引擎后退一步回到先前的位置，并尝试采取不同的路径，希望找到匹配。因此，量词`+`减少重复次数，回溯一个单词，并尝试匹配输入中的其余单词——在本例中是`A long sentence with invalid characters that takes soo much time to be matched that it potentially causes our CPU usage to`
*   然后，引擎从以下位置继续搜索:可以再次应用量词`*`并匹配单词`increase`。记住，我们有`$`量词；发动机使用它，但它无法再次匹配`drastically!!!`

正则表达式引擎将再次回溯，减少重复的次数，并一直这样做，直到探索完所有可能的路径。我们期望正则表达式匹配花费大约 *O(n)* 时间，其中 *n* 表示输入字符串长度。

在大多数情况下，这可能是真的。尽管如此，在某些情况下——比如我们刚刚看到的情况 regex 引擎可能需要在输入字符串中采用指数数量的路径来查找匹配。

* * *

### 更多来自 LogRocket 的精彩文章:

* * *

因此，在输入大小约为 125 的情况下，我们会遇到这样的情况:引擎采用指数数量的路径，大约 2^125 不同的路径，这给出了大约 4.2535296e+37 种不同的组合，因为在特定位置有一个无效单词。这通常会导致所谓的灾难性回溯。这样的正则表达式需要花费大量的时间和资源来执行。

最后，我们将研究各种方法来保护我们的模式不受这些问题的影响。

## 如何保护正则表达式免受 DoS 攻击

有几种方法可以确保正则表达式模式不易受到拒绝服务攻击。

### 减少组合的数量

一种方法是减少正则表达式引擎执行的组合数量。有几种方法可以做到这一点:

*   避免使用嵌套量词，例如`(a+)*`
*   避免含有重叠子句的 ORs，例如`(b|b)*`

根据引擎的不同，一些使用嵌套量词和重叠子句编写的正则表达式可以快速执行，但不能保证。还是小心点比较安全。

### 控制回溯

另一种方法是控制回溯。尽管回溯使我们能够构造复杂而强大的正则表达式，但最终的好处可能是无关紧要的，尤其是与我们之前研究的那些糟糕的性能相比。

幸运的是，我们可以使用某些特性来限制或抑制回溯，同时仍然创建强大的正则表达式。让我们来看两个:原子组和前瞻。

#### 原子团

原子组使用`?>`语法来抑制对表达式的回溯。一旦找到匹配，它不允许任何其他部分受到回溯，即使这意味着有成功匹配的可能性。

这种抑制回溯的方法有助于提高使用嵌套量词时的性能。不幸的是，并不是所有的 regex 引擎都实现了这个特性，特别是 JavaScript/Node.js 中没有这个特性。

让我们看看另一个特性，它使我们能够做类似的事情，并且在 JavaScript/Node.js 中可用。

#### 向前看

使用我们之前看到的例子，我们不希望我们的量词回溯，因为在大多数情况下，回溯会导致严重的问题，正如我们之前看到的。我们可以利用一个叫做前瞻的特性来加强这一点。

当使用前瞻断言时，我们使用语法`?=` —例如，对于模式`A(?=B)`，它简单地说，“查找 A，但是如果它后面跟有 b，则匹配它。”这很重要，因为我们可以确定表达式是否可以匹配接下来的字符，而无需回溯或前进。

在这种情况下，我们希望在不回溯的情况下匹配尽可能多的单词。我们可以重写匹配从`\w+`到`(?=(\w+))\1`的单词的模式。乍一看可能有点不直观，但我们来分解一下。

在我们重写的模式中，`(?=(\w+))\1`，我们告诉引擎在当前位置寻找最长的单词。内括号中的模式`(\w+)`告诉引擎记住内容，我们稍后可以使用`\1`来引用它。

这解决了我们的问题，因为我们可以使用 lookahead 特性将单词`w+`作为一个整体进行匹配，并使用模式`\1`引用它。本质上，我们可以实现一个所有格的`+`量词，它必须匹配整个单词，而不是某些部分。

在我们的第一个例子中，指定的模式捕获单词，但是当它遇到一个无效单词时，`+`量词强迫它回溯，直到它成功或失败。在我们重写的例子中，我们使用 lookahead 来查找一个有效的单词，这个单词作为一个整体被匹配，并使用`\1`包含在模式中。

让我们将这个新模式与之前的量词一起运行，看看我们是否会遇到同样的问题:

```
node -p "/^((?=(\w+))\1\s?)*$/.test('A long sentence with invalid characters but doesnt cause our CPU usage to increase drastically!!!')" | gnomon

```

瞧啊。，我们可以看到正则表达式被执行，我们瞬间收到一个输出；大约花了 0.0052 秒才得到一个结果。

## 结论

在本教程中，我们学习了如何保护正则表达式免受拒绝服务攻击。我们更深入地了解正则表达式匹配是如何工作的，这使我们能够理解为什么以及如何发生这个问题。然后，我们看了一个带有这种漏洞的正则表达式模式的例子，并演示了阻止 DoS 攻击者可能利用的漏洞的方法。

## 使用 [LogRocket](https://lp.logrocket.com/blg/signup) 消除传统错误报告的干扰

[![LogRocket Dashboard Free Trial Banner](img/d6f5a5dd739296c1dd7aab3d5e77eeb9.png)](https://lp.logrocket.com/blg/signup)

[LogRocket](https://lp.logrocket.com/blg/signup) 是一个数字体验分析解决方案，它可以保护您免受数百个假阳性错误警报的影响，只针对几个真正重要的项目。LogRocket 会告诉您应用程序中实际影响用户的最具影响力的 bug 和 UX 问题。

然后，使用具有深层技术遥测的会话重放来确切地查看用户看到了什么以及是什么导致了问题，就像你在他们身后看一样。

LogRocket 自动聚合客户端错误、JS 异常、前端性能指标和用户交互。然后 LogRocket 使用机器学习来告诉你哪些问题正在影响大多数用户，并提供你需要修复它的上下文。

关注重要的 bug—[今天就试试 LogRocket】。](https://lp.logrocket.com/blg/signup-issue-free)
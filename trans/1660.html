<html>
<head>
<title>What’s new in Relay v11 - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>Relay v11 - LogRocket 博客中的新内容</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/whats-new-in-relay-v11/#0001-01-01">https://blog.logrocket.com/whats-new-in-relay-v11/#0001-01-01</a></blockquote><div><article class="article-post">
<p>GraphQL 是当今许多公司都在使用的技术(例如脸书)。它正在成为构建可靠的、可伸缩的、高性能的 API 的重要替代方法。</p>
<p>脸书<a href="https://engineering.fb.com/2020/05/08/web/facebook-redesign/" target="_blank" rel="noopener">几个月前发布了一个新版本</a>，并在他们的应用程序中大量使用 React、GraphQL 和最新版本的<a href="https://relay.dev/" target="_blank" rel="noopener"> Relay </a>。脸书在生产中使用 Relay 已经有几年了，它正在帮助他们拥有一个更具可伸缩性、稳定性和可维护性的应用程序。</p>
<p>在本帖中，我们将介绍新版本的<a href="https://relay.dev/" target="_blank" rel="noopener">继电器</a>。我们将探索最新版本是如何工作的，以及我们如何创建更可靠和可伸缩的 React 和 GraphQL 应用程序。</p>
<h2>继电器挂钩</h2>
<p><a href="https://relay.dev/" target="_blank" rel="noopener"> Relay </a>是一个强大的 JavaScript 框架，用于在 React 应用程序中使用 GraphQL。Relay 不同于其他 GraphQL 客户端，因为它更加结构化和固执己见。</p>
<p><a href="https://relay.dev/" target="_blank" rel="noopener"> Relay </a>有助于构建更具可伸缩性、结构化和高性能的 React 和 GraphQL 应用。依靠 GraphQL 的最佳实践，如<a href="https://graphql.org/learn/queries/#fragments" target="_blank" rel="noopener">片段</a>、<a href="https://graphql.org/learn/pagination/#complete-connection-model" target="_blank" rel="noopener">连接</a>、<a href="https://graphql.org/learn/global-object-identification/" target="_blank" rel="noopener">全局对象识别</a>等，它使得在 GraphQL 中获取数据变得容易。</p>
<p>Relay 的最新版本于 2021 年 3 月 9 日发布，它有一个对开发者更友好的 API。新版本支持<a href="https://reactjs.org/docs/concurrent-mode-suspense.html" target="_blank" rel="noopener">反应悬念</a>，虽然这是一个实验性的功能。</p>
<p>Relay Hooks 是一组新的 API，用于在 React 应用程序中使用 React Hooks 获取和管理 GraphQL 数据。</p>
<p>从最新版本的 Relay 开始，让我们首先使用<a href="https://create-react-app.dev/" target="_blank" rel="noopener"> create-react-app </a>创建一个新的 React 应用程序，并设置 Relay:</p>
<pre>npx create-react-app graphql-relay-example --template typescript
</pre>
<p>创建 React 应用程序后，我们需要安装几个包来开始使用 Relay:</p>
<pre>yarn add react-relay relay-runtime isomorphic-fetch

yarn add --dev @types/react-relay @types/relay-runtime graphql relay-compiler relay-compiler-language-typescript
</pre>
<p>现在，我们创建一个名为<code>environment.tsx</code>的文件，这是我们将要创建中继环境的地方。使用 Relay 的最佳方式是使用与 Relay 兼容的 GraphQL API，它将遵循最佳实践，并使实现诸如分页之类的事情更加容易。</p>
<p>在我们的<code>environment.tsx</code>文件中，放入以下代码:</p>
<pre>import {
  Environment,
  Network,
  RecordSource,
  Store,
  RequestParameters,
  Variables
} from "relay-runtime";
import fetch from "isomorphic-fetch";

function fetchQuery(operation: RequestParameters, variables: Variables) {
  return fetch('https://podhouse-server.herokuapp.com/graphql', {
    method: "POST",
    headers: {
      Accept: "application/json",
      "Content-type": "application/json",
    },
    body: JSON.stringify({
      query: operation.text,
      variables,
    }),
    }).then((response: any) =&gt; {
      return response.json()
    })
}

const network = Network.create(fetchQuery);

const env = new Environment({
  network,
  store: new Store(new RecordSource(), {
    gcReleaseBufferSize: 10,
  }),
});

export default env;
</pre>
<p>在我们的<code>index.tsx</code>中，我们导入<code>RelayEnvironmentProvider</code>并传递我们的<code>environment</code>给它:</p>
<pre><code>import React from "react";
import ReactDOM from "react-dom";
import { RelayEnvironmentProvider } from "react-relay/hooks";
import environment from "./environment";

ReactDOM.render(
  &lt;RelayEnvironmentProvider environment={environment}&gt;
    &lt;React.StrictMode&gt;
      &lt;App /&gt;
    &lt;/React.StrictMode&gt;
  &lt;/RelayEnvironmentProvider&gt;,
  document.getElementById('root')
);
</code></pre>
<p>现在，我们已经为我们的项目设置了 Relay，我们可以开始使用最新的版本，看看它是如何工作的。</p>
<h2>用<code>useLazyLoadQuery</code>抓取</h2>
<p>用 Relay 获取数据最简单的方法是使用<code>useLazyLoadQuery</code>。这个钩子将在渲染过程中获取数据，使其成为获取数据的最有效方式，但也是最简单的方式:</p>
<pre>import { useLazyLoadQuery } from "react-relay/hooks";
useLazyLoadQuery(query, variables, options);
</pre>
<p>下面是<code>useLazyLoadQuery</code>的工作原理:</p>
<ul>
<li><code>query</code> —您需要它来传递您的 GraphQL 查询模板文本</li>
<li><code>variables</code> —包含用于获取查询的值的对象。例如，当您想要在应用程序内部对用户进行身份验证时</li>
<li><code>options</code> —是一个你定义了一些属性的对象。<code>fetchPolicy</code>用于决定数据是否需要缓存。<code>fetchKey</code>用于强制重新评估查询</li>
<li><code>networkCacheConfig</code>是一个你可以定义到你的缓存配置选项的对象</li>
</ul>
<p><code>useLazyLoadQuery</code>应该总是在<code>RelayEnvironmentProvider</code>中使用。当网络请求正在进行时，<code>useLazyLoadQuery</code>可能会暂停您的数据，这取决于您选择的<code>fetchPolicy</code>。根据所选的<code>fetchPolicy</code>,您应该在应用中使用<a href="https://reactjs.org/docs/concurrent-mode-suspense.html" target="_blank" rel="noopener">反应暂停</a>作为<a href="https://relay.dev/docs/guided-tour/rendering/loading-states/" target="_blank" rel="noopener">加载状态</a>。</p>
<p>查看<code>useLazyLoadQuery</code>挂钩的示例:</p>
<pre>import React from "react";
import graphql from "babel-plugin-relay/macro";
import { useLazyLoadQuery } from "react-relay/hooks";

const query = graphql`
  query SettingsQuery {
    currentUser {
      id
      _id
      email
    }
  }
`;

const Component = () =&gt; {
  const data = useLazyLoadQuery(
    query,
    {},
    {
      fetchPolicy: "store-and-network",
    }
  );

  return (
    &lt;div&gt;
      &lt;h1&gt;{data.currentUser.email}&lt;/h1&gt;
    &lt;/div&gt;
  );
};

export default Component;
</pre>
<h2>用<code>usePreloadedQuery</code>抓取</h2>
<p><code>usePreloadedQuery</code>是最推荐的用 Relay 获取数据的钩子。它实现了<a href="https://reactjs.org/docs/concurrent-mode-suspense.html#approach-3-render-as-you-fetch-using-suspense" target="_blank" rel="noopener">即取即渲染</a>模式，这种模式允许我们加载我们需要的数据并并行渲染我们的组件。</p>
<p><code>usePreloadedQuery</code>可能有点混乱，所以让我们弄清楚这个钩子是如何工作的:</p>
<ul>
<li><code>usePreloadedQuery</code>使用<code>useQueryLoader</code>，这是新版本继电器上的另一个挂钩</li>
<li><code>useQueryLoader</code>是一个用于安全加载查询的钩子。它将保存一个查询引用，并在组件被释放时释放它</li>
<li><code>useQueryLoader</code>设计为与<code>usePreloadedQuery</code>一起使用</li>
<li><code>useQueryLoader</code>返回一个<code>queryReference</code>、一个<code>loadQuery</code>回调和一个<code>disposeQuery</code>回调</li>
<li>我们需要首先使用来自<code>useQueryLoader</code>的<code>loadQuery</code>回调，它将在 React 状态下存储一个查询引用</li>
<li>之后，我们将<code>queryReference</code>传递给我们的<code>usePreloadedQuery</code>，这将允许我们更早地获取数据，同时不会阻塞组件上的呈现</li>
</ul>
<p><code>usePreloadedQuery</code>是使用中继获取数据的最强大和推荐的方式。</p>
<p>查看<code>usePreloadedQuery</code>钩的使用示例:</p>
<pre>import React, { useEffect } from "react";
import graphql from "babel-plugin-relay/macro";
import { useQueryLoader, usePreloadedQuery } from "react-relay/hooks";

const query = graphql`
  query UserQuery($_id: ID!) {
    user(_id: $_id) {
      id
      _id
      name
    }
  }
`;

const Component = () =&gt; {
  const [queryReference, loadQuery, disposeQuery] = useQueryLoader(query);

  useEffect(() =&gt; {
    loadQuery({ _id: _id }, { fetchPolicy: "store-or-network" });
    return () =&gt; {
      disposeQuery();
    };
  }, [loadQuery, disposeQuery, _id]);

  return (
    &lt;React.Suspense fallback="Loading user..."&gt;
    {queryReference != null ? &lt;UserComponent queryReference={queryReference} /&gt; : null
    }
    &lt;/React.Suspense&gt;
  );
};

const UserComponent = ({ queryReference }) =&gt; {
  const data = usePreloadedQuery(query, queryReference);
  return &lt;h1&gt;{data.user?.name}&lt;/h1&gt;;
}

export default Component;
</pre>
<h2><code>usePaginationFragment</code></h2>
<p>使用 Relay，让你的 GraphQL API <a href="https://blog.logrocket.com/making-a-graphql-server-compatible-with-relay/" target="_blank" rel="noopener">与 Relay </a>兼容，并遵循<a href="https://spec.graphql.org/June2018/" target="_blank" rel="noopener"> GraphQL 规范</a>的一个好处是，它使得实现一些特性比如分页变得非常容易。</p>
<p><code>usePaginationFragment</code>是一个钩子，可用于呈现一个片段并在其上分页:</p>
<pre>import { usePaginationFragment } from "react-relay/hooks";
usePaginationFragment(query, variables, options);
</pre>
<p>下面是<code>usePaginationFragment</code>的工作原理:</p>
<ul>
<li><code>fragment</code>–graph QL 片段模板文字。GraphQL 片段必须有一个<code>@connection</code>和<code>@refetchable</code>指令，否则，它将抛出一个错误</li>
<li><code>fragmentReference</code>–一个片段引用，Relay 使用它从存储中读取片段的数据</li>
</ul>
<p>我们可以将<code>usePaginationFragment</code>和<code>usePreloadedQuery</code>一起使用。查看一个使用<code>usePreloadedQuery</code>钩子的例子。首先，我们创建查询和片段:</p>
<pre>const query = graphql`
  query ProductsQuery($name: String!) {
    ...SearchProducts_products @arguments(name: $name)
  }
`;

const fragment = graphql`
fragment SearchProducts_products on Query
@argumentDefinitions(
name: { type: "String" }
after: { type: "String" }
first: { type: "Int", defaultValue: 30 }
before: { type: "String" }
last: { type: "Int" }
)
@refetchable(queryName: "SearchProductsPaginationQuery") {
products(
name: $name
after: $after
first: $first
before: $before
last: $last
) @connection(key: "SearchProducts_products", filters: ["name"]) {
edges {
node {
_id
name
image
}
}
}
}
`; 
</pre>
<p>现在，在我们的组件中，我们将查询传递给<code>useQueryLoader</code>钩子，在子组件中我们使用<code>usePreloadedQuery</code>:</p>
<pre>import React, { useEffect } from "react";
import graphql from "babel-plugin-relay/macro";
import { useQueryLoader, usePreloadedQuery } from "react-relay/hooks";

const Component = () =&gt; {
  const [queryReference, loadQuery, disposeQuery] = useQueryLoader(query);

  useEffect(() =&gt; {
    loadQuery({ name: name }, { fetchPolicy: "store-or-network" });
    return () =&gt; {
      disposeQuery();
    };
  }, [loadQuery, disposeQuery, name]);

  return (
  &lt;React.Suspense fallback="Loading products..."&gt;
    {queryReference != null ? (&lt;ProductComponent queryReference={queryReference} /&gt;) : null}
  &lt;/React.Suspense&gt;
  );
};

const ProductComponent = ({ queryReference }) =&gt; {
  const query = usePreloadedQuery(query, queryReference);
  const { data } = usePaginationFragment(fragment, query);

  return (
    &lt;div&gt;
      {data.friends?.edges.map(({ node }) =&gt; (
      &lt;div&gt;{node.name}&lt;/div&gt;
      ))}
    &lt;/div&gt;
  );
};

export default Component;
</pre>
<h2><code>useMutation</code></h2>
<p>突变是 GraphQL 非常重要的一部分。它允许我们创建、更新和删除数据。</p>
<p><code>useMutation</code>是用中继执行变异的新钩子。这是一个非常简单明了的挂钩，只有两个参数:</p>
<ul>
<li><code>mutation</code>—graph QL 变异模板文字</li>
<li><code>commitMutationFn</code> —将被调用的函数。这个函数是可选的，大多数时候你不需要它</li>
</ul>
<p><code>useMutation</code>只返回两个值:</p>
<ul>
<li><code>commitMutation</code> —将执行变异的函数</li>
<li><code>isInFlight</code> —检查突变是否仍在进行中的值。你可以想用多少次就用多少次<code>commitMutation</code>，所以通常你可以在飞行中一次使用多个变异</li>
</ul>
<p>查看<code>usePreloadedQuery</code>挂钩的示例:</p>
<pre>import React from "react";
import graphql from "babel-plugin-relay/macro";
import { useMutation } from "react-relay/hooks";

const mutation = graphql`
  mutation SignInWithEmail($input: SignInWithEmailInput!) {
    SignInWithEmail(input: $input) {
      token
      success
      error
    }
  }
`;

const Component = () =&gt; {
  const [commitMutation, isInFlight] = useMutation(mutation);

  const onSubmit = () =&gt; {
    commitMutation({
      variables: {
        input: {
          email: email,
          password: password,
        },
      },
      onCompleted: ({ SignInWithEmail }) =&gt; {
        if (SignInWithEmail?.error) {
          return SignInWithEmail?.error;
        }
        updateToken(SignInWithEmail?.token);
      },
    });
  };

  return (
    &lt;form onSubmit={onSubmit}&gt;
      &lt;input type="text" value={email} /&gt;
      &lt;input type="password" value={password} /&gt;
      &lt;button type="submit"&gt;Submit&lt;/button&gt;
    &lt;/form&gt;
  );
};

export default Component;
</pre>
<h2>结论</h2>
<p>Relay 的最新版本带来了一组新的 API，它们将帮助我们构建更多可伸缩的 React 和 GraphQL 应用程序。React 钩子的使用可以帮助我们构建更加模块化和高性能的应用程序，使我们的代码更容易理解，并且没有意想不到的副作用。</p><div class="code-block code-block-17">
<div class="blog-plug inline-plug react-plug" vwo-el-id="26283398190">
<h2 vwo-el-id="41600691720"><a href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener"> LogRocket </a>:全面了解您的生产 React 应用</h2><p>调试 React 应用程序可能很困难，尤其是当用户遇到难以重现的问题时。如果您对监视和跟踪 Redux 状态、自动显示 JavaScript 错误以及跟踪缓慢的网络请求和组件加载时间感兴趣，</p><a href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" vwo-el-id="19356441070">try LogRocket</a><p>. </p><a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="19356441380">
<img class="first-react-image alignnone size-full wp-image-46 jetpack-lazy-image jetpack-lazy-image--handled" src="../Images/f300c244a1a1cf916df8b4cb02bec6c6.png" vwo-el-id="18272717540" data-lazy-loaded="1" data-original-src="https://files.readme.io/27c94e7-Image_2017-06-05_at_9.46.04_PM.png"/>
</a>
<a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="19356441690">
<img class="second-react-image alignnone size-full wp-image-46 jetpack-lazy-image jetpack-lazy-image--handled" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" vwo-el-id="30720362350" data-lazy-loaded="1" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/>
</a>
<p vwo-el-id="28675660440" class="">LogRocket 结合了会话回放、产品分析和错误跟踪，使软件团队能够创建理想的 web 和移动产品体验。这对你来说意味着什么？</p>
<p>LogRocket 不是猜测错误发生的原因，也不是要求用户提供截图和日志转储，而是让您回放问题，就像它们发生在您自己的浏览器中一样，以快速了解哪里出错了。</p>
<p>不再有嘈杂的警报。智能错误跟踪允许您对问题进行分类，然后从中学习。获得有影响的用户问题的通知，而不是误报。警报越少，有用的信号越多。</p>
<p vwo-el-id="28675660750">LogRocket Redux 中间件包为您的用户会话增加了一层额外的可见性。LogRocket 记录 Redux 存储中的所有操作和状态。</p>
<p vwo-el-id="28675661060">现代化您调试 React 应用的方式— <a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="40093418840">开始免费监控</a>。</p>
</div></div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
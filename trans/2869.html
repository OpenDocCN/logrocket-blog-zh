<html>
<head>
<title>Comparing random number generators in Rust - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>Rust - LogRocket 博客中的随机数生成器比较</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/comparing-random-number-generators-rust/#0001-01-01">https://blog.logrocket.com/comparing-random-number-generators-rust/#0001-01-01</a></blockquote><div><article class="article-post">
<p><a href="https://en.wikipedia.org/wiki/Randomness" target="_blank" rel="noopener">随机性</a>是网络发展和我们今天生活中不可或缺的一部分。如果没有随机性，<a href="https://blog.logrocket.com/sending-bitcoin-with-javascript/" target="_blank" rel="noopener">比特币</a>和<a href="https://blog.logrocket.com/how-to-create-cryptocurrency-javascript/" target="_blank" rel="noopener">加密货币</a>，银行系统<a href="https://en.wikipedia.org/wiki/Game_of_chance" target="_blank" rel="noopener">，像骰子或轮盘这样的机会游戏</a>，当然，所有的加密操作，都将是可预测的和不安全的。</p>
<p>在 Rust 中，有几个随机数生成器实现板条箱。下面，我们将看看流行的随机数生成器，比较和对比它们，并探讨它们的优缺点及其用例。</p>
<p><em>注意:与 JavaScript 不同，Rust 中目前没有</em> <code>Math.random</code> <em>的等效方法。</em></p>
<h2>使用 Rand，一个流行的随机数生成器</h2>
<p>Rand 是 Rust 生态系统中最受欢迎的随机数生成器，由 rust-random 和 229 名贡献者维护。它的 GitHub 评分超过了<a href="https://github.com/rust-random/rand/stargazers" target="_blank" rel="noopener">1090</a>颗星。Rand 提供了许多功能，您可以在 Rust 中针对不同的随机情况使用这些功能，它目前使用 12 轮的<a href="https://www.cryptopp.com/wiki/ChaCha20" target="_blank" rel="noopener"> ChaCha </a>分组密码算法，该算法速度快、统计性强且不可预测，因此它可以充分生成密码安全的伪随机数(CSPRNG)。</p>
<p>Rand 的文件很小，只有 87.1KB，下载量很大。截至本文撰写之时，它已被下载了 116，114，195 次。</p>
<h3>Rand 的主要特性</h3>
<h4>1.确定性随机数生成器</h4>
<p>确定性随机数是从一个种子(一组定义的数字)中生成的。任何有那个种子的人都可以重新生成同样的数字。以下面这段代码为例:</p>
<pre class="language-rust hljs">use rand_chacha;

fn generate_random_numbers_with_a_seed(seed : u64) {
    let mut rng = rand_chacha::ChaCha8Rng::seed_from_u64(seed);
    println!("Deterministic Random numbers with seed:{}", rng.gen::&lt;i32&gt;());
}

fn main(){
generate_random_numbers_with_a_seed(200); 
//Result : -416273517
}
</pre>
<p>只要你在使用种子<code>200</code>，结果总是<code>-416273517</code>。为了让这个例子工作，您需要将<code>rand_chacha</code>作为一个依赖项添加到您的<code>Cargo.toml</code>文件中，如下所示:</p>
<pre class="language-rust hljs">[dependencies]
rand_chacha = "0.3.1"
</pre>
<p>在之前的 Rand 版本中，你只需要安装 Rand 就可以使用<code>rand_chacha</code>，因为它是一个依赖项。但是，截至 2019 年 8 月<a href="https://github.com/rust-random/rand/issues/872" target="_blank" rel="noopener"/>，<code><a href="https://github.com/rust-random/rand/issues/872" target="_blank" rel="noopener">rand_chacha</a></code>是<a href="https://github.com/rust-random/rand/issues/872">单独的</a>，因为团队希望减少依赖性。</p>
<p><img data-attachment-id="103733" data-permalink="https://blog.logrocket.com/comparing-random-number-generators-rust/rand-github-issue-conversation/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/04/rand-github-issue-conversation.png" data-orig-size="730,257" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Rand GitHub issue conversation" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/04/rand-github-issue-conversation-300x106.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/04/rand-github-issue-conversation.png" decoding="async" class="aligncenter size-full wp-image-103733 jetpack-lazy-image" src="../Images/2bce4a4eeb7ff0ab205a4d6613acd7c6.png" alt="Rand GitHub Issue Conversation" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2022/04/rand-github-issue-conversation.png 730w, https://blog.logrocket.com/wp-content/uploads/2022/04/rand-github-issue-conversation-300x106.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2022/04/rand-github-issue-conversation.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/04/rand-github-issue-conversation.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="103733" data-permalink="https://blog.logrocket.com/comparing-random-number-generators-rust/rand-github-issue-conversation/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/04/rand-github-issue-conversation.png" data-orig-size="730,257" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Rand GitHub issue conversation" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/04/rand-github-issue-conversation-300x106.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/04/rand-github-issue-conversation.png" decoding="async" loading="lazy" class="aligncenter size-full wp-image-103733" src="../Images/2bce4a4eeb7ff0ab205a4d6613acd7c6.png" alt="Rand GitHub Issue Conversation" srcset="https://blog.logrocket.com/wp-content/uploads/2022/04/rand-github-issue-conversation.png 730w, https://blog.logrocket.com/wp-content/uploads/2022/04/rand-github-issue-conversation-300x106.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/04/rand-github-issue-conversation.png"/></noscript>
<h4>2.非确定性随机数生成器</h4>
<p>Rand 还允许你创建没有种子的随机数，因为它是由系统播种的，只在必要时重新播种。您可以手动触发重新播种过程，如下所示:</p>
<pre class="language-rust hljs">use rand::rngs::OsRng;
use rand::rngs::adapter::ReseedingRng;
use rand::prelude::*;
use rand_chacha::ChaCha20Core; 

fn main(){
    let prng = ChaCha20Core::from_entropy();
    let mut reseeding_rng = ReseedingRng::new(prng, 0, OsRng); //Reseeding
    println!("Random number: {}", reseeding_rng.gen::&lt;u64&gt;());
}
</pre>
<p>在发生<a href="https://en.wikipedia.org/wiki/Side-channel_attack" target="_blank" rel="noopener">旁道攻击和/或误用</a>的情况下，重新播种可以提高您的安全性。本质上，重新播种意味着你从系统产生的熵中产生一个新的种子。</p>
<p>然而，在大多数情况下，您可能会更频繁地使用线程本地生成器<code>thread_rng()</code>来用 Rand 生成随机数。这是因为它通常足以产生你需要的随机性(并且是由你的系统设定的)。关键是你必须为每个随机数使用一个新的种子。下面是一个在 Rand 中使用线程本地生成器的例子。</p>
<pre class="language-rust hljs">let mut rng = rand::thread_rng();
println!("{}", rng.gen::&lt;i32&gt;()); //Result is an unknown value
println!("{}", rng.gen::&lt;i64&gt;()); //Result is an unknown value
println!("{}", rng.gen::&lt;u32&gt;()); //Result is an unknown value
println!("{}", rng.gen::&lt;u64&gt;()); //Result is an unknown value
</pre>
<p>Rand crate 中有几个函数—查看 Rand 的<a href="https://rust-random.github.io/book/intro.html" target="_blank" rel="noopener">文档以了解更多</a>。</p>
<p>那么，在 Rust 应用程序中使用 Rand 有什么好处和坏处呢？最重要的是，Rand 拥有几乎所有你需要的安全随机性，这很好。然而，如果您希望实现基本的随机性，而不太担心复杂性或安全性，那么 Rand 对于您的项目来说可能是多余的。</p>
<h3>在 Rust 中使用 Rand</h3>
<p>下面我们来介绍一些 Rand 的使用案例。借助 Rand，您可以:</p>
<ol>
<li>从一系列数字<code>.gen_range(1.0..100.0)</code> : <pre class="language-rust hljs">let mut rng = thread_rng(); let random_number = rng.gen_range(1.0..100.0); println!("Random from range {}", random_number);</pre>中生成随机数</li>
<li>通过混洗数组产生一个随机数:<pre class="language-rust hljs">let mut rng = rand::thread_rng(); let mut arr = (1..100).collect::&lt;Vec&lt;i32&gt;&gt;(); arr.shuffle(&amp;mut rng); println!("Shuffle array: {:?}", arr);</pre></li>
<li>从种子生成随机数:<pre class="language-rust hljs">let mut rng = rand_chacha::ChaCha8Rng::seed_from_u64(1000); println!("Deterministic Random numbers with seed:{}", rng.gen::&lt;i32&gt;()); // Ghan</pre></li>
<li>抛硬币:<pre class="language-rust hljs">fn flip_coin() {     let mut rng = rand::thread_rng();     if rng.gen::&lt;bool&gt;() {         println!("heads");     } else {         println!("tails");     } }</pre></li>
</ol>
<p>你可以用 Rand 做更多的事情，但是你应该检查一下<a href="https://rust-random.github.io/book/intro.html" target="_blank" rel="noopener">文档来了解更多</a>。</p>
<h2>对 Rust 使用 Fastrand</h2>
<p><a href="https://github.com/smol-rs/fastrand" target="_blank" rel="noopener"> Fastrand </a>是基于<a href="https://github.com/wangyi-fudan/wyhash" target="_blank" rel="noopener"> WyRand </a>的小型快速随机数生成器，是一种现代的非密码哈希函数和伪随机数生成器。它是两年前发布的，与 Rand 不同，Fastrand 不是密码安全的，所以它不应该用于那个目的。它也只有一个依赖项<code><a href="https://github.com/sebcrozet/instant" target="_blank" rel="noopener">Instant</a></code>，而 Rand 有六个。</p>
<h3>Fastrand 的特点</h3>
<p>Fastrand 的随机数仅基于预先确定的种子生成，因此任何拥有该种子的人都可以生成相同的数字。</p>
<h3>使用 Fastrand 的利与弊</h3>
<p>Fastrand 简单紧凑。最重要的是，速度快。然而，Fastrand 在密码方面并不安全。因此，如果您正在寻找更安全的加密方法，请使用 Rand。</p>
<h3>社区支持</h3>
<p>在撰写本文时，使用 Fastrand 时没有<a href="https://stackoverflow.com/questions/tagged/fastrand+rust" target="_blank" rel="noopener">栈溢出问题</a>，GitHub 上只有几个<a href="https://github.com/smol-rs/fastrand/issues?q=" target="_blank" rel="noopener">问题</a>。该项目目前有八个以上的贡献者和 10，976，949 次下载。与其他随机数生成器相比，Fastrand 周围的社区发展很快，但没有 rand 快。</p>
<h3>在 Rust 中使用 Fastrand</h3>
<p>让我们来看一些使用 Fastrand 可以做些什么的例子。</p>
<ol>
<li>首先，您可以生成一个随机的布尔值和<code>true</code>或<code>false</code>值，这对于抛硬币的场景来说很好。<pre class="language-rust hljs">// Flip a coin: if fastrand::bool() {       println!("Fast Rand: heads");     } else {       println!("Fast Rand: tails"); }</pre></li>
<li>使用 Fastrand，可以根据类型生成随机数，以及有符号和无符号数:<pre class="language-rust hljs">println!("Fast Rand: Unsigned Random number 32bit: {}", fastrand::u32(..));     println!("Fast Rand: Unsigned Random unsigned number 64bit: {}", fastrand::u64(..));     println!("Fast Rand: Signed Random number 64bit: {}", fastrand::i64(..)); } </pre></li>
<li>你也可以从一个集合中选择一个随机数，就像这样:<pre class="language-rust hljs">let i = fastrand::usize(vec![1,3,5,6,7,8]); let element = arr[i]; println!("Fast Rand: Random number from array {:?}: is {}", arr, elem);</pre></li>
<li>你可以通过打乱一个数组来产生随机数:<pre class="language-rust hljs">fn shuffle(mut arr: Vec&lt;u32&gt;) {     let shuffled = fastrand::shuffle(&amp;mut arr);     println!("Random numbers from Shuffled array {:?}", shuffled); }</pre></li>
</ol>
<p>你应该查看文档中更多的用例。</p>
<h2>在 rust 中使用非品牌随机性</h2>
<p>Nanorand 是一个有趣的随机数生成器，它很简单，即使它允许你使用一种以上的算法。您可以根据需要选择要使用的算法。</p>
<h3>非品牌的特征</h3>
<p>首先也是最重要的，Nanorand 允许你使用多种算法，比如<code>WyRand</code>、<code>ChaCha</code>和<code>Pcg64</code>。</p>
<p><img data-attachment-id="103736" data-permalink="https://blog.logrocket.com/comparing-random-number-generators-rust/algorithms-for-nanorand/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/04/algorithms-for-nanorand.png" data-orig-size="730,333" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Algorithms for Nanorand" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/04/algorithms-for-nanorand-300x137.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/04/algorithms-for-nanorand.png" decoding="async" class="aligncenter size-full wp-image-103736 jetpack-lazy-image" src="../Images/d14c9a23413d3a9e271776adde2b67e7.png" alt="Algorithms for Nanorand" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2022/04/algorithms-for-nanorand.png 730w, https://blog.logrocket.com/wp-content/uploads/2022/04/algorithms-for-nanorand-300x137.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2022/04/algorithms-for-nanorand.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/04/algorithms-for-nanorand.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="103736" data-permalink="https://blog.logrocket.com/comparing-random-number-generators-rust/algorithms-for-nanorand/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/04/algorithms-for-nanorand.png" data-orig-size="730,333" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Algorithms for Nanorand" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/04/algorithms-for-nanorand-300x137.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/04/algorithms-for-nanorand.png" decoding="async" loading="lazy" class="aligncenter size-full wp-image-103736" src="../Images/d14c9a23413d3a9e271776adde2b67e7.png" alt="Algorithms for Nanorand" srcset="https://blog.logrocket.com/wp-content/uploads/2022/04/algorithms-for-nanorand.png 730w, https://blog.logrocket.com/wp-content/uploads/2022/04/algorithms-for-nanorand-300x137.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/04/algorithms-for-nanorand.png"/></noscript>
<p>因此，无论您是希望生成一个密码安全的 PRNG，还是一个编译时间短的不安全随机数，您都可以使用 Nanorand 来完成。</p>
<h3>使用非品牌的利弊</h3>
<p>Nanorand 是轻量级的，大约 18.4KB，并且速度很快，这取决于您试图生成的随机数的类型。记住:加密安全的随机数比非加密安全的随机数生成要慢得多。</p>
<p>目前，Nanorand 没有太多的社区支持，除了<code>WyRand</code>之外，文档没有涉及它实现的其他算法。然而，Nanorand 已经安装了 834，185 次，有 11 个贡献者，在 GitHub 上几乎没有问题。</p>
<h3>用例</h3>
<p>Nanorand 的用例就像我们已经讨论过的其他随机数生成器一样。</p>
<ol>
<li>根据类型生成随机数，如<code>u64</code>、<code>u32</code>、<code>i32</code>等。<pre class="language-rust hljs">let mut rng = WyRand::new(); println!("Nano Rand: random number 64bit: {}", rng.generate::&lt;u64&gt;()); println!("Nano Rand: random number 32bit: {}", rng.generate::&lt;u32&gt;());</pre></li>
<li>通过混洗数组来生成随机数:<pre class="language-rust hljs">let mut rng = WyRand::new(); let mut items = vec![1, 2, 3, 4, 5, 6, 7, 8, 9, 10]; rng.shuffle(&amp;mut items); println!("Nano: Shuffled array vec {:?}", items);</pre></li>
<li>生成一系列数字之间的随机数。<pre class="language-rust hljs">let mut rng = WyRand::new(); println!(     "Random number between 1 and 100: {}",     rng.generate_range(1_u64..=100) );</pre></li>
</ol>
<h2>在 Rust 中使用 oorandom</h2>
<p><a href="https://crates.io/crates/oorandom" target="_blank" rel="noopener"> Oorandom </a>是一个确定性随机数生成器，实现了<a href="https://en.wikipedia.org/wiki/Permuted_congruential_generator" target="_blank" rel="noopener">置换同余生成器(PCG) </a>。如果您发现 rand 板条箱对于您的项目来说太大，而只是想要更紧凑和具体的东西，请使用 oorandom。更重要的是，它是<code>#[no_std]</code>，如果你正在为裸机设备构建一个项目，这是非常好的。</p>
<p>要生成随机数，您需要从种子中生成它。如果您想生成一个不确定的随机数，使用<code>getrandom</code>箱从您的系统生成随机种子。</p>
<h3>使用 oorandom 的利与弊</h3>
<ul>
<li>它的文件大小约为 10.1KB，并且没有依赖关系</li>
<li>它使用 PCG，这提供了出色的统计性能</li>
</ul>
<p>不幸的是，Oorandom 没有密码安全。</p>
<h3>社区</h3>
<p>Oorandom 非常受欢迎，已经安装了 8107644 次。对于大多数需要一个简单的随机数生成器的人来说，oorandom 是一个很好的选择。</p>
<h3>用例</h3>
<p>Oorandom 只实现了少数几个功能:<code>rand_float</code>、<code>rand_i32</code>、<code>rand_range</code>和<code>rand_u32</code>。</p>
<p><img data-attachment-id="103738" data-permalink="https://blog.logrocket.com/comparing-random-number-generators-rust/oorand-functions/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/04/oorand-functions.png" data-orig-size="730,361" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Oorand functions" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/04/oorand-functions-300x148.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/04/oorand-functions.png" decoding="async" class="aligncenter size-full wp-image-103738 jetpack-lazy-image" src="../Images/a6fe4d4086c8e4757e729a6849e03b22.png" alt="Oorand Functions" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2022/04/oorand-functions.png 730w, https://blog.logrocket.com/wp-content/uploads/2022/04/oorand-functions-300x148.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2022/04/oorand-functions.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/04/oorand-functions.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="103738" data-permalink="https://blog.logrocket.com/comparing-random-number-generators-rust/oorand-functions/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/04/oorand-functions.png" data-orig-size="730,361" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Oorand functions" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/04/oorand-functions-300x148.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/04/oorand-functions.png" decoding="async" loading="lazy" class="aligncenter size-full wp-image-103738" src="../Images/a6fe4d4086c8e4757e729a6849e03b22.png" alt="Oorand Functions" srcset="https://blog.logrocket.com/wp-content/uploads/2022/04/oorand-functions.png 730w, https://blog.logrocket.com/wp-content/uploads/2022/04/oorand-functions-300x148.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/04/oorand-functions.png"/></noscript>
<p>下面是一个如何使用它的示例:</p>
<pre class="language-rust hljs">use oorandom;

fn main(){
  let seed = 4;
  let mut rng = oorandom::Rand32::new(seed);
  println!("OORandom: Random number 32bit: {}", rng.rand_i32());
  println!("OORandom: Random number range: {}", rng.rand_range(1..100));
  println!("OORandom: Random number with float: {}", rng.rand_float());
}
</pre>
<h2>结论</h2>
<p>有了 Rust，我们可以通过使用随机数生成器做很多事情。虽然这个列表中的生成器可能会随着时间的推移而改变，因为创建了更强的算法，但我们在本文中讨论了开发人员使用 Rust、security 和/或 cryptography 的一些常用选项。黑客快乐！</p><div class="code-block code-block-29">
<div class="blog-plug inline-plug rust-plug"><h2><a href="https://lp.logrocket.com/blg/rust-signup" target="_blank">log rocket</a>:Rust 应用的 web 前端的全面可见性</h2><p>调试 Rust 应用程序可能很困难，尤其是当用户遇到难以重现的问题时。如果您对监控和跟踪 Rust 应用程序的性能、自动显示错误、跟踪缓慢的网络请求和加载时间感兴趣，</p><a href="https://lp.logrocket.com/blg/rust-signup" target="_blank">try LogRocket</a><p>. </p><a class="signup" href="https://lp.logrocket.com/blg/rust-signup" target="_blank" rel="noopener noreferrer"><img class="alignnone size-full wp-image-46 jetpack-lazy-image" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/><noscript><img data-lazy-fallback="1" class="alignnone size-full wp-image-46" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/></noscript></a><p>LogRocket 就像是网络和移动应用程序的 DVR，记录你的 Rust 应用程序上发生的一切。您可以汇总并报告问题发生时应用程序的状态，而不是猜测问题发生的原因。LogRocket 还可以监控应用的性能，报告客户端 CPU 负载、客户端内存使用等指标。</p><p>现代化调试 Rust 应用的方式— <a class="signup" href="https://lp.logrocket.com/blg/rust-signup" target="_blank" rel="noopener noreferrer">开始免费监控</a>。</p></div>


</div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
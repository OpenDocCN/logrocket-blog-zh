<html>
<head>
<title>Creating a Remix app with GraphQL - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>用GraphQL - LogRocket博客创建一个混音应用</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/creating-remix-app-graphql/#0001-01-01">https://blog.logrocket.com/creating-remix-app-graphql/#0001-01-01</a></blockquote><div><article class="article-post">
<p>Remix是一个非常棒的React框架，专注于服务器端渲染。Remix允许应用程序有一个快速的加载时间，一旦应用程序被加载，水合作用就开始发挥作用，并为它提供客户端功能。</p>
<p>因为Remix可以在服务器上运行，所以我们可以在Remix应用程序中创建API路由来执行后端任务，比如连接到数据库。感谢像Apollo GraphQL这样的技术和工具，我们可以利用Remix API路由来构建一个功能性的全栈GraphQL应用程序。</p>
<p>在本文中，我们将介绍如何建立一个具有GraphQL功能的Remix应用程序。我们将研究如何通过使用Apollo创建GraphQL服务器路由，在Remix应用程序中实现简单的CRUD功能。</p>

<h2 id="what-remix">什么是混音？</h2>
<p>Remix是一个关注用户界面的全栈web框架。它通过web基本原理来提供快速、流畅、有弹性的用户体验。</p>
<p>Remix基于React构建，包括React路由器、服务器端渲染、TypeScript支持、生产服务器和后端优化。</p>
<p>如果您熟悉React，您会知道有几个框架提供基于React的服务器端呈现功能。一些这样的框架包括<a href="https://nextjs.org/" target="_blank" rel="noopener"> Next.js </a>和<a href="https://astro.build/" target="_blank" rel="noopener"> Astro </a>。</p>
<p>Remix从其他服务器端React框架中脱颖而出有几个原因。首先，与Next.js等其他框架不同，它不提供静态站点生成(SSG)。相反，它建立在<a href="https://remix.run/docs/en/v1/pages/philosophy#serverclient-model" target="_blank" rel="noopener">服务器/客户端模型</a>之上，专注于SSR，在服务器上构建和编译一切，并在边缘利用分布式系统。客户端接收较小的有效负载，并在客户端使用React进行水合。</p>
<p>Remix还完全采用了web Fetch API等Web标准，允许开发人员利用Web提供的核心工具和功能，并且已经开发了多年。例如，Remix利用HTTP缓存，让浏览器处理任何复杂的缓存资源。</p>
<p>最后，我们会发现，与其他框架不同，Remix在数据突变和CRUD功能方面利用了HTML <code>&lt;form&gt;</code>。然后，它使用<code>action</code>和<code>loader</code>来处理用<code>&lt;form&gt;</code>发送的请求。</p>
<h3 id="understanding-remix-api-routes">了解Remix API路线</h3>
<p>有了Remix，<a href="https://remix.run/docs/en/v1/guides/api-routes#routes-are-their-own-api" target="_blank" rel="noopener">路由就是自己的API</a>。因为一切都在服务器上，所以当用户请求路由时，组件在服务器端获取数据。</p>
<p>Remix中的<a href="https://blog.logrocket.com/understanding-routes-route-nesting-remix/" target="_blank" rel="noopener">路由是Remix与Next.js等框架的另一个关键区别</a>，在next . js中，客户端需要向API/服务器路由发出请求，以便在<code>loader</code>和<code>action</code>的帮助下执行CRUD操作</p>
<p>看看下面的代码:</p>
<pre class="language-typescript hljs">// ./app/routes/index.tsx

import { json } from '@remix-run/node';
import { useLoaderData } from '@remix-run/react';

// type definitions
type Book = {
  title: string;
  genre: string;
};
type Books = Array&lt;Book&gt;;
type LoaderData = {
  books: Books;
};

// Loader function
export const loader = async () =&gt; {
  return json&lt;LoaderData&gt;({
    books: [
      {
        title: 'Harry Potter and the Deathly Hallows',
        genre: "Children's Fiction",
      },
      {
        title: "Harry Potter and the Philosopher's Stone",
        genre: "Children's Fiction",
      },
    ],
  });
};

export default function Index() {
  // use data from loader
  const { books } = useLoaderData() as LoaderData;
  return (
    &lt;div style={{ fontFamily: 'system-ui, sans-serif', lineHeight: '1.4' }}&gt;
      &lt;h1&gt;Welcome to Remix&lt;/h1&gt;
      &lt;ul&gt;
        {books.map(({ title, genre }, i) =&gt; {
          return (
            &lt;li key={i}&gt;
              &lt;h3&gt; {title} &lt;/h3&gt;
              &lt;p&gt; {genre} &lt;/p&gt;
            &lt;/li&gt;
          );
        })}
      &lt;/ul&gt;
    &lt;/div&gt;
  );
}
</pre>
<p><a href="https://stackblitz.com/edit/node-kd1jcm?file=app/routes/index.tsx" target="_blank" rel="noopener">点击此处查看StackBlitz </a>。</p>
<p>在上面的代码中，我们可以看到我们声明了一个<code>loader</code>来返回一个可以从远程服务器或数据库获取的书籍数组，但是现在它是硬编码的。由于<code>loader</code>函数是<a href="https://remix.run/docs/en/v1/tutorials/blog#loading-data" target="_blank" rel="noopener">我们路线的后端“API”</a>，在<code>useLoaderData</code>的帮助下，我们可以很容易地从<code>Index</code>组件中的<code>loader</code>获得数据。</p>
<p>由于这一切都发生在服务器上，它被渲染并发送到浏览器。在客户端没有额外的获取操作。</p>
<p>除了获取数据，我们还可以使用<code>actions</code>在服务器端发送要处理的数据。</p>
<p>让我们向我们的<code>Index</code>组件添加一个带有<code>method="post"</code>的表单和一个将处理提交请求的<code>action</code>:</p>
<pre class="language-typescript hljs">import { json } from '@remix-run/node';
import { useLoaderData, useActionData, Form } from '@remix-run/react';
// type definitions
// ...

// loader function
export const loader = async () =&gt; {
 // ...
};

// action funtion
export const action = async ({ request }) =&gt; {
  const formData = await request.formData();
  const name = formData.get('name');
  return json({ name });
};

export default function Index() {
  // use data from loader
  const { books } = useLoaderData() as LoaderData;

  // get data from action
  const data = useActionData();
  return (
    &lt;div style={{ fontFamily: 'system-ui, sans-serif', lineHeight: '1.4' }}&gt;
      {/* show "Stranger" if no data is available yet */}
      &lt;h1&gt;Welcome to Remix {data ? data.name : 'Stranger'} &lt;/h1&gt;

      &lt;ul&gt;
        {books.map(({ title, genre }, i) =&gt; {
          return (
            &lt;li key={i}&gt;
              &lt;h3&gt; {title} &lt;/h3&gt;
              &lt;p&gt; {genre} &lt;/p&gt;
            &lt;/li&gt;
          );
        })}
      &lt;/ul&gt;

      {/* Remix form component with "POST" method */}
      &lt;Form method="post"&gt;
        &lt;div className="form-control"&gt;
          &lt;label htmlFor="name"&gt;
            Name
            &lt;input id="name" name="name" type="text" /&gt;
          &lt;/label&gt;
        &lt;/div&gt;
        &lt;button type="submit"&gt;Submit &lt;/button&gt;
      &lt;/Form&gt;
    &lt;/div&gt;
  );
}
</pre>
<p><a href="https://stackblitz.com/edit/node-kd1jcm?file=app/routes/index.tsx">堆栈上的视图</a></p>
<p>在上面的代码中，我们创建了一个带有<code>request</code>参数的<code>action</code>函数。我们通过调用<code>request.formData()</code>并将其传递给<code>formData</code>变量来获取表单值。为了获得<code>name</code>值，我们在<code>formData</code>上调用<code>.get()</code>方法。</p>
<p>最后，我们返回一个JSON对象，包含从请求中收到的<code>name</code>。</p>
<p>在我们的<code>Index</code>组件中，为了从我们的路由<code>action</code>访问JSON解析的数据，我们简单地使用了<code><a href="https://remix.run/docs/en/v1/api/remix#useactiondata" target="_blank" rel="noopener">useActionData</a></code>钩子。如果在当前位置还没有提交，它返回<code>undefined</code>。</p>
<p>这是对Remix最基本的介绍，我们已经看到了如何在Remix应用程序中获取和发送数据。接下来，我们将看看GraphQL以及如何在Remix中使用它。</p>
<h2 id="why-use-graphql">为什么要使用GraphQL？</h2>
<p>与REST API相比，GraphQL的主要优势在于，在与API交互时，GraphQL减少了不必要的请求。</p>
<p>根据请求，REST APIs往往会返回比我们应用程序所需更多或更少的数据。这可能会使来自我们请求的响应变得不必要的臃肿，甚至对于一个操作来说是不够的。然后我们将不得不执行另一个请求，这反过来会影响用户体验，尤其是在不稳定的网络条件下)。</p>
<p>使用GraphQL，我们必须能够在响应中明确请求我们需要的内容——不多也不少。</p>
<p>将GraphQL的效率与Remix在构建服务器端呈现的web应用程序时带来的效率结合起来，我们将看到一些真正令人敬畏的东西。</p>
<h3 id="introduction-apollo-graphql">Apollo GraphQL简介</h3>
<p>正如本文中的<a href="https://flaviocopes.com/apollo/" target="_blank" rel="noopener">所定义的，“Apollo是一套创建GraphQL服务器和消费GraphQL API的工具。”</a></p>
<p>我们将使用的工具之一是<a href="https://www.apollographql.com/docs/react/api/link/apollo-link-schema/" target="_blank" rel="noopener">模式链接</a>，它允许我们对提供的模式执行GraphQL操作，而不是对GraphQL API进行网络调用。</p>
<p>这个工具对于SSR应用程序来说非常方便，在本文中我们将和其他工具一起使用。</p>
<h2 id="overview-remix-graphql-app">我们的Remix和GraphQL应用概述</h2>
<p>下面是我们在本教程中将要构建的内容的简要概述。</p>
<p>在上一节中，我们介绍了Remix、<code>loader</code>和<code>action</code>函数中的路线，为了演示这些概念，我们构建了一个简单的应用程序来呈现图书列表，并包含一个表单，在提交时询问并显示我们的姓名。</p><div class="code-block code-block-54">
<hr/>
<h3>更多来自LogRocket的精彩文章:</h3>

<hr/></div>
<p>提醒一下，你可以在<a href="https://stackblitz.com/edit/node-kd1jcm?file=app/routes/index.tsx" target="_blank" rel="noopener"> StackBlitz </a>和这个<a href="https://github.com/miracleonyenma/remix-demo/tree/actions" target="_blank" rel="noopener"> GitHub分支</a>上访问代码。</p>
<p>在下一节中，我们将构建一个简单的应用程序，它显示图书列表，并提供一个表单以嵌套的方式上传新书，所有这些都使用GraphQL查询和变体。</p>
<p>您可以在GitHub 上的资源库的<a href="https://github.com/miracleonyenma/remix-demo/tree/schema-links" target="_blank" rel="noopener"> schema-links分支上访问最终代码。</a></p>
<h3 id="prerequisites">先决条件</h3>
<p>要阅读这篇文章，我们需要:</p>
<ul>
<li>文本编辑器(例如VSCode)</li>
<li><a href="https://remix.run/" target="_blank" rel="noopener">再混合</a>的基础知识</li>
<li><a href="https://graphql.org/" target="_blank" rel="noopener"> GraphQL </a>的基础知识</li>
<li>最近安装的<a href="https://nodejs.org/en/" target="_blank" rel="noopener"> Node.js </a>版本</li>
</ul>
<h2 id="setting-up-remix-project">设置混音项目</h2>
<p>要创建新的混音项目，请在终端中运行以下命令:</p>
<pre class="language-bash hljs">npx <a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="086b7a6d697c6d257a6d6561704864697c6d7b7c">[email protected]</a>
</pre>
<p>然后按照提示操作:</p>
<pre class="language-bash hljs">? Where would you like to create your app? remix-graphql
? What type of app do you want to create? Just the basics
? Where do you want to deploy? Choose Remix App Server if you're unsure; it's easy to change deployment targets. Remix App Server
? TypeScript or JavaScript? TypeScript
? Do you want me to run `npm install`? Yes
</pre>
<p>一旦创建并安装了项目，我们就可以继续了。</p>
<h2 id="apollo-graphql-remix">阿波罗图QL在Remix</h2>
<p>为了在我们的项目中使用Apollo GraphQL，我们必须安装几个包:</p>
<pre class="language-bash hljs">npm install @apollo/client @graphql-tools/schema
</pre>
<p>一旦安装了包，让我们设置我们的GraphQL客户端。如前所述，我们将使用模式链接。在新的<code>./app/lib/apollo/index.ts</code>文件中，我们将配置我们的模式和解析器:</p>
<pre class="language-typescript hljs">// ./app/lib/apollo/index.ts

import { ApolloClient, gql, InMemoryCache } from "@apollo/client";
import { SchemaLink } from "@apollo/client/link/schema";
import { makeExecutableSchema } from "@graphql-tools/schema";
import { read, write } from "../../utils/readWrite";

// a schema is a collection of type definitions (hence "typeDefs")
// that together define the "shape" of queries that are executed against
// your data.
export const typeDefs = gql`

  # Comments in GraphQL strings (such as this one) start with the hash (#) symbol.
  # This "Book" type defines the queryable fields for every book in our data source.
  type Book {
    title: String
    author: String
  }

  # the "Query" type is special: it lists all of the available queries that
  # clients can execute, along with the return type for each. in this
  # case, the "books" query returns an array of zero or more Books (defined above).
  type Query {
    books: [Book]
  }
`;

// resolvers define the technique for fetching the types defined in the
// schema. this resolver retrieves books from the "books" array above.
export const resolvers = {
  Query: {
    books: () =&gt; {
      const books = read();
      return books;
    },
  }
};

const schema = makeExecutableSchema({ typeDefs, resolvers });

export const graphQLClient = new ApolloClient({
  cache: new InMemoryCache(),
  ssrMode: true,
  link: new SchemaLink({ schema }),
});
</pre>
<p>在上面的代码中，我们定义了我们的<code>Book</code>和<code>Query</code>类型。对于我们的<code>Query</code>，<code>books</code>查询返回一个<code>Book</code>的列表。</p>
<p>我们还在<code>resolvers</code>中定义了我们的<code>Query</code>解析器，它简单地返回由<code>read</code>函数提供的图书列表。这可能是一个从外部API或数据库获取图书列表的函数。在我们的例子中，我们只是从一个JSON文件中获取书籍。</p>
<p>然后，我们使用<code>makeExecutableSchema</code>创建一个可执行模式，并传入模式(<code>typeDefs</code>和<code>resolvers</code>)。</p>
<p>最后，我们定义一个新的<code>ApolloClient</code>实例为<code>graphQLClient</code>并导出它，准备在我们的Remix加载器中使用。</p>
<p>在此之前，让我们设置我们的实用函数<code>read</code>和<code>write</code>，使我们能够读取和修改包含图书列表的<code>.json</code>文件。</p>
<h2 id="setting-up-utility-functions-read-write-json-files">设置实用函数来读写JSON文件</h2>
<p>在<code>./app/data/books.json</code>创建一个JSON文件:</p>
<pre class="language-json hljs">// ./app/data/books.json
[
  {
    "title": "The Awakening",
    "author": "Kate Chopin"
  },
  {
    "title": "City of Glass",
    "author": "Paul Auster"
  },
  {
    "title": "Harry Potter and the Deathly Hallows",
    "author": "JK Rowling"
  }
]
</pre>
<p>创建一个新文件<code>./app/utils/readWrite.ts</code>并输入以下代码:</p>
<pre class="language-json hljs">// ./app/utils/readWrite.ts
import fs from "fs"

// JSON file containing books array
const dataPath = `${process.cwd()}/app/data/books.json`;

// function to read file contents 
export const read = (
  returnJSON = false,
  path = dataPath,
  encoding = "utf-8"
) =&gt; {
  try {
    let data = readFileSync(path, encoding);
    return returnJSON ? data : JSON.parse(data);
  } catch (error) {
    console.log({ error });
    return null;
  }
};

// function to write content to file
export const write = (data: object, path = dataPath) =&gt; {
  let initialData = read();
  let modifiedData = [...initialData, data];
  try {
    writeFileSync(path, JSON.stringify(modifiedData, null, 2));
    let result = read();
    return result;
  } catch (error) {
    console.log({ error });
    return null;
  }
};
</pre>
<p>太好了！既然已经为解析器创建了读写函数，那么让我们创建一个<code>/books</code>路由来运行一个查询，该查询使用Apollo客户机模式链接列出我们所有的书籍。</p>
<h3 id="running-queries">运行我们的查询</h3>
<p>用以下代码创建一个新文件<code>./app/routes/books.tsx</code>:</p>
<pre class="language-typescript hljs">// ./app/routes/books.tsx

import { LoaderFunction, json } from "@remix-run/node";
import { gql } from "@apollo/client";
import { graphQLClient } from "~/lib/apollo";
import { useLoaderData } from "@remix-run/react";

const query = gql`
  query GetBooks {
    books {
      title
      author
    }
  }
`;

export const loader: LoaderFunction = async ({ request, params }) =&gt; {
  const { data } = await graphQLClient.query({
    query,
  });
  return json({ books: data.books });
};

export default function Books() {
  const { books } = useLoaderData();
  return (
    &lt;main&gt;
      &lt;section&gt;
        &lt;h1&gt;All books&lt;/h1&gt;
        &lt;ul&gt;
          {books.map(({ title, author }: { title: string; author: string }, index:number) =&gt; (
            &lt;li key={index}&gt;
              &lt;h3&gt;{title}&lt;/h3&gt;
              &lt;p&gt;{author}&lt;/p&gt;
            &lt;/li&gt;
          ))}
        &lt;/ul&gt;
      &lt;/section&gt;
    &lt;/main&gt;
  );
}
</pre>
<p>这里，我们定义了我们的<code>query</code>，在我们的<code>loader</code>函数中，我们使用<code>graphQLClient.query()</code>执行查询并返回<code>json</code>响应。</p>
<p>在我们的<code>Books</code>组件中，我们使用<code>useLoaderData()</code>获取图书列表并呈现它:</p>
<p><img data-attachment-id="135655" data-permalink="https://blog.logrocket.com/creating-remix-app-graphql/attachment/all-books/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/10/all-books.png" data-orig-size="730,295" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="All books" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/10/all-books-300x121.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/10/all-books.png" decoding="async" class="aligncenter size-full wp-image-135655 jetpack-lazy-image" src="../Images/3824db59d489071e47e07a6ef0a80df1.png" alt="All Books UI Screen" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2022/10/all-books.png 730w, https://blog.logrocket.com/wp-content/uploads/2022/10/all-books-300x121.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2022/10/all-books.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/10/all-books.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="135655" data-permalink="https://blog.logrocket.com/creating-remix-app-graphql/attachment/all-books/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/10/all-books.png" data-orig-size="730,295" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="All books" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/10/all-books-300x121.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/10/all-books.png" decoding="async" loading="lazy" class="aligncenter size-full wp-image-135655" src="../Images/3824db59d489071e47e07a6ef0a80df1.png" alt="All Books UI Screen" srcset="https://blog.logrocket.com/wp-content/uploads/2022/10/all-books.png 730w, https://blog.logrocket.com/wp-content/uploads/2022/10/all-books-300x121.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/10/all-books.png"/></noscript>
<p>厉害！我们的查询路线有效。接下来，我们将看到如何设置突变。</p>
<h3 id="setting-up-mutations">设置突变</h3>
<p>首先，我们在<code>./app/lib/apollo/index.ts</code>中的<code>typeDefs</code>中定义我们的<code>Mutation</code>和<code>BookInput</code>类型:</p>
<pre class="language-typescript hljs">// ./app/lib/apollo/index.ts
// ...

export const typeDefs = gql`

  # here, we define an input
  input BookInput {
    title: String
    author: String
  }

  # here, we define our mutations
  type Mutation {
    addBook(book: BookInput): [Book]!
  }
`;
</pre>
<p>在这里，我们用<code>title</code>和<code>author</code>定义了一个<code>input</code>类型:<code>BookInput</code>。它们都是字符串。</p>
<p>我们还定义了一个<code>addBook</code>变异，它接受我们之前创建的输入类型<code>BookInput</code>的一个参数<code>book</code>。</p>
<p>然后，<code>addBook</code>变异返回一个名为<code>[Book]</code>的图书列表</p>
<p>接下来，我们定义我们的<code>Mutation</code>解析器:</p>
<pre class="language-typescript hljs">// ./app/lib/apollo/index.ts

// ...
export const resolvers = {
  Query: {
   // ...
  },
  Mutation: {
    addBook: (parent: any, { book }: any) =&gt; {
      console.log({ book });
      let books = write(book);
      return books;
    },
  },
};
// ...
</pre>
<p>这里，我们创建了一个新的<code>addBook</code>解析器，它接受<code>book</code>作为参数，并将其传递给<code>write()</code>函数。这会将新书添加到列表中，并返回更新后的图书列表。</p>
<p>创建新的<code>/books/addbook</code>路线。这将是一个嵌套的路由，这意味着我们必须创建一个像<code>./app/routes/books/addbook.tsx</code>一样的<code>books</code>目录:</p>
<pre class="language-typescript hljs">// ./app/routes/books/addbook.tsx

import { gql } from "@apollo/client";
import { ActionFunction, json } from "@remix-run/node";
import { Form } from "@remix-run/react";
import { graphQLClient } from "~/lib/apollo";

// action function
export const action: ActionFunction = async ({ request }) =&gt; {
  const formData = await request.formData();
  const title = formData.get("title");
  const author = formData.get("author");

  let book = {
    title,
    author,
  };

  // mutation to add book
  const mutation = gql`
    mutation ($book: BookInput) {
      addBook(book: $book) {
        title
      }
    }
  `;

  const { data } = await graphQLClient.mutate({
    mutation,
    variables: { book },
  });

  return json({ books: data.books });
};
export default function AddBook() {
  return (
    &lt;section style={{ border: "1px solid #333", padding: "1rem" }}&gt;
      &lt;h2&gt;Add new book&lt;/h2&gt;
      &lt;Form method="post"&gt;
        &lt;div className="form-control"&gt;
          &lt;label htmlFor="title"&gt;Title&lt;/label&gt;
          &lt;input id="title" name="title" type="text" /&gt;
        &lt;/div&gt;
        &lt;div className="form-control"&gt;
          &lt;label htmlFor="author"&gt;Author&lt;/label&gt;
          &lt;input id="author" name="author" type="text" /&gt;
        &lt;/div&gt;
        &lt;button type="submit"&gt;Submit&lt;/button&gt;
      &lt;/Form&gt;
    &lt;/section&gt;
  );
}
</pre>
<p>在这里，我们可以看到我们有一个<code>action</code>函数，从<code>request</code>中得到<code>title</code>和<code>author</code>。</p>
<p>然后，我们创建一个<code>mutation</code>并将包含<code>title</code>和<code>author</code>的<code>book</code>对象作为变量传递。之后，我们使用<code>graphQLClient.mutate</code>执行这个查询。</p>
<p>在我们的<code>AddBook</code>组件中，我们使用Remix提供的<code>Form</code>组件通过<code>method = "post"</code>发送我们的数据。</p>
<p>现在，为了渲染我们的嵌套路线，我们必须在<code>./app/routes/books.tsx</code>中添加<code>&lt;Outlet/&gt;</code>:</p>
<pre class="language-typescript hljs">// ...

export default function Books() {
  const { books } = useLoaderData();
  return (
    &lt;main&gt;
      &lt;section&gt;
        {/* ... */}
      &lt;/section&gt;

      &lt;Outlet /&gt;
    &lt;/main&gt;
  );
}
</pre>
<p>现在，当我们转到<code><a href="http://localhost:3000/books/addbook" rel="nofollow">http://localhost:3000/books/addbook</a></code>时，我们应该会看到:</p>
<p><img data-attachment-id="135657" data-permalink="https://blog.logrocket.com/creating-remix-app-graphql/attachment/working-app-gif/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/10/working-app-gif.gif" data-orig-size="730,356" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Working app gif" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/10/working-app-gif-300x146.gif" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/10/working-app-gif.gif" decoding="async" class="aligncenter size-full wp-image-135657 jetpack-lazy-image" src="../Images/12e6b851dd924ca500b71b1fdff2c591.png" alt="Working App Gif" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2022/10/working-app-gif.gif?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/10/working-app-gif.gif"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="135657" data-permalink="https://blog.logrocket.com/creating-remix-app-graphql/attachment/working-app-gif/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/10/working-app-gif.gif" data-orig-size="730,356" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Working app gif" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/10/working-app-gif-300x146.gif" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/10/working-app-gif.gif" decoding="async" loading="lazy" class="aligncenter size-full wp-image-135657" src="../Images/12e6b851dd924ca500b71b1fdff2c591.png" alt="Working App Gif" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/10/working-app-gif.gif"/></noscript>
<p>不错！</p>
<h2 id="conclusion">结论</h2>
<p>到目前为止，我们已经能够使用Apollo GraphQL设置Remix来针对我们的GraphQL模式发出请求。</p>
<p>我们现在可以进行查询和改变，这一切都发生在服务器端，所以在我们的客户端没有不必要的网络调用。</p>
<p>这只是我们用Remix和GraphQL所能实现的事情的冰山一角。我们还可以在Remix中创建一个资源路由，使用Apollo Server提供一个GraphQL端点。这将允许我们提出请求，并提供一个GraphQL平台。</p>
<p>你可以在再混合文档中读到更多关于<a href="https://remix.run/docs/en/v1/guides/resource-routes" target="_blank" rel="noopener">资源路线的信息，也可以在阿波罗文档</a>中读到更多关于<a href="https://www.apollographql.com/docs/apollo-server/getting-started" target="_blank" rel="noopener">阿波罗服务器的信息。</a></p><div class="code-block code-block-24">
<div class="blog-plug inline-plug graphql-plug"><h2>监控生产中失败和缓慢的GraphQL请求</h2><p>虽然GraphQL有一些调试请求和响应的特性，但确保GraphQL可靠地为您的生产应用程序提供资源是一件比较困难的事情。如果您对确保对后端或第三方服务的网络请求成功感兴趣，</p><a href="https://lp.logrocket.com/blg/graphql-signup" target="_blank">try LogRocket</a><p>.</p><a class="signup" href="https://lp.logrocket.com/blg/graphql-signup" target="_blank" rel="noopener noreferrer"><img src="../Images/432a3823c85b3fb72a206e6236a29f48.png" data-lazy-src="https://files.readme.io/69aa835-Image_2019-11-09_at_1.28.05_PM.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" class=" jetpack-lazy-image" data-original-src="https://files.readme.io/69aa835-Image_2019-11-09_at_1.28.05_PM.png"/><noscript><img data-lazy-fallback="1" src="../Images/432a3823c85b3fb72a206e6236a29f48.png" data-original-src="https://files.readme.io/69aa835-Image_2019-11-09_at_1.28.05_PM.png"/></noscript><img class="alignnone size-full wp-image-46 jetpack-lazy-image" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/><noscript><img data-lazy-fallback="1" class="alignnone size-full wp-image-46" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/></noscript></a><a href="https://lp.logrocket.com/blg/graphql-signup" target="_blank" rel="noopener noreferrer">https://logrocket.com/signup/</a><p>LogRocket 就像是网络和移动应用的DVR，记录下你网站上发生的每一件事。您可以汇总并报告有问题的GraphQL请求，以快速了解根本原因，而不是猜测问题发生的原因。此外，您可以跟踪Apollo客户机状态并检查GraphQL查询的键值对。</p><p>LogRocket检测您的应用程序以记录基线性能计时，如页面加载时间、到达第一个字节的时间、慢速网络请求，还记录Redux、NgRx和Vuex操作/状态。</p><a class="signup" href="https://lp.logrocket.com/blg/graphql-signup" target="_blank" rel="noopener noreferrer">Start monitoring for free</a><p>.</p></div>


</div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
<html>
<head>
<title>Implementing pagination with GraphQL in NestJS - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>在 NestJS - LogRocket 博客中用 GraphQL 实现分页</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/implementing-pagination-graphql-nestjs/#0001-01-01">https://blog.logrocket.com/implementing-pagination-graphql-nestjs/#0001-01-01</a></blockquote><div><article class="article-post">
<h1>在 NestJS 中用 GraphQL 实现分页</h1>
<p>分页是许多数据驱动的应用程序中常见的 UX 问题。我们需要限制屏幕上显示的内容；如果我的内容需要太多的滚动，在我的网站上导航对我的用户来说是一种痛苦的经历。</p>
<p>在这篇文章中，我们将看到一种解决这个问题的常见方法，用 GraphQL 构建一个 NestJS 服务器，然后在 React 前端使用它。通过一步一步地学习下面的内容，我们将构建一个简单的分页系统，它可以应用于各种应用程序。</p>
<p>本指南将分为三个主要部分:</p>
<ol>
<li><a href="#pagination-algorithm">分页算法</a></li>
<li><a href="#setting-api-using-nestjs-graphql">使用 NestJS、GraphQL 和 Mongoose 建立 API</a></li>
<li><a href="#building-react-frontend">构建一个 React 前端来使用 API </a></li>
</ol>
<p>这是用 NestJS 和 GraphQL 实现简单分页系统的实用指南。您可以改进我们将在本指南中构建的应用程序，以创建更适合生产的东西。</p>
<p>我推荐编码来巩固概念。本指南所写的所有代码都可以在我的 GitHub 上找到<a href="https://github.com/ovieokeh/graphql-nestjs-pagination-guide" target="_blank" rel="noopener">。</a></p>
<h2 id="what-are-we-building">我们在建造什么？</h2>
<p>我们将构建的应用程序是一个简单的 React 前端，允许用户浏览用户列表。它非常简单，足以轻松理解我们将涉及的不同概念，同时也足够实用，可以针对现有应用程序进行修改。</p>
<figure id="attachment_119659" aria-describedby="caption-attachment-119659" class="wp-caption aligncenter"><img data-attachment-id="119659" data-permalink="https://blog.logrocket.com/implementing-pagination-graphql-nestjs/attachment/react-frontend-pagination/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/06/react-frontend-pagination.png" data-orig-size="737,452" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="react-frontend-pagination" data-image-description="" data-image-caption="&lt;p&gt;This should be getting an AWWWARDS nomination anytime now&lt;/p&gt;&#10;" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/06/react-frontend-pagination-300x184.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/06/react-frontend-pagination.png" decoding="async" class="wp-image-119659 size-full jetpack-lazy-image" src="../Images/2d533fe717ae315f20f3ee94fc4b5e29.png" alt="Page through a list of users" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2022/06/react-frontend-pagination.png 737w, https://blog.logrocket.com/wp-content/uploads/2022/06/react-frontend-pagination-300x184.png 300w" data-lazy-sizes="(max-width: 737px) 100vw, 737px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2022/06/react-frontend-pagination.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/06/react-frontend-pagination.png"/><noscript><img data-lazy-fallback="1" data-attachment-id="119659" data-permalink="https://blog.logrocket.com/implementing-pagination-graphql-nestjs/attachment/react-frontend-pagination/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/06/react-frontend-pagination.png" data-orig-size="737,452" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="react-frontend-pagination" data-image-description="" data-image-caption="&lt;p&gt;This should be getting an AWWWARDS nomination anytime now&lt;/p&gt;&#10;" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/06/react-frontend-pagination-300x184.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/06/react-frontend-pagination.png" decoding="async" loading="lazy" class="wp-image-119659 size-full" src="../Images/2d533fe717ae315f20f3ee94fc4b5e29.png" alt="Page through a list of users" srcset="https://blog.logrocket.com/wp-content/uploads/2022/06/react-frontend-pagination.png 737w, https://blog.logrocket.com/wp-content/uploads/2022/06/react-frontend-pagination-300x184.png 300w" sizes="(max-width: 737px) 100vw, 737px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/06/react-frontend-pagination.png"/></noscript><figcaption id="caption-attachment-119659" class="wp-caption-text">This should be getting an AWWWARDS nomination anytime now</figcaption></figure>

<p>在设置项目之前，浏览一下我们将要实现的分页算法是值得的。当我们开始创建文件和编写代码时，这将帮助您理解项目的每个部分。</p>
<p>让我们跳过这一步，看看我们将调用的最后一个 GraphQL 查询，以获取用户列表并对其进行分页。</p>
<pre class="language-graphql hljs">{
  count
  users(take: 20, skip: 0) {
    firstName
    lastName
  }
}
</pre>
<p>该查询由两个资源组成，<code>count</code>和<code>users</code>。</p>
<p>第一个是<code>count</code>，从名字就可以看出，它只是返回数据库中所有用户的数量。另一个资源，<code>users</code>让我们指定要检索多少个用户(<code>take</code>)，以及开始获取的偏移量(<code>skip</code>)。</p>
<p>我们如何用这个简单的查询实现分页呢？</p>
<p>考虑一个场景，我们有五种资源:</p>
<pre class="language-plaintext hljs"><code>[one, two, three, four, five]
</code></pre>
<p>如果我们使用参数<code>take = 2, skip = 0</code>运行上面的查询，我们将获得以下资源:</p>
<pre class="language-plaintext hljs"><code>[one, two]
</code></pre>
<p>如果我们再次运行相同的查询，但是使用以下参数:</p>
<p><code>take = 2, skip = 2</code></p>
<p>我们会得到以下资源:</p>
<pre class="language-plaintext hljs"><code>[three, four]
</code></pre>
<figure id="attachment_119666" aria-describedby="caption-attachment-119666" class="wp-caption aligncenter"><img data-attachment-id="119666" data-permalink="https://blog.logrocket.com/implementing-pagination-graphql-nestjs/attachment/frontend-users/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/06/frontend-users.png" data-orig-size="800,750" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="frontend-users" data-image-description="" data-image-caption="&lt;p&gt;How &lt;code&gt;take&lt;/code&gt; and &lt;code&gt;skip&lt;/code&gt; work, but visually&lt;/p&gt;&#10;" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/06/frontend-users-300x281.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/06/frontend-users.png" decoding="async" class="size-full wp-image-119666 jetpack-lazy-image" src="../Images/f9ff337cb1bef731fc6130275166b2ed.png" alt="Using skip and take to keep track of users" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2022/06/frontend-users.png 800w, https://blog.logrocket.com/wp-content/uploads/2022/06/frontend-users-300x281.png 300w, https://blog.logrocket.com/wp-content/uploads/2022/06/frontend-users-768x720.png 768w" data-lazy-sizes="(max-width: 800px) 100vw, 800px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2022/06/frontend-users.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/06/frontend-users.png"/><noscript><img data-lazy-fallback="1" data-attachment-id="119666" data-permalink="https://blog.logrocket.com/implementing-pagination-graphql-nestjs/attachment/frontend-users/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/06/frontend-users.png" data-orig-size="800,750" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="frontend-users" data-image-description="" data-image-caption="&lt;p&gt;How &lt;code&gt;take&lt;/code&gt; and &lt;code&gt;skip&lt;/code&gt; work, but visually&lt;/p&gt;&#10;" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/06/frontend-users-300x281.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/06/frontend-users.png" decoding="async" loading="lazy" class="size-full wp-image-119666" src="../Images/f9ff337cb1bef731fc6130275166b2ed.png" alt="Using skip and take to keep track of users" srcset="https://blog.logrocket.com/wp-content/uploads/2022/06/frontend-users.png 800w, https://blog.logrocket.com/wp-content/uploads/2022/06/frontend-users-300x281.png 300w, https://blog.logrocket.com/wp-content/uploads/2022/06/frontend-users-768x720.png 768w" sizes="(max-width: 800px) 100vw, 800px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/06/frontend-users.png"/></noscript><figcaption id="caption-attachment-119666" class="wp-caption-text">How <code>take</code> and <code>skip</code> work, but visually</figcaption></figure>
<p>通过跟踪我们在前端检索了多少用户，我们可以将一个数字传递给<code>skip</code>参数来检索下一个用户的正确数量。当我们实现前端时，这将变得更加清晰。</p>
<p>现在，让我们设置 API 来实现到目前为止讨论的功能。</p>
<h2 id="setting-api-using-nestjs-graphql">使用 NestJS、GraphQL 和 Mongoose 设置 API</h2>
<p>通常，我们会从建立一个新的 NestJS 项目和安装一些依赖项开始。</p>
<p>然而，为了跳过按照教程设置项目的所有痛苦部分，我已经开始用所有必要的库和设置文件建立一个存储库。</p>
<p>存储库是一个包含后端和前端组件的 monorepo。这使得我们可以在一个 repo 中构建 API 和前端，从而加快开发速度。</p>
<p>它依赖于<a href="https://classic.yarnpkg.com/lang/en/docs/workspaces/"> Y </a> <a href="https://classic.yarnpkg.com/lang/en/docs/workspaces/" target="_blank" rel="noopener"> arn 工作空间</a>，所以你需要安装 npm 和 Yarn。</p>
<p>克隆存储库并运行以下命令开始。</p>
<pre class="language-bash hljs">git clone https://github.com/ovieokeh/graphql-nestjs-pagination-guide.git
npm install

cd ../workspaces/frontend
npm install

cd workspaces/backend
npm install

mkdir src &amp;&amp; cd src
</pre>
<p>如果您运行<code>package.json</code>文件中的任何命令，它们很可能会出错。如果您配置了编辑器，也可能会看到<code>eslint</code>错误。这很好。我们将在阅读指南的过程中解决这些问题。</p>
<p>现在您已经安装了所有需要的包，我们可以开始构建 API 的不同组件了。</p>
<h3 id="mongoose-schema-setup">Mongoose 模式设置</h3>
<p>首先，我们需要建立一个查询 GraphQL 的数据库。我决定使用 Mongoose 作为本指南，因为它是目前最流行的数据库 ORM 之一，但是您应该能够将相同的概念应用于其他 ORM。</p>
<p>我们将首先创建一个<code>src/mongoose</code>文件夹和一个<code>src/mongoose/schema.ts</code>文件来保存我们的数据库类型、模型和模式。</p>
<pre>mkdir mongoose
touch mongoose/schema.ts
</pre>
<p>现在，让我们配置我们的<code>schema.ts</code>文件。</p>
<pre class="language-typescript hljs">// src/mongoose/schema.ts

import { Prop, Schema, SchemaFactory } from '@nestjs/mongoose'
import { Document } from 'mongoose'

export type UserDocument = UserModel &amp; Document

@Schema()
export class UserModel {
  @Prop()
  firstName: string

  @Prop()
  lastName: string

  @Prop()
  email: string

  @Prop()
  dateOfBirth: Date
}

export const UserSchema = SchemaFactory.createForClass(UserModel)
</pre>
<ul>
<li><code>UserDocument</code>是表示用户模型和 Mongoose 文档的 TypeScript 类型</li>
<li><code>UserModel</code>表示要存储在数据库中的单个用户</li>
<li><code>UserSchema</code>是从<code>UserModel</code>派生出来的一个猫鼬模式</li>
</ul>
<p>当我们完成 API 的设置时，我们将会用到它们。</p>
<h2 id="nestjs-graphql">nestjs 和 GraphQL</h2>
<p>接下来，我们需要创建一些文件和文件夹，这些将在我们填充内容时解释。</p>
<pre class="language-bash hljs">mkdir users &amp;&amp; cd users

mkdir dto entities
touch dto/fetch-users.input.ts entities/user.entity.ts 
</pre>
<h3><strong>T2<code>dto/fetch-users.input.ts</code></strong></h3>
<hr/>
<pre class="language-typescript hljs">// dto/fetch-users.input.ts

import { Field, Int, ArgsType } from '@nestjs/graphql'
import { Max, Min } from 'class-validator'

@ArgsType()
export class FetchUsersArgs {
  @Field(() =&gt; Int)
  @Min(0)
  skip = 0

  @Field(() =&gt; Int)
  @Min(1)
  @Max(50)
  take = 25
}
</pre>
<p><code>FetchUsersArgs</code>是一个<a href="https://docs.nestjs.com/controllers#request-payloads" target="_blank" rel="noopener">数据传输对象(DTO) </a>，这意味着它描述了一段通过网络发送的数据。在本例中，它描述了参数<code>skip</code>和<code>take</code>，我们将在查询用户时将它们传递给 API。</p>
<p>我们将创建的下一组文件是用户服务、解析器和模块。</p>
<h3>创建<code><strong>users.service.ts</strong></code>文件</h3>
<pre class="language-typescript hljs">touch users.service.ts users.resolver.ts users.module.ts

import { Model } from 'mongoose'
import { Injectable } from '@nestjs/common'
import { InjectModel } from '@nestjs/mongoose'

import { UserDocument, UserModel } from '../../mongoose/schema'
import { FetchUsersArgs } from './dto/fetch-users.input'
import { User } from './entities/user.entity'

@Injectable()
export class UsersService {
  constructor(
    @InjectModel(UserModel.name) private userModel: Model&lt;UserDocument&gt;,
  ) {}

... continues below (1) ...
</pre>
<p>NestJS 使用<code>@InjectModel</code>装饰将我们之前创建的 Mongoose 数据库注入到<code>UsersService</code>类中。这允许我们使用<code>getCount</code>和<code>findAll</code>方法查询数据库。</p>
<pre class="language-typescript hljs">... continues from (1) ...
  async getCount(): Promise&lt;number&gt; {
    const count = await this.userModel.countDocuments()
    return count
  }
... continues below (2) ...
</pre>
<p><code>UsersService.getCount()</code>是一种允许我们获取数据库中用户总数的方法。这个计数将有助于在前端实现编号分页组件。</p>
<pre class="language-typescript hljs">... continues from (2) ...
  async findAll(args: FetchUsersArgs = { skip: 0, take: 5 }): Promise&lt;User[]&gt; {
    const users: User[] = (await this.userModel.find(null, null, {
      limit: args.take,
      skip: args.skip,
    })) as User[]

    return users
  }
}
</pre>
<p><code>UsersService.findAll({ skip, take })</code>是一个获取指定数量的用户(带有<code>take</code>参数)和偏移量(<code>skip</code>)的方法。</p>
<p>这两个方法构成了我们将要构建的分页系统的基础。</p>
<h3>创建<code>users.resolver.ts</code>文件</h3>
<pre class="language-typescript hljs">import { Resolver, Query, Args } from '@nestjs/graphql'

import { User } from './entities/user.entity'
import { UsersService } from './users.service'
import { FetchUsersArgs } from './dto/fetch-users.input'

@Resolver(() =&gt; User)
export class UsersResolver {
  constructor(private readonly usersService: UsersService) {}

  @Query(() =&gt; Number, { name: 'count' })
  async getCount(): Promise&lt;number&gt; {
    return this.usersService.getCount()
  }

  @Query(() =&gt; [User], { name: 'users' })
  async findAll(@Args() args: FetchUsersArgs): Promise&lt;User[]&gt; {
    return this.usersService.findAll(args)
  }
}
</pre>
<p><code>UsersResolver</code>类是用于<code>count</code>和<code>users</code>查询的 GraphQL 解析器。这些方法简单地调用相应的<code>UsersService</code>方法。</p>
<h3>创建<strong> <code>users.module.ts</code> </strong>文件</h3>
<pre class="language-typescript hljs">import { Module } from '@nestjs/common'
import { MongooseModule } from '@nestjs/mongoose'

import { UserModel, UserSchema } from '../../mongoose/schema'
import { UsersService } from './users.service'
import { UsersResolver } from './users.resolver'

@Module({
  imports: [
    MongooseModule.forFeature([{ name: UserModel.name, schema: UserSchema }]),
  ],
  providers: [UsersResolver, UsersService],
})
export class UsersModule {}
</pre>
<p><code>UsersModule</code>类导入 Mongoose 模式并配置解析器和服务类，如上所述。这个模块被传递给主应用程序模块，并允许前面定义的查询。</p>
<h3>创建<code>app.module.ts</code>文件</h3>
<p>最后，为了将一切联系在一起，让我们创建一个<code>app.module.ts</code>文件来使用我们到目前为止定义的所有模块。</p>
<pre class="language-typescript hljs">import { Module } from '@nestjs/common'
import { GraphQLModule } from '@nestjs/graphql'
import { ApolloDriver, ApolloDriverConfig } from '@nestjs/apollo'
import { MongooseModule } from '@nestjs/mongoose'

import { UsersModule } from './users/users.module'
import { ConfigModule, ConfigService } from '@nestjs/config'
import configuration from '../nest.config'

@Module({
  imports: [
    UsersModule,
    ConfigModule.forRoot({
      load: [configuration],
    }),
    MongooseModule.forRootAsync({
      imports: [ConfigModule],
      useFactory: async (configService: ConfigService) =&gt; ({
        uri: configService.get('databaseUrl'),
      }),
      inject: [ConfigService],
    }),
    GraphQLModule.forRoot&lt;ApolloDriverConfig&gt;({
      driver: ApolloDriver,
      autoSchemaFile: 'schema.gql',
      include: [UsersModule],
    }),
  ],
})
export class AppModule {}
</pre>
<p>如果您已经有了使用 GraphQL 和 NestJS 的经验，应该对这些都很熟悉。我们正在导入:</p>
<ul>
<li><code>GraphQLModule</code>用于设置图表 QL</li>
<li><code>MongooseModule</code>为数据库</li>
<li><code>UsersModule</code>对于用户资源</li>
<li><code>ConfigModule</code>用于设置环境变量</li>
</ul>
<p>现在，在添加您的数据库连接 URI 之前，确保设置一个<a href="https://www.mongodb.com/docs/drivers/node/current/fundamentals/connection/" target="_blank" rel="noopener"> MongoDB 数据库</a>并使用<code>.env.example</code>作为向导创建一个<code>.env</code>文件。</p>
<p>此时，您可以通过执行以下操作来测试 API:</p>
<ol>
<li>确保您位于后端目录— <code>cd src/workspaces/backend</code></li>
<li>运行<code>yarn seed</code>植入一些虚假的用户数据</li>
<li>运行<code>yarn start:dev</code>在端口 3000 上启动服务器</li>
<li>在浏览器上导航到<code><a href="http://localhost:3000/graphql" rel="nofollow">http://localhost:3000/graphql</a></code>打开 GraphQL playground，在这里您可以尝试来自“<a href="https://blog.logrocket.com/?p=119650&amp;preview=true#pagination-algorithm" target="_blank" rel="noopener">分页算法</a>”部分的查询，如下所示:<pre class="language-graphql hljs">{   count   users(take: 20, skip: 0) {     firstName     lastName   } }</pre></li>
</ol>
<p>如果你能走到这一步，你就是摇滚明星😎。</p>
<p>这是一个休息一下，再次浏览后端代码的好时机。花点时间理解它，也许可以喝杯果汁(或者茶，如果你喜欢的话)，然后继续前端。</p>
<h2 id="building-react-frontend">构建一个 React 前端来使用 API</h2>
<p>设置好后端之后，我们现在可以创建一个闪亮的 React 前端来实现一个基本的分页系统。</p>
<h2 id="building-components">构建组件</h2>
<p>您可以利用<code>workspaces/frontend</code>文件夹，而不是建立一个全新的前端项目，该文件夹已经安装了一个 React 应用程序，并安装了所有必要的依赖项。</p>
<pre class="language-bash hljs">cd ../frontend/src
</pre>
<p>让我们从自底向上的方法开始构建组件，然后在最后集成所有组件。</p>
<p>我们需要以下组件:</p>
<ul>
<li><code>Users</code> —查询 API 并呈现用户列表</li>
<li><code>Pagination</code> —提供分页逻辑并呈现控件</li>
<li><code>App</code> —呈现用户和分页</li>
<li><code>Index</code> —将应用程序包装在 Apollo 提供程序中，并呈现给 DOM</li>
</ul>
<h3>编写我们的<code><strong>users.tsx</strong></code>组件</h3>
<figure id="attachment_119682" aria-describedby="caption-attachment-119682" class="wp-caption aligncenter"><img data-attachment-id="119682" data-permalink="https://blog.logrocket.com/implementing-pagination-graphql-nestjs/attachment/list-of-names/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/06/list-of-names.png" data-orig-size="599,199" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="list-of-names" data-image-description="" data-image-caption="&lt;p&gt;Just a list of names&lt;/p&gt;&#10;" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/06/list-of-names-300x100.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/06/list-of-names.png" decoding="async" class="size-full wp-image-119682 jetpack-lazy-image" src="../Images/58cd4e41f6b59c48ac7db178deba90c5.png" alt="List of names" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2022/06/list-of-names.png 599w, https://blog.logrocket.com/wp-content/uploads/2022/06/list-of-names-300x100.png 300w" data-lazy-sizes="(max-width: 599px) 100vw, 599px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2022/06/list-of-names.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/06/list-of-names.png"/><noscript><img data-lazy-fallback="1" data-attachment-id="119682" data-permalink="https://blog.logrocket.com/implementing-pagination-graphql-nestjs/attachment/list-of-names/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/06/list-of-names.png" data-orig-size="599,199" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="list-of-names" data-image-description="" data-image-caption="&lt;p&gt;Just a list of names&lt;/p&gt;&#10;" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/06/list-of-names-300x100.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/06/list-of-names.png" decoding="async" loading="lazy" class="size-full wp-image-119682" src="../Images/58cd4e41f6b59c48ac7db178deba90c5.png" alt="List of names" srcset="https://blog.logrocket.com/wp-content/uploads/2022/06/list-of-names.png 599w, https://blog.logrocket.com/wp-content/uploads/2022/06/list-of-names-300x100.png 300w" sizes="(max-width: 599px) 100vw, 599px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/06/list-of-names.png"/></noscript><figcaption id="caption-attachment-119682" class="wp-caption-text">Just a list of names</figcaption></figure>
<p>该组件将使用<code>@apollo/client</code>库查询 GraphQL API，并在查询完成时呈现一个用户列表。</p>
<pre class="language-bash hljs">// ensure you're in /workspaces/frontend/src
touch Users.tsx
</pre>
<p>打开新创建的文件。</p>
<pre class="language-typescript hljs">// Users.tsx
import { gql, useQuery } from '@apollo/client'

const GET_USERS = gql`
  query GetUsers($skip: Int!, $amountToFetch: Int!) {
    users(skip: $skip, take: $amountToFetch) {
      id
      firstName
      lastName
    }
  }
`

type User = {
  id: string
  firstName: string
  lastName: string
}
... continues below (3) ...
</pre>
<p>在文件的顶部，我们从前面提到的<code>@apollo/client</code>库中导入<code>gql</code>和<code>useQuery</code>。</p>
<p>允许我们构建一个 GraphQL 查询，具有动态变量替换等功能。<code>GET_USERS</code>变量是一个查询，它从偏移量<code>$skip</code>请求长度<code>$amountToFetch</code>的<code>users</code>列表。</p>
<p>我们正在查询每个用户的<code>id</code>、<code>firstName</code>和<code>lastName</code>属性。<code>User</code>变量是指定用户结构的 TypeScript 类型。</p>
<pre class="language-typescript hljs">... continues from (3) ...

const Users = (props: { skip?: number; amountToFetch?: number }) =&gt; {
  const { data } = useQuery&lt;{ count: number; users: User[] }&gt;(GET_USERS, {
    variables: props,
  })

  const renderedUsers = data?.users?.map(({ id, firstName, lastName }) =&gt; {
    const name = `${firstName} ${lastName}`
    return (
      &lt;div key={id}&gt;
        &lt;p&gt;{name}&lt;/p&gt;
      &lt;/div&gt;
    )
  })

  return &lt;div className="Users"&gt;{renderedUsers}&lt;/div&gt;
}

export default Users
</pre>
<p>最后，我们有一个接受两个道具的<code>Users</code>组件:<code>skip</code>和<code>amountToFetch</code>。</p>
<p>它立即启动对 API 的查询<code>GET_USERS</code>查询，并将<code>props</code>作为<code>variables</code>传递。</p>
<p>然后，我们映射用户数组(使用三元运算符，以防数据尚未准备好),并返回包含每个用户姓名的<code>div</code>。</p>
<p>最后，return 语句完成了这个组件。</p>
<h3><code><strong>pagination.tsx</strong></code>组件</h3>
<figure id="attachment_119686" aria-describedby="caption-attachment-119686" class="wp-caption aligncenter"><img data-attachment-id="119686" data-permalink="https://blog.logrocket.com/implementing-pagination-graphql-nestjs/attachment/pagination-component/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/06/pagination-component.png" data-orig-size="716,95" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="pagination-component" data-image-description="" data-image-caption="&lt;p&gt;The glorious pagination component&lt;/p&gt;&#10;" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/06/pagination-component-300x40.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/06/pagination-component.png" decoding="async" class="size-full wp-image-119686 jetpack-lazy-image" src="../Images/4c52515de0f73f54858be27d1e62a7d7.png" alt="Pagination component" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2022/06/pagination-component.png 716w, https://blog.logrocket.com/wp-content/uploads/2022/06/pagination-component-300x40.png 300w" data-lazy-sizes="(max-width: 716px) 100vw, 716px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2022/06/pagination-component.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/06/pagination-component.png"/><noscript><img data-lazy-fallback="1" data-attachment-id="119686" data-permalink="https://blog.logrocket.com/implementing-pagination-graphql-nestjs/attachment/pagination-component/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/06/pagination-component.png" data-orig-size="716,95" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="pagination-component" data-image-description="" data-image-caption="&lt;p&gt;The glorious pagination component&lt;/p&gt;&#10;" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/06/pagination-component-300x40.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/06/pagination-component.png" decoding="async" loading="lazy" class="size-full wp-image-119686" src="../Images/4c52515de0f73f54858be27d1e62a7d7.png" alt="Pagination component" srcset="https://blog.logrocket.com/wp-content/uploads/2022/06/pagination-component.png 716w, https://blog.logrocket.com/wp-content/uploads/2022/06/pagination-component-300x40.png 300w" sizes="(max-width: 716px) 100vw, 716px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/06/pagination-component.png"/></noscript><figcaption id="caption-attachment-119686" class="wp-caption-text">The glorious pagination component</figcaption></figure>
<p>希望你熟悉 React 中的<code>renderProps</code>技术。该组件利用<code>renderProps</code>来呈现带有道具的组件，以及呈现选择输入和一些按钮。</p>
<p>创建一个新的<code>Pagination.tsx</code>文件并打开它。</p>
<pre class="language-bash hljs">// ensure you're in /workspaces/frontend/src
touch Pagination.tsx
</pre>
<p>我们首先从 React 导入一些类型和实用程序，并设置一些状态变量来跟踪分页组件的当前状态。</p>
<pre class="language-typescript hljs">import { ChangeEvent, cloneElement, FunctionComponentElement, useState } from 'react'

const Pagination = ({ count, render }: {
  count: number
  render: FunctionComponentElement&lt;{ skip: number; amountToFetch: number }&gt;
}) =&gt; {
  const [step, setStep] = useState(0)
  const [amountToFetch, setAmountToFetch] = useState(10)

... continues below (4) ...
</pre>
<p><code>Pagination</code>组件接受两个道具:</p>
<ol>
<li><code>count</code> —数据库中的用户总数。用于计算在 UI 中呈现的步骤数</li>
<li><code>render</code> —将从<code>Pagination</code>组件接收额外道具的 React 组件</li>
</ol>
<p>它还有两个状态变量:</p>
<ol>
<li><code>step</code> —正在渲染的当前步骤</li>
<li><code>amountToFetch</code> —在任何给定时间获取的用户数量</li>
</ol>
<pre class="language-typescript hljs">... continues from (4) ...

const steps = count ? Math.ceil(count / amountToFetch) : 0
const renderedSteps = new Array(steps).fill(0).map((num, index) =&gt; (
  &lt;button
    data-is-active={index === step}
    key={index}
    type="button"
    onClick={() =&gt; setStep(index)}
  &gt;
    {index + 1}
  &lt;/button&gt;
))

const renderWithProps = cloneElement(render, {
  skip: step * amountToFetch,
  amountToFetch,
})

... continues below (5) ...</pre>
<p>接下来，定义三个变量:</p>
<ol>
<li><code>steps</code> —这执行一些简单的算术来获得渲染的步骤数<br/> <em> &gt;如果 count = 10 个用户，amountToFetch = 5</em><br/><em>&gt;步骤数= 2/&lt;1 2&gt;</em><br/><em>&gt;如果 count = 10 个用户，amountToFetch = 2</em><em>&gt;步骤数= 5/&lt;1 2 3 4 5&gt;</em></li>
<li><code>renderedSteps</code> —利用<code>steps</code>呈现来自<code>1..steps</code>的按钮数组。每个按钮都有一个更新<code>step</code>状态的<code>onClick</code>处理器</li>
<li><code>renderWithProps</code> —克隆在<code>render</code>道具中传递的组件，并向其添加两个新道具:<pre class="language-typescript hljs"> ... continues from (5) ...  return ( &lt;&gt; {renderWithProps}  &lt;select     name="amount to fetch"     id="amountToFetch"     value={amountToFetch}     onChange={(e: ChangeEvent&lt;HTMLSelectElement&gt;) =&gt; {       const newAmount = +e.target.value       setAmountToFetch(newAmount)       setStep(0)     }}   &gt;     &lt;option value={10}&gt;10&lt;/option&gt;     &lt;option value={20}&gt;20&lt;/option&gt;     &lt;option value={50}&gt;50&lt;/option&gt;   &lt;/select&gt;   &lt;button     type="button"     disabled={step === 0}     onClick={() =&gt; setStep((prevstep) =&gt; prevstep - 1)}   &gt;     {'&lt;'}   &lt;/button&gt;    {renderedSteps}    &lt;button     type="button"     disabled={(step + 1) * amountToFetch &gt; count}     onClick={() =&gt; setStep((prevstep) =&gt; prevstep + 1)}   &gt;     {'&gt;'}   &lt;/button&gt; &lt;/&gt; ) }  export default Pagination</pre><ol>
<li><code>skip</code> —查询用户时跳过多少</li>
<li><code>amountToFetch</code> —要检索的用户数量</li>
</ol>
</li>
</ol>
<p>最后，我们向 DOM 呈现五个元素:</p>
<ol>
<li><code>renderWithProps</code>:添加道具克隆的<code>render</code>组件</li>
<li><code>select</code>:控制<code>amountToFetch</code>状态变量，允许用户改变每页取多少用户。我们目前已经对 20、50 和 100 这三个步骤进行了硬编码。<code>onChange</code>处理器更新<code>amountToFetch</code>状态并重置<code>step</code></li>
<li><code>button</code>:允许用户后退一步</li>
<li><code>renderedSteps</code>:允许切换到相应步骤的按钮列表</li>
<li><code>button</code>:允许用户向前移动一步</li>
</ol>
<p>再次，花一些时间呼吸，放松，理解到目前为止所涵盖的概念。散步可能不是一个坏主意😉</p>
<h3 id="react-apollo">反应和阿波罗</h3>
<p>我们现在离终点线很近了！剩下的工作就是将<code>Users</code>组件与<code>Pagination</code>组件连接起来并进行渲染。</p>
<p>创建一个<code>App.tsx</code>文件并打开它。</p>
<pre class="language-bash hljs">// ensure you're in /workspaces/frontend/src
touch App.tsx
</pre>
<p>以下是我们的文件内容:</p>
<pre class="language-typescript hljs">import { gql, useQuery } from '@apollo/client'

import Users from './Users'
import Pagination from './Pagination'

import './App.css'

const GET_USERS_COUNT = gql`
  query GetUsersCount {
    count
  }
`

function App() {
  const { data } = useQuery&lt;{ count: number }&gt;(GET_USERS_COUNT)

  return (
    &lt;div className="App"&gt;
      &lt;Pagination count={data?.count || 0} render={(&lt;Users /&gt;) as any} /&gt;
    &lt;/div&gt;
  )
}

export default App
</pre>
<p>这是一个相对简单的组件。我们进口:</p>
<ul>
<li><code>gql</code>和<code>useQuery</code>我们将在下面定义一个查询</li>
<li><code>Users</code>和<code>Pagination</code>组件</li>
<li>项目附带的 CSS 样式表</li>
</ul>
<p>然后我们定义了<code>GET_USERS_COUNT</code>查询，它简单地请求数据库中的用户总数。</p>
<p><code>App</code>函数请求<code>GET_USERS_COUNT</code>查询，并将结果存储在<code>data</code>变量中。<br/>在<code>return</code>语句中，我们在一个 div 中呈现了<code>Pagination</code>组件，并且—</p>
<ul>
<li>将<code>data.count</code>变量作为<code>count</code>属性传递</li>
<li>将<code>Users</code>组件作为<code>render</code>道具传递</li>
</ul>
<p>只剩下最后一部分，您将能够在浏览器中测试您的结果。咻！</p>
<p>现在，创建一个<code>index.tsx</code>文件并打开它。</p>
<pre class="language-bash hljs">// ensure you're in /workspaces/frontend/src
touch index.tsx
</pre>
<p>以下是我们的文件内容:</p>
<pre class="language-typescript hljs">import React from 'react'
import ReactDOM from 'react-dom/client'
import { ApolloClient, InMemoryCache, ApolloProvider } from '@apollo/client'

import App from './App'

import './index.css'

const client = new ApolloClient({
  uri: process.env.REACT_APP_API_GRAPHQL_URL,
  cache: new InMemoryCache(),
})

const root = ReactDOM.createRoot(document.getElementById('root') as HTMLElement)

root.render(
  &lt;React.StrictMode&gt;
    &lt;ApolloProvider client={client}&gt;
      &lt;App /&gt;
    &lt;/ApolloProvider&gt;
  &lt;/React.StrictMode&gt;
)
</pre>
<p>这个文件中的大部分内容现在应该很熟悉了。有趣的是，我们正在创建一个新的 Apollo 客户机来连接我们的 API，并在<code>root.render</code>语句中将其传递给 Apollo 提供者。</p>
<p>注意:确保使用<code>.env.example</code>作为向导创建一个<code>.env</code>文件，并添加您的 API URL(很可能是<code>http:localhost:3000/graphql</code>)。</p>
<p>此时，您现在可以在浏览器中启动前端，并惊叹您的创造。</p>
<ul>
<li>确保后端正在运行(<code>yarn start:dev</code>)</li>
<li>确保您在<code>workspaces/frontend</code>并运行<code>yarn start</code></li>
<li>导航到<a href="http://localhost:3001" target="_blank" rel="noopener"> http://localhost:3001 </a></li>
</ul>
<figure id="attachment_119695" aria-describedby="caption-attachment-119695" class="wp-caption aligncenter"><img data-attachment-id="119695" data-permalink="https://blog.logrocket.com/implementing-pagination-graphql-nestjs/attachment/frontend-pagination-creation/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/06/frontend-pagination-creation.png" data-orig-size="737,452" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="frontend-pagination-creation" data-image-description="" data-image-caption="&lt;p&gt;Tada!&lt;/p&gt;&#10;" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/06/frontend-pagination-creation-300x184.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/06/frontend-pagination-creation.png" decoding="async" class="size-full wp-image-119695 jetpack-lazy-image" src="../Images/f2a84d5ed86146f92e03d6f932ae2f70.png" alt="End result is paginated list of users" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2022/06/frontend-pagination-creation.png 737w, https://blog.logrocket.com/wp-content/uploads/2022/06/frontend-pagination-creation-300x184.png 300w" data-lazy-sizes="(max-width: 737px) 100vw, 737px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2022/06/frontend-pagination-creation.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/06/frontend-pagination-creation.png"/><noscript><img data-lazy-fallback="1" data-attachment-id="119695" data-permalink="https://blog.logrocket.com/implementing-pagination-graphql-nestjs/attachment/frontend-pagination-creation/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/06/frontend-pagination-creation.png" data-orig-size="737,452" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="frontend-pagination-creation" data-image-description="" data-image-caption="&lt;p&gt;Tada!&lt;/p&gt;&#10;" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/06/frontend-pagination-creation-300x184.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/06/frontend-pagination-creation.png" decoding="async" loading="lazy" class="size-full wp-image-119695" src="../Images/f2a84d5ed86146f92e03d6f932ae2f70.png" alt="End result is paginated list of users" srcset="https://blog.logrocket.com/wp-content/uploads/2022/06/frontend-pagination-creation.png 737w, https://blog.logrocket.com/wp-content/uploads/2022/06/frontend-pagination-creation-300x184.png 300w" sizes="(max-width: 737px) 100vw, 737px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/06/frontend-pagination-creation.png"/></noscript><figcaption id="caption-attachment-119695" class="wp-caption-text">Tada!</figcaption></figure>
<h2 id="conclusion">结论</h2>
<p>继续与分页控件进行交互。也许你可以找到一种方法来截断中间部分，甚至添加一些漂亮的造型；这是一个基本的分页系统，您可以根据任何数据类型或场景进行定制。</p>
<p>你可以在我的 GitHub 上找到这篇文章的源代码。</p>
<p>如果你设法坚持到最后，你应该受到表扬。我知道它有时有点晦涩，但希望这对你有用。</p><div class="code-block code-block-24">
<div class="blog-plug inline-plug graphql-plug"><h2>监控生产中失败和缓慢的 GraphQL 请求</h2><p>虽然 GraphQL 有一些调试请求和响应的特性，但确保 GraphQL 可靠地为您的生产应用程序提供资源是一件比较困难的事情。如果您对确保对后端或第三方服务的网络请求成功感兴趣，</p><a href="https://lp.logrocket.com/blg/graphql-signup" target="_blank">try LogRocket</a><p>.</p><a class="signup" href="https://lp.logrocket.com/blg/graphql-signup" target="_blank" rel="noopener noreferrer"><img src="../Images/432a3823c85b3fb72a206e6236a29f48.png" data-lazy-src="https://files.readme.io/69aa835-Image_2019-11-09_at_1.28.05_PM.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" class=" jetpack-lazy-image" data-original-src="https://files.readme.io/69aa835-Image_2019-11-09_at_1.28.05_PM.png"/><noscript><img data-lazy-fallback="1" src="../Images/432a3823c85b3fb72a206e6236a29f48.png" data-original-src="https://files.readme.io/69aa835-Image_2019-11-09_at_1.28.05_PM.png"/></noscript><img class="alignnone size-full wp-image-46 jetpack-lazy-image" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/><noscript><img data-lazy-fallback="1" class="alignnone size-full wp-image-46" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/></noscript></a><a href="https://lp.logrocket.com/blg/graphql-signup" target="_blank" rel="noopener noreferrer">https://logrocket.com/signup/</a><p>LogRocket 就像是网络和移动应用的 DVR，记录下你网站上发生的每一件事。您可以汇总并报告有问题的 GraphQL 请求，以快速了解根本原因，而不是猜测问题发生的原因。此外，您可以跟踪 Apollo 客户机状态并检查 GraphQL 查询的键值对。</p><p>LogRocket 检测您的应用程序以记录基线性能计时，如页面加载时间、到达第一个字节的时间、慢速网络请求，还记录 Redux、NgRx 和 Vuex 操作/状态。</p><a class="signup" href="https://lp.logrocket.com/blg/graphql-signup" target="_blank" rel="noopener noreferrer">Start monitoring for free</a><p>.</p></div>


</div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
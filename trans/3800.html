<html>
<head>
<title>XML parsing in Swift: Tutorial with examples </title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>Swift中的XML解析:示例教程</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/xml-parsing-swift/#0001-01-01">https://blog.logrocket.com/xml-parsing-swift/#0001-01-01</a></blockquote><div><article class="article-post">
<p>尽管与JSON文件格式相比，XML文件格式听起来已经过时了，但是XML仍然非常活跃。JSON在web开发中可能更受欢迎，但是XML有许多JSON所没有的特性，比如名称空间支持，它有助于避免元素和属性的名称冲突。XML还有一种模式，可以强制XML文档遵守某种标准。</p>
<p>您不需要寻找第三方库来使用Swift操作XML文件。Swift标准库拥有满足您所有XML需求的<code>XMLParser</code>。</p>
<p>向前跳:</p>

<h2 id="setting-up-xml-parser-xml-parser-delegate">设置<code>XMLParser</code>和<code>XMLParserDelegate</code></h2>
<p>在XCode中创建一个游乐场项目，命名为<code>XMLParsingPlayground</code>。参考<a href="https://blog.logrocket.com/getting-started-regexbuilder-swift/#setting-up-swift-playground-xcode">这篇文章</a>了解更多关于这个步骤的信息。</p>
<p>为了解析XML数据，您需要将XML字符串转换为<code>Data</code>。添加以下代码:</p>
<pre class="language-swift hljs">let xmlContent =
"""
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;root&gt;
    &lt;article&gt;
        &lt;title&gt;Getting Started with Swift&lt;/title&gt;
    &lt;/article&gt;
    &lt;article&gt;
        &lt;title&gt;How to Parse XML with Rust&lt;/title&gt;
    &lt;/article&gt;
&lt;/root&gt;
""";

let xmlData = Data(xmlContent.utf8)
</pre>
<p>在上面的代码中，您用一个XML字符串初始化了一个<code>Data</code>实例。现在，您需要用这个<code>Data</code>实例初始化一个<code>XMLParser</code>实例:</p>
<pre class="language-swift hljs">let xmlParser = XMLParser(data: xmlData)
</pre>
<p><code>XMLParser</code>将解析逻辑委托给它的委托类。你需要实现这个继承了<code>NSObject</code>和<code>XMLParserDelegate</code>的类。添加以下代码以创建类及其实例:</p>
<pre class="language-swift hljs">class Parser1 : NSObject, XMLParserDelegate {

    func parserDidStartDocument(_ parser: XMLParser) {
        print("Start of the document")
        print("Line number: \(parser.lineNumber)")
    }

    func parserDidEndDocument(_ parser: XMLParser) {
        print("End of the document")
        print("Line number: \(parser.lineNumber)")
    }

}
let parser1 = Parser1()
</pre>
<p>在委托类中，当您在解析过程中点击文档的开头和结尾时，您设置了一个逻辑来做一些事情。如果您遇到这些问题，您将在解析器当前所在的位置打印一些字符串和一个行号。两种方法都在参数中接受一个<code>XMLParser</code>实例。委托类中的许多方法在其参数中接受一个<code>XMLParser</code>实例。</p>
<p>一旦完成了解析器委托实例，就必须将其设置为<code>XMLParser</code>实例的委托类:</p>
<pre class="language-swift hljs">xmlParser.delegate = parser1
</pre>
<p>最后一步是解析它:</p>
<pre class="language-swift hljs">xmlParser.parse()
</pre>
<p>如果您编译并运行了该程序，您应该得到以下输出:</p>
<pre class="language-swift hljs">Start of the document
Line number: 1
End of the document
Line number: 9
</pre>
<p>上面的代码意味着当解析器遇到<code>start of the document</code>的事件时，它在第1行。然后是文件的内容。它穿越了元素，但是因为你没有实现方法来处理它，所以什么也没发生。最后，当它遇到<code>end of the document</code>的事件时，它通过您已经实现的<code>parserDidEndDocument</code>方法通知我们。</p>
<h2 id="handling-elements-xml-data">处理XML数据的元素</h2>
<p>解析XML时，需要实现处理感兴趣的节点或事件的方法。如果您对注释感兴趣，那么当解析器遇到XML数据中的注释时，您需要实现一个方法。</p>
<p>现在，您希望实现一些方法，用于解析器何时遇到像<code>article</code>和<code>title</code>这样的元素。您需要实现的方法是带有以下签名的<code>parser</code>方法:</p>
<pre class="language-swift hljs">func parser(
        _ parser: XMLParser,
        didStartElement elementName: String,
        namespaceURI: String?,
        qualifiedName qName: String?,
        attributes attributeDict: [String : String] = [:]
    )
</pre>
<p>创建新的解析器委托类:</p>
<pre class="language-swift hljs">class Parser2 : NSObject, XMLParserDelegate {

    func parser(
        _ parser: XMLParser,
        didStartElement elementName: String,
        namespaceURI: String?,
        qualifiedName qName: String?,
        attributes attributeDict: [String : String] = [:]
    ) {
        print(elementName)
    }

}
</pre>
<p>在新的委托类中，您没有实现<code>parserDidStartDocument</code>和<code>parserDidEndDocument</code>，因为您只关注解析元素。</p>
<p>像往常一样，您需要设置一个新的<code>XMLParser</code>实例的委托类实例，并再次调用<code>parse</code>方法:</p>
<pre class="language-swift hljs">let parser2 = Parser2()
let xmlParser2 = XMLParser(data: xmlData)
xmlParser2.delegate = parser2

xmlParser2.parse()
</pre>
<p>编译并运行程序，它将打印元素的名称:</p>
<pre class="language-swift hljs">root
article
title
article
title
</pre>
<p>如你所见，有五个元素。如果你想区分<code>title</code>元素，因为它们有两个，你需要添加更多的逻辑。其中一个例子是跟踪解析遇到了多少个<code>article</code>元素。</p>
<p>创建另一个委托类:</p>
<pre class="language-swift hljs">class Parser3 : NSObject, XMLParserDelegate {

    var articleNth = 0

    func parser(
        _ parser: XMLParser,
        didStartElement elementName: String,
        namespaceURI: String?,
        qualifiedName qName: String?,
        attributes attributeDict: [String : String] = [:]
    ) {
        if (elementName=="article") {
            articleNth += 1
        } else if (elementName=="title") {
            print("'\(elementName)' in the article element number \(articleNth)")
        }
    }

}
</pre>
<p>这一次，你追踪了你遇到了多少个<code>article</code>元素，这样当你遇到<code>title</code>元素时，你就知道你在哪个<code>article</code>元素中了。</p>
<p>创建一个新的<code>XMLParser</code>实例，并将委托类设置为<code>Parser3</code>:</p>
<pre class="language-swift hljs">let parser3 = Parser3()
let xmlParser3 = XMLParser(data: xmlData)
xmlParser3.delegate = parser3

xmlParser3.parse()
</pre>
<p>如果您编译并运行该程序，您应该会看到以下输出:</p>
<pre class="language-swift hljs">'title' in the article element number 1
'title' in the article element number 2
</pre>
<h2 id="handling-attributes-elements-xml-data">处理XML数据元素的属性</h2>
<p>XML数据中的元素也可以有属性。您可能想要查询属性。您最近执行的方法有另一个引用属性的参数。但是首先，您必须创建其他XML数据，因为这些数据现在还没有属性:</p>
<pre class="language-swift hljs">let xmlContent_attributes =
"""
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;root&gt;
    &lt;article id="1" tag="swift"&gt;
        &lt;title&gt;Getting Started with Swift&lt;/title&gt;
    &lt;/article&gt;
    &lt;article id="2" tag="rust"&gt;
        &lt;title&gt;How to Parse XML with Rust&lt;/title&gt;
    &lt;/article&gt;
&lt;/root&gt;
""";
let xmlData_attributes = Data(xmlContent_attributes.utf8)
</pre>
<p>这一次，您在<code>article</code>元素上添加了属性。属性是<code>id</code>和<code>tag</code>。</p>
<p>现在，您必须创建委托类来处理属性:</p>
<pre class="language-swift hljs">class Parser4 : NSObject, XMLParserDelegate {

    func parser(
        _ parser: XMLParser,
        didStartElement elementName: String,
        namespaceURI: String?,
        qualifiedName qName: String?,
        attributes attributeDict: [String : String] = [:]
    ) {
        for (attr_key, attr_val) in attributeDict {
            print("Key: \(attr_key), value: \(attr_val)")
        }
    }

}
</pre>
<p>该方法与您之前实现的方法相同。但是这一次，你没有忽略<code>attributeDict</code>这个论点。</p>
<p>我们还没完呢！现在，您必须创建一个使用这个委托类实例的新的<code>XMLParser</code>实例:</p>
<pre class="language-swift hljs">let parser4 = Parser4()
let xmlParser4 = XMLParser(data: xmlData_attributes)
xmlParser4.delegate = parser4

xmlParser4.parse()
</pre>
<p>如果您编译并运行该程序，您会看到以下属性:</p>
<pre class="language-swift hljs">Key: id, value: 1
Key: tag, value: swift
Key: id, value: 2
Key: tag, value: rust
</pre>
<h2 id="handling-namespace-xml-data">处理XML数据中的命名空间</h2>
<p>现在，在<code>parser</code>方法中还有两个参数没有处理。他们是<code>namespaceURI</code>和<code>qName</code>，两者是有联系的。</p>
<p>首先，需要将名称空间添加到XML数据中:</p>
<pre class="language-swift hljs">let xmlContent_namespace =
"""
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;root xmlns:t="http://logrocket.com/tech" xmlns:m="http://logrocket.com/marketing"&gt;
    &lt;t:article&gt;
        &lt;t:title&gt;Getting Started with Swift&lt;/t:title&gt;
    &lt;/t:article&gt;
    &lt;m:article&gt;
        &lt;m:title&gt;How to Parse XML with Rust&lt;/m:title&gt;
    &lt;/m:article&gt;
&lt;/root&gt;
""";

let xmlData_namespace = Data(xmlContent_namespace.utf8)
</pre>
<p>这个XML数据中有两个名称空间:<code><a href="http://logrocket.com/tech" rel="nofollow">http://logrocket.com/tech</a></code>和<code><a href="http://logrocket.com/marketing" rel="nofollow">http://logrocket.com/marketing</a></code>。根元素中的元素使用名称空间。已经不是<code>article</code>了，而是<code>t:article</code>或者<code>m:article</code>。</p>
<p><code>t</code>是指<code>xmlns:t</code>，其值为<code><a href="http://logrocket.com/tech" rel="nofollow">http://logrocket.com/tech</a></code>。<code>m</code>是指<code>xmlns:m</code>，其值为<code><a href="http://logrocket.com/marketing" rel="nofollow">http://logrocket.com/marketing</a></code>。</p>
<p>然后，您需要创建委托类来处理名称空间:</p>
<pre class="language-swift hljs">class Parser5 : NSObject, XMLParserDelegate {

    func parser(
        _ parser: XMLParser,
        didStartElement elementName: String,
        namespaceURI: String?,
        qualifiedName qName: String?,
        attributes attributeDict: [String : String] = [:]
    ) {
        print("Namespace URI: \(namespaceURI!), qualified name: \(qName!)")
    }

}
</pre>
<p>要获得名称空间URI，例如，<code><a href="http://logrocket.com/tech" rel="nofollow">http://logrocket.com/tech</a></code>，可以使用<code>namespaceURI</code>参数。要获得限定名，例如，<code>t:article</code>，可以使用<code>qName</code>参数。</p>
<p>下一步很重要。创建一个新的<code>XMLParser</code>实例来处理名称空间:</p>
<pre class="language-swift hljs">let parser5 = Parser5()
let xmlParser5 = XMLParser(data: xmlData_namespace)
xmlParser5.delegate = parser5
xmlParser5.shouldProcessNamespaces = true

xmlParser5.parse()
</pre>
<p>在编译和运行程序之前，注意有一行告诉解析器处理名称空间。要在XML数据中启用名称空间，需要将解析器的<code>shouldProcessNamespaces</code>属性设置为<code>true</code>。否则，命名空间将被忽略。</p>
<p>编译并运行程序。然后，您将获得名称空间URIs和限定名:</p>
<pre class="language-swift hljs">Namespace URI: , qualified name: root
Namespace URI: http://logrocket.com/tech, qualified name: t:article
Namespace URI: http://logrocket.com/tech, qualified name: t:title
Namespace URI: http://logrocket.com/marketing, qualified name: m:article
Namespace URI: http://logrocket.com/marketing, qualified name: m:title
</pre>
<h2 id="getting-text-content-parsing-xml-data">解析XML数据时获取文本内容</h2>
<p>现在，是时候从XML数据中获取文本内容了。您需要实现的方法是带有以下签名的<code>parser</code>方法:</p>
<pre class="language-swift hljs">    func parser(
        _ parser: XMLParser,
        foundCharacters string: String
    )
</pre>
<p>添加以下XML数据:</p>
<pre class="language-swift hljs">let xmlContent_text =
"""
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;root&gt;
    &lt;article&gt;
        &lt;title&gt;Getting Started with Swift&lt;/title&gt;
        &lt;published&gt;true&lt;/published&gt;
    &lt;/article&gt;
    &lt;article&gt;
        &lt;title&gt;How to Parse XML with Rust&lt;/title&gt;
        &lt;published&gt;false&lt;/published&gt;
    &lt;/article&gt;
&lt;/root&gt;
""";
let xmlData_text = Data(xmlContent_text.utf8)
</pre>
<p>然后，您需要实现具有处理文本内容的方法的委托类:</p>
<pre class="language-swift hljs">class Parser6 : NSObject, XMLParserDelegate {

    func parser(
        _ parser: XMLParser,
        foundCharacters string: String
    ) {
        if (string.trimmingCharacters(in: .whitespacesAndNewlines) != "") {
            print(string)
        }
    }

}
</pre>
<p>您只对包含一些字符的文本内容感兴趣。如果没有实现过滤器，就会产生大量空白文本内容。文本上下文被定义为元素节点之间的文本。这也包括<code>article</code>元素和<code>title</code>元素之间的空白文本:</p>
<pre class="language-swift hljs">    &lt;article&gt;
        &lt;title&gt;How to Parse XML with Rust&lt;/title&gt;
</pre>
<p>不仅仅是空格，在<code>article</code>和<code>title</code>之间还有一条新的线。这就是为什么你先修剪它，然后检查它是否是一个空字符串。</p>
<p>最后，创建一个<code>XMLParser</code>实例来处理文本内容:</p>
<pre class="language-swift hljs">let parser6 = Parser6()
let xmlParser6 = XMLParser(data: xmlData_text)
xmlParser6.delegate = parser6

xmlParser6.parse()
</pre>
<p>如果您编译并运行了该程序，您应该得到以下文本内容:</p>
<pre class="language-swift hljs">Getting Started with Swift
true
How to Parse XML with Rust
false
</pre>
<h2 id="handling-errors-parsing-xml-data">解析XML数据时处理错误</h2>
<p>生活并不理想。有时您会得到不完美的XML数据，并且数据被损坏。但是不用担心！您可以使用带有以下签名的<code>parser</code>方法来处理错误:</p>
<pre class="language-swift hljs">    func parser(
        _ parser: XMLParser,
        parseErrorOccurred parseError: Error
    )
</pre>
<p>但是首先，您需要编写损坏的XML数据:</p>
<pre class="language-swift hljs">let xmlContent_corrupted =
"""
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;root&gt;
    &lt;article&gt;
        &lt;title&gt;Getting Started with Swift&lt;/title&gt;
    &lt;/article&gt;
    &lt;article&gt;
        &lt;title&gt;How to Parse XML with Rust
    &lt;/article&gt;
&lt;/root&gt;
""";
let xmlData_corrupted = Data(xmlContent_corrupted.utf8)
</pre>
<p>请注意，这里缺少一个结束标签<code>title</code>。</p>
<p>然后，创建一个委托类来处理错误:</p>
<pre class="language-swift hljs">class Parser7 : NSObject, XMLParserDelegate {

    func parser(
        _ parser: XMLParser,
        parseErrorOccurred parseError: Error
    ) {
        print(parseError)
    }

}
</pre>
<p>这个方法给出了包含错误信息的参数<code>parseError</code>。在这种情况下，您打印了错误本身。</p>
<p>错误看起来像什么？您需要创建<code>XMLParser</code>实例来获取这个委托类:</p>
<pre class="language-swift hljs">let parser7 = Parser7()
let xmlParser7 = XMLParser(data: xmlData_corrupted)
xmlParser7.delegate = parser7

xmlParser7.parse()
</pre>
<p>如果您编译并运行了该程序，您应该会看到以下错误:</p>
<pre class="language-swift hljs">Error Domain=NSXMLParserErrorDomain Code=76 "(null)" UserInfo={NSXMLParserErrorColumn=15, NSXMLParserErrorLineNumber=8, NSXMLParserErrorMessage=Opening and ending tag mismatch: title line 7 and article
}
</pre>
<p>您得到了发生错误的行号和列号。您还收到了错误消息，告诉您开始和结束标记不匹配。</p>
<h2 id="conclusion">结论</h2>
<p>在本文中，您了解了如何解析XML数据。您从创建<code>XMLParser</code>实例开始。然后您创建了一个委托的<code>XMLParserDelegate</code>类来处理解析过程的逻辑。在那里，您处理了元素、属性和文本内容。您还管理了解析过程中的一个错误，并将解析器配置为处理名称空间。</p><div class="code-block code-block-54">
<hr/>
<h3>更多来自LogRocket的精彩文章:</h3>

<hr/></div>
<p>本文只是触及了Swift中XML解析的皮毛。您可以在这里的文档中了解更多关于XML解析API的信息。本文的代码可以在这个<a href="https://github.com/arjunaskykok/XML-parsing-in-swift"> GitHub仓库中找到。</a></p>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

 </div>    
</body>
</html>
<html>
<head>
<title>Create a typewriter effect for code blocks with React - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>使用 React - LogRocket 博客为代码块创建打字机效果</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/code-block-typewriter-effect-react/#0001-01-01">https://blog.logrocket.com/code-block-typewriter-effect-react/#0001-01-01</a></blockquote><div><article class="article-post">
<p>使用打字机效果，单词一次显示一个字母，而不是一次显示所有字母，使文本看起来像是实时书写的。你可以在<a href="https://codepen.io/"> Codepen 的</a>登录页面上找到一个代码块打字机效果的例子，它使用语法高亮，一种特殊的颜色格式，以代码的形式轻松显示书面文本。</p>
<p>在本文中，我们将学习如何使用 React 从头开始构建一个类似的代码块打字机效果。我们还将演示另一种方法，它使用预先存在的打字机包。要跟随本教程，您需要 React 的基本知识。我们将讨论以下内容:</p>

<p>你可以在这个 GitHub repo 找到这个教程<a href="https://github.com/Victory-ET/Code-TypeWriter-Effect">的完整源代码。我们开始吧！</a></p>
<h2 id="installing-dependencies">安装依赖项</h2>
<p>如果您还没有安装 React，请在系统中导航到您的项目目录，打开一个命令行窗口，并在其中运行以下 bash 脚本:</p>
<pre class="language-bash hljs">npx create-react-app typewriter
</pre>
<p>上面的命令创建了一个名为<code>typewriter</code>的 React 项目文件夹，其中包含构建我们的应用程序所需的所有依赖项。为了让我们的应用程序更加简单，我们将使用 Tailwind CSS 。您可以通过在 CLI 中运行以下命令来安装 Tailwind CSS:</p>
<pre class="language-bash hljs">npm install -D tailwindcss postcss autoprefixer
npx tailwindcss init -p
</pre>
<p>安装完成后，修改<code>tailwind.config.js</code>文件以支持<code>jsx</code>元素，如下所示:</p>
<pre class="language-javascript hljs">/** @type {import('tailwindcss').Config} */
module.exports = {
  content: [
    "./src/**/*.{js,jsx,ts,tsx}",
  ],
  theme: {
    extend: {},
  },
  plugins: [],
}
</pre>
<p>最后，将下面的 Tailwind CSS 指令添加到<code>index.css</code>的顶层:</p>
<pre class="language-css hljs">@tailwind base;
@tailwind components;
@tailwind utilities;
</pre>
<h2 id="building-typewriter-effect">构建打字机效果</h2>
<p>我们的打字机效果将由两个主要部分组成，一个用来保存我们想要动画的文本的容器和一个模仿打字机的闪烁光标。</p>
<h3 id="typewriter-display-area">打字机显示区</h3>
<p>首先，在我们的<code>App.js</code>文件中，我们将为打字机效果构建显示窗口:</p>
<pre class="language-javascript hljs">import "./App.css";
import {React, useState, useEffect} from "react";

function App() {
  const [text1, setText1] = useState("const sayHello = () = {");
  const [text2, setText2] = useState("Console.log('hello')");
  const [text3, setText3] = useState("//This prints out Hello World");
  return (
    &lt;div className=" flex h-screen justify-center items-center"&gt;
      &lt;div className=" h-1/2 w-1/2 bg-black rounded-md flex items-center pl-6"&gt;
        {/* type writer display */}
        &lt;span&gt;
          &lt;div className=" text-white text-2xl blinking-cursor"&gt;{text1}&lt;/div&gt;
          &lt;div className=" text-white text-2xl blinking-cursor"&gt;{text2}&lt;/div&gt;
          &lt;div className=" text-white text-2xl blinking-cursor"&gt;{text3}&lt;/div&gt;
          &lt;div className=" text-white text-2xl blinking-cursor"&gt;{`}`}&lt;/div&gt;
        &lt;/span&gt;
      &lt;/div&gt;
    &lt;/div&gt;
  );
}

export default App;
</pre>
<p>上面的代码创建了一个容器，我们将在其中保存想要用打字机效果制作动画的文本。如果我们用<code>npm start</code>命令运行上面的代码，我们将得到一个“Hello，World！”<span>类似下图的结果:</span></p>
<p><img data-attachment-id="126006" data-permalink="https://blog.logrocket.com/code-block-typewriter-effect-react/attachment/typewriter-effect-container/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/07/typewriter-effect-container.png" data-orig-size="730,426" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="typewriter-effect-container" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/07/typewriter-effect-container-300x175.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/07/typewriter-effect-container.png" decoding="async" class="aligncenter wp-image-126006 size-full jetpack-lazy-image" src="../Images/afea733849054257d1298eff285c583a.png" alt="Typewriter Effect Container" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2022/07/typewriter-effect-container.png 730w, https://blog.logrocket.com/wp-content/uploads/2022/07/typewriter-effect-container-300x175.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2022/07/typewriter-effect-container.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/07/typewriter-effect-container.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="126006" data-permalink="https://blog.logrocket.com/code-block-typewriter-effect-react/attachment/typewriter-effect-container/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/07/typewriter-effect-container.png" data-orig-size="730,426" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="typewriter-effect-container" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/07/typewriter-effect-container-300x175.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/07/typewriter-effect-container.png" decoding="async" loading="lazy" class="aligncenter wp-image-126006 size-full" src="../Images/afea733849054257d1298eff285c583a.png" alt="Typewriter Effect Container" srcset="https://blog.logrocket.com/wp-content/uploads/2022/07/typewriter-effect-container.png 730w, https://blog.logrocket.com/wp-content/uploads/2022/07/typewriter-effect-container-300x175.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/07/typewriter-effect-container.png"/></noscript>
<h3 id="add-blinking-cursor">添加闪烁光标</h3>
<p>接下来，我们将构建一个闪烁的光标并将其附加到文本的末尾。将以下代码添加到<code>index.css</code>:</p>
<pre class="language-css hljs">.bg-code{
  background-color: rgb(40, 42, 54);
}

.blinking-cursor::after {
  content: "|";
  animation: blink 1s step-end infinite;
}
@keyframes blink {
  from,
  to {
    opacity: 1;
  }
  50% {
    opacity: 0;
  }
}
</pre>
<p>上面的 CSS 样式在每个文本的末尾添加了一个<code>|</code>，产生了一种类似光标的闪烁效果。</p>
<h2 id="add-typewriting-effect-text">给文本添加打字机效果</h2>
<p>为了创建我们的打字机效果，我们将使用 React <code>useEffect</code>钩子。为此，请在代码中添加以下修改:</p>
<pre class="language-javascript hljs">const first_text = "const sayHello = () = {";
  const second_text = "console.log('hello')";
  const third_text = "//This prints out Hello World";

  const [text1, setText1] = useState("");
  const [text2, setText2] = useState("");
  const [text3, setText3] = useState("");

  useEffect(() =&gt; {
    const timeout = setTimeout(() =&gt; {
      setText1(first_text.slice(0, text1.length + 1));
    }, 100);
    return () =&gt; clearTimeout(timeout);
  }, [text1]);

  useEffect(() =&gt; {
    const timeout = setTimeout(() =&gt; {
      setText2(second_text.slice(0, text2.length + 1));
    }, 250);

    return () =&gt; clearTimeout(timeout);
  }, [text2]);

  useEffect(() =&gt; {
    const timeout = setTimeout(() =&gt; {
      setText3(third_text.slice(0, text3.length + 1));
    }, 300);

    return () =&gt; clearTimeout(timeout);
  }, [text3]);
</pre>
<p>在上面的代码中，我们使用了一个<code>setTimeout</code>函数和一个切片操作符。<code>setTimeout</code>函数在指定的时间间隔后执行代码块。我们使用 splice 操作符将整个字符串分成字符，并一次返回一个字符。</p>
<p>对于回调，我们使用状态。每当我们输入一个新字符，状态就会更新，并且执行<code>setTimeout</code>函数。因此，<code>setTimeout</code>会一直运行，直到整个文本被完全输入。</p>
<h2 id="deleting-retyping-text">删除和重新键入文本</h2>
<p>为了循环打字机效果，我们将添加两种状态，<code>isdeleting</code>和<code>istyping</code>，分别用于用户想要删除文本的时候和他们完成键入的时候:</p>
<pre class="language-javascript hljs">const textState = ["istyping", "isdeleting"];
const [typing, setTyping] = useState(textState[0]);

function sleep(ms) {
    return new Promise((resolve) =&gt; setTimeout(resolve, ms));
}
</pre>
<p>现在我们已经创建了输入和删除文本的状态，让我们使用<code>sleep</code>函数来创建两种状态之间的切换延迟。因此，当用户完全输入完文本时，我们将实现暂停。让我们继续修改我们的代码以使用这些状态，如下所示:</p>
<pre class="language-javascript hljs">useEffect(() =&gt; {
    const timeout = setTimeout(() =&gt; {
      if (typing === "istyping" &amp;&amp; text1 !== first_text) {
        setText1(first_text.slice(0, text1.length + 1));
      }
      else if (text1 === first_text &amp;&amp; typing === "istyping"){
        sleep(2000).then(()=&gt;{
        setTyping(textState[1])
        })
      }
      else if ( (text1 === first_text &amp;&amp; typing==="isdeleting") || typing === "isdeleting" ) {
        setText1(first_text.slice(0, text1.length - 1));
        if(text1.length&lt;=2){
            setTyping(textState[0])
        }
      }
    }, 100);
  return () =&gt; clearTimeout(timeout);
}, [text1, typing1]);
</pre>
<p>在上面的代码中，我们检查了<code>typing</code>是否等于<code>istyping</code>以及文本是否等于完整的字符串。如果返回<code>true</code>，我们将运行输入效果。当文本与完整字符串相似时，我们使用<code>sleep</code>功能在两秒钟后切换到<code>isdeleting</code>状态。</p>
<p>最后，我们使用最后一个条件一次删除一个字符，直到只剩下一个字母。此时，<code>typing</code>状态被设置回<code>istyping</code>，整个过程再次开始。我们也会为<code>text2</code>和<code>text3</code>做同样的事情。</p>
<h2 id="highlighting-code-syntax">突出显示代码语法</h2>
<p>为了突出显示我们的文本，使其看起来像一个代码块，我们将通过 CLI 安装<a href="https://github.com/react-syntax-highlighter/react-syntax-highlighter"> React 语法高亮器</a>:</p>
<pre class="language-bash hljs">npm i react-syntax-highlighter
</pre>
<p>当这个包被安装后，我们可以在<code>App.js</code>中导入它并如下使用它:</p>
<pre class="language-javascript hljs">import SyntaxHighlighter from 'react-syntax-highlighter';
import { docco } from 'react-syntax-highlighter/dist/esm/styles/hljs';
//...
&lt;span&gt;
  &lt;div className=" text-2xl"&gt;
    &lt;SyntaxHighlighter className="blinking-cursor" language="javascript" style={dracula}&gt;
      {text1}
    &lt;/SyntaxHighlighter&gt;
  &lt;/div&gt;
  &lt;div className=" text-2xl"&gt;
    &lt;SyntaxHighlighter className="blinking-cursor" language="javascript" style={dracula}&gt;
      {text2}
    &lt;/SyntaxHighlighter&gt;
  &lt;/div&gt;
  &lt;div className=" text-2xl"&gt;
    &lt;SyntaxHighlighter className="blinking-cursor" language="javascript" style={dracula}&gt;
      {text3}
    &lt;/SyntaxHighlighter&gt;
  &lt;/div&gt;
  &lt;div className=" text-2xl"&gt;
    &lt;SyntaxHighlighter className="blinking-cursor" language="javascript" style={dracula}&gt;
      {`}`}
    &lt;/SyntaxHighlighter&gt;
  &lt;/div&gt;
&lt;/span&gt;
</pre>
<p>现在我们已经实现了我们的<code>Syntax Higlighter</code>组件，我们可以结束我们的打字机效果了。</p>
<h2 id="using-typewriting-library">使用预建的打字库</h2>
<p>作为编码和定制我们自己的打字机效果的替代方法，我们可以使用预建的库来节省时间。</p>
<p>处理打字机效果的库的一个例子是<code><a href="https://www.npmjs.com/package/typewriter-effect">react-typewriter-effect</a></code>。我们可以使用以下命令通过 CLI 安装该软件包:</p>
<pre class="language-bash hljs">npm i react-typewriter-effect
</pre>
<p>安装完成后，我们可以在应用程序中使用它，如下所示，以获得打字机效果:</p>
<pre class="language-javascript hljs">import TypeWriterEffect from 'react-typewriter-effect';
//...

&lt;TypeWriterEffect
  textStyle={{ fontFamily: 'Red Hat Display' }}
  startDelay={100}
  cursorColor="black"
  text="Text for typewriting effect here"
  typeSpeed={100}
  eraseSpeed={100}
/&gt;
</pre>
<p>上面的代码将为指定的文本字符串产生打字机效果。</p>
<h2 id="conclusion">结论</h2>
<p>在本文中，我们学习了如何使用 React 轻松创建打字机效果。在你的网站或应用程序中实现这一功能可以通过增加视觉趣味和引导用户的注意力到你想要的地方来改善你的用户界面。您可以添加到我们从头构建的打字机效果中，以实现更多您自己的定制，或者您可以使用为您实现该功能的库，如<code>react-typewriter-effect</code>。</p>
<p>我希望你喜欢这篇文章，如果你有任何问题，一定要留下评论。编码快乐！</p><div class="code-block code-block-17">
<div class="blog-plug inline-plug react-plug" vwo-el-id="26283398190">
<h2 vwo-el-id="41600691720">使用 LogRocket 消除传统反应错误报告的噪音</h2>
<a href="https://lp.logrocket.com/blg/react-signup-issue-free" target="_blank" vwo-el-id="19356441070">LogRocket
</a><p>是一款 React analytics 解决方案，可保护您免受数百个误报错误警报的影响，只针对少数真正重要的项目。LogRocket 告诉您 React 应用程序中实际影响用户的最具影响力的 bug 和 UX 问题。</p><a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="19356441380">
<img class="first-react-image alignnone size-full wp-image-46 jetpack-lazy-image jetpack-lazy-image--handled" src="../Images/f300c244a1a1cf916df8b4cb02bec6c6.png" vwo-el-id="18272717540" data-lazy-loaded="1" data-original-src="https://files.readme.io/27c94e7-Image_2017-06-05_at_9.46.04_PM.png"/>
</a>
<a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="19356441690">
<img class="second-react-image alignnone size-full wp-image-46 jetpack-lazy-image jetpack-lazy-image--handled" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" vwo-el-id="30720362350" data-lazy-loaded="1" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/>
</a>
<a href="https://lp.logrocket.com/blg/react-signup-issue-free" target="_blank" rel="noopener noreferrer" vwo-el-id="35866400580">LogRocket
</a><p>自动聚合客户端错误、反应错误边界、还原状态、缓慢的组件加载时间、JS 异常、前端性能指标和用户交互。然后，LogRocket 使用机器学习来通知您影响大多数用户的最具影响力的问题，并提供您修复它所需的上下文。</p><p vwo-el-id="28675661060">关注重要的 React bug—<a class="signup" href="https://lp.logrocket.com/blg/react-signup-issue-free" target="_blank" rel="noopener noreferrer" vwo-el-id="40093418840">今天就试试 LogRocket】。</a></p>
</div></div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>
 
</div>    
</body>
</html>
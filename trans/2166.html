<html>
<head>
<title>SWR v1 is here: What's new? - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>SWR v1 在这里:有什么新的？- LogRocket 博客</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/whats-new-swr-v1/#0001-01-01">https://blog.logrocket.com/whats-new-swr-v1/#0001-01-01</a></blockquote><div><article class="article-post">
<h2>简介:什么是 SWR？</h2>
<p>SWR 是一个钩子库，它为远程数据获取提供了 React 钩子。<a href="https://pankod.github.io/superplate/docs/react/hooks/swr/" target="_blank" rel="noopener">正如 SWR 文档所述</a>,“SWR”这个名字来源于<code>stale-while-revalidate</code>，这是一种 HTTP 缓存失效策略。</p>
<p>简而言之，<code>stale-while-revalidate</code>策略仅仅意味着在重新验证(获取)更新的数据的同时，提供或返回陈旧(缓存)的数据，并在更新的数据返回后将其提供给<code>UI</code>。过时数据的重新验证发生在用户关注或网络重新连接的情况下。</p>
<p>其结果是，我们的应用程序组件不断获得新的数据流，使我们的<code>UI</code>速度极快，反应非常灵敏，响应速度更快。</p>
<p>我们提供的另一项有助于提升应用性能的出色功能是<a href="https://swr.vercel.app/docs/advanced/performance#deduplication" target="_blank" rel="noopener">重复数据删除</a>。重复数据删除是一种消除冗余数据的技术，通过实施这种技术，SWR 实现了智能抓取。</p>
<p>这意味着，当我们呈现一个多次重用<code>useSWR</code>钩子的组件时，如果键是相同的，SWR 将防止多次使用<code>useSWR</code>钩子来重新验证数据，从而消除不必要的网络请求，因为只会发出一个请求，过时的数据将被提供给后续的请求。</p>
<p>在这篇文章中，我们将看到 SWR 版本 1 中令人惊叹的新增功能，但是如果你是 SWR 的新手，你可以通过阅读我们以前的 useSWR 文章开始。</p>
<h2>SWR v1 中的新功能</h2>
<h3>1.更小的尺寸和更高的性能</h3>
<p>SWR 版本 1 提供了一个明显更小的库和改进的性能特性，比如树抖动。<a href="https://swr.vercel.app/blog/swr-v1#smaller-size" target="_blank" rel="noopener">根据文档</a>，版本 1 要小得多——内核小了 41 %, gzip 压缩时小了 24%。</p>
<p>SWR 计划是不可动摇的，因为性能是 SWR 最重要的特征之一。</p>
<p>版本 1 支持路径导入，如下所示:</p>
<pre>import useSWR from 'swr'
import useSWRInfinite from 'swr/infinite'
</pre>
<p>对于路径导入，在我们不使用<code>useSWRInfinite</code>钩子的情况下，它不会被捆绑在我们的应用程序中。移除死代码使得我们最终的包大小显著变小。</p>
<p>通过使库更加树摇和轻量级，我们的应用程序将有一个更小的包，一个更精简的运行时，和一个更小的<code>node_modules</code>目录。</p>
<h3>2.自定义缓存提供程序</h3>
<p>默认情况下，SWR 使用全局缓存。然而，版本 1 通过提供提供者 API 进一步发展了这一点。provider API 由一个缓存提供程序组成，该缓存提供程序是一个类似映射的对象，与以下 TypeScript 定义相匹配:</p>
<pre>interface Cache&lt;Data&gt; {
  get(key: string): Data | undefined
  set(key: string, value: Data): void
  delete(key: string): void
}
</pre>
<p>缓存提供者被传递给<code>SWRConfig</code>的提供者选项，如下所示:</p>
<pre>import useSWR, { SWRConfig } from 'swr'

function App() {
  return (
    &lt;SWRConfig value={{ provider: () =&gt; new Map() }}&gt;
      &lt;Blog/&gt;
    &lt;/SWRConfig&gt;
  )
}
</pre>
<p>这样做的结果是我们的定制缓存提供者将被<code>SWRConfig</code>中的所有 SWR 钩子使用。换句话说，<code>Blog</code>中的所有 SWR 钩子将从那个<code>map</code>实例中读取和写入，但是没有嵌套在缓存提供者中的 SWR 钩子退回到默认缓存，这是一个空的<code>map</code>。因此，缓存提供程序应该放在组件树的更高位置或渲染之外。</p>
<p>缓存提供者旨在调整 SWR 以支持更多的存储选项，根据我们的用例，它们可以是 JavaScript Map 实例或其他缓存提供者实现。</p>
<p>SWR v1 为扩展当前的缓存提供者提供了实验性的支持。因此，我们可以将缓存提供者与本地存储同步，在测试用例之间重置缓存，并使用扩展的缓存提供者执行<a href="https://swr.vercel.app/docs/advanced/cache#experimental-extend-cache-provider" target="_blank" rel="noopener">更多操作。</a></p>
<p>此外，在版本 1 中，我们可以在 React 组件中通过使用如下所示的<code><a href="https://swr.vercel.app/docs/global-configuration#access-to-global-configurations" target="_blank" rel="noopener">useSWRConfig</a></code>钩子来访问当前的缓存提供者:</p>
<pre>import { useSWRConfig } from 'swr'

const Post() {
  const { cache, ...extraConfig } = useSWRConfig()
  cache.get(key) // Get the current data for the specified key.
  cache.clear()  // Clear all the cache. SWR will revalidate upon re-render.
  // ...
}
</pre>
<blockquote><p><strong>注意</strong>，直接写入缓存可能会导致 SWR 的未定义行为。推荐的做法是<a href="https://swr.vercel.app/docs/mutation" target="_blank" rel="noopener">使用 SWR API 比如突变</a>。</p></blockquote>
<h3>3.<code>useSWRConfig()</code></h3>
<p>虽然<code>SWRConfig</code>上下文为所有 SWR 钩子提供了全局配置选项，但是新的<code>useSWRConfig()</code>钩子使我们能够在 React 组件内部访问这些选项。</p>
<p>考虑下面的代码:</p>
<pre>import { useSWRConfig } from 'swr'

function MyComponent () {
  const { refreshInterval, mutate, ...restConfig } = useSWRConfig()
  // ... do something
}
</pre>
<p>从我们的缓存示例中，我们看到我们也可以使用<code>useSWRConfig</code>访问缓存。</p>
<h3>4.不可变模式</h3>
<p>开箱即用，SWR 支持以下事件的自动重新验证:</p>
<h4>焦点上的重新验证</h4>
<p>当我们重新聚焦一个页面或者在选项卡之间切换时，就会发生这种重新验证。这有助于为我们的应用程序提供新数据。默认情况下，此功能是打开的，但您可以通过<code><a href="https://swr.vercel.app/docs/options" target="_blank" rel="noopener">revalidateOnFocus</a></code>选项将其禁用。</p>
<h4>间隔重新验证</h4>
<p>在许多情况下，由于许多设备、多个用户和多个打开的标签，我们的应用程序的数据会很快变得陈旧。该特性使 SWR 能够按时间间隔执行轮询，这提供了一种同步到最新状态并随时间更新 UI 上的数据的方法。</p>
<p>您可以通过用<code>fetcher</code>功能中的值设置<code><a href="https://swr.vercel.app/docs/options" target="_blank" rel="noopener">refreshInterval</a></code>选项来启用此功能:</p>
<pre>useSWR('/api/todos', fetcher, { refreshInterval: 2000 })
</pre>
<p>上面的代码仅仅意味着每 2000 毫秒轮询一次。</p>
<p>此外，SWR 使我们能够在窗口不可见时——如果启用了<code>refreshInterval</code>——通过使用<code>refreshWhenHidden</code>选项来执行轮询，并且在浏览器离线时使用<code>refreshWhenOffline</code>选项。</p>
<h4>重新连接时重新验证</h4>
<p>这种重新验证发生在网络恢复时，例如在用户重新在线的情况下。可以使用<code><a href="https://swr.vercel.app/docs/options" target="_blank" rel="noopener">revalidateOnReconnect</a></code>选项进行配置。</p>
<p>在版本 1 中，SWR 提供了一个助手，<code>useSWRImmutable</code>钩子，使状态不可变。这意味着当我们重新验证时，状态不会改变。</p>
<p><code>useSWRImmutable</code>挂钩类似于<code>useSWR</code>挂钩，我们可以使用两者使状态不可变，如下所示:</p>
<pre>import useSWR from 'swr'
import useSWRImmutable from 'swr/immutable'

useSWRImmutable(key, fetcher, options) // makes resourse immutable 

useSWR(key, fetcher, {
  revalidateIfStale: false,
  revalidateOnFocus: false,
  revalidateOnReconnect: false
})

// equivalent to
useSWRImmutable(key, fetcher) // makes resourse immutable 
</pre>
<p>在上面的代码中，这两个钩子使得数据一旦被缓存就不可改变。它会自动为我们完成。</p>
<h3>5.中间件</h3>
<p><a href="https://swr.vercel.app/docs/middleware#request-logger" target="_blank" rel="noopener"> SWR 中间件 API </a>提供了一种抽象和重用逻辑的好方法。</p>
<p>中间件是一个闭包，它接收 SWR 钩子作为参数并包装<code>useSWR</code>钩子，从而使我们能够在调用<code>useSWR</code>钩子之前和之后执行逻辑。</p>
<p>考虑下面的代码:</p>
<pre>function SWRMiddleware (useSWRNext) {
  return (key, fetcher, config) =&gt; {
    // beform operations before invoking useSWR()

    // Handle the next middleware, or invokes `useSWR` hook if this is the last middleware.
    const swr = useSWRNext(key, fetcher, config)

    // befrom operations after invoking useSWR()
    return swr
  }
}
</pre>
<p>SWR 中间件非常有用和强大，使用这个特性可以实现很多想法。文档中的一个例子是请求记录器。</p>
<p>记录器中间件是一个<a href="https://blog.logrocket.com/understanding-javascript-decorators/" target="_blank" rel="noopener">函数装饰器</a>，它用记录请求的能力来装饰<code>fetcher</code>函数——在本例中是 SWR 键:</p>
<pre>function logger(useSWRNext) {
  return (key, fetcher, config) =&gt; {
    // Add logger to the original fetcher.
    const extendedFetcher = (...args) =&gt; {
      console.log('SWR Request:', key)
      return fetcher(...args)
    }

    // Execute the hook with the new fetcher.
    return useSWRNext(key, extendedFetcher, config)
  }
}
</pre>
<p>因此，当我们使用这个中间件时，SWR 密钥被记录到控制台:</p>
<pre>...
// ... used from inside your component
useSWR(key, fetcher, { use: [logger] })
SWR Request: /api/user1
SWR Request: /api/user2
...
</pre>
<p>为了使用这个特性，我们将一组中间件传递给<code>SWRConfig</code>或<code>useSWR</code>:</p>
<pre>&lt;SWRConfig value={{ use: [middlewareA, middleWareB, middlewareC] }}&gt;

// or...

useSWR(key, fetcher, { use: [middlewareA, middleWareB, middlewareC] })
</pre>
<p>当处理多个中间件时，每个中间件嵌套在另一个中间件中，最后一个中间件接收 SWR 钩子。</p>
<h3>6.后备数据</h3>
<p>这一新功能使我们能够为所有具有特定键的 SWR 提供任意预取数据:</p>
<pre>&lt;SWRConfig value={{
  fallback: {
    '/user': { name: 'Eagles', ... },
    '/posts': ...,
    '/pages': ...,
    ...
  }
}}&gt;
  &lt;App/&gt;
&lt;/SWRConfig&gt;
</pre>
<p>当应用程序重新验证时，这些预取的数据可以作为占位符内容显示在页面上。这改善了用户体验，在静态站点生成(SSG)和服务器端渲染(SSR)等场景中非常有用。</p>
<p>此外，为了一致性和避免混淆，旧的<code>initialData</code>已经被重命名为<code>fallbackData</code>，但是它仍然为指定的 SWR 钩子提供一个单独的回退值。</p>
<h2>结论</h2>
<p>SWR 是一个令人敬畏的，经过深思熟虑的，轻量级的，快速的数据获取库。它是与传输和协议无关的——它支持 REST 和 GraphQL，它支持<code>suspense</code>，并且它是类型脚本就绪的。在 SWR 实现的模式让开发人员的生活变得更加轻松。</p>
<p>SWR 版本 1 绝对是每个开发人员的必备品。你可以<a href="https://swr.vercel.app/blog/swr-v1" target="_blank" rel="noopener">在这里</a>了解更多关于版本 1 的信息。你也可以阅读<a href="https://github.com/vercel/swr/releases" target="_blank" rel="noopener">变更日志</a>了解更多信息。</p><div class="code-block code-block-17">
<div class="blog-plug inline-plug react-plug" vwo-el-id="26283398190">
<h2 vwo-el-id="41600691720"><a href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener"> LogRocket </a>:全面了解您的生产 React 应用</h2><p>调试 React 应用程序可能很困难，尤其是当用户遇到难以重现的问题时。如果您对监视和跟踪 Redux 状态、自动显示 JavaScript 错误以及跟踪缓慢的网络请求和组件加载时间感兴趣，</p><a href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" vwo-el-id="19356441070">try LogRocket</a><p>. </p><a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="19356441380">
<img class="first-react-image alignnone size-full wp-image-46 jetpack-lazy-image jetpack-lazy-image--handled" src="../Images/f300c244a1a1cf916df8b4cb02bec6c6.png" vwo-el-id="18272717540" data-lazy-loaded="1" data-original-src="https://files.readme.io/27c94e7-Image_2017-06-05_at_9.46.04_PM.png"/>
</a>
<a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="19356441690">
<img class="second-react-image alignnone size-full wp-image-46 jetpack-lazy-image jetpack-lazy-image--handled" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" vwo-el-id="30720362350" data-lazy-loaded="1" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/>
</a>
<p vwo-el-id="28675660440" class="">LogRocket 结合了会话回放、产品分析和错误跟踪，使软件团队能够创建理想的 web 和移动产品体验。这对你来说意味着什么？</p>
<p>LogRocket 不是猜测错误发生的原因，也不是要求用户提供截图和日志转储，而是让您回放问题，就像它们发生在您自己的浏览器中一样，以快速了解哪里出错了。</p>
<p>不再有嘈杂的警报。智能错误跟踪允许您对问题进行分类，然后从中学习。获得有影响的用户问题的通知，而不是误报。警报越少，有用的信号越多。</p>
<p vwo-el-id="28675660750">LogRocket Redux 中间件包为您的用户会话增加了一层额外的可见性。LogRocket 记录 Redux 存储中的所有操作和状态。</p>
<p vwo-el-id="28675661060">现代化您调试 React 应用的方式— <a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="40093418840">开始免费监控</a>。</p>
</div></div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
<html>
<head>
<title>Building web components with WebC in vanilla JavaScript </title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>用普通JavaScript用WebC构建web组件</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/building-web-components-with-webc-vanilla-javascript/#0001-01-01">https://blog.logrocket.com/building-web-components-with-webc-vanilla-javascript/#0001-01-01</a></blockquote><div><article class="article-post">
<p><em>目录:</em></p>

<h2 id="what-are-web-components">什么是web组件？</h2>
<p>Web组件是自定义的、可重用的、强封装的HTML组件，它与库无关，可以在任何JavaScript项目中使用。</p>
<p>一个流行的web组件的例子是<code>&lt;video&gt;</code>标签。虽然<code>video</code>可能看起来像一个HTML元素，但实际上，它由几个HTML元素和定义其行为的定制逻辑组成。</p>
<h2 id="why-use-web-components">为什么要使用web组件？</h2>
<p>那么，为什么要使用web组件呢？概括地说，web组件的两个主要优势是封装性和缺乏外部依赖性。</p>
<p>Web组件通过允许您将CSS和JavaScript代码的影响限制在组件范围内来解决封装问题。</p>
<p>当然，像React和<a href="https://blog.logrocket.com/tag/angular"> Angular </a>这样的流行JavaScript框架可以帮助你实现类似的封装效果。那么，是什么让web组件与众不同呢？这个问题给我们带来了第二个优势:web组件是库不可知的，您可以只使用内置的JavaScript APIs来创建它们。</p>
<p>在设计UI组件库时，web组件与库无关的特性尤其有用。与其他为特定框架构建的库不同，您可以使用web组件来构建一个不与单一技术栈耦合的库。这意味着任何人都可以使用它，不管他们的项目使用的是什么JavaScript框架。</p>
<h3 id="web-component-specifications">Web组件规范</h3>
<p>通常，在创建web组件时，您将使用三种规范/技术:</p>
<ul>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/Web_Components/Using_custom_elements">自定义元素</a>:创建HTML元素的API，用来封装您的自定义HTML、JavaScript和CSS代码</li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/Web_Components/Using_shadow_DOM"> Shadow DOM </a>:一个API，将一个隐藏的DOM附加到一个元素上，这个元素不会与应用程序其他部分的CSS或JavaScript代码冲突</li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/Web_Components/Using_templates_and_slots">模板</a>:重用标记结构的API。使用<code>&lt;template&gt;</code>标签，您可以定义一个标记结构，它不会在页面加载时立即呈现，而是使用JavaScript复制</li>
</ul>
<p>要了解关于这些规范的更多信息，以及web组件与React等JavaScript框架相比如何，请查看这个<a href="https://blog.logrocket.com/react-vs-web-components/"> LogRocket博客</a>帖子。</p>
<h3 id="limitations-web-components">web组件的限制</h3>
<p>就像任何技术一样，web组件也有局限性。让我们简单介绍一下。</p>
<p>Web组件要求浏览器允许在您的web应用程序上运行JavaScript，即使您的web组件纯粹是表示性的，不包含任何交互式JavaScript代码。</p>
<p>通常，您需要以命令的方式编写web组件，而不是以声明的方式。这导致了有些笨拙的创作体验，尤其是在实现更高级的技术时，比如渐进式增强。我们将在后面的章节中更详细地讨论这一点。</p>
<h2 id="how-webc-helps">WebC如何提供帮助</h2>
<p>正如您可能已经猜到的，WebC有助于解决使用web组件时的一些问题。</p>
<p>WebC是一个为web组件生成标记的序列化器。它与框架无关，并提供了各种有用的编译工具，使编写web组件变得更加容易。</p>
<p>正如我提到的，web组件通常要求JavaScript可用，即使对于其中没有任何JavaScript的web组件也是如此。但是有了WebC，就不是这样了。即使浏览器禁用了JavaScript，您也可以创建只显示HTML的web组件。这是因为WebC将您的web组件代码编译成一个简单的HTML输出。</p>
<p>在编写web组件时，WebC提供了更好的创作体验。使用WebC，您可以创建易于编写和维护的单文件web组件。它们整合您的HTML、CSS和JavaScript代码，并使用模板和Shadow DOM等功能简化这个过程。</p>
<p>这还只是皮毛:WebC有更多的特性和定制，使得编写web组件成为一种更愉快的体验。查看<a href="https://github.com/11ty/webc">他们的文档</a>以获得所有功能和选项的更详细概述。</p>
<h2 id="building-custom-web-components-with-webc-vanilla-javascript">在普通JavaScript项目中使用WebC构建定制web组件</h2>
<p>让我们来看看WebC是如何运作的！在本教程中，我们将构建一个自定义组件，它带有一个按钮和一个当您单击按钮时会旋转的框。这是一个非常不自然的例子，但是它仍然可以帮助我们说明使用WebC的好处。<br/> <img data-attachment-id="153231" data-permalink="https://blog.logrocket.com/building-web-components-with-webc-vanilla-javascript/attachment/button-component-with-rotate-click/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/12/button-component-with-rotate-click.png" data-orig-size="730,862" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="button-component-with-rotate-click" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/12/button-component-with-rotate-click-254x300.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/12/button-component-with-rotate-click.png" decoding="async" class="aligncenter size-full wp-image-153231 jetpack-lazy-image" src="../Images/7ce98aa3a7b6ee99194aed0a113d497e.png" alt="Our custom button component that rotates on click" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2022/12/button-component-with-rotate-click.png 730w, https://blog.logrocket.com/wp-content/uploads/2022/12/button-component-with-rotate-click-254x300.png 254w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2022/12/button-component-with-rotate-click.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/12/button-component-with-rotate-click.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="153231" data-permalink="https://blog.logrocket.com/building-web-components-with-webc-vanilla-javascript/attachment/button-component-with-rotate-click/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/12/button-component-with-rotate-click.png" data-orig-size="730,862" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="button-component-with-rotate-click" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/12/button-component-with-rotate-click-254x300.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/12/button-component-with-rotate-click.png" decoding="async" loading="lazy" class="aligncenter size-full wp-image-153231" src="../Images/7ce98aa3a7b6ee99194aed0a113d497e.png" alt="Our custom button component that rotates on click" srcset="https://blog.logrocket.com/wp-content/uploads/2022/12/button-component-with-rotate-click.png 730w, https://blog.logrocket.com/wp-content/uploads/2022/12/button-component-with-rotate-click-254x300.png 254w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/12/button-component-with-rotate-click.png"/></noscript>
<p>首先，您需要建立一个JavaScript项目。我将使用<a href="https://vitejs.dev/"> Vite </a>快速启动一个新项目。</p>
<p>您还需要安装Node.js我们将使用它来运行我们的WebC编译脚本，该脚本将生成静态文件，Vite将提供这些文件。</p>
<p>一旦你建立了你的项目，运行<code>yarn add @11ty/webc</code>来安装WebC。接下来，让我们添加我们的<code>main.js</code>脚本，该脚本将注册WebC页面并将其内容写入项目根目录下的<code>index.html</code>:</p>
<pre class="language-javascript hljs">import { WebC } from "@11ty/webc";
import fs from "fs";
let page = new WebC();
page.defineComponents("components/**.webc");
page.setInputPath("page.webc");
let { html, css, js, components } = await page.compile();
fs.writeFile("./index.html", html, (err) =&gt; {
  if (err) {
    console.log({ err });
  }
});</pre>
<p>所以，这就是上面发生的事情:</p>
<ul>
<li>首先，我们实例化一个WebC页面对象。这是将包含我们的自定义web组件的页面</li>
<li>使用<code>page.setInputPath("page.webc");</code>，我们为页面定义内容源。WebC页面和组件通常有一个<code>.webc</code>文件扩展名</li>
<li>使用<code>page.defineComponents("components/**.webc");</code>，我们定义保存web组件的文件夹</li>
<li>我们调用<code>page.compile()</code>将页面内容聚合并编译成静态HTML输出</li>
<li>最后，我们将输出HTML写到<code>index.html</code>文件中</li>
</ul>
<p>在我们继续深入之前，让我们简要地了解一下页面和组件之间的区别。在WebC中，页面是以<code>&lt;!doctype</code>或<code>&lt;html</code>开头的文件，通常用于显示整个页面。</p>
<p>组件是用于显示可重用UI片段的任何其他WebC文件。</p>
<p>现在，让我们创建我们的<code>page.webc</code>文件并尝试运行我们的脚本。该文件将包含一个基本的HTML页面设置:</p>
<pre class="language-html hljs">&lt;!-- HTML--&gt;
&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
  &lt;head&gt;
    &lt;meta charset="UTF-8"&gt;
    &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt;
    &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;
    &lt;title&gt;WebC tutorial&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;my-component&gt;&lt;/my-component&gt;
  &lt;/body&gt;
  &lt;style&gt;
    body {
      padding: 20%;
    }
  &lt;/style&gt;
&lt;/html&gt;</pre>
<p>你可能已经注意到，这看起来就像我们的标准HTML，这是因为它是！对于WebC，除了一些需要添加一些WebC语法的情况，您可以使用常规的HTML、JavaScript和CSS。</p>
<p>现在让我们试着运行我们的脚本。您可以简单地使用<code>node main.js</code>命令来运行它。为了更好的开发者体验，我推荐使用nodemon 的<a href="https://blog.logrocket.com/nodemon-tutorial-automatically-restart-node-js-apps-with-nodemon/">。它将获取您对脚本所做的任何更改，并自动重新运行该文件。</a></p>
<p>下面是我在本教程中使用的nodemon命令:</p>
<pre class="language-javascript hljs">nodemon main.js -e js,webc,html
</pre>
<p>接下来，让我们通过创建<code>components</code>文件夹并将<code>my-component.webc</code>文件放在那里来添加我们的web组件。我们来补充以下内容:</p>
<pre class="language-html hljs">&lt;!-- HTML--&gt;
&lt;div id="rectangle"&gt;&lt;/div&gt;
&lt;button id="flipper"&gt;Flip&lt;/button&gt;
&lt;style webc:scoped&gt;
  #rectangle {
    background-color: skyblue;
    width: 40px;
    height: 160px;
    border: 2px #4ba3c6 solid;
  }

  button {
    margin-top: 12px;
    width: 40px;
  }
&lt;/style&gt;</pre>
<p>同样，我们使用简单的HTML和CSS来为我们的盒子设置按钮和<code>div</code>并设置样式。</p>

<p>上例中一个值得注意的部分是我们的<code>style</code>标签中的<code>webc:scoped</code>属性。这个标签允许你在你的组件中封装你的CSS代码。</p>
<p>当您将该属性添加到一个<code>style</code>标签中时，WebC将在编译期间自动生成一个惟一的散列字符串类并将其分配给组件元素。然后，它在组件中声明的所有CSS选择器的前面加上这个散列字符串的前缀。</p>
<p>像<code>emotion</code>和<code>styled-components</code>这样的流行样式库使用类似的哈希生成机制来包含定制组件中的样式。</p>
<h3 id="adding-javascript-functionality-web-component">向我们的web组件添加JavaScript功能</h3>
<p>到目前为止，我们已经定义了web组件的外观，但是它并没有做太多的事情。让我们添加一些用于交互的JavaScript代码。</p>
<p>在同一个web组件中，在<code>style</code>标记的正下方，添加一个带有以下JavaScript代码的<code>script</code>标记:</p>
<pre class="language-html hljs">&lt;!-- HTML--&gt;
&lt;script&gt;
  let deg = 0;
  document.getElementById("flipper").onclick = () =&gt; {
    const rectangle = document.getElementById("rectangle");
    const nextDeg = deg === 0 ? 90 : 0;
    rectangle.style.transform = `rotate(${nextDeg}deg)`
    deg = nextDeg;
  }
&lt;/script&gt;</pre>
<p>在这里，我们简单地向按钮添加了一个<code>onclick</code>监听器，通过更新<code>transform</code>样式属性来旋转矩形。注意，我们不必使用<code>customElements.define</code>来全局定义我们的web组件；我们简单地添加了JavaScript代码来驱动我们的按钮。</p>
<p>仅此而已。现在我们有了一个功能正常的简单web组件。如果您使用扩展为您的本地服务器关闭JavaScript，我们的web组件仍然会显示，尽管这个按钮不会做任何事情。</p>
<h2 id="progressive-enhancement-webc">使用WebC进行渐进式增强</h2>
<p>WebC的另一个强大功能是简化向应用程序添加渐进式改进的过程。</p>
<p><a href="https://blog.logrocket.com/understanding-progressive-enhancement/">渐进式增强</a>是一种模式，允许用户首先访问网站的基本内容和功能。之后，如果用户的浏览器功能和互联网连接允许，用户将获得UI增强和更多的交互式功能。</p>
<p>让我们为组件添加一个简单的渐进式增强处理，方法是禁用按钮，直到JavaScript可用。<br/> <img data-attachment-id="153235" data-permalink="https://blog.logrocket.com/building-web-components-with-webc-vanilla-javascript/attachment/button-disabled-javascript-available/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/12/button-disabled-javascript-available.gif" data-orig-size="730,502" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="button-disabled-javascript-available" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/12/button-disabled-javascript-available-300x206.gif" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/12/button-disabled-javascript-available.gif" decoding="async" class="aligncenter size-full wp-image-153235 jetpack-lazy-image" src="../Images/06a2c1764d4f6d90468a6fdbe7cb2dd2.png" alt="Our button is disabled until JavaScript is available" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2022/12/button-disabled-javascript-available.gif?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/12/button-disabled-javascript-available.gif"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="153235" data-permalink="https://blog.logrocket.com/building-web-components-with-webc-vanilla-javascript/attachment/button-disabled-javascript-available/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/12/button-disabled-javascript-available.gif" data-orig-size="730,502" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="button-disabled-javascript-available" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/12/button-disabled-javascript-available-300x206.gif" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/12/button-disabled-javascript-available.gif" decoding="async" loading="lazy" class="aligncenter size-full wp-image-153235" src="../Images/06a2c1764d4f6d90468a6fdbe7cb2dd2.png" alt="Our button is disabled until JavaScript is available" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/12/button-disabled-javascript-available.gif"/></noscript>
<p>首先，我们需要更新我们的<code>script</code>标签中的代码:</p>
<pre class="language-html hljs">&lt;!-- HTML--&gt;
&lt;script&gt;
  let deg = 0;
  class MyComponent extends HTMLElement {
    connectedCallback() {
      document.getElementById("flipper").onclick = () =&gt; {
        const rectangle = document.getElementById("rectangle");
        const nextDeg = deg === 0 ? 90 : 0;
        rectangle.style.transform = `rotate(${nextDeg}deg)`
        deg = nextDeg;
      }
    }
  }
  window.customElements.define("my-component", MyComponent)
&lt;/script&gt;</pre>
<p>这里，我们使用标准模式通过<code>window.customElements.define</code>来定义web组件，以便能够等待JavaScript变得可用。</p>
<p>现在让我们将CSS处理添加到我们的按钮中:</p>
<pre class="language-css hljs">&lt;!-- HTML--&gt;
&lt;style webc:scoped&gt;
  #rectangle {
    background-color: skyblue;
    width: 40px;
    height: 160px;
    border: 2px #4ba3c6 solid;
  }

  button {
    margin-top: 12px;
    width: 40px;
  }

  :host:not(:defined)&gt;button {
    opacity: 0.2;
    cursor: not-allowed;
  }
&lt;/style&gt;</pre>
<p>如您所见，我们正在使用<code>:host:not(:defined)</code>选择器。这个选择器来自Shadow DOM API，允许您在web组件加载时为它们定义特殊的样式。</p>
<p>不过，WebC确实有自己的解释:当你的代码被编译时，它会用生成的hash string类替换<code>:host</code>部分。</p>
<p>现在，如果您要关闭本地服务器的JavaScript，您会看到该按钮是灰色的，更明显的是该按钮不做任何事情。<br/> <img data-attachment-id="153239" data-permalink="https://blog.logrocket.com/building-web-components-with-webc-vanilla-javascript/attachment/button-disabled-styling/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/12/button-disabled-styling.png" data-orig-size="730,525" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="button-disabled-styling" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/12/button-disabled-styling-300x216.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/12/button-disabled-styling.png" decoding="async" class="aligncenter size-full wp-image-153239 jetpack-lazy-image" src="../Images/8a61c804ddd187faae126c547eda4516.png" alt="Our styling contributes to the understanding that the button is disabled" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2022/12/button-disabled-styling.png 730w, https://blog.logrocket.com/wp-content/uploads/2022/12/button-disabled-styling-300x216.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2022/12/button-disabled-styling.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/12/button-disabled-styling.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="153239" data-permalink="https://blog.logrocket.com/building-web-components-with-webc-vanilla-javascript/attachment/button-disabled-styling/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/12/button-disabled-styling.png" data-orig-size="730,525" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="button-disabled-styling" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/12/button-disabled-styling-300x216.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/12/button-disabled-styling.png" decoding="async" loading="lazy" class="aligncenter size-full wp-image-153239" src="../Images/8a61c804ddd187faae126c547eda4516.png" alt="Our styling contributes to the understanding that the button is disabled" srcset="https://blog.logrocket.com/wp-content/uploads/2022/12/button-disabled-styling.png 730w, https://blog.logrocket.com/wp-content/uploads/2022/12/button-disabled-styling-300x216.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/12/button-disabled-styling.png"/></noscript>
<p>您可以使用相同的模式对您的web页面进行任何您想要的渐进式增强处理。</p>
<h2>结论</h2>
<p>这个帖子到此为止。我们讨论了web组件、它们的用例，以及它们与JavaScript框架的比较。</p>
<p>此外，我们讨论了WebC如何减轻web组件的一些缺点，并帮助我们获得它们的全部好处。</p><div class="code-block code-block-27">
<div class="blog-plug inline-plug vanilla-javascript-cta"><h2>通过理解上下文，更容易地调试JavaScript错误</h2>
<p>调试代码总是一项单调乏味的任务。但是你越了解自己的错误，就越容易改正。</p>
<p>LogRocket 让你以新的独特的方式理解这些错误。我们的前端监控解决方案跟踪用户与您的JavaScript前端的互动，让您能够准确找出导致错误的用户行为。</p>
<a href="https://lp.logrocket.com/blg/javascript-signup" class="signup" target="_blank" rel="noopener noreferrer"><img class="alignnone size-full wp-image-46 jetpack-lazy-image" src="../Images/cbfed9be3defcb505e662574769a7636.png" alt="LogRocket Dashboard Free Trial Banner" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2020/06/reproduce-javascript-errors.gif?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/06/reproduce-javascript-errors.gif"/><noscript><img data-lazy-fallback="1" class="alignnone size-full wp-image-46" src="../Images/cbfed9be3defcb505e662574769a7636.png" alt="LogRocket Dashboard Free Trial Banner" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/06/reproduce-javascript-errors.gif"/></noscript></a>
<p>LogRocket记录控制台日志、页面加载时间、堆栈跟踪、慢速网络请求/响应(带有标题+正文)、浏览器元数据和自定义日志。理解您的JavaScript代码的影响从来没有这么简单过！</p>
<a class="signup" href="https://lp.logrocket.com/blg/javascript-signup" target="_blank" rel="noopener noreferrer">Try it for free</a><p>.</p></div>


</div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
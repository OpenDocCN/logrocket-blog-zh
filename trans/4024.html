<html>
<head>
<title>Comparing Milkdown with other WYSIWYG editors </title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>将Milkdown与其他所见即所得编辑器进行比较</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/comparing-milkdown-other-wysiwyg-editors/#0001-01-01">https://blog.logrocket.com/comparing-milkdown-other-wysiwyg-editors/#0001-01-01</a></blockquote><div><article class="article-post">
<p>有许多可用的所见即所得编辑器，这使得选择一个具有挑战性。在这篇文章中，我们将评估Milkdown，一个新的所见即所得编辑器，并与它的一些顶级竞争对手进行比较。以下是我们将要介绍的内容:</p>

<h2 id="milkdown">什么是牛奶？</h2>
<p>Milkdown是一个开源的所见即所得的Markdown编辑器。它的目标是提供一个强大的、可扩展的、可以在任何地方使用的编辑器组件。它是:</p>
<ul>
<li><strong>开源</strong>:您可以<a href="https://github.com/Milkdown/milkdown">读取</a><a href="https://github.com/Milkdown/milkdown">Gi</a><a href="https://github.com/Milkdown/milkdown">t</a><a href="https://github.com/Milkdown/milkdown">H</a><a href="https://github.com/Milkdown/milkdown">ub</a>上的代码，并根据您的需求进行扩展</li>
<li><strong>轻量级</strong>:缩小后，库在125kb左右；缩小压缩后大概有40kb左右<a href="https://bundlephobia.com/package/@milkdown/core@7.0.1">来源</a>。这些在未来可能会改变，因为该库仍处于早期开发阶段</li>
<li>可扩展性:它遵循基于插件的原则，所以你需要的任何特性都可以使用npm包来添加和安装，或者你可以创建自己的来支持你的想法</li>
<li><strong>可定制</strong> : Milkdown让你控制造型</li>
<li><strong>可靠</strong> : Milkdown基于<a href="https://prosemirror.net/">的ProseMirror </a>和<a href="https://remark.js.org/">的Remark </a>，这两者都已经有了庞大的支持性社区，并且经过了充分的检验</li>
<li><strong>集成</strong>:支持所有流行的前端框架，包括React、Vue等。</li>
</ul>
<p>Milkdown内部由两部分组成，<a href="https://milkdown.dev/">根据官方网站</a>:</p>
<ol>
<li>一个微小的核心，它提供了一个插件加载器和各种内部插件</li>
<li>许多插件提供语法、命令和组件</li>
</ol>
<p>基于插件的系统的好处是你可以很容易地启用和禁用定制功能。这也将有助于确保您只发布您需要发布的代码。</p>
<p>它还支持一些很酷的功能，可以通过官方和社区插件获得:</p>
<ol>
<li><a href="https://milkdown.dev/plugin-math">数学</a>:你可以在编辑器里面写你的数学文档；通过<a href="https://en.wikipedia.org/wiki/TeX"> TeX </a>支撑</li>
<li><a href="https://milkdown.dev/preset-gfm">表格</a>:可以在编辑器中添加表格</li>
<li>slash命令:你可以使用Slash命令，就像它在idea、Slack等应用中的实现方式一样。</li>
<li><a href="https://github.com/Milkdown/milkdown/tree/main/packages/plugin-collab">协同</a>:支持共享编辑</li>
</ol>
<h2 id="why-milkdown">为什么是牛奶？</h2>
<p>Milkdown网站对此做了很好的解释:</p>
<blockquote><p>有各种不同的markdown编辑器，如<a href="https://typora.io/"> Typora </a>、<a href="https://github.com/nhn/tui.editor"> tui </a>和<a href="https://bear.app/"> Bear </a>。它们在不同平台上的Markdown中写笔记都很好用。那么，为什么要费心制作牛奶呢？</p>
<p>Milkdown旨在为开发人员提供一个开源解决方案，使他们的编辑器更强大、更有吸引力，并且可以在任何地方使用。</p></blockquote>
<p>大多数编辑没有给你全部的权力来定制一切。有些是有报酬的。有些没有其他的功能丰富。Milkdown采用了一种不同的方法，提供了许多现成的功能。如果你对现有的功能不满意，你可以在基于插件的系统的帮助下创建你正在寻找的特定功能。</p>
<p>你可以在Milkdown网站上找到官方插件，在GitHub 上找到<a href="https://github.com/Saul-Mirone/awesome-milkdown">社区插件。</a></p>
<blockquote><p>注意:因为Milkdown是ProseMirror的包装器，所以您也可以使用它的所有功能，比如协作、linters等。</p></blockquote>
<h3 id="basic-milkdown-example">基本挤奶示例</h3>
<p>下面是一个将Milkdown与vanilla TypeScript一起使用的基本示例。这个例子<a href="https://github.com/Milkdown/examples/tree/main/vanilla-commonmark/src">是受Milkdown文档</a>的启发:</p>
<pre class="language-typescript hljs">// These two imports are important to render the editor
import { Editor, defaultValueCtx, rootCtx } from "@milkdown/core";
import { commonmark } from "@milkdown/preset-commonmark";

// Plugins: Use based on your requirement
import { gfm } from "@milkdown/preset-gfm";
import { nord } from "@milkdown/theme-nord";
import { menu } from "@milkdown/plugin-menu";

import '@milkdown/theme-nord/style.css'
// Default value
const markdown = `
# Test demo.
- [x] Hello
- [ ] World
- [x] Testing
- Remirror
\`\`\`ts
const new = 1
\`\`\`
`;
async function main() {
  await Editor.make()
    .config((ctx) =&gt; {
      // By default it set to `document.body`. In this case we want to load editor on dom with id app
      ctx.set(rootCtx, "#app");
      ctx.set(defaultValueCtx, markdown.trim());
    })
    .use(commonmark)
    .use(nord)
    .use(menu)
    .use(gfm)
    .create();
}
main();
</pre>
<p>你可以在StackBlitz 上玩我们的<a href="https://stackblitz.com/edit/github-w8pjcn?file=README.md">示例演示，在Milkdown网站</a>上玩<a href="https://milkdown.dev/playground">官方演示</a> <a href="https://milkdown.dev/playground">。</a></p>
<h2 id="how-milkdown-compares-quill-js">Milkdown与Quill.js相比如何</h2>
<p>Quill.js是一个流行的开源JavaScript库，用于在web上构建富文本编辑器。</p>
<p>它是轻量级的，易于使用，并且提供了一组强大的特性以及丰富的资源和社区支持。它适用于基本的文本格式化和编辑任务，使用模块化设计方法，并为开发人员提供定制和扩展编辑器功能的灵活性。Quill.js也很好地支持跨浏览器。</p>
<h3 id="key-features-quill-js">关键特征</h3>
<p>Quill.js让你定制编辑器的界面。默认情况下，它支持最小的即插即用接口，并使用语义命名约定，因此不需要学习技术术语来使用编辑器，就像使用ProseMirror一样。</p>
<p>其他功能包括:</p>
<ol>
<li>支持常见的文本格式，如粗体、斜体和其他行业标准功能</li>
<li>能够通过添加或删除模块来为编辑器功能添加自定义插件</li>
<li>一个简单易用的API，允许开发人员轻松地将编辑器与他们现有的应用程序工作流集成</li>
<li>速度和效率，这使它成为需要处理大量用户文本的应用程序的好选择</li>
<li>轻量级大小(缩小:~209kb，缩小+ gzipped: 45.2kb，<a href="https://bundlephobia.com/package/quill@1.3.7"> source </a>)</li>
<li>所有核心功能都是现成的；不需要安装额外的插件</li>
</ol>
<h3 id="milkdown-vs-quill-js">与牛奶稀释的比较</h3>
<p>总的来说，Quill.js的功能比Milkdown少:</p>
<ol>
<li>不支持国际化</li>
<li>不支持拖放(有社区插件，但是你必须根据你的需求来使用它们)</li>
<li>不支持集成前端框架</li>
<li>不支持高级功能，如图形或数学，作为其官方插件的一部分</li>
</ol>
<p>这个例子的灵感来自于<a href="https://quilljs.com/docs/quickstart/"> Quill.js文档</a>:</p>
<pre class="language-html hljs">&lt;html&gt;
  &lt;head&gt;
    &lt;title&gt;Quilljs Example&lt;/title&gt;
    &lt;meta charset="UTF-8" /&gt;
    &lt;link
      href="https://cdn.quilljs.com/1.3.6/quill.snow.css"
      rel="stylesheet"
    /&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;!-- Include stylesheet --&gt;
    &lt;!-- Create the editor container --&gt;
    &lt;div id="editor"&gt;
      &lt;p&gt;Hello World!&lt;/p&gt;
      &lt;p&gt;Some initial &lt;strong&gt;bold&lt;/strong&gt; text&lt;/p&gt;
      &lt;p&gt;&lt;br /&gt;&lt;/p&gt;
    &lt;/div&gt;
    &lt;!-- Include the Quill library --&gt;
    &lt;script src="https://cdn.quilljs.com/1.3.6/quill.js"&gt;&lt;/script&gt;
    &lt;!-- Initialize Quill editor --&gt;
    &lt;script&gt;
      var quill = new Quill("#editor", {
        theme: "snow"
      });
    &lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;
</pre>
<p>你可以在他们的网站上了解更多关于T2的信息。</p>
<h2 id="how-milkdown-compares-prosemirror">Milkdown与ProseMirror相比如何</h2>
<p>ProseMirror也是一个开源的JavaScript库，由构建<a href="https://codemirror.net/"> CodeMirror </a>的同一作者构建。它也有点类似于Quill.js，因为它也提供了一组用于构建富文本编辑器的工具和概念。这是另一个高度可定制和可扩展的库，拥有全面的文档和一个庞大的用户社区，他们帮助构建了广泛的文本编辑功能。</p>
<p>这里需要注意的是，Milkdown是建立在ProseMirror之上的。这意味着无论ProseMirror提供什么，您也可以在Milkdown中使用。</p>
<h3 id="key-features-prosemirror">关键特征</h3>
<ol>
<li>支持协作编辑</li>
<li>模块化架构:与其他架构相比，维护和开发更容易</li>
<li>基于插件的系统</li>
<li>为构建定制插件提供了一个健壮的API</li>
<li><a href="https://prosemirror.net/examples/schema/">可扩展模式</a> : ProseMirror有助于编辑具有定制结构的文档，而无需从头开始编写自己的编辑器。它有更好的文档模型，也更灵活</li>
</ol>
<p>这里有一个受ProseMirror文档启发的<a href="https://prosemirror.net/examples/basic/">基本示例:</a></p>
<pre class="language-html hljs"/>
<p id="editor">你好，普罗塞米尔</p>
<p>这是可编辑的文本。你可以聚焦它，开始打字。</p>
<div id="content">
<p> </p>
<h3>要应用样式，您可以选择一段文本，并从菜单中操作它的<br/>样式。基本模式支持<em>强调</em>，<br/>T5】强文本 <br/> <code>code font</code></h3>
<p> </p>
<p>块级结构可以通过键绑定(尝试使用ctrl-shift-2创建一个2级标题，或者输入一个空的textblock退出父块)或通过菜单来操作。</p>
<p> </p>
<p>尝试使用菜单中的“列表”项将此段落包装在编号列表中。</p>
<p> </p>
<p>Block-level structure can be manipulated with key bindings (try ctrl-shift-2 to create a level 2 heading, or enter in an empty textblock to exit the parent block), or through the menu.</p>
<p>更多来自LogRocket的精彩文章:</p>
<p>Milkdown与TinyMCE相比如何</p>
<p>TinyMCE是另一种挤奶替代品。根据<a href="https://github.com/tinymce/tinymce">他们的GitHub页面</a>:</p>
</div>
<p>TinyMCE被数百万开发人员所使用和信任，它是世界上最具可定制性、可伸缩性和灵活性的富文本编辑器。</p><div class="code-block code-block-54">
<hr/>
<h3>凭借每年超过3.5亿次的下载，我们也是互联网上最值得信赖的企业级开源HTML编辑器之一。目前，全球有超过1亿个产品由Tiny提供支持。作为一个强大的所见即所得编辑器，TinyMCE是按比例构建的，旨在创新，并致力于为困难的边缘情况提供结果。</h3>

<hr/></div>
<pre class="language-javascript hljs">import { EditorState } from "prosemirror-state";
import { EditorView } from "prosemirror-view";
import { Schema, DOMParser } from "prosemirror-model";
import { schema } from "prosemirror-schema-basic";
import { addListNodes } from "prosemirror-schema-list";
import { exampleSetup } from "prosemirror-example-setup";
import "prosemirror-menu/style/menu.css";
// Mix the nodes from prosemirror-schema-list into the basic schema to
// create a schema with list support.
const mySchema = new Schema({
  nodes: addListNodes(schema.spec.nodes, "paragraph block*", "block"),
  marks: schema.spec.marks
});
window.view = new EditorView(document.querySelector("#editor"), {
  state: EditorState.create({
    doc: DOMParser.fromSchema(mySchema).parse(
      document.querySelector("#content")
    ),
    plugins: exampleSetup({ schema: mySchema })
  })
});</pre>
<h2 id="how-milkdown-compares-tinymce">关键特征</h2>
<p>你完全可以使用它的CDN或者自主机</p>
<blockquote><p>与其他类似，它也遵循基于插件的架构，因此您可以根据自己的需求扩展该库</p>
<p>提供辅助功能支持</p></blockquote>
<h3 id="key-features-tinymce">断开链接检查支持</h3>
<ol>
<li>增强的图像编辑</li>
<li>你可以在这里找到功能的完整列表。</li>
<li>与牛奶稀释的比较</li>
<li>TinyMCE是一个高级编辑器，支持许多现成的功能，而Milkdown只支持基本的富文本编辑功能</li>
<li>TinyMCE中提供了可访问性支持</li>
</ol>
<p>TinyMCE提供高级图像支持；您可以在TinyMCE编辑器中编辑图像，它支持图像响应</p>
<h3 id="milkdown-vs-tinymce">许多功能，将来会派上用场。您不需要考虑从头开始创建特征</h3>
<ol>
<li>比Milkdown更好的文档和支持</li>
<li>基本示例</li>
<li>基本的设置示例是从TinyMCE的文档中借用的<a href="https://www.tiny.cloud/docs/tinymce/6/cloud-quick-start/">:</a></li>
<li>Milkdown与Toast UI编辑器相比如何</li>
<li><a href="https://ui.toast.com/"> Toast UI </a>是另一个流行的开源编辑器。它提供了两种编辑模式:Markdown和WYSIWYG，可以随时切换。它遵循CommonMark和GFM (GitHub风格的Markdown)规范，这两个规范都在软件行业中广泛使用。</li>
</ol>
<h3 id="basic-example-tinymce">关键特征</h3>
<p><strong> Viewer </strong>:支持只显示降价数据而不显示编辑区的模式</p>
<pre class="language-html hljs">&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
  &lt;head&gt;
    &lt;meta charset="UTF-8" /&gt;
    &lt;meta name="viewport" content="width=device-width, initial-scale=1" /&gt;
    &lt;script
      src="https://cdn.tiny.cloud/1/no-api-key/tinymce/6/tinymce.min.js"
      referrerpolicy="origin"
    &gt;&lt;/script&gt;
    &lt;script&gt;
      tinymce.init({
        selector: "#mytextarea"
      });
    &lt;/script&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;h1&gt;TinyMCE Quick Start Guide&lt;/h1&gt;
    &lt;form method="post"&gt;
      &lt;textarea id="mytextarea"&gt;Hello, World!&lt;/textarea&gt;
    &lt;/form&gt;
  &lt;/body&gt;
&lt;/html&gt;
</pre>
<h2 id="how-milkdown-compares-toast-ui-editor">国际化:支持英语、荷兰语、韩语、日语、中文、西班牙语、德语、俄语、法语、乌克兰语、土耳其语、芬兰语、捷克语、阿拉伯语、波兰语、加利西亚语、瑞典语、意大利语、挪威语和克罗地亚语，但是您可以扩展它以支持任何语言</h2>
<p><strong>小部件</strong>:这个特性允许您配置规则，用小部件节点替换与特定正则表达式匹配的字符串</p>
<h3 id="key-features-toast-ui"><strong>自定义块</strong>:不支持Markdown的节点可以通过自定义块定义。您可以通过在自定义块中编写解析逻辑来显示您想要的节点</h3>
<ol>
<li>借助官方插件，你也可以扩展编辑器的功能。一些扩展包括:</li>
<li>图表</li>
<li>代码语法突出显示</li>
<li>颜色语法</li>
</ol>
<p>表格合并单元格</p>
<ul>
<li>用户模式</li>
<li>与牛奶稀释的比较</li>
<li>这两个库都是类似的编辑器，但是Toast UI在市场上已经存在很长时间了。它久经考验，并得到社区的支持。</li>
<li>在插件的帮助下，它对图表的支持是与Milkdown的一个区别，milk down目前还不提供图表支持</li>
<li>它有先进的表格支持，也有插件的帮助</li>
</ul>
<h3 id="milkdown-vs-toast-ui">查看器模式仅允许您呈现降价内容</h3>
<p>它支持颜色选择器！如果你想改变你正在编辑的文本的颜色，你可以使用它的插件来实现</p>
<ol>
<li>尽管支持其他一些重要的特性，Milkdown比Toast UI有更好的图形支持</li>
<li>两者都支持国际化、黑暗主题、代码语法高亮</li>
<li>使用Toast UI的原因</li>
<li>如果您的用例需要在编辑期间显示一个<code>iframe</code>、<code>highlight text color</code>或一些其他特殊类型的内容，Toast UI编辑器会非常有帮助，因为它的API不太复杂，并且能够添加定制功能。与其他编辑器相比，创建小部件和插件的学习曲线没有那么复杂。</li>
<li>基本示例</li>
<li>结论</li>
</ol>
<h3 id="reason-use-toast-ui">在这篇文章中，我们讨论了Milkdown，一个新上市的具有强大功能的编辑器。它目前的主要缺点是它的社区不像其他编辑器那样强大:如果出现问题，你可能会花费额外的时间来解决它。因此，使用时风险自担。</h3>
<p>最终，您对编辑器的选择取决于您的需求。虽然其他开源编辑器更适合基本应用程序，但如果您想构建一个具有许多功能的复杂应用程序，Toast UI和TinyMCE是理想的选择。没有一个编辑器能满足所有需求。</p>
<h3 id="basic-example-toast-ui">在插件的帮助下，免费的编辑器可以和那些付费的编辑器表现一样好，特别是当社区像ProseMirror和Quill.js一样强大的时候</h3>
<pre class="language-html hljs">&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
  &lt;head&gt;
    &lt;meta charset="UTF-8" /&gt;
    &lt;meta name="viewport" content="width=device-width, initial-scale=1" /&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;div id="editor"&gt;&lt;/div&gt;
    &lt;script src="src/index.ts" type="module"&gt;&lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;
</pre>
<pre class="language-javascript hljs">import Editor from "@toast-ui/editor";
import "@toast-ui/editor/dist/toastui-editor.css";
const editor = new Editor({
  el: document.querySelector("#editor")
});
</pre>
<h2>您是否添加了新的JS库来提高性能或构建新特性？如果他们反其道而行之呢？</h2>
<p>毫无疑问，前端变得越来越复杂。当您向应用程序添加新的JavaScript库和其他依赖项时，您将需要更多的可见性，以确保您的用户不会遇到未知的问题。</p>
<p>LogRocket 是一个前端应用程序监控解决方案，可以让您回放JavaScript错误，就像它们发生在您自己的浏览器中一样，这样您就可以更有效地对错误做出反应。</p>
<p><a href="https://lp.logrocket.com/blg/javascript-signup" target="_blank" rel="noopener noreferrer"> LogRocket </a>可以与任何应用程序完美配合，不管是什么框架，并且有插件可以记录来自Redux、Vuex和@ngrx/store的额外上下文。您可以汇总并报告问题发生时应用程序的状态，而不是猜测问题发生的原因。LogRocket还可以监控应用的性能，报告客户端CPU负载、客户端内存使用等指标。</p><div class="code-block code-block-28">
<div class="blog-plug inline-plug js-libraries-plug"><h2>自信地构建— <a class="signup" href="https://lp.logrocket.com/blg/javascript-signup" target="_blank" rel="noopener noreferrer">开始免费监控</a>。</h2><p>There’s no doubt that frontends are getting more complex. As you add new JavaScript libraries and other dependencies to your app, you’ll need more visibility to ensure your users don’t run into unknown issues.</p>
<p><a href="https://lp.logrocket.com/blg/javascript-signup">LogRocket</a> is a frontend application monitoring solution that lets you replay JavaScript errors as if they happened in your own browser so you can react to bugs more effectively. </p><a class="signup" href="https://lp.logrocket.com/blg/javascript-signup" target="_blank" rel="noopener noreferrer"><img class="alignnone size-full wp-image-46 jetpack-lazy-image" src="../Images/e8a0ab42befa3b3b1ae08c1439527dc6.png" alt="LogRocket Dashboard Free Trial Banner" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2019/10/errors-screenshot.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/10/errors-screenshot.png"/><noscript><img data-lazy-fallback="1" class="alignnone size-full wp-image-46" src="../Images/e8a0ab42befa3b3b1ae08c1439527dc6.png" alt="LogRocket Dashboard Free Trial Banner" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/10/errors-screenshot.png"/></noscript></a>
<a href="https://lp.logrocket.com/blg/javascript-signup" target="_blank" rel="noopener noreferrer">https://logrocket.com/signup/</a><p><a href="https://lp.logrocket.com/blg/javascript-signup" target="_blank" rel="noopener noreferrer">LogRocket</a> works perfectly with any app, regardless of framework, and has plugins to log additional context from Redux, Vuex, and @ngrx/store. Instead of guessing why problems happen, you can aggregate and report on what state your application was in when an issue occurred. LogRocket also monitors your app’s performance, reporting metrics like client CPU load, client memory usage, and more.
</p><p>Build confidently — <a class="signup" href="https://lp.logrocket.com/blg/javascript-signup" target="_blank" rel="noopener noreferrer">Start monitoring for free</a>.</p></div>


</div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
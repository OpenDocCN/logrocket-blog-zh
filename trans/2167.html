<html>
<head>
<title>Investigating the new CSS viewport-relative units - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>调查新的 CSS 视口相对单位日志博客</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/investigating-new-css-viewport-relative-units/#0001-01-01">https://blog.logrocket.com/investigating-new-css-viewport-relative-units/#0001-01-01</a></blockquote><div><article class="article-post">
<p>CSS 工作组(CSSWG)最近发布了一份更新的<a href="https://www.w3.org/blog/CSS/2021/07/15/css-values-4-viewport-units/" target="_blank" rel="noopener">CSS Values and Units Level 4 specification</a>的工作草案——一份描述 CSS 语法定义和值类型的文档。</p>
<p>这次更新带来了一些有趣的特性，其中包括新的视口单位。让我们看看它们是什么以及它们是如何工作的！</p>
<h2>相对于视口的单位</h2>
<p>我们将从快速修改当前相对于视口的单位开始。</p>
<p>视口百分比长度单位，或所谓的视口相对单位，是相对于初始包含块的 CSS 单位，初始包含块是根(<code>&lt;html&gt;</code>)元素所在的矩形。块本身是基于视口的大小(通常是浏览器窗口或 iframe)，因此单位的类别的名称。</p>
<h3>知名单位</h3>
<p>在这一类别中，有四个您应该已经熟悉的单元:</p>
<ul>
<li><code>vw</code>–视口宽度的 1%</li>
<li><code>vh</code>–视口高度的 1%</li>
<li><code>vmin</code>–较小的<code>vw</code>或<code>vh</code></li>
<li><code>vmax</code>–大于<code>vw</code>或<code>vh</code></li>
</ul>
<p>上述单元在所有现代浏览器中都可用，对<a href="https://caniuse.com/viewport-units" target="_blank" rel="noopener">的支持可以追溯到 IE 10 </a>(除了<code>vmax</code>单元)。</p>
<p>你通常会看到页面元素的动作单元，如模态、覆盖图等，<a href="https://blog.logrocket.com/experimenting-with-fullscreen-api/" target="_blank" rel="noopener">为全屏体验提供动力</a>。</p>
<h3>其他单位</h3>
<p>现在，除了上述四个单元，新规范实际上还定义了另外两个:<code>vi</code>和<code>vb</code>。他们成为 4 级的一部分已经有一段时间了，但是<a href="https://caniuse.com/mdn-css_types_length_vi" target="_blank" rel="noopener">仍然没有得到任何知名浏览器的支持。尽管如此，它们仍然存在，这意味着最终浏览器会支持它们，所以了解它们是如何工作的是值得的。</a></p>
<p>这两个单位都依赖于<code>writing-mode</code>属性，使得它们的值绑定到用户的语言方向。</p>
<ul>
<li><code>vi</code>–内联方向视口尺寸的 1%</li>
<li><code>vb</code>–块方向上视口尺寸的 1%</li>
</ul>
<p>在水平书写的语言中，如英语，单位分别相当于<code>vw</code>和<code>vh</code>。对于像日语这样的垂直书写的语言，单位是互换的，使得<code>vi</code>等于<code>vh</code>，而<code>vb</code>等于<code>vw</code>。</p>
<h2>浏览器 UI 的问题</h2>
<p>在讨论新单元之前，我们首先需要了解为什么要引入它们。</p>
<p>问题出在用户代理界面，也就是浏览器的 UI。</p>
<p>虽然浏览器通常可以访问桌面上的大屏幕，但移动设备却不能。这就是为什么移动浏览器经常最小化他们的 UI——比如搜索栏——以节省用户滚动时的空间。</p>
<figure id="attachment_67184" aria-describedby="caption-attachment-67184" class="wp-caption aligncenter"><img data-attachment-id="67184" data-permalink="https://blog.logrocket.com/investigating-new-css-viewport-relative-units/ui-expanded-retracted-safari-ios-15/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2021/09/ui-expanded-retracted-safari-ios-15.png" data-orig-size="730,756" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="ui-expanded-retracted-safari-ios-15" data-image-description="" data-image-caption="&lt;p&gt;The UI expanded and retracted in Safari iOS 15&lt;/p&gt;&#10;" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2021/09/ui-expanded-retracted-safari-ios-15-290x300.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2021/09/ui-expanded-retracted-safari-ios-15.png" decoding="async" class="size-full wp-image-67184 jetpack-lazy-image" src="../Images/862495ca7b6d863f266fe42b8e0cd5fd.png" alt="The UI expanded and retracted in Safari iOS 15" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2021/09/ui-expanded-retracted-safari-ios-15.png 730w, https://blog.logrocket.com/wp-content/uploads/2021/09/ui-expanded-retracted-safari-ios-15-290x300.png 290w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2021/09/ui-expanded-retracted-safari-ios-15.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2021/09/ui-expanded-retracted-safari-ios-15.png"/><noscript><img data-lazy-fallback="1" data-attachment-id="67184" data-permalink="https://blog.logrocket.com/investigating-new-css-viewport-relative-units/ui-expanded-retracted-safari-ios-15/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2021/09/ui-expanded-retracted-safari-ios-15.png" data-orig-size="730,756" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="ui-expanded-retracted-safari-ios-15" data-image-description="" data-image-caption="&lt;p&gt;The UI expanded and retracted in Safari iOS 15&lt;/p&gt;&#10;" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2021/09/ui-expanded-retracted-safari-ios-15-290x300.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2021/09/ui-expanded-retracted-safari-ios-15.png" decoding="async" loading="lazy" class="size-full wp-image-67184" src="../Images/862495ca7b6d863f266fe42b8e0cd5fd.png" alt="The UI expanded and retracted in Safari iOS 15" srcset="https://blog.logrocket.com/wp-content/uploads/2021/09/ui-expanded-retracted-safari-ios-15.png 730w, https://blog.logrocket.com/wp-content/uploads/2021/09/ui-expanded-retracted-safari-ios-15-290x300.png 290w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2021/09/ui-expanded-retracted-safari-ios-15.png"/></noscript><figcaption id="caption-attachment-67184" class="wp-caption-text">The UI expanded and retracted in Safari iOS 15</figcaption></figure>
<p>这允许在屏幕上一次显示更多的内容，但是引入了一个问题:应该如何实现与视口相关的单元？</p>
<p>从历史上看，单元的实际值被改变以适应浏览器的当前 UI 状态。事实证明，这不利于用户体验，因为用户滚动时内容会不断移动。</p>
<p>因此，<a href="https://bugs.webkit.org/show_bug.cgi?id=141832" target="_blank" rel="noopener"> Safari </a>、Chrome(大约一年后)和其他浏览器供应商改变了这种行为，使浏览器 UI 最小化时视口相对单位依赖于视口大小。这修复了一些问题，但引入了新的问题。</p>
<p>现在，对任何视窗单元使用<code>100</code>意味着当页面最大化时，部分页面可能会被浏览器的用户界面隐藏。这反过来导致这种做法成为移动设备上的反模式，迫使开发人员实现 JavaScript 变通方法。</p>
<p>这就是新的单位和规格更新介入的地方。</p>
<h2>相对于视口的单位变量</h2>
<p>事实上，新的单元并不是真正的新。相反，它们只是我们上面提到的已经存在的单位的变体，通过视口大小来区分。</p>
<p>让我们看看这是什么意思。</p>
<h3>默认视口</h3>
<p>以<code>v*</code>开始的当前单位现在正式称为 UA-默认视口百分比单位，它们视口大小的实现取决于用户代理。这意味着这些单元的行为在不同的浏览器之间会有所不同，同时要记住当前的、非官方的行业标准。</p>
<p>所以，重申一下——这没什么新鲜的。<code>vh</code>、<code>vw</code>、<code>vmin</code>、<code>vmax</code>、<code>vb</code>和<code>vi</code>单元保持变更前的规格。这确保了向后兼容性。</p>
<h3>大视窗和小视窗</h3>
<p>现在，当我们进入大的和小的视口百分比单位时，事情变得有趣了。顾名思义，这些单元对 UA 应该如何调整其视口提出了具体的要求。</p>
<p>对于大视口单位，视口的大小必须考虑到最大可能的视口，假设任何动态浏览器用户界面都被收回。这使得开发人员可以让他们的设计充满整个视口，同时记住浏览器 UI 可能至少会与视口的一部分重叠。</p>
<p>这个大视口变体从<code>lv*</code>开始，包括<code>lvh</code>、<code>lvw</code>、<code>lvmin</code>、<code>lvmax</code>、<code>lvb</code>和<code>lvi</code>。</p>
<p>对于小的视口单元，情况正好相反。在这种情况下，必须在假设任何动态界面都展开的情况下调整视口的大小，以确定可能的最小视口。这确保了开发人员的设计在 UA 界面展开时填充整个视口，而在 UI 收缩时可能会留下空白空间。</p><div class="code-block code-block-54">
<hr/>
<h3>更多来自 LogRocket 的精彩文章:</h3>

<hr/></div>
<p>这个小视窗变体从<code>sv*</code>开始，包括<code>svh</code>、<code>svw</code>、<code>svmin</code>、<code>svmax</code>、<code>svb</code>和<code>svi</code>。</p>
<h3>动态视口</h3>
<p>最后，还有动态视口百分比单位。这将允许开发人员使用“历史”行为，其中视口大小(以及单位值)取决于浏览器界面是扩展还是收缩。</p>
<p>虽然这意味着开发人员有了更多的控制和选择，但这种变体也带来了警告。</p>
<p>使用它会导致内容移动，降低 UX。其他要考虑的事情是重新计算期间的性能影响和可能的动画。这些措施既可以改善也可以进一步降低 UX，取决于普遍获得的实施情况。</p>
<p>动态视口变体从<code>dv*</code>开始，包括<code>dvh</code>、<code>dvw</code>、<code>dvmin</code>、<code>dvmax</code>、<code>dvb</code>和<code>dvi</code>。</p>
<h2>结论</h2>
<p>总的来说，规范中新的视口相关单位意味着开发人员可以更精确地控制他们的设计相对于用户视口的行为。</p>
<p>然而，权力越大，责任越大。当新单元最终出现在浏览器中时，对于开发者来说，这不仅意味着多了一件需要控制的事情，也意味着多了一件需要记住的事情。虽然供应商肯定会尽最大努力明智地实现这些单元，但现在对开发人员来说，确保并提供良好的用户体验比以前更加重要。</p><div class="code-block code-block-25">
<div class="blog-plug inline-plug css-plug"><h2>你的前端是否占用了用户的 CPU？</h2><p>随着 web 前端变得越来越复杂，资源贪婪的特性对浏览器的要求越来越高。如果您对监控和跟踪生产环境中所有用户的客户端 CPU 使用、内存使用等感兴趣，</p><a target="_blank" href="https://lp.logrocket.com/blg/css-signup">try LogRocket</a><p>.</p><a class="signup" href="https://lp.logrocket.com/blg/css-signup" target="_blank" rel="noopener noreferrer"><img class="alignnone size-full wp-image-46 jetpack-lazy-image" src="../Images/dacb06c713aec161ffeaffae5bd048cd.png" alt="LogRocket Dashboard Free Trial Banner" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2019/12/cpu-memory-usage.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/12/cpu-memory-usage.png"/><noscript><img data-lazy-fallback="1" class="alignnone size-full wp-image-46" src="../Images/dacb06c713aec161ffeaffae5bd048cd.png" alt="LogRocket Dashboard Free Trial Banner" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/12/cpu-memory-usage.png"/></noscript></a><a href="https://lp.logrocket.com/blg/css-signup" target="_blank" rel="noopener noreferrer">https://logrocket.com/signup/</a><p>LogRocket 就像是网络和移动应用的 DVR，记录你的网络应用或网站上发生的一切。您可以汇总和报告关键的前端性能指标，重放用户会话和应用程序状态，记录网络请求，并自动显示所有错误，而不是猜测问题发生的原因。</p><p>现代化您调试 web 和移动应用的方式— <a class="signup" href="https://lp.logrocket.com/blg/css-signup" target="_blank" rel="noopener noreferrer">开始免费监控</a>。</p></div>
</div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
<html>
<head>
<title>Speed up JavaScript builds with spack bundler in Rust - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>Rust - LogRocket 博客中的 spack bundler 加速 JavaScript 构建</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/using-spack-bundler-in-rust-to-speed-up-builds/#0001-01-01">https://blog.logrocket.com/using-spack-bundler-in-rust-to-speed-up-builds/#0001-01-01</a></blockquote><div><article class="article-post">
<p>因为大多数 JavaScript bundlers 和 transpilers 都是用 JavaScript 本身编写的，所以它们往往缺乏效率。然而，如果 bundlers 和 transpilers 是用更快、更好编译和优化的语言编写的，比如 Python 或 Rust，它们可以运行得更快。</p>
<p/>
<p>在本文中，我们将讨论如何在 Rust 中使用带有<code>swc-project</code>的<code>spack</code>捆绑器来加速 JavaScript 构建。</p>
<h2 id="whatisswcproject">什么是<code>swc-project</code>？</h2>
<p>是一个用 Rust 写的 bundlers 和 transpilers 的集合。<code>swc-project</code>可以 transpile Typescript，JSX，TSX，以及其他版本的 JavaScript。和巴别塔一样，SWC 是一个阅读源代码的工具；然而，<a href="https://blog.logrocket.com/why-you-should-use-swc/"> SWC 的工作速度比巴别塔</a>快大约 20 倍。</p>
<p><code>swc</code>可以使用<code>.swcrc</code>文件进行配置；看不同配置<a href="https://swc.rs/docs/configuring-swc">这里</a>。</p>
<h2 id="transpilingthroughswcwithspack">通过<code>swc</code>与<code>spack</code>进行传输</h2>
<p><code>spack</code>是一个 JS 捆绑器，支持通过<code>swc</code>进行传输。它是<code>webpack</code>的的<a href="https://blog.logrocket.com/benchmarking-bundlers-2020-rollup-parcel-webpack">替代品，支持死代码消除和树抖动。</a></p>
<p><code>spack</code>纯用 Rust 写，Deno 用；Deno 最近在<code>spack</code>的基础上增加了新的 TypeScript 捆绑和传输选项。</p>
<p><code>spack</code>内部依靠<code>swc_bundler</code>板条箱进行资产捆绑。</p>
<pre>const { config } = require("@swc/core/spack");
const path = require("path");
module.exports = config({
 // starting point
  entry: {
    web: path.join(__dirname, "src", "index.ts"),
  },
 // output file
  output: {
    path: path.join(__dirname, "dist"),
  },
  module: {},
});
</pre>
<h2 id="configuringbundlersandtranspilers">配置捆扎机和传输机</h2>
<p><code>spack</code>使用<code>.swcrc</code>文件为传输器配置，使用<code>spack.config.js</code>文件为捆扎机配置。</p>
<p>要了解它是如何工作的，创建一个名为<code>spack-demo</code>的目录。在<code>spack-demo</code>文件夹中，添加<code>index.js</code>文件和多个演示文件。将<code>spack.config.js</code>和<code>.swcrc</code>文件添加到目录中。</p>
<p>文件结构应该是这样的。</p>
<pre>├── index.js
├── spack.config.js
└── .swcrc
</pre>
<p>使用<code>npm i @swc/core @swc/cli @swc/helpers</code>安装所需的软件包。</p>
<p>对于捆绑:<code>spack.config.js</code></p>
<pre>// importing config creator
const { config } = require("@swc/core/spack");

// import path module
const path = require("path");

// export config
module.exports = config({

// start file
  entry: {
    build: path.join(__dirname, "index.js"),
  },

// output file
  output: {
    path: path.join(__dirname),
  },
  module: {},
});
</pre>
<p>用于运输:<code>.swcrc</code></p>
<pre>{
    "jsc": {
// transpile to es2015
        "target": "es2015",
        "parser": {
// file use ecmascript
            "syntax": "ecmascript",
        }
    }
}
</pre>
<h2 id="usingspacktobundlejavascript">使用<code>spack</code>捆绑 JavaScript</h2>
<p>我们之前添加的样板代码可以用于 React.js 和 Node.js 等大多数代码库所需的基本绑定和传输。</p>
<p>对于一个演示，用 index.js 创建一个名为<code>mod</code>的目录，并在根目录中导入<code>index.js</code>。文件结构应该是这样的。</p>
<pre>├── index.js
├── mod
│   └── index.js
├── spack.config.js
└── .swcrc
</pre>
<p>请注意，<code>mod/index.js</code>和<code>index.js</code>包含用于演示<code>spack</code>捆绑功能的伪代码:</p>
<p><code>mod/index.js</code></p>
<pre>export const sum=(a,b)=&gt;a+b;
</pre>
<p><code>index.js</code></p>
<pre>import {sum as add} from "./mod"
console.log(add(1,2));
</pre>
<p><code>build.js</code>(该文件由<code>spack</code>生成)</p>
<pre>var sum = function(a, b) {
    return a + b;
};
console.log(sum(1,2));
</pre>

<p><code>spack</code>根据<code>.swcrc</code>文件中的<code>target</code>键，使用<code>swc</code>转换成多个版本的 JavaScript。<code>swc</code>支持 ES5、ES2015、ES2016、ES2018、ES2019 和 ES2020。</p>
<p>在我们之前的演示中，我们编写了由新版 es 2015 Javascript 支持的代码，但是使用<code>spack</code>，我们可以将代码转换到旧版浏览器支持的旧版 Javascript 中。几乎所有的浏览器都支持 JavaScript 的 ES5 版本。</p>
<p>要了解它是如何工作的，将<code>target</code>改为<code>es5</code>，并给<code>mod/index.js</code>添加一些新的代码。</p>
<p><code>mod/index.js</code></p><div class="code-block code-block-54">
<hr/>
<h3>更多来自 LogRocket 的精彩文章:</h3>

<hr/></div>
<pre>export const sum=(a,b)=&gt;({...a,...b})
</pre>
<p><code>.swcrc</code></p>
<pre>{
    "jsc": {
// transpile to es5
        "target": "es5",
        "parser": {
// file use ecmascript
            "syntax": "ecmascript",
        }
    }
}
</pre>
<p>您的<code>build.js</code>输出文件现在将如下所示:</p>
<pre>function _defineProperty(obj, key, value) {
    if (key in obj) {
        Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
        });
    } else {
        obj[key] = value;
    }
    return obj;
}
function _objectSpread(target) {
    for(var i = 1; i &lt; arguments.length; i++){
        var source = arguments[i] != null ? arguments[i] : {
        };
        var ownKeys = Object.keys(source);
        if (typeof Object.getOwnPropertySymbols === "function") {
            ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
                return Object.getOwnPropertyDescriptor(source, sym).enumerable;
            }));
        }
        ownKeys.forEach(function(key) {
            _defineProperty(target, key, source[key]);
        });
    }
    return target;
}
var sum = function(a, b) {
    return _objectSpread({
    }, a, b);
};
console.log(sum({
}, {
}));
</pre>
<p>当您仔细查看<code>build.js</code>输出文件时，您会发现它现在包含一些额外的代码来支持新的 JS 特性(比如 spread operator)。所有额外的代码都是由<code>spack</code>注入的，这样我们的代码可以在新旧浏览器上完美运行，包括那些只支持 ES5 版本 JavaScript 的浏览器。</p>
<h2 id="bundlingmultiplejavascriptentries">捆绑多个 JavaScript 条目</h2>
<p>当处理多个包时，可以通过缓存公共文件或模块并避免重复工作来优化构建。<code>spack</code>同时支持多个捆绑包，跨捆绑包缓存通用文件。</p>
<p><code>spack.config.js</code></p>
<pre>const { config } = require("@swc/core/spack");
const path = require("path");
module.exports = config({
  entry: {
    web: path.join(__dirname, "src", "index.js"),
    node: path.join(__dirname, "src", "node.js"),
  },
  output: {
    path: path.join(__dirname, "dist"),
  },
  module: {},
});
</pre>
<h2 id="bundlingtypescript">捆绑打字稿</h2>
<p><code>spack</code>由 Deno 用于传输和捆绑打字稿。它完全支持使用<code>swc</code>的 TypeScript transpilation 和 bundling。<code>swc</code>编译通过了 TypeScript repo 的所有测试。将<code>syntax</code>键改为 TypeScript 可以支持 TypeScript。</p>
<pre>{
    "jsc": {
// transpile to es5
        "target": "es5",
        "parser": {
// file use ecmascript
            "syntax": "typescript",
        }
    }
}
</pre>
<h2>结论</h2>
<p><code>spack</code>还处于早期阶段，但在它可以生产之前，它仍然可以在 Rust <code>swc-project</code>中用于开发环境中的捆绑。<code>spack</code>也可以作为一个基础库，用来创建一个更健壮的具有多种特性的捆绑器，就像 Deno 用来捆绑打字稿一样。</p><div class="code-block code-block-21">
<div class="blog-plug inline-plug typescript-plug"><h2><a class="signup" href="https://lp.logrocket.com/blg/typescript-signup" target="_blank" rel="noopener noreferrer"> LogRocket </a>:全面了解您的网络和移动应用</h2>
<a href="https://lp.logrocket.com/blg/typescript-signup" class="signup" target="_blank" rel="noopener noreferrer"><img class="alignnone size-full wp-image-46 jetpack-lazy-image" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/><noscript><img data-lazy-fallback="1" class="alignnone size-full wp-image-46" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/></noscript></a>
<p>LogRocket 是一个前端应用程序监控解决方案，可以让您回放问题，就像问题发生在您自己的浏览器中一样。LogRocket 不需要猜测错误发生的原因，也不需要向用户询问截图和日志转储，而是让您重放会话以快速了解哪里出错了。它可以与任何应用程序完美配合，不管是什么框架，并且有插件可以记录来自 Redux、Vuex 和@ngrx/store 的额外上下文。</p>
<p>除了记录 Redux 操作和状态，LogRocket 还记录控制台日志、JavaScript 错误、堆栈跟踪、带有头+正文的网络请求/响应、浏览器元数据和自定义日志。它还使用 DOM 来记录页面上的 HTML 和 CSS，甚至为最复杂的单页面和移动应用程序重新创建像素级完美视频。</p><div class="code-block code-block-29">
<div class="blog-plug inline-plug rust-plug"><h2><a href="https://lp.logrocket.com/blg/rust-signup" target="_blank">log rocket</a>:Rust 应用的 web 前端的全面可见性</h2><p>调试 Rust 应用程序可能很困难，尤其是当用户遇到难以重现的问题时。如果您对监控和跟踪 Rust 应用程序的性能、自动显示错误、跟踪缓慢的网络请求和加载时间感兴趣，</p><a href="https://lp.logrocket.com/blg/rust-signup" target="_blank">try LogRocket</a><p>. </p><a class="signup" href="https://lp.logrocket.com/blg/rust-signup" target="_blank" rel="noopener noreferrer"><img class="alignnone size-full wp-image-46 jetpack-lazy-image" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/><noscript><img data-lazy-fallback="1" class="alignnone size-full wp-image-46" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/></noscript></a><p>LogRocket 就像是网络和移动应用程序的 DVR，记录你的 Rust 应用程序上发生的一切。您可以汇总并报告问题发生时应用程序的状态，而不是猜测问题发生的原因。LogRocket 还可以监控应用的性能，报告客户端 CPU 负载、客户端内存使用等指标。</p><p>现代化调试 Rust 应用的方式— <a class="signup" href="https://lp.logrocket.com/blg/rust-signup" target="_blank" rel="noopener noreferrer">开始免费监控</a>。</p></div>


</div>
<a class="signup" href="https://lp.logrocket.com/blg/typescript-signup" target="_blank" rel="noopener noreferrer">Try it for free</a><p>.</p></div>
</div>

<p class="clearfix"/>
 <p class="clearfix"/>
</article>

</div>    
</body>
</html>
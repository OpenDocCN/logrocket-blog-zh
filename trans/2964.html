<html>
<head>
<title>Creating an RN video calling app with react-native-webrtc - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>用 react-native-webrtc-log rocket Blog 创建 RN 视频通话 app</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/creating-rn-video-calling-app-react-native-webrtc/#0001-01-01">https://blog.logrocket.com/creating-rn-video-calling-app-react-native-webrtc/#0001-01-01</a></blockquote><div><article class="article-post">
<p><a href="https://webrtc.org/" target="_blank" rel="noopener"> WebRTC </a> (web 实时通信)是一个开源项目，使 web 应用程序能够捕获和传输音频和视频流。该技术在所有现代浏览器和主要本机平台上都可用。它是由谷歌、苹果、微软等公司开发和维护的。</p>
<p>在这一点上，WebRTC 是一种成熟的技术，并且是构建视频会议应用程序的事实上的方法。</p>
<h2 id="building-our-demo-a-react-native-chat-application">构建我们的演示:一个 React 本地聊天应用程序</h2>
<p>我们将使用<a href="https://github.com/react-native-webrtc/react-native-webrtc" target="_blank" rel="noopener"> react-native-webrtc </a>插件构建一个 React 原生应用程序。当我们实现应用程序时，我们将学习 WebRTC 的基础知识。</p>
<p>这是该应用程序的最终版本。它实际上是在我的手机上发起的视频通话，并在我的笔记本电脑上接听。启动网络摄像头后，我们可以开始新的视频通话或加入现有的视频通话。</p>
<p>如果我们开始通话，我们会得到一个唯一的 ID。其他人可以通过在文本框中键入该 ID 并按下<strong>应答呼叫</strong>按钮来加入该呼叫。整个项目的<a href="https://github.com/cristian-rita/react-native-webrtc-example" target="_blank" rel="noopener">代码可以在这里</a>找到。</p>
<p><img data-attachment-id="111704" data-permalink="https://blog.logrocket.com/creating-rn-video-calling-app-react-native-webrtc/chat-apps/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/05/chat-apps.jpeg" data-orig-size="236,512" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Chat apps" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/05/chat-apps-138x300.jpeg" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/05/chat-apps.jpeg" decoding="async" class="aligncenter size-full wp-image-111704 jetpack-lazy-image" src="../Images/6636ea81554bbf0b4645ff4aaa531294.png" alt="Chat Apps" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2022/05/chat-apps.jpeg 236w, https://blog.logrocket.com/wp-content/uploads/2022/05/chat-apps-138x300.jpeg 138w" data-lazy-sizes="(max-width: 236px) 100vw, 236px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2022/05/chat-apps.jpeg?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/05/chat-apps.jpeg"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="111704" data-permalink="https://blog.logrocket.com/creating-rn-video-calling-app-react-native-webrtc/chat-apps/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/05/chat-apps.jpeg" data-orig-size="236,512" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Chat apps" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/05/chat-apps-138x300.jpeg" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/05/chat-apps.jpeg" decoding="async" loading="lazy" class="aligncenter size-full wp-image-111704" src="../Images/6636ea81554bbf0b4645ff4aaa531294.png" alt="Chat Apps" srcset="https://blog.logrocket.com/wp-content/uploads/2022/05/chat-apps.jpeg 236w, https://blog.logrocket.com/wp-content/uploads/2022/05/chat-apps-138x300.jpeg 138w" sizes="(max-width: 236px) 100vw, 236px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/05/chat-apps.jpeg"/></noscript>
<h2 id="installation">装置</h2>
<p>首先，让我们创建一个空白的 React 原生项目:</p>
<pre class="language-bash hljs">npx react-native init ReactNativeWebRTCExample</pre>
<p>然后，我们需要安装 react-native-webrtc:</p>
<pre class="language-bash hljs">npm install react-native-webrtc</pre>
<p>为了完成安装，根据平台的不同，我们有一些额外的步骤。</p>
<h3 id="ios-implementation">iOS 实施</h3>
<p>安装 CocoaPods:</p>
<pre class="language-bash hljs">npx pod-install</pre>
<p>更新<code>Info.plist</code>文件中的权限:</p>
<pre class="language-xml hljs">&lt;key&gt;NSCameraUsageDescription&lt;/key&gt;
&lt;string&gt;Camera permission description&lt;/string&gt;
&lt;key&gt;NSMicrophoneUsageDescription&lt;/key&gt;
&lt;string&gt;Microphone permission description&lt;/string&gt;</pre>
<h3 id="android-implementation">Android 实现</h3>
<p>类似地，在 Android 上，我们需要在<code>AndroidManifest.xml</code>文件中请求这些权限:</p>
<pre class="language-xml hljs">    &lt;uses-permission android:name="android.permission.ACCESS_NETWORK_STATE" /&gt;
    &lt;uses-permission android:name="android.permission.BLUETOOTH" /&gt;
    &lt;uses-permission android:name="android.permission.CAMERA" /&gt;
    &lt;uses-permission android:name="android.permission.INTERNET" /&gt;
    &lt;uses-permission android:name="android.permission.MODIFY_AUDIO_SETTINGS" /&gt;
    &lt;uses-permission android:name="android.permission.RECORD_AUDIO" /&gt;
    &lt;uses-permission android:name="android.permission.SYSTEM_ALERT_WINDOW" /&gt;
    &lt;uses-permission android:name="android.permission.WAKE_LOCK" /&gt;</pre>
<p>我们还需要通过在 Android 部分中向<code>android/app/build.gradle</code>添加以下代码来启用 Java 8 支持:</p>
<pre class="language-gradle hljs">compileOptions {
        sourceCompatibility JavaVersion.VERSION_1_8
        targetCompatibility JavaVersion.VERSION_1_8
}</pre>
<p>我们完成了安装。</p>
<h2 id="creating-the-real-time-chat-app">创建实时聊天应用程序</h2>
<p>接下来，我们需要创建一个<code>RTCPeerConnection</code>的实例，它将管理本地计算机和远程对等体之间的连接。</p>
<p>虽然数据传输是点对点的，但是我们确实需要一些服务器。其中之一是 ICE(交互式连接建立)服务器。为了建立对等连接，两个客户端需要找到发现彼此的方法。因为 NAT，这可能会很棘手，所以 ICE 服务器负责为我们做所有的工作。谢天谢地，谷歌免费提供 ICE 服务器:</p>
<pre class="language-javascript hljs">//App.js

  const [remoteStream, setRemoteStream] = useState(null);
  const [localStream, setLocalStream] = useState(null);
  const [webcamStarted, setWebcamStarted] = useState(false);
  const [channelId, setChannelId] = useState(null);
  const pc = useRef();
  const servers = {
    iceServers: [
      {
        urls: [
          'stun:stun1.l.google.com:19302',
          'stun:stun2.l.google.com:19302',
        ],
      },
    ],
    iceCandidatePoolSize: 10,
  };</pre>
<p>这里我们声明 ICE 服务器的配置。我们还声明了一些很快就会用到的状态变量。</p>
<p>下一步，我们将从用户的摄像机中捕获本地流，并将其添加到 RTCPeerConnection 中。<code>MediaDevices</code>接口提供对相机和麦克风等已连接媒体输入的访问。通过调用<code>mediaDevices.getUserMedia()</code>方法，我们要求用户授予访问这些媒体输入的权限。我们还将更新本地和远程曲目(音频和视频曲目):</p>
<pre class="language-javascript hljs">const startWebcam = async () =&gt; {
    pc.current = new RTCPeerConnection(servers);
    const local = await mediaDevices.getUserMedia({
      video: true,
      audio: true,
    });
    pc.current.addStream(local);
    setLocalStream(local);

    const remote = new MediaStream();
    setRemoteStream(remote);

    // Push tracks from local stream to peer connection
    local.getTracks().forEach(track =&gt; {
      pc.current.getLocalStreams()[0].addTrack(track);
    });

    // Pull tracks from peer connection, add to remote video stream
    pc.current.ontrack = event =&gt; {
      event.streams[0].getTracks().forEach(track =&gt; {
        remote.addTrack(track);
      });
    };

    pc.current.onaddstream = event =&gt; {
      setRemoteStream(event.stream);
    };
  };</pre>
<p>此时，我们创建了一个<code>RTCPeerConnection</code>来管理我们的对等连接。我们从本地对等点捕获视频和音频流，并将该流添加到<code>RTCPeerConnection</code>。</p>
<p>我们现在准备好连接到另一个对等体。为此，我们需要一个信令服务器。它的工作是充当中介，让两个对等体建立连接。作为发起者，你需要发出开始打电话的信号。其他对等方也必须发出信号，表示他们想要连接到您的特定视频通话。</p>
<p>WebRTC 对如何发信号没有自己的看法。我们可以通过 WebSockets、HTTP 或任何我们喜欢的方式来实现。在本演示中，我们将使用 Firebase Firestore 作为信令服务器。</p>
<p>连接到<a href="https://blog.logrocket.com/storing-retrieving-data-react-native-apps-firebase/" target="_blank" rel="noopener"> Firebase </a>和使用 Firestore 不在本文讨论范围之内，所以我将让您创建 Firebase 应用程序并从 React Native 连接到它们。我将使用 https://rnfirebase.io/的<a href="https://rnfirebase.io/" target="_blank" rel="noopener">与 Firebase 交互。</a></p>
<p>所有这些都准备好了，我们现在可以创建发起呼叫的函数:</p>
<pre class="language-javascript hljs">   const startCall = async () =&gt; {
    const channelDoc = firestore().collection('channels').doc();
    const offerCandidates = channelDoc.collection('offerCandidates');
    const answerCandidates = channelDoc.collection('answerCandidates');

    setChannelId(channelDoc.id);

    pc.current.onicecandidate = async event =&gt; {
      if (event.candidate) {
        await offerCandidates.add(event.candidate.toJSON());
      }
    };

    //create offer
    const offerDescription = await pc.current.createOffer();
    await pc.current.setLocalDescription(offerDescription);

    const offer = {
      sdp: offerDescription.sdp,
      type: offerDescription.type,
    };

    await channelDoc.set({offer});

    // Listen for remote answer
    channelDoc.onSnapshot(snapshot =&gt; {
      const data = snapshot.data();
      if (!pc.current.currentRemoteDescription &amp;&amp; data?.answer) {
        const answerDescription = new RTCSessionDescription(data.answer);
        pc.current.setRemoteDescription(answerDescription);
      }
    });

    // When answered, add candidate to peer connection
    answerCandidates.onSnapshot(snapshot =&gt; {
      snapshot.docChanges().forEach(change =&gt; {
        if (change.type === 'added') {
          const data = change.doc.data();
          pc.current.addIceCandidate(new RTCIceCandidate(data));
        }
      });
    });
  };</pre>
<p>我知道这很多，但是让我们试着分解一下。</p>
<p>在 Firestore，我们保存了一个文档<code>channels</code>，包含所有的沟通渠道。每个信道 ID 代表一个唯一的呼叫 ID。作为信令机制的一部分，我们创建了两个子集合:<code>offerCandidates</code>和<code>answerCandidates</code>。</p>
<p><code>createOffer()</code>方法启动 SDP 提议的创建，目的是启动到远程对等点的新 WebRTC 连接。我们将此提议写入 Firestore 上的频道文档。然后我们监听<code>channelDoc</code>更新。在收到一个回答后，我们创建一个<code>RTCSessionDescription</code>对象。协商两个对等体之间的连接包括来回交换<code>RTCSessionDescription</code>对象。</p>
<p>如果一个新的文档被添加到<code>answerCandidates</code>子集合中，这意味着有人已经回答了，所以我们将这个新的候选文档添加到<code>RTCPeerConnection</code>中。</p>
<p>类似地，让我们实现用于应答呼叫的函数:</p>
<pre class="language-javascript hljs">const joinCall = async () =&gt; {
    const channelDoc = firestore().collection('channels').doc(channelId);
    const offerCandidates = channelDoc.collection('offerCandidates');
    const answerCandidates = channelDoc.collection('answerCandidates');

    pc.current.onicecandidate = async event =&gt; {
      if (event.candidate) {
        await answerCandidates.add(event.candidate.toJSON());
      }
    };

    const channelDocument = await channelDoc.get();
    const channelData = channelDocument.data();

    const offerDescription = channelData.offer;

    await pc.current.setRemoteDescription(
      new RTCSessionDescription(offerDescription),
    );

    const answerDescription = await pc.current.createAnswer();
    await pc.current.setLocalDescription(answerDescription);

    const answer = {
      type: answerDescription.type,
      sdp: answerDescription.sdp,
    };

    await channelDoc.update({answer});

    offerCandidates.onSnapshot(snapshot =&gt; {
      snapshot.docChanges().forEach(change =&gt; {
        if (change.type === 'added') {
          const data = change.doc.data();
          pc.current.addIceCandidate(new RTCIceCandidate(data));
        }
      });
    });
  };</pre>
<p>在这种情况下，我们创建一个<code>answerOffer</code>并更新 Firestore 中的<code>channelDoc</code>。我们还监听<code>offerCandidates</code>子集合中的任何变化。或多或少，我们在模仿开始呼叫的行为。</p>
<p>最后，当我们想要开始或加入一个呼叫时，我们需要调用这些函数:</p>
<pre class="language-javascript hljs">&lt;KeyboardAvoidingView style={styles.body} behavior="position"&gt;
      &lt;SafeAreaView&gt;
        {localStream &amp;&amp; (
          &lt;RTCView
            streamURL={localStream?.toURL()}
            style={styles.stream}
            objectFit="cover"
            mirror
          /&gt;
        )}

        {remoteStream &amp;&amp; (
          &lt;RTCView
            streamURL={remoteStream?.toURL()}
            style={styles.stream}
            objectFit="cover"
            mirror
          /&gt;
        )}
        &lt;View style={styles.buttons}&gt;
          {!webcamStarted &amp;&amp; (
            &lt;Button title="Start webcam" onPress={startWebcam} /&gt;
          )}
          {webcamStarted &amp;&amp; &lt;Button title="Start call" onPress={startCall} /&gt;}
          {webcamStarted &amp;&amp; (
            &lt;View style={{flexDirection: 'row'}}&gt;
              &lt;Button title="Join call" onPress={joinCall} /&gt;
              &lt;TextInput
                value={channelId}
                placeholder="callId"
                minLength={45}
                style={{borderWidth: 1, padding: 5}}
                onChangeText={newText =&gt; setChannelId(newText)}
              /&gt;
            &lt;/View&gt;
          )}
        &lt;/View&gt;
      &lt;/SafeAreaView&gt;</pre>
<h2 id="conclusion">结论</h2>
<p>WebRTC 是一项强大的技术，使用<code>react-native-webrtc</code>我们可以用浏览器上可用的相同 API 构建 React 本地应用程序。</p>
<p>您可以用这个项目的<a href="https://github.com/cristian-rita/react-native-webrtc-example" target="_blank" rel="noopener">代码亲自尝试一下。</a></p><div class="code-block code-block-18">
<div class="blog-plug inline-plug react-native-plug"><h2><a href="https://lp.logrocket.com/blg/react-native-signup"> LogRocket </a>:即时重现 React 原生应用中的问题。</h2><a class="signup" href="https://lp.logrocket.com/blg/react-native-signup" target="_blank" rel="noopener noreferrer"><img class="alignnone size-full wp-image-46 jetpack-lazy-image" src="../Images/110055665562c1e02069b3698e6cc671.png" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2021/10/react-native-plug_v2-2.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2021/10/react-native-plug_v2-2.png"/><noscript><img data-lazy-fallback="1" class="alignnone size-full wp-image-46" src="../Images/110055665562c1e02069b3698e6cc671.png" data-original-src="https://blog.logrocket.com/wp-content/uploads/2021/10/react-native-plug_v2-2.png"/></noscript></a><p><a href="https://lp.logrocket.com/blg/react-native-signup" target="_blank" rel="noopener noreferrer"> LogRocket </a>是一款 React 原生监控解决方案，可帮助您即时重现问题、确定 bug 的优先级并了解 React 原生应用的性能。</p><p>LogRocket 还可以向你展示用户是如何与你的应用程序互动的，从而帮助你提高转化率和产品使用率。LogRocket 的产品分析功能揭示了用户不完成特定流程或不采用新功能的原因。</p><p>开始主动监控您的 React 原生应用— <a class="signup" href="https://lp.logrocket.com/blg/react-native-signup" target="_blank" rel="noopener noreferrer">免费试用 LogRocket】。</a></p></div>
</div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
<html>
<head>
<title>Persist state with Redux Persist using Redux Toolkit in React - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>在 React - LogRocket 博客中使用 Redux Toolkit 持久化状态</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/persist-state-redux-persist-redux-toolkit-react/#0001-01-01">https://blog.logrocket.com/persist-state-redux-persist-redux-toolkit-react/#0001-01-01</a></blockquote><div><article class="article-post">
<p>使用 Redux Persist 库，开发人员可以将 Redux 存储保存在持久存储中，例如本地存储。因此，即使在刷新浏览器后，站点状态仍然会被保留。Redux Persist 还包含一些方法，允许我们定制持久化和再水化的状态，所有这些都使用一个易于理解的 API。</p>
<p>在本文中，我们将学习如何在 React 中使用<a href="https://github.com/rt2zz/redux-persist"> Redux Persist </a>和<a href="https://blog.logrocket.com/smarter-redux-redux-toolkit/#bootstrapping-react-redux-toolkit"> Redux Toolkit。要阅读本文，您应该熟悉 React 和 Redux 工具包。您还应该在计算机上安装 Node.js。</a></p>

<h2 id="setting-up-react">设置 React</h2>
<p>我已经创建了一个使用 Redux Toolkit 进行状态管理的应用程序。我们将在本教程中使用它来了解 Redux Persist 是如何工作的。开始，<a href="https://github.com/Tammibriggs/auth-app.git">c</a>T2【lone】GitHub 回购。您可以使用以下命令来完成此操作:</p>
<pre class="language-bash">$ git clone https://github.com/Tammibriggs/auth-app.git

$ cd auth-app

$ npm install
</pre>
<p>接下来，我们可以用<code>npm start</code>命令启动应用程序。在我们的应用程序中，我们会看到一个表单，其中有一个字段可以输入我们的姓名和电子邮件。在输入所需的输入并提交表单后，我们将被带到我们的个人资料页面，该页面看起来类似于下图:</p>
<p><img data-attachment-id="113583" data-permalink="https://blog.logrocket.com/persist-state-redux-persist-redux-toolkit-react/react-profile-page/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/06/react-profile-page.png" data-orig-size="730,182" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="react-profile-page" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/06/react-profile-page-300x75.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/06/react-profile-page.png" decoding="async" class="aligncenter wp-image-113583 size-full jetpack-lazy-image" src="../Images/22e9395e390e403be4d032f0f81e88a9.png" alt="React Profile Page" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2022/06/react-profile-page.png 730w, https://blog.logrocket.com/wp-content/uploads/2022/06/react-profile-page-300x75.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2022/06/react-profile-page.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/06/react-profile-page.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="113583" data-permalink="https://blog.logrocket.com/persist-state-redux-persist-redux-toolkit-react/react-profile-page/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/06/react-profile-page.png" data-orig-size="730,182" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="react-profile-page" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/06/react-profile-page-300x75.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/06/react-profile-page.png" decoding="async" loading="lazy" class="aligncenter wp-image-113583 size-full" src="../Images/22e9395e390e403be4d032f0f81e88a9.png" alt="React Profile Page" srcset="https://blog.logrocket.com/wp-content/uploads/2022/06/react-profile-page.png 730w, https://blog.logrocket.com/wp-content/uploads/2022/06/react-profile-page-300x75.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/06/react-profile-page.png"/></noscript>
<p>当我们刷新浏览器时，我们的数据将会丢失。让我们学习如何使用 Redux Persist 将状态保存在持久存储中，以便即使在刷新之后，数据仍然保持不变。我们还将了解如何定制持久化的内容，以及如何合并传入的状态。我们开始吧！</p>
<h2 id="persisting-state-redux-persist">用 Redux Persist 保持状态</h2>
<p>首先，我们将使用以下命令向我们的应用程序添加 Redux Persist:</p>
<pre class="language-bash">$ npm i redux-persist
</pre>
<p>接下来，我们需要修改我们的存储，我们将在克隆应用程序的<code>src</code>目录中的<code>redux</code>文件夹中找到它。目前，我们的商店看起来像下面的代码:</p>
<pre class="language-javascript">// src/redux/store.js
import { configureStore } from "@reduxjs/toolkit";
import userReducer from "./slices/userSlice";

export const store = configureStore({
  reducer: userReducer,
  devTools: process.env.NODE_ENV !== 'production',
})
</pre>
<p>我们将对我们的<code>store.js</code>文件进行以下修改，以使用 Redux Persist:</p>
<pre class="language-javascript">// src/redux/store.js
import { configureStore } from "@reduxjs/toolkit";
import userReducer from "./slices/userSlice";
import storage from 'redux-persist/lib/storage';
import { persistReducer, persistStore } from 'redux-persist';
import thunk from 'redux-thunk';

const persistConfig = {
  key: 'root',
  storage,
}

const persistedReducer = persistReducer(persistConfig, userReducer)

export const store = configureStore({
  reducer: persistedReducer,
  devTools: process.env.NODE_ENV !== 'production',
  middleware: [thunk]
})

export const persistor = persistStore(store)
</pre>
<p>在上面的代码中，我们将存储中的属性<code>reducer</code>的值从<code>userReducer</code>替换为<code>persistedReducer</code>，这是一个增强的缩减器，配置为将<code>userReducer</code>状态持久化到本地存储。除了本地存储，我们还可以使用其他存储引擎<a href="https://github.com/rt2zz/redux-persist#storage-engines">比如<code><a href="https://developer.mozilla.org/en-US/docs/Web/API/Window/sessionStorage">sessionStorage</a></code>和</a><a href="https://github.com/abersager/redux-persist-cookie-storage#redux-persist-cookie-storage-adapter"> Redux Persist Cookie 存储适配器</a>。</p>
<p>要使用不同的存储引擎，我们只需要用我们想要使用的存储引擎修改<code>persistConfig</code>的<code>storage</code>属性的值。例如，要使用<code>sessionStorage</code>引擎，我们将首先如下导入它:</p>
<pre>import storageSession from 'reduxjs-toolkit-persist/lib/storage/session'
</pre>
<p>然后，修改<code>persistConfig</code>,看起来像下面的代码:</p>
<pre>const persistConfig = {
  key: 'root',f
  storageSession,
}
</pre>
<p>在上面对存储的修改中，我们还包括了<a href="https://blog.logrocket.com/async-actions-bare-redux-thunk-custom-middleware/#using-thunk-redux-toolkit-manage-asynchronous-actions"> Thunk 中间件，它将在不可序列化的值</a>到达缩减器之前拦截并停止它们。当在不使用 Thunk 中间件的情况下使用 Redux Persist 时，我们会在浏览器的控制台上看到一个错误消息<code>a non-serializable value was detected in the state</code>。</p>
<p>最后，我们将我们的存储作为参数传递给<code>persistStore</code>，它是持久化和再水合状态的函数。使用该功能，我们的存储将被保存到本地存储，即使在浏览器刷新后，我们的数据仍将保留。</p>
<p>在大多数用例中，我们可能希望延迟应用程序 UI 的呈现，直到持久数据在 Redux store 中可用。为此，Redux Persist 包含了<a href="https://github.com/ryanwillis/reduxjs-toolkit-persist/blob/main/docs/PersistGate.md"> <code>PersistGate</code> </a>组件。要使用<code>PersistGate</code>，请转到<code>src</code>目录中的<code>index.js</code>文件，并添加以下导入:</p>
<pre class="language-javascript">// src/index.js
import { persistor, store } from './redux/store';
import { PersistGate } from 'redux-persist/integration/react';
</pre>
<p>现在，修改<code>render</code>函数调用，看起来像下面的代码:</p>
<pre class="language-javascript">// src/index.js
root.render(
  &lt;React.StrictMode&gt;
    &lt;Provider store={store}&gt;
      &lt;PersistGate loading={null} persistor={persistor}&gt;
        &lt;App /&gt;
      &lt;/PersistGate&gt;
    &lt;/Provider&gt;
  &lt;/React.StrictMode&gt;
);
</pre>
<p>在本节中，我们介绍了使用 Redux Persist 时的基本设置。现在，让我们探索 Redux Persist 的可用选项和用例。</p>
<h2 id="nested-persists-redux">使用 Redux Persist 的嵌套持久化</h2>
<p>如果我们在 Redux Toolkit 中有两个或更多的 reducers，比如<code>userReducer</code>和<code>notesReducer</code>，并且我们想将它们添加到我们的存储中，我们可能会如下配置存储:</p>
<pre class="language-javascript">const store = configureStore({
  reducer: {
    user: userReducer,
    notes: notesReducer
  },
})
</pre>
<p>我们也可以如下使用<code>combineReducers</code>，它做同样的事情:</p>
<pre class="language-javascript">const rootReducer = combineReducers({ 
  user: userReducer,
  notes: NotesReducer
})

const store = configureStore({
  reducer: rootReducer
})
</pre>
<p>为了在这种情况下使用 Redux Persist，我们将提供<code>rootReducer</code>作为<code>persistReducer</code>的参数，然后用持久化的 reducer 替换我们商店中的<code>rootReducer</code>,如下所示:</p>
<pre class="language-javascript">const rootReducer = combineReducers({ 
  user: userReducer,
  notes: NotesReducer
})

const persistedReducer = persistReducer(persistConfig, rootReducer)

const store = configureStore({
  reducer: persistedReducer
})
</pre>
<p>但是，如果我们想设置一个不同的配置呢？例如，假设我们想将<code>userReducer</code>的存储引擎改为<code>sessionStorage</code>。为此，我们可以使用<a href="https://github.com/rt2zz/redux-persist#nested-persists">嵌套持久化</a>，这是一个允许我们嵌套<code>persistReducer</code>的特性，让我们能够为减速器设置不同的配置。</p>
<p>下面是一个嵌套持久化的例子，我将<code>userReducer</code>的存储改为<code>sessionStorage</code>:</p>
<pre class="language-javascript">const rootPersistConfig = {
  key: 'root',
  storage,
}

const userPersistConfig = {
  key: 'user',
  storage: storageSession,
}

const rootReducer = combineReducers({
  user: persistReducer(userPersistConfig, userReducer),
  notes: notesReducer
})

const persistedReducer = persistReducer(rootPersistConfig, rootReducer)

const store = configureStore({
  reducer: persistedReducer
})
</pre>
<h2 id="specify-incoming-state-merged">指定如何合并传入状态</h2>
<p>合并包括将持久状态保存回 Redux 存储中。当我们的应用程序启动时，我们的初始状态被设置。不久之后，Redux Persist 从存储中检索我们的持久状态，然后覆盖任何初始状态。这个过程是自动进行的。</p>
<p>默认情况下，合并过程会自动合并一个级别。假设我们有一个传入的初始状态，如下所示:</p>
<pre class="language-javascript">{user: {name: 'Tammibriggs'}, isLoggedIn: true} // incoming state
{ user: {name: '', email: ''}, isLoggedIn: false, status: 'Pending'} // initial state
</pre>
<p>合并后的状态将类似于以下代码:</p>
<pre class="language-javascript">{ user: {name: 'Tammibriggs'}, isLoggedIn: true, status: 'Pending'} // reconciled/merged state
</pre>
<p>初始状态与传入状态和顶级属性值合并。在传入状态下，这些被替换而不是合并，这就是为什么<code>user</code>中的<code>email</code>属性丢失的原因。在我们的代码中，这将类似于以下内容:</p>
<pre>const mergedState = { ...initialState };

mergedState['user'] = persistedState['user']
mergedState['isLoggedIn'] = persistedState['isLoggedIn']
</pre>
<p>Redux Persist 中的这种合并称为<code>autoMergeLevel1</code>，是 Redux Persist 中的<a href="https://github.com/rt2zz/redux-persist#state-reconciler">默认状态协调器。其他的状态协调器包括<code>hardSet</code>，它用进入的状态完全覆盖初始状态，以及<code>autoMergeLevel2</code>，它合并两个深度级别。</a></p>
<p>在我们之前的例子中，<code>user</code>中的<code>email</code>属性不会丢失。协调或合并的状态将类似于以下代码:</p>
<pre>{ user: {name: 'Tammibriggs' email:''}, isLoggedIn: true, status: 'Pending'} // reconciled/merged state
</pre>
<p>例如，要设置一个状态协调器，如果我们想使用<code>autoMergeLevel2</code>，我们只需要在<code>persistConfig</code>中指定一个<code>stateReconciler</code>属性:</p>
<pre class="language-javascript">import autoMergeLevel2 from 'redux-persist/lib/stateReconciler/autoMergeLevel2';

const persistConfig = {
  key: 'root',
  storage,
  stateReconciler: autoMergeLevel2
}
</pre>
<h2 id="customize-whats-persisted">自定义保留的内容</h2>
<p>通过使用传递给<code>persistReducer</code>的<code>config</code>对象的<code>blacklist</code>和<code>whitelist</code>属性，我们可以定制我们状态的一部分来持久化。使用<code>blacklist</code>属性，我们可以指定不持久化状态的哪一部分，而<code>whitelist</code>属性则相反，指定持久化状态的哪一部分。</p>
<p>例如，假设我们有以下减速器:</p>
<pre class="language-javascript">const rootReducer = combineReducers({ 
  user: userReducer,
  notes: notesReducer
})
</pre>
<p>如果我们想防止<code>notes</code>持续存在，那么<code>config</code>对象应该如下所示:</p>
<pre class="language-javascript">const rootPersistConfig = {
  key: 'root',
  storage,
  blacklist: ['notes']
}

// OR

const rootPersistConfig = {
  key: 'root',
  storage,
  whitelist: ['users']
}
</pre>
<p><code>blacklist</code>和<code>whitelist</code>属性接受一个字符串数组。每个字符串必须匹配由我们传递给<code>persistReducer</code>的 reducer 管理的状态的一部分。当使用<code>blacklist</code>和<code>whitelist</code>时，我们只能瞄准一层深度。但是，如果我们想在上面的状态中定位一个属性，我们可以利用嵌套持久化。</p>
<p>例如，假设<code>userReducer</code>初始状态如下:</p>
<pre>const initialState = {
  user: {},
  isLoggedIn: false,
}
</pre>
<p>如果我们想防止<code>isLoggedIn</code>持续，我们的代码将如下所示:</p>
<pre>const rootPersistConfig = {
  key: 'root',
  storage,
}

const userPersistConfig = {
  key: 'user',
  storage,
  blacklist: ['isLoggedIn']
}

const rootReducer = combineReducers({
  user: persistReducer(userPersistConfig, userReducer),
  notes: notesReducer
})

const persistedReducer = persistReducer(rootPersistConfig, rootReducer);
</pre>
<p>现在，<code>isLoggedIn</code>属性不会被持久化。</p>
<h2 id="conclusion">结论</h2>
<p>在本教程中，我们学习了如何使用 Redux Toolkit 中的 Redux Persist 将数据保存在持久存储中。因此，即使在浏览器刷新后，我们的数据仍将保留。我们还探索了定制 Redux Persist 的几个选项，例如，指定使用哪个存储引擎，以及使用<code>blacklist</code>和<code>whitelist</code>属性定制在我们的状态中持久化的内容。</p>
<p>虽然在撰写本文时，Redux Persist 正在维护中，已经有一段时间没有更新了，但它仍然是一个非常棒的工具，拥有强大的社区支持。我希望你喜欢这个教程，如果你有任何问题，一定要留下评论。</p>
<div class="code-block code-block-17">
<div class="blog-plug inline-plug react-plug" vwo-el-id="26283398190">
<h2 vwo-el-id="41600691720">使用 LogRocket 消除传统反应错误报告的噪音</h2>
<a href="https://lp.logrocket.com/blg/react-signup-issue-free" target="_blank" vwo-el-id="19356441070">LogRocket
</a><p>是一款 React analytics 解决方案，可保护您免受数百个误报错误警报的影响，只针对少数真正重要的项目。LogRocket 告诉您 React 应用程序中实际影响用户的最具影响力的 bug 和 UX 问题。</p><a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="19356441380">
<img class="first-react-image alignnone size-full wp-image-46 jetpack-lazy-image jetpack-lazy-image--handled" src="../Images/f300c244a1a1cf916df8b4cb02bec6c6.png" vwo-el-id="18272717540" data-lazy-loaded="1" data-original-src="https://files.readme.io/27c94e7-Image_2017-06-05_at_9.46.04_PM.png"/>
</a>
<a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="19356441690">
<img class="second-react-image alignnone size-full wp-image-46 jetpack-lazy-image jetpack-lazy-image--handled" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" vwo-el-id="30720362350" data-lazy-loaded="1" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/>
</a>
<a href="https://lp.logrocket.com/blg/react-signup-issue-free" target="_blank" rel="noopener noreferrer" vwo-el-id="35866400580">LogRocket
</a><p>自动聚合客户端错误、反应错误边界、还原状态、缓慢的组件加载时间、JS 异常、前端性能指标和用户交互。然后，LogRocket 使用机器学习来通知您影响大多数用户的最具影响力的问题，并提供您修复它所需的上下文。</p><p vwo-el-id="28675661060">关注重要的 React bug—<a class="signup" href="https://lp.logrocket.com/blg/react-signup-issue-free" target="_blank" rel="noopener noreferrer" vwo-el-id="40093418840">今天就试试 LogRocket】。</a></p>
</div></div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
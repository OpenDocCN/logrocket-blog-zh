<html>
<head>
<title>React Native track player: A complete guide </title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>反应原生轨道播放器:完全指南</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/react-native-track-player-complete-guide/#0001-01-01">https://blog.logrocket.com/react-native-track-player-complete-guide/#0001-01-01</a></blockquote><div><article class="article-post">
 <p>React原生应用开发者构建各种应用，其中一些涉及实现音乐播放列表。如果您计划使用React Native构建一个音频播放器，那么您无疑需要一个playlist实现，它包括一个可管理的音乐曲目队列，该队列对用户是可见的，或者作为一个后台服务运行，用于以特定的顺序播放音乐曲目。</p>
<p>音乐播放列表通常连接到播放所选音乐曲目的音乐播放器实现。从用户的角度来看，他们应该能够在播放列表中添加、删除、随机播放和重新排序音乐曲目。从开发人员的角度来看，他们也应该能够以编程方式更新播放列表。</p>
<p>在React Native中创建和管理播放列表有几种潜在的方法。我们可以在没有第三方库的情况下从头构建一个播放列表和播放器，但这很耗时。我们也可以使用一个库来播放音乐曲目，并基于音乐播放器事件从头开始开发一个音乐队列。我们可以使用功能齐全的音乐曲目播放器库来进一步加快开发过程。</p>
<p><a href="https://github.com/doublesymmetry/react-native-track-player"> <code>react-native-track-player</code>库</a>提供了全功能的API，用于在React Native中创建基于播放列表的音乐应用。在本教程中，我将通过实现一个包含可视播放列表的音乐播放器来解释<code>react-native-track-player</code>的特性。</p>
<p><em>向前跳转:</em></p>

<h2 id="highlighted-features-react-native-track-player"><code>react-native-track-player</code>的突出特点</h2>
<p>在我们开始实践教程之前，让我们看看这个库的特性。</p>
<p>这个库附带了以下有助于构建音乐应用程序的功能:</p>
<h3 id="developer-friendly-player-state-management">开发者友好的玩家状态管理</h3>
<p>该库由两个逻辑模块组成:</p>
<ol>
<li>音乐播放器模块</li>
<li>播放列表实现</li>
</ol>
<p>音乐播放器模块播放播放列表中出现的曲目。这个库提供了函数和React钩子来控制音乐播放器的状态和订阅播放器事件。这些开发人员友好的玩家状态管理特性使得track player-UI集成变得容易。此外，基于事件的React挂钩降低了React状态管理需求的复杂性。</p>
<h3 id="simple-playlist-management">简单的播放列表管理</h3>
<p>这个库为开发者提供了一个简单的API来管理音乐曲目队列。您可以通过程序添加、删除、重复和跳过带有自解释功能的音乐曲目。使用这个库，创建你自己的基于播放列表的音乐播放器很容易。</p>
<h3 id="performance-first-native-library-core">性能第一的原生库核心</h3>
<p>对于播放列表管理和回放，该库使用两个本机模块:</p>

<p>JavaScript <code>react-native-track-player</code>实现调用上述本机模块进行音乐回放和播放列表管理，因此这个库努力为您的音乐应用程序提供本机性能。播放列表存储在优化的本地数据结构中，以获得更好的性能(例如，Kotlin中的<a href="https://github.com/doublesymmetry/KotlinAudio/blob/dd4bdab147c90fffcff7800790dbfcb41291d29b/kotlin-audio/src/main/java/com/doublesymmetry/kotlinaudio/players/QueuedAudioPlayer.kt#L16"> LinkedList </a>)。</p>
<p>该库提供了一个开发人员友好的、一致的异步API，因此您可以在React本机应用程序代码库中轻松使用现代的<code>async/await</code>模式。</p>
<h3 id="platform-support-flexible-platform-specific-configuration">平台支持和灵活的平台特定配置</h3>
<p>这个库可以在Android、iOS和Windows平台上运行。它使用<a href="https://learn.microsoft.com/en-us/uwp/api/windows.media.playback"> WinRT媒体播放API </a>在Windows上播放音乐内容，所以你可以使用这个包来构建现代的Windows应用程序！</p>
<p>track player库从未通过仅提供通用的跨平台API来限制开发人员，它为高级用例提供了特定于平台的配置。例如，它可以让你改变Android上的通知面板播放器图标。</p>
<h2 id="react-native-track-player-tutorial"><code>react-native-track-player</code>教程</h2>
<p>现在，我们将通过开发一个带有播放列表的音乐播放器应用程序来学习如何使用<code>react-native-track-player</code>库。在构建音乐播放器应用程序时，我将向您展示一些额外的示例代码片段，以进一步解释库API函数。</p>
<h3 id="integrating-library-react-native-project">将库与React本地项目集成</h3>
<p>从安装<code>react-native-track-player</code>包开始。首先，创建一个新的React本地项目来构建音乐播放器:</p>
<pre class="language-bash hljs">npx react-native init MusicTrackPlayer
cd MusicTrackPlayer
</pre>
<p>接下来，运行新创建的应用程序，确保一切正常:</p>
<pre class="language-bash hljs">npx react-native run-android
# --- or ---
npx react-native run-ios
</pre>
<p>现在，安装库:</p>
<pre class="language-bash hljs">npm install react-native-track-player
# --- or ---
yarn add react-native-track-player
</pre>
<p>我正在Android上开发这个示例应用程序，所以运行上面的命令就足以设置这个库了。但是，在iOS上，您需要手动安装本机依赖项:</p>
<pre class="language-bash hljs">cd ios &amp;&amp; pod install
</pre>
<p>再次构建应用程序并运行它来验证包的安装状态。</p>
<p>注意:在Android上，如果<code>:app:checkDebugAarMetadata</code> Gradle build任务失败，在你的<code>android/build.gradle</code>中使用<code>compileSdkVersion = 33</code>。更多信息见本<a href="https://github.com/doublesymmetry/react-native-track-player/issues/1767">参考</a>。</p>
<h3 id="creating-simple-track-player">创建一个简单的轨道播放器</h3>
<p>让我们开始用音轨播放器库播放音乐吧。在为播放列表实现UI组件之前，我们将以编程方式创建一个播放列表，以理解播放列表管理API。</p>
<p>首先，在你的应用程序源目录中创建一个名为<code>assets</code>的新目录，并下载<a href="https://github.com/codezri/react-native-track-player-demo/tree/main/assets">这些音乐曲目</a>(来自<a href="https://pixabay.com/music/"> Pixabay Music </a>的三个MP3音频文件)到其中。</p>
<p>在初始化track player实例以播放您下载的MP3文件之前，我们需要定义几个服务来帮助我们配置、初始化和控制track player实例。创建一个名为<code>trackPlayerServices.js</code>的新文件，并添加以下代码:</p>
<pre class="language-js hljs">import TrackPlayer, {
  AppKilledPlaybackBehavior,
  Capability,
  RepeatMode,
  Event
} from 'react-native-track-player';

export async function setupPlayer() {
  let isSetup = false;
  try {
    await TrackPlayer.getCurrentTrack();
    isSetup = true;
  }
  catch {
    await TrackPlayer.setupPlayer();
    await TrackPlayer.updateOptions({
      android: {
        appKilledPlaybackBehavior:
          AppKilledPlaybackBehavior.StopPlaybackAndRemoveNotification,
      },
      capabilities: [
        Capability.Play,
        Capability.Pause,
        Capability.SkipToNext,
        Capability.SkipToPrevious,
        Capability.SeekTo,
      ],
      compactCapabilities: [
        Capability.Play,
        Capability.Pause,
        Capability.SkipToNext,
      ],
      progressUpdateEventInterval: 2,
    });

    isSetup = true;
  }
  finally {
    return isSetup;
  }
}

export async function addTracks() {
  await TrackPlayer.add([
    {
      id: '1',
      url: require('./assets/fluidity-100-ig-edit-4558.mp3'),
      title: 'Fluidity',
      artist: 'tobylane',
      duration: 60,
    }
  ]);
  await TrackPlayer.setRepeatMode(RepeatMode.Queue);
}

export async function playbackService() {
  // TODO: Attach remote event handlers
}
</pre>
<p>上面的代码实现了三个服务:</p>
<ol>
<li><code>setupPlayer</code>:仅用几个播放器功能和默认行为(即，应用程序终止行为)初始化一个轨道播放器实例一次</li>
<li><code>addTracks</code>:从捆绑资源向当前播放列表添加一首曲目</li>
<li>这个服务接收远程事件。我们将在下一节讨论回放服务事件，所以现在让这个函数为空</li>
</ol>
<p>这里，我们通过<code>require</code>函数从app bundle中加载一个MP3文件。该库支持通过<code>http</code>协议加载远程音频文件，通过<code>file</code>协议加载本地音频文件。</p>
<p>接下来，我们需要将上面的<code>playbackService</code>函数注册为回放事件处理程序。在您的<code>index.js</code>文件中使用以下代码:</p>
<pre class="language-js hljs">import { AppRegistry } from 'react-native';
import TrackPlayer from 'react-native-track-player';
import App from './App';
import { name as appName } from './app.json';
import { playbackService } from './trackPlayerServices';

AppRegistry.registerComponent(appName, () =&gt; App);
TrackPlayer.registerPlaybackService(() =&gt; playbackService);
</pre>
<p>现在，我们可以开始构建应用程序UI，因为我们的track player服务已经准备好了。将以下代码添加到您的<code>App.js</code>文件中:</p>
<pre class="language-js hljs">import React, { useEffect, useState } from 'react';
import {
  SafeAreaView,
  StyleSheet,
  View,
  Button,
  ActivityIndicator,
} from 'react-native';
import TrackPlayer from 'react-native-track-player';
import { setupPlayer, addTracks } from './trackPlayerServices';

function App() {

  const [isPlayerReady, setIsPlayerReady] = useState(false);

  useEffect(() =&gt; {
    async function setup() {
      let isSetup = await setupPlayer();

      const queue = await TrackPlayer.getQueue();
      if(isSetup &amp;&amp; queue.length &lt;= 0) {
        await addTracks();
      }

      setIsPlayerReady(isSetup);
    }

    setup();
  }, []);

  if(!isPlayerReady) {
    return (
      &lt;SafeAreaView style={styles.container}&gt;
        &lt;ActivityIndicator size="large" color="#bbb"/&gt;
      &lt;/SafeAreaView&gt;
    );
  }

  return (
    &lt;SafeAreaView style={styles.container}&gt;
      &lt;Button title="Play" color="#777" onPress={() =&gt; TrackPlayer.play()}/&gt;
    &lt;/SafeAreaView&gt;
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    justifyContent: 'center',
    padding: 20,
    backgroundColor: '#112'
  },
});

export default App;
</pre>
<p>上面的<code>App</code>组件通过<code><a href="https://blog.logrocket.com/using-react-useeffect-hook-lifecycle-methods/">useEffect</a></code>调用<code>setupPlayer</code>服务来初始化本机的音轨播放器。接下来，如果当前播放列表为空，它调用<code>addTracks</code>服务来初始化播放列表。该组件使用条件呈现逻辑，如下所示:</p>
<ul>
<li>如果播放器没有准备好(设置正在进行中),则渲染加载动画</li>
<li>如果播放器设置过程成功，则呈现一个<strong>播放</strong>按钮</li>
</ul>
<p><strong>播放</strong>按钮调用<code>TrackPlayer.play</code>函数开始播放曲目队列。运行上面的app代码，按下<strong>播放</strong>按钮。播放列表将开始播放！看下面的预告:</p>
<p><img data-attachment-id="149341" data-permalink="https://blog.logrocket.com/react-native-track-player-complete-guide/attachment/play-button-3/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/12/play-button.gif" data-orig-size="730,1542" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="play-button" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/12/play-button-142x300.gif" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/12/play-button-485x1024.gif" decoding="async" class="aligncenter wp-image-149341 size-full jetpack-lazy-image" src="../Images/bb25077bf999ef2290cc1eed93a2f7ae.png" alt="Play button" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2022/12/play-button.gif?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/12/play-button.gif"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="149341" data-permalink="https://blog.logrocket.com/react-native-track-player-complete-guide/attachment/play-button-3/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/12/play-button.gif" data-orig-size="730,1542" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="play-button" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/12/play-button-142x300.gif" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/12/play-button-485x1024.gif" decoding="async" loading="lazy" class="aligncenter wp-image-149341 size-full" src="../Images/bb25077bf999ef2290cc1eed93a2f7ae.png" alt="Play button" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/12/play-button.gif"/></noscript>
<p>使用以下代码为<code>addTracks</code>服务播放所有下载的音乐曲目:</p>
<pre class="language-js hljs">export async function addTracks() {
  await TrackPlayer.add([
    {
      id: '1',
      url: require('./assets/fluidity-100-ig-edit-4558.mp3'),
      title: 'Fluidity',
      artist: 'tobylane',
      duration: 60,
    },
    {
      id: '2',
      url: require('./assets/penguinmusic-modern-chillout-future-calm-12641.mp3'),
      title: 'Modern Chillout',
      artist: 'penguinmusic',
      duration: 66,
    },
    {
      id: '3',
      url: require('./assets/powerful-beat-121791.mp3'),
      title: 'Powerful Beat',
      artist: 'penguinmusic',
      duration: 73,
    }
  ]);
  await TrackPlayer.setRepeatMode(RepeatMode.Queue);
}
</pre>
<p>得益于<code>RepeatMode.Queue</code>模式，播放列表将在结束时重新开始播放。</p>
<p> </p>
<h3 id="managing-playlist">管理播放列表<br/>在前面的示例代码中，我们使用了<code>TrackPlayer.add</code>函数向播放列表添加新的音乐曲目。同样，您可以使用以下功能来管理当前播放列表:</h3>
<ul>
<li><code>TrackPlayer.remove</code>:按曲目索引删除音乐曲目</li>
<li><code>TrackPlayer.skip</code>:跳转到给定索引的音乐曲目</li>
<li><code>TrackPlayer.next</code>:转到下一首音乐曲目</li>
<li><code>TrackPlayer.previous</code>:转到上一首音乐曲目</li>
<li><code>TrackPlayer.reset</code>:清除当前播放列表并停止播放音乐</li>
</ul>
<p>在<a href="https://react-native-track-player.js.org/docs/api/functions/queue">官方文档</a>中浏览所有支持的播放列表管理功能。</p>
<p>按下<strong>播放</strong>按钮后，通过热加载功能逐一执行以下函数调用，熟悉播放列表管理功能:</p>
<pre class="language-js hljs">TrackPlayer.remove(0)
TrackPlayer.skip(2)
TrackPlayer.next()
TrackPlayer.previous()
TrackPlayer.reset()
</pre>
<p> </p>
<h3 id="visualizing-manageable-playlist">可视化可管理的播放列表</h3>
<p>让我们在实际场景中使用上面的播放列表管理功能。我们可以开始改进示例应用程序，将它变成基于播放列表的音乐播放器。</p>
<p>作为第一步，让我们创建一个React组件来显示当前播放列表，并让用户播放喜欢的音乐曲目。为了简单起见，在本教程中，我们将在我们的<code>App.js</code>文件中开发所有组件，但是当您开发生产级应用时，请确保将您的应用适当地分解到单独的源文件中。</p>
<p>首先，将以下导入行添加到<code>App.js</code>:</p>
<pre class="language-js hljs">import {
  SafeAreaView,
  StyleSheet,
  Text,
  View,
  Button,
  FlatList,
  ActivityIndicator,
  TouchableOpacity,
} from 'react-native';
import TrackPlayer, {
  useTrackPlayerEvents,
  Event,
  State
} from 'react-native-track-player';
</pre>
<p>接下来，将<code>Playlist</code>组件实现添加到源文件中:</p>
<pre class="language-js hljs">function Playlist() {
  const [queue, setQueue] = useState([]);
  const [currentTrack, setCurrentTrack] = useState(0);

  async function loadPlaylist() {
    const queue = await TrackPlayer.getQueue();
    setQueue(queue);
  }

  useEffect(() =&gt; {
    loadPlaylist();
  }, []);

  useTrackPlayerEvents([Event.PlaybackTrackChanged], async (event) =&gt; {
    if(event.state == State.nextTrack) {
      let index = await TrackPlayer.getCurrentTrack();
      setCurrentTrack(index);
    }
  });

  function PlaylistItem({index, title, isCurrent}) {

    function handleItemPress() {
      TrackPlayer.skip(index);
    }

    return (
      &lt;TouchableOpacity onPress={handleItemPress}&gt;
        &lt;Text
          style={{...styles.playlistItem,
            ...{backgroundColor: isCurrent ? '#666' : 'transparent'}}}&gt;
        {title}
        &lt;/Text&gt;
      &lt;/TouchableOpacity&gt;
    );
  }

  return(
    &lt;View&gt;
      &lt;View style={styles.playlist}&gt;
        &lt;FlatList
          data={queue}
          renderItem={({item, index}) =&gt; &lt;PlaylistItem
                                            index={index}
                                            title={item.title}
                                            isCurrent={currentTrack == index }/&gt;
          }
        /&gt;
      &lt;/View&gt;
    &lt;/View&gt;
  );
}
</pre>
<p>这里，我们用一个<code>FlatList</code>组件呈现当前播放列表。<code>FlatList</code>组件使用<code>queue</code>状态变量来加载当前播放列表的细节。同时，<code>useEffect</code>调用<code>TrackPlayer.getQueue</code>将当前播放列表抓取到<code>queue</code>中。</p>
<p>播放列表UI还突出显示了当前的音乐曲目，因此我们将当前的音乐曲目索引存储在<code>currentTrack</code>状态变量中。一旦用户按下一个列表项，我们就通过调用<code>TrackPlayer.skip</code>函数来请求track player实例播放选中的曲目。我们通过<code>useTrackPlayerEvents</code>库钩子跟踪<code>currentTrack</code>的变化。</p>
<p>接下来，在<code>App</code>组件中添加<code>&lt;Playlist/&gt;</code>，如下面的代码片段所示:</p>
<pre class="language-js hljs">return (
  &lt;SafeAreaView style={styles.container}&gt;
    &lt;Playlist/&gt;
    &lt;Button title="Play" color="#777" onPress={() =&gt; TrackPlayer.play()}/&gt;
  &lt;/SafeAreaView&gt;
);
</pre>
<p>将以下样式定义添加到样式表中:</p>
<pre class="language-jsx hljs">playlist: {
  marginTop: 40,
  marginBottom: 40
},
playlistItem: {
  fontSize: 16,
  paddingTop: 4,
  paddingBottom: 4,
  paddingLeft: 8,
  paddingRight: 8,
  borderRadius: 4
},
</pre>
<p>运行应用程序。现在，您可以按下并选择音乐曲目。等待音乐曲目结束，播放列表组件将自动设置下一首当前音乐曲目，如以下预览所示:</p>
<p><img data-attachment-id="149344" data-permalink="https://blog.logrocket.com/react-native-track-player-complete-guide/attachment/music-track/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/12/music-track.gif" data-orig-size="730,1542" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="music-track" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/12/music-track-142x300.gif" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/12/music-track-485x1024.gif" decoding="async" class="aligncenter wp-image-149344 size-full jetpack-lazy-image" src="../Images/5f474ae1229486aa7e3b4f9e1456721a.png" alt="music track" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2022/12/music-track.gif?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/12/music-track.gif"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="149344" data-permalink="https://blog.logrocket.com/react-native-track-player-complete-guide/attachment/music-track/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/12/music-track.gif" data-orig-size="730,1542" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="music-track" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/12/music-track-142x300.gif" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/12/music-track-485x1024.gif" decoding="async" loading="lazy" class="aligncenter wp-image-149344 size-full" src="../Images/5f474ae1229486aa7e3b4f9e1456721a.png" alt="music track" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/12/music-track.gif"/></noscript>
<h3 id="handling-playback-player-state">处理播放和播放器状态</h3>
<p>前面，我们调用了<code>TrackPlayer.play</code>函数来开始播放曲目队列。我们在构建音乐app时经常需要暂停、控制播放速度、调节音乐音量、跳转到当前音乐曲目的特定位置。除了播放动作外，<code>react-native-track-player</code>库还允许您通过以下功能控制播放和播放器状态:</p>
<ul>
<li><code>TrackPlayer.pause</code>:暂停当前播放曲目；您可以使用<code>TrackPlayer.play</code>功能再次播放</li>
<li><code>TrackPlayer.seekTo</code>:根据输入的秒数跳转到特定位置</li>
<li><code>TrackPlayer.setRate</code>:改变播放速度</li>
<li><code>TrackPlayer.setVolume</code>:设置音乐播放器音量</li>
</ul>
<p>上述功能会影响当前播放/播放器状态。也可以在调用上述函数之前获取回放/播放器状态。这里有一些我们经常需要的吸气剂:</p>
<ul>
<li><code>TrackPlayer.getState</code>:返回当前播放状态</li>
<li><code>TrackPlayer.getVolume</code>:返回当前音量</li>
</ul>
<p>注意:如前所述，这个库提供了一个异步API，所以您必须使用<code>await</code>标记从解析的承诺中提取返回的数据。从官方文档中浏览所有支持的回放状态控制功能。</p>
<p>按下<strong>播放</strong>按钮后，通过热重装逐一执行以下函数调用，熟悉播放器/播放状态函数:</p>
<pre class="language-js hljs">TrackPlayer.pause()
TrackPlayer.seekTo(10)
TrackPlayer.setRate(0.5)
TrackPlayer.setVolume(0.2)
</pre>
<p> </p>
<h3 id="visualizing-playback-player-state">可视化回放和播放器状态</h3>
<p>现在，我们将使用上述函数向我们的音乐播放器添加一个控制盒。用户可以使用控制盒按钮播放/暂停、转到上一首音乐曲目以及转到下一首音乐曲目。我们将使用<a href="https://github.com/oblador/react-native-vector-icons"> <code>react-native-vector-icons</code>包</a>来构建控件箱图标按钮。</p>
<p>首先，根据<a href="https://github.com/oblador/react-native-vector-icons#installation">官方安装指南</a>安装并重建项目。然后，在您的<code>App.js</code>文件中添加以下导入:</p>
<pre class="language-js hljs">import TrackPlayer, {
  useTrackPlayerEvents,
  usePlaybackState,
  Event,
  State
} from 'react-native-track-player';
import Icon from 'react-native-vector-icons/FontAwesome';
</pre>
<p>现在，更新现有的<code>Playlist</code>组件并添加新的<code>Controls</code>组件源:</p>
<pre class="language-js hljs">function Playlist() {
  const [queue, setQueue] = useState([]);
  const [currentTrack, setCurrentTrack] = useState(0);

  async function loadPlaylist() {
    const queue = await TrackPlayer.getQueue();
    setQueue(queue);
  }

  useEffect(() =&gt; {
    loadPlaylist();
  }, []);

  useTrackPlayerEvents([Event.PlaybackTrackChanged], (event) =&gt; {
    if(event.state == State.nextTrack) {
      TrackPlayer.getCurrentTrack().then((index) =&gt; setCurrentTrack(index));
    }
  });

  function PlaylistItem({index, title, isCurrent}) {

    function handleItemPress() {
      TrackPlayer.skip(index);
    }

    return (
      &lt;TouchableOpacity onPress={handleItemPress}&gt;
        &lt;Text
          style={{...styles.playlistItem,
            ...{backgroundColor: isCurrent ? '#666' : 'transparent'}}}&gt;
        {title}
        &lt;/Text&gt;
      &lt;/TouchableOpacity&gt;
    );
  }

  return(
    &lt;View&gt;
      &lt;View style={styles.playlist}&gt;
        &lt;FlatList
          data={queue}
          renderItem={({item, index}) =&gt; &lt;PlaylistItem
                                            index={index}
                                            title={item.title}
                                            isCurrent={currentTrack == index }/&gt;
          }
        /&gt;
      &lt;/View&gt;
      &lt;Controls/&gt;
    &lt;/View&gt;
  );
}

function Controls({ onShuffle }) {
  const playerState = usePlaybackState();

  async function handlePlayPress() {
    if(await TrackPlayer.getState() == State.Playing) {
      TrackPlayer.pause();
    }
    else {
      TrackPlayer.play();
    }
  }

  return(
    &lt;View style={{flexDirection: 'row',
      flexWrap: 'wrap', alignItems: 'center'}}&gt;
        &lt;Icon.Button
          name="arrow-left"
          size={28}
          backgroundColor="transparent"
          onPress={() =&gt; TrackPlayer.skipToPrevious()}/&gt;
        &lt;Icon.Button
          name={playerState == State.Playing ? 'pause' : 'play'}
          size={28}
          backgroundColor="transparent"
          onPress={handlePlayPress}/&gt;
        &lt;Icon.Button
          name="arrow-right"
          size={28}
          backgroundColor="transparent"
          onPress={() =&gt; TrackPlayer.skipToNext()}/&gt;
    &lt;/View&gt;
  );
}
</pre>
<p>这里，我们使用一个图标按钮在以下条件下切换播放/暂停状态:</p>
<pre class="language-js hljs">await TrackPlayer.getState() == State.Playing
</pre>
<p>从<code>App</code>组件中移除上一个播放按钮，因为不再需要它:</p>
<pre class="language-js hljs">return (
  &lt;SafeAreaView style={styles.container}&gt;
    &lt;Playlist/&gt;
  &lt;/SafeAreaView&gt;
);
</pre>
<p>运行应用程序。现在，您可以使用控制盒:</p>
<p><img data-attachment-id="149346" data-permalink="https://blog.logrocket.com/react-native-track-player-complete-guide/attachment/control-box/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/12/control-box.gif" data-orig-size="730,1542" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="control-box" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/12/control-box-142x300.gif" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/12/control-box-485x1024.gif" decoding="async" class="aligncenter wp-image-149346 size-full jetpack-lazy-image" src="../Images/0fb32cf80419d9367a9b800206ab3511.png" alt="Control box" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2022/12/control-box.gif?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/12/control-box.gif"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="149346" data-permalink="https://blog.logrocket.com/react-native-track-player-complete-guide/attachment/control-box/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/12/control-box.gif" data-orig-size="730,1542" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="control-box" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/12/control-box-142x300.gif" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/12/control-box-485x1024.gif" decoding="async" loading="lazy" class="aligncenter wp-image-149346 size-full" src="../Images/0fb32cf80419d9367a9b800206ab3511.png" alt="Control box" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/12/control-box.gif"/></noscript>
<p>该库提供了<code>useProgress</code>钩子来跟踪音乐曲目进度。这个钩子默认每秒轮询一次曲目进度，但是你可以根据自己的意愿配置间隔(即<code>useProgress(200)</code>)。</p>
<p>创建一个新组件，用<code>useProgress</code>钩子显示音乐曲目进度:</p>
<pre class="language-js hljs">function TrackProgress() {
  const { position, duration } = useProgress(200);

  function format(seconds) {
    let mins = (parseInt(seconds / 60)).toString().padStart(2, '0');
    let secs = (Math.trunc(seconds) % 60).toString().padStart(2, '0');
    return `${mins}:${secs}`;
  }

  return(
    &lt;View&gt;
      &lt;Text style={styles.trackProgress}&gt;
        { format(position) } / { format(duration) }
      &lt;/Text&gt;
    &lt;/View&gt;
  );
}
</pre>
<p>上面的<code>TrackProgress</code>组件使用音轨持续时间以<code>mm:ss</code>格式显示当前音轨进度。</p>
<p>添加另一个组件来显示当前音乐曲目信息:</p>
<pre class="language-js hljs">function Header() {
  const [info, setInfo] = useState({});
  useEffect(() =&gt; {
    setTrackInfo();
  }, []);

  useTrackPlayerEvents([Event.PlaybackTrackChanged], (event) =&gt; {
    if(event.state == State.nextTrack) {
      setTrackInfo();
    }
  });

  async function setTrackInfo() {
    const track = await TrackPlayer.getCurrentTrack();
    const info = await TrackPlayer.getTrack(track);
    setInfo(info);
  }

  return(
    &lt;View&gt;
        &lt;Text style={styles.songTitle}&gt;{info.title}&lt;/Text&gt;
        &lt;Text style={styles.artistName}&gt;{info.artist}&lt;/Text&gt;
    &lt;/View&gt;
  );
}
</pre>
<p>这里，我们使用了<code>useTrackPlayerEvents</code>钩子来更新当前轨道的细节。接下来，将<code>useProgress</code>挂钩添加到导入列表中:</p>
<pre class="language-js hljs">import TrackPlayer, {
  useTrackPlayerEvents,
  usePlaybackState,
  useProgress,
  Event,
  State
} from 'react-native-track-player';
</pre>
<p>现在，在<code>App</code>中渲染上述组件:</p>
<pre class="language-js hljs">return (
  &lt;SafeAreaView style={styles.container}&gt;
    &lt;Header/&gt;
    &lt;TrackProgress/&gt;
    &lt;Playlist/&gt;
  &lt;/SafeAreaView&gt;
);
</pre>
<p>将以下样式定义添加到样式表中:</p>
<pre class="language-js hljs">  trackProgress: {
    marginTop: 40,
    textAlign: 'center',
    fontSize: 24,
    color: '#eee'
  },
  songTitle: {
    fontSize: 32,
    marginTop: 50,
    color: '#ccc'
  },
  artistName: {
    fontSize: 24,
    color: '#888'
  },
</pre>
<p>运行应用程序。现在，您将看到带有音乐曲目详细信息、曲目进度、播放列表和控制框组件的:</p>
<p><img data-attachment-id="149349" data-permalink="https://blog.logrocket.com/react-native-track-player-complete-guide/attachment/complete-music-player-app-ui/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/12/complete-music-player-app-ui.gif" data-orig-size="730,1542" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="complete-music-player-app-ui" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/12/complete-music-player-app-ui-142x300.gif" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/12/complete-music-player-app-ui-485x1024.gif" decoding="async" class="aligncenter wp-image-149349 size-full jetpack-lazy-image" src="../Images/c07b43b654d701b42ece8a79770c0ceb.png" alt="complete music player app UI" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2022/12/complete-music-player-app-ui.gif?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/12/complete-music-player-app-ui.gif"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="149349" data-permalink="https://blog.logrocket.com/react-native-track-player-complete-guide/attachment/complete-music-player-app-ui/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/12/complete-music-player-app-ui.gif" data-orig-size="730,1542" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="complete-music-player-app-ui" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/12/complete-music-player-app-ui-142x300.gif" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/12/complete-music-player-app-ui-485x1024.gif" decoding="async" loading="lazy" class="aligncenter wp-image-149349 size-full" src="../Images/c07b43b654d701b42ece8a79770c0ceb.png" alt="complete music player app UI" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/12/complete-music-player-app-ui.gif"/></noscript>
<p>您可以通过添加带有<code>[react-native-slider](<a href="https://github.com/callstack/react-native-slider" rel="nofollow">https://github.com/callstack/react-native-slider</a>)</code>的搜索栏来改进音乐曲目播放器，但我们不会在本教程中深入讨论<code>react-native-slider</code>集成。添加搜索栏很容易，只需执行以下步骤:</p>
<ol>
<li>用<code>useProgress</code>钩子更新滑块</li>
<li>为滑块附加一个事件处理程序，并调用<code>TrackPlayer.seekTo</code>来改变播放状态</li>
</ol>
<h3 id="loop-shuffle-playlist-items">如何循环和随机播放播放列表项目</h3>
<p>您可以使用我们之前测试过的源代码来转到上一首或下一首音乐曲目。自从我们在<code>addTracks</code>服务中使用了<code>RepeatMode.Queue</code>模式以来，每当播放列表结束时，它将再次开始(循环)。您可以使用<code>RepeatMode.Track</code>通过<code>TrackPlayer.setRepeatMode</code>功能循环播放当前曲目。尝试自己在控制盒中添加一个播放列表-重复模式选择器按钮！</p>
<p>如果你需要随机播放播放列表怎么办？原生播放列表重排功能仍然是一个正在进行的功能请求(<a href="https://github.com/doublesymmetry/react-native-track-player/issues/1711">问题#1711 </a>)，但是现在，我们可以在JavaScript端实现播放列表重排。</p>
<p>首先，在<code>Playlist</code>组件中实现播放列表洗牌:</p>
<pre class="language-js hljs">async function handleShuffle() {
  let queue = await TrackPlayer.getQueue();
  await TrackPlayer.reset();
  queue.sort(() =&gt; Math.random() - 0.5);
  await TrackPlayer.add(queue);

  loadPlaylist()
}

return(
  &lt;View&gt;
    &lt;View style={styles.playlist}&gt;
      &lt;FlatList
        data={queue}
        renderItem={({item, index}) =&gt; &lt;PlaylistItem
                                          index={index}
                                          title={item.title}
                                          isCurrent={currentTrack == index }/&gt;
        }
      /&gt;
    &lt;/View&gt;
    &lt;Controls onShuffle={handleShuffle}/&gt;
  &lt;/View&gt;
);
</pre>
<p>这里，我们提取当前队列，对其进行洗牌，并通过<code>handleShuffle</code>函数将其重新加载到播放列表中。接下来，添加一个新的图标按钮进行随机播放:</p>
<pre class="language-js hljs">function Controls({ onShuffle }) {
  const playerState = usePlaybackState();

  async function handlePlayPress() {
    if(await TrackPlayer.getState() == State.Playing) {
      TrackPlayer.pause();
    }
    else {
      TrackPlayer.play();
    }
  }

  return(
    &lt;View style={{flexDirection: 'row',
      flexWrap: 'wrap', alignItems: 'center'}}&gt;
        &lt;Icon.Button
          name="arrow-left"
          size={28}
          backgroundColor="transparent"
          onPress={() =&gt; TrackPlayer.skipToPrevious()}/&gt;
        &lt;Icon.Button
          name={playerState == State.Playing ? 'pause' : 'play'}
          size={28}
          backgroundColor="transparent"
          onPress={handlePlayPress}/&gt;
        &lt;Icon.Button
          name="arrow-right"
          size={28}
          backgroundColor="transparent"
          onPress={() =&gt; TrackPlayer.skipToNext()}/&gt;
        &lt;Icon.Button
          name="random"
          size={28}
          backgroundColor="transparent"
          onPress={onShuffle}/&gt;
    &lt;/View&gt;
  );
}
</pre>
<p>运行应用程序后，您可以使用随机播放功能:</p>
<p><img data-attachment-id="149352" data-permalink="https://blog.logrocket.com/react-native-track-player-complete-guide/attachment/shuffle-feature/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/12/shuffle-feature.gif" data-orig-size="730,1542" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="shuffle-feature" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/12/shuffle-feature-142x300.gif" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/12/shuffle-feature-485x1024.gif" decoding="async" class="aligncenter wp-image-149352 size-full jetpack-lazy-image" src="../Images/4b3ddacd20f1eaf506f6333d4e8957da.png" alt="shuffle feature" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2022/12/shuffle-feature.gif?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/12/shuffle-feature.gif"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="149352" data-permalink="https://blog.logrocket.com/react-native-track-player-complete-guide/attachment/shuffle-feature/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/12/shuffle-feature.gif" data-orig-size="730,1542" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="shuffle-feature" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/12/shuffle-feature-142x300.gif" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/12/shuffle-feature-485x1024.gif" decoding="async" loading="lazy" class="aligncenter wp-image-149352 size-full" src="../Images/4b3ddacd20f1eaf506f6333d4e8957da.png" alt="shuffle feature" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/12/shuffle-feature.gif"/></noscript>
<p>添加一个按钮来自己播放随机的音乐曲目！同样，您可以通过操作曲目播放器队列来重新排序播放列表项并创建多个播放列表。播放列表管理操作将有效地工作，因为该库在本地使用适当的数据结构处理播放列表。</p>
<h3 id="track-player-events">使用跟踪播放器事件</h3>
<p>我们已经在上面的组件中使用了一些track player事件。例如，在<code>Header</code>组件中，我们使用了<code>useTrackPlayerEvents</code>钩子来检测音乐曲目更改事件。</p>
<p>该库允许您为两种事件类型附加函数:</p>
<ol>
<li>应用内事件:这些事件在应用内自动发生或由用户发起，即播放/暂停事件。该库提供了<code>useTrackPlayerEvents</code>和<code>usePlaybackState</code>挂钩来订阅这些应用内事件</li>
<li>远程事件:这些事件由操作系统发起，即当用户按下通知区域迷你播放器的<b>播放</b>按钮时，库会调度<code>Event.RemoteNext</code>事件。我们将在下一节讨论处理远程事件</li>
</ol>
<p>您可以从<a href="https://react-native-track-player.js.org/docs/api/events">官方文档</a>中浏览所有支持的事件详情。</p>
<h3 id="working-background-mode">使用背景模式</h3>
<p>用户在使用音乐应用程序时通常会进行多任务处理。例如，移动用户可以在听音乐的同时使用消息应用。</p>
<p>音乐应用通常即使在后台模式下也会播放当前播放列表，但如果用户想要播放下一首歌曲呢？用户可以从通知面板按下<strong>下一个</strong>按钮，而不是再次打开音乐播放器应用。</p>
<p>运行示例应用程序并检查通知栏。您将看到一个小的、特定于平台的播放器组件，如下所示:</p>
<p><img data-attachment-id="149355" data-permalink="https://blog.logrocket.com/react-native-track-player-complete-guide/attachment/small-platform-specific-player/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/12/small-platform-specific-player.gif" data-orig-size="730,1542" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="small-platform-specific-player" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/12/small-platform-specific-player-142x300.gif" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/12/small-platform-specific-player-485x1024.gif" decoding="async" class="aligncenter wp-image-149355 size-full jetpack-lazy-image" src="../Images/3df05caf7bfd07486bdea5b13dbbdc9a.png" alt="small, platform-specific player" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2022/12/small-platform-specific-player.gif?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/12/small-platform-specific-player.gif"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="149355" data-permalink="https://blog.logrocket.com/react-native-track-player-complete-guide/attachment/small-platform-specific-player/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/12/small-platform-specific-player.gif" data-orig-size="730,1542" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="small-platform-specific-player" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/12/small-platform-specific-player-142x300.gif" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/12/small-platform-specific-player-485x1024.gif" decoding="async" loading="lazy" class="aligncenter wp-image-149355 size-full" src="../Images/3df05caf7bfd07486bdea5b13dbbdc9a.png" alt="small, platform-specific player" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/12/small-platform-specific-player.gif"/></noscript>
<p>但是，你还不能用这个迷你播放器控制播放列表。原因是库触发远程事件处理程序，而不是改变轨道播放器状态。这种情况为开发人员提供了处理远程事件的灵活性。</p>
<p>你还记得我们在演示应用的代码库中有一个<code>TODO:</code>注释吗？这就是我们将<code>playbackService</code>附加到库的地方——但是我们没有为远程事件实现动作。</p>
<p>使用<code>playbackService</code>中的以下代码根据远程事件控制轨道播放器:</p>
<pre class="language-js hljs">export async function playbackService() {
  TrackPlayer.addEventListener(Event.RemotePause, () =&gt; {
    console.log('Event.RemotePause');
    TrackPlayer.pause();
  });

  TrackPlayer.addEventListener(Event.RemotePlay, () =&gt; {
    console.log('Event.RemotePlay');
    TrackPlayer.play();
  });

  TrackPlayer.addEventListener(Event.RemoteNext, () =&gt; {
    console.log('Event.RemoteNext');
    TrackPlayer.skipToNext();
  });

  TrackPlayer.addEventListener(Event.RemotePrevious, () =&gt; {
    console.log('Event.RemotePrevious');
    TrackPlayer.skipToPrevious();
  });
}
</pre>
<p>即使在后台运行应用程序时，上述服务也会被执行。回放/播放器事件应该像预期的那样在后台模式下工作——换句话说，<code>react-native-track-player</code>库支持后台模式，无需定制调整！</p>
<p>运行应用程序，在音乐播放器上打开另一个应用程序，并使用通知区域的迷你播放器播放下一首音乐曲目——一切都会正常工作。</p>
<p>在Android上，音乐播放器应用程序会移除通知区域的迷你播放器，并在终止时停止播放音乐，但您可以通过在<code>setupPlayer</code>服务中使用以下设置来避免这种行为:</p>
<pre class="language-js hljs">await TrackPlayer.updateOptions({
  android: {
    appKilledPlaybackBehavior:
      AppKilledPlaybackBehavior.ContinuePlayback,
  },
// ---
</pre>
<h3 id="store-playlist">如何存储播放列表</h3>
<p>在本教程中，出于演示目的，我们使用了一个硬编码的播放列表。但是，在制作音乐应用程序中，你可能需要以一种更易于管理的方式存储你的播放列表。考虑以下存储播放列表信息的选项:</p>
<ul>
<li>如果你的应用程序自动从设备存储器中提取音乐文件(即使用<code><a href="https://blog.logrocket.com/how-to-access-file-systems-react-native/">react-native-fs</a>)</code>)，考虑在应用程序偏好设置或临时文件中缓存播放列表</li>
<li>如果您允许用户管理播放列表，您还可以缓存播放列表并提供导出/导入播放列表的功能</li>
<li>如果你的音乐应用是一个远程音乐播放器(比如Spotify)，你无疑可以将你的播放列表存储在服务器中，并提供一个CRUD API来管理播放列表</li>
</ul>
<h2>结论</h2>
<p>在本教程中，我们开发了一个基于播放列表的音乐曲目播放器来学习<code>react-native-track-player</code>库的特性。<code>react-native-track-player</code>库允许您创建和管理可播放的音乐播放列表。</p>
<p>或者，您可以使用<a href="https://github.com/zmxv/react-native-sound"> <code>react-native-sound</code>库</a>来播放音乐，并用JavaScript自己处理播放列表——然后，您必须基于<code>react-native-sound</code>事件为整个播放列表队列的实现编写代码。尽管您肯定可以开发这样的实现，但是您可能会面临应用程序性能的问题，因为您在JavaScript中处理回放事件和播放列表状态。</p>
<p><code>react-native-track-player</code>库处理本机端的一切，并将事件分派给JavaScript以供UI更新使用。因此，使用<code>react-native-track-player</code>进行可播放音乐播放列表管理可以提高您的工作效率，并为您提供性能第一、生产就绪的解决方案。</p>
<p>从我的GitHub库中找到演示应用的源代码。</p><div class="code-block code-block-18">
<div class="blog-plug inline-plug react-native-plug"><h2><a href="https://lp.logrocket.com/blg/react-native-signup"> LogRocket </a>:即时重现React原生应用中的问题。</h2><a class="signup" href="https://lp.logrocket.com/blg/react-native-signup" target="_blank" rel="noopener noreferrer"><img class="alignnone size-full wp-image-46 jetpack-lazy-image" src="../Images/110055665562c1e02069b3698e6cc671.png" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2021/10/react-native-plug_v2-2.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2021/10/react-native-plug_v2-2.png"/><noscript><img data-lazy-fallback="1" class="alignnone size-full wp-image-46" src="../Images/110055665562c1e02069b3698e6cc671.png" data-original-src="https://blog.logrocket.com/wp-content/uploads/2021/10/react-native-plug_v2-2.png"/></noscript></a><p><a href="https://lp.logrocket.com/blg/react-native-signup" target="_blank" rel="noopener noreferrer"> LogRocket </a>是一款React原生监控解决方案，可帮助您即时重现问题、确定bug的优先级并了解React原生应用的性能。</p><p>LogRocket还可以向你展示用户是如何与你的应用程序互动的，从而帮助你提高转化率和产品使用率。LogRocket的产品分析功能揭示了用户不完成特定流程或不采用新功能的原因。</p><p>开始主动监控您的React原生应用— <a class="signup" href="https://lp.logrocket.com/blg/react-native-signup" target="_blank" rel="noopener noreferrer">免费试用LogRocket】。</a></p></div>
</div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
<html>
<head>
<title>Managing multi-channel notification streams with Notifire - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>用 Notifire - LogRocket 博客管理多渠道通知流</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/managing-multi-channel-notification-streams-notifire/#0001-01-01">https://blog.logrocket.com/managing-multi-channel-notification-streams-notifire/#0001-01-01</a></blockquote><div><article class="article-post">
<p>如今，用户更有可能从多个渠道接收信息。</p>
<p>这样做的根本原因是消费者希望能够根据自己的需求定制沟通渠道——这迫使开发人员跨代码库处理所有这些 API。通知有各种形状和大小；从 Reddit 到脸书，Twitter，等等。</p>
<p>对客户来说，通知代表了他们最喜欢的人、企业和兴趣的更新。因此，通知系统是网站开发者和 SaaS 营销人员将他们的商品呈现在相关人员面前的强有力的方法。</p>
<p>有大量的知识可用，但人们只有这么多的时间和能力来分享，这意味着只有最有吸引力的服务才能吸引他们的目标人群。</p>
<p>同时，跨在线浏览器和移动操作系统的原生通知系统的流行对于能够成功利用它们进行客户拓展的组织是有益的。这些及时的信息会对客户保持和参与绩效产生巨大影响。</p>
<p>在本文中，您将了解 Notifire，它是如何实现的，以及它在根据特定需求为目标终端用户提供机会方面的多功能性。</p>

<h2 id="what-is-notifire">什么不是火？</h2>
<p>Notifire 是一个强大的可定制的开源通知基础设施，它使用一个 API 来管理多渠道的事务通知。</p>
<p>Notifire 的优势和特点:</p>
<ul>
<li>电子邮件、推送通知和 SMS 等所有消息服务都使用相同的 API</li>
<li>轻松管理多个渠道，如 Twilio、SendGrid、Slack 等</li>
<li>面向高级布局和设计的高度可定制、以模板为中心的引擎</li>
<li>缺失变量的内置保护</li>
<li>易于设置和集成</li>
<li>用可预测的静态类型用 TypeScript 编写</li>
<li>社区驱动和开源</li>
</ul>
<h2 id="architecture-and-setup">架构和设置</h2>
<p>Notifire 写在<a href="https://blog.logrocket.com/whats-new-typescript-4-5/" target="_blank" rel="noopener">类型脚本</a>中；你可以用 Notifire 在几分钟内创建一个通知层。</p>
<p>在深入实现之前，您需要理解库背后的架构，以便清楚地了解 Notifire 是如何增强通知的。</p>
<p>Notifire 的架构侧重于关注点的分离。根据这一原则，事务性沟通由许多独立的元素组成，每个元素负责某项工作。为了方便合并和维护额外的功能，必须对通信层进行建模。</p>
<p>看看下面的图表。</p>
<p><img data-attachment-id="96208" data-permalink="https://blog.logrocket.com/managing-multi-channel-notification-streams-notifire/notifire-flow-delivery-diagram-layout/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/02/notifire-flow-delivery-diagram-layout.png" data-orig-size="730,660" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="notifire-flow-delivery-diagram-layout" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/02/notifire-flow-delivery-diagram-layout-300x271.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/02/notifire-flow-delivery-diagram-layout.png" decoding="async" class="aligncenter wp-image-96208 size-full jetpack-lazy-image" src="../Images/ac385200b62efe527770c436cfecae59.png" alt="Notifire Flow Delivery Diagram" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2022/02/notifire-flow-delivery-diagram-layout.png 730w, https://blog.logrocket.com/wp-content/uploads/2022/02/notifire-flow-delivery-diagram-layout-300x271.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2022/02/notifire-flow-delivery-diagram-layout.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/02/notifire-flow-delivery-diagram-layout.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="96208" data-permalink="https://blog.logrocket.com/managing-multi-channel-notification-streams-notifire/notifire-flow-delivery-diagram-layout/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/02/notifire-flow-delivery-diagram-layout.png" data-orig-size="730,660" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="notifire-flow-delivery-diagram-layout" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/02/notifire-flow-delivery-diagram-layout-300x271.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/02/notifire-flow-delivery-diagram-layout.png" decoding="async" loading="lazy" class="aligncenter wp-image-96208 size-full" src="../Images/ac385200b62efe527770c436cfecae59.png" alt="Notifire Flow Delivery Diagram" srcset="https://blog.logrocket.com/wp-content/uploads/2022/02/notifire-flow-delivery-diagram-layout.png 730w, https://blog.logrocket.com/wp-content/uploads/2022/02/notifire-flow-delivery-diagram-layout-300x271.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/02/notifire-flow-delivery-diagram-layout.png"/></noscript>
<p> </p>
<p>以下元素可确保向最终用户成功发送通知:</p>
<h3>模板</h3>
<p>模板充当蓝图，为每条消息提供框架或结构。每条消息都与一个特定的通道相关联，为该通道提供了内容模板和编码规则，如过滤器、优先级和其他影响给定消息传递的元数据。</p>
<h3>提供者</h3>
<p>提供者负责消息传递。他们负责通过指定的渠道向最终用户提供警报。Notifire 处理状态并协调所有特定于提供者的定制，因为每个提供者都是无状态的，并且符合指定的接口。</p>
<h3>扳机</h3>
<p>显示通知消息所需的变量和数据将由每个触发器发送。如果某个值不存在，变量保护模式被激活，消息被<em>而不是</em>发送。</p>
<p>触发器负责通知系统发生了事件，但不负责通知消息将在何时何地发送。</p>
<h3>通信引擎</h3>
<p>通信引擎负责读取模板配置、确定必要的通道、与提供商连接以及执行警报的传递。定时、优先级和信道都由通信引擎维护。</p>
<h3>模板和提供程序存储</h3>
<p>在运行时执行期间，这两层管理配置并保存在内存中以备将来使用。每个存储都提供接口来查询通信引擎要使用的提供者和模板。</p>
<h2 id="template-based-approach">基于模板的方法</h2>
<p>让我们看看 Notifire 中基于模板的方法。</p><div class="code-block code-block-54">
<hr/>
<h3>更多来自 LogRocket 的精彩文章:</h3>

<hr/></div>
<p>模板包含消息传递所需的元数据。这些模板可以重复使用，并存储在模板库中以供访问。包含<code>subject</code>、<code>channel</code>、<code>template</code>和<code>active</code>开关等主要部分。</p>
<p>看看下面这个简单的例子:</p>
<pre class="language-typescript hljs">const UpdateEmailTemplate = await notifire.registerTemplate({
  id: "update-email",
  messages: [
    {
      subject: "Your email update request",
      channel: ChannelTypeEnum.EMAIL,           // Email Channel
      template: `
        Hi {{firstName}}!


        To update your email, click &lt;a href="{{emailLink}}"&gt;here.&lt;/a&gt;


        {{#if organization}}
            &lt;img src="{{organization.logo}}" /&gt;
        {{/if}}
      `,
    },
    {
      channel: ChannelTypeEnum.SMS,             // SMS Channel
      template: ` 
        Hey {{firstName}}, here's the link to update your email: {{emailLink}}
        `,
      active: (trigger) =&gt; !trigger.$phone,
    },
  ],
});
</pre>
<p>如您所见，<code>messages</code>数组保存了一个通信信道列表和要发送给用户的相应消息细节。您可以通过包括类似于上述示例的特定于渠道的详细信息来个性化渠道体验。</p>
<p><code>channel</code>指定用户需要被告知的媒介。基于选择的<code>channel</code>,从提供者存储中使用合适的提供者。</p>
<p>通道的例子可以是:<code>SMS</code>、<code>EMAIL</code>、<code>PUSH</code>、<code>DIRECT_MESSAGE</code>、<code>IN_APP</code>。每个用枚举值指定的<code>channel</code>保存其对象块，如上例所示。</p>
<p><code>template</code>变量保存消息内容。Notifire 利用了<a href="https://handlebarsjs.com/" target="_blank" rel="noopener">把手</a>，因此您可以用把手表达式格式编写模板，如下例所示:</p>
<pre class="language-javascript hljs">{{#each tasks}}
  {{title}}
  {{#if done}}
    &lt;span&gt; Done &lt;/span&gt;
  {{/if}}
{{/each}}
</pre>
<p><code>active</code>开关用于根据提供的布尔值决定是否发送消息。<code>active</code>也用于发送基于触发器的消息。</p>
<h3>基于模板的方法的优势:</h3>
<ul>
<li>高度可定制和可重复使用的通信模板</li>
<li>具有可变保护的可扩展和防故障方法</li>
<li>根据变量、功能、条件和行为确定目标用户</li>
</ul>
<h2 id="integrating-your-favorite-providers">整合您最喜欢的提供商</h2>
<p>Notifire 为提供者提供了一个即插即用的解决方案，一旦加载到提供者存储的内存中，它通常会保持待机模式。让我们看看 Notifire 支持的提供者列表:</p>
<h3>电子邮件</h3>
<p>电子邮件是最常见和最广泛使用的沟通渠道之一。Notifire 提供了下面的接口来实现你自己版本的<code>channel</code>:</p>
<pre class="language-typescript hljs">export interface IProvider {
  id: string;                       // ID of the template
  channelType: ChannelTypeEnum;     // Type of channel such as EMAIL
}

export interface IEmailOptions {
  to: string | string[];            // One or multiple recepients
  subject: string;                  // Subject of the email
  html: string;                     // Content body of the email
  from?: string;                    // Email ID of the sender
  text?: string;                    // Plain text content body of the email
}

export interface IEmailProvider extends IProvider {
  channelType: ChannelTypeEnum.EMAIL;

  sendMessage(options: IEmailOptions): Promise&lt;any&gt;;        // Method to be overridden to send email message
}
</pre>
<p>目前支持流行的电子邮件提供商，包括 SendGrid、Mailgun、AWS SES、邮戳、NodeMailer、Mailjet、Mandrill、SendinBlue、EmailJS，支持的提供商数量还在不断增加。</p>
<p>要注册特定的电子邮件提供者，您需要将它注册到 Notifire 库，如下所示:</p>
<pre class="language-typescript hljs">import { SESEmailProvider } from "@notifire/ses"        // Import your required provider

const provider = new SESEmailProvider({                 // Declare your provider
    region: "eu-west-1",                                ////
    accessKeyId: "AWS_ACCESS_KEY_ID",                   ////    Provide configuration details to register your provider
    secretAccessKey: "AWS_SECRET_ACCESS_KEY",           ////
    from: "<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="c6a0b4a9ab86a3aba7afaae8a5a9ab">[email protected]</a>",                             ////
});                                                     //

import { MailgunEmailProvider } from '@notifire/mailgun';   // Mailgun email provider

const provider = new MailgunEmailProvider({
  apiKey: process.env.MAILGUN_API_KEY,
  domain: process.env.MAILGUN_DOMAIN,
  username: process.env.MAILGUN_USERNAME,
});

import { SendinblueEmailProvider } from './sendinblue.provider';    //  SendinBlue email provider

const provider = new SendinblueEmailProvider({
  apiKey: process.env.SENDINBLUE_API_KEY
});
</pre>
<h3>短信</h3>
<p>就像电子邮件一样，Notifire 也允许短信提供商。下面是用于实现 SMS 提供程序的接口:</p>
<pre class="language-typescript hljs">export interface IProvider {
  id: string;                           // ID of the template
  channelType: ChannelTypeEnum;         // Type of communication channel
}

export interface ISmsOptions {
  to: string;                           // Number on which SMS needs to be sent
  content: string;                      // Content body to be sent in the SMS
  from?: string;                        // Number of the sender
}

export interface ISmsProvider extends IProvider {
  sendMessage(options: ISmsOptions): Promise&lt;any&gt;;      // Method to be overridden to send email message

  channelType: ChannelTypeEnum.SMS;
}
</pre>
<p>目前支持包括 Twilio、AWS SNS 和 Plivo 在内的流行短信提供商，支持的短信提供商数量也在增长。要注册特定的 SMS 提供程序，您需要将它注册到 Notifire 库，如下所示:</p>
<pre class="language-typescript hljs">import { TwilioSmsProvider } from '@notifire/twilio';   // Twilio SMS provider

const provider = new TwilioSmsProvider({
  accountSid: process.env.TWILIO_ACCOUNT_SID,
  authToken: process.env.TWILIO_AUTH_TOKEN,
  from: process.env.TWILIO_FROM_NUMBER,                 // a valid twilio phone number
});

import { SNSSmsProvider } from "@notifire/sns"          // AWS SNS provider

const provider = new SNSSmsProvider({
    region: "eu-west-1",
    accessKeyId: "AWS_ACCESS_KEY_ID",
    secretAccessKey: "AWS_SECRET_ACCESS_KEY",
});

import { PlivoSmsProvider } from '@notifire/plivo';      // Plivo SMS provider

const provider = new PlivoSmsProvider({
  accountSid: process.env.PLIVO_ACCOUNT_ID,
  authToken: process.env.PLIVO_AUTH_TOKEN,
  from: process.env.PLIVO_FROM_NUMBER,
});
</pre>
<h3>更多提供商</h3>
<p>如您所见，根据您的需要即插即用您最喜欢的提供商是很简单的；您需要做的就是使用配置向 Notifire 注册提供程序，并开始使用声明的模板。</p>
<p>除了电子邮件和短信提供商，Notifire 将来还会扩展，允许设置直接消息、推送通知和应用内消息的提供商。</p>
<p>这将包括 Slack、微软团队、Discord、PagerDuty、AWS SNS 等提供商。</p>
<h2 id="scaling-your-implementation">扩展您的实施</h2>
<p>如今，许多组织使用各种不同的沟通平台，随着此类平台的不断增加，事情开始变得混乱。Notifire 通过在架构中使用模板等组件，非常聪明地解决了这个问题。</p>
<p>当扩展您的产品或服务时，您的实现还需要处理用户和通信的规模。</p>
<p>下面是一些您应该遵循的最佳实践，以确保为您的用户提供良好的体验。</p>
<h3>避免使用通用内容</h3>
<p>在推送消息中使用一般的、冗长的、非个人化的材料是一个严重的错误，会让接收者不知所措、心烦意乱。这种警告可能导致与该特定推送消息链接的移动应用被卸载。</p>
<h3>避免轰炸你的用户</h3>
<p>在没有足够的商业智能(BI)和消费者行为分析的情况下发送通知或通信可能会导致糟糕的用户体验，并且您可能会以不相关的用户为目标。</p>
<h3>避免在不恰当的时间锁定目标</h3>
<p>营销人员在使用推送通知时最常犯的一个错误是在错误的时间发送。在繁忙的工作时间或深夜发送信息不是一个好主意。这可能会激怒用户，结果他们可能会停止使用你的产品或服务。</p>
<h3>利用个性化</h3>
<p>在许多情况下，营销人员会在没有对行为特征、个人数据、位置信息和客户兴趣进行充分的行为分析的情况下发送通用通知，从而犯下这种错误。</p>
<p>有几种用户以不同的方式响应警报。绝大多数用户，57%的用户阅读并打开应用程序，如果信息是适当定制的，他们会立即回答。</p>
<h3>发送欢迎通知</h3>
<p>当用户完全加入后，你可以向他们发送一条欢迎他们加入应用的推送通知。或者，你可以给他们提供一张你提供的产品的折扣券，让他们有一个好的开始。同样，作为一名试用者，给他们提供一些免费的好东西——任何能让他们体验你的软件并吸引他们更多使用它的东西。</p>
<h2>结论</h2>
<p>在当今的数字市场中，通过适当的通知和沟通来锁定用户是至关重要的。</p>
<p>不言而喻，通知已经超越了应用程序、产品、服务及其用户之间的所有其他通信模式。</p>
<p>因此，现代组织的存在需要强大的通知策略。</p>
<p>Notifire 提供了一个平台，以惊人的能力构建和扩展您的通知基础设施。</p>
<p>随着用例的增长和扩展，Notifire 将为您提供大量的选项和提供者实现，以便无缝地集成到您的工作流中。</p>
<p>该解决方案旨在为具有良好能力的开发人员提供一个便捷的解决方案。</p><div class="code-block code-block-2">
<div class="blog-plug base-cta"><h2>使用<a class="signup" href="https://lp.logrocket.com/blg/signup" target="_blank" rel="noopener noreferrer"> LogRocket </a>消除传统错误报告的干扰</h2>
<a href="https://lp.logrocket.com/blg/signup" class="signup" target="_blank" rel="noopener noreferrer"><img class="alignnone size-full wp-image-46 jetpack-lazy-image" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/><noscript><img data-lazy-fallback="1" class="alignnone size-full wp-image-46" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/></noscript></a>
<p><a href="https://lp.logrocket.com/blg/signup" target="_blank" rel="noopener noreferrer"> LogRocket </a>是一个数字体验分析解决方案，它可以保护您免受数百个假阳性错误警报的影响，只针对几个真正重要的项目。LogRocket 会告诉您应用程序中实际影响用户的最具影响力的 bug 和 UX 问题。</p>
<p>然后，使用具有深层技术遥测的会话重放来确切地查看用户看到了什么以及是什么导致了问题，就像你在他们身后看一样。</p>
<p>LogRocket 自动聚合客户端错误、JS 异常、前端性能指标和用户交互。然后 LogRocket 使用机器学习来告诉你哪些问题正在影响大多数用户，并提供你需要修复它的上下文。</p>
<p>关注重要的 bug—<a class="signup" href="https://lp.logrocket.com/blg/signup-issue-free" target="_blank" rel="noopener noreferrer">今天就试试 LogRocket】。</a></p></div></div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
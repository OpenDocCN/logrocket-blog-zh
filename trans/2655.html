<html>
<head>
<title>Intercepting JavaScript Fetch API requests and responses - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>拦截 JavaScript 获取 API 请求和响应</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/intercepting-javascript-fetch-api-requests-responses/#0001-01-01">https://blog.logrocket.com/intercepting-javascript-fetch-api-requests-responses/#0001-01-01</a></blockquote><div><article class="article-post">
<p>拦截器是可以用来预处理或后处理 HTTP 调用的代码块，有助于全局错误处理、身份验证、日志记录等等。在本文中，您将学习如何<a href="https://blog.logrocket.com/axios-vs-fetch-best-http-requests/">拦截 JavaScript Fetch API 调用</a>。</p>
<p>有两种类型的事件您可能想要拦截 HTTP 调用，请求和响应事件。请求拦截器应该在发送实际的 HTTP 请求之前执行，而响应拦截器应该在到达发出调用的应用程序代码之前执行。</p>
<p>在深入研究代码之前，我们需要理解几个重要因素。首先，<a href="https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API"> Fetch API </a>本身不支持拦截器。此外，需要额外的包来<a href="#node">使用 Node.js </a>中的 Fetch API。</p>
<h2 id="">JavaScript 获取 API</h2>
<p>首先，让我们介绍一下 Fetch API 的一些基础知识，例如语法:</p>
<pre class="language-javascript hljs">const fetchResponsePromise = fetch(resource [, init])
</pre>
<p><code>resource</code>定义你想要获取的资源，可以是一个<a href="https://developer.mozilla.org/en-US/docs/Web/API/Request)"> <code>Request</code>对象</a>或者一个 URL。<code>init</code>是一个可选对象，它将包含您想要应用于这个特定请求的任何定制配置。</p>
<p>获取 API 是基于承诺的。因此，当您调用 Fetch 方法时，您将得到一个响应承诺。这里称为<code>fetchResponsePromise</code>，如上例所示。</p>
<p>默认情况下，Fetch 使用<code>GET</code>方法进行 API 调用，如下所示:</p>
<pre class="language-javascript hljs">fetch('https://jsonplaceholder.typicode.com/todos/1')
.then((response) =&gt; response.json())
.then((json) =&gt; console.log(json));
</pre>
<p>下面是一个带有 Fetch 的<code>POST</code>请求的例子:</p>
<pre class="language-javascript hljs">fetch('https://jsonplaceholder.typicode.com/todos', {
  method: 'POST',
  body: JSON.stringify({
    completed: false,
    id: 1,
    title: 'New Todo',
    userId: 1,
  }),
  headers: new Headers({
    'Content-Type': 'application/json; charset=UTF-8',
  }),
})
.then((response) =&gt; response.json())
.then((json) =&gt; console.log(json));
</pre>
<p><code>POST</code>调用必须有一个<code>body</code>。请看一下<a href="https://developer.mozilla.org/en-US/docs/Web/API/fetch">获取文档</a>了解更多细节。</p>
<h2 id="implementinginterceptors">实现拦截器</h2>
<p>有两种方法可以将拦截器添加到我们的 Fetch API 调用中；我们可以使用猴子补丁或者<a href="https://github.com/werk85/fetch-intercept"> <code>fetch-intercept</code>库</a>。</p>
<h2 id="monkeypatchingwithfetch">用获取进行猴子修补</h2>
<p>为任何 JavaScript 函数或方法创建拦截器的一种方法是用猴子修补它。Monkey patching 是一种用您的函数版本覆盖原始功能的方法。</p>
<p>让我们一步一步地看看如何使用 monkey 补丁为 Fetch API 创建一个拦截器:</p>
<pre class="language-javascript hljs">const { fetch: originalFetch } = window;

window.fetch = async (...args) =&gt; {
    let [resource, config ] = args;
    // request interceptor here
    const response = await originalFetch(resource, config);
    // response interceptor here
    return response;
};
</pre>
<p>上面的代码用一个自定义实现覆盖了原始的 Fetch 方法，并在其中调用原始的 Fetch 方法。您将使用这个样板代码来创建请求和响应拦截器。</p>
<h3>请求拦截器</h3>
<p>在下面的例子中，我们将创建一个简单的请求拦截器来改变一个插图的资源 URL:</p>
<pre class="language-javascript hljs">const { fetch: originalFetch } = window;
window.fetch = async (...args) =&gt; {
    let [resource, config ] = args;

    // request interceptor starts
    resource = 'https://jsonplaceholder.typicode.com/todos/2';
    // request interceptor ends

    const response = await originalFetch(resource, config);

    // response interceptor here
    return response;
};


fetch('https://jsonplaceholder.typicode.com/todos/1')
.then((response) =&gt; response.json())
.then((json) =&gt; console.log(json));

// log
// {
//   "userId": 1,
//   "id": 2,
//   "title": "quis ut nam facilis et officia qui",
//   "completed": false
// }
</pre>
<p>这个 API 调用将从<code><a href="https://jsonplaceholder.typicode.com/todos/2" rel="nofollow">https://jsonplaceholder.typicode.com/todos/2</a></code>而不是<code><a href="https://jsonplaceholder.typicode.com/todos/1" rel="nofollow">https://jsonplaceholder.typicode.com/todos/1</a></code>获取数据，如<code>todo</code>的 ID <code>2</code>所示。</p>
<blockquote><p>注意:请求拦截器最常见的用例之一是更改身份验证的头。</p></blockquote>
<h3>响应拦截器</h3>
<p>响应拦截器会在 API 响应被传递给实际的调用者之前拦截它。让我们来看看下面的代码:</p>
<pre class="language-javascript hljs">const { fetch: originalFetch } = window;
window.fetch = async (...args) =&gt; {
  let [resource, config] = args;

  let response = await originalFetch(resource, config);

  // response interceptor
  const json = () =&gt;
    response
      .clone()
      .json()
      .then((data) =&gt; ({ ...data, title: `Intercepted: ${data.title}` }));

  response.json = json;
  return response;
};

fetch('https://jsonplaceholder.typicode.com/todos/1')
  .then((response) =&gt; response.json())
  .then((json) =&gt; console.log(json));

// log
// {
//     "userId": 1,
//     "id": 1,
//     "title": "Intercepted: delectus aut autem",
//     "completed": false
// }
</pre>
<p>在上面的代码中，我们更改了 JSON 方法以返回一些定制数据，而不是原始数据。查看文档以了解更多关于可以更改的<a href="https://developer.mozilla.org/en-US/docs/Web/API/Response">属性。</a></p>
<blockquote><p>注意:回复只允许消费一次。因此，每次想要使用响应时，都需要用<a href="https://developer.mozilla.org/en-US/docs/Web/API/Response/clone">克隆它。</a></p></blockquote>
<h3>处理错误</h3>
<p>通过检查<code>response.ok</code>和<code>response.status</code>的值，可以很容易地处理请求的错误。在下面的代码片段中，您可以拦截<code>404</code>错误:</p>
<pre class="language-javascript hljs">const { fetch: originalFetch } = window;
window.fetch = async (...args) =&gt; {
  let [resource, config] = args;
  let response = await originalFetch(resource, config);
  if (!response.ok &amp;&amp; response.status === 404) {
    // 404 error handling
    return Promise.reject(response);
  }
  return response;
};
fetch('https://jsonplaceholder.typicode.com/todos/1000000')
  .then((response) =&gt; response.json())
  .then((json) =&gt; console.log(json))
  .catch((error) =&gt; console.error(error));
</pre>
<h3 id="node">节点. js</h3>
<p>您可以在 Node.js 中使用相同的方法。但是，Node.js 本身不支持 Fetch API(尽管对 Fetch API 的本机支持将在 Node.js 的未来版本中<a href="https://github.com/nodejs/node/pull/41749">可用)。现在，您需要安装</a><a href="https://github.com/node-fetch/node-fetch">节点获取</a>包，然后 monkey 修补<code>fetch</code>方法。</p>
<h2>使用提取截取库</h2>
<p>如果你不喜欢做<code>dirty</code>工作(双关语)，那么<code><a href="https://github.com/werk85/fetch-intercept">fetch-intercept</a></code>库允许你用一个更干净的 API 注册拦截器。您可以使用 npm 或 Yarn 安装库，如下所示:</p>
<pre class="language-bash hljs">npm install fetch-intercept whatwg-fetch --save
// or
yarn install fetch-intercept whatwg-fetch</pre>
<blockquote><p>注意:fetch-intercept 库只支持浏览器，在 Node.js 中不起作用，而且它需要<a href="https://github.com/whatwg/fetch"> whatwg-fetch </a>作为依赖才能工作。</p></blockquote>
<p>使用下面的代码，我们可以实现与我们的 monkey 补丁示例中相同的请求和响应拦截器:</p>
<pre class="language-javascript hljs">import * as fetchIntercept from 'fetch-intercept';

const unregister = fetchIntercept.register({
  request: function (url, config) {
    const modifiedUrl = `https://jsonplaceholder.typicode.com/todos/2`;
    return [modifiedUrl, config];
  },

  requestError: function (error) {
    return Promise.reject(error);
  },

  response: function (response) {
    const clonedResponse = response.clone();
    const json = () =&gt;
      clonedResponse
        .json()
        .then((data) =&gt; ({ ...data, title: `Intercepted: ${data.title}` }));

    response.json = json;
    return response;
  },

  responseError: function (error) {
    return Promise.reject(error);
  },
});

fetch('https://jsonplaceholder.typicode.com/todos/1')
  .then((response) =&gt; response.json())
  .then((json) =&gt; console.log(json));

// unregister interceptors
unregister();
</pre>
<p><code>register</code>方法允许您为 Fetch API 调用注册拦截器。它接受一个带有<code>request</code>、<code>requestError</code>、<code>response</code>和<code>responseError</code>回调的对象。<code>register</code>方法返回另一个可以用来注销拦截器的方法。</p>
<p>Fetch API 本身不支持拦截器。然而，还有其他支持拦截器的用于进行 HTTP 调用的库。看看<a href="https://axios-http.com/docs/interceptors"> Axios </a>，它提供了开箱即用的功能。</p>
<h2 id="summary">摘要</h2>
<p>在本文中，我们介绍了什么是 JavaScript 拦截器，学习了如何通过 monkey 修补 Fetch API 和使用 fetch-intercept 库来创建拦截器。</p>
<p>拦截器最初是由 Angular 引入的，它有助于各种各样的用例，比如帮助进行全局错误处理、身份验证、日志记录等等。您可以使用本文中描述的方法将拦截器添加到您的 JavaScript 应用程序中，但是，请记住 Node.js 还需要额外的依赖项</p>
<p>我希望你喜欢这篇文章，如果你有任何问题，一定要留下评论。编码快乐！</p><div class="code-block code-block-27">
<div class="blog-plug inline-plug vanilla-javascript-cta"><h2>通过理解上下文，更容易地调试 JavaScript 错误</h2>
<p>调试代码总是一项单调乏味的任务。但是你越了解自己的错误，就越容易改正。</p>
<p>LogRocket 让你以新的独特的方式理解这些错误。我们的前端监控解决方案跟踪用户与您的 JavaScript 前端的互动，让您能够准确找出导致错误的用户行为。</p>
<a href="https://lp.logrocket.com/blg/javascript-signup" class="signup" target="_blank" rel="noopener noreferrer"><img class="alignnone size-full wp-image-46 jetpack-lazy-image" src="../Images/cbfed9be3defcb505e662574769a7636.png" alt="LogRocket Dashboard Free Trial Banner" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2020/06/reproduce-javascript-errors.gif?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/06/reproduce-javascript-errors.gif"/><noscript><img data-lazy-fallback="1" class="alignnone size-full wp-image-46" src="../Images/cbfed9be3defcb505e662574769a7636.png" alt="LogRocket Dashboard Free Trial Banner" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/06/reproduce-javascript-errors.gif"/></noscript></a>
<p>LogRocket 记录控制台日志、页面加载时间、堆栈跟踪、慢速网络请求/响应(带有标题+正文)、浏览器元数据和自定义日志。理解您的 JavaScript 代码的影响从来没有这么简单过！</p>
<a class="signup" href="https://lp.logrocket.com/blg/javascript-signup" target="_blank" rel="noopener noreferrer">Try it for free</a><p>.</p></div>


</div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
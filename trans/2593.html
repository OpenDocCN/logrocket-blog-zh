<html>
<head>
<title>Cloning Solidity smart contracts using the factory pattern - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>使用工厂模式克隆 Solidity 智能合同</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/cloning-solidity-smart-contracts-factory-pattern/#0001-01-01">https://blog.logrocket.com/cloning-solidity-smart-contracts-factory-pattern/#0001-01-01</a></blockquote><div><article class="article-post">
<h2 id="introduction">介绍</h2>
<p>在区块链开发中，将数据集挖掘到区块链是一个非常昂贵的过程，因为挖掘到下一个区块的每个新数据都要收费。在区块链上部署智能合约会导致将合约数据挖掘到下一个块中，如果部署在以太坊区块链上，这将需要一些在以太中收取的汽油费。</p>
<p>本文将实际演示如何使用工厂模式以正确的方式部署智能契约的多个实例。此外，我们将讨论工厂模式，它的好处，以及何时使用它。</p>
<h2 id="prerequisite">先决条件</h2>
<p>要阅读本文，您应该先了解使用 Solidity 进行智能契约开发的知识。</p>
<p>本文将涵盖以下内容:</p>

<h2 id="the-factory-pattern">工厂模式</h2>
<p>工厂设计模式是一种众所周知的编程模式。这个概念很简单:不是直接创建对象的实例，而是由一个单独的对象(工厂)来完成。</p>
<p>这与可靠性是一样的，因为智能合约是对象。在 Solidity 中，工厂是一个将部署其他契约的多个实例的契约。</p>
<p>我们有时需要创建不同类型的对象，但是在运行时执行代码之前，我们不知道我们将实例化哪种类型的对象。在这种情况下，工厂技术就派上了用场。</p>
<p>通常，一个基本的工厂契约应该能够部署同一个契约的多个实例，将这些创建的实例存储在区块链上，并在需要时检索它们。您可能希望添加更多的功能来管理已部署的协定，例如检索特定的协定实例、禁用协定实例等等。</p>
<h3 id="benefits-of-using-the-factory-pattern-in-solidity">在 Solidity 中使用工厂模式的好处</h3>
<p>以下是在 Solidity 中使用工厂模式的好处:</p>
<ol>
<li>部署多个高能效合同</li>
<li>跟踪所有已部署的合同</li>
<li>节省多项合同部署的成本</li>
</ol>
<h3 id="when-to-use-the-factory-pattern">何时使用工厂模式</h3>
<p>工厂模式在以下情况下有效:</p>
<ul>
<li>当我们需要在运行时快速生成智能契约的多个实例时</li>
<li>当我们处理大量具有相同功能的合同时</li>
</ul>
<h3 id="types-of-factory-patterns-in-solidity">Solidity 中工厂模式的类型</h3>
<p>我们将讨论在<a href="https://blog.logrocket.com/writing-smart-contracts-solidity/" target="_blank" rel="noopener"> Solidity smart contracts </a>中通常实现的两种工厂模式。这些模式包括:</p>
<ul>
<li>普通工厂模式——该工厂模式部署其他契约的多个实例，而不进行任何优化以节省每次部署的时间</li>
<li>克隆工厂模式——这种工厂模式部署了其他契约的多个实例，强调优化以节省每次部署的时间</li>
</ul>
<h3 id="our-first-solidity-smart-contract">我们的第一份可靠智能合同</h3>
<p>我们将创建一个简单的智能契约，工厂契约将使用它来部署它的多个实例:</p>
<pre class="language-solidity hljs">// SPDX-License-Identifier: MIT
pragma solidity &gt;0.4.23 &lt;0.9.0;

contract Foundation {
    string public name;
    address public owner;

    constructor(
        string memory _name,
        address _owner
    ) public {
        name = _name;
        owner = _owner;
    }
    
}
</pre>
<p>因为以太坊是一个开源项目，所以第一行显示了合同的开源许可。第二行指定了执行本合同所需的可靠性版本。</p>
<p>接下来，我们建立<code>Foundation</code>契约，它类似于其他面向对象编程语言中的一个类。这里的构造函数用中作为参数提供的值初始化协定的状态变量。当我们创建一个契约实例时，会调用<code>constructor</code>函数。</p>
<h3 id="writing-our-first-factory-contract">撰写我们的第一份工厂合同</h3>
<p>基础契约目前无法创建。因此，我们将创建一个工厂契约，它将使用正常的工厂模式创建基础契约的各个实例。</p>
<p>下面是一份正常的工厂合同应该是什么样子的:</p>
<pre class="language-solidity hljs">// SPDX-License-Identifier: MIT
pragma solidity &gt;0.4.23 &lt;0.9.0;
import "./Foundation.sol";
contract FoundationFactory {
    Foundation[] private _foundations;
    function createFoundation(
        string memory name
    ) public {
        Foundation foundation = new Foundation(
            name,
            msg.sender
        );
        _foundations.push(foundation);
    }
    function allFoundations(uint256 limit, uint256 offset)
        public
        view
        returns (Foundation[] memory coll)
    {
        return coll;
    }
}
</pre>
<p>这里，这段代码导入了<code>Foundation</code>契约，我们希望为其创建多个实例。<code>_foundations</code>变量保存创建的<code>Foundation</code>契约的实例。</p>
<p><code>createFoundation</code>函数部署<code>Foundation</code>合同的一个实例并将其存储在区块链中，而<code>allFoundations</code>函数检索存储在区块链中的<code>Foundation</code>合同的所有实例。</p>
<h3 id="a-drawback-of-the-normal-factory-pattern">正常工厂模式的一个缺点</h3>
<p>CREATE 操作码的 gas 成本目前为 32，000 Gwei。每部署一个<code>Foundation</code>合同实例，收取 32,000 Gwei 的燃气费。</p>
<p>正常工厂模式的主要缺点是<a href="https://ethereum.stackexchange.com/q/84764/33305" target="_blank" rel="noopener">高昂的天然气成本</a>。这就是克隆工厂模式派上用场的地方。</p>
<h2 id="the-cloned-factory-pattern-the-right-pattern-for-deploying-multiple-instances-of-our-solidity-smart-contract">克隆工厂模式:部署我们的 Solidity smart 契约的多个实例的正确模式</h2>
<h3 id="why-the-clone-factory-pattern">为什么是克隆工厂模式？</h3>
<p>因为我们部署的是同一个契约，所以契约的每个实例都有相同的字节码。因此，存储每个部署的所有字节码会重复地增加字节码的 gas 成本的浪费。</p>
<p>这个问题的解决方案是一种机制，只部署一个<code>Foundation</code>契约的实例，让所有其他<code>Foundation</code>契约的实例充当代理，将调用委托给第一个<code>Foundation</code>契约的实例，并允许函数在代理契约的上下文中运行。这样，<code>Foundation</code>契约的每个实例都有自己的状态，并简单地使用我们建立的<code>Foundation</code>契约的实例作为库。</p>
<p>由<a href="https://github.com/yarrumretep" target="_blank" rel="noopener">彼得·默里</a>、<a href="https://github.com/nathanwelch" target="_blank" rel="noopener">内特·韦尔奇</a>、<a href="https://github.com/JAMesserman" target="_blank" rel="noopener">乔·梅瑟曼</a>创建的<a href="https://eips.ethereum.org/EIPS/eip-1167" target="_blank" rel="noopener"> eip-1167 </a>提供了这种机制。根据它的<a href="https://eips.ethereum.org/EIPS/eip-1167">文档</a>，“这个标准指定了一个最小的字节码实现，它将所有调用委托给一个已知的固定地址，以一种不可变的方式简单而廉价地克隆契约功能。”</p>
<p><a href="https://github.com/optionality/clone-factory" target="_blank" rel="noopener">克隆工厂契约</a>是<a href="https://eips.ethereum.org/EIPS/eip-1167" target="_blank" rel="noopener"> eip-1167 </a>标准的参考实现。</p>
<h3 id="using-the-clone-factory-pattern">使用克隆工厂模式</h3>
<p>要实现克隆工厂契约，您必须安装克隆工厂包，如下所示:</p>
<pre>npm install @optionality.io/clone-factory
</pre>
<p>现在我们可以在我们的<code>FoundationFactory</code>上实现克隆工厂契约，如下所示</p>
<pre class="language-solidity hljs">// SPDX-License-Identifier: MIT
pragma solidity &gt;0.4.23 &lt;0.9.0;
import "./Foundation.sol";
import "@optionality.io/clone-factory/contracts/CloneFactory.sol";
import "zeppelin-solidity/contracts/ownership/Ownable.sol";


contract FoundationFactory is Ownable, CloneFactory {

  address public libraryAddress;

  event FoundationCreated(address newFoundation);

  function FoundationFactory(address _libraryAddress) public {
    libraryAddress = _libraryAddress;
  }

  function setLibraryAddress(address _libraryAddress) public onlyOwner {
    libraryAddress = _libraryAddress;
  }

  function createFoundation(string _name) public onlyOwner {
    address clone = createClone(libraryAddress);
    Foundation(clone).init(_name);
    FoundationCreated(clone);
  }
}
</pre>
<p>这里，我们从 OpenZeppelin 库导入了<code>Ownable</code>契约，以便利用它的<code>onlyOwner</code>修饰符，因为它是经过审计的，并且比我们自己编写契约更安全。</p>
<p>有了上面的代码片段，我们就有了一个契约，它会以较低的天然气成本将所有呼叫委托给契约<code>libraryAddress</code>。</p><div class="code-block code-block-54">
<hr/>
<h3>更多来自 LogRocket 的精彩文章:</h3>

<hr/></div>
<p>虽然这是一种更好的机制，但是您应该注意以下几点:</p>
<ul>
<li>确保你的主契约不会自毁，因为这会导致所有克隆体停止工作，从而冻结它们的状态和平衡</li>
<li>确保在构造函数中预初始化主协定，因为只有在主协定创建期间才会调用主协定构造函数</li>
</ul>
<h3 id="deploying-your-clone-factory-contract">部署您的克隆工厂合同</h3>
<p>现在，如果您正在使用 Truffle 进行开发，您可以通过使用以下内容创建一个新的迁移文件来部署工厂契约:</p>
<pre class="language-javascript hljs">const FoundationFactoryContract = artifacts.require("FoundationFactory");
module.exports = function(deployer) {
 deployer.deploy(FoundationFactoryContract);
}
</pre>
<p>如果你正在用 Hardhat 开发，那么<code>ethers.getContractFactory</code>方法已经覆盖了你，所以没有必要自己创建一个工厂契约。</p>
<p>您可以继续部署<code>Foundation</code>契约，如下所示:</p>
<pre class="language-javascript hljs">const hre = require("hardhat");
async function main() {
  const Foundation= await hre.ethers.getContractFactory("Foundation");
  const foundation= await NFTMarket.deploy();
  await foundation.deployed();
  console.log("Foundation contract deployed to: ", foundation.address);
}
</pre>
<h2 id="comparison-between-the-normal-factory-and-clone-factory-patterns">普通工厂和克隆工厂模式的比较</h2>
<p>为了检查<code>CloneFactory</code>和普通工厂之间的 gas 成本差异，我们将每个契约部署到一个 testnet，然后执行每个契约的<code>createFoundation</code>函数，然后在 explorer 中检查事务散列以了解使用了多少 gas。以下是执行<code>createFoundation</code>功能收取的燃气费:</p>
<p>克隆工厂<br/>汽油费:<br/>基数:12.959896517 Gwei</p>
<p>正常出厂<br/>气费:<br/>基数:25.529794514 Gwei</p>
<h2 id="conclusion">结论</h2>
<p>在本文中，我们探讨了工厂模式、它的好处、类型，以及它最适合我们的智能合约的时间。此外，我们已经确定克隆工厂模式是部署我们的 Solidity smart 契约的多个实例的正确模式，因为它的成本效率很高。</p>
<p>希望这篇文章对你有所帮助。你可以在<a href="https://twitter.com/vuemarshmello"> T </a> <a href="https://twitter.com/vuemarshmello" target="_blank" rel="noopener"> witter </a>和<a href="https://www.linkedin.com/in/emmanuel-john-83bb19192/" target="_blank" rel="noopener"> LinkedIn </a>上关注我，我会在那里分享关于 web3 和 web 开发的日常技巧。</p><div class="code-block code-block-26">
<div class="blog-plug inline-plug blockchain-plug"><h2>加入像 Bitso 和 Coinsquare 这样的组织，他们使用 LogRocket 主动监控他们的 Web3 应用</h2><p>影响用户在您的应用中激活和交易的能力的客户端问题会极大地影响您的底线。如果您对监控 UX 问题、自动显示 JavaScript 错误、跟踪缓慢的网络请求和组件加载时间感兴趣，</p><a target="_blank" href="https://lp.logrocket.com/blg/web3-signup">try LogRocket</a><p>.</p><a class="signup" href="https://lp.logrocket.com/blg/web3-signup" target="_blank" rel="noopener noreferrer"><img class="alignnone size-full wp-image-46 jetpack-lazy-image" src="../Images/dacb06c713aec161ffeaffae5bd048cd.png" alt="LogRocket Dashboard Free Trial Banner" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2019/12/cpu-memory-usage.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/12/cpu-memory-usage.png"/><noscript><img data-lazy-fallback="1" class="alignnone size-full wp-image-46" src="../Images/dacb06c713aec161ffeaffae5bd048cd.png" alt="LogRocket Dashboard Free Trial Banner" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/12/cpu-memory-usage.png"/></noscript></a><a href="https://lp.logrocket.com/blg/web3-signup" target="_blank" rel="noopener noreferrer">https://logrocket.com/signup/</a><p>LogRocket 就像是网络和移动应用的 DVR，记录你的网络应用或网站上发生的一切。您可以汇总和报告关键的前端性能指标，重放用户会话和应用程序状态，记录网络请求，并自动显示所有错误，而不是猜测问题发生的原因。</p><p>现代化您调试 web 和移动应用的方式— <a class="signup" href="https://lp.logrocket.com/blg/web3-signup" target="_blank" rel="noopener noreferrer">开始免费监控</a>。</p></div>
</div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
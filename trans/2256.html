<html>
<head>
<title>Create a React Native search bar from scratch - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>从头开始创建一个 React 原生搜索栏</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/create-react-native-search-bar-from-scratch/#0001-01-01">https://blog.logrocket.com/create-react-native-search-bar-from-scratch/#0001-01-01</a></blockquote><div><article class="article-post">
<p>试着想象一下没有机会过滤数据的今天的数字世界。不可思议，对吧？</p>
<p>搜索栏是实现这种过滤器的一个例子。如果你现在想到手机上的任何一个应用，你的脑海里应该会蹦出很多搜索栏的例子。</p>
<p>在本教程中，我们将从头开始在 React Native 中创建一个搜索栏。React Native 是一个基于 JavaScript 的框架，它使得构建跨平台(iOS 和 Android)的移动应用程序变得非常容易。</p>
<p>观看下面的视频，获得这个小项目的第一印象！正如您所看到的，示例应用程序将包含一个屏幕，其中列出了您可以应用过滤器的编程语言。</p>
<p><iframe loading="lazy" title="YouTube video player" src="https://www.youtube.com/embed/klLqbhvoV6g" frameborder="0" allowfullscreen="allowfullscreen">视频</iframe></p>
<h2>先决条件</h2>
<p>我在开发 React 本地应用程序时使用了<a href="https://docs.expo.dev" target="_blank" rel="noopener"> Expo </a>，所以您应该通过在您的机器上运行以下代码来安装 Expo 客户端:</p>
<pre class="language-bash hljs">npm install --global expo-cli</pre>
<p>如果您不使用 Expo，本教程中的所有内容应该仍然有效，除了我们稍后将使用的 Expo 矢量图标。如果你没有使用 Expo，我建议你用<a href="https://github.com/oblador/react-native-vector-icons" target="_blank" rel="noopener"> React Native Vector 图标</a>替换这些图标。</p>
<p>除了使用 Expo，我可以推荐使用 Visual Studio 代码或类似的东西。JavaScript 和 React/React Native 的一些基础知识会帮助你理解这个教程。</p>
<h2>从头开始构建 React 原生搜索栏</h2>
<p>首先，让我们深入实际代码！首先，转到您想要存储项目的目录。在这个目录中，运行<code>expo init my-project</code>来初始化 Expo 项目。你可以用任何你喜欢的名字代替<code>my-project</code>。</p>
<p>然后，使用<code>cd my-project</code>转到新创建的目录，并运行<code>expo start</code>来启动开发服务器。Expo 让你决定选择使用哪种设备；我在上面的演示和视频中使用的设备是一台 iPhone 12 Pro Max。</p>
<p>如果你想让应用程序马上运行，只需从<a href="https://github.com/kevintomas1995/logRocket_searchBar" target="_blank" rel="noopener"> GitHub repo </a>中克隆代码，并在应用程序目录中运行<code>npm install</code>。<br/>下面，我总结了终端命令:</p>
<pre class="language-bash hljs"># cd into the directory where to store your project
 $ cd dir

# initialize the expo project
$ expo init my-project

# navigate inside the newly created project
$ cd my-project

# run the development server
$ expo start
</pre>
<h3>React 本地搜索栏的项目目录</h3>
<p>为了保持清晰，我总是在我的 React 原生项目中添加一个<code>screens</code>文件夹和<code>components</code>文件夹。在这里，<code>screens</code>文件夹将只包含一个文件，因为我们只需要查看一个屏幕，搜索栏将在那里运行。</p>
<p><code>components</code>文件夹将包含任何 React 本地组件，这些组件可以外包给一个单独的文件。在这个示例应用程序中，我们在这个文件夹中有两个文件，分别叫做<code>List.js</code>和<code>SearchBar.js</code>。</p>
<p>我们首先来看一下<code>SearchBar.js</code>文件。</p>
<h2>在<code>SearchBar.js</code>中定义我们的搜索栏</h2>
<p>下面，您将在我们的<code>SearchBar.js</code>文件中找到内容。这个组件还不包含任何过滤逻辑，它只负责显示搜索栏本身。</p>
<pre class="language-javascript hljs">// SearchBar.js
import React from "react";
import { StyleSheet, TextInput, View, Keyboard, Button } from "react-native";
import { Feather, Entypo } from "@expo/vector-icons";

const SearchBar = ({clicked, searchPhrase, setSearchPhrase, setCLicked}) =&gt; {
  return (
    &lt;View style={styles.container}&gt;
      &lt;View
        style={
          clicked
            ? styles.searchBar__clicked
            : styles.searchBar__unclicked
        }
      &gt;
        {/* search Icon */}
        &lt;Feather
          name="search"
          size={20}
          color="black"
          style={{ marginLeft: 1 }}
        /&gt;
        {/* Input field */}
        &lt;TextInput
          style={styles.input}
          placeholder="Search"
          value={searchPhrase}
          onChangeText={setSearchPhrase}
          onFocus={() =&gt; {
            setClicked(true);
          }}
        /&gt;
        {/* cross Icon, depending on whether the search bar is clicked or not */}
        {clicked &amp;&amp; (
          &lt;Entypo name="cross" size={20} color="black" style={{ padding: 1 }} onPress={() =&gt; {
              setSearchPhrase("")
          }}/&gt;
        )}
      &lt;/View&gt;
      {/* cancel button, depending on whether the search bar is clicked or not */}
      {clicked &amp;&amp; (
        &lt;View&gt;
          &lt;Button
            title="Cancel"
            onPress={() =&gt; {
              Keyboard.dismiss();
              setClicked(false);
            }}
          &gt;&lt;/Button&gt;
        &lt;/View&gt;
      )}
    &lt;/View&gt;
  );
};
export default SearchBar;

// styles
const styles = StyleSheet.create({
  container: {
    margin: 15,
    justifyContent: "flex-start",
    alignItems: "center",
    flexDirection: "row",
    width: "90%",

  },
  searchBar__unclicked: {
    padding: 10,
    flexDirection: "row",
    width: "95%",
    backgroundColor: "#d9dbda",
    borderRadius: 15,
    alignItems: "center",
  },
  searchBar__clicked: {
    padding: 10,
    flexDirection: "row",
    width: "80%",
    backgroundColor: "#d9dbda",
    borderRadius: 15,
    alignItems: "center",
    justifyContent: "space-evenly",
  },
  input: {
    fontSize: 20,
    marginLeft: 10,
    width: "90%",
  },
});

</pre>
<p>正如你在第 2-4 行看到的，我们不需要导入太多来创建一个定制的搜索栏。这里最有趣的导入是<code>@expo/vector-icons</code>，我们将使用它来实现一些好看的图标。</p>
<p>从第 9 行开始，我们定义了实际的搜索栏。在随后的几行(67-83)中，您会注意到我使用了条件样式来描述搜索栏的两个“版本”:未点击的搜索栏和点击的搜索栏。</p>
<p>如果您查看以下代码片段，这将变得更加清楚:</p>
<pre class="language-javascript hljs">&lt;View
        style={
          clicked
            ? styles.searchBar__clicked
            : styles.searchBar__unclicked
        }
      &gt;</pre>
<p>如果<code>clicked</code>设置为真，则<code>styles.searchBar__clicked</code>将被应用。否则，将应用<code>styles.searchBar__unclicked</code>。</p>
<figure id="attachment_72001" aria-describedby="caption-attachment-72001" class="wp-caption aligncenter"><img data-attachment-id="72001" data-permalink="https://blog.logrocket.com/create-react-native-search-bar-from-scratch/unclicked-search-bar/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2021/10/unclicked-search-bar.png" data-orig-size="730,127" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="unclicked-search-bar" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2021/10/unclicked-search-bar-300x52.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2021/10/unclicked-search-bar.png" decoding="async" class="wp-image-72001 size-full jetpack-lazy-image" src="../Images/770d124461cb85ed4dfcf32ef43103cc.png" alt="The search bar before the user clicks into the text input field" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2021/10/unclicked-search-bar.png 730w, https://blog.logrocket.com/wp-content/uploads/2021/10/unclicked-search-bar-300x52.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2021/10/unclicked-search-bar.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2021/10/unclicked-search-bar.png"/><noscript><img data-lazy-fallback="1" data-attachment-id="72001" data-permalink="https://blog.logrocket.com/create-react-native-search-bar-from-scratch/unclicked-search-bar/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2021/10/unclicked-search-bar.png" data-orig-size="730,127" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="unclicked-search-bar" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2021/10/unclicked-search-bar-300x52.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2021/10/unclicked-search-bar.png" decoding="async" loading="lazy" class="wp-image-72001 size-full" src="../Images/770d124461cb85ed4dfcf32ef43103cc.png" alt="The search bar before the user clicks into the text input field" srcset="https://blog.logrocket.com/wp-content/uploads/2021/10/unclicked-search-bar.png 730w, https://blog.logrocket.com/wp-content/uploads/2021/10/unclicked-search-bar-300x52.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2021/10/unclicked-search-bar.png"/></noscript><figcaption id="caption-attachment-72001" class="wp-caption-text">The search bar before the user clicks into the text input field</figcaption></figure>
<figure id="attachment_71999" aria-describedby="caption-attachment-71999" class="wp-caption aligncenter"><img data-attachment-id="71999" data-permalink="https://blog.logrocket.com/create-react-native-search-bar-from-scratch/clicked-search-bar/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2021/10/clicked-search-bar.png" data-orig-size="730,162" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="clicked-search-bar" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2021/10/clicked-search-bar-300x67.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2021/10/clicked-search-bar.png" decoding="async" class="wp-image-71999 size-full jetpack-lazy-image" src="../Images/53e0d7214120ac7b7942f2abbd97fb85.png" alt="The search bar after the user clicks into the text input field" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2021/10/clicked-search-bar.png 730w, https://blog.logrocket.com/wp-content/uploads/2021/10/clicked-search-bar-300x67.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2021/10/clicked-search-bar.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2021/10/clicked-search-bar.png"/><noscript><img data-lazy-fallback="1" data-attachment-id="71999" data-permalink="https://blog.logrocket.com/create-react-native-search-bar-from-scratch/clicked-search-bar/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2021/10/clicked-search-bar.png" data-orig-size="730,162" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="clicked-search-bar" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2021/10/clicked-search-bar-300x67.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2021/10/clicked-search-bar.png" decoding="async" loading="lazy" class="wp-image-71999 size-full" src="../Images/53e0d7214120ac7b7942f2abbd97fb85.png" alt="The search bar after the user clicks into the text input field" srcset="https://blog.logrocket.com/wp-content/uploads/2021/10/clicked-search-bar.png 730w, https://blog.logrocket.com/wp-content/uploads/2021/10/clicked-search-bar-300x67.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2021/10/clicked-search-bar.png"/></noscript><figcaption id="caption-attachment-71999" class="wp-caption-text">The search bar after the user clicks into the text input field</figcaption></figure>
<p>通过<code>clicked</code>确定是否点击了该条。我们将在本教程稍后查看主屏幕时进入这种状态，所有的道具都在主屏幕上管理。</p>
<p>在包含搜索栏的<code>&lt;View&gt;</code>中，我们还可以找到搜索图标(第 17-22 行)、文本输入(第 24-32 行)和十字图标(第 35-38 行)。让我们在下一节回顾一下这些。</p>
<h2>在 React Native 中实现文本输入监听器</h2>
<p>这里的文本输入包含了一些有趣的道具。先说<code>onChangeText</code>属性。</p>
<p>有了这个特性，您可以添加一个监听器，它将在每次<code>TextInput-field</code>中的文本改变时触发。在我们的例子中，我们调用<code>setSearchPhrase</code>函数。这样，我们可以将文本输入从子组件(<code>SearchBar.js</code>)传递到父组件(<code>Home.js</code>)。</p><div class="code-block code-block-54">
<hr/>
<h3>更多来自 LogRocket 的精彩文章:</h3>

<hr/></div>
<p>这个文本输入然后通过<code>searchPhrase</code>传递给<code>TextInput</code>组件的<code>value</code>属性。该属性定义了文本输入的实际显示值，因此得名。</p>
<p>最后，我们定义了<code>onFocus</code>属性，这样当搜索栏被点击时，它会告诉应用程序该做什么。只有当<code>clicked</code>设置为<code>true</code>时，才会显示十字(第 34 行)和取消按钮(第 41 行)。</p>
<p>如果您问自己为什么我们甚至需要将这些数据传递给父组件，要知道我们不仅需要在<code>SearchBar.js</code>组件中的搜索短语和其他数据，还需要在<code>List.js</code>组件中，我们将在那里实际过滤数据。</p>
<p>下图说明了不同组件之间传递的数据的连接:</p>
<p><img data-attachment-id="94167" data-permalink="https://blog.logrocket.com/create-react-native-search-bar-from-scratch/image2-19/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2021/10/image2-e1645541334890.png" data-orig-size="730,352" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="create-react-native-search-bar-scratch" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2021/10/image2-300x145.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2021/10/image2-e1645541334890.png" decoding="async" class="aligncenter wp-image-94167 size-full jetpack-lazy-image" src="../Images/235e611b505d549893efaab39a44027e.png" alt="passing data through components" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2021/10/image2-e1645541334890.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2021/10/image2-e1645541334890.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="94167" data-permalink="https://blog.logrocket.com/create-react-native-search-bar-from-scratch/image2-19/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2021/10/image2-e1645541334890.png" data-orig-size="730,352" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="create-react-native-search-bar-scratch" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2021/10/image2-300x145.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2021/10/image2-e1645541334890.png" decoding="async" loading="lazy" class="aligncenter wp-image-94167 size-full" src="../Images/235e611b505d549893efaab39a44027e.png" alt="passing data through components" data-original-src="https://blog.logrocket.com/wp-content/uploads/2021/10/image2-e1645541334890.png"/></noscript>
<h2>过滤<code>List.js</code>中输入的文本</h2>
<p>为了呈现数据，我使用了一个名为 FlatList 的<a href="https://blog.logrocket.com/deep-dive-react-native-flatlist/" target="_blank" rel="noopener"> React 本地组件。如果您查看<code>List.js</code>的第 41-45 行，您会注意到在我们的例子中，FlatList 将<code>data</code>、<code>renderItem</code>和<code>keyExtractor</code>作为属性。</a></p>
<pre class="language-javascript hljs">// List.js
import React from "react";
import {
  StyleSheet,
  Text,
  View,
  FlatList,
  SafeAreaView,
} from "react-native";

// definition of the Item, which will be rendered in the FlatList
const Item = ({ name, details }) =&gt; (
  &lt;View style={styles.item}&gt;
    &lt;Text style={styles.title}&gt;{name}&lt;/Text&gt;
    &lt;Text style={styles.details}&gt;{details}&lt;/Text&gt;
  &lt;/View&gt;
);

// the filter
const List = (<span>{ searchPhrase, setCLicked, data }</span>) =&gt; {
  const renderItem = ({ item }) =&gt; {
    // when no input, show all
    if (searchPhrase === "") {
      return &lt;Item name={item.name} details={item.details} /&gt;;
    }
    // filter of the name
    if (item.name.toUpperCase().includes(searchPhrase.toUpperCase().trim().replace(/\s/g, ""))) {
      return &lt;Item name={item.name} details={item.details} /&gt;;
    }
    // filter of the description
    if (item.details.toUpperCase().includes(searchPhrase.toUpperCase().trim().replace(/\s/g, ""))) {
      return &lt;Item name={item.name} details={item.details} /&gt;;
    }
  };

  return (
    &lt;SafeAreaView style={styles.list__container}&gt;
      &lt;View
        onStartShouldSetResponder={() =&gt; {
          setClicked(false);
        }}
      &gt;
        &lt;FlatList
          data={data}
          renderItem={renderItem}
          keyExtractor={(item) =&gt; item.id}
        /&gt;
      &lt;/View&gt;
    &lt;/SafeAreaView&gt;
  );
};

export default List;

const styles = StyleSheet.create({
  list__container: {
    margin: 10,
    height: "85%",
    width: "100%",
  },
  item: {
    margin: 30,
    borderBottomWidth: 2,
    borderBottomColor: "lightgrey"
  },
  title: {
    fontSize: 20,
    fontWeight: "bold",
    marginBottom: 5,
    fontStyle: "italic",
  },
});
</pre>
<p>我们需要在第 11 行定义的第一件事是<code>Item</code>，它将显示编程语言的名称和细节。在另一个步骤中，从第 20 行开始，我们定义这个<code>Item</code>实际发生了什么。这是我们根据文本输入过滤编程语言列表的地方。</p>
<p>在<code>renderItem</code>函数中，我们定义了刚刚定义的项目应该如何在<code>FlatList</code>组件中呈现。在我们的例子中，我们区分了三种情况。在第一种情况下(第 22 行)，我们指的是没有输入的情况(<code>(searchPhrase === "")</code>)。这里，我们简单地呈现列表中所有可用的项目。</p>
<p>通过第 26 行的<code>(item.name.toUpperCase().includes(searchPhrase.toUpperCase().trim().replace(/\s/g, "")))</code>,我们过滤了编程语言的名称。我们将输入和名称都转换为大写，并删除所有空格。</p>
<p>在<code>renderItem</code>函数中列出了三个检查，它们是实际的过滤器。在<code>List.js</code>的第 27 行，我们检查项目名称(编程语言)是否包含文本输入(<code>searchPhrase</code>)。这将为我们的数据中的每个项目完成，如果检查结果为真，那么项目将被呈现。</p>
<p>在第 30 行，我们做了同样的事情，只是我们将它应用于编程语言的描述。</p>
<p>实现过滤逻辑的方法有很多种，所以您可以自行尝试一些东西！</p>
<p>现在，我们已经为 FlatList 准备好了<a href="https://blog.logrocket.com/how-to-use-flatlist-component-in-react/" target="_blank" rel="noopener">的一切，让我们看看我们实际上从这个<code>List</code>组件返回了什么(第 35-50 行)。在第 37 行，您将看到我将平面列表包装在一个<code>View</code>中。这是因为我想实现一个功能，确保当我们点击或点击搜索栏外的任何地方时，键盘将被关闭，<code>clicked</code>将被设置为<code>false</code>。<code>onStartShouldSetResponder={() =&gt; { setClicked(false) }}</code>实现了这一逻辑。</a></p>
<p>来自<code>FlatList</code>(第 43 行)的<code>data</code>属性中的数据将由其父组件提供。<code>renderItem</code>将从 20 号线设置到我们的<code>const renderItem</code>。对于<code>keyExtractor</code>，我们将使用相应项目的<code>id</code>。</p>
<p><code>keyExtractor</code>提取一个项目的唯一键。这对于缓存和有效地重新排序<code>FlatList</code>中的项目非常重要。</p>
<p>在下一步中，我将浏览<code>Home.js</code>组件，在那里所有的东西都聚集在一起！坚持住，你差点就成功了！</p>
<h2>在<code>Home.js</code>文件中完成我们的 React 本地搜索栏</h2>
<p>下面是我们的<code>Home.js</code>文件的样子:</p>
<pre class="language-javascript hljs">// Home.js
import React, { useState, useEffect } from "react";
import {
  StyleSheet,
  Text,
  SafeAreaView,
  ActivityIndicator,
} from "react-native";
import List from "../components/List";
import SearchBar from "../components/SearchBar";

const Home = () =&gt; {
  const [searchPhrase, setSearchPhrase] = useState("");
  const [clicked, setClicked] = useState(false);
  const [fakeData, setFakeData] = useState();

  // get data from the fake api endpoint
  useEffect(() =&gt; {
    const getData = async () =&gt; {
      const apiResponse = await fetch(
        "https://my-json-server.typicode.com/kevintomas1995/logRocket_searchBar/languages"
      );
      const data = await apiResponse.json();
      setFakeData(data);
    };
    getData();
  }, []);

  return (
    &lt;SafeAreaView style={styles.root}&gt;
      {!clicked &amp;&amp; &lt;Text style={styles.title}&gt;Programming Languages&lt;/Text&gt;}
      &lt;SearchBar
        searchPhrase={searchPhrase}
        setSearchPhrase={setSearchPhrase}
        clicked={clicked}
        setClicked={setClicked}
      /&gt;
      { : (

          &lt;List
            searchPhrase={searchPhrase}
            data={fakeData}
            setClicked={setClicked}
          /&gt;

      )}
    &lt;/SafeAreaView&gt;
  );
};

export default Home;

const styles = StyleSheet.create({
  root: {
    justifyContent: "center",
    alignItems: "center",
  },
  title: {
    width: "100%",
    marginTop: 20,
    fontSize: 25,
    fontWeight: "bold",
    marginLeft: "10%",
  },
});
</pre>
<p>首先，我们在第 9 行和第 10 行导入我们的定制组件<code>List</code>和<code>SearchBar</code>。下面，我们定义三种不同的状态，其中两种(<code>clicked</code>和<code>searchPhrase</code>)你应该很熟悉。第三个<code>fakeData</code>，将是第 18 行<code>useEffect</code>挂钩中使用的<a href="https://blog.logrocket.com/guide-to-react-useeffect-hook/" target="_blank" rel="noopener">。</a></p>
<p>为了让这个例子尽可能真实，我模拟了从一个 API 端点获取数据。在<code>useEffect</code>钩子内部，我们定义了一个名为<code>getData</code>的异步函数，在这里我们从<a href="https://my-json-server.typicode.com" target="_blank" rel="noopener">假 API </a>获取数据，并将数据存储在名为<code>fakeData</code>的常量中。定义函数后，我们立即在第 26 行调用它。我没有在第 27 行定义任何依赖关系，所以这个钩子只有在组件被渲染后才会被执行。</p>
<p>标题“编程语言”用<code>{!clicked &amp;&amp; &lt;Text style={styles.title}&gt;Programming Languages&lt;/Text&gt;}</code>实现，并将根据<code>clicked</code>的值有条件地呈现。这意味着只有当<code>searchBar</code>不是<code>clicked</code>时，文本“编程语言”才会被渲染。</p>
<p>下一步，我们用道具<code>searchPhrase</code>、<code>setSearchPhrase</code>、<code>clicked</code>和<code>setClicked</code>来呈现我们的<code>SearchBar</code>组件。</p>
<p>获取数据可能需要几秒钟的时间，所以我们需要在这段时间内进行渲染。在这种情况下，让我们渲染一个加载微调器。因此，只要<code>fakeData</code>未定义，我们将使用<code>!fakeData ? (&lt;ActivityIndicator</code> <code>size="large" /&gt;)</code>渲染加载微调器，否则将渲染<code>List</code>组件。</p>
<p>差不多就是这样了！最后，您只需要像这样将这个<code>Home.js</code>文件导入到您的<code>App.js</code>文件中:</p>
<pre class="language-javascript hljs">import React from 'react';
import { StyleSheet, Text, View } from 'react-native';
import Home from './screens/Home';

export default function App() {
  return (
    &lt;View style={styles.root}&gt;
      &lt;Home /&gt;
    &lt;/View&gt;
  );
}
</pre>
<h2>结论</h2>
<p>在这篇文章中，我们回顾了如何创建自己的自定义 React 原生搜索栏，而无需安装任何外部库！数据是从一个假的 API 端点获取的，并用一个 FlatList 组件显示。此外，我们还讨论了如何实现条件样式。</p>
<p>请随意使用这段代码作为进一步开发的基础。例如，您可以在服务器端实现数据过滤，而不是像我们在这里所做的那样在客户端实现。这个项目的<a href="https://github.com/kevintomas1995/logRocket_searchBar" target="_blank" rel="noopener">源代码可以在我的 GitHub 上找到。</a></p><div class="code-block code-block-18">
<div class="blog-plug inline-plug react-native-plug"><h2><a href="https://lp.logrocket.com/blg/react-native-signup"> LogRocket </a>:即时重现 React 原生应用中的问题。</h2><a class="signup" href="https://lp.logrocket.com/blg/react-native-signup" target="_blank" rel="noopener noreferrer"><img class="alignnone size-full wp-image-46 jetpack-lazy-image" src="../Images/110055665562c1e02069b3698e6cc671.png" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2021/10/react-native-plug_v2-2.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2021/10/react-native-plug_v2-2.png"/><noscript><img data-lazy-fallback="1" class="alignnone size-full wp-image-46" src="../Images/110055665562c1e02069b3698e6cc671.png" data-original-src="https://blog.logrocket.com/wp-content/uploads/2021/10/react-native-plug_v2-2.png"/></noscript></a><p><a href="https://lp.logrocket.com/blg/react-native-signup" target="_blank" rel="noopener noreferrer"> LogRocket </a>是一款 React 原生监控解决方案，可帮助您即时重现问题、确定 bug 的优先级并了解 React 原生应用的性能。</p><p>LogRocket 还可以向你展示用户是如何与你的应用程序互动的，从而帮助你提高转化率和产品使用率。LogRocket 的产品分析功能揭示了用户不完成特定流程或不采用新功能的原因。</p><p>开始主动监控您的 React 原生应用— <a class="signup" href="https://lp.logrocket.com/blg/react-native-signup" target="_blank" rel="noopener noreferrer">免费试用 LogRocket】。</a></p></div>
</div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
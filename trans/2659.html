<html>
<head>
<title>A definitive guide to Vue 3 components - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>Vue 3 组件的权威指南</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/definitive-guide-vue-3-components/#0001-01-01">https://blog.logrocket.com/definitive-guide-vue-3-components/#0001-01-01</a></blockquote><div><article class="article-post">
<p>Vue web 应用程序中的组件非常重要，因为它们可以用非常简单的方式来制作非常复杂的应用程序。在本文中，我们将介绍 Vue 3 组件的基础知识以及如何使用它们。</p>
<p><em>向前跳转:</em></p>

<h2 id="what-are-components-in-vue-3">Vue 3 中有哪些组件？</h2>
<p>组件是构建功能性 web 应用程序的可重用 UI 代码片段。它们既可以用作复杂应用程序的构建块，也可以用作可重用的部分，以防止重复重写类似的代码。</p>
<p>Vue 应用程序通常由一个根组件和任意数量的其他组件组成。所有组件实际上都是组件对象，包含状态变量、组件逻辑和指定组件呈现的模板。</p>
<h2 id="creating-a-component-in-vue-3">在 Vue 3 中创建组件</h2>
<p>在我们开始创建组件之前，我们必须首先设置我们的项目。我们可以创建两种类型的 Vue 3 项目:</p>
<ul>
<li>CDN，它与 HTML 页面集成在一起</li>
<li>CLI，它是使用 Node.js 开发和构建的</li>
</ul>
<h3 id="cdn-project">CDN </h3>
<p>CDN 项目是最简单的 Vue 3 项目。</p>
<p>为了建立一个空的 CDN 项目，我们首先将 CDN 导入到我们的 HTML 页面中:</p>
<pre class="language-html hljs">&lt;script src="https://cdnjs.cloudflare.com/ajax/libs/vue/3.2.37/vue.global.min.js"&gt;&lt;/script&gt;
</pre>
<p>接下来，我们创建一个<code>div</code>元素来呈现 Vue 应用程序:</p>
<pre class="language-html hljs">&lt;div id="app"&gt;&lt;/div&gt;
</pre>
<p>然后，我们在<code>body</code>标签的底部创建一个空的<code>script</code>标签:</p>
<pre class="language-html hljs">&lt;script&gt;

&lt;/script&gt;
</pre>
<p>最后，我们在新的<code>script</code>标签中创建和挂载一个空应用程序:</p>
<pre class="language-html hljs">Vue.createApp({}).mount("#app");
</pre>
<p>完成上述步骤后，HTML 代码应该如下所示:</p>
<pre class="language-html hljs">&lt;script src="https://unpkg.com/<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="631516062350">[email protected]</a>"&gt;&lt;/script&gt;

&lt;div id="app"&gt;&lt;/div&gt;

&lt;script&gt;
  Vue.createApp({}).mount("#app");
&lt;/script&gt;
</pre>
<h3 id="command-line-interface-project">命令行界面项目</h3>
<p>设置 CLI 项目比创建 CDN 项目更复杂。首先安装以下组件:</p>

<p>接下来，使用以下任意命令安装<a href="https://cli.vuejs.org" target="_blank" rel="noopener"> Vue CLI </a>:</p>
<pre class="language-bash hljs"># for npm
npm install -g @vue/cli

# for yarn 1.x
yarn global add @vue/cli
</pre>
<p>现在，创建一个项目<code>vue-tutorial</code>，像这样:</p>
<pre class="language-html hljs">vue create vue-tutorial
</pre>
<p>然后，选择<code>Vue 3</code>:</p>
<p><img decoding="async" src="../Images/a3f96b418ae58d5c3587ec07264c01ad.png" alt="" data-lazy-src="https://paper-attachments.dropbox.com/s_6C3673131284E446B08CEAA9C64F0AFCD5BF70C7B18A985263F8D14EFE0032FF_1654686811103_Screenshot+from+2022-06-08+12-08-16.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" class=" jetpack-lazy-image" data-original-src="https://paper-attachments.dropbox.com/s_6C3673131284E446B08CEAA9C64F0AFCD5BF70C7B18A985263F8D14EFE0032FF_1654686811103_Screenshot+from+2022-06-08+12-08-16.png"/></p><noscript><img data-lazy-fallback="1" decoding="async" src="../Images/a3f96b418ae58d5c3587ec07264c01ad.png" alt="" data-original-src="https://paper-attachments.dropbox.com/s_6C3673131284E446B08CEAA9C64F0AFCD5BF70C7B18A985263F8D14EFE0032FF_1654686811103_Screenshot+from+2022-06-08+12-08-16.png"/></noscript>
<p><em> <strong>注意，</strong>如果你使用的是<a href="https://yarnpkg.com/getting-started/migration#step-by-step" target="_blank" rel="noopener"> Yarn v2 或更高版本</a>，你必须使用<code>*yarn dlx @vue/cli create vue-tutorial*</code>来创建项目；Yarn v2+不支持全局安装</em></p>
<p>Vue CLI 创建项目后，其树结构应该如下所示:</p>
<pre class="language-html hljs">.
├── babel.config.js
├── jsconfig.json
├── package.json
├── package-lock.json
├── public
│   ├── favicon.ico
│   └── index.html
├── README.md
├── src
│   ├── App.vueThe v
│   ├── assets
│   │   └── logo.png
│   ├── components
│   │   └── HelloWorld.vue
│   └── main.js
└── vue.config.js
</pre>
<p>一个 Vue 3 项目的根是<code>src/main.js</code>:</p>
<pre class="language-html hljs">import { createApp } from 'vue'
import App from './App.vue'

createApp(App).mount('#app')
</pre>
<p>在上面的代码中，<code>vue</code>中的<code>createApp</code>函数创建了一个应用程序实例，并将其挂载到一个 ID 为<code>app</code>的 HTML 元素中。<code>createApp</code>接受一个组件作为参数，在本例中来自<code>./App.vue</code>文件。</p>
<h3 id="vue-3-createapp">视图 3 <code>createApp</code></h3>
<p>Vue 3 提供了一个用于创建应用实例的<code>createApp</code>函数。该函数将组件作为参数，使其成为实例的根。</p>
<p>应用程序实例提供了一个<code>mount</code>方法，该方法将实例装载到一个 HTML 元素中。</p>
<pre class="language-html hljs">import { createApp } from "vue";
import App from "./App.vue";

createApp(App).mount('#app');  // the element has an id "app"
</pre>
<p><code>createApp</code>功能只存在于 Vue 3 中。Vue 2 提供了一个<code>Vue</code>构造函数来创建应用程序实例。</p>
<pre class="language-html hljs">import Vue from 'vue'
import App from './App.vue' 

new Vue({
  render: h =&gt; h(App),
}).$mount('#app')
</pre>
<p><code>Vue</code>构造函数接受一个应该包含一个<code>render</code>方法的对象来呈现根组件。构造的实例有一个<code>$mount</code>方法，允许我们将实例挂载到 HTML 元素。<code>$mount</code>方法也使用 CSS 选择器来引用元素。</p>
<p>Vue 允许我们在 v2 和 v3 中创建<a href="https://012.vuejs.org/guide/custom-directive.html" target="_blank" rel="noopener">指令</a>。指令使我们能够向 Vue 应用程序实例添加功能。为了在 Vue 2 中创建指令，我们需要使用<code>Vue</code>对象。</p>
<p>所有应用程序实例都可以使用使用<code>Vue</code>对象创建的任何指令。当我们的 web 应用程序使用多个 Vue 应用程序实例，但我们希望将某些功能限制到特定实例时，这就成了一个问题。</p>
<pre class="language-html hljs">// The only way to create a directive in Vue 2
Vue.directive('directive', {
    // ...
});

// Both of the application instances can access the directive
const appOne = new Vue(App1).mount('#app1');
const appTwo = new Vue(App2).mount('#app2');
</pre>
<p>Vue 3 <code>createApp</code>函数通过提供用于定制实例的<a href="https://v3-migration.vuejs.org/breaking-changes/global-api.html#a-new-global-api-createapp" target="_blank" rel="noopener">实例 API 来解决这个问题。API 方法之一<code>directive</code>为实例创建定制指令:</a></p>
<pre class="language-html hljs">// Both of the application instances can access the directive
const appOne = Vue.createApp(App1);
appOne.directive('directive', {
    // only availalble "appOne" instance */
});
appOne.mount('#app1');

const appTwo = Vue.createApp(App2);
appTwo.directive('directive', {
    // only availalble to "appTwo"
});
appTwo.mount('#app2');
</pre>
<h2 id="creating-a-root-component">创建根组件</h2>
<p>所有 Vue web 应用程序都从根组件开始。<code>createApp</code>函数将这个组件绑定到一个 HTML 元素。</p>
<p>为了创建一个根组件，我们从一个空对象开始，按照惯例将其命名为<code>RootComponent</code>。为了将对象注册为根，我们将它传递给<code>Vue.createApp()</code>函数:</p>
<pre class="language-html hljs">&lt;script&gt;
    const RootComponent = {};
    const app = Vue.createApp(RootComponent);
    app.mount("#app");
&lt;/script&gt;
</pre>
<p>在 Vue CLI 中，根组件就像任何其他组件一样，位于<code>src/App.vue</code>。</p>
<h2 id="creating-a-simple-component">创建简单的组件</h2>
<p>为了在 Vue 中创建一个组件，我们从一个空的对象开始，就像根组件一样。但是，我们没有将它传递给<code>Vue.createApp()</code>函数，而是将它注册到我们想要使用它的组件中。</p>
<p>为了在根组件中注册一个新组件，我们在对象中创建一个<code>components</code>属性。下面是在根中注册一个<code>CustomButton</code>组件的例子:</p>
<pre class="language-html hljs">&lt;script&gt;
    const CustomButton = {};
    const RootComponent = {
        components: {
            CustomButton,
        },
    };
    const app = Vue.createApp(RootComponent);
    app.mount("#app");
&lt;/script&gt;
</pre>
<p>组件需要一个呈现给视图的模板。模板通常在带有<code>vue-template</code>的<code>type</code>的<code>script</code>标签中，以防止浏览器将其作为 JavaScript 代码执行。</p>
<p>模板应该有一个 ID，它允许组件对象引用它的脚本。这里有一个简单的<code>CustomButton</code>组件模板脚本。在这个例子中，模板脚本 ID 是<code>"``custom-button``"</code>:</p>
<pre class="language-html hljs">&lt;script type="vue-template" id="custom-button"&gt;
    &lt;button&gt;Click Me!&lt;/button&gt;
&lt;/script&gt;
</pre>
<p>为了将模板绑定到组件，我们向组件对象添加了一个<code>template</code>属性，并将引用传递给脚本:</p>
<pre class="language-html hljs">&lt;script&gt;
    const CustomButton = {
        template: "#custom-button"
    };
...
&lt;/script&gt;
</pre>
<p>现在，我们可以在根组件中使用<code>CustomButton</code>组件:</p>
<pre class="language-html hljs">&lt;div id="app"&gt;
    &lt;CustomButton /&gt;
&lt;/div&gt;
</pre>
<p>在 CLI 版本中，组件具有不同的结构。每个组件都在一个<code>.vue</code>文件中。所有组件必须包括一个<code>template</code>标签和一个<code>script</code>。还可以添加一个<code>style</code>标签来设置模板的样式。</p>
<p>下面是一个使用 Vue CLI 创建的简单 Vue 组件的示例:</p>
<pre class="language-html hljs">&gt;&lt;template&gt;
  Hello, World!
&lt;/template&gt;

&lt;script&gt;
  export default {}
&lt;/script&gt;
</pre>
<p><code>export default</code>之后的对象就像 CDN 版本中的组件对象一样。由 CLI 和 CDN 创建的简单组件之间的唯一区别如下:</p>
<ul>
<li>对于 CDN 版本，不需要为对象指定模板脚本</li>
<li>使用 CDN 版本，我们可以将组件分离到不同的文件中</li>
</ul>
<p>要在另一个组件中使用一个组件，请按照下列步骤操作:</p>
<ol>
<li>   <ol>
<li>将<code>.vue</code>文件导入组件脚本标签</li>
<li>将默认导出添加到<code>component</code>属性</li>
</ol>
</li>
</ol>
<pre class="language-html hljs">import HelloWorld from './components/HelloWorld.vue'export default {
components: {
HelloWorld
}
}</pre>
<h2 id="adding-state-to-vue3-components">向 Vue 3 组件添加状态</h2>
<p>要向 Vue 组件添加状态变量，在组件对象中创建一个<code>data</code>方法。<code>data</code>方法应该返回一个包含状态变量的对象。</p>
<p>在下面的例子中，<code>CustomButton</code>组件包含一个<code>buttonText</code>状态，它有一个字符串值:<code>"``Click me!``"</code>:</p>
<pre class="language-html hljs">&lt;script&gt;
    const CustomButton = {
        template: "#custom-button",
        data: function () {
            return {
                'buttonText': "Click me!"
            }
        }
    }
    // some lines are hidden
&lt;/script&gt;
</pre>
<p>我们在模板脚本的<code>button</code>标签中使用状态变量，用双花括号<code>{{ }}</code>将它括起来，就像这样:</p>
<pre class="language-html hljs">&lt;script type="vue-template" id="custom-button"&gt;
    &lt;button&gt;{{ buttonText }}&lt;/button&gt;
&lt;/script&gt;
</pre>
<h2 id="handling-vue-3-component-props">处理 Vue 3 组件道具</h2>
<p>Vue 中的 Props 是传递给组件的属性，就像 HTML 元素一样。它们提高了组件的灵活性和可重用性，这使得在略有不同的场景中使用相同的代码成为可能，从而使 UI 更加高效。</p>
<p>我们向组件传递属性的方式与向 HTML 元素传递属性的方式相同:</p>
<pre class="language-html hljs">&lt;component prop="value"&gt;&lt;/component&gt;
</pre>
<p>然后，我们可以通过添加包含按钮文本的<code>text</code>属性来更新<code>custom-button</code>组件:</p>
<pre class="language-html hljs">&lt;div id="app"&gt;
    {{ greeting }}, {{ name }}
    &lt;CustomButton text="Click me!"&gt;&lt;/CustomButton&gt;
&lt;/div&gt;
</pre>
<p>为了让<code>text</code>道具工作，我们将它注册到<code>CustomButton</code>组件:</p>
<pre class="language-html hljs">&lt;script&gt;
    const CustomButton = {
        template: "#custom-button",
        data: function () {
            return {
                'buttonText': "Click me!"
            }
        },
&gt;       props: ['text']
    }

    // some lines are hidden
&lt;/script&gt;
</pre>
<p>然后，我们用模板中的<code>{{ text }}</code>替换<code>{{ buttonText }}</code>:</p>
<pre class="language-html hljs">&lt;script type="vue-template" id="custom-button"&gt;
    &lt;button&gt;{{ text }}&lt;/button&gt;
&lt;/script&gt;
</pre>
<p>接下来，我们移除<code>buttonText</code>状态变量，因为不再需要它了:</p>
<pre class="language-html hljs">&lt;script&gt;
    const CustomButton = {
        template: "#custom-button",
        props: ['text'],
    }

    // some lines are hidden
&lt;/script&gt;
</pre>
<h2 id="handling-multiple-component-props">处理多个组件道具</h2>
<p>在一个 Vue 组件中可以使用多个道具。一个组件拥有的道具越多，它就变得越灵活和可用。要向组件添加更多属性，请将属性的名称追加到组件的属性数组中:</p>
<pre class="language-html hljs">&lt;script&gt;
    const CustomButton = {
        template: "#custom-button",
&gt;       props: ['text', 'label'],
    }

    // some lines are hidden
&lt;/script&gt;
</pre>
<p>但是，在给 Vue 组件添加更多道具时要小心。过多的道具会使 Vue 组件变得不必要的复杂和难以维护。</p>
<p>现在，<code>CustomButton</code>组件有两个道具:<code>text</code>和<code>label</code>。</p>
<p>添加了<code>label</code>道具后，我们修改了模板以使用这个道具:</p>
<pre class="language-html hljs">&lt;script type="vue-template" id="custom-button"&gt;
    {{ label }}: &lt;button&gt;{{ text }}&lt;/button&gt;
&lt;/script&gt;
</pre>
<p>使用多个 props 和使用 Vue CLI 创建的组件的工作方式相同。</p>
<h2 id="nested-components">嵌套组件</h2>
<p>Vue 3 允许我们在其他组件中嵌套组件。这种嵌套导致了<a href="https://blog.logrocket.com/build-better-higher-order-components-with-vue-3/" target="_blank" rel="noopener">组合</a>，其中一个大的或复杂的组件由更小的组件组成。组合有助于提高用户界面的效率和维护性。</p>
<p>这里有一个简单的嵌套组件的例子。<code>StartStopButton</code>包含两个<code>CustomButton</code>组件:</p>
<pre class="language-html hljs">&lt;script type='vue-template' id="start-stop-button"&gt;
  
</pre>
<p/>
<p/>
<p>现在，我们可以将<code>StartStopButton</code>组件添加到根组件中:</p>
<p id="app">{{问候语}}，{{姓名}}</p>
<p>使用<code>defineComponent</code>和打字稿</p>
<pre class="language-html hljs">&lt;script&gt;
    // ...
    const RootComponent = {
        data: function () {
            return {
                greeting: "Hello",
                name: "John",
            }
        },
        components: {
            StartStopButton
        },
    };

    // ...
&lt;/script&gt;
</pre>
<h2 id="using-definecomponent-and-typescript">Vue 2 和 Vue 3 都允许我们<a href="https://blog.logrocket.com/vue-typescript-tutorial-examples/" target="_blank" rel="noopener">使用 TypeScript </a>构建 Vue 应用程序。TypeScript 语言是 JavaScript 的强大超集，提供可选的静态类型并支持更多的 ide。</h2>
<p>与 Vue 3 相比，Vue 2 中的 TypeScript 支持真的很差<a href="https://blog.logrocket.com/new-features-in-vue-3-and-how-to-use-them-2/#bettertypescriptsupport" target="_blank" rel="noopener">。要用 TypeScript 在 Vue 2 中创建组件，我们需要使用标准语法或类组件。每种方法都有利弊；让我们来看看。</a></p>
<p>在本例中，我们使用标准语法在 Vue 2 中用 TypeScript 创建了一个组件:</p>
<p>在上面的代码中，我们可以看到用标准语法创建的组件类似于一个组件对象，但是缺少对类似于<a href="https://vuex.vuejs.org/" target="_blank" rel="noopener"> Vuex </a>的特性的支持。</p>
<pre class="language-html hljs">&lt;template&gt;
  &lt;div&gt;
    {{ name }}: {{ msg }}
  &lt;/div&gt;
&lt;/template&gt;

&lt;script lang="ts"&gt;
  import Vue from "vue";
  export default Vue.extend({
    name: "HelloVue",
    props: {
      msg: String
    },
    data () {
      return {
        name: "LogRocket"
      }
    }
  })
&lt;/script&gt;
</pre>
<p>在这个例子中，我们使用一个类组件在 Vue 2 中用 TypeScript 创建一个组件:</p>
<p>在上面的代码中，我们可以看到用类组件创建的组件与组件对象有很大的不同，尽管它支持额外的特性。</p>
<pre class="language-html hljs">&lt;template&gt;
  &lt;div&gt;
    {{ name}}: {{ msg }}
  &lt;/div&gt;
&lt;/template&gt;

&lt;script lang="ts"&gt;
  import { Component, Prop, Vue } from "vue-property-decorator";
  @Component
  export default class HelloVue extends Vue {
    @Prop() public msg!: string;
    public name: string = "LogRocket";
  }
&lt;/script&gt;
</pre>
<p>Vue 3 通过提供一个<code>defineComponent</code>函数解决了这些缺点。这个函数允许我们创建一个类似于组件对象的 TypeScript 组件，并且还支持额外的特性。</p>
<p>结论</p>
<pre class="language-html hljs">&lt;template&gt;
  &lt;div&gt;
    {{ name }}: {{ msg }}
  &lt;/div&gt;
&lt;/template&gt;

&lt;script lang="ts"&gt;
  import { defineComponent } from "vue";
  export default defineComponent({
    props: {
      msg: {
        type: String,
        required: true
      }
    },
    data() {
      return {
        name: "LogRocket",
      }
    }
  });
&lt;/script&gt;  
</pre>
<h2 id="conclusion">我希望这篇文章能帮助你理解在 Vue 3 中创建组件并使用它们构建复杂应用程序的过程。但是，如果你仍然不明白其中的任何部分，或者不能理解，请在评论中告诉我。</h2>
<p>感谢您的阅读，祝您愉快！</p>
<p>像用户一样体验您的 Vue 应用</p><div class="code-block code-block-20">
<div class="blog-plug inline-plug vue-inline"><h2>调试 Vue.js 应用程序可能会很困难，尤其是当用户会话期间有几十个(如果不是几百个)突变时。如果您对监视和跟踪生产中所有用户的 Vue 突变感兴趣，</h2><p>. </p><a href="https://lp.logrocket.com/blg/vue-signup" target="_blank">try LogRocket</a><p>LogRocket 就像是网络和移动应用程序的 DVR，记录你的 Vue 应用程序中发生的一切，包括网络请求、JavaScript 错误、性能问题等等。您可以汇总并报告问题发生时应用程序的状态，而不是猜测问题发生的原因。</p><a class="signup" href="https://lp.logrocket.com/blg/vue-signup" target="_blank" rel="noopener noreferrer"><img class="alignnone size-full wp-image-46 jetpack-lazy-image" src="../Images/0d269845910c723dd7df26adab9289cb.png" alt="LogRocket Dashboard Free Trial Banner" data-lazy-src="https://files.readme.io/00591d0-687474703a2f2f692e696d6775722e636f6d2f6a3049327856572e706e67.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://files.readme.io/00591d0-687474703a2f2f692e696d6775722e636f6d2f6a3049327856572e706e67.png"/><noscript><img data-lazy-fallback="1" class="alignnone size-full wp-image-46" src="../Images/0d269845910c723dd7df26adab9289cb.png" alt="LogRocket Dashboard Free Trial Banner" data-original-src="https://files.readme.io/00591d0-687474703a2f2f692e696d6775722e636f6d2f6a3049327856572e706e67.png"/></noscript></a><a href="https://lp.logrocket.com/blg/vue-signup" target="_blank" rel="noopener noreferrer">https://logrocket.com/signup/</a><p>LogRocket Vuex 插件将 Vuex 突变记录到 LogRocket 控制台，为您提供导致错误的环境，以及出现问题时应用程序的状态。</p><p>现代化您调试 Vue 应用的方式- <a class="signup" href="https://lp.logrocket.com/blg/vue-signup" target="_blank" rel="noopener noreferrer">开始免费监控</a>。</p><p>Modernize how you debug your Vue apps - <a class="signup" href="https://lp.logrocket.com/blg/vue-signup" target="_blank" rel="noopener noreferrer">Start monitoring for free</a>.</p></div>


</div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
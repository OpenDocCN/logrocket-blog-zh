<html>
<head>
<title>Optimizing performance in a React app - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>在 React app - LogRocket 博客中优化性能</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/optimizing-performance-react-app/#0001-01-01">https://blog.logrocket.com/optimizing-performance-react-app/#0001-01-01</a></blockquote><div><article class="article-post">
<p><em> <strong>编者按:</strong>这份优化 React 应用性能的指南最近一次更新是在 2023 年 2 月 9 日，为您的 React 应用提供了更多优化技术。此更新还包括反映 React 更改的更新。要了解更多关于 React 的信息，请访问我们的<a href="https://blog.logrocket.com/tag/react/">档案，这里是</a>。</em></p>
<p>优化应用程序的性能对于那些注重保持<a href="https://blog.logrocket.com/ux-design/designing-ux-user-flow-app/">用户体验积极</a>的开发人员来说至关重要，这样才能让他们继续使用应用程序并参与其中。根据<a href="https://www.portent.com/blog/analytics/research-site-speed-hurting-everyones-revenue.htm#:~:text=The%20first%205%20seconds%20of,(between%20seconds%200%2D5)">网站</a>的研究，一秒钟加载的网站的<a href="https://blog.logrocket.com/product-management/what-is-conversion-rate-how-to-calculate/">转换率</a>是十秒钟加载的网站的五倍。众所周知，开发人员必须创建性能优化的应用。</p>
<p>在 React 应用程序中，默认情况下我们保证会有一个非常快的 UI。然而，随着应用程序的增长，开发人员可能会遇到性能问题。在本指南中，我们将讨论优化 React 应用程序性能的一些重要方法，包括预优化技术。</p>
<p><em>向前跳转:</em></p>

<h2 id="react-update-ui">了解 React 如何更新其 UI</h2>
<p>在优化 React 应用程序之前，我们必须了解 React 如何更新其 UI，以及如何衡量应用程序的性能。这使得解决任何 React 性能问题变得容易。让我们首先回顾一下 React UI 是如何更新的。</p>
<p>当我们创建一个渲染组件时，React 为组件中的元素树创建一个虚拟 DOM。现在，只要组件的状态发生变化，React 就会重新创建虚拟 DOM 树，并将结果与之前的渲染进行比较。它只会通过 diffing 更新实际 DOM 中已更改的元素。</p>
<h3 id="diffing-re-rendering">检查差异和重新渲染</h3>
<p>React 使用虚拟 DOM 的概念来最小化重新呈现网页的性能成本，因为实际的 DOM 操作起来非常昂贵。这很棒，因为它加快了 UI 渲染时间。然而，如果管理不善，这个概念会降低复杂应用程序的速度。在这里，我们可以推断出 React 组件中的状态更改会导致重新呈现。同样，当状态作为道具传递给子组件时，它会重新呈现子组件，这没问题，因为 React 必须更新 UI。</p>
<p>当子组件不受状态更改的影响时，问题就出现了。换句话说，它们不从父组件接收任何道具。尽管如此，React 会重新呈现这些子组件。因此，只要父组件重新渲染，它的所有子组件都会重新渲染，不管是否有道具传递给它们。这是 React 的<a href="https://blog.logrocket.com/complete-guide-react-default-props/">默认行为。</a></p>
<p>让我们快速演示一下这个概念。这里，我们有一个包含一个<code>state</code>和一个<code>child</code>组件的<code>App</code>组件:</p>
<pre class="language-javascript hljs">import { useState } from "react";

export default function App() {
  const [input, setInput] = useState("");

  return (
    &lt;div&gt;
      &lt;input
        type="text"
        value={input}
        onChange={(e) =&gt; setInput(e.target.value)}
      /&gt;
      &lt;h3&gt;Input text: {input}&lt;/h3&gt;
      &lt;ChildComponent /&gt;
    &lt;/div&gt;
  );
}

function ChildComponent() {
  console.log("child component is rendering");
  return &lt;div&gt;This is child component.&lt;/div&gt;;
};
</pre>
<p>每当<code>App</code>组件的状态更新时，<code>ChildComponent</code>就会重新渲染，即使它没有受到状态变化的直接影响。在这个 CodeSandbox 演示的输入字段中，您会看到对于每一次击键，<code>ChildComponent</code>都会重新呈现:</p>
<p/>
<p>在大多数情况下，这种重新渲染不会导致性能问题，我们也不会注意到应用程序中的任何延迟。然而，如果未受影响的组件呈现了昂贵的计算，并且我们注意到了性能问题，那么我们应该优化我们的 React 应用程序。这就把我们带到了第二种预优化技术——概要分析。</p>
<h3 id="profiling-react-app">剖析 React 应用程序以定位瓶颈</h3>
<p>React 允许我们使用 React 开发工具中的<a href="https://blog.logrocket.com/debug-react-apps-react-devtools/">分析器来测量应用的性能。在那里，我们可以在应用程序渲染时收集性能信息。分析器记录组件渲染所需的时间、组件渲染的原因等等。从那里，我们可以调查受影响的组件，并提供必要的优化。</a></p>
<p>要使用 profiler，请为您选择的浏览器安装 React DevTools。如果你还没有安装，去他们的扩展页面安装它(在这里选择<a href="https://chrome.google.com/webstore/detail/react-developer-tools/fmkadmapgofadopljbjfkapdkoienihi"> Chrome </a>或<a href="https://addons.mozilla.org/en-US/firefox/addon/react-devtools/">Firefox</a>)。现在，在处理 React 项目时，我们应该会看到 profiler 选项卡。回到我们的代码。如果我们分析应用程序，我们会看到以下行为:</p>
<p><img data-attachment-id="160819" data-permalink="https://blog.logrocket.com/optimizing-performance-react-app/attachment/profiler-react-dev-tools/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2021/09/profiler-react-dev-tools.gif" data-orig-size="730,339" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Showing profiler dev tools to optimize React app" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2021/09/profiler-react-dev-tools-300x139.gif" data-large-file="https://blog.logrocket.com/wp-content/uploads/2021/09/profiler-react-dev-tools.gif" decoding="async" class="aligncenter size-full wp-image-160819 jetpack-lazy-image" src="../Images/aae05e92863b158f5145e7e6e50a6a10.png" alt="Showing Profiler Dev Tools to Optimize React App" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2021/09/profiler-react-dev-tools.gif?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2021/09/profiler-react-dev-tools.gif"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="160819" data-permalink="https://blog.logrocket.com/optimizing-performance-react-app/attachment/profiler-react-dev-tools/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2021/09/profiler-react-dev-tools.gif" data-orig-size="730,339" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Showing profiler dev tools to optimize React app" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2021/09/profiler-react-dev-tools-300x139.gif" data-large-file="https://blog.logrocket.com/wp-content/uploads/2021/09/profiler-react-dev-tools.gif" decoding="async" loading="lazy" class="aligncenter size-full wp-image-160819" src="../Images/aae05e92863b158f5145e7e6e50a6a10.png" alt="Showing Profiler Dev Tools to Optimize React App" data-original-src="https://blog.logrocket.com/wp-content/uploads/2021/09/profiler-react-dev-tools.gif"/></noscript>
<p>当输入文本字段更新时，React DevTools profiler 突出显示每个呈现的组件，并且我们从呈现的组件接收每个细节。在下面的火焰图中，我们可以看到渲染组件花了多长时间，以及为什么<code>App</code>组件正在渲染:</p>
<p><img data-attachment-id="160821" data-permalink="https://blog.logrocket.com/optimizing-performance-react-app/attachment/rendered-components-react/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2021/09/rendered-components-react.png" data-orig-size="730,216" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Receiving details from rendered components, shows why React app renders" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2021/09/rendered-components-react-300x89.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2021/09/rendered-components-react.png" decoding="async" class="aligncenter size-full wp-image-160821 jetpack-lazy-image" src="../Images/90e9f35d18d51d931c34bfce43288bc3.png" alt="Receiving Details From Rendered Components, Shows Why React App Renders" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2021/09/rendered-components-react.png 730w, https://blog.logrocket.com/wp-content/uploads/2021/09/rendered-components-react-300x89.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2021/09/rendered-components-react.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2021/09/rendered-components-react.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="160821" data-permalink="https://blog.logrocket.com/optimizing-performance-react-app/attachment/rendered-components-react/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2021/09/rendered-components-react.png" data-orig-size="730,216" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Receiving details from rendered components, shows why React app renders" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2021/09/rendered-components-react-300x89.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2021/09/rendered-components-react.png" decoding="async" loading="lazy" class="aligncenter size-full wp-image-160821" src="../Images/90e9f35d18d51d931c34bfce43288bc3.png" alt="Receiving Details From Rendered Components, Shows Why React App Renders" srcset="https://blog.logrocket.com/wp-content/uploads/2021/09/rendered-components-react.png 730w, https://blog.logrocket.com/wp-content/uploads/2021/09/rendered-components-react-300x89.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2021/09/rendered-components-react.png"/></noscript>
<p>同样，下图显示了<code>child</code>组件正在渲染，因为<code>parent</code>组件已经渲染:</p>
<p><img data-attachment-id="160823" data-permalink="https://blog.logrocket.com/optimizing-performance-react-app/attachment/react-child-component-rendering/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2021/09/react-child-component-rendering.png" data-orig-size="730,210" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Shows child component rendering because parent component rendering" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2021/09/react-child-component-rendering-300x86.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2021/09/react-child-component-rendering.png" decoding="async" class="aligncenter size-full wp-image-160823 jetpack-lazy-image" src="../Images/3a5000e41b96f5bfb7e084406dbefa0c.png" alt="Shows Child Component Rendering Because Parent Component Rendering" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2021/09/react-child-component-rendering.png 730w, https://blog.logrocket.com/wp-content/uploads/2021/09/react-child-component-rendering-300x86.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2021/09/react-child-component-rendering.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2021/09/react-child-component-rendering.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="160823" data-permalink="https://blog.logrocket.com/optimizing-performance-react-app/attachment/react-child-component-rendering/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2021/09/react-child-component-rendering.png" data-orig-size="730,210" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Shows child component rendering because parent component rendering" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2021/09/react-child-component-rendering-300x86.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2021/09/react-child-component-rendering.png" decoding="async" loading="lazy" class="aligncenter size-full wp-image-160823" src="../Images/3a5000e41b96f5bfb7e084406dbefa0c.png" alt="Shows Child Component Rendering Because Parent Component Rendering" srcset="https://blog.logrocket.com/wp-content/uploads/2021/09/react-child-component-rendering.png 730w, https://blog.logrocket.com/wp-content/uploads/2021/09/react-child-component-rendering-300x86.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2021/09/react-child-component-rendering.png"/></noscript> <img data-attachment-id="160825" data-permalink="https://blog.logrocket.com/optimizing-performance-react-app/attachment/react-child-component-rendering-2/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2021/09/react-child-component-rendering-1.png" data-orig-size="730,210" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="react-child-component-rendering" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2021/09/react-child-component-rendering-1-300x86.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2021/09/react-child-component-rendering-1.png" decoding="async" class="aligncenter size-full wp-image-160825 jetpack-lazy-image" src="../Images/6a0319c9f37a7340940f5cac4c0a0f84.png" alt="" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2021/09/react-child-component-rendering-1.png 730w, https://blog.logrocket.com/wp-content/uploads/2021/09/react-child-component-rendering-1-300x86.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2021/09/react-child-component-rendering-1.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2021/09/react-child-component-rendering-1.png"/><noscript><img data-lazy-fallback="1" data-attachment-id="160825" data-permalink="https://blog.logrocket.com/optimizing-performance-react-app/attachment/react-child-component-rendering-2/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2021/09/react-child-component-rendering-1.png" data-orig-size="730,210" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="react-child-component-rendering" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2021/09/react-child-component-rendering-1-300x86.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2021/09/react-child-component-rendering-1.png" decoding="async" loading="lazy" class="aligncenter size-full wp-image-160825" src="../Images/6a0319c9f37a7340940f5cac4c0a0f84.png" alt="" srcset="https://blog.logrocket.com/wp-content/uploads/2021/09/react-child-component-rendering-1.png 730w, https://blog.logrocket.com/wp-content/uploads/2021/09/react-child-component-rendering-1-300x86.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2021/09/react-child-component-rendering-1.png"/></noscript>
<p>如果我们在<code>child</code>组件中有一个需要时间计算的操作，这会影响 React 应用程序的性能。这让我们想到了我们的优化技术。</p>
<h2 id="react-performance-optimization-techniques">反应性能优化技术</h2>
<h3 id="component-state-local">必要时保持组件状态局部化</h3>
<p>我们已经知道，父组件中的状态更新会重新呈现父组件及其子组件。因此，为了确保只在必要时才重新呈现组件，我们可以提取与组件状态相关的代码部分，使其位于该部分代码的本地。</p>
<p>通过重构我们之前的代码，我们得到了以下内容:</p>
<pre class="language-javascript hljs">import { useState } from "react";

export default function App() {
  return (
    &lt;div&gt;
      &lt;FormInput /&gt;
      &lt;ChildComponent /&gt;
    &lt;/div&gt;
  );
}

function FormInput() {
  const [input, setInput] = useState("");

  return (
    &lt;div&gt;
      &lt;input
        type="text"
        value={input}
        onChange={(e) =&gt; setInput(e.target.value)}
      /&gt;
      &lt;h3&gt;Input text: {input}&lt;/h3&gt;
    &lt;/div&gt;
  );
}

function ChildComponent() {
  console.log("child component is rendering");
  return &lt;div&gt;This is child component.&lt;/div&gt;;
}
</pre>
<p>这确保了只有关心状态的组件才会呈现。在我们的代码中，只有输入字段关心状态。因此，我们将该状态和输入提取到一个<code>FormInput</code>组件，使其成为<code>ChildComponent</code>的兄弟。</p>
<p>这意味着当<code>FormInput</code>组件中的状态改变时，只有组件被重新渲染。如果我们在演示中再次测试这个应用程序，<code>ChildComponent</code>不再在每次击键时重新呈现。使用这种技术，我们可以大大提高 React 应用程序的性能。这是演示:</p>
<p class="codepen" data-height="399.36328125" data-default-tab="html,result" data-slug-hash="vYzBBMW" data-user="nefejames">参见<a href="https://codepen.io"> CodePen </a>上的笔<a href="https://codepen.io/nefejames/pen/vYzBBMW"> <br/>保持组件状态本地</a>由 Emadamerho Nefe(<a href="https://codepen.io/nefejames">@ Nefe James</a>)<br/>。</p>
<p/>
<p>但有时，我们无法避免在全局组件中有一个状态，同时将它作为道具传递给子组件。在这种情况下，让我们学习如何避免重新渲染未受影响的子组件。</p>
<h3 id="memoizing-react-components">记忆反应组件以防止不必要的重新渲染</h3>
<p>与前面的性能技术不同，在前面的技术中，重构代码可以提高性能，而在这里，我们用内存空间换取时间。因此，我们必须仅在必要时记忆组件。</p>
<p><a href="https://blog.logrocket.com/react-re-reselect-better-memoization-cache-management/"> Memoization </a>是一种优化策略，它缓存组件渲染的操作，将结果保存在内存中，并返回相同输入的缓存结果。本质上，如果一个子组件收到一个道具，默认情况下，记忆组件会简单地比较这个道具，如果道具没有改变，它会跳过子组件的重新渲染。看起来是这样的:</p>
<pre class="language-javascript hljs">import { useState } from "react";

export default function App() {
  const [input, setInput] = useState("");
  const [count, setCount] = useState(0);

  return (
    &lt;div&gt;
      &lt;input
        type="text"
        value={input}
        onChange={(e) =&gt; setInput(e.target.value)}
      /&gt;
      &lt;button onClick={() =&gt; setCount(count + 1)}&gt;Increment counter&lt;/button&gt;
      &lt;h3&gt;Input text: {input}&lt;/h3&gt;
      &lt;h3&gt;Count: {count}&lt;/h3&gt;
      &lt;hr /&gt;
      &lt;ChildComponent count={count} /&gt;
    &lt;/div&gt;
  );
}

function ChildComponent({ count }) {
  console.log("child component is rendering");
  return (
    &lt;div&gt;
      &lt;h2&gt;This is a child component.&lt;/h2&gt;
      &lt;h4&gt;Count: {count}&lt;/h4&gt;
    &lt;/div&gt;
  );
}
</pre>
<p>通过更新输入字段，<code>App</code>组件和<code>ChildComponent</code>重新呈现，你可以在这里看到<a href="https://codepen.io/nefejames/pen/KKxPKvp"/>。相反，<code>ChildComponent</code>应该只在点击<strong> <code>count</code>按钮</strong>时重新渲染，因为它必须更新 UI。</p>
<p>在这里，我们可以记忆<code>ChildComponent</code>来优化我们应用的性能:</p>
<p class="codepen" data-height="399.4609375" data-default-tab="html,result" data-slug-hash="KKxPKvp" data-user="nefejames">参见<a href="https://codepen.io"> CodePen </a>上 Emadamerho Nefe(<a href="https://codepen.io/nefejames">@ Nefe James</a>)<br/>的 Pen <a href="https://codepen.io/nefejames/pen/KKxPKvp"> <br/> memoization-one </a>。</p>
<p/>
<h3 id="react-memo">实施<code>React.memo()</code></h3>
<p><code>React.memo</code>是一个<a href="https://blog.logrocket.com/understanding-react-higher-order-components/">高阶组件</a>，用于包装一个纯粹的功能组件，以防止在该组件中接收的道具从不改变的情况下重新渲染:</p>
<pre class="language-javascript hljs">import React, { useState } from "react";

// ...

const ChildComponent = React.memo(function ChildComponent({ count }) {
  console.log("child component is rendering");
  return (
    &lt;div&gt;
      &lt;h2&gt;This is a child component.&lt;/h2&gt;
      &lt;h4&gt;Count: {count}&lt;/h4&gt;
    &lt;/div&gt;
  );
});
</pre>
<p>如果<code>count</code>属性从不改变，React 将跳过渲染<code>ChildComponent</code>并重用之前渲染的结果，最终提高 React 的性能。您可以在此处的教程中尝试一下:</p>
<p class="codepen" data-height="399.359375" data-default-tab="html,result" data-slug-hash="zYJOYPw" data-user="nefejames">参见<a href="https://codepen.io"> CodePen </a>上 Emadamerho Nefe(<a href="https://codepen.io/nefejames">@ Nefe James</a>)<br/>的 Pen <a href="https://codepen.io/nefejames/pen/zYJOYPw"> <br/> memoization-two </a>。</p>
<p/>
<p>在我们的例子中，当我们传递原始值(比如一个数字)时,<code>React.memo()</code>工作得很好。而且，如果你熟悉<a href="https://blog.logrocket.com/rethinking-hooks-memoization/#use-usememe-referential-equalities">引用相等</a>，原始值总是引用相等，如果值从不改变，则返回 true。</p>
<p>另一方面，像<code>object</code>这样的非原始值，包括数组和函数，总是在重新渲染之间返回<code>false</code>，因为它们指向内存中的不同空间。当我们把<code>object</code>、<code>array</code>或者<code>function</code>作为道具传下来的时候，记忆化的组件总是会重新渲染。</p>
<p>这里，<a href="https://codesandbox.io/s/angry-frost-rl829?file=/src/App.js">将一个功能传递给子组件</a>:</p>
<pre class="language-javascript hljs">import React, { useState } from "react";

export default function App() {
  // ...

  const incrementCount = () =&gt; setCount(count + 1);

  return (
    &lt;div&gt;
      {/* ... */}
      &lt;ChildComponent count={count} onClick={incrementCount} /&gt;
    &lt;/div&gt;
  );
}

const ChildComponent = React.memo(function ChildComponent({ count, onClick }) {
  console.log("child component is rendering");
  return (
    &lt;div&gt;
      {/* ... */}
      &lt;button onClick={onClick}&gt;Increment&lt;/button&gt;
      {/* ... */}
    &lt;/div&gt;
  );
});
</pre>
<p>这段代码主要关注传递给<code>ChildComponent</code>的<code>incrementCount</code>函数。当<code>App</code>组件重新渲染时，即使没有点击<code>count</code>按钮，该函数也会重新定义，使得<code>ChildComponent</code>也重新渲染。</p>
<p>为了防止函数总是被重定义，我们将使用一个<code>useCallback</code>钩子，它在渲染之间返回回调的一个记忆版本。</p>
<h3 id="use-call-back-use-memo-hooks">使用<code>useCallback</code>和<code>useMemo</code>挂钩</h3>
<p>使用<code>useCallback</code>钩子，<code>incrementCount</code>函数只在<code>count</code>依赖数组改变时重新定义:</p>
<pre class="language-javascript hljs">const incrementCount = React.useCallback(() =&gt; setCount(count + 1), [count]);
</pre>
<p>你可以在这里亲自尝试一下:</p>
<p class="codepen" data-height="399.8515625" data-default-tab="html,result" data-slug-hash="eYLOYyB" data-user="nefejames">参见<a href="https://codepen.io"> CodePen </a>上 Emadamerho Nefe(<a href="https://codepen.io/nefejames">@ Nefe James</a>)<br/>的钢笔<a href="https://codepen.io/nefejames/pen/eYLOYyB"> <br/> memoization-three </a>。</p>
<p/>
<p>当我们传递给子组件的道具是一个数组或对象时，我们可以使用一个<a href="https://blog.logrocket.com/react-memo-vs-usememo/"> <code>useMemo</code> </a>钩子来记忆渲染之间的值。正如我们在上面学到的，这些值指向内存中不同的空间，并且是全新的值。</p>
<p>您还可以使用<code>useMemo</code>钩子来避免在组件中重新计算同样昂贵的值。它允许我们记住这些值，并且只在依赖关系改变时才重新计算它们。与<code>useCallback</code>类似，<code>useMemo</code>钩子也需要一个函数和一组依赖项:</p>
<pre class="language-javascript hljs">const memoizedValue = React.useMemo(() =&gt; {
  // return expensive computation
}, []);
</pre>
<p>让我们看看如何应用<code>useMemo</code>钩子来提高 React 应用程序的性能。看看下面的代码，我们故意把它延迟得很慢:</p>
<pre class="language-javascript hljs">import React, { useState } from "react";

const expensiveFunction = (count) =&gt; {
  // artificial delay (expensive computation)
  for (let i = 0; i &lt; 1000000000; i++) {}
  return count * 3;
};

export default function App() {
  // ...
  const myCount = expensiveFunction(count);
  return (
    &lt;div&gt;
      {/* ... */}
      &lt;h3&gt;Count x 3: {myCount}&lt;/h3&gt;
      &lt;hr /&gt;
      &lt;ChildComponent count={count} onClick={incrementCount} /&gt;
    &lt;/div&gt;
  );
}

const ChildComponent = React.memo(function ChildComponent({ count, onClick }) {
  // ...
});
</pre>
<p>正如我们在这个<a href="https://codesandbox.io/s/determined-pond-94xg8?file=/src/App.js">代码沙箱</a>中所看到的，每当我们试图在<code>input</code>字段中输入文本以及点击<code><strong>count</strong></code> <strong>按钮</strong>时，我们的应用程序都会出现延迟。这是因为每次<code>App</code>组件渲染时，它都会调用<code>expensiveFunction</code>并降低应用程序的速度。</p>
<p>只有当点击<code><strong>count</strong></code> <strong>按钮</strong>时，才应该调用<code>expensiveFunction</code>，而不是当我们在<code>input</code>字段中键入时。我们可以使用<code>useMemo</code>钩子来记忆<code>expensiveFunction</code>的返回值，这样它只在需要时才重新计算函数，例如，当点击<code><strong>count</strong></code> <strong>按钮</strong>时。</p>
<p>为此，我们会有这样的东西:</p>
<pre class="language-javascript hljs">const myCount = React.useMemo(() =&gt; {
  return expensiveFunction(count);
}, [count]);
</pre>
<p>现在，如果我们在 CodeSandbox 上再次测试该应用程序，我们将不再遇到在输入字段中键入时的延迟:</p>
<p class="codepen" data-height="399.66015625" data-default-tab="html,result" data-slug-hash="OJoLJvY" data-user="nefejames">参见<a href="https://codepen.io"> CodePen </a>上 Emadamerho Nefe(<a href="https://codepen.io/nefejames">@ Nefe James</a>)<br/>的笔<a href="https://codepen.io/nefejames/pen/OJoLJvY"> <br/> memoization-four </a>。</p>
<p/>
<h3 id="code-splitting-import">使用动态<code>import()</code>在 React 中进行代码拆分</h3>
<p>代码分割是 React 应用程序的另一项重要的优化技术。默认情况下，当 React 应用程序在浏览器中呈现时，包含整个应用程序代码的包文件会立即加载并提供给用户。该文件通过合并 web 应用程序运行所需的所有代码文件来生成。</p>
<p>捆绑的想法很有用，因为它减少了一个页面可以处理的 HTTP 请求的数量。但是，随着应用程序的增长，文件大小也会增加，从而增加了包文件。在某一点上，这种连续的文件增加减缓了初始页面加载，降低了用户的满意度。</p>
<p>通过代码分割，React 允许我们使用动态<code>import()</code>将一个大的包文件分割成多个块，然后使用<code>React.lazy</code>按需通过<a href="https://blog.logrocket.com/lazy-loading-components-in-react-16-6-6cea535c0b52/">延迟加载</a>这些块。这种策略极大地提高了复杂 React 应用程序的页面性能。</p>
<p>为了实现代码分割，我们像这样转换一个普通的 React 导入:</p>
<pre class="language-javascript hljs">import Home from "./components/Home";
import About from "./components/About";
</pre>
<p>然后，变成这样:</p>
<pre class="language-javascript hljs">const Home = React.lazy(() =&gt; import("./components/Home"));
const About = React.lazy(() =&gt; import("./components/About"));
</pre>
<p>这个语法告诉<a href="https://blog.logrocket.com/react-dynamic-imports-route-centric-code-splitting-guide/#:~:text=Loadable%20Components-,Dynamic%20imports,-This%20is%20a"> React 动态加载每个组件</a>。例如，当用户点击主页链接时，React 只下载所请求页面的文件，而不是为整个应用程序加载一个大的包文件。导入之后，我们必须在一个<code>Suspense</code>组件中呈现惰性组件，就像这样:</p>
<pre class="language-javascript hljs">&lt;React.Suspense fallback={&lt;p&gt;Loading page...&lt;/p&gt;}&gt;
  &lt;Route path="/" exact&gt;
    &lt;Home /&gt;
  &lt;/Route&gt;
  &lt;Route path="/about"&gt;
    &lt;About /&gt;
  &lt;/Route&gt;
&lt;/React.Suspense&gt;
</pre>
<p>当 React 等待在 UI 中呈现惰性组件时，<code>Suspense</code>允许我们显示一个加载文本或指示器作为后备。您可以在这里亲自尝试一下:</p>
<p/>
<h3 id="windowing-list-virtualization-react">React 应用程序中的窗口或列表虚拟化</h3>
<p>假设我们有一个应用程序，其中我们在一个页面上呈现几行项目。无论任何项目是否显示在浏览器视窗中，它们都会在 DOM 中呈现，并且可能会影响我们的应用程序的性能。</p>
<p>有了<a href="https://blog.logrocket.com/react-performance-optimization-windowing-vs-component-recycling/">窗口</a>的概念，我们可以只向 DOM 呈现对用户可见的部分。然后，当滚动时，在替换退出视口的项目的同时，呈现剩余的列表项目。这种技术可以大大提高大型列表的<a href="https://blog.logrocket.com/render-large-lists-react-5-methods-examples/">渲染性能。</a><a href="https://blog.logrocket.com/how-to-virtualize-large-lists-using-react-window/"> react-window </a>和<a href="https://blog.logrocket.com/windowing-wars-react-virtualized-vs-react-window/"> react-virtualized </a>是两个流行的窗口库，可以实现这个概念。</p>
<h3 id="lazy-loading">在 React 中延迟加载图像</h3>
<p>为了优化由几个图像组成的应用程序，我们可以避免一次呈现所有图像，以缩短页面加载时间。通过延迟加载，我们可以等到每个图像即将出现在视口中时，才在 DOM 中呈现它们。</p>
<p>与上面提到的窗口概念类似，延迟加载图像可以防止创建不必要的 DOM 节点，从而提高 React 应用程序的性能。<br/> <a href="https://blog.logrocket.com/the-top-choices-for-react-lazy-loading-libraries-in-2021/"> react-lazyload 和 react-lazy-load-image-component</a>是流行的惰性加载库，可以在 React 项目中使用。</p>
<p>下面是一个用<code>react-lazy-load-image-component</code>进行延迟加载的例子:</p>
<pre class="language-javascript hljs">import { LazyLoadImage } from "react-lazy-load-image-component";
import "react-lazy-load-image-component/src/effects/blur.css";

export default function App() {
  return (
    &lt;div className="App"&gt;
      &lt;LazyLoadImage
        src={"https://placedog.net/500/300"}
        width={600}
        height={400}
        alt="Image Alt"
        effect="blur"
      /&gt;
    &lt;/div&gt;
  );
}
</pre>
<p/>
<h3 id="immutable-data-structures">使用不可变的数据结构</h3>
<p>不可变数据结构背后的思想很简单。不要直接对包含复杂数据的对象进行更改，而是制作已用更改更新的对象的副本。</p>
<p>然后，我们可以很容易地比较原始对象和新对象的引用，以识别更改并触发 UI 更新。React 状态应该被视为不可变的，我们永远不应该直接改变它。让我们看看这在实践中是如何工作的:</p>
<pre class="language-javascript hljs">export default function App() {
  const [bookInfo, setBookInfo] = useState({
    name: "A Cool Book",
    noOfPages: 28
  });

  const updateBookInfo = () =&gt; {
   bookInfo.name = 'A New title'
  };
  return (
    &lt;div className="App"&gt;
      &lt;h2&gt;Update the book's info&lt;/h2&gt;
      &lt;pre&gt;
        {JSON.stringify(bookInfo)}
      &lt;/pre&gt;
      &lt;button onClick={updateBookInfo}&gt;Update&lt;/button&gt;
    &lt;/div&gt;
  );
} 
</pre>
<p>这里，我们试图直接更新<code>updateBookInfo</code>函数中的<code>bookInfo</code>状态。这将导致一些性能问题，因为 React 无法跟踪更改并相应地更新 UI。我们可以通过将<code>bookInfo</code>状态视为<a href="https://blog.logrocket.com/immutability-react-should-you-mutate-objects/">不可变数据结构</a>来解决这个问题，而不是试图直接改变它:</p>
<pre class="language-javascript hljs">  const updateBookInfo = () =&gt; {
    const newBookInfo = { ...bookInfo };
    newBookInfo.name = "A Better Title";
    setBookInfo(newBookInfo);
  };
</pre>
<p>我们不是直接更新<code>updateBookInfo</code>中的状态，而是复制<code>bookInfo</code>，更新它并将新值传递给<code>setBookInfo</code>。这样，React 可以正确地跟踪发生的任何状态变化，并相应地正确更新 UI。虽然我们可以自己设置不变性，但是我们也可以使用像<a href="https://blog.logrocket.com/immutability-in-react-with-immer/"> Immer </a>和<a href="https://blog.logrocket.com/immer-and-immutable-js-how-do-they-compare/"> Immutable.js </a>这样的库。</p>
<p>这就是它的作用:</p>
<p class="codepen" data-height="399.109375" data-default-tab="html,result" data-slug-hash="gOdYYLR" data-user="nefejames">参见<a href="https://codepen.io"> CodePen </a>上 Emadamerho Nefe(<a href="https://codepen.io/nefejames">@ Nefe James</a>)<br/>的 Pen <a href="https://codepen.io/nefejames/pen/gOdYYLR"> <br/>不可变数据结构</a>。</p>
<p>在 React 中应用 web workers</p>
<h3 id="web-workers">我们可以使用<a href="https://blog.logrocket.com/web-workers-react-typescript/"> web workers </a>与应用程序的主线程并行运行<a href="https://blog.logrocket.com/everything-you-need-know-about-react-scripts/">脚本</a>。然后，我们可以在一个单独的线程中执行长时间的密集处理，而不会降低 UI 的渲染速度。让我们通过模拟一个阻塞的 UI 来看看这是如何工作的:</h3>
<p>在上面的代码片段中，我们设置了一个简单的应用程序，它有两种状态，<code>noOfApples</code>和<code>noOfTomatoes</code>。当点击<strong>按钮</strong>时，<code>noOfTomatoes</code>的计数增加。但是<code>noOfApples</code>因为循环而无法增加，进而阻塞了 UI。</p>
<pre class="language-javascript hljs">export default function App() {
  const [noOfTomatoes, setNoOfTomatoes] = useState(0);
  const [noOfApples, setNoOfApples] = useState(0);

  const addApples = () =&gt; {
    const start = Date.now();
    while (Date.now() &lt; start + 5000) {}
    setNoOfApples(noOfApples + 1);
  }
  return (
    &lt;main&gt;
      &lt;p&gt; Tomato: {noOfTomatoes} | Apple: {noOfApples} &lt;/p&gt;
      &lt;div&gt;
        &lt;button onClick={() =&gt; setNoOfTomatoes(noOfTomatoes + 1)}&gt;
          Tomato
        &lt;/button&gt;
        &lt;button onClick={() =&gt; addApples()}&gt;Apple&lt;/button&gt;
      &lt;/div&gt;
    &lt;/main&gt;
  );
}
</pre>
<p>让我们通过使用一个 web worker 来处理<code>addApples</code>功能来修复阻塞效应:</p>
<p><code>onmessage</code>是 web worker 的入口点，是我们在 app 中会触发的监听器。如果有一个事件的一些数据带有适当的<code>msg</code>，<code>"increaseAppleCount"</code>，在这种情况下，然后我们调用<code>addApples</code>函数，这增加了苹果的数量。</p>
<pre class="language-javascript hljs">//apple-worker.js

self.onmessage = async ($event) =&gt; {
    if ($event &amp;&amp; $event.data &amp;&amp; $event.data.msg === 'increaseAppleCount') {
        const newCounter = addApples($event.data.noOfApples);
        self.postMessage(newCounter);
    }
};

function addApples(noOfApples) {
    const start = Date.now();
    while (Date.now() &lt; start + 5000) {
    }
    return noOfApples + 1;
}
</pre>
<p>最后，我们通过<code>postMessage</code>将计数值返回给应用程序。然后，我们使用我们在 UI 中创建的<code>apple worker</code>:</p>
<p>在<code>useEffect</code>中，我们注册了一个监听器，当 web worker 发出一个结果时，它会更新<code>noOfApples</code>。最后，我们更新<code>addApples</code>函数来调用 web worker。这样，应用程序现在可以同时运行多个进程，而不会阻塞 UI 的呈现。</p>
<pre class="language-javascript hljs">function App() {
  const [noOfTomatoes, setNoOfTomatoes] = useState(0);
  const [noOfApples, setNoOfApples] = useState(0);

  useEffect(() =&gt; {
    appleWorker.onmessage = ($event) =&gt; {
      if ($event &amp;&amp; $event.data) {
        setNoOfApples($event.data);
      }
    };
  }, []);

  function addApples() {
    appleWorker.postMessage({
      msg: "increaseAppleCount",
      noOfApples: noOfApples,
    });
  }
  return (
    &lt;main&gt; ... &lt;/main&gt;
  );
} 
</pre>
<p>在 Redux 中使用重选来优化渲染</p>
<h3 id="reselect-redux">虽然<a href="https://blog.logrocket.com/react-hooks-context-redux-state-management/"> React 和 Redux </a>配合得很好，但 Redux 经常会导致性能问题，因为当状态改变时会出现不必要的重新渲染。我们可以使用 Redux 的选择器库<a href="https://github.com/reduxjs/reselect">r</a>T4】eselect 来防止不必要的渲染发生。</h3>
<p>Reselect 提供了一个用于创建记忆选择器的<code>createSelector</code>函数。记忆选择器将缓存它的值，只有在值改变时才重新呈现或重新计算。查看<a href="https://redux.js.org/usage/deriving-data-selectors"> Redux 文档</a>以了解更多关于选择器及其工作方式的信息。</p>
<p>结论</p>
<h2>为了成功地优化 React 应用程序，我们必须首先找到应用程序中的性能问题并加以纠正。在本指南中，我们解释了如何测量 React 应用程序的性能，以及如何优化性能以获得更好的 UX。</h2>
<p>如果你喜欢这个指南，确保你在网上分享它。另外，让我知道你对哪种技术最感兴趣。</p>
<p><a href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener"> LogRocket </a>:全面了解您的生产 React 应用</p><div class="code-block code-block-17">
<div class="blog-plug inline-plug react-plug" vwo-el-id="26283398190">
<h2 vwo-el-id="41600691720">调试 React 应用程序可能很困难，尤其是当用户遇到难以重现的问题时。如果您对监视和跟踪 Redux 状态、自动显示 JavaScript 错误以及跟踪缓慢的网络请求和组件加载时间感兴趣，</h2><p>. </p><a href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" vwo-el-id="19356441070">try LogRocket</a><p>LogRocket 结合了会话回放、产品分析和错误跟踪，使软件团队能够创建理想的 web 和移动产品体验。这对你来说意味着什么？</p><a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="19356441380">
<img class="first-react-image alignnone size-full wp-image-46 jetpack-lazy-image jetpack-lazy-image--handled" src="../Images/f300c244a1a1cf916df8b4cb02bec6c6.png" vwo-el-id="18272717540" data-lazy-loaded="1" data-original-src="https://files.readme.io/27c94e7-Image_2017-06-05_at_9.46.04_PM.png"/>
</a>
<a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="19356441690">
<img class="second-react-image alignnone size-full wp-image-46 jetpack-lazy-image jetpack-lazy-image--handled" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" vwo-el-id="30720362350" data-lazy-loaded="1" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/>
</a>
<p vwo-el-id="28675660440" class="">LogRocket 不是猜测错误发生的原因，也不是要求用户提供截图和日志转储，而是让您回放问题，就像它们发生在您自己的浏览器中一样，以快速了解哪里出错了。</p>
<p>不再有嘈杂的警报。智能错误跟踪允许您对问题进行分类，然后从中学习。获得有影响的用户问题的通知，而不是误报。警报越少，有用的信号越多。</p>
<p>LogRocket Redux 中间件包为您的用户会话增加了一层额外的可见性。LogRocket 记录 Redux 存储中的所有操作和状态。</p>
<p vwo-el-id="28675660750">现代化您调试 React 应用的方式— <a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="40093418840">开始免费监控</a>。</p>
<p vwo-el-id="28675661060">Modernize how you debug your React apps —
<a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="40093418840">start monitoring for free</a>.
</p>
</div></div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
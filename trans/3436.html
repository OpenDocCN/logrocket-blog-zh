<html>
<head>
<title>Build a Jamstack app with Tigris - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>使用Tigris - LogRocket博客构建Jamstack应用程序</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/build-jamstack-app-tigris/#0001-01-01">https://blog.logrocket.com/build-jamstack-app-tigris/#0001-01-01</a></blockquote><div><article class="article-post">
<p>当开发人员必须设置和配置多个工具时，构建web应用程序可能特别具有挑战性，这些工具可能包括数据库、服务器、构建工具和存储服务器。设置所有这些可能需要几个小时的开发时间，延长了产品上线的时间。</p>
<p>Jamstack的创建是为了减轻开发人员的负担，让他们在开发灵活、可伸缩、高性能和可维护的web应用程序时，能够专注于代码或业务逻辑。在本教程中，我们将学习如何用Tigris构建Jamstack应用程序。</p>
<p>要阅读本文，您需要在您的机器上安装Docker和Node.js <em> ≥ </em> v14。我们开始吧！</p>

<h2 id="what-tigris">什么是底格里斯</h2>
<p>Tigris 是一款开源、现代、可扩展的后端软件，用于开发实时网站和应用。凭借其零操作方法，Tigris将开发人员解放出来，让他们专注于自己的应用程序。Tigris是一个数据平台，允许开发人员构建实时应用程序，而不必处理所有繁琐的基础设施管理，从而允许更多以代码为中心的开发和更少的数据基础设施。</p>
<p>重要的是要记住，在撰写本文时，Tigris还处于测试阶段。</p>
<h2 id="why-use-tigris">为什么要用Tigris？</h2>
<p>让我们考虑一下您可能选择Tigris作为web应用程序的一些原因。首先，它处理所有的部署、配置、安全、监控和维护任务，以及基础设施组件。它是查询调优、索引管理和维护等传统数据处理方法的替代方法。</p>
<p>默认情况下，每个Tigris应用程序都包含一个数据库，因此没有必要学习新的数据库语言。Tigris保持数据控制，同时避免供应商锁定，并消除数据孤岛和庞大的数据基础设施。</p>
<h2 id="getting-started-tigris">Tigris入门</h2>
<p>满足上述要求后，让我们开始使用下面的命令搭建一个Tigris应用程序:</p>
<pre class="language-bash hljs">mkdir tigris-app &amp;&amp; cd tigris-app
npx create-tigris-app
</pre>
<p>上面的命令将创建一个<code>tigris-app</code>文件夹，并用下面的文件夹结构搭建一个新的Tigris应用程序:</p>
<pre class="language-txt hljs">tigris-app
┣ src
 ┃ ┣ lib
 ┃ ┃ ┗ config.ts
 ┃ ┣ models
 ┃ ┃ ┗ user.ts
 ┃ ┣ app.ts
 ┃ ┗ index.ts
 ┣ package-lock.json
 ┣ package.json
 ┗ tsconfig.json
</pre>
<ul>
<li><code>index.ts</code>:生成的应用程序的入口点</li>
<li><code>app.ts</code>:初始化Tigris客户端的应用程序类</li>
<li><code>models/user.ts</code>:包含用户集合的数据容器和模式。这里定义了Tigris应用程序中的所有模式</li>
</ul>
<p>您可以随意修改项目结构。</p>
<h2 id="start-tigris-docker">用Docker启动Tigris</h2>
<p>要运行Tigris服务器，运行下面的命令来<a href="https://blog.logrocket.com/node-js-docker-improve-dx-docker-compose/">运行Tigris的Docker映像</a>:</p>
<pre class="language-docker hljs">docker run -d -p 8081:8081 tigrisdata/tigris-local
</pre>
<p>上面的命令将在<code>localhost:8081</code>运行Tigris。现在，用下面的命令运行应用程序:</p>
<pre class="language-bash hljs">npm run start
</pre>
<p>上面的命令将运行项目中配置的默认操作，但我们将在以后更改这些操作。</p>
<h2 id="create-restful-web-app">创建RESTful web应用程序</h2>
<p>创建并运行我们的应用程序后，让我们修改项目，为博客网站创建一个RESTful web应用程序。首先，<a href="https://blog.logrocket.com/express-js-5-migration-guide/">使用下面的命令安装Express </a>:</p>
<pre class="language-bash hljs">npm install express @types/express
</pre>
<p>然后，在<code>src</code>目录下创建一个<code>controllers</code>文件夹。</p>
<h3 id="create-the-model">创建模型</h3>
<p>Tigris允许您将数据模型声明为应用程序的一部分，然后将它们转换为适当的对象，比如集合。我们将在模型的文件夹中这样做。将<code>models/user.ts</code>文件重命名为<code>blog.ts</code>,并用下面的代码片段替换现有代码:</p>
<pre class="language-typescript hljs">import {
    TigrisCollectionType,
    TigrisDataTypes,
    TigrisSchema
} from "@tigrisdata/core/dist/types";

export interface Blog extends TigrisCollectionType {
    id?: number;
    title: string;
    content: string;
    description: string
}

export const blogSchema: TigrisSchema&lt;Blog&gt; = {
    id: {
        type: TigrisDataTypes.INT32,
        primary_key: {
            order: 1,
            autoGenerate: true,
        },
    },
    title: {
        type: TigrisDataTypes.STRING,
    },
    content: {
        type: TigrisDataTypes.STRING,
    },
    description: {
        type: TigrisDataTypes.STRING,
    },
};
</pre>
<p>在上面的代码片段中，我们导入了<code>TigrisCollectionType</code>来定义我们正在创建的博客的接口类型，导入了<code>TigrisDataTypes</code>来定义我们的<code>blog</code>模式中的字段的数据类型，导入了<code>TigrisSchema</code>来定义模式类型。</p>
<p>接下来，我们创建了<code>blog</code>模式并定义了字段。我们有一个自动生成的主键<code>id</code>，以及每个博客的<code>title</code>、<code>content</code>和<code>description</code>。</p>
<h3 id="create-the-controllers">创建控制器</h3>
<p>创建模式后，让我们创建应用程序的控制器。首先，在<code>controllers</code>目录下创建<code>blog.ts</code>和<code>controller.ts</code>文件。在下面的代码片段中，我们将在<code>controller.ts</code>文件中定义一个接口来设置该应用程序的路由:</p>
<pre class="language-typescript hljs">import express from "express";

export interface Controller {
    setupRoutes(app: express.Application);
}
</pre>
<p>然后，在<code>controller/blog.ts</code>文件中，我们将创建所需的导入，创建一个<code>BlogController</code>类，并用代码片段定义所需的变量:</p>
<pre class="language-typescript hljs">import express, { Request, Response, Router } from "express";
import { Collection, DB } from "@tigrisdata/core";
import { Blog } from "../models/blog";
import { Controller } from "./controller";

export class BlogController implements Controller {
   private readonly db: DB;
   private readonly blogs: Collection&lt;Blog&gt;;
   private readonly router: Router;
   private readonly path: string;

  constructor(db: DB, app: express.Application) {
    this.blogs = db.getCollection&lt;Blog&gt;("blogs");
    this.path = "/blogs";
    this.router = Router();
    this.db = db;
  }
}
</pre>
<p>在上面的代码片段中，我们从Tigris导入了<code>Collection</code>和<code>DB</code>、<code>Blog</code>模式和<code>Controller</code>接口。然后，我们定义了全局变量，并在构造函数方法中为它们分配了适当的值和方法。</p>
<p>现在，让我们使用下面的代码片段将CRUD方法添加到该类中:</p>
<pre class="language-typescript hljs">//...
  public createBlog = async (req: Request, res: Response) =&gt; {
        try {
            const newBlog = await this.blogs.insert(req.body);

            res.status(200).json({
                data: newBlog,
                message: "Blog Created!",
            });
        } catch (e) {
            res.status(500).json({
                message: "An error occured:" + e,
            });
        }
    }
    public getBlogs = async (req: Request, res: Response) =&gt; {
        try {
            const blogs = await this.blogs.findMany(req.body);
            res.status(200).json({
                data: blogs
            });
        } catch (e) {
            res.status(500).json({
                message: "An error occured:" + e,
            });
        }
    }

    public getBlog = async (req: Request, res: Response) =&gt; {
        try {
            const blog = await this.blogs.findOne({
                id: Number.parseInt(req.params.id),
            });
            if (!blog) {
                return res.status(404).json({
                    data: blog,
                    message: "Blog not found!",
                });
            }
            return res.status(200).json({
                data: blog
            });
        } catch (e) {
            res.status(500).json({
                message: "An error occured:" + e,
            });
        }
    };

    public updateBlog = async (req: Request,
        res: Response,) =&gt; {
        try {
            await this.blogs.update({ id: parseInt(req.params.id) }, req.body);
            res.status(200).json({
                message: "Blog Updated"
            });

        } catch (e) {
            res.status(500).json({
                message: "An error occured:" + e,
            });
        }
    }
    public deleteBlog = async (
        req: Request,
        res: Response,
    ) =&gt; {
        try {
            await this.blogs.delete({
                id: Number.parseInt(req.params.id),
            });
            res.status(200).json({
                message: "Blog deleted",
            });
        } catch (e) {
            res.status(500).json({
                message: "An error occured:" + e,
            });
        }
    };
  //...
</pre>
<p>在上面的代码片段中，我们使用了blog的实例，它是我们通过<code>db.getCollection</code>函数访问的<code>Blog</code>模式的集合。这个函数为我们提供了在数据库中执行CRUD操作所需的方法。</p>
<p>然后，通过添加以下方法为此方法设置路由:</p>
<pre class="language-typescript hljs">//...
   public setupRoutes(app: express.Application) {
        this.router.post(`${this.path}/`, this.createBlog);
        this.router.get(`${this.path}/`, this.getBlogs);
        this.router.get(`${this.path}/:id`, this.getBlog);
        this.router.put(`${this.path}/:id`, this.updateBlog);
        this.router.delete(`${this.path}/:id`, this.deleteBlog);
        app.use("/", this.router);
    }
//...
</pre>
<p>在上面的代码片段中，我们使用了快速路由器(可以通过<code>router</code>实例访问)来为我们的<code>BlogController</code>中的每个方法定义路由的端点。最后，调用构造函数方法中的<code>setupRoutes</code>方法:</p>
<pre class="language-typescript hljs">constructor(db: DB, app: express.Application){
   // ...
   this.setupRoutes(app);
   //...
}
</pre>
<h3 id="configure-application">配置应用程序</h3>
<p>设置好控制器和路由后，让我们配置应用程序，初始化Tigris，为应用程序创建一个数据库，并创建一个博客集合。首先，删除<code>app.ts</code>文件中的代码，并替换为下面的代码片段:</p>
<pre class="language-typescript hljs">import { DB, Tigris } from "@tigrisdata/core";
import { Blog, blogSchema } from "./models/blog";
import express from "express";
import { BlogController } from "./controllers/blog";

export class Application {
    private readonly tigris: Tigris;
    private db: DB
    private readonly app: express.Application;
    private readonly PORT: string | number;
    private readonly dbName: string;

    constructor(tigris: Tigris) {
        this.tigris = tigris
        this.app = express()
        this.PORT = 3000;
        this.dbName = 'tigris_blog'
        this.setup();
    }

    public async setup() {
        this.app.use(express.json());
        await this.initTigris();
    }

    public async initTigris() {
        //create a database
        this.db = await this.tigris.createDatabaseIfNotExists(this.dbName);
        console.log('database created successfully')

        //register collections
        await this.db.createOrUpdateCollection&lt;Blog&gt;('blogs', blogSchema);

        //setup controllers
        new BlogController(this.db, this.app);
    }

    public start() {
        this.app.listen(this.PORT, () =&gt; {
            console.log(`Server is running at ${this.PORT}`)
        })
    }
}
</pre>
<p>在上面的代码中，我们导入并定义了这个类中需要的模块和全局变量。我们创建一个设置方法，其中我们创建应用程序的中间件，并通过调用<code>initTigris</code>方法初始化Tigris，这将创建一个数据库和我们的博客集合。我们还创建了一个start方法来在<code>port 3000</code>上运行应用程序，这是由<code>PORT</code>变量定义的。</p>
<p>现在，让我们修改<code>index.ts</code>文件来调用我们的<code>Application</code>类中的<code>start</code>方法，这将开始运行服务器:</p>
<pre class="language-typescript hljs">//..
app.start();
</pre>
<p>最后，确保在<code>lib/config</code>文件中初始化的Tigris客户端<code>serverUrl</code>正在监听<code>localhost:8081</code>，如下面的代码片段所示:</p>
<pre class="language-typescript hljs">import {Tigris} from "@tigrisdata/core";

export class Config {
    public initializeTigrisClient(): Tigris {
        return new Tigris({
            serverUrl: "localhost:8081",
            insecureChannel: true,
        });
    }
}
</pre>
<h2 id="test-application">测试应用程序</h2>
<p>现在，让我们使用cURL测试应用程序。运行以下命令创建新博客:</p>
<pre class="language-typescript hljs">curl http://localhost:4000/blogs \
    -X POST \
    -H 'Content-Type: application/json' \
    -d '{
        "title": "Build a web app with Node.js",
        "content": "Content goes here",
        "description":"Description goes here"
      }'
</pre>
<p>您应该会得到如下截图所示的响应:</p>
<p><img data-attachment-id="135790" data-permalink="https://blog.logrocket.com/build-jamstack-app-tigris/attachment/test-application-curl-result/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/10/test-application-curl-result.png" data-orig-size="597,32" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="test-application-curl-result" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/10/test-application-curl-result-300x16.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/10/test-application-curl-result.png" decoding="async" class="aligncenter wp-image-135790 size-full jetpack-lazy-image" src="../Images/f80433fa530798c2b1c69f67367b2d01.png" alt="Test Application Curl Result" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2022/10/test-application-curl-result.png 597w, https://blog.logrocket.com/wp-content/uploads/2022/10/test-application-curl-result-300x16.png 300w" data-lazy-sizes="(max-width: 597px) 100vw, 597px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2022/10/test-application-curl-result.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/10/test-application-curl-result.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="135790" data-permalink="https://blog.logrocket.com/build-jamstack-app-tigris/attachment/test-application-curl-result/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/10/test-application-curl-result.png" data-orig-size="597,32" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="test-application-curl-result" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/10/test-application-curl-result-300x16.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/10/test-application-curl-result.png" decoding="async" loading="lazy" class="aligncenter wp-image-135790 size-full" src="../Images/f80433fa530798c2b1c69f67367b2d01.png" alt="Test Application Curl Result" srcset="https://blog.logrocket.com/wp-content/uploads/2022/10/test-application-curl-result.png 597w, https://blog.logrocket.com/wp-content/uploads/2022/10/test-application-curl-result-300x16.png 300w" sizes="(max-width: 597px) 100vw, 597px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/10/test-application-curl-result.png"/></noscript>
<h2 id="conclusion">结论</h2>
<p>在本教程中，我们学习了如何用Tigris构建一个Jamstack应用程序。我们首先介绍了Tigris，并讨论了为什么您应该考虑使用它。然后，作为演示，我们构建了一个RESTful web应用程序来管理博客。</p>
<p>Tigris是一个令人兴奋的工具，我推荐查看Tigris文档以了解更多信息。我希望你喜欢这篇文章，并快乐编码！</p>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
<html>
<head>
<title>Using the React Testing Library debug method </title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>使用React测试库调试方法</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/using-react-testing-library-debug-method/#0001-01-01">https://blog.logrocket.com/using-react-testing-library-debug-method/#0001-01-01</a></blockquote><div><article class="article-post">
<p>在将应用程序部署到生产环境之前对其进行测试，可以保证产品不会出错，并按预期运行。知道如何执行正确的测试和调试代码是使你成为更好的开发人员的必要条件。</p>
<p>在本文中，我们将介绍如何使用React测试库<code><a href="https://testing-library.com/docs/react-testing-library/api/#debug">debug</a></code>方法来识别和分析测试错误。我们将讨论以下内容:</p>

<p>在本文的后面，我们还将探索用RTL <code>logTestingPlaygroundURL()</code>方法进行<a href="#debugging-log-testing-playground-url-method">调试。要跟随本教程，您应该</a><a href="https://blog.logrocket.com/comparing-react-testing-libraries/">熟悉React和React测试库</a>。你可以在GitHub库找到本教程<a href="https://github.com/Ibaslogic/react-rtl-debug">的完整代码。我们开始吧！</a></p>
<h2 id="react-testing-library-overview">React测试库概述</h2>
<p>React测试库，也称为RTL，提供了一个测试React组件的解决方案，模拟用户如何与它们交互。RTL的方法避免了测试实现细节，从而使我们的测试代码更容易维护。本质上，React测试库是一组与Jest 或Mocha等测试运行程序一起使用的实用工具。</p>
<h3 id="react-testing-library-vs-jest">React测试库vs. Jest</h3>
<p>回顾一下，<a href="https://blog.logrocket.com/jest-testing-top-features/"> Jest既是JavaScript相关库和框架的测试人员，也是测试框架</a>。因此，我们可以为React应用程序编写测试，并且只使用Jest来调试Jest测试。</p>
<p>Jest <a href="https://jestjs.io/docs/troubleshooting">提供了一些不同的方法</a>来调试应用程序，并在出错时解决问题。根据环境的不同，我们可以使用Chrome Inspector中的<a href="https://blog.logrocket.com/debugging-node-js-chrome-devtools/#debugger-keyword"> Node.js <code>debugger;</code> </a>语句或Visual Studio代码中的<a href="https://blog.logrocket.com/debugging-react-native-vs-code/">调试来对Jest测试进行故障排除。</a></p>
<p>虽然如果我们只使用Jest，上面的方法可能会很方便，但React测试库为我们提供了像<code>debug()</code>、<code>logTestingPlaygroundURL()</code>和<code>logRoles</code>函数这样的方法来简化调试测试。让我们深入研究并实现这些方法吧！</p>
<h2 id="adding-react-testing-library-react-apps">向React应用程序添加React测试库</h2>
<p>要在带有RTL的React应用程序上执行测试，并在调试期间识别测试错误，首先，我们必须将RTL添加到我们的应用程序中。</p>
<p>使用Create React App CLI创建的React项目与RTL捆绑在一起，因此不需要额外安装。否则，我们必须使用国家预防机制将RTL包括在内，如下所示:</p>
<pre class="language-bash hljs">npm install --save-dev @testing-library/react
</pre>
<p>我们也可以用纱线安装RTL:</p>
<pre class="language-bash hljs">yarn add --dev @testing-library/react
</pre>
<p>除了RTL，我们还将包括<a href="https://github.com/testing-library/jest-dom"><code>jest-dom</code>实用程序</a>，它允许我们使用像<code>.toBeInTheDocument()</code>这样的定制匹配器:</p>
<pre class="language-bash hljs">npm install --save-dev @testing-library/jest-dom
</pre>
<p>接下来，让我们<a href="https://github.com/Ibaslogic/react-rtl-debug">克隆我们将在本教程中使用的React项目</a>:</p>
<pre class="language-bash hljs">git clone https://github.com/Ibaslogic/react-rtl-debug 
</pre>
<p>然后，转到项目文件夹并生成<code>node_modules</code>文件夹:</p>
<pre class="language-bash hljs">cd react-rtl-debug

npm install
# or
yarn
</pre>
<p>最后，运行项目:</p>
<pre class="language-bash hljs">npm run start
# or
yarn start
</pre>
<p>您应该会在<code>port 3000</code>看到项目在浏览器中打开。如果它没有自动打开，请在成功启动开发服务器后访问<code><a href="http://localhost:3000/" rel="nofollow">http://localhost:3000/</a></code>:</p>
<p><img data-attachment-id="156296" data-permalink="https://blog.logrocket.com/1-initial-page-load-application-loading-message/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2023/01/1-initial-page-load-application-loading-message-.gif" data-orig-size="730,317" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="initial-page-load-application-loading-message" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2023/01/1-initial-page-load-application-loading-message--300x130.gif" data-large-file="https://blog.logrocket.com/wp-content/uploads/2023/01/1-initial-page-load-application-loading-message-.gif" decoding="async" class="aligncenter wp-image-156296 size-full jetpack-lazy-image" src="../Images/e2dfac871bab94729480a2d175986a82.png" alt="Initial Page Load Application Loading Message" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2023/01/1-initial-page-load-application-loading-message-.gif?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2023/01/1-initial-page-load-application-loading-message-.gif"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="156296" data-permalink="https://blog.logrocket.com/1-initial-page-load-application-loading-message/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2023/01/1-initial-page-load-application-loading-message-.gif" data-orig-size="730,317" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="initial-page-load-application-loading-message" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2023/01/1-initial-page-load-application-loading-message--300x130.gif" data-large-file="https://blog.logrocket.com/wp-content/uploads/2023/01/1-initial-page-load-application-loading-message-.gif" decoding="async" loading="lazy" class="aligncenter wp-image-156296 size-full" src="../Images/e2dfac871bab94729480a2d175986a82.png" alt="Initial Page Load Application Loading Message" data-original-src="https://blog.logrocket.com/wp-content/uploads/2023/01/1-initial-page-load-application-loading-message-.gif"/></noscript>
<p>如上面的GIF所示，当从后端服务器检索和显示帖子列表时，应用程序在初始页面加载时显示了一条加载消息。</p>
<p>如果你需要一个关于创建项目的复习，看看这篇关于如何在一个React项目中获取数据的文章。项目文件结构应类似于以下代码:</p>
<pre class="language-javascript hljs"> project
   ...
    ├── src
    │    ├── components
    │    │      ├── App.js
    │    │      ├── Header.js
    │    │      └── Posts.js
    │    ├── app.css
    │    ├── index.js
    │    └── setupTest.js
   ...
</pre>
<p>现在，我们可以开始与React测试库进行交互。</p>
<h2 id="using-react-testing-library">使用React测试库</h2>
<p>在我们开始使用<code>debug</code>方法之前，让我们探索一下RTL的一些设施。</p>
<p>RTL提供了让我们查询DOM节点并断言其内容的方法。在最简单的实现中，我们将编写一个测试来断言标题文本reading <code>Fetch asynchronous posts</code>显示在应用程序的UI中。</p>
<p>在名为<code>components/Header.test.js</code>的文本文件中，我们可以添加以下代码:</p>
<pre class="language-javascript hljs">import { render, screen } from '@testing-library/react';
import Header from './Header';

test('should display heading text', () =&gt; {
  render(&lt;Header /&gt;);
  const headingText = screen.getByText('Fetch asynchronous posts');
  expect(headingText).toBeInTheDocument();
});
</pre>
<p>React测试库中的<code>render</code>方法允许我们将想要测试的React组件呈现到测试环境中。同时，<code>screen</code>对象提供了对查询方法的访问，比如用<code>getByText()</code>来查找DOM节点。</p>
<p>然后，在测试块中，我们通过使用来自<code>jest-dom</code>的<code>toBeInTheDocument()</code>匹配器断言返回的DOM节点中的文本出现在页面上。</p>
<p>如果我们保存文件并用<code>npm run test</code>命令运行测试，测试应该通过，结果如下:</p>
<p><img data-attachment-id="156298" data-permalink="https://blog.logrocket.com/2-dom-node-text-present-rtl-test-pass/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2023/01/2-dom-node-text-present-rtl-test-pass.png" data-orig-size="730,169" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="dom-node-text-present-rtl-test-pass" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2023/01/2-dom-node-text-present-rtl-test-pass-300x69.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2023/01/2-dom-node-text-present-rtl-test-pass.png" decoding="async" class="aligncenter wp-image-156298 size-full jetpack-lazy-image" src="../Images/2eb698ddffc9b53be153bbd3d99ec764.png" alt="Dom Node Text Present Rtl Test Pass" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2023/01/2-dom-node-text-present-rtl-test-pass.png 730w, https://blog.logrocket.com/wp-content/uploads/2023/01/2-dom-node-text-present-rtl-test-pass-300x69.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2023/01/2-dom-node-text-present-rtl-test-pass.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2023/01/2-dom-node-text-present-rtl-test-pass.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="156298" data-permalink="https://blog.logrocket.com/2-dom-node-text-present-rtl-test-pass/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2023/01/2-dom-node-text-present-rtl-test-pass.png" data-orig-size="730,169" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="dom-node-text-present-rtl-test-pass" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2023/01/2-dom-node-text-present-rtl-test-pass-300x69.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2023/01/2-dom-node-text-present-rtl-test-pass.png" decoding="async" loading="lazy" class="aligncenter wp-image-156298 size-full" src="../Images/2eb698ddffc9b53be153bbd3d99ec764.png" alt="Dom Node Text Present Rtl Test Pass" srcset="https://blog.logrocket.com/wp-content/uploads/2023/01/2-dom-node-text-present-rtl-test-pass.png 730w, https://blog.logrocket.com/wp-content/uploads/2023/01/2-dom-node-text-present-rtl-test-pass-300x69.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2023/01/2-dom-node-text-present-rtl-test-pass.png"/></noscript>
<h2 id="debugging-test-failures-react-testing-library">用React测试库调试测试失败</h2>
<p>有时，不知不觉中，我们可能会编写一个测试来查询一个不存在的DOM元素。例如，让我们修改之前编写的查询中的文本，使其不匹配特定的元素:</p>
<pre class="language-javascript hljs">const headingText = screen.getByText(
  'Does not exist: Fetch asynchronous posts'
);
</pre>
<p>由于上述更改，测试将失败，结果如下:</p>
<p><img data-attachment-id="156300" data-permalink="https://blog.logrocket.com/3-test-fail-query-nonexistent-result/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2023/01/3-test-fail-query-nonexistent-result.png" data-orig-size="730,383" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="test-fail-query-nonexistent-result" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2023/01/3-test-fail-query-nonexistent-result-300x157.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2023/01/3-test-fail-query-nonexistent-result.png" decoding="async" class="aligncenter wp-image-156300 size-full jetpack-lazy-image" src="../Images/7d62969a3e17153284ee109b44208e15.png" alt="Test Fail Query Nonexistent Result" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2023/01/3-test-fail-query-nonexistent-result.png 730w, https://blog.logrocket.com/wp-content/uploads/2023/01/3-test-fail-query-nonexistent-result-300x157.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2023/01/3-test-fail-query-nonexistent-result.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2023/01/3-test-fail-query-nonexistent-result.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="156300" data-permalink="https://blog.logrocket.com/3-test-fail-query-nonexistent-result/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2023/01/3-test-fail-query-nonexistent-result.png" data-orig-size="730,383" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="test-fail-query-nonexistent-result" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2023/01/3-test-fail-query-nonexistent-result-300x157.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2023/01/3-test-fail-query-nonexistent-result.png" decoding="async" loading="lazy" class="aligncenter wp-image-156300 size-full" src="../Images/7d62969a3e17153284ee109b44208e15.png" alt="Test Fail Query Nonexistent Result" srcset="https://blog.logrocket.com/wp-content/uploads/2023/01/3-test-fail-query-nonexistent-result.png 730w, https://blog.logrocket.com/wp-content/uploads/2023/01/3-test-fail-query-nonexistent-result-300x157.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2023/01/3-test-fail-query-nonexistent-result.png"/></noscript>
<h2 id="automatic-logging">自动记录</h2>
<p>当<code>screen.getByText()</code>方法没有找到匹配的DOM节点时，它抛出一个有意义的错误消息，如上图所示。此错误包含DOM的当前状态，如图中突出显示的。</p>
<p>由于这种失败发生时的自动记录，我们可以更容易地可视化DOM，提示我们断言失败的原因。上图显示标题文本与我们在测试块中提供的不匹配。现在我们已经找到了错误，我们可以修复文本，这样我们的测试就会通过。</p>
<p>一种叫做<a href="https://blog.logrocket.com/test-driven-development-methods-deno/#what-test-driven-development">测试驱动开发(TDD) </a>的测试方法有助于使开发变得轻而易举；TDD让我们在产品完全开发出来之前，根据产品需求编写测试用例。</p>
<h2 id="using-screen-debug-method">使用<code>screen.debug()</code>方法</h2>
<p>React测试库从<code>screen</code>对象中公开了一个<code>debug()</code>方法来打印出DOM的状态。除了我们上面解释的自动日志记录之外，<code>debug()</code>方法还可以帮助我们在编写断言之前可视化DOM树。</p>
<h3>理解<code>screen.debug()</code>语法</h3>
<p>看看下面显示的<code>screen.debug()</code>语法:</p>
<pre class="language-javascript hljs">screen.debug(element, maxLengthToPrint, options);
</pre>
<p><code>debug()</code>方法的第一个参数是我们希望<code>screen.debug()</code>方法打印出来的<code>element</code>。该参数可以是单个元素，也可以是多个元素。如果未定义，它将默认打印根节点。</p>
<p>第二个参数让我们指定要打印的内容长度。默认输出长度是<code>7000</code>，这意味着内容将在七千个字符后被截断。我们可以根据需要增加或限制输出长度。</p>
<p>我们可能还想使用<code>options</code>参数来<a href="https://github.com/facebook/jest/tree/main/packages/pretty-format#usage-with-options">配置测试格式。例如，我们可以在终端中使用参数<code>options</code>关闭语法高亮显示，如下所示:</a></p>
<pre class="language-javascript hljs">screen.debug(undefined, null, { highlight: false });
</pre>
<h3>使用<code>debug()</code>方法的示例</h3>
<p>使用我们最后的测试示例，我们将使用<code>screen.debug()</code>方法来调试文档状态和<code>heading</code>元素。首先，让我们考虑调试文档状态:</p>
<pre class="language-javascript hljs">test('should display heading text', () =&gt; {
  render(&lt;Header /&gt;);
  screen.debug();
  // assertion
});
</pre>
<p>由于我们没有向<code>debug()</code>传递任何参数，它将如下所示打印DOM树的状态:</p>
<pre class="language-javascript hljs">&lt;body&gt;
  &lt;div&gt;
    &lt;h1&gt;
      Fetch asynchronous posts
    &lt;/h1&gt;
  &lt;/div&gt;
&lt;/body&gt;
</pre>
<p>通过可视化DOM，我们可以很容易地识别和分析测试错误，我们将在本文的后面探讨这一点。</p>
<p>接下来，我们考虑调试<code>heading</code>元素。为了记录<code>heading</code>元素，我们将把<code>heading</code>节点传递给<code>debug()</code>:</p>
<pre class="language-javascript hljs">test('should display heading text', () =&gt; {
  render(&lt;Header /&gt;);
  const headingText = screen.getByText('Fetch asynchronous posts');
  screen.debug(headingText);
  // assertion
});
</pre>
<p>以下是输出:</p>
<pre class="language-javascript hljs">&lt;h1&gt;
  Fetch asynchronous posts
&lt;/h1&gt;
</pre>
<p>使用由<code>debug()</code>方法打印的输出，我们确信目标元素存在于开发阶段。这将有助于我们在测试中做出正确的断言。</p>
<h2 id="waiting-appearance-disappearance-using-debug">使用<code>debug()</code>等待出现和消失</h2>
<p>让我们进一步探索React测试库<code>debug()</code>方法，看看我们如何使用它来检查程序在不同开发阶段的状态。</p>
<p>在本教程的前面，当从服务器获取数据时，我们看到了应用程序中显示的加载消息。数据一返回，加载消息就消失了。现在，我们将为这个异步操作编写一个测试，同时使用<code>debug()</code>方法调试测试代码。</p>
<h3>创建我们的测试文件并检查DOM状态</h3>
<p>为了渲染文章，我们使用了<code>components/Posts.js</code>组件文件。在同一个目录中，我们将创建一个名为<code>Posts.test.js</code>的测试文件，并添加以下代码:</p>
<pre>import { render, screen } from '@testing-library/react';
import Posts from './Posts.js';

test('should display loading message', () =&gt; {
  render(&lt;Posts /&gt;);
  screen.debug();
});
</pre>
<p>如果我们保存文件，我们应该看到DOM的当前状态:</p>
<p><img data-attachment-id="156302" data-permalink="https://blog.logrocket.com/4-test-file-render-posts/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2023/01/4-test-file-render-posts.png" data-orig-size="730,255" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="test-file-render-posts" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2023/01/4-test-file-render-posts-300x105.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2023/01/4-test-file-render-posts.png" decoding="async" class="aligncenter wp-image-156302 size-full jetpack-lazy-image" src="../Images/87fc2043e57fdff679d95033c1280b2a.png" alt="Test File Render Posts" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2023/01/4-test-file-render-posts.png 730w, https://blog.logrocket.com/wp-content/uploads/2023/01/4-test-file-render-posts-300x105.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2023/01/4-test-file-render-posts.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2023/01/4-test-file-render-posts.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="156302" data-permalink="https://blog.logrocket.com/4-test-file-render-posts/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2023/01/4-test-file-render-posts.png" data-orig-size="730,255" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="test-file-render-posts" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2023/01/4-test-file-render-posts-300x105.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2023/01/4-test-file-render-posts.png" decoding="async" loading="lazy" class="aligncenter wp-image-156302 size-full" src="../Images/87fc2043e57fdff679d95033c1280b2a.png" alt="Test File Render Posts" srcset="https://blog.logrocket.com/wp-content/uploads/2023/01/4-test-file-render-posts.png 730w, https://blog.logrocket.com/wp-content/uploads/2023/01/4-test-file-render-posts-300x105.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2023/01/4-test-file-render-posts.png"/></noscript>
<p>DOM中的当前状态包含预期的加载消息。此时，数据还没有到达。</p>
<h3>Axios &gt;0.27.2将在CRA打破Jest测试</h3>
<p>如果您在撰写本文时使用的是最新版本的Axios 1 . 2 . 5，您可能会遇到以下错误:</p>
<pre class="language-javascript hljs">SyntaxError: Cannot use import statement outside a module
</pre>
<p>这个Jest错误是由于较新版本的Axios如何发出<a href="https://blog.logrocket.com/commonjs-vs-es-modules-node-js/"> ES模块而不是CommonJS </a>。对此的解决方法是将<code>package.json</code>中的测试脚本更新为以下内容:</p>
<pre class="language-javascript hljs">"test": "react-scripts test --transformIgnorePatterns \"node_modules/(?!axios)/\"",
</pre>
<p>另一种选择是使用npm将Axios降级到v0.27.2:</p>
<pre class="language-bash hljs">npm i <a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="97f6effef8e4d7e1a7b9a5a0b9a5">[email protected]</a>
</pre>
<p>然后，用<code>Ctrl + C</code>停止测试，用<code>npm run test</code>重新运行。现在您应该可以看到DOM树的当前状态。</p>
<h3>断言我们的文本在文档中</h3>
<p>现在我们知道了React测试库看到的是什么，我们可以断言字符串<code>A moment please…</code>存在于文档中。为此，请将测试块更新为以下代码:</p>
<pre class="language-javascript hljs">test('should display loading message', () =&gt; {
  render(&lt;Posts /&gt;);
  // screen.debug();
  const loadingMessage = screen.getByText('A moment please...');
  expect(loadingMessage).toBeInTheDocument();
});
</pre>
<p>如果我们保存测试文件，测试应该通过，结果如下:</p>
<p><img data-attachment-id="156304" data-permalink="https://blog.logrocket.com/5-asserting-string-document-test-pass/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2023/01/5-asserting-string-document-test-pass.png" data-orig-size="730,235" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="asserting-string-document-test-pass" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2023/01/5-asserting-string-document-test-pass-300x97.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2023/01/5-asserting-string-document-test-pass.png" decoding="async" class="aligncenter wp-image-156304 size-full jetpack-lazy-image" src="../Images/0973568fcb4ad123931727ae4b8b09b1.png" alt="Asserting String Document Test Pass" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2023/01/5-asserting-string-document-test-pass.png 730w, https://blog.logrocket.com/wp-content/uploads/2023/01/5-asserting-string-document-test-pass-300x97.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2023/01/5-asserting-string-document-test-pass.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2023/01/5-asserting-string-document-test-pass.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="156304" data-permalink="https://blog.logrocket.com/5-asserting-string-document-test-pass/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2023/01/5-asserting-string-document-test-pass.png" data-orig-size="730,235" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="asserting-string-document-test-pass" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2023/01/5-asserting-string-document-test-pass-300x97.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2023/01/5-asserting-string-document-test-pass.png" decoding="async" loading="lazy" class="aligncenter wp-image-156304 size-full" src="../Images/0973568fcb4ad123931727ae4b8b09b1.png" alt="Asserting String Document Test Pass" srcset="https://blog.logrocket.com/wp-content/uploads/2023/01/5-asserting-string-document-test-pass.png 730w, https://blog.logrocket.com/wp-content/uploads/2023/01/5-asserting-string-document-test-pass-300x97.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2023/01/5-asserting-string-document-test-pass.png"/></noscript>
<h2 id="testing-appearance">外观测试</h2>
<p>让我们执行一个测试来确保我们的post数据从服务器返回并显示在客户机上。我们将使用<code>debug</code>方法来简化测试过程。</p>
<p>因为我们异步获取post数据，所以我们必须设置我们的测试来等待post在DOM中显示。对于这样的操作，RTL提供了像<code>findBy*</code>和<code>waitFor</code>这样的异步方法。这些方法返回承诺，所以我们在调用它们时将通过使用<code>await</code>关键字来对待它们。下面的代码使用<code>findBy*</code>异步方法执行异步测试:</p>
<pre class="language-javascript hljs">test('should fetch and display asynchronous posts', async () =&gt; {
  render(&lt;Posts /&gt;);
  screen.debug(); //post initially not present
  const postItemNode = await screen.findByText('qui est esse');
  screen.debug(); //post is present
});
</pre>
<p><code>findBy*</code>返回一个承诺，该承诺只有在其他情况下找到或拒绝某个元素时才会解决。我们已经用关键字<code>await</code>处理了这个返回的承诺，以防止测试在异步承诺解决之前完成。这样做有助于避免误报失败，这是一种即使应用程序中断，测试也能通过的情况。</p>
<p>注意我们是如何有策略地放置<code>debug()</code>方法来在post数据到达之前和之后可视化DOM树的。请参见下面的输出:</p>
<p><img data-attachment-id="156306" data-permalink="https://blog.logrocket.com/6-visualize-dom-tree-date-before-after/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2023/01/6-visualize-dom-tree-date-before-after.png" data-orig-size="730,406" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="visualize-dom-tree-date-before-after" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2023/01/6-visualize-dom-tree-date-before-after-300x167.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2023/01/6-visualize-dom-tree-date-before-after.png" decoding="async" class="aligncenter wp-image-156306 size-full jetpack-lazy-image" src="../Images/926ac9354a697d58e586d93cec62b048.png" alt="Visualize DOM Tree Date Before After" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2023/01/6-visualize-dom-tree-date-before-after.png 730w, https://blog.logrocket.com/wp-content/uploads/2023/01/6-visualize-dom-tree-date-before-after-300x167.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2023/01/6-visualize-dom-tree-date-before-after.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2023/01/6-visualize-dom-tree-date-before-after.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="156306" data-permalink="https://blog.logrocket.com/6-visualize-dom-tree-date-before-after/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2023/01/6-visualize-dom-tree-date-before-after.png" data-orig-size="730,406" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="visualize-dom-tree-date-before-after" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2023/01/6-visualize-dom-tree-date-before-after-300x167.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2023/01/6-visualize-dom-tree-date-before-after.png" decoding="async" loading="lazy" class="aligncenter wp-image-156306 size-full" src="../Images/926ac9354a697d58e586d93cec62b048.png" alt="Visualize DOM Tree Date Before After" srcset="https://blog.logrocket.com/wp-content/uploads/2023/01/6-visualize-dom-tree-date-before-after.png 730w, https://blog.logrocket.com/wp-content/uploads/2023/01/6-visualize-dom-tree-date-before-after-300x167.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2023/01/6-visualize-dom-tree-date-before-after.png"/></noscript>
<p>正如我们所见，<code>debug</code>方法有助于模拟应用程序的行为。当页面最初加载时，它会打印一条加载消息。当数据返回时，它用数据替换加载消息。</p>
<p>既然我们已经确定post数据已经到达，我们可以断言DOM中存在一个<code>post</code>条目:</p>
<pre class="language-javascript hljs">test('should fetch and display asynchronous posts', async () =&gt; {
  render(&lt;Posts /&gt;);
  const postItemNode = await screen.findByText('qui est esse');
  expect(postItemNode).toBeInTheDocument();
});
</pre>
<p>测试应该通过，结果如下:</p>
<p><img data-attachment-id="156308" data-permalink="https://blog.logrocket.com/7-assert-post-item-present-dom/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2023/01/7-assert-post-item-present-dom.png" data-orig-size="730,172" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="assert-post-item-present-dom" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2023/01/7-assert-post-item-present-dom-300x71.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2023/01/7-assert-post-item-present-dom.png" decoding="async" class="aligncenter wp-image-156308 size-full jetpack-lazy-image" src="../Images/e606c887e511c46f19a1c485a07c4a94.png" alt="Assert Post Item Present Dom" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2023/01/7-assert-post-item-present-dom.png 730w, https://blog.logrocket.com/wp-content/uploads/2023/01/7-assert-post-item-present-dom-300x71.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2023/01/7-assert-post-item-present-dom.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2023/01/7-assert-post-item-present-dom.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="156308" data-permalink="https://blog.logrocket.com/7-assert-post-item-present-dom/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2023/01/7-assert-post-item-present-dom.png" data-orig-size="730,172" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="assert-post-item-present-dom" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2023/01/7-assert-post-item-present-dom-300x71.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2023/01/7-assert-post-item-present-dom.png" decoding="async" loading="lazy" class="aligncenter wp-image-156308 size-full" src="../Images/e606c887e511c46f19a1c485a07c4a94.png" alt="Assert Post Item Present Dom" srcset="https://blog.logrocket.com/wp-content/uploads/2023/01/7-assert-post-item-present-dom.png 730w, https://blog.logrocket.com/wp-content/uploads/2023/01/7-assert-post-item-present-dom-300x71.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2023/01/7-assert-post-item-present-dom.png"/></noscript>
<h3>避免触及实际的API</h3>
<p>在实践中，当执行测试时，我们应该避免触及实际的API，以防止我们的测试变得缓慢和脆弱。相反，我们应该创建模拟数据来模拟API交互。</p>
<p>本教程关注的是<code>debug</code>方法，所以我们不会讨论模仿API。然而，<a href="https://github.com/Ibaslogic/react-rtl-debug">这个项目的GitHub库</a>使用<a href="https://blog.logrocket.com/getting-started-with-mock-service-worker/">模拟服务工作者(MSW) </a>实现API模拟。</p>
<h2 id="testing-disappearance">消失测试</h2>
<p>为了结束我们关于React测试库<code>debug</code>方法的课程，我们可以测试加载消息最初出现在页面加载中，然后在post数据到达时消失。测试代码如下所示:</p>
<pre class="language-javascript hljs">test('Should display loading message and disappear when posts arrive', async () =&gt; {
  render(&lt;Posts /&gt;);
  screen.debug(); //message initially present
  await waitForElementToBeRemoved(() =&gt;
    screen.getByText('A moment please...')
  );
  screen.debug(); //loading message not present
});
</pre>
<p>虽然这不是本文的重点，但RTL提供了<a href="https://testing-library.com/docs/dom-testing-library/api-async/#waitforelementtoberemoved"> <code>waitForElementToBeRemoved</code> </a>助手函数来测试一个元素最初异步出现，然后消失。它返回一个承诺，当目标节点从DOM中移除时，该承诺将被解析。</p>
<p><code>debug()</code>方法的放置让我们可以在加载消息消失前后可视化DOM树。以下是输出:</p>
<p><img data-attachment-id="156311" data-permalink="https://blog.logrocket.com/8-debug-method-placement-visualize-dom-tree/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2023/01/8-debug-method-placement-visualize-dom-tree.png" data-orig-size="730,424" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="debug-method-placement-visualize-dom-tree" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2023/01/8-debug-method-placement-visualize-dom-tree-300x174.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2023/01/8-debug-method-placement-visualize-dom-tree.png" decoding="async" class="aligncenter wp-image-156311 size-full jetpack-lazy-image" src="../Images/a48cd6702e4fc7e0189fdbf0944daa5e.png" alt="Debug Method Placement Visualize Dom Tree" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2023/01/8-debug-method-placement-visualize-dom-tree.png 730w, https://blog.logrocket.com/wp-content/uploads/2023/01/8-debug-method-placement-visualize-dom-tree-300x174.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2023/01/8-debug-method-placement-visualize-dom-tree.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2023/01/8-debug-method-placement-visualize-dom-tree.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="156311" data-permalink="https://blog.logrocket.com/8-debug-method-placement-visualize-dom-tree/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2023/01/8-debug-method-placement-visualize-dom-tree.png" data-orig-size="730,424" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="debug-method-placement-visualize-dom-tree" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2023/01/8-debug-method-placement-visualize-dom-tree-300x174.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2023/01/8-debug-method-placement-visualize-dom-tree.png" decoding="async" loading="lazy" class="aligncenter wp-image-156311 size-full" src="../Images/a48cd6702e4fc7e0189fdbf0944daa5e.png" alt="Debug Method Placement Visualize Dom Tree" srcset="https://blog.logrocket.com/wp-content/uploads/2023/01/8-debug-method-placement-visualize-dom-tree.png 730w, https://blog.logrocket.com/wp-content/uploads/2023/01/8-debug-method-placement-visualize-dom-tree-300x174.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2023/01/8-debug-method-placement-visualize-dom-tree.png"/></noscript>
<p>如上图所示，第一个<code>debug</code>方法打印包含加载消息的DOM树，而第二个<code>debug</code>方法通知我们消息不再存在，因为数据已经从服务器到达。</p>
<p>请记住，我们已经使用MSW实现了一个模拟API来拦截网络请求并返回响应。在这种情况下，它返回上面看到的<code>title 1</code>文本，而不是API post的实际数据。</p>
<p>现在，测试应该通过，结果如下:</p>
<p><img data-attachment-id="156313" data-permalink="https://blog.logrocket.com/9-debug-method-print-dom-tree-test-pass/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2023/01/9-debug-method-print-dom-tree-test-pass.png" data-orig-size="730,187" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="debug-method-print-dom-tree-test-pass" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2023/01/9-debug-method-print-dom-tree-test-pass-300x77.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2023/01/9-debug-method-print-dom-tree-test-pass.png" decoding="async" class="aligncenter wp-image-156313 size-full jetpack-lazy-image" src="../Images/81c5c4da7bcfe1b39554b6269e88bc29.png" alt="Debug Method Print Dom Tree Test Pass" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2023/01/9-debug-method-print-dom-tree-test-pass.png 730w, https://blog.logrocket.com/wp-content/uploads/2023/01/9-debug-method-print-dom-tree-test-pass-300x77.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2023/01/9-debug-method-print-dom-tree-test-pass.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2023/01/9-debug-method-print-dom-tree-test-pass.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="156313" data-permalink="https://blog.logrocket.com/9-debug-method-print-dom-tree-test-pass/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2023/01/9-debug-method-print-dom-tree-test-pass.png" data-orig-size="730,187" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="debug-method-print-dom-tree-test-pass" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2023/01/9-debug-method-print-dom-tree-test-pass-300x77.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2023/01/9-debug-method-print-dom-tree-test-pass.png" decoding="async" loading="lazy" class="aligncenter wp-image-156313 size-full" src="../Images/81c5c4da7bcfe1b39554b6269e88bc29.png" alt="Debug Method Print Dom Tree Test Pass" srcset="https://blog.logrocket.com/wp-content/uploads/2023/01/9-debug-method-print-dom-tree-test-pass.png 730w, https://blog.logrocket.com/wp-content/uploads/2023/01/9-debug-method-print-dom-tree-test-pass-300x77.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2023/01/9-debug-method-print-dom-tree-test-pass.png"/></noscript>
<h2 id="logroles-function"><code>logRoles</code>功能</h2>
<p>像<code>debug()</code>方法一样，<code><a href="https://testing-library.com/docs/dom-testing-library/api-accessibility/#logroles">logRoles</a></code>可以记录一个元素的ARIA角色或应用于DOM树中元素的角色列表。这个过程有助于使测试更容易，我们马上就会看到。</p>
<p>在本教程中，我们使用了<code>getByText</code>和<code>findByText</code>查询方法来查找页面上的元素。在这一过程中，RTL将<code>*ByRole</code>的同行放在的<a href="https://testing-library.com/docs/queries/about#priority">优先级列表的顶端。</a></p>
<p>要使用<code>*ByRole</code>查询，我们必须熟悉HTML元素中隐含的角色。在处理非语义元素时，我们可以手动提供一个<code>role</code>属性。像<code>&lt;button&gt;</code>这样的语义元素有一个隐含的角色<code>button</code>。请随意查看适用于HTML元素的ARIA角色的<a href="https://www.w3.org/TR/html-aria/#docconformance">列表。</a></p>
<p>使用<code>logRoles</code>函数，我们可以很容易地记录元素的隐式ARIA角色，以便在我们的可访问性测试中使用。如果我们使用<code>findByText</code>重温我们之前的测试，我们可以像这样将助手函数应用到我们的测试代码中:</p>
<pre class="language-javascript hljs">import {
  // ...
  logRoles,
} from '@testing-library/react';
// ...
test('should view implicit roles with logRoles', async () =&gt; {
  render(&lt;Posts /&gt;);
  const postItemNode = await screen.findByText('title 1');
  logRoles(postItemNode);
  expect(postItemNode).toBeInTheDocument();
});
</pre>
<p>在上面的代码中，我们从测试库中导入<code>logRoles</code>开始。然后，我们将目标节点作为参数传递给函数。输出将为我们提供该元素的ARIA角色:</p>
<p><img data-attachment-id="156315" data-permalink="https://blog.logrocket.com/10-logroles-target-node-output-argument-function/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2023/01/10-logroles-target-node-output-argument-function.png" data-orig-size="730,285" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="logroles-target-node-output-argument-function" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2023/01/10-logroles-target-node-output-argument-function-300x117.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2023/01/10-logroles-target-node-output-argument-function.png" decoding="async" class="aligncenter wp-image-156315 size-full jetpack-lazy-image" src="../Images/03c918bba43426a61279524653a598f4.png" alt="Logroles Target Node Output Argument Function" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2023/01/10-logroles-target-node-output-argument-function.png 730w, https://blog.logrocket.com/wp-content/uploads/2023/01/10-logroles-target-node-output-argument-function-300x117.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2023/01/10-logroles-target-node-output-argument-function.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2023/01/10-logroles-target-node-output-argument-function.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="156315" data-permalink="https://blog.logrocket.com/10-logroles-target-node-output-argument-function/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2023/01/10-logroles-target-node-output-argument-function.png" data-orig-size="730,285" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="logroles-target-node-output-argument-function" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2023/01/10-logroles-target-node-output-argument-function-300x117.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2023/01/10-logroles-target-node-output-argument-function.png" decoding="async" loading="lazy" class="aligncenter wp-image-156315 size-full" src="../Images/03c918bba43426a61279524653a598f4.png" alt="Logroles Target Node Output Argument Function" srcset="https://blog.logrocket.com/wp-content/uploads/2023/01/10-logroles-target-node-output-argument-function.png 730w, https://blog.logrocket.com/wp-content/uploads/2023/01/10-logroles-target-node-output-argument-function-300x117.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2023/01/10-logroles-target-node-output-argument-function.png"/></noscript>
<p>如上图所示，咏叹调角色是<code>heading</code>。我们可以重构测试代码来使用<code>findByRole</code>可访问的查询，而不是<code>findByText</code>，因此我们有如下代码:</p>
<pre class="language-javascript hljs">test('should view implicit roles with logRoles', async () =&gt; {
  render(&lt;Posts /&gt;);
  const postItemNode = await screen.findByRole('heading', {
    name: 'title 1',
  });
  expect(postItemNode).toBeInTheDocument();
});
</pre>
<p>为了保证我们的UI是可访问的，我们应该考虑在其他查询类型之前使用<code>*ByRole</code>。</p>
<p>要打印应用于DOM树中元素的ARIA角色列表，我们可以将呈现的容器元素作为参数传递给<code>logRoles</code>。代码将如下所示:</p>
<pre class="language-javascript hljs">test('should view implicit roles with logRoles', async () =&gt; {
  const view = render(&lt;Posts /&gt;);
  const postItemNode = await screen.findByRole('heading', {
    name: 'title 1',
  });
  logRoles(view.container);
  expect(postItemNode).toBeInTheDocument();
});
</pre>
<p>现在，输出将如下图所示:</p>
<p><img data-attachment-id="156318" data-permalink="https://blog.logrocket.com/11-print-aria-roles-dom-tree/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2023/01/11-print-aria-roles-dom-tree.png" data-orig-size="730,372" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="print-aria-roles-dom-tree" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2023/01/11-print-aria-roles-dom-tree-300x153.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2023/01/11-print-aria-roles-dom-tree.png" decoding="async" class="aligncenter wp-image-156318 size-full jetpack-lazy-image" src="../Images/00f1deafb621a7d33260705ece9e8628.png" alt="Print Aria Roles Dom Tree" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2023/01/11-print-aria-roles-dom-tree.png 730w, https://blog.logrocket.com/wp-content/uploads/2023/01/11-print-aria-roles-dom-tree-300x153.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2023/01/11-print-aria-roles-dom-tree.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2023/01/11-print-aria-roles-dom-tree.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="156318" data-permalink="https://blog.logrocket.com/11-print-aria-roles-dom-tree/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2023/01/11-print-aria-roles-dom-tree.png" data-orig-size="730,372" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="print-aria-roles-dom-tree" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2023/01/11-print-aria-roles-dom-tree-300x153.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2023/01/11-print-aria-roles-dom-tree.png" decoding="async" loading="lazy" class="aligncenter wp-image-156318 size-full" src="../Images/00f1deafb621a7d33260705ece9e8628.png" alt="Print Aria Roles Dom Tree" srcset="https://blog.logrocket.com/wp-content/uploads/2023/01/11-print-aria-roles-dom-tree.png 730w, https://blog.logrocket.com/wp-content/uploads/2023/01/11-print-aria-roles-dom-tree-300x153.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2023/01/11-print-aria-roles-dom-tree.png"/></noscript>
<p>如上所示，输出包含DOM元素及其各自的ARIA角色。我们可以通过这些元素的隐含角色来定位它们。例如，如果我们想要断言一个<code>li</code>项在DOM中可见，我们可以编写下面的测试:</p>
<pre class="language-javascript hljs">test('should list item visible in the DOM', async () =&gt; {
  render(&lt;Posts /&gt;);
  const postItemNode = await screen.findByRole('listitem');
  expect(postItemNode).toBeVisible();
});
</pre>
<h2 id="debugging-log-testing-playground-url-method">用<code>logTestingPlaygroundURL()</code>方法调试</h2>
<p><code>screen</code>对象还公开了<code>logTestingPlaygroundURL()</code>方法，这进一步简化了调试测试。当我们在测试代码中使用这个方法时，RTL在编辑器终端<a href="https://testing-playground.com/">中返回一个链接，指向一个测试平台</a>。</p>
<p>如果您知道testing playground是如何工作的，我们可以粘贴使用<code>debug()</code>方法打印的DOM树，以找到对目标元素的最佳查询。例如，让我们重温一下我们的第一个示例测试。正如我们所知，使用<code>debug()</code>方法将打印DOM树:</p>
<pre class="language-javascript hljs">test('should display heading text', () =&gt; {
  render(&lt;Header /&gt;);
  screen.debug();
});
</pre>
<p>打印后，DOM树应该如下所示:</p>
<pre class="language-javascript hljs">&lt;div&gt;
  &lt;h1&gt;
    Fetch asynchronous posts
  &lt;/h1&gt;
&lt;/div&gt;
</pre>
<p>记住，在示例中，我们以标题节点为目标，并使用<code>screen.getByText()</code>方法进行断言，如下所示:</p>
<pre class="language-javascript hljs">test('should display heading text', () =&gt; {
  render(&lt;Header /&gt;);
  const headingText = screen.getByText('Fetch asynchronous posts');
  expect(headingText).toBeInTheDocument();
});
</pre>
<p>虽然这是可行的，但是正如我们在<code>logRoles</code>部分中提到的，我们应该考虑在其他查询类型之前使用可访问的查询。对于不确定最适合使用的查询方法的初学者来说，playground可以提供帮助。</p>
<p>如果我们将DOM元素复制到testing playground(标签1)，我们可以在视图中选择元素(标签2)。然后，我们将看到一个建议的查询，标签为3，我们可以将它复制到我们的测试中:</p>
<p><img data-attachment-id="156321" data-permalink="https://blog.logrocket.com/12-copy-dom-elements-testing-playground/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2023/01/12-copy-dom-elements-testing-playground-.png" data-orig-size="730,453" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="copy-dom-elements-testing-playground" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2023/01/12-copy-dom-elements-testing-playground--300x186.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2023/01/12-copy-dom-elements-testing-playground-.png" decoding="async" class="aligncenter wp-image-156321 size-full jetpack-lazy-image" src="../Images/518ef2e8b716e02cc5449d83c53ce405.png" alt="Copy Dom Elements Testing Playground" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2023/01/12-copy-dom-elements-testing-playground-.png 730w, https://blog.logrocket.com/wp-content/uploads/2023/01/12-copy-dom-elements-testing-playground--300x186.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2023/01/12-copy-dom-elements-testing-playground-.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2023/01/12-copy-dom-elements-testing-playground-.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="156321" data-permalink="https://blog.logrocket.com/12-copy-dom-elements-testing-playground/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2023/01/12-copy-dom-elements-testing-playground-.png" data-orig-size="730,453" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="copy-dom-elements-testing-playground" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2023/01/12-copy-dom-elements-testing-playground--300x186.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2023/01/12-copy-dom-elements-testing-playground-.png" decoding="async" loading="lazy" class="aligncenter wp-image-156321 size-full" src="../Images/518ef2e8b716e02cc5449d83c53ce405.png" alt="Copy Dom Elements Testing Playground" srcset="https://blog.logrocket.com/wp-content/uploads/2023/01/12-copy-dom-elements-testing-playground-.png 730w, https://blog.logrocket.com/wp-content/uploads/2023/01/12-copy-dom-elements-testing-playground--300x186.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2023/01/12-copy-dom-elements-testing-playground-.png"/></noscript>
<p>现在，有了这个查询，一个更容易访问的测试将看起来像下面的代码:</p>
<pre class="language-javascript hljs">test('should display heading text', () =&gt; {
  render(&lt;Header /&gt;);
  const headingText = screen.getByRole('heading', {
    name: /fetch asynchronous posts/i,
  });
  expect(headingText).toBeInTheDocument();
});
</pre>
<p>记住这个操场，让我们在测试块中使用<code>screen.logTestingPlaygroundURL()</code>,如下所示:</p>
<pre class="language-javascript hljs">test('should display heading text', () =&gt; {
  render(&lt;Header /&gt;);
  screen.logTestingPlaygroundURL();
});
</pre>
<p>然后，在我们运行测试之后，RTL将生成一个到操场的链接:</p>
<p><img data-attachment-id="156325" data-permalink="https://blog.logrocket.com/13-rtl-generate-playground-link-2/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2023/01/13-RTL-generate-playground-link-1.png" data-orig-size="730,125" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="RTL-generate-playground-link" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2023/01/13-RTL-generate-playground-link-1-300x51.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2023/01/13-RTL-generate-playground-link-1.png" decoding="async" class="aligncenter wp-image-156325 size-full jetpack-lazy-image" src="../Images/ba210f8650c414c8c882d17d1b1679c8.png" alt="RTL Generate Playground Link" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2023/01/13-RTL-generate-playground-link-1.png 730w, https://blog.logrocket.com/wp-content/uploads/2023/01/13-RTL-generate-playground-link-1-300x51.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2023/01/13-RTL-generate-playground-link-1.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2023/01/13-RTL-generate-playground-link-1.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="156325" data-permalink="https://blog.logrocket.com/13-rtl-generate-playground-link-2/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2023/01/13-RTL-generate-playground-link-1.png" data-orig-size="730,125" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="RTL-generate-playground-link" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2023/01/13-RTL-generate-playground-link-1-300x51.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2023/01/13-RTL-generate-playground-link-1.png" decoding="async" loading="lazy" class="aligncenter wp-image-156325 size-full" src="../Images/ba210f8650c414c8c882d17d1b1679c8.png" alt="RTL Generate Playground Link" srcset="https://blog.logrocket.com/wp-content/uploads/2023/01/13-RTL-generate-playground-link-1.png 730w, https://blog.logrocket.com/wp-content/uploads/2023/01/13-RTL-generate-playground-link-1-300x51.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2023/01/13-RTL-generate-playground-link-1.png"/></noscript>
<p>如果我们访问这个链接，我们将得到与上面显示的操场UI相当的东西。因此，我们不必使用<code>debug()</code>方法将DOM树打印并复制到操场中。相反，它会自动添加。</p>
<p>在没有<code>debug()</code>方法的情况下，通过<code>screen.logTestingPlaygroundURL()</code>方法查看操场让我们一眼就能看出哪些元素对用户是可见的。它还建议了针对元素的最合适的查询方法。</p>
<h2 id="conclusion">结论</h2>
<p>如果你刚刚开始使用，测试可能会很麻烦。然而，调试的能力可以使这个过程变得轻而易举。</p>
<p>在本文中，我们讨论了如何使用React测试库中的<code>debug()</code>方法来识别和分析测试错误。我们还学习了如何使用<code>logTestingPlaygroundURL()</code>方法来进一步简化调试过程。如果你喜欢这一课，一定要留下评论。编码快乐！</p><div class="code-block code-block-17">
<div class="blog-plug inline-plug react-plug" vwo-el-id="26283398190">
<h2 vwo-el-id="41600691720"><a href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener"> LogRocket </a>:全面了解您的生产React应用</h2><p>调试React应用程序可能很困难，尤其是当用户遇到难以重现的问题时。如果您对监视和跟踪Redux状态、自动显示JavaScript错误以及跟踪缓慢的网络请求和组件加载时间感兴趣，</p><a href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" vwo-el-id="19356441070">try LogRocket</a><p>. </p><a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="19356441380">
<img class="first-react-image alignnone size-full wp-image-46 jetpack-lazy-image jetpack-lazy-image--handled" src="../Images/f300c244a1a1cf916df8b4cb02bec6c6.png" vwo-el-id="18272717540" data-lazy-loaded="1" data-original-src="https://files.readme.io/27c94e7-Image_2017-06-05_at_9.46.04_PM.png"/>
</a>
<a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="19356441690">
<img class="second-react-image alignnone size-full wp-image-46 jetpack-lazy-image jetpack-lazy-image--handled" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" vwo-el-id="30720362350" data-lazy-loaded="1" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/>
</a>
<p vwo-el-id="28675660440" class="">LogRocket 结合了会话回放、产品分析和错误跟踪，使软件团队能够创建理想的web和移动产品体验。这对你来说意味着什么？</p>
<p>LogRocket不是猜测错误发生的原因，也不是要求用户提供截图和日志转储，而是让您回放问题，就像它们发生在您自己的浏览器中一样，以快速了解哪里出错了。</p>
<p>不再有嘈杂的警报。智能错误跟踪允许您对问题进行分类，然后从中学习。获得有影响的用户问题的通知，而不是误报。警报越少，有用的信号越多。</p>
<p vwo-el-id="28675660750">LogRocket Redux中间件包为您的用户会话增加了一层额外的可见性。LogRocket记录Redux存储中的所有操作和状态。</p>
<p vwo-el-id="28675661060">现代化您调试React应用的方式— <a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="40093418840">开始免费监控</a>。</p>
</div></div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
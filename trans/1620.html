<html>
<head>
<title>Intro to ForgoJS, an ultra-lightweight UI runtime - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>介绍 ForgoJS，一个超轻量 UI 运行时日志博客</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/forgo-js-ultra-lightweight-ui-runtime/#0001-01-01">https://blog.logrocket.com/forgo-js-ultra-lightweight-ui-runtime/#0001-01-01</a></blockquote><div><article class="article-post">
<h2>介绍</h2>
<p>Forgo 是一个用于创建 web 应用程序的轻量级(4KB) JavaScript 库。尽管它被宣传为 React 的替代方案，甚至使用了 JSX 语法，但在使用 Forgo 时，有几个主要的区别需要记住。</p>
<p>在本文中，我们将看看如何使用<a href="https://forgojs.org/"> Forgo 库</a>创建客户端 web 应用程序，同时，我们将看看 Forgo 和 React 之间的区别。</p>
<h2>用 Forgo 创建演示组件</h2>
<p>首先，我们应该通过运行以下命令来全局安装 webpack 和 webpack-cli:</p>
<pre>npm i -g webpack webpack-cli
</pre>
<p>然后，我们使用以下命令将 JavaScript repo 克隆到我们的计算机中:</p>
<pre>npx degit forgojs/forgo-template-javascript#main my-project
</pre>
<p>一旦我们完成了，我们应该跳转到我们的<code>my-project</code>文件夹并运行<code>npm i</code>来安装<code>package.json</code>中列出的包。<code>npm start</code>将运行我们刚刚克隆的项目。</p>
<p>默认情况下，项目在端口 8080 上运行。我们可以通过添加<code>-- --port=8888</code>选项来更改运行项目的端口，如下所示:</p>
<pre>npm start -- --port=8888</pre>
<p>我们克隆的项目带有 JSX 解析器和其他构建工具，所以我们不必担心项目的工具。</p>
<p>现在我们可以通过在<code>index.js</code>中编写以下代码来创建一个简单的组件:</p>
<pre>import { mount, rerender } from "forgo";

function Timer() {
  let seconds = 0;

  return {
    render(props, args) {
      setTimeout(() =&gt; {
        seconds++;
        rerender(args.element);
      }, 1000);

      return &lt;div&gt;{seconds}&lt;/div&gt;;
    },
  };
}
</pre>
<p>我们用<code>args.element</code>调用<code>rerender</code>来重新渲染一个组件。与 React 不同，状态存储在常规变量中，而不是状态中，我们在<code>return</code>语句中呈现<code>seconds</code>。</p>
<h3>安装组件</h3>
<p>要安装组件，我们需要添加:</p>
<pre>window.addEventListener("load", () =&gt; {
  mount(&lt;Timer /&gt;, document.getElementById("root"));
});
</pre>
<p>因此，加上我们刚刚写给<code>index.js</code>的样本组件，我们有:</p>
<pre>import { mount, rerender } from "forgo";

function Timer() {
  let seconds = 0;

  return {
    render(props, args) {
      setTimeout(() =&gt; {
        seconds++;
        rerender(args.element);
      }, 1000);

      return &lt;div&gt;{seconds}&lt;/div&gt;;
    },
  };
}

window.addEventListener("load", () =&gt; {
  mount(&lt;Timer /&gt;, document.getElementById("root"));
});
</pre>
<p>我们可以用元素选择器替换<code>document.getElementById</code>，这样我们可以写:</p>
<pre>window.addEventListener("load", () =&gt; {
  mount(&lt;Timer /&gt;, "#root");
});
</pre>
<h2>子组件和道具</h2>
<p>与 React 一样，我们可以创建子组件并向它们传递道具。为此，我们写道:</p>
<pre>import { mount } from "forgo";

function Parent() {
  return {
    render() {
      return (
        &lt;div&gt;
          &lt;Greeter name="james" /&gt;
          &lt;Greeter name="mary" /&gt;
        &lt;/div&gt;
      );
    },
  };
}

function Greeter({ name }) {
  return {
    render(props, args) {
      return &lt;div&gt;hi {name}&lt;/div&gt;;
    },
  };
}

window.addEventListener("load", () =&gt; {
  mount(&lt;Parent /&gt;, document.getElementById("root"));
});
</pre>
<p><code>Greeter</code>组件是<code>Parent</code>组件的子组件。<code>Greeter</code>接受<code>name</code>道具，我们在<code>return</code>语句中添加该道具来呈现其值。</p>
<p>我们也可以很容易地用 Forgo 添加输入。为此，我们应该写:</p>
<pre>import { mount } from "forgo";

function Input() {
  const inputRef = {};

  return {
    render() {
      function onClick() {
        const inputElement = inputRef.value;
        alert(inputElement.value);
      }

      return (
        &lt;div&gt;
          &lt;input type="text" ref={inputRef} /&gt;
          &lt;button onclick={onClick}&gt;get value&lt;/button&gt;
        &lt;/div&gt;
      );
    },
  };
}

window.addEventListener("load", () =&gt; {
  mount(&lt;Input /&gt;, document.getElementById("root"));
});
</pre>
<p>我们创建一个名为<code>inputRef</code>的对象变量，并将其传递给 input 元素的<code>ref</code>属性。然后，我们获得具有<code>inputRef.value</code>属性的输入元素对象，就像我们在<code>onClick</code>方法中所做的那样。现在我们可以通过获取<code>value</code>属性来获取输入值。</p>
<h2>列表和键</h2>
<p>与 React 类似，我们可以通过调用数组上的<code>map</code>来呈现列表，然后返回我们想要呈现的组件。例如，我们可以写:</p>
<pre>import { mount } from "forgo";

function App() {
  return {
    render() {
      const people = [
        { name: "james", id: 1 },
        { name: "mary", id: 2 },
      ];
      return (
        &lt;div&gt;
          {people.map(({ key, name }) =&gt; (
            &lt;Child key={key} name={name} /&amp;gt;
          ))}
        &lt;/div&gt;
      );
    },
  };
}

function Child() {
  return {
    render({ name }) {
      return &lt;div&gt;hi {name}&lt;/div&gt;;
    },
  };
}

window.addEventListener("load", () =&gt; {
  mount(&lt;App /&gt;, document.getElementById("root"));
});
</pre>
<p>我们有一个带有数组<code>people</code>的<code>App</code>组件。我们可以通过调用<code>map</code>，然后返回带有<code>key</code>和<code>name</code>道具的<code>Child</code>组件，在浏览器中呈现数组。</p>
<p>属性允许 Forgo 通过分配一个唯一的 ID 来区分渲染的项目。<code>name</code>是我们在<code>Child</code>组件中得到并渲染的常规道具。</p>
<h2>在 Forgo 中提取数据</h2>
<p>我们可以通过承诺获取数据，就像我们对 React 组件所做的那样。然而，我们只能使用<code>then</code>方法来获取数据——没有 async/await。如果我们使用<code>async</code>和<code>await</code>，我们会得到一个<code>regeneratorRuntime not defined</code>错误。</p>
<p>因此，为了在组件挂载时获取数据，我们可以编写如下代码:</p>
<pre>import { mount, rerender } from "forgo";

function App() {
  let data;

  return {
    render(_, args) {
      if (!data) {
        fetch('https://yesno.wtf/api')
          .then(res =&gt; res.json())
          .then(d =&gt; {
            data = d;
            rerender(args.element);
          })
        return &lt;p&gt;loading&lt;/p&gt;
      }
      return &lt;div&gt;{JSON.stringify(data)}&lt;/div&gt;
    },
  };
}

window.addEventListener("load", () =&gt; {
  mount(&lt;App /&gt;, document.getElementById("root"));
});
</pre>
<p><code>data</code>最初没有值，在这种情况下，我们调用<code>fetch</code>对一些数据发出 GET 请求。然后，我们将<code>d</code>参数赋给<code>data</code>，它有响应数据。</p>
<p>我们用<code>args.element</code>调用<code>rerender</code>在<code>data</code>更新后重新渲染组件，在下一个渲染周期，渲染字符串化的<code>data</code>值。现在我们应该能够看到从 API 中检索到的数据。</p>
<h2>事件和错误</h2>
<p>Forgo 组件在其呈现生命周期中发出各种事件。让我们以下面的组件为例:</p>
<pre>import { mount } from "forgo";

function App() {
  return {
    render(props, args) {
      return &lt;div id='hello'&gt;Hello&lt;/div&gt;;
    },
    mount(props, args) {
      console.log(`mounted on node with id ${args.element.node.id}`);
    },
    unmount(props, args) {
      console.log("unmounted");
    },
  };
}

window.addEventListener("load", () =&gt; {
  mount(&lt;App /&gt;, document.getElementById("root"));
});
</pre>
<p>我们的<code>render</code>方法返回一个 ID 为<code>hello</code>的 div，当组件挂载时，我们调用<code>mount</code>方法。<code>args.element.node.id</code>接受根元素的<code>id</code>属性的值，所以它的值应该是<code>'hello'</code>。</p>
<p>因此，我们应该看到<code>'mounted on node with id hello'</code>被记录。<code>unmount</code>方法在组件卸载时运行，所以当组件从 DOM 中移除时，我们应该会看到<code>'unmounted'</code>。</p>
<p>例如，假设我们有:</p>
<pre>import { mount, rerender } from "forgo";

function App() {
  let showChild = false

  return {
    render(props, args) {
      const onClick = () =&gt; {
        showChild = !showChild
        rerender(args.element)
      }

      return (
        &lt;div&gt;
          &lt;button onclick={onClick}&gt;toggle&lt;/button&gt;
          {showChild ? &lt;Child /&gt; : undefined}
        &lt;/div&gt;
      );
    },
  };
}

function Child() {
  return {
    render(props, args) {
      return &lt;div&gt;child&lt;/div&gt;;
    },
    unmount(props, args) {
      console.log("unmounted");
    },
  };
}

window.addEventListener("load", () =&gt; {
  mount(&lt;App /&gt;, document.getElementById("root"));
});
</pre>
<p>当我们点击<strong>切换</strong>按钮时，<code>Child</code>组件会消失，我们应该会看到<code>'unmounted'</code>。</p>
<p>我们还可以通过使用<code>shouldUpdate</code>函数手动调用<code>rerender</code>来选择何时重新渲染组件。<code>shouldUpdate</code>有参数<code>newProps</code>和<code>oldProps</code>，顾名思义，它们分别给出了道具的当前值和旧值。</p>
<p>考虑下面的例子:</p>
<pre>import { mount, rerender } from "forgo";

function App() {
  let name = 'james'

  return {
    render(props, args) {
      const onClick = () =&gt; {
        name = name === 'james' ? 'jane' : 'james'
        rerender(args.element)
      }

      return (
        &lt;div&gt;
          &lt;button onclick={onClick}&gt;toggle&lt;/button&gt;
          &lt;Greeter name={name} /&gt;
        &lt;/div&gt;
      );
    },
  };
}

function Greeter() {
  return {
    render({ name }, args) {
      return &lt;div&gt;hi {name}&lt;/div&gt;;
    },
    shouldUpdate(newProps, oldProps) {
      console.log(newProps, oldProps)
      return newProps.name !== oldProps.name;
    },
  };
}

window.addEventListener("load", () =&gt; {
  mount(&lt;App /&gt;, document.getElementById("root"));
});
</pre>
<p><strong>切换</strong>按钮切换<code>name</code>的值，我们将它作为<code>Greeter</code>的<code>name</code>道具的值传入。因此，每当我们点击<strong>切换</strong>按钮，我们将看到控制台日志更新。</p>
<p>最后，我们可以用<code>error</code>方法处理返回的对象中的错误。子组件的错误会上升到父组件。</p>
<p>所以，如果我们有:</p>
<pre>import { mount } from "forgo";

function App() {
  return {
    render() {
      return (
        &lt;div&gt;
          &lt;BadComponent /&gt;
        &lt;/div&gt;
      );
    },
    error(props, args) {
      return (
        &lt;p&gt;
          {args.error.message}
        &lt;/p&gt;
      );
    },
  };
}

function BadComponent() {
  return {
    render() {
      throw new Error("error");
    },
  };
}
window.addEventListener("load", () =&gt; {
  mount(&lt;App /&gt;, document.getElementById("root"));
});
</pre>
<p><code>args.error.message</code>应该有我们传递给<code>Error</code>构造函数的字符串，因为错误会从子组件传播到父组件。</p>
<h2>结论</h2>
<p>Forgo 只有 4KB，是 React 的一个很小的替代品，它允许我们轻松地创建简单的组件。因为它使用 JSX 语法，所以 React 开发人员应该对它很熟悉。</p>
<p>然而，在行为上有一些主要的不同。必须用<code>rerender</code>方法手动重新渲染。<a href="https://blog.logrocket.com/react-lifecycle-methods-tutorial-examples/">组件生命周期</a>也大不相同，状态存储为普通变量而不是状态。也没有挂钩；相反，我们使用生命周期方法在组件的生命周期中执行各种操作。</p>
<p>开始 Forgo yourself 的最简单方法是全局安装 webpack dev 依赖项，然后用<code>degit</code>克隆 starter 项目。</p><div class="code-block code-block-28">
<div class="blog-plug inline-plug js-libraries-plug"><h2>您是否添加了新的 JS 库来提高性能或构建新特性？如果他们反其道而行之呢？</h2><p>毫无疑问，前端变得越来越复杂。当您向应用程序添加新的 JavaScript 库和其他依赖项时，您将需要更多的可见性，以确保您的用户不会遇到未知的问题。</p>
<p>LogRocket 是一个前端应用程序监控解决方案，可以让您回放 JavaScript 错误，就像它们发生在您自己的浏览器中一样，这样您就可以更有效地对错误做出反应。</p><a class="signup" href="https://lp.logrocket.com/blg/javascript-signup" target="_blank" rel="noopener noreferrer"><img class="alignnone size-full wp-image-46 jetpack-lazy-image" src="../Images/e8a0ab42befa3b3b1ae08c1439527dc6.png" alt="LogRocket Dashboard Free Trial Banner" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2019/10/errors-screenshot.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/10/errors-screenshot.png"/><noscript><img data-lazy-fallback="1" class="alignnone size-full wp-image-46" src="../Images/e8a0ab42befa3b3b1ae08c1439527dc6.png" alt="LogRocket Dashboard Free Trial Banner" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/10/errors-screenshot.png"/></noscript></a>
<a href="https://lp.logrocket.com/blg/javascript-signup" target="_blank" rel="noopener noreferrer">https://logrocket.com/signup/</a><p><a href="https://lp.logrocket.com/blg/javascript-signup" target="_blank" rel="noopener noreferrer"> LogRocket </a>可以与任何应用程序完美配合，不管是什么框架，并且有插件可以记录来自 Redux、Vuex 和@ngrx/store 的额外上下文。您可以汇总并报告问题发生时应用程序的状态，而不是猜测问题发生的原因。LogRocket 还可以监控应用的性能，报告客户端 CPU 负载、客户端内存使用等指标。</p><p>自信地构建— <a class="signup" href="https://lp.logrocket.com/blg/javascript-signup" target="_blank" rel="noopener noreferrer">开始免费监控</a>。</p></div>


</div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
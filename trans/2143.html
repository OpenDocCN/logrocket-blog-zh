<html>
<head>
<title>Manage notifications in React Native with react-native-notifications - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>使用 React-Native-notifications-log rocket 博客管理 React Native 中的通知</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/manage-notifications-react-native-notifications/#0001-01-01">https://blog.logrocket.com/manage-notifications-react-native-notifications/#0001-01-01</a></blockquote><div><article class="article-post">
<p>通知在我们的应用程序中扮演着重要的角色。他们是推动用户参与我们应用的主要来源。通常，公司会通知用户新收到的消息，例如，钱包应用程序中的通知会通知用户即将支付的账单。</p>
<p>我们可以在应用中实现多种类型的通知，例如远程和本地通知、交互式通知和静默通知。在本文中，我们将介绍如何使用<a href="https://github.com/wix/react-native-notifications" target="_blank" rel="noopener">react-native-notifications</a>实现这些类型的通知。</p>
<h2>什么是反应本地通知？</h2>
<p>React-native-notifications 是由<a href="https://www.wix.com/" target="_blank" rel="noopener"> Wix </a>开发的开源产品，可以帮助开发者在 React 原生应用中轻松实现通知。根据<a href="https://wix.github.io/react-native-notifications/docs/installation-ios" target="_blank" rel="noopener">文档</a>，你可能会将其与 iOS 10 和 Android 5 (API 21)集成。它也可以在 Windows、macOS 和 Linux 操作系统上编译。</p>
<p>在撰写本文时，该库支持:</p>
<ul>
<li>远程通知</li>
<li>本地通知</li>
<li>服务器管理的通知</li>
<li>交互式通知</li>
</ul>
<h2>安装 react-native-通知</h2>
<p>让我们从安装库开始。本指南假设您正在运行 React Native v10.x。</p>
<p>使用 npm:</p>
<pre>npm install --save react-native-notifications
</pre>
<p>带纱线:</p>
<pre>yarn add react-native-notifications
</pre>
<p>现在，我们需要对本机文件进行一些更改，以使用 react-native-notifications。</p>
<h3>将 react-native-notifications 与 iOS 链接</h3>
<h4>如果没有安装<code>cocoapods</code></h4>
<p>用<code>cocoapods</code>反应原生作品。如果您的计算机上没有安装，请运行以下命令:</p>
<pre>sudo gem install cocoapods
</pre>
<p>现在使用<code>cd</code>移动到您的项目目录。</p>
<h4>如果在安装 react-native-notifications 之前安装了<code>cocoapods</code></h4>
<p>是时候将<code>cocoapods</code>安装到项目的<code>iOS</code>目录中了。当我们安装 react-native-notification 库时，它会自动将 pod 添加到<code>Podfile</code>中。所以，我们只需要运行这个命令:</p>
<pre>pod install --project-directory=ios/</pre>
<h4>如果<code>cocoapods</code>是后来安装的并且<code>react-native-notifications</code>没有将吊舱添加到<code>Podfile</code></h4>
<p>如果您刚刚安装了<code>cocoapods</code>或者<code>Podfile</code>中没有添加所需的<code>pod</code>，那么您可以手动添加:</p>
<p>打开<code>./ios/Podfile</code>(假设您在项目目录中)并将其添加到窗格列表中:</p>
<pre>pod 'react-native-notifications', :podspec =&gt; '../node_modules/react-native-notifications/react-native-notifications.podspec'
</pre>
<p>现在运行这个:</p>
<pre>cd iOS &amp;&amp; pod install
</pre>
<p>下一步，我们将在<code>AppDelegate.m</code>文件中做一些修改。打开<code>./ios/{project_name}/AppDelegate.m</code>文件并完成以下步骤。</p>
<ol>
<li>将这一行添加到文件的顶部:<pre>#import "RNNotifications.h"</pre></li>
<li>从下面的代码片段开始【T0:<pre>- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions {     [RNNotifications startMonitorNotifications]; // -&gt; Add this line      return YES; }</pre></li>
<li>增加以下功能支持注册:<pre>- (void)application:(UIApplication *)application didRegisterForRemoteNotificationsWithDeviceToken:(NSData *)deviceToken {   [RNNotifications didRegisterForRemoteNotificationsWithDeviceToken:deviceToken]; }  - (void)application:(UIApplication *)application didFailToRegisterForRemoteNotificationsWithError:(NSError *)error {   [RNNotifications didFailToRegisterForRemoteNotificationsWithError:error]; }</pre></li>
</ol>
<h3>将 react-native-notifications 与 Android 链接</h3>
<p>首先打开<code>MainApplication.java</code>并将其添加到库中:</p>
<pre>import com.wix.reactnativenotifications.RNNotificationsPackage;
</pre>
<p>在 Android 上，推送通知由<a href="https://firebase.google.com/docs/cloud-messaging" target="_blank" rel="noopener">Google Firebase Cloud Messaging(FCM)</a>管理，所以你需要继续使用它。如果你以前没有在你的项目中使用过 Firebase，那么就按照<a href="https://firebase.google.com/docs/cloud-messaging/android/client" target="_blank" rel="noopener">设置指南</a>中提供的步骤操作。</p>
<p>我们需要在<code>./android/settings.gradle</code>文件中链接 react-native-notifications，就像这样:</p>
<pre>include ':react-native-notifications'
project(':react-native-notifications').projectDir = new File(rootProject.projectDir, '../node_modules/react-native-notifications/lib/android/app')
</pre>
<p>如果你愿意，你可以为 Android 中的通知设置一些默认设置，比如默认图标，文本颜色等。，要显示。如果我们在发送通知时不提供特定设置，将使用这些设置。</p>
<p>接下来，打开<code>AndroidManifest.xml</code>并添加以下代码:</p>
<pre>&lt;!-- Set custom default icon. This is used when no icon is set for incoming notification messages. --&gt;
&lt;meta-data
        android:name="com.google.firebase.messaging.default_notification_icon"
        android:resource="@drawable/notification_icon" /&gt;
&lt;!-- Set color used with incoming notification messages. This is used when no color is set for the incoming notification message. --&gt;
&lt;meta-data
        android:name="com.google.firebase.messaging.default_notification_color"
        android:resource="@color/colorAccent" /&gt;
</pre>
<p>这里，我们设置了一个默认的通知图标，它存储在一个可绘制的文件夹中。请注意，图标名称应该是<code>notification_icon</code>。我们还设置了一个默认的文本颜色，我们将把它添加到<code>colors.xml</code>文件中。</p>
<pre>&lt;resources&gt;
    &lt;color name="colorAccent"&gt;#C60C30&lt;/color&gt;
&lt;/resources&gt;
</pre>
<h2>在 React Native 中实现推送通知</h2>
<p>首先，我们需要了解推送通知是如何工作的。每个设备都有唯一的设备 ID。要发送通知，我们需要此 ID。让我们一步步回顾一下如何实现推送通知。</p>
<ol>
<li>将设备注册到供应商的服务器(例如 FCM)或在 iOS 中获得权限</li>
<li>获取刷新令牌并存储在通知服务器中，如<a href="https://aws.amazon.com/sns/" target="_blank" rel="noopener">亚马逊 SNS </a></li>
<li>使用存储的令牌发送通知</li>
</ol>
<h3>获得许可并注册设备</h3>
<p>在 iOS 中，我们需要获得用户的许可才能显示通知。</p>
<figure id="attachment_66104" aria-describedby="caption-attachment-66104" class="wp-caption aligncenter"><img data-attachment-id="66104" data-permalink="https://blog.logrocket.com/manage-notifications-react-native-notifications/notifications-prompt/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2021/09/notifications-prompt.png" data-orig-size="471,335" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Notifications prompt" data-image-description="&lt;p&gt;ddd&lt;/p&gt;&#10;" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2021/09/notifications-prompt-300x213.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2021/09/notifications-prompt.png" decoding="async" class="wp-image-66104 size-full jetpack-lazy-image" src="../Images/7046e46602cff3aea464dfd25f986175.png" alt="Notifications Prompt" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2021/09/notifications-prompt.png 471w, https://blog.logrocket.com/wp-content/uploads/2021/09/notifications-prompt-300x213.png 300w" data-lazy-sizes="(max-width: 471px) 100vw, 471px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2021/09/notifications-prompt.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2021/09/notifications-prompt.png"/><noscript><img data-lazy-fallback="1" data-attachment-id="66104" data-permalink="https://blog.logrocket.com/manage-notifications-react-native-notifications/notifications-prompt/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2021/09/notifications-prompt.png" data-orig-size="471,335" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Notifications prompt" data-image-description="&lt;p&gt;ddd&lt;/p&gt;&#10;" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2021/09/notifications-prompt-300x213.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2021/09/notifications-prompt.png" decoding="async" loading="lazy" class="wp-image-66104 size-full" src="../Images/7046e46602cff3aea464dfd25f986175.png" alt="Notifications Prompt" srcset="https://blog.logrocket.com/wp-content/uploads/2021/09/notifications-prompt.png 471w, https://blog.logrocket.com/wp-content/uploads/2021/09/notifications-prompt-300x213.png 300w" sizes="(max-width: 471px) 100vw, 471px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2021/09/notifications-prompt.png"/></noscript><figcaption id="caption-attachment-66104" class="wp-caption-text">Source: <a href="https://developer.apple.com/documentation/usernotifications/asking_permission_to_use_notifications" target="_blank" rel="noopener">Apple.com</a></figcaption></figure>
<p>在 Android 上，我们在 FCM 上注册设备并获得刷新令牌。</p>
<p>这是通过调用<code>remoteNotificationsRegistered()</code>函数来完成的。它适用于两个平台。</p>
<pre>import { Notifications } from 'react-native-notifications';

class App extends Component {
    constructor() {
        // Request permissions on iOS, refresh token on Android
        Notifications.registerRemoteNotifications();

        Notifications.events().registerRemoteNotificationsRegistered((event: Registered) =&gt; {
            // TO-DO: Send the token to my server so it could send back push notifications...
            console.log("Device Token Received", event.deviceToken);
        });
        Notifications.events().registerRemoteNotificationsRegistrationFailed((event: RegistrationError) =&gt; {
            console.error(event);
        });
    }
}
</pre>
<p>首先，我们在<code>App.js</code>中导入 react-native-notifications 库。在构造函数中，我们调用<code>registerRemoteNotifications()</code>，它会在 iOS 上显示权限对话框，在 Android 上的 FCM 上注册 app。</p>
<p>根据该函数的成功情况，将调用<code>registerRemoteNotificationsRegistered()</code>函数或<code>registerRemoteNotificationsRegistrationFailed()</code>函数。</p>
<p>如果失败，则不允许您发送通知。您可以稍后再次尝试权限，并希望成功。</p>
<p>如果成功，那么<code>registerRemoteNotificationsRegistered()</code>将提供<code>deviceToken</code>，我们需要将它发送到后端并向通知服务注册。</p>
<p>下面介绍如何检查用户在 iOS 上授予了哪些权限。</p>
<pre>Notifications.ios.checkPermissions().then((currentPermissions) =&gt; {
    console.log('Badges enabled: ' + !!currentPermissions.badge);
    console.log('Sounds enabled: ' + !!currentPermissions.sound);
    console.log('Alerts enabled: ' + !!currentPermissions.alert);
    console.log('Car Play enabled: ' + !!currentPermissions.carPlay);
    console.log('Critical Alerts enabled: ' + !!currentPermissions.criticalAlert);
    console.log('Provisional enabled: ' + !!currentPermissions.provisional);
    console.log('Provides App Notification Settings enabled: ' + !!currentPermissions.providesAppNotificationSettings);
    console.log('Announcement enabled: ' + !!currentPermissions.announcement);
});</pre>
<h3>在 React Native 中处理收到的通知</h3>
<p>从您的服务器，您可以使用刷新令牌发送通知。现在是时候在你的应用程序中处理它们了，但我们如何做取决于应用程序是在前台还是后台。</p><div class="code-block code-block-54">
<hr/>
<h3>更多来自 LogRocket 的精彩文章:</h3>

<hr/></div>
<p>当应用程序在前台时——意味着它是活动的并被用户使用——触发<code>notificationReceivedForeground()</code>事件。同样，如果应用程序在后台运行，将触发<code>notificationReceivedBackground()</code>事件。</p>
<p>下面是应用程序是否在前台运行的代码块:</p>
<pre>Notifications.events().registerNotificationReceivedForeground((notification: Notification, completion: (response: NotificationCompletion) =&gt; void) =&gt; {
      console.log("Notification Received - Foreground", notification.payload);

      // Calling completion on iOS with `alert: true` will present the native iOS inApp notification.
      completion({alert: true, sound: true, badge: false});
        });
</pre>
<p>重要的是调用<code>completion</code>回调来表明该过程已经完成。</p>
<p>如果应用程序在后台，下面是代码。</p>
<pre>Notifications.events().registerNotificationReceivedBackground((notification: Notification, completion: (response: NotificationCompletion) =&gt; void) =&gt; {
      console.log("Notification Received - Background", notification.payload);

      // Calling completion on iOS with `alert: true` will present the native iOS inApp notification.
      completion({alert: true, sound: true, badge: false});
        });
</pre>
<p>如果一个通知在用户点击时被打开，一个<code>notificationOpened</code>事件将被触发。</p>
<pre>Notifications.events().registerNotificationOpened((notification: Notification, completion: () =&gt; void, action: NotificationActionResponse) =&gt; {
      console.log("Notification opened by device user", notification.payload);
      console.log(`Notification opened with an action identifier: ${action.identifier} and response text: ${action.text}`);
      completion();
        });
</pre>
<p>在<code>notification.payload</code>中接收的数据是:</p>
<ul>
<li><code>identifier</code></li>
<li><code>title</code></li>
<li><code>subtitle</code></li>
<li><code>body</code></li>
<li><code>sound</code></li>
<li><code>badge</code></li>
<li><code>category</code></li>
<li><code>payload</code></li>
</ul>
<h2>从 React 本机应用程序发送本地通知</h2>
<p>当我们从应用程序发送通知时，它们被称为本地通知。使用<code>postLocalNotification()</code>在 React Native 中完全支持它们。</p>
<pre>let localNotification = Notifications.postLocalNotification({
    body: "Local notification!",
    title: "Local Notification Title",
    sound: "chime.aiff",
    silent: false,
    category: "SOME_CATEGORY",
    userInfo: { },
    fireDate: new Date(),
});
</pre>
<p>有了它，我们可以传递各种选项，如正文、标题、声音和类别。<code>fireDate</code>属性将通知安排在一个日期和时间，当您想要在将来显示通知时，它是必需的。</p>
<p>此属性仅在 iOS 上有效。该事件返回一个惟一的通知 ID，我们将它存储在一个本地变量<code>localNotification</code>中。这用于在需要时取消预定的通知。</p>
<h2>取消 React Native 中的本地通知</h2>
<p>要取消本地通知，我们需要将<code>localNotification</code>变量传递给<code>cancelLocalNotification()</code>函数。</p>
<pre>Notifications.cancelLocalNotification(localNotification);
</pre>
<p>对于 iOS，我们有更多的功能可以用来取消通知:</p>
<ol>
<li><code>cancelAllLocalNotifications()</code>用于取消所有预定的本地通知。它不需要任何通知</li>
<li><code>removeDeliveredNotifications()</code>从<a href="https://developer.apple.com/documentation/foundation/notificationcenter" target="_blank" rel="noopener">通知中心</a>删除已经发送的通知。您需要传递通知 id 数组来移除它们</li>
<li>从通知中心删除所有已发送的通知</li>
</ol>
<h2>结论</h2>
<p>React-native-notifications 是 React native 和 Native 通知 API 之间的桥梁，它适用于 Android 和 iOS。</p>
<p>在这篇博文中，我们了解了推送和本地通知，以及它们如何帮助提高用户参与度。尽管许多选项是特定于平台的，但 react-native-notifications 可以很好地处理这两个平台，并尽可能提供通用功能。</p><div class="code-block code-block-18">
<div class="blog-plug inline-plug react-native-plug"><h2><a href="https://lp.logrocket.com/blg/react-native-signup"> LogRocket </a>:即时重现 React 原生应用中的问题。</h2><a class="signup" href="https://lp.logrocket.com/blg/react-native-signup" target="_blank" rel="noopener noreferrer"><img class="alignnone size-full wp-image-46 jetpack-lazy-image" src="../Images/110055665562c1e02069b3698e6cc671.png" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2021/10/react-native-plug_v2-2.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2021/10/react-native-plug_v2-2.png"/><noscript><img data-lazy-fallback="1" class="alignnone size-full wp-image-46" src="../Images/110055665562c1e02069b3698e6cc671.png" data-original-src="https://blog.logrocket.com/wp-content/uploads/2021/10/react-native-plug_v2-2.png"/></noscript></a><p><a href="https://lp.logrocket.com/blg/react-native-signup" target="_blank" rel="noopener noreferrer"> LogRocket </a>是一款 React 原生监控解决方案，可帮助您即时重现问题、确定 bug 的优先级并了解 React 原生应用的性能。</p><p>LogRocket 还可以向你展示用户是如何与你的应用程序互动的，从而帮助你提高转化率和产品使用率。LogRocket 的产品分析功能揭示了用户不完成特定流程或不采用新功能的原因。</p><p>开始主动监控您的 React 原生应用— <a class="signup" href="https://lp.logrocket.com/blg/react-native-signup" target="_blank" rel="noopener noreferrer">免费试用 LogRocket】。</a></p></div>
</div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
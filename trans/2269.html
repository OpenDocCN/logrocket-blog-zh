<html>
<head>
<title>Commitlint: Write more organized code - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>Commitlint:写更有条理的代码日志博客</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/commitlint-write-more-organized-code/#0001-01-01">https://blog.logrocket.com/commitlint-write-more-organized-code/#0001-01-01</a></blockquote><div><article class="article-post">
<p>作为开发人员，我们经常会跳入现有的项目——有时是大型代码库——来修复一个 bug 或开发一个新功能。我们通常从浏览源代码开始，以了解它是如何构建的，以及应用程序中的组件是如何相互交互的。</p>
<p>但是，即使我们找到了错误发生的确切位置，也可能不清楚问题的正确解决方案是什么，或者它最初是如何出现的。</p>
<p>幸运的是，有一个叫做<a href="https://blog.logrocket.com/the-git-workflow-you-need-how-to-deal-with-multiple-teams-in-a-single-repository-faf5bb17a6e4/" target="_blank" rel="noopener"> Git </a>的工具，当正确使用时，它可以调查谁以及为什么特定代码被更改或添加。但是，如果您的经历和我一样，那么当您访问项目的 Git 历史记录时，您可能会发现如下内容:</p>
<p><img data-attachment-id="72681" data-permalink="https://blog.logrocket.com/commitlint-write-more-organized-code/git-history/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2021/10/git-history.png" data-orig-size="730,213" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Git history" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2021/10/git-history-300x88.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2021/10/git-history.png" decoding="async" class="aligncenter size-full wp-image-72681 jetpack-lazy-image" src="../Images/bfd17ba7c594922403467e0de062f113.png" alt="Git History" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2021/10/git-history.png 730w, https://blog.logrocket.com/wp-content/uploads/2021/10/git-history-300x88.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2021/10/git-history.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2021/10/git-history.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="72681" data-permalink="https://blog.logrocket.com/commitlint-write-more-organized-code/git-history/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2021/10/git-history.png" data-orig-size="730,213" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Git history" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2021/10/git-history-300x88.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2021/10/git-history.png" decoding="async" loading="lazy" class="aligncenter size-full wp-image-72681" src="../Images/bfd17ba7c594922403467e0de062f113.png" alt="Git History" srcset="https://blog.logrocket.com/wp-content/uploads/2021/10/git-history.png 730w, https://blog.logrocket.com/wp-content/uploads/2021/10/git-history-300x88.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2021/10/git-history.png"/></noscript>
<p>不是很有帮助，对吧？不可能确定哪个提交与我们相关，因为所有的描述都是相同的或者不是描述性的。</p>
<p>这个能修好吗？让我们讨论一下 commitlint 是如何拯救世界的。</p>
<h2>什么是 commitlint？</h2>
<p><a href="https://github.com/conventional-changelog/commitlint" target="_blank" rel="noopener">提交列表</a>是您提交消息的<a href="https://eslint.org/" target="_blank" rel="noopener">列表</a>。它根据预定义的提交格式对任何文本执行验证。用户可以根据自己的需要配置这些格式，或者采用预先内置的约定，比如<a href="https://www.conventionalcommits.org/en/v1.0.0/" target="_blank" rel="noopener">常规提交</a>。</p>
<p>因为该工具可以通过<a href="https://opensource.com/article/18/8/introduction-pipes-linux" target="_blank" rel="noopener">管道</a>传输到其他流程的输出，所以通过在提交更改、推送或使用任何其他 Git 挂钩之前验证消息，它可以很容易地与您的开发工作流集成。</p>
<p>在学习如何设置之前，让我们先来看看它的运行情况:</p>
<p><img data-attachment-id="72683" data-permalink="https://blog.logrocket.com/commitlint-write-more-organized-code/commitlint-in-action/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2021/10/commitlint-in-action.png" data-orig-size="730,458" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Commitlint in action" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2021/10/commitlint-in-action-300x188.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2021/10/commitlint-in-action.png" decoding="async" class="aligncenter size-full wp-image-72683 jetpack-lazy-image" src="../Images/4dc26ab5b82dcbdc6d15edeb5910108e.png" alt="Commitlint in Action" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2021/10/commitlint-in-action.png 730w, https://blog.logrocket.com/wp-content/uploads/2021/10/commitlint-in-action-300x188.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2021/10/commitlint-in-action.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2021/10/commitlint-in-action.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="72683" data-permalink="https://blog.logrocket.com/commitlint-write-more-organized-code/commitlint-in-action/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2021/10/commitlint-in-action.png" data-orig-size="730,458" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Commitlint in action" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2021/10/commitlint-in-action-300x188.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2021/10/commitlint-in-action.png" decoding="async" loading="lazy" class="aligncenter size-full wp-image-72683" src="../Images/4dc26ab5b82dcbdc6d15edeb5910108e.png" alt="Commitlint in Action" srcset="https://blog.logrocket.com/wp-content/uploads/2021/10/commitlint-in-action.png 730w, https://blog.logrocket.com/wp-content/uploads/2021/10/commitlint-in-action-300x188.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2021/10/commitlint-in-action.png"/></noscript>
<h2>正在安装 commitlist</h2>
<p>Commitlint 很容易为 npm 或 Yarn 项目设置。让我们从作为开发依赖项安装该工具开始。</p>
<p>因为我们将使用默认配置，所以我们需要安装两个不同的 commitlint 模块、CLI 工具和实际配置。从您的终端运行:</p>
<pre>npm install --save-dev @commitlint/{cli,config-conventional}</pre>
<p>或者，使用纱线:</p>
<pre>yarn add @commitlint/{cli,config-conventional} --dev</pre>
<p>最后，您需要用您的配置选项创建一个<code>commitlint.config.js</code>文件。为此，您可以在终端中执行以下命令:</p>
<pre>echo "module.exports = { extends: ['@commitlint/config-conventional'] };" &gt; commitlint.config.js</pre>
<h2>用 commitlist 设置 git 挂钩</h2>
<p>为了在每个 Git 提交命令上自动运行提交消息验证，我们将使用<a href="https://blog.logrocket.com/configuring-git-hooks-for-the-win/" target="_blank" rel="noopener"> Husky </a>，这是一个使我们能够快速设置 Git 挂钩的工具。</p>
<p>这非常简单，所以让我们直接进入命令:</p>
<h3>使用 npm</h3>
<p>安装 Husky</p>
<pre>npm install husky --save-dev</pre>
<p>激活挂钩</p>
<pre>npx husky install</pre>
<p>添加提交消息挂钩</p>
<pre>npx husky add .husky/commit-msg 'npx --no-install commitlint --edit $1'</pre>
<h3>用纱线</h3>
<p>安装 Husky</p>
<pre>yarn add husky --dev</pre>
<p>激活挂钩</p>
<pre>yarn husky install</pre>
<p>添加提交消息挂钩</p>
<pre>yarn husky add .husky/commit-msg 'yarn commitlint --edit $1'</pre>
<p>现在一切都设置好了，我们可以尝试用无效的文本格式提交，看看会发生什么:</p>
<pre>~ git commit -m "commit"

⧗ input: commit

✖ subject may not be empty [subject-empty]

✖ type may not be empty [type-empty]

✖ found 2 problems, 0 warnings

ⓘ Get help: https://github.com/conventional-changelog/commitlint/#what-is-commitlint</pre>
<p>很明显，commitlint 拒绝了“提交”消息。我们也知道原因，所以让我们修正我们的消息，看看结果:</p>
<pre>~ git commit -m "chore: add commitlint on commit-msg"

[master (root-commit) e0f064f] chore: add commitlint on commit-msg

5 files changed, 3412 insertions(+)

create mode 100644 .gitignore

create mode 100755 .husky/commit-msg

create mode 100644 commitlint.config.js

create mode 100644 package-lock.json

create mode 100644 package.json
</pre>
<p>当消息满足标准时，commit 命令继续其工作流并存储更改。</p>
<p>都搞定了。Commitlint 现在正在验证您的所有提交消息，并帮助您增强提交历史记录。现在让我们讨论默认约定以及如何编写高质量的提交消息。</p>
<h2>编写提交消息</h2>
<p>让我们暂时离开技术领域，专注于编写——更准确地说，如何编写好的不言自明的提交消息，并通过 commitlint 默认验证。</p>
<p>一个好的典型提交消息将具有以下结构:</p>
<pre>&lt;type&gt;(&lt;scope?&gt;): &lt;subject!&gt;
&lt;BLANK LINE&gt;
&lt;body?&gt;
&lt;BLANK LINE&gt;
&lt;footer?&gt;

</pre>
<p>我来<a href="https://github.com/angular/angular/blob/22b96b9/CONTRIBUTING.md#-commit-message-guidelines" target="_blank" rel="noopener">解释一下各个部分</a>。</p>
<h3>类型</h3>
<p><code>type</code>是强制性的，决定了改变的意图。以下是可能的值:</p>
<ul>
<li><code>build</code>:影响构建系统或外部依赖的变更</li>
<li><code>ci</code>:更新持续集成和部署服务的配置文件</li>
<li><code>chore</code>:更新打杂任务等。；没有生产代码变更</li>
<li><code>docs</code>:仅文档变更</li>
<li>新功能</li>
<li>一个错误修复</li>
<li><code>perf</code>:提高性能的代码更改</li>
<li>一个既没有修复 bug 也没有增加特性的代码变化</li>
<li><code>style</code>:不影响代码含义的更改(空白、格式、缺少分号等)。)</li>
<li><code>test</code>:添加缺失的测试或修正现有的测试</li>
</ul>
<h3>范围</h3>
<p>范围是一个可选值，它提供了关于变更的附加上下文信息。例如，当模块名、npm 包或特定例程受到影响时。</p>
<p>范围(如果存在)必须包含在括号内。</p>
<h3>科目</h3>
<p>主题是提交的标题。它应该用一句话概括变化的本质。</p><div class="code-block code-block-54">
<hr/>
<h3>更多来自 LogRocket 的精彩文章:</h3>

<hr/></div>
<p>对于主题，请考虑以下规则:</p>
<ul>
<li>使用命令式现在时:“改变”，而不是“改变”或“变化”</li>
<li>第一个字母不要大写</li>
<li>没有点(。)在最后</li>
</ul>
<h3>身体</h3>
<p>正文是一个可选的空间，用于提供有关变更、变更动机和所做工作的附加信息。正如主语的情况一样，正文是用现在时态写的。</p>
<h3>页脚</h3>
<p>最后，页脚是参考信息的可选占位符，例如，重大变更警报或参考编号或参考文献。</p>
<p>突破性改变应该以单词“突破性改变”开始，并带有空格或两个换行符。</p>
<h2>好的提交消息的例子</h2>
<p>首先，让我们看看我创建的一些示例:</p>
<p>示例 1:</p>
<pre>feat(payment): add a new endpoint to calculate taxes

This allows the payment module to calculate taxes for an order based on the order information. Currently only US sales tax and European VAT are supported

Refs #45621
</pre>
<p>示例 2:</p>
<pre>build(docs-infra): regenerate docs after deployment pipeline completes

Automates the process of building the documentation portal after changes are merged into develop, release and master branches.overloads.
PR Close #43614
</pre>
<p>以下是来自 GitHub 的一些其他<a href="https://github.com/angular/angular/commits/master" target="_blank" rel="noopener">优秀例子:</a></p>
<p>示例 1:</p>
<pre>fix(bazel): construct a manifest file even when warnings are emitted

Previously if _any_ diagnostics were emitted, regardless of their category, the manifest would not be generated. This means that if a target emits only warnings and no errors, it would still fail to build because it does not generate all the required output files (specifically the `.es5.MF` file). Now the manifest file is generated as long as there are no error diagnostics in the result. This makes `ng_module()` support compiler warnings as a user would expect.

Added a test that uses extended template diagnostics to trigger the invalid banana in box diagnostic. This generates a warning and uses Skylib's `build_test()` to verify that it builds successfully. Unfortunately, there is no easy way to verify that the warning diagnostic is emitted at all. `expected_diagnostics` should be able to do that, but it doesn't seem to have any effect on `ng_module()` and may not be integrated. Instead, testing that a target with warnings builds correctly is the best we can easily do here without a deeper investigation.

PR Close #43582
</pre>
<p>示例 2:</p>
<pre>docs: reviewed tag added (#43472)

PR Close #43472
</pre>
<p>示例 3:</p>
<pre>test(router): refactor tests to not use deprecated loadChildren (#43578)

Many of the tests in the router code use the deprecated loadChildren as a string. This
has been deprecated for years and can easily be changed to just a function that
returns the module.

PR Close #43578
</pre>
<h2>结论</h2>
<p>开发人员不喜欢在格式化文本这样的琐碎任务上花费时间。这就是为什么他们建立了惊人的自动化工具，如 ESLint、Prettier 和现在的 commit lint——让他们的生活更轻松。更重要的是，他们构建这些工具是因为他们知道拥有良好格式化和标准化的代码和消息的价值。</p>
<p>为了它给你、你的项目和你的组织带来的价值，你会在这个自动化和过程上投入时间吗？我当然愿意！</p>
<p>ESLint 和 beauty 已经是我们生活的一部分了。让我们欢迎 commitlint 加入开发人员生产力工具家族。</p>
<p>感谢阅读！</p><div class="code-block code-block-2">
<div class="blog-plug base-cta"><h2>使用<a class="signup" href="https://lp.logrocket.com/blg/signup" target="_blank" rel="noopener noreferrer"> LogRocket </a>消除传统错误报告的干扰</h2>
<a href="https://lp.logrocket.com/blg/signup" class="signup" target="_blank" rel="noopener noreferrer"><img class="alignnone size-full wp-image-46 jetpack-lazy-image" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/><noscript><img data-lazy-fallback="1" class="alignnone size-full wp-image-46" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/></noscript></a>
<p><a href="https://lp.logrocket.com/blg/signup" target="_blank" rel="noopener noreferrer"> LogRocket </a>是一个数字体验分析解决方案，它可以保护您免受数百个假阳性错误警报的影响，只针对几个真正重要的项目。LogRocket 会告诉您应用程序中实际影响用户的最具影响力的 bug 和 UX 问题。</p>
<p>然后，使用具有深层技术遥测的会话重放来确切地查看用户看到了什么以及是什么导致了问题，就像你在他们身后看一样。</p>
<p>LogRocket 自动聚合客户端错误、JS 异常、前端性能指标和用户交互。然后 LogRocket 使用机器学习来告诉你哪些问题正在影响大多数用户，并提供你需要修复它的上下文。</p>
<p>关注重要的 bug—<a class="signup" href="https://lp.logrocket.com/blg/signup-issue-free" target="_blank" rel="noopener noreferrer">今天就试试 LogRocket】。</a></p></div></div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
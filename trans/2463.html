<html>
<head>
<title>Responsive CSS border radius with the Fab Four technique - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>使用 Fab Four 技术的响应式 CSS 边界半径</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/responsive-css-border-radius-fab-four-technique/#0001-01-01">https://blog.logrocket.com/responsive-css-border-radius-fab-four-technique/#0001-01-01</a></blockquote><div><article class="article-post">
<p>在过去的几年里，浏览器对各种 CSS 特性的支持已经有了长足的进步。虽然垂直居中一个<code>div</code>是我们用这种方式相当容易执行的事情，但是我们仍然缺少一些关键的特性。</p>
<p>你可能已经熟悉了<code>media-queries</code>，它基于浏览器视窗或屏幕分辨率应用样式，但有时我们可能需要<code><a href="https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Container_Queries" target="_blank" rel="noopener">container-queries</a></code>，它仍然只在某些浏览器的<code>feature</code>标志下可用。</p>
<p>今天我们将实现 Fab Four 技术，根据元素的<code>container</code>维度，而不是<code>screen</code>宽度，对元素应用<code>border-radius</code>。</p>
<blockquote><p><strong>作者注</strong>:我最近在<a href="https://twitter.com/shadeed9/status/1444683275616854022" target="_blank" rel="noopener">推特</a>上偶然发现了这个技巧，在那里<a href="https://twitter.com/frankyan" target="_blank" rel="noopener"> Frank Yan </a>(一位脸书工程师)进一步解释了它的含义。在这个帖子中，有人建议这段代码不应该是“人写的”，所以我在这篇博文的结尾为你做了介绍。</p></blockquote>
<h2 id="what-does-this-technique-do">这种技术有什么作用？</h2>
<p>Fab Four 技术可以通过使用各种 CSS 函数来实现，如<code>min</code>、<code>max</code>、<code>calc</code>和<code>clamp</code>，以计算是否应该应用特定的 CSS 规则，同时将其与容器元素的维度而不是设备视口进行比较。</p>
<p>让我们来看看下面的演示，其中几个<code>card</code>组件被包装在一个可调整大小的容器中:</p>
<p class="codepen" data-height="300" data-default-tab="result" data-slug-hash="YzrKKKW" data-user="kspeyanski">参见<a href="https://codepen.io"> CodePen </a>上 Kiril Peyanski(<a href="https://codepen.io/kspeyanski">@ kspeyanski</a>)<br/>的未命名的笔。</p>
<p/>
<p>这里我们想要实现的特定需求是，每当卡片的容器宽度小于<code>400px</code>时，就移除卡片的<code>border-radius</code>。</p>
<p><img data-attachment-id="82329" data-permalink="https://blog.logrocket.com/responsive-css-border-radius-fab-four-technique/dynamic-border-fab-four/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2021/12/Dynamic-Border-Fab-Four.gif" data-orig-size="730,468" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Resizing the border radius of the cards" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2021/12/Dynamic-Border-Fab-Four-300x192.gif" data-large-file="https://blog.logrocket.com/wp-content/uploads/2021/12/Dynamic-Border-Fab-Four.gif" decoding="async" class="aligncenter size-full wp-image-82329 jetpack-lazy-image" src="../Images/001382ece06c2841dd1e57c627f01bf8.png" alt="Resizing the Border Radius of the Cards" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2021/12/Dynamic-Border-Fab-Four.gif?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2021/12/Dynamic-Border-Fab-Four.gif"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="82329" data-permalink="https://blog.logrocket.com/responsive-css-border-radius-fab-four-technique/dynamic-border-fab-four/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2021/12/Dynamic-Border-Fab-Four.gif" data-orig-size="730,468" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Resizing the border radius of the cards" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2021/12/Dynamic-Border-Fab-Four-300x192.gif" data-large-file="https://blog.logrocket.com/wp-content/uploads/2021/12/Dynamic-Border-Fab-Four.gif" decoding="async" loading="lazy" class="aligncenter size-full wp-image-82329" src="../Images/001382ece06c2841dd1e57c627f01bf8.png" alt="Resizing the Border Radius of the Cards" data-original-src="https://blog.logrocket.com/wp-content/uploads/2021/12/Dynamic-Border-Fab-Four.gif"/></noscript>
<blockquote><p><strong>作者注</strong>:用<code>console.log</code>相当于调试的 CSS 是<code>border: 1px solid red</code>，用了应该不会心疼！</p></blockquote>
<p>深入研究我们的代码，我们可以观察到下面的<code>border-radius</code>计算:</p>
<pre class="language-css hljs">css
.dynamic-card {
  border-radius: max(0px, min(16px, (100% - 400px + 1px) * 9999)) / 16px;
}
</pre>
<p>乍一看可能很奇怪，但是我们将检查每个计算并进一步解释它。我们希望确定代码中的以下变量:</p>
<ul>
<li>期望的<code>border-radius</code></li>
<li>集装箱宽度<code>breakpoint</code></li>
</ul>
<pre class="language-css hljs">css
.dynamic-card {
  border-radius: max(0px, min(DESIRED_BORDER_RADIUS, (100% - WIDTH_BREAKPOINT + 1px) * 9999)) / DESIRED_BORDER_RADIUS;
}</pre>
<p>为了深入研究上面的 CSS 规则，我们必须将它分成三个不同的计算:</p>
<ul>
<li><code>min</code>计算</li>
<li><code>max</code>计算</li>
<li><code>division</code>按像素</li>
</ul>
<h3 id="the-min-calculation"><code>min</code>计算</h3>
<pre class="language-css hljs">css
  min(DESIRED_BORDER_RADIUS, (100% - WIDTH_BREAKPOINT + 1px) * 9999)
</pre>
<p>这里发生了什么事？嗯，首先我们必须考虑<code>100%</code>在做什么。将<code>width: 100%</code>设置为 CSS 元素会(在大多数情况下)将元素扩展到其整个容器宽度，这意味着当在<code>min</code>函数中使用<code>100%</code>时，它将总是返回我们容器的<code>width</code>。</p>
<p>这意味着如果我们的容器是<code>480px</code>宽，并且我们已经定义了一个<code>400px</code>的<code>WIDTH_BREAKPOINT</code>，计算将是:</p>
<pre class="language-css hljs">css
  /* 480px - 400px + 1px = 81px * 9999 = a really big POSITIVE number */
  min(DESIRED_BORDER_RADIUS, (480px - 400px + 1px) * 9999)
</pre>
<p>计算的<code>* 9999</code>部分只是为了确保我们总是高于<code>max</code>值或者低于<code>min</code>值。否则，我们可能会处于两者之间。</p>
<p>看一下容器宽度小于我们预定义的断点的另一种情况:</p>
<pre class="language-css hljs">css
  /* 320px - 400px + 1px = -79px * 9999 = a really big NEGATIVE number */
  min(DESIRED_BORDER_RADIUS, (320px - 400px + 1px) * 9999)
</pre>
<p>由于我们有一个<code>min</code>函数，我们通过计算得到以下结果:</p>
<ul>
<li>当<code>container</code>宽度大于<code>breakpoint</code>宽度时，最终结果将是<code>DESIRED_BORDER_RADIUS</code>(或本例中的<code>16px</code>)</li>
<li>当<code>container</code>宽度低于<code>breakpoint</code>时，我们得到一个负数(或者在我们的例子中是<code>-789,921</code>)</li>
</ul>
<p><code>max</code>计算<br/>这是我们复杂计算集合中要调用的下一个函数:</p>
<pre class="language-css hljs">css
  max(0px, RESULT_FROM_MIN)
</pre>
<p>我们已经知道我们会得到一个正的边界半径或者一个负数。通过应用<code>min</code>计算的结果，我们得到以下结果:</p>
<ul>
<li>当<code>container</code>宽度大于<code>breakpoint</code>宽度时:<code>RESULT_FROM_MIN</code>(或本例中的<code>16px</code>)</li>
<li>当<code>container</code>宽度低于<code>breakpoint</code>时:<code>0px</code></li>
</ul>
<h3 id="the-desired-border-radius"><code>/ DESIRED_BORDER_RADIUS</code>计算</h3>
<pre class="language-css hljs">css
  border-radius: RESULT_FROM_MAX / DESIRED_BORDER_RADIUS;
</pre>
<p>这不是一个<code>division</code>操作符，而是一个<a href="https://developer.mozilla.org/en-US/docs/Web/CSS/border-radius#values" target="_blank" rel="noopener">扩展语法</a>，用于将<code>border-radius</code>应用于一个元素。上面的代码将被评估(注意丢失的<code>/</code>字符):</p>
<pre class="language-css hljs">css
  border-top-left-radius:     RESULT_FROM_MAX DESIRED_BORDER_RADIUS;
  border-top-right-radius:    RESULT_FROM_MAX DESIRED_BORDER_RADIUS;
  border-bottom-right-radius: RESULT_FROM_MAX DESIRED_BORDER_RADIUS;
  border-bottom-left-radius:  RESULT_FROM_MAX DESIRED_BORDER_RADIUS;
</pre>
<p>这很重要，因为 CSS 解析引擎对我们试图用<code>min</code>和<code>max</code>函数定义边界半径的方式不太满意，所以我们使用这个巧妙的小技巧。</p>
<p>我们可以使用<code>clamp</code>功能作为替代，但我们避免这样做，因为它在 Safari 12 中不支持<a href="https://caniuse.com/css-math-functions" target="_blank" rel="noopener"/>。</p>
<p><img data-attachment-id="82331" data-permalink="https://blog.logrocket.com/responsive-css-border-radius-fab-four-technique/clamp_support_in_safari/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2021/12/clamp_support_in_safari.png" data-orig-size="730,296" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Clamp support in safari" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2021/12/clamp_support_in_safari-300x122.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2021/12/clamp_support_in_safari.png" decoding="async" class="aligncenter size-full wp-image-82331 jetpack-lazy-image" src="../Images/978eb9a80df01724b1b6adc19d6cbcd6.png" alt="Clamp Support in Safari" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2021/12/clamp_support_in_safari.png 730w, https://blog.logrocket.com/wp-content/uploads/2021/12/clamp_support_in_safari-300x122.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2021/12/clamp_support_in_safari.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2021/12/clamp_support_in_safari.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="82331" data-permalink="https://blog.logrocket.com/responsive-css-border-radius-fab-four-technique/clamp_support_in_safari/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2021/12/clamp_support_in_safari.png" data-orig-size="730,296" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Clamp support in safari" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2021/12/clamp_support_in_safari-300x122.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2021/12/clamp_support_in_safari.png" decoding="async" loading="lazy" class="aligncenter size-full wp-image-82331" src="../Images/978eb9a80df01724b1b6adc19d6cbcd6.png" alt="Clamp Support in Safari" srcset="https://blog.logrocket.com/wp-content/uploads/2021/12/clamp_support_in_safari.png 730w, https://blog.logrocket.com/wp-content/uploads/2021/12/clamp_support_in_safari-300x122.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2021/12/clamp_support_in_safari.png"/></noscript>

<p>这项技术依赖于我们的 CSS 解析引擎来计算<code>100%</code>。这个百分比将评估为我们容器的<code>width</code>，而不是我们可以在<code>media-queries</code>中使用的<code>screen width</code>。</p>
<p>下面的代码在大多数情况下可以工作，但是当我们有一个可调整大小的容器时就会失败，如上例所示:</p>
<pre class="language-css hljs">css
.dynamic-card {
    border-radius: 0;
}
@media screen and (min-width: 400px) {
  .dynamic-card {
    border-radius: 16px;
  }
}
</pre>
<h3 id="reversing-the-logic">颠倒逻辑</h3>
<p>根据应用要求，Fab Four 技术可以应用于多种情况。有时，每当容器<code>width</code>小于特定的<code>breakpoint</code>时，应该应用特定的规则。在这种情况下，我们可以颠倒逻辑:</p>
<p>出发地:</p>
<pre class="language-css hljs">(100% - WIDTH_BREAKPOINT + 1px) * 9999))
</pre>
<p>收件人:</p>
<pre class="language-css hljs">(WIDTH_BREAKPOINT - 1px - 100%) * 9999))
</pre>
<p>这将仅在<code>width</code>低于<code>breakpoint</code>时应用期望的<code>value</code>。</p>
<h2 id="utilities">公用事业</h2>
<p>让我们面对这样一个事实，即使你很熟悉这个技术，这个计算也不是简单易懂的。幸运的是，我们可以提取 SASS mixins，或者各种 CSS-in-JS 库的实用函数(比如<a href="https://styled-components.com/" target="_blank" rel="noopener"> styled-components </a>)。</p>
<h3 id="native-css-with-css-variables">带有 CSS 变量的原生 CSS</h3>
<pre class="language-css hljs">css
  .dynamic-card {
    --border-radius: 16px;
    --breakpoint: 400px;
  }
  .dynamic-border {
    border-radius: max(0px, min(var(--border-radius), (100% - var(--breakpoint) + 1px) * 9999)) / var(--border-radius);
  }
</pre>
<h3 id="sass-mixin">萨斯米辛</h3>
<p>以下<a href="https://sass-lang.com/documentation/at-rules/mixin"> SASS mixin </a>帮助我们在基于 SASS 的项目中实现 Fab Four 技术:</p>
<pre class="language-scss hljs">scss
@mixin dynamic-border-radius($value, $breakpoint) {
  &amp; {
    border-radius: #{"max(0px, min(#{$value}, 100% - #{$breakpoint} + 1px) * 9999) / #{$value}"};
  }
}
.dynamic-card {
  @include dynamic-border-radius(16px, 400px);
}
</pre>
<h3 id="css-in-js">CSS-in-JS</h3>
<pre class="language-javascript hljs">import styled, { css } from 'styled-components';
const dynamicBorderRadius = (value, breakpoint) =&gt; css`
  border-radius: max(0px, min(${value}px, 100% - ${breakpoint}px + 1px) * 9999) /
    ${value}px;
`;
const Card = styled('div')`
    ${dynamicBorderRadius(16, 400)};
`;
</pre>
<h2 id="conclusion">结论</h2>
<p>随着网络的发展，我们将会看到更多像<code>container-queries</code>这样的特性在大多数网络浏览器中实现。在这一天到来之前，我们可以使用 Fab Four 这样的技术来实现特定的应用程序需求，这些需求看起来并不总是那么简单。</p><div class="code-block code-block-25">
<div class="blog-plug inline-plug css-plug"><h2>你的前端是否占用了用户的 CPU？</h2><p>随着 web 前端变得越来越复杂，资源贪婪的特性对浏览器的要求越来越高。如果您对监控和跟踪生产环境中所有用户的客户端 CPU 使用、内存使用等感兴趣，</p><a target="_blank" href="https://lp.logrocket.com/blg/css-signup">try LogRocket</a><p>.</p><a class="signup" href="https://lp.logrocket.com/blg/css-signup" target="_blank" rel="noopener noreferrer"><img class="alignnone size-full wp-image-46 jetpack-lazy-image" src="../Images/dacb06c713aec161ffeaffae5bd048cd.png" alt="LogRocket Dashboard Free Trial Banner" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2019/12/cpu-memory-usage.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/12/cpu-memory-usage.png"/><noscript><img data-lazy-fallback="1" class="alignnone size-full wp-image-46" src="../Images/dacb06c713aec161ffeaffae5bd048cd.png" alt="LogRocket Dashboard Free Trial Banner" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/12/cpu-memory-usage.png"/></noscript></a><a href="https://lp.logrocket.com/blg/css-signup" target="_blank" rel="noopener noreferrer">https://logrocket.com/signup/</a><p>LogRocket 就像是网络和移动应用的 DVR，记录你的网络应用或网站上发生的一切。您可以汇总和报告关键的前端性能指标，重放用户会话和应用程序状态，记录网络请求，并自动显示所有错误，而不是猜测问题发生的原因。</p><p>现代化您调试 web 和移动应用的方式— <a class="signup" href="https://lp.logrocket.com/blg/css-signup" target="_blank" rel="noopener noreferrer">开始免费监控</a>。</p></div>
</div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
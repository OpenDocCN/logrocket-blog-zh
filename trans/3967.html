<html>
<head>
<title>Reactivity with the Vue 3 Composition API: ref() and reactive() </title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>与Vue 3组合API的反应性:ref()和reactive()</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/reactivity-vue-3-composition-api-ref-reactive/#0001-01-01">https://blog.logrocket.com/reactivity-vue-3-composition-api-ref-reactive/#0001-01-01</a></blockquote><div><article class="article-post">
<p>在单页应用程序(SPA)中，反应性是指应用程序更新其用户界面以响应底层数据变化的能力。反应性允许我们编写更干净的代码，防止我们必须手动更新UI来响应数据变化。相反，用户界面会自动更新。</p>
<p>然而，JavaScript本身并不这样工作，所以我们可以使用React、Vue和Angular等库和框架来实现反应性。比如在Vue中，我们可以创建一个名为<code>state</code>的数据集；然后，Vue使用一个观察器和观察者系统来跟踪状态并更新我们的UI。</p>
<p>当Vue检测到状态变化时，它使用虚拟DOM来重新呈现UI，并确保它总是最新的，通过使用记忆化和选择性更新等技术，使这个过程尽可能地快速和高效。</p>
<p>有几种不同的方法来定义我们希望Vue跟踪的应用程序状态。例如，在Vue 3 中的<a href="https://blog.logrocket.com/vue-composition-api-vs-react-hooks/">合成API之前，我们使用了一个数据函数，该函数返回我们想要跟踪的对象。然而，对于组合API，我们使用两个函数来定义状态，<code>ref()</code>和<code>reactive()</code>。在本文中，我们将探索这两个函数，概述它们的独特之处，并了解何时应该使用它们。</a></p>
<p><em>向前跳转:</em></p>

<h2 id="vue-reactive">视图〔t0〕</h2>
<p>您可以使用<a href="/paper/ep/redirect/external-link?url=https%3A%2F%2Fvuejs.org%2Fapi%2Freactivity-core.html%23reactive&amp;hmac=RHYc6xdJyliWCxc%2ButwPZTjkjP94Sn15HXM3sTTukWc%3D"> <code>reactive( )</code> </a>来声明Vue中使用组合API的对象或数组的状态:</p>
<pre class="language-javascript hljs">import { reactive } from 'vue'

const state = reactive({
  first_name: "John",
  last_name: "Doe",
})
</pre>
<p>在上面的代码片段中，我们向Vue声明我们想要在<code>reactive( )</code>函数中跟踪对象。然后我们可以创建一个依赖于这个反应对象的UI，Vue将跟踪<code>state</code>对象并使用它来更新UI:</p>
<pre class="language-javascript hljs">&lt;template&gt;
  &lt;div&gt;{{state.first_name}} {{state.last_name}}&lt;/div&gt;
&lt;/template&gt;
&lt;script&gt;
import { reactive } from 'vue'
export default {
  setup() {
    const state = reactive({
      first_name: "John",
      last_name: "Doe",
    })

    return { state }
  }
}
&lt;/script&gt;
</pre>
<p>在上面的代码中，我们显示了状态中的反应数据。现在，Vue的反应系统可以跟踪这些数据，并在数据发生变化时更新用户界面。我们可以通过创建一个函数来测试这一点，当我们单击一个按钮时，这个函数会改变<code>first_name</code>和<code>last_name</code>:</p>
<pre class="language-javascript hljs">&lt;template&gt;
  &lt;div&gt;{{state.first_name}} {{state.last_name}}&lt;/div&gt;
  &lt;button @click="swapNames"&gt;Swap names&lt;/button&gt;
&lt;/template&gt;
&lt;script&gt;
import { reactive } from 'vue'
export default {
  setup() {
    const state = reactive({
      first_name: "John",
      last_name: "Doe",
    })

    const swapNames = () =&gt; {
      state.first_name = "Naruto"
      state.last_name = "Uzumaki"
    }

    return { state, swapNames }
  }
}
&lt;/script&gt;
</pre>
<p>点击按钮时，<code>swapNames</code>功能改变<code>first_name</code>和<code>last_name</code>，Vue即时更新UI内容。</p>
<p><code>reactive()</code>函数是在Vue组件中创建反应对象的强大工具，但是因为它在幕后工作，所以它有一个主要的限制；它只能处理对象。因此，您不能将它与字符串或数字之类的原语一起使用。为了处理这种限制，Vue提供了第二个功能来声明应用程序中的反应状态，<code>ref()</code>。</p>
<h2 id="vue-ref">视图〔t0〕</h2>
<p><a href="https://vuejs.org/api/reactivity-core.html#ref"> <code>ref()</code>函数</a>可以保存任何值类型，包括原语和对象。因此，我们以类似于<code>reactive()</code>函数的方式使用它:</p>
<pre class="language-javascript hljs">import { ref } from 'vue'

const age = ref(0)
</pre>
<p><code>ref()</code>函数返回一个特殊的反应对象。为了访问<code>ref()</code>正在跟踪的值，我们访问返回对象的<code>value</code>属性:</p>
<pre class="language-javascript hljs">import { ref } from 'vue'

const age = ref(0)

if(age.value &lt; 18) {
  console.log("You are too young to drink. Get lost!")
} else {
  console.log("Have some ale mate!")
}
</pre>
<p>下面的代码显示了我们将如何制作一个对<code>age</code> <code>ref()</code>的变化做出反应的UI:</p>
<pre class="language-javascript hljs">&lt;template&gt;
  &lt;h1&gt;{{age}}&lt;/h1&gt;
  &lt;button @click="increaseAge"&gt;+ Increase age&lt;/button&gt;
  &lt;button @click="decreaseAge"&gt;- Decrease age&lt;/button&gt;
&lt;/template&gt;
&lt;script&gt;
import { ref } from 'vue'
export default {
  setup() {
    const age = ref(0);

    const increaseAge = () =&gt; {
      age.value++
    }

    const decreaseAge = () =&gt; {
      age.value--
    }

    return { age, increaseAge, decreaseAge }
  }
}
&lt;/script&gt;
</pre>
<p>您可能会注意到，在模板中使用<code>age</code> <code>ref()</code>时，我们不需要指定值。当你在模板中调用<code>age</code>时，Vue会自动将<a href="https://vuejs.org/api/reactivity-utilities.html#unref"> <code>unref()</code> </a>应用到<code>age</code>中，所以你永远不需要使用模板中的值。</p>
<p>我们可以用一个<code>ref</code>重写第一个<code>reactive()</code>属性的例子；唯一的区别是，我们需要使用<code>.value</code>属性来访问JavaScript代码中的值。</p>
<h2 id="ref-vs-reactive-which-one"><code>ref()</code> vs <code>reactive()</code>:应该用哪个？</h2>
<p><code>ref()</code>和<code>reactive()</code>的显著区别在于<code>ref()</code>函数允许我们为原语和对象声明反应状态，而<code>reactive()</code>只为对象声明反应状态。</p>
<p>我们还必须通过使用返回对象的<code>.value</code>属性来访问<code>ref()</code>的值，但是我们不必为<code>reactive()</code>对象这样做。因此，在真实的场景中，您会发现使用<code>ref()</code>的Vue代码比使用<code>reactive()</code>的多，但是<code>reactive()</code>是完美的，因为它可以很容易地接受在组合API之前定义的状态。两者都有效地跟踪反应，所以使用哪一个是偏好和编码风格的问题。</p>
<h2 id="reactivity-vue-2-vs-vue-3">反应性:Vue 2与Vue 3</h2>
<p>Vue 3并没有完全消除我们在Vue 2中定义反应状态的默认方式；相反，Vue 3附带了两个API，即<a href="https://blog.logrocket.com/new-features-in-vue-3-and-how-to-use-them/">组合API </a>和选项API。Options API主要以Vue 2的方式工作:</p>
<pre class="language-javascript hljs">&lt;template&gt;
  &lt;h1&gt;{{age}}&lt;/h1&gt;
  &lt;button @click="increaseAge"&gt;+ Increase age&lt;/button&gt;
  &lt;button @click="decreaseAge"&gt;- Decrease age&lt;/button&gt;
&lt;/template&gt;
&lt;script&gt;
import { ref } from 'vue'
export default {
  data: function() {
    return {
      age: 0
    }
  },
  methods: {
    increaseAge() {
      this.age++
    },
    decreaseAge() {
      this.age--
    }
  }
}
&lt;/script&gt;
</pre>
<p>在上面的例子中，我们在状态中声明了<code>age</code>，并将其设置为<code>zero</code>。通过这些方法，我们可以增加或减少<code>age</code>，然后在视图上看到每次点击按钮的数据变化。上面的代码使用了选项API，对Vue 2和3都有效。</p>
<p>从Vue 2返回的<code>data</code>属性与我们之前讨论的组合API中的<code>reactive()</code>函数非常相似。它只作为一个对象工作；不能从数据属性包含的函数中返回字符串这样的原始值。</p>
<h2 id="migrating-vue2-app-ref-reactive">迁移Vue 2应用程序以使用<code>ref()</code>和<code>reactive()</code></h2>
<p>将应用程序从Vue 2 Options API迁移到Vue 3 Composition API相当简单。我们可以很容易地将Vue 2 <code>state</code>转换成<code>ref()</code>或<code>reactive()</code>。看看下面的Vue 2组件:</p>
<pre>&lt;template&gt;
  &lt;div&gt;
    &lt;button&gt;Clicked {{xTimes}}&lt;/button&gt;
  &lt;/div&gt;
&lt;/template&gt;
&lt;script&gt;
export default {
  data: function() {
    return {
      xTimes: 0  
    }
  },
  methods: {
    increase() {
      this.xTimes++
    }    
  }
}
&lt;/script&gt; 
</pre>
<p>我们可以很容易地使用<code>ref()</code>重写这个组件来显示它。考虑下面的代码片段:</p>
<pre class="language-javascript hljs">&lt;template&gt;
  &lt;div&gt;
    &lt;button&gt;Clicked {{xTimes}}&lt;/button&gt;
  &lt;/div&gt;
&lt;/template&gt;
&lt;script&gt;
import {ref} from "vue"
export default {
  setup() {
    const xTimes = ref(0)
    return {xTimes}
  },
  methods: {
    increase() {
      this.xTimes++
    }    
  }
}
&lt;/script&gt; 
</pre>
<p>我们也可以使用<code>reactive()</code>重写这个组件来显示它:</p>
<pre class="language-javascript hljs">&lt;template&gt;
  &lt;div&gt;
    &lt;button&gt;Clicked {{xTimes}}&lt;/button&gt;
  &lt;/div&gt;
&lt;/template&gt;
&lt;script setup&gt;
import {ref} from "vue"
const xTimes = ref(0)
const increase = () =&gt; {
  xTimes++
}   

&lt;/script&gt;
</pre>
<p>我们可以通过使用<code>setup( )</code>语法使<a href="https://vuejs.org/api/sfc-script-setup.html#basic-syntax">的代码更加流畅，这看起来更像下面的代码:</a></p>
<pre class="language-javascript hljs">&lt;template&gt;
  &lt;div&gt;
    &lt;button&gt;Clicked {{xTimes}}&lt;/button&gt;
  &lt;/div&gt;
&lt;/template&gt;
&lt;script&gt;
import {reactive} from "vue"

  setup() {
    const state = reactive({
      xTimes: 0
    })
    return {state}
  },
  methods: {
    increase() {
      this.state.xTimes++
    }    
  }
}
&lt;/script&gt;
</pre>
<h2 id="downsides-ref-reactive"><code>ref()</code>和<code>reactive()</code>的缺点</h2>
<p>使用<code>ref()</code>的缺点是总是不得不使用<code>.value</code>来访问您的状态会很不方便。如果您必须使用一个可能是<code>ref()</code>的值，您可能不知道它是否已经被初始化，并且在null上调用<code>.value</code>可能会抛出一个运行时错误。为了解决这个问题，我们可以<code>unref</code>T5，我们将在本文后面讨论。</p>
<p>另一方面，使用<code>reactive</code>的缺点是它不能用在原语上。您只能在对象和基于对象的类型上使用<code>reactive()</code>，比如<code>Map</code>和<code>Set</code>。您可以通过使用与在选项API中定义状态相同的方式使用<code>reactive()</code>来规避这个问题。</p>
<h2 id="mixing-ref-reactive">混合<code>ref()</code>和<code>reactive()</code>:这是个好主意吗？</h2>
<p>没有规则或惯例反对混合使用<code>ref()</code>和<code>reactive()</code>。是否这样做是主观的，取决于相关开发人员的偏好和编码模式。</p>
<p>有一些库，像<a href="https://vuelidate.js.org/">Vuelidate</a>,<a href="https://blog.logrocket.com/form-validation-in-vue-with-vuelidate/">使用<code>reactive()</code>来设置验证状态</a>。在这种情况下，组合其他州的多个<code>ref()</code>函数和验证规则的<code>reactive()</code>函数是有意义的。</p>
<p>在编写代码时，与团队达成一致以避免混淆是非常重要的。<code>ref()</code>和<code>reactive()</code>是非常高效的声明状态的工具，它们可以一起使用，没有任何技术上的缺陷。</p>
<h2 id="ref-unwrapping"><code>ref()</code>打开包装</h2>
<p>Vue通过在特定情况下自动打开<code>ref()</code>功能来改善使用功能的人体工程学。在这些情况下使用<code>ref()</code>时，我们不需要使用<code>.value</code>，因为Vue会自动为我们解包。</p>
<p>Vue为我们打开<code>ref()</code>函数的一个地方是在模板中。当从模板中访问一个<code>ref()</code>时，我们可以在不使用<code>.value</code>的情况下检索<code>ref()</code>的值，如下图和上例所示:</p>
<pre class="language-javascript hljs">&lt;template&gt;
  &lt;div&gt;
    &lt;button @click="increase"&gt;Clicked {{xTimes}}&lt;/button&gt;
  &lt;/div&gt;
&lt;/template&gt;
&lt;script&gt;
import {ref} from "vue"
export default {
  setup() {
    const xTimes = ref(0)
    return {xTimes}
  },
  methods: {
    increase() {
      this.xTimes++
    }    
  }
}
&lt;/script&gt;
</pre>
<p>当一个<code>ref()</code>被设置为一个<code>reactive()</code>对象的值时，Vue也会在我们访问它的时候自动为我们解开<code>ref()</code>，如下图所示:</p>
<pre class="language-javascript hljs">&lt;template&gt;
  &lt;div&gt;
    &lt;button @click="increase"&gt;Clicked {{ state.count }}&lt;/button&gt;
  &lt;/div&gt;
&lt;/template&gt;
&lt;script setup&gt;
import { ref, reactive } from "vue";

const state = reactive({
  count: ref(0),
});

function increase() {
  state.count++;
}
&lt;/script&gt;
</pre>
<h2 id="conclusion">结论</h2>
<p>应用反应性可以帮助你写出更简洁的代码。在本文中，我们学习了如何使用<code>reactive()</code>和<code>ref()</code>函数处理Vue中的反应性。此外，我们还了解了它们与Vue 2选项API以及Vue 3组合API的关系，讨论了何时使用它们。</p>
<p>我希望你喜欢这篇文章，如果你有任何问题，一定要留下评论。谢谢！</p><div class="code-block code-block-20">
<div class="blog-plug inline-plug vue-inline"><h2>像用户一样体验您的Vue应用</h2><p>调试Vue.js应用程序可能会很困难，尤其是当用户会话期间有几十个(如果不是几百个)突变时。如果您对监视和跟踪生产中所有用户的Vue突变感兴趣，</p><a href="https://lp.logrocket.com/blg/vue-signup" target="_blank">try LogRocket</a><p>. </p><a class="signup" href="https://lp.logrocket.com/blg/vue-signup" target="_blank" rel="noopener noreferrer"><img class="alignnone size-full wp-image-46 jetpack-lazy-image" src="../Images/0d269845910c723dd7df26adab9289cb.png" alt="LogRocket Dashboard Free Trial Banner" data-lazy-src="https://files.readme.io/00591d0-687474703a2f2f692e696d6775722e636f6d2f6a3049327856572e706e67.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://files.readme.io/00591d0-687474703a2f2f692e696d6775722e636f6d2f6a3049327856572e706e67.png"/><noscript><img data-lazy-fallback="1" class="alignnone size-full wp-image-46" src="../Images/0d269845910c723dd7df26adab9289cb.png" alt="LogRocket Dashboard Free Trial Banner" data-original-src="https://files.readme.io/00591d0-687474703a2f2f692e696d6775722e636f6d2f6a3049327856572e706e67.png"/></noscript></a><a href="https://lp.logrocket.com/blg/vue-signup" target="_blank" rel="noopener noreferrer">https://logrocket.com/signup/</a><p>LogRocket 就像是网络和移动应用程序的DVR，记录你的Vue应用程序中发生的一切，包括网络请求、JavaScript错误、性能问题等等。您可以汇总并报告问题发生时应用程序的状态，而不是猜测问题发生的原因。</p><p>LogRocket Vuex插件将Vuex突变记录到LogRocket控制台，为您提供导致错误的环境，以及出现问题时应用程序的状态。</p><p>现代化您调试Vue应用的方式- <a class="signup" href="https://lp.logrocket.com/blg/vue-signup" target="_blank" rel="noopener noreferrer">开始免费监控</a>。</p></div>


</div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
<html>
<head>
<title>Create reusable components with Mitosis and Builder.io - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>使用有丝分裂和 Builder 创建可重用组件</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/creating-reusable-components-mitosis-builder-io/#0001-01-01">https://blog.logrocket.com/creating-reusable-components-mitosis-builder-io/#0001-01-01</a></blockquote><div><article class="article-post">
<p>开发团队面临的一个共同挑战是使用相同的语言；当一个子团队正在使用 Vue 时，另一个子团队可能正在使用 React，这会导致多余的工作，并迫使您创建两次共享组件。</p>
<p>在本教程中，我们将探索<a href="https://github.com/BuilderIO/mitosis">有丝分裂</a>，这是一个工具，除了像 Angular、React 和 Vue 这样的框架和库之外，它还可以将代码编译成标准 JavaScript，允许您创建可重用的组件。</p>
<p>我们将回顾一些背景信息，以澄清您何时应该使用有丝分裂，然后在一个新项目中安装有丝分裂以查看它的运行情况。我们开始吧！</p>
<h2>有丝分裂与 web 组件</h2>
<p>虽然一些开发人员最初转向 web 组件来创建可重用组件，但他们遇到了诸如 web 组件的浏览器兼容性及其底层方法等问题，这使得创建可重用组件成为一个密集的过程。</p>
<p>类似地，像 React 这样的库的工作流使得整合 web 组件变得困难，导致了像 Google 的 LitElement、Ionic 和 Stencil.js 这样的解决方案的产生。</p>
<p>与此同时，苗条身材和结实身材也出现了类似的趋势。Svelte 和 SolidJS 旨在构建应用程序，通过将源代码编译成标准 JavaScript，创建比 web 组件更小、更快的包，获得了巨大的性能收益。</p>
<p>有丝分裂建立在 Svelte 和 SolidJS 的功能上，采用相同的编译速度，并允许您从相同的代码库将组件重新编译成不同的框架和库。编译后的组件像框架中的任何其他组件一样工作。</p>
<p>与 SolidJS 类似，Mitosis 使用 JSX 的一个版本将组件编译成 JSON。插件然后将组件编译到不同的目标，允许您在两个方向上创建工具:</p>
<ul>
<li>可以转换成有丝分裂 JSON 的代码</li>
<li>将 JSON 编译或序列化到目标框架的插件</li>
</ul>
<p>由于这些原因，有丝分裂支持无代码工具。例如，<a href="https://www.builder.io/"> Builder.io </a>允许你使用可视化工具创建你的网站，然后编译成你选择的框架。Builder.io 充当 CMS，但由有丝分裂驱动。</p>
<p>有丝分裂使用 WYSIWYG 编辑和 SPA 框架进行编译。现在我们已经了解了有丝分裂是如何工作的，让我们用有丝分裂创建一个组件。</p>
<h2 id="gettingstartedwithmitosis">有丝分裂入门</h2>
<p>首先，我们将安装有丝分裂 CLI:</p>
<pre class="language-bash hljs">npm install -g @builder.io/mitosis-cli
</pre>
<p>在您的计算机上创建一个空文件夹。在您的终端中，打开文件夹并创建一个新的 npm 项目:</p>
<pre class="language-bash hljs">npm init -y
</pre>
<p>接下来，我们将安装有丝分裂:</p>
<pre class="language-bash hljs">npm install @builder.io/mitosis
</pre>
<p>创建一个名为<code>component.lite.jsx</code>的文件。<code>lite.jsx</code>是有丝分裂项目的扩展。接下来，我们将安装 Builder.io VS 代码扩展，它为<code>lite.jsx</code>文件提供语法高亮显示。</p>
<p>在<code>component.lite.jsx</code>文件中，添加以下代码:</p>
<pre>import { useState, Show, For } from "@builder.io/mitosis";
export default function Component(props){
const state = useState({count: 0})
</pre>
<p>在上面的代码中，我们使用<code>useState</code>钩子声明状态。<span>现在，当状态对象中的任何属性发生变化时，UI 都会呈现。</span></p>
<p>接下来，将下面的代码块添加到<code>component.lite.jsx</code>，它将像 React 或 SolidJS 一样返回 JSX:</p>
<pre>    return (&lt;div&gt;
        {/* DISPLAY SOME JSX CONDITIONALLY */}
        &lt;Show when={state.count &gt; 10}&gt;
            &lt;h1&gt;You Win!!!&lt;/h1&gt;    
        &lt;/Show&gt;

        {/* DISPLAY THE COUNT */}
        &lt;h1&gt;{state.count}&lt;/h1&gt;

        {/* BUTTON TO ADD TO THE COUNT */}
        &lt;button onClick={(event) =&gt; {state.count += 1}}&gt;Click to Add One&lt;/button&gt;
    &lt;/div&gt;)
}
</pre>
<p>在上面的代码中，<code>show</code>组件允许我们有条件地呈现 UI。因为状态是用简单的重新分配来更新的，所以不需要添加我们在 React 中使用的<code>setState</code>函数。最后，请注意，我们所有的状态都可以捆绑到一个对象中。</p>
<p>现在我们的组件已经构建好了，让我们来看一些编译到不同框架的组件的例子！</p>
<h2>有丝分裂中的编译</h2>
<h3>反应</h3>
<p>让我们使用有丝分裂将组件编译成 React 组件:</p>
<pre>mitosis compile --to=react component.lite.jsx &gt; component.jsx</pre>
<p><code>--to=</code>标志让我们选择将有丝分裂组件编译到的框架。当编译为 React 时，我们将得到以下输出:</p>
<pre>import { useContext } from "react";
import { useLocalObservable } from "mobx-react-lite";
export default function Component(props) {
  const state = useLocalObservable(() =&gt; ({ count: 0 }));
  return (
    &lt;div&gt;
      {state.count &gt; 10 &amp;&amp; (
        &lt;&gt;
          &lt;h1&gt;You Win!!!&lt;/h1&gt;
        &lt;/&gt;
      )}
      &lt;h1&gt;{state.count}&lt;/h1&gt;
      &lt;button
        onClick={(event) =&gt; {
          state.count += 1;
        }}
      &gt;
        Click to Add One
      &lt;/button&gt;
    &lt;/div&gt;
  );
}
</pre>
<h3>某视频剪辑软件</h3>
<pre>--to=vue component.lite.jsx &gt; component.vue
</pre>
<p>当编译成 Vue 时，我们的组件看起来像下面的代码:</p>
<pre>&lt;template&gt;
  &lt;div&gt;
    {{/* DISPLAY SOME JSX CONDITIONALLY */}}
    &lt;template v-if="count &gt; 10"&gt;
      &lt;h1&gt;You Win!!!&lt;/h1&gt;
    &lt;/template&gt;

    {{/* DISPLAY THE COUNT */}}
    &lt;h1&gt;{{ count }}&lt;/h1&gt;

    {{/* BUTTON TO ADD TO THE COUNT */}}
    &lt;button @click="count += 1"&gt;Click to Add One&lt;/button&gt;
  &lt;/div&gt;
&lt;/template&gt;
&lt;script&gt;
export default {
  name: "Component",

  data: () =&gt; ({ count: 0 }),
};
&lt;/script&gt;
</pre>
<h3>苗条的</h3>
<pre>--to=svelte component.lite.jsx &gt; component.svelte
</pre>
<p>当我们将有丝分裂组件编译成 Svelte 时，我们将得到以下输出:</p>
<pre class="language-svelte hljs">&lt;script&gt;

     let  count= 0

&lt;/script&gt;

&lt;div &gt;

  {#if count &gt; 10 }       
    &lt;h1 &gt;You Win!!!&lt;/h1&gt;
  {/if}

  &lt;h1 &gt;{count}&lt;/h1&gt;

  &lt;button  on:click="{event =&gt; 
    count += 1;
  }" &gt;Click to Add One&lt;/button&gt;

&lt;/div&gt;
</pre>
<h3>有角的</h3>
<pre class="language-typescript hljs">--to=angular component.lite.jsx &gt; component.tsx
</pre>
<p>当我们将有丝分裂组件编译成 Angular 时，它看起来像下面的代码:</p>
<pre class="language-typescript hljs">import { Component } from "@angular/core";

@Component({
  selector: "component",
  template: 
    &lt;div&gt;
      &lt;ng-container *ngIf="count &gt; 10"&gt;
        &lt;h1&gt;You Win!!!&lt;/h1&gt;
      &lt;/ng-container&gt;

      &lt;h1&gt;{{count}}&lt;/h1&gt;

      &lt;button
        (click)="
      count += 1;
    "
      &gt;
        Click to Add One
      &lt;/button&gt;
    &lt;/div&gt;
  ,
})
export default class Component {
  count = 0;
}
</pre>
<h3>web 组件</h3>
<pre>--to=customElement component.lite.jsx &gt; component.js
</pre>
<p>当编译成 web 组件时，我们将得到以下输出:</p>
<pre>/**
 * Usage:
 *
 *  &lt;component&gt;&lt;/component&gt;
 *
 */
class Component extends HTMLElement {
  constructor() {
    super();

    const self = this;
    this.state = { count: 0 };

    // Event handler for 'click' event on button-1
    this.onButton1Click = (event) =&gt; {
      this.state.count += 1;
      this.update();
    };
  }

  connectedCallback() {
    this.innerHTML = `
      &lt;div&gt;
        &lt;span data-name="show"&gt;
          &lt;h1&gt;You Win!!!&lt;/h1&gt;
        &lt;/span&gt;

        &lt;h1&gt;
         &lt;span data-name="div-1"&gt;&lt;!-- state.count --&gt;&lt;/span&gt;
        &lt;/h1&gt;

        &lt;button data-name="button-1"&gt;Click to Add One&lt;/button&gt;
      &lt;/div&gt;
     &lt;style&gt;&lt;/style&gt;`;
    this.update();
  }

  update() {
    this.querySelectorAll("[data-name='show']").forEach((el) =&gt; {
      el.style.display = this.state.count &gt; 10 ? "inline" : "none";
    });

    this.querySelectorAll("[data-name='div-1']").forEach((el) =&gt; {
      el.innerText = this.state.count;
    });

    this.querySelectorAll("[data-name='button-1']").forEach((el) =&gt; {
      el.removeEventListener("click", this.onButton1Click);
      el.addEventListener("click", this.onButton1Click);
    });
  }
}

customElements.define("component", Component);
</pre>
<p>正如您所看到的，安装有丝分裂，创建一个组件，然后将其编译成您选择的语言、库或框架是非常简单的。我们在本教程中讨论了几个例子，但是仅仅触及了皮毛；其他编译目标包括 Swift、Liquid.js、SolidJS、React Native 等。</p>
<h2>结论</h2>
<p>当不可能和你的团队中的其他人使用相同的语言时，有丝分裂是一个有用的工具，通过减少多余的工作来节省时间。</p>
<p>有丝分裂允许你为一个单独的组件编写一个代码库，然后将它编译成许多目标中的一个。它促进了低代码和无代码解决方案，以创建快速、反应式的应用程序。</p>
<p>我们探索了 Builder.io 插件，但是另一个流行的插件是<a href="https://github.com/builderio/figma-html"> figma-html </a>插件，它<span>允许你把你的 figma 设计变成任何框架的代码。</span></p>
<p>当您构建自己的可重用组件时，您可以使用 Builder.io 的<a href="https://jsx-lite.builder.io/?outputTab=vue"> JSX-lite fiddle </a>来查看可视化结果。然而，在撰写本文时，该功能仍处于早期预览阶段。我希望你喜欢这个教程！</p><div class="code-block code-block-1">
<div class="blog-plug base-cta"><h2>使用<a class="signup" href="https://lp.logrocket.com/blg/signup" target="_blank" rel="noopener noreferrer"> LogRocket </a>消除传统错误报告的干扰</h2>
<a href="https://lp.logrocket.com/blg/signup" class="signup" target="_blank" rel="noopener noreferrer"><img class="alignnone size-full wp-image-46 jetpack-lazy-image" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/><noscript><img data-lazy-fallback="1" class="alignnone size-full wp-image-46" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/></noscript></a>
<p><a href="https://lp.logrocket.com/blg/signup" target="_blank" rel="noopener noreferrer"> LogRocket </a>是一个数字体验分析解决方案，它可以保护您免受数百个假阳性错误警报的影响，只针对几个真正重要的项目。LogRocket 会告诉您应用程序中实际影响用户的最具影响力的 bug 和 UX 问题。</p>
<p>然后，使用具有深层技术遥测的会话重放来确切地查看用户看到了什么以及是什么导致了问题，就像你在他们身后看一样。</p>
<p>LogRocket 自动聚合客户端错误、JS 异常、前端性能指标和用户交互。然后 LogRocket 使用机器学习来告诉你哪些问题正在影响大多数用户，并提供你需要修复它的上下文。</p>
<p>关注重要的 bug—<a class="signup" href="https://lp.logrocket.com/blg/signup-issue-free" target="_blank" rel="noopener noreferrer">今天就试试 LogRocket】。</a></p></div></div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
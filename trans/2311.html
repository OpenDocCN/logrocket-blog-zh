<html>
<head>
<title>Making HTTP requests in Rust with Reqwest - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>在 Rust 中使用 Reqwest - LogRocket 博客发出 HTTP 请求</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/making-http-requests-rust-reqwest/#0001-01-01">https://blog.logrocket.com/making-http-requests-rust-reqwest/#0001-01-01</a></blockquote><div><article class="article-post">
<p>由于强大的开源社区，Rust 似乎变得越来越强大。Rust 已经成为全栈应用的一个可行选项(<a href="https://rocket.rs/" target="_blank" rel="noopener"> Rocket </a>就是一个有趣的例子)。</p>
<p>但是随着无限的应用程序而来的是对无限的数据连接的需求。那么，我们如何从某个地方请求数据呢？</p>
<p>在我们的机器上保存数据转储和 CLI 输入并不有趣。让我们了解 Rust 的<a href="https://github.com/seanmonstar/reqwest" target="_blank" rel="noopener"> Reqwest </a>库如何:</p>
<ul>
<li>发出基本的 GET 和 POST 请求</li>
<li>使用标题验证和请求内容类型</li>
<li>将 JSON 序列化为可用的、类型安全的结构</li>
<li>帮助我们构建一个基本的 Spotify 搜索客户端</li>
</ul>
<h2>什么是铁锈？</h2>
<p>如果您是 Rust 新手，那么对于任何编程背景来说，它都是一种非常受欢迎的语言。我认为它是 c 的现代等价物。但是为了使严格的类型和内存管理更易于管理，它增加了人类可读的编译时错误的细节和函数式编程特性，如<a href="https://doc.rust-lang.org/rust-by-example/flow_control/match.html" target="_blank" rel="noopener">“匹配”表达式</a>。</p>
<p>更重要的是，Rust 提供了一个欣欣向荣的贡献者社区和大量优秀的 T2 教程。</p>
<h2>Reqwest 是什么？</h2>
<p>Reqwest 库是为使用<a href="https://developer.mozilla.org/en-US/docs/Web/HTTP" target="_blank" rel="noopener"> HTTP 协议</a>获取资源而构建的。它提供了一个简化的 API，可以向一个给定的 URL 发出<code>get</code>和<code>post</code>请求，还提供了一个全功能的<code>Client</code>模块，可以应用头部、cookies、重定向策略等。</p>
<p>Reqwest 遵循 Rust 的异步协议，使用“<a href="https://rust-lang.github.io/async-book/01_getting_started/01_chapter.html" target="_blank" rel="noopener">期货</a>”如果你不熟悉 Rust 的异步编程故事，它有两个特性:</p>
<ul>
<li><strong>标志表示我们的异步代码块</strong>(<code>await</code>关键字)。如果您在 JavaScript 中使用过<code>await</code>关键字，它在 Rust 中的工作方式类似</li>
<li>识别这些标志并执行我们的异步程序的运行时。Rust 采用了<code>async</code>关键字来标记我们应该等待响应的函数和块范围。然而，Reqwest 也依赖于<a href="https://github.com/tokio-rs/tokio" target="_blank" rel="noopener"> Tokio </a>运行时来有效地排队异步事件</li>
</ul>
<p>要了解更多，还可以查看<a href="https://rust-lang.github.io/async-book/01_getting_started/01_chapter.html" target="_blank" rel="noopener"> Rust 古雅的异步编程书籍</a>。</p>
<h2>使用 Reqwest 构建应用程序</h2>
<blockquote><p><strong>免责声明</strong>:该演示使用了 2021 年 10 月记录的 Spotify API。从那时起，他们的 API +认证协议可能已经改变了！但是不要担心，从这个演示中学到的知识仍然适用。</p></blockquote>
<p>对于我们的项目，我们将使用<a href="https://developer.spotify.com/documentation/web-api/" target="_blank" rel="noopener"> Spotify API </a>来构建一个简单的搜索客户端，以快速获取歌曲链接并与朋友分享。为了简单起见，我们跳过了官方的认证流程，所以如果你想跟着做，<a href="https://developer.spotify.com/console/get-search-item/" target="_blank" rel="noopener">点击这里</a>来获取一个你可以使用的示例 API 令牌。如果您需要，可以免费创建帐户。</p>
<h2>创建我们的首个<code>get</code> Reqwest</h2>
<p>让我们进入一些基本的<code>get</code>和<code>post</code>请求。首先，用<a href="https://doc.rust-lang.org/cargo/getting-started/first-steps.html" target="_blank" rel="noopener"> Cargo </a>创建一个新项目，并向<code>cargo.toml</code>添加一些依赖项:</p>
<pre class="language-rust hljs">[dependencies]
reqwest = { version = "0.11", features = ["json"] } # reqwest with JSON parsing support
futures = "0.3" # for our async / await blocks
tokio = { version = "1.12.0", features = ["full"] } # for our async runtime
</pre>
<p>现在，让我们给 Spotify 的一个 API 端点打个电话:</p>
<pre class="language-rust hljs">use reqwest;

// tokio let's us use "async" on our main function
#[tokio::main]
async fn main() {
    // chaining .await will yield our query result
    let result = reqwest::get("https://api.spotify.com/v1/search").await
}
</pre>
<p>相当简单！让我们看看印刷品给了我们什么:</p>
<pre class="language-rust hljs">println!("{:?}", result)

// 👉 Ok(Response { url: Url { scheme: "https", cannot_be_a_base: false, username: "", password: None, host: Some(Domain("api.spotify.com")), port: None, path: "/v1/search", query: None, fragment: None }, status: 401, headers: {"www-authenticate": "Bearer realm=\"spotify\"", "access-control-allow-origin": "*", "access-control-allow-headers": "Accept, App-Platform, Authorization...
</pre>
<p>嗯，我们收到的数据比预期的多。怎么会这样这是因为任何请求的初始响应都将是服务器的直接<code>Response</code>对象。</p>
<p>如果您曾经在浏览器中使用过检查器工具来观察网络活动，您可能以前见过这些栏中的一些。<code>Status</code>是一个用于匹配错误条件的有用字段，例如，这将我们带到下一节。</p>
<h3>匹配于<code>StatusCode</code></h3>
<p>您可能会希望根据响应分支到不同的行为。我们可以匹配请求的<code>StatusCode</code>:</p>
<pre class="language-rust hljs">match response.status() {
    reqwest::StatusCode::OK =&gt; {
        println!("Success! {:?}");
    },
    reqwest::StatusCode::UNAUTHORIZED =&gt; {
        println!("Need to grab a new token");
    },
    _ =&gt; {
        panic!("Uh oh! Something unexpected happened.");
    },
};
</pre>
<p>一旦我们稍后开始反序列化有效响应，这将被证明特别有用，因为与有效输出相比，错误通常具有不同的响应体。</p>
<h3>解析响应正文</h3>
<p>如果我们想要实际的响应体，我们需要链接第二个函数来指定我们正在解析的内容。让我们先尝试一下<code>.text()</code>字段，并将其作为明文处理:</p>
<pre class="language-rust hljs">#[tokio::main]
async fn main() {
    let response = reqwest::get("https://api.spotify.com/v1/search")
        .await
        // each response is wrapped in a `Result` type
        // we'll unwrap here for simplicity
        .unwrap()
        .text()
        .await;
    println!("{:?}", response);
}
// 👉 Ok("{\n  \"error\": {\n    \"status\": 401,\n    \"message\": \"No token provided\"\n  }\n}")
</pre>
<p>这里没什么可看的！因为我们没有提供身份验证令牌，所以我们的搜索查询遇到了 401，这应该属于前面的<code>match</code>中的<code>reqwest::StatusCode::UNAUTHORIZED</code>情况。</p>
<p>那么我们如何获得一个<code>200</code>状态响应呢？我们来谈谈头球。</p>
<h2>将内容类型指定为标题</h2>
<p>让我们为我们的查询添加几个标题:</p>
<ul>
<li><code>content_type</code>和<code>accept</code>来确认我们想要一个 JSON 形式的响应</li>
<li><code>authorization</code>通过我们的 Spotify 帐户令牌</li>
</ul>
<p>我们不能将这些头直接传递给<code>reqwest::get</code>。相反，我们需要使用<code>client</code>模块将我们的头链接在一起。让我们重构之前的查询，首先使用<code>client</code>:</p>
<pre class="language-rust hljs">#[tokio::main]
async fn main() {
    let client = reqwest::Client::new();
    let response = client
        .get("https://api.spotify.com/v1/search")
        // confirm the request using send()
        .send()
        .await
        // the rest is the same!
        .unwrap()
        .text()
        .await;
    println!("{:?}", response);
}
</pre>
<p>现在我们有了一个<code>client</code>，我们可以添加我们的头部配置，就像这样:</p>
<pre class="language-rust hljs">let response = client
    .get("https://api.spotify.com/v1/search")
    .header(AUTHORIZATION, "Bearer [AUTH_TOKEN]")
    .header(CONTENT_TYPE, "application/json")
    .header(ACCEPT, "application/json")
    .send()
    ...
</pre>
<p><code>[AUTH_TOKEN]</code>是你账户的 OAuth 令牌(<a href="https://developer.spotify.com/console/get-search-item/?q=Muse&amp;type=track&amp;market=US&amp;limit=5&amp;offset=5&amp;include_external=" target="_blank" rel="noopener">这里抓一个</a>)。如果我们现在记录我们的响应，我们应该看到…一个不同的错误状态！</p>
<p>我们应该得到一个错误 400 错误请求，而不是 401 授权错误。这是因为我们还没有指定要搜索的内容，所以让我们这样做:</p>
<pre class="language-rust hljs">let url = format!(
    "https://api.spotify.com/v1/search?q={query}&amp;type=track,artist",
    // go check out her latest album. It's 🔥
    query = "Little Simz"
);
// the rest is the same as before!
let client = reqwest::Client::new();
let response = client
    .get(url)
    .header(AUTHORIZATION, "Bearer [AUTH_TOKEN]")
    .header(CONTENT_TYPE, "application/json")
    .header(ACCEPT, "application/json")
    .send()
    .await
    .unwrap();
println!("Success! {:?}", response)
// 👉 Ok("{\n  \"artists\" : {\n    \"href\" : \"https://api.spotify.com/v1/search?query=Lil+Simz&amp;type=artist&amp;offset=0&amp;limit=20\",\n    \"items\" : [ {\n      \"external_urls\"...
</pre>
<h2>反序列化到 JSON</h2>
<p>现在我们已经收到了大量的搜索结果。我们如何把它变成一个有用的数据结构呢？</p>
<p>好吧，让我们使用嵌套的<code>structs</code>来建模我们想要接收的数据。根据您的使用情况，结构会有很大的不同，但我们需要 Spotify 搜索结果的模型如下:</p>
<pre class="language-rust hljs">use serde::{Deserialize, Serialize};

#[derive(Serialize, Deserialize, Debug)]
struct ExternalUrls {
    spotify: String,
}
#[derive(Serialize, Deserialize, Debug)]
struct Artist {
    name: String,
    external_urls: ExternalUrls,
}
#[derive(Serialize, Deserialize, Debug)]
struct Album {
    name: String,
    artists: Vec&lt;Artist&gt;,
    external_urls: ExternalUrls,
}
#[derive(Serialize, Deserialize, Debug)]
struct Track {
    name: String,
    href: String,
    popularity: u32,
    album: Album,
    external_urls: ExternalUrls,
}
#[derive(Serialize, Deserialize, Debug)]
struct Items&lt;T&gt; {
    items: Vec&lt;T&gt;,
}
#[derive(Serialize, Deserialize, Debug)]
struct APIResponse {
    tracks: Items&lt;Track&gt;,
}
</pre>
<p>注意:在撰写本文时，Rust 不支持嵌套结构，所以我们将把每一级分解成单独命名的可序列化结构。</p>
<p>您还会注意到<code>Serialize</code>派生，它允许 Reqwest 通过<a href="https://serde.rs/" target="_blank" rel="noopener"> Serde </a>将原始 API 响应转换为 Rust 友好类型。确保将 Serde 添加为项目依赖项，如下所示:</p>
<pre class="language-rust hljs">[dependencies]
...
serde = { version = "1.0", features = ["derive"] }
serde_json = "1.0"
</pre>
<p>现在我们准备解析我们的响应。我们应该只在 API 以 200 状态响应时尝试解析。否则，我们将遇到解析错误消息到我们的<code>APIResponse</code>结构的问题。</p>
<p>让我们根据状态代码恢复前面的<code>match</code>语法:</p>
<pre class="language-rust hljs">let response = client
    .get(url)
    ...
match response.status() {
    reqwest::StatusCode::OK =&gt; {
        // on success, parse our JSON to an APIResponse
        match response.json::&lt;APIResponse&gt;().await {
            Ok(parsed) =&gt; println!("Success! {:?}", parsed),
            Err(_) =&gt; println!("Hm, the response didn't match the shape we expected."),
        };
    }
    reqwest::StatusCode::UNAUTHORIZED =&gt; {
        println!("Need to grab a new token");
    }
    other =&gt; {
        panic!("Uh oh! Something unexpected happened: {:?}", other);
    }
};
</pre>
<p>幸运的话，我们应该得到一个可以使用的 API 输出。我们还通过缩小结构上的键来过滤掉 API 响应中我们不感兴趣的键。</p>
<p>如果您习惯于 JavaScript 和 TypeScript，其中可能会出现意外的对象键，那么这应该是一个受欢迎的附加功能！</p>
<h2>创建 CLI 客户端</h2>
<p>让我们将这些数据转化为人类可读的东西。</p>
<p>我们会在我们的足迹上运行一个基本的地图:</p>
<pre class="language-rust hljs">fn print_tracks(tracks: Vec&lt;&amp;Track&gt;) {
    for track in tracks {
        println!("🔥 {}", track.name);
        println!("💿 {}", track.album.name);
        println!(
            "🕺 {}",
            track
                .album
                .artists
                .iter()
                .map(|artist| artist.name.to_string())
                .collect::&lt;String&gt;()
        );
        println!("🌎 {}", track.external_urls.spotify);
        println!("---------")
    }
}
</pre>
<p>然后在我们的<code>match</code>中调用这个打印函数:</p>
<pre class="language-rust hljs">match response.status() {
    reqwest::StatusCode::OK =&gt; {
        match response.json::&lt;APIResponse&gt;().await {
            Ok(parsed) =&gt; print_tracks(parsed.tracks.items.iter().collect()),
            Err(_) =&gt; println!("Hm, the response didn't match the shape we expected."),
        };
    }
...
</pre>
<p>我们还应该接受您希望作为 CLI 参数的任何查询:</p>
<pre class="language-rust hljs">let args: Vec&lt;String&gt; = env::args().collect();
let search_query = &amp;args[1];
let url = format!(
    "https://api.spotify.com/v1/search?q={query}&amp;type=track,artist",
    query = search_query
);
...
</pre>
<p>现在，我们可以从我们的终端运行这样的搜索输出:</p>
<pre class="language-rust hljs">cargo run "Little Simz"
     Running `target/debug/spotify-search`
🔥 Venom
💿 Venom
🕺 Little Simz
🌎 https://open.spotify.com/track/4WaaWczlVb1UJ24LILsR4C
---------
🔥 Fear No Man
💿 Sometimes I Might Be Introvert
🕺 Little Simz
🌎 https://open.spotify.com/track/6bLkNijhsnr1MWYrO6XnRz
---------
🔥 Venom
💿 GREY Area
🕺 Little Simz
🌎 https://open.spotify.com/track/3A0ITFj6kbb9CggwtPe55f
---------
...
</pre>
<p>就是这样！</p>
<h2>结论</h2>
<p>希望本教程展示了 Reqwest 库是多么强大和简单。如果您需要一些扩展阅读，Reqwest 的文档提供了一些有价值的深入研究的示例，包括:</p>

<p>如果你想探索成品，你可以在 GitHub 上找到<a href="https://github.com/Holben888/spotify-search" target="_blank" rel="noopener">这个 Spotify 搜索！</a></p><div class="code-block code-block-29">
<div class="blog-plug inline-plug rust-plug"><h2><a href="https://lp.logrocket.com/blg/rust-signup" target="_blank">log rocket</a>:Rust 应用的 web 前端的全面可见性</h2><p>调试 Rust 应用程序可能很困难，尤其是当用户遇到难以重现的问题时。如果您对监控和跟踪 Rust 应用程序的性能、自动显示错误、跟踪缓慢的网络请求和加载时间感兴趣，</p><a href="https://lp.logrocket.com/blg/rust-signup" target="_blank">try LogRocket</a><p>. </p><a class="signup" href="https://lp.logrocket.com/blg/rust-signup" target="_blank" rel="noopener noreferrer"><img class="alignnone size-full wp-image-46 jetpack-lazy-image" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/><noscript><img data-lazy-fallback="1" class="alignnone size-full wp-image-46" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/></noscript></a><p>LogRocket 就像是网络和移动应用程序的 DVR，记录你的 Rust 应用程序上发生的一切。您可以汇总并报告问题发生时应用程序的状态，而不是猜测问题发生的原因。LogRocket 还可以监控应用的性能，报告客户端 CPU 负载、客户端内存使用等指标。</p><p>现代化调试 Rust 应用的方式— <a class="signup" href="https://lp.logrocket.com/blg/rust-signup" target="_blank" rel="noopener noreferrer">开始免费监控</a>。</p></div>


</div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
<html>
<head>
<title>Comparing Redux vs. Vuex </title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>Redux vs. Vuex比较</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/comparing-redux-vs-vuex/#0001-01-01">https://blog.logrocket.com/comparing-redux-vs-vuex/#0001-01-01</a></blockquote><div><article class="article-post">
<p>状态是任何应用程序的关键部分，因为它处理数据如何在应用程序内部传递。随着应用程序变得越来越大，状态的管理变得越来越复杂，需要使用中央存储库来访问应用程序数据。这个中央存储库有助于确保应用程序中的状态管理是简单的、原子的和可扩展的。</p>
<p>在本文中，我们将仔细观察并比较当前前端生态系统中最流行的两个状态管理库:<a href="https://redux.js.org"> Redux </a>和<a href="https://vuex.vuejs.org"> Vuex </a>。</p>
<h2 id="contents">内容</h2>

<h2 id="what-is-state-management">什么是状态管理，我们为什么需要它？</h2>
<p>状态管理是读取和更改在应用程序的各个组件之间共享的状态(即数据)的方法。</p>
<p>状态并不总是复杂的。在某些情况下，州可以很小，很容易在本地管理。例如，处理从父组件A到子组件b的数据传递是非常简单的，但是，如果在外部组件J中需要来自组件A的一条信息呢？</p>
<p>在这种情况下，管理状态的一种方法可能是传播数据。然而，这并不总是有效的做法。</p>
<p>如前所述，当应用程序变大时，数据管理往往会变得更加复杂。这推动了对用于存储状态的集中式存储库的需求，这种存储库可以跨各种组件(甚至是不相关的组件)使用，这与钻取相反，钻取对于深度嵌套的组件来说可能是一个难题。</p>
<p>这促进了对全局状态的需求，全局状态是所有应用程序组件可以轻松访问所有应用程序状态的核心来源，几乎没有任何限制。</p>
<h2 id="what-is-redux">Redux是什么？</h2>
<p>自2015年创建以来，Redux已经发展成为React应用程序开发中最受欢迎的<a href="https://blog.logrocket.com/redux-vs-mobx/">状态管理库</a>。它是一个可预测的状态容器，允许我们使用普通的JavaScript，同时强制执行一致的模式，以确保我们的应用程序在客户端、服务器和本机环境中是可靠的，并且易于测试。</p>
<p>除了React，Redux还可以与任何其他JavaScript框架或库一起使用，如Vue.js。然而，Redux最近受到了一些批评<a href="https://blog.logrocket.com/redux-isnt-dead/">，声称它很难使用</a>。这种负面反馈可能是因为编写动作来定义每一个可能的状态变化，然后创建多个reducers来控制这些动作会导致大量的代码，这些代码会很快变得难以管理。</p>
<p>为了解决这个问题，脸书的软件工程师丹·阿布拉莫夫和安德鲁·克拉克以及React的核心团队成员创造了Redux Toolkit。它简化了存储设置，减少了所需的样板文件，使其成为高效Redux开发的首选工具。默认情况下，Redux Toolkit也遵循最佳实践。</p>
<h2 id="how-does-redux-work">Redux是如何工作的？</h2>
<p>在我们了解Redux如何用于管理React应用程序中的状态之前，让我们先了解一下它是如何工作的。</p>
<p>典型的Redux设置包括以下内容:</p>
<ul>
<li><strong>状态</strong>:app中的数据；当组件连接到状态时，状态的更新会导致组件重新呈现</li>
<li><strong>Reducers</strong>:Redux存储更新的媒介；reducer接收一个动作，存储中的状态根据动作类型和有效负载进行操作</li>
<li><strong>动作</strong>:由UI组件触发的功能，目的是更新店铺；动作有一个类型和一个有效负载，它通过一个调度程序发送。虽然类型从字面上定义了发送给缩减器的动作的类型，但是有效负载是由缩减器在存储中更新的数据</li>
</ul>
<p>这里有一张来自<a href="https://redux.js.org/tutorials/essentials/part-1-overview-concepts">redux.js.org</a>的图表，展示了Redux状态管理库中的数据流:</p>
<p><img data-attachment-id="142401" data-permalink="https://blog.logrocket.com/comparing-redux-vs-vuex/attachment/flow-of-data-in-redux/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/11/flow-of-data-in-redux.gif" data-orig-size="730,548" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Flow of data in Redux" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/11/flow-of-data-in-redux-300x225.gif" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/11/flow-of-data-in-redux.gif" decoding="async" class="aligncenter wp-image-142401 size-full jetpack-lazy-image" src="../Images/5fd371c00d17b98cd91d6858e4beb90c.png" alt="Flow of Data in the Redux State Management Library" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2022/11/flow-of-data-in-redux.gif?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/11/flow-of-data-in-redux.gif"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="142401" data-permalink="https://blog.logrocket.com/comparing-redux-vs-vuex/attachment/flow-of-data-in-redux/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/11/flow-of-data-in-redux.gif" data-orig-size="730,548" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Flow of data in Redux" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/11/flow-of-data-in-redux-300x225.gif" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/11/flow-of-data-in-redux.gif" decoding="async" loading="lazy" class="aligncenter wp-image-142401 size-full" src="../Images/5fd371c00d17b98cd91d6858e4beb90c.png" alt="Flow of Data in the Redux State Management Library" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/11/flow-of-data-in-redux.gif"/></noscript>
<h2 id="how-to-manage-state-in-react-using-redux">如何使用Redux管理React中的状态</h2>
<p>让我们仔细看看Redux是如何用于管理React应用程序中应用程序范围的状态的。在本演示中，我们将通过构建一个基本的计数器应用程序来展示实现，从而使事情变得简单。</p>
<h3 id="project-setup">项目设置</h3>
<p>首先，使用下面的命令创建一个React项目，并将其命名为<code>redux-demo</code>:</p>
<pre class="language-javascript hljs">create-react-app redux-demo
</pre>
<p>现在，安装<code>redux</code>包(这将使我们能够在应用程序中使用Redux)和另一个名为<code>react-redux</code>的包，它使得将React应用程序连接到Redux存储和reducers非常简单:</p>
<pre class="language-javascript hljs">npm install redux react-redux
&gt;</pre>
<p>接下来，启动服务器:</p>
<pre class="language-javascript hljs">npm start
</pre>
<p>因为我们关注的是使用Redux，所以我们不会详细讨论构建React组件的细节。</p>
<p>在<code>src</code>文件夹中，创建一个名为<code>components</code>的新文件夹，然后创建两个名为<code>Counter.js</code>和<code>Counter.css</code>的文件。将以下代码添加到<code>Counter.js</code>文件中:</p>
<pre class="language-javascript hljs">const Counter = () =&gt; {
  return (
    &lt;main&gt;
      &lt;h1&gt;Redux Counter&lt;/h1&gt;
      &lt;div&gt;{counter}&lt;/div&gt;
      &lt;button&gt;Increment Counter&lt;/button&gt;
      &lt;button&gt;Decrement Counter&lt;/button&gt;
    &lt;/main&gt;
  );
};

export default Counter;
</pre>
<p>这里，我们有两个按钮，稍后我们将使用它们来增加或减少<code>counter</code>值。</p>
<p>接下来，将<code>Counter.js</code>导入到<code>App.js</code>中。更新后的<code>App.js</code>文件应该是这样的:</p>
<pre class="language-javascript hljs">import Counter from './components/Counter';

function App() {
  return &lt;Counter /&gt;;
}

export default App;
</pre>
<h3 id="setting-up-redux">设置Redux</h3>
<p>在<code>src</code>文件夹中，创建另一个名为<code>store</code>的文件夹；在这个文件夹中创建一个名为<code>index.js</code>的文件。我们还不会订阅商店，因为我们只是在设置<code>counter</code>值；我们还没有准备好开始监听它的状态变化。</p>
<p>接下来，将应用程序连接到Redux商店，以便应用程序内的组件可以使用商店；并导出<code>counterReducer</code>的一个实例。</p>
<p><code>src/store/index.js</code>文件现在应该看起来像这样:</p>
<pre class="language-javascript hljs">import { createStore } from "redux";

const counterReducer = (state = { counter: 0 }, action) =&gt; {
    if (action.type === "increment") {
        return {
            counter: state.counter + 1,
        };
    }
    if (action.type === "decrement") {
        return {
            counter: state.counter - 1,
        };
    }
    return state
};

const store = createStore(counterReducer);
export default store;
</pre>
<h3 id="providing-the-store-and-accessing-data-managed-by-store">提供存储并访问由存储管理的数据</h3>
<p>为了让应用程序组件使用商店作为中央状态存储库，我们必须用从<code>react-redux</code>导入的<code>Provider</code>组件包装根<code>App</code>组件。然后，我们将通过将它作为道具传递给<code>Provider</code>组件来引用商店。</p>
<p>为此，更新<code>src/index.js</code>文件，如下所示:</p>
<pre class="language-javascript hljs">import React from 'react';
import ReactDOM from 'react-dom/client';
import './index.css';
import App from './App';
import { Provider } from 'react-redux';
import store from './store/index'

const root = ReactDOM.createRoot(document.getElementById('root'));
root.render(
  &lt;Provider store={store}&gt;
    &lt;App /&gt;
  &lt;/Provider&gt;
);
</pre>
<p>为了从<code>Counter</code>组件访问存储中的数据，我们将从<code>react-redux</code>库导入<code>useSelector</code>钩子。这个挂钩将使我们能够利用我们希望使用的商店的特定部分。</p>
<p><code>useSelector</code>的另一个好处是它在幕后管理订阅。</p>
<p>我们将使用<code>useSelector</code>钩子从存储中提取<code>counter</code>状态。接下来，我们将传递一个函数，该函数接收由Redux管理的状态和我们想要提取的状态部分。然后，我们将输出<code>counter</code>值，如下所示:</p>
<pre class="language-javascript hljs">import { useSelector } from 'react-redux';

const Counter = () =&gt; {
  const counter = useSelector((state) =&gt; state.counter);

  return (
    &lt;main&gt;
      &lt;h1&gt;Redux Counter&lt;/h1&gt;
      &lt;div&gt;{counter}&lt;/div&gt;
      &lt;button&gt;Increment Counter&lt;/button&gt;
      &lt;button&gt;Decrement Counter&lt;/button&gt;
    &lt;/main&gt;
  );
};

export default Counter;
</pre>
<p>到目前为止，我们已经看到了如何检索由Redux管理的数据。现在，让我们看看如何更新数据。</p>
<h3 id="dispatching-actions-to-update-data">调度操作以更新数据</h3>
<p>为了将<code>counter</code>值增加或减少<code>1</code>，我们将使用<code>react-redux</code>包中的<code>useDispatch</code>钩子。</p><div class="code-block code-block-54">
<hr/>
<h3>更多来自LogRocket的精彩文章:</h3>

<hr/></div>
<p>首先，我们将调用<code>useDispatch</code>，它给了我们一个调度函数，我们可以调用它来调度对Redux存储的操作。接下来，我们将创建可以使用各种按钮调用的方法。我们还将传递类型标识符。</p>
<p>更新后的<code>Counter.js</code>文件如下所示:</p>
<pre class="language-javascript hljs">import { useSelector, useDispatch } from 'react-redux';

const Counter = () =&gt; {
  const counter = useSelector((state) =&gt; state.counter);
  const dispatch = useDispatch();
  const incrementHandler = () =&gt; {
    dispatch({ type: 'increment' });
  };
  const decrementHandler = () =&gt; {
    dispatch({ type: 'decrement' });
  };
  return (
    &lt;main&gt;
      &lt;h1&gt;Redux Counter&lt;/h1&gt;
      &lt;div&gt;{counter}&lt;/div&gt;
      &lt;button onClick={incrementHandler}&gt;Increment Counter&lt;/button&gt;
      &lt;button onClick={decrementHandler}&gt;Increment Counter&lt;/button&gt;
    &lt;/main&gt;
  );
};

export default Counter;
</pre>
<p>现在，当点击<code>increment</code>或<code>decrement</code>按钮时，会发生适当的动作，将<code>counter</code>值增加或减少<code>1</code>。</p>
<p>我们已经仔细研究了如何使用Redux来管理React应用程序中的状态。现在，让我们看看如何使用Vuex来管理Vue应用程序中的状态。</p>
<h2 id="what-is-vuex">什么是Vuex？</h2>
<p>Vue由尤雨溪创建，由Vue核心团队维护。Vuex基于与Redux 相同的<a href="https://blog.logrocket.com/pinia-vs-vuex/">通量架构。Vuex是Vue.js应用程序的状态管理模式和库。</a></p>
<p>有了这个库，应用程序的状态就集中起来了，这样应用程序中的每个组件都可以随时访问应用程序所需的状态。有了Vuex，获取状态变得很容易，而改变状态是有目的的。</p>
<h2 id="how-does-vuex-work">Vuex是如何工作的？</h2>
<p>Vuex是状态、getters、突变和动作的集合:</p>
<ul>
<li><strong> State </strong>:就像Redux中一样，State定义了整个应用程序的全局数据属性；这使得定位特定的数据变得容易，并且允许开发人员容易地拍摄当前应用状态的快照，用于调试或其他目的</li>
<li><strong> Getters </strong>:存储中的计算值。在构建时，我们可能需要基于某个时间点计算派生状态，例如，过滤帖子列表并获得总数。如果这个值将被多个组件使用，那么我们通过使用getters来实现。这将防止我们在不同组件中重复实现相同结果的功能</li>
<li><strong>突变</strong>:提交突变是有效更新Vuex存储中状态的唯一方式。突变就像事件；每个突变都有一个字符串类型和一个处理程序；状态修改由突变处理器执行</li>
<li><strong>动作</strong>:在工作方式上非常类似于突变，但是，不是直接突变状态，动作提交突变，突变状态需要异步操作</li>
</ul>
<p>这里有一张来自<a href="https://vuex.vuejs.org/#what-is-a-state-management-pattern">vuex.vuejs.org</a>的图表，展示了Vuex状态管理库中的数据流:</p>
<p><img data-attachment-id="142406" data-permalink="https://blog.logrocket.com/comparing-redux-vs-vuex/attachment/flow-of-data-in-vuex/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/11/flow-of-data-in-vuex.png" data-orig-size="701,551" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Flow of data in Vuex" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/11/flow-of-data-in-vuex-300x236.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/11/flow-of-data-in-vuex.png" decoding="async" class="aligncenter wp-image-142406 size-full jetpack-lazy-image" src="../Images/a1c689ed9ff9e63ee242e54ccebbce71.png" alt="Flow of Data in the Vuex State Management Library" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2022/11/flow-of-data-in-vuex.png 701w, https://blog.logrocket.com/wp-content/uploads/2022/11/flow-of-data-in-vuex-300x236.png 300w" data-lazy-sizes="(max-width: 701px) 100vw, 701px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2022/11/flow-of-data-in-vuex.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/11/flow-of-data-in-vuex.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="142406" data-permalink="https://blog.logrocket.com/comparing-redux-vs-vuex/attachment/flow-of-data-in-vuex/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/11/flow-of-data-in-vuex.png" data-orig-size="701,551" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Flow of data in Vuex" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/11/flow-of-data-in-vuex-300x236.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/11/flow-of-data-in-vuex.png" decoding="async" loading="lazy" class="aligncenter wp-image-142406 size-full" src="../Images/a1c689ed9ff9e63ee242e54ccebbce71.png" alt="Flow of Data in the Vuex State Management Library" srcset="https://blog.logrocket.com/wp-content/uploads/2022/11/flow-of-data-in-vuex.png 701w, https://blog.logrocket.com/wp-content/uploads/2022/11/flow-of-data-in-vuex-300x236.png 300w" sizes="(max-width: 701px) 100vw, 701px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/11/flow-of-data-in-vuex.png"/></noscript>
<h2 id="how-to-manage-state-in-vuejs-using-vuex">如何使用Vuex管理Vue.js中的状态？</h2>
<p>为了展示Vuex如何用于管理Vue应用程序中的状态，让我们从Redux演示中构建一个计数器应用程序的副本，具有相同的结构和功能。</p>
<h3 id="project-setup-and-creating-the-vuex-store">项目设置和创建Vuex商店</h3>
<p>首先使用下面的命令创建Vue项目名<code>vuex-demo</code>:</p>
<pre class="language-javascript hljs">vue create vuex-demo
</pre>
<p>在Vue项目设置期间，我们会被问及一系列问题。对于本教程，我们采用以下配置:</p>
<table>
<thead>
<tr>
<th><strong>提示</strong></th>
<th><strong>选项</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>请选择一个预设</td>
<td>手动选择功能</td>
</tr>
<tr>
<td>检查项目所需的功能</td>
<td>所有预选选项+ Vuex</td>
</tr>
<tr>
<td>选择您想要用来启动项目的Vue.js版本</td>
<td>3.x</td>
</tr>
<tr>
<td>选择棉绒/格式化程序配置</td>
<td>仅带防错功能的ESLint</td>
</tr>
<tr>
<td>挑选附加棉绒特征</td>
<td>保存时Lint</td>
</tr>
<tr>
<td>你更喜欢把Babel，ESLint等的配置放在哪里？</td>
<td>在专用配置文件中</td>
</tr>
<tr>
<td>将此存储为未来项目的预置？</td>
<td>普通</td>
</tr>
</tbody>
</table>
<p>请注意，从Vuex创建之初就将其安装到我们的应用程序中是多么容易，这可以通过导航到<code>src/store/index</code>找到。</p>
<p>如果应用程序没有Vuex，只需使用以下命令安装库:</p>
<pre class="language-javascript hljs">npm install <a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="582e2d3d2018363d202c">[email protected]</a> --save
</pre>
<p><strong> <em>注意，</em> </strong> <em>在上面的代码中添加</em> @next <em>安装Vuex的最新版本</em></p>
<p>继续，因为我们专注于使用Vuex，我们将保持<code>Counter</code>组件简单。</p>
<p>导航到<code>src</code>文件夹，创建一个名为<code>Counter.vue</code>的文件，并添加以下代码:</p>
<pre class="language-javascript hljs">&lt;template&gt;
  &lt;main&gt;
    &lt;h1&gt;Vuex Counter&lt;/h1&gt;
    &lt;div&gt;0&lt;/div&gt;
    &lt;button&gt;Increment Counter&lt;/button&gt;
    &lt;button&gt;Decrement Counter&lt;/button&gt;
  &lt;/main&gt;
&lt;/template&gt;
</pre>
<p>接下来，将<code>Counter.vue</code>导入到<code>App.vue</code>文件中。<code>App.vue</code>文件应该是这样的:</p>
<pre class="language-javascript hljs">&lt;template&gt;
  &lt;Counter /&gt;
&lt;/template&gt;
&lt;script&gt;
import Counter from './components/Counter.vue';
export default {
  name: 'App',
  components: {
    Counter
  }
}
&lt;/script&gt;

export default App;
</pre>
<p>接下来，我们需要为演示创建一个适当的状态、突变、动作和getters。</p>
<h3 id="using-vuex-store-in-vuejs-components">在Vue.js组件中使用Vuex存储</h3>
<p>状态是存储中的一包属性。因此，为了定义<code>counter</code>值的状态，我们将它作为键值插入到存储中的状态对象。我们也给它一个初始值<code>0</code>，如下所示:</p>
<pre class="language-javascript hljs">import { createStore } from 'vuex';

export default createStore({
  state: {
    counter: 0,
  },
  mutations: {},
  actions: {},
  modules: {},
});
</pre>
<p>为了访问<code>Counter</code>组件中的<code>counter</code>值，我们首先导入商店，然后定位所需的州(在本例中是<code>counter</code>):</p>
<pre class="language-javascript hljs">&lt;template&gt;
  &lt;main&gt;
    &lt;h1&gt;Vuex Counter&lt;/h1&gt;
    &lt;div&gt;{{counter}}&lt;/div&gt;
    &lt;button&gt;Increment Counter&lt;/button&gt;
    &lt;button&gt;Decrement Counter&lt;/button&gt;
  &lt;/main&gt;
&lt;/template&gt;
&lt;script&gt;

import { computed } from '@vue/reactivity';
import store from '../store';

export default {
  setup() {
    const counter = computed(() =&gt; {
      return store.state.counter
    })
    return {
      counter
    };
  },
};
&lt;/script&gt;
</pre>
<p>为了让按钮更新<code>counter</code>值，我们将在<code>Counter</code>组件中创建方法，并分派一个调用突变的动作(在这里我们传递一个有效载荷)来更新状态。从<code>Counter</code>组件传递来的有效载荷用于更新<code>counter</code>状态(通过<code>1</code>对其进行递减或递增)。</p>
<p>为了实现这一点，我们将更新<code>Counter.vue</code>，如下所示:</p>
<pre class="language-javascript hljs">&lt;template&gt;
  &lt;main&gt;
    &lt;h1&gt;Vuex Counter&lt;/h1&gt;
    &lt;div&gt;{{ counter }}&lt;/div&gt;
    &lt;button @click="increment"&gt;Increment Counter&lt;/button&gt;
    &lt;button @click="decrement"&gt;Decrement Counter&lt;/button&gt;
  &lt;/main&gt;
&lt;/template&gt;

&lt;script&gt;
import { computed } from '@vue/reactivity';
import store from '../store';
export default {
  setup() {
    const counter = computed(() =&gt; {
      return store.state.counter
    })
    const increment = () =&gt; {
      store.commit('increment', { value: 1 })
    }
    const decrement = () =&gt; {
      store.commit('decrement', { value: 1 })
    }
    return {
      counter
    };
  },
};
&lt;/script&gt;
</pre>
<p>接下来，更新商店:</p>
<pre class="language-javascript hljs">import { createStore } from 'vuex';
export default createStore({
  state: {
    counter: 0,
  },
  mutations: {
    increment(state, payload) {
      state.counter = state.counter + payload.value;
    },
    decrement(state, payload) {
      state.counter = state.counter - payload.value;
    },
  },
  actions: {},
  modules: {},
});
</pre>
<h3 id="using-getters-to-read-state">使用字母读取状态</h3>
<p>假设我们想读取一个状态的值，也许用它来执行一个外部操作。我们可以使用吸气剂来实现这一点。</p>
<p>在计数器演示中，我们将读取<code>counter</code>值，并在DOM上呈现乘以<code>2</code>的值。</p>
<p>让我们更新存储以使用getters，如下所示:</p>
<pre class="language-javascript hljs">import { createStore } from 'vuex';

export default createStore({
  state: {
    counter: 0,
  },
  mutations: {
    increment(state, payload) {
      state.counter = state.counter + payload.value;
    },
    decrement(state, payload) {
      state.counter = state.counter - payload.value;
    },
  },
  actions: {},
  getters: {
    modifiedCounterValue(state) {
      return state.counter * 2;
    },
  },
  modules: {},
});
</pre>
<p>我们现在可以从<code>App.vue</code>文件中访问<code>modifiedCounterValue</code>。我们使用一个<code>computed</code>属性来实现，如下所示:</p>
<pre class="language-javascript hljs">&lt;template&gt;
  &lt;Counter /&gt;
  &lt;div&gt;Modified counter value: {{modifiedCounterValue}}&lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
import { computed } from '@vue/reactivity';
import Counter from './components/Counter.vue';
import store from './store';

export default {
  name: 'App',
  components: {
    Counter,
  },
  setup() {
    const modifiedCounterValue = computed(() =&gt; {
      return store.getters.modifiedCounterValue
    })
    return {
      modifiedCounterValue,
    }
  }
}
&lt;/script&gt;
</pre>
<h3 id="dispatching-actions-to-update-data-1">调度操作以更新数据</h3>
<p>在Vue中，最好的做法是只在执行异步操作时使用动作。因为我们的小演示不是异步的，所以我们可以仔细阅读<a href="https://vuex.vuejs.org/guide/actions.html"> Vuex docs </a>来了解如何在使用异步操作和处理承诺(比如从API获取数据)时使用动作来调度数据。</p>
<h2 id="conclusion">结论</h2>
<p>Redux和Vuex状态管理库在开发者生态系统中广泛使用。在本文中，我们探索了这两个库，展示了它们是如何工作的，并演示了如何使用它们。我们还查看了Redux工具包，并展示了它如何帮助简化Redux设置、帮助避免常见错误，以及用名为<code>configureStore</code>的改进版本替换<code>createStore</code>。</p>
<p>你可以在<a href="https://redux.js.org/introduction/why-rtk-is-redux-today">官方文档</a>中阅读更多关于Redux Toolkit的内容。同样，你可以从它的<a href="https://vuex.vuejs.org">官方文档</a>中了解更多关于Vuex的信息。</p>
<p>这些库可以作为所有应用程序状态的可预测的中央存储，但是最好避免在不太复杂的应用程序中使用它们，因为这可能会成为一种乏味而繁琐的方法。</p>
<p>与Vuex相比，Redux是一个更受欢迎和支持更好的库，但Vuex似乎是一个更好的维护性能的状态管理库。然而，选择权在你，取决于你具体的项目需求。</p>
<p>我希望这篇文章能帮助你更好地理解Redux和Vuex是如何工作的，并为你提供有用的信息来决定哪个解决方案最适合你的项目。</p><div class="code-block code-block-20">
<div class="blog-plug inline-plug vue-inline"><h2>像用户一样体验您的Vue应用</h2><p>调试Vue.js应用程序可能会很困难，尤其是当用户会话期间有几十个(如果不是几百个)突变时。如果您对监视和跟踪生产中所有用户的Vue突变感兴趣，</p><a href="https://lp.logrocket.com/blg/vue-signup" target="_blank">try LogRocket</a><p>. </p><a class="signup" href="https://lp.logrocket.com/blg/vue-signup" target="_blank" rel="noopener noreferrer"><img class="alignnone size-full wp-image-46 jetpack-lazy-image" src="../Images/0d269845910c723dd7df26adab9289cb.png" alt="LogRocket Dashboard Free Trial Banner" data-lazy-src="https://files.readme.io/00591d0-687474703a2f2f692e696d6775722e636f6d2f6a3049327856572e706e67.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://files.readme.io/00591d0-687474703a2f2f692e696d6775722e636f6d2f6a3049327856572e706e67.png"/><noscript><img data-lazy-fallback="1" class="alignnone size-full wp-image-46" src="../Images/0d269845910c723dd7df26adab9289cb.png" alt="LogRocket Dashboard Free Trial Banner" data-original-src="https://files.readme.io/00591d0-687474703a2f2f692e696d6775722e636f6d2f6a3049327856572e706e67.png"/></noscript></a><a href="https://lp.logrocket.com/blg/vue-signup" target="_blank" rel="noopener noreferrer">https://logrocket.com/signup/</a><p>LogRocket 就像是网络和移动应用程序的DVR，记录你的Vue应用程序中发生的一切，包括网络请求、JavaScript错误、性能问题等等。您可以汇总并报告问题发生时应用程序的状态，而不是猜测问题发生的原因。</p><p>LogRocket Vuex插件将Vuex突变记录到LogRocket控制台，为您提供导致错误的环境，以及出现问题时应用程序的状态。</p><p>现代化您调试Vue应用的方式- <a class="signup" href="https://lp.logrocket.com/blg/vue-signup" target="_blank" rel="noopener noreferrer">开始免费监控</a>。</p></div>


</div>

<p class="clearfix"/>
 <p class="clearfix"/>
</article>

</div>    
</body>
</html>
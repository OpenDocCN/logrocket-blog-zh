<html>
<head>
<title>The guide to converting Angular apps to React </title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>将角度应用程序转换为反应的指南</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/guide-converting-angular-apps-react/#0001-01-01">https://blog.logrocket.com/guide-converting-angular-apps-react/#0001-01-01</a></blockquote><div><article class="article-post">
<p>随着开发人员寻求更小更快的项目，将Angular应用转换为React已经变得很流行。它们是目前最流行的两种JavaScript前端框架，但是随着项目规模、功能和复杂性的增长，有必要从一个框架迁移到另一个框架。</p>
<p>迁移将使您的工程团队有机会将您的项目更新到现代应用程序所期望的标准，并更好地应对软件开发生命周期中不断变化的方面(主要是在维护方面)，从Angular迁移到react也不例外。</p>
<p>在本文中，您将了解在将Angular应用程序转换为React时应该考虑的事项、迁移策略、迁移的优点和缺点，以及您可能想要迁移的原因；最后，我们将演练将Angular应用程序转换为React的过程，您可以按照自己的节奏进行操作。让我们开始吧。</p>
<p><em>向前跳转:</em></p>

<h2 id="things-note-migrating-angular-react">从Angular迁移到React时需要注意的事项</h2>
<p>Angular和React是很好的前端框架，具有独特的特征，使它们有着根本的不同，在迁移时，您必须注意以下几点:</p>
<ul>
<li>React使用虚拟DOM，而Angular使用真实DOM</li>
<li>Angular具有双向绑定，而React具有单向绑定</li>
<li>Angular自带TypeScript开箱即用；React不会</li>
<li>Angular内置了对AJAX、HTTP和Observables的支持，React没有。</li>
<li>React拥有庞大的生态系统和来自Meta(脸书)的直接支持，而Angular仅由开发者社区提供支持</li>
<li>Angular具有现成的特性，如验证、组件范围的CSS、动画、条件呈现等等</li>
<li>Angular CLI可以轻松生成组件、模块和其他有助于开发人员提高工作效率的功能</li>
</ul>
<h2 id="what-before-migrating">迁移前做什么有角度的反应</h2>
<h3 id="set-goals-avoid-scope-creep">设定目标以避免范围蔓延</h3>
<p>许多开发团队在项目工作时遭受没有制定范围的后果。</p>
<p>这次迁移的目标和重点是什么？严格来说，这是一次性的迁移吗？或者，您会利用这个机会在迁移过程中进行更新、错误修复和性能优化吗？请注意，这些问题的答案将影响迁移的交付时间表。</p>
<h3 id="carry-audit-understand-pain-points-blockers">进行审核以了解棘手问题和阻碍因素</h3>
<p>您当前系统的哪些限制和低效之处需要更换？重要的是，您要切换到的新堆栈会移除现有的阻止程序，而不会添加新的阻止程序。确保在迁移之前有合理的理由，并且没有遗留问题。</p>
<h3 id="choose-right-migration-strategy">选择正确的迁移策略</h3>
<p>您将使用什么迁移策略？会错开迁移发布吗？选择正确的策略是成功迁移和保持预期的关键。</p>
<h2 id="some-reasons-teamsm-migrate-angular-react">团队可能从Angular迁移到React的一些原因</h2>
<p>业务和开发团队的需求随着时间的推移而变化，有时这些变化需要技术栈的过渡来适应。</p>
<p>以下是您可能从Angular迁移到React的主要原因:</p>
<ul>
<li>React的采用在开发人员中不断增加，新一批web开发人才专注于学习最具市场需求的技能。这意味着寻找或雇佣有棱角的开发人员来管理项目将变得越来越困难，你可能需要在必要时做出反应</li>
<li>React比Angular具有更广泛的灵活性——你可以很容易地找到博客模板、动画库、多组件库、toast库等等。与Angular相比，React有一个更大、更活跃的开源社区，它不断开发第三方库、模板、在线课程和其他资源</li>
<li>业务需求和关注点会随着时间的推移而变化，开发人员可能需要开发移动应用来服务更多的客户。对他们来说，采用React代码库与React Native一起工作会更容易、更快</li>
</ul>
<h2 id="migration-strategies">迁移策略</h2>
<p>迁移应用程序的代码库是复杂的，虽然没有简单的方法来做到这一点，但我们可以探索几种策略。</p>
<h3 id="rewrite">重写</h3>
<p>就质量而言，从头开始完全重写被认为是迁移应用程序的更好方式，因为您可以从新的应用程序开始，定义适合新框架的架构，并且没有必要处理新旧代码的集成。</p>
<p>但是，这种策略也有缺点—它需要更多的时间和资源，并且交付时间表很难估计。</p>
<h3 id="strangler-pattern">扼杀者模式</h3>
<p>React和Angular是基于组件的框架，您可以在定义迁移策略时利用这一点。基于组件的迁移意味着你可以把你的Angular应用分成单独的部分，然后一个接一个地迁移它们。</p>
<p>由于不同组件的开发可以并行进行，您可以让不同的团队迁移应用程序的不同部分——使用这种策略，您可以错开发布，并为每个组件部署迁移。</p>
<p>一个缺点是，您必须将新框架的架构与旧框架的架构相集成。</p>
<h2 id="why-want-migrate-angular-react">为什么您可能不想从Angular迁移到React</h2>
<p>Angular的一个持久的好处是，由于其固执己见的系统和内置工具，它使决策变得更容易——开发人员不需要花费数天或数周的时间来讨论用于状态管理或数据获取的库。</p>
<p>Angular是用TypeScript构建的，使用现成的TypeScript可以强化干净的代码，并使调试和维护更加容易——除了缩放问题。</p>
<p>从Angular迁移到React将意味着失去Angular CLI，开发人员可以使用它来创建可重复的代码块，如组件、服务、管道和命令行指令。</p>
<h2 id="converting-angular-app-react">转换角度应用程序以做出反应</h2>
<p>了解了框架迁移的背景之后，让我们转换一个Angular应用程序，看看它是如何完成的。</p><div class="code-block code-block-54">
<hr/>
<h3>更多来自LogRocket的精彩文章:</h3>

<hr/></div>
<p>我们将为React应用程序使用Next.js然而，相同的原则和代码片段可以被应用到一个普通的React应用程序中。</p>
<p>首先，请按照这些<a href="https://angular.io/guide/setup-local"> Angular </a>和<a href="https://nextjs.org/docs/getting-started"> Next.js </a>指南中的步骤来启动新的Angular和React应用程序。</p>
<h2 id="project-convert">我们将转换的项目</h2>
<p>我们将把一个简单的任务追踪器app从Angular转换成React下图显示了该应用程序。</p>
<p>当点击<strong> Add </strong>按钮时，会显示一个我们可以添加新任务的模式。</p>
<p><img data-attachment-id="138708" data-permalink="https://blog.logrocket.com/guide-converting-angular-apps-react/attachment/task-tracker/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/10/task-tracker.png" data-orig-size="730,574" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="task-tracker" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/10/task-tracker-300x236.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/10/task-tracker.png" decoding="async" class="aligncenter wp-image-138708 size-full jetpack-lazy-image" src="../Images/dd6703f715cd4be17886ce73904c7a65.png" alt="Task tracker" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2022/10/task-tracker.png 730w, https://blog.logrocket.com/wp-content/uploads/2022/10/task-tracker-300x236.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2022/10/task-tracker.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/10/task-tracker.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="138708" data-permalink="https://blog.logrocket.com/guide-converting-angular-apps-react/attachment/task-tracker/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/10/task-tracker.png" data-orig-size="730,574" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="task-tracker" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/10/task-tracker-300x236.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/10/task-tracker.png" decoding="async" loading="lazy" class="aligncenter wp-image-138708 size-full" src="../Images/dd6703f715cd4be17886ce73904c7a65.png" alt="Task tracker" srcset="https://blog.logrocket.com/wp-content/uploads/2022/10/task-tracker.png 730w, https://blog.logrocket.com/wp-content/uploads/2022/10/task-tracker-300x236.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/10/task-tracker.png"/></noscript>
<p><img data-attachment-id="138712" data-permalink="https://blog.logrocket.com/guide-converting-angular-apps-react/attachment/adding-task-2/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/10/adding-task-1.png" data-orig-size="730,674" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="adding-task" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/10/adding-task-1-300x277.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/10/adding-task-1.png" decoding="async" class="aligncenter wp-image-138712 size-full jetpack-lazy-image" src="../Images/bc6d4f87bec168cd1628f9589a606e5f.png" alt="Adding the task in task tracker" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2022/10/adding-task-1.png 730w, https://blog.logrocket.com/wp-content/uploads/2022/10/adding-task-1-300x277.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2022/10/adding-task-1.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/10/adding-task-1.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="138712" data-permalink="https://blog.logrocket.com/guide-converting-angular-apps-react/attachment/adding-task-2/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/10/adding-task-1.png" data-orig-size="730,674" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="adding-task" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/10/adding-task-1-300x277.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/10/adding-task-1.png" decoding="async" loading="lazy" class="aligncenter wp-image-138712 size-full" src="../Images/bc6d4f87bec168cd1628f9589a606e5f.png" alt="Adding the task in task tracker" srcset="https://blog.logrocket.com/wp-content/uploads/2022/10/adding-task-1.png 730w, https://blog.logrocket.com/wp-content/uploads/2022/10/adding-task-1-300x277.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/10/adding-task-1.png"/></noscript>
<p>这是应用程序的不同组成部分:</p>
<ul>
<li><strong>表头:</strong>app的表头</li>
<li><strong>按钮:</strong>一个可重用的按钮组件</li>
<li><strong>添加任务:</strong>负责添加新任务的表单组件</li>
<li><strong>任务项:</strong>单个任务项</li>
<li><strong>任务:</strong>我们在其中呈现所有任务的组件</li>
</ul>
<p>让我们开始创建组件。我们将首先查看角度代码，然后将其转换为反应。</p>
<p>(注意:除了本文的其余部分，还需要Angular和Next.js的工作知识)</p>
<h2 id="defining-angular-services">定义角度服务</h2>
<p>服务是应用程序完成特定任务或执行操作所需的功能块。服务是为Angular应用添加功能的关键部分；点击了解更多信息<a href="https://blog.logrocket.com/how-dependency-injection-works-in-angular/">。</a></p>
<p>Angular应用程序需要两个服务，一个是<strong>任务</strong>服务，另一个是<strong> UI </strong>服务。</p>
<h3 id="creating-task-service">创建任务服务</h3>
<p>这将负责从模拟API获取任务、添加新任务和删除任务。</p>
<p>下面的代码执行以下操作:</p>
<ul>
<li><code>getTasks</code>获取任务</li>
<li><code>deleteTask</code>添加新任务</li>
<li><code>addTask</code>删除任务</li>
</ul>
<div>
<pre class="language-javascript hljs">//

import { Injectable } from '@angular/core';
import { Observable } from 'rxjs';
import { Task } from 'src/app/mock-tasks';
import { HttpClient, HttpHeaders } from '@angular/common/http';

const httpOptions = {
  headers: new HttpHeaders({
    'Content-Type': 'application/json',
  }),
};

@Injectable({
  providedIn: 'root',
})

export class TaskService {
  private apiUrl = 'http://localhost:5000/tasks';
  constructor(private http: HttpClient) {}
 
  getTasks(): Observable&lt;Task[]&gt; {
    return this.http.get&lt;Task[]&gt;(this.apiUrl);
  }
 
  deleteTask(task: Task): Observable&lt;Task&gt; {
    const url = `${this.apiUrl}/${task.id}`;
    return this.http.delete&lt;Task&gt;(url);
  }
 
  addTask(task: Task): Observable&lt;Task&gt; {
    return this.http.post&lt;Task&gt;(this.apiUrl, task, httpOptions);
  }
}
</pre>
</div>
<p>创建UI服务</p>
<h3 id="creating-ui-service">UI服务将通过<code>toggleAddTask</code>函数控制表单切换功能。</h3>
<p>太好了！既然我们已经定义了服务，现在我们继续创建组件。</p>
<pre class="language-javascript hljs">//

import { Injectable } from '@angular/core';
import { Observable, Subject } from 'rxjs';

@Injectable({
  providedIn: 'root',
})

export class UiService {
  private showAddTask: boolean = false;
  private subject = new Subject&lt;any&gt;();
  constructor() {}
  toggleAddTask(): void {
    this.showAddTask = !this.showAddTask;
    this.subject.next(this.showAddTask);
  }
  onToggle(): Observable&lt;any&gt; {
    return this.subject.asObservable();
  }
}
</pre>
<p>header组件将包含一个按钮，单击该按钮将切换用户用来添加更多任务的表单。此外，按钮的背景颜色和文本也将被切换。</p>

<p>要在Angular中进行设置，请在应用程序中创建一个标题组件，并执行以下操作:</p>
<p>首先，定义组件的HTML。</p>
<p>按钮接受一个<code>btnClick</code>处理程序，而<code>toggleAddTask</code>方法负责切换表单的可见性。</p>
<pre class="language-javascript hljs">
&lt;header&gt;
  &lt;h1&gt;Task Tracker&lt;/h1&gt;
  &lt;app-button
    color="{{ showAddTask ? 'red' : 'green' }}"
    text="{{ showAddTask ? 'Close' : 'Add' }}"
    (btnClick)="toggleAddTask()"
  &gt;&lt;/app-button&gt;
&lt;/header&gt;
</pre>
<p>连接到服务并创建<code>toggleAddTask</code>方法。</p>
<p>然后，添加代码来定义行为:</p>
<p>我们访问包含一个<code>toggleAddTask</code>的UI服务，并使用它来定义第二个<code>toggleAddTask</code>方法，我们在header的HTML中使用了这个方法。</p>
<pre class="language-javascript hljs">
import { Component, OnInit } from '@angular/core';
import { Subscription } from 'rxjs';
import { UiService } from 'src/app/services/ui.service';

@Component({
  selector: 'app-header',
  templateUrl: './header.component.html',
  styleUrls: ['./header.component.css'],
})

export class HeaderComponent implements OnInit {
  showAddTask: boolean = false;
  subscription: Subscription;

  constructor(private uiService: UiService) {
    this.subscription = this.uiService
      .onToggle()
      .subscribe((value) =&gt; (this.showAddTask = value));
  }
  ngOnInit(): void {}
  ngOnDestroy() {
    // Unsubscribe to ensure no memory leaks
    this.subscription.unsubscribe();
  }
  toggleAddTask() {
    this.uiService.toggleAddTask();
  }
}
</pre>
<p>我们可以看到，在设置Angular的功能时，有相当多的活动部件。让我们看看这在React中是如何工作的。</p>
<p>首先，创建一个header组件并粘贴到下面的代码中。</p>
<p>这里，我们从<code>showFormContext</code>访问<code>showAddTaskForm</code>布尔函数和<code>toggleAddTaskForm</code>函数，并使用它们来设置功能。接下来，我们创建上下文。</p>
<pre class="language-javascript hljs">
import Button from "../Button/Button";
import styled from "styled-components";
import { useShowFormContext } from "../../context/showFormContext";

export default function Header() {
  const { showAddTaskForm, toggleAddTaskForm } = useShowFormContext();
  return (
    &lt;StyledHeader&gt;
      &lt;h1&gt;Task Tracker&lt;/h1&gt;
      &lt;Button
        bgColor={showAddTaskForm ? "red" : "green"}
        btnClickHandler={toggleAddTaskForm}
        btnLabel={showAddTaskForm ? "Close" : "Add"}
      /&gt;
    &lt;/StyledHeader&gt;
  );
}
</pre>
<p>创建<code>showFormContext</code>，它将包含<code>showAddTaskForm</code>和<code>toggleAddTaskForm</code>。</p>
<p>我们建立了具有相似特性的相同组件，但是代码行更少——这是React的胜利，也是它带给我们的简单性。</p>
<pre class="language-javascript hljs">
import { useState, useContext, createContext } from "react";
const ShowFormContext = createContext();
export const useShowFormContext = () =&gt; useContext(ShowFormContext);

export default function ShowFormContextProvider({ children }) {
  const [showAddTaskForm, setShowAddTaskForm] = useState(false);
  const toggleAddTaskForm = () =&gt; {
    setShowAddTaskForm(!showAddTaskForm);
  };
  return (
    &lt;ShowFormContext.Provider value={{ showAddTaskForm, toggleAddTaskForm }}&gt;
      {children}
    &lt;/ShowFormContext.Provider&gt;
  );
}
</pre>
<p>创建按钮组件</p>
<h2 id="creating-button-component">不要把这个按钮误认为是表单上的按钮。相反，它是我们在header组件中使用的按钮。先说棱角。</h2>
<p>创建按钮的HTML:</p>
<p>设置按钮的功能:</p>
<pre class="language-javascript hljs">
&lt;button 
  class="btn" 
  (click)="onClick()"
  [ngStyle]="{ 'background-color': color }"&gt;
  {{ text }}
&lt;/button&gt;
</pre>
<p>按钮的颜色和文本是动态的，所以我们为它们设置了变量。此外，按钮需要接受一个点击事件，所以我们发出了<code>btnClick</code>。</p>
<pre class="language-javascript hljs">
import { Component, OnInit, Input, Output, EventEmitter } from '@angular/core';

@Component({
  selector: 'app-button',
  templateUrl: './button.component.html',
  styleUrls: ['./button.component.css'],
})

export class ButtonComponent implements OnInit {
  @Input() text: string = '';
  @Input() color: string = '';
  @Output() btnClick = new EventEmitter();
  constructor() {}
  ngOnInit(): void {}
  onClick() {
    this.btnClick.emit();
  }
}
</pre>
<p>请注意，在Angular中定义props并将动态数据传递给组件要复杂得多。</p>
<p>让我们在React中设置按钮，看看它是什么样子:</p>
<p>这就是一切！显然，Angular版本的“道具”具有更高的复杂性。</p>
<pre class="language-javascript hljs">
import Styled from "styled-components";
export default function Button({ btnLabel, bgColor, btnClickHandler }) {
  return (
    &lt;StyledButton onClick={btnClickHandler} bgColor={bgColor}&gt;
      {btnLabel}
    &lt;/StyledButton&gt;
  );
}
</pre>
<p>创建添加任务组件</p>
<h2 id="creating-add-task-component">Add Task组件是我们用来添加新任务的表单。让我们以角度来设置它。</h2>
<p>我们是这样定义HTML框架的:</p>
<p>在这里，我们执行以下操作:</p>
<pre class="language-javascript hljs">
&lt;form *ngIf="showAddTask" class="add-form" (ngSubmit)="onSubmit()"&gt;
  &lt;div class="form-control"&gt;
    &lt;label for="text"&gt;Task&lt;/label&gt;
    &lt;input
      type="text"
      name="text"
      [(ngModel)]="text"
      id="text"
      placeholder="Add Task"
    /&gt;
  &lt;/div&gt;
  &lt;div class="form-control"&gt;
    &lt;label for="day"&gt;Day &amp; Time&lt;/label&gt;
    &lt;input
      type="text"
      name="day"
      [(ngModel)]="day"
      id="day"
      placeholder="Add Day &amp; Time"
    /&gt;
  &lt;/div&gt;
  &lt;input type="submit" value="Save Task" class="btn btn-block" /&gt;
&lt;/form&gt;
</pre>
<p>定义HTML并使用Angular的<code>ngModel</code>表单指令来跟踪表单字段的值</p>
<ul>
<li>根据<code>showAddTask</code>的状态，用<code>*ngIf</code>指令有条件地呈现表单</li>
<li>使表单具有交互性</li>
</ul>
<h3 id="make-form-interactive">接下来，我们需要通过定义数据将被传递到的变量和处理表单提交来向表单添加功能:</h3>
<p>这里，我们创建了<code>onSubmit</code>函数，它添加了新的任务并清除了表单字段。我们还添加了保存表单数据的必要变量。</p>
<pre class="language-javascript hljs">
import { Component, OnInit, Output, EventEmitter } from '@angular/core';
import { UiService } from 'src/app/services/ui.service';
import { Subscription } from 'rxjs';
import { Task } from 'src/app/mock-tasks';
@Component({
  selector: 'app-add-task',
  templateUrl: './add-task.component.html',
  styleUrls: ['./add-task.component.css'],
})
export class AddTaskComponent implements OnInit {
  @Output() onAddTask: EventEmitter&lt;Task&gt; = new EventEmitter();
  text: string;
  day: string;
  showAddTask: boolean;
  subscription: Subscription;
  constructor(private uiService: UiService) {
    this.subscription = this.uiService
      .onToggle()
      .subscribe((value) =&gt; (this.showAddTask = value));
  }
  ngOnInit(): void {}
  ngOnDestroy() {
    // Unsubscribe to ensure no memory leaks
    this.subscription.unsubscribe();
  }
  onSubmit() {
    const newTask: Task = {
      text: this.text,
      day: this.day,
    };
    this.onAddTask.emit(newTask);
    this.text = '';
    this.day = '';
  }
}
</pre>
<p>让我们在React中设置相同的内容:</p>
<p>我们来分解一下上面的代码:</p>
<pre class="language-javascript hljs">
const handleSubmit = (e) =&gt; {
  e.preventDefault();
  const formData = new FormData(e.target);
  const data = Object.fromEntries(formData);
  console.log(data);
};

export default function AddTask() {
  return (
    &lt;StyledForm className="add-form" onSubmit={handleSubmit}&gt;
      &lt;div className="form-control"&gt;
        &lt;label for="text"&gt;Task&lt;/label&gt;
        &lt;input type="text" name="task" id="text" placeholder="Add Task" /&gt;
      &lt;/div&gt;
      &lt;div className="form-control"&gt;
        &lt;label for="day"&gt;Day &amp; Time&lt;/label&gt;
        &lt;input type="text" name="day" id="day" placeholder="Add Day &amp; Time" /&gt;
      &lt;/div&gt;
      &lt;input type="submit" value="Save Task" className="btn btn-block" /&gt;
    &lt;/StyledForm&gt;
  );
}
</pre>
<p>首先，我们定义HTML</p>
<ul>
<li>接下来，我们设置了<code>handleSubmit</code>函数，它利用FormData构造函数来访问表单的数据</li>
<li>创建任务项和任务组件</li>
</ul>
<h2 id="creating-task-item-task-components">任务项组件是执行的每个任务。它包含任务的标题、日期和删除任务的按钮。</h2>
<p>让我们以角度来设置它:</p>
<p>我们需要创建传递给图标的<code>onDelete</code>方法。</p>
<pre class="language-javascript hljs">
&lt;div class="task"&gt;
  &lt;h3&gt;
    {{ task.text }}
    &lt;fa-icon
      [icon]="faTimes"
      [ngStyle]="{ color: 'red' }"
      (click)="onDelete(task)"
    &gt;&lt;/fa-icon&gt;
  &lt;/h3&gt;
  &lt;p&gt;{{ task.day }}&lt;/p&gt;
&lt;/div&gt; 
</pre>
<p>这里，我们定义了<code>onDelete</code>方法并使用它来省略<code>onDeleteTask</code>方法，这样任务项的父项就可以捕获删除事件并删除任务。</p>
<pre class="language-javascript hljs">
import { Component, OnInit, Input, Output, EventEmitter } from '@angular/core';
import { Task } from 'src/app/mock-tasks';
import { faTimes } from '@fortawesome/free-solid-svg-icons';

@Component({
  selector: 'app-task-item',
  templateUrl: './task-item.component.html',
  styleUrls: ['./task-item.component.css'],
})

export class TaskItemComponent implements OnInit {
  @Input() task: Task;
  faTimes = faTimes;
  @Output() onDeleteTask = new EventEmitter&lt;Task&gt;();
  constructor() {}
  ngOnInit(): void {}
  onDelete(task: Task) {
    this.onDeleteTask.emit(task);
  }
}
</pre>
<p>让我们创建Tasks组件来看看它是什么样子的。</p>
<p>这里，我们为任务组件定义HTML。在这里，我们遍历任务数组，并在任务项组件中呈现每个任务。</p>
<pre class="language-javascript hljs">
&lt;app-add-task (onAddTask)="addTask($event)"&gt;&lt;/app-add-task&gt;
&lt;app-task-item
  *ngFor="let task of tasks"
  [task]="task"
  (onDeleteTask)="deleteTask(task)"
&gt;&lt;/app-task-item&gt;
</pre>
<p>然后，我们从任务组件中捕获<code>onDeleteTask</code> delete事件，并使用它来设置任务删除功能。我们也为添加任务组件和<code>onAddTask</code>事件做同样的事情。</p>
<p>最后，我们利用任务服务的功能:</p>
<p>这里，我们从服务中访问<code>addTask</code>和<code>deleteTask</code>函数，并使用它们创建另一组在任务和任务项组件中使用的<code>addTask</code>和<code>deleteTask</code>方法。</p>
<pre class="language-javascript hljs">
import { Component, OnInit } from '@angular/core';
import { Task } from 'src/app/mock-tasks';
import { TaskService } from 'src/app/services/task.service';

@Component({
  selector: 'app-tasks',
  templateUrl: './tasks.component.html',
  styleUrls: ['./tasks.component.css'],
})

export class TasksComponent implements OnInit {
  tasks: Task[] = [];
  constructor(private taskService: TaskService) {}
  ngOnInit(): void {
    this.taskService.getTasks().subscribe((tasks) =&gt; (this.tasks = tasks));
  }
  deleteTask(task: Task) {
    this.taskService
      .deleteTask(task)
      .subscribe(
        () =&gt; (this.tasks = this.tasks.filter((t) =&gt; t.id !== task.id))
      );
  }
  addTask(task: Task) {
    this.taskService
      .addTask(task)
      .subscribe((task) =&gt; this.tasks.unshift(task));
  }
}
</pre>
<p>然后，我们使用<code>getTasks</code>函数从模拟API获取任务列表。</p>
<p>Angular就是这样！现在，让我们将任务和任务项功能迁移到React，从任务项开始:</p>
<p>这里，我们定义了一个<code>deleteTask</code>函数，并将其传递给图标。然后，我们还呈现了任务的数据。</p>
<pre class="language-javascript hljs">
export default function TaskItem({ task, tasks, setTasks }) {
  const deleteTask = () =&gt; {
    let newTasks;
    fetch(`http://localhost:5000/tasks/${task.id}`, {
      method: "DELETE",
    })
      .then((newTasks = tasks.filter((t) =&gt; t.id !== task.id)))
      .then(setTasks(newTasks));
    console.log("red");
  };
  return (
    &lt;Container className="task"&gt;
      &lt;h3&gt;
        {task.text} &lt;DeleteIcon const deleteTask={deleteTask} /&gt;
      &lt;/h3&gt;
      &lt;p&gt;{task.day}&lt;/p&gt;
    &lt;/Container&gt;
  );
}

function DeleteIcon({ deleteTask }) {
  return (
    &lt;svg
      onClick={deleteTask}
    &gt;
      &lt;path d=""&gt;&lt;/path&gt;
    &lt;/svg&gt;
  );
}
</pre>
<p>对于任务组件:</p>
<p>在这里，我们做了以下工作:</p>
<pre class="language-javascript hljs">
import AddTask from "../AddTask/AddTask";
import TaskItem from "../TaskItem/TaskItem";
import { useShowFormContext } from "../../context/showFormContext";
import { useState, useEffect } from "react";

export default function Tasks() {
  const [tasks, setTasks] = useState(null);
  const { showAddTaskForm } = useShowFormContext();

  useEffect(() =&gt; {
    fetch("http://localhost:5000/tasks")
      .then((res) =&gt; res.json())
      .then((data) =&gt; setTasks(data));
  }, []);

  return (
    &lt;&gt;
      {showAddTaskForm &amp;&amp; &lt;AddTask /&gt;}
      {tasks
        ? tasks.map((task) =&gt; (
            &lt;TaskItem
              key={task.id}
              task={task}
              tasks={tasks}
              setTasks={setTasks}
            /&gt;
          ))
        : null}
    &lt;/&gt;
  );
}
</pre>
<p>从模拟API获取任务</p>
<ul>
<li>根据<code>showAddTaskForm</code>的值切换表单的可见性</li>
<li>呈现任务列表</li>
<li>这样，我们已经成功地将一个基本的任务跟踪器应用程序从Angular转换为React。</li>
</ul>
<p>然而，请注意，这是一个基本项目，当处理具有多种服务、复杂的状态管理和许多页面和功能的Angular应用程序时，迁移会更加复杂——但原则是相同的。</p>
<p>转换过程中的感悟</p>
<h2 id="insights-conversion-process">虽然Angular和React都是很好的前端框架，但是前者比后者更复杂</h2>
<ul>
<li>平均来说，在Angular中创建一个特征要比在React中花费更多的代码行</li>
<li>总的来说，将组件从Angular转换为React会减少代码行，使事情变得更简单、更快速。这提高了应用程序的性能，并提供了更好的维护和开发体验</li>
<li>结论</li>
</ul>
<h2 id="conclusion">迁移可能是一项相当艰巨的任务，需要花费大量的精力、时间、规划和开发来确保它顺利进行，而不会影响维护和开发速度。在迁移之前考虑利弊是很重要的。</h2>
<p>虽然完全重写转换有很多好处，但这并不总是可能的，因为大多数公司没有时间或资源来致力于这种方法。在这种情况下，我们可以利用工具来自动化大部分迁移过程，例如<a href="https://github.com/ngReact/ngReact">n react</a>、<a href="https://github.com/coatue-oss/react2angular"> react2angular </a>和<a href="https://github.com/coatue-oss/angular2react"> angular2react </a>。</p>
<p>我希望这篇解释者和教程文章对你有用——你可以从这个报告中获得Angular和React应用程序的完整源代码。</p>
<p><a href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener"> LogRocket </a>:全面了解您的生产React应用</p><div class="code-block code-block-17">
<div class="blog-plug inline-plug react-plug" vwo-el-id="26283398190">
<h2 vwo-el-id="41600691720">调试React应用程序可能很困难，尤其是当用户遇到难以重现的问题时。如果您对监视和跟踪Redux状态、自动显示JavaScript错误以及跟踪缓慢的网络请求和组件加载时间感兴趣，</h2><p>. </p><a href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" vwo-el-id="19356441070">try LogRocket</a><p>LogRocket 结合了会话回放、产品分析和错误跟踪，使软件团队能够创建理想的web和移动产品体验。这对你来说意味着什么？</p><a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="19356441380">
<img class="first-react-image alignnone size-full wp-image-46 jetpack-lazy-image jetpack-lazy-image--handled" src="../Images/f300c244a1a1cf916df8b4cb02bec6c6.png" vwo-el-id="18272717540" data-lazy-loaded="1" data-original-src="https://files.readme.io/27c94e7-Image_2017-06-05_at_9.46.04_PM.png"/>
</a>
<a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="19356441690">
<img class="second-react-image alignnone size-full wp-image-46 jetpack-lazy-image jetpack-lazy-image--handled" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" vwo-el-id="30720362350" data-lazy-loaded="1" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/>
</a>
<p vwo-el-id="28675660440" class="">LogRocket不是猜测错误发生的原因，也不是要求用户提供截图和日志转储，而是让您回放问题，就像它们发生在您自己的浏览器中一样，以快速了解哪里出错了。</p>
<p>不再有嘈杂的警报。智能错误跟踪允许您对问题进行分类，然后从中学习。获得有影响的用户问题的通知，而不是误报。警报越少，有用的信号越多。</p>
<p>LogRocket Redux中间件包为您的用户会话增加了一层额外的可见性。LogRocket记录Redux存储中的所有操作和状态。</p>
<p vwo-el-id="28675660750">现代化您调试React应用的方式— <a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="40093418840">开始免费监控</a>。</p>
<p vwo-el-id="28675661060">Modernize how you debug your React apps —
<a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="40093418840">start monitoring for free</a>.
</p>
</div></div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
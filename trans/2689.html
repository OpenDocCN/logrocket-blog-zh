<html>
<head>
<title>How to build a file upload service with vanilla JavaScript - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>如何用普通 JavaScript 构建文件上传服务</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/how-to-build-file-upload-service-vanilla-javascript/#0001-01-01">https://blog.logrocket.com/how-to-build-file-upload-service-vanilla-javascript/#0001-01-01</a></blockquote><div><article class="article-post">
<p>第三方包、编译器和捆绑器是幕后的魔法。由于缺乏时间和巨大的竞争，我们没有足够的担心底层的东西，以了解在这些第三方包的幕后到底发生了什么。</p>
<p>在本文中，我们将从头开始用普通的 JavaScript 构建一个文件上传服务。我们的目标是在没有外部库的情况下构建它，以理解 JavaScript 的一些核心概念。我们将在前端读取用户上传的文件，并将其分块传输到后端，存储在那里。</p>
<p>让我们快速浏览一下我们将要制作的产品:</p>
<p><img data-attachment-id="114254" data-permalink="https://blog.logrocket.com/how-to-build-file-upload-service-vanilla-javascript/js-file-upload-multiple/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/02/js-file-upload-multiple.gif" data-orig-size="600,337" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="JS multipart upload" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/02/js-file-upload-multiple-300x169.gif" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/02/js-file-upload-multiple.gif" decoding="async" class="size-full wp-image-114254 aligncenter jetpack-lazy-image" src="../Images/e9945fda8b2d889c50b1499f23f10268.png" alt="JS Multipart Upload" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2022/02/js-file-upload-multiple.gif?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/02/js-file-upload-multiple.gif"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="114254" data-permalink="https://blog.logrocket.com/how-to-build-file-upload-service-vanilla-javascript/js-file-upload-multiple/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/02/js-file-upload-multiple.gif" data-orig-size="600,337" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="JS multipart upload" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/02/js-file-upload-multiple-300x169.gif" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/02/js-file-upload-multiple.gif" decoding="async" loading="lazy" class="size-full wp-image-114254 aligncenter" src="../Images/e9945fda8b2d889c50b1499f23f10268.png" alt="JS Multipart Upload" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/02/js-file-upload-multiple.gif"/></noscript>
<p>让我们开始吃吧。</p>
<h2 id="table-of-contents">目录</h2>

<h2 id="set-up-the-node-js-server">设置 Node.js 服务器</h2>
<p>我们将利用漂亮的内置 HTTP 包来设置后端服务器。</p>
<p>首先，我们需要为项目创建一个新文件夹。</p>
<pre class="language-bash hljs">mkdir fileupload-service
</pre>
<p>这样做之后，我们需要创建一个<code>index.js</code>文件，作为我们后端服务器的入口点。</p>
<pre class="language-bash hljs">touch index.js
</pre>
<p>之后，创建 HTTP 服务器。</p>
<pre class="language-javascript hljs">const http = require('http');      // import http module
const server = http.createServer();     // create server

server.listen(8080, () =&gt; {
    console.log('Server running on port 8080') // listening on the port
})
</pre>
<p>上面的代码非常简单明了。我们已经创建了一个 HTTP 服务器，运行在端口 8080 上。</p>
<h2 id="set-up-the-frontend">设置前端</h2>
<p>下一步是设置前端。由于我们没有做任何花哨的事情，我们将创建一个带有文件输入和上传按钮的基本 HTML 文件，单击该按钮将启动上传过程。将会有一个微小的状态文本来声明文件上传的状态。</p>
<p>在 vanilla JS 中，要在任何按钮点击上添加动作，我们可以简单地附加一个事件监听器。</p>
<pre class="language-html hljs">&lt;html lang="en"&gt;
&lt;head&gt;
    &lt;meta charset="UTF-8"&gt;
    &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;
    &lt;title&gt;File Uploader&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;h2&gt;File Upload Service&lt;/h2&gt;
    &lt;input type="file" id="file"&gt;
    &lt;button id="upload"&gt;Upload&lt;/button&gt;
        &lt;small id="status"&gt;&lt;/small&gt;

    &lt;script&gt;
        const file = document.getElementById('file');
        const upload = document.getElementById('upload');
                const status = document.getElementById('status');
        upload.addEventListener('click', () =&gt; {
                console.log('clicked the upload button!');
        })
    &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</pre>
<p>用户可以选择文件并通过点击上传按钮来上传。很简单！</p>
<p>为了在调用 home route 时提供这个 HTML 文件，我们需要从后端发送这个文件。最简单的方法如下。</p>
<pre class="language-javascript hljs">server.on('request', (req, res) =&gt; {

    if(req.url === '/' &amp;&amp; req.method === 'GET') {
        return res.end(fs.readFileSync(__dirname + '/index.html'))
    }
})
</pre>
<blockquote><p><strong>注意:</strong>,<code>server.on('request')</code>方法用于监听节点后端服务器中的所有 HTTP 请求。</p></blockquote>
<h2 id="read-the-file-content-on-the-frontend">读取前端的文件内容</h2>
<p>当我们的后端服务器启动并运行时，我们需要一种在前端读取文件的方法。为此，我们将使用<code>FileReader</code>对象。它让 web 应用程序异步读取存储在用户计算机上的文件(或原始数据缓冲区)的内容，使用<code><a href="https://developer.mozilla.org/en-US/docs/Web/API/File">File</a></code>或<code><a href="https://developer.mozilla.org/en-US/docs/Web/API/Blob">Blob</a></code>对象来指定要读取的文件或数据。</p>
<p>使用<code>FileReader</code>对象在客户端读取文件的语法如下。</p>
<pre class="language-javascript hljs">const fileReader = new FileReader(); // initialize the object  
fileReader.readAsArrayBuffer(file); // read file as array buffer
</pre>
<p>我们可以在输入的<code>files</code>字段下访问选择的输入文件。目前，我们只为单个文件上传构建它，但是以后，我们也可以为多个文件上传扩展它。</p>
<pre class="language-javascript hljs">const selectFile = file.files[0]; 
</pre>
<p>为了读取一个文件，<code>FileReader</code>提供了一些方法。</p>
<ol>
<li><code>FileReader.readAsArrayBuffer() </code> —读取文件作为数组缓冲区</li>
<li>
<p><code>FileReader.readAsBinaryString()</code> —以原始二进制数据读取文件</p>
</li>
<li>
<p><code>FileReader.readAsDataURL()</code> —读取文件并将结果作为数据 url 返回</p>
</li>
<li>
<p>如果我们知道文件的类型是文本，这个方法很有用</p>
</li>
</ol>
<p>对于我们的用例，我们将使用<code>readAsArrayBuffer</code>方法以字节为单位读取文件，并通过网络将其传输到后端。</p>
<p>为了在客户端跟踪读取文件，<code>FileReader</code>提供了几个事件监听器，如<code>onload</code>、<code>onprogress</code>等。</p><div class="code-block code-block-54">
<hr/>
<h3>更多来自 LogRocket 的精彩文章:</h3>

<hr/></div>
<p>我们的目标是读取文件，将它分成块，并上传到后端，所以我们将使用<code>onload</code>事件，该事件在文件读取完成后触发。</p>
<p>你可能想知道，为什么我们不使用<code>onprogress</code>方法来制作一个完全流式文件上传的应用程序？但是<code>onprogress</code>方法的问题是它不告诉新的读取块，它告诉直到现在的完整数据读取。所以，我们使用了<code>onload</code>方法。</p>
<p>一旦文件被完全读取，我们就将它分成小块，并将其传输到后端。</p>
<pre class="language-html hljs">&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;
    &lt;meta charset="UTF-8"&gt;
    &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;
    &lt;title&gt;File Uploader&lt;/title&gt;
&lt;/head&gt;

&lt;body&gt;
    &lt;h2&gt;File Upload Service&lt;/h2&gt;


    &lt;input type="file" id="file"&gt;
    &lt;button id="upload"&gt;Upload&lt;/button&gt;
        &lt;small id="status"&gt;&lt;/small&gt;

    &lt;script&gt;


        const file = document.getElementById('file');
        const upload = document.getElementById('upload');
                const status = document.getElementById(status);

        upload.addEventListener('click', () =&gt; {
                        // set status to uploading
                        status.innerHTML = ‘uploading…’;

            const fileReader = new FileReader();
            fileReader.readAsArrayBuffer(file.files[0]);


            fileReader.onload = (event) =&gt; {
                console.log('Complete File read successfully!')
            }
        });
    &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</pre>
<p>你可能已经注意到我们正在使用一个<code>&lt;small&gt;</code>标签，当我们开始上传时它会变成<code>uploading...</code>，一旦文件成功上传到后台，它就会变成<code>uploaded!!!</code>！</p>
<h2 id="divide-and-stream-the-file-in-chunks-to-the-backend">将文件分割成块并传输到后端</h2>
<p>有时，文件可能很大，因此一次发送完整的文件并不是一个好的做法。一些代理服务器如 Nginx 可能会阻止它，因为它似乎是恶意的。</p>
<p>因此，我们将把这个文件分割成大约 5000 字节的块，然后一个接一个地发送到后端。</p>
<p>如果我们仔细观察<code>event</code>参数，我们会发现，一旦它读取了文件，我们就可以在<code>event.target.result</code>字段中访问作为数组缓冲区的文件内容。</p>
<p>我们将把这个文件的数组缓冲区分成 5000 字节的块。</p>
<pre class="language-javascript hljs">// file content 
const content = event.target.result;
// fix chunk size
const CHUNK_SIZE = 5000;
// total chunks
const totalChunks = event.target.result.byteLength / CHUNK_SIZE;

// loop over each chunk
for (let chunk = 0; chunk &lt; totalChunks + 1; chunk++) {
    // prepare the chunk
    let CHUNK = content.slice(chunk * CHUNK_SIZE, (chunk + 1) * CHUNK_SIZE)

        // todo - send it to the backend
}
</pre>
<p>现在，我们需要将这些块发送到后端。为了攻击后端服务器，我的老朋友<code>fetch</code>来帮忙了。</p>
<p>在我们将块发送到后端之前，我们需要确保我们按顺序进行，否则文件将会损坏。</p>
<p>第二件事是在上传时使用<code>async await</code>,因为我们不想后端服务器被请求淹没。</p>
<pre class="language-javascript hljs">fileReader.onload = async (event) =&gt; {

    const content = event.target.result;
    const CHUNK_SIZE = 1000;
    const totalChunks = event.target.result.byteLength / CHUNK_SIZE;

    // generate a file name
    const fileName = Math.random().toString(36).slice(-6) + file.files[0].name;


    for (let chunk = 0; chunk &lt; totalChunks + 1; chunk++) {
        let CHUNK = content.slice(chunk * CHUNK_SIZE, (chunk + 1) * CHUNK_SIZE)


        await fetch('/upload?fileName=' + fileName, {
                'method' : 'POST',
                'headers' : {
                    'content-type' : "application/octet-stream",
                    'content-length' : CHUNK.length,
                },
                'body': CHUNK
        })
    }
        status.innerHTML = ‘uploaded!!!’;
}
</pre>
<p>如您所见，我们已经添加了文件名作为查询参数，您可能想知道为什么我们也要发送文件名。看，所有对后端服务器的 API 调用都是无状态的，所以要将内容附加到一个文件中，我们需要有一个惟一的标识符，这就是我们例子中的文件名。</p>
<p>因为用户可能希望上传具有相同文件名的文件，以确保后端工作正常，所以我们需要一个惟一的标识符。为此，我们使用这个漂亮的一行程序:</p>
<pre>Math.random().toString(36).slice(-6)</pre>
<p>理想情况下，我们不应该发送任何自定义头，因为大多数代理如 Nginx 或 HAProxy 可能会阻止它。</p>
<h2 id="receive-the-chunks-and-store-them-on-the-server">接收块并将它们存储在服务器上</h2>
<p>因为我们已经完全设置好了前端，所以下一步是监听文件块并将它们写入服务器。</p>
<p>为了从请求的查询参数中提取文件名，我们使用下面这段代码。</p>
<pre>const query = new URLSearchParams(req.url);
const fileName = query.get(‘/upload?fileName’);
</pre>
<p>因此，我们的最终代码看起来像这样:</p>
<pre class="language-javascript hljs">server.on('request', (req, res) =&gt; {

if(req.url === '/' &amp;&amp; req.method == 'GET') {
    return res.end(fs.readFileSync(__dirname + '/index.html'))
}

if(req.url=== '/upload' &amp;&amp; req.method == 'POST') {
    const query = new URLSearchParams(req.url);
        const fileName = query.get(‘/upload?fileName’);

    req.on('data', chunk =&gt; {
        fs.appendFileSync(fileName, chunk); // append to a file on the disk
    })


    return res.end('Yay! File is uploaded.')
}
})</pre>
<h2 id="upload-multiple-files">上传多个文件</h2>
<p>到目前为止，我们已经用 vanilla JS 构建了一个漂亮的单个文件上传应用程序。现在，我们的下一个目标是扩展我们当前的实现，以支持多文件上传。</p>
<p>让我们开始吧。</p>
<p>如果我们仔细观察，我们会发现后端足够智能，可以顺利地处理多个文件上传，因为它有一个非常简单的工作:获取一个块，并将其附加到请求中收到的相应文件名。它完全独立于从前端上传了多少文件。</p>
<p>所以，让我们利用它，提高我们对它的应用。</p>
<p>在 UI 上接受多个文件选择的第一步是修改文件输入。目前，它默认接受单个文件输入。要接受多个文件，我们在输入中使用<code>multiple</code>选项:</p>
<pre class="language-html hljs">&lt;input type="file" id="files" multiple&gt;
</pre>
<p>现在，我们已经设置好在文件输入中接受多个文件。如果你错过了，我们也已经更新了从<code>file</code>到<code>files</code>的文件输入的<code>id</code>。</p>
<p>我们知道所有的输入文件现在都可以通过<code>files.files</code>数组访问。因此，我们的想法非常简单:我们将遍历所选文件的数组，将它一个接一个地分成块，并将其传输到后端服务器并存储在那里:</p>
<pre class="language-javascript hljs">for(let fileIndex=0;fileIndex&lt;files.files.length;fileIndex++) {
    const file = files.files[fileIndex];

    // divide the file into chunks and upload it to the backend
}
</pre>
<p>我们的好朋友<code>for</code>循环使得检查每个文件并上传到后端变得非常简单。</p>
<p>为了跟踪文件上传状态，我们维护一个变量，该变量在每次文件上传时更新。</p>
<p>因此，我们的文件上传脚本如下所示:</p>
<pre class="language-javascript hljs">        const files = document.getElementById('files');
        const upload = document.getElementById('upload');
        const status = document.getElementById('status');

        upload.addEventListener('click', () =&gt; {

            // set loading status
            status.innerHTML = 'uploading...';
            let fileUploaded = 0;

            for(let fileIndex = 0; fileIndex &lt; files.files.length; fileIndex++) {
                const file = files.files[fileIndex];

                const fileReader = new FileReader();

                fileReader.readAsArrayBuffer(file);

                fileReader.onload = async (event) =&gt; {
                    const content = event.target.result;
                    const CHUNK_SIZE = 1000;
                    const totalChunks = event.target.result.byteLength / CHUNK_SIZE;

                    const fileName = Math.random().toString(36).slice(-6) + file.name;

                    for (let chunk = 0; chunk &lt; totalChunks + 1; chunk++) {
                        let CHUNK = content.slice(chunk * CHUNK_SIZE, (chunk + 1) * CHUNK_SIZE)

                        await fetch('/upload?fileName=' + fileName, {
                            'method' : 'POST',
                            'headers' : {
                                'content-type' : "application/octet-stream",
                                'content-length' : CHUNK.length
                            },
                            'body' : CHUNK
                        })
                    }           
                    fileUploaded += 1;        

                    status.innerHTML = `file ${fileUploaded} of ${files.files.length} uploaded!!!`;
                }
            }

        })
</pre>
<p>我不确定您是否是通过查看我们的实现想到这一点的，但是我们也实现了多个文件并行上传。如果您仔细查看“网络”选项卡，您会发现文件块是以并行方式上传的，但没错，文件本身是以串行方式上传的。</p>
<p><img data-attachment-id="114434" data-permalink="https://blog.logrocket.com/how-to-build-file-upload-service-vanilla-javascript/js-multipart-uploaded-parallel-files/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/02/JS-multipart-uploaded-parallel-files.png" data-orig-size="605,354" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="JS multipart upload with parallel files" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/02/JS-multipart-uploaded-parallel-files-300x176.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/02/JS-multipart-uploaded-parallel-files.png" decoding="async" class="size-full wp-image-114434 aligncenter jetpack-lazy-image" src="../Images/5800dd9c6fe950e5ae87522aeb1c19b6.png" alt="JS Multipart Upload with Parallel Files" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2022/02/JS-multipart-uploaded-parallel-files.png 605w, https://blog.logrocket.com/wp-content/uploads/2022/02/JS-multipart-uploaded-parallel-files-300x176.png 300w" data-lazy-sizes="(max-width: 605px) 100vw, 605px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2022/02/JS-multipart-uploaded-parallel-files.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/02/JS-multipart-uploaded-parallel-files.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="114434" data-permalink="https://blog.logrocket.com/how-to-build-file-upload-service-vanilla-javascript/js-multipart-uploaded-parallel-files/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/02/JS-multipart-uploaded-parallel-files.png" data-orig-size="605,354" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="JS multipart upload with parallel files" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/02/JS-multipart-uploaded-parallel-files-300x176.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/02/JS-multipart-uploaded-parallel-files.png" decoding="async" loading="lazy" class="size-full wp-image-114434 aligncenter" src="../Images/5800dd9c6fe950e5ae87522aeb1c19b6.png" alt="JS Multipart Upload with Parallel Files" srcset="https://blog.logrocket.com/wp-content/uploads/2022/02/JS-multipart-uploaded-parallel-files.png 605w, https://blog.logrocket.com/wp-content/uploads/2022/02/JS-multipart-uploaded-parallel-files-300x176.png 300w" sizes="(max-width: 605px) 100vw, 605px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/02/JS-multipart-uploaded-parallel-files.png"/></noscript>
<p>因为我们没有等待前一个文件完全上传，所以所有的文件都是并行上传的。因为我们的后端是无状态的，所以这个功能非常好。</p>
<p>如果你热衷于探索代码库的 GitHub 库，<a href="https://github.com/Pankajtanwarbanna/vanilla-js-file-upload">你可以在这里找到它。</a></p>
<h2 id="conclusion">结论</h2>
<p>我们学习了如何用 vanilla JS 构建文件上传服务。显然，这不是最有效的实现，但是它足以让您对一些核心概念有一个大致的了解。</p>
<p>我们可以扩展它，在上传时有一个进度条，在失败时重试块上传，上传多个文件，一次上传多个块，等等。</p>
<p>我是推特上活跃的第二号人物，很想听听你的想法。如果你对我的其他文章感兴趣，<a href="https://www.pankajtanwar.in/blogs" target="_blank" rel="noopener">你可以在这里找到</a>。</p><div class="code-block code-block-27">
<div class="blog-plug inline-plug vanilla-javascript-cta"><h2>通过理解上下文，更容易地调试 JavaScript 错误</h2>
<p>调试代码总是一项单调乏味的任务。但是你越了解自己的错误，就越容易改正。</p>
<p>LogRocket 让你以新的独特的方式理解这些错误。我们的前端监控解决方案跟踪用户与您的 JavaScript 前端的互动，让您能够准确找出导致错误的用户行为。</p>
<a href="https://lp.logrocket.com/blg/javascript-signup" class="signup" target="_blank" rel="noopener noreferrer"><img class="alignnone size-full wp-image-46 jetpack-lazy-image" src="../Images/cbfed9be3defcb505e662574769a7636.png" alt="LogRocket Dashboard Free Trial Banner" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2020/06/reproduce-javascript-errors.gif?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/06/reproduce-javascript-errors.gif"/><noscript><img data-lazy-fallback="1" class="alignnone size-full wp-image-46" src="../Images/cbfed9be3defcb505e662574769a7636.png" alt="LogRocket Dashboard Free Trial Banner" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/06/reproduce-javascript-errors.gif"/></noscript></a>
<p>LogRocket 记录控制台日志、页面加载时间、堆栈跟踪、慢速网络请求/响应(带有标题+正文)、浏览器元数据和自定义日志。理解您的 JavaScript 代码的影响从来没有这么简单过！</p>
<a class="signup" href="https://lp.logrocket.com/blg/javascript-signup" target="_blank" rel="noopener noreferrer">Try it for free</a><p>.</p></div>


</div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>
 
</div>    
</body>
</html>
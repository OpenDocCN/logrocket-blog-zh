<html>
<head>
<title>Build a dynamic MPA with Enhance </title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>使用增强功能构建动态MPA</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/build-dynamic-mpa-enhance/#0001-01-01">https://blog.logrocket.com/build-dynamic-mpa-enhance/#0001-01-01</a></blockquote><div><article class="article-post">
<p>在构建多页面应用程序(MPAs)时，有数不清的语言和框架可供选择。但是有一些专注于构建MPAs的最基本的语言——HTML。</p>
<p>有了大多数选项，您需要学习如何安装和配置许多包，以便为开发准备好最基本的MPA。</p>
<p>如果有一个框架可以让你用一个简单的HTML文件构建你的应用程序，然后你可以向它添加更多的东西——比如样式、交互和数据——会怎么样？在任何时候，你都可以部署你的应用，甚至不需要JavaScript。</p>
<p>增强是一个可以完成所有这些的框架。</p>
<p>在本教程中，您将学习什么是Enhance以及如何用它构建一个示例项目。我还将向你展示渐进增强的思维模式如何改进你构建网站的方式。</p>
<p>向前跳:</p>

<h2 id="what-is-enhance">什么是增强？</h2>
<p>它的官方文档将Enhance定义为“一个基于web标准的HTML框架”这意味着它允许我们使用网络平台提供的标准来建立网站。</p>
<p>出于多种原因，这是好的。首先，我们的应用程序包的大小可以更小，因为我们不需要安装额外的库来完成基本的事情。第二，我们的网站将更有性能，因为它将使用为浏览器运行而优化的东西。第三，它使团队协作变得容易得多，因为所有开发人员都知道标准，所以需要学习的东西会更少。</p>
<p>在Enhance中构建应用程序的用户界面很容易，因为它是基于web组件的。因此，我们得到了所有的好处，比如可重用性、可组合性和限定范围的样式。</p>
<p>更简单的是，Enhance不要求我们直接使用web组件API(尽管我们可以这样做)。相反，我们可以简单地从组件返回一个HTML字符串，它会按照预期的方式呈现它。</p>
<p>Enhance处理让web组件在SSR中工作的所有必要工作，如果您需要自己做，这不是一个愉快的体验。</p>
<p>Enhance还为我们提供了一种简单的方法，通过基于文件系统的路由器向我们的应用程序添加页面。它不仅用于为用户添加页面，还允许我们添加API路由来处理服务器请求，并提供我们的应用程序所需的数据。在本教程的后面部分，我将向您展示如何创建这两种路由类型。</p>
<h2 id="progressive-enhancement">渐进增强</h2>
<p>增强是建立在渐进增强的思想上的。渐进式改进意味着您不需要对应用程序的每个方面(如JavaScript、获取数据或样式)都进行工作，就可以让您的应用程序为测试甚至部署做好准备。</p>
<p>考虑到渐进增强，您可以逐步构建您的应用程序。因此，您从HTML开始，提取一些组件，向应用程序提供硬编码的数据，获取真实数据，并在浏览器中使用JavaScript向表单添加用户交互。</p>
<p>在上述步骤中的任何一点，您都应该能够测试甚至部署您的应用程序——并且您可以在以后增强它。</p>
<h2 id="creating-example-project-progressive-enhancement-mindset">用渐进增强的思维方式创建一个示例项目</h2>
<p>现在，我们对什么是增强以及为什么要使用它有了一个概念。让我们学习如何构建一个简单的应用程序来看看它的运行。</p>
<p>我们将建立的应用程序将非常简单，所以我们可以专注于概念。在这个应用程序中，我们将显示一个带有文本输入的表单，当它被提交时，服务器会将输入的文本转换为大写。</p>
<p>该应用的第一个版本不会在浏览器中使用JavaScript。这意味着在用户提交表单后，它将重新加载页面以显示结果。</p>
<p>之后，我们将使用JavaScript增强它，这样我们就可以在页面上立即看到结果，而无需重新加载。</p>
<p>让我们从创建一个新的增强项目开始。首先，确保您的计算机上安装了Node v16或更高版本。然后，从您的终端运行以下命令:</p>
<pre class="language-bash hljs">npm create "@enhance" ./enhance-uppercase  -y</pre>
<p>接下来，安装依赖项并启动项目:</p>
<pre class="language-bash hljs">cd ./enhance-uppercase

npm install

npm start</pre>
<p>之后，你应该会看到你的应用在<a href="http://localhost:3333/" rel="nofollow"> http://localhost:3333/ </a>运行。</p>
<h2 id="how-routing-works-enhance">路由在增强中的工作原理</h2>
<p>Enhance中的路由基于文件系统，这意味着您添加的页面的URL将基于您定义页面文件的位置以及您对该文件的命名。</p><div class="code-block code-block-54">
<hr/>
<h3>更多来自LogRocket的精彩文章:</h3>

<hr/></div>
<p>所有页面路由都应该位于<code>app/pages/</code>下。如果它被命名为<code>index.html</code>，那么它将是根页面——即<code>/</code>。所以，以添加<code>/about</code>页面为例，你需要添加<code>app/pages/about.html</code>。</p>
<p>你可以从<a href="https://enhance.dev/docs/learn/concepts/routing/">增强文档</a>中了解更多关于路由的信息。在本例中，我们将在主页上工作，<code>app/pages/index.html</code>。</p>
<p>因此，页面路由是针对用户看到的页面的。如果我们想要定义API路由，那么我们可以遵循相同的约定，除了我们应该在<code>app/api/</code>中定义它们。</p>
<h2 id="api-routes">API路由有什么用？</h2>
<p>我们知道在哪里定义API路由，但不知道它们的用途。我们在这里解释一下。</p>
<p>当用户在Enhance中请求页面时，路由器会将用户请求的URL与开发人员在应用程序中定义的路由进行匹配。</p>
<p>因此，如果用户请求<code>/about</code>页面，那么路由器寻找<code>app/pages/about.html</code>来为用户服务。这时我们不需要为页面定义API路由。如果应用程序也为该请求定义了API路由，那么它将在<code>app/pages/about.html</code>被服务之前执行<code>app/api/about.mjs</code>。</p>
<p>这使我们有机会在将页面提供给用户之前获取和处理任何数据。因此，在Enhance中，我们可以从被请求页面的API路径向被请求页面返回任何我们想要的数据。</p>
<p>为了更好地理解这一点，让我们看一个代码示例。</p>
<p>如果我们以About页面为例，我们会有<code>app/api/about.mjs</code>:</p>
<pre class="language-javascript hljs">export async function get (request) {
  return {
    json: {
      userBio: 'example bio'
    }
  }
}</pre>
<p>所以，当用户请求<code>/about</code>时，我们会从<code>get</code>返回JSON数据(因为是GET请求)。</p>
<p>为了使用这些数据，我们可以从传递给页面的<code>state</code>对象中访问它。因此，应该在<code>app/pages/about.mjs</code>中定义页面路由。注意我们是如何定义它为<code>.mjs</code>而不是<code>.html</code>来访问数据的:</p>
<pre class="language-javascript hljs">export default function about ({ html, state }) {
  return html
    User bio: ${state.userBio}
</pre>
<h2 id="adding-form-homepage">将表单添加到主页</h2>
<p>回到我们的项目，我们需要添加一个带有文本输入的表单。因此，将<code>app/pages/index.html</code>中的所有内容替换为:</p>
<pre class="language-html hljs">&lt;style&gt;
  main {
    width: 500px;
    margin: 100px auto;
    font-family: sans-serif;
  }

  form {
    display: flex;
    align-items: center;
    margin-bottom: 10px;;
  }

  input {
    border: 1px solid #888;
    border-radius: 4px;
    margin-right: 10px;
    padding: 3px 10px;
  }

  button {
    background: #eee;
    padding: 5px 10px;
    border-radius: 4px;
  }

&lt;/style&gt;

&lt;main&gt;
  &lt;form action="/"&gt;
    &lt;input type="text" name="text" /&gt;
    &lt;button&gt;Convert&lt;/button&gt;
  &lt;/form&gt;

  &lt;div class="result"&gt;
    Result: &lt;span class="output"&gt;&lt;/span&gt;
  &lt;/div&gt;
&lt;/main&gt;
</pre>
<p>如果您检查您的浏览器，您会看到文本输入，提交按钮，以及下面的结果部分。</p>
<h2 id="adding-custom-element">添加自定义元素</h2>
<p>这是一个简单的例子，但是如果你想在多个地方使用这个表单呢？然后，最好将其提取为自定义元素。</p>
<p>在Enhance中，可以在<code>app/elements/</code>中定义自定义元素。那么，让我们在<code>app/</code>中创建一个<code>elements</code>目录，然后将<code>uppercase-form.mjs</code>添加到<code>app/elements/</code>中。</p>
<p>自定义元素被定义为纯函数。因此，让我们这样定义元素:</p>
<pre class="language-javascript hljs">export default function UppercaseForm({ html }) {
  return html`
    &lt;style&gt;
      main {
        width: 500px;
        margin: 100px auto;
        font-family: sans-serif;
      }

      form {
        display: flex;
        align-items: center;
        margin-bottom: 10px;;
      }

      input {
        border: 1px solid #888;
        border-radius: 4px;
        margin-right: 10px;
        padding: 3px 10px;
      }

      button {
        background: #eee;
        padding: 5px 10px;
        border-radius: 4px;
      }

    &lt;/style&gt;

    &lt;main&gt;
      &lt;form action="/"&gt;
        &lt;input type="text" name="text" /&gt;
        &lt;button&gt;Convert&lt;/button&gt;
      &lt;/form&gt;

      &lt;div class="result"&gt;
        Result: &lt;span class="output"&gt;&lt;/span&gt;
      &lt;/div&gt;
    &lt;/main&gt;
  `
}</pre>
<p>因此，它类似于我们在<code>pages/index.html</code>中的内容，除了HTML是使用参数中提供的<code>html</code>函数呈现的。</p>
<p>要在<code>pages/index.html</code>中使用它，只需删除所有内容并添加:</p>
<pre class="language-html hljs">&lt;uppercase-form /&gt;</pre>
<p>请注意，我们不需要导入任何东西。增强功能会自动导入页面中的所有自定义元素。</p>
<h2 id="defining-get-api-route">定义获取API路由</h2>
<p>我们创建的表单将<code>action</code>设置为<code>/</code>。这意味着当提交表单时，它会向<code><a href="http://localhost:3333/" rel="nofollow">http://localhost:3333/</a></code>发送一个GET请求。因为我们已经在<code>pages/index.html</code>定义了一个页面，所以响应将显示该页面。但是，我们还需要返回大写版本的响应文本。为此，我们需要为<code>/</code>定义一个GET API路径。</p>
<p>遵循API路由约定，我们应该在<code>app/api/index.mjs</code>中定义它。</p>
<p>因此，添加该文件，并将以下内容放入其中:</p>
<pre class="language-javascript hljs">export function get (req) {
  const text = req.query.text || ''
  const transformedText = text.toUpperCase()

  return {
    json: { transformedText }
  }
}</pre>
<p>在上面的代码中，我们定义了一个名为<code>get</code>的函数，因为它应该处理该页面的GET请求。</p>
<p>因为这是一个GET请求，所以我们通过请求查询字符串来访问表单数据，这个字符串就是<code>req.query</code>。文本值作为<code>text</code>可用，因为输入有<code>name="text"</code>。</p>
<p>如果请求中没有文本(这意味着表单还没有提交)，那么我们默认返回一个空字符串<code>const text = req.query.text || ''</code>。</p>
<p>在我们将文本转换成大写后，我们将其作为JSON响应返回。这样我们可以通过<code>state.store.transformedText</code>从我们的定制元素中访问它。让我在下一节向您展示如何做。</p>
<h2 id="displaying-result">显示结果</h2>
<p>正如我在上一节中提到的，我们可以通过参数中的<code>store</code>来访问自定义元素中的JSON数据。</p>
<p>因此，将自定义元素的参数更新为:</p>
<pre class="language-javascript hljs">export default function UppercaseForm({ html, state }) {</pre>
<p>然后，在<code><span class="output">&lt;span class="output"&gt;</span></code>中显示。</p>
<pre class="language-javascript hljs">&lt;div class="result"&gt;
Result: &lt;span class="output"&gt;${state.store.transformedText}&lt;/span&gt;
&lt;/div&gt;</pre>
<p>现在，如果您提交表单，您应该看到文本被转换为大写并显示在结果部分。</p>
<p>该应用程序正在按预期工作，可以部署。但是，我们可以通过显示结果而不重新加载页面来改进它。为此，让我们在客户端用一些JavaScript来增强我们的应用程序。</p>
<h2 id="adding-javascript-improve-user-experience">添加JavaScript以改善用户体验</h2>
<p>为了使定制元素在客户端可用(即浏览器中的JavaScript)，我们需要为浏览器重新定义元素。我们将在一个<code>&lt;script&gt;</code>标签中这样做。</p>
<p>为了简单起见，让我们将其定义为<code>app/elements/uppercase-form.mjs</code>中自定义元素HTML中的内联JavaScript。</p>
<p>所以，将这个<code>&lt;script&gt;</code>添加到<code>&lt;/main&gt;</code>下面的自定义元素HTML中。</p>
<pre class="language-html hljs">&lt;script type="module"&gt;
  class UppercaseForm extends HTMLElement {
    constructor () {
      super()
      this.form = this.querySelector('form')
      this.output = this.querySelector('.output')
      this.form.addEventListener('submit', this.onSubmit.bind(this))
    }

    async onSubmit (e) {
      e.preventDefault()

      const formData = new FormData(e.target)
      const queryString = new URLSearchParams(formData).toString()

      const result = await fetch('/?' + queryString, {
        headers: { 'accept': 'application/json' },
        method: 'get'
      })

      const json = await result.json()
      this.output.textContent = json.transformedText
    }
  }

  customElements.define('uppercase-form', UppercaseForm)
&lt;/script&gt;</pre>
<p>添加这个之后，<code>uppercase-form</code>元素在浏览器端会有点“水化”。</p>
<p>现在，当用户提交表单时，客户端JavaScript将通过使用浏览器的本地<a href="https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API/Using_Fetch#:~:text=The%20Fetch%20API%20provides%20a,resources%20asynchronously%20across%20the%20network">获取API </a>发送请求来处理表单。但是请注意，我们如何需要将headers设置为<code>{ 'accept': 'application/json' }</code>,以使我们的API route将其作为JSON响应而不是常规的HTML响应返回。</p>
<p>如果您现在测试应用程序，它应该会转换文本并显示它，而无需重新加载页面。</p>
<p>这种方法的好处是，即使浏览器禁用了JavaScript，我们的应用程序仍然可以工作，因为它是逐步增强的。</p>
<h2 id="conclusion">结论</h2>
<p>关于Enhance还有更多需要学习的地方。我鼓励你查看文档来了解它的所有特性。</p>
<p>我们在本教程中探索的重要的事情是，当我们想用渐进式增强来构建我们的应用程序时，增强是多么强大。</p>
<p>做完本教程的项目，我推荐尝试不用JavaScript搭建一个计数器app，然后用JavaScript完善。如果您需要这方面的帮助，请查看文档中的<a href="https://www.google.com/url?q=https://enhance.dev/docs/learn/concepts/routing/api-routes&amp;sa=D&amp;source=docs&amp;ust=1671735801637107&amp;usg=AOvVaw0GQBcQntXl2HE_-yndI6BL">示例。</a></p><div class="code-block code-block-4">
<div class="blog-plug base-cta"><h2>使用<a class="signup" href="https://lp.logrocket.com/blg/signup" target="_blank" rel="noopener noreferrer"> LogRocket </a>消除传统错误报告的干扰</h2>
<a href="https://lp.logrocket.com/blg/signup" class="signup" target="_blank" rel="noopener noreferrer"><img class="alignnone size-full wp-image-46 jetpack-lazy-image" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/><noscript><img data-lazy-fallback="1" class="alignnone size-full wp-image-46" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/></noscript></a>
<p><a href="https://lp.logrocket.com/blg/signup" target="_blank" rel="noopener noreferrer"> LogRocket </a>是一个数字体验分析解决方案，它可以保护您免受数百个假阳性错误警报的影响，只针对几个真正重要的项目。LogRocket会告诉您应用程序中实际影响用户的最具影响力的bug和UX问题。</p>
<p>然后，使用具有深层技术遥测的会话重放来确切地查看用户看到了什么以及是什么导致了问题，就像你在他们身后看一样。</p>
<p>LogRocket自动聚合客户端错误、JS异常、前端性能指标和用户交互。然后LogRocket使用机器学习来告诉你哪些问题正在影响大多数用户，并提供你需要修复它的上下文。</p>
<p>关注重要的bug—<a class="signup" href="https://lp.logrocket.com/blg/signup-issue-free" target="_blank" rel="noopener noreferrer">今天就试试LogRocket】。</a></p></div></div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
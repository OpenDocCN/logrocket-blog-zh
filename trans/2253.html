<html>
<head>
<title>The complete guide to internationalization in Next.js - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>Next.js - LogRocket 博客中的国际化完整指南</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/complete-guide-internationalization-nextjs/#0001-01-01">https://blog.logrocket.com/complete-guide-internationalization-nextjs/#0001-01-01</a></blockquote><div><article class="article-post">
<p>将 web 应用程序翻译成多种语言是一种常见的需求。在过去，创建多语言应用程序不是一件容易的事情，但是最近(多亏了<a href="https://blog.logrocket.com/new-features-in-next-js-11/" target="_blank" rel="noopener"> Next.js </a>框架和<a href="https://blog.logrocket.com/how-to-set-up-internationalization-in-react-using-lingui-js/" target="_blank" rel="noopener"> Lingui.js </a>库背后的人们),这项任务变得容易多了。</p>
<p>在这篇文章中，我将向您展示如何用前面提到的工具构建国际化的应用程序。我们将创建一个支持静态呈现和按需语言切换的示例应用程序。</p>
<p><img data-attachment-id="71781" data-permalink="https://blog.logrocket.com/complete-guide-internationalization-nextjs/internationalized-nextjs-application/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2021/10/internationalized-nextjs-application.gif" data-orig-size="542,472" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="internationalized-nextjs-application" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2021/10/internationalized-nextjs-application-300x261.gif" data-large-file="https://blog.logrocket.com/wp-content/uploads/2021/10/internationalized-nextjs-application.gif" decoding="async" class="size-full wp-image-71781 aligncenter jetpack-lazy-image" src="../Images/6db7eafedaf564b2fea444355bdc2f0f.png" alt="Gif of sample Next.js application switching between languages" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2021/10/internationalized-nextjs-application.gif?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2021/10/internationalized-nextjs-application.gif"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="71781" data-permalink="https://blog.logrocket.com/complete-guide-internationalization-nextjs/internationalized-nextjs-application/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2021/10/internationalized-nextjs-application.gif" data-orig-size="542,472" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="internationalized-nextjs-application" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2021/10/internationalized-nextjs-application-300x261.gif" data-large-file="https://blog.logrocket.com/wp-content/uploads/2021/10/internationalized-nextjs-application.gif" decoding="async" loading="lazy" class="size-full wp-image-71781 aligncenter" src="../Images/6db7eafedaf564b2fea444355bdc2f0f.png" alt="Gif of sample Next.js application switching between languages" data-original-src="https://blog.logrocket.com/wp-content/uploads/2021/10/internationalized-nextjs-application.gif"/></noscript>
<p>你可以<a href="https://linguijs-translation-demo.vercel.app/">在这里查看演示</a>和<a href="https://github.com/ivandotv/nextjs-translation-demo" target="_blank" rel="noopener">分叉库</a>。</p>
<h2>设置</h2>
<p>首先，我们需要用 TypeScript 创建 Next.js 应用程序。在终端中输入以下内容:</p>
<pre class="language-typescript hljs">npx create-next-app --ts
</pre>
<p>接下来，我们需要安装所有需要的模块:</p>
<pre class="language-shell hljs">npm install --save-dev @lingui/cli @lingui/loader @lingui/macro babel-plugin-macros @babel/core
npm install --save @lingui/react make-plural
</pre>
<h2>Next.js 中的国际化路由</h2>
<p>国际化 Next.js 应用程序的一个基本方面是国际化路由功能，因此具有不同语言偏好的用户可以进入不同的页面，并能够链接到这些页面。</p>
<p>此外，通过在网站头部添加适当的链接标签，你可以告诉谷歌在哪里可以找到所有其他语言版本的网页，以便进行正确的索引。</p>
<p>Next.js 支持两种国际化路由场景。</p>
<p>第一个是子路径路由，其中第一个子路径(www.myapp.com/{language}/blog)标记将要使用的语言。比如<code><a href="http://www.myapp.com/en/tasks" rel="nofollow">http://www.myapp.com/en/tasks</a></code>或者<code><a href="http://www.myapp.com/es/tasks" rel="nofollow">http://www.myapp.com/es/tasks</a></code>。在第一个例子中，用户将使用英语版本的应用程序(<code>en</code>)，在第二个例子中，用户将使用西班牙语版本(<code>es</code>)。</p>
<p>第二个是域路由。通过域路由，您可以拥有同一个应用程序的多个域，每个域将服务于不同的语言。比如<code>en.myapp.com/tasks</code>或者<code>es.myapp.com/tasks</code>。</p>
<h3>Next.js 如何检测用户的语言</h3>
<p>当用户访问应用程序的根页面或索引页面时，Next.js 将尝试根据<code>Accept-Language</code>头自动检测用户喜欢的位置。如果设置了语言的位置(通过 Next.js 配置文件)，用户将被重定向到该路由。</p>
<p>如果不支持该位置，将为用户提供默认语言路线。该框架还可以使用 cookie 来确定用户的语言。</p>
<p>如果用户的浏览器中存在<code>NEXT_LOCALE</code> cookie，那么框架将使用该值来决定向用户提供哪种语言路由，而<code>Accept-Language</code>头将被忽略。</p>
<h2>配置我们的示例 Next.js 应用程序</h2>
<p>我们的演示将使用三种语言:默认英语(<code>en</code>)、西班牙语(<code>es</code>)和我的母语塞尔维亚语(<code>sr</code>)。</p>
<p>因为默认语言是英语，所以任何其他不支持的语言都将默认为英语。</p>
<p>我们还将使用<code>subpath</code>路由来传递页面，就像这样:</p>
<pre class="language-javascript hljs">//next.config.js

module.exports = {
  i18n: {
    locales: ['en', 'sr', 'es', 'pseudo'],
    defaultLocale: 'en'
  }
}
</pre>
<p>在这个代码块中，<code>locales</code>是我们想要支持的所有语言，<code>defaultLocale</code>是默认语言。</p>
<p>你会注意到，在配置中，还有第四种语言:<code>pseudo</code>。我们稍后将对此进行更多讨论。</p>
<p>如您所见，这个 Next.js 配置很简单，因为该框架仅用于路由，没有其他用途。如何翻译你的应用取决于你自己。</p>
<h2>配置 Lingui.js</h2>
<p>对于实际的翻译，我们将使用<a href="https://lingui.js.org/" target="_blank" rel="noopener"> Lingui.js </a>。</p>
<p>让我们设置配置文件:</p>
<pre class="language-javascript hljs">// lingui.config.js

module.exports = {
  locales: ['en', 'sr', 'es', 'pseudo'],
  pseudoLocale: 'pseudo',
  sourceLocale: 'en',
  fallbackLocales: {
    default: 'en'
  },
  catalogs: [
    {
      path: 'src/translations/locales/{locale}/messages',
      include: ['src/pages', 'src/components']
    }
  ],
  format: 'po'
}
</pre>
<p>Lingui.js 的配置比 Next.js 更复杂，所以让我们一个一个地检查每个部分。</p>
<p><code>locales</code>和<code>pseudoLocale</code>都是我们要生成的位置，哪些位置会分别作为伪位置。</p>
<p><code>sourceLocale</code>后面跟有<code>en</code>,因为生成翻译文件时，默认字符串是英文的。这意味着，如果您不翻译某个字符串，它将保留默认或源语言。</p>
<p><code>fallbackLocales</code>属性与 Next.js 的默认语言环境无关，它只是意味着如果你试图加载一个不存在的语言文件，Lingui.js 将退回到<code>default</code>语言(在我们的例子中是英语)。</p>
<p><code>catalogs:path</code>是保存生成文件的路径。<code>catalogs:include</code>指示 Lingui.js 在哪里寻找需要翻译的文件。在我们的例子中，这是<code>src/pages</code>目录，我们所有的 React 组件都位于<code>src/components</code>中。</p>
<p><code>format</code>是生成文件的格式。我们使用推荐的<code>po</code>格式，但也有其他格式，如<code>json</code>。</p>
<h2>Lingui.js 如何使用 React</h2>
<p>有两种方法可以将 Lingui.js 与 React 一起使用。我们可以使用库提供的常规 React 组件，也可以使用库提供的 Babel 宏。</p><div class="code-block code-block-54">
<hr/>
<h3>更多来自 LogRocket 的精彩文章:</h3>

<hr/></div>
<p>Linqui.js 有专门的 React 组件和 Babel 宏。在 Babel 处理代码生成最终的 JavaScript 代码之前，宏会对代码进行转换。</p>
<p>如果你想知道这两者之间的区别，看看这些例子:</p>
<pre class="language-javascript hljs">//Macro
import { Trans } from '@lingui/macro'

function Hello({ name }: { name: string }) {
  return &lt;Trans&gt;Hello {name}&lt;/Trans&gt;
}


//Regular React component
import { Trans } from '@lingui/react'

function Hello({ name }: { name: string }) {
  return &lt;Trans id="Hello {name}" values={{ name }} /&gt;
}
</pre>
<p>可以看到，宏和生成的 React 组件之间的代码非常相似。宏使我们能够省略<code>id</code>属性并编写更干净的组件。</p>
<p>现在让我们为其中一个组件设置翻译:</p>
<pre class="language-JSX hljs">// src/components/AboutText.jsx

import { Trans } from '@lingui/macro'

function AboutText() {
  return (
    &lt;p&gt;
      &lt;Trans id="next-explanation"&gt;My text to be translated&lt;/Trans&gt;
    &lt;/p&gt;
  )
}
</pre>
<p>在我们完成组件之后，下一步是从源代码中提取文本，这些文本需要被翻译成称为消息目录的外部文件。</p>
<p>消息目录是您希望交给翻译人员进行翻译的文件。每种语言都会生成一个文件。</p>
<p>为了提取所有消息，我们将通过命令行使用 Lingui.js 并运行:</p>
<pre class="language-shell hljs">npm run lingui extract
</pre>
<p>输出应该如下所示:</p>
<pre class="language-shell hljs">Catalog statistics:
┌──────────┬─────────────┬─────────┐
│ Language │ Total count │ Missing │
├──────────┼─────────────┼─────────┤
│ es       │      1      │    1    │
│ en       │      1      │    0    │
│ sr       │      1      │    1    │
└──────────┴─────────────┴─────────┘

(use "lingui extract" to update catalogs with new messages)
(use "lingui compile" to compile catalogs for production)
</pre>
<p><code>Total count</code>是需要翻译的消息总数，在我们的代码中只有一条来自<code>AboutText.jsx</code> (ID: <code>next-explanation</code>)的消息。</p>
<p><code>Missing</code>是需要翻译的消息数量。因为英语是默认语言，所以<code>en</code>版本没有丢失消息。但是，我们缺少塞尔维亚语和西班牙语的翻译。</p>
<p><code>en</code>生成的文件的内容将是这样的:</p>
<pre class="language-JSX hljs">#: src/components/AboutText.jsx:5
msgid "next-explanation"
msgstr "My text to be translated"
</pre>
<p><code>es</code>文件的内容如下:</p>
<pre class="language-JSX hljs">#: src/components/AboutText.jsx:5
msgid "next-explanation"
msgstr ""
</pre>
<p>您会注意到<code>msgstr</code>是空的。这是我们需要添加翻译的地方。如果我们将该字段留空，那么在运行时，引用这个<code>msgid</code>的所有组件都将用默认语言文件中的字符串填充。</p>
<p>让我们翻译西班牙文文件:</p>
<pre class="language-JSX hljs">#: src/components/AboutText.jsx:5
msgid "next-explanation"
msgstr "Mi texto para ser traducido"
</pre>
<p>现在，如果我们再次运行<code>extract</code>命令，输出如下:</p>
<pre class="language-shell hljs">Catalog statistics:
┌──────────┬─────────────┬─────────┐
│ Language │ Total count │ Missing │
├──────────┼─────────────┼─────────┤
│ es       │      1      │    0    │
│ en       │      1      │    0    │
│ sr       │      1      │    1    │
└──────────┴─────────────┴─────────┘

(use "lingui extract" to update catalogs with new messages)
(use "lingui compile" to compile catalogs for production)
</pre>
<p>注意，西班牙语的<code>Missing</code>字段是<code>0</code>，这意味着我们已经翻译了西班牙语文件中所有缺失的字符串。</p>
<p>这是翻译的要旨，现在让我们开始将 Lingui.js 与 Next.js 整合。</p>
<h3>编译消息</h3>
<p>为了让应用程序使用带翻译的文件(<code>.po</code>文件)，需要将它们编译成 JavaScript。为此，我们需要使用<code>lingui compile</code> CLI 命令。</p>
<p>命令运行完毕后，您会注意到在<code>locale/translations</code>目录中有每个地区的新文件(<code>es.js</code>、<code>en.js</code>和<code>sr.js</code>):</p>
<pre class="language-javascript hljs">├── en
│   ├── messages.js
│   └── messages.po
├── es
│   ├── messages.js
│   └── messages.po
└── sr
    ├── messages.js
    └── messages.po
</pre>
<p>这些是将要加载到应用程序中的文件。将这些文件视为构建工件，不要用源代码管理来管理它们；只有<code>.po</code>文件应该添加到源代码控制中。</p>
<h3>使用复数</h3>
<p>另一件肯定会出现的事情是处理单数或复数单词(在演示中，您可以用<strong> Developers </strong> dropdown 元素来测试)。</p>
<p>Lingui.js 让这变得非常简单:</p>
<pre class="language-javascript hljs">import { Plural } from '@lingui/macro'

function Developers({ developerCount }) {
  return (
    &lt;p&gt;
      &lt;Plural
        value={developerCount}
        one="Whe have # Developer"
        other="We have # Developers"
      /&gt;
    &lt;/p&gt;
  )
}
</pre>
<p>当<code>developerCount</code>值为<code>1</code>时，<code>Plural</code>组件会呈现“我们有 1 个开发者”</p>
<p>你可以在 Lingui.js 文档中阅读更多关于复数的内容。</p>
<p>现在，不同的语言有不同的多元化规则。为了适应这些规则，我们稍后将使用一个名为<a href="https://www.npmjs.com/package/make-plural" target="_blank" rel="noopener"> <code>make-plural</code> </a>的附加包。</p>
<h2>Next.js 和 Lingui.js 集成</h2>
<p>现在是最难的部分:将 Lingui.js 与 Next.js 框架集成。</p>
<p>首先，我们要初始化 Lingui.js:</p>
<pre class="language-Typescript hljs">// utils.ts

import type { I18n } from '@lingui/core'
import { en, es, sr } from 'make-plural/plurals'

//anounce which locales we are going to use and connect them to approprite plural rules
export function initTranslation(i18n: I18n): void {
  i18n.loadLocaleData({
    en: { plurals: en },
    sr: { plurals: sr },
    es: { plurals: es },
    pseudo: { plurals: en }
  })
}
</pre>
<p>因为整个应用程序只需初始化一次，所以我们将从 Next.js <code><a href="https://nextjs.org/docs/advanced-features/custom-app" target="_blank" rel="noopener">_app</a></code>组件调用该函数，该组件按照设计包装了所有其他组件:</p>
<pre class="language-tsx hljs">// _app.tsx

import { i18n } from '@lingui/core'
import { initTranslation } from '../utils'

//initialization function
initTranslation(i18n)

function MyApp({ Component, pageProps }) {
  // code ommited
}
</pre>
<p>Lingui.js 代码初始化后，我们需要加载并激活适当的语言。</p>
<p>同样，我们将使用<code>_app</code>来表示，就像这样:</p>
<pre class="language-tsx hljs">// _app.tsx

function MyApp({ Component, pageProps }) {
  const router = useRouter()
  const locale = router.locale || router.defaultLocale
  const firstRender = useRef(true)

  if (pageProps.translation &amp;&amp; firstRender.current) {
    //load the translations for the locale
    i18n.load(locale, pageProps.translation)
    i18n.activate(locale)
    // render only once
    firstRender.current = false
  }

  return (
    &lt;I18nProvider i18n={i18n}&gt;
      &lt;Component {...pageProps} /&gt;
    &lt;/I18nProvider&gt;
  )
}
</pre>
<p>所有使用翻译的组件都需要在 Lingui.js <code>&lt;I18Provider&gt;</code>组件下。为了确定加载哪种语言，我们将研究 Next.js 路由器<code>locale</code>的属性。</p>
<p>翻译通过<code>pageProps.translation</code>传递给组件。如果您想知道<code>pageProps.translation</code>属性是如何创建的，我们接下来将解决这个问题。</p>
<p>在呈现之前，<code>src/pages</code>中的每个页面都需要加载适当的翻译文件，该文件位于<code>src/translations/locales/{locale}</code>中。</p>
<p>因为我们的页面是静态生成的，所以我们将通过 Next.js <code>getStatisProps</code>函数来完成:</p>
<pre class="language-tsx hljs">// src/pages/index.tsx

export const getStaticProps: GetStaticProps = async (ctx) =&gt; {
  const translation = await loadTranslation(
    ctx.locale!,
    process.env.NODE_ENV === 'production'
  )

  return {
    props: {
      translation
    }
  }
}
</pre>
<p>如您所见，我们正在用<code>loadTranslation</code>函数加载翻译文件。看起来是这样的:</p>
<pre class="language-Typescript hljs">// src/utils.ts

async function loadTranslation(locale: string, isProduction = true) {
  let data
  if (isProduction) {
    data = await import(`./translations/locales/${locale}/messages`)
  } else {
    data = await import(
      `@lingui/loader!./translations/locales/${locale}/messages.po`
    )
  }

  return data.messages
}
</pre>
<p>这个函数有趣的地方在于，它根据我们是否在生产中运行 Next.js 项目来有条件地加载文件。</p>
<p>这是 Lingui.js 的伟大之处之一；当我们在生产中时，我们将加载编译的(<code>.js</code>)文件，但是当我们在开发模式中时，我们将加载源文件(<code>.po</code>)。一旦我们改变了<code>.po</code>文件中的代码，它将立即反映在我们的应用程序中。</p>
<p>记住，<code>.po</code>文件是我们编写翻译的源文件，然后编译成普通的<code>.js</code>文件，用常规的 JavaScript <code>import</code>语句加载到产品中。要不是专门的<a href="https://lingui.js.org/ref/loader.html?highlight=loader#api-reference-webpack-loader-lingui-loader" target="_blank" rel="noopener"> <code>@lingui/loader!</code> </a> webpack 插件，我们就要不断手动编译翻译文件，才能在开发的同时看到变化。</p>
<h2>动态改变语言</h2>
<p>到目前为止，我们处理了静态生成，但是我们还希望能够在运行时通过下拉菜单动态地更改语言。</p>
<p>首先，我们需要修改<code>_app</code>组件来观察位置变化，并在<code>router.locale</code>值变化时开始加载适当的翻译。这非常简单；我们需要做的就是使用<code>useEffect</code>钩子。</p>
<p>这是最后一个<code>_app</code>组件:</p>
<pre class="language-tsx hljs">// _app.tsx
// import statements omitted

initTranslation(i18n)

function MyApp({ Component, pageProps }) {
  const router = useRouter()
  const locale = router.locale || router.defaultLocale
  const firstRender = useRef(true)

  // run only once on the first render (for server side)
  if (pageProps.translation &amp;&amp; firstRender.current) {
    i18n.load(locale, pageProps.translation)
    i18n.activate(locale)
    firstRender.current = false
  }

  // listen for the locale changes
  useEffect(() =&gt; {
    if (pageProps.translation) {
      i18n.load(locale, pageProps.translation)
      i18n.activate(locale)
    }
  }, [locale, pageProps.translation])

  return (
    &lt;I18nProvider i18n={i18n}&gt;
      &lt;Component {...pageProps} /&gt;
    &lt;/I18nProvider&gt;
  )
}
</pre>
<p>接下来，我们需要构建下拉组件。每次用户从下拉菜单中选择不同的语言时，我们都要加载相应的页面。</p>
<p>为此，我们将使用 Next.js <code><a href="https://nextjs.org/docs/api-reference/next/router#routerpush" target="_blank" rel="noopener">router.push</a></code>方法来指示 Next.js 更改页面的区域设置(这将依次被我们在<code>_app</code>组件中创建的<code>useEffect</code>获取):</p>
<pre class="language-tsx hljs">// src/components/Switcher.tsx

import { useRouter } from 'next/router'
import { useState, useEffect } from 'react'
import { t } from '@lingui/macro'

type LOCALES = 'en' | 'sr' | 'es' | 'pseudo'

export function Switcher() {
  const router = useRouter()
  const [locale, setLocale] = useState&lt;LOCALES&gt;(
    router.locale!.split('-')[0] as LOCALES
  )

  const languages: { [key: string]: string } = {
    en: t`English`,
    sr: t`Serbian`,
    es: t`Spanish`
  }

  // enable 'pseudo' locale only for development environment
  if (process.env.NEXT_PUBLIC_NODE_ENV !== 'production') {
    languages['pseudo'] = t`Pseudo`
  }

  useEffect(() =&gt; {
    router.push(router.pathname, router.pathname, { locale })
  }, [locale, router])

  return (
    &lt;select
      value={locale}
      onChange={(evt) =&gt; setLocale(evt.target.value as LOCALES)}
    &gt;
      {Object.keys(languages).map((locale) =&gt; {
        return (
          &lt;option value={locale} key={locale}&gt;
            {languages[locale as unknown as LOCALES]}
          &lt;/option&gt;
        )
      })}
    &lt;/select&gt;
  )
}
</pre>
<h2>假定位</h2>
<p>现在，我将处理您在示例中看到的所有<code>pseudo</code>代码。</p>
<p>伪本地化是一种软件测试方法，它用改变的版本替换文本字符串，同时仍然保持字符串的可见性。这使得我们很容易发现 Lingui.js 组件或宏中遗漏了哪些字符串。</p>
<p>因此，当用户切换到<code>pseudo</code>语言环境时，应用程序中的所有文本都应该像这样修改:</p>
<pre class="language-shell hljs">Account Settings --&gt; [!!! Àççôûñţ Šéţţîñĝš !!!]
</pre>
<p>如果有任何文本没有被修改，这意味着我们可能忘记这样做。当谈到 Next.js 时，框架没有特殊的<code>pseudo</code>本地化的概念，它只是另一种要路由到的语言。但是，Lingui.js 需要特殊的配置。</p>
<p>除此之外，<code>pseudo</code>只是我们可以切换到的另一种语言。<code>pseudo</code>区域设置只能在<code>development</code>模式下启用。</p>
<h2>结论</h2>
<p>在本文中，我向您展示了如何翻译和国际化 Next.js 应用程序。我们已经完成了多种语言的静态渲染和按需语言切换。我们还创建了一个很好的开发工作流程，在这个流程中，我们不必在每次更改时手动编译翻译字符串。接下来，我们实现了一个<code>pseudo</code>语言环境，以便直观地检查是否有遗漏的翻译。</p>
<p>如果您有任何问题，请在评论中发表，或者如果您发现演示中的代码有任何问题，请确保在<a href="https://github.com/ivandotv/nextjs-translation-demo" target="_blank" rel="noopener"> github 库</a>上打开一个问题。</p><div class="code-block code-block-30">
<div class="blog-plug inline-plug next-plug"><h2><a href="https://lp.logrocket.com/blg/nextjs-signup" target="_blank"> LogRocket </a>:全面了解生产 Next.js 应用</h2><p>调试下一个应用程序可能会很困难，尤其是当用户遇到难以重现的问题时。如果您对监视和跟踪状态、自动显示 JavaScript 错误、跟踪缓慢的网络请求和组件加载时间感兴趣，</p><a href="https://lp.logrocket.com/blg/nextjs-signup" target="_blank">try LogRocket</a><p>. </p><a class="signup" href="https://lp.logrocket.com/blg/nextjs-signup" target="_blank" rel="noopener noreferrer"><img class="alignnone size-full wp-image-46 jetpack-lazy-image" src="../Images/f300c244a1a1cf916df8b4cb02bec6c6.png" data-lazy-src="https://files.readme.io/27c94e7-Image_2017-06-05_at_9.46.04_PM.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://files.readme.io/27c94e7-Image_2017-06-05_at_9.46.04_PM.png"/><noscript><img data-lazy-fallback="1" class="alignnone size-full wp-image-46" src="../Images/f300c244a1a1cf916df8b4cb02bec6c6.png" data-original-src="https://files.readme.io/27c94e7-Image_2017-06-05_at_9.46.04_PM.png"/></noscript></a><a class="signup" href="https://lp.logrocket.com/blg/nextjs-signup" target="_blank" rel="noopener noreferrer"><img class="alignnone size-full wp-image-46 jetpack-lazy-image" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/><noscript><img data-lazy-fallback="1" class="alignnone size-full wp-image-46" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/></noscript></a><p>LogRocket 就像是网络和移动应用的 DVR，记录下你的 Next.js 应用上发生的一切。您可以汇总并报告问题发生时应用程序的状态，而不是猜测问题发生的原因。LogRocket 还可以监控应用程序的性能，报告客户端 CPU 负载、客户端内存使用等指标。</p><p>LogRocket Redux 中间件包为您的用户会话增加了一层额外的可见性。LogRocket 记录 Redux 存储中的所有操作和状态。</p><p>让您调试 Next.js 应用的方式现代化— <a class="signup" href="https://lp.logrocket.com/blg/nextjs-signup" target="_blank" rel="noopener noreferrer">开始免费监控</a>。</p></div></div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
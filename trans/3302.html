<html>
<head>
<title>6 modern C# features for cleaner Unity code - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>6个现代C#特性，让Unity代码更简洁</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/6-modern-c-sharp-features-cleaner-unity-code/#0001-01-01">https://blog.logrocket.com/6-modern-c-sharp-features-cleaner-unity-code/#0001-01-01</a></blockquote><div><article class="article-post">
<p>从C# 7.0开始，许多帮助我们编写更少代码的代码改进已经被添加到语言中。本教程将重点介绍六个新特性，它们可以帮助我们编写更简洁易读的代码，以及我们如何在Unity的C#上使用这些特性。</p>
<p>这些是教程部分:</p>

<h2 id="prerequisites">先决条件</h2>
<p>本教程需要满足以下先决条件:</p>
<ul>
<li>统一的基本知识</li>
<li>以前在Unity中编写C#脚本的经验</li>
</ul>
<h2 id="setting-up-our-unity-project">设置我们的Unity项目</h2>
<p>首先，我们需要创建我们的Unity项目。对于本教程，我们将使用版本2021.3.4f1，在我写这篇文章的时候，这是最新的LTS Unity版本。</p>
<p>在项目模板列表中，选择<strong> 2D(核心)</strong>(最简单的)，给它命名，然后点击<strong>创建项目</strong>按钮。</p>
<p><img data-attachment-id="129475" data-permalink="https://blog.logrocket.com/6-modern-c-sharp-features-cleaner-unity-code/attachment/create-project-screenshot/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/08/create-project-screenshot.png" data-orig-size="730,425" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Create project screenshot" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/08/create-project-screenshot-300x175.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/08/create-project-screenshot.png" decoding="async" class="aligncenter size-full wp-image-129475 jetpack-lazy-image" src="../Images/0ea25c6986c8eb3734e2f527bd43951a.png" alt="Create Project Screenshot" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2022/08/create-project-screenshot.png 730w, https://blog.logrocket.com/wp-content/uploads/2022/08/create-project-screenshot-300x175.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2022/08/create-project-screenshot.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/08/create-project-screenshot.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="129475" data-permalink="https://blog.logrocket.com/6-modern-c-sharp-features-cleaner-unity-code/attachment/create-project-screenshot/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/08/create-project-screenshot.png" data-orig-size="730,425" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Create project screenshot" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/08/create-project-screenshot-300x175.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/08/create-project-screenshot.png" decoding="async" loading="lazy" class="aligncenter size-full wp-image-129475" src="../Images/0ea25c6986c8eb3734e2f527bd43951a.png" alt="Create Project Screenshot" srcset="https://blog.logrocket.com/wp-content/uploads/2022/08/create-project-screenshot.png 730w, https://blog.logrocket.com/wp-content/uploads/2022/08/create-project-screenshot-300x175.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/08/create-project-screenshot.png"/></noscript>
<p>项目启动后，在<code>Assets</code>文件夹中创建一个名为<code>Scripts</code>的文件夹。在教程中，我们将使用它们来保持我们的项目有条理。</p>
<p><img data-attachment-id="129478" data-permalink="https://blog.logrocket.com/6-modern-c-sharp-features-cleaner-unity-code/attachment/assets-project-folder/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/08/assets-project-folder.png" data-orig-size="528,192" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Assets project folder" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/08/assets-project-folder-300x109.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/08/assets-project-folder.png" decoding="async" class="aligncenter size-full wp-image-129478 jetpack-lazy-image" src="../Images/7812177d9d61bb94b1c7e6649cfdcb9b.png" alt="Assets Project Folder" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2022/08/assets-project-folder.png 528w, https://blog.logrocket.com/wp-content/uploads/2022/08/assets-project-folder-300x109.png 300w" data-lazy-sizes="(max-width: 528px) 100vw, 528px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2022/08/assets-project-folder.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/08/assets-project-folder.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="129478" data-permalink="https://blog.logrocket.com/6-modern-c-sharp-features-cleaner-unity-code/attachment/assets-project-folder/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/08/assets-project-folder.png" data-orig-size="528,192" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Assets project folder" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/08/assets-project-folder-300x109.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/08/assets-project-folder.png" decoding="async" loading="lazy" class="aligncenter size-full wp-image-129478" src="../Images/7812177d9d61bb94b1c7e6649cfdcb9b.png" alt="Assets Project Folder" srcset="https://blog.logrocket.com/wp-content/uploads/2022/08/assets-project-folder.png 528w, https://blog.logrocket.com/wp-content/uploads/2022/08/assets-project-folder-300x109.png 300w" sizes="(max-width: 528px) 100vw, 528px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/08/assets-project-folder.png"/></noscript>
<h2 id="tutorial-structure">教程结构</h2>
<p>对于如何使用新的C#特性的每个示例，我们将首先看看以前是如何完成的，然后看看我们如何使用新特性编写更少、更可读的代码。</p>
<p>下面的类只是在整个教程的所有示例中使用的存根。您可以将它们添加到<code>Scripts</code>文件夹内的脚本中:</p>
<pre class="language-csharp hljs">// GAME MODE.
public enum GameMode
{
    TimeAttack,
    Survive,
    Points
}

// ENEMIES.
public abstract class Enemy
{
    public bool IsVisible { get; set; }
    public bool HasArmor { get; set; }
}
 
public class Minion : Enemy { }
public class Troll : Enemy { }
public class Vampire : Enemy { }

public class Zombie : Enemy { }


// WEAPONS.
public abstract class Weapon { }
public class Stake : Weapon { }
public class Shotgun : Weapon { }</pre>
<h2 id="c-sharp-features-support-in-unity">Unity中的C#特性支持</h2>
<p>在C#版本8和9中，语言中加入了许多新特性。您可以在下面的链接中阅读每个版本的完整功能列表:</p>

<h3 id="c-sharp-8-and-9-features-in-unity-whats-missing">Unity中的C# 8和c # 9特性:缺少什么？</h3>
<p>对C# 8的统一支持从版本<a href="https://docs.unity3d.com/2020.2/Documentation/Manual/CSharpCompiler.html" target="_blank" rel="noopener"> 2020.2 </a>开始，C# 9从版本<a href="https://docs.unity3d.com/2021.2/Documentation/Manual/CSharpCompiler.html" target="_blank" rel="noopener"> 2021.2 </a>开始。</p>
<p>请注意，Unity并不支持所有的C# 8和c# 9特性，比如:</p>
<ul>
<li>默认接口方法</li>
<li>指数和范围</li>
<li>异步流</li>
<li>异步一次性</li>
<li>抑制发出局部初始化标志</li>
<li>协变返回类型</li>
<li>模块初始化器</li>
<li>非托管函数指针的可扩展调用约定</li>
<li>仅初始化设置器</li>
</ul>
<p>这些不受支持的特性大多用于非常特殊的场景，比如非托管函数指针的<a href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/proposals/csharp-9.0/function-pointers" target="_blank" rel="noopener">可扩展调用约定</a>，有些则不然，比如<a href="https://docs.microsoft.com/en-us/dotnet/csharp/whats-new/csharp-8#indices-and-ranges" target="_blank" rel="noopener">索引和范围</a>。</p>
<p>正因为如此，像索引和范围以及init only setters这样的特性可能会在Unity的未来版本中得到支持。然而，对于一个非常特殊的场景，一个不被支持的特性在未来获得Unity支持的机会比像<a href="https://docs.microsoft.com/en-us/dotnet/csharp/whats-new/csharp-8#indices-and-ranges" target="_blank" rel="noopener">索引和范围</a>这样的特性要小。</p>
<p>也许你可以找到一些变通方法来使用Unity中这些不支持的功能，但我不鼓励你这样做，因为Unity是一个跨平台的游戏引擎。新特性中的变通方法可能会导致难以理解、调试和解决的问题。</p>
<p>幸运的是，Unity支持C# 8和C # 9中一些更常见的模式和表达式。让我们回顾下面一些最有帮助的方法，看看它们如何让我们写出更干净的代码。</p>
<h2 id="switch-expression">开关表达式</h2>
<p>switch表达式可以极大地简化和减少<a href="https://en.wikipedia.org/wiki/Source_lines_of_code" target="_blank" rel="noopener"> LOC(代码行)</a>来生成<code>switch</code>，因为我们可以避免一堆样板代码，比如case和return语句。</p>
<p><em> <a href="https://docs.microsoft.com/en-us/dotnet/csharp/whats-new/csharp-8#switch-expressions" target="_blank" rel="noopener">文档提示</a>:开关表达式在表达式上下文中提供了类似开关的语义。当开关臂产生一个值时，它提供了一个简洁的语法。</em></p>
<p>通常，switch语句在其每个case块中产生一个值。开关表达式使您能够使用更简洁的表达式语法。重复的case和break关键字较少，花括号也较少。</p>
<h3>以前</h3>
<pre class="language-csharp hljs">public string GetModeTitleOld(GameMode mode)
{
    switch (mode)
    {
        case GameMode.Points:
            return "Points mode";

        case GameMode.Survive:
            return "Survive mode";

        case GameMode.TimeAttack:
            return "Time Attack mode";

        default:
            return "Unsupported game mode";
    }
}
</pre>
<h3>在...之后</h3>
<pre class="language-csharp hljs">public string GetModeTitleNew(GameMode mode)
{
    return mode switch
    {
        GameMode.Points =&gt; "Points mode",
        GameMode.Survive =&gt; "Survive mode",
        GameMode.TimeAttack =&gt; "Time Attack mode",
        _ =&gt; "Unsupported game mode",
    };
}</pre>
<h2 id="property-pattern">财产模式</h2>
<p>属性模式使您能够匹配在<code>switch</code>表达式中检查的对象的属性。</p>
<p>正如您在下面的示例中看到的，使用属性模式，我们可以将一系列的<code>if</code>语句转换成switch语句上的对象应该匹配的简单属性列表。</p>
<p><code>_ =&gt;</code>与经典<code>switch</code>上的<code>default</code>含义相同。</p>
<p><em> <a href="https://docs.microsoft.com/en-us/dotnet/csharp/whats-new/csharp-8#property-patterns" target="_blank" rel="noopener">单据提示</a>:当表达式结果非空，且每个嵌套模式都匹配表达式结果对应的属性或字段时，属性模式匹配表达式。</em></p>
<h3>以前</h3>
<pre class="language-csharp hljs">public float CalculateDamageOld(Enemy enemy)
{
    if (enemy.IsVisible)
        return enemy.HasArmor ? 1 : 2;

    return 0;
}</pre>
<h3>在...之后</h3>
<pre class="language-csharp hljs">public static float CalculateDamageNew(Enemy enemy) =&gt; enemy switch
{
    { IsVisible: true, HasArmor: true } =&gt; 1,
    { IsVisible: true, HasArmor: false } =&gt; 2,
    _ =&gt; 0
};</pre>
<h2 id="type-pattern">类型模式</h2>
<p>我们可以使用类型模式来检查表达式的运行时类型是否与给定的类型兼容。</p>
<p>类型模式与属性模式的逻辑几乎相同，但现在用于对象类型的上下文中。我们可以将一系列检查对象类型的<code>if</code>语句转换成一系列类型，这些类型是<code>switch</code>语句中的对象应该匹配的。</p>
<h3>之前之后</h3>
<pre class="language-csharp hljs">public static float GetEnemyStrengthOld(Enemy enemy)
{
    if (enemy is Minion)
        return 1;

    if (enemy is Troll)
        return 2;

    if (enemy is Vampire)
        return 3;

    if (enemy == null)
        throw new ArgumentNullException(nameof(enemy));

    throw new ArgumentException("Unknown enemy", nameof(enemy));
}</pre>
<h3>使用类型模式，我们从16行代码减少到只有8行代码，它们具有相同的结果，并且非常清晰易读。</h3>
<pre class="language-csharp hljs">public static float GetEnemyStrengthNew(Enemy enemy) =&gt; enemy switch
{
    Minion =&gt; 1,
    Troll =&gt; 2,
    Vampire =&gt; 3,
    null =&gt; throw new ArgumentNullException(nameof(enemy)),
    _ =&gt; throw new ArgumentException("Unknown enemy", nameof(enemy)),
};</pre>
<p>恒定模式</p>
<h2 id="constant-pattern">常量模式可用于测试表达式结果是否等于指定的常量。</h2>
<p>可能是最简单的模式匹配，它只是匹配一个常量值—例如，一个字符串—然后返回结果。</p>
<p>之前之后</p>
<h3>常量模式可以用于任何常量表达式，如<code>int</code>、<code>float</code>、<code>char</code>、<code>string</code>、<code>bool</code>和<code>enum</code>。</h3>
<pre class="language-csharp hljs">public Enemy CreateEnemyByNameOld(string name)
{
    if(name == null)
        throw new ArgumentNullException(nameof(name));

    if (name.Equals("Minion"))
        return new Minion();

    if (name.Equals("Troll"))
        return new Troll();

    if (name.Equals("Vampire"))
        return new Vampire();

    throw new ArgumentException($"Unknown enemy: {name}", nameof(name));
}</pre>
<h3>更多来自LogRocket的精彩文章:</h3>
<pre class="language-csharp hljs">public Enemy CreateEnemyByNameNew(string name) =&gt; name switch
{
    "Minion" =&gt; new Minion(),
    "Troll" =&gt; new Troll(),
    "Vampire" =&gt; new Vampire(),
    null =&gt; throw new ArgumentNullException(nameof(name)),
    _ =&gt; throw new ArgumentException($"Unknown enemy: {name}", nameof(name)),
};</pre>
<p>关系模式</p><div class="code-block code-block-54">
<hr/>
<h3>关系模式会将表达式结果与常数进行比较。</h3>

<hr/></div>
<h2 id="relational-pattern">这可能是最复杂的模式匹配，但其核心并不复杂。对于关系模式，我们可以直接使用逻辑操作符作为<code>&lt;</code>、<code>&gt;</code>、<code>&lt;=</code>或<code>&gt;=</code>来评估对象，然后为<code>switch</code>提供一个结果。</h2>
<p><em> <a href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/operators/patterns#relational-patterns" target="_blank" rel="noopener">文档提示</a>:关系模式的右边部分必须是常量表达式。</em></p>
<p>之前之后</p>
<p>任何一个<a href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/operators/comparison-operators" target="_blank" rel="noopener">关系操作符</a> <code>&lt;</code>、<code>&gt;</code>、<code>&lt;=</code>或<code>&gt;=</code>都可以用在一个关系模式上。</p>
<h3>逻辑模式</h3>
<pre class="language-csharp hljs">public string GetEnemyEnergyMessageOld(float energy)
{
    if(energy &lt; 0 || energy &gt; 1)
        throw new ArgumentException("Energy should be between 0.0 and 1.0", nameof(energy));

    if (energy &gt;= 1f)
        return "Healthy";

    if (energy &gt; .5f)
        return "Injured";

        return "Very hurt";
}</pre>
<h3>我们可以使用<code>not</code>、<code>and</code>和<code>or</code>模式组合子来创建逻辑表达式。</h3>
<pre class="language-csharp hljs">public string GetEnemyEnergyMessageNew(float energy) =&gt; energy switch
{
    &lt; 0 or &gt; 1 =&gt; throw new ArgumentException("Energy should be between 0.0 and 1.0", nameof(energy)),
    &gt;= 1 =&gt; "Healthy",
    &gt; .5f =&gt; "Injured",
    _ =&gt; "Very hurt"
};</pre>
<p>这就像是关系模式的扩展，您可以组合逻辑操作符<code>not</code>、<code>and</code>和<code>or</code>来创建更复杂和精细的模式匹配。</p>
<h2 id="logical-pattern"><em> <a href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/operators/patterns#logical-patterns" target="_blank" rel="noopener">文档提示</a>:您使用<code>not</code>、<code>and</code>和<code>or</code>模式组合器来创建以下逻辑模式:</em></h2>
<p><em>当被求反的模式不匹配表达式</em>时，匹配表达式的求反<code>not</code>模式</p>
<p><em>合取<code>and</code>模式，当两个模式都匹配表达式</em>时匹配表达式</p>
<p><em>析取<code>or</code>模式，当任一模式匹配表达式时匹配表达式</em></p>
<ul>
<li>以前</li>
<li>在...之后</li>
<li>结论</li>
</ul>
<h3>在本教程中，我们学习了如何使用开关表达式、属性模式、类型模式、常量模式、关系模式和逻辑模式在Unity上编写越来越少的现代C#代码。</h3>
<pre class="language-csharp hljs">public float CalculateEnergyLossByStakeOld(Enemy enemy)
{
    if (enemy == null)
        throw new ArgumentNullException(nameof(enemy));

    if (enemy is not Vampire)
        return .1f;

    return 1f;
}</pre>
<h3>希望您可以在下一个项目中使用其中的一些来节省您的时间，同时编写更干净的代码。</h3>
<pre class="language-csharp hljs">public float CalculateEnergyLossByStakeNew(Enemy enemy) =&gt; enemy switch
{
    null =&gt; throw new ArgumentNullException(nameof(enemy)),
    not Vampire =&gt; .1f,
    _ =&gt; 1f
};</pre>
<h2 id="conclusion">使用<a class="signup" href="https://lp.logrocket.com/blg/signup" target="_blank" rel="noopener noreferrer"> LogRocket </a>消除传统错误报告的干扰</h2>
<p><a href="https://lp.logrocket.com/blg/signup" target="_blank" rel="noopener noreferrer"> LogRocket </a>是一个数字体验分析解决方案，它可以保护您免受数百个假阳性错误警报的影响，只针对几个真正重要的项目。LogRocket会告诉您应用程序中实际影响用户的最具影响力的bug和UX问题。</p>
<p>然后，使用具有深层技术遥测的会话重放来确切地查看用户看到了什么以及是什么导致了问题，就像你在他们身后看一样。</p><div class="code-block code-block-4">
<div class="blog-plug base-cta"><h2>LogRocket自动聚合客户端错误、JS异常、前端性能指标和用户交互。然后LogRocket使用机器学习来告诉你哪些问题正在影响大多数用户，并提供你需要修复它的上下文。</h2>
<a href="https://lp.logrocket.com/blg/signup" class="signup" target="_blank" rel="noopener noreferrer"><img class="alignnone size-full wp-image-46 jetpack-lazy-image" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/><noscript><img data-lazy-fallback="1" class="alignnone size-full wp-image-46" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/></noscript></a>
<p>关注重要的bug—<a class="signup" href="https://lp.logrocket.com/blg/signup-issue-free" target="_blank" rel="noopener noreferrer">今天就试试LogRocket】。</a></p>
<p>Then, use session replay with deep technical telemetry to see exactly what the user saw and what caused the problem, as if you were looking over their shoulder.</p>
<p>LogRocket automatically aggregates client side errors, JS exceptions, frontend performance metrics, and user interactions. Then LogRocket uses machine learning to tell you which problems are affecting the most users and provides the context you need to fix it.</p>
<p>Focus on the bugs that matter — <a class="signup" href="https://lp.logrocket.com/blg/signup-issue-free" target="_blank" rel="noopener noreferrer">try LogRocket today</a>.</p></div></div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
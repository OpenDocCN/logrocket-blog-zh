<html>
<head>
<title>Understanding Astro islands architecture </title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>了解阿童木岛建筑</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/understanding-astro-islands-architecture/#0001-01-01">https://blog.logrocket.com/understanding-astro-islands-architecture/#0001-01-01</a></blockquote><div><article class="article-post">
<p>如今，我们都习惯于看到新的框架出现，并承诺彻底改变我们构建web的方式。然而，我们大多数时候仍然依赖于特定的UI库(React、Vue、Svelte等)。)来定义我们的组件并为用户构建体验。</p>
<p>这一次，故事不同了！利用<a href="https://vite.js/"> Vite.js </a>的力量，我们得到了Astro:一个不可知的框架，它可以作为SSG(静态站点生成器)工作，并提供SSR(服务器端渲染)。</p>
<p>使用Astro插件系统，我们可以按照我们想要的方式构建和增强我们的网站，甚至可以将不同的UI库合并到一个项目中。</p>
<p>在本帖中，我们将了解Astro islands以及它们是如何提供这一功能的。</p>
<p><em>向前跳转:</em></p>

<h2 id="astro-introduction">Astro 101:简介</h2>
<p>当你看他们<a href="https://astro.build/">官网</a>上的定义，你会发现:</p>
<p>Astro是一个一体化的web框架，用于构建快速、以内容为中心的网站。</p>
<p>最近，他们发布了<a href="https://astro.build/blog/astro-1/">第一个稳定版本</a>，标志着该框架已经准备好投入生产，这是新兴框架的一个巨大里程碑。网络社区的反应非常积极，每天我们都看到越来越多的项目使用Astro frontends。</p>
<p>Astro有许多很酷的特性，让开发者和用户体验很棒。我建议查看另一篇LogRocket文章以获得关于Astro的更全面的概述。</p>
<p>在我个人看来，Astro和其他框架的关键区别在于它的架构:孤岛架构。这个概念在2019年由<a href="https://twitter.com/ksylor">凯蒂·塞勒-米勒</a>首次描述，随后由Preact的创作者<a href="https://twitter.com/_developit">杰森·米勒</a>在<a href="https://jasonformat.com/islands-architecture/">本帖</a>中进一步阐述。</p>
<p><img data-attachment-id="145421" data-permalink="https://blog.logrocket.com/understanding-astro-islands-architecture/attachment/astro-islands-architecture/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/12/Astro-islands-architecture.png" data-orig-size="730,637" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Astro-islands-architecture" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/12/Astro-islands-architecture-300x262.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/12/Astro-islands-architecture.png" decoding="async" class="aligncenter wp-image-145421 size-full jetpack-lazy-image" src="../Images/8540359c2ccad739b25e6ad0b3f357b4.png" alt="Astro islands architecture" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2022/12/Astro-islands-architecture.png 730w, https://blog.logrocket.com/wp-content/uploads/2022/12/Astro-islands-architecture-300x262.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2022/12/Astro-islands-architecture.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/12/Astro-islands-architecture.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="145421" data-permalink="https://blog.logrocket.com/understanding-astro-islands-architecture/attachment/astro-islands-architecture/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/12/Astro-islands-architecture.png" data-orig-size="730,637" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Astro-islands-architecture" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/12/Astro-islands-architecture-300x262.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/12/Astro-islands-architecture.png" decoding="async" loading="lazy" class="aligncenter wp-image-145421 size-full" src="../Images/8540359c2ccad739b25e6ad0b3f357b4.png" alt="Astro islands architecture" srcset="https://blog.logrocket.com/wp-content/uploads/2022/12/Astro-islands-architecture.png 730w, https://blog.logrocket.com/wp-content/uploads/2022/12/Astro-islands-architecture-300x262.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/12/Astro-islands-architecture.png"/></noscript>
<h2 id="astro-islands">什么是阿童木岛？</h2>
<p>术语“Astro island”指的是HTML静态页面上的交互式UI组件。一个页面上可以存在多个岛，一个岛总是孤立地呈现，这意味着每个岛可以使用任何UI框架，甚至只是普通的Astro代码，与页面上的其他岛一起使用。</p>
<p>需要强调的是，Astro在默认情况下生成的每个网站都没有客户端JavaScript。每次我们在页面上渲染一个岛，Astro都会提前自动渲染成HTML，然后剥离掉所有的JavaScript。这通过从页面中移除所有未使用的JavaScript来保持每个站点的速度。</p>
<p>我们以React中做的一个<code>Counter</code>组件的实现为例。第一次渲染时会显示一个按钮，文字为“<code>Counter: 0</code>”，用户每点击一次，计数器就会增加<code>1</code>。</p>
<pre class="language-typescript hljs">// src/components/Counter.tsx
import { useState } from 'react';

const Counter = () =&gt; {
  const [count, setCounter] = useState(0);
  return (
    &lt;button onClick={() =&gt; setCounter((number) =&gt; number + 1)}&gt;
      Counter: {count}
    &lt;/button&gt;
  );
};

export default Counter;
</pre>
<p>然后，让我们在Astro中渲染这个组件。</p>
<p>要在Astro项目中使用React组件，必须将<code><a href="https://docs.astro.build/en/guides/integrations-guide/react/">@astrojs/react</a></code>集成添加到项目中。</p>
<pre class="language-javascript hljs">// src/pages/index.astro
---
import Counter from '../components/Counter';
---

&lt;Counter /&gt;
</pre>
<p>这段代码将呈现按钮，但是因为JavaScript在构建时被Astro删除了，所以用户不能增加计数器的值。当我们想让我们的应用程序具有交互性时，我们必须通过使用客户端指令来明确说明(我们将在后面讨论它们)。</p>
<p>这个过程被称为部分或选择性水合。本质上，这意味着发布支持组件的动态运行时需求所需的任何框架代码或运行时。像状态变化和交互性这样的事情就是最好的例子。</p>
<pre class="language-javascript hljs">// src/pages/index.astro
---
import Counter from '../components/Counter.jsx';
--

&lt;Counter client:load /&gt;
</pre>
<p>Astro islands的一个好处是，除了专注于让你的应用程序尽可能轻之外，每个岛都是并行加载的。您甚至可以使用客户机指令为每个岛单独指定装载策略！这意味着我们可以完全控制如何以及何时为客户加载资产，并尽我们所能提供最佳体验。</p>
<h2 id="astro-islands-compare-rest">阿斯特罗岛和其他地方相比怎么样？</h2>
<p>正如我在这篇文章开头提到的，Astro团队并没有创造岛屿建筑。相同的技术在许多框架中实现，并作为单独的库发布。</p>
<p>一个很好的例子是<a href="https://is-land.11ty.dev/"> <code>is-land</code> </a>(来自<a href="https://www.11ty.dev/"> <code>11ty</code> </a>团队)，它在给组件补水时提供了附加条件(也称为客户端指令)，例如:</p>
<ul>
<li><code>on:interaction</code></li>
<li><code>on:save-data</code></li>
</ul>
<p>它还允许您在组件尚未水合时指定一个后备:</p>
<pre class="language-html hljs">&lt;is-land on:interaction&gt;
  &lt;form&gt;
    &lt;button type="button"&gt;Hydrate the island&lt;/button&gt;
  &lt;/form&gt;

  &lt;p&gt;This content is before hydration.&lt;/p&gt;

  &lt;template data-island="replace"&gt;
    &lt;vanilla-web-component&gt;My component content after hydration&lt;/vanilla-web-component&gt;
  &lt;/template&gt;
&lt;/is-land&gt;
</pre>
<p>尽管框架之间在语法上有些差异，但主要思想是每个框架最终都实现了部分水合。Astro编写UI的方式确保了用户需求总是定义水合策略，这在其他孤岛框架中是可选的，比如<code>is-land</code>。</p>
<p>如果你想了解更多关于岛屿建筑的知识，我发现GitHub <code><a href="https://github.com/lxsmnsyc/awesome-islands">awesome-islands</a></code>是一个很好的资源，它组织了很多与岛屿建筑相关的内容。</p>
<h2 id="astro-client-directives">所有Astro客户指令</h2>
<p>指令是一个组件属性，它告诉Astro你的组件应该如何渲染。在撰写本文时，Astro总共支持<a href="https://docs.astro.build/en/reference/directives-reference/#client-directives">五种不同的客户端指令</a>。随着框架增加新的特性，这个数字可能会改变。</p>
<p>假设我们想要呈现名为<code>MyComponent</code>的组件，根据我们使用的客户端指令，我们可以修改用户与之交互的方式:</p>
<ul>
<li><code>&lt;MyComponent client:load/&gt;</code>:在页面加载时立即合并组件JavaScript</li>
<li><code>&lt;MyComponent client:idle/&gt;</code>:当页面完成初始加载并且<code><a href="https://developer.mozilla.org/en-US/docs/Web/API/Window/requestIdleCallback">requestIdleCallback</a></code>事件被触发时，合并组件JavaScript</li>
<li><code>&lt;MyComponent client:visible/&gt;</code>:一旦组件进入用户的视口，就合并组件JavaScript。这在内部使用了一个<code><a href="https://blog.logrocket.com/lazy-loading-using-the-intersection-observer-api/">IntersectionObserver</a></code>来跟踪可见性</li>
<li><code>&lt;MyComponent client:media={string}/&gt;</code>:一旦满足某个<a href="https://blog.logrocket.com/choose-between-media-container-queries/"> CSS媒体查询</a>，就合并组件JavaScript</li>
<li><code>&lt;MyComponent client:only={string}/&gt;</code>:跳过HTML服务器渲染，只在客户端渲染。该组件将在构建时被跳过，这对于完全依赖于客户端API的组件非常有用</li>
</ul>
<h2 id="working-client-directives">使用客户端指令</h2>
<p>为了说明客户端指令的威力，我创建了一个小的Astro项目，在这个项目中，我使用不同的客户端指令来渲染上面显示的相同的<code>Counter</code>组件，以便任何人都可以在一个地方尝试它们。请随意<a href="https://astro-client-directives-test.netlify.app/">在Netlify上看一下现场应用</a>。</p>
<p><img data-attachment-id="145424" data-permalink="https://blog.logrocket.com/understanding-astro-islands-architecture/attachment/client-directives-demo/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/12/Client-directives-demo.png" data-orig-size="730,1242" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Client-directives-demo" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/12/Client-directives-demo-176x300.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/12/Client-directives-demo-602x1024.png" decoding="async" class="aligncenter wp-image-145424 size-full jetpack-lazy-image" src="../Images/744347d76e229a66384a106f66df97da.png" alt="Client directives demo" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2022/12/Client-directives-demo.png 730w, https://blog.logrocket.com/wp-content/uploads/2022/12/Client-directives-demo-176x300.png 176w, https://blog.logrocket.com/wp-content/uploads/2022/12/Client-directives-demo-602x1024.png 602w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2022/12/Client-directives-demo.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/12/Client-directives-demo.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="145424" data-permalink="https://blog.logrocket.com/understanding-astro-islands-architecture/attachment/client-directives-demo/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/12/Client-directives-demo.png" data-orig-size="730,1242" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Client-directives-demo" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/12/Client-directives-demo-176x300.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/12/Client-directives-demo-602x1024.png" decoding="async" loading="lazy" class="aligncenter wp-image-145424 size-full" src="../Images/744347d76e229a66384a106f66df97da.png" alt="Client directives demo" srcset="https://blog.logrocket.com/wp-content/uploads/2022/12/Client-directives-demo.png 730w, https://blog.logrocket.com/wp-content/uploads/2022/12/Client-directives-demo-176x300.png 176w, https://blog.logrocket.com/wp-content/uploads/2022/12/Client-directives-demo-602x1024.png 602w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/12/Client-directives-demo.png"/></noscript>
<p>下面是上面截图中页面的全部代码。页面的内容基本上是相同的<code>Counter </code>组件，总共呈现了六次:第一次没有指定任何客户端指令(该组件根本不是交互式的)，然后其余的部分使用了我们上面提到的所有不同的客户端指令。</p>
<pre class="language-javascript hljs">// src/pages/index.astro
---
import Layout from '../layouts/Layout.astro';
import Counter from '../components/Counter';
---

&lt;Layout title="Welcome to Astro"&gt;
  &lt;main&gt;
    &lt;h1&gt;Welcome to &lt;span class="text-gradient"&gt;Astro&lt;/span&gt;&lt;/h1&gt;

    &lt;h2&gt;&lt;pre&gt;no directive&lt;/pre&gt;&lt;/h2&gt;
    &lt;p class="instructions"&gt;
      &lt;code&gt;No JS, no interactive&lt;/code&gt;
      &lt;Counter /&gt;
    &lt;/p&gt;

    &lt;h2&gt;&lt;pre&gt;client:load&lt;/pre&gt;&lt;/h2&gt;
    &lt;p class="instructions"&gt;
      &lt;code&gt;Loads JS as soon as possible&lt;/code&gt;
      &lt;Counter client:load /&gt;
    &lt;/p&gt;

    &lt;h2&gt;&lt;pre&gt;client:idle&lt;/pre&gt;&lt;/h2&gt;
    &lt;p class="instructions"&gt;
      &lt;code&gt;Loads JS when rendering is over&lt;/code&gt;
      &lt;Counter client:idle /&gt;
    &lt;/p&gt;

    &lt;h2&gt;&lt;pre&gt;client:visible&lt;/pre&gt;&lt;/h2&gt;
    &lt;p class="instructions"&gt;
      &lt;code&gt;Loads JS when the button is visible to the user&lt;/code&gt;
      &lt;Counter client:visible /&gt;
    &lt;/p&gt;

    &lt;h2&gt;&lt;pre&gt;client:media&lt;/pre&gt;&lt;/h2&gt;
    &lt;p class="instructions"&gt;
      &lt;code&gt;Loads JS when the media query (min-width: 680px) is valid&lt;/code&gt;
      &lt;Counter client:media="(min-width: 680px)" /&gt;
    &lt;/p&gt;

    &lt;h2&gt;&lt;pre&gt;client:only&lt;/pre&gt;&lt;/h2&gt;
    &lt;p class="instructions"&gt;
      &lt;code&gt;Loads JS only in client (No SSR)&lt;/code&gt;
      &lt;Counter client:only="react" /&gt;
    &lt;/p&gt;
  &lt;/main&gt;
&lt;/Layout&gt;
</pre>
<p>完整的源代码可以在<a href="https://github.com/EmaSuriano/astro-client-directives-test">这个GitHub库</a>里找到。我强烈建议分叉项目并在本地运行项目，以充分理解客户端指令如何修改您的应用程序的行为。</p>
<h2>临终遗言</h2>
<p>我认为Astro是一个全新的框架，能够使用零JavaScript代码构建超轻网站。它让我们更加意识到，在这个庞大的生态系统中，什么时候我们确实需要JavaScript，什么时候我们可以向客户交付更少的KB。</p>
<p>Astro的另一大优势是它是UI不可知的，这意味着你可以自带UI框架(BYOF)！React、Preact、Solid、Svelte、Vue和Lit都是Astro 官方支持的<a href="https://docs.astro.build/en/guides/integrations-guide/#official-integrations">。您甚至可以在同一个页面上混合搭配不同的框架，使未来的迁移更加容易，并防止项目局限于单一框架。</a></p>
<p>感谢您的阅读，让我们继续一起努力吧！👷‍♂️</p><div class="code-block code-block-28">
<div class="blog-plug inline-plug js-libraries-plug"><h2>您是否添加了新的JS库来提高性能或构建新特性？如果他们反其道而行之呢？</h2><p>毫无疑问，前端变得越来越复杂。当您向应用程序添加新的JavaScript库和其他依赖项时，您将需要更多的可见性，以确保您的用户不会遇到未知的问题。</p>
<p>LogRocket 是一个前端应用程序监控解决方案，可以让您回放JavaScript错误，就像它们发生在您自己的浏览器中一样，这样您就可以更有效地对错误做出反应。</p><a class="signup" href="https://lp.logrocket.com/blg/javascript-signup" target="_blank" rel="noopener noreferrer"><img class="alignnone size-full wp-image-46 jetpack-lazy-image" src="../Images/e8a0ab42befa3b3b1ae08c1439527dc6.png" alt="LogRocket Dashboard Free Trial Banner" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2019/10/errors-screenshot.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/10/errors-screenshot.png"/><noscript><img data-lazy-fallback="1" class="alignnone size-full wp-image-46" src="../Images/e8a0ab42befa3b3b1ae08c1439527dc6.png" alt="LogRocket Dashboard Free Trial Banner" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/10/errors-screenshot.png"/></noscript></a>
<a href="https://lp.logrocket.com/blg/javascript-signup" target="_blank" rel="noopener noreferrer">https://logrocket.com/signup/</a><p><a href="https://lp.logrocket.com/blg/javascript-signup" target="_blank" rel="noopener noreferrer"> LogRocket </a>可以与任何应用程序完美配合，不管是什么框架，并且有插件可以记录来自Redux、Vuex和@ngrx/store的额外上下文。您可以汇总并报告问题发生时应用程序的状态，而不是猜测问题发生的原因。LogRocket还可以监控应用的性能，报告客户端CPU负载、客户端内存使用等指标。</p><p>自信地构建— <a class="signup" href="https://lp.logrocket.com/blg/javascript-signup" target="_blank" rel="noopener noreferrer">开始免费监控</a>。</p></div>


</div>
<h3>参考</h3>


<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
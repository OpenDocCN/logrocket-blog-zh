<html>
<head>
<title>SvelteKit Auth with AWS Cognito </title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>带有AWS Cognito的SvelteKit Auth</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/sveltekit-auth-aws-cognito/#0001-01-01">https://blog.logrocket.com/sveltekit-auth-aws-cognito/#0001-01-01</a></blockquote><div><article class="article-post">
<p>2022年最后一个季度，前端世界发布了一些非常酷的公告。其中之一是<a href="https://vercel.com/blog/announcing-sveltekit-auth"> NextAuth.js成为Auth.js </a>，并将NextAuth.js的出色开发人员体验带到了其他流行的web框架中。有了Vercel和一个了不起的社区的支持，Auth.js很快将成为所有流行的web框架中的身份验证的首选解决方案。</p>
<p>但是如果不使用Next.js或者React呢？如果用SvelteKit呢？好吧，你很幸运，因为斯维尔基特认证是在这里拯救一天。SvelteKit Auth是一个为SvelteKit应用程序提供认证的SvelteKit模块。</p>
<p>在本文中，我们将讨论:</p>

<h2 id="what-sveltekit-auth">什么是SvelteKit Auth？</h2>
<p>SvelteKit Auth是一个为SvelteKit应用程序提供认证的SvelteKit模块。SvelteKit Auth建立在<a href="https://authjs.dev/"> Auth.js </a>之上，允许你添加认证提供者和定制你的应用的认证流程。</p>
<h2 id="building-sveltekit-app">构建我们的SvelteKit应用程序</h2>
<p>让我们创建一个新的SvelteKit项目，并向其中添加AWS Cognito身份验证。我们将使用自定义凭证添加AWS Cognito身份验证，然后在服务器端和客户端获取身份验证令牌和会话数据，直到内部布局。</p>
<p>首先，让我们使用带有打字稿的<a href="https://kit.svelte.dev/docs/creating-a-project">官方指南</a>来搭建一个新的SvelteKit项目:</p>
<pre class="language-typescript hljs">npm create <a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="453633202931200529243120">[email protected]</a>st skauth-congito-demo
</pre>
<p>这将为我们提供裸机。</p>
<p>接下来，我们将把最新版本的SvelteKit Auth添加到我们的项目中:</p>
<pre class="language-bash hljs">pnpm install @auth/<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="a5d6d3c0c9d1c0ceccd1e5cbc0ddd1">[email protected]</a> @auth/<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="98fbf7eafdd8f6fde0ec">[email protected]</a>
</pre>
<h2 id="aws-cognito-setup">AWS认知设置</h2>
<p>我们将使用AWS Cognito进行身份验证。我们需要建立一个新的AWS Cognito用户池和一个应用程序客户端。您可以使用<a href="https://docs.aws.amazon.com/cognito/latest/developerguide/cognito-user-pool-as-user-directory.html">官方指南</a>设置AWS Cognito用户池。一旦你有了<code>COGNITO_USER_POOL_ID</code>和<code>COGNITO_CLIENT_ID</code>，你就可以继续执行了。</p>
<p>现在我们已经准备好了AWS Cognito用户池和应用程序客户端，我们将把自定义凭证auth添加到我们的SvelteKit项目中。首先，让我们将AWS Cognito SDK添加到我们的项目中:</p>
<pre class="language-javascript hljs">pnpm install amazon-cognito-identity-js
</pre>
<p>我们将在项目中添加以下环境变量。我们将使用这些环境变量来获取用户池ID和应用程序客户端ID:</p>
<pre class="language-javascript hljs"># .env
COGNITO_USER_POOL_ID=us-east-1_XXXXXXXXX
COGNITO_CLIENT_ID=XXXXXXXXXXXXXXXXXXXXXXXXXX
</pre>
<h2 id="aws-cognito-implementation">AWS认知实施</h2>
<p>使用域驱动架构，我们将把所有与auth相关的模块保存在<code>src/lib/domain/auth</code>目录中。</p>
<p>创建一个新文件<code>src/lib/domain/auth/services/Cognito.ts</code>，并向其中添加以下代码:</p>
<pre class="language-typescript hljs">/**
 * @file Cognito.ts
 * File containing the Cognito service
 */
import { COGNITO_USER_POOL_ID, COGNITO_CLIENT_ID } from '$env/static/private';
import { AuthenticationDetails, CognitoRefreshToken, CognitoUser, CognitoUserPool, CognitoUserSession } from 'amazon-cognito-identity-js';
export type CognitoUserSessionType = CognitoUserSession;
const CONFIGS = {
  UserPoolId: COGNITO_USER_POOL_ID,
  ClientId: COGNITO_CLIENT_ID
};
// Create a new Cognito User Pool
const Pool = new CognitoUserPool(CONFIGS);
// Wrapper function to create a new Cognito User from the User Pool
const User = (Username: string): CognitoUser =&gt; new CognitoUser({ Username, Pool });
/**
 * Login to Cognito User Pool using the provided credentials.
 * This will return the session data at the time of login.
 *
 * @param Username - Email address of the user to login
 * @param Password - Password of the user to login
 * @returns - Promise with the result of the login
 */
export const getSession = (Username: string, Password: string): Promise&lt;CognitoUserSession&gt; =&gt; {
  return new Promise((resolve, reject) =&gt;
    User(Username).authenticateUser(new AuthenticationDetails({ Username, Password }), {
      onSuccess: resolve,
      onFailure: reject,
    })
  );
};
/**
 * Refresh the access token of the provided user.
 * We will use this method to refresh the access token from our axios interceptor
 * 
 * @param sessionData - Session data of the user with the refresh token
 * @returns - Promise with the new user object with tokens and expiration date
 */
export const refreshAccessToken = async (sessionData: {
  refreshToken: string;
}): Promise&lt;CognitoUserSession&gt; =&gt; {
  const cognitoUser = Pool.getCurrentUser();
  // Check if the user is logged in
  if (!cognitoUser) {
    throw new Error('No user found');
  }
  // Refresh the session
  const RefreshToken = new CognitoRefreshToken({
    RefreshToken: sessionData.refreshToken,
  });
  return new Promise&lt;CognitoUserSession&gt;((resolve) =&gt; {
    cognitoUser.refreshSession(RefreshToken, (_resp, session: CognitoUserSession) =&gt; {
      resolve(session);
    });
  });
}
</pre>
<p>该文件实现了登录AWS Cognito用户池和刷新访问令牌所需的所有方法。我们将在我们的SvelteKit认证模块中使用这个文件。</p>
<h2 id="adding-custom-credentials-auth">添加自定义凭据身份验证</h2>
<p>SvelteKit Auth利用SvelteKit提供的服务器端<code>hooks</code>来实现认证特性。在我们的应用程序中，我们将自定义和创建<code>src/hooks.server.ts</code>。</p>
<p>这是它看起来的样子。这看起来可能有点复杂，但我们将详细介绍每个步骤:</p>
<pre class="language-typescript hljs">/**
 * @file src/hooks.service.ts
 * File containing the hooks service
 */
// Import the SvelteKit Auth module
import { SvelteKitAuth } from "@auth/sveltekit"
import Credentials from "@auth/core/providers/credentials"
// Import the Cognito service that we created earlier
import { getSession, refreshAccessToken, type CognitoUserSessionType } from "$lib/domains/auth/services/Cognito"
// Type of the user object returned from the Cognito service
import type AuthUser from "$lib/domains/auth/types/AuthUser";
// Import the secret key from the environment variables
import { AUTH_SECRET } from "$env/static/private";
interface AuthToken {
  accessToken: string;
  accessTokenExpires: number;
  refreshToken: string;
  user: {
    id: string;
    name: string;
    email: string;
  };
}
/**
 * Extract the user object from the session data. This is a helper function that we will use to extract the user object from the session data returned from the Cognito service.
 */
const extractUserFromSession = (session: CognitoUserSessionType): AuthUser =&gt; {
  if (!session?.isValid?.()) throw new Error('Invalid session');
  const user = session.getIdToken().payload;
  return {
    id: user.sub,
    name: `${user.name} ${user.family_name}`,
    email: user.email,
    image: user.picture,
    accessToken: session.getAccessToken().getJwtToken(),
    accessTokenExpires: session.getAccessToken().getExpiration(),
    refreshToken: session.getRefreshToken().getToken(),
  }
}
/**
 * Create the token object from the user object. This is a helper function that we will use to create the token object from the user object returned from the Cognito service.
 */
const createTokenFromUser = (user: AuthUser): AuthToken =&gt; {
  return {
    accessToken: user.accessToken,
    accessTokenExpires: user.accessTokenExpires,
    refreshToken: user.refreshToken,
    user: {
      id: user.id,
      name: user.name,
      email: user.email,
      image: user.image,
    },
  }
}
export const handle = SvelteKitAuth({
  secret: AUTH_SECRET,
  providers: [
    Credentials({
      type: 'credentials',
      id: 'credentials',
      name: 'Cognito',
      credentials: {
        email: { label: "Email", type: "email", placeholder: "<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="99edfceaedd9edfceaedb7faf6f4">[email protected]</a>" },
        password: { label: "Password", type: "password" },
      },
      async authorize(credentials) {
        if (!credentials) return null
        try {
          const response = await getSession(credentials?.email, credentials?.password)
          return extractUserFromSession(response)
        } catch (error) {
          console.error(error);
          return null
        }
      }
    }) as any,
  ],
  /**
   * Since we are using custom implementation; we have defined URLs for the login and error pages
   */
  pages: {
    signIn: "/auth/login",
    error: "/auth/login",
  },
  callbacks: {
    /**
     * This callback is called whenever a JWT is created or updated. 
     * For the first time login we are creating a token from the user object returned by the authorize callback.
     * For subsequent requests we are refreshing the access token and creating a new token from the user object. If the refresh token has expired
     *
     */
    async jwt({ token, user, account }: any) {
      // Initial sign in; we have plugged tokens and expiry date into the user object in the authorize callback; object
      // returned here will be saved in the JWT and will be available in the session callback as well as this callback
      // on next requests
      if (account &amp;&amp; user) {
        return createTokenFromUser(user);
      }
      // Return previous token if the access token has not expired yet
      if (Date.now() &lt; token?.accessTokenExpires) {
        return token;
      }
      try {
        const newUserSession = await refreshAccessToken({
          refreshToken: token?.refreshToken,
        })
        const user = extractUserFromSession(newUserSession);
        return createTokenFromUser(user);
      } catch(error) {
        console.error(error);
        throw new Error('Invalid session');
      }
    },
    /**
     * The session callback is called whenever a session is checked. By default, only a subset of the token is
     * returned for increased security. We are sending properties required for the client side to work.
     * 
     * @param session - Session object
     * @param token - Decrypted JWT that we returned in the jwt callback
     * @returns - Promise with the result of the session
     */
    async session({ session, token }: any) {
      session.user = token.user
      session.accessToken = token.accessToken
      session.error = token.error
      return session;
    },
  },
});
</pre>
<p>在上面的代码中，我们定义了SvelteKit将用来处理认证的<code>handle</code>函数。我们使用来自SvelteKit Auth模块的SvelteKitAuth函数来创建<code>handle</code>函数。我们还使用来自SvelteKit Auth模块的<code>Credentials</code>来创建凭证提供者。</p>
<p><code>Credentials</code>函数接受一个对象作为参数。该对象具有以下属性:</p>
<ul>
<li><code>type</code>:提供商类型。在我们的例子中，它是<code>credentials</code></li>
<li><code>id</code>:提供者的ID。在我们的例子中，它是<code>credentials</code></li>
<li><code>name</code>:提供者名称。在我们的例子中，它是<code>Cognito</code></li>
<li><code>credentials</code>:包含凭证的对象。在我们的例子中，它是<code>email</code>和<code>password</code></li>
<li><code>authorize</code>:当用户尝试登录时，该函数将被调用。在我们的例子中，我们调用前面创建的<code>getSession</code>函数，并从会话数据中返回用户对象</li>
</ul>
<p>在<code>pages</code>属性中，我们定义了登录和错误页面的URL。如果没有通过认证，SvelteKit Auth会将用户重定向到登录页面。因为我们为错误和登录保留了相同的URL，所以我们将在登录页面的查询参数中收到错误消息。</p>
<p>在<code>callbacks</code>中，我们已经实现了<code>jwt</code>和<code>session</code>方法。每当从我们定义的<code>authorize</code>方法中创建一个JWT时，就会调用<code>jwt</code>方法。每当检查一个会话时，就会调用<code>session</code>方法。</p>
<h2 id="creating-root-layout">创建根布局</h2>
<p>现在我们已经配置了SevelteKit Auth，我们需要创建一个将被所有页面使用的根布局。</p>
<p>创建一个<code>src/routes/+layout.svelte</code>文件并添加以下代码:</p>
<pre class="language-javascript hljs">&lt;script lang="ts"&gt;
  import { signOut } from "@auth/sveltekit/client"
  import { page } from "$app/stores"
&lt;/script&gt;
&lt;div&gt;
  &lt;header&gt;
    {#if $page.data.session}
      &lt;div&gt;
        &lt;strong&gt;Hello {$page.data.session.user?.name}&lt;/strong&gt;
        &lt;button on:click|preventDefault={signOut} class="button"&gt;Sign out&lt;/button&gt;
      &lt;/div&gt;
    {:else}
      &lt;a href="/auth/login" class="buttonPrimary"&gt;Sign in&lt;/a&gt;
    {/if}
  &lt;/header&gt;
  &lt;slot /&gt;
&lt;/div&gt;
</pre>
<p>一旦用户通过身份验证，SvelteKit Auth将使用会话对象设置页面数据。我们可以使用<code>session</code>数据来检查用户是否被授权。</p>
<p>在我们的示例中，如果用户通过了身份验证，我们将显示用户名和退出按钮。如果用户未经验证，我们将显示一个登录按钮。这里，直接从SvelteKit Auth模块使用<code>signOut</code>函数。该功能将注销用户，并将用户重定向到登录页面。</p>
<h2 id="redirecting-user-login-page">将用户重定向到登录页面</h2>
<p>现在我们有了根布局，我们可以创建登录页面了。我们将创建一个<code>src/routes/auth/login/+page.svelte</code>文件，并添加以下代码:</p>
<pre class="language-javascript hljs">&lt;script lang="ts"&gt;
  import { signIn } from "@auth/sveltekit/client"
  import { invalidateAll } from '$app/navigation';
  const handleSubmit = async (event: any) =&gt; {
    const data = new FormData(event.target);
    try {
      await signIn('credentials', {
        email: data.get('email'),
        password: data.get('password')
      });
    } catch (error) {
      await invalidateAll();
    }
  }
&lt;/script&gt;
&lt;h1&gt;Login&lt;/h1&gt;
&lt;div&gt;
  &lt;form name="login" method="POST" on:submit|preventDefault={handleSubmit}&gt;
    &lt;input name="email" type="email" placeholder="Email Address" /&gt;
    &lt;input name="password" placeholder="Password" type="password" /&gt;
    &lt;button&gt;Sign In&lt;/button&gt;
  &lt;/form&gt;
&lt;/div&gt;
</pre>
<p>在上面的代码中，我们使用了来自SvelteKit Auth模块的<code>signIn</code>函数来登录用户。这将调用我们在<code>Credentials</code>中定义的<code>authorize</code>。如果用户认证成功，将调用<code>jwt</code>回调，用户将被重定向到主页，并带有我们在<code>hooks.server.ts</code>从<code>session</code>回调返回的会话数据。</p>
<h2 id="session-redirection">会话和重定向</h2>
<p>正如在根布局中所讨论的，SvelteKit Auth将在页面存储中设置会话数据。我们可以在子布局中访问这些数据。为了确保我们已认证的路由不被未认证的用户访问，我们将把所有已认证的路由放在<code>src/lib/routes/(auth)</code>目录下。在这里，我们利用了SvelteKit 惊人的<a href="https://kit.svelte.dev/docs/advanced-routing#advanced-layouts">高级布局技术。</a></p>
<p>现在让我们在该目录中创建一个<code>+layout.server.ts</code>文件:</p>
<pre class="language-typescript hljs">import { redirect } from '@sveltejs/kit';
import type { LayoutServerLoad } from './$types';
import { getAccount } from '$lib/domains/auth/api/getAccount';
export const load: LayoutServerLoad = async ({ locals }) =&gt; {
  // Get the session from the locals
  const session = (await locals.getSession()) as any;
  // If the user is not authenticated, redirect to the login page 
  if (!session?.user?.id || !session?.accessToken) {
    throw redirect(307, '/auth/login');
  }
  // Get the account details at the root layout level so that we can use it in the sub layouts
  const account = await getAccount(session?.user?.id, session?.accessToken);
  // If the account is not found, redirect to the login page
  if (!account) {
    throw redirect(307, '/auth/login');
  }
  // On success, we can send the session and account data to the sub layouts
  return {
    session,
    account,
  };
};
</pre>
<p>现在，会话中的所有数据，即所需的令牌和用户帐户详细信息，在服务器端和客户端都可用，我们可以使用它们向后端和/或出于任何其他目的发出经过身份验证的请求。</p>
<h2 id="conclusion">结论</h2>
<p>Auth.js是一个有用的库，用于实现当今最流行的web框架的身份验证。它使得实现基于重定向的登录变得非常容易，最重要的是，它提供了很大的灵活性，允许我们根据需要实现自己的身份验证逻辑。</p>
<p>本文我们看到的只是<a href="https://authjs.dev/"> Auth.js </a>能做的一小部分。我强烈推荐你查看一下<a href="https://authjs.dev/getting-started/introduction">auth . js</a>入门指南来了解更多。</p>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
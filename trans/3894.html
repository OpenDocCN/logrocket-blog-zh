<html>
<head>
<title>Pinning Rust async data types for memory safety </title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>固定Rust异步数据类型以实现内存安全</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/pinning-rust-async-data-types-memory-safety/#0001-01-01">https://blog.logrocket.com/pinning-rust-async-data-types-memory-safety/#0001-01-01</a></blockquote><div><article class="article-post">
<p>实现异步编程可以帮助您的应用程序运行得更快，并处理高流量。但是，Rust中异步编程的挑战是确保多个任务访问的数据是一致和安全的。</p>
<p><a href="https://blog.logrocket.com/deep-dive-concurrency-rust-programming-language/">并发是防止这个问题</a>的一种策略，因为它在内存使用方面提供了好处。然而，对于Rust中异步数据类型的内存安全，钉住是最好的解决方案。</p>
<p>Pinning是Rust中的一个特性，它允许将一个异步数据类型固定或“固定”到内存中的一个特定位置，这样当它被多个任务使用时就不能被移动。</p>
<p>在本文中，我们将研究在Rust中实现锁定的不同方法。我们还将了解如何安全地访问固定数据。</p>
<p><em>向前跳转:</em></p>

<h2 id="using-future-trait-async-data-types-rust">在Rust中为异步数据类型使用<code>Future</code>特征</h2>
<p>当在Rust中处理异步数据时，我们有一个叫做<code>Future</code>的特性来帮助我们。任何使用这个特征的函数或结构都将处于两种状态之一:<code>Pending</code>或<code>Ready</code>。</p>
<p>我们使用<code>await</code>关键字来等待<code>Future</code>特征完成并给我们一个值。挺顺手的！</p>
<p>下面是如何将<code>Future</code>特征实现到一个结构中:</p>
<pre class="language-rust hljs">impl Future for MyFutureStruct {
    type Output = ();
    fn poll(self: Pin&lt;&amp;mut Self&gt;, _cx: &amp;mut Context&lt;'_&gt;) -&gt; Poll&lt;()&gt; {
        Poll::Ready(())
    }
}
</pre>
<p>下面是如何将<code>Future</code>特征实现到一个函数中:</p>
<pre class="language-rust hljs">impl MyFutureStruct {
    fn get_something_async(&amp;self) -&gt; impl Future&lt;Output = String&gt; + '_ {
        async {
            "Something".to_string()
        }
    }
}
</pre>
<p>任何Rust数据类型都可以在async中使用，只要它实现了<code>Future</code>特征。</p>
<h2 id="understanding-problems-async-data-types-memory-safety">理解异步数据类型和内存安全的问题</h2>
<p>让我们来看看我们是如何在Rust中实现异步的。语言本身并没有为我们提供一个运行器来进行异步编程，但是幸运的是，有一个社区包<code>tokio</code>，可以帮助我们处理异步运行器。让我们将它安装在我们的Rust项目中:</p>
<pre class="language-rust hljs">cargo add tokio --features full
</pre>
<p>用<code>tokio</code>创建异步运行器有两种方法，一种是用宏，另一种是用<code>tokio</code>运行时构建器。</p>
<p>下面是如何用宏创建异步运行时:</p>
<pre class="language-rust hljs">#[tokio::main(flavor = "current_thread")]
async fn main() {
   // your code here
}
</pre>
<p>下面是如何使用<code>tokio</code>运行时构建器创建异步运行时:</p>
<pre class="language-rust hljs">fn main() {
    let rt = tokio::runtime::Builder::new_current_thread()
        .build()
        .unwrap();
    rt.block_on(/* your async code or function here */);
}
</pre>
<p>对于本教程，我们将使用宏版本，因为它更简单。</p>
<p>在Rust中，我们有可以用来存储自定义值的<code>struct</code>数据类型——就像Java中的类一样。</p>
<p>我们可以像这样创建一个<code>struct</code>:</p>
<pre class="language-rust hljs">#[derive(Debug)]
struct Post {
    name: String,
    slug: *const String
}
</pre>
<p>但是，我们不能直接使用这个结构来执行异步过程。首先，我们需要为这个结构实现一个<code>Future</code>特征。这将告诉我们的异步运行时，来自该结构的值<code>slug</code>将在以后被填充，使我们能够运行异步进程来获取该结构的值。</p>
<p>让我们给我们的结构添加一个方法，这样我们就可以填充<code>name</code>和<code>slug</code>属性的值:</p>
<pre class="language-rust hljs">impl Post {
    pub fn new(name: String) -&gt; Self {
        Self { 
            name,
            slug: std::ptr::null()
        }
    }
    fn collect_slug(&amp;mut self) {
        let ref_slug = &amp;self.name as *const _;
        self.slug = ref_slug;
    }
    fn get_slug(&amp;self) -&gt; String {
        unsafe { &amp;*(self.slug) }.replace(" ", "-").to_lowercase()
    }
}
</pre>
<p>现在，让我们为我们的结构实现一个<code>Future</code>特征:</p>
<pre class="language-rust hljs">use std::future::Future;
use std::pin::Pin;
use std::task::Context;
use std::task::Poll;

impl Future for Post {
    type Output = ();
    fn poll(self: Pin&lt;&amp;mut Self&gt;, _cx: &amp;mut Context&lt;'_&gt;) -&gt; Poll&lt;()&gt; {
        println!("Post:::poll {}", self);
        Poll::Ready(())
    }
}
</pre>
<p>让我们也实现一个<code>Display</code>来使我们更容易读取我们的结构中的值:</p>
<pre class="language-rust hljs">impl Display for Post {
    fn fmt(&amp;self, f: &amp;mut std::fmt::Formatter&lt;'_&gt;) -&gt; std::fmt::Result {
        write!(f, "name:`{}` slug:`{}`",self.name self.get_slug()).unwrap();
        Ok(())
    }
}
</pre>
<p>现在让我们尝试使用这个结构:</p>
<pre class="language-rust hljs">#[tokio::main(flavor = "current_thread")]
async fn main() {
    let mut post1 = Post::new("Article First".to_string());
    let mut post2 = Post::new("Article Second".to_string());
    post1.collect_slug();
    post2.collect_slug();
    post1.await;
    post2.await;
}
</pre>
<p>我们得到了我们想要的一切！以下是输出结果:</p>
<pre class="language-rust hljs">Post:::poll name:`Article First` slug:`article-first`
Post:::poll name:`Article Second` slug:`article-second`
</pre>
<p>但是，在移动<code>Post</code>结构的值时，我们会遇到一个问题。看看下面的代码:</p>
<pre class="language-rust hljs">#[tokio::main(flavor = "current_thread")]
async fn main() {
    let mut post1 = Post::new("Article First".to_string());
    let mut post2 = Post::new("Article Second".to_string());
    post1.collect_slug();
    post2.collect_slug();
    std::mem::swap(&amp;mut post1, &amp;mut post2);
    post1.await;
    post2.await;
}
</pre>
<p>通过这种内存交换，我们期望得到如下值:</p>
<pre class="language-rust hljs">Post:::poll name:`Article Second` slug:`article-second`
Post:::poll name:`Article First` slug:`article-first`
</pre>
<p>相反，这是我们的结果:</p>
<pre class="language-rust hljs">Post:::poll name:`Article Second` slug:`article-first`
Post:::poll name:`Article First` slug:``
</pre>
<p>为什么会这样？为了进一步研究，让我们使用<code>println</code>添加一些简单的跟踪:</p>
<pre class="language-rust hljs">println!("Before swap");
println!("post1: {:?} =&gt; {:p}, {:?}", post1.name, &amp;post1.name, post1.get_slug());
println!("post2: {:?} =&gt; {:p}, {:?}\n", post2.name, &amp;post2.name, post2.get_slug());
std::mem::swap(&amp;mut post1, &amp;mut post2);
println!("After swap");
println!("post1: {:?} =&gt; {:p}, {:?}", post1.name, &amp;post1.name, post1.get_slug());
println!("post2: {:?} =&gt; {:p}, {:?}\n", post2.name, &amp;post2.name, post2.get_slug());
</pre>
<p>如果我们打印内存中的值，我们会得到下面的输出。奇怪的是，即使我们使用了一个<code>Future</code>特征，我们也没有为<code>post2</code>得到一个交换的<code>slug</code>值:</p>
<pre class="language-rust hljs">Before swap
post1: "Article Firstd" =&gt; 0x16af320b0, "article-firstd"
post2: "Article Second" =&gt; 0x16af320d0, "article-second"

After swap
post1: "Article Second" =&gt; 0x16af320b0, "article-firstd"
post2: "Article Firstd" =&gt; 0x16af320d0, "article-second"
</pre>
<p>我们成功地为<code>name</code>变量交换了内存，但是原始的<code>slug</code>地址仍然是相同的——没有任何改变。</p>
<p>下图可能有助于理解交换的工作原理:</p>
<p><img data-attachment-id="158032" data-permalink="https://blog.logrocket.com/pinning-rust-async-data-types-memory-safety/attachment/understanding-how-swaps-work-rust/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2023/02/understanding-how-swaps-work-rust.png" data-orig-size="720,427" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Understanding how swaps work Rust" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2023/02/understanding-how-swaps-work-rust-300x178.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2023/02/understanding-how-swaps-work-rust.png" decoding="async" class="aligncenter wp-image-158032 size-full jetpack-lazy-image" src="../Images/b8cc329962c58910e753873ebb28b717.png" alt="Understanding How Swaps Work Rust" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2023/02/understanding-how-swaps-work-rust.png 720w, https://blog.logrocket.com/wp-content/uploads/2023/02/understanding-how-swaps-work-rust-300x178.png 300w" data-lazy-sizes="(max-width: 720px) 100vw, 720px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2023/02/understanding-how-swaps-work-rust.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2023/02/understanding-how-swaps-work-rust.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="158032" data-permalink="https://blog.logrocket.com/pinning-rust-async-data-types-memory-safety/attachment/understanding-how-swaps-work-rust/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2023/02/understanding-how-swaps-work-rust.png" data-orig-size="720,427" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Understanding how swaps work Rust" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2023/02/understanding-how-swaps-work-rust-300x178.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2023/02/understanding-how-swaps-work-rust.png" decoding="async" loading="lazy" class="aligncenter wp-image-158032 size-full" src="../Images/b8cc329962c58910e753873ebb28b717.png" alt="Understanding How Swaps Work Rust" srcset="https://blog.logrocket.com/wp-content/uploads/2023/02/understanding-how-swaps-work-rust.png 720w, https://blog.logrocket.com/wp-content/uploads/2023/02/understanding-how-swaps-work-rust-300x178.png 300w" sizes="(max-width: 720px) 100vw, 720px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2023/02/understanding-how-swaps-work-rust.png"/></noscript>
<p>在Rust中，如果一个类型包含指向自身的指针，移动该类型的值是不安全的，因为指针不会被更新，仍然指向旧的内存位置。</p>
<p>例如，如果我们试图将<code>post1</code>的值移动到<code>post2</code>，那么<code>post1</code>中的slug指针仍然会指向内存中的旧位置，而<code>post2</code>中的slug指针不会被更新。</p>
<p>这将导致<code>post1</code>和<code>post2</code>都有无效指针，这是不安全的。交换<code>post1</code>和<code>post2</code>的值需要改变slug字段，这是不可能的，因为它是自引用的。</p>
<p>让我们看看锁定如何帮助我们解决这个问题。</p>
<h2 id="implementing-pinning-rust">理解和实现Rust中的锁定</h2>
<p><code>[Pin](<a href="https://github.com/rust-lang/rfcs/blob/master/text/2349-pin.md" rel="nofollow">https://github.com/rust-lang/rfcs/blob/master/text/2349-pin.md</a>)</code> <a href="https://github.com/rust-lang/rfcs/blob/master/text/2349-pin.md">是Rust </a>中的引用类型；引入它是为了处理不应该移动或不能安全移动的数据。例如，异步访问的数据可以固定在内存中，以防止它被Rust运行时移动或修改。</p>
<p>通过钉住，我们可以确保异步数据被可预测地、一致地访问，避免数据竞争等并发问题。在Rust中实现pinning有两种方法；我们可以固定在堆栈上，也可以固定在堆上。</p>
<p>让我们仔细看看！</p>
<h3 id="pinning-stack">固定到堆栈</h3>
<p>将<code>PhantomPinned</code>特征添加到<code>Post</code>结构允许它被固定在内存中，这意味着它在内存中的位置是固定的，不会被程序移动。</p><div class="code-block code-block-54">
<hr/>
<h3>更多来自LogRocket的精彩文章:</h3>

<hr/></div>
<p>为了实现这一点，我们首先需要将<code>PhantomPinned</code>导入到我们的项目中，然后将它添加到<code>Post</code> struct！取消固定:</p>
<pre class="language-rust hljs">use std::marker::PhantomPinned;
#[derive(Debug)]
struct Post {
    name: String,
    slug: *const String,
    _marker: PhantomPinned,
}
</pre>
<p>现在，我们可以创建一个<code>Post</code>结构的新实例，如下所示:</p>
<pre class="language-rust hljs">impl Post {
    pub fn new(name: String) -&gt; Self {
        Self {
            name,
            slug: std::ptr::null(),
            _marker: PhantomPinned,
        }
    }
}
</pre>
<p>接下来，我们需要改变我们改变结构值的方式:</p>
<pre class="language-rust hljs">impl Post {
    pub fn collect_slug(self: Pin&lt;&amp;mut Self&gt;) {
        let ref_slug = &amp;self.name as *const String;
        let this = unsafe {
            self.get_unchecked_mut()
        };
        this.slug = ref_slug;
    }
    pub fn get_slug(self: Pin&lt;&amp;Self&gt;) -&gt; String {
        unsafe { &amp;*(self.slug) }.replace(" ", "-").to_lowercase()
    }
    fn get_name(&amp;self) -&gt; &amp;str {
        &amp;self.name
    }
}
</pre>
<p>我们还需要更改到<code>Display</code> trait实现:</p>
<pre class="language-rust hljs">impl Display for Post {
    fn fmt(&amp;self, f: &amp;mut std::fmt::Formatter&lt;'_&gt;) -&gt; std::fmt::Result {
        let this = unsafe { Pin::new_unchecked(self) };
        write!(f, "name:`{}` slug:`{}`", this.as_ref().get_name(), Post::get_slug(this)).unwrap();
        Ok(())
    }
}
</pre>
<p>最后，我们可以使用结构的固定值:</p>
<pre class="language-rust hljs">#[tokio::main(flavor = "current_thread")]
async fn main() {
    let mut post1 = Post::new("Article Firstd".into());
    let mut post2 = Post::new("Article Second".into());
    let mut post1 = unsafe { Pin::new_unchecked(&amp;mut post1) };
    let mut post2= unsafe { Pin::new_unchecked(&amp;mut post2) };
    Post::collect_slug(post1.as_mut());
    Post::collect_slug(post2.as_mut());
    post1.await;
    post2.await;
}
</pre>
<p>这是运算的结果。它很有效，给了我们预期的价值:</p>
<pre class="language-rust hljs">Post:::poll name:`Article Second` slug:`article-second`
Post:::poll name:`Article Firstd` slug:`article-firstd`
</pre>
<p>但是，当我们以这种方式使用交换时，Rust编译器会“抱怨”,因为这不是内存安全的:</p>
<pre class="language-rust hljs">std::mem::swap(post1.get_mut(), post2.get_mut());
</pre>
<p><em> <strong>注意，<strong>如果要对数据进行变异，当你的数据实现<code>PhantomPinned</code>时一定要使用<code>.get_mut()</code>。这一特性保证了该结构在可变引用的生存期内不会在内存中移动，并且可以防止在使用固定数据</strong> </strong> </em>时可能出现的某些类型的错误</p>
<h3 id="pinning-heap">固定到堆</h3>
<p>存储在堆栈上的数据可以在内存中移动。但是当数据被“钉”在堆上时，意味着它在内存中的位置是固定的，不会被程序移动。只要程序在运行，固定在堆上的数据就在一个位置，并且易于访问和使用。</p>
<p>为了在堆中存储数据，我们将使用<code>Box</code>数据类型:</p>
<pre class="language-rust hljs">impl Post {
    pub fn new(name: String) -&gt; Pin&lt;Box&lt;Self&gt;&gt; {
        let post = Self {
            name,
            slug: std::ptr::null(),
            _marker: PhantomPinned,
        };
        let mut boxed = Box::pin(post);
        let self_ptr = &amp;boxed.name as *const String;
        unsafe { boxed.as_mut().get_unchecked_mut().slug = self_ptr }
        boxed
    }
    fn get_slug(&amp;self) -&gt; String {
        unsafe { &amp;*(self.slug) }.replace(" ", "-").to_lowercase()
    }
    fn get_name(&amp;self) -&gt; &amp;str {
        &amp;self.name
    }
}
</pre>
<p>为了显示数据的值，我们将使用来自<code>Box</code>的<code>as_ref</code>函数:</p>
<pre class="language-rust hljs">impl Display for Post {
    fn fmt(&amp;self, f: &amp;mut std::fmt::Formatter&lt;'_&gt;) -&gt; std::fmt::Result {
        write!(f, 
          "name:`{}` slug:`{}`", 
          self.as_ref().get_name(), self.as_ref().get_slug()
        ).unwrap();
        Ok(())
    }
}
</pre>
<p>以下是我们获取价值的方式:</p>
<pre class="language-rust hljs">#[tokio::main(flavor = "current_thread")]
async fn main() {
    let post1 = Post::new("Article Firstd".into());
    let post2 = Post::new("Article Second".into());
    post1.await;
    post2.await;
}

// Post:::poll name:`Article Firstd` slug:`article-firstd`
// Post:::poll name:`Article Second` slug:`article-second`
</pre>
<h2 id="accessing-data-values-pin-projections">使用管脚投影访问数据值</h2>
<p>引脚投影使我们能够访问一个<code>Pin&lt;P&gt;</code>的内部值(即类型<code>P</code>的值)，同时将它固定在内存中。</p>
<p>要访问一个<code>Pin&lt;P&gt;</code>的内部值，我们可以使用<code>.as_ref()</code>或<code>.as_mut()</code>方法来获取内部值的引用或可变引用。这允许我们像处理常规值一样处理内部值，同时确保它不会被移动。</p>
<p>例如，我们可以创建一个<code>Pin</code>，像这样:</p>
<pre class="language-rust hljs">let mut post1 = Post::new("Article Firstd".into());
</pre>
<p>然后，我们可以使用<code>as_ref</code>来访问内部值:</p>
<pre class="language-rust hljs">println!("post1: {:?} =&gt; {:?}", post1.as_ref().get_name(), post1.as_ref().get_slug());
</pre>
<p>这在我们处理实现了<code>Future</code>特征的嵌套结构时很有用。假设我们想要为我们的<code>post</code>结构实现一些跟踪:</p>
<pre class="language-rust hljs">struct TraceDuration&lt;Fut: Future&gt; {
    start: Option&lt;time::Instant&gt;,
    child: Fut
}
</pre>
<p>我们不能像这样直接使用<code>child</code>:</p>
<pre class="language-rust hljs">impl&lt;Fut: Future&gt; Future for TraceDuration&lt;Fut&gt; {
    type Output = (Fut::Output, Duration);
    fn poll(self: Pin&lt;&amp;mut Self&gt;, cx: &amp;mut Context&lt;'_&gt;) -&gt; Poll&lt;Self::Output&gt; {
        let start = self.start.get_or_insert(time::Instant::now());
        let post_poll = self.child.poll(cx);
        let elapsed = start.elapsed();
        match post_poll {
            Poll::Ready(res) =&gt; Poll::Ready((res, elapsed)),
            Poll::Pending =&gt; Poll::Pending,
        }
    }
}
</pre>
<p>相反，我们需要从<code>self</code>对象中提取该字段，如下所示:</p>
<pre class="language-rust hljs">impl&lt;Fut: Future&gt; Future for TraceDuration&lt;Fut&gt; {
    type Output = (Fut::Output, Duration);
    fn poll(self: Pin&lt;&amp;mut Self&gt;, cx: &amp;mut Context&lt;'_&gt;) -&gt; Poll&lt;Self::Output&gt; {
        let (mut start, child) = unsafe {
            let this = self.get_unchecked_mut();
            (
                Pin::new_unchecked(&amp;mut this.start),
                Pin::new_unchecked(&amp;mut this.child),
            )
        };
        let start = start.get_or_insert(time::Instant::now());
        let post_poll = child.poll(cx);
        let elapsed = start.elapsed();
        match post_poll {
            Poll::Ready(res) =&gt; Poll::Ready((res, elapsed)),
            Poll::Pending =&gt; Poll::Pending,
        }
    }
}
</pre>
<p>幸运的是，有一个名为<code>pin-project</code>的箱子使我们的代码更加简洁，这样我们就不需要手动进行管脚投影了:</p>
<pre class="language-rust hljs">cargo add pin-project
</pre>
<p>下面是我们使用<code>pin-project</code>访问<code>child</code>时代码的样子:</p>
<pre class="language-rust hljs">impl&lt;Fut: Future&gt; Future for TraceDuration&lt;Fut&gt; {
    type Output = (Fut::Output, Duration);
    fn poll(self: Pin&lt;&amp;mut Self&gt;, cx: &amp;mut Context&lt;'_&gt;) -&gt; Poll&lt;Self::Output&gt; {
        let this = self.project();
        let start = this.start.get_or_insert(time::Instant::now());
        let post_poll = this.child.poll(cx);
        let elapsed = start.elapsed();
        match post_poll {
            Poll::Ready(res) =&gt; Poll::Ready((res, elapsed)),
            Poll::Pending =&gt; Poll::Pending,
        }
    }
}
</pre>
<h2 id="conclusion">结论</h2>
<p>通过在异步编程中使用pinning，我们可以确保多个任务访问的数据总是一致的，并且没有数据竞争的情况。</p>
<p>当使用自引用结构和锁定Rust时，要知道有时使用不安全的代码是必要的。一个例子是遵从存储在<code>slug</code>变量中的指针。以这种方式使用点数可能会很危险。如果使用不当，会导致内存安全问题，如数据竞争或空指针取消引用。</p>
<p>理解你的代码的安全级别是非常重要的，并且谨慎地使用不安全的代码。此外，确保结构在被单个或多个任务访问时不会在内存中移动也很重要，否则会导致数据争用或未定义的行为。</p><div class="code-block code-block-29">
<div class="blog-plug inline-plug rust-plug"><h2><a href="https://lp.logrocket.com/blg/rust-signup" target="_blank">log rocket</a>:Rust应用的web前端的全面可见性</h2><p>调试Rust应用程序可能很困难，尤其是当用户遇到难以重现的问题时。如果您对监控和跟踪Rust应用程序的性能、自动显示错误、跟踪缓慢的网络请求和加载时间感兴趣，</p><a href="https://lp.logrocket.com/blg/rust-signup" target="_blank">try LogRocket</a><p>. </p><a class="signup" href="https://lp.logrocket.com/blg/rust-signup" target="_blank" rel="noopener noreferrer"><img class="alignnone size-full wp-image-46 jetpack-lazy-image" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/><noscript><img data-lazy-fallback="1" class="alignnone size-full wp-image-46" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/></noscript></a><p>LogRocket 就像是网络和移动应用程序的DVR，记录你的Rust应用程序上发生的一切。您可以汇总并报告问题发生时应用程序的状态，而不是猜测问题发生的原因。LogRocket还可以监控应用的性能，报告客户端CPU负载、客户端内存使用等指标。</p><p>现代化调试Rust应用的方式— <a class="signup" href="https://lp.logrocket.com/blg/rust-signup" target="_blank" rel="noopener noreferrer">开始免费监控</a>。</p></div>


</div>

<p class="clearfix"/>
 <p class="clearfix"/>
</article>

</div>    
</body>
</html>
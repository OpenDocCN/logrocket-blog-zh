<html>
<head>
<title>Building Rust microservices with Apache Kafka - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>用Apache Kafka构建Rust微服务</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/building-rust-microservices-apache-kafka/#0001-01-01">https://blog.logrocket.com/building-rust-microservices-apache-kafka/#0001-01-01</a></blockquote><div><article class="article-post">
<p><a href="https://kafka.apache.org/" target="_blank" rel="noopener"> Apache Kafka </a>是一个事件流平台，允许软件应用程序之间进行有效的通信。这是将微服务等小型应用连接在一起的绝佳选择。</p>
<p>在本文中，您将了解如何使用Kafka的<a href="https://www.rust-lang.org/" target="_blank" rel="noopener"> Rust </a>构建微服务。我们将涵盖:</p>

<p>你可以在<a href="https://github.com/TheGhoulRe/rust-microservices" target="_blank" rel="noopener">这个GitHub repo </a>里看到最终的项目。</p>
<h2 id="prerequisites">先决条件</h2>
<p>按照这篇文章，你需要在你的系统中安装Rust和Rust的基本知识。</p>
<h2 id="microservices">什么是微服务？</h2>
<p>微服务是小型、独立的应用程序，它们执行特定的任务，这些任务对于复杂应用程序的解耦组件和促进分布式应用程序都很有用。</p>
<p>把微服务想象成一个更大尺度上的物体。与对象类似，微服务是独立的，可以重用。然而，两者之间的显著区别在于它们返回数据的位置。对象直接获取和返回数据，而微服务将数据返回到池中。</p>
<p>微服务允许开发者用不同的编程语言构建应用。微服务中的错误很少会导致整个应用程序崩溃。</p>
<p><img data-attachment-id="132797" data-permalink="https://blog.logrocket.com/building-rust-microservices-apache-kafka/attachment/graphic-rust-microservice-kafka/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/09/graphic-rust-microservice-kafka.png" data-orig-size="512,291" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Rust microservice in Kafka" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/09/graphic-rust-microservice-kafka-300x171.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/09/graphic-rust-microservice-kafka.png" decoding="async" class="aligncenter wp-image-132797 size-full jetpack-lazy-image" src="../Images/2d82da7cb33c168aff41e82537d12342.png" alt="Rust microservice in Kafka chart" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2022/09/graphic-rust-microservice-kafka.png 512w, https://blog.logrocket.com/wp-content/uploads/2022/09/graphic-rust-microservice-kafka-300x171.png 300w" data-lazy-sizes="(max-width: 512px) 100vw, 512px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2022/09/graphic-rust-microservice-kafka.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/09/graphic-rust-microservice-kafka.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="132797" data-permalink="https://blog.logrocket.com/building-rust-microservices-apache-kafka/attachment/graphic-rust-microservice-kafka/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/09/graphic-rust-microservice-kafka.png" data-orig-size="512,291" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Rust microservice in Kafka" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/09/graphic-rust-microservice-kafka-300x171.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/09/graphic-rust-microservice-kafka.png" decoding="async" loading="lazy" class="aligncenter wp-image-132797 size-full" src="../Images/2d82da7cb33c168aff41e82537d12342.png" alt="Rust microservice in Kafka chart" srcset="https://blog.logrocket.com/wp-content/uploads/2022/09/graphic-rust-microservice-kafka.png 512w, https://blog.logrocket.com/wp-content/uploads/2022/09/graphic-rust-microservice-kafka-300x171.png 300w" sizes="(max-width: 512px) 100vw, 512px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/09/graphic-rust-microservice-kafka.png"/></noscript>
<p>卡夫卡是什么？</p>
<h2 id="kafka">Kafka是一个用于读写数据的事件流平台，可以轻松连接微服务。要了解更多关于Kafka的信息，请查看这个<a href="https://blog.logrocket.com/apache-kafka-real-time-data-streaming-app/" target="_blank" rel="noopener"> Kafka实时数据流应用教程</a>。</h2>
<p>在我们深入讨论这个平台之前，我们需要熟悉一些Kafka术语。</p>
<p>事件:在卡夫卡那里，数据被称为事件</p>
<ul>
<li>主题:主题是用于组织事件的标识符。生产者和消费者可以实时读写一个主题</li>
<li>生产者:Kafka使用生产者将事件发布到一个主题</li>
<li>消费者:这些从一个主题中读取事件</li>
<li>Broker:Kafka中的服务器被称为broker</li>
<li>集群:几个代理一起工作形成一个集群，防止事件丢失。这一点非常重要，因为事件和主题可以在一个或多个代理之间复制</li>
<li><img data-attachment-id="132799" data-permalink="https://blog.logrocket.com/building-rust-microservices-apache-kafka/attachment/kafka-broker-consumer-producer-graphic/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/09/kafka-broker-consumer-producer-graphic.png" data-orig-size="512,136" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Kafka brokers, consumer, and producers" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/09/kafka-broker-consumer-producer-graphic-300x80.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/09/kafka-broker-consumer-producer-graphic.png" decoding="async" class="aligncenter wp-image-132799 size-full jetpack-lazy-image" src="../Images/9fe1b7cad6358ac9044e8017b7915ce7.png" alt="Kafka brokers, consumer, and producers graphic" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2022/09/kafka-broker-consumer-producer-graphic.png 512w, https://blog.logrocket.com/wp-content/uploads/2022/09/kafka-broker-consumer-producer-graphic-300x80.png 300w" data-lazy-sizes="(max-width: 512px) 100vw, 512px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2022/09/kafka-broker-consumer-producer-graphic.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/09/kafka-broker-consumer-producer-graphic.png"/></li>
</ul>
<p>卡夫卡入门</p><noscript><img data-lazy-fallback="1" data-attachment-id="132799" data-permalink="https://blog.logrocket.com/building-rust-microservices-apache-kafka/attachment/kafka-broker-consumer-producer-graphic/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/09/kafka-broker-consumer-producer-graphic.png" data-orig-size="512,136" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Kafka brokers, consumer, and producers" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/09/kafka-broker-consumer-producer-graphic-300x80.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/09/kafka-broker-consumer-producer-graphic.png" decoding="async" loading="lazy" class="aligncenter wp-image-132799 size-full" src="../Images/9fe1b7cad6358ac9044e8017b7915ce7.png" alt="Kafka brokers, consumer, and producers graphic" srcset="https://blog.logrocket.com/wp-content/uploads/2022/09/kafka-broker-consumer-producer-graphic.png 512w, https://blog.logrocket.com/wp-content/uploads/2022/09/kafka-broker-consumer-producer-graphic-300x80.png 300w" sizes="(max-width: 512px) 100vw, 512px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/09/kafka-broker-consumer-producer-graphic.png"/></noscript>
<p>要继续阅读本文，您需要设置您的Kafka broker。注意，您将在您的系统上使用一个本地代理。除了本地代理，Kafka还提供了在云中或远程系统上使用代理的选项。</p>
<h2 id="getting-started-kafka">要在您的系统上设置Kafka，请按照下列步骤操作:</h2>
<p>首先，在这里下载最新的Kafka版本<a href="https://www.apache.org/dyn/closer.cgi?path=/kafka/3.2.1/kafka_2.13-3.2.1.tgz" target="_blank" rel="noopener">，解压压缩文件。之后，在你的终端打开解压后的文件夹，用下面的命令启动</a><a href="https://kafka.apache.org/documentation/#zk" target="_blank" rel="noopener"> ZooKeeper </a>服务器:</p>
<p>然后，在解压缩的文件夹中打开另一个终端会话，并启动Kafka broker:</p>
<p>卡夫卡经纪人需要一个活跃的动物园管理员才能正常工作。ZooKeeper维护代理，没有它，代理会生成错误消息。</p>
<pre class="language-bash hljs">$ bin/zookeeper-server-start.sh config/zookeeper.properties</pre>
<p>设置Kafka主题、生产者和消费者</p>
<pre class="language-bash hljs">$ bin/kafka-server-start.sh config/server.properties</pre>
<p>接下来，让我们通过设置主题、生产者和消费者来组织Kafka broker中发布的事件。</p>
<h2 id="setting-up-Kafka-topics-producers-consumers">要在本地服务器中创建主题，请运行以下命令:</h2>
<p>第一个命令在控制台中启动一个消费者，<code>--topic topic-name</code>告诉消费者从<code>topic-name</code>中读取。<code>--bootstrap-server localhost:9092</code>告诉卡夫卡在<code>localhost:9092</code>连接到你的本地服务器。</p>
<p><code>--from-beginning</code>告诉消费者阅读最早发布的所有事件。你可以用<code>--offset earliest</code>代替<code>--from-beginning</code>来达到同样的效果。如果您希望消费者只收听新事件，请使用<code>--offset latest</code>。</p>
<pre class="language-bash hljs">$ bin/kafka-topics.sh --create --topic topic-name --bootstrap-server localhost:9092</pre>
<p>Kafka提供了一个可以在终端中运行的消费者和生产者:</p>
<p>上面的命令在控制台中启动一个生成器，生成器将事件发布到由<code>--topic topic-name</code>指定的<code>topic-name</code>。生产者连接到您在<code>localhost:9092</code>的本地服务器，并由<code>--bootstrap-server localhost:9092</code>指定。</p>
<p>制造铁锈消费者和生产者</p>
<pre class="language-bash hljs"># console consumer reading from "topic-name"
$ bin/kafka-console-consumer.sh --topic topic-name --from-beginning --bootstrap-server localhost:9092

# console producer publishing to "topic-name"
$ bin/kafka-console-producer.sh --topic topic-name --bootstrap-server localhost:9092</pre>
<p>现在，您已经看到了控制台中的生产者和消费者，我将向您展示如何使用Rust构建Kafka生产者和消费者。用Rust构建的基于Kafka的微服务通常有一个或多个生产者和消费者。我们开始吧！</p>
<h2 id="creating-rust-consumers-producers">首先，您需要使用以下命令创建一个新的Rust项目:</h2>
<p>接下来，将卡夫卡图书馆添加到<code>Cargo.toml</code>:</p>
<p>现在我们已经添加了Kafka库，我们可以构建项目来获取它的依赖项:</p>
<pre class="language-bash hljs">$ cargo new kafka_consumer</pre>
<p>然后将这段代码粘贴到<code>src/main.rs</code>:</p>
<pre class="language-toml hljs">[dependencies]
kafka = "0.9"</pre>
<p>我们上面创建的消费者读取发布到<code>topic-name</code>主题的事件，并将事件消息打印到控制台。下面更详细地介绍了它的工作原理:</p>
<pre class="language-bash hljs">$ cargo build</pre>
<p>首先，我们在第6行初始化消费者将要连接的主机列表(在本例中是<code>localhost:9092</code>)。</p>
<pre class="language-rust hljs">use kafka::consumer::{Consumer, FetchOffset};
use std::str;

fn main () {

 let hosts = vec!["localhost:9092".to_owned()];
 
 let mut consumer =
   Consumer::from_hosts(hosts)
     .with_topic("topic-name".to_owned())
     .with_fallback_offset(FetchOffset::Latest)
     .create()
     .unwrap();

 loop {
   for ms in consumer.poll().unwrap().iter() {
     for m in ms.messages() {
       // If the consumer receives an event, this block is executed
       println!("{:?}", str::from_utf8(m.value).unwrap());
     }

     consumer.consume_messageset(ms).unwrap();
   }

   consumer.commit_consumed().unwrap();
 }
}</pre>
<p>接下来，从第8行到第13行，我们初始化一个连接到<code>topic-name</code>主题(第10行)的消费者，并开始从最近发布的事件中读取事件:</p>
<p>最后，我们创建一个无限循环来监听发布到<code>topic-name</code>的事件:</p>
<pre class="language-rust hljs"> let hosts = vec!["localhost:9092".to_owned()];</pre>
<p>现在，我们已经成功地创建了消费者，让我们看看创建生产者的下一步。</p>
<pre class="language-rust hljs"> let mut consumer =
   Consumer::from_hosts(hosts)
     .with_topic("topic-name".to_owned())
     .with_fallback_offset(FetchOffset::Latest)
     .create()
     .unwrap();</pre>
<p>首先，使用以下命令创建一个新的Rust项目:</p>
<pre class="language-rust hljs"> loop {
   for ms in consumer.poll().unwrap().iter() {
     for m in ms.messages() {
       // convert message from bytes to string
       println!("{:?}", str::from_utf8(m.value).unwrap());
     }

     consumer.consume_messageset(ms).unwrap();
   }

   consumer.commit_consumed().unwrap();
 }</pre>
<p>然后将卡夫卡图书馆添加到<code>Cargo.toml</code>:</p>
<p>构建项目以获取其依赖项:</p>
<pre class="language-bash hljs">$ cargo new kafka_producer</pre>
<p>然后，将这段代码粘贴到<code>src/main.rs</code>:</p>
<pre class="language-toml hljs">[dependencies]
kafka = "0.9"</pre>
<p>这个想法是创建一个生产者，发送数字<code>0</code>到<code>9</code>到<code>topic-name</code>主题。下面是它的工作原理:</p>
<pre class="language-bash hljs">$ cargo build</pre>
<p>首先，我们定义一个我们正在连接的Kafka服务器的列表(<code>localhost:9092</code>)。</p>
<pre class="language-rust hljs">use kafka::producer::{Producer, Record};

fn main() {
 let hosts = vec!["localhost:9092".to_owned()];

 let mut producer =
   Producer::from_hosts(hosts)
     .create()
     .unwrap();

 for i in 0..10 {
   let buf = format!("{i}");
   producer.send(&amp;Record::from_value("topic-name", buf.as_bytes())).unwrap();
   println!("Sent: {i}");
 }
}</pre>
<p>注意，<code>Producer::from_hosts</code>函数初始化了生产者。初始化的生产者连接到本地Kafka服务器(<code>localhost:9092</code>)。</p>
<p>我们创建了一个从0到9的循环，并将每个数字发送到<code>topic-name</code>主题。</p>
<pre class="language-rust hljs">let hosts = vec!["localhost:9092".to_owned()];</pre>
<p>现在我们已经设置了消费者和生产者，让我们运行他们。消费者监听在<code>topic-name</code>中发布的事件，生产者项目将事件发布到<code>topic-name.</code>，在发布事件之前拥有一个活跃的消费者可以确保事件被实时消费。</p>
<pre class="language-rust hljs">let mut producer =
   Producer::from_hosts(hosts)
     .create()
     .unwrap();</pre>
<p>用Kafka构建Rust微服务</p>
<pre class="language-rust hljs">for i in 0..10 {
   let buf = format!("{i}");
   producer.send(&amp;Record::from_value("topic-name", buf.as_bytes())).unwrap();
   println!("Sent: {i}");
 }
}</pre>
<p>在本节中，我们将构建一个微服务来存储和删除文本。这个微服务是通过发送描述添加或删除文本的事件来操作的。该事件将是一个JSON字符串，带有描述其动作的动作键和提供必要数据的值键。</p>
<h2 id="building-rust-microservice-kafka">下图展示了微服务如何添加文本:</h2>
<p><img data-attachment-id="132978" data-permalink="https://blog.logrocket.com/building-rust-microservices-apache-kafka/attachment/diagram-microservice-adding-text-2/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/09/diagram-microservice-adding-text.png" data-orig-size="730,222" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="diagram-microservice-adding-text" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/09/diagram-microservice-adding-text-300x91.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/09/diagram-microservice-adding-text.png" decoding="async" class="aligncenter size-full wp-image-132978 jetpack-lazy-image" src="../Images/c02a257f2b30ddbbc69bba5ea7a7ed28.png" alt="Microservice graphic for adding text" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2022/09/diagram-microservice-adding-text.png 730w, https://blog.logrocket.com/wp-content/uploads/2022/09/diagram-microservice-adding-text-300x91.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2022/09/diagram-microservice-adding-text.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/09/diagram-microservice-adding-text.png"/></p>
<p>如图所示，我们的微服务从actions主题读取要执行的操作，然后将文本列表发布到texts主题。现在我们有了一些背景，让我们来建立这个微服务。</p>
<p>首先，让我们创建一个新项目:</p><noscript><img data-lazy-fallback="1" data-attachment-id="132978" data-permalink="https://blog.logrocket.com/building-rust-microservices-apache-kafka/attachment/diagram-microservice-adding-text-2/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/09/diagram-microservice-adding-text.png" data-orig-size="730,222" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="diagram-microservice-adding-text" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/09/diagram-microservice-adding-text-300x91.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/09/diagram-microservice-adding-text.png" decoding="async" loading="lazy" class="aligncenter size-full wp-image-132978" src="../Images/c02a257f2b30ddbbc69bba5ea7a7ed28.png" alt="Microservice graphic for adding text" srcset="https://blog.logrocket.com/wp-content/uploads/2022/09/diagram-microservice-adding-text.png 730w, https://blog.logrocket.com/wp-content/uploads/2022/09/diagram-microservice-adding-text-300x91.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/09/diagram-microservice-adding-text.png"/></noscript>
<p>使用下面的命令将下列依赖项添加到<code>Cargo.toml </code>:</p>
<p>使用以下命令构建项目:</p>
<pre class="language-bash hljs">$ cargo new texts-microservice</pre>
<p>之后，我们将创建模块，分别处理生产者、消费者和文本。在<code>src</code>中，这些模块的文件名分别是<code>my_consumer.rs</code>、<code>my_producer.rs</code>和<code>texts.rs</code>。</p>
<pre class="language-toml hljs">[dependencies]
kafka = "0.9"
serde_json = "1.0.85"</pre>
<p>现在，按照以下步骤构建微服务:</p>
<pre class="language-bash hljs">$ cargo build</pre>
<p>首先，我们需要初始化模块，因为我们正在将微服务分割成模块。因此，将这个代码块添加到<code>main.rs</code>文件中:</p>
<p>之后，在<code>main.rs</code>中创建<code>main</code>函数:</p>
<p>接下来，在<code>main.rs</code>的<code>main</code>函数中定义您正在连接微服务的Kafka服务器:</p>
<pre class="language-rust hljs">mod my_consumer;
mod my_producer;
mod texts;

use my_consumer::MyConsumer;
use my_producer::MyProducer;
use texts::Texts;</pre>
<p>现在，用<code>main.rs</code>的<code>main</code>函数中的以下代码行初始化文本、消费者和生产者模块:</p>
<pre class="language-rust hljs">fn main() { 
}</pre>
<p>接下来，创建一个循环来侦听使用者收到的事件:</p>
<pre class="language-rust hljs">  let hosts = vec![ "localhost:9092".to_string() ];</pre>
<p>之后，用下面这行代码从前面代码块的循环中检索数据:</p>
<pre class="language-rust hljs">  let mut texts = Texts::new();
  let mut consumer = MyConsumer::new( hosts.clone(), "actions".to_string() );
  let mut producer = MyProducer::new( hosts );</pre>
<p>现在，从事件数据中提取要对文本执行的操作，并在前面的代码块后加上这一行:</p>
<pre class="language-rust hljs">  loop {
    for ms in consumer.consume_events().iter() {
      for m in ms.messages() {

      }
      consumer.consume_messageset(ms);
    }
    consumer.commit_consumed();
  }</pre>
<p>之后，使用<code>if</code>、<code>if/else</code>、<code>else</code>块执行<code>event_data["action"]</code>指定的动作:</p>
<pre class="language-rust hljs">        let event_data = MyConsumer::get_event_data(m);</pre>
<p>最后，将文本转换为JSON字符串，并在循环结束时将它发送给带有生产者的文本主题:</p>
<pre class="language-rust hljs">        let action = event_data["action"].to_string();</pre>
<p>最后，您的<code>main.rs</code>文件应该是这样的:</p>
<pre class="language-rust hljs">        if action == "\"add\"" {
          texts.add_text( event_data["value"].to_string() );

        } else if action == "\"remove\"" {
          let index = event_data["value"].to_string().parse::&lt;usize&gt;().unwrap();
          texts.remove_text( index );

        } else {
          println!("Invalid action");
        }</pre>
<p>现在，在<code>src</code>中创建一个<code>my_consumer.rs</code>文件，并将以下代码粘贴到其中:</p>
<pre class="language-rust hljs">        producer.send_data_to_topic( "texts", texts.to_json() );</pre>
<p>此外，创建一个包含以下代码的<code>my_producer.rs</code>文件:</p>
<pre class="language-rust hljs">mod my_consumer;
mod my_producer;
mod texts;

use my_consumer::MyConsumer;
use my_producer::MyProducer;
use texts::Texts;

fn main() { 
  let hosts = vec![ "localhost:9092".to_string() ];

  let mut texts = Texts::new();
  let mut consumer = MyConsumer::new( hosts.clone(), "actions".to_string() );
  let mut producer = MyProducer::new( hosts );
  // put here to show that the microservice has started
  println!("Started...");

  loop {
    for ms in consumer.consume_events().iter() {
      for m in ms.messages() {

        // when the consumer receives an event, this block is executed 
        let event_data = MyConsumer::get_event_data(m);
        let action = event_data["action"].to_string();
        
        if action == "\"add\"" {
          texts.add_text( event_data["value"].to_string() );

        } else if action == "\"remove\"" {
          let index = event_data["value"].to_string().parse::&lt;usize&gt;().unwrap();
          texts.remove_text( index );

        } else {
          println!("Invalid action");
        }

        producer.send_data_to_topic( "texts", texts.to_json() );
      }
      consumer.consume_messageset(ms);
    }
    consumer.commit_consumed();
  }
}</pre>
<p>最后，创建一个<code>texts.rs</code>文件，并将以下内容粘贴到其中:</p>
<pre class="language-rust hljs">use kafka::consumer::{Consumer, FetchOffset, MessageSets, MessageSet, Message};
use std::str;
use serde_json::Value;

pub struct MyConsumer {
 consumer: Consumer
}

impl MyConsumer {

 pub fn new (hosts: Vec&lt;String&gt;, topic: String) -&gt; Self {
   Self {
     consumer: Consumer::from_hosts(hosts)
                 .with_topic(topic)
                 .with_fallback_offset(FetchOffset::Latest)
                 .create()
                 .unwrap()
   }
 }

 pub fn get_event_data (m: &amp;Message) -&gt; Value {
   let event = str::from_utf8(m.value).unwrap().to_string();
   serde_json::from_str(&amp;event).unwrap()
 }

 pub fn consume_events(&amp;mut self) -&gt; MessageSets {
   self.consumer.poll().unwrap()
 }

 pub fn consume_messageset(&amp;mut self, ms: MessageSet) {
   self.consumer.consume_messageset(ms).unwrap();
 }

 pub fn commit_consumed(&amp;mut self) {
   self.consumer.commit_consumed().unwrap();
 }

}</pre>
<p>构建项目后，我们需要运行并测试它。</p>
<pre class="language-rust hljs">use kafka::producer::{Producer, Record};

pub struct MyProducer {
  producer: Producer
}

impl MyProducer {

  pub fn new( hosts: Vec&lt;String&gt; ) -&gt; Self {
    let producer =
      Producer::from_hosts( hosts )
        .create()
        .unwrap();
    
    Self {
      producer: producer
    }
  }

  pub fn send_data_to_topic(&amp;mut self, topic: &amp;str, data: String ) {
    let record = Record::from_value( topic, data.as_bytes() );
    self.producer.send(&amp;record).unwrap();
  }

}</pre>
<p>首先，创建文本和操作主题:</p>
<pre class="language-rust hljs">use serde_json::json;

pub struct Texts {
  texts: Vec&lt;String&gt;
}

impl Texts {

  pub fn new() -&gt; Self {
    Self {
      texts: vec![]
    }
  }

  pub fn add_text(&amp;mut self, text: String) {
    self.texts.push(text);
  }

  pub fn remove_text(&amp;mut self, index: usize) {
    self.texts.remove( index );
  }

  pub fn to_json(&amp;self) -&gt; String {
    json!(&amp;self.texts).to_string()
  }
}</pre>
<p>接下来，设置控制台消费者主题<code>texts</code>:</p>
<p>为主题操作设置一个生成器。</p>
<pre class="language-bash hljs"># create texts topic
$ bin/kafka-topics.sh --create --topic texts --bootstrap-server localhost:9092

# create actions topic
$ bin/kafka-topics.sh --create --topic actions --bootstrap-server localhost:9092</pre>
<p>现在让我们用以下代码运行项目:</p>
<pre class="language-bash hljs">$ bin/kafka-console-consumer.sh --topic texts --from-beginning --bootstrap-server localhost:9092</pre>
<p>然后，给制作人写动作:</p>
<pre class="language-bash hljs">$ bin/kafka-console-producer.sh --topic actions --bootstrap-server localhost:9092</pre>
<p>最后，让我们看看消费者控制台中每个事件的结果:</p>
<pre class="language-bash hljs">$ cargo run</pre>
<p>结论</p>
<pre class="prettyprint">&gt; { "action": "add", "value": "first text" }
&gt; { "action": "add", "value": "second text" }
&gt; { "action": "remove", "value": 1 }
&gt; { "action": "add", "value": "third text" }</pre>
<p>在本文中，我们介绍了如何用Rust创建一个基本的微服务。虽然单个微服务简单且专注于一项任务，但多个或更多高级微服务可以形成易于维护的分布式复杂应用，处理数据库、实时计算、物联网、实时数据收集和欺诈检测。</p>
<pre class="prettyprint">[ "first text" ]
[ "first text", "second text" ]
[ "first text" ]
[ "first text", "third text" ]
</pre>
<h2><a href="https://lp.logrocket.com/blg/rust-signup" target="_blank">log rocket</a>:Rust应用的web前端的全面可见性</h2>
<p>调试Rust应用程序可能很困难，尤其是当用户遇到难以重现的问题时。如果您对监控和跟踪Rust应用程序的性能、自动显示错误、跟踪缓慢的网络请求和加载时间感兴趣，</p><div class="code-block code-block-29">
<div class="blog-plug inline-plug rust-plug"><h2>. </h2><p>LogRocket 就像是网络和移动应用程序的DVR，记录你的Rust应用程序上发生的一切。您可以汇总并报告问题发生时应用程序的状态，而不是猜测问题发生的原因。LogRocket还可以监控应用的性能，报告客户端CPU负载、客户端内存使用等指标。</p><a href="https://lp.logrocket.com/blg/rust-signup" target="_blank">try LogRocket</a><p>现代化调试Rust应用的方式— <a class="signup" href="https://lp.logrocket.com/blg/rust-signup" target="_blank" rel="noopener noreferrer">开始免费监控</a>。</p><a class="signup" href="https://lp.logrocket.com/blg/rust-signup" target="_blank" rel="noopener noreferrer"><img class="alignnone size-full wp-image-46 jetpack-lazy-image" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/><noscript><img data-lazy-fallback="1" class="alignnone size-full wp-image-46" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/></noscript></a><p><a href="https://lp.logrocket.com/blg/rust-signup" target="_blank" rel="noopener noreferrer">LogRocket</a> is like a DVR for web and mobile apps, recording literally everything that happens on your Rust app. Instead of guessing why problems happen, you can aggregate and report on what state your application was in when an issue occurred. LogRocket also monitors your app’s performance, reporting metrics like client CPU load, client memory usage, and more.</p><p>Modernize how you debug your Rust apps — <a class="signup" href="https://lp.logrocket.com/blg/rust-signup" target="_blank" rel="noopener noreferrer">start monitoring for free</a>.</p></div>


</div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>